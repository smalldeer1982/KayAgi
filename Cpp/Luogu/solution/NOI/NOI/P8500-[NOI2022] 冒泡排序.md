# [NOI2022] 冒泡排序

## 题目背景

最近，小 Z 对冒泡排序产生了浓厚的兴趣。

下面是冒泡排序的伪代码：

```
输入: 一个长度为 n 的序列 a[1...n]
输出: a 从小到大排序后的结果
for i = 1 to n do:
    for j = 1 to n - 1 do
        if (a[j] > a[j + 1])
            交换 a[j] 与 a[j + 1] 的值
```

冒泡排序的交换次数被定义为在排序时**进行交换的次数**，也就是上面冒泡排序伪代码**第六行**的执行次数。他希望找到一个交换次数尽量少的序列。

## 题目描述

小 Z 所研究的序列均由非负整数构成。它的长度为 $n$，且必须满足 $m$ 个附加条件。其中第 $i$ 个条件为：下标在 $[L_i, R_i]$ 中的数，即 $a_{L_i}, a_{L_{i+1}},\dots,a_{R_i}$ 这些数，其最小值**恰好为 $\boldsymbol{V_i}$**。

他知道冒泡排序时常会超时。所以，他想要知道，在所有满足附加条件的序列中，进行冒泡排序的交换次数的最少值是多少。

## 说明/提示

**【样例解释 \#1】**

这组数据的约束条件为 $a_1 = 2022, \min\{a_2, a_3\} = 39$。

若 $a_2 = 39$，且 $39 \leq a_3 < 2022$，则冒泡排序只有第一轮有交换操作，这一轮交换了 $a_1, a_2$ 和 $a_2, a_3$，总交换次数为 $2$。

若 $a_2 = 39$，且 $a_3 \geq 2022$，则冒泡排序只有第一轮有交换操作，这一轮仅仅交换 $a_1, a_2$，总交换次数为 $1$。

若 $a_3 = 39$，且 $39 < a_2 < 2022$，则冒泡排序算法第一轮交换 $a_1, a_2$ 和 $a_2, a_3$，第二轮交换 $a_1, a_2$。总交换次数为 $3$。

若 $a_3 = 39$，且 $a_2 \geq 2022$，则冒泡排序算法第一轮交换 $a_2, a_3$，第二轮交换 $a_1, a_2$。总交换次数为 $2$。

因此，交换次数的最小值为 $1$。

----

**【样例 \#2】**

见附件中的 `bubble/bubble2.in` 与 `bubble/bubble2.ans`。

----

**【样例 \#3】**

见附件中的 `bubble/bubble3.in` 与 `bubble/bubble3.ans`。

这个样例满足测试点 $8 \sim 10$ 的条件。

----

**【样例 \#4】**

见附件中的 `bubble/bubble4.in` 与 `bubble/bubble4.ans`。

这个样例满足测试点 $13 \sim 14$ 的条件。

----

**【样例 \#5】**

见附件中的 `bubble/bubble5.in` 与 `bubble/bubble5.ans`。

这个样例满足测试点 $15 \sim 16$ 的条件。

----

**【样例 \#6】**

见附件中的 `bubble/bubble6.in` 与 `bubble/bubble6.ans`。

这个样例满足测试点 $23 \sim 25$ 的条件。

----

**【数据范围】**

本题共 $25$ 个测试点。全部测试点满足：$1 \leq T \leq 1000$，$1 \leq \sum n, \sum m \leq 10^6$，$1 \leq L_i \leq R_i \leq n$，$0 \leq V_i \leq 10^9$。

其中 $\sum n, \sum m$ 分别表示所有测试点的 $n$ 的总和和 $m$ 的总和。$\sum n^2, \sum m^2, \sum n^3, \sum m^3$ 的含义类似。

| 测试点          | 数据范围                                                   | 特殊性质         |
|:------------:|:------------------------------------------------------:|:------------:|
| $1 \sim 4$   | $n,m \leq 7$，且最多 $2$ 组数据不满足 $n, m \leq 5$              |              |
| $5 \sim 7$   | $n,m \leq 17$，且最多 $3$ 组数据不满足 $n, m \leq 9$             | A |
| $8 \sim 10$  | $n,m \leq 100$，$\sum n^3,\sum m^3 \leq 4 \times 10^7$  | A |
| $11 \sim 12$ | $n,m \leq 2000$，$\sum n^2,\sum m^2 \leq 4 \times 10^7$ | A |
| $13 \sim 14$ | $n,m \leq 2000$，$\sum n^2,\sum m^2 \leq 4 \times 10^7$ | B |
| $15 \sim 16$ | $n,m \leq 2000$，$\sum n^2,\sum m^2 \leq 4 \times 10^7$ | C |
| $17 \sim 18$ | $n,m \leq 2000$，$\sum n^2,\sum m^2 \leq 4 \times 10^7$ |              |
| $19$         | $\sum n,\sum m \leq 10^6$                              | A |
| $20$         | $\sum n,\sum m \leq 10^6$                              | B |
| $21 \sim 22$ | $\sum n,\sum m \leq 10^6$                              | C |
| $23 \sim 25$ | $\sum n,\sum m \leq 10^6$                              |              |

特殊性质 A：对于 $1 \leq i \leq m$，$0 \leq V_i \leq 1$。  
特殊性质 B：对于 $1 \leq i \leq m$，$L_i = R_i$。  
特殊性质 C：输入给出的 $m$ 个区间 $[L_i, R_i]$ 两两不相交。

----

**【提示】**

本题的部分测试点输入量较大。我们建议你使用较为快速的读入方式。

## 样例 #1

### 输入

```
1
3 2
1 1 2022
2 3 39
```

### 输出

```
1
```

# 题解

## 作者：gyh20 (赞：36)

题解将按照 A,B,C 一步步的深入。

这里称最终的数列为 $a$，限制为 $L_i,R_i,V_i$，下面视 $n,m$ 同阶。

先说两个所有部分都要用的性质：

$1.$ 存在一种最优情况，使得最终数列中的所有数都为输入的 $L_i,R_i,V_i$ 其中一个的 $V_i$。如果不是，将这个区间的数全体调整即可。

$2.$ 若存在 $i<j,a_i>a_j$，且交换 $a_i,a_j$ 后合法，则交换后一定更优。证明显然。

先考虑 A：

此时的限制有两种：区间全为 $1$，称其为 $1$ 类限制，和区间不全为 $1$，称其为 $2$ 类限制。

根据性质 $2$，若存在相邻的 $10$ 且可以交换一定更优，所以对于每一个 $0$ 的连续极长区间，都有其的第一个位置是某个 $2$ 类限制的 $L$，或其前一个位置是一个 $1$ 类限制的 $R$。

将所有的 $1$ 类限制求一个区间覆盖。

将所有的 $2$ 类限制按照 $L$ 从大到小排序。在这样的顺序下，我们可以贪心，若区间内没有已经钦定为 $0$ 的位置，则把区间内第一个没有被 $1$ 类区间覆盖的位置强制钦定为 $0$，因为若该位置不为 $0$ 且后面有 $0$，可以直接交换。

做了这样的操作之后，每一个限制都已经合法了，于是现在的情况就是一些位置强制为 0/1，剩下位置没有限制，根据性质 $2$，那么剩下的位置必定是一个前缀为 $0$，枚举一下分界线，中途涉及到的操作做到 $O(n\log n)$ 是容易的。

B:

相当于有一些单点的限制，无解的情况可以轻易判掉。

然后发现一个神奇的性质，局部最优解构成了全局最优解，即，对于每个没有限制的位置单独考虑，其位置越靠后，最终选的值会越大。即，对于每个点，只考虑其于已经被限制的点的贡献来选出一个最优解，那么这些位置的上的值内部不存在逆序对。用线段树容易 $O(n\log n)$。证明很容易理解，实在不行把维护单点最优解的线段树操作拿出来很容易理解。

C:

首先根据性质 $2$，区间最小值一定在区间的第一个。

然后可以近似看作 B，在 B 的基础上，多了一些 $a_i\geq k_i$ 的限制。

这里先说做法，和 B 做一模一样的操作，从前往后，找局部最优解即线段树上 $\geq k_i$ 的位置上的最小值，若有多个选最靠前的。

为什么这样是正确的呢？首先选更大的位置显然是不优的，因为是从前往后的，选的越小对后面的位置影响越小，如果当前选的为 $x$，假设存在某个更优的位置是 $y$，那么直接将最终序列当前位置之后的所有值在 $[y,x]$ 之间的数变为 $x$ 即可，这样显然是合法并且不劣的。

正解：

还是尝试将问题转化为限制某些位置的值 $=V_i$，某些位置的值 $\geq V_i$，后者即为被覆盖的位置取一个 $\max$。

若两个区间相交且 $V$ 不同，那么可以缩短 $V$ 小的一个区间，看成不相交，若 $V$ 相同，可以直接用 A 性质来搞出对单点的限制。

于是最终的流程即为，从大到小枚举 $x$，对所有的 $V_i=x$ 的位置用 A 中的做法进行标记，然后将区间内的所有位置删掉，之后不能被标记，若任意时刻找不到合法的标记输出 $-1$，这部分可以用并查集。

然后对于已经限制的点内部用一个树状数组统计逆序对，剩下的用一个线段树动态维护。总复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read(){
	re int t=0;re char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();
	return t;
}
int t,n,m,a[1000002],A,B,L[1000002],R[1000002],V[1000002],W[1000002],mn[4000002],mnp[4000002],tg[4000002],fa[1000002],V1[1000002],V2[1000002],c[1000002],ans1,ans2;
char s[1000002];
inline void add(re int x){for(;x;x^=x&(-x))++c[x];}
inline int ask(re int x,re int s=0){for(;x<=m;x+=x&(-x))s+=c[x];return s;} 
inline void build(re int p,re int l,re int r){
	tg[p]=mn[p]=0,mnp[p]=l;
	if(l==r)return;
	re int mid=l+r>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r); 
}
inline void pu(re int p){
	mn[p]=min(mn[p<<1],mn[p<<1|1]);
	if(mn[p]==mn[p<<1])mnp[p]=mnp[p<<1];
	else mnp[p]=mnp[p<<1|1];
}
inline void Add(re int x,re int y){mn[x]+=y,tg[x]+=y;}
inline void pd(re int p){
	if(tg[p])Add(p<<1,tg[p]),Add(p<<1|1,tg[p]),tg[p]=0;
}
inline void add(re int p,re int l,re int r,re int x,re int y,re int z){
	if(l>=x&&r<=y)return Add(p,z);
	pd(p);
	re int mid=l+r>>1;
	if(x<=mid)add(p<<1,l,mid,x,y,z);
	if(y>mid)add(p<<1|1,mid+1,r,x,y,z);
	pu(p);
}
inline void ask(re int p,re int l,re int r,re int x,re int y){
	if(l>=x&&r<=y){
		if(mn[p]<ans2)ans2=mn[p],ans1=mnp[p];
		return;
	}pd(p);
	re int mid=l+r>>1;
	if(x<=mid)ask(p<<1,l,mid,x,y);
	if(y>mid)ask(p<<1|1,mid+1,r,x,y);
}
struct node{int x,y;bool operator <(const node A)const{return x<A.x;};};
inline int root(re int x){return x==fa[x]?x:fa[x]=root(fa[x]);}
vector<node>G[1000002];
int main(){
	t=read();
	while(t--){
		n=read(),m=read();
		for(re int i=1;i<=m;++i)L[i]=read(),R[i]=read(),V[i]=W[i]=read(),G[i].clear();
		for(re int i=1;i<=n;++i)V1[i]=V2[i]=0; 
		sort(W+1,W+m+1);
		for(re int i=1;i<=m;++i)V[i]=lower_bound(W+1,W+m+1,V[i])-W,G[V[i]].push_back((node){L[i],R[i]});
		for(re int i=1;i<=n+1;++i)fa[i]=i;re bool ia=1;
		for(re int i=m;i&&ia;--i)if(G[i].size()){
			sort(G[i].begin(),G[i].end());
			re int lst=n+1; 
			for(re int j=G[i].size()-1;~j&&ia;--j)
				if(G[i][j].y<lst){
					re int pos=root(G[i][j].x);
					V1[pos]=i,ia&=pos<=G[i][j].y,lst=pos;
				}
			for(auto z:G[i])
			for(re int j=root(z.x);j<=z.y;j=root(j))V2[j]=i,fa[j]=j+1;
		}if(!ia){puts("-1");continue;}build(1,0,m+1);long long ans=0;
		for(re int i=1;i<=m;++i)c[i]=0;
		for(re int i=1;i<=n;++i)if(V1[i])ans+=ask(V1[i]+1),add(V1[i]),add(1,0,m+1,V1[i]+1,m+1,1);
		for(re int i=1;i<=n;++i)
			if(V1[i])add(1,0,m+1,V1[i]+1,m+1,-1),add(1,0,m+1,0,V1[i]-1,1);
			else{
				ans2=1e9,ask(1,0,m+1,V2[i],m+1);
				ans+=ans2;
				if(ans1)add(1,0,m+1,0,ans1-1,1);
			}
		printf("%lld\n",ans);
	}
}
```


---

## 作者：Alex_Wei (赞：20)

- Upd on 2022.9.5：换成可以在 UOJ 上 [通过](https://uoj.ac/submission/582080) 的代码。

> D2T2. [P8500 [NOI2022] 冒泡排序](https://www.luogu.com.cn/problem/P8500)

我太爱这道题目了！

首先对题目进行初步观察：

- 冒泡排序交换次数就是逆序对数，只能说这个皮套得很离谱。
- $V_i$ 可以离散化，因为在最终方案中若存在 $a_i$ 不等于任何 $V_j$，则将其调整到大于它的最小的 $V_j$ 或小于它的最大的 $V_j$ 均不使得逆序对数量变多。

受到 [P4229 某位歌姬的故事](https://www.luogu.com.cn/problem/P4229) 的影响，我在考场上以为这题是神仙 DP 题，不会做，摆烂了。但仔细想想就会发现 P4229 只要考虑最后一个满足条件的位置，但是本题逆序对数需要考虑当前位置和之前所有位置产生的联合贡献，看起来不太能做。

从部分分入手，这题部分分设置得真好。

考虑 **特殊性质 B**。除去无解的情况，一些位置的值已经固定，其余位置可以任意取值。

> 性质 1：任意取值的位置必然不产生逆序对。

证明：若 $i < j$ 且 $a_i > a_j$，交换 $a_i, a_j$ 显然不劣。

据此，从后往前枚举所有任意取值的位置 $i$，每次选择使得与固定取值位置之间贡献最少的值作为 $a_i$。设 $c_v$ 表示当前位置选择 $v$ 产生的贡献，则 $a_i = \mathrm{argmin}_{v = 1} ^ m c_v$。这样决策 $a_i$，可证任意取值位置之间不产生逆序对：从后往前扫的过程中，若遇到固定取值位置 $j$，则我们的操作是将 $c$ $[1, a_j - 1]$ 区间减 $1$，$[a_j + 1, m]$ 区间加 $1$，因此若 $i < j$ 且 $c_i \leq c_j$，那么接下来任意时刻均有 $c_i\leq c_j$，因此具有 **决策单调性**。

注意尽管具有决策单调性，但 $c$ **不具有凸性**，不可以直接用指针维护。用线段树区间加全局 $\mathrm{argmin}$ 维护 $c$ 即可 $\mathcal{O}(n\log n)$ 性质 B。[代码](https://uoj.ac/submission/580489)。

进一步地，考虑 **特殊性质 C**。限制相对独立，我们找一些贪心思想。逆序对数相关，我们希望 **较小的数尽可能排在前面**。这就启发我们得到如下结论：对于限制 $(l, r, V)$，将 $V$ **尽可能往前放**，即必然有 $a_l = V$。因为观察 $a_l \sim a_r$，如果 $a_l > V$，那么必然存在 $p\in (l, r]$ 满足 $a_p = V$，$a_l$ 与 $a_p$ 之间形成逆序对，交换更优。这样一来，**恰好等于** 的要求就被搞定了，$(l, r, V)$ 对 $a_{l + 1}\sim a_r$ 的限制仅仅是不小于 $V$。

借鉴性质 B 的思路，我们有如下算法：设 $b_i$ 表示 $a_i$ 被限制 $\geq b_i$。对于所有限制 $(l, r, V)$，将 $c_1 \sim c_{V - 1}$ 区间加上 $r - l + 1$，表示如果选择小于 $V$ 的数，则会和 $a_l \sim a_r$ 形成 $r - l + 1$ 个逆序对，并令 $b_i\gets V(i\in [l, r])$。仍然从后往前考虑所有位置，对于位置 $i$，若其被限制 $\geq b_i$，则将 $c_1\sim c_{b_i - 1}$ 区间减 $1$，这和性质 B 一样。接下来，若 $a_i$ 还没有被固定取值，即 $i$ 不是某限制的 $l$，则令 $a_i = \mathrm{argmin}_{v = b_i} ^ m c_v$。注意这里不是令 $a_i$ 为全局 $\mathrm{argmin}$ 再和 $b_i$ 取 $\max$，因为 $c$ **没有凸性**，我在考场上这么写过不了样例 5，以为是结论假了，寄。最后令 $c_{a_i + 1} \sim c_r$ 区间加 $1$，意义显然。时间复杂度 $\mathcal{O}(n\log n)$。[代码](https://uoj.ac/submission/580490)。

这个做法正确性证明有点难，大家根据性质 B 做法感性理解即可。

接下来考虑 **特殊性质 A**。若 $V = 1$，显然 $a_l\sim a_r$ 均为 $1$，否则将所有 $V = 0$ 的限制拎出来，仍然是从后往前考虑所有位置。因为我们希望较小的数尽可能排在前面，所以我们 **当且仅当再不放 $0$ 就会出现无解的时候**，我们才选择固定当前位为 $0$，这其实和性质 C 的贪心有异曲同工之妙。贪心过程容易维护：

- 进行处理使得区间不相互包含（但注意若 $I_1 \subseteq I_2$，那么是 $I_1$ 限制更紧，要保留 $I_1$ 而非 $I_2$），然后用指针维护最后一个未满足的区间，扫一遍所有未被填入 $1$ 的位置。
- 或者将所有区间按照左端点从大到小排序后考虑，用 set 维护已经选中和未被选中的位置。若不存在已经选中的位置属于 $I$ 则在未被选中的位置集合中查询 $l$ 的后继，若不存在或大于 $r$ 则无解，否则选中该后继。

固定一些位置等于 $0$ 之后做一遍特殊性质 B 即可。时间复杂度 $\mathcal{O}(n\log n)$。

贪心正确性证明：考虑 $V = 0$ 的限制区间集 $S$，考虑左端点最大的任意限制 $I\in S$，我们在 $l_I$ 处固定 $a_{l_I} = 0$。因为不存在左端点比 $I$ 更靠右的区间，再根据 $I$ 的限制，在 $\geq l_I$ 的位置必须至少一个位置固定为 $0$，而选择 $l_I$ 可以让尽可能多的其它区间被满足，选择其它位置通过调整总是不优于选择 $l_I$，证毕。

正解考虑结合特殊性质 A 和特殊性质 C 的做法，对每个值 $v$，将所有 $b_i = v$ 的位置拎出来（$b_i > v$ 的位置不能放 $v$），所有 $V = v$ 的限制区间拎出来，对这些位置和区间做性质 A，最终得到一些已经固定的 $a$，结合 $b_i$ 做性质 C 即可。时间复杂度 $\mathcal{O}(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
namespace IO {
  char buf[1 << 21], *p1 = buf, *p2 = buf;
  #define gc (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
  inline int read() {
    int x = 0; bool sgn = 0; char s = gc;
    while(!isdigit(s)) sgn |= s == '-', s = gc;
    while(isdigit(s)) x = x * 10 + s - '0', s = gc;
    return sgn ? -x : x;
  }
}
using namespace IO;
bool Mbe;
constexpr int N = 1e6 + 5;
int n, m, d[N], fa[N], val[N], low[N];
int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
struct BIT {
  int c[N];
  void clear() {for(int i = 1; i <= m; i++) c[i] = 0;}
  void add(int x, int v) {while(x) c[x] += v, x -= x & -x;}
  int query(int x) {int s = 0; while(x <= m) s += c[x], x += x & -x; return s;}
} tr;
struct limit {
  int l, r, v;
} c[N];
set<int> pos[N];
vector<limit> buc[N];
struct Segtree1 {
  struct dat {
    int mn, pos;
    dat operator + (const dat &x) const { // ensure that pos < x.pos
      return mn <= x.mn ? *this : x;
    }
  } val[N << 2];
  int laz[N << 2];
  void build(int l, int r, int x) {
    laz[x] = 0;
    if(l == r) return val[x] = {0, l}, void();
    int m = l + r >> 1;
    build(l, m, x << 1), build(m + 1, r, x << 1 | 1);
    val[x] = val[x << 1] + val[x << 1 | 1];
  }
  void tag(int x, int v) {val[x].mn += v, laz[x] += v;}
  void down(int x) {
    if(laz[x]) {
      tag(x << 1, laz[x]);
      tag(x << 1 | 1, laz[x]);
      laz[x] = 0;
    }
  }
  void modify(int l, int r, int ql, int qr, int x, int v) {
    if(ql > qr) return;
    if(ql <= l && r <= qr) return tag(x, v);
    int m = l + r >> 1;
    down(x);
    if(ql <= m) modify(l, m, ql, qr, x << 1, v);
    if(m < qr) modify(m + 1, r, ql, qr, x << 1 | 1, v);
    val[x] = val[x << 1] + val[x << 1 | 1];
  }
  dat query(int l, int r, int ql, int qr, int x) {
    if(ql <= l && r <= qr) return val[x];
    int m = l + r >> 1;
    down(x);
    dat ans = {N, 0};
    if(ql <= m) ans = ans + query(l, m, ql, qr, x << 1);
    if(m < qr) ans = ans + query(m + 1, r, ql, qr, x << 1 | 1);
    return ans;
  }
} sgt1;
void solve() {
  n = read(), m = read();
  for(int i = 1; i <= n + 1; i++) fa[i] = i, val[i] = low[i] = 0;
  for(int i = 1; i <= m; i++) {
    c[i].l = read(), c[i].r = read();
    d[i] = c[i].v = read();
  }
  sort(d + 1, d + m + 1);
  for(int i = 1; i <= m; i++) c[i].v = lower_bound(d + 1, d + m + 1, c[i].v) - d;
  for(int i = 1; i <= m; i++) buc[i].clear(), pos[i].clear();
  for(int i = 1; i <= m; i++) buc[c[i].v].push_back(c[i]);
  for(int i = m; i; i--)
    for(auto it : buc[i]) {
      while(1) {
        int p = find(it.l);
        if(p > it.r) break;
        fa[p] = p + 1, low[p] = i, pos[i].insert(p);
      }
    }
  for(int i = 1; i <= m; i++) {
    sort(buc[i].begin(), buc[i].end(), [&](limit x, limit y) {return x.l > y.l;});
    set<int> settle;
    for(auto it : buc[i]) {
      auto pt = settle.lower_bound(it.l);
      if(pt != settle.end() && *pt <= it.r) continue;
      pt = pos[i].lower_bound(it.l);
      if(pt == pos[i].end() || *pt > it.r) return puts("-1"), void();
      settle.insert(*pt);
      val[*pt] = i;
      pos[i].erase(pt);
    }
  }
  sgt1.build(1, m, 1);
  for(int i = 1; i <= n; i++) if(low[i]) sgt1.modify(1, m, 1, low[i] - 1, 1, 1);
  for(int i = n; i; i--) {
    if(low[i]) sgt1.modify(1, m, 1, low[i] - 1, 1, -1);
    if(!val[i]) val[i] = sgt1.query(1, m, low[i], m, 1).pos;
    sgt1.modify(1, m, val[i] + 1, m, 1, 1);
  }
  ll ans = 0;
  tr.clear();
  for(int i = 1; i <= n; i++) ans += tr.query(val[i] + 1), tr.add(val[i], 1);
  cout << ans << "\n";
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("bubble6.in", "r", stdin);
    FILE* OUT = freopen("e.out", "w", stdout);
  #endif
  int T;
  cin >> T;
  while(T--) solve();
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/8/29
author: Alex_Wei
start coding at 16:34
finish debugging at 20:20
*/
```

---

## 作者：FjswYuzu (赞：9)

首先有个一级结论就是最小化逆序对数量，因为冒泡排序每次交换必定会减少一个逆序对，不交换肯定不会减少。问题就相当于最小化逆序对数量。

然后还有一个一级结论是我们只会填入 $m$ 个限制里面的数。这点很好理解，因为如果 $a=b$ 肯定就不会产生逆序对，否则的话就有可能产生逆序对。

到这里没有很好的切入点。从特殊性质分析。

首先考虑满足每个限制。每个限制可以描述为，「$[L_i,R_i]$ 这段区间内的所有值都不小于 $V_i$，并且至少存在一个 $V_i$」。不如先考虑一下这个 $V_i$ 放在哪里更好。

先借用一下特殊性质 B 考虑——呃，这有必要考虑吗？

然后考虑特殊性质 C。现在区间是互不相交的，我们可以对每个区间单独考虑。下面给出一个结论，即对每个限制，强制令 $a_{L_i}=V_i$ 是最优的。

考虑证明。如果其他位置要拔高，最小的放在最前面肯定不会增加新的逆序对。

那如果没有特殊性质呢？事实上我们仍然可以沿用上面的结论，只不过要处理一些区间相交的情况：

- 相交的区间，$V$ 相同：不妨让 $L_1 \leq L_2$，有 $L_1 \leq L_2 \leq R_1 \leq R_2$，那么放在 $L_2$ 最优：放在 $L_2$ 可以满足两个限制，不在 $L_1$ 再放一个是因为你不可能让一个位置的选择变得更少，这样肯定不优；   
- $V$ 不相同：那么大的就把小的那一段区间覆盖掉了，转化成区间没有相交的情况。

对于更复杂的情况可以一直用上面的方法处理。具体的，我们对于 $V$ 相同的所有区间一起处理，先按左端点从大到小排序，然后记录最近的一个放了 $V$ 的位置。枚举每个区间（假设这个区间没有完整地被 $V$ 更大的区间覆盖），如果区间内已经有 $V$ 了就跳过，不然就在 $L$ 这个位置放下一个 $V$。 

这一部分可以用并查集实现。

```cpp
	for(int i=len;i;--i)
	{
		sort(Seg[i].begin(),Seg[i].end(),[&](P x,P y){return x.first>y.first;});
		int lst=n+1;
		for(auto seg:Seg[i])
		{
			int l=seg.first,r=seg.second;
			if(ufs.findSet(l)>r)	return void(puts("-1"));
			int p=ufs.findSet(l);
			if(lst>r)	lst=p,a[p]=i;
		}
		for(auto seg:Seg[i])
		{
			int l=seg.first,r=seg.second;
			int p=ufs.findSet(l);
			while(p<=r)	ufs[p]=r+1,d[p]=i,p=ufs.findSet(p+1);
		}
	}
```

接下来不妨考虑一个更强的问题，就是直接把这个序列构造出来。

当然直接考虑这个问题太难啦！我们对特殊性质 B 考虑一下。

初步考虑之后发现，中间没有确定的部分，整体来看是递增的（当然这个弱智结论不能扩展到全局，不然你会像我一样错失过题良机）。

分析这个递增性质的来源。不妨先假设中间的段可以独立考虑，也即每两段之间不产生任何贡献，只考虑已经确定了的位置之间的贡献，和已确定的位置和还没填之间的贡献。

首先这里有个简单结论是每个没有确定位置的极长段填的数是一样的，因为它们地位平等贡献平等（虽然说这个结论没啥用就对了）。

然后因为每段独立，我们可以直接在 $m$ 个取值里面选择产生贡献最小的值，记第 $i$ 个极长段的取值为 $p_i$。欲证 $p$ 单调不减。

证明应该也算是直观，因为越往后走，放的数小了的话对前面就会产生更多的逆序对，大了对后面产生的逆序对会越来越少，因此 $p$ 单调不减。

大胆猜测合理结论，从前往后确定每个位置，每个还没被确定的位置实际上只由前面填了的所有数（包括一开始没确定的）和后面已经确定的数，以及自身的取值下界决定，**在所有产生贡献最小的数中选最小的**。先对着特殊性质 A 验证一下，除非是为了满足必要的要求，一定存在一个分界线前面填的是 $0$，后面填的是 $1$。这实际上和我们的结论是相符合的（当然和整体来看是递增的这个弱智错结论不符了……），因为越往后前面 $1$ 的个数就会比后面 $0$ 的个数多了，自然选 $1$ 更合理。

那就写了一发，然后就过了……既然你敢写，那你就 win 了……证明暂时还不会，之后再补吧。

放个[完整代码](https://www.luogu.com.cn/paste/0asgsg7k)。



---

## 作者：KaguyaH (赞：4)

对于所有长度为 $n$ 的满足下列条件的序列 $a_{1 \dots n}$，求逆序对数最小值。

- $\forall 1 \le i \le m, \min_{j = L_i}^{R_i} = V_i.$

多测，$\sum n, \sum m \le 10^6$。

---

容易看出，一定有一个逆序对数最小的合法序列，$\forall i, a_i \in V$，其中 $V$ 为所有 $V_j$ 构成的集合。于是我们可以将 $V_i$ 的值域离散化到 $[1, m]$ 中。

首先，这些条件对每个给出了下限，记为 $b_{1 \dots n}$。考虑钦定一些位置取到下限，使得条件被满足。

一个简单的考虑是：如果最终的 $a$ 中存在一个逆序对且可以交换，那么交换必然不劣。所以若只考虑一个条件，则我们可以直接找到最靠左的一个 $b_j = V_i \pod{L_i \le j \le R_i}$，并钦定 $a_j = b_j$；若无法找到合法的 $j$，那么无解（容易看出，这里对无解的判定是充要的）。

这个结论可以容易地扩展到多个条件的情况：先按照 $V_i$ 将条件分类，每一类内部按 $L_i$ 从大到小的顺序枚举条件；枚举到一个条件 $(L_i, R_i, V_i)$ 时，我们考虑是否已经有一个 $L_i \le j \le R_j \land b_j = V_i$ 的 $j$ 被钦定，若没有，则找到最小的 $j$，钦定 $a_j = b_j$。

于是，我们将条件转化为：分别给定一些位置的取值；并分别给定其余位置的下限。我们将给定取值的位置称为 A 类位置；给定下限的位置称为 B 类位置。

---

A 类位置内部的逆序对数是确定的，只需要最小化含 B 类位置的逆序对数目。

将填写视作插入，维护一个序列 $c_{1 \dots m}$ 以及一个指针 $p$，$c_i$ 表示当前若在 $p$ 处填写一个 $i$，与已经确定或填好的位置之间所产生的代价。初始时，$p$ 指向 $1$ 位置前，对于每个 A 类位置 $i$，将 $c_{b_i + 1 \dots m}$ 分别 $+1$。我们将 $p$ 向后移动，来填写 $a_{1 \dots n}$。

考虑如何跳过一个 A 类位置 $p$。这是容易的，将 $c_{1 \dots a_p - 1}$ 分别 $+1$，将 $c_{a_p + 1 \dots m}$ 分别 $-1$ 即可。

若填完一个 B 类位置 $p$，则我们应将 $c_{1 \dots a_p - 1}$ 分别 $+1$。

我们发现，若在 $p$ 处填 $x$ 不优于填 $y \pod{x < y}$，则此后无论如何 $x$ 都不会优于 $y$。这启发我们考虑贪心。

对于一个 B 类位置 $p$，我们的所有决策对 $c_{1 \dots b_p - 1}$ 的影响都是一致的（$+1$）。考虑直接选择一个最小的 $c_x$，令 $a_p = x$。由于填写 $b_p \dots x - 1$ 均不优于填 $x$，故将 $c_{b_p \dots x - 1}$ 分别 $+1$ 是不会影响此后的填写工作的。于是我们填写一个这样的 $x$ 是不劣的。

---

整理一下做法。

首先确定每个位置的下限。从右往左考虑限制，若当前限制可能不满足，则在区间内钦定一个尽量靠左的合法（指下限与当前限制的 $V_i$ 相同）位置取到下限，若区间内不存在合法位置，则无解。

然后考虑填写未钦定好的位置 $p$。仅考虑当前已经钦定好或填好的位置与 $a_p$ 之间的贡献即可。

时间复杂度 $O((n + m) \log (n + m))$。

---

考场上 12:30 会了这个做法，没写完。

代码可以找我要。

---

## 作者：Graygoo (赞：4)

好题，可以作为性质题以及部分分设计的典范。

既然说到了部分分设计得好，肯定是因为部分分很有启发性，所以我们来看下部分分情况如何解决。

但是在这之前，要先搞定两个$lemma$。

$lemma \ 1$.最优情况下，序列的值只可能是在条件内出现过的值。

老生常谈的局部调整，这个性质使得我们可以无后顾之忧地离散化。

$lemma \ 2$.如果一个大的在一个小的前且可交换，交换后必定更优。

可以列一张表自己看一下交换前和交换后哪些会产生贡献，不难证。

好 现在来看性质B。

性质B的操作相当于给单点确定它的值。那么我们有一个贪心，就是只需要最小化被确定了的点与未确定点之间的贡献，因为在最小化了的前提下，未确定点本身也会是不降的。打一个线段树维护即可。

性质C。

区间不相交的话，根据我们的$lemma \ 2$，会发现只要把最小值放在首位，其它的保证大于等于它即可。受到性质B的启发，不妨思考贪心性质会不会仍然存在。答案是肯定的，但是要做一点小改动，在确定一个未被确定值的点的最优值时，需要考虑所有它前面的点以及后面的被确定点的贡献，在满足保证大于强制条件的情况下选择贡献最小的，若贡献相同选择更小的,设为$x$。

简单证明一下：首先我们不会傻到选一个前面贡献比现在大，且值也更大的，因为这会使得前后贡献均不优。如果我们选一个前面贡献更大但值更小的呢？设选择的值为$y$，那么我们把包括自己在内的后面所有值在$y$到$x$之间的全部移到$x$，这显然合法，并且必然不劣。(因为这个点都有y对于前面的贡献>x的贡献了，那么根据性质B的证明，显然后面也是如此)。

现在可以思考原题目了。

交叉的区间实际上并不难处理，并查集扫描线或线段树都可以将其转化到性质C的解法。我高兴地打完了程序，然后发现过不了第二个数据，因为重复后一个点可能被多个最小值相同的区间覆盖。

如何处理相同的值。将值相同的区间按照左端点从大到小排序，找到左侧开始第一个没有被比自己值大的区间覆盖的点并打上"必定为自己的值"的标记，当然如果自己的区间内有先前和自己值相同的其他区间打的标记就可以跳过。容易证明，这样贪心是最优的。

然后就整完了。

代码:
```
#include<bits/stdc++.h>
using namespace std;
struct p{
	int l,r,v;
}q[1000001];
int stk[1000001];
int mn[1000001];
int fa[1000001];
int val[1000001];
#define pii pair<int,int>
#define mid(l,r) ((l+r)>>1)
pii h[6000001];
int lzy[6000001];
int bit[5000001];
void modify(int x,int v){
	for(int y=x;y<=5000000;y+=y&-y)bit[y]+=v;
	return ;
}
int query(int x){
	int ret=0;
	for(int y=x;y;y-=y&-y)ret+=bit[y];
	return ret;
}
inline pii merge(pii a,pii b){
	if(a.first<=b.first)return a;
	return b;
}
inline void down(int id){
	h[id*2].first+=lzy[id];
	h[id*2+1].first+=lzy[id];
	lzy[id*2]+=lzy[id];
	lzy[id*2+1]+=lzy[id];
	lzy[id]=0;
	return ;
}
void modify(int l,int r,int fr,int to,int id,int delta){
	if(!h[id].second)h[id].second=l;
	if(l>=fr and r<=to){h[id].first+=delta;lzy[id]+=delta;return ;}
	if(l>to or r<fr)return ;
	down(id);
	modify(l,mid(l,r),fr,to,id*2,delta);
	modify(mid(l,r)+1,r,fr,to,id*2+1,delta);
	h[id]=merge(h[id*2],h[id*2+1]);
	return ;
}
pii query(int l,int r,int fr,int to,int id){
	if(!h[id].second)h[id].second=l;
	if(l>=fr and r<=to)return h[id];
	if(l>to or r<fr)return {INT_MAX,0};
	down(id);
	pii ret=merge(query(l,mid(l,r),fr,to,id*2),query(mid(l,r)+1,r,fr,to,id*2+1));
	return ret;
}
int rt(int id){
	if(fa[id]==id)return id;
	return fa[id]=rt(fa[id]);
}
int main(){
	int T;cin>>T;
	while(T--){
	int n,m;cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>q[i].l>>q[i].r>>q[i].v;
		stk[i]=q[i].v;
	}
	sort(stk+1,stk+1+m);
	int cnt=unique(stk+1,stk+1+m)-stk;
	for(int i=1;i<=m;i++){
		q[i].v=lower_bound(stk+1,stk+cnt,q[i].v)-stk;
	}
	sort(q+1,q+1+m,[](p a,p b){return a.v==b.v?a.l>b.l:a.v>b.v;});
	bool flg=1;
	for(int i=1;i<=n+1;i++)fa[i]=i,val[i]=-1,mn[i]=1;
	int ptr=1;
	while(ptr<=m){
		int tmp=ptr;
		while(tmp<=m and q[tmp].v==q[ptr].v)tmp++;
		tmp--;int mns=n+1;
		for(int i=ptr;i<=tmp;i++){
			if(mns<=q[i].r)continue;
			int g=rt(q[i].l);mns=g;val[g]=q[i].v;
		}
		for(int i=ptr;i<=tmp;i++){
			if(rt(q[i].l)>q[i].r)flg=0;
		}
		for(int i=ptr;i<=tmp;i++){
			int f=rt(q[i].l);
			while(f<=q[i].r){
				fa[f]=f+1;mn[f]=q[i].v;
				f=rt(f);
			}
		}
		ptr=tmp+1;
	}
	if(!flg){
		cout<<-1<<endl;
		continue;
	}
	for(int i=1;i<=n;i++){
		if(val[i]!=-1)modify(1,cnt,val[i]+1,cnt,1,1);
	}
	for(int i=1;i<=n;i++){
		if(val[i]!=-1){
			modify(1,cnt,val[i]+1,cnt,1,-1);
			if(val[i]!=1)modify(1,cnt,1,val[i]-1,1,1);
		}
		else {
			val[i]=query(1,cnt,mn[i],cnt,1).second;
			if(val[i]!=1)modify(1,cnt,1,val[i]-1,1,1);
		}
	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		ans+=i-1-query(val[i]);
		modify(val[i],1);
	}
	cout<<ans<<endl;
	for(int i=1;i<=min(6000000,8*n);i++)h[i]={0,0},lzy[i]=0;
	for(int i=1;i<=n;i++)modify(val[i],-1);
	}
	return 0;
}
```


---

## 作者：Tyyyyyy (赞：4)

## P8500

### 题意简述
求非负整数序列 $a_{1\dots n}$ 满足 $m$ 条限制（形如 $(L,R,V)$ 表示 $\min_{i=L}^R a_i=V$），且逆序对数最小。输出最小逆序对数。

$1\leq n,m\leq 10^6,0\leq V\leq 10^9$。

### 题目分析
前排提示：题解中感性证明的部分可能比较多。

#### 判断可行性
将限制按 $V$ 降序排序，依次考虑限制，给区间中未被赋值的位置赋值。设此时得到的序列为 $A_{1\dots n}$，直接检查 $A$ 序列是否满足所有条件即可。且任一符合条件的序列 $a$ 一定满足 $a_i\geq A_i$（易证）。

#### 尝试最优化
相当于现在我们知道了每个数可以取的值的下界，那么显然只能调整一些数将它们变大，而另外一些数不变。我们称不变的数为关键点，则关键点就是每个限制中取到 $\min$ 的点。考虑算答案，可以分为三个部分：关键点对关键点，关键点对非关键点，非关键点对非关键点。

#### Lemma 1
存在这样一种构造关键点的方式使得答案不劣：

- 按 $V$ 从大到小考虑所有值相同的限制。

- 去除范围包含其它限制的限制。

- 从右到左考虑剩下的限制，若该限制还未被满足，则设定该限制内最左边可以被设为关键点的位置为关键点。

#### Proof 1
感性理解一下吧。。。这个构造确实很符合人类直觉（雾

#### 非关键点的取值
确定好关键点后，关键点对关键点的逆序对数容易计算。接下来要对于每个非关键点考虑取值。若只需最小化关键点对非关键点的逆序对数，则该过程是容易的。但还要考虑非关键点对非关键点的逆序对数，问题似乎与两个非关键点的取值均有关系。这使得问题变得棘手了起来，我们考虑挖掘性质简化一下问题。

#### Lemma 2
对于没有取值下界（未被任何一个限制包含）的位置，其取值在最优解中一定是单调不降的。

#### Proof 2
假设单调不降不是最优策略，设有相邻两个没有取值下界的位置 $i,j$ 取值分别为 $v_i,v_j$，考虑交换 $i,j$ 的取值，不难发现逆序对数一定变多，与假设矛盾。因此，单调不降的取值是最优策略。

#### Lemma 3
对于非关键点 $i,j(i<j)$，若 $i$ 位置的取值下界为 $A_i$，$j$ 的取值为 $w$，则在最优解中 $(i,j)$ 是一个逆序对当且仅当 $A_i>w$。

#### Proof 3
假设 $A_i\leq w$ 时 $(i,j)$ 构成逆序对，那么考虑调整 $i$ 的取值使得 $i$ 的取值 $\leq w$，不难发现逆序对数一定变少。因此，上述结论成立。

#### 使用结论简化问题
根据定理 $3$，我们知道对于两个非关键点 $i,j$，$(i,j)$ 是否产生贡献只与 $j$ 的取值和 $i$ 的下界有关。换句话说，此时 $j$ 的最优取值只与前后关键点的值和前面非关键点的取值下界有关。具体地，可以写出 $j$ 取 $val$ 时对答案造成的贡献式子（设 $b_i$ 为关键点取值，$a_i$ 为非关键点下界）：

$$\sum_{i=1}^{j-1}[b_i>val]+\sum_{i=j+1}^n[b_i<val]+\sum_{i=1}^{j-1}[a_i>val]$$

线段树不难做到 $O(n\log n)$。加上前面的关键点构造，整个过程的时间复杂度也为 $O(n\log n)$。

Code：
```cpp
const int N=1e6+10;
int T,n,m,a[N],b[N],c[N],idx;
struct node
{
	int l,r,v;
}p[N],t[N];
vector<int>pos[N];
struct BIT
{
	int c[N];
	void add(int x,int y){for(;x<N;x+=x&(-x))c[x]+=y;}
	int ask(int x)
	{
		int res=0;
		for(;x;x-=x&(-x))res+=c[x];
		return res;
	}
}tr;
bool flg[N];
void work()
{
	sort(t+1,t+idx+1,[&](node x,node y){return x.l!=y.l?x.l>y.l:x.r<y.r;});
	for(int i=1;i<=idx;i++)flg[i]=!!tr.ask(t[i].r),tr.add(t[i].r,1);
	for(int i=1;i<=idx;i++)tr.add(t[i].r,-1);
}
struct SegmentTree
{
	int mn[N<<2],tag[N<<2];
	void pushup(int p){mn[p]=min(mn[p<<1],mn[p<<1|1]);}
	void build(int p,int l,int r)
	{
		tag[p]=mn[p]=0;
		if(l==r)return;
		int mid=(l+r)>>1;
		build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	}
	void adtag(int p,int v){mn[p]+=v,tag[p]+=v;}
	void pushdown(int p)
	{
		if(!tag[p])return;
		adtag(p<<1,tag[p]),adtag(p<<1|1,tag[p]);
		tag[p]=0;
	}
	void upd(int p,int l,int r,int L,int R,int d)
	{
		if(L>R)return;
		if(L<=l&&r<=R)return adtag(p,d);
		pushdown(p);int mid=(l+r)>>1;
		if(L<=mid)upd(p<<1,l,mid,L,R,d);
		if(R>mid)upd(p<<1|1,mid+1,r,L,R,d);
		pushup(p);
	}
	int ask(int p,int l,int r,int L,int R)
	{
		if(L<=l&&r<=R)return mn[p];
		pushdown(p);int mid=(l+r)>>1,res=1e9;
		if(L<=mid)res=min(res,ask(p<<1,l,mid,L,R));
		if(R>mid)res=min(res,ask(p<<1|1,mid+1,r,L,R));
		return res;
	}
}sgt;
int main()
{
	read(T);
	while(T--)
	{
		read(n,m);
		for(int i=1;i<=m;i++)read(p[i].l,p[i].r,p[i].v),b[i]=p[i].v;
		sort(b+1,b+m+1);int cnt=unique(b+1,b+m+1)-b-1;
		for(int i=1;i<=m;i++)p[i].v=lower_bound(b+1,b+cnt+1,p[i].v)-b;
		for(int i=1;i<=cnt;i++)pos[i].resize(0),pos[i].push_back(0);
		sort(p+1,p+m+1,[&](node x,node y){return x.v>y.v;});
		set<int>st;
		for(int i=1;i<=n;i++)st.insert(i),a[i]=c[i]=-1;
		for(int i=1;i<=m;i++)
		{
			auto it=st.lower_bound(p[i].l);
			for(;it!=st.end()&&(*it)<=p[i].r;it=st.erase(it))a[*it]=p[i].v;
		}
		for(int i=1;i<=n;i++)pos[a[i]].push_back(i);
		for(int i=1;i<=cnt;i++)pos[i].push_back(n+1);
		bool ok=1;
		for(int i=1;i<=m;i++)
		{
			int v=p[i].v;
			int pl=lower_bound(pos[v].begin(),pos[v].end(),p[i].l)-pos[v].begin();
			int pr=upper_bound(pos[v].begin(),pos[v].end(),p[i].r)-pos[v].begin()-1;
			if(pl>pr){ok=0;break;}
		}
		if(!ok){puts("-1");continue;}
		idx=0,t[++idx]=p[1];
		for(int i=2;i<=m;i++)
		{
			if(p[i].v!=p[i-1].v)
			{
				work(),st.clear();vector<node>vec;int v=p[i-1].v;
				for(int j=1;j<=idx;j++)if(!flg[j])vec.push_back(t[j]);
				sort(vec.begin(),vec.end(),[&](node x,node y){return x.l!=y.l?x.l<y.l:x.r<y.r;});
				for(int j=vec.size()-1;j>=0;j--)
				{
					auto it=st.lower_bound(vec[j].l);
					if(it==st.end()||(*it)>vec[j].r)
					{
						int x=*lower_bound(pos[v].begin(),pos[v].end(),vec[j].l);
						c[x]=v,st.insert(x);
					}
				}
				idx=0;
			}
			t[++idx]=p[i];
		}
		work(),st.clear();vector<node>vec;int v=p[m].v;
		for(int j=1;j<=idx;j++)if(!flg[j])vec.push_back(t[j]);
		sort(vec.begin(),vec.end(),[&](node x,node y){return x.l!=y.l?x.l<y.l:x.r<y.r;});
		for(int j=vec.size()-1;j>=0;j--)
		{
			auto it=st.lower_bound(vec[j].l);
			if(it==st.end()||(*it)>vec[j].r)
			{
				int x=*lower_bound(pos[v].begin(),pos[v].end(),vec[j].l);
				c[x]=v,st.insert(x);
			}
		}
		ll ans=0;sgt.build(1,1,cnt);
		for(int i=1;i<=n;i++)
			if(c[i]!=-1)sgt.upd(1,1,cnt,c[i]+1,cnt,1),ans+=tr.ask(cnt)-tr.ask(c[i]),tr.add(c[i],1);
		for(int i=1;i<=n;i++)if(c[i]!=-1)tr.add(c[i],-1);
		for(int i=1;i<=n;i++)
			if(c[i]!=-1)sgt.upd(1,1,cnt,c[i]+1,cnt,-1),sgt.upd(1,1,cnt,1,c[i]-1,1);
			else ans+=sgt.ask(1,1,cnt,a[i],cnt),sgt.upd(1,1,cnt,1,a[i]-1,1);
		printf("%lld\n",ans);
	}
	IO::pchar(0);
	return 0;
}
```

---

## 作者：Undead2008 (赞：2)

解法自然，思路清新，部分分对正解的提示性一步步增强，跟 NOI24 D1T3 有着极相似的思维方式，这真是绝世好题！

初见这个题很难做，这是个最小化逆序对，而条件又规定了跟序列的绝对位置和绝对大小相关的信息，常见的方法，比如只能维护相对位置 / 大小的按值 / 位置插入毫无用武之地！

尽量弱化限制最苛刻的条件，考虑 B 性质。

逆序对很强，你也要弱化！使用调整即可得知序列中不确定的位置填的数一定是不降的，这样最强的限制变成了填的数和给定的数间的逆序对。

经过分析可以得出，对每个位置填上与给定序列贡献最小的数，得到的答案序列一定是单调不降的，也就是说局部最优一定是全局最优！

考虑 $m=1$ 的情况。钦定的 $\min$ 一定放在开头，否则交换它与开头元素更优。

考虑 $V_i$ 相等的若干个区间，此时将 $\min$ 放在开头不一定更优，因为多个区间可能共享一个 $\min$。进行贪心，将区间按左端点从大到小排序，对于每个区间贪心地将最小值填在最左边能填的位置上，经过调整证明，这样是最优的。

正解就是拼上这两个东西！注意题目中给出的区间还要有形如 $a_i\ge v$ 的限制，此时每个位置填上值 $\ge v$ 的局部最优决策，经过调整法证明，是正确的！

---

## 作者：int233 (赞：2)

[评价和前情提要（视情况决定公开与否）](https://www.luogu.com.cn/paste/4tr381ma)

先发掘性质：

- 所有 $A_i$ 均在 $V_i$ 中出现过。

然后考虑特殊部分分：

## B 部分

- 对于每个限制相当于单点赋值

- 对于未赋值的位置，一定是升序排列的

- 发现每个未赋值的位置的贡献形式是（假设该位置赋值为 $x$）$\sum\limits_{j=0}^{L}[x>j]c_j$，相当于在动态 $c$ 序列上找一个前缀 $c$ 和最大（如有相同，取最小的 $x$），可以线段树维护。

## C 部分

- 相当于 $a_{L_i}=V_i$，$\forall j\in(L_i,R_i],a_j\ge V_i$。

- 发现每个未赋值的位置的贡献形式是（假设该位置赋值为 $x$）$\sum\limits_{j=0}^{L}[x>j]c_j$，相当于在动态 $c$ 序列上找一个前缀 $c$ 和最大，且 $x\ge $ 限制（如有相同，取最小的 $x$），可以线段树维护，发现这样子是最优的，证明略。

## 汇总

- 考虑把询问按 $V_i$ 从大到小排序，相同 $V_i$ 按照 $L_i$ 从大到小排序，对于每个询问，钦定第一个未被其他 $>V_i$ 询问覆盖的位置为 $=V_i$ 的，如果已经有了，就跳过，然后按 C 部分来做。

---

## 作者：LebronDurant (赞：2)

首先考虑 A 性质的点。区间最小值为 $1$ 的限制等价于要求区间所有值为 $1$。另外一种限制等价于区间不全为 $1$。

把一定是 $1$ 的做一个区间覆盖。其他部分暂且设为 $0$。设当前暂时的序列为 $a_i$，$s_i$ 为 $a_i$ 的前缀和，那么若 $a_i=0$，若把 $a_i$ 变成 $1$ 的话，逆序对数的改变量为 $-s_i+(n-i-(s_n-s_i))=n-i-s_n$。惊奇的发现他只和整个序列 $1$ 的数量有关。那么初始状态下，$i>n-s_n$ 的位置改成 $1$ 的话，逆序对数一定减少。这个过程中 $s_n$ 也在增大，所以使逆序对减小的 $i$ 的下界也在减少。那么就只需要倒序依次考虑每一个位置是否要变为 $1$ 即可。

接下来考虑如何满足一个区间不全为 $1$ 的限制。这个是一种常见的考虑 dp 的方法。和 noi2020d1t2 类似，当前已经逆序决策到了 $i$ 下标。那么我们时刻维护“当前还没满足条件的限制的左端点的最大值$rm$”，则在 $[rm,i]$ 内必须要有一个 $0$。对于一个变成 $1$ 会更优的位置，我们只需要考虑若这次把他变成 $1$ 了，那 $[rm,i-1]$ 还有没有机会出现 $0$ 即可，这样我们可以知道每个位置是否必须取到 $0$。其中 $rm$ 和上一个 $0$ 的位置都可以循环时直接维护，时间复杂度 $O(n)$。

##### 性质 B

首先此题有一个很显然的结论，就是最优序列一定可以是每个位置都填出现过的 $V_i$。否则调整后一定不劣。考虑某一个非确定位置的位置 $i$，它对逆序对数的贡献是 $\sum\limits_{j<i}[a_j>a_i]+\sum\limits_{j>i}[a_j<a_i]=\sum\limits_{j<i}[a_j>a_i]+n-i-\sum\limits_{j>i}[a_j\geq a_i]$。那么这个东西如果每一个空位单独考虑的话，很容易用线段树维护出来。而且发现（因为A我思维定式了，其实正着做也行）逆序依次决定的话，这棵以取值为下标，维护贡献的线段树的修改都是前缀减 $1$，查询都是全局最小。也就是说，他的最小值点永远在减小。只需要考虑任意两个位置之间大小关系很容易看出来。在序列上也就是空位内部一定没有逆序对。所以每个位置贡献独立，用线段树维护即可，时间复杂度 $O(n\log m)$。

我到这时候我才反应过来这个本该更早意识到的结论：空位内部没有逆序对，否则调整一定更优。

C 性质和 B 性质其实没啥大差别。很显然如果区间之间无影响的话，最小值点一定取在区间左端点。区间 $[l+1,r]$ 的点要求 $a_i\geq v$ 。那么有类似的结论：若位置 $i$ 处取了 $a_i$，则 $j<i$ 和 $i$ 形成逆序对当且仅当 $j$ 处要求的下界大于 $a_i$。其余部分依然一定没有逆序对，否则交换一定更优。所以就把 $j<i,mn_j>a_i$ 的贡献同样考虑在线段树上即可，和 B 性质一样做法，代码甚至都没差太多。~~至此已经有足足 80 分。~~

#####  正解

对于一般情况，考虑如何判无解。这是个经典问题，印象中好像是个奶牛题。对于两个限制，若两个限制相交，则限制区间最小值较小的那个限制比较大的限制更松。也就是说他们的交集只需考虑限制最小值较大的那个限制即可。那么就可以考虑从大到小考虑所有限制。如果某个限制的区间已经被之前的较大限制覆盖过了，那么是不合法的。这个过程用类似并查集，其实就是记一个后继的思路可以做到 $O(n)$，同时求出来每个位置取值的下界 $mn_i$。

所以现在这些限制可以转化为，每个位置的 $a_i\geq mn_i$，且每个区间必须有个位置取到最小值。显然这个取到最小值的位置一定是越靠左越好。那么对于每个值 $v$，把 $V_i=v$ 的限制和他限制的区间中 $mn_x=v$ 的位置拿出来，对他们做类似性质 A 做法的贪心，倒着做，考虑“还没满足的限制里最靠右的左端点”即可求出一些必须要强制取到 $v$ 的位置。而其他位置只需满足大于 $v$ 即可满足条件。

这样就完全转化为了 C 性质最终要维护的问题：一部分点固定，一部分点有下界，倒着扫一遍维护线段树即可。时间复杂度 $O(n\log m)$。

ABC 性质不算很困难，最后用经典奶牛题的做法，再结合起来 A 和 C 做法这一步还是差在这了。其实要是很熟悉那个题的话，这一步也算是自然。

我代码写的有点放飞自我，但是要是写的收敛一些的话我这个做法的常数还是比较小的，对 A 性质的处理比较简单。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
#define N 1101200
inline void rd(int &x)
{x=0;register char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){x=x*10+c-48;c=getchar();}
}
struct node{int l,r,mn;}b[N];
bool cmp(node n1,node n2){return n1.mn>n2.mn;}
int T,n,m,s[N],a[N],rm[N],pre[N],mn[N<<2],mnp[N<<2],rt,laz[N<<2];
int lsh[N],tot,dn[N],nxt[N];
vector<int>v[N];
inline void gv(int ind,int x){mn[ind]+=x;laz[ind]+=x;}
void pushdown(int ind){gv(ind<<1,laz[ind]);gv(ind<<1|1,laz[ind]);laz[ind]=0;}
void pushup(int ind)
{
	if(mn[ind<<1]<mn[ind<<1|1])mn[ind]=mn[ind<<1],mnp[ind]=mnp[ind<<1];
	else mn[ind]=mn[ind<<1|1],mnp[ind]=mnp[ind<<1|1];
}
void bt(int ind,int l,int r)
{mn[ind]=laz[ind]=0;
	if(l==r){mnp[ind]=l;return;}
	int mid=(l+r)>>1;
	bt(ind<<1,l,mid);bt(ind<<1|1,mid+1,r);
	pushup(ind);
}
void chng(int ind,int l,int r,int al,int ar,int x)
{if(al>ar)return;
	if(al<=l&&r<=ar){gv(ind,x);return;}
	int mid=(l+r)>>1;pushdown(ind);
	if(al<=mid)chng(ind<<1,l,mid,al,ar,x);
	if(ar>mid)chng(ind<<1|1,mid+1,r,al,ar,x);
	pushup(ind);
}
pair<int,int> ask(int ind,int l,int r,int al,int ar)
{
	if(al<=l&&r<=ar)return make_pair(mn[ind],mnp[ind]);
	int mid=(l+r)>>1,rmn=1e9,rmnp;pushdown(ind);
	if(al<=mid)
	{
		pair<int,int> ret=ask(ind<<1,l,mid,al,ar);
		if(ret.first<rmn)rmn=ret.first,rmnp=ret.second;
	}
	if(ar>mid)
	{
		pair<int,int> ret=ask(ind<<1|1,mid+1,r,al,ar);
		if(ret.first<=rmn)rmn=ret.first,rmnp=ret.second;
	}
	return make_pair(rmn,rmnp);
}
inline int getpos(int co,int x)
{
	int l=0,r=v[co].size()-1,mid,ret;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(x>=v[co][mid])ret=mid,l=mid+1;
		else r=mid-1;
	}return ret;
}
int main()
{
	rd(T);
	while(T--)
	{
		rd(n),rd(m);
		for(int i=1;i<=m;i++)
		{
			rd(b[i].l),rd(b[i].r),rd(b[i].mn);
		}
		for(int i=1;i<=n;i++)a[i]=dn[i]=0;
		tot=0;for(int i=1;i<=m;i++)lsh[++tot]=b[i].mn;
		sort(lsh+1,lsh+1+tot);tot=unique(lsh+1,lsh+1+tot)-lsh-1;
		for(int i=1;i<=m;i++)b[i].mn=lower_bound(lsh+1,lsh+1+tot,b[i].mn)-lsh;
		sort(b+1,b+1+m,cmp);
		bool flag=true;
		for(int i=1;i<=n;i++)nxt[i]=i+1;
		for(int i=1;i<=m;i++)
		{
			bool tf=false;
			for(int j=b[i].l;j<=b[i].r;j=nxt[j])
			{
				if(dn[j]<=b[i].mn)dn[j]=b[i].mn,tf=true;
			}
			if(!tf){flag=false;break;}
			for(int j=b[i].l;j<=b[i].r;)
			{
				int nx=nxt[j];
				if(dn[j]==b[i].mn)nxt[j]=nxt[b[i].r];
				j=nx;
			}
		}
		if(!flag)
		{
			puts("-1");
			continue;}
		for(int i=1;i<=tot;i++)v[i].clear();
		//for(int i=1;i<=n;i++)printf("%d ",dn[i]);puts("dn");
		for(int i=1;i<=n;i++)if(dn[i])v[dn[i]].push_back(i);
		for(int i=1;i<=m;i++)
		{
			int j=i;while(j<=m&&b[i].mn==b[j].mn)j++;j--;
			int co=b[i].mn;
			int len=v[co].size();
			if(!len){i=j;continue;}
			for(int ii=0;ii<len;ii++)rm[v[co][ii]]=0;
			for(int ii=i;ii<=j;ii++)
			{
				int tx=getpos(co,b[ii].r);
				rm[v[co][tx]]=max(rm[v[co][tx]],b[ii].l);
			}
			int trm=0;
			for(int ii=len-1;ii>=0;ii--)
			{
				int tx=v[co][ii];
				trm=max(trm,rm[tx]);
				if(trm&&(ii==0||v[co][ii-1]<trm))a[tx]=co,trm=0;
				else a[tx]=-co;
			}
			i=j;
		}
		//for(int i=1;i<=n;i++)printf("%d ",a[i]);puts("aa");
		bt(1,1,tot);
		for(int i=1;i<=n;i++)
		{
			if(a[i]>0)
			{
				chng(1,1,tot,1,a[i]-1,1);
			}
		}
		for(int i=1;i<=n;i++)if(a[i]<0)
		{
			chng(1,1,tot,1,-a[i]-1,1);
		}
		
		//printf("%lld\n",ans);
		for(int i=n;i;i--)
		{
			if(a[i]==0)
			{
				int tp=mnp[1];
				a[i]=tp;
				chng(1,1,tot,1,tp,-1);
			}
			else if(a[i]<0)
			{
				chng(1,1,tot,1,-a[i]-1,-1);
				pair<int,int>pr=ask(1,1,tot,-a[i],tot);
				a[i]=pr.second;
				chng(1,1,tot,1,pr.second,-1);
			}
			else
			{
				chng(1,1,tot,1,a[i]-1,-1);
				chng(1,1,tot,1,a[i],-1);
			}
		}
		ll ans=0;
		bt(1,1,tot);
		for(int i=1;i<=n;i++)
		{
			pair<int,int>pr=ask(1,1,tot,a[i],a[i]);
			ans+=pr.first;
			chng(1,1,tot,1,a[i]-1,1);
		}
		printf("%lld\n",ans);
	}
}
```


---

## 作者：juju (赞：2)

题意：

对长度为 $n$ 的序列 $a$，已知 $m$ 个条件：区间 $[l,r]$ 的最小值为 $v$。

最小化逆序对数。

---

易知存在最优解满足每个 $a_i$ 一定是某个 $v$。

考虑性质 B：$l_i=r_i$。

即可以确定每个被限制的 $a_i$，没有被限制的位置可以任意放。

容易发现没有被限制的位置一定放成一个不降的子序列，那么在每个位置上贪心放产生逆序对数目最少的数字即可。

接下来考虑性质 C： $[l_i,r_i]$ 不交。

容易想到这样的策略：每个区间的最前端钦定放 $v$。这样只是在 $B$ 性质的基础上多了一个某些位置的数字有不小于某个数的限制。

事实上，从前往后考虑，在这些未被钦定的位置上放下产生逆序对数目最少的数字就是最优的。

有一个比较奇怪的解释是：

考虑另外一种填法：

1. 我们考虑从小往大填数字，每次将一些位置都变成一个数。容易发现这些位置一定是可以填的数的一个前缀。
1. 考虑这样一件事：一个被填的位置与没有被钦定的位置产生的贡献是它前面的没有被填的位置的数量。这样的话每次二分就可以找到应当被填的前缀了。

可以发现这两种填法其实是等价的。

数据结构维护一下就可以得到 $28$ 分。

对于原问题，我们也猜测：给一些位置钦定等于某个数，其余位置不小于某个数，这等价于原问题的限制。

不妨先考虑性质 A，显然可以转化为一些位置钦定为 $1$，另外限制某些区间存在 $0$。

事实上，我们去除有包含关系的限制，把限制按照左端点排序，从后往前考虑，每次贪心在不导致有区间不合法的情况下把最前的位置变成 $0$ 就是对的。

那么原题就是将限制对 $v$ 从大到小排序后，每次提取出 $v$ 相同的区间做一次性质 A 得到被钦定的位置，最后把没有钦定的位置做一次性质 C 就行了。

$\color{white}{\text{bonus: 请不要把线段树二分写成 2log。/ll/ll/ll}}$

---

## 作者：cwfxlh (赞：1)

## [P8500 [NOI2022] 冒泡排序](https://www.luogu.com.cn/problem/P8500)    

做了一个下午才做出来，此等水平如何 noi/ll。      

性质分引导很厉害。    

步数转化成逆序对数，然后离散化。

### 性质 A   

取值肯定就在 $0$ 和 $1$ 之间取了。如果 $v_i=1$，那么这一段就必定全是 $1$，否则至少要有一个 $0$。对于 $v_i=0$ 的区间，如果有一个区间包含另一个区间，那么删除这个区间。接下来考虑选中若干个位置将其设为 $0$，使得所有 $v_i=0$ 的区间都包含了至少一个 $0$。     

编出来一个贪心。$0$ 的位置显然越靠前越好，所以从后往前扫，选择尽量长的一段后缀区间满足它们的交里有可以设为 $0$ 的位置，然后将最靠前的合法位置设为 $0$。这就是最优的选择方法了，证明考虑调整，任意一种其他的选择方法都可以通过删除一个位置或者将一个位置前移，最后得到这个选择方法。      

确定了这些 $0$ 的位置后，剩下的数好确定了，显然应该是一段前缀是 $0$，后缀是 $1$，随便算算就可以了。    

### 性质 B   

比较简单的一档，所以分也是最少的一档。     

考虑对于没有限制的位置，它们的值一定是递增的，否则交换两个递减的位置，逆序对数一定不劣。    

这一档分我没想足够通过 $10^6$ 的做法，有一个简单的想法是直接枚举值来 dp，复杂度是平方的。我们带着性质 B 的思路直接来看下一档，这一档不管了。    

### 性质 C

因为区间不交，所以每个区间内部一定是递增的，也就是区间的第一个点值是确定的，其他点的限制都是形如 $a_i\ge x_i$ 的形式，这里令 $x_i$ 表示所有包含 $i$ 的区间的 $v$ 的最大值，也就是 $a_i$ 至少要取多少。。      

考虑拓展性质 B 的思路。      

对于两个自由位置的逆序对 $i<j,a_i>a_j$，如果$x_i\le a_j$，那么交换 $a_i,a_j$ 显然是不劣的，所以逆序对的情况一定是 $x_i>a_j$。也就是说我们选择一个地方的值的时候，最优选择与贡献，是和其他地方的值无关的。证明是好证明的，这样算出来的答案显然不会大于最终答案，如果其小于最终答案，且存在 $i<j,a_i>a_j,x_i\le a_j$，那么答案会至少减小 $1$，由于答案的计算方法是若干位置的贡献加起来，并且交换后只有这两个位置的贡献变了，于是 $i$ 的贡献与 $j$ 的贡献一定有一个变小了，不是最小贡献，发生矛盾。      

于是有一个算法，先把确定位置之间的逆序对算出来，然后对于每个自由位置，它的贡献有三部分，它前面的确定位置，它前面的自由位置的 $x_i$，它后面的确定位置，三者都是固定的，线段树维护一下就好了。     

现在成功得到了 80 分。    

### 正解     

只要能确定每个区间最小值选在哪里，那么直接套用性质 C 就可以了。     

这一步的做法我是猜出来的。对于每个值 $p$ 跑一遍性质 B，记得只能在 $x_i=p$ 的位置选择最小值。然后这样选出来的最小值就是最优，最靠前的了，再跑性质 C 即可。      

记得判无解。复杂度 $O(n\log n)$。    

代码：    

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int testnum,n,m,v[1000003],lmt[1000003][3],ST[1000003][19],ps[1000003],ans,ppp;
int stk[1000003],tots;
vector<int>seq;
vector<int>plst[1000003];
vector<int>qlst[1000003];
set<int>R;
int Query(int l,int r){
	l=max(l,1ll);r=min(r,n);
	if(l>r)return 0;
	auto p=R.lower_bound(l);
	if(p==R.end()||(*p)>r)return 0;
	return (*p);
}
bool comp(int xx,int yy){
	if(lmt[xx][0]!=lmt[yy][0])return lmt[xx][0]<lmt[yy][0];
	return lmt[xx][1]>lmt[yy][1];
}
int mk[5000003],mnv[5000003];
void pushup(int now){mnv[now]=min(mnv[now*2],mnv[now*2+1]);return;}
void addmk(int now,int val){mk[now]+=val;mnv[now]+=val;return;}
void pushdown(int now){addmk(now*2,mk[now]);addmk(now*2+1,mk[now]);mk[now]=0;return;}
void modify(int now,int l,int r,int ql,int qr,int val){
	if(l>qr||r<ql)return;
	if(l>=ql&&r<=qr){addmk(now,val);return;}
	pushdown(now);
	modify(now*2,l,((l+r)>>1),ql,qr,val);
	modify(now*2+1,((l+r)>>1)+1,r,ql,qr,val);
	pushup(now);
	return;
}
int Query(int now,int l,int r,int ql,int qr){
	if(l>qr||r<ql)return 10000000;
	if(l>=ql&&r<=qr)return mnv[now];
	pushdown(now);
	return min(Query(now*2,l,((l+r)>>1),ql,qr),Query(now*2+1,((l+r)>>1)+1,r,ql,qr));
}
void sol(){
	cin>>n>>m;
	for(int i=0;i<=m+1;i++){
		plst[i].clear();plst[i].shrink_to_fit();
		qlst[i].clear();qlst[i].shrink_to_fit();
	}
	tots=0;
	for(int i=1;i<=m;i++){
		cin>>lmt[i][0]>>lmt[i][1]>>lmt[i][2];
		stk[++tots]=lmt[i][2];
	}
	sort(stk+1,stk+tots+1);
	for(int i=1,j=0;i<=tots;i++){
		if(j==0||stk[j]!=stk[i])stk[++j]=stk[i];
		if(i==tots)tots=j;
	}
	for(int i=1;i<=m;i++)lmt[i][2]=(int)(lower_bound(stk+1,stk+tots+1,lmt[i][2])-stk);
	for(int i=1;i<=n;i++){
		for(int j=0;j<=18;j++)ST[i][j]=1;
	}
	for(int i=1;i<=m;i++){
		int l=lmt[i][0],r=lmt[i][1];
		ST[l][__lg(r-l+1)]=max(ST[l][__lg(r-l+1)],lmt[i][2]);
		ST[r-(1<<__lg(r-l+1))+1][__lg(r-l+1)]=max(ST[r-(1<<__lg(r-l+1))+1][__lg(r-l+1)],lmt[i][2]);
	}
	for(int i=18;i>0;i--){
		for(int j=1;j+(1<<i)-1<=n;j++){
			ST[j][i-1]=max(ST[j][i-1],ST[j][i]);
			ST[j+(1<<(i-1))][i-1]=max(ST[j+(1<<(i-1))][i-1],ST[j][i]);
		}
	}
	for(int i=1;i<=n;i++)v[i]=ST[i][0];
	for(int i=1;i<=18;i++){
		for(int j=1;j+(1<<i)-1<=n;j++)ST[j][i]=min(ST[j][i-1],ST[j+(1<<(i-1))][i-1]);
	}
	for(int i=1;i<=m;i++){
		int l=lmt[i][0],r=lmt[i][1];
		if(min(ST[l][__lg(r-l+1)],ST[r-(1<<__lg(r-l+1))+1][__lg(r-l+1)])>lmt[i][2]){
			cout<<-1<<'\n';
			return;
		}
	}
	for(int i=1;i<=n;i++)plst[v[i]].emplace_back(i);
	for(int i=1;i<=m;i++)qlst[lmt[i][2]].emplace_back(i);
	for(int i=0;i<=n+1;i++)ps[i]=0;
	for(int i=1;i<=m;i++){
		R.clear();
		for(auto j:plst[i])R.insert(j);
		sort(qlst[i].begin(),qlst[i].end(),comp);
		if(qlst[i].size()==0)continue;
		seq.clear();seq.shrink_to_fit();
		for(int j=qlst[i].size()-1,u=n+1;j>=0;j--){
			if(lmt[qlst[i][j]][1]<u){
				u=lmt[qlst[i][j]][1];
				seq.emplace_back(qlst[i][j]);
			}
		}
		reverse(seq.begin(),seq.end());
		for(int j=(int)(seq.size())-1;j>=0;j--){
			if(Query(lmt[seq[j]][0],lmt[seq[j]][1])==0){
				cout<<-1<<'\n';
				return;
			}
			int u=j;
			while(u-1>=0&&Query(lmt[seq[j]][0],lmt[seq[u-1]][1])!=0)u--;
			int pt=Query(lmt[seq[j]][0],lmt[seq[u]][1]);
			R.erase(pt);
			ps[pt]=i;
			j=u;
		}
	}
	for(int i=0;i<=4*m+50;i++)mk[i]=mnv[i]=0;
	for(int i=1;i<=n;i++)if(ps[i])modify(1,1,m,ps[i]+1,m,1);
	ans=0;
	for(int i=1;i<=n;i++){
		if(ps[i]){
			ans+=Query(1,1,m,ps[i],ps[i]);
			modify(1,1,m,ps[i]+1,m,-1);
			modify(1,1,m,1,ps[i]-1,1);
		}
		else{
			ans+=Query(1,1,m,v[i],m);
			modify(1,1,m,1,v[i]-1,1);
		}
	}
	for(int i=0;i<=4*m+50;i++)mk[i]=mnv[i]=0;
	for(int i=1;i<=n;i++){
		if(ps[i])ans-=Query(1,1,m,ps[i],ps[i]);
		modify(1,1,m,1,v[i]-1,1);
	}
	cout<<ans<<'\n';
	return;
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>testnum;
	while(testnum--)sol();
	return 0;
}
```

---

## 作者：MurataHimeko (赞：1)

设 $a_i$ 表示最优方案里第 $i$ 个位置的值，$b_i$ 表示第 $i$ 个位置最小是多少。

那么一定存在一种方案使得对于任意 $a_i$，存在一个限制里的 $V$ 使得 $a_i = V$。不然将所有 $a_i$ 都调整成第一个大于等于或小于等于 $a_i$ 的 $V$ 不会变劣。

首先特判无解，具体来说按照最小值从大到小扫区间，同时确定 $b$，用一个并查集维护即可。如果扫到一个区间时，区间内没有可以填的数则无解。

性质 B：


对于有限制的位置，$a$ 已经确定。对于两个无限制的的位置 $i,j (i<j)$，一定满足 $a_i \leq a_j$，不然交换后更优。

于是可以设 $f_{i,j}$ 表示，前 $i$ 个数，无限制的位置的最大值为 $j$，逆序对数最少是多少。转移形如 $f_{i,j} = \min{f_{i-1,k} + w_{i,j}}$，其中 $w_{i,j}$ 表示在第 $i$ 个位置填 $j$，跟有限制的位置产生的逆序对数量。


设 $c_i$ 为扫到第 $i$ 个位置时，$w_{i,j}$ 取到最小值的位置，有多个取最小的。 

注意到用线段树求 $w_{i,j}$ 时，一开始是一堆后缀加的操作，随着 $i$ 的变大，一部分后缀加会变成前缀加，所以 $c_i$ 单调不降，所以不会产生新的逆序对。于是可以直接对于每个 $i$ 求出最小值然后累加。

性质 A：

可以先钦定最小值为 $0$ 的位置为 $0$，然后逐步调整。那么一定是贪心地将最后一个能填 $1$ 的位置改成 $1$。对区间排序后双指针维护一下即可。

性质 C：

可以先贪心地把每个区间的第一个位置设成最小值。

考虑剩下的位置，关键在于有了 $b_i$ 的限制后，$c_i$ 变成了 $[b_i, L]$ 里的最小值，$a_i$ 可能不再单调不降从而产生新的逆序对。

根据性质 B，对于两个位置 $i,j(i<j)$：

如果 $c_j$ 在 $[\max(b_i,b_j), L]$ 这一部分，那么根据性质 B，$c_j \geq c_i$，所以 $a_j \geq a_i$，不会产生新的贡献。



否则，如果 $b_i > b_j$，则一定会产生一个新的逆序对，因为 $a_i \geq b_i$。同时前缀加不会破坏在某个区间内最小值位置不降的性质，所以只需要额外对 $[1, b_i-1]$ 加 $1$。通过这个操作也可以看出来，当前位置无论怎么选，对后面的贡献都是固定的，所以选最小值即可。

然后正常求最小值即可。

正解：

结合性质 A 和性质 C 其实就是正解了。对于最小值相同的区间，先从后往前扫，如果这个区间内已经有数取到最小值，那么跳过，否则将区间内第一个能取到最小值的数设成最小值。然后按照性质 C 来做就好了。

时间复杂度 $O(n\log n)$。

代码：

```cpp
#include <bits/stdc++.h>
#define rep(i, f, t) for(int i(f); i <= t; ++i)
#define re(i, t) for(int i(1); i <= t; ++i)
#define per(i, t, f) for(int i(t); i >= f; --i)
#define pe(i, t) for(int i(t); i >= 1; --i) 
typedef long long ll; 
using namespace std;
typedef pair <int, int> pii;
#define pb push_back
#define fi first
#define se second
#define ix(l, r) ((l + r) | (l != r))
#define ls (ix(l, mid))
#define rs (ix(mid + 1, r))
#define mp(i, j) (make_pair(i, j))
#define inf (int)(1e9+7) 
bool sT;


namespace IO {
char buf[1 << 21], *p1 = buf, *p2 = buf, buf1[1 << 21];
inline char gc() {return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;}
template<class I>
inline void read(I &x) {x = 0;I f = 1;char c = gc();while (c < '0' || c > '9') {if (c == '-') {f = -1;} c = gc();}while (c >= '0' && c <= '9') {x = x * 10 + c - '0';c = gc();}x *= f;}
template<class I>
inline void write(I x) {if (x == 0) {putchar('0');return;}I tmp = x > 0 ? x : -x;if (x < 0) {putchar('-');}int cnt = 0;while (tmp > 0) {buf1[cnt++] = tmp % 10 + '0';tmp /= 10;}while (cnt > 0)putchar(buf1[--cnt]);}
#define outn(x) write(x), putchar('\n')
#define out(x) write(x), putchar(' ')
} using namespace IO;

const int N = 1e6 + 5;
int T, n, m;
int base[N], len, L;
struct node {
    int l, r, w;
}p[N];

pii q[N];

bool cmp (node x, node y) {
    if(x.l == y.l) return x.r > y.r;
    return x.l < y.l;
}

int lim[N];
vector<pii>vec[N];
int fath[N];

int find (int u) {
    return (fath[u] == u) ? (u) : (fath[u] = find(fath[u]));
}
int a[N];  

struct Tree {
    int tag, mn;
}tr[N<<1];

void pushup (int l, int r) {
    int mid = (l +r) >> 1;
    if(tr[ls].mn < tr[rs].mn) tr[ix(l,r)].mn = tr[ls].mn;
    else tr[ix(l,r)].mn = tr[rs].mn;
}

void pushdown (int l, int r) {
    int mid = (l + r) >> 1;
    int res = tr[ix(l, r)].tag;
    if(res) {
        tr[ls].tag += res, tr[ls].mn += res;
        tr[rs].tag += res, tr[rs].mn += res;
    }
    tr[ix(l, r)].tag = 0;
}

void update (int l, int r, int dl, int dr, int w) {
    if(dl>dr) return ;
    if(dl <= l && r <= dr) {
        tr[ix(l, r)].mn += w;
        tr[ix(l, r)].tag += w;
        return ;
    }
    int mid = (l +r) >> 1;
    pushdown(l, r);
    if(dl <= mid) update(l,mid,dl,dr,w);
    if(dr > mid) update(mid+1,r, dl,dr,w);
    pushup(l,r);
}

int query (int l, int r, int dl, int dr) {
    if(dl>dr) return inf;
    if(dl <= l && r <= dr) return tr[ix(l, r)].mn;
    pushdown(l, r);
    int mid= (l+r)>>1;
    if(dr <= mid) return query(l,mid,dl,dr);
    if(dl > mid) return query(mid+1,r,dl,dr);
    return min(query(l, mid, dl, dr), query(mid + 1, r, dl, dr));
}

void build (int l, int r) {
    tr[ix(l, r)].mn = tr[ix(l, r)].tag = 0;
    if(l == r) { 
        return ;
    }
    int mid = (l+r)>>1;
    build(l,mid),build(mid+1,r);
    pushup(l,r);
}

void work () { 
    sort(p + 1, p + m + 1, cmp);   
    build(1, L);
    ll ans = 0;
    pe(i, n) {
        if(a[i]) {
            ans += query(1, L, a[i], a[i]);
            update(1, L, a[i]+1, L, 1); 
        }
    } 
    re(i, n) { 
        if(a[i]) {
            update(1, L, 1, a[i]-1, 1);
            update(1, L, a[i]+1, L, -1); 
        }
        else {  
            ans += query(1, L, lim[i], L); 
            update(1, L, 1, lim[i]-1, 1);
        }
    }
    outn(ans); 
}

bool cmp2 (pii a, pii b) {
    if(a.fi != b.fi) return a.fi > b.fi;
    return a.se < b.se;
}

int main () {    
    read(T);
    while(T--) {
        read(n),read(m); 
        re(i, m) {
            read(p[i].l), read(p[i].r), read(p[i].w);
            base[i] = p[i].w;
        }
        sort(base + 1, base + m + 1);
        L = len = unique(base + 1, base + m + 1) - (base + 1);
        re(i, m) {
            p[i].w = lower_bound(base + 1, base + len + 1, p[i].w) - base;
            vec[p[i].w].pb(mp(p[i].l, p[i].r));
        }   
        re(i, n+1) fath[i] = i, lim[i] = 1, a[i] = 0;
        bool flag = 0;
        pe(i, len) {
            int top = 0; 
            sort(vec[i].begin(), vec[i].end(), cmp2); 
            int mn = inf;
            for(auto res : vec[i]) {
                if(mn <= res.se) {
                    continue;
                } 
                mn = res.se;
                q[++top] = res;
            }  
            int lst = inf;
            re(j, top) {
                pii res = q[j];
                int l = res.fi, r = res.se;
                if(lst <= q[j].se) continue;
                int now = find(l);
                if(now > r) {
                    flag = 1;
                    break;
                } 
                a[now] = i;
                lst = now;
            }
            for(auto res : vec[i]) {
                int l = res.fi, r = res.se;
                int now = find(l); 
                while(now <= r) {
                    lim[now] = i;
                    fath[find(now)] = find(now + 1);
                    now = find(now);
                }    
            }
        }
        re(i, len) vec[i].clear();
        if(flag) {
            outn(-1);
            continue;
        } 
        work();  
    }
    return 0;
}
```


---

## 作者：syzf2222 (赞：1)

不太困难的一道题，即使我鸽掉模拟赛想了一上午。

意识到我们只会填给定的那些 $V_i$，填其他的数含义不大。于是可以离散化。

首先考虑性质 B，即已经确定了一些单点其余随意填。考虑我们一定填的是单调不降的，不然我们可以交换相邻逆序对答案不会变劣。我们希望贪心地将每个位置都取到最小值，我们将每个位置取最小的取到最小值的数。尝试证明这是单调不降的，考虑若存在相邻两个位置分别取 $x,y$ 但 $x>y$，则把 $x$ 变为 $y$ 和把 $y$ 变为 $x$ 总有一个会变优。

然后考虑性质 C，显然会把 $V_i$ 放在区间的第一个。相当于转化为一些点值已经确定，一些点不小于一个数，然后求解。我们容易感受到，还是类似 B 中每次选择不小于限制的最小的取到最小值的数，我不会证，但是考场上可以拍。考虑若有一个更优的选法在一个位置上选了一个比我选的数 $x$ 更小的数 $y$，这个更优的选法中的这个位置往后的所有 $[y,x]$ 的数都变成 $x$ 是不劣的。这是因为，$x$ 是当前最小的能取到最小值的数，也就是 $\forall y<x$，逆序对都会增加，那么我们把 $[y,x)$ 中的数变为 $x$ 逆序对显然就会减少。感觉很聪明。

最后考虑性质 A。如果要求是 $1$ 那整个区间都是 $1$ 了。现在只考虑 $0$ 的区间，我们希望把每个区间的 $0$ 尽量往前放。首先如果两个区间包含了，则大区间是不必要的。那么此时考虑按照左端点从后往前排序，左端点最后的区间显然 $0$ 就放在左端点上，然后依次考虑，如果区间内已经有 $0$ 了那么就没有限制了，否则 $0$ 放在左端点上。然后就转化成了 B。

正解就是结合一下 AC。容易把这些恰好是最小值的位置像 A 一样搞出来，容易算出其他位置的最小值，然后就是 C 了。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
const int mod=1e9+7;
const int inf=1e9;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
int T,n,m,b[maxn],tot;
struct node{int l,r,v;}L[maxn];
struct sgt1{int vl,laz;}tr1[maxn<<2];int Mn[maxn];
inline int cmp(node x,node y){
	if(x.v!=y.v)return x.v<y.v;
	return x.l>y.l;
}
inline void build(int h,int l,int r){
	tr1[h].laz=-1;tr1[h].vl=0;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(h<<1,l,mid);build(h<<1|1,mid+1,r);
}
inline void pushup(int h,int z){
	tr1[h].laz=tr1[h].vl=z;
}
inline void pushdown(int h){
	if(tr1[h].laz==-1)return;
	pushup(h<<1,tr1[h].laz);
	pushup(h<<1|1,tr1[h].laz);
	tr1[h].laz=-1;
}
inline void modify1(int h,int l,int r,int x,int y,int z){
	if(l>y||r<x)return;
	if(l>=x&&r<=y)return pushup(h,z),void();
	int mid=(l+r)>>1;pushdown(h);
	modify1(h<<1,l,mid,x,y,z);
	modify1(h<<1|1,mid+1,r,x,y,z);
	tr1[h].vl=min(tr1[h<<1].vl,tr1[h<<1|1].vl);
}
inline void getmn(int h,int l,int r){
	if(l==r)return void(Mn[l]=tr1[h].vl);
	int mid=(l+r)>>1;pushdown(h);
	getmn(h<<1,l,mid);getmn(h<<1|1,mid+1,r);
}
int A[maxn];
inline int query1(int h,int l,int r,int x,int y){
	if(r<x||tr1[h].vl>y)return n+1;
	if(l==r)return l;
	int mid=(l+r)>>1;
	if(l>=x){
		if(tr1[h<<1].vl<=y)return query1(h<<1,l,mid,x,y);
		return query1(h<<1|1,mid+1,r,x,y);
	}else{
		int pos=query1(h<<1,l,mid,x,y);
		if(pos<=n)return pos;
		return query1(h<<1|1,mid+1,r,x,y);
	}
}
#define pii pair<int,int>
#define fi first
#define se second
#define mkp make_pair
#define pb push_back
struct sgt2{int mn,laz,pos;}tr[maxn<<2];
inline void build1(int h,int l,int r){
	tr[h]=(sgt2){0,0,l};if(l==r)return;
	int mid=(l+r)>>1;
	build1(h<<1,l,mid);build1(h<<1|1,mid+1,r);
}
inline sgt2 merge(sgt2 x,sgt2 y){
	sgt2 res;res.laz=0;
	res.mn=min(x.mn,y.mn);
	res.pos=(x.mn==res.mn)?x.pos:y.pos;
	return res;
}
inline void pushup1(int h,int z){
	tr[h].laz+=z;tr[h].mn+=z;
}
inline void pushdown1(int h){
	if(!tr[h].laz)return;
	pushup1(h<<1,tr[h].laz);
	pushup1(h<<1|1,tr[h].laz);
	tr[h].laz=0;
}
inline void modify(int h,int l,int r,int x,int y,int z){
//	if(h==1)printf("modify x=%d y=%d z=%d\n",x,y,z);
	if(l>y||r<x||x>y)return;
	if(l>=x&&r<=y)return void(pushup1(h,z));
	int mid=(l+r)>>1;pushdown1(h);
	modify(h<<1,l,mid,x,y,z);
	modify(h<<1|1,mid+1,r,x,y,z);
	tr[h]=merge(tr[h<<1],tr[h<<1|1]);
}
inline sgt2 query(int h,int l,int r,int x){
	if(r<x)return (sgt2){inf,0,inf};
	if(l>=x)return tr[h];
	int mid=(l+r)>>1;pushdown1(h);
	return merge(query(h<<1,l,mid,x),query(h<<1|1,mid+1,r,x));
}
#define ll long long
int Tr[maxn];
inline void bl(int h,int l,int r){
	printf("l=%d r=%d mn=%d pos=%d\n",l,r,tr[h].mn,tr[h].pos);
	if(l==r)return;pushdown1(h);int mid=(l+r)>>1;
	bl(h<<1,l,mid);bl(h<<1|1,mid+1,r);
}
inline void solve(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		L[i].l=read(),L[i].r=read();
		L[i].v=b[i]=read();
	}sort(b+1,b+1+m);
	tot=unique(b+1,b+1+m)-b-1;
	for(int i=1;i<=m;i++)
		L[i].v=lower_bound(b+1,b+1+tot,L[i].v)-b;
	build(1,1,n);build1(1,1,tot);
//	bl(1,1,tot);
	sort(L+1,L+1+m,cmp);
//	for(int i=1;i<=m;i++)
//		printf("%d %d %d\n",L[i].l,L[i].r,L[i].v);
	for(int i=1;i<=m;i++)
		modify1(1,1,n,L[i].l,L[i].r,L[i].v);
	getmn(1,1,n);int flg=1;//puts("ok");
//	for(int i=1;i<=n;i++)
//		printf("%d ",Mn[i]);puts("");
	for(int i=1;i<=n;i++)A[i]=0;
	for(int i=1,j;i<=m;i=j+1){
		j=i;while(j<m&&L[j+1].v==L[i].v)++j;
//		printf("i=%d j=%d\n",i,j);
		int las=n+1;
		for(int k=i;k<=j;k++){
			if(las<=L[k].r)continue;
			int pos=query1(1,1,n,L[k].l,L[k].v);
			if(pos>L[k].r){flg=0;break;}
			A[pos]=L[k].v;
			modify1(1,1,n,pos,pos,inf);
			modify(1,1,tot,L[k].v+1,tot,1);
			las=pos;
		}if(flg==0)break;
	}
	//puts("out");
	if(!flg)return puts("-1"),void();
//	for(int i=1;i<=n;i++)
//		printf("%d ",A[i]);puts("");
//	bl(1,1,tot);
	for(int i=1;i<=n;i++)
		if(A[i]){
			modify(1,1,tot,A[i]+1,tot,-1),modify(1,1,tot,1,A[i]-1,1);
//			printf("i=%d\n",i);bl(1,1,tot);
		}else{
			A[i]=query(1,1,tot,Mn[i]).pos;
			modify(1,1,tot,1,A[i]-1,1);
		}
//	for(int i=1;i<=n;i++)
//		printf("%d ",A[i]);puts("");
//	puts("over");
	for(int i=1;i<=tot;i++)Tr[i]=0;ll ans=0;
	for(int i=n;i>=1;i--){
		for(int j=A[i]-1;j;j-=j&(-j))ans+=Tr[j];
		for(int j=A[i];j<=tot;j+=j&(-j))++Tr[j];
	}printf("%lld\n",ans);
}
int main(){
	freopen("P8500.in","r",stdin);
	freopen("P8500.out","w",stdout);
	T=read();
	while(T--)solve();
	return 0;
}
```

深深地感到自己的弱小。

---

## 作者：hexagon (赞：1)

这道题的子任务有很大的启发性，故可以从子任务入手。

首先交换次数就是逆序对。

对于 B 性质，相当于是确定了一些位置的值，然后其它位置的值不确定，要使逆序对最小。那么对于所有不确定位置，**它们的值一定是不降的**。因为如果存在两个 $i,j$ 满足 $a_i>a_j$，则交换 $a_i,a_j$ 显然会使答案变小。这说明了不确定位置间是不会贡献逆序对的，也就意味着**每个位置填什么都可以独立决策**（与其它不确定位置填什么无关），对于每个位置我们直接选择一个代价最小的填入即可。

对于 A 性质，序列中一定只可能填 $0$ 或 $1$。对于限制 $(l,r,1)$ 说明了这个区间中全是 $1$，而对于限制 $(l,r,0)$ 则说明区间中至少要有一个 $0$，现在要使逆序对尽量小，我们可以用贪心解决：先把那些一定是 $1$ 的位置填上，考虑对于最终的序列，一个 $0$ 的贡献是左侧 $1$ 的个数。故我们可以把所有限制 $(l,r,0)$ 按照左端点从大到小排序，如果当前限制区间中已经有 $0$，则这个限制就合法了；如果没有 $0$，那么把区间中**最靠左的一个还没填的数**填成 $0$ 一定最优（感性理解：因为这样既可以让后面的限制区间尽可能包含 $0$，也可以让这个 $0$ 的贡献尽量小）。这样就已经满足所有限制了，现在还剩下一些位置可以任意填，要使逆序对最小。这就回到了 B 性质。

然后考虑原问题，我们把所有限制区间按照 $v$ 从大到小依次处理。对于最大的 $v$，显然这些限制涉及到位置的值就是 $v$。假设现在处理到 $v=i$，则我们把所有 $v=i$ 的限制拿出来，按照左端点从大到小排序，对于当前限制 $(l,r,i)$：

- 若 $[l,r]$ 中已经有一个数是 $i$，则可以忽略。
  
- 若 $[l,r]$ 中还没有数是 $i$，则要填一个。与性质 A 相同，我们填 $i$ 的位置要尽量靠左。所以我们就将 $i$ 填在最靠左的**没有被任何 $v$ 大于 $i$ 的限制覆盖**的位置，具体实现时可以用并查集。
  

于是现在就满足了所有限制，然后要对其它未确定的位置填数，使得逆序对最小。与性质 B 不同的是，这里对于未确定的位置增加了一个**下界**，这使得问题变得比性质 B 更加复杂，因为上文中“不确定位置不降”的性质就没有了。

我们记一个序列 $b_i$，若 $i$ 已经确定了，则 $b_i=a_i$，否则 $b_i$ 为 $i$ 位置的下界。

考察两个未确定的位置 $i,j$ （$i<j$）（这一部分讨论画个图会更清晰）：

- $b_i\leq b_j$，则一定有 $a_i<a_j$。因为如果 $a_i>a_j$，交换后依然满足下界且答案更优。
  
- $b_i>b_j$：
  
  1. 若 $a_j\geq b_i$，则一定有 $a_i<a_j$。因为如果 $a_i>a_j$，交换后依然满足下界且答案更优。
    
  2. 若 $b_j\leq a_j<b_i$，则一定有 $a_i>a_j$（显然），会产生 $1$ 的贡献。注意这里 $1$ 的贡献只和 $a_j$ 的取值有关，故我们把它看作 $j$ 的贡献。
    

这里的讨论说明了**对于一个未确定位置，它与其它位置的贡献只和自己的取值有关**，和其它不确定位置具体取什么值无关，于是可以对每个位置独立决策。

具体来说，我们从小到大遍历每一个不确定的位置 $i$，并维护数组 $c_x$ 表示当 $a_i=x$ 时会产生多少贡献，考虑 $c_x$ 应该怎么得到：

- 若 $a_j$ 已经确定且 $j<i$，则 $c_{[1,a_j-1]}$ 加 $1$。
  
- 若 $a_j$ 已经确定且 $j>i$，则 $c_{[a_j+1,inf]}$ 加 $1$。
  
- 若 $a_j$ 未确定且 $j<i$，则 $c_{[1,b_j-1]}$ 加 $1$。
  
- 若 $a_j$ 未确定且 $j>i$，此时的贡献与 $a_i$ 的取值无关，在 $j$ 处计算。
  

然后把 $c$ 中值最小的一项的下标填入 $a_i$ 即可，这里的 $c$ 可以用一棵线段树维护。

时间复杂度 $O(n\log n)$。

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P8500)

**题目大意**

> 给定序列 $a_1\sim a_n$，有 $m$ 个限制，形如 $\min a[l,r]=V$，求一个满足条件的序列 $a$ 最小化逆序对数。
>
> 数据范围：$n,m\le 10^6$。

**思路分析**

首先发现我们填的所有数一定是某个 $V$，否则换成小于等于当前数的一个 $V$ 一定严格更优。

先从所有 $l=r$ 开始，此时相当于一个被确定了若干位的序列，很显然可以任意填的位置一定是单调不降的，否则排序后肯定更优。

从前往后确定每个位置，我们只需要最小化未填元素和已填元素之间的逆序对，这个问题和未填元素之间的取值无关，只需要每个未填元素填贪心最优解即可（多解取最小）。

容易发现越靠后的位置填的数一定更大，因为代价函数上填更小的数代价会严格变大。

然后考虑所有 $[l,r]$ 都不交的情况，很显然我们要在每个 $[l,r]$ 中选一个位置填 $V$，我们可以对每个区间内部升序排列，不影响对外部的逆序对。

因此注意到区间所有位置填的都  $\ge V$，那么最小值 $V$ 一定恰好落在 $a_l$ 上。

然后就是要解决一个有下界限制的问题，依然考虑贪心，从前往后动态维护每个位置上填数的代价函数，每个位置都贪心取最优解，如果有多个则取最小值。

很显然我们不会选一个比贪心解 $x$ 更大的值，因为更大的值对后续代价函数的增加量也更大，我们要说明取的数 $y$ 不会小于贪心解。

如果 $y<x$，那么直接把值域在 $[y,x]$ 中的元素推平成 $x$，这些元素内部的逆序对数会减少，而这些元素和已确定元素之间的逆序对数也会变少，因为每个位置的最优解一定 $\ge x$。

因此我们可以依然可以用贪心解决这个问题。

接下来回到原问题，我们要考虑如何确定每个区间中填 $V$ 的数的位置，然后又转化为前一个特殊性质的贪心问题。

倒序扫描 $V$，先去除所有有包含关系的限制，然后我们要贪心使得填 $V$ 的数越靠左越好。

从后往前扫描即可，每个区间如果未满足就把 $V$ 放在左端点，容易证明此时对后续区间的选取也是最优的。

注意删去被标记为 $\ge V$ 的位置，用线段树维护剩下的贪心即可。

时间复杂度 $\mathcal O((n+m)\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
typedef array<int,2> pii;
const int MAXN=1e6+5;
int n,m,q;
struct SegmentTree {
	pii tr[MAXN<<2];
	int tg[MAXN<<2];
	void adt(int p,int k) { tr[p][0]+=k,tg[p]+=k; }
	void psd(int p) { adt(p<<1,tg[p]),adt(p<<1|1,tg[p]),tg[p]=0; }
	void psu(int p) { tr[p]=min(tr[p<<1],tr[p<<1|1]); }
	void init(int l=1,int r=q,int p=1) {
		tr[p]={0,l},tg[p]=0;
		if(l==r) return ;
		int mid=(l+r)>>1;
		init(l,mid,p<<1),init(mid+1,r,p<<1|1);
	}
	void add(int ul,int ur,int k,int l=1,int r=q,int p=1) {
		if(ul>ur) return ;
		if(ul<=l&&r<=ur) return adt(p,k);
		int mid=(l+r)>>1; psd(p);
		if(ul<=mid) add(ul,ur,k,l,mid,p<<1);
		if(mid<ur) add(ul,ur,k,mid+1,r,p<<1|1);
		psu(p);
	}
	pii qry(int ul,int ur,int l=1,int r=q,int p=1)  {
		if(ul<=l&&r<=ur) return tr[p];
		int mid=(l+r)>>1; psd(p);
		if(ur<=mid) return qry(ul,ur,l,mid,p<<1);
		if(mid<ul) return qry(ul,ur,mid+1,r,p<<1|1);
		return min(qry(ul,ur,l,mid,p<<1),qry(ul,ur,mid+1,r,p<<1|1));
	}
}	T;
struct info { int l,r,v; };
vector <info> I[MAXN];
int a[MAXN],dsu[MAXN];
bool up[MAXN];
int find(int x) { return dsu[x]^x?dsu[x]=find(dsu[x]):x; }
void solve() {
	scanf("%d%d",&n,&m);
	vector <info> lims(m);
	vector <int> vals;
	for(auto &e:lims) scanf("%d%d%d",&e.l,&e.r,&e.v),vals.push_back(e.v);
	sort(vals.begin(),vals.end());
	vals.erase(unique(vals.begin(),vals.end()),vals.end());
	q=vals.size(),T.init();
	for(auto &e:lims){
		e.v=lower_bound(vals.begin(),vals.end(),e.v)-vals.begin()+1;
		I[e.v].push_back(e);
	}
	iota(dsu+1,dsu+n+2,1);
	for(int i=q;i>=1;--i) {
		vector <int> idx;
		for(auto o:I[i]) for(int x=find(o.l);x<=o.r;x=find(x)) {
			idx.push_back(x),a[x]=i,dsu[x]=x+1;
		}
		sort(idx.begin(),idx.end()),idx.push_back(n+1);
		sort(I[i].begin(),I[i].end(),[&](info x,info y){ return x.l^y.l?x.l>y.l:x.r<y.r; });
		int lst=n+1;
		vector <info> J;
		for(auto o:I[i]) if(o.r<lst) J.push_back(o),lst=o.r;
		sort(J.begin(),J.end(),[&](info x,info y){ return x.l>y.l; }),lst=n+1;
		for(auto o:J) if(lst>o.r) {
			lst=*lower_bound(idx.begin(),idx.end(),o.l);
			if(lst<=o.r) up[lst]=true;
			else return puts("-1"),void();
		}
	}
	ll ans=0;
	for(int i=n;i;--i) if(up[i]) ans+=T.qry(a[i],a[i])[0],T.add(a[i]+1,q,1);
	for(int i=1;i<=n;++i) {
		if(up[i]) T.add(a[i]+1,q,-1),T.add(1,a[i]-1,1);
		else {
			auto z=T.qry(max(a[i],1),q,1);
			ans+=z[0],T.add(1,z[1]-1,1);
		}
	}
	printf("%lld\n",ans);
}
signed main() {
	int cs; scanf("%d",&cs);
	while(cs--) {
		solve();
		for(int i=1;i<=n;++i) a[i]=up[i]=0;
		for(int i=1;i<=q;++i) I[i].clear();
	}
	return 0;
}
```

---

## 作者：SafariMo (赞：0)

[NOI2022 冒泡排序](https://www.luogu.com.cn/problem/P8500)

题目的限制 $l,r,v$ 可以分为两个条件：

- $a_{l\sim r}$ 中含有一个 $v$。
- $a_{l\sim r}\ge v$。

于是可以分为两个子问题：

- 对于每个询问，最优化选定 $a_{i\in [l,r]}=v$。
- 对于没有选定的 $a_i\ge d_i$，最优化选定 $a_i$。

对于第一个子问题：

- 如果 $[l,r]$ 不重，则选定 $a_l=v$ 一定是最优的。
- 考虑相交的情况，令 $l_1\le l_2\le r_1\le r_2$。
   - 如果 $v_1=v_2$，则选定 $l_2$ 最优。
   - 否则和不相交没有区别。

则我们按 $v$ 分类，按 $l$ 从大到小排序，每次使用并查集表示最小的可以被选取的下一个每次更新顺便特判掉无解的情况并且维护 $d$ 数组，维护上一个 $l$ 尽量合并。

对于第二个子问题：

考虑每个 $a_i$ 的贡献，使用线段树维护，每次令 $a_i$ 为让当前逆序对贡献最少的 $k\ge d_i$。

当我们求出所有 $a_i$ 时，就可以使用线段树求出逆序对个数了。    

注意 $v$ 是需要离散化的。

[Submission](https://loj.ac/s/2065775)

---


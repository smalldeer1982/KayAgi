# [NOI2023] 桂花树

## 题目描述

小 B 八年前看到的桂花树是一棵 $n$ 个节点的树 $T$，**保证 $T$ 的非根结点的父亲的编号小于自己**。给定整数 $k$，称一棵 $(n+m)$ 个节点的有根树 $T^{\prime}$ 是繁荣的，当且仅当以下所有条件满足：

1. 对于任意满足 $1 \le i,j \le n$ 的 $(i,j)$，在树 $T$ 和树 $T^{\prime}$ 上，节点 $i$ 和 $j$ 的最近公共祖先编号相同。
2. 对于任意满足 $1 \le i,j \le n + m$ 的 $(i,j)$，在树 $T^{\prime}$ 上，节点 $i$ 和 $j$ 的最近公共祖先编号不超过 $\max(i,j)+k$。

**注意题目中所有树的节点均从 $1$ 开始编号，且根结点编号为 $1$。$T^{\prime}$ 不需要满足非根结点的父亲编号小于自己。**

小 B 想知道有多少棵 $(n+m)$ 个节点的树是繁荣的，认为两棵树不同当且仅当存在某一个节点在两棵树上的父亲不同。你只输出方案数在模 $(10^9+7)$ 意义下的值。

## 说明/提示

**【样例解释 #1】**

对于样例中的第一组测试数据，有三棵合法的树，其每个节点的的父亲构成的序列 $\{f_2,f_3\}$ 分别为 $\{1,1\}$、$\{3,1\}$、$\{1,2\}$。注意这组测试数据的第二行为空行。

对于样例中的第二组、第三组测试数据，共有 $16$ 棵树满足第一个条件，其中只有父亲序列为 $\{4,4,1\}$ 的树在第三组测试数据中不满足第二个条件。

**【样例解释 #2】**

该组样例满足 $n \le 100$，五组测试数据中 $m$ 分别不超过 $0, 1, 1, 2, 2$。

**【样例解释 #3】**

该组样例满足 $k = 0$，五组测试数据中前两组测试数据满足 $n = 1$，第一、三、四组测试数据满足 $n, m \le 100$。

**【样例解释 #4】**

该组样例前两组测试数据满足 $n = 1$，第一、三、四组测试数据满足 $n, m \le 100$。

**【数据范围】**

对于所有测试数据保证：$1 \le t \le 15$，$1 \le n \le 3 \times 10^4$，$0 \le m \le 3000$，$0 \le k \le 10$，$1 \le f_i \le i - 1$。

| 测试点编号 | $n \le$ | $m \le $| $k \le $|
| :--: | :--: | :--: | :--: |
| $1,2$ | $4$|$4$|$10$|
|$3$|$3\times 10^4$|$0$|$10$|
|$4$|$10^2$|$1$|$10$|
|$5$|$3 \times 10^4$|$1$|$10$|
|$6$|$10^2$|$2$|$10$|
|$7$|$3\times 10^4$|$2$|$10$|
|$8,9$|$1$|$10^2$|$0$|
|$10$|$1$|$3,000$|$0$|
|$11$|$1$|$10^2$|$10$|
|$12$|$1$|$3,000$|$10$|
|$13,14$|$10^2$|$10^2$|$0$|
|$15,16$|$3\times 10^4$|$3,000$|$0$|
|$17,18$|$10^2$|$10^2$|$10$|
|$19,20$|$3\times 10^4$|$3,000$|$10$|

## 样例 #1

### 输入

```
0 3
1 2 1

2 2 1
1
2 2 0
1```

### 输出

```
3
16
15```

## 样例 #2

### 输入

```
见附件中的 tree/tree2.in。```

### 输出

```
见附件中的 tree/tree2.ans。```

## 样例 #3

### 输入

```
见附件中的 tree/tree3.in。```

### 输出

```
见附件中的 tree/tree3.ans。```

## 样例 #4

### 输入

```
见附件中的 tree/tree4.in。```

### 输出

```
见附件中的 tree/tree4.ans。```

# 题解

## 作者：Rainbow_qwq (赞：53)

我觉得这是 adhoc 好题啊，但是放在场上就区分上去了一些会猜 $k=0$ 结论的选手，区分度比较怪。

下面来复原一下考场想法。

----

称 $>n$ 编号的点为新点。

题目的限制很奇怪，首先思考一下原树对最终树形成了什么限制。

经过手玩得出的结论是：新点似乎只能插在原树的某条边上，或者塞在原树节点下面，那么**原树是最终树的一棵虚树**。

那新点形成若干个子树、若干条链，能不能设计一个子树合并的 dp 呢？试了试，貌似不太行。

那就从部分分一个一个考虑。先考虑 $n=1,k=0$。

子树合并不太行时因为限制了每一个 $\text{lca}$，想一想能否设计一个符合题目限制的状态？

我们的限制是 $\text{lca}(i,j)\le \max(i,j)+k$. 

考虑把 $\max$ 去掉，一次一次地加点并满足：对于 $1\le j<i,\text{lca}(i,j)\le i+k$。

发现形式一下子变得比较好看，考虑一下 $k=0$ 的情况。

此时要求 $1\le j<i,\text{lca}(i,j)\le i$.

那么插入点 $i$ 时，只能插在某条边上，或者某个点下面开一个新点，方案数为 $2size-1$。接下来会递归成 $n\to n+1$ 的同等问题。

那么 $k=0$ 问题的答案就很显然了：

$$\prod_{i=n}^{n+m-1}(2i-1)$$

~~当然有的人暴力找规律就找出这一步了。~~

---

用同样的思想考虑 $k>0$。

考虑从小到大一个一个插入点。此时不一样的是，一个点 $i$ 和其他点的 $\text{lca}$ 可能在 $[i+1,i+k]$。

也就是可以在现在树上的一条边上衍生出一个叶子，新加两个点，一个点是 $i$，一个点在 $[i+1,i+k]$ 之间且未确定。

![](https://cdn.luogu.com.cn/upload/image_hosting/maqetj2v.png)

再形式化的描述一下，发现我们考虑的正是 $[1,i]$ 的虚树，而且虚树上的点必须在 $[1,i+k]$ 内！

也就是说，空白需要填的点只有 $[i+1,i+k]$ 这些可能，最多 $k$ 个。

那就可以进行状压 dp，设 $f(i,S)$ 表示插入了 $i$ 个点，并且前 $k$ 次加入的未被填掉的白点用一个状态 $S$ 表示。

转移有以下几种：

- 将 $i+1$ 插入在边上或挂在点下面，系数 $2size-1$。
- 将 $i+1$ 从一条边上衍生出来（加两个点），加入一个空白点，系数 $size-1$。
- 用 $i+1$ 填上一个空白点。

虚树节点 $size=i+\text{popcount}(S)$，那么就做完了。

时间复杂度 $O(Tmk2^k)$，代码用了 `ull` 加起来一起取模卡常。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(int i=(a);i>=(b);--i)
#define ull unsigned long long

#define mod 1000000007
#define maxn 200005
#define inf 0x3f3f3f3f

int n,m,k,fa[maxn];
ull f[1<<10|5],g[1<<10|5];
int popc[1<<10|5];

void work()
{
	n=read(),m=read(),k=read();
	For(i,2,n)fa[i]=read();
	if(k==0){
		ull res=1;
		For(i,n,n+m-1)res=res*(i*2-1)%mod;
		cout<<res<<"\n";
		return;
	}
	memset(f,0,sizeof f),f[0]=1;
	int mxs=1<<k;
	For(i,n,n+m-1){
		For(s,(1<<(k-1)),(1<<k)-1)
			g[(s<<1)&(mxs-1)]+=f[s];
		For(s,0,(1<<(k-1))-1){
			Rep(j,k-2,0)
				if(s>>j&1) g[(s^(1<<j))<<1]+=f[s];
			g[s<<1]+=f[s]*((i+popc[s])*2-1);
			g[s<<1|1]+=f[s]*(i+popc[s]-1);
		}
		For(s,0,mxs-1) f[s]=g[s]%mod,g[s]=0;
	}
	cout<<f[0]<<"\n"; 
}

signed main()
{
	For(i,1,(1<<10)-1)popc[i]=popc[i>>1]+(i&1);
	read();int T=read();
	while(T--)work();
	return 0;
}
```

---

## 作者：Alex_Wei (赞：27)

### [P9479 [NOI2023] 桂花树](https://www.luogu.com.cn/problem/P9479)

神题，太神了。

第一个条件等价于 $1\sim n$ 构成的虚树等于它本身。

第二个条件等价于对每个 $1\leq i\leq n + m$，$1\sim i$ 构成的虚树中，不能有编号大于 $i + k$ 的结点。

考虑按编号从小到大加入结点并维护当前前缀的虚树。注意到我们只关心虚树上每个未确定的结点不能超过多少，而每加入一个结点最多加入一个未确定的结点，因此这个信息可以用 $k$ 位二进制数 $S$ 表示。

对当前 $i, S$，虚树结点数为 $c = i + \mathrm{popcount}(S)$。考虑加入 $i + 1$ 时对虚树形态的影响，有四种转移方式：

- 将 $i + 1$ 挂在一个叶子上，方案数为 $c$。
- 将 $i + 1$ 插入一条边，方案数为 $c - 1$。
- 将 $i + 1$ 作为某个未确定的结点填入，枚举 $S$ 的每个 $1$ 转移。
- 对某条边进行 “人” 字形分裂，即从某条边旁逸斜出一根枝条，则除了 $i + 1$，还会加入一个未确定的结点，且它的编号不大于 $i + k + 1$。

时间复杂度 $\mathcal{O}(mk2 ^ k)$，瓶颈在第三种转移。洛谷评测机速度较慢，需要使用 lowbit 优化减半枚举常数。

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using pdd = pair<double, double>;
using ull = unsigned long long;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;
// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
mt19937_64 rnd(1064);
int rd(int l, int r) {
  return rnd() % (r - l + 1) + l;
}

constexpr int mod = 1e9 + 7;
void addt(int &x, int y) {
  x += y, x >= mod && (x -= mod);
}
int add(int x, int y) {
  return x += y, x >= mod && (x -= mod), x;
}
int ksm(int a, int b) {
  int s = 1;
  while(b) {
    if(b & 1) s = 1ll * s * a % mod;
    a = 1ll * a * a % mod, b >>= 1;
  }
  return s;
}

constexpr int Z = 1e6 + 5;
int fc[Z], ifc[Z];
int bin(int n, int m) {
  if(n < m) return 0;
  return 1ll * fc[n] * ifc[m] % mod * ifc[n - m] % mod;
}
void init_fac(int Z) {
  for(int i = fc[0] = 1; i < Z; i++) fc[i] = 1ll * fc[i - 1] * i % mod;
  ifc[Z - 1] = ksm(fc[Z - 1], mod - 2);
  for(int i = Z - 2; ~i; i--) ifc[i] = 1ll * ifc[i + 1] * (i + 1) % mod;
}

void cmin(ll &x, ll y) {
  x = x < y ? x : y;
}

// ---------- templates above ----------

int n, m, k, f[1 << 10], g[1 << 10];
void mian() {
  cin >> n >> m >> k;
  for(int i = 2, f; i <= n; i++) cin >> f;
  memset(f, 0, sizeof(f)), f[0] = 1;
  for(int i = 0; i < m; i++) {
    memset(g, 0, sizeof(g));
    for(int S = 0; S < 1 << k; S++) {
      if(!f[S]) continue;
      int T = S;
      while(T) {
        int j = T & -T;
        int nxt = (S ^ j) << 1;
        if(nxt < (1 << k)) addt(g[nxt], f[S]);
        T ^= j;
      }
      int nxt = S << 1;
      int c = n + i + __builtin_popcount(S);
      if(nxt < (1 << k)) {
        addt(g[nxt], 1ll * f[S] * (c * 2 - 1) % mod);
        addt(g[nxt | 1], 1ll * f[S] * (c - 1) % mod);
      }
    }
    swap(f, g);
  }
  cout << f[0] << "\n";
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int c, T = 1;
  cin >> c >> T;
  while(T--) mian();
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
```

---

## 作者：strcmp (赞：13)

省流：没进弱省省队的场外选手的乱胡。

好题，赛时区分度不是很好，但瑕不掩瑜，这题的部分分对正解有很大的启发。

------------

**题目大意：** 给定一颗 $n$ 个结点的树 $\text T$，问有多少棵有 $n+m$ 个结点的树 $\text T'$，满足：

- 对于 $1 \le i,\,j \le n$，都有 $\operatorname{LCA}(i,\,j) = \operatorname{LCA'}(i,\,j)$，即不大于 $n$ 的结点对 $i,\,j$ 在两棵树上的最近公共祖先相同。

- 对于 $1 \le i,\,j \le n + m$，都有 $\operatorname{LCA} \le \max(i,\,j) + k$，即所有结点对 $i,\,j$ 的最近公共祖先的编号不超过 $\max(i,\,j) + k$。

给出答案对 $(10^9 + 7)$ 取模的结果，**保证 $\text{T}$ 的非根结点的父亲编号小于自己。**

以下将 $\text{T}$ 称为“原树”。

------------

这题部分分设计的很好，不妨分别考虑每一个部分分。

### Subtask1（$n,\,m \le 4$）

最基础的暴力分，直接搜索即可。

### Subtask2（$m = 0$）

我们关心是否有非原树的 $n$ 个结点的树满足条件。

考虑这棵满足条件的树 $\text T'$ 的根结点，它必然跟原树一样，也是 $1$。否则我们设它的根结点是 $u \ne 1$，取 $\operatorname{LCA}'(u,\,1)$，原树上 $\operatorname{LCA}(u,\,1)$ 必然为 $1$，$\text T'$ 上 $\operatorname{LCA}'(u,\,1)$ 必然为 $u$，不满足条件，矛盾。

我们继续将其递归到根结点的每一个子树，最后容易得知 $\text T'$ 的所有子树的根结点都能与原树一一对应。

所以 $\text T'$ 必然只会是原树，$m = 0$ 时答案为 $1$。

因为各个子树是否合法互相独立，这启发我们：**可以将询问转化为 $m$ 个结点在原树上的插入。**

### Subtask3（$m = 1$）

根据 $m = 0$ 时的结论，我们考虑这个加入的点能插入在原树上的哪里。

我们发现此时我们只有三种可能的插入方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/v1mm3a8i.png)

只有第三种会产生新的 $\text{LCA}$，而产生了新的 $\text{LCA}$，其分岔出的子结点肯定都是原树上的，必然不合法。

所以我们只能在边上插入，或者给每个结点挂一个新的叶子结点。

边数是 $n - 1$，结点数是 $n$，答案就是 $2n - 1$。

### Subtask4（$m = 2$）

我们又多了一种新的可能合法的插入方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/kism5i9o.png)

分两种情况。

- $k = 0$，此时我们只能在原树上进行原来的插入方式，因为我们必须满足挂着 $i$ 结点的结点编号在 $i + 1$ 以上，而因为 $k = 0$，对于这个挂着 $i$ 的未知结点，其儿子中任意原树结点 $j$。$\max(i,\,j)$ 必然小于 $i + 1$，所以说我们仍然无法使用这种插入方式。此时乘上之前插入结点的方案数 $2n - 1$，插入新结点后新增一条边一个点，现在插入方案数是 $2n + 1$，根据乘法原理，答案为 $(2n - 1)(2n + 1) = 4n^2 - 1$。

- $k \ge 1$，此时我们对于每一条边都可以使用这种新的插入方式，我们新增的答案为 $n - 1$，总答案为 $(4n^2 + n - 1)$。



### Subtask5（$k = 0$）

根据 Subtask4 的 $k = 0$ 的讨论，递归一下，我们无论如何都只能进行原来合法的两种插入方式，答案为 $\prod\limits_{i = n}^{n + m - 1}(2i - 1)$。

### Subtask6（$n = 1$）

这个基本就是正解，所以我们将其放到正解来做。

说句闲话，如果您按照之前的步骤一步步的解决部分分，现在已经有了 $70$ 的高分。刚才的部分分对于一个能够冲进 NOI 的选手，推导以及写代码的时间不会超过 $2\text{h}$。如果您的 T1 正常发挥拿下，理论上 T3 也至少有 $1\text{h}$ 以上的时间，即使只拿了 $36\text{pts}$ 的暴力容斥，也有 $206\text{pts}$，已经离队线只有十多分了。

这告诉我们在大型考试上冷静分析部分分的重要性。

### 正解

$k \le 10$ 给我们很大的提示，这说明时间复杂度中完全能承受 $m2^k$ 这个量级的复杂度。

这时候我们继续搬出这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kism5i9o.png)

我们可以给 $[i + 1,\,i + k]$ 这个没有确定的结点上一个空白的结点，之后要插入的时候直接将当前结点接在这个空白结点就行了，空白结点的取值只可能有 $k - 1$ 种。	

$[i + 1,\,i + k]$ 这个状态太小了，以至于我们可以进行指数级的操作。

考虑设计一个状压 dp。

$f_{i,\,\text S}$ 表示插入到第 $i$ 个结点时，$[i + 1,\,i + k]$ 中**未填上的空白结点**的集合为 $\text{S}$ 的合法方案数。

第 $i$ 次插入时，当前树的结点的数量为 $n + i - 1 + |\text{S}|$，边数比点数少 $1$，我们设 $t = n + i - 1 + |\text{S}|$。

- 将结点插入到一条边上或者点上，$f_{i + 1,\,\text{S}\backslash\{i\}} \leftarrow f_{i + 1,\,\text{S}\backslash\{i\}} + f_{i,\text{S}} \times (2t - 1)$。

- 执行插入 $i$ 和一个空白结点的操作，$f_{i + 1,\,\text{S}\backslash\{i\}\cup\{i+k\}} \leftarrow f_{i + 1,\,\text{S}\backslash\{i\}\cup\{i+k\}} + f_{i,\text{S}} \times (t - 1)$。

- 填入一个空白结点，$\forall j \in \text{S},\,f_{i + 1,\,\text{S}\backslash\{i\}\backslash\{j\}} \leftarrow f_{i + 1,\,\text{S}\backslash\{i\}\backslash\{j\}} + f_{i,\text{S}}$。

最终答案为 $f_{m,\,\emptyset}$，转移与原树的形态没有任何关系，时间复杂度 $\Theta(Tmk2^k)$，可以通过。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define re register
typedef unsigned long long int ll;
const int maxn = 1e4 + 10;
const ll mod = 1e9 + 7;//
int n, m, k, x; ll f[maxn], g[maxn];
int main() {
	int c, t;
	scanf("%d%d", &c, &t);
	while (t--) {
		scanf("%d%d%d", &n, &m, &k);
		for (int i = 2; i <= n; i++)scanf("%d", &x);
		if (k == 0) {
			ll ans = 1;
			for (int i = n; i <= n + m - 1; i++)ans = ans * (ll)(2 * i - 1) % mod;
			printf("%lld\n", ans);
			continue;
		}
		f[0] = 1;
		for (int i = 1; i <= m; i++) {
			memset(g, 0, sizeof(g));
			for (int j = 0; j < (1 << k); j++) {
				if (f[j]) {
					ll w = n + i - 1 + __builtin_popcount(j);
					if ((j << 1) < (1 << k)) {
						g[j << 1] += (2 * w - 1) * f[j];
						g[j << 1 | 1] += (w - 1) * f[j];
					}
					int ls = j;
					while (ls) {
						x = ls & (-ls); ls = ls ^ x; // 删除最低位
						if ((j ^ x) << 1 < (1 << k)) {
							g[(j ^ x) << 1] += f[j];;
						}
					}
				}
			}
			for (int j = 0; j < (1 << k); j++)f[j] = g[j] % mod;
		}
		printf("%lld\n", f[0]);
		memset(f, 0, sizeof(f));
		memset(g, 0, sizeof(g));
	}
	return 0;
}
```

另外申请将时限调到 1s 以上，原题 500ms 在洛谷评测机上压力较大。

upd：修了下公式的错误。

---

## 作者：namelessgugugu (赞：10)

场切了这题，稍微来讲讲赛时思路，希望能有点启发。

#### 题面

给定一颗 $n$ 个点的以 $1$ 为根的树 $T$，点 $i$ 的父亲是 $f_i(f_i < i)$。

给定常数 $m, k$，问有多少个 $n + m$ 个点的以 $1$ 为根的树 $T'$，满足：

 1. $\forall 1 \leq i, j \leq n$，有 $\mathrm{lca}_T(i, j) = \mathrm{lca}_{T'}(i, j)$；
 2. $\forall 1 \leq i, j \leq n + m$，有 $\mathrm{lca}_{T'}(i, j) \leq \max\{i, j\} + k$。
 
其中 $\mathrm{lca}_T(x, y)$ 表示在树 $T$ 上点 $x$ 和点 $y$ 的最近公共祖先。

答案对 $10^9 + 7$ 取模。

有 $t$ 组测试数据。

$1 \leq t \leq 15, 1 \leq n \leq 3 \cdot 10^4, 1 \leq m \leq 3000, 1 \leq k \leq 10$。

#### 题解

以下这些推导都是我考场上的思路，绕了不少弯路。

首先观察条件。发现条件 1 相当于把 $T'$ 中的点 $1$ 到 $n$ 拎出来建虚树会得到 $T$。而条件 2 涉及到两个点编号之间数值的具体比较，不是单纯的相对大小关系。如果使用树形 DP，似乎必须存下子树内所有点的编号，才能保证每个点编号不同，也很难利用 $k \leq 10$ 的条件。这启发让我们从值域方向入手，通过编号从小到大加点解决比较数值的问题。

在原树的基础上加了若干点之后会得到一个虚树，考虑维护虚树相关的信息用来转移。由于虚树需要把每个点对的 $\mathrm{lca}$ 也扔进来，所以树中可能有若干还未确定编号的点，把这种点称为空点。

考虑在这个虚树上增加一个新的点 $x$ 会有什么变化：第一种情况是这个点被放在了虚树中已有的一条边上或成为某个已经存在的节点的儿子，假设当前的树有 $p$ 个点，那这种情况有 $2p - 1$ 中方案。第二种是会在某一条已有的边上新建一个空点，然后自己成为这个空点的儿子，这种方案数是 $p - 1$ 中。第三种是这个点被放入了一个空点，让这个点变成非空点。

可以发现前两种情况都不会违反限制 2，只有第三种情况可能出现违法操作，考虑要记录什么东西才能方便这种情况的转移。

一个直观的想法是：一个空点能被放入 $x$ 当且仅当它有至多一个儿子，使得这个儿子的子树中存在编号 $< x - k$ 的点，而编号位于 $[x - k, x)$ 的点（称这些点为关键点）是很少的，可以考虑记录这 $k$ 个点和当前所有空点的虚树（称这个小虚树为关键虚树）。

但是问题来了，如果这个点放进当前的虚树中时，不在关键虚树上，很难看出关键虚树会变成什么样子，这怎么办呢？

冷静一下，发现如果一个关键点的子树中有编号 $< x - k$ 的非关键点，其实这个点已经没有用处了，所以有用的关键点都是堆在一整颗子树（当然子树里面也可能有些空点）里面的。这样一来只要记录下每个关键点子树的形态，而加入的点如果不在某个关键点子树内就新开一个关键点子树，相当于记录一个森林。

思考一下感觉记录每个空点的限制好像比存树更加简单。发现如果一个空点已经有一个非关键子树的儿子了，那么它的限制也就固定了，就是不超过其他所有儿子的子树中编号最小值 $+k$。于是只需要考虑空点因为加入新点和关键点逐渐变成非关键点导致限制变化的情况了。

再冷静一下，发现一个点的限制从一开始就固定了。这是因为一个空点被建立的时候，恰有两个儿子了，其中一个是一个之前已经存在编号都 $< x$ 的点构成的子树，还有一个是单个叶子 $x$。而由于之后的过程中加入的点编号都 $> x$，所以第一个儿子子树会第一个出现非关键点，此时剩下的儿子子树编号最小值自然就成了 $x$，所以这个空点的限制就是 $\leq x + k$。

于是可以直接 DP，设 $f_{i, j}$ 表示当前加入了编号在 $[n + 1, n + i]$ 中的点，$j$ 是一个 $k$ 位二进制数，第 $d$ 位为 $1$ 表示有一个空点，它上面的点的编号必须 $\leq n + i + d + 1$，直接按一开始讨论的三种情况进行转移即可，第三种转移就在 $j$ 中找一个为 $1$ 的位填上去。最后答案即为 $f_{m, 0}$。

复杂度 $O(tm 2^k k)$，可以通过。

不过最后发现一上来就考虑每个空点的限制就做完了，考虑“关键点子树”之类的东西有点小丑。

#### 代码

因为没拿到考场代码，先咕咕咕一下，马上补上。

---

## 作者：FireBladeMaster (赞：5)

题目等价于两个条件。

1. $T'_{[1,n]}$ 的虚树为 $T$。
2. $T'_{[1,i]}$ 的虚树上的点的编号不超过 $i+k$。

我们从 $T$ 开始依次加入 $n+1,n+2,\cdots,n+m$。

当加入一个点 $i$ 时，虚树形态有以下情况。

1. $i$ 加在虚树的一条边上。
2. $i$ 加在虚树的一个点上作为叶子。
3. $i$ 没加在上面两个位置，此时 $i$ 在虚树上需要预留一条边，在上面增加一个编号 $[i+1,i+k]$ 的父亲。

然后我们进行 dp。设 $dp_{i,S}$ 表示放好了前 $i$ 个点，在加入时预留了 $[i+1,i+k]$ 中集合 $S$ 中的点。转移的时候会发现这个 dp 和树的形态完全无关！

具体转移：

对于 $i$ 如果 $i$ 被预留那么直接把 $i$ 填上去；否则可以以 $2(n+i-1+\operatorname{popcount}(S))-1$ 的系数进行 1 和 2 的转移；或者找到一个不在 $S$ 中的数（未被预留），把他放到一条边上作为虚树的父亲。

总复杂度 $O(Tmk2^k)$。

```cpp
// wo shi huahua
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <queue>
#include <assert.h>
#include <math.h>
#include <set>
#define od(x) printf("%lld",x)
#define odb(x) printf("%lld ",x)
#define odl(x) printf("%lld\n",x)
#define odp(x,y) printf("%lld %lld\n",x,y)
#define int long long
const int mod=1e9+7;
inline int read()
{
    int num=0,f=1;char c=getchar();
    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}
    while(c>47&&c<58)num=num*10+(c^48),c=getchar();
    return num*f;
}
int dp[2][1024];
void mae(int &x,int y){x=x+y;if(x>=mod)x-=mod;}
int me(int x,int y){return x*y%mod;}
signed main()
{
	int ID=read(),T=read();
	while(T--)
	{
		int n=read(),m=read(),k=read();
		for(int i=1;i<n;i++)read();
		memset(dp,0,sizeof(dp));
		dp[0][0]=1;
		for(int i=1;i<=m;i++)
		{
			int c=i&1,d=c^1;
			memset(dp[c],0,sizeof(dp[c]));
			for(int j=0;j<(1<<k);j++)
			{
				int v=dp[d][j];
				if(j&1)mae(dp[c][j>>1],v);
				else
				{
					int u=j>>1;
					mae(dp[c][j>>1],me(v,(n+i-1+__builtin_popcount(j))*2-1));
					// odl
					for(int s=0;s<k;s++)if(!(u>>s&1))
					{
						int o=u^1<<s;
						mae(dp[c][o],me(v,n+i-1+__builtin_popcount(j)-1));
					}
				}
			}
			// for(int j=0;j<(1<<k);j++)odb(dp[c][j]);puts("");
		}
		int res=0;
		odl(dp[m&1][0]);
		
	}
}
```

---

## 作者：EXODUS (赞：4)

# Part 1：前言

超级厉害的数数题，vp 的时候只拿到 70 分就走人了，还是不会计数 dp 啊/kk。

下文将按照我的 vp 时思路，说一下每个部分分（下文称作 Sub）的做法，个人认为对正解有很大的启发意义。

# Part 2：正文

## Sub1：$n,m\leq 4$。

直接搜索即可，时间复杂度 $O(n^{n-2}(n+m)^3)$，反正能过（确信）。

## Sub 2：$m=0$。

现在我们只需要考虑第一个限制。注意到我们可以从每一个叶子出发，每次向上唯一确定两个相邻叶子的父亲（我们定义两个叶子相邻，当且仅当其距离为 $2$），然后删除这两个叶子。若出现找不到相邻叶子的情况，则说明要么只剩下根节点，要么出现了一条单链。对于后一种情况，我们每次确定链底的父亲然后删除链底即可。依此可以唯一确定一颗树。因此当 $m=0$ 的时候，一定有 $T'=T$，故答案为 $1$。

## Sub 3：$m=1$。

仍然只考虑第一个限制。由 $m=0$ 的思路启发我们把原过程转化为向 $T$ 上插入 $m$ 个点。那么此时考虑第二个限制，我们一定不能在插入一个节点后，导致任意两个点编号不大于 $n$ 的点的 lca 改变。更进一步的，我们发现只能把这个点插在一条边上，或把这个点挂在一个已有的点下面当叶子，故此时答案为 $n+n-1$。

## Sub 4：$k=0$。

根据上面的分析，我们发现此时相当于将 $m$ 个点插入树中，其中每次向树中加入一个点都会恰好让边数加一，点数加一，因此下一次的决策总数加二。

那么答案即为 $\prod\limits_{i=n}^{n+m-1} (2i-1)$。

## Sub 5：$m=2$。

赛时好像不太会啊，找找规律发现是 $(2n-1)(2n+1)+[k\neq 0](n-1)$。

## Sub 6：正解。

首先根据 Sub2 的分析，我们考虑一个点可以被插到哪里。

- 插到一条边上。
- 插到一个节点下面做叶子。
- 插到其它地方，并为其钦定一个 $[i+1,i+k]$ 的节点做父亲。

注意到 $k$ 这一维很小，这启发我们状压后面的 $k$ 个节点的放置状态。具体而言，设 $f_{i,S}$ 表示把前 $i$ 个点填进去，当前第 $[i+1,i+k]$ 的点被钦定的状态为 $S$ 的方案数。转移考虑按照上面三种分情况讨论。

- $i$ 是一个被钦定的父亲。

  直接把 $i$ 填进去即可。

- $i$ 不是一个被钦定的父亲。

  对于加到边上和叶子上是好求的，具体而言，点数为 $n+i-1+\text{popcount(S)}$，边数为 $n+i-1+\text{popcount(S)}-1$，直接以这个系数转移即可。如果说要为 $i$ 钦定一个父亲，那么直接枚举一个不在 $S$ 中的数，并将其插到任意一条边上，钦定为 $i$ 的父亲，改变其状态为已钦定即可。


# Part 3：代码

保留了赛时写的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i,l,r) for(int i(l);i<=(r);++i)
#define per(i,r,l) for(int i(r);i>=(l);--i)
#define eb emplace_back
#define Debug(...) fprintf(stderr,__VA_ARGS__)
int read(){
	int ans=0,flg=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flg=-1;ch=getchar();}
	while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	return ans*flg;
}
template<typename T>
void read(T &x){
	x=0;T flg=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flg=-1;ch=getchar();}
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	x*=flg;
}
template<typename T,typename... Args>
void read(T &x,Args &...args){read(x),read(args...);}
const int N=3e4+7,S=(1<<10)+7,mod=1e9+7;
int tp,T,n,m,k;
vector<int>g[N];
int anc[N],dep[N];

void dfs(int *Dep,vector<int>*G,int u){
	for(auto v:G[u]){
		Dep[v]=Dep[u]+1;
		dfs(Dep,G,v);
	}
}

namespace Sub1{
	struct Dsu{
		int bin[N];
		void init(int _n){iota(bin+1,bin+_n+1,1);}
		int find(int u){
			if(u==bin[u])return u;
			return bin[u]=find(bin[u]);
		}
		bool merge(int u,int v){
			u=find(u),v=find(v);
			if(u==v)return 0;
			bin[v]=u;
			return 1;
		}
	}dsu;
	int anct[N],dept[N],ans;
	vector<int>gt[N];
	int glca(int *Anc,int *Dep,int u,int v){
		while(u!=v){
			if(Dep[u]<Dep[v])swap(u,v);
			u=Anc[u];
		}
		return u;
	}
	void calc(){
		dsu.init(n+m);
		for(int i=2;i<=n+m;i++)if(!dsu.merge(i,anct[i]))return;
		// for(int i=1;i<=n+m;i++)Debug("%d ",anct[i]);
		// Debug("\n");
		for(int i=1;i<=n+m;i++)gt[i].clear();
		for(int i=2;i<=n+m;i++)gt[anct[i]].eb(i);
		dept[1]=1;dfs(dept,gt,1);
		// for(int i=1;i<=n+m;i++)Debug("%d ",dept[i]);
		// Debug("\n");
		for(int i=1;i<=n;i++)
			for(int j=i+1;j<=n;j++)
				if(glca(anc,dep,i,j)!=glca(anct,dept,i,j))return;
		for(int i=1;i<=n+m;i++)
			for(int j=1;j<=n+m;j++)
				if(glca(anct,dept,i,j)>max(i,j)+k)return;
		ans++;
	}
	void dfsans(int u){
		if(u==n+m+1)return calc();
		for(int i=1;i<=n+m;i++)anct[u]=i,dfsans(u+1);
	}
	void solve(){
		read(n,m,k);
		for(int i=2;i<=n;i++)read(anc[i]),g[anc[i]].eb(i);
		dep[1]=1;dfs(dep,g,1);dfsans(2);
		printf("%d\n",ans);
		for(int i=1;i<=n;i++)anc[i]=dep[i]=0,g[i].clear();
		ans=0;
	}
	void _main(){
		while(T--)solve();
	}
}

namespace Sub2{
	int ans;
	void solve(){
		read(n,m,k);
		for(int i=2;i<=n;i++)read(anc[i]),g[anc[i]].eb(i);
		dep[1]=1;dfs(dep,g,1);
		if(m==0){
			ans=1;
		}else if(m==1){
			ans=2*n-1;
		}else if(m==2){
			ans=((ll)(2*n-1)*(2*n+1)+(k?(n-1):0))%mod;
		}
		printf("%d\n",ans);
		for(int i=1;i<=n;i++)anc[i]=dep[i]=0,g[i].clear();
		ans=0;
	}
	void _main(){
		while(T--)solve();
	}
}

namespace Sub3{
	int ans;
	void solve(){
		read(n,m,k);
		for(int i=2;i<=n;i++)read(anc[i]),g[anc[i]].eb(i);
		dep[1]=1;dfs(dep,g,1);
		int cur=2*n-1;ans=1;
		for(int i=1;i<=m;i++,cur+=2)ans=(ll)ans*cur%mod;
		printf("%d\n",ans);
		for(int i=1;i<=n;i++)anc[i]=dep[i]=0,g[i].clear();
		ans=0;
	}
	void _main(){
		while(T--)solve();
	}
}

namespace Sub4{
	int f[S],g[S];
	void add(int &x,int y){x+=y-mod,x+=x>>31&mod;}
	void solve(){
		read(n,m,k);
		for(int i=2;i<=n;i++)read();
		memset(f,0,sizeof(f));f[0]=1;
		int full=(1<<k);
		for(int i=0;i<m;i++){
			memset(g,0,sizeof(g));
			for(int j=0;j<full;j++)if(f[j]){
				for(int p=j,cur;p;p&=(p-1)){
					cur=j^(p&(-p));
					if((cur<<1)<full)add(g[cur<<1],f[j]);
				}
				int coef=n+i+__builtin_popcount(j);
				if((j<<1)<full){
					add(g[j<<1],(ll)(coef*2-1)*f[j]%mod);
					add(g[j<<1|1],(ll)(coef-1)*f[j]%mod);
				}
			}
			memcpy(f,g,sizeof(f));
		}
		printf("%d\n",f[0]);
	}
	void _main(){
		while(T--)solve();
	}
}

int main(){
	read(tp,T);
	if(tp==1||tp==2)return Sub1::_main(),0;
	else if(tp==3||tp==4||tp==5||tp==6||tp==7)return Sub2::_main(),0;
	else if(tp==8||tp==9||tp==10||tp==13||tp==14||tp==15||tp==16)return Sub3::_main(),0;
	else return Sub4::_main(),0;
	return 0;
}
```

---

## 作者：Leasier (赞：3)

~~把各种找规律拼起来可以获得高贵的 $70 \operatorname{pts}$！！！~~

考虑把条件转化一下：

- $1 \sim n$ 在 $T'$ 上的虚树与 $T$ 相同。
- $\forall 1 \leq i, j \leq m$，$\operatorname{lca}(i, j) \leq \max(i, j) + k$。

现在我们尝试在 $n + m - 1$ 个点的前提下添加一个编号为 $u = n + m$ 的点，分为以下几种情况：

- 挂在一个点下面作为叶子。
- 挂在一条边中间。
- 把一个 $v \in [u, u + k]$ 挂在一条边中间，再把 $u$ 挂在它下面作为叶子。

前两种情况的贡献只与点数有关，于是我们只需要考虑最后一种情况。

注意到 $k$ 很小，考虑每次加入 $u$ 时记录“这里 $u$ 还需要一个 $v$ 的信息”。具体地，设 $dp_{i, S}$ 表示现在讨论到 $i + u$，$[i + u - k, i + u)$ 中需要还没有被满足的 $u$ 的集合为 $S$。

转移略去，唯一需要注意的是转移时让某些需要 $v$ 的 $u$ 空着是不合法的。时间复杂度为 $O(Tmk 2^k)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int mod = 1e9 + 7;
ll dp[3007][1027];

int main(){
	int c, t;
	scanf("%d %d", &c, &t);
	dp[0][0] = 1;
	for (register int i = 1; i <= t; i++){
		int n, m, k, full;
		ll ans = 0;
		scanf("%d %d %d", &n, &m, &k);
		full = (1 << k) - 1;
		for (register int j = 2; j <= n; j++){
			int f;
			scanf("%d", &f);
		}
		for (register int j = 0; j < m; j++){
			for (register int x = 0; x <= full; x++){
				dp[j + 1][x] = 0;
			}
			for (register int x = 0; x <= full; x++){
				int cnt = n + j + __builtin_popcount(x);
				if (k != 0 && (x >> (k - 1) & 1)){
					dp[j + 1][(x << 1) & full] = (dp[j + 1][(x << 1) & full] + dp[j][x]) % mod;
				} else {
					dp[j + 1][(x << 1) & full] = (dp[j + 1][(x << 1) & full] + dp[j][x] * (cnt * 2 - 1) % mod) % mod;
					if (k != 0){
						dp[j + 1][(x << 1 | 1) & full] = (dp[j + 1][(x << 1 | 1) & full] + dp[j][x] * (cnt - 1) % mod) % mod;
						for (register int y = 1; y < k; y++){
							if (x >> (y - 1) & 1) dp[j + 1][((x ^ (1 << (y - 1))) << 1) & full] = (dp[j + 1][((x ^ (1 << (y - 1))) << 1) & full] + dp[j][x]) % mod;
						}
					}
				}
			}
		}
		printf("%lld\n", dp[m][0]);
	}
	return 0;
}
```

---

## 作者：tzc_wk (赞：3)

显然，

- 条件一等价于在 $T'$ 中，$1\sim n$ 组成的虚树等于它本身。

- 条件二等价于 $1\sim i$ 组成的虚树上点的标号不超过 $i+k$。

我们考虑在原树的基础上依次添加 $n+1\sim n+m$ 这 $m$ 个点。添加一个点 $i$ 时，它与原树的位置关系可能有以下几种：

- 挂在原树上某个点的下面。
- 挂在原树上某条边的中间。
- 原树上某条边分裂出一个编号比它大的点 $j$，然后将 $i$ 挂在 $j$ 下面。

我们考虑，对于第三种情况，我们不直接将这样的 $i$ 加入虚树，而是维护一个集合 $S$，如果遇到这样的 $i$，就往 $S$ 中加入 $i$，然后到扫描到 $j$ 的时候再处理这样的 $i$。那么一个性质是，假设我们当前扫描到 $i$（还没处理加入 $i$ 的贡献），那么 $S$ 中的所有元素都必须 $\ge i-k$。这样可能的 $S$ 只有 $2^k$ 种。我们考虑 $dp_{i,msk}$ 表示现在加入完 $n+1\sim n+i$，$\forall x$，$x\in S$ 当且仅当 $msk$ 的第 $n+i-x$ 位为 $1$。那么我们考虑处理 $i+1$ 时可能发生的转移：

- $i+1$ 挂在原树上某个点的下面，有 $n+i+|S|$ 种可能，转移到 $dp_{i+1,2·msk}$。
- $i+1$ 挂在原树上某条边的中间，有 $n+i+|S|-1$ 种可能，转移到 $dp_{i+1,2·msk}$。
- $i+1$ 作为上述第三种情况中某个“$i$“出现，有 $n+i+|S|-1$ 种可能，转移到 $dp_{i+1,2·msk+1}$。
- $i+1$ 作为上述第三种情况中某个“$j$“出现，那么我们枚举它消灭掉的是哪个 $i$，设为 $x$，那么转移到 $dp_{i+1,2(msk-2^x)}$。

时间复杂度 $Tmk2^k$。

```cpp
const int MAXP=1024;
const int MOD=1e9+7;
int n,m,k,f[MAXP+5],g[MAXP+5];
void add(int &x,int v){((x+=v)>=MOD)&&(x-=MOD);}
void solve(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=2;i<=n;i++)scanf("%*d");
	memset(f,0,sizeof(f));f[0]=1;
	for(int i=0;i<m;i++){
		memset(g,0,sizeof(g));
		for(int j=0;j<(1<<k);j++)if(f[j]){
			int tmp=j;
			while(tmp){
				int lw=tmp&(-tmp);tmp^=lw;
				if(((j^lw)<<1)<(1<<k))add(g[(j^lw)<<1],f[j]);
			}
			int c=n+i+__builtin_popcount(j);
			if((j<<1)<(1<<k)){
				add(g[j<<1],1ll*(c*2-1)*f[j]%MOD);
				add(g[j<<1|1],1ll*(c-1)*f[j]%MOD);
			}
		}swap(f,g);
	}printf("%d\n",f[0]);
}
int main(){
	int qu;scanf("%*d%d",&qu);
	while(qu--)solve();
	return 0;
}
```



---

## 作者：_fairytale_ (赞：0)

# 前言

666 这个树是桂

然后是对“在虚树中插入一个 $[i+1,i+k]$ 中的点，再把 $i$ 挂在下面”做了一些解释。

# 题解

考虑原题的限制，其实就是 $\forall i$，$[1,i]$ 号点形成的虚树中的点只能在 $[1,i+k]$ 中。

先思考 $k=0$ 的部分分。考虑从小到大往虚树中加入点，因为 $k=0$，所以每个 $[1,i]$ 形成的虚树只能是它本身，因为你不能改变以往虚树的形态（即祖孙关系），所以只能把一个点插入一条边或者挂在某个点下面，所以答案为 $\prod_{i=0}^{m-1}(2(n+i)-1)$。

考虑 $k>0$ 的情况。首先 $[1,n]$ 的虚树还需要是它本身。但是对于 $i>n,[1,i]$ 形成的虚树中可以有 $[i,i+k]$ 中的点。称 $[i+1,i+k]$ 中的点是黑点。

我们需要把插不插入黑点的方案区分开。对于不插入黑点的情况，我们可以把点插入一条边或者挂在某个点的下方。这样生成的树都有一个性质：在所有 $[1,i]$ 生成的虚树中，每个点下方只有最多一个点编号比自己小。

因此，如果要插入黑点，就必须保证黑点下方至少有两个数比自己小。钦定某一个黑点的这种情况最早在 $i$ 出现，因此需要找到一条边，在这条边中间先插入一个黑点，再把 $i$ 挂在下面。

可以设计一个 DP，$f_{i,S}$ 表示考虑到 $[1,i]$ 形成的虚树，$S$ 中的黑点已经被选入虚树的方案数，转移方程比较简单，见代码。

```cpp
#include<bits/stdc++.h>
#define rep(x,qwq,qaq) for(int x=(qwq);x<=(qaq);++x)
template <int MOD>
struct modint {
    int val;
    static int norm(const int& x) { return x < 0 ? x + MOD : x; }
    static constexpr int get_mod() { return MOD; }
    modint() : val(0) {}
    modint(const int& m) : val(norm(m)) {}
    modint(const long long& m) : val(norm(m % MOD)) {}
    modint operator-() const { return modint(norm(-val)); }
    bool operator==(const modint& o) { return val == o.val; }
    bool operator<(const modint& o) { return val < o.val; }
    modint& operator+=(const modint& o) { return val = (1ll * val + o.val) % MOD, *this; }
    modint& operator-=(const modint& o) { return val = norm(1ll * val - o.val), *this; }
    modint& operator*=(const modint& o) { return val = static_cast<int>(1ll * val * o.val % MOD), *this; }
    modint& operator/=(const modint& o) { return *this *= o.inv(); }
    modint& operator^=(const modint& o) { return val ^= o.val, *this; }
    modint& operator>>=(const modint& o) { return val >>= o.val, *this; }
    modint& operator<<=(const modint& o) { return val <<= o.val, *this; }
    modint operator-(const modint& o) const { return modint(*this) -= o; }
    modint operator+(const modint& o) const { return modint(*this) += o; }
    modint operator*(const modint& o) const { return modint(*this) *= o; }
    modint operator/(const modint& o) const { return modint(*this) /= o; }
    modint operator^(const modint& o) const { return modint(*this) ^= o; }
    bool operator!=(const modint& o) { return val != o.val; }
    modint operator>>(const modint& o) const { return modint(*this) >>= o; }
    modint operator<<(const modint& o) const { return modint(*this) <<= o; }
    friend std::istream& operator>>(std::istream& is, modint& a) {
        long long v;
        return is >> v, a.val = norm(v % MOD), is;
    }
    friend std::ostream& operator<<(std::ostream& os, const modint& a) { return os << a.val; }
    friend std::string tostring(const modint& a) { return std::to_string(a.val); }
    template <typename T>
    friend modint qpow(const modint a, const T& b) {
        assert(b >= 0);
        modint x = a, res = 1;
        for (T p = b; p; x *= x, p >>= 1)
            if (p & 1) res *= x;
        return res;
    }
    modint inv() const {
        return qpow(*this,MOD-2);
    }
};
using M107 = modint<1000000007>;
using mint = M107;
using namespace std;
#define maxn 3010
int n,m,k;
mint f[maxn][(1<<10)];
void luotianyi(){
    cin>>n>>m>>k;
    for(int i=2,u;i<=n;++i)cin>>u; 
    rep(i,1,m)rep(S,0,(1<<k)-1)f[i][S]=0;
    f[0][0]=1;
	rep(i,0,m-1){
    	rep(S,0,(1<<k)-1){
    		if(S&1)f[i+1][S>>1]+=f[i][S];
    		else{
    			int p=__builtin_popcount(S);
    			rep(w,1,k)if(~(S>>w)&1)f[i+1][(S|(1<<w))>>1]+=f[i][S]*(n+i+p-1);
				f[i+1][S>>1]+=f[i][S]*(n+i+p+n+i+p-1);
			}
		}
	}
	cout<<f[m][0]<<'\n';
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    int Testcases=1;
    cin>>Testcases>>Testcases;
    while(Testcases--)luotianyi();
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P9479)

**题目大意**

> 给定 $n$ 个节点的树，保证父亲节点编号小于儿子，求有多少 $n+m$ 个节点的树（根节点为 $1$），使得：
>
> - 对于所有 $i,j\in[1,n]$，在两棵树上 $\mathrm{LCA}(i,j)$ 的标号相同。
> - 对于所有 $ i,j$，在新树上 $\mathrm{LCA}(i,j)\le \max(i,j)+k$。
>
> 数据范围：$n\le 3\times 10^4,m\le 3000,k\le 10$。

**思路分析**

考虑 $k=0,m=1$ 如何做，不难发现第一个条件等价于 $1\sim n$ 的虚树不变，因此只需要在原树上插入一个点，可以插在边中间或者挂在节点下面，方案数 $2n-1$。

对于 $k=0$ 的一般情况，此时要求每个前缀的虚树都不包含更大的节点，从 $n+1\sim n+m$ 依次插入每个节点，方案数 $\prod_{i=n}^{n+m-1}(2i-1)$。

对于原问题，我们依然考虑依次插入 $i=n+1\sim n+m$，但是插入 $i$ 时 $i$ 可以不在 $1\sim i-1$ 的虚树上，而是通过一个 $\mathrm{LCA}$ 挂上去，而这个 $\mathrm{LCA}$ 一定在 $[i+1,i+k]$ 范围内。

因此对于每个 $i$，要么直接将插入树上，有 $2(i-1)-1$ 种方案，要么在 $[i+1,i+k]$ 中另选择一个节点插在某条边中间，然后把 $i$ 挂在该节点下面。

不难设计出一个 dp，$f_{i,s}$ 表示当前已经插入 $1\sim i$，$[i+1,i+k]$ 中已经被插入的元素是集合 $s$，转移时如果 $0\in s$ 就跳过，否则按上述过程转移，注意此时树的大小是 $i+|s|$。

时间复杂度：$\mathcal O(n+mk2^k)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=1e9+7;
int n,m,k,f[1<<10],pc[1<<10];
ll g[1<<10];
void solve() {
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<n;++i) scanf("%*d");
	memset(f,0,sizeof(f)),memset(g,0,sizeof(g));
	if(!k) {
		ll s=1;
		for(int i=n;i<n+m;++i) s=s*(2*i-1)%MOD;
		return printf("%lld\n",s),void();
	}
	for(int i=1;i<(1<<k);++i) pc[i]=pc[i>>1]+(i&1);
	f[0]=1;
	for(int i=n;i<n+m;++i) {
		for(int s=0;s<(1<<k);++s) {
			if(s&1) g[s>>1]+=f[s];
			else {
				int z=i+pc[s],t=s>>1;
				g[t]+=1ll*f[s]*(2*z-1);
				for(int j=0;j<k;++j) if(!(t>>j&1)) g[t|(1<<j)]+=1ll*f[s]*(z-1);
			}
		}
		for(int s=0;s<(1<<k);++s) f[s]=g[s]%MOD,g[s]=0;
	}
	printf("%d\n",f[0]);
}
signed main() {
	int c,T; scanf("%d%d",&c,&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：Natori (赞：0)

>[P9479 [NOI 2023] 桂花树](https://www.luogu.com.cn/problem/P9479)

好题！

可以先看看[这个](https://www.noi.cn/xw/2023-09-16/795619.shtml)，虽然感觉并没有什么用（

------------
先考虑第一条限制。

在纸上画几个图，大概可以分成以下几类（左边是原树，右边是有 $n+m$ 个点的新树）：

![](https://cdn.luogu.com.cn/upload/image_hosting/qn94djtf.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/d0ya4h1r.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/4e9fg07h.png)

黑色点表示原树上的点，蓝色点表示新加入的点。

上面三个图分别代表：新点挂在原树的一个点上成为叶节点（不一定挂在原树的叶节点上）、新点加在原树的一条边上、新点成为某两个原树上的点的 LCA。

不难发现只有前两种情况是满足要求的，原因显然。

那么我们就得到了第一条限制的等价描述：

>新树上，新点在原树的若干条边上，或者新点的度数为 $1$。

事实上，@[Alex_Wei](https://www.luogu.com.cn/user/123294) 在他的题解中有一个更厉害的描述：

>新树上编号在 $[1,n]$ 中点的虚树等于原树。

~~我们不妨沿用 Alex_Wei 的描述，~~ 从虚树的角度考虑第二个条件：

>对于一个编号为 $u\in[1,n+m]$ 的点，新树上编号前缀 $[1,u]$ 对应点集的虚树中，所有点编号均不超过 $u+k$。

现在回到问题，从第二条限制出发，使用 **增量法**，在已求出虚树一个编号前缀点集的基础上考虑加入一个点带来的影响。

当 $m=1$ 时，只有两种增加这个新点的方案：挂在节点上和加在边上。因此加点方案数是 $num+num-1=num\times2-1$，其中 $num$ 是虚树的点数，直接输出即可。

当 $m\ge2$ 时，如果 $k=0$ ，则仍只有上面的两种方式，答案显然。

否则 $k>0$。

假设现在要向 $[1,u]$ 加入编号为 $u+1$ 的点，此时仍然可以使用之前的两种方式，总方案数为 $num\times2-1$。

但是现在还有一种方式是，新点作为编号在 $[u+1,u+k]$ 中的点加入点集。我们把这样的新点称为 **变点**。注意到变点的变化范围只有 $k$，而 $k$ 很小，所以考虑 **状态压缩 DP**：设 $dp_{u,s}$ 表示考虑到编号 $u$，已经选择变点的集合为 $s$ 时，符合要求的树的个数。不难发现此时 $num=n+u+\text{popcount}(s)$。

对于上面的这种方式，可以枚举 $s$ 的每一位，遇到一个 $1$ 就转移一次。

此外，由于普通点和变点显然可以同时存在，因此还有一种方式是同时加入一个普通点 $u+1$ 和一个变点，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/87culqka.png)

其中虚线点是变点，实线点是普通点。

不难发现此时变点可以选择的位置有 $num-1$ 个，所以方案数是 $num-1$。注意此时对 DP 状态中的 $s$ 也有影响。

以上转移具体见代码。

枚举 $u,s$ 和 $s$ 的每一位，时间复杂度 $\mathcal{O}(mk2^k)$。

一个细节是，为了方便状压，从 $0$ 开始枚举 $dp$ 数组的第一维。

由于时限较小，所以需要用一些方法优化常数。一种方法是使用 lowbit 加速转移。因为 $s$ 实际上会有许多为 $0$ 的位，使用 lowbit 就可以跳过这些位置。同时 $dp$ 数组可以用滚动数组优化。

附上人傻常数大的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool Mbegin;
void File_Work(){
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
}
const int M=3e3+8,ALL=1<<11,mod=1e9+7;
int lowbit(int x){
	return x&(-x);
}
int popcount(int x){
	int res=0;
	while(x){
		res+=x&1;
		x>>=1;
	}
	return res;
}
int n,m,k,all,dp[2][ALL+8];
void mian(){
	for(int s=0;s<=all+8;s++)
	    dp[0][s]=dp[1][s]=0;
	cin>>n>>m>>k;
	all=(1<<k)-1;
	for(int i=2;i<=n;i++){
		int father;
		cin>>father;
	}
	dp[1][0]=1;
	for(int u=0;u<m;u++){
		int cur=u&1;
		for(int s=0;s<=all+8;s++)
		    dp[cur][s]=0;
		for(int s=0;s<=all;s++){
			if(dp[cur^1][s]==0)
				continue;
			int t=s;
			while(t){
				int now=lowbit(t);
				int nxt=(s^now)<<1;
				if(nxt<=all)
					dp[cur][nxt]=(dp[cur][nxt]+dp[cur^1][s])%mod;
				t^=now;
			}
			int num=n+u+popcount(s);
			if((s<<1)<=all){
				dp[cur][s<<1]=(dp[cur][s<<1]+1ll*dp[cur^1][s]*(num*2-1)%mod)%mod;
				dp[cur][s<<1|1]=(dp[cur][s<<1|1]+1ll*dp[cur^1][s]*(num-1)%mod)%mod;
			}
		}
	}
	cout<<dp[(m-1)&1][0]<<'\n';
}
bool Mend;
int main(){
	File_Work();
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cerr<<fixed<<setprecision(3)<<(&Mbegin-&Mend)/1048576.0<<" MB\n\n\n";
	int testid,testnum;
	cin>>testid>>testnum;
	while(testnum--)
		mian();
	cerr<<"\n\n\n"<<fixed<<setprecision(0)<<1e3*clock()/CLOCKS_PER_SEC<<" ms";
	return 0;
}
```

注意到我们并没有记录原树的结构，因为 DP 转移时一定能满足第一个条件。

---

## 作者：Feyn (赞：0)

考虑使用更加优雅的语言描述题目中的限制。一个集合内两个点的 lca 也在集合内部，这样的形式想到虚树，那么前者的限制等价于节点 $[1,n]$ 形成的虚树只包括 $[1,n]$ 的点，而后者的限制等价于节点 $[1,t] $ 形成的虚树不包括编号大于 $t+k$ 的点。观察数据范围发现 $k\le 10$，这样的数据范围想到状压。

容易设计状态 $f_{x,s}$ 表示结点 $[1,x]$ 形成的虚树上编号在 $[x+1,x+k]$ 之中的节点的集合是 $s$ 的方案数。考虑转移，也就是当前的这个点应该放在虚树上什么样的位置。发现只有三种情况：直接挂在原有虚树的一个点上、拆开虚树的一条边挤进去、先在虚树的某条边上挤进去另外一个节点再挂在这个节点上。转移系数是简单的：假设当前虚树有 $n$ 个点，那么第一种决策系数是 $n$，第二种是 $n-1$，第三种也是 $n-1$。转移即可。代码相当好写。

也就是说答案和树的形态无关，这何尝不是一种诈骗题呢。

```cpp
#include<bits/stdc++.h>
// #define feyn
using namespace std;
const int mod=1e9+7;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int m,n,k,f[1<<10],g[1<<10];
inline void add(int &s1,int s2){
    s1=(s1+s2)%mod;
}
void solve(){
    read(m);read(n);read(k);
    for(int i=1,in;i<m;i++)read(in);
    memset(f,0,sizeof(f));f[0]=1;
    for(int x=1;x<=n;x++){
        memset(g,0,sizeof(g));
        for(int t=0;t<(1<<k);t++){
            int data=f[t];
            if(t&1){add(g[t>>1],data);continue;}
            int num=x+m-1+__builtin_popcount(t),u=t>>1;
            add(g[u],1ll*data*(num*2-1)%mod);
            for(int v=0;v<k;v++){
                if(u&(1<<v))continue;
                add(g[u|(1<<v)],1ll*data*(num-1)%mod);
            }
        }
        for(int i=0;i<(1<<k);i++)f[i]=g[i];
    }
    printf("%d\n",f[0]);
}

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif

    int test;
    read(test);read(test);
    while(test--)solve();

    return 0;
}
```

---


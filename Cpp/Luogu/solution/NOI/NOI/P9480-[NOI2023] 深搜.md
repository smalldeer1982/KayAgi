# [NOI2023] 深搜

## 题目描述

深度优先搜索是一种常见的搜索算法。通过此算法，我们可以从一个无重边、无自环的无向连通图 $G = (V, E)$，和某个出发点 $s$，得到一棵树 $T$。

算法的流程描述如下:

1. 将栈 $S$ 设置为空，并令 $T = (V, \emptyset)$，即 $T$ 的边集初始为空。
2. 首先将出发点 $s$ 压入 $S$ 中。
3. 访问栈顶节点 $u$，并将 $u$ 标记为“已访问的”。
4. 如果存在与 $u$ 相邻且未被访问的节点，则**任意地**从这些节点中挑选一个记为 $v$。我们将边 $(u, v)$ 加入 $T$ 的边集中，并将 $v$ 压入栈 $S$ 中，然后**回到步骤 3**。若不存在这样的节点，则从栈中弹出节点 $u$。

可以证明，当图 $G$ 为连通图时，该算法会得到图的某一棵生成树 $T$。但**算法得到的树 $T$ 可能不是唯一的，它取决于搜索的顺序，也就是算法的第 4 步所选取的顶点**。指定出发点 $s$ 后，如果能够选取一种特定的搜索顺序，使得算法得到的树恰好是 $T$，则我们称 **$T$ 是 $G$ 的一棵 $s$-dfs 树**。

现在给定一棵 $n$ 个顶点的树 $T$，顶点编号为 $1 \sim n$，并额外给出 $m$ 条边。我们保证这 $m$ 条边两两不同，连接不同的顶点，且与 $T$ 中的 $n - 1$ 条树边两两不同。我们称额外给出的 $m$ 条边为**非树边**。在这 $n$ 个顶点中，我们指定了恰好 $k$ 个顶点作为**关键点**。

现在你想知道，有多少种选取这 $m$ 条非树边的方法（可以全部不选），使得：将 $T$ 的边与被选中的非树边构成图 $G$ 之后，存在某个**关键点** $s$，使得 $T$ 是 $G$ 的一棵 $s$-dfs 树。

由于答案可能十分巨大，你只需要输出方案数在模 $(10 ^ 9 + 7)$ 意义下的值。

## 说明/提示

**【样例解释 #1】**

在这个样例中，有三种选取非树边的方法：只选取边 $(1, 3)$，只选取边 $(2, 4)$，或不选取任何条非树边。

如果只选取边 $(1, 3)$，或者不选取任何一条非树边，则我们发现 $T$ 都是图 $G$ 的 $3$-dfs 树。指定的搜索顺序如下：
1. 将 $3$ 放入栈 $S$ 中。此时 $S = [3]$。
2. 将 $3$ 标记为“已访问的”。
3. 由于 $3$ 与 $2$ 相连，且 $2$ 是“未访问的”，将 $2$ 放入栈 $S$ 中，并将 $(3, 2)$ 加入树 $T$ 中，此时 $S = [3, 2]$。
4. 将 $2$ 标记为“已访问的”。
5. 由于 $2$ 与 $1$ 相连，且 $1$ 是“未访问的”，将 $1$ 放入栈 $S$ 中，并将 $(2, 1)$ 加入树 $T$ 中，此时 $S = [3, 2, 1]$。
6. 由于与 $1$ 相邻的点都是“已访问的”，将 $1$ 弹出栈，此时 $S = [3, 2]$。
7. 由于与 $2$ 相邻的点都是“已访问的”，将 $2$ 弹出栈，此时 $S = [3]$。
8. 由于 $3$ 与 $4$ 相连，且 $4$ 是“未访问的”，将 $4$ 放入栈 $S$ 中，并将 $(3, 4)$ 加入树 $T$ 中，此时 $S = [3, 4]$。
9. 由于与 $4$ 相连的点都是“已访问的”，将 $4$ 弹出栈，此时 $S = [3]$。
10. 由于与 $3$ 相连的点都是“己访问的”，将 $3$ 弹出栈，此时 $S$重新变为空。

如果只选取边 $(2, 4)$，则我们可以说明 $T$ 是图 $G$ 的 $2$-dfs 树。指定的搜索顺序如下：

1. 将 $2$ 放入栈 $S$ 中。此时 $S = [2]$。
2. 将 $2$ 标记为“已访问的”。
3. 由于 $2$ 与 $3$ 相连，且 $3$ 是“未访问的”，将 $3$ 放入栈 $S$ 中，并将 $(2, 3)$ 加入树 $T$ 中，此时 $S = [2, 3]$。
4. 将 $3$ 标记为“已访问的”。
5. 由于 $3$ 与 $4$ 相连，且 $4$ 是“未访问的”，将 $4$ 放入栈 $S$ 中，并将 $(3, 4)$ 加入树 $T$ 中，此时 $S = [2, 3, 4]$。
6. 由于与 $4$ 相邻的点都是“己访问的”，将 $4$ 弹出栈，此时 $S = [2, 3]$。
7. 由于与 $3$ 相邻的点都是“已访问的”，将 $3$ 弹出栈，此时 $S= [2]$。
8. 由于 $2$ 与 $1$ 相连，且 $1$ 是“未访问的”，将 $1$ 放入栈 $S$ 中，并将 $(2, 1)$ 加入树 $T$ 中，此时 $S = [2, 1]$。
9. 由于与 $1$ 相连的点都是“已访问的”，将 $1$ 弹出栈此时 $S = [2]$。
10. 由于与 $2$ 相连的点都是“已访问的”，将 $2$ 弹出栈，此时 $S$ 重新变为空。

**【样例解释 #2】**

这个样例满足测试点 $4 \sim 6$ 的约束条件。

**【样例解释 #3】**

这个样例满足测试点 $10 \sim 11$ 的约束条件。

**【样例解释 #4】**

这个样例满足测试点 $12 \sim 13$ 的约束条件。

**【样例解释 #5】**

这个样例满足测试点 $14 \sim 16$ 的约束条件。

**【样例解释 #6】**

这个样例满足测试点 $23 \sim 24$ 的约束条件。

**【数据范围】**

对于所有测试数据保证：$1 \le k \le n \le 5 \times 10 ^ 5$，$1 \le m \le 5 \times 10 ^ 5$。

|测试点编号|$n \le$|$m \le$|$k \le$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1 \sim 3$|$6$|$6$|$n$|无|
|$4 \sim 6$|$15$|$15$|$6$|无|
|$7 \sim 9$|$300$|$300$|$6$|无|
|$10 \sim 11$|$300$|$300$|$n$|A|
|$12 \sim 13$|$300$|$300$|$n$|B|
|$14 \sim 16$|$300$|$300$|$n$|无|
|$17 \sim 18$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|A|
|$19 \sim 21$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|B|
|$22$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|无|
|$23 \sim 25$|$5 \times 10 ^ 5$|$5 \times 10 ^ 5$|$n$|无|

特殊性质 A：保证在 $T$ 中，$i$ 号点与 $i + 1$ 号点相连（$1 \le i < n$）。

特殊性质 B：保证若将 $T$ 的边与所有 $m$ 条非树边构成一个图 $G$，则 $T$ 是 $G$ 的棵 $1$-dfs 树。

**请注意，$1$ 号点不一定是 $k$ 个关键点之一。**

## 样例 #1

### 输入

```
0
4 2 2
1 2
2 3
3 4
1 3
2 4
2 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
见附件中的 dfs/dfs2.in。```

### 输出

```
见附件中的 dfs/dfs2.ans。```

## 样例 #3

### 输入

```
见附件中的 dfs/dfs3.in。```

### 输出

```
见附件中的 dfs/dfs3.ans。```

## 样例 #4

### 输入

```
见附件中的 dfs/dfs4.in。```

### 输出

```
见附件中的 dfs/dfs4.ans。```

## 样例 #5

### 输入

```
见附件中的 dfs/dfs5.in。```

### 输出

```
见附件中的 dfs/dfs5.ans。```

## 样例 #6

### 输入

```
见附件中的 dfs/dfs6.in。```

### 输出

```
见附件中的 dfs/dfs6.ans。```

# 题解

## 作者：Alex_Wei (赞：28)

### [P9480 [NOI2023] 深搜](https://www.luogu.com.cn/problem/P9480)

超级酷的题目！

思路参考了 Rainbow_qwq 的题解，对他的题解进行一些补充。题解最后给出的代码有：$n\leq 300$ 的性质 B，$n\leq 300$，未卡常正解和卡常后的正解。

首先，$T$ 可以作为 $s$-DFS 树的充要条件是所有非树边均为返祖边，因为 DFS 树的非树边为返祖边，且如果满足条件则对 $T$ 进行 DFS 就是符合条件的 DFS 顺序。

称非树边 $e$ **覆盖** 点 $s$ 当且仅当 $e$ 在以 $s$ 为根的 $T$ 上是横叉边（非返祖边）。易知非树边 $e = (u, v)$ **不覆盖** 点 $s$ 当且仅当 $s$ 在以 $v$ 为根时 $u$ 的子树内（称为 $u$ 侧），或以 $u$ 为根时 $v$ 的子树内（称为 $v$ 侧）。

对于性质 B，有两种思路：

- 记录从子树内向上延伸的返祖边的最浅深度，并维护当前子树内是否有关键点未被覆盖。
- 设 $c(S)$ 表示不覆盖 $S$ 中任意关键点的非树边数量，设关键点集合为 $U$，容斥得 $\sum_{|S| \geq 1 \ \land \ S\subseteq U} (-1) ^ {|S| + 1} 2 ^ {c(S)}$。

顺着前一种思路不容易解决原问题，因此考虑第二种思路。

##### 非树边的形态

- 称一个点 **属于虚树**，当且仅当它是虚树的结点。
- 称一个点 **落在虚树上**，当且仅当它被虚树的某条边覆盖。

定点 $1$ 为根。

建出 $S$ 的虚树 $T_S$。注意要和我们所理解的虚树做区分：当且仅当 $x\in S$ 或有至少三棵子树（包括向上的子树）含属于 $S$ 的点时，$x$ 才属于虚树。它们的唯一区别在于，当 $S$ 所有点的 LCA $d$ 只有两棵子树含属于 $S$ 的点时，$d$ 不属于 $T_S$，但 $d$ 属于我们通常所理解的虚树。

考虑非树边 $e = (u, v)$ 不覆盖 $S$ 的充要条件：$S$ 全部在 $u$ 侧，$S$ 全部在 $v$ 侧，$u, v$ 侧均有属于 $S$ 的点。它将合法非树边的形态分成两类：

- 落在虚树上的点向虚树外延伸的某条边的对应子树内的返祖边。注意 “返祖边” 是在以该点为根时判定的。
- $u, v$ 对应树上路径被虚树的某条边完全包含。

![](https://cdn.luogu.com.cn/upload/image_hosting/oc9mqdf1.png)

如上图，绿色的点表示 $S$，黄色的点不属于 $S$ 但属于虚树，橙色的点不属于虚树但落在虚树上。红色虚边为合法非树边，蓝色虚边为不合法非树边。

##### 性质 B

对于性质 B，注意到不存在跨过 $d$ 的合法横叉边，因此可以将虚树改为我们通常所理解的虚树：若 $x$ 有两棵子树含属于 $S$ 的点，则 $x$ 也属于虚树。即认为 $d$ 属于虚树对答案无影响。

枚举 $S$ 的 LCA $d$，则不存在一端在 $d$ 子树内（不含 $d$），另一端在 $d$ 子树外的（不含 $d$）的合法非树边。因此子树内外独立，贡献直接相乘。

- 子树内的贡献可利用虚树结构 DP，因此设 $f_d$ 表示当 $d$ **属于虚树** 时，仅考虑 $d$ 子树内所有关键点和非树边的贡献。
- 子树外的贡献为 $2 ^ {out_d}$，其中 $out_d$ 表示 $d$ 子树外以 $d$ 为根时的返祖边数量。设 $in_d$ 表示 $d$ 子树内以 $d$ 为根时的返祖边数量，换根 DP 求出 $in$ 和 $out$。$out$ 的求法稍有些复杂，留给读者自行思考，可以参考代码 `dfs3` 部分。

$f$ 的转移是重头戏。转移时，需要不重不漏地统计每一处贡献。为此，请读者牢记所有可能产生贡献的非树边形态：落在虚树上的点向虚树外延伸的某条边的对应子树内的返祖边；返祖边两端对应树上路径被虚树的某条边完全包含。

设 $d$ 的所有儿子为 $s_1\sim s_k$。$s_i$ 的子树内要么没有虚树上的点，要么有虚树上的点。对于后者，根据虚树的性质，有且仅有最浅的点与 $d$ 在虚树上相连。

设 $d$ 在虚树上的儿子为 $P$，有基本贡献系数 $\prod_{p\in P} f_p$。接下来统计未考虑到的非树边：

- **第一类非树边**：对于每个 $p\in P$，包含于路径 $d\rightsquigarrow p$ 的非树边。
- **第二类非树边**：对于每个 $p\in P$ 和所有 $q\in d\rightsquigarrow p$（不含 $d, p$），从 $q$ 向虚树外延伸的某条边的对应子树内的返祖边。
- **第三类非树边**：对于 $d$，向虚树外延伸且在子树内的某条边的对应子树内的返祖边。

将第三类非树边摊到每个未选点的儿子，得：

- 对于选点的儿子 $s_i$，贡献系数为 $X(s_i) = \sum_{p\in \mathrm{subtree}(s_i)} g_{p\to d}$，其中 $g_{p\to d}$ 表示 $f_p$ 乘以 $2 ^ c$，其中 $c$ 表示包含于路径 $d\rightsquigarrow p$ 的非树边数量，加上对于所有 $q\in d\rightsquigarrow p$（不含 $d, p$），从 $q$ 向路径 $d\rightsquigarrow p$ 外延伸的某条边的对应子树的返祖边数量之和。
- 对于未选点的儿子 $s_i$，贡献系数为 $Y(s_i) = 2 ^ c$，其中 $c$ 表示 $s_i$ 子树内的返祖边数量 $in_{s_i}$，加上较浅的一端为 $d$，较深的一端落在 $s_i$ 子树内的返祖边数量。

![](https://cdn.luogu.com.cn/upload/image_hosting/mv0n45o8.png)

如上图，$d$ 的左子树选择点 $p$，红色虚边为产生贡献的非树边。$d$ 的右子树没有选择，红色虚边为产生贡献的非树边。

假设已经求出 $X(s_i)$ 和 $Y(s_i)$，**考虑 $f_d$ 如何计算**。设恰好在 $k$ 棵子树内选点的答案为 $F_k$，即 $F_k = [x ^ k]\prod (X(s_i) x + Y(s_i))$。

- 如果 $d\notin S$，则至少要有两棵子树被选择，产生贡献 $\sum_{k\geq 2} F_k$。
- 如果 $d\in S$，则要求 $d$ 是关键点，对被选择子树数量没有限制，产生贡献 $-\sum_{k\geq 0} F_k$。

发现 $k\geq 2$ 的 $F_k$ 等价，因此背包时维护 $F_0, F_1$ 和 $\sum_{k\geq 2} F_{k}$ 即可。

设 $Z = \sum_{1\leq i\leq n} f_i 2 ^ {out_i}$，则 $Z = \sum_{|S|\geq 1 \ \land \ S\subseteq U} (-1) ^ {|S|} 2 ^ {c(S)}$，答案为 $-Z$。

**考虑维护 $g_{p\to d}$ 求 $X(s_i)$**。根据 $g$ 的定义，可得如下步骤：

- 首先，对于 $p\in \mathrm{subtree}(d)$，令 $g_{p\to d}\gets g_{p\to s_i}$，其中 $s_i$ 是 $p$ 对应的 $d$ 的儿子。
- 对于所有 $s_i$，令 $g_{s_i\to d}\gets f_{s_i}$。由于不存在等于树边的非树边，将这一步放在下面两步之后也正确。
- 加入第一类非树边的贡献：枚举所有以 $d$ 为一端，另一端在 $d$ 子树内的非树边 $e = (d, u)$，对于 $p\in \mathrm{subtree}(u)$，将 $g_{p\to d}$ 乘以 $2$。
- 加入第二类非树边的贡献：枚举所有以 $s_i$ 为一端，另一端在 $s_i$ 子树内的非树边 $e = (s_i, u)$，设 $u$ 对应 $s_i$ 的儿子为 $v$，则对于 $s_i$ 的所有不为 $v$ 的儿子 $t_j\neq v$，对于 $p\in \mathrm{subtree}(t_j)$，将 $g_{p\to d}$ 乘以 $2$。简单地说，返祖边 $e = (u, v)$（其中 $u$ 是较浅端）会对 $u$ 的不为 $u\to v$ 后继的所有儿子的子树内所有结点产生贡献。

我使用的维护方法是：继承 $g$；加入第一类非树边的贡献；计算 $X$ 求出 $f$；加入以 $d$ 为较浅端的第二类非树边的贡献；令 $g_{d\to d} \gets f_d$。其实就是将统计第二类非树边的贡献下放到每个儿子处进行，这样好写一点，但注意这类贡献需要在计算 $X$ 求出 $f$ 之后统计。

将 $p$ 这一维用 DFS 序拍平到序列上，线段树合并维护 $g_{p\to d}$，支持区间乘法，区间求和。注意到每个子树的时间戳区间不交，所以不用线段树合并，只需用一棵线段树维护。

**考虑求 $Y(s_i)$**。在计算 $g_{p\to d}$，加入第一类非树边的贡献时，对于每个 $e = (d, u)$ 以及对应 $d$ 的儿子 $s_i$，将 $in_{s_i}$ 加上 $1$，过程结束后得到新的 $in'_{s_i}$。则 $Y(s_i) = 2 ^ {in'_{s_i}}$。

时间复杂度 $\mathcal{O}((n + m)\log n)$。

##### 正解

相较于性质 B 多出了以 $1$ 为根时的横叉边。

考虑在何种情况下性质 B 的做法会导致错误：性质 B 保证我们可以将 $d$ 加入虚树，而性质 B 的做法在 “无论非树边是否是返祖边，只要 $d$ 在虚树上” 时，均可得到正确的答案，因为我们在分析合法非树边形态时，并没有要求这些非树边是以 $1$ 为根时的返祖边。这说明性质 B **只是** 让我们将 $d$ 加入虚树。

将 $d$ 加入虚树会导致一些非树边从合法变成不合法。

- 对于形如 “落在虚树上的点向虚树外延伸的某条边的对应子树内的返祖边” 的非树边，由于将 $d$ 加入虚树不改变落在虚树的点集，因此不会有影响。
- 对于形如 “$u, v$ 对应树上路径被虚树的某条边完全包含” 的非树边，将 $d$ 加入虚树后产生的影响为：若虚树原本不包含 $d$，且存在经过 $d$ 的虚树边 $(x, y)$，那么一条两端均属于 $x, y$ 树上路径，且两端分别在 $d$ 的两侧的非树边从合法变成了不合法。

因此，只需重新计算这样的 $S$ 的贡献：$d\notin S$，且 $d$ **恰有** 两棵子树有属于 $S$ 的点。

枚举 $d$ 和将 $d$ 加入虚树后它在虚树上的两个儿子 $p, q$，设它们分别对应 $d$ 在原树上的儿子 $u\neq v$。设 $z = g_{p\to d} \times g_{q\to d}\times \prod_{s_i \neq u, v} Y(s_i)$，这是原来计算的贡献。枚举 LCA 为 $d$ 的非树边 $e = (x, y)$，若 $x, y$ 分别在 $d\rightsquigarrow p$ 和 $d\rightsquigarrow q$ 上（路径不含 $d$，$x, y$ 顺序无关），则将 $z$ 乘以 $2$。最终得到 $z'$ 为真正的贡献。暴力做的复杂度是 $\mathcal{O}(n ^ 2 m)$。

先将 $s_i$ 子树时间戳区间的所有 $g$ 值乘以 $\frac 1 {Y(s_i)}$，最后将贡献乘以 $\prod_{s_i} Y(s_i)$（我们发现，实际上 $\prod_{s_i} Y(s_i) = 2 ^ {in_d}$），这样贡献只与 $g_{p\to d}$ 和 $g_{q\to d}$ 有关，而与其它儿子无关。

枚举 $d$，则一条 LCA 为 $d$ 的非树边的贡献是矩形乘以 $2$。若干次矩形乘以 $2$ 之后全平面求和，注意容斥掉 $u\neq v$ 的贡献。我使用的维护方法是：支持查找子树内某点 $x$ 对应的 $d$ 的儿子在时间戳上的后继 $\mathrm{suc}(x)$。扫描线，将所有儿子的时间戳加入事件，则遇到事件 $(x, l, r, c)$ 时（当前扫到时间戳 $x$，操作为给 $l\sim r$ 乘以 $c$），设上一次考虑的时间戳为 $x'$（初始值为 $d$ 的儿子时间戳最小值 $L = \mathrm{dfn}(d) + 1$）。因为所有儿子的时间戳也被加入了事件，所以 $x'\sim x - 1$ 一定是同一个儿子子树内的时间戳。求出 $x'\sim x - 1$ 的 $g$ 值之和，求出 $\mathrm{suc}(x')\sim R$ 的 $g$ 值之和（$R$ 表示 $d$ 的子树时间戳最大值 $\mathrm{dfn}(d) + \mathrm{size}(d) - 1$），相乘后再乘以 $2 ^ {out_d} \prod_{s_i} Y(s_i)$ 加入答案。

最后不要忘记将答案减去 $F_2 \times 2 ^ {out_d}$，也就是减去原先计算的错误答案。为此，需要区分 $F_2$ 和 $F_{k\geq 3}$，背包时维护 $F_0, F_1, F_2, \sum_{k\geq 3} F_{k}$。

时间复杂度 $\mathcal{O}((n + m)\log n)$，空间复杂度为 $\mathcal{O}(n + m)$，加上求 LCA 的空间复杂度。[代码](https://www.luogu.com.cn/paste/rdxgs34l)。

---

## 作者：Rainbow_qwq (赞：25)

前言：考场上想到了这题正解，不过代码有点难写没调完，只拿了 A,B 性质的 72pts。

---

题意中的“以 $s$ 点为根能成为 dfs 树”，相当于“以 $s$ 点为根，所有额外边都是返祖边”。

我们考虑容斥，对 $k$ 个关键点的集合容斥。答案形如：先加上钦定了 $1$ 个点为关键点的合法选边方案数，再减去钦定了 $2$ 个点为关键点的合法选边方案数，再加上三个点的，一次类推。

设 $cnt(S)$ 表示 以 $S$ 集合中的点作为根，都为返祖边的额外边数。那么答案为：

$$\sum_{T \subseteq S ,T\neq \varnothing}(-1)^{|T|-1}2^{cnt(T)}$$

暴力计算可得 36pts.

---

考虑如何表示一个 $cnt(S)$。

建出 $S$ 集合点的虚树。合法的额外边一共两种：

- 被虚树中的每条边包含的边；
- 在虚树中每个点向虚树外伸出的子树中，为返祖边的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/ew31oglc.png)

定 $1$ 为根，考虑对于每一种虚树形态，**在虚树的 LCA 处**统计这颗虚树的贡献。

---

考虑性质 B 怎么做（以 $1$ 为根，所有可选边都是返祖边）。

由于没有横叉边的贡献，一个点如果有 $\ge 2$ 个子树内选了点，就可以把它当作在虚树上，贡献不变。

可以从下到上做 dp，设 $f_u$ 表示 $u$ 在虚树上，并且只考虑子树之内的所有额外边 & 只考虑子树之内的所有关键点，所有方案的答案之和。

$u$ 在虚树上有两种可能：

- 有 $\ge 2$ 个子树中选了点，自己选不选无所谓。
- 有 $\le 1$ 个子树中选了点，并且自己选了。

这两种情况都逃不掉要求这样一个东西：在某个子树中，任意选一个点 $v$（作为虚树的根），用 $f_v$ 乘上 $u$ 到 $v$ 这段路径的贡献。路径的贡献就是：

- 这段路径上包含的所有返祖边。
- 这段路径上所有点 向 所有不在这条路径上的子树中的可选边 的个数。

设这两种边的个数为 $c_{u\to v}$，贡献就是 $\sum f_v\times 2^{c_{u\to v}}$。

形象一点就是下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/naks6a50.png)

设 $sf_v$ 表示 $v$ 子树中选至少一个点的贡献（也就是上面那个东西），如果求出了 $sf_v$，那么背包一下就可以得到选择 $0/1/2/\ge 3$ 个子树的贡献，进而求出 $f_u$。

现在问题是求出 $sf_v$。

考虑实时维护 $sf_v$ 表示 $f_v\times 2^{c_{u\to v}}$.

在 $u$ 处要处理上面两种边的贡献：

一：$u$ 向子树内的边：设有一条 $u\to x$，则 $x$ 子树中的所有点 $sf$ 乘 $2$。

二：所有不在这条路径上的子树中的可选边：

设 $sz_u$ 为 $fa_u$ 向 $u$ 子树中的边 和 $u$ 子树中的所有可选边，设 $sz2_u$ 表示 $u$ 向 $fa_u$ 方向的所有可选边。这两个可以在树上分别从下到上 & 从上到下求出。

那对于 $u$ 的儿子 $v$，要给 $u$ 除了 $v$ 外的子树的 $sf$ 值乘上 $2^{sz_v}$。

发现操作都是子树乘，子树求和。那开一颗 dfs 序下标的线段树维护 $sf$ 的值即可，支持线段树区间乘，区间求和。

由于要在虚树的 LCA 处统计贡献，此时 $ans$ 要加上 $f_u$ 乘上 $u$ 向 $fa_u$ 方向的所有可选边的贡献，也就是 $f_u\times 2^{sz2_u}$。

那这样就做完了性质 B，写代码时注意多选一个点要乘 $-1$ 的贡献。结合暴力有 72pts.

---

最后是有横叉边的情况。

此时 $f_u$ 的值不会有问题。

问题出在计算 $ans$ 时，选了两个子树，自己没选的情况，此时横叉边会有贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/2mi4pmms.png)

仍然把树拍扁到 dfs 序上，变成 $[l_u,r_u]\times [l_u,r_u]$ 的矩形。矩形每个初始位置值是两个坐标的 $sf$ 的乘积。

设一条横叉边端点为 $x,y$，则 会给 $[l_x,r_x]\times [l_y,r_y]$ 的矩形乘 $2$，最后求矩形内所有点的和。

那么扫描线线段树即可，最后减掉两个点选在相同子树内的贡献。

时间复杂度 $O((n+m)\log n)$。

~~考场代码拍成照了，哪天数据出了再抄一遍~~ upd：有数据了

[84pts 代码](https://www.luogu.com.cn/paste/moh3lgxi)

[100pts 代码](https://www.luogu.com.cn/paste/mo13l46r)

---

## 作者：_ANIG_ (赞：2)

很 CNOI 的一道题。

首先考虑暴力怎么做。

题目要求存在某个关键点 $s$ 的方案数，容易想到容斥，转成钦定一个集合内的关键点，使得以这个集合内的任意一个点为根都能满足条件。

可以发现，$T$ 是 $G$ 的 dfs 树的充要条件是额外边中不存在横叉边。

也就是说要求出来选边的方案数，使得任意一条边都不是集合内任何点为根时的横叉边。

显然，边之间的贡献是独立的。

如果有 $k$ 条边满足其不是集合内任何点为根时的横叉边，则方案数为 $2^k$。

于是得到了 $O(2^kn)$ 的做法。

把这个过程放到树形 dp 上。

不难发现，对于一个子树是否合法，我们只关注这个子树内所有关键点的最近公共祖先。

于是设置状态：$f_{x,k}$ 表示 $x$ 的子树内，所有被选了的关键点 lca 为 $k$，方案数和容斥系数的乘积之和。

转移的时候分讨一下就能解决 B 性质。

套个线段树合并即可获得 72pts。

现在还剩横叉边无法处理。

在横叉边的 lca 处统计贡献。

可以发现，只要选了横叉边，则不在横叉边的端点的子树内的点中一定没有被选的关键点。

于是枚举横叉边两个端点的子树内关键点的 lca，即可做到 $O(n^3)$。

可以发现要统计的东西类似一个扫描线的形式，套个扫描线即可获得 100pts，复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+5,mods=1e9+7;
namespace tr{
    struct node{
    	signed lson,rson,sm,laz;
    }p[N*50];
    int idx;
    void mul(int x,int sm){
    	p[x].sm=1ll*p[x].sm*sm%mods;
    	p[x].laz=1ll*p[x].laz*sm%mods;
    }
    void dnset(int x){
    	if(p[x].laz!=1){
    		mul(p[x].lson,p[x].laz);
    		mul(p[x].rson,p[x].laz);
    		p[x].laz=1;
    	}
    }
    void init(int x){
    	if(!p[x].lson)p[x].lson=++idx,p[idx].laz=1;
    	if(!p[x].rson)p[x].rson=++idx,p[idx].laz=1;
    }
    void upset(int x){
    	p[x].sm=(p[p[x].lson].sm+p[p[x].rson].sm)%mods;
    }
    void mul(int x,int l,int r,int sm,int nl,int nr){
    	if(l<=nl&&r>=nr){
    		mul(x,sm);
    		return;
    	}
    	int mid=nl+nr>>1;
    	init(x);
    	dnset(x);
    	if(l<=mid)mul(p[x].lson,l,r,sm,nl,mid);
    	if(r>mid)mul(p[x].rson,l,r,sm,mid+1,nr);
    	upset(x);
    }
    void add(int x,int d,int sm,int nl,int nr){
    	if(nl==nr){
    		p[x].sm=(p[x].sm+sm)%mods;
    		return;
    	}
    	init(x);
    	dnset(x);
    	int mid=nl+nr>>1;
    	if(d<=mid)add(p[x].lson,d,sm,nl,mid);
    	else add(p[x].rson,d,sm,mid+1,nr);
    	upset(x);
    }
    int gets(int x,int l,int r,int nl,int nr){
    	if(!x)return 0;
    	if(l<=nl&&r>=nr)return p[x].sm;
    	int mid=nl+nr>>1;
    	dnset(x);
    	if(r<=mid)return gets(p[x].lson,l,r,nl,mid);
    	if(l>mid)return gets(p[x].rson,l,r,mid+1,nr);
    	return (gets(p[x].lson,l,r,nl,mid)+gets(p[x].rson,l,r,mid+1,nr))%mods;
    }
    int hb(int a,int b,int nl,int nr){
    	if(!a||!b)return a|b;
		if(nl==nr){
    		p[a].sm=(p[a].sm+p[b].sm)%mods;
    		return a;
    	}
    	int mid=nl+nr>>1;
    	dnset(a);dnset(b);
    	p[a].lson=hb(p[a].lson,p[b].lson,nl,mid);
    	p[a].rson=hb(p[a].rson,p[b].rson,mid+1,nr);
    	upset(a);
    	return a;
    }
}
int pows(int a,int b){
	if(b==0)return 1;
	int res=pows(a,b>>1);
	res=res*res%mods;
	if(b&1)res=res*a%mods;
	return res;
}
int inv2=mods+1>>1,op,n,m,k,rt[N],dfn[N],dy[N],js[N],f1[N],f2[N],sl[N],ff[N],sz[N],res,mk[N],cf[N],pw2[N],inv[N],dp[N],eds[N],dep[N],fa[N][20],idx,bk[N];
vector<int>p[N],g[N],gs[N];
vector<pair<int,int> >jl[N];
map<pair<int,int>,vector<pair<int,int> > >q[N];
void dfs(int x){
	for(int i=1;i<=19;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	mk[x]=1;
	dfn[x]=++idx;
	dy[idx]=x;
	for(auto c:p[x]){
		if(mk[c])continue;
		dep[c]=dep[x]+1;
		fa[c][0]=x;
		dfs(c);
	}
	mk[x]=0;
	eds[x]=idx;
}
int up(int x,int k){
	while(k){
		x=fa[x][__lg(k&-k)];
		k^=k&-k;
	}
	return x;
}
int lca(int a,int b){
	if(dep[a]>dep[b])swap(a,b);
	b=up(b,dep[b]-dep[a]);
	if(a==b)return a;
	for(int i=19;i>=0;i--){
		if(fa[a][i]!=fa[b][i])a=fa[a][i],b=fa[b][i];
	}
	return fa[a][0];
}
bool in(int a,int b){
	return a>=dfn[b]&&a<=eds[b];
}
struct msg{
	int x,op,l,r;
};
void solve(int x){
	rt[x]=++tr::idx;
	mk[x]=1;
	dp[x]=1;
	if(bk[x])tr::add(rt[x],dfn[x],-1,1,n);
	sz[x]=0;
	for(auto c:p[x]){
		if(mk[c])continue;
		solve(c);
		dp[x]=dp[x]*dp[c]%mods;
		sz[x]+=sz[c]+g[c].size();
	}
	for(auto [t,c]:q[x]){
		int a=t.first,b=t.second,ans=-tr::gets(rt[a],1,n,1,n)*tr::gets(rt[b],1,n,1,n)%mods;
		vector<msg>jl;
		for(auto [s1,s2]:c){
			jl.push_back({dfn[s1],0,dfn[s2],eds[s2]});
			jl.push_back({eds[s1]+1,1,dfn[s2],eds[s2]});
		}
		jl.push_back({n+1,2});
		sort(jl.begin(),jl.end(),[&](msg a,msg b){
		    return a.x<b.x;
		});
		int lst=0;
		for(auto [x,op,l,r]:jl){
			if(lst<x)ans+=tr::gets(rt[a],lst,x-1,1,n)*tr::gets(rt[b],1,n,1,n)%mods;
			lst=x;
			if(op==0)tr::mul(rt[b],l,r,2,1,n);
			if(op==1)tr::mul(rt[b],l,r,inv2,1,n);
		}
		ans%=mods;
		res+=ans*pw2[cf[dfn[x]]-sz[x]]%mods*dp[x]%mods*inv[a]%mods*inv[b]%mods;
	}
	dp[x]=1;
	for(auto c:p[x]){
		if(mk[c])continue;
		int he=tr::gets(rt[x],1,n,1,n);
		int tmp=he*tr::gets(rt[c],1,n,1,n)%mods;
		tr::mul(rt[c],dp[x]);
		tr::mul(rt[x],dp[c]);
		rt[x]=tr::hb(rt[x],rt[c],1,n);
		tr::add(rt[x],dfn[x],tmp,1,n);
		dp[x]=dp[x]*dp[c]%mods;
	}
	res+=tr::gets(rt[x],dfn[x],dfn[x],1,n)*pw2[cf[dfn[x]]-sz[x]]%mods;
	res%=mods;
    for(auto c:g[x]){
    	tr::mul(rt[x],dfn[c],eds[c],2,1,n);
        dp[x]=dp[x]*2%mods;
        if(c==x)js[x]++;
	}
	inv[x]=pows(dp[x],mods-2);
	mk[x]=0;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>op>>n>>m>>k;
	pw2[0]=1;
	for(int i=1;i<=m;i++)pw2[i]=pw2[i-1]*2%mods;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		p[x].push_back(y);
		p[y].push_back(x);
	}
	dfs(1);
    for(int i=1;i<=m;i++){
		int a,b;
		cin>>a>>b;
		if(dfn[a]>dfn[b])swap(a,b);
		if(dfn[b]>=dfn[a]&&dfn[b]<=eds[a]){
			g[up(b,dep[b]-dep[a]-1)].push_back(b);
			cf[dfn[b]]++;
			cf[eds[b]+1]--;
			cf[1]++;f1[i]=a;f2[i]=b;
			int tmp=up(b,dep[b]-dep[a]-1);
			cf[dfn[tmp]]--;
			cf[eds[tmp]+1]++;
			ff[dfn[b]]++;ff[eds[b]+1]--;
		}else{
			int c=lca(a,b);
			jl[c].push_back({a,b});
			q[c][{up(a,dep[a]-dep[c]-1),up(b,dep[b]-dep[c]-1)}].push_back({a,b});
			gs[up(a,dep[a]-dep[c]-1)].push_back(a);
			gs[up(b,dep[b]-dep[c]-1)].push_back(b);
			cf[dfn[a]]++;
			cf[eds[a]+1]--;
			cf[dfn[b]]++;
			cf[eds[b]+1]--;
		}
	}
	for(int i=1;i<=n;i++)cf[i]+=cf[i-1],ff[i]+=ff[i-1];
	for(int i=1;i<=k;i++){
		int x;
		cin>>x;
		bk[x]=1;
	}
	solve(1);
	cout<<(-res%mods+mods)%mods<<"\n";
}
```

---

## 作者：nullqtr_pwp (赞：2)

### 算法 $1$

注意到判定就是 dfs 树看作 $T$ 时，对于额外边不允许存在横叉边，也就是必须都是返祖边（无向图 dfs 树不考虑前向边），即以某个 $s$ 为根时要求任意非树边的两个端点均形成祖先关系。那么只需要计算多少条边符合条件即可。

记符合条件的边数量是 $c$ 的话就会产生 $2^c$ 的贡献。但是我们要求重复的只计数一次，可以考虑容斥原理。对于关键点集合 $S$ 计数有多少边满足以 $S$ 中任意点为根时这条边的端点均形成祖先关系即可。带上 $(-1)^{|S|+1}$ 的容斥系数直接统计答案。时间复杂度 $\mathcal O(2^kk(n+m))$，期望得分 $36$。

### 算法 $2$

性质 $\text{A}$ 是链，那么将额外边看成区间 $[u,v]$，那么就要求所有选取的区间都必须要在 $[1,s]$ 或者 $[s,n]$ 之间。可以考虑对于一个合法的方案让它在最小合法的 $s$ 上进行统计。那么反过来枚举 $s$，记上一个关键点为 $s'$，那么就要求 $u\in[1,s'],v\in[s',s]$ 中的至少选取一条边。这是简单的二维数点问题，容易做到时间复杂度 $\mathcal O(n\log n)$。结合算法 $1$ 期望得分 $52$。

### 算法 $3$

考虑特殊性质 $\text{B}$：在以 $1$ 为根的情况下不存在横叉边。不妨设树根是 $1$。考虑对容斥的做法使用数据结构优化。对于关键点集合 $S$ 考虑如何刻画符合条件的非树边。可以对点集 $S$ 建立虚树。显然一条边合法可以是：完全被某条虚树上的边给包含；另一种情况是，落在虚边上对应路径的某个点 $u$ 向外一条边 $(u,v)$ 使得 $v$ 不在虚树上，那么要求起点（非树边深度较大的端点）必须在 $v$ 子树之中的同时，不构成该点为子树意义下的横叉边。注意，如果出现虚树上度数为 $2$ 的根且根不在 $S$ 之中就需要将合并一下两个儿子的路径，否则会违反判定 $1$。注意到性质 $\text{B}$ 告诉我们没有横叉边，在这个条件下我们可以暂时认为对于两个儿子的子树都在，我们就可以认为它也在虚树上。

那么可以对于所有 $S$ 构成的虚树 $T'$，将 $T'$ 在以 $1$ 为根的意义下的根位置 $R$ 进行答案的统计。注意到由于没有横叉边，因此子树内外两部分是独立的。那么就需要换根维护 $out_R$ 表示以 $R$ 为根时，在以 $1$ 为根意义下 $R$ 的子树补范围中非树边的个数。这个是经典的换根 dp，容易 $\mathcal O(n)$ 求出。结合性质可以进行 dp。$f_u$ 表示仅考虑 $u$ 子树此时 $u$ 为虚树根的选取贡献和。即在 $u$ 子树中选取 $S$ 得到的容斥系数乘 $2$ 的合法路径个数次方之和。考虑转移分为两种：$\ge 2$ 个儿子选了；恰好 $1$ 个儿子选了且自己也选入 $S$。此时细节就是要从子树中位置 $v$ 来接。此时虚边对应路径添加了 $(u,v)$。此时需要维护返祖链终结在这个路径以及这个路径本身的贡献。

对于路径 $(u,v)$ 包含非树边的情况，可以使用 dfs 序来刻画。形如一个直链上一个区间内的 $v$ 以及 $\mathcal O(1)$ 个区间内的 $u$。当然你要做的是在 dfs 过程中实时维护这个 $\times 2$ 的系数，也就是访问 $f_u$ 时你在数据结构中要有的是 $f_v\times 2^{\text{coef}(u,v)}$。

考虑将非树边视为更新操作，那么对于在端点深度较浅的位置新增一条非树边一个朴素的操作就是进行子树 $\times 2$。那么对于另一种贡献，返祖链合并到虚树上时，那么其实是对旁边一个子树都有更新的，那么加入一个点 $u$ 就需要求出子树内有多少个合法的非树边，记为 $in_u$，可以直接进行树上 dp。那么对于数据结构的操作，就是枚举所有 $(u,v)$，对于所有除了 $v$ 以外的子树，对于数据结构执行乘 $2^{in_v}$ 的操作。

对于统计答案，还需要执行子树求和的操作。操作都是对于子树的，可以直接将它拍成 dfs 序，这样子树操作可以转化为区间乘区间加。直接使用线段树维护即可做到 $\mathcal O(n\log n)$ 的时间复杂度。结合算法 $1,2$ 期望得分 $72$。

### 算法 $4$

瓶颈在于：对于虚树虚点自己不选，但存在两个儿子被选导致其出现在虚树上的方案统计。问题在于这个会导致合并路径。那么对于一个横叉边而言，其不形成祖先关系。从 dfs 序的角度进一步思考，两个端点对应的子树区间也是不交的。那么意味着当虚树根连接的两个点 $v_1\in[l_1,r_1],v_2\in[l_2,r_2]$ 时是可以进行插入的。也就是说贡献在于被 $v_1,v_2$ 包含的点。注意这个附加代价当且仅当只有两个儿子才可以进行。因此这是一个二维问题。我们发现一个更优美的性质，这个造成贡献当且仅当虚树根取到 $\text{lca}$ 上。直接挂在这个 $\text{lca}$ 上。当前统计 $f_u$ 时直接扫描线所有儿子即可。这个内部可以用一棵线段树来维护。

使用线段树维护，总复杂度 $\mathcal O(n\log n)$。

---

## 作者：Otomachi_Una_ (赞：2)

**【题目简述】**

> 给一棵树 $T$ 和一些额外边 $E$ 和一些关键点集合 $V$。求 $E'\subset E$ 的个数，满足存在 $v\in V$ 使得 $T$ 在以 $v$ 为根意义下 $E'$ 的边都是返祖边。
>
> $|T|,|E|\leq 5\times 10^5$。

**【解题思路】**

是在是太神仙了，这个题。码量和思维量都特别充足。定义 $(e,u)$ 是“好的”当且仅当 $T$ 在 $u$ 为根意义下 $e$ 为返祖边。

### $k\leq 6$

考虑如果我们确定了一个 $V'\subset V$ 的关键点集合，有哪些 $e\in E$ 使得任意 $v_0\in V'$ 都是好的。我们记这样的 $e$ 为 $E[V']$。

答案即 $\sum_{V'\subset V}(-1)^{|V'|-1}2^{|E[V']|}$。

### 特殊性质 B（无返祖边）

我们来注意到一个结论：

> 假设 $p,q,r\in V'$ 设 $v=center(p,q,r)$，即 $p,q,r$ 在树上交叉点。则对任意 $e\in E[V']$ 都有 $(v,e)$ 是好的。

正确性显然。

这说明，我们可以 $E[V']=E[vir(V')]$，其中 $vir(S)$ 表示 $S$ 点集在 $T$ 上构成的虚树。注意这里虚树不一定包含 $1$。

考虑 dp，定义 $f_u$ 表示只考虑 $u$ 子树内的关键点和额外边的容斥结果。我们在计算 $f_u$ 的时候需要维护 $sf_{0,1,2,\geq3}$ 表示当前已经选了 $t$ 个关键节点。

考虑转移：枚举 $u$ 的每个儿子 $v$，那么两种情况：

- 不选 $v$ 子树内的所有节点，那么你会获得 $2^{c_v}$ 的贡献。其中 $c_v$ 表示 $v$ 子树内部，或者 $fa_v\to v$ 子树内部的边数。
- 选择的 $v$ 子树内的某个节点 $w$，那么贡献是 $f_w\times 2^{p(v,w)}$。其中 $p(u,v)$ 表示 $u\to v$ 路径上的返祖边，或者挂在子树内部的边。

对于前者是容易维护的，后者我们把树拍成 dfn 序，然后每一条边的 $p$ 的贡献是一个区间。用个维护单点改，区间乘的线段树就行了。

最后我们得到 $f_u$ 之后还需要求出 $u$ 为根时子树外的返祖边数量。这里也可以通过 dfs 方法直接算出来。

时间复杂度：$\mathcal O(n\log n)$。

### 满分做法

考虑加入了非返祖边，实际上对 $f$ 并没有影响。现在唯一可能造成的影响是形如下图这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/iueqq4c6.png)

红色部分是虚树。绿色是额外边。

可以发现额外边在这个虚树上实际上也是好的。考虑修订这个小问题。

解决方式也是简单的，把每条非返祖边的额外边挂到 LCA 上面。对每个 LCA $u$ 而言，实际上就是一个 $siz_u\times siz_u$ 的矩阵，每个矩阵元素的值一开始是 $f_i\times f_j$。一条额外边的作用是给一个矩形所有元素 $\times 2$。要求这个矩形所有元素和。

这里可以通过简单的扫描线完成。

**【参考代码】**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=5e5+5;
const int MOD=1e9+7;
const int inv2=(MOD+1)/2;
int sid,n,m,k,in[MAXN],out[MAXN],dep[MAXN],tot;
int fa[MAXN][20],siz1[MAXN],siz2[MAXN],eu[MAXN],ev[MAXN],s[MAXN];
// siz1[u]: u 内横跨边的数量 + fa_u -> u 子树内的边的数量
// siz2[u]: dp 后的额外贡献，v 子树内 + p 子树外去掉 p 的祖先
vector<int> edg[MAXN],vec[MAXN];
vector<array<int,4>> oper[MAXN];
ll f[MAXN],pw[MAXN],ans;
bool ipt[MAXN];
inline void add(ll &x,ll y){x=(x+y)%MOD;}
inline void prod(ll &x,ll y){x=x*y%MOD;}
ll ksm(ll a,int b){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}
inline int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=19;i>=0;i--) if((dep[x]-dep[y])>>i&1) x=fa[x][i];
	if(x==y) return x;
	for(int i=19;i>=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
struct segt{
ll laz[MAXN<<2],s[MAXN<<2];
void build(int id=1,int l=1,int r=n){
	laz[id]=1;s[id]=0;
	if(l==r) return;
	int mid=l+r>>1;
	build(id<<1,l,mid);build(id<<1|1,mid+1,r);
}
void pushdown(int id){
	if(laz[id]==1) return;
	prod(laz[id<<1],laz[id]);prod(laz[id<<1|1],laz[id]);
	prod(s[id<<1],laz[id]);prod(s[id<<1|1],laz[id]);
	laz[id]=1;
}
void pushup(int id){s[id]=(s[id<<1]+s[id<<1|1])%MOD;}
void modify(int L,int R,int d,int id=1,int l=1,int r=n){
	if(L<=l&&r<=R){
		prod(laz[id],d);prod(s[id],d);
		return;
	}
	pushdown(id);
	int mid=l+r>>1;
	if(L<=mid) modify(L,R,d,id<<1,l,mid);
	if(mid<R) modify(L,R,d,id<<1|1,mid+1,r);
	pushup(id);
}
void upd(int x,int v,int id=1,int l=1,int r=n){
	if(l==r){s[id]=v;return;}
	pushdown(id);
	int mid=l+r>>1;
	if(x<=mid) upd(x,v,id<<1,l,mid);
	else upd(x,v,id<<1|1,mid+1,r);
	pushup(id);
}
ll ask(int L,int R,int id=1,int l=1,int r=n){
	if(L<=l&&r<=R) return s[id];
	pushdown(id);
	int mid=l+r>>1;
	if(R<=mid) return ask(L,R,id<<1,l,mid);
	if(mid<L) return ask(L,R,id<<1|1,mid+1,r);
	return (ask(L,R,id<<1,l,mid)+ask(L,R,id<<1|1,mid+1,r))%MOD;
}
}T;
int get_anc(int u,int p){
	for(int i=19;i>=0;i--) if(p>>i&1) u=fa[u][i];
	return u;
}
void dfs(int u,int f){
	fa[u][0]=f;
	for(int i=1;i<20;i++) fa[u][i]=fa[fa[u][i-1]][i-1];
	in[u]=++tot;
	for(int v:edg[u]) if(v!=f){
		dep[v]=dep[u]+1;
		dfs(v,u);
		oper[u].push_back({0,in[v]-1,0,in[v]});
	}
	out[u]=tot;
	oper[u].push_back({0,0,0,out[u]+1});
}
void dfs1(int u,int fa){
	for(int v:edg[u]) if(v!=fa){
		dfs1(v,u);
		siz1[u]+=siz1[v];siz2[u]+=siz2[v];
	}
	return;
}
void dfs2(int u,int fa){
	ll c=-siz2[u];
	for(int v:edg[u]) if(v!=fa) dfs2(v,u),c+=siz1[v];
	for(int p:vec[u]) T.modify(in[p],out[p],2);
	ll f0=1,f1=0,f2=0,f3=-ipt[u];
	for(int v:edg[u]) if(v!=fa){
		ll g0=f0*pw[siz1[v]]%MOD,g1=f1*pw[siz1[v]]%MOD;
		ll g2=f2*pw[siz1[v]]%MOD,g3=f3*pw[siz1[v]]%MOD;
		ll f=T.ask(in[v],out[v]);
		add(g1,f0*f%MOD);add(g2,f1*f%MOD);add(g3,(f2+f3)*f%MOD);
		f0=g0;f1=g1;f2=g2;f3=g3;
	}
	c=ksm(2,MOD-1-c);
	int lst=in[u]+1,ri=in[u]+1;
	for(int v:edg[u]) if(v!=fa){
		if(in[u]<=in[v]-1) T.modify(in[u],in[v]-1,pw[siz1[v]]);
		if(out[v]+1<=out[u]) T.modify(out[v]+1,out[u],pw[siz1[v]]);
	}
	for(auto o:oper[u]){
		if(in[u]<=ri&&lst<=o[3]-1){
			add(ans,c*T.ask(in[u],ri)%MOD*T.ask(lst,o[3]-1)%MOD);
		}
		if(o[0]==0) ri=o[1];
		else if(o[0]==1) T.modify(o[1],o[2],2);
		else T.modify(o[1],o[2],inv2);
		lst=o[3];
	}
	add(ans,f3*pw[siz2[u]]%MOD);
	T.upd(in[u],f[u]=(f2+f3)%MOD);
}
int main(){
	ios::sync_with_stdio(false);
	// freopen("dfs.in","r",stdin);
	// freopen("dfs.out","w",stdout);
	pw[0]=1;
	for(int i=1;i<MAXN;i++) pw[i]=pw[i-1]*2%MOD;
	cin>>sid>>n>>m>>k;
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		edg[u].push_back(v);
		edg[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1;i<=m;i++){
		cin>>eu[i]>>ev[i];
		if(dep[eu[i]]>dep[ev[i]]) swap(eu[i],ev[i]);
		if(!(in[eu[i]]<=in[ev[i]]&&out[ev[i]]<=out[eu[i]])){
			int p=lca(eu[i],ev[i]);
			if(in[eu[i]]>in[ev[i]]) swap(eu[i],ev[i]);
			oper[p].push_back({1,in[eu[i]],out[eu[i]],in[ev[i]]});
			oper[p].push_back({-1,in[eu[i]],out[eu[i]],out[ev[i]]+1});
			s[in[eu[i]]]++;s[out[eu[i]]+1]--;
			s[in[ev[i]]]++;s[out[ev[i]]+1]--;
		}else{
			int p=get_anc(ev[i],dep[ev[i]]-dep[eu[i]]-1);
			siz1[eu[i]]++;siz2[eu[i]]++;
			s[in[ev[i]]]++;s[out[ev[i]]+1]--;
			s[1]++;s[in[p]]--;s[out[p]+1]++;vec[eu[i]].push_back(ev[i]);
		}
	}
	for(int i=1;i<=n;i++) sort(oper[i].begin(),oper[i].end(),
		[&](auto x,auto y){return x[3]<y[3];});
	dfs1(1,0);
	for(int i=1;i<=n;i++) s[i]+=s[i-1];
	for(int i=1;i<=m;i++) if(in[eu[i]]<=in[ev[i]]&&out[ev[i]]<=out[eu[i]]){
		int p=get_anc(ev[i],dep[ev[i]]-dep[eu[i]]-1);
		siz1[p]++;
	}
	for(int i=1;i<=n;i++) siz2[i]=s[in[i]]-siz2[i];
	for(int i=1;i<=k;i++){
		int x;cin>>x;ipt[x]=true;
	}
	dfs2(1,0);
	ans*=-1;ans=(ans%MOD+MOD)%MOD;
	cout<<ans<<'\n';
	cerr<<"Running time: "<<1.*clock()/CLOCKS_PER_SEC<<'\n';
	return 0;
}
```

---

## 作者：SegTree (赞：1)

## 36pts 做法

注意到 $T$ 是以 $s$ 为根的 dfs 树当且仅当选取非树边没有横叉边。

要求存在合法，于是我们考虑钦定合法的点集，然后乘个 $(-1)^{|S|-1}$ 就可以了。
## 特殊性质 A

考虑利用容斥的思想，在链上 dp，记 $dp_i$ 为上个在链上选取的结点为 $s_i$ 的权值和，有转移：

$dp_i=-\sum_{j<i}dp_j2^{e(s_j,s_i)}-2^{e(1,s_i)}$。

答案为 $-\sum_{i=1}^s dp_i2^{e(s_i,n)}$。

其中 $e(l,r)$ 表示 $l\le x\le y\le n,(x,y)\in E$ 的个数，朴素计算容易做到 $O(n^2)$ 。优化是简单的，写一颗线段树支持区间乘区间和即可。

## 特殊性质 B
考虑延续特殊性质 A 的想法。记 $f_u$ 为当前钦定点集的 LCA 为 $u$ 的权值和，则转移相当于要么选择点 $u$，要么至少选够两个儿子。

不选择一个儿子的方案显然是 $2^{c_u}$，其中 $c_u$ 表示 $fa_u$ 连入的边数加上两端点完全落入以 $u$ 为根的子树的边数。

选择一个儿子 $x$ 的方案：枚举选择点 $p$，则考虑哪些边可以随便选，相当于是两端点落在 $x$ 子树内且不落在 $p$ 子树内，落在 $(x,p)$ 链上或者与 $(x,p)$ 相离（这里的相离定义在边上）。

还是可以用线段树维护，最后自由选择的 $e(s_i,n)$ 改成不落在 $u$ 子树内的边数就行。
## 正解
特殊性质 B 的问题在于存在横叉边是无法正确处理。

因此需要把上面的两个儿子的限制改成三个儿子（这样不会受到横叉边的影响），然后单独考虑两个儿子的情况：

设选取的点为 $(p,q)$，当前枚举的 LCA 为 $u$，那么一条横叉边可造成贡献当且仅当一个端点位于 $(p,u)$ 的路径上，一个端点位于 $(q,u)$ 的路径上。

这个问题考虑扫描线，然后还是可以线段树维护区间乘区间和。这个时候自由选择的是不落在两个儿子内的边的个数，这是容易的。

时间复杂度：$O(n\log n)$。

---

## 作者：_Ch1F4N_ (赞：1)

先考虑怎么做特殊性质 B，不难发现此时如果以 $1$ 为根，所有的额外边都是返祖边。

结合前面 $k \leq 6$ 的部分分，我们可以考虑对关键点容斥，暴力的看就是枚举关键点子集 $S$，计算使得 $S$ 中的点为根均存在合法 dfs 树（即以这些点为根树上没有横叉边）的选取额外边的方案。

又要选取关键点又要选取额外边，看上去情况非常复杂，不妨认为关键点是计数的主体，也就是在刻画了关键点形态后再看看能否简单地计算选取额外边的方案。

首先我们知道一条额外边 $u,v$ 会导致树上 $u,v$ 路径之间的点（不包括 $u,v$）以及这些点上挂着的不向链 $u,v$ 方向上延伸的子树中所有点被禁用，也就是这些点作为根时 $u,v$ 是横叉边，故我们发现选取了关键点集合后选择额外边的方案就是 $2$ 的可以选的（没有导致任何一个子集中的关键点被禁用）额外边数量次方。

考虑怎么刻画可以选的额外边，由于这个问题在树上，不妨建立关键点子集的虚树。然后手玩一下额外边可选的充要条件。

![](https://cdn.luogu.com.cn/upload/image_hosting/sjnitguu.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

如图，红色点是关键点，黄色点是虚树上的非关键点，橙色是虚树的边。

直接横跨红色点的边显然会直接禁用掉这个关键点，而横跨了黄色点的边也会禁用掉这个点另一个方向上的关键点，如图中蓝色边禁用了点 X，从被虚树边覆盖的点出发如果先沿着虚树边方向走一段再拐出去会导致虚树边下方的关键点被禁用，如图中紫色边禁用了点 Y。

所以合法的额外边是被虚树的边完整覆盖的边，从被虚树边覆盖的点出发直接进入向边外方向挂着的子树的边（如图中两条绿色边）以及部分完全游离在虚树之外的边。

这里之所以是部分是因为虚树根到 $1$ 的路径上的点也会受到类似于虚树覆盖边的约束，其余的虚树外的边是可以任选的。

我们考虑对这个东西计数。

考虑设计状态 $f_{u,0/1/2}$ 表示考虑点 $u$ 的子树内所有关键点选取方案，在点 $u$ 不属于关键点子集并且其 $1$ 个儿子，$\geq 2$ 个儿子子树内存在选入子集的关键点与自身就是选入点集的关键点的前提下，所有方案带权和。

考虑转移，类似一个背包，关键是怎么快速处理一个 $v$ 转移到其祖先 $u$ 的转移系数。

不妨把转移系数拆为两个部分，$v$ 到 $u$ 路径上被完整覆盖的边与 $u$ 到 $v$ 路径上（不包括 $u,v$）挂着的进入边外方向子树的边的选取方案与点 $u$ 出发不进入 $v$ 所在子树的边的选取方案。

这么做是因为如果一个点 $u$ 在虚树上存在多个儿子就需要挖去多个子树内的边。

因此后半部分的贡献可以这么计算：选取了 $v$ 子树内的儿子时，将贡献乘上进入 $v$ 内边的选取方案的 $-1$ 次方，最后再给 $f$ 乘上点 $u$ 挂着的边的选取方案即可。

前半部分的贡献快速计算可以考虑：点 $v$ 到 $u$ 与点 $v$ 到 $fa_u$ 的前半部分贡献差量为挂在 $u$ 上的，下端 $w$ 也是 $v$ 祖先的额外边与挂在 $u$ 上的不进入 $v$ 所在子树的边选取方案，考虑在树形 DP 的过程中用线段树维护 dfs 序每个位置上的点的贡献值，从 $u \to fa_u$ 的过程中要进行的就是若干次子树乘（dfs 序区间乘），所以这部分时间复杂度是 $O(n \log n)$。

最后再来考虑一下完全游离在虚树外的边的选取方案，不难通过简单树形 DP 求解出来。

现在考虑做原题，手玩一下不难发现横叉边可以选的情形只有两个，一种是虚树根到 $1$ 的路径上的点上挂着的横叉边，另一种就是下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/gba63wdz.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

只有横插边只覆盖了虚树的根并且这个根不属于选取的关键点集，且两个端点内均有一个虚树上的点（如浅蓝色边）时才合法，只要有一个虚树上的点没有被端点子树覆盖，其虚树子树内关键点就会被禁用（如粉色边）。

考虑怎么快速统计这个部分的贡献，考虑把横叉边挂在其 lca 上，然后在对于一个 $u$ 统计 lca 是其的横插边贡献时，考虑如果枚举其的一个虚树上的儿子结点 $x$，虚树上另一个儿子结点 $y$ 所需要满足的条件就是与 $x$ 不在同一个 $u$ 的子树内，贡献就是将 $x$ 的祖先中挂着的所有横叉边的另一个端点子树内所有乘 $2$ 然后将满足要求的所有 $y$ 的贡献求和，注意这里依然需要给每个子树内的贡献乘上进入其内边的选取方案的 $-1$ 次方，最后再给对答案的贡献乘上点 $u$ 挂着的边的选取方案。

然而你不可能 dfs 整个子树，但是考虑由于横叉边数量总和很少，所以不妨对挂在 $u$ 上的横叉边的端点建立虚树，不难发现虚树上一个点子树去除其所有虚树上儿子的子树构成的部分满足贡献情形相同，于是对这个部分一起贡献即可，时间复杂度 $O((n+m) \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
const int maxn = 5e5+114;
int n,m,k;
int vis[maxn];
vector<int> E[maxn];
int L[maxn],R[maxn];
int dfncnt;
int dep[maxn],sz[maxn],son[maxn];
int top[maxn],fa[maxn];
void dfs1(int u){
    sz[u]=1;
    dep[u]=dep[fa[u]]+1;
    for(int v:E[u]){
        if(v!=fa[u]){
            fa[v]=u;
            dfs1(v);
            sz[u]+=sz[v];
            if(sz[v]>sz[son[u]]) son[u]=v;
        }
    }
}
int node[maxn];
void dfs2(int u,int tp){
    top[u]=tp;
    L[u]=++dfncnt;
    node[dfncnt]=u;
    if(son[u]!=0) dfs2(son[u],tp);
    for(int v:E[u]){
        if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
    }
    R[u]=dfncnt;
}
int LCA(int u,int v){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    return v;
}
vector<int> toson[maxn];
int tofa[maxn];
vector< pair<int,int> > xtr[maxn];
int f[maxn][3];//0 有一个儿子子树内存在关键点且自己不是关键点 1 有至少两个儿子子树内存在关键点且自己不是关键点 2 自己是关键点
int sube[maxn];//u 子树内完整包含的返祖边数量
int jump(int u,int v){
    //u jump
    while(top[u]!=top[v]){
        if(fa[top[u]]==v) return top[u];
        u=fa[top[u]];
    }
    return node[L[v]+1];
}
int sone[maxn];//挂在点 x 上进入其儿子 y 的子树的返祖边
int _pow[maxn];//2^x
int inv[maxn];//2^x 的逆元
void DP1(int u){
    sube[u]=toson[u].size();
    for(int v:E[u]){
        if(v!=fa[u]){
            DP1(v);
            sube[u]+=sube[v];
        }
    }
}
int tr[maxn<<2],tag[maxn<<2];
void pushup(int cur){
    tr[cur]=(1ll*tr[cur<<1]+tr[cur<<1|1])%mod;
}
void pushdown(int cur){
    tr[cur<<1]=1ll*tr[cur<<1]*tag[cur]%mod;
    tag[cur<<1]=1ll*tag[cur<<1]*tag[cur]%mod;
    tr[cur<<1|1]=1ll*tr[cur<<1|1]*tag[cur]%mod;
    tag[cur<<1|1]=1ll*tag[cur<<1|1]*tag[cur]%mod;
    tag[cur]=1;
}
void change(int cur,int lt,int rt,int l,int r,int c){
    if(rt<l||r<lt) return ;
    if(l<=lt&&rt<=r){
        tr[cur]=1ll*tr[cur]*c%mod;
        tag[cur]=1ll*tag[cur]*c%mod;
        return ;
    }
    int mid=(lt+rt)>>1;
    pushdown(cur);
    change(cur<<1,lt,mid,l,r,c);
    change(cur<<1|1,mid+1,rt,l,r,c);
    pushup(cur);
}
void add(int cur,int lt,int rt,int pos,int v){
    if(lt==rt){
        tr[cur]=(1ll*tr[cur]+v)%mod;
        return ;
    }
    int mid=(lt+rt)>>1;
    pushdown(cur);
    if(pos<=mid) add(cur<<1,lt,mid,pos,v);
    else add(cur<<1|1,mid+1,rt,pos,v);
    pushup(cur);
}
int ask(int cur,int lt,int rt,int l,int r){
    if(rt<l||r<lt) return 0;
    if(l<=lt&&rt<=r) return tr[cur];
    int mid=(lt+rt)>>1;
    pushdown(cur);
    return (1ll*ask(cur<<1,lt,mid,l,r)+ask(cur<<1|1,mid+1,rt,l,r))%mod;
}
int ans;
int dp[maxn];//虚树子树根为 u 时 u 子树外贡献
int xtrval[maxn];
int subkey[maxn];
void DP2(int u){
    subkey[u]=vis[u];
    for(int v:E[u]){
        if(v!=fa[u]){
            //u 到 1 的贡献变为 v 到 1 的贡献
            int cnt=sube[u]-sube[v]-sone[v]+tofa[v]+xtrval[v];
            dp[v]=1ll*dp[u]*_pow[cnt]%mod;
            DP2(v);
            subkey[u]+=subkey[v];
        }
    }
}
vector<int> Vtr[maxn];
vector<int> insv[maxn];
int val;
int ql,qr,root;
void DP4(int u){
    if(u==root){
        qr=R[Vtr[u][0]];
        for(int i=1;i<Vtr[u].size();i++){
            DP4(Vtr[u][i]);
            qr=R[Vtr[u][i]];
        }
        return ;
    }
    for(int x:insv[u]){
        change(1,1,n,L[x],R[x],2);
    }
    int res=ask(1,1,n,L[u],R[u]);
    for(int v:Vtr[u]){
        res=(1ll*res+mod-ask(1,1,n,L[v],R[v]))%mod;
        DP4(v);
    }
    res=1ll*res*ask(1,1,n,ql,qr)%mod;
    val=(1ll*val+res)%mod;
    for(int x:insv[u]){
        change(1,1,n,L[x],R[x],(mod+1)/2);
    }
}
void DP3(int u){
    for(int v:E[u]){
        if(v!=fa[u]){
            DP3(v);
        }
    }
    //完整包含路径新增贡献
    for(int v:toson[u]){
        change(1,1,n,L[v],R[v],2);
    }
    for(int v:E[u]){
        if(v!=fa[u]){
            //v 子树内点转移到 v 的系数变成转移到 u 的系数
            //点 x 转移到祖先 v 的系数是 dp[x] 乘上 x 到 v 路径上（不包括 x 和 v）所有点向链外子树挂的返祖边与链外子树内部的返祖边选取方案再乘上 x 到 v 的链上（包括 x 和 v）完整包含的返祖边选取方案
            for(int w:E[v]){
                if(w!=fa[v]){
                    int cnt=sube[v]-sube[w]-sone[w];
                    change(1,1,n,L[w],R[w],_pow[cnt]);
                }
            }//链外子树
            //x 转移到 u 时，转移系数额外乘上 (2^{sone[v]+sube[v]}) 的逆元
            //最后给 f 乘上 2^{sube[u]} 就相当于给没有关键点的子树计算了返祖边从 u 进入其和被其包含的贡献
            int res=ask(1,1,n,L[v],R[v]);
            res=1ll*res*inv[sone[v]+sube[v]]%mod;
            f[u][1]=(1ll*f[u][1]*(res+1)%mod+1ll*f[u][0]*res%mod)%mod;
            f[u][0]=(1ll*f[u][0]+res)%mod;
        }
    }
    if(xtr[u].size()>0&&subkey[u]-vis[u]>=2){
        for(int v:E[u]){
            if(v!=fa[u]){
                change(1,1,n,L[v],R[v],inv[sone[v]+sube[v]]);
            }
        }
        vector<int> S;
        for(pair<int,int> now:xtr[u]){
            S.push_back(L[now.first]);
            S.push_back(L[now.second]);
            int x=now.first,y=now.second;
            if(L[x]>L[y]) swap(x,y);
            insv[y].push_back(x);
        }
        for(int v:E[u]){
            if(v!=fa[u]) S.push_back(L[v]);
        }
        sort(S.begin(),S.end());
        S.erase(unique(S.begin(),S.end()),S.end());
        vector<int> vec;
        for(int x:S) vec.push_back(x);
        for(int i=0;i+1<S.size();i++) vec.push_back(L[LCA(node[S[i]],node[S[i+1]])]);
        sort(vec.begin(),vec.end());
        vec.erase(unique(vec.begin(),vec.end()),vec.end());
        for(int i=0;i+1<vec.size();i++) Vtr[LCA(node[vec[i]],node[vec[i+1]])].push_back(node[vec[i+1]]);
        val=0;
        ql=L[u]+1,root=u;
        DP4(u);
        int sum=0;
        for(int v:E[u]){
            if(v!=fa[u]){
                val=(1ll*val+mod-1ll*sum*ask(1,1,n,L[v],R[v])%mod)%mod;
                sum=(1ll*sum+ask(1,1,n,L[v],R[v]))%mod;
            }
        }
        val=1ll*val*_pow[sube[u]]%mod;
        ans=(1ll*ans+1ll*val*dp[u]%mod)%mod;
        for(int x:vec) Vtr[node[x]].clear(),insv[node[x]].clear();
        for(int v:E[u]){
            if(v!=fa[u]){
                change(1,1,n,L[v],R[v],_pow[sone[v]+sube[v]]);
            }
        }
    }
    f[u][0]=1ll*f[u][0]*_pow[sube[u]]%mod;
    f[u][1]=1ll*f[u][1]*_pow[sube[u]]%mod;
    if(vis[u]==1) f[u][2]=(1ll*f[u][0]+f[u][1]+_pow[sube[u]])%mod*(mod-1)%mod;//容斥 加入一个点贡献乘上 -1 注意这里的容斥系数是 (-1)^{|S|} 最后要给答案整体乘上 -1
    //其中 _pow[sube[u]] 是将 u 作为虚树上一个新叶子的贡献
    //单独选一个虚树上的叶子
    ans=(1ll*ans+(1ll*f[u][1]+f[u][2])%mod*dp[u]%mod)%mod;//虚树根子树外的贡献是子树根到 1 的路径上（不包括子树根）所有点向链外子树的返祖边与所有被链外子树包含的返祖边与子树根到 1 路径上（包括子树根）被完整包含的返祖边，这个可以事先 dp 预处理
    add(1,1,n,L[u],(1ll*f[u][1]+f[u][2])%mod);
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int id;
    cin>>id;
    cin>>n>>m>>k;
    _pow[0]=inv[0]=1;
    for(int i=1;i<=m;i++) _pow[i]=1ll*_pow[i-1]*2%mod,inv[i]=1ll*inv[i-1]*((mod+1)/2)%mod;
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        E[u].push_back(v);
        E[v].push_back(u);
    }
    dfs1(1);
    dfs2(1,1);
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        if(dep[u]<dep[v]) swap(u,v);
        if(LCA(u,v)==v){
            toson[v].push_back(u),tofa[u]++;
            sone[jump(u,v)]++;
        }else xtr[LCA(u,v)].push_back(make_pair(u,v)),xtrval[u]++,xtrval[v]++;
    }
    for(int i=1;i<=k;i++){
        int x;
        cin>>x;
        vis[x]=1;
    }
    for(int i=0;i<(maxn<<2);i++) tag[i]=1;
    DP1(1);
    dp[1]=1;
    DP2(1);
    DP3(1);
    cout<<(1ll*mod-ans)%mod<<"\n";
    return 0;
}
```

---


# [NOI2023] 合并书本

## 题目描述

小 C 有 $n$ 本书，每本书都有一个重量，他决定把它们合并成一摞。

每一次合并小 C 可以把一摞书放到另一摞书上面，使得它们合并到一摞。如果小 C 把第 $i$ 摞书放到第 $j$ 摞书上面，小 C 需要消耗的体力为**第 $i$ 摞书的重量**加上**两摞书的磨损值之和**。

初始时每本书自成一摞且磨损值均为 $0$。每当小 C 将两摞书合并后，形成的新的一摞书的磨损值为合并前的两摞书的磨损值的**较大值的两倍再加一**，重量为合并前的两摞书的**重量之和**。

你的任务是设计出合并的次序方案，使小 C 耗费的体力最少，并输出这个最小的体力耗费值。

## 说明/提示

**【样例解释 #1】**

如果小 C 将 $4$ 本书两两合并再将得到的两摞合并成一摞，那么前两次需要消耗的体力值各为 $1$。第三次将一摞重量为 $2$ 的书放到另一摞上面，两摞书磨损值各为 $1$，需要消耗的体力为 $2 + 1 + 1 = 4$。

因此如果选择这个方案，小 C 耗费的体力只有 $1 + 1 + 4 = 6$。

可以证明，在上述例子中，$6$ 为最小的体力耗费值。

**【数据范围】**

对于所有测试数据保证：$1 \le t \le 10$，$1 \le n \le 100$，$1 \le w_i \le 10 ^ 9$。

|测试点编号|$n \le$|是否有特殊性质|
|:-:|:-:|:-:|
|$1 \sim 2$|$7$|否|
|$3$|$11$|否|
|$4$|$13$|否|
|$5 \sim 6$|$22$|否|
|$7 \sim 8$|$28$|否|
|$9 \sim 13$|$50$|否|
|$14$|$60$|否|
|$15$|$70$|否|
|$16$|$80$|否|
|$17 \sim 18$|$100$|是|
|$19 \sim 20$|$100$|否|

特殊性质：保证 $w_i = 1$。

## 样例 #1

### 输入

```
1
4
1 1 1 1
```

### 输出

```
6
```

## 样例 #2

### 输入

```
见附件中的 book/book2.in。```

### 输出

```
见附件中的 book/book2.ans。```

## 样例 #3

### 输入

```
见附件中的 book/book3.in。```

### 输出

```
见附件中的 book/book3.ans。```

## 样例 #4

### 输入

```
见附件中的 book/book4.in。```

### 输出

```
见附件中的 book/book4.ans。```

# 题解

## 作者：asmend (赞：41)

考虑对合并过程建一棵树。

对于一个点 $x$，定义 $a_x$ 表示它向上合并的时候，对答案造成的重量贡献的系数。

定义一个点的层级 $d_x$ 为它的两个儿子层级的较大值 $+1$。我们称 $d$ 更小的层级为更深的层级。

那么层级为 $i$ 的非根非叶子节点会对答案造成 $2^i-1$ 的磨损值贡献。由于非根非叶子节点共有 $n-2$ 个，可以当成是造成 $2^i$ 的贡献，最后给答案减掉 $n-2$ 即可。

考虑这样一个过程：从浅往深（从大往小）扫每一层 $i$，找出所有 $d_x<i$ 但 $d_{fa_x}\geq i$ 的点 $x$，那么我们只关心可重集 $S=\{a_x\}$ 以及层数 $\geq i$ 的点的磨损值贡献之和（记作 $c$）。

考虑从 $i$ 层转移到第 $i-1$ 层时会发生什么，这相当于选择一些叶子把它们分裂成两个叶子。也就是选择 $S$ 的一个子集 $T$，对每个 $t\in T$，将 $t+1$ 加入到 $S$，然后令 $c=2(c+|T|)$。

然后我们发现两个性质。一个是 $T$ 一定是 $S$ 的一个前缀，这是显然的。另一个是对于一个方案，$|T|$ 从浅到深单调不降，否则我们可以把某个点留到更深的层级再分裂。

于是可以考虑搜索，每次暴力枚举 $|T|$，一共有划分数种方案，可以获得 75 分。

然后我们发现，对于 $S$ 相同的状态，只有 $c$ 最小的那个是有用的，可以 bfs 搜出所有状态。实测 $n\leq 100$ 的时候只有 $47575$ 个状态，可以通过。

``` cpp
int lim;
int t,_,n[15],m,i,j,k,a[15][105],vis[500005],lst[500005];
i64 ans,dis[500005];
int ch[500005][105],cnt;
vector<int> seq[500005];
vector<int> f[105];
int qid(vector<int> v)
{
	int x=0,i,len=0;
	vector<int> cur;
	ff(v,it){
		cur.push_back(*it);
		if(!ch[x][*it]){
			ch[x][*it]=++cnt;
			f[cur.size()].push_back(cnt);
			seq[cnt]=cur;
			dis[cnt]=1e18;
		}
		x=ch[x][*it];
	}
	return x;
}
void upd(vector<int> v,i64 c,int l)
{
	int x=qid(v);
	if(dis[x]>c){
		dis[x]=c;lst[x]=l;
	}
	if(dis[x]==c){
		lst[x]=max(lst[x],l);
	}
}
int main()
{
	//cerr<<sizeof(ch)/1048576<<endl;
	read(t);fz1(i,t){read(n[i]);fz1(j,n[i])read(a[i][j]);lim=max(lim,n[i]);}
	upd({0},0,0);
	fz1(_,lim)for(int x:f[_]){
		i64 cur=dis[x]*2;
		vector<int> v=seq[x];
		vector<int> nv=v;
		fz0k(i,v.size()){
			if(x!=1) cur+=2;nv.push_back(v[i]+1);int j=nv.size()-1;
			if(nv.size()>lim) break;
			while(j&&nv[j]<nv[j-1])swap(nv[j],nv[j-1]),j--;
			if(i>=lst[x]) upd(nv,cur,i);
		}
	}
	//cerr<<cnt<<endl;
	fz1(k,t){
		ans=1e18;sort(a[k]+1,a[k]+n[k]+1);
		if(n[k]==1){puts("0");continue;}
		for(int i:f[n[k]]){
			i64 sum=dis[i];
//			cerr<<dis[i]<<endl;ff(seq[i],it) cerr<<*it<<' ';cerr<<endl;
			fz1(j,n[k]) sum+=1ll*a[k][j]*seq[i][n[k]-j];
			ans=min(ans,sum);
		}
		printf("%lld\n",ans-(n[k]-2));
	}
	return 0;
}
```


---

## 作者：Alex_Wei (赞：26)

### *[P9483 [NOI2023] 合并书本](https://www.luogu.com.cn/problem/P9483)

对 [csy 题解](https://www.luogu.com.cn/blog/21658/solution-p9483) 的补充说明。

考虑一棵合并树，它对应的磨损值为所有非叶结点磨损值之和（叶子的磨损值为 $0$），减去根节点的磨损值。但是，如果我们希望得到每个非叶结点对重量造成的劳累度的贡献，就难以避免记录子树内的物品集合。因此，我们必须抛弃这种思想。

如果不能预先知道每个非叶结点的重量贡献，应如何求出重量对劳累度的贡献的最小值？非叶结点不可知，那么只能将贡献下放到叶子处统计。每个叶子的 “**重量贡献系数**” 就是包含它的子树作为 “轻子树” 与另一个子树合并的次数。若已知每个叶子的重量贡献系数 $c_i$，问题就转化为了求排列 $p$ 最小化 $\sum c_i a_{p_i}$，这是经典问题：将 $c$ 从小到大排序，将 $a$ 从大到小排序后依次匹配即可。这说明我们只关心 $c_i$ 形成的可重集 $S$。

想要凭空构建出树形结构，一般有两种方式：自顶向下和自底向上。

##### 自底向上

所谓自底向上，就是枚举根节点合并的两棵子树 $T_l, T_r$。

为了能够计算出新的磨损值和新的可重集，思考哪些信息是必要的：子树叶子结点最大深度 $d$，子树磨损值之和 $v$，和子树的重量贡献系数可重集 $S$。方便起见，我们认为 $v$ 包含根节点的磨损值。

合并 $T_l$ 和 $T_r$ 得到 $T$，考虑如何计算出 $d(T), v(T)$ 和 $S(T)$。

显然，$d(T) = \max(d(T_l), d(T_r)) + 1$，$v(T) = v(T_l) + v(T_r) + 2 ^ {d(T)} - 1$。

对于 $S(T)$，钦定左子树或右子树更重，可以选择将 $S(T_l)$ 或 $S(T_r)$ 的所有元素全部加 $1$，再和另一个取并，这一步的两个选择将产生不同的 $T$。

对于 $S$ 和 $d$ 值均相同的两棵树 $T, T'$，显然 $v$ 值更小的那一棵更优。因此，设 $f_{S, d}$ 表示固定 $S$ 和 $d$ 时 $v$ 的最小值，根据上述分析转移即可。

但这样太慢了，考虑剪枝：对于两个状态 $(S, d, v)$ 和 $(S', d', v')$，如果 $|S| = |S'|$，$S'$ 被 $S$ 严格偏序（即对于所有 $1\leq i\leq |S|$，$S$ 的第 $i$ 小的值不大于 $S'$ 的第 $i$ 小的值），$d\leq d'$，$v\leq v'$，那么 $(S', d', v')$ 就是不优的。

按层转移，每次求出所有 $|S| = i$ 的 $f_{S, d}$，然后暴力做偏序。按二元组 $(S, d)$ 的字典序枚举，检查它前面所有未被偏序的状态是否将它偏序（由于按字典序枚举，一个状态不会被它后面的状态排序）。若一个状态被偏序则从 $f$ 中删去。

按这样的思路写，可以通过 $n\leq 50$，获得 $65$ 分：$|S| = 50$ 的状态数仅有 $245$。观察性质加入更多剪枝后可以通过 $n\leq 60$，多获得 $5$ 分（听说 dx 可以过 $n\leq 80$）。

这种思路的瓶颈在于：做偏序前的状态很多，而暴力做偏序的代价很大，整个算法就卡在这了。因此，我们必须考虑自顶向下。代码见底部链接。

##### 自顶向下

所谓自顶向下，就是从只有根节点开始，记录所有叶子的状态，每次分裂若干叶子得到新的叶子。这刚好与 “记录所有叶子的贡献系数” 的要求相吻合，说明这个思路更有前途。

类似地，考虑记录叶子的贡献系数可重集 $S$ 和当前整棵树的磨损值之和。

若一个结点的子树最大深度为 $d$，则称该结点在第 $d$ 层，将其放在从下往上数的第 $d$ 层。我们发现，每一次分裂，所有非叶结点的层数全部加 $1$。因为如果某个非叶结点层数没有加 $1$，那么可以将它的整棵子树的深度全部加 $1$，即层数全部减 $1$，也就是延后这个非叶结点分裂出两个叶子的时间。注意，一个结点越晚被分裂，那么它的层数就越少，对应的磨损值越小。

这就意味着不用关心当前树的深度：考虑分裂一次，分裂后的所有非叶非根结点的权值变为原来的两倍加 $1$（无论原来是叶子还是非叶子）。因此，每次分裂后磨损值之和变为原来的两倍，加上分裂后非叶非根结点数量，也就是叶子数量减 $2$。根节点的贡献一直为 $0$，乘以 $2$ 之后仍为 $0$。

磨损度之和考虑完了，接下来考虑 $S$ 每次分裂如何变化。一个贡献系数为 $c$ 的叶子分裂后会变成一个贡献系数为 $c$ 的叶子和一个贡献系数为 $c + 1$ 的叶子。因此，若选中叶子集合 $T\subseteq S$ 进行分裂，那么 $S$ 会变成 $S$ 并上 $T$ 中的每个元素加 $1$。若固定了选中的叶子个数 $|T|$，那么磨损值的变化也就随之确定了。为了让新的 $S$ 的每个元素尽可能小，我们显然会选择 $S$ 中最小的 $|T|$ 个数进行分裂。证明这一点很容易，就略去了。

设 $f_S$ 表示贡献系数可重集为 $S$ 的最小磨损值，每次枚举 $S$ 最小的若干个数分裂扩展更新。这样状态数略多，$|S| = 50$ 的状态有 $1466$ 个，但转移复杂度很小，可以通过 $n\leq 70$。代码见底部链接。

回到我们得出 “每个非叶结点层数必然加 $1$” 的结论的地方。思考一下这到底意味着什么：对于上一轮某个叶子分裂出的两个叶子，至少有一个必须在这一轮分裂，否则上一轮的叶子就可以留到这一轮分裂。这说明每一轮分裂的叶子个数 $|T|$ 单调不降。那么我们有必要再记录上一轮分裂的叶子个数（设为 $m$）这一维吗？并没有！对于相同的 $S$ 的不同状态 $(v, m)$ 和 $(v', m')$，将它们合并得到 $(\min(v, v'), \min(m, m'))$ 就可以保证在让磨损值尽量小的同时不漏掉所有可能称为最优解的状态了：假设最优解由 $(v, m)$ 扩展到，那么将 $m$ 改成 $\min(m, m')$ 反而扩大了搜索范围，显然不劣；假设最优解由 $(v', m')$ 扩展到，那么由于 $\min(m, m') \leq m'$，所以最优解接下来每一步的分裂操作均可以从 $(\min(v, v'), \min(m, m'))$ 依次扩展得到，而 $\min(v, v')\leq v'$，所以这样得到的解一定不劣于最优解。

这个剪枝看起来没啥用，但仔细想想，对于大部分状态，想要达到该状态所需的最后一次分裂的叶子个数最小值并不小，所以它实际上是非常有用的。再加上去掉 $v \geq 5\times 10 ^ {11}$ 的剪枝（$100$ 个 $10 ^ 9$ 的答案小于这个值）对于 $|S| = 100$，只有惊人的 $1790$ 个状态。总状态数为 $44863$，可以通过本题，甚至可以做 $T = 10 ^ 3$。[代码](https://www.luogu.com.cn/paste/1h94nbi5)。

所以不知道标算究竟在干啥捏。

以下是和 csy 深入探讨这个做法时得到的一些东西。

将 $\min(m, m')$ 改成取最小的 $v$ 对应的某个 $m$ 也可以：考虑 $v < v'$ 但 $m' < m$，此时应如何决策？假设 $(v', m')$ 能够扩展到最优解，那么将后继操作复制到 $(v, m)$ 上可得磨损值更小且最终 $S$ 相同的优于最优解的解，这与最优解矛盾。因此直接取 $(v, m)$ 就是正确的。这里可能有读者会产生疑问：如果 $(v', m')$ 对应最优解的下一步分裂了 $m'' < m$ 个叶子，那么从 $(v, m)$ 出发不就无法遍历到最优解了吗？请注意：在不忽略任何 $S$ 相同时不同的二元组 $(v, m)$ 时，最优解显然是可达的，而刚才证明了所有 $v < v'$ 的 $(v', m')$ 不可达最优解。因此忽略掉这些状态后，最优解仍然是可达的，也就是我们总能找到最优解。

甚至将 $\min(m, m')$ 改成 $\max(m, m')$ 也可以，但是不会证。



---

## 作者：dead_X (赞：17)

## 前言
对不起。对不起。对不起。对不起。对不起。对不起。对不起。对不起。
## 思路
直接基于序列去动态构建决策树肯定死路一条。

考虑决策树的形态，一定是一棵完全二叉树（每个节点有 $0/2$ 个孩子），代表右孩子放到了左孩子上。

尝试记录一棵决策树的信息，$dep$ 和 $dep$ 造成的代价和 $cost$ 都与 $a_i$ 无关，可以直接通过树的形态算出。而剩下每个叶子也能算出会贡献进答案的次数 $c_i$，也就是到根路径上走右孩子的次数。我们直接记录这些数的可重集即可作为一个合法状态。

最后考虑一个决策是严格比另一个决策优，当且仅当满足以下条件：

- $dep$ 小于等于另一个决策。
- $cost$ 小于等于另一个决策。
- 对于任意 $t$，$c_i\geq t$ 的 $i$ 的数量小于等于另一个决策。

于是我们直接维护所有可能的决策进行 DP 转移，再删除掉不优的决策即可。注意到 $n\leq 100$ 时决策的数量在 $M=10^3$ 级别，而我们的算法复杂度为 $O(M^3\log M)$，加上一些剪枝优化即可通过。

笔者的代码使用了下列剪枝，可以通过本题：

- 我们不需要记录 $cost>10^{13}$ 的决策，因为 $a_i=10^9$ 只需要约 $10^{12}$ 的代价。
- 我们不需要记录轻子树 $dep$ 超过 $10^3$ 的决策，因为打表发现没有。
- 预处理 $c_i\geq t$ 的 $i$ 的数量的数组 $d_t$，由于上一条剪枝只需要开 $10$ 左右的数组。

## 代码
```
// Problem: P9483 [NOI2023] 合并书本
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P9483
// Memory Limit: 512 MB
// Time Limit: 1500 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//♡_______♡
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
ll a[103];
struct node
{
	ll dep,cost;
	unsigned char occ[8];
	ll ld,rd;
	inline bool operator<(const node&t)const
	{
		if(dep!=t.dep) return dep<t.dep;
		if(cost!=t.cost) return cost<t.cost;
		for(int i=1; i<8; ++i)
			if(occ[i]!=t.occ[i]) return occ[i]<t.occ[i];
		return 0;
	}
};
vector<node> st[103];
node merge(const node &x,const node &y)
{
	node t=x;
	t.dep=(max(x.dep,y.dep)<<1)+1,
	t.cost=x.cost+y.cost+x.dep+y.dep;
	for(int i=0; i<7; ++i) t.occ[i+1]+=y.occ[i];
	t.occ[0]+=y.occ[0];
	t.ld=x.dep,t.rd=y.dep;
	return t;
}
bool cmp(const node &x,const node &y)
{
	if(x.dep<y.dep) return 1;
	if(x.cost<y.cost) return 1;
	for(int i=1; i<8; ++i) if(x.occ[i]<y.occ[i]) return 1;
	return 0;
}
const int N=100,G=1e3;
signed main()
{
	node e;
	memset(e.occ,0,sizeof(e.occ)),
	e.occ[0]=1,e.dep=e.cost=0,st[1].push_back(e);
	for(int i=2; i<=N; ++i)
		for(int j=1; j<=i-j; ++j)
		{
			for(node x:st[j]) for(node y:st[i-j])
			{
				if(y.dep<=G)
				{
					node Z=merge(x,y);
					if(st[i].empty()||cmp(Z,st[i].back()))
						st[i].push_back(Z);
				}
				if(j<i-j&&x.dep<=G)
				{
					node Z=merge(y,x);
					if(st[i].empty()||cmp(Z,st[i].back()))
						st[i].push_back(Z);
				}
			}
			stable_sort(st[i].begin(),st[i].end());
			vector<node> ans;
			for(node j:st[i])
				if(j.cost<1e13&&(ans.empty()||cmp(j,ans.back())))
					ans.push_back(j);
			ans.swap(st[i]);
		}
	for(int T=read(); T--;)
	{
		int n=read();
		for(int i=1; i<=n; ++i) a[i]=read();
		sort(a+1,a+n+1);
		ll ans=1e18;
		for(int i=1; i<=n; ++i) a[i]+=a[i-1];
		for(node i:st[n])
		{
			ll sum=i.cost;
			for(int j=1; j<8; ++j) sum+=a[i.occ[j]];
			ans=min(ans,sum);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Leasier (赞：10)

首先不难想到把我们堆书的过程建成一棵树：

- 叶子表示初始的书。
- 非叶子 $u$ 表示把 $ls_u$ 堆到 $rs_u$ 上。
- $u$ 的质量为其子树中叶子的质量之和，磨损值为 $2^{d_u - 1}$，其中 $d_u$ 表示 $u$ 子树中的最大深度。

考虑最终的贡献由啥构成：

- 每个作为左儿子的点的质量之和。
- 除根之外的磨损值之和。

设 $a_i$ 表示叶子 $i$ 到根的路径上作为左儿子的次数，则第一部分的答案为 $\displaystyle\sum_{i = 1}^n a_i w_i$。

贪心地，对于一个升序排序的 $a_i$，我们只需要让 $w_i$ 降序排序即可取得对应项相乘之和的最小值，于是我们只需要关注 $a$ 所构成的可重集。

在“重构树”的结构未知的情况下，我们有两种思路——**自底向上**和**自顶向下**。我们这里将分别讨论。

1. 自底向上

考虑将一棵可重集为 $S_1$、最大深度为 $d_1$ 的子树放到一棵可重集为 $S_2$、最大深度为 $d_2$ 的子树上面，则我们可以得到一棵这样的子树：

- 可重集为 $(\cup_{i \in S_1} (i + 1)) \cup S_2$。
- 最大深度为 $\max(d_1, d_2) + 1$。

而此时产生的新贡献 $(2^{d_1} - 1) + (2^{d_2} - 1)$ 只与 $d_1, d_2$ 有关、最终计算答案时的贡献只与最终的可重集 $S$ 有关，考虑把这两个东西压进状态 dp。

设 $f_{S, d}$ 表示一棵可重集为 $S$、最大深度为 $d$ 的子树的最小磨损值，则转移模拟上述结果即可。

但是直接做的状态数是不可接受的。注意到当 $S_1$ 排序后逐项不大于 $S_2$，$S_2$ 可以直接舍去，于是我们每次转移完后如此剪枝即可。

$n = 50$ 时没被偏序的 $S$ 只有 $245$ 项，但因为转移的时间复杂度过高，如果不进一步剪枝就止步于 $n \leq 50$ 了。

2. 自顶向下

在上面一种思路中，我们每次合并两棵子树并计算贡献。那要是我们每次对叶子进行分裂呢？

还是设当前的可重集为 $S$，现在我们希望通过分裂一些叶子产生 $d_u = i$ 的点，其中 $i$ 表示上一次分裂后根的最大深度。

贪心地，我们一定会选择 $S$ 中前若干小的元素进行分裂，每分裂一个 $x$ 会得到一个 $x$ 和 $x + 1$。设分裂完后的可重集为 $T$。

那么每次分裂后新产生的磨损值如何计算呢？直观感觉是很麻烦的，因为我们不知道哪些 $u$ 的 $d_u$ 会改变。

不妨考虑把重构树删空的过程：

- 考虑任意一棵最终得到的重构树。
- 我们从 $d_{ls_u} = d_{rs_u} = 0$ 的点开始将它们删除，这些 $u$ 就是最后一次被分裂的点。
- 重复以上操作直到树被删得只剩根。

考虑把这个过程逆向进行，即钦定当前这次分裂后：

- 每个上次被分裂出来的一对叶子至少有一个在这次也被分裂掉。
- 允许在上次之前分裂出的叶子中任选一些来分裂。

这样就保证了所有非根且非叶子的点的 $d_u$ 都会改变。

注意到此时我们相当于有 $|T| - 2$ 个（即所有非根且非叶子的点的数量）个项从 $2^d - 1$ 变成 $2^{d + 1} - 1$。设原来的磨损值之和为 $x$，则新产生的磨损值为 $x + (|T| - 2)$，于是总磨损值为 $2x + (|T| - 2)$。

类似于第一种思路，考虑设 $f_S$ 表示当前可重集为 $S$ 的方案数，每次枚举选哪些元素分裂即可。

把值过大而不可能成为答案的项扔掉后，$n = 70$ 的状态就已经有 $6878$ 个了，考虑进行剪枝。

注意到我们前面的钦定实际上还保证了每次分裂的叶子数量单调不降，考虑一个直观的想法：在 $f$ 中加一维 $i$ 表示上一次分裂了 $i$ 个叶子。

但加一维带来的时间复杂度增加显然是不可接受的。考虑直接在状态中记录在达到此状态的前提下、最后一次分裂的**最小**叶子数量，转移时据此设定分裂叶子数量的下限。

事实证明这个剪枝相当强，$n = 100$ 的状态只有 $1777$ 个，因而可以通过。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <map>
#include <vector>

using namespace std;

typedef long long ll;

const int N = 100;
const ll M = 169073741990ll;
int w[N + 7];
map<vector<int>, pair<ll, int> > mp[N + 7];

int main(){
	int t;
	cin >> t;
	mp[1][vector<int>(1)] = make_pair(0, 1);
	for (register int i = 1; i < N; i++){
		for (register map<vector<int>, pair<ll, int> >::iterator j = mp[i].begin(); j != mp[i].end(); j++){
			vector<int> v1 = j->first, v2 = v1;
			for (register int k = 1; k <= i; k++){
				int size = i + k;
				if (size > N) break;
				int val = v1[k - 1] + 1;
				v2.insert(lower_bound(v2.begin(), v2.end(), val), val);
				if (k >= j->second.second){
					pair<ll, int> pr1(j->second.first * 2 + (size - 2), k);
					if (pr1.first > M) break;
					if (!mp[size].count(v2)){
						mp[size][v2] = pr1;
					} else {
						pair<ll, int> &pr2 = mp[size][v2];
						pr2.first = min(pr2.first, pr1.first);
						pr2.second = min(pr2.second, pr1.second);
					}
				}
			}
		}
	}
	for (register int i = 1; i <= t; i++){
		int n;
		ll ans = 0x7fffffffffffffffll;
		cin >> n;
		for (register int j = 1; j <= n; j++){
			cin >> w[j];
		}
		sort(w + 1, w + n + 1);
		for (register map<vector<int>, pair<ll, int> >::iterator j = mp[n].begin(); j != mp[n].end(); j++){
			ll cur_ans = j->second.first;
			vector<int> v = j->first;
			for (register int k = 1; k <= n; k++){
				cur_ans += (ll)w[k] * v[n - k];
			}
			if (ans > cur_ans) ans = cur_ans;
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：bunH2O (赞：8)

博主写了不知道什么玩意，结果一交发现跑的飞快，于是决定写篇题解记录一下这个做法。[提交记录](https://www.luogu.com.cn/record/213857528)（截止至博客发出时仍是洛谷上的最优解）。

**由于博主才疏学浅，本篇题解中诸多结论均没有给出证明，请谨慎甄别。**

---

为了方便，我们不妨假设 $w_1\leq w_2\leq\cdots\leq w_n$。在下文中，我们记第 $i$ 堆书的磨损值为 $d_i$。

考虑刻画合并过程，当我们将第 $i$ 摞书放到第 $j$ 摞书上时，记作这里存在一条从 $i$ 到 $j$ 的有向边。不难发现所有边构成一棵内向树。

进一步发掘内向树的性质。经过一定的观察，我们**猜测**总存在一种合并方案，满足树的根为 $n$，且对于 $1\leq i<n$，有 $fa_i>i$。进一步地，我们**猜测** $\forall i\in [0,n]$，深度 $\leq i$ 的节点总可以呈一个后缀。

进行更深刻的观察。我们继续**猜测**，当 $i$ 合并到 $fa_i$ 时（注意并非最终时刻），总可以有 $d_i\leq d_{fa_i}$。换而言之，存在一种方案，使得当第 $i$ 堆书进行第 $j$ 次合并时，其磨损值总为 $j-1$。据此我们修改磨损度 $d$ 的定义，当 $i$ 合并到 $j$ 后，我们令 $d_i$ 和 $d_j$ 均 $+1$。易证在该猜想基础上、在此定义下体力耗费值不变。不难发现此时 $d_i$ 与 $\deg_i$（$i$ 的邻居数量）定义相同，此后我们将同时使用 $\deg_i$ 与 $d_i$ 。

综合以上猜想，我们得到了对一棵内向树计算贡献的贡献式：

$$f(T)=\sum\limits_{i=1}^n (\text{dep}_i\times w_i+\sum\limits_{j=0}^{\deg_i-1}(2^j-1))$$

其中 $\text{dep}_i$ 表示 $i$ 的深度。 

记 $S(i)$ 表示 $\sum\limits_{j=0}^{i-1}(2^j-1)$，则上式可改写为：

$$f(T)=\sum\limits_{i=1}^n \text{dep}_i\times w_i+S(\deg_i)$$

我们考虑从顶向下逐层确定整棵树的形态。由于合并过程中要保证 $d_i\leq d_{fa_i}$，因此第 $i$ 个节点的第 $j$ 个儿子的磨损值需要 $<j$。也即每个上一层的点对该层点的限制均呈如下形式：该点至多有 $\text{son}_i$ 个点可以记他为父亲，且第 $i$ 个儿子的度数应 $<i$。我们将一层的所有限制的总和记为该层的状态。

逐层转移时暴力枚举上层所有合法状态和本层点数。考虑如何转移，我们**猜测**下述方案在题设下一定不劣：先给每个点挂第一个儿子，再给每个点挂第二个儿子，以此类推……不难发现转移是唯一的。

由上，我们解决了本题（？）。正确性不会证，时间复杂度不会算，实测最慢的点转移数在 $40000$ 左右。

---

## 作者：璀璨星空1 (赞：8)

> 将世界终结前最后的空白　深深刻印进死水般的心海  
> 即使到了要说再见的日子　回想这一切仍是如此悲哀

------

考虑对合并过程建一棵树 $T$：

- 有 $n$ 个叶子表示初始的书。
- 有 $n-1$ 个非叶子 $u$ 表示把 $\text{lch}(u)$ 堆到 $\text{rch}(u)$ 上。

记 $w(u)$ 表示 $u$ 的重量，$h(u)$ 表示 $u$ 子树的高度。那么把 $l$ 堆到 $r$ 上的代价 $=w(l)+2^{h(l)}+2^{h(r)}-2$。

称 $w(l)$ 的和为第一部分贡献，$2^{h(l)}+2^{h(r)}-2$ 的和为第二部分贡献。总代价等于两部分贡献相加。

固定树的结构，则第二部分贡献恒定。考虑最小化第一部分贡献。设 $a_i$ 表示叶子 $i$ 到根的路径上作为左儿子的次数，则 $w(l)$ 的和 $=\displaystyle\sum\limits_{i=1}^na_iw_i$。我们要把 $w_i$ 匹配到 $a_i$ 上。不妨设 $a_1\leq a_2\leq\dots\leq a_n$，则根据排序不等式，当 $w_1\geq w_2\geq\dots\geq w_n$ 时 $\displaystyle\sum\limits_{i=1}^na_iw_i$ 取到最小值。

------

接下来考虑 $T$ 应满足哪些性质：

性质 $1$. 对于所有非叶子 $u$，都有 $h\big(\text{lch}(u)\big)\leq h\big(\text{rch}(u)\big)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/23z7uu9n.png)

反证法。找到最深的 $u$ 使得 $h\big(\text{lch}(u)\big)>h\big(\text{rch}(u)\big)$。那么 $h_2\geq h_1,h_3$。我们考虑右旋：

- 左图的代价 $=2w_1+w_2+2^{h_1}+2^{h_2}+2^{h_3}+2^{h_2+1}-4$。
- 右图的代价 $=w_1+w_2+2^{h_1}+2^{h_2}+2^{h_3}+2^{h_2+1}-4$。

右图省掉了一个 $w_1$。并且 $h_u$ 仍 $=h_2+2$，不会影响 $u$ 的祖先，调整是严格优的。综上，任何一个最优的 $T$ 都满足性质 $1$。

------

>那样的虚度或这样的盲目　如何才不会忘却梦的温度  
>所有人都在渐渐变得麻木　愤怒唾弃着本就从不存在的祝福

我们自顶向下建出 $T$。所谓自顶向下，就是从只有根结点开始，记录所有叶子的状态，每步分裂一个叶子得到两个新的叶子。

用一个叶子的左深度表示一个叶子。那么一个 $a$ 可以分裂成一个 $a+1$ 和一个 $a$。考虑一个序列 $L=[0]$，每步从 $L$ 中拿出一个数分裂成两个。如果拿出的是 $a$，那么会多出一个 $a+1$。从 $|L|=1$ 到 $|L|=n$ 一共要分裂 $n-1$ 步。最终的 $L$ 就是 $n$ 个叶子的贡献系数。

考虑分层分裂。第 $a$ 层分裂所有左深度 $=a$ 的叶子。这样一来，我们考虑的 $a_i$ 是升序的，因此安排给它们的 $w_i$ 一定是降序的。这允许我们边分裂边计算第一部分贡献。

为了计算第二部分贡献，除了记录所有叶子的左深度 $a$ 以外，还需要记录它们的子树高度 $x$。用 $(a,x)$ 来表示一个叶子。

回想性质 $1$。当一个 $(a,x)$ 分裂时，你需要在 $[0,x)$ 中选择一个 $y$，将 $(a,x)$ 分裂成一个 $(a+1,y)$ 和一个 $(a,x-1)$，并付出 $2^y+2^{x-1}-2$ 的分裂代价。称你选择的 $y$ 为 $x$ 的衰变产物 $\text{decay}(x)$。

只要 $x\geq1$，$(a,x)$ 就必须分裂。每步分裂你都必须指定 $\text{decay}(x)$。在最开始，你还需要指定根结点的高度 $(0,x)$。在整个分裂过程中你所做的决策只包括上面两部分。

放大到第 $a$ 层的视角。在第 $a$ 层分裂产生第 $a+1$ 层的时候，一个 $(a,x)$ 将经过 $x$ 步分裂变成 $(a,0)$，并产生 $x$ 个叶子。这 $x$ 个叶子 $y$ 的上界分别是 $x-1,x-2,\cdots,1,0$。

综上所述，我们得到了一个初步的动态规划做法。设当前在第 $a$ 层，我们记录所有左深度 $=a$ 的叶子的子树高度 $x$ 组成的可重集 $A$。再记录 $L$ 中 $\leq a$ 的数的个数 $k$。那么 $(k,A)$ 就是一个状态。

考虑转移。以 $A=\{6,4,2,2,1\}$ 为例，我们要选择 $15$ 个自然数，它们的上界分别是 $5,4,3,3,2,2,1,1,1,1,0,0,0,0,0$。设这 $15$ 个自然数组成的可重集是 $B$，我们从 $(k,A)$ 转移到 $(k+15,B)$。

注意我们的状态是不包含 $a$ 的。通过分层，可以差分计算第一部分贡献。我们知道 $L$ 中 $\leq a$ 的数共有 $k$ 个，说明第 $a$ 层有 $k$ 个叶子已经停止分裂，那么会产生 $S_{n-k}$ 的贡献，其中 $S_k$ 表示最小的 $k$ 个 $w_i$ 之和。于是第一部分贡献就 $=\displaystyle\sum\limits_{i=0}S_{n-k_i}$。

------

现在的问题是：对于一个 $A$，可能的 $B$ 太多了。假设 $|B|=15$，$B$ 中的 $15$ 个元素 $x_1,x_2,\cdots,x_{15}$ 的上界分别是 $y_1,y_2,\cdots,y_{15}$，其中 $y_1\geq y_2\geq\dots\geq y_{15}$。我们进一步分析性质：

性质 $2$. 若 $x_i-x_{i+1}=2$，则一定有 $x_{i+1}=y_{i+1}$。

以 $(x_i,x_{i+1})=(5,3)$ 为例，我们要说明：一定可以将 $(5,3)$ 调整成 $(4,4)$ 或 $(5,4)$ 之一。

- 若 $\text{decay}(5)\leq3$，则一个 $5$ 和一个 $3$ 分裂出的 $8$ 个东西，两个 $4$ 同样可以做到。同时 $2^4+2^4<2^5+2^3$ 严格优。
- 若 $\text{decay}(5)=4$，则只好调整成 $(5,4)$。设原来的 $\text{decay}(3)=z$，则令现在的 $\text{decay}(4)$ 也 $=z$。这样的话，分裂代价的总和不会变化，但是原来的一个叶子 $(a,z)$ 现在变成了 $(a-1,z)$。因此总代价也会严格变小。

于是性质 $2$ 成立。同理对于任意 $i<j$ 满足 $x_i-x_j=2$ 也可以调整。

性质 $2$ 显著减小了可能的 $B$ 的数量。考虑实际 $x_i$ 的最大值 $x$，根据性质 $2$，对于 $y_i<x$ 都有 $x_i=y_i$，对于 $y_i\geq x$ 则有 $x_i\in\{x-1,x\}$。每次取出状态 $(k,A)$，先枚举 $x_i$ 的最大值 $x$，再枚举 $x-1$ 和 $x$ 的个数各是多少即可。

实现的时候，一开始所有 $x_i=0$，维护当前最大值 $x$，每次将一个 $x-1$ 替换成 $x$ 并更新代价，直到 $x-1$ 的个数等于上界为 $x-1$ 的数的个数为止。然后开始枚举 $x+1$。

一些优化：

- $x=0$ 的叶子不能分裂，因此我们并不需要记录 $(a,0)$ 的个数，可以直接认为 $A$ 中不包含 $0$。
- 只需要保留那些 $u$ 加上 $A$ 中所有元素的和不超过 $n$ 的状态 $(k,A)$。

------

代码实现：[https://loj.ac/s/1866129](https://loj.ac/s/1866129)。实践表明，这个做法是非常优秀的。

---

## 作者：Lynkcat (赞：7)

该做法来自 @zhoukangyang

建出操作树，按照子树重量和进行链剖分，观察到重量大的一定深度也大，否则可以调整使得答案不劣。接着我们发现可以将链缩成点，因为记录链上合并子树的顺序是不必要的。

接下来新树能对应一棵原树的条件是一个 $deg$ 为 $i$ 的点的儿子中，必须满足对于所有 $j\leq i-1$ 都有 $\sum_u [\deg_u\leq j]\geq j$

考虑从上往下一层层做，我们显然只关心每层的 deg 集合。感受一下，先钦定一下每儿子度数都取到上界，然后我们每次选度数最大的点将其度数减 $1$，最优秀的方法一定在进行若干次之后取到。

然后直接搜就行了。

```c++
// Problem: P9483 [NOI2023] 合并书本
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P9483
// Memory Limit: 512 MB
// Time Limit: 1500 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define poly vector<int>
#define IOS ios::sync_with_stdio(false)
#define ll long long
#define mp make_pair
#define mt make_tuple
#define pa pair < int,int >
#define fi first
#define se second
#define inf 1e18
#define mod 998244353
#define sz(x) (int)((x).size())
#define int ll
#define N 105
using namespace std;
int cnt[N],val[N],a[N];
int n,ans;
void dfs(vector<poly>g,int siz)
{
	int l=0;
	for (auto u:g.back())
		l+=u-1;
	if (l+siz>n) return;
	if (siz==n)
	{
		int res=0,pos=1,tt=0;
		for (int i=0;i<g.size();i++)
		{
			for (auto u:g[i])
			{
				tt++;
				cnt[i]++;
				res+=val[u];
				if (i!=0) res+=val[u+1]-val[u];
			}
		}
		for (int i=0;i<=n;i++)
		{
			for (int j=1;j<=cnt[i];j++)
			{
				res+=a[pos]*(i);
				pos++;
			}
			cnt[i]=0;
		}
		ans=min(ans,res);
		return;
	}
	poly nxt;
	for (auto u:g.back())
		for (int j=1;j<u;j++) nxt.push_back(j);
	sort(nxt.begin(),nxt.end());
	g.push_back(nxt);
	if (nxt.empty()) return;
	while (1)
	{
		dfs(g,siz+nxt.size());
		if (g.back().back()==1) break;
		for (int i=(int)g.back().size()-1;i>=0;i--)
		{
			if (g.back()[i]!=g.back().back())
			{
				g.back()[i+1]--;
				break;
			}
		}
	}
}		
void BellaKira()
{
	cin>>n;
	for (int i=1;i<=n;i++)
		cin>>a[i];
	val[1]=0;
	val[2]=0;
	for (int i=3;i<=50;i++)
	{
		int now=val[i-1]-val[i-2];
		val[i]=val[i-1]+(now*2+1);
	}
	sort(a+1,a+n+1,greater<int>());
	ans=inf;
	for (int i=1;i<=50;i++)
	{
		dfs(vector<poly>(1,poly(1,i)),1);
	}
	cout<<ans<<'\n';
}
signed main()
{
	IOS;
	cin.tie(0);
	int T=1;
	cin>>T;
	while (T--)
	{
		BellaKira();
	}
}
```

---

## 作者：strcmp (赞：5)

> 消愁罢了

------------

**题目大意：** 给定长度为 $n$ 的正整数序列 $a$，以及一个初始全部元素为 $0$ 的序列 $b$。每次操作可以将 $a$ 中选取两数 $a_i,\,a_j$，将 $a_i$ 合并到 $a_j$ 上，代价为 $a_i + b_i + b_j$，并使 $b_j \leftarrow 2\max(b_i, b_j) + 1$。求将所有数合并为一个数的最小代价。

------------

表示看不懂大佬的题解，于是回寝推了一个晚上。

很人类智慧的一道题。

考虑根据合并关系建树，显然建出来的树满足子结点数为 $2$ 或 $0$。

我们设结点 $u$ 的左儿子为 $l_u$，右儿子为 $r_u$，我们钦定对每个结点 $u$，将 $l_u$ 放到 $r_u$ 上，由对称性不影响答案。

> 结论 $1$：设 $u$ 子树中与 $u$ 有最长距离的结点与 $u$ 的距离为 $\operatorname{f}(u)$。则**非根结点** $u$ 的磨损值为 $2^{\operatorname{d}(u)} - 1$。

我们可以以 $u$ 为根的这个子树从树拔出来，从最深结点一直走到 $u$，贡献为 $\sum^{\operatorname{d}(u) - 1}_{i=0}2^i = 2^{\operatorname{d}(u)} - 1$。

我们递归定义函数 $s(u)$，若 $u$ 是叶子，则 $s(u) = a_u$，否则 $s(u) = s(l_u) + s(r_u)$。则重量对答案的贡献为 $\sum_u s(l_u)$。

这时候，我们将所有贡献拆为了两个。

- $\sum_u s(l_u)$，其中 $u$ 是**非叶子结点**。

- $\sum_u 2^{\operatorname{d}(u)} - 1$，其中 $u$ 是**非根结点**。

设 $w(u)$ 为**叶子结点** $u$ 到根节点这条路径中经过了多少条左儿子边。

则 $\sum_u s(l_u) = \sum_u w(u)a_u$。

根据**排序不等式**，要使得该值最小，则降序排序 $a$ 后要使得 $w$ 为升序。

注意到，这样的 $w$ 是好构造的，我们根据大小将 $a_i$ 分别分配到对应的 $w$ 上即可。

于是我们只用考虑 $w(u)$ 这个可重集。

接下来我们有两种模拟方式，其一是从叶子结点开始合并到根节点，其二是从根结点开始分裂到叶子结点。

------------

如果从叶子合并到根结点，我们需要记录合并的两个子树的 $\operatorname{d}(u)$、$\operatorname{D}(u) = \sum 2^{\operatorname{d}(u)} - 1$ 和 $w$。也就是磨损度之和与 $w$ 的可重集。

显然：

$\operatorname{d}(u) \leftarrow \max(\operatorname{d}(l_u),\,\operatorname{d}(r_u)) + 1$。

$\operatorname{D}(u) \leftarrow \operatorname{D}(l_u) + \operatorname{D}(r_u) + 2^{\operatorname{d}(u)} - 1$。

对于 $w$，我们需要钦定一个子树为左子树，使得这棵子树的 $w$ 全部加一，跟右子树取并，这一步是我们的决策之一。

于是固定 $f_{s,\,i}$ **表示可重集 $w$ 为 $s$，且 $\operatorname{d}(u) = i$ 的最小磨损值**。注意到我们将 $w$ 纳入状态之后只用考虑磨损值的大小。注意，这里我们采用**最小表示法**，将可重集看作单调不减的序列。

枚举状态转移即可，可惜的是状态数实在太大，考虑剪枝。

注意到，两个状态 $f_{s,\,i},\,f_{s',\,i'}$ 若满足：

- $\forall i, |s| = |s'|,\,s_i \le s'_i \wedge i < i' \wedge f_{s,\,i} < f
_{s',\,i'}$。

则从 $f_{s',\,i'}$ 转移出来的状态永远不可能成为最优状态。

于是我们枚举层数，暴力做个偏序即可。

这样跑个暴搜之后可以看到 $s$ 的状态数并不多，但转移复杂度太高，且维护 $\operatorname{d}(i)$ 的这一层也大大增加了我们的总状态数。

------------

想办法去掉 $\operatorname{d}(i)$。

注意到，自底向上的方法很难去掉 $\operatorname{d}(i)$，因为我们并不知道当前结点最终的最深深度，也就不能知道当前结点的磨损值贡献。

只能考虑自顶向下，将叶子分裂着处理了。

> 结论 $2$，我们总是取 $w$ 的前若干小值进行分裂，这是最优的。

显然，将 $x \in w$ 分裂出去，会生成 $x$ 和 $x + 1$，我们选取 $x$ 最小，总是不劣的。

考虑我们每次分裂出的点的性质，将时间倒序，加点变为删点，则每次删的点 $l_u$ 和 $r_u$ 必然是 $\operatorname{d}(l_u) = 0$ **且** $ \operatorname{d}(r_u) = 0$ 的，也就是必然是将一个三个结点的满二叉树删成一个根结点的形式，这正是我们加点时所分裂出来的点的性质。

这告诉我们，**每次分裂出的一对叶子 $(l_u,\,r_u)$，在下一步分裂时，这一对中的至少一个叶子必然还要分裂出新的一个叶子。** 否则，如果这一步不分裂，则我们可以延后这对叶子的分裂时间，直到这里需要分裂。（注意，这不是一个没有条件的性质，这是在我们钦定下成立的性质）

![](https://cdn.luogu.com.cn/upload/image_hosting/99r30v68.png)

可以看到，在上图，两种转移方式都得到了同一个结果。（我们钦定转移是下面的方式）

这样有什么好处？**我们可以证明，每次分裂之后，分裂前原树的所有非根非叶结点的磨损值都会改变，且都从 $2^{\operatorname{d}(u)} - 1$ 变为 $2^{\operatorname{d}(u) + 1} - 1$。**

，设分裂前整棵树的磨损值为 $v$，分裂后树的大小为 $|\text{T}|$，则分裂后树的磨损值为 $2v + |\text{T}| - 2$。

这可太好维护了，设 $f_s$ 为当可重集 $w$ 为 $s$ 时最小的磨损值，直接转移即可。

但是，我们兴冲冲地写了一个暴搜出来，发现当 $n = 70$ 时状态数就已经到达了骇人的 $6969$ 个，状态数平方再乘一个 $n$ 的复杂度显然难以承受。

这时候，就体现出我们转移方式的优越性了。我们发现，因为每分裂出一对叶子，这对叶子就必然至少有一个下一次也要分裂，所以**每次分裂出的叶子数是单调不减的**。

于是我们可以在状态中再维护一个分裂出的叶子数，在每次分裂出的叶子大于上一次时再转移，这个剪枝看起来没什么用，但是实际效果非常吓人，在 $n = 100$ 时状态数只有 $1790$ 个，可以直接通过本题。

参考代码：

```cpp
#ifndef ONLINE_JUDGE
#pragma warning(disable:4996)
#include <iostream>
#include <algorithm>
#include <queue>
#include <map>
#else
#include <bits/stdc++.h>
#endif
using namespace std;
typedef long long int ll;
const ll inf = 500000000000;
using pll = pair<ll, ll>;
const int maxn = 1e4 + 10;
map<vector<int>, pll>s[201];
//s[n][v] 的含义是需要分裂出 n 个结点，w 的可重集集合为 v 的情况下，s[n][v].first 为最小磨损值，s[n][v].second 为每次分裂的叶子结点的下限
int t, n; ll a[maxn];
const int N = 100;
void solve() {
    s[1][{0}] = { 0, 1 };
    for (int i = 1; i <= N; i++) {
        for (auto& x : s[i]) {
            vector<int> v1 = x.first, v2 = v1;
            ll ms = x.second.first;
            ll low = x.second.second;
            size_t siz = v1.size();
            for (int j = 0; j < i; j++) {
                int wz = i + j + 1;
                if (wz > N) break;
                v2.insert(lower_bound(v2.begin(), v2.end(), v1[j] + 1), v1[j] + 1);
                //维护 v2 的单调性，我们以最小表示法表示状态
                size_t new_sz = v2.size();
                if (j + 1 >= low) {
                    pll p = { 2 * ms + new_sz - 2, j + 1};
                    if (p.first > inf) break;
                    else if (!s[wz].count(v2)) s[wz][v2] = p;
                    else {
                        pll& w = s[wz][v2];
                        w.first = min(w.first, p.first);
                        w.second = min(w.second, p.second);
                    }
                }
            }
        }
    }
}
//#define DEBUG
int main() {
    scanf("%d", &t); solve();
    while (t--) {
        scanf("%d", &n); ll ans = inf << 5;
        for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
        sort(a + 1, a + n + 1, greater<ll>()); 
        for (auto& x : s[n]) {
            ll sum = 0;
            for (int i = 0; i < x.first.size(); i++) {
                sum += a[i + 1] * x.first[i];
            }
            sum += x.second.first;
            ans = min(ans, sum);
        }
        printf("%lld\n", ans);
    }
    return 0;
}

```

---

## 作者：ducati (赞：3)

## Description

[传送门](https://www.luogu.com.cn/problem/P9483)

## Solution

### Part 1

考虑一棵合并树，令 $ls_u,rs_u$ 表示 $u$ 的左右儿子，$d_u$ 表示 $u$ 子树的最大深度，$c_u$ 表示 $u$ 被合并的次数，令所有非叶非根节点对应 $2^d - 1$ 的和为 $S$，则答案为 $\sum_{i=1}^n c_iw_i + S$。 

可以发现，我们只关心 $c$ 的**可重集**及其对应的 $\min\{S\}$。当确定 $c$ 的可重集后，为最小化 $\sum_{i=1}^n c_iw_i$，我们将 $c$ 从小到大排序，$w$ 从大到小排序，再一一对应即可。

下面，我们的目标是：求出**所有可能作为最优解**的可重集 $c$ 及其对应的 $\min\{S\}$。

### Part 2

先考虑怎么暴力求出**所有**的可重集 $c$ 及其对应的 $\min\{S\}$。

考虑使用**分裂叶子**的方法。具体来说，刚开始树上只含一个点，即根，其 $c = 0$。每次，我们找到树上的某个叶子 $u$，建出 $ls_u,rs_u$，$u$ 不再是叶子的同时得到两个新的叶子。

但是，每当分裂一个叶子后，新的 $\min\{S\}$ 与树形态有关，难以进一步优化。

考虑一种特殊的分裂顺序，倒序枚举 $d_0 = n, n - 1, \cdots, 0$，每次将树上所有 $d = d_0$ 的点分裂。这样的好处在于，分裂前所有非叶节点、被分裂的叶子的 $d$ 在分裂后均恰好增加 $1$，即 $\min'\{S\} = 2\min\{S\} \ +$ 分裂前树上非叶点数 $+$ 分裂叶子数，该值与树形态无关。

设计 $dp_{c}$ 表示，目前分裂得到的可重集为 $\{c\}$，此时 $\min\{S\}$ 的值。转移时，分裂任何叶子都是可行的，可以忽略 $d = d_0$ 的限制；这是因为，不满足限制只会将答案算大，而存在最优解因满足限制而被计入。

显然，我们不需枚举所有叶子的集合，只需枚举 $c$ 的**所有前缀**，将其分裂并转移。注意，分裂 $x$ 会得到 $x, x + 1$。

期望得分 $75$ 分。

### Part 3

考虑减枝。对于每个 $\{c\}$，我们额外记录 $lim_c$，表示所有转移到 $c$ 的最优状态里，至少分裂了多少叶子。那么，此时分裂的叶子数 $\ge lim_{c}$。

这样一来，分裂叶子数的可能情况大幅减少，转移复杂度大幅降低，可以通过本题。

## Code

参考了 Alex_Wei 的实现。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=105,inf=1e18,max_ans=169073741990;

namespace IO{
	inline char nc(){
		static char buf[500001],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,500000,stdin),p1==p2)?EOF:*p1++;
	}
	char out[500001],*pout=out,*eout=out+500000;
	template<typename T> inline T read(){
		char ch=nc(); T sum=0; bool f=false;
		for(;ch<'0'||ch>'9';ch=nc()) if(ch=='-') f=1;
		while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();
		return f?-sum:sum;
	}
}
#define read IO::read<int>

int n,w[N]; map<vector<int>,pair<int,int>> states[N];
void init(int maxsz){
	states[1][{0}]=make_pair(0,1);
	for (int n=1;n<=maxsz;n++){
		for (auto &cur:states[n]){
			int cur_cost=cur.second.first;
			for (int cnt=cur.second.second;cnt<=n&&n+cnt<=maxsz;cnt++){
				int new_n=n+cnt,new_cost=(cur_cost<<1)+cnt+(n-2);
				if (new_cost>max_ans)  break;

				vector<int> new_arr=cur.first;
				for (int i=0;i<cnt;i++)  new_arr.emplace_back(cur.first[i]+1);
				sort(new_arr.begin(),new_arr.end());

				auto it=states[new_n].find(new_arr);
				if (it!=states[new_n].end()){
					auto &info=it->second;
					if (new_cost<info.first)  info=make_pair(new_cost,cnt);
					else if (new_cost==info.first)  info.second=min(info.second,cnt);
				}
				else states[new_n][new_arr]=make_pair(new_cost,cnt);
			}
		}
	}
}
signed main(){
	int T=read(); init(N-5);
	while (T--){
		n=read();
		for (int i=0;i<n;i++)  w[i]=read();
		sort(w,w+n,greater<int>());

		int ans=inf;
		for (auto &state:states[n]){
			int sum=state.second.first;
			for (int i=0;i<n&&sum<ans;i++)  sum+=w[i]*state.first[i];
			ans=min(ans,sum);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```



---

## 作者：DaiRuiChen007 (赞：1)

[iProblem Link](https://www.luogu.com.cn/problem/P9483)

**题目大意**

> 给定 $n$ 个元素，每个元素有 $w,d$ 两个属性，初始第 $i$ 个元素为 $(w_i,0)$，合并元素 $i\to j$ 的代价为 $w_i+d_i+d_j$，合并后形成新元素 $(w_i+w_j,2\max(d_i,d_j)+1)$，求把所有元素合并成一个的最小代价。
>
> 数据范围：$n\le 100$。

**思路分析**

考虑把元素的合并看成一棵二叉树，记每个点 $u$ 子树的最大深度为 $d(u)$，那么所有 $d$ 的贡献就是所有非根节点的 $\sum 2^{d(u)}-1$。

而 $w$ 的贡献可以看成二叉树上每个点选一个子树系数 $+1$，每个叶子的系数就表示该叶子对应 $w_i$ 对答案的贡献系数。

容易发现每个叶子的具体排列不重要，确定二叉树结构后把权值最大的放到系数最小的位置上即可。

因此我们只关心 $n$ 个系数构成的每一种可重集 $C$。

可以暴力 dp，$f_{d,C}$ 表示子树内最大深度为 $d$，构成系数可重集为 $C$ 时，$\sum 2^{d(u)}-1$ 贡献的最小值。

转移时枚举两个状态合并，但这样复杂度太高，无法通过。

我们考虑自上而下地维护这棵二叉树：即从根节点开始，每次把树上的一个叶子分裂出两个儿子节点。

但是每次分裂的时候会影响树上原有节点的 $d(u)$，这就需要记录一些和树形态有关的信息，这是完全不能接受的。

考虑优化，注意到一个子树最大深度为 $d(u)$ 的点，我们可以钦定他在倒数第 $d(u)$ 次操作时才进行第一次分裂，那么此后的每一次分裂他的最大深度都 $+1$，很显然这个过程不改变最优解。

因此存在一种分裂的方式，使得每次分裂后每个非叶节点的最大深度都 $+1$，那么 $\sum 2^{d(u)}$ 就会翻倍，也容易求出分裂后的 $\sum 2^{d(u)}-1$。

但是这么做还不足以通过，首先发现答案不超过 $1.7\times 10^{11}$，可以用来优化 $\sum 2^{d(u)}-1$ 的上界。

其次我们发现按照上述钦定的过程分裂，前一次分裂过的节点的两个儿子中至少有一个这次操作也会分裂，因此每次分裂的节点数单调不降，记录上一次分裂的节点个数即可。

时间复杂度 $\mathcal O(n^2Q_n+nS_n)$，其中 $Q$ 表示叶子数 $1\sim n$ 时的总状态数，$S$ 表示叶子数 $=n$ 时的总状态数，$n=100$ 时 $Q_n=44039,S_n=1745$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll inf=1.7e11;
typedef vector<int> vi;
map <vi,array<ll,2>> f[105];
//[tree size][leaf coef] {min val,low}
ll a[105];
void solve() {
	int n; scanf("%d",&n);
	for(int i=0;i<n;++i) scanf("%lld",&a[i]);
	sort(a,a+n,greater<ll>());
	ll ans=inf;
	for(auto &it:f[n]) {
		const vi&c=it.first;
		ll s=it.second[0];
		for(int i=0;i<n;++i) s+=c[i]*a[i];
		ans=min(ans,s);
	}
	printf("%lld\n",ans);
}
signed main() {
	const int n=100;
	f[1][{0}]={0,1};
	for(int i=1;i<=n;++i) for(auto &it:f[i]) {
		const vi&c=it.first;
		vi d=it.first;
		ll w=it.second[0],lim=it.second[1];
		for(int j=1;j<=i&&i+j<=n;++j) {
			d.insert(upper_bound(d.begin(),d.end(),c[j-1]+1),c[j-1]+1);
			if(j>=lim) {
				ll nw=2*w+(i+j-2);
				if(nw>inf) break;
				if(!f[i+j].count(d)) f[i+j][d]={nw,j};
				else {
					auto &z=f[i+j][d];
					z=min(z,array<ll,2>{nw,j});
				}
			}
		}
	}
	int T; scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---


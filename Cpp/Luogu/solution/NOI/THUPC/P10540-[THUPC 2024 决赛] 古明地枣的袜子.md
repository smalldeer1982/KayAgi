# [THUPC 2024 决赛] 古明地枣的袜子

## 题目描述

你需要维护一个序列 $a_1,\dots,a_n$ 。

给定一个操作序列 $(x_1,y_1),\dots,(x_n,y_n)$ ，操作 $(x,y)$ 表示将 $a_1,\dots,a_x$ 的值加上 $y$ 。

共 $m$ 次查询，每次查询给出 $l,r$ ，问对初始值为 $0$ 的序列 $a$ 依次执行操作 $(x_l,y_l),\dots,(x_r,y_r)$ ，最后 $\max\limits_{i=1}^n a_i$ 的值。

## 说明/提示

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
6 5
6 4
2 6
5 -5
3 6
1 2
3 6
1 6
1 6
2 6
2 6
5 6
```

### 输出

```
19
19
15
15
8
```

# 题解

## 作者：XiaoShanYunPan (赞：4)

# THUPC2024 古明地枣的袜子

~~古明地枣是谁？~~

## 题意

有一个长度为 $n$ 的序列。

给出 $n$ 个操作 $(x_i,y_i)$，每个操作为将 $a_1,a_2,\cdots,a_{x_i}$ 全部加上 $y_i$。

有 $m$ 次相互独立的询问，询问若 $a$ 初始全为 $0$，则做完操作 $(x_l,y_l),(x_{l+1},y_{l+1}),\cdots,(x_r,y_r)$ 后全局最大值为多少。

数据范围：$n,m\le 5\times 10^5$，时限 10s。

## 题解

（下面在计算时间复杂度时认为 $n,m$ 同级。）

zz 神仙讲的，~~虽然我没听~~。

观察数据范围和时限，首先排除单双 $\log$，因为这俩最多 2s。

猜测是个根号算法，那我们需要想办法分块。

下设块长为 $B$。

常见的分块要么对 $a$ 分，要么对操作分。

我们单纯对 $a$ 分会出现一堆操作挤在一个块内的情况，而对操作分块又可能出现块内操作太过分散的问题。

于是人类智慧地，把两者结合到一起，**先将操作按 $x$ 排序后再分块，同时记录操作的时间戳**。

这样子可以规避上面两种可能导致复杂度退化的情况，看上去就要优秀一些。

有了分块，接下来考虑怎么维护。

注意到我们询问是全局的，如果考虑每个块统计，那么想要做到一个根号就必须 $\mathcal{O}(1)$ 处理每个块的询问。

这样我们不得不进行预处理，设预处理出块 $b$ 在询问 $[l,r]$ 时的最大值为 $f_{b,l,r}$。

直接处理会发现我们连数组都存不下，肯定爆炸了。

但是注意到对于某个块内，有大量的询问是本质相同的，实际上一个块内最多只有 $\dfrac{B(B-1)}{2}$ 种本质不同的询问。

这样我们可以把 $l,r$ **离散化为块内对应的操作按照时间戳排序后的排名**，空间复杂度就降下来可以存储了。

不过即使如此，怎么算出 $f$ 也是个关键的问题。

如果你想，你可以暴力套一个 $\log$，用线段树等 DS 简单维护一下，然后把 $B$ 平衡一下取到 $\mathcal{O}(n\sqrt{n\log n})$ 的时间复杂度。

但是，太烂了，我们需要严格根号算法。

注意到我们需要把操作排序之后才能够解决一个块内的答案。

这个时候人类智慧地意识到我们可以使用 **归并排序**。

在归并排序的分治过程中处理答案，看看怎么分治。

对于一个分治区间 $[l,r]$，它表示我们处理按照 $x$ 排序后的操作 $l$ 到 $r$。

此时我们能够得到两个更小区间里的 $f$，此时 $f_{i,j}$ 表示区间内时间戳排名为 $i$ 到 $j$ 操作做完后的最大值。

现在我们枚举 $f_{i,j}$，计算当前这个区间的答案。

分类讨论如何转移：

+ 如果之前的最大值位于右半区间，此时它的所有贡献已经被算完，左边的其它操作无法对其产生贡献，直接令 $f_{i,j}$ 和右半最大值取 $\max$ 即可。
+ 如果之前的最大值位于左半区间，此时右半区间的操作可以对其产生贡献，利用前缀和可以简单计算出贡献，令 $f_{i,j}$ 和加上贡献的左半最大值取 $\max$ 即可。

对于一个 $i,j$，我们意识到其对应的左右区间的情况是不同的。

详细来说，我们可以设在时间戳排名为 $[i,j]$ 的操作中，原本位于左半区间的为左半区间排名为 $[il,jl]$，同理设右半区间为 $[ir,jr]$，这个可以在归并排序时计算。

然后我们就可以利用 $il,jl,ir,jr$ 来转移 $f_{i,j}$ 了。

分析分治的时间复杂度会发现 $T(n)=2T(\dfrac{n}{2})+\mathcal{O}(n^2)=\mathcal{O}(n^2)$，而我们对每个块做此操作，总时间复杂度为 $\mathcal{O}(nB)$。

结合询问的总时间复杂度 $\mathcal{O}(\dfrac{n^2}{B})$，取 $B=\sqrt{n}$ 时最优，为 $\mathcal{O}(n\sqrt{n})$。

然后就是细节了：

+ 注意到对于一个区间 $[l,r]$，如果一整个区间的操作的 $x$ 均相同，那么我们不能够直接用其信息转移更大的区间，因为更大的区间可能包含更多操作。

考虑下面一个例子：

> 在分治时左半区间有操作 $1,2$ 对 $a_1$ 进行修改，而右半区间有操作 $3$ 同样对 $a_1$ 进行修改。
>
> 在合并求解区间 $[1,3]$ 时，不能够取 $[3,3]$ 的最大值来转移，因为此时三个操作都被执行了，需要直接得到 $a_1$ 的最终结果。
>
> 假设操作 $3$ 令 $a_1$ 变得很大，此时我们的 $f$ 可能直接取到仅操作操作 $3$ 后 $a_1$ 的值，导致答案错误。

这个东西实现的时候稍微小心一点即可。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
constexpr int N=500010,B=666,INF=1e9;
struct operation
{
	int x,y,t;
	bool operator < (operation oth) {return x<oth.x;}
}op[N],sorted[N];
ll f[B+10][B+10],tmp[B+10][B+10];/*预处理答案*/
ll s[N];/*操作的y的前缀和，分治时需要动态处理*/
int now;
int pl[N],pr[N];
template<typename Type>inline void chkmax(Type &a,Type b){if(a<b)a=b;return;}
int change[N],cs[N];/*见正文细节部分*/
void solve(int l,int r)
{
	if(l==r)
	{
		f[l-now][l-now]=change[l]?op[l].y:-INF;
		return;
	}
	int mid=(l+r)>>1;
	solve(l,mid),solve(mid+1,r);
	s[mid]=0;
	for(int i=mid+1;i<=r;i++)s[i]=s[i-1]+op[i].y;
	pl[l-1]=l-1,pr[l-1]=mid;
	for(int i=l,j=mid+1,k=l;i<=mid||j<=r;k++)
	{
		if(j>r||(i<=mid&&op[i].t<op[j].t))sorted[k]=op[i],i++;
		else sorted[k]=op[j],j++;
		pl[k]=i-1,pr[k]=j-1;
	}
	for(int i=l;i<=r;i++)op[i]=sorted[i];
	for(int i=l;i<=mid;i++)for(int j=i;j<=mid;j++)tmp[i-now][j-now]=f[i-now][j-now];
	for(int i=mid+1;i<=r;i++)for(int j=i;j<=r;j++)tmp[i-now][j-now]=f[i-now][j-now];
	for(int i=l;i<=r;i++)
	{
		for(int j=i;j<=r;j++)
		{
			/*计算f[i][j]*/
			f[i-now][j-now]=-INF;
			int il=pl[i-1]+1,ir=pr[i-1]+1,jl=pl[j],jr=pr[j];
			if(cs[mid]-cs[l-1])chkmax(f[i-now][j-now],tmp[il-now][jl-now]+s[jr]-s[ir-1]);
			if(cs[r]-cs[mid])chkmax(f[i-now][j-now],tmp[ir-now][jr-now]);
		}
	}
	return;
}
struct question{int l,r;ll ans=-INF;}q[N];
int n,m;
ll suf[N];/*后缀和*/
int rt[N];/*t为i的op的编号*/
int rk[N];/*对应在此块内的排名*/
inline void Calc_Block(int l,int r)
{
	now=l-1;
	for(int i=l;i<=r;i++)for(int j=i;j<=r;j++)f[i-now][j-now]=-INF;
	solve(l,r);
	suf[0]=0;
	for(int i=1;i<=n;i++)suf[i]=suf[i-1]+(rt[i]>r?op[rt[i]].y:0);/*把后面的块的操作预处理*/
	rk[1]=1;
	for(int i=1,j=l;i<=n;i++)
	{
		if(i==op[j].t)j++,rk[i+1]=rk[i]+1;
		else rk[i+1]=rk[i];
	}
	for(int i=1;i<=m;i++)if(cs[r]-cs[l-1])chkmax(q[i].ans,f[rk[q[i].l]][rk[q[i].r+1]-1]+suf[q[i].r]-suf[q[i].l-1]);
	return;
}
template<typename Type>inline void r(Type &x)
{
	x=0;
	char c=getchar();
	bool f=c=='-';
	while(c<'0'||c>'9')c=getchar(),f|=c=='-';
	while(c>='0'&&c<='9')x*=10,x+=c-'0',c=getchar();
	if(f)x=-x;
	return;
}
int main()
{
	r(n),r(m);
	for(int i=1;i<=n;i++)r(op[i].x),r(op[i].y),op[i].t=i;
	for(int i=1;i<=m;i++)r(q[i].l),r(q[i].r);
	sort(op+1,op+n+1);
	n++,op[n]={n,0,n+1};//UKE
	for(int i=1;i<=n;i++)change[i]=op[i-1].x!=op[i].x,cs[i]=cs[i-1]+change[i];
	for(int i=1;i<=n;i++)rt[op[i].t]=i;
	for(int i=1,j=B;i<=n;i+=B,j+=B)Calc_Block(i,min(j,n));
	for(int i=1;i<=m;i++)printf("%lld\n",q[i].ans);
	return 0;
}
```

## 鸣谢

参考文章：https://www.cnblogs.com/peiwenjun/p/18257226 ，膜拜 peiwenjun 佬。

~~代码实现是我自己敲的，但是对着佬的代码看了半天所以敲得都一样了。~~

---

## 作者：zesqwq (赞：3)

把前缀加改成单点加，最大后缀和。

单点加还是好难，干脆变成静态的好了，也就是说，我们要把一个被多个点修改的点分裂。

对于 $x_i$ 相同的操作，我们发现可以把该位置分裂，减的放在后面，加的放在前面，特判第 $n$ 个数（因为没说答案向 $0\ \text{chkmax}$） 变为全局操作，然后问题就变为了有一个长度为 $m$ 的序列，每个位置有一个存活时间，询问为问一个时间区间的最大后缀和。

然后该问题是 $\text{D2T2}$ 严格弱化版，[link](https://www.luogu.com.cn/problem/P5611)。

带 $\log$ 的做法可以在 $\text{QOJ}$ 上通过。

数据很水，好多错解可以过，比如数据没有对一个点大量操作啥的，暴力做法分块就可以直接开 `int` 了。

提供一个从 $\text{D2T2}$ 改过来的代码：

```cpp
const int N = 5e5 + 1080, B = 1080;
struct Node {
    int rv, sum;
};
inline Node operator+(Node a, Node b) {
    return {max(b.rv, b.sum + a.rv), a.sum + b.sum};
}
using table = vector<vector<Node> >;
table ans[1024];
int posra[1024], posrb[1024], c[N];
vector<int> val[1024];
inline void merge(int a, int b, int f) {
    int nr = 0, fsz = 0;
    for (int i = 0; i < val[a].size(); i++) {
        int v = val[a][i];
        while (fsz < val[b].size() && val[b][fsz] <= v)
            val[f][nr] = val[b][fsz++], ++nr;
        val[f][nr] = v;
        ++nr;
    }
    while (fsz < val[b].size()) val[f][nr++] = val[b][fsz++];
    int ra = 0, rb = 0, la = 0, lb = 0;
    for (int r = 0; r < val[f].size(); r++) {
        while (ra < val[a].size() && val[a][ra] <= val[f][r]) ++ra;
        while (rb < val[b].size() && val[b][rb] <= val[f][r]) ++rb;
        posra[r] = ra, posrb[r] = rb;
    }
    for (int l = 0; l < val[f].size(); l++) {
        while (la < val[a].size() && val[a][la] < val[f][l]) ++la;
        while (lb < val[b].size() && val[b][lb] < val[f][l]) ++lb;
        for (int r = l; r < val[f].size(); r++)
            ans[f][l + 1][r + 1] =
                ans[a][la + 1][posra[r]] + ans[b][lb + 1][posrb[r]];
    }
}
void build(int u, int L, int R) {
    int len = R - L + 1;
    ans[u].resize(len + 2);
    for (auto &v : ans[u]) v.resize(len + 2);
    val[u].resize(len);
    if (L == R) return;
    int M = L + R >> 1;
    build(u << 1, L, M), build(u << 1 | 1, M + 1, R);
}
inline Node get(int x) { return {x, x}; }
struct Query {
    int L, R, id;
} q[N];
int id[N], n, m, a[N], nxt[N], pre[N], b[N];
inline void build(int x) {
    for (int i = 0; i < 512; i++)
        val[i + 512][0] = id[x + i], ans[i + 512][1][1] = get(c[x + i]);
    for (int i = 511; i; i--) merge(i << 1, i << 1 | 1, i);
    memset(pre, 0, sizeof(pre));
    vector<int> vec2;
    for (int i = x; i <= x + 511; i++) ++pre[id[i]];
    for (int i = 1; i <= n; i++) pre[i] += pre[i - 1];
}
inline Node query(int L, int R) { return ans[1][pre[L - 1] + 1][pre[R]]; }
int qx[N];
ll cx[N], res[N];
int main() {
    read(n), read(m);
    for (int i = 1; i <= n; i++) {
        read(a[i], b[i]);
        if (a[i] == n)  // 特判 n
            cx[i] += b[i], b[i] = 0;
        id[i] = i;
    }
    for (int i = 1; i <= n; i++) cx[i] += cx[i - 1];
    sort(id + 1, id + n + 1,
         [](int x, int y) { return a[x] == a[y] ? b[x] > b[y] : a[x] < a[y]; });
    for (int i = 1; i <= n; i++) a[id[i]] = i;
    for (int i = 1; i <= n; i++) c[a[i]] = b[i];
    for (int i = 1; i <= m; i++) {
        int L, R;
        read(L), read(R);
        q[i] = {L, R, i};
        qx[i] = cx[R] - cx[L - 1];
    }
    build(1, 1, 512);
    for (int i = 1; i <= (n >> 9) + 1; i++) {
        int l = i - 1 << 9, r = (i << 9) - 1;
        ++l, ++r, build(l);
        for (int j = 1; j <= m; j++) {
            auto c = query(q[j].L, q[j].R);
            res[j] = max(res[j] + c.sum, ll(c.rv));
        }
    }
    for (int i = 1; i <= m; i++) println(max(0ll, res[i]) + qx[i]);
    return 0;
}
```

---


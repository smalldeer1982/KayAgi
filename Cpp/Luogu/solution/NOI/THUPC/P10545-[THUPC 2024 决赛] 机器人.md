# [THUPC 2024 决赛] 机器人

## 题目背景

注意本题的指令含义与初赛的略有不同。


## 题目描述

有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\sim n-1$。

每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。

所有的机器人内部都写有一条「指令」，「指令」有以下这些形式：

### 指令

下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。

- `SLACKOFF`：**「摸鱼」**，即什么也不做。
- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。
- `SWAP`：**「交换」** 双手指向的机器人的「指令」。
- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一；`<COMMAND>` 表示一条完整的非 `TRIGGER` 「指令」。`TRIGGER` 指令本身不会被「执行」，但是，当一个**其他**机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：
  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；
  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是一条 `TRIGGER` 指令被「触发」时，「执行」的 `<COMMAND>` 部分。
- `TOGGLETRIGGERREPLACE h <COMMANDNAME> <NEWCOMMAND>`：如果第 $h$ 只手指向的机器人的「指令」是 `TRIGGER` 指令，则将其 **「切换」** 为该「指令」的 `<COMMAND>` 部分，即删去前面的 `TRIGGER` 及条件部分；如果这条「指令」不是 `TRIGGER` 指令，假设是 `<COMMAND>`，则将其「切换」为 `TRIGGER <COMMANDNAME>: <COMMAND>`。其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一。然后将自己的「指令」（注意这可能不仅仅包含正在「执行」的那部分「指令」）修改为 `<NEWCOMMAND>`。其中，`<NEWCOMMAND>` 是一条完整的「指令」。

机器人「执行」各「指令」时的输出格式如下：

- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。
- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。
- 「交换」时输出 `Robot <id> swaps the commands of Robot <id2> and Robot <id3>.`。其中 `<id2>` 和 `<id3>` 为整数，表示被「交换」「指令」的机器人编号，这两个数可以按任意顺序输出。
- 「切换」时输出 `Robot <id> toggles the trigger property of the command of Robot <id2>`。
- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。

你按照一定顺序选择了一些机器人（可能重复选择）并「执行」了对应机器人的「指令」，得到了「执行」的**完整**输出，也就是说，在「执行」完输出中最后一条「指令」之后，没有其他「指令」被「触发」。但是，你忘记了你选择机器人的顺序，也忘了每个机器人开始时有什么「指令」。你只记得机器人的总数以及开始时每个机器人的手指向什么位置。

你想通过已知的所有信息还原出最初所有机器人的「指令」都是什么。

## 说明/提示

**样例解释 1**

选择机器人的顺序为 $1,1,0,1,3$，其中第二、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。

注意 `TRIGGER` 指令「触发」的时机是在「执行」上一条「指令」之后，所以第一次「交换」之后由于 $1$ 号机器人的「右手」指向了写有 `TRIGGER SWAP: SWAP` 的 $0$ 号机器人，所以这条 `TRIGGER` 指令能被「触发」。

**样例解释 2**

选择机器人的顺序为 $0,3,0,1,3$，其中第五、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。

第一次「执行」会使 $1$ 号机器人的「指令」变为 `SWAP`，$0$ 号机器人的「指令」变为 `MOVE 1 1`。

第五次「执行」会使 $2$ 号机器人的「指令」由 `SLACKOFF` 变为 
```
TRIGGER TOGGLETRIGGERREPLACE: SLACKOFF
```
，$3$ 号机器人的「指令」由
```
TRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF
```
会变为 `SLACKOFF` 而不是 `TRIGGER SWAP: SLACKOFF`。

**样例解释 3**

选择机器人的顺序为 $0$，其中第二、三、四条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。

注意 $3$ 号机器人「执行」完「指令」后不会接着「触发」自己的 `TRIGGER` 「指令」，即使它的「右手」指向了自己。

另外，选择一个写有 `TRIGGER` 指令的机器人不会产生任何输出，所以这么做没有意义。

**样例解释 4**

见题目目录下的 *4.in*。该样例不提供样例输出。

**样例解释 5**

见题目目录下的 *5.in*。该样例不提供样例输出。

**提示**

我们会下发一个可执行文件 `checker` 来帮助你检查你的输出是否正确。使用方式为在该文件所在目录下使用如下指令：

```
./checker <输入文件路径> <你的输出文件路径>
```

若你的输出正确，程序会输出 `Accepted.`；否则会提示「执行」结果与输入文件最早一次不匹配的地方。

注意，若你使用的输入文件不是样例输入，该程序不会检查是否存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的「执行」结果。

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>


## 样例 #1

### 输入

```
4 7
1 3
2 0
3 0
2 1
SWAP 1 0 2
SWAP 0 1 3
SWAP 1 2 0
MOVE 0 0 2
SWAP 1 0 2
SWAP 0 2 3
MOVE 3 0 3
```

### 输出

```
MOVE 0 1
SWAP
TRIGGER SWAP: SWAP
SWAP
```

## 样例 #2

### 输入

```
4 7
1 2
2 3
3 1
0 2
TOGGLETRIGGERREPLACE 0 1
SLACKOFF 3
MOVE 0 1 3
SWAP 1 2 3
TOGGLETRIGGERREPLACE 3 2
SLACKOFF 2
SLACKOFF 3
```

### 输出

```
TOGGLETRIGGERREPLACE 0 MOVE MOVE 1 1
TRIGGER SLACKOFF: SWAP
TRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF
SLACKOFF
```

## 样例 #3

### 输入

```
4 4
2 1
1 2
0 3
1 3
SLACKOFF 0
SLACKOFF 1
SLACKOFF 2
SLACKOFF 3
```

### 输出

```
SLACKOFF
TRIGGER SLACKOFF: SLACKOFF
TRIGGER SLACKOFF: SLACKOFF
TRIGGER TRIGGER: SLACKOFF
```

# 题解

## 作者：Rosmist (赞：6)

不是纯模拟题，怎么会呢？

当没有 `TRIGGER` 和 `TOGGLETRIGGERREPLACE` 指令时，这道题就是一道很容易的模拟题。

我们记 $f_i$ 为 $i$ 号机器人的「指令」的编号，初始时，令 $f_i=i$。

接着，按顺序处理每一条「指令」的输出信息。根据输出信息，我们得知该「指令」的编号为 $f_{\text{id}}$，并据此完善该「指令」的类型、左手/右手等信息。然后，如果该「指令」是 `SWAP`，我们交换 $f_{\text{id2}}$ 和 $f_{\text{id3}}$；如果是 `MOVE`，也进行相应的修改。

最后，按顺序输出初始时 $i$ 号机器人的「指令」（即编号为 $i$ 的「指令」）的详细信息。若仍有不确定的信息，说明该信息是无关紧要的，随意输出一个合理值即可。

而 `TRIGGER` 和 `TOGGLETRIGGERREPLACE` 指令使问题复杂起来。

首先，`TOGGLETRIGGERREPLACE` 指令产生的两条新「指令」，我们用和其他「指令」不同的编号表示它们。被 `TOGGLETRIGGERREPLACE` 指令「切换」的「指令」前后大部分信息相同而编号不同，这些信息可以记录在同一个地方，以避免两条「指令」的信息的不同步。

对于 `TRIGGER`，容易知道，`TRIGGER` 指令的触发和非 `TRIGGER` 指令的执行可能产生相同的输出信息，因此输出信息为 `<COMMANDNAME>` 的「指令」有 `TRIGGER <ANOTHERCOMMANDNAME>: <COMMANDNAME>` 或 `<COMMANDNAME>` 两种可能的形式。

具体地，我们发现：

- 只有「当一个**其他**机器人『执行』完一条『指令』之后，且『右手』指向自己的时候」，自己的 `TRIGGER` 指令才可能被触发。
  - 从而，一条「指令」最多触发一条 `TRIGGER` 指令。
    - `TRIGGER <COMMANDNAME（非 TRIGGER）>` 指令的上一条执行的「指令」一定是 `<COMMANDNAME>` 或 `TRIGGER <ANOTHERCOMMANDNAME>: <COMMANDNAME>` 指令。
    - 输出信息为 `<COMMANDNAME>` 的「指令」的下一条执行的「指令」如果是 `TRIGGER`，则下一条「指令」要么是 `TRIGGER <COMMANDNAME>`，要么是 `TRIGGER TRIGGER`。
    - 一个机器人「执行」完一条输出信息为 `<COMMANDNAME>` 的「指令」之后，若这是最后一条「指令」或「右手」不指向下一条「指令」的执行者，
      - 若这不是最后一条「指令」，则下一条「指令」一定不是 `TRIGGER` 指令；
      - 若「右手」不指向它自己，则其「右手」指向的机器人的「指令」一定不是 `TRIGGER <COMMANDNAME>` 指令。

对于每条「指令」，我们根据上述结论维护「若这条『指令』是 `TRIGGER <COMMANDNAME>`，`<COMMANDNAME>` 可能的选择集合」。

假如一条「指令」是 `TRIGGER`，而且根据上述「选择集合」，它既可能是 `TRIGGER <COMMANDNAME（非 TRIGGER）>`，又可能是 `TRIGGER TRIGGER`，那么这条「指令」一定可以是前者，不必额外考虑后者的情况。

假如一条「指令」是 `TRIGGER`，但是根据上述「选择集合」，它只可能是 `TRIGGER TRIGGER`，由于在处理输出信息的过程中，我们并不知道每条「指令」是否一定是 `TRIGGER`，从而不能确定触发这条「指令」的「指令」是否都是 `TRIGGER`，因此我们需要再进行一遍处理：

- `TRIGGER TRIGGER` 指令的上一条执行的「指令」一定是 `TRIGGER` 指令。
  - 非 `TRIGGER` 指令的下一条执行的「指令」一定不是 `TRIGGER TRIGGER` 指令。
- 一个机器人「执行」完 `TRIGGER` 指令之后，若这是最后一条「指令」或「右手」不指向下一条「指令」的执行者，且「右手」不指向它自己，则其「右手」指向的机器人的「指令」不是 `TRIGGER TRIGGER` 指令。

因为这样的「指令」如果是 `TRIGGER`，则一定是 `TRIGGER TRIGGER`，所以可以直接据此判断其是否可以是 `TRIGGER`。

我们再配合另外的限制：

- 若对一条「指令」维护的「选择集合」是空集，则这条「指令」不是 `TRIGGER` 指令。
- 被 `TOGGLETRIGGERREPLACE` 指令「切换」的「指令」前后有且仅有一个是 `TRIGGER` 指令。

对于每条「指令」是否是 `TRIGGER` 指令，我们根据上述有关限制建立 2-SAT 模型并求解，根据结果输出即可。

总的流程是：

1. 遍历并处理每一条「指令」的输出信息。
   1. 完善该「指令」的信息。
   2. 根据该「指令」和上一条「指令」之间的关系，维护「选择集合」。
   3. 实现该「指令」本身执行时的效果。
2. 注意处理最后一条「指令」对「选择集合」的影响。
3. 根据有关限制建立 2-SAT 模型。
   - `TOGGLETRIGGERREPLACE` 指令的限制可以直接在遍历时处理。
4. 求解 2-SAT。
5. 输出结果。
   - 注意某些无关紧要的信息，如 `TOGGLETRIGGERREPLACE h <COMMANDNAME> <NEWCOMMAND>` 对 `TRIGGER` 指令「切换」时 `<COMMANDNAME>` 的内容，任意「指令」名称都是可以的。

[代码丑](https://loj.ac/s/2191527)。

---


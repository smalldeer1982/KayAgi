# [THUPC 2025 初赛] 峰回路转

## 题目背景

昼短夜长冬至近。江冽漆黑，但见东云粉。窗外惺忪鸥鹭阵，室中香漫晨炊奋。

朝肄暮劳催彼盹。宵寂观书，灯烬方安寝。请替君劳分重任，逍遥共舞生辰顺。

## 题目描述

K 最近在学古诗文。古诗文的行文不一定按照现代人的习惯，有时是因为古诗文有其特殊的语法结构，有时是因为对仗工整、韵律和谐等主观原因。但是，如果直接在原文旁边标注一个表示正确阅读顺序的排列，不仅在排版上不美观，而且寻找下一个编号也比较麻烦。为了方便阅读，K 设计了一套辅助记号来标注顺序，替代直接标注顺序编号的方式。

辅助记号一共有 3 种：近邻逆接记号、近邻顺接记号、遥远跳转记号。两种近邻记号定义了**相邻两个字符**之间相对的阅读顺序，故其必须出现在相邻两个字符之间，而不能出现在句首或句末；遥远跳转记号在单独使用时仅作用于其**前一个字符**，故其必须出现在单个字符之后，可以出现在句末而不能出现在句首。

近邻逆接记号 `*` 用于表示，在正常阅读顺序中，该记号前的**最后一个**字符应该**紧跟**在该记号后的**第一个**字符之后，如“研表`*`究明，汉字序`*`顺并不定`*`一影阅`*`响读”的正确语序是“研究表明，汉字顺序并不一定影响阅读”。近邻逆接记号可以连续使用，此时表示对应的一整段文字应从后往前逐个阅读。如“林暗草惊风，将军夜引弓”的正常语序是“林暗风惊草，将军夜引弓”，所以可以用“林暗草`*`惊`*`风”来标记主宾换位。

对于较复杂的阅读顺序，可以用遥远跳转记号来辅助理解。例如，“马之千里者，一食或尽粟一石”中，“一石”是修饰“粟”的数量短语，因此按正常语序应为“一食或尽一石粟”。为了标注此类不相邻的顺序交换，可以使用遥远跳转记号来指出需要从后往前依次阅读的一组字符，并称这样的一组字符为遥远跳转结构。为了防止出现混乱，规定对于任意两组遥远跳转结构，要么其中一组的所有字符都在另一组的任意字符之前，要么其中一组的所有字符都位于另一组中连续的某两个字符之间；不允许两组遥远跳转结构的字符在原字符串中交叉出现。因为可能出现多层嵌套，所以遥远跳转记号具有 `p-q` 的形式，其中正整数 `p` 表示内部嵌套的层数，`q` 表示在该组中的顺序。如果一组遥远跳转结构内部没有嵌套任何其它遥远跳转结构，则该组遥远跳转结构的各记号的层数 `p` 均为 $1$，否则为内部嵌套的所有遥远跳转结构的最大层数 $+1$。对于同一组遥远跳转结构，按各字符在原字符串中的出现顺序从后往前依次编号 `q` $=1,2,3,\cdots$，这一顺序也即实际阅读顺序。在阅读带有辅助记号的文本时，如果一个字符后紧跟着序号 `q` $\ge 2$ 的遥远跳转记号，则应暂时跳过该字符不读；直到遇到 `q` 恰好为 $1$ 的遥远跳转记号，此时应从后往前依次阅读同组的 `p-1`，`p-2` 等记号前的**单个**字符，直到遇到层数 `p` 更大的遥远跳转记号、另一个层数相同的 `p-1` 的遥远跳转记号（此时这一记号应标记另一组遥远跳转结构），或者碰到开头。

对于上文中取自《马说》的例句，相应的标注方法为“一食或尽粟`1-2`一石`1-1`”。再例如，“入则无法家拂士，出则无敌国外患者，国恒亡，然后知生于忧患而死于安乐也”一句中出现了两处状语后置（“然后知于忧患生而于安乐死也”），其满足要求的标注方法为“然后知生`1-2`于忧患`1-1`而死`1-2`于安乐`1-1`也”。另外，同一组的遥远跳转记号的序号 `q` 一定是降序出现的，即不允许连续出现 `p-2 p-3 p-1` 等情况。

由于近邻逆接记号和遥远跳转记号都可以用来表示与正常阅读方向相反的跳转，规定在读完一个字符后需要紧接着阅读其前一个字符时，**必须**使用近邻逆接记号。这一规定会产生一个问题，即在同一组遥远跳转结构中出现了在原文中相邻的字符时，如果相邻的字符不在遥远跳转结构的开头或结尾，用近邻逆接记号来标注这一堆字符，有可能会导致阅读顺序的歧义。幸好，解决办法并不复杂：只需在出现相邻字符的位置将一个遥远跳转结构拆成两个或多个即可。注意拆开时，每个新的结构的所对应的层数应独立计算。

在使用遥远跳转记号时，默认只更改记号前的**单个**字符的阅读顺序。如果需要将连续的多个字符的阅读顺序推后，则应配合近邻顺接记号 `#`，表示该记号后的**第一个**字符应该**紧跟**在该记号前的**最后一个**字符之后。例如，“今日大风寒，寒风摧树木，严霜结庭兰”一句中，主语“庭兰”和宾语“严霜”的位置发生了对调，故可以标注为“严`1-3#`霜结`1-2`庭兰`1-1`”。出于简洁起见，要求近邻顺接记号必须和序号 `q` $\ge 2$ 的遥远跳转记号连用，但根据实际需要可以连续使用多个近邻顺接记号，此时在且仅在第一个近邻顺接记号前标注遥远跳转记号。例如，“七八个星天外，两三点雨山前”的正常语序是“天外七八个星，山前两三点雨”，因此可以标注为“七`1-2#`八`#`个`#`星天外`1-1`，两`1-2#`三`#`点`#`雨山前`1-1`”。

在阅读标注有辅助记号的文本时，默认按照正常阅读顺序从前往后处理每个字符。如果遇到一个字符没有标注辅助记号且其前一个字符没有标记近邻顺接记号，应该直接阅读这个字符；否则，先暂时忽略该字符。当遇到标注有序号为 $1$ 的遥远跳转记号的字符（对应忽略了同组的遥远跳转记号及任何相关的近邻顺接记号）或没有标注辅助记号的字符（对应忽略了至少一个近邻逆接记号）时，先阅读这个字符，再按相应规则返回阅读被忽略的字符。

为了防止使用记号时出现歧义，除了上述规则外，还规定：

- 相邻两个字符之间，要么不使用任何辅助记号，要么使用单独的近邻逆接记号，单独的近邻顺接记号，单独的遥远跳转记号，一个遥远跳转记号和一个近邻逆接记号，或一个遥远跳转记号和一个近邻顺接记号。最后一个字符之后要么没有辅助记号，要么有单独的遥远跳转记号。
- 如果相邻两个字符之间使用了一个遥远跳转记号和任意一种近邻记号的组合，则应将遥远跳转记号标在近邻记号之前。特别地，如果是一个遥远跳转记号和一个近邻逆接记号的组合，则该遥远跳转记号的序号 `q` 必须为 $1$。
- 对于任意连续的三个字符，不允许混合使用近邻逆接记号和近邻顺接记号（无论是否与遥远跳转记号搭配使用），即不能出现 `.#.*.` 或 `.*.#.` 等未定义的标注方式，其中 `.` 表示单个需要被标注的字符。同理，不允许出现前一个字符标注了近邻顺接记号，后一个字符标注了遥远跳转记号（无论这个遥远跳转记号是否与任意近邻记号组合使用）。

不过，K 发现这套系统并不能标记任意的排列。例如，“绿垂风折笋，红绽雨肥梅”在现代汉语中的语序是“风折绿笋垂，雨肥红梅绽”，它就无法被任意记号的组合表示。因此 K 想知道，对于给定的一个阅读顺序，是否存在一种仅使用上述三种记号的标注方法。如果存在，请帮 K 求出满足简洁要求的唯一标注方法。

## 说明/提示

### 样例解释

- 样例 1：“微斯人，吾谁`*`与归？”

- 样例 2：“故`1-2#`国神游`1-1`，多`1-2#`情应笑我`1-1`。”

- 样例 3：
另外三种不能被表示出来的长度为 $4$ 的阅读顺序为：
  + $2, 4, 3, 1$；
  + $3, 1, 4, 2$；
  + $3, 2, 4, 1$。
  
### 题目来源

题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。

## 样例 #1

### 输入

```
4
1 3 2 4```

### 输出

```
..*..```

## 样例 #2

### 输入

```
9
3 4 1 2 8 9 5 6 7```

### 输出

```
.1-2#...1-1.1-2#....1-1```

## 样例 #3

### 输入

```
4
2 4 1 3```

### 输出

```
-1```

## 样例 #4

### 输入

```
7
7 1 2 6 5 3 4```

### 输出

```
.1-2...1-1*.1-2..1-1```

## 样例 #5

### 输入

```
8
1 2 8 6 3 5 4 7```

### 输出

```
...2-2.1-2..1-1*..2-1```

## 样例 #6

### 输入

```
8
2 1 3 8 7 5 4 6```

### 输出

```
.*...*.1-2.*..1-1```

# 题解

## 作者：JHPOTATO (赞：7)

## 一些废话

开赛半个小时后分配到这题，然后被硬控至结束，还没调出来，团队直接蒸发一人。(这下不得不膜拜另一位狂切七题的巨佬了)

这题也是本人写的第一道紫模拟，第二道蓝及以上的模拟。

这也是本人第一篇题解，写得不好还请见谅。

## 题解

感觉和前几年的大模拟不同，这题的种种要求是在叙述中把限制零散地给出来的，并没有系统性，乍看上去很难入手，所以我们首先需要对题面做阅读理解，并简化题意。

仔细阅读后可以总结出这两条基本性质：

1. 近邻逆接记号和近邻顺接记号都只用于连接一段连续的数
2. 遥远跳转记号用于连接不同的段

那么我们可以将原序列按照阅读顺序分成若干连续段，比如可以把 `3 4 1 2 8 9 5 6 7` 划分为 `(3 4) (1 2) (8 9) (5 6 7)` 四段，并给每个段标上输出顺序，即 `2 1 4 3`，接下来的处理就可以以段为单位进行。

首先进行无解判断，因为单个段一定存在合法输出，所以只需判断能不能通过遥远跳转记号把这些段调整至正确的输出顺序。可以发现只有在遥远跳转记号之间**存在交叉**时不存在合法方案，这也是无法用栈对一个序列进行排序的充要条件，所以可以通过模拟用栈排序进行判定。也就是说**当且仅当**不能用一个栈对我们划分出的序列进行排序时，不存在合法方案，反之存在。

判断完是否合法后，我们就要确定遥远跳转标记 `p-q` 中 `p` 与 `q` 的值，也就是嵌套层数和该层的跳转顺序，我们发现这两个值都可以在栈排序的过程中求出，具体地说，我们可以给每次连续出栈的一段的 `q` 赋值，而这一段的 `p` 值可以通过统计栈中**历史存储的最大深度**求解，当然，如果一次只弹出了一个元素就不需要跳转标记了，具体细节可以看代码。

这样我们似乎就能输出一组解了，但是发现还有一些题目限制没有满足，所以针对这些细节继续处理。

再次阅读题面后，发现还有如下两条限制没满足：

1. 由于近邻顺接记号只是用来把一串数连成一段，阅读顺序与自然阅读顺序完全相同，所以如果遥远跳转记号 `q` 值为 1 且这段需要顺序输出，我们可以按照 `....p-1` 的格式输出，而不是用 `.p-1#.#.#.` 的格式输出。
2. 题目说明了形如 `*.p-q`（q 不为 1）的输出会引起阅读歧义，但题目中也给出了解决方案，只需将 `.*.*.*.p-q`（q 不为 1）改为 `p2-q2.*.*.*.p-1` 即可。

对于第一点，我们只需要进行特判并打标记即可；对于第二点，我们只需在处理到逆序输出的段时重开一层就可以解决。

处理完这些后就可以输出答案，以段为单位输出，具体实现可以看代码。

回过头再看看，会发现虽然题目给的条件零散且杂乱，但整合起来后限制并没有想象的那么多，而且代码的细节似乎也很少。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
void in(T &x){
	char c=getchar(), f=1;
	while ((c<'0' || c>'9') && c!='-') c=getchar();
	if (c=='-') f=-1, c=getchar();
	for (x=0; c>='0' && c<='9'; c=getchar())
		x=x*10+c-'0';
	x*=f;
}
//先"合并"连续段
//然后作插入
//栈发生冲突则无解
const int N=1e6+5;
int n,cnt,tmp[N],b[N];//b->映射数组
struct Node{
	bool flag;//1->顺接 0->逆接
	int st,ed;//起始点,终点
	int id;//新标号(按输出顺序标号)
	int p,q,f3;//嵌套的p,q值(首),是否有特殊输出.p-q#.#.#.---->....p-q q==1
	int p2,q2;//嵌套的p,q值(尾)
}s[N];//"缩点"后的数组
int c[N];//c->id与排序后位置的映射
bool cmp(Node e,Node f){
	return e.st<f.st;
}
int stk[N],top,ned;
int d[N];//统计嵌套层数
int stk2[N],top2;//处理连续段的嵌套的p,q值
void out(int num){//输出一段
	if(s[num].f3==1){/*
    判断是否为特殊输出
    即相邻却不需要顺邻标记的段,可能是q为1的顺序段,也可能是不需要跳转标记的顺序段
    两种情况可以放在一起考虑
    */
		for(int i=s[num].st;i<=s[num].ed;i++)printf(".");
		if(s[num].p2&&s[num].q2)printf("%d-%d",s[num].p2,s[num].q2);
		return ;
	}
	//否则一定是.*.*.或.#.#.的格式
	//首部和尾部的跳转标记直接插入即可
	printf(".");
	if(s[num].p&&s[num].q)printf("%d-%d",s[num].p,s[num].q);
	for(int i=s[num].st+1;i<=s[num].ed;i++){
		if(s[num].flag==1)printf("#.");
		else printf("*.");
	}
	if(s[num].p2&&s[num].q2)printf("%d-%d",s[num].p2,s[num].q2);
}
int main(){
	in(n);
	for(int i=1;i<=n;i++){
		in(tmp[i]);
		b[tmp[i]]=i;
	}
	int fir=1;
	while(fir<=n){
		if(fir==n){
			cnt++;
			s[cnt]={1,b[fir],b[fir],cnt};
		}
		else{
			bool flag;
			if(abs(b[fir]-b[fir+1])!=1){
				cnt++;
				s[cnt]={1,b[fir],b[fir],cnt};
			}
			else{
				flag=b[fir]<b[fir+1];
				int last=fir+1;
				while(abs(b[last]-b[last+1])==1&&last<n){
					last++;
				}
				cnt++;
				s[cnt]={flag,min(b[fir],b[last]),max(b[fir],b[last]),cnt};
				fir=last;
			}
		}
		fir++;
		//按时间段先后赋id
	}
	sort(s+1,s+cnt+1,cmp);//按原序列位置先后排序
	ned=1;stk[0]=1e9;
	for(int i=1;i<=cnt;i++){
		c[s[i].id]=i;
		if(s[i].id==ned){
			ned++;
			while(stk[top]==ned){
				ned++,top--;
			}
		}
		else{
			if(stk[top]<s[i].id){
				printf("-1\n");
				return 0;
			}
			stk[++top]=s[i].id;
		}
	}
	//能跑完(能用单栈完成排序)说明有解,然后重做一遍,进行答案更新
	top=0,ned=1;
	for(int i=1;i<=cnt;i++){
		if(s[i].id==ned){
			ned++;
			int ct=1,mxx=0;
			while(stk[top]==ned){
				mxx=max(mxx,d[top]);//记录这一段中的历史最大深度
				ned++,top--;
				ct++;
			}
			d[top]=max(d[top],mxx+1);//更新历史最大深度
			if(ct==1){//不需要嵌套
				if(s[i].flag==1)s[i].f3=1;
			}
			else{
				mxx=1,stk2[++top2]=s[i].id;
				if(s[i].flag==1)s[i].f3=1;
				for(int j=ct-1;j>=1;j--){
					mxx=max(mxx,d[top+j]);
					if(s[c[stk[top+j]]].flag==0){//重开一层,避免*.p-q q!=1的理解歧义
						int x2=top2+1;
						s[c[stk[top+j]]].p2=mxx,s[c[stk[top+j]]].q2=x2;
						x2--;
						while(top2){
							if(s[c[stk2[top2]]].f3==1){//特殊输出判断(....#)
								s[c[stk2[top2]]].p2=mxx;
								s[c[stk2[top2]]].q2=x2;
							}
							else{
								s[c[stk2[top2]]].p=mxx;
								s[c[stk2[top2]]].q=x2;
							}
							x2--;top2--;
						}
						if(j>1){//如果是首,显然不用再跳转
							stk2[++top2]=stk[top+j];
						}
						mxx=0;
					}
					else{
						stk2[++top2]=stk[top+j];
					}
				}
				if(top2){//处理未弹出部分 显然第一个是顺接 因为逆接会重开一层
					int x2=top2;
					s[c[stk2[top2]]].p=mxx,s[c[stk2[top2]]].q=x2;
					top2--,x2--;
					while(top2){
						if(s[c[stk2[top2]]].f3==1){//特殊输出判断(....#)
							s[c[stk2[top2]]].p2=mxx;
							s[c[stk2[top2]]].q2=x2;
						}
						else{
							s[c[stk2[top2]]].p=mxx;
							s[c[stk2[top2]]].q=x2;
						}
						x2--;top2--;
					}
				}
			}
		}
		else{stk[++top]=s[i].id;d[top]=1;}
	}
	for(int i=1;i<=cnt;i++)out(i);//由于已经按原序列位置先后排序,直接顺次输出
	return 0;
}
```

---


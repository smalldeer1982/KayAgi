# [THUPC 2025 决赛] 一个 01 串，n 次三目运算符，最后值为 1

## 题目背景


三目运算符表达式 `a?b:c` 的含义是，如果 `a` 为真，那么返回 `b`，否则返回 `c`。

三目运算符是右结合的：`a?b:c?d:e` 和 `a?b:(c?d:e)` 等价。如果你不记得运算顺序，可以总是使用括号。

$0$ 为假，$1$ 为真。

## 题目描述



给定一个长为 $2n+1$ 的 01 串，你需要使用 $n$ 次三目运算符，即在中间插入恰好 $n$ 个 `?` 和 $n$ 个 `:` 以及若干括号，使得表达式的结果为 $1$，或判断无解。


## 说明/提示

### 样例 #1 解释


你如果输出 `(((1?0:((((1)))))?0:1))` 等表达式也算正确。

### 提示


你可以直接使用 g++ 编译你的表达式来检查表达式的值，但是这种方法并不能检测数字的顺序是否一致，也不能检测你使用三目运算符的次数是否恰好为 $n$，即是否每两个相邻的数字之间都有一个 `?` 或 `:`：

```c++
#include <cassert>
#define YOUR_EXPRESSION <your_expression>
int main(){
    assert(YOUR_EXPRESSION);
    return 0;
}
```

### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
2
10101
```

### 输出

```
Yes
(1?0:1)?0:1
```

## 样例 #2

### 输入

```
2
00000
```

### 输出

```
No
```

# 题解

## 作者：xxgirlxx (赞：12)

## 题外话

警示后人：不要分讨太投入导致忘记要输出 Yes/No，主播因此浪费 30min+。

代码后附做题游记（逃。
## 题目思路
首先可以发现三目运算符最后结果想为 $1$，最后一步的结构一定是 `1?1:x` 或者 `0?x:1` 中的一个。

然后发现第一种情况的第一个 $1$ 可能是我们不需要考虑的，这是一种情况，第二种情况中的第一个 $0$ 和最后一个 $1$ 也可能是我们不需要考虑的，这又是两种情况。所以我们需要讨论三种情况。

在考虑情况之前我们先找一点性质：可以发现，`0?x:0` 的嵌套最终结果是最后一个数，我们可以考虑在最后一个数的位置放 $1$ 来将这一串化为一个 $1$，即将嵌套中的最后一个 `0?x:0` 换位 `0?x:1`。而且这个式子还有性质就是里面涉及到的重要的数字的所在位置的奇偶性是一致的。

然后我们考虑第一种情况，即如果该 01 串的第一个数是 $1$，那么我们就需要找到另一个 $1$，而且这个 $1$ 化出来后必须是第二个数，这个时候就可以用到上面的性质了：我们从第二个数开始一个个跳着（就是从 $x$ 跳到 $x+2$）往后找，直到找到一个 $1$ 为止。这样我们就弄出了 `1?1:x`，后面的不用管怎么算，只需要输出合法即可。

接下来我们考虑第二种情况，即如果该 01 串的最后一个数是 $1$，那么我们就需要使得第一个数是 $0$。这个时候我们需要结合上一种情况：如果该串的第一位是 $0$，那么直接就构成了 `0?x:1`，中间乱搞然后合法输出。否则该串一定进入上一种情况中进行一次判断，若该串的第二个位置是 $1$，那么该串会直接在上一种情况中输出解而不会到这种情况中。否则前三位可以构成 `1?0:x` 使得第一位变成 $0$，然后就构成了 `0?x:1`，中间乱搞然后合法输出。但是注意一下如果第一位是 $1$ 就需要判断长度，因为针对第一位是 $1$ 的情况，长度必须大于 $5$ 才行，因为需要做两次运算，如果不判断长度，就需要特判这个 hack：`101`。

最后我们来考虑第三种情况，即如果该 01 串的第一个数是 $0$，那么我们就需要使得最后一个数是 $1$。可以发现，使得最后一个数为 $1$，可以转化为在该串中取一个后缀，使得该后缀的最终值为 $1$，因此我们可以考虑将这部分用分成的三种情况中的一种情况的方法来做：但是用第三种情况等于无限嵌套，根本做不出来；第二种情况需要最后一个位置为 $1$，在这里被固定了，无法保证是通解；而第一种情况则是要求第一个数为 $1$，放到这里来就是可以选择的，我们可以通过选择合适的后缀的起点来使得第一位为 $1$，更适用且是通解，因为如果你连最后是个 $1$ 都弄不出来你整个也就做不了了。所以我们考虑将这部分转化为第一种情况，注意因为要化为 $1$ 所以后缀的长度一定是奇数，且需保证第一位为 $1$ 然后中间在偶数位上有 $1$ 就可以按第一种情况的方法做了。
## Code
注释里的做题游记占了代码总长的 $\frac{3}{5}$，抽象。

已注释掉暴戾语言，求过。
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
char a[3000010];
int main(){
	cin>>n,n=n*2+1;
	for(int i=1;i<=n;i++)cin>>a[i];
	if(a[1]=='1'){
		int f=0;
		if(a[2]=='1'){
			cout<<"Yes\n1?1:";
			int num=0;
			for(int i=5;i<=n;i+=2)num++,cout<<"(";
			cout<<a[3];
			for(int i=5;i<=n;i+=2)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			return 0;
		}
		int num=0;
		for(int i=4;i<=n;i+=2){
			num++;
			if(a[i]=='1'){f=i;break;}
		}
		if(f!=0){
			cout<<"Yes\n1?";
			for(int i=1;i<=num;i++)cout<<"(";
			cout<<a[2];
			for(int i=4,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<":",num=0;
			for(int i=f+3;i<=n;i+=2)num++,cout<<"(";
			cout<<a[f+1];
			for(int i=f+3,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
            return 0;
		}
	} 
	if(a[n]=='1'){
		if(n>=5||a[1]=='0'){
			if(a[1]=='0'){
				int num=0;
				cout<<"Yes\n0?";
				for(int i=4;i<=n;i+=2)num++,cout<<"(";
				cout<<a[2];
				for(int i=4,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
				cout<<":1";
			}
			else{
				int num=0;
				cout<<"Yes\n(1?0:"<<a[3]<<")?";
				for(int i=6;i<=n;i+=2)num++,cout<<"(";
				cout<<a[4];
				for(int i=6,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
				cout<<":1";
			}
			return 0;
		}
	}
	if(a[1]=='0'){
		int lst=0,f=0;
		for(int i=3;i<=n;i++){
			if(a[i]=='1'){
				if(i%2==1)lst=i;
				else if(lst!=0){f=i;break;}
			}
		}
		if(f!=0){
			int num=0;
			cout<<"Yes\n0?";
			for(int i=4;i<lst;i+=2)num++,cout<<"(";
			cout<<a[2];
			for(int i=4,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<":(1?",num=0;
			for(int i=lst+3;i<=f;i+=2)num++,cout<<"(";
			cout<<a[lst+1];
			for(int i=lst+3,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<":",num=0;
			for(int i=f+3;i<=n;i+=2)num++,cout<<"(";
			cout<<a[f+1];
			for(int i=f+3,j=1;j<=num;i+=2,j++)cout<<"?"<<a[i-1]<<":"<<a[i]<<")";
			cout<<")";
			return 0;
		}
	} 
	cout<<"No"; 
	return 0;
}
/*
好的如你所见我又开始做构造了
这是我的第三道构造黑
前两道分别是P6892和AT_arc189_e
在这里贴个专栏：
P6892:https://www.luogu.com.cn/article/gnqb5657
AT_arc189_e: https://www.luogu.com.cn/article/st0edth2
lc上场那个T2能算构造嘛？
没有方案的构造是没有灵魂滴！
首先搞清楚肯定正确的情况：
1?1:x和0?x:1一定是正确的
因此我们可以尝试着舍弃第一个数？
好像不行
这不就假了？
***
不会
三目运算符最强大的一集
哦哦哦可以发现一个东西就是你想要一个1可以是多个0?x:0嵌套然后最后一个是0?x:1
这样就可以弄出一个1来
然后你就会发现这样搞出来貌似0的位置的奇偶性都是一致的
这样第一位为1的话就非常容易了啊
至少其中一种有解是非常容易的
但是显然不是这种方式无解就无解
样例一就是反例
因为可以有最后一个位置是1然后搞成第一位为0的情况
so?
所以还要讨论两种情况？
***
讨厌分讨
虽然难的构造很少有不分讨的（逃
所以接下来就又分成两种：
一种是0?x:1（确定1）
另一种是0?x:1（确定0）
不管了
先把1?1:x的情况给写了
Coding···
哦哦哦发现一个corner case
就是如果1前面只有一个0就会逝
***
还得搞？
哦哦哦
这种情况下貌似就不行
***
为什么会T啊？
哦哦哦字符串加太屎了
改一下
欸nm为什么会WA啊
哦哦哦原来起始位置写错了
完成
所以现在还剩两种情况：
都是以0?x:1来使最终结果为1
但确定的东西不同
一个确定的是0
另一个确定的是1
先看看确定0的情况
那就是要使最后一个位置为1
这好搞吗？
感觉不好搞啊
1?1:x中的1之所以好搞是因为它不需要考虑位置的原因啊
反正从第二个位置开始就行了
但这种情况不行啊
它的最后一个位置必须是1
不好搞
这真不好搞
再尝试找找除了0?x:0嵌套之外的性质吧
有没有1的嵌套呢？
好像没有
主要是0之所以有性质是因为0刚好隔一个就行
所以0如果中间先弄的话是不会改变结果的
但是1就不行了
***
神秘
哦哦哦发现一种可以做确定1的情况的做法
就是你会发现你最后一位是1
需要第一位是0
但如果第一位不是0那么就肯定是1
那就会进入第一个进行判断
但是第一个又没有成功
就说明第二个位置一定是0
所以直接跑前三个就可以弄出0了
但是注意一下可能有101卡你
因为这种方法长度至少都得是5
所以还是要判断一下
Coding···
***
怎么WA了？
怎么是神秘错误
***
我**0?1:1也有错？
不符合模式？
什么模式？
这哪里不是三目运算符了？
进题目给的链接里找下数据和SPJ
***这么多怎么找？
尝试寻找旁边的大佬求助未果
终于找到了
看看SPJ
***我没输出Yes/No
幽默过头了哥们
好的过了
最后一种定0找1真**不知道咋做啊
这个1真心不好找啊
主要是你要找1
最后一个又不一定是1
假如说前面又足够多的数
最终化出来的结尾要么是100要么是10
这不得去前面找1？
这去前面找1那不得麻烦上天
***太难了
所以说会不会最终用的1不是最后一个1？
***很有可能啊
那会是哪个1？
哦哦哦可以在后面找两个连着的1
这样后面就不用管了
正确性也很好证
你连两个连着的1都没有剩下的你还能怎么搞出来？
肯定搞不出来
Coding···
哦哦哦还要注意一下这两个连着的1中前面那个必须在奇数位
否则你会发现搞不了
先assert一下验证一下正确性
完蛋
剩下的部分不是全是这个东西
也就是说这个不是通解
哦哦哦不一定要现在就连着
可以用操作来让它连着
翻译：只要有两个1之间差了偶数个数就可以
***
剩下的还有不是这个东西的
那**是什么？
欸欸欸这题怎么有个紫的双倍经验啊？
那这题是黑还是紫？
不管了
好好想想0?x:1定0怎么做
哦是不是还是得到前面去找1啊？
难绷
看看是不是需要两个1之间隔偶数位且后面的0的数量是奇数
毕竟奇数个才能使110算出来是0
那最后一位是1怎么办？
那不是都在上一种情况考虑过了吗？
再assert试试
都奋战3h+了
再试不出来就要崩溃看题解了
漂亮！
就是这个方法
Coding···
颢爷
我成啦！
*/
```

---

## 作者：Lyrella (赞：5)

# 题解

大分讨。我们先考虑什么情况下有解？因为每次操作是三个数为一组，所以我们可以把基本情况在草稿纸上列出来（在此不列出）。我们尝试总结一点神秘结论，比如若最后为一，只有 $101$ 是无解的，其余均有解。还有就是连着两个一跟着什么东西好像也有解，但是 $10010$ 这样也有解但是这又该怎么归类呢？

首先对于奇数位置为一且后面位置有偶数位置有一时一定有解。对于这种我们可以刻画成 $??1??1?$ 的结构，现在我们尝试对此化简。看到一中间偶数个位置，考虑我们先随便操作，到最后还剩下两个位置的时候我们可以进行分类讨论。若现在为形如 $1xy1$ 的结构，我们看 $x=0/1$ 的做法：

- $x=0$，序列形如 $10y1$。我们可以这样操作：$1(0?y:1)$，此时在遇到零后就与 $y$ 无关了，现在简化成了 $11$ 的情况。
- $x=1$，序列形如 $11y1$。我们可以这样操作：$(1?1:y)1$，此时同理可得 $11$。

因此我们解决了中间间隔为偶数的情况，现在考虑形如 $??11?$ 的做法。如果只有后面三个数我们肯定是直接做就对了，但是实际前面还有一段，所以我们希望维持最后这个结构。我们还是讨论一下：

- 第一个为零，序列形如 $0?11?$，我们先做最左边变成 $11?$ 然后就行了。
- 第一个为一，序列形如 $1?11?$，这个可能没有那么一眼但是也不难，考虑先做中间的 $?11$，因为无论条件最后都返回一，于是序列变成 $11?$ 然后就又可以做了。

于是我们就解决完奇数位置为一且后面位置有偶数位置有一的情况。现在考虑最后一个位置为一的情况。因为我们已经做了前面一种情况所以不会出现一个奇数位置为一后面又有偶数位置为一。我们还是只看最后五个位置，这样不失一般性。现在开始大力讨论：

- 序列形如 $0?011$ 或 $01??1$。这个就用上面相同的方法做就行了。

- 序列形如 $?0?01$。我们继续去讨论第一个位置是多少：

  - 第一个为零，序列形如 $00?01$，我们先做中间的 $0?0$，但是我们不关心其取值，因为最后还有 $0?1$ 一定为一。

  - 第一个为一，序列形如 $10?01$，我们先做最前面的 $10?$ 变成 $0$，然后做 $001$ 变成一即可。

然后你就发现貌似是讨论完了，对于长度为三的情况就暴力特判即可。

大概讲一下代码，首先你先特判长度为三的序列，直接分讨，然后注意每次合并你就当成维护并查集即可。把整个流程画出来你发现其实就是一个三叉树的形式，并且如果你从根开始 dfs 就行了。但是你这样做就不知道每次合并后相邻的位置的情况，所以你改装一下这棵树，加入链表的特征，让他能维护前后，每次合并同时维护链表即可。

# 代码

```cpp
/*
 * @Author: Nekopedia 
 * @Date: 2025-06-27 11:12:19 
 * @Last Modified by: Nekopedia
 * @Last Modified time: 2025-06-27 12:16:59
 */
#include <bits/stdc++.h>
#define ll long long
#define gc getchar
#define pc putchar
using namespace std;
const int N = 5e5 + 5, S = 1 << 25;
inline ll rd(){
    ll x = 0, f = 1; char c = gc();
    while(! isdigit(c)){if(c == '-')f = - f; c = gc();}
    while(isdigit(c)){x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    return x * f;
}
inline void wt(ll x){
    if(x < 0)pc('-'), x = - x; static short st[20], top(0);
    do st[++top] = x % 10, x /= 10; while(x);
    while(top)pc(st[top--] ^ 48);
}

int n, tot, p1, p2, st, ed;
struct node{int son[3], x, las, nxt; inline void clr(){son[0] = son[1] = son[2] = 0;}}a[N];
inline void cmb(int x, int y, int z){
    a[++tot] = {x, y, z};
    a[tot].x = a[x].x ? a[y].x : a[z].x;
    a[tot].las = a[x].las; a[tot].nxt = a[z].nxt;
    a[a[x].las].nxt = tot; a[a[z].nxt].las = tot;
    if(x == st)st = tot; if(z == ed)ed = tot;
}
void dfs(int x){
    if(! a[x].son[0])return wt(a[x].x), void();
    pc('('); dfs(a[x].son[0]); pc('?');
    dfs(a[x].son[1]); pc(':'); dfs(a[x].son[2]); pc(')');
}

inline void special_solve(){
    if(! a[2].x and ! a[3].x)return puts("No"), void();
    if(a[1].x != a[2].x and a[2].x != a[3].x)return puts("No"), void();
    puts("Yes");
    if(! a[1].x)return printf("0?%d:1\n", a[2].x), void();
    printf("1?1:%d\n", a[3].x);
}
inline void case1_solve(){
    puts("Yes");
    for(int i = p1 + 3; i < p2; i += 2){
        int x1 = a[i].las, x2 = a[x1].las;
        cmb(x2, x1, i);
    }
    int x = a[p1].nxt, y = a[p2].las;
    if(x != p2){
        if(a[x].x)cmb(p1, x, y), p1 = tot;
        else cmb(x, y, p2), p2 = tot;
    }
    for(int i = a[p2].nxt; i != ed; i = tot){
        int j = a[i].nxt, k = a[j].nxt;
        cmb(i, j, k);
    }
    if(p1 == st){
        cmb(p1, p2, a[p2].nxt);
        return dfs(tot), pc('\n'), void();
    }
    for(int i = st; a[a[i].nxt].nxt != p1; i = tot){
        int j = a[i].nxt, k = a[j].nxt;
        cmb(i, j, k);
    }
    if(a[st].x)cmb(a[st].nxt, p1, p2), cmb(st, tot, ed);
    else cmb(st, a[st].nxt, p1), cmb(tot, p2, ed);
    dfs(tot); pc('\n');
}
inline void case2_solve(){
    puts("Yes");
    for(int i = st; a[a[i].nxt].nxt != a[a[ed].las].las; i = tot){
        int j = a[i].nxt, k = a[j].nxt;
        cmb(i, j, k);
    }
    if(a[st].x)cmb(st, a[st].nxt, a[a[st].nxt].nxt), cmb(tot, a[ed].las, ed);
    else cmb(a[st].nxt, a[a[st].nxt].nxt, a[ed].las), cmb(st, tot, ed);
    dfs(tot); pc('\n');
}

signed main(){
    for(int T = rd(); T--; p1 = p2 = 0){
        tot = n = rd() << 1 | 1; for(int i = 1; i <= n; ++i){
            char c; cin >> c; a[i].x = c ^ 48;
            a[i].las = i - 1, a[i].nxt = i + 1;
        }
        st = 1, ed = n;
        if(n == 3){special_solve(); goto lyr;}
        for(int i = 1; i <= n; ++i){
            if(i & 1 and a[i].x and ! p1)p1 = i;
            if(i + 1 & 1 and a[i].x and p2 < p1)p2 = i;
        }
        if(p1 and p1 < p2)case1_solve();
        else if(a[n].x)case2_solve();
        else puts("No");
        lyr : for(int i = 1; i <= tot; ++i)a[i].x = a[i].las = a[i].nxt = 0, a[i].clr();
    }
    return 0;
}
```

---

## 作者：MatrixGroup (赞：5)

## 题意

给定一个长度为 $2n+1$ 的 $\texttt{01}$ 串，试构造一个三目运算符表达式，依序出现的常量恰为这个字符串，或报告无解。

并非多测，$n\le 1.5\times10^5$。

## 题解

这里复现一下 THUPC 考场思路。

首先，题意等价于不断把 $\texttt{1}ab\to a$ 而 $\texttt{0}ab\to b$，最终得到 $\texttt{1}$。

### 简单情况

考虑最后一步，要么是 $\texttt{11}x\to \texttt1$ 要么是 $\texttt{0}x\texttt{1}\to \texttt1$。由于 $x$ 是任意的，那么如果字符串以 $\texttt{11}$ 开头或者以 $\texttt{0}$ 开头且以 $\texttt{1}$ 结尾，那么剩下的随便合并，最后做一次即可。

### 以 $\texttt{1}$ 结尾

刚才说了两种简单情况，排除掉之后，如果还要以 $\texttt{1}$ 结尾，那么必须以 $\texttt{10}$ 开头。

首先，$\texttt{101}$ 做一次之后会变成 $\texttt{0}$，因此这时无解。否则，考虑到转化成已经解决的有解的情况。对前三个字符做一次，因为是 $\texttt{10}$ 开头，必然得到 $\texttt{0}$，然后就按照 $\texttt{0}$ 开头 $\texttt{1}$ 结尾的做即可。

### 以 $\texttt{1}$ 开头

刚才说的情况排除掉之后，剩下的部分以 $\texttt{10}$ 开头以 $\texttt{0}$ 结尾。这个时候缩开头看起来有点难受，考虑能不能保留 $\texttt{1}$ 而剩下凑出 $\texttt{1}$。通过一定手玩可以发现，如果有一个偶数位的 $\texttt{1}$，考虑找出第一个，即字符串形如 $\texttt{10}x\texttt{0}y\texttt{0}z\texttt{0}\cdots p\texttt{0}q\texttt{1}$，那因为 $\texttt{0}$ 的作用是取它后面两个的位置，那不断向前缩就可以得到 $\texttt{11}$ 开头，于是就做完了！

那如果没有偶数位置的 $\texttt{1}$ 呢？猜测无解，考虑证明。容易发现这样的字符串做完一次操作之后还是这样的字符串。具体地，若字符串形如 $\texttt{*0*0*0}\cdots\texttt{*00}$，其中 $\texttt{*}$ 是任意字符，那么缩 $\texttt{*0*}$ 得到的结果不知道，看做任意字符 $\texttt{*}$，缩 $\texttt{0*0}$ 得到的是 $\texttt{0}$，缩 $\texttt{*00}$ 也只能得到 $\texttt{0}$，因此这个字符串一定一直长成这样，那么最后只能得到 $\texttt{0}$，故无解。

### 其它情况

剩下的情况怎么办呢？考虑类比刚才的结论，我们知道在最后一位是 $\texttt{0}$ 的时候，偶数位全是 $\texttt{0}$ 是无解的。类似的，奇数位全是 $\texttt{0}$ 也是无解的。但手玩可以发现偶数位和奇数位都有 $\texttt{1}$ 有时也无解，比如 $\texttt{01100}$。

那还是来考虑先直接构造一些有解的情况吧。刚才说过 $\texttt{0*0*0*}\cdots\texttt{0*1}$ 可以缩成 $\texttt{1}$，刚才对 $\texttt{11}$ 开头的第二个 $\texttt{1}$ 反向做了这个事情，那第一个 $\texttt{1}$ 也可以！因此，如果存在一个奇数位置的 $\texttt1$ 在偶数位置的 $\texttt1$ 前面，则找到第一个奇数位置的 $\texttt1$ 后面的第一个偶数位置的 $\texttt1$ 缩掉即可！

  否则，经过手玩可以猜测它无解。考虑证明。存在一个奇数位置的 $\texttt1$ 在偶数位置的 $\texttt1$ 前面，反过来就是所有奇数 $\texttt{1}$ 都在偶数 $\texttt1$ 后面，也就是存在一个分界线，前面的奇数位都是 $\texttt{0}$，后面的偶数位都是 $\texttt0$。再加上我们排除了结尾是 $\texttt{1}$ 的情况，字符串一定形如 $\texttt{0*0*}\cdots\texttt{0*0**0*0*}\cdots\texttt{0*00}$。根据类似的论证，这个字符串一定保持这种形态，直到 $\texttt{**}$ 和 $\texttt{00}$ 碰到一起（当然也可能没有 $\texttt{**}$ 和 $\texttt{00}$，也就是奇位全 $\texttt0$ 或偶位全 $\texttt0$，这种情况讨论过了），即 $\texttt{0*0*}\cdots\texttt{0*0**00}$，此时对 $\texttt{**0}$ 或者 $\texttt{*00}$ 操作，就会得到 $\texttt{0*0*}\cdots\texttt{0*0*0}$，这种情况刚才讨论过是无解的。综上，这种情况无解。

### 总结

把刚才说的实现一下即可，注意一部分讨论可以合并。

把缩字符串变成三目运算符可以考虑记录每个字符的来源，最后递归输出。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,del##i##verme=int(n);i<del##i##verme;++i)
#define pb push_back
using namespace std;
int n,cnt;
string s;
int x[1145141],y[1145141],z[1145141],val[1145141];
int f(int a,int b,int c)
{
	int ret=++cnt;
	x[ret]=a;y[ret]=b;z[ret]=c;val[ret]=val[a]?val[b]:val[c];
	return ret;
}
vector<int> vc;
void write(int id)
{
	if(id<=1){cout<<id;return ;}
	cout<<'(';write(x[id]);cout<<'?';write(y[id]);cout<<':';write(z[id]);cout<<')';
}
int construct()
{
	if(vc[0]==1&&vc[1]==1)
	{
		int cur=vc[2];
		for(int i=3;i<int(s.size());++++i) cur=f(cur,vc[i],vc[i+1]);
		cur=f(vc[0],vc[1],cur);
		return cur;
	}
	if(vc[0]==0&&vc.back()==1)
	{
		int cur=vc[1];
		for(int i=3;i<int(s.size());++++i) cur=f(cur,vc[i-1],vc[i]);
		cur=f(vc[0],cur,vc.back());
		return cur;
	}
	if(vc.back()==1)
	{
		if(n==1) return -1;
		int cur=vc[3];
		for(int i=5;i<int(s.size());++++i) cur=f(cur,vc[i-1],vc[i]);
		int bg=f(vc[0],vc[1],vc[2]);cur=f(bg,cur,vc.back());
		return cur;
	}
	int pos=0;while(pos<int(s.size())&&vc[pos]==0) ++++pos;
	if(pos>=int(s.size())) return -1;
	int pos2=pos+1;while(pos2<int(s.size())&&vc[pos2]==0) ++++pos2;
	if(pos2>=int(s.size())) return -1;
	int bg=vc[pos];for(int i=pos-2;i>=0;----i) bg=f(vc[i],vc[i+1],bg);
	int md=vc[pos2];for(int i=pos2-2;i>=pos+1;----i) md=f(vc[i],vc[i+1],md);
	int ed=vc[pos2+1];for(int i=pos2+2;i<int(s.size());++++i) ed=f(ed,vc[i],vc[i+1]);
	int cur=f(bg,md,ed);
	return cur;
}
int t;
void solve()
{
	vc.clear();cnt=1;
	cin>>n>>s;rep(i,2*n+1) vc.pb(s[i]&1);
	int result=construct();
	if(result==-1){cout<<"No\n";return ;}
	cout<<"Yes\n";write(result);cout<<'\n';
}
int main()
{
	ios_base::sync_with_stdio(false);cin.tie(0);
	t=1;
	while(t--)solve();
	return 0;
}
```

---

## 作者：Jorisy (赞：5)

$$
\gdef\wht{\color{white}}
\gdef\sth{\boxed{\wht \0}}
\gdef\1{\texttt{1}}
\gdef\0{\texttt{0}}
\gdef\?{\,\texttt{?}\,}
\gdef\:{\,\texttt{:}\,}
$$
考虑最外层的一个三目运算符，要结果为 $\1$，**转化到最后**，只会是 $\1\?\1\:\sth$ 或 $\0\?\sth\:\1$。

首先考虑 $\1\?\1\:\sth$ 的情况。对于表达式中的 $\1$，我们都可以构造 $\0\?\sth\:\0\?\sth\:\cdots\0\?\sth\:\1$ 得到。

由于 $\sth$ 的长度都是奇数，所以表达式中第一个 $\1$ 我们需要一个原先在奇数位的 $\1$；继而得到，第二个 $\1$ 我们需要一个原先在偶数位的 $\1$。所以我们找到**最靠前**的这样两个 $\1$ 就可以直接构造了。并且如果不存在这样的两个 $\1$ **该情况下**就是无解。

事实上，上述情况我们忽略了第二个 $\1$ 在末尾的可能。这一点可以和上述情况中的无解一同放到 $\0\?\sth\:\1$ 的情况下考虑。

注意，在第二种情况下，除了最后一位，其余位的 $\1$ 的**下标奇偶性相同**。

首先判一下最后一位是不是 $\1$。是 $\1$ 的话显然可以用上述方法构造。不是的话，我们必须要构造一个保留最外层表达式是一个 $\1\?\1\:\0$ 的状物。然而根据第一种情况的论述，这里的两个 $\1$ 原先位置的下标奇偶性不同，所以就无解了。 

串的第一位是 $\0$ 是极其容易的。考虑第一位是 $\1$ 的情况，我们必须要将其转化为 $\0$。由于第二位是 $\0$，那么我们就有 $\texttt(\1\?\0\:\sth\texttt)\?\sth\:\1$ 的构造形式。

于是就做完了。

此外还有一些像 $\1\0\1$ 的极小 corner case，需要注意一下。

```cpp
#include<bits/stdc++.h>
#define N 300005
#define ll long long
#define mod 
using namespace std;

int n,m,a[N];

int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    m=n*2+1;
    for(int i=1;i<=m;i++)
    {
        char c;
        cin>>c;
        a[i]=c-48;
    }
    if(a[m])
    {
        if(!a[1])
        {
            cout<<"Yes\n0?";
            for(int i=2;i<m-1;i++) cout<<a[i]<<"?:"[i&1];
            cout<<a[m-1]<<":1";
            return 0;
        }
        if(!a[2])
        {
            if(m==3)
            {
                cout<<"No";
                return 0;
            }
            cout<<"Yes\n(1?0:"<<a[3]<<")?";
            for(int i=4;i<m-1;i++) cout<<a[i]<<"?:"[i&1];
            cout<<a[m-1]<<":1";
            return 0;
        }
    }
    int p1=0,p2=0;
    for(int i=1;i<=m;i+=2)
    {
        if(!a[i]) continue;
        p1=i;
        break;
    }
    for(int i=p1+1;i<=m;i+=2)
    {
        if(!a[i]) continue;
        p2=i;
        break;
    }
    if(p1>=p2)
    {
        cout<<"No";
        return 0;
    }
    cout<<"Yes\n(";
    for(int i=1;i<p1;i++) cout<<a[i]<<":?"[i&1];
    cout<<"1)?";
    for(int i=p1+1;i<p2;i++) cout<<a[i]<<"?:"[i&1];
    for(int i=p2;i<m;i++) cout<<a[i]<<":?"[i&1];
    cout<<a[m];
    return 0;
}
```

---

## 作者：wosile (赞：3)

Fun fact：这题在纸质题面上的标题为“标题请以 OJ 为准”。

首先我们可以发现，要让一个三目运算表达式的值为 $1$，这个表达式一定是 `0?x:1` 或者 `1?1:x`，其中 `x` 为任意值。我们尝试往这个方向构造。

通过对这两种构造的细致分讨我们可以发现，绝大部分结尾为 `1` 的串都可以构造使得其答案为 $1$，唯一的反例是 `101`。我们考虑如下分类讨论：

- 如果这个串的开头是 `0`，那么我们把第一个字符作为条件，最后一个字符作为不成立取值，答案即为 $1$。
- 如果这个串的开头是 `10`，那么我们把前三个字符作为条件，最后一个字符作为不成立取值，答案即为 $1$。注意这样做需要整个串的长度至少为 $5$，所以 `101` 这个串是无法构造的（也是唯一的反例）。
- 如果这个串的开头是 `11`，那么我们把第一个字符作为条件，第二个字符作为成立取值即可。

基于 `1?1:x` 的构造，我们还可以发现，假如我们有一个（从 $1$ 开始编号）奇数位置的 `1`，在其后有一个偶数位置上的 `1`（$s_{p_1}=s_{p_2}=1,p_1<p_2,p_1 \bmod 2 = 1, p_2\bmod 2 = 0$），那么我们可以把整个串划分为 $[1,p_1]$，$[p_1+1,p_2]$，$[p_2+1,2n+1]$ 三段，其中前两段都可以构造使得值为 $1$。为了避免出现 `101` 这种反例，我们可以选择尽量小的合法的 $p_1$ 和 $p_2$，容易证明这样前两段一定不会出现 `101`。

对于剩下的情况，所有的偶数位置上的 `1` 都在奇数位置上的 `1` 后面，且末尾不是 `1`。我们考虑归纳来证明这个串无论如何划分取值一定为 $0$。将整个串分为三段，根据归纳假设，第一段与第三段（条件和不成立取值）都一定为 $0$，所以整个串也为 $0$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char s[300005];
void anys(int l,int r){
    // 任意结果
    if(l==r){
        printf("%c",s[l]);
        return;
    }
    printf("(%c?%c:",s[l],s[l+1]);
    anys(l+2,r);
    printf(")");
}
void solve(int l,int r){
    // 末尾为 1 的构造
    assert(s[r]=='1');
    if(l==r){
        printf("%c",s[l]);
        return;
    }
    if(s[l]=='0'){
        printf("(%c?",s[l]);
        anys(l+1,r-1);
        printf(":%c)",s[r]);
    }
    else{
        assert(l+3<r);
        printf("((%c?%c:%c)?",s[l],s[l+1],s[l+2]);
        anys(l+3,r-1);
        printf(":%c)",s[r]);
    }
}
int main(){
    scanf("%d",&n);
    scanf("%s",s+1);
    n=n*2+1;
    if(n==3 && s[1]=='1' && s[2]=='0' && s[3]=='1'){
        printf("No\n");
        return 0;// 特判 101
    }
    int p1=-1,p2=-1;
    for(int i=1;i<=n;i+=2)if(s[i]=='1'){
        p1=i;
        break;
    }
    for(int i=p1+1;i<=n;i+=2)if(s[i]=='1'){
        p2=i;
        break;
    }
    if(p1!=-1 && p2!=-1){
        assert(p1%2==1 && p2%2==0);
        printf("Yes\n");
        printf("(");
        solve(1,p1);
        printf("?");
        solve(p1+1,p2);
        printf(":");
        anys(p2+1,n);
        printf(")");
    }
    else if(s[n]=='1'){
        printf("Yes\n");
        solve(1,n);
    }
    else printf("No\n");
    return 0;
}
```

---

## 作者：_LiWenX_ (赞：2)

好题，以下为赛时思路：

首先尝试手玩，发现只要有连续三个 `1` 就必然合法之后就再也没玩出来什么东西了，于是等队友写完其他题之后抢占机子写了个 $O(n^4)$ 的判断有无解的 dp，然后把长度为 $9$ 的所有合法串搜了出来，发现了几个性质：

首先最显而易见的是，只要最后一位是 `1` 就合法。

其次会发现，只要存在一个奇数位置上的 `1` 后面紧跟一个 `1`，就合法。

猜测是充要条件，然后被 `001001000` hack 了。。。

然后我发扬人类智慧，猜测只要存在一个奇数下标的 `1` 在一个偶数下标的 `1` 之前，就合法。

把这个结论和暴力拍了一下，发现对了？？！！！

所以现在当务之急是考虑构造出来。

## case1

首先考虑存在一个奇数位置上的 `1` 后面紧跟一个 `1` 的情况：

把这两个特殊的 `1` 标记出来。

不妨把其他与这两个无关的段任意缩起来，得到串 `ab1cd1e`。

首先考虑一个弱化的问题，`ab11c`，可以发现存在一个通解：

- 若 $a=0$，`([a?b:1]?1:c)`。

- 若 $a=1$，`(a?[b?1:1]:c)`。

所以我们解决了 `ab11c`。

考虑把 `ab1cd1e` 变成 `ab11c`，也就是 `1ab1` 变成 `11`，也可以发现存在一个通解：

- 若 $a=0$，`1(a?b:1)`。

- 若 $a=1$，`(1?a:b)1`。

所以 case1 解决了。

## case2

只要最后一位是 `1` 就合法。

在此之前，会发现有特例 `100`，也就是说 $n\ge 5$ 才生效，所以我们可以把一个串先不断的操作，直到保留后面五个元素，又因为判掉了 case1，现在的串必然形如 `a0b01`，手玩之后，也有通解：

- 若 $a=1$，`[(a?0:b)?0:1]`。

- 若 $a=0$，`(a?[0?b:0]:1)`。

所以你发现做完了，具体实现又有若干细节，复杂度显然是线性。

我的代码实现有点狗屎，应该有漂亮的多的写法，这里只给个参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int op;
	int l,m,r,id;
}a[1000005];
char s[1000005];
node sta[1000005];int top; 
int ys(int x,int y,int z){
	if(a[x].op) return a[y].op;
	return a[z].op; 
}
void solve(node x){
	if(!x.l){
		cout<<x.op;
		return ;
	}
	cout<<'(';
	solve(a[x.l]);
	cout<<"?";
	solve(a[x.m]);
	cout<<":";
	solve(a[x.r]);
	cout<<')';
}
void solve(){
	int n;cin>>n;n<<=1,n++;
	for(int i=1;i<=n;i++){
		cin>>s[i];
	}
	int fir=n+1,ed=-1;
	for(int i=1;i<=n;i++){
		if(s[i]=='1'){
			if(i&1) fir=min(fir,i);
			else ed=i;
		}
	}
	top=0;
	if(fir>ed){
		if(s[n]=='1'){
			if(n==3){
				bool flag=0;
				if(s[1]=='1'){
					if(s[2]=='1') flag=1;
					else flag=0;
				}
				else{
					if(s[3]=='1') flag=1;
					else flag=0;
				}
				if(flag){
					cout<<"Yes\n";
					cout<<s[1]<<'?'<<s[2]<<":"<<s[3]<<'\n';
					return ;
				}
				else{
					cout<<"No\n";
					return ;
				}
			}
			cout<<"Yes\n";
			int N=n;
			for(int i=n;i;i--){
				sta[++top]={s[i]-'0',0,0,0,i};a[i]=sta[top];
				if(top==7){
					int l=sta[top].id,m=sta[top-1].id,r=sta[top-2].id;
					top-=3;
					sta[++top]={ys(l,m,r),l,m,r,++N};a[N]=sta[top];
				}
			}
			swap(sta[1],sta[5]),swap(sta[2],sta[4]);
			if(sta[1].op==1){
				node now;
				int l,m,r;
				l=sta[1].id,m=sta[2].id,r=sta[3].id;
				now={ys(l,m,r),l,m,r,++N};a[N]=now;
				
				l=now.id,m=sta[4].id,r=sta[5].id;
				now={ys(l,m,r),l,m,r,++N};a[N]=now;
				
				solve(now);
			} 
			else{
				node now;
				int l,m,r;
				l=sta[2].id,m=sta[3].id,r=sta[4].id;
				now={ys(l,m,r),l,m,r,++N};a[N]=now;
				
				l=sta[1].id,m=now.id,r=sta[5].id;
				now={ys(l,m,r),l,m,r,++N};a[N]=now;
				
				solve(now);
			}
			cout<<'\n';
			return ;
		} 
		cout<<"No\n";
		return ;
	}
	cout<<"Yes\n";
	
	int N=n;
	if(fir<ed){
		top=0;
		for(int i=1;i<fir;i++){
			sta[++top]={s[i]-'0',0,0,0,i};a[i]=sta[top];
			if(top>=3){
				int l,m,r;
				l=sta[top-2].id,m=sta[top-1].id,r=sta[top].id;
				top-=3;
				sta[++top]={ys(l,m,r),l,m,r,++N};a[N]=sta[top];
			}
		}
		sta[++top]={1,0,0,0,fir};a[fir]=sta[top];
		int pre=top;
		for(int i=fir+1;i<ed;i++){
			sta[++top]={s[i]-'0',0,0,0,i};a[i]=sta[top];
			if(top>=pre+3){
				int l,m,r;
				l=sta[top-2].id,m=sta[top-1].id,r=sta[top].id;
				top-=3;
				sta[++top]={ys(l,m,r),l,m,r,++N};a[N]=sta[top];
			}
		}
		sta[++top]={1,0,0,0,ed};a[ed]=sta[top];
		pre=top;
		for(int i=ed+1;i<=n;i++){
			sta[++top]={s[i]-'0',0,0,0,i};a[i]=sta[top];
			if(top>=pre+3){
				int l,m,r;
				l=sta[top-2].id,m=sta[top-1].id,r=sta[top].id;
				top-=3;
				sta[++top]={ys(l,m,r),l,m,r,++N};a[N]=sta[top];
			}
		}
		
		if(fir!=ed-1){
			if(fir==1){
				if(sta[2].op==0){
					vector<node> vec;
					vec.push_back(sta[1]);
					int l,m,r;
					l=sta[2].id,m=sta[3].id,r=sta[4].id;
					node now={ys(l,m,r),l,m,r,++N};a[N]=now;
					vec.push_back(now);
					
					for(int i=5;i<=top;i++) vec.push_back(sta[i]);
					top=vec.size();
					for(int i=1;i<=top;i++) sta[i]=vec[i-1];
				}
				else{
					vector<node> vec;
					int l,m,r;
					l=sta[1].id,m=sta[2].id,r=sta[3].id;
					node now={ys(l,m,r),l,m,r,++N};a[N]=now;
					vec.push_back(now);
					vec.push_back(sta[4]);
					
					for(int i=5;i<=top;i++) vec.push_back(sta[i]);
					top=vec.size();
					for(int i=1;i<=top;i++) sta[i]=vec[i-1];
				}
			}
			else{
				if(sta[4].op==0){
					vector<node> vec;vec.push_back(sta[1]),vec.push_back(sta[2]);
					
					vec.push_back(sta[3]);
					int l,m,r;
					l=sta[4].id,m=sta[5].id,r=sta[6].id;
					node now={ys(l,m,r),l,m,r,++N};a[N]=now;
					vec.push_back(now);
					
					for(int i=7;i<=top;i++) vec.push_back(sta[i]);
					top=vec.size();
					for(int i=1;i<=top;i++) sta[i]=vec[i-1];
				}
				else{
					vector<node> vec;vec.push_back(sta[1]),vec.push_back(sta[2]);
					
					int l,m,r;
					l=sta[3].id,m=sta[4].id,r=sta[5].id;
					node now={ys(l,m,r),l,m,r,++N};a[N]=now;
					vec.push_back(now);
					vec.push_back(sta[6]);
					
					for(int i=7;i<=top;i++) vec.push_back(sta[i]);
					top=vec.size();
					for(int i=1;i<=top;i++) sta[i]=vec[i-1];
				}
			}
		}
		
		if(top==3){
			int l,m,r;
			l=sta[1].id,m=sta[2].id,r=sta[3].id;
			node now;now={ys(l,m,r),l,m,r,++N};a[N]=now;
			solve(now);
		} 
		else{
			if(sta[1].op==0){
				node now;
				int l,m,r;
				l=sta[1].id,m=sta[2].id,r=sta[3].id;
				now={ys(l,m,r),l,m,r,++N};a[N]=now;
				
				l=now.id,m=sta[4].id,r=sta[5].id;
				now={ys(l,m,r),l,m,r,++N};a[N]=now;
				
				solve(now);
			}
			else{
				node now;
				int l,m,r;
				l=sta[2].id,m=sta[3].id,r=sta[4].id;
				now={ys(l,m,r),l,m,r,++N};a[N]=now;
				
				l=sta[1].id,m=now.id,r=sta[5].id;
				now={ys(l,m,r),l,m,r,++N};a[N]=now;
				
				solve(now);
			}
		} 
	}
	cout<<'\n';
}
#define lfxxx (1?(0?0:1):0)
signed main(){
	assert(((0?0:1)?(0?0:1):0));
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	solve();
}
```

---

## 作者：Priestess_SLG (赞：1)

**请务必注意 本题解中下标从 $0$ 开始。**

首先 $n$ 很小的情况会有一叠的 conner case 让人头疼，因此这个时候~~直接暴搜即可。~~ 有个更简单的做法是直接特殊情况全都判掉（搜太难写的/kk）。

### 当所有字符均为 $0$ 时：

很显然无解。

### 当前两个字符为 $11$ 时：

直接按照顺序构造三目运算符，形如：`a[0]?a[1]:(a[2]?a[3]:a[4])`。容易发现设从 $a_2$ 开始到 $a_{2n}$ 一段表达式的值为 $x$，则此时表达式形如：`1?1:x`，很显然这个表达式的值为 $1$，因此得到合法解。

### 当第一个字符为 $1$ 时：

此时字符串前两个位置必须为 $10$。继续分类讨论结尾字符的情况：

#### 当最后一个字符为 $1$ 时：

把前三个字符构造三目运算符即 `a[0]?a[1]:a[2]` 即 `1?0:a[2]`，很显然这个表达式的值为 $0$。此时得到一个长度奇数，$0$ 开头 $1$ 结尾的字符串。

考虑对这样的字符串进行构造：把除了第一个和最后一个位置以外的位置按照顺序构造三目运算符。显然这个值不可控，设这个值为 $x$，那么最终状态形如 `a[0]=0,a[1]=x,a[2]=1`，构造三目运算符得到 `0?x:1`，很显然这个值为 $1$，因此构造完成。

#### 当最后一个字符为 $0$ 时：

看上去没有前面那么好处理了，考虑继续分类讨论：

+ 存在位置 $i$ 满足 $2\nmid i$，满足 `a[i]=1`，那么把最前面的一个位置保留，从 `a[1]` 开始处理到 `a[i-1]` 构造三目运算符。执行完这个操作之后前两个字符必然形如 $11$，这个情况前面讨论过了。
+ 否则，容易证明必然不存在合法解。

### 当第一个字符为 $0$ 时：

还是得分讨啊/生气了！

#### 当最后一个字符为 $1$ 时：

终于又回到了简单情况！

考虑把除了第一个和最后一个位置以外的位置按照顺序构造三目运算符。显然这个值不可控，设这个值为 $x$，那么最终状态形如 `a[0]=0,a[1]=x,a[2]=1`，构造三目运算符得到 `0?x:1`，很显然这个值为 $1$，因此构造完成。

#### 当最后一个字符为 $0$ 时：

发现这个时候没有什么容易的性质，因此用搜玩了若干组数据之后发现：

+ 若此时存在一个下标 $i$ 使得 $2\mid i$ 使得 `a[i]=1`，且继续存在一个下标 $j$ 使得 $2\nmid j,j>i$ 且 `a[j]=1`，那么合法，否则一定不合法！
+ 更清晰的说，存在偶数下标 $i$ 使得其后面存在奇数下标 $j$ 满足 `a[i]=1` 且 `a[j]=1` 则合法，否则不合法。

那么对于合法的情况考虑构造出一个解。容易找出第一个合法的 $i$ 和 $i$ 后面第一个合法的 $j$，那么就直接按照顺序分别对 $0\sim i$ 和 $i+1\sim j$ 两个部分构造出 $1$（这个上面已经讨论过了），这样前两个字符变为 $11$，这个情况也讨论过了。于是这个题做完了，后面就是可♂爱♀的 implementation 时间啦！

```cpp
// #pragma GCC optimize(3, "Ofast", "inline", "unroll-loops")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>
#define int long long
using namespace std;
// const int N = 500010;
const int inf = 2e18;
using ull = unsigned long long;
template<class _T>
using treap = __gnu_pbds::tree<_T, __gnu_pbds::null_type, less_equal<_T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;
using POD = pair<double, double>;
const double pi = acos(-1);
using cauto = complex<double>;
const int N = 1000010;
const int mod = 1e9 + 7;
const ull base = 218105633;
char s[N];
signed main() {
    // freopen("count.in", "r", stdin);
    // freopen("count.out", "w", stdout);
    // freopen("debug.err", "w", stderr);
    // cin.tie(0)->sync_with_stdio(false);
    cout << fixed << setprecision(15);
    srand(time(0));
    int T = 1;
    // cin >> T;
    int tc = T, ca = 1;
    while (T--) {
        int n;
        cin >> n;
        scanf("%s", s);
        // if (tc > 100 && ca++ == 77) {
        //     puts(s);
        //     return 0;
        // } else if (tc > 100) continue;
        if (count(s, s + n + n + 1, '0') == n + n + 1) {
            cout << "No\n";
        } else {
            if (n == 1) {
                if (s[0] == '1' && s[1] == '1' && s[2] == '0') {
                    cout << "Yes\n";
                    cout << "1?1:0\n";
                    continue;
                } else if (s[0] == '1' && s[1] == '1' && s[2] == '1') {
                    cout << "Yes\n";
                    cout << "1?1:1\n";
                    continue;
                } else if (s[0] == '1' && s[1] == '0' && s[2] == '1') {
                    cout << "No\n";
                    continue;
                }
            }
            if (s[0] == '1') {
                if (s[1] == '1') {
                    cout << "Yes\n";
                    int idx = 0;
                    for (int i = 0; i < n + n; i += 2) cout << s[i] << "?" << s[i + 1] << ":(", ++idx;
                    cout << s[n + n];
                    for (int i = 0; i < idx; ++i) cout << ")";
                    cout << '\n';
                } else {
                    if (s[n + n] == '1') {
                        cout << "Yes\n";
                        cout << "(" << s[0] << "?" << s[1] << ":" << s[2] << ")?(";
                        for (int i = 3; i < n + n - 1; i += 2) cout << s[i] << "?" << s[i + 1] << ":";
                        cout << s[n + n - 1] << "):" << s[n + n] << '\n';
                    } else {
                        int pos = -1;
                        for (int i = 1; i <= n + n; i += 2)
                            if (s[i] == '1') {
                                pos = i;
                                break;
                            }
                        if (~pos) {
                            cout << "Yes\n";
                            int idx = 1;
                            cout << s[0] << "?(";
                            for (int i = 1; i < pos; i += 2) cout << s[i] << "?" << s[i + 1] << ":(", ++idx;
                            cout << s[pos];
                            for (int i = 0; i < idx; ++i) cout << ")";
                            cout << ":(";
                            idx = 1;
                            for (int i = pos + 1; i < n + n; i += 2) cout << s[i] << "?" << s[i + 1] << ":(", ++idx;
                            cout << s[n + n];
                            for (int i = 0; i < idx; ++i) cout << ")";
                            cout << '\n';
                        } else {
                            cout << "No\n";
                        }
                    }
                }
            } else {
                if (s[n + n] == '1') {
                    cout << "Yes\n";
                    cout << s[0] << "?(";
                    for (int i = 1; i < n + n - 1; i += 2) cout << s[i] << "?" << s[i + 1] << ":";
                    cout << s[n + n - 1] << "):" << s[n + n] << '\n';
                } else {
                    int ii = -1, jj = -1;
                    vector<int> v;
                    for (int i = 2; i < n + n; ++i)
                        if (s[i] == '1') v.emplace_back(i);
                    if (v.size() < 2) {
                        cout << "No\n";
                    } else {
                        int ok = 0;
                        for (int &i : v) {
                            if (ok == 2) break;
                            if (!ok) {
                                if (i % 2 == 0) {
                                    ii = i;
                                    ok = 1;
                                }
                            } else {
                                if (i % 2 == 1) {
                                    jj = i;
                                    ok = 2;
                                }
                            }
                        }
                        // cout << ii << ' ' << jj << '\n';
                        if (ok != 2) {
                            cout << "No\n";
                            continue;
                        }
                        cout << "Yes\n";
                        cout << "(";
                        if (ii) {
                            for (int i = 0; i < ii; i += 2) cout << s[i] << "?" << s[i + 1] << ":";
                            cout << s[ii] << ")?";
                        } else cout << s[ii] << ")?";
                        if (jj - ii > 1) {
                            cout << "(";
                            for (int i = ii + 1; i < jj; i += 2) cout << s[i] << "?" << s[i + 1] << ":";
                            cout << s[ii] << "):(";
                        } else cout << s[jj] << ":(";
                        for (int i = jj + 1; i < n + n; i += 2) cout << s[i] << "?" << s[i + 1] << ":";
                        cout << s[n + n];
                        cout << ")\n";
                    }
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：_lmh_ (赞：1)

首先用瞪眼法发现 `0?x:y` 相当于删去 `0` 和 `x`，`1?x:y` 相当于删去 `1` 和 `y`。

现在我们来处理一个序列。首先删去连续的 `00` 显然不劣，所以我们尽可能多地删，得到的序列不可能出现连续的两个 `0`（除了最后两个位置以外）。

现在已经没法一次操作删去两个 `0` 了，删去一个 `0` 一个 `1` 显然无法创造出新的可以删除的 `00`（需要分类讨论），而删除两个 `1` 最多把三个 `0` 的连续段拼在一起——可以证明最多只能删一次 `00`。

所以新的连续段如果 `1` 数量比 `0` 少就完蛋了，否则我们尝试在每消去一个 `1` 同时都消去一个 `0`。

对于后缀的 `0` 我们先不做处理，其余的 `0` 从前往后优先匹配右边那个 `1`，这样可以直接消除。

但是倒数第二个位置可能是 `0` 同时最后一个位置是 `1`，此时如果在前面就是 `1` 的话，存在一个后缀为 `1101`，消去第一个 `1` 和唯一一个 `0` 即可。

否则，我们回滚上一次操作，它可能是 `00101`，`10001`，`01101` 或 `10101`。注意此时如果没有上一次操作，那么原序列必定是 `101`，显然无解。

为它们构造方案（`X` 代表已被删除）：

`00101 0XX01 XXXX1`  
`10001 X0X01 XXXX1`  
`01101 0X1X1 XXXX1`  
`10101 X0X01 XXXX1`

然后剩下的是一个 `1` 的前缀和一个 `0` 的后缀，此时 `1` 的数量比 `0` 多所以前半部分和最中间的数一定都是 `1`，用左边的 `1` 消掉右边的数即可。

---


# [THUPC 2019] 不用找的树

## 题目描述

给出一棵 $n$ 个节点的树，结点标号从 $1$ 到 $n$ 。

定义树上两点 $a,b$ 的距离 $d(a,b)$ 是最小的非负整数 $k$ ，满足存在结点序列 $v_0,v_1,...,v_k$ ，满足 $v_0=a,v_k=b$ ，且对于 $0\leq i\leq k-1$ 有 $v_i$ 和 $v_{i+1}$ 之间在树上有一条边相连。

有 $m$ 个询问，每个询问包含参数 $p_0,d_0,p_1,d_1$ ，求：

$$\sum\limits_{d(p_0,a)\leq d_0}\sum\limits_{d(p_1,b)\leq d_1}d(a,b)$$



## 说明/提示

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
7
1 1 2 3 5 2
5
5 1 5 0
2 0 5 0
2 2 4 5
7 2 2 4
3 2 5 4```

### 输出

```
2
3
69
57
70```

# 题解

## 作者：Ynoi (赞：3)

这题这辈子都调不出了，不过还是写个题解说下思路吧。

核心思路：树分块，然后大力分类讨论。

考虑树分块，使用[王室联盟](https://www.luogu.com.cn/problem/P2325)的做法，把树分成$O(\sqrt n)$块，每块里有$O(\sqrt n)$个节点，且如果把这个块所有点的LCA加上进块里，块内所有点联通。

然后我们考虑怎么算结果。

定义$f(S,T) = \sum_{x \in S}\sum_{y \in T}dis(x,y)$（如果S或T是一个点那么就把这个点当成仅包含这个点的集合看）

$g(x,d) = ${$y|dis(x,y) \le d$,且y和x在同一个块内 }


先考虑一下块内的贡献。

首先是一个预备技能，就是对于一个块，块大小为S，我们已知$x,d$,我们$O(S)$得到所有块内的点$u$的$f(u,g(x,d))$。这个就换根~~换头~~dp一下就可以了(来做这个题的这些应该会吧）

然后我们考虑计算答案，按照每个块分别考虑。有这么几种情况。

为了描述一下下面的“进入”是什么意思，这里大致说一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/bob0jeb8.png)

如图，这里意味着$p0$从$A$（有可能后面会描述成从一个块这样）进入了块$B$.

1.就是$p0$或$p1$所在块，这个直接$O(S)$暴力统计即可.

2.$p0$,$p1$从块的不同子块进入，这个只有$p0,p1$的LCA所在块，也可以$O(S)$暴力统计.

3.$p0$,$p1$从块的同一个子块进入.

4.$p0,p1$其中一个块顶进入,另一个从某个子块进入.

5.$p0,p1$都从块顶进入.

设进入点是$u,v$.

3,4,5的情况,所有块的$f(g(u,i),g(v,j))$ 总共最多$O(n \sqrt n)$种情况,那么我们就可以直接预处理出来,枚举所有g(u,i)(总共O(n)种),然后把块内所有f(g(u,i),x)算出来,之后再bfs一遍就可以把所有f(g(u,i),g(v,j))算出来.

然后块内的贡献就算好了.

然后是块间的贡献.

对于树上两个联通块 S,T, 两个点u,v,且u->v的路径上的点(u,v除外)不存在一个点在S或T中出现,u更靠近S,v更靠近T.

那么$f(S,T) = \sum_{i \in S}d(i,u) * |T| + \sum_{j \in T}d(j,v)*|S| +d(u,v)*|S|*|T|$

对于每个值分别计算.

对于一个块S,上面柿子的第2项不必计算(因为S->T的会在T->S中被算掉).
 
对于第一项,可以把 假如删除S(除了其他块的块顶)后的所有联通块 的贡献分别计算.

对于第二项,考虑树形dp来维护,大概就是维护往下走一个块后其他块对它贡献的变化.

整合一下就是$O(n \sqrt n)$.

不过真正写起来会发现细节特别多,那就祝你们好运了.

(注:也许有一些错误或是某些地方处理的不太优的情况,请写在评论区)

---

## 作者：gxy001 (赞：2)

首先你要会[树分块](https://missingroom.github.io/_posts/2021-03-13-%E6%A0%91%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)，这种树分块满足每个块都是一个连通块，且每个块只有最多两个节点与其他块相连，更多内容不赘述，可以看我的[博客](https://missingroom.github.io/_posts/2021-03-13-%E6%A0%91%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)。

一个邻域可以被拆分成不同块内的 $O(B)$ 个邻域，其中只有 $O(1)$ 个邻域的中心不是界点。

先对每个块单独处理，只考虑同一块内的两个邻域的贡献，分两种情况。

- 两个邻域的中心有至少一个不是界点，这种情况总共只有 $O(m)$ 次。我们知道 $d(a,b)=d(rt,a)+d(rt,b)-2d(rt,\operatorname{lca}(a,b))$，我们只要知道 $\sum d(rt,\operatorname{lca}(a,b))$ 就可以了。对一个邻域内的点到根的路径全部加一，求另一个邻域内的每个点到根的路径的权值和就是我们要求得值，总时间复杂度 $O(mB)$。
- 两个邻域的中心都是界点，中心只有三种情况，半径只有 $O(B^2)$ 种情况，所以总情况数只有 $O(B^2)$ 种，预处理出来就行了，预处理的方法是枚举第一个邻域的半径，然后用上面的方法就可以求出第二个邻域所有半径下的答案，总复杂度 $O(\frac {n}{B}B^2)=O(nB)$。

在考虑不同块之间的贡献，对于两个不相交的邻域，有一个求出答案的方法，找到一个点使得从两个邻域中各选一个点路径必定经过这个点。只要求出每个邻域所有点到这个点的距离和点的个数，称为 $d_i,c_i$，则答案为 $d_0c_1+d_1c_0$。对每个询问每个块求出邻域在这个块内点的个数和到两个界点的距离和，在收缩树上按照这个式子 dp 一下子就完事了。

时间复杂度 $O((n+m)\sqrt n)$，空间复杂度 $O(n+m)$。

代码就不放了，需要的可以找我要。

---


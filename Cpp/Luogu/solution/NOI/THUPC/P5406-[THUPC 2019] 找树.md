# [THUPC 2019] 找树

## 题目描述

定义 $\otimes_1, \otimes_2, \otimes_3$ 分别为按位与、按位或、按位异或运算。记 $a_i$ 表示 $a$ 的从低位到高位的第 $i$ 个二进制位。定义一个作用在 $w$ 位二进制数上的新运算 $\oplus$，满足对于结果 $a\oplus b$ 的每一位 $(a\oplus b)_i$ 有 $(a\oplus b)_i = a_i \otimes_{o_i} b_i$。不难验证 $\oplus$ 运算满足结合律和交换律。

给出一张 $n$ 个点 $m$ 条边的无向图，每一条边的权值是一个 $w$ 位二进制数（即小于 $2^w$ 的非负整数）。请你找一棵原图的生成树。设你找出的生成树中的边边权分别为 $v_1,\cdots,v_{n-1}$，请你最大化 $v_1\oplus v_2\oplus\cdots\oplus v_{n-1}$。

## 说明/提示

### 关于数据

由于一些原因，数据只保留了最后 $20$ 个点。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
3 3
^
1 2 1
2 3 1
1 3 0```

### 输出

```
1```

# 题解

## 作者：AzusaCat (赞：12)

首先，这不是一道最优化题，这是一道计数题，如果对每个 $i$，我们求出权值为 $i$ 的生成树的数量，那么答案就是最大的生成树数量不为 $0$ 的 $i$。

那么问题就转化成了：求权值为 $i$ 的生成树数量。

首先矩阵树定理是少不了的，我们知道，矩阵树定理实际上求的是

$$
\sum\limits_{T}\prod_{e\in T}w_{Te}
$$
注意到这个 $\prod$，它不一定非得是数相乘，只要保证 $<W,+,\times>$ 构成一个环，那么这个式子就成立。其中 $W$ 是边权所在的全集。

所以我们可以对于每一条边构造一个集合幂级数 $f_v=x^{v}$，乘法定义为输入的集合卷积（如果这一位为或，这一位就是集合或卷积，其它同理），这样求出的行列式的 $x^v$ 项的系数就是权值为 $v$ 的生成树个数。（集合幂级数形成了一个交换环）

具体实现我们注意到 FWT 是线性变换，所以我们一开始先把矩阵做好 FWT，求完行列式再 IFWT 回去，而且直接求生成树的数量太大，我们可以对大质数取模，复杂度是 $O(n^32^w)$，信仰跑吧。关于集合卷积如何按位做不明白的可以看代码。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll const p=1e9+7,inv=500000004;
int n,m,w;
ll mat[75][75][4097],r[75][75],c[4097];
string str;
ll mod(ll x){return x>=p?x-p:x;}
ll pw(ll x,ll y)
{
    ll res=1;
    while(y)
    {
        if(y&1)res*=x,res%=p;
        x*=x,x%=p;
        y>>=1;
    }
    return res;
}
void fwt(ll *f,int n,int op)
{
    for(int len=2,b=0;len<=n;len<<=1,b++)
    {
        int q=(len>>1);
        if(str[b]=='|')
        {
            for(int i=0;i<n;i+=len)
                for(int j=i;j<i+q;j++)
                    if(op==1)f[j+q]=mod(f[j+q]+f[j]);
                    else f[j+q]=mod(f[j+q]+p-f[j]);
        }
        else if(str[b]=='&')
        {
            for(int i=0;i<n;i+=len)
                for(int j=i;j<i+q;j++)
                    if(op==1)f[j]=mod(f[j]+f[j+q]);
                    else f[j]=mod(f[j]+p-f[j+q]);
        }
        else
        {
            for(int i=0;i<n;i+=len)
                for(int j=i;j<i+q;j++)
                {
                    f[j]=mod(f[j]+f[j+q]);
                    f[j+q]=(f[j]-2*f[j+q]+2*p)%p;
                    if(op==-1)f[j]*=inv,f[j]%=p,f[j+q]*=inv,f[j+q]%=p;
                }
        }
    }
}
ll det()
{
    ll ans=1;
    for(int i=1;i<n;i++)
    {
        for(int j=i+1;j<n;j++)
            if((!r[i][i])&&r[j][i]){ans=p-ans,swap(r[i],r[j]);break;}
        if(!r[i][i])return 0;
        ll t=pw(r[i][i],p-2);
        for(int j=i+1;j<n;j++)
        {
            ll t2=t*r[j][i]%p;
            for(int k=i;k<n;k++)
                r[j][k]=mod(r[j][k]-t2*r[i][k]%p+p);
        }
    }
    for(int i=1;i<n;i++)ans*=r[i][i],ans%=p;
    return ans;
}
int main()
{
    int x,y,v;
    scanf("%d%d",&n,&m);
    cin>>str;
    w=str.size();
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&v);
        mat[x][y][v]--,mat[y][x][v]--;
        mat[x][x][v]++,mat[y][y][v]++;
    }
    for(int i=1;i<n;i++)
        for(int j=1;j<n;j++)
        {
            for(int k=0;k<(1<<w);k++)
                if(mat[i][j][k]<0)mat[i][j][k]+=p;
        }
    for(int i=1;i<n;i++)
        for(int j=1;j<n;j++)
            fwt(mat[i][j],(1<<w),1);
    for(int i=0;i<(1<<w);i++)
    {
        memset(r,0,sizeof(r));
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++)
                r[j][k]=mat[j][k][i];
        c[i]=det();
    }
    fwt(c,(1<<w),-1);
    for(int i=(1<<w)-1;i>=0;i--)
        if(c[i]){printf("%d",i);return 0;}
    puts("-1");
    return 0;
}
```


---

## 作者：lhm_ (赞：4)

对于一种权值的生成树的存在性，可以将其转化为该权值的生成树个数的计数问题。

先考虑运算若不是位运算，是加法的情况，要怎么处理。对于边权为 $v$ 的一条边，将其边权赋为 $x^v$，然后应用矩阵树定理，若所得行列式的第 $i$ 次项系数不为 $0$，即生成树个数不为 $0$，就说明存在边权和为 $i$ 的生成树。

同样，对于位运算也是适用的。分别考虑每种边权，对于每种边权都构造出基尔霍夫矩阵，沃尔什变换后求解行列式，然后记录每种边权求得的行列式的值，对其逆沃尔什变换后即为答案。

因为每一位的位运算类型不同，所以沃尔什变换时要考虑每一位的类型，应用对应的变换。在应用矩阵树定理时还需模一个大质数。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 75
#define maxv 5010
#define p 998244353
#define inv2 499122177
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,w,all;
ll t[maxn][maxn][maxv],a[maxn][maxn],ans[maxv];
char s[maxn];
void FWT(ll *a,int type)
{
    for(int len=1,pos=1;len<all;len<<=1,++pos)
    {
        for(int i=0;i<all;i+=len<<1)
        {
            for(int j=i;j<i+len;++j)
            {
                if(s[pos]=='|') a[j+len]=(a[j+len]+a[j]*type+p)%p;
                if(s[pos]=='&') a[j]=(a[j]+a[j+len]*type+p)%p;
                if(s[pos]=='^')
                {
                    ll x=a[j],y=a[j+len];
                    a[j]=(x+y)%p,a[j+len]=(x-y+p)%p;
                    if(type!=1) a[j]=a[j]*inv2%p,a[j+len]=a[j+len]*inv2%p;
                }
            }
        }
    }
}
ll qp(ll x,ll y)
{
    ll v=1;
    while(y)
    {
        if(y&1) v=v*x%p;
        x=x*x%p,y>>=1;
    }
    return v;
}
ll det()
{
    ll v=1;
    for(int i=1;i<n;++i)
    {
        int pos=i;
        for(int j=i+1;j<n;++j)
        {
            if(a[j][i])
            {
                pos=j;
                break;
            }
        }
        if(pos!=i) swap(a[i],a[pos]),v*=-1;
        if(!a[i][i]) return 0;
        ll inv=qp(a[i][i],p-2);
        for(int j=i+1;j<n;++j)
        {
            ll d=a[j][i]*inv%p;
            for(int k=i;k<n;++k)
                a[j][k]=(a[j][k]-a[i][k]*d%p+p)%p;
        }
        v=v*a[i][i]%p;
    }
    return v;
}
int main()
{
    read(n),read(m);
    scanf("%s",s+1),w=strlen(s+1),all=1<<w;
    for(int i=1;i<=m;++i)
    {
        int x,y,v;
        read(x),read(y),read(v);
        t[x][x][v]++,t[y][y][v]++;
        t[x][y][v]--,t[y][x][v]--;
    }
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            FWT(t[i][j],1);
    for(int k=0;k<all;++k)
    {
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                a[i][j]=t[i][j][k];
        ans[k]=det();
    }
    FWT(ans,-1);
    for(int i=all-1;i>=0;--i)
    {
        if(ans[i])
        {
            printf("%d",i);
            return 0;
        }
    }
    puts("-1");
    return 0;
}
```

---

## 作者：hs_black (赞：3)

## 解题思路

大佬做题不证明，蒟蒻看着很难受，因此写一下这篇题解给一些简单的正确性证明

神仙题，首先这题不是最优化题而是数数题，我们算出权值为 k 的生成树个数，如果不为零就可能是答案

生成树计数就看矩阵树定理，矩阵树定理在边权为环的情况下成立，而集合幂级数构成了一个环，加法就是对应相加，乘法就是卷积

先假设所有运算符都是异或

求解行列式我们直接暴力阶乘算法，发现只含有乘法和加法，乘法的时候又是先 FWT 一遍然后点值对应相乘最后再加起来，我们发现每个点值互不影响，所以我们直接分别对每个点值求行列式，这样就可以高斯消元了

现在运算符更加的丰富，你可以将 FWT 看成将 $2^n$ 个向量代入求得点值的过程，那么每一位又是独立的，所以我们对应的算用对应的 FWT 即可，看代码就知道具体实现了，如果想要理解为什么是这样的可以看看我[这篇文章](https://www.cnblogs.com/Hs-black/p/13408474.html)，或者去翻论文，虽然也不是很好懂（不知道为什么 UOJ 自测调试 1.7s，loj 却要 4s 都不够

```cpp
#pragma GCC optimize(2)
#include <queue>
#include <vector>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define MP make_pair
#define ll long long
#define fi first
#define se second
using namespace std;

template <typename T>
void read(T &x) {
    x = 0; bool f = 0;
    char c = getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;
    for (;isdigit(c);c=getchar()) x=x*10+(c^48);
    if (f) x=-x;
}

template<typename F>
inline void write(F x, char ed = '\n')
{
	static short st[30];short tp=0;
	if(x<0) putchar('-'),x=-x;
	do st[++tp]=x%10,x/=10; while(x);
	while(tp) putchar('0'|st[tp--]);
	putchar(ed);
}

template <typename T>
inline void Mx(T &x, T y) { x < y && (x = y); }

template <typename T>
inline void Mn(T &x, T y) { x > y && (x = y); }

const int N = 75;
const int Ww = 5048;
const int P = 998244353;
const int inv2 = (P + 1) / 2;
ll e[N][N][Ww], w, n, m, W;
char op[N];
void exFwt(ll *f, int ty) {
	for (int i = 1, t = 1;t <= w; t++, i <<= 1) 
		for (int j = 0;j < W; j += (i << 1)) 
			for (int k = 0;k < i; k++) {
				if (op[t] == '|') f[i+j+k] = (f[i+j+k] + ty * f[j+k] + P) % P;
				else if (op[t] == '&') f[j+k] = (f[j+k] + ty * f[i+j+k] + P) % P;
				else {
					ll x = f[j+k], y = f[i+j+k];
					f[j+k] = (x + y) % P, f[i+j+k] = (x - y + P) % P;
					if (ty == -1) f[j+k] = f[j+k] * inv2 % P,
								f[i+j+k] = f[i+j+k] * inv2 % P;
				}
			}
}

ll M[N][N];

ll fpw(ll x, ll mi) {
	ll res = 1;
	for (; mi; mi >>= 1, x = x * x % P)
		if (mi & 1) res = res * x % P;
	return res;
}

ll Mat(void) {
	ll ans = 1;
	for (int i = 1;i < n; i++) {
		for (int j = i;j < n; j++) {
			if (M[j][i]) {
				if (j == i) break;
				ans = P - ans;
				for (int k = i;k < n; k++) swap(M[i][k], M[j][k]);
				break;
			}
		}
		ans = ans * M[i][i] % P;
		if (!ans) return ans; ll inv = fpw(M[i][i], P - 2);
		for (int j = i;j < n; j++) M[i][j] = M[i][j] * inv % P;
		for (int j = i + 1;j < n; j++) {
			ll t = P - M[j][i];
			for (int k = i;k < n; k++)
				M[j][k] = (M[j][k] + t * M[i][k]) % P;
		}
	}
	return ans;
}

ll f[Ww];
int main() {
	read(n), read(m), scanf ("%s", op + 1);
	w = strlen(op + 1); W = 1 << w;
	for (int i = 1, x, y, v;i <= m; i++) {
		read(x), read(y), read(v);
		e[x][y][v]--, e[y][x][v]--;
		e[x][x][v]++, e[y][y][v]++;
	}
	for (int i = 1;i <= n; i++)
		for (int j = 1;j <= n; j++)
			exFwt(e[i][j], 1);
	for (int i = 0;i < W; i++) {
		for (int j = 1;j <= n; j++) 
			for (int k = 1;k <= n; k++)
				M[j][k] = e[j][k][i];
		f[i] = Mat(); 
	}
	exFwt(f, -1);
	for (int i = W - 1;i >= 0; i--)
		if (f[i] != 0) return write(i), 0;
	return write(-1), 0;
}
```





---

## 作者：i207M (赞：3)

~~论出题人czy不会做自己的题~~

~~woc，这jb题写了我一下午！卡常，然后我因为对负数取模，挂了好几次！！！中间LOJ还挂了！~~

哇，又一次开拓眼界了。

首先，如果我们能对每种最终权值，求出生成树个数，那么我们取最大的就好。

咋算呢？位运算启发我们使用FWT。我们记$f[x][y][v]$表示只考虑权值为v的边的基尔霍夫矩阵，对于每个$x,y$，把第三维FWT一下。

然后，对于每个权值v，把它的基尔霍夫矩阵的行列式求出来，把这个新数组FWT回去就是我们要求的。

这里说的FWT是广义的FWT，如果这一位是|,&，就高维前/后缀和；是^就是FFT。

---

## 作者：TianTian2008 (赞：1)

首先，我们不要被题目重新定义的位运算吓住了。虽然是重新定义的，但运算时每一位之间还是独立的，那么它跟传统位运算就没有本质区别。

然后发现是对图上的生成树进行计数，往矩阵树定理方向考虑。生成树的权值是边权和，可以套路地把边权设成 GF，这样加和就被转换成了乘积。

接下来我们考虑如何在这个新定义的位运算下做卷积。事实上，我们 FWT 时就是每一位独立分治的，所以每一位分治时使用不同的变换也是可行的。没懂的话看一眼代码就懂了。

最后我们考虑如何对一个元素是多项式的矩阵求行列式。一个经典 trick：因为进行 FFT,FWT 之类变换后的乘法是对应点值相乘，所以不同点值之间是独立的，可以把同一位点值的矩阵拿出来求行列式再合并成答案多项式的点值。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define mod 998244353
using namespace std;
typedef long long ll;
ll n,m,a[71][71][4096],b[71][71];
char s[20];
const ll C[][2][2]={{{0,1},{1,1}},{{1,0},{1,1}},{{1,1},{1,-1}}},iC[][2][2]={{{-1,1},{1,0}},{{1,0},{-1,1}},{{499122177,499122177},{499122177,-499122177}}};
void fwt(ll *f) {
	for(int mid=1,p=1;mid<m;mid<<=1,++p) {
		ll len=mid<<1,id=s[p]=='&'?0:s[p]=='|'?1:2;
		for(int i=0;i<m;i+=len)
			for(int j=0;j<mid;++j) {
				ll f0=f[i+j],f1=f[i+j+mid];
				f[i+j]=(f0*C[id][0][0]+f1*C[id][0][1])%mod;
				f[i+j+mid]=(f0*C[id][1][0]+f1*C[id][1][1])%mod;
			}
	}
}
void ifwt(ll *f) {
	for(int mid=1,p=1;mid<m;mid<<=1,++p) {
		ll len=mid<<1,id=s[p]=='&'?0:s[p]=='|'?1:2;
		for(int i=0;i<m;i+=len)
			for(int j=0;j<mid;++j) {
				ll f0=f[i+j],f1=f[i+j+mid];
				f[i+j]=(f0*iC[id][0][0]+f1*iC[id][0][1])%mod;
				f[i+j+mid]=(f0*iC[id][1][0]+f1*iC[id][1][1])%mod;
			}
	}
}
ll ksm(ll x,ll y) {
	ll res=1;
	while(y) {
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
ll calc() {
	ll res=1;
	for(int i=1;i<n;++i) {
		if(!b[i][i]) {
			ll id=0;
			for(int j=i+1;j<n;++j)
				if(b[j][i]) id=j;
			if(!id) return 0;
			res=-res;
			for(int j=i;j<n;++j) swap(b[i][j],b[id][j]);
		}
		ll d=ksm(b[i][i],mod-2);
		for(int j=i+1;j<n;++j) {
			ll t=b[j][i]*d%mod;
			for(int k=i;k<n;++k) b[j][k]=(b[j][k]-b[i][k]*t)%mod;
		}
	}
	for(int i=1;i<n;++i) res=res*b[i][i]%mod;
	return res;
}
int main() {
	scanf("%lld%lld%s",&n,&m,s+1);
	ll u,v,w;
	while(m--) {
		scanf("%lld%lld%lld",&u,&v,&w);
		++a[u][u][w];
		++a[v][v][w];
		--a[u][v][w];
		--a[v][u][w];
	}
	m=1<<strlen(s+1);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j) fwt(a[i][j]);
	for(int i=0;i<m;++i) {
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k) b[j][k]=a[j][k][i];
		a[0][0][i]=calc();
	}
	ifwt(a[0][0]);
	for(int i=m-1;i>=0;--i)
		if(a[0][0][i]) {
			printf("%d",i);
			return 0;
		}
	puts("-1");
	return 0;
}
```

---

## 作者：MoonPie (赞：1)

# [THUPC2019]找树

## 题意

对于 $w$ 位二进制数，定义一种新的位运算 $\oplus$​：每一位是 and、or、xor 的一种。

给出一张 $n$ 个点 $m$ 条边的图。请你找一棵原图的生成树。设你找出的生成树中的边边权分别为 $v_1,\cdots,v_{n-1}$。请你最大化 $v_1\oplus v_2\oplus\cdots\oplus v_{n-1}$​。
$$
1\le n\le 70,1\le m\le 5000,1\le w \le 12
$$

## 题解

先不要考虑“新的位运算”，如果就是加法，怎么做？

矩阵树定理中，生成树的权值是所有边权的**乘积**。如果一个边权为 $w$ 的边变成形式幂级数 $x^w$，那么矩阵中的每一项都是一个多项式。最后算出来的行列式也是一个多项式，并且其第 $k$ 项系数就是权值为 $k$ 的生成树的个数。这样我们就将最值问题转化为计数问题。

然后，使用 $FWT$ 就可以了，每一位用对应的变换系数即可。

真就可以了吗？我们会发现一个很棘手的问题，如果直接带着多项式做高斯消元求行列式的话，我们**无法恰好消掉一整个多项式**。但事实上我们可以，先对每一位做一次 $FWT$，然后**按位**求出多项式每一位的行列式，然后在 $IFWT$ 回去。

即，
$$
IFWT(\det(FWT(T))) = \det(T)
$$
说人话就是多项式的行列式的每一项可以独立算。

证明如下：
$$
\begin{aligned}
\det(T) &= \sum(-1)^{cnt(p)}\prod_{j=1}^{n} T_{j,p_j}
\\&=\sum(-1)^{cnt(p)}IFWT\left(\sum_{i}^{}x^{i}\prod_{j} FWT(T_{j,p_j})[x^{i}]\right)
\\&=IFWT\left(\sum (-1)^{cnt(p)}\sum_{i}^{}x^{i}\prod_{j} FWT(T_{j,p_j})[x^{i}]\right)
\\\\
\\FWT(\det(T))&=\sum (-1)^{cnt(p)}\sum_{i}^{}x^{i}\prod_{j} FWT(T_{j,p_j})[x^{i}]
\\&=\det(FWT(T))
\\\\
\\IFWT(\det(FWT(T)))&=IFWT(FWT(\det(T)))
\\&=\det(T)
\end{aligned}
$$

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353, inv2 = 499122177;
template<class T> void Plus(T &x, T y) { x = (x + y) % mod; }
int qpow(int x,int y=mod-2)
{
	int res = 1;
	for (int i = 0; (y>>i) > 0; ++i, x = 1ll*x*x%mod)
	 if (y>>i&1) res = 1ll * res * x % mod;
	return res;
}

const int c[3][2][2][2] = {{{{1,1},{0,1}},{{1,-1},{0,1}}},{{{1,0},{1,1}},{{1,0},{-1,1}}},{{{1,1},{1,-1}}, {{inv2,inv2},{inv2,mod-inv2}}}};
const int N = 71, W = 12;
int n,m,w;
string o;
int q[15];

struct POLY
{
	int f[1<<W];
	POLY() { memset(f,0,sizeof(f)); }
	int& operator[](int x) { return f[x]; }
	void FWT(int op)  // 0 是DFT，1是IDFT
	{
		for (int l = 0; l < w; ++l)
		{
			int len = (1<<l);
			for (int i = 0; i < (1<<w); i += len+len)
				for (int j = i; j < i+len; ++j)
				{
					int sav = f[j];
					f[j] = (1ll*f[j]*c[q[l]][op][0][0] + 1ll*f[j+len]*c[q[l]][op][0][1]) % mod;
					f[j+len] = (1ll*sav*c[q[l]][op][1][0] + 1ll*f[j+len]*c[q[l]][op][1][1]) % mod;
				}
		}
	}
}T[N][N], ans;

int a[N][N];
int det()
{
	int res = 1;
	for (int i = 2; i <= n; ++i)
	{
		for (int j = i; j <= n; ++j) if (!a[i][i] && a[j][i]) 
			{swap(a[i], a[j]); res = -res; break;}

		int p = qpow(a[i][i]);
		for (int j = i+1; j <= n; ++j)
		{
			int t = 1ll * a[j][i] * p % mod;
			for (int k = 1; k <= n; ++k) 
				a[j][k] = (a[j][k] - 1ll * a[i][k] * t % mod + mod) % mod;
		}
	}
	for (int i = 2; i <= n; ++i) res = 1ll * res * a[i][i] % mod;
	return (res + mod) % mod;
}

int main()
{
	cin >> n >> m;
	cin >> o; w = o.length();
	for (int i = 0; i < w; ++i) 
	{
		if (o[i] == '&') q[i] = 0;
		if (o[i] == '|') q[i] = 1;
		if (o[i] == '^') q[i] = 2;
	}
	for (int i = 1, u, v, w; i <= m; ++i)
	{
		cin >> u >> v >> w;
		T[u][u][w]++; T[v][v][w]++;
		T[u][v][w]--; T[v][u][w]--;
	}

	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
		{
			T[i][j].FWT(0);
			for (int k = 0; k < (1<<w); ++k) {
				T[i][j][k] = (T[i][j][k] + mod) % mod;
			}
		}

	for (int p = 0; p < (1<<w); ++p)
	{
		for (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j)
			a[i][j] = T[i][j][p];
		ans[p] = det();
	}
	
	ans.FWT(1);

	for (int i = (1<<w)-1; i>=0; --i)
		if (ans[i]) {cout << i << endl; return 0;}
	puts("-1");
	
	return 0;
}
```

---

## 作者：lprdsb (赞：0)

### 题意

- 给定一个无向图，定义一个生成树的权值为按位$\oplus_{o_i}$的结果
- 求最大的生成树

先将问题转化一下，把求最大的生成树，转化为存不存在某个权值的生成树，于是就可以利用$matrix-tree$定理求出某个权值的生成树的个数，但这里的边权可以先按照$\oplus_{o_i}$的规则fwt一下，最后再将行列式的值ifwt回来

```cpp
#include<bits/stdc++.h>
#define For(i, a, b) for(int i = (a), en = (b); i <= en; ++i)
#define Rof(i, a, b) for(int i = (a), en = (b); i >= en; --i)
#define Tra(u, i) for(int i = hd[u]; ~i; i = e[i].net)
#define cst const
#define LL long long
#define DD double
#define LD long double
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define inf 0x3f3f3f3f
#define Inf 0x3f3f3f3f3f3f3f3f
#define eps 1e-12
#define mod 998244353
#define maxn 70
using namespace std;

int n, m, w, a[maxn + 5], lim, inv2;
int fp(int x, int y){
	int asi = 1;
	while(y){
		if(y & 1) asi = 1ll * asi * x % mod;
		x = 1ll * x * x % mod;
		y >>= 1;
	}
	return asi;
}
struct Pol{
	int x[4096];
	void out(){
		For(i, 0, lim - 1) cout << x[i] << " ";
		cout << endl;
	}
	void fwt(int ty){
		for(int i = 2, now = 0; i <= lim; i <<= 1, now++){
			int ii = i >> 1;
			for(int j = 0; j < lim; j += i){
				For(p, j, j + ii - 1){
					if(!ty){
						int tem = x[p], tem1 = x[p + ii];
						if(a[now] == 0)	x[p] = (tem + tem1) % mod;
						if(a[now] == 1) x[p + ii] = (tem + tem1) % mod;
						if(a[now] == 2){
							x[p] = (tem - tem1 + mod) % mod;
							x[p + ii] = (tem + tem1) % mod;
						}
					}
					else{
						int tem = x[p], tem1 = x[p + ii];
						if(a[now] == 0) x[p] = (tem - tem1 + mod) % mod;
						if(a[now] == 1) x[p + ii] = (tem1 - tem + mod) % mod;
						if(a[now] == 2){
							x[p] = 1ll * inv2 * (tem + tem1) % mod;
							x[p + ii] = 1ll * inv2 * (tem1 - tem + mod) % mod;
						}
					}
				}
			}
		}
	}
} zer;
Pol operator + (cst Pol &x, cst Pol &y){Pol asi; For(i, 0, lim - 1) asi.x[i] = (x.x[i] + y.x[i]) % mod; return asi;}
Pol operator - (cst Pol &x, cst Pol &y){Pol asi; For(i, 0, lim - 1) asi.x[i] = (x.x[i] - y.x[i] + mod) % mod; return asi;}
Pol operator * (cst Pol &x, cst Pol &y){Pol asi; For(i, 0, lim - 1) asi.x[i] = 1ll * x.x[i] * y.x[i] % mod; return asi;}
Pol operator / (cst Pol &x, cst Pol &y){Pol asi; For(i, 0, lim - 1) asi.x[i] = 1ll * x.x[i] * fp(y.x[i], mod - 2) % mod; return asi;}
bool operator ! (cst Pol &x){For(i, 0, lim - 1) if(x.x[i]) return 0; return 1;}
struct Mat{
	Pol x[maxn + 5][maxn + 5];
	Pol get_det(){
		int k = 0;
		Pol asi;
		For(i, 0, lim - 1) asi.x[i] = 1;
		For(i, 1, n - 1){
			if(!x[i][i]){
				k++;
				For(j, i + 1, n - 1){
					if(!x[j][i]) continue;
					For(p, i, n - 1) swap(x[i][p], x[j][p]);
					break;
				}
			}
			if(!x[i][i]) return zer;
			asi = asi * x[i][i];
			For(j, i + 1, n - 1){
				Pol tem = x[j][i] / x[i][i];
				For(p, i, n - 1) x[j][p] = x[j][p] - tem * x[i][p];
			}
		}
		if(k & 1) For(i, 0, lim - 1) asi.x[i] = mod - asi.x[i];
		return asi;
	}
} ma;

template <class T>
void read(T &x){
	char ch;
	bool ok;
	for(ok = 0, ch = getchar(); !isdigit(ch); ch = getchar()) if(ch == '-') ok = 1;
	for(x = 0; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());
	if(ok) x = -x;
}

char s[maxn + 5];
int main(){
	//freopen("19.in", "r", stdin);
	inv2 = fp(2, mod - 2);
	read(n); read(m);
	scanf("%s",s); w = strlen(s);
	For(i, 0, w - 1){
		if(s[i] == '|') a[i] = 1;
		if(s[i] == '^') a[i] = 2;
	}
	lim = 1 << w;
	For(i, 1, m){
		int u, v, wi; read(u); read(v); read(wi);
		ma.x[u][v].x[wi]--;
		ma.x[v][u].x[wi]--;
		ma.x[u][u].x[wi]++;
		ma.x[v][v].x[wi]++;
	}
	For(i, 1, n - 1) For(j, 1, n - 1){
		if(i ^ j) For(p, 0, lim - 1) ma.x[i][j].x[p] = (ma.x[i][j].x[p] + mod) % mod;
		ma.x[i][j].fwt(0);
	}
	Pol tem = ma.get_det();
	tem.fwt(1);
	Rof(i, lim - 1, 0) if(tem.x[i]){printf("%d\n", i); return 0;}
	puts("-1");
	return 0;
}
```



---


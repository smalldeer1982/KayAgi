# [THUPC 2018] 好图计数

## 题目背景

这道题目非常简单，它甚至没有题目背景、没有任何故事。

但为了能让你顺利理解题目，善良的 Yazid 将为你介绍一些概念。

* 简单图：不存在重边、自环的图。（重边即为两条完全相同的边，自环即为两端点为同一节点的边）

* 补图：一个图 $G$ 的补图有与 $G$ 完全相同的节点，且任意两点之间有边当且仅当他们在 $G$ 中不相邻。

## 题目描述

我们归纳定义一个无向简单图是**好的**：

1. 一个单点是好的。

2. 若干个好的图分别作为联通块所形成的图是好的。

3. 一个好的图的补图是好的。

给定一个正整数 $n$。

求 $n$ 个点的本质不同的好的图的数量对质数 $P$ 取模的结果。（这里的 $P$ 是一个常数，具体见【输入格式】）

两个好的图的被认为是**本质不同的**，当且仅当无论如何将一个图重标号，它都不能与另一个图完全相同。

## 说明/提示

### 样例解释

下面是 $3$ 个点的所有好的图：

![](https://i.loli.net/2018/05/14/5af990dbcfbc0.png)

### 数据范围

保证 $T\leq 233$，$n\leq 23333$，$2^{29} < P < 2^{30}$ 且保证 $P$ 为质数。

### 提示

能够通过本题的算法的时间复杂度可能比你想象的要糟糕一些、也可能比你想象的要优秀一些。

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
2 233
3
4```

### 输出

```
4
10```

# 题解

## 作者：b2019dy (赞：9)

我们可以得出一个结论，联通好图的不图只会是非联通好图，非联通好图的不图只会是联通好图

这个结论是怎么来的呢

若干个好图作为联通块形成的好图显然是非联通好图，也就是我们没有不通过补图构成联通好图的手段，所以联通好图的补图不可能是联通好图

而非联通好图的补图一定为联通好图，这是显然的

我们设$f_n$表示n个点好图数量，$g_n$表示n个点联通好图数量

$$f_n=2*g_n$$

我们可以先拿到这样一个结论

EGF貌似没有办法搞，我们考虑从实际意义出发来写出他的生成函数

$$F(x)=\prod_{k>0}(\sum_{i>0} x^{ik})^{g_k}$$

$$
F(x)=\prod_{k>0}(1-x^k)^{-g_k}
$$

什么意思呢，我们考虑将若干个联通好图拼在一起

我们需要现在点数中选择一种，然后需要在点数为k的联通好图中选择一种形状，然后再选择该形状的联通好图数量，点数就是ik，为什么不用乘以2呢，因为联通好图也可以看作是一个好图拼起来的，所以他同时包含了联通好图与非联通好图的所有情况

我们难以求出累乘，于是我们对两边求ln

$$
\ln(F(x))=-\sum g_k \ln(1-x^k)
$$

再求个导

$$
\frac{F'(x)}{F(x)}=\sum g_k\frac{kx^{k-1}}{1-x^k}
$$

$$
F'(x)=F(x)\sum g_k\frac{kx^{k-1}}{1-x^k}
$$

$$
(n+1)f(n+1)=\sum_{i=0}^n f(i)[x^{n-i}]\sum kg_k\frac{x^{k-1}}{1-x^k}
$$

因为

$$
\frac{x^{k-1}}{1-x^k}=\sum_{i=1}x^{ik-1}
$$

所以上面式子仅当  k|(n+1)时有值

$$(n+1)f(n+1)=\sum_{i=0}^n f(i)\sum_{k|(n-i+1)}kg_k$$

我们把n+1，换成n

$$nf(n)=\sum_{i=0}^{n-1} f(i)\sum_{k|(n-i)}kg_k$$

这个式子就可以进行暴力递推了，我们就可以进行n^2做法

然后卡卡常就能过了

当然这个式子可以写成自卷积形式，写成自卷积形式后就可以$O(nlogn^2)$
```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
int t,p,n;
long long f[50005],g[50005],sum[50005];
long long ksm(long long x,int n)
{
	long long ans=1;
	while(n)
	{
		if(n&1) ans=ans*x%p;
		x=x*x%p;
		n>>=1;
	}
	return ans;
}
int main()
{
	scanf("%d%d",&t,&p);
	f[0]=f[1]=1,g[1]=1;
	f[2]=2,g[2]=1;
	for(int i=1;i<=23333;i++) sum[i]=1;
	for(int i=2;i<=23333;i+=2) sum[i]+=2;
	for(long long i=3;i<=23333;i++)
	{
		__int128 tmp=0;
		for(int j=0;j<i;j++) tmp+=f[j]*sum[i-j];
		tmp%=p;
		g[i]=tmp*ksm(i,p-2)%p;
		f[i]=g[i]*2%p;
		for(int j=i;j<=23333;j+=i) sum[j]+=tmp,sum[j]%=p;
	}
	while(t--)
	{
		scanf("%d",&n);
		printf("%lld\n",f[n]);
	}
}
```

---

## 作者：_rqy (赞：6)

aaa我不想写代码了（没有NTT模数有点自闭）。

如果 NTT 模数的话可以 $O(n\log n)$ 的，非 NTT 模数...有点慢orz。

我们令 $f_n$ 表示 $n$ 个点的连通好图的个数，规定 $f_0=0$。

答案显然就是 $2f_n$。并且对于一个连通好图，不难发现它的补图一定不是连通的（不然这个好图是怎么构造出来的？）。于是我们构造一个连通好图的方式就是：选择至少两个连通好图，然后把它们拼起来，再取补图。

那么现在我们需要对于每种形态的好图选出若干，可以发现这就是一个完全背包，于是令 $F(x)=\sum_n f_nx^n$，就有

$$
F(x)=x+\prod_{i=1}^{\infty}\left(\frac{1}{1-x^i}\right)^{f_i}-F(x)
$$

为了理解这个例子，我们发现完全背包中一个体积为 $k$ 的物品给答案的贡献是乘上 $1+x^k+x^{2k}+\dots=\frac{1}{1-x^k}$，而大小为 $i$ 的好图有 $f_i$ 个，因此贡献是 $\left(\frac{1}{1-x^k}\right)^{f_i}$。但是我们不能只选出一个，所以我们把只选出一个的方案（$F(x)$）减掉；然后再把唯一的例外即单点图（$x$）加上。

我们随便化一化式子：

$$
\begin{aligned}
2F(x)-x&=\prod_{i=1}^{\infty}\left(\frac{1}{1-x^i}\right)^{f_i}\\
&=\exp\left(\sum_{i=1}^{\infty}f_i\ln\frac{1}{1-x^i}\right)\\
&=\exp\left(\sum_{i=1}^{\infty}f_i\sum_{j=1}^{\infty}\frac{x^{ij}}{j}\right)\\
&=\exp\left(\sum_{j=1}^{\infty}\frac{1}{j}\sum_{i=1}^{\infty}f_ix^{ij}\right)\\
&=\exp\left(\sum_{j=1}^{\infty}\frac{F(x^j)}{j}\right)
\end{aligned}
$$

我们把等式右边记做 $T_F(x)$。那么我们相当于得到了一个关于 $F$ 的方程：

$$
2F(x)-T_F(x)-x=0
$$

考虑对这个东西进行牛顿迭代，即令 $G(F)=2F-T_F-x$。但是令我们不爽的是这里面有 $F(x^2),F(x^3)\dots$ 项。

但是牛顿迭代的时候我们是从前 $n$ 项来计算前 $2n$ 项，但是我们发现 $k\geq2$ 的时候 $F(x^k)$ 的前 $2n$ 项是不依赖 $F$ 的第 $n+1\dots 2n$ 项的，所以可以把 $F(x^2),F(x^3)\dots$ 当做常函数。

于是考虑 $T_F=\exp(F+Q)$，其中 $Q=\sum_{i=2}^{\infty}\frac{F(x^i)}{i}$ 可以看成常函数。于是其对 $F$ 的导数就是它本身（$e^{x+C}$ 导数还是 $e^{x+C}$）。所以 $G$ 对 $F$ 的导数就是 $2-T_F$，单次牛顿迭代的方式就是

$$
F\leftarrow F-\frac{2F-T_F-x}{2-T_F}
$$

计算 $T_F$ 显然是 $O(n\log n)$ 的（里面的 $\sum$ 只有 $n\log n$ 项，暴力算出来跑一遍 $\exp$ 就可以了）。于是对它牛顿迭代就可以了。


---

## 作者：洛水·锦依卫 (赞：4)

# Algorithm

生成函数，$DP$ 。

# Mentality

典型的利用生成函数寻找性质。

根据题目这个奇怪的定义，我们可以得到以下结论：

不难发现，当超过一个点的时候，一个联通图要成为好图，必须依靠条件 $3$ 。

同时，对于一个不联通的图，它的补图一定是个联通图。证明很简单，对于任意两个联通块 $A$ 和 $B$ ，在补图里，$A$ 中的每个点都会向 $B$ 中的每个点连边，则两个联通块自然就联通了。

则我们的联通好图和不联通好图一定可以成对两两互补。

所以设 $f_n$ 为 $n$ 个点的好图个数，$g_n$ 为 $n$ 个点的联通好图个数，则有：$f_n=2g_n$ 。

为了推式子比较方便，我们设 $f_0=1$ 。

不难发现，对于大小为 $k$ 的联通好图，其能够组成的好图方案的生成函数为：

$$
(\sum_i x^{ik})^{g_k}=(1-x^k)^{-g_k}
$$

则我们可以列出 $\{f_n\}$ 的生成函数 $F$ 的式子：

$$
F=\prod_{k} (1-x^k)^{-g_k}
$$

发现右边是 $\prod$ 特别不好搞，于是考虑用 $ln$ 拆成加法，然后再求导去掉 $ln$。

$$
lnF=\sum_k (ln(1-x^k)^{-g_k})
$$
$$
\frac{F'}{F}=\sum_k g_k*k*\frac{x^{k-1}}{1-x^k}
$$
$$
F'=F*\sum_k g_k*k*\frac{x^{k-1}}{1-x^k}
$$

接下来我们要推递推用的式子了：

$$
[x^n]F'=(n+1)f_{n+1}=[x^n]F*(\sum_k g_k*k*\frac{x^{k-1}}{1-x^k})
$$
$$
    =\sum_{i=0}^n f_i*[x^{n-i}](\sum_k g_k*k*\frac{x^{k-1}}{1-x^k})
$$

对于 $\frac{x^{k-1}}{1-x^k}$ 来说，考虑 $\frac{1}{1-x^k}=\sum_{i>=0}x^{ik}$ ，则有：

$$
\frac{x^{k-1}}{1-x^k}=\sum_{i>=1}x^{ik-1}
$$

故可得：

$$
[x^{n-i}](\sum_k g_k*k*\frac{x^{k-1}}{1-x^k})=\sum_{k|(n-i+1)} kg_k
$$

然后我们设 $h_i=\sum_{j|i} j*g_j$

代回原式便有：

$$
(n+1)f_{n+1}=\sum_{i=0}^n f_i * h(n-i+1)
$$

发现由于在计算 $f_0*h(n+1)$ 的时候式中包含未知的 $g_{n+1}=\frac{f_{n+1}}{2}$ ，所以将其移到左边去，则式子变为：

$$
\frac{(n+1)}{2}f_{n+1}=\sum_{i=1}^n f_i * h(n-i+1)+\sum_{k|(n+1),k<n+1} k*g(k)
$$

因为 $O2$ 很猛，直接 $n^2$ 卡常递推就可以过了。

至于怎么卡常……什么 $FastMod$ 加速取模都是假的，真正快到极致的就是不取模，用 $int128$ 省去大量取模，你值得拥有。

# Code

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
#define LL long long
#define go(G, x, i, v) \
  for (int i = G.hd[x], v = G.to[i]; i; v = G.to[i = G.nx[i]])
#define inline __inline__ __attribute__((always_inline))
inline LL read() {
  LL x = 0, w = 1;
  char ch = getchar();
  while (!isdigit(ch)) {
    if (ch == '-') w = -1;
    ch = getchar();
  }
  while (isdigit(ch)) {
    x = (x << 3) + (x << 1) + ch - '0';
    ch = getchar();
  }
  return x * w;
}

const int Max_n = 3e4 + 5;
int T, mod, n;
int f[Max_n], g[Max_n], h[Max_n];

namespace Init {
int ksm(int a, int b = mod - 2) {
  int res = 1;
  for (; b; b >>= 1, a = (LL)a * a % mod)
    if (b & 1) res = (LL) res * a % mod;
  return res;
}
void main() {
  n = 23333;
  for (int i = 1; i <= n; i++) {
    __int128 t = 0;
    for (int j = 1; j < i; j++) t += (LL)f[j] * h[i - j];
    f[i] = 2ll * (f[i] + t % mod) * ksm(i) % mod;
    g[i] = (LL)ksm(2) * f[i] % mod + (i == 1), f[i] += (i == 1);
    for (int j = i; j <= n; j += i) {
      (h[j] += (LL)i * g[i] % mod) %= mod;
      if (j > i) (f[j] += (LL)i * g[i] % mod) %= mod;
    }
  }
}
}  // namespace Init

int main() {
#ifndef ONLINE_JUDGE
  freopen("6389.in", "r", stdin);
  freopen("6389.out", "w", stdout);
#endif
  T = read(), mod = read();
  Init::main();
  while(T--) {
    n = read();
    printf("%d\n", f[n]);
  }
}
```


---

## 作者：Kinandra (赞：2)

#### Part 1

因为**不连通图的补图一定连通**, 所以**不连通的好图**的**补图**一定是**连通好图**.

根据定义可知, 如果一个的大小不为$1$的**连通图**的**补图**是**连通图**, 那么这个图不是好图.

综上有**连通好图的个数**=**不连通好图个数** , 不妨将大小为 $n$ 的**连通好图**的数量设为 $f_n$ , 特别地, 令 $f_0=0$. 

此外, 我们设 $G(x)$ 为**好图**个数的普通生成函数, $g_i=[x^n]G(x)$ .

根据开头提到的性质, $\forall n>1,g_n=2f_n$ .

#### Part 2

根据**好图**是由若干个连通好图组合成的, 有:
$$
\begin {aligned}
G(x)&=\prod_{i=1}^{+\infty}({\sum_{j=0}^{+\infty}x^{ij}})^{f_i}\\
	&=\prod_{i=1}^{+\infty}(1-x^i)^{-f_i}
\end {aligned}
$$
发现指数上的值和 $\prod$ 似乎不好处理, 对等式两边取 $\ln$ :
$$
\ln G(x)=-\sum_{i=1}^{+\infty}f_i\ln(1-x^i)
$$
有 $\ln$ 考虑求导(对 $x$):
$$
{G'(x)\over G(x)}=\sum_{i=1}^{+\infty}f_i{ix^{i-1}\over1-x^i}=\sum_{i=1}^{+\infty}f_i\times ix^{i-1}\sum_{j=0}^{+\infty}{x^{ij}}
$$

#### Part 3

移项:
$$
\begin {aligned}
(n+1)g_{n+1}&=[x^n]G'(x)=\sum_{i=0}^n g_i[x^{n-i}]\sum_{j=0}^{+\infty}f_j\times jx^{j-1}\sum_{k=0}^{+\infty}{x^{jk}}
\end {aligned}
$$
上式中的 $[x^{n-i}]\sum_{j=0}^{+\infty}f_j\times jx^{j-1}\sum_{k=0}^{+\infty}{x^{jk}}$ 不为 $0$ 当且仅当 $\exists k\in\mathbb N,jk+j-1=n-i$, 即 $j|n-i+1$ . 
$$
\begin {aligned}
(n+1)g_{n+1}&=\sum_{i=0}^n g_i\sum_{j|n-i+1}f_j\times j
\end {aligned}
$$

#### Part 4

这个式子可以 $\mathcal O(n^2)$ 递推, 递推过程中顺便更新一下 $h_i=\sum_{i|x}f_i\times i$ 即可. 

注意我们求 $g_{n+1}$ 是会用到 $h_{n+1}$ 的值, 而我们的 $h_{n+1}$ 并没有完全更新好, 所以我们需要把缺少的 $f_{n+1}\times n$ 这一项考虑进去, 由于 $n+1>1$ 时有 $f_{n+1}=\frac 12g_{n+1}$ , 把这一项移到左边即可.

这样的递推显然可以用分治FFT优化, 同样需要在分治树的叶子上更新 $h_i$ , 时间复杂度 $\mathcal O(n\log ^2n)$.

#### Part 5

推完式子兴冲冲地开始码, 定睛一看: ! , 居然不保证 NTT 模数, 8102 年的题居然还卡模数, 顿时心情抑郁.

忽然出题人亲切的提示映入眼帘:

```
能够通过本题的算法的时间复杂度可能比你想象的要糟糕一些、也可能比你想象的要优秀一些。
```

......

我从短暂的人生当中学到一件事 ...... 越是优化复杂度, 就越会发现码力是有极限的. 

**我不写 $\log^2$ 了!JOJO**.(雾

亲测 $O(n^2)$ 卡卡常可过, 美滋滋.



```cpp
#include <bits/stdc++.h>
using namespace std;
int read();

int n, T, mod, inv[30004], g[30004], h[30004];
__int128 f[30004];
int M(int x) { return x >= mod ? x - mod : x; }
void Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }

int main() {
    clock_t c = clock();
    n = 23333, T = read(), mod = read(), f[1] = inv[1] = g[0] = g[1] = h[1] = 1;
    for (int i = 2; i <= n; ++i)
        h[i] = 1, inv[i] = mod - 1ll * (mod / i) * inv[mod % i] % mod;
    for (int i = 2; i <= n; ++i) {
        for (int j = 0; j < i; ++j) f[i] += 1ll * g[j] * h[i - j];
        f[i] = f[i] % mod * inv[i] % mod, g[i] = M(f[i] << 1);
        for (int j = i, t = 1ll * f[i] * i % mod; j <= n; j += i) Add(h[j], t);
    }
    for (int i = 2; i <= n; ++i) f[i] = M(f[i] << 1);
    while (T--) printf("%d\n", (int)f[read()]);
    return 0;
}

int read() {
    int x = 0;
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x;
}
```



---

## 作者：飞雨烟雁 (赞：2)

**原题链接**：[P5448 [THUPC2018]好图计数](https://www.luogu.com.cn/problem/P5448)。

建议做过此题再看本题解：[P5900 无标号无根树计数](https://www.luogu.com.cn/problem/P5900)。

------------

首先可以发现，**好图**可以分为两种，一种是由多于一个好图组成的（非连通图），另一种是前者的补图（连通图）。

不妨设一个单点属于第二种好图，并记第一种好图的 OGF 为 $F(x)$，第二种好图的 OGF 为 $G(x)$，那么总的好图的 OGF 就是 $F(x)+G(x)$。

根据「一个好的图的补图是好的」这个规则，我们可以得到：$F(x)+x=G(x)$，加上 $x$ 是因为我们规定了单点属于第二种好图。

紧接着，我们发现任意一个好图一定是由一个或多个第二种好图凑在一起得到的。在图无标号的情况下，我们可用 **Euler 变换**来描述好图的组合意义。

（关于 Euler 变换，可看该题第一篇题解：[P5900 无标号无根树计数 题解](https://www.luogu.com.cn/problem/solution/P5900)）

因此我们得到了第二条表达式：

$$G(x)+F(x)=\text{Euler}(G(x))-1$$

减一是因为 Euler 变换会把一个点都没有的图计入在内。

两式联立得：

$$2G(x)-x+1=\text{Euler}(G(x))$$

Euler 变换的表达式为（设 $g_i=[x^i]G(x)$）：

$$\text{Euler}(G(x))=\prod_{i\ge 1}(1-x^i)^{-g_i}=\exp\Big(\sum_{k\ge 1}\frac {G(x^k)}k\Big)$$

代回原式并两边取对数有：

$$\ln(2G(x)-x+1)=G(x)+\sum_{k\ge2}\frac{G(x^k)}{k}$$

这个形式可以进行牛顿迭代，具体地，我们设：

$$\alpha(x)=\sum_{k\ge 2}\dfrac{G(x^k)}{k}$$

$$H(G)=\ln(2G(x)-x+1)-G(x)-\alpha$$

那么迭代方程就是：

$$G\leftarrow G_0(x)-\dfrac{\ln(2G_0(x)-x+1)-G_0(x)-\alpha}{\frac{2}{2G_0(x)-x+1}-1}$$

这个形式已经可以牛顿迭代了，初始条件是 $G_0(x)=x$。

不过我们可以再进行化简，以降低常数，先设：

$$Q(x)=(2G_0(x)-x+1)^{-1}$$

那么分母就是 $2Q(x)-1$ 了，对于分子的对数部分：

$$
\begin{aligned}
\ln(2G_0(x)-x+1)&=\int \dfrac{2G'_ 0(x)-1}{2G_0(x)-x+1}\,\text dx\\
&=\int (2G'_ 0(x)-1)Q(x)\,\text dx
\end{aligned}
$$

代回迭代方程并通分（公式里面的 $(x)$ 全被我吃了）：

$$
\begin{aligned}
G&= \dfrac{G_0(2Q-1)-\int (2G'_ 0-1)Q\,\text dx+G_0+\alpha}{2Q-1}\\
&= \dfrac{2G_0Q-\int (2G'_ 0-1)Q\,\text dx+\alpha}{2Q-1}
\\
&= \dfrac{\int(2G_0'Q+2G_0Q')\,\text dx-\int (2G'_ 0-1)Q\,\text dx+\alpha}{2Q-1}
\\
&= \dfrac{\int(2G_0Q'+Q)\,\text dx+\alpha}{2Q-1}
\end{aligned}
$$

大功告成！可能有人会问为啥要化成这个样子，明明常数几乎没区别。~~事实上常数确实差不多，主要是这个式子好看~~，另外一个原因是这个拆积分形式的技巧对于某些题确实可以大幅化简式子（参见 [P7439](https://www.luogu.com.cn/problem/P7439) 和 [P8561](https://www.luogu.com.cn/problem/P8561)）。

然后呢？模数又不是 NTT 模数。这简单，模数保证是质数，那上任意模数就好了。

牛迭得到 $G(x)$ 就能求出 $F(x)+G(x)$，然后 $O(1)$ 回答，总时间复杂度是 $O(n\log n+T)$。

------------

```cpp
#include <iostream>
#include <cstring>
#include <cstdio> 
#include <cmath>
#define ll long long
using namespace std;

int Read(){
    int res = 0; char c = getchar();
    while(c < '0' || c > '9') c = getchar();
    while(c >= '0' && c <= '9') res = res * 10 + (c ^ 48), c = getchar();
    return res;
}

void Write(int x){ if(x > 9) Write(x / 10); putchar(48 ^ (x % 10));}

struct Complex{
    double a, b;
    Complex(double _a = 0, double _b = 0){ a = _a, b = _b;}
    Complex Conj(){ return {a, -b};}
    Complex operator + (const Complex &x) const { return {a + x.a, b + x.b};}
    Complex operator - (const Complex &x) const { return {a - x.a, b - x.b};}
    Complex operator * (const Complex &x) const { return {a * x.a - b * x.b, a * x.b + b * x.a};}
    Complex operator += (const Complex &x) { return (*this) = {a + x.a, b + x.b};}
    Complex operator -= (const Complex &x) { return (*this) = {a - x.a, b - x.b};}
    Complex operator *= (const Complex &x) { return (*this) = {a * x.a - b * x.b, a * x.b + b * x.a};}
    void Print(){ printf("%.2lf + %.2lf i\n", a, b);}
}Ftr;

const int MLen = 1 << 16, Mx = MLen + 5;
const double Pi = acos(-1);
int Mod;

Complex URt[Mx]; 
int Eli[Mx];
void PolyInit(int Len = MLen){
    int NLen = Len >> 1;
    URt[NLen] = {1, 0}, Eli[NLen] = Len - 1;
    for(int i = 1; i < NLen; ++i) URt[i | NLen] = {cos(i * Pi / NLen), sin(i * Pi / NLen)};
    for(int i = NLen + 1; i < Len; ++i) Eli[i] = Eli[i - 1] - 1;
    for(int i = NLen - 1; i > 0; --i) URt[i] = URt[i << 1], Eli[i] = Eli[i << 1] >> 1;
}

ll FastPow(ll a, int b){
    ll res = 1;
    while(b){
        if(b & 1) res = res * a % Mod;
        b >>= 1, a = a * a % Mod;
    }
    return res;
}

ll Inv(ll x){ return FastPow(x % Mod, Mod - 2);}

struct Poly{
    Complex F[Mx];
    int Len;
    void DFT(){
        for(int i = Len >> 1; i; i >>= 1)
            for(int j = 0; j < Len; j += (i << 1))
                for(int k = 0; k < i; ++k)
                    Ftr = F[i + j + k],
                    F[i + j + k] = (F[j + k] - Ftr) * URt[k + i],
                    F[j + k] += Ftr;
    }
    void IDFT(){
        for(int i = 1; i < Len; i <<= 1)
            for(int j = 0; j < Len; j += (i << 1))
                for(int k = 0; k < i; ++k)
                    Ftr = F[i + j + k] * URt[i + k],
                    F[i + j + k] = F[j + k] - Ftr,
                    F[j + k] += Ftr;
        for(int i = 1; i < (Len >> 1); ++i) swap(F[i], F[Len - i]);
    }
}MT1, MT2, MT3;

void MTT(const int F[], const int G[], int H[], const int Len){
    MT1.Len = MT2.Len = MT3.Len = Len;
    for(int i = 0; i < Len; ++i)
        MT1.F[i].a = F[i] >> 15, MT1.F[i].b = F[i] & 32767,
        MT3.F[i].a = G[i] >> 15, MT3.F[i].b = G[i] & 32767;

    MT1.DFT(), MT3.DFT();
    for(int i = 0; i < Len; ++i) MT2.F[i] = MT1.F[Eli[i]].Conj();
    for(int i = 0; i < Len; ++i) MT1.F[i] *= MT3.F[i], MT2.F[i] *= MT3.F[i];
    MT1.IDFT(), MT2.IDFT();

    ll t1, t2, t3;
    for(int i = 0; i < Len; ++i){
        MT1.F[i].a /= Len, MT1.F[i].b /= Len, MT2.F[i].a /= Len;
        t1 = (ll)((MT2.F[i].a + MT1.F[i].a) / 2 + 0.5) % Mod;
        t2 = (ll)(MT1.F[i].b + 0.5) % Mod;
        t3 = (ll)((MT2.F[i].a - MT1.F[i].a) / 2 + 0.5) % Mod;
        H[i] = ((((t1 << 15) + t2) << 15) + t3) % Mod;
    }
}

void MTT0(const int F[], int G[], const int Len){
    for(int i = 0; i < Len; ++i) MT1.F[i].a = F[i] >> 15, MT1.F[i].b = F[i] & 32767;
    MT1.DFT();
    for(int i = 0; i < Len; ++i) MT2.F[i] = MT1.F[Eli[i]].Conj();
    for(int i = 0; i < Len; ++i) MT1.F[i] *= MT3.F[i], MT2.F[i] *= MT3.F[i];
    MT1.IDFT(), MT2.IDFT();
    ll t1, t2, t3;
    for(int i = 0; i < Len; ++i){
        MT1.F[i].a /= Len, MT1.F[i].b /= Len, MT2.F[i].a /= Len;
        t1 = (ll)((MT2.F[i].a + MT1.F[i].a) / 2 + 0.5) % Mod;
        t2 = (ll)(MT1.F[i].b + 0.5) % Mod;
        t3 = (ll)((MT2.F[i].a - MT1.F[i].a) / 2 + 0.5) % Mod;
        G[i] = ((((t1 << 15) + t2) << 15) + t3) % Mod;
    }
}

int Inv1[Mx], Inv2[Mx], Inv3[Mx];
void Inverse(int F[], const int Len){
    memset(Inv1, 0, sizeof Inv1), memset(Inv3, 0, sizeof Inv3);
    Inv1[0] = Inv(F[0]);
    for(int i = 2; i <= Len; i <<= 1){
        for(int j = (i >> 1) - 1; j >= 0; --j) Inv3[j] = Inv1[j];
        for(int j = i - 1; j >= 0; --j) Inv2[j] = F[j];
        MTT(Inv2, Inv3, Inv2, i);
        for(int j = (i >> 1) - 1; j >= 0; --j) Inv2[j] = Inv2[j + (i >> 1)], Inv2[j + (i >> 1)] = 0;
        MTT0(Inv2, Inv2, i);
        for(int j = i >> 1; j < i; ++j) Inv1[j] = Mod - Inv2[j - (i >> 1)];
    }
    for(int i = 0; i < Len; ++i) F[i] = Inv1[i];
}

int Pnv[Mx];
void PreInv(){
	Pnv[1] = 1;
	for(int i = 2; i < Mx; ++i) Pnv[i] = Mod - 1ll * (Mod / i) * Pnv[Mod % i] % Mod;
}

int F[Mx];
int Q[Mx], R[Mx], H[Mx], D[Mx];
// Q = (2G - x + 1) ^ (-1)  R = (2Q - 1) ^ (-1)  H = G  D = Q'
void Newton(int Len){
	if(Len == 2){ F[1] = 1; return;}
	int Nen = Len >> 1, Men = Len << 1;
	Newton(Nen);
	Q[0] = Q[1] = 1;
	for(int i = 2; i < Nen; ++i) Q[i] = (F[i] << 1) % Mod;
	for(int i = Nen; i < Len; ++i) Q[i] = 0;
	Inverse(Q, Len);
	R[0] = 1;
	for(int i = 1; i < Len; ++i) R[i] = (Q[i] << 1) % Mod;
	Inverse(R, Len);
	for(int i = 0; i < Nen; ++i) H[i] = F[i];
	for(int i = Nen; i < Len; ++i) H[i] = 0;
	for(int i = 1; i < Len; ++i) D[i - 1] = 1ll * Q[i] * i % Mod; 
	MTT(H, D, H, Men);
	for(int i = 0; i < Len; ++i) H[i] = ((H[i] << 1) % Mod + Q[i]) % Mod;
	for(int i = Len - 1; ~i; --i) H[i] = 1ll * H[i - 1] * Pnv[i] % Mod;
	for(int i = Len; i < Men; ++i) H[i] = 0;
	for(int i = 2; i < Len; ++i){
		for(int j = i, t = 1; j < Len; j += i, ++t){
			H[j] = (H[j] + 1ll * F[t] * Pnv[i]) % Mod;
		}
	}
	MTT(H, R, H, Men);
	for(int i = 0; i < Len; ++i) F[i] = H[i];
}

int main(){
    int T = Read(); Mod = Read();
	PolyInit(), PreInv();
    Newton(32768);
    while(T--){
    	int n = Read();
    	if(n == 1) puts("1");
    	else Write((F[n] << 1) % Mod), putchar('\n');
	}
    return 0; 
}
```

------------

喜提最优解，但是应该没啥人真写任意模数吧……

顺带一提，如果这道题是有标号的好图计数，只需把迭代方程里的 $\alpha(x)$ 扔掉就好了，牛迭出来的是 EGF，乘上阶乘即可。

---

## 作者：_i_i_ (赞：1)

考虑到一个好图一定是由若干个联通好图凑起来的，因此设 $F$ 为好图个数的 OGF，$G$ 为联通好图个数的 OGF，则有 $F(x) = \text{Eular}(G(x))$。

因此有：

$$
F(x)=\prod_{i=1}(1-x^i)^{-G[i]}
$$

两边取 $\ln$ 然后求导可以得到：

$$
\begin{aligned}
\ln F(x)&=\sum_{i=1}-G[i]\ln(1-x^i)\\
\frac{F'(x)}{F(x)}&=\sum_{i=1}\frac{G[i]ix^{i-1}}{1-x^i}\\
F'(x)&=F(x)\sum_{i=1}\frac{G[i]ix^{i-1}}{1-x^i}\\
\end{aligned}
$$

拆开来：

$$
\begin{aligned}
xF[x]&=F'[x-1]\\
&=\sum\limits_{i=0}^{x-1}F[i]\left(\sum\limits_{j=1}\dfrac{G[j]jx^{j-1}}{1-x^j}\right)[x-1-i]
\end{aligned}
$$

观察到 $\dfrac{x^{j-1}}{1-x^j} = \sum\limits_{k=1}x^{jk-1}$，因此只有当 $j|x-i$ 的时候 $x^{x-1-i}$ 的位置才有值。

$$
xF[x]=\sum\limits_{i=0}^{x-1}F[i]\sum\limits_{j|x-i}jG[j]
$$

我们发现在 $x>1$ 的时候，联通好图和非联通好图形成双射，即 $F[i]=2G[i]$，因此上面式子可以将后半部分预处理，然后直接递推，时间复杂度 $O(n^2)$。

$$
\begin{aligned}
xF[x]&=\sum\limits_{i=0}^{x-1}F[i]\sum\limits_{j|x-i,j<x}jG[j]+xG[x]\\
\frac x2F[x]=xG[x]&=\sum\limits_{i=0}^{x-1}F[i]\sum\limits_{j|x-i,j<x}jG[j]
\end{aligned}
$$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 25005;
long long f[MAXN], sg[MAXN]; int p;
int qkpow(int a, int b) {
	int ans = 1; for (; b; b >>= 1, a = 1ll * a * a % p) if (b & 1) ans = 1ll * ans * a % p; return ans;
}
int main() {
	int t; scanf("%d %d", &t, &p);
	f[0] = 1; f[1] = 1; for (int i = 1; i <= 23333; i++) sg[i]++;
	for (int i = 2; i <= 23333; i++) {
		__int128 tmpf = 0; for (int j = 0; j < i; j++) tmpf += (__int128)f[j] * sg[i - j];
		f[i] = tmpf % p * qkpow(i, p - 2) * 2 % p; long long tmpg = tmpf % p;
		for (int j = i; j <= 23333; j += i) sg[j] += tmpg;
	}
	while (t--) {int n; scanf("%d", &n); printf("%d\n", (int)f[n]);}
}
```

---


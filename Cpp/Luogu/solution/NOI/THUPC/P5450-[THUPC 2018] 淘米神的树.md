# [THUPC 2018] 淘米神的树

## 题目描述

可爱的 Tommy 有一棵树。这棵树上只有点 $a$ 和 $b$ 是黑色，其它的点都是白色。

每次，Tommy 可以将一个黑色 $p$ 的点染成红色，然后把和 $p$ 相邻的所有白色的点染成黑色。最后，所有的点都会被染成红色。

设第 $i$ 个点是第 $t_i$ 个被染成红色的，那么 $t_i$ 是一个 $1$ 到 $n$ 的排列。Tommy 希望你帮他求出，有多少种不同的 $t_i$。

## 说明/提示

### 数据范围

保证 $a,b\le n\le 234,567$。

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
4 1 2
1 2
2 3
3 4```

### 输出

```
4```

# 题解

## 作者：Karry5307 (赞：10)

### 题意

写的很明白了，不需要解释。

$\texttt{Data Range:}1\leq n\leq 234567$

### 题解

当你看到这篇题解的时候请大声喊出：$\texttt{\color{black}t\color{red}ommy0103}\texttt{ is God! }\texttt{\color{black}I\color{red}tst}\texttt{ txdy! }\texttt{\color{black}M\color{red}\_sea}\texttt{ is God!}$

国 际 计 数 水 平

首先考虑一开始只有一个黑点的情况怎么做。

我们钦定黑点为根，设 $f_i$ 表示以 $i$ 为子树，并且 $i$ 这个节点为黑色的答案，那么我们得到：

$$f_u=(sz_u-1)!\prod\limits_{fa_v=u}\frac{f_v}{sz_v!}$$

接下来我们阐述这个式子到底是在干什么。

首先我们枚举**可能**的排列，由于现在只有 $u$ 是黑色的，第一轮肯定是先把 $u$ 变成红色。也就是说，$u$ 只能放在第一个，而剩下的可以任意。（注意这里是可能而不是合法）

接下来考虑排除掉所有不合法的排列，枚举每一棵子树，考虑某棵子树所有节点之间的偏序关系。

对于一个树 $T$ 对应的可能的序列 $P$ 来说，我们按顺序从 $P$ 中选出一些元素构造 $Q$，使得 $Q$ 中的每一个元素都是 $T$ 中某个子树 $S$ 中存在的节点的编号，并且 $S$ 中每个节点的编号都要在 $Q$ 中出现。

这里，$T$ 的根为 $u$，$S$ 的根为 $v$ 且 $fa_v=u$。

然后我们发现，如果序列 $Q$ 是不合法的，那么序列 $P$ 也是不合法的。

对所有子树都这么做就得到同时满足所有约束的序列个数，也就是上面的式子。

接下来我们考虑直接计算根节点的答案。

$$
f_{rt}=\frac{(sz_{rt}-1)!}{\prod\limits_{fa_v=rt}sz_v!}\prod\limits_{fa_v=rt}f_v
$$

然后我们对于所有根节点的儿子 $v$ 代入进来，再将所有孙子代入进来……相当于我们枚举所有节点计算，于是有

$$
f_{rt}=\prod\limits_{u=1}^{n}\frac{(sz_{u}-1)!}{\prod\limits_{fa_v=u}sz_v!}
$$

简单化开

$$
f_{rt}=\frac{\prod\limits_{u=1}^{n}(sz_{u}-1)!}{\prod\limits_{u=1}^{n}\prod\limits_{fa_v=u}sz_v!}
$$

注意分母，也就是说我们对于每个节点 $u$ 都枚举 $u$ 的所有儿子，相当于枚举所有非根节点（因为每个非根节点总会是某个节点的儿子），于是有

$$
f_{rt}=\frac{\prod\limits_{u=1}^{n}(sz_{u}-1)!}{\prod\limits_{u=1,u\neq rt}^{n}sz_u!}
$$

现在来拆分子。单独把 $u=rt$ 的拿出来，剩下的合并并约分，得到

$$
f_{rt}=(sz_{rt}-1)!\prod\limits_{u=1,u\neq rt}^{n}\frac{1}{sz_u}
$$

然后分子分母同乘一个 $sz_{rt}$ 得到答案为

$$
f_{rt}=sz_{rt}!\prod\limits_{u=1}^{n}\frac{1}{sz_u}
$$

接下来考虑两个黑点咋做，建立一个虚拟节点 $s$，向 $a,b$ 连无向边，初始的时候只有 $s$ 是黑点。

第一次只能变 $s$，然后就变成 $s$ 是红点，$a,b$ 是黑点。容易证明这样对答案没有任何影响。

于是树就变成了一颗基环树，考虑怎么求答案。

我们枚举环上染红的最后一个点的位置，但是这是不可行的。

那么我们就用类似于 NOIp2018 Day 2 T1 的方法，考虑枚举一条在环上的边并删除他来计算答案。

但是这样做可能会用重复的答案，所以我们要考虑如何来排除这些答案。

注意到对于一种染色方案来说，考虑这个方案在环上最后一个被染成红色的点。我们发现这个点可以有两种方案被染黑，也就是说每个方案都会算 $2$ 此，于是最终答案要乘上 $\frac{1}{2}$。

对于不是环上的点和虚拟节点 $s$ 我们都能用 $\texttt{dfs}$ 求出子树大小，设他们的和为 $z$。

我们现在考虑这些在环上的点，对于某个在环上的点 $u$ 来说，设 $a_u$ 表示它的确定子树大小（也就是所有不在环上的儿子的大小之和加一），$b_u$ 表示某种断环方式下的 $sz_u$，那么通过~~人类智慧~~我们发现

将环上的 $k+1$ 个点编号，$s$ 点为 $0$，其余的依次为 $1\sim k$，假设断的边是 $r\to r+1$，那么

$$b_u=\begin{cases}\sum\limits_{i=1}^{u}a_u,& 1\leq u\leq r\\\sum\limits_{i=u}^{k}a_u,&r+1\leq u\leq k\end{cases}$$

我们对 $a$ 做前缀和变成 $c$，那么可以发现

$$\prod b=\prod_{i\neq j}\vert c_i-c_j\vert$$

其中 $c_0=0$。

然后我们可以用快速插值的套路去优化这个东西，复杂度 $O(n\log^2n)$。

最后的最后，如果你看到了这里来了，请再跟我说一遍：

$\texttt{\color{black}t\color{red}ommy0103}\texttt{ is God! }$

tommy0103/qq

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#define clr(f,n) memset(f,0,sizeof(int)*(n))
#define cpy(f,g,n) memcpy(f,g,sizeof(int)*(n))
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
using namespace std;
typedef int ll;
typedef long long int li;
typedef unsigned long long int ull;
const ll MAXN=524291,MOD=998244353,G=3,INVG=332748118;
struct Edge{
    ll to,prev;
};
Edge ed[MAXN];
ll n,x,y,z,fct,from,to,tot,tp,cur,res;
ll rev[MAXN],omgs[MAXN],invo[MAXN];
ll last[MAXN],sz[MAXN],fa[MAXN],st[MAXN],p[MAXN],c[MAXN];
ll pr[MAXN],px[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline void addEdge(ll from,ll to)
{
    ed[++tot].prev=last[from];
    ed[tot].to=to;
    last[from]=tot;
}
inline void dfs(ll node,ll f)
{
    sz[node]=1,fa[node]=f;
    for(register int i=last[node];i;i=ed[i].prev)
    {
        if(ed[i].to!=f)
        {
            dfs(ed[i].to,node),sz[node]+=sz[ed[i].to];
        }
    }
}
inline ll qpow(ll base,ll exponent)
{
    ll res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%MOD;
        }
        base=(li)base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void setupOmg(ll cnt)
{
    ll limit=log2(cnt)-1,omg;
    omg=qpow(G,(MOD-1)>>(limit+1)),omgs[cnt>>1]=1;
    for(register int i=(cnt>>1|1);i!=cnt;i++)
    {
        omgs[i]=(li)omgs[i-1]*omg%MOD;
    }
    for(register int i=(cnt>>1)-1;i;i--)
    {
        omgs[i]=omgs[i<<1]; 
    }
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    static ull tcp[MAXN];
    register ll cur=0,x,shift=log2(cnt)-__builtin_ctz(cnt);
    if(inv==-1)
    {
        reverse(cp+1,cp+cnt);
    }
    for(register int i=0;i<cnt;i++)
    {
        tcp[rev[i]>>shift]=cp[i];
    }
    for(register int i=2;i<=cnt;i<<=1)
    {
        cur=i>>1;
        for(register int j=0;j<cnt;j+=i)
        {
            for(register int k=0;k<cur;k++)
            {
                x=tcp[j|k|cur]*omgs[k|cur]%MOD;
                tcp[j|k|cur]=tcp[j|k]+MOD-x,tcp[j|k]+=x;
            }
        }
    }
    for(register int i=0;i<cnt;i++)
    {
        cp[i]=tcp[i]%MOD;
    }
    if(inv==1)
    {
        return;
    }
    x=MOD-(MOD-1)/cnt;
    for(register int i=0;i<cnt;i++)
    {
        cp[i]=(li)cp[i]*x%MOD;
    }
}
inline void conv(ll fd,ll *f,ll *g,ll *res)
{
    static ll tmpf[MAXN],tmpg[MAXN];
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
        tmpf[i]=i<fd?f[i]:0,tmpg[i]=i<fd?g[i]:0;
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmpf,cnt,1),NTT(tmpg,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        tmpf[i]=(li)tmpf[i]*tmpg[i]%MOD;
    }
    NTT(tmpf,cnt,-1),cpy(res,tmpf,fd);
}
inline void inv(ll fd,ll *f,ll *res)
{
    static ll tmp[MAXN];
    if(fd==1)
    {
        res[0]=qpow(f[0],MOD-2);
        return;
    }
    inv((fd+1)>>1,f,res);
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
        tmp[i]=i<fd?f[i]:0;
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmp,cnt,1),NTT(res,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        res[i]=(li)(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD;
    }
    NTT(res,cnt,-1),clr(res+fd,cnt-fd-1);
}
inline void mod(ll fd,ll gd,ll *f,ll *g,ll *r)
{
    static ll tmpf[MAXN],tmpg[MAXN],tinv[MAXN],q[MAXN];
    if(fd<gd)
    {
        for(register int i=0;i<gd-1;i++)
        {
            r[i]=f[i];
        }
        return;
    }
    for(register int i=0;i<fd;i++)
    {
        tmpf[i]=f[fd-1-i];
    }
    for(register int i=0;i<gd;i++)
    {
        tmpg[i]=g[gd-1-i];
    }
    inv(fd-gd+2,tmpg,tinv);
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmpf,cnt,1),NTT(tinv,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        q[i]=1ll*tmpf[i]*tinv[i]%MOD;
    }
    NTT(q,cnt,-1),reverse(q,q+fd-gd+1);
    for(register int i=0;i<cnt;i++)
    {
        tmpf[i]=tinv[i]=tmpg[i]=0;
        q[i]=i<fd-gd+1?q[i]:0,g[i]=i<gd?g[i]:0;
    }
    cnt>>=1,limit--;
    for(register int i=0;i<cnt;i++)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(q,cnt,1),NTT(g,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        tmpf[i]=1ll*q[i]*g[i]%MOD;
    }
    NTT(g,cnt,-1),NTT(tmpf,cnt,-1);
    for(register int i=0;i<gd-1;i++)
    {
        r[i]=(f[i]-tmpf[i]+MOD)%MOD;
    }
    for(register int i=0;i<cnt;i++)
    {
        q[i]=tmpf[i]=0;
    }
}
vector<ll> tmpf2[MAXN<<2];
void dnc(ll *pts,ll l,ll r,ll node)
{
    static ll tmp[MAXN],tmp2[MAXN];
    if(l==r)
    {
        tmpf2[node].push_back((MOD-pts[l])%MOD),tmpf2[node].push_back(1);
        return;
    }
    ll mid=(l+r)>>1,ls=node<<1,rs=ls|1;
    dnc(pts,l,mid,ls),dnc(pts,mid+1,r,rs);
    ll d=tmpf2[ls].size(),d2=tmpf2[rs].size();
    copy(tmpf2[ls].begin(),tmpf2[ls].end(),tmp);
    copy(tmpf2[rs].begin(),tmpf2[rs].end(),tmp2);
    ll cnt=1,limit=-1;
    while(cnt<(d+d2))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmp,cnt,1),NTT(tmp2,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        tmp[i]=(li)tmp[i]*tmp2[i]%MOD;
    }
    NTT(tmp,cnt,-1),tmpf2[node].resize(d+d2-1);
    copy(tmp,tmp+d+d2-1,tmpf2[node].begin()),clr(tmp,cnt),clr(tmp2,cnt);
}
ll tmpf3[19][MAXN];
void dnc2(ll fd,ll *f,ll depth,ll l,ll r,ll node,ll *res)
{
    static ll tmp[MAXN],pw[17];
    if(r-l<=1024)
    {
        for(register int i=l;i<=r;i++)
        {
            ll x=c[i],cur=f[fd-1],v1,v2,v3,v4;
            pw[0]=1;
            for(register int j=1;j<=16;j++)
            {
                pw[j]=1ll*pw[j-1]*x%MOD;
            }
            for(register int j=fd-2;j-15>=0;j-=16)
            {
                v1=(1ll*cur*pw[16]+1ll*f[j]*pw[15]+
                    1ll*f[j-1]*pw[14]+1ll*f[j-2]*pw[13])%MOD;
                v2=(1ll*f[j-3]*pw[12]+1ll*f[j-4]*pw[11]+
                    1ll*f[j-5]*pw[10]+1ll*f[j-6]*pw[9])%MOD;
                v3=(1ll*f[j-7]*pw[8]+1ll*f[j-8]*pw[7]+
                    1ll*f[j-9]*pw[6]+1ll*f[j-10]*pw[5])%MOD;
                v4=(1ll*f[j-11]*pw[4]+1ll*f[j-12]*pw[3]+
                    1ll*f[j-13]*pw[2]+1ll*f[j-14]*pw[1])%MOD;
                cur=(0ll+v1+v2+v3+v4+f[j-15])%MOD;
            }
            for(register int j=((fd-1)&15)-1;~j;j--)
            {
                cur=(1ll*cur*x+f[j])%MOD;
            }
            res[i]=cur;
        }
        return;
    }
    ll sz=tmpf2[node].size()-1;
    for(register int i=0;i<sz+1;i++)
    {
        tmp[i]=tmpf2[node][i];
    }
    clr(tmpf3[depth],sz+10),mod(fd,sz+1,f,tmp,tmpf3[depth]);
    ll mid=(l+r)>>1;
    dnc2(sz,tmpf3[depth],depth+1,l,mid,node<<1,res);
    dnc2(sz,tmpf3[depth],depth+1,mid+1,r,(node<<1)|1,res);
    for(register int i=0;i<sz;i++)
    {
        tmpf3[depth][i]=0;
    }
}
inline void eval(ll fd,ll pcnt,ll *f,ll *pts,ll *res)
{
    dnc(pts,0,pcnt-1,1),dnc2(fd,f,0,0,pcnt-1,1,res);
}
int main()
{
    setupOmg(524288),n=read(),x=read(),y=read();
    for(register int i=0;i<n-1;i++)
    {
        from=read(),to=read();
        addEdge(from,to),addEdge(to,from);
    }
    dfs(x,0);
    while(y!=x)
    {
        st[++tp]=y,p[y]=1,y=fa[y];
    }
    st[++tp]=y,p[y]=1,y=fa[y],z=n+1,fct=1;
    for(register int i=1;i<=tp;i++)
    {
        c[i]=1;
        for(register int j=last[st[i]];j;j=ed[j].prev)
        {
            if(!p[ed[j].to])
            {
                c[i]+=sz[ed[j].to];
            }
        }
    }
    for(register int i=1;i<=n;i++)
    {
        fct=(li)fct*i%MOD;
        if(!p[i])
        {
            z=(li)z*sz[i]%MOD;
        }
    }
    fct=(li)fct*(n+1)%MOD;
    for(register int i=1;i<=tp;i++)
    {
        c[i]=(c[i-1]+c[i])%MOD;
    }
    dnc(c,1,tp+1,1);
    for(register int i=1;i<=tp+1;i++)
    {
        pr[i-1]=(li)i*tmpf2[1][i]%MOD;
    }
    memset(tmpf2,0,sizeof(tmpf2)),eval(n+1,tp+1,pr,c,px);
    for(register int i=0;i<=tp;i++)
    {
        cur=(li)fct*qpow((li)px[i]*z%MOD,MOD-2)%MOD;
        res=(res+(((tp-i)&1)?MOD-cur:cur))%MOD;
    }
    printf("%d\n",(li)res*499122177%MOD);
}
```

---

## 作者：Prean (赞：1)

萌萌多项式。

先考虑有根树指定根节点的拓扑排序方案数。

设 $dp[u]$ 是 $u$ 为根子树的方案数，容易发现有
$$dp[u]=(\sum_{v\in son(u)}siz[v])!\prod_{v\in son(u)}\frac{1}{siz[v]!}=(siz[u]-1)!\prod_{v\in son(u)}\frac{1}{siz[v]!}$$
稍微推导一下可以得到 $f[rt]$ 是：
$$n\times n!\prod_{i=1}^{n}\frac{1}{siz[i]}$$
考虑原问题。

枚举 $(a,b)$ 路径上的一条断边，表示一边全部是被 $a$ 扩展成红色节点的，另一边全是被 $b$ 扩展的。

容易发现非 $(a,b)$ 路径上节点的 $siz$ 都是固定的，是常数。

于是只需要考虑 $(a,b)$ 路径上节点的 $siz$ 即可。

设 $a_i$ 表示断掉 $(a,b)$ 路径上所有边后，原本路径上第 $i$ 个节点所在的连通块大小，$S$ 为 $a$ 的前缀和。

可以随手写出柿子答案是：
$$\sum_{i=1}^{n-1}\frac{1}{\prod_{j=1}^{i}(S_i-S_{j-1})\prod_{j=i+1}^{n}(S_j-S_i)}$$
设 $f_i=\lim_{x\to S_i}\frac{\prod_{j=1}^{n}(x-S_j)}{x-S_i}$，不难发现答案是：
$$\sum_{i=1}^{n-1}\frac{1}{S_if_i(-1)^{n-i}}$$
根据洛必达法则，设：
$$F(x)=\prod_{i=1}^{n}(x-S_i)$$
有：
$$f_i=G'(S_i)$$
于是写个分治乘再写个多点求值就做完了，复杂度 $O(n\log^2n)$。

但是注意到实际上算重了。

因为有一个节点是最后被计算到的，将它归为左部分和右部分各算了一次。（除了端点）

所以直接把两个端点分别作为黑点的方案算出来，加上之后除以 $2$ 即可。复杂度不变。

有趣的是，这篇题解因为全家桶太长被小粉兔拒过一遍。
```cpp
int n,a,b,ege,f[M],h[M],S[M],sz[M],siz[M];bool vis[M];int len,nd[M];
Poly F[M<<2];
struct Edge{
	int v,nx;
}e[M<<1];
inline void AddEdge(const int&u,const int&v){
	e[++ege]=(Edge){v,h[u]};h[u]=ege;
	e[++ege]=(Edge){u,h[v]};h[v]=ege;
}
inline bool Find(const int&u,const int&fa){
	if(u==a)return vis[nd[++len]=u]=true;
	for(int v,E=h[u];E;E=e[E].nx)if((v=e[E].v)^fa&&Find(v,u))return vis[nd[++len]=u]=true;
	return false;
}
inline void DFS(const int&u,const int&fa){
	siz[u]=1;for(int v,E=h[u];E;E=e[E].nx)if(v=e[E].v,v^fa&&!vis[v])DFS(v,u),siz[u]+=siz[v];
}
inline void Build(const int&u,const int&L,const int&R){
	if(L==R)return F[u].push_back(mod-S[L]),F[u].push_back(1);
	const int&mid=L+R>>1;Build(u<<1,L,mid);Build(u<<1|1,mid+1,R);F[u]=F[u<<1]*F[u<<1|1];
}
inline void Solve(const int&u,const int&L,const int&R,Poly H){
	if(L==R)return void(f[L]=H[0]);
	const int&mid=L+R>>1;Solve(u<<1,L,mid,H%F[u<<1]);Solve(u<<1|1,mid+1,R,H%F[u<<1|1]);
}
inline int Get(const int&u,const int&fa){
	int prod(1);sz[u]=1;for(int v,E=h[u];E;E=e[E].nx)if((v=e[E].v)^fa)prod=1ll*prod*Get(v,u)%mod,sz[u]+=sz[v];
	return 1ll*prod*sz[u]%mod;
}
signed main(){
	int sum(0),prod(1);n=read();a=read();b=read();init(n+1);
	for(int u,v,i=1;i<n;++i)u=read(),v=read(),AddEdge(u,v);Find(b,0);
	for(int i=1;i<=len;++i)DFS(nd[i],0);for(int i=1;i<=n;++i)if(!vis[i])prod=1ll*prod*siz[i]%mod;prod=pow(prod);
	if(len==1){
		for(int i=1;i<n;++i)prod=1ll*prod*i%mod;write(prod);
		return 0;
	}
	for(int i=1;i<=len;++i)S[i]=S[i-1]+siz[nd[i]];Build(1,1,len);Solve(1,1,len,F[1].Der());
	for(int i=1;i<len;++i)sum=(sum+pow(1ll*(len-i&1?mod-f[i]:f[i])*S[i]%mod))%mod;prod=1ll*prod*sum%mod;
	prod=(prod+pow(Get(a,0)))%mod;prod=(prod+pow(Get(b,0)))%mod;prod=1ll*prod*pow(2)%mod;
	for(int i=1;i<=n;++i)prod=1ll*prod*i%mod;write(prod);
}
```

---

## 作者：Acoipp (赞：0)

## 分析

首先考虑只有一个点最开始是黑色的情况怎么做，这个很简单，就是树的拓扑序计数，这里摆出结论，这个结论证明方法很多且不是这道题的重点，此处并不详解：

$$
ans=n!\prod_{i=1}^n \frac 1{siz_i}
$$

$n$ 是节点总数，$siz_p$ 表示 $p$ 这棵子树内的节点数量。

然后考虑有两个点最开始是黑色的情况，设这两个点为 $a,b$，连接这两个点的链是 $p_1,p_2,\dots,p_k(p_1=a,p_k=b)$，那么最后不管怎么样一定会存在一个 $p_i$ 满足 $p_i$ 是这条链上最后一个被染黑的点。（$1<i<k$）

我们发现点的限制并不好处理，考虑一条 $p_i \to p_{i+1}$ 的边，$p_{1 \sim i}$ 的黑色都是 $a$ 给的，$p_{i+1 \sim k}$ 的黑色都是 $b$ 给的，那这样就划分成了两棵树，我们对于每棵树跑只有一个点的答案就可以了。

我们发现，非链上的节点的子树大小无论如何不会发生变化，设其对答案的贡献为 $res$，因此我们只需要考虑链上节点的子树大小，设以 $a$ 为根，$siz_p$ 表示 $p$ 为根的子树大小，并且当前分割的边是 $i \to i+1$ 那么就有答案等于（$s_{k+1}=0$）：

$$
n!(res\prod_{j=1}^i (s_j-s_{i+1})\prod_{j=i+2}^{k+1} (s_{i+1}-s_j))^{-1}
$$

去掉常数项得到：

$$
\prod_{j=1}^i (s_{i+1}-s_j)\prod_{j=i+2}^{k+1} (s_{i+1}-s_j)
$$

再化一下：

$$
\dfrac{\prod_{j=1}^{k+1} (s_{i+1}-s_j)}{s_{i+1}-s_{i+1}}
$$

容易发现这就是一个多项式多点求值，即求 $x$ 在 $s_{i+1}$ 处的取值：

$$
\dfrac{\prod_{j=1}^{k+1} (x-s_j)}{x-s_{i+1}}
$$

但是上下都是 $0$ 怎么办呢？通过洛必达法则我们知道，$x$ 在 $s_{i+1}$ 处的取值也就等于在下面函数的 $s_{i+1}$ 处的取值：

$$
(\prod_{j=1}^{k+1} (x-s_j))'
$$

于是我们先分治求出 $(\prod_{j=1}^{k+1} (x-s_j))'$ 的值，然后上多项式多点求值即可，就能得到上式的答案。

最后，因为第 $i(1<i<k)$ 个链上的点最后染黑色在断 $i-1 \sim i$ 的时候和 $i \sim i+1$ 计算过两次，所以最终的答案需要加上以 $a$ 作为唯一黑点的答案和以 $b$ 作为唯一黑点的答案之后，再除以 $2$。（此处黑点也需要再涂一次变成红点，有可能是最后一个涂的，但是只算了一次）

时间复杂度 $O(n \log^2 n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
#define ll long long
#define N 2000005
#define mod 998244353
using namespace std;
namespace IO{
	inline char nc(){
		static char buf[1000000],*p=buf,*q=buf;
		return p==q&&(q=(p=buf)+fread(buf,1,1000000,stdin),p==q)?EOF:*p++;
	}
	inline ll read(){
		ll res = 0,w = 1;
		char c = nc();
		while(c<'0'||c>'9')w=(c=='-'?-1:w),c=nc();
		while(c<='9'&&c>='0')res=res*10+c-'0',c=nc();
		return res*w;
	}
	char obuf[1<<21],*p3=obuf; 
	inline void pc(char c){ 
		p3-obuf<=(1<<20)?(*p3++=c):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=c); 
	} 
	inline void write(ll x){ 
		if(x<0) pc('-'),x=-x; 
		if(x>9) write(x/10); 
		pc(x%10+'0'); 
	}
}

using namespace IO;

inline ll qmi(ll a,ll b,ll p){
	ll res = 1,t = a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
}


vector<ll> op[N];

ll n,m,a,b,i,x,y,c[N],k,ans,sum[N],tot,sta[N],top,vis[N],son[N],jc[N],inv[N],res=1,as[N],bs[N],cs[N];

ll bin[N<<3],*pos(bin),*g[N];

inline void dfs(ll x,ll fa){
	sta[++top] = x,son[x] = 1;
	if(x==b) for(ll i=1;i<=top;i++) vis[sta[i]]=1;
	for(ll i=0;i<op[x].size();i++){
		if(op[x][i]==fa) continue;
		dfs(op[x][i],x);
		son[x] += son[op[x][i]];
	}
	top--;
}

inline void dfss(ll x,ll fa){
	son[x] = 1;
	for(ll i=0;i<op[x].size();i++){
		if(op[x][i]==fa) continue;
		dfss(op[x][i],x);
		son[x] += son[op[x][i]];
	}
	res=res*qmi(son[x],mod-2,mod)%mod;
}

inline void dfs2(ll x,ll fa){
	ll res = 1;
	for(ll i=0;i<op[x].size();i++){
		if(op[x][i]==fa) continue;
		if(vis[op[x][i]]) continue;
		res += son[op[x][i]];
	}
	sum[++tot] = res;
	for(ll i=0;i<op[x].size();i++){
		if(vis[op[x][i]]&&op[x][i]!=fa) dfs2(op[x][i],x);
	}
}

inline void binary_ntt(ll l,ll r,ll p){
	g[p] = pos,pos += (r-l+2);
	if(l==r){
		g[p][0]=(mod-sum[l])%mod,g[p][1]=1;
		return ;
	}
	ll mid = (l+r)/2;
	binary_ntt(l,mid,2*p),binary_ntt(mid+1,r,2*p+1);
	poly::times(g[2*p],g[2*p+1],g[p],mid-l+2,r-mid+1,1);   //多项式乘法，此处省略
}

int main(){
	poly::G=3,poly::invG=qmi(poly::G,mod-2,mod),poly::init(1<<20);
	n=read(),a=read(),b=read();
	jc[0]=1;
	for(i=1;i<=n;i++) jc[i]=jc[i-1]*i%mod;
	for(i=n;i>=1;i--) inv[i-1]=inv[i]*i%mod;
	for(i=1;i<n;i++) x=read(),y=read(),op[x].push_back(y),op[y].push_back(x);
	dfs(a,-1);
	dfs2(a,-1);
	for(i=1;i<=n;i++) if(!vis[i]) res=res*qmi(son[i],mod-2,mod)%mod;
	for(i=tot;i>=2;i--) sum[i-1]+=sum[i];
	sum[++tot]=0;
	binary_ntt(1,tot,1);
	for(i=0;i<=tot;i++) as[i]=g[1][i];
	for(i=1;i<=tot;i++) as[i-1]=as[i]*i%mod;
	as[tot]=0;
//	for(i=0;i<tot;i++) cout<<as[i]<<" ";
//	cout<<endl;
	for(i=1;i<=tot-2;i++) bs[i]=sum[i+1];
	poly::get_val(as,bs,cs,tot,tot-1);  //多项式多点求值，此处省略
	for(i=1;i<=tot-2;i++){
		ll temp = res*qmi(qmi(mod-1,i,mod)*cs[i]%mod,mod-2,mod)%mod*jc[n]%mod;
		ans=(ans+temp)%mod;
	}
	res=jc[n],dfss(a,-1),ans=(ans+res)%mod,res=jc[n],dfss(b,-1),ans=(ans+res)%mod;
	write(ans*qmi(2,mod-2,mod)%mod);
	fwrite(obuf,p3-obuf,1,stdout);
	return 0;
}
/*
6 1 4
1 2
2 5
2 3
3 4
1 6

63
*/
```

---


# [THUPC 2019] 摆家具

## 题目描述

你有 $k$ 件不同的家具，需要摆放在 $n$ 个不同的房间中。假设每个房间足够大，并且只考虑每件家具处于哪个房间（而不考虑房间内部如何摆放），那么总共有 $n^k$ 种不同的摆放方式（注意，不是 $k^n$）。

摆放家具也算一门学问了，至少不太好乱摆的吧？对于每种摆放方式，我们可以给这种方式打分。例如，某个方案把餐桌放到了卫生间，或是一个卧室放了两张床而另一个卧室没有床，就会获得比较低的分数。由于这个分数关于每件家具、每个房间不是独立的，我们会输入所有 $n^k$ 种摆放方式的分数。

你现在心血来潮，想换一换房间的布局。给出一种初始时的摆放方式，你会重复 $T$ 次下述操作：每次，你会任选一件家具，然后将这件家具移动到任意一个其他房间中。每一轮有 $k(n-1)$ 种决策（选择家具的方案数乘以选择另一个房间的方案数），所以总共有 $k^T(n-1)^T$ 种决策。你需要计算这每一种决策后的摆放方式的得分之和。

不仅如此，我们会给出 $q$ 次询问，每次输入初始时的摆放方式与 $T$，你需要**在线地**回答 $k^T(n-1)^T$ 种决策后的得分之和（取模）。详见输入与输出格式。

我们如下定义一种摆放方式的编号：

我们将家具用 0 到 $k-1$ 的不同整数编号，房间用 $0$ 到 $n-1$ 的不同整数编号。设在某种摆放方式下，第 $i$ 号家具被放在了 $p_i$ 号房间中，则定义这种摆放方式的编号为 $\sum_{i=0}^{k-1} p_i n^i$。可以发现，所有的 $n^k$ 种摆放方式的编号恰好是 $0$ 到 $n^k -1$ 的不同整数。

另外，设 $P=998244353$。

## 说明/提示

#### 样例解释
第一次询问中，初始摆放方式的编号为 $0$，$T=1$。

初始时，$0$ 号家具放在 $0$ 号房间，$1$ 号家具放在 $0$ 号房间，$2$ 号家具放在 $0$ 号房间。经过 $1$ 次操作后，可能的情况有：

* 将 $0$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $1$，得分为 $10$；
* 将 $1$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $2$，得分为 $100$；
* 将 $2$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $4$，得分为 $998244245$。

所以，所有情况的总得分为 $998244355$，对 $P$ 取模后为 $2$。

第二次询问中，初始摆放方式的编号为 $0$，$T=2$。

初始时，$0$ 号家具放在 $0$ 号房间，$1$ 号家具放在 $0$ 号房间，$2$ 号家具放在 $0$ 号房间。经过 $2$ 次操作后，可能的情况有：

* 将 $0$ 号家具移动到 $1$ 号房间，然后将 $0$ 号家具移动到 $0$ 号房间，此后的摆放方式编号为 $0$，得分为 $1$；
* 将 $0$ 号家具移动到 $1$ 号房间，然后将 $1$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $3$，得分为 $1000$；
* 将 $0$ 号家具移动到 $1$ 号房间，然后将 $2$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $5$，得分为 $100000$；
* 将 $1$ 号家具移动到 $1$ 号房间，然后将 $0$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $3$，得分为 $1000$；
* 将 $1$ 号家具移动到 $1$ 号房间，然后将 $1$ 号家具移动到 $0$ 号房间，此后的摆放方式编号为 $0$，得分为 $1$；
* 将 $1$ 号家具移动到 $1$ 号房间，然后将 $2$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $6$，得分为 $1000000$；
* 将 $2$ 号家具移动到 $1$ 号房间，然后将 $0$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $5$，得分为 $100000$；
* 将 $2$ 号家具移动到 $1$ 号房间，然后将 $1$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $6$，得分为 $1000000$；
* 将 $2$ 号家具移动到 $1$ 号房间，然后将 $2$ 号家具移动到 $0$ 号房间，此后的摆放方式编号为 $0$，得分为 $1$。

所以，所有情况的总得分为 $2202003$，对 $P$ 取模后为 $2202003$。

第三次询问中，初始摆放方式的编号为 $1$，$T=513066699$。初始时，$0$ 号家具放在 $1$ 号房间，$1$ 号家具放在 $0$ 号房间，$2$ 号家具放在 $0$ 号房间。

……（省略至少 $3^{513066699}$ 行）

#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 https://github.com/wangyurzee7/THUPC2019 查看。

## 样例 #1

### 输入

```
2 3 3
1
10
100
1000
998244245
100000
1000000
10000000
0 1
0 1
1 233```

### 输出

```
2
2202003
444957911```

# 题解

## 作者：Acoipp (赞：1)

首先考虑给的集合 $S$ 到达 $T$，有一些点的位置会发生变化，设有 $l$ 个，那么剩下 $k-l$ 个没有发生变化，那么有结论 $S \to T$ 的方案数只跟 $l$ 有关。

这个方案可以直接矩阵乘法求出来，设矩阵为 $B$，那么 $B$ 的构造是容易的，只需要设置一个阈值 $K$，预处理出 $B^0 \sim B^K$ 以及 $B^K,B^{2K},\dots$ 就可以实现 $O(k^2)$ 查询出来在 $T$（题面中的意思）固定的情况下每个 $l$ 的方案数。

这一部分预处理时间复杂度是 $O(\sqrt{mod}k^3+k^2q)$ 的。

然后考虑处理出 $f_{S,i}$ 表示与集合 $S$ 中不同的元素（某个物品在 $S$ 中的位置与在 $T$ 中的位置不一样）有 $i$ 个的 $T$ 的所有得分之和。

这个 $f$ 我们可以用类似于高维前缀和的方法处理，大概就是枚举 $i$，然后 $f_{S,j}$ 存的是所有 $T$ 与 $S$ 在前 $i$ 位有 $j$ 个不同，并且后 $k-i$ 位与 $S$ 完全相同的 $T$ 的得分之和。

最后只需要枚举第 $i+1$ 位填的是什么即可。

于是就可以用高维前缀和的套路优化了，这部分的时间复杂度是 $O(n^kk^2)$。

整体来说呢，需要卡卡常才能过。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 1000005
#define mod 998244353
using namespace std;
ll n,k,q,i,j,l,l2,up,val[N],qm[N],ans=1,a,b,anss[21][21],temp[21][21],g[N][21],h[N][21],p[21],inv[21],C[25][25],B,ps;
int f[32005][21][21],f2[32005][21][21];
inline ll qmi(ll a,ll b,ll p){
	ll res = 1%p,t = a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
}
inline void times(ll a[21][21],int b[21][21],ll n1,ll n2,ll n3){
	for(ll i=0;i<=n1;i++) for(ll j=0;j<=n2;j++) for(ll k=0;k<=n3;k++) temp[i][k]=(temp[i][k]+a[i][j]*b[j][k])%mod;
	for(ll i=0;i<=n1;i++) for(ll k=0;k<=n3;k++) a[i][k]=temp[i][k],temp[i][k]=0;
}
inline char nc(){
	static char buf[1000000],*p=buf,*q=buf;
	return p==q&&(q=(p=buf)+fread(buf,1,1000000,stdin),p==q)?EOF:*p++;
}
inline ll read(){
	ll res = 0,w = 1;
	char c = nc();
	while(c<'0'||c>'9')w=(c=='-'?-1:w),c=nc();
	while(c<='9'&&c>='0')res=res*10+c-'0',c=nc();
	return res*w;
}
char obuf[1<<21],*p3=obuf; 
inline void pc(char c){ 
	p3-obuf<=(1<<20)?(*p3++=c):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=c); 
} 
inline void write(ll x){ 
	if(x<0) pc('-'),x=-x; 
	if(x>9) write(x/10); 
	pc(x%10+'0'); 
}
int main(){
	n=read(),k=read(),q=read(),up=qmi(n,k,mod),B=sqrt(mod);
	qm[0]=1;
	for(i=1;i<=k;i++) qm[i]=qm[i-1]*n;
	for(i=0;i<up;i++) val[i]=read(),g[i][0]=val[i];
	for(i=0;i<k;i++){
		for(j=0;j<up;j++){
			for(l=0;l<=i;l++){
				(h[j][l] = (h[j][l]+g[j][l]))>=mod&&(h[j][l]-=mod);
				(h[j][l+1] = (h[j][l+1]-g[j][l]))<0&&(h[j][l+1]+=mod);
			}
			if((j/qm[i])%n==0){
				memset(p,0,sizeof(p));
				for(l=0;l<n;l++) for(l2=0;l2<=i;l2++) (p[l2+1]=(p[l2+1]+g[j+l*qm[i]][l2]))>=mod&&(p[l2+1]-=mod);
				for(l=0;l<n;l++) for(l2=0;l2<=i+1;l2++) (h[j+l*qm[i]][l2]=(p[l2]+h[j+l*qm[i]][l2]))>=mod&&(h[j+l*qm[i]][l2]-=mod);
			}
		}
		for(j=0;j<up;j++) for(l=0;l<=i+1;l++) g[j][l]=h[j][l],h[j][l]=0;
	}
	C[0][0]=1;
	for(i=0;i<=k;i++){
		for(j=0;j<=k;j++){
			if(i) C[i][j]+=C[i-1][j];
			if(i&&j) C[i][j]+=C[i-1][j-1];
			if(C[i][j]>=mod) C[i][j]-=mod;
		}
	}
	for(i=0;i<=k;i++){
		if(i) f[1][i][i-1]=(f[1][i][i-1]+i)%mod,f[1][i][i]=(f[1][i][i]+1ll*i*(n-2))%mod;
		if(k-i) f[1][i][i+1]=(f[1][i][i+1]+1ll*(k-i)*(n-1))%mod;
	}
	for(i=2;i<=B;i++){
		for(j=0;j<=k;j++) for(l=0;l<=k;l++) for(ps=0;ps<=k;ps++) f[i][j][ps]=(f[i][j][ps]+1ll*f[i-1][j][l]*f[1][l][ps])%mod;
	}
	for(i=0;i<=k;i++) for(j=0;j<=k;j++) f2[1][i][j]=f[B][i][j];
	for(i=2;i<=(mod/B);i++){
		for(j=0;j<=k;j++) for(l=0;l<=k;l++) for(ps=0;ps<=k;ps++) f2[i][j][ps]=(f2[i][j][ps]+1ll*f2[i-1][j][l]*f2[1][l][ps])%mod;
	}
	for(i=0;i<=k;i++) inv[i]=qmi(C[k][i],mod-2,mod)*qmi(qmi(n-1,i,mod),mod-2,mod)%mod;
	while(q--){
		a=read(),b=read();
		b=b*ans%mod;
		for(i=0;i<=k;i++) anss[0][i]=0;
		anss[0][0]=1;
		if(b/B) times(anss,f2[b/B],0,k,k);
		if(b%B) times(anss,f[b%B],0,k,k);
		for(i=0,ans=0;i<=k;i++) ans=(ans+anss[0][i]*g[a][i]%mod*inv[i])%mod;
		write(ans),pc('\n');
	}
	return fwrite(obuf,p3-obuf,1,stdout),0;
}
```

---


# [THUPC 2021] 区间本质不同逆序对

## 题目描述

给定一个长为 $n$ 的序列 $a$。

有 $m$ 次询问，每次询问给定一个区间 $[l,r]$，求 $|\{(a_i,a_j) : l\le i<j\le r \wedge a_i>a_j\}|$。

$1\le n\le 10^5$，$1\le m\le 5\times 10^5$。

## 说明/提示

**【样例解释】**

对于第一次询问，集合为 $\{(3,2)\}$。

对于第二次与第三次询问，集合为 $\{(2,1),(3,1),(3,2)\}$。

对于第四次询问，集合为空集。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_0/tree/master](https://github.com/yylidiw/thupc_0/tree/master) 查看。

## 样例 #1

### 输入

```
5
2 1 3 2 1
4
2 4
1 5
3 5
2 2```

### 输出

```
1
3
3
0```

# 题解

## 作者：dead_X (赞：22)

## 前言

比 $\texttt{c}\color{red}\texttt{yffff}$ 那篇多描述了实现上的一些细节。

## 为何使用莫队

注意到如果给的是一个排列，那么问题就是区间逆序对，因此算法复杂度不会低于根号。

有两种做法：**分块**和**二次离线莫队**。

由于分块做法常数较大而且预处理之后整块散块不是很好算，我们考虑二次离线莫队。

## 要计算的贡献

因为两侧加入和删除都是等价的，考虑从最右侧加入一个数的贡献。

记加入的数下标为 $r$，它上一次出现为 $r'$，则 $(r',r)$ 中新出现的数会被计入贡献。

记 $f(l,r)$ 为 $[l,r]$ 中 $>a_r$ 的数的数量，贡献就可以拆成 $f(l,r)-f(l,r')$。

于是问题变成了 $n\sqrt m$ 次算 $f(l,r)$。

## 离线和最终问题

显然我们不能一个一个地储存 $n\sqrt m$ 个询问。

注意到在右侧插入的询问中 $l$ 都一样，而 $r$ 是一段连续的值，因此我们可以把这些值压成一段然后排序。 

现在询问已经将 $l$ 从大到小排序了，我们再次简化问题：

* $n$ 次单点加。
* $n\sqrt m$ 次区间二维前缀和查询。
* **这些查询中，第二维的值只取决于第一维的值。**

## 一个性质

在这里，我们可以将相同的 $a_r$ 直接加以区分，相同的数越靠左越大，让序列变成一个排列。

不难证明这样在题目中的查询里答案仍然正确。

这个性质会在最后一部分散块处理中用到。

## 人类智慧分块

我们考虑一些令人窒息的操作：

我们把询问的矩形分成 $n^{0.5}$ 个 $n^{0.75}\times n^{0.75}$ 的块。

再分成 $n^{0.75}$ 个 $n^{0.75}\times n^{0.5}$ 和 $n^{0.5}\times n^{0.75}$ 的块。

再分成 $n$ 个 $n^{0.5}\times n^{0.5}$ 的块。

于是一个询问大概可以被划分成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/3856rdih.png)

## 整块的处理方式

对于橙色的色块，我们暴力维护二维前缀和，复杂度为 $O(\sqrt n)-O(1)$。

对于黄，绿的色块，我们也暴力维护每个独立区域的二维前缀和。

由于一个独立区域仅包含 $\sqrt n $ 个块，因此可以做到 $O(\sqrt n)-O(1)$。

## 散块的处理方式

于是只剩下最后一部分了：蓝色的边角。

由于边角这一块的数量巨大，且绝大多数信息都为空，我们不能直接维护前缀和。

于是我们考虑反向维护：对于每个元素，它可能在哪些询问中从蓝色部分计入答案呢？

答案非常简单，询问符合条件当且仅当覆盖了这个元素的位置，且没有覆盖这个元素所在 $n^{0.5}\times n^{0.5}$ 块右上角的位置。

由于上文的那个性质，此时可以直接枚举两维 $\sqrt n$ 个可能合法的询问，如果满足则修改对应的值。

在查询时，直接加上第一维对应的值即可，因此这部分复杂度也是 $O(\sqrt n)-O(1)$

## 代码

至此本题得解，空间复杂度 $O(n+m)$，时间复杂度 $O(n\sqrt n+n\sqrt m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define R(x) (n+1-x)
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
struct node
{
	int l,r,id,bl;
	bool operator<(const node&t)const{return (bl<t.bl)||(bl==t.bl&&r<t.r);}
}q[500003];
struct query
{
	int id,l,r,f;
};
vector<query> v1[500003],v2[500003];
int a[100003],pos[100003],lst[100003],nxt[100003];
ll ans[500003],lxl[500003];
int s0[30][30],s1[350][30],s2[30][350],s3[350][350],s4[110003];
int o[100003],b[100003],id[100003];
const int B1=320,B2=5760;
int n=read(),m,B;
void insert(int x)
{
	int y=b[x];
	for(int i=x/B2+1; i<20; ++i)
		for(int j=y/B2+1; j<20; ++j) 
			++s0[i][j];
	for(int i=x/B1+1,ir=(x/B2+1)*18; i<ir; ++i)
		for(int j=y/B2+1; j<20; ++j) 
			++s1[i][j];
	for(int i=x/B2+1; i<20; ++i)
		for(int j=y/B1+1,jr=(y/B2+1)*18; j<jr; ++j) 
			++s2[i][j];
	for(int i=x/B1+1,ir=(x/B2+1)*18; i<ir; ++i)	
		for(int j=y/B1+1,jr=(y/B2+1)*18; j<jr; ++j) 
			++s3[i][j];
	for(int i=x+1,ir=(x/B1+1)*B1; i<=n&&i<ir; ++i) (b[i]>y)&&(++s4[i]);
	for(int i=y+1,ir=(y/B1+1)*B1,sdt=(x/B1+1)*B1; i<=n&&i<=ir; ++i) 
	(id[i]>=sdt)&&(++s4[id[i]]);
}
void erase(int x)
{
	int y=b[x];
	for(int i=x/B2+1; i<20; ++i)
		for(int j=y/B2+1; j<20; ++j) 
			--s0[i][j];
	for(int i=x/B1+1,ir=(x/B2+1)*18; i<ir; ++i)
		for(int j=y/B2+1; j<20; ++j) 
			--s1[i][j];
	for(int i=x/B2+1; i<20; ++i)
		for(int j=y/B1+1,jr=(y/B2+1)*18; j<jr; ++j) 
			--s2[i][j];
	for(int i=x/B1+1,ir=(x/B2+1)*18; i<ir; ++i)	
		for(int j=y/B1+1,jr=(y/B2+1)*18; j<jr; ++j) 
			--s3[i][j];
	for(int i=x+1,ir=(x/B1+1)*B1; i<=n&&i<ir; ++i) (b[i]>y)&&(--s4[i]);
	for(int i=y+1,ir=(y/B1+1)*B1,sdt=(x/B1+1)*B1; i<=n&&i<=ir; ++i) 
	(id[i]>=sdt)&&(--s4[id[i]]);
}
int getsum(int x)
{
	int y=b[x]-1;
	return s0[x/B2][y/B2]+s1[x/B1][y/B2]+s2[x/B2][y/B1]+s3[x/B1][y/B1]+s4[x];
}
void solve1()
{
	for(int i=1; i<=n; ++i) ++o[a[i]];
	for(int i=1; i<=n; ++i) o[i]+=o[i-1];
	for(int i=1; i<=n; ++i) b[i]=o[a[i]]--;
	for(int i=1; i<=n; ++i) id[b[i]]=i;
	for(int i=n; i>=1; --i)
	{
		if(nxt[i]) erase(nxt[i]);
		insert(i);
		for(query t:v1[i]) 
		{
			ll s=0;
			for(int j=t.l; j<=t.r; ++j) 
			s+=getsum(j),(lst[j]>i)&&(s-=getsum(lst[j]));
			ans[t.id]+=s*t.f;
		}
	}
	return ;
}
void solve2()
{
	for(int i=1; i<=n; ++i) o[i]=0;
	for(int i=1; i<=n; ++i) ++o[a[i]];
	for(int i=1; i<=n; ++i) o[i]+=o[i-1];
	for(int i=1; i<=n; ++i) b[i]=o[a[i]]--;
	for(int i=1; i<=n; ++i) id[b[i]]=i;
	for(int i=1; i<=n; ++i)
	{
		if(lst[i]) erase(R(lst[i]));
		insert(R(i));
		for(query t:v2[i]) 
		{
			ll s=0;
			for(int j=t.l; j<=t.r; ++j) 
			s+=getsum(R(j)),(nxt[j]&&nxt[j]<i)&&(s-=getsum(R(nxt[j])));
			ans[t.id]+=s*t.f;
		}
	}
	return ;
}
signed main()
{
    for(int i=1; i<=n; ++i) a[i]=n+1-read();
    for(int i=1; i<=n; ++i) (pos[a[i]])&&(lst[i]=pos[a[i]]),pos[a[i]]=i;
    for(int i=1; i<=n; ++i) pos[i]=0;
    for(int i=n; i>=1; --i) (pos[a[i]])&&(nxt[i]=pos[a[i]]),pos[a[i]]=i;	
    m=read(),B=n/sqrt(m)+1;
    for(int i=1; i<=m; ++i) q[i].l=read(),q[i].r=read(),q[i].id=i,q[i].bl=q[i].l/B;
    sort(q+1,q+m+1);
    for(int i=1,l=1,r=1; i<=m; ++i) 
    {
    	if(r<q[i].r) v1[l].push_back((query){i,r+1,q[i].r,1}),r=q[i].r;
    	if(l>q[i].l) v2[r].push_back((query){i,q[i].l,l-1,1}),l=q[i].l;
		if(r>q[i].r) v1[l].push_back((query){i,q[i].r+1,r,-1}),r=q[i].r;
		if(l<q[i].l) v2[r].push_back((query){i,l,q[i].l-1,-1}),l=q[i].l;
    }
    solve1(),
    memset(s0,0,sizeof(s0)),
    memset(s1,0,sizeof(s1)),
    memset(s2,0,sizeof(s2)),
    memset(s3,0,sizeof(s3)),
    memset(s4,0,sizeof(s4)),
    reverse(a+1,a+n+1);
    for(int i=1; i<=n; ++i) a[i]=n+1-a[i];
    solve2();
    for(int i=1; i<=m; ++i) ans[i]+=ans[i-1];
    for(int i=1; i<=m; ++i) lxl[q[i].id]=ans[i];
    for(int i=1; i<=m; ++i) printf("%lld\n",lxl[i]);
	return 0;
}
```

---

## 作者：Butterfly_qwq (赞：4)

有意思的题目。

**以下复杂度分析按 $n,m$ 计算。**

[双倍经验](https://www.luogu.com.cn/problem/P7448)。

[弱化版](https://www.luogu.com.cn/problem/P5047)。

首先弱化版虽然有 $O(n^{\sqrt{2}})$ 做法。但是正常人还是写 $O(n^{\frac{3}{2}})$ 做法的，所以这题人做的方法肯定不弱于 $O(n^{\frac{3}{2}})$。

弱化版告诉我们要二离，于是我们二离。

二离之后就变成了一个 $O(n)$ 次单点修改，$O(n^{\frac{3}{2}})$ 矩阵求和的二维问题，**其中第二维的值依赖且仅依赖于第一维的值**。

简单的二维树状数组或树套树没办法平衡这个复杂度，考虑在弱化版中我们平衡复杂度是用的分块。

可是那道题二离之后是一维问题，自然可以分块，但是这道题二离之后是一个二维问题，怎么办呢？

这时候，奇技淫巧二维分块就该上场了。

分一次块谁都会做，而且谁都知道不能过。

这时候，我们还是通过一个弱化问题引入：[线段树板子](https://www.luogu.com.cn/problem/P3372)怎么做到单次操作 $O(n^{\frac{1}{3}})$？

这个问题很久以前我在我的博客里专门讨论过（但显然不是因为这道题），具体出门左转到[这里](https://www.luogu.com.cn/article/s0eqvy0o)。

同理，二维情况也可以分两层（或者说四层）。

考虑分四种块，分别为大块、长块、高块、小块。大小分别为 $n^{\frac{3}{4}}\times n^{\frac{3}{4}}$，$n^{\frac{3}{4}}\times n^{\frac{1}{2}}$，$n^{\frac{1}{2}}\times n^{\frac{3}{4}}$，$n^{\frac{1}{2}}\times n^{\frac{1}{2}}$。

xfrvq 的图不错，现在他是我的了。

![](https://cdn.luogu.com.cn/upload/image_hosting/d5tnp5jb.png)

就是这样。

这四种块都很好处理，那么就做完了！

但是我们似乎忽略了一点：散块（图中黄色部分）！

散块信息量巨大，显然没办法直接维护。

这时候之前的一个性质就派上用场了。

翻翻笔记，我之前加粗了，看看你们有没有标红？

看来大家都没记笔记，那么我重复一遍：

**其中第二维的值依赖且仅依赖于第一维的值**。

我们可以对于右侧，枚举 $x$ 的值，看一看 $y$ 值是否在右侧，是的话就加上贡献，上侧也同理。

注意右上不要算重就行了。

Code:

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int B=141,B1=5688,B2=316,A1=25,A2=350,Ad=18,N=500005;
int n,m,a[N],lst[N],nxt[N],rp[N];
namespace query
{
	int blk[N],ans[N];
	struct Que
	{
		int l,r,id,sum;
		bool operator<(const Que &a)const
		{
			if(blk[l]==blk[a.l])return r<a.r;
			return blk[l]<blk[a.l];
		}
	}q[N];
	struct que
	{
		int l,r,id,op;
	};
	vector<que> ql[N],qr[N];
}
using namespace query;
namespace blk2d
{
	int lk[A1][A1],sk[A2][A2],hk[A2][A1],wk[A1][A2],pk[N<<1],cnt[N<<1],rec[N<<1],rid[N<<1];
	void ins(int u)
	{
		int v=rec[u];
		for(int i=u/B1+1;i<A1;i++)for(int j=v/B1+1;j<A1;j++)lk[i][j]++;
		for(int i=u/B2+1;i<(u/B1+1)*Ad;i++)for(int j=v/B1+1;j<A1;j++)hk[i][j]++;
		for(int i=u/B1+1;i<A1;i++)for(int j=v/B2+1;j<(v/B1+1)*Ad;j++)wk[i][j]++;
		for(int i=u/B2+1;i<(u/B1+1)*Ad;i++)for(int j=v/B2+1;j<(v/B1+1)*Ad;j++)sk[i][j]++;
		for(int i=u+1;i<=n&&i< (u/B2+1)*B2;i++)if(rec[i]>v)pk[i]++;
		for(int i=v+1;i<=n&&i<=(v/B2+1)*B2;i++)if(rid[i]>=(u/B2+1)*B2)pk[rid[i]]++;
	}
	void del(int u)
	{
		int v=rec[u];
		for(int i=u/B1+1;i<A1;i++)for(int j=v/B1+1;j<A1;j++)lk[i][j]--;
		for(int i=u/B2+1;i<(u/B1+1)*Ad;i++)for(int j=v/B1+1;j<A1;j++)hk[i][j]--;
		for(int i=u/B1+1;i<A1;i++)for(int j=v/B2+1;j<(v/B1+1)*Ad;j++)wk[i][j]--;
		for(int i=u/B2+1;i<(u/B1+1)*Ad;i++)for(int j=v/B2+1;j<(v/B1+1)*Ad;j++)sk[i][j]--;
		for(int i=u+1;i<=n&&i< (u/B2+1)*B2;i++)if(rec[i]>v)pk[i]--;
		for(int i=v+1;i<=n&&i<=(v/B2+1)*B2;i++)if(rid[i]>=(u/B2+1)*B2)pk[rid[i]]--;
	}
	int getsum(int u)
	{
		int v=rec[u]-1;
		return lk[u/B1][v/B1]+hk[u/B2][v/B1]+wk[u/B1][v/B2]+sk[u/B2][v/B2]+pk[u];
	}
}
using namespace blk2d;
void solver()
{
	for(int i=1;i<=n;i++)cnt[a[i]]++;
	for(int i=1;i<=n;i++)cnt[i]+=cnt[i-1];
	for(int i=1;i<=n;i++)rec[i]=cnt[a[i]]--;
	for(int i=1;i<=n;i++)rid[rec[i]]=i;
	for(int i=n,res;i;i--)
	{
		if(nxt[i])del(nxt[i]);
		ins(i);
		for(que qu:qr[i])
		{
			res=0;
			for(int j=qu.l;j<=qu.r;j++)
			{
				res+=getsum(j);
				if(lst[j]>i&&lst[j])res-=getsum(lst[j]);
			}
			q[qu.id].sum+=res*qu.op;
		}
	}
}
void solvel()
{
	for(int i=1;i<=n;i++)cnt[a[i]]++;
	for(int i=1;i<=n;i++)cnt[i]+=cnt[i-1];
	for(int i=1;i<=n;i++)rec[i]=cnt[a[i]]--;
	for(int i=1;i<=n;i++)rid[rec[i]]=i;
	for(int i=1,res;i<=n;i++)
	{
		if(lst[i])del(n+1-lst[i]);
		ins(n+1-i);
		for(que qu:ql[i])
		{
			res=0;
			for(int j=qu.l;j<=qu.r;j++)
			{
				res+=getsum(n+1-j);
				if(nxt[j]<i&&nxt[j])res-=getsum(n+1-nxt[j]);
			}
			q[qu.id].sum+=res*qu.op;
		}
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]=n+1-a[i];
		blk[i]=(i-1)/B+1;
	}
	for(int i=1;i<=n;i++)
	{
		lst[i]=rp[a[i]];
		rp[a[i]]=i;
	}
	memset(rp,0,sizeof(rp));
	for(int i=n;i;i--)
	{
		nxt[i]=rp[a[i]];
		rp[a[i]]=i;
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>q[i].l>>q[i].r;
		q[i].id=i;
	}
	sort(q+1,q+m+1);
	int l=1,r=0;
	for(int i=1;i<=m;i++)
	{
		if(q[i].l<l)
		{
			ql[r].push_back({q[i].l,l-1,i,1});
			l=q[i].l;
		}
		if(q[i].r>r)
		{
			qr[l].push_back({r+1,q[i].r,i,1});
   		r=q[i].r;
		}
		if(q[i].l>l)
		{
			ql[r].push_back({l,q[i].l-1,i,-1});
   		l=q[i].l;
		}
		if(q[i].r<r)
		{
			qr[l].push_back({q[i].r+1,r,i,-1});
   		r=q[i].r;
		}
	}
	solver();
	memset(lk,0,sizeof(lk));
	memset(sk,0,sizeof(sk));
	memset(hk,0,sizeof(hk));
	memset(wk,0,sizeof(wk));
	memset(pk,0,sizeof(pk));
	memset(cnt,0,sizeof(cnt));
	memset(rec,0,sizeof(rec));
	memset(rid,0,sizeof(rid));
	reverse(a+1,a+n+1);
	for(int i=1;i<=n;i++)a[i]=n+1-a[i];
	solvel();
	for(int i=1;i<=m;i++)q[i].sum+=q[i-1].sum;
	for(int i=1;i<=m;i++)ans[q[i].id]=q[i].sum;
	for(int i=1;i<=m;i++)cout<<ans[i]<<'\n';
}
```

---

## 作者：Cat_shao (赞：3)

### 题意

给定一个长度为 $n$ 的序列 $a$ ，询问 $m$ 次区间中有多少本质不同逆序对。

$1 \le n \le 10^5, \ 1 \le m \le 5 \times 10^5, \ 1 \le a_i \le 10^5$ 。

### 普通莫队怎么做？

>转移，即计算左、右端点的扩张、收缩： $[l, r] \to \ \begin{array}{l} [l - 1, r] \\ [l + 1, r] \\ [l, r - 1] \\ [l, r + 1]\end{array}$
>
>贡献，即转移为这次询问的答案增加了多少。（通常答案是个数字）
> 
> $(p, q)$ 与 $(x, y)$ 本质相同指的是 $a_p = a_x$ 且 $a_q = a_y$ 。 $(p, q)$ 和 $(x, y)$ 可以不是逆序对。下文默认对于任意数对 $(x, y)$ 都有 $x < y$ 。

我们发现这个问题用莫队解决。以右端点扩张为例，$[l, r - 1] \to [l, r]$ 。我们要找，有多少个 $i$ 在 $[l, r - 1]$ 中使得 $(i, r)$ 与其他逆序对本质不同。

1. 记 $r'$ 是从 $r$ 起从右往左数第一个值为 $a_r$ 的位置 ，也就是 $\begin{aligned} r' = \max_{x < r \text{且} a_x = a_r} \{x \} \end{aligned}$ 。对于任意一个 $i < r'$ ，$(i, r')$ 与 $(i, r)$ 组成的数对本质相同。也就是说能产生贡献的 $i$ 只能在 $[r', r]$ 中。
2. 在 $[l, r - 1]$ 中有若干个位置，它们的值相同，与 $r$ 只能组成一对本质不同的数对。规定 $a_l, a_{l + 1}, \ldots, a_{i - 1}$ 中没有一个跟 $a_i$ 相同。这样数能做到不重不漏。
3. 最后要满足 $(i, r)$ 是逆序对，也就是 $a_i > a_r$ 。

一三两个条件长得像二维偏序。我们把上述这些条件转换为平面上的单点修改、矩形数点（求和）。把 $[l, r - 1]$ 中，从左到右数，第一次出现值 $a_j$ 的位置 $j$ （也就是 $a_l, a_{l + 1}, \ldots, a_{j - 1}$ 没有一个跟 $a_j$ 相同），以一个点 $(j, a_j)$ 加入到平面中。点 $(i, a_i)$ 只能出现在


$$
\boxed{\begin{matrix}
  &  (r, \infty) \\\\\\
(r', a_{r} +1) & 
\end{matrix}}
$$

莫队每转移一次，我们需要动态维护平面上的点，并矩形求和。单点修改、矩形求和没法做到两个的时间复杂度都是 $O(1)$ 。为降低转移的时间复杂度，我们考虑莫队二次离线。

### 莫队二次离线

（这道题的贡献没法拆开算，即 $r$ 对 $[l, r - 1]$ 的贡献不等于 $r$ 对 $[1, r - 1]$ 的贡献减 $r$ 对 $[1, l - 1]$ 的贡献）

以左端点为 $l$ ，右端点扩张为例。把上一节所说满足条件 2 的 $i$ ，作为点全部加入到平面中。比如说 $[l, r - 1] \to [l, r]$ ，平面上 $x$ 坐标大于 $r$ 的点不会影响到计算的贡献。进行矩形求和就能求出贡献。

扫描线，从 $n$ 到 1 ，扫的过程中动态维护平面上的点。扫到 $l$ ，就处理左端点为 $l$ 的转移（注意到扩张和收缩的贡献只有符号不同，可以一起算）。

我们要进行 $\Theta(n)$ 次单点修改，$\Theta(n \sqrt{m})$ 次矩形求和。需要一个单点修改时间复杂度 $O(\sqrt{n})$ ，矩形求和时间复杂度 $O(1)$ 的数据结构。由这个复杂度不难想到分块。

### 只有 $\Theta(n)$ 种矩形求和

下面要讲的分块依赖于这个性质。观察这个矩形。

$$
\boxed{\begin{matrix}
  &  (r, \infty) \\\\\\
(r', a_{r} +1) & 
\end{matrix}}
$$

$\infty$ 就当做是 $n$ ，本题的值域上界。平面上 $x$ 坐标为 $r$ 的点顶多就一个，特判这个点，把 $r'$ 换成 $r' + 1$ ，并把 $a_r + 1$ 换成 $a_r$ 。

$$
\boxed{\begin{matrix}
  &  (r, \infty) \\\\\\
(r' + 1, a_{r}) & 
\end{matrix}}
$$

所有点（平面上的点，矩形的端点）的 $y$ 坐标翻转过来。翻转：记 $\operatorname{rev}(x) = n - x + 1$。

$$
\boxed{\begin{matrix}
  &  (r, \operatorname{rev}(a_{r})) \\\\\\
(r' + 1, 1) & 
\end{matrix}}
$$

并写成差分形式。

$$
\boxed{\begin{matrix}
  &  (r, \operatorname{rev}(a_{r})) \\\\\\
(1, 1) & 
\end{matrix}}
-
\boxed{\begin{matrix}
  &  (r', \operatorname{rev}(a_{r'})) \\\\\\
(1, 1) & 
\end{matrix}}
$$

我们发现 $\Theta(n\sqrt{m})$ 个矩形求和本质上只有 $\Theta(n)$ 种。

### “离散化”

下面要讲的分块也依赖于这个性质。平面上出现过的点 $x$ 坐标互不相同，$y$ 坐标有相同的。我们考虑把 $y$ 坐标“离散化”，使得平面上出现过的点的 $y$ 坐标互不相同。这么做，前面的矩形求和就有了细微的差别，请读者自行思考 $(r, a_r)$ 和 $(r', a_{r'})$ 会不会被差分后的两个矩形包含。

具体讲下怎么离散化。开一个数组 $cnt$ ，$cnt[i]$ 记录 $i$ 在 $a$ 中出现了多少次。我们规定相同的值，位置越靠左离散化后的值越大。记离散化后的序列是 $a'$ 。统计完 $cnt$ 后，对 $cnt$ 求前缀和并存回 $cnt$ 。从 $n$ 到 1 扫，扫到 $i$ ，让 $a'_i = cnt[a_i]$ ，然后 $cnt[a_i] = cnt[a_i] - 1$ 。

```cpp
for (int i = 1; i <= n; ++i) {
    cnt[a[i]]++;
}
partial_sum(cnt + 1, cnt + n + 1, cnt + 1);
for (int i = 1; i <= n; ++i) {
    a[i] = cnt[a[i]]--;
}
```

### [二维分块](https://www.luogu.com.cn/problem/U210802)

需要维护的平面是 $n \times n$ 的，我们按如下方式进行分块：
1. 将平面分成 $\sqrt{n}$ 个 $n^{0.75} \times n^{0.75}$ 的橙块。
2. 每个橙块内再分成 $\sqrt{n}$ 个 $n^{0.5} \times n^{0.5}$ 个蓝块。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/orange.svg)

以橙块为单位维护二维前缀和，每个橙块内分别以蓝块为单位维护二维前缀和。

同时将整个平面横着分为一个个 $n \times n^{0.75}$ 的区域，每个区域中分成 $\sqrt{n}$ 个 $n^{0.75} \times n^{0.5}$ 的黄块。每个区域分别以黄块为单位维护二维前缀和。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/yellow.svg)

竖着分为一个个 $n^{0.75} \times n$ 的区域，每个区域被分成 $\sqrt{n}$ 个 $n^{0.5} \times n^{0.75}$ 的绿块。每个区域分别以绿块为单位维护二维前缀和。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/green.svg)

加入一个点时，需要更新 $O(\sqrt{n})$ 个以橙块、蓝块、黄块、绿块为单位的二维前缀和（将包含新增点的二维前缀和都加 1），因而加入一个点时间复杂度 $O(\sqrt{n})$ 。

这样分块空间复杂度 $O(n)$ 。

-------------------

如下图，一次求和的矩形可分为整块部分和散块部分。显然整块部分将对应橙块、黄块、绿块、蓝块维护好的二维前缀和累加，时间复杂度 $O(1)$ 。散块部分点分布稀疏，不能通过进一步分块解决，因为进一步分块 $O(n^2)$ 的空间是绝对开不下来的。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/query.svg)

考虑反向维护。前面说过虽然共有 $O(n \sqrt{m})$ 次矩形求和，但本质只有 $O(n)$ **种**矩形求和。每新增一个点求出它在哪几种矩形求和的散块部分中。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/purple.svg)

以散块中横着的部分为例。将 $y$ 坐标分为 $\sqrt{n}$ 块。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/y.svg)

横着的散块高度 $< n^{0.5}$ ，只会被分到一个块中。一个点只会被分到一个块中。加入一个点，枚举这个点所在块中的散块哪些覆盖这个点。

看似这么做是 $\Theta(n^2)$ 的。然而加入的点 $y$ 坐标互不相同，一个块内只会有 $O(\sqrt{n})$ 个点，也就是说每种散块至多被枚举 $O(\sqrt{n})$ 次。共有 $\Theta(n)$ 种散块，因此这么做是 $O(n\sqrt{n})$ 的。

矩形求和时，散块中有多少个点已经在加点的时候求好了，自然是 $O(1)$ 。

对于竖着的散块就对 $x$ 坐标分为 $\sqrt{n}$ 块，与横着的散块几乎一样。

在写代码的时候，如果直接将橙块边长设为 $n^{0.75}$ 并取整，蓝块边长设为 $n^{0.5}$ 并取整，会出现一个蓝块一半在一个橙块一半在另一个橙块。为方便写代码，可以将 $n$ 调整为 $\left \lceil n^{0.25} \right \rceil ^ 4$ ，保证了 $n^{0.75}$ 、 $n^{0.5}$ 都是整数，每个蓝块只在一个橙块中。


### 实现

[代码](https://www.luogu.com.cn/paste/4sziu1vs) | [双倍经验](https://www.luogu.com.cn/problem/P7601) | [LOJ 题目链接](https://loj.ac/p/6762) | [同样是二维分块 rcn](https://www.luogu.com.cn/problem/P7721)

如有错误麻烦大家指出。谢谢大家。以及评论区禁止无意义。

---

## 作者：xfrvq (赞：3)

[$\tt Link$](/problem/P7601)

## 题意

多次求区间逆序对，但是如果多个逆序对满足分别位置的值相等，那我们就只算一次。

$a_i\le n\le10^5,m\le5\times10^5$。

## 选择方法&拆贡献

首先发现这个问题严格难于 [区间逆序对](/problem/P5047) 问题。区间逆序对的常见做法是 **分块** 或者 **二次离线莫队**，这里选择更好写且常数小的 **二次离线莫队**。

标识：记 $P_i,N_i$ 分别为与 $i$ 位置颜色相同的上一个/下一个位置。

假如我们莫队，那么从 $[l,r-1]$ 变成 $[l,r]$，答案会增加 $[P_r,r]$ 新出现的 $\gt a_r$ 的数的种类数。拆一下，就是 $[l,r]$ 中 $\gt a_r$ 的数的种类数，减去 $[l,P_r]$ 中 $\gt a_r$ 的数的种类数。

## 离线后转化问题

即使经过转化，我们要求的东西还是和 **种类数** 有关而非**总数**。所以我们对数组做一次扫描线，在扫到 $i$ 时，计算有关 $i$ 的贡献，同时**把 $P_i$ 的贡献消除**就行了。

于是现在的问题就是 **总数**，要求 **单点加，区间大于 $x$ 的数的个数**，考虑将其转化为二维形式，第一维是下标，第二维是值域，那么原问题就是一个 **带权二维数点**。

鉴于莫队二次离线的原理，我们把问题转换为：

+ 扫描线过程中，拆出 $O(n)$ 个修改（包括插入 $i$ 以及删去 $P_i$）
+ 给每个询问计算贡献，总共会有 $O(n\sqrt m)$ 次二维的查询。

于是你要合理的平衡复杂度，做到 $O(\sqrt n)$ 修改 $O(1)$ 查询。

别漏了几个性质。

+ 所有有值的点，$x$ 坐标互不相同，$y$ 坐标可能相同（因为是值域）。
+ 我们有一种方法让 $y$ 坐标也互不相同，即对于相同的 $y$ 坐标值，让 $x$ 坐标越小的 $y$ 坐标越小。

## 二维分块

~~刚看到这个概念以及这个问题的时候，我甚至已经准备好直接用 $\sout{n^{\frac 23}}$ 做块长暴力了~~

**注意：下面介绍的是一种 $O(\sqrt n)$ 前缀矩形加 $O(1)$ 单点查询的数据结构，原问题是 $O(\sqrt n)$ 单点加 $O(1)$ 前缀矩形和，二者本质一样。**

举个例子，假设我们要加的是这么一个矩形（左下角是原点，右上角是询问点）。

![](https://cdn.luogu.com.cn/upload/image_hosting/76po4cy3.png)

为了方便，以下记 $\mathbf a=n^{0.25},\mathbf b=n^{0.5},\mathbf c=n^{0.75}$。

首先因为整块复杂度要保证，所以块数是 $O(\sqrt n)$ 的，于是你就应该用 $\bf c\times c$ 来分块，这样总块数就是 $O(\mathbf{a\times a}=\sqrt n)$ 的。

![](https://cdn.luogu.com.cn/upload/image_hosting/04pkufgz.png)

但是我们整块复杂度保证，散块又不行了。于是考虑在现在的灰色部分分块用来辅助原来的散块，分出

+ $\bf a\times b$ 个 $\bf c\times b$ 的块
+ $\bf b\times a$ 个 $\bf b\times c$ 的块
+ $\bf b\times b$ 个 $\bf b\times b$ 的块

![](https://cdn.luogu.com.cn/upload/image_hosting/d5tnp5jb.png)

现在总共分了 $4$ 种块，对于每种块我们都维护块和。

现在来算一下复杂度。

+ 对于红色块而言，它一定不超过 $\sqrt n$ 个。
+ 对于橙色块而言，它一行最多只有 $n\div\mathbf c=n^{0.25}$ 个，一列最多只有 $\mathbf{c\div b}=n^{0.25}$ 个，乘起来不超过 $\sqrt n$ 个。
+ 对于蓝色块而言，它一行最多只有 $\mathbf{c\div b}=n^{0.25}$ 个，一列最多只有 $n\div\mathbf c=n^{0.25}$ 个，乘起来不超过 $\sqrt n$ 个。
+ 对于绿色块而言，它一行/一列最多只有 $\mathbf{c\div b}=n^{0.25}$ 个，乘起来也不超过 $\sqrt n$ 个。
+ 散块需要结合这题的特殊性质才可做，这里不作讨论，下面讲。

那散块如何做呢？

首先，散块本身的定义是：**一个询问覆盖了一个点但没有完全覆盖这个点所在的 $\bf b\times b$ 块**，就是上图中的黄色部分。

上文提到的性质，可以理解为：保证所有的 $x$ 坐标或 $y$ 坐标互不相同。

**基于性质**，我们把散块拆分为三部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/ntxsmopv.png)

对于紫色部分，枚举紫色范围内 $x$ 坐标，然后查看 $y$ 坐标是否也在紫色范围内，如果是就加上贡献。

对于粉色部分，枚举粉色范围内 $y$ 坐标，然后查看 $x$ 坐标是否也在粉色范围内，如果是就加上贡献。

你可以在紫色部分的时候算上蓝色部分，也可以在粉色部分的时候算上蓝色部分，不要算重就行了。

## 代码

[$\tt Code$](https://www.luogu.com.cn/paste/j50a2b67)

用宏定义，多个相同功能函数使用一个代替等的简化，我写的还算简洁，不到 2.5k，不到 100 行。

~~事实是因为使用大量宏定义简化导致一个字母打错调了一天~~

---

## 作者：lzyqwq (赞：0)

::::info[题意]
- 给出长度为 $n$ 的序列 $a$，$q$ 次询问一个区间本质不同的逆序对数量。
- $n\le 10^5$，$q\le 5\times 10^5$。
::::

参照没有“本质不同”限制的做法，莫队二次离线，考虑如何转移。以 $r-1\rightarrow r$ 的情况为例。

记 $i$ 的前驱、后继分别为 $\text{pr}_i,\text{nx}_i$。记 $w([l,r],x)$ 为 $[l,r]$ 内 $>x$ 的颜色数。若 $\text{pr}_{r}>l$，则对于仅出现在 $(\text{pr}_{r},r)$ 内且 $>a_{r}$ 的颜色，均可以与 $a_{r}$ 构成一种新的逆序对，一共有 $w([l,r-1],a_r) - w([l,\text{pr}_{r}],a_r)$ 种，而注意到 $\text{pr}_r$ 对 $w([l,\text{pr}_r],a_r)$ 没有贡献，因此可以写成 $w([l,r-1],a_r) - w([l,\text{pr}_{r}-1],a_{\text{pr}_r})$。否则答案为 $w([l,r-1],a_r)$。

空间可以通过在 $l$ 上挂一个区间做到线性。现在问题变成 $\mathcal{O}(n\sqrt q)$ 次查询一个区间内大于某个值的颜色数。显然要求 $\mathcal{O}(1)$。

考虑从 $n$ 到 $1$ 扫描线，把 $(i,a_i)$ 看成平面上的点，表示这种颜色 $a_i$ 出现在下标 $i$ 的位置。每种颜色在其最左边出现的位置统计贡献，加入一个点后删除其后继的贡献。我们发现贡献都被统一成了 $w([l,r-1],a_r)$ 的形式。这个式子的答案是下标在 $[l,r-1]$ 内且值大于 $a_r$ 的点的个数。由于我们只加入了下标 $\ge l$ 的点，因此第一个限制可以改写成下标小于 $r$。这样就变成了 $2-\text{side}$ 矩形数点。为了方便我们可以通过翻转值域等方式转化成右上角矩形数点。并且此时我们将大于号均改成大于等于号，由于下标互不相同，一次查询只可能会多算 $(r,a_r)$ 这个点。再记录一下每个点是否被加入来减去多余的贡献即可。

下文用“询问的点”指代以该点为左下角的右上角矩形的询问。

考虑加入一个点后会对哪些上述形式的询问产生贡献，显然是其左下矩形的范围。问题来到 $\mathcal{O}(n)$ 次矩形加。

接下来进入二维分块。可以参考其他题解的插图。简单来说就是对两维分别以 $n^{0.75}$ 和 $n^{0.5}$ 为块长分块（没把常数写进去，注意要让大的块包含小的块），那么平面上会形成四种矩形块：

- $n^{0.75}\times n^{0.75}$。
- $n^{0.5}\times n^{0.75}$。
- $n^{0.75}\times n^{0.5}$。
- $n^{\times 0.5}\times n^{0.5}$。


那么我们可以将矩形加的范围拆成左下角的一类块、一类块右侧的二类块、一类块上侧的三类块、一类块右上方的四类块各 $\mathcal{O}(\sqrt n)$ 个，以及剩下的“L” 字形区域。考虑对于这五种区域的标记，使得对于任意一个**有询问**的点，其对应五种标记的和为询问的答案。

对四类整块打标记。至于剩下的“L”形区域比较棘手。考虑钦定 $a$ 种重复出现的数靠右的更大，将序列 $a$ 变成一个排列 $b$。**不改变扫描线加入点的方式**，仅将加入和询问的点从 $(i,a_i)$ 改成 $(i,b_i)$，不会影响询问的答案。因为在 $b$ 中相同的数左边更小，不会落到 $>b_r$ 的区域中，而原本与 $a_r$ 不同的数对询问的贡献不变。

这样一来，所有询问的点的横纵坐标互不相同。考虑加入一个点会对哪些询问产生贡献，由于“L”形区域的宽度为 $\mathcal{O}(\sqrt n)$，因此这个范围内的询问个数也只可能有 $\mathcal{O}(\sqrt n)$ 种。枚举每种横纵坐标对应的询问即可。注意不要把转角区域重复贡献。

这样一来就可以做到 $\mathcal{O}(\sqrt n)$ 矩形加 $\mathcal{O}(1)$ 单点查。然后就做完了。

时间复杂度 $\mathcal{O}(n\sqrt q)$。空间复杂度 $\mathcal{O}(q)$。不卡常。


::::info[AC 代码]
```cpp
#include <bits/stdc++.h>
#define eb emplace_back
#define me memset
template<class T> void read(T &x) {
    x = 0; T f = 1; char c = getchar();
    for (; c < 48 || c > 57; c = getchar()) if (c == 45) f = -1;
    for (; c > 47 && c < 58; c = getchar()) x = x * 10 + c - 48; x *= f;
}
template<class T> void write(T x) {
    if (x > 9) write(x / 10); putchar(x % 10 + 48);
}
template<class T> void print(T x, char ed = '\n') {
    if (x < 0) putchar('-'), x = -x; write(x), putchar(ed);
}
using namespace std; typedef long long ll; const int N = 100005, M = 500005;
int n, q, a[N], b[N], c[N], pr[N], nx[N], B, ps[N], X[N], Y[N], rx[N], ry[N];
struct QR { int l, r, v, id; } Q[M]; ll ans[M], df[M]; vector<QR> g1[N], g2[N];
struct BLOCK {
    int B1, B2, s1[500][500], s2[500][500], s3[500][500], s4[500][500],
        s5[N], id1[N], id2[N], bl1[N], br1[N], bl2[N], br2[N], vs[N];
    void I() {
        B1 = pow(n, 0.75); B2 = sqrt(n);
        for (int i = 1; i <= n; ++i) id1[i] = (i - 1) / B1 + 1;
        for (int i = 1; i <= id1[n]; ++i) {
            bl1[i] = br1[i - 1] + 1; br1[i] = min(n, i * B1);
            for (int p = bl1[i], r; p <= br1[i]; p += B2) {
                r = min(br1[i], p + B2 - 1); ++id2[0];
                for (int j = p; j <= r; ++j) id2[j] = id2[0];
                bl2[id2[0]] = p; br2[id2[0]] = r;
            }
        }
    }
    void C() {
        me(s1, 0, sizeof s1); me(s2, 0, sizeof s2); me(s3, 0, sizeof s3);
        me(s4, 0, sizeof s4); me(s5, 0, sizeof s5); me(vs, 0, sizeof vs);
    }
    void U(int id, int v) {
        vs[id] += v; int x = X[id], y = Y[id];
        for (int i = 1; i < id1[x]; ++i)
            for (int j = 1; j < id1[y]; ++j) s1[i][j] += v;
        for (int i = id2[bl1[id1[x]]]; i < id2[x]; ++i)
            for (int j = 1; j < id1[y]; ++j) s2[i][j] += v;
        for (int j = id2[bl1[id1[y]]]; j < id2[y]; ++j)
            for (int i = 1; i < id1[x]; ++i) s3[i][j] += v;
        for (int i = id2[bl1[id1[x]]]; i < id2[x]; ++i)
            for (int j = id2[bl1[id1[y]]]; j < id2[y]; ++j) s4[i][j] += v;
        for (int i = bl2[id2[x]]; i <= x; ++i)
            if (Y[rx[i]] <= y) s5[rx[i]] += v;
        for (int j = bl2[id2[y]]; j <= y; ++j)
            if (X[ry[j]] < bl2[id2[x]]) s5[ry[j]] += v;
    }
    int Q(int i) {
        return s1[id1[X[i]]][id1[Y[i]]] + s2[id2[X[i]]][id1[Y[i]]] - vs[i] +
               s3[id1[X[i]]][id2[Y[i]]] + s4[id2[X[i]]][id2[Y[i]]] + s5[i];
    }
} ds;
void solve1() {
    for (int i = 1; i <= n; ++i) rx[i] = X[i] = ry[Y[i] = n - b[i] + 1] = i;
    for (int i = 1; i <= n; ++i) {
        if (pr[i]) ds.U(pr[i], -1); ds.U(i, 1);
        for (auto [l, r, v, id] : g1[i])
            for (int j = l, s = 0; j <= r; ++j) {
                s = ds.Q(j); if (nx[j] < i) s -= ds.Q(nx[j]); df[id] += v * s;
            }
    }
}
void solve2() {
    for (int i = 1; i <= n; ++i) rx[X[i] = n - i + 1] = ry[Y[i] = b[i]] = i;
    for (int i = n; i >= 1; --i) {
        if (nx[i] <= n) ds.U(nx[i], -1); ds.U(i, 1);
        for (auto [l, r, v, id] : g2[i])
            for (int j = l, s = 0; j <= r; ++j) {
                s = ds.Q(j); if (pr[j] > i) s -= ds.Q(pr[j]); df[id] += v * s;
            }
    }
}
signed main() {
    read(n); for (int i = 1; i <= n; ++i) read(a[i]), ++c[a[i]]; ds.I();
    for (int i = 1; i <= n; ++i)
        c[i] += c[i - 1], pr[i] = ps[a[i]], ps[a[i]] = i;
    read(q); B = n / sqrt(q); for (int i = 1; i <= n; ++i) ps[i] = n + 1;
    for (int i = n; i >= 1; --i)
        b[i] = c[a[i]]--, nx[i] = ps[a[i]], ps[a[i]] = i;  
    for (int i = 1; i <= q; ++i)
        read(Q[i].l), read(Q[i].r), Q[i].id = i, Q[i].v = Q[i].l / B;
    stable_sort(Q + 1, Q + q + 1, [&](QR x, QR y) {
        return x.v != y.v ? x.v < y.v : x.v & 1 ? x.r < y.r : x.r > y.r;
    });
    for (int i = 1, l = 1, r = 0; i <= q; ++i) {
        if (l > Q[i].l) g1[r].eb(QR{Q[i].l, l - 1, 1, i}), l = Q[i].l;
        if (r < Q[i].r) g2[l].eb(QR{r + 1, Q[i].r, 1, i}), r = Q[i].r;
        if (l < Q[i].l) g1[r].eb(QR{l, Q[i].l - 1, -1, i}), l = Q[i].l;
        if (r > Q[i].r) g2[l].eb(QR{Q[i].r + 1, r, -1, i}), r = Q[i].r;
    }
    solve1(); ds.C(); solve2();
    for (int i = 1; i <= q; ++i) ans[Q[i].id] = ans[Q[i - 1].id] + df[i];
    for (int i = 1; i <= q; ++i) print(ans[i]); return 0;
}
```
::::

---

## 作者：Eterna (赞：0)

莫队二次离线，以下只讨论 $[l,r-1]$ 变为 $[l,r]$ 的情况。

我们设 $f(i,[l,r])=|\{a_j : l\le j \le r \wedge a_j > a_i\}|$。即区间 $[l,r]$ 中大于 $a_i$ 的不同数数量。

设 $r'$ 为上一个满足 $a_{r'}=a_{r}$ 的位置，则对于 $i \le r'$，数对 $(i,r')$ 和 $(i,r)$ 是本质相同的数对。

区间扩展后，答案增加区间 $[r',r]$ 中新增加的 $>a_r$ 的不同数数量。考虑先取消 $r'$ 的贡献，然后加入 $r$ 的贡献，则贡献为 $f(r,[l,r])-f(r',[l,r'])$。注意这里贡献不能差分成前缀。

令 $g(l,r)=f(r,[l,r])$，我们需要进行 $\mathcal{O}(n\sqrt{m})$ 次查询 $g(l,r)$。

莫队转移的 $g(l,r)$ 中，显然有一些 $l$ 不变，$r$ 连续的 $g(l,r)$，是 $\mathcal{O}(m)$ 个的。所以不需要拆开存。

扫描线，将所有 $g(l,r)$ 按 $l$ 从大到小排序。从后往前，每次插入 $(j,a_j)$，查询满足 $r'\le x \le r,a_x > a_r$ 的点数。注意插入要将上一个值相同的位置删掉。

就是维护二维矩阵，$\mathcal{O}(n)$ 次单点加，$\mathcal{O}(n\sqrt{m})$ 次二维前缀和查询。容易化为 $\mathcal{O}(n)$ 次二维前缀加，$\mathcal{O}(n\sqrt{m})$ 次单点查询。

这样经典的修改查询比例，启示我们使用 $\mathcal{O}(\sqrt{n})-\mathcal{O}(1)$ 的分块。

考虑以下的结构：

![](https://cdn.luogu.com.cn/upload/image_hosting/aros4k2w.png)

对于单次修改，有五种不同的块：

1.对于 $n^{0.75} \times n^{0.75}$ 的块，最多有 $\mathcal{O}(\sqrt{n})$ 个。

2.对于 $n^{0.5} \times n^{0.75}$ 的块，最多有 $\mathcal{O}(n^{0.25})$ 列和 $\mathcal{O}(n^{0.25})$ 行，总量还是 $\mathcal{O}(\sqrt{n})$ 个。

3.对于 $n^{0.75} \times n^{0.5}$ 的块，情况与上一个相同，共 $\mathcal{O}(\sqrt{n})$ 个。

4.对于 $n^{0.5} \times n^{0.5}$ 的块，最多有 $\mathcal{O}(n^{0.25})$ 列和 $\mathcal{O}(n^{0.25})$ 行，依然是 $\mathcal{O}(\sqrt{n})$ 个。

5.散块面积是 $\mathcal{O}(n^{1.5})$ 的，无法直接枚举，处理方法后面讲。

我们发现对于所有的点，它们的 $x$ 坐标互不相同，我们可以通过枚举最后那 $n^{0.5}$ 个 $x$ 坐标就可以算了。

但是 $y$ 不是互不相同的。考虑对于相同的 $a_i$，我们让左边先出现的更大。这样 $y$ 坐标就也可以互不相同了。用与 $x$ 坐标相同的方法处理即可。

总的时间复杂度为 $\mathcal{O}(n\sqrt{m})$。

本题对另一个方向的扫描线其实可以直接将序列和值域一起反转，就不需要写两个函数了。

---

## 作者：orz_z (赞：0)


区间本质不同逆序对。

$\mathcal O(n \sqrt n \times \sqrt n)$ 应该谁都会做，而且谁都知道不能过。

回顾 `P5047`，考虑莫队二次离线。

记 $f(l,r)$ 为 $[l,r]$ 中 $>a_r$ 的数的种类数。

则区间转移从 $[l,r-1]$ 变成 $[l,r]$，令 $r'$ 为 $a_r$ 上一次出现的位置，则贡献为 $f(l,r)-f(l,r')$，其他方向和一连段转移同理。

考虑到种类数难以维护，尝试通过扫描线转换为总数，问题转化为查询区间内比一个数小的数的个数，需要 $\mathcal O(n)$ 次单点修改，$\mathcal O(n \sqrt n)$ 次矩阵和查询，第一维是下标，第二维是值域，此时点的横坐标和纵坐标一一对应，即横坐标和纵坐标两两不同。

我们需要一个针对上述问题的 $\mathcal O(\sqrt n)-\mathcal O(1)$ 数据结构。

引入二维分块，即对 $n\times n$ 的矩阵进行适当地分块，使得块数 $\mathcal O(\sqrt n)$  且支持 $\mathcal O(\sqrt n)-\mathcal O(1)$ 或 $\mathcal O(1)-\mathcal O(\sqrt n)$。

首先用将整个矩形用 $n^{0.75}\times n^{0.75}$ 来分块（如图红色部分），这样总块数为 $\mathcal O(n^{0.25}\times n^{0.25}=\sqrt n)$ 的，整块复杂度保证。

考虑分剩余块，使得较小块复杂度保证，不证：

* $n^{0.25}\times n^{0.25}$ 个 $n^{0.75}\times n^{0.5}$ 大小的块，蓝色部分。
* $n^{0.25}\times n^{0.25}$ 个 $n^{0.5}\times n^{0.76}$ 大小的块，绿色部分。
* $n^{0.25}\times n^{0.25}$ 个 $n^{0.5}\times n^{0.5}$ 大小的块，橙色部分。

如图，例：$155$。

![](https://s3.bmp.ovh/imgs/2022/06/12/df0a51f0ef38837c.png)

最后考虑灰色块复杂度，由于询问横坐标和纵坐标两两不同，而灰色块宽度不超过 $\mathcal O(\sqrt n)$，涉及的询问只有 $\mathcal O(\sqrt n)$ 种，故散块修改 $\mathcal O(\sqrt n)$，查询 $\mathcal O(1)$，复杂度保证。

时间复杂度为 $\mathcal O(n\sqrt n)$，空间复杂度为 $\mathcal O(n)$。

[CODE](https://www.luogu.com.cn/paste/i2p5x8f4)







---

## 作者：Others (赞：0)

是[YLST II](https://www.luogu.com.cn/problem/P5047)的进阶版，$O(\sqrt n)-O(1)$ 的二维分块的“练手题”。

首先看数据范围 $n\le10^5,m\le5\times10^5$，这玩意儿还是区间逆序对的加强版，时间范围是 $3s$，肯定不是给更劣的复杂度，而是给常数的。这题竟然没卡空间（雾）。

考虑 YLSTII 的二离，但这题是区间不同逆序对，也就是说加入一个数时若贡献区间中有相同的数，那它的贡献区间就只能在两个数的中间，这东西又不能再差分一遍（若再差分就相当于一个点一个点算贡献，总共 $O(n\sqrt m)$ 个转移，岂不是原地爆炸？），所以就需要二维区间查询，单点修改，复杂度是 $O(\sqrt n)-O(1)$。

$O(1)$ 查询要求我们用前缀和维护，然后还要 $O(\sqrt n)$ 修改，所以两维平均一维 $O(n^{0.25})$ 的复杂度，所以这一部分块长是 $n^{0.75}$，对于 $n\times n^{0.75}$ 和 $n^{0.75}\times n$ 的矩形，我们再分一个 $n^{0.75}\times n^{0.5}$ 和 $n^{0.5}\times n^{0.75}$ 的矩形，再次之，对于 $n^{0.75}\times n^{0.75}$ 的矩形，分成 $n^{0.5}\times n^{0.5}$ 的矩形，先不考虑散块，可以发现现在可以做到 $O(\sqrt n)-O(1)$。

然后是散块，因为相同的数不影响，所以给他们钦定一个顺序，使得每个纵坐标对应唯一的横坐标，每个横坐标对应唯一的纵坐标，且横纵坐标都在 $[1,n]$ 内，于是画图发现每个点对应的散块只有至多 $O(\sqrt n)$ 个点，反过来想，每个点能以散块贡献的也只有 $O(\sqrt n)$ 个点，横坐标和纵坐标分别枚举到 $n^{0.5}\times n^{0.5}$ 的块的端点，用上面的性质去看就知道了，这东西可以直接暴力维护。

**注意：**
- $n^{0.75}$ 和 $n^{0.5}$ 必须成倍数，因为预处理会使空间时间一起爆。
- 散块贡献注意不要重复加。
- “前缀和”需要我们在某些询问时将序列倒过来或将值取反，后缀和也可以，只是有点难打。
- 莫队排序的块长是 $\frac{n}{\sqrt m}$，不然常数会有点大，但不一定会 TLE，只是增加了概率。
- 有个双黑经验[P7448](https://www.luogu.com.cn/problem/P7448)，美汁汁。

---


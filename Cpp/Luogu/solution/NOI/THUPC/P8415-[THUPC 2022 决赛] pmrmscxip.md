# [THUPC 2022 决赛] pmrmscxip

## 题目描述

给序列 $a_1,\dots,a_n$ 和排列 $b_1,\dots,b_n$，共有 $m$ 次操作：

修改操作：给定 $x,y$，将 $a_x$ 改为 $y$；

查询操作：给定 $l,r,x$，查区间 $[l,r]$ 内最长的子区间 $[l',r']$（即满足 $l\le l'\le r'\le r$），使得对 $l'\le i<r'$ 有 $a_{i+1}=b_{a_i}$，且存在 $l'\le i\le r'$ 使得 $a_i=x$。需要输出满足条件的 $r'-l'+1$ 的最大值，若不存在则输出 $0$。


## 说明/提示

$1\le n,m\le 10^6$；

$1\le a_i\le n$；

$1\le b_i\le n$，$b_i$ 互不相同；

对修改操作，满足 $1\le x,y\le n$；

对查询操作，满足 $1\le l\le r\le n$，$1\le x\le n$。

## 样例 #1

### 输入

```
8 10
1 4 7 3 8 2 4 7
5 4 8 7 1 6 3 2
2 6 6 2
2 8 8 7
1 4 3
2 6 8 3
2 4 4 3
2 4 4 3
2 6 8 4
2 5 6 2
2 1 8 1
2 1 1 6
```

### 输出

```
1
1
0
1
1
3
2
1
0
```

# 题解

## 作者：qiuzx (赞：9)

目前唯一的一篇题解有点过于抽象了，并且比较怀疑那个口胡的做法是不是真的能过~~因为我自己用那个做法没做出来~~。这里是一种比较清晰的处理方式（应该也是标期望的做法）

显然找到某个 $=x$ 的位置，然后向左向右分别延伸到最后能延伸的地方即可。这个问题相当于是单点修改一个 $01$ 序列，每次查询需要求出区间内最长的 $1$ 连续段使得其中包含某个 $x$。但这件事是比较困难的，所以需要考虑急用 $a_{i+1}=b_{a_i}$ 的性质解决这个问题。

容易发现每个极长的 $1$ 连续段其中的元素都位于 $b$ 的同一个置换环上，所以可以将所有元素先按照所处置换环分类，在同一个置换环中的元素按照环上绕圈的顺序依次重新编号。这样 $a_{i+1}=b_{a_i}$ 的限制就相当于是 $a_{i+1}=a_i+1$ 且在同一个置换环中，这里 $+1$ 是在模置换环环长的意义下进行的。这样如果我们实时维护所有极长的 $1$ 连续段，那么一个连续段所包含的元素，要么是一段区间，要么是两段区间拼起来，这就比较方便我们进行维护了。

定义一个连续段的信息为它在原序列中位置的区间，以及它包含的元素的区间（或两个区间）。则一次修改相当于是修改了 $O(1)$ 个连续段的信息。使用 set 维护所有的连续段，则对于一次查询，首先特殊处理包含某个端点的连续段，因为这些连续段的端点会被区间截掉一部分，不过由于截掉之后值仍然是连续的，所以可以快速判定是否合法并更新答案。剩余的情形中，我们只需要关心所有被 $[l,r]$ 完全包含的连续段，而这些连续段的合法性以及对答案的贡献和 $l,r$ 的具体取值无关，只和它们本身有关。

因此现在的问题转化为需要支持在线插入与删除若干五元组 $(l,r,a,b,v)$，每次查询给出 $L,R,x$，需要查询在满足 $L\le l\le r\le R,a\le x\le b$ 的所有五元组中 $v$ 的最大值。这个问题很难做到 $O(n\log^2n)$ 以内，所以需要进一步优化。可以再添加一维时间轴，即每个五元组再增加两维 $tl,tr$，表示它在 $tl$ 时刻被插入，$tr$ 时刻被删除，然后查询有一个当前时刻 $t$，这样就是刚刚问题的离线版本，需要额外满足 $tl\le t\le tr$。很自然可以想到线段树分治，将一个 $[tl,tr]$ 的五元组插入在时间轴线段树上，然后遍历整棵树，在遍历到一个点的时候用这个点上的五元组去更新这个点子树内的所有询问，这样总共是 $O(n\log n)$ 个五元组与询问，没有时间轴的限制，且可以离线。

直接做还是比较困难，因为 $L\le l\le r\le R$ 这个限制就不是很好满足。此时需要回到原题观察这些五元组的性质。注意到在任意时刻所有区间都是不交的，换句话说，所有能够去更新一组询问的五元组中的区间 $[l,r]$ 是不交的。所以我们一次更新所遇到的 $[l,r]$ 都是不交的，这样可以直接按照 $l$ 排序，那么一次询问 $L\le l\le r\le R$ 这个限制就可以直接被转化为仅关于 $l$ 的限制。于是这个问题就变成了有若干四元组 $(l,a,b,v)$ 和若干查询 $(L,R,x)$，需要查询满足 $L\le l\le R,a\le x\le b$ 的四元组中 $v$ 的最大值。这是一个平面上横线与竖线交点的问题，可以扫描线 $O(n\log n)$ 解决，所以总复杂度 $O(n\log^2n)$。

[代码](https://loj.ac/s/2092864)

---

## 作者：Zzzcr (赞：7)

模拟赛搬了，没写出来，深刻体会到自己代码能力的弱小。

我们称一段连续满足限制的区间为一个连续段，a 序列上的一个连续段的颜色集合显然由 b 序列给出的置换环上重标号后的至多两个区间构成。

把查询时被砍成两半的边界连续段暴力算下贡献。于是剩下的连续段就都是整段了。对于每个置换环分别维护。把一个区间的贡献刻画到平面上，大概就是原序列下标 $[l,r]$，在置换环上的下标 $[a,b]$，就放一个 $x\in[l,r],y\in[a,b]$，权值为 $r-l+1$ 的矩形。

一次查询 (不妨假设没有被截断的连续段) $(L,R,k)$ 相当于是求 $L\le l,r\le R,y=k$ 的最大权值，注意到任意时刻的区间 $[l,r]$ 是不交的。于是可以不考虑 $r\le R$ 的限制，也就是等价于求 $L\le x\le R,y=k$ 这条线段所截的最大权值。

这个维护是简单的，对每个置换环建出线段树，来支持 $y\in[a,b]$ 区间插入二元组 $(l,r)$，再在线段树的叶子节点上建个平衡树，当 pushdown 到叶子节点时把 $[l,r]$ 插入平衡树即可。查询时只需要在一棵平衡树里取出 $l\in[L,R]$ 这个区间，查下区间 $len_{max}$ 即可。注意这里实现需要做节点回收，否则空间复杂度是假的。

时间 $\mathcal{O}(n\log^2n)$，空间线性。

---
upd on 2024.12.20:

空间复杂度是 $\mathcal{O}(n\log n)$，之前分析错了/lh。顺便给出一个时空常数更优的做法：

给每个线段树节点开个平衡树，修改的时候直接在区间上修，查询的时候在所有包含它的线段树节点上查询。这样可以过加强版 P10151。

---

## 作者：0Io_oI0 (赞：5)

显然维护每个极长的合法段，这是因为每次修改只会进行 $O(1)$ 次合法段的合并或分裂。

考虑怎么维护存在 $a_i=x$ 这个条件。首先容易对询问 $l,r$ 的两端点进行特判。

考虑怎么搞中间那些极长段，我们来用上环的这个条件。沿着 $b$ 的置换环进行编号。不难发现在这样的编号下一个极长合法段拥有的 
${
a_
i
}$ 集合是不超过两段区间的并。

搞个线段树套平衡树，对每个极长段给每个能覆盖到的 $a_
i$ 打个标记。查询只需要查询包含 $x$ 的极长连续区间的长度的 max 即可。

上述都能用 FHQ 轻松维护。

---

## 作者：ty_mxzhn (赞：2)

![](https://cdn.luogu.com.cn/upload/image_hosting/3payf8xv.png)

读题，发现问题是在一个链上连边删边，查询区间内包含 $X$ 的最大联通块。

连边删边以后，只会产生或消去 $\le 2$ 个联通块，可以直接拿 set 维护。

然后好像不是很好做了。考虑 $b$ 是一个排列，会**形成若干个置换环**。

把每个置换环上的点按照环的顺序重标号，则所有联通块**在 $a$ 这一维上**形成了 $\le 2$ 个区间。

考虑二维化，则每个联通块可以看成两个 $x$ 轴相同的矩形。查询时先把经过 $l,r$ 的联通块特判掉，只保留 $x$ 轴在 $l,r$ 内的矩形，问 $y$ 轴和 $X$ 相同的点权 $\max$。

使用线段树套平衡树维护即可。lxl 把本题放在模拟赛里并开了 $6$ 秒时限。

---

## 作者：happybob (赞：0)

单根号过了，很慢。

分块，对于整块或散块内部的区间，容易在修改时重构块内信息得到。除此之外，重构时维护每个块内最长合法前后缀，如此一来跨块的信息只需要从前往后扫每个块并依次判断是否能包含整一个块。

时间复杂度 $O(n\sqrt n)$，空间复杂度 $O(n)$，为了空间做到线性，需要离线对于每个块分别维护结果。我写了，跑了十秒左右。

还有一个 poylog 做法，考虑维护所有连续段，这是容易用 `set` 维护的，对于询问 $[l,r]$，先把 $l,r$ 所在的连续段判掉，要问最长的连续段 $[l',r'] \subseteq [l,r]$ 且 $x$ 在 $a_l$ 到 $a_r$ 中。注意到 $a_l$ 到 $a_r$ 是一个置换环的一部分，于是对于每个这样的连续段，将其映射到置换环的一个环上区间上，对于每个值环维护树套树，对于环上区间 $[x,y]$，将 $[x,y]$ 在外层线段树上遍历到的每个节点加入一个序列中的区间 $[l,r]$，查询就可以直接做了。时间复杂度 $O(n \log^2 n)$，空间复杂度 $O(n \log n)$。

---


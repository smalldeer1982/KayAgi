# [THUPC 2022 决赛] 高性能计算导论集群登录密码复杂性策略

## 题目背景

高性能计算导论是 T 大学 C 系开设的一门专业选修课。这门课程讲述了高性能计算的基本概念和原理，常见并行编程模型及并行程序的基本编写思路，程序性能分析和优化的基本方法，以及计算机体系结构和程序性能的关系。为了让同学们能够实际体验并行程序的编写、性能分析和优化，课程为同学们提供了五台服务器组成的集群，每台服务器上都配置了 2 socket × 14 core 的处理器和 1 块 GPU。选课的同学可以在集群上进行基于消息传递的并行编程、基于共享内存模型的并行编程和 CUDA 编程。为了防止宝贵的计算资源被滥用（比如偷偷用服务器挖矿），课程在集群使用上有很多的规定，其中就包括要求选课同学使用高强度的集群登录密码。

## 题目描述

为了确保选课同学使用了较强的集群登录密码，课程组在集群上配置了密码复杂性策略。所有选课的同学在学期初会收到随机生成的初始密码。在使用初始密码登录集群后，集群会要求同学输入新的密码，密码更改完毕后才能正常访问集群。在本题中，我们假设密码复杂性策略为：

- 密码至少包含 $L$ 个字符，且至少包含一个数字和一个字母；

- 密码不能包含**连续** $A$ 个**重复**字符，如 `2333` 包含了连续 3 个重复字符；

- 密码不能包含**连续** $B$ 个字符组成的上升序列或下降序列，其中定义上升序列为 `0123456789`，`ABCDEFGHIJKLMNOPQRSTUVWXYZ` 和 `abcdefghijklmnopqrstuvwxyz` 三个字符串中某一个串的**连续**子串，下降序列为这三个字符串中某一个串的**连续**子串的反向串，例如： 
  
  - `6789` 是长度为 4 的上升序列，`FED` 是长度为 3 的下降序列；
  
  - `90`、`AZ`、`az` 不是上升序列或下降序列；
  
  - `GPU` 不是上升序列，因为它不连续；
  
  - `Def` 不是上升序列，因为字母大小写不一致（但它包含长度为 2 的上升连续子序列 `ef`）；
  
  - `1112345678999` 不是上升序列，但它的子序列 `123456789` 是上升的。

假设密码仅由数字及大小写字母构成。求在长度不超过 $R$ 的所有密码中，有多少个密码满足密码复杂性策略。

## 说明/提示

【样例 1 解释】

因为密码必须至少包含一个数字和一个字母，所以满足要求的密码有 $2\times 10 \times (26\times 2) = 1040$ 种。

【数据范围与约定】


保证 $1\le L\le R\le 10^9$，$2\le A\le 6$，$2\le B\le 26$。

【提示】

如果你不想记住又长又复杂的密码，不想每次登录时手动输入密码，也可以配置公钥进行 SSH 登录。

## 样例 #1

### 输入

```
2 2 2 2
```

### 输出

```
1040
```

## 样例 #2

### 输入

```
12 24 3 4
```

### 输出

```
718185656
```

## 样例 #3

### 输入

```
100 10000000 6 6
```

### 输出

```
146399052
```

# 题解

## 作者：251Sec (赞：6)

简单题，咋没人写题解。

不难得到一个暴力 DP 形如 $f(n,c,l_1,l_2,l_3,0/1,0/1)$，即已经填了 $n$ 位，最后一位为 $c$，结尾相等、上升、下降的长度为 $l_{1..3}$，是否已经选出了字母，是否已经选出了数字的方案数。这个 DP 太炸裂了，不过我们再观察一下：$l_{1..3}$ 至多有一个不是 $1$，$c$ 为大写字母和小写字母的状态是等价的，最后两个 $0/1$ 实际上只需要记一个代表是否存在一个位置左侧和右侧分别为字母和数字。所以状态数瞬间就少了很多，只有几千种了，可以暴力 DP 前 $10^3$ 项。$l,r$ 很大，看起来就很线性递推，所以记录 $s(n)$ 代表长度 $\le n$ 的密码种类数，然后直接把它丢进 BM 一看发现递推式长度只有几百。那就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 1e9 + 7;
ll QPow(ll a, ll b) {
	ll res = 1;
	for (; b; b >>= 1, a = a * a % P) if (b & 1) res = res * a % P;
	return res;
}
struct Poly {
	vector<ll> w;
	Poly() {}
	Poly(int sz) : w(sz) {}
	Poly(vector<ll> w) : w(w) {}
	ll &operator[](int i) { return w[i]; }
	ll operator[](int i) const { return w[i]; }
	int size() const { return w.size(); }
	void resize(int x) { w.resize(x); }
	Poly operator*(const Poly &b) const {
		Poly res(size() + b.size() - 1);
		for (int i = 0; i < size(); i++) {
			for (int j = 0; j < b.size(); j++) {
				res[i + j] += w[i] * b[j] % P;
			}
		}
		for (int i = 0; i < res.size(); i++) res[i] %= P;
		return res;
	}
	Poly operator%(const Poly &b) const {
		if (size() < b.size()) return *this;
		Poly a = *this;
		ll iv = QPow(b.w.back(), P - 2);
		int m = b.size() - 1;
		for (int i = size() - 1; i >= m; i--) {
			if (!a[i]) continue;
			ll w = a[i] * iv % P;
			for (int j = 0; j <= m; j++) (a[i - j] -= w * b[m - j] % P) %= P;
		}
		for (int i = 0; i < a.size(); i++) a[i] = (a[i] % P + P) % P;
		while (a.size() && !a.w.back()) a.w.pop_back();
		return a;
	}
};
namespace BM {
	vector<ll> cur, lst;
	ll del, fail;
	void UpdLst(vector<ll> t, ll tdel, ll tfail) {
		if ((int)t.size() - tfail < (int)lst.size() - fail) fail = tfail, del = tdel, lst = t;
	}
	vector<ll> Solve(ll *a, int n) {
		for (int i = 1; i <= n; i++) {
			ll d = a[i];
			for (int j = 0; j < cur.size(); j++) d -= a[i - j - 1] * cur[j] % P;
			d = (d % P + P) % P;
			if (!d) continue;
			vector<ll> tcur = cur;
			if (!fail) cur.resize(i);
			else {
				ll w = d * del % P;
				if (cur.size() < i - fail + lst.size()) cur.resize(i - fail + lst.size());
				(cur[i - fail - 1] += w) %= P;
				for (int j = 0; j < lst.size(); j++) (cur[i - fail + j] += (P - lst[j]) * w % P) %= P;
			}
			UpdLst(tcur, QPow(d, P - 2), i);
		}
		for (int i = 0; i < cur.size(); i++) cur[i] = (P - cur[i]) % P;
		reverse(cur.begin(), cur.end());
		cur.push_back(1);
		return cur;
	}
}
int l, r, a, b;
ll f[1005][36][26][2][3], s[1005];
void Upd(ll &x, ll y) { (x += y) %= P; }
ll Calc(Poly f, int n) {
	Poly a; a.resize(2), a[1] = 1;
	Poly res; res.resize(1), res[0] = 1;
	for (; n; n >>= 1, a = a * a % f) if (n & 1) res = res * a % f;
	ll ans = 0;
	for (int i = 0; i < res.size(); i++) ans += res[i] * s[i] % P;
	return ans % P;
}
int main() {
	scanf("%d%d%d%d", &l, &r, &a, &b);
	for (int i = 0; i < 36; i++) f[1][i][1][0][0] = 1 + (i > 9);
	for (int i = 1; i <= 1000; i++) {
		for (int j = 0; j < 36; j++) {
			for (int k = 1; k < 26; k++) {
				for (int x = 0; x < 2; x++) {
					for (int y = 0; y < 3; y++) {
						if (f[i][j][k][x][y] && ((!y && k < a) || (y && k < b))) {
							ll w = f[i][j][k][x][y];
							for (int z = 0; z < 36; z++) {
								if (z == j) Upd(f[i + 1][z][!y ? k + 1 : 2][x][0], w);
								else if (z == j + 1 && j != 9) Upd(f[i + 1][z][y == 1 ? k + 1 : 2][x][1], w);
								else if (z == j - 1 && j != 10) Upd(f[i + 1][z][y == 2 ? k + 1 : 2][x][2], w);
								else Upd(f[i + 1][z][1][x || ((j < 10) != (z < 10))][0], w);
								if (z > 9) Upd(f[i + 1][z][1][x || ((j < 10) != (z < 10))][0], w);
							}
							if (x) Upd(s[i], w);
						}
					}
				}
			}
		}
	}
	for (int i = 1; i <= 1000; i++) Upd(s[i], s[i - 1]);
	auto g = BM::Solve(s - 1, 1001);
	printf("%lld\n", (Calc(g, r) - Calc(g, l - 1) + P) % P);
	return 0;
}
```

---


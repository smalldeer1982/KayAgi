# [THUPC 2023 初赛] 种苹果

## 题目描述

农夫种了一棵苹果树，树上结满了大大小小的苹果。夏天正是果树生长发育的大好时节，树上不断抽出新的枝条、结出新的苹果，已有的苹果也在不断长大。

为了观察和记录苹果的生长状况，以便对未来收获的行情有大致的估计，农夫进行了长时间仔细的观察和研究。在整个记录周期的最开始，树上一共结有 $n$ 个苹果，农夫将其编号为 $1\sim n$ ，有 $n-1$ 条树枝连接这些苹果，每条树枝的两端都恰好挂有一个苹果，使得整个苹果树成为一个名副其实的树形结构。农夫对每个苹果进行了一番价值估计，第 $i$ 个苹果的初始价值为 $a_i$ ，表示农夫此时摘下它并卖出的净收益，考虑到成本因素， $a_i$ 可能为负。

在整个记录周期中，共发生了 $m$ 件值得记录的事件，所有的事件共分为以下几种类型：

$1\ u\ v\ w$：树上原本连接苹果 $u$ 和苹果 $v$ 的树枝中间结出了一个新的苹果。设原先树上共有 $k$ 个苹果，则此时变为 $k+1$ 个，农夫将新长出的苹果编号为 $k+1$ ，其价值为 $w$ 。原先连接苹果 $u$ 和 $v$ 的树枝也因此分裂成两条，一条连接苹果 $u$ 和 $k+1$ ，另一条连接苹果 $k+1$ 和 $v$；

$2\ u\ w$：树上长出了一条新树枝和一个新苹果。设原先树上共有 $k$ 个苹果，则此时变为 $k+1$ 个，农夫将新长出的苹果编号为 $k+1$，其价值为 $w$。新树枝连接苹果 $u$ 和 $k+1$。

$3\ u\ v\ w$：树上一部分苹果的价值发生了变化。树上连接苹果 $u$ 和 $v$ 的一整段枝条（即树形结构上连接 $u$ 和 $v$ 的最短路径，包括 $u$ 和 $v$ 本身）上的所有苹果的价值均增加了 $w$ 。考虑到价值的变化也可能是由于营养不足或病虫害引起的，因此 $w$ 可能为负。

$4\ u\ v\ w$：农夫想在树上进行一次抽样调查来研究自己的可能收益。他定义价值不小于 $w$ 的苹果为“优质苹果”，并选择了树上连接苹果 $u$ 和 $v$ 的一整段枝条（含义同上），想统计一下这段枝条上的苹果中有多少个“优质苹果”。

但由于苹果的数量是在太多了，农夫数不过来，便只好请你来帮忙。注意：由于农夫不能预测未来，因此你帮农夫时必须**强制在线**地回答问题。

## 说明/提示

#### 样例解释 1

对于这组样例，去除强制在线后的数据如下：

```
5 6
1 3 3 2 2
1 2
1 3
2 4
2 5
4 3 4 2
3 1 5 1
4 3 4 2
1 1 2 5
2 6 3
4 4 7 4
```

#### 数据范围

对于所有数据， $n,m \leq 2 \times 10^5$，$|a_i|, |w|\leq 10^9$，保证任意时刻涉及到的苹果编号均有意义，保证初始的 $n-1$ 条树枝构成树形结构，所有 $1$ 事件保证连接苹果 $u$ 和 $v$ 的树枝在事件发生时存在。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
5 6
1 3 3 2 2
1 2
1 3
2 4
2 5
4 3 4 2
3 2 6 2
4 0 7 1
1 5 6 1
2 2 7
4 0 3 0
```

### 输出

```
3
4
2
```

# 题解

## 作者：EnofTaiPeople (赞：8)

### Part1 前言

WBTT 暂时被我认为是考场不可写作的，也就是它把我劝退了。

但本题感觉把 WBTT 写到脸上了，但我说了 WBTT 考场不可写作，所以我没有办法使用 WBTT。

然而，做法依旧是 zx2003 教我的，虽然我没有和他见过面，也不在一个学校。

### Part2 考场做法

树分块是平凡且不具有扩展性的，这道题可以归约为 Link-Cut 链加链 rank，放在序列上是经典分块问题。

于是我将 [WBTT](https://zx2003.blog.uoj.ac/blog/7884) 中的 WBTT 换成了 LCT 就过了。

具体地，对 LCT 上节点的 $sz$ 做根号分治，在 `pushup` 时，只有 $sz_x\le\sqrt n$ 才会将两个子树的 `vector` 归并，这样保证了修改复杂度为 $O(\sqrt n\log n)$。

查询递归到每一棵 $sz_x\le\sqrt n$ 的子树二分就行了，这一步是 $O(\sqrt n\log n)$ 的。

### Part3 对低复杂度做法的探讨

然后我考后发现查询复杂度是错误的。

原因是，如果当时 `splay` 存在较长链，这一步就必须要伸展，否则就不对，不过出题人并没有卡，事实上，我自己就能卡掉。

如果你这一步选择伸展，那么伸展复杂度是 $O(\sqrt n\log n)$ 的，$O(nq\log n)$ 有存在的必要吗？

其实还是有方法的，使用 `fhqTreap` 就可以了，注意这里需要建 Top Tree，不然 $O(q\sqrt n\log^2 n)$ 也已经渐近暴力了。

直接用 `fhqTreap` 实现 $\text{Rand Top Tree}$ 是 $O(q\sqrt n\log n)$ 的，这一步我并不会证。

### Part4 用常数换复杂度

我要半个 $\log$！虽然半 $\log$ 标算的题目是极少的。

你需要会分散层叠算法。

就是说，即使 $sz_x>B$，我们也进行两个子树的分散层叠合并，然后将 $B\leftarrow\sqrt{\dfrac n{\log n}}$ 于是时空复杂度 $O(n\sqrt{n\log n})$。

然而常数太大了，分散层叠在目前的应用大多数都停留在理论分析。

标算的定期重构树分块是平凡的，即使有较小的常数优势但并不具有可扩展性，我要你真的 Link-Cut 你就没了。

当然，WBTT 必定是严格 $O(n\sqrt n)$ 的。

### Part5 后记

我已经下定决心短时间内不再研究 $\text{Top Tree}$ 的更深内容了，一道题似乎并不能让我回来？

希望有一天我能够真正地学会 WBTT 吧，至少上高中之后了。

---

## 作者：Graphcity (赞：2)

- **前置知识**：[P8353 [SDOI/SXOI2022] 无处存储](https://www.luogu.com.cn/problem/P8353) 的随机撒点树分块做法

- **理论部分**

首先注意到这题中对树改变形态的操作十分特殊，一种是在边上加点，另一种是加叶子，远远弱于 LCT 中的 Link/Cut 操作。对于这种形态的树，用随机撒点树分块的方式维护是一种好方法。

随机撒 $A$ 个点并建立虚树，任意点到关键点 / 虚树的距离为 $O(\dfrac{n}{A})$ 级别，虚树上两相邻点之间的链长也为 $O(\dfrac{n}{A})$ 级别，从任意点跳到根经过的链数为 $O(A)$ 级别。

跟普通的树链剖分一样，我们剖分虚树中相邻关键点的链，每条链用一个有序的数组来维护。一条链建立 / 重构的时间复杂度为 $O(\dfrac{n}{A}\log n)$，插入结点的时间复杂度为 $O(\dfrac{n}{A})$。

查询时，散点暴力查询 $O(1)$，整条链可以二分找到链上有多少个数 $\ge w$，时间复杂度 $O(\log n)$，单次查询时间复杂度 $O(A\log n+\dfrac{n}{A})$。

修改时，散点暴力修改，整条链可以打一个永久化标记。而对于一条不完整的链的修改，可以发现有序数组能分成两个子序列（要修改和不要修改的），对其中一个子序列进行修改，修改完后归并可以做到线性。单次修改时间复杂度 $O(A+\dfrac{n}{A})$。

不妨令 $A=\sqrt\dfrac{n}{\log n}$，则总时间复杂度 $O(m\sqrt{n\log n})$。

但是加点可能会破坏原来的性质，所以我们考虑定期重构，每次重构复杂度 $O(n\log n)$，以 $T=\sqrt{n\log n}$ 为周期重构，重构的总时间复杂度依然为 $O(m\sqrt{n\log n})$。

- **实践部分**

**实际操作中，需要维护的跟原树形态相关的信息只有每个点的父亲是谁。**

首先随机撒点树分块的虚树完全不需要用按照 dfs 序排序然后栈维护的方法，可以暴力一点，从关键点跳到根并沿途打标记，如果路过标记点则停止操作，并将该点加入虚树。这样不仅能建出虚树，还能够标记一个点是否在虚链上。

求 LCA 的方法类似于树剖，这里需要先将点跳到虚链上，再在虚链上暴力跳关键点，单次是 $O(A+\dfrac{n}{A})$ 的。

链加可以转化为当前点到根的加 / 减。比如，$sum(x,y)=sum(x)+sum(y)-sum(LCA(x,y))-sum(fa_{LCA(x,y)})$。链查也可以用相同方式转化。

由于边上加点操作的存在，深度是较难维护的，考虑仅维护关键点的深度。每次加点时，需要将子树中的所有关键点深度 +1。但加点操作不会影响虚树形态，所以还是可以存储虚树中每个点的儿子，然后进行 dfs。单次操作是 $O(A)$ 的。

用邻接表存图。vector 会超时。实际上如果按照理论方法选取撒点个数和重构间隔会超时，$A=T=10^3$ 是不错的选择。

本题读入输出量较大，但 [这道题](https://www.luogu.com.cn/problem/P8353) 已经帮你写好了快读。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=4e5,T=1000;

namespace INPUT_SPACE{
	const int S=(1<<20)+5;char B[S],*H,*T;inline int gc() { if(H==T) T=(H=B)+fread(B,1,S,stdin);return (H==T)?EOF:*H++; }
	inline int read() { int x,ch,f=1;while((ch=gc())<'0'||ch>'9')if(ch=='-')f=-1;x=ch^'0';while((ch=gc())>='0'&&ch<='9')x=x*10+(ch^'0');return x*f; }
}using INPUT_SPACE::read;
inline void write(int x)
{
    if(x>=10) write(x/10);
    putchar(x%10+'0');
}

struct Node{int to,nxt;} Edge[Maxn*4+5];
int tot,Head[Maxn+5],Head2[Maxn+5];
inline void Addedge(int x,int y) {Edge[++tot]=(Node){y,Head[x]},Head[x]=tot;}
inline void Addedge2(int x,int y) {Edge[++tot]=(Node){y,Head2[x]},Head2[x]=tot;}

int n,m,B,ans,nxt[Maxn+5];
int p[Maxn+5],fa[Maxn+5],flg[Maxn+5]; ll tag[Maxn+5],a[Maxn+5];
int dep[Maxn+5],anc[Maxn+5],vis[Maxn+5],chk[Maxn+5];
mt19937 rnd(time(0));

struct Array
{
    vector<pair<ll,int>> v;
    inline void Clear() {v.clear(),v.shrink_to_fit();}
    inline void Remake(int x)
    {
        v.clear(),v.shrink_to_fit();
        for(int i=x;i!=anc[x];i=fa[i]) v.emplace_back(a[i],i);
        sort(v.begin(),v.end());
    }
    inline void Insert(int x)
    {
        auto res=make_pair(a[x],x);
        for(auto it=v.begin();it!=v.end();it++)
            if(res<*it) {v.insert(it,res); return;}
        v.push_back(res);
    }
    inline void Merge(vector<pair<ll,int>> x,vector<pair<ll,int>> y)
    {
        auto il=x.begin(),ir=y.begin(); v.clear();
        while(il!=x.end() && ir!=y.end()) if((*il)<(*ir)) v.push_back(*il++); else v.push_back(*ir++);
        while(il!=x.end()) v.push_back(*il++); while(ir!=y.end()) v.push_back(*ir++);
    }
    inline int Count(ll w) {return v.end()-lower_bound(v.begin(),v.end(),make_pair(w,0));}
} tr[Maxn+5];

inline void dfs0(int x,int f)
{
    fa[x]=f,dep[x]=dep[f]+1;
    for(int i=Head[x];i;i=Edge[i].nxt) {int y=Edge[i].to; if(y!=f) dfs0(y,x);}
}
inline void dfs1(int x) {dep[x]++; for(int i=Head2[x];i;i=Edge[i].nxt) dfs1(Edge[i].to);}
inline int GetDep(int x) {int res=0; while(!vis[x]) res++,x=fa[x]; return dep[x]+res;}
inline int Find(int x) {while(!vis[fa[x]]) x=fa[x]; return nxt[x];}
inline int GetLca(int x,int y) {while(x!=y) if(dep[x]>dep[y]) x=anc[x]; else y=anc[y]; return x;}
inline int LCA(int x,int y)
{
    if(x==y) return x;
    int a=x,b=y,dx=GetDep(x),dy=GetDep(y);
    while(!chk[a]) a=fa[a]; while(!chk[b]) b=fa[b];
    if(a==b) {while(x!=y) if(dx>dy) x=fa[x],dx--; else y=fa[y],dy--; return x;}
    x=a,y=b,a=(vis[x]?x:Find(x)),b=(vis[y]?y:Find(y));
    if(a==b) return (GetDep(x)<GetDep(y)?x:y);
    int k=GetLca(a,b);
    if(k==a) return x; else if(k==b) return y; else return k;
}
inline void Insert(int x,int w) {fa[++n]=x,a[n]=w;}
inline void Insert(int x,int y,int w)
{
    if(fa[y]==x) swap(x,y);
    int k=++n; fa[x]=k,fa[k]=y,a[k]=w;
    if(vis[y] && chk[x]) nxt[k]=nxt[x],nxt[x]=0;
    if(chk[x] && chk[y])
    {
        chk[k]=1; int id=(vis[x]?x:Find(k));
        a[k]-=tag[id],tr[id].Insert(k),dfs1(id);
    }
}
inline void PushDown(int x) {for(int i=x;i!=anc[x];i=fa[i]) a[i]+=tag[x]; tag[x]=0;}
inline void Modify(int x,int k)
{
    if(!x) return;
    while(!chk[x]) a[x]+=k,x=fa[x];
    if(!vis[x])
    {
        int id=Find(x);
        vector<pair<ll,int>> v1,v2;
        for(int i=x;!vis[i];i=fa[i]) flg[i]=1;
        for(auto i:tr[id].v)
        {
            if(flg[i.second]) v2.emplace_back(i.first+k,i.second);
            else v1.push_back(i);
        }
        tr[id].Merge(v1,v2);
        for(int i=x;!vis[i];i=fa[i]) flg[i]=0;
        while(!vis[x]) a[x]+=k,x=fa[x];
    }
    for(int i=x;i;i=anc[i]) tag[i]+=k;
}
inline void Modify(int x,int y,int k)
{
    int l=LCA(x,y);
    if(l==x) Modify(y,k),Modify(fa[x],-k);
    else if(l==y) Modify(x,k),Modify(fa[y],-k);
    else Modify(x,k),Modify(y,k),Modify(l,-k),Modify(fa[l],-k);
}
inline int Count(int x,int w)
{
    if(!x) return 0;
    int res=0;
    while(!chk[x]) res+=(a[x]>=w),x=fa[x];
    if(!vis[x])
    {
        int id=Find(x);
        while(!vis[x]) res+=(a[x]+tag[id]>=w),x=fa[x];
    }
    for(int i=x;i;i=anc[i]) res+=tr[i].Count(w-tag[i]);
    return res;
}
inline int Count(int x,int y,int w)
{
    int l=LCA(x,y),res=0;
    if(l==x) res=Count(y,w)-Count(fa[x],w);
    else if(l==y) res=Count(x,w)-Count(fa[y],w);
    else res=Count(x,w)+Count(y,w)-Count(l,w)-Count(fa[l],w);
    return res;
}
inline void Clear()
{
    tot=0;
    for(int id=1,i=p[1];id<=B;i=p[++id])
        PushDown(i),tr[i].Clear(),Head2[i]=0;
    For(i,1,n) chk[i]=vis[i]=dep[i]=anc[i]=nxt[i]=Head[i]=0;
    For(i,2,n) Addedge(fa[i],i);
}
inline void ReBuild()
{
    Clear(),dfs0(1,0),B=T;
    For(i,1,B) p[i]=rnd()%n+1; p[++B]=1;
    sort(p+1,p+B+1),B=unique(p+1,p+B+1)-p-1;
    For(i,1,B) vis[p[i]]=1; chk[1]=1;
    for(int id=1,i=p[1],j;id<=B;i=p[++id])
    {
        for(j=i;!chk[j];j=fa[j]) chk[j]=1;
        if(!vis[j]) vis[j]=1,p[++B]=j;
    }
    sort(p+1,p+B+1);
    for(int id=2,i=p[2],x,y;id<=B;i=p[++id])
    {
        for(x=i,y=fa[i];!vis[y];x=y,y=fa[y]);
        anc[i]=y,nxt[x]=i;
        if(anc[i]) Addedge2(anc[i],i);
    }
    For(i,1,B) tr[p[i]].Remake(p[i]);
}

int main()
{
    n=read(),m=read();
    For(i,1,n) a[i]=read();
    For(i,1,n-1)
    {
        int x=read(),y=read();
        Addedge(x,y),Addedge(y,x);
    }
    dfs0(1,0),ReBuild();
    for(int i=1,cnt=0;i<=m;++i)
    {
        int op=read(),x=read()^ans,y=read()^ans,z;
        if(op==1) z=read()^ans,Insert(x,y,z),cnt++;
        if(op==2) Insert(x,y),cnt++;
        if(op==3) z=read()^ans,Modify(x,y,z);
        if(op==4) z=read()^ans,write(ans=Count(x,y,z)),putchar('\n');
        if(cnt>=T) cnt=0,ReBuild();
    }
    return 0;
}
```

---

## 作者：UNVRS (赞：2)

不喜欢这道缝合题，但是写了很久。

## 题意

给一颗树，支持加点、边中加点、树链加、树链查询 $k$ 的排名。

$n,m\le 2\times10^5$。

## 思路

首先做教主的魔法，然后做无处储存。

然后把两道题融合即可通过本题，随机撒点树链分块然后块内排序，查询时对整块块内二分，时间复杂度 $O(n\sqrt{n\log n})$。

~~可见本题只有蓝题难度。~~

对于加点，分成若干情况讨论然后把链重新连一下即可。

## 实现

但是第一次写树链分块，所以写挂了。

细节包括但不限于：

- 深度是比较难维护的，所以求 LCA 直接令一个点跳到根并标记路径，然后令另一个点去找标记，注意同在一条链上时要暴力判一下哪个比较浅（记得清空标记）。
- 连链的时候按照 $B$ 为一节拆开，最后保留一节小于 $2B$ 的（令重链长度不小于 $B$），自动保证复杂度正确，然后记得下放中间的链的信息。
- 为了保证复杂度，对于散点需要维护一个下方最长链的长度，在向上找链的时候维护即可。
- 对于边中间加点有四种情况：
    1. 在链中间，这种情况先把链的信息下放下去，然后重连。
    2. 在两条链的中间，因为链是下闭上开的，所以下放下方链的信息，然后重连下方链到上方链的顶部。
    3. 在上方链的底部，直接连到上方链（这种情况当散点也行）。
    4. 在散点，这个时候要判断下方最长链的长度加上方到链上的距离，够大就从底部连上来。
- 注意边中间加点的时候，对于链信息需要**提前手动下放**，不然新点连好之后再下放信息会有问题。
- 在点下加点要判断上方到链上的距离，维护一下结构。
- 结点 $1$ 是不在任何链中的，这个一定要注意。
- 根据实现复杂度还会有若干细节（以上是我精简代码之后仅剩的）。

## 关于常数

~~我去除了大部分的运行用时，但保留了一小部分，好让评测机知道它评测的是 N 根号 Log。~~

这个做法应该不卡常，我第一遍调出来就 3.7s，个人感觉询问分块然后重构的方法是比较卡常的，因为我赛后写了一份现在没过。

---

写挂的时候发现一个卡常小寄巧，对于所有非根的点总是保留第一条链不连成链（无论任何情况都不连接），让上面的点连。

然后就是对于暴力修改小于一定阈值使用插入排序。

块长调小，跑的很快，2.5s 左右。

## CODE

含少量注释。

```c++
#include<cstdio>
#include<vector>
#include<random>
#include<chrono>
#include<algorithm>
using namespace std;
const int N=400010,FSIZE=1<<24,B=280;
int n,m,p[N],fa[N],up[N],in[N],dp[N],hs[N],path[N],tag[N],tmp[N];
bool v[N];
vector<int> t[N];
vector<pair<int,int>> c[N];
char BuF[FSIZE],*InF=BuF,WuF[FSIZE],*OnF=WuF;
template<typename T>void read(T &x){
    bool f=0;
    for(x=0;48>*InF||*InF>57;*InF++=='-'&&(f=1));
    for(;47<*InF&&*InF<58;x=x*10+(*InF++^48));
    f&&(x=-x);
}
void write(int x){
    char st[12]={},*c=st;
    for(!x&&(*OnF++=48);x;x/=10) *++c=x%10^48;
    for(;c!=st;*OnF++=*c--);
    *OnF++='\n';
}
void reset(int u){    // 下放链的信息，并删除这条链
    c[u].clear();
    if(int &i=tag[u]){
        for(int x=up[u];u!=x;u=fa[u]) p[u]+=i;
        i=0;
    }
}
void set(int x,int y){    // 将 x->y 连接成若干条链
    for(tmp[tmp[0]=1]=x;x!=y;tmp[++tmp[0]]=x=fa[x])
        if(x==in[x]) reset(x);
    for(int *i=tmp+1,*j=i,*r=tmp+tmp[0];i<r;i=j){
        int *nxt=i+B;
        if(nxt+B>r) nxt=r;
        for(;j<nxt;++j){
            up[*j]=*nxt;
            c[in[*j]=*i].emplace_back(p[*j],*j);
        }
        sort(c[*i].begin(),c[*i].end());
    }
}
int dfs(int x){    // 预处理初始撒点情况
    int re=0;
    for(int i:t[x]) if(i!=fa[x]){
        fa[i]=x;
        if(int tmp=dfs(i)){
            if(re){
                set(tmp,x);
                v[x]=1;
            }else re=tmp;
        }
        if(dp[i]>dp[hs[x]]) hs[x]=i;
    }
    dp[x]=dp[hs[x]]+1;
    return(!re&&v[x]?x:re);
}
pair<int,int> getup(int i){    // 获取到上方链的距离及编号，并维护向下最长链的长度
    for(int x,dis=0;;++dis,i=x){
        if(dp[i]>dp[hs[x=fa[i]]]) dp[x]=dp[hs[x]=i]+1;
        if(in[x]||x==1) return(make_pair(x,dis));
    }
}
void add(int u,int w){    // 点下加点
    fa[++n]=u;
    p[n]=w;
    auto m=getup(n);
    if(m.second>=B) set(n,m.first);
}
void add(int u,int v,int w){    // 边中加点
    if(fa[u]==v) swap(u,v);
    if(in[v]) reset(in[v]);    // 提前手动下放
    fa[fa[v]=++n]=u;
    p[n]=w;
    if(in[v]&&in[v]!=in[u]) return(set(in[v],u));    // 在两条链中间
    if(in[u]) return(set(u==in[u]?n:in[u],up[u]));    // 在链中间或底部
    dp[n]=dp[hs[n]=v]+1;
    auto m=getup(n);
    if(m.second+dp[n]>=B+B){
        int x=n;
        for(;hs[x];x=hs[x]);
        set(x,m.first);
    }
}
int check(int u,int v){    // 返回两结点中较浅的一个
    int x=in[u];
    for(;x!=v&&x!=u;x=fa[x]);
    return(x==v?u:v);
}
int lca(int u,int v){    // 如名
    int x=u,re=0;
    for(;!up[x]&&x>1;x=fa[x]) path[x]=1;
    for(;!up[v]&&v;v=fa[v])
        if(path[v]){
            re=v;
            break;
        }
    for(;!up[u]&&u>1;u=fa[u]) path[u]=0;
    if(re) return(re);
    for(;x>1;x=up[x]) path[in[x]]=x;
    for(;v>1;v=up[v])
        if(path[in[v]]){
            re=check(path[in[v]],v);
            break;
        }
    for(;u>1;u=up[u]) path[in[u]]=0;
    return(re?re:1);
}
void modify2(int u,int v,int w){    // 对链内（或散点）暴力修改
    int b=in[u],sz=0;
    for(;u!=v;u=fa[u],++sz) p[u]+=w;
    if(b){
        for(auto &x:c[b]) x.first=p[x.second];
        if(sz<8)
            for(auto i=c[b].begin()+1;i<c[b].end();++i)
                for(auto j=i;j>c[b].begin()&&j[-1]>*j;--j) swap(j[-1],*j);
        else sort(c[b].begin(),c[b].end());
    }
}
void modify1(int u,int x,int w){    // 修改祖先后代链
    for(;!up[u]&&u!=x;u=fa[u]) modify2(u,fa[u],w);
    for(;in[u]!=in[x];u=up[u])
        if(in[u]==u) tag[u]+=w;
        else modify2(u,up[u],w);
    modify2(u,x,w);
}
void modify(int u,int v,int w){    // 如名
    int l=lca(u,v);
    modify1(u,l,w);
    modify1(v,l,w);
    modify2(l,fa[l],w);
}
int query2(int u,int x,int w){    // 对链内（或散点）暴力询问
    int re=0;
    for(w-=tag[in[u]];u!=x;u=fa[u]) re+=p[u]>=w;
    return(re);
}
int query1(int u,int x,int w){    // 询问祖先后代链
    int re=0;
    for(;!up[u]&&u!=x;u=fa[u]) re+=p[u]>=w;
    for(;in[u]!=in[x];u=up[u])
        if(u==in[u])
            re+=c[u].end()-lower_bound(c[u].begin(),c[u].end(),make_pair(w-tag[u],0));
        else re+=query2(u,up[u],w);
    return(query2(u,x,w)+re);
}
int query(int u,int v,int w){    // 如名
    int l=lca(u,v),re=p[l]>=w-tag[in[l]];
    re+=query1(u,l,w);
    re+=query1(v,l,w);
    return(re);
}
int main(){
    fread(BuF,1,FSIZE,stdin);
    read(n);read(m);
    for(int i=1;i<=n;++i) read(p[i]);
    for(int i=1,x,y;i<n;++i){
        read(x);read(y);
        t[x].push_back(y);
        t[y].push_back(x);
    }
    mt19937 rnd(chrono::steady_clock().now().time_since_epoch().count());
    for(int i=v[1]=1;i<=n;i+=B) v[rnd()%n+1]=1;
    set(dfs(1),1);    // 注意手动连接最后一条传上来的链
    for(int i=0,o,x,y,w,lastans=0;i<m;++i){
        read(o);read(x);read(y);
        x^=lastans;
        y^=lastans;
        if(o!=2){
            read(w);
            w^=lastans;
            switch(o){
            case 1:add(x,y,w);break;
            case 3:modify(x,y,w);break;
            case 4:write(lastans=query(x,y,w));
            }
        }else add(x,y);
    }
    fwrite(WuF,1,OnF-WuF,stdout);
    return(0);
}
```



---

## 作者：dcmfqw (赞：1)

昨天植树节但是是周日，今天补上。

由于这个加点实在是太弱了，所以首先以 $B$ 为块长划分成若干簇，然后可以划出来顶多 $2\frac nB$ 个界点，每次加点的时候如果当前簇大小超过 $2B$ 那么就把当前簇的重心再划成一个界点，然后再加一个界点来保证分开的东西是个簇，然后把当前簇内的信息分到各个新簇中，这样簇大小总小于等于 $B$，界点个数最多为 $2\frac nB+2\frac mB$，暴力划分次数至多为 $B$。

然后看看要维护什么东西，链加链排名强制在线值域乱飞，这个放到序列上也是一个十分重量级的玩意，所以复杂度做到类 $O(m\sqrt{n\log n})$ 即可。

（听说可以分散层叠？不会那个东西。）

由于每个簇两端最多两个界点，所以把每个簇内维护的点分成两种，界点之间路径上的点和其他点，查询的时候两端的簇直接暴力查询，中间的簇只会涉及到前面那种点，在按权值排好序的数组上二分，可以做到 $O(mB+m\frac nB\log B+m\frac mB\log B)$。

每次修改两端的簇直接重构，内部的簇只会改前面那种，然后界点总共才那么多所以涉及到的簇顶多 $O(\frac nB+\frac mB)$ 个，打标记即可，复杂度 $O(mB+m\frac nB+m\frac mB)$，当然重构的时候要写由乃打扑克的那个把数组分开再归并的优化。

加点要插入，但是一个插入只会影响一个簇，直接插入维护的数组就行，复杂度 $O(mB)$。

然后簇分裂，就是上面的第一句话里的簇重构，这个由于会有原先不在界点中的点变成界点中的点，意味着还要在之前维护一个每个簇中不在界点中的点的排名数组，当然你可以直接排序不会影响到最后的那个根号，复杂度 $O(B^2)$。

注意一下界点也是点，而且不在任何簇内，但是它们暴力维护就行。

初始化的时候至少要排个序，复杂度 $O(n\log n)$。

具体实现时可以始终维护原树形态，由于两个界点的 `lca` 仍是一个界点（要求根节点为界点），所以每个界点只用存它在收缩树上的父亲，不用维护整棵收缩树的形态。

但是这样的话询问时要知道每个界点的深度，如果上面没有维护整棵收缩树的形态的话这个是不能在重构时直接求的，不过可以记忆化搜索，每次求完深度的时候把结果记下来，顺便记一下当前界点个数，这样重构时就不需要直接改这个记忆化数组了。

对于每个点记录一下在哪个簇里以及它是否在两个界点间，对于界点记录它父亲在哪个簇里，特殊地给根的父亲找个虚簇方便讨论，每个簇还要存它下面的界点（也可以没有）和上面维护的两个数组。

复杂度 $O(B^2+n\log n+mB+m\frac nB\log B+m\frac mB\log B)$，让后面那个 $m\frac mB\log B$ 假装被 $m\frac nB\log B$ 吞了，$B=\sqrt{n\log n}$ 可以做到 $(n\log n+m\sqrt{n\log n})$。

（但是事实上 $B$ 取 $\sqrt n$ 跑得飞快，取 $B=\sqrt{n\log n}$ 会 `T` 成狗，谔谔）

（可能是两边常数过于不均衡导致的。）

（此题目前是我历史码量榜一，直接怒码四百五十行共 `11.25KB`。）

[代码。](https://www.luogu.com.cn/paste/orbyiqm2)


---

## 作者：Raymondzll (赞：1)

## P9136 种苹果

最近在强攻 DS，看到了这道题。

吐槽：新时代大模拟。有这个谁还写猪国杀。

### 解题思路

这是一道 $n,q$ 均为 $10^5$ 级别，时限 $6s$ 的树上强制在线题。要求链加、求链上值排名，叶子下挂点和拆边加点（U—V 变成 U—W—V）。

维护排名可见于 P2801。除了分块维护并没有什么更好的做法。

为了将数列迁移至树上，我们想要把树剖成链，在有 $O(B)$ 条链的情况下，我们希望每条链长度在 $O(\frac n B)$ 级别。我们引入随机撒点树分块。

### 随机撒点树分块的普遍步骤与套路

1. 随机选择一堆点称为关键点（必须包含根），去重，排序。

2. 所谓建虚树，其实只是让所有关键点对的 LCA 也是关键点。做法：从每个关键点开始往上爬，沿途标记。当碰到之前的标记时，这个相遇点就要称为关键点。这些标记后面还有用，暂称为路径点。注意到关键点是特殊的路径点。

3. 我们剖出的链是从每个关键点走到他上面的关键点形成的链（下闭上开）。

注意到不是所有点都在链上，也就是说有一类点是没有归属的。这类点走到叶子的链长期望与正常链一个级别。

什么？你说做完了？不不不。实际上要维护的东西还有一些。我们采取发现问题解决问题的方式来剖析。

先不管 1，2 操作。对于链操作，很容易拆成到根操作。首先我们遇到的问题是，怎么知道一个点的所属块？

往下跳是可以的，但我选择一种更好理解的方式，往上跳。在顶部关键点处维护其每个儿子所属块。

解决了这个问题修改和查询其实大同小异。

```cpp
int find(int u){//gives out the id of the block u belongs to.
	while(!key[fa[u]])u=fa[u];
	return G[key[fa[u]]][idx[u]];
}
void update(int u,int w){//update from u to root
	if(!u)return;
	for(;!path[u];u=fa[u])a[u]+=w;
	if(!key[u]){
		int x=find(u);
		for(int v=u;v!=p[Fa[x]];v=fa[v])a[v]+=w;
		maintain(x);u=p[Fa[x]];
	}
	for(u=key[u];u;u=Fa[u])tg[u]+=w;
}
int ask(int u,int w){//easy to understand.
	if(!u)return 0;int r=0;
	for(;!path[u];u=fa[u])r+=(a[u]>=w);
	if(!key[u]){
		int x=find(u);
		for(int v=u;v!=p[Fa[x]];v=fa[v])r+=(a[v]+tg[x]>=w);
		u=p[Fa[x]];
	}
	for(u=key[u];u;u=Fa[u])r+=blk[u].size()-(lower_bound(blk[u].begin(),blk[u].end(),w-tg[u])-blk[u].begin());
	return r;
}
```

然后我们要做 LCA。注意到这并不好处理！由于有动态加点的操作存在，不可能用简易的方法去维护。那考虑用已有的分块来解决。

首先对于关键点的 LCA，我们有每个关键点的上面的关键点了，这是一颗 $O(B)$ 的树，直接暴力跳。这个过程要求了我们维护关键点的深度。

对于普通点 $u,v$，先往上爬到一个路径点。设各自爬到 $x,y$。若 $x=y$ 则 $u,v$ 在一块没归属的点里。暴力跳。若 $x\neq y$ ，考虑他们所属块。同一块的话就是在一条链上，返回浅的点。不同块就跳到同块，若块与块呈现祖孙关系，依旧返回浅的点。否则返回关键点的 LCA。

然后就是要求每个普通点的深度。很显然往上爬到关键点就好了。代码不贴了，去下面的整个代码里找。

### 加点

我们现在有这么多东西要维护。

```cpp
ll a[N];
vector<int>g[N];int idx[N];int fa[N],key[N];bitset<N>path;
vector<int>G[M];int p[M],Dep[M],Fa[M];
vector<ll>blk[M];ll tg[M];
```

对于下面挂一个点不要太简单。改的是 ```a idx fa g```。

但对于中间加点，我们要额外去动 ```blk G path Dep```。

动 Dep 是子树里动的，但只动关键点所以很简单。动 G 我用一个小 trick 免去了。具体来说 G 和 g 共享第二维下标。

### 重构

想要过 #16 这种一条链上挂链的变态数据，靠最开始的一次撒点跑完全场是不行的。我们就以 $B'$ 为间隔不断重构。好复杂啊。

### 寄

作为“大模拟”，很容易写寄。

我寄的点分享一下。最常见是寄在重构里。打的懒标记要下放，**不要清空数据了再下放懒标记！！！**

之前写的板子里 ```fa[i]``` 肯定小于 i，但有了加点就不一定了。因此重构里算 ```Dep``` 不能循环一遍算，要 DFS 算。

其他地方也要时刻注意 a 数组和 blk 的统一性。

### 卡常？

不用怎么卡。一开始我 maintain 函数多处使用，删掉不必要的就过了。


```cpp
typedef long long ll;
const int N=400010,B=1000,B2=1000,M=2*B+10;
mt19937 rnd(time(0));
int n,m,q;ll a[N];
vector<int>g[N];int idx[N];int fa[N],key[N];bitset<N>path;//if this is a key point, key is an integer. Otherwise key is zero.
vector<int>G[M];int p[M],Dep[M],Fa[M];//things on the virtual tree starts with a capital letter.
vector<ll>blk[M];ll tg[M];
void maintain(int x){//maintain block x
	blk[x].clear();
	for(int v=p[x];v!=p[Fa[x]];v=fa[v])a[v]+=tg[x],blk[x].pb(a[v]);
	sort(blk[x].begin(),blk[x].end());
	tg[x]=0;
}
int dep(int u){//gives out the real depth.
	int d=0;for(;!key[u];u=fa[u])d++;
	return d+Dep[key[u]];
}
int find(int u){//gives out the id of the block u belongs to.
	while(!key[fa[u]])u=fa[u];
	return G[key[fa[u]]][idx[u]];
}
void update(int u,int w){//update from u to root
	if(!u)return;
	for(;!path[u];u=fa[u])a[u]+=w;
	if(!key[u]){
		int x=find(u);
		for(int v=u;v!=p[Fa[x]];v=fa[v])a[v]+=w;
		maintain(x);u=p[Fa[x]];
	}
	for(u=key[u];u;u=Fa[u])tg[u]+=w;
}
int ask(int u,int w){//easy to understand.
	if(!u)return 0;int r=0;
	for(;!path[u];u=fa[u])r+=(a[u]>=w);
	if(!key[u]){
		int x=find(u);
		for(int v=u;v!=p[Fa[x]];v=fa[v])r+=(a[v]+tg[x]>=w);
		u=p[Fa[x]];
	}
	for(u=key[u];u;u=Fa[u])r+=blk[u].size()-(lower_bound(blk[u].begin(),blk[u].end(),w-tg[u])-blk[u].begin());
	return r;
}
int Lca(int u,int v){//u v be key points. That is, this function gives out a block id.
	while(u!=v)Dep[u]<Dep[v]?v=Fa[v]:u=Fa[u];return u;
}
int lca(int u,int v){//normal lca
	int x=u,y=v,depu=dep(u),depv=dep(v);
	while(!path[x])x=fa[x];while(!path[y])y=fa[y];
	if(x==y){
		while(u!=v)depu<depv?(v=fa[v],depv--):(u=fa[u],depu--);return u;
	}
	u=x;x=key[x]?key[x]:find(x);
	v=y;y=key[y]?key[y]:find(y);
	if(x==y)return dep(u)<dep(v)?u:v;
	int z=Lca(x,y);
	if(z==x)return u;if(z==y)return v;
	return p[z];
}
void update(int u,int v,int w){//easy to understand
	if(u==v)update(u,w),update(fa[u],-w);
	else{
		int x=lca(u,v);
		if(x==u)update(v,w),update(fa[u],-w);
		else if(x==v)update(u,w),update(fa[v],-w);
		else update(u,w),update(v,w),update(x,-w),update(fa[x],-w);
	}
}
int ask(int u,int v,int w){//easy to understand
	if(u==v)return ask(u,w)-ask(fa[u],w);
	int x=lca(u,v);
	if(x==u)return ask(v,w)-ask(fa[u],w);
	if(x==v)return ask(u,w)-ask(fa[v],w);
	return ask(u,w)+ask(v,w)-ask(x,w)-ask(fa[x],w);
}
void dfs1(int u,int x){//only used in main()
	fa[u]=x;
	for(int i=0;i<g[u].size();i++)if(g[u][i]==x)g[u].erase(g[u].begin()+i);
	for(int i=0;i<g[u].size();i++){idx[g[u][i]]=i;dfs1(g[u][i],u);}
}
void dfs2(int u){Dep[u]++;for(int v:G[u])if(v)dfs2(v);}//add depth of a subtree, used in add middle point
void dfs3(int u){Dep[u]+=Dep[Fa[u]];for(int v:G[u])if(v)dfs3(v);}//add depth from top to bottom, used in rebuild
void add_middle_point(int u,int v,int w){
	if(fa[v]==u)swap(u,v);//assure that u is the son.
	a[n+1]=w;fa[u]=n+1;fa[n+1]=v;
	g[v][idx[u]]=n+1;idx[n+1]=idx[u];
	g[n+1].pb(u);idx[u]=0;
	if(path[u]){
		int x=key[u]?key[u]:find(u);
		a[n+1]-=tg[x];blk[x].pb(a[n+1]);sort(blk[x].begin(),blk[x].end());
		path[n+1]=1;
		dfs2(x);
	}
	n++;
}
void add_leaf_point(int u,int w){
	a[n+1]=w;fa[n+1]=u;g[u].pb(n+1);idx[n+1]=g[u].size()-1;n++;
}
void rebuild(){
	for(int i=1,u;i<=m;i++)if(tg[i]){
		for(u=p[i];u!=p[Fa[i]];u=fa[u])a[u]+=tg[i];
	}
	for(int i=1;i<=m;i++)G[i].clear(),blk[i].clear();
	cl(p);cl(key);cl(tg);path.reset();
	m=B;p[1]=1;
	for(int i=2;i<=m;i++)p[i]=rnd()%n+1;
	sort(p+1,p+m+1);m=unique(p+1,p+m+1)-p-1;
	for(int i=1;i<=m;i++)key[p[i]]=1;path[1]=1;
	for(int i=2,u;i<=m;i++){
		for(u=p[i];!path[u];u=fa[u])path[u]=1;
		if(!key[u])key[u]=1,p[++m]=u;
	}
	sort(p+1,p+m+1);
	for(int i=1;i<=m;i++)key[p[i]]=i,G[i].resize(g[p[i]].size());
	blk[1].pb(a[1]);Dep[1]=1;
	for(int i=2,lst;i<=m;i++){
		blk[i].pb(a[p[i]]);Dep[i]=1;
		for(Fa[i]=fa[p[i]],lst=p[i];!key[Fa[i]];lst=Fa[i],Fa[i]=fa[Fa[i]])blk[i].pb(a[Fa[i]]),Dep[i]++;
		Fa[i]=key[Fa[i]];G[Fa[i]][idx[lst]]=i;
		sort(blk[i].begin(),blk[i].end());
	}
	dfs3(1);
}
int main(){
	n=read();q=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1,u,v;i<n;i++)u=read(),v=read(),g[u].pb(v),g[v].pb(u);
	dfs1(1,0);rebuild();
	for(int op,u,v,w,lstans=0,cnt=0;q;q--){
		op=read();u=read()^lstans;v=read()^lstans;
		if(op!=2)w=read()^lstans;
		if(op==1)add_middle_point(u,v,w),cnt++;
		if(op==2)add_leaf_point(u,v),cnt++;
		if(op==3)update(u,v,w);
		if(op==4)lstans=ask(u,v,w),print(lstans),pc(10);
		if(cnt==B2)rebuild(),cnt=0;
	}
	flush();
	return 0;
}

```

---


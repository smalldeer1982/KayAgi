# [THUPC 2023 初赛] 乱西星上的空战

## 题目背景

众所周知，在乱西星的现代战争中，制空权是很重要的。为此，人们发展出了无人机技术——遗憾的是，由于乱西星的算法水平和各种意义上的通讯水平实在太落后了，所以这些无人机只能采用各自独立的傻瓜式战斗模式，这些模式不含任何随机因素，因此一场傻瓜式无人机空战总是几乎能在开始前就被预测到结果。

总而言之，乱西星上正在相互战争的 |\\| 国和 () 国的傻瓜式无人机战斗机编队在其边境交界处的空域遭遇了，现在两国军方希望你能预测这一空战的结果。

## 题目描述

### 空域与时刻

由于乱西星的神秘物理法则，乱西星的时间和空间并不是连续的；若认为遭遇战开始的时刻是第 $1$ 时刻，那么对于任意的第 $k\in \N$ 个时刻，在这一时刻开始和结束时，一个物体（无人机或导弹）只能在形如 $(x,y,z)\in\mathbb Z^3$ 的位置（即空域内的整点）上。

### 无人机

由于空域相比无人机要大得多，因此我们可以将无人机视为一个质点（尽管他们实际上长得和地球上的一般意义上的飞机十分相似）。

#### 飞行状态

在每个时刻，一架无人机的飞行状态可以用以下三组参数描述：

1. 当前时刻所在的坐标 $\vec p=(x,y,z)\in\mathbb Z^3$；
2. 当前时刻的飞行方向向量 $\vec{d},\|\vec d\|=1$；
   - 其中， $\|\vec{v}\|$ 表示向量 $\vec v$ 的长度：设 $\vec{v}=(v_x,v_y,v_z)$，则 $\|\vec{v}\|=\sqrt{v_x^2+v_y^2+v_z^2}$。
   - 你可以简单地将 $\vec d$ 理解为机头指向的方向。
3. 当前时刻的无人机升力线方向 $\vec u,\|\vec u\|=1,\vec u\bot \vec d$；
   - 你可以简单的将 $\vec u$ 理解为飞机所在平面的、从机腹指向机背的单位法向量。
   - 此时，$\vec d$ 和 $\vec u$ 可以唯一确定一个“左手向” $\vec l=\vec u\times \vec d$。

#### 飞行性能

不严格地讲，一般而言，一架飞机通常有三个操作轴，即俯仰、滚转和偏航：俯(负杆)和仰(正杆)分别对应飞机机头向下和向上（即保持 $\vec l$ 不变）；滚转即飞机以飞行方向为中轴线旋转（即保持 $\vec d$ 不变）；偏航则为飞机机头向左或者向右（即保持 $\vec u$ 不变）。由于无人机的特殊设计，其**没有偏航**轴，只能进行俯仰和滚转——容易看出，即使仅进行俯仰和滚转，一架无人机也能随意地改变 $\vec d$ 和 $\vec u$ （在保持 $\|\vec u\|=\|\vec d\|=1,\vec u\bot \vec d$ 的前提下）。

以上的俯仰(正杆或负杆)、滚转操作，以及直线飞行，及其复合统称“机动”。

由于无人机型号差异，一架无人机的飞行性能可以用以下三组参数描述（为方便起见，在本节中，对进行一次机动前的飞行状态对应参数为 $\vec p=(x,y,z),\vec d,\vec u,\vec l$，进行一次机动后的飞行状态对应的参数为 $\vec p'=(x',y',z'),\vec d',\vec u',\vec l'$）：

1. 正杆率 $\theta_u\in(\dfrac\pi4,\dfrac\pi2)$ 和负杆率 $\theta_d\in(\dfrac\pi4,\dfrac \pi2)$；
   - 若无人机**仅进行正杆**机动，则必须有 $\vec p=\vec p',\vec l=\vec l',\vec u\cdot \vec d'\ge 0$；此时，进行一次这样的机动花费的时间是 $\dfrac{\angle(\vec d,\vec d')}{\theta_u}$。
   - 若无人机**仅进行负杆**机动，则必须有 $\vec p=\vec p',\vec l=\vec l',\vec u\cdot \vec d'\le 0$；此时，进行一次这样的机动花费的时间是 $\dfrac{\angle(\vec d,\vec d')}{\theta_d}$。
2. 滚转率 $\gamma\in(\dfrac\pi4,\dfrac \pi 2)$；
   - 若无人机**仅进行滚转**机动，则必须有 $\vec p=\vec p',\vec d=\vec d'$；此时，进行一次这样的机动花费的时间是 $\dfrac{\angle(\vec u,\vec u')}{\gamma}$。
3. 飞行极速 $v_{m}>0$；
   - 若无人机**仅进行直线飞行**，则必须有 $\vec d=\vec d',\vec u=\vec u'$；此时，花费的时间是 $\dfrac{\|\vec p'-\vec p\|}{v_m}$。

#### 合法位移

在每个时刻，若一架无人机可以从 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 这一飞行状态，严格按照**滚转**、**俯仰**(正杆或负杆)和**直线飞行**的顺序进行机动，使飞行状态变为 $\vec p'=(x',y',z')\not=\vec p,\vec d',\vec u',\vec l'$，满足 $\vec d'//(\vec p'-\vec p)$，并且各机动花费的时间之和不超过 $1$，则称这是一次(无人机的)合法的综合机动。

如果一架无人机可以从 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 通过一次合法的综合机动，使飞行状态变为 $\vec p'=(x',y',z')\not=\vec p,\vec d',\vec u',\vec l'$，并且在所有使飞行状态变为 $\vec p''=\vec p',\vec d'',\vec u'',\vec l''$ 的合法综合机动中，总用时是最短的，则称之为一次（无人机的）合法位移（或称该位移合法）。此时，无人机会沿直线从 $\vec p$ 移动到 $\vec p'$。如无特殊指明，下文中“位移”均默认(应当为)合法位移。

#### 眼镜蛇机动

在每个时刻，无论无人机飞行性能如何，无人机总是可以通过眼镜蛇机动，从 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 这一飞行状态，变为 $\vec p'=\vec p,\vec d'=\vec u,\vec u'=-\vec d,\vec l'=\vec l$ 这一飞行状态。注意，这种机动不被视为合法机动。

#### 其它参数

除此之外，一架无人机还具有以下参数：

1. 无人机编号（简称“编号”）；
   - 保证任意两架无人机编号不同。
2. 所在阵营（简称“阵营”）；
   - 所在阵营必须是|\\| 国或者是 () 国中之一，并且双方互称敌方阵营。

#### 坠毁

一架无人机坠毁，当且仅当其符合下列条件之一：

1. 在某激活的导弹位移过程中，与该导弹的距离不大于导弹的空爆距离（详见下文）。
2. 在某导弹位移结束后，与该导弹位置重合（从而导弹直接命中无人机导致坠毁，下同）。
3. 在无人机位移过程中，存在至少一枚激活的导弹，与其距离不大于该导弹的空爆距离。
4. 在无人机位移结束后，存在至少一枚导弹所在位置与其位置重合。
5. 在无人机位移结束后，存在另一架无人机与其坐标相同（从而发生碰撞导致双双坠毁）。

无人机坠毁后将立即消失，此后不会发射导弹，也不会导致其它无人机坠毁。但无人机已经发射的导弹不会立刻消失或爆炸。

此时也称无人机被摧毁。

### 空空红外制导导弹

类似的，一枚空空红外制导导弹（下文简称“导弹”）也可视为一质点，并且同样可以描述其飞行状态和飞行性能。

#### 飞行状态

由于导弹无所谓上下左右，因此仅需要以下两组参数以描述一个导弹的飞行状态：

1. 当前时刻所在的坐标 $\vec p=(x,y,z)\in\Z^3$；
2. 当前时刻的飞行方向向量 $\vec{d},\|\vec d\|=1$；
   - 你可以简单地将 $\vec d$ 理解为导弹弹头指向的方向。

#### 飞行性能

同样由于一枚导弹无所谓上下左右，因此其不存在俯仰、滚转和偏航轴，其向各个方向改变 $\vec d$ 的性能是相同的，此时统称仅改变 $\vec d$ 的操作为 "偏航"。其与直线飞行及复合统称“机动”。

因此一枚导弹的飞行性能可以用以下两组参数描述（为方便起见，在本节中，对进行一次机动前的飞行状态对应参数为 $\vec p=(x,y,z),\vec d$，进行一次机动后的飞行状态对应的参数为 $\vec p'=(x',y',z'),\vec d'$）：

1. 偏航率 $\theta_r\in(\dfrac\pi4,\dfrac\pi2)$；
   - 若导弹**仅进行偏航**机动，则必须有 $\vec p=\vec p'$；此时，进行一次这样的机动花费的时间是 $\dfrac{\angle(\vec d,\vec d')}{\theta_r}$；
2. 飞行极速 $v_m>0$；
   - 若导弹**仅进行直线飞行**，则必须有 $\vec d=\vec d'$；此时，花费的时间是 $\dfrac{\|\vec p'-\vec p\|}{v_m}$。

#### 合法位移

在每个时刻，若一枚导弹可以从 $\vec p=(x,y,z),\vec d$ 这一飞行状态，严格按照**偏航**和**直线飞行**的顺序进行机动，使飞行状态变为 $\vec p'=(x',y',z')\not=\vec p,\vec d'$，满足 $\vec d//(\vec p'-\vec p)$，并且各机动花费的时间之和不超过 $1$，则称这是一次(导弹的)合法位移（或称该位移合法）。此时，导弹会沿直线从 $\vec p$ 移动到 $\vec p'$。如无特殊指明，下文中“位移”均（应当）默认为合法位移。

#### 其它参数

除此之外，一枚导弹还具有以下参数：

1. 保险距离 $d_s>0$ 和激活状态；
   - 导弹被发射后立即处于未激活状态。
   - 每个时刻结束时，若导弹处于未激活状态，并且发射该导弹的无人机已坠毁，或者与发射该导弹的无人机的距离大于保险距离 $d_s$ 时，进入激活状态。此后将保持激活状态，并称该导弹被激活，或称其为一枚激活的导弹。
2. 空爆距离 $d_p>0$；
   - 每次导弹位移过程中，当一枚激活的导弹与任一无人机（包括发射该导弹的无人机）距离不大于 $d_p$ 时，该导弹会进入可空爆状态（详见下文“可空爆”）。
   - 每次无人机位移过程中，若存在一无人机与一枚激活的导弹距离不大于 $d_p$ 时，该导弹也会进入可空爆状态。
3. 最大锁定角 $\beta_s\in(\dfrac\pi4,\dfrac\pi2)$；
   - 任意时刻，一枚飞行状态为 $\vec p=(x,y,z),\vec d$、最大锁定角的导弹能锁定到 $\vec p'$ 处的无人机，当且仅当 $\vec d\cdot(\vec p'-\vec p)>0$，并且 $\angle(\vec d,\vec p'-\vec p)\le \beta_s$。
   - 此时称该无人机能被该导弹锁定，或称其在导弹的锁定范围内。
   - 称 $\angle(\vec d,\vec p'-\vec p)$ 为锁定角。
4. 制导时长 $t_z>0$；
   - 若导弹在第 $k$ 个时刻被发射，则到第 $k+t_z$ 个时刻结束时，若导弹仍未爆炸，则导弹会立刻消失（见“爆炸、消失与可空爆”）。此时称导弹超过制导时长。

#### 爆炸、消失与可空爆

一枚导弹在符合下列全部条件时，会立刻爆炸并消失：

1. 在导弹位移开始前，导弹处于激活状态；

2. 符合以下条件之一：
   
   1. 在该导弹位移过程中，存在一架位于 $\vec q$ 的无人机，使 $\min_{\lambda\in[0,1]}\|\lambda \vec p+(1-\lambda)\vec p'-\vec q\|\le d_p$，其中  $\vec p,\vec p'$ 为导弹本次位移的起点和终点。
      
      - 此时，所有这样的无人机都会被该导弹摧毁。同时，一架无人机可能同时被若干枚导弹摧毁。
   
   2. 在无人机位移过程中，存在一架无人机，记其从位置 $\vec q$ 位移到 $\vec q'$ ，满足 $\min_{\lambda\in[0,1]}\|\lambda \vec q+(1-\lambda)\vec q'-\vec p\|\le d_p$，其中 $\vec p$ 为导弹此时的位置。
      
      - 此时，所有这样的无人机都会被该导弹摧毁。同时，该导弹也可能同时摧毁若干这样的无人机。

此时，称该导弹可空爆，或该导弹进入可空爆状态。

一枚导弹在符合下列条件之一时，不会发生爆炸，但是会在当前时刻结束时消失：

1. 导弹脱锁（见下文“导弹脱锁”），并且在当前时刻开始时已被激活；

2. 导弹超过制导时长；

3. 导弹未激活，并且导弹位移结束后与一无人机位置重合；
   
   - 此时，该无人机会被这枚导弹摧毁。同时，一架无人机可能同时被若干枚导弹摧毁。

4. 导弹未激活，无人机位移结束后，该导弹与一无人机位置重合。
   
   - 此时，该无人机会被这枚导弹摧毁。同时，一枚导弹可能同时摧毁若干这样的无人机。

### 无人机视野、雷达搜索与导弹锁定

#### 无人机视野

任意时刻，一架飞行状态为 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 的无人机能够发现一架位于 $\vec p'=(x',y',z')$ 的无人机，当且仅当 $\vec d\cdot(\vec p'-\vec p)> 0$；此时称 $\vec p'$ 处的无人机在 $\vec p$ 处无人机的视野内。

#### 无人机机载雷达搜索范围

一架无人机的机载雷达（下文简称“雷达”）的扫描范围可以用以下两个参数描述：

1. 水平扫描范围 $L_x\in\N^+$ 和垂直扫描范围 $H_y\in\N^+$；
   - 任意时刻，一架飞行状态为 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 、雷达扫描范围为 $L_x,H_y$ 的无人机的能够扫描到一架位于 $\vec p'$ 的无人机，当且仅当，$\vec d\cdot(\vec p'-\vec p)>0$ 并且 $\exist x,y,s.t.\ |x|\le L_x,|y|\le H_y$ 且 $[\vec p'-(\vec p+x\vec l+y\vec u)]//\vec d$。
   - 即若以 $\vec p$ 为原点、以 $\vec l$ 和 $\vec u$ 为 $X,Y$ 轴建一平面 $\alpha=\alpha(\vec p;\vec l,\vec u)$，则  $\vec p'$ 在这一平面上的投影 $\vec r=P(\vec p';\alpha)$ 应当落在 $[-L_x,L_x]\times [-H_y,H_y]$ 中。
   - 此时称 $\vec p'$ 处的无人机在 $\vec p$ 处无人机雷达扫描范围内。

#### 导弹脱锁

当无人机位移结束后，若一枚导弹选定的目标已坠毁，或其不能被该导弹锁定，则称该导弹脱锁，或处于脱锁状态。

此后将一直保持脱锁状态，无论是否此前选定的无人机是否重新可以被导弹锁定。

### 无人机选定目标策略

任意时刻，无人机（简称"本机"，下同）按下述策略选择目标无人机。

1. 若本机视野内无敌方阵营无人机（简称“敌机”，下同），则本机无选定目标；
2. 否则，若上一时刻本机选择的无人机仍位于本机视野内，则本机仍选定该目标；
3. 否则，若存在至少一架敌机处于本机雷达扫描范围内，则选取其中与本机距离最近的；若与本机距离最近的敌机不唯一，则选取编号最小的。
4. 否则，对视野内的处于 $\vec p'$ 的敌机，记 $\alpha=\alpha(\vec p;\vec l,\vec u),\vec r=P(\vec p';\alpha)=(r_x,r_y)$，则选取 $\min\{|r_x-L_x|,|r_x+L_x|\}+\min\{|r_y-H_y|,|r_y+H_y|\}$ 最小的。若有多个最小值，则同样选择编号最小的。

### 飞行策略

#### 无人机飞行策略

设无人机飞行状态是 $\vec p=(x,y,z),\vec d,\vec u,\vec l$，其飞行极速为 $v_m$，机载雷达扫描范围为 $L_x,H_y$。

1. 若无人机有位于 $\vec p'$ 的选定目标：
   1. 若无人机能够合法地位移到某个位置，使敌机现在的位置 $\vec p'$ 仍处于本机的视野内，则无人机会合法地移动到飞行状态 $\vec q=(x_q,y_q,z_q),\vec d_q,\vec u_q,\vec l_q$，使敌机现在的位置 $\vec p'$ 仍处于本机视野内，且 $\|\vec p'-\vec q\|$ 最小。
      1. 若有多个这样的位置，记 $\alpha_q=\alpha(\vec q;\vec l_q,\vec u_q),\vec r_q=P(\vec p';\alpha_q)=(r_{qx},r_{qy})$，则优先选取使 $\vec r_q=(r_{qx},r_{qy})\in[-L_x,L_x]\times [-H_y,H_y]$ 的位置；
         1. 若仍有多个这样的位置，则选取使 $\|\vec r_q\|=\sqrt{r_{qx}^2+r_{qy}^2}$ 最小的；
         2. 若仍有多个这样的位置，则选取 $\vec q$ 字典序最小的。
      2. 若不存在这样的 $\vec r_q$，则选取使 $\min\{|r_{qx}-L_x|,|r_{qx}+L_x|\}+\min\{|r_{qy}-H_y|,|r_{qy}+H_y|\}$ 最小的；
         1. 若仍有多个这样的位置，则选取 $\vec q$ 字典序最小的。
   2. 否则，无人机会合法地移动到某个位置 $\vec q$，使 $\|\vec q-\vec p-v_m\vec d\|$ 最小；
      1. 若有多个这样的位置，则选取 $\vec q$ 字典序最小的。
2. 否则，无人机通过眼镜蛇机动，将飞行状态变为 $\vec p=(x,y,z),\vec u,-\vec d,\vec l$。

保证在上述1.的情况下，无人机总能合法地移动到某个位置。

#### 导弹飞行策略

设导弹当前时刻飞行状态 $\vec p,\vec d$，其选定的敌机飞行状态为 $\vec p',\vec d',\vec u',\vec l'$；

若上一时刻结束时，导弹未脱锁，则记 $\vec q'$ 为敌机根据其飞行策略，下一时刻会移动到的位置。

若导弹能合法位移到 $\vec q'$，则导弹会直接位移到 $\vec q'$。

否则，导弹会合法地位移到能使敌机位移后的位置 $\vec q'$ 处于锁定范围内的位置 $\vec q$ ，且 $\|\vec q-\vec q'\|$ 最小。

1. 若有多个这样的 $\vec q$，则选取位移后锁定角最小的；
2. 若仍有多种可能，则选取 $\vec q$ 字典序最小的。

若不存在这样的位置，或者上个时刻结束时，导弹已经脱锁，则导弹会合法地位移到某个位置 $\vec q$，使 $\|\vec q-\vec p-v_m\vec d\|$ 最小。

保证导弹总能合法地移动到某个位置。

### 无人机发射导弹规则

一飞行状态为 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 的无人机（简称"本机"）向**被本机选定**的、处于 $\vec p'$ 的目标无人机（简称“敌机”）发射导弹的规则为：

在每个时刻开始时，若选定的敌机已处于本机雷达扫描范围内，且当前不存在由本机发射且未爆炸（或消失）的导弹，则向敌机发射一初始飞行状态为 $\vec p,\vec d=\dfrac{\vec p'-\vec p}{\|\vec p'-\vec p\|}$ 的未激活的导弹，该导弹选定敌机。

### 同一时刻内各事件发生顺序

1. 所有无人机选定目标，并确定当前时刻内的飞行策略；
2. 所有能发射导弹的无人机发射导弹；
3. 所有导弹确定飞行策略并位移，该过程中部分无人机可能被摧毁；
4. 所有可空爆的导弹爆炸并消失；
5. 所有无人机按 1. 中确定的飞行策略位移，该过程中部分无人机可能被摧毁；
6. 所有可空爆的导弹爆炸并消失；
7. 所有位置相同的无人机发生碰撞并坠毁。
8. 所有超过制导时长和脱锁且已激活的导弹消失。
9. 所有可激活的导弹被激活。

### 任务

给定空域开始时（即第 $1$ 时刻开始时），各无人机的飞行性能与状态、导弹的飞行性能，假定这场空战会持续 $T$ 个时刻，双方指挥官希望你能按时间顺序依次给出每个时刻发生的所有重要事件。

## 说明/提示

#### 样例解释 1

在第 $1$ 时刻，两架飞机于 $(4,0,0)$ 处相撞。

#### 样例解释 2

在第 $4$ 时刻，两枚导弹分别摧毁了敌机。

#### 数据范围

$T,n\le 100,3\le v_m\le 20$；

$v_m>10$ 的无人机和导弹总数不超过 $10$；

$\theta_u,\theta_d,\gamma,\theta_r,\beta_s\in(\dfrac\pi4,\dfrac\pi2)$；

$1\le d_s,d_p\le 20,1\le t_z\le 100$；

$|x|,|y|,|z|\le 100$；

$1\le L_x,H_y\le 100$。

所有输入的实数精确到小数点后不超过 $6$ 位。

最初时，$\vec p$ 两两不同。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
1 1
0 0 0
1 0 0 0 0 1
1 1 1 4 1 1
1 3 1 1 1 1
8 0 0
-1 0 0 0 0 1
1 1 1 4 1 1
1 3 1 1 1 1
```

### 输出

```
0 0 1
2 1 2
```

## 样例 #2

### 输入

```
1 4
0 0 0
1 0 0 0 0 1
1 1 1 3 1 1
1 15 3 2 1 10
60 0 0
-1 0 0 0 0 1
1 1 1 3 1 1
1 15 3 2 1 10
```

### 输出

```
0 0 0
0 0 0
0 0 0
0 2 0
1 1 2
2 1 1
```

# 题解

## 作者：tiger2005 (赞：55)

[提交记录信息](https://www.luogu.com.cn/record/104003469) / [官方数据集](https://github.com/THUSAAC/THUPC2023-Pre/tree/master/day0/I) / [原题传送](https://www.luogu.com.cn/problem/P9141)

不得不说，这道题目扔到一个 4.5 小时的 ACM 竞赛里面确实有些丧尽天良了.jpg

## 0x00 题意

你需要模拟一系列非常复杂的空中战争系统，具体请仔细阅读原题信息。

## 0x01 向量

这道题目的状态绕不开三维向量，故我们需要实现一个基础的三维向量类，以及一些基础的数学函数：

```cpp
const double PI = -acos(-1.0);
const double EPS = 1e-9;

bool isZero (double x) {
  return abs(x) < EPS;
}

double clamp (double x) {
  return max(-1.0, min(x, 1.0));
}

struct Vec3 {
  double x, y, z;
  Vec3 (double x, double y, double z)
    :x(x), y(y), z(z) {}
  Vec3 () {
    x = y = z = 0;
  }
  double Dot (Vec3 v) {
    return x * v.x + y * v.y + z * v.z;
  }
  Vec3 Cross (Vec3 v) {
    return Vec3(
      y * v.z - z * v.y,
      z * v.x - x * v.z,
      x * v.y - y * v.x
    );
  }
  double Length () {
    return sqrt(x * x + y * y + z * z);
  }
  Vec3 operator - () {
    return Vec3 (-x, -y, -z);
  }
  Vec3 operator + (Vec3 v) {
    return Vec3 (
      x + v.x, y + v.y, z + v.z
    );
  }
  Vec3 operator * (double len) {
    return Vec3 (x * len, y * len, z * len);
  }
  Vec3 operator / (double len) {
    return *this * (1 / len);
  }
  Vec3 Norm () {
    return (*this) / (*this).Length();
  }
  Vec3 operator - (Vec3 v) {
    return *this + (-v);
  }
  double Angle (Vec3 v) {
    return acos(clamp(Dot(v)));
  }
  bool _isZero () {
    return isZero(Length());
  }
  void init () {
    scanf(" %lf %lf %lf", &x, &y, &z);
  }
};
```

注意在将点乘结果套入 `acos()` 函数前，需要先 `clamp()` 一下，防止结果小于 -1 导致返回 `nan`。

这道题涉及到点到线段的距离，以及三维向量到面的映射。前者可以通过分类讨论解决，后者只需要通过点乘计算出在单位向量的分向量，故有：

```cpp
double minLength (Vec3 a, Vec3 b, Vec3 c) {
  Vec3 ca = a - c, cb = b - c, ab = b - a;
  if (ca.Dot(ab) > 0)
    return ca.Length();
  if (ab.Dot(cb) < 0)
    return cb.Length();
  return ca.Cross(cb).Length() / ab.Length();
}

pair<double, double> Alpha (Vec3 x, Vec3 y, Vec3 p) {
  return make_pair(x.Dot(p), y.Dot(p));
}
```

## 0x02 无人机

先定义类：

```cpp
struct Plane {
  Vec3 p, d, u, l;
  int id, from;
  bool crashed;
  int target;
  double tu, td, gm, v, lx, hy;
  Vec3 strategy;
};
```

考虑计算将飞机移动到一个位置时的代价。根据题目条件，显然可以得到：一个合法移动应该是所有到达同等位置的移动中最快的，故不会停停走走，而是连续进行操作到达目的地。代价需要分三部分计算：

- **滚动**：考虑到在滚动后 $\vec{l}$ 需要垂直于 $\vec{d}$ 和 $\vec{d'}$ 形成的面上，故先计算出这个面的法向量（只需要一次叉乘），判断是否需要翻转后计算和 $\vec{l}$ 的夹角即可。此处需要特判 $\vec{d}$ 和 $\vec{d'}$ 平行的情况，在这个情况下可以不滚动。
- **俯仰**：直接计算 $\vec{d}$ 和 $\vec{d'}$ 的夹角即可。
- **直线移动**：直接计算位置距离即可。

那么我们可以写出估价和移动代码：

```cpp
double planeMoveCost (Plane &p, Vec3 delta) {
  Vec3 dir = delta.Norm();
  Vec3 L = p.d.Cross(dir);
  if (L._isZero())
    L = p.l;
  else {
    L = L.Norm();
    if (L.Dot(p.l) < 0)
      L = - L;
  }
  double SpinTo = L.Angle(p.l);
  double RotateTo = p.d.Angle(dir);
  return SpinTo / p.gm + RotateTo / (p.u.Dot(dir) >= 0 ? p.tu : p.td) + delta.Length() / p.v;
}

void planeMoveTo (Plane &p, Vec3 delta) {
  if (delta._isZero()) {
    swap(p.u, p.d);
    p.u = - p.u;
    return;
  }
  p.p = p.p + delta;
  Vec3 dir = delta.Norm();
  Vec3 L = p.d.Cross(dir);
  if (L._isZero())
    L = p.l;
  else {
    L = L.Norm();
    if (L.Dot(p.l) < 0)
      L = - L;
  }
  p.d = dir;
  p.l = L;
  p.u = p.d.Cross(p.l);
}
```

## 0x03 导弹

依然先定义类：

```cpp
struct Missle {
  Vec3 p, d;
  double tr, v, ds, dp, bs;
  bool activated;
  bool explosive;
  bool used;
  bool lost;
  int target;
  int tz;
  int id;
  Vec3 strategy;
};
```

导弹的代价计算相对简单，偏航角度就是两个飞行方向的夹角，长度也很好算，故有：

```cpp
double missleMoveCost (Missle& m, Vec3 delta) {
  Vec3 dir = delta.Norm();
  double SpinTo = m.d.Angle(dir);
  return SpinTo / m.tr + delta.Length() / m.v;
}

void missleMoveTo (Missle &m, Vec3 delta) {
  m.p = m.p + delta;
  Vec3 dir = delta.Norm();
  m.d = dir;
  -- m.tz;
}

```

## 0x04 策略

无人机需要在时刻开始时确定目标。根据题目的分布条件，我们可以编写一些辅助函数，从而快速实现。

其中，判定视野直接利用题目公式点乘判断即可，判断雷达也可以利用前面实现的 `Alpha()` 函数计算。我们可以通过“需不需要换 -> 有没有雷达区内的 -> 有没有视野内的”的顺序枚举并判断。

```cpp
bool inView (Plane &p, Plane &q) {
  return p.d.Dot(q.p - p.p) > EPS;
}

bool detective (Plane &p, Plane &q) {
  if (! inView(p, q))
    return false;
  pair<double, double> loc = Alpha(p.l, p.u, q.p - p.p);
  return abs(loc.first) <= p.lx + EPS && abs(loc.second) <= p.hy + EPS;
}

void planeChoose (Plane &p) {
  if (p.target != 0 && !planes[p.target].crashed && inView(p, planes[p.target]))
    return;
  p.target = 0;
  double q1 = 1e18;
  int id = -1;
  for (int i = 1; i <= 2 * N; i ++) {
    if (i == p.id || planes[i].crashed || planes[i].from == p.from)
      continue;
    if (detective (p, planes[i])) {
      double val = (p.p - planes[i].p).Length();
      if (q1 - val > EPS) {
        q1 = val;
        id = i;
      }
    }
  }
  if (id != -1) {
    p.target = id;
    return;
  }
  q1 = 1e18, id = -1;
  for (int i = 1; i <= 2 * N; i ++) {
    if (i == p.id || planes[i].crashed || planes[i].from == p.from)
      continue;
    if (inView (p, planes[i])) {
      pair<double, double> loc = Alpha(p.l, p.u, planes[i].p - p.p);
      double val = min(abs(loc.first - p.lx), abs(loc.first + p.lx))
                  + min(abs(loc.second - p.hy), abs(loc.second + p.hy));
      if (q1 - val > EPS) {
        q1 = val;
        id = i;
      }
    }
  }
  if (id != -1) {
    p.target = id;
    return;
  }
}
```

随后就是策略选择。考虑到每个时刻前后无人机只会出现在整点处，而 $v_m$ 范围并不大，故可以直接枚举附近的整点，判断代价后借助题目提供的流程翻译成对应代码就好了。相信来到这一步，你对题目设计的专业名词已经很熟悉了！

代码中 `Vec(0, 0, 0)` 代表眼镜蛇机动标识，因为一个合法的机动必然需要移动。

```cpp
void planeStrategy (Plane &p) {
  if (!p.target)
    p.strategy = Vec3 (0, 0, 0);
  else {
    Plane q = planes[p.target];
    int P = floor(p.v);
    Vec3 cur;
    double q1 = 1e18, q2 = 1e18;
    vector<pair<Vec3, Plane> > vs;
    for (int i = - P; i <= P; i ++)
      for (int j = - P; j <= P; j ++)
        for (int k = - P; k <= P; k ++)
          if ((i != 0 || j != 0 || k != 0) && (cur = Vec3(i, j, k)).Length() <= p.v) {
            Plane np = p;
            double l = (p.p + cur - q.p).Length();
            if (planeMoveCost(np, cur) <= 1.0 + EPS) {
              planeMoveTo(np, cur);
              if (inView(np, q)) {
                if (q1 - l > EPS)
                  vs.clear(), q1 = l;
                if (isZero(q1 - l))
                  vs.emplace_back(cur, np);
              }
            }
          }
    q1 = 1e18; int id = -1;
    bool det = false;
    for (int i = 0; i < (int)vs.size(); i ++) {
      Plane np = vs[i].second;
      pair<double, double> loc = Alpha(np.l, np.u, q.p - np.p);
      if (detective(np, q)) {
        det = true;
        double val = sqrt(loc.first * loc.first + loc.second * loc.second);
        if (q1 - val > EPS)
          q1 = val, id = i;
      }
      else if (! det) {
        double val = min(abs(loc.first - np.lx), abs(loc.first + np.lx))
                  + min(abs(loc.second - np.hy), abs(loc.second + np.hy));
        if (q2 - val > EPS)
          q2 = val, id = i;
      }
    }
    if (id != -1)
      p.strategy = vs[id].first;
    else {
      Vec3 exp = p.d * p.v;
      Vec3 str = Vec3(0, 0, 0);
      for (int i = - P; i <= P; i ++)
        for (int j = - P; j <= P; j ++)
          for (int k = - P; k <= P; k ++)
            if ((i != 0 || j != 0 || k != 0) && (cur = Vec3(i, j, k)).Length() <= p.v) {
              if (planeMoveCost(p, cur) <= 1.0 + EPS) {
                double val = (exp - cur).Length();
                if (q1 - val > EPS)
                  q1 = val, str = cur;
              }
            }
      p.strategy = str;
    }
  }
}
```

导弹也需要实现策略。在实现锁定角相关的辅助函数后，这部分代码也不难写出，也不难发现和无人机策略代码类似。

```cpp
double missleAngle (Missle &m, Plane &p) {
  Vec3 v = (p.p - m.p).Norm();
  return v.Angle(m.d);
}

bool missleDetective (Missle &m, Plane &p) {
  if (p.crashed)
    return false;
  if (m.d.Dot(p.p - m.p) <= 0)
    return false;
  return missleAngle(m, p) <= m.bs;
}

void missleStrategy (Missle &m) {
  int P = floor(m.v);
  Vec3 cur;
  double q1 = 1e18;
  if (m.target) {
    if (!m.lost) {
      Plane q = planes[m.target];
      planeMoveTo(q, q.strategy);
      vector<pair<Vec3, Missle> > vs;
      for (int i = - P; i <= P; i ++)
        for (int j = - P; j <= P; j ++)
          for (int k = - P; k <= P; k ++)
            if ((i != 0 || j != 0 || k != 0) && (cur = Vec3(i, j, k)).Length() <= m.v) {
              Missle nm = m;
              double l = (m.p + cur - q.p).Length();
              if (missleMoveCost(nm, cur) <= 1.0 + EPS) {
                missleMoveTo(nm, cur);
                if (isZero(l) || missleDetective(nm, q)) {
                  if (q1 - l > EPS)
                    q1 = l, vs.clear();
                  if (isZero(q1 - l))
                    vs.emplace_back(cur, nm);
                }
              }
            }
      if (isZero(q1)) {
        m.strategy = vs[0].first;
        return;
      }
      q1 = 1e18; int id = -1;
      for (int i = 0; i < (int)vs.size(); i ++) {
        double val = missleAngle(vs[i].second, q);
        if (q1 - val > EPS)
          q1 = val, id = i;
      }
      if (id != -1) {
        m.strategy = vs[id].first;
        return;
      }
    }
  }

  Vec3 exp = m.d * m.v;
  Vec3 str = Vec3(0, 0, 0);

  for (int i = - P; i <= P; i ++)
    for (int j = - P; j <= P; j ++)
      for (int k = - P; k <= P; k ++)
        if ((i != 0 || j != 0 || k != 0) && (cur = Vec3(i, j, k)).Length() <= m.v) {
          if (missleMoveCost(m, cur) <= 1.0 + EPS) {
            double val = (exp - cur).Length();
            if (q1 - val > EPS)
              q1 = val, str = cur;
          }
        }
  m.strategy = str;
}
```

## 0x05 发射导弹

无人机在空闲情况下会朝着敌方发射导弹。这一部分其实相当容易实现，只需要新增一个空闲数组即可。

```cpp
void launchMissle (Plane &p) {
  if (p.target != 0 && detective(p, planes[p.target]) && !idle[p.id]) {
    Vec3 _p = planes[p.target].p;
    Missle m = missleOpts[p.id];
    m.p = p.p;
    m.d = (_p - p.p).Norm();
    m.target = p.target;
    missles.push_back(m);
    idle[p.id] = true;
  }
}
```

## 0x06 事件整理

最后根据题目提供时刻事件表，将所有的步骤变成对应的代码，我们就得到了主函数：

```cpp
vector<int> killList[210];

void generateKillMessage (vector<pair<int, int> > kills) {
  for (int i = 1; i <= 2 * N; i ++)
    killList[i].clear();
  for (auto l: kills)
    killList[l.second].push_back(l.first);
  for (int i = 1; i <= 2 * N; i ++) if (killList[i].size() != 0) {
    printf("%d %d ", i, (int)killList[i].size());
    sort(killList[i].begin(), killList[i].end());
    for (auto x: killList[i])
      printf("%d ", x);
    printf("\n");
  }
}

int main() {
  scanf("%d %d", &N, &T);
  for (int i = 1; i <= 2 * N; i ++) {
    planes[i].p.init();
    planes[i].d.init();
    planes[i].u.init();
    planes[i].l = planes[i].u.Cross(planes[i].d);
    scanf(" %lf %lf %lf %lf %lf %lf", &planes[i].tu, &planes[i].td, &planes[i].gm, &planes[i].v, &planes[i].lx, &planes[i].hy);
    scanf(" %lf %lf %lf %lf %lf %d", &missleOpts[i].tr, &missleOpts[i].v, &missleOpts[i].ds, &missleOpts[i].dp, &missleOpts[i].bs, &missleOpts[i].tz);
    planes[i].id = missleOpts[i].id = i;
    planes[i].from = i <= N;
    ++ missleOpts[i].tz;
  }
  while (T --) {
    vector<pair<int, int> > kills1(0);
    vector<pair<int, int> > kills2(0);
    vector<vector<int> > group(0);
    int ANS1 = 0, ANS2 = 0;
    // 所有无人机选定目标，并确定当前时刻内的飞行策略
    for (int i = 1; i <= 2 * N; i ++) {
      if (planes[i].crashed)
        continue;
      planeChoose(planes[i]);
      planeStrategy(planes[i]);
    }
    // 所有能发射导弹的无人机发射导弹
    for (int i = 1; i <= 2 * N; i ++) {
      if (planes[i].crashed)
        continue;
      launchMissle(planes[i]);
    }
    // 所有导弹确定飞行策略并位移，该过程中部分无人机可能被摧毁
    for (auto &m: missles) {
      missleStrategy(m);
      Vec3 f = m.p, t = m.p + m.strategy;
      missleMoveTo(m, m.strategy);
      if (!m.activated) {
        for (int i = 1; i <= 2 * N; i ++) {
          if (!planes[i].crashed && (planes[i].p - m.p)._isZero()) {
            kills1.emplace_back(m.id, i);
            m.explosive = true;
          }
        }
      }
      else {
        for (int i = 1; i <= 2 * N; i ++) {
          if (!planes[i].crashed && minLength(f, t, planes[i].p) <= m.dp) {
            kills1.emplace_back(m.id, i);
            m.explosive = true;
          }
        }
      }
    }
    for (auto l: kills1) {
      if (! planes[l.second].crashed) {
        planes[l.second].crashed = true;
        ++ ANS1;
      }
    }
    // 所有可空爆的导弹爆炸并消失
    for (auto &m: missles) {
      if (m.explosive && !m.used) {
        m.used = true;
        idle[m.id] = false;
      }
    }
    // 所有无人机按 1. 中确定的飞行策略位移，该过程中部分无人机可能被摧毁
    for (int i = 1; i <= 2 * N; i ++) {
      if (planes[i].crashed)
        continue;
      Vec3 f = planes[i].p, t = planes[i].p + planes[i].strategy;
      planeMoveTo(planes[i], planes[i].strategy);
      for (auto &m: missles) {
        if (m.activated && !m.used && minLength(f, t, m.p) <= m.dp) {
          kills2.emplace_back(m.id, i);
          m.explosive = true;
        }
        else if (!m.activated && !m.used && (m.p - planes[i].p)._isZero()) {
          kills2.emplace_back(m.id, i);
          m.explosive = true;
        }
      }
    }
    for (auto l: kills2) {
      if (! planes[l.second].crashed) {
        planes[l.second].crashed = true;
        ++ ANS2;
      }
    }
    // 所有可空爆的导弹爆炸并消失
    for (auto &m: missles) {
      if (m.explosive && !m.used) {
        m.used = true;
        idle[m.id] = false;
      }
    }
    // 所有位置相同的无人机发生碰撞并坠毁
    for (int i = 1; i <= 2 * N; i ++) {
      if (planes[i].crashed)
        continue;
      vector<int> v(0);
      v.push_back(i);
      for (int j = i + 1; j <= 2 * N; j ++) {
        if (!planes[j].crashed && (planes[j].p - planes[i].p)._isZero())
          v.push_back(j);
      }
      if (v.size() > 1) {
        group.push_back(v);
        for (auto p: v)
          planes[p].crashed = true;
      }
    }
    // 所有超过制导时长和脱锁且已激活的导弹消失
    for (auto &m: missles) {
      if (!m.used) {
        if (!missleDetective(m, planes[m.target]))
          m.lost = true;
        if (m.tz == 0 || (m.activated && m.lost)) {
          m.used = true;
          idle[m.id] = false;
        }
      }
    }
    // 所有可激活的导弹被激活
    vector<Missle> nms;
    for (auto &m: missles) {
      if (!m.used) {
        if (planes[m.id].crashed || (m.p - planes[m.id].p).Length() > m.ds)
          m.activated = true;
        nms.push_back(m);
      }
    }
    missles = nms;

    printf("%d %d %d\n", ANS1, ANS2, (int)group.size());
    generateKillMessage(kills1);
    generateKillMessage(kills2);
    for (auto v: group) {
      printf("%d ", (int)v.size());
      for (auto x: v)
        printf("%d ", x);
      printf("\n");
    }
  }
  return 0;
}
```

整合后得到最终代码：[这里](https://www.luogu.com.cn/paste/ewhkj68t)。

## 0x07 结束了……？

当然没有。这道题目设立了相当多的坑点，稍有不慎就会误入歧途。

- 题目中的制导时长 $t_z$ 代表 导弹可以操作进行 **最多 $t_z + 1$ 次** 控制，而不是 $t_z$ 次。如果你在每一次控制后将寿命减去 1，千万要主意这点。
- 请注意代码中 $\epsilon$ 的使用！如果你在一些地方缺失了浮点数判断，那么就可能导致目标计算错误而导致偏航！
- 导弹事件的触发机制比较复杂，请不要默认一些操作的条件。
- 这道题目设计了多个函数对一个函数的复用。请注意复用时被调用函数内部变量是否符合预期。

## 0xff 趣闻 

1. 这份代码我花了一个晚上（3 小时）写完，又花了一个晚上（4 小时）调试完毕。至于为什么，我相信大家也都知道了。
2. 这份代码后半部分调试运用到了官方数据集的正确代码和数据。std 可读性比我的代码差得多了！
3. 我在官方数据集下找到了三份 std，随后扔到了 Lemonlime 一起测试，于是：![](https://cdn.luogu.com.cn/upload/image_hosting/21soj4hi.png)

---

## 作者：寄风 (赞：41)

## part -1 废话
他妈的，什么破题什么破题什么破题什么破题什么破题什么破题。

（请不要理会这位发疯人士）

如果在题解里有任何不明白的地方，可以去看代码，里面的注释应该是比较清楚的。当然，也欢迎私信询问。
## part 0 题意
模拟一场三维空间下的空战。具体题意过于复杂，不再阐述。
## part 1 三维向量
因为这道题不仅仅是大模拟，还是个计算几何题，所以我们需要实现一个基础的三维向量。~~（至于怎么写，自行 bdfs 吧我也是百度的）~~

然后就是记得在求夹角的时候记得先让算出的值与 $1$ 取最小，与 $-1$ 取最大，不然套 `acos` 的时候会出现玄学错误，WA on #8。

然后这道题涉及到点到线的距离，这个直接分讨，还涉及到向量到平面的投影，直接叉乘判断。
## part 2 无人机
首先一眼丁真，合法移动绝对是一次性移完的，不会在滚转、俯仰和直线飞行间停留。

考虑计算无人机移动的代价，容易想到按照**滚转**、**俯仰**和**直线飞行**的顺序分别计算代价。

然后因为我们之前已经实现了数学函数，所以直接按照题意算代价即可。
## part 3 导弹
导弹的代价十分好算，因为题目中的偏航角度其实就是两个向量间的夹角，然后长度也很好算，所以继续按照题意算代价、移动即可。
## part 4 无人机的锁定目标与移动策略
分两个部分解决。
### 第一部分：锁定目标
是否在视野内可以直接用题面给的公式点乘判断，而雷达部分就可以采用之前写好的获取三维向量到平面的投影的函数来完成。

判断顺序：
判断要不要切换目标 -> 有没有在雷达区域内的 -> 有没有在视野内的。
### 第二部分：移动策略的选择
由于无人机的坐标均为整数，而坐标的值域并不大，所以我们直接枚举无人机附近的整点，按照题意计算即可。

因为合法机动必须要移动，所以我们可以用 一个三个值均为 $0$ 的三维向量来表示眼镜蛇机动。

导弹类似，不再阐述。
## part 5 导弹的锁定目标与移动策略
类似于无人机，不再阐述。
## part 6 发射导弹
这一步相当简单，用一个数组来表示无人机是否空闲即可。
## part 7 按次序模拟事件并打印
理清顺序，按次序模拟即可。

[最终代码](https://www.luogu.com.cn/paste/f8ul4jce)

---

## 作者：liuzhangfeiabc (赞：25)

大家好我又来了，这次带给大家的依然是 THUPC 的传统艺能大模拟~

个人点评：这题是我个人写完并通过的算法竞赛中的大模拟题中最长的一道，但可能并非最难写的。甚至在我看来，在你有一个相对完整的三维计算几何模板的情况下，码长只有这题三分之一的 [P7147 [THUPC2021 初赛] 麻将模拟器](https://www.luogu.com.cn/problem/P7147) 的实现难度都不低于这题。

究其原因，这题的模块化特别强，各个模块之间基本上相对独立，特别适合进行抽象及使用各种 oop 技巧，尤其是在题目已经天然地给你划分好阶段的前提下。这样下来的整个编码逻辑是十分清晰的，尤其不会出现像我写 [P7610 [THUPC2021] 群星连结](https://www.luogu.com.cn/problem/P7610) 时各种逻辑线搅乱在一起根本不知道下一步该开哪一条的现象。

甚至于我在赛前预测，说不定会有队伍专门来写这题。如果队友们能有效地并行工作，每人写一个模块的话，应该是有希望在赛时写完并调过的，但是为什么没有队这么干呢 qwq。

我们一点点来看吧：

首先，正如麻将模拟器那题的真正难点在于 dp，这题的真正难点大概在于计算几何部分吧。除了常规的空间向量运算外，还有点到线段的距离、点在平面上的投影等。如果第一次写可能会绕不过弯来，但是熟练了或者有现成模板的话应该问题不大。

这里一个致命的小细节是我调试时才发现的：一开始误以为全都是整点的情况下应该有办法避免精度误差，因此自信地直接写实数比较，结果分分钟被教做人了。后来发现主要原因出自求角度时的 `acos` 函数，即使只有机器精度级别的误差，在后面判相等之类的地方都是致命的。所以不该偷懒的地方千万别偷懒啊。

```cpp
namespace geometry{
#define EPS 1e-12l
	inline ldb my_acosl(ldb x){return acosl(max(-1.0l,min(1.0l,x)));}
	inline bool chkeq(ldb x,ldb y){return fabsl(x - y) < EPS;}
	struct vec2{
		ldb x,y;
		ldb dis()const {return sqrtl(x * x + y * y);} //长度
		ldb dis2()const {return x * x + y * y;} //长度的平方
		ldb dot(const vec2 &p)const {return x * p.x + y * p.y;}
		ldb cross(const vec2 &p)const {return x * p.y - y * p.x;}
		ldb dis_to_rectangle(ldb lx,ldb hy)const {return min(fabsl(x - lx),fabsl(x + lx)) + min(fabsl(y - hy),fabsl(y + hy));}
	};
	struct vec3{
		ldb x,y,z;
		vec3 to_int(){x = round(x);y = round(y);z = round(z);return *this;}
		ldb dis()const {return sqrtl(x * x + y * y + z * z);} 
		ldb dis2()const {return x * x + y * y + z * z;} 
		vec3 get_norm()const {ldb d = dis();return {x / d,y / d,z / d};}//获取向量单位化后的结果，但向量本身不单位化
		vec3 norm(){ldb d = dis();x /= d;y /= d;z /= d;return *this;}//获取向量单位化后的结果并将向量本身单位化
		ldb dot(const vec3 &p)const {return x * p.x + y * p.y + z * p.z;}
		vec3 cross(const vec3 &p)const {return {y * p.z - z * p.y,z * p.x - x * p.z,x * p.y - y * p.x};}
		ldb get_angle(const vec3 &p)const {return my_acosl(dot(p) / dis() / p.dis());}
		void input(){x = read_ldb();y = read_ldb();z = read_ldb();}	
	};
	vec3 operator + (const vec3 &a,const vec3 &b){return {a.x + b.x,a.y + b.y,a.z + b.z};}
	vec3 operator - (const vec3 &a,const vec3 &b){return {a.x - b.x,a.y - b.y,a.z - b.z};}
	vec3 operator * (ldb k,const vec3 &a){return {k * a.x,k * a.y,k * a.z};}
	bool operator == (const vec3 &a,const vec3 &b){return chkeq(a.x,b.x) && chkeq(a.y,b.y) && chkeq(a.z,b.z);}
	struct line{
		vec3 p,v;
		vec3 projection(const vec3 &x)const {return p + v.dot(x - p) * v;}
		ldb get_min_dis(const vec3 &x)const {return (x - projection(x)).dis();}
	};
	struct segment{
		vec3 p,q;
		ldb len()const {return (p - q).dis();} //长度
		ldb len2()const {return (p - q).dis2();} //长度的平方
		ldb get_min_dis(const vec3 &x)const {//求点到线段的最近距离
			if(p == q) return (x - p).dis();
			ldb tmp = (x - p).dot(q - p);
			if(tmp <= 0) return (x - p).dis();
			if(tmp >= len2()) return (x - q).dis();
			line y = {p,(q - p).norm()};
			return y.get_min_dis(x);
		}
	};
	struct plain{
		vec3 p,n;
		vec3 projection(const vec3 &x)const {return x - n.dot(x - p) * n;}
	};
};
```

接下来是无人机的定义。因为要预判无人机的走位，这里采用的方法是在一个对象里分别定义了无人机当前的运动状态和预判的运动状态。比较麻烦的部分大概就是求敌机在自己雷达平面上的投影，以及判断一个位置是否能飞到。前者在已有的计算几何板子下也并不难，后者主要就是把各种是否要滚转、向哪个方向滚转，以及到底是正杆还是负杆搞清楚就好。

```cpp
struct plane{
	int id;
	int status;
	bool team;
	vec3 p,d,u,l; //当前的运动状态向量 
	vec3 nxtp,nxtd,nxtu,nxtl; //这一回合即将移动到的运动状态向量 
	ldb tu,td,r,vm,lx,hy;
	int target;
	bool tar_in_radar;
	vector<int> exploded;
	void getl(){l = u.cross(d);}
	void input(int _id,bool _team){
		id = _id;
		team = _team;
		p.input();d.input();u.input();getl();
		tu = read_ldb();td = read_ldb();r = read_ldb();
		vm = read_ldb();lx = read_ldb();hy = read_ldb();
		status = ALIVE;
		target = 0;
		exploded.clear();
	}
	bool in_horizon(const plane &x)const {return d.dot(x.p - p) > EPS;}
	bool in_nxt_horizon(const plane &x)const {return nxtd.dot(x.p - nxtp) > EPS;}
	vec2 get_radar_r(const plane &x)const {//求x在自己的雷达平面上的投影
		plain pl = {p,d};
		vec3 nd = pl.projection(x.p);
		return {l.dot(nd - p),u.dot(nd - p)};
	}
	vec2 get_nxt_radar_r(const plane &x)const {//求移动后x在自己的雷达平面上的投影
		plain pl = {nxtp,nxtd};
		vec3 nd = pl.projection(x.p);
		return {nxtl.dot(nd - p),nxtu.dot(nd - p)};
	}
	bool in_radar_r(const vec2 &r)const {return fabsl(r.x) <= lx + EPS && fabsl(r.y) <= hy + EPS;}
	bool can_reach(const vec3 &x){//飞机能否飞行x距离（飞到p+x位置），能的话更新nxtp,nxtu,nxtd
		nxtp = p + x;
		nxtd = x.get_norm();
		if(d == nxtd) nxtl = l;//不需要滚转
		else if(d == -1 * nxtd) return 0;
		else{//需要滚转
			nxtl = d.cross(nxtd).norm();//要通过滚转把l转到与d和nxtd所在的平面垂直的方向
			if(l.dot(nxtl) < 0) nxtl = -1 * nxtl;//滚转只能在90度以内
		}
		nxtu = nxtd.cross(nxtl);
		return l.get_angle(nxtl) / r //滚转
			+ d.get_angle(nxtd) / (u.dot(nxtd) >= 0 ? tu : td) //俯仰
			+ x.dis() / vm <= 1 + EPS; //直线飞行
	}
}a[210]; 
```

导弹的定义与无人机类似，鉴于同一时刻存在的来自于同一架无人机的导弹最多只会存在一枚，我这里的写法是一个导弹对象就是固定由某架无人机发射的，那么需要注意多次初始化的问题；另外导弹会比无人机多一个功能，即预判是否锁定目标及相应的锁定角，不过这不难写。

```cpp
struct missile{
	int id;
	int status;
	bool team;
	vec3 p,d; //当前的运动状态向量 
	vec3 nxtp,nxtd; //这一回合即将移动到的运动状态向量 
	ldb tr,vm,ds,dp,bs;
	int tz,timer,target;
	void input(int _id,bool _team){
		id = _id;
		team = _team;
		tr = read_ldb();vm = read_ldb();ds = read_ldb();
		dp = read_ldb();bs = read_ldb();tz = read();
		status = DEAD;
		timer = target = 0;
	}
	void init(const vec3 &_p,const vec3 &_d,int _target){
		p = _p;d = _d;
		timer = 0;
		target = _target;
		status = INACTIVE;
	}
	bool nxt_can_lock(const plane &x,ldb &angle){//导弹即将飞到的位置能否锁定目标即将飞到的位置，能的话锁定角是多少（传给angle）
		if(x.nxtp == nxtp){//两者目标位置相同
			angle = 0;
			return 1;
		}
		ldb dott = nxtd.dot(x.nxtp - nxtp); 
		angle = nxtd.get_angle(x.nxtp - nxtp);//锁定角
		return dott > 0 && angle <= bs + EPS;//在前方且锁定角不超过最大锁定角
	}
	bool can_reach(const vec3 &x){//导弹能否飞行x距离（飞到p+x位置），能的话更新nxtp,nxtd
		nxtp = p + x;
		nxtd = x.get_norm();
		return d.get_angle(nxtd) / tr //偏航
			+ x.dis() / vm <= 1 + EPS; //直线飞行
	}
}b[210];
```

接下来，抽象出几个比较麻烦的步骤：

无人机目标选择：这一部分需要注意优先级为“先前选定的目标——在雷达范围内的目标（按到自己的距离排序）——在视野范围内但不在雷达范围内的目标（按到雷达范围的曼哈顿距离排序）”，然后分类讨论即可。为了后续实现方便，可以在无人机对象里记录这一步求出的“目标敌机是否在雷达范围内”信息。

```cpp
void find_target(plane &x){//无人机选定目标
	if(x.status != ALIVE) return;
	int last_target = x.target;x.target = 0;x.tar_in_radar = 0;
	ldb min_dis = INF,min_dis_r = INF;
	for(int i = 1;i <= m;++i){
		plane &y = a[i];
		if(y.status != ALIVE || y.team == x.team || !x.in_horizon(y)) continue;
		vec2 r = x.get_radar_r(y);
		if(last_target == i){//先前的锁定目标，现在还能锁定 
			x.target = i;
			x.tar_in_radar = x.in_radar_r(r);
			return;
		}
		if(x.in_radar_r(r)){//在雷达范围内，优先选 
			ldb nw_dis = (x.p - y.p).dis2();
			if(nw_dis < min_dis - EPS){//取距离自己最近的 
				x.target = i;
				min_dis = nw_dis;
				x.tar_in_radar = 1;
			}
		}
		else{//不在雷达范围内 
			if(min_dis < INF) continue;
			ldb nw_dis = r.dis_to_rectangle(x.lx,x.hy);
			if(nw_dis < min_dis_r - EPS){//取距离雷达范围最近的 
				x.target = i;
				min_dis_r = nw_dis;
			}
		}
	}
}
```

无人机和导弹的下一步飞行策略：这里出题人期待的做法就是大力枚举所有附近的整点，因为本身情况特别多，想给出一个比较方便的排除掉大量点的方案还是很困难的。本题时限之所以开得很大也正是希望确保所有在这里即使是最暴力枚举而不加任何优化的实现也可以轻松通过而不卡常。

在枚举终点后，是否可达由先前定义中已经给出的函数来判断；然后是优先级，这里千万要看清楚，比如无人机的移动在“目标敌机都仍落在视野内”的前提下，应当先比较“与目标敌机的距离”而非“目标敌机是否在雷达范围内”。

```cpp
void get_plane_fly_info(plane &x){//求出无人机的飞行策略
	if(x.status != ALIVE) return;
	if(x.target){//如果无人机有选定目标
		int vi = floor(x.vm);
		vec3 nxtp = {0,0,0},nxtd = {0,0,0},nxtu = {0,0,0};
		ldb min_tar_dis = INF,min_len_rq = INF,min_dis_radar = INF,min_straight_fly = INF;
		for(int i = -vi;i <= vi;++i){
			for(int j = -vi;j <= vi;++j){
				for(int k = -vi;k <= vi;++k){
					if(!i && !j && !k) continue;//不能原地不动
					if(i * i + j * j + k * k > x.vm * x.vm) continue;
					vec3 np = {(ldb)i,(ldb)j,(ldb)k};
					if(!x.can_reach(np)) continue;//必须要合法到达
					if(x.in_nxt_horizon(a[x.target])){//目标在视野内
						ldb ds = (x.p + np - a[x.target].p).dis2();//到目标的距离
						if(ds - EPS > min_tar_dis) continue;
						vec2 r = x.get_nxt_radar_r(a[x.target]);
						ldb tmp1 = INF,tmp2 = INF;
						if(x.in_radar_r(r)) tmp1 = r.dis();//在雷达范围内
						else tmp2 = r.dis_to_rectangle(x.lx,x.hy);//不在雷达范围内
						if((ds < min_tar_dis - EPS) //优先：距离最小
							|| (chkeq(ds,min_tar_dis) && tmp1 < min_len_rq - EPS) //其次：在雷达范围内且距视野中心尽可能近
							|| (chkeq(ds,min_tar_dis) && min_len_rq == INF && tmp2 < min_dis_radar - EPS)){ //再次：不在雷达范围内，距雷达范围尽可能近
							min_tar_dis = ds;
							min_len_rq = tmp1;
							min_dis_radar = tmp2;
							nxtp = x.nxtp;
							nxtd = x.nxtd;
							nxtu = x.nxtu;
						}
					}
					else{//目标不在视野内
						if(min_tar_dis < INF) continue;
						ldb ds = (np - x.vm * x.d).dis();
						if(ds < min_straight_fly - EPS){//找距离直飞最近的整点
							min_straight_fly = ds;
							nxtp = x.nxtp;
							nxtd = x.nxtd;
							nxtu = x.nxtu;
						}
					}
				}
			}
		}
		x.nxtp = nxtp;
		x.nxtd = nxtd;
		x.nxtu = nxtu;
	}
	else{//眼镜蛇机动
		x.nxtp = x.p;
		x.nxtd = x.u;
		x.nxtu = -1 * x.d;
	}
}
                                                
void get_missile_fly_info(missile &x){//求出导弹的飞行策略 
	if(x.status == DEAD) return;
	int vi = floor(x.vm);
	vec3 nxtp = {0,0,0},nxtd = {0,0,0};
	ldb min_tar_dis = INF,min_lock_angle = INF,min_straight_fly = INF;
	for(int i = -vi;i <= vi;++i){
		for(int j = -vi;j <= vi;++j){
			for(int k = -vi;k <= vi;++k){
				if(!i && !j && !k) continue;//不能原地不动
				if(i * i + j * j + k * k > x.vm * x.vm) continue;
				vec3 np = {(ldb)i,(ldb)j,(ldb)k};
				if(!x.can_reach(np)) continue;//必须要合法到达
				ldb tmp_angle = INF;
				
				if(x.target && x.nxt_can_lock(a[x.target],tmp_angle)){//有目标，且位移之后仍能锁定
					ldb ds = (x.p + np - a[x.target].nxtp).dis2();//到目标即将飞到的位置的距离
					if((ds < min_tar_dis - EPS) //优先：距离最小
						|| (chkeq(ds,min_tar_dis) && tmp_angle < min_lock_angle - EPS)){//其次：锁定角最小
						min_tar_dis = ds;
						min_lock_angle = tmp_angle;
						nxtp = x.nxtp;
						nxtd = x.nxtd;
					}
				}
				else{//没有目标，或位移之后脱锁
					if(min_tar_dis < INF) continue;
					ldb ds = (np - x.vm * x.d).dis();
					if(ds < min_straight_fly - EPS){//找距离直飞最近的整点
						min_straight_fly = ds;
						nxtp = x.nxtp;
						nxtd = x.nxtd;
					}
				}
			}
		}
	}
	if(min_tar_dis == INF) x.target = 0;//脱锁
	x.nxtp = nxtp;
	x.nxtd = nxtd;
}
                                 
```

接下来是对各个阶段的拆解：


第一阶段，无人机选定目标并确定飞行策略：已经搞定了。

```cpp
void stage1(){//所有无人机选定目标，并确定当前时刻内的飞行策略
	for(int i = 1;i <= m;++i) find_target(a[i]);
	for(int i = 1;i <= m;++i) get_plane_fly_info(a[i]);
}
```

第二阶段，所有能发射导弹的无人机发射导弹：简单判断即可。

```cpp
void launch_missile(plane &x){//发射导弹
	if(x.status != ALIVE || !x.tar_in_radar) return;
	if(b[x.id].status != DEAD) return;
	b[x.id].init(x.p,(a[x.target].p - x.p).norm(),x.target);
}
void stage2(){//所有能发射导弹的无人机发射导弹
	for(int i = 1;i <= m;++i) launch_missile(a[i]);
}
```

第三阶段，所有导弹确定飞行策略并位移：注意判断是否有导弹会爆炸，这里要用到点到线段的最短距离，还要注意导弹是否激活，以及直接撞上去的特殊情况。建议把需要判断的内容都放在这里进行，这样接下来处理导弹爆炸就会很容易。

```cpp
bool chk_missile_explode(const vec3 &st,const vec3 &ed,const vec3 &tar,ldb dp){
	//从st飞到ed，距离tar的最近距离是否不超过dp
	if(st == ed) return (tar - st).dis2() <= dp * dp;
	segment seg = {st,ed};
	return seg.get_min_dis(tar) <= dp;
}
void missile_fly(missile &x){//导弹飞行
	if(x.status == DEAD) return;
	for(int i = 1;i <= m;++i){
		plane &y = a[i];
		if(y.status == DEAD) continue;
		if(x.nxtp == y.p //导弹直接撞到飞机上，无论是否激活都摧毁 
			|| (x.status == ACTIVE && chk_missile_explode(x.p,x.nxtp,y.p,x.dp))){//判断激活的导弹x能否摧毁飞机y
			y.status = HANDLING;
			y.exploded.pb(x.id);
		}
	}
	x.p = x.nxtp;
	x.d = x.nxtd;
}
void stage3(){//所有导弹确定飞行策略并位移，该过程中部分无人机可能被摧毁；
	for(int i = 1;i <= m;++i) get_missile_fly_info(b[i]);
	for(int i = 1;i <= m;++i) missile_fly(b[i]);
}
```

第四阶段，所有可空爆的导弹爆炸并消失：这里可以与第六阶段一起写成一个函数，难度不大，主要在于准备输出信息的部分。

```cpp
void crash(plane &x,bool flag){//飞机坠毁
	if(x.status != HANDLING) return;
	if(!flag){
		++out_en.p1;
		out_en.q1.pb(mp(x.id,x.exploded));
	}
	else{
		++out_en.p2;
		out_en.q2.pb(mp(x.id,x.exploded));
	}
	x.status = DEAD;
	for(int i = 0;i < x.exploded.size();++i) b[x.exploded[i]].status = DEAD;
	for(int i = 1;i <= m;++i){//瞄准它的导弹立刻脱锁 
		if(b[i].target == x.id) b[i].target = 0;
	} 
}
void stage4(){//所有可空爆的导弹爆炸并消失
	for(int i = 1;i <= m;++i) crash(a[i],0);
}
```

第五阶段，所有无人机按第一阶段中确定的飞行策略位移：与第三阶段类似，要处理导弹引爆的问题。

```cpp
void plane_fly(plane &x){//无人机飞行
	if(x.status == DEAD) return;
	for(int i = 1;i <= m;++i){//检查飞机能否被别的导弹摧毁 
		missile &y = b[i];
		if(y.status == DEAD) continue; 
		if(x.nxtp == y.p //导弹直接撞到飞机上，无论是否激活都摧毁  
			|| (y.status == ACTIVE && chk_missile_explode(x.p,x.nxtp,y.p,y.dp))){//判断激活的导弹y能否摧毁飞机x
			x.status = HANDLING;
			x.exploded.pb(i);
		}
	}
	x.p = x.nxtp;
	x.d = x.nxtd;
	x.u = x.nxtu;
	x.getl();
}
void stage5(){//所有无人机按 1. 中确定的飞行策略位移，该过程中部分无人机可能被摧毁；
	for(int i = 1;i <= m;++i) plane_fly(a[i]);
}
```

第六阶段，所有可空爆的导弹爆炸并消失：已经搞定了。

```cpp
void stage6(){//所有可空爆的导弹爆炸并消失
	for(int i = 1;i <= m;++i) crash(a[i],1);
}
```

第七阶段，所有位置相同的无人机发生碰撞并坠毁：这里主要是一个碰撞检测，难度并不大，主要是准备输出内容，注意不要重复统计就好。

```cpp
void chk_collide(plane &x){//碰撞检测
	if(x.status != ALIVE) return;
	bool flag = 0;
	vector<int> vt;vt.clear();
	for(int j = x.id + 1;j <= m;++j){
		plane &y = a[j];
		if(y.status != ALIVE) continue;
		if(y.p == x.p){
			x.status = y.status = DEAD;
			if(!flag){
				flag = 1;
				vt.pb(x.id);
				for(int k = 1;k <= m;++k){//瞄准它的导弹立刻脱锁 
					if(b[k].target == x.id) b[k].target = 0;
				} 
			}
			vt.pb(j);
			for(int k = 1;k <= m;++k){//瞄准它的导弹立刻脱锁 
				if(b[k].target == j) b[k].target = 0;
			} 
		}
	}
	if(flag){
		++out_en.p3;
		out_en.q3.pb(mp(x.id,vt));
	}
}
void stage7(){//所有位置相同的无人机发生碰撞并坠毁
	for(int i = 1;i <= m;++i) chk_collide(a[i]);
}
```

第八阶段，导弹消失：因为导弹消失不会带走别的飞机，因此简单判断就好。

```cpp
void self_explosion(missile &x){//导弹自爆
	if(x.status == DEAD) return;
	if(x.timer++ == x.tz //超时 
		|| (!x.target && x.status == ACTIVE)) //脱锁并且已经激活 
			x.status = DEAD;
}
void stage8(){//所有超过制导时长和脱锁且已激活的导弹消失。
	for(int i = 1;i <= m;++i) self_explosion(b[i]);
}
```

第九阶段，导弹激活：要注意导弹激活的前提除了远离发射它的无人机外，还有可能是发射它的无人机已经坠毁了。也都不难判断。

```cpp
void activate(missile &x){//导弹激活
	if(x.status != INACTIVE) return;
	if(a[x.id].status == DEAD || (x.p - a[x.id].p).dis2() > x.ds * x.ds) x.status = ACTIVE;
}
void stage9(){//所有可激活的导弹被激活
	for(int i = 1;i <= m;++i) activate(b[i]);
}
```

大功告成！我们来看一下完整代码。

```cpp
#include<bits/stdc++.h>
#define gc getchar()
#define pc putchar
#define li long long
#define uli unsigned li
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define pii pair<int,int>
#define md int mid = l + r >> 1
#define ls q << 1
#define rs q << 1 | 1
#define ln ls,l,mid
#define rn rs,mid + 1,r
#define ldb long double
#define INF 1e18l
using namespace std;
inline li read(){
	li x = 0;
	int y = 0,c = gc;
	while(c < '0' || c > '9') y = c,c = gc;
	while(c >= '0' && c <= '9') x = x * 10 + c - '0',c = gc;
	return y == '-' ? -x : x;
}
inline ldb read_ldb(){
	double x;scanf("%lf",&x);return (ldb)x;
}
inline void prt(li x){
	if(x >= 10) prt(x / 10);
	pc(x % 10 + '0');
}
inline void print(li x){
	if(x < 0) pc('-'),x = -x;
	prt(x);
}
int n,m,t;

/**************************GEOMETRY BEGIN********************************/
namespace geometry{
#define EPS 1e-12l
	inline ldb my_acosl(ldb x){return acosl(max(-1.0l,min(1.0l,x)));}
	inline bool chkeq(ldb x,ldb y){return fabsl(x - y) < EPS;}
	struct vec2{
		ldb x,y;
		ldb dis()const {return sqrtl(x * x + y * y);} //长度
		ldb dis2()const {return x * x + y * y;} //长度的平方
		ldb dot(const vec2 &p)const {return x * p.x + y * p.y;}
		ldb cross(const vec2 &p)const {return x * p.y - y * p.x;}
		ldb dis_to_rectangle(ldb lx,ldb hy)const {return min(fabsl(x - lx),fabsl(x + lx)) + min(fabsl(y - hy),fabsl(y + hy));}
	};
	struct vec3{
		ldb x,y,z;
		vec3 to_int(){x = round(x);y = round(y);z = round(z);return *this;}
		ldb dis()const {return sqrtl(x * x + y * y + z * z);} 
		ldb dis2()const {return x * x + y * y + z * z;} 
		vec3 get_norm()const {ldb d = dis();return {x / d,y / d,z / d};}//获取向量单位化后的结果，但向量本身不单位化
		vec3 norm(){ldb d = dis();x /= d;y /= d;z /= d;return *this;}//获取向量单位化后的结果并将向量本身单位化
		ldb dot(const vec3 &p)const {return x * p.x + y * p.y + z * p.z;}
		vec3 cross(const vec3 &p)const {return {y * p.z - z * p.y,z * p.x - x * p.z,x * p.y - y * p.x};}
		ldb get_angle(const vec3 &p)const {return my_acosl(dot(p) / dis() / p.dis());}
		void input(){x = read_ldb();y = read_ldb();z = read_ldb();}	
	};
	vec3 operator + (const vec3 &a,const vec3 &b){return {a.x + b.x,a.y + b.y,a.z + b.z};}
	vec3 operator - (const vec3 &a,const vec3 &b){return {a.x - b.x,a.y - b.y,a.z - b.z};}
	vec3 operator * (ldb k,const vec3 &a){return {k * a.x,k * a.y,k * a.z};}
	bool operator == (const vec3 &a,const vec3 &b){return chkeq(a.x,b.x) && chkeq(a.y,b.y) && chkeq(a.z,b.z);}
	struct line{
		vec3 p,v;
		vec3 projection(const vec3 &x)const {return p + v.dot(x - p) * v;}
		ldb get_min_dis(const vec3 &x)const {return (x - projection(x)).dis();}
	};
	struct segment{
		vec3 p,q;
		ldb len()const {return (p - q).dis();} //长度
		ldb len2()const {return (p - q).dis2();} //长度的平方
		ldb get_min_dis(const vec3 &x)const {//求点到线段的最近距离
			if(p == q) return (x - p).dis();
			ldb tmp = (x - p).dot(q - p);
			if(tmp <= 0) return (x - p).dis();
			if(tmp >= len2()) return (x - q).dis();
			line y = {p,(q - p).norm()};
			return y.get_min_dis(x);
		}
	};
	struct plain{
		vec3 p,n;
		vec3 projection(const vec3 &x)const {return x - n.dot(x - p) * n;}
	};
};
using namespace geometry;
/**************************GEOMETRY END**********************************/

/**************************DEFINITION BEGIN******************************/
struct out_entry{
	int p1,p2,p3;
	vector<pair<int,vector<int> > >q1,q2,q3;
	void init(){
		q1.clear();q2.clear();q3.clear();
		p1 = p2 = p3 = 0;
	}
	void out_sort(){
		for(int i = 0;i < p1;++i) sort(q1[i].second.begin(),q1[i].second.end());
		sort(q1.begin(),q1.end());
		for(int i = 0;i < p2;++i) sort(q2[i].second.begin(),q2[i].second.end());
		sort(q2.begin(),q2.end());
		for(int i = 0;i < p3;++i){
			sort(q3[i].second.begin(),q3[i].second.end());
			q3[i].first = q3[i].second[0];
		}
		sort(q3.begin(),q3.end());
	}
	void output(){
		out_sort();
		print(p1);pc(' ');print(p2);pc(' ');print(p3);pc('\n');
		for(int i = 0;i < p1;++i){
			print(q1[i].first);pc(' ');print(q1[i].second.size());
			for(int j = 0;j < q1[i].second.size();++j) pc(' '),print(q1[i].second[j]);
			pc('\n');
		}
		for(int i = 0;i < p2;++i){
			print(q2[i].first);pc(' ');print(q2[i].second.size());
			for(int j = 0;j < q2[i].second.size();++j) pc(' '),print(q2[i].second[j]);
			pc('\n');
		}
		for(int i = 0;i < p3;++i){
			print(q3[i].second.size());
			for(int j = 0;j < q3[i].second.size();++j) pc(' '),print(q3[i].second[j]);
			pc('\n');
		}
		init();
	}
}out_en;
#define DEAD 0
#define ALIVE 1
#define INACTIVE 2
#define ACTIVE 3
#define HANDLING 4
struct plane{
	int id;
	int status;
	bool team;
	vec3 p,d,u,l;
	vec3 nxtp,nxtd,nxtu,nxtl;
	ldb tu,td,r,vm,lx,hy;
	int target;
	bool tar_in_radar;
	vector<int> exploded;
	void getl(){l = u.cross(d);}
	void input(int _id,bool _team){
		id = _id;
		team = _team;
		p.input();d.input();u.input();getl();
		tu = read_ldb();td = read_ldb();r = read_ldb();
		vm = read_ldb();lx = read_ldb();hy = read_ldb();
		status = ALIVE;
		target = 0;
		exploded.clear();
	}
	bool in_horizon(const plane &x)const {return d.dot(x.p - p) > EPS;}
	bool in_nxt_horizon(const plane &x)const {return nxtd.dot(x.p - nxtp) > EPS;}
	vec2 get_radar_r(const plane &x)const {//求x在自己的雷达平面上的投影
		plain pl = {p,d};
		vec3 nd = pl.projection(x.p);
		return {l.dot(nd - p),u.dot(nd - p)};
	}
	vec2 get_nxt_radar_r(const plane &x)const {//求移动后x在自己的雷达平面上的投影
		plain pl = {nxtp,nxtd};
		vec3 nd = pl.projection(x.p);
		return {nxtl.dot(nd - p),nxtu.dot(nd - p)};
	}
	bool in_radar_r(const vec2 &r)const {return fabsl(r.x) <= lx + EPS && fabsl(r.y) <= hy + EPS;}
	bool can_reach(const vec3 &x){//飞机能否飞行x距离（飞到p+x位置），能的话更新nxtp,nxtu,nxtd
		nxtp = p + x;
		nxtd = x.get_norm();
		if(d == nxtd) nxtl = l;//不需要滚转
		else if(d == -1 * nxtd) return 0;
		else{//需要滚转
			nxtl = d.cross(nxtd).norm();//要通过滚转把l转到与d和nxtd所在的平面垂直的方向
			if(l.dot(nxtl) < 0) nxtl = -1 * nxtl;//滚转只能在90度以内
		}
		nxtu = nxtd.cross(nxtl);
		return l.get_angle(nxtl) / r //滚转
			+ d.get_angle(nxtd) / (u.dot(nxtd) >= 0 ? tu : td) //俯仰
			+ x.dis() / vm <= 1 + EPS; //直线飞行
	}
}a[210]; 
struct missile{
	int id;
	int status;
	bool team;
	vec3 p,d;
	vec3 nxtp,nxtd;
	ldb tr,vm,ds,dp,bs;
	int tz,timer,target;
	void input(int _id,bool _team){
		id = _id;
		team = _team;
		tr = read_ldb();vm = read_ldb();ds = read_ldb();
		dp = read_ldb();bs = read_ldb();tz = read();
		status = DEAD;
		timer = target = 0;
	}
	void init(const vec3 &_p,const vec3 &_d,int _target){
		p = _p;d = _d;
		timer = 0;
		target = _target;
		status = INACTIVE;
	}
	bool nxt_can_lock(const plane &x,ldb &angle){//导弹即将飞到的位置能否锁定目标即将飞到的位置，能的话锁定角是多少（传给angle）
		if(x.nxtp == nxtp){//两者目标位置相同
			angle = 0;
			return 1;
		}
		ldb dott = nxtd.dot(x.nxtp - nxtp); 
		angle = nxtd.get_angle(x.nxtp - nxtp);//锁定角
		return dott > 0 && angle <= bs + EPS;//在前方且锁定角不超过最大锁定角
	}
	bool can_reach(const vec3 &x){//导弹能否飞行x距离（飞到p+x位置），能的话更新nxtp,nxtd
		nxtp = p + x;
		nxtd = x.get_norm();
		return d.get_angle(nxtd) / tr //偏航
			+ x.dis() / vm <= 1 + EPS; //直线飞行
	}
}b[210];
/**************************DEFINITION END*********************************/

/**************************STAGE 1 BEGIN**********************************/
void find_target(plane &x){//无人机选定目标
	if(x.status != ALIVE) return;
	int last_target = x.target;x.target = 0;x.tar_in_radar = 0;
	ldb min_dis = INF,min_dis_r = INF;
	for(int i = 1;i <= m;++i){
		plane &y = a[i];
		if(y.status != ALIVE || y.team == x.team || !x.in_horizon(y)) continue;
		vec2 r = x.get_radar_r(y);
		if(last_target == i){//先前的锁定目标，现在还能锁定 
			x.target = i;
			x.tar_in_radar = x.in_radar_r(r);
			return;
		}
		if(x.in_radar_r(r)){//在雷达范围内，优先选 
			ldb nw_dis = (x.p - y.p).dis2();
			if(nw_dis < min_dis - EPS){//取距离自己最近的 
				x.target = i;
				min_dis = nw_dis;
				x.tar_in_radar = 1;
			}
		}
		else{//不在雷达范围内 
			if(min_dis < INF) continue;
			ldb nw_dis = r.dis_to_rectangle(x.lx,x.hy);
			if(nw_dis < min_dis_r - EPS){//取距离雷达范围最近的 
				x.target = i;
				min_dis_r = nw_dis;
			}
		}
	}
}
void get_plane_fly_info(plane &x){//求出无人机的飞行策略
	if(x.status != ALIVE) return;
	if(x.target){//如果无人机有选定目标
		int vi = floor(x.vm);
		vec3 nxtp = {0,0,0},nxtd = {0,0,0},nxtu = {0,0,0};
		ldb min_tar_dis = INF,min_len_rq = INF,min_dis_radar = INF,min_straight_fly = INF;
		for(int i = -vi;i <= vi;++i){
			for(int j = -vi;j <= vi;++j){
				for(int k = -vi;k <= vi;++k){
					if(!i && !j && !k) continue;//不能原地不动
					if(i * i + j * j + k * k > x.vm * x.vm) continue;
					vec3 np = {(ldb)i,(ldb)j,(ldb)k};
					if(!x.can_reach(np)) continue;//必须要合法到达
					if(x.in_nxt_horizon(a[x.target])){//目标在视野内
						ldb ds = (x.p + np - a[x.target].p).dis2();//到目标的距离
						if(ds - EPS > min_tar_dis) continue;
						vec2 r = x.get_nxt_radar_r(a[x.target]);
						ldb tmp1 = INF,tmp2 = INF;
						if(x.in_radar_r(r)) tmp1 = r.dis();//在雷达范围内
						else tmp2 = r.dis_to_rectangle(x.lx,x.hy);//不在雷达范围内
						if((ds < min_tar_dis - EPS) //优先：距离最小
							|| (chkeq(ds,min_tar_dis) && tmp1 < min_len_rq - EPS) //其次：在雷达范围内且距视野中心尽可能近
							|| (chkeq(ds,min_tar_dis) && min_len_rq == INF && tmp2 < min_dis_radar - EPS)){ //再次：不在雷达范围内，距雷达范围尽可能近
							min_tar_dis = ds;
							min_len_rq = tmp1;
							min_dis_radar = tmp2;
							nxtp = x.nxtp;
							nxtd = x.nxtd;
							nxtu = x.nxtu;
						}
					}
					else{//目标不在视野内
						if(min_tar_dis < INF) continue;
						ldb ds = (np - x.vm * x.d).dis();
						if(ds < min_straight_fly - EPS){//找距离直飞最近的整点
							min_straight_fly = ds;
							nxtp = x.nxtp;
							nxtd = x.nxtd;
							nxtu = x.nxtu;
						}
					}
				}
			}
		}
		x.nxtp = nxtp;
		x.nxtd = nxtd;
		x.nxtu = nxtu;
	}
	else{//眼镜蛇机动
		x.nxtp = x.p;
		x.nxtd = x.u;
		x.nxtu = -1 * x.d;
	}
}
void stage1(){//所有无人机选定目标，并确定当前时刻内的飞行策略
	for(int i = 1;i <= m;++i) find_target(a[i]);
	for(int i = 1;i <= m;++i) get_plane_fly_info(a[i]);
}
/**************************STAGE 1 END************************************/

/**************************STAGE 2 BEGIN**********************************/
void launch_missile(plane &x){//发射导弹
	if(x.status != ALIVE || !x.tar_in_radar) return;
	if(b[x.id].status != DEAD) return;
	b[x.id].init(x.p,(a[x.target].p - x.p).norm(),x.target);
}
void stage2(){//所有能发射导弹的无人机发射导弹
	for(int i = 1;i <= m;++i) launch_missile(a[i]);
}
/**************************STAGE 2 END************************************/

/**************************STAGE 3 BEGIN**********************************/
bool chk_missile_explode(const vec3 &st,const vec3 &ed,const vec3 &tar,ldb dp){
	//从st飞到ed，距离tar的最近距离是否不超过dp
	if(st == ed) return (tar - st).dis2() <= dp * dp;
	segment seg = {st,ed};
	return seg.get_min_dis(tar) <= dp;
}
void get_missile_fly_info(missile &x){//求出导弹的飞行策略 
	if(x.status == DEAD) return;
	int vi = floor(x.vm);
	vec3 nxtp = {0,0,0},nxtd = {0,0,0};
	ldb min_tar_dis = INF,min_lock_angle = INF,min_straight_fly = INF;
	for(int i = -vi;i <= vi;++i){
		for(int j = -vi;j <= vi;++j){
			for(int k = -vi;k <= vi;++k){
				if(!i && !j && !k) continue;//不能原地不动
				if(i * i + j * j + k * k > x.vm * x.vm) continue;
				vec3 np = {(ldb)i,(ldb)j,(ldb)k};
				if(!x.can_reach(np)) continue;//必须要合法到达
				ldb tmp_angle = INF;
				
				if(x.target && x.nxt_can_lock(a[x.target],tmp_angle)){//有目标，且位移之后仍能锁定
					ldb ds = (x.p + np - a[x.target].nxtp).dis2();//到目标即将飞到的位置的距离
					if((ds < min_tar_dis - EPS) //优先：距离最小
						|| (chkeq(ds,min_tar_dis) && tmp_angle < min_lock_angle - EPS)){//其次：锁定角最小
						min_tar_dis = ds;
						min_lock_angle = tmp_angle;
						nxtp = x.nxtp;
						nxtd = x.nxtd;
					}
				}
				else{//没有目标，或位移之后脱锁
					if(min_tar_dis < INF) continue;
					ldb ds = (np - x.vm * x.d).dis();
					if(ds < min_straight_fly - EPS){//找距离直飞最近的整点
						min_straight_fly = ds;
						nxtp = x.nxtp;
						nxtd = x.nxtd;
					}
				}
			}
		}
	}
	if(min_tar_dis == INF) x.target = 0;//脱锁
	x.nxtp = nxtp;
	x.nxtd = nxtd;
}
void missile_fly(missile &x){//导弹飞行
	if(x.status == DEAD) return;
	for(int i = 1;i <= m;++i){
		plane &y = a[i];
		if(y.status == DEAD) continue;
		if(x.nxtp == y.p //导弹直接撞到飞机上，无论是否激活都摧毁 
			|| (x.status == ACTIVE && chk_missile_explode(x.p,x.nxtp,y.p,x.dp))){//判断激活的导弹x能否摧毁飞机y
			y.status = HANDLING;
			y.exploded.pb(x.id);
		}
	}
	x.p = x.nxtp;
	x.d = x.nxtd;
}
void stage3(){//所有导弹确定飞行策略并位移，该过程中部分无人机可能被摧毁；
	for(int i = 1;i <= m;++i) get_missile_fly_info(b[i]);
	for(int i = 1;i <= m;++i) missile_fly(b[i]);
}
/**************************STAGE 3 END************************************/

/**************************STAGE 4 BEGIN**********************************/
void crash(plane &x,bool flag){//飞机坠毁
	if(x.status != HANDLING) return;
	if(!flag){
		++out_en.p1;
		out_en.q1.pb(mp(x.id,x.exploded));
	}
	else{
		++out_en.p2;
		out_en.q2.pb(mp(x.id,x.exploded));
	}
	x.status = DEAD;
	for(int i = 0;i < x.exploded.size();++i) b[x.exploded[i]].status = DEAD;
	for(int i = 1;i <= m;++i){//瞄准它的导弹立刻脱锁 
		if(b[i].target == x.id) b[i].target = 0;
	} 
}
void stage4(){//所有可空爆的导弹爆炸并消失
	for(int i = 1;i <= m;++i) crash(a[i],0);
}
/**************************STAGE 4 END************************************/

/**************************STAGE 5 BEGIN**********************************/
void plane_fly(plane &x){//无人机飞行
	if(x.status == DEAD) return;
	for(int i = 1;i <= m;++i){//检查飞机能否被别的导弹摧毁 
		missile &y = b[i];
		if(y.status == DEAD) continue; 
		if(x.nxtp == y.p //导弹直接撞到飞机上，无论是否激活都摧毁  
			|| (y.status == ACTIVE && chk_missile_explode(x.p,x.nxtp,y.p,y.dp))){//判断激活的导弹y能否摧毁飞机x
			x.status = HANDLING;
			x.exploded.pb(i);
		}
	}
	x.p = x.nxtp;
	x.d = x.nxtd;
	x.u = x.nxtu;
	x.getl();
}
void stage5(){//所有无人机按 1. 中确定的飞行策略位移，该过程中部分无人机可能被摧毁；
	for(int i = 1;i <= m;++i) plane_fly(a[i]);
}
/**************************STAGE 5 END************************************/

/**************************STAGE 6 BEGIN**********************************/
void stage6(){//所有可空爆的导弹爆炸并消失
	for(int i = 1;i <= m;++i) crash(a[i],1);
}
/**************************STAGE 6 END************************************/

/**************************STAGE 7 BEGIN**********************************/
void chk_collide(plane &x){//碰撞检测
	if(x.status != ALIVE) return;
	bool flag = 0;
	vector<int> vt;vt.clear();
	for(int j = x.id + 1;j <= m;++j){
		plane &y = a[j];
		if(y.status != ALIVE) continue;
		if(y.p == x.p){
			x.status = y.status = DEAD;
			if(!flag){
				flag = 1;
				vt.pb(x.id);
				for(int k = 1;k <= m;++k){//瞄准它的导弹立刻脱锁 
					if(b[k].target == x.id) b[k].target = 0;
				} 
			}
			vt.pb(j);
			for(int k = 1;k <= m;++k){//瞄准它的导弹立刻脱锁 
				if(b[k].target == j) b[k].target = 0;
			} 
		}
	}
	if(flag){
		++out_en.p3;
		out_en.q3.pb(mp(x.id,vt));
	}
}
void stage7(){//所有位置相同的无人机发生碰撞并坠毁
	for(int i = 1;i <= m;++i) chk_collide(a[i]);
}
/**************************STAGE 7 END************************************/

/**************************STAGE 8 BEGIN**********************************/
void self_explosion(missile &x){//导弹自爆
	if(x.status == DEAD) return;
	if(x.timer++ == x.tz //超时 
		|| (!x.target && x.status == ACTIVE)) //脱锁并且已经激活 
			x.status = DEAD;
}
void stage8(){//所有超过制导时长和脱锁且已激活的导弹消失。
	for(int i = 1;i <= m;++i) self_explosion(b[i]);
}
/**************************STAGE 8 END************************************/

/**************************STAGE 9 BEGIN**********************************/
void activate(missile &x){//导弹激活
	if(x.status != INACTIVE) return;
	if(a[x.id].status == DEAD || (x.p - a[x.id].p).dis2() > x.ds * x.ds) x.status = ACTIVE;
}
void stage9(){//所有可激活的导弹被激活
	for(int i = 1;i <= m;++i) activate(b[i]);
}
/**************************STAGE 9 END************************************/

int main(){
	int i;
	n = read();t = read();m = n + n;
	for(i = 1;i <= m;++i){
		a[i].input(i,i <= n);b[i].input(i,i <= n);
	}
	out_en.init();
	for(i = 1;i <= t;++i){
		stage1();
		stage2();
		stage3();
		stage4();
		stage5();
		stage6();
		stage7();
		stage8();
		stage9();
		out_en.output();
	}
	return 0;
}
```

后记：

从造题者的角度讲，最大的难点大概不是写出完整代码，而是确保代码的正确性与题面的准确和无歧义性。因为这种题目即使是出题人也很难保证代码一开始就是对的而且完美契合题意的，许多 bug，无论是程序上的还是题目叙述上的，都是出题人和验题人反复对拍、调试、磨合后才能发现的。作为验题人，写完整个代码大概只有零零碎碎的几个小时，但是“与出题人拍过+检验题面正确性”这事花了我们整整一个晚上……

算了，心累了，以后不搞这玩意了（大概率下次会真香吧）。

---

## 作者：佬头 (赞：3)

## Description
有人想要在乱西星上打飞机，因此可爱的无人机就被迫在那里互相攻击，而每架无人机都是一个独特的个体，所以他们的性能略有不同。

现在知道了每架无人机的性能以及初始状态和各自导弹的性能，希望你能预测这一空战的结果。~~学校里刚学空间向量，正好来巩固一下。~~

## Solution
### Subtask 1
1. 所有无人机选定目标（在视野范围内）。
	1. 上一时刻本机选择的无人机**优先选定**（若存在）；
	2. 其次是处于本机雷达扫描范围内的敌机；
	- **雷达扫描范围**，以本机 $\vec p$ 为原点、$\vec l$ 和 $\vec u$ 为 $X,Y$ 轴建一平面 $\alpha$，敌机 $\vec p'$ 在 $\alpha$ 上的投影 $\vec r=(\vec p'-\vec p)-[\vec d\cdot(\vec p'-\vec p)]\vec d$ 落在 $[-L_x,L_x]\times [-H_y,H_y]$ 中，即 $\vert\vec r\cdot\vec l\vert\le L_x$ 且 $\vert\vec r\cdot\vec u\vert\le H_y$。
	3. 最后是对视野内处于 $\vec p'$ 的敌机，选取 $\vert L_x-\vert\vec r\cdot\vec l\vert\vert+\vert H_y-\vert\vec r\cdot\vec u\vert\vert$ 最小的。$\|\vec l\|=\|\vec d\|\|\vec u\|\sin\theta=1$。
2. 所有无人机确定当前时刻内的飞行策略。~~（事故多发路段）~~
	1. 题目里说 $v_m>10$ 的无人机和导弹**总数不超过** $10$；
	2. 题目里又说某一时刻开始和结束时，无人机或导弹只能在形如 $(x,y,z)\in\mathbb Z^3$ 的位置上（显然无人机和导弹是减缓位移速度后到达整点的）。
	- 因此可以暴力**枚举** $[-v_m,v_m]\times[-v_m,v_m]\times[-v_m,v_m]$ 内的**整点**，根据题意选择飞行策略。其余的与无人机目标的选定基本类似。
	- 必须是**合法位移**或**一次眼镜蛇机动**。
- 无人机的俯仰有**正负杆**之分，在进行合法位移时，俯，需要考虑负杆率；仰，需要考虑正杆率。（这里与导弹略有不同，需要判断正负杆）
- 无人机合法位移必须**严格按照**滚转、俯仰和直线飞行的顺序。（可以证明此顺序下的位移才可以是最快的）
- 设目标点为 $\vec q$，考虑到仅有滚转、俯仰，滚转后应保证 $\vec d,\vec u,(\vec q-\vec p)$ **共面**，即 $\vec l\perp\vec d,\vec l\perp\vec u$。设 $\vec d,(\vec q-\vec p)$ 构成的平面的单位法向量为 $\vec n~(\vec n\cdot\vec l\ge0,(\vec d\times(\vec q-\vec p))\parallel \vec n)$，则俯仰角为 $\angle(\vec q-\vec p,\vec d)$，滚转角为 $\angle(\vec n,\vec l)$。
- 用向量的叉乘求 $\vec n$ 时，还要特判一下 $\vec d\parallel(\vec q-\vec p)$，此时 $\vec d\times(\vec q-\vec p)=\vec0$。
### Subtask 2
所有能发射导弹的无人机发射导弹。
- 一架无人机同一时刻**仅有**一颗导弹（发射在外或由无人机机载）。
- 导弹初始方向向量由本机**指向敌机**，并非与本机方向 $\vec d$ 一致。
- 发射导弹时敌机应在**雷达范围**内，而非视野范围。
- 发射后至导弹第一次确定飞行策略期间，导弹默认为**未脱锁**状态。
### Subtask 3
1. 所有导弹确定飞行策略。设 $\vec p,\vec p'$ 为导弹本次位移的起点和终点。
	1. **已脱锁**或不管怎么位移**都会脱锁**，按照 $v_m\vec d$ 盲飞。
	2. 直接合法位移到敌机目标位置 $\vec q$。
	3. 合法位移到距敌机最近且锁定角较小的**整点**，同样可以暴力**枚举**。
		- **锁定角** $\angle(\vec p'-\vec p,\vec q-\vec p')$ 可以通过反余弦来计算，即 $\arccos(\cos\angle(\vec p'-\vec p,\vec q-\vec p'))$。
	- 导弹仅有**偏航率**。
2. 所有导弹位移。
	1. 导弹**已激活**（炸不到本机）。所有位于 $\vec q$，且 $\min_{\lambda\in[0,1]}\|\lambda\vec p+(1-\lambda)\vec p'-\vec q\|\le d_p$ 的无人机被摧毁，同时导弹**立即消失**。
		- 简而言之，就是无人机 $P$ 与导弹位移路径 $AB$ 的距离 $d$ 满足 $d\le d_p$，需要**分类讨论**。
			1. $\overrightarrow{PA}\cdot\overrightarrow{BA}\lt0$，$d=\|\overrightarrow{PA}\|$；
			2. $\overrightarrow{PB}\cdot\overrightarrow{AB}\lt0$，$d=\|\overrightarrow{PB}\|$；
			3. $d=\|\overrightarrow{PA}\|-\dfrac{\overrightarrow{PA}\cdot\overrightarrow{BA}}{\|\overrightarrow{BA}\|}$。
	- 导弹**不分敌我**，激活后靠近即摧毁。
	2. 导弹未激活。与导弹位移后重合的无人机被摧毁，导弹在**本时刻结束时消失**。
	- 导弹**不分敌我**，未激活时重合即摧毁。
### Subtask 4
所有可空爆的导弹爆炸并消失。在判断无人机被爆炸摧毁后即可让这些导弹立即消失。
### Subtask 5
所有无人机位移。基本与导弹位移相似。
1. 所有从 $\vec q$ 位移到 $\vec q'$，且满足 $\min_{\lambda\in[0,1]}\|\lambda \vec q+(1-\lambda)\vec q'-\vec p\|\le d_p$（$\vec p$ 为某**激活导弹**此时的位置）的无人机被摧毁，同时这些导弹**立即消失**。
2. 所有位移后与**某未激活导弹**重合的无人机被摧毁，导弹在**本时刻结束时消失**。
### Subtask 6
所有可空爆的导弹爆炸并消失。在判断所有无人机被爆炸摧毁后即可让这些导弹立即消失。
### Subtask 7
所有位置相同的无人机发生碰撞并坠毁。套两重循环即可（当然本机与本机不算重合）。
- 此时还需要判断一下每个导弹的锁定情况（**是否脱锁**），即锁定角 $\angle(\vec d,\vec q-\vec p)\le\beta_s$。~~脱锁之后没有目标就盲飞。~~
### Subtask 8
所有超过制导时长 $t_z$ 和脱锁且已激活的导弹消失。
- 第 $k$ 个时刻被发射的导弹会在第 $k+t_z$ 个时刻结束消失。也就是说会生效 $t_z+1$ 个时刻。
- 本时刻脱锁且上一时刻激活的导弹才会消失（本时刻导弹尚未统一激活），同样导弹也不能提前激活。
- 导弹位移和无人机位移过程中，部分未激活导弹在此时可以消失了。
- 脱锁意味着导弹失去目标，导弹脱锁后将永久性盲飞，不具有重新锁定的能力。
### Subtask 9
所有可激活的导弹被激活。
- 激活意味着导弹炸不到本机，导弹激活后将永久性激活，因此会误伤本机。
- 本机被摧毁后，导弹是激活而不是消失，在脱锁之前，理论上还可以飞很久。
## Importance
接下来就是这道题的特色之处了——疯一般的实数问题。
- 判断实数 $a,b$ 相等需要留有一定误差，即 $\vert a-b\vert\lt e$（$e$ 这里取 $10^{-6}$），不能直接判断相等。
	- 同理，判断实数 $a$ 为零也不能直接判断，需要用 $\vert a\vert\lt e$。
	- 判断实数 $a\lt b$ 需要用 $a+e\le b$；$a\le b$ 需要用 $a\lt b+e$ 等。
- 在求 $\arccos(cos\angle(\vec a,\vec b))$ 时，需要写成 $\arccos(\min\{cos\angle(\vec a,\vec b),1\})$，否则 `printf` 会返回 `-1.#IND00`，`cout` 会返回 `nan`。~~我真是太难了。~~
- 在求 $\sqrt{a}$ 时，应写成 $\sqrt{a+e}$，特别是用勾股定理求点到线段的距离的时候，不然一样会返回 `-1.#IND00` 或 `nan`。
- 每一时刻结束时检查一下答案数组是否需要清空。

基本上这题只有无人机和导弹的重合可以用等号直接判断（因为是整点）。
## Code
~~懒婆娘的裹脚布——又臭又长。~~
```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <cmath>
#define square(x) (x)*(x)
using namespace std;
const int N = 202;
const double eps = 1e-6;
int n, nn, t;
int read(){
	int x = 0;
	bool tf = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a == '-'? tf = 1: 0, a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return tf? -x: x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
struct vec{
	double x, y, z;
	void input(){
		x = read(), y = read(), z = read();
	}
	vec(double _x, double _y, double _z){
		x = _x, y = _y, z = _z;
	}
	vec(){};
	bool operator !() const{ //零向量
		return abs(x) < eps && abs(y) < eps && abs(z) < eps;
	}
	vec operator +(const vec &a) const{
		return vec(x + a.x, y + a.y, z + a.z);
	}
	vec operator -() const{
		return vec(-x, -y, -z);
	}
	vec operator -(const vec &a) const{
		return vec(x - a.x, y - a.y, z - a.z);
	}
	double operator *(const vec &a) const{ //点乘
		return x * a.x + y * a.y + z * a.z;
	}
	vec operator *(const double &a) const{ //数乘
		return vec(x * a, y * a, z * a);
	}
	vec operator /(const double &a) const{
		return vec(x / a, y / a, z / a);
	}
	vec operator ^(const vec &a) const{ //叉乘
		return vec(y * a.z - z * a.y, z * a.x - x * a.z, x * a.y - y * a.x);
	}
	bool operator <(const vec &a) const{ //字典序
		if(x == a.x){
			if(y == a.y) return z < a.z;
			return y < a.y;
		}
		return x < a.x;
	}
	bool operator ==(const vec &a) const{
		return x == a.x && y == a.y && z == a.z;
	}
};
struct total{
	vec p, d, u, l, stra;
	vec mp, md;
	double su, sd, r, vm, lx, hy; //无人机
	double msr, mvm, mds, mdp, mbs, mtz; //导弹
	int aim = 0, maim, mt;
	bool alive = 1, missile = 1, aim_inrad, lock, activate, need_die;
	void input(){
		p.input(), d.input(), u.input();
		l = u ^ d;
		scanf("%lf%lf%lf%lf%lf%lf", &su, &sd, &r, &vm, &lx, &hy);
		scanf("%lf%lf%lf%lf%lf", &msr, &mvm, &mds, &mdp, &mbs), mtz = read();
	}
} p[N];
vector <int> ans1, ans2, ans3, v[N]; //v[i]{1:导弹位移时的导弹;2:无人机位移时的导弹;3:重合的无人机数}
bool dead[N], missile_dead[N]; //绝对坠毁,绝对消失
double length(vec x){ //长度
	return sqrt(square(x.x) + square(x.y) + square(x.z));
}
vec unit(vec x){ //与其同向的单位向量
	x = x / length(x);
	return x;
}
vec shadow(vec p, vec d){ //计算投影r
	return p - d * (d * p);
}
bool inradar(vec u, vec &l, vec &r, double &lx, double &hy){ //在无人机机载雷达搜索范围内
	return abs(r * l) < lx + eps && abs(r * u) < hy + eps;
}
double distance(vec u, vec l, vec &r, double &lx, double &hy){
	return abs(lx - abs(r * l)) + abs(hy - abs(r * u));
}
void UAV_Choose(){ //无人机选定目标
	for(int i = 1; i <= nn; ++ i)
		if(p[i].alive){
			int aim = p[i].aim;
			vec raim = shadow(p[aim].p - p[i].p, p[i].d);
			if(aim && p[aim].alive && (p[aim].p - p[i].p) * p[i].d >= eps){
				p[i].aim_inrad = inradar(p[i].u, p[i].l, raim, p[i].lx, p[i].hy);
				continue;
			}
			aim = 0;
			bool is_inradar = 0;
			for(int j = 1 + (i <= n) * n; j <= n + (i <= n) * n; ++ j)
				if(p[j].alive && (p[j].p - p[i].p) * p[i].d >= eps){
					vec r = shadow(p[j].p - p[i].p, p[i].d);
					if(is_inradar == inradar(p[i].u, p[i].l, r, p[i].lx, p[i].hy))
						if(is_inradar){
							if(length(p[i].p - p[aim].p) >= length(p[i].p - p[j].p) + eps) aim = j, raim = r;
						}
						else{
							if(!aim || distance(p[i].u, p[i].l, raim, p[i].lx, p[i].hy) >= distance(p[i].u, p[i].l, r, p[i].lx, p[i].hy) + eps) aim = j, raim = r;
						}
					else if(!is_inradar) aim = j, raim = r, is_inradar = 1;
				}
			p[i].aim = aim;
			p[i].aim_inrad = is_inradar;
		}
}
double cos(vec x, vec y){
	return min(x * y / length(x) / length(y), 1.0);
}
bool UAV_Legal(vec direct, vec &d, vec &u, vec &l, double &r, double &su, double &sd, double &vm){ //无人机能否合法位移
	if(!(direct ^ d)) return length(direct) / vm < 1 + eps;
	if((direct ^ d) * l <= -eps) return acos(cos(d ^ direct, l)) / r + acos(cos(direct, d)) / ((d ^ (d ^ direct)) * direct < 0? sd: su) + length(direct) / vm < 1 + eps;
	return acos(cos(direct ^ d, l)) / r + acos(cos(direct, d)) / ((d ^ (direct ^ d)) * direct < 0? sd: su) + length(direct) / vm < 1 + eps;
}
void UAV_Fly(){ //无人机飞行策略
	for(int i = 1; i <= nn; ++ i)
		if(p[i].alive){
			if(!p[i].aim){
				p[i].stra = vec(0, 0, 0); //眼镜蛇机动
				continue;
			}
			vec cur = vec(0, 0, 0), dir;
			bool inview = 0;
			for(dir.x = -int(p[i].vm); dir.x <= p[i].vm; ++ dir.x)
				for(dir.y = -int(p[i].vm); dir.y <= p[i].vm; ++ dir.y)
					for(dir.z = -int(p[i].vm); dir.z <= p[i].vm; ++ dir.z)
						if(!!dir && UAV_Legal(dir, p[i].d, p[i].u, p[i].l, p[i].r, p[i].su, p[i].sd, p[i].vm))
							if((p[p[i].aim].p - p[i].p - dir) * dir >= eps){
								if(!inview){
									inview = 1, cur = dir;
									continue;
								}
								double d = length(p[p[i].aim].p - p[i].p - dir), dcur = length(p[p[i].aim].p - p[i].p - cur);
								if(dcur >= d + eps) cur = dir;
								else if(!(d - dcur)){
									vec r = shadow(p[p[i].aim].p - p[i].p - dir, unit(dir)), rcur = shadow(p[p[i].aim].p - p[i].p - cur, unit(cur));
									vec l = !(p[i].d ^ dir)? p[i].l: unit(p[i].d ^ dir), lcur = !(p[i].d ^ cur)? p[i].l: unit(p[i].d ^ cur);
									if(inradar(unit(cur ^ lcur), lcur, rcur, p[i].lx, p[i].hy)){
										if(inradar(unit(dir ^ l), l, r, p[i].lx, p[i].hy) && length(rcur) >= length(r) + eps) cur = dir;
									}
									else if(inradar(unit(dir ^ l), l, r, p[i].lx, p[i].hy)) cur = dir;
									else if(distance(unit(cur ^ lcur), lcur, rcur, p[i].lx, p[i].hy) >= distance(unit(dir ^ l), l, r, p[i].lx, p[i].hy) + eps) cur = dir;
								}
							}
							else if(!cur || !inview && length(cur - (p[i].d * p[i].vm)) >= length(dir - (p[i].d * p[i].vm)) + eps) cur = dir;
			p[i].stra = cur;
		}
}
void Task1(){
	UAV_Choose();
	UAV_Fly();
}
void Task2(int &t){ //发射
	for(int i = 1; i <= nn; ++ i)
		if(p[i].alive && p[i].missile && p[i].aim_inrad){
		  p[i].missile = 0;
		  p[i].mp = p[i].p;
		  p[i].md = unit(p[p[i].aim].p - p[i].p);
		  p[i].maim = p[i].aim;
		  p[i].lock = 1;
		  p[i].activate = 0;
		  p[i].need_die = 0;
		  p[i].mt = t;
		}
}
bool missile_legal(vec direct, vec &d, double &sr, double &vm){ //导弹能否合法位移
	return acos(min(d * direct / length(direct), 1.0)) / sr + length(direct) / vm < 1 + eps;
}
bool inlock_range(vec p, vec &d, double &bs){ //无人机可以被锁定
	return p * d >= eps && acos(cos(p, d)) < bs + eps;
}
double distance1(vec &p, vec &a, vec b){ //点到线段的距离
	if((a - p) * (a - b) <= -eps) return length(a - p);
	if((b - p) * (b - a) <= -eps) return length(b - p);
	return sqrt(square(a - p) - square((a - p) * (a - b) / length(a - b)) + eps); //减法可能导致结果小于0
}
void Task34(){ //导弹飞行策略
	for(int i = 1; i <= nn; ++ i)
		if(!p[i].missile){
			vec cur = vec(0, 0, 0), q = p[p[i].maim].p + p[p[i].maim].stra - p[i].mp, dir;
			bool cur_lock = 0;
			if(p[i].lock && missile_legal(q, p[i].md, p[i].msr, p[i].mvm)) cur = q;
			else{
				for(dir.x = -int(p[i].mvm); dir.x <= p[i].mvm; ++ dir.x)
					for(dir.y = -int(p[i].mvm); dir.y <= p[i].mvm; ++ dir.y)
						for(dir.z = -int(p[i].mvm); dir.z <= p[i].mvm; ++ dir.z)
							if(!!dir && missile_legal(dir, p[i].md, p[i].msr, p[i].mvm))
								if(p[i].lock && inlock_range(q - dir, dir, p[i].mbs)){
									if(!cur_lock || length(q - cur) >= length(q - dir) + eps) cur = dir, cur_lock = 1;
									else if(abs(length(q - dir) - length(q - cur)) < eps && cos(q - dir, dir) >= cos(q - cur, cur) + eps) cur = dir;
								}
								else if(!cur || (!p[i].lock || !cur_lock) && length(cur - (p[i].md * p[i].mvm)) >= length(dir - (p[i].md * p[i].mvm)) + eps) cur = dir;
			}
			if(p[i].activate){ //位移过程
				bool bomb = 0;
				for(int j = 1; j <= nn; ++ j)
					if(p[j].alive && p[i].mdp > distance1(p[j].p, p[i].mp, p[i].mp + cur) - eps){
						if(!dead[j]) ans1.push_back(j), dead[j] = 1;
						bomb = 1;
						v[j].push_back(i);
					}
				if(bomb) p[i].missile = 1; //立刻消失
			}
			else for(int j = 1; j <= nn; ++ j)
				if(p[j].alive && p[j].p == p[i].mp + cur){
					if(!dead[j]) ans1.push_back(j), dead[j] = 1;
					v[j].push_back(i);
					p[i].need_die = 1; //后来消失
				}
			p[i].mp = p[i].mp + cur;
			p[i].md = unit(cur);
		}
	for(int i = 1; i <= nn; ++ i)
		if(p[i].alive && dead[i])
			p[i].alive = 0; //局部时间存活的处死
}
void Task56(){ //无人机飞行
	for(int i = 1; i <= nn; ++ i)
		if(p[i].alive){
			for(int j = 1; j <= nn; ++ j)
				if(!p[j].missile)
					if(p[j].activate){
						if(p[j].mdp > distance1(p[j].mp, p[i].p, p[i].p + p[i].stra) - eps){
							if(p[i].alive) ans2.push_back(i), p[i].alive = 0;
							v[i].push_back(j);
							missile_dead[j] = 1;
						}
					}
					else if(p[j].mp == p[i].p + p[i].stra){
						if(p[i].alive) ans2.push_back(i), p[i].alive = 0;
						v[i].push_back(j);
						p[j].need_die = 1; //后来消失
					}
			if(p[i].alive)
				if(!p[i].stra){
					swap(p[i].d, p[i].u);
					p[i].u = -p[i].u;
				}
				else{
					p[i].p = p[i].p + p[i].stra;
					if(!!(unit(p[i].stra) - p[i].d)){
						if(p[i].l * (p[i].stra ^ p[i].d) >= eps) p[i].l = unit(p[i].stra ^ p[i].d);
						else p[i].l = unit(p[i].d ^ p[i].stra);
						p[i].d = unit(p[i].stra);
						p[i].u = p[i].d ^ p[i].l;
					}
				}
		}
	for(int i = 1; i <= nn; ++ i)
		if(!p[i].missile && missile_dead[i])
				p[i].missile = 1, missile_dead[i] = 0; //局部时间保存的爆炸
}
void Task7(){ //无人机碰撞坠毁
	for(int i = 1; i <= nn; ++ i)
		if(p[i].alive){
			for(int j = 1; j <= nn; ++ j)
				if(i != j && p[j].alive && p[i].p == p[j].p){
					if(p[i].alive){
						ans3.push_back(i);
						v[i].push_back(i);
						p[i].alive = 0;
					}
					v[i].push_back(j);
					p[j].alive = 0;
				}
		if(!p[i].alive){
			sort(v[i].begin(), v[i].end());
			ans3.back() = v[i].front();
			v[ans3.back()] = v[i];
		}
	}
}
void Check_Lock(){ //检查脱锁
	for(int i = 1; i <= nn; ++ i)
		if(!p[p[i].maim].alive || !inlock_range(p[p[i].maim].p - p[i].mp, p[i].md, p[i].mbs))
			p[i].lock = 0;
}
void Task8(int &t){
	for(int i = 1; i <= nn; ++ i)
		if(!p[i].missile && (p[i].mt + p[i].mtz == t || p[i].need_die || p[i].activate && !p[i].lock))
			p[i].missile = 1;
}
void Task9(){
	for(int i = 1; i <= nn; ++ i)
		if(!p[i].missile && !p[i].activate && (!p[i].alive || length(p[i].p - p[i].mp) >= p[i].mds + eps))
			p[i].activate = 1;
}
void Output(){
	write(ans1.size()), putchar(' ');
	write(ans2.size()), putchar(' ');
	write(ans3.size()), putchar('\n');
	sort(ans1.begin(), ans1.end());
	for(int i: ans1){
		write(i), putchar(' ');
		write(v[i].size()), putchar(' ');
		sort(v[i].begin(), v[i].end());
		for(int j: v[i]) write(j), putchar(' ');
		putchar('\n');
	}
	ans1.clear();
	sort(ans2.begin(), ans2.end());
	for(int i: ans2){
		write(i), putchar(' ');
		write(v[i].size()), putchar(' ');
		sort(v[i].begin(), v[i].end());
		for(int j: v[i]) write(j), putchar(' ');
		putchar('\n');
	}
	ans2.clear();
	sort(ans3.begin(), ans3.end());
	for(int i: ans3){
		write(v[i].size()), putchar(' ');
		for(int j: v[i]) write(j), putchar(' ');
		putchar('\n');
	}
	ans3.clear();
}
int main(){
	nn = (n = read()) << 1, t = read();
	for(int i = 1; i <= nn; ++ i) p[i].input();
	for(int i = 1; i <= t; ++ i){
		Task1();
		Task2(i);
		Task34();
		Task56();
		Task7();
		Check_Lock();
		Task8(i);
		Task9();
		Output();
	}
	return 0;
}
```

调到[第三天半夜](https://www.luogu.com.cn/record/167015178)（悲），但是跑得比较慢，不知道为啥。

---

## 作者：BFSDFS123 (赞：0)

## 0. 闲话

不难注意到乱西星把前两个字取反就变成了安东星，出题人战雷批实锤。

这题是一道大模拟，我也是直接写了四个多小时才写完。~~还花了很长时间调完~~。


## 1. 细节


一些细节的地方：

1. 制导时长 $t_z$ 代表可以进行 $t_z+1$ 次控制，如果您的代码是在减一后判断是否为 $0$，请在输入的时候将 $t_z+1$。
2. 注意无人机的视野和雷达搜索范围的区别，特别是如果你将两个判断函数的名称取得十分相近。
3. 一个导弹能击落多个无人机，但是有意思的一点是位移后位于一点的无人机会碰撞损毁，轮不到**后面发射**的导弹击落，但是**之前**发射的导弹可以将它们击落。
4. 如果一枚导弹已经被发射，脱锁但是没有消失，此时即使飞机瞄准了新的目标也不能发射导弹。
5. 位移**过程中**不小于空爆距离会损毁，这一点很重要。
6. 请务必一定注意精度问题。

因为本题诗大模拟，所以很考察选手的细心和细节程度。

## 2. 实现

### 2.1 三维向量

首先因为我们需要维护飞机和导弹的飞行状态、飞行性能，所以我们需要维护一个三维向量。具体地，需要维护点乘、叉乘、向量加、向量减、向量乘除常数等。

代码：

```cpp
bool is_zero(double now)
{
	return abs(now)<eps;
}
double clamp(double now)
{
	if(now<-1) return -1;
	if(now>1) return 1;
	return now; 
}
struct vector3{ // 三维向量 
	double x,y,z;//(x,y,z)
	vector3(){x=0,y=0,z=0;};
	vector3(double a,double b,double c)
	{
		x=a,y=b,z=c;
	}
	double dot(vector3 now) // 点乘
	{
		double ans=x*now.x+y*now.y+z*now.z;
		return ans;
	}
	vector3 cross(vector3 now) // 叉乘
	{
		return vector3(y*now.z-now.y*z,
					z*now.x-now.z*x,
					x*now.y-now.x*y);
	}
	double value() // 向量长度
	{
		double ans=x*x+y*y+z*z;
		ans=sqrt(ans);
		return ans;
	}
	
	vector3 operator-()const{
		return vector3(-x,-y,-z);
	}
	vector3 operator+(const vector3 &rhs)const{
		return vector3(x+rhs.x,y+rhs.y,z+rhs.z);
	}
	vector3 operator-(const vector3 &rhs)const{
		return vector3(x-rhs.x,y-rhs.y,z-rhs.z);
	}
	vector3 operator*(const double &rhs)const{
		return vector3(x*rhs,y*rhs,z*rhs);
	}
	vector3 operator/(const double &rhs)const{
		return vector3(x/rhs,y/rhs,z/rhs);
	}
	vector3 Norm(){
		return(*this)/((*this).value());
	}
	bool is_zero_()
	{
		return is_zero(value());
	}
	double Angle(vector3 now)
	{
		return acos(clamp(dot(now)));
	}
};
```

有一个细节在于，若 $\operatorname {acos}(x)$ 的 $x$ 小于 $-1$ 或大于 $1$，则 $\operatorname {acos}$ 会返回 ``nan``，故需要一个函数 ``clamp`` 将其稳定在 $-1$ 与 $1$ 之间。

这样，我们就可以计算飞行状态和飞行性能了。

### 2.2 无人机飞行与锁定与发射导弹

飞行前，通过数学函数和公式，计算到各个位置的代价（可以将移动拆成三个方向上的移动进行计算），注意同种情况取的大小。如果没有锁定则进行眼镜蛇机动。

对于锁定，首先判断是否要切换目标（上次的目标是否在视野内），再求出雷达探测范围内与自己距离最小的。最后再考虑视野范围内的。注意顺序。

发射导弹，只需要维护一个无人机的导弹是否空闲，如果空闲直接发射即可。

### 2.3 导弹飞行与锁定

导弹飞行与无人机飞行类似，而且少了一个升力线方向。

对于锁定也与无人机类似。

### 2.4 小技巧

考虑在计算移动策略的时候，因为整点数很小，所以可以直接枚举整点而非用数学公式计算，这样还节省了精度差。具体地，可以通过大致的范围计算出上下界，在上下界中枚举整点。

对于判断大小，尽量使用 ``eps`` 进行判断，避免精度误差。

写代码的时候，记得随手写注释，事半功倍。~~防止像我一样写完后面前面的代码忘了~~。

## 3. 代码

[链接](https://www.luogu.com.cn/paste/hlbnhdc9)。

---

## 作者：NKL丶 (赞：0)

## Description

给定一系列有关无人机和导弹的相关信息，模拟一场三维空间下的空战。

## Solution

大模拟，加量版的[杀蚂蚁](https://www.luogu.com.cn/problem/P2586)，但细节相较于前者更多而且繁琐。

分析后发现代码需要实现 4 个功能：

1. 基本的三维向量运算。
2. 无人机和导弹类的策略模拟与移动。
3. 分析无人机的坠毁和导弹的消失。
4. 答案的统计。

然后就是按照题目中同一时刻各事件发生顺序将各个功能组合起来。

一些需要注意的点：

- 导弹的 `tz` 参数代表着导弹可以持续 `tz+1` 个时刻（在 `tz+1` 个时刻末消失），因此可以在读入参数时将 `tz` 加一，或者在判断时以 $\text{tz} < 0$ 为标准。
- 无人机和导弹移动的策略类似，因此在调试移动策略的时候注意两边同时修改相同部分。
- 注意导弹激活、脱锁、消失的判断时机，可能在多个时机触发并且存在一定先后顺序。
- 各功能的组合顺序要严格按照题目要求，不确定时可以对照题目原文一句句对应。
- 调试时应有一定层级性（数学 $\rightarrow$ 物体移动 & 估价 $\rightarrow$ 策略 & 其他功能），长时间发现不符合预期的情况先考虑底层内容是否写挂了（一般策略写挂可以通过输出无人机/导弹的状态发现哪里有问题）。

一些功能的实现：

1. 将导弹与对应无人机放到对应数组的同一下标处，同时使用引用直接对应无人机/导弹（节省码量，统一写法）。
2. 由于整个三维空间大小并不大，考虑策略时可以直接枚举 $[-v_m,v_m]\times[-v_m,v_m]\times[-v_m,v_m]$ 的点判断是否能合法位移。
3. 输出直接把所有要输出的内容丢进同一个 `vector` 内，然后根据输出格式依次读取并输出。
4. 代码内各部分说明：数学 $\rightarrow$ 物体定义 & 移动 & 估值 $\rightarrow$ 策略 $\rightarrow$ 事件整理 $\rightarrow$ 输出答案。

## [Code](https://www.luogu.com.cn/paste/khtw9w0u)

---


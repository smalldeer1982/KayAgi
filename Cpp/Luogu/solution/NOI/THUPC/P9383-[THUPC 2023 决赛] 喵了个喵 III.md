# [THUPC 2023 决赛] 喵了个喵 III

## 题目背景

小 E 玩腻了《喵了个喵》，于是决定换一款消除游戏来玩。然而小 E 发现市面上的消除游戏规则都差不多，比如这个游戏，它的规则和《喵了个喵》只有一个字不相同。虽然说，改了一个字的游戏就是新游戏，但确是缺了点意思。


## 题目描述

这个游戏有一个牌堆和 $n$ 个栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1,a_2,\cdots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。

- 选择两个不同的栈，如果这两个栈栈**顶**的卡牌有相同的图案，则可以将这两张牌消去。如果不同，则什么也不会做。

经过多次观察小 E 发现总是有 $n=2$ 和 $k=m/2$，即只有两个栈且每一种图案的卡牌都恰好有 $2$ 张。虽然如此，小 E 还是一直无法通关。请你帮小 E 设计一下游戏方案，即给出相应的操作序列使得小 E 可以把所有的卡牌消去。


## 说明/提示

### 样例 1 解释
下图是初始状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/ds0k392b.png)

下图是前两次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/iy4w5r9m.png)

![scale=0.24](https://cdn.luogu.com.cn/upload/image_hosting/kb0woz7t.png)

下图是第三次和第四次操作之后的结果。
![](https://cdn.luogu.com.cn/upload/image_hosting/t9zxtszv.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5z2eyqe2.png)

下图是第五次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/9kr8v9mm.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/z32r81vt.png)


### 数据规模与约定

- 保证 $2\le m \le 1500$ 且为偶数。
- 保证 $1\le a_i \le m/2$ 且每一种数在序列中出现恰好两次。

### 评分方法

你的输出的第一行需要与标准答案一致。

若有解，且在按顺序进行所有操作后，牌堆为空且所有的栈均为空，则认为你的答案正确。

### 后记

**以下部分与本题内容无关。**

说到底，那个嫌《喵了个喵 II》的题面太长的人其实是小 E 自己。它本来的题面中，题目背景和题目描述是这样的：

【题目背景】

小 E 玩腻了《喵了个喵》，于是决定换一款消除游戏来玩。然而小 E 发现市面上的消除游戏规则都差不多，比如这个游戏，它的规则和《喵了个喵》只有略微不相同。虽然说，只要改一个字就是新游戏，但确是缺了点意思。

【题目描述】

这个游戏有一个牌堆和 $n$ 个可以从栈底删除元素的栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1,a_2,\cdots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。

- 选择两个不同的栈，如果这两个栈栈**底**的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。

经过多次观察小 E 发现总是有 $n=2$ 和 $k=m/4$，并且每一种图案的卡牌都恰好有 $4$ 张。虽然如此，小 E 还是一直无法通关。请你帮小 E 设计一下游戏方案，即给出相应的操作序列使得小 E 可以把所有的卡牌消去。


### 题目来源


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
4
1 2 1 2```

### 输出

```
Cleared.
5
12202```

# 题解

## 作者：yemuzhe (赞：19)

~~此题解篇幅太长，请谨慎观看！~~

# 题目大意

- 有一个大小为 $n$ 的牌堆 $A$，牌堆中的数均为 $1 \sim n / 2$，且每个数恰好出现 $2$ 次。

- 刚开始有两个空栈。可以进行 $op$ 次操作，有两种操作：

  1. 可以把牌堆顶上的数放入一个栈中，如果该栈最上方的两个数相同，则自动消去这两个数。

  2. 如果两个栈**顶**的数相同，则可以消去这两个数。

- 构造一种操作方案，使得所有数都被消去。

- $2 \le n \le 1500$ 且 $n$ 为偶数。

# 解题思路

这题可用区间 dp 解决。

容易发现，第一种操作的后半句没什么用，因为可以改写成第二种操作来实现。

于是我们把相同的两个数放入不同的栈中，也避免了第一种操作的自动消除。

考虑牌堆中的一段区间 $[l, r]$。内部可以消去的肯定要消去，剩下的是不能消去的数，且按原牌堆顺序排列。

如图：（图中一种颜色的球代表一个数）

![](https://s1.ax1x.com/2023/07/26/pCjXDo9.md.png)

当然，也不一定像这样所有一起加入后再消除。

在 dp 时我们枚举 $[l, r]$ 内最后消去的数（可能一个或两个），然后分段处理。

我们把 $[1, l - 1]$ 中能和 $[l, r]$ 中的数配对的数称为「有用的数」。

这里有一条非常重要的性质：

> **「有用的数」一定都（要）堆在同一个栈的最顶部。**

我们把这个栈称为「有用的栈」。如果没有「有用的数」则认为两个栈都是「有用的栈」。

这条性质的证明将会在「区间 dp」部分的末尾给出。请读者时刻牢记这一性质。

## Part 1：预处理

在 dp 之前，我们需要预处理几个数组：$p, lx, ry, xl, ly, yr$。

- ### $p$ 数组

  $p _ i$ 记录的是值为 $A _ i$ 的另一个数的位置。可以用一个 $l$ 数组记录 $A _ i$ 上一次出现的位置处理。

  ```cpp
  for (int i = 1; i <= n; i ++)
  {
      // 如果 A[i] 已经出现过，那么那么令 p[上一次出现的位置] = i 且 p[i] = 上一次出现的位置
      if (l[a[i]]) p[l[a[i]]] = i, p[i] = l[a[i]];
      l[a[i]] = i; // 用当前位置更新
  }
  ```

- ### $lx$ 数组

  $lx _ {l, r}$ 表示对于 $l \le i \le r$，**最前面**的满足 $p _ i > r$ 的 $i$。

  初始化 $lx _ {r + 1, r} = r + 1$（即无穷大），易得递推式 $lx _ {l, r} = \begin {cases} lx _ {l + 1, r} & (p _ l \le r) \\ \min \{lx _ {l + 1, r}, l\} & (p _ l > r) \end {cases}$。

  这个函数可以用来判断 $[l, r]$ 内的数是否可以全部消除（即 $lx _ {l, r}$ 是否大于 $r$）。

- ### $ry$ 数组

  $ry _ {l, r}$ 表示对于 $l \le i \le r$，**最后面**的满足 $p _ i < l$ 的 $i$。

  初始化 $ry _ {l, l - 1} = 0$（即负无穷大），易得递推式 $ry _ {l, r} = \begin {cases} lx _ {l, r - 1} & (p _ r \ge l) \\ \min \{lx _ {l, r - 1}, r\} & (p _ r < l) \end {cases}$。

  可以在 dp 时顺便处理，省去两维（就变成变量了）。

- ### $xl$ 数组

  $xl _ {l, r}$ 表示对于 $l \le i \le r$，**最前面**的 $p _ i$。

  初始化 $xl _ {l, l - 1} = l$，易得递推式 $xl _ {l, r} = \min \{xl _ {l, r - 1}, p _ r\}$。

  可以在 dp 时顺便处理，省去第一维（如果不是还要预处理 $yr$ 数组还可省去第二维）。

- ### $ly$ 数组

  $ly _ {l, r}$ 表示对于 $r < i \le n$，**最前面**的满足 $xl _ {l, r} < p _ i < l $ 的 $i$。

  考虑用树状数组实现。注意这里的树状数组的循环顺序有些不同，用来实现后缀查询。

  加入时只加 $p _ i < l$ 的。在 $p _ i$ 位置加入 $i$。

  查询时 $(xl _ {l, r}, n]$ 这一段区间的最小值，也可以查询 $[xl _ {l, r}, n]$。

  可以在 dp 时顺便处理，省去第一维。

  ```cpp
  void modify (int p, int c) // 单点修改（其实是加入）
  {
      for (; p; p &= p - 1) tr[p] = min (tr[p], c);
      return ;
  }
  
  int ask (int p) // 区间（后缀）求最小值
  {
      int res = inf;
      for (; p <= n; p += p & -p) res = min (res, tr[p]);
      return res;
  }
  
  // int main ()
  
  for (int l = n; l; l --)
  {
      // ...
      memset (tr, 0x3f, sizeof tr);
  	for (int r = n; r >= l; r --)
      {
          ly[r] = ask (xl[r]); // 询问满足条件的最小 i
          if (p[r] < l) modify (p[r], r); // 加入当前 r
      }
      // ...
  }
  ```

- ### $yr$ 数组

  $yr _ {l, r}$ 表示对于 $l \le i \le r$，**最后面**的 $p _ i$。

  初始化 $yr _ {l, l - 1} = l$，易得递推式 $yr _ {l, r} = \max \{yr _ {l, r - 1}, p _ r\}$。

  可以在 dp 时顺便处理，省去两维（就变成变量了）。

这样我们就完成了所有的预处理。

## Part 2：区间 dp

### 状态设计

记 $f _ {l, r}$ 为当一个栈是「有用的栈」时，能否删完 $[l, r]$ 内配对的部分并把剩下的堆在另一个栈。

同理记 $g _ {l, r}$ 为当一个栈是「有用的栈」时，能否删完 $[l, r]$ 内配对的部分并把剩下的堆在同一个栈。

考虑到可能没有剩余的，记 $both _ {i, j}$ 为当一个栈是「有用的栈」时，能否删完 $[l, r]$ 这部分。

容易发现 $both$ 其实是 $f$ 和 $g$ 共同的特殊情况。

注意「状态转移」部分中分界点的同 / 另一个栈是相对整个区间而言，而子区间的同 / 另一个栈是对子区间而言。

由于题目还要求具体方案，需要存三个数组 $pf, pg, pboth$，来记录转移的信息（具体见「状态转移」部分）。

根据「状态转移」部分可知，最终答案即 $both _ {1, n}$ 的过程仅与 $f, g, both$ 有关，故只设计设三种状态即可。

### 初始化

初始化 $f _ {i + 1, i} = g _ {i + 1, i} = both _ {i + 1, i} = 0$（$0 \le i \le n$）即可。

### 状态转移

- ### 第一种：$g \leftarrow f + f$

  #### 概念

  ![](https://s1.ax1x.com/2023/07/27/pCvQzWR.png)

  如上图，我们选择最前面的满足 $p _ i > r$ 的 $i$ 即 $lx _ {l, r}$，然后把这个序列分成 $[l, i - 1]$、$i$ 和 $[i + 1, r]$ 三段。

  对于 $[l, i - 1]$ 这段，把它们放进另一个栈（右边）。

  对于 $i$，把它放进同一个栈（左边），它不会产生任何消除（和它配对的在 $r$ 后面）。

  对于 $[i + 1, r]$，把它们放进另一个栈（这时是左边），这时它们会把 $[l, i - 1]$ 这部分**剩下的全部消掉**。

  为什么这时候另一个栈是左边呢？因为左边的栈已经被 $i$ 堵住了，相当于是空栈（没用），但右边的栈很可能是「有用的栈」。

  这样我们就不会在另一个栈（右边）剩东西，从而实现了 $g$ 的转移。

  为什么 $i$ 一定是最后消除的呢？

  如果分界点为 $i$，那么 $[i + 1, r]$ 的剩余部分都会叠在 $i$ 上面（堵住了），而 $[l, i - 1]$ 没有剩余；

  如果分界点不为 $i$，那么 $i$ 就会剩在另一个栈无法消去，不符合 $g$ 的定义。

  读者不妨可以模拟一下上图的具体过程。

  #### 前提

  首先得保证存在这么一个 $i$，也就是存在 $i$ 使得 $p _ i > r$，即 $lx _ {l, r} \le r$。

  其次要保证 $[i + 1, r]$ 与前面的 $[1, l - 1]$ 无关。

  也就是 $[l, r]$ 最后面的满足 $p _ j < l$ 的 $j$ 不在 $[i + 1, r]$ 中，即 $ry _ {l, r} \le i$（也可 $ry _ {l, r} < i$）。

  #### 转移

  放入 $i$ 一定是合法的。所以只需判 $f _ {l, i - 1}$ 和 $f _ {i + 1, r}$ 的合法性即可。

  这时 $pg$ 数组不需记录信息，具体见「查找每个数放入的栈」。

  ```cpp
  if (lx[l][r] <= r) // 第一种情况
  {
      now = lx[l][r];
      if (ry < now) g[l][r] = f[l][now - 1] & f[now + 1][r];
  }
  ```

- ### 第二种：$f \leftarrow g + f$

  #### 概念

  ![](https://cdn.acwing.com/media/article/image/2023/07/29/160254_3d1c33f22e-1.png)

  如上图，我们选择最前面的满足 $p _ i > r$ 的 $i$ 即 $lx _ {l, r}$，然后把这个序列分成 $[l, i - 1]$、$i$ 和 $[i + 1, r]$ 三段。

  对于 $[l, i - 1]$ 这段，把它们放进同一个栈（左边）。

  对于 $i$，把它放进另一个栈（右边），它不会产生任何消除。

  对于 $[i + 1, r]$，把它们放进另一个栈（右边），这时它们会把 $[l, i - 1]$ 这部分**剩下的全部消掉**。

  这样我们就不会在同一个栈（左边）剩东西，从而实现了 $f$ 的转移。

  为什么 $i$ 一定是最后消除的呢？理由同第一种情况。

  读者不妨可以模拟一下上图的具体过程。

  #### 前提

  首先得保证存在这么一个 $i$，也就是存在 $i$ 使得 $p _ i > r$，即 $lx _ {l, r} \le r$。

  其次必须满足两个条件之一：

  1. $[l, i - 1]$ 与前面的 $[1, l - 1]$ 无关，即 $xl _ {l, i - 1} = l$（也可 $xl _ {l, i} = l$）；

  2. 不存在 $(j, k)$（$l \le j < i < k \le r$）满足 $p _ j < p _ k <l$，
     也就是不存在 $p _ k$（$i < k \le r$）满足 $xl _ {l, i - 1} < p _ k < l$，即 $ly _ {l, i - 1} > r$（也可 $ly _ {l, i} > r$）。

  这里简要说明一下第二个条件。

  如果存在 $(j, k)$ 满足 $p _ j < p _ k < l$，根据性质，$p _ j, p _ k$ 在同一个栈中且 $p _ k$ 在 $p _ j$ 上面，这样 $j$ 就无法和 $p _ j$ 消去（$p _ j$ 被 $p _ k$ 卡住了）。

  总而言之就是要**满足 $[l, i - 1]$ 的「有用的数」都在同一个栈的最顶部**。

  而区间 $[l, r]$ 本身就满足「有用的数」在同一个栈的最顶部，所以可能造成干扰的是 $[i + 1, r]$ 这一部分，而不用考虑后面的部分。

  #### 转移

  放入 $i$ 一定是合法的。所以只需判 $g _ {l, i - 1}$ 和 $f _ {i + 1, r}$ 的合法性即可。

  这时 $pf$ 数组不需记录信息，具体见「查找每个数放入的栈」。

  ```cpp
  if (lx[l][r] <= r) // 第二种情况
  {
      now = lx[l][r];
      if (xl[now] == l || r < ly[now])
      {
          f[l][r] = g[l][now - 1] & f[now + 1][r];
      }
  }
  ```

- ### 第三种：$both \leftarrow f + f + both$

  #### 概念

  ![](https://cdn.acwing.com/media/article/image/2023/07/31/160254_a39f5de32f-1.png)

  如上图，这种情况当前区间不会产生剩余。于是我们选择 $p _ i > i$ 的 $i$。

  然后把区间分成 $[l, i - 1]$、$i$、$[i + 1, p _ i - 1]$、$p _ i$ 和 $[p _ i + 1, r]$ 五段。

  对于 $[l, i - 1]$ 这段，把它们放入另一个栈（右边）。

  对于 $i$，把它放入同一个栈（左边），这时它不会产生任何消除。

  对于 $[i + 1, p _ i - 1]$ 这段，把它们放入另一个栈（这时是左边），这时它们会把 $[l, i - 1]$ 这部分**剩下的全部消掉**。

  为什么这时候另一个栈是左边呢？因为左边的栈已经被 $i$ 堵住了，相当于是空栈（没用），但右边的栈很可能是「有用的栈」。

  对于 $p _ i$，把它放入另一个栈（右边），它已经和 $i$ 配好对，等待 $i$ 上面的数被消除即可。

  对于 $[p _ i + 1, r]$ 这段，把它们全部消掉，这时它们会把 $[i + 1, p _ i - 1]$ 这部分**剩下的全部消掉**。

  最后消掉 $i$ 和 $p _ i$。这样我们就不会剩东西，从而实现了 $both$ 的转移。

  很显然，$i$ 和 $p _ i$ 是最后消去的。

  读者不妨可以模拟一下上图的具体过程。

  #### 前提

  首先要保证没有剩余，即 $lx _ {l, r} > r$。

  然后枚举 $i$ 的时候，要保证 $[i + 1, r]$ 与前面的 $[1, l - 1]$ 无关（否则就会被 $i$ 堵住），即 $ry _ {l, r} \le i$（也可 $ry _ {l, r} < i$）。

  还有要保证 $[p _ i + 1, r]$ 与 $[l, i - 1]$ 无关（否则就会被 $p _ i$ 堵住），即 $yr _ {l, i - 1} < p _ i$（也可 $yr _ {l, i - 1} \le p _ i$）。

  #### 转移

  放入 $i, p _ i$ 和消除 $i, p _ i$ 一定是合法的。

  所以只需判 $f _ {l, i - 1}$、$f _ {i + 1, p _ i - 1}$ 和 $both _ {p _ i + 1, r}$ 的合法性即可。

  这时 $pboth$ 数组需要记录 $i$，具体见「查找每个数放入的栈」。

  ```cpp
  if (lx[l][r] > r) // 第三种情况
  {
      for (int i = l, yr = l; i <= r; i ++)
      {
          if (p[i] < yr) continue;
          if (ry < i)
          {
              tmp = f[l][i - 1] & f[i + 1][p[i] - 1] & both[p[i] + 1][r];
              if (both[l][r] = tmp) {pboth[l][r] = i; goto skip;}
          }
          yr = p[i];
      }
      skip:;
  }
  ```

- ### 第四种：$both \leftarrow g + f + both$

  #### 概念

  ![](https://cdn.acwing.com/media/article/image/2023/07/31/160254_e5ffe3592f-1.png)

  如上图，这种情况当前区间不会产生剩余。于是我们选择 $p _ i > i$ 的 $i$。

  然后把区间分成 $[l, i - 1]$、$i$、$[i + 1, p _ i - 1]$、$p _ i$ 和 $[p _ i + 1, r]$ 五段。

  对于 $[l, i - 1]$ 这段，把它们放入同一个栈（左边）。

  对于 $i$，把它放入另一个栈（右边），这时它不会产生任何消除。

  对于 $[i + 1, p _ i - 1]$ 这段，把它们放入另一个栈（右边），这时它们会把 $[l, i - 1]$ 这部分**剩下的全部消掉**。

  对于 $p _ i$，把它放入同一个栈（左边），它已经和 $i$ 配好对，等待 $i$ 上面的数被消除即可。

  对于 $[p _ i + 1, r]$ 这段，把它们全部消掉，这时它们会把 $[i + 1, p _ i - 1]$ 这部分**剩下的全部消掉**。

  最后消掉 $i$ 和 $p _ i$。这样我们就不会剩东西，从而实现了 $both$ 的转移。

  很显然，$i$ 和 $p _ i$ 是最后消去的。

  读者不妨可以模拟一下上图的具体过程。

  #### 前提

  首先要保证没有剩余，即 $lx _ {l, r} > r$。

  其次枚举 $i$ 的时候，类似第二种情况，必须满足两个条件之一：

  1. $[l, i - 1]$ 与前面的 $[1, l - 1]$ 无关，即 $xl _ {l, i - 1} = l$（也可 $xl _ {l, i} = l$）；

  2. 不存在 $(j, k)$（$l \le j < i < k \le r$）满足 $p _ j < p _ k <l$，
     也就是不存在 $p _ k$（$i < k \le r$）满足 $xl _ {l, i - 1} < p _ k < l$，即 $ly _ {l, i - 1} > r$（也可 $ly _ {l, i} > r$）。

  理由同第二种情况。

  然后要保证 $[p _ i + 1, r]$ 与前面的 $[1, l - 1]$ 无关（否则就会被 $p _ i$ 堵住），即 $ry _ {l, r} \le p _ i$（也可 $ry _ {l, r} < p _ i$）。

  还有要保证 $[p _ i + 1, r]$ 与 $[l, i - 1]$ 无关（否则就会被 $p _ i$ 堵住），即 $yr _ {l, i - 1} < p _ i$（也可 $yr _ {l, i - 1} \le p _ i$）。

  #### 转移

  放入 $i, p _ i$ 和消除 $i, p _ i$ 一定是合法的。

  所以只需判 $g _ {l, i - 1}$、$f _ {i + 1, p _ i - 1}$ 和 $both _ {p _ i + 1, r}$ 的合法性即可。

  这时 $pboth$ 数组需要记录 $p _ i$，具体见「查找每个数放入的栈」。

  ```cpp
  if (lx[l][r] > r) // 第四种情况
  {
      for (int i = l, yr = l; i <= r; i ++)
      {
          if (p[i] < yr) continue;
          if ((xl[i] == l || r < ly[i]) && ry < p[i])
          {
              tmp = g[l][i - 1] & f[i + 1][p[i] - 1] & both[p[i] + 1][r];
              if (both[l][r] = tmp) {pboth[l][r] = p[i]; goto skip;}
          }
          yr = p[i];
      }
      skip:;
  }
  ```

- ### 第五种：$both \leftarrow g + both$

  #### 概念

  ![](https://cdn.acwing.com/media/article/image/2023/07/31/160254_b687515e2f-1.png)

  如上图，我们选择 $p _ i$ 最小的 $i$ 即 $p _ {xl _ {l, r}}$，然后把这个序列分成 $[l, i - 1]$、$i$ 和 $[i + 1, r]$ 三段。

  对于 $[l, i - 1]$ 这段，把它们放进同一个栈（左边）。

  对于 $i$，把它放进另一个栈（右边），这时它不会产生任何消除。

  对于 $[i + 1, r]$，把它们全部消去，这时它们会把 $[l, i - 1]$ 这部分**剩下的全部消掉**。

  这样我们就不会剩东西，从而实现了 $both$ 的转移。

  很显然，$i$ 是最后消去的。那为什么一定是 $i$ 呢？

  因为根据性质 $p _ i < p _ j < l$ 的 $j$ 肯定比它先消去（否则就堵住了），对于 $p _ j \ge l$ 的 $j$ 肯定存在一种方式让 $j, p _ j$ 先消去。

  当然也可以不选择那种方式，但是这段区间就可以拆成两个 $both$ 的区间相加了。

  读者不妨可以模拟一下上图的具体过程。

  #### 前提

  首先要保证没有剩余，即 $lx _ {l, r} > r$。

  其次要保证要存在这个 $i$，也就是存在 $p _ i < l$ 的 $i$，即 $xl _ {l, r} < l$（其实也可以判 $ry _ {l, r} \ge l$，上文的 $lx$ 同样可以换成判 $yr$）。

  然后类似第二种情况，必须满足两个条件之一：

  1. $[l, i - 1]$ 与前面的 $[1, l - 1]$ 无关，即 $xl _ {l, i - 1} = l$；

  2. 不存在 $(j, k)$（$l \le j < i < k \le r$）满足 $p _ j < p _ k <l$，
     也就是不存在 $p _ k$（$i < k \le r$）满足 $xl _ {l, i - 1} < p _ k < l$，即 $ly _ {l, i - 1} > r$。

  理由同第二种情况。

  #### 转移

  放入 $i$ 一定是合法的。所以只需判 $g _ {l, i - 1}$ 和 $both _ {i + 1, r}$ 的合法性即可。

  这时 $pboth$ 数组需要记录 $-i$，具体见「查找每个数放入的栈」。

  ```cpp
  if (lx[l][r] > r) // 第五种情况
  {
      if (xl[r] < l)
      {
          now = p[xl[r]];
          if (xl[now - 1] == l || r < ly[now - 1])
          {
              tmp = g[l][now - 1] & both[now + 1][r];
              if (both[l][r] = tmp) pboth[l][r] = -now;
          }
      }
  }
  ```

~~容易发现~~只有这几种情况，分别转移即可。

对于第二、四、五种情况，其实如果预处理 $ly _ {i, i - 1}$，那么前提两个条件中的第一个条件可以略去。

因为当 $xl _ {l, i} = l$ 时，$ly _ {l, i}$ 一定等于无穷大，也就是满足 $ly _ {l, i} > r$。~~只是作者太懒了代码不想改 qwq。~~

### 目标状态

如果 $both _ {1, n} = 1$，则有解（输出 `Cleared.`）；否则无解（输出 `No solution`）。

### 关于 $both$ 数组的补充说明

很显然，当 $[l, r]$ 内没有剩余即 $lx _ {l, r} > r$ 时，$both$ 数组取 $f$ 和 $g$ 任意一个都行（相当于把空集堆在任意一个栈）。

因此我们转移时可以把 $both$ 都换成 $f$，转移后再把 $g \leftarrow f$ 就可以了。

记录上一个状态的数组 $pboth$ 也可换成 $pf$，转移后再把 $pg \leftarrow pf$ 即可。

### 关于性质的粗略证明

证明：

考虑用数学归纳法。命题对于 $[1, n]$ 显然成立（都没有「有用的数」）。

设命题对于 $[l, r]$ 成立，接下来证明命题对于由它分割的一个子区间 $[l ^ \prime, r ^ \prime]$ 依然成立。

对于第一种情况（$g = f + f$），$[l, r]$ 的「有用的数」都是 $[l, i - 1]$ 的，命题对于 $[l, i - 1]$ 显然成立；

而前提保证 $[i + 1, r]$ 的「有用的数」都在 $[l, i - 1]$ 中被堆在了另一个栈且只剩下「有用的数」，命题也成立。

对于第二种情况（$f = g + f$），根据我们在第二种情况时的讨论，命题对于 $[l, i - 1]$ 显然成立；

而 $[i + 1, r]$ 的「有用的数」要么就在之前「有用的栈」的最顶部，要么就在 $[l, i - 1]$ 剩下的当中，命题也成立。

因为前提保证了 $[l, i - 1]$ 只会剩下「有用的数」，所以「有用的数」仍在同一个栈的最顶部。

对于第三种情况（$both = f + f + both$），同第一种情况，命题对于 $[l, i - 1]$ 显然成立；

命题对于 $[i + 1, p _ i - 1]$ 同样成立，理由同第一种情况；

前提保证了 $[1, l - 1]$ 和 $[l, i - 1]$ 部分都没有 $[p _ i + 1, r]$ 的「有用的数」，所以「有用的数」只会在 $[i + 1, p _ i - 1]$ 当中，命题也成立。

因为前提保证了 $[p _ i + 1, r]$ 只会剩下「有用的数」，所以「有用的数」仍在同一个栈的最顶部。

对于第四种情况（$both = g + f + both$），同第二种情况，命题对于 $[l, i - 1]$ 显然成立；

命题对于 $[i + 1, p _ i - 1]$ 同样成立，理由同第二种情况；

对于 $[p _ i + 1, r]$ 这部分同第三种情况，命题也成立。

对于第五种情况（$both = g + both$），同第二种情况，命题对于 $[l, i - 1]$ 显然成立；

命题对于 $[i + 1, r]$ 同样成立，理由同第二种情况。

证毕。

## Part 3：求具体方案

首先容易发现 $op = \frac 3 2 n$，因为每个数都被进行了一次加入操作，两个数一组被进行了一次消除操作。

### 查找每个数放入的栈

设 $gt _ i$ 为第 $i$ 个数应该放入的栈。$gt _ i = 0$ 表示放入栈 $1$，$gt _ i = 1$ 表示放入栈 $2$。

记 $pre _ {l, r, w} = \begin {cases} pf _ {l, r} & (w = 1) \\ pg _ {l, r} & (w = 0) \end {cases}$，可以有效简化步骤。

特别提醒：根据「关于 $both$ 数组的补充说明」，此时 $both$ 数组已并入 $f$ 和 $g$ 中， $pboth$ 数组已并入 $pf$ 和 $pg$ 中。

考虑递归查找。需要传入四个参数：$l, r, w, d$，表示当前递归到区间 $[l, r]$，是第 $w$ 种转移方式，同一个栈为栈 $d$。

这里 $w = 1$ 表示转移方式 $f$，$w = 0$ 表示转移方式 $g$；$d = 0$ 表示栈 $1$，$d = 1$ 表示栈 $2$。

查找的入口为区间 $[1, n]$，我们钦定 $w = d = 0$。

如果当前递归查找的区间为 $[l, r]$，是第 $w$ 种转移方式，同一个栈为栈 $d + 1$，分几种情况：

- ### 第一、二种情况

  #### 判定

  如果满足 $lx _ {l, r} \le r$，那么说明是第一、二种情况。

  #### 查找分界点放入的栈

  不管是第一种情况还是第二种情况，分界点都是 $lx _ {l, r}$。

  然而还要考虑 $w$ 的影响。发现 $f$ 的分界点被放入另一个栈，而 $g$ 的分界点被放入同一个栈。也就是说 $w = 1$ 时要反过来。

  总结规律可以得出 $gt _ {lx _ {l, r}} = w ~ \mathrm {xor} ~ d$。

  #### 递归

  第一种情况是 $g = f + f$，第二种情况是 $f = g + f$。

  发现两种情况的共同点是都只有两个子区间，其中左边子区间的转移方式与当前区间相反，且右边子区间转移方式为 $f$。

  而左边子区间同一个栈与当前区间相同，右边子区间同一个栈如果 $w = 0$ 那么还要反过来。

  所以分别递归 $(l, lx _ {l, r} - 1, !w, d)$ 和 $(lx _ {l, r} + 1, r, 1, !w ~ \mathrm {xor} ~ d)$。

- ### 第三种情况

  #### 判定

  如果满足 $lx _ {l, r} > r$ 且 $pre _ {l, r, w} > 0$ 且 $pre _ {l, r, w} < p _ {pre _ {l, r, w}}$，那么说明是第三种情况。

  #### 查找分界点放入的栈

  靠左的分界点 $pre _ {l, r, w}$ 会被放入同一个栈，靠右的分界点 $p _ {pre _ {l, r, w}}$ 会被放入另一个栈。

  令 $gt _ {pre _ {l, r, w}} = d$，$gt _ {p _ {pre _ {l, r, w}}} = ~ !d$。

  #### 递归

  三个子区间转移方式都为 $f$（这里我们把右边子区间的转移方式钦定为 $f$）。

  左边子区间同一个栈与当前区间相同，中间子区间同一个栈与当前区间相反，右边子区间同一个栈与当前区间相同。

  所以分别递归 $(l, pre _ {l, r, w} - 1, 1, d)$、$(pre _ {l, r, w} + 1, p _ {pre _ {l, r, w}} - 1, 1, !d)$ 和 $(p _ {pre _ {l, r, w}} + 1, r, 1, d)$。

- ### 第四种情况

  #### 判定

  如果满足 $lx _ {l, r} > r$ 且 $pre _ {l, r, w} > 0$ 且 $pre _ {l, r, w} > p _ {pre _ {l, r, w}}$，那么说明是第四种情况。

  #### 查找分界点放入的栈

  靠左的分界点 $p _ {pre _ {l, r, w}}$ 会被放入另一个栈，靠右的分界点 $pre _ {l, r, w}$ 会被放入同一个栈。

  令 $gt _ {p _ {pre _ {l, r, w}}} = ~ !d$，$gt _ {pre _ {l, r, w}} = d$。

  #### 递归

  左边子区间转移方式为 $g$，其它子区间转移方式都为 $f$（这里我们把右边子区间的转移方式钦定为 $f$）。

  左边子区间同一个栈与当前区间相同，中间子区间同一个栈与当前区间相同，右边子区间同一个栈与当前区间相反。

  所以分别递归 $(l, p _ {pre _ {l, r, w}} - 1, 0, d)$、$(p _ {pre _ {l, r, w}} + 1, p _ {l, r, w} - 1, 1, d)$ 和 $(p _ {l, r, w} + 1, r, 1, !d)$。

- ### 第五种情况

  #### 判定

  如果满足 $lx _ {l, r} > r$ 且 $pre _ {l, r, w} < 0$，那么说明是第五种情况。

  #### 查找分界点放入的栈

  分界点 $-pre _ {l, r, w}$ 会被放入另一个栈。

  令 $gt _ {-pre _ {l, r, w}} = ~ !d$。

  #### 递归

  左边子区间转移方式为 $g$，右边子区间转移方式我们钦定为 $f$。

  左边子区间和右边子区间同一个栈都与当前区间相同。

  所以分别递归 $(l, -pre _ {l, r, w} - 1, 0, d)$ 和 $(-pre _ {l, r, w} + 1, 1, d)$。

### 模拟具体操作

得出 $gt$ 数组后，我们从前往后遍历每一个数。设当前遍历到位置 $i$，数为 $A _ i$。

首先如果 $gt _ i = 0$，那么输出 `1`；否则输出 `2`。然后把 $A _ i$ 压入对应的栈中。

在栈顶数字相同的情况下，一直输出 `0` 并弹出两边栈顶。

---

于是我们就可以~~愉快地~~搞定一道黑题啦。下面附上 AC 代码：

# AC Code

```cpp
#include <cstdio>
#include <cstring>
#define inf 0x3f3f3f3f
#define N 1505
#define min(x,y) ((x)<(y)?(x):(y))
using namespace std;

int n, a[N], l[N], p[N], gt[N], pf[N][N], pg[N][N];
int lx[N][N], xl[N], ly[N], tr[N];
int top[2], st[2][N]; // 数组模拟栈
bool tmp, f[N][N], g[N][N];

int &pre (int i, int j, bool k) // 合并两个数组为一个函数
{
    return k ? pf[i][j] : pg[i][j];
}

// 这里的树状数组写法有些不同，实现的是单点修改，区间（后缀）询问

void modify (int p, int c) // 树状数组加入元素
{
    for (; p; p &= p - 1) tr[p] = min (tr[p], c);
    return ;
}

int ask (int p) // 树状数组询问
{
    int res = inf;
    for (; p <= n; p += p & -p) res = min (res, tr[p]);
    return res;
}

void dfs (int l, int r, bool w, bool d) // dfs 求具体方案
{
    if (l > r) return ;
    if (lx[l][r] <= r)
    {
        gt[lx[l][r]] = w ^ d;
        dfs (l, lx[l][r] - 1, !w, d);
        dfs (lx[l][r] + 1, r, 1, !w ^ d);
    }
    else
    {
        if (pre (l, r, w) > 0)
        {
            gt[pre (l, r, w)] = d;
            gt[p[pre (l, r, w)]] = !d;
            if (pre (l, r, w) < p[pre (l, r, w)])
            {
                dfs (l, pre (l, r, w) - 1, 1, d);
                dfs (pre (l, r, w) + 1, p[pre (l, r, w)] - 1, 1, !d);
                dfs (p[pre (l, r, w)] + 1, r, 1, d);
            }
            else
            {
                dfs (l, p[pre (l, r, w)] - 1, 0, d);
                dfs (p[pre (l, r, w)] + 1, pre (l, r, w) - 1, 1, d);
                dfs (pre (l, r, w) + 1, r, 1, !d);
            }
        }
        else
        {
            gt[-pre (l, r, w)] = !d;
            dfs (l, -pre (l, r, w) - 1, 0, d);
            dfs (-pre (l, r, w) + 1, r, 1, d);
        }
    }
    return ;
}

int main ()
{
    scanf ("%d", &n), f[1][0] = g[1][0] = 1; // 初始化
    for (int i = 1; i <= n; i ++)
    {
        scanf ("%d", &a[i]);
        if (l[a[i]]) p[l[a[i]]] = i, p[i] = l[a[i]]; // 预处理
        l[a[i]] = i, f[i + 1][i] = g[i + 1][i] = 1; // 初始化
    }
    for (int r = 1; r <= n; r ++)
    {
        lx[r + 1][r] = r + 1; // 初始化
        for (int l = r; l; l --) // 预处理
        {
            lx[l][r] = lx[l + 1][r];
            if (p[l] > r) lx[l][r] = l;
        }
    }
    for (int l = n, ry = 0; l; l --, ry = 0)
    {
        xl[l - 1] = l, memset (tr, 0x3f, sizeof tr); // 初始化
        for (int r = l; r <= n; r ++) // 预处理
        {
            xl[r] = min (xl[r - 1], p[r]);
        }
        for (int r = n; r >= l; r --) // 预处理
        {
            ly[r] = ask (xl[r]);
            if (p[r] < l) modify (p[r], r);
        }
        for (int r = l, now; r <= n; r ++) // 区间 dp
        {
            if (p[r] < l) ry = r; // 顺便预处理
            if (lx[l][r] <= r)
            {
                now = lx[l][r];
                if (ry < now) g[l][r] = f[l][now - 1] & f[now + 1][r]; // 第一种情况
                if (xl[now] == l || r < ly[now]) // 第二种情况
                {
                    f[l][r] = g[l][now - 1] & f[now + 1][r];
                }
            }
            else
            {
                for (int i = l, yr = l; i <= r; i ++)
                {
                    if (p[i] < yr) continue;
                    if (ry < i) // 第三种情况
                    {
                        tmp = f[l][i - 1] & f[i + 1][p[i] - 1] & f[p[i] + 1][r];
                        if (f[l][r] = tmp) {pf[l][r] = i; goto skip;}
                    }
                    if ((xl[i] == l || r < ly[i]) && ry < p[i]) // 第四种情况
                    {
                        tmp = g[l][i - 1] & f[i + 1][p[i] - 1] & f[p[i] + 1][r];
                        if (f[l][r] = tmp) {pf[l][r] = p[i]; goto skip;}
                    }
                    yr = p[i]; // 顺便预处理
                }
                if (xl[r] < l)
                {
                    now = p[xl[r]];
                    if (xl[now - 1] == l || r < ly[now - 1]) // 第五种情况
                    {
                        tmp = g[l][now - 1] & f[now + 1][r];
                        if (f[l][r] = tmp) pf[l][r] = -now;
                    }
                }
                skip:; g[l][r] = f[l][r], pg[l][r] = pf[l][r]; // 关于 Both 的处理
            }
        }
    }
    puts (f[1][n] ? "Cleared." : "No solution.");
    if (!f[1][n]) return 0;
    printf ("%d\n", n / 2 * 3), dfs (1, n, 0, 0);
    for (int i = 1; i <= n; i ++) // 模拟
    {
        putchar ('1' + gt[i]), st[gt[i]][++ top[gt[i]]] = a[i];
        while (top[0] && top[1] && st[0][top[0]] == st[1][top[1]])
        {
            putchar ('0'), top[0] --, top[1] --;
        }
    }
    return 0;
}
```

题解若有问题欢迎在评论区反馈。

---

## 作者：E.Space (赞：16)

本题有个很关键的性质是，每种卡牌分别出现了恰好两次。

首先注意到可以全部使用第二种操作来消除。因为如果你想用第一种操作消除的话，可以改成把卡牌放进另一个栈，然后再执行一次第二种操作。

最难的在下面这一步。考虑枚举最后一次消除中消掉了哪种卡牌。假设它的种类是 $x$。由于只能从栈顶消除，所以放进的两张 $x$ 必须都在栈底，否则它们消完下面一定还有别的卡牌没消干净。

这意味着，在即将放进这两张 $x$ 中的任何一张之前，对应的栈一定是空的。由于两张同一种卡牌必须放进不同的栈，所以在放进第一张 $x$  之前，所有出现了两次的卡牌必须要消干净，只剩下只出现一次的卡牌，按它们出现的顺序从栈底到栈顶放在另一个栈里。

然后，放进第二张 $x$ 之前，要把那个之前堆了消不掉的东西的栈清空。这同时意味着，如果一种卡牌在第一个 $x$ 之前恰好出现了一次，那么它必须在两个 $x$ 之间再次出现，否则就无法空出这第二个栈底。同样的，对于在两个 $x$ 之间出现两次的卡牌，也要全部消干净，对于一次出现在两个 $x$ 之间，另一次出现在第二个 $x$ 之后的卡牌，需要全部按顺序堆在第一个 $x$ 上面，以空出第二个栈底。

最后，需要消掉剩下的所有卡牌。到这里可以发现，在放进两个 $x$ 前后，两个栈里的内容都是唯一确定的：一个栈是空的，另一个栈里从下到上堆着那些当前只出现过一次的卡牌。这也就意味着，被两个 $x$ 分开的三个区间，它们的消除过程是互不影响的，可以分别作为子问题，使用动态规划处理。在处理后两个区间的时候，我们无需关心所有 $x$ 的存在，因为它们都被压在最底下，不干扰区间内的消除；而且只要这两个区间都能正确地消成目标局面（放进第二个 $x$ 之前该有的样子和两个栈里分别只有一个 $x$，没有其他卡牌），那么这两个 $x$ 就能在最后消掉。

本题最难的部分到此结束，然后就是推导如何定义以及解决这些子问题，即设计动态规划的状态和转移。

首先这三个区间以中间的区间最为复杂，其一般形式是：

- 初始局面为，第一个栈是空的，第二个栈中从下到上按第一次出现的顺序放着一次出现在 $[1,l)$，另一次出现在 $[l,r]$ 的卡牌；
- 需要把序列中 $[l,r]$ 的卡牌依次放进栈里，在任何时候如果两个栈顶相同则消掉；
- 最终局面为，第**二**个栈是空的，第**一**个栈中从下到上按第一次出现的顺序放着一次出现在 $[l,r]$，另一次出现在 $(r,m]$ 的卡牌。

另外两个区间也都可以表示成这种形式。我们用 $f(l,r)$ 表示上面这个问题是否有解。

如果最终局面第一个栈不是空的，考虑这个栈栈底的那张牌。对于这个区间 $[l,r]$ 来说，这张牌一旦放进去，就会永远留在这个位置，因为它在区间内只出现了一次。所以，在即将放进这张牌之时，第一个栈必须是空的。那么这时第二个栈里有什么呢？设和第一个栈栈底种类相同的另一张牌出现在序列上 $i$ 的位置。由于此时第一个栈必须是空的，那么对于在 $[l,i)$ 中出现两次的牌和出现一次但在初始局面中第二个栈里的牌都必须要消掉。在消完这些卡牌之后，如果 $[l,i)$ 内有消不掉的牌需要放在 $(i,r]$ 消除的，也必须按顺序堆在第二个栈顶上。于是这里需要两个条件：

- 对于所有的一次出现在 $[1,l)$，一次出现在 $[l,i)$ 的卡牌，它第一次出现的位置必须比任何满足一次出现在 $[1,l)$，一次出现在 $(i,r]$ 的卡牌的第一次出现的位置更晚，即在栈里的更上方，否则它就会全程被后者压在下面而无法在 $[l,i)$ 内被消掉；
- 对于所有的一次出现在 $[1,l)$，一次出现在 $[l,i)$ 的卡牌，它第二次出现的位置必须比任何满足一次出现在 $[l,i)$，一次出现在 $(i,r]$ 的卡牌的第一次出现的位置更早，否则在后者进入第二个栈之后，前者就会被压在下面而无法在 $[l,i)$ 内被消掉。

如果任何一个条件不满足，$f(l,r)$ 就直接无解了。否则放进 $i$ 前后的局面也是唯一确定的，于是又可以在忽略位于 $i$ 的这张牌的存在之后把 $[l,i)$ 和 $(i,r]$ 两个区间当成子问题处理。可以仔细分析一下，$(i,r]$ 这个区间的子问题就是 $f(i+1,r)$，但是 $[l,i)$ 这个区间的子问题有一点不一样：

- 初始局面为，第一个栈是空的，第二个栈中从下到上按第一次出现的顺序放着一次出现在 $[1,l)$，另一次出现在 $[l,i)$ 的卡牌；
- 需要把序列中 $[l,i)$ 的卡牌依次放进栈里，在任何时候如果两个栈顶相同则消掉；
- 最终局面为，第**一**个栈是空的，第**二**个栈中从下到上按第一次出现的顺序放着一次出现在 $[l,i)$，另一次出现在 $[i,m]$ 的卡牌。

这个问题的形式和 $f$ 很像，我们考虑用 $g(l,i-1)$ 表示上面这个问题是否有解。

如果最终局面下两个栈都是空的，那么 $f(l,r)$ 和 $g(l,r)$ 是同一个问题。这种情况我们放在最后讨论。我们先考虑如何对最终局面下第二个栈非空的 $g(l,r)$ 求解。

考虑最终局面下第二个栈栈底的卡牌。对于这个区间 $[l,r]$ 来说，这张牌一旦放进去，就会永远留在这个位置，因为它在区间内只出现了一次。所以，在即将放进这张牌之时，第二个栈必须是空的。那么这时第一个栈里有什么呢？设和第二个栈栈底种类相同的另一张牌出现在序列上 $i$ 的位置。由于此时第二个栈必须是空的，那么对于在 $[l,i)$ 中出现两次的牌和初始局面中第二个栈里**所有的牌**都必须要消掉。如果 $[l,i)$ 内有消不掉的牌需要放在 $(i,r]$ 消除的，需要按顺序堆在第一个栈顶上。于是这里需要满足一个条件：

- 不存在一次出现在 $[1,l)$，另一次出现在 $(i,r]$ 的卡牌。

如果不满足，$g(l,r)$ 就无解了。否则放进 $i$ 前后的局面也是唯一确定的，于是又可以在忽略位于 $i$ 的这张牌的存在之后把 $[l,i)$ 和 $(i,r]$ 两个区间当成子问题处理。可以仔细分析一下，$[l,i)$ 这个区间的子问题就是 $f(l,i-1)$；$(i,r]$ 这个区间的子问题在交换两个栈的编号之后就是 $f(i+1,r)$。

剩下就是最终局面下两个栈全空的情况。这时 $f(l,r)$ 和 $g(l,r)$ 是等价的。为了表示区别，这里用 $b(l,r)$ 表示。

考虑枚举最后一次消除的是哪种类型的卡牌。

首先，如果初始局面下第二个栈不是空的，那么最后一次消除的卡牌可能是这个栈栈底的卡牌。那么放进另一张同种类的卡牌时，另一个栈必须是空的。设另一张同种类的卡牌的位置为 $i$，那么类似于上面的分析，可以拆分为 $g(l,i-1)$ 和 $f(i+1,r)$ 两个子问题，且需要满足条件：

- 对于所有的一次出现在 $[1,l)$，另一次出现在 $[l,i)$ 的卡牌，它第一次出现的位置必须比任何满足一次出现在 $[1,l)$，另一次出现在 $(i,r]$ 的卡牌的第一次出现的位置更晚；
- 对于所有的一次出现在 $[1,l)$，另一次出现在 $[l,i)$ 的卡牌，它第二次出现的位置必须比任何满足一次出现在 $[l,i)$，另一次出现在 $(i,r]$ 的卡牌的第一次出现的位置更早。

此外，设最后一次消除的卡牌分别位于 $i$ 和 $j$ 的位置，其中 $i<j$。

由于初始局面下第二个栈可能不是空的，所以把位置在 $i$ 的元素（以下直接用 $i$ 表示）放进哪个栈是有区别的。这里我们枚举讨论。

无论如何，$i$ 和 $j$ 入栈时都必须位于栈底。

如果把 $i$ 放进第一个栈，那么类似于上面的分析，可以拆分为 $g(l,i-1)$，$f(i+1,j-1)$ 和交换两个栈编号之后的 $b(j+1,r)$ 三个子问题，且需要满足条件：

- 对于所有的一次出现在 $[1,l)$，另一次出现在 $[l,i)$ 的卡牌，它第一次出现的位置必须比任何满足一次出现在 $[1,l)$，另一次出现在 $(i,r]$ 的卡牌的第一次出现的位置更晚；
- 对于所有的一次出现在 $[1,l)$，另一次出现在 $[l,i)$ 的卡牌，它第二次出现的位置必须比任何满足一次出现在 $[l,i)$，另一次出现在 $(i,j)$ 的卡牌的第一次出现的位置更早；
- 不存在一次出现在 $[l,i)$，另一次出现在 $(j,r]$ 的卡牌。

如果把 $i$ 放进第二个栈，那么类似于上面的分析，可以拆分为 $f(l,i-1)$，交换两个栈编号之后的 $f(i+1,j-1)$ 和不交换两个栈编号的 $b(j+1,r)$ 三个子问题，且需要满足条件：

- 不存在一次出现在 $[1,l)$，另一次出现在 $(i,r]$ 的卡牌；
- 不存在一次出现在 $[l,i)$，另一次出现在 $(j,r]$ 的卡牌。

于是 $b(1,m)$ 就代表了整个问题是否有解。构造方案就是需要对每个 $b$ 记录你选择的 $i$ 和 $j$，以及把 $i$ 放进哪个栈，然后 DFS 求出每种牌是先放在第一个栈还是先放在第二个栈。这里可以用 $i$ 和 $j$ 分别代表把 $i$ 放进第一个栈和第二个栈。注意有些子问题递归进去的时候需要交换两个栈的编号，这在前面已经全部注明。需要注意所有要满足的条件必须手动判断而不是让状态的定义域自动解决，否则根据状态的定义，那些中间的确定局面会出错。

时间复杂度为 $O(m^3)$，但由于 $b$ 类状态数量很少（仍然是 $O(m^3)$），可以轻松通过。

---


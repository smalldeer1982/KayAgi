# [THUPC 2024 初赛] 排序大师

## 题目描述

由于你是排序大师，你经常被路过的游客刁难，要求用一些奇怪的操作给序列排序。

由于你是远近闻名的排序大师，邻国的排序萌新小 I 慕名前来拜访，留下了一个长度为 $n$ 的排列 $a_1, a_2 \cdots, a_n$，并要求你用以下操作将排列升序排序：

- 定义 $a_{i \sim j} = \{a_i,a_{i+1},\cdots, a_j\}$。选定 $1 \le i \le j < k \le l \le n$，交换 $a_{i \sim j}$ 和 $a_{k \sim l}$，即交换过后序列变为 $a_{1 \sim i-1}, a_{k \sim l}, a_{j+1 \sim k-1}, a_{i \sim j}, a_{l+1 \sim n}$。

由于你是因精益求精而远近闻名的排序大师，你需要给出一个排序方案**最小化**操作次数。

## 说明/提示

### 样例 \#1 解释
选定 $i = 2, j = 3, k = 5, l = 5$，$\colorbox{white}{\color{black}{1}\color{blue}{45}\color{black}{3}\color{red}{2}\color{black}{6}}$ 变为 $\colorbox{white}{\color{black}{1}\color{red}{2}\color{black}{3}\color{blue}{45}\color{black}{6}}$。

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
6
1 4 5 3 2 6
```

### 输出

```
1
2 3 5 5
```

# 题解

## 作者：vzcx_host (赞：8)

不会严格证明结论，但是过了。

考虑到当 $x$ 后面紧跟 $x+1$ 时这两个数完全可以绑在一起，因此我们考虑将 $i$ 归位时尽可能增加绑定数对的数量。

假定 $1\sim i-1$ 已经归位，考虑将 $i$ 归位，如果 $i$ 已经在位置上了可以直接跳过，否则 $i$ 的位置必然为第二个区间的左端点，这时候考虑另外三个点选哪里，若 $i+1$ 在 $i$ 的左边，我们可以将 $i-1,i+1$ 中间的数与  $i$ 交换（若 $i-1$ 紧贴 $i+1$，则第一个区间取 $i+1$ 的位置到 $i$ 的位置减一），$i$ 归位的同时 $i$ 与 $i+1$ 绑定；若 $i+1$ 在 $i$ 的右边，将第二个区间的右端点更新为 $i+1$ 的位置，继续考虑 $i+2$ 的位置，直到找到一个数在 $i$ 左侧。若 $j$ 为找到的第一个在 $i$ 左侧的数，则操作后 $i$ 会归位，$j-1$ 会与 $j$ 贴合。由于操作前 $i$ 没有归位，其左侧必定有别的数。

猜为什么这样是对的：将 $i,j,j+1$ 的位置视为“墙”，“墙”把原序列分为了四段，每段段内的相对顺序没变，意味着其它优化位置没有被破坏，看起来很对。

---

## 作者：Kubic (赞：5)

赛时做法，与 std 略有不同。

令 $a_0=0$，$b_{a_i}=a_{i+1}$。接下来的下标与值均在 $\bmod (n+1)$ 意义下考虑。

定义 $G(b)$ 表示 $i$ 向 $b_i$ 连边得到的有向图。

考虑一次操作 $i,j,k,l$，我们相当于先交换 $b_{i-1},b_{k-1}$，再交换 $b_j,b_l$。最终的目标为 $\forall i,b_i=i+1$。

于是自然想到将一次操作分裂为两个二元组 $(a_{i-1},a_{k-1}),(a_j,a_l)$。最终相当于是依次考虑每个二元组 $(x,y)$，并交换 $b_x,b_y$。

$G(b)$ 初始为一个环，交换 $b_x,b_y$ 后 $G(b)$ 会变为两个环。而题目中给出的操作额外要求当访问完偶数个二元组之后 $G(b)$ 为一个环。

不妨先忽略这个限制（即不关心 $G(b)$ 的环数）。则问题变为每次可以交换 $b$ 中任意两个元素，用最少的步数变为 $\forall i,b_i=i+1$。这是经典问题，这里不再赘述。

于是我们得到了不考虑限制的情况下的一组解。考虑对其进行调整使得它满足限制。

设 $(x_i,y_i)$ 表示上述解中的第 $i$ 个二元组。

我们钦定 $(x_1,y_1)$ 不变。则交换 $b_{x_1},b_{y_1}$ 之后 $G(b)$ 变为两个环，设它们的点集分别为 $S,T$。

因为在访问所有二元组之后 $G(b)$ 为一个环，所以一定存在 $i\in [2,2t]$ 使得 $x_i\in S,y_i\in T$ 或 $x_i\in T,y_i\in S$。

我们找到满足上述条件的最小的 $i$。不断地尝试将 $(x_i,y_i)$ 与 $(x_{i-1},y_{i-1})$ 交换顺序，并令 $i\leftarrow i-1$，直到 $i=2$ 为止。

令原来的顺序为 $(x_{i-1},y_{i-1}),(x_i,y_i)$。交换的方法如下：

- $\{x_i,y_i\}=\{x_{i-1},y_{i-1}\}$ 的情况不可能出现，否则一定不是最优解。

- 若 $x_i,y_i,x_{i-1},y_{i-1}$ 互不相同，则变为 $(x_i,y_i),(x_{i-1},y_{i-1})$。

- 否则不妨设 $x_i=x_{i-1}$，则变为 $(y_{i-1},y_i),(x_{i-1},y_{i-1})$。

可以发现，上述交换过程不会改变 $b$ 在施加所有操作后的最终状态。并且在上述过程结束时一定有 $x_2\in S,y_2\in T$ 或 $x_2\in T,y_2\in S$。因此访问完 $(x_1,y_1),(x_2,y_2)$ 后 $G(b)$ 为一个环。

归纳地进行类似的调整，最终可以使得整个序列满足条件。

构造出满足限制的操作序列之后将其转化成原题的输出还需要讨论一些细节，不过这是 trivial 的，请读者自行思考（

暴力实现的时间复杂度即为 $O(n^2)$，足以通过。

参考代码（代码中在序列末尾增加了一项，应该是没有必要的）：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 2005
int n,tp,a[N],b[N],vs[N],o[N];struct Node {int x,y;}z[N];
void swp(int x)
{
    if(z[x].x==z[x-1].x) z[x].x=z[x-1].y;
    else if(z[x].x==z[x-1].y) z[x].x=z[x-1].x;
    else if(z[x].y==z[x-1].x) z[x].y=z[x-1].y;
    else if(z[x].y==z[x-1].y) z[x].y=z[x-1].x;
    swap(z[x],z[x-1]);
}
void get() {int nw=0;for(int i=b[0];i;i=b[i]) o[i]=++nw;}
int main()
{
    scanf("%d",&n);for(int i=1;i<=n;++i) scanf("%d",&a[i]);++n;a[n]=n;
    for(int i=0;i<=n;++i) b[(a[i]+1)%(n+1)]=a[(i+1)%(n+1)];
    for(int i=0;i<=n;++i) if(!vs[i])
    {	
        for(int j=b[i];j!=i;j=b[j])
            vs[j]=1,z[++tp]=(Node) {(i+n)%(n+1),(j+n)%(n+1)};vs[i]=1;
    }for(int i=0;i<=n;++i) b[a[i]]=a[(i+1)%(n+1)];
    for(int i=1,t;i<=tp;i+=2)
    {
        t=0;swap(b[z[i].x],b[z[i].y]);fill(vs,vs+n+1,0);
        for(int j=z[i].x;!vs[j];j=b[j]) vs[j]=1;
        for(int j=z[i].y;!vs[j];j=b[j]) vs[j]=2;
        for(int j=i+1;j<=tp;++j) if(vs[z[j].x]^vs[z[j].y]) {t=j;break;}
        while(t>i+1) swp(t--);swap(b[z[i+1].x],b[z[i+1].y]);
    }for(int i=0;i<=n;++i) b[a[i]]=a[(i+1)%(n+1)];printf("%d\n",tp/2);
    for(int i=1;i<=tp;i+=2)
    {
        get();swap(b[z[i].x],b[z[i].y]);swap(b[z[i+1].x],b[z[i+1].y]);
        if(o[z[i].x]>o[z[i].y]) swap(z[i].x,z[i].y);
        if(o[z[i+1].x]>o[z[i+1].y]) swap(z[i+1].x,z[i+1].y);
        while(o[z[i].x]>=o[z[i+1].x] || o[z[i].y]>=o[z[i+1].y])
        {
            swp(i+1);if(o[z[i].x]>o[z[i].y]) swap(z[i].x,z[i].y);
            if(o[z[i+1].x]>o[z[i+1].y]) swap(z[i+1].x,z[i+1].y);
        }printf("%d %d %d %d\n",o[z[i].x]+1,o[z[i+1].x],o[z[i].y]+1,o[z[i+1].y]);
    }return 0;
}
```

---


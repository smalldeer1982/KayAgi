# [THUPC 2024 初赛] 一棵树

## 题目描述

这里有一棵树，具体的，这是一张有 $n$ 个节点和 $n-1$ 条边组成的无向联通图。

每个节点初始颜色为白色，你需要恰好将其中 $k$ 个节点染成黑色，定义一条边的权值是，断开这条边之后，两个连通块的黑色节点个数之差，定义一棵树的权值为所有边的权值求和，你需要最小化整棵树的权值。

## 说明/提示

### 样例 \#1 解释

下图展示了一种满足条件的染色方案，边上的数字表示边权。

![fig:sample](https://cdn.luogu.com.cn/upload/image_hosting/9i3ztp9r.png)

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
10 4
1 2
2 3
2 4
3 5
3 6
3 7
4 10
6 8
8 9
```

### 输出

```
16
```

# 题解

## 作者：_xinyu1113 (赞：48)

我们充分发扬人类智慧：

记每个点的权值为 $\sum{\min(sz_v,k/2)\times[fa_v=u]}$，然后按权值从大往小排序。

根据数学直觉，在权值排序后，答案所取的根在数组中肯定比较靠前。

所以我们只取数组最前的 $20$ 个点来计算答案。

这样速度快得飞起，在 $1\le k \le n \le 5 \times 10^5$ 时都可以在 400ms 内卡过。

---

## 作者：一念之间、、 (赞：10)


来一份官方题解。

## 题意简述

树，选 $k$ 个点染黑，代价为边权求和，边权定义为两边子树黑色节点之差。
	
$n,k\le 5\times 10^5$

## 题解

注意到当前询问形如权值为边权的权值求和，考虑树形 dp，直接的 dp 为 $f_{i,j}$ 表示 $i$ 子树内有 $j$ 个黑色节点的最小代价. 

有转移是易于计算的，子树的合并是树形背包的合并 $f_{x,j+k}=\min(f_{x,j}+f_{to,k})$，考虑当前点 x 到父亲这条边的代价是多少. 

注意到，形如如果当前子树有 $A$ 个黑点，子树外有 $k-A$ 个白点，代价为 $|2A-k|$.

观察函数的形式，你注意到如果将 $x$ 坐标作为黑点个数，$y$ 坐标作为代价，则每次代价增量为一个下凸函数，有树形背包合并不影响函数凸性.

注意到凸函数的维护可以尝试维护其差分数组，两个下凸函数做 $\min$ 卷积可以之际的视作差分数组的归并. 

现在需要考虑的问题是往父亲方向的增量怎么处理.

考虑代价增量的差分，形如一段前缀差分为负数，一段后缀差分为正数，中间一个点根据 k 的奇偶性讨论是否存在差分 = 0. 

有这一段前缀的长度总为定长度 $\lfloor \frac k 2 \rfloor$ 于是我们维护可并堆顶堆，使得左侧堆大小始终为前缀定长度，然后可以打加法标记实现.

总复杂度 $O(n\log n)$.

## 代码

```cpp
#include<bits/stdc++.h>
namespace ifzw{
#define ll long long 
#define dd double 
#define ull unsigned ll
#define LL __int128
#define siz(A) ((int)A.size())
using namespace std;
char gc(){static char buf[1<<16],*s,*t;if(s==t){t=(s=buf)+fread(buf,1,1<<16,stdin);if(s==t)return EOF;}return *s++;}
#define getchar gc
ll read()
{
	char c;
	ll w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	ll ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
void pc(char c,int op)
{
	static char buf[1<<16],*s=buf,*t=(buf+(1<<16));
	(op||((*s++=c)&&(s==t)))&&(fwrite(buf,1,s-buf,stdout),s=buf);
}
void wt(int x)
{
	if(x>9)wt(x/10);
	pc('0'+x%10,0);
}
void wts(int x,char op)
{
	if(x<0)pc('-',0),x=-x;
	wt(x),pc(op,0);
}
char ST;
const int xx=5e5+5;
int n,tk;
struct nod{int next,to;}e[xx<<1];
int cnt,h[xx];
void add(int x,int y){cnt++,e[cnt]={h[x],y},h[x]=cnt;}
//共用 point 系统 
struct pt
{
	int l,r,dst,siz;
	ll v,tg;
}t[xx];
void ad(int k,ll v){if(k)t[k].tg+=v,t[k].v+=v;}
void pd(int k){if(t[k].tg)ad(t[k].l,t[k].tg),ad(t[k].r,t[k].tg),t[k].tg=0;}
void upd(int k){t[k].siz=t[t[k].l].siz+t[t[k].r].siz+1;}

int m1(int x,int y)//大根 
{
//	cerr<<x<<" "<<y<<"@\n";
	if(!x||!y)return x+y;
	pd(x),pd(y);
	if(t[x].v<t[y].v)swap(x,y);
	t[x].r=m1(t[x].r,y);
	if(t[t[x].r].dst>t[t[x].l].dst)swap(t[x].l,t[x].r);
	t[x].dst=t[t[x].r].dst+1;
	return upd(x),x;
}
int m2(int x,int y)//小根 
{
//	cerr<<x<<" "<<y<<"^&^&\n";
	if(!x||!y)return x+y;
	assert(x!=y);
	pd(x),pd(y);
	if(t[x].v>t[y].v)swap(x,y);
	t[x].r=m2(t[x].r,y);
	if(t[t[x].r].dst>t[t[x].l].dst)swap(t[x].l,t[x].r);
	t[x].dst=t[t[x].r].dst+1;
	return upd(x),x;
}
//就加入的点叫做 x 
int tl[xx],tr[xx],A;

void print(int x)
{
	if(!x)return ;
	pd(x);
	cout<<t[x].v<<" ";
	print(t[x].l),print(t[x].r);
}
void pr(int x)
{
	print(tl[x]),print(tr[x]);
	puts("");
}
void dfs(int x,int y)
{
//		cerr<<"A B"<<"#\n";
	t[x].siz=1;
	for(int i=h[x];i;i=e[i].next)
	{
		if(e[i].to==y)continue;
		dfs(e[i].to,x);
//		cerr<<t[tl[e[i].to]].siz<<" "<<t[tl[x]].siz<<"##\n";
		tl[x]=m1(tl[x],tl[e[i].to]);
//		cerr<<t[tl[e[i].to]].siz<<" "<<t[tl[x]].siz<<"QQ\n";
		tr[x]=m2(tr[x],tr[e[i].to]);
	}
	
	t[x].v=0,t[x].tg=0;
	if(t[tl[x]].v>=0)tl[x]=m1(tl[x],x);
	else tr[x]=m2(tr[x],x);
//	cerr<<x<<" "<<t[tl[x]].siz<<" "<<t[tr[x]].siz<<"$AAAAAAAAAAA1%\n";
	while(t[tl[x]].siz<A&&t[tr[x]].siz)
	{
//		cerr<<"A B"<<"#\n";
//	cerr<<x<<" "<<y<<"@\n";
//		cerr<<t[tr[x]].siz<<" "<<t[tl[x]].siz<<" "<<A<<" "<<tl[x]<<" "<<tr[x]<<" #\n";
//		cerr<<t[tl[x]].siz<<"@#23\n";
		y=tr[x],pd(y);
		tr[x]=m2(t[tr[x]].l,t[tr[x]].r);
		t[y].siz=1,t[y].l=t[y].r=0,t[y].dst=0;
		tl[x]=m1(tl[x],y);
//		cerr<<t[tr[x]].siz<<" "<<t[tl[x]].siz<<" "<<A<<" #\n";
	}
//	cerr<<x<<" "<<t[tl[x]].siz<<" "<<t[tr[x]].siz<<"$BBBBBBBBBB1%\n";
	while(t[tl[x]].siz>A)
	{
//		cerr<<"A B"<<"#\n";
//		cerr<<t[tl[x]].siz<<"@#ab\n";
		y=tl[x],pd(y);
		tl[x]=m1(t[tl[x]].l,t[tl[x]].r);
		t[y].siz=1,t[y].l=t[y].r=0,t[y].dst=0;
		tr[x]=m2(tr[x],y);
	}
	if(x!=1)
	{
		if(tk&1)
		{
			ad(tl[x],-2);
			y=tr[x],pd(y);
			tr[x]=m2(t[tr[x]].l,t[tr[x]].r);
			if(y)t[y].siz=1,t[y].l=t[y].r=0,t[y].dst=0;
			ad(tr[x],2),tr[x]=m2(tr[x],y);
		}
		else ad(tl[x],-2),ad(tr[x],2);
	}
//	cerr<<x<<" "<<t[tl[x]].siz<<" "<<t[tr[x]].siz<<"$!!!!!!!!!!!!!!!!!1%\n";
//	cerr<<x<<"@@!!SS\n";
//	pr(x);
	
}
char ED;
int main(){
	t[0].dst=-1;
	cerr<<abs(&ST-&ED)/1024.0/1024<<"\n";
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
	n=read(),tk=read(),A=tk/2;
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		add(x,y),add(y,x);
	}
	if(!tk)
	{
		puts("0");
		return 0;
	}
	dfs(1,0);
//	for(int i=1;i<=n;i++)cout<<t[i].l<<" "<<t[i].r<<"SS\n";
//	cerr<<tl[1]<<" "<<tr[1]<<" "<<t[tl[1]].siz<<" "<<t[tr[1]].siz<<"%%\n";
//	exit(0);
//	cerr<<"!\n";
	vector<ll>cf;
	while(t[tl[1]].siz)
	{
//		cerr<<tl[1]<<" "<<t[tl[1]].siz<<" "<<t[tl[1]].l<<" "<<t[tl[1]].r<<"@#2\n";
		cf.push_back(t[tl[1]].v);pd(tl[1]);
		tl[1]=m1(t[tl[1]].l,t[tl[1]].r);
	}
//	exit(0);
	while(t[tr[1]].siz)
	{
//		cerr<<tr[1]<<"%^%^\n";
		cf.push_back(t[tr[1]].v);pd(tr[1]);
		tr[1]=m2(t[tr[1]].l,t[tr[1]].r);
	}
	sort(cf.begin(),cf.end());
	ll ini=1ll*(n-1)*tk;
//	cerr<<siz(cf)<<"$%$%%%\n";
//	cerr<<siz(cf)<<" "<<tk<<"%$%\n";
	assert(siz(cf)>=tk);
	for(int i=0;i<tk;i++)ini+=cf[i];
//	for(int i=0;i<tk;i++)cerr<<i<<" "<<cf[i]<<"$\n";
//	cerr<<cf[0]<<"$\n";
	cout<<ini<<"\n";
	pc('1',1);
	return 0;
}


}signed main(){return ifzw::main();}
```

---

## 作者：Alex_Wei (赞：7)

### *[P9962 [THUPC 2024 初赛] 一棵树](https://www.luogu.com.cn/problem/P9962)

**谁说点分治过不了?**

思路来自 asmend。

从边的角度计算贡献，涉及黑点个数之差的绝对值，难以入手。

考虑从点的角度计算贡献。钦定黑点重心为 $x$，以 $x$ 为根，则每条边的贡献为 $k - 2 b_i$，其中 $b_i$ 表示这条边的子树的黑点个数，从而知每个点涂成黑点的贡献为 $-2d_i$，其中 $dep_i$ 表示点 $i$ 的深度。

因为钦定 $x$ 是黑点的重心，所以 $x$ 的每棵子树不能选超过 $m = \frac k 2$ 个黑点（所有除法均为下取整）。棘手的地方在于，如果某棵子树选择了超过 $m$ 个黑点，那么会得到更优的答案，也就是不合法的方案带来了更优值，所以必须严格满足合法性（若不合法的方案不会更优，那么就算 $x$ 最终不是重心也没关系）。

考虑最优方案对应的黑点重心 $x ^ *$，那么 $x ^ *$ 不会有子树希望选超过 $m$ 个黑点，否则调整可得更优解。相反，对于钦定的重心 $x$，如果 $x$ 没有子树希望选超过 $m$ 个点，那么它一定是最优方案之一对应的黑点重心之一。否则考虑更优方案在以 $x$ 为根时对应的权值，根据刚才的分析，是小于它真实权值的，但最优方案的权值又小于更优方案在以 $x$ 为根时对应的权值（这条性质由贪心策略保证），所以最优方案的权值小于更优方案的权值，矛盾。于是，我们希望找到一个点，使得以它为根贪心时没有子树希望选超过 $m$ 个黑点。

当 $k$ 为偶数时，最多有一棵子树希望选超过 $m$ 个黑点。如果这样的子树存在，那么 $x ^ *$ 显然落在这棵子树里，因为容易证明对于子树外的任意 $x'$，以 $x'$ 为根时 $x$ 方向的子树希望选超过 $m$ 个黑点。任意选点，每次选一棵子树递归，点分治即可。

时间复杂度 $\mathcal{O}(n\log ^ 2 n)$，且常数较大。将排序换成桶排序即可做到 $\mathcal{O}(n\log n)$。

当 $k$ 为奇数时，由于奇偶性的限制，可能存在两棵子树希望选超过 $m$ 个黑点。这也是唯一需要特殊处理的情况。如果这种情况没有发生，类似点分治即可。注意特判 $k = 1$。

实际上，我们断言，$k$ 为奇数时的答案就是 $k - 1$ 时的答案额外加入一个新增权值最小的黑点。考虑在当前方案的基础上再选一个黑点 $y$ 产生的贡献（减小的权值）。

- 对于不在 $x\sim y$ 路径上的所有边，它们黑点个数较多的那部分子树又多出一个黑点，所以贡献增加 $1$，即 $y$ 没有减少这些边的权值（一开始所有边的权值当成 $k$ 算，即方案的权值为 $(n - 1)k$ 减去每个黑点的贡献）。
- 对于在 $x\sim y$ 路径上的所有边，由于 $x$ 是当前的重心，所以它们含 $y$ 的一侧子树至多有 $m$ 个黑点。如果黑点数恰好为 $m$，那么也没有减少这些边的权值。反之则减小了 $2$。

综合上述两种情况，$y$ 产生的贡献为它到所有 “子树恰有 $m$ 个黑点” 的点的最短距离。于是每个白点 $y$ 变成黑点后产生的贡献就是容易计算的了。相信现在读者的心中还剩下一个谜团 ——

---

为什么会这样？

首先考虑 $k - 1$ 最优方案的重心 $x$，那么 $k$ 的最优方案不会在 $x$ 的某棵子树选超过 $m + 1$ 个点，否则 $k - 1$ 时 $x$ 在该方向上希望选至少 $m + 1$ 个点，与 $x$ 在 $k - 1$ 时的最优性矛盾。

如果 $k$ 的最优方案没有在 $x$ 的某棵子树选 $m + 1$ 个点，那么 $x$ 就是 $k$ 的重心，根据贪心过程，$k$ 的最优方案由 $k - 1$ 的最优方案多选一个黑点得到。

否则 $k$ 的最优方案在 $x$ 的某棵子树 $T$ 选了 $m + 1$ 个点。此时 $k - 1$ 的最优方案一定在 $T$ 选了 $m$ 个点，否则存在 $y\notin T$ 使得 $y$ 的深度不小于所有 $T$ 中 “在 $k$ 的最优方案被选中但没有在 $k - 1$ 的最优方案被选中” 的点的深度，且 $y$ 没有在 $k$ 的最优方案被选中，调整即得更优解。

子树之间的贡献相对独立，容易证明 $T$ 以外其它子树的决策不变。现在只需要考虑 $T$ 内部的决策。

枚举所有 $m + 1$ 个黑点的 LCA $d$，在 $d$ 的限制下的最优方案为先选 $d$ 子树内 $m$ 个深度最大的点，再选一个让 LCA 固定为 $d$。设选点集合为 $S$，黑点的总贡献为 $2\sum_{i\in S} dep_i - 2dep_d$，我们要最大化总贡献。

一个容易理解的性质是 $m$ 个深度最大的点可以任选：假设我们想选择的 $m$ 个深度最大的点 $S'$ 之中有一个点 $x$ 没有被选中，那么 $S$ 中至少有两个不是 $S'$ 的元素。对于任意 $x\in S$，存在 $y\in S$ 使得 $x, y$ 的 LCA 等于 $S$ 的 LCA（这是对于任意有根树和任意 $S$ 都成立的），且 $(S\backslash S') \cup (S\cap S') = S$，所以

- 要么 $S\backslash S'$ 存在元素 $y$ 使得 $x, y$ 的 LCA 为 $d$，此时由于 $|S\backslash S'| \geq 2$，挑一个不是 $y$ 的元素换成 $x$ 即可。
- 要么 $S\cap S$ 存在元素 $x'$ 使得 $x, y$ 的 LCA 为 $d$，此时任选 $y\in S\backslash S'$ 换成 $x$ 即可。

所有工具已经准备完毕，只差最后一击了！设原来 $m$ 个黑点的 LCA 为 $d'$：

- 如果 $d$ 不是 $d'$ 的 LCA，那么将选择的 $m$ 个 $d$ 子树内深度最大的点换成原来的 $m$ 个黑点，则 $\sum_{i\in S} dep_i$ 不降（因为原来 $m$ 个黑点的深度是 $T$ 最大的 $m$ 个深度），且新的 LCA 变浅，即 $2dep_d$ 减小，于是总贡献增加。此时原来的 $m$ 个黑点现在依然是黑点。
- 如果 $d$ 是 $d'$ 的 LCA，那么由于选择的 $m$ 个深度最大的点可以是任意 $m$ 个深度最大的点，所以同样的，原来的 $m$ 个黑点现在依然可以是黑点。

综上，原来的 $m$ 个黑点现在依然可以是黑点。

$\square$

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using pdd = pair<double, double>;
using ull = unsigned long long;
using LL = __int128_t;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;
// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
mt19937_64 rnd(1064);
int rd(int l, int r) {
  return rnd() % (r - l + 1) + l;
}

// ---------- templates above ----------

constexpr int N = 5e5 + 5;

int n, k;
ll ans = LONG_LONG_MAX;
vector<int> e[N];

int R, mx[N], sz[N], vis[N];
void findr(int id, int ff, int tot) {
  sz[id] = 1, mx[id] = 0;
  for(int it : e[id]) {
    if(it == ff || vis[it]) continue;
    findr(it, id, tot);
    sz[id] += sz[it];
    mx[id] = max(mx[id], sz[it]);
  }
  mx[id] = max(mx[id], tot - sz[id]);
  if(mx[id] < mx[R]) R = id;
}

int dep[N], bel[N];
struct dat {
  int dep, id;
  bool operator < (const dat &z) const {
    return dep < z.dep;
  }
};
vector<dat> arr;
void findd(int id, int ff, int dp, int anc) {
  bel[id] = anc;
  arr.push_back({dep[id] = dp, id});
  for(int it : e[id]) {
    if(it == ff) continue;
    findd(it, id, dp + 1, anc ? anc : it);
  }
}

int f[N], cnt[N];
void dfs(int id, int ff) {
  for(int it : e[id]) {
    if(it == ff) continue;
    dfs(it, id), f[id] += f[it];
  }
}
void divide(int id) {
  vis[id] = 1;
  arr.clear();
  findd(id, 0, 0, 0);
  sort(arr.begin(), arr.end());
  vector<int> to;
  ll sum = 1ll * (n - 1) * k, lst = 0;
  memset(cnt, 0, N << 2);
  memset(f, 0, N << 2);
  for(int _ = 1; _ <= k; _++) {
    while(!arr.empty()) {
      int tid = arr.back().id;
      if((cnt[bel[tid]] + 1) * 2 <= k) break;
      else to.push_back(bel[tid]);
      arr.pop_back();
    }
    if(arr.empty()) break;
    sum -= lst = 2 * arr.back().dep;
    f[arr.back().id] = 1;
    cnt[bel[arr.back().id]]++;
    arr.pop_back();
    if(_ == k) ans = min(ans, sum);
  }


  sort(to.begin(), to.end());
  to.resize(unique(to.begin(), to.end()) - to.begin());
  if(to.size() <= 1) {
    for(int it : to) {
      if(vis[it]) continue;
      findr(it, id, n);
      R = 0, findr(it, id, sz[it]);
      divide(R);
    }
    return;
  }

  sum += lst, dfs(id, 0); // 撤回到 k - 1 的方案. 这里可以不清空 lst 对应 tid 的 f, 想一想为什么?
  static int dis[N], mx = 0;
  memset(dis, -1, N << 2);
  queue<int> q;
  for(int i = 1; i <= n; i++) {
    if(f[i] >= k / 2) dis[i] = 0, q.push(i);
  }
  while(!q.empty()) {
    int t = q.front();
    q.pop();
    if(!f[t]) mx = dis[t];
    for(int it : e[t]) {
      if(dis[it] == -1) {
        dis[it] = dis[t] + 1;
        q.push(it);
      }
    }
  }
  ans = min(ans, sum - 2 * mx);
}

void solve() {
  cin >> n >> k;
  if(k == 1) {
    cout << n - 1 << "\n";
    return;
  }
  for(int i = 1; i < n; i++) {
    int u, v;
    cin >> u >> v;
    e[u].push_back(v);
    e[v].push_back(u);
  }
  mx[0] = N, findr(1, 0, n);
  divide(R);
  cout << ans << endl;
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = 1;
  while(T--) solve();
  fprintf(stderr, "%d ms\n", int(1e3 * clock() / CLOCKS_PER_SEC));
  return 0;
}

/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/
```

---

## 作者：一只绝帆 (赞：7)

非常好题目，使我的代码旋转。

一点题外话是作者参加 APIO2023 前刚接触分层图最短路还没开始学就被创死了，这次参加 THUPC2024 前刚接触 `Minkowski Sum` 还没开始整理就似了。

可以说是官解的细化吧。

首先有朴素的树上背包，设 $f_{x,i}$ 为子树 $x$ 中染了 $i$ 个黑点，该子树（包括根向上连的那条边）的权值最小值。

转移式很简单，首先合并子树 $f_{x,i}+f_{y,j}\to f_{x,i+j}$，就是做了一个 $(\min,+)$ 卷积。

然后把所有子树合起来之后如果 $x\ne 1$，那再加上根选或不选的代价，设 $g_i$ 为子树内选了 $i$ 个黑点的代价，则有 $g_i=|i-(k-i)|=|2i-k|$。

也就是合并结束之后 $\forall i,f'_{x,i}\gets \min(f_{x,i}+g_i,f_{x,i-1}+g_i)$。

以上就是 $\Theta(n^2)$ 的 dp 部分，我们考虑优化。

$(\min,+)$ 卷积想要优化只有一个思路，考虑证明 $f_x$ 关于 $i$ 是凸的。

事实上不妨假设儿子的 $f_{y}$ 都是凸的，如果经过合并之后能证明 $f_x$ 也是凸的，则我们能归纳地证明这个问题。

既然假设 $f_y$ 是凸的那么对其做 $(\min,+)$ 卷积就是求闵可夫斯基和，也就是将两个单调有序的差分数组归并起来，所以合并后仍为凸函数。

然后我们加上 $x$ 是否染黑的代价，也就是：

$$\begin{aligned}f'_{x,i}\gets&\min(f_{x,i}+g_i,f_{x,i-1}+g_i)\\=&\min(f_{x,i},f_{x,i-1})+g_i\end{aligned}$$

那我们可以进一步拆解，先 $f'_{i}\gets \min(f_i,f_{i-1})$，再 $f'_i\gets f_i+g_i$。

前一个操作可以看作往背包里扔了一个空元素，后一个操作是凸函数加凸函数，仍然是一个凸函数（证明就是单调导数相加仍单调）。

好知道 $f_x$ 是凸的了，那么前一部分合并就处理完了，现在只需要处理 $f_i'\gets f_i+g_i$。

考虑维护 $f,g$ 的差分数组 $F,g'$，则我们发现：

$$g'_i=\left\{\begin{aligned}-2,&&i&\le \left\lfloor\frac k 2\right\rfloor\\0,&&i&=\left\lceil\frac k 2\right\rceil=\left\lfloor\frac k 2\right\rfloor+1\\2,&&i&>\left\lceil\frac k 2\right\rceil\end{aligned}\right.$$

（$g'$ 是 $g$ 的差分数组。）

所以这对 $F$ 的影响就是值域上一段前缀向左挪 $2$，中间可能有一个值不变，后面的部分向右挪 $2$。

（实际上对差分数组的第一个数的增加并不是 $-2$ 而是 $k$，但这不影响我们的合并过程，我们可以将其留到最后加到答案中。）

考虑 $F$ 还需要支持快速合并，直接上能打 `tag` 的可并对顶堆，复杂度 $\Theta(n\log n)$。

（也可以平衡树 + 启发式合并。）

代码写的比官解精简很多：

```cpp
#include<bits/stdc++.h>
#define l(x) ls[x]
#define r(x) rs[x]
#define G(i,x) for(int i(start[x]);i;i=Next[i])
#define F(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
using namespace std;typedef long long ll;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char *p1,*p2,buf[1<<21];
int read() {
	int s=0,w=0;char ch=gc();
	while(ch<'0'||ch>'9') w|=(ch=='-'),ch=gc();
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=gc();
	return w?-s:s;
} const int N=5e5+5,N2=N<<1;
int n,k,v[N2],Next[N2],start[N],cnt;ll tg[N2],a[N2];
int q[N2],siz[N2],r1[N2],r2[N2],l(N2),r(N2);
void add(int x,int y) {v[++cnt]=y;Next[cnt]=start[x];start[x]=cnt;}
void Add(int x,int y) {add(x,y);add(y,x);}
void up(int x) {siz[x]=siz[l(x)]+siz[r(x)]+1;}
void pr(int x,int v) {if(x) tg[x]+=v,a[x]+=v;}
void down(int x) {if(tg[x]) pr(l(x),tg[x]),pr(r(x),tg[x]),tg[x]=0;}
int m(int x,int y) {//big root
	if(!x||!y) return x|y;down(x);down(y);
	if(a[x]<a[y]) swap(x,y);
	r(x)=m(r(x),y);
	if(q[l(x)]<q[r(x)]) swap(l(x),r(x));
	q[x]=q[r(x)]+1;
	return up(x),x;
}
int pop(int &r) {if(!r) return 0;
	int t=r;down(t);r=m(l(t),r(t));
	l(t)=r(t)=q[t]=0;siz[t]=1;
	return t;
}
int M(int x,int y) {
	if(!x||!y) return x|y;down(x);down(y);
	if(a[x]>a[y]) swap(x,y);
	r(x)=M(r(x),y);
	if(q[l(x)]<q[r(x)]) swap(l(x),r(x));
	q[x]=q[r(x)]+1;
	return up(x),x;
}
int Pop(int &r) {if(!r) return 0;
	int t=r;down(t);r=M(l(t),r(t));
	l(t)=r(t)=q[t]=0;siz[t]=1;
	return t;
}
void d(int x,int fa=0) {
	G(i,x) if(v[i]^fa) {
		d(v[i],x);
		r1[x]=m(r1[x],r1[v[i]]);
		r2[x]=M(r2[x],r2[v[i]]);
	} a[x]=0;siz[x]=1;
	if(a[r1[x]]>=0) r1[x]=m(r1[x],x);
	else r2[x]=M(r2[x],x);
	if(x==1) return;
	while(siz[r1[x]]<k/2&&r2[x]) r1[x]=m(r1[x],Pop(r2[x]));
	while(siz[r1[x]]>k/2) r2[x]=M(r2[x],pop(r1[x]));
	if(k&1) {
		int t=Pop(r2[x]);pr(r1[x],-2);pr(r2[x],2);
		r2[x]=M(r2[x],t);
	} else pr(r1[x],-2),pr(r2[x],2);
}
vector<ll> s;
int main() {q[0]=-1;
	n=read();k=read();
	F(i,2,n) Add(read(),read());
	d(1);
	while(r1[1]) s.push_back(a[pop(r1[1])]);
	while(r2[1]) s.push_back(a[Pop(r2[1])]);
	sort(begin(s),end(s));
	F(i,1,k-1) s[i]+=s[i-1];
	cout<<s[k-1]+1ll*(n-1)*k<<endl;
	return 0;
}
```

---

## 作者：0x3F (赞：5)

我们发现，答案就是 $\sum_{i=2}^{n}\lvert k-2cnt_{i}\rvert$，其中 $cnt_{i}$ 表示以 $i$ 为根的子树内黑点的数量。

考虑朴素 DP：记 $dp_{i,a}$ 表示以 $i$ 为根的子树内有 $a$ 个黑点时，$\sum_{j\in T_{i},j\ne1}\lvert k-2cnt_{j}\rvert$ 的最小值，其中 $T_{i}$ 表示以 $i$ 为根的子树。

转移比较显然：初始时 $dp_{i,0}=dp_{i,1}=0$，然后枚举 $i$ 的儿子 $j$，令 $dp^{\prime}_{i,a}\gets\min\{dp_{i,a-b}+dp_{j,b}\}$。枚举完所有儿子以后，如果 $i\ne 1$，那么令 $dp_{i,a}\gets dp_{i,a}+\lvert k-2a\rvert$。

但是这样显然不能过。我们发现，转移的形式和闵可夫斯基和的形式是一致的，而 $\lvert k-2a\rvert$ 是凸函数，由归纳法可证 $dp_{i,a}$ 是关于 $a$ 的凸函数。

我们用某种数据结构维护对于每个 $i$，$dp_{i,a}-dp_{i,a-1}$ 构成的可重集，需要支持将两个集合合并，以及将一段区间内的数 $-2$，将一段区间内的数 $+2$。

使用平衡树和 DSU on tree 即可，时间复杂度为 $\mathcal{O}(n\log^2n)$，但是常数似乎较小，可以通过此题。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 5e5 + 10;
const int __ = 1e6 + 10;
int n, k, e, u, v, hd[_], nx[__], to[__], trt[_], tsiz[_], tson[_];
long long beg[_];
int fa[__], ch[__][2], siz[__];
long long val[__], tag[__], sum[__];
int SIZ, TOP, BIN[__];
inline void recycle(int x) {
	fa[x] = ch[x][0] = ch[x][1] = val[x] = siz[x] = 0;
	tag[x] = sum[x] = 0LL;
	BIN[++TOP] = x;
}
inline int reuse() {
	return ((TOP) ? (BIN[TOP--]) : (++SIZ));
}
inline int type(int x) {
	return (x == ch[fa[x]][1]);
}
inline void pushup(int x) {
	siz[x] = siz[ch[x][0]] + 1 + siz[ch[x][1]];
	sum[x] = sum[ch[x][0]] + val[x] + sum[ch[x][1]];
}
inline void pushdown(int x) {
	int ls = ch[x][0];
	int rs = ch[x][1];
	if (ls) {
		val[ls] += tag[x];
		sum[ls] += tag[x] * siz[ls];
		tag[ls] += tag[x];
	}
	if (rs) {
		val[rs] += tag[x];
		sum[rs] += tag[x] * siz[rs];
		tag[rs] += tag[x];
	}
	tag[x] = 0LL;
}
inline void rotate(int x) {
	int y = fa[x];
	int z = fa[y];
	bool f = type(x);
	bool g = type(y);
	ch[y][f] = ch[x][!f];
	if (ch[x][!f]) fa[ch[x][!f]] = y;
	ch[x][!f] = y;
	fa[y] = x;
	fa[x] = z;
	if (z) ch[z][g] = x;
	pushup(y);
	pushup(x);
}
inline int find(int k, int r) {
	bool f;
	while (1) {
		pushdown(r);
		if (k == siz[ch[r][0]] + 1) return r;
		bool f = (k > siz[ch[r][0]]);
		if (f) k -= siz[ch[r][0]] + 1;
		r = ch[r][f];
	}
}
inline void splay(int x, int r, int& rt) {
	for (int f; (f = fa[x]) != r; rotate(x)) {
		if (fa[f] != r) rotate(type(x) == type(f) ? f : x);
	}
	if (!r) rt = x;
}
inline void invadd(int x, int n, long long c, int& rt) {
	int s = 0, t = rt;
	if (x != 1) {
		swap(s, t);
		s = find(x - 1, s);
		splay(s, t, rt);
		t = ch[s][1];
	}
	if (n != siz[t]) {
		swap(s, t);
		s = find(n + 1, s);
		splay(s, t, rt);
		t = ch[s][0];
	}
	val[t] += c;
	sum[t] += c * siz[t];
	tag[t] += c;
	if (s) pushup(s);
	if (fa[s]) pushup(fa[s]);
}
inline long long invsum(int x, int n, int& rt) {
	int s = 0, t = rt;
	if (x != 1) {
		swap(s, t);
		s = find(x - 1, s);
		splay(s, t, rt);
		t = ch[s][1];
	}
	if (n != siz[t]) {
		swap(s, t);
		s = find(n + 1, s);
		splay(s, t, rt);
		t = ch[s][0];
	}
	return sum[t];
}
inline void insnum(long long x, int& rt) {
	if (!rt) {
		rt = reuse();
		val[rt] = x;
		siz[rt] = 1;
		tag[rt] = 0;
		sum[rt] = x;
	} else {
		int t = rt;
		bool f;
		while (1) {
			pushdown(t);
			f = (x >= val[t]);
			if (ch[t][f]) t = ch[t][f];
			else {
				int s = reuse();
				ch[t][f] = s;
				fa[s] = t;
				val[s] = x;
				siz[s] = 1;
				tag[s] = 0;
				sum[s] = x;
				pushup(s);
				pushup(t);
				splay(s, 0, rt);
				return;
			}
		}
	}
}
void breakdown(int x, vector<long long>& arr) {
	if (!x) return;
	arr.push_back(val[x]);
	pushdown(x);
	breakdown(ch[x][0], arr);
	breakdown(ch[x][1], arr);
	recycle(x);
}
inline void addedge(int u, int v) {
	e++;
	nx[e] = hd[u];
	to[e] = v;
	hd[u] = e;
}
void dfs1(int x, int f) {
	tsiz[x] = 1;
	for (int i = hd[x]; i; i = nx[i]) {
		int y = to[i];
		if (y != f) {
			dfs1(y, x);
			tsiz[x] += tsiz[y];
			if (!tson[x] || tsiz[y] > tsiz[tson[x]]) {
				tson[x] = y;
			}
		}
	}
}
void dfs2(int x, int f) {
	if (tson[x]) {
		dfs2(tson[x], x);
		trt[x] = trt[tson[x]];
		beg[x] = beg[tson[x]];
	}
	vector<long long> tmp;
	for (int i = hd[x]; i; i = nx[i]) {
		int y = to[i];
		if (y != f && y != tson[x]) {
			dfs2(y, x);
			breakdown(trt[y], tmp);
			beg[x] += beg[y];
		}
	}
	for (auto vv: tmp) {
		insnum(vv, trt[x]);
	}
	insnum(0, trt[x]);
	if (f) {
		beg[x] += k;
		if (tsiz[x] * 2 > k) {
			if (k & 1) {
				invadd(1, (k>>1), -2LL, trt[x]);
				if (tsiz[x]-(k>>1)-1 > 0) invadd((k>>1)+2, tsiz[x]-(k>>1)-1, 2LL, trt[x]);
			} else {
				invadd(1, (k>>1), -2LL, trt[x]);
				invadd((k>>1)+1, tsiz[x]-(k>>1), 2LL, trt[x]);
			}
		} else {
			invadd(1, tsiz[x], -2LL, trt[x]);
		}
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> k;
	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		addedge(u, v);
		addedge(v, u);
	}
	dfs1(1, 0);
	dfs2(1, 0);
	cout << beg[1] + invsum(1, k, trt[1]) << endl;
	return 0;
}
```

---

## 作者：KingPowers (赞：4)

算是闵可夫斯基和进阶但又基础的应用。

先考虑朴素的树形背包，设 $f_{u,x}$ 表示考虑 $u$ 子树内染黑了 $x$ 个点时的答案，统计答案的方式是在合并子树时考虑一条边被统计几次，具体来说：

$$
f'_{u,x}=\min_{i+j=x}(f_{u,i}+f_{v,j}+|2j-k|)
$$

直接实现复杂度是 $O(n^2)$ 的，考虑优化。

我们发现每次合并相当于是把 $f_{u,x}$ 和 $f_{v,x}+|2x-k|$ 做一个 $(\min,+)$ 卷积，而 $(\min,+)$ 卷积想要优化唯一的思路就是证明我们的背包是下凸的。

首先 $|2x-k|$ 本身就是个下凸的函数，因为凸函数加凸函数还是凸函数，所以我们如果假设 $f_{u,x}$ 与 $f_{v,x}$ 是凸函数，那么 $f_{u,x}$ 和 $f_{v,x}+|2x-k|$ 这两个凸函数做完 $(\min,+)$ 卷积后一定还是凸函数，所以凸性是可以归纳说明的。

对下凸的函数做 $(\min,+)$ 卷积相当于归并两个递增的差分数组，这是经典的结论。我们先考虑加上 $|2x-k|$ 会对 $f_{v,x}$ 的差分数组产生什么影响，设 $d$ 是 $|2x-k|$ 的差分数组：

- 当 $1\le i\le\lfloor\frac{k}{2}\rfloor$ 时，有 $d_i=-2$。

- 当 $i>\lceil\frac{k}{2}\rceil$ 时，有 $d_i=2$。

- 如果 $k$ 为奇数，那么 $d_{\lceil\frac{k}{2}\rceil}=0$。

所以加上 $|2x-k|$ 对 $f_{v,x}$ 的影响就形如一段前缀减 $2$ 和后缀加 $2$。

考虑使用平衡树维护每个结点背包的差分数组，合并儿子 $v$ 时按照上述分析修改它的差分，然后再使用 dsu on tree 的方式插入进来即可，时间复杂度 $O(n\log^2 n)$，卡卡常就过了。

事实上因为每次对差分数组修改的范围比较固定，我们使用可并对顶堆维护可以做到 $O(n\log n)$，但是我不太会所以没写。


```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i, a, b) for(int i = (a); i <= (b); i++)
#define Rof(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 1e6 + 5;
char BUF[1 << 21], *P1 = BUF, *P2 = BUF;
#define getchar() (P1 == P2 && (P2 = (P1 = BUF) + fread(BUF, 1, 1 << 21, stdin), P1 == P2) ? EOF : *P1++)
int read(){
	int x = 0, f = 1; char ch = getchar();
	while(!isdigit(ch)){if(ch == '-') f = -1; ch = getchar();}
	while(isdigit(ch)){x = x * 10 + (ch & 15); ch = getchar();}
	return x * f;
}
struct node{
	int val, tag, sz, key;
}t[N];
int tot, top, ls[N], rs[N], stk[N];
mt19937 nrd(114514);
int newnode(int val){
	int p = top ? stk[top--] : ++tot;
	t[p].val = val; t[p].sz = 1;
	t[p].tag = ls[p] = rs[p] = 0;
	return t[p].key = nrd(), p;
}
void pushup(int now){
	t[now].sz = t[ls[now]].sz + t[rs[now]].sz + 1;
}
void addtag(int now, int w){
	t[now].val += w; t[now].tag += w;
}
void pushdown(int now){
	if(!t[now].tag) return;
	if(ls[now]) addtag(ls[now], t[now].tag);
	if(rs[now]) addtag(rs[now], t[now].tag);
	t[now].tag = 0;
}
void split(int now, int val, int &x, int &y){
	if(!now) return x = y = 0, void();
	pushdown(now);
	if(t[now].val <= val){
		x = now;
		split(rs[now], val, rs[now], y);
	}
	else{
		y = now;
		split(ls[now], val, x, ls[now]);
	}
	pushup(now);
}
void split_sz(int now, int k, int &x, int &y){
	if(!now) return x = y = 0, void();
	pushdown(now);
	if(t[ls[now]].sz + 1 <= k){
		x = now;
		split_sz(rs[now], k - t[ls[now]].sz - 1, rs[now], y);
	}
	else{
		y = now;
		split_sz(ls[now], k, x, ls[now]);
	}
	pushup(now);
}
int merge(int x, int y){
	if(!x || !y) return x | y;
	pushdown(x); pushdown(y);
	if(t[x].key < t[y].key){
		rs[x] = merge(rs[x], y);
		return pushup(x), x;
	}
	else{
		ls[y] = merge(x, ls[y]);
		return pushup(y), y;
	}
}
void insert(int &p, int val){
	int x, y; split(p, val, x, y);
	p = merge(merge(x, newnode(val)), y);
}
void pop_val(int now, vector<int> &rub, bool op = 1){
	if(op) stk[++top] = now;
	pushdown(now);
	if(ls[now]) pop_val(ls[now], rub);
	rub.push_back(t[now].val);
	if(rs[now]) pop_val(rs[now], rub);
}
struct edge{
	int nxt, to;
}e[N];
int n, k, sz[N], son[N], rt[N];
int cnt, head[N];
void add_edge(int u, int v){
	e[++cnt] = {head[u], v}; head[u] = cnt;
	e[++cnt] = {head[v], u}; head[v] = cnt;
}
void dfs(int now, int fa){
	sz[now] = 1;
	for(int i = head[now]; i; i = e[i].nxt){
		int to = e[i].to;
		if(to == fa) continue;
		dfs(to, now); sz[now] += sz[to];
		if(sz[to] > sz[son[now]]) son[now] = to;
		int pl = k / 2, pr = (k + 1) / 2 + 1, x, y;
		split_sz(rt[to], min(sz[to], pl), x, y);
		addtag(x, -2); rt[to] = merge(x, y);
		if(sz[to] >= pr){
			split_sz(rt[to], pr - 1, x, y);
			addtag(y, 2); rt[to] = merge(x, y);
		}
	}
	if(son[now]) rt[now] = rt[son[now]];
	insert(rt[now], 0);
	for(int i = head[now]; i; i = e[i].nxt){
		int to = e[i].to;
		if(to == son[now] || to == fa) continue;
		vector<int> rub; pop_val(rt[to], rub);
		for(int val : rub) insert(rt[now], val);
	}
}
signed main(){
	n = read(), k = read();
	For(i, 1, n - 1){
		int u = read(), v = read();
		add_edge(u, v);
	}
	dfs(1, 0); int ans = (n - 1) * k;
	vector<int> rub; pop_val(rt[1], rub);
	For(i, 0, k - 1) ans += rub[i];
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：_AyachiNene (赞：3)

闵可夫斯基和模板题，双 $\log$ 直接冲过去了。
# 思路：
容易想到一个暴力 dp，设 $f_{i,j}$ 表示在以 $i$ 为根的子树中选了 $j$ 个点的最小答案。转移就是一个书上背包，对于每个 $u$ 的儿子 $v$ 有转移：

$g_{i}=\min_{j+k=i}\{f_{u,j}+f_{v,k}+\left|2k-m\right|\}$

容易发现 $f_u$ 具有凸性，因为每次加上的是个凸函数，且转移是一个 min-add 卷积，想到用闵可夫斯基和优化，考虑维护差分数组。首先考虑如何加上后面的贡献，显然是把 $f_v$ 的前 $\lfloor\frac{k}{2}\rfloor$ 项加上一个一次函数 $-2x+m$，后面加上 $2x-m$。这个看起来不好搞，但要维护的其实是差分数组，直接区间加上斜率 $2$ 或 $-2$，全局加上 $m$ 即可。要把差分数组排序还要做区间加，想到用平衡树。到这里可能会有一个疑问，做了区间加后值域有交怎么办，合并不就要双 $\log$ 了？但是别忘了做以上操作的前提是 $f_u$ 具有凸性，所以操作完还是单调的。最后把 $u$ 和 $v$ 的平衡树合并一下就相当于做了闵可夫斯基和。但这个无论是写平衡树合并还是启发式合并都是 $n\log^2n$，常数小直接过了。太菜了不会单 $\log$。

# Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){x="";char ch=getch();while(!(ch>='a'&&ch<='z')&&!(ch>='A'&&ch<='Z'))ch=getch();while((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);putch(' ');write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
struct node
{
	int nxt,to;
}e[1000005];
int head[500005],cnt_edge;
void add_edge(int u,int v)                              
{
	e[++cnt_edge].to=v;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
int n,m;
namespace Nene
{
	#define pii pair<int,int>
	#define fi first
	#define se second
	struct fhqt
	{
		int l,r,siz,rnd,tag;
		pii key;
	}t[1000005];
	int rt[500005],cnt;
	inline int New(int x){t[++cnt]=(fhqt){0,0,1,rand(),0,{x,cnt}};return cnt;}
	inline void update(int p){t[p].siz=t[t[p].l].siz+t[t[p].r].siz+1;}
	inline void push(int p,int v){if(!p) return;t[p].tag+=v;t[p].key.fi+=v;}
	inline void down(int p)
	{
		if(!t[p].tag) return;
		push(t[p].l,t[p].tag);push(t[p].r,t[p].tag);
		t[p].tag=0;
	}
	void split_k(int p,pii v,int &x,int &y)
	{
		if(!p) return x=y=0,void();
		down(p);
		if(t[p].key<=v) x=p,split_k(t[p].r,v,t[p].r,y);
		else y=p,split_k(t[p].l,v,x,t[p].l);
		update(p);
	}
	void split_s(int p,int v,int &x,int &y)
	{
		if(!p) return x=y=0,void();
		down(p);
		if(t[t[p].l].siz+1<=v) x=p,split_s(t[p].r,v-t[t[p].l].siz-1,t[p].r,y);
		else y=p,split_s(t[p].l,v,x,t[p].l);
		update(p);
	}
	int merge(int x,int y)
	{
		if(!x||!y) return x|y;
		down(x);down(y);
		if(t[x].rnd<t[y].rnd) return t[x].r=merge(t[x].r,y),update(x),x;
		return t[y].l=merge(x,t[y].l),update(y),y;
	}
	int merget(int x,int y)
	{
		if(!x||!y) return x|y;
		down(x);down(y);
		if(t[x].rnd>t[y].rnd) swap(x,y);
		int a,b;
		split_k(y,t[x].key,a,b);
		t[x].l=merget(t[x].l,a);t[x].r=merget(t[x].r,b);
		update(x);return x;
	}
	void print(int p)
	{
		if(!p) return;
		down(p);
		print(t[p].l);
		cout<<t[p].key.fi<<" ";
		print(t[p].r);
	}
}using namespace Nene;
int f[500005];
void dfs(int u,int fa)
{
	rt[u]=merge(rt[u],New(0));
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		int a,b;
		f[v]+=m;
		if(m&1)
		{
			int x,y;
			split_s(rt[v],m/2,a,b);
			push(a,-2);
			split_s(b,1,x,y);
			push(y,2);
			b=merge(x,y);
		}
		else
		{
			split_s(rt[v],m/2,a,b);
			push(a,-2);push(b,2);
		}
		rt[v]=merge(a,b);
		rt[u]=merget(rt[u],rt[v]);
		f[u]+=f[v];	
	}
//	cout<<u<<endl;
//	cout<<f[u]<<" ";print(rt[u]);cout<<endl;
}
int sum=0,c=0;
void calc(int p)
{
	if(!p) return;
	down(p);
	calc(t[p].l);
	if(++c>m) return;
	sum+=t[p].key.fi;
	calc(t[p].r);
}
signed main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	read(n,m);
	for(int i=1;i<n;i++)
	{
		int u,v;read(u,v);
		add_edge(u,v);add_edge(v,u);
	}
	dfs(1,0);
	sum=f[1];calc(rt[1]);
//	cout<<f[1]<<endl;
	write(sum);
	flush();
	return 0;
}
/*
6 5
4 5
2 4
2 1
3 4
1 6
*/
```

---

## 作者：dengchengyu (赞：2)

## P9962 [THUPC 2024 初赛] 一棵树

首先考虑朴素的 DP，设 $f_{i,j}$ 表示 $i$ 子树内选了 $j$ 个黑点。

1. 对于每个点，先把所有儿子合并 $f'_{x,i}=\min_{j\le i}f_{x,i-j}+f_{v,j}$。
2. 考虑自己选不选，$f'_{x,i}=\min (f_{x,i},f_{x,i-1})$。
3. 加上到父亲的边权，$f'_{x,i}\gets f_{x,i}+|2i-k|$。

由于 $|2i-k|$ 是凸的，于是 $f$ 无论何时都是凸的。

因为凸性质，对于合并儿子的部分，可以记录 $f$ 的差分数组与 $f_{x,0}$，则合并就是将差分数组归并。这时就可以用可并堆记录差分数组，合并为 $O(\log n)$。

考虑怎样加边权，对于 $i\le \lfloor k/2\rfloor$ 的部分，每个差分都加上 $-2$；而对于 $i=\lfloor k/2\rfloor+1$，当 $k$ 为奇数时差分不变，否则差分加 $2$；对于 $i>\lfloor k/2 \rfloor+1$ 的部分，每个差分都加上 $2$。

所以把一个堆换成一组对顶堆，保证第一个堆大小不超过 $\lfloor k/2\rfloor$，合并时分别把两个堆合并再调整堆的大小。由于每个点只会往堆里新增一个元素，且每个元素会从第一个堆往第二个堆里移动依次，所以复杂度是 $O(n\log n)$。

最终复杂度 $O(n\log n)$。

代码：

```cpp
const int N=5e5+5;
int n,K;
vi G[N];
int rta[N],rtb[N];
int sz[N],ls[N],rs[N],val[N],tag[N],len[N];
int sum[N];
int tot;
void pushdown(int x) {
	if(tag[x]) {
		val[x]+=tag[x];
		if(ls[x]) tag[ls[x]]+=tag[x];
		if(rs[x]) tag[rs[x]]+=tag[x];
		tag[x]=0;
	}
}
void pushup(int x) {
	sz[x]=sz[ls[x]]+sz[rs[x]]+1;
	if(len[ls[x]]<len[rs[x]]) swap(ls[x],rs[x]);
	len[x]=len[rs[x]]+1;
} 
int mergeA(int x,int y) {
	if(!x||!y) return x|y;
	pushdown(x),pushdown(y);
	if(val[x]<val[y]) swap(x,y);
	rs[x]=mergeA(rs[x],y);
	pushup(x); return x;
}
int mergeB(int x,int y) {
	if(!x||!y) return x|y;
	pushdown(x),pushdown(y);
	if(val[x]>val[y]) swap(x,y);
	rs[x]=mergeB(rs[x],y);
	pushup(x); return x;
}
void dfs(int x,int y) {
	for(int v:G[x]) {
		if(v==y) continue;
		dfs(v,x);
		sum[x]+=sum[v];
		rta[x]=mergeA(rta[x],rta[v]);
		rtb[x]=mergeB(rtb[x],rtb[v]);
	}
	sz[++tot]=1;
	rta[x]=mergeA(rta[x],tot);
	while(sz[rta[x]]>K/2) {
		int t=rta[x]; pushdown(rta[x]),rta[x]=mergeA(ls[rta[x]],rs[rta[x]]);
		sz[t]=1,ls[t]=rs[t]=0;
		rtb[x]=mergeB(rtb[x],t);
	}
	if(x==1) return;
	sum[x]+=K;
	tag[rta[x]]+=-2;
	if(rtb[x]) {
		if(K&1) {
			int t=rtb[x]; pushdown(rtb[x]),rtb[x]=mergeB(ls[rtb[x]],rs[rtb[x]]);
			tag[rtb[x]]+=2;
			sz[t]=1,ls[t]=rs[t]=0;
			rtb[x]=mergeB(rtb[x],t);
		}
		else tag[rtb[x]]+=2;
	} 
}
signed main(){
	read(n,K);
	fu(i,1,n) {
		int u,v; read(u,v);
		G[u].pb(v),G[v].pb(u);
	}
	dfs(1,0);
	while(sz[rta[1]]) {
		int t=rta[1]; pushdown(t), rta[1]=mergeA(ls[rta[1]],rs[rta[1]]);
		sum[1]+=val[t];
	}
	fo(i,1,K-K/2) {
		int t=rtb[1]; pushdown(t), rtb[1]=mergeB(ls[rtb[1]],rs[rtb[1]]);
		sum[1]+=val[t];
	}
	write(sum[1]);
	return 0;
}
```

---

## 作者：yyyx_ (赞：2)

闵可夫斯基和好题，做完之后有了更深的理解。

题意不再赘述。

---

容易想出：令 $f_{x,i}$ 表示结点 $x$ 为根的子树中有 $i$ 个黑点的所有边的最小权值和，对于每个 $i(0\le i \le k)$ 转移有：

$$f_{x,i} = \min_{y\in son(x)}\min_{j\le i}^{j = 0} (f_{x,i-j}+f_{y,j}+\left | k-2j \right | ) (i\le k)$$

以上转移钦定结点 $x$ 不为黑点。

$$f_{x,i} \gets \min\{f_{x,i}, f_{x,i-1}\}$$

最后做一遍以上操作即可。视 $n,k$ 等阶，时间复杂度为 $O(n^3)$。

---

如何改进？观察到 $f$ 和绝对值都具有凸性，并且抛去绝对值的转移类似一个 $\min$ 卷积，考虑把转移拆开来分别操作，再类似于闵可夫斯基和一样做合并。

那么令 $f_{x,i}$ 表示结点 $x$ 为根的子树中有 $i$ 个黑点的所有边，**以及的结点 $x$ 向上的一条边**的最小权值和，转移可以变成：

$$f_{x,i} = \min_{y\in son(x)}\min_{j\le i}^{j = 0} (f_{x,i-j}+f_{y,j}) (i\le k)\texttt{ (1)}$$

以上转移钦定结点 $x$ 不为黑点。

$$f_{x,i} \gets \min\{f_{x,i}, f_{x,i-1}\}\texttt{ (2)}$$ 

最后处理绝对值：

$$f_{x,i} \gets f_{x,i} + \left | k-2i \right | \texttt{ (3)}$$

对于 $\texttt{(1)}$，形式显然是一个 $\min$ 卷积。令 $g_{x,i}=f_{x,i}-f_{x,i-1}$。用一个平衡树维护 $g$ 数组的第二维，那子树转移（做闵可夫斯基和）就变成了平衡树合并。注意这里值域是可能有交的，还没学习过平衡树有交合并的可以看[我的题解（做法及时间复杂度证明）](https://www.luogu.com.cn/article/zqh3t1up)。

对于 $\texttt{(2)}$，在做闵可夫斯基和的过程中就贪心掉了（相当于与一个空元素合并）。

对于 $\texttt{(3)}$，将贡献函数（绝对值函数）的值差分。将平衡树按下标分裂，具体的：

- 首项 $+k$，这是必要的，也可以在最后输出时候加上。
- 若 $2|k$
  - 对于 $[1,\frac{k}{2}]$，区间 $-2$。（平衡树维护了差分数组，对第 $i$ 个位置前缀和后变动值为 $-2i$）
  - 对于 $[\frac{k}{2} + 1,k]$，区间 $+2$。（平衡树维护了差分数组，对第 $i$ 个位置前缀和后变动值为 $2i$）
- 若 $2\not|k$
  - 对于 $[1,\lfloor\frac{k}{2}\rfloor]$，区间 $-2$。
  - 对于 $\lceil\frac{k}{2}\rceil$，不变。
  - 对于 $[\lceil\frac{k}{2}\rceil + 1,k]$，区间 $+2$。

最后做一遍前缀和即可。

我这里实现是 $O(n \log^2 n)$ 的，瓶颈在平衡树有交合并，但实测常数非常小，跑过了好多单 $\log$ 做法。

## $\texttt{Code}$


```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
inline void read(T &x)
{
    x = 0;
    char c = getchar();
    bool f = false;
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = true;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    f ? (x = -x) : 0;
}

template <typename T, typename... Args>
inline void read(T &x, Args &...temps)
{
    read(x), read(temps...);
}

#define de(x) cerr << '[' << #x << ' ' << '=' << ' ' << x << ']' << ' '
#define ed() cerr << endl
const int N = 5e5 + 5;
typedef long long ll;

unsigned seed = 1;
inline unsigned rd()
{
    seed *= 9999991;
    return seed;
}

struct node
{
    int l, r, siz;
    ll val, sum;
    unsigned key;
    ll add;
} a[N << 2];

struct BalanceTree
{
    int rt, tot;
    inline void build() { rt = tot = 0; }
    inline int new_node(ll val)
    {
        ++tot;
        a[tot].val = val;
        a[tot].sum = val;
        a[tot].key = rd();
        return tot;
    }
    inline void push_up(int p)
    {
        a[p].siz = a[a[p].l].siz + a[a[p].r].siz + 1;
        a[p].sum = a[a[p].l].sum + a[a[p].r].sum + a[p].val;
    }
    inline void Add(int p, ll w)
    {
        a[p].sum += w * a[p].siz;
        a[p].val += w;
        a[p].add += w;
    }
    inline void push_down(int p)
    {
        if (a[p].add)
        {
            Add(a[p].l, a[p].add);
            Add(a[p].r, a[p].add);
            a[p].add = 0;
        }
    }
    inline void split(int p, ll val, int &x, int &y)
    {
        if (!p)
            x = y = 0;
        else
        {
            push_down(p);
            if (a[p].val <= val)
            {
                x = p;
                split(a[p].r, val, a[p].r, y);
            }
            else
            {
                y = p;
                split(a[p].l, val, x, a[p].l);
            }
            push_up(p);
        }
    }
    inline void split_siz(int p, int siz, int &x, int &y)
    {
        if (!p)
            x = y = 0;
        else
        {
            push_down(p);
            if (a[a[p].l].siz < siz)
            {
                x = p;
                split_siz(a[p].r, siz - a[a[p].l].siz - 1, a[p].r, y);
            }
            else
            {
                y = p;
                split_siz(a[p].l, siz, x, a[p].l);
            }
            push_up(p);
        }
    }
    inline int merge(int x, int y)
    {
        if (!x || !y)
            return x | y;
        if (a[x].key > a[y].key)
        {
            push_down(x);
            a[x].r = merge(a[x].r, y);
            push_up(x);
            return x;
        }
        else
        {
            push_down(y);
            a[y].l = merge(x, a[y].l);
            push_up(y);
            return y;
        }
    }
    inline ll Min(int x)
    {
        while (a[x].l)
            push_down(x), x = a[x].l;
        return a[x].val;
    }
    inline void swp(ll &x, ll &y)
    {
        x ^= y ^= x ^= y;
    }
    inline void swp(int &x, int &y)
    {
        x ^= y ^= x ^= y;
    }
    inline int Merge(int x, int y)
    {
        int z = 0;
        while (x && y)
        {
            ll wx = Min(x), wy = Min(y);
            if (wx > wy)
                swp(wx, wy), swp(x, y);
            int w = 0;
            split(x, wy, w, x);
            z = merge(z, w);
        }
        return merge(merge(z, x), y);
    }
} bt;

int n, k;
vector<int> g[N];

int dfs(int x, int fa)
{
    int rt = bt.new_node(0);
    for (int y : g[x])
    {
        if (y == fa)
            continue;
        rt = bt.Merge(rt, dfs(y, x));
    }
    if (k & 1)
    {
        int x = 0, y = 0;
        bt.split_siz(rt, k >> 1, x, rt);
        bt.split_siz(rt, 1, rt, y);
        bt.Add(x, -2);
        bt.Add(y, 2);
        rt = bt.merge(bt.merge(x, rt), y);
    }
    else
    {
        int x = 0, y = 0;
        bt.split_siz(rt, k >> 1, x, y);
        bt.Add(x, -2);
        bt.Add(y, 2);
        rt = bt.merge(x, y);
    }
    return rt;
}

ll cal(int rt)
{
    int x = 0, y = 0;
    bt.split_siz(rt, k, x, y);
    ll res = a[x].sum;
    rt = bt.merge(x, y);
    return res;
}

signed main()
{
    read(n, k);
    bt.build();
    for (int i = 1, x, y; i < n; i++)
    {
        read(x, y);
        g[x].emplace_back(y);
        g[y].emplace_back(x);
    }
    printf("%lld\n", cal(dfs(1, 1)) + 1ll * (n - 1) * k);

    return 0;
}
```

---

## 作者：xiaosi4081 (赞：2)

考虑一个树形 dp：设 $f_{u, j}$ 表示 $u$ 子树内有 $j$ 个黑点时的最小代价。

考虑加入 $v$ 这一棵子树，$v$ 是 $u$ 的儿子。那么显然我们可以树上背包转移：$f_{u, j} = \min_{i \leq j} f_{v, i}+f_{u, j-i}$。

然后计算 $u$ 子树的贡献，$f_{u, i} \leftarrow f_{u, i}+|2i-k|$。

如果把 $i$ 看成横坐标，$f_{u, i}$ 看成纵坐标，那就变成给一个函数加上一个凸函数 $g(x) = |2x-k|$。

然后由于贡献是凸函数，猜想 dp 数组是凸函数。

维护差分，背包部分的转移就是直接归并差分数组，贡献部分就是给差分数组的前 $\lfloor \frac k2\rfloor$ 个位置减去 $k$，给差分数组的后 $\lfloor \frac k2\rfloor$ 个位置加上 $k$。

然后每个节点维护对顶堆，启发式合并即可。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e5+5;
template<typename T>
struct heap{
	int v;
	priority_queue<int, vector<int>, T> q;
	void pop(){ q.pop(); }
	int top(){ return q.top()+v; }
	void add(int x){ v += x; }
	void push(int x){ q.push(x-v); }
	int size(){ return q.size(); }
};
heap<less<int> > q1[N], t1;
heap<greater<int> > q2[N], t2;
int n, k;
vector<int> g[N];
void merge(int a, int b){
	if(q1[a].size()+q2[a].size() > q1[b].size()+q2[b].size()) swap(q1[a], q1[b]), swap(q2[a], q2[b]);
	while(q1[a].size()) q1[b].push(q1[a].top()), q1[a].pop();
	while(q2[a].size()) q1[b].push(q2[a].top()), q2[a].pop();
}
int c[N], siz[N];
void dfs(int u, int fa){
	q1[u].push(0); siz[u] = 1;
	for(auto v:g[u]){
		if(v == fa) continue;
		dfs(v, u);
		siz[u] += siz[v];
		merge(v, u);
	}
	while(q1[u].size() > (k/2)) q2[u].push(q1[u].top()), q1[u].pop(); 
	if(!fa) return;
	q1[u].add(-2);	
	if((k&1) && q2[u].size()){
		int x = q2[u].top(); q2[u].pop();
		q2[u].push(x-2);
	} 
	q2[u].add(2);
}
signed main(){
	cin >> n >> k;
	for(int i = 1; i < n; i++){
		int u, v; cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, 0);
	int res = 0, cnt = q1[1].size();
	while(q1[1].size()) c[q1[1].size()] = q1[1].top(), q1[1].pop();
	while(q2[1].size()) c[++cnt] = q2[1].top(), q2[1].pop();
	for(int i = 1; i <= k; i++) res += c[i];
	cout << res+k*(n-1) << endl;
	return 0;
} 
```

---

## 作者：lzytag (赞：1)

来点魔怔做法。

首先根据官方题解的思路，考虑树上背包，$f_{i,j}$ 代表 $i$ 的子树内，选了 $j$ 个黑点的最小权值，转移就相当于先把所有儿子的背包合并起来然后再给每一位加上 $|k-2j|$。

发现这个东西具有下凸性，可以通过归纳法证明，那么我们就可以用带懒标记的可合并的堆维护凸包的斜率，具体的操作为，对每个结点先往堆里加入一个 $0$，然后把所有儿子的堆也合并进来，然后前 $\lfloor\frac{k}{2}\rfloor$ 小的斜率减 $2$，如果 $k$ 为奇数，那么第 $\frac{k+1}{2}$ 斜率不变，剩下的斜率全部加 $2$。

写左偏树维护前 $\lfloor\frac{k}{2}\rfloor$ 个数应该就做完了，但是通过观察这个操作的性质，我们可以找到更优秀的做法。我们发现最后根节点的堆里面的每个数都是由在某个节点加入的 $0$ 转变而来，那我们就可以反过来考虑各个节点加入的 $0$ 都会经历怎样的操作。

发现一个点被弹出堆的位置就是最近的子树中有 $\lfloor\frac{k}{2}\rfloor$ 个节点深度比他大的祖先，于是我们可以按深度从小到大将节点排序，然后依次删除，同时找到第一个子树中还剩 $\lfloor\frac{k}{2}\rfloor$ 以上个节点未被删的祖先，用 dfn 序和树状数组维护子树内未被删节点个数，再用并查集维护最近满足条件的节点即可。如果 $k$ 为偶数，那么就可以直接求出这个 $0$ 到根节点时的值。若 $k$ 为奇数，那么再 dfs 一遍，每个点上维护已经被弹出的节点中的最小值即可。最后到根节点再用 $k\times(n-1)$ 减去最小的 $k$ 个斜率即可。

细节可以看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
int n,k;
vector<int>vec[N];
int dep[N],f[N],fa[N],id[N],ed[N],dfn[N],dfcnt;
vector<int>e[N];
void dfs(int u)
{
    dep[u] = dep[f[u]] + 1;
    dfn[u] = ++dfcnt;
    for(auto v:e[u]) if(v != f[u])
    {
        f[v] = u;
        dfs(v);
    }
    ed[u] = dfcnt;
}
bool cmp(int i,int j){return dep[i] < dep[j];}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int tr[N];
int lowbit(int c){return c & (-c);}
void upd(int c,int x){for(;c <= n;c += lowbit(c)) tr[c] += x;}
int qry(int c){int Res = 0;for(;c;c -= lowbit(c)) Res += tr[c];return Res;}
vector<int>res;
int mn[N];
void dfs1(int u)
{
    mn[u] = 1;
    for(auto x:vec[u])
    {
        if(x < mn[u])
        {
            if(mn[u] != 1) res.push_back(mn[u]+2*(dep[u]-1));
            mn[u] = x;
        }
        else
        {
            res.push_back(x+2*(dep[u]-1));
        }
    }
    for(auto v:e[u]) if(v != f[u])
    {
        dfs1(v);
        if(mn[v] == 1) continue;
        int x = mn[v];
        if(x < mn[u])
        {
            if(mn[u] != 1) res.push_back(mn[u]+2*(dep[u]-1));
            mn[u] = x;
        }
        else
        {
            res.push_back(x+2*(dep[u]-1));
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(0);
    cin>>n>>k;
    for(int i = 1;i <= n;i++) id[i] = i;
    for(int i = 1,u,v;i < n;i++)
    {
        cin>>u>>v;
        e[u].push_back(v),e[v].push_back(u);
    }
    dfs(1);
    sort(id+1,id+1+n,cmp);
    for(int i = 1;i <= n;i++) upd(i,1),fa[i] = i;
    for(int i = 1;i <= n;i++)
    {
        int u = id[i];
        u = find(u);
        //if(u%10000 == 0) cerr<<"!"<<u<<"\n";
        while(u != 1)
        {
            if(qry(ed[u]) - qry(dfn[u]-1) > k/2) break;
            fa[u] = f[u];
            u = find(u);
        }
        upd(dfn[u],-1);
        vec[u].push_back(-2*(dep[id[i]]-dep[u]));
    }
    if(k%2 == 0)
    {
        for(int i = 1;i <= n;i++) for(auto x:vec[i]) res.push_back(x+2*(dep[i]-1));
        sort(res.begin(),res.end());
        ll ans = 1ll*(n-1)*k;
        for(int i = 0;i < k;i++) ans += res[i];
        cout<<ans<<"\n";
        return 0;
    }
    ll ans = 1ll*(n-1)*k;
    dfs1(1);
    res.push_back(mn[1]);
    sort(res.begin(),res.end());
    for(int i = 0;i < k;i++) ans += res[i];
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：OldDriverTree (赞：1)

# Solution

套路题，不难想到一个 $O(n^2)$ 的暴力做法：

树上背包，设 $f_{u,x}$ 表示 $u$ 的子树中，选了 $x$ 个点的答案。

转移就是 $f_{u,x}+f_{v,y}+\vert 2x-k\vert\to f'_{u,x+y}$。

考虑如何优化。

首先可以归纳证明 $f_u$ 是关于 $x$ 的下凸函数：由于 $\vert 2x-k\vert$ 是一个下凸的函数的，且两个凸函数的和也是凸函数，两个下凸函数的 $(\min,+)$ 卷积也是下凸函数（因为对两个凸函数进行 $(\min,+)$ 卷积就是闵可夫斯基和，可以直接把两个单调递增的差分数组归并起来，于是新函数的差分数组也是单调递增的），所以 $f_u$ 是关于 $x$ 的下凸函数。

知道这个性质后，我们考虑闵可夫斯基和，对于 $f_u$ 维护它的差分数组，转移就是把 $f_v$ 的差分数组的一个前缀加上 $-2$，一个后缀加上 $2$，然后再把 $f_u$ 和 $f_v$ 放在一起归并。

直接归并时间复杂度显然还是 $O(n^2)$ 的，然后有两种做法可以优化归并的时间复杂度，一种对差分数组维护一棵平衡树，归并操作直接用启发式合并即可，用 $\text{Splay}$ 好像是 $O(n\log n)$ 的，用其他平衡树是 $O(n\log^2 n)$ 的，但是好像卡下常也能过（

另一种做法是注意到每次减二和加二的前缀和后缀的位置都是相同的，于是用可并对顶堆维护，对于每个节点用来两棵左偏树来维护这两个堆，一个大根堆维护前 $\lfloor\dfrac k2\rfloor$ 小的，另一个小根堆维护剩下的，对于加二和减二操作直接打个 $\text{tag}$，对于归并操作，先把每个子节点的大根堆都合并在一起，小根堆也都合并在一起，此时小根堆中的数排名显然都是大于 $\lfloor\dfrac k2\rfloor$ 的，于是直接把大根堆中多的数都直接弹出来，放到小根堆里即可，时间复杂度也是 $O(n\log n)$。

因为我不会 $\text{Splay}$，所以写的是可并对顶堆做法（

# Code

注意下面小根堆中的数都取反了

```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
const int N=5e5+1;
int n,m,f[N],g[N];
vector<int> G[N];

struct custom_hash
{
	static uint64_t splitmix64(uint64_t x) {
		x+=0x9e3779b97f4a7c15;
		x=(x^(x>>30) )*0xbf58476d1ce4e5b9;
		x=(x^(x>>27) )*0x94d049bb133111eb;
		return x^(x>>31);
	}
	size_t operator() (uint64_t x) const {
		static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x+FIXED_RANDOM);
	}
};
int read() {
	int x=0; bool f=true; char c=0;
	while (!isdigit(c) ) f&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return f?x:-x;
}
struct node {
	int ls,rs,dis,siz,val,tag;
	void add(int x) { val+=x,tag+=x; }
}T[N];

void pushdown(int rt) {
	T[T[rt].ls].add(T[rt].tag);
	T[T[rt].rs].add(T[rt].tag);
	T[rt].tag=0;
}
int merge(int x,int y) {
	if (!x||!y) return x|y;
	if (T[x].val<T[y].val) swap(x,y);
	pushdown(x),T[x].rs=merge(T[x].rs,y);
	if (T[T[x].ls].dis<T[T[x].rs].dis) swap(T[x].ls,T[x].rs);
	T[x].dis=T[T[x].rs].dis+1,T[x].siz=T[T[x].ls].siz+T[T[x].rs].siz+1;
	return x;
}
int pop(int &rt) {
	int pos=rt; pushdown(rt),rt=merge(T[rt].ls,T[rt].rs);
	return T[pos].ls=T[pos].rs=T[pos].dis=0,T[pos].siz=1,pos;
}
void dfs(int u,int fa)
{
	for (int v:G[u]) if (v^fa) {
		dfs(v,u),T[f[v] ].add(-2);
		if (m&1&&g[v]) { int t=pop(g[v]); T[g[v] ].add(-2),g[v]=merge(g[v],t); } 
		else T[g[v] ].add(-2); f[u]=merge(f[u],f[v]),g[u]=merge(g[u],g[v]);
	}
	while (T[f[u] ].siz>m/2) {
		int x=pop(f[u]); T[x].val*=-1;
		g[u]=merge(g[u],pop(x) );
	}
}
main()
{
	n=read(),m=read(),T[0].dis=-1;
	for (int i=1;i<n;i++) {
		int x=read(),y=read();
		G[x].push_back(y),G[y].push_back(x);
	}
	for (int i=1;i<=n;i++) T[i].siz=1,f[i]=i;
	dfs(1,0); int ans=(n-1)*m;
	for (int i=1;i<=m;i++) {
		if (f[1]) ans+=T[pop(f[1])].val;
		else ans-=T[pop(g[1])].val;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：win114514 (赞：1)

提供一个赛时暴力想法。

### 思路

考虑一个暴力的 $\text{dp}$ 做法。

每个点记 $dp_{i,j}$ 表示在 $i$ 子树下，选了 $j$ 个点的最小代价是多少。

转移比较显然：

$$dp_{i,j}=\min_{s_k\in son(i),\sum_{a_k=j}}\sum dp_{s_k,a_k}+|m-2\times j|$$

从式子入手，我们发现每一次选择一个点就相当于给到根的所有边权全部减二。

然后最后的代价就是所有边权的绝对值之和。

可以猜出一个结论：每一次选择改动后边权的绝对值减的最多的那一个点。

这个其实可以比较简单的感性理解。

那么我们现在就变成了一个树上的维护信息题目。

考虑绝对值的变化有三种情况。

1. $a>1$，那么 $a$ 减二后绝对值也减二。

2. $a=1$，那么 $a$ 减二后绝对值不变。

3. $a\le 0$，那么 $a$ 减二后绝对值加二。

我们可以进行树剖，每一次利用线段树找到边权为 $1$，为 $2$，为 $3$ 的边。

并进行区间减操作。

然后可以再开一棵线段树，维护选择每个点的贡献。

只需要支持子树加即可。

复杂度：$O(q\log^2 n+n\log n)$。

如果用全局平衡二叉树就是：$O(q\log n+n\log n)$。

当然在赛时此题把这个做法卡常卡的稀碎。

全局平衡二叉树因为常数过大还跑不过树剖。

赛时卡常卡了两个小时，利用了各种优化才卡过。

赛后发现只需要随机一个根就可以过了。

成小丑了。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define x first
#define y second
#define mp(x, y) make_pair(x, y)
#define eb(...) emplace_back(__VA_ARGS__)
#define fro(i, x, y) for(int i = (x);i <= (y);i++)
#define pre(i, x, y) for(int i = (x);i >= (y);i--)
#define dbg cerr << "Line " << __LINE__ << ": "
#define EVAL(x) #x " = " << (x)

typedef int64_t i64;
typedef uint32_t u32;
typedef uint64_t u64;
typedef __int128_t i128;
typedef __uint128_t u128;
typedef pair<int, int> PII;

bool ED;

const int N = 1000010;
const int mod = 998244353;

int n, m;
int rt, tot, id[N], dfn[N];
int fa[N], dep[N], top[N], siz[N], son[N];
vector<int> to[N];
vector<int> last0, last1;

inline void dfs1(int now)
{
	siz[now] = 1;
	dep[now] = dep[fa[now]] + 1;
	for(auto i : to[now])
	{
		if(i == fa[now]) continue;
		fa[i] = now;
		dfs1(i);
		siz[now] += siz[i];
		if(siz[i] > siz[son[now]])
			son[now] = i;
	}
}
inline void dfs2(int now, int tp)
{
	top[now] = tp;
	id[dfn[now] = ++tot] = now;
	if(son[now]) dfs2(son[now], tp);
	for(auto i : to[now])
	{
		if(i == fa[now] || i == son[now])
			continue;
		dfs2(i, i);
	}
}
namespace Tree1
{
	int mi[N], tg[N];
	inline void push(int p, int x = 1)
		{ tg[p] += x, mi[p] -= 2 * x; }
	inline void pdo(int p, int mid)
		{ if(tg[p]) push(mid<<1, tg[p]), push(mid<<1|1, tg[p]), tg[p] = 0; }
	inline void pup(int p, int mid)
		{ mi[p] = min(mi[mid<<1], mi[mid<<1|1]); }
	inline void build(int p, int l, int r)
	{
		if(l == r)
			return mi[p] = m, void();
		int mid = (l + r) >> 1;
		build(mid<<1, l, mid);
		build(mid<<1|1, mid + 1, r);
		pup(p, mid);
	}
	inline void upd(int p, int l, int r, int ls, int rs)
	{
		if(l == r)
		{
			if(mi[p] == 1) last1.eb(id[l]);
			if(mi[p] == 2) last0.eb(id[l]);
			if(mi[p] == 3) last1.eb(id[l]);
			mi[p] -= 2;
			if(mi[p] <= 0) mi[p] = 1e9;
			return;
		}
		int mid = (l + r) >> 1; pdo(p, mid);
		if(ls <= l && r <= rs)
		{
			if(mi[p] <= 3)
			{
					upd(mid<<1, l, mid, ls, rs);
					upd(mid<<1|1, mid + 1, r, ls, rs);
			}
			else push(p);
			return;
		}
		if(mid >= ls) upd(mid<<1, l, mid, ls, rs);
		if(mid <  rs) upd(mid<<1|1, mid + 1, r, ls, rs);
		pup(p, mid);
	}
}
namespace Tree2
{
	int val[N], tag[N];
	inline void push(int p, int x)
		{ tag[p] += x, val[p] += x; }
	inline void pdo(int p, int mid)
		{ if(tag[p]) push(mid<<1, tag[p]), push(mid<<1|1, tag[p]), tag[p] = 0; }
	inline void pup(int p, int mid)
		{ val[p] = max(val[mid<<1], val[mid<<1|1]); }
	inline void build(int p, int l, int r)
	{
		if(l == r)
			return val[p] = (dep[id[l]] - 1) * (m != 1 ? 2 : 0), void();
		int mid = (l + r) >> 1;
		build(mid<<1, l, mid);
		build(mid<<1|1, mid + 1, r);
		pup(p, mid);
	}
	inline void upd(int p, int l, int r, int ls, int rs, int k)
	{
		if(ls <= l && r <= rs) return push(p, k);
		int mid = (l + r) >> 1; pdo(p, mid);
		if(mid >= ls) upd(mid<<1, l, mid, ls, rs, k);
		if(mid <  rs) upd(mid<<1|1, mid + 1, r, ls, rs, k);
		pup(p, mid);
	}
	inline int upd(int p, int l, int r)
	{
		if(l == r) return val[p] = -1e9, id[l];
		int mid = (l + r) >> 1, res = 0; pdo(p, mid);
		if(val[mid<<1] == val[p])
			res = upd(mid<<1, l, mid);
		else
			res = upd(mid<<1|1, mid + 1, r);
		return pup(p, mid), res;
	}
	inline PII ask()
	{
		int res = val[1];
		return {upd(1, 1, n), res};
	}
}
inline void solve()
{
	cin >> n >> m;
	srand(random_device{}());
	rt = rand() % n + 1;
	fro(i, 1, n - 1)
	{
		int x, y;
		cin >> x >> y;
		to[x].eb(y);
		to[y].eb(x);
	}
	dfs1(rt), dfs2(rt, rt);
	Tree1::build(1, 1, n);
	Tree2::build(1, 1, n);
	i64 ans = 1ll * (n - 1) * m;
	fro(i, 1, m)
	{
		auto [x, y] = Tree2::ask();
		ans -= y;
		while(x)
		{
			int l = dfn[top[x]], r = dfn[x]; 
			Tree1::upd(1, 1, n, max(l, 2), r), x = fa[top[x]];
		}
		for(auto i : last0)
			Tree2::upd(1, 1, n, dfn[i], dfn[i] + siz[i] - 1, -4);
		last0.clear();
		for(auto i : last1)
			Tree2::upd(1, 1, n, dfn[i], dfn[i] + siz[i] - 1, -2);
		last1.clear();
	}
	cout << ans << "\n";
}

bool ST;

signed main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	double Mib = fabs((&ED-&ST)/1048576.), Lim = 125;
	cerr << " Memory: " << Mib << "\n", assert(Mib<=Lim);
	solve();
	return 0;
}
```

---

## 作者：AC_Lover (赞：1)

闵和好题。

首先介绍一下**闵和（闵可夫斯基和）**。

两个凸包的闵和可以看做是把一个凸包的顶点不断换成另一个凸包顶点后最外层组成的凸多边形，这里不详细展开，主要分析下凸壳时的情况。

闵和主要是用来优化 $\left(\min,+\right)$ 卷积的一个方法，有重要性质：

**两个下凸壳的 $\left(\min,+\right)$ 卷积依然是一个下凸壳。**

假设要把下凸壳 $f,g$ 做 $\left(\min,+\right)$ 卷积，即要计算

$$
h_i=\min_{j+k=i}\set {f_j+g_k}
$$

那么此时

**$h$ 的差分数组就是 $f,g$ 差分数组的归并。**

有这个重要性质，就可以考虑用平衡树等数据结构快速维护凸壳的差分数组。

---

回到此题，显然可以使用一个 $\mathrm{dp}$，定义 $f_{u,i}$ 表示考虑 $u$ 为根的子树内，染了 $i$ 个黑点时的最小代价，类比树形背包，得到转移：

$$
f_{u,i}\leftarrow \min_{j+k=i}\set{f_{u,j}+f_{v,k}}
$$

然后要加上代价，考虑 $\mathrm{fa}_u\to u$ 这条边，上面有 $K-i$ 个，下面有 $i$ 个，于是差为 $|K-i-i|=|K-2i|$，于是

$$
f_{u,i}\leftarrow f_{u,i}+|K-2i|
$$

初值 $f_{u,0}=f_{u,1}=0$，最终目标：$f_{1,k}$

直接做背包时间和空间都不能接受，但是观察式子：

$$
\min_{j+k=i}\set{f_{u,j}+f_{v,k}}
$$

于是考虑使用刚刚提到的闵和优化一下，很明显，此时 $f_u$ 是 $f_u$ 和 $f_v$ 进行 $(\min,+)$ 卷积得到的，如果我们维护 $f_u,f_v$ 的差分数组，即维护第 $i$ 个位置为 $f^{\prime}_i$ 到 $f^{\prime}_{i-1}$ 的差分，那么如果支持快速进行归并，即在值域上进行合并，那么就可以得出 $f_u$ 的差分数组。而对于最后的 $|K-2i|$，这是绝对值函数，分类讨论一下

记 $m=\lfloor\frac{K}{2}\rfloor$

- $K$ 为偶数

  那么当 $i\le m$ 时贡献为 $K-2i$，是一个斜率为 $-2$ 的一次函数，对应在差分数组上相当于 $-2$。当 $i>m$ 时贡献为 $2i-K$，是一个斜率为 $2$ 的一次函数，同理相当于差分 $+2$

- $K$ 为奇数

  那么当 $i\le m$ 时贡献为 $K-2i$，分析同上。当 $i=m+1$ 时，注意到 $|K-2(i-1)|=|K-2i|$，所以此时斜率变化为 $0$，不用管。而当 $i>m+1$ 时贡献为 $2i-K$，分析同上。

于是我们相当于要用一个数据结构维护差分数组，其支持值域上合并，区间加上一个数。很明显使用平衡树即可。其值域上合并的复杂度为 $O(\log^2 n)$，区间加可以打 $\mathrm{tag}$，于是就可以在 $O(n\log^2 n)$ 的时间内求解出 $f$ 的差分数组。

那么求答案也是简单的。考虑到我们已经求出了差分数组，只要知道 $f_{1,0}$，那么代入差分数组推下去就可以得到 $f_{1,k}$，$f_{1,0}$ 在原来的 $\mathrm{dp}$ 中很明显值为 $(n-1)k$，于是从前往后加上差分数组就做完了。

代码：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <random>
#include <ctime>

using namespace std;

const int N=500010;
typedef long long ll;
int n,k;
int h[N],e[N<<1],ne[N<<1],idx;

void adde(int u,int v) { e[idx]=v,ne[idx]=h[u],h[u]=idx++; }

mt19937 rnd(time(0));

namespace FHQ
{
	const int M=N*2;
	ll val[M],add[M];
	int pri[M],ch[M][2],sz[M],root[N],idx;
	
	inline int new_node(ll v)
	{
		int u=++idx;
		val[u]=v;
		pri[u]=rnd();
		sz[u]=1;
		return u;
	}
	
	inline void pushup(int u) { sz[u]=sz[ch[u][0]]+sz[ch[u][1]]+1; }
	
	inline void Add(int u,ll d)
	{
		add[u]+=d;
		val[u]+=d;
	}
	
	inline void pushdown(int u)
	{
		if (add[u])
		{
			Add(ch[u][0],add[u]);
			Add(ch[u][1],add[u]);
			add[u]=0;
		}
	}
	
	void split(int rt,ll k,int &rt1,int &rt2)
	{
		if (!rt)
		{
			rt1=rt2=0;
			return;
		}
		pushdown(rt);
		if (val[rt]<=k)
		{
			rt1=rt;
			split(ch[rt][1],k,ch[rt][1],rt2);
		}
		else
		{
			rt2=rt;
			split(ch[rt][0],k,rt1,ch[rt][0]);
		}
		pushup(rt);
	}
	
	void cntsplit(int rt,int k,int &rt1,int &rt2)
	{
		if (!rt)
		{
			rt1=rt2=0;
			return;
		}
		pushdown(rt);
		if (sz[ch[rt][0]]+1<=k)
		{
			rt1=rt;
			cntsplit(ch[rt][1],k-sz[ch[rt][0]]-1,ch[rt][1],rt2);
		}
		else
		{
			rt2=rt;
			cntsplit(ch[rt][0],k,rt1,ch[rt][0]);
		}
		pushup(rt);
	}
	
	int merge(int rt1,int rt2)
	{
		if (!rt1 || !rt2) return rt1^rt2;
		if (pri[rt1]<pri[rt2])
		{
			pushdown(rt1);
			ch[rt1][1]=merge(ch[rt1][1],rt2);
			pushup(rt1);
			return rt1;
		}
		else
		{
			pushdown(rt2);
			ch[rt2][0]=merge(rt1,ch[rt2][0]);
			pushup(rt2);
			return rt2;
		}
	}
	
	int Merge(int rt1,int rt2)
	{
		if (!rt1 || !rt2) return rt1^rt2;
		if (pri[rt1]>pri[rt2]) swap(rt1,rt2);
		pushdown(rt1);
		int x,y;
		split(rt2,val[rt1],x,y);
		ch[rt1][0]=Merge(ch[rt1][0],x);
		ch[rt1][1]=Merge(ch[rt1][1],y);
		pushup(rt1);
		return rt1;
	}
	
	ll qrys(int u)
	{
		if (!u) return 0;
		pushdown(u);
		return val[u]+qrys(ch[u][0])+qrys(ch[u][1]);
	}
	
	void adj(int u)
	{
		pushdown(u);
		if (ch[u][0]) adj(ch[u][0]);
		if (ch[u][1]) adj(ch[u][1]);
		pushup(u);
	}
	
	void print(int u)
	{
		pushdown(u);
		if (ch[u][0]) print(ch[u][0]);
		cout << val[u] << " ";
		if (ch[u][1]) print(ch[u][1]);
	}
	
	void prt(int rt) { print(rt);cout << "\n"; }
}
using namespace FHQ;

inline void Mrg(int u,int v)
{
	root[u]=Merge(root[u],root[v]);
	if (sz[root[u]]>k)
	{
		int x,y;
		cntsplit(root[u],k,x,y);
		root[u]=x;
	}
}

void dfs(int u,int fa)
{
	root[u]=merge(root[u],new_node(0));
	root[u]=merge(root[u],new_node(1e18));
	
	for (int i=h[u];i!=-1;i=ne[i])
	{
		int v=e[i];
		if (v==fa) continue;
		dfs(v,u);
		
		Mrg(u,v);
	}
	
	// |k-2x|
	
	if (fa!=-1)
	{
		int mid=k/2;
		if (k&1)
		{
			int x,y,z;
			cntsplit(root[u],mid,x,y);
			Add(x,-2);
			if (sz[y]>1)
			{
				cntsplit(y,1,y,z);
				Add(z,2);
				root[u]=merge(merge(x,y),z);
			}
			else root[u]=merge(x,y);
		}
		else
		{
			int x,y;
			cntsplit(root[u],mid,x,y);
			Add(x,-2);
			Add(y,2);
			root[u]=merge(x,y);
		}
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	
	cin >> n >> k;
	memset(h,-1,sizeof(h));
	for (int i=1;i<n;i++)
	{
		int u,v;
		cin >> u >> v;
		adde(u,v);adde(v,u);
	}
	
	dfs(1,-1);
	
	ll res=1ll*(n-1)*k;
	int x,y;
	cntsplit(root[1],k,x,y);
	res+=qrys(x);
	
	cout << res << "\n";
	
	return 0;
}
```

---

## 作者：PeppaPig_qwq (赞：0)

闵可夫斯基和好题。

定义 $sze_x$ 表示 x 的子树大小。

先设 1 为根。定义 $f_{x,i}$ 表示在 $x$ 的子树内，有 $i$ 个黑点，$x$ 子树内所有边（包括 $x$ 往父亲连的边）的权值和的最小值。

边界不说了。转移的话，先令 $f_{x,0} = 0$。然后枚举 $x$ 的每个儿子 $s$，令 $f_{x,i} = \min _j\{f_{x,j} + f_{s,i - j}\}$。如果 x 不是 1，就让 $f_{x,i} + |k - 2i| \to f_{x,i}$，最后让 $f_{x,i} = \min \{f_{x,i},f_{x,i - 1}\}$ 即可。

显然这一串柿子你没看懂。让我来解释一下。$f_{x,i} = \min _j\{f_{x,j} + f_{s,i - j}\}$ 这个式子就是把 $i$ 个黑点分配到了 $s$ 的子树内和子树外。$f_{x,i} + |k - 2i| \to f_{x,i}$ 就是算上 x 往父亲的边的贡献。有 $f_{x,i} = \min \{f_{x,i},f_{x,i - 1}\}$ 这个式子是因为 x 可能也会放黑点。

好了，现在来讲优化。注意到 $|k - 2i|$ 关于 $i$ 是上凸的。所以 $f$ 关于第二维也是上凸的。所以第一个式子可以用闵可夫斯基和优化转移。具体的，用一只平衡树维护 $f$ 关于第二维的差分。使启发式合并，就是 $x$ 继承 $x$ 重儿子的平衡树。然后对于每个轻儿子把这个节点对应的平衡树合并入 $x$ 的平衡树。

对于第二个式子，观察到 $|k - 2i|$ 的差分形如这样 $-2,-2,-2,\cdots,0,\cdots2,2,2$，所以对于前面一段整体加 -2，对于后面一段整体加 2 即可。分段点自己想。

对于第三个式子，给平衡树加入一个 0 即可。

---

## 作者：Richard_Whr (赞：0)

STL优先队列的启发式合并+对顶堆实现。

考虑普通 $\texttt{dp}$：

设 $f_{u,i}$ 表示以 $u$ 为根的子树中，选 $i$ 个黑点的最小代价。 

有比较显然的树形背包转移：

$$f_{u,i}= \min\limits_{j+k=i}\{f_{u,k}+f_{v,j}+|2\times j-K|\}$$

最后决策根节点选不选：

$$f_{u,i}=min\{f_{u,i},f_{u,i-1}\}$$

利用背包大小与子树有关的限制，可以做到 $O(n^2)$

注意到这个转移是一个很像 $(\min,+)$ 卷积的东西，如果是这样可以闵可夫斯基和优化。考虑变成一般的 $(\min,+)$ 卷积的形式。

首先我们改变一下状态定义，将每次在子树合并的时候加到父亲边的贡献这一步在儿子做。提前将这部分代价加到 $\texttt{dp}$ 数组里面。

此时转移方程变为：

$$f_{u,i}= \min\limits_{j+k=i}\{f_{u,k}+f_{v,j}\}$$

根节点选不选决策方程不变，最后加上代价：

$$f_{u,i}=f_{u,i}+|2\times i-K|$$

接着考察 $f_{u}$ 关于 $i$ 的凸性，归纳证明：

在叶子节点的时候：$f_{u,i}=|2\times i-K|$，是凸的。

在非叶子结点的时候，上述转移方程可以抽象为三个操作：

已知初始为空，是凸的。

- 与已证明为凸函数的儿子做 $(\min,+)$ 卷积；

- 向左平移与原来取 $\min$；

- 加上一个绝对值函数（凸）；

容易发现都不会影响凸性。因此可以证明一直是凸的。

考虑维护上述几个操作。

凸函数做 $(\min,+)$ 卷积可以视为差分数组的归并，这个结论就不证了。

平移后取 $\min$ 相当于给中间加了一段斜率为 $0$ 的段，相当于给差分数组加了一个 $0$。

最后加一个绝对值函数。注意它的定义域是整数，值域也是整数。

那么这样对于差分数组的影响大体上是一段 $+2$，一段 $-2$。

具体地，前 $\frac{K}{2}$ 个都 $+2$，之后如果 $K$ 为奇数，$\frac{K}{2}+1$ 会 $+0$，之后的都 $+2$。

最后从 $f_{u,0}=(n-1)\times K$ 倒推答案（可以看成每条边断掉都会产生 $K$ 的代价，或者说每次加绝对值函数的时候给 $0$ 都加了 $K$，但实际没有维护）。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10;
vector<int> e[N];
priority_queue<int> f1[N];
priority_queue<int,vector<int>,greater<int>> f2[N];
int add1[N],add2[N];
int n,m;

int sz(int u)
{
	return f1[u].size()+f2[u].size();
}

void Swap(int u,int v)
{
	swap(f1[u],f1[v]),swap(f2[u],f2[v]);
	swap(add1[u],add1[v]),swap(add2[u],add2[v]);
}

void balance(int u)
{
	while(f1[u].size()>m/2) f2[u].push(f1[u].top()+add1[u]-add2[u]),f1[u].pop();
}

void merge(int u,int v)
{
	if(sz(u)<sz(v)) Swap(u,v);
	while(f1[v].size()) f1[u].push(f1[v].top()+add1[v]-add1[u]),f1[v].pop();
	while(f2[v].size()) f1[u].push(f2[v].top()+add2[v]-add1[u]),f2[v].pop();
	balance(u);
}

void dfs(int u,int fa)
{
	for(auto v:e[u])
	{
		if(v==fa) continue;
		dfs(v,u);
		merge(u,v);
	}	
	f1[u].push(0-add1[u]);
	balance(u);
	if(u!=1)
	{
		add1[u]-=2,add2[u]+=2;
		if(m&1 && f2[u].size()) 
		{
			int x=f2[u].top();f2[u].pop();
			f2[u].push(x-2);
		}
	}
} 

int calc()
{
	int res=(n-1)*m,cur=m;
	while(cur && f1[1].size())
	{
		int x=f1[1].top();f1[1].pop();
		res+=x+add1[1];
		cur--;
	}
	while(cur && f2[1].size())
	{
		int x=f2[1].top();f2[1].pop();
		res+=x+add2[1];
		cur--;
	}
	return res;
}

signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1,a,b;i<n;i++)
	{
		cin>>a>>b;
		e[a].push_back(b),e[b].push_back(a);
	}
	
	dfs(1,0);

	cout<<calc()<<"\n";
	
	return 0;
} 
```

---


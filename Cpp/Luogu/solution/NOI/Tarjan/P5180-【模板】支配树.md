# 【模板】支配树

## 题目背景

模板题，无背景。

## 题目描述

给定一张有向图，求从 $1$ 号点出发，每个点能支配的点的个数（包括自己）。

## 说明/提示

$n\le2\times 10^5$，$m\le3\times 10^5$。

## 样例 #1

### 输入

```
10 15
1 2
2 3
3 4
3 5
3 6
4 7
7 8
7 9
7 10
5 6
6 8
7 8
4 1
3 6
5 3```

### 输出

```
10 9 8 4 1 1 3 1 1 1 ```

# 题解

## 作者：hezlik (赞：55)

**前言.**

写这篇文章主要是因为大部分题解里要么代码实现的时候时间复杂度是假的，要么只是求解半支配点后直接用 DAG 上树上倍增的方法做，这里想写一份复杂度正确的题解与代码。

由于本人水平有限，这里只是大概介绍怎么做，不介绍如何证明。

**支配树概念.**

对于一张有向图，我们确定一个起点 $S$。

对于一个点 $k$，称 $x$ 为其支配点当且仅当，删去点 $x$ 后，$S$ 无法到达 $k$，即 $S$ 到达 $k$ 的所有路径都必须通过 $x$。

容易发现，一个点的支配点不止一个。

同时，也很容易发现，如果我们将一个点 $k$ 与其最近的支配点连边，那么会形成一个树形结构，这个树形结构即支配树。

接下来我们所称的支配点一般指其在支配树上的父亲。

求解支配树的一个优秀做法是 Lengauer-Tarjan 算法，可以做到在 $O(n\alpha(n))$ 或 $O(n\log n)$ 的时间复杂度内求解支配树。

**DAG 上的支配树构造 .**

虽然这部分与 Lengauer-Tarjan 算法并没有什么关系，不过还是介绍一下吧。

首先，显然一个点 $k$ 的支配点是所有能够直接到达 $k$ 的点在支配树上的 LCA。

那么就很简单了，我们按照拓扑序依次做下去，建立反图找到所有能够直接到达当前点的点，倍增求解 LCA 即可。

**Lengauer-Tarjan 算法**

Lengauer-Tarjan 算法的分为三步：
1. 求出 dfs 树，得到每个点 $k$ 的 dfs 序 $d_k$。
2. 求解半支配点。
3. 求解支配点。

**引入半支配点.**

Lengauer-Tarjan 算法的精髓在于引入了半支配点这个概念。

一个点 $k$ 的半支配点是指一个 dfs 序最小的点 $x$，使得 $x$ 可以通过一条路径 $x,x_1,x_2,\cdots,x_c,k$ 到达点 $k$ ，求满足对于任意 $1\leq i\leq c$，有 $d_{x_i}>d_k$。

只要能求出半支配点，就有办法求解支配点，所以我们先来求解半支配点。

对于一个可以直接到达点 $k$ 的点 $x$，有两种可能的情况：
1. 若 $d_x<d_k$，则 $x$ 可能是 $k$ 的半支配点。
2. 若 $d_x>d_k$，则考虑其所有祖先 $u$ 满足 $d_u>d_k$，$u$ 的半支配点可能是点 $k$ 的半支配点。

可以证明这两种情况是充分的。

考虑按照 dfs 序倒序考虑所有点 $k$。枚举所有能够直接到达点 $k$ 的点 $x$，第一种情况可以快速维护，但第二种情况需要考虑其所有祖先，我们不能暴力枚举。

考虑维护一个带权并查集，每次处理完一个点 $k$，我们就将 $k$ 往其 dfs 树上的父亲合并，同时维护一个点并查集中除根以外的所有祖先中，半支配点 dfs 序最小的那个点，就可以在一次 $O(\log n)$ 的时间复杂度内完成第二种情况的查询。

至此，我们已经在 $O(n\log n)$ 的时间复杂度内完成了半支配点的求解。

**利用半支配点求解支配点.**

考虑点 $k$ 到其半支配点 $x$ 的这条链（不包括 $x$）上半支配点 dfs 序最小的点 $u$ 及其半支配点 $v$，则 $k$ 在支配点有两种情况：
1. 若 $x=v$，则 $k$ 的支配点就是 $x$。
2. 若 $d_x>d_v$，则 $k$ 的支配点是 $u$ 的支配点。

可以证明这两种情况是充分必要的。

我们再次考虑按照 dfs 序倒序处理。

对于一个点 $k$，我们考虑其在半支配点 $x$，现在需要完成在 dfs 树上查询 $k$ 到 $x$ 这条链（不包含 $x$）中半支配点 dfs 序最小的点。

我们发现这个查询就在半支配点的求解中出现过。

考虑在求解半支配点同时求解支配点。当我们求出 $k$ 的半支配点后，将 $k$ 的半支配点与 $k$ 连边，维护半支配树。同时令 $x$ 为 $k$ 在 dfs 树上的父亲，枚举 $x$ 在半支配树上的儿子 $y$，容易发现当前并查集中维护的正好就是 $y$ 到 $x$（不包含 $x$）中半支配点 dfs 序最小的点。

不过一个问题是，如果查询出来的结果是第二种情况，此时我们并不知道得到点的支配点，所以把得到点先存下来，最后再按照 dfs 序正序处理一遍就好了。

同时，如果我们每一次都枚举 $k$ 的父亲 $x$ 在半支配树中的所有儿子，会导致多次枚举了某些点，所以每次枚举完之后需要将这些儿子清空才能保证复杂度正确。这也是大部分题解复杂度错误的原因。

至此，我们已经在 $O(n\log n)$ 的时间复杂度内完成了支配点的求解，也就完成了整个 Lengauer-Tarjan 算法。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N=200000,M=300000;

int n,m;
struct side{
  int y,next;
}e[M*2+N+9];
int lin[3][N+9],cs;
//0为原图，1为反图，2为半支配树

void Ins(int id,int x,int y){e[++cs].y=y;e[cs].next=lin[id][x];lin[id][x]=cs;}

void into(){
  scanf("%d%d",&n,&m);
  for (int i=1;i<=m;++i){
    int x,y;
    scanf("%d%d",&x,&y);
    Ins(0,x,y);Ins(1,y,x);
  }
}

int dfn[N+9],ord[N+9],co;
int fa[N+9];

void Tarjan(int k){
  ord[dfn[k]=++co]=k;
  for (int i=lin[0][k];i;i=e[i].next)
    if (!dfn[e[i].y]){
      fa[e[i].y]=k;
      Tarjan(e[i].y);
    }
}

int idom[N+9],sdom[N+9];
int uni[N+9],mn[N+9];

int Query_uni(int k){
  if (k==uni[k]) return k;
  int res=Query_uni(uni[k]);
  if (dfn[sdom[mn[uni[k]]]]<dfn[sdom[mn[k]]]) mn[k]=mn[uni[k]];
  return uni[k]=res;
}

void Contract(int st){
  Tarjan(st);
  for (int i=1;i<=n;++i) sdom[i]=uni[i]=mn[i]=i;
  for (int i=co;i>=2;--i){
    int t=ord[i];
    for (int i=lin[1][t];i;i=e[i].next){
      int y=e[i].y;
      if (!dfn[y]) continue;
      //如果无法到达y则直接跳过
      Query_uni(y);
      if (dfn[sdom[mn[y]]]<dfn[sdom[t]]) sdom[t]=sdom[mn[y]];
    }
    uni[t]=fa[t];
    //半支配点的求解过程
    Ins(2,sdom[t],t);
    //维护半支配树
    for (int i=lin[2][t=fa[t]];i;i=e[i].next){
      int y=e[i].y;
      Query_uni(y);
      idom[y]=t==sdom[mn[y]]?t:mn[y];
    }
    //支配点的求解过程
    lin[2][t]=0;
    //清空已扫过的儿子
  }
  for (int i=2;i<=co;++i){
    int t=ord[i];
    if (idom[t]^sdom[t]) idom[t]=idom[idom[t]];
  }
  //最后的正序扫描
}

int ans[N+9];

void Get_ans(){
  for (int i=co;i>=2;--i) ans[idom[ord[i]]]+=++ans[ord[i]];
  ++ans[1];
}

void work(){
  Contract(1);
  Get_ans();
}

void outo(){
  for (int i=1;i<=n;++i)
    printf("%d ",ans[i]);
  puts("");
}

int main(){
  into();
  work();
  outo();
  return 0;
}
```

---

## 作者：Mine_King (赞：17)

[在我的博客获得不一定更好的体验。](https://caijimk.netlify.app/post/dominator-tree)

约定：本文中用 $u \to v$ 表示从 $u$ 通过一条边直接走到 $v$，$u \rightsquigarrow v$ 表示 $u$ 通过某条路径走到 $v$。

## 支配关系与支配点

对于一张有向图和一个起始点 $s$，我们定义 $u$ **支配** $v$ 当且仅当所有 $s$ 到 $v$ 的路径都经过 $u$，记做 $u \mathbin{\mathrm{dom}} v$。  
方便起见，我们认为 $s$ 可以到达图上每一个点。

若 $u \mathbin{\mathrm{dom}} v$，则我们认为 $u$ 是 $v$ 的一个**支配点**。每个点都是自己的支配点，$s$ 是所有点的支配点。

> 引理 1：支配关系是偏序关系。

根据定义有自反性，反对称性和传递性也是好证的。

> 引理 2：若 $u \mathbin{\mathrm{dom}} w, v \mathbin{\mathrm{dom}} w$，则 $u \mathbin{\mathrm{dom}} v$ 或 $v \mathbin{\mathrm{dom}} u$。

使用反证法，若不满足的话一定不同时满足 $u \mathbin{\mathrm{dom}} w, v \mathbin{\mathrm{dom}} w$。

## 支配树

根据上面两个引理，我们可以发现点集和支配关系构成的偏序集的哈斯图构成了一棵以 $s$ 为根的外向树，称之为**支配树**。

*注：一个偏序集 $R$ 的哈斯图是指：对于偏序集中任意两个元素 $a, b$，当且仅当 $a \mathrel{R} b$ 且不存在 $c$ 使得 $a \mathrel{R} c, c \mathrel{R} b$ 时图上有一条 $a$ 到 $b$ 的边。*

对于除 $s$ 以外的任意一个点 $u$，其都有至少两个支配点。我们称除 $u$ 以外到 $u$ 距离最近的点为 $u$ 的**直接支配点**，记做 $idom(u)$。可以发现，$idom(u)$ 就是就是支配树上 $u$ 的父亲。

根据定义可以得到，每个点的**支配点**是其在支配树上的所有祖先（包括其本身），每个点支配其子树中的所有点。

## 外向树的支配树

外向树的支配树即为其本身。

## DAG 的支配树

> 引理 3：$\forall u, v, u \ne v, u \mathbin{\mathrm{dom}} v \iff \forall w, (w, v) \in E, u \mathbin{\mathrm{dom}} w$

证明略。

对于 DAG，我们考虑按拓扑序构造支配树。  
对于一个点 $u$，其支配点集是其所有前驱的支配点集的交加上其本身，对应到支配树上，即为其所有前驱的公共祖先加上其本身，因此点 $u$ 的直接支配点即为其所有前驱在支配树上的 LCA。

## Lengauer–Tarjan 算法

Lengauer–Tarjan 算法用于在 $O(n \alpha(n))$ / $O(n \log n)$ 复杂度内求一张有向图的支配树。该算法引入了**半支配点**的概念，并通过半支配点来求直接支配点。

首先对原图进行 dfs 求出 dfs 序以及 dfs 生成树 $T$。  
以下定义 $u < v \iff dfn _ u < dfn _ v$，定义 $fa _ u$ 为 $u$ 在 dfs 树上的父亲。

### 半支配点

我们定义一个点 $u \ne s$ 的半支配点 $sdom(u)$ 为最小的点 $v$ 使得存在一条路径 $v \to v _ 1 \to v _ 2 \to \ldots \to v _ k \to u, \forall i \in [1, k], v _ i > u$。

*注：在某些地方也称存在一条上述路径的点为半支配点，称同时满足最小的点为最小半支配点。*

约定：  
以下「满足半支配点的条件」指存在一条上述路径但不一定最小。  
以下 $u \stackrel{s}{\rightsquigarrow} v$ 表示 $u$ 到 $v$ 的一条满足 $v$ 的半支配点的条件的路径，$u \stackrel{T}{\rightsquigarrow} v$ 表示 $u$ 通过树边到 $v$ 的路径。  
以下讨论中默认点不包括 $s$。

> 引理 4：对于任意点 $u$，$sdom(u) < u$

证明考虑 $fa _ u$ 一定满足半支配点的条件。

> 引理 5：对于任意点 $u$，$idom(u)$ 一定是 $u$ 的祖先。

证明考虑 $idom(u)$ 一定在 $T$ 中从根到 $u$ 的路径上。

> 引理 6：对于任意点 $u$，$sdom(u)$ 一定是 $u$ 的祖先。

证明考虑从 $sdom(u)$ 走的第一步只能走到 $sdom(u)$ 的子树中。假设 $sdom(u)$ 不是 $u$ 的祖先，则一定要走到 $sdom(u)$ 的祖先，就矛盾了。

> 引理 7：对于任意节点 $u$，$idom(u)$ 一定是 $sdom(u)$ 的祖先（或就是 $sdom(u)$）。

证明考虑 $sdom(u) \stackrel{s}{\rightsquigarrow} u$ 不经过 $T$ 上 $sdom(u)$ 到 $u$ 这条树链中间的点，因此 $sdom(u)$ 到 $u$ 中间的点一定不是 $u$ 的支配点。

> 引理 8：对于任意点 $u, v$，$u$ 是 $v$ 的祖先，要么 $u$ 是 $idom(v)$ 的祖先（或相等），要么 $idom(v)$ 是 $idom(u)$ 的祖先（或相等）。

对于树上任意 $idom(u)$ 到 $u$ 中间的点，一定存在一条路径从 $s$ 出发到 $idom(u)$ 再到 $u$ 再到 $v$ 并不经过这些点，因此要么 $idom(v)$ 是 $idom(u)$ 的祖先，要么 $u$ 是 $idom(v)$ 的祖先。

> 定理 1：$sdom(u) = \min(\{v \mid (v, u) \in E, v < u\} \cup \{sdom(w) \mid w > u \land \exists v > u, (v, u) \in E, \text{s.t. } w\text{ 是 }v\text{ 的祖先或 }w = v\})$

证明：设右式的值为 $x$。

先证 $sdom(u) \le x$，即证 $x$ 满足成为 $sdom(u)$ 的条件。  
若 $x$ 取到第一部分，显然满足。若 $x$ 取到第二部分，则路径 $x \stackrel{s}{\rightsquigarrow} w \stackrel{T}{\rightsquigarrow} v \to u$ 满足条件。

再证 $sdom(u) \ge x$，相当于证右边的集合一定存在一个元素小于等于 $sdom(u)$。考虑其对应的路径 $sdom(u) \to v _ 1 \to v _ 2 \to \ldots \to v _ k \to u$，若 $k = 0$ 则其一定满足 $sdom(u) < u, (sdom(u), u) \in E$，一定可以被上面式子的第一部分取到。否则 $v _ k > u$，找到 $j$ 使得 $v _ j$ 是 $v _ k$ 的祖先（或 $= v _ k$）且 $v _ j$ 最小，只需证 $sdom(u)$ 是一个满足成为 $v _ j$ 的半支配点条件的点，即 $\forall i \in [1, j - 1], v _ i > v _ j$。我们发现如果存在 $v _ i < v _ j$，找到最后的 $i$，可以发现其只能走到子树内的点（因为走到子树外一定要通过返祖边或横叉边，这样会走到一个更小的点，不满足 $v _ i$ 是最后的 $< v _ j$ 的点），因此 $v _ i$ 一定是 $v _ j$ 的祖先，与 $v _ j$ 是 $v _ k$ 在路径中出现的最小的祖先矛盾，所以不存在这样的 $v _ i$。

综上，$sdom(u) \le x$ 且 $sdom(u) \ge x$，因此 $sdom(u) = x$。$\square$

根据定理 1，我们可以得到一个 $O(n \log n)$ 求半支配点的方法：按 dfs 序从后往前做，对于每个点 $u$ 和他的前驱 $v$，若 $v < u$ 则用 $v$ 更新 $sdom(u)$，否则用其 $sdom$ 最小的祖先的 $sdom$ 更新 $sdom(u)$，后面这部分相当于询问从 $v$ 开始往上的一条树链的 $sdom$ 的最小值，使用带权并查集维护，每扫完一个点就将他与父亲合并即可。

### 求支配点

**方法一：**

在 $T$ 基础上加上所有 $sdom(u) \to u$ 的边会形成一个 DAG，其上的支配关系与原图相同，因此在这个图上跑 DAG 的做法即可得到支配树。

证明：显然我们只需要考虑有祖先关系的点。首先容易发现原图存在的支配关系依然存在，然后要证明原图不存在的支配关系在新图上也不存在。  
对于一个点 $u$ 及其子树内的一个点 $v$，如果 $u$ 不支配 $v$，那么存在一条路径不经过 $u$ 进入 $u$ 的子树内。我们考虑这条路径进入 $u$ 子树前最后一个点 $k$ 和进入后最小的到达的 $u$ 和 $v$ 中间这条树链中的点 $r$（包括 $v$ 但不包括 $u$），$LCA(u, k) \stackrel{T}{\rightsquigarrow} k \to r$ 是一条满足 $r$ 的半支配点的路径（可以证明 $k \rightsquigarrow r$ 中的点都 $> r$），因此如果我们把所有满足半支配点条件的点对作为边全都加入那么支配关系就与原图相同了。而因为一个点所有满足半支配点条件的点都是他的祖先，所以我们只需要保留最上面的一个即可。$\square$

其实这个做法很好写，因为每个点只会有两个入度而且在 $T$ 上都是他的祖先，所以实际上也不需要拓扑排序直接按 dfs 序做也是对的。

**方法二：**

但是有人认为上面这个做法太不优雅了，所以这里给出另一种做法。

> 定理 2：对于任意节点 $u$，设 $v$ 是 $sdom(u)$ 到 $u$ 这条链上 $sdom$ 最小的点（不包括 $u$ 和 $sdom(u)$），若 $sdom(v) \ge sdom(u)$，则 $idom(u) = sdom(u)$。

证明：等价于证 $sdom(u) \mathbin{\mathrm{dom}} u$。

对于 $sdom(u) = s$ 显然成立，下面考虑 $sdom(u) \ne s$ 的情况。

假设存在一条到 $u$ 的路径不经过 $sdom(u)$，记其中最后一个小于 $sdom(u)$ 的点为 $x$。  
我们把树切成五部分，分别是 $< sdom(u)$ 的点（记为第一部分），$sdom(u)$，$u$，$> sdom(u)$ 的点（记为第三部分）以及中间的部分（记为第二部分）。显然 $x$ 在第一部分，且 $x$ 要走到第一部分以外的地方只能通过树边或前向边，因此 $x$ 一定是 $sdom(u)$ 的祖先。

考虑 $x$ 之后的路径，一定存在一个 $y$ 使得其在 $sdom(u)$ 到 $u$ 的树链上，因为不存在这样的 $y$ 等价于 $x$ 之后没有进入第二部分，使得 $x$ 满足半支配点的条件且 $< sdom(u)$，那 $sdom(u)$ 就会变成 $x$。  
我们找到最小的 $y$，由于 $sdom(y) \ge sdom(u) > x$，因此从 $x$ 出发到 $y$ 一定要经过 $x$ 到 $y$ 中间这条树链上的点。又因为 $x$ 是最后一个小于 $sdom(u)$ 的点，所以中间这个点一定在 $sdom(u)$ 到 $y$ 中间这条树链上，而这与 $y$ 是最小的在 $sdom(u)$ 到 $u$ 中的点矛盾，因此不存在这样的路径，因此 $sdom(u) \mathbin{\mathrm{dom}} u$。$\square$

> 定理 3：对于任意节点 $u$，设 $v$ 是 $sdom(u)$ 到 $u$ 这条链上 $sdom$ 最小的点（不包括 $u$ 和 $sdom(u)$），若 $sdom(v) < sdom(u)$，则 $idom(u) = idom(v)$。

证明：因为 $idom(u)$ 是 $idom(v)$ 的祖先（或相等），所以等价于证明 $idom(v) \mathbin{\mathrm{dom}} u$。

类似地，假设存在一条到 $u$ 的路径不经过 $idom(v)$，记其中最后一个小于 $idom(v)$ 的点为 $x$。  
同样的分析方法可以得到 $x$ 是 $idom(v)$ 的祖先，在路径上 $x$ 之后一定存在一个 $y$ 使得其在 $idom(v)$ 到 $u$ 的树链上。找到最小的 $y$。  
可以发现这条路径上 $x \rightsquigarrow y$ 是一条满足 $y$ 的半支配点的条件的路径，因此 $sdom(y) \le x < idom(v) \le sdom(v)$。并且 $y$ 一定不是 $sdom(u)$ 的后代（否则由于 $sdom(y) < sdom(v)$，与 $sdom(v)$ 最小这点矛盾）因此 $idom(v) < y \le sdom(u)$。

此时我们发现存在一条路径 $s \stackrel{T}{\rightsquigarrow} sdom(y) \stackrel{s}{\rightsquigarrow} y \stackrel{T}{\rightsquigarrow} sdom(u) \stackrel{T}{\rightsquigarrow} v$，这条路径不经过 $idom(v)$，矛盾，因此不存在这样的路径，因此 $idom(v) \mathbin{\mathrm{dom}} u$。$\square$

根据上面两个定理，我们可以得到：

$$
idom(u) = \begin{cases}
sdom(u) & sdom(v) = sdom(u) \lor sdom(u) = fa _ u \\
idom(v) & \text{otherwise}
\end{cases}
$$

在求 $sdom$ 的同时求 $idom$，具体地，将每个点挂在其 $sdom$ 上，对于第一种情况直接求，对于第二种情况用并查集维护即可。

### 参考代码

```cpp
int n, m; // n, m 为点数和边数
struct graph {
	int tot, hd[200005];
	int nxt[300005], to[300005];
	
	void add(int u, int v) {
		nxt[++tot] = hd[u];
		hd[u] = tot;
		to[tot] = v;
		return ;
	}
} g, fg; // g 为原图，fg 为反图
int timer, fa[200005], dfn[200005], id[200005];
int sdom[200005], idom[200005];
struct dsu {
	int fa[200005], mn[200005];

	dsu() {for (int i = 1; i < 200005; i++) fa[i] = mn[i] = i;}
	int find(int x) {
		if (x == fa[x]) return x;
		int tmp = find(fa[x]);
		if (dfn[sdom[mn[fa[x]]]] < dfn[sdom[mn[x]]]) mn[x] = mn[fa[x]];
		return fa[x] = tmp;
	}
} d;
vector<int> vec[200005];

void dfs(int now) {
	id[dfn[now] = ++timer] = now;
	for (int i = g.hd[now]; i; i = g.nxt[i])
		if (!dfn[g.to[i]]) fa[g.to[i]] = now, dfs(g.to[i]);
	return ;
}
void solve() {
	dfs(1);
	for (int i = 1; i <= n; i++) sdom[i] = i;
	for (int i = timer; i >= 1; i--) {
		int u = id[i];
		for (int v : vec[u]) {
			d.find(v);
			if (sdom[d.mn[v]] == u) idom[v] = u;
			else idom[v] = d.mn[v]; // 这里是一个省数组的写法，将 idom 和并查集用同一个数组维护了。
		}
		if (i == 1) continue;
		for (int j = fg.hd[u]; j; j = fg.nxt[j]) {
			if (!dfn[fg.to[j]]) continue;
			if (dfn[fg.to[j]] < dfn[sdom[u]]) sdom[u] = fg.to[j];
			else if (dfn[fg.to[j]] > dfn[u]) {
				d.find(fg.to[j]);
				if (dfn[sdom[d.mn[fg.to[j]]]] < dfn[sdom[u]]) sdom[u] = sdom[d.mn[fg.to[j]]];
			}
		}
		vec[sdom[u]].push_back(u);
		d.fa[u] = fa[u];
	}
	for (int i = 2; i <= timer; i++)
		if (idom[id[i]] != sdom[id[i]]) idom[id[i]] = idom[idom[id[i]]];
	return ;
}
```

## 例题

- [P5180 【模板】支配树](https://www.luogu.com.cn/problem/P5180)
- [P2597 [ZJOI2012] 灾难](https://www.luogu.com.cn/problem/P2597)
- [P7520 [省选联考 2021 A 卷] 支配](https://www.luogu.com.cn/problem/P7520)
- [CF757F Team Rocket Rises Again](https://www.luogu.com.cn/problem/CF757F)

## 参考资料

- <https://www.luogu.com.cn/blog/zhw-ifmt/z-zuo-p-pian-s-shu-post>
- <https://www.bilibili.com/video/BV1DA411k79m/>

---

## 作者：Alex_Wei (赞：12)

注：摘自 [笔记](https://www.luogu.com.cn/article/qaggtm3r)。所有定理均有通俗易懂的证明，且大量配图。

## 4. 有向图必经点：支配树

**前置知识**：有向图 DFS 树。

无向图的必经点由割点和割边刻画，有向图同样存在必经点相关的概念与算法：支配点和支配树。学习一般图支配树能够有效提升图论水平！

### 4.1 定义与性质

首先明确：接下来的所有探究基于 **起点固定** 这一前提条件。

对一般有向图 $G = (V, E)$，选定起点 $s$。若 $s$ 到 $y$ 的所有路径均经过 $x$，则称 $x$ **支配** (*dominate*) $y$，$x$ 是 $y$ 的 **支配点**。即 $x$ 是从 $s$ 到 $y$ 的必经点。

对 $s$ 不可达的点讨论支配关系没有意义。不失一般性地，设 $s = 1$ 且 $1$ 可达图上所有点。若有多个起点，建立虚点向这些点连边，转化为起点唯一的情况。

和无向图一样，在讨论支配关系时，只考虑 **简单路径**。如果重复经过一个点，那么将这两次经过之间的点删去。被删去且没有在新路径上出现的点不是支配点。

支配是一种二元关系，我们记作 $D$，$x$ 支配 $y$ 可以写成 $xDy$。从一般二元关系的常见性质出发，探究支配关系所具有的性质：

- **传递性**：若 $xDy$，$yDz$，则 $1\rightsquigarrow z$ 的任意路径都经过 $y$，且 $1\rightsquigarrow y$ 的任意路径都经过 $x$。因此，$x$ 在 $1\rightsquigarrow z$ 的任意路径上，即 $xDz$。
- **自反性**：$1\rightsquigarrow x$ 的任意路径都经过 $x$，即 $xDx$。
- **反对称性**：若 $xDy$，$yDx$，则 $1\rightsquigarrow y$ 的任意路径都经过 $x$。如果 $x\neq y$，那么存在 $1\rightsquigarrow x$ 的路径不经过 $y$，和 $yDx$ 矛盾。因此 $x = y$。**反对称性** 即对称性的反面：对称性要求对于任意 $x\neq y$，若 $xDy$ 则 $yDx$。

满足以上三条性质的关系称为 **偏序关系**，元素集合和它对应的偏序关系一起称为偏序集。

> **补充**
>
> 偏序关系的含义是 “部分” 满足 “序关系”，即局部满足 **全序关系**。在全序关系 $R$ 里，元素两两可比较（对 $x\neq y$，$xRy$ 或 $yRx$ 恰有一个成立）。这种关系抽象成图是一排点，每个点指向它后面的所有点。
>
> 直观地，在一个偏序集内部，元素之间通过偏序关系形成很多条链，链与链之间有交叉。在交叉点以外，分别位于两个不同链的元素不能比较。但是单独取出某一条链，上面的元素形成全序集。

对偏序关系建图只能得到 DAG：如果环长大于 $1$，根据传递性，环上每个点向其它点连边，不满足反对称性。

> **性质 1**
>
> 若 $xDz$ 且 $yDz$，则 $xDy$ 或 $yDx$。
>
> **证明**
>
> $x = y$ 的情况显然。
>
> 因为 $xDz$ 且 $yDz$，不妨设 $x$ 在 $y$ 之前，那么 $y$ 不支配 $x$。如果在此基础上 $x$ 不支配 $y$，那么存在一条 $1\rightsquigarrow y\rightsquigarrow z$ 的路径不经过 $x$，与 $xDz$ 矛盾。所以 $xDy$。$\square$

当一个偏序关系满足性质 1 时，就可以用树状结构刻画：考虑支配 $z$ 的所有点 $D_z = \{x_1, x_2, \cdots, x_k\}$，对任意两个不同元素 $x_i, x_j$ 应用该性质，可知元素之间形成了全序关系，所有 $x_i$ 的关系可以用一条链描述。

设 $idom_i$ 表示 $D_i$ 去掉 $i$ 之后被其它所有点支配的点，称为 $i$ 的 **直接支配点** (*immediate dominator*)。特别地，$idom_s$ 没有定义。$idom_i$ 可以理解为 $i$ 的所有支配点当中除了 $i$ 以外距离 $i$ 最近的一个，这里 “最近” 是良定义的：类似无向图两点之间的必经点在它们之间的任意简单路径上出现顺序固定，有向图从起点到某一点之间的必经点在它们之间的任意简单路径上出现的顺序也是固定的。

从 $idom_i$ 向 $i$ 连边，得到 **支配树** (*dominator tree*)，它是一棵叶向树。一个点在支配树上的祖先集合（包括它自己）恰为支配它的所有点。支配树刻画了有向图在给定起点时结点之间的必经关系，类似圆方树刻画了无向图上的必经关系。

### 4.2 有向无环图

DAG 无环的特殊性质使得我们能够方便地求出其支配树。

拓扑排序。设当前结点为 $x$。根据拓扑排序的性质，$x$ 对拓扑序在它之前的结点的必经性没有影响，因为 $x$ 不可达它们。因此，只需求出 $idom_x$。

当 $x$ 只有一条入边 $y\to x$ 时，显然 $idom_x = y$。到达 $x$ 要走 $y\to x$ 这条边，所以 $y$ 支配 $x$，由支配的传递性推出 $y$ 在支配树上的所有祖先 $anc(y)$ 都是 $x$ 的支配点，而 $y$ 是距离 $x$ 最近的一个。

当 $x$ 有两条入边 $y\to x$ 和 $z\to x$ 时，若最后一条边是 $y\to x$，则集合 $anc(y)$ 是必经点；若最后一条边是 $z\to x$，则集合 $anc(z)$ 是必经点。据定义，$x$ 的支配点是 $anc(y)$ 与 $anc(z)$ 的交集加上 $x$，前者即 $anc(lca(y, z))$。因此，$idom_x = lca(y, z)$。

根据上述分析，容易证明：若 $x$ 有若干条入边 $y_i \to x$，则 $anc(x) \backslash x$ 等于 $\bigcap_{i = 1} ^ k anc(y_i)$。所以

$$
idom_x = lca(y_1, y_2, \cdots, y_k)
$$
因为拓扑序在 $x$ 之前的 $idom$ 均已确定，所以在确定每个点的 $idom$ 之后立刻预处理这个点的倍增数组，倍增求 LCA。时间复杂度 $\mathcal{O}((n + m)\log n)$。

[模板题](https://www.luogu.com.cn/problem/P2597) 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1 << 16;
constexpr int K = 16;
constexpr int M = 1e6 + 5;
int p, topo[N], sz[N];
int n, dep[N], deg[N], anc[K][N];
int cnt, hd[N], nxt[M], to[M];
void add(int u, int v) {nxt[++cnt] = hd[u], hd[u] = cnt, to[cnt] = v;}
int lca(int u, int v) {
  if(!u || !v) return u | v;
  if(dep[u] < dep[v]) swap(u, v);
  for(int i = K - 1; ~i; i--) {
    if(dep[anc[i][u]] >= dep[v]) u = anc[i][u];
  }
  if(u == v) return u;
  for(int i = K - 1; ~i; i--) {
    if(anc[i][u] != anc[i][v]) {
      u = anc[i][u], v = anc[i][v];
    }
  }
  return anc[0][u];
}
int main() {
  cin >> n;
  for(int i = 1, u; i <= n; i++) {
    scanf("%d", &u);
    while(u) deg[i]++, add(u, i), scanf("%d", &u);
    if(!deg[i]) deg[i] = 1, add(n + 1, i);
  }
  queue<int> q;
  q.push(n + 1), dep[n + 1] = 1;
  while(!q.empty()) {
    int t = q.front();
    q.pop(), topo[++p] = t;
    dep[t] = dep[anc[0][t]] + 1;
    for(int i = 1; i < K; i++) anc[i][t] = anc[i - 1][anc[i - 1][t]];
    for(int i = hd[t]; i; i = nxt[i]) {
      int it = to[i];
      anc[0][it] = lca(anc[0][it], t);
      if(!--deg[it]) q.push(it);
    }
  }
  for(int i = p; i; i--) {
    int id = topo[i];
    sz[anc[0][id]] += sz[id] + 1;
  }
  for(int i = 1; i <= n; i++) printf("%d\n", sz[i]);
  return 0;
}
```

### 4.3 一般图

先考虑朴素做法。和无向图的必经性一样，我们删掉 $x$ 后检查 $s$ 是否可达 $y$，由此判断 $x$ 是不是 $y$ 的支配点。因此，独立地删掉每个点 $x\neq s$，剩余的图上所有 $s$ 不可达的点被 $x$ 支配。时间 $\mathcal{O}(nm)$。

Thomas Lengauer 和 Robert Tarjan 于 1979 年给出了更快的支配树算法。具体多快呢？$\mathcal{O}(m\log n)$。精细实现可以做到几乎线性的 $\mathcal{O}(m\alpha(m, n))$。

首先求出以 $s$ 为根的 DFS 树，将每个点重新编号为它的时间戳。因为可以只走树边，所以每个点的直接支配点是它在树上的真祖先（祖先且不相等）。

> **引理 1**
>
> $idom_x \neq x$ 且 $idom_x$ 是 $x$ 的祖先。

在研究强连通分量横叉边的性质的时候，一个基本结论是如果 $v < u$，那么 $v$ 可达 $u$ 当且仅当 $v$ 可达 $d$，其中 $d = lca(u, v)$。接下来的引理和这个结论密切相关。

> **引理 2**
>
> 如果 $v < u$，那么所有 $v$ 到 $u$ 的路径都经过 $d$ 的祖先。
>
> **证明**
>
> 在考虑 DFS 树的时候，一个形象的方法是把儿子按 DFS 顺序从左到右排列。这样，对于两个没有祖先后代关系的点，左边的点的时间戳小于右边的点。
>
> 这个引理的一句话证明是，因为只有树边或前向边增加编号，所以从小于 $u$ 的点走到不小于 $u$ 的点这一步 $x\to y$ 是树边或前向边，那么 $x$ 是 $u$ 的祖先（如果 $x < u$ 且 $x$ 不是 $u$ 的祖先，那么 $x$ 子树内所有点都小于 $u$），而从 $v$ 开始走到某个 $u$ 的祖先的过程中，$u, v$ 的 LCA 只会不断变浅。
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/5hnam8xz.png)
>
> 如上图，$v = 6$，$u = 7$，虚线是非树边。从 $u$ 走到某个 $d = 5$ 的祖先 $1$ 之前的路径用红色标出，之后的路径用蓝色标出。绿色是编号大于 $u$ 的点，可以发现能够直接走到它们的编号不大于 $7$ 的点只有 $7$ 的祖先。红色路径上每个点和 $7$ 的 LCA 依次是 $5, 1, 1$，这个 LCA 只会变得越来越浅。
>
> 具体地，设 $c$ 是当前 $u$ 和 $v$ 的 LCA，初始为 $d$，当 $v = c$ 时停止。从 $v$ 出发依次考虑路径上的每一步：
>
> - 如果走树边或前向边，那么 $c$ 不变。
> - 如果走返祖边且没有停止，那么 $c$ 不变。
> - 如果走横叉边，那么 $c$ 只会变成 $c$ 的祖先，因为能够使得 $c$ 变深的 $v' > v$，但横叉边只会减小时间戳。例如上图中不会出现 $2, 3$ 或 $4$ 到 $6$ 的使得和 $7$ 的 LCA 变深的横叉边。
>
> 所以最终的 $c$ 是 $d$ 的祖先，路径一定经过 $d$ 的祖先。$\square$

引理 2 是有向图上路径的强有力而不那么平凡的结论。它可以想象成一个单向的 “屏障”，从 $x$ 左边到 $x$ 右边必须要经过这个屏障上的点，从 $x$ 右边到 $x$ 左边则不需要。

考虑 $1$ 到 $x$ 的任意路径。如果经过了小于 $x$ 但不是 $x$ 的祖先的点，那么根据引理 2，之后一定会经过 $x$ 的祖先。我们考虑最后一个这样的祖先 $d$，之后只会经过大于 $x$ 的点到 $x$。因此，$d$ 可以只经过大于 $x$ 的点到 $x$。如果有很多个这样的祖先，显然只有最浅的祖先对支配关系是有用的。这个概念比较关键，我们给它一个定义：

> **半支配点**
>
> 存在路径 $u\to p_1 \to \cdots \to p_k \to x$ 且 $p_i > x$ 的最小的 $x$ 的祖先 $u$ 称为 $x$ 的 **半支配点** (*semidominator*)，记为 $sdom_x$。

将上述定义的 “$x$ 的祖先” 的限制去掉没有影响，因为如果 $u < x$ 且 $u$ 不是 $x$ 的祖先，那么根据引理 2，路径经过 $x$ 的祖先 $d < u$。

为方便描述，对 $u < v$，我们称 $u$ 到 $v$ 的路径是 **好路径**，当且仅当中途只经过大于 $v$ 的点。

已知 $idom_x$ 和 $sdom_x$ 都是 $x$ 的祖先，那么自然地，我们希望确定它们的位置关系。这个也很显然：因为 $sdom_x$ 可以绕过 $sdom_x$ 到 $x$ 的树上路径到达 $x$，所以这段路径上的点（不含 $sdom_x$）都不可能支配 $x$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ibau8i2q.png)

如上图，$sdom_4 = 2$，$idom_4 = 1$。$3$ 不可能是支配点，因为根据 $sdom$ 的定义，存在一条 $2$ 到 $4$ 且中途只经过大于 $4$ 的点的路径 $2\to 5\to 4$ 绕过了它。但是从 $1$ 出发又可以绕过 $2$ 到 $4$，所以 $2$ 也不是支配点。

> **引理 3**
>
> $idom_x$ 是 $sdom_x$ 的祖先。

引理 3 可以理解为 $sdom_x$ 到 $x$ “跳过” 了一些点，这些点不可能成为 $x$ 的支配点。引理 3 带给我们的启发是任何这样的 $(sdom_u, u)$ 二元组都能够让我们 “跳过” 一些点。

具体地，$idom_x$ 和 $sdom_x$ 都在 $x$ 到根的路径上。我们把这条链拿出来水平摆放，$1$ 在最左边，$x$ 在最右边，那么每个 $sdom_u$ 到 $u$（$u$ 在链上）都会跳过一些点，这些点不可能是 $x$ 的支配点，因为可以从 $1$ 在链上走到 $sdom_u$，然后根据 $sdom$ 的定义只经过大于 $u$ 的点（于是不经过被跳过的点）到 $u$，再从链上走到 $x$。

![](https://cdn.luogu.com.cn/upload/image_hosting/n5slvsj8.png)

以上分析表明被二元组跳过的点一定不是支配点。那么没有被任何二元组跳过的点是否一定是支配点呢？

> **引理 4**
>
> 对 $x$ 的真祖先 $y$，如果不存在 $x$ 的祖先 $u$ 使得 $y$ 落在 $sdom_u$ 到 $u$ 在树上的路径上（不含两端），那么 $y$ 支配 $x$。
>
> **证明**
>
> 假设存在 $1$ 到 $x$ 的不经过 $y$ 的路径。考虑路径上所有 $x$ 的祖先，可知存在 $u$ 到 $v$ 的路径 $P$，使得路径上不经过其它 $x$ 的祖先，其中 $u, v$ 都是 $x$ 的祖先且 $u$ 是 $y$ 的真祖先，$v$ 是 $y$ 的真后代。
>
> 假设 $P$ 中途经过了小于 $v$ 的点，那么根据引理 2，$P$ 在此之后经过了 $v$ 的真祖先，和 $P$ 不经过其它 $x$ 的祖先矛盾。于是 $P$ 是好路径。因此 $sdom_v \leq u$。因为 $u$ 是 $y$ 的真祖先，所以 $sdom_v$ 是 $y$ 的真祖先，和 $y$ 不落在任何 $sdom_u$ 到 $u$ 之间矛盾。$\square$
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/bj070kd6.png)
>
> 如上图，蓝色是从 $u$ 出发跳过 $y$ 的好路径，红色是从 $u$ 出发经过 $z < v$ 所以最终一定经过 $lca(z, v)$（$x$ 的小于 $v$ 的祖先）的路径。

引理 3 和引理 4 合起来告诉我们一个重要结论：$y$ 支配 $x$ 当且仅当 $y$ 没有被覆盖。具体地，用 $x$ 的所有祖先 $u$ 的 $sdom_u$ 到 $u$（不含两端）覆盖 $1$ 到 $x$ 的链，那么最深的没有被覆盖的 $x$ 的真祖先就是 $idom_x$。这个显然可以 DP。

- 一个等价表述是仅保留树边和 $sdom_x$ 到 $x$ 的边不影响支配关系。于是可以使用 DAG 支配树的做法。

设 $sdom_x$ 到 $x$ 从左到右分别覆盖了 $p_1, \cdots, p_k$。如果这些点的 $sdom$ 都在 $sdom_x$ 及其右边，那么 $sdom_x$ 就没有被覆盖。否则 $idom_x$ 在 $sdom_x$ 左边。

称添加一个点 $u$ 表示用 $sdom_u$ 到 $u$ 覆盖。考虑使得 $sdom_{p_i}$ 最小的 $p_i$，那么在添加 $p_{i + 1}, \cdots, p_k, x$ 时，只会影响到 $sdom_{p_i}$ 及其右边。假设现在已经添加了 $1$ 到 $p_i$ 的每个点，那么此时最深的未被覆盖的 $p_i$ 的真祖先 $idom_{p_i}$ 在 $sdom_{p_i}$ 或其左边，而添加 $p_{i + 1}, \cdots, p_k, x$ 不会让 $idom_{p_i}$ 被覆盖，且覆盖了 $p_{i\sim k}$。于是此时最深的未被覆盖的 $x$ 的真祖先依然是 $idom_{p_i}$。综上所述：

> **结论 1**
> $$
> idom_x = \begin{cases} sdom_x, & \forall p_j : sdom_x \leq sdom_{p_j}; \\ idom_{p_i}, & \exists p_i :(\forall p_j : sdom_{p_i}\leq sdom_{p_j}) \land sdom_{p_i} <  sdom_x. \end{cases}
> $$
> ![](https://cdn.luogu.com.cn/upload/image_hosting/0xuorrkk.png)
> 
> 如上图，红色的 $idom_{p_i}$（可能和 $sdom_{p_i}$ 相等）不会被 $p_j(j > i)$ 和 $x$ 覆盖，而蓝色的 $p_{i\sim k}$ 又被 $x$ 覆盖，所以 $idom_x = idom_{p_i}$。

具体如何实现呢？只需计算 $sdom_x$ 到 $x$ 在树上的所有点（不含 $sdom_x$）的 $sdom$ 的最小值。这种两端具有祖先后代关系的链上最值查询有很经典的做法：把查询挂到较浅的端点处，在 DFS 回溯时维护子树内每个点到当前点的链上最值并回答对应的询问，带权并查集即可。具体地，在并查集内额外维护每个点到它指向结点的树上路径的点权最小值，回溯时让当前点的所有儿子在并查集内指向当前点即可。

现在还要求 $sdom$。我们考虑从 $u$ 到 $x$ 的好路径。没有中间点的情况是容易处理的，因为此时 $u$ 到 $x$ 就是一条树边或前向边，只需求出指向 $x$ 的 $u$ 最小的前向边即可。

如果有中间点，那么根据 DP 的思想，自然地考虑路径的最后一条边 $v\to x$。但是这里有个问题，就是路径上 $u$ 到 $v$ 的部分不一定是好路径，而只用 $sdom_v$ 更新 $sdom_x$ 显然没有考虑到这种情况。

设中途经过的最小点是 $y$，那么 $x < y \leq v$。如果 $y$ 不是 $v$ 的祖先，那么根据引理 2，$y$ 到 $v$ 一定会经过 $lca(y, v) < y$，矛盾。因此 $y$ 是 $v$ 的祖先，也就是说，$y$ 落在 $lca(x, v)$ 到 $v$ 在树上的路径上（不含 $lca(x, v)$）。而 $y$ 又是中途经过的最小的点，所以路径上 $u$ 到 $y$ 的部分是好路径。

对于每条边 $v\to x$，考虑用 $lca(x, v)$ 到 $v$ 在树上的所有点（不含 $lca(x, v)$）的 $sdom$ 更新 $sdom_x$。因为任何 $u$ 到 $x$ 的最后一条边是 $v\to x$ 的好路径，都给出了 $u$ 到 $y$ 的好路径，所以不会漏情况，把 $sdom_x$ 算大。而任何 $u$ 到 $y$ 的好路径都可以扩展（从树边走到 $v$，再走 $v\to x$）得到一条 $u$ 到 $x$ 的好路径，所以不会多情况，把 $sdom_x$ 算小。

> **结论 2**
> $$
> sdom_x = \min(\{u \mid u < x \land (u, x) \in E\} \cup \{sdom_y \mid y > x \land \exists u : (y\in anc(u) \land (u, x) \in E\}))
> $$
> 其中 $anc(u)$ 表示 $u$ 的祖先集合。
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/so23yk0v.png)
>
> 如上图，蓝色边 $u_1\to x$ 对应的 $y$ 用蓝色标出，红色边 $u_2\to x$ 对应的 $y$ 用红色标出。

后半部分怎么算呢？和 $idom$ 一样，依然是具有祖先后代关系的链最值查询，使用带权并查集维护即可。不过显然地，这两部分可以共用一个带权并查集。

时间复杂度是并查集 $n$ 次合并 $m$ 次查询。[模板题](https://www.luogu.com.cn/problem/P5180) 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 2e5 + 5;
int n, m, dn, fa[N], ind[N], dfn[N];
int sdom[N], idom[N], sz[N];
vector<int> e[N], rev[N], buc[N];
void dfs(int id) {
  ind[dfn[id] = ++dn] = id;
  for(int it : e[id]) if(!dfn[it]) fa[it] = id, dfs(it);
}
struct dsu {
  int fa[N], mi[N]; // mi 维护 sdom 最小的点的编号
  int find(int x) {
    if(fa[x] == x) return fa[x];
    int f = fa[x];
    fa[x] = find(f);
    if(sdom[mi[f]] < sdom[mi[x]]) mi[x] = mi[f];
    return fa[x];
  }
  int get(int x) {
    return find(x), mi[x];
  }
} tr;
int main() {
  cin >> n >> m;
  for(int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    e[u].push_back(v);
    rev[v].push_back(u);
  }
  dfs(1), sdom[0] = n + 1;
  for(int i = 1; i <= n; i++) tr.fa[i] = i;
  for(int i = n; i; i--) { // i = 1 的时候有些语句不用执行, 不过执行了也没事
    int id = ind[i];
    for(int it : buc[i]) idom[it] = tr.get(it); // 此时的 idom 是 sdom 最小的 pi
    if(i == 1) break;
    sdom[id] = i;
    for(int it : rev[id]) {
      if(dfn[it] <= i) sdom[id] = min(sdom[id], dfn[it]);
      else sdom[id] = min(sdom[id], sdom[tr.get(it)]);
    }
    tr.mi[id] = id, tr.fa[id] = fa[id]; // 连接 id 和 fa[id]
    buc[sdom[id]].push_back(id); // 把询问挂到对应位置
  }
  for(int i = 2; i <= n; i++) {
    int id = ind[i];
    if(sdom[idom[id]] != sdom[id]) idom[id] = idom[idom[id]]; // 如果 sdom 最小的 sdom[pi] 不等于 sdom[id], 那么 idom[id] = idom[pi]
    else idom[id] = sdom[id]; // 否则 idom[id] = sdom[id]
  }
  for(int i = n; i; i--) {
    int id = ind[i];
    sz[i] += 1;
    if(i > 1) sz[ind[idom[i]]] += sz[i];
  }
  for(int i = 1; i <= n; i++) cout << sz[i] << " ";
  cout << "\n";
  return 0;
}
```

---

## 作者：takanashi_mifuru (赞：8)

> 玛奇玛，不，『支配之恶魔』

#### 问题

[link](https://www.luogu.com.cn/problem/P5180)

给一个单源有向图，对于起点 $s$，到任意一个点 $t$，如果在图上删掉点 $k$ 就能使得 $s$ 无法到达点 $t$，那么称 $k$ 支配 $t$，$k$ 是 $t$ 的支配点。

现在要求出一个点支配多少点。

#### 定义

对于一个点 $t$ 的支配点 $k$，如果 $k$ 的所有支配点都能支配 $t$，那么就认为 $k$ 是 $t$ 的最近支配点，即 $idom_t$，容易发现最近支配点是唯一的。

首先，他有传递性和反对称性，即 $a$ 支配 $b$，$b$ 支配 $c$，则 $a$ 支配 $c$。

$a$ 支配 $b$，$b$ 不一定支配 $a$。

反证一下发现，如果 $a$ 和 $b$ 支配 $c$，并且 $a$ 不支配 $b$，$b$ 不支配 $a$，分类讨论一下，如果 $a$ 不能到 $b$，那么删掉点 $b$ 后仍然能从点 $a$ 到 $s$，出现矛盾；如果 $a$ 能到 $b$，删掉点 $a$ 能使 $s$ 与 $c$ 不连通，而此时 $b$ 和 $c$ 连通，所以 $s$ 与 $b$ 不联通，即 $a$ 支配 $b$，出现矛盾。

如果每个点都认自己的 $idom$ 为父亲，就会出现一棵以 $s$ 为根节点的树，容易发现这样建树后，点 $x$ 被他的所有祖先支配，同时又支配他子树中的所有点。

Lengauer-Tarjan 可以 $O\left(n\log n\right)$ 求解支配树。

**我们认为点 $x$ 比点 $y$ 大，当且仅当 $dfn_x>dfn_y$。**

Lengauer-Tarjan 算法的巧妙之处在于引入了半支配点求解支配点。

若第 $sdom$ 号为第 $u$ 号结点的半支配点，则 $sdom$ 到 $u$ 的路径中所有点都比 $u$ 要大。

然后经典的 5 个引理和 3 个定理。

以下引理所提到的树没有特殊说明皆为 dfs 树。

**引理 1：若两个点 $u,v$ 满足 $u\leqslant v$，则任意一条 $u$ 到 $v$ 的路径都要经过dfs树上的 $LCA(u,v)$。**

然后你说为什么。树边肯定要跨 LCA，前向边和返祖边都不能跨越子树，而横叉边需要满足 $v\leqslant u$，因为如果反过来的话，即 $u$ 先搜到，那么横叉边就是由 $v$ 的子树引过来的。

**引理 2：$u\neq s$，$idom_u$ 必定为 dfs 树上 $u$ 的祖先**

如果不是，直接顺着 dfs 树往下跑就行了。

**引理 3：$u\neq s$，$sdom_u$ 必定为 dfs 树上 $u$ 的祖先**

如果不是，那就会在别的子树里，从别的子树的任意一个点 $v$ 到 $u$ 的路径必然经过 $LCA\left(u,v\right)$，而 $LCA\left(u,v\right)$ 必然不比 $u$ 大，与定义矛盾。

**引理 4：$idom_u$ 必定是 $sdom_u$ 的祖先。**

如果不是，有两种情况，第一种是 $idom_u$ 堵住了 $sdom_u$，则 $s$ 可以直接沿着搜索树往下找到 $u$，第二种是 $idom_u$ 堵住了 $s$，则 $s$可以沿着 $sdom_u$ 往下找到 $u$，这两种情况都与定义矛盾。

**引理 5：在搜索树上，所有 $idom_u$ 到 $u$ 的路径要么包含要么不交。**

如果不是那就说明有的点交了但只交了一部分，即 $idom_u$ 被路径 $(idom_v,v)$ 包含，$idom_u$ 肯定是 $idom_v$ 的真后代，他必然不支配 $v$，如果删掉他，$s$ 就可以沿着 $idom_v$ 到点 $v$ 再到点 $u$，与定义矛盾。

看上去非常厉害，我们拿这些引理来证明一下求解 $idom$ 的关键的 3 个定理。

**定理 1：对于dfs树上的一条路径 $(sdom_w,w)$，若路径上所有点的都满足 $sdom_u\geqslant sdom_w$，则 $idom_w=sdom_w$。**

意思就是 $sdom_w$ 到 $w$ 的路径完全包含了 $sdom_u$ 到 $u$ 的路径，由引理4可得，$idom_w$ 为 $sdom_w$ 的祖先，所以我们现在只需要证明 $sdom_w$ 支配 $w$。

考虑在 $s$ 到点 $w$ 的路径上找出最后一个**编号**小于 $sdom_w$ 的点 $x$，他显然能够到达 $sdom_w$ 到 $w$ 中的路径的一些点，我们称里面最小的点为 $y$，由前提条件可知，$sdom_y\geqslant sdom_w$，所以 $x\neq sdom_y$。考虑对于点 $y$，肯定能够找到一个点 $v$ 使得 $x$ 是 $v$ 的真祖先并且 $v$ 是 $y$ 的真祖先，因为 $x$ 是最小的，所以 $(sdom_w,v,w)$ 一定构成一条链。

如果是这样的话 $y$ 点和 $v$ 点就矛盾了，所以 $y$ 点和 $sdom_w$ 点之间不能有别的点，有别的点就一定能够向上面一样构造出一组 $v$把他替代，所以 $y=sdom_w$，即所有从 $s$ 到 $w$ 的道路都必须经过 $sdom_w$，即 $idom_w=sdom_w$。

**定理 2：对于 dfs 树上的一条路径 $(sdom_w,w)$，设 $u$ 为链上 $sdom_u$ 最小的点，若 $sdom_u\leqslant sdom_w$，则 $idom_w=idom_u$。**

由引理5可得，$idom_w$ 到 $w$ 的路径要么包含 $idom_u$ 到 $u$ 的路径要么与这条路径不交，又由引理 4 可得，$idom_w$ 必须是 $sdom_w$ 的祖先，所以 $idom_w$ 到点 $w$ 之间的路径必然包含 $idom_u$ 到 $u$ 的路径，我们只需要证明 $idom_u$ 是否支配 $w$ 即可。

这个证明类似定理 $1$，这里不再赘述。

我们把上面两个定理结合一下，发现一个弱智推论。

**推论 1：对于dfs树上的一条路径 $(sdom_w,w)$，设 $u$ 为链上 $sdom_u$ 最小的点，若 $sdom_u=sdom_w$，则 $idom_w=sdom_w$，若 $sdom_u<sdom_w$，则 $idom_w=idom_u$。**

注意到最小的 $sdom_u$ 必然不比 $sdom_w$ 要大，因为 $u$ 可以取 $sdom_w$。

根据推论1，我们已经可以用 $sdom$ 快速求出 $idom$ 了，问题变成了如何快速求出 $sdom$。

**定理 3：**![](https://pic.imgdb.cn/item/63759f6d16f2c2beb19e16c4.jpg)

**$sdom(w)=min(v|(v,w)\in E,v<w\bigcup sdom(u)|u>w,\exists(v,w)\in E,v\in (r\rightsquigarrow v))))$**

不会打latex所以直接截图。

upd：现在有latex啦！

这段式子翻译一下就是如果点 $v$ 满足 $v,w$ 之间直接有边相连，并且 $v<w$ 就能取 $v$，如果 $u>w$ 并且 $u$ 在从 $s$ 到 $w$ 的路径上同时 $u\neq w$就能取 $sdom_u$。

![](https://pic.imgdb.cn/item/6375aa8516f2c2beb1ae0ec7.jpg)

源自[link](https://www.luogu.com.cn/blog/Zenislt/qian-tan-zhi-pei-shu-lengauer-tarjan-algorithm)

有的地方 $sdom$ 打成 $sdow$ 了。

现在我们可以快速求出 $sdom$ 和 $idom$ 了，于是支配树我们就建完了。

考虑实现方法。

先求 $sdom$，首先是取 $v$ 的部分，这个可以直接建反图更新；然后是取 $sdom_u$ 的部分，根据定理3，只有 $u>w$ 的时候 $sdom_u$ 才能取到，那就倒序枚举 $dfn$。

考虑第二个条件如何满足，我们维护一个dfs树上的带权并查集（注意，这棵树是反图上的！），每次处理一个点就把他合并到他的父亲身上（注意，这个父亲是正图上的！），同时维护出一个并查集里面 $sdom$ 的最小值，每次可以直接更新。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> ljb[200005];
vector<int> G[200005];
vector<int> tree[200005];
int n,m;
int dfn[200005];
int rnk[200005];
int fa[200005];
int cnt;
void dfs(int cur){
    dfn[cur]=++cnt;
    rnk[cnt]=cur;
    for(int v:ljb[cur]){
        if(!dfn[v]){
            fa[v]=cur;
            dfs(v);
        }
    }
    return;
}
int father[200005];
int ans[200005];
int sdom[200005];
int idom[200005];
int res[200005];
int unionn(int x){
    if(father[x]==x)return x;
    int F=unionn(father[x]);
    if(dfn[sdom[ans[father[x]]]]<dfn[sdom[ans[x]]]){
        ans[x]=ans[father[x]];
    }
    return father[x]=F;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        ljb[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1);
    for(int i=1;i<=n;i++){
        sdom[i]=i;
        father[i]=i;
        ans[i]=i;
    }
    for(int i=cnt;i>1;i--){
        int tmp=rnk[i];
        for(int v:G[tmp]){
            if(!dfn[v])continue;
            unionn(v);
            if(dfn[sdom[tmp]]>dfn[sdom[ans[v]]]){
                sdom[tmp]=sdom[ans[v]];
            }
        }
        father[tmp]=fa[tmp];
        tree[sdom[tmp]].push_back(tmp);
        tmp=father[tmp];
        for(int v:tree[tmp]){
            unionn(v);
            if(tmp==sdom[ans[v]])idom[v]=tmp;
            else idom[v]=ans[v];
        }
        tree[tmp].clear();
    }
    for(int i=2;i<=cnt;i++){
        int tmp=rnk[i];
        if(idom[tmp]^sdom[tmp]){
            idom[tmp]=idom[idom[tmp]];
        }
    }
    for(int i=cnt;i>1;i--){
        res[rnk[i]]++;
        res[idom[rnk[i]]]+=res[rnk[i]];
    }
    res[1]++;
    for(int i=1;i<=n;i++){
        printf("%d ",res[i]);
    }
    return 0;
}
```

#### DAG 上支配树

[板子-灾难](https://www.luogu.com.cn/problem/P2597)

容易发现题目要求的就是每个点支配多少个点。

你说，诶，这不就是支配树板子？

多起点啊，所以我们虚拟出一个超级源点出来，连向所有入度为 $0$ 的点即可。

然后就直接跑支配树板子，注意这里每个点不能支配他自己。

这事还没完，考虑到这张图是个 DAG，你思考 DAG 可以干嘛，可以跑拓扑对吧，假设现在拓扑到第 $u$ 号点，那么 $idom_u$ 就是 $u$ 的所有前驱 $v$ 在支配树上的 LCA，这个东西不难证，首先 LCA 肯定支配 $u$ 的所有前驱的点，所以 LCA 肯定支配点 $u$，其次如果不这么做，比如说 LCA 往哪棵子树跑一下，就会使得某个前驱 $v$ 不再被 LCA 支配，而 $v$ 都不被支配，$u$ 可以顺着 $v$ 爬过来，于是 $idom_u$ 就是点 $u$ 的所有前驱的 LCA。

于是 DAG 上支配树就做完了。

时间复杂度 $O\left(n\log n\right)$。

一般图支配树代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> ljb[200005];
vector<int> G[200005];
vector<int> tree[200005];
int n,m;
int dfn[200005];
int rnk[200005];
int fa[200005];
int cnt;
void dfs(int cur){
    dfn[cur]=++cnt;
    rnk[cnt]=cur;
    for(int v:ljb[cur]){
        if(!dfn[v]){
            fa[v]=cur;
            dfs(v);
        }
    }
    return;
}
int father[200005];
int ans[200005];
int sdom[200005];
int idom[200005];
int res[200005];
int unionn(int x){
    if(father[x]==x)return x;
    int F=unionn(father[x]);
    if(dfn[sdom[ans[father[x]]]]<dfn[sdom[ans[x]]]){
        ans[x]=ans[father[x]];
    }
    return father[x]=F;
}
int main(){
    scanf("%d",&n);
    n++;
    for(int i=2;i<=n;i++){
        int k;
        scanf("%d",&k);
        if(k==0){
            ljb[1].push_back(i);
            G[i].push_back(1);
        }
        while(k){
            k++;
            ljb[k].push_back(i);
            G[i].push_back(k);
            scanf("%d",&k);
        }
    }
    dfs(1);
    for(int i=1;i<=n;i++){
        sdom[i]=i;
        father[i]=i;
        ans[i]=i;
    }
    for(int i=cnt;i>1;i--){
        int tmp=rnk[i];
        for(int v:G[tmp]){
            if(!dfn[v])continue;
            unionn(v);
            if(dfn[sdom[tmp]]>dfn[sdom[ans[v]]]){
                sdom[tmp]=sdom[ans[v]];
            }
        }
        father[tmp]=fa[tmp];
        tree[sdom[tmp]].push_back(tmp);
        tmp=father[tmp];
        for(int v:tree[tmp]){
            unionn(v);
            if(tmp==sdom[ans[v]])idom[v]=tmp;
            else idom[v]=ans[v];
        }
        tree[tmp].clear();
    }
    for(int i=2;i<=cnt;i++){
        int tmp=rnk[i];
        if(idom[tmp]^sdom[tmp]){
            idom[tmp]=idom[idom[tmp]];
        }
    }
    for(int i=cnt;i>1;i--){
        res[idom[rnk[i]]]+=res[rnk[i]]+1;
    }
    for(int i=2;i<=n;i++){
        printf("%d\n",res[i]);
    }
    return 0;
}
```

DAG 上支配树代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int> ljb[65550];
vector<int> G[65550];
vector<int> nt[65550];
int rd[65550];
int idom[65550][25];
int dep[65550];
int ans[65550];
int lca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i=20;i>=0;i--){
        if(dep[idom[x][i]]>=dep[y]){
            x=idom[x][i];
        }
    }
    if(x==y)return x;
    for(int i=20;i>=0;i--){
        if(idom[x][i]^idom[y][i]){
            x=idom[x][i];
            y=idom[y][i];
        }
    }
    return idom[x][0];
}
void toposort(){
    queue<int> q;
    q.push(1);
    while(!q.empty()){
        int tmp=q.front();
        q.pop();
        for(int v:ljb[tmp]){
            rd[v]--;
            if(!rd[v])q.push(v);
        }
        int LCA=0;
        for(int pre:G[tmp]){
            if(!LCA){
                LCA=pre;
                continue;
            }
            LCA=lca(LCA,pre);
        }
        idom[tmp][0]=LCA;
        dep[tmp]=dep[LCA]+1;
        for(int i=1;i<=20;i++){
            idom[tmp][i]=idom[idom[tmp][i-1]][i-1];
        }
    }
    return;
}
void dfs(int cur){
    ans[cur]=0;
    for(int v:nt[cur]){
        dfs(v);
        ans[cur]+=ans[v]+1;
    }
    return;
}
int main(){
    scanf("%d",&n);
    n++;
    for(int i=2;i<=n;i++){
        int k;
        scanf("%d",&k);
        if(k==0){
            ljb[1].push_back(i);
            G[i].push_back(1);
            rd[i]++;
        }
        while(k){
            k++;
            ljb[k].push_back(i);
            G[i].push_back(k);
            rd[i]++;
            scanf("%d",&k);
        }
    }
    toposort();
    for(int i=2;i<=n;i++){
        nt[idom[i][0]].push_back(i);
    }
    dfs(1);
    for(int i=2;i<=n;i++){
        printf("%d\n",ans[i]);
    }
    return 0;
}
```

#### 树上支配树

树上的支配树还可以随着树的形态的变化而动态变化。

[模板](https://www.luogu.com.cn/problem/P3690)

容易发现一棵树的支配树就是他自己，所以这个没有应用。

#### 总结

花里胡哨的支配树没一般图支配树好写好用好快。

没了。

---

## 作者：haochengw920 (赞：7)

# 支配树

作者写这篇文章的原因主要是现有题解要么就毫无证明，要么证明过程不太直观、概念不太清晰，在我的学习过程中困扰了我很久。

我是农历年前学的，由于实力比较弱，那时候经常坐在房间椅子上一个下午想这个算法，勉强看懂证明后草草放弃。这几天回想到这个算法，仔细思考想清楚了之后决定写下本文，方便给像我这样的学习者一个向导。

言归正传，由于作者我之前主要是根据 [这篇巨佬的文章](https://www.luogu.com.cn/article/8lpy3e1e) 学习的，因此在表示和论述方法上会有相似，但是证明过程和内容编排多数为自己的想法，使用了更感性的证明论述方法。如果您学术目的比较强，也可以去参考那篇文章。

## 注例

这里给出了一些本文符号代表的含义，读者不理解时可以来这里检索。

- 在本文中，使用 $u$ 代指 $dfn[u]$ ，关于 $u$ 的比较即为 $dfn$ 的比较。
- 文章中用 $u\overset{T}{\rightsquigarrow}v$ 表示 $u$ 到 $v$ 在 dfs 树上的路径，用 $u\overset{S}{\rightsquigarrow}v$ 表示在图上的路径。
- 本文中的 $lca$ 以及 $dep$ 默认指支配树上的 $lca$ / $dep$ ，如果指 dfs 树上的 $lca$ 会写作 $lca_T$ 。

## 定义

作者自己学习过程中的一大难点就是没有抓住准确的定义，经过摸索猜测联系下文等才理解。

这一部分会对支配，支配树， $dom$ ， $idom$ ， $sdom$ 等概念做出详细的文字以及图示描述。

- 支配 ： 对于一个图 $G=\{V,E\}$  ，给定源点 $S$ ，如果从 $S$ 出发到达 $u$ 的所有路径都必须经过点 $v$ ，则称 $v$ 支配 $u$ ，又作 $v\ dom\ u$ 。特别的， $S\ dom\ u$ 。

- 在 dfs 树上能 $dom\ u$ 的最深的点称为 $idom(u)$ 。

- 支配树 ： 除源点外，对每个点 $u$ 连一条 $(idom(u),u)$ 的边，形成的树即为支配树。对于 $u\neq S$ ，$idom(u) \neq u$ ，所以可以证明所形成的必为一棵树。

- $sdom$ ： 这是 Lengauer-Tarjan 算法的**核心**，请读者**注意** 。

  对于点 $w$ ，如果存在一条路径 $w\overset{S}{\rightsquigarrow}u$ ，满足路径上的所有点（不含两端）都大于点 $u$ ，则称 $w\ sdom\ u$ 。对于最小的满足条件的 $w$ ，即 $sdom(u) = w$ 。

读者可以结合图示理解 $sdom(u)$ 跳到 $u$ 的过程 ： 

![](https://cdn.luogu.com.cn/upload/image_hosting/w0hvictm.png)

文字描述：最小的 $sdom(u)$ 先走向一个大链，再不断向树边或前向边走再跳到一个较轻链，直至到达 $u$ 。满足这个结构的深度最低的点即为 $sdom(u)$ 。

注：理解 $sdom$ 的过程中，请紧扣 dfs 树的一个性质——只有前向边和树边可以增加 dfn ，返祖边和**横插边**都会减小 dfn。

## 引理

这一部分删去了一些显然的结论，保留了重要的、与证明紧连的结论，后面会进行引用。

- 引理 1 ： 对于任意点 $u$ ， $idom(u)$ 一定是 $u$ 的祖先。

- 引理 2 ： 对于任意点 $u$ ， $sdom(u)$ 一定是 $u$ 的祖先。更一般的，如果有点 $w\ sdom\ u$ ，那么 $w$ 也一定是 $u$ 的祖先。

- 引理 3 ： 对于任意点 $u$ ， $idom(u)$ 一定是 $sdom(u)$ 的祖先或本身。

  考虑 $sdom(u)$ 已经有两条路， $sdom(u)\overset{T}{\rightsquigarrow}u$ 和 $sdom(u)\overset{S}{\rightsquigarrow}u$ ，所以 $idom(u)$ 必须支配 $sdom(u)$ ，结合引理 1 可得证。

- 引理 4 ： $S$ 到 $u$ 的路径一定要经过 $sdom(u)\overset{T}{\rightsquigarrow}u$ （左闭右开）链上的点。

  证明 ： 

  1. $sdom(u) = S$ ，显然成立。

  2. 把 $T$ 分为 3 部分， $[S,sdom(u))$ ， $[sdom(u), u)$ ，$[u, n]$ ，命名为第一、二、三部分；

     $S$ 属于第一部分， $u$ 属于第三部分，必然经过。若不经过第二部分，则必有点 $v \in [S,sdom(u))$ 满足半支配条件，违背了 $sdom(u)$ 的最小性。 

## 求解 $sdom(u)$ 

先抄一个公式 ： 

- 定理 1 ： $sdom(u)=min(\{v|(v,u)\in E,v<u\}\cup\{sdom(w)|w>u\land\exists v>u,(v,u)\in E,s.t.\ w是v的祖先或w=v\})$ 。

这个定理可以看成一个 DP 过程，即枚举临点转移的过程。

1. 对于前半部分，由于 $sdom(u)\overset{S}{\rightsquigarrow}u$ 只能经过比 $u$ 大的点，链的起始点只能到 $v$ 为止了。
2. 对于后半部分，即枚举最后一条链的长度，即枚举上一条链是跳到最后一条链的哪一个点的。

其中，后面一种情况的枚举过程可以使用并查集优化，具体见下文代码实现。

## 求解 $idom(u)$ 

### 方法一

首先需要 DAG 上求支配树的基础，不会的可以去做做 [P2597 ZJOI2012\] ](https://www.luogu.com.cn/problem/P2597) 这道题。

过程 ： 对每个点 $u\neq S$ 在 dfs 树上连边 $(sdom(u),u)$ ，然后跑 DAG 上支配树。

注：作者想了很久，没有想到特别直观的证明方法，如果读者不能理解下文可以先看方法二。

证明 ： 其实就是证明 $idom(u)=lca(sdom(u),fa_u)$ ，显然 $dep_{sdom(u)} \ge dep_{fa_u}$ 。

1. $sdom(u)=fa_u$ ，即没有点能通过一条大链到达 $u$ ，故 $idom(u)=fa_u$ 。

2. $sdom(u) < fa_u$ ，

   此时 $lca(sdom(u), fa_u)=lca(sdom(u),idom(fa_u))$ （因为支配树上 $fa_u$ 就挂在 $idom(fa_u)$ 下面）。

   $idom（fa_u)$ 保证了树边的不可达， $sdom(u)$ 保证了假如有点不经过 $lca$ 到达 $u$ ，必须要先跳到 $sdom(u)\overset{T}{\rightsquigarrow}u$ 的链上（引理 4 ）。

   我们假设这个点为 $y$ ， $y$ 连接的点为 $r$ ，则 $lca_T(sdom(u),r)$ 满足 $y$ 的 $sdom$ 条件。根据引理 2 ， $sdom(y)$ 一定为 $lca_T$ 的祖先或本身。又根据引理 3 ， $y\overset{T}{\rightsquigarrow}u$ 从 $y$ 开始就已经挂在 $idom(y)$ 下面了，这使 $lca(sdom(u),idom(fa_u)$ 一定是 $lca_T(sdom(u),r)$ 在 dfs 树上的祖先了，路径被 $dom$ 。

### 方法二

优雅的解法，下文给出了简洁的证明，也是本文对比其他题解的优势所在。

设 $v$ 是 $sdom(u)\overset{T}{\rightsquigarrow}u$ 链上 $sdom$ 最小的点，分类讨论 ： 

1. 若 $sdom(v) \ge sdom(u)$ ，则 $idom(u)=sdom(u)$ 。

   证明 ： 根据引理 4 ， $S$ 要到 $u$ 一定要经过 $sdom(u)\overset{T}{\rightsquigarrow}u$ 链上的点，设到达点 $r$ ，但因为 $sdom(r)\ge sdom(u)$ ，到达 $r$ 又要经过，$sdom(u)\overset{T}{\rightsquigarrow}r$ ，可以用无穷递降法证明 $r$ 不存在。

2. 若 $sdom(v) \ge sdom(u)$ ， 则 $idom(u)=idom(v)$ 。

   证明 ： “最小”保证了不会有点从 $idom(v)$ 上方跳到 $sdom(u)\overset{T}{\rightsquigarrow}u$ ，“ $idom$ ”保证了不会有点从 $idom(v)$ 上方跳到 $idom(v)\overset{T}{\rightsquigarrow}sdom(u) \in idom(v)\overset{T}{\rightsquigarrow}v$ 。

综上所述，$ idom(u) = \begin{cases}  sdom(u) & \text{} sdom(v) = sdom(u) \land v=fa_u\\idom(v) & \text{otherwise}\end{cases} $ 。

可以使用并查集优化。

## 代码实现

可以参考代码理解。

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;

const int MAXN = 200005, MAXM = 300005;

int n, m;
class Graph {
	private : 
	struct edge {
		int to, nex;
	}e[MAXM]; int idx;
	public : 
	int head[MAXN];
	inline void add(int u, int v) {
		e[++ idx].to = v;
		e[idx].nex = head[u];
		head[u] = idx; 
	}
	inline edge operator [] (const int &x) const {
		return e[x];
	}
}G, F, T;
int fa[MAXN], sum[MAXN];
int timer, id[MAXN], dfn[MAXN]; 
int sdom[MAXN], idom[MAXN];
inline void dfs(int u) {
	id[dfn[u] = ++ timer] = u;
	for (int i = G.head[u]; i; i = G[i].nex) {
		int v = G[i].to;
		if (dfn[v]) continue;
		fa[v] = u; dfs(v);
	}
}
struct Dsu {
	int fa[MAXN], mn[MAXN];
	inline Dsu() {
		for (int i = 1; i < MAXN; ++ i)
			fa[i] = mn[i] = i;
	}
	inline int pushll(int x) {
		if (x == fa[x]) return x;
		int tmp = pushll(fa[x]);
		if (dfn[sdom[mn[fa[x]]]] < dfn[sdom[mn[x]]]) mn[x] = mn[fa[x]];
		return fa[x] = tmp;
	}
}d;
vector<int>vec[MAXN];
inline int Calc(int u) {
	sum[u] = 1;
	for (int i = T.head[u]; i; i = T[i].nex) {
		int v = T[i].to;
		sum[u] += Calc(v);
	}
	return sum[u];
}
inline void Solve() {
	dfs(1);
	for (int i = 1; i <= n; ++ i) sdom[i] = i;
	for (int t = timer; t; -- t) {
		int u = id[t];
		for (int v : vec[u]) {
			d.pushll(v);
			if (sdom[d.mn[v]] == u) idom[v] = u;
			else idom[v] = d.mn[v];
		}
		if (t == 1) continue;
		for (int i = F.head[u]; i; i = F[i].nex) {
			int v = F[i].to;
			if (dfn[v] < dfn[sdom[u]]) sdom[u] = v;
			else if (dfn[v] > dfn[u]) {
				d.pushll(v);
				if (dfn[sdom[d.mn[v]]] < dfn[sdom[u]]) sdom[u] = sdom[d.mn[v]];
				
			}
		}
		vec[sdom[u]].push_back(u);
		d.fa[u] = fa[u];
	}
	for (int t = 2; t <= timer; ++ t)
		if (idom[id[t]] != sdom[id[t]])
			idom[id[t]] = idom[idom[id[t]]];
	for (int i = 2; i <= n; ++ i) T.add(idom[i], i);
	Calc(1);
}

int main()
{
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= m; ++ i) {
		int u, v; scanf ("%d%d", &u, &v);
		G.add(u, v); F.add(v, u);
	}
	Solve();
	for (int i = 1; i <= n; ++ i)
		printf ("%d ", sum[i]);
	return puts(""), 0;
}
```

---


# [集训队互测 2023] 基础寄术练习题

## 题目描述

对于长度为 $n$ 的序列 $a$，定义 $f(a)=\dfrac{1}{\prod\limits_{i=k}^ns_i}$，其中 $s_i$ 为 $\{a_n\}$ 的前缀和数组，**$k$ 是给定的常数且 $1\le k\le 2$**。

考虑所有满足以下三个条件的序列 $a$：

- $a$ 的长度为 $n$。
- $\forall i,j$，$a_i\ne a_j$。
- $1\le a_i\le m$。

求它们的 $f(a)$ 之和，答案对 $p$ 取模。保证 $p$ 是一个质数。

## 说明/提示

对于所有数据，保证 $2\le n\le m\le 100$，$10^8<p<1.07\times 10^9$ 且 $p$ 为质数，$1\le k\le 2$。

- Subtask 1 (10 pts)：$m\le 20$。
- Subtask 2 (25 pts)：$k=1$。
- Subtask 3 (15 pts)：$n=m\le 30$。
- Subtask 4 (10 pts)：$m\le 30$。
- Subtask 5 (15 pts)：$m\le 40$。
- Subtask 6 (10 pts)：$m\le 70$。
- Subtask 7 (15 pts)：$m\le 100$。

## 样例 #1

### 输入

```
2 3 2 1000000007```

### 输出

```
966666675```

## 样例 #2

### 输入

```
3 5 2 998244353```

### 输出

```
148276980```

## 样例 #3

### 输入

```
6 10 2 1004535809```

### 输出

```
622165218```

## 样例 #4

### 输入

```
15 20 2 1064822107```

### 输出

```
53789887```

## 样例 #5

### 输入

```
30 40 1 265371653```

### 输出

```
179937201```

# 题解

## 作者：隔壁泞2的如心 (赞：6)

首先，这题要求的是前缀和的积的倒数的和，你知道淘米神的树吧？没错，和这题没什么关系（

但这启发我们考虑构造一棵树，使得最后答案和某棵树的拓扑序数挂钩。我们构造一棵“右偏树”，每个点只有最右方的儿子不为叶子，深度为 $i$ 的非叶子结点有 $a_{n+1-i}$ 个叶子儿子，然后按照 bfs 序给它们编号，这样寄术题就被转化为计数题。先枚举总结点数 $N$，再枚举拓扑序排列，最后考虑有多少种树结构可能存在上述拓扑序。你会发现，这个排列只有前缀最小值可能成为非叶子结点，所以我们理所当然地考虑第一类斯特林数状物。对于一个固定的 $N$，我们只要求出一个长为 $N$ 的，满足置换环长均在 $m$ 以内且两两不同的排列，然后把每个置换环按其中最小值排序，然后最小值作为非叶子，就一定可以构造出一棵树！所以当 $k=1$ 时，总结点数为 $N$ 的答案就是上述排列的数量除以 $N!$，由于除了阶乘，这一部分的 $dp$ 甚至不需要记录当前总结点数，复杂度为 $O(n^2)$！

然后考虑 $k=2$，我们要做的其实就是把最下面的非叶子节点的子树大小再乘回去。可是，这其实极其困难，因为我们确定完排列置换环长集合后，该如何找到哪个环将来的最小值最大，需要被乘回去呢？这个最小值最大模型，你知道猎人杀吧？没错，和这题没什么关系（

~~upd：哦好吧，刚才我发现其实它和猎人杀的关系还是很大的，基本是一个容斥思路，原来只有我做那题没用容斥（~~

但这启发我们进行类似的转化，把这些置换环想象为一些体积不同的人，然后随机枪毙他们，每人每回合被枪毙概率和其体积成正比，我们要求的就是最后被枪毙的人的期望体积。你想到了什么？min-max 容斥！最后被枪毙的人的期望体积不好求，但我们可以求某集合里第一个被枪毙的人的期望体积啊！那么我们在前面 dp 的基础上，额外记录一维，表示当前被 min-max 容斥枚举的集合的总体积，然后此题就做完了！

时间复杂度 $O(n^4)$，常数也不大（

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#define int long long
#define add(a,b) (a+=(b),a>=mod?a-=mod:0)
#define neg(x) ((x)&1?mod-1:1)
#define Q(a,b) C((a)+(b)-1,(b)-1)
using namespace std;
int inv[407693],mod;
inline int qpow(int n1,int n2){
    int n3=n1,n4=1;
    while(n2){
        if(n2&1)n4*=n3,n4%=mod;
        n3*=n3,n3%=mod;n2>>=1;
    }return n4;
}
inline int mut(initializer_list<int> arg){
    int ret=1;
    for(auto i:arg)ret*=i,ret%=mod;
    return ret;
}
int n,m,k,dp[300][300],pd[2][101][5340],pe[2][101][5340]; 
signed main(){
    scanf("%lld%lld%lld%lld",&n,&m,&k,&mod);
    for(int i=1;i<=9876;i++)inv[i]=qpow(i,mod-2);
    if(k==1){
    dp[0][0]=1;
    for(int i=1;i<=m;i++){
        for(int j=0;j<=i;j++){
            if(j>0)dp[i][j]+=dp[i-1][j-1]*inv[i]%mod;
            dp[i][j]+=dp[i-1][j];
            dp[i][j]%=mod;
        }
    }
    printf("%lld",dp[m][n]);
    }
    else{
        pd[0][0][0]=mod-1;
        for(int i=1;i<=m;i++){
            for(int j=0;j<=i;j++){
                int r=(i+i-j)*j/2;
                for(int h=0;h<=r;h++){
                    pd[~i&1][j][h]%=mod;
                    pe[~i&1][j][h]%=mod;
                    pd[i&1][j][h]+=pd[~i&1][j][h];
                    pe[i&1][j][h]+=pe[~i&1][j][h];
                    pd[i&1][j+1][h]+=pd[~i&1][j][h]*inv[i]%mod;
                    pe[i&1][j+1][h]+=pe[~i&1][j][h]*inv[i]%mod;
                    pd[i&1][j+1][h+i]+=(mod-pd[~i&1][j][h])*inv[i]%mod;
                    pe[i&1][j+1][h+i]+=(mod+mod-pe[~i&1][j][h]-pd[~i&1][j][h]*i%mod*i%mod)*inv[i]%mod;
                    pd[~i&1][j][h]=0;
                    pe[~i&1][j][h]=0;
                }
            }
        }
        int ans=0;
        for(int i=1;i<=(m)*(m+1)/2;i++)ans+=pe[m&1][n][i]*inv[i],ans%=mod;
        printf("%lld",ans);
    }
}
```


---

## 作者：nullqtr_pwp (赞：3)

搬运下官方题解。

现有的另一篇题解的做法是将"前缀和积"映射到树的拓扑序数上，两种做法的第一步都是将它转化掉。

以下的 $\binom{\sum a_i}{a_1,a_2,\cdots,a_k}$ 指的是将 $\sum a_i$ 个球，第 $i$ 种有 $a_i$ 个，相同种球都相同，整体排列的不同方案数，此时为 $\prod\frac{1}{a_i!}\times(\sum a_i)!$。

## $k=1$

分子上的东西我们通常可以通过累加的技巧解决，但是这个题的分母非常神秘，是前缀和积的倒数，因此考虑优先解决**分母**上的问题。

考虑一个组合模型：有一个序列，有 $n$ 种数，第 $i$ 种有 $a_i$ 个，一共有 $\sum a_i$ 个数，要计算有多大的**概率**随机重排整个序列，使得对于第 $i$ 种数最后一次出现的位置 $R_i$，序列 $R$ 单调递增。答案是，考虑**倒序**确定当前未填数的位置，最后一个必须分给当前数种类最大的，求概率乘法原理即可。写成式子就是：

$$
g(a)=\prod_{i=1}^n\dfrac{a_i}{\sum_{j=1}^i a_j}
$$

bonus：将这个问题高维化之后，就是[【CTS2019】随机立方体](https://uoj.ac/problem/472) 的做法，解决方法是相同的。

注意到这种形式就是前缀和积倒数，考虑进一步拓展这个思想，对于一个 $a_1<a_2<\cdots<a_n$，考虑 $a_i$ 的所有排列的 $g(a)$ 的和。从整体上考虑直接 $\sum a_i$ 个球进行多重集组合数。注意到 $R_i$ 在不考虑具体赋哪种颜色时是存在且唯一的，所以每一种排列都存在贡献。因此一个有序 $a_i$ 的所有排列的 $g(a)$ 的和 $=1$，即必然存在。整理可得：

$$
\sum_{a'} \dfrac{\prod_{i=1}^n a'_i}{\prod_{i=1}^n s_i}=\left (\prod_{i=1}^n a_i\right )\times \sum_{a'}\dfrac{1}{\prod_{i=1}^n s_i}=1
$$

所以 $f(a)$ 的和是 $\dfrac{1}{\prod_{i=1}^{n}a_i}$。

$k=1$ 时，答案就是：
$$
\sum_{S\subseteq\lbrace 1,2,\cdots,m\rbrace,|S|=n}\left(\prod_{i\in S}\dfrac{1}{i}\right)
$$

容易用背包 $O(n^2)$ 求解，可以通过子任务 $2$。

## $k=2$

相当于每个序列都有 $a_1$ 的权值。考虑枚举 $a_1=val$，并且对于给定 $S$，固定$\lbrace a_2,a_3,\cdots,a_n\rbrace=\lbrace1,2,\cdots,m\rbrace\setminus\lbrace val\rbrace=S$ 的做法。

考虑最终一起统计的时候，每个排列的 $R_i$ 单调递增可以不考虑，但是我们要求 $R_1$ 必须是 $R$ 中最小的。

正难则反，考虑容斥钦定一个集合 $T$ 使得 $\forall i\in T,R_i<R_1$，容斥系数显然是 $(-1)^{|T|}$。方案数显然为，$T,a_1$ 内部考虑加上其余的方案数，令 $p=\sum_{i\in T}i$。贡献为：

$$
\binom{p}{T_1,T_2,\cdots,T_{|T|}}\binom{a_1-1+p}{a_1-1}\binom{\sum_{i=1}^n a_i}{p+a_1,}
$$

逐个理解即可，除以总个数就是多重集组合数之后累计进答案，这个分式化简后为 $\dfrac{a_1}{a_1+p}$。因此对于固定的 $S$，求出 $\sum_{T\subseteq S}(-1)^{|T|}\frac{a_1}{a_1+\sum_{i\in T}i}$ 即可。


考虑整体做法，使用 DP 加速枚举子集。设 $f_{i,j,k,0/1}$ 表示：考虑前 $i$ 个数中选，$\sum_{t\in T} t=j,|S|=k$，$a_1$ 是否已经选入 $T$ 的容斥系数和。将 $a_1$ 扔进分母，最后统计答案时计算即可。

时间复杂度 $O(n^4)$。

```cpp

namespace A{
	int f[105][105];
	void solve(){
		f[0][0]=1;
		F(i,1,m) F(j,0,min(i,n)) f[i][j]=add(f[i-1][j],(j==0)?0:(1ll*f[i-1][j-1]*inv[i]%mod));
		printf("%d",f[m][n]);
	}
}
namespace B{
	int f[2][105][10005][2];
	void solve(){
		f[0][0][0][0]=1;
		int ans=0;
		F(i,1,m){
			const int cur=i&1,lst=cur^1;
			F(j,0,n-1)F(k,0,i*m)F(l,0,1){
				f[cur][j][k][l]=f[lst][j][k][l];
				if(j>0) inc(f[cur][j][k][l],1ll*inv[i]*f[lst][j-1][k][l]%mod);
				if(j>0&&k>=i) dec(f[cur][j][k][l],1ll*inv[i]*f[lst][j-1][k-i][l]%mod);
				if(l>0&&k>=i) inc(f[cur][j][k][l],1ll*i*f[lst][j][k-i][0]%mod);
			}
		}
		F(i,1,m*m) inc(ans,1ll*inv[i]*f[m&1][n-1][i][1]%mod);
		printf("%d",ans);
	}
}
void solve(){
	n=read(),m=read(),k=read(),mod=read();
	init(maxn-3);
	if(k==1) return A::solve(),void();
	if(k==2) return B::solve(),void();
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10005)

**题目大意**

> 定义一个长度为 $n$ 的序列 $a$ 的权值为 $\prod_{i=k}^n s_i^{-1}$，其中 $s_i$ 是 $a_i$ 的前缀和。
>
> 给定 $n,m,k$，求所有长度为 $n$ 值域 $[1,m]$ 且互不相同的序列的权值和。
>
> 数据范围：$n,m\le 100,k\in\{1,2\}$。

**思路分析**

从 $k=1$ 开始，其代价函数为 $\prod s_i^{-1}$，直接维护不可做，考虑设计组合意义并转化。

可以设计出如下的问题：

对于 $i\in[1,n]$，颜色为 $i$ 的球有 $a_i$ 个，将他们的排列随机打乱，要求第 $i$ 种颜色的球的最后一次出现位置比第 $i+1$ 种颜色的球的最后一次出现位置早。

考虑每种颜色依次插入，得到的总概率就是 $\prod\limits_{i=1}^n \dfrac{a_i}{s_i}$。

假设我们确定了所有 $a_i$ 构成的无序集合，那么对于一组球的排列，一定有唯一一组 $a_i$ 的排列与之对应使其符合条件（按每种颜色最后出现位置排序）。

因此确定所有 $a_i$ 构成的无序集合后，$\sum\prod_{i=1}^n\dfrac{a_i}{s_i}=1$，那么这种情况的 $\prod s_i^{-1}=\prod a_i^{-1}$。

因此我们 dp 求出 $1\sim m$ 选 $n$ 个元素，选 $k$ 权值为 $\dfrac 1k$ 时的权值和。

然后考虑 $k=2$ 的情况。

此时相当于给答案 $\times a_1$。

假如我们钦定一组 $a_1\sim a_n$，那么答案就是前一问排列合法的概率乘以 $a_1$，先计算排列合法的概率。

此时 $a_1$ 一定是最后一次出现最靠前的颜色，这不好处理，考虑容斥，即钦定一个集合 $B$ 中的元素最后一次出现比 $a_1$ 早，设他们对应的球数为 $b_1\sim b_t$。

求对应的方案数，先排列 $b_1\sim b_t$，然后插入 $a_1$，最后插入其他元素，记 $S_B=\sum b_i$ 得到：
$$
\binom{S_B}{b_1,\dots,b_k}\binom{S_B+a_1-1}{S_B}\dfrac{A!}{(S_B+a_1)!\prod_{i\not\in B}a_i!}
$$
化简得到原式等于：
$$
\binom{A}{a_1,a_2,\dots,a_n}\dfrac{a_1}{S_B+a_1}
$$
注意到我们求的是概率，因此前面那个表示方案数的式子需要除掉。

因此一组 $B$ 对答案的贡献就是 $(-1)^{|B|}\dfrac{a_1}{S_B+a_1}$，答案就是：
$$
\sum_a a_1\times \prod_{i}\dfrac 1{a_i}\sum_B (-1)^B\dfrac{a_1}{S_B+a_1}
$$
考虑直接 dp 维护，设 $f_{i,j,s,0/1}$ 表示考虑值域为 $[1,i]$ 的数，选了 $j$ 个元素进 $a$，$S_B+a_1=s$，是否选定 $a_1$ 的答案。

转移时枚举 $i+1$ 是不放、当 $a_1$、放入 $B$、放入 $\overline B$ 中的哪一种情况即可转移。

时间复杂度 $\mathcal O(m^4)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=105,MAXS=1e4+5;
int n,m,k,MOD;
ll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }
ll inv[MAXS];
namespace k1 {
ll f[MAXN];
void main() {
	f[0]=1;
	for(int i=1;i<=m;++i) for(int j=n;j;--j) f[j]=(f[j]+f[j-1]*inv[i])%MOD;
	printf("%lld\n",f[n]);
}
}
namespace k2 {
int up[MAXN];
ll f[MAXN][MAXS][2],g[MAXN][MAXS][2];
void add(ll &x,ll y) { x=(x+y)%MOD; }
void main() {
	for(int i=1;i<=m;++i) up[i]=(i<=n)?i*(i+1)/2:up[i-1]+n;
	f[0][0][0]=1;
	for(int i=1;i<=m;++i) {
		memcpy(g,f,sizeof(g));
		for(int j=0;j<n;++j) for(int s=0;s<=up[i-1];++s) for(int o:{0,1}) {
			ll &w=f[j][s][o]; if(!w) continue;
			add(g[j+1][s][o],inv[i]*w); //choose in A
			add(g[j+1][s+i][o],(MOD-inv[i])*w); //choose in B
			if(!o) add(g[j][s+i][1],i*w); //choose as a[1]
		}
		memcpy(f,g,sizeof(f));
	}
	ll ans=0;
	for(int s=0;s<=up[m];++s) ans=(ans+f[n-1][s][1]*inv[s])%MOD;
	printf("%lld\n",ans);
}
}
signed main() {
	scanf("%d%d%d%d",&n,&m,&k,&MOD);
	for(int i=1;i<MAXS;++i) inv[i]=ksm(i);
	k==1?(k1::main()):(k2::main());
	return 0;
}
```

---


# [集训队互测 2023] 落日珊瑚

## 题目描述

给一个长度为 $n$、包含方括号和圆括号的括号串，定义一个串 $S$ 合法，当且仅当以下几种情况之一：

1.  $S$ 为空串；
1.  $S= [T]$ 且 $T$ 合法；
1.  $S= (T)$ 且 $T$ 合法；
1.  $S=TU$ 且 $T, U$ 合法。

比如 ```()```，```[()]``` 都是一个合法的括号串，但 ```[()]())``` 不是。

定义一个操作叫选择一个区间 $[l, r]$，并把所有在区间里的字符从方括号变圆括号，从圆括号变方括号。

定义一个括号串的权值 $val(S)$ 为：如果这个括号串能通过操作变成合法，就是最小的操作次数；否则是 $0$。

给出 $q$ 次修改查询，有以下两种可能。

1.  修改，给出一个区间 $[l, r]$ 把所有在区间里的字符从方括号变圆括号，从圆括号变方括号。
2.  查询，给出一个区间 $[l, r]$，求 $\sum_{[l', r'] \in [l, r]} val(s[l', r'])$。

## 说明/提示

对于所有数据，$1 \le n, q \le 5\cdot 10^5$，$0 \le T \le 10^9$，$1 \le l, r \le n$，$1 \le opt \le 2$。

| 子任务编号 |  $n, q \le $  | 特殊性质 | 分值 |
| :--------: | :-----------: | :------: | :--: |
|     1      |      $100$      |    E     |  5   |
|     2      |     $6000$      |    E     |  5   |
|     3      |    $10^5$     |    AE    |  5   |
|     4      | $2\cdot 10^5$ |    BE    |  5   |
|     5      | $2\cdot 10^5$ |   CDE    |  5   |
|     6      | $2\cdot 10^5$ |    CE    |  10  |
|     7      | $2\cdot 10^5$ |    DE    |  10  |
|     8      | $2\cdot 10^5$ |    E     |  10  |
|     9      | $2\cdot 10^5$ |    无    |  20  |
|     10     | $5\cdot 10^5$ |    无    |  25  |



A 性质：每个位置有 $\frac{1}{4}$ 的概率为方圆左右括号。

B 性质：保证没有修改。

C 性质：保证修改为单点修改。

D 性质：保证查询区间 $[l, r]$ 满足 $S[l, r]$ 经过若干次操作可以变成合法串，且不存在另一个 $k \in [l, r)$，使得 $S[l, k]$ 可以经过若干次操作变成合法串。

E 性质：保证 $T = 0$，即可以离线。

## 样例 #1

### 输入

```
10 10 0 0
[)]]((()][
2 10 6
1 6 6
1 3 6
2 5 7
2 3 3
2 10 4
1 7 1
2 4 4
2 4 2
1 5 5
```

### 输出

```
1
0
0
1
0
0
```

## 样例 #2

### 输入

```
20 20 0 0
[)])[)[](()((]]([[)[
2 9 3
2 8 10
1 4 15
1 5 9
1 16 10
1 18 20
1 1 8
2 8 9
1 2 16
1 10 13
1 16 9
1 8 1
2 20 7
2 14 11
1 3 16
1 15 18
1 6 4
2 10 7
2 2 4
2 13 2
```

### 输出

```
2
0
0
1
2
1
0
4
```

# 题解

## 作者：Lynkcat (赞：13)

最喜欢的一集

首先思考一下查询一个串的最小操作次数怎么求。我们把括号树建出来，匹配的一对括号若不同则权值为 $1$ 否则是 $0$，发现翻转一个子串上的字符相当于翻转树上一条路径上的边权。那么问题就变成了最小操作次数使得全翻转成 $0$。这是一个经典问题，定义 $d_i$ 表示相邻 $1$ 边条数，答案为 $d$ 为奇数的点的个数除以二。

到这里还算阳间，让我们来看看原题还需要支持啥，需要支持区间 flip 跟区间查询“子区间”的答案的和。

首先我们知道区间 flip 是路径翻转了，不过需要注意的是原串不保证合法需要补成合法的串建括号树。区间内查询子区间的答案的和就很阴间了。首先我们发现一个区间不仅可以看成一条路径，还可以看成若干个子树的并。我们考虑怎么方便维护这些信息。

考虑直接上个静态 top tree 看看。

首先对于每个点的度数是奇数的个数拆成除根以外每个点的本身 $d$ 为奇数的个数和 $+$ 根连向每个儿子的 $1$ 边条数（设为 $d'$）是否为奇数。

考虑类似 rake 形式的合并。

维护 $f_i$ 表示 $i$ 子树内所有方案的答案和，$s_i$ 为 $i$ 子树内 $d$ 是奇数的个数。现在 $k$ 的儿子集合是 $S_k$，我们需要把这些儿子的信息合并起来。

建立 rake 树，每个虚点需要维护 $pre_{0/1},suf_{0/1}$ 表示每个前缀/后缀且根目前 $d'$ 为 $0/1$ 的答案的和/方案数，合并的时候考虑把 $pre$ 与 $suf$ 合并起来就行。

再考虑类似 compress 形式的合并，在 compress 树上我们发现可以记当前虚点代表的重链区间的两端是否为 $0/1$ 的所有方案的数量跟答案和，每次合并能把中间的这个点的贡献算出来。

信息的合并方式大概搓出来了，现在还有一个问题是路径 flip 还有查询。

路径 flip 是可以做的，只需要在 compress 树上加一个区间 flip 的操作还有在 rake 树上进行单点修改。

查询的话发现需要拆成这几部分：$x$ 的某个儿子区间的 $f$ 的和；$x \to lca$ 链的右半部分儿子 $f$ 的和；$lca$ 的某个儿子区间的 $f$ 的和；$lca \to y$ 链的左半部分的 $f$ 的和；$y$ 的某个儿子区间的 $f$ 的和。也就是说儿子的顺序也是影响答案的，所以需要在 compress 树上维护左右的答案的和。

那么大体整个题这样做就做完了。

代码：这是碰都不能碰的花题。

---


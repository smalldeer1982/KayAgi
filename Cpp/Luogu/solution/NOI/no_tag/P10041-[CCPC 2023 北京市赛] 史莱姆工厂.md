# [CCPC 2023 北京市赛] 史莱姆工厂

## 题目描述

有 $n$ 个史莱姆排成一行，其中第 $i$ 个的颜色为 $c_i$，质量为 $m_i$。

你可以执行任意次把一个史莱姆的质量增加 $1$ 的操作，需要花费 $w$ 的价钱。

但是一旦史莱姆的质量达到 $k$ 或以上，就会变得不稳定而必须在下一次操作之前被卖掉。你只能卖出质量大于等于 $k$ 的史莱姆。根据市场价，卖掉一个质量为 $i$ 的史莱姆可以得到 $p_i$ 的收入。保证 $p_i-p_{i-1}<w$。但不保证 $p_i$ 单调不降。

卖掉一个史莱姆之后，它两边的史莱姆会被挤压继而靠在一起。如果这两个史莱姆颜色相同，那么就会互相融合成一个史莱姆，其质量是二者的质量之和。这个新的史莱姆也有可能需要被卖掉从而接着进行这个过程。

你想知道卖掉所有史莱姆最多可以净赚多少。

## 说明/提示

先增加颜色为 $3$ 的史莱姆的质量。然后它被卖掉，获得 $5$ 的收入。

然后增加颜色为 $1$ 的史莱姆的质量两次。然后它被卖掉，获得 $5$ 的收入。接着两个颜色为 $2$ 的史莱姆融合在一起卖掉，获得 $7$ 的收入。

操作了三次需要 $18$ 的花费，所以净利润为 $-1$。可以证明不存在更好的方案。

## 样例 #1

### 输入

```
4 5 6
2 1 2 3
3 3 3 4
5 7 9 11```

### 输出

```
-1```

# 题解

## 作者：E.Space (赞：8)

考虑最后一次卖的那个史莱姆是由最初的哪些史莱姆合并成的。

这些史莱姆是原序列的一个子序列。它们需要满足哪些性质呢？

首先肯定必须同色。然后考虑最后一次合并之前的情况。

- 如果没有最后一次合并，也就是说，这个子序列只包含一个史莱姆，那么一定可行。这时需要增加 $k-m_i$ 次质量，这次卖出可以获得 $p_k-(k-m_i)w$ 的收益。
- 如果存在最后一次合并，由于任何时刻史莱姆的质量不能大于等于 $k$，否则会被立即卖掉，所以合并之前的两个史莱姆的质量必须均小于 $k$。也就是说，这个子序列必须能够分成前后两段，使得每一段的质量和均小于 $k$。由于题目保证了 $p_i-w<p_{i-1}$，所以如果需要增加质量，一定存在一种最优解是在最后一次合并之后再开始增加质量。所以，如果整个子序列的质量总和仍小于 $k$，那么卖出收益是 $p_k-(k-sum)w$，否则是 $p_{sum}$。为方便起见，对 $1\le i <k$ 定义 $p_i=p_k-(k-i)w$。

这时，原序列被这个子序列分割成了若干极长连续段，每个极长连续段都不包含子序列中的史莱姆。由于选中的子序列是最后被卖掉的，所以这些被分割出来的连续段之间一定互不干扰，也就是说，在任何连续段之内的操作都不会影响到其他连续段的状态。于是就可以区间 DP 了。

然后，为了保证最后一次卖出的史莱姆恰好是选中的子序列，需要保证分割出来的连续段中最后一次卖出的史莱姆的颜色不能与连续段之外两侧的颜色相同，否则就会发生合并。

于是就可以设计状态和转移了。

记 $f(l,r)$ 为区间 $[l,r]$ 的答案。

记 $g_1(l,r,s_1)$ 为，在区间 $[l,r]$ 中选了一个子序列，满足 $r$ 属于子序列，且属于子序列中两个质量和 $<k$ 的段的前面一段，且此时前面一段的质量和为 $s_1$ 时，区间 $[l,r]$ 内所有被分割出的极长连续段的答案之和的最大值。

记 $g_2(l,r,s_1,s_2)$ 为，在区间 $[l,r]$ 中选了一个子序列，满足 $r$ 属于子序列，且属于子序列中两个质量和 $<k$ 的段的后面一段，且此时前面一段的质量和为 $s_1$，后面一段的质量和为 $s_2$ 时，区间 $[l,r]$ 内所有被分割出的极长连续段的答案之和的最大值。

$f$ 的转移分两种情况，子序列长度为 $1$ 和子序列长度大于 $1$。两种情况均考虑枚举子序列中最右边一只史莱姆的位置 $i$。子序列长度为 $1$ 时，有 $f(l,r)\xleftarrow{\max}f(l,i)+f(i+1,r)+p_{m_i}$；子序列长度大于 $1$ 时，有 $f(l,r)\xleftarrow{\max}g_2(l,i,s_1,s_2)+f(i+1,r)+p_{s_1+s_2}$。其中 $s_1$ 和 $s_2$ 需要枚举，且需要保证 $1\le s_1,s_2 < k$。为了避免这个子序列和区间外两侧之后要卖出的史莱姆提前合并，需要保证 $c_i\ne c_{l-1}$ 和 $c_i \ne c_{r+1}$。

$g_1$ 的转移分两种情况，子序列长度为 $1$ 和子序列长度大于 $1$。子序列长度为 $1$ 说明 $r$ 是子序列中唯一的位置。所以有 $g_1(l,r,m_r)\xleftarrow{\max}f(l,r-1)$。注意此时 $s_1$ 必须等于 $m_r$。子序列长度大于 $1$ 时考虑枚举子序列中倒数第二个位置 $i$。这时有 $g_1(l,r,s_1)\xleftarrow{\max}g_1(l,i,s_1-m_r)+f(i+1,r-1)$。

$g_2$ 的转移分两种情况，子序列的两个质量和不超过 $k$ 的段中的第二段的长度为 $1$ 和长度大于 $1$。两种情况均考虑枚举子序列中倒数第二只史莱姆的位置 $i$。长度为 $1$ 说明 $r$ 是第二段中唯一的位置。所以有 $g_2(l,r,s_1,m_r)\xleftarrow{\max}g_1(l,i,s_1)+f(i+1,r-1)$。注意此时 $s_2$ 必须等于 $m_r$。第二段长度大于 $1$ 时有 $g_2(l,r,s_1,s_2)\xleftarrow{\max}g_2(l,i,s_1,s_2-m_r)+f(i+1,r-1)$。

然后就做完了。答案是 $f(1,n)$。

$f$ 一共有 $O(n^2)$ 种状态，单次转移需要枚举 $i,s_1,s_2$，所以单次转移复杂度是 $O(nk^2)$，总复杂度是 $O(n^3k^2)$。

$g_1$ 一共有 $O(n^2k)$ 种状态，单次转移需要枚举 $i$，所以单次转移复杂度是 $O(n)$，总复杂度是 $O(n^3k)$。

$g_2$ 一共有 $O(n^2k^2)$ 种状态，单次转移需要枚举 $i$，所以单次转移复杂度是 $O(n)$，总复杂度是 $O(n^3k^2)$。

所以该算法总时间复杂度为 $O(n^3k^2)$，空间复杂度为 $O(n^2k^2)$。

---

## 作者：zyxawa (赞：7)

由于每次合并可以刻画为向外延伸，那么考虑区间 $\text{dp}$，设 $dp_{l,r,m,c}$ 表示考虑了 $[l,r]$ 且剩下了一个质量为 $m \in [0,K)$ 颜色为 $c$ 的史莱姆的答案。

状态过大且转移方程不便于优化而考虑优化状态，由于对于一个极短的需要合并成一个史莱姆的区间 $[p,q]$，最终的颜色只能是 $c_p$ 或 $c_q$，中间的颜色不可能延展出去否则会与极短不符。

所以设 $f_{l,r}$ 表示处理掉 $[l,r]$ 的所有史莱姆的答案，$fl_{l,r,p}$ 表示剩下一个质量为 $p$ 且颜色为 $c_l$ 的史莱姆的答案，$fr_{l,r,p}$ 则是颜色为 $c_r$ 的。

至于 $p_i-p_{i-1}< w$ 则表示要合并的史莱姆并不会手动提升它的质量。

先考虑转移 $fl_{l,r,p}$，首先可以直接删除 $(l,r]$，即 $fl_{l,r,m_l}=f_{l+1,r}$，否则可以先保留 $l$，再删除中间一段区间，再把剩下的 $fl$ 和 $l$ 这个史莱姆合并，即 $fl_{l,r,p}=\max\limits_{l< k \le r,c_l=c_k} f_{l+1,k-1}+fl_{k,r,p-m_l}$，$fr_{l,r,p}$ 同理可得。

至于 $f_{l,r}$ 的转移分为是否是一个极短合并区间，如果需要合并首先需要满足 $c_l=c_r$，那么 $f_{l,r}=\max\limits_{l\le k< r,0< i< K,0< j< K}fl_{l,k,i}+fr_{k+1,r,j}+p_{i+j}$，如果不合并而直接合并两边的 $f$，那么 $f_{l,r}=\max\limits_{l\le k< r,c_k\neq c_{r+1} \vee c_{k+1}\neq c_{l-1}} f_{l,k}+f_{k+1,r}$，$c$ 的限制是因为不满足就会自动与 $[l,r]$ 外的史莱姆合并。

可能有写错的地方记得来打我，可能有人要问 $fl,fr,f$ 是不是还应该有其他关于 $c$ 的限制啊，应该是存在一种顺序满足条件吧，其实我也不大知道，加上就过不了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,s,w,c[151],m[151],p[21];
ll f[151][151],fl[151][151][21],fr[151][151][21];
void upd(ll &x,ll y){x=max(x,y);}
int main(){
	memset(f,-0x3f,sizeof(f)),memset(fl,-0x3f,sizeof(fl)),memset(fr,-0x3f,sizeof(fr));
	scanf("%d%d%d",&n,&s,&w);
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
	for(int i=1;i<=n;i++) scanf("%d",&m[i]);
	for(int i=s;i<=2*s-2;i++) scanf("%d",&p[i]);
	for(int i=1;i<s;i++) p[i]=p[s]-(s-i)*w;
	for(int i=1;i<=n;i++) f[i][i]=p[m[i]],fl[i][i][m[i]]=fr[i][i][m[i]]=f[i][i-1]=0;
	for(int t=2;t<=n;t++){
		for(int l=1;l+t-1<=n;l++){
			int r=l+t-1;
			upd(fl[l][r][m[l]],f[l+1][r]);
			for(int k=l+1;k<=r;k++) if(c[l]==c[k]) for(int i=1;i<s-m[l];i++) upd(fl[l][r][i+m[l]],f[l+1][k-1]+fl[k][r][i]);
			upd(fr[l][r][m[r]],f[l][r-1]);
			for(int k=l;k<r;k++) if(c[r]==c[k]) for(int i=1;i<s-m[r];i++) upd(fr[l][r][i+m[r]],f[k+1][r-1]+fr[l][k][i]);
			for(int k=l;k<r;k++) if(c[k]!=c[r+1]||c[k+1]!=c[l-1]) upd(f[l][r],f[l][k]+f[k+1][r]);
			if(c[l]==c[r]) for(int k=l;k<r;k++) for(int i=1;i<s;i++) for(int j=1;j<s;j++) upd(f[l][r],fl[l][k][i]+fr[k+1][r][j]+p[i+j]);
		}
	}
	printf("%lld",f[1][n]);
	return 0;
}
```

---

## 作者：Hanghang (赞：6)



前言：感谢小 E 给我的帮助，一直耐心讲解。

这是一道非常好的区间 dp，让我对此类问题有了更深刻的理解。

如何刻画区间？注意到消除史莱姆的操作有些复杂，考虑多设一些状态。

一个区间无论如何都有最后一次消除（废话），考虑从此入手。

设 $f_{l,r}$ 表示区间 $[l,r]$ 的答案，$fl_{l,r,p}$ 表示区间最后剩下一些史莱姆，保留第 $l$ 堆，质量为 $p$，颜色为 $c_l$，$fr_{l,r,p}$ 表示区间最后剩下一些史莱姆，保留第 $r$ 堆，质量为 $p$，颜色为 $c_r$。

由于颜色相同的史莱姆相邻会合并，那么 $fl_{l,r,p}$ 有解当且仅当 $c_l \neq c_{r+1}$。

首先有 $f_{l,r,a_l}=f_{l+1,r}$。

考虑合并区间内两堆史莱姆。

那么有 $fl_{l,r,p+a_l}=\displaystyle\max_{l <k\le r,c_k=c_l,1 \le p <m-a_l}^{}fl_{k,r,p}+f_{l+1,k-1}$

具体意思就是枚举另一堆史莱姆在哪，那么合并时将中间先全部干掉即可。

注意到区间最后一次操作一定是将一坨史莱姆加质量然后干掉或者是两坨史莱姆合并到一起后消除，分开计算。

前者：(注意与两端边界颜色不能相同)

$f_{l,r}=\displaystyle\max_{l\le k \le r,c_k \neq c_{l-1},c_k\neq c_{r+1},1 \le p<m}^{}f_{l,k-1}+fl_{k,r,p}+b_{m}-w\times (m-p)$

$fr$ 和 $fl$ 转移贡献方式类似。

后者可以分为两部实现，第一部先将左侧答案与中间要消除的合并计算，第二部再将第一托和右侧史莱姆合并计算。

那么设 $g_{l,r,p}$ 表示将区间 $[l,r)$ 消除，只剩下颜色为 $a_r$，质量为 $p$ 的答案。

$g_{l,r,p}=\displaystyle\max_{l \le k<r,c_k=c_r,c_k\neq c_{l-1},1 \le p < m}^{}fr_{l,k,p}+f_{k+1,r-1}$

$f_{l,r}=\displaystyle\max_{l<k \le r,c_k \neq c_{r+1},1 \le x <m,1 \le y <m,x+y \ge m}^{}g_{l,k,x}+fr_{k,r,y}+b_{x+y}$

最后输出 $f_{1,n}$ 即可。细节有点多，要慢慢感受。

复杂度 $O(n^3 k^2)$，常数不大。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N=153,M=13;
ll n,m,w,a[N],b[N],c[N],f[N][N],fl[N][N][M],fr[N][N][M],g[N][N][M];
void Max(ll &x,ll y){if(x<y)x=y;}
int main()
{
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=m;i<=2*m-2;i++)cin>>b[i];
	memset(f,-0x3f,sizeof(f));memset(g,-0x3f,sizeof(g));
	memset(fl,-0x3f,sizeof(fl));memset(fr,-0x3f,sizeof(fr));
	for(int i=1;i<=n;i++)
	    fl[i][i][a[i]]=fr[i][i][a[i]]=f[i][i-1]=0,f[i][i]=b[m]-w*(m-a[i]);
	for(int len=2;len<=n;len++)for(int l=1,r=len;r<=n;l++,r++)
	{
		if(c[l-1]!=c[r])Max(fr[l][r][a[r]],f[l][r-1]);
		for(int k=l;k<r;k++)if(c[k]==c[r]&&c[l-1]!=c[k])
		    for(int p=1;p+a[r]<m;p++)Max(fr[l][r][p+a[r]],fr[l][k][p]+f[k+1][r-1]);
		if(c[l]!=c[r+1])Max(fl[l][r][a[l]],f[l+1][r]);
		for(int k=l+1;k<=r;k++)if(c[k]==c[l]&&c[r+1]!=c[k])
		    for(int p=1;p+a[l]<m;p++)Max(fl[l][r][p+a[l]],fl[k][r][p]+f[l+1][k-1]);
		for(int k=l;k<=r;k++)if(c[k]!=c[l-1]&&c[k]!=c[r+1])
		    for(int p=1;p<m;p++)Max(f[l][r],f[l][k-1]+fl[k][r][p]+b[m]-w*(m-p));
		for(int k=l;k<=r;k++)if(c[k]!=c[l-1]&&c[k]!=c[r+1])
		    for(int p=1;p<m;p++)Max(f[l][r],fr[l][k][p]+f[k+1][r]+b[m]-w*(m-p));
		for(int k=l;k<r;k++)if(c[k]==c[r]&&c[l-1]!=c[k])
		    for(int p=1;p<m;p++)Max(g[l][r][p],fr[l][k][p]+f[k+1][r-1]);
		for(int k=l+1;k<=r;k++)if(c[k]!=c[r+1])
		    for(int x=1;x<m;x++)for(int y=1;y<m;y++)if(x+y>=m)
			    Max(f[l][r],g[l][k][x]+fl[k][r][y]+b[x+y]);
	}
	cout<<f[1][n];
}
```



---

## 作者：critnos (赞：3)

亲爱的史莱姆君： 

很困难的区间 dp。很笨的做法。

强制相同颜色合并非常恶心。只能从相邻颜色不同入手，设计一个状态 $f_{l,r,i,j}$ 表示区间 $[l,r]$ 中史莱姆 $l,r$ 所属的史莱姆暂时不被卖掉且其他史莱姆全部被卖掉了，且 $l,r$ 所属的史莱姆重量分别为 $i,j$ 的最大收益。具体的：

* 如果 $c_l\neq c_r$，则 $i,j<t$。
* 如果 $c_l=c_r$，则 $i=j\le 2t-2$。

再对于 $c_i=c_j$，记 $f_{i,j}$ 表示将 $dp_{l,r,x,x}$ 卖掉（如果大小不够就加到 $k$）的最大收益。

转移考虑枚举合并到左右两边的史莱姆中间的最后一次卖掉的史莱姆，具体来说枚举一个区间 $[l',r']$，满足 $c_{l'}=c_{r'}$ 且 $c_{l'}\neq c_l,c_{l'}\neq c_r$ 表示这个史莱姆是由 $c_{l'},c_{r'}$ 以及一些它们中间的史莱姆合并成的。对于 $c_l\neq c_r$ 的转移是

$$dp_{l,r,i,j}=\max dp_{l,l',i,m_{l'}}+f_{l',r'}+dp_{r',r,m_{r'},j}$$

$c_l=c_r$ 是类似的。

注意 $c_l\neq c_r$ 的情况还有中间没有史莱姆的情况，判一下。然后在 $0$ 和 $n+1$ 塞两个特殊的史莱姆，$dp_{0,n+1}$ 就是答案了。

直接暴力这样做是 $O(n^4k^2)$ 的，非常好写而且直接能过了。感觉能优化一下，但懒得搞了。

附图：写草稿的时候摸的史莱姆，不太会画画。

![](https://cdn.luogu.com.cn/upload/image_hosting/b6knyp6h.png)

---

## 作者：Jorisy (赞：3)

鲲队的模拟赛 C 放了这题，被爆了，遂写一发题解。

首先区间 dp 是不难想的，也容易想到设 $f_{l,r}$ 为区间 $[l,r]$ 的最大净利润。

~~然后我场上就不会了，遂放弃。~~

当然，不难想到对于 $i\in[1,m-1]$，有 $p_i=p_m-(m-i)w$。

考虑合并操作。

首先发现题目条件中的 $p_i-p_{i-1}<w$，这乍一眼看上去很奇怪。其实仔细思考一下，就不难发现它是在说，要合并的史莱姆不会被做质量加 $1$ 的操作。

可以想到，一个区间 $[l,r]$ 要合并成一个史莱姆，其颜色只能是 $c_l$ 或 $c_r$。

于是设 $g_{l,r,m,0/1}$ 表示区间 $[l,r]$ 的史莱姆合并后剩下一个颜色为 $c_l$（或 $c_r$）的史莱姆的答案。

接下来考虑转移状态。

对于 $g_{l,r,m,0}$，首先可以直接卖掉 $[l+1,r]$ 的史莱姆，即为 $f_{l+1,r}$。

然后就是将 $l$ 与 $[k,r]$ 合并（自然要保证 $c_l=c_k$），并卖掉区间 $[l+1,k-1]$ 的史莱姆，结合上面，可得 $g_{l,r,m,0}=\max\left(f_{l+1,r},\max\limits_{l<k\le r\land c_l=c_k}\{f_{l+1,k-1}+g_{k,r,m-m_i,0}\}\right)$。

同理，有 $g_{l,r,m,1}=\max\left(f_{l,r-1},\max\limits_{l\le k<r\land c_r=c_k}\{g_{l,k,m-m_i,1}+f_{k+1,r-1}\}\right)$。

于是我们就可以开始转移 $f_{l,r}$ 了！

首先容易地，枚举区间 $[l,k],[k+1,r]$，为了避免史莱姆的合并，不应同时满足 $c_{l-1}=c_{k+1},c_k=c_{r+1}$，即有 $f_{l,r}=\max\limits_{l\le k<r,c_{l-1}\neq c_{k+1}\lor c_k\neq c_{r+1}}\{f_{l,k}+f_{k+1,r}\}$。

特别地，对于 $c_l=c_r$ 的，我们**另外**有 $f_{l,r}=\max\limits_{l\le k<r,1\le i,j<m}\{g_{l,k,i,0}+g_{k+1,r,j,1}+p_{i+j}\}$。

最后答案为 $f_{1,n}$。写吐了。

---


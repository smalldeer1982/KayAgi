# [CCPC 2023 北京市赛] 三染色

## 题目描述

我有一个调色盘，总共 $n$ 行 $m$ 列，形成了 $n\times m$ 个格子，每个格子里要放一朵花。可以放置的花有 $3$ 种颜色可以选择，分别用 $0,1,2$ 表示。

花朵注视着它周围的花，并想要变成其他花朵的样子。如果在一个时刻，一朵颜色为 $c$ 的花的上、下、左、右之一，有至少一朵花的颜色为 $c-1$，那么这朵花在下一个时刻会变成颜色 $c-1$，否则它在下一个时刻的颜色仍然是 $c$。其中颜色 $\bmod 3$ 考虑。

对于一个初始的在调色盘中放花的方案，如果经过有限个时刻之后，所有花都变成同一颜色，我们称这个放花的方案是**美好的**。

不难看出，对于一个美好的放花方案，每朵花都有一个最早的时刻，它在这个时刻之后一直不变色。我们称这个时刻为这朵花的**稳定时刻**。
我们从第 $0$ 时刻开始计时，所以一朵花如果从未改变颜色，那么它的稳定时刻就是 $0$。

现在我已经在调色盘的一些格子中放置了花朵，也有一些格子是空的。我想知道，有多少种给剩余的格子放花的方案，使得这个方案是美好的？以及，对于这些美好的方案，位于第 1 行第 1 列格子中花朵的稳定时刻的总和是多少？

你只需要回答我这两个结果对 $998244353$ 取模的值。

## 说明/提示

**【样例解释 1】**

只有在未知格子放入花朵颜色为 $0$ 的时候会结束，并且在两个时刻之后所有花朵的颜色全部变为 $2$，此时左上角方格中的花朵颜色变成 $2$ 并不再改变，因此它的稳定时刻就是 $2$。

## 样例 #1

### 输入

```
2 2
1 0
3 2```

### 输出

```
1 2```

## 样例 #2

### 输入

```
5 5 
3 3 3 3 2
2 3 3 3 1
1 3 3 3 3
3 3 3 3 3
3 3 3 3 3```

### 输出

```
50830224 170059345
```

# 题解

## 作者：Larunatrecy (赞：5)

### [[CCPC 2023 北京市赛] 三染色](https://www.luogu.com.cn/problem/P10042)

$\bmod 3$ 意义下不太好考虑，我们先考虑普通情况：

- 有一个高度矩阵 $h_{i,j}$，满足相邻的 $h$ 差的绝对值不超过 $1$。对于每一轮，如果某个点 $h_{i,j}$ 周围存在点的高度是 $h_{i,j}-1$，那么 $h_{i,j}=h_{i,j}-1$，否则不变，求出最终停止变化的时刻。

这个问题是简单的，因为最小值一定不变，并且每一轮最小值都会把周围的点也变为最小值，因此答案就是到 $(1,1)$  曼哈顿距离最小的最小值点的距离。

考虑拓展一下，我们构造一个高度矩阵 $h_{i,j}$，使得除了满足上述条件，并且 $h_{i,j}\equiv a_{i,j}\pmod 3$，可以发现若能构造出来，那么 $h$ 与 $a$ 的变化就一模一样的，答案同上。

不妨令 $h_{1,1}=a_{1,1}$，然后归纳假设已经构造了 $h_{i-1,j},h_{i,j-1}$，因为 $|h_{i-1,j-1}-h_{i-1,j}|\leq 1,|h_{i-1,j-1}-h_{i,j-1}|\leq 1$ 都满足，所以通过简单的分类讨论可以发现当且仅当这个子矩阵形如这样时无法构造：
$$
\begin{pmatrix}
    a & a\\
    b & c
\end{pmatrix}
$$
当然，旋转或者整体加 $d$ 都也是不行的。

手玩一下可以发现，此时这个矩阵会不断自我迭代，因此一定不会稳定。故只要不存在这样的子矩形就一定是可以构造的，这就是第一问的答案，直接 $3^{2n}m$ 暴力状压 dp 即可通过。

对于第二问，我们需要维护最小高度，当前的高度，最小值位置，以及最后一列的状态，显然过不掉，考虑优化。

首先可以用轮廓线 dp 把状态变成 $3^n$，然后注意到我们不关心最小值具体是什么，只关心当前高度与最小高度的差，具体的，我们可以一开始就枚举 $h_{1,1}$ 比最小值高多少，并且实时记录差，强制过程中不经过差 $<0$ 的点，那么差 $=0$ 的点就是最小值点。

同时，我们其实也不关心最小值位置，只关心其曼哈顿距离，可以发现曼哈顿距离相等的点构成了一条斜线，我们只需要记录这一条线与当前列的交点即可，这个交点如果超出边界，以后也不可能更优了，直接计入答案即可，否则这个交点是 $O(n)$ 的。

综上，我们能在 $O(3^nn^2m^2)$ 的复杂度解决该问题。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 55;
const int M = 4100;
int n,m;
int a[N][N];
const int mod = 998244353;
inline int add(int a,int b){return a+b>+mod?a+b-mod:a+b;}
inline void myplus(int &a,int b){a+=b;if(a>=mod)a-=mod;}
template <typename T>inline void read(T &x)
{
    x=0;char c=getchar();bool f=0;
    for(;c<'0'||c>'9';c=getchar())f|=(c=='-');
    for(;c>='0'&&c<='9';c=getchar())x=((x<<1)+(x<<3)+(c^48));
    x=(f?-x:x);
}
int f[2][M][N*2][8][3],g[2][M][N*2][3],pw[N];
int dp[N][M];
inline int get(int s,int i){return (s>>((i-1)<<1))&3;}
inline int gen(int c,int i){return c*(1<<((i-1)*2));}
inline int promote(int x,int y){if(y==x)return 0;if(y==(x+1)%3)return 1;return -1;}
int suan[M][N][3];
bool chk[3][3][3][3];
bool flag1[N][M],flag2[M][M];
bool chk2(int i,int s)
{
    for(int j=1;j<=m;j++)
    {
        if(a[i][j]!=3&&get(s,j)!=a[i][j])return 0;
    }
    return 1;
}
bool chk3(int s,int t)
{
    for(int j=1;j<=m-1;j++)
    {
        int c1=get(s,j),c2=get(s,j+1);
        int c3=get(t,j),c4=get(t,j+1);
        if(c1==c2&&c1!=c3&&c1!=c4&&c3!=c4)return 0;
        if(c1==c3&&c1!=c2&&c1!=c4&&c2!=c4)return 0;
        if(c2==c4&&c2!=c1&&c2!=c3&&c1!=c3)return 0;
        if(c3==c4&&c3!=c1&&c3!=c2&&c1!=c2)return 0;
    }
    return 1;
}
vector<int> used;
void solve1()
{
    for(int i=1;i<=n;i++)
    for(int j:used)
    flag1[i][j]=chk2(i,j);
    for(int i:used)
    {
        for(int k:used)
        flag2[i][k]=chk3(i,k);
    }
    for(int j:used)if(flag1[1][j])dp[1][j]=1;
    for(int i=2;i<=n;i++)
    for(int j:used)if(dp[i-1][j])
    for(int k:used)if(flag1[i][k]&&flag2[j][k])
    dp[i][k]=add(dp[i][k],dp[i-1][j]);
    int res=0;
    for(int j:used)res=(res+dp[n][j])%mod;
    cout<<res<<' ';
}
int main()
{
    read(m);read(n);
    for(int j=1;j<=m;j++)
    for(int i=1;i<=n;i++)
    read(a[i][j]);
    pw[0]=1;
    int cur=0;
    for(int i=1;i<=m;i++)pw[i]=pw[i-1]*4;
    int t=1;
    for(int i=1;i<=m;i++)t=t*3;
    for(int u=0;u<t;u++)
    {
        int s=0,x=u;
        for(int i=1;i<=m;i++)
        {
            int c=x%3;
            x/=3;
            s+=gen(c,i);
        }
        used.push_back(s);
    }
    solve1();
    for(int s:used)
    {
        int i=1;
        int mn=0,d=0,p=1;bool flag=1;
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]!=3&&get(s,j)!=a[i][j])
            {
                flag=0;
                break;
            }
            if(j>1)
            {
                d=d+promote(get(s,j-1),get(s,j));
                if(d<mn)
                {
                    mn=d;
                    p=j;
                }
            }
        }
        if(flag)
        for(int v=-(n+m);v<=mn;v++)
        {
            if(v==mn)f[cur][s][0-v][p][0]++;
            else g[cur][s][0-v][0]++;
        }
    }
    for(int s:used)
    {
        for(int i=2;i<=m;i++)
        for(int c=0;c<=2;c++)
        {
            int d=0;
            for(int j=1;j<i-1;j++)d+=promote(get(s,j),get(s,j+1));
            d+=promote(get(s,i-1),c);
            suan[s][i][c]=d;
        }
    }
    for(int c1=0;c1<=2;c1++)for(int c2=0;c2<=2;c2++)
    for(int c3=0;c3<=2;c3++)for(int c4=0;c4<=2;c4++)
    {
        if(c1==c2&&c1!=c3&&c1!=c4&&c3!=c4)continue;
        if(c1==c3&&c1!=c2&&c1!=c4&&c2!=c4)continue;
        if(c2==c4&&c2!=c1&&c2!=c3&&c1!=c3)continue;
        if(c3==c4&&c3!=c1&&c3!=c2&&c1!=c2)continue;
        chk[c1][c2][c3][c4]=1;
    }
    int all=0;
    for(int i=2;i<=n;i++)
    {
        if(i)
        {
            int j=1;
            int nxt=(cur^1);
            for(int s:used)
            for(int d=0;d<=n+m;d++)
            {
                int w=0;
                for(int sp=0;sp<=2;sp++)w=add(w,g[cur][s][d][sp]),g[cur][s][d][sp]=0;
                if(!w)continue;
                for(int c=0;c<=2;c++)
                {
                    if(a[i][j]!=3&&a[i][j]!=c)continue;
                    all++;
                    int ns=s-gen(get(s,j),j)+gen(c,j),nsp=get(s,j),nv=d+promote(get(s,j),c);
                    if(nv>0)//keep
                    {
                        myplus(g[nxt][ns][nv][nsp],w);
                    }
                    else if(nv==0)//update
                    {
                        myplus(f[nxt][ns][nv][j][nsp],w);
                    }
                }
            }
            for(int s:used)
            for(int d=0;d<=n+m;d++)
            for(int r=0;r<=m;r++)
            {
                int w=0;
                for(int sp=0;sp<=2;sp++)w=add(w,f[cur][s][d][r][sp]),f[cur][s][d][r][sp]=0;
                if(!w)continue;
                for(int c=0;c<=2;c++)
                {
                    if(a[i][j]!=3&&a[i][j]!=c)continue;
                    all++;
                    int ns=s-gen(get(s,j),j)+gen(c,j),nv=d+promote(get(s,j),c),nr=max(0,r-1),nsp=get(s,j);
                    if(nv>0||(nv==0&&nr<=j))//keep
                    {
                        if(r==1&&nr==0)
                        myplus(f[nxt][ns][nv][nr][nsp],1ll*w*(i-1+r-2)%mod);
                        else
                        myplus(f[nxt][ns][nv][nr][nsp],w);
                    }
                    else if(nv==0)//update
                    {
                        myplus(f[nxt][ns][nv][j][nsp],w);
                    }
                }
            }
            cur=nxt;
        }
        for(int j=2;j<=m;j++)
        {
            int nxt=(cur^1);
            for(int s:used)
            for(int d=0;d<=n+m;d++)
            for(int sp=0;sp<=2;sp++)
            if(g[cur][s][d][sp])
            {
                for(int c=0;c<=2;c++)
                {
                    if(a[i][j]!=3&&a[i][j]!=c)continue;
                    if(!chk[sp][get(s,j)][get(s,j-1)][c])continue;
                    if(d+suan[s][j][c]<0)continue;
                    all++;
                    int ns=s-gen(get(s,j),j)+gen(c,j),nsp=get(s,j),nv=d+suan[s][j][c];
                    if(nv>0)//keep
                    {
                        myplus(g[nxt][ns][d][nsp],g[cur][s][d][sp]);
                    }
                    else if(nv==0)//update
                    {
                        myplus(f[nxt][ns][d][j][nsp],g[cur][s][d][sp]);
                    }
                }
                g[cur][s][d][sp]=0;
            }
            for(int s:used)
            for(int d=0;d<=n+m;d++)
            for(int r=0;r<=m;r++)
            for(int sp=0;sp<=2;sp++)
            if(f[cur][s][d][r][sp])
            {
                for(int c=0;c<=2;c++)
                {
                    if(a[i][j]!=3&&a[i][j]!=c)continue;
                    if(!chk[sp][get(s,j)][get(s,j-1)][c])continue;
                    if(d+suan[s][j][c]<0)continue;
                    all++;
                    int ns=s-gen(get(s,j),j)+gen(c,j),nr=r,nsp=get(s,j),nv=d+suan[s][j][c];
                    if(nv>0||(nv==0&&nr<=j))//keep
                    {
                        if(r==1&&nr==0)
                        myplus(f[nxt][ns][d][nr][nsp],1ll*f[cur][s][d][r][sp]*(i-1+r-2)%mod);
                        else
                        myplus(f[nxt][ns][d][nr][nsp],f[cur][s][d][r][sp]);
                    }
                    else if(nv==0)//update
                    {
                        myplus(f[nxt][ns][d][j][nsp],f[cur][s][d][r][sp]);
                    }
                }
                f[cur][s][d][r][sp]=0;
            }
            cur=nxt;
        }
    }
    int ans=0;
    for(int s:used)
    for(int d=0;d<=n+m;d++)
    for(int sp=0;sp<=2;sp++)
    {
        myplus(ans,f[cur][s][d][0][sp]);
        for(int r=1;r<=m;r++)myplus(ans,1ll*f[cur][s][d][r][sp]*(n+r-2)%mod);
    }
    cout<<ans;
    return 0;
}

```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10042)

**题目大意**

> 给定 $n\times m$ 网格，每个格子填 $0\sim 2$，有些还没填，你要给他们填入 $0\sim 2$。
>
> 一个网格会进行若干轮迭代，对于一个填 $x$ 的格子，如果他四联通的格子中有 $x-1$，那么迭代后这个格子也会变成 $x-1$，在 $\bmod 3$ 意义下考虑。
>
> 一个网格是好的当且仅当其不会无限迭代，定义其权值为 $(0,0)$ 最后一次迭代时共迭代了几次。
>
> 数据范围：$n\le 5,m\le 50$。

**思路分析**

考虑把 $\bmod 3$ 去掉，设原矩阵为 $a_{i,j}$，那么找到一个 $b_{i,j}\equiv a_{i,j}\pmod 3$ 且相邻元素差 $\in[-1,1]$。

如果确定 $b_{1,1}$ 的值那么 $a$ 与 $b$ 构成双射。

在 $a$ 上的操作也会在 $b$ 上进行，并且 $a,b$ 的操作情况完全相同。

那么一个 $b$ 的网格一定会停止，并且所有最小值所在位置不会迭代，每次操作就会把它周围的点权值变该点权值。

因此答案就是所有最小值中到 $(0,0)$ 最小的曼哈顿距离。

因此只要 $a$ 能找到一个对应的 $b$ 就一定是好的矩阵，我们又发现找不到 $b$ 的矩阵 $a$ 一定包含一个形如 $\begin{bmatrix}x&x\\y&z\end{bmatrix}$ 的子矩阵，而这个子矩阵会无限减小，所以我们证明了好矩阵和存在 $b$ 的矩阵一一对应。

对于每个 $2\times 2$ 检验是否合法即可。

因此第一问可以简单 dp，$f_{i,s}$ 表示前 $i$ 列的状态为 $s$ 有多少种方案，转移枚举第 $i+1$ 列轮廓线，时间复杂度 $\mathcal O(m6^n)$。

然后考虑第二问，设 $b_{1,1}=0$，我们要维护最小的 $b$，以及所有 $b$ 取到最小值的位置到 $(0,0)$ 的最小距离。

如果暴力记录状态还要记录 $b_{0,i}$，这是不能接受的，但我们只关心 $b$ 的最小值与 $b_{j,i}$ 的相对关系，因此可以记录 $b_{0,i}-b_{\min}$ 的值。

然后要维护到 $(0,0)$ 的最小距离，我们发现这一维如果再记录 $\mathcal O(n+m)$ 的信息是无法接受的。

考虑类似刚才的技巧，设最小距离为 $d$，我们只关心 $d$ 与某个 $j+i$ 的关系，因此可以记录 $d-i$。

而 $d\le i$ 时说明 $>i$ 的列都不可能成为最小曼哈顿距离的点，因此只要记录 $\max(0,d-i)$ 即可，这样这一维的信息只有 $\mathcal O(n)$。

因此设计状态 $f_{i,j,k,s}$，$j$ 表示 $b_{0,i}-b_{\min}$，$k$ 表示 $\max(0,d-i)$ 的方案数，再记录 $g_{i,j,k,s}$ 表示对应权值和。

时间复杂度 $\mathcal O(nm(n+m)6^n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=60,MAXS=255,MOD=998244353;
const int pw[6]={1,3,9,27,81,243},d[3][3]={{0,1,-1},{-1,0,1},{1,-1,0}};
int n,m,Q,a[MAXN][5];
bool ok[55][MAXS],trs[MAXS][MAXS];
int v[MAXS],p[MAXS]; //min prefix, pos
int f1[MAXS][MAXN][5],f2[MAXS][MAXN][5];
//(last color,cur min-a[i,0],mindis-i) {wys ans}
int g1[MAXS][MAXN][5],g2[MAXS][MAXN][5];
int dg(int s,int i) { return s/pw[i]%3; }
void add(int &x,int y) { x=(x+y>=MOD)?x+y-MOD:x+y; }
void add(int &x,long long y) { x=(x+y)%MOD; }
signed main() {
	ios::sync_with_stdio(false);
	cin>>n>>m,Q=pw[n];
	for(int i=0;i<n;++i) for(int j=0;j<m;++j) cin>>a[j][i];
	for(int i=0;i<m;++i) for(int s=0;s<Q;++s) {
		ok[i][s]=true;
		for(int j=0;j<n;++j) ok[i][s]&=(a[i][j]==3||a[i][j]==dg(s,j));
	}
	for(int s=0;s<Q;++s) {
		v[s]=p[s]=0;
		for(int i=1,k=0;i<n;++i) {
			k+=d[dg(s,i-1)][dg(s,i)];
			if(k<v[s]) v[s]=k,p[s]=i;
		}
		for(int t=0;t<Q;++t) {
			trs[s][t]=true;
			for(int i=1;i<n;++i) {
				int x=dg(s,i-1),y=dg(t,i-1),z=dg(t,i),w=dg(s,i);
				trs[s][t]&=!(d[x][y]+d[y][z]+d[z][w]+d[w][x]);
			}
		}
	}
	for(int s=0;s<Q;++s) if(ok[0][s]) f1[s][-v[s]][p[s]]=1,f2[s][-v[s]][p[s]]=p[s];
	for(int i=1;i<m;++i) {
		memset(g1,0,sizeof(g1)),memset(g2,0,sizeof(g2));
		for(int s=0;s<Q;++s) for(int j=0;j<=i+n;++j) for(int k=0;k<n;++k) for(int t=0;t<Q;++t) {
			if(!ok[i][t]||!trs[s][t]) continue;
			int w=(d[t%3][s%3]-j)-v[t],z=f1[s][j][k];
			if(!z) continue;
			if(w<0||(w==0&&k-1<=p[t])) { //remain min
				add(g1[t][j-d[t%3][s%3]][max(k-1,0)],z);
				add(g2[t][j-d[t%3][s%3]][max(k-1,0)],f2[s][j][k]);
			} else { //min is cur
				add(g1[t][-v[t]][p[t]],z);
				add(g2[t][-v[t]][p[t]],1ll*z*(i+p[t]));
			}
		}
		memcpy(f1,g1,sizeof(f1)),memcpy(f2,g2,sizeof(f2));
	}
	int s1=0,s2=0;
	for(int s=0;s<Q;++s) for(int j=0;j<=m+n;++j) for(int k=0;k<n;++k) {
		add(s1,f1[s][j][k]),add(s2,f2[s][j][k]);
	}
	printf("%d %d\n",s1,s2);
	return 0;
}
```

---

## 作者：C1942huangjiaxu (赞：1)

先考虑如何判断一个方案是否合法。

**必要性**是不存在四个格子与  $\begin{bmatrix} 0 & 0 \\ 1 & 2 \end{bmatrix}$ 同构，因为这样的 $4$ 个格子会循环变换。

例如 $\begin{bmatrix} 1 & 1 \\ 0 & 2 \end{bmatrix}$，$\begin{bmatrix} 2 & 0 \\ 2 & 1 \end{bmatrix}$ 等。

下面来说明**充分性**。

考虑给每个格子一个**权值**。

先考虑相邻的 $2$ 个格子，假设数分别为 $x,y$，考虑在格子间连**有向边**。

如果 $x$ 下一轮会变为 $y$ 则认为 $y=x+1$，从 $x$ 到 $y$ 的边权为 $1$，从 $y$ 到 $x$ 的边权为 $-1$。

如果 $x=y$ ，认为 $x,y$ 之间的边权为 $0$。

发现在满足**必要性**的情况下，**任意 2 个格子之间的路径权值相同**。

也就是说，我们可以**比较任意 $2$ 个格子的大小**，最后所有格子都会**变为最大的格子的颜色**。

**充分性**得证。

这样第一问容易解决。

考虑第二问，可以发现，一个格子的稳定时刻就是所有**最大的格子到它的最小距离**。

一列一列的 DP，为了方便行下标从 $0$ 开始，就是求到 $(0,1)$ 距离最小的最大格子。

记 $f_{i,S,j,k}$ 表示，考虑到第 $i$ 列，第 $i$ 列的颜色是 $S$，当前最大值比 $(0,i)$ 大 $j$，到 $(0,1)$ 的距离为 $i-1+k$。

$i$ 的范围是 $[1,m]$，$j$ 的范围是 $[0,n+m-2]$，$S$ 的范围是 $[0,3^n-1]$。

考虑 $k$ 这一维，实际上只要记录 $[0,n]$。

首先第 $i$ 列的距离最大值是 $i+n-2$，对应 $k=n-1$。

若 $k\lt 0$，那么之后**所有点距离都比它大了，只要考虑权值**即可，即 $f_{i,S,j,0}\rightarrow f_{i,S,j+1,n}$。

在 $f_{i,S,j,0}$ 统计答案，为了统计答案，还需要求出 $g_{i,S,j}$ 表示第 $i$ 列的颜色为 $S$， $i\sim m$ 列中最大值 $\le (0,i)+j$ 的方案数。

转移时分类讨论，具体见代码。

进行一些预处理后，时间复杂度 $O((n+m)mn3^{2n})$，常数较小，可以通过。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=998244353;
constexpr int pw[6]={1,3,9,27,81,243},w[3][3]={{0,-1,1},{1,0,-1},{-1,1,0}};
int n,m,a[5][55],st[pw[5]][5],ans1,ans2,mx[pw[5]],pmx[pw[5]],d[pw[5]][pw[5]],M;
bool chk[55][pw[5]],ok[pw[5]][pw[5]];
int f[55][pw[5]][61][6],g[55][pw[5]][61];
inline void Add(int &x,int y){
	if((x+=y)>=P)x-=P;
}
bool checkS(int x,int S){
	for(int i=0;i<n;++i)if(a[i][x]!=3&&st[S][i]!=a[i][x])return false;
	return true;
}
bool check(int S,int T){
	int x[4];
	for(int i=1;i<n;++i){
		x[0]=st[S][i-1],x[1]=st[S][i],x[2]=st[T][i],x[3]=st[T][i-1];
		for(int j=0;j<4;++j)
			if(x[j]==x[j+1&3]&&x[j]!=x[j+2&3]&&x[j]!=x[j+3&3]&&x[j+2&3]!=x[j+3&3])return false;
	}
	return true;
}
int main(){
	scanf("%d%d",&n,&m);
	M=pw[n];
	for(int i=0;i<n;++i)for(int j=1;j<=m;++j)scanf("%d",&a[i][j]);
	for(int S=0;S<M;++S)for(int i=0;i<n;++i)st[S][i]=S/pw[i]%3;
	for(int S=0;S<M;++S){
		mx[S]=pmx[S]=0;
		for(int i=1,v=0;i<n;++i){
			v+=w[st[S][i-1]][st[S][i]];
			if(v>mx[S])mx[S]=v,pmx[S]=i;
		}
	}
	for(int i=1;i<=m;++i)for(int S=0;S<M;++S)chk[i][S]=checkS(i,S);
	for(int S=0;S<M;++S)for(int T=0;T<M;++T)ok[S][T]=check(S,T),d[S][T]=mx[S]-w[st[S][0]][st[T][0]]-mx[T];
	for(int S=0;S<M;++S)if(chk[m][S])g[m][S][0]=1;
	for(int i=m;i>1;--i)for(int S=0;S<M;++S)if(chk[i][S])
		for(int j=0;j+i<n+m;++j)if(g[i][S][j])
			for(int T=0;T<M;++T)if(chk[i-1][T]&&ok[S][T])
				Add(g[i-1][T][max(0,j+d[S][T])],g[i][S][j]);
	for(int i=1;i<=m;++i)for(int S=0;S<M;++S)
		for(int j=1;j+i<n+m;++j)Add(g[i][S][j],g[i][S][j-1]);
	for(int S=0;S<M;++S)if(chk[1][S])f[1][S][0][pmx[S]]=1;
	for(int i=1;i<m;++i)for(int S=0;S<M;++S)if(chk[i][S]){
		vector<int>tmp;
		for(int T=0;T<M;++T)if(chk[i+1][T]&&ok[S][T])tmp.emplace_back(T);
		for(int j=0;j<i+n-1;++j){
			Add(f[i][S][j+1][n],f[i][S][j][0]);
			int w=1ll*f[i][S][j][0]*g[i][S][j]%P;
			Add(ans1,w);
			Add(ans2,1ll*w*(i-1)%P);
			for(int k=1;k<=n;++k)if(f[i][S][j][k]){
				int t=k<n?k-1:n,v=f[i][S][j][k];
				for(auto T:tmp){
					int o=d[S][T]+j;
					if(o>0)Add(f[i+1][T][o][t],v);
					else if(!o)Add(f[i+1][T][o][min(t,pmx[T])],v);
					else Add(f[i+1][T][0][pmx[T]],v);
				}
			}
		}
	}
	for(int S=0;S<M;++S)for(int j=0;j<m+n-1;++j)for(int k=0;k<n;++k){
		int v=f[m][S][j][k];
		Add(ans1,v);
		Add(ans2,1ll*v*(m-1+k)%P);
	}
	printf("%d %d\n",ans1,ans2);
	return 0;
}
```

---


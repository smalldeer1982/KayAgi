# [SNOI2024] 拉丁方

## 题目描述

我们定义一个 $n \times n$ 的矩阵 $A$ 为拉丁方，当且仅当，每行每列都是一个 $1 \sim n$ 的排列。

现在给你一个矩阵 $A$ 左上角的一个 $R \times C$ 的子矩阵，也就是 $A_{i, j}$（$1 \le i \le R$，$1 \le j \le C$）。问能不能将剩下的位置填上数使得它是一个拉丁方。

## 说明/提示

**【样例 \#1 解释】**

在第一个样例中，对于第二组数据，根据前两行可以发现，$A_{1, 3} = A_{2, 3} = 3$，所以不存在满足条件的拉丁方。

对于第三组数据，可以发现输出是一个满足条件的拉丁方，并且左上角是输入的矩阵。下面也是一个满足条件的方案。
$$\begin{bmatrix} 1 & 2 & 3 & 5 & 4 \\ 4 & 3 & 2 & 1 & 5 \\ 3 & 5 & 1 & 4 & 2 \\ 2 & 4 & 5 & 3 & 1 \\ 5 & 1 & 4 & 2 & 3 \end{bmatrix}$$

---

**【样例 \#2】**

见附件中 `latin/latin2.in` 与 `latin/latin2.ans`，这个样例满足测试点 $6 \sim 7$ 的条件限制。

---

**【样例 \#3】**

见附件中 `latin/latin3.in` 与 `latin/latin3.ans`，这个样例满足测试点 $11 \sim 12$ 的条件限制。

---

**【数据范围】**

对于所有的数据，保证 $1 \le T \le 10$，$1 \le n \le 500$，$1 \le R, C \le n$，$1 \le A_{i, j} \le n$，保证输入的子矩阵不存在一行或者一列有两个相同的数。

具体如下：

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $6$ | 无 |
| $3 \sim 4$ | $10$ | 无 |
| $5$ | $500$ | A |
| $6 \sim 7$ | $100$ | B |
| $8 \sim 9$ | $300$ | B |
| $10$ | $500$ | B |
| $11 \sim 12$ | $500$ | C |
| $13 \sim 14$ | $100$ | 无 |
| $15 \sim 16$ | $300$ | 无 |
| $17 \sim 20$ | $500$ | 无 |

特殊性质 A：保证 $R = 1$。  
特殊性质 B：保证 $C = n$。  
特殊性质 C：保证 $R, C \le \frac{n}{2}$。

## 样例 #1

### 输入

```
3
2 1 1
1
3 2 2
1 2
2 1
5 2 3
1 2 3
4 3 2
```

### 输出

```
Yes
1 2
2 1
No
Yes
1 2 3 4 5
4 3 2 5 1
2 4 5 1 3
3 5 1 2 4
5 1 4 3 2
```

# 题解

## 作者：LRC0511 (赞：18)

提供一个好写的做法。

首先考虑 $R=n$ 时怎么做，此时我们可以确定所有行剩余部分可以填的数的集合，我们只需保证每一列的数不重复就够了。

我们将每一行作为左部点，每种数作为右部点，如果该行可以填某个数则连一条边，这是一张二分图，且每个点的度数均为 $n-C$。

根据上面的讨论，我们需要将其划分成 $n-C$ 组完美匹配，每一组匹配确定了每一列填哪些数。

我们知道，一张二分图的边染色数是它每个点度数的最大值。因此我们可以求出这张图的一个 $n-C$ 边染色，对于每种颜色的所有边，易知它们构成了一组完美匹配。

只需要利用 [CF600F](https://www.luogu.com.cn/problem/CF600F) 的方法求一次二分图边染色即可，时间复杂度 $O(n^3)$。

再考虑 $R \neq n$ 的情况。我们考虑先填左下角的部分，将问题转化为 $R=n$ 的情况。

同样可以确定前 $C$ 列可填的数的集合，利用同样的方式建图，我们得到了一张左部点度数均为 $n-R$ 的二分图。

如果某个右部点的度数大于 $n-R$，这意味着某个数出现的次数超过 $n-R$，但是未填的 $n-R$ 行中，每行至多填一个，因此此时必然无解。

所以该二分图有 $n-R$ 边染色，每种颜色的边对应一组左部满的匹配，对应每一行所填的数的集合。

只需再跑一次二分图边染色即可，时间复杂度 $O(n^3)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=505;
int n,r,c,a[N][N],to[N*2][N];
namespace Paint
{
    inline void init(int n,int d)
    {
        for(int i=1;i<=n;i++)
            for(int j=1;j<=d;j++)
                to[i][j]=0;
    }
    void dfs(int u,int v,int x,int y)//x->y
    {
        if(!to[v][y]){to[u][y]=v,to[v][y]=u,to[v][x]=0;return;}
        int w=to[v][y];
        if(to[w][x]) dfs(w,to[w][x],x,y);
        else to[w][y]=0;
        to[w][x]=v,to[v][x]=w,to[v][y]=u,to[u][y]=v;
    }
    inline void add(int u,int v)
    {
        int x=1,y=1;while(to[u][x]) x++;
        while(to[v][y]) y++;
        if(x==y){to[u][x]=v,to[v][y]=u;return;}
        dfs(u,v,y,x);
    }
}
int tmp[N];
bool work1()
{
    for(int i=1;i<=n;i++) tmp[i]=c;
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            tmp[a[i][j]]--;
    for(int i=1;i<=n;i++)
        if(tmp[i]>n-r) return 0;
    Paint::init(n+c,n-r);
    for(int j=1;j<=c;j++)
    {
        for(int i=1;i<=n;i++) tmp[i]=0;
        for(int i=1;i<=r;i++) tmp[a[i][j]]=1;
        for(int i=1;i<=n;i++)
            if(!tmp[i]) Paint::add(j,c+i);
    }
    for(int j=1;j<=c;j++)
        for(int i=r+1;i<=n;i++)
            a[i][j]=to[j][i-r]-c;
    return 1;
}
void work2()
{
    Paint::init(2*n,n-c);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++) tmp[j]=0;
        for(int j=1;j<=c;j++) tmp[a[i][j]]=1;
        for(int j=1;j<=n;j++)
            if(!tmp[j]) Paint::add(i,n+j);
    }
    for(int i=1;i<=n;i++)
        for(int j=c+1;j<=n;j++)
            a[i][j]=to[i][j-c]-n;
}
void work()
{
    cin>>n>>r>>c;bool fl=1;
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            cin>>a[i][j];
    if(r<n) fl=work1();
    if(fl) work2();
    if(!fl){cout<<"No\n";return;}
    cout<<"Yes\n";
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cout<<a[i][j]<<" \n"[j==n];
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int T;cin>>T;while(T--) work();
    return 0;
}
```


---

## 作者：Rainbow_qwq (赞：16)

考虑 $C=n$ 怎么做，不难猜测在这种情况下一定有解。

相当于左部点向 $k$ 个不同右部点有连边，要求 $k$ 个完美匹配的方案，也就是二分图边染色。

这是 $k$-正则二分图，根据[前置知识](https://www.luogu.com.cn/blog/rqy/hall-theorem-regular-bigraph)：

- 可以用随机算法 $O(n\log n)$ 单次找一组完美匹配（[正则二分图匹配](https://loj.ac/p/180)）；
- 在 $n$ 为偶数时，可以用欧拉回路，递归成两个 $\frac{n}{2}$ 的子问题（$\deg = 2^k$ 时的染色方法）。

运用上述两条规约子问题，在 $n$ 为奇数时用第一条，在 $n$ 为偶数时用第二条，就可以找到正则二分图的匹配划分。

时间复杂度是 $T(k) = 2 T(\frac{k}{2}) + O(kn+n\log n)$，于是复杂度 $O(n^2\log n)$。

再考虑 $C<n$ 怎么做。

假设一个颜色 $x$ 在 $R\times C$ 中的出现次数为 $c_x$。

如果 $c_x + 2n-R-C < n$ 即 $c_x < R+C-n$，那么一定不可行，因为每次加一行或加一列最多会多一个 $x$。

否则能构造证明一定是有解的。

考虑先把 $R\times C$ 补全为 $R\times n$，对于初始的 $R$ 行，考虑剩下的 $n-C$ 列，用“行”去匹配“颜色”，跑一个匹配划分，把每一组匹配都放在同一列。

右边建 $n$ 个表示颜色的点，左边建 $n$ 个表示行的点。

对于前 $R$ 行，每行向这行没有出现过的颜色连边。这样会得到左边 $R$ 个点，每个点出度 $n-C$，右边有 $n$ 个点，每个点度数 $\le n-C$。

这还不是正则二分图，于是对剩下的 $n-R$ 列，往左边建 $n-R$ 个虚点，补全成正则二分图。

对于剩下的 $n-R$ 个点，每行贪心分配剩下的右边的度数，把图补全成一张正则二分图。于是再使用正则二分图的匹配划分即可，然后把每一组匹配都放在同一列。

由于剩下的右部点度数为 $c_x$，而 $c_x\ge R+C-n$，每次选 $c_x$ 最大的若干个连边，就可以连完所有度数。

时间复杂度 $O(n^2\log n)$，[这个做法的代码实现](https://qoj.ac/submission/315091)，由于本题数据范围 $n\le 500$ 所以并没有比 $O(n^3)$ 快多少。

---

## 作者：FFTotoro (赞：12)

看到这种矩阵构造又有奇怪约束的题目，考虑建图解决。

$C=n$ 似乎是一个很好的入手点。可以观察到在这种情况下每一列要填哪些值都知道了，但是不知道每个值要填在哪一行。于是考虑建出二分图，由**值**向**列**连边；因为要求同一行不能有相同的值，这是一个典型的[二分图边染色问题](https://www.luogu.com.cn/problem/CF600F)，最终每条边的颜色即为该值在该列的行数。可以证明这种情况下一定有解。

但是 $C<n$ 的情况可能会出现无解。考虑把原矩阵补成一个 $C=n$ 的矩阵（就是把右上角那一块填上）。仍然使用上面的做法，这次由**值**向**行**连边，然后每条边的颜色就是其所在的列。注意如果使用的颜色数 $p$ 与 $n-C$ 不相等，说明无解。

使用找 $\mathrm{mex}$ 然后调整冲突的方法进行二分图边染色，封装成一个类似乎比较好写。代码实现中使用了 C++17 中的 `std::variant`，使用方法见[这里](https://en.cppreference.com/w/cpp/utility/variant)。

放代码：

```cpp
#include<bits/stdc++.h>
#define int short
using namespace std;
class EdgeColoring{
  private:
    vector<int> d;
    vector<vector<int> > a;
    // a[i][j] 表示 i 结点出发的颜色为 j 的边到达哪个点
  public:
    EdgeColoring(int n,int m){
      d.resize(n+m);
      a.resize(n+m,vector<int>(n+m,-1));
    } // 初始化
    int add_edge(int u,int v){
      d[u]++,d[v]++; // 记录度数，判断无解用
      int c1=0,c2=0;
      while(~a[u][c1])c1++;
      while(~a[v][c2])c2++; // 找 mex
      a[u][c1]=v,a[v][c2]=u;
      if(c1!=c2) // 有冲突
        for(int c3=c2,i=v;~i;i=a[i][c3],c3^=c1^c2)
          swap(a[i][c1],a[i][c2]); // 调整
      return c1;
    }
    pair<int,vector<vector<int> > > color(){
      return make_pair(*max_element(d.begin(),d.end()),a);
    } // 返回值前者为颜色数，后者为染色方案
}; // 二分图边染色
variant<vector<vector<int> >,bool> f1(int n,vector<vector<int> > &a){
  vector s(a.size(),vector<int>(n));
  for(int i=0;i<a.size();i++)
    for(int j=0;j<a[0].size();j++)
      s[i][j]=a[i][j];
  EdgeColoring g(n,a.size());
  for(int i=0;i<a.size();i++){
    vector<bool> b(n);
    for(int j=0;j<a[0].size();j++)
      b[a[i][j]-1]=true;
    for(int j=0;j<n;j++)
      if(!b[j])g.add_edge(j,i+n);
  } // 建图
  auto [p,m]=g.color(); // 染色
  if(p!=n-a[0].size())return false; // 无解
  for(int i=0;i<n;i++)
    for(int j=0;j<n-a[0].size();j++)
      if(~m[i][j])s[m[i][j]-n][j+a[0].size()]=i+1; // 构造
  return s;
}
vector<vector<int> > f2(int n,vector<vector<int> > &a){
  vector s(n,vector<int>(n));
  for(int i=0;i<a.size();i++)
    s[i]=a[i];
  EdgeColoring g(n,n);
  for(int i=0;i<n;i++){
    vector<bool> b(n);
    for(int j=0;j<a.size();j++)
      b[a[j][i]-1]=true;
    for(int j=0;j<n;j++)
      if(!b[j])g.add_edge(j,i+n);
  }
  auto m=g.color().second;
  for(int i=0;i<n;i++)
    for(int j=0;j<n-a.size();j++)
      if(~m[i][j])s[j+a.size()][m[i][j]-n]=i+1;
  return s;
}
main(){
  ios::sync_with_stdio(false);
  int t; cin>>t;
  while(t--){
    int n,r,c; cin>>n>>r>>c;
    vector a(r,vector<int>(c));
    for(auto &i:a)for(auto &j:i)cin>>j;
    if(auto s=f1(n,a);get_if<bool>(&s))cout<<"No\n";
    else{
      auto s2=f2(n,get<vector<vector<int> > >(s));
      cout<<"Yes\n";
      for(auto i:s2){
        for(int j:i)cout<<j<<' ';
        cout<<'\n';
      }
    }
  }
  return 0;
}
```

---

## 作者：Purslane (赞：6)

# Solution

个人认为这道题 << D1T2。不过 vp 的时候一直在想 flow，当时还不会二分图染色，就打了个暴力跑路。![](https://pic2.zhimg.com/v2-413a6e79909a18f3e4bbf9192e70426d_b.webp)

> 我考场上的想法：建立 $2n^2$ 个虚点，表示每行每列的颜色；把格子拆点；然后建立网络流模型，跑最大流。但是这样会有 $O(n^3)$ 条边，显然过不了。

对于 $20$ 分做法，直接暴力枚举。

对于特殊性质 $A$，我们发现实际上可以通过对标号作用一个置换得到 $a_{i,j} = (i+j) \bmod n +1$ 这个矩阵。

考虑特殊性质 $B$。这时候相当于每一列都有一个要放置的数集 $S_i$。你需要每一列恰好放置这些数集，且同一行没有重复的。

考虑建立二分图，左部表示数，右边表示列。如果某一列要放置某一个数，那么就在相应的左部点和右部点之间连一条边。

那么考虑现在“行”的限制是什么。我们发现，显然每一列和每一行，每一种颜色和每一行都只能有最多一个交点。啥意思？就是某个组合对象，它和每个左部点以及右部点都最多只有一个相交的位置。这像极了[**二分图染色**](https://www.luogu.com.cn/blog/120947/solution-cf600f)。我们把边给染上颜色，就是行的标号。这样很容易确定每一列的每个数字放在哪一行。

> 注意，由于保证输入数据合法，剩下的数每种最多只出现 $n-r$ 次。否则，必定有一个数在**输入的数据中**出现了 $r+1$ 次。这是不可能的。所以我们一定可以构造出一组 $n-r$ 种颜色的染色方案。

这样可以在 $O(n^3)$ 的复杂度内完成特殊性质 $B$。实际很难跑满（如果你不满意，可以在二分图染色出现矛盾的过程中使用随机数钦定，这样不会被卡）。

对于原题，我们考虑先补齐右上角 $r \times (n-c)$ 的区域。考虑照搬特殊性质 $B$ 的做法。不过这次，我们研究每一行中出现的数集，把每一行当做右部点，每一列当做边的染色情况。

这时候一定有解吗？考虑如果有解，必定所有点的 $\deg$ 都小于等于 $n-c$（否则无法找出 $n-c$ 种颜色的染色方案）。

什么时候会出现 $\deg$ 大于 $n-c$？右部点，显然都不会出现，因为根据建图方式，他们恰好会有 $n-c$ 条边。那么只有左部点了！我们特判一下即可。这是唯一可能出无解的情况。

然后化归为 $c=n$ 的情况。完全套用特殊性质 $B$ 的做法就可以了。

你可以封装一个二分图染色的函数。这样特别好写。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=500+10;
int T,n,r,c,res[MAXN][MAXN];
int tl[MAXN][MAXN],tr[MAXN][MAXN],degl[MAXN],degr[MAXN],id[MAXN][MAXN];
pair<int,vector<int>> get_col(int n1,int n2,vector<pair<int,int>> G) {
	memset(tl,0,sizeof(tl)),memset(tr,0,sizeof(tr)),memset(degl,0,sizeof(degl)),memset(degr,0,sizeof(degr));
	int cnt=0; vector<int> ans(G.size());
	for(auto pr:G) degl[pr.first]++,degr[pr.second]++,id[pr.first][pr.second]=++cnt;
	int lst=max(*max_element(degl+1,degl+n1+1),*max_element(degr+1,degr+n2+1));
	for(auto pr:G) {
		int u=pr.first,v=pr.second;
		int flg=0;
		ffor(j,1,lst) if(tl[u][j]+tr[v][j]==0) flg=j;
		if(flg) tl[u][flg]=v,tr[v][flg]=u;	
		else {
			int flg1=0,flg2=0;
			ffor(j,1,lst) if(tl[u][j]==0) flg1=j;
			ffor(j,1,lst) if(tr[v][j]==0) flg2=j;
			int pos=v;
			vector<int> cl,cr;
			while(1) {
				cr.push_back(pos);
				if(tr[pos][flg1]) {
					cl.push_back(tr[pos][flg1]);
					pos=tl[tr[pos][flg1]][flg2];	
				}
				else break ;
			}
			for(auto id:cl) swap(tl[id][flg1],tl[id][flg2]);
			for(auto id:cr) swap(tr[id][flg1],tr[id][flg2]);
			tl[u][flg1]=v,tr[v][flg1]=u;
		}
	}
	ffor(i,1,n1) ffor(j,1,lst) if(tl[i][j]) ans[id[i][tl[i][j]]-1]=j;
	return {lst,ans};
}
int flg[MAXN];
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		cin>>n>>r>>c;
		memset(res,0,sizeof(res));
		ffor(i,1,r) ffor(j,1,c) cin>>res[i][j];
		vector<pair<int,int>> G;
		ffor(i,1,r) {
			memset(flg,0,sizeof(flg));
			ffor(j,1,c) flg[res[i][j]]=1;
			ffor(j,1,n) if(flg[j]==0) G.push_back({j,i});	
		}
		auto pr=get_col(n,r,G);
		if(pr.first!=n-c) {
			cout<<"No\n";
			continue ;	
		}
		ffor(i,0,(int)G.size()-1) res[G[i].second][c+pr.second[i]]=G[i].first;
		G.clear();
		ffor(j,1,n) {
			memset(flg,0,sizeof(flg));	
			ffor(i,1,r) flg[res[i][j]]=1;
			ffor(i,1,n) if(flg[i]==0) G.push_back({i,j});
		}
		pr=get_col(n,n,G);
		ffor(i,0,(int)G.size()-1) res[r+pr.second[i]][G[i].second]=G[i].first;
		cout<<"Yes\n";
		ffor(i,1,n) {
			ffor(j,1,n) cout<<res[i][j]<<' ';
			cout<<'\n';	
		}
	}
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：4)

[Problem Link](https://www.luogu.com.cn/problem/P10062)

**题目大意**

> 给定 $n\times n$ 矩阵的前 $R$ 行 $C$ 列元素，构造一个完整矩阵使得每一行每一列都是 $1\sim n$ 排列。
>
> 数据范围：$n\le 500$。

**思路分析**

先考虑 $C=n$ 的情况，此时相当于已经知道若干完整的行。

此时一定有解，可以依次构造每一行，建立二分图，左部点是这一行的所有位置，右部点是 $1\sim n$ 的值，如果一个位置可以填某个值，那么就在其间连一条边。

此时所有点的度数都是 $n-R$，那么这张图是一张正则二分图，根据 Hall 定理证明其完美匹配总是存在，那么就证明了此时矩阵总是存在。

考虑如何构造，如果不对每一行分别求匹配，那么我们就是要把这张正则二分图分解成 $n-R$ 个完美匹配。

事实上，这就是二分图最小边染色，下面给出做法：

> 对于任意一张二分图，其最小边染色定义为用最少的颜色给每条边染色，且每个点的所有出边两两异色。
>
> 事实上最小边染色的大小就是所有顶点的最大度数，这显然是一个下界，现给出构造性证明。
>
> 考虑每次加入一条边 $(u,v)$，如果 $u,v$ 的出边中的未选用元素集有公共元素，直接设为这种颜色。
>
> 否则任选一种 $u$ 的出边中未选用的颜色 $x$ 和 $v$ 的出边种未选用的颜色 $y$。
>
> 找到 $v$ 的 $x$ 颜色出边对应的端点 $w$，然后将 $(v,w)$ 设成颜色 $y$，然后 $(u,v)$ 设成颜色 $x$。
>
> 此时 $w$ 的出边中可能出现两个 $y$，把另外一个设成颜色 $x$，可以证明在二分图上这样的调整过程总会停止。
>
> 关于此构造的正确性与时间复杂度的证明：
>
> 该构造过程只更改了原颜色为 $x$ 或 $y$ 的颜色的边，所以暂时不考虑图上其它的边。
>
> 此时，每个点的度数不超过 $2$，所以此时图由若干链与环构成，且所有的链或环上边的颜色是 $x$，$y$ 交替出现的。
>
> 又因为 $u$ 一开始没有颜色 $x$ 的邻边，$v$ 一开始没有颜色 $y$ 的邻边，所以 $u,v$ 均是孤立点或链的一端。
>
> 假设 $u,v$ 是同一条链的两端，则该链 $u$ 端的边的颜色为 $y$，$v$ 端的颜色为 $x$，由于链上颜色交替出现，所以该链的长度（边数）是偶数；同时，由于 $u,v$ 在二分图的两侧，所以该链的长度是奇数。推出矛盾，所以 $u,v$ 是两条不同的链的端点。
>
> 容易发现，这个构造只会扫描 $u$ 所在的链，因此这个构造一定会结束，而且只会扫到 $O(n)$ 条边。

然后考虑 $C<n$ 的情况，那么对前 $R$ 列分别建点求出类似的二分图，左部点度数均为 $n-C$。

如果右部点中存在度数 $>n-C$ 的点，说明这种元素要在 $R\times(n-C)$ 区域中出现 $>n-C$ 次，显然无解。

否则类似地求出一组二分图边染色即可。

时间复杂度 $\mathcal O(n^3)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=505;
struct bip {
	int X,Y,g[MAXN<<1][MAXN];
	void init(int x,int y) {
		X=x,Y=y;
		for(int i=1;i<=X+Y;++i) memset(g[i],0,sizeof(g[i]));
	}
	void add(int u,int v) {
		v+=X;
		int x=1,y=1;
		while(g[u][x]) ++x;
		while(g[v][y]) ++y;
		g[u][x]=v,g[v][y]=u;
		if(x==y) return ;
		for(int w=v,z=y;w;w=g[w][z],z^=x^y) swap(g[w][x],g[w][y]);
	}
}	G;
int d[MAXN],a[MAXN][MAXN];
bool vis[MAXN];
void solve() {
	int n,R,C;
	cin>>n>>R>>C;
	for(int i=1;i<=n;++i) d[i]=R;
	for(int i=1;i<=R;++i) for(int j=1;j<=C;++j) cin>>a[i][j],--d[a[i][j]];
	for(int i=1;i<=n;++i) if(d[i]>n-C) return cout<<"No\n",void();
	G.init(R,n);
	for(int i=1;i<=R;++i) {
		memset(vis,false,sizeof(vis));
		for(int j=1;j<=C;++j) vis[a[i][j]]=true;
		for(int j=1;j<=n;++j) if(!vis[j]) G.add(i,j);
	}
	for(int i=1;i<=R;++i) {
		for(int j=1;j<=n-C;++j) a[i][j+C]=G.g[i][j]-R;
	}
	G.init(n,n);
	for(int i=1;i<=n;++i) {
		memset(vis,false,sizeof(vis));
		for(int j=1;j<=R;++j) vis[a[j][i]]=true;
		for(int j=1;j<=n;++j) if(!vis[j]) G.add(i,j);
	}
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=n-R;++j) a[j+R][i]=G.g[i][j]-n;
	}
	cout<<"Yes\n";
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) cout<<a[i][j]<<" \n"[j==n];
}
signed main() {
	ios::sync_with_stdio(false);
	int T; cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：User_Unauthorized (赞：3)

首先考虑若 $C = n$ 如何处理。

发现我们可以处理出每一列需要填的数字集合，且其需要满足如下限制：

- 每一行填的数字互不相同。

考虑建如下二分图：

- 左部点共 $n$ 个点，每个点代表一个数字；
- 右部点共 $n$ 个点，每个点代表一列；
- 若数字 $x$ 需要在第 $y$ 列中出现，那么建边 $\left(x, y\right)$。

不难发现此时每个数字均需要在 $n - R$ 列中出现，而每列也均需要出现 $n - R$ 个数字，因此此图为正则二分图，不难得出其最小边染色为 $n - R$。

因此我们考虑对该图进行边染色，若边 $\left(x, y\right)$ 被染色，那么所有与之同色的边可以组成一行且满足上述限制。

至此我们解决了 $C = n$ 的情况，对于 $C < n$ 的情况我们考虑补充右上角 $R \times n - C$ 的区域使其转化为 $C = n$ 的情况。

考虑类似于上述的方法，我们让左部点代表数字，右部点代表行。

但是区别在于这种情况下建出的二分图不一定为正则二分图，主要体现在左部点的度数不一定为 $n - C$，发现若存在左部点的度数大于 $n - C$ 那么一定无解，反之一定有解。进而继续处理即可。

我们只需要求两次二分图的最小边染色即可解决这个问题。若采取增广路径的方法那么复杂度为 $\mathcal{O}(n^3)$。

---

## 作者：shinzanmono (赞：2)

先考虑特殊性质 B 怎么做。

发现该性质已经将方格的左部填好，你只需要填右半部分即可。

也就是你需要将剩下的没填的 $n(n-C)$ 个数填进去，然后对于每行，每个未出现的数又要出现一次。

考虑行的编号为左部点，数字为右部点。设第 $i$ 行需要填 $x_1,x_2,\ldots,x_{n-C}$，那么对于 $j=1,2,\ldots,n-C$，将左部点 $i$ 和右部点 $x_j$ 连边，进行颜色范围为 $C+1,C+2,\ldots,n$ 的染色。比较显然的一点是左部点的度数都是 $n-C$，根据二分图染色结论可知，右部点的度数不能超过 $n-C$，否则无解。如果一条边 $(i,j)$ 的颜色为 $c$，那么 $A_{i,c}=j$。

接下来考虑将问题转化为特殊性质 B。

考虑将矩阵缩小为 $n\times C$，那么我们只需要按照刚才填行的方式把左下角的列全部填满，这样就转化为 $R=n$ 的问题。

两次二分图染色的时间复杂度为 $O(n^3)$，可以通过。

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
const int sz=510;
void solve(){
    int n,R,C;
    std::cin>>n>>R>>C;
    std::vector<std::vector<int>>a(n+1,std::vector<int>(n+1));
    std::vector<std::vector<int>>color(n*2+1,std::vector<int>(n+1,0));
    std::vector<std::vector<bool>>cnt(n+1,std::vector<bool>(n+1,0));
    for(int i=1;i<=R;i++)
        for(int j=1;j<=C;j++)std::cin>>a[i][j],cnt[j][a[i][j]]=true;
    std::vector<std::pair<int,int>>graph;
    std::vector<int>deg(n+1,0);
    for(int i=1;i<=C;i++)
        for(int j=1;j<=n;j++)
            if(!cnt[i][j])graph.push_back(std::make_pair(i,j+n)),deg[j]++;
    if(*std::max_element(deg.begin()+1,deg.end())>n-R)return std::cout<<"No\n",void();
    for(auto p:graph){
        int u=p.first,v=p.second,cu=R+1,cv=R+1;
        while(color[u][cu]!=0)cu++;
        while(color[v][cv]!=0)cv++;
        color[u][cu]=v,color[v][cv]=u;
        if(cu==cv)continue;
        for(int t=v,cur=cv;t!=0;t=color[t][cur],cur^=cu^cv)std::swap(color[t][cu],color[t][cv]);
    }
    for(int i=1;i<=C;i++)
        for(int j=R+1;j<=n;j++)a[j][i]=color[i][j]-n;
    color=std::vector<std::vector<int>>(n*2+1,std::vector<int>(n+1,0));
    cnt=std::vector<std::vector<bool>>(n+1,std::vector<bool>(n+1,0));
    deg=std::vector<int>(n+1,0);
    graph.clear();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=C;j++)cnt[i][a[i][j]]=true;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(!cnt[i][j])graph.push_back(std::make_pair(i,j+n)),deg[j]++;
    if(*std::max_element(deg.begin()+1,deg.end())>n-C)return std::cout<<"No\n",void();
    for(auto p:graph){
        int u=p.first,v=p.second,cu=C+1,cv=C+1;
        while(color[u][cu]!=0)cu++;
        while(color[v][cv]!=0)cv++;
        color[u][cu]=v,color[v][cv]=u;
        if(cu==cv)continue;
        for(int t=v,cur=cv;t!=0;t=color[t][cur],cur^=cu^cv)std::swap(color[t][cu],color[t][cv]);
    }
    for(int i=1;i<=n;i++)
        for(int j=C+1;j<=n;j++)a[i][j]=color[i][j]-n;
    std::cout<<"Yes\n";
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)std::cout<<a[i][j]<<" ";
        std::cout<<"\n";
    }
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int t;
    std::cin>>t;
    while(t--)solve();
    return 0;
}
```

---

## 作者：D2T1 (赞：2)

upd：卡过了。

首先考虑 $C = n$。

发现保证输入的子矩阵不存在一行或者一列有两个相同的数，那考虑建二分图，左边点表示每个数，右边点表示每一列，左边连右边表示这个数可以填到这一列。发现二分图每边有 $n$ 个点，每个点度数为 $k$，是个正则二分图。根据 Hall 定理可以每次跑出一个完美匹配，最后按照匹配填，肯定能找到解。

$C\neq n$ 也同理，首先将它转化到 $C=n$ 的问题，则考虑把前 $R$ 行填满。同样建图，左边点表示每个数，右边点表示每一行，左边连右边表示这个数可以填到这一行。发现二分图左边是 $n$ 个点但是右边点数 $=R\leq n$，右边点每个点度数 $n-C$ 但左边点度数不定。

那么如果左边存在一个点度数 $> n-C$，那么就要填 $> n-C$ 个这个数在 $R\times(n-C)$ 矩阵里，显然是无解的。

现在左边点度数一定 $\leq n-C$，那么我们将右边点个数补成 $n$，即新增 $n-R$ 个右边点，然后贪心地连边，容易理解可以把所有点度数补为相同的 $n-C$，然后按照上面的做法做就行。

但是复杂度是 $O(Tn^{3.5})$，过不去怎么办？

假设现在二分图每一个点度数为 $x$，若 $x$ 为奇数，跑一次匹配；否则对其求一个欧拉回路，可以把图分成两部分，分别跑匹配。那么现在仍然会跑 $n$ 次匹配，但是每次匹配的边数会减少，复杂度会变成 $O(Tn^{2.5})$。

```cpp
const int N = 510;
int T, n, r, c, a[N][N], flg, vs[N][N], ind[N*2], cnt[N], nw[N*2];
struct Graph{
	int hd[N*2], dep[N*2], now[N*2], tot = 1;
	struct edge{
		int eg, ln, nx, ban;
	} eg[N*N*5];
	void add(int u, int v, int w){
		eg[++tot] = { v, w, hd[u], 0 };
		hd[u] = tot;
	}
	bool bfs(int s, int t){
        memset(dep, 0, sizeof(dep));
        memcpy(now, hd, sizeof(hd));
        dep[s] = 1;
        queue<int> q;
        q.push(s);
        while(!q.empty()){
            int x = q.front();
            q.pop();
            for(int i = hd[x]; i; i = eg[i].nx){
                int y = eg[i].eg, z = eg[i].ln;
                if(!dep[y] && z && !eg[i].ban){
                    dep[y] = dep[x] + 1;
                    q.push(y);
                    if(y == t){
                        return 1;
                    }
                }
            }
        }
        return 0;
    }
    int dfs(int x, int t, int fl){
        if(x == t){
            return fl;
        }
        int rs = fl;
        for(int i = now[x]; i && rs; i = eg[i].nx){
            int y = eg[i].eg, z = eg[i].ln;
            now[x] = i;
            if(dep[y] == dep[x] + 1 && z && !eg[i].ban){
                int k = dfs(y, t, min(z, rs));
                if(!k){
                    dep[y] = 0;
                }
                eg[i].ln -= k;
                eg[i^1].ln += k;
                rs -= k;
            }
        }
        return fl - rs;
    }
    int dinic(int s, int t){
        int mf = 0, tmp = 0;
        while(bfs(s, t)){
            while(tmp = dfs(s, t, 1000)){
                mf += tmp;
            }
        }
        return mf;
    }
	void init(){
		tot = 1;
		memset(hd, 0, sizeof(hd));
	}
	int fl(){
		for(int i = 1; i <= n; ++ i){
			add(0, i, 1);
			add(i, 0, 0);
			add(i+n, n+n+1, 1);
			add(n+n+1, i+n, 0);
		}
		return dinic(0, n+n+1);
	}
} g, G[60];

void eular(int d, int deg){
	memset(ind, 0, sizeof(ind));
	memcpy(nw, G[d].hd, sizeof(nw));
	for(int i = 1; i <= n+n; ++ i){
		ind[i] = deg;
	}
	queue<int> q;
	for(int i = 1; i <= n; ++ i){
		if(ind[i]){
			q.push(i);
			int cl = 2;
			while(!q.empty()){
				int x = q.front();
				q.pop();
				for(int i = nw[x]; i; i = G[d].eg[i].nx){
					nw[x] = i;
					int y = G[d].eg[i].eg;
					bool chk = (x < y) ? G[d].eg[i].ln : !G[d].eg[i].ln;
					if(y != 0 && y != n+n+1 && ind[y] && chk && !G[d].eg[i].ban){
						-- ind[x];
						G[d].eg[i].ban = G[d].eg[i^1].ban = cl;
						cl = 5 - cl;
						q.push(y);
						break;
					}
				}
			}
		}
	}
}

void pp1(int l, int r, int d){
	if(l == r){
		for(int j = 1; j <= n; ++ j){
			for(int k = G[d].hd[j]; k; k = G[d].eg[k].nx){
				if(G[d].eg[k].eg > n && !G[d].eg[k].ban){
					a[G[d].eg[k].eg-n][l] = j;
					G[d].eg[k].ban = G[d].eg[k^1].ban = 1;
				}
			}
		}
		return;
	}
	if((r - l + 1) & 1){
		int i = l;
		G[d].fl();
		for(int j = 1; j <= n; ++ j){
			for(int k = G[d].hd[j]; k; k = G[d].eg[k].nx){
				if(G[d].eg[k].eg > n && !G[d].eg[k].ln && !G[d].eg[k].ban){
					a[G[d].eg[k].eg-n][i] = j;
					G[d].eg[k].ban = G[d].eg[k^1].ban = 1;
				}
			}
		}
		++ l;
	}
	int mid = l + r >> 1;
	eular(d, r-l+1);
	G[d+2].init();
	G[d+3].init();
	for(int x = 1; x <= n; ++ x){
		for(int j = G[d].hd[x]; j; j = G[d].eg[j].nx){
			int y = G[d].eg[j].eg;
			if(G[d].eg[j].ban == 3){
				G[d+2].add(x, y, 1);
				G[d+2].add(y, x, 0);
			} else if(G[d].eg[j].ban == 2){
				G[d+3].add(x, y, 1);
				G[d+3].add(y, x, 0);
			}
		}
	}
	pp1(l, mid, d+2);
	pp1(mid+1, r, d+3);
}
void pr1(){
	G[0].init();
	memset(vs, 0, sizeof(vs));
	memset(cnt, 0, sizeof(cnt));
	for(int i = 1; i <= r; ++ i){
		for(int j = 1; j <= c; ++ j){
			vs[a[i][j]][i] = 1;
			++ cnt[a[i][j]];
		}
	}
	for(int i = 1; i <= n; ++ i){
		cnt[i] = r - cnt[i];
		if(cnt[i] > n-c){
			flg = 0;
			return;
		}
		for(int j = 1; j <= r; ++ j){
			if(!vs[i][j]){
				G[0].add(i, j+n, 1);
				G[0].add(j+n, i, 0);
			}
		}
	}
	for(int i = r + 1, nw = 1; i <= n; ++ i){
		for(int j = 1; j <= n-c; ++ j){
			while(cnt[nw] == n - c){
				++ nw;
			}
			G[0].add(nw, i+n, 1);
			G[0].add(i+n, nw, 0);
			++ cnt[nw];
		}
	}
	pp1(c+1, n, 0);
}
void pp2(int l, int r, int d){
	if(l == r){
		for(int j = 1; j <= n; ++ j){
			for(int k = G[d].hd[j]; k; k = G[d].eg[k].nx){
				if(G[d].eg[k].eg > n && !G[d].eg[k].ban){
					a[l][G[d].eg[k].eg-n] = j;
					G[d].eg[k].ban = G[d].eg[k^1].ban = 1;
				}
			}
		}
		return;
	}
	if((r - l + 1) & 1){
		int i = l;
		G[d].fl();
		for(int j = 1; j <= n; ++ j){
			for(int k = G[d].hd[j]; k; k = G[d].eg[k].nx){
				if(G[d].eg[k].eg > n && !G[d].eg[k].ln && !G[d].eg[k].ban){
					a[i][G[d].eg[k].eg-n] = j;
					G[d].eg[k].ban = G[d].eg[k^1].ban = 1;
				}
			}
		}
		++ l;
	}
	if(l > r){
		return;
	}
	int mid = l + r >> 1;
	eular(d, r-l+1);
	G[d+2].init();
	G[d+3].init();
	for(int x = 1; x <= n; ++ x){
		for(int j = G[d].hd[x]; j; j = G[d].eg[j].nx){
			int y = G[d].eg[j].eg;
			if(G[d].eg[j].ban == 3){
				G[d+2].add(x, y, 1);
				G[d+2].add(y, x, 0);
			} else if(G[d].eg[j].ban == 2){
				G[d+3].add(x, y, 1);
				G[d+3].add(y, x, 0);
			}
		}
	}
	pp2(l, mid, d+2);
	pp2(mid+1, r, d+3);
}
void pr2(){
	static int vs[N][N];
	G[1].init();
	memset(vs, 0, sizeof(vs));
	for(int i = 1; i <= r; ++ i){
		for(int j = 1; j <= n; ++ j){
			vs[a[i][j]][j] = 1;
		}
	}
	for(int i = 1; i <= n; ++ i){
		for(int j = 1; j <= n; ++ j){
			if(!vs[i][j]){
				G[1].add(i, j+n, 1);
				G[1].add(j+n, i, 0);
			}
		}
	}
	pp2(r+1, n, 1);
}

void solve(){
	read(T);
	while(T--){
		read(n, r, c);
		flg = 1;
		for(int i = 1; i <= r; ++ i){
			for(int j = 1; j <= c; ++ j){
				read(a[i][j]);
			}
		}
		if(c < n){
			pr1();
		}
		if(flg){
			pr2();
			println_cstr("Yes");
			for(int i = 1; i <= n; ++ i){
				for(int j = 1; j <= n; ++ j){
					printk(a[i][j]);
				}
				print('\n');
			}
		} else {
			println_cstr("No");
		}
	}
}
```

---

## 作者：云浅知处 (赞：2)

考虑 $C=n$ 咋做，发现只需要每次扩展一行。具体来说，我们每次从 $R\times n\to (R+1)\times n$，并时刻保证每行是排列，且每列没有重复元素。考虑建二分图，如果 $A_{R+1,i}$ 可以取 $j$ 就连边 $(L_i,R_j)$，然后找一个完美匹配。

注意建出来的图是正则二分图（每个点度数均为 $n-R$），所以一定存在完美匹配，而且可以[在 $O(n\log n)$ 时间内求出完美匹配](https://www.luogu.com.cn/article/j989a4hs)，瓶颈在于建边，复杂度 $O(n^3)$。

考虑一般情况，发现只要我们能把它填成一个 $R\times n$ 的子矩形，且每行每列没有重复元素，那就套用上面的过程可以构造解；如果没办法填出这样的矩形那自然是无解的。现在只需要考虑怎么填出来这样的一个子矩形。

发现此时不一定可以任取一组完美匹配，例如 $n=4,R,C=2$，我们想要补全成 $2\times 4$ 的，目前的样子是

```
1 2
3 1
```

如果我们第一步补成了

```
1 2 3
3 1 2
```

那后面就无解了。但显然只需要

```
1 2 4 3
3 1 2 4
```

就有解。

我们考虑怎么判无解，考虑一种数 $x$，如果目前我们填到 $R\times i$ 了，它出现了 $j$ 次，那么它还需要出现 $R-j$ 次，于是需要 $R-j\le n-i$。那如果满足这个条件，是否一定有解呢。

仿照 QOJ895，考虑每次从 $i$ 扩展到 $i+1$。左侧建 $R+1$ 个点，右侧建 $n$ 个点，对于 $i\le R$，连 $(i,j)$ 当且仅当这一列上第 $i$ 个位置可以放 $j$，选这条匹配边意味着把这个位置确实填上 $j$；第 $R+1$ 个点则代表失配，对右侧的每个点，只要它还能失配（即 $R-j<n-i$），我们就连到这个点上。

为了方便证明，对于右侧点 $x$，如果它出现了 $j$ 次，那么我们往左侧点 $R+1$ 上连 $n-i-(R-j)$ 条边，那么 $n-i=R-j$ 的时候这个边数就是 $0$，相当于不能失配。

算一下每个点的度数：右侧每个点的度数都是 $n-i$，左侧前 $R$ 个点的度数都是 $n-i$，对于第 $R+1$ 个点，可以算出它的度数是 $(n-R)(n-i)$，于是我们把它看做 $n-R$ 个点，就得到一个每个点度数均为 $n-i$ 的正则二分图。那当然存在完美匹配，于是成功从 $i\to i+1$。同理跑正则二分图完美匹配即可。

进一步发现本题的约束其实比 QOJ895 更弱，本题要做的实际上可以看作一个 $k$ 正则二分图边染色问题。对于这一问题，考虑结合正则二分图完美匹配的两个算法：

- 若染色数 $k$ 为偶数，跑一遍欧拉回路，这样每个点的入边和出边数量相同，只保留入边或出边可以变成一个规模为 $(n,\frac{k}{2})$ 的子问题。
- 否则，我们可以先找一个完美匹配出来，然后转化为 $k$ 是偶数的情形。

有复杂度 $T(n,k)=2T(n,\frac{k}{2})+O(nk+n\log n)$，总复杂度为 $O(nk(\log k+\log n))$。

这里 $k=O(n)$，故复杂度为 $O(n^2\log n)$。

以下是 $O(n^3)$ 的代码。没太注意常数，跑得比较慢。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

mt19937 rnd(20070819);
int randint(int l,int r){return rnd()%(r-l+1)+l;}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int N=1005;

int n,R,C;
int a[505][505];

void clr(){memset(a,0,sizeof(a)),n=R=C=0;}

namespace Match{

int ml[N],mr[N],G[N*N],st[N],ed[N];
void init(int D){for(int i=1;i<=n*2;i++)ml[i]=mr[i]=0,ed[i]=ed[i-1]+D,st[i]=ed[i]+1;}
void adde(int u,int v){v+=n,G[--st[u]]=v,G[--st[v]]=u;}

void argu_L(int u);
void argu_R(int u,int pre);

void argu_R(int u,int pre){
	if(!mr[u])return mr[u]=pre,void();
	int p=mr[u];mr[u]=pre,argu_L(p);
}
void argu_L(int u){
	while(1){
		int p=G[randint(st[u],ed[u])];
		if(ml[u]==p)continue;
		ml[u]=p,argu_R(p,u);break;
	}
}
vector<int>Solve(){
	vector<int>id(n);
	for(int i=0;i<n;i++)id[i]=i+1;
	shuffle(id.begin(),id.end(),rnd);
	for(int i=0;i<n;i++)argu_L(id[i]);
	vector<int>ans(n+1);
	for(int i=1;i<=n;i++)ans[i]=ml[i]-n;
	return ans;
}

}

namespace Solve1{
	
void solve(){
	for(int i=R;i<n;i++){
		Match::init(n-i);
		for(int j=1;j<=n;j++){
			vector<int>vis(n+1);
			for(int k=1;k<=i;k++)vis[a[k][j]]=1;
			for(int k=1;k<=n;k++)if(!vis[k])Match::adde(j,k);
		}
		auto P=Match::Solve();
		for(int j=1;j<=n;j++)a[i+1][j]=P[j];
	}
	puts("Yes");
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cout<<a[i][j]<<" \n"[j==n];
	
	clr();
}

}

void solve(){
	n=read(),R=read(),C=read();
	for(int i=1;i<=R;i++)for(int j=1;j<=C;j++)a[i][j]=read();

	auto ext=[&](int cur){
		Match::init(n-cur);
		vector<int>cnt(n+1,0);
		for(int i=1;i<=R;i++){
			vector<int>vis(n+1,0);
			for(int j=1;j<=cur;j++)vis[a[i][j]]=1,cnt[a[i][j]]++;
			for(int j=1;j<=n;j++)if(!vis[j])Match::adde(i,j);
		}
		int now=R+1,deg=0;
		for(int i=1;i<=n;i++){
			int cc=n-cur-(R-cnt[i]);
			while(cc>0){
				if(deg==n-cur)deg=0,now++;
				int ret=n-cur-deg;
				if(ret<=cc)Match::adde(now,i),deg=0,now++,cc-=ret;
				else deg+=cc,Match::adde(now,i),cc=0;
			}
		}
		auto P=Match::Solve();
		for(int i=1;i<=R;i++)a[i][cur+1]=P[i];
	};
	
	vector<int>cnt(n+1);
	for(int i=1;i<=R;i++)for(int j=1;j<=C;j++)cnt[a[i][j]]++;
	for(int i=1;i<=n;i++)if(n+cnt[i]<R+C)return puts("No"),clr();
		
	if(R>1)for(int i=C;i<n;i++)ext(i);
	else{
		vector<int>vals;
		for(int i=1;i<=n;i++)if(cnt[i]==0)vals.emplace_back(i);
		for(int i=C+1;i<=n;i++)a[1][i]=vals[i-C-1];
	}
	
	return Solve1::solve();
}

signed main(void){
	
	int tt=read();while(tt--)solve();

	return 0;
}
```

---

## 作者：OrinLoong (赞：1)

## LGP10062 [SNTS 2024] 拉丁方 学习笔记
[Luogu Link](https://www.luogu.com.cn/problem/P10062)

### 前言
本题解借鉴自[这篇题解](https://www.luogu.com.cn/article/pvh8v339)。

原理相同，不过处理顺序略有不同：我是先考虑补全列数再考虑补全行数的，和题目一致，和那篇题解相反。

这题真的能当作省选 D1T3 吗？放 T2 还差不多。

说是这么说，要是放考场上你能保证切出来吗？

### 题意简述
定义：一个 $n\times n$ 的矩阵是拉丁方，当且仅当每行每列都是一个 $1\sim n$ 的排列。

现在给定一个矩阵 $A$ 左上角的一个 $R\times C$ 的矩阵，也就是 $A_{i,j}(1\le i\le R,1\le j\le C)$。问能不能把它补成一个拉丁方。多测。

$n\le 500$。

### 做法解析
看到 $n\le 500$，我感到一种 $n^3$ 的气息——我们感性理解，这玩意的解法基本上就是某种 DP 或者某种图匹配网络流之类的东西了。另外，本题中要填的数可以当成“颜色”去考虑。

我们先从性质 B 入手——$C=n$。此时我们发现其必定有解法。

> 具体来说，因为子矩阵内合法，所以不合法的情况一定出现在子矩阵外。我们先在每列剩余的位置填上这一列缺的元素，由于子矩阵合法，所以不会出现一列上有两个相同元素的情况；然后我们再安排每一列内部顺序使其尽量合法。如果还做不到，说明肯定有不可避免的，一行里有两个相同元素 $x$ 的情况（记这一行为 $r_1$）——但这就说明至少有一行 $r_2$ 不存在这种元素，并且 $r_1,r_2$ 都在子矩阵外。那么我们从 $r_1$ 换一个 $x$ 到 $r_2$ 就行，和“肯定不可避免”矛盾。

上文是对其必然有解的感性刻画；有没有更本质的刻画证明呢？有的兄弟有的。

我们既然想要严格刻画，再加上这个复杂度，我们大胆往图匹配上面靠。

我们建立一张二分图，左右各 $n$ 个点，如果第 $i$ 列还缺第 $j$ 种“颜色”的话就连一条 $(i,j)$ 的边。这样的话，我们发现其中一组完美匹配就等价于一行的合法填数方案。

> 二分图中，一组完美匹配是指 $n$ 条两两不共端点的边所组成的边集。此处完美匹配之所以有这样的意义：左部没有端点重合，意味着一个位置只能填一个数，右部没有端点重合，意味着一个颜色在一行内只能出现一次。

![pEdIvyn.png](https://s21.ax1x.com/2025/03/18/pEdIvyn.png)

如果我们能拆出来 $n-R$ 个完美匹配，那就说明有解了。而判定并求解能否拆出 $k$ 组完美匹配的过程，就等价于用 $k$ 种颜色进行二分图边染色的过程。不会二分图边染色的可参考[我的CFP600题解](https://www.cnblogs.com/OrinLoong/p/18778801)。而根据二分图边染色所需最小颜色数量等于图中最大度数的结论，这样一张图里面所有点的度数都是 $n-R$，所以必然有解。

那么对于更一般的情况呢？我们首先考虑把 $R\times C$ 补成 $R\times N$。这一步和上一步的处理是类似的，见图和代码。需要注意的是，此时图中最大度数 $mxd$ 就不一定等于 $N-C$ 了——如果大于的话，那说明无解，因为在 $N-C$ 列里面填入 $mxd$ 个颜色 $x$ 是做不到的。

![pEdIxLq.md.png](https://s21.ax1x.com/2025/03/18/pEdIxLq.md.png)

那这题就做完了！细节见代码。

### 代码实现
封装一个二分图染色器有助于写出优异的代码。

有一点细节，想清楚再写。

```cpp
#include <bits/stdc++.h>
using namespace std;
using namespace obasic;
const int MaxN=505;
int N,R,C,A[MaxN][MaxN];
struct Painter{
    int tov[MaxN<<1][MaxN];
    void init(int l,int d){
        for(int i=1;i<=l;i++){
            fill(tov[i]+1,tov[i]+d+1,0);
        }
    }
    void add(int u,int v){
        int cc1=1,cc2=1;
        while(tov[u][cc1])cc1++;
        while(tov[v][cc2])cc2++;
        tov[u][cc1]=v,tov[v][cc2]=u;
        if(cc1==cc2)return;
        for(int tc=cc2,w=v,cx=cc1^cc2;w;){
            swap(tov[w][cc1],tov[w][cc2]);
            w=tov[w][tc],tc^=cx;
        }
    }
}P;
int tmp[MaxN];
bool solve1(){
    P.init(R+N,N-C);fill(tmp+1,tmp+N+1,0);
    for(int i=1;i<=R;i++)for(int j=1;j<=C;j++)tmp[A[i][j]]++;
    for(int i=1;i<=N;i++)if(R-tmp[i]>N-C)return 0;
    for(int i=1;i<=R;i++){
        fill(tmp+1,tmp+N+1,0);
        for(int j=1;j<=C;j++)tmp[A[i][j]]++;
        for(int j=1;j<=N;j++)if(!tmp[j])P.add(i,j+R);
    }
    for(int i=1;i<=R;i++){
        for(int j=1;j<=N-C;j++){
            if(P.tov[i][j])A[i][j+C]=P.tov[i][j]-R;
        }
    }
    return 1;
}
void solve2(){
    P.init(N*2,N);
    for(int i=1;i<=N;i++){
        fill(tmp+1,tmp+N+1,0);
        for(int j=1;j<=R;j++)tmp[A[j][i]]++;
        for(int j=1;j<=N;j++)if(!tmp[j])P.add(i,j+N);
    }
    for(int i=1;i<=N;i++){
        for(int j=1;j<=N;j++){
            if(P.tov[i][j])A[j+R][i]=P.tov[i][j]-N;
        }
    }
}
void mian(){
    readi(N),readi(R),readi(C);
    for(int i=1;i<=R;i++)for(int j=1;j<=C;j++)readi(A[i][j]);
    if(C<N&&!solve1()){puts("No");return;};solve2(),puts("Yes");
    for(int i=1;i<=N;i++,puts(""))for(int j=1;j<=N;j++)writi(A[i][j]),putchar(' ');
}
int Tcn;
int main(){
    readi(Tcn);
    while(Tcn--)mian();
    return 0;
}
```

### 反思总结
填色可行性类问题，想想图匹配！

当然，本题与少儿益智填色游戏（迫真）无关。

---

## 作者：DengDuck (赞：1)

感觉难度是被二分图染色撑起来的。

考虑特殊性质 B，那么就说明前 $R$ 行是染好色的，我们感觉只能转换成网络流模型或者图论模型啊！DP 什么的感觉根本做不了。

考虑怎么建图可以表示出一种颜色一行，一列只出现一次，感觉可以对于每一列建点，然后对于每一种颜色建点，然后列和该列没有出现过的颜色建边，跑二分图染色就行了，二分图染色的限制恰好满足了两个限制。

考虑普遍形式，可以先把前 $R$ 行染好色（你把前 $R$ 行看成一个矩形，然后旋转 $90$ 度，然后类似特殊性质 B 那样做），然后再按照特殊性质 B 的方法染色。

时间复杂度为 $\mathcal O(n^3)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
#define pLL pair<LL,LL>
#define fir first
#define sec second
using namespace std;
const LL N=1005;
// const LL K;
// const LL M;
LL c[N][N];
vector<LL> work(LL A,LL B,vector<pLL>v)
{
    memset(c,0,sizeof(c));
    vector<LL>col;
    for(pLL i:v)
    {
        LL mx1=1,mx2=1;
        LL u=i.fir,v=i.sec;
       // cout<<u<<' '<<v<<endl;
        while(c[u][mx1])mx1++;
        while(c[v][mx2])mx2++;
        c[u][mx1]=v,c[v][mx2]=u;
        if(mx1==mx2)continue;
        for(LL t=mx2,x=v;x;x=c[x][t],t^=mx1^mx2)swap(c[x][mx1],c[x][mx2]);
    }
 //   cout<<endl;
    LL len=v.size();
    for(LL i=0;i<len;i++)
    {
        for(int j=1;;j++)
        {
            if(c[v[i].fir][j]==v[i].sec)
            {
                col.pb(j);
                break;
            }
        }
    }
    return col;
}
LL T,n,R,C,ans[N][N],hav[N];
vector<pLL>v;
int main()
{
    scanf("%lld",&T);
    while(T--)
    {
        scanf("%lld%lld%lld",&n,&R,&C);
        v.clear();
        memset(ans,0,sizeof(ans));
        for(int i=1;i<=R;i++)
        {
            for(int j=1;j<=C;j++)
            {
                scanf("%lld",&ans[i][j]);
            }
        }
        for(int i=1;i<=R;i++)
        {
            memset(hav,0,sizeof(hav));
            for(int j=1;j<=C;j++)hav[ans[i][j]]++;
            for(int j=1;j<=n;j++)
            {
                if(!hav[j])v.pb({i,j+R});
            }
        }
        vector<LL>res=work(R,n,v);
        LL len=res.size();
        for(int i=0;i<len;i++)
        {
            if(res[i])ans[v[i].fir][C+res[i]]=v[i].sec-R;
        }
        v.clear();
        // c -> n
        for(int i=1;i<=n;i++)
        {
            memset(hav,0,sizeof(hav));
            for(int j=1;j<=R;j++)hav[ans[j][i]]++;
            for(int j=1;j<=n;j++)
            {
                if(!hav[j])v.pb({i,j+n});
            }
        }
        res=work(n,n,v);
        len=res.size();
        for(int i=0;i<len;i++)
        {
            if(res[i])ans[R+res[i]][v[i].fir]=v[i].sec-n;
        }
        //r -> n
        LL flg=1;
        for(int i=1;i<=n;i++)
        {
            memset(hav,0,sizeof(hav));
            for(int j=1;j<=n;j++)
            {
                hav[ans[i][j]]++;
            }
            for(int j=1;j<=n;j++)
            if(!hav[j])
            {
                flg=0;
                break;
            }
            if(!flg)break;
        }
        for(int i=1;i<=n;i++)
        {
            memset(hav,0,sizeof(hav));
            for(int j=1;j<=n;j++)
            {
                hav[ans[j][i]]++;
            }
            for(int j=1;j<=n;j++)
            if(!hav[j])
            {
                flg=0;
                break;
            }
            if(!flg)break;
        }
        if(!flg)
        {
            puts("No");
            continue;
        }
        puts("Yes");
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                printf("%lld ",ans[i][j]);
            }
            printf("\n");
        }
    }
}
//RP++
```

---


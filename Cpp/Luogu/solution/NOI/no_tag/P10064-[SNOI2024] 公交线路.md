# [SNOI2024] 公交线路

## 题目描述

给定一棵 $n$ 个点的无根树。我们希望在一些点对之间修建公交线路，满足任意两个点之间只需要至多两条公交线路就能到达。

形式化地说，考虑树上的所有 $\frac{n (n - 1)}{2}$ 条两个端点不同的简单路径。对于这些路径的一个子集 $S$，称它是好的当且仅当：
- 考虑一张新的图 $G$，对于一对点 $u, v$，当且仅当存在 $S$ 中的一条路径 $P$，满足 $u$ 和 $v$ 都在 $P$ 上，我们会在 $u, v$ 之间连上边权为 $1$ 的无向边。
- 要求 $G$ 中任意两点之间的距离都不超过 $2$。

你需要求出有多少个子集 $S$ 是好的。由于答案可能很大，输出对 $998244353$ 取模的结果。

## 说明/提示

**【样例 \#1 解释】**

对于对于第一个样例，所有可行的方案为 $\{(1, 3)\}, \{(1, 3), (1, 2)\}, \{(1, 3), (2, 3)\}, \{(1, 3), (1, 2), (2, 3)\}, \{(1, 2), (2, 3)\}$。

---

**【样例 \#3】**

见附件中 `bus/bus3.in` 与 `bus/bus3.ans`。

这个样例满足测试点 $11 \sim 14$ 的条件限制。

---

**【样例 \#4】**

见附件中 `bus/bus4.in` 与 `bus/bus4.ans`。

这个样例满足测试点 $19 \sim 20$ 的条件限制。

---

**【数据范围】**

对于所有的数据，保证 $1 \le n \le 3000$。

具体如下：

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 3$ | $6$ | 无 |
| $4 \sim 7$ | $10$ | 无 |
| $8 \sim 10$ | $3000$ | A |
| $11 \sim 14$ | $100$ | 无 |
| $15 \sim 18$ | $500$ | 无 |
| $19 \sim 20$ | $3000$ | 无 |

特殊性质 A：保证树是一条链。

## 样例 #1

### 输入

```
3
1 2
2 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
6
1 2
2 3
2 4
3 5
3 6
```

### 输出

```
27296
```

# 题解

## 作者：Otomachi_Una_ (赞：23)

显然我们只需要考虑每个叶子节点 $u$ 新图上距离为 $1$ 的点 $S_u$。原题即要求每个叶子 $u,v$，$S_u,S_v$ 的交非空。

$S_u$ 显然是一个连通块，连通块两两交非空等价于由公共元素。这里公共元素必然是一个连通块。

根据经典的“点减边”容斥，我们只需要算出“钦定经过某个点的方案树和”减去“钦定经过某个边的方案树”即可。

考虑怎么算经过 $u$ 的方案数。我们只需要关心叶子。我们以 $u$ 为根，考虑容斥，钦定若干叶子不能和 $u$ 联通。dp状态是容易的，假设 $f_i$ 表示当前已经钦定 $i$ 个叶子不能和 $u$ 联通，那么考虑 $u$ 和 $v$ 合并。假设 $siz,lef$ 表示当前的子树大小，子树叶子个数，转移：
$$
tf_{i+j}\leftarrow f_i\times \binom{lef_v}{j}\times 2^{(siz_u-i)\times(siz_v-j)}
$$
 

$tf$ 是转移后的 $f$ 数组。

这样子单个 $u$ 复杂度已经是 $\mathcal O(n^2)$ 了，总复杂度是 $\mathcal O(n^3)$。考虑优化。

注意到树上背包卷积复杂度只有 $\mathcal O(n^2)$，考虑只容斥子树内元素。对于子树外元素钦定必须经过，这样子是可以直接算答案的，由于不需要卷积子树外的元素，复杂度只有 $\mathcal O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=3e3+5;
const int MOD=998244353;
void add(ll &x,ll y){x=(x+y%MOD+MOD)%MOD;}
ll ksm(ll a,int b){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}
int n;
ll fac[MAXN],inf[MAXN],ans;
vector<int> edg[MAXN];
ll f[MAXN],g[MAXN];
int lef[MAXN],siz[MAXN],rt=1,sl=0;
ll C(int x,int y){return fac[y]*inf[x]%MOD*inf[y-x]%MOD;}
void dfs(int u,int fa){
	if(edg[u].size()==1){
		lef[u]=siz[u]=1;
		return;
	}
	for(int v:edg[u]) if(v!=fa) dfs(v,u);
	memset(f,0,sizeof(f));
	siz[u]=f[0]=1;
	int in=0;
	for(int v:edg[u]) if(v!=fa){
		memset(g,0,sizeof(g));
		for(int i=0;i<=lef[u];i++) for(int j=0;j<=lef[v];j++)
			add(g[i+j],f[i]*(j&1?MOD-1:1)%MOD*C(j,lef[v])%MOD*ksm(2,(siz[u]-i)*(siz[v]-j))%MOD);
		swap(f,g);
		siz[u]+=siz[v];lef[u]+=lef[v];in+=siz[v]*(siz[v]-1)/2;
	}
	int os=n-siz[u],of=sl-lef[u];in+=os*(os-1)/2;
	for(int i=0;i<=lef[u];i++) add(ans,f[i]*ksm(2,in)%MOD*ksm(2,(os-of)*(siz[u]-i))%MOD*ksm(ksm(2,siz[u]-i)-1,of)%MOD);
	if(fa){
		in=os*(os-1)/2+siz[u]*(siz[u]-1)/2;
		for(int i=0;i<=lef[u];i++) add(ans,(i&1?1:MOD-1)*C(i,lef[u])%MOD*ksm(2,in)%MOD*ksm(2,(siz[u]-i)*(os-of))%MOD*ksm(ksm(2,siz[u]-i)-1,of)%MOD);
	}
}
int main(){
	ios::sync_with_stdio(false);
	fac[0]=inf[0]=1;
	for(int i=1;i<MAXN;i++) inf[i]=ksm(fac[i]=fac[i-1]*i%MOD,MOD-2);
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		edg[u].push_back(v);
		edg[v].push_back(u);
	}
	if(n==2) return cout<<1<<endl,0;
	while(edg[rt].size()==1) rt++;
	for(int i=1;i<=n;i++) if(edg[i].size()==1) sl++;
	dfs(rt,0);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Nesraychan (赞：17)

为啥洛谷现有的题解全是 $O(n^2\log n)$ 的做法？给个好写的 $O(n^2)$ 做法。

感觉这题是这套题中除了 D1T1 以外最简单的题（

------

显然最远的距离一定由两个叶子贡献，我们拎出一个非叶节点为根，分析一些性质。

考虑两个叶子 $u,v$ 何时距离 $\le 2$，这要求它们所一步能到达的最浅点 $f(u),f(v)$ 为祖先后代关系。不妨设 $f(u)$ 为 $f(v)$ 的祖先，还要求 $u$ 存在一个走一步的方式走入 $f(v)$ 的子树中。容易发现这便是充要条件。

考虑枚举 $x$ 表示最深的 $f(u)$，这个限制肯定最严。现在要求所有叶子都可以一步走到 $x$，并且存在一个在其子树内的叶子满足所能达到的最浅点为 $x$。

注意到第二个限制处理起来并不是很方便，可以先去掉这个条件，再扣掉所有在 $x$ 子树内的叶子都能达到 $x$ 的父亲的方案数。本质就是点数减边数等于一这个经典容斥。

只有第一个限制后直接做还是不好做，考虑容斥，这样就变成有一些边不能选，这是方便 dp 的。如果对所有叶子容斥跑背包的话是 $O(n^3)$ 的，考虑优化。

注意到只对子树内的叶子跑这个算法就是树形背包，复杂度为 $O(n^2)$，这是可以接受的。

于是我们只容斥子树内的叶子，由于只剩下最后一类反子树的点没有考虑，在确定了前面的信息之后我们是可以直接计算符合题意的方案数的，这样就把复杂度优化到了 $O(n^2)$。

最后剩下的一点问题就是扣掉都能达到 $x$ 的父亲的方案数，依旧考虑类似的做法，$O(n^2)$ 计算是容易的。

```cpp
#include<bits/stdc++.h>
#define IL inline
#define reg register
#define mod 998244353
#define N 3030
IL int read()
{
    reg int x=0; reg char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x;
}

IL int Add(reg int x,reg int y){return x+y<mod?x+y:x+y-mod;}
IL int Sub(reg int x,reg int y){return x<y?x-y+mod:x-y;}
IL void Pls(reg int &x,reg int y){x=Add(x,y);}
IL void Dec(reg int &x,reg int y){x=Sub(x,y);}
IL int Mul(reg int x,reg int y){reg long long r=1ll*x*y; return r<mod?r:r%mod;}

int pw[N*N],c[N][N],con[N][N];

IL void init(reg int n)
{
    pw[0]=1;
    for(reg int i=1;i<=n*n;++i)pw[i]=Mul(pw[i-1],2);
    for(reg int i=0,j;i<=n;++i)
    {
        con[i][0]=1;
        for(j=1;j<=n;++j)con[i][j]=Mul(con[i][j-1],Sub(pw[i],1));
    }
    for(reg int i=0;i<=n;++i)c[i][0]=1;
    for(reg int i=1,j;i<=n;++i)for(j=1;j<=i;++j)c[i][j]=Add(c[i-1][j],c[i-1][j-1]);
}

int n,rt,ans;
std::vector<int>G[N];

IL void add(reg int u,reg int v){G[u].push_back(v),G[v].push_back(u);}

int fa[N],sz[N],cnt[N];

void dfs(reg int u)
{
    sz[u]=1,cnt[u]=G[u].size()==1;
    for(reg auto v:G[u])if(!sz[v])
        fa[v]=u,dfs(v),sz[u]+=sz[v],cnt[u]+=cnt[v];
}

IL int A(reg int n){return n*(n-1)>>1;}

main()
{
    n=read();
    if(n<=2)puts("1"),exit(0);
    init(n);
    for(reg int i=n;--i;)add(read(),read());
    for(rt=1;G[rt].size()==1;++rt);
    dfs(rt);
    for(reg int u=1,i,j,w,up;u<=n;++u)
    {
        static int f[N],g[N];
        for(i=1;i<=n;++i)f[i]=0;
        f[1]=up=1;
        for(reg auto v:G[u])if(v!=fa[u])
        {
            for(i=1;i<=up;++i)for(j=0;j<=cnt[v];++j)
            {
                w=Mul(Mul(f[i],c[cnt[v]][j]),pw[i*(sz[v]-j)]);
                if(j&1)Dec(g[i+sz[v]-j],w); else Pls(g[i+sz[v]-j],w);
            }
            up+=sz[v];
            for(i=1;i<=up;++i)f[i]=g[i],g[i]=0;
        }
        reg int a0=cnt[u],b0=sz[u]-a0,a1=cnt[rt]-cnt[u],b1=n-sz[u]-a1;
        w=0;
        for(i=1;i<=up;++i)Pls(w,Mul(Mul(f[i],pw[i*b1]),con[i][a1]));
        for(reg auto v:G[u])if(v!=fa[u])w=Mul(w,pw[A(sz[v])]);
        w=Mul(w,pw[A(n-sz[u])]),Pls(ans,w),w=0;
        for(i=0;i<=a0;++i)
        {
            reg int k=Mul(Mul(c[a0][i],pw[(a0-i)*b1]),con[b0+a0-i][a1]);
            if(i&1)Dec(w,k); else Pls(w,k);
        }
        w=Mul(w,pw[A(a0+b0)+A(a1+b1)+b0*b1]),Dec(ans,w);
    }
    printf("%d\n",ans);
}
```

---

## 作者：xfrvq (赞：7)

太菜看不懂现有题解...

$O(n^2)$ 树形 dp 做法。

---

显然“存在一对点距离超过 $2$”的充要条件是“**存在一对叶子距离超过 $2$**”，于是**满足所有叶子距离 $\le 2$ 即可。**

而叶子间距离 $\le2$ 则意味着：**存在一个 $p$，可一步内到达任意叶子**。

所有叶子能到达的点一定是一个联通块。考虑联通块满足点数减边数为 $1$，数“每个点在联通块中出现的次数和”与“每条边在联通块出现的次数和”之差即可。

---

现在计算一个点 $u$ 出现在联通块中方案数，即所有叶子一步都能到达 $u$ 的方案数。

考虑二项式反演，设 **$f_i$ 为钦定 $i$ 个叶子不能一步到达 $u$ 方案数**，考虑一个形如树形背包的转移。

$$f^\prime_{i+j}\gets f_i\times\binom{lef_v}j\times2^{(siz_u-i)(siz_v-j)}$$

其中 $f^\prime$ 为转移后的 $f$，$siz$ 为子树大小，$lef$ 为子树中叶子个数。

转移的意义是：

+ $v$ 前的子树中有 $i$ 个叶子有限制，在 $v$ 子树中任选 $j$ 个叶子有限制，取法为 $\binom{lef_v}j$。
+ 此时 $v$ 前的子树有 $siz_u-i$ 个点无限制，$v$ 子树中有 $siz_v-j$ 个点无限制。
+ 无限制的点之间可以任意连边，即 $2^{(siz_u-i)(siz_v-j)}$。

这里没写 $(-1)^j$ 的容斥系数，也没考虑不跨过 $u$ 的边（即各子树内的边，这个可任意取，所以最后再考虑）。

---

此时如果对子树外叶子用上述式子换根转移，树形 dp 的复杂度是 $O(n^3)$，但只考虑子树内，复杂度就只有 $O(n^2)$（可以简单理解为，一对叶子只会在其 LCA 处被计算一次）。

所以先 dp 算子树内答案，统计的时候钦定子树外的叶子必选，是一个这样的转移式：

$$sum\gets f_i\times2^{in+(os-ol)(siz_u-i)}\times(2^{siz_u-i}-1)^{ol}$$

其中 $in$ 为不经过 $u$ 路径数，即各子树路径数 $\sum\frac{siz_v(siz_v-1)}2$。$os$ 为 $u$ 子树外点数，$ol$ 为 $u$ 子树外叶子数。

转移的意义是：

+ 在 $u$ 子树内钦定 $i$ 个叶子限制不取，$u$ 子树外叶子限制必须全取。
+ $u$ 子树内 $siz_u-i$ 个点无限制，$u$ 子树外 $os-ol$ 个点无限制。
+ 不经过 $u$ 的路径数任意取或不取：$2^{in}$。
+ 无限制的点对路径任意取或不取：$2^{(os-ol)(siz_u-i)}$。
+ $ol$ 个叶子必须与 $u$ 一步可达，也就是对于 $u$ 子树外叶子 $p$，$u$ 子树的 $siz_u-i$ 个无限制的点中有至少一个 $q$ 使路径 $p,q$ 被取。那么有 $2^{siz_u-i}-1$ 种取法（至少取一个的情况数，就是每个任取的情况数，减去所有都不取的 $1$ 种情况），对于 $ol$ 个叶子答案是 $(2^{siz_u-i}-1)^{ol}$。

---

此时还要算边的答案，不过边的情况较简单，dp 都不需要。原因是 dp 本质是合并多个子树的信息，而一条边 $\{u,fa_u\}$ 可看成两个子树的根，一个是原来的 $u$ 子树，一个是原来的 $u$ 子树外。直接合并即可。（而点就不得不看做所有 $v$ 子树和原来的 $u$ 子树外，这就是多个子树了）。

---

用预处理 $2$ 的幂次和 $2^i-1$ 的幂次来代替快速幂，总复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

const int N = 3e3 + 5;
const ll mod = 998244353;

int n,m,rt,lef[N],siz[N];
ll pw2[N * N],pw[N][N],C[N][N],f[2][N],sum;
vector<int> G[N];

void dfs(int u,int ft){
	if(G[u].size() == 1) return siz[u] = lef[u] = 1,void();
	for(int v : G[u]) if(v != ft) dfs(v,u);
	memset(f,0,sizeof f);
	int t = 0,in = 0; siz[u] = f[0][0] = 1;
	for(int v : G[u]) if(v != ft){
		t ^= 1,memset(f[t],0,sizeof f[t]);
		for(int i = 0;i <= lef[u];++i)	
			for(int j = 0,x = 1;j <= lef[v];++j,x = mod - x)
				(f[t][i + j] += f[t ^ 1][i] * x % mod * C[lef[v]][j] % mod * pw2[(siz[u] - i) * (siz[v] - j)] % mod) %= mod;
		siz[u] += siz[v],lef[u] += lef[v],in += siz[v] * (siz[v] - 1) / 2;
	}
	int os = n - siz[u],ol = m - lef[u];
	in += os * (os - 1) / 2;
	for(int i = 0;i <= lef[u];++i)
		(sum += f[t][i] * pw2[in] % mod * pw2[(os - ol) * (siz[u] - i)] % mod * pw[siz[u] - i][ol] % mod) %= mod;
	if(ft){
		in = siz[u] * (siz[u] - 1) / 2 + os * (os - 1) / 2;
		for(int i = 0,x = mod - 1;i <= lef[u];++i,x = mod - x)
			(sum += C[lef[u]][i] * x % mod * pw2[in] % mod * pw2[(os - ol) * (siz[u] - i)] % mod * pw[siz[u] - i][ol] % mod) %= mod;
	}
}

int main(){
	scanf("%d",&n);
	for(int i = 1,u,v;i < n;++i)
		scanf("%d%d",&u,&v),G[u].push_back(v),G[v].push_back(u);
	pw2[0] = C[0][0] = 1;
	for(int i = 1;i <= n * n;++i) pw2[i] = pw2[i - 1] * 2 % mod;
	for(int i = 1;i <= n;++i){
		pw[i][0] = C[i][0] = 1;
		for(int j = 1;j <= n;++j)
			C[i][j] = j ? (C[i - 1][j] + C[i - 1][j - 1]) % mod : 1,
			pw[i][j] = pw[i][j - 1] * (pw2[i] - 1) % mod;
	}
	for(int i = 1;i <= n;++i) G[i].size() == 1 ? ++m : (rt = i);
	dfs(rt,0);
	return printf("%lld\n",sum),0;
}
```

---

## 作者：yyyyxh (赞：6)

有趣 trick 题。但是做法超纲。

首先来刻画一下好的路径组 $S$ 需要满足的条件。

第一个观察是，我们只需要检查两个叶子间是否可以两步可达就行了，因为两个内点肯定没有对应的两个叶子相距的远。

那么我们可以考虑从一个叶子 $i$ 跳一步可以走到哪些点，这也就是以这个叶子为一个端点的所有路径形成的点集并。不妨记为 $P_i$

那么题目的条件等价于所有 $P_i$ 两两相交。

由于这是一颗树，而 $P_i$ 又全是联通点集，所以说两两相交等价于 $\bigcap_{i\text{ is leaf}} P_i$ 是一个非空的连通块。

我们考虑以这个连通块为对象计数。每一个合法路径组对应一个连通块。我们期望每一个合法路径组恰好被统计一次。

考虑经典点减边 trick。这样我们只需要统计每一个点以及每一条边被对应的连通块包含的方案数。

先看一个点，那么这就相当于找出所有经过这个点的路径之后，这些路径覆盖了每一个叶子。一条边同理。

覆盖每一个叶子不好处理，我们容斥。容斥之后就变成了一个类似背包的形式，直接 DP 可以做到 $O(n^3)$ 拿到 90 分。（这跟叶子个数有关，所以也可以直接过链那档分）。

发现这个背包不同于一般的卷积背包的地方在于，它带了一个 $2^{ij}$ 的转移系数。

于是我们考虑一个神秘技巧：Chirp-Z 变换！

即把它拆成 $2^{{i+j\choose 2}-{i \choose 2}-{j \choose 2}}$。

然后你要卷 $deg_i$ 个多项式，看起来需要带两只 $\log$？

注意到前 $deg_i-1$ 个多项式卷起来就是树形背包，暴力卷复杂度就是 $O(n^2)$ 的，最后一个直接卷，复杂度就做到了 $O(n^2\log n)$。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int N=3003,M=N*N>>1;
const int P=998244353;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
int n,m,cnt;
int deg[N];
int qp(int a,int b=P-2){
	int res=1;
	while(b){
		if(b&1) res=(ll)res*a%P;
		a=(ll)a*a%P;b>>=1;
	}
	return res;
}
int read(){/* read */}
int hd[N],ver[N<<1],nxt[N<<1],tot;
void add(int u,int v){nxt[++tot]=hd[u];hd[u]=tot;ver[tot]=v;}
int ipw[M],pw[M],sz[N],sm[N];
int res;
int f[N],g[N];
int C[N][N];
int S(int x){return x*(x-1)>>1;}
typedef vector<int> vi;
int rev[1<<13],cw[1<<13|1];
int ilen,len,bit;
inline void inc(int &x,int v){if((x+=v)>=P) x-=P;}
inline void dec(int &x,int v){if((x-=v)<0) x+=P;}
void init(int _len){
	len=1;bit=-1;
	while(len<_len) len<<=1,++bit;
	int w=qp(3,(P-1)>>(bit+1));
	cw[len]=cw[0]=1;
	for(int i=1;i<len;++i){
		rev[i]=(rev[i>>1]>>1)|((i&1)<<bit);
		cw[i]=(ll)cw[i-1]*w%P;
	}
	ilen=qp(len);
}
struct poly{
	vi f;
	poly(int Len):f(Len){}
	poly(initializer_list<int> Init):f(Init){}
	void NTT(){
		f.resize(len,0);
		for(int i=0;i<len;++i) if(i<rev[i]) swap(f[i],f[rev[i]]);
		for(int i=1,tt=len>>1;i<len;i<<=1,tt>>=1)
			for(int j=0;j<len;j+=(i<<1))
				for(int k=j,t=0;k<(j|i);++k,t+=tt){
					int x=f[k],y=(ll)f[k|i]*cw[t]%P;
					if((f[k]=x+y)>=P) f[k]-=P;
					if((f[k|i]=x-y)<0) f[k|i]+=P;
				}
	}
	void INTT(){
		for(int i=0;i<len;++i) if(i<rev[i]) swap(f[i],f[rev[i]]);
		for(int i=1,tt=len>>1;i<len;i<<=1,tt>>=1)
			for(int j=0;j<len;j+=(i<<1))
				for(int k=j,t=len;k<(j|i);++k,t-=tt){
					int x=f[k],y=(ll)f[k|i]*cw[t]%P;
					if((f[k]=x+y)>=P) f[k]-=P;
					if((f[k|i]=x-y)<0) f[k|i]+=P;
				}
		for(int i=0;i<len;++i) f[i]=(ll)f[i]*ilen%P;
		while(!f.empty()&&!f.back()) f.pop_back();
	}
};
int solve(vector<pii> vec){
	int num=0;
	f[0]=1;
	while(vec.size()>1lu){
		auto [a,b]=vec.back();vec.pop_back();
		for(int t=0;t<=num;++t) g[t]=f[t],f[t]=0;
		for(int t=0;t<=num;++t)
			for(int i=0;i<=a;++i)
				f[t+i]=(f[t+i]+(ll)g[t]*ipw[i*(n-b)+S(i)]%P*C[a][i])%P;
		num+=a;
	}
	auto [a,b]=vec.back();
	poly F(num+1),G(a+1);
	init(num+a+1);
	for(int i=0;i<=num;++i) F.f[i]=f[i],f[i]=0;
	for(int i=0;i<=a;++i) G.f[i]=(ll)ipw[i*(n-b)+S(i)]*C[a][i]%P;
	F.NTT();G.NTT();
	for(int i=0;i<len;++i) F.f[i]=(ll)F.f[i]*G.f[i]%P;
	F.INTT();
	num=F.f.size()-1;
	int res=0;
	for(int i=0;i<=num;++i){
		F.f[i]=(ll)F.f[i]*pw[S(i)]%P;
		if(i&1) dec(res,F.f[i]);
		else inc(res,F.f[i]);
	}
	res=(ll)res*pw[m]%P;
	return res;
}
void dfs(int u,int fa){
	sz[u]=1;sm[u]=(deg[u]==1);
	for(int i=hd[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==fa) continue;
		dfs(v,u);
		vector<pii> vec;
		vec.emplace_back(sm[v],sz[v]);
		vec.emplace_back(cnt-sm[v],n-sz[v]);
		sm[u]+=sm[v];
		sz[u]+=sz[v];
		dec(res,solve(vec));
	}
	vector<pii> tmp;
	if(fa) tmp.emplace_back(cnt-sm[u],n-sz[u]);
	for(int i=hd[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==fa) continue;
		tmp.emplace_back(sm[v],sz[v]);
	}
	inc(res,solve(tmp));
}
int main(){
	n=read();m=S(n);
	for(int i=1;i<n;++i){
		int u=read(),v=read();
		add(u,v);add(v,u);
		++deg[u];++deg[v];
	}
	for(int i=0;i<=n;++i){
		C[i][0]=1;
		for(int j=1;j<=i;++j){
			C[i][j]=C[i-1][j-1]+C[i-1][j];
			if(C[i][j]>=P) C[i][j]-=P;
		}
	}
	for(int i=1;i<=n;++i) if(deg[i]==1) ++cnt;
	pw[0]=ipw[0]=1;
	for(int i=1;i<=m;++i){
		pw[i]=(pw[i-1]<<1);
		if(pw[i]>=P) pw[i]-=P;
		ipw[i]=ipw[i-1];
		if(ipw[i]&1) ipw[i]+=P;
		ipw[i]>>=1;
	}
	dfs(1,0);
	printf("%d\n",res);
	return 0;
}
```

90 分代码。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int N=3003,M=N*N>>1;
const int P=998244353;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
int n,m,cnt;
int deg[N];
int qp(int a,int b=P-2){
	int res=1;
	while(b){
		if(b&1) res=(ll)res*a%P;
		a=(ll)a*a%P;b>>=1;
	}
	return res;
}
int read(){/*...*/}
int hd[N],ver[N<<1],nxt[N<<1],tot;
void add(int u,int v){nxt[++tot]=hd[u];hd[u]=tot;ver[tot]=v;}
void inc(int &x,int v){if((x+=v)>=P) x-=P;}
void dec(int &x,int v){if((x-=v)<0) x+=P;}
int pw[M],sz[N],sm[N];
int res;
int f[N],g[N],len;
int C[N][N];
int solve(vector<pii> vec){
	f[len=0]=1;
	for(auto [a,b]:vec){
		for(int t=0;t<=len;++t) g[t]=f[t],f[t]=0;
		for(int t=0;t<=len;++t)
			for(int i=0;i<=a;++i)
				f[t+i]=(f[t+i]+(ll)g[t]*pw[i*(n-b-t)]%P*C[a][i])%P;
		len+=a;
	}
	int res=0;
	for(int i=0;i<=len;++i){
		if(i&1) dec(res,f[i]);
		else inc(res,f[i]);
		f[i]=0;
	}
	res=(ll)res*qp(2,m)%P;
	return res;
}
void dfs(int u,int fa){
	sz[u]=1;sm[u]=(deg[u]==1);
	for(int i=hd[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==fa) continue;
		dfs(v,u);
		vector<pii> vec;
		vec.emplace_back(sm[v],sz[v]);
		vec.emplace_back(cnt-sm[v],n-sz[v]);
		sm[u]+=sm[v];
		sz[u]+=sz[v];
		dec(res,solve(vec));
	}
	vector<pii> tmp;
	if(fa) tmp.emplace_back(cnt-sm[u],n-sz[u]);
	for(int i=hd[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==fa) continue;
		tmp.emplace_back(sm[v],sz[v]);
	}
	inc(res,solve(tmp));
}
int main(){
	n=read();m=n*(n-1)>>1;
	for(int i=1;i<n;++i){
		int u=read(),v=read();
		add(u,v);add(v,u);
		++deg[u];++deg[v];
	}
	for(int i=0;i<=n;++i){
		C[i][0]=1;
		for(int j=1;j<=i;++j){
			C[i][j]=C[i-1][j-1]+C[i-1][j];
			if(C[i][j]>=P) C[i][j]-=P;
		}
	}
	for(int i=1;i<=n;++i) if(deg[i]==1) ++cnt;
	pw[0]=1;
	for(int i=1;i<=m;++i){
		pw[i]=pw[i-1];
		if(pw[i]&1) pw[i]+=P;
		pw[i]>>=1;
	}
	dfs(1,0);
	printf("%d\n",res);
	return 0;
}
```

---

## 作者：forest114514 (赞：5)

神秘题目，读错题意害人呐！

首先考虑就是选择所有链的一个子集，把子集内每条链上点两两连一条边，问所有点是否距离 $\leq 2$。

首先 $2$ 这个东西显然可以类似枚举中间点，就是每个点连边的点集两两交集非空。

然后发现每个点连边的点集就是经过自己的链的并，然后再发现只用关心叶子是否两两满足，所以除了叶子出发的链之外都没用。

考虑每个的链并是个联通块，所以它们的交也是个联通块，问有多少情况交是个连通块，你联想到**希望**使用点边容斥使得连通块变成了 $1$ 这个可以用于计算方案的思想。

首先要计算多少个集合其边集经过某个点 $u$，就是考虑每个叶子存在一条以其为端点出发的链经过了 $u$，这个如何计算？发现这个形式是**恰好全部**都经过了 $u$，不好做，容斥钦定了 $i$ 个不经过 $u$，其余叶子 $n-\text{叶子数}$ 条连边任选以及它们之间连线任选。

设 $f_{u,j}$ 为子树 $u$ 内钦定了 $j$ 个点不经过 $u$ 时**算钦定叶子和非叶子和以及叶子间的链**的方案数，设 $leaf_u$ 为 $u$ 子树内的点个数，每次合并一个子树：
$$
f_{u,i+j}\leftarrow 2^{(leaf_{u}-i)(leaf_{v}-j)+j(siz_v-1)-\binom{leaf_v}{2}}\binom{leaf_v}{j}f_{u,i},leaf_u\leftarrow  leaf_u+leaf_v
$$
直接对每个根做一次的话时间是 $O(n\cdot leaf_1^2)$ 的，有 $90$ 分。

考虑除了 $1$ 之外都有子树外的叶子没算，写一写看看有什么发现：
$$
ans_u=\sum\limits_{i=0}^{leaf_u}\sum\limits_{j=0}^{leaf_1-leaf_u} \binom{leaf_1-leaf_u}{j}\times  2^{(leaf_u-i)(leaf_1-leaf_u-j)}f_{u,i}
$$
哎不妨设子树外叶子选 $j$ 个内部的贡献就是 $g_j$，子树外叶子个数为 $c_u$，答案就是：
$$
ans_u=\sum\limits_{i=0}^{leaf_u}\sum\limits_{j=0}^{c_u} 2^{ij}f_{u,leaf_u-i}g_{c_u-j}
$$
可以看做求 $\sum\limits_{i=0}^{n}\sum\limits_{j=0}^{n}2^{ij}F_iG_j$，善良出题人模数给 $998244353$，这不给个 $10^9+7$，使用 CZT 可以做到 $O(n^2\log n)$，但是我们不会一点 poly 怎么办？

首先思考我们容斥的目的是因为叶子相互连边会对是否经过 $u$ 产生影响，这其中主要是 $u$ 不同子树内叶子的连边的影响了我们对于经过 $u$ 数量的判断，但是此时只有一个子树有这个顾虑了，其的影响非常好想了。

现在只有 $u$ 子树外的叶子了，只要钦定他们必须经过 $u$ 就行了，这些点需要在 $u$ 子树内除了钦定的叶子之外的点中至少选一个连边，不难发现对完了！感觉这个只容斥一半，后面直接强制钦定是思路好厉害！

时间复杂度 $O(n^2)$，这里偷懒写的 $O(n^2\log n)$ 的代码，原谅作者在脑子不清醒的状态下写得很屎山。

```cpp
const int N=3005,mod=998244353;
int n,rt,tot,siz[N],deg[N],leaf[N];
LL ksm(LL a,LL b){
	LL res=1;for(;b;b>>=1,a=a*a%mod) if(b&1) res=res*a%mod;return res;
}
vector<int> E[N];
LL f[N][N],tmp[N],ans,fac[N],ifac[N];
LL C(int n,int m){
	return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
void dfs(int x,int ff){
	if(deg[x]==1) leaf[x]=1;
	siz[x]=f[x][0]=1;
	for(auto y:E[x]){
		if(y==ff) continue;
		dfs(y,x);
		rep(i,0,leaf[x]) rep(j,0,leaf[y]) (tmp[i+j]+=f[x][i]*C(leaf[y],j)%mod*ksm(2,(leaf[x]-i)*(leaf[y]-j)+j*(siz[y]-leaf[y])+C(leaf[y],2))%mod)%=mod;
		leaf[x]+=leaf[y],siz[x]+=siz[y];
		rep(i,0,leaf[x]) f[x][i]=tmp[i]%mod,tmp[i]=0;
		
		rep(i,0,leaf[y]){
			(ans-=1ll*(mod+1-2*(i&1))%mod*C(leaf[y],i)%mod*ksm(2,leaf[y]*(siz[y]-1)-C(leaf[y],2)+(leaf[y]-i)*(n-siz[y]-(tot-leaf[y]))+
				(tot-leaf[y])*(n-siz[y]-1)-C(tot-leaf[y],2))%mod*ksm(ksm(2,siz[y]-i)-1,tot-leaf[y])%mod)%=mod;
		}
	}
	
	rep(i,0,leaf[x]){
		(ans+=1ll*(mod+1-2*(i&1))%mod*ksm(2,(leaf[x]-i)*(n-tot)+(n-siz[x]-1)*(tot-leaf[x])-C(tot-leaf[x],2))%mod*f[x][i]%mod*
		ksm(ksm(2,siz[x]-i)-1,tot-leaf[x])%mod)%=mod;
	}
}
bool _ED;
signed main(){
	fprintf(stderr,"%.20lf MB\n",(&_ST-&_ED)/1048576.0);
	//ios::sync_with_stdio(false);
	//cin.tie(0);cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	read(n),rt=1;
	if(n==2) return puts("1"),0;
	rep(i,1,n-1){
		int u,v;read(u,v);
		E[u].pb(v),E[v].pb(u);
		++deg[u],++deg[v];
	}
	while(deg[rt]==1) ++rt;
	fac[0]=1;
	rep(i,1,n) fac[i]=fac[i-1]*i%mod,tot+=(deg[i]==1);
	ifac[n]=ksm(fac[n],mod-2);
	per(i,n-1,0) ifac[i]=ifac[i+1]*(i+1)%mod;
	dfs(rt,0);
//	cerr<<C(n,2)-tot*(n-1)+C(tot,2)<<endl;
	write((ans%mod+mod)%mod*ksm(2,C(n-tot,2))%mod,'\n');
	fprintf(stderr,"%.4lf s\n",1.0*clock()/CLOCKS_PER_SEC);
	return 0;
}
```

---

## 作者：ningago (赞：3)

- 性质：对于题目中的 $S$ 合法性，只用考虑任意两**叶子节点** $u,v$ 在 $G$ 中；距离是否 $\leq 2$ 即可。

> 如果 $u,v$ 任意一个点不是叶子节点，把 $u/v$ 修改成其对应子树内任意叶子节点，同样满足条件。

也就是说可以将 $S$ 合法的判定条件转化为：令 $T_x$ 表示**叶节点** $x$ 能够通过 $S$ 中路径一步到达的节点集合，则对于任意两**叶子节点** $u,v$，$T_u\cap T_v\ne \varnothing$。

- 性质：上述条件相当于 $\bigcap_{x\in \text{leaf}}T_x=\varnothing$。

> 反证，由于 $T_x$ 一定是连通块，所以若上式为空则相当于存在环，显然不成立。

也就是说此时只需要判断 $\bigcap_{x\in \text{leaf}}T_x$ 是否非空即可，由于 $\bigcap_{x}T_x$（若非空则）必然是一个连通块，所以可以使用点 $-$ 边容斥，拆分成两个类似的问题：

- 对于每个节点 $k$，求 $\forall{x\in \text{leaf}}:k\in T_x$ 的方案数。
- 对于每条边 $u\to v$，求 $\forall{x\in \text{leaf}}:u,v\in T_x$ 的方案数。

考虑第一个问题（第二个问题是类似的，且更容易求解），直接做的困难在于如果一条经过 $k$ 的路径 $(p,q)$ 的两端点都是叶子，将会让 $k\in T_p/k\in T_q$ 两个条件同时成立。

但 $k\not\in T_x$ 这个条件是简单的，于是考虑容斥：固定 $k$，令 $f_i$ 表示**钦定**有 $i$ 个叶子节点满足 $k\not\in T_x$ 的方案数，此时对于以叶节点 $u$ 为端点的所有路径 $(u,v)$，$v$ 都不能是 $k$ 以及子树外的点。可以直接对于每个子树背包求解，复杂度 $O(n|\text{leaf}|^2)$。

一个巧妙的优化：考虑背包合并子树时，合并到最后一个子树的时候，此时就不存在 $(p,q)$ 的问题了，所以可以不对这个子树进行容斥，直接贡献（钦定过的叶子不连路径，否则随便连）。

考虑任意指定一个（非叶子）根 $root$，在考虑到 $k$ 时，将 $fa_k$ 对应的子树放在最后一个处理。此时的合并复杂度只与子数内叶子个数有关（即树形背包复杂度），复杂度 $O(n|\text{leaf}|)=O(n^2)$。（假定预处理了快速幂）

```cpp

#define N 3010
int n, root;
int fac[N], invf[N]; int C(int n, int m) { return 1ll * fac[n] * invf[m] % mod * invf[n - m] % mod; }
int h[N], e[N << 1], ne[N << 1], idx = -1, du[N];
void add_edge(int x, int y) { ne[++idx] = h[x], h[x] = idx, e[idx] = y; }
void add(int x, int y) { add_edge(x, y), add_edge(y, x); }
int f[N], tmp[N], sz[N], tot[N], all, ans;
void dfs(int k, int fa)
{
	sz[k] = 1, tot[k] = (du[k] == 1);
	if(du[k] == 1) { /*点 - 边抵消了*/ return; }
	for(int _ = h[k]; ~_; _ = ne[_]) if(e[_] != fa) dfs(e[_], k);
	f[0] = 1;
	for(int _ = h[k]; ~_; _ = ne[_])
	{
		int nx = e[_]; if(nx == fa) continue;
		for(int i = 0; i <= tot[k]; i++) for(int j = 0; j <= tot[nx]; j++)
			plus_(tmp[i + j], 1ll * f[i] * C(tot[nx], j) % mod * ksm(2, sz[nx] * (sz[nx] - 1) / 2 + (sz[nx] - j) * (sz[k] - i)) % mod);
		sz[k] += sz[nx]; tot[k] += tot[nx];
		for(int i = 0; i <= tot[k]; i++) f[i] = tmp[i], tmp[i] = 0;
	}
	int s = n - sz[k], t = all - tot[k], res = 0;
	for(int i = 0; i <= tot[k]; i++)
	{
		int v = 1ll * f[i] * ksm(2, s * (s - 1) / 2 + (s - t) * (sz[k] - i)) % mod * ksm(ksm(2, sz[k] - i) - 1, t) % mod;
		if(i & 1) plus_(res, sm(mod - v));
		else plus_(res, v);
	}
	plus_(ans, res);
	if(!fa) return;
	for(int i = res = 0; i <= tot[k]; i++)
	{
		int v = 1ll * ksm(2, s * (s - 1) / 2 + sz[k] * (sz[k] - 1) / 2 + (s - t) * (sz[k] - i)) * ksm(ksm(2, sz[k] - i) - 1, t) % mod * C(tot[k], i) % mod;
		if(i & 1) plus_(res, sm(mod - v));
		else plus_(res, v);
	}
	plus_(ans, sm(mod - res));
}

void solve()
{
	memset(h, idx = -1, sizeof(h));
	n = read();
	if(n <= 2) { print(1, '\n'); return; }
	for(int i = 1, x, y; i < n; i++) du[x = read()]++, du[y = read()]++, add(x, y);
	for(root = 1; du[root] == 1; root++);
	all = std::count(du + 1, du + 1 + n, 1);
	dfs(root, 0);
	print(ans, '\n');
}
```

---

## 作者：123456xwd (赞：2)

这道题相当于说叶子之间要满足条件，因为若 $(u,v)$ 不满足条件，那么他们子树内的叶子结点相互间也不满足条件。

设 $S_u$ 表示点 $u$ 经过一条边到达的点集，则 $\forall x,y\in leaf,S_x\cap S_y\neq \varnothing$。

相当于说所有叶子节点的交集不为空，那么一定是一个联通块。

点边容斥，先考虑计数点 $u$ 在联通块的方案数：

考虑点 $u$ 外的节点经过点 $u$ 其实是好算的，必须和点 $u$ 内的节点连接边，但是点 $u$ 内的就不一定了，所以先容斥计算点 $u$ 内的。

设 $f_{i}$ 表示考虑到点 $u$ 时，至少有 $i$ 个叶子不经过点 $u$ 的方案数，且我们只考虑了经过 $u$ 的边，则：

$$
f_{i+j}=f'_i\tbinom{lef_v}{j}2^{(siz_v-j)(siz_u-i)}
$$

其中 $lef_v,siz_v$ 分别表示子树内叶子和节点的数量。

这个类似树上背包，时间为 $\mathcal{O}(n^2)$，其实远远达不到。

最后考虑利用二项式反演计算，设 $Ans$ 表示包含 $u$ 的方案数，那么：

$$
Ans=2^{tmp}\sum_{i=0}^{lef_u}(-1)^i f_i\times2^{(siz_u-i)(n-siz_u-(m-lef_u))}(2^{siz_u-i}-1)^{m-lef_u}
$$

其中 $m$ 表示的是一共的叶子节点，$tmp$ 表示的是在 $u$ 外面的边的数量以及在 $u$ 儿子内的边的数量，$f_i$ 后面那两坨分别乘的是 $u$ 外的非叶子节点的贡献和叶子结点的贡献。

接下来考虑一下 $u\to fa_u$ 的边，这个就比较好计算了，和类似上面，设 $Ans'$ 表示包含 $u\to fa_u$ 的方案数，那么：

$$
Ans'=2^{tmp}\sum_{i=0}^{lef_u}(-1)^i\tbinom{lef_u}{i}2^{(siz_u-i)(n-siz_u-(m-lef_u))}(2^{siz_u-i}-1)^{m-lef_u}

$$
其中 $tmp=\tbinom{n-siz_u}{2}+\tbinom{siz_u}{2}$，即同边 $u\to fa_u$ 无关的贡献。

设最终答案为 $ans$，那么 $ans\gets Ans-Ans'$。

注意的是，我们的根节点的度数要 $\ge 2$，所以要特判 $n=2$ 的情况。

```c++
#include<bits/stdc++.h>
#define ull unsigned long long
#define ll long long
#define p_b push_back
#define m_p make_pair
#define pii pair<int,int>
#define fi first
#define se second
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define gcd __gcd
#define lowbit(x) (x&(-x))
using namespace std;
int rd(){
    int x=0,f=1; char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if (ch=='-') f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
void write(int x){
    if(x>9) write(x/10);
    putchar('0'+x%10);
}
const int N=3005,INF=0x3f3f3f3f,mod=998244353;
int ksm(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=1ll*res*a%mod;
        a=1ll*a*a%mod;b>>=1;
    }
    return res;
}
void add(int &x,int y){
    x+=y;
    if(x>=mod) x-=mod;
}
int C2(int x){return x*(x-1)/2;}
int C[N][N],pw[N*N],n,m,rt,f[N],g[N],siz[N],lef[N],ans;
vector<int> G[N];
void dfs(int u,int dad){
    if(G[u].size()==1){
        siz[u]=lef[u]=1;
        return;
    }
    for(auto v : G[u]) if(v!=dad) dfs(v,u);
    int tmp=0,res=0,x;
    memset(f,0,sizeof(f));siz[u]=1,f[0]=1;
    for(auto v : G[u]){
        if(v==dad) continue;
        for(int i=0;i<=lef[u];i++) g[i]=f[i],f[i]=0;
        for(int i=0;i<=lef[u];i++){
            for(int j=0;j<=lef[v];j++){
                add(f[i+j],1ll*g[i]*C[lef[v]][j]%mod*pw[(siz[v]-j)*(siz[u]-i)]%mod);
            }
        }
        siz[u]+=siz[v],lef[u]+=lef[v],tmp+=C2(siz[v]);
    }
    tmp+=C2(n-siz[u]),x=n-siz[u]-(m-lef[u]);
    for(int i=0;i<=lef[u];i++){
        if(i&1) add(res,mod-(1ll*f[i]*pw[(siz[u]-i)*x]%mod*ksm(pw[siz[u]-i]-1,m-lef[u])%mod));
        else add(res,1ll*f[i]*pw[(siz[u]-i)*x]%mod*ksm(pw[siz[u]-i]-1,m-lef[u])%mod);
    }
    res=1ll*pw[tmp]*res%mod;add(ans,res);
    if(!dad) return;
    res=0,tmp=C2(n-siz[u])+C2(siz[u]);
    for(int i=0;i<=lef[u];i++){
        if(i&1) add(res,mod-(1ll*C[lef[u]][i]*pw[(siz[u]-i)*x]%mod*ksm(pw[siz[u]-i]-1,m-lef[u])%mod));
        else add(res,1ll*C[lef[u]][i]*pw[(siz[u]-i)*x]%mod*ksm(pw[siz[u]-i]-1,m-lef[u])%mod);
    }
    res=1ll*pw[tmp]*res%mod;add(ans,mod-res);
}
int main(){
    n=rd();
    for(int i=1;i<n;i++){
        int u=rd(),v=rd();
        G[u].p_b(v),G[v].p_b(u);
    }
    if(n==2){
        puts("1");
        return 0;
    }
    C[0][0]=1,pw[0]=1;
    for(int i=1;i<=n;i++){
        C[i][0]=1;
        for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
    }
    for(int i=1;i<=n*n;i++) pw[i]=2ll*pw[i-1]%mod;
    for(int i=1;i<=n;i++){
        if(G[i].size()==1) m++;
        else if(!rt) rt=i;
    }
    dfs(rt,0);
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：zifanwang (赞：1)

弱化版：[CF1827E Bus Routes](https://www.luogu.com.cn/problem/CF1827E)。

对于 $n=2$ 的情况可以判掉，剩下的情况取一个度数大于一的点作为根。

首先发现如果叶子间满足条件，那么整棵树也满足条件。考虑叶子间什么时候满足条件，记点 $x$ 通过最多一条路径可以到达的所有点的集合为 $S_x$，则需满足 $\forall x,y\in \mathbf{leaf},S_x\cap S_y\ne \empty$。

又因为这是一颗树，可以推得 $\bigcap_{x\in \mathbf{leaf}}S_x\ne \empty$，且这个交在原树中一定是一个连通块。考虑经典的点减边容斥，答案即为钦定经过每一个点的方案数的和减去钦定经过每一条边的方案数的和。

先考虑怎么计算钦定经过每一个点的方案数的和。放到原树上考虑，先钦定在它子树外的所有叶子节点都满足条件，然后对于它的子树可以容斥计算。

因为它的一个儿子的子树中的叶子节点都是一样的，所以对于每个儿子只需要知道钦定了多少个不合法的叶子节点，背包合并即可，最后再乘上一些系数。

对于钦定经过边的情况类似，也是先钦定子树外的叶子节点都满足条件（这是为了保证背包这部分的总时间复杂度是 $\mathcal O(n^2)$），然后子树内再做一遍容斥。

然后就做完了，有亿些细节，时间复杂度 $\mathcal O(n^2)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 3003
#define md 998244353
#define pb push_back
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
using namespace std;
struct node{
	int x,y;
}e[mxn];
int n,tot,sz[mxn],c1[mxn],c[mxn][mxn];
vector<int>g[mxn];
ll ans,d[mxn],dp[mxn][mxn];
ll power(ll x,int y){
	ll ans=1;
	for(;y;y>>=1){
		if(y&1)ans=ans*x%md;
		x=x*x%md;
	}
	return ans;
}
void dfs(int x,int fa){
	if(g[x].size()==1){
		sz[x]=c1[x]=1;
		return;
	}
	dp[x][0]=1,sz[x]=1;
	int cnt=0;
	for(int i:g[x])if(i!=fa){
		dfs(i,x);
		cnt+=sz[i]*(sz[i]-1)/2;
		rep(j,0,c1[x])d[j]=dp[x][j],dp[x][j]=0;
		rep(j,0,c1[x]){
			rep(k,0,c1[i]){
				dp[x][j+k]=(dp[x][j+k]+d[j]*c[c1[i]][k]%md*power(2,(sz[i]-k)*(sz[x]-j)))%md;
			}
		}
		sz[x]+=sz[i],c1[x]+=c1[i];
	}
	cnt+=(n-sz[x])*(n-sz[x]-1)/2;
	ll sum=0;
	rep(j,0,c1[x])sum=(sum+(j&1?-1:1)*dp[x][j]*power(2,(sz[x]-j)*(n-sz[x]-(tot-c1[x])))%md*power(power(2,sz[x]-j)-1,tot-c1[x]))%md;
	ans=(ans+sum*power(2,cnt))%md;
	if(fa){
		sum=0;
		rep(j,0,c1[x])sum=(sum+(j&1?-1:1)*c[c1[x]][j]*power(2,(sz[x]-j)*(n-sz[x]-(tot-c1[x])))%md*power(power(2,sz[x]-j)-1,tot-c1[x]))%md;
		ans=(ans-sum*power(2,(n-sz[x])*(n-sz[x]-1)/2+sz[x]*(sz[x]-1)/2))%md;
	}
}
signed main(){
	scanf("%d",&n);
	c[0][0]=1;
	rep(i,1,n){
		c[i][0]=1;
		rep(j,1,i)c[i][j]=(c[i-1][j-1]+c[i-1][j])%md;
	}
	for(int i=1,x,y;i<n;++i){
		scanf("%d%d",&x,&y);
		g[x].pb(y),g[y].pb(x);
		e[i]={x,y};
	}
	if(n==2){
		puts("1");
		return 0;
	}
	rep(i,1,n)if(g[i].size()==1)tot++;
	int rt=1;
	while(g[rt].size()==1)rt++;
	dfs(rt,0);
	cout<<(ans+md)%md;
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10064)

**题目大意**

> 给定 $n$ 个点的树，在所有简单路径中选择若干条，要求任意两个点之间的路径都存在 $\le 2$ 条选出的路径覆盖其中的每条边，求方案数。
>
> 数据范围：$n\le 3000$。

**思路分析**

显然如果存在一条不合法路径，那么一定存在一条叶子到叶子的不合法路径。

因此只要所有叶子的路径合法。

我们取出每个叶子 $u$ 能通过一条选出路径到达的所有点 $S_u$，我们就是要要求所有 $S_u$ 交非空。

注意到 $S_u$ 的交如果非空，一定是连通块，因此我们可以使用点减边容斥，即计算每个点属于 $S_u$ 的交和每条边（两端点）属于 $S_u$ 的交的方案数。

先考虑如何计算 $u\to fa(u)$ 的边被 $S_u$ 的交包含的方案数，发现不好维护，不妨进行容斥，钦定 $u$ 子树内有多少个 $S_u$ 不包含这条边，可以算出子树外的叶子的 $S$ 一定经过 $u$ 方案数：
$$
\mathrm{Ans} =\sum_{i=0}^{l_u}(-1)^i\binom {l_u}i2^{(s_o-l_o)(s_u-i)}\times 2^{s_u(s_u-1)/2}\times 2^{s_o(s_o-1)/2}\times (2^{s_u-i}-1)^{l_o}
$$
其中 $s_u/s_o$ 表示 $u$ 子树内、外的大小，$l_u,l_o$ 表示 $u$ 子树内、外的叶子个数，具体意义就是分讨每类边的连接情况。

然后考虑 $u$ 被 $S_u$ 的交包含的方案数，此时不能直接容斥，因为此时删除 $u$ 后有 $\mathrm{deg}(u)$ 个连通块，我们只能钦定其中一个连通块中所有叶子的 $S$ 过 $u$。

那么我们可以背包维护容斥系数，$f_i$ 表示 $u$ 子树钦定 $i$ 个叶子不过 $u$ 的方案数，加上 $v$ 子树的转移就是：
$$
f'_{i+j}\gets f_i\times (-1)^j\binom{l_v}j\times 2^{(S_u-i)(S_v-j)}
$$
$u$ 子树外的叶子直接钦定 $S_u$ 必须过 $u$，算答案的式子和上面类似，由于此时卷积的上界是 $s_u$，因此复杂度是平方的。

时间复杂度 $\mathcal O(n^2\log P)$，瓶颈在计算答案时的快速幂，可以预处理优化掉。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=3005,MAXV=5e6+5,MOD=998244353;
ll ksm(ll a,ll b) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }
ll f[MAXN],g[MAXN],C[MAXN][MAXN],pw[MAXV],ans=0;
int n,sz[MAXN],sf[MAXN],lfc=0;
vector <int> G[MAXN];
void dfs(int u,int fz) {
	if(G[u].size()==1) return sz[u]=sf[u]=1,void();
	for(int v:G[u]) if(v^fz) dfs(v,u);
	memset(f,0,sizeof(f)),sz[u]=1,f[0]=1;
	int in=0;
	for(int v:G[u]) if(v^fz) {
		memset(g,0,sizeof(g));
		for(int i=0;i<=sf[v];++i) {
			ll w=i&1?MOD-C[sf[v]][i]:C[sf[v]][i];
			for(int j=0;j<=sf[u];++j) {
				g[i+j]=(g[i+j]+w*f[j]%MOD*pw[(sz[v]-i)*(sz[u]-j)])%MOD;
			}
		}
		memcpy(f,g,sizeof(f));
		in+=sz[v]*(sz[v]-1)/2;
		sf[u]+=sf[v],sz[u]+=sz[v];
	}
	int oz=n-sz[u],of=lfc-sf[u];
	in+=oz*(oz-1)/2;
	for(int i=0;i<=sf[u];++i) {
		ans=(ans+f[i]*pw[in+(oz-of)*(sz[u]-i)]%MOD*ksm(pw[sz[u]-i]-1,of))%MOD;
	}
	if(!fz) return ;
	in=oz*(oz-1)/2+sz[u]*(sz[u]-1)/2;
	for(int i=0;i<=sf[u];++i) {
		ll z=i&1?C[sf[u]][i]:MOD-C[sf[u]][i];
		ans=(ans+z*pw[in+(oz-of)*(sz[u]-i)]%MOD*ksm(pw[sz[u]-i]-1,of))%MOD;
	}
}
signed main() {
	scanf("%d",&n);
	for(int i=pw[0]=1;i<=n*(n-1)/2;++i) pw[i]=pw[i-1]*2%MOD;
	for(int i=0;i<=n;++i) for(int j=C[i][0]=1;j<=i;++j) {
		C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	}
	for(int i=1,u,v;i<n;++i) {
		scanf("%d%d",&u,&v),G[u].push_back(v),G[v].push_back(u);
	}
	if(n==2) return puts("1"),0;
	int rt=0;
	for(int i=1;i<=n;++i) {
		if(G[i].size()==1) ++lfc;
		else if(!rt) rt=i;
	}
	dfs(rt,0);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：win114514 (赞：1)

非常好题目。

### 思路

可以发现限制最严的一定是两个叶子的联通性。

我们不妨把一个叶子向外起到**联通性作用**的路径称为有用的路径。

也就是这个叶子走这条路径一定可以两步以内到达任意点。

这个路径集合有什么作用呢。

有一个性质：整个集合的路径的交最终会形成一个连通块。

那么我们就可以进行求解方案数。

考虑容斥。

我们设 $dp_{1,i}$ 为联通块内强制有 $i$ 这个点，设 $dp_{2,i}$ 为联通块内强制有 $i$ 这条边。

那么：

$$ans=\sum dp_{1,i}-\sum dp_{2,i}$$

如何求解？

首先考虑边的情况。

我们可以设 $f_i$ 为至少有 $i$ 个叶子不与这条边联通，$sz_i$ 表示 $i$ 的子树大小，$yz_i$ 表示 $i$ 的叶子数量。

那么：

$$f_{i+j}=\sum_{i=0}^{yz_x}C_{yz_x}^i 2^{i\times(sz_x-1)-\frac{i\times(i-1)}{2}}\sum_{j=0}^{yz_y}C_{yz_y}^j 2^{j\times(sz_y-1)-\frac{j\times(j-1)}{2}}$$

当然还要乘其他不重要的边的方案数，也是一个二的次幂。

暴力做是平方的。

容易发现可以多项式优化。

然后考虑点的情况。

同样可以设 $f_i$ 为至少有 $i$ 个叶子不与这个点联通。

那么加入一颗子树的代价是：

$$f_{i+j}=\sum f_i\sum_{j=0}^{yz_y}C_{yz_y}^j 2^{j\times(sz_y-1)-\frac{j\times(j-1)}{2}}$$

同样是卷积形式，可以多项式优化。

最终复杂度：$O(n^2 \log n)$。

---

## 作者：Leasier (赞：0)

~~明示 [CF1827E Bus Routes](https://www.luogu.com.cn/problem/CF1827E)。~~

------------

考虑将条件改为**对叶子的限制**，即要求任意两个叶子都能通过不超过两条路径到达。

考虑每个叶子 $u$ 一步可达点所构成的**连通块** $S_u$，则 $\forall \operatorname{leaf} u, v$，有 $S_u \cap S_v \neq \emptyset$。

考虑把这个性质转化成更适于计数的形式。容易感性理解或归纳出上式成立当且仅当 $T = \cap_{\operatorname{leaf} u} S_u \neq \emptyset$。

注意到当 $T$ 非空，$T$ 一定为一棵**树**。

- 当 $T$ 为森林，有**连通块计数** trick：$T$ 中连通块数为 $T$ 的边数减去 $|T|$。

于是我们可以对 $T$ 中的点和边计数。下面以点为例。

枚举点 $u \in T$，考虑容斥：在每个子树内钦定若干点不能选，容斥系数为 $-1$ 的点数次方；接下来在可选的点中随便选即可。

写出 dp 式子，可以发现转移形如 $h_i = \displaystyle\sum_{j = 0}^i f_i g_{i - j} 2^{j(i - j)}$。

施以 Chirp-Z 变换即可。时间复杂度为 $O(n^2 \log n)$。

代码：
```cpp
#include <iostream>

using namespace std;

const int mod = 998244353;
int power[4498507], inv_power[4498507];

inline int comb_2(int n){
	return n * (n - 1) / 2;
}

inline int add1(int x, int y){
	return x + y >= mod ? x + y - mod : x + y;
}

inline int sub1(int x, int y){
	return x - y < 0 ? x - y + mod : x - y;
}

inline int quick_pow(int x, int p){
	int ans = 1;
	while (p){
		if (p & 1) ans = 1ll * ans * x % mod;
		x = 1ll * x * x % mod;
		p >>= 1;
	}
	return ans;
}

namespace CZT {
	typedef struct {
		int n;
		int a[4097];
		
		inline void clear(int limit){
			for (register int i = n + 1; i < limit; i++){
				a[i] = 0;
			}
		}
	} Polynomial;
	
	const int mod_g = 3, mod_g_inv = 332748118;
	Polynomial p, temp1, temp2, temp3;
	int rev[4097], ans[3007];
	
	inline void init(int n){
		int m = n >> 1;
		for (register int i = 1; i < n; i++){
			rev[i] = rev[i >> 1] >> 1;
			if (i & 1) rev[i] += m;
		}
	}
	
	inline void NTT(Polynomial &a, int limit, int type){
		for (register int i = 0; i < limit; i++){
			if (i < rev[i]) swap(a.a[i], a.a[rev[i]]);
		}
		for (register int i = 1; i < limit; i <<= 1){
			int wn, j = i << 1;
			wn = quick_pow(type == 1 ? mod_g : mod_g_inv, (mod - 1) / j);
			for (register int k = 0; k < limit; k += j){
				int r = k + i, w = 1;
				for (register int l = k; l < r; l++){
					int x = a.a[l], y = l + i, z = 1ll * w * a.a[y] % mod;
					a.a[l] = add1(x, z);
					a.a[y] = sub1(x, z);
					w = 1ll * w * wn % mod;
				}
			}
		}
		if (type == -1){
			int inv_limit = quick_pow(limit, mod - 2);
			for (register int i = 0; i < limit; i++){
				a.a[i] = 1ll * a.a[i] * inv_limit % mod;
			}
		}
	}
	
	void operator *=(Polynomial &a, Polynomial &b){
		int limit = 1, t = a.n + b.n;
		while (limit <= t) limit <<= 1;
		init(limit);
		a.clear(limit);
		a.n = t;
		temp1.n = b.n;
		temp1.clear(limit);
		for (register int i = 0; i <= b.n; i++){
			temp1.a[i] = b.a[i];
		}
		NTT(a, limit, 1);
		NTT(temp1, limit, 1);
		for (register int i = 0; i < limit; i++){
			a.a[i] = 1ll * a.a[i] * temp1.a[i] % mod;
		}
		NTT(a, limit, -1);
	}
	
	inline void CZT(int a[], int b[], int n, int m, int ans[]){
		temp2.n = n;
		temp3.n = m;
		for (register int i = 0; i <= n; i++){
			temp2.a[i] = 1ll * a[i] * inv_power[comb_2(i)] % mod;
		}
		for (register int i = 0; i <= m; i++){
			temp3.a[i] = 1ll * b[i] * inv_power[comb_2(i)] % mod;
		}
		temp2 *= temp3;
		for (register int i = 0; i <= temp2.n; i++){
			ans[i] = 1ll * temp2.a[i] * power[comb_2(i)] % mod;
		}
	}
}

typedef struct {
	int nxt;
	int end;
} Edge;

const int inv2 = 499122177;
int cnt = 0;
int c[3007][3007], deg[3007], head[3007], fa[3007], sz[3007], leaf[3007], dp[3007], f[3007], g[3007];
Edge edge[6007];

inline void init(int n){
	int m = comb_2(n);
	c[0][0] = 1;
	for (register int i = 1; i <= n; i++){
		c[i][0] = 1;
		for (register int j = 1; j <= i; j++){
			c[i][j] = add1(c[i - 1][j], c[i - 1][j - 1]);
		}
	}
	power[0] = inv_power[0] = 1;
	for (register int i = 1; i <= m; i++){
		power[i] = power[i - 1] * 2 % mod;
		inv_power[i] = 1ll * inv_power[i - 1] * inv2 % mod;
	}
}

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void dfs(int u, int father){
	fa[u] = father;
	sz[u] = 1;
	leaf[u] = 0;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father){
			dfs(x, u);
			sz[u] += sz[x];
			leaf[u] += leaf[x];
		}
	}
	if (leaf[u] == 0) leaf[u] = 1;
}

inline void add2(int &x, int y){
	if ((x += y) >= mod) x -= mod;
}

inline void sub2(int &x, int y){
	if ((x -= y) < 0) x += mod;
}

int main(){
	int n;
	cin >> n;
	if (n <= 2){
		cout << 1;
		return 0;
	}
	int root, ans = 0;
	init(n);
	for (register int i = 1; i < n; i++){
		int u, v;
		cin >> u >> v;
		deg[u]++;
		deg[v]++;
		add_edge(u, v);
		add_edge(v, u);
	}
	for (register int i = 1; i <= n; i++){
		if (deg[i] > 1){
			root = i;
			break;
		}
	}
	dfs(root, 0);
	for (register int i = 1; i <= n; i++){
		int prod = 1, pre_leaf = 0, pre_non = 0, sum = 0;
		if (deg[i] == 1){
			dp[0] = 0;
			dp[1] = 1;
			pre_leaf++;
		} else {
			dp[0] = 1;
			pre_non++;
		}
		for (register int j = head[i]; j != 0; j = edge[j].nxt){
			int x = edge[j].end, cur_size, cur_leaf, cur_non;
			if (x != fa[i]){
				cur_size = sz[x];
				cur_leaf = leaf[x];
			} else {
				cur_size = n - sz[i];
				cur_leaf = leaf[root] - leaf[i];
			}
			cur_non = cur_size - cur_leaf;
			prod = 1ll * prod * power[comb_2(cur_size)] % mod;
			for (register int k = 0; k <= cur_leaf; k++){
				if ((cur_leaf - k) % 2 == 0){
					f[k] = c[cur_leaf][k];
				} else {
					f[k] = mod - c[cur_leaf][k];
				}
			}
			for (register int k = 0; k <= pre_leaf; k++){
				dp[k] = 1ll * dp[k] * power[(k + pre_non) * cur_non] % mod;
			}
			for (register int k = 0; k <= cur_leaf; k++){
				f[k] = 1ll * f[k] * power[pre_non * k] % mod;
			}
			CZT::CZT(dp, f, pre_leaf, cur_leaf, dp);
			pre_leaf += cur_leaf;
			pre_non += cur_non;
		}
		for (register int j = 0; j <= pre_leaf; j++){
			add2(sum, dp[j]);
		}
		add2(ans, 1ll * prod * sum % mod);
	}
	for (register int i = 1; i <= n; i++){
		if (i == root) continue;
		int p = leaf[root] - leaf[i], q = sz[i] - leaf[i], r = (n - sz[i]) - p, t = leaf[i] + p, sum = 0;
		for (register int j = 0; j <= leaf[i]; j++){
			if ((leaf[i] - j) % 2 == 0){
				f[j] = c[leaf[i]][j];
			} else {
				f[j] = mod - c[leaf[i]][j];
			}
		}
		for (register int j = 0; j <= p; j++){
			if ((p - j) % 2 == 0){
				g[j] = c[p][j];
			} else {
				g[j] = mod - c[p][j];
			}
		}
		for (register int j = 0; j <= leaf[i]; j++){
			f[j] = 1ll * f[j] * power[(j + q) * r] % mod;
		}
		for (register int j = 0; j <= p; j++){
			g[j] = 1ll * g[j] * power[q * j] % mod;
		}
		CZT::CZT(f, g, leaf[i], p, dp);
		for (register int j = 0; j <= t; j++){
			add2(sum, dp[j]);
		}
		sub2(ans, 1ll * power[comb_2(sz[i]) + comb_2(n - sz[i])] * sum % mod);
	}
	cout << ans;
	return 0;
}
```

---


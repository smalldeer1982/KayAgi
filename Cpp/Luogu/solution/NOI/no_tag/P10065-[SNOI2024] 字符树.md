# [SNOI2024] 字符树

## 题目描述

给你一个 $n$ 个点的有根树，根为 $1$。每条边上有一个字符 $c = \{0, 1\}$。$S_u$ 表示从根到 $u$ 的路径上每条边的字符依次写下来组成的字符串。保证每个节点向儿子的边上的字符互不相同。

对每个点 $u$，有一个价值 $\mathit{val}_u$ 和一个限制 $a_u$。对每个点 $u$，如果点 $v$ 满足 $S_u$ 是 $S_v$ 的后缀。那么我们认为 $v$ 是的 $u$ 扩展点。

Alice 手里有一个字符串 $S$，初始令 $S = S_u$，现在他可以删掉若干末尾的字符，使得 $S$ 变成 $S'$。并将 $S'$ 告诉给 Bob。

Bob 获得了一个字符串 $S'$，他需要在 $S'$ 之后加入若干字符，并获得 $S''$。对于某个 $u$ 的扩展点 $v$，满足 $S'' = S_v$，并且 $\lvert S' \rvert \ge a_v$，那么 Bob 就获得了 $\mathit{val}_v$ 的收益，当然 Bob 只能进行一次这样的操作，所以他会选择符合条件的 $v$ 里，$\mathit{val}_v$ 最大的那个。如果没有符合条件的 $v$，Bob 只能获得 $0$ 的收益。

现在 Alice 想知道，对于删除 $0 \sim \lvert S \rvert$ 个字符，总计 $\lvert S \rvert + 1$ 种删除方式里 Bob 能获得权值之和是多少？

对于每个 $u$，你都需要回答 Alice 的询问。

形式化地说：

我们需要对每个点 $u$ 求出 $\mathit{ans}_u = \sum\limits_{0 \le i \le \lvert S_u \rvert} \max\limits_{i \ge a_v \land S_u = S_v[\lvert S_v \rvert - \lvert S_u \rvert + 1, \lvert S_v \rvert] \land S_u[1, i] = S_v[1, i]} \mathit{val}_v$。

特殊的，如果对于某个 $u$，不存在任何 $v$ 满足条件，那么 $\max = 0$。

其中 $S[l, r]$ 表示字符串 $S$ 的第 $l$ 到第 $r$ 个字符组成的字符串。特殊的，$S[x + 1, x]$ 表示空串。$\lvert S \rvert$ 表示字符串 $S$ 的长度，$\land$ 表示且。

## 说明/提示

**【样例 \#1 解释】**

以下表格表示当 $u, i$ 固定时，式子中 $\mathit{val}_v$ 的最大值。

| | $u = 1$ | $u = 2$ | $u = 3$ | $u = 4$ | $u = 5$ |
|:-:|:-:|:-:|:-:|:-:|:-:|
| $i = 0$ | $3$ | $0$ | $3$ | $0$ | $0$ |
| $i = 1$ | - | $4$ | $3$ | $4$ | $0$ |
| $i = 2$ | - | - | - | $4$ | $5$ |

---

**【样例 \#2】**

见附件中 `tree/tree2.in` 与 `tree/tree2.ans`。

这个样例满足测试点 $3 \sim 5$ 的条件限制。

---

**【样例 \#3】**

见附件中 `tree/tree3.in` 与 `tree/tree3.ans`。

这个样例满足测试点 $9 \sim 10$ 的条件限制。

---

**【样例 \#4】**

见附件中 `tree/tree4.in` 与 `tree/tree4.ans`。

这个样例满足测试点 $11 \sim 12$ 的条件限制。

---

**【数据范围】**

对于所有数据保证 $1 \le T \le 5$，$1 \le n \le 5 \times {10}^5$，$1 \le \mathit{val}_i \le {10}^9$，$1 \le \mathit{fa}_i < i$，$c_i = \{0, 1\}$，$0 \le a_i \le n$。

具体如下：

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $100$ | 无 |
| $3 \sim 5$ | $2 \times {10}^3$ | 无 |
| $6 \sim 8$ | ${10}^4$ | 无 |
| $9 \sim 10$ | ${10}^5$ | A |
| $11 \sim 12$ | ${10}^5$ | B |
| $13 \sim 16$ | ${10}^5$ | 无 |
| $17 \sim 20$ | $5 \times {10}^5$ | 无 |

特殊性质 A：$c_i = 0$。  
特殊性质 B：$\mathit{fa}_i = \lfloor \frac{i}{2} \rfloor$。

## 样例 #1

### 输入

```
1
5
1 0
1 1
2 0
2 1
1 2 3 4 5
0 1 0 1 2
```

### 输出

```
3 4 6 8 5
```

# 题解

## 作者：Rainbow_qwq (赞：8)

考虑建出 ACAM 的 fail 树。（下面注意 fail 树和 trie 树的区别）

则问题转化为：

每个点 $i$ 有一个操作，操作是对 trie 树上一段自己到祖先的路径对 $val_i$ 取 $\max$。

对于每个点，求出：在进行了自己 fail 树子树内的所有取 $\max$ 操作后，在 trie 树上每个祖先的权值之和。

使用树剖 + 线段树合并，这里的线段树使用 seg beats。这样做时间、空间是 $O(n\log^2 n)$ 的，由于毒瘤的 5e5 7s 5 组数据、256 MB 空间，肯定过不掉。

而 seg beats 的复杂度是均摊的，不太方便用一些带撤销的算法。

但这里 dsu on tree 复杂度是对的 $O(n\log^2 n)$，因为线段树上初始势能是 $0$，而 dsu on tree 是对于每条重链从下往上扫描线。（所以如果初始给每个点一个权值就卡掉了）

考虑全局平衡二叉树，其实可以看作是重量平衡、非 leafy 的线段树。

类似线段树合并，全局平衡二叉树也是可以合并的，于是用全局平衡二叉树代替树剖 + 线段树，全局平衡二叉树也使用 seg beats 维护信息。这里的 trie 只有 $01$，所以每个点最多有 $1$ 个虚儿子，多维护一个虚儿子就行。

时间复杂度是 $O(n\log n)$，空间复杂度 $O(n\log n)$。

但是单 $\log$ 空间还是过不去，但是可以使用 [$O(n)$ 空间线段树合并](https://www.luogu.com.cn/blog/DPair2005/post-on-kong-jian-xian-duan-shu-ge-bing-post)，每次先遍历最重的儿子，在合并过程中空间回收，可以证明空间复杂度是 $O(n)$。

> 题外话：

这个题说明了一些“分治结构”是可以做合并的，例如 [CTSC2018]暴力写挂 的边分树合并，以及 [ZJOI2019] 语言也可以用这种方法。

扩展全局平衡二叉树合并的想法，就可以做静态 top tree 合并（可以把这题扩展到任意字符集的 trie），也就是说可 rake compress 的信息都可以这样解决.

---

## 作者：gxy001 (赞：7)

建出 fail 树，称原字典树为 $T1$，fail 树为 $T2$，则所求为，对于每个点 $u$：
$$
\sum\limits_{x\in path_{T1}(rt,u)}\max\limits_{dep_{T1}(x)\ge a_v\land v\in subtree_{T2}(u)\land v\in subtree_{T1}(x)}val_v
$$
注意到 $dep_{T1}(x)\ge a_v\land v\in subtree_{T1}(x)$ 等价于 $x\in path_{T1}(p_v,v)$（$p_v$ 为 $v$ 的深度为 $a_v$ 的祖先）。

因此，所求可转化为：
$$
\sum\limits_{x\in path_{T1}(rt,u)}\max\limits_{x\in path_{T1}(p_v,v)\land v\in subtree_{T2}(u)}val_v
$$
我们使用数据结构维护 $T1$，对 $subtree_{T2}(u)$ 内的每个点 $v$，对链 $path_{T1}(p_v,v)$ 上每个点与 $val_v$ 取 $\max$，然后再求和 $path_{T1}(rt,u)$，即为答案。

链取 $max$，链和，可以使用静态 top tree beats 完成。而我们要对 $u$ 子树内的每个点 $v$ 都执行一个只和 $v$ 有关的修改，不难想到可以使用静态 top tree 合并来维护。

另外，本题为二叉树，这使得每个点最多只有一个虚儿子，利用这点可以使维护更简单。本题的时空限制都较紧，务必注意实现的常数。

时间复杂度为 $O(n\log n)$。

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#define BUFSIZE 10000000
struct read{
	char buf[BUFSIZE],*p1,*p2,c;
	read():p1(buf),p2(buf){}
	char gc(void){
		return p1==p2&&(p2=buf+fread(p1=buf,1,BUFSIZE,stdin),p1==p2)?EOF:*p1++;
	}
	read& operator >>(int& x){
		for(c=gc(),x=0;c<'0'||c>'9';c=gc());
		for(;c>='0'&&c<='9';c=gc())x=x*10+(c-'0');
		return *this;
	}
}cin;
struct write{
	char buf[BUFSIZE],*p1,*p2;
	write():p1(buf),p2(buf+BUFSIZE){}
	~write(){fwrite(buf,1,p1-buf,stdout);}
	void pc(char c){p1==p2&&(fwrite(buf,1,p1-buf,stdout),p1=buf),*p1++=c;}
	write& operator <<(long long x){
		static int stk[30],tp;
		do stk[tp++]='0'+x%10,x/=10; while(x);
		while(tp) pc(stk[--tp]);
		return *this;
	}
	write& operator <<(char c){return pc(c),*this;}
}cout;
int n,s[500010][2],fail[500010];
int val[500010],a[500010],p[500010];
namespace TT{
	int rt,cnt,sz[1000010],csz[1000010],A[1000010],B[1000010],ls[500010],rs[500010],tp[500010];
	int s[500010],fa[500010],son[500010];
	int newnode(int x){
		int u=x+n;
		csz[u]=sz[u]=1,A[u]=B[u]=x;
		return u;
	}
	int bd(int x,int y,int p){
		int u=++cnt;
		ls[u]=x,rs[u]=y,sz[u]=sz[x]+sz[y],tp[u]=p;
		if(p==0) csz[u]=csz[x]+csz[y],A[u]=A[x],B[u]=B[y];
		else csz[u]=csz[x],A[u]=A[x],B[u]=B[x];
		return u;
	}
	int c[500010],cs[500010],ccnt;
	int cbuild(int l,int r,int p){
		if(l==r) return c[l];
		int u=std::lower_bound(cs+l,cs+r,cs[l-1]+(cs[r]-cs[l-1])/2)-cs;
		if(u==r) return bd(cbuild(l,r-1,p),c[r],p);
		else return bd(cbuild(l,u,p),cbuild(u+1,r,p),p);
	}
	int build(int x){
		int u=x;
		static int tmp[500010];
		while(u){
			for(auto w: ::s[u])if(w&&w!=son[u]) tmp[w]=build(w);
			ccnt=0,c[++ccnt]=newnode(u),cs[ccnt]=1;
			for(auto w: ::s[u])if(w&&w!=son[u]) c[++ccnt]=tmp[w],cs[ccnt]=cs[ccnt-1]+sz[tmp[w]];
			tmp[u]=cbuild(1,ccnt,1),u=son[u];
		}
		u=x,ccnt=0;
		while(u) c[++ccnt]=tmp[u],cs[ccnt]=cs[ccnt-1]+sz[tmp[u]],u=son[u];
		return cbuild(1,ccnt,0);
	}
	int R[1000010],ct;
	void ini(int x){
		if(x>n) return A[x]=B[x]=R[x]=++ct,void();
		ini(ls[x]),ini(rs[x]);
		A[x]=A[A[x]+n],B[x]=B[B[x]+n];
		R[x]=ct;
	}
	void dfs(int x){
		static int pt,f[500010];
		f[pt++]=x,s[x]=1,son[x]=0;
		if(a[x]>=pt) p[x]=0;
		else p[x]=f[a[x]];
		for(int u: ::s[x]) if(u) fa[u]=x,dfs(u),s[x]+=s[u],son[x]=(s[son[x]]>s[u]?son[x]:u);
		--pt;
	}
	void init(){
		cnt=0;
		dfs(1);
		rt=build(1);
		ini(rt);
	}
}
std::vector<int> vec[500010];
int sz[500010];
void dfs(int x){
	sz[x]=1;
	for(auto u:vec[x]) dfs(u),sz[x]+=sz[u];
}
long long ans[500010];
#define MAXN 2100010
int cct,ls[MAXN],rs[MAXN],mn[MAXN],lmn[MAXN],cnt[MAXN],tag[MAXN];
long long sum[MAXN],stk[MAXN],tp;
inline int newnode(int pos){
	using TT::csz;
	int u=tp?stk[--tp]:++cct;
	ls[u]=rs[u]=0,tag[u]=sum[u]=mn[u]=0,cnt[u]=csz[pos],lmn[u]=2e9;
	return u;
}
inline void addtag(int x,int v){
	sum[x]+=1ll*(v-mn[x])*cnt[x];
	mn[x]=tag[x]=v;
}
inline void pushdown(int x,int pos){
	if(!tag[x]) return;
	if(!ls[x]) ls[x]=newnode(TT::ls[pos]);
	if(TT::tp[pos]==0){
		if(!rs[x]) rs[x]=newnode(TT::rs[pos]);
		if(mn[ls[x]]==mn[rs[x]]) addtag(ls[x],tag[x]),addtag(rs[x],tag[x]);
		else if(mn[ls[x]]<mn[rs[x]]) addtag(ls[x],tag[x]);
		else addtag(rs[x],tag[x]);
	}else addtag(ls[x],tag[x]);
	tag[x]=0;
}
inline void pushup(int x,int pos){
	using TT::csz;
	if(TT::tp[pos]==0){
		if(!ls[x]&&!rs[x]) sum[x]=mn[x]=0,cnt[x]=csz[pos],lmn[x]=2e9;
		else if(!ls[x]) sum[x]=sum[rs[x]],mn[x]=0,lmn[x]=(mn[rs[x]]==0?lmn[rs[x]]:mn[rs[x]]),cnt[x]=csz[TT::ls[pos]]+(mn[rs[x]]==0?cnt[rs[x]]:0);
		else if(!rs[x]) sum[x]=sum[ls[x]],mn[x]=0,lmn[x]=(mn[ls[x]]==0?lmn[ls[x]]:mn[ls[x]]),cnt[x]=csz[TT::rs[pos]]+(mn[ls[x]]==0?cnt[ls[x]]:0);
		else{
			if(mn[ls[x]]==mn[rs[x]]) sum[x]=sum[ls[x]]+sum[rs[x]],mn[x]=mn[ls[x]],lmn[x]=std::min(lmn[ls[x]],lmn[rs[x]]),cnt[x]=cnt[ls[x]]+cnt[rs[x]];
			else if(mn[ls[x]]<mn[rs[x]]) sum[x]=sum[ls[x]]+sum[rs[x]],mn[x]=mn[ls[x]],lmn[x]=std::min(lmn[ls[x]],mn[rs[x]]),cnt[x]=cnt[ls[x]];
			else sum[x]=sum[ls[x]]+sum[rs[x]],mn[x]=mn[rs[x]],lmn[x]=std::min(mn[ls[x]],lmn[rs[x]]),cnt[x]=cnt[rs[x]];
		}
	}else
		if(!ls[x]) sum[x]=mn[x]=0,cnt[x]=csz[pos],lmn[x]=2e9;
		else sum[x]=sum[ls[x]],mn[x]=mn[ls[x]],cnt[x]=cnt[ls[x]],lmn[x]=lmn[ls[x]];
}
inline void beats(int &rt,int v,int pos){
	if(!rt) rt=newnode(pos);
	if(v<=mn[rt]) return;
	if(v<lmn[rt]) return addtag(rt,v);
	tag[rt]=0;
	beats(ls[rt],v,TT::ls[pos]),beats(rs[rt],v,TT::rs[pos]);
	pushup(rt,pos);
}
inline void lupdate(int b,int v,int &rt,int pos=TT::rt){
	using TT::B,TT::R;
	if(!rt) rt=newnode(pos);
	if(B[pos]==b) return beats(rt,v,pos);
	pushdown(rt,pos);
	if(b<=R[TT::ls[pos]]) lupdate(b,v,ls[rt],TT::ls[pos]);
	else beats(ls[rt],v,TT::ls[pos]),lupdate(b,v,rs[rt],TT::rs[pos]);
	pushup(rt,pos);
}
inline void rupdate(int a,int v,int &rt,int pos=TT::rt){
	using TT::A,TT::R;
	if(!rt) rt=newnode(pos);
	if(A[pos]==a) return beats(rt,v,pos);
	pushdown(rt,pos);
	if(a>R[TT::ls[pos]]) rupdate(a,v,rs[rt],TT::rs[pos]);
	else rupdate(a,v,ls[rt],TT::ls[pos]),beats(rs[rt],v,TT::rs[pos]);
	pushup(rt,pos);
}
inline void update(int a,int b,int v,int &rt,int pos=TT::rt){
	using TT::A,TT::B,TT::R;
	if(!rt) rt=newnode(pos);
	if(A[pos]==a&&B[pos]==b) return beats(rt,v,pos);
	pushdown(rt,pos);
	if(b<=R[TT::ls[pos]]) update(a,b,v,ls[rt],TT::ls[pos]);
	else if(a>R[TT::ls[pos]]) update(a,b,v,rs[rt],TT::rs[pos]);
	else rupdate(a,v,ls[rt],TT::ls[pos]),lupdate(b,v,rs[rt],TT::rs[pos]);
	pushup(rt,pos);
}
inline long long query(int b,int rt,int pos=TT::rt){
	using TT::B,TT::R;
	if(!rt) return 0;
	if(B[pos]==b)return sum[rt];
	pushdown(rt,pos);
	if(b<=R[TT::ls[pos]]) return query(b,ls[rt],TT::ls[pos]);
	else return sum[ls[rt]]+query(b,rs[rt],TT::rs[pos]);
}
void merge(int &x,int y,int pos=TT::rt){
	using TT::A,TT::B;
	if(!x||!y) return x|=y,void();
	if(pos>n) return sum[x]=mn[x]=std::max(mn[x],mn[y]),stk[tp++]=y,void();
	int u=std::max(tag[x],tag[y]);
	tag[x]=0;
	merge(ls[x],ls[y],TT::ls[pos]);
	merge(rs[x],rs[y],TT::rs[pos]);
	pushup(x,pos);
	if(u) beats(x,u,pos);
	stk[tp++]=y;
}
int solve(int x){
	int rt=0;
	std::sort(vec[x].begin(),vec[x].end(),[&](int x,int y){return sz[x]>sz[y];});
	for(auto u:vec[x]) merge(rt,solve(u));
	if(p[x]==1) lupdate(TT::A[x+n],val[x],rt);
	else if(p[x]) update(TT::A[p[x]+n],TT::A[x+n],val[x],rt);
	ans[x]=query(TT::A[x+n],rt);
	return rt;
}
#include<chrono>
using namespace std::chrono_literals;
void solve(){
	auto u=std::chrono::steady_clock().now();
	cin>>n;
	for(int i=1;i<=n;i++) s[i][0]=s[i][1]=fail[i]=0,vec[i].clear(),vec[i].shrink_to_fit();
	for(int i=2,x,v;i<=n;i++) cin>>x>>v,s[x][v]=i;
	for(int i=1;i<=n;i++) cin>>val[i];
	for(int i=1;i<=n;i++) cin>>a[i];
	TT::init();
	static int que[500010];
	int *hd=que,*tl=que;
	for(int i=0;i<2;i++) if(s[1][i]) *tl++=s[1][i],fail[s[1][i]]=1;else s[1][i]=1;
	while(hd!=tl){
		int p=*hd++;
		for(int i=0;i<2;i++)
			if(s[p][i]) fail[s[p][i]]=s[fail[p]][i],*tl++=s[p][i];
			else s[p][i]=s[fail[p]][i];
	}
	for(int i=2;i<=n;i++) vec[fail[i]].push_back(i);
	dfs(1);
	cct=tp=0,lmn[0]=2e9;
	solve(1);
	for(int i=1;i<=n;i++) cout<<ans[i]<<' ';
	cout<<'\n';
	std::cerr<<cct<<' '<<(std::chrono::steady_clock().now()-u)/1.0s<<'\n';
}
int main(){
	int T;
	cin>>T;	
	while(T--) solve();
	return 0;
}
```



---


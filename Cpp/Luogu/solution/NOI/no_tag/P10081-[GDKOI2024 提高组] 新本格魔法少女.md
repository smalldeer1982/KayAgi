# [GDKOI2024 提高组] 新本格魔法少女

## 题目描述

给定一个长度 $n$ 的整数序列 $a_1,\dots, a_n$；

给定一个由 $m$ 次操作构成的操作序列，操作从 $1$ 开始编号，到 $m$ 结束。操作序列中包含修改操作和求和操作，修改操作给定 $l, r, v$，将 $a_l, a_{l+1}, \dots, a_r$ 修改为 $v$，求和操作给定 $l,r$ ，查询 $\sum \limits_{i=l}^r a_i$。

共 $q$ 次查询，每次查询给出 $L,R$ ，询问将序列 $a$ 初始化为 $0$ 后，依次进行操作序列中的第 $L, L+1, \dots , R$ 次操作，每次求和操作的答案之和。

## 说明/提示

对所有数据，满足 $1 \leq l \leq r \leq n$，$1 \leq v \leq n$，$1 \leq L \leq R \leq m$，$1 \leq n, m, q \leq 5 \times 10^5$。

对 $10\%$ 的数据，$n, m, q \leq 10^2$。

对另外 $20\%$ 的数据，$n, m, q \leq 5 \times 10^3$。

对另外 $10\%$ 的数据，每次操作都是求和操作。

对另外 $20\%$ 的数据，每次查询满足 $L = 1$。

对另外 $20\%$ 的数据，$n, m, q \leq 2 \times 10^5$。

对于其余数据，无特殊限制。

## 样例 #1

### 输入

```
10 5 4
1 9 10 7
1 7 10 9
2 3 10
1 10 10 1
2 5 10
2 5
1 1
3 4
1 3```

### 输出

```
64
0
0
36```

# 题解

## 作者：xhhhh36 (赞：13)

[传送门](https://www.luogu.com.cn/problem/P10081)

不妨考虑一个简单的版本：把区间赋值 $C$ 改为区间加法 $A$。

考虑对操作序列按 $B= \sqrt{n}$ 分块。

假设我们能够对任意 $i,R$ 预处理出 $op[iB,R]$ 的答案。

则询问 $op[L,R]$ 的时候，我们可以将贡献分成三部分：
- $op[L,iB)$ 的 $A$ 对 $op[L,iB)$ 的 $Q$ 的贡献；
- $op[L,iB)$ 的 $A$ 对 $op[iB,R]$ 的 $Q$ 的贡献；
- $op[iB,R]$ 的 $A$ 对 $op[iB,R]$ 的 $Q$ 的贡献；

显然第三部分已经预处理，考虑前两部分。
### 第一部分：$op[L,iB)$ 的 $A$ 对 $op[L,iB)$ 的 $Q$ 的贡献
该部分可以看成是一个后缀 $op[*,iB)$ 的贡献，也可以预处理。

在后缀移动的时候直接对每个操作 $A$ 暴力检验对其后面 $Q$ 的贡献即可。

该部分总复杂度 $O(n \sqrt{n})$。
### 第二部分：$op[L,iB)$ 的 $A$ 对 $op[iB,R]$ 的 $Q$ 的贡献
注意到
- $op[L,iB)$ 的 $A$ 会将 $a[1...n]$ 划分成不超过 $O(B)$ 个连续段。

在从小到大枚举 $R$ 时可以通过差分标记求得 $op[iB,R]$ 对 $O(B)$ 的每个连续段共求和过多少次。

询问的时候可暴力 $O(B)$ 还原差分标记，并 $O(B)$ 枚举 $op[L,iB)$ 的 $A$ 求得贡献。
### 预处理第三部分：$op[iB,R]$ 的 $A$ 对 $op[iB,R]$ 的 $Q$ 的贡献
实际上该部分可以拆成：
- $op[iB,(i+1)B)$ 的 $A$ 对 $op[iB,(i+1)B)$ 的 $Q$ 的贡献；
- $op[(i+1)B,R]$ 的 $A$ 对 $op[(i+1)B,R]$ 的 $Q$ 的贡献；
- $op[iB,(i+1)B)$ 的 $A$ 对 $op[(i+1)B,R]$ 的 $Q$ 的贡献；

第一个与之前讨论的询问没有本质区别；

第二个可直接继承后一块的答案；

对于第三个，可以使用 $O(\sqrt{n})$ 修改，$O(1)$ 查询的值域分块，总复杂度 $O(n \sqrt{n})$。

### 对于零散的部分，也即询问的 $[L,R) \in [iB,(i+1)B)$ 的情况
可以视为
- $op[L,(i+1)B)$ 的 $A$ 对 $op[L,(i+1)B)$ 的 $Q$ 的贡献；
- 减去 $op[R,(i+1)B)$ 的 $A$ 对 $op(R,(i+1)B)$ 的 $Q$ 的贡献；
- 减去 $op[L,R)$ 的 $A$ 对 $op[R,(i+1)B)$ 的 $Q$ 的贡献；

前两部分已经通过后缀贡献预处理得到，对于第三部分：
- 对每个 $op[R,(i+1)B)$ 打差分标记。
- 对 $op[L,R)$ 的 $A$ 暴力枚举贡献即可。

## 回到原题意
考虑操作都是同一个区间的情况，设在时间 $t$ 赋值为 $v$：
- 若该操作为第一次赋值，则视为在时间 $t$ 将值加等于 $v$；
- 若其上一次赋值为 $(t',v')$，则视为在时间 $[t',t]$ 将值减等于 $v'$。

上述操作均可抽象成操作序列轴上的 $(tl,tr,v)$，当且仅当询问 $[L,R]$ 包含 $[tl,tr]$ 的时候，该加法操作才生效。
- 不是同一个区间的情况，可以通过颜色数均摊的方式转化成 $O(m)$ 个等价的相同区间。

转化后与简化版本唯一的不同是区间加法操作 $A$ 是有生效范围限制的，即
- 令 $A=(tl,tr,l,r,v)$，当且仅当询问 $[L,R]$ 包含 $[tl,tr]$ 的时候对 $a[l,r]+=v$

考虑每个部分需要怎么适配。
### 预处理第三部分：$op[iB,R]$ 的 $A$ 对 $op[iB,R]$ 的 $Q$ 的贡献
该部分没有变化，注意 $op[iB,R]$ 的 $A$ 指 $[tl,tr] \in [iB,R]$ 即可。
### 第二部分：$op[L,iB)$ 的 $A$ 对 $op[iB,R]$ 的 $Q$ 的贡献
- $op[iB,R]$ 的差分标记这部分不变。
- 在 $O(B)$ 暴力枚举 $A$ 的时候注意只需要枚举满足 $[tl,tr] \in [L,R]$ 的 $A$。

### 第一部分：$op[L,iB)$ 的 $A$ 对 $op[L,iB)$ 的 $Q$ 的贡献
该部分由于 $R$ 未知，所以每个 $A$ 是否生效未知，不能直接简单预处理每个后缀的答案。

但由于 $R\ge iB$，所有 $Q$ 都是生效的，所以对于每一个 $A=op[j]$ 求得其后所有 $Q\in op(j,iB)$ 的贡献。

然后在 $O(B)$ 暴力枚举 $A$ 检验是否生效即可。
### 零散部分，$op[L,R) \in op[iB,(i+1)B)$ 的情况
由于预处理后缀的方法已经不行了，故考虑另一个方法：
- 容：先假设所有 $A\in op[L,R)$ 都在 $Q \in op[iB,R)$ 前面
- 斥：然后扣除额外多统计的 $Q\in op[iB,j)$ 对 $A=op[j]$ 的贡献

通过容斥之后就转化成了前缀 $Q$ 和前缀 $Q+A$ 的贡献，通过差分标记预处理，每个询问可以预处理 $O(\sqrt n)$ 求得。

综上所述，总复杂度 $O(n\sqrt n)$。

---

## 作者：PrinceX (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P10081)

刚放这题时有一篇题解（是谁已经记不清了），我就是用的他的做法做出的，但是现在被删了。所以我按自己的理解再发一遍。

> 给定$m$个操作，每个操作形如 $1,l,r,x$ 表示将 $i\in[l,r],a_i\gets x$，或者是 $2,l,r$ 表示求 $\sum_{i=l}^ra_i$ 的值。
>
> 现有 $q$ 个询问，每个询问给出 $L,R$，表示求将数列初始置为 $0$ 后依次执行$[L,R]$内的操作，求所有 $2$ 操作的答案和。
>
> $n,m,q$同阶，$\le5e5$，6s。

与官方题解做法不同。
注意区分“查询”和“询问“，查询指2操作。

对操作扫描线，想方设法维护出 $R=i$ 时所有 $L$ 的答案。这样不仅去掉了 $R$ 的限制，而且只需要求屏蔽掉 $<L$ 的操作后的答案，模型简化。

考虑对**序列分块**，分别计算以下贡献：

+ 修改对**散块查询**的贡献
+ 整块修改对**整块查询**的贡献
+ 散块修改对**整块查询**的贡献

对于情况1，枚举每个位置的查询，我们可以轻松维护出每个位置最新覆盖的数（整块标记和散块标记），并将这些操作更新进答案中。

具体地，假设当前位操作的时刻是 $t$，那么如果 $t\ge L$ 那么会对询问造成贡献。注意到这里的 $t$（修改）共有 $O(m\sqrt n)$ 个，而询问只有 $q$ 个，所以使用 $O(1)-O(\sqrt n)$ 分块，这部分贡献就被处理完了。

对于情况2，如果当前整块的值整个相同（即上一次是整块修改），实际上就和单个数是一样的，所以同样套用刚刚的数据结构做即可。

对于情况3，实际上我们求的是**当前查询整块的值不整个相同时所有查询带来的贡献**。注意到部分修改一个块只能是散块修改，并且如果整块修改覆盖了原来的散块修改也要去掉散块修改的贡献。易知这里总的操作数是 $O(m)$（上界 $4m$）。

单独考虑所有的块并枚举每个操作。如果当前操作有对当前块的散块修改或者删除散块修改 的修改，就暴力执行。

考虑这里一个散块修改操作的贡献：设其执行时间为 $t$ ，那么对于 $L\le t$ 的询问会造成贡献。贡献就是**权值** $\times$ **加入时刻到询问时刻中当前块查询的次数** $-$ **删除时刻到当前时刻中当前块查询的次数**。实际上删除和加入本质相同，只是权值互为相反数，之后不再分类讨论。

对于所谓的**加入时刻到询问时刻中当前块查询的次数**，可以转化成**初始时刻到询问时刻的查询次数-初始时刻到加入时刻的查询次数**。

考虑维护两个 $O(\sqrt n)-O(1)$ 分块，分别维护**初始时刻到当前所有权值的贡献和**以及**所有权值乘上当前查询次数的贡献和**。

因此总复杂度是$O(n\sqrt n)$。本题可以轻松通过。做完可以去试试[加强版](https://www.luogu.com.cn/problem/P10148)，时限少了1s，非常卡常。

情况三比较困难，给一下代码：
[link](https://www.luogu.com.cn/paste/80401hyj)

---

## 作者：Others (赞：4)

官方题解讲的什么，为什么一个机房的都没读懂。

## 题意

初始序列全为 $0$，有一个覆盖和求和的操作序列，问从操作序列的 $l$ 执行到 $r$（$1$ 到 $l-1$ 不执行）中求和操作的答案的和是多少，$q$ 次询问。

都是 $5\times10^5$ 的数量级。

## Solution

由于这个题的维数已经不支持直接维护了，而且求和是一个很有拆贡献提示的操作，所以考虑拆贡献。

序列分块，扫描操作序列右端点，散块查询可以暴力维护贡献的 $(time,value)$ 二维信息，这个整散块的覆盖都可以查询到。继承以上方法还可以顺便求了整块覆盖对整块查询的贡献，但这个贡献并不包含整块覆盖后再散块覆盖一次的整块的贡献（就是散块覆盖打散了标记，所以这部分贡献不计了）。

然后逐块处理散块覆盖对整块查询的贡献，可以发现散块覆盖一共 $O(m)$ 个，由于是覆盖，再套上颜色段均摊还是 $O(m)$ 个贡献的加减，查询是 $O(q\sqrt n)$ 个，所以用 $O(\sqrt n)-O(1)$ 的分块。

后半部分的细节（杂，所以单独列举）：

1. 贡献怎么转成答案：对于二元组 $(t,v)$，他加进来的时刻到询问右端点的时刻中间整块被查询了多少次，答案就加上多少倍 $v$。注意加进来的时刻不一定是 $t$，也有可能是 $t$ 时刻的覆盖被撤销的时刻；注意一段时间中被查询了多少次需要被差分成询问右端点前查询了多少次减去加进来前查询了多少次，简单维护一下就行了。

2. 整块覆盖的时候散块覆盖的贡献要撤销。

3. 散块覆盖时如果有标记要先把标记下传了来。

...

Of course，考完发现是 Ynoi 的题，那不得不讲卡常的相关事宜：

1. 我们有 $O(1)-O(\sqrt n)$ 和 $O(\sqrt n)-O(1)$ 的分块，所以卡块长是必不可少的，或者是用 $1024$ 当块长，可以快速计算要贡献的位置。

2. 序列分块的块长开 $3000\pm500$ 大概是最佳的。

3. 扫描线要维护询问右端点为 $r$ 的询问信息，一般情况是用 `vector` 或链式前向星，但是这个题要遍历 $O(q\sqrt n)$ 次，那两个肯定不够格，麻烦点，直接排序，用一个指针去维护（写起来或许甚至简单点？）。

4. 散块覆盖的维护方式很幽默，你可以暴力覆盖，因为总共的散块长度加起来可以接受。（~~当然也可以学我这种笨蛋写链表维护连续段，然后暴力遍历链表看哪些区间会被更新~~）

不想删调试语句，所以不代码了。

---


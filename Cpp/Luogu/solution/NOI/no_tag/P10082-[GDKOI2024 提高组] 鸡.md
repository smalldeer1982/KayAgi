# [GDKOI2024 提高组] 鸡

## 题目描述

对于一个非负整数序列 $a$，定义它对应的独立集序列 $f(a)$：

- 假设将 $a_i$ 改为 $0$，此时选出若干个两两不相邻的数使得它们的和最大，则 $f(a)_i$ 表示和的最大值。

现在给定 $n, m$，求有多少个长度为 $b$ 的非负整数序列 $b$ 满足以下条件：

- 存在至少一个长度为 $n$，值域为 $[0, m]$ 的非负整数序列 $a$ 使得 $f(a) = b$。

答案对给定的质数 $\textit{MOD}$ 取模。

## 说明/提示

**本题使用子任务捆绑测试。**

对于 $100\%$ 的数据，$1 \leq n, m \leq 3 \times 10^3$，$n \geq 2$，$10^9 < \textit{MOD} < 1.01 \times 10^9$，$\textit{MOD}$ 为质数。

- Subtask 1（10%）：$n, m \leq 5$。
- Subtask 2（15%）：$n \leq 300$，$m = 1$。
- Subtask 3（25%）：$n \leq 300$，$m ≤ 5$。
- Subtask 4（20%）：$n, m \leq 50$。
- Subtask 5（15%）：$n, m \leq 300$。
- Subtask 6（15%）：无特殊限制。


## 样例 #1

### 输入

```
3 1 1000000007```

### 输出

```
6```

## 样例 #2

### 输入

```
4 2 1000000007```

### 输出

```
47```

## 样例 #3

### 输入

```
20 24 1000000007```

### 输出

```
901565358```

## 样例 #4

### 输入

```
123 234 1000000009```

### 输出

```
141754844```

## 样例 #5

### 输入

```
1234 2345 1004535809```

### 输出

```
576196526```

# 题解

## 作者：Rainbow_qwq (赞：36)

通过找规律，发现 $f(n,m)$ 满足如下关系式：

$$f(2,m)=(m+1)^2$$

$$f(3,m)=\frac{1}{3}m^3+2m^2+\frac{8}{3}m+1$$

$$f(4,m)=\frac{7}{3}m^3+5m^2+\frac{11}{3}m+1$$

$$f(5,m)=\frac{7}{12}m^4 + \frac{17}{3}m^3+\frac{89}{12} m^2+\frac{13}{3}m+1$$

$$f(6,m)=\frac{25}{6}m^4 + \frac{38}{3}m^3+\frac{71}{6} m^2+\frac{16}{3}m+1$$

$$f(7,m)=\frac{5}{6}m^5 + \frac{37}{3}m^4 + \frac{133}{6}m^3+\frac{47}{3} m^2+6m+1$$

$$f(n,m) = 2f(n-1,m)+2m\cdot f(n-2,m)-(2m+2)f(n-3,m)-(m^2+2m-1)f(n-4,m)+2m\cdot f(n-5,m)+m^2f(n-6,m)$$

据此计算即可。时间复杂度 $O(n)$，可以优化到 $O(\log n)$。

核心代码：

```cpp
int n;
modint m;
modint f[maxn];

signed main()
{
	n=read(),m=read(),initmod();
	f[2]=(m+1)*(m+1);
	f[3]=m*m*m/3+m*m*2+m*8/3+1;
	f[4]=m*m*m*7/3+m*m*5+m*11/3+1;
	f[5]=m*m*m*m*7/12+m*m*m*17/3+m*m*89/12+m*13/3+1;
	f[6]=m*m*m*m*25/6+m*m*m*38/3+m*m*71/6+m*16/3+1;
	f[7]=m*m*m*m*m*5/6+m*m*m*m*37/3+m*m*m*133/6+m*m*47/3+m*6+1;
	For(i,8,n)f[i]=f[i-1]*2+f[i-2]*2*m+f[i-3]*((-m)*2-2)+f[i-4]*((-m)*m-m*2+1)+f[i-5]*m*2+f[i-6]*m*m;
	cout<<f[n].x;
	return 0;
}
```

----

我们不加证明地猜测两个结论：

- 当 $n$ 固定时，答案是一个关于 $m$ 的多项式。
- 当 $m$ 固定时，答案序列 $f_n$ 存在一个较短的递推式。

首先写一个快一点的指数级暴力，比如对每种差分数组算上下界然后加起来，可以跑出 $n\le 13,0\le m\le 3$ 的结果。

据此可以 BM 求出 $1\le m\le 3$ 的所有递推式，发现第二条结论是正确的，而且递推式长度仅为 $6$：

- $m=1$：$(2,2,-4,-2,2,1)$
- $m=2$：$(2,4,-6,-7,4,4)$
- $m=3$：$(2,6,-8,-14,6,9)$

容易~~找规律~~观察出递推式为 $(2,2m,-(2m+2),-((m+1)^2-2),2m,m^2)$。

那现在问题在于固定 $m$ 求出 $f(2\sim 7,m)$ 的值，之后可以使用递推式。

由于第一条结论，可以暴力跑出 $n,m\le 8$ 的答案，然后插值求出 $n=2\sim 7$ 时 $m$ 满足的多项式。

---

## 作者：NaCly_Fish (赞：12)

[题目链接](https://www.luogu.com.cn/problem/P10082)


看到 [Rainbow_qwq](https://www.luogu.com.cn/user/151935) 的题解中提到了两个未证明的结论，设答案为 $f(n,m)$，则有：

- $f(n,m)$ 是关于 $m$ 的 $\Theta(n)$ 次多项式。  

- $f(n,m)$ 是关于 $n$ 的**从 $n=2$ 开始的** $6$ 阶常系数线性递推。

由于我完全不懂这题的组合推导，这里就对着 [DaiRuiChen007 ](https://www.luogu.com.cn/user/539618) 的 [题解代码](https://www.luogu.com.cn/blog/DaiRuiChen007/P10082)（平方复杂度部分）证明一下结论。
****
首先代码中递推得到了数组 $f$ 和 $f_1$，观察到其为 $2$ 阶线性常系数递推。它们对应的生成函数（$F(x)$ 与 $F_1(x)$）都是分母为 $2$ 次的有理分式。

然后计算 $f_1$ 的自卷积得到了数组 $g$ 也就是说 $G(x)=F_1(x)^2$，$G(x)$ 也是有理分式，分母为 $4$ 次多项式。

然后答案可以表示为三部分之和（$S_1+S_2+mS_3$），分别是：

$$S_1=f(n)+\frac{m(m-1)}{2}\sum_{i=1}^nf_1(i-1)f_1(n-i)$$
$$S_2=\sum_{i=1}^{m-1}(i-m)\sum_{l\geq0}[2l+1=n]+2(m-i)f_1(n-2l-3)+(m-i)^2g(n-2l-5)$$
$$S_3=\sum_{l=2}^n \left\lfloor \frac l2\right\rfloor\left([l=n]+2mf_1(n-l-2)+m^2g(n-l-4)\right)$$
首先 $S_1$ 关于 $n$ 显然是常系数线性递推的。由于 $F_1(x)=xF(x)$，其递推阶数为 $4$。又由于 $f_1(i)$ 是关于 $m$ 的 $\Theta(i)$ 次多项式，$S_1$ 也是关于 $m$ 的 $\Theta(n)$ 次多项式。
***
至于 $S_2$，这又是分为了三个部分，分别为：

$$\frac{1-(-1)^n}{2}\left( \sum_{i=1}^{m-1}(i-m)\right)-\left(\sum_{i=1}^{m-1}2(i-m)^2\right)[x^{n-3}]\frac{F_1(x)}{1-x^2}+\left( \sum_{i=1}^{m-1}(i-m)^3\right)[x^{n-5}]\frac{G(x)}{1-x^2}$$
这就很明显了，每个和式中都是一个关于 $m$ 的 $\Theta(1)$ 次多项式，提取的系数其实也是一段部分和，各部分也就都是关于 $m$ 的 $\mathcal O(n)$ 次多项式。再来看递推性质，和式中与 $n$ 无关可以不管，提取系数的部分很显然，是在对一个有理分式提取系数。其中 $G(x)$ 的分母为 $4$ 次，除以一个 $1-x^2$ 自然就是 $6$ 阶递推了。
***

最后是 $S_3$，尝试把 $\lfloor l/2\rfloor$ 用生成函数表示：
$$S_3=\sum_{l=0}^n\left( [x^l]\frac{x^2}{(1-x)(1-x^2)}\right)\left( [l=n]+2mf_1(n-l-2)+m^2g(n-l-4)\right)$$
这个同样可以再分为三个部分分析，第一部分很显然就不说了。剩下两部分都很容易写成 $\dfrac{x^2}{(1-x)(1-x^2)}$ 和 $F_1(x),G(x)$ 的卷积分别，提取 $[x^{n-2}]$ 和 $[x^{n-4}]$ 系数的结果。这样和 $S_2$ 就能以相同的方法分析得出结论。

不过这里有个疑点，$G(x)$ 那一项卷积出来的分母是 $7$ 次的，并不是 $6$ 次。大概可以这样解释：因为 Rainbow\_qwq 的结论是从 $n=2$ 开始的，按照其给出的递推式倒推回 $n=1$ 的情况**是错误的**。也就是说，想要补上 $n=1$ 这一项的特殊情况，递推式就要长一点。

现在整体结构已经分析完毕，我们有理由确信本文开头所给出的结论了。

---

## 作者：DaiRuiChen007 (赞：12)

# P10082 题解

[Problem Link](https://www.luogu.com.cn/problem/P10082)

感谢 @by_chance 哥哥的指导。

**题目大意**

> 对于一个数列 $a_1\sim a_n$，定义 $b_i$ 表示 $a_i=0$ 时在原序列选取若干不相邻位置的最大权值和。
>
> 求多少组 $\{b_i\}$ 可能被某组值域 $[0,m]$ 的 $\{a_i\}$ 生成。
>
> 数据范围：$n,m\le 3000$。

**思路分析**

考虑记全局答案为 $B,c_i=B-b_i$，那么 $c_i>0$ 的就是所有最大独立集的公共部分。

那么对于 $\{c_i\}$ 的限制就是 $c_i>0$ 的位置不能相邻，构造时直接取 $c_i=a_i$ 即可。

接下来我们尝试对于每组合法的 $\{c_i\}$，算出 $B$ 的取值范围，可以证明这样的 $B$ 总是区间。

显然 $B\ge \sum c_i$，构造也是容易的，那么我们只要计算 $B$ 的上界会增加多少即可。

先考虑 $c_i=0$ 的元素的贡献，不妨设 $[l,r]$ 为 $\{c_i\}$ 中一段极长的 $0$ 连续段。

若 $l>1$，那么 $c_{l-1}>0$，则 $a_{l-1}$ 必然是最大独立集的必经点，那么 $a_l$ 就必定不在最大独立集中，同理，若 $r<n$ 则 $a_r$ 一定无贡献。

考虑有贡献的区间 $[l',r']$，很自然的想法是令所有 $a_i\gets m$，但当 $2\nmid r'-l'+1$ 时，删除奇数位置上的 $a_i$ 会使答案 $-m$，因此我们必须少取一个 $a_i$。

那么这样的一个区间对 $B$ 的贡献就是 $m\times \left\lfloor\dfrac{r'-l'+1}2\right\rfloor$。

然后考虑 $c_i>0$ 的贡献，同样先把 $m-c_i$ 加入答案中。

手玩样例可以发现，无法构造的情况形如 $p,0,x,0,x,0,\dots,0,x,0,q$，其中 $p,q>x$。

第一个和最后一个 $x$ 的位置为 $l,r$，若 $l=1$ 则 $a[l-2,l-1]$ 不是必要的，同理 $r=n$ 时 $a[r+1,r+2]$ 不是必要的。

观察可以发现，设 $[l,r]$ 中有 $len$ 个 $x$，那么我们能构造对 $B$ 贡献为 $(len-1)m+x$ 的一组解。

取 $a_r=x$，其他 $c_i=x$ 的位置取 $a_i=m$，且 $a_{r+1}=0$，其他 $c_i=0$ 的位置取 $a_i=m-x$。

然后证明必要性，对于 $b_{l}$ 对应的解，$a_{l-2}$ 一定被选，否则 $b_{l-2}\ge b_l,c_{l-2}\le c_l$，与 $p>x$ 矛盾。

因此对于 $b_l$ 对应的解，$a[1,l-2],a[r+2,n]$ 的选取方式与全局最优答案一致，而内部的答案自然不能超过 $(len-1)m+x$。

因此对于所有这样的段，我们会将 $B$ 的取值范围减少 $m-x$。

考虑计算答案：

先求 $c_i>0$ 的贡献，设 $f_i$ 表示长度为 $i$ 的合法 $c$ 序列个数，且 $c_1>0$，那么 $f_0=f_1=1,f_i=f_{i-1}+mf_{i-2}$。

设 $g_i=\sum _{j=0}^i f_{j}\times f_{i-j}$，即 $f\times f$ 的结果。

那么原始的贡献为 $\sum _{i=1}^nf_{i-1}f_{n-i}\sum_{x=1}^{m}(m-x)=g_{n-1}\dfrac{m(m-1)}2$。

然后容斥掉形如 $p,0,x,0,x,0,\dots,0,x,0,q$，枚举 $x,0,x,0,\dots,0,x$ 一段的长度 $len=1,3,5,7,\dots$：

- 若 $len=n$，那么方案数为 $1$。
- 若 $len+2\le n$，那么可以当前缀或后缀，方案数为 $2(m-x)f_{n-len-2}$。
- 若 $len+4\le n$，那么可以当任意子段，方案数为 $(m-x)^2g_{n-len-4}$。

最终答案减去方案数乘以 $(m-x)$。

容易发现对于不同的 $x$，和 $len$ 有关的系数可以预处理。

即求出 $\sum f_{n-len-2}$ 和 $\sum g_{n-len-4}$，然后计算方案的时候就能不用枚举 $len$。

因此这一部分可以 $\mathcal O(n+m)$ 计算答案。

然后考虑 $c_i=0$ 的贡献，枚举有贡献的 $0$ 连续段的长度 $len$：

- 若 $len=n$ 则方案数为 $1$。
- 若 $len+2\le n$ 那么可以当前缀或后缀，方案数为 $2mf_{n-len-2}$。
- 若 $len+4\le n$ 那么可以当任意子段，方案数为 $m^2g_{n-len-4}$。

答案加上方案数乘以 $m\times \left\lfloor \dfrac {len}2\right\rfloor$。

最终答案加上 $f_{n+1}$，表示对于每种方案，$B$ 初始的取值范围都是 $1$。

注意到：$g_n=f_0f_n+f_1f_{n-1}+\sum_{i=2}^n (f_{i-1}+mf_{i-2})f_{n-i}=g_{n-1}+mg_{n-2}+f_n$，因此这部分可以 $\mathcal O(n)$ 递推。

时间复杂度 $\mathcal O(n+m)$。

**代码呈现**

$\mathcal O(n^2+nm)$ 实现：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=3005;
ll f[MAXN],f1[MAXN],g[MAXN]; //f1: limited a[1]=0
signed main() {
	int n,m,MOD;
	scanf("%d%d%d",&n,&m,&MOD);
	f1[0]=f1[1]=f[0]=1,f1[2]=f[1]=m+1;
	for(int i=2;i<=n;++i) f1[i+1]=f[i]=(f[i-1]+f[i-2]*m)%MOD;
	for(int i=0;i<=n;++i) for(int j=0;j<=n-i;++j) {
		g[i+j]=(g[i+j]+f1[i]*f1[j])%MOD;
	}
	ll ans=0;
	//ci>0
	for(int i=1;i<=n;++i) ans=(ans+f1[i-1]*f1[n-i]%MOD*m*(m-1)/2)%MOD;
	for(int x=1;x<m;++x) { //delete p0x0x0x0x0q
		ll cnt=0;
		for(int len=1;len<=n;len+=2) {
			if(len==n) cnt=(cnt+1)%MOD;
			if(len+2<=n) cnt=(cnt+2*(m-x)*f1[n-len-2])%MOD; //left or right
			if(len+4<=n) cnt=(cnt+(m-x)*(m-x)*g[n-len-4])%MOD; //mid 
		}
		ans=(ans+MOD-cnt*(m-x)%MOD)%MOD;
	}
	//ci=0
	for(int len=2;len<=n;++len) {
		ll cnt=0;
		if(len==n) cnt=1;
		else {
			if(len+2<=n) cnt=(cnt+2*m*f1[n-len-2])%MOD; //[000000]0q|....
			if(len+4<=n) cnt=(cnt+m*m*g[n-len-4])%MOD; //...|p0[000000]0q|...
		}
		ans=(ans+m*(len/2)*cnt)%MOD;
	}
	ans=(ans+f[n])%MOD; //init B
	printf("%lld\n",ans);
	return 0;
}
```

$\mathcal O(n+m)$ 实现：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=3005;
ll f[MAXN],g[MAXN];
signed main() {
	int n,m,MOD;
	scanf("%d%d%d",&n,&m,&MOD);
	f[0]=f[1]=1;
	for(int i=2;i<=n+1;++i) f[i]=(f[i-1]+f[i-2]*m)%MOD;
	for(int i=0;i<=2;++i) for(int j=0;j<=n-i;++j) {
		g[i+j]=(g[i+j]+f[i]*f[j])%MOD;
	}
	for(int i=3;i<=n;++i) g[i]=(g[i-1]+m*g[i-2]+f[i])%MOD;
	ll ans=m*(m-1)/2*g[n-1]%MOD,c0=0,c1=0;
	for(int len=1;len<=n;len+=2) {
		if(len+2<=n) c0=(c0+2*f[n-len-2])%MOD;
		if(len+4<=n) c1=(c1+g[n-len-4])%MOD;
	}
	for(int x=1;x<m;++x) {
		ans=(ans+MOD-((m-x)*(m-x)*c1+(m-x)*c0+n%2)%MOD*(m-x)%MOD)%MOD;
	}
	for(int len=2;len<=n;++len) {
		ll cnt=0;
		if(len==n) cnt=1;
		else {
			if(len+2<=n) cnt=(cnt+2*m*f[n-len-2])%MOD;
			if(len+4<=n) cnt=(cnt+m*m*g[n-len-4])%MOD;
		}
		ans=(ans+m*(len/2)*cnt)%MOD;
	}
	ans=(ans+f[n+1])%MOD;
	printf("%lld\n",ans);
	return 0;
}
```

---


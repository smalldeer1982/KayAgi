# [GDKOI2024 提高组] 计算

## 题目描述

定义 $F(x, a, b) = \gcd(x^a - 1, x^b - 1) + 1, x > 0$。

特别的，如果 $a = 0$ 或 $b = 0$，$F(x, a, b) = 0$。

现在给出五个非负整数 $m, a, b, c, d$。

令 $L = F(m, a, b) + 1$，$R = F(m, c, d)$。

问集合 $\{L, L + 1, L + 2, \dots, R - 2, R - 1, R\}$ 有多少个子集和是 $m$ 的倍数。

由于答案可能很大，你只需要输出方案数对 $998244353$ 取模后的结果就可以了。

## 说明/提示

**【样例解释】**

经过计算可知 $L=1$，$R=5$，集合是 $1,2,3,4,5$，满足条件的子集和有以下 $8$ 个：

$\{\}$，$\{5\}$，$\{2, 3\}$，$\{1, 4\}$，$\{1, 2, 3, 4\}$，$\{2, 3, 5\}$，$\{1, 4, 5\}$，$\{1, 2, 3, 4, 5\}$。

**【数据范围】**

| 测试点编号 | $m$ | $L$ | $R$ | $a$ | $b$ | $c$ | $d$ | $T$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $m=2$ | $L=1$ | $R=2$ | $a=0$ | $b=0$ | $c\leq 10$ | $d\leq 10$ | $T\leq 5$ | 无 |
| $2$ | $m\leq 10$ | $L=1$ | $R=m$ | $a=0$ | $b=0$ | $c\leq 10$ | $d\leq 10$ | $T\leq 5$ | 无 |
| $3$ | $m\leq 5$ | $L\leq 10^3$ | $R\leq 10^3$ | $a\leq 10$ | $b\leq 10$ | $c\leq 10$ | $d\leq 10$ | $T\leq 5$ | $1$ |
| $4\sim 6$ | $m\leq 20$ | $L\leq 2\times 10^3$ | $R\leq 2\times 10^3$ | $a\leq 10$ | $b\leq 10$ | $c\leq 10$ | $d\leq 10$ | $T\leq 5$ | 无 |
| $7$ | $m\leq 20$ | $L\leq 10^5$ | $R\leq 10^5$ | $a\leq 10^2$ | $b\leq 10^2$ | $c\leq 10^2$ | $d\leq 10^2$ | $T\leq 5$ | $2$ |
| $8,9$ | $m\leq 80$ | $L\leq 10^9$ | $R\leq 10^9$ | $a\leq 10^2$ | $b\leq 10^2$ | $c\leq 10^2$ | $d\leq 10^2$ | $T\leq 5$ | 无 |
| $10\sim 13$ | $m\leq 2\times 10^3$ | $L\leq 10^{18}$ | $R\leq 10^{18}$ | $a\leq 10^3$ | $b\leq 10^3$ | $c\leq 10^3$ | $d\leq 10^3$ | $T\leq 5$ | 无 |
| $14\sim 17$ | $m\leq 10^5$ | $L\leq 10^{18}$ | $R\leq 10^{18}$ | $a\leq 10^3$ | $b\leq 10^3$ | $c\leq 10^3$ | $d\leq 10^3$ | $T\leq 5$ | 无 |
| $18\sim 20$ | $m\leq 10^7$ | $L\leq 10^{18}$ | $R\leq 10^{18}$ | $a\leq 10^3$ | $b\leq 10^3$ | $c\leq 10^3$ | $d\leq 10^3$ | $T\leq 10^4$ | 无 |

- 特殊性质 1：$R - L + 1 \leq 20$；
- 特殊性质 2：$R - L + 1 \leq 2000$；

对于全部数据，保证 $L < R$，$m > 0$。

## 样例 #1

### 输入

```
3
5 0 0 2 1
4 1 2 2 4
8 3 2 4 6```

### 输出

```
8
1024
527847872```

# 题解

## 作者：Tangninghaha (赞：18)

看不清公式可以放大。

题意简单转化

首先有 $\gcd(x^{a}-1,x^{b}-1)+1=x^{\gcd(a,b)}$。

> 证明：
>
> 因为当 $a\ge b$ 时， $\gcd(a,b)=\gcd(a-b,b)$。
>
> 让我们钦定 $a\ge b$，那么
>
> 考虑 $\gcd(x^{a}-1,x^{b}-1)=\gcd(x^{a}-x^{b},x^{b}-1)=\gcd(x^{b}(x^{a-b}-1),x^{b}-1)$
>
> 由于 $\gcd(x^{b},x^{b}-1)=1$，所以
>
> $\gcd(x^{b}(x^{a-b}-1),x^{b}-1)=\gcd(x^{a-b}-1,x^{b}-1)$
>
> 我们发现指数在更相减损！
>
> 直到更相减损结束的时候，即 $\gcd(x^{\gcd(a,b)}-1,x^{0}-1)$ 时，我们得到原式为 $x^{\gcd(a,b)}-1$。

---

发现 $m\vert L-1$ 且 $m\vert R$，将 $L,R$ 都减去 $L$，原问题相当于 $[1,N]$ 的问题。

这题中有多项式 $f(x)=(1+x)(1+x^{2})(1+x^{3})\cdots (1+x^{k})=c_{0}+c_{1}x+c_{2}x^{2}+\cdots+c_{t}x^{t}$。

我们知道展开这个多项式，就相当于在每一个括号内选取一项相乘。

$(1+x^{i})$，如果选择1，乘积的指数不变，表示子集中没有 $i$。如果选择 $x^{i}$，乘积的指数增加了 $i$，表示子集中有 $i$。那么如果展开后有一项 $c_{i}x^{i}$，其中 $c_{i}$ 是系数，那么 $c_{i}$ 就表示子集和为 $i$ 的方案数。

因为 $x$ 是任意代入的，所以我们希望代入一些具有优秀性质的 $x$ 来简化我们的运算。

---

引理
$$
[m\vert i]=\frac{1}{m}\sum_{k=0}^{m-1}\omega_{m}^{ik}
$$
证明：

考虑等比数列求和：$S=\frac{\omega_{m}^{im}-1}{\omega_{m}^{i}-1}$，分类讨论：

- 当 $\omega_{m}^{i}\not=1$ 时，可以知道 $i$ 不是 $m$ 的倍数，并且 $\omega_{m}^{im}-1$ 为0。
- 当 $\omega_{m}^{i}=1$ 时，可以知道 $i$ 是 $m$ 的倍数，并且由于分母为0，此时不能使用等比数列求和公式，所以特判。此时 $\omega_{m}^{ik}=1$，因为 $i$ 是 $m$ 的倍数。得到 $\sum_{k=0}^{m-1}\omega_{m}^{ik}=m$，所以除以 $m$ 得到1。

---

将 $m$ 次单位根代入得到 $\sum f(\omega_{m}^{i})$，展开，由引理得到只有 $m\vert i$ 时，系数为 $c_{i}$ 的项的和不为0。而下标为 $m$ 的倍数的数相加得到 $m\times c_{k}$。故答案为
$$
\frac{1}{m}\sum f(\omega_{m}^{i})
$$
问题转化为快速计算该式子。

---

当 $m$ 为奇素数的时候：

考虑：根据单位根的定义，我们可以对 $z^{m}-1$ 在复数域内进行因式分解。得到 $z^{m}-1=(z-\omega_{m}^{0})(z-\omega_{m}^{1})\cdots(z-\omega_{m}^{m-1})$，代入 $z=-1$，进一步得到 $2=(1+\omega_{m}^{1})(1+\omega_{m}^{2})\cdots(1+\omega_{m}^{m})$。又因为 $m$ 是素数，所以 $(1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{mi})$ 的指数模 $m$ 组成了一个完全剩余系，其值仍然等于2。

> 当然，如果 $m$ 为偶数的时候，可以得到 $z^{m}=(-1)^{m}=1$，所以该式子等于0。

进一步对其拓展，我们知道 $n$ 是 $m$ 的倍数，那么当 $i>0$ 时， $f(\omega_{m}^{i})=(1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{ni})=2^{\frac{n}{m}}$。当 $i=0$ 时，该式等于 $2^{n}$。

所以答案等于 $\frac{1}{m}(2^{n}+(m-1)2^{\frac{n}{m}})$。

---

拓展到 $m$ 一般的情况，考虑假设$(i,m)=p$，1~m分别乘 i 模 m 得到的剩余系，包含 $\frac{m}{p}$ 个数，是由 $p$ 个  模 $\frac{m}{p}$ 的完全剩余系中的数字乘 $p$ 得到的。

那么可以将 $(1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{mi})$ 按照模 $m$ 得到的值可以表示为 $[(1+\omega_{m}^{p})(1+\omega_{m}^{2p})\cdots(1+\omega_{m}^{m})]^{p}$。

所以 $f(\omega_{m}^{i})=[(1+\omega_{m}^{p})(1+\omega_{m}^{2p})\cdots(1+\omega_{m}^{m})]^{p\times \frac{n}{m}}$。

注意到单位根的性质 $\omega_{m}^{p}=\omega_{\frac{m}{p}}^{1}$，所以其实上式中括号内的部分就是 $(1+\omega_{\frac{m}{p}}^{1})(1+\omega_{\frac{m}{p}}^{2})\cdots(1+\omega_{\frac{m}{p}}^{\frac{m}{p}})$。

当 $\frac{m}{p}$ 为偶数的时候，上面的式子为0。当 $\frac{m}{p}$ 为奇数的时候，上面的式子为2。所以 $f(\omega_{m}^{i})=2^{p\times\frac{n}{m}}[2\nmid \frac{m}{p}]$。

所以答案等于 $\frac{1}{m}(2^{n}+\sum_{i=1}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])$。

我们之前特判了 $i=0$ 的情况，其实 $i=0$ 和 $i=m$ 是一样的，当 $i=m$ 时，$p=m$，$2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])=2^{n}$，所以式子可以简化为：
$$
\frac{1}{m}(\sum_{i=0}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])
$$
直接计算可以获得 85 分。

---

进一步优化，观察到如果 $2\vert \frac{m}{(i,m)}$ 时，$i$ 对答案没有贡献。所以假设 $m=2^{k}\times u$，其中 $u$ 是一个奇数，那么 $i$ 要求满足 $i=2^{k}\times x$。

所以有：
$$
\begin{aligned}
\frac{1}{m}(\sum_{i=0}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])&=\frac{1}{m}(\sum_{i=1}^{u}2^{\frac{n}{2^{k}\times u}\times \gcd(2^{k}\times u,2^{k}\times i)})\\
&=\frac{1}{m}(\sum_{i=1}^{u}2^{\frac{n}{u}\times \gcd(u,i)})
\end{aligned}
$$
考虑到 $\gcd(u,i)$ 为 $u$ 的约数，我们直接枚举 $\gcd(u,i)$，也就是：
$$
\frac{1}{m}(\sum_{d\vert u}2^{\frac{n}{u}\times d}\times \varphi(\frac{u}{d}))
$$
因为 $\gcd(u,i)=d$ 要求 $\gcd(\frac{u}{d},\frac{i}{d})=1$，所以有多少个 $\frac{i}{d}$ 满足 $\gcd(\frac{u}{d},\frac{i}{d})=1$ 就是与 $\frac{u}{d}$ 互质的数字的个数。

由于 $u$ 的特殊性（没有质因子2），所以其约数个数不会太多，1e7 之内大约只有 200 个，可以通过本题。

代码：

```c++
#include<cstdio>
#include<cmath>
using namespace std;
using ll=long long;
const int mod=998244353;
const int M=1e7+5;
ll qpow(ll a,ll b){
  ll res=1;
  while(b){
    if(b&1)res=res*a%mod;
    a=a*a%mod;
    b>>=1;
  }
  return res;
}
ll qpowNoMod(ll a,ll b){
  ll res=1;
  while(b){
    if(b&1)res=res*a;
    a=a*a;
    b>>=1;
  }
  return res;
}
int phi[M],pri[M],tot;
bool vis[M];
void init(){
  phi[1]=1;
  for(int i=2;i<=(int)1e7;++i){
    if(!vis[i])phi[i]=i-1,pri[++tot]=i;
    for(int j=1;j<=tot;++j){
      if(pri[j]*i>1e7)break;
      vis[pri[j]*i]=true;
      if(i%pri[j]==0){phi[pri[j]*i]=phi[i]*pri[j];break;}
      phi[pri[j]*i]=phi[i]*(pri[j]-1);
    }
  }
}
int gcd(int x,int y){
  return y==0?x:gcd(y,x%y);
}
ll F(int m,int x,int y){
  if(x==0||y==0)return 0;
  return qpowNoMod(m,gcd(x,y));
}
int main(){
  init();
  int t;
  scanf("%d",&t);
  while(t--){
    int m,a,b,c,d;
    scanf("%d%d%d%d%d",&m,&a,&b,&c,&d);
    ll l=F(m,a,b)+1,r=F(m,c,d);
    ll n=r-l+1;
    int u=m;
    while(!(u&1))u>>=1;
    ll ans=0;
    for(int i=1,_i=sqrt(u+0.5);i<=_i;++i){
      if(u%i!=0)continue;
      ans+=qpow(2,n/u*i)*phi[u/i]%mod;
      if(i*i!=u){
        int j=u/i;
        ans+=qpow(2,n/u*j)*phi[u/j]%mod;
        ans%=mod;
      }
    }
    ans*=qpow(m,mod-2);
    ans%=mod;
    printf("%lld\n",ans);
  }
}

```

---

## 作者：OptimisticForever (赞：7)


首先 $\gcd(x^a-1,x^b-1)+1=x^{\gcd(a,b)}$。

所以我们能算出 $L,R$，其中 $L=m^x+1,R=m^y$。

于是现在题目转化 $[1,n=R-L+1]$ 问那个子集和问题。

设 $f(x)=\prod_{i=1}^n (1+x^i)$。

那么我们需要求 $\sum _{i=0}^{n}[m|i]f(x)[x^i]$。

考虑单位根反演：
$$
\begin{aligned}
\sum _{i=0}^{n}[m|i]f(x)[x^i]&=\sum _{i=0}^n\frac 1 m \sum _{j=0}^{m-1}\omega_{m}^{ij}f(x)[x^i]\\
&=\frac 1 m \sum _{j=0}^{m-1}\sum _{i=0}^n \omega_{m}^{ij}f(x)[x^i]\\
&=\frac 1 m \sum _{j=0}^{m-1}\sum _{i=0}^n (\omega_{m}^{j})^if(x)[x^i]\\
&=\frac 1 m \sum _{j=0}^{m-1}f(\omega_{m}^j)\\
\end{aligned}
$$
考虑如何计算 $f(w_m^a)$。

设 $d=\gcd(a,m)$。

我们有结论：

$a,2a,3a,\cdots,ma$ 一共有 $d$ 个模 $\frac m d$ 的剩余系。

于是，$f(w_m^a)=(\prod _{k=0}^{{\frac m d}-1}(\omega_{m}^{kd }+1))^{\frac{n}{\frac m d}}$。

其实就是 $\frac m d$ 的单位根。

根据单位根性质 $(\omega _m^{kd})^{\frac m d}=1$，所以对于方程 $z^{\frac m d}=1$，其能被因式分解成 $w_{m}^{kd}-1$ 的乘积。

令 $z=-1$，推式子，得到答案。
$$
\frac 1 m\sum _{i=1}^m 2^{\frac n m \gcd(i,m)}[\gcd(i,m)\bmod 2=1]
$$
令 $m'=\frac m {2^k},m'\bmod 2\not= 0$。

则答案变成
$$
\frac 1 m\sum _{i=1}^{m'} 2^{\frac n {m'} \gcd(i,{m'})}
$$
枚举 $\gcd$。
$$
\frac 1 m \sum _{i|m'}2^{\frac n {m'}i}\varphi(\frac {m'}i)
$$
直接枚举约数即可通过此题。

复杂度是 $O(T(\sqrt m + d(m)\log n))$，跑的飞快。

---

## 作者：0000pnc (赞：7)

场切此题！1111 竟然没挂分。

----

题意：给定非负整数 $m,a,b,c,d$，求 $[\gcd(m^{a}-1,m^{b}-1) + 2,\gcd(m^{c}-1,m^{d}-1)+1]$ 中的整数有多少个子集的和为 $m$ 的倍数。约定 $\gcd(0,n)=-1$。

多测，$T \le 10^{4}$，$m \le 10^{7}$，$a,b,c,d \le 10^{3}$。

----

首先考虑求出 $\gcd(m^{a}-1,m^{b}-1)$。

因式分解：$m^{a}-1=(m-1)(m^{a-1}+m^{a-2}+\cdots+m+1)$。于是可以约掉一个 $m-1$，问题变成求 $\gcd(m^{a-1}+m^{a-2}+\cdots+m+1,m^{b-1}+m^{b-2}+\cdots+m+1)$。

直接辗转相除，得原式 $=(m-1)(m^{\gcd(a,b)-1}+m^{\gcd(a,b)-2}+\cdots+m+1)$。这部分可以直接 $O(a)$ 处理出来（默认 $a,b,c,d$ 同阶）。

注意到这个东西是模 $m$ 余 $-1$ 的，原因显然。所以接下来我们进入到第二部分：求 $[L,R]$ 间的整数有多少个子集的和为 $m$ 的倍数，且保证 $R-L+1$ 为 $m$ 的倍数。

不妨把 $[L,R]$ 平移至 $[1,R-L+1]$。然后考虑子集和为 $i$ 的方案数 $a_{i}$ 的生成函数 $f(x)=(x+1)(x^2+1)(x^{3}+1)\cdots(x^{R-L+1}+1)=x^{0}a_{0}+x^{1}a_{1}+x^{2}a_{2}+\cdots$。

由于我们只需要 $i$ 为 $m$ 的倍数的项，根据经典套路可以分别带入 $m$ 个 $m$ 次单位根后将这些式子的值全部相加来消掉。即：

$$
\begin{aligned}
f(\omega_{m}^{0})&=\omega_m^0a_0+\omega_m^0a_1+\cdots+\omega_m^0a_{m-1}+\cdots\\
f(\omega_{m}^{1})&=\omega_m^0a_0+\omega_m^1a_1+\cdots+\omega_m^{m-1}a_{m-1}+\cdots\\
f(\omega_{m}^{2})&=\omega_m^0a_0+\omega_m^2a_1+\cdots+\omega_m^{m-2}a_{m-1}+\cdots\\
&\cdots\\
f(\omega_{m}^{m-1})&=\omega_m^0a_0+\omega_m^{m-1}+\cdots+\omega_m^1a_{m-1}+\cdots
\end{aligned}
$$

将上列的 $m$ 个式子相加，得到 $a_{p}$ 的系数为 $\displaystyle \sum_{k=0}^{m-1}\omega_m^{kp}$。当 $p\neq 0$ 时，该式恒为 $0$（易证）。当 $p=0$ 时，该式的值为 $m$。

于是，只要我们能够求出 $f(x)$ 在所有 $m$ 次单位根处的取值，加起来除以 $m$ 就是答案。

接下来就是求值了。

注意到，如果 $\gcd(p,m)=1$，那么对于 $k\in[0,m-1]$，$\{kp\}$ 构成模 $m$ 的完系，$f(\omega_m^p)=(\omega_m^0+1)(\omega_m^1+1)\cdots(\omega_m^{m-1}+1)\cdots$。注意到 $x^m-1=(x-\omega_m^0)(x-\omega_m^1)\cdots(x-\omega_m^{m-1})$，代入 $x=-1$ 得到 $(-1)^m-1=(-1-\omega_m^0)(-1-\omega_m^1)\cdots(-1-\omega_m^{m-1})$。故当 $m$ 为偶数时，$(\omega_m^0+1)(\omega_m^1+1)\cdots(\omega_m^{m-1}+1)=0$；$m$ 为奇数时，$(\omega_m^0+1)(\omega_m^1+1)\cdots(\omega_m^{m-1}+1)=2$。则 $f(\omega_m^p)=[m\bmod2=1]2^{\frac{R-L+1}{m}}$。

如果 $\gcd(p,m)\neq 1$，我们也可以使用类似的思路。设 $\gcd(p,m)=g$，那么对于 $k\in[0,\frac{m}{g}-1]$，$\{\frac{kp}{g}\}$ 构成模 $\frac{m}{g}$ 的完系。然后也是类似的推导。

最后的式子是 $\displaystyle \sum_{p=0}^{m-1}f(\omega_m^p)=\sum_{p=0}^{m-1}[\frac{m}{\gcd(p,m)}\bmod 2=1]2^{\frac{R-L+1}{m}\cdot \gcd(p,m)}$。直接拿这个式子算是 $\mathcal{O}(Tm\log m)$ 的，可以获得 85pts 的高分。

考虑优化，显然我们只需要知道对于每个可能的 $g$，$\gcd(p,m)=g$ 的 $p$ 有多少个。$\gcd(\frac{p}{g},\frac{m}{g})=1$，所以有 $\varphi(\frac{m}{g})$ 个。

然后根号枚举 $g$ 即可。总时间复杂度为 $\mathcal{O}(m+T(a+\sqrt{m}))$。

赛时代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int mod = 998244353, mod2 = 998244352, lim = 10000000, sqr = 100000;

LL qpow(LL x, LL cnt) {
	LL ret = 1, bas = x, c = cnt;
	while (c) {
		if (c & 1) ret = ret * bas % mod;
		bas = bas * bas % mod;
		c >>= 1;
	}
	return ret;
}

int T, g[2], cur, phi[10000005], prm[2000005], tot;
bool isp[10000005];
LL m, a, b, c, d, pow1[100005], pow2[100005];

void init() {
	phi[1] = 1;
	for (int i = 2; i <= lim; i++) {
		if (!isp[i]) {
			phi[i] = i - 1;
			prm[++tot] = i;
		}
		for (int j = 1; j <= tot && i * prm[j] <= lim; j++) {
			int tmp = i * prm[j];
			isp[tmp] = 1;
			if (i % prm[j] == 0) {
				phi[tmp] = phi[i] * prm[j];
				break;
			}
			else phi[tmp] = phi[i] * phi[prm[j]];
		}
	}
	pow1[0] = 1; for (int i = 1; i <= sqr; i++) pow1[i] = pow1[i - 1] * 2 % mod;
	pow2[0] = 1; for (int i = 1; i <= sqr; i++) pow2[i] = pow2[i - 1] * pow1[sqr] % mod;
}

LL qmod(LL x) { return (x >= mod ? x - mod : x); }
LL qmod2(LL x) { return (x >= mod2 ? x - mod2 : x); }
LL lpow(LL cnt) { return pow1[cnt % sqr] * pow2[cnt / sqr] % mod; }

void f(LL x, LL l, LL r) {
	g[cur] = -1;
	if (l == 0 || r == 0) return;
	g[cur] = __gcd(l, r) - 1;
}

void work() {
	scanf("%lld %lld %lld %lld %lld", &m, &a, &b, &c, &d);
	cur = 0; f(m, a, b); cur = 1; f(m, c, d);
	LL blc = 0, res = 1;
	for (int i = 1; i <= g[1]; i++) {
		if (i > g[0]) blc = qmod2(blc + res);
		res = res * m % mod2;
	}
	blc = blc * (m - 1) % mod2;
	if (g[0] == -1) blc = qmod2(blc + 1);
	LL all = 0;
	for (int i = 1; i * i <= m; i++) {
		if (m % i == 0) {
			if ((m / i) & 1) all = (all + lpow(blc * i % mod2) * phi[m / i]) % mod;
			if (i * i != m && (i & 1)) all = (all + lpow(blc * (m / i) % mod2) * phi[i]) % mod;
		}
	}
	printf("%lld\n", all * qpow(m, mod - 2) % mod);
}

int main() {
	freopen("calculate.in", "r", stdin);
	freopen("calculate.out", "w", stdout);
	init();
	scanf("%d", &T);
	while (T--) work();
	return 0;
}
```

---

## 作者：luogu_gza (赞：4)

考察辗转相减，$F(x,a,b)=\gcd(x^a-1,x^b-1)+1=\gcd(x^a-1,x^b-x^a)+1=\gcd(x^a-1,x^{b-a}-1)+1(a<b)$，注意到在指数上可以做辗转相减，所以 $F(x,a,b)=x^{\gcd(a,b)}-1+1=x^{\gcd(a,b)}$。

因此注意到 $L \sim R$ 中，每种 $\bmod m$ 的结果出现次数都相等，我们设 $n=\dfrac{R-L}m$。

列出 gf，表述一下答案。

$$\sum_{k=0}^{\infty}[k \bmod m=0][x^k]\prod_{i=0}^{m-1}(1+x^i)^n$$

采用单位根反演。

$$\sum_{k=0}^{\infty}\dfrac 1m \sum_{j=0}^{m-1}[x^k]\prod_{i=0}^{m-1}((x\omega^j)^i+1)^n$$

注意到最外层枚举的 $k$ 其实是在对里面的 gf 做系数和。

$$\dfrac 1m \sum_{j=0}^{m-1}\prod_{i=0}^{m-1}(1+\omega^{ij})^n$$

$\omega$ 上的指数随着 $i$ 的变化实际上是在走一个环，环长为 $\gcd(m,j)$，我们尝试枚举 $\gcd(m,j)$。

$$\dfrac 1m \sum_{g|m}\varphi(\dfrac mg)(\prod_{j=0}^{\frac mg-1}(1+\omega_{\frac mg}^{j}))^{ng}$$

$\prod_{j=0}^{\frac mg-1}(1+\omega_{\frac mg}^{j})$ 其实是 $[2 \nmid \dfrac mg]2$，只需要考察分圆多项式 $x^n-1=\prod_{i=0}^{n-1}(x-\omega_n^i)$，将 $x=-1$ 带入即可得证。

$$\dfrac 1m \sum_{g|m}\varphi(\dfrac mg)[2 \nmid \dfrac mg]2^{ng}$$

暴力算。

---

## 作者：This_Rrhar (赞：2)

$$
\begin{aligned}
F(x,a,b)&=\gcd(x^a-1,x^b-1)+1\\
&=\gcd(x^a-x^b,x^b-1)+1\\
&=\gcd(x^b(x^{a-b}-1),x^b-1)+1\\
&=\gcd(x^{a-b}-1,x^b-1)\\
&=\ldots\\
&=\gcd(x^{\gcd(a,b)}-1,0)+1\\
&=x^{\gcd(a,b)}
\end{aligned}
$$

那么 $L=m^{\gcd(a,b)}+1,R=m^{\gcd(c,d)}$，记 $n=m^{\gcd(c,d)}-m^{\gcd(a,b)}$，原问题转化为：$\{1,2,3,\ldots,n\}$ 中有多少个子集和是 $m$ 的倍数？

容易设生成函数 $F_i(x)=1+x^i$，表示 $i$ 是否在子集中，所有子集的生成函数为

$$
F(x)=\prod\limits_{i=1}^nF_i(x)
$$

显然我们要求的是 $\sum\limits_{m|i}[x^i]F(x)$。

使用单位根反演，有

$$
\begin{aligned}
\text{ans}&=\sum\limits_{m|i}[x^i]F(x)\\
&=\dfrac1m\sum\limits_{i=0}^{m-1}F(\omega_m^i)\\
&=\dfrac1m\sum\limits_{i=0}^{m-1}\prod\limits_{j=1}^nF_i(\omega_m^j)\\
&=\dfrac1m\sum\limits_{i=0}^{m-1}\prod\limits_{j=1}^n(1+\omega_m^{ij})\\
\end{aligned}
$$

令 $g=\gcd(m,i)$，由于 $i,2i,3i,\ldots,mi$ 中共有 $g$ 个模 $\dfrac mg$ 的剩余系，且 $m|n$，故原式可改写为

$$
\begin{aligned}
\text{ans}&=\dfrac1m\sum\limits_{i=0}^{m-1}\left(\prod\limits_{j=1}^\frac mg(1+\omega_ m^{jg})\right)^{g\frac nm}\\
&=\dfrac1m\sum\limits_{i=0}^{m-1}\left(\prod\limits_{j=1}^\frac mg(1+\omega_ \frac mg^j)\right)^{g\frac nm}\\
\end{aligned}
$$

~~打表~~观察可以发现

$$
\prod\limits_{j=1}^\frac mg(1+\omega_ \frac mg^j)=\left[2\nmid \frac mg\right]
$$

进而有

$$
\text{ans}=\dfrac1m\sum\limits_{i=0}^{m-1}\left[2\nmid \frac mg\right]2^{g\frac nm}
$$

分解 $m=2^k\times p$，其中 $p$ 为奇数。那么当 $i=2^k\times q$ 时，才会对 $\rm ans$ 产生贡献，且 $g=2^k\times\gcd(p,q)$。枚举 $q$，可以得到

$$
\text{ans}=\dfrac1m\sum\limits_{q=1}^p2^{\gcd(p,q)\frac np}
$$

时间复杂度为 $O(Tm)$，无法通过。考虑枚举 $i=\gcd(p,q)$，那么 $\dfrac pi\bot\dfrac qi$，这样的数显然有 $\varphi\left(\dfrac pi\right)$ 个，于是得到答案：

$$
\text{ans}=\dfrac1m\sum\limits_{i|p}2^{\frac{in}p}\times\varphi\left(\dfrac pi\right)
$$

线性筛出 $\varphi$ 后再暴力枚举 $p$ 的所有因数即可，时间复杂度 $O(m+T\sqrt m)$，问题解决。

注意封装 $F(x,a,b)$ 以解决 $a=0$ 或 $b=0$ 的情况。另外需要使用 `double`，否则会得到 $85\,\rm pts$ 的好成绩。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _r return*this
#define _o &operator
namespace IO
{
	const int _S=1<<21;
	char b[_S],*p1=b,*p2=b,pb[_S],*pp=pb;
	void fl(){fwrite(pb,1,pp-pb,stdout),pp=pb;}
	struct input
	{
		char gc(){if(p1==p2)p2=(p1=b)+fread(b,1,_S,stdin);return p1==p2?' ':*p1++;}
		input _o>>(char&num){do num=gc();while(num==' '||num=='\n'||num=='\r'||num=='\t');_r;}
		template<typename T>input _o>>(T&x)
		{
			char c=gc();T f=1;
			for(x=0;!isdigit(c);)(c=='-'?f=-1:1),c=gc();
			while(isdigit(c))x=(x*10)+(c^48),c=gc();
			x*=f;_r;
		}
		input(){}
	}in;
	struct output
	{
		void pt(char num){*pp++=num;if(pp-pb==_S)fl();}
		output _o<<(char num){pt(num);_r;}
		template<typename T>output _o<<(T x)
		{
			if(!x){pt(48);_r;}
			if(x<0)pt('-'),x=-x;
			int s[64],t=0;
			while(x)s[++t]=x%10,x/=10;
			while(t)pt(s[t--]+48);
			_r;
		}
		output _o<<(const char*s){int num=0;while(s[num])pt(s[num++]);_r;}
		output(){}
	}out;
	struct fe{~fe(){fl();}}fls;
	
	int read(){int x;return in>>x,x;}
	long long readll(){long long x;return in>>x,x;}
}
using IO::in;
using IO::out;
using IO::read;
using IO::readll;
using ll=long long;

#define N 10000001
#define MOD 998244353

ll qpow(ll x,ll y)
{
	ll res=1;
	x%=MOD;
	while(y)
	{
		if(y&1)(res*=x)%=MOD;
		(x*=x)%=MOD,y>>=1;
	}
	return res;
}
ll pr[N],cur;
bool t[N];
ll phi[N];
void init()
{
	phi[1]=1;
	for(ll i=2;i<N;i++)
	{
		if(!t[i])phi[i]=i-1,pr[++cur]=i;
		for(ll j=1;j<=cur;j++)
		{
			if(i*pr[j]>=N)break;
			t[i*pr[j]]=true;
			if(i%pr[j]==0)
			{
				phi[i*pr[j]]=phi[i]*pr[j];
				break;
			}
			phi[i*pr[j]]=phi[i]*(pr[j]-1);
		}
	}
}

double F(ll x,ll a,ll b)
{
	if(a==0||b==0)return 0;
	return pow(x,__gcd(a,b));
}

ll T,n,m,p,a,b,c,d,ans;

int main()
{
	in>>T,init();
	while(T--)
	{
		in>>m>>a>>b>>c>>d,p=m,n=F(m,c,d)-F(m,a,b),ans=0;
		while(!(p&1))p>>=1;
		for(ll i=1,j=sqrt(p);i<=j;i++)if(p%i==0)
		{
			(ans+=qpow(2,n/p*i)*phi[p/i]%MOD)%=MOD;
			if(i*i!=p)(ans+=qpow(2,n/i)*phi[i]%MOD)%=MOD;
		}
		out<<ans*qpow(m,MOD-2)%MOD<<"\n";
	}
}
```

---

## 作者：RyexAwl (赞：2)

当 $a\ne 0$ 且 $b\ne 0$ 时，有 $F(x,a,b)=x^{\gcd(a,b)}$。

那么求 $L,R$ 是比较简单的，而有 $m\mid (L-1)$，$m\mid R$，那么可以将其看成是 $[1,n]$，其中 $m\mid n$。

令 $f(x)=(1+x)(1+x^2)(1+x^3)...(1+x^n)$。

那么我们要求的即：$\sum_{m\mid d} [x^d]f(x)$。

考虑单位根反演，转化为求：

$$
\dfrac{1}{m}\sum_{i=0}^{m-1}f(\omega_m^{i})
$$

而对于 $m$ 次单位根，有：

考虑：

$$
f(\omega_m^i)=(1+\omega_m^i)(1+\omega_m^{2i})...(1+\omega_m^{ni})
$$

因为 $\omega_m^k=\omega_{m}^{k\bmod m}$，所以 $(1+\omega_m^i)(1+\omega^{2i})...(1+\omega^{mi})$ 可以看成：

$$
(1+\omega_m^0)^p(1+\omega_m^{p})^p(1+\omega_m^{2p})^p...(1+\omega_m^{m-p})^p
$$

其中 $p=\gcd(m,i)$。

把 $m$ 次单位根换成 $\frac{m}{p}$ 次单位根，令 $k=\frac{m}{p}$：

$$
(1+\omega_k^0)^p(1+\omega_k^1)^p(1+\omega_k^2)^p...(1+\omega_k^{k-1})^p
$$

考虑：

$$
z^k-1=(z-\omega_k^0)(z-\omega_k^1)...(z-\omega_k^{k-1})
$$

带入 $z=-1$，当 $k$ 是偶数时：

$$
(1+\omega_k^0)(1+\omega_k^1)(1+\omega_k^2)...(1+\omega_k^{k-1})=0
$$

当 $k$ 是奇数时：

$$
(1+\omega_k^0)(1+\omega_k^1)(1+\omega_k^2)...(1+\omega_k^{k-1})=2
$$

那么：

$$
f(\omega_m^i)=[\gcd(i,m)\bmod 2=1]2^{\frac{n}{m}\times \gcd(i,m)}
$$

答案即：

$$
\frac{1}{m}\sum_{i=1}^m[\frac{m}{\gcd(i,m)}\bmod 2=1]2^{\frac{n}{m}\times \gcd(i,m)}
$$

令 $m=2^k\times u$，且 $2\nmid u$，那么产生贡献的 $i$ 一定满足 $2^k\mid \gcd(i,m)$，考虑枚举 $\gcd$：

$$
\frac{1}{m}\sum_{d\mid u}2^{\frac{n}{u}\times d}\varphi(\frac{u}{d})
$$

复杂度 $O(Td(u)\log V)$。

---

## 作者：DaiRuiChen007 (赞：2)

# P10084 题解

[Problem Link](https://www.luogu.com.cn/problem/P10084)


**题目大意**

> 定义 $F(m,a,b)=\gcd(m^a-1,m^b-1)+1$。
>
> $T$ 次询问给定 $m,a,b,c,d$，设 $L=F(m,a,b),R=F(m,c,d)$，求 $[L+1,R]$ 有多少个子集的元素和是 $m$ 的倍数。
>
> 数据范围：$T\le 10^4,m\le 10^7,L,R\le10^{18}$。

**思路分析**

若无特殊标注，以下 $\omega$ 均指 $\omega_m$。

容易发现 $F(m,a,b)=m^{\gcd(a,b)}$。

显然我们只关心 $(L,R]$ 中 $\bmod m$ 每种余数的个数，显然每种余数出现次数都相等，记为 $n=\dfrac{R-L}m$。

那么就可以开始推式子了：
$$
\begin{aligned}
\mathrm{Answer}
&=\sum_{i=0}^{\infty} [i\mid m][x^i]\prod_{j=0}^{m-1} (x^j+1)^n\\
\end{aligned}
$$
考虑单位根反演 $\sum _{d=0}^{m-1} \omega^{dk}=[k\mid m]m$，把 $x=\omega^0x,\omega^1x,\dots,\omega^{m-1}x$ 分别代入，即可反演掉 $[i\mid m]$ 的限制：
$$
\begin{aligned}
\mathrm{Answer}
&=\sum_{i=0}^{\infty} [i\mid m][x^i]\prod_{j=0}^{m-1} (x^j+1)^n\\
&=\sum_{i=0}^{\infty}\dfrac 1m\sum _{d=0}^{m-1} [x^i]\prod_{j=0}^{m-1}((x\omega ^d)^j+1)^n
\end{aligned}
$$
注意到答案是一个生成函数的系数之和，直接将 $x=1$ 代入得到：
$$
\begin{aligned}
\mathrm{Answer}
&=\sum_{i=0}^{\infty}\dfrac 1m\sum _{d=0}^{m-1} [x^i]\prod_{j=0}^{m-1}((x\omega ^d)^j+1)^n\\
&=\dfrac 1m\sum_{d=0}^{m-1}\prod_{j=0}^{m-1}(\omega^{jd}+1)^n
\end{aligned}
$$
观察到 $0,d,\dots,(m-1)d$ 只和 $\gcd(m,d)=k$ 有关，最终的指数集合形如 $\{0,k,\dots,(m/k-1)k\}$ 重复 $k$ 次，枚举 $k$ 得到：
$$
\begin{aligned}
\mathrm{Answer}
&=\dfrac 1m\sum_{d=0}^{m-1}\prod_{j=0}^{m-1}(\omega^{jd}+1)^n\\
&=\dfrac 1m\sum_{k\mid m}\varphi\left(\dfrac mk\right)\prod_{j=0}^{m/k-1}(\omega^{kj}+1)^{nk}\\
&=\dfrac 1m\sum_{k\mid m}\varphi\left(\dfrac mk\right)\left(\prod_{j=0}^{m/k-1}(\omega^{j}_{m/k}+1)\right)^{nk}\\
\end{aligned}
$$
注意到最后一个式子形如分圆多项式 $z^n-1=\prod_{i=0}^{n-1} (z-\omega_n^i)$的形式，将 $z=-1$ 代入得到 $\prod_{i=0}^{n-1}(\omega_n^i+1)=[2\nmid n]\times 2$：
$$
\begin{aligned}
\mathrm{Answer}
&=\dfrac 1m\sum_{k\mid m}\varphi\left(\dfrac mk\right)\left(\prod_{j=0}^{m/k-1}(\omega^{j}_{m/k}+1)\right)^{nk}\\
&=\dfrac 1m\sum_{k\mid m}\varphi\left(\dfrac mk\right)\left[2\nmid\dfrac mk\right]2^{nk}\\
\end{aligned}
$$
暴力枚举因数计算即可，容易发现 $10^7$ 以内每个元素的奇因子个数 $Q$ 不超过 $200$。

时间复杂度 $\mathcal O(T(\sqrt m+Q\log P))$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=998244353,MAXN=1e7+5;
ll ksm(ll a,ll b=MOD-2,ll p=MOD) {
	ll ret=1; a%=p,b%=p-1;
	for(;b;a=a*a%p,b=b>>1) if(b&1) ret=ret*a%p;
	return ret;
}
int phi[MAXN];
bool isc[MAXN];
vector <int> prs;
void solve() {
	ll m,a,b,c,d;
	scanf("%lld%lld%lld%lld%lld",&m,&a,&b,&c,&d);
	if(m==1) return puts("1"),void();
	ll L=1,R=1;
	if(a&&b) for(int i=0,v=__gcd(a,b);i<v;++i) L=L*m;
	else L=0;
	if(c&&d) for(int i=0,v=__gcd(c,d);i<v;++i) R=R*m;
	else R=0;
	if(L==R) return puts("1"),void();
	ll n=(R-L)/m,ans=0; n%=MOD-1;
	auto add=[&](int x) {
		if((m/x)%2) ans=(ans+phi[m/x]*ksm(2,x*n))%MOD;
	};
	for(int k=1;k*k<=m;++k) if(m%k==0) {
		add(k); if(k*k!=m) add(m/k);
	}
	printf("%lld\n",ans*ksm(m)%MOD);
}
signed main() {
	phi[1]=1;
	for(int i=2;i<MAXN;++i) {
		if(!isc[i]) prs.push_back(i),phi[i]=i-1;
		for(int p:prs) {
			if(i*p>=MAXN) break;
			phi[i*p]=phi[i]*(p-1),isc[i*p]=true;
			if(i%p==0) { phi[i*p]+=phi[i]; break; }
		}
	}
	int T; scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：zifanwang (赞：1)

- [题目传送门](https://www.luogu.com.cn/problem/P10084)
- [前置知识：单位根反演](https://zhuanlan.zhihu.com/p/604377422)

先考虑怎么求 $F(x,a,b)$，易得 $\gcd(x^a-1,x^b-1)=x^{\gcd(a,b)}-1$。

所以 $L=m^{\gcd(a,b)}+1,R=m^{\gcd(c,d)}$，然后发现 $[L,R]$ 中的数模 $m$ 后每种余数出现次数相同，下面记其为 $n=\frac{R-L}{m}$。

考虑用生成函数做，易得答案为：

$$\sum_{i=0}^{\infty}[m\mid i][x^i]\prod_{j=0}^{m-1}(x^j+1)^n$$

套一下单位根反演的式子 $\sum_{k=0}^{\infty}[n\mid k]f_k=\frac{1}{m}\sum_{i=0}^{m-1}f(\omega_m^i)$ 得：

$$\frac{1}{m}\sum_{i=0}^{m-1}\prod_{j=0}^{m-1}(\omega_m^{ij}+1)^n$$

注意到 $\omega_m^m=1$。设 $d=\gcd(m,i)$，那么 $ij \operatorname{mod} m$ 对于所有 $j=0,1,\dots,m-1$ 恰好取遍了 $\{0,d,2d,\dots,m-d\}$ 中的每个数各 $d$ 次，于是枚举 $d$，式子转化为：

$$
\begin{aligned}
&\frac{1}{m}\sum_{k|m}\varphi(\frac{m}{k})\prod_{j=0}^{m/k-1}(\omega_m^{kj}+1)^{nk}\\
=&\frac{1}{m}\sum_{k|m}\varphi(\frac{m}{k})\left(\prod_{j=0}^{m/k-1}(\omega_{m/k}^{j}+1)\right)^{nk}
\end{aligned}
$$

考虑右边这个括号里的东西怎么求，由因式分解知识可得 $x^k-1=\prod_{i=0}^{k-1}(x-\omega_k^i)$，带入 $x=-1$ 就出来了，于是式子转化为：

$$\frac{1}{m}\sum_{k|m}\varphi(\frac{m}{k})2^{nk}[2\nmid \frac{m}{k}]$$

然后直接 $\mathcal O(\sqrt m)$ 枚举 $m$ 的每个因子做就好了，可以通过此题。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 10000003
#define md 998244353
#define rep(i,a,b) for(int i=a;i<=b;++i)
using namespace std;
ll power(ll x,int y){
	ll ans=1;
	for(;y;y>>=1){
		if(y&1)ans=ans*x%md;
		x=x*x%md;
	}
	return ans;
}
ll power1(ll x,int y){
	ll ans=1;
	for(;y;y>>=1){
		if(y&1)ans*=x;
		x*=x;
	}
	return ans;
}
inline int gcd(int x,int y){
	while(y^=x^=y^=x%=y);
	return x;
}
int t,m,a,b,c,d,tot,p[mxn],f[mxn],phi[mxn];
ll l,r,n,g,ans;
void init(int n){
	phi[1]=1;
	rep(i,2,n){
		if(!f[i])f[i]=p[++tot]=i,phi[i]=i-1;
		rep(j,1,tot){
			if(p[j]>f[i]||p[j]>n/i)break;
			f[p[j]*i]=p[j];
			phi[p[j]*i]=i%p[j]?phi[i]*(p[j]-1):phi[i]*p[j];
		}
	}
}
signed main(){
	init(1e7);
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d%d%d",&m,&a,&b,&c,&d);
		l=a==0||b==0?0:power1(m,gcd(a,b));
		r=power1(m,gcd(c,d));
		n=(r-l)/m;
		ans=0;
		g=power(2,n%(md-1));
		rep(k,1,sqrt(m))if(m%k==0){
			if(k&1)ans=(ans+phi[k]*power(g,m/k))%md;
			if(m/k!=k){
				if((m/k)&1)ans=(ans+phi[m/k]*power(g,k))%md;
			}
		}
		printf("%lld\n",(ans*power(m,md-2)%md+md)%md);
	}
	return 0;
}
```

---

## 作者：EuphoricStar (赞：1)

第一步是一个经典结论，$L = m^{\gcd(a, b)} + 1$，$R = m^{\gcd(c, d)}$。

因为 $L \equiv 1 \pmod m$ 且 $R \equiv 0 \pmod m$，所以可以把问题的范围改成 $[1, n = R - L + 1]$。

写出选数的生成函数：

$$F(x) = \prod\limits_{i = 1}^n (1 + x^i)$$

我们希望求所有次数是 $m$ 的倍数的项的系数之和。

施单位根反演：

$$\begin{aligned} ans & = \sum\limits_{i \ge 0} [m \mid i] [x^i] F(x) \\ & = \frac{1}{m} \sum\limits_{i \ge 0} \sum\limits_{j = 0}^{m - 1} \omega_m^{ij} [x^i] F(x) \\ & = \frac{1}{m} \sum\limits_{j = 0}^{m - 1} \sum\limits_{i \ge 0} (\omega_m^j)^i [x^i] F(x) \\ & = \frac{1}{m} \sum\limits_{j = 0}^{m - 1} F(\omega_m^j) \end{aligned}$$

考虑对于一个给定的 $j$ 如何计算 $F(\omega_m^j)$ 即 $\prod\limits_{i = 1}^n (1 + (\omega_m^j)^i)$。

设 $d = \gcd(m, j)$。因为有 $\omega_m^k = \omega_m^{k \bmod m}$，又因为 $\frac{j}{d}, \frac{2j}{d}, \ldots, \frac{nj}{d}$ 形成了 $\frac{n}{\frac{m}{d}}$ 个模 $\frac{m}{d}$ 的剩余系，所以：

$$\begin{aligned} F(\omega_m^j) & = \prod\limits_{i = 1}^n (1 + (\omega_{\frac{m}{d}}^{\frac{j}{d}})^i) \\ & = \prod\limits_{k = 1}^{\frac{m}{d}} (1 + \omega_{\frac{m}{d}}^k)^{\frac{n}{\frac{m}{d}}} \\ & = \prod\limits_{k = 0}^{\frac{m}{d} - 1} (1 + \omega_{\frac{m}{d}}^k)^{\frac{n}{\frac{m}{d}}} \end{aligned}$$

考虑求这样一个式子：$\prod\limits_{i = 0}^{n - 1} (1 + \omega_n^i)$。考虑分圆多项式：

$$x^n - 1 = \prod\limits_{i = 0}^{n - 1} (x - \omega_n^i)$$

代入 $x = -1$ 得：

$$(-1)^n - 1 = \prod\limits_{i = 0}^{n - 1} (-1 - \omega_n^i)$$

$$1 - (-1)^n = \prod\limits_{i = 0}^{n - 1} (1 + \omega_n^i)$$

也就是当 $\frac{m}{d}$ 为偶数时，$F(\omega_m^j) = 0$；否则 $F(\omega_m^j) = 2^{\frac{n}{\frac{m}{d}}}$。

把 $F(\omega_m^j)$ 代入到答案的式子中，有：

$$ans = \frac{1}{m} \sum\limits_{j = 0}^{m - 1} [2 \nmid \frac{m}{\gcd(m, j)}] 2^{\frac{n}{\frac{m}{\gcd(j, m)}}}$$

直接计算，时间复杂度 $O(Tm \log n)$，无法通过。

考虑一些 trivial 的优化，枚举 $d = \gcd(m, j)$，$[0, m - 1]$ 中和 $m$ 的 $\gcd$ 为 $d$ 的数的个数显然为 $\varphi(\frac{m}{d})$，那么：

$$ans = \frac{1}{m} \sum\limits_{d \mid m} [2 \nmid \frac{m}{d}] 2^{\frac{n}{\frac{m}{d}}} \varphi(\frac{m}{d})$$

先线性筛出全部 $\varphi(i)$ 即可计算。时间复杂度降为 $O(T(\sqrt{m} + d(m) \log n))$，可以通过。

```cpp
// Problem: P10084 [GDKOI2024 提高组] 计算
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10084
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 10000100;
const int N = 10000000;
const ll mod = 998244353;

ll n, m, pr[maxn / 10], tot, phi[maxn];
bool vis[maxn];

inline ll qpow(ll b, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) {
			res = res * b % mod;
		}
		b = b * b % mod;
		p >>= 1;
	}
	return res;
}

inline void init() {
	phi[1] = 1;
	for (int i = 2; i <= N; ++i) {
		if (!vis[i]) {
			pr[++tot] = i;
			phi[i] = i - 1;
		}
		for (int j = 1; j <= tot && i * pr[j] <= N; ++j) {
			vis[i * pr[j]] = 1;
			if (i % pr[j] == 0) {
				phi[i * pr[j]] = phi[i] * pr[j];
				break;
			}
			phi[i * pr[j]] = phi[i] * (pr[j] - 1);
		}
	}
}

inline ll work(ll d) {
	if ((m / d) % 2 == 0) {
		return 0;
	}
	return qpow(2, n / (m / d)) * phi[m / d] % mod;
}

void solve() {
	ll _a, _b, _c, _d;
	scanf("%lld%lld%lld%lld%lld", &m, &_a, &_b, &_c, &_d);
	ll _x = 1, _y = 1;
	for (int _ = 0; _ < __gcd(_c, _d); ++_) {
		_x *= m;
	}
	for (int _ = 0; _ < __gcd(_a, _b); ++_) {
		_y *= m;
	}
	n = _x - _y;
	if (!_a || !_b) {
		n = _x;
	}
	ll ans = 0;
	for (ll i = 1; i * i <= m; ++i) {
		if (m % i) {
			continue;
		}
		ans = (ans + work(i)) % mod;
		if (i * i != m) {
			ans = (ans + work(m / i)) % mod;
		}
	}
	printf("%lld\n", ans * qpow(m, mod - 2) % mod);
}

int main() {
	init();
	int T = 1;
	scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}

```

---

## 作者：xiezheyuan (赞：0)

## 简要题意

令 $F(x,a,b)=\gcd(x^a-1,x^b-1)+1$，特别地，当 $ab=0$ 时规定 $F(x,a,b)=0$。

给定 $m,a,b,c,d$，令 $L=F(m,a,b)+1,R=F(m,c,d)$。

计算有多少个 $S\subseteq [L,R]\cap\mathbb{Z}$ 满足 $m\mid \sum\limits_{i\in S} i$，答案对 $\mathrm{mod}=998,244,353$ 取模。

$T$ 组数据，$1\leq T\leq 10^4,1\leq m\leq 10^7,0\leq a,b,c,d\leq 10^3,0\leq L<R\leq 10^{18}$。

## 思路

> 引理 1：$F(x,a,b)=x^{\gcd(a,b)}$（$ab\neq 0$）。

证明：钦定 $a\geq b$，则有：

$$
\begin{aligned}
F(x,a,b)&=\gcd(x^a-1,x^b-1)+1=\gcd(x^a-1-(x^b-1),x^b)+1\\
&=\gcd(x^b(x^{a-b}-1),x^b-1)=\gcd(x^{a-b}-1,x^b-1)
\end{aligned}
$$

对指数数学归纳，则立即有：

$$
F(x,a,b)=x^{\gcd(a,b)}-1+1=x^{\gcd(a,b)}
$$

Q.E.D.

那么就有：

$$
L = m^{\gcd(a,b)}+1,R=m^{\gcd(c,d)}
$$

则 $m\mid (L-1),m\mid R$。不妨将所有数全部减去 $L-1$，并令 $n=R-L+1$，则将原本的集合 $[L,R]\cap\mathbb{N}$ 归约到 $[1,n]\cap\mathbb{N}$。

考虑如何刻画子集和，常见的方法就是生成函数，根据 OGF 理论，我们很容易写出答案的一个表达式：

$$
\sum_{i\geq 0} [m\mid i]\cdot [z^i]\prod_{k=1}^{n}(1+z^k)
$$
后面的 $n$ 个二项式的乘积目前是较难处理的，不妨先令 $F(z)=\prod\limits_{k=1}^{n}(1+z^k)$，将答案改写为 $\sum\limits_{i\geq 0}[m\mid i]\cdot [z^i]F(z)$​。

不妨进行单位根反演：
$$
\begin{aligned}
&\sum_{i\geq 0}[m\mid i]\cdot [z^i]F(z)=\frac{1}{m}\sum_{i\geq 0}[z^i]F(z)\sum_{k=0}^{m-1}\omega_m^{ik}\\
=&\frac{1}{m}\sum_{k=0}^{m-1}\sum_{i\geq 0}[z^i]F(z)\cdot \left(\omega_m^k\right)^i=\frac{1}{m}\sum_{k=0}^{m-1} F(\omega_m^k)
\end{aligned}
$$
因此我们得到一个经典引理，这是单位根反演公式的直接推论：

> 引理 2：
> $$
> \sum_{i\geq 0}[m\mid i]\cdot [z^i]F(z)=\frac{1}{m}\sum_{k=0}^{m-1} F(\omega_m^k)
> $$

那么我们现在就需要研究 $F(\omega_m^k)$ 的取值，将 $F(z)=\prod\limits_{k=1}^{n}(1+z^k)$ 代入：
$$
F(\omega_m^k)=\prod_{i=1}^{n}(1+\omega_m^{ik})
$$
由于 $m\mid (L-1),m\mid R$，因此 $m\mid R-(L-1)$，即 $m\mid n$，又因为根据本原单位根的性质，$\forall i,j,k\in\mathbb{Z}^+,\omega_m^{im+k}=\omega_m^{jm+k}$，所以可以改写：
$$
F(\omega_m^k)=\prod_{i=1}^{n}(1+\omega_m^{ik})=\left(\prod_{i=0}^{m-1}(1+\omega_m^{ik})\right)^{\frac{n}{m}}
$$
取 $p=\gcd(m,k)$，根据本原单位根的另一个性质 $\omega_{mk}^{ak}=\omega_m^a$，得到：
$$
\begin{aligned}
&\sqrt[\frac{n}{m}\cdot p]{F(\omega_m^k)}=\prod_{i=0}^{\frac{m}{p}-1}(1+\omega_{\frac{m}{p}}^{i\frac{k}{p}})=\prod_{i=0}^{\frac{m}{p}-1}(1+\omega_{\frac{m}{p}}^i)\\
=&(-1)^{\frac{m}{p}}\prod_{i=0}^{\frac{m}{p}-1}((-1)-\omega_{\frac{m}{p}}^i)=(-1)^{\frac{m}{p}}((-1)^{\frac{m}{p}}-1)=2\left[2\nmid \frac{m}{p}\right]
\end{aligned}
$$
倒数第二步用到的是根据单位根的定义的因式分解 $z^n-1=\prod_{i=0}^{n-1} (z-\omega_{n}^i)$。将结果代入：
$$
\begin{aligned}
&\frac{1}{m}\sum_{k=0}^{m-1} F(\omega_m^k)=\frac{1}{m}\sum_{k=0}^{m-1}\left[2\nmid \frac{m}{\gcd(m,k)}\right]2^{\frac{n\gcd(m,k)}{m}}\\
=&\frac{1}{m}\sum_{d\mid m}\left[2\nmid \frac{m}{d}\right]2^{\frac{nd}{m}}\sum_{k=0}^{m-1}[\gcd(m,k)=d]=\frac{1}{m}\sum_{d\mid m}2^{\frac{nd}{m}}\left[2\nmid \frac{m}{d}\right]\sum_{k=1}^{\frac{m}{d}}\left[\gcd\left(\frac{m}{d},k\right)=1\right]\\
=&\frac{1}{m}\sum_{d\mid m}2^{\frac{nd}{m}}\left[2\nmid \frac{m}{d}\right]\varphi\left(\frac{m}{d}\right)=\frac{1}{m}\sum_{d\mid m}2^{\frac{n}{d}}[2\nmid d]\varphi(d)
\end{aligned}
$$
$O(m)$ 线性筛出 $\varphi$，然后每组数据暴力枚举 $m$ 的因子即可，时间复杂度 $O(m+T\sqrt{m}\log \mathrm{mod})$，勉强能过。

## 代码

```cpp
#include <bits/stdc++.h>
using std::cin, std::cout;

constexpr int mod = 998244353;
int A(int x, int y){ return (x + y) >= mod ? (x + y - mod) : (x + y); }
int S(int x, int y){ return (x - y) < 0 ? (x - y + mod) : (x - y); }
int M(int x, int y){ return 1ll * x * y % mod; }
int P(int x, int y){ int ans = 1; for(;y;x=M(x,x),y>>=1) if(y & 1) ans = M(ans, x); return ans; }
int I(int x){ return P(x, mod - 2); }
template<class T> int Fit(T x){ return (x % mod + mod) % mod; }

const int N = 1e7 + 5;
int pri[N], phi[N], tot;
bool vis[N];

void sieve(int n){
    phi[1] = 1;
    for(int i=2;i<=n;i++){
        if(!vis[i]) pri[++tot] = i, phi[i] = i - 1;
        for(int j=1;j<=tot&&1ll*i*pri[j]<=n;j++){
            vis[i * pri[j]] = 1;
            if(!(i % pri[j])){
                phi[i * pri[j]] = phi[i] * pri[j];
                break;
            }
            phi[i * pri[j]] = phi[i] * (pri[j] - 1);
        }
    }
}

namespace solution {
    using i64 = long long;
    int m, a, b, c, d;
    std::basic_string<int> ds;

    i64 naive_pow(int x, int y){
        i64 ret = 1;
        for(int i=0;i<y;i++) ret = ret * x;
        return ret;
    }

    i64 F(int m, int a, int b){ return (!a || !b) ? 0 : naive_pow(m, std::gcd(a, b)); }

    void solve(){
        cin >> m >> a >> b >> c >> d;
        i64 L = F(m, a, b) + 1, R = F(m, c, d), n = R - L + 1;
        for(int i=1;i*i<=m;i++){
            if(m % i) continue;
            ds += i;
            if(i * i != m) ds += m / i;
        }
        int ans = 0;
        for(int x : ds) if(x & 1) ans = A(ans, M(phi[x], P(2, (n / x) % (mod - 1))));
        cout << M(ans, I(m)) << '\n';
    }

    void clear(){ ds.clear(); }
}

signed main(){
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    sieve(1e7);
    int T; cin >> T;
    while(T--) solution::solve(), solution::clear();
    return 0;
}

// [P_10084_GDKOI_2024_提高组_计算.cpp] Think twice, code once.
// Written by xiezheyuan
```

---

## 作者：0x3F (赞：0)

首先，我们注意到，$\gcd(x^a-1,x^b-1)=x^{\gcd(a,b)}-1$，可以使用数学归纳法证明。

因此，我们有 $m\mid(R-L)$，设 $R-L=km$，则答案显然为：

$$\sum_{i=0}^{\infty}[x^{mi}]((x^0+1)(x^1+1)(x^2+1)\cdots(x^{m-1}+1))^k$$

我们考虑单位根反演，记 $\omega_m$ 为 $m$ 次单位根，则原式可化为：

$$\frac{1}{m}\sum_{i=0}^{m-1}[((x^0+1)(x^1+1)(x^2+1)\cdots(x^{m-1}+1))^k]_{x=\omega_m^i}
\\
=\frac{1}{m}\sum_{d\mid m}\varphi(d)((\omega_{d}^{0}+1)(\omega_{d}^{1}+1)(\omega_{d}^{2}+1)\cdots(\omega_{d}^{d-1}+1))^{\frac{km}{d}}$$

我们注意到，$x^d-1=(x-\omega_{d}^{0})(x-\omega_{d}^{1})(x-\omega_{d}^{2})\cdots(x-\omega_{d}^{d-1})$

代入 $x=-1$，得：$(-1)^d-1=(-1)^d(\omega_{d}^{0}+1)(\omega_{d}^{1}+1)(\omega_{d}^{2}+1)\cdots(\omega_{d}^{d-1}+1)$

故 $(\omega_{d}^{0}+1)(\omega_{d}^{1}+1)(\omega_{d}^{2}+1)\cdots(\omega_{d}^{d-1}+1)=\begin{cases}2&2\nmid d\\0&2\mid d\end{cases}$

则原式可化为：

$$\frac{1}{m}\sum_{d\mid m}[2\nmid d]\varphi(d)2^{\frac{km}{d}}$$

预处理 $\varphi$，查询可以直接计算。

时间复杂度为 $\mathcal{O}(T\sqrt{m})$，瓶颈为质因数分解。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int p = 998244353;
inline int qpow(int a, long long b) {
    int s = 1;
    while (b) {
        if (b & 1LL) {
            s = (long long) s * a % p;
        }
        a = (long long) a * a % p;
        (b >>= 1LL);
    }
    return s;
}
const int _ = 1e7 + 10;
int cp, pr[_], phi[_];
bool vis[_];
inline void init(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            pr[++cp] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cp && i * pr[j] <= n; j++) {
            vis[i * pr[j]] = true;
            if (!(i % pr[j])) {
                phi[i * pr[j]] = phi[i] * pr[j];
                break;
            } else {
                phi[i * pr[j]] = phi[i] * (pr[j] - 1);
            }
        }
    }
}
int main() {
    init(10000000);
    ios::sync_with_stdio(0);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
        int m, a, b, c, d;
        cin >> m >> a >> b >> c >> d;
        long long L = 0LL;
        if (a && b) {
            int g = __gcd(a, b);
            L = 1LL;
            while (g--) {
                L *= m;
            }
        }
        long long R = 0LL;
        if (c && d) {
            int g = __gcd(c, d);
            R = 1LL;
            while (g--) {
                R *= m;
            }
        }
        long long k = (R - L) / m;
        int ans = 0;
        for (int i = 1; i * i <= m; i++) {
            if (!(m % i)) {
                if (i & 1) {
                    ans = (ans + (long long) phi[i] * qpow(2, k * (m / i))) % p;
                }
                if (i * i != m) {
                    if ((m / i) & 1) {
                        ans = (ans + (long long) phi[m / i] * qpow(2, k * i)) % p;
                    }
                }
            }
        }
        ans = (long long) ans * qpow(m, p - 2) % p;
        cout << ans;
        if (T) {
            cout << '\n';
        }
    }
    cout << endl;
}
```

---

## 作者：Kreado (赞：0)

前置知识：[from 3b1b](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1R34y1W7Xn)。

[题目传送门](https://www.luogu.com.cn/problem/P10084)。

有意思的问题。

## 思路

考虑化简 $F(x,a,b)=\gcd(x^a-1,x^b-1)+1$，默认 $a\ge b$。

根据欧几里得定理，有 $\gcd(a,b)=\gcd(a-b,a),(a\ge b)$。

那么 $\gcd(x^a-1,x^b-1)=\gcd(x^a-x^b,x^b-1)=\gcd(x^b(x^{a-b}-1),x^b-1)$，因为 $\gcd(x^b,x^b-1)=1$，所以 $F(x,a,b)=\gcd(x^{a-b}-1,x^b-1)+1$。

我们发现，指数在更相减损，归纳得到 $F(x,a,b)=x^{\gcd(a,b)}$。

那么 $L=m^{\gcd(a,b)}+1,R=m^{\gcd(c,d)}$，我们可以直接将 $L,R$ 减去 $L$。

问题也就转换成了集合 $\{1,\cdots,R-L \}$ 有多少子集和为 $m$ 的倍数。

令 $n=R-L+1,S=n(n+1)/2$，考虑生成函数 $G(x)=\displaystyle \prod_{i=1}^n (1+x^i)$，那么答案就是

$$\sum_{i=1}^S [m\mid i] [x^i]G(x)$$

使用单位根反演，原式化为了

$$\dfrac{1}{m}\sum_{i=1}^m G(\omega_m^i)$$

问题也就转换成了如何快速求出

$$\dfrac{1}{m}\sum_{i=1}^m \left(\prod_{i=1}^n (1+\omega_m^{ij})\right)$$

很显然，大括号里面的式子一定存在一个循环节，假设 $\gcd(i,m)=k$，那么循环节长度就是 $\dfrac{m}{k}$，不妨枚举这个 $k$，那么有

$$
\begin{aligned}
\sum_{i=1}^m \left(\prod_{i=1}^n (1+\omega_m^{ij})\right)&=\sum_{k\mid m}\left( \sum_{i=1}^m [\gcd(i,m)=k] \right)\left(\prod_{i=1}^{m/k}(1+\omega_{m}^{ik})\right)^{nk/m}\\
&=\sum_{k\mid m}\varphi\left(\dfrac{m}{k}\right)\left(\prod_{i=1}^{m/k}(1+\omega_n^{ik})\right)^{nk/m}\\
&=\sum_{k\mid m}\varphi\left(\dfrac{m}{k}\right)(1-(-1)^k)^{n/k}\\
&=\sum_{k\mid m,2\nmid k}\varphi\left(k\right)2^{n/k}
\end{aligned}
$$

答案就是 

$$\dfrac{1}{m}\sum_{k\mid m,2\nmid k}\varphi\left(k\right)2^{n/k}$$

时间复杂度 $\mathcal{O}(T(\sqrt m+\tau(m)\log p))$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const ll Mod=998244353,MML=5e18;
const int Maxn=1e7+7;
int T;
ll m,a,b,c,d;
vector<int>prm;
bitset<Maxn>isp;
ll phi[Maxn];

inline void init(int N){
    isp.set(0),isp.set(1);phi[1]=1;
    for(int i=2;i<=N;i++){
        if(!isp.test(i)) prm.emplace_back(i),phi[i]=i-1;
        for(auto j:prm){
            const int t=i*j;
            if(t>N) break;
            isp.set(t);
            if(!(i%j)){
                phi[t]=phi[i]*j;
                break;
            }
            phi[t]=phi[i]*(j-1);
        }
    }
}
inline ll ksm(ll a,ll b,ll mod){ll z=1;a%=mod;while(b){if(b&1) z=z*a%mod;a=a*a%mod;b>>=1;}return z;}
inline ll upd(ll x){
    return (x%Mod+Mod)%Mod;
}
inline ll calc(ll a,ll b){
    if(!a||!b) return 0;
    return ksm(m,__gcd(a,b),MML);
}

int main(){
    scanf("%d",&T);

    init(Maxn-3);

    while(T--){
        scanf("%lld%lld%lld%lld%lld",&m,&a,&b,&c,&d);
        ll n=calc(c,d)-calc(a,b);

        ll ans=0;
        for(ll k=1;k*k<=m;k++){
            if(!(m%k)){
                if(k&1) ans=upd(ans+phi[k]*ksm(2,n/k,Mod)%Mod); 
                if(k*k!=m&&((m/k)&1)) ans=upd(ans+phi[m/k]*ksm(2,n/(m/k),Mod)%Mod);
            }
        }
        ans=upd(ans*ksm(m,Mod-2,Mod)%Mod);
        printf("%lld\n",ans);
    }
    return 0;
}
```



---

## 作者：Register_int (赞：0)

前置知识：如果感觉单位根反演不好理解可以看看 [这个](https://www.bilibili.com/video/BV1R34y1W7Xn)。

首先把 $F$ 处理掉。不妨设 $a\ge b$，我们有：

$$
\begin{aligned}
&\gcd(x^a-1,x^b-1)+1\\
=&\gcd((x^a-1)-(x^b-1),x^b-1)+1\\
=&\gcd(x^a-x^b,x^b-1)+1\\
=&\gcd(x^{a-b}-1,x^b-1)+1\\
=&\cdots\\
=&x^{\gcd(a,b)}-1+1\\
=&x^{\gcd(a,b)}\\
\end{aligned}
$$

有 corner case，但读者可以发现这些都满足接下来的讨论，所以不做过多说明。中所以题目实际上是求 $(m^{\gcd(a,b)},m^{\gcd(c,d)}]$ 的答案。显然这玩意与 $(0,m^{\gcd(c,d)}-m^{\gcd(a,b)}]$ 同余，所以设 $n=m^{\gcd(c,d)}-m^{\gcd(a,b)}$，转化为 $[1,n]$ 内的答案。

显然可以进行朴素的背包，写成多项式形式，子集和为 $k$ 的方案数为 $[x^k]\prod^n_{i=1}(1+x^i)$，答案即为 $\sum_k[m|k][x^k]\prod^n_{i=1}(1+x^i)$。

现在我们要做的是提取所有次数为 $m$ 倍数的项的系数。单位根反演得到答案为：

$$\dfrac1m\sum^m_{i=1}f(\omega^i_m)$$

由于 $n$ 能被 $m$ 整除，我们只需要关心 $0\sim m-1$ 这些数。而对于 $0\le k<m$，$\omega^{ki}_m$ 显然存在循环节，循环次数为 $d=\gcd(k,m)$。不妨枚举循环的次数，得到：

$$
\begin{aligned}
&\dfrac1m\sum_{d|m}\left(\sum^m_{i=1}[\gcd(i,m)=d]\right)\left(\prod^{m/d}_{j=1}(\omega^{jd}_m+1)\right)^{d\times n/m}\\
=&\dfrac1m\sum_{d|m}\varphi(m/d)\left(\prod^{m/d}_{j=1}(\omega^{jd}_m+1)\right)^{nd/m}\\
=&\dfrac1m\sum_{d|m}\varphi(m/d)\left(\prod^{m/d}_{j=1}(\omega^j_{m/d}+1)\right)^{nd/m}\\
\end{aligned}
$$

对于后面大括号里的柿子，他为 $(-1)^{m/d}\prod^{m/d}_{j=1}(-1-\omega^j_{m/d})$。后半部分是 $x^{m/d}-1$ 因式分解后在 $x=-1$ 时的值，所以整体为 $(-1)^{m/d}((-1)^{m/d}-1)=1-(-1)^{m/d}=2[2\nmid\frac md]$。得到答案：

$$
\dfrac1m\sum_{d|m}\varphi(m/d)[2\nmid \frac md]2^{nd/m}
$$

事实上，因为要保证 $m/d$ 不含 $2$ 的因数，可以直接求出 $m$ 的最大奇因子 $p$，那么原式为：

$$
\dfrac1m\sum_{d|p}\varphi(p/d)2^{nd/p}=\dfrac1m\sum_{d|p}\varphi(d)2^{np}
$$

$p$ 的约数个数极小，可以直接枚举，但前提是我们要保证只枚举到约数。可以将每个数的最小质因子预处理出来做到 $O(m)-O(\log m)$ 分解质因数，再搜索搜出他的所有约数，复杂度就对了。时间复杂度 $O(m)-O(\sigma_0(p)\log n)$。事实上，$\varphi(d)$ 的值可以在搜索的过程中递推得出，可以下降一半的常数。

我们还有另一种做法：不预处理，直接枚举因数。时间复杂度是 $O(1)-O(\sigma_0(p)\sqrt m)$ 的。数据分治一下可以达到最优复杂度。总时间 417ms，跑进了最优解第一页。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e7 + 10;
const int mod = 998244353;

int pr[MAXN], mp[MAXN], tot; bool vis[MAXN];

inline 
void init(int n) {
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) pr[++tot] = i, mp[i] = i;
		for (int j = 1; j <= tot; j++) {
			if (i * pr[j] > n) break;
			vis[i * pr[j]] = 1, mp[i * pr[j]] = pr[j];
			if (i % pr[j] == 0) break;
		}
	}
}

inline 
ll qpow(ll b, ll p) {
	ll res = 1;
	for (; p; p >>= 1, b = b * b % mod) if (p & 1) res = res * b % mod;
	return res;
}

inline 
ll _pow(ll b, ll p) {
	ll res = 1;
	for (; p; p >>= 1, b = b * b) if (p & 1) res = res * b;
	return res;
}

inline 
ll calc(ll m, ll a, ll b) {
	if (!a || !b) return 0;
	return _pow(m, __gcd(a, b));
}

inline 
ll calcphi(int n) {
	int res = n;
	for (int i = 2; i <= n / i; i++) {
		if (n % i == 0) for (res -= res / i; n % i == 0; n /= i);
	}
	if (n > 1) res -= res / n; return res;
}

int f[MAXN], pw[MAXN], cnt;

inline 
void get(int n) {
	for (cnt = 0; n > 1;) {
		f[++cnt] = mp[n], pw[cnt] = 0;
		for (; n % f[cnt] == 0; n /= f[cnt], pw[cnt]++);
	}
}

int T; ll m, a, b, c, d, n, p, ans;

void dfs(int k, ll x, ll phi) {
	if (k > cnt) return ans = (ans + phi * qpow(2, n / x)) % mod, void();
	for (int i = 0; i <= pw[k]; i++) dfs(k + 1, x, phi), x *= f[k], phi *= (f[k] - !i);
}

int main() {
	scanf("%d", &T);
	if (T > 5) {
		init(1e7);
	    for (; T--;) {
	    	scanf("%lld%lld%lld%lld%lld", &m, &a, &b, &c, &d);
	    	for (p = m; ~p & 1; p >>= 1); get(p);
	    	n = calc(m, c, d) - calc(m, a, b), ans = 0, dfs(1, 1, 1);
	    	printf("%lld\n", ans * qpow(m, mod - 2) % mod);
		}
	} else {
		for (; T--;) {
	    	scanf("%lld%lld%lld%lld%lld", &m, &a, &b, &c, &d);
	    	n = calc(m, c, d) - calc(m, a, b), ans = 0;
	    	for (int i = 1; i <= m / i; i++) {
	    		if (m % i == 0 && i & 1) ans = (ans + calcphi(i) * qpow(2, n / i) % mod) % mod;
			}
			for (int i = 1; i < m / i; i++) {
	    		if (m % i == 0 && m / i & 1) ans = (ans + calcphi(m / i) * qpow(2, n / m * i) % mod) % mod;
			}
	    	printf("%lld\n", ans * qpow(m, mod - 2) % mod);
		}
	}
}
```

---

## 作者：zhouyuhang (赞：0)

首先发现 $f(x,a,b)=x^{\gcd(a,b)}$，证明可以考虑对指数作辗转相减。写成 GF 的形式，即求 

$$
[x^0]\left(\prod_{i=l}^r(x^i+1)\bmod (x^k -1)\right)
$$

考虑单位根反演 $[k\mid n]=\frac{1}{k}\sum_{i=0}^{k-1}\omega_{k}^{in}$。则有答案为

$$
\frac{1}{k}\sum_{i=0}^{k-1}\prod_{j=l}^r(\omega_{k}^{ij}+1)
$$

注意到 $k\mid r-l+1$。记 $n=\frac{r-l+1}{k}$，则有答案为

$$
\begin{aligned}
& \frac{1}{k}\sum_{i=0}^{k-1}\left(\prod_{j=0}^{k-1}(\omega_{k}^{ij}+1)\right)^n\\
& =\frac{1}{k}\sum_{i=0}^{k-1}\left(\prod_{j=0}^{(k/\gcd(i,k))-1}(\omega_{k/\gcd(i,k)}^j+1)\right)^{n\gcd(i,k)}\\
\end{aligned}
$$

我们接下来考察 $\prod_{i=0}^{k-1}(\omega_k^i+1)$。只需注意 $x^k-1=\prod_{i=0}^{k-1}(x-\omega_k^i)$，则带入 $x=-1$ 得到 $\prod_{i=0}^{k-1}(\omega_k^i+1)=1-(-1)^k$。带回上式，有答案为

$$
\begin{aligned}
& \frac{1}{k}\sum_{i=0}^{k-1}\left(1-(-1)^{k/\gcd(i,k)}\right)^{n\gcd(i,k)} \\
& =\frac{1}{k}\sum_{d\mid k}\left(1-(-1)^{k/d}\right)^{nd}\varphi\left(\frac{k}{d}\right)\\
\end{aligned}
$$

于是可以直接枚举因子计算，复杂度即为 $\Theta(\operatorname{factor}(k)+\tau(k)\log n)$。

---


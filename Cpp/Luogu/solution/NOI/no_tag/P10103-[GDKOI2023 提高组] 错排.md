# [GDKOI2023 提高组] 错排

## 题目描述

小 X 最近学习了错排问题，于是开始思考一个关于它的变种问题：有多少个长度为 $n$ 的排列 $p$，满足对
于 $i \le m$ 的位置满足 $p_i > m$，且对于所有位置 $i$ 都满足 $p_i \ne i$？

小 X 一共想出了 $T$ 个这样的问题，你能告诉他每个问题的答案吗？

由于答案可能过大，你只需要求出答案对 $998244353$ 取模后的值即可。

## 说明/提示

对于 100% 的数据，$0 ≤ T ≤ 2 \times 10^5$，$0 ≤ m ≤ n ≤ 2 \times 10^5$。

本题采用子任务捆绑测试。

- Subtask 1 (1pts)：保证 $T = 0$。
- Subtask 2 (9pts)：保证 $T ≤ 10$，$n, m ≤ 8$。
- Subtask 3 (10pts)：保证 $m = 0$。
- Subtask 4 (20pts)：保证 $n, m ≤ 5000$。
- Subtask 5 (20pts)：保证 $T ≤ 10$。
- Subtask 6 (40pts)：无特殊性质。

## 样例 #1

### 输入

```
6
8 0
8 4
100 10
1000 100
10000 1000
100000 10000
```

### 输出

```
14833
576
548326276
694205000
493811811
135068319```

# 题解

## 作者：vegetable_king (赞：12)

[可能更好的阅读体验](https://yjh965.github.io/post/gdkoi2023-ti-gao-zu-cuo-pai-ti-jie/)

非常好 Counting，使我滨州发光旋转。

$2m > n$ 显然无解，判掉。

首先考虑，对于一个 $> m$ 的数，如果它填到了左边，那么它所对应的位置就没有限制了。所以考虑在 $> m$ 的数中选择 $m$ 个，有序地填到左边，右边 $n - m$ 个位置就有 $m$ 个没有限制，剩下 $n - 2m$ 个位置有限制。

如果我们设 $f_{i, j}$ 为一个长为 $i + j$ 的序列，前面 $i$ 个位置没有限制，后面 $j$ 个位置有限制的方案数，则答案为 $m!\binom{n - m}mf_{m, n - 2m}$，现在我们的目标就变为快速求出 $f_{i, j}$。

考虑推导出递推式。按照传统错排问题的思路，考虑填一个有限制的位置对应的数。考虑两种情况：

1. 其对应的数填到了一个无限制的位置，则这个有限制的位置变为无限制的位置，被填到的那个位置被移除，相当于少了一个有限制的位置，无限制的位置个数不变，方案数为 $i \times f_{i, j - 1}$。
2. 其对应的数填到了另外一个有限制的位置，则这个有限制的位置变为无限制的位置，被填到的那个位置被移除，相当于少了两个有限制的位置，无限制的个数多了一个，方案数为 $(j - 1) f_{i + 1, j - 2}$。

于是可以 $O(n^2)$ 预处理 $f_{i, j}$。

尝试填一个无限制的位置对应的数得到另一个递推式，考虑两种情况：

1. 其对应的数就填在这个位置，则不产生任何贡献，方案数为 $f_{i - 1, j}$。
2. 钦定其对应的数不能填在这个位置，这个无限制的位置变为有限制的位置，方案数为 $f_{i - 1, j + 1}$。

整合一下得到两个递推式：
$$
f_{i, j} = i \times f_{i, j - 1} + (j - 1) f_{i + 1, j - 2}\\
f_{i, j} = f_{i - 1, j} + f_{i - 1, j + 1}\\
$$

将第二个递推式代入第一个递推式的 $f_{i + 1, j - 2}$ 中，得到：
$$
f_{i, j} = i \times f_{i, j - 1} + (j - 1)(f_{i, j - 2} + f_{i, j - 1})\\
f_{i, j} = (j - 1)f_{i, j - 2} + (i + j - 1)f_{i, j - 1}\\
f_{i, j + 2} = (j + 1) \times f_{i, j} + (i + j + 1) f_{i, j + 1}\\
$$
所以如果知道了 $f_{i, j}, f_{i, j + 1}$ 可以 $O(1)$ 求出 $f_{i, j + 2}$。根据最开始的第二个递推式，有：
$$
f_{i + 1, j} = f_{i, j} + f_{i, j + 1}\\
f_{i + 1, j + 1} = f_{i, j + 1} + f_{i, j + 2}\\
$$
将 $f_{i, j + 2}$ 代入，得：
$$
f_{i + 1, j + 1} = (j + 1) \times f_{i, j} + (i + j + 2) f_{i, j + 1}\\
$$
所以如果知道了 $f_{i, j}, f_{i, j + 1}$ 可以 $O(1)$ 求出 $f_{i + 1, j}, f_{i + 1, j + 1}$。

我们也可以手动解方程回推，知道 $f_{i, j}, f_{i, j + 1}$ 可以 $O(1)$ 求出 $f_{i, j - 1}$ 以及 $f_{i - 1, j}, f_{i - 1, j + 1}$：
$$
f_{i - 1, j} = \frac{(i + j + 1)f_{i, j} - f_{i, j + 1}}i\\
f_{i - 1, j + 1} = \frac{f_{i, j + 1} - (j + 1)f_{i, j}}i\\
f_{i, j - 1} = \frac{f_{i, j + 1} - (i + j) f_{i, j}}j\\
$$

综上所述，我们可以维护 $(f_{i, j}, f_{i, j + 1})$，并在 $O(1)$ 的时间复杂度内支持 $i \to i \pm 1, j \to j \pm 1$ 四种操作。于是将询问离线下来，上莫队即可，时间复杂度为 $O(T \sqrt n)$。[代码](https://www.luogu.com.cn/paste/xq7nwsj1)在这里。

---

## 作者：kyEEcccccc (赞：8)

这里提供一种非常简洁有力的做法。

注意到我们要解决的问题只是：对于 $T$ 组 $n, m$ 求 $n-m$ 个自由元素，$m$ 个限制元素的广义错排。剩余部分容易在 $\Theta(n)$ 部分解决，这里不赘述。

首先写出错排问题三种组合意义导出的转移方程：

$$
\begin{aligned}
f(n, m) &= f(n,m-1)-f(n-1,m-1) & (1)\\
f(n, m) &= (m-1)f(n-1,m-2)+(n-m)f(n-1,m-1) & (2)\\
f(n, m) &= mf(n-1,m-1)+(n-m)f(n-1,m) & (3)\\
\end{aligned}
$$

详细的解释：

- $(1)$ 式：考虑将一个自由元素替换成限制元素，会造成一些排列不合法，具体地也就是将这个元素放在原位不动的那些排列。通过直接删除该元素不难发现这些不合法排列个数就是 $f(n-1,m-1)$。
- $(2)$ 式：考虑新加入一个限制元素，讨论它放在哪里。
- $(3)$ 式：类似地考虑新加入一个自由元素，讨论它放在哪里。

联立 $(1),(2)$，当我们将 $(n,m),(n,m-1),(n-1,m-1),(n-1,m-2)$ 四个位置放到坐标系中，注意到它们排列为一个竖着较长的平行四边形。我们只需要知道其中的任意两个就能通过解上面给出的方程得到另外两个。对于 $(1),(3)$ 也是同理，会得到横着较长的平行四边形。

所以只需要维护形如 $(f(a, b),f(a+1,b+1))$ 的数对，就可以通过上述的两组方程在 $\Theta(1)$ 时间内使得 $a$ 或 $b$ 增加 $1$，结合回滚莫队即可做到 $\Theta(n\sqrt T)$。解方程时会用到逆元，但是值域很小，预处理即可。

```cpp
// Author: kyEEcccccc

#include <bits/stdc++.h>

using namespace std;

using LL = long long;
using ULL = unsigned long long;

#define F(i, l, r) for (int i = (l); i <= (r); ++i)
#define FF(i, r, l) for (int i = (r); i >= (l); --i)
#define MAX(a, b) ((a) = max(a, b))
#define MIN(a, b) ((a) = min(a, b))
#define SZ(a) ((int)((a).size()) - 1)

constexpr int N = 200005, BB = 420, MOD = 998244353;

ULL kpow(ULL x, ULL k = MOD - 2)
{
	x = x % MOD;
	ULL r = 1;
	while (k)
	{
		if (k & 1) r = r * x % MOD;
		x = x * x % MOD;
		k >>= 1;
	}
	return r;
}

int t;
int p[N], q[N];
array<int, 3> a[N];
ULL res[N], fac[N], ifac[N], iv[N];

ULL C(int n, int r)
{
	if (0 <= r && r <= n) return fac[n] * ifac[r] % MOD * ifac[n - r] % MOD;
	return 0;
}

signed main(void)
{
	// freopen(".in", "r", stdin);
	// freopen(".out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(nullptr);

	fac[0] = 1;
	F(i, 1, 200001) fac[i] = fac[i - 1] * i % MOD, iv[i] = kpow(i);
	ifac[200000] = kpow(fac[200000]);
	FF(i, 200000, 1) ifac[i - 1] = ifac[i] * i % MOD;

	cin >> t;
	F(i, 1, t)
	{
		cin >> p[i] >> q[i];
		if (q[i] > p[i] - q[i]) a[i] = {0, 0, i};
		else a[i] = {p[i] - q[i], p[i] - q[i] - q[i], i};
	}

	sort(a + 1, a + t + 1, [] (array<int, 3> x, array<int, 3> y)
	{
		if (x[0] / BB != y[0] / BB) return x[0] < y[0];
		return x[1] < y[1];
	});

	int cn = 0, cm = 0;
	ULL A = 1, B = 0;
	F(i, 1, t)
	{
		if (cm > a[i][1])
		{
			cn = 0, cm = 0;
			A = 1, B = 0;
		}
		int recn = cn, recm = cm;
		ULL recA = A, recB = B;
		while (cn < a[i][0])
		{
			++cn;
			ULL x = (A + B) % MOD, y = ((cm + 1) * x + (cn - cm) * B) % MOD;
			A = x, B = y;
			if (cn % BB == 0) recn = cn, recA = A, recB = B;
		}
		while (cm < a[i][1])
		{
			++cm;
			ULL x = (B + MOD - cm * A % MOD) * iv[cn - cm + 1] % MOD, y = (B + MOD - x) % MOD;
			A = x, B = y;
		}
		res[a[i][2]] = A;
		cn = recn, cm = recm;
		A = recA, B = recB;
		while (cm < a[i][1] && cm < cn)
		{
			++cm;
			ULL x = (B + MOD - cm * A % MOD) * iv[cn - cm + 1] % MOD, y = (B + MOD - x) % MOD;
			A = x, B = y;
		}
	}

	F(i, 1, t)
	{
		if (q[i] > p[i] - q[i]) cout << 0 << '\n';
		else cout << res[i] * C(p[i] - q[i], q[i]) % MOD * fac[q[i]] % MOD << '\n';
	}

	return 0;
}
```

---

## 作者：MaxBlazeResFire (赞：5)

找组合意义。

设 $f(x)$ 表示，$m$ 右侧恰有 $x$ 个位置满足 $p_i\neq i$ 的方案数。

$g(x)$ 表示，$m$ 右侧有 $x$ 个位置，乱排的方案数。

则 $\displaystyle g(x)=\sum_{i=0}^x\binom{x}{i}f(i)$。即枚举有多少个数是错位的，然后选出这些位置。

反演得 $\displaystyle f(x)=\sum_{i=0}^x\binom{x}{i}(-1)^{x-i}g(i)$。

然后考虑 $g(x)$ 是好求的。即先在左边 $m$ 个位置填，共 $\displaystyle\frac{x!}{(x-m)!}$ 种填法；然后在右面 $x$ 个位置乱填，即 $x!$ 种填法。

$\displaystyle g(x)=\frac{x!^2}{(x-m)!}$。

考虑我们要求的是 $f(n-m)$。代入 $g$，一个询问的答案就是

$\displaystyle f(n-m)=\sum_{i=0}^{n-m}\binom{n-m}{i}(-1)^{n-m-i}\frac{i!^2}{(i-m)!}$。

考虑分离常数并化简，即 $\displaystyle f(n-m)=\sum_{i=0}^{n-m}\frac{(-1)^{n-m-i}(n-m)!i!^2}{i!(n-m-i)!(i-m)!}$

$\displaystyle=\sum_{i=0}^{n-m}\frac{(-1)^{n-m-i}(n-m)!i!}{(n-m-i)!(i-m)!}$

$\displaystyle=\sum_{i=0}^{n-m}\frac{(-1)^i(n-m)!(n-m-i)!}{i!(n-2m-i)!}$

$\displaystyle=\sum_{i=0}^{n-m}\frac{(n-2m)!}{i!(n-2m-i)!}\times\frac{(n-m)!(-1)^i(n-m-i)!}{(n-2m)!}$

$\displaystyle=\frac{(n-m)!}{(n-2m)!}\sum_{i=0}^{n-m}\binom{n-2m}{i}(-1)^i(n-m-i)!$

$\displaystyle=\frac{(n-m)!}{(n-2m)!}\sum_{i=0}^{n-2m}\binom{n-2m}{i}(-1)^i(n-m-i)!$。

求和号左边的东西可以最后乘。

设 $\displaystyle f(A,B)=\sum_{i=0}^A\binom{A}{i}(-1)^i(B-i)!$。

答案即 $f(n-2m,n-m)$。

则 $\displaystyle f(A,B)=\sum_{i=0}^A(\binom{A-1}{i-1}+\binom{A-1}{i})(-1)^i(B-i)!$。

$\displaystyle=\sum_{i=0}^A\binom{A-1}{i-1}(-1)^i(B-i)!+\sum_{i=0}^A\binom{A-1}{i}(-1)^i(B-i)!$。

$\displaystyle=\sum_{i=-1}^{A-1}\binom{A-1}{i}(-1)^{i+1}(B-1-i)!+\sum_{i=0}^{A}\binom{A-1}{i}(-1)^i(B-i)!$。

考虑 $\displaystyle\binom{x}{x+1}=0,\binom{x}{-1}=0$，那么

$\displaystyle=\sum_{i=0}^{A-1}\binom{A-1}{i}(-1)^i(B-i)!-\sum_{i=0}^{A-1}\binom{A-1}{i}(-1)^i(B-1-i)!$

$\displaystyle=f(A-1,B)-f(A-1,B-1)$。

然后考虑另一种变换：

$\displaystyle f(A,B)=\sum_{i=0}^A\binom{A}{i}(-1)^i(B-1-i)!(B-i)$

$\displaystyle=B\times\sum_{i=0}^A\binom{A}{i}(-1)^i(B-1-i)!-\sum_{i=0}^Ai\times\binom{A}{i}(-1)^i(B-1-i)!$。

$\displaystyle=B\times f(A,B-1)-\sum_{i=0}^AA\times\binom{A-1}{i-1}(-1)^i(B-1-i)!$

$\displaystyle=B\times f(A,B-1)-A\times\sum_{i=-1}^{A-1}\binom{A-1}{i}(-1)^{i+1}(B-2-i)!$。

仍然有 $\displaystyle\binom{x}{-1}=0$。

$\displaystyle=B\times f(A,B-1)+A\times f(A-1,B-2)$。

即 $f(A,B)=f(A-1,B)-f(A-1,B-1)=B\times f(A,B-1)+A\times f(A-1,B-2)$。

变换一下，即 $f(A,B)+f(A+1,B+1)=f(A,B+1)$。

$(A+1)\times f(A,B)+(B+2)\times f(A+1,B+1)=f(A+1,B+2)$。

也就是说，若我们知道 $f(A,B)$ 与 $f(A+1,B+1)$，就可以 $O(1)$ 求出 $f(A,B+1)$ 与 $f(A+1,B+2)$。

为了方便实现，我们再做一次变换：

$f'(A,B)=f(A,A+B)$。

那么式子变为：

$f'(A-1,B)+f'(A,B)=f'(A-1,B+1)$。

$A\times f'(A-1,B)+(A+B+1)\times f'(A,B)=f'(A,B+1)$。

答案变为 $f'(n-2m,m)$。

初始化为 $V_1=f'(0,1)=f(0,1)=1,V_2=f'(1,1)=f(1,2)=1$。

即 $A=1,B=1,V_1=1,V_2=1$。

其中 $V_1=f'(A-1,B),V_2=f'(A,B)$。

考虑 $4$ 种转移。

* $A\rightarrow A+1$。

$V'_1=V_2$，$V'_2=f'(A+1,B)=f'(A,B+1)-f'(A,B)=A\times f'(A-1,B)+(A+B)\times f'(A,B)=A\times V_1+(A+B)\times V_2$。

* $A\rightarrow A-1$。

$\displaystyle V'_2=V_1,V'_1=f'(A-2,B)=\frac{f'(A-1,B+1)-(A+B)\times f'(A-1,B)}{A-1}$

$\displaystyle=\frac{V_1+V_2-(A+B)\times V_1}{A-1}=\frac{V_2-(A+B-1)\times V_1}{A-1}$。

* $B\rightarrow B+1$。

$V'_1=f'(A-1,B+1)=V_1+V_2,V'_2=A\times V_1+(A+B+1)\times V_2$。

* $B\rightarrow B-1$。

$V_2'=f'(A,B-1)$，将其代入一式有 $A\times f'(A-1,B-1)+A\times f'(A,B-1)=A\times f'(A-1,B)$，
代入二式有 $A\times f'(A-1,B-1)+(A+B)\times f'(A,B-1)=f'(A,B)$。

下式减上式为 $B\times f'(A,B-1)=f'(A,B)-A\times f'(A-1,B)$。

即 $\displaystyle V'_2=\frac{V_2-A\times V_1}{B}$，

$V'_1=f'(A-1,B-1)=f'(A-1,B)-f'(A,B-1)=V_1-V'_2$。

$O(1)$ 实现这 $4$ 种转移。然后询问按照所属块排序，离线下来做莫队就可以。复杂度 $O((n+q)\sqrt n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define MAXN 300005
#define mod 998244353

int Ans[MAXN] = {0},fac[MAXN] = {0},ifac[MAXN] = {0},inv[MAXN] = {0},rediff[MAXN] = {0},before[MAXN] = {0};
int T,cnt = 0,maxx = 0,sqn = 0;

struct query{ int x,y,id; }useful[MAXN];

inline bool cmp( query A , query B ){
	int b1 = ( A.y - 1 ) / sqn,b2 = ( B.y - 1 ) / sqn;
	if( b1 == b2 ){
		if( b1 & 1 ) return A.x > B.x;
		else return A.x < B.x;
	}
	else return b1 < b2;
} 

signed main(){
    ios::sync_with_stdio(0);
    cin >> T;
    inv[1] = 1; for( int i = 2 ; i <= MAXN - 5 ; i ++ ) inv[i] = ( mod - mod / i ) * inv[mod % i] % mod;
    ifac[0] = fac[0] = 1; for( int i = 1 ; i <= MAXN - 5 ; i ++ ) fac[i] = fac[i - 1] * i % mod,ifac[i] = ifac[i - 1] * inv[i] % mod;
    rediff[1] = 0,rediff[2] = 1; for( int i = 3 ; i <= MAXN - 5 ; i ++ ) rediff[i] = ( rediff[i - 1] + rediff[i - 2] ) % mod * ( i - 1 ) % mod;
    for( int i = 1 ; i <= T ; i ++ )
    {
        int n,m; cin >> n >> m;
        if( n >= 2 * m )
        {
        	if( n == 2 * m ) Ans[i] = fac[n - m],before[i] = fac[n - m];
        	else if( m == 0 ) Ans[i] = rediff[n],before[i] = 1;
        	else useful[++cnt] = query{ n - 2 * m , m , i },before[i] = fac[n - m] * ifac[n - 2 * m] % mod;
        	maxx = max( maxx , m );
        }
        else Ans[i] = 0;
    }
    int px = 1,py = 1,v1 = 1,v2 = 1; sqn = (int)sqrt( maxx );
    sort( useful + 1 , useful + cnt + 1 , cmp );
    for( int i = 1 ; i <= cnt ; i ++ ){
        int x = useful[i].x,y = useful[i].y,id = useful[i].id;
        while( py < y )
        {
        	int t1 = ( v1 + v2 ) % mod;
        	int t2 = ( px * v1 % mod + ( px + py + 1 ) * v2 % mod ) % mod;
        	v1 = t1,v2 = t2,py ++;
        }
        while( px < x )
        {
        	int t1 = v2;
        	int t2 = ( px * v1 % mod + ( px + py ) * v2 % mod ) % mod;
        	v1 = t1,v2 = t2,px ++;
        }
        while( py > y )
        {
        	int t2 = ( v2 + ( mod - v1 ) * px % mod ) % mod * inv[py] % mod;
        	int t1 = ( v1 - t2 + mod ) % mod;
        	v1 = t1,v2 = t2,py --;
        }
        while( px > x )
        {
        	int t1 = ( v2 + ( mod - v1 ) * ( px + py - 1 ) % mod ) % mod * inv[px - 1] % mod;
        	int t2 = v1;
        	v1 = t1,v2 = t2,px --;
        }
        Ans[id] = v2;
    }
    for( int i = 1 ; i <= T ; i ++ ) cout << Ans[i] * before[i] % mod << "\n";
    return 0;
}
```

---

## 作者：NaCly_Fish (赞：4)

[题目链接](https://www.luogu.com.cn/problem/P10103)

首先由于 $i\leq m$ 的位置都满足 $p_i>m$，这样必然就满足了错排的条件。

可以从后 $n-m$ 个较大的数中取 $m$ 个与前面互换，这样答案就是 $(n-m)^{\underline m}$ 乘以「从 $n-m$ 个选项的中选 $n-2m$ 个填到对应位置（像英语七选五那样），全错的方案数」再乘以 $m!$。最后乘的这个 $m!$ 是因为从前 $m$ 个位置取来的元素，在剩下的位置可以随意排列。
****

那么现在的问题就是计算这个「$n$ 选 $m$ 全错」的方案数，直接枚举至少选对了 $j$ 个做容斥，就得到方案数为

$$b_{n,m}=\frac{1}{(n-m)!}\sum_{j=0}^m\binom mj(-1)^j(n-j)!$$


设 $T(n,m)=(n-m)!b_{n,m}$，考虑其在 $m$ 这一维方向上的递推，可以算出
$$(n-m)T(n,m+1)=mT(n,m-1)-(1+2m-n)T(n,m)$$
你问这个递推式咋来的？我们把 $T(n,m)$ 的式子改写为

$$\begin{aligned}T(n,m) &=\sum_{j=0}^m \binom mj (-1)^j (n-m+(m-j))!  \\ &=m![x^m] \text e^{-x} \left( \sum_{j=0}^\infty \frac{(n-m+j)!}{j!}x^j\right)\end{aligned}$$
后面这个级数的 ODE 很容易从其递推式得出，这样就能得到 $T(n,m)$ 的横向递推。


回到原问题，由此可以设向量和方阵

$$\bold V_{n,m}=\begin{bmatrix} n^{\underline{m-1}}T(n,m-1) & n^{\underline m}T(n,m)\end{bmatrix}$$
$$\bold M_m(n)=\begin{bmatrix} 0 & m(n-m+1) \\1 & n-2m-1\end{bmatrix}$$
这样就可以写成矩阵转移：$\bold V_{n,m+1} = \bold V_{n,m} \times \bold M_m(n)$，即：
$$\bold V_{n,m}=\begin{bmatrix} n! & n!(n-1)\end{bmatrix} \times \prod_{i=1}^{m-1}\bold M_i(n)$$
这个是[经典问题](https://www.luogu.com.cn/blog/your-alpha1022/zu-ge-shuo-qian-zhui-hu-djq-fen-zhi)（人称 djq 分治），对于给定的多组 $n,m$ 快速计算这些矩阵的乘积即可。这个做法有一个优势，就是只用推导 $T(n,m)$ 横向的变化，而且时间复杂度更优秀。

时间复杂度 $\mathcal O (n \log^2 n)$。

---

## 作者：cainiaoshanglu (赞：3)

# P10103 题解
考场上直接推式子，大力出奇迹！

令 $f(i,j)$ 表示有一个 $i+j$个人组成的队伍要进行重新排列，其中有 $i$ 个人不能到自己原本的位置（下称“约束人”），剩余的 $j$ 个人可以到任意位置（下称“自由人”）。显然，原问题等价于求:
$$f(n-2m,m)m!C^m_{n-m}$$
因此只需要找到快速求出 $f$ 函数的方法即可。

考虑移除一个自由人，他可以呆在自己位置上不作贡献，也可以不呆在自己位置上，成为约束人，所以可以得到
$$f(i,j)=f(i,j-1)+f(i+1,j-1)$$
再考虑移除一个约束人：如果他前往一个自由人的位置，这不会对自由人有任何影响，否则就是传统的错排部分，因此又有递推式：
$$f(i,j)=jf(i-1,j)+(i-1)(f(i-1,j)+f(i-2,j))$$
我们发现通过第二个式子，我们可以快速求得每一行的值。而第一个式子长得很像组合数的行间递推，这说明其可以拓展成为类范德蒙德卷积的形式：
$$f(i,j)=\sum_{k=0}^d f(i+k,j-d)C_d^k$$
这启示我们预处理一些行，询问时通过上式求得单点值。设相邻的两个预处理行的距离为 $B$，总复杂度即为 $O(n^2/B+TB)$，注意到 $n$ 与 $T$ 同阶，取 $B=O(\sqrt n)$即可，复杂度为 $O((n+T)\sqrt n)$。

实现细节：求行的时候初值是 $f(0,j)=j!$ 和 $f(1,j)=j\times j!$。为了提高效率，可以将前 $B \times B$ 的组合数预处理出来，从而不需要每次从阶乘求出来。我个人取到 $B=450$ 就可以通过。

代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <cassert>
#define int long long
using namespace std;

const int md=998244353,B=450;
void read(int &x){
	x=0;
	int f=1;
	char c=getchar();
	while(!('0'<=c && c<='9')){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while('0'<=c && c<='9'){
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	x*=f;
}
int C[510][510];
int val[510][210010],t,n,m;
int fact[210010],invf[210010],inv[210010];
int getC(int n,int m){
	return n>=m?fact[n]*invf[n-m]%md*invf[m]%md:0;
}
signed main(){
	fact[0]=invf[0]=invf[1]=fact[1]=inv[1]=1;
	for(int i=2;i<=210000;i++){
		fact[i]=fact[i-1]*i%md;
		inv[i]=(md-md/i)*inv[md%i]%md;
		invf[i]=invf[i-1]*inv[i]%md;
	}
	for(int i=0;i<=B;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%md;
		}
	}
	for(int i=0;i<=B;i++){
		val[i][0]=fact[i*B];
		val[i][1]=i*B*fact[i*B]%md;
		for(int j=2;j<=210000;j++){
			val[i][j]=(i*B*val[i][j-1]+(j-1)*(val[i][j-1]+val[i][j-2]))%md;
		}
	}
	read(t);
	while(t--){
		read(n);
		read(m);
		if(n>=2*m){
			int sum=0;
			int lst=m/B,d=m%B;
			for(int i=0;i<=d;i++){
				sum=(sum+C[d][i]*val[lst][n-2*m+i])%md;
			}
			printf("%lld\n",sum*fact[m]%md*getC(n-m,m)%md);
		}else{
			printf("0\n");
		}
	} 
	return 0;
} 
```


---

## 作者：qczrz6v4nhp6u (赞：2)

### Solution

$2m>n$ 答案显然为 $0$，考虑 $2m\le n$ 的情况。

首先直接容斥可以得到答案即为：

$$f(n,m)=\sum_{i=0}^{n-m}(-1)^{i}{n-m\choose i}(n-m-i)^{\underline m}(n-m-i)!$$

即指定有 $i$ 个 $>m$ 的位置满足 $p_i=i$，然后将 $\le m$ 的位置填上 $>m$ 的数，剩下的数再任意放的方案数。

简单的化简得到

$$f(n,m)=\frac{(n-m)!}{(n-2m)!}\sum_{i=0}^{n-2m}(-1)^i{n-2m\choose i}(n-m-i)!$$

设 $g(n,m)$ 表示限制了 $m$ 个位置必须错位的错排，也即

$$g(n,m)=\sum_{i=0}^{m}(-1)^i{m\choose i}(n-i)!$$

则

$$f(n,m)=\frac{(n-m)!}{(n-2m)!}g(n-m,n-2m)$$

问题转化为求 $g(n,m)$。

尝试观察 $g(n,m)$ 有哪些性质。打表或简单的组合数推导可以发现

$$g(n,m)=g(n,m-1)-g(n-1,m-1)$$

这就是说每一行的差分等于上一行的相反数。

于是可以得到一个简单的 $O(n\sqrt{q\log n})$ 做法：对行分块，设块长为 $B$。每 $B$ 行就 NTT 算出一整行的 $g(n,m)$，查询的时候找到其下面的第一行，组合数算一下贡献系数即可。复杂度 $O(\frac{n^2\log n}{B}+qB)$，取 $B=n\sqrt\frac{\log n}{q}$ 可得最优复杂度 $O(n\sqrt{q\log n})$。

尝试优化。不难发现瓶颈在于预处理的 NTT，由于卷积的两个多项式已知且其微分有限，我们尝试找出它在 $n$ 不变或者 $m$ 不变时的递推式。但是这部分似乎比较困难（至少我不会做），考虑尝试一些歪门邪道。

进行更深入的打表可以发现有：

$$g(n,m)=n\times g(n-1,m)+m\times g(n-2,m-1)$$

等号右侧的两项在一条对角线上，注意到第一个递推实际上也能对对角线做（$g(n,m)=g(n-1,m)+g(n,m+1)$），我们可以应用第一个递推式把 $g(n,m)$ 也搞到对应的对角线上。那么有：

$$g(n,m)=(n-1)\times g(n-1,m-1)+(m-1)\times g(n-2,m-2)$$

于是对角线的部分就可以快速算了，复杂度变为 $O(n\sqrt q)$。

关于是怎么注意到后面的递推式的：手玩 $m=1$ 的情况（此时 $g(n,m)=n!-(n-1)!$），随机代换一下再用后面的项修正即可。

~~其实如果你最开始将 $g$ 的定义设为 $m$ 个位置没限制的错排的话会发现显然很多。~~

### Code

```cpp
bool Mst;
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=2e5+5,B=447,mod=998244353;
inline ll add(ll x,ll y){return (x+=y)>=mod&&(x-=mod),x;}
inline ll Add(ll &x,ll y){return x=add(x,y);}
inline ll sub(ll x,ll y){return (x-=y)<0&&(x+=mod),x;}
inline ll Sub(ll &x,ll y){return x=sub(x,y);}
inline ll qpow(ll a,ll b){
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)res=res*a%mod;
	return res;
}
int q;ll fac[N],ifac[N];
void init(int n){
	fac[0]=1;
	for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
	ifac[n]=qpow(fac[n],mod-2);
	for(int i=n;i>=1;i--)ifac[i-1]=ifac[i]*i%mod;
}
vector<pii> qry[N];
ll ans[N],F[N];
void work(int n){
	int lst=-1;
	for(int i=0;i<=n;i++){
		if(i%B==0){
			F[0]=fac[i],F[1]=sub(fac[i+1],fac[i]);
			for(int j=2;j<=n-i;j++)
				F[j]=((i+j-1)*F[j-1]+(j-1)*F[j-2])%mod;
			lst=i;
		}
		int k=i-lst;
		for(const auto &o:qry[i]){
			ll res=0;int del=o.fi-i;
			for(int j=0;j<=k;j++)
				res=(res+F[j+del]*ifac[j]%mod*ifac[k-j])%mod;
			ans[o.se]=res*fac[k]%mod*fac[o.fi]%mod*ifac[del]%mod;
		}
	}
}
bool Med;
int main(){
	cerr<<abs(&Mst-&Med)/1048576.0<<endl;
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	init(2e5);
	cin>>q;
	for(int i=1;i<=q;i++){
		int u,v;cin>>u>>v;
		if((v<<1)<=u)
			qry[v].emplace_back(make_pair(u-v,i));
	}
	work(2e5);
	for(int i=1;i<=q;i++)
		cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Anoshag_Ruwan (赞：2)

怎么我做计数题都是先想出一个很笨的组合意义，后面全靠推式子啊，活该已经退役。

首先，当 $n-m<m$ 时答案显然为 $0$，而 $m=0$ 时答案为正常错排数，其 EGF 为 $\frac{e^{-x}}{1-x}$ 可以 $O(n)$ 对阶乘倒数做交错前缀和求得，这是不难的。

然后考虑大力做本题，首先钦定 $[1,m]$ 的位置与 $[m+1,n]$ 中的 $m$ 个点匹配，这部分贡献是 $\tbinom{n-m}{m}m!$。然后令 $f_{n,m}$ 表示两个大小为 $n$，交集大小为 $n-m$ 的集合的合法匹配（错排）数。可以枚举非交集元素与交集元素匹配的个数 $k$，将一个集合的非交集匹配完成后，剩下两个集合的就有长为 $k$ 的非交集。等式为 $f_{n,m}=m!\sum\limits_{k \leq m}\tbinom{n-m}{k}\tbinom{m}{k}f_{n-m,k}$，其中 $f_{n,0}=[x^n]\frac{e^{-x}}{1-x}$。思考组合意义部分结束。

令 $g_{n,m}=\tbinom{n}{m}f_{n,m}$，上式转为 $g_{n,m}=\frac{n!}{(n-m)!}\sum\limits_{k \geq 0}\tbinom{m}{k}g_{n-m,k}$，根据 $ng_{n-1,n-1}=g_{n,n},ng_{n-1,m-1}=\frac{n!}{(n-m)!}\sum\limits_{k \geq 0}\tbinom{m-1}{k}g_{n-m,k}=g_{n,m}-\frac{n!}{(n-m)!}\sum\limits_{k \geq 1}\tbinom{m-1}{k-1}g_{n-m,k}$，数学归纳得 $g_{n,m}=n(g_{n-1,m-1}+g_{n-1,m})(m>0)$。

对于常数项（错排数）我们有 $g_{n,0}=ng_{n-1,0}+(-1)^n$，把 $g_{n,m}$ 的每一行写成生成函数 $G_n(x)$，则有 $G_n(x)=n(1+x)G_{n-1}(x)+(-1)^n$。

将上式迭代展开，$G_n(x)=\sum\limits_{k \leq n}(-1)^{n-k}(1+x)^k\frac{n!}{(n-k)!}$，对于每一项而言有 $g_{n,m}=\sum\limits_{k \geq 0}(-1)^{n-k}\frac{n!}{(n-k)!}\tbinom{k}{m}$，卷积，得出 $g_{n,m}$ 每一列的指数型生成函数 $ġ_m(x)=\frac{x^me^{-x}}{(1-x)^{m+1}}$。

对 $ġ_m(x)$ 求导，则有 $ġ_m'(x)=\frac{(mx^{m-1}-x^m)e^{-x}}{(1-x)^{m+1}}+\frac{(m+1)e^{-x}x^m}{(1+x)^{m+2}}=\frac{m-x}{x}ġ_m(x)+\frac{1}{x}ġ_{m+1}(x)$，由于是 EGF，所以 $[x^n]ġ_m(x)=\frac{g_{n,m}}{n!}$，得到方程 

$(n-m+1){g_{n+1,m}}=(m+1)g_{n+1,m+1}-(n+1)g_{n,m}$。

现在虽然依旧不能快速求出每一项的通项，也无法已知当前项求相邻一项，但我们得到了两个在这张表任意 $2 \times 2$ 相邻区域内四个未知量的线性无关方程。通过线性组合，如果知道其中两个，就可以推出另外两个，比如已知 $g_{n,m},g_{n,m+1}$，则 $g_{n+1,m+1}=(n+1)(g_{n,m}+g_{n,m+1}),g_{n+1,m}=\frac{n+1}{n-m+1}((m+1)g_{n,m+1}+mg_{n,m})$，也可以变换转移顺序使其更简便。当然求出 $g_{n,m+2},g_{n,m-1}$ 也不难。于是可以使用莫队移动，若当前在 $(n,m)$ 位置 $(1 \leq m \leq n)$，则维护两个指针 $g_{n,m-1},g_{n,m}$ 即可，答案不要忘记乘上 $m!$，时间复杂度 $O(n\sqrt{t})$。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define LL long long
using namespace std;
const int N=1e6+11,p=998244353;
struct qw{LL l,r,num;}q[N];
LL frc[N<<1],inv[N<<1],cnt1,cnt2,c[N<<1],iv[N<<1],d[N<<1],fk[N<<1],q1,q2;
inline LL add(LL x,LL y){return x+y>=p?x+y-p:x+y;}
inline bool mo(qw x,qw y){return (x.r<0)?(x.r<y.r):(fk[x.l]==fk[y.l]?x.r<y.r:x.l<y.l);}
inline void add1(LL x,LL y,bool m){
	if(m){q2=add(q1,q2)*x%p;q1=add(q2*y%p,p-q1*x%p)*iv[x-y+1]%p;}
	else {q2=add(add(y*q1%p,(y+1)*q2%p)*iv[x-y+1]%p,p-q1);swap(q1,q2);}}
inline void del(LL x,LL y,bool m){
	if(m)q1=add(q2*y%p,p-q1*(x-y+1)%p)*iv[x]%p,q2=add(q2*iv[x]%p,p-q1);
	else {q1=add(q1,q2)*(x-y+1)%p,q1=add(q1,p-y*q2%p)*iv[y+1]%p;swap(q1,q2);}
	if(m)x--;else y++;
}
inline LL rd(){
	LL i=0,j=1;char g=getchar();
	while(g>57||g<48){if(g=='-')j=-1;g=getchar();}
	while(g>47&&g<58)i=(i<<3)+(i<<1)+g-48,g=getchar();
	return i*j; 
}
inline LL ksm(LL x,LL y){
	LL k=1,l=x;
	while(y){if(y&1)k=k*l%p;l=l*l%p,y>>=1;}
	return k;
}
int main()
{
	LL i,j,k,m,n=2e5,lpt,u,v,rpt,sq=sqrt(n),t=rd();
	for(i=frc[0]=iv[0]=1;i<=n;i++)frc[i]=frc[i-1]*i%p,fk[i]=(i-1)/sq+1;
	for(i=n,inv[n]=ksm(frc[n],p-2);i;i--)
		inv[i-1]=inv[i]*i%p,iv[i]=frc[i-1]*inv[i]%p,c[i]=inv[i];
	for(i=1,c[0]=1;i<=n;i+=2)c[i]=p-c[i];
	for(i=1;i<=n;i++)c[i]=add(c[i-1],c[i]);for(i=1;i<=n;i++)c[i]=c[i]*frc[i]%p;
	for(i=1;i<=t;i++)u=rd(),v=rd(),q[i]=(qw){v,u-v,i};
	sort(q+1,q+t+1,mo);
	for(i=1,lpt=q1=1,rpt=q2=0;i<=t;i++){
		if(q[i].l>q[i].r){d[q[i].num]=0;continue;}
		if(q[i].l==0){d[q[i].num]=c[q[i].r];continue;}
		while(rpt<q[i].r)add1(++rpt,lpt,1);
		while(lpt>q[i].l)add1(rpt,--lpt,0);
		while(rpt>q[i].r)del(rpt--,lpt,1);
		while(lpt<q[i].l)del(rpt,lpt++,0);
		d[q[i].num]=q2*frc[q[i].l]%p;
	}for(i=1;i<=t;i++)printf("%lld\n",d[i]);
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10103)

**题目大意**

> $q$ 组询问给定 $n,m$，求有多少 $n$ 阶排列 $p$ 满足 $p_1\sim p_m>m$ 且所有 $p_i\ne i$。
>
> 数据范围：$n,m,q\le 2\times 10^5$。

**思路分析**

先在 $m+1\sim n$ 中选出 $m$ 个放到 $p_1\sim p_m$ 上，变成一个子问题：剩下 $n-m$ 个位置，$n-2m$ 个元素不能放在自己对应的位置上，$m$ 个元素没有任何限制。

因此可以设计状态 dp：$f_{n,m}$ 表示 $n$ 个不能放在自己对应位置上的元素，$m$ 个无位置限制的元素，排列的方案数。

考虑分别消去一个有限制的元素和一个无限制的元素，根据组合意义处理。

先考虑一个无限制的元素如何填：

- 如果填在自己对应的位置上，那么转移到 $f_{n,m-1}$。
- 否则相当于这个元素被钦定了“不能放在自己位置上”的限制，变成一个有限制的元素，转移到 $f_{n+1,m-1}$。

因此 $f_{n,m}=f_{n,m-1}+f_{n+1,m-1}$，类似杨辉三角的递推，考虑 $f_{n',m-k}\to f_{n,m}$ 的转移系数，我们得到：
$$
f_{n,m}=\sum_{i=0}^k \binom kif_{n+i,m-k}
$$
然后考虑一个有限制的元素如何填：

- 填在一个无限制元素对应的位置上，那么这个无限制元素依然可以任意填，转移到 $m\times f_{n-1,m}$。
- 填在一个有限制元素对应的位置上，变成经典错排，考虑这个元素是否和当前元素互换位置，转移到 $(n-1)(f_{n-1,m}+f_{n-2,m})$。

因此 $f_{n,m}=(m+n-1)f_{n-1,m}+(n-1)f_{n-2,m}$。

那么考虑对 $m$ 分块回答询问，取块长为 $B$，对于 $m=kB$，用第二个递推式，求出整行的 $f_{0,m}\sim f_{n,m}$。

然后对于一个 $m=kB+r$ 其中 $r\in[0,B)$ 的询问，用第一个递推式 $\mathcal O(r)$ 计算答案。

时间复杂度 $\mathcal O\left(qB+\dfrac{V^2}B\right)$，取 $B=\dfrac{V}{\sqrt q}$ 时最优。

时间复杂度 $\mathcal O(V\sqrt q)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace FastMod {
typedef unsigned long long ull;
typedef __uint128_t uLL;
ull b,m;
inline void init(ull B) { b=B,m=ull((uLL(1)<<64)/B); }
inline ull mod(ull a) {
	ull q=((uLL(m)*a)>>64),r=a-q*b;
	return r>=b?r-b:r;
}
};
#define o FastMod::mod
const int MAXN=2e5+5,B=450,MOD=998244353,N=2e5;
ll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=o(a*a),b>>=1) if(b&1) s=o(s*a); return s; }
ll fac[MAXN],ifac[MAXN],f[MAXN],C[B+5][B+5],ans[MAXN];
vector <array<int,3>> Q[MAXN];
signed main() {
	FastMod::init(MOD);
	for(int i=fac[0]=ifac[0]=1;i<=N;++i) ifac[i]=ksm(fac[i]=o(fac[i-1]*i));
	int q; scanf("%d",&q);
	for(int i=1,n,m;i<=q;++i) {
		scanf("%d%d",&n,&m);
		if(n-m<m) ans[i]=0;
		else ans[i]=o(fac[n-m]*ifac[n-2*m]),Q[m/B].push_back({n-2*m,m,i});
	}
	for(int i=0;i<=B;++i) for(int j=C[i][0]=1;j<=i;++j) C[i][j]=o(C[i-1][j]+C[i-1][j-1]);
	for(int x=0;x*B<=N;++x) if(Q[x].size()) {
		int M=x*B;
		f[0]=fac[M],f[1]=o(M*fac[M]);
		for(int n=2;n<=N;++n) f[n]=o((n+M-1)*f[n-1]+(n-1)*f[n-2]);
		for(auto z:Q[x]) {
			int n=z[0],m=z[1],k=m-M; ll s=0;
			for(int i=0;i<=k;++i) s=o(s+f[n+i]*C[k][i]);
			ans[z[2]]=o(ans[z[2]]*s)%MOD;
		}
	}
	for(int i=1;i<=q;++i) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：_lbw_ (赞：1)

题解区理论复杂度最慢做法。

类似于原错排问题,对后 $n-m$ 个数进行容斥,答案即为:

$$m!\dbinom{n-m}{m}\sum\limits_{i=0}^{n-2m}(-1)^i\dbinom{n-2m}{i}(n-m-i)!$$

你发现自己已经得到了 40 分的高分！！！！！！

然后我们考虑 $n,m\leq 5\times 10^3$ 怎么做。

考虑对 $f_{n,m}=g_{m,N=n-2m}=\sum\limits_{i=0}^{N}(-1)^i\dbinom{N}{i}(N+m-i)!$ 打表，容易发现有 $g_{i,j}=g_{i-1,j-1}+g_{i-1,j}$。

如何计算 $g$？设 $g$ 第 $i$ 的生成函数为 $G_i(x)$，原式即为 $G_i=(1+x^{-1})G_{i-1}$,$G_0$ 即为原错排函数，是容易的。

我们发现已经会了所有部分分,对于 $T$ 小和 $n,m$ 小的情况都得到解决。

于是考虑根号分治,先用卷积求出所有 $G_{i+kB}$，然后对于每组询问找出前面的离它最近的 $G$，这个位置的答案可以用 $\mathcal{O}(B)$ 个 $G$ 乘上组合数表示。

时间复杂度 $\mathcal{O}(\dfrac{n^2\log n}B+qB\geq n\sqrt{q\log n})$。

实现与题解稍有不同。

upd: 容易发现错排是 D-Finite 的，于是错排乘上 $(1+x)^k$ 也 D-Finite，于是每一行都可以线性求，不需要卷积，时间复杂度 $\mathcal{O}(n\sqrt{q})$。

```cpp
#undef ll
#include "assert.h"
const int MAX = 2e5;
mt19937_64 rnd(her1);
using i64 = long long;
const int maxn = 5e6+5;
i64 qpow(i64 n,i64 base=cht-2){
	i64 ans=1;
	while(base){
		if(base&1)ans=ans*n%cht;
		n=n*n%cht;base>>=1;
	}
	return ans;
}
const i64 V = 2.7e3;
const i64 invG = qpow(G);
i64 fac[maxn],ifac[maxn],rev[maxn];
IV cadd(i64&x,i64 val){x=(x+val)%cht;}
i64 n,m,f[maxn],g[maxn],tot,Mul[maxn],ans[maxn],now;
IV init(){
	fac[0]=1;F(i,1,MAX)fac[i]=fac[i-1]*i%cht;
	g[0]=1;g[1]=0;F(i,2,MAX)g[i]=(g[i-1]+g[i-2])*(i-1)%cht;
	ifac[MAX]=qpow(fac[MAX]);D(i,MAX-1,0)ifac[i]=ifac[i+1]*(i+1)%cht;
}
i64 C(i64 n,i64 m){
	if(n<m||n<0||m<0)return 0;
	return fac[n]*ifac[m]%cht*ifac[n-m]%cht;
}
IV NTT(i64*a,i64 limit,bool type){
	i64 sb=__lg(limit);
	F(i,0,limit-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<sb-1);
	F(i,0,limit-1)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int p=2;p<=limit;p<<=1){
		i64 k=p>>1,wG=qpow(type?invG:G,(cht-1)/p);
		for(i64 l=0,w=1;l<limit;l+=p,w=1)
			F(i,l,l+k-1){
				i64 x=a[i],y=a[i+k]*w%cht;
				a[i]=(x+y)%cht;a[i+k]=(x-y+cht)%cht;
				w=w*wG%cht;
			}
	}
	if(type){
		i64 inv=qpow(limit);
		F(i,0,limit-1)a[i]=a[i]*inv%cht;
	}
}
struct node{i64 M,p,id;}qwq[maxn];
IV add(i64 k){
	i64 limit=1;
	while(limit<=k+MAX-2*now)limit<<=1;
	F(i,0,limit-1)f[i]=0;
	F(i,0,k)f[i]=C(k,i);

	NTT(f,limit,0);NTT(g,limit,0);
	F(i,0,limit-1)g[i]=g[i]*f[i]%cht;
	NTT(g,limit,1);
	
	now+=k;
	F(i,0,MAX-2*now)g[i]=g[i+k];
	F(i,MAX+1-2*now,limit)g[i]=0;
}
const i64 out_L = 10;
IV print(){
	F(i,0,out_L)cout<<g[i]<<' ';puts("");
}
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	init();i64 Q=read();	
	F(i,1,Q){
		i64 n=read(),m=read();
		if(n>=2*m)qwq[++tot]={m,n-2*m,i},Mul[i]=C(n-m,m)*fac[m]%cht;
	}
	sort(qwq+1,qwq+1+tot,[](node A,node B){
		return A.M<B.M;
	});
	F(i,1,tot){
		if(qwq[i].M-now>V)add(qwq[i].M-now);i64 D=qwq[i].M-now;
		F(j,0,D)cadd(ans[qwq[i].id],g[qwq[i].p+j]*C(D,j));
	}
	F(i,1,Q)printf("%lld\n",ans[i]*Mul[i]%cht);
	return 0;
}
```


---


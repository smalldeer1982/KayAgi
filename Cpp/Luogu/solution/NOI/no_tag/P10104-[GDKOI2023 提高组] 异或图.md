# [GDKOI2023 提高组] 异或图

## 题目描述

给定一张 $n$ 个点 $m$ 条边的无向图和一个长度为 $n$ 的数组 $a_1, a_2, \cdots , a_n$ 以及一个整数 $C$，你需要求出有多少个长度为 $n$ 的数组 $b$ 满足：

1. $0 ≤ b_i ≤ a_i,\forall 1 ≤ i ≤ n$。
2. 对于每条边 $(u, v)$，$b_u \ne b_v$。
3. $b_1 ⊕ b_2 ⊕ \cdots  ⊕ b_n = C$，其中 $\oplus$ 代表异或。

答案对 $998244353$ 取模。


## 说明/提示

可行的 $b$ 数组有 $(0, 1, 3),(0, 2, 0),(1, 0, 3),(1, 2, 1)$ 四种。

对于所有数据，满足 $1 ≤ n ≤ 15$，$ 0 ≤ m ≤ \frac{n(n−1)}{2}$，$ 0 ≤ a_i, C ≤ 10^{18}$。

- Subtask 1 (20pts)：$n ≤ 5$，$ 0 ≤ a_i, C ≤ 15$。
- Subtask 2 (50pts)：$n ≤ 13$。
- Subtask 3 (10pts)：$m = 0$。
- Subtask 4 (20pts)：无特殊限制。


## 样例 #1

### 输入

```
3 1 2
1 2 3
1 2
```

### 输出

```
4```

## 样例 #2

### 输入

```
4 6 2
7 11 14 0
1 2
1 3
2 3
2 4
4 1
4 3```

### 输出

```
44```

# 题解

## 作者：DaiRuiChen007 (赞：7)

# P10104 题解

[Problem Link](https://www.luogu.com.cn/problem/P10104)

**题目大意**

> 给定 $a_1\sim a_n,C$，以及一张 $n$ 个点 $m$ 条边的无向图 $G$，求有多少 $b_1\sim b_n$ 满足：
>
> - $\forall i\in[1,n]$，满足 $b_i\in[0,a_i]$
> - $\forall (u,v)\in G$，满足 $b_u\ne b_v$。
> - $\oplus_{i=1}^n b_i=C$。
>
> 数据范围：$n\le 15$。

**思路分析**

先考虑 $m=0$ 的情况，容易发现我们只要找到第一个存在一个自由元的位 $d$，那么 $<d$ 的位都可以随便填。

枚举 $d$，然后 dp 求出当前这一位有至少一个自由元，且异或和满足条件的方案数。

时间复杂度 $\mathcal O(n\log V)$。

那么最朴素的想法就是 $\mathcal O(2^m)$ 枚举一些边相等，那么我们只保留每个奇数大小的连通块里最小的 $a_i$。

很显然我们只关心最终的连通块划分情况，因此可以 $\mathcal O(3^n)$ 预处理出 $f_S$ 表示点集为 $S$ 时每个连通块的容斥系数 $(-1)^{|E|}$ 之和。

可以直接状压哪些点被选，哪些点是关键点，暴力 dp 时间复杂度 $\mathcal O(4^n)$。

考虑进一步压缩状态，我们按 $a_i$ 排序，每次取出 $a_u$ 最小的未被加入的 $u$，然后枚举 $u$ 所在的连通块，此时 $<a_u$ 的全部被加入，只要维护他们是不是关键点，同理 $>a_u$ 的全部不是关键点，只要维护他们是否被选入连通块。

那么状态数为 $\mathcal O(2^n)$，转移复杂度为 $\mathcal O(n3^n)$。

时间复杂度 $\mathcal O((m+n\log V)2^n+n3^n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=998244353;
void add(ll &x,ll y) { x=(x+y)%MOD; }
ll calc(vector<ll>a) {
	ll ans=0;
	for(int d=60;~d;--d) {
		ll hi=0;
		for(ll i:a) hi^=i>>(d+1);
		if(hi) break;
		array<array<ll,2>,2> f{1,0,0,0},g{0,0,0,0}; //xor free
		for(ll i:a) {
			g={0,0,0,0};
			for(int x:{0,1}) for(int y:{0,1}) if(f[x][y]) {
				ll lo=((i&((1ll<<d)-1))+1)%MOD;
				if(~(i>>d)&1) add(g[x][y],f[x][y]*lo);
				else {
					if(y) add(g[x][1],(1ll<<d)%MOD*f[x][y]);
					else add(g[x][1],f[x][y]);
					add(g[x^1][y],f[x][y]*lo);
				}
			}
			f=g;
		}
		add(ans,f[0][1]);
	}
	ll hi=0;
	for(ll i:a) hi^=i;
	if(!hi) ++ans;
	return ans;
}
int n,m,ord[15],id[15],ec[1<<15];
ll C,a[15],cf[1<<15],cg[1<<15],dp[1<<15],tmp[1<<15];
ll solve(vector<ll>vi) {
	if(!C) return calc(vi);
	vi.push_back(C);
	ll ans=calc(vi);
	--vi.back();
	return (ans+MOD-calc(vi))%MOD;
}
signed main() {
	scanf("%d%d%lld",&n,&m,&C);
	for(int i=0;i<n;++i) scanf("%lld",&a[i]);
	iota(ord,ord+n,0),sort(ord,ord+n,[&](int x,int y){ return a[x]<a[y]; }),sort(a,a+n);
	for(int i=0;i<n;++i) id[ord[i]]=i;
	for(int i=0,u,v;i<m;++i) {
		scanf("%d%d",&u,&v),u=id[u-1],v=id[v-1];
		ll x=(1<<u)|(1<<v);
		for(int s=0;s<(1<<n);++s) if((s&x)==x) ++ec[s];
	}
	for(int s=0;s<(1<<n);++s) cg[s]=!ec[s];
	for(int s=0;s<(1<<n);++s) {
		cf[s]=cg[s];
		int lb=s&-s;
		for(int t=(s-1)&s;t;t=(t-1)&s) if(t&lb) {
			cf[s]=(cf[s]+MOD-cf[t]*cg[s^t])%MOD;
		}
	}
	dp[0]=1;
	for(int i=0;i<n;++i) {
		//<i: is key?, >=i in queue?
		memset(tmp,0,sizeof(tmp));
		for(int s=0;s<(1<<n);++s) if(dp[s]) {
			if(s&(1<<i)) { add(tmp[s^(1<<i)],dp[s]); continue; }
			int rem=(s^((1<<n)-1))&(~((1<<(i+1))-1));
			for(int t=rem;;t=(t-1)&rem) {
				int u=t|(1<<i);
				if(__builtin_popcount(u)&1) add(tmp[s|u],dp[s]*cf[u]);
				else add(tmp[s|t],(a[i]+1)%MOD*dp[s]%MOD*cf[u]);
				if(!t) break;
			}
		}
		swap(tmp,dp);
	}
	ll ans=0;
	for(int s=0;s<(1<<n);++s) {
		vector <ll> vi;
		for(int i=0;i<n;++i) if(s&(1<<i)) vi.push_back(a[i]);
		add(ans,dp[s]*solve(vi));
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：6)

考虑 $m=0$ 怎么做，即没有某些不等的限制。

问题为：给定 $n$ 个数的数列 $\lbrace a_i\rbrace$，计数 $b$ 的数量使得：

- $0\leq b_i\leq a_i$。
- $\bigoplus_{i=1}^nb_i=C$。

先给出结论，这个子问题的时间复杂度是 $O(n\log V)$。$V=10^{18}$ 是值域。

有异或和 $=C$ 的很难处理。注意到 $C$ 为某个值与 $C=0$ 并无本质区别，直接转化成异或和为 $0$。考虑钦定 $a_{n+1}=C$，计算此时**异或和为 $0$** 的方案数 $A$，再令 $a_{n+1}=C-1$，方案数为 $B$，那么显然前 $n$ 个数异或和为 $C$ 的方案数为 $A-B$。

考虑异或和 $=0$ 怎么做。对于一种特殊情况：$a_1>\max_{i=2}^n a_i$ 时，可以让 $a_{2\sim n}$ 任意取，此时无论如何在更低位都可以找到一个 $a_1$ 满足值的限制，使得异或和 $=0$，这种情况的方案数为 $\prod_{i=2}^n (a_i+1)$。

从这个方向进一步考虑，不妨设比第 $d$ 位高的部分的异或和为 $0$，那么考虑最低 $d$ 位能用以上方式调整的条件，让这个调整的位置是 $i$，那么要求 $b_i$ 与 $a_i$ 的比 $d$ 位高的部分并不完全重合，那么就要求 $b_i\leq a_i-2^{d+1}$。

枚举 $d=\log V\to 0$。只考虑 $d$ 以及 $d$ 位以下的低位。设计 $\text{dp}$ 为：$f_{i,0/1,0/1}$ 表示前 $i$ 个数，是否有位置作为自由元，第 $d$ 位的异或和为 $0/1$ 的贡献积。转移是容易的。

这样可以在 $O(n\log V)$ 的时间解决这个子问题。



------------


考虑原问题怎么做，不难想到容斥。

显然有一个对于边集 $S$，钦定 $S$ 的边都不满足两端互不相等的做法，这样的复杂度是 $O(2^mn\log V)$，不能接受。

注意到上述做法的细节：关注 $S$ 中的边构成的连通块，进一步地，大小为奇数的连通块只关注最小的 $a_i$，大小为偶数的连通块直接乘上 $(\min(a_i)+1)$。

所以我们可以简化成，连通块被划分成什么样子。

考虑重新分配涉及的边集的容斥系数。$(-1)^{|E|}$ 显然可以拆到每个连通块上求 $(-1)^{|E'|}$ 的积。对于每个连通块，容斥系数即为：导出子图边集中所有使得此点集的连通的边集的，$(-1)^{|E'|}$ 之和。可以 $O(3^nn)$ 预处理这个，记录为 $g_S$，具体就是钦定一个部分与剩下的部分不连通，进行枚举子集。

直接枚举点集划分是 $O(\text{Bell}(n)n\log V)$ 的，大概能过 $n\leq 13$。



------------


事实上点集划分会导出，对于所有的 $\min(a_i)$ 且连通块为奇数的序列 $c$，去跑最开始写的那个东西。不同的点集划分可能导出相同的 $c$，这样非常浪费，加一个哈希表本质上无法优化复杂度。

考虑枚举这个序列 $c$，难点在于求它的容斥系数 $coef_c$。

注意到 $\min(a)$ 可以直接对于所有点按照 $a$ 排序，然后按序从 $i=1\to n$ 进行连通块划分。$\text{dp}$ 当前已经划分的点集的 $coef_S$。每次枚举到 $i$ 时，$1\sim i-1$ 必然已经划分完毕，对后面造成贡献的只有 $i$。枚举 $i$ 的连通块 $T\subseteq\lbrace i,i+1,i+2,\cdots,n\rbrace$，$i\in T$，直接更新 $coef$ 即可。

时间复杂度 $O(3^nn+2^nn\log V)$。

[提交记录。](https://loj.ac/s/2082803)

---

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P10104)

本题属于集合划分容斥，更多关于集合划分容斥的信息可观看[ 详细揭秘：集合划分容斥的容斥系数](https://www.luogu.com.cn/article/ov7ptv00)。
## 题意
给定一个 $n$ 个点 $m$ 条边的图以及一个长为 $n$ 的序列 $a_{1\dots n}$，有一常数 $C$，你需要求出有多少序列 $b_{1\dots n}$ 满足 $0\le b_i\le a_i$，$\forall (u,v)\in E,b_u\ne b_v$，$\text{xor}_{i=1}^nb_i=C$。

$n\le 15$。
## 思路
考虑 $m=0$ 怎么做，从高至低枚举第一个不全顶到上界的位 $d$，则低 $d-1$ 位只需要一个在第 $d$ 位不顶到上界的数进行调整，其余数任选即可。

令等价类为相等的数的集合，则令集合幂级数 $[x^S]F(x)$ 等于 $1$ 当且仅当 $S$ 内点在图上为独立集。容斥系数 $H(x)=\ln (F(x)+1)$ 可以直接求出。

考虑一个状态的答案，我们只关注每个等价类内部的最小值。每个大小为偶数的等价类均可随便取，大小为奇数的等价类的最小值（称为关键点）构成 $m=0$ 的子问题。

设 $f_{S,T}$ 表示当前已经考虑了 $S$ 内的点，其中关键点的集合为 $T$ 的方案数，时间复杂度为 $O(4^n)$。

此时记录了大量无用信息，我们将 $a$ 从小到大排序，逐个尝试加入关键点。设当前加入到 $i$，则 $[1,i)$ 的点已经必然在考虑的点集中，只需要记录它们是否在关键点集中；$[i,n]$ 的点必然不在当前关键点集中，只需要记录它们是否在已考虑点集中。这样状态数就减小至 $2^n$，再加上枚举子集，时间复杂度为 $O(3^nn+2^n(m+n\log V))$。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int S=1<<15,N=15+2,M=N*N,mod=998244353;
namespace Init{
    inline int add(int x,int y){
        return x+y>=mod?x+y-mod:x+y;
    }
    inline int dec(int x,int y){
        return x>=y?x-y:x-y+mod;
    }
	int pc[S],inv[N],fac[N];
	inline void Prefix(int n){
		int m=__lg(n);
		for(int i=0;i<n;i++)
			pc[i]=pc[i/2]+(i&1);
		inv[1]=1;
		for(int i=2;i<=m;i++)
			inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		fac[0]=1;
		for(int i=1;i<=m;i++)
			fac[i]=1ll*fac[i-1]*i%mod;
	}
}
using namespace Init;
namespace Poly{
	int n,m;
	inline void init(int N){
		n=N,m=__lg(n);
	}
	inline void FWT(int *c){
		for(int i=0;i<m;i++)
			for(int j=0;j<n;j++)
                if(j>>i&1)
                    c[j]=add(c[j],c[j^(1<<i)]);
	}
	inline void IFWT(int *c){
		for(int i=0;i<m;i++)
			for(int j=n-1;j>=0;j--)
                if(j>>i&1)
                    c[j]=dec(c[j],c[j^(1<<i)]);
	}
	int F[N][S],G[N][S],H[N][S];
	inline void mul(int *a,int *b,int *c){
		for(int i=0;i<m;i++)
			for(int j=0;j<n;j++)
				F[i][j]=G[i][j]=H[i][j]=0;
		for(int i=0;i<n;i++)
			F[pc[i]][i]=a[i],G[pc[i]][i]=b[i];
		for(int i=0;i<=m;i++)
			FWT(F[i]),FWT(G[i]);
		for(int k=0;k<=m;k++){ 
			for(int i=0;i<=k;i++)
				for(int j=0;j<n;j++)
					H[k][j]=(H[k][j]+1ll*F[i][j]*G[k-i][j])%mod;
			IFWT(H[k]);
		}
		for(int i=0;i<n;i++)
			c[i]=H[pc[i]][i];
	}
	inline void ln(int *a,int *b){
		for(int i=0;i<m;i++)
			for(int j=0;j<n;j++)
				F[i][j]=G[i][j]=0;
		for(int i=0;i<n;i++)
			F[pc[i]][i]=a[i];
		for(int i=0;i<=m;i++)
			FWT(F[i]);
		for(int p=0;p<n;p++)
			for(int i=1;i<=m;i++){
				int s=0;
				for(int j=1;j<i;j++)
					s=(s+1ll*(i-j)*F[j][p]%mod*G[i-j][p])%mod;
				s=dec(1ll*i*F[i][p]%mod,s);
				G[i][p]=1ll*s*inv[i]%mod;
			}
		for(int i=0;i<=m;i++)
			IFWT(G[i]);
		for(int i=0;i<n;i++)
			b[i]=G[pc[i]][i];
	}
}
using Poly::init;
using Poly::ln;
int n,m,p[N],r[N],F[S],H[S],dp[N][2][2],f[S],g[S];
ll a[N],b[N],C;
struct node{
	int u,v;
}e[M];
inline int solve(int s){
	int ct=0;
	for(int i=0;i<n;i++)
		if(s>>i&1)
			b[++ct]=a[p[i]];
	int ans=0,fl=0;
	for(int d=59;d>=0;d--){
		ll w=1ll<<d;
		int c=0,v=C>>d&1,wc=w%mod;
		dp[0][0][0]=1;
		for(int i=1;i<=ct;i++){
			if(b[i]&w){
				b[i]^=w,c++;
				int v=(b[i]+1)%mod;
				dp[i][0][0]=1ll*dp[i-1][0][1]*v%mod;
				dp[i][0][1]=1ll*dp[i-1][0][0]*v%mod;
				dp[i][1][0]=(1ll*dp[i-1][1][1]*v+1ll*dp[i-1][1][0]*wc+dp[i-1][0][0])%mod;
				dp[i][1][1]=(1ll*dp[i-1][1][0]*v+1ll*dp[i-1][1][1]*wc+dp[i-1][0][1])%mod;
			}else{
				int v=(b[i]+1)%mod;
				dp[i][0][0]=1ll*dp[i-1][0][0]*v%mod;
				dp[i][0][1]=1ll*dp[i-1][0][1]*v%mod;
				dp[i][1][0]=1ll*dp[i-1][1][0]*v%mod;
				dp[i][1][1]=1ll*dp[i-1][1][1]*v%mod;
			}
		}
		ans=(ans+dp[ct][1][v])%mod;
		if((c&1)!=v){ fl=1;break; }
	}
	if(!fl) ans++;
	return ans;
}
inline bool cmp(int i,int j){
	return a[i]<a[j];
}
inline int get(int s,int l,int r){
	return s&(((1<<r+1)-1)^((1<<l)-1));
}
int main(){
	n=read(),m=read(),C=read();
	for(int i=0;i<n;i++)
		a[i]=read(),p[i]=i;
	sort(p,p+n,cmp);
	for(int i=0;i<n;i++)
		r[p[i]]=i;
	for(int i=1;i<=m;i++)
		e[i].u=r[read()-1],e[i].v=r[read()-1];
	int u=1<<n;
	Prefix(u),init(u);
	for(int s=0;s<u;s++){
		bool fl=1;
		for(int i=1;i<=m;i++)
			if((s>>e[i].u&1)&&(s>>e[i].v&1)){
				fl=0;
				break;
			}
		F[s]=fl;
	}
	ln(F,H);
	f[0]=1;
	for(int i=0;i<n;i++){
		for(int s=0;s<u;s++){
			int v=f[s];
			if(!v) continue;
			int cur=((1<<i)-1)|get(s,i,n-1);
			if(cur>>i&1){
				int t=s^(1<<i);
				g[t]=add(g[t],v);
				continue;
			}
			for(int T=(u-1)^cur^(1<<i),t=T;;t=(t-1)&T){
				if(pc[t]&1) g[s|t]=(g[s|t]+1ll*v*H[t|(1<<i)]%mod*(a[p[i]]%mod+1))%mod;
				else g[s|t|(1<<i)]=(g[s|t|(1<<i)]+1ll*v*H[t|(1<<i)])%mod;
				if(!t) break;
			}
		}
		for(int s=0;s<u;s++)
			f[s]=g[s],g[s]=0;
	}
	int ans=0;
	for(int s=0;s<u;s++)
		ans=(ans+1ll*f[s]*solve(s))%mod;
	write(ans);
	flush();
}
```

---

## 作者：tzc_wk (赞：3)

首先 $b_u\ne b_v$ 的条件自然让我们想到容斥。这样我们有了一个 $2^m\text{poly}(n,m)$ 的暴力：枚举一个边集并强制要求这些边两端的点的 $b$ 相同，计算满足这个条件的 $b$ 序列的个数，乘以 $2^{|\text{集合大小}|}$ 累加入答案中，求解符合条件的序列个数相当于把每个大小为奇数的连通块中 $a$ 最小的拎出来跑 $m=0$，再乘以所有大小为偶数的连通块的 $(\min a_i)+1$。

考虑优化，其实我们并不用关心每个连通块中具体边集是什么，只用关心它们生成的连通块是什么就行了。因此考虑先求出 $f_S$ 表示所有 $S$ 的导出子图的连通子图的 $(-1)^{|E|}$ 之和——这部分可以类似于连通子图计数那样 $3^n$ 求出。这样我们枚举一种连通块划分方案，乘以 $\prod g_S$ 再跑前面的算法就行了。这样复杂度是 $B_n\text{poly}(n)$ 的，可以拿到 80 分。

再优化。我们甚至不用知道每个连通块的划分方案，因为最后求解答案的过程中，只用知道大小为奇数的连通块中 $a$ 最小的点（以下称作代表点）的集合是什么，这是一个 $2^n$ 的 `mask`，可以先求出 $h_S$ 表示代表点集合为 $S$ 的所有边集的容斥系数之和，然后就可以求出答案。求解 $h_S$ 有一个非常 naive 的 $4^n$ 的 DP 就是暴力记录当前所有连通块覆盖的点集以及它们的代表点组成的集合，转移就枚举子集，虽然可以通过，但是总觉得不够快。其实有一个非常巧妙的优化到 $3^n·n$ 的方法：不妨假设 $a$ 数组有序，那么一个连通块的代表点就是其中编号最小的点。我们按照 $1\sim n$ 的顺序枚举所有点，对于一个连通块而言，我们在枚举到其代表点时加入这个连通块的贡献。那么枚举到 $i$ 的时候，$1\sim i-1$ 肯定都已经加入了某个连通块，我们就不用记录它们是否被访问过，只用记录它们是否是某个大小为奇数的连通块的代表点即可。同时，$i+1\sim n$ 肯定不是某个连通块的代表点，只用记录它们是否被加入连通块集合。这样我们 DP 时候状态只有 $2^n$ 种，加上枚举子集的复杂度，是 $3^n·n$。可以通过这道题。

```cpp
const int MAXN=15;
const int MAXP=32768;
const int MOD=998244353;
int n,m;ll c;
int qpow(int x,int e){int ret=1;for(;e;e>>=1,x=1ll*x*x%MOD)if(e&1)ret=1ll*ret*x%MOD;return ret;}
void add(int &x,int v){((x+=v)>=MOD)&&(x-=MOD);}
ll a[MAXN+3];int ord[MAXN+5],id[MAXN+5];
int lg[MAXP+5],E[MAXP+5],f[MAXP+5],g[MAXP+5],h[MAXP+5],tmp[MAXP+5];
int calc(vector<ll>v){
	int len=v.size(),res=0;
	for(int i=60;~i;i--){
		ll xs=0;for(int j=1;j<=len;j++)xs^=v[j-1]>>(i+1);
		if(!xs){
			static int dp[MAXN+5][2][2];memset(dp,0,sizeof(dp));dp[0][0][0]=1;
			for(int j=1;j<=len;j++)for(int x=0;x<2;x++)for(int y=0;y<2;y++){
				if(dp[j-1][x][y]){
					for(int d=0;d<=(v[j-1]>>i&1);d++){
						ll way=((d==((v[j-1]>>i&1))?((v[j-1]&((1ll<<i)-1))+1):(1ll<<i)))%MOD;
						add(dp[j][x^d][y|(d!=(v[j-1]>>i&1))],1ll*way%MOD*dp[j-1][x][y]%MOD);
					}
				}
			}add(res,1ll*dp[len][0][1]*qpow((1ll<<i)%MOD,MOD-2)%MOD);
		}
	}
	ll xs=0;for(ll x:v)xs^=x;if(xs==0)add(res,1);
	return res;
}
int _calc(vector<ll>v){
	if(!c)return calc(v);
	else{
		v.pb(c);int res=calc(v);v.ppb();
		v.pb(c-1);res=(res-calc(v)+MOD)%MOD;
		return res;
	}
}
int main(){
	scanf("%d%d%lld",&n,&m,&c);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),ord[i]=i;
	sort(ord+1,ord+n+1,[&](int x,int y){return a[x]<a[y];});
	for(int i=1;i<=n;i++)id[ord[i]]=i;
	sort(a+1,a+n+1);
	for(int i=1,u,v;i<=m;i++)scanf("%d%d",&u,&v),E[(1<<id[u]-1)|(1<<id[v]-1)]++;
	for(int i=0;i<n;i++)for(int j=0;j<(1<<n);j++)if(j>>i&1)E[j]+=E[j^(1<<i)];
	for(int i=0;i<(1<<n);i++)g[i]=E[i]?0:1;
	for(int i=1;i<(1<<n);i++){
		f[i]=g[i];int rst=i&(i-1);
		for(int S=rst;S;--S&=rst)f[i]=(f[i]+1ll*(MOD-f[i^S])*g[S])%MOD;
	}
	h[0]=1;
	for(int i=1;i<=n;i++){
		memcpy(tmp,h,sizeof(h));memset(h,0,sizeof(h));
		for(int S=0;S<(1<<n);S++){
			if(S>>(i-1)&1)add(h[S^(1<<i-1)],tmp[S]);
			else{
				int S0=((S^((1<<n)-1))&((1<<n)-(1<<i)));
				for(int T=S0;;--T&=S0){
					int T0=(S|T),s=1ll*tmp[S]*f[T|(1<<i-1)]%MOD;
					if(__builtin_parity(T))h[T0]=(h[T0]+(a[i]+1)%MOD*s)%MOD;
					else add(h[T0|(1<<i-1)],s);
					if(!T)break;
				}
			}
		}
	}
	int res=0;
	for(int i=0;i<(1<<n);i++)if(h[i]){
		vector<ll>vec;
		for(int j=1;j<=n;j++)if(i>>(j-1)&1)vec.pb(a[j]);
		res=(res+1ll*h[i]*_calc(vec))%MOD;
	}printf("%d\n",res);
	return 0;
}
/*
3 3 3
3 3 3
1 2
2 3
3 1
*/
```

---

## 作者：TallBanana (赞：1)

题面：[[GDKOI2023 提高组] 异或图](https://www.luogu.com.cn/problem/P10104)

发现 $b$ 不能相等这个限制可以容斥掉，然后就好搞很多。那么先考虑二进制枚举所有的边是否符合条件，然后将 $b_i$ 的上界转化为 $b$ 钦定相同的连通块中 $a_i$ 的最小值。那么问题等价于去掉了第二个限制。

考虑这个如何做？首先把 $=C$ 变成 $=0$，具体方法是对于 $a$，新增一个 $a_x=C$，算方案，再减去 $a_x=C-1$ 的方案。然后我们发现对于二进制拆分从高到低位考虑，如果一个 $b_i$ 在第 $d$ 位没有顶到上界，那么后面的位可以随便取，我们可以称这样的 $b_i$ 为自由元。那么自由元可以贴合其他 $b_i$ 的值，使得最终异或和 $=0$。

考虑 dp，从高位到低位枚举 $d$，顺便检查 $d$ 以上的位是否满足异或等于 0 的条件。设 $f_{i,0/1,0/1}$ 表示 考虑了 $a_{1\sim i}$，第 $d$ 位的异或结果是多少，是否有自由元的方案数。转移分讨第 $d$ 位是 0/1、是否作为自由元即可。对答案的贡献是 $f_{n,0,1}$。注意我们这里固定是存在自由元的，对于没有自由元的情况就检查是否满足 $\oplus_{i=1}^n a_i=0$ 就好了。

我们可以切掉这道题了吗？还不行。记得我们是如何容斥的吗，是通过枚举边是否满足限制。然而这是超时的。怎么办呢？由于我们只关心 $b_i$ 相同的连通块，所以我们可以直接枚举连通块的情况，并算出这些情况的容斥系数之和。

首先对于一个连通块，可以算不联通的容斥系数，然后用总共减去不联通的（其实你发现只要关心存不存在边即可）。

然后考虑把连通块合并成一个图。要是考虑记录每个连通块中 $a_i$ 最小值是哪个和每个点是否被选则，空间复杂度将会是 $O(4^n)$ 的，不能接受。考虑压缩状态，先将 $a_i$ 排序，然后每次考虑最小的没有被选的点它所在的连通块，复杂度变为 $O(n3^n)$。具体地，考虑当前最小没有被选的是 $i$，那么 $1\sim i$ 的位表示是否是 $a_i$ 是否被选为最小值，$i+1\sim n$ 的位表示是否被选了。容易转移。

那么我们就可以快乐地切掉这道题啦 :D。

**code（参考了 DaiRuiChen 大神的）**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL N=20,M=1<<15,P=998244353;
LL n,m,C,id[N],p[M],cnt[M],f[M],g[M],pop[M],ans;
bool e[N][N];
struct zxz { LL a,id; }gg[N];
bool cmp(zxz a,zxz b) { return a.a<b.a; }
void upd(LL &x,LL y) { x=(x+y)%P; }
LL Bond(vector<LL> ve)
{
	LL res=0;
	for(int d=60;d>=0;d--)
	{
		LL xo=0;
		for(auto a:ve) xo^=a>>d+1;
		if(xo!=0) break;
		LL f[2][2],g[2][2];
		f[0][0]=1; f[0][1]=f[1][0]=f[1][1]=0;
		for(auto a:ve)
		{
			memcpy(g,f,sizeof(f));
			memset(f,0,sizeof(f));
			for(int x=0;x<=1;x++)
				for(int y=0;y<=1;y++)
				{
					LL tmp=((a&(1ll<<d)-1)+1)%P;
					if(((a>>d)&1)==0) upd(f[x][y],g[x][y]*tmp%P);
					else
					{
						if(y) upd(f[x][1],(1ll<<d)%P*g[x][y]%P);
						else upd(f[x][1],g[x][y]);
						upd(f[x^1][y],g[x][y]*tmp%P);
					}
				}
		}
		upd(res,f[0][1]);
	}
	LL xo=0; for(auto a:ve) xo^=a;
	if(!xo) res=(res+1)%P;
	return res;
}
void solve()
{
	for(int i=1;i<(1<<n);i++)
		for(int u=1;u<=n;u++)
			for(int v=u+1;v<=n;v++)
				cnt[i]+=e[u][v]&&(i>>u-1&1)&&(i>>v-1&1);
	for(int i=0;i<(1<<n);i++)
	{
		p[i]=!cnt[i]; pop[i]=pop[i>>1]+(i&1);
		for(int j=(i-1)&i;j;j=(j-1)&i)
			if(j&(i&-i)) p[i]=(p[i]-p[j]*(!cnt[i^j])+P)%P;
	}
	f[0]=1;
	for(int i=1;i<=n;i++)
	{
		memcpy(g,f,sizeof(f));
		memset(f,0,sizeof(f));
		for(int s=0;s<(1<<n);s++)
		{
			if(s>>i-1&1) { upd(f[s^(1<<i-1)],g[s]); continue; }
			int j=(((s>>i)^-1)<<i)&(1<<n)-1;
			for(int t=j;227;t=(t-1)&j)
			{
				int me=t^(1<<i-1);
				if(pop[me]&1) upd(f[s^me],g[s]*p[me]%P);
				else upd(f[s^t],g[s]*p[me]%P*((gg[i].a+1)%P)%P);
				if(!t) break;
			}
		}
	}
	for(int s=0;s<(1<<n);s++)
	{
		vector<LL> vec;
		for(int i=1;i<=n;i++)
			if(s>>i-1&1) vec.push_back(gg[i].a);
		if(C==0) { ans=(ans+f[s]*Bond(vec)%P)%P; continue; }
		vec.push_back(C); LL t=Bond(vec);
		vec.back()--; ans=(ans+f[s]*(t-Bond(vec)+P)%P)%P;
	}
	printf("%lld",ans);
}
int main()
{
	scanf("%lld%lld%lld",&n,&m,&C);
	for(int i=1;i<=n;i++) scanf("%lld",&gg[i].a),gg[i].id=i;
	sort(gg+1,gg+n+1,cmp);
	for(int i=1;i<=n;i++) id[gg[i].id]=i;
	for(int i=1,u,v;i<=m;i++) scanf("%d%d",&u,&v),e[id[u]][id[v]]=e[id[v]][id[u]]=1;
	solve();
	return 0;
}
```

---


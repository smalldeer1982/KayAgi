# [GDKOI2023 提高组] 树

## 题目描述

给定一棵 $n$ 个结点的有根树 $T$，结点从 $1$ 开始编号，根结点为 $1$ 号结点，每个结点有一个正整数权值 $v_i$。

有 $Q$ 次询问，对于一次询问，给定 $(x, k)$，设 $x$ 号结点的子树内（包含 $x$ 自身）的所有满足距离 $x$ 号结点不超过 $k$ 的结点编号为 $c_1, c_2, . . . , c_k$，则这次询问的答案为：

$$(v_{c_1} ⊕ d(c_1, x)) + (v_{c_2} ⊕ d(c_2, x)) + \cdots + (v_{c_k} ⊕ d(c_k, x))$$

其中 $d(x, y)$ 表示树上 $x$ 号结点与 $y$ 号结点间唯一简单路径所包含的边数，$d(x, x) = 0$。$⊕$ 表示异或运算。

## 说明/提示

对于 10% 的数据，满足 $n, Q ≤ 2 \times 10^3$。

对于 20% 的数据，满足 $n, Q ≤ 10^5$。

对于另外 20% 的数据，满足 $p_i = i - 1$。

对于另外 10% 的数据，满足 $k ≤ 20$。

对于另外 20% 的数据，满足 $k = n$。

对于另外 10% 的数据，满足 $v_i = 0$。

对于 100% 的数据，满足 $1 ≤ n, Q ≤ 10^6$，$ 0 ≤ v ≤ 10^9$，$ 1 ≤ p_i < i$，$ 1 ≤ x, k ≤ n$。

## 样例 #1

### 输入

```
10
9 3 0 7 4 8 8 7 2 5
1 1 2 2 3 6 6 8 7
10
8 2
2 1
5 1
4 1
4 1
1 4
4 1
6 3
4 1
1 4```

### 输出

```
10
14
4
7
7
55
7
30
7
55```

# 题解

## 作者：cyffff (赞：22)

[$\text{Link}$](https://www.luogu.com.cn/problem/P10107)

相当巧妙的倍增/差分题。

## 题意
给你一颗 $n$ 个结点的树，点有点权，$q$ 次询问给出 $x,k$，求：

$$\sum_uv_u\oplus d(u,x)$$

其中 $u$ 为 $x$ 子树中距离 $x$ 不超过 $k$ 的所有点，$d(x,y)$ 为 $x$ 到 $y$ 的距离。

$n,q\le 10^6$.

## 思路

![p](https://cdn.luogu.com.cn/upload/image_hosting/kftupnxm.png?x-oss-process=image)

考虑这样一颗树，要求 $6$ 子树中距离它不超过 $1$ 的点的答案，即黄色部分。我们可以用绿色部分的答案减去橙色部分的答案得到黄色部分的答案（由于深度相同可以直接减）。

定义一个结点 $x$ 对应的蓝色区域为所有深度 $\ge dep_x$ 的点中 $dfn$ 小于等于 $low_x$ 的结点。如上图中给出了结点 $6$ 对应的蓝色区域。

定义一个结点 $x$ 对应的深度为 $k$ 的绿色区域为所有深度在 $[dep_x,dep_x+k)$ 中的点中 $dfn$ 小于等于 $low_x$ 的结点。如上图中给出了结点 $6$ 对应的深度为 $2$ 的绿色区域。

那么不妨对于每个深度的结点按 $\text{dfs}$ 序排序，记 $pr_x$ 为 $x$ 在深度为 $dep_x$ 的点中的前驱，$rs_x$ 为 $x$ 子树中 $\text{dfs}$ 序最大的子结点（没有子结点则设为 $rs_{pr_x}$）。

考虑到所求的值中有深度相关的异或运算，需要利用有二进制相关性质的维护方式，不妨考虑使用**倍增**。记 $rs_{i,x}$ 表示对 $x$ 进行 $2^i$ 次 $x\gets rs_x$ 得到的结点，$f_{i,x}$ 为 $x$ 对应的深度为 $2^i$ 的绿色区域的答案。

考虑从 $f_{i-1,x}\to f_{i,x}$，$rs_{i-1,x}$ 的深度为 $2^{i-1}$ 的绿色区域中所有点的点权都要异或上 $2^{i-1}$，于是还需要维护 $cnt_x$ 表示 $x$ 对应的蓝色区域的结点数，$vnt_{i,x}$ 表示 $x$ 对应的蓝色区域中有几个点的点权第 $i$ 位为 $1$。用 $vnt_{i-1,rs_{i-1,x}}$ 减去 $vnt_{i-1,rs_{i,x}}$ 就可以得到有几个数的第 $i-1$ 位会从 $1$ 变成 $0$，同理可求有几个数此位从 $0$ 变成 $1$。

询问时用 $x$ 的深度为 $k$ 的绿色区域的答案减去 $pr_x$ 的即可，考虑求 $x$ 的答案，先求出 $p$ 为 $x$ 进行 $k$ 次 $x\gets rs_x$ 得到的结点，然后每次从 $x$ 跳 $2^i$ 步到 $rs_{i,x}$ 时，$rs_{i,x}$ 的蓝色区域减去 $p$ 的蓝色区域内的点权的第 $i$ 位都会改变，同上求出即可。

时间复杂度 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
    
}
const int N=1e6+10,L=20;
int n,q,dep[N],v[N],pr[N],rs[L][N],cnt[N],vnt[L][N];
ll f[L][N];
vector<int>a[N],vec[N];
inline void dfs1(int x){
	vec[dep[x]].push_back(x);
	for(auto t:a[x])
		rs[0][x]=t,dep[t]=dep[x]+1,dfs1(t);
}
inline void dfs2(int x){
	for(auto t:a[x])
		dfs2(t);
	cnt[x]+=cnt[rs[0][x]];
	for(int k=0;k<L;k++)
		vnt[k][x]+=vnt[k][rs[0][x]];
}
inline ll solve(int x,int k){
	if(!x) return 0;
	k++;
	int p=x;
	ll ans=0;
	for(int i=L-1;i>=0;i--)
		if(k>>i&1)
			ans+=f[i][p],p=rs[i][p];
	for(int i=L-1;i>=0;i--)
		if(k>>i&1){
			int t=rs[i][x];
			int c0=vnt[i][t]-vnt[i][p];
			int c1=cnt[t]-cnt[p]-c0;
			ans+=(c1-c0)*(1ll<<i);
			x=t;
		}
	return ans;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		v[i]=read();
	for(int i=2;i<=n;i++)
		a[read()].push_back(i);
	dfs1(1);
	for(int i=0;i<=n;i++){
		if(!vec[i].size()) break;
		for(int j=0;j<vec[i].size();j++){
			int x=vec[i][j];
			if(j) pr[x]=vec[i][j-1];
			if(!rs[0][x]) rs[0][x]=rs[0][pr[x]];
			f[0][x]=v[x]+f[0][pr[x]];
			cnt[x]=1+cnt[pr[x]];
			for(int k=0;k<L;k++)
				vnt[k][x]=(v[x]>>k&1)+vnt[k][pr[x]];
		}
	}
	dfs2(1);
	for(int i=1;i<L;i++)
		for(int x=1;x<=n;x++){
			rs[i][x]=rs[i-1][rs[i-1][x]];
			int t=rs[i-1][x],p=rs[i][x];
			int c0=vnt[i-1][t]-vnt[i-1][p];
			int c1=cnt[t]-cnt[p]-c0;
			f[i][x]=f[i-1][x]+f[i-1][t]+(c1-c0)*(1ll<<i-1);
		}
	q=read();
	while(q--){
		int x=read(),k=read();
		write(solve(x,k)-solve(pr[x],k)),putc('\n');
	}
	flush();
}
```


---

## 作者：WrongAnswer_90 (赞：12)

# [My Blogs]()

### [P10107 [GDKOI2023 提高组] 树](https://www.luogu.com.cn/problem/P10107)

狠 $\uparrow$ 狠 $\downarrow$ 维 $\uparrow$ 护 $\downarrow$ ！！

来自沙东二轮省集的长剖加倍增做法！目前是洛谷最优解喵。

首先考虑链怎么做。异或问题还是考虑每位拆贡献。对于一个询问 $(x,y)$，假设在考虑第 $k$ 位，则贡献应当是形如：

![image.png](https://s2.loli.net/2024/05/22/bBFCuQsfa3htDwT.png)

其中黑色的区域表示这个数的第 $k$ 位是 $0$ 有贡献，白色表示 $1$ 有贡献。上面的矩形表示第 $k$ 位的贡献情况，下面一个矩形表示第 $k-1$ 位的贡献情况。

容易发现，在一个 $k$ 的黑或白段的内部，$k-1$ 及以下的位的贡献是相同的。这启发我们倍增：设 $f_{i,j}$ 表示第 $i$ 位开始的 $2^j$ 位，对于 $<j$ 的位按照题目中的方式计算贡献，对于大于等于 $j$ 的位全部算上的权值和。合并两个的时候：

![image.png](https://s2.loli.net/2024/05/22/gMCiNYEPWaDr71A.png)

只有灰色的地方是算错的。所以需要查询区间某一位 $0$ 的个数减去 $1$ 的个数，做一下前缀和即可。查询比较容易处理，这样复杂度是 $\mathcal O(n\log n)$。

然后考虑怎么搬到树上。线段树合并状物可能也能做，但是复杂度保底两只 $\log$，显然是爆了。所以考虑高效一点的东西：长链剖分。

设 $f_{i,j,k}$ 表示 $i$ 子树内，从从 $i$ 开始向下 $j$ 层的位置，到向下 $j+2^k$ 的位置的所有点，对于 $<k$ 的位按照题目中的方式计算贡献，对于大于等于 $k$ 的位全部算上的权值和。

首先对于重儿子，可以直接把他的 DP 数组继承过来，但是可以发现，这样没有算上 $f_{i,0,k}$。然后对于轻儿子，可以直接把对应位置的所有倍增数组对应相加，然后这样也是没有更新 $f_{i,0,k}$。所以现在问题变成了：新拼上一个子树，如何在 $\log$ 或者以下的时间复杂度内更新 $f_{i,0}$。

一个经典 trick：首先 $f_{i,0,0}$ 已经有一位 $a_i$，然后可以在后面拼上一个 $f_{to,0,0}$ 变成 $f_{i,0,1}$。然后再拼一个 $f_{to,1,1}$ 变成 $f_{i,0,2}$，然后再拼一个 $f_{to,3,2}$ 变成 $f_{i,0,3}\dots$

![](https://s2.loli.net/2024/05/22/cDEfKIUnlCX5gWi.png)

$i$ 左侧是已经合并好的子树，$to$ 是新合并的子树。容易发现这样就可以在 $\log$ 的时间复杂度内，完成一个子树合并之后 $f_{i,0}$ 的更新。

这样还有一个问题，更新 $i$ 的时候需要查询当前 $i$ 子树内深度在某个区间的某一位是 $0$ 的数减去 $1$ 的数的个数。这个东西在序列上是用前缀和维护，但是长剖不能支持前缀和。

但是合并的时候因为 $to$ 的链长严格小于 $i$ 的链长，所以更新的是 $i$ 主链的一个前缀，可以弄一个后缀和，$g_{i,j,k}$ 表示深度 $\geq j$ 的，第 $k$ 位是 $0$ 的减第 $k$ 位是 $1$ 的数的个数，这样合并的复杂度就对了。总复杂度是 $\mathcal O(n\log n)$，常数还是比较优秀的/dy/dy。

```cpp
int n,m,cnt,head[1000010],to[2000010],nex[2000010];
int dis[1000010],son[1000010],a[1000010];
ll ans[1000010];
vector<pii> ve[1000010];
inline void add(int x,int y){to[++cnt]=y,nex[cnt]=head[x],head[x]=cnt;}
struct Node{ll f[20];int g[20];}p[2000010],*f[1000010],*o=p;
void dfs(int x,int fa)
{
	dis[x]=1;
	for(int i=head[x];i;i=nex[i])if(to[i]!=fa)
	{
		dfs(to[i],x);
		if(Mmax(dis[x],dis[to[i]]+1))son[x]=to[i];
	}
}
inline void merge(int x,int y)
{
	int j=1,p=0;ll s=0;
	for(;p+(1<<(j-1))-1<dis[y];p+=(1<<(j-1)),++j)
	{
		s+=f[y][p].f[j-1]+(1ll<<(j-1))*(f[y][p].g[j-1]-f[y][p+(1ll<<(j-1))].g[j-1]);
		f[x][0].f[j]+=s;
	}
	s+=(1ll<<(j-1))*f[y][p].g[j-1];
	for(int k=j-1;k>=0;--k)
	{
		if(p+(1<<k)-1>=dis[y])continue;
		s+=f[y][p].f[k],p+=1<<k;
		s+=(1ll<<k)*f[y][p].g[k];
	}
	while(j<20)f[x][0].f[j]+=s,++j; 
}
void dfs2(int x,int fa)
{
	for(int j=0;j<20;++j)f[x][0].f[j]=a[x],f[x][0].g[j]=a[x]>>j&1?-1:1;
	if(son[x])
	{
		f[son[x]]=f[x]+1,dfs2(son[x],x),merge(x,son[x]);
		for(int j=0;j<20;++j)f[x][0].g[j]+=f[x][1].g[j];
	}
	for(int i=head[x];i;i=nex[i])if(to[i]!=fa&&to[i]!=son[x])
	{
		f[to[i]]=o,o+=dis[to[i]]+1,dfs2(to[i],x),merge(x,to[i]);
		for(int j=0;j<dis[to[i]];++j)for(int k=0;k<20;++k)
		{
			f[x][j+1].f[k]+=f[to[i]][j].f[k];
			f[x][j+1].g[k]+=f[to[i]][j].g[k];
		}
		for(int k=0;k<20;++k)f[x][0].g[k]+=f[to[i]][0].g[k];
	}
	for(auto q:ve[x])
	{
		Mmin(q.fi,dis[x]-1);int p=0;
		for(int j=19;j>=0;--j)
		{
			if(p+(1<<j)-1>q.fi)continue;
			ans[q.se]+=f[x][p].f[j],p+=1<<j;
			ans[q.se]+=(1ll<<j)*(f[x][p].g[j]-f[x][q.fi+1].g[j]);
		}
	}
}
inline void mian()
{
	read(n);int x,y;
	for(int i=1;i<=n;++i)read(a[i]);
	for(int i=2;i<=n;++i)read(x),add(x,i),add(i,x);
	read(m);
	for(int i=1;i<=m;++i)read(x,y),ve[x].eb(mp(y,i));
	dfs(1,0),f[1]=o,o+=dis[1]+1,dfs2(1,0);
	for(int i=1;i<=m;++i)write(ans[i],'\n');
}
```

---

## 作者：Mobius127 (赞：8)

很厉害的 BFS 序！

考虑链怎么做，设 $f_{i, j}$ 为当 $x=i$，$k=2^{j}-1$ 时的答案，$[0, 2^{j-1})$ 可以由 $f_{i, j-1}$ 得到，$[2^{j-1}, 2^{j})$ 的部分，注意到此有 $\operatorname{dist}(i, v)=v-i=v-(i+2^{j-1})+2^{j-1}$，即 $f_{i+2^{j-1}, j-1}$ 处计算贡献时，异或的位置只有 $j-1$ 这一位不同，考虑删掉多余的贡献，那么有：

$$f_{i, 0}=v_{i}$$

$$f_{i, j(j>0)}=f_{i-1, j-1}+f_{i+2^{j-1}, j-1}+\sum_{k=i+2^{j-1}}^{i+2^{j}-1} \operatorname{calc}(k, j-1)$$

$\operatorname{calc}(x, bit)$ ：若 $v_{x}$ 二进制下第 $bit$ 为 $1$ 则为 $2^{bit}$（原来异或为 $0$ 现在是 $1$），否则为 $-2^{bit}$。

对 $bit$ 分别求 $\operatorname{calc}(x)$ 的前缀和，预处理 $O(n\log n)$。

对于询问 $(x, k)$，考虑每跳一次之后，第 $j$ 位对于后面是跳不了的，考虑计算后面的数第 $j$ 位变 $1$ 的贡献，不难发现也是 $\sum_{i=p}^{x+k}\operatorname{calc}(k, j)$ 的形式，仍用上面的前缀和数组即可做到单次询问 $\log n$。

### 做法一

考虑搬到树上，$f_{i, j}$ 仍为原来定义。

对于预处理，考虑 $i$ 向下走 $d=2^{j-1}$ 步到的点集 $S_{i, d}$（即链中的 $i+2^{j-1}$），其在 BFS 序上是一个连续的区间，对 $j$ 在 bfs 序上做 $f$ 的后缀和即可。

接下来，考虑转移的第三部分。

对于原来的贡献 $\operatorname{cost}(i, j, 2^{j-1})=\sum_{k=i+2^{j-1}}^{i+2^{j}-1} \operatorname{calc}(k, j-1)$，这一段虽然被拆成了 $2^{j-1}$ 个区间，但是状态数还是过大，考虑下图。


![](https://cdn.luogu.com.cn/upload/image_hosting/ti9bvcuy.png)

需要计算贡献的点是蓝色部分，考虑最上面一排（被粉色线串到的点），我们直接计算它们子树内所有点的贡献，再减去下面一排（被橙色线串到的点）子树内所有点的贡献，就得到了蓝色部分的贡献。

根据 $i$ 向下走 $d$ 步到的点集 $S_{i, d}$ 在 BFS 序上连续的结论，设 $g_{i, j}=\sum_{v\in T_{i}}\operatorname{calc}(v, j)$，对其在 BFS 序上做前缀和，那么有：

$$f_{i, 0}=v_{i}$$

$$f_{i, j}=f_{i, j-1}+sumf_{[\min{S_{i, 2^{j-1}}}, \max{S_{i, 2^{j-1}}}], j-1}$$

$$+sumg_{[\min{S_{i, 2^{j-1}}}, \max{S_{i, 2^{j-1}}}], j-1}-sumg_{[\min{S_{i, 2^{j}}}, \max{S_{i, 2^{j}}}], j-1}$$

这部分 $\LaTeX$ 有点崩，放放源码：

```
$$f_{i, j}=f_{i, j-1}+sumf_{[\min{S_{i, 2^{j-1}}}, \max{S_{i, 2^{j-1}}}], j-1}$$

$$+sumg_{[\min{S_{i, 2^{j-1}}}, \max{S_{i, 2^{j-1}}}], j-1}-sumg_{[\min{S_{i, 2^{j}}}, \max{S_{i, 2^{j}}}], j-1}$$

```


这样就可以轻松地做到 $O(n\log n)$ 预处理。

接着做询问，考虑 $x$ 相邻的兄弟 $y$，考虑 $x, y$ 一起向右跳，维护跳到的儿子，在 BFS 序上差分即可。

总复杂度 $O((n+q)\log n)$。

实际上这种写法难写到吐，因为向下并不能直接跳，我们还得处理向左/右不超过自己的点。

### 做法二

首先，从 $x$ 开始向右走 $2^{i}$ 步走到的最右边的点 $rp_{x, i}$（这个向右走指的是在同层 BFS 序小于等于 $x$ 的所有点的子树中走）是可以简单处理的。

设 $f_{i, j}$ 表示在与 $x$ 同层、且 BFS 序小于等于 $x$ 的所有点，向下走 $2^{j}$ 的答案和。$g_{i, j}$ 同理。

那么有转移：

$$f_{x, 0}=\sum_{dep_{t}=dep_{x}, bfn_{t}\le bfn_{x}} v_{t}$$

$$f_{i, j}=f_{i, j-1}+f_{rp_{x, i}, j-1}+g_{rp_{x, i-1}, j-1}-g_{rp_{x, i}, j-1}$$

接着考虑询问，可以差分为 在与 $x$ 同层、且 BFS 序**小于等于** $x$ 的所有点，向下走 $d$ 的答案和 减去 在与 $x$ 同层、且 BFS 序**小于** $x$ 的所有点，向下走 $d$ 的答案和。

先不考虑每一位 $j$ 对后面部分的贡献，假设最后跳到了 $y$，重塑整个跳的步骤，直接用 $g$ 进行差分即可。

不难发现做法二本质是做法一的前缀和，但在询问处差分比在预处理处和处理处差分要好写地多。


### Code 

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cctype>
#include <vector>
#include <queue>
#include <bitset>
#define vi vector<int>
#define pb push_back
#define mp make_pair
#define st first
#define nd second
using namespace std;
typedef long long ll;
typedef pair <int, int> Pii;
const int INF=0x3f3f3f3f;
const int cp=998244353;
inline int mod(int x){if(x>=cp) x-=cp;if(x<0) x+=cp;return x;}
inline void plust(int &x, int y){x=mod(x+y);return ;}
inline void minut(int &x, int y){x=mod(x-y);return ;}
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline int ksm(int a, int b=cp-2){
	int ret=1;
	for(; b; b>>=1, a=1ll*a*a%cp)
		if(b&1) ret=1ll*ret*a%cp;
	return ret;
}
const int N=1e6+6;
int n, val[N], bfn[N], rev[N], pre[N], lst[N], dep[N], rp[N][21];
vi G[N], nd[N];
ll f[N][21], g[N][21];
void bfs(){
	queue <int> Q;Q.push(1);
	while(!Q.empty()){
		int x=Q.front();Q.pop();
		rev[bfn[x]=++bfn[0]]=x;
		for(auto v:G[x]) Q.push(v);
	}
}
int calc(int x, int bit){int t=1<<bit;return ((val[x]>>bit)&1)?-t:t;}
void dfs(int x){
	pre[x]=lst[dep[x]];lst[dep[x]]=x;nd[dep[x]].pb(x);
	for(auto v:G[x]) dep[v]=dep[x]+1, dfs(v);
	rp[x][0]=lst[dep[x]+1];f[x][0]=val[x], g[x][0]=calc(x, 0);
	for(int i=1; i<=20; ++i) rp[x][i]=rp[rp[x][i-1]][i-1], g[x][i]=calc(x, i);;
}
ll query(int x, int d){
	if(!x) return 0;int y=x;ll res=0;
	for(int i=20, p=d; i>=0; --i)
		if(p>=(1<<i)) p-=1<<i, res+=f[y][i], y=rp[y][i];
	for(int i=20, p=d; i>=0; --i)
		if(p>=(1<<i)) p-=1<<i, x=rp[x][i], res+=g[x][i]-g[y][i];
	return res;
}
void dfs2(int x){for(auto v:G[x]) dfs2(v);for(int i=0; i<=20; ++i) g[x][i]+=g[rp[x][0]][i];}
signed main(){
	n=read();
	for(int i=1; i<=n; ++i) val[i]=read();
	for(int i=2; i<=n; ++i) G[read()].pb(i);
	bfs();dfs(dep[1]=1);
	for(int d=1; d<=n; ++d){
		int up=nd[d].size();
		for(int i=1; i<up; ++i)
			for(int j=0; j<=20; ++j)
				f[nd[d][i]][j]+=f[nd[d][i-1]][j], g[nd[d][i]][j]+=g[nd[d][i-1]][j];
	}
	dfs2(1);
	for(int j=1; j<=20; ++j)
		for(int i=1; i<=n; ++i)
			f[i][j]=f[i][j-1]+f[rp[i][j-1]][j-1]+g[rp[i][j-1]][j-1]-g[rp[i][j]][j-1];
	int Q=read();
	for(int i=1, x, d; i<=Q; ++i)
		x=read(), d=read(), printf("%lld\n", query(x, d+1)-query(pre[x], d+1));
	return 0;
}

```










---

## 作者：fireinice (赞：7)

# P10107 [GDKOI2023 提高组] 树

题解区好像都是在 bfs 序上前缀和差分，沙东省集讲到这个题然后大家糊了一个 $O(n\log n)$ 长剖做法。

先考虑链上怎么做，设 $f_{i,j}$ 表示点 $i$ 询问 $2^j$，只考虑前 $j-1$ 位的答案，$g_{i,j}$ 表示第 $i$ 位 $1$ 的个数的前缀和，转移就是多考虑 $j$ 这一位的贡献。

然后只要把这个做法套上长剖不变的搬到树上：离线，把询问挂在点上，处理点 $u$ 时先把所有短儿子的 $f$ 和 $g$ 全都加到长链上对应位置，再倍增递推出 $u$ 的 $f$ 和 $g$ 即可。

时空都是 $O(n\log n)$，然后这个做法好处在于不依赖和的差分性，可以把原题的加法改成些更奇怪的东西。

code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#include<array>
#define endl '\n'
using namespace std;
using ll = long long;
using pi2 = array<int,2>;
using pi3 = array<int,3>;

const int N=1e6+500,V=31,H=20;

vector<int> G[N];
ll f[N][H],cnt[N][V],tot[N];
int dep[N],fa[N],ml[N],son[N];
void dfs1(int u){
    dep[u]=dep[fa[u]]+1,ml[u]=0;
    for(int v:G[u])
        dfs1(v),ml[u]=max(ml[v]+1,ml[u]),son[u]=ml[v]>=ml[son[u]]?v:son[u];
}

int top[N],dfn[N],arr[N],dcnt;
void dfs2(int u,int tp){
    top[u]=tp,dfn[u]=++dcnt,arr[dfn[u]]=u;
    if(son[u])
        dfs2(son[u],tp);
    for(int v:G[u])
        if(v!=son[u])dfs2(v,v);
}
const inline int d(int u,int x){return x<=ml[u]?arr[dfn[u]+x]:0;}
int vs[N];
void merge(int u,int v){
    for(int i=0;i<H;i++)
        for(int j=0;j<=ml[v];j++)
            f[d(u,j+dep[v]-dep[u])][i]+=f[d(v,j)][i];
    
    for(int j=ml[v];j>=0;j--){
        tot[d(u,j+dep[v]-dep[u])]+=tot[d(v,j)];
        for(int i=0;i<V;i++)
            cnt[d(u,j+dep[v]-dep[u])][i]+=cnt[d(v,j)][i];
    }
}

const inline ll calc(int u,int i,int l,int r){
    return (cnt[d(u,l)][i]-cnt[d(u,r)][i])-(i?(cnt[d(u,l)][i-1]-cnt[d(u,r)][i-1]):0);
};
const inline ll calctot(int u,int l,int r){
    return (tot[d(u,l)]-tot[d(u,r)]);
};
ll query(int u,int k){
    k=min(k+1,ml[u]+1);
    ll res=0;
    for(int i=V-1;i>H-1;i--){
        res+=calc(u,i,0,k);
    }
    for(int i=H-1;i>=0;i--){
        if(k>=(int)1<<i){
            res+=f[u][i];
            res+=(calctot(u,(int)1<<i,min((int)1<<i+1,k))<<i)-calc(u,i,(int)1<<i,k);
            res+=calc(u,i,0,(int)1<<i);
            k-=(int)1<<i;
            u=d(u,(int)1<<i);
        }else{
            res+=calc(u,i,0,k);
        }
    }
    return res;
}
ll ans[N];
vector<pi2> qs[N];
void dfs(int u){
    if(son[u])dfs(son[u]);
    for(int v:G[u])
        if(v!=son[u])
            dfs(v),merge(u,v);

    f[u][0]=0,tot[u]=1;
    for(int i=0;i<V;i++)cnt[u][i]=((vs[u]>>i&1)<<i)+(i?cnt[u][i-1]:0);

    for(int i=0;i<V;i++)cnt[u][i]+=cnt[son[u]][i];
    tot[u]+=tot[son[u]];

    auto d=[&u](int x){return x<=ml[u]?arr[dfn[u]+x]:0;};
    for(int i=1;i<H;i++)
        // if(((int)1<<i)<=ml[u]+1)
        f[u][i]=f[u][i-1]+f[d((int)1<<i-1)][i-1]+
            calc(u,i-1,0,(int)1<<i-1)+
            (calctot(u,(int)1<<i-1,(int)1<<i)<<i-1)-calc(u,i-1,(int)1<<i-1,(int)1<<i);

    for(auto q:qs[u])
        ans[q[1]]=query(u,q[0]);
}
int n;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>vs[i];
    for(int i=2;i<=n;i++)cin>>fa[i],G[fa[i]].push_back(i);
    int q;
    cin>>q;
    for(int i=1;i<=q;i++){
        int x,k;
        cin>>x>>k;
        qs[x].push_back({k,i});
    }
    
    dfs1(1),dfs2(1,1);
    dfs(1);
    for(int i=1;i<=q;i++)
        cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：_l_l_ (赞：4)

新时代 OI 题！

观察到“子树”、“深度”等关键词，于是长剖启动，然后就释怀的似了。

考虑观察“二进制”关键词，联想到倍增，观察到本题加法支持前缀和，于是我们考虑倍增式的往下跳。

先扫一遍树，记 $x$ 的 dfn 序为 $q_x$，深度为 $d_x$，大小为 $sz_x$，令：

$$f_{x,i} = \sum_{q_y<q_x+sz_x,d_y\in[d_x,d_x+2^i)} v_y\oplus(d_y-d_x)$$

那么就可以观察到 $k=2^i$ 时答案即为 $f_{x,i}-f_{{prv_x},i}$，$prv_x$ 为**同层**的 dfn 的前一个点。

尝试维护 $f$，发现由于倍增自带一个二进制，我们只需要维护一个区间中的 $v$ 其中一个位的信息就行，但是此时再维护一个 $2^i$ 就会爆炸，但是我们有前缀和，我们只需要维护：

$$g_{x,u,op}=\sum_{q_y<q_x+sz_x,d_y\geq d_x} [\lfloor v_y/2^u\rfloor\bmod2=op]$$

那么，如果只求一层的 $g$，我们只需要求出 $g_{x,u}-g_{sub_x,u}$，$sub_x$ 即为**下一层**中 dfn $\leq q_x+sz_x$ 的最后一个点，没有的话为 $0$，这个值可以合理使用 $prv_x$ 来求出。

扩展一下，求出 $2^i$ 层的 $g$ 便可以求 $g_{x,u}-g_{sub_{x,i},u}$。

这样我们便可以推出 $g$ 与 $f$ 的递推式子：

$$
\begin{aligned}
g_{x,i}&=g_{prv_x,i}+g_{sub_x,i}-g_{sub_{prv_x},i}+\operatorname{calc}(x,i)\\
f_{x,i}&=f_{x,i-1}+f_{sub_{x,i-1},i-1}+2^{i-1}\times((g_{sub_{x,i-1},i-1,0}-g_{sub_{x,i},i-1,0})-(g_{sub_{x,i-1},i-1,1}-g_{sub_{x,i},i-1,1}))
\end{aligned}
$$

计算答案时是类似的，不再推导。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1000005;
vector<int> G[MAXN]; int fa[MAXN], val[MAXN], dep[MAXN];
int prv[MAXN], sub[MAXN][20], tmp[MAXN], g[MAXN][20][2]; long long f[MAXN][20];
int queryg(int u, int v, int i) {return g[u][i][0] - g[v][i][0] - g[u][i][1] + g[v][i][1];}
void dfs(int u) {
	dep[u] = dep[fa[u]] + 1; prv[u] = tmp[dep[u]]; tmp[dep[u]] = u;
	for (int v : G[u]) if (v != fa[u]) dfs(v), sub[u][0] = v;
	if (sub[u][0] == 0) sub[u][0] = sub[prv[u]][0];
	for (int i = 1; i < 20; i++) sub[u][i] = sub[sub[u][i - 1]][i - 1];
	for (int _ = 0; _ < 2; _++) for (int i = 0; i < 20; i++) {
		g[u][i][_] = g[prv[u]][i][_] + g[sub[u][0]][i][_] - g[sub[prv[u]][0]][i][_] + ((val[u] >> i & 1) == _);
	}
	f[u][0] = val[u] + f[prv[u]][0]; for (int i = 1; i < 20; i++) {
		f[u][i] = f[u][i - 1] + f[sub[u][i - 1]][i - 1] + (1ll << (i - 1)) * queryg(sub[u][i - 1], sub[u][i], i - 1);
	}
}
int kth(int u, int k) {for (int i = 19; ~i; i--) if (k >= 1 << i) k -= 1 << i, u = sub[u][i]; return u;}
long long query(int u, int k) {
	k++; int v = kth(u, k); long long ans = 0; for (int i = 19; ~i; i--) {
		if (k >= 1 << i) ans += f[u][i] + (1ll << i) * queryg(sub[u][i], v, i), u = sub[u][i], k -= 1 << i;
	} return ans;
}
int main() {
	int n; scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &val[i]);
	fa[1] = 1; for (int i = 2; i <= n; i++) scanf("%d", &fa[i]), G[fa[i]].push_back(i); dfs(1);
	int q; scanf("%d", &q); while (q--) {int x, k; scanf("%d %d", &x, &k); printf("%lld\n", query(x, k) - query(prv[x], k));}
}
```

---

## 作者：DaiRuiChen007 (赞：3)

[Problem Link](https://www.luogu.com.cn/problem/P10107)

**题目大意**

> 给定 $n$ 个点的有根树，点有点权，$q$ 次询问 $u,k$，求出所有 $u$ 子树内距离 $u$ 不超过 $k$ 的点 $v$，$a_v\oplus\mathrm{dis}(u,v)$ 的和。
>
> 数据范围：$n,q\le 10^6$。

**思路分析**

考虑刻画子问题，注意到这个问题的子问题不太可能被一个子树内的信息描述，而是形如同层内一些节点的子树信息的合并。

又因为这题要处理的信息和距离的二进制异或有关，这启示我们用倍增一类自带二进制结构的算法刻画信息。

因此我们可以考虑 $f(u,k)$ 表示所有和 $u$ 同层且 dfn 序小于等于 $u$ 的点的子树中，深度 $\le d_u+2^k$ 的点的答案和。

那么 $f(u,k)\gets f(u,k-1)+f(dw_{u,k-1},k-1)$，其中 $dw_{u,k-1}$ 表示深度为 $d_u+2^{k-1}$ 的节点中，dfn 序 $<\mathrm{dfn}(u)+\mathrm{siz}(u)$ 的最后一个点，也可以简单理解为 $u$ 子树内最“靠右”的节点。

由于 $f(u,k)$ 自带二进制位上的信息，因此我们只要处理距离的第 $2^{k-1}$ 位上的变化量，即给每个 $f(dw_{u,k-1},k-1)$ 里的元素贡献异或上 $2^{k-1}$。

那么我们要计数 $f(dw_{u,k-1},k-1)$ 对应的这个范围内，有多少个 $a_v$ 的 $2^{k-1}$ 位为 $0$，多少个为 $1$，事实上我们只关心这两种元素的数量差。

如果暴力设 $G(u,k,d)$ 表示 $f(u,k)$ 对应范围内，$a_v$ 的第 $d$ 个二进制位为 $0$ 的元素数量减去为 $1$ 的元素数量，这可以类似倍增转移，但此时信息总量是 $\mathcal O(n\log^2n)$ 级别的。

考虑优化，很显然 $u,d$ 三维是必须记录的，那么考虑去除 $k$ 一维的影响。

记 $g(u,d)=G(u,\infty,d)$，即和 $u$ 同层且 dfn 序不超过 $u$ 的每个点的整个子树中，$a_v$ 的第 $d$ 位等于 $0$ 的数量减去等于 $1$ 的数量。

那么原本的 $G(u,k,d)=g(u,d)-g(dw_{u,k},d)$，即一个类似差分的过程。

那么 $g$ 的转移可以看成一个类似二维前缀和的过程，记 $pre_u$ 表示和 $u$ 同层的点中最后一个 dfn 序小于 $u$ 的。

那么不难得到转移：$g(u,d)=g(dw_{u,0},d)+g(pre_u,d)-g(dw_{pre_u,0},d)+[a_u\operatorname{AND} 2^d=z]$，即分别从 $u$ 的“下方”和“右方”转移，然后容斥。

查询答案可以做一些类似的过程，每次考虑最高位的影响，实际上每个最高位都只会影响深度的一段后缀，也可以用 $g$ 算出其贡献。

时间复杂度 $\mathcal O((n+q)\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e6+5;
vector <int> G[MAXN];
int n,q,a[MAXN],lst[MAXN],dep[MAXN],pre[MAXN],dw[MAXN][20],g[MAXN][20];
ll f[MAXN][20];
void dfs(int u,int fz) {
	dep[u]=dep[fz]+1,pre[u]=lst[dep[u]],lst[dep[u]]=u;
	dw[u][0]=dw[pre[u]][0];
	for(int v:G[u]) if(v^fz) dfs(v,u),dw[u][0]=v;
	for(int k=1;k<20;++k) dw[u][k]=dw[dw[u][k-1]][k-1];
	for(int k=0;k<20;++k) {
		g[u][k]=g[dw[u][0]][k]+g[pre[u]][k]-g[dw[pre[u]][0]][k]+(a[u]>>k&1?-1:1);
	}
	f[u][0]=a[u]+f[pre[u]][0];
	for(int k=1;k<20;++k) {
		int v=dw[u][k-1];
		f[u][k]=f[u][k-1]+f[v][k-1]+(1ll<<(k-1))*(g[v][k-1]-g[dw[u][k]][k-1]);
	}
}
ll qf(int u,int z) {
	int v=u; ll s=0; ++z;
	for(int k=19;~k;--k) if(z>>k&1) v=dw[v][k];
	for(int k=19;~k;--k) if(z>>k&1) {
		s+=f[u][k]+(1ll<<k)*(g[dw[u][k]][k]-g[v][k]),u=dw[u][k];
	}
	return s;
}
signed main() {
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int u=2,v;u<=n;++u) cin>>v,G[u].push_back(v),G[v].push_back(u);
	dfs(1,0),cin>>q;
	for(int x,k;q--;) cin>>x>>k,cout<<qf(x,k)-qf(pre[x],k)<<"\n";
	return 0;
}
```

---

## 作者：win114514 (赞：2)

值得一写的倍增。

### 思路

考虑一条链的时候怎么做（好像是个经典问题）。

我们可以设 $f_{i,j}$ 代表从 $i$ 开始 $2^j$ 次方个点，在模 $2^j$ 的权值和。

再设 $g_{i,j}$ 表示 $i$ 到链底的在第 $j$ 位和。

那么我们要如何推出 $f_{i,j}$ 呢？

那么有：

$$
f_{i,j}=f_{i,j-1}+f_{i+2^{j-1},j-1}+(g_{i,j}-g_{i+2^{j-1},j})\times 2^j+(2^{j-1}-(g_{i+2^{j-1},j}-g_{i+2^j,j}))\times 2^j
$$

也就相当于把 $j-1$ 的答案先累加，然后前一半不用异或，后一半异或一下。

个人感觉是比较巧妙的。

这个做法可以推广到树上吗。

我们惊奇的发现，这个东西是可以累加的。

那么可以对树进行长链剖分。

递推时直接把短儿子的 $f,g$ 累加到长链上，在推出 $i$ 的值。

代码比较好写，有一些细节可以自己想一想。

时间复杂度：$O(n\log n)$。

### Code

```cpp
/*
  ! 如果没有天赋，那就一直重复
  ! Created: 2024/06/28 16:45:56
*/
#include <bits/stdc++.h>
using namespace std;

#define fro(i, x, y) for (int i = (x); i <= (y); i++)
#define pre(i, x, y) for (int i = (x); i >= (y); i--)

using i64 = long long;

const int N = 1e6 + 10;

int n, q, lg, ct;
int a[N], b[N], v[N], p[N], d[N];
int sn[N], dn[N], ed[N], sz[N], md[N];
i64 ans[N];
i64 s[N];
i64 f[N][21];
i64 g[N][21];
vector<int> to[N];
vector<int> qu[N];

inline void dfs1(int x) {
  d[x] = md[x] = d[p[x]] + 1;
  for (auto i : to[x]) {
    dfs1(i), md[x] = max(md[x], md[i]);
    if (md[sn[x]] < md[i]) sn[x] = i;
  }
}
inline void dfs2(int x) {
  dn[x] = ++ct;
  if (sn[x]) dfs2(sn[x]);
  for (auto i : to[x])
    if (i != sn[x]) dfs2(i);
  ed[x] = (sn[x] ? ed[sn[x]] : dn[x]);
}
inline void dfs3(int x) {
  for (auto i : to[x]) dfs3(i);
  int L = dn[x], R = ed[x];
  for (auto i : to[x])
    if (i != sn[x]) {
      int p = L - dn[i] + 1;
      fro(j, dn[i], ed[i]) {
        fro(k, 0, lg) {
          f[p + j][k] += f[j][k];
          g[p + j][k] += g[j][k];
        }
        sz[p + j] += sz[j], s[p + j] += s[j];
      }
    }
  sz[L] = 1;
  fro(k, 0, lg) g[L][k] = (v[x] >> k) & 1;
  fro(k, lg + 1, 30) s[L] += v[x] & (1ll << k);
  if (L != R) {
    sz[L] += sz[L + 1], s[L] += s[L + 1];
    fro(k, 0, lg) g[L][k] += g[L + 1][k];
  }
  fro(k, 1, lg) {
    int l, r, len, res;
    f[L][k] += f[L][k - 1];
    l = L + (1ll << k - 1);
    r = l + (1ll << k - 1);
    if (L + (1ll << k - 1) <= R) {
      f[L][k] += f[l][k - 1];
      len = sz[l] - (r > R ? 0 : sz[r]);
      res = g[l][k - 1] - (r > R ? 0 : g[r][k - 1]);
      f[L][k] += (len - res) * (1ll << k - 1);
    }
    res = g[L][k - 1] - (l > R ? 0 : g[l][k - 1]);
    f[L][k] += res * (1ll << k - 1);
  }
  for (auto i : qu[x]) {
    b[i]++, ans[i] = s[L] - (L + b[i] > R ? 0 : s[L + b[i]]);
    int cr = L, l, r, len, res;
    pre(k, lg, 0) {
      if ((1ll << k) <= b[i]) {
        l = cr + (1ll << k), b[i] -= (1ll << k);
        if (l <= R) {
          r = l + b[i];
          len = sz[l] - (r > R ? 0 : sz[r]);
          res = g[l][k] - (r > R ? 0 : g[r][k]);
          ans[i] += (len - res) * (1ll << k);
        }
        ans[i] += f[cr][k];
        res = g[cr][k] - (l > R ? 0 : g[l][k]), ans[i] += res * (1ll << k);
        if ((cr = l) > R) break;
      } else {
        r = cr + b[i];
        res = g[cr][k] - (r > R ? 0 : g[r][k]), ans[i] += res * (1ll << k);
      }
    }
  }
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n, lg = __lg(n);
  fro(i, 1, n) cin >> v[i];
  fro(i, 2, n) cin >> p[i], to[p[i]].push_back(i);
  dfs1(1), dfs2(1);
  cin >> q;
  fro(i, 1, q) {
    cin >> a[i] >> b[i];
    qu[a[i]].push_back(i);
  }
  dfs3(1);
  fro(i, 1, q) cout << ans[i] << "\n";
  return 0;
}
```

---

## 作者：nullqtr_pwp (赞：1)

如果在子树内，显然 $\text{dis}$ 可以转化成 $\Delta \text{dep}$。那么在同一个 $\text{dep}$ 的点，考虑第二维的 $\text{dfn}$ 属性，那么我们可以考虑，求解 $u$ 子树内 $\text{dfn}$ 的最大值的点，减去前一个 $u$，以容斥掉未计算的部分。每一个 $u$ 管辖的就是每层的一段前缀。每层的最后一个点就会构成 $u$ 子树的最右链。

令 $\text{rs}(u)$ 表示 $u$ 最右边的儿子，用来考虑 $u$ 管辖的子树的边界。

定义【$k$ 级邻域】是 $\text{dep}_v\in[\text{dep}_u,\text{dep}_u+k)$，且在 $v$ 的管辖范围之中的点。

考虑倍增维护，$f_{u,i}$ 表示 $u$ 的 $2^i$ 级邻域的答案。考虑 $f_{u,i-1}\to f_{u,i}$ 的变化：$u$ 的 $2^{i-1}$ 级的右儿子的 $2^{i-1}$ 级邻域，在 $i-1$ 位多异或了一个 $1$。还需要维护 $\text{size}_u$ 表示 $u$ 的管辖区域的大小，以及在此管辖区域中，有多少个点的点值在第 $i$ 位为一。容易求出，有多少个点，在 $i-1$ 位 $1\to 0$，以及 $0\to 1$。

考虑 $k$ 级邻域的答案，先往下跳右子到 $v$，然后考虑从 $u$ 往下走，去减掉 $v$ 的管辖区域，来求出某一位的变化量。时间复杂度 $\mathcal O(n\log n)$。

---

## 作者：qwqUwU (赞：1)

~~建议降紫~~

## GDKOI2023 树 题解

二进制运算求和，首先考虑拆位。

问题变成对每个 $d$ 求 $u$ 子树 $k$ 层内：

  - $bit(dep_x-dep_u,d)=0$ 的 $x$ 的 $1$ 的个数。
  - $bit(dep_x-dep_u,d)=1$ 的 $x$ 的 $0$ 的个数。

  $bit(x,y)$ 表示 $x$ 的二进制第 $y$ 位。

考虑链怎么做。为方便，容斥一下变成算后者的 $0$ 个数减去 $1$ 个数。

考虑在链上怎么做。这是经典问题。

发现 $bit(x-l,d)=1$ 的 $x$ 的位置是从 $l$ 开始，每隔 $2^d$ 个 $0$ 有 $2^d$ 个 $1$ 。

我们显然可以对这个东西记一个前缀和。

具体的，$f_i$ 从 $f_{i+2^{d+1}}$ 转移，并附带 $[i+2^d,2+2^{d+1})$ 的系数和。

询问时找到最近的 $l+2^{d+1}$ 的位置，一些边角位置都是好算的。

现在上树。发现只和深度有关，上个长剖即可。

注意长剖维护前缀和的方向。

同时这个做法注意卡常。不建议开 vector ，也不要傻乎乎的做 $\log$ 次 dfs 。

```cpp
#include<bits/stdc++.h>
#define bit(s,x) (((s)>>(x))&1)
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
typedef long long ll; 
inline int read(){
	int x=0,c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
const int N=1e6+3;
int n,Q,a[N],md[N],son[N],dfn[N],tim,idfn[N];
int f[N],g[N],h[N];
ll ans[N];
int m,mm;
int head[N],nxt[N];
inline void dfs1(int u){
	md[u]=0;
	for(int v=head[u];v;v=nxt[v]){
		dfs1(v);
		md[u]=max(md[u],md[v]+1);
		if(!son[u]||md[v]>md[son[u]])son[u]=v;
	}
}
inline void dfs2(int u){
	idfn[dfn[u]=++tim]=u;
	if(son[u])dfs2(son[u]);
	for(int v=head[u];v;v=nxt[v])if(v!=son[u])dfs2(v);
}
struct Node{int k,x,id;}b[N];
int main(){
	n=read();rep(i,1,n)a[i]=read();
	rep(i,2,n){
		int x=read();
		nxt[i]=head[x],head[x]=i;
	}
	Q=read();
	rep(i,1,Q)b[i].x=read(),b[i].k=read(),b[i].id=i;
	dfs1(1); dfs2(1);
	sort(b+1,b+Q+1,[&](Node A,Node B){return dfn[A.x]>dfn[B.x];});
	rep(d,0,29){
		m=1<<d,mm=1<<d+1;
		int p=1;
		per(i,n,1){
			int u=idfn[i];
			for(int v=head[u];v;v=nxt[v])if(v!=son[u]){
				rep(i,dfn[v],dfn[v]+md[v]){
					int j=i-dfn[v]+dfn[u]+1;
					f[j]+=f[i],g[j]+=g[i],h[j]+=h[i];
				}
			}
			h[i]=bit(a[u],d);
			f[i]=h[i]?-1:1;
			g[i]=0;
			if(md[u])f[i]+=f[i+1],h[i]+=h[i+1];
			if(md[u]>=mm)g[i]=g[i+mm]-f[i+mm];
			if(md[u]>=m)g[i]+=f[i+m];
			for(;p<=Q&&b[p].x==u;++p){
				int k=min(b[p].k,md[u]),k1=k&~((m<<1)-1);
				int res=g[i]-g[i+k1];
				k1+=m;
				if(k1<=k){
					res+=f[i+k1];
					if(k<md[u])res-=f[i+k+1];
				}
				res += h[i];
				if(k<md[u])res-=h[i+k+1];
				ans[b[p].id]+=1ll*res*m;
			}
		}
	}
	rep(i,1,Q)printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：可爱的小棉羊 (赞：0)

CSP 模拟赛（？）搬了，有同学过了，太强了。

很巧妙的题，这里介绍第一篇题解的做法。

距离是假的其实是深度之差，下面都这样认为。

考虑跑个 dfs 序，记 $low_u$ 为子树 $u$ 中的最大时间戳，$dfn_u$ 为 $u$ 的时间戳。

那么考虑这样一件事情，如果查询 $(x,k)$，我们会将其理解为满足 $dep_u\in [dep_x,dep_x+k],dfn_u\in[dfn_x,low_x)$ 的点的贡献。

不妨差分一下，记 $pre_u$ 为和 $u$ 同层的点中，它的 $dfn$ 序上的前驱。

满足 $dep_u\in [dep_x,dep_x+k],low_{pre_u}<dfn_u\le low_x$ 的点的贡献，依然是没问题的，这个可以分为两段前缀，下面我们考虑求 $dep_u\in [dep_x,dep_x+k],dfn_u\le low_x$ 点的贡献，因为这样把 $x$ 换成 $pre_x$ 再求一遍，一减就是答案。

（这是个典 trick 吗？我想不通为啥题解区都觉得这个很显然，问同学，同学：“做多题就知道了。”）

那么我们就转变问题了，但是 $dep_u\in [dep_x,dep_x+k]$ 依然不好算。而且深度这一维不好做相同的操作。

那假设 $k$ 正好是 $2^p-1$ 呢？考虑前 $2^{p-1}-1$，是不变的，而且后面 $2^{p-1}$ 相当于给他异或上 $2^{p-1}$ 这里记下这一块有多少个 $p-1$ 位上为 $1$，那么也可以计算。

欸，我们发现上面过程也可以拓展到非 $2^p-1$ 的形式，且我们考虑记下 $f_{i,x}$，问题为 $(x,2^i-1)$ 时候的答案。（不是原问题哦，而是转化完之后的）。

考虑如何去求，记 $rs_u$ 为 $u$ 最后遍历的儿子标号，没儿子就是 $rs_{pr_u}$，那么考虑类似倍增 LCA 的求解方式，同理设 $rs_{i,u}$ 为 $u \gets rs_u$ 这个操作重复 $2^i$ 后的节点。

$f_{i,x}$ 前一段由 $f_{i-1,x}$ 继承，而后一段考虑只是从 $f_{i-1,rs_{i-1,x}}$ 贡献每一个值都疑惑上了个 $2^{i-1}$，考虑如何计算这些数 $i-1$ 位有多少 $1$ 和 $0$，这样就可以计算了。

这是可减的，所以说考虑记录 $cnt_u$ 表示满足 $dep_x\le dep_u,dfn_x\le low_u$ 的点数，减一下即可解决，对于每一位也可以用类似的方法。

求这个可以用类似前缀和的方法。

做完了，时空都为 $O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int dfn[1000005],tot,a[1000005];
int pr[1000005];
long long f[25][1000005];
int rs[25][1000005],dep[1000005];
int fa[1000005],low[1000005],cnt[1000005],res[35][1000005],sum[35][1000005],sum2[1000005];
vector<int>vec[1000005];
int last[1000005];
void dfs(int u){
    low[u]=dfn[u]=++tot;
    pr[u]=last[dep[u]];
    last[dep[u]]=u;
    sum2[u]=cnt[u]=sum2[pr[u]]+1;
    for(int i=0;i<32;i++)sum[i][u]=((a[u]>>i)&1)+sum[i][pr[u]],res[i][u]=((a[u]>>i)&1)+sum[i][pr[u]];
    int lastv=0;
    for(int i=0;i<vec[u].size();i++){
        int v=vec[u][i];
        dep[v]=dep[u]+1;
        lastv=v;
        dfs(v);
        low[u]=max(low[u],low[v]);
    }
    if(lastv==0)rs[0][u]=rs[0][pr[u]];
    else rs[0][u]=lastv;
    for(int i=0;i<32;i++)res[i][u]+=res[i][rs[0][u]];
    f[0][u]=f[0][pr[u]]+a[u];
    cnt[u]+=cnt[rs[0][u]];
}
long long solve(int x,int k){
    long long ans=0,pos=x;
    k++;
    for(int i=20;i>=0;i--)if(((k>>i)&1))pos=rs[i][pos];
    for(int i=20;i>=0;i--){
        if(!((k>>i)&1))continue;
        k^=(1<<i);
        ans+=f[i][x]+1ll*(1<<i)*(cnt[rs[i][x]]-cnt[pos]-2*(res[i][rs[i][x]]-res[i][pos]));
        x=rs[i][x];
    }
    return ans;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=2;i<=n;i++){
        cin>>fa[i];
        vec[fa[i]].push_back(i);
    }
    dep[1]=1; 
    dfs(1);
    for(int i=1;i<=20;i++){
        for(int j=1;j<=n;j++){
            rs[i][j]=rs[i-1][rs[i-1][j]];
            f[i][j]=f[i-1][j]+f[i-1][rs[i-1][j]]+1ll*(1<<(i-1))*(cnt[rs[i-1][j]]-cnt[rs[i][j]]-2*(res[i-1][rs[i-1][j]]-res[i-1][rs[i][j]]));

        }
    }

    int q;
    cin>>q;
    while(q--){
        int x,k;
        cin>>x>>k;
        cout<<solve(x,k)-solve(pr[x],k)<<'\n';
    }
}
```

---

## 作者：KSCD_ (赞：0)

考虑按位计算贡献，先考虑链的情况。考虑倍增，设 $f_{i,k}$ 表示 $[i,i+2^k)$ 区间的答案。转移时先累加两个小区间的贡献，另外后半部分的第 $(k-1)$ 位要异或 $1$，因此设 $g_{i,k}$ 表示前 $i$ 个数第 $k$ 位若异或 $1$ 会产生的总变化量。统计时若其该位为 $1$ 则贡献 $-1$，否则贡献 $1$。通过差分计算变化量，最终转移为 $f_{i,k}=f_{i,k-1}+f_{i+2^{k-1},k-1}+2^{k-1}\times(g_{i+2^k-1}-g_{i+2^{k-1}-1})$。统计答案时一直向后跳并累加即可。

考虑把这东西搬到树上，但由于子树内在某一层上的点不止一个，只能在 $i$ 节点本身上记录信息。所以设 $f_{i,j,k}$ 表示 $i$ 子树内深度在 $[d_i+j,d_i+j+2^k)$ 内所有点的贡献和。可以发现这个 $(i,j)$ 很能长链剖分，重儿子直接继承，轻儿子对应位置直接累加。但是这样没有计算 $f_{i,0}$，考虑怎么计算这个。

那么先把 $a_i$ 加到 $f_{i,0}$ 里。假如从子树 $v$ 给 $f_{i,0}$ 更新，设 $s_k$ 表示 $v$ 子树内对 $f_{i,0,k}$ 的贡献，有 $s_0=0$。发现 $s_k$ 可以用 $s_{k-1}$ 拼上 $f_{v,2^{k-1}-1,k-1}$ 得到，这里的式子应该和链的情况一样，实际实现时由于 $s_k$ 只从 $s_{k-1}$ 转移，开一个变量，一直更新就行。

那么问题就在于还需要一个记录贡献变化量的数组 $g$ 来辅助更新。链上我们是用前缀和维护的，但是树上长剖不好搞前缀和，所以考虑转而计算后缀和。具体地设 $g_{i,j,k}$ 表示 $i$ 子树内深度不低于 $d_i+j$ 的所有点权第 $k$ 位若异或 $1$ 会产生的总变化量，这就可以直接对应位累加了，只需要在 $g_{i,0}$ 上额外加入 $a_i$ 的贡献即可。

所有的转移和统计答案都跟链上类似，把每个询问扔到对应节点上处理即可。只是要格外注意在 $g$ 上差分时不能超出当前节点的管辖范围，有比较多的细节。时间复杂度 $O((n+q)\log n)$。

~~~c++
#include<iostream>
#include<vector>
#define pii pair<int,int>
#define ll long long
using namespace std;
const int N=1e6+10;
const int K=20+3;
int n,q,v[N],d[N],son[N]; ll res[N];
vector <int> e[N];
vector <pii> a[N];
struct nod{ll f[K],g[K];}temp[N],*f[N],*cur=temp;
void dfs(int u)
{
	d[u]=0;
	for(int v:e[u])
	{
		dfs(v),d[u]=max(d[u],d[v]);
		if(d[v]>d[son[u]]) son[u]=v;
	}
	d[u]++;
}
void merg(int u,int v)
{
	for(int j=0;j<20;j++) f[u][0].g[j]+=f[v][0].g[j];
	ll s=0;
	for(int p=0,k=1;k<20;p+=(1<<(k-1)),k++)
	{
		if(p<d[v]) s+=f[v][p].f[k-1]+(1<<(k-1))*f[v][p].g[k-1];
		if(p+(1<<(k-1))<d[v]) s-=(1<<(k-1))*f[v][p+(1<<(k-1))].g[k-1];
		f[u][0].f[k]+=s;
	}
}
void dfsb(int u)
{
	for(int j=0;j<20;j++) f[u][0].f[j]=v[u],f[u][0].g[j]=(((v[u]>>j)&1)?-1:1);
	if(son[u]) f[son[u]]=f[u]+1,dfsb(son[u]),merg(u,son[u]);
	for(int v:e[u]) if(v!=son[u])
	{
		f[v]=cur,cur+=d[v],dfsb(v),merg(u,v);
		for(int j=0;j<d[v];j++) for(int k=0;k<20;k++) 
			f[u][j+1].f[k]+=f[v][j].f[k],f[u][j+1].g[k]+=f[v][j].g[k];
	}
	for(pii te:a[u])
	{
		int x=min(te.first,d[u]-1),id=te.second;
		for(int p=0,k=19;k>=0;k--)
		{
			if(p+(1<<k)-1>x) continue;
			res[id]+=f[u][p].f[k],p+=(1<<k);
			if(p<d[u]) res[id]+=(1<<k)*f[u][p].g[k];
			if(x+1<d[u]) res[id]-=(1<<k)*f[u][x+1].g[k];
		}
	}
}
signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n,d[0]=-1;
	for(int i=1;i<=n;i++) cin>>v[i];
	for(int i=2,x;i<=n;i++) cin>>x,e[x].push_back(i);
	cin>>q;
	for(int i=1;i<=q;i++)
	{
		int x,k; cin>>x>>k;
		a[x].push_back({k,i});
	}
	dfs(1),f[1]=cur,cur+=d[1],dfsb(1);
	for(int i=1;i<=q;i++) cout<<res[i]<<'\n';
	return 0;
}
~~~

---

## 作者：phil071128 (赞：0)

如果异或符号和加法换一下则或许是01trie经典问题，可能会去想长剖，但是距离和权值的异或不是很好处理。

看到二进制异或操作依然考虑二进制位分离，而树上倍增确实能够完美契合。

由于常见倍增都是向上倍增，所以无法解决询问子树的问题。但是我们可以考虑**向下倍增**，$f_{x,k}$ 表示询问为 $(x,2^k-1)$ 的答案，但是这样显然不能快速转移预处理。一种套路是改状态为前缀和的形式：所有与 $x$ 同层的点 $u,bfn[u]\le bfn[x]$，$(u,2^k-1)$ 的答案的和。形象的说，树的连续若干层组成了一个梯形，而我们用梯形右上角的点来代表这个梯形。对于询问，找到同一层左边的节点，差分一下即可。

考虑转移：从 $f_{x,k}\to f_{x,k+1}$，首先需要找到下一 $2^k$ 层的代表节点 $h_{x,k}$。贪心的想，就是 $x$ 一直沿着bfs序最大的儿子走 $2^k$ 步到达的点，但这样做是不对的，我们依旧需要每走一层进行一次前缀和预处理。
$$
f_{x,k+1}=f_{x,k}+f_{h_{x,k},k}+(v_{c_1}\oplus 2^k+v_{c_2}\oplus 2^k...+v_{c_k}\oplus 2^k)
$$
其中 $c$ 是所有 $h_{x,k}$ 所代表的，高度为 $2^k-1$ 的梯形内的点。于是再处理这些点中 $v_c$ 第 $k$ 位为 $0/1$ 的个数即可。

我们设 $g'_{x,k,0/1}$ 表示 $x$ 子树内，有多少点的 $v_i$ 第 $k$ 位是 $0/1$。再令 $g_{x,k,0/1}=\sum g'_{u,k,0/1}$。其中 $u$ 的含义和上文相同。不难发现，这样才可以容易去做前缀和。

令 $y=h_{x,k}$ ，即：
$$
f_{x,k+1}=f_{x,k}+f_{y,k}+((g_{y,k,0}-g_{h_{y,k},k,0})-(g_{y,k,1}-g_{h_{y,k},k,1}))\times2^{k}
$$
时间复杂度 $O((n+q)\log n)$。空间 $2n\log V+2n\log n$，略微吃力。

#### 细节

1. 在预处理 $h_{x,0}$ 时，笔者用 `vector::sort()` ，对于叶子节点的判定是：`vector[i].size()==1`，然而这样会导致根节点 $1$ 有可能被误判为叶子。

#### Code

```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
int read(){
	char c=getchar();int h=0,tag=1;
	while(!isdigit(c)) tag=(c=='-'?-1:1),c=getchar();
	while(isdigit(c)) h=(h<<1)+(h<<3)+(c^48),c=getchar();
	return h*tag;
}
const int N=1e6+5;
vector<int>s[N];
int bfn[N],f[N],dep[N],pre_g[N][31][2],pre[N],v[N];
vector<int>d[N];
void dfs(int x,int fa) {
	for(int i=0;i<31;i++) {
		if((v[x]&(1<<i))==0) pre_g[x][i][0]++;
		else pre_g[x][i][1]++;
	}
	dep[x]=dep[fa]+1;
	f[x]=fa;
	d[dep[x]].push_back(x);
	for(int y:s[x]) {
		if(y==f[x]) continue;
		dfs(y,x);
		for(int i=0;i<31;i++) for(int t=0;t<2;t++) pre_g[x][i][t]+=pre_g[y][i][t];
	}
}
void bfs() {
	queue<int>q;
	q.push(1);
	int cnt=0;
	while(!q.empty()) {
		int x=q.front();q.pop();
		bfn[x]=++cnt;
		for(int y:s[x]) {
			if(y==f[x]) continue;
			q.push(y);
		}
	}
}
int dp[N][21],h[N][21];
bool cmp(int a,int b) {
	return bfn[a]<bfn[b];
}
int n;
int query(int x,int k) {
	int t=x,ans=0,_k=k;
	for(int i=20;i>=0;i--) {
		int y=h[x][i];
		if(k>=(1<<i)) ans+=dp[x][i],k-=(1<<i), x=h[x][i];
	}
	int y=x;
	x=t;
	k=_k; 
	for(int i=20;i>=0;i--) {
		if(k>=(1<<i)) x=h[x][i],ans+=((pre_g[x][i][0]-pre_g[y][i][0])*(1<<i)-(pre_g[x][i][1]-pre_g[y][i][1])*(1<<i)),k-=(1<<i);
	}
	return ans;
} 
signed main(){
	n=read();
	for(int i=1;i<=n;i++) v[i]=read();
	for(int i=2;i<=n;i++) {
		int x=read();s[x].push_back(i);s[i].push_back(x);		
	}
	dfs(1,0);bfs();	
	sort(s[1].begin(),s[1].end(),cmp);
	h[1][0]=s[1].back();
	for(int i=2;i<=n;i++) {
		sort(s[i].begin(),s[i].end(),cmp);
		if(s[i].size()==1) h[i][0]=0;
		else h[i][0]=s[i].back();
	}
	for(int i=1;i<=n;i++) {
		for(int j=0;j<d[i].size();j++) {
			if(j==0) dp[d[i][j]][0]=v[d[i][j]],pre[d[i][j]]=0;
			else dp[d[i][j]][0]=dp[d[i][j-1]][0]+v[d[i][j]],pre[d[i][j]]=d[i][j-1],h[d[i][j]][0]=((bfn[h[d[i][j]][0]]<bfn[h[d[i][j-1]][0]])?h[d[i][j-1]][0]:h[d[i][j]][0]);//max(,);
			int x=d[i][j];
			for(int k=0;k<20;k++) {
				for(int t=0;t<2;t++)
				if(j==0) pre_g[x][k][t]=pre_g[x][k][t];
				else pre_g[x][k][t]+=pre_g[d[i][j-1]][k][t];
			}
		}
	}
	for(int j=0;j<20;j++) {
		for(int x=1;x<=n;x++) {
			h[x][j+1]=h[h[x][j]][j];
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=0;j<d[i].size();j++) {
			for(int k=0;k<20;k++) {
				int x=d[i][j];
				if(j==0) h[x][k]=h[x][k];
				else {
					if(bfn[h[x][k]]<bfn[h[d[i][j-1]][k]]) h[x][k]=h[d[i][j-1]][k];
				}
			}
		}
	}
	for(int j=0;j<20;j++) {
		for(int x=1;x<=n;x++) {
			int y=h[x][j];
			dp[x][j+1]=dp[x][j]+dp[y][j]-(pre_g[y][j][1]-pre_g[h[y][j]][j][1])*(1<<j)+(pre_g[y][j][0]-pre_g[h[y][j]][j][0])*(1<<j);
		}
	}
	int Q=read();
	while(Q--) {
		int x=read(),k=read()+1,ans=0;int t1=x,t2=k;
		printf("%lld\n",query(x,k)-query(pre[x],k));
	}
	return 0;
}
```

---

## 作者：xxxxxzy (赞：0)

学习笔记，看的题解的倍增差分做法。

讲一个大概思路，发现贡献是可差分的，按 dfs 序给每个深度排序，维护每个点 $f_{i,x}$ 代表向下跳 $2^i$，$x$ 子树的对应前缀的所有节点产生的贡献。

这个显然是好维护的，设 $pre_x$ 为 $x$ 在这一层的前缀，维护 $g_{i,x}$ 代表从 $x$ 出发跳 $2^i$ 次 dfs 序最大的儿子得到的节点，特殊地，若 $x$ 没有儿子，$g_{0,x}=pre_x$。

然后维护一个 $num_{i,x}$ 代表 $x$ 左下区域，即 $dfn_u \le low_x$ 的所有节点有多少个点权第 $i$ 位等于 $1$。

然后转移是简单的的，就不写了。

时空复杂度 $O(n \log n)$，感觉比较标准，但是我太菜了没见过这种东西。

---


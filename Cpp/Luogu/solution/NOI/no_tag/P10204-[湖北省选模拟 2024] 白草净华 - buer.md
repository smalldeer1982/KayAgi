# [湖北省选模拟 2024] 白草净华 / buer

## 题目背景

**由于洛谷评测环境限制，请勿使用 C++ 14 (GCC 9) 语言提交本题，否则可能会导致编译错误。**

**这是一道交互题。**

神明只送给人类填饱肚子的知识，人类却借此制作了工具，书写了文字，壮大了城邦，现在又放眼星辰与深渊……

他们每时每刻都在创造全新的「知识」，也令我再也无法移开双眼。

我自认为我擅长提问和回答问题，但我渐渐明白，有很多人是揣着明白装糊涂，问题的答案并不能帮上他们的忙。是不是随着年龄增长，大家都会失去面对质问和答案的勇气呢……

## 题目描述

智慧之神布耶尔的知识可以用长度为 $N$ 的数列 $a_0,a_1,\cdots,a_{N-1}$ 表示（请注意，下标从 $0$ 开始）。很遗憾，凡人难以窥探智慧之神的知识，你既不知道 $N$ 的大小，又不知道任何 $a_i$ 的值。

智慧之神是善良的，纳西妲愿意告诉你关于知识的一切：

- 对于任意的 $0 \le i < N$，$a_i \neq a_{(i+1)\bmod N}$。
- **有且仅有一个** $i(0 \le i < N)$，使 $a_i>a_{(i+1)\bmod N}$ 与 $a_i > a_{(i+N-1)\bmod N}$ 同时成立。

你可以向智慧之神提问，每次提问，你可以向纳西妲提供一个 $0\sim10^9$ 范围内的整数 $k$，纳西妲将回答你 $a_{(d+k)\bmod N}$ 的值。其中，$d$ 是上一次纳西妲回答的元素的下标。$d$ 的初始值设定为 $0$。例如，$N=5$，你依次向纳西妲提供了 $1,2,3$，纳西妲回答的数字依次为 $a_1,a_3,a_1$。

你有 $333$ 次提问的机会，你需要求出数列 $a$ 中的最大值。

你，还有质问与提问的勇气吗？

### 实现细节

交互库实现了如下函数，**选手需要在程序中声明这些函数，但不应该实现其函数体**：

```cpp
int ask(int k);
```

- 这个函数返回  $a_{(d+k)\bmod N}$ 的值，并将 $d$ 的值修改为 $d+k$。

```cpp
int cheat();
```

- 这个函数返回 $N$ 的值。
- **调用该函数，将不能得到测试点全部的分数，详见评分方式部分。**

**你不需要，也不应该实现主函数。** 你需要实现函数 `buer`：

```cpp
int buer(int T);
```

- `T` 表示测试点编号。
- 你需要在函数结束时，返回数列 $a$ 的最大值。

**此外，你提交的程序不应试图从或向任何文件或标准控制流读取或写入信息，否则本题以零分计。** 你的程序需要引用全部你所需要的头文件与命名空间。

最终测试时，在每个测试点，交互库会恰好调用一次 `buer` 函数，并将其返回值作为你程序的结果。

下面是一个示例程序，其功能是获取 $a_1 \sim a_9$ 并返回 $\max(a_1,a_2)$。选手可以在此基础上继续实现本题。

```cpp
#include <vector>
using std::max;
using std::vector;
// 引用所需头文件与命名空间中的函数
int ask(int k);
int cheat(); 
// 声明 ask 与 cheat 函数
int buer(int T) {
	vector <int> vec;
	for(int i = 1; i <= 9; i++) {
		int p = ask(1);
		vec.push_back(p);
	}
	return max(vec[0], vec[1]);
}
```

**保证在 `ask` 函数调用不超过 $3333$ 次的情况下，最终测试的交互库运行所需时间不超过 $0.2$ 秒，交互库本身所消耗的内存不超过 $10$ MiB。**

### 测试程序方式

本题目录下提供了交互库的参考实现 `grader.cpp`。最终测试时所使用的交互库实现与该实现有所不同，因此选手的解法**不应依赖交互库的具体实现**。

选手实现程序 `buer.cpp` 后，将 `grader.cpp` 与 `buer.cpp` 放置在同一目录下，使用如下命令编译得到可执行程序：

```plain
g++ -c grader.cpp -O2 -std=c++14
g++ -c buer.cpp -O2 -std=c++14
g++ grader.o buer.o -o buer -O2 -std=c++14
```

其中第一行命令会编译 `grader.cpp` 得到目标文件 `grader.o`，第二行命令会编译 `buer.cpp` 得到目标文件 `buer.o`，第三行命令会将 `grader.o` 与 `buer.o` 链接起来，生成可执行文件 `buer`。

按上述方法编译得到的可执行文件 `buer`，其运行方式如下：

- 可执行文件将从 `buer.in` 读入以下格式的数据：

  - 第一行为两个正整数 $N,T$，分别表示 $a$ 的长度与测试点编号。
  - 第二行为 $N$ 个正整数 $a_0,a_1,\ldots,a_{N-1}$，表示数列 $a$。

- 若你的程序正常运行完毕，可执行文件将向 `buer.out` 写入以下内容：

  - 输出一行两个整数，分别表示你的询问次数与 `buer` 函数的返回值。

选手在调试时需要保证输入可执行文件 `buer` 的数据满足上述格式，否则不保证交互库正确运行。

## 说明/提示

### 样例解释 1

本题提供的样例输入中，第一行为两个整数 $N,T$，分别表示 $N$ 与测试点编号，样例测试点编号均为 $0$。第二行为 $N$ 个整数 $a_0,a_1,\cdots,a_{N-1}$，表示数列 $a$。样例输出为一行一个正整数，表示数列 $a$ 的最大值。

**请注意，你的程序不应试图从或向任何文件或标准控制流读取或写入信息。**

### 评分方式

最终评测**只**收取 `buer.cpp`，请不要提交选手目录下其他文件。

**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 $0$ 分，运行
时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。

在上述条件以外，在一个测试点中，若程序执行了非法的函数调用或 `buer` 函数返回了错误答案，该测试点将会获得 $0$ 分。否则，假设你的程序调用了 $Q$ 次 `ask` 函数：

- 若 $0 \le Q \le 333$，且没有调用 `cheat` 函数，该测试点得 $5$ 分。

- 若 $333<Q\le 3333$，且没有调用 `cheat` 函数，该测试点得 $3$ 分。

- 若 $0\le Q \le 333$，但调用了 `cheat` 函数，该测试点得 $2$ 分。

- 若 $333<Q\le 3333$，但调用了 `cheat` 函数，该测试点得 $1$ 分。
- 若 $Q>3333$，该测试点得 $0$ 分。

### 子任务

对于所有测试数据，保证 $2 \le N \le 10^6$，$1 \le a_i \le 10^9$。

| 测试点编号 | $N\le$ |
| :--: | :--: |
| $1$ | $333$ |
| $2\sim 20$ | $10^6$ |

## 样例 #1

### 输入

```
4 0
1 2 3 2```

### 输出

```
3```

# 题解

## 作者：ottora (赞：30)

考虑随机化。

先随机 $m$ 次询问，再枚举序列长度 $n$ 并检查是否合法。

注意到长度为 $m$ 的循环单峰排列是 $O\left(n^3\right)$ 的（[A060354](https://oeis.org/A060354)），因此当 $m = O\left(\log N\right)$ 时即可求出唯一的 $n$。

之后倍增求最大值是简单的。

期望询问次数 $O\left(\log N\right)$，实际上非常优秀，在本题数据范围下几乎不超过 $100$ 次询问。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int ask(int);
int cheat();
vector<int> B; vector<int64_t> X;
vector<pair<int, int>> V;
bool check(int n, int q){
  V.clear();
  for(int i = 0; i <  q; i++) V.emplace_back(X[i] % n, B[i]);
  sort(V.begin(), V.end());
  for(int i = 0; i <  q; i++)
    if(V[i].first == (V[(i + 1) % q].first) && V[i].second != (V[(i + 1) % q].second)) return 0;
  V.erase(unique(V.begin(), V.end()), V.end()), q = V.size();
  if(q > 2) for(int i = 0; i <  q; i++)
    if(V[i].second == V[(i + 1) % q].second && V[i].second == V[(i + 2) % q].second) return 0;
  int mx = 0, mn = 0;
  for(int i = 0; i <  q; i++) if(V[i].second > V[mx].second) mx = i;
  for(int i = 0; i <  q; i++) if(V[i].second < V[mn].second) mn = i;
  for(int i = mn, lst = INT_MIN; i != mx; ++i >= q && (i = 0))
    if(V[i].second < lst) return 0; else lst = V[i].second;
  for(int i = mx, lst = INT_MAX; i != mn; ++i >= q && (i = 0))
    if(V[i].second > lst) return 0; else lst = V[i].second;
  return 1;
}
int buer(int){
  mt19937 rnd(time(0));
  vector<int> Ans;
  for(int i = 2; i <= 1000000; i++) Ans.push_back(i);
  int64_t x = 0;
  for(int q = 1; Ans.size() > 1; q++){
    int k = rnd() % 1000000000 + 1;
    X.push_back(x += k), B.push_back(ask(k));
    if(q > 5){
      vector<int> Now;
      for(int i: Ans) if(check(i, q)) Now.push_back(i);
      Ans = Now;
    }
  }
  int n = Ans.back(), id = 0;
  for(int i = 0; i < (int)X.size(); i++) if(B[i] > B[id]) id = i;
  int p = ask((X[id] - x) % n + n), q = ask(1); id = (X[id] + 1) % n;
  if(p < q){
    int v = q;
    for(int k = 20; k >= 0; k--){
      p = ask(1 << k), q = ask(1);
      if(v < p && p < q) id = (id + (1 << k) + 1) % n, v = q;
      else ask((n - (1 << k) - 1) % n + n);
    } return max(v, ask(1));
  } else {
    int v = q;
    for(int k = 20; k >= 0; k--){
      p = ask((n - (1 << k)) % n + n), q = ask(n - 1);
      if(v < p && p < q) id = (id + n * 2 - (1 << k) - 1) % n, v = q;
      else ask((1 << k) + 1);
    } return max(v, ask(n - 1));
  }
  return 0;
}
```

---

## 作者：zyn_ (赞：13)

## $0$

纳西妲：你好呀，旅行者！

我：啊，是你呀，纳西妲！等等……我现在在哪里？

纳西妲：你在梦境中呢。今天我来梦中找你，是为了这么一件事——

纳西妲：最近，我发明了一个游戏，希望能通过梦境与须弥的孩子们玩这个游戏。然而我不能确定这个游戏的难度：如果太困难了，孩子们就会觉得无聊！因此，我找到了聪明的你，你能协助我测试一下这个游戏吗？

我：好吧，我很乐意。

纳西妲：那你听清楚游戏规则哦！

## $1$

纳西妲：首先，我会想好一个正整数序列 $a_0,a_1,\dots,a_{n-1}$。不过，我不会告诉你任何一项 $a_i$，我也不会告诉你 $n$ 的值。$a_i$ 最大不超过 $10^9$，而 $n$ 在 $1$ 到 $10^6$ 之间。

纳西妲：但是，我向你保证，对于任意 $0\le i\lt n$，有 $a_i\neq a_{(i+1)\bmod n}$；并且，**有且仅有一个 $i$**（$0\le i\lt n$），使 $a_i\gt a_{(i+1)\bmod n}$ 与 $a_i\gt a_{(i+n-1)\bmod n}$ 同时成立。

纳西妲：现在我有一个数 $d$，它的初始值为 $0$。你可以向我询问，给定一个 $0$ 与 $10^9$ 之间的整数 $k$，我会令 $d\gets (d+k)\bmod n$，然后告诉你 $a_d$ 的值。

纳西妲：你要如何获得游戏的胜利呢？你需要在 $333$ 次询问内求出序列 $a$ 中的最大值。

纳西妲：好了，现在我已经想好序列 $a$ 了。游戏，开始！

我：（能记住长达 $10^6$ 的序列 $a$，这就是神明的记忆力吗……）

## $2$

首先，这个询问的形式……相当于 $a$ 是一个环形序列，有一个指针，我每次只能将指针**向同一个方向（不妨假设是顺时针）移动**，然后获得当前指针指向的数的值。

求出序列 $a$ 的最大值……这很像一个**二分**的问题，而且 $333$ 次询问的限制，似乎也指向一个 $O(\log n)$ 的做法。

看起来，单独一个数不能给我带来任何关于最大值的位置的信息。如果考虑**相邻两个数**呢？

设 $p_i=(a_i,a_{i+1})$，并定义 $f((x,y))=[x<y]$，即若 $x<y$ 则此式为 $1$，否则为 $0$。有一个简单的想法：如果 $f(p_i)=1$ 但 $f(p_j)=0$，似乎就可以确定最大值在 $p_i$ 与 $p_j$ 之间了……

但是如何再次将指针拨回 $p_i$ 与 $p_j$ 之间呢？否则二分可无法进行。我不能将指针反方向拨动，看来需要**求出 $n$ 的值**呢。

$n$ 的值也能二分求出吗？有一个困难：如果纳西妲想的 $n$ 其实很小，那么我询问一个大一点的 $k$，指针就会转很多圈，就不好把握它的位置了。然而 $n$ 很大时，询问的 $k$ 又不能太小……

看来，可以尝试不断增大 $k$ 的值……嗯，是不是可以考虑**倍增**？

假设下标 $\bmod n$ 理解。我可以依次询问 $p_0,p_1,p_2,p_4,p_8,p_{16},\dots$，通过 $p_0,p_{2^m},p_{2^{m+1}}$ 我是不是可以知道什么？

欸，原来我可以**判断任意三个 $p_i$ 的相对顺序**，我可以知道三个 $p_i$ 是顺时针还是逆时针排列！比如 $p_i=(6,9),p_j=(4,2),p_k=(11,7)$，那么 $p_i,p_j,p_k$ 就是逆时针依次排列。不过看起来需要分类讨论？

我想起了三个字：「不妨设」！通过一些假设，可以大量减少分类讨论的情况数。设三对数是 $p_i,p_j,p_k$，可以假设它们互不相同。由抽屉原理，不妨 $f(p_i)=f(p_j)=1$。交换 $p_i,p_j$ 恰好反转这三对数的方向，因此可以设 $a_i\lt a_{i+1}\lt a_j\lt a_{j+1}$。此时若 $f(p_k)=0$ 则为顺时针，若 $f(p_k)=1$ 则当且仅当 $p_k$ 在 $p_i$ 与 $p_j$ 之间时为逆时针。

$m$ 小时，$p_0,p_{2^m},p_{2^{m+1}}$ 当然是顺时针排列。考虑最小的 $m$ 使 $p_0,p_{2^m},p_{2^{m+1}}$ 逆时针排列。我可以得到……$2^m\lt n\lt 2^{m+1}$！当然，如果有一个 $m$ 使 $p_0=p_{2^m}$，那么 $n=2^m$，这是容易的。

这样，我就用 $O(\log n)$ 次询问得到了 $n$ 的一个范围。接下来可以二分了，因为现在 $n$ 的可能最大值与最小值相差不到 $2$ 倍，$k$ 的大小应该好把控不少。

现在我不必关心 $a_0$ 的位置，我可以不妨将现在指针所在的位置当作 $a_0$。既然知道 $2^m\lt n\lt 2^{m+1}$，我二分检验 $s$，询问 $p_0,p_{2^m},p_{s}$（$2^m\lt s\lt 2^{m+1}$）。如果 $p_0=p_s$ 显然 $n=s$，否则我**断言 $n\gt s$ 当且仅当 $p_0,p_{2^m},p_{s}$ 按顺时针排列**。这个断言正确吗？

是正确的！因为 $2^m\lt n,s\lt 2^{m+1}$，所以从 $p_0$ 到 $p_{2^m}$ 到 $p_s$ 至多只能转过序列一圈，并且不能第二次到达 $p_{2^m}$。用代数式表达，如果 $n\lt s$，那么一定有 $0\lt s\bmod n\lt 2^m$，从而 $p_0,p_{2^m},p_{s}$ 按逆时针排列。

现在我可以用 $O(\log n)$ 次询问得到 $n$ 的值了！

（进行了若干次询问，得到了 $n$ 的值。）

我：纳西妲，现在我已经知道 $n$ 的值了——就是……，对吧？

纳西妲：嗯……现在可还不能告诉你对错！

## $3$

得到了 $n$ 的值，下一步就是求序列 $a$ 中的最大值了，大概还需要二分吧。

与之前的做法一样，我仍然可以假设指针当前指向 $a_0$。不过，知道了 $n$ 以后，每次询问的是序列的哪一项就清楚了，因此我可以随时询问自己想要的位置了。

仍沿用之前 $p_i$ 的定义。设最大值为 $a_t$。二分验证 $s$ 时，如果 $s\neq t$，那么 $s\lt t$ 当且仅当 $p_0,p_s,p_t$ 按顺时针排列。然而我不可能在此时知道 $p_t$！那该如何判定 $s$ 和 $t$ 的大小关系呢？

那我可以假设序列 $a$ 的最大值很大。我可以把 $p_t$ 改成一对很大很大的数，比如 $(M,M-1)$，其中 $M>10^9+7$ 甚至**超出了值域**！这样会对判定造成什么影响呢？

欸，效果似乎很好！我发现，这时 $p_0,p_s,(M,M-1)$ 按顺时针排列等价于 $s\lt t$，而 $p_0,p_s,(M,M-1)$ 按逆时针排列，就是 $p_0,(M,M-1),p_s$ 按顺时针排列，等价于 $s\ge t$。没错，这个不等关系的等号恰好可以取！

那不是直接二分就 $O(\log n)$ 次询问了？这样总询问次数怎么样都到不了 $333$ 吧？让我试试……

（使用二分法，向纳西妲进行了若干次询问。）

我：现在我知道序列 $a$ 中的最大值了。它就是……！对吗？

纳西妲：嗯……你的回答是——

纳西妲：正确的！

## $4$

纳西妲：旅行者，你认为这个游戏的难度如何？

我：对我来说还行，但是对孩子们，或许有些困难。

纳西妲：是吗……看来我要想办法降低一下游戏难度呢。总之，感谢你的协助，旅行者！再见！

---

梦醒了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define M 2024102700
int n,a,b,c,d,e,f;
int ask(int);
int cheat();
int buer(int);
struct ll{int u,v;friend bool operator==(const ll&a,const ll&b){return a.u==b.u&&a.v==b.v;}};
int dir(ll a,ll b,ll c){
	// returns 1 if a->b->c, 0 if a->c->b,
	// 2 if a=b, 3 if b=c, 4 if c=a
	if(a==b)return 2;
	if(b==c)return 3;
	if(c==a)return 4;
	int p=1;
	if(a.u>a.v)swap(a.u,a.v),swap(b.u,b.v),swap(c.u,c.v),p^=1;
	if(b.u>b.v&&c.u>c.v){
		if(b.u<c.u)p^=1;
		return p;
	}
	if(b.u>b.v)swap(b,c),p^=1;
	if(a.u>b.u)swap(a,b),p^=1;
	if(c.u>c.v)return p;
	if(a.u<c.u&&c.u<b.u)p^=1;
	return p;
}
int buer(int T){
	int n=0,i,a,b,c,d,e,q,l,r,mid;
	a=ask(0);b=ask(1);c=ask(1);
	if(a==c)return max(a,b);
	ll f={a,b},g={b,c},h;
	for(i=0;;++i){
		d=ask((1<<i)-1);e=ask(1);h={d,e};
		q=dir(f,g,h);
		if(q==4){n=(1<<(i+1));break;}
		if(q==0){l=(1<<i);r=(1<<(i+1))-1;break;}
		g=h;
	}
	if(!n){
		while(l<r){
			mid=(l+r)>>1;
			a=ask(0);b=ask(1);f={a,b};
			c=ask((1<<i)-1);d=ask(1);g={c,d};
			d=ask(mid-1-(1<<i));e=ask(1);h={d,e};
			q=dir(f,g,h);
			if(q==4){n=mid;break;}
			if(q==3){n=mid-1;break;}
			if(q==1)l=mid+1;
			else r=mid-1;
		}
		if(!n)n=l;
	}
	a=ask(0);b=ask(1);c=ask(1);
	if(b>a&&b>c)return b;
	c=ask(n-3);
	if(a>b&&a>c)return a;
	ask(1);
	f={a,b};h={M,M-1};
	l=1;r=n-2;
	while(l<r){
		mid=(l+r+1)>>1;
		d=ask(mid);e=ask(1);g={d,e};
		q=dir(f,g,h);
		if(q==1)l=mid;
		else r=mid-1;
		ask(n-mid-1);
	}
	return ask(l+1);
}
```

---

## 作者：览遍千秋 (赞：3)

本题解为官方题解。

---

首先，将数组放到一个环上，根据条件，这个环上相邻两项不相同，且只存在一个局部最大值。即这个环由一段单调递增的部分和一段单调递减的部分组成。
		
虽然环上单调递增部分和单调递减部分可能存在大小相同的数，但环上相邻两项组成的有序对 $(a_i,a_{(i+1)\bmod n})$ 对于不同的 $i$ 一定是不同的。
		
我们将环上的一个这样的有序对 $(x,y)$ 称为环上的一个指针。
		
结论：当环上存在三个不同的指针时，可以判断三个指针间的相对位置关系。即判断三个指针在环上的相对位置关系为 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 或 $1 \rightarrow 3 \rightarrow 2 \rightarrow 1$。

证明：在下图中，设逆时针方向为数组坐标增大的方向，三个指针分别为 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$

![](https://cdn.luogu.com.cn/upload/image_hosting/b3k0667c.png)

如果三个指针的 $y$ 都小于 $x$，如图中第一种情况，不妨设 $x_1 > x_2 > x_3$，那么指针间的关系为 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$。
		
如果三个指针有两个 $y$ 小于 $x$，一个 $y$ 大于 $x$，如图中第二种情况，不妨设指针 $1,2$ 的 $y$ 小于 $x$，$x_1 > x_2$，指针 $3$ 的 $y$ 大于 $x$，那么指针间的关系为 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$。
		
对于三个指针中有一个 $y$ 小于 $x$，两个 $y$ 大于 $x$ 和三个 $y$ 大于 $x$ 的情况同理可以判断三个指针的相对位置关系。
		
如此可以用倍增和二分的方式求出 $n$ 的值：首先记录 $(a_0,a_1)$，$(a_1,a_2)$ 和 $(a_2,a_3)$ 三个指针。如果第三个指针和第一个指针相等，说明 $n = 2$，否则说明 $n>2$。随后不断倍增第二个和第三个指针。即保持第一个指针不变，第 $x$ 次让第二个指针取 $(a_{2^{x-1}},a_{2^{x-1}+1})$，第三个指针取 $(a_{2^x},a_{2^x+1})$。

如下图，设逆时针方向为数组坐标增大的方向，当三个指针从 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 构型转变为 $1 \rightarrow 3 \rightarrow 2 \rightarrow 1$ 构型时，即为 $a_{2^x}$ 第一次超过 $n$ 的位置。然后，可以在 $a_{2^{x-1}}$ 和 $a_{2^x}$ 之间二分，保持第二个指针不动，二分第三个指针的位置，得出 $n$ 具体的值。

![](https://cdn.luogu.com.cn/upload/image_hosting/cym8i4xx.png)

二分时，由于交互中 $d$ 的变化量 $k$ 必须为正，如果二分得到的 $mid$ 超过了答案，存在无法倒退指针使 $d$ 到达新的 $mid$ 的问题。但由于这里只考虑三个指针间的相对位置关系，在已知三个指针在环上的相对距离的情况下，无需考虑第一个指针在环上的真正位置。此时可以将当前位置的 $d$ 作为新的第一个指针，并在环上移动到新的第二个指针和第三个指针的位置继续二分。
		
由此即可求出 $n$ 的准确值。接下来继续通过二分的方式找到数组的最大值。
		
在数组中找到任意一个指针，在 $1$ 到 $n-1$ 间二分第二个指针与第一个指针的相对距离。

设第一个指针（红色）为 $(x_1,y_1)$，第二个指针（蓝色）为 $(x_2,y_2)$。设逆时针方向为数组坐标增大的方向。

![](https://cdn.luogu.com.cn/upload/image_hosting/6fu7izzd.png)

若 $y_1<x_1$，如图中第一种情况。当 $y_2<x_2$ 时，若 $x_2<x_1$，则第二个指针未到达最大值的位置。否则第二个指针已经超过最大值的位置。当 $y_2>x_2$ 时，第二个指针未到达最大值的位置。
		
若 $y_1>x_1$，如图中第二种情况。当 $y_2>x_2$ 时，若 $x_2<x_1$，则第二个指针已经超过最大值的位置。否则第二个指针未到达最大值的位置。当 $y_2<x_2$ 时，第二个指针已经超过最大值的位置。

由此即可二分得到最大值的位置。特判掉第一个指针本身是最大值的情况，即可得到数组 $a$ 的最大值。总交互次数根据实现的不同在 $10 \cdot \log(n)$ 到 $16 \cdot \log(n)$ 之间，可以通过此题。

---


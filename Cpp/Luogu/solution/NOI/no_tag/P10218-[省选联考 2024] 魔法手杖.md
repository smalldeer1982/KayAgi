# [省选联考 2024] 魔法手杖

## 题目描述

**提示：** 我们在题目描述的最后提供了一份简要的、形式化描述的题面。

C 城是一座魔力之都，以最高的魔法师水平闻名。对于一名魔法师而言，最重要的固然是魔法手杖和镶嵌在手杖上的魔法水晶。

每个魔法手杖和魔法水晶都可以用**魔力值**来衡量其能力大小，一个魔法手杖的魔力值是镶嵌在其上的所有魔法水晶中魔力值的最小值。

小 $\omega$ 是 C 城的一名见习魔法师，他想加强他的魔法手杖。在加强之前，小 $\omega$ 的魔法手杖镶嵌着 $n$ 颗魔法水晶，它们的魔力值分别为 $a_1,a_2,\dots,a_n$。

小 $\omega$ 准备使用一次强力的秘术来加强他的手杖。这一次秘术中，他可以任意选择 $x$，然后将所有魔法水晶的魔力值由 $a_i$ 变为 $(a_i \oplus x)$，其中 $\oplus$ 表示按位异或。由于小 $\omega$ 能力有限，$a_1,a_2,\dots,a_n$ 和 $x$ 都是 $[0,2^k-1]$ 中的整数。

小 $\omega$ 还发现这个秘术可以定向加强。具体地，他可以花费 $b_i$ 的体力值对第 $i$ 个魔法水晶进行定向加强，将原本应变为 $(a_i \oplus x)$ 的魔力值变为 $(a_i+x)$。小 $\omega$ 能力有限，因此他定向加强所花费的体力值总和不能超过 $m$，且每个水晶只能被定向加强至多一次。

小 $\omega$ 想知道他在加强魔法手杖后，魔法手杖的魔力值最大能为多少，但他并不会算，所以请你来帮他计算。

**形式化的：** 给定 $a_1,a_2,\dots,a_n$ 以及 $b_1,b_2,\dots,b_n$，满足 $a_i \in [0,2^k-1]$ 以及 $b_i\geq 0$，你需要给出 $S \subseteq \{1,2,\dots,n\}$ 以及 $x \in [0,2^k-1]$ 满足以下条件：

- $\sum \limits_{i\in S} b_i\leq m$；
- 满足以上条件的前提下，最大化 $val(S,x)=\min(\min \limits_{i \in S}(a_i+x),\min \limits_{i \in U \backslash S}(a_i \oplus x))$ 的值。

你只需要给出最大的 $val(S,x)$ 的值即可。

## 说明/提示

**【样例 1 解释】**

- 对于第一组数据，一种可行的方案为：定向强化魔法水晶 $5$（即 $S=\{5\}$）并取 $x=4$，最后得到的魔法水晶魔力值分别为 $5,5,6,7,11$，故魔法手杖的魔力值为 $5$。可以证明不存在更优方案。
- 对于第二组数据，一种可行的方案为：定向强化魔法水晶 $1$（即 $S=\{1\}$）并取 $x=1$。

**【样例 2】**

见附件中的 `xor2.in/ans`。

该组样例满足 $c=4$。

**【样例 3】**

见附件中的 `xor3.in/ans`。

该组样例满足 $c=7$。

**【样例 4】**

见附件中的 `xor4.in/ans`。

该组样例满足 $c=9$。

**【样例 5】**

见附件中的 `xor5.in/ans`。

该组样例满足 $c=11$。

**【样例 6】**

见附件中的 `xor6.in/ans`。

该组样例满足 $c=14$。

**【样例 7】**

见附件中的 `xor7.in/ans`。

该组样例满足 $c=22$。

**【子任务】**

设 $\sum n$ 表示单组测试点各组数据 $n$ 的和。对于所有测试数据，
- $T \geq 1$；
- $1 \leq n \leq 10^5$，$1 \leq \sum n \leq 5\times 10^5$；
- $0 \leq m \leq 10^9$；
- $0 \leq k \leq 120$；
- $\forall 1 \leq i \leq n, 0 \leq a_i<2^k$；
- $\forall 1 \leq i \leq n, 0 \leq b_i \leq 10^9$。

| 测试点编号 | $\sum n \leq$ | $n \leq$ | $m \leq$ | $k \leq$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $10$ | $10$ | $10^9$ | $10$ | / |
| $4\sim 6$ | $5\times 10^5$ | $10^5$ | $0$ | $30$ | A |
| $7,8$ | $5\times 10^5$ | $2$ | $10^9$ | $30$ | B |
| $9,10$ | $5\times 10^5$ | $10^5$ | $10^9$ | $30$ | B |
| $11\sim 13$ | $5\times 10^5$ | $10^5$ | $10^9$ | $30$ | C |
| $14,15$ | $500$ | $10^2$ | $10^9$ | $30$ | / |
| $16\sim 18$ | $5\times 10^4$ | $10^4$ | $10^9$ | $60$ | / |
| $19\sim 21$ | $3\times 10^5$ | $10^5$ | $10^9$ | $120$ | / |
| $22\sim 25$ | $5\times 10^5$ | $10^5$ | $10^9$ | $120$ | / |


- 特殊性质 A：$m=0$；$\forall 1 \leq i\le n, b_i\geq 1$；
- 特殊性质 B：$m=1$；$\forall 1 \leq i\le n, b_i \in \{1,2\}$，且至多只有一个 $i$ 满足 $b_i=1$；
- 特殊性质 C：$m=1$；$\forall 1 \leq i\le n, b_i \in \{1,2\}$。

**【提示】**

本题输入文件较大，请使用较为快速的输入方式。

在评测环境中，你可以使用 $128$ 位有符号整数类型 `__int128`，它可以存储范围在 $[-2^{127},2^{127}-1]$ 内的整数，使用方法与其他整型类型基本一致。

需要注意，此类型无法使用诸如 `cin/cout` 或 `scanf/printf` 等常规输入输出方式进行输入输出。我们在选手目录下提供了一份 `__int128` 的输入输出函数实现供选手选择使用。

## 样例 #1

### 输入

```
1 2
5 2 3
1 1 2 3 7
1 1 0 3 2
1 1 1
1
0```

### 输出

```
5
2```

# 题解

## 作者：AC_Evil (赞：76)

退役三年选手回来做了下～

这题直观感觉很吓人，其实看到异或就可以往 Trie 树上思考了。

这题有两个未知量 $S$ 和 $x$，其中 $S\subseteq [n]$，$x\in[0,2^k)\cap\Z$，状态过于复杂，肯定不能枚举，从答案的角度考虑。首先直观感受是有点像二分，其实我们可以从高位往低位确定答案 $ans$。

分析一下得出结论：$ans$ 的二进制长度最长为 $k+1$ 位（注意这里是个特殊情况），当且仅当 $\sum b_i\le m$，这个时候根据贪心，取 $x=2^k-1$ 即可，此时 $ans=\min\{b_i\}+x$。

否则，$ans$ 最长为 $k$ 位，我们可以从高往低确定 $ans$。假设当前正在讨论第 $d$ 位，根据贪心，我们需要判断第 $d$ 位是否可以为 1。假如我们把所有的 $a_i$ 插入一棵 Trie 树，对于 $val(S,x)=\min(\min \limits_{i \in S}(a_i+x),\min \limits_{i \in U \backslash S}(a_i \oplus x))$，我们称由 $+$ 部分和 $\oplus$ 部分组成。如果希望结果越大，也就是两个部分必须超过 $ans$ 才可以。

这个时候，我们需要先确定 $x$ 的第 $d$ 位的取值，我们分 $x=0$ 和 $x=1$ 两种情况。在此基础上，$S$ 的决策会影响 $ans$ 的第 $d$ 位。我们需要仔细分析一下，看一看能不能变成一个判定性问题。

假设此时在 Trie 树上的节点 $u$，如果左右孩子都存在，当 $x$ 取 0 时，左子树的所有值在 $\oplus$ 部分会贡献出 $ans=0$，右子树的所有值在 $\oplus$ 部分会贡献出 $ans=1$，此时我们可以考虑将左子树移到 $+$ 部分，尝试一下 $ans$ 变成 1。考虑下影响：$S$ 中的最小值更新了，这里用 $y$ 表示，那么需要满足两个条件：1、左子树的 $b$ 的和不超过剩余值（初始值位 $m$）；2、$+$ 部分必须超过当前的 $ans$（$ans$ 未确定部分全部置成 0，$x$ 未确定部分全部置成 1，极端情况的考虑）。只有这两个条件满足了，才能确定 $ans$ 的第 $d$ 位可以为 1，那么递归右子树，继续确定 $d-1$ 位。$x$ 取 1 时刚好对称。

所以得到了一个 `贪心+dfs` 的思路。先判断 $ans$ 是否可以为 1，如果可以需要递归两种情况（合法时才递归），否则 $ans$ 为 0，此时 $x$ 取 0 时右子树可以忽略，递归左子树，反之亦然。也是两种情况。注意一下边界（$d=-1$ 或者 $u$ 是空节点）。

利用 Trie 维护 $a$ 的 $\min$ 和 $b$ 的和，最终时间复杂度 ${\rm O}(\sum nk)$，空间复杂度 ${\rm O}(nk)$。代码想清楚的话很好写。

由于官方数据还没出来，大样例和民间数据都过了，先占个位置。代码有问题回头再修改。

```cpp
#include<bits/stdc++.h>
using namespace std;

void read(__int128 &x){
    // read a __int128 variable
    char c; bool f = 0;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') { f = 1; c = getchar(); }
    x = c - '0';
    while ((c = getchar()) >= '0' && c <= '9') x = x * 10 + c - '0';
    if (f) x = -x;
}
void write(__int128 x){
    // print a __int128 variable
    if (x < 0) { putchar('-'); x = -x; }
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

typedef long long ll;
const int N = 1e5 + 5, K = 120 + 5;
int T, c, n, m, k, ch[N * K][2], cnt;
int b[N]; ll sumb[N * K];
__int128 a[N], mina[N * K], ans;
int nnode() {
    cnt++;
    ch[cnt][0] = ch[cnt][1] = 0;
    mina[cnt] = (__int128)1 << k;
    sumb[cnt] = 0;
    return cnt;
}
void solve(int o, int d, int t, __int128 x, __int128 y, __int128 z) {
    if (d == -1) {
        ans = max(ans, z);
        return;
    }
    __int128 bit = (__int128)1 << d, mask = bit - 1;
    if (!o) {
        ans = max(ans, y + (x | mask | bit));
        return;
    }
    int lc = ch[o][0], rc = ch[o][1];
    bool flag = false;
    if (sumb[lc] <= t && (x | mask) + min(y, mina[lc]) >= (z | bit))
        solve(rc, d - 1, t - sumb[lc], x, min(y, mina[lc]), z | bit), flag = true;
    if (sumb[rc] <= t && (x | mask | bit) + min(y, mina[rc]) >= (z | bit))
        solve(lc, d - 1, t - sumb[rc], x | bit, min(y, mina[rc]), z | bit), flag = true;
    if (flag) return;
    solve(lc, d - 1, t, x, y, z);
    solve(rc, d - 1, t, x | bit, y, z);
}
int main() {
    freopen("xor.in", "r", stdin);
    freopen("xor.out", "w", stdout);
    scanf("%d%d", &c, &T);
    while (T--) {
        scanf("%d%d%d", &n, &m, &k);
        for (int i = 1; i <= n; i++) read(a[i]);
        for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
        cnt = 0; nnode();
        __int128 MAX = (__int128)1 << k;
        mina[0] = MAX;
        for (int i = 1; i <= n; i++) {
            int u = 1;
            sumb[u] += b[i];
            mina[u] = min(mina[u], a[i]);
            for (int j = k - 1; ~j; j--) {
                int x = a[i] >> j & 1;
                if (!ch[u][x]) ch[u][x] = nnode();
                u = ch[u][x];
                mina[u] = min(mina[u], a[i]);
                sumb[u] += b[i];
            }
        }
        ans = 0;
        if (sumb[1] <= m)
            ans = mina[1] + MAX - 1;
        else
            solve(1, k - 1, m, 0, MAX, 0);
        write(ans); putchar('\n');
    }
    return 0;
}
```

---

## 作者：UniGravity (赞：33)

## Solution P10218 [省选联考 2024] 魔法手杖
### 前言
本人水平有限，考试时只想出来了最简单的暴力。本篇题解参考了[Liuxizai](https://liuxizai.ac.cn/archives/solution-lg10218.html)和[AC_Evil](https://www.luogu.com.cn/article/rl47y9yv)的题解，在此表示非常感谢。

本篇题解旨在将 Trie 树上贪心的过程讲的更加清楚。

### 做法
对于异或，可以想到使用 01Trie。

01Trie 有一个思想就是逐位确定答案的值，可以从这个角度思考，考虑求出 $val(S,x)$ 的每一位值。

发现一个性质，$a\oplus b\le a+b$。

首先判断掉特殊情况，对于 $\sum_ib_i\le m$ 显然可以全部选择，答案即为 $\min\{a_i\}+2^k-1$，因为此时 $x$ 越大越好。

接下来考虑在 01Trie 上贪心。记节点 $u$ 的子树中 $a$ 的最小值为 $mina_u$，$b$ 的和为 $sumb_u$。因为求和时只与 $a$ 的最小值有关，计算代价时与 $b$ 的和有关。

我们设计这样一个函数 $\text{dfs}(idx,dep,amin,bsum,x,ans)$ 表示节点为 $idx$，$dep$ 为当前位，$amin$ 表示按加法计算的 $a$ 的最小值，$bsum$ 表示花费的代价，即按加法计算的 $b$ 的值，$x$ 和 $ans$ 是需要贪心求出的答案。

贪心分为以下几种情况：
- 因为要求最大的答案，所以首先判断 $ans$ 的第 $dep$ 位是否能为 $1$，如果则一定要为 $1$。如果为 $1$，则左右子树必须有一个为加法运算，否则异或无法使得二者的第 $dep$ 位均为 $1$。
  - 假设左子树是加法运算，首先需要保证代价在范围内，即 $bsum+sumb_{ls}\le m$。接下来判断是否能满足 $a_i+x\ge ans$ 的条件，因为优先保证条件满足，所以对于这个式子我们需要让 $x$ 尽量大，$ans$ 尽量小。那么 $x$ 的小于 $dep$ 的非确定位则全部置为 $1$，$ans$ 的非确定位置为 $0$。判断条件即为 $\min\{amin,mina_{ls}\}+(x\mid (2^k-1))\ge(ans\mid 2^k)$。那么 $amin$ 更新为 $\min\{amin,mina_{ls}\}$，$ans$ 变为 $ans\mid2^k$。
  - 假设右子树是加法运算，则条件与上述类似，需要注意的是 $x$ 的第 $dep$ 位需要是 1，因为要使得左子树的异或值大于 $ans$。判断条件变为 $\min\{amin,mina_{ls}\}+(x\mid2^k\mid (2^k-1))\ge(ans\mid 2^k)$。
- 否则确定了 $ans$ 这位为 $0$，直接对左右子树分别考虑。
  - $x$ 的第 $dep$ 位为 $0$，此时右子树这一位均为 $1$，均大于等于 $ans$，对答案没有贡献。只需调用 $\text{dfs}(ls,dep-1,amin,bsum,x,ans)$。
  - 否则同理，左子树对答案没有贡献，调用 $\text{dfs}(rs,dep-1,amin,bsum,x\mid2^k,ans)$，注意 $x$ 的值有发生变化。
  
至此这题已全部讲述完毕，时间复杂度是 $O(\sum nk)$，具体细节可以见代码。

### 代码
注意 `__int128` 的运算，同时记得给 $mina_0$ 赋值为 INF。
```cpp
#include <bits/stdc++.h>
#define ll __int128
#define int long long
using namespace std;
inline ll read() {
    ll x = 0, f = 1;
    char c = getchar();
    while (c < '0' || '9' < c) {
        if (c == '-') f = -1;
        c = getchar();
    }
    while ('0' <= c && c <= '9') {
        x = x * 10 + (ll)(c - '0');
        c = getchar();
    }
    return x * f;
}
inline void write(ll x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

const int N = 500005, M = 12000005;
const ll INF = ((ll)1) << ((ll)120);

int n, m, k;
int b[N], ch[M][2], tot, sumb[M];
ll a[N], mina[M], mainans;

inline int add() {
    tot++;
    ch[tot][0] = ch[tot][1] = 0;
    mina[tot] = (ll)1 << k;
    sumb[tot] = 0;
    return tot;
}

inline void insert(ll a, int b) {
    int pos = 1, c;
    mina[pos] = min(mina[pos], a);
    sumb[pos] += b;
    for (int i = k - 1; ~i; i--) {
        c = a >> i & 1;
        if (ch[pos][c] == 0) ch[pos][c] = add();
        pos = ch[pos][c];
        mina[pos] = min(mina[pos], a);
        sumb[pos] += b;
    }
}

inline void solve(int pos, int dep, ll amin, int bsum, ll x, ll ans) {
    if (dep == -1) {
        mainans = max(mainans, ans);
        return;
    }
    ll base = (ll)1 << dep, all = base - 1;
    if (!pos) {
        mainans = max(mainans, amin + (x | all | base));
        return;
    }

    bool f = false; // ans can be 1
    if (bsum + sumb[ch[pos][0]] <= m && min(amin, mina[ch[pos][0]]) + (x | all) >= (ans | base)) {
        solve(ch[pos][1], dep - 1, min(amin, mina[ch[pos][0]]), bsum + sumb[ch[pos][0]], x, ans | base);
        f = true;
    }
    if (bsum + sumb[ch[pos][1]] <= m && min(amin, mina[ch[pos][1]]) + (x | all | base) >= (ans | base)) {
        solve(ch[pos][0], dep - 1, min(amin, mina[ch[pos][1]]), bsum + sumb[ch[pos][1]], x | base, ans | base);
        f = true;
    }
    if (f) return;
    solve(ch[pos][0], dep - 1, amin, bsum, x, ans);
    solve(ch[pos][1], dep - 1, amin, bsum, x | base, ans);
}

inline void work() {
    scanf("%lld %lld %lld", &n, &m, &k);
    ll maxa = (ll)1 << k;
    for (int i = 1; i <= n; i++) {
        a[i] = read();
    }
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &b[i]);
    }
    mainans = 0;
    tot = 0;
    add();
    mina[0] = maxa;
    for (int i = 1; i <= n; i++) insert(a[i], b[i]);
    if (sumb[1] <= m) { // special test
        write(mina[1] + maxa - 1);
        putchar('\n');
        return;
    }
    solve(1, k - 1, maxa, 0, 0, 0);
    write(mainans);
    putchar('\n');
}

signed main() {
    //freopen("xor2.in", "r", stdin);
    //freopen("xor.out", "w", stdout);
    int c, T;
    scanf("%lld %lld", &c, &T);
    while (T--) work();   
    return 0;
}
```

---

## 作者：耳朵龙_ (赞：30)

纪念一下第一道正赛场上想出来的黑题，虽然因为没调出来这题导致 Day 1 崩了。不知道会不会降紫。

答案显然满足二分的性质，考虑二分答案。答案大于等于 $mid$ 当且仅当存在 $0\le x<2^k$ 使得：

+ $\forall i,a_i+x\ge mid$
+ $\sum\limits_{a_i\text{ xor }x<mid}b_i\le m$

第一个条件即为：被定向加强的水晶在秘术后的魔力值大于等于 $mid$（对于未被定向加强的水晶，由于 $a+x=(a\text{ xor }x)+2(a\text{ and }x)\ge (a\text{ xor }x)\ge mid$，其也满足该不等式，因此 $i$ 取遍 $1$ 到 $n$ 即可）。

第二个条件即为：对于满足 $a_i\text{ xor }x<mid$ 的水晶，其必须被定向加强，且消耗的总体力值小于等于 $m$。

记 $mn$ 为 $a$ 序列最小值，则第一个条件即为 $x\ge mid-mn$。对于第二个条件，对于某个 $a_i$，满足 $a_i\text{ xor }x<mid$ 的 $x$ 是 $k$ 段区间，在 Trie 树上子树加即可。具体地，在插入 $a_i$ 时，对于 Trie 上一子树：

+ 若 $mid$ 的该位为 $1$，则该位与 $a_i$ 相同的子树须打上加 $b_i$ 标记，递归考虑该位与 $a_i$ 不同的子树。
+ 若 $mid$ 的该位为 $0$，则该位与 $a_i$ 不同的子树均不需要加 $b_i$，递归考虑该位与 $a_i$ 相同的子树。

按上述做法建出 Trie，搜索是否存在标记和小于等于 $m$ 且位置大于等于 $mid-mn$ 的位置即可，时间复杂度 $O(nk^2)$，期望得分 72 pts。考场上我实现了该做法，但是建 $k$ 次 Trie 太慢了，只得到了 32 pts。

考虑优化该做法。由于每次的 $mid$ 不同导致建树时递归方向不同，每次建出的 Trie 也是不同的，难以优化复杂度。对于位运算，按位确定答案通常是比二分更好的选择，将二分改为从高到低确定答案的每一位，在确定更高位后，若这一位填 $1$ 合法则填 $1$，否则填 $0$，其本质与二分相同，此时复杂度仍为 $O(nk^2)$。

检查第 $q$ 位是否合法时，我们将更低位均视为 $0$，因此不必建出 Trie 树比 $q$ 层还深的地方（那些地方不会进行加法操作）。注意到 Trie 树前 $q$ 层的形态只和答案的前 $q$ 位有关，也就是说此时的 Trie 树只是上一次检查建出的 $q-1$ 层 Trie 树扩展一层叶子得到的。因此在按位确定答案时逐层建出 Trie 即可。时间复杂度 $O(nk)$。场上没调出来，T3 爆蛋了。

代码细节有点多，其中 $mxpos$ 维护不在当前叶子子树中且标记和小于等于 $m$ 的最大 $x$，存在合法 $x$ 当且仅当叶子子树内存在合法 $x$ 或 $mxpos\ge ans-mn$。注意特判掉可以定向加强所有水晶的情况（此时答案为 $mn+2^k-1$，可能大于等于 $2^k$，难以在 Trie 树上处理）。实现时无需建出 Trie，维护叶子即可，空间复杂度 $O(n)$。
```cpp
#include<bits/stdc++.h>
namespace IO{
const int L=(1<<20)+30;
char buf[L],*s,*t,pbuf[L],*p=pbuf;
#define gf() (s==t&&(s=buf)==(t=buf+fread(buf,1,L,stdin))?-1:*s++)
void fl(){fwrite(pbuf,1,p-pbuf,stdout),p=pbuf;}
void pf(char c){if(p-pbuf==L) fl();*p++=c;}
template<typename T>void rd(T&x){
	x=0;char c=gf();
	while(c<48) c=gf();
	while(c>=48) x=x*10+(c^48),c=gf();
}
void wt(__int128 x){
	static int st[40],tp;
	do st[++tp]=x%10,x/=10;while(x);
	while(tp) pf(st[tp--]|48);
	pf(10);
}
}
using IO::rd;
using IO::wt;
using namespace std;
const int N=100005;
int T,n,m,k,b[N],pos[N],idx,id[N*2];
__int128 a[N],mn,ans,mxpos,_mxpos;
long long val[N],_val[N*2];
bitset<N*2>vis;
bool flg;
#define E(x) (__int128(1)<<x)
#define ls (p<<1)
#define rs (ls|1)
#define K(a) ((a>>(x+1))<<(x+1))
void calc(int x,int t){
	// 令 ans 的第 x 位为 t，扩展一层 Trie。
	_mxpos=mxpos,flg=0;
	for(int p=0;p<idx;++p) vis[ls]=vis[rs]=0,_val[ls]=_val[rs]=val[p];
	for(int i=1,u,p;i<=n;++i)
		if(u=a[i]>>x&1,p=pos[i],t)
			_val[ls|u]+=b[i],vis[ls|(u^1)]=1;
		else vis[ls|u]=1;
	// 计算此时是否合法。
	__int128 r=E(x);
	for(int i=1,p;i<=n;++i){
		p=pos[i];
		if(vis[ls]) flg|=_val[ls]<=m&&K(a[i])+r>ans-mn;
		else if(_val[ls]<=m) _mxpos=max(_mxpos,K(a[i])+r-1);
		if(vis[rs]) flg|=_val[rs]<=m&&K(a[i])+r*2>ans-mn;
		else if(_val[rs]<=m) _mxpos=max(_mxpos,K(a[i])+r*2-1);
	}
}
void upd(int x,int t){
	// 将刚刚扩展的一层作为新的叶子。
	int _idx=0;mxpos=_mxpos;
	for(int i=0;i<idx*2;++i) if(vis[i]) id[i]=_idx++;
	for(int i=1,u,p;i<=n;++i)
		if(u=a[i]>>x&1,p=pos[i],t)
			val[pos[i]=id[ls|(u^1)]]=_val[ls|(u^1)],a[i]^=E(x);
		else val[pos[i]=id[ls|u]]=_val[ls|u];
	idx=_idx;
}
void work(){
	long long sum=ans=0;
	rd(n),rd(m),rd(k),mn=E(k);
	for(int i=1;i<=n;++i) rd(a[i]),mn=min(mn,a[i]);
	for(int i=1;i<=n;++i) rd(b[i]),sum+=b[i];
	if(sum<=m) return wt(mn+E(k)-1);
	mxpos=-1,val[0]=0,idx=1,memset(pos+1,0,n*4);
	for(int i=k-1;~i;--i){
		ans^=E(i),calc(i,1);
		if(_mxpos<ans-mn&&!flg) ans^=E(i),calc(i,0);
		upd(i,ans>>i&1);
	}
	wt(ans);
}
int main(){
	freopen("xor.in","r",stdin);
	freopen("xor.out","w",stdout);
	rd(T),rd(T);
	while(T--) work();
	return IO::fl(),0;
}
```

---

## 作者：zifanwang (赞：11)

首先有个很显然的 $\mathcal O(nk^2)$ 的做法，即二分答案，然后 trie 树上判断。

对于 trie 树上一颗子树内的判定，考虑当前二分的 $\text{mid}$ 这一位是 $1$ 还是 $0$ 以及 $x$ 这一位填什么。

- 对于 $1$ 的情况，如果填 $0$，那么右儿子仍然合法，左儿子中的数必须要放到集合 $S$ 中。预处理出一个子树内 $a$ 的最小值以及 $b$ 的和，递归到右儿子继续求解。填 $1$ 的情况类似。

- 对于 $0$ 的情况，如果填 $0$，那么右儿子已经满足异或值 $>\text{mid}$，递归到左儿子继续求解。填 $1$ 的情况类似。

发现这种做法每个点只会被遍历一次，可以获得云斗 $92$ & CCF $72$ 分的好成绩。

---

优化的部分就简单了。

考虑怎么优化。发现可以把二分去掉，在子树内贪心考虑如果答案的当前位填 $1$，剩下的位全填 $0$ 是否有解，如果有解就填 $1$，否则填 $0$。

发现判定可以用之前预处理出来的东西 $\mathcal O(1)$ 做，每个点只会被遍历一次。所以时间复杂度 $\mathcal O(nk)$，可以通过此题。

参考代码：
```cpp
#include<bits/stdc++.h>
#define mxn 100003
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
inline int read(){
    int x=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}
inline __int128 read1(){
    __int128 x=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}
inline void print(__int128 a){
    if(a>9)print(a/10);
    putchar(a%10+'0');
}
int c,T,n,m,k,b,sm,tot,f[mxn*120],t[mxn*120][2];
__int128 a,mn,pw[123],A[mxn],s[mxn*120];
void ins(){
    int p=0;
    drep(i,k-1,0){
        if(!t[p][(a>>i)&1])t[p][(a>>i)&1]=++tot,f[tot]=0,s[tot]=a;
        p=t[p][(a>>i)&1],f[p]=min(f[p]+b,m+1),s[p]=min(s[p],a);
    }
}
__int128 solve(__int128 mid,int x,int d,__int128 now,__int128 mn,int sum,bool fl){
    if(sum>m)return 0;
    if(d<0)return mid;
    __int128 ans=0;
    if(pw[d]-1+(fl&&t[x][1]?min(mn,s[t[x][1]]):mn)+now>=mid){
    	ans=max(ans,solve(mid+pw[d],fl?t[x][0]:0,d-1,now+pw[d],fl&&t[x][1]?min(mn,s[t[x][1]]):mn,min(sum+(fl?f[t[x][1]]:0),m+1),fl&&t[x][0]));
	}
    if(pw[d]-1+(fl&&t[x][0]?min(mn,s[t[x][0]]):mn)+now>=mid+pw[d]){
    	ans=max(ans,solve(mid+pw[d],fl?t[x][1]:0,d-1,now,fl&&t[x][0]?min(mn,s[t[x][0]]):mn,min(sum+(fl?f[t[x][0]]:0),m+1),fl&&t[x][1]));
	}
	if(ans)return ans;
	if(pw[d]-1+mn+now>=mid){
		ans=max(ans,solve(mid,fl?t[x][0]:0,d-1,now,mn,sum,fl&&t[x][0]));
	}
	if(pw[d+1]-1+mn+now>=mid){
		ans=max(ans,solve(mid,fl?t[x][1]:0,d-1,now+pw[d],mn,sum,fl&&t[x][1]));
	}
    return ans;
}
signed main(){
    c=read(),T=read();
    pw[0]=1;
    rep(i,1,120)pw[i]=pw[i-1]*2;
    while(T--){
        n=read(),m=read(),k=read();
        rep(i,0,tot)t[i][0]=t[i][1]=0;
        tot=0;
        sm=0,mn=pw[k];
        rep(i,1,n)A[i]=read1();
        rep(i,1,n){
            b=read(),a=A[i];
            ins();
            sm=min(sm+b,m+1),mn=min(mn,a);
        }
        if(sm<=m){
            print(mn+pw[k]-1);
            puts("");
            continue;
        }
        print(solve(0,0,k-1,0,pw[k],0,1));
        puts("");
    }
    return 0;
}
```

---

## 作者：Graphcity (赞：9)

将所有元素按照 $a$ 从小往大的顺序排序。首先特判掉 $\sum_{i}b_i\le m$ 的情况，此时答案等于 $a_1+2^k-1$。剩下的情况，必然有至少一个元素是进行了异或的。

注意到一个性质：$a\oplus x\le a+x$。因此如果 $a_1$ 取的是异或，那么就有 $a_1\oplus x\le a_1+x\le a_k+x$，此时所有取加法的都不可能为最小值。否则 $a_1$ 取的是加法，那么所有取加法部分的最小值就是 $a_1+x$。

我们先考虑 $a_1$ 取加法的情况，考虑二分答案 $mid$，判断是否存在 $x\ge mid-a_1$ 使得：存在一个 $x$ 和一种删数方案使得所有被删数字的 $b$ 之和 $\le m$ 的同时其它数字的 $a\oplus x\ge mid$。

考虑枚举 $x$ 判断是否存在合法解。设 $y=x\oplus mid$，在 Trie 树上找到 $y$ 对应的路径。容易发现，删掉这条路径后，剩下的子树要么 $\oplus x$ 均 $\ge mid$，要么均 $<mid$。我们只需要判断这些 $<mid$ 的子树 $b$ 的和是否 $\le m$ 即可。

考虑优化枚举 $x$ 的过程。注意到所有对应一个空结点的，必删数字之和 $\le m$ 的 $y$，我们只需要保留其对应 $x$ 最大的一个即可。此时所有有效的 $x$ 只有 $O(n)$ 个，通过在 Trie 树从上往下的遍历可以 $O(nk)$ 找到所有的合法 $x$ 并加以判断。

再考虑 $a_1$ 取异或的过程。实际上是一样的，我们只是把对 $x$ 的限制从 $x\ge mid-a_1$ 变成了 $x\oplus a_1\ge mid$ 而已。对于空结点的处理，实际上我们还是找 $a_1\oplus x$ 最大的就行了。总时间复杂度 $O(nk^2)$。

把二分变成从高往低确定每一位的值就可以做到 $O(nk)$。

[Code](https://www.luogu.com.cn/paste/elcgxt52)

---

## 作者：Mophie (赞：8)

退役前写篇题解。

先考虑 $2 \log$ 咋做。

我们尝试去二分答案 $t$，然后两个条件分别考虑。

先考虑第一条限制 $\min \limits_{i \in S}(a_i+x) \le t$，感觉这个 $i \in S$ 很烦啊，咋办呢？

我们发现可以直接去掉，因为 $x \oplus y \le x + y$，所以只要考虑 $\min(a_i+x)$ 即可，言下之意就是前面那部分只要考虑最小的 $a_i$ 就行。

然后后面那部分其实不难处理。考虑在 trie 上面跑一个类似于 dp 的东西，trie 上的节点就表示当前子树的限制还没有处理完，其他都处理完了。

比如说先从根开始以一个类似 BFS 的顺序跑 dp，记录当前的 $x$ 和权值和，然后进行分讨：

- 如果当前答案位为 $1$，那么往其中一棵子树走时另外一棵子树所有的权值都要加上去，然后如果往 $0$ 走，那么 $x$ 这位就是 $1$，反之亦然。

- 如果当前答案位为 $0$，那么往其中一棵子树走时另外一棵子树就不用管了，然后如果往 $0$ 走，那么 $x$ 这位就是 $0$，反之亦然。

于是就轻松的得到了一个 $2 \log$ 的做法。

那么我们现在考虑消除 $\log$，感觉 BFS 的 $\log$ 大概率是省不掉的，尝试去省掉二分答案的那只 $\log$。

我们发现：可以在 BFS 的时候逐位确定答案。

具体来说，我们做到那一层那么答案就确定到哪一层，然后只保留有用的节点。

主要对于一个节点来说，比如说答案确定到了这一层，那么如果当前合法，且子树内全取 $1$ 合法（即加上最小值大于等于答案）那它就是合法的，因为答案后面几位都可以取 $0$，而取 $0$ 必然满足异或的限制。

然后模拟上面的分讨即可。

最后注意特判一下空节点。

时间复杂度 $O(nk)$。

```cpp
#include<bits/stdc++.h>
#define ll __int128
#define L(i, l, r) for (int i = (l); i <= (r); i++)
#define R(i, r, l) for (int i = (r); i >= (l); i--)
using namespace std;
inline ll read() 
{
    ll sum = 0, nega = 1; char ch = getchar(); 
    while(ch > '9' || ch < '0') {if(ch == '-') nega = -1; ch = getchar();}
    while(ch <= '9' && ch >= '0') sum = sum * 10 + ch - '0', ch = getchar();
    return sum * nega; 
}
inline void Write(ll X) 
{
    if(X > 9) Write(X / 10); 
    putchar(X % 10 + '0'); return ;
}
const int N = 1e5 + 9, M = (1e5 + 9) * 121; 
ll n, m, a[N], mn, b[N], k, ans, pown[123];
int ch[M][2], val[M], cnt;
struct node
{
    ll x, y, z; 
}dp[N], lst[N]; 
int ls; 
inline void ins(ll x, int v) 
{ 
    int tt = 0; 
    R(i, k - 1, 0)
    {
        int t = (x >> i) & 1; 
        if(!ch[tt][t]) ch[tt][t] = ++cnt;
        tt = ch[tt][t]; 
        val[tt] = min((int)m + 1, val[tt] + v); 
    }
    return ;
}
inline void init() 
{
    pown[0] = 1; 
    L(i, 1, 122) pown[i] = pown[i - 1] + pown[i - 1]; 
    return ; 
}
ll ss, res; 
inline void solve() 
{
    n = read(), m = read(), k = read();
    L(i, 0, cnt) val[i] = 0, ch[i][0] = 0, ch[i][1] = 0; 
    cnt = 0; ss = 0; ls = 0; ans = 0; res = 0; 
    L(i, 1, n) a[i] = read();
    L(i, 1, n) b[i] = read(), ins(a[i], b[i]), ss = min(ss + b[i], m + 1);
    mn = a[1]; 
    L(i, 1, n) mn = min(mn, a[i]); 
    if(ss <= m) 
    {
        Write(mn + pown[k] - 1); puts(""); return ;
    }
    ls = 1; lst[ls] = node{0, 0, 0}; 
    R(i, k - 1, 0) 
    {
        int cn = 0, u, v, ps; 
        L(j, 1, ls) 
            L(s, 0, 1)
            { 
                u = lst[j].x; v = ch[u][s]; ps = s ^ 1;  
                ll nm = lst[j].y + val[ch[u][ps]], nx = lst[j].z; 
                if(ps) nx += pown[i]; 
                if(nm > m) continue; 
                if(nx + pown[i] - 1 + mn < ans + pown[i]) continue; 
                if(!v) 
                {
                    res = max(res, min(ans + pown[i + 1] - 1, mn + nx + pown[i] - 1)); 
                } 
                dp[++cn] = node{v, nm, nx}; 
            }
        if(cn) ans += pown[i];
        else 
        {
            L(j, 1, ls) 
                L(s, 0, 1)
                { 
                    u = lst[j].x; v = ch[u][s]; 
                    ll nm = lst[j].y, nx = lst[j].z; 
                    if(s) nx += pown[i]; 
                    if(nm > m) continue; 
                    if(nx + pown[i] - 1 + mn < ans) continue; 
                    if(!v) 
                    {
                        res = max(res, min(ans + pown[i] - 1, mn + nx + pown[i] - 1)); 
                    } 
                    dp[++cn] = node{v, nm, nx}; 
            }
        }
        ls = cn; 
        L(j, 1, ls) lst[j] = dp[j];   
    }
    ans = max(ans, res); 
    Write(ans); 
    puts("");
    return ;
}
signed main() 
{
    init(); 
//    freopen("xor.in", "r", stdin);
//    freopen("xor.out", "w", stdout);
    int CC = read(), TT = read();
    L(i, 1, TT) solve(); 
}
```

---

## 作者：ZnPdCo (赞：6)

我们可以想到，答案在**大部分**情况下都是 $k$ 位的（注意，这里和下文中的位指**二进制位**），为什么是大部分情况呢？因为只要我们有一个水晶**不是**定向加强，那么这个水晶的魔力值 $a_i\oplus x$ 则一定不会超过 $k$ 位，因为 $a_i<2^k$，$x<2^k$。

那么小部分情况则是 $\sum_{i=1}^n b_i\le m$，所有水晶都可以定向加强，贪心地取 $x=2^k-1$，答案就是 $\min_{i\in U}(a_i + x)$，这时答案就是 $k+1$ 位的了（$a_i$ 最小值是 $0$ 除外）。

所以特判这种情况。

---

首先考虑只能异或的情况。

这就是一个典型的贪心问题。

考虑构建一颗字典树，然后贪心地从高到低考虑（设最高位为 $k-1$，最低位为 $0$）。假设考虑到了第 $i$ 位，那么枚举 $x$ 在第 $i$ 位的取值，假设枚举这一位是 $1$，那么它的左子树（即这一位为 $0$ 的儿子）就不用走了，因为它们对答案的贡献为 $1$，不是最小值；我们只用走右子树（即这一位为 $1$ 的儿子），因为它们对答案的贡献为 $0$，是最小值。枚举这一位是 $0$ 同理。时间复杂度 $O(nk)$。

---

接着考虑加上加法怎么办。

发现加法有一个性质：$\min_{i\in S}(a_i+x)=\min_{i\in S}(a_i)+x$，所以我们只需要实时记录定向加强中 $a_i$ 的最小值 $\text{minn}=\min_{i\in S}(a_i)$ 即可。

考虑上面的情景，枚举 $x$ 在第 $i$ 位的取值。假设枚举这一位是 $1$，那么它的右子树对答案的贡献是 $0$，我们可以尝试将右子树全部定向加强（变成加法）。假如可以（右子树的花费小于等于当前剩余的体力值），又分为两种情况：

- **右子树变成加法后的** $\text{minn}+x$ 还是不能将这一位变得比左子树答案大。

  这种情况，说明加法的答案是最小值，可以更新答案为 $\text{minn}+x$。

- 右子树变成加法后的 $\text{minn}+x$ 能将这一位变得比左子树答案大。

  这种情况，说明左子树的答案是最小值，我们更新 $\text{minn}$ 后走左子树继续判断。

其上，为了考虑极端情况，我们设 $x$ 的**未确定部分为 $1$**，左子树答案未确定部分为 $0$。

如果右子树的花费大于当前剩余的体力值，那么就不可行，又分为两种情况：

- $\text{minn}+x$ 不能将这一位变得比右子树答案大（注意这里的 $\text{minn}$ 是没有更新右子树的）。

  这种情况，说明加法的答案是最小值，可以更新答案为 $\text{minn}+x$。

- $\text{minn}+x$ 能将这一位变得比右子树答案大。

  这种情况，说明右子树的答案是最小值，我们走右子树继续判断。

其上，枚举 $x$ 这一位是 $0$ 同理。

---

然后可能需要剪剪枝，如果答案的一个位上能够填 $1$ 了，我们就不需要考虑这一位上答案填 $0$ 的情况了。剪完之后就可以拿满分。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define i28 __int128
#define son(x, y) trie[x].son[y]
#define cost(x) trie[x].cost
#define mn(x) trie[x].mn
#define get(x, y) ((x & ((i28)1 << y)) != 0)
#define inf 1e18
const ll N = 1e5 * 120 + 10;


void read(i28 &x){
	// read a __int128 variable
	char c; bool f = 0;
	while(((c = getchar()) < '0' || c > '9') && c != '-');
	if(c == '-'){f = 1; c = getchar();}
	x = c - '0';
	while((c = getchar()) >= '0' && c <= '9')x = x * 10 + c - '0';
	if(f) x = -x;
}
void write(i28 x){
	// print a __int128 variable
	if(x < 0){putchar('-'); x = -x;}
	if(x > 9)write(x / 10);
	putchar(x % 10 + '0');
}

ll c, T, n, m, k;

i28 a[N], mx;
ll b[N];

struct node {
	ll son[2], cost;
	i28 mn;
	void init() {
		cost = 0;
		son[0] = 0;
		son[1] = 0;
		mn = (i28)1 << k;
	}
} trie[N];
ll cnt;


void insert(i28 x, ll y) {
	ll p = 1;
	cost(p) += y;
	mn(p) = min(mn(p), x);
	for(ll i = k - 1; i >= 0; i--) {
		if(!son(p, get(x, i))) {
			son(p, get(x, i)) = ++cnt;
			trie[cnt].init();
		}
		p = son(p, get(x, i));
		cost(p) += y;
		mn(p) = min(mn(p), x);
	}
}

void dfs(ll p, ll use, ll i, i28 x, i28 minn, i28 tot) {
	i28 bit = ((i28)1 << i), mask = bit - 1;
	i28 x0 = x, x1 = x0 | bit;
	i28 mxx0 = x | mask, mxx1 = mxx0 | bit | mask;
	i28 tot0 = tot, tot1 = tot | bit;
	
	if(i < 0) {
		mx = max(mx, tot);
		return;
	}
	
	if(!p)
		return;
	
	bool flag = 1;
	
	// x取0
	if(cost(son(p, 0)) <= use) {
		if(mxx0 + min(mn(son(p, 0)), minn) < tot1) {
			if(min(mn(son(p, 0)), minn) < ((i28)1 << k))
				mx = max(mx, min(mn(son(p, 0)), minn) + mxx0);
		} else {
			dfs(son(p, 1), use - cost(son(p, 0)), i - 1, x0, min(mn(son(p, 0)), minn), tot1), flag = 0;
		}
	}
	
	
	// x取1
	if(cost(son(p, 1)) <= use) {
		if(mxx1 + min(mn(son(p, 1)), minn) < tot1) {
			if(min(mn(son(p, 1)), minn) < ((i28)1 << k))
				mx = max(mx, min(mn(son(p, 1)), minn) + mxx1);
		} else {
			dfs(son(p, 0), use - cost(son(p, 1)), i - 1, x1, min(mn(son(p, 1)), minn), tot1), flag = 0;
		}
	}
		
	if(flag) {
		if(mxx0 + minn < tot0) {
			if(minn < ((i28)1 << k))
				mx = max(mx, minn + mxx0);
		} else {
			dfs(son(p, 0), use, i - 1, x0, minn, tot0);
		}
		
		if(mxx1 + minn < tot0) {
			if(minn < ((i28)1 << k))
				mx = max(mx, minn + mxx1);
		} else {
			dfs(son(p, 1), use, i - 1, x1, minn, tot0);
		}
	}
}

int main(){
	scanf("%lld %lld", &c, &T);
	while(T--) {
		scanf("%lld %lld %lld", &n, &m, &k);
		mx = 0, cnt = 1;
		trie[0].init(), trie[1].init();
		ll sumb = 0;
		i28 mna = (i28)1 << k;
		for(ll i = 1; i <= n; i++)
			read(a[i]), mna = min(mna, a[i]);
		for(ll i = 1; i <= n; i++)
			scanf("%lld", &b[i]), sumb += b[i];
		if(sumb <= m)
			mx = ((i28)1 << k) - 1 + mna;
		for(ll i = 1; i <= n; i++)
			insert(a[i], b[i]);
		dfs(1, m, k - 1, 0, (i28)1 << k, 0);
		write(mx);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：ty_mxzhn (赞：6)

场上直接被代码能力送走了，下文中 $O(\log V)=O(k)$。

# $O(n \log^2 V)$

异或有三大方向考虑，线性基，01trie，还有一个忘了（可能是按位贪心？）

看到最小值最大，极其套路的，想到二分答案 $X$。原问题转化成求是否可以满足：

1. $\displaystyle \sum_{i\in S}b_i\le m$

2. $\forall i \in S [a_i + x \ge X]$

3. $\forall i \in U \backslash S [a_i \oplus x \ge X]$

然后就出现了，本题的关键性质：$a_i \oplus x \le a_i +x$。即为定向加强一定可以使得魔法值增大。

证明：$a_i \oplus x =a_i+x-2(a_i \operatorname{and} x)$。

所以说呢，如果我们想要所有数满足条件，那么如果选择的 $x$ 可以使得 $a_i \oplus x \ge X$ 那么就不需要定向加强了。

同理，如果我们有一个 $a_i +x < X$，那么这个 $a_i$ 就没救了，因为非定向加强更不行。判断完这个**必死条件**后，**所有的数经过定向加强后都可以满足 2、3 条件了**。

所以考场上一眼就知道可以建出 01trie，然后考察 $a_i \oplus x \geq X$，也就是可以不让这个数必需定向加强的方法。

类比 01trie [求最大两两异或和](https://www.luogu.com.cn/problem/P10471)的板子题，我们考虑从最高位开始逐步考虑。

用类似数位 dp 中 dfs 的方式，如果除去了去贴近 $X$ 的最低位限制 $\text{lim}$，则这棵子树范围内的 $x$ 就可以被任意达到 $a_i \oplus x \geq X$，否则继续递归，直到遇见第一个最高的比 $X$ 的当前的位值严格小的位值后，所到的子树内部的 $x$ 都符合条件。

其中，**子树内部的 $x$**，意味着**如果**在 trie 树上插入了这个 $x$，那么这个数会在这棵子树内被插入。

显然此时会分出 $\log V$ 个子树，在子树根部打上一个加标记后，我们就已经可以知道，如果我们要尝试 $x$，那么这个 $x$ 会帮哪些 $a_i$ 满足 $a_i \oplus x \geq X$ 这个条件。

能达到这一点以后，直接实现可以做到 $O(n \log^2 V)$ 了。


# $O(n \log V)$

根据经典的数据结构方法，我们就需要**利用数据结构性质平衡**了（比方说分块和二分结合就不好，线段树天生满足二分性质）。类比线段树上二分的方法，我们可以将二分放在求答案的途中，也就是 01trie 上二分了。或者说，按位贪心吧。

这是个好问题。我们考虑当我们正在 trie 上二分时，$X$ 后面的位还是 $0$，此时我们的另一个数位 dp 进程只需要考虑到前面的这些已经填好的位。因为如果 $X$ 的一位是 $0$ 的话就没有限制了。

所以我们贪心确定当前最高的没填的位时，直接递归左右子树即可，时间复杂度为遍历树的复杂度 $O(n \log V)$。

具体的说：

1. 如果这一位置想要选择 $1$？

+ $x$ 的这一位是 $0$ 吗？左子树里面就只能定向加强了。

+ $x$ 的这一位是 $1$ 吗？右子树里面就只能定向加强了。

2. 求之不得，使得这一位选 $0$ 吧。枚举 $x$ 选择 $0,1$，有一边就可以被普度苍生了（也就是失去最低位限制，剩下的位怎么填都可以不被定向加强）



代码：

```cpp
#include <bits/stdc++.h>
#define ii __int128
using namespace std;

int tr[15000007][2];
long long sz[15000007];
int b[100007];
ii mn[15000007],mx,a[100007];
int n,m,k,tot=1;
ii ans;
void read(ii &x){
    char c;bool f=0;
    while(((c=getchar())<'0'||c>'9')&&c!='-');
    if(c=='-') f=1,c=getchar();
    x=c-'0';
    while((c=getchar())>='0'&&c<='9') x=x*10+c-'0';
    if(f) x=-x;
}
void write(ii x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
void clr(int x){
	tr[x][0]=tr[x][1]=0;
	mn[x]=mx;
	sz[x]=0;
	return;
}
void upd(ii x,int y){
	int p=1;
	for(int i=k-1;i>=0;i--){
		int z=(x>>i)&1;
		sz[p]+=y;
		mn[p]=min(mn[p],x);
		if(!tr[p][z]) tr[p][z]=++tot,clr(tot);
		p=tr[p][z];
	}
	sz[p]+=y;
	mn[p]=min(mn[p],x);
}
void dfs(int p,int d,int m,ii x,ii y,ii s){
	if(d==-1){
		ans=max(ans,s);
		return;
	}
	ii b=(ii)1<<d,mk=b-1;
	if(!p){
		ans=max(ans,y+(x|mk|b));
		return;
	}
	bool lx=sz[tr[p][0]]<=m&&(x|mk  )+min(y,mn[tr[p][0]])>=(s|b);
	bool ux=sz[tr[p][1]]<=m&&(x|mk|b)+min(y,mn[tr[p][1]])>=(s|b);
	if(lx) dfs(tr[p][1],d-1,m-sz[tr[p][0]],x  ,min(y,mn[tr[p][0]]),s|b);
	if(ux) dfs(tr[p][0],d-1,m-sz[tr[p][1]],x|b,min(y,mn[tr[p][1]]),s|b);
	if(!(lx||ux)){
		dfs(tr[p][0],d-1,m,x  ,y,s);
		dfs(tr[p][1],d-1,m,x|b,y,s);
	}
}
signed main(){
	int c,T;
	scanf("%d%d",&c,&T);
	while(T--){
		scanf("%d%d%d",&n,&m,&k);
		for(int i=1;i<=n;i++) read(a[i]);
		for(int i=1;i<=n;i++) scanf("%d",&b[i]);
		mx=(ii)1<<k;
		tot=1,clr(0),clr(1);
		for(int i=1;i<=n;i++) upd(a[i],b[i]);
		ans=0;
		if(sz[1]<=m) ans=mn[1]+mx-1;
		else dfs(1,k-1,m,0,mx,0);
		write(ans);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：狂风之息 (赞：4)

注：我们称把 $i$ 加入 $S$ 为把 $i$ skip 掉。称 $X$ 为原题中的 $x$。

显然把这个东西放到 trie 上。

那么有一种很常见的思路，就是让答案尽量满足高位是 $1$。

显然 $\forall x$ 有 $x \operatorname{xor} k\le x+k$。

那么考虑我们现在递归到 trie 上一个节点，左子树与右子树都不为空。那么三种可能：

- skip 左子树所有数，$Ans$ 这位为 $1$，$X$ 这位为 $0$；
- skip 右子树所有数，$Ans$ 这位为 $1$，$X$ 这位为 $1$；
- 都不 skip 直接递归下去求解，$Ans$ 这位为 $0$, $X$ 这位为**递归下去的方向**。

显然能使答案为 $1$ 就为 $1$。因此每个子树只会被递归一次。

那么如何判断能不能 skip？

令 $w$ 为被 skip 的最小值，判断更新 之后会不会导致 $Ans>w+X$。如果会导致就不能 (因为高位已经确定的大小关系不会因为低位而改变）。

同时需要注意到 $b_i$ 的限制，这个只要记录还剩下多少体力值可用就好了。

上面提到每个子树只会被递归一次，所以直接搜一遍完事，搜的时候传一下当前节点的 $Ans,X,w$ 和剩余体力值。

时间复杂度 $O(n\log V)$，$V$ 为值域。

考场代码，勿喷。

---

但凡多给我半个小时……

``` cpp
#include<bits/stdc++.h>
#define ll __int128
const ll zzp=1;
const ll inf=(zzp<<122);
using namespace std;

ll read(){
    ll n; char c;
    while (!isdigit(c=getchar())) ; n=c-'0';
    while (isdigit(c=getchar())) n=n*10+c-'0';
    return n;
}

void write(ll x){
    if (x>=10) write(x/10);
    putchar(x%10+'0');
    return ;
}
void writeln(ll x){write(x); putchar('\n'); return;}

int n, m, k;
ll a[100005],b[100005];

int ch[12000007][2], tot;
ll mn[12000007], w[12000007];
void add(ll x,ll w_){
    int u=1;
    for (int i=k-1;i>=0;i--){
        mn[u]=min(mn[u],x); w[u]+=w_;
        int v=((x>>i)&1);
        if (!ch[u][v]){
            ch[u][v]=++tot;
            mn[tot]=inf; w[tot]=0;
            ch[tot][0]=ch[tot][1]=0;
        }
        u=ch[u][v];
    }
    mn[u]=x; w[u]+=w_;
}

void Init(){
    tot=1; 
    mn[1]=inf; w[1]=0;
    ch[1][0]=ch[1][1]=0;
    mn[0]=inf; w[0]=0;
}

ll dfs(int u,ll low,ll now,int dep, int tag,ll cur,ll tmp){
    // if (low>(zzp<<dep+1)) return -inf;
    // printf("%lld %d %d %d %d %d>\n",low,u,dep,ch[u][0],ch[u][1],tag);
    if (dep<0) return 0;
    if (!u) return (zzp<<dep+1)-1-max((ll)(0),tag?low:0);
    ll res=0;

    // if (low<(zzp<<dep)||!tag){
    //     if ((low<0||!tag)&&!(!tag&&!mn[ch[u][0]])&&now>=w[ch[u][0]]){
    //         if (!tag){
    //             res=max(res,(zzp<<dep)+dfs(ch[u][1],(zzp<<dep)-mn[ch[u][0]],now-w[ch[u][0]],dep-1, 1));
    //         }else res=max(res,(zzp<<dep)+dfs(ch[u][1],low+(zzp<<dep),now-w[ch[u][0]],dep-1, 1));
    //     }else res=max(res,dfs(ch[u][0],low,now,dep-1,tag));
    // }
    // if (1){
    //     if ((low<(zzp<<dep)||!tag)&&now>=w[ch[u][1]]){
    //         res=max(res,(zzp<<dep)+dfs(ch[u][0],low,now-w[ch[u][1]],dep-1,tag));
    //     }else res=max(res,dfs(ch[u][1],low-(zzp<<dep),now,dep-1,tag));
    // }
    bool ioi=1;
    if (now>=w[ch[u][0]]&&(low<0||!tag)&&!(!tag&&(cur<<dep+1)>=mn[ch[u][0]]+(tmp<<dep+1))){
        if (!tag&&ch[u][0]) res=max(res,(zzp<<dep)+dfs(ch[u][1],(cur*2+1<<dep)-(tmp<<dep+1)-mn[ch[u][0]],now-w[ch[u][0]],dep-1, 1, (cur<<1)+1, tmp<<1));
        else res=max(res,(zzp<<dep)+dfs(ch[u][1],low+(zzp<<dep),now-w[ch[u][0]],dep-1, tag, (cur<<1)+1, tmp<<1));
        ioi=0;
    }else res=max(res,dfs(ch[u][1],low-(zzp<<dep),now,dep-1,tag,cur<<1, (tmp<<1)+1));
    if (now>=w[ch[u][1]]&&(low<(zzp<<dep)||!tag))
        res=max(res,(zzp<<dep)+dfs(ch[u][0],low,now-w[ch[u][1]],dep-1,tag,cur*2+1, tmp*2+1));
    else if ((low<(zzp<<dep)||!tag)&&ioi) res=max(res,dfs(ch[u][0],low,now,dep-1,tag,cur*2, tmp*2));
    return res;
}

void Solve(){
    Init();
    scanf("%d %d %d",&n,&m,&k);
    for (int i=1;i<=n;i++) a[i]=read();
    for (int i=1;i<=n;i++) b[i]=read();
    for (int i=1;i<=n;i++) add(a[i],b[i]);
    if (w[1]<=m){
        ll ans=(zzp<<k);
        for (int i=1;i<=n;i++) ans=min(ans,a[i]);
        return writeln(ans+(zzp<<k)-1);
    }
    writeln(dfs(1,0,m,k-1,0,0,0));
    return;
}


int main(){
    // freopen("test.in","r",stdin);
//    freopen("1.in","r",stdin);
//    freopen("xor.out","w",stdout);
    int c,t; scanf("%d %d",&c,&t);
    while (t--) Solve();
}
```

---

## 作者：Nightingale_OI (赞：4)

## 思路

特判 $\sum b_i\leq m$；放弃大脑，思考如何将问题转化为若干个不交的子问题。

如果 $x$ 确定，可以贪心地将 $a_i\oplus x$ 的前尽量多小值对应的 $i$ 加入 $S$，直到再加不满足 $\sum\limits_{i\in S}b_i\leq m$。

对于确定要加入 $S$ 的 $i$，我们只关注其最小值 $w$，以及剩余的 $m'$。

记 $X_i$ 表示 $x$ 二进制下第 $i$ 位的取值，我们从高到低确定，我们希望见到每个子问题是如下形式：

目前的全集是未确定是否加入 $S$ 的集合，记为 $U$。

$$\min(\min_{i\in U/S}(a_i\oplus x),\min_{i\in S}(a_i+x),w+x)$$

$$\sum_{i\in S}b_i\leq m$$

考虑到第 $i$ 位时，我们可以根据 $x\in U$ 中每个 $a_x$ 在这一位的取值分为 $A_0$ 与 $A_1$，同时记：

$$B_0=\sum_{i\in A_0}b_i,W_0=\min(\min_{i\in A_0}a_i,w)$$

$$B_1=\sum_{i\in A_1}b_i,W_1=\min(\min_{i\in A_1}a_i,w)$$

考虑如果取 $X_i=0$，那么 $A_0$ 里元素异或出来的东西一定比 $A_1$ 里小。此时如果 $B_0\leq m$，我们就一定会把 $A_0$ 里**所有**元素加入 $S$；否则我们一定不会把 $A_1$ 里**任何**元素加入 $S$，并且 $A_0$ 里**不会全**加入 $S$，所以我们可以忽略 $A_1$。

$X_i=1$ 同理，分 $B_1\leq m$ 是否成立有两种情况。

一共可以分四种情况讨论，其中 $t=2^i$，每种情况靠上的是 $X_i=0$：

```cpp
if(B0>m&&B1>m){
	dfs(A0,x,m,w);
	dfs(A1,x+t,m,w);
}else if(B0<=m&&B1<=m){
	dfs(A1,x,m-B0,W0);
	dfs(A0,x+t,m-B1,W1);
}else if(B0>m&&B1<=m){
	dfs(A0,x,m,w);
	dfs(A0,x+t,m-B1,W1);
}else{
	dfs(A1,x,m-B0,W0);
	dfs(A1,x+t,m,w);
}
```

发现后两种情况有问题，不满足两子问题不交，不急，先把式子贴过来。

$$\min(\min_{i\in U/S}(a_i\oplus x),\min_{i\in S}(a_i+x),w+x)$$

记 $X_i=0$ 时 $x$ 所有可能取值构成集合为 $L$，$X_i=1$ 时为 $R$。

若 $B_0>m,B_1\leq m$，由于 $X_i=1$：

$$\max_{i\in A_0,x\in L}(a_i\oplus x)<\min_{i\in A_0,x\in R}(a_i\oplus x)$$

$$\max_{i\in A_0,x=\in L}(a_i+x)<\min_{i\in U,x=\max(R)}(a_i+x)$$

$$\max_{x\in L}(w+x)<\min_{x\in R}(w+x)$$

第二个式子不太显然，考虑把 $U$ 拆成 $A_0$ 和 $A_1$ 讨论，读者自证不难。

则只需在 $X_i=1$ 时取 $S=\varnothing$，$x=\max(R)$ 即可完杀 $X_i=0$，不需要考虑 $X_i=0$。

若 $B_0\leq m,B_1>m$，重头戏来了。

类似上面第一个式子，不难算出 $y$ 使得：

$$\min_{i\in A_1,x\in L}(a_i\oplus x)\geq y>\max_{i\in A_1,x\in R}(a_i\oplus x)$$

不知道该干什么了，先装作二分了一个 $p$ 要判断合法性。

若 $y<p$，则 $X_i=1$ 一定不合法。

若 $y\geq p$，我们 $X_i=0$ 无论 $S$ 如何取值都满足异或限制，不妨取 $S=\varnothing$，$x=\max(L)$ 使得剩下的取到最大值 $z=W_0+x$。

此时若 $z\geq p$，则答案可以 $\geq p$，直接返回，否则 $X_i=0$ 一定不合法。

```cpp
y=(a[a1[0]]&o)^x;z=w0+x+t-1;
if(y>=p){
	if(z>=p)return 1;
	dfs(A1,x+t,m,w);//Xi=1 
}else{
	dfs(A1,x,m-B0,W0);//Xi=0
}
```

然后不难发现这个二分很没用，若 $y\leq z$，一定不会取 $X_i=1$，否则 $X_i=0$ 对答案的贡献就是 $z$，不需要考虑。

贴个最终形式：

```cpp
if(b0>m&&b1>mif(B0>m&&B1>m){
	dfs(A0,x,m,w);
	dfs(A1,x+t,m,w);
}else if(B0<=m&&B1<=m){
	dfs(A1,x,m-B0,W0);
	dfs(A0,x+t,m-B1,W1);
}else if(B0>m&&B1<=m){
	dfs(A0,x+t,m-B1,W1);
}else{
	Max(ans,min(y=(a[A1[0]]&o)^x,z=W0+x+t-1));
	if(y>z)dfs(A1,x+t,m,w);
	else dfs(A1,x,m-B0,W0);
}
```

一共 $k$ 层，每层所有子问题不交，复杂度 ${\rm O}(nk)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll __int128
#define f(i,j,k) for(int i=j;i<=k;++i)
#define g(i,j,k) for(int i=j;i>=k;--i)
int n,m,s,l;
void read(__int128 &x){
	char c;bool f=0;
	while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-'){f=1;c=getchar();}
	for(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';
	if(f)x=-x;
}
void write(__int128 x){if(x>9)write(x/10);putchar(x%10+48);}
const ll N=101010,_=1,inf=_<<121;
ll a[N],b[N],k,ans;vector<int>c;
inline void Max(ll&x,ll y){if(x<y)x=y;}
inline int e(ll i,int j){return (i>>(j-1))&1;}
inline void dfs(vector<int>&U,ll x,ll m,ll w,int i,ll o){
	if(!i)return Max(ans,min(a[U[0]]^x,w+x));
	vector<int>A0,A1;ll B0=0,B1=0,W0=w,W1=w;
	for(int x:U)(e(a[x],i)?A1:A0).push_back(x);
	for(int x:A0)W0=min(W0,a[x]),B0+=b[x];
	for(int x:A1)W1=min(W1,a[x]),B1+=b[x];
	ll y,z,t=_<<(--i);o+=t;
	if(B0>m&&B1>m){
		dfs(A0,x,m,w,i,o);
		dfs(A1,x+t,m,w,i,o);
	}else if(B0<=m&&B1<=m){
		dfs(A1,x,m-B0,W0,i,o);
		dfs(A0,x+t,m-B1,W1,i,o);
	}else if(B0>m&&B1<=m){
		dfs(A0,x+t,m-B1,W1,i,o);
	}else{
		Max(ans,min(y=(a[A1[0]]&o)^x,z=W0+x+t-1));
		if(y>z)dfs(A1,x+t,m,w,i,o);
		else dfs(A1,x,m-B0,W0,i,o);
	}
}
inline void doing(){
	scanf("%d %d",&n,&m);read(k);
	f(i,1,n)read(a[i]);
	f(i,1,n)read(b[i]);
	ll sum=0,mn=a[1];
	f(i,1,n)mn=min(mn,a[i]),sum+=b[i];
	if(sum<=m)return write(mn+(_<<k)-1);
	ans=0;c.clear();
	f(i,1,n)c.push_back(i);
	dfs(c,0,m,inf,k,0);
	write(ans);
}
signed main(){
	int t;read(k);
	for(cin>>t;t--;putchar('\n'))doing();
	return 0;
}
```

---

## 作者：Liuxizai (赞：4)

省选考场上已经无限接近这个题的正解，可以由于有一些细节没考虑清楚，少写了一些情况，最后挂到了 36pts，喜提暴力同分。

题目让我们将数分为加法和异或两部分，由于对一堆数进行异或的贡献很难计算，我们尝试着将这个问题放到 01-trie 上考虑。

特判掉将所有数都分入加法部分的情况。

我们希望从高往低逐位确定 $x$ 以及最终的答案。

不妨设我们当前走到了 trie 上的某个结点 $u$，已经确定的答案为 $ans$（$ans$ 只有高位有值），$ans$ 应当恰好是从根走到 $u$ 的路径异或上 $x$ 对应的二进制数。

我们首先需要判断 $ans$ 的当前位是否能够为 $1$，如果可以则必然要令这一位为 $1$。我们在这里只讨论 $u$ 有两个儿子的情形，一个儿子是类似的。若希望 $ans$ 的当前位为 $1$，我们必须将 $u$ 一个儿子子树内的所有数都划分进加法部分（这个操作在后文被称作删除）。同时，我们还需要加法部分对答案的贡献也 $\ge ans\mid 2^d$，其中 $2^d$ 即为当前位的权值。

具体来说，我们可以枚举要删除哪个儿子并判断是否可行，首先我们需要儿子子树内所有数对应的 $b_i$ 之和不超过剩余可用的代价，其次加法部分的数的最小值 $mn$ 需要满足 $mn+(x\mid(2^d-1))\ge ans\mid 2^d$，这里是在考虑加法部分在最优情形下对答案的贡献，在无需关心异或部分取值时，$x$ 的值可以任取，所以我们将还未确定的低位全部置为了 $1$。如果发现删除某一个儿子可以使得答案的当前位为 $1$，就对应的更新 $ans$ 与 $x$，朝另一个儿子递归即可。

若我们确定了 $ans$ 的当前位不可能为 $1$，首先我们仍考虑是否要删除一棵子树并令异或部分的当前位为 $1$，此时异或部分必然不会对最终的答案产生限制，只需要考虑加法部分，很显然，最优解即是将剩下的低位全部置为 $1$，所以我们直接用算出的数更新全局答案即可。现在只剩下不删除子树的情况，我们枚举 $x$ 的取值，此时当前位异或为 $1$ 的子树不会对答案产生限制，朝异或为 $0$ 的子树递归即可。

在任何情况下，我们都只会朝 $u$ 的每个儿子递归不超过一次，trie 上的每个结点至多被访问一次，所以总复杂度为 $O(nk)$。

[Code](https://liuxizai.ac.cn/archives/solution-lg10218.html#Code)

> 此为考场代码加上少量修改，仅供参考，变量命名与含义和题解中不完全一致。

---

## 作者：ppip (赞：2)

[题目传送门](/problem/P10218)

首先将所有元素按照 $a$ 排序。现在 $a_1$ 即为最小的 $a$。

考虑钦定 $a_1$ 最终是加还是异或。无论是哪种，显然其它选择加的元素都大于等于最终的 $a_1$，所以可以将问题转化为删除 $b_i$ 之和不超过 $m$ 的一些元素，并选择一个 $x$ 使得剩下的数异或 $x$ 的最小值最大。

如果 $a_1$ 钦定为异或则等价不能删除 $a_1$。如果钦定为加则可以二分答案转化为任意删除，但是必须满足最终的 $x$ 大于等于 $mid-a_1$。这两个问题都可以通过 trie 树上递推解决。

具体地，对于异或问题，求解对于 trie 树的某个子树 $p$，有大小为 $m$ 的背包，并且是否禁止删除子树中最小的数，答案是多少。将该问题表示为 $(p,m,0/1)$。

显然如果 $p$ 只有一个子树直接利用该子树的答案。否则考虑能否完全删除某一个子树，如果能则考察删除哪个子树更优，问题转化为 $(ls,m-sz_{rs},0/1)$ 和 $(rs,m-sz_{ls},0/1)$，其中 $sz$ 为子树内元素 $b_i$ 之和，$ls$ 和 $rs$ 为 trie 树上的左右儿子。

否则当前指向儿子的边对应位答案必然为零。所以枚举哪边为零然后整个背包都给它，取两边较大值，转化为 $(ls,m,0/1)$ 和 $(rs,m,0/1)$。

显然上下两种情况只会选择一个，所以每个子树至多只需要求解一个问题。可以在 $O(nk)$ 的时间复杂度进行递推得到。

对于加法问题也是类似。考虑 $(p,m,0/1)$，这里只有最后一位与之前不同，表示已经选择的高位是否顶这下界（类似数位 DP 中的做法）。同样的进行递推即可。因为有二分答案，这部分的复杂度是 $O(nk^2)$，不能通过。

考虑优化。注意到 trie 树一个结点在只有一个儿子的时候直接调用答案（并加上当前的那一位），所以可以将所有只有一个儿子的结点缩掉，于是现在整棵树只有 $2n-1$ 个结点，复杂度变为 $O(nk)$，可以通过。

代码细节较多，特别是在加法问题上，因为缩点边权将不止一位，需要考虑仔细考虑顶着下界时候的情况。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int Spp{1<<20};
char buf[Spp],*p1,*p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,Spp,stdin),p1==p2)?EOF:*p1++)
template <typename T>
void read(T &x) {
    char c;int f{1};
    do x=(c=getchar())^48;
    while (!isdigit(c)&&c!='-');
    if (x==29) x=0,f=-1;
    while (isdigit(c=getchar()))
        x=x*10+(c^48);
    x*=f;
}
template <typename T,typename ...Args>
void read(T &x,Args &...args) { read(x);read(args...); }
constexpr int N(1e5),M(4e5);
constexpr __int128 one{1};
pair<__int128,int> a[N+5];
__int128 lf[M+5],zf[M+5];
int L[M+5],R[M+5],ac[M+5],ls[M+5],rs[M+5],tot;
long long sz[M+5];
void init(int p,int l,int r,int dep) {
    L[p]=l;R[p]=r;
    sz[p]=ac[p]=lf[p]=zf[p]=0;
    while (dep>=0&&(a[l].first>>dep&1)==(a[r].first>>dep&1))
        zf[p]|=((a[l].first>>dep&1)<<dep),lf[p]|=((~a[l].first>>dep&1)<<dep),
            --dep;
    ac[p]=dep;
    if (dep==-1) {
        for (int i{l};i<=r;++i) sz[p]+=a[i].second;
        return;
    }
    int fr;
    for (int i{0};i<r-l+1;++i)
        if (a[l+i].first>>dep&1) {
            fr=l+i;
            break;
        } else if (~a[r-i].first>>dep&1) {
            fr=r-i+1;
            break;
        }
    init(ls[p]=++tot,l,fr-1,dep-1);
    init(rs[p]=++tot,fr,r,dep-1);
    sz[p]=sz[ls[p]]+sz[rs[p]];
}
__int128 ONE(int l,int r) {
    if (l<r) return 0;
    return ((one<<(l-r+1))-1)<<r;
}
__int128 solve1(int p,int m,bool ct,int dep) {
    if (ac[p]==-1) {
        return (one<<dep+1)-1;
    }
    if (ct) {
        if (sz[rs[p]]<=m) {
            return solve1(ls[p],m-sz[rs[p]],true,ac[p]-1)+(ONE(dep,ac[p]));
        } else {
            return max(solve1(ls[p],m,true,ac[p]-1),solve1(rs[p],m,false,ac[p]-1))+ONE(dep,ac[p]+1);
        }
    } else {
        __int128 ans{-1};
        if (sz[ls[p]]<=m) ans=max(ans,solve1(rs[p],m-sz[ls[p]],false,ac[p]-1));
        if (sz[rs[p]]<=m) ans=max(ans,solve1(ls[p],m-sz[rs[p]],false,ac[p]-1));
        if (ans!=-1) return ans+ONE(dep,ac[p]);
        else return max(solve1(ls[p],m,false,ac[p]-1),solve1(rs[p],m,false,ac[p]-1))+ONE(dep,ac[p]+1);
    }
}
__int128 limit;
int __lg(__int128 z) {
    if (z>>60) return __lg((long long)(z>>60))+60;
    else return __lg((long long)z);
}
__int128 solve2(int p,int m,bool limited,int dep) {
    if (ac[p]==-1) {
        if (limited) {
            auto z{lf[p]&(~limit)};
            if (!z) return ((limit&ONE(dep,ac[p]+1))|lf[p])^zf[p];
            else {
                z=__lg(z);
                return ((limit&ONE(dep,z+1))|lf[p])^(zf[p]);
            }
        } else return lf[p]^zf[p];
    }
    if (limited) {
        auto z{lf[p]&(~limit)};
        if (!z) {
            if (limit>>ac[p]&1) {
                auto prefix{(limit&ONE(dep,ac[p]+1))|lf[p]};
                prefix^=zf[p];
                __int128 ans{-1};
                if (sz[rs[p]]<=m) ans=max(ans,solve2(ls[p],m-sz[rs[p]],true,ac[p]-1));
                if (ans!=-1) return ans+prefix+ONE(ac[p],ac[p]);
                else return solve2(rs[p],m,true,ac[p]-1)+prefix;

            } else {
                auto prefix{(limit&ONE(dep,ac[p]+1))|lf[p]};
                prefix^=zf[p];
                __int128 ans{-1};
                if (sz[ls[p]]<=m) ans=max(ans,solve2(rs[p],m-sz[ls[p]],true,ac[p]-1));
                if (sz[rs[p]]<=m) ans=max(ans,solve2(ls[p],m-sz[rs[p]],false,ac[p]-1));
                if (ans!=-1) return ans+prefix+ONE(ac[p],ac[p]);
                else return max(solve2(ls[p],m,true,ac[p]-1),solve2(rs[p],m,false,ac[p]-1))+prefix;
            }
        } else {
            z=__lg(z);
            auto prefix{(limit&ONE(dep,z+1))|lf[p]};
            prefix^=zf[p];
            __int128 ans{-1};
            if (sz[ls[p]]<=m) ans=max(ans,solve2(rs[p],m-sz[ls[p]],false,ac[p]-1));
            if (sz[rs[p]]<=m) ans=max(ans,solve2(ls[p],m-sz[rs[p]],false,ac[p]-1));
            if (ans!=-1) return ans+prefix+ONE(ac[p],ac[p]);
            else return max(solve2(ls[p],m,false,ac[p]-1),solve2(rs[p],m,false,ac[p]-1))+prefix;
        }

    } else {
        __int128 ans{-1};
        if (sz[ls[p]]<=m) ans=max(ans,solve2(rs[p],m-sz[ls[p]],false,ac[p]-1));
        if (sz[rs[p]]<=m) ans=max(ans,solve2(ls[p],m-sz[rs[p]],false,ac[p]-1));
        if (ans!=-1) return ans+ONE(dep,ac[p]);
        else return max(solve2(ls[p],m,false,ac[p]-1),solve2(rs[p],m,false,ac[p]-1))+ONE(dep,ac[p]+1);
    }
}
void write(__int128 x){
	if(x < 0){putchar('-'); x = -x;}
	if(x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
int main() {
    int c,T;read(c,T);
    while (T--) {
        int n,m,k;read(n,m,k);
        for (int i{1};i<=n;++i) read(a[i].first);
        for (int i{1};i<=n;++i) read(a[i].second);
        sort(a+1,a+1+n);tot=1;
        init(1,1,n,k-1);
        if (m>=sz[1]) {
            write(a[1].first+(one<<k)-1);
            putchar('\n');
            continue;
        }
        __int128 ans{solve1(1,m,true,k-1)};
        if (m>=a[1].second) {
            tot=1;
            init(1,2,n,k-1);
            __int128 L{a[1].first},R{(one<<k)-1};
            while (L<=R) {
                auto mid{L+R>>1};
                limit=mid-a[1].first;
                if (solve2(1,m-a[1].second,true,k-1)>=mid) {
                    ans=max(ans,mid);
                    L=mid+1;
                } else {
                    R=mid-1;
                }
            }
        }
        write(ans);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：Acoipp (赞：1)

## 分析

首先看到最大化 $\min\{\min_{a \in S_1}\{a+x\},\min_{a \in S_2}\{a \operatorname{xor} x\}\}$ 并且 $S_1+S_2=S$，可以想到贪心。

考虑从高到低确定每一位，首先决定这一位可不可以为 $1$，我们需要同时维护两个变量 $ans$ 和 $x$，对于一个 $a_i$ 如果只考虑已经决策过的位 $a_i \operatorname{xor} x<$ 或者 $>ans$，都可以直接确定它到底属于 $S_1$ 还是 $S_2$，那么剩下的就是 $=ans$ 的，容易发现这一部分在 trie 树上是一棵子树，所以我们可以递归求解。

假设当前节点是 $u$，下一位 $ans$ 选择 $1$，$x$ 也选择 $1$，那么 $u$ 的右子节点就需要全部加到 $S_1$ 里面，同时需要判断 $b$ 的和是否超过当前的 $m$，左子节点也需要递归解决，当然递归之前要判断最坏情况下是否有解，即 $x$ 剩下的位都是 $1$，$ans$ 剩下的位都是 $0$ 是否满足 $\min_{a \in S_1}\{a+x\} \ge ans$。

$x$ 选择 $0$ 的情况是对称的。

如果 $ans$ 下一位不可能选择 $1$，那就只有选择 $0$，这个时候当 $x=1$ 的时候，$u$ 的左子树可以直接加入 $S_2$，右子树需要递归求解，$x=0$ 同理。

综上，每个节点最多遍历一次，故时间复杂度和空间复杂度不会超时。


## 代码

代码如下，时间复杂度和空间复杂度都是 $O(\sum nk)$。

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
#define ll __int128
#define N 100005
#define M 12000005
using namespace std;
inline char nc(){
	static char buf[1000000],*p=buf,*q=buf;
	return p==q&&(q=(p=buf)+fread(buf,1,1000000,stdin),p==q)?EOF:*p++;
}
inline ll read(){
	ll res = 0;
	char c = nc();
	while(c<'0'||c>'9')c=nc();
	while(c<='9'&&c>='0')res=res*10+c-'0',c=nc();
	return res;
}
char obuf[1<<21],*p3=obuf; 
inline void pc(char c){ 
	p3-obuf<=(1<<20)?(*p3++=c):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=c); 
} 
inline void write(ll x){ 
	if(x<0) pc('-'),x=-x; 
	if(x>9) write(x/10); 
	pc(x%10+'0'); 
}
ll T,n,m,k,i,a[N],b[N],asum,ans,tot,minn[M],qmi[205];
int trie[M][2];
long long sum[M];
inline void insert(ll x,ll y){
	ll p = 0;
	for(ll i=k-1;i>=0;i--){
		if(!trie[p][(x>>i)&1]) trie[p][(x>>i)&1]=++tot,minn[tot]=qmi[k];
		p=trie[p][(x>>i)&1],minn[p]=min(minn[p],x),sum[p]+=y;
	}
}
inline void dfs(ll pos,ll val,ll nowa,ll nowx,ll step,ll nowmin){
	if(nowa+qmi[step+1]-1<ans) return ;
	if(step==-1||(!pos&&step!=k-1)){
		if(step==-1) ans=max(ans,nowa);
		else{
			for(ll i=step;i>=0;i--){
				if(nowmin+nowx+qmi[i+1]-1>=nowa+qmi[i]) nowa+=qmi[i],nowx+=qmi[i];
				else nowx+=qmi[i];
			}
			ans=max(ans,nowa);
		}
		return ;
	}
	ll temp = 0;
	if(sum[trie[pos][0]]<=val&&min(nowmin,minn[trie[pos][0]])+nowx+qmi[step]-1>=nowa+qmi[step]){
		temp=1;
		dfs(trie[pos][1],val-sum[trie[pos][0]],nowa+qmi[step],nowx,step-1,min(nowmin,minn[trie[pos][0]]));
	}
	if(sum[trie[pos][1]]<=val&&min(nowmin,minn[trie[pos][1]])+nowx+qmi[step+1]-1>=nowa+qmi[step]){
		temp=1;
		dfs(trie[pos][0],val-sum[trie[pos][1]],nowa+qmi[step],nowx+qmi[step],step-1,min(nowmin,minn[trie[pos][1]]));
	}
	if(temp) return ;
	dfs(trie[pos][0],val,nowa,nowx,step-1,nowmin),dfs(trie[pos][1],val,nowa,nowx+qmi[step],step-1,nowmin);
}
inline void solve(){
	asum=0,ans=-1;
	n=read(),m=read(),k=read();
	qmi[0]=1;
	for(i=1;i<=k;i++) qmi[i]=qmi[i-1]*2;
	for(i=1;i<=n;i++){
		a[i]=read();
		if(ans==-1) ans=a[i];
		else ans=min(ans,a[i]);
	}
	for(i=1;i<=n;i++) b[i]=read(),asum+=b[i];
	if(asum<=m){
		write(ans+qmi[k]-1),pc('\n');
		return ;
	}
	ans=0,minn[0]=qmi[k];
	for(i=1;i<=n;i++) insert(a[i],b[i]);
	dfs(0,m,0,0,k-1,qmi[k]);
	write(ans),pc('\n');
	while(tot) trie[tot][0]=trie[tot][1]=0,sum[tot]=0,minn[tot]=0,tot--;
	trie[tot][0]=trie[tot][1]=0,sum[tot]=0,minn[tot]=0;
	return ;
}
int main(){
	T=read(),T=read();
	while(T--) solve();
	fwrite(obuf,p3-obuf,1,stdout);
	return 0;
}
```

---

## 作者：eastcloud (赞：1)

我们先考虑只有异或该怎么做，这类问题的一个传统套路是从高位到低位贪心检验前面确定的为加上这位为 1 是否有解，有解就将答案这位设成 1，否则不变并向下继续考虑，因此我们只用关心怎样解决如何判定答案的问题。

由于这个问题有良好的贪心性质，我们也从上往下依次进行判定，类似数位 dp 的操作，我们只考虑到当前位都贴紧答案上界的数，这样如果有些数已经在比较高的某些位置（我们已经考虑过的位置）大于答案，那我们就不用再在下面处理。这样说可能有些抽象，更具体地，若是关注判定过程中的其中一层，我们可以将其分为以下几种情况：

* 若答案这位为 0，那么如果我们不在这位进行异或操作，这位为 1 的数字就可以不用考虑，直接递归处理这位为 0 的数字，进行操作的情况同理。

* 若答案这位为 1，如果这位既有 0 又有 1 那肯定无解，因为我们没办法只通过异或让所有数这位都是 1，否则操作唯一，递归处理即可。

这样我们就解决了全是异或操作的情况，但是由于这个判定过程是在 trie 上贪心，加上枚举复杂度将会达到 $O(nk^2)$，不过我们其实可以直接考虑：若当前层颜色唯一，则这位答案可以为 1，否则按照对不对这位进行操作各递归两边进行计算，这样就能做到 $O(nk)$

接下来要引入加法，由于加法操作也有能够贪心的良好性质，我们尝试能不能不做大的改动，只在原本求解的框架上进行小的修改。

继续考察判定过程，上述第一种情况不变，第二种则由于加法操作的引进，不一定无解，此时无解条件就变成了为 0 的子树最小值加上操作已经确定的位和操作未确定的位都设成 1 之后的数（考虑最小的数必须要满足条件）必须要大于钦定答案这位为 1 后的值，且花费能够接受，如果合法则这位可以为 1。

但是这样会有一个问题：改成加法操作的子树也会对答案产生影响，我们必须对其进行递归，但这样两个子树的操作就不独立，必须一起考虑，但是我们的复杂度建立在拆分的基础上，这样会导致复杂度退化。

怎么解决呢？我们刚才提过，加法有良好的贪心性质，我们只需要考虑加法子树中最小的数，只有它会对答案产生影响，在递归过程中顺便记录现在已经钦定加法的子树最小值，判定的时候还要考虑这个值在最好情况下能不能满足条件，即可解决问题，剩下的按照异或的方法分类讨论即可。

```
#include<bits/stdc++.h>
#define ll __int128
#define inf 4e36
#define N 150005
using namespace std;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9')f=(ch=='-'?-1:f),ch=getchar();
    while(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
void write(ll x){
    if(x<0)x=-x,putchar('-');
    if(x/10)write(x/10);
    putchar(x%10+'0');
}
ll n,m;
ll a[N],tot=1,minn[N*121];
ll ans;
int ch[N*121][2];
long long cost[N*121],b[N];
ll maxc(ll x,ll y){
    return (x>y?x:y);
}
void solve(int p,ll k,ll minplus,ll res,long long rescos,ll opr){
    if(!p && minplus<inf)return ans=maxc(ans,minplus+(((__int128)1)<<(k+1))-1+opr),void();
    else if(!p)return;
    if(k==-1)return ans=maxc(ans,res),void();
    int ls=ch[p][0],rs=ch[p][1],flag=0;
    if(cost[ls]<=rescos && opr+min(minplus,minn[ls])+((__int128)1<<k)-1>=((__int128)1<<k)+res){
        solve(rs,k-1,min(minplus,minn[ls]),res|((__int128)1<<k),rescos-cost[ls],opr);
        flag=1;
    }
    if(cost[rs]<=rescos && opr+min(minplus,minn[rs])+((__int128)1<<k)-1>=res){
        solve(ls,k-1,min(minplus,minn[rs]),res|((__int128)1<<k),rescos-cost[rs],opr|((__int128)1<<k));
        flag=1;
    }
    if(flag)return;
    solve(ls,k-1,minplus,res,rescos,opr);
    solve(rs,k-1,minplus,res,rescos,opr|((__int128)1<<k));
}
void solve(){
    n=read(),m=read();ll k=read();ans=0;minn[0]=inf;
    for(ll i=1;i<=tot;i++)minn[i]=inf,cost[i]=ch[i][0]=ch[i][1]=0;tot=1;
    for(ll i=1;i<=n;i++)a[i]=read();
    for(ll i=1;i<=n;i++)b[i]=read();
    for(ll i=1;i<=n;i++){
        ll p=1;
        minn[p]=min(minn[p],a[i]);
        cost[p]+=b[i];
        for(ll j=k-1;j>=0;j--){
            ll it=((a[i]&((__int128)1<<j))?1:0);
            if(!ch[p][it])ch[p][it]=++tot;
            p=ch[p][it];minn[p]=min(minn[p],a[i]);
            cost[p]+=b[i];
        }
    }
    if(cost[1]<=m){write(minn[1]+((__int128)1<<k)-1);putchar('\n');return;}
    solve(1,k-1,inf,0,m,0);write(ans);putchar('\n');
}
int main(){
    memset(minn,0x3f,sizeof(minn));
    ll c=read(),T=read();while(T--)solve();
    return 0;
}
```

---

## 作者：云浅知处 (赞：1)

把 $a$ 排序，显然相同的 $a$ 如果要放到 $S$ 内一定要一起放进去，于是我们可以先把相同的 $a$ 合并起来，顺便排序。下面假定序列 $a$ 严格单调递增。

考虑二分答案 $mid$，注意到 $A\oplus B\le A+B$，因此必有 $a_1+x\ge mid$（否则 $a_1$ 一定不合法）。于是 $x\ge mid-a_1$，进而推出，任何一个数只要放进 $S$ 中，都一定是合法的。

考虑建出 $a$ 的 01Trie，然后在 Trie 上 DP：$f(u)$ 表示 $u$ 子树内的这些 $a$ 所需的最小代价，每次决策 $x$ 的当前位是 $0$ 还是 $1$ 即可。这样做一次复杂度为 $O(nk)$，总复杂度为 $O(nk^2)$。

--------------

考虑 $O(nk)$ 咋做。先不考虑集合 $S$，考虑选一个 $x$ 最大化 $\min a_i\oplus x$。发现可以直接 DP，每次考虑当前位，相当于可以舍弃一边的子树（它们不再对 min 造成约束了），直接走进另一边的子树内接着做。这样复杂度只有一个 $O(nk)$。

那现在考虑有集合 $S$ 了咋办，根据上面的过程我们知道一个数如果放进集合 $S$ 了一定是合法的。由于我们是在贪心地从高到低确定每一位，因此最优一定是让当前位的 min 尽可能大，为此我们可以选一些子树把它们放进 $S$ 中来去除它们对 min 的约束；同时还需要 $x$ 有一个下界。

还是考虑每一位，发现如果当前位上同时有向 $0$ 走的和向 $1$ 走的，那么如果没有集合 $S$，我们这一位上的 min 一定会出现 $0$，然后我们只需要考虑 $0$ 这一侧；但有了集合 $S$ 之后，我们可能的决策就是，把一边的 $a_i$ 全都放进 $S$ 中，然后让另一边的 xor 一下，这一位都变成 $1$，这样就可以把这一位的值变成 $1$。

但我们之前还对 $x$ 有一个下界的约束，发现上面那种情况下如果我们要选一边放进集合 $S$，讨论一下 $x$ 的取值：

- 这一位上 $x$ 取 $1$，也就是我们把 $a_i$ 这一位为 $1$ 的扔进集合 $S$，这一位为 $0$ 的接着考虑，发现这里对 $x$ 没有下界的约束，因为 $a_i$ 这一位如果是 $1$，$x$ 的这一位也是 $1$，那么加起来直接就 win 了。
- 这一位上 $x$ 取 $0$，然后把 $a_i$ 这一位为 $0$ 的扔进集合 $S$，这一位为 $1$ 的接着考虑。那还是考虑 $0$ 那边对他的约束，发现只有最小的一个 $a_i$ 是有用的。我们把这个 $a_i$ 记录下来，接着往下走。

那这个时候走到一个节点 $u$ 的时候，对 min 的约束还额外有一个 $x+a_t$。考虑决策下一位，发现我们必须要能够进一位，也就是说，这里不能出现 $(x+a_t)_i=0$，直到 $a_t,x$ 的这一位都取到 $1$，我们成功进行了一次进位为止。

考虑在 trie 上 DFS，记录 $\text{solve}(u,w,K,c=0/1,d=0/1)$ 表示当前在结点 $u$（也就是说，不在节点 $u$ 内的 $a_j$ 都对 $ans$ 没有约束了），在 $u$ 往前的部分，$x$ 和 $ans$ 都已经确定了的情况下：有一个限制是 ans 对 $x+w$ 取 min，还剩下 $K$ 的体力值可以花费，$c=0/1$ 表示是否钦定后面的位需要传一个进位上来，$d=0/1$ 表示这里面的元素如果放进 $S$，是否已经一定都合法了。现在我们同时确定 $ans$ 和 $x$ 的当前位，原则是尽量把 $ans$ 的当前位定为 $1$。

然后在 Trie 上进行一些史一样的分类讨论就好了，具体可以看代码。时间复杂度 $O(nk)$。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second
#define i128 __int128

using namespace std;

const i128 INF=(i128(1)<<122)-1;

void Read(i128 &x){
	// read a __int128 variable
	char c; bool f = 0;
	while(((c = getchar()) < '0' || c > '9') && c != '-');
	if(c == '-'){f = 1; c = getchar();}
	x = c - '0';
	while((c = getchar()) >= '0' && c <= '9')x = x * 10 + c - '0';
	if(f) x = -x;
}
void out(i128 x){
	// print a __int128 variable
	if(x < 0){putchar('-'); x = -x;}
	if(x > 9)out(x / 10);
	putchar(x % 10 + '0');
}

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int mod=998244353;
int ksm(int x,ll y,int p=mod){
	int ans=1;y%=(p-1);
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
mt19937 rnd(time(0));
int randint(int l,int r){return rnd()%(r-l+1)+l;}
void add(int &x,int v){x+=v;if(x>=mod)x-=mod;}
void Mod(int &x){if(x>=mod)x-=mod;}
int cmod(int x){if(x>=mod)x-=mod;return x;}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int N=1e5+5;
const int M=2e7+5;
 
int tr[M][2],tot,fa[M],sum[M],dep[M];
bitset<M>Leaf;
int n,m,k,b[N];
i128 a[N],mn[M];

int op(int x,int y){return min(m+1,x+y);}
void clr(){
	for(int i=1;i<=tot;i++)fa[i]=dep[i]=sum[i]=tr[i][0]=tr[i][1]=Leaf[i]=0,mn[i]=INF;
	for(int i=1;i<=n;i++)a[i]=b[i]=0;
}
void ins(i128 x,int val){
	int p=1;
	for(int i=k-1;i>=0;i--){
		sum[p]=op(sum[p],val),cmin(mn[p],x);
		int c=((x>>i)&1);
		if(!tr[p][c]){
			int q=++tot;
			fa[q]=p,dep[q]=i-1,tr[p][c]=q;
		}
		p=tr[p][c];
	}
	sum[p]=op(sum[p],val),Leaf[p]=1,cmin(mn[p],x);
}

#define ls(p) (tr[p][0])
#define rs(p) (tr[p][1])

i128 Pw[200];
i128 dfs(int u,i128 w,int K,int c,int d){
	if(Leaf[u])return c==1?(-INF):((i128)(0));
	if(c==1&&((w&(Pw[dep[u]+1]-1))==0))return (i128)(-1);
	i128 ans=0;
	if(sum[u]<=K){
		i128 cw=(w&(Pw[dep[u]+1]-1));
		cmax(ans,cw-1);
		return ans;
	}
	int pc=((w>>dep[u])&1);
	if(c==0){
		if(ls(u)==0){ // a_i = 1
			i128 res=dfs(rs(u),w,K,(pc==0?1:0),d); // x_i = 0 , ans_i = 1
			if(res!=-INF)cmax(ans,res+Pw[dep[u]]);
			else{
				// x_i = 1 , ans_i = 0
				res=dfs(rs(u),INF,K,0,0);
				cmax(ans,res);
			}
		}
		else if(rs(u)==0){ // a_i = 0 , x_i = 1 , ans_i = 1
			if(pc==1)w=INF;
			i128 res=dfs(ls(u),w,K,0,d);
			if(res!=-INF)cmax(ans,res+Pw[dep[u]]);
		}
		else{
			i128 res=0;
			
			// ans_i = 1
			if(sum[rs(u)]<=K){
				// x_i = 1 , a_i = 0
				res=dfs(ls(u),(pc==1?INF:w),K-sum[rs(u)],0,d);
				if(res!=-INF)cmax(ans,res+Pw[dep[u]]);
			}
			if(sum[ls(u)]<=K){
				// x_i = 0 , a_i = 1
				i128 ww=w;int ppc=((ww>>dep[u])&1);
				if(d==1)cmin(ww,mn[ls(u)]),ppc=((ww>>dep[u])&1);
				res=dfs(rs(u),ww,K-sum[ls(u)],(ppc==0?1:0),d);
				if(res!=-INF)cmax(ans,res+Pw[dep[u]]);
			}
			
			if(ans==0){
				// ans_i = 0
				
				// x_i = 0 , a_i = 0
				if(pc==1)w=INF;
				res=dfs(ls(u),w,K,0,d);
				if(res!=-INF)cmax(ans,res);
				// x_i = 1 , a_i = 1
				res=dfs(rs(u),INF,K,0,0);
				if(res!=-INF)cmax(ans,res);
			}
		}
	}
	else{
		// ans_i = 1 , x_i = 1 , a_i = 0
		if(sum[rs(u)]<=K&&pc==1){
			i128 res=-INF;
			if(ls(u)==0){
				i128 cw=(w&(Pw[dep[u]]-1));
				if(cw==0)res=-INF;
				else res=cw-1;
			}
			else res=dfs(ls(u),w,K-sum[rs(u)],1,d);
			if(res!=-INF)cmax(ans,res+Pw[dep[u]]);
		}
		
		if(ans==0){	
			// ans_i = 0
			if(rs(u)!=0){
				// a_i = 1 , x_i = 1
				i128 res=dfs(rs(u),w,K,(pc==1?0:1),0);
				if(res!=-INF)cmax(ans,res);
			}
			// x_i = 0 , a_i = 0
			if(pc==1){
				if(ls(u)!=0){
					i128 res=dfs(ls(u),w,K,1,0);
					if(res!=-INF)cmax(ans,res);
				}
				else{
					i128 cw=(w&(Pw[dep[u]]-1));
					cmax(ans,cw-1);
				}
			}
			
			if(rs(u)==0){
				i128 cw=(w&(Pw[dep[u]+1]-1));
				cmax(ans,cw-1);
			}
		}
	}
	return ans;
}

i128 pres;
void solve(){
	n=read(),m=read(),k=read();int sm=0;i128 minn=INF;
	
	for(int i=1;i<=n;i++)Read(a[i]),cmin(minn,a[i]);
	for(int i=1;i<=n;i++)b[i]=read(),sm=op(sm,b[i]);
	
	if(sm<=m){out(minn+Pw[k]-1),putchar('\n'),clr();return ;}
	
	tot=1,dep[1]=k-1;
	for(int i=1;i<=n;i++)ins(a[i],b[i]);
	
	i128 res=dfs(1,INF,m,0,1);
	out(res),putchar('\n');
	
	clr();
}

signed main(void){

	Pw[0]=1;for(int i=1;i<=122;i++)Pw[i]=Pw[i-1]+Pw[i-1];
	for(int i=0;i<M;i++)mn[i]=INF;
	int Id=read(),tt=read();while(tt--)solve();

	return 0;
}
```

---


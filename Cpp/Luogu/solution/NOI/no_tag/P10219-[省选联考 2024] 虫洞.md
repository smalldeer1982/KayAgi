# [省选联考 2024] 虫洞

## 题目描述

E 国有 $n$ 个城市，编号为 $1$ 至 $n$。为了让城市之间的来往更加便利，E 国的交通部想在 $n$ 个城市间建造一些虫洞。每条虫洞是一条**单向**的从某个城市到另一个城市的通道。允许通道的起点和终点是同一个城市，也允许两个城市之间有多个虫洞连接。

为了区分虫洞的建造时间，交通部给每一条虫洞一个正整数的编号。

我们称一种虫洞的建造方案是**好的**，若它满足如下四个条件：

1. 存在一个非负整数 $d$ 使得每个城市恰好是 $d$ 条虫洞的起点，也恰好是 $d$ 条虫洞的终点。
2. 对于每个城市而言，在以它为起点的虫洞的编号中，$1$ 到 $d$ **恰好**各出现一次。
3. 对于每个城市而言，在以它为终点的虫洞的编号中，$1$ 到 $d$ **恰好**各出现一次。
4. 任意选取一个城市 $u$ 和正整数 $1\le j_1, j_2 \le d$。设从 $u$ 出发，先经过一次编号为 $j_1$ 的虫洞，再经过一次编号为 $j_2$ 的虫洞，到达城市 $v_1$。设从 $u$ 出发，先经过一次编号为 $j_2$ 的虫洞，再经过一次编号为 $j_1$ 的虫洞，到达城市 $v_2$。则条件 $v_1=v_2$ 必定满足。

特别地，不建造任何虫洞的方案也是好的。

现在，建造师已建造了 $mn$ 条虫洞，且给了它们 $1\sim m$ 的编号，**此时这样的建造方案是好的**。他想要新建造 $kn$ 条虫洞，并给它们 $(m+1)\sim (m+k)$ 的编号。他必须保证这 $(m + k)n$ 条虫洞形成的建造方案仍然是好的。他想知道有多少种新建造 $kn$ 条虫洞的方法，使得这 $(m + k)n$ 条虫洞形成的建造方案是好的。

由于答案很大，你只需要求出方案数除以 $998244353$ 的余数。

## 说明/提示

**【样例 1 解释】**

在该组样例中，已经建造的编号为 $1$ 的虫洞为 $1\to 2,2\to 1,3\to 4,4\to 3$。为了使 $8$ 条虫洞形成的建造方案是好的，新建造的编号为 $2$ 的虫洞可能有 $8$ 种情形：

1. $1\to 1, 2\to 2, 3\to 3, 4\to 4$
2. $1\to 1, 2\to 2, 3\to 4, 4\to 3$
3. $1\to 2, 2\to 1, 3\to 3, 4\to 4$
4. $1\to 2, 2\to 1, 3\to 4, 4\to 3$
5. $1\to 3, 2\to 4, 3\to 1, 4\to 2$
6. $1\to 3, 2\to 4, 3\to 2, 4\to 1$
7. $1\to 4, 2\to 3, 3\to 1, 4\to 2$
8. $1\to 4, 2\to 3, 3\to 2, 4\to 1$

**【样例 2】**

见附件中的 `wormhole2.in/ans`。

该样例的 $c = 2$，它满足第 2 个测试点的限制条件。

**【样例 3】**

见附件中的 `wormhole3.in/ans`。

该样例的 $c = 5$，它满足第 5 个测试点的限制条件。

**【样例 4】**

见附件中的 `wormhole4.in/ans`。

该样例的 $c = 7$，它满足第 7 个测试点的限制条件。

**【样例 5】**

见附件中的 `wormhole5.in/ans`。

该样例的 $c = 9$，它满足第 9 个测试点的限制条件。

**【样例 6】**

见附件中的 `wormhole6.in/ans`。

该样例的 $c = 11$，它满足第 11 个测试点的限制条件。

**【样例 7】**

见附件中的 `wormhole7.in/ans`。

该样例的 $c = 15$，它满足第 15 个测试点的限制条件。

**【样例 8】**

见附件中的 `wormhole8.in/ans`。

该样例的 $c = 17$，它满足第 17 个测试点的限制条件。

**【样例 9】**

见附件中的 `wormhole9.in/ans`。

该样例的 $c = 20$，它满足第 20 个测试点的限制条件。

**【样例 10】**

见附件中的 `wormhole10.in/ans`。

该样例的 $c = 22$，它满足第 22 个测试点的限制条件。

**【子任务】**

对于所有测试点，

- $1\le n \le 2\cdot 10^3$，$0 \le m \le 10^3$，$1 \le k \le 10^{15}$；
- $1 \le u,v \le n$，$1 \le w \le m$；
- 保证初始建造的 $mn$ 条虫洞构成一个号的建造方案。

| 测试点编号 | $n$ | $m$ | $k$ |
| :--: | :--: | :--: | :--: |
| $1\sim 4$ | $\le 5$ | $\le 3$ |$ \le 3$ |
| $5\sim 6$ | $\le 2\cdot 10^3$| $=0$ | $=1$|
| $7\sim 8$ | $\le 10^2$ | $=1$| $=1$ |
| $9\sim 10$ | $\le 10^2$ | $\le 10$ | $=1$|
| $11\sim 14$ | $\le 10^2$ | $\le 10$ | $\le 10^3$|
| $15\sim 16$ | $\le 10^2$ | $=0$ | $\le 10^{15}$ |
| $17\sim 19$ | $\le 10^2$ | $\le 10$ | $\le 10^{15}$ |
| $20\sim 21$ | $\le 2\cdot 10^3$ | $\le 10^3$ | $\le 10^2$ |
| $22\sim 25$ | $\le 2\cdot 10^3$ | $\le 10^3$ | $\le 10^{15}$ |

**【提示】**

本题部分测试点输入规模较大，我们推荐你使用较为快速的读入方式。

## 样例 #1

### 输入

```
1 4 1 1
1 2 1
2 1 1
3 4 1
4 3 1```

### 输出

```
8```

# 题解

## 作者：Kubic (赞：36)

一种不需要高级线性代数知识的低复杂度做法。

我们只考虑 $m=0$ 的情况。实际上，通过之后的分析可以知道 $m\neq 0$ 的情况可以归约为若干个 $\sum n$ 不超过原来的 $n$ 且 $m=0$ 的子问题。

依次加入每种颜色的边。加入第一种颜色时，我们得到了若干个环。

令点 $u$ 所在的环大小为 $size(u)$。加入第二种颜色时，对于一条边 $u\rightarrow v$，此时要求 $size(u)=size(v)$，否则与条件四矛盾。

进一步利用条件四，我们可以刻画第二种颜色的边：将环划分成若干个集合，要求每个集合中所有环大小相等。对于一个集合，令其中的环为 $C_1\dots C_p$，大小均为 $L$，令 $C_{i,j}$ 表示环 $C_i$ 中（从任意点开始）顺时针编号的第 $j$ 个点。则 $\forall i\in [1,p),j\in [0,L)$，存在第二种颜色的边 $C_{i,j}\rightarrow C_{i+1,j}$。特殊地，$\exist d\in [0,L),\forall j\in [0,L)$，存在边 $C_{p,j}\rightarrow C_{1,(j+d)\bmod L}$。

相当于将一个集合中的环合并成了一个“柱”。

再加入第三种颜色。通过一些分析可以得到：将“柱”划分为若干个集合，要求每个集合中所有“柱”**同构**。连边方式也与之前类似，即为每个“柱”向下一个“柱”的某一种同构方式的对应点连边。

以此类推，我们可以猜测出 $k$ 种颜色的情况：之前的“环”与“柱”都可以被推广为“连通块”，每一轮都是对等价的“连通块”进行合并，形成更大的“连通块”。

实际上，我们可以通过归纳得到一个较为关键的性质：对于一个“连通块”，若看作无标号，那么其中任意两点都是等价的，即存在一种自同构使得这两个点对应，并且这种自同构是唯一的。

因此我们令 $f_{i,j}$ 表示进行 $j$ 步操作能够合并出多少种不同的大小为 $i$ 的**无标号**“连通块”。有转移：

$$
f_{i,j}\times i\rightarrow f_{i',j+1}
$$

其中要求 $i\mid i'$。

其意义为这一步合并了 $\dfrac{i'}{i}$ 个两两同构的大小为 $i$ 的“连通块”。因为无标号，所以我们只乘一个 $i$ 表示最后一层到第一层的连边方式。

我们只需要对于每个 $i\in [1,n]$ 计算 $f_{i,k}$，再进行多项式 exp 即可得到答案。

但 $j$ 这一维可能非常巨大，需要使用一些手段对其进行优化。

将 $f$ 写作生成函数，即令 $F_i(x)=\sum f_{i,j}x^j$。转移可以改写为：

$$
F_i=\dfrac{1}{1-ix}\sum\limits_{j\mid i}F_j\times jx
$$

进一步将 $F_i$ 写作有理分式，容易发现可以令 $F_i$ 分母为 $\prod\limits_{j\mid i}{(1-jx)}$。

只需维护 $F_i$ 的分子（可以证明次数不超过分母），最后用线性递推求出 $k$ 次项系数，即可将时间复杂度降为 $O(\text{poly}(n,\log k))$，使用较好的实现方式可通过本题。

更进一步地，注意到分母形式的特殊性，我们可以将 $F_i$ 写作分式分解形式，即 $F_i=\sum\limits_{j\mid i}\dfrac{w_{i,j}}{1-jx}$。

按照上述转移式直接暴力维护 $w_{i,j}$，即可做到 $O\left(\sum\dfrac{n}{i}d(i)\right)=O(n\log^2 n)$。

这个转移还可以通过类似于“在线高维前缀和”的方式进一步优化，令 $s_{i,j}$ 表示在 $i$ 处只对前 $j$ 个质因子做高维前缀和得到的结果。可以将时间复杂度降为 $O(n\log n\log\log n)$。

参考代码（$O(n\log^2 n)$）：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
const int N=2e6+5,MOD=998244353;
int n,pw[N],id[N],z[N],z1[N];ll m;vector<int> d[N],f[N];
int l,lim,lim1,invL,r[N],inv[N],tmp1[N],tmp2[N],tmp3[N],g[2][N];
void W(int &x,int y) {x+=y;if(x>=MOD) x-=MOD;}
void W(int &x,ll y) {x=(x+y)%MOD;}
int add(int x,int y) {x+=y;return x<MOD?x:x-MOD;}
int qPow(int x,int y)
{int res=1;for(;y;y>>=1,x=1ll*x*x%MOD) if(y&1) res=1ll*res*x%MOD;return res;}
void init(int n)
{
	l=0;lim=1;while(lim<n) ++l,lim*=2;invL=qPow(lim,MOD-2);
	for(int i=0;i<lim;++i) r[i]=(r[i>>1]>>1)|((i&1)<<l-1);
	if(lim>lim1)
	{
		for(int i=1;i<lim;++i) inv[i]=i>1?1ll*inv[MOD%i]*(MOD-MOD/i)%MOD:1;
		for(int i=1,t1,t2,t3,t4;i<lim;i*=2)
		{
			t1=qPow(3,(MOD-1)/(i*2));t2=qPow(t1,MOD-2);t3=t4=1;
			for(int j=0;j<i;++j,t3=1ll*t3*t1%MOD,t4=1ll*t4*t2%MOD)
				g[0][i+j]=t3,g[1][i+j]=t4;
		}lim1=lim;
	}
}
void deriv(int n,int a[]) {for(int i=1;i<n;++i) a[i-1]=1ll*a[i]*i%MOD;a[n-1]=0;}
void integ(int n,int a[]) {for(int i=n-1;i;--i) a[i]=1ll*a[i-1]*inv[i]%MOD;a[0]=0;}
void NTT(bool fl,int a[])
{
	for(int i=0;i<lim;++i) if(i<r[i]) swap(a[i],a[r[i]]);
	for(int i=1,t1,t2;i<lim;i*=2) for(int j=0;j<lim;j+=i*2) for(int k=0;k<i;++k)
	{
		t1=a[j+k];t2=1ll*g[fl][i+k]*a[i+j+k]%MOD;
		a[j+k]=add(t1,t2);a[i+j+k]=add(t1,MOD-t2);
	}if(fl) for(int i=0;i<lim;++i) a[i]=1ll*a[i]*invL%MOD; 
}
void polyInv(int n,int a[],int res[])
{
	if(n==1) {res[0]=qPow(a[0],MOD-2);return;}polyInv((n+1)/2,a,res);
	for(int i=0;i<n;++i) tmp1[i]=a[i];for(int i=n;i<lim;++i) tmp1[i]=0;
	init(n*2-1);NTT(0,tmp1);NTT(0,res);
	for(int i=0;i<lim;++i) res[i]=(2-1ll*tmp1[i]*res[i]%MOD+MOD)*res[i]%MOD;
	NTT(1,res);for(int i=n;i<lim;++i) res[i]=0;
}
void polyLn(int n,int a[])
{
	init(n*2-1);for(int i=0;i<lim;++i) tmp2[i]=0;
	polyInv(n,a,tmp2);deriv(n,a);NTT(0,a);NTT(0,tmp2);
	for(int i=0;i<lim;++i) a[i]=1ll*a[i]*tmp2[i]%MOD;
	NTT(1,a);integ(n,a);for(int i=n;i<lim;++i) a[i]=0;
}
void polyExp(int n,int a[],int res[])
{
	if(n==1) {res[0]=1;return;}polyExp((n+1)/2,a,res);
	for(int i=0;i<n;++i) tmp3[i]=res[i];for(int i=n;i<lim;++i) tmp3[i]=0;
	polyLn(n,tmp3);for(int i=0;i<n;++i) tmp3[i]=add(a[i],MOD-tmp3[i]);++tmp3[0];
	NTT(0,tmp3);NTT(0,res);for(int i=0;i<lim;++i) res[i]=1ll*res[i]*tmp3[i]%MOD;
	NTT(1,res);for(int i=n;i<lim;++i) res[i]=0;
}
int main()
{
	scanf("%*d %d %*d %lld",&n,&m);m%=MOD-1;
	for(int i=1;i<=n;++i)
	{
		pw[i]=qPow(i,m);inv[i]=i>1?1ll*inv[MOD%i]*(MOD-MOD/i)%MOD:1;
		for(int j=i;j<=n;j+=i) d[j].pb(i);
	}
	for(int i=1,t;i<=n;++i)
	{
		f[i].resize(d[i].size());if(i==1) {f[i][0]=z[1]=1;continue;}
		for(int j=0;j<d[i].size();++j) id[d[i][j]]=j;
		for(auto j:d[i]) if(j<i) for(int k=0;k<d[j].size();++k)
			W(f[i][id[d[j][k]]],f[j][k]);
		for(int j=0;j<d[i].size();++j)
		{
			if(d[i][j]<i)
			{
				t=1ll*f[i][j]*(MOD-inv[i-d[i][j]])%MOD;
				f[i][j]=t;W(f[i].back(),MOD-t);
			}W(z[i],1ll*f[i][j]*pw[d[i][j]]);
		}z[i]=1ll*z[i]*inv[i]%MOD;for(auto &x:f[i]) x=1ll*x*i%MOD;
	}polyExp(n+1,z,z1);for(int i=1;i<=n;++i) z1[n]=1ll*z1[n]*i%MOD;
	printf("%d\n",z1[n]);return 0;
}
```

---

## 作者：Wuyanru (赞：34)

赛时拿到高分，赛后和 lrs 花了 1h 推到满分，写题解纪念之。

我也不知道这篇题解怎么这么长。

[题目链接](https://www.luogu.com.cn/problem/P10219)

## 题意

对于一张有 $n$ 个点，$nm$ 条边的有向图（边有编号，编号在 $1\sim m$ 之间，可重），我们称它是好的，当且仅当它满足以下条件：

1. 对于每一个点，以它为起点的边恰好有 $m$ 条，且编号为 $1\sim m$ 的各有一个；
2. 对于每一个点，以它为终点的边恰好有 $m$ 条，且编号为 $1\sim m$ 的各有一个；
3. 任选一个点 $u(1\le u\le n)$ 与两种编号 $j_1,j_2(1\le j_1,j_2\le m)$，设从 $u$ 出发，先走 $j_1$ 边，再走 $j_2$ 边到达的点为 $v_1$，从 $u$ 出发，先走 $j_2$ 再走 $j_1$ 到达的点位 $v_2$，都有 $v_1=v_2$。

现给定一张 $n$ 个点 $m$ 条边的图，保证他是好的。

你现在需要新建 $nk$ 条边，边的编号在 $m+1\sim m+k$ 之间。

求最终这张有 $(k+m)n$ 条边的图，有多少种方案是好的。

 $1\le n\le 2\times 10^3$。

 $0\le m\le 10^3$。

 $1\le k\le 10^{15}$。

## 题解

这道题实在是太难了，我在最终解决它的过程中也使用了一些工具（oeis）。

所以这篇题解主要分为两部分，第一部分根据我的考场思路，讲如何自然地推出 $64$ 分，第二部分讲如何把 $64$ 分优化为满分。

**本题解中所有的连通均指有向图的弱联通。**

### 基础结论

这道题看起来没有任何切入点，我们不妨从简单的情况看起。

考虑 $m=1$ 的时候，整张图长什么样子。

不难发现，此时整张图一定被分为若干个环。

在此基础上，考虑加上编号为 $2$ 的边，看看图会有什么变化。

假设现在有一个编号为 $1$ 的边构成的环 $1\to 2\to 3\to 1$，如下图（黑色表示编号为 $1$ 的边，红色表示编号为 $2$ 的边）：

![](https://cdn.luogu.com.cn/upload/image_hosting/i4cqs11s.png)

假设 $1$ 号点连出的 $2$ 边指向 $x$，$x$ 连出的 $1$ 边指向 $y$。

那么按照第三条条件，从点 $1$ 经过 $2,1$ 两条边到了 $y$，那么从 $1$ 走 $1,2$ 两条边也应该走到 $y$。

那么我们就知道，$2$ 连出的 $2$ 边应当指向 $y$。

同理，$3$ 连出的 $2$ 边，与 $y$ 连出的 $1$ 边应当指向一个点 $z$。

特殊地，我们还可以推出 $z$ 连出的 $1$ 边应当指向点 $x$。

这里可以发现一些规律：

若存在一条 $x$ 边 $u\to v$，则 $u$ 所在的连通块（仅保留前 $x-1$ 种边）连出的所有 $2$ 边，一定在连向 $v$ 所在的连通块。

入边同理。

证明是简单的，按照我上述的过程进行构造即可，由于不是重点就不展开讲了。

特殊地，我们从上述条件中可以看出，如果在连完一条 $x$ 边后，两个连通块合并，则两个连通块大小一定相等。

但是，是否所有大小相等的连通块都可以进行连边合并呢？

显然是不行的。

![](https://cdn.luogu.com.cn/upload/image_hosting/3i7ngros.png)

例如上图有 $3$ 个连通块，每一个连通块大小都是相等的。

但是 $1,2$ 两个连通块不能合并，$2,3$ 两个连通块也不能合并（可以自己试试）。

唯一可以合并的是 $1,3$ 两个连通块，这里画出了可能的一种合并方式。

为了判断两个连通块能否合并，我们不妨自己进行这样一个定义：

>对于两个只存在编号为 $1\sim x$ 的边的连通块 $(V_1,E_1)$ 和 $(V_2,E_2)$，与点 $u\in V_1$ 和 $v\in V_2$。
>
>若称这两个连通块关于 $(u,v)$“同构”，当且仅当：
>
>1. $|V_1|=|V_2|$ 且 $|E_1|=|E_2|$；
>2. 存在 $V_1$ 的排列 $p=(p_1,p_2,\dots,p_{|V_1|})$ 使得 $p_1=u$；
>3. 存在 $V_2$ 的排列 $q=(q_1,q_2,\dots,q_{|V_2|})$ 使得 $q_1=v$；
>4. 对于任意节点 $p_i(1\le i\le |V_1|)$，若从 $p_i$ 出发走 $w(1\le w\le x)$ 边到达了点 $p_j$，则从 $q_i$ 出发走 $w$ 边一定到达节点 $q_j$。

~~不知道这个名字起的怎么样，我觉得挺顺耳的。~~

显然，按照我们的定义，有一些显然的结论，例如同构具有传递性。

那么对于任意两个点 $u,v$，若他们所在的连通块在连完一条 $x$ 边 $u\to v$ 后合法，当且仅当这两个连通块关于 $(u,v)$ 同构。

这个比较简单，就不证了。

比较重要的是下面这个结论：

>对于一个连通块 $(V,E)$ 与其中两点 $u,v\in V$，这个连通块与自己关于 $(u,v)$ 同构。

这个也比较显然，归纳就可以证明。

大题的思路是考虑若干个连通块，在连完一种边后合并在一起的过程。

就可以利用同构的传递性，以及合并连通块需要同构，这两个性质进行证明。

那么还可以推出：

> 对于两个连通块 $(V_1,E_1)$ 与 $(V_2,E_2)$，若他们关于 $(u,v)(u\in V_1,v\in V_2)$ 同构。
>
> 则对于任意两个点 $u'\in V_1$ 与 $v'\in V_2$，这两个连通块关于 $(u',v')$ 同构。

这个也好证，结合上一个结论与传递性即可。

从这个结论也可以看出，两个连通块同构，和我们选取的两个点 $(u,v)$ 并没有什么关系（其实选取也只是为了方便证明）。

所以下文的同构，会将这两个点省略，直接说某两个连通块同构。

这个结论是很有意思的，这告诉我们，对于两个同构的连通块。

如果我们要从第一个连通块向第二个连通块连边，那么我们只需要确定任何一个点所指向的点，就能唯一确定一个合法方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/j7k9735s.png)

### dp 设计

至此，我们就可以尝试进行做法的设计了。

首先考虑输入的图。不难发现，若当前的两个连通块在连完了新的 $k$ 种边后合并了，则这两个连通块此时同构。

显然，我们可以把所有的连通块分为若干类，其中每一类的所有连通块同构。

那么每一类之间的答案是独立的，我们只需要把它们的答案分别算出，乘起来即可。

而将连通块分类也是简单的，容易使用哈希在 $O(n^2+nm)$ 复杂度内完成分类。

现在我们只需要考虑所有连通块都同构的情况了。

设 $dp_{i,j,s}$ 表示现在有 $i$ 个同构的连通块，每一个大小都是 $s$，在连了 $j$ 种边后，所有点被连进一个连通块的方案数。

所有点被连进一个连通块如果能算出来，那么最终的方案容易使用另一个 dp 算出。

考虑这个状态如何转移。

边界状态是简单的，显然有 $dp_{1,0,s}=1$。

否则，我们枚举 $x$，表示第一次连边之后，整张图剩下了 $x$ 个连通块，那么每一个连通块必然是由 $\dfrac{i}{x}$ 个连通块拼起来的。

那么有转移方程 $dp_{i,j,s}=\sum\limits_{x\mid i}dp_{x,j-1,\frac{is}{x}}f_{i,x}\times ?$。

其中 $f_{i,j}$ 表示将 $i$ 个连通块分为 $j$ 个大小相等的圆排列的方案数，容易使用 $O(n\ln n)$ 的 dp 算出。

方程中的 $?$ 表示连边的方案数，这个需要推一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/k2ipsgk8.png)

容易发现，对于前 $\dfrac{i}{x}$ 个连通块来说，他们组成的大连通块长什么样子是无所谓的，所以方案数是 $s^{\frac{i}{x}}$。

而对于后面的所有连通块，我们需要保证练成的样子与第一组同构，所以对于每一组的最后一个连通块，我们有唯一的连边限制。

也就是说，后面所有的方案数是 $s^{(x-1)(\frac{i}{x}-1)}$。

所以转移方程是 $dp_{i,j,s}=\sum\limits_{x\mid i}dp_{x,j-1,\frac{is}{x}}f_{i,x}s^{i-x+1}$。

这样我们就可以在大约 $O(n^2k\ln n)$ 的复杂度内完成转移。

dp 显然是正确的，但是他的复杂度太高了。而且似乎有些怪怪的？

似乎 $s$ 这一维自始至终都是没有任何用处的？

考虑 $dp_{i,j,s}$ 中，$s$ 总共被乘了多少遍。

容易发现，上边的 $i-x+1$ 表示 当前连通块个数 减去 连完一条边的连通块个数 加上 $1$。

那么裂项相消之后不难想到：

> 结论：$dp_{i,j,s}=dp_{i,j,1}s^{i+j-1}$。

考虑归纳证明，对 $j=0$ 显然成立。

假设对 $j<p$ 的情况成立，那么对于 $j=p$ 的情况：

$$
\begin{aligned}
dp_{i,j,s}&=\sum_{x\mid i}dp_{x,j-1,\frac{is}{x}}f_{i,x}s^{i-x+1}\\
&=\sum_{x\mid i}dp_{x,j-1,1}f_{i,x}s^{i-x+1}\left(\dfrac{is}{x}\right)^{x+j-2}\\
&=s^{i+j-1}\sum_{x\mid i}dp_{x,j-1,1}f_{i,x}\left(\dfrac{i}{x}\right)^{x+j-2}\\
&=s^{i+j-1}\sum_{x\mid i}dp_{x,j-1,\frac{i}{x}}f_{i,x}\\
&=s^{i+j-1}dp_{i,j,1}\\
\end{aligned}
$$

显然是对的。

这样我们就可以在 $O(nk\ln n)$ 的时间复杂度内完成这个 dp。

那么这个 dp 就可以只保留前两维，有转移式 $dp_{i,j}=\sum\limits_{x\mid i}dp_{x,j-1}f_{i,x}\left(\dfrac{i}{x}\right)^{x+j-2}$。

总时间复杂度是 $O(nm+n^2+nk\ln n)$，可以拿到 $64$ 分。

时间复杂度瓶颈在于最后这个 dp。

### dp 优化

考场上写完这里就只剩 $1$ 分钟了，直接加了个文件走人了。

考虑先打表看看规律。

首先可以来看 $f_{i,j}(j\mid i)$，可以发现有 $f_{i,j}=\dfrac{i!}{j!\left(\dfrac{i}{j}\right)^j}$。

证明的话还是归纳，显然对 $f_{i,1}$ 都成立。

$$
\begin{aligned}
f_{i,j}&=f_{i-\frac{i}{j},j-1}\left(\dfrac{i}{j}-1\right)!\dbinom{i-1}{\frac{i}{j}-1}\\
&=\dfrac{\left(i-\dfrac{i}{j}\right)!}{(j-1)!\left(\dfrac{i}{j}\right)^{j-1}}\left(\dfrac{i}{j}-1\right)!\dfrac{(i-1)!}{\left(\dfrac{i}{j}-1\right)!\left(i-\dfrac{i}{j}\right)!}\\
&=\dfrac{(i-1)!}{(j-1)!\left(\dfrac{i}{j}\right)^{j-1}}\\
&=\dfrac{(i-1)!}{(j-1)!\left(\dfrac{i}{j}\right)^{j}}\times\dfrac{i}{j}\\
&=\dfrac{i!}{j!\left(\dfrac{i}{j}\right)^j}
\end{aligned}
$$

所以结论成立。

带回原来的式子。
$$
\begin{aligned}
dp_{i,j}&=\sum_{x\mid i}dp_{x,j-1}f_{i,x}\left(\dfrac{i}{x}\right)^{x+j-2}\\
&=\sum_{x\mid i}dp_{x,j-1}\left(\dfrac{i}{x}\right)^{x+j-2}\dfrac{i!}{x!\left(\dfrac{i}{x}\right)^x}\\
&=\sum_{x\mid i}dp_{x,j-1}\left(\dfrac{i}{x}\right)^{j-2}\dfrac{i!}{x!}\\
&=\sum_{x\mid i}dp_{x,j-1}\left(\dfrac{i}{x}\right)^{j-1}\dfrac{(i-1)!}{(x-1)!}\\
\end{aligned}
$$
有个阶乘，还有个指数，很烦，设 $fp_{i,j}=\dfrac{dp_{i,j}}{(i-1)!i^{j-1}}$。

其中边界条件有一些变化，为 $fp_{i,1}=1$，可以发现结果不变。

那么 $fp_{i,j}=\dfrac{dp_{i,j}}{(i-1)!i^{j-1}}=\sum\limits_{x\mid i}\dfrac{fp_{x,j-1}}{x}$。

而我们的目标是求出 $fp_{1\sim n,k}$。

考虑实际意义，$fp_{i,j}$ 实际上是在说：

对于所有长度为 $j$，满足 $a_1=1,a_j\mid i$，且有 $a_{i-1}\mid a_i$ 的序列 $\{a_j\}$。

定义他的权值是 $\prod\limits_i \dfrac{1}{a_i}$，求所有合法序列的权值和。

 考虑 $fp_{i,x+y}$ 的值是多少。

按照实际意义，我们枚举第 $x+1$ 项填了哪个数字。

那么 $fp_{i,x+y}=\sum\limits_{j\mid i}\dfrac{fp_{j,x}fp_{i/j,y}}{j^y}$。

这样我们就可以以一个类似快速幂的形式，求出所有 $fp_{*,k}$ 的值。

总时间复杂度是 $O(n^2+nm+n\ln n\log k)$。

代码比较好写，就不放了~~其实是懒得粘下来~~。

写完力！

update：代码贴到[这里](https://www.luogu.com.cn/paste/x4mg5m28)了，最后一个 dp 的实现不太一致。

---

## 作者：20_200 (赞：15)

# 省选联考 2024 D1T3

### 前言

~~Day1 发挥不完全，Day2 完全不发挥。~~

神题，在机房爆肝了两天。

写篇题解纪念一下，讲讲这题我自认为比较简单的一种推导和做法。

这是本蒟蒻的第三篇洛谷题解，表达能力不佳，请见谅。

### 题解

**性质 & 结论**

>每一种编号的边构成一个排列的置换环。

从题给的前面三个条件可知，每个点每一种编号的边的入度和出度都为一，所以每种编号的编都构成若干个环，也就是一个排列的置换环，给定的图相当于 $m$ 个排列，需要我们再选出 $k$ 个排列。

定义排列复合运算 $(P\times Q)(i)=P(Q(i))$ 。

下文所说连通均只有向图若连通（即将边视为无向后连通）。

第四个条件就是 $P(Q(i))=Q(P(i))$，即 $P\times Q=Q\times P$，选出的排列的复合运算具有交换律，

接下来先考虑只有两个排列 $P,Q$ 的情况。

>同一连通块同一排列的所有环大小相等。

因为 $P\times Q=Q\times P$ ，所以 $P\times P\times Q=P\times Q\times P=Q\times P\times P$ ，以此类推得 $P^n\times Q=Q\times P^n$ ，$P^n(Q(x))=Q(P^n(x))$ 。

设元素 $x$ 在 $P,Q$ 上所在的环分别为 $P_x,Q_x$ ，因为 $P^n(x)$ 最终会把 $P_x$ 遍历一遍，所以上面的式子中，$Q$ 建立了一个从 $P_x\to P_{Q(x)}$ 的双射，则 $|P_x|=|P_{Q(x)}|$ 。

这告诉我们 $P$ 的两个环 $P_x,P_y$ 之间只要连有 $Q$ 的边，那么 $|P_x|=|P_y|$ ，所以同一个连通分量中 $P$ 的任意两个环大小相等，$Q$ 同理。

>同一连通块的所有环都经过另一个排列中的所有环。

上面的推导告诉我们，$P_x$ 中的所有元素经过 $Q$ 置换后恰好一一对应到另一个环 $P_y$ ，则若 $Q$ 的某个环经过 $P_x$ ，那么它一定也会经过 $P_y$ 。而因为 $P_x$ 的所有出边都会到达 $P_y$，因此这个连通分量中，$Q$ 的经过 $P_x$ 的每个环都经过 $P_y$，则 $Q$ 的每个环都要经过 $P$ 的所有环才能保证连通，反之同理。

>同一连通块同一排列的所有环都按一定顺序经过另一个排列中的所有环，且经过次数相等。这里说的经过顺序也构成一个环。

因为连通分量中的所有 $Q$ 环在 $P_x$ 的出边都走向 $P_y$ ，所以所有 $Q$ 环经过 $P$ 的环的顺序是相同的。同样是因为每次经过 $P_x$ 下一步都只能到 $P_y$ ，所以 $Q$ 环在经过 $P_x$ 的最小正周期内必需便利完所有的 $P$ 环，即经过顺序也构成一个环。

>同一连通块同一环内的属于另一排列的同一环中的点的间隔相等。

有了上面的结论，这个就很显然了。因为每个环都会周期性遍地遍历另一个排列的所有环，所以上面说的间隔就是经过另一个排列的环的最小正周期。

这也等价于，同一排列的所有环被另一个排列不同环经过的位置可以通过循环变得本质相同，同一个排列的环和环之间也本质相同。

现在我们已经描述出了只有两个排列时的每个连通块的连边方式，接下来要将它推广到多个排列的情况。

我们考虑现在有若干个连通分量，我们要通过新加一个排列来将它们合并。

首先一定要大小相等，不然明显不行。

但是大小相等也不一定就行，还要看具体的连边情况。

这里定义两个图同构等价于可以将顶点重新标号使得任意两个点之间连的边集相等，边的编号区分。

>一个连通分量的所有位置等价。

每个位置都会被所有排列的某个环经过，而每个排列的位置和环都本质相同，所有一个连通分量中的所有位置本质相同。

>一个连通块确定一个位置作关键点后，其他的点的相对位置就都本质不同。

这可以归纳的证明。因为新加入一个排列，合并一堆连通块可以使得连通块之间存在相对位置区分，本质不同，而可以选一个起点，将新的排列第一次经过每个连通块的点作为关键点，这样每个连通块内部的点就本质不同，因此合并完后的连通块中所有的点都本质不同。

>若干个连通分量可以被合并的充分必要条件是它们同构，合并后的结构由合并前的结构和新排列的环相邻两次经过同一联通块时经过的两点的相对位置唯一确定。

这个是这道题的最终结论，但是根据上面推出的性质，就很好证了。

首先考虑新排列的一个环经过待合并连通块的所有环，然后因为上面那个间隔相同的性质，所有连通分量中对应排列的环都必须以相同的相对位置存在，也就是说所有连通分量同构。

而因为新排列的每一个环相邻两次经过每个连通块的每个环的两点的相对位置都相同，且每个连通块内点可以唯一确定相对位置，因此合并后的连通块的结构可以被新排列的环相邻两次经过同一联通块时经过的两点的相对位置唯一确定。

这个最终结论十分完美，以至于可以直接用来计数。

**DP**

由上面的结论，用一个新的排列将 $x$ 个大小为 $y$ 的同构连通块合并为某一给定结构共有 $y^{x-1}(x-1)!$ 种方案，可以合并产生 $y$ 种不同的结构（若 $x=1$ 就是加的排列经过该连通块的边只连向该连通块内部）。

当前不同构的连通块不可能在增加新的排列后同构，而且同时记录一堆连通块的结构并不方便，所以可以按照全部合并完后的最终结果进行计数。

为了方便变量命名，将原题中的 $k$ 变为 $p$ 。

考虑设计 dp 计算将一些同构的连通块最终合并成一个的方案数。此时因为整个过程中这些连通块都是同构的，所以无需记录它们的结构。

设 $dp_{k,i,j}$ 表示将 $i$ 个大小为 $\frac{k}{i}$ 的连通块用 $j$ 个新排列最终合并为一个大小为 $k$ 的连通块的方案数。

边界条件为 $dp_{k,1,0}=1$ 。

枚举每次加完排列后变成了多少个连通块，乘上有标号划分和连通块合并的方案数，再乘上合并后产生的新结构数，可以推出转移式

$$dp_{k,i,j}=\sum_{x|i}dp_{k,x,j-1}\times\frac{i!}{((\frac{i}{x})!)^xx!}\times((\frac{k}{i})^{\frac{i}{x}-1}\times(\frac{i}{x}-1)!)^x\times\frac{k}{i}$$

代数化简一下

$$dp_{k,i,j}=\sum_{x|i}dp_{k,x,j-1}\times\frac{i!}{(\frac{i}{x})^xx!}\times(\frac{k}{i})^{i-x+1}$$

$$dp_{k,i,j}=\sum_{x|i}dp_{k,x,j-1}\times\frac{i!x^xk^i}{x!i^ik^x}\times\frac{k}{i}$$

把相同的字母尽量移到同一边，使两边保持相同的形式，得到

$$\frac{dp_{k,i,j}\times i^i}{i!\times k^i}=\frac{k}{i}\times\sum_{x|i}\frac{dp_{k,x,j-1}\times x^x}{x!\times k^x}$$

发现转移式与 $j$ 无关，而如果把两边的式子整体看成新的 dp 状态，那么 $k$ 相当于是常数，每次都会乘，可以直接整体提出来到最后再乘，现在转移式就只与 $i$ 有关了。

考虑对把 $k$ 去掉后的式子设计新的 dp

$$dp_{1,0}=1$$

$$dp_{i,j}=\frac{1}{i}\times\sum_{x|i}dp_{x,j-1}$$

这个 dp 十分的简洁，而且每一次转移也只与 $i$ 有关，那么可以使用矩阵快速幂优化。

不过直接矩阵快速幂每次矩阵乘是 $O(n^3)$ 的，但是这个 dp 每个状态只能从它的因子转移而来，因子个数是 $O(\log n)$ 的，故在矩阵乘法时只枚举因子即可做到 $O(n\operatorname{poly}(\log n))$ 的复杂度。

设状态矩阵为 $F$，转移矩阵为 $W$，则 

$$F_j=WF_{j-1}$$

$$W_{i,j}=\frac{[j|i]}{i}$$

$$(X\times Y)_{i,j}=\sum [j|k]\times [k|i]\times X_{i,k}\times Y_{k,j}$$

$$F_m=W^mF_0$$

设 $f_{k,i}=dp_{k,i,p}$ ，即将 $i$ 个大小为 $\frac{k}{i}$ 的连通块用 $p$ 个排列最终合并为一个大小为 $k$ 的连通块的方案数，根据上面的定义得

$$f_{k,i}=F_{i,p}\times k^{p+i-1}\times \frac{i!}{i^i}$$

注意这里 $k$ 的指数需要减一是因为按照上述定义，$dp_{1,0}$ 应该为 $\frac{1}{k}$ ，而我们计算时取得是 $1$ 。

现在我们已经解决了将若干同构连通块合并为一个的问题，还需解决合并结果不固定的问题。

设 $dp_{i,j}$ （和上文同名但无关）表示将大小为 $i$ 的 $j$ 个同构连通块合并成最终结果的方案数，转移就是标准的背包

$$dp_{i,j}=\sum_{k=1}^{j}dp_{i,j-k}\times f_{i\times k,k}\times\binom{j-1}{k-1}$$

答案为初始状态下每一种结构的连通块的方案数乘积。

注意上文 dp 状态里定义的大小和个数的字母不全相同，写的时候别打错了。

**同构判断**

现在这题还剩最后一步，判定初始给定的 $m$ 个环的同构性。好像还没看到有题解讲这个部分，我还想了老半天，是不是巨佬们都觉得太简单了，这里来简单说一下。

如果按照上面计数的方法判定同构，每次计算新加入一个排列相邻两次经过同一个连通分量两点的相对位置，我们需要一种支持快速修改和查询的标号方式来得到每个连通分量的节点的相对位置，这非常难写（我没调对，重构了）。

所以我们应该换一种判定同构的思路。首先枚举每一个连通块，因为所有的点等价，所以可以随便找一个点开始 dfs 。

因为确定一个起点后剩余的点都本质不同，且每条边都是有标号的，所以如果我们记录每个点的 dfn 序，按标号从小到大遍历每个点的每一条边，如果到达的点没访问过就递归进入，这样就得到了一种表现通块结构的节点访问顺序。

在搜索过程中，按搜索的顺序，每搜完一条边，就将其连接的两个点的 dfn 加入一个序列，那么这个序列就可以表示出这个连通块的结构，对这个序列使用哈希即可快速判定两个连通块是否同构。

注意哈希函数的使用，这里需要用到一个三元（原来的哈希值和当前加入的边两端的 dfn 序）的哈希函数，需使三个字母都不对称，可以使用

$$f(x,y,z)=(Cx+y^2z)\bmod P$$

其中 $C,P$ 是互质的常数。

**总结**

上述的矩阵快速幂因为是从因子转移，枚举因子和因子的因子在实现时可能还需要 map 来辅助存储（好写，精细实现可以不用），总共需要 $O(n\log^2n\log\log n)$ 的复杂度。

另一个 dp 是 $O(n^2)$ 的（因为 $\sum{\frac{1}{i^2}}=\frac{\pi^2}{6}$ 是常数），可以用多项式优化但没有必要。

所以现在的瓶颈在于~~输入~~同构的判断，$nm$ 条边显然优化不掉，要是没有这个东西的话，这题不仅好写很多，说不定还可以加强到 $10^5$ 级别。

这种计数题目基本上都是先推一些性质结论，然后用 dp 或者组合方法去计算。结论往往是简洁优美的，千万不要想复杂了。当然，OI 特有的打表猜结论大法也是很好的选择。

这道题充分的告诉我们，一种运算想要有交换律有多不容易。

总时间复杂度为

$$O(n^2+nm+n\log^2n\log\log n\log p)$$

### 代码

```c++
#include<bits/stdc++.h>
#define ll long long
#define ul unsigned ll
#define ld long double
#define pb push_back
#define pii pair<ll,ll>
#define fi first
#define se second
using namespace std;
const ll N=2024,P=998244353;
ll n,m,p,d,h,ans,c[N],fc[N],iv[N],e[N][N],f[N][N],dp[N][N];
vector<ll>b[N];
map<ll,ll>mp[N];
mt19937 rnd(time(0));
void init(){
	fc[0]=iv[0]=iv[1]=1;
	for(ll i=2;i<N;i++)
		iv[i]=(P*P-P/i*iv[P%i])%P;
	for(ll i=1;i<N;i++){
		fc[i]=fc[i-1]*i%P,(iv[i]*=iv[i-1])%=P;
		for(ll j=1;j<N;j++)
			if(i%j==0)b[i].pb(j);
	}
}
ll C(ll x,ll y){return x>=y&&y>=0?fc[x]*iv[y]%P*iv[x-y]%P:0;}
ll ksm(ll x,ll y=P-2){return y?ksm(x*x%P,y>>1)*(y&1?x:1)%P:1;}
void dfs(int x){
	if(c[x])return;c[x]=++d;
	for(ll i=1;i<=m;i++)
		dfs(e[i][x]),h=(h*N+c[x]*c[x]%P*c[e[i][x]])%P;
}
struct mat{
	vector<ll>a[N];
	mat(ll t=0){
		for(ll i=1;i<N;i++)
			a[i].resize(b[i].size()),a[i][a[i].size()-1]=t;
	}
	mat operator*(mat x){
		mat y;
		for(ll i=1;i<N;i++){
			map<ll,ll>s;
			for(ll j=0;j<b[i].size();j++)
				for(ll k=0;k<b[b[i][j]].size();k++)
					(s[b[b[i][j]][k]]+=a[i][j]*x.a[b[i][j]][k])%=P;
			for(ll j=0;j<b[i].size();j++)y.a[i][j]=s[b[i][j]];
		}
		return y;
	}
	mat ksm(ll y){return y?(*this**this).ksm(y>>1)*(y&1?*this:mat(1)):mat(1);}
};
void DP(){
	mat X;
	for(ll i=1;i<N;i++)
		for(ll j=0;j<X.a[i].size();j++)X.a[i][j]=ksm(i);
	X=X.ksm(p);
	for(ll i=1;i<N;i++)
		for(ll j:b[i])
			f[i][j]=X.a[j][0]*ksm(i,p+j-1)%P*ksm(j,P-1-j)%P*fc[j]%P;
	for(ll i=1;i<N;i++){
		dp[i][0]=1;
		for(ll j=1;i*j<N;j++)
			for(ll k=1;k<=j;k++)
				(dp[i][j]+=dp[i][j-k]*f[i*k][k]%P*C(j-1,k-1))%=P;
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>n>>m>>p,ans=1,init(),DP();
	for(ll i=1,x,y,z;i<=n*m;i++)
		cin>>x>>y>>z,e[z][x]=y;
	for(ll i=1;i<=n;i++)
		if(!c[i])d=h=0,dfs(i),mp[d][h]++;
	for(ll i=1;i<=n;i++)
		for(pii j:mp[i])(ans*=dp[i][j.se])%=P;
	cout<<ans;
	return 0;
}
```

---

## 作者：forest114514 (赞：7)

主播主播，你的 DP 确实很强大，但是还是太考验手法了，有没有简单又快速的方法？有的兄弟，有的有的，后面忘了，我们 GF 可是能做到单 $\log$ 而且复杂度和 $k$ 无关的。

限制 $1,2,3$ 就说明每种颜色的边都是一个置换，就是若干个环组成。

然后是最为神秘的限制 $4$，其他题解有详细的证明，我才疏学浅，就不在这里乱胡了。

结论：

1. 一个弱连通块所有颜色的环大小相等，而且一个弱连通块每一个点都是等价的。

2. 考虑任意两种颜色，第一种颜色形成若干环，第二种颜色只会在等长的环之间连边。

   拓展到多个就是任意颜色都只会在本质相同的弱连通块之间连边。

所以每次新加颜色就可以看做合并若干等价类，合并 $x$ 个大小为 $y$ 的等价类有 $y$ 种本质不同的合并方式，每一种的方案数都是 $(x-1)!y^{x-1}$。

假设当前有 $x$ 个大小为 $y$ 的等价类，你每一波变成了新的子问题的时候，假设你合并了 $c_{i,j}$ 个大小 $i\times y$ 的第 $j$ 种块，此时的方案数系数为：
$$
\frac{x!}{\prod\limits_{i\geq 1}\prod\limits_{j=1}^{i} c_{i,j}!(i!)^{c_{i,j}}}\times\prod\limits_{i\geq 1}\prod\limits_{j=1}^{i}((i-1)!y^{i-1})^{c_{i,j}}=\frac{x!y^{x}}{\prod\limits_{i\geq 1}\prod\limits_{j=1}^{i}c_{i,j}!(yi)^{c_{i,j}}}
$$
那个 $x!y^x$ 有相同的形式，然后 $y$ 和 $yi$ 又正好是连通块大小，所以考虑以下 GF，$y$ 指刻画的等价类的大小：
$$
H_{y}(z)=\sum\limits_{i\geq 0}\frac{a_i z^{yi}}{y^ii!}
$$
如果你考虑设 $ H_{t,y}(z)$ 表示当前操作了 $t$ 次，当前等价类大小为 $y$，关于每个数量 $z$ 最后的答案的上述形式 GF，你会发现有：
$$
H_{t,y}(z)=\prod\limits_{i\geq 1}H^{y}_{t+1,iy}(z)
$$
特殊的我们知道边界条件 $H_{k,y}(z)=\sum\limits_{i\geq 0} \frac{z^{iy}}{y^ii!}=\exp( \frac
{z^y}{y})$。

用一点组合计数技巧可以得到 $H_{k,yw}(z)$ 对 $H_{0,y}(z)$ 的贡献为（设 $w$ 的因数分解为 $\prod p_i^{a_i}$）： $val_{w}=\prod\limits_{i}[z^k]\prod\limits_{j=0}^{a_i}\frac{1}{1-p_i^jz}=\prod\limits_{i}{k+a_i\brack a_i}_{p_i}$ 次。（${k+a_i\brack a_i}_{p_i}$ 是 q-组合数，实际上就是 $\frac{\prod\limits_{j=k+1}^{k+a_{i}} (1-p_i^j)}{\prod\limits_{j=1}^{a_i}(1-p_i^j)}$，可以总共 $O(n\log _{n}mod)$ 预处理所有 $p$ 的幂次的答案，瓶颈在于对于所有 $p$ 算 $p^{k}$）

所以你可以知道 $H_{0,y}(z)=\exp({y^{k} \sum\limits_{i\geq 1}val_{i}\times \frac{z^{iy}}{iy}}) $，对于每个 $val_i$ 的贡献，可以用线性筛筛出，于是你可以用一次多项式 exp 得到答案，我们对于一开始有 $x_0$ 个 $y_0$ 大小的连通块，答案为 $[\frac{z^{x_0y_0}}{y_0^{x_0}x_0!}]H_{0,y_0}(z)$。

判同构你可以依次加入每种边，加入一种边之前一定还有若干联通分量，然后一种边的形态只和走多少步回到当前连通块以及回到位置的差异有关，可以记录下每种的颜色对应状态，这样可以通过哈希 $O(nm)$ 得到每种连通块数量和大小。

于是我们得到了 $O(n(m+\log n+\log_{n}mod))$ 的做法，和 $k$ 大小无关而且 $\log_n mod$ 实际上很小可以看做常数，所以很快。

代码：

```cpp
const int N=5050,mod=998244353;
int n,m,pwk[N];
LL k;
LL ksm(LL a,LL b){
	LL res=1;for(;b;b>>=1,a=a*a%mod) if(b&1) res=res*a%mod;return res;
}
int to[2050][2050];
unordered_map<int,int> mp[N];
int dfn[N],Ti,HS;
vector<int> qfac[N],iqfac[N];
int tot,pri[N],vis[N],mnp[N],cntp[N];
LL val[N],fac[N],ifac[N],inv[N];
void sieve(){
	val[1]=1,fac[0]=1;
	rep(i,1,n) fac[i]=fac[i-1]*i%mod;
	ifac[n]=ksm(fac[n],mod-2);
	per(i,n-1,0) ifac[i]=ifac[i+1]*(i+1)%mod;
	
	inv[1]=1;
	rep(i,2,n*2+10) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	
	rep(i,2,n){
		if(!vis[i]){
			int p=i;
			pri[++tot]=p;
			mnp[p]=p,cntp[p]=1,pwk[p]=ksm(p,k);
			
			LL mul=1,cur=pwk[p];
			
			qfac[p].pb(1),iqfac[p].pb(1);
			for(LL ct=1,V=p;V<=n;V*=p,++ct){
				mul=mul*(mod+1-cur)%mod*ksm(mod+1-V,mod-2)%mod;
				qfac[p].pb(mul),iqfac[p].pb(ksm(mul,mod-2));
				cur=cur*p%mod;
			}
			val[p]=qfac[p][1];
		}
		
		for(int j=1;j<=tot&&i*pri[j]<=n;++j){
			vis[i*pri[j]]=1;
			mnp[i*pri[j]]=pri[j];
			if(i%pri[j]==0){
				cntp[i*pri[j]]=cntp[i]+1;
				val[i*pri[j]]=val[i]*iqfac[pri[j]][cntp[i]]%mod*qfac[pri[j]][cntp[i]+1]%mod;
				break;
			}
			cntp[i*pri[j]]=1;
			val[i*pri[j]]=val[i]*val[pri[j]]%mod;
		}
	}
}
namespace poly{
	#define mul(x,y) (1ll*x*y%mod)
	#define add(x,y) (x+y>=mod?x+y-mod:x+y)
	#define dec(x,y) (x-y<0?x-y+mod:x-y)
	int r[N],A[N],B[N],C[N],D[N],F[N],G[N],O[N],f[N],g[N];
	void init(int limit){
	    for(int i=0,l=limit<<1;i<=l;++i) inv[i]=ksm(i,mod-2);
	}
	void NTT(int *A,int type,int len){
	    int limit=1,l=0;
	    while(limit<len) limit<<=1,++l;
	    for(int i=0;i<limit;++i)
	    r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	    for(int i=0;i<limit;++i)
	    if(i<r[i]) swap(A[i],A[r[i]]);
	    for(int mid=1;mid<limit;mid<<=1){
	        int R=mid<<1,Wn=ksm(3,(mod-1)/R);O[0]=1;
	        for(int j=1;j<mid;++j) O[j]=mul(O[j-1],Wn);
	        for(int j=0;j<limit;j+=R){
	            for(int k=0;k<mid;++k){
	                int x=A[j+k],y=mul(O[k],A[j+k+mid]);
	                A[j+k]=add(x,y),A[j+k+mid]=dec(x,y);
	            }
	        }
	    }
	    if(type==-1){
	        reverse(A+1,A+limit);
	        for(int i=0,invl=inv[limit];i<limit;++i)
	        A[i]=mul(A[i],invl);
	    }
	}
	void Inv(int *a,int *b,int len){
	    if(len==1) return (void)(b[0]=inv[a[0]]);
	    Inv(a,b,len>>1);
	    for(int i=0;i<len;++i) C[i]=a[i],D[i]=b[i];
	    NTT(C,1,len<<1),NTT(D,1,len<<1);
	    for(int i=0,l=(len<<1);i<l;++i) C[i]=mul(mul(C[i],D[i]),D[i]);
	    NTT(C,-1,len<<1);
	    for(int i=0;i<len;++i) b[i]=dec(add(b[i],b[i]),C[i]);
	    for(int i=0,l=(len<<1);i<l;++i) C[i]=D[i]=0;
	}
	void Direv(int *A,int *B,int len){
	    for(int i=1;i<len;++i) B[i-1]=mul(A[i],i);B[len-1]=0; 
	}
	void Inter(int *A,int *B,int len){
	    for(int i=1;i<len;++i) B[i]=mul(A[i-1],inv[i]);B[0]=0; 
	}
	void Ln(int *a,int *b,int len){
	    Direv(a,A,len),Inv(a,B,len);
	    NTT(A,1,len<<1),NTT(B,1,len<<1);
	    for(int i=0,l=len<<1;i<l;++i) A[i]=mul(A[i],B[i]);
	    NTT(A,-1,len<<1),Inter(A,b,len<<1);
	    for(int i=0,l=len<<1;i<l;++i) A[i]=B[i]=0;
	}
	void Exp(int *a,int *b,int len){
	    if(len==1) return (void)(b[0]=1);
	    Exp(a,b,len>>1),Ln(b,F,len);
	    F[0]=dec(a[0]+1,F[0]);
	    for(int i=1;i<len;++i) F[i]=dec(a[i],F[i]);
	    NTT(F,1,len<<1),NTT(b,1,len<<1);
	    for(int i=0,l=len<<1;i<l;++i) b[i]=mul(b[i],F[i]);
	    NTT(b,-1,len<<1);
	    for(int i=len,l=(len<<1);i<l;++i) b[i]=F[i]=0;
	}
	LL solve(int x0,int y0){//初始有x0个大y0的块 
		int nn=x0*y0+1;
		LL pw=ksm(y0,k);
		rep(i,1,x0) f[i*y0]=val[i]*inv[i*y0]%mod*pw%mod;
	    int len;for(len=1;len<=nn;len<<=1);init(len);
	    Exp(f,g,len);
	    LL res=1ll*g[x0*y0]*fac[x0]%mod*ksm(y0,x0)%mod;
	    rep(i,0,len<<1) f[i]=g[i]=0;
	    return res;
	}
}
int key1[N],key2[N];
mt19937 Rand(time(0));
void dfs(int x){
	dfn[x]=++Ti;
	rep(i,1,m){
		if(!dfn[to[x][i]]) dfs(to[x][i]);
		HS=(HS*13331ll+1ll*key1[dfn[x]]*key2[dfn[to[x][i]]])%mod;
	}
}
bool _ED;
signed main(){
	fprintf(stderr,"%.20lf MB\n",(&_ST-&_ED)/1048576.0);
	//ios::sync_with_stdio(false);
	//cin.tie(0);cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	read(n,n,m,k),k=k%(mod-1);
	sieve();
	rep(i,1,n) key1[i]=Rand(),key2[i]=Rand();
	rep(i,1,m*n){
		int u,v,c;
		read(u,v,c);
		to[u][c]=v;
	}
	rep(i,1,n){
		if(dfn[i]) continue;
		Ti=HS=0;
		dfs(i);
		mp[Ti][HS]++;
	}
	LL ans=1;
	rep(i,1,n) for(auto j:mp[i]) ans=ans*poly::solve(j.sc,i)%mod;
	write(ans,'\n');
	fprintf(stderr,"%.4lf s\n",1.0*clock()/CLOCKS_PER_SEC);
	return 0;
}
```

---

## 作者：_Diu_ (赞：5)

我的做法和 Wuyanru 大佬的[做法](https://www.luogu.com.cn/article/goqa0h29)基本一致，但是我发现在其中的一些步骤可以通过稍微增加 $\text{ploy}\log$ 因子而降低思考量。下面我将详细介绍这个方法，其他内容不在赘述。具体可以看我的[省选做题记录](https://www.luogu.com.cn/article/swrenvut)。

快进到 dp：

$$
g_{i,k}=\sum_{j|i}\frac{g_{j,k-1}}j
$$

这个和 $k$ 就无关了，可以写成矩乘形式。直接暴力矩乘，复杂度相当于数 $1\le i\le j\le k\le n,i|j,j|k$ 的三元组 $(i,j,k)$ 个数 $S(n)$。
$$
S(n)=\sum_{j=1}^n\lfloor\frac nj\rfloor d(j)
$$
其中 $d(i)$ 表示 $i$ 的约数个数。
$$
O(S(n))=O(n\sum_{i=1}^n\frac 1{\sqrt i})=O(n\sqrt n)
$$
还有高手，上面粗略的把 $d(i)$ 估计成 $\sqrt i$ 是非常松的。
$$
S(n)=\sum_{i=1}^n\sum_{ij\le n}\lfloor\frac n{ij}\rfloor
$$

$$
S(n)=\sum_{i=1}^nH(\lfloor\frac ni\rfloor)
$$

$$
O(S(n))=O(n\log^2 n)
$$

当 $n=2000$ 时 $S(n)=69924$。那么这部分复杂度为 $O(n\log^2 n\log k)$。我们直接矩乘就可以通过。

这里也启发我们：**多层调和级数嵌套并不会增加 $n$ 的指数，只会增加 $\text{poly}\log$ 因子**。

那么我们对于前面的 $O(n^3\log^3n\log k)$ 的矩乘，是否还有分析的空间？

把式子拉回来：

$$
f_{i,j,x}=\sum_{d|i}f_{\frac id,j-1,dx}\times\prod_{l=1}^{\frac id}\binom{ld-1}{d-1}(d-1)!\times x^{i-\frac id+1}
$$

这个也是大部分人能够赛时想到的点，大部分人因为赛时策略安排等原因做到这里就不再往后去想了。但是实际上矩乘如果只维护有值的位置的转移复杂度就是能够接受的！

我们对于每一对 $(i,x)$，要求 $ix\le n$，对 $(i/d,xd)$ 有转移。

那矩乘相当于枚举 $i,x,a,b$，一次矩乘的复杂度实际上是统计 $(iab,x),(ia,xb),(i,xab)$ 这样的转移，要求 $ixab\le n$，那么这个复杂度是 $O(n\log^3n)$ 的。因此最前面的暴力上矩乘优化其实可以做到 $O(n\log^3n\log k)$，也是足以通过的！

---

## 作者：隔壁泞2的如心 (赞：4)

过了大样例，做法应该没假，来一个似乎比较阳间的做法的题解（

为了找到性质，不妨先设 $m=0$ ，然后从 $k=1$ 时开始考虑。当 $k=1$ 时，好的建造方案有个很众所周知的名字——排列（

结合暴力，恭喜你得到了 $24$ 分！

然后再看 $k=2$，如果确定了首层的排列，那么第二层只能在环长相等的环间连边，然后我们可以在许多环间连边，我们可以给这时候的好的建造方案起个很众所周知的名字——循环网格（

![](https://cdn.luogu.com.cn/upload/image_hosting/waz5hu5e.png)

它的合法性理所当然，并且可以证明，所有 $k=2$ 的方案都可以被归类为循环网格。只不过有的循环网格行或列数为 $1$，有的循环网格的列在循环回来后在行上有位移。

恭喜你会了 $m=1$，又喜提了 $8$ 分！

你可以想象一下，这个循环网格的所有点全部等价。那么 $k=3$ 呢？可以发现，第三层只能在前两层里完全相同的循环网格间连边。于是我们可以发现，每建一层都是将低维循环网格合并为高维循环网格的过程。虽然最后会有 $10^{15}$ 层，但是这个合并的过程显然可以用矩阵刻画。比如说要想将 $j$ 个有 $i$ 个点的循环网格合并，设含 $i$ 个点的有标号循环网格数量为 $S_i$，则它对 $S_{ij}$ 的贡献为 $C^{i-1}_{ij-1}(i(j-1))!iS_i$，组合意义是先选出 $1$ 和剩下的 $i-1$ 个标号作新循环网格的第一层，然后再挨个选剩下的标号一点一点连下去，最后连回来的位移有 $i$ 中情况。由于这个矩阵只有少数位置有值，因此最终的矩阵快速幂复杂度是 $O(nlog^2nlogk)$ 的！

不过，我们刚才只考虑了单个连通块的情形。将连通块合并是很套路的多项式操作。只要你没有在高考前天时复健 OI，你就应该会发现求个 exp 就行。这里用最暴力的做法就行，复杂度 $O(n^2logn)$。

恭喜你会了 $k=10^{15}$！那么 $m$ 不为 $0$ 呢？由于只有完全相同的连通块可以合并——

什么？你问我怎么判断相同？那你不要在高考前 100 天时复健 OI。

这里和原先的区别相当于是原本的循环网格中每一个点都变成了同样多个点。如果我们打算将 $j$ 个建好的大小为 $i$ 的连通块合并，那么我们只需要将讨论好的 $i=1$ 时单个连通块的答案乘上 $i^{j-1+k}$，组合意义是在除了第一个连通块内的每个连通块里选出一个点作为“代表”，然后 $k$ 轮建造每轮的偏移都“多”了 $i$ 种情况。

如果你在这一步卡住了，那么不要在高考前 100 天时复健 OI。

现在你做完了此题！这实在是一道综合性很强的题目，你需要会判断连通块是否相同、基础的多项式操作以及一些性质的观察。我已经花了将近 $7$ 个小时在这道题的代码上，写得已经要从沙漠里眺望海市蜃楼了，到底该用什么多项式操作以及到底怎么处理 $m\ne0$ 时的连通块合并在思路上都把我卡成了 $21$。可以预见的是我不可能在任何一场比赛中做出此题，但这都没有我在文化课没有任何转机的时候来做此题显得更为小丑。

不要在高考前 100 天时复健 OI。~~这是代码，要是出数据了但没过的话这个出题人就是题难样例弱的毒瘤！~~

然而真的没过，因为写得太久，忘改 $m=0$ 特判了……

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
#include<cstdlib>
#include<ctime>
#include<cassert>
#include<queue>
#define mod 998244353
#define int long long
#define add(a,b) (a+=(b),a>=mod?a-=mod:0)
#define neg(x) ((x)&1?mod-1:1)
#define Q(a,b) C((a)+(b)-1,(b)-1)
using namespace std;
int fac[407693],ifac[407693],inv[407693];
int C(int n1,int m1){
    if(m1<0||m1>n1)return 0;
    return fac[n1]*ifac[m1]%mod*ifac[n1-m1]%mod;
}
inline int qpow(int n1,int n2){
    int n3=n1,n4=1;
    while(n2){
        if(n2&1)n4*=n3,n4%=mod;
        n3*=n3,n3%=mod;n2>>=1;
    }return n4;
}
inline int mut(initializer_list<int> arg){
	int ret=1;
	for(auto i:arg)ret*=i,ret%=mod;
	return ret;
}
int gcd(int n1,int n2){
	if(n2==0)return n1;
	return gcd(n2,n1%n2);
}
v OId lybb(int *a1,int *a2,int len){
//	for(int i=0;i<=len;i++)printf("%lld ",a2[i]);printf("\n");
	for(int i=0;i<=len;i++)a2[i]=0;a2[0]=1;
	for(int i=1;i<=len;i++){
		for(int j=len;j>=0;j--)
			for(int h=1,v=a1[i];j+h*i<=len;h++,v=v*a1[i]%mod){
				a2[j+h*i]+=a2[j]*v%mod*ifac[h],a2[j+h*i]%=mod;
			}
	}
//	for(int i=0;i<=len;i++)printf("%lld ",a1[i]);printf("\n");
//	for(int i=0;i<=len;i++)printf("%lld ",a2[i]);printf("\n");
}
int work(int n1,int n2,int len){
	if(len==0)return 1;
	if(n1==0)return qpow(n2,len);
	if(n2==0)return qpow(n1,len);
	int p=n2*qpow(n1,mod-2);
	return qpow(p-1,mod-2)*(qpow(p,len+1)-1)%mod*qpow(n1,len)%mod;
}
int cc,n,m,k,l[4016][4016],c[4016][4016],ha[4016],cct[4016],p1[4016],p2[4016],p3[4016],nid=0,rd[4016],id[4016],res[4016][4016];
vector<int> bel[4016];
struct mat{
	int m[2017][2017];
}; 
mat m4,m3,m5;
v OId mmut(mat ma,mat mb,mat &mc){
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j+=i){
			m5.m[i][j]=0;
		}
	}
	for(int i=1;i<=n;i++){
		for(int k=i;k<=n;k+=i){
			for(int j=k;j<=n;j+=k){
//				printf("%lld %lld %lld\n",i,j,k);
				m5.m[i][j]+=ma.m[i][k]*mb.m[k][j]%mod;m5.m[i][j]%=mod;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j+=i){
			mc.m[i][j]=m5.m[i][j];
		}
	}
}
v OId solve(int len,int n2){
	for(int i=1;i<=len;i++){
		for(int j=1;j<=len;j++){
			m3.m[i][j]=m4.m[i][j]=0;
		}
	}
	for(int i=1;i<=len;i++){
		for(int j=1;j*i<=len;j++){
			m3.m[i][i*j]=C(i*j-1,i-1)*fac[i*(j-1)]%mod*i%mod;
		}
	}
	for(int i=1;i<=len;i++){
		for(int j=1;j<=len;j++){
			m4.m[i][j]=(i==j);
		}
	}
	while(n2){
//		for(int i=1;i<=n;i++){for(int j=1;j<=n;j++){printf("%lld ",m3.m[i][j]);}printf("\n");}
//		printf("%lld\n",n2);
		if(n2&1)mmut(m4,m3,m4);
		mmut(m3,m3,m3);n2>>=1;
	}
//	for(int i=1;i<=len;i++){for(int j=1;j<=len;j++){printf("%lld ",m4.m[i][j]);}printf("\n");}
}
map<int,int> mp,siz;
int ds[4016],dt[4016],dcnt=0;
v OId dfsid(int now,int beg){
	id[now]=++nid;bel[beg].push_back(now);
//	printf("%lld %lld %lld\n",now,beg,nid);
	for(int i=1;i<=m;i++){
		if(!id[l[i][now]])dfsid(l[i][now],beg);
		ha[now]^=qpow(id[l[i][now]]+17711,17711+i*7);
	}
}
int dfscmp(int now1,int now2){
	if(bel[now1].size()!=bel[now2].size())return 0;
	for(int i=0;i<bel[now1].size();i++){
		if(ha[bel[now1][i]]!=ha[bel[now2][i]])return 0;
	}
	return 1;
}
signed main(){
//	freopen("wormhole10.in","r",stdin);
//	freopen("wormhole10.out","w",stdout);
	srand(time(0));
    fac[0]=1;for(int i=1;i<=401010;i++)fac[i]=fac[i-1]*i%mod;
    ifac[401010]=qpow(fac[401010],mod-2);for(int i=401010;i>=1;i--)ifac[i-1]=ifac[i]*i%mod;
    for(int i=1;i<=401010;i++)inv[i]=ifac[i]*fac[i-1]%mod;
//    p1[0]=1;p1[1]=-1;gln(p1,p2,20);
//    for(int i=1;i<=20;i++)printf("%lld ",inv[i]);printf("\n");
    scanf("%lld%lld%lld%lld",&cc,&n,&m,&k);
    if(m==0){
    	dcnt=1;ds[1]=n;dt[1]=1;bel[1].push_back(0);cct[1]=n;
	}
	else{
    for(int i=1;i<=n*m;i++){
    	int in1,in2,in3;
    	scanf("%lld%lld%lld",&in1,&in2,&in3);
    	l[in3][in1]=in2;
	}
//	for(int i=1;i<=m;i++){for(int j=1;j<=n;j++){printf("%lld ",l[i][j]);}printf("\n");}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			if(c[i][j])continue;
			int h1=j,h2=l[i][j],cnt=1;
			while(h2!=h1){cnt++;h2=l[i][h2];}
			c[i][h1]=cnt;while(h2!=h1){c[i][h2]=cnt;h2=l[i][h2];}
		}
	}
//	for(int i=1;i<=m;i++){for(int j=1;j<=n;j++){printf("%lld ",c[i][j]);}printf("\n");}
	rd[0]=rand();
	for(int i=1;i<=n;i++)rd[i]=rd[i-1]+1;
	for(int i=1;i<=n;i++){
		if(id[i])continue;
		nid=0;dfsid(i,i);cct[nid]++;
	}
//	for(int i=1;i<=n;i++){
//		for(auto j:bel[i]){
//			printf("%lld ",j);
//		}
//		printf("{%lld}\n",i);
//	}
//	for(int i=1;i<=n;i++)printf("%lld ",ha[i]);printf("\n");
	for(int i=1;i<=n;i++){
		if(id[i]==1){
			int fl=0;
			for(int j=1;j<=dcnt;j++){
				if(dfscmp(dt[j],i)){
					ds[j]++;fl=1;break;
				}
			}
			if(!fl){
//				printf("dcnt=%lld\n",dcnt);
				++dcnt;ds[dcnt]=1;dt[dcnt]=i;
			}
		}
	} 
//	for(int i=1;i<=n;i++)printf("%lld ",id[i]);printf("\n");
	}
	int ans=1;
//	for(int i=1;i<=n;i++)printf("%lld ",p2[i]);printf("\n");
	solve(n,k);
	for(int i=1;i<=n;i++){
//		printf("[%lld]\n",i);
		if(!cct[i])continue;
		int h=cct[i];
		p1[0]=0;
		for(int j=1;j<=h;j++){
			p1[j]=m4.m[1][j]*ifac[j]%mod*qpow(i,j-1+k)%mod;
		}
		lybb(p1,p2,h);
		for(int ss=1;ss<=dcnt;ss++){
			int sz=ds[ss],j=bel[dt[ss]].size();
//			printf("[%lld %lld]\n",sz,j);
			if(j==i){
				ans*=p2[sz]*fac[sz]%mod;
				ans%=mod;
			}
		}
//		printf("%lld\n",ans);
	}
	printf("%lld",ans);
}
```

不要在高考前 100 天时复健 OI。

---

## 作者：Acoipp (赞：3)

## 分析

容易发现，第一二三条限制限制了对于每种颜色的边，都构成若干个环。

第四条限制则值得我们研究一下，我们考虑现在 $1 \sim x-1$ 编号的边都是合法的，然后加入编号为 $x$ 的边（若干个环），在哪种情况下面才会满足第四条限制。

首先我们可以发现如果原图中有两个连通块（这两个连通块一定是强连通的），设为 $S,T$，如果加入编号为 $x$ 的边里面有一条 $u \to v$ 满足 $u \in S,v \in T$，那么就会导致 $S$ 和 $T$ 按照某种顺序循环加边，如果 $|S| \ne |T|$，那么就会有多余的边无法与 $S$ 和 $T$ 匹配，就是不合法的方案。

例如 $S=\{1,2,3\}$，$T=\{4,5,6\}$，并且 $S,T$ 各自形成了一个只有编号为 $1$ 的环，现在考虑加入编号为 $2$ 的边，如果有一条是 $1 \to 5$，那么剩下的边必须是 $2 \to 6,3 \to 4$ 才可以，因为根据题意 $1$ 经过编号为 $2,1$ 的边到了 $6$，那么经过编号为 $1,2$ 的边也一定到 $6$，这样的话 $2 \to 6$ 就必须存在，递归证明即可。

当然，大小相同只是一个必要条件，我们思考一个充要条件。

取 $u \in S,v \in T$，如果排列 $S,T$ 形成 $s,t$ 两个序列并且对于任意 $i,d$ 有（$1 \le i \le |S|,1 \le d <x$）：

- $s_i$ 走一条编号为 $d$ 的边到达了 $s_j$，则 $t_i$ 走一条编号为 $d$ 的边到达了 $t_j$。

则称 $S,T$ 同构，容易发现，如果 $S,T$ 同构，那么对于任意 $u \in S,v \in T$ 都能够找到排列 $s,t$ 满足上述条件。（这个可以数学归纳法求解）

只有 $S,T$ 同构，才能存在一条 $S\to T$ 的编号为 $x$ 的边，然后根据排列 $a,b$ 循环加边就可以了。

所以一次加边就是可以合并两个同构的集合 $S,T$，并且大小不同，集合也就不同构，所以开始 $nm$ 条边就不同构的集合到最后也一定不会同构。

因此我们用哈希处理出来出若干组 $(x,y,z)$ 表示大小为 $x$ 的哈希值为 $y$ 的有 $z$ 个，并且设 $f_{i,j}$ 表示 $i$ 个大小为 $j$ 的连通块连 $K$ 条边并且合法的方案数，答案就是 $\prod f_{z,x}$。

### 哈希处理

对每个连通块，我们按照 DFS 的套路，首先对所有点按照边的编号从小到大排序，优先访问编号小的边，然后得到 dfs 序。

再次按照上面的 dfs 顺序 dfs 下去，遇到一条边就令 $val$ 后面添加上 $dfn_u,id_e,dfn_v$ 三个数字（起点 dfs 序，边的编号，终点 dfs 序），然后对 $val$ 数组执行字符串哈希就可以了。

这个哈希还是比较强的，字符串哈希我取 $base=13331,mod=998244353$ 就可以完美通过。

### dp 处理

我们接下来要得到 $f_{i,j}$ 表示大小为 $i$ 的连通块有 $j$ 个最后互相连接了 $K$ 条边的方案数。

为方便转移，我们设 $dp_{i,j,k}$ 表示大小为 $i$ 的连通块有 $j$ 个，互相连接了 $k$ 条边，最终合并成了一个连通块的方案数。

于是可以得到转移 $f_{i,j} = \sum_{k=0}^{j-1} C_{j-1}^k f_{i,j-1-k} dp_{i,k+1,K}$。

也就是说预处理出来了 $dp_{*,*,K}$ 那么我们就可以 $O(n^2)$ 得到 $f$。

接下来考虑 $dp$ 的转移，首先边界情况就是 $dp_{*,1,0}=1$。

然后有简单的 $dp_{i,j,k}=\sum_{x \mid j} dp_{\frac{ij}{x},x,k-1} g_{j,x} res$。

$res$ 等会再处理，现在考虑 $g_{i,j}$，$g_{i,j}$ 表示 $i$ 个元素均分为 $j$ 个圆排列的方案数量，然后 $g_{i,j}$ 实际上是 $\dfrac{i!}{j!(\frac ij)^j}$，这个可以打表找一下规律或者是归纳法证明，由于笔者太菜不会递推转封闭，所以这里不再赘述。

然后 $res$ 就表示一次连边就合并成了 $x$ 块，那么每一块有 $\frac jx$ 个元素，要让这 $x$ 块每一块都同构，第一块里面的 $\frac jx$ 就可以随便排列连边，由于固定了第一个位置，两个连通块之间的边就固定了，并且这个是可以循环移位的，所以任意固定两个连通块之间的边只有 $i$ 种方法，也就是 $i^{\frac jx}$，然后剩下的 $x-1$ 块，每块有 $\frac jx-1$ 个连通块可以随便循环移位，最后一个移位必须使得这个大块和第一个大块同构，所以就有 $i^{(\frac jx -1)(x-1)}$ 种方案。

然后两者乘起来就是 $res=i^{j-x+1}$。

所以 $dp_{i,j,k}=\sum_{x \mid j} dp_{\frac{ij}{x},x,k-1} g_{j,x} i^{j-x+1}$。（$g$ 先不展开）

然后因为有个 $i^{j-x+1}$ 次方很烦，考虑 $i$ 的次数，合理猜测 $dp_{i,j,k}=dp_{1,j,k}i^{j+k-1}$，然后代进去计算发现没问题，于是就可以消去一维，得到 $dp_{j,k}=\sum_{x \mid j} dp_{x,k-1} g_{j,x} (\dfrac{j}{x})^{x+k-2}$。

把 $g$ 代进去得到：

$$
\begin{aligned}
dp_{j,k}&=\sum_{x \mid j} dp_{x,k-1} \dfrac{j!}{x!(\frac{j}{x})^x} (\dfrac{j}{x})^{x+k-2} \\
&=\sum_{x \mid j} dp_{x,k-1} \dfrac{(j-1)!}{(x-1)!} (\dfrac{j}{x})^{k-1} \\

\end{aligned}
$$

所以就可以在 $O(kn \ln n)$ 的时间复杂度内求出 $dp$ 了，但这显然不优，于是我们设 $p_{j,k}=\dfrac{dp_{j,k}}{(j-1)!j^{k-1}}$，那么就显然有 $p_{j,k} = \sum_{x \mid j} \dfrac{p_{x,k-1}}{x}$。

边界情况就是 $p_{j,1}=1$，这个也很好理解。

而这个东西呢可以理解为一个 dp 式，也就是求满足要求的序列 $a$ 的权值和，$val_a=\prod \frac{1}{a_i}$。

- $|a|=k$ 并且 $a_i \mid a_{i+1},a_1=1,a_k\mid j$。

所以考虑拼接一个长度为 $x,y$ 的 $a$ 序列，仍然合法的方案数。所以我们枚举第 $x+1$ 项填了什么。

得到：

$$
p_{j,x+y}= \sum_{k \mid j} \frac{p_{k,x}p_{\frac jk,y}}{k^y}
$$

于是用倍增求解 $p$ 数组，还原 $dp$ 进而得到 $f$ 数组就可以了！

## 代码

代码如下，时间复杂度显然为 $O(n \log k \log n)$ 预处理加上 $O(n^2)$ DP。

可能常数会有点大。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 998244353
#define N 5005
#define M 4000005
using namespace std;

namespace IO{
	inline char nc(){
		static char buf[1000000],*p=buf,*q=buf;
		return p==q&&(q=(p=buf)+fread(buf,1,1000000,stdin),p==q)?EOF:*p++;
	}
	inline ll read(){
		ll res = 0,w = 1;
		char c = nc();
		while(c<'0'||c>'9')w=(c=='-'?-1:w),c=nc();
		while(c<='9'&&c>='0')res=res*10+c-'0',c=nc();
		return res*w;
	}
	char obuf[1<<21],*p34=obuf; 
	inline void pc(char c){ 
		p34-obuf<=(1<<20)?(*p34++=c):(fwrite(obuf,p34-obuf,1,stdout),p34=obuf,*p34++=c); 
	} 
	inline void write(ll x){ 
		if(x<0) pc('-'),x=-x; 
		if(x>9) write(x/10); 
		pc(x%10+'0'); 
	}
}
using namespace IO;

struct node{ll x,y,z;}p[N];

bool cmp(node a,node b){return a.x<b.x;}
bool cmp2(node a,node b){return a.x>b.x;}

vector<ll> yz[N];
vector<node> op[N];

ll T,n,m,k,i,j,x,y,d,ans=1,tx[N],ty[N],tot,ttt,fp[60][N],nfp[N],dp[N],la[N],ne[M],to[M],val[M],idd[M],temp[N],temp2[N],et,jc[N],inv[N],tim,hashs,dfn_tot,dfn[N];

ll dpn[N],dpw[N],vis[N],found[M];

inline ll qmi(ll a,ll b,ll p){
	ll res = 1%p,t = a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
}

inline void solve(ll *f,ll *ff,ll *g,ll n){
	for(ll i=1;i<=n;i++) for(ll j=0;j<yz[i].size();j++) g[i]=(g[i]+f[yz[i][j]]*ff[i/yz[i][j]]%mod*temp[yz[i][j]])%mod;
}

inline ll C(ll n,ll m){
	if(n<m) return 0;
	return jc[n]*inv[m]%mod*inv[n-m]%mod;
}

inline void dfs(ll x,ll tim){
	vis[x] = tim;
	if(!dfn[x]) dfn[x]=++dfn_tot,hashs = (hashs*13331+dfn[x])%mod;
	ll pos = op[x].size();
	while(pos>=0){
		while(pos>=op[x].size()&&pos>=0) pos--;
		if(pos<0) return ;
		if(found[op[x][pos].z]){
			op[x].pop_back();
			continue;
		}
		ll to = op[x][pos].y,nex = (!dfn[to]?dfn_tot+1:dfn[to]);
		found[op[x][pos].z]=1;
		hashs=(hashs*13331+dfn[x])%mod;
		hashs=(hashs*13331+op[x][pos].x)%mod;
		hashs=(hashs*13331+nex)%mod;
		op[x].pop_back();
		dfs(to,tim);
	}
}

inline ll solve(ll len,ll cnt){
	for(ll i=1;i<=n;i++) dpn[i]=dp[i]*qmi(len,i+k,mod)%mod,dpw[i]=0;
	dpw[0]=1;
	for(ll i=1;i<=cnt;i++) for(ll j=0;j<i;j++) dpw[i]=(dpw[i]+dpw[i-1-j]*C(i-1,j)%mod*dpn[j+1])%mod;
	return dpw[cnt];
}

int main(){
	T=read(),n=read(),m=read(),k=read();
	jc[0]=1;
	for(i=1;i<=n;i++) jc[i]=jc[i-1]*i%mod;
	inv[n]=qmi(jc[n],mod-2,mod);
	for(i=n;i>=1;i--) inv[i-1]=inv[i]*i%mod;
	for(i=1;i<=n;i++) for(j=i;j<=n;j+=i) yz[j].push_back(i);
	for(i=1;i<=n*m;i++){
		x=read(),y=read(),d=read();
		op[x].push_back((node){d,y,i});
	}
	for(i=1;i<=n;i++) sort(op[i].begin(),op[i].end(),cmp2);
	for(i=1;i<=n;i++){
		if(!vis[i]){
			hashs = 0,dfn_tot = 0;
			ll sum = 0;
			dfs(i,++tim);
			for(j=1;j<=n;j++) sum+=(vis[j]==tim);
			p[++ttt] = (node){hashs,sum,0};
		}
	}
	sort(p+1,p+ttt+1,cmp);
	for(i=1;i<=ttt;i=j){
		for(j=i;j<=ttt;j++) if(p[i].x!=p[j].x) break;
		tot++,tx[tot]=p[i].y,ty[tot]=j-i;
	}
	for(i=1;i<=n;i++) fp[0][i]=1,nfp[i]=1;
	for(i=1;i<60;i++){
		for(j=1;j<=n;j++) temp[j]=qmi(qmi(j,(1ll<<(i-1)),mod),mod-2,mod);
		solve(fp[i-1],fp[i-1],fp[i],n);
	}
	k--;
	for(i=59;i>=0;i--){
		if((k>>i)&1){
			for(j=1;j<=n;j++) temp2[j]=nfp[j],temp[j]=qmi(qmi(j,(1ll<<i),mod),mod-2,mod),nfp[j]=0;
			solve(temp2,fp[i],nfp,n);
		}
	}
	for(i=1;i<=n;i++) dp[i]=nfp[i]*jc[i-1]%mod*qmi(i,k,mod)%mod;
	for(i=1;i<=tot;i++) ans=ans*solve(tx[i],ty[i])%mod;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：tribool4_in (赞：3)

连通块定义为极大弱联通分量。

考虑当用一种新边连接两个连通块时，必须要求两个连通块同构，此时连边方案形如错位后依次连接（手玩一下即可发现），然后两个连通块合并为一个。

考虑用 dp 描述这个过程，设 $dp_{i,j,s}$ 表示有 $i$ 个大小为 $s$ 的两两同构的连通块，用 $j$ 种边连成一个连通块的方案数。发现转移需要考虑：$i$ 个连通块（环排列）合并为 $l$ 个的方案，以及每个连通块的连边方案。前者考虑设 $f_{i,j}$ 表示将 $i$ 个东西分成 $j$ 个环排的方案数（满足 $j\mid i$），转移有 $\displaystyle f_{i,j}=f_{i-\frac{i}{j},j-1}\binom{i-1}{\frac{i}{j}-1}(\frac{i}{j}-1)!$（由于是环排，所以相当于固定最小值以免算重，因此几处减一），答案即为 $f_{i,l}$。后者考虑每个连成的“大环”由 $\dfrac{i}{l}$ 个连通块组成，前 $\dfrac{i}{l}$ 个连通块可以随意连边（错位依次连边），为 $s^{\frac{i}{l}}$ 种；其余必须与第一个大环同构，为 $(s^{\frac{i}{l}-1})^{l-1}=s^{i-l+1-\frac{i}{l}}$ 种（即前 $\frac{i}{l}-1$ 条可以选择任意错位，最后一条的错位数需要使得当前整个环的总错位数等于第一个，只有这样才同构）。总方案 $s^{i-l+1}$

于是终于获得了转移：$\displaystyle dp_{i,j,s}=\sum_{l\mid i}dp_{l,j-1,\frac{si}{l}}\times f_{i,l}\times s^{i-l+1}$。

发现这个 $s$ 只作为底数，且转移时也按照 $\frac{i}{l}$ 的系数增加，每次转移其次数会加一，于是猜 $dp_{i,j,s}=dp_{i,j,1}s^{i+j-1}$，可以归纳证明。于是可以只对 $s=1$ 转移，有 $\displaystyle dp'_{i,j}=\sum_{l\mid i}dp'_{l,j-1}\times f_{i,l}\times \left(\frac{i}{l}\right)^{l+j-2}$。

考虑如何求答案。原图中可以划分为若干个同构类。对于某个同构类，设内部包含 $c$ 个同构连通块，每个大小为 $s$，可以将其合并成若干（可能不等价）的连通块。于是设 $g_i$ 表示 $i$ 个同构连通块的方案，有 $\displaystyle g_i=\sum_{j=1}^i g_{i-j}dp_{j,k,s}\binom{i-1}{j-1}$（同样的，环排需要减一）。答案为 $\displaystyle\prod g_c$。

考虑重新表示 $f$。对于 $f_{i,j}$，考虑钦定环排需要满足其第一个元素为最小值。从概率思考，每个小环排合法的概率为 $\dfrac{1}{\frac{i}{j}}$，总共 $\dfrac{1}{(\frac{i}{j})^j}$；环排之间无序，因此钦定其必须升序，为 $\dfrac{1}{j!}$，乘上总方案 $i!$，有 $f_{i,j}=\dfrac{i!}{j!(\frac{i}{j})^j}$。扔回原式：$\displaystyle dp'_{i,j}=\sum_{l\mid i}dp'_{l,j-1}\times \dfrac{i!}{l!}\times \left(\frac{i}{l}\right)^{j-2}$。设 $h_{i,j}=\dfrac{dp'_{i,j}}{i!\times i^{j-2}}$，有 $\displaystyle h_{i,j}=\sum_{l\mid i}\dfrac{h_{l,j-1}}{l}$。

发现第二维值域为 $k$，考虑优化掉。由于最终只需要 $k$ 的答案，考虑倍增。

很人类智慧的，考虑此时 $h$ 的实际意义：定义一个长度为 $j$ 的序列，满足 $a_1=1,\ a_j\mid i,\ a_i\mid a_{i+1}$，权值为 $\displaystyle \prod \frac{1}{a_i}$，则 $h_{i,j}$ 表示所有合法序列的权值和。因此获得转移 $\displaystyle h_{i,j+k}=\sum_{l\mid i}\dfrac{h_{l,j}h_{\frac{i}{l},k}}{l^k}$。可利用此式倍增到 $k$，然后还原 $dp$ 数列，于是做完了。

```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int N = 2e3 + 10, mod = 998244353;
int qpow(int a, long long b = mod - 2) {
    int res = 1;
    for (; b; a = 1ll * a * a % mod, b >>= 1)
        if (b & 1) res = 1ll * res * a % mod;
    return res;
}
int c, n, m;
long long k;
int fac[N], ifac[N], nxt[N][N], C[N][N], fa[N], siz[N];
#define chkmod(x) (((x) >= mod) && ((x) -= mod))
void init() {
    int Mx = 2e3;
    iota(fa + 1, fa + n + 1, 1);
    fill(siz + 1, siz + n + 1, 1);
    for (int i = fac[0] = 1; i <= Mx; i++) fac[i] = 1ll * fac[i - 1] * i % mod;
    ifac[Mx] = qpow(fac[Mx]);
    for (int i = Mx; i >= 1; i--) ifac[i - 1] = 1ll * ifac[i] * i % mod;
    for (int i = 0; i <= Mx; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1], chkmod(C[i][j]);
    }
}
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); };
int dp[N], tp[N];
void dpwork() {
    int mb = -1;
    for (int i = 50; i >= 0; i--) {
        if (k >> i & 1) {
            mb = i;
            break;
        }
    }
    for (int i = 1; i <= n; i++) dp[i] = 1;
    long long l = 1;
    for (int b = mb - 1; b >= 0; b--) {
        for (int i = 1; i <= n; i++) tp[i] = 0;
        for (int i = 1; i <= n; i++) {
            int w = qpow(qpow(i, l));
            for (int j = i; j <= n; j += i) {
                tp[j] += 1ll * dp[i] * dp[j / i] % mod * w % mod;
                chkmod(tp[j]);
            }
        }
        for (int i = 1; i <= n; i++) dp[i] = tp[i];
        l <<= 1;
        if (k >> b & 1) {
            for (int i = 1; i <= n; i++) tp[i] = 0;
            for (int i = 1; i <= n; i++) {
                int w = qpow(i);
                for (int j = i; j <= n; j += i) {
                    tp[j] += 1ll * dp[i] * w % mod;
                    chkmod(tp[j]);
                }
            }
            for (int i = 1; i <= n; i++) dp[i] = tp[i];
            l |= 1;
        }
    }
}
const ull b = 1e9 + 7;
ull gethash(int s) {
    static int cnt = 0, bfn[N];
    static queue<int> q;
    static vector<int> ls, ext;
    memset(bfn, 0, sizeof(bfn));
    ext.clear(), ls.clear();
    ext.push_back(s), ls.push_back(s), bfn[s] = cnt = 1;
    for (int c = 1; c <= m; c++) {
        for (auto u : ext) q.push(u);
        while (!q.empty()) {
            int u = q.front(), v = nxt[u][c];
            q.pop();
            if (!bfn[v]) bfn[v] = ++cnt, q.push(v), ext.push_back(v);
            ls.push_back(v);
        }
    }
    ull res = 0;
    for (auto u : ls) res = res * b + bfn[u];
    return res;
}
ull h[N];
int len[N], g[N];
int DP(int i, int s) { return 1ll * dp[i] * qpow(s, k + i - 1) % mod; }
int getans(int c, int s) {
    g[0] = 1;
    for (int i = 1; i <= c; i++) {
        g[i] = 0;
        for (int j = 1; j <= i; j++) {
            g[i] += 1ll * g[i - j] * DP(j, s) % mod * C[i - 1][j - 1] % mod;
            chkmod(g[i]);
        }
    }
    return g[c];
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> c >> n >> m >> k;
    init(), dpwork();
    for (int i = 1; i <= n; i++) dp[i] = 1ll * dp[i] * qpow(i, k - 1) % mod * fac[i - 1] % mod;
    for (int i = 1, u, v, w; i <= n * m; i++) {
        cin >> u >> v >> w;
        nxt[u][w] = v;
        int fu = find(u), fv = find(v);
        if (fu ^ fv) fa[fu] = fv, siz[fv] += siz[fu];
    }
    for (int i = 1; i <= n; i++) {
        if (find(i) != i) continue;
        h[i] = gethash(i);
        for (int j = 1; j <= i; j++) {
            if ((len[j] || j == i) && h[j] == h[i]) {
                len[j] += 1;
                break;
            }
        }
    }
    int ans = 1;
    for (int i = 1; i <= n; i++) {
        if (!len[i]) continue;
        ans = 1ll * ans * getans(len[i], siz[i]) % mod;
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：eastcloud (赞：3)

讲一些 @Kubic 的 [这篇文章](https://www.luogu.com.cn/article/o15f26g1) 中没有提到的点，做法原文已经解释得很详细了，这里补充了一些细节和完整实现。

对于两个连通块能够连边当且仅当它们同构的结论，这里补充一个感性理解，首先每个连通块的一个颜色的所有边都会连到另一个连通块上，否则一定不合法。

然后你可以将性质 4 这么理解：先考虑归纳，你现在将若干个连通块的边连成了环，现在这个环上的连通块各有一个分身，本体在你一开始所在连通块上，走连通块间的边相当于切换本体所在的连通块，否则就是所有分身走对应的一步。

这个性质要求切换本体所在连通块的顺序不影响答案，不难发先这其实就是同构的定义。

然后，在将转移式转化为生成函数时，原文写的比较简略：

$$ F_i =\sum_{j|i} F_j\times jx$$

$$ F_i -F_i\times ix=\sum_{j|i,j\neq i} F_j$$

$$ F_i =\frac{1}{1-ix}\sum_{j|i ,j\neq i} F_j \times jx$$

初值是 $F_1 = \frac{1}{1-x}$。

接着，对于分式分解部分如何维护 $w_{i,j}$ 以及求出答案，我们先假设已经将所有小于 $i$ 的数进行了分式分解，那么 $F_i$ 形似：

$$\sum_{j|i} \frac{cx}{(1-ix)(1-jx)}$$

对于求和里的每一项进行分解，那就待定系数法解个方程就行。

无标号转为有标号只要乘 $(n-1)!$ 就行，原因在于如果直接 $n!$，某个编号填到另外一个节点时会有有且仅有一种编号方式使这两种同构，因此还要除 $n$。

当 $m=0$ 扩展时，原图只有同构的连通块才能互相连边，因此我们要用哈希判断一下同构，然后对于每一个类型的连通块分别计算，发现只要我们对点的出边按编号排序求出 dfs 序，那么同构当且仅当任意一条一个连通块有的边另一个连通块也有（边形如 $(u,v,w)$，$u$ 和 $v$ 表示原边端点 dfs 序，$w$ 是编号）。

这里 dfs 树根随便选~~不难发现这样很对~~，严谨证明可以归纳。哈希判断一个方便的方法是，你对每条本质不同边随机赋权，连通块权值就是边异或和，map 判重即可。

缩点之后转移也要改，设当前算的连通块类型大小为 $w$，那么转移就变成了：

$$ F_i =\sum_{j|i} F_j\times wjx$$

$$ F_i =\frac{w}{1-wix}\sum_{j|i ,j\neq i} F_j \times jx$$

原因在于此时大小实际上是 $wi$，然后分式分解的时候注意一下系数就行。

最后放一下我的 [完整实现](https://paste.ubuntu.com/p/9c4W2mKpgJ/)，写的比较丑还不如平方快（

---

## 作者：lupengheyyds (赞：2)

# P10219 [省选联考 2024] 虫洞 题解

前三个条件说明对于每种编号构成的子图都是形如若干个环，于是这启发我们对于每种颜色分别处理。考虑现在已经处理了编号为 $1\sim i-1$ 的边，考虑加入编号为 $i$ 的边，看什么条件下会合法。

不难发现合法的添加有两种：

- 在一个连通块 $G=(V,E)$ 中加边。加边方式形如一个循环移位（即一个大环）。并且可以发现当一个点的连边被确定后，整个连通块的加边方案就确定了。所以方案数为 $|V|$。

- 在从连通块 $G_1=(V_1,E_1)$ 向连通块 $G_2=(V_2,E_2)$ 连边。为了满足第四个条件，这两个连通块应该是同构的（同构是指可以对两个联通块中的点进行重标号使得这两个连通块相同，显然一个必要条件为 $|V_1|=|V_2|\land |E_1|=|E_2|$）。同理，方案数为 $|V_1|$。

由此我们可以发现两个性质：

- 对于任意连通块，它是强连通的。

- 一个连通块中的各个点是等价的。

- 如果两个连通块一开始不同构，那么以后他们不可能在同构。

所以在一开始可以将同构的连通块放在一起单独处理，这可以通过 Hash 实现。发现转移的代价仅与连通块点数有关，这启示我们忽略其连通块具体构造而仅记录其点数进行处理。

设 $f_{i,j}$ 表示将 $i$ 个有 $j$ 个点的连通块添加 $K$ 种边的方案数。假设我们将同构的联通块放在一起形成若干组 $(G,|V|,cnt)$，则答案为 $\prod f_{cnt,|V|}$。

---

现在考虑如何求 $f$。

由于 $f$ 的图中个连通块最后不一定合并成一个连通块，用一般图计数的思路，枚举第 $n$ 个点在的连通块，化为处理连通图计数问题。

设 $dp_{k,i,j}$ 表示添加了 $k$ 种边，有 $i$ 个含 $j$ 个点的连通块，并最终合并成一个连通块的方案数，枚举第 $i$ 个连通块所在的那个连通块，有转移：

$$
f_{i,j}=\sum_{k=1}^idp_{K,k,j}f_{i-k,j}{i-1\choose k-1}
$$

---

现在考虑如何求 $dp_{}$。

枚举合并为几个连通块，有转移 $dp_{k,i,j}=\sum_{x|i}dp_{k-1,x,\frac {ij}x}g_{i,x}res$。

其中 $g_{i,j}$ 表示将 $i$ 个点分为 $j$ 个圆排列的方案数。考虑每次选出 $\frac ij$ 个点进行圆排列的过程，方案数为 $\frac{i!}{\frac ij(i-\frac ij)!}\times \frac{(i-\frac ij)!}{\frac ij(i-2\frac ij)}\times \cdots=\frac{i!}{(\frac ij)^j}$ 由于圆排列之间是无序的，再除以 $j!$ 最终方案数为 $\frac{i!}{j!(\frac ij)^j}$。

$res$ 表示一次连边合并为 $x$ 块，且两两同构的方案数。对于第 $1$ 块里面的 $\frac jx$ 可以随便连边，即 $j^{\frac ix}$ 种，对于剩下的 $x-1$ 块，前 $\frac ix-1$ 可以随便连，最后一个必定可以使得整个图同构（画图可以理解），即 $j^{(\frac ix-1)(x-1)}$ 种。两者乘起来为 $j^{i-x+1}$ 种。

于是：

$$
dp_{k,i,j}=\sum_{x|i}dp_{k-1,x,\frac {ij}x}\frac{i!}{x!(\frac ix)^x}j^{i-x+1}
$$

设 $h_{k,i,j}=\frac{dp_{k,i,j}}{j^{i}}$，整理可得 $h_{k,i,j}=j\sum_{x|i}h_{k-1,x,j\times \frac {i}x}\frac{i!}{x!(\frac ix)^x}$，发现这次转移 $h_{k,i,j}$ 相比 $h_{k,i,1}$ 仅是多乘了一个 $j$ ,而其第三维所有可以到的状态也是 $\frac ix$ 与 $j\times \frac ix$ 即乘了一个 $j$ 的区别，于是可以发现性质：$h_{k,i,j}=j^{k-1}h_{k,i,1}$，进一步可得：

$$
dp_{k,i,j}=j^{k+i-1}dp_{k,i,1}
$$

---

设 $q_{i,j}=dp_{i,j,1}$，则有：

$$
q_{i,j}=\sum_{x|j}q_{i-1,x}\frac{j!}{x!(\frac jx)^x}(\frac jx)^{i+x-2}=\sum_{x|j}q_{i-1,x}\frac{(j-1)!}{(x-1)!}(\frac jx)^{i-1}
$$

设 $p_{i,j}=\frac{q_{i,j}}{(j-1)!j^{i-1}}$，则有：

$$
p_{i,j}=\sum_{x|j}\frac{p_{i-1,x}}{x}
$$

我们发现这是一个进行多次的迪利克雷卷积式，而我们知道一般可以由卷积 $x$ 的结果卷上卷 $y$ 次的结果得到卷 $x+y$ 次的结果。

我们去探索这种表达式，首先推导一个 $x\to x+2$ 的表达式，

$$
\begin{aligned}
&p_{i+2,j}\\
=&\sum_{x|j}\frac {p_{i+1,x}}{x}\\
=&\sum_{x|j}\sum_{y|x}\frac{p_{i,y}}{xy}\\
=&\sum_{y|x}\frac{p_{i,y}}{y^2}\sum_{x|\frac jy}\frac 1x\\
=&\sum_{y|j}\frac{p_{i,y}p_{2,\frac iy}}{y^2}
\end{aligned}
$$

于是我们猜测 $p_{x+y,j}=\sum_{k|j}\frac{p_{x,k}p_{y,\frac jk}}{k^y}$，可以用数学归纳法证明确实是这样的。

这样通过倍增处理 $p_{2^k,*}$ 在 $\mathcal O(n\log n\log k)$ 算出 $p_{K,*}$。

于是上我们解决了这道题。

---

关于如何 Hash 判同构。

我们知道各个点是等价的，于是从任何一个点开始，优先通过编号更小的边开始DFS，将每条边起点 $u$ 与 终点 $v$ 的 dfn 值作为一组进行 hash 即可。

代码（注意 dp 各维顺序有变）：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int NN=2e3+5,MOD=998244353,N=2025;
typedef pair<int,int> pa;
int n,m,K;
int to[NN][NN],p[50][NN],p_final[NN],dp[NN][NN],fac[NN],f[NN],c[NN][NN],dfn[NN],num,h,ans=1,inv[100][NN];
vector<int> fc[NN];
int QP(int a,int b,int p=MOD){
    int c=1;
    for(;b;b>>=1){
        if(b&1)c=1ll*a*c%p;
        a=1ll*a*a%p;
    }
    return c;
}
void PreWork(){
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j+=i)fc[j].push_back(i);
    fac[0]=1;for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%MOD;
    c[0][0]=1;
    for(int i=1;i<=n;i++){
        c[i][0]=1;
        for(int j=1;j<=n;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;
    }
    for(int i=0;i<=50;i++){
        int tmp=QP(2,i,MOD-1)*(MOD-2);
        for(int k=1;k<=n;k++)inv[i][k]=QP(k,tmp);
    }
    return;
}
void P(){
    for(int i=1;i<=n;i++)p[0][i]=1;
    p_final[1]=1;
    for(int i=1;i<=__lg(K);i++)
        for(int j=1;j<=n;j++)
            for(int k:fc[j])(p[i][j]+=p[i-1][k]*p[i-1][j/k]%MOD*inv[i-1][k])%=MOD;//QP(2,i-1)是放在指数上的，应该%(MOD-1)而非%MOD 
    for(int i=__lg(K);i>=0;i--){
        if((K>>i)&1){
            for(int j=n;j>=1;j--){
                int tmp=0;
                for(int k:fc[j])(tmp+=p_final[k]*p[i][j/k]%MOD*inv[i][k])%=MOD;
                p_final[j]=tmp;
            }
        } 
    }
    return;
}
void DP(){
    for(int i=1;i<=n;i++)
        dp[1][i]=p_final[i]*fac[i-1]%MOD*QP(i,K-1)%MOD;
    for(int j=1;j<=n;j++){
        int tmp=QP(j,K);
        for(int i=1;i<=n;i++){
            dp[j][i]=dp[1][i]*tmp%MOD;
            (tmp*=j)%=MOD;
        }
    }
    return;
}
int F(int i,int o){
    f[0]=1;
    for(int j=1;j<=o;j++){
        f[j]=0;
        for(int k=1;k<=j;k++)
            (f[j]+=c[j-1][k-1]*f[j-k]%MOD*dp[i][k])%=MOD;
    }
    return f[o];
}
void DFS(int x){
    if(dfn[x])return;
    dfn[x]=++num;
    for(int i=1;i<=m;i++){
        DFS(to[x][i]);
        h=(h*N+dfn[x]*dfn[x]%MOD*dfn[to[x][i]])%MOD;
    }
    return;
}
unordered_map<int,int> mp[NN];
signed main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>n>>n>>m>>K;
    for(int i=1;i<=n*m;i++){
        int u,v,w;cin>>u>>v>>w;
        to[u][w]=v;
    }
    for(int i=1;i<=n;i++){
        if(dfn[i])continue;
        num=h=0;
        DFS(i);
        mp[num][h]++;
    }
    PreWork();
    P();
    DP();
    for(int i=1;i<=n;i++)
        for(auto o:mp[i])
            (ans*=F(i,o.second))%=MOD;
    cout<<ans;
    return 0;
}
```

---

## 作者：Ihave4oranges (赞：2)

赛时不会 T2，会这道题的 80pts，但是没调出来，只拿到了 40pts。

[原题](https://www.luogu.com.cn/problem/P10219)|[提交通道](https://www.luogu.com.cn/problem/P10219#submit)

## 题意

称一个有 $n$ 个点，$nm$ 条有编号边的有向图是「好的」，当且仅当：

- 每个点作为起点的边的编号集合为 $\{1,2,\dots,m\}$
- 每个点作为终点的边的编号集合为 $\{1,2,\dots,m\}$
- 从一个点 $u$ 出发，依次经过两条编号分别为 $j_1$ 和 $j_2$ 的边，设到达的点为 $v_1$。从点 $u$ 出发，依次经过编号为 $j_2$ 和 $j_1$ 的边，设到达的点为 $v_2$。则 $v_1=v_2$ 永远成立。

给你一个有 $n$ 个点，$nm$ 条边的「好的」有向图。你需要增加编号分别为 $m+1,m+2,\dots,m+k$ 的有向边各 $n$ 条，使得新的图也是「好的」。求合法的方案数，对 $998244353$ 取模。

## 题意理解

首先考虑前两个条件。对于所有编号为 $i$ 的边，它们的起点集合一定是 $\{1,2,\dots,n\}$，终点集合也是一样，所以这些边一定构成若干个不相交的环（允许自环）。

接下来考虑第三个条件。这个条件是关于两条边的，那么我们能不能把它推广到三条边？四条边？任意多条边呢？

答案是肯定的。注意到这个条件等价于，把一条路径的相邻两条边的编号交换（中间的那个节点可能会改变），这仍然是一条路径。这也就是说，一个点经过一个可重集合中所有元素作为编号的边，最终到达的点一定是确定的，且与经过这些边的顺序无关。

## 一些结论

**1. 对于一个「好的」连通图，它的自同构数量等于它的点数。**

这里，连通的意思是，把所有边看成无向边之后，整个图连通。

假设这个连通块的点编号为 $1,2,\dots,k$。枚举编号为 $1$ 的点在其同构图中的对应点的编号。不妨设这个点编号是 $2$。

把原图的反图加入，反图中的边的编号为其原来编号的相反数。

考虑从这两个点开始，经过一条编号为 $i$ 的边。如果要满足同构的条件，那么这两条边分别到达的点，在原图与这个自同构图中，也一定是对应的。

这就保证了，在固定了 $1$ 号点的对应点的情况下，自同构图的数量不会超过 $1$ 个。

下面证明这样的自同构图一定存在。

假设不存在。那么一定存在一个可重集合 $S$，满足从点 $1$ 出发，经过 $S$ 中的所有元素的编号的边，还能回到点 $1$。但是从点 $2$ 出发，经过 $S$ 中的所有元素的编号的边，不能回到点 $2$。不妨设到达的点为 $3$。

设从点 $2$ 经过某个集合 $S^\prime$ 的边之后，能到达点 $1$。由于 $1$ 和 $2$ 连通，所以这样的 $S^\prime$ 一定存在。这就是说，从点 $2$ 出发，经过集合 $S\cup S^\prime$ 的所有边，能到达 $1$。那么，我们从点 $2$ 出发，先经过 $S$ 中的所有边，到达 $3$，根据之前的结论，点 $3$ 经过 $S^\prime$ 中的边之后，一定能到达 $1$。这样，点 $2$ 和点 $3$ 分别经过集合 $S\cup S^\prime$ 中的边，都能到达点 $1$。考虑取 $S\cup S^\prime$ 中所有边的反边。那么，从点 $1$ 出发，经过这个新的反边集合中的边，既能到达 $2$，又能到达 $3$，这与之前的结论矛盾。

所以，假设不成立。这样的图一定存在。

这样，我们证明了，对于一个连通图，$1$ 号点对应每个点，都存在恰好一个自同构图。

**2. 原图中的两个连通块，它们最终有可能在同一个连通块中，当且仅当它们同构。**

这个并不难证明。

先证充分性，必要性显然。

设两个连通块为 $G_1$ 和 $G_2$。固定这两个连通块中的一组对应点 $v_1$ 和 $v_2$，用新的一条边从 $v_1$ 连向 $v_2$。那么我们可以用类似前面的方法，确定其它点的对应关系，这样就保证了其它点之间连边的唯一性。

这样我们仅仅连接了一半的边。再随意找一组对应点 $v_3$ 和 $v_4$（可以是在前一步中不对应的一组点），从 $v_4$ 向 $v_3$ 连边。那么对于这一种（可能不同的）对应关系，它的连边方式也是唯一的了。

在证明过程中，我们还得出了一个结论：两个大小都为 $x$ 的同构的连通块，把它们用一种新的编号的边连接到一起，方案数为 $x^2$。

考虑推广这个结论。假设有 $y$ 个大小都为 $x$ 的同构的连通块，把它们用一种新的编号的边连接到一起。首先把这些连通块放到一个有向的圆排列中，相邻两个图之间随意固定一组对应点连边，其它边就是唯一的了。所以总共的方案数为 $x^y\times(y-1)!$。

## 80pts 做法

先把每一组同构的连通块找出来，统计它们的答案。由于不同构的连通块永远不能合并，所以最总答案就是这些答案的乘积。

根据之前的结论，我们只关心连通块的点数以及它们是否互相同构，而不关心它们具体的结构。所以，对于一组同构的连通块，有用的信息只有每个连通块的点数 $x$ 和连通块的个数 $y$。下面只计算一组的答案。

考虑最终的图中，原图中的连通块哪些合并到了一起。对于最终的图中的每一个连通块，它的方案数只与它包含原图中的连通块个数有关。那么这种结构的图它的方案数就等于它各个连通块的方案数的乘积。

我们设计一个 dp 状态：用 $dp_{i,j}$ 表示，最终图的 $i$ 个连通块，包含了原图中的 $j$ 个连通块。为了避免重复计数，我们额外要求，每次选取一个新的集合，它必须要包含目前还未选择的连通块中，编号最小的一个。设 $f_i$ 表示，$i$ 个原图中大小为 $x$ 的连通块，最终合并到一起的方案数。那么有：

$$
dp_{i,j}=\sum_{k=1}^jdp_{i-1,j-k}\times f_{k}\times\binom{k-1}{n-(j-k)-1}
$$

这里的状态数是 $O(n^2)$ 的，转移是 $O(n)$ 的，所以时间复杂度为 $O(n^3)$。之后会进行优化。

那么我们现在只剩下了 $f$ 数组。

考虑按照编号顺序依次添加一组新边。

为了使最终所有的连通块能合并，每一个时刻中，所有连通块必须同构。设 $dp_{i,j}$ 表示添加了 $i$ 种边，目前已经把每 $j$ 个连通块合并成了一个新的连通块的方案数。需要注意这个 dp 与之前的无关。

显然，$dp_{k-1,i}$ 能转移到 $dp_{k,j}$ ，必须满足 $i\mid j$。所以，真正有用的状态 $dp_{i,j}$ 必须满足 $j\mid y$。

下面计算 $dp_{k-1,i}$ 到 $dp_{k,j}$ 的转移系数。

首先，我们目前还剩 $\frac{y}{i}$ 个连通块。考虑把它们分成 $\frac{y}{j}$ 个大小为 $\frac{j}{i}$ 的圆排列，则方案数为：

$$
\frac{\left(\frac{y}{i}\right)!}{\left(\frac{j}{i}\right)^{\frac{y}{j}}}
$$

然后，由于要保证这些合并后的连通块依然同构，所以这些圆排列种的连边方式必须相同（同构）。

对于第一个圆排列，它可以随意连边，所以它的方案数为 $(ix)^{\frac{j}{i}}$。

对于之后的圆排列，我们这样考虑：假设从一个点 $u$ 连续经过 $\frac{j}{i}$ 条新边之后回到点 $v$（这两个点一定在同一个当前的连通块中）。新建一个有向图，点集为 $u$ 的所在的当前的连通块中的点，然后把所有这样的 $u$ 向 $v$ 连一条边。这个图，与所有其它圆排列所构成的图，需要保证同构。

那么，对于其它圆排列，除了最后一对相邻的连通块之外，其它的相邻连通块之间，还是可以随意连边，方案数也是 $ix$，总方案数就是 $(ix)^{\frac{j}{i}-1}$。

所以，$dp_{k-1,i}$ 到 $dp_{k,j}$ 的转移系数为：

$$
\frac{\left(\frac{y}{i}\right)!}{\left(\frac{j}{i}\right)^{\frac{y}{j}}}\times(ix)^{\frac{y}{i}-\frac{y}{j}+1}
$$

由于（原题中的）$k$ 太大了，我们使用矩阵快速幂来转移。状态数为 $d(y)$，矩阵乘法的时间复杂度是 $O(d(y)^3)$，所以总时间复杂度为 $O(d(y)^3\log k)$。

我们要对于 $1\le i\le y$ 的每个 $i$ 求出 $f_i$，所以最终的时间复杂度为 $O(\sum_{i=1}^nd(i)^3\log k)$。这个应该是正确的，但是我没有证明，也没有计算。复杂度瓶颈在于之前 $O(n^3)$ 的 dp。加上 $m=0$ 且 $k=1$ 的数据可以拿到 80pts。事实上我的代码可以通过 96pts~100pts。

## 100pts 做法

再次观察转移方程。

$$
dp_{i,j}=\sum_{k=1}^jdp_{i-1,j-k}\times f_{k}\times\binom{k-1}{n-(j-k)-1}
$$

把组合数拆开：

$$
dp_{i,j}=\sum_{k=1}^jdp_{i-1,j-k}\times f_{k}\times\frac{(n-(j-k)-1)!}{(k-1)!(n-j)!}
$$

重新组合：

$$
dp_{i,j}\times(n-j)!=\sum_{k=1}^jdp_{i-1,j-k}\times(n-(j-k)-1)!\times \frac{f_{k}}{(k-1)!}
$$

固定一个 $i$，那么这就是一个卷积的形式，可以 NTT 优化到 $O(n\log n)$。$i$ 最多循环到 $n$，所以总共的时间复杂度为 $O(n^2\log n)$，这样就可以通过本题了。

最终时间复杂度为 $O(n^2\log n+\sum_{i=1}^nd(i)^3\log k)$。

这道题的数据没有卡满（而且好像也不太可能卡满），所以我的没有经过优化的 $O(n^3)$ 代码加上 $m=0$ 且 $k=1$ 的特判刚好能过，最后一个点有一定概率 AC/TLE。事实上，孤立的点太多，容易让假做法或者一些依赖于连通块大小的做法通过，而孤立点太少就会使连通块数量减少，就会让像我这样的代码通过。

## 调试

可以用我的代码输出矩阵，测试数据为 `0 8 0 3`（感谢 @zhuzhu2891）。

我调试的时候是发现了 $m=0$，$k=3$ 时答案关于 $n$ 的 OEIS 数列 [A072169](https://oeis.org/A072169)，才得到答案的。

~~这是我的 $O(n^3)$ 代码，改天再写 $O(n^2\log n)$。~~ upd：写好了

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353,G=3,Gi=332748118;
inline int read(){
	int x=0;bool f=0;char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=1;
		ch=getchar();
	}
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
inline void write(int x){
	if(x==0){putchar('0');return;}
	if(x<0){putchar('-');x=-x;}
	char ch[21];int cnt=-1;
	while(x){
		ch[++cnt]=(x%10)^48;
		x/=10;
	}
	while(~cnt){putchar(ch[cnt--]);}
}
inline int poW(int x,int y){
	int res=1;
	while(y){
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
int fact[1000005],inv[1000005],invn[1000005];
inline void getfact(int x){fact[0]=1;for(int i=1;i<=x;++i)fact[i]=fact[i-1]*i%mod;}
inline void getinv(int x){getfact(x);inv[x]=poW(fact[x],mod-2);for(int i=x;i;--i)inv[i-1]=inv[i]*i%mod;}
inline int C(int x,int y){return fact[x]*inv[y]%mod*inv[x-y]%mod;}
int rev[2100000];
struct Poly{
	int size;
	vector<int> a;
	Poly(){size=0;a.clear();a.push_back(0);}
	Poly(int n){size=n;a.clear();a.resize(n+1);a.shrink_to_fit();}
	void resize(int n){size=n;a.clear();a.resize(n+1);a.shrink_to_fit();}
	void print(){for(auto x:a) cout<<x<<" ";cout<<endl;}
	friend bool operator <(Poly x,Poly y){return x.size<y.size;}
	friend bool operator >(Poly x,Poly y){return x.size>y.size;}
	int& operator [](int x){return a[x];}
	void NTT(int N,int flag){
		size=N;a.resize(N+1);
		for(int i=0;i<N;++i)
			if(i<rev[i]) swap(a[i],a[rev[i]]);
		for(int i=1;i<N;i<<=1){
			int w=poW(flag==1?G:Gi,(mod-1)/(i<<1));
			for(int j=0;j<N;j+=(i<<1)){
				int wk=1;
				for(int k=0;k<i;++k,wk=wk*w%mod){
					int nx=a[j+k],ny=wk*a[j+k+i]%mod;
					a[j+k]=(nx+ny)%mod;
					a[j+k+i]=(nx-ny+mod)%mod;
				}
			}
		}
	}
	friend Poly operator *(Poly x,Poly y){
		if(x.size<=20&&y.size<=20){
			Poly z(x.size+y.size);
			for(int i=0;i<=x.size;++i)
				for(int j=0;j<=y.size;++j) (z.a[i+j]+=x.a[i]*y.a[j])%=mod;
			return z;
		}
		int N=1,L=0,nsize=x.size+y.size;
		while(N<=x.size+y.size) N<<=1,++L;
		for(int i=1;i<N;++i) rev[i]=(rev[i>>1]>>1)|((i&1)<<(L-1));
		x.NTT(N,1);
		y.NTT(N,1);
		Poly z(N);
		for(int i=0;i<=N;++i) z.a[i]=x.a[i]*y.a[i]%mod;
		z.NTT(N,-1);
		int inv=poW(N,mod-2);
		for(int i=0;i<=N;++i) z.a[i]=z.a[i]*inv%mod;
		z.size=nsize;
		while(z.size>0&&!z.a[z.size]) --z.size;
		z.a.resize(z.size+1);
		vector<int>(z.a).swap(z.a);
		return z;
	}
	friend Poly operator %(Poly x,int y){
		if(x.a.size()>y){
			x.a.resize(y);
			x.a.shrink_to_fit();
		}
		return x;
	}
};
int ID,n;
int m1,m2;
int g[2005][1005];
int fa[2005];
bool vis[2005];
int Cnt[2005];
int ans=1;
vector<int> vc;
vector<int> isz[2005];
map<int,int> mp;
bool FLAG;
inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
inline void merge(int x,int y){
	x=find(x);y=find(y);
	if(x!=y) fa[x]=y;
}
void dfs1(int v){
	vis[v]=1;
	vc.push_back(v);
	for(int i=1;i<=m1;++i)
		if(!vis[g[v][i]]) dfs1(g[v][i]);
}
void dfs2(int x,int y){
	mp[x]=y;
	for(int i=1;i<=m1;++i){
		int nx=g[x][i],ny=g[y][i];
		if(mp.count(nx)){
			if(mp[nx]!=ny) FLAG=false;
		}else dfs2(nx,ny);
	}
}
bool check(int x,int y){
	mp.clear();
	FLAG=true;
	dfs2(x,y);
	return FLAG;
}
int a[2005][2005],b[2005][2005],tmp[2005][2005];
int calc(int x,int y){
//	cerr<<"calc "<<x<<" "<<y<<endl;
	vector<int> vc;
	for(int i=1;i<=y;++i)
		if(y%i==0) vc.push_back(i);
	for(int i=0;i<vc.size();++i)
		for(int j=0;j<vc.size();++j)
			if(vc[j]%vc[i]==0){
				a[i][j]=poW(vc[i]*x,y/vc[i]-y/vc[j]+1)*(fact[y/vc[i]]*poW(invn[vc[j]/vc[i]],y/vc[j])%mod*inv[y/vc[j]]%mod)%mod;
//				cout<<"a["<<vc[i]<<"]["<<vc[j]<<"]="<<a[i][j]<<endl;
			}else a[i][j]=0;
	for(int i=0;i<vc.size();++i)
		for(int j=0;j<vc.size();++j) b[i][j]=0;
	for(int i=0;i<vc.size();++i) b[i][i]=1;
	int m=m2;
	while(m){
		if(m&1ll){
			for(int i=0;i<vc.size();++i)
				for(int j=0;j<vc.size();++j)
					for(int k=0;k<vc.size();++k)
						(tmp[j][k]+=b[j][i]*a[i][k]%mod)%=mod;
			for(int i=0;i<vc.size();++i)
				for(int j=0;j<vc.size();++j){
					b[i][j]=tmp[i][j];
					tmp[i][j]=0;
				}
		}
		for(int i=0;i<vc.size();++i)
			for(int j=0;j<vc.size();++j)
				for(int k=0;k<vc.size();++k)
					(tmp[j][k]+=a[j][i]*a[i][k]%mod)%=mod;
		for(int i=0;i<vc.size();++i)
			for(int j=0;j<vc.size();++j){
				a[i][j]=tmp[i][j];
				tmp[i][j]=0;
			}
		m>>=1ll;
	}
//	cerr<<"calc "<<x<<" "<<y<<" = "<<b[0][vc.size()-1]<<endl;
	return b[0][vc.size()-1];
}
int f[2005];
Poly dp[2005],F;
int solve(int x,int y){
	f[0]=1;
	for(int i=1;i<=y;++i) f[i]=calc(x,i);
//	for(int i=1;i<=y;++i) cerr<<f[i]<<" ";
//	cerr<<endl;
	F=Poly(y);
	F[0]=0;
	for(int i=1;i<=y;++i) F[i]=f[i]*inv[i-1]%mod;
	dp[0]=Poly(y);
	dp[0][0]=1;
	for(int i=0;i<y;++i){
		for(int j=0;j<y;++j) dp[i][j]=dp[i][j]*fact[y-j-1]%mod;
		dp[i+1]=dp[i]*F%(y+1);
		for(int j=1;j<=y;++j) dp[i+1][j]=dp[i+1][j]*inv[y-j]%mod;
	}
//	for(int i=1;i<=y;++i){
//		for(int j=1;j<=y;++j) cout<<"dp["<<i<<"]["<<j<<"]="<<dp[i][j]<<endl;
//	}
	int res=0;
	for(int i=1;i<=y;++i) (res+=dp[i][y])%=mod;
	return res;
}
signed main(){
//	freopen("wormhole.in","r",stdin);
//	freopen("wormhole.out","w",stdout);
	getinv(1000000);
	for(int i=1;i<=1000000;++i) invn[i]=inv[i]*fact[i-1]%mod;
	ID=read();n=read();m1=read();m2=read();
	for(int i=1,x,y,z;i<=n*m1;++i){
		x=read();y=read();z=read();
		g[x][z]=y;
	}
	if(m1==0&&m2==1){
		write(fact[n]);
		putchar('\n');
		return 0;
	}
	for(int i=1;i<=n;++i)
		if(!vis[i]){
			vc.clear();
			dfs1(i);
			isz[vc.size()].push_back(i);
		}
	for(int i=1;i<=n;++i){
		if(isz[i].empty()) continue;
		iota(fa,fa+isz[i].size(),0);
		for(int j=1;j<isz[i].size();++j){
			int from=-1;
			for(int k=0;k<j;++k){
				if(fa[k]==k){
					if(check(isz[i][k],isz[i][j])){
						from=k;
						break;
					}
				}
			}
			if(from!=-1) merge(j,from);
		}
		memset(Cnt,0,sizeof(Cnt));
		for(int j=0;j<isz[i].size();++j) ++Cnt[find(j)];
		for(int j=0;j<isz[i].size();++j)
			if(fa[j]==j) ans=ans*solve(i,Cnt[j])%mod;
	}
	write(ans);
	putchar('\n');
	return 0;
}
```

---

## 作者：SnowFlavour (赞：1)

# 说明

本题解不提供完整思路，是对于其他题解的补充说明（主要是证明了一些性质）。

建议理解思路后再翻阅本题解。

# 一、合并与同构的关系

> 为方便表述，两个连通块的同构称为“异同构”，同一个连通块关于自己同构称为“自同构”。

## 1. “可以合并”合并意味着“异同构”

首先，对于题目中的条件：

> 1. 存在一个非负整数 $d$ 使得每个城市恰好是 $d$ 条虫洞的起点，也恰好是 $d$ 条虫洞的终点。
> 2. 对于每个城市而言，在以它为起点的虫洞的编号中，$1$ 到 $d$ **恰好**各出现一次。
> 3. 对于每个城市而言，在以它为终点的虫洞的编号中，$1$ 到 $d$ **恰好**各出现一次。
> 4. 任意选取一个城市 $u$ 和正整数 $1\le j_1, j_2 \le d$。设从 $u$ 出发，先经过一次编号为 $j_1$ 的虫洞，再经过一次编号为 $j_2$ 的虫洞，到达城市 $v_1$。设从 $u$ 出发，先经过一次编号为 $j_2$ 的虫洞，再经过一次编号为 $j_1$ 的虫洞，到达城市 $v_2$。则条件 $v_1=v_2$ 必定满足。

考虑它究竟说了什么？

- 定义 $V(u,w)$ 表示从 $u$ 出发走种类为 $w$ 的边到达的点。由于性质 2，该点唯一。
- 定义 $P(u,w)$ 表示从 $u$ 出发走种类为 $w$ 的**反向**边到达的点。由于性质 3，该点唯一。

考虑证明同构。

假设当前已经连接了 $k$ 种边，现在连接 $k + 1$ 种边，那么先连接一条 $k + 1$ 种边 $u \to v$，可以得到 $\forall w \in [1,k] 且 w \in \mathbb{N},V(u,w) \to V(v, w)$。

而这个结论具有传递性。所以所有能从 $u$ 到达的节点都满足这个性质，因而这些点构成的子图同构。

同理，能够到达 $u$ 的点也是同构的。

因此两个子图是同构的。

> 注意：我们认为 $u$ 可以从 $u$ 到达，也可以到达 $u$，因此这两个导出子图一定是有交的。

## 2. 连通块一定自同构

这个性质可以通过归纳证明。

假设一个连通块连接了 $k$ 种边，

- 当 $k = 0$ 时（其实就是个点），显然成立。
- 若 $k - 1$ 时成立，那么对于任意一个连通块上的点 $u$：
  - 对于任意一个合并以后处于同一个连通块的节点 $v$，它们所在的小连通块一定是同构的。
  - $u$ 和 $v$ 一定都有一条 $k$ 边连向下一个连通块。由于小连通块是自同构的，所以连接的位置不重要。
  - 两点连向的下一个连通块也一定满足上述性质，因此整个大连通块都满足。
  - 因此这个大连通块自同构。

# 二、组合计数的公式

> 这部分的字母会参考 [@Wuyanru的题解](https://www.luogu.com.cn/article/goqa0h29)，建议随时翻阅。

## 1. 计算连通块的排列

大部分题解对这个公式的解释是归纳法、瞪眼法和 oeis 法。

定义将 $i$ 个连通块等分成 $j$ 组（满足 $j|i$），各组内部进行圆排列的方案数是 $f_{i, j}$。

首先，$f_{i,j}$ 显然可以用 dp 来求。但是我们可以考虑推式子：

1. 我们要把连通块分成 $j$ 组。这个要求的一种可行的刻画是直接求出这些连通块的全排列 $i!$，然后前 $j$ 个是一组，第 $j + 1$ 到 $2j$ 个是一组，以此类推。
2. 接下来考虑圆排列。我们知道对于每一组，圆排列的方案数要除以连通块的数量 $\frac{i}{j}$。因此，$j$ 个连通块就需要将这个数算 $j$ 次。
3. 考虑这样是否还有重复？显然，$1,2,3,4,5,6$ 和 $3,4,1,2,5,6$ 是一样的，但是被重复计算在内。也就是说，在分组的时候我们并没有考虑组间的顺序，因此总方案数就要再除以 $j!$。

因此，得到公式：

$$
f_{i,j}=\frac{i!}{j!(\frac{i}{j})^j}
$$

## 2. DP 方程的压维

考虑到压维以后的方程实际上相当于连通块是点的合并，我们只需要计算从一个点到一个连通块的变化即可。

首先明确原方程的 $s^{i - x + 1}$ 仅解决了连边的问题，所有连通块的位置是通过 $f_{i,j}$ 计算的，在连边时相当于位置锁定。

那么我们就看看点和连通块的区别。

- 大的连接方向是清晰的，并且在点和连通块上都一样。
- 对于一个连通块向下一个连通块连边的连接上，一个连通块会有 $s$ 种连接方式，因此如果每个连通块都随意连边，会比点连边多出 $s^i$ 的系数。
- 然而我们要确保同构。这事实上意味着，有些连通块可以自由选择如何连向下一个连通块，而有些并没有自由，只能“被迫”处在一个位置。

也就是说，我们只要找到在多次合并中，“自由”的连通块数量即可。（注意：无论合并以后的连通块如何，我们的连通块合并始终是由点的合并“膨胀”而来的，所以每一次一个连通块即使是自由的，也仍然只有 $s$ 种连边的方式。）

由于每一次合并的时候都必然存在自由的连通块，我们不妨钦定一个连通块始终是自由的。

**以下的内容是在多次合并过程中的某一次，也就是说原先的连通块现在已经被合并成了大连通块**。

- 当只有一个大连通块的时候，显然只有这一个连通块是自由的。
- 否则，我们让这个连通块先随便连。这样，这个连通块所在的大连通块的连接方式就被确定了。接下来，由于其它连通块连接到最后时，封圈的那一个连通块不是自由的，这一次我们就让这个连通块选择连边方式。
  - 而这个连通块又是由几个更小的连通块合并来的，所以我们再找小连通块中封圈的连通块，同理这个封圈的块又可以找到更小的连通块，以此类推，就会找到最初封圈的连通块。

这样我们发现，这个始终自由的连通块再 $j$ 次合并中都是可以自由连接的，方案为 $s^j$，而剩下的连通块只要有一次不是作为封圈的连通块，它就再也不会自由连接了，而所有的连通块都一定有一次是自由的（毕竟最后合并成了一个连通块），所以方案是 $s^{i-1}$。

因此，我们得到了如下公式：

$$
dp_{i,j,s}=dp_{i,j,1} \times s^{i+j-1}
$$

为什么我们得到的结论如此简洁？一是因为我们合并时一个连通块要么完全自由，要么就是没有任何自由，所以自由的方案数一定是 $s$ 的次方；二是因为合并的过程中只关心从“点”到“连通块”的变化，并没有关注连接位置的不同（那部分内容在 $f_{i,j}$ 里面），并且最终结果是“一个连通块”。

# 三、一些实现上的小问题
## 1. 哈希

**免责声明：这部分内容能通过所有数据，不保证正确性，如果能证明正确性或者能给出正确的概率，欢迎在评论留言**。

具体地，我们从任何一个点开始，按照边权的顺序 BFS，依次把经过的边存储起来。由于自同构性，两个同构的连通块显然会得到一个相同的序列。

## 2. 倍增的实现

> 这部分的字母依然会参考[@Wuyanru的题解](https://www.luogu.com.cn/article/goqa0h29)。

根据推导，我们有如下式子：

$$
fp_{i,x+y}=\sum_{j|i}\frac{fp_{j,x}fp_{\frac{i}{j},y}}{j^y}
$$

考虑当 $x=y=2^a$ 时，原式可化为：

$$
fp_{i,2^{a+1}}=\sum_{j|i}\frac{fp_{j,2^a}fp_{\frac{i}{j},2^a}}{j^{2^a}}
$$

这玩意可以 $O(n\log k \ln n)$ 求。（当然，快速幂复杂度也得算上，所以最后事实上会多一个 $\log$。）

最终，我们要求的是 $fp_{i,k}$。这可以通过二进制分解来实现。简单来说就是套公式，由于描述比较复杂，我就直接摆代码了：
```cpp
for (int j = 50; j >= 0; j--) {
    if (1ll << j <= nw) {
        swap(now, old);
        for (int i = 1; i <= n; i++) res[i][now] = 0;
        nw -= (1ll << j);
        for (int i = 1; i <= n; i++) {
            for (auto k : fac[i]) {
                res[i][now] =
                    (res[i][now] + res[k][old] * p[i / k][j] % MD *fast(fast(k, 1ll << j), MD - 2) % MD) %MD;
            }
        }
    }
}
```

（我的码风可能有点抽象……）

# 四、结语

虽然没有完整思路，但是这篇题解的篇幅也不算小了。

事实上我认为最重要的是推式子的能力。第二部分的两个公式都可以打表+归纳得出结论，但是这样的问题是不稳定，毕竟你不能指望当式子很复杂的时候还能够瞪出结果。然而构造和组合公式的力量是强大的，它可以确保你无论结论多复杂，它都应当没有问题。

当然，考场上你只要能够得到正确结论就能得分，所以场上什么方式都随便用，但是平时应该多锻炼的是后者，这是更强的道路。

同时不应该忽视一些实现的细节（~~我才不会告诉你我因为上面的代码滚的时候没清空调了一个小时~~），毕竟信竞的题目就是这样，一个细节可以把分数直接归零。

如果能勘误，欢迎随时在评论留言！

---

## 作者：nullqtr_pwp (赞：1)

定义连通块为：有向边视为无向边后形成的连通块。

感受一下，只有**同构的连通块**之间可以连边。~~这就是我一节数学课的进展。~~ 具体严格证明别的题解都有。

所以初始的图的唯一用处就是让你划分等价类，考虑对每个连通块 BFS，在此过程中进行字符串哈希即可。```unsigned long long``` 自然溢出即可维护，不知道为什么我写了 $4$ 个哈希，注意保证 $\text{base}$ 是奇数。

两两同构的连通块是我们要关注的对象，我们关心它每个连通块的大小以及同构连通块的数量。每种连通块显然相互独立，最终乘法原理合并即可。

考虑当前有 $N$ 个连通块，每个的大小均为 $S$。

我们很关心合并成一个连通块的情况，因此设 $f_{i,j,S}$ 表示 $j$ 种新颜色的边加入后，原来 $i$ 个同构的大小为 $S$ 的连通块，所有的连边方案数使得它们成为一个新的大连通块。

- **初始情况**： 显然为 $f_{i,0,S}=[i=0]$。我们最终的目标是求出所有 $f_{i,k,S}$。

- **统计答案**： 有了这些 $\text{dp}$ 值后，统计答案是容易的：具体就是 $dp_i$ 表示前 $i$ 个连通块划分完的答案，枚举最后 $j$ 个和 $i$ 一起合并成一个大连通块。有转移：

- $$dp_{i}=\sum_{j=1}^{i}dp_{i-j}\times f_{j,k,S}\times \binom{i-1}{j-1}$$


考虑怎么求 $\lbrace f_{i,j,s}\rbrace$。

首先有枚举第 $j$ 种颜色实际合并了哪些，考虑由 $x|S$ 表示前 $j-1$ 种划分成了 $x$ 个连通块。由于无论何时，连通块都必须同构，所以每种都是等价的，并且必须有 $x|S$。

考虑第 $j$ 种颜色怎么连边：

- 对每个点找到后继。每个连通块内部的后继形成一个环，所以考虑用圆排列刻画。
- 首先将 $i$ 个点划分成 $x$ 个圆排列，因为我们只考虑相对次序，所以要在这一步进行具体的划分。令 $g_{i,x}$ 表示 $i$ 个点划分成 $x$ 个大小相同的圆排列的方案数，要求 $x|i$。显然有：

- $$g_{n,m}=\dfrac{n!}{m!(\frac{n}{m})^{m}}$$

- 解释：在不考虑圆排列时，显然为 $\dfrac{n!}{m!}$，有了圆排列，每个子序列的权值不是 $len!$ 而是 $(len-1)!$。

- 考虑每个大连通块内部怎么连边。让第一个大连通块随便选形态，后面的所有联通块，最后一个点的指向就是确定的。

- 因此有 $S^{\frac{i}{x}}S^{(\frac{i}{x}-1)(x-1)}=S^{i-x+1}$ 种选法。

整理一下，得到转移为：

$$f_{i,j,S}=\sum_{d|i} f_{d,j-1,\frac{i}{d}S}g_{i,d}S^{i-d+1}$$

转移和 $S$ 的关系很小。

**结论：** $f_{i,j,S}=f_{i,j,1}\times S^{i+j-1}$。

- 可以数学归纳证明。

因此可以直接用 $f_{i,j,1}$ 表示 $f_{i,j,*}$。重新定义 $P_{i,j}$ 为 $i$ 个点 $j$ 个颜色合并成大连通块的方案数。


$$P_{i,j}=\sum_{k|i} P_{k,j-1}g_{i,k}(\frac{i}{k})^{j+k-2}$$

将 $g_{i,k}=\dfrac{i!}{k!(\frac{i}{k})^k}$ 带入并化简，得到：

$$P_{i,j}=\sum_{k|i}P_{k,j-1}\dfrac{(i-1)!(\frac{i}{k})^{j-1}}{(k-1)!}$$

此时考虑换元，令 $T_{i,j}=\dfrac{P_{i,j}}{(i-1)!i^{j-1}}$，那么得到：

$$T_{i,j}=\sum_{k|i}\dfrac{T_{k,j-1}}{k}$$

我们的目标是求出 $T_{1,2,\cdots,N,k}$。


考虑将这个转移视作另一个动态规划的转移式，赋予其组合意义：

- 考虑所有长度为 $j$ 的序列 $a$，定义 $a_{j+1}=i,a_1=1$，合法序列要求任意 $k$ 有 $a_{k}|a_{k+1}$，再定义序列的权值为 $\dfrac{1}{\prod_{i=1}^j a_i}$，求所有合法序列的权值和。$T_{i,j}$ 的意义即为 $a_j=i$ 的所有合法序列权值和。

考虑到最后要求的第二维 $k$ 很大，但是 $T_{i}$ 视为向量后，可以合并，具体有：

$$T_{i,x+y}=\sum_{j|i}\dfrac{1}{T_{j,x}T_{\frac{i}{j},y}j^y}$$

可以预处理所有 $T_{i,2^t}$，直接合并得出所有 $T_{i,k}$。单次合并两个向量的时间复杂度为 $O(n\log n)$，需要合并 $O(\log k)$ 次。

得出所有 $T_{i,k}$ 后，再还原得到 $P_{i,k}$，再求出 $f_{i,k,*}$ 即可。这两步是 $O(1)$ 计算的。

总时间复杂度 $O(nm+n^2+n\log k\log n)$。

[提交记录。](https://uoj.ac/submission/692806)

---

## 作者：SegTree (赞：0)

通过 $m=1$ 的情况简单手玩不难得出，在不同构的连通块之间相连一定会导出矛盾，而每轮连边相当于把若干个连通块串在一起。

考虑基于这个过程设计 dp 状态：记 $dp_{i,j,k}$ 表示将 $i$ 个大小为 $k$ 的同构连通块经过 $j$ 轮连边后被合并到一个连通块的方案数。

那么每轮转移，相当于把若干个连通块合并，考虑枚举分成了 $x$ 个连通块，下面需要计算将 $i$ 个连通块串成 $x$ 个的方案数：

首先需要乘上将 $i$ 个元素划分成 $x$ 个大小为 $\dfrac{i}{x}$ 的圆排列，方案数为 $\dfrac{\binom i {\frac{i}{x}\cdots \frac{i}{x}}(\frac{i}{x}-1)!^x}{x!}=\dfrac{i!}{x!(\dfrac{i}{x})^x}$。

还需要乘上内部连接的方案数。对于第一组被合并的连通块显然可以任意选择，方案为 $k^{\frac{i}{x}}$，而对于第 $2$ 到 $x$ 组每组的最后一次合并需要保证同构性，因此为 $k^{(\frac{i}{x}-1)(x-1)}$，两者之积为 $k^{i-x+1}$。

综上有转移：

$dp_{i,j,k}=\sum_{x|i}dp_{x,j-1,\frac{ik}{x}}\dfrac{i!}{x!(\dfrac{i}{x})^x}k^{i-x+1}$。

注意到 $k$ 这一维产生的贡献其实是 $i+j-1$ 次幂，不难得到，故有 $dp_{i,j,k}=dp_{i,j,1}k^{i+j-1}$。因此化简 dp 状态，记 $dp_{i,j}$ 为原来的 $dp_{i,j,1}$，则可以得到转移 $dp_{i,j}=\sum_{x|i}dp_{x,j-1}(\dfrac{i}{x})^{x+j-2}\dfrac{i!}{x!(\dfrac{i}{x})^x}$。

因为 $j$ 是 $10^{15}$ 级别的，因此我们尽可能将转移式化到与 $j$ 无关，这样就可以用矩阵快速幂计算。

我们记 $f_{i,j}=\dfrac{dp_{i,j}}{i!i^{j-2}}$，此时有转移 $f_{i,j}=\sum_{x|i}\dfrac{f_{x,j-1}}{x}$，并且求出 $f_{k,*}$ 之后即可还原 $dp_{k,*}$ 的结果。

问题转化为对 $f$ 的求解，使用矩阵快速幂只维护有值的位置，则时间复杂度为 $O(n\log^2n\log k)$。

求出 $dp$ 数组后考虑统计答案。对于同构的若干个大小为 $sz$ 的连通块考虑用 dp 求解方案数，记 $ans_i$ 表示前 $i$ 个的方案数，有：

$ans_i=\sum_{j<i}ans_jdp_{i-j,k,sz}\binom {i-1} {i-j-1}$。

那么问题已经转化为如何判定连通块是否同构。考虑哈希，显然任意点在连通块中是对称的，于是任选一点按照边的编号顺序依次遍历全图并求出 $dfn$ 序，则把 $idfn_{u}dfn_{to_{u,i}}$ 做字符串哈希即可。

时间复杂度为 $O(nm+n^2+n\log^2n\log k)$，可以通过本题。

---


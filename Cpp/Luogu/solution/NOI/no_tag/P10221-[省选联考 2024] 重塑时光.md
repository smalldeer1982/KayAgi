# [省选联考 2024] 重塑时光

## 题目描述

小 T 正在研究某段时间中所发生的事件。经观测，有 $n$ 个编号为 $1\sim n$ 的事件在这段时间内按顺序依次发生，第 $i$ 个发生的是事件 $p_i$。这个描述事件发生顺序的排列 $p$ 可称为这段时间的**时间线**。

突然，邪恶生物小 S 攻击了这条时间线，将这 $n$ 个事件的发生顺序 $p$ 变为了在所有长为 $n$ 的排列中等概率随机选取的一个排列。不仅如此，小 S 还用剪刀把时间线剪断，通过进行 $k$ 次操作，将排列 $p$ 分割成了 $(k + 1)$ 段。

具体而言，在小 S 进行第 $i$ 次操作时，排列 $p$ 和之前所有插入的剪断点构成了一个长度为 $(n + i - 1)$ 的序列。该序列包括所有相邻元素之间和序列开头、末尾处共有 $(n + i)$ 个插入位置。小 S 将从这些插入位置中等概率随机选取一个位置，插入一个新的剪断点。最后，小 S 从最终被插入的 $k$ 个剪断点处把序列剪开，将排列 $p$ 分割成了 $(k + 1)$ 段序列。这 $(k + 1)$ 段序列中可能有空序列。

为了拯救这条即将毁灭的时间线，小 T 决定把这 $(k + 1)$ 段序列按某种顺序重新拼接成一个长度为 $n$ 的排列，形成一条新的时间线。不过，由于事件之间存在一定的逻辑关系，事件的发生时间之间也存在一些先后顺序要求。经研究，共存在 $m$ 条先后顺序要求 $(u, v)$，要求事件 $u$ 的发生时间必须在事件 $v$ 之前。也就是说，$u$ 在时间线中的出现位置必须在 $v$ 之前。

请你设计程序，计算有多大的概率，存在至少一种重新排列这 $(k + 1)$ 段序列，并将其重新拼接为一条新的时间线的方案，能够使所有的 $m$ 条事件发生时间之间的先后顺序要求都得到满足。

为了避免精度误差，请你输出答案对 $10^9 +7$ 取模的结果。形式化地，可以证明答案可被表示为一最简分数 $\frac{p}{q}$，请你输出一个 $x$ 满足 $0 \le x < 10^9+7$ 且 $qx \equiv p \pmod {10^9+7}$。可以证明在题目条件下这样的 $x$ 总是存在。

## 说明/提示

**【样例 1 解释】**

![](https://cdn.luogu.com.cn/upload/image_hosting/f8vh2qqo.png)

假如事件 $1$ 的发生时间早于事件 $2$，那么无论怎样拼接都是可行方案，一定可以满足要求。否则，只有剪断时间线的位置位于事件 $1$ 和事件 $2$ 的发生时间之间，才能满足要求。答案为 $\frac{1}{2}+\frac{1}{2}\times \frac{1}{3}=\frac{2}{3}$。

**【样例 2 解释】**

没有任何事件发生时间之间的先后顺序要求，因此无论怎样拼接都是可行的方案，答案为 $1$。

**【样例 4】**

见附件中的 `timeline4.in/ans`。

**【样例 5】**

见附件中的 `timeline5.in/ans`。

该组样例满足数据范围中的特殊性质 B。

**【样例 6】**

见附件中的 `timeline6.in/ans`。

该组样例满足数据范围中的特殊性质 A。

**【样例 7】**

见附件中的 `timeline7.in/ans`。

**【子任务】**

对于所有测试数据，

- $1 \le n \le 15$，
- $0 \le m \le \frac{n(n-1)}{2}$，$0 \le k \le n$，
- $1 \le u < v \le n$，保证不存在两对 $(u,v)$ 完全相同。

| 测试点 | $n$ | $m$ | $k$ | 特殊性质 |
| :--: | :--: | :--: | :--: | :--: |
| $1$ | $\le 3$ | $=n-1$ | $=0$ | B |
| $2$ | $\le 5$ | $\le \frac{n(n-1)}{2}$ | $\le n$| 无 |
| $3,4$ | $\le 14$ | $=n-1$| $\le n$ | B |
| $5$ | $\le 14$ | $=n-1$ | $=0$ | A |
| $6$ | $\le 14$ | $=n-1$ | $\le n$ | A |
| $7$ | $\le 14$ | $=0$ | $\le n$ | 无 |
| $8$ | $\le 14$ | $=\frac{n(n-1)}{2}$ | $\le n$ | 无 |
| $9,10$ | $\le 9$ | $\le 15$ | $\le n$ | 无 |
| $11$ | $\le 13$ | $\le \frac{n(n-1)}{2}$ | $=0$ | 无 |
| $12$ | $\le 13$ | $\le \frac{n(n-1)}{2}$ | $\le n$ | 无 |
| $13 \sim 17$ | $\le 14$ | $\le \frac{n(n-1)}{2}$ | $\le n$ | 无 |
| $18\sim 20$ | $\le 15$ | $\le \frac{n(n-1)}{2}$ | $\le n$ | 无 |

特殊性质 A：对于每个事件 $x$，至多存在一条先后顺序 $(u, v)$ 使得 $v = x$。

特殊性质 B：对于所有先后顺序 $(u, v)$，均满足 $u = 1$。

## 样例 #1

### 输入

```
2 1 1
1 2```

### 输出

```
666666672```

## 样例 #2

### 输入

```
3 0 2
```

### 输出

```
1```

## 样例 #3

### 输入

```
4 4 4
1 2
1 3
1 4
2 4```

### 输出

```
937500007```

# 题解

## 作者：vegetable_king (赞：35)

[菜就多练，输不起就别玩。](https://www.luogu.com.cn/article/lzv3arzo)忘记卷积可以拉插就是菜，认为 $O(3^nn^2)$ 没多少分就是蠢，没什么借口可找。

如果你做过 ABC306Ex 和 CF1874E，而且你又不是像我这样的蠢货，你就能场切这个题。

---

[可能更佳的阅读体验](https://yjh965.github.io/post/sheng-xuan-lian-kao-2024-chong-su-shi-guang-ti-jie/)

考虑重排之后切 $k$ 刀，本质上就相当于将 $\{1, \dots, n\}$ 划分成 $(k + 1)$ 个可以为空的点集，而能重排成功等价于以下条件：

- 对于每个点序列，其为其导出子 DAG 的一个拓扑序；
- 对于将每个点序列缩成一个大点得出的新图，其也是 DAG。

由于题目中每一段内是有序的，所以对于这样的划分方案，还要乘上每个点集内部的拓扑序方案数。

所以我们考虑类似 ABC306Ex 容斥拓扑序计数的方法，每次加入若干个对应大点入度为 $0$ 的点集，设加入了 $i$ 个大点，则容斥系数为 $(-1)^{i + 1}$。

考虑设 $f_{S, i}$ 表示 $S$ 集合内的点被划分为 $i$ 个**非空**大点的合法方案数，转移可以枚举加入点集的并 $T$，并枚举 $j$，将 $T$ 划分为 $j$ 个大点。再设辅助数组 $g_{S, i}$ 表示 $S$ 集合内的点被划分为 $i$ 个**独立的**大点，每个大点内部拓扑序方案数之积，$h_S$ 表示 $S$ 集合里的点的拓扑序方案数，于是得转移方程：
$$
f_{S, i} = \sum_{T \subseteq S} \mathrm{chk}(T, S / T) \sum_{j = 1}^i f_{S / T, i - j} g_{T, j} (-1)^{j + 1}\\
g_{S, i} = \sum_{T \subseteq S} \mathrm{chk}(T, S / T) \mathrm{chk}(S/T, T) g_{S / T, i - 1} h_T\\
h_S = \sum_{u \in S} \mathrm{chk}(S / u, u) h_{S / u}
$$
其中 $\mathrm{chk}(A, B)$ 表示是否不存在 $B \to A$ 的边，可以 $O(2^n)$ 预处理出每个点集 $S$ 的入边的并集 $in_S$，于是 $O(1)$ 判断 $in_A \cap B = 0$ 即可。

时间复杂度为 $O(3^nn^2)$，但是 $g, h$ 可以 $O(n3^n)$ 预处理。推出具体的转移方程就能看出这个东西明显跑不满，但是我并没有。

发现转移其实是一个卷积形式，所以我们考虑把 dp 写成多项式形式，即 $[x^i]F_S = f_{S, i}$。则可以得出转移方程：
$$
F_S = \sum_{T \subseteq S} \mathrm{chk}(T, S / T) F_{S / T} G_T
$$
其中 $[x^i]G_S = g_{S, i} (-1)^{i + 1}$。根据 $f$ 的定义，$F, G$ 显然都是 $n$ 次多项式，使用类似 CF1874E 中的技巧，给 $x$ 代入 $1 \sim n + 1$ 共 $n + 1$ 个点值，分别求出 $F_{2^n - 1}(x)$ 此时的值，即可 $O(n^2)$ 拉插求出其各项系数，也就是 $f_{2^n - 1, 1 \sim n}$ 的值。而代入一个 $x$ 做上述 dp 是 $O(3^n + n2^n)$ 的，后者是预处理所有 $G$ 的时间复杂度。

算出方案之后转换回概率是简单的，考虑将这 $i$ 段非空段重排，然后与无序的 $(k + 1 - i)$ 段空段归并，再以任意的顺序切割已经钦定好的 $k$ 个位置，得到式子：
$$
i!k!\binom{k + 1}{i} = \frac{k!(k + 1)!}{(k + 1 - i)!}
$$
最后除掉总方案数 $(n + k)!$ 即可。于是我们在 $O(n3^n)$ 的时间复杂度内解决了这题，代码在[这里](https://www.luogu.com.cn/paste/z805c5aq)。

---

## 作者：20_200 (赞：17)

# 省选联考 2024 D2T2

### 前言

Day1 发挥不完全，Day2 完全不发挥。

Day2 场上写 T1 4h 25min，并且最终也只写了个假做法，最后两分钟在这题输出了 `1` ，并获得了总分 5 分的好成绩

~~如果省选也能重塑时光，重塑 Day2 的四个半小时，重塑一下开题顺序，......~~，但是过去的事情没有如果，时光也不能重塑，省选打炸了只能~~退役~~明年再战。

这是本蒟蒻的二篇洛谷题解，表达能力不佳，请见谅。

### 题解

首先发现总方案数有限，这个概率没啥意义。

因为切断点也是有序的，所以总方案数可以看成 $n+k$ 个数的排列，为 $(n+k)!$ ，我们只需求出合法方案数。

显然切完之后形成的若干段之间的顺序无意义（因为可以重排），段内数的顺序有意义（同一段要保持原来的排列顺序）。设把排列切成 $i$ 段，不管具体切法，段间无序的方案数为 $s_i$ ，考虑如何计算 $s_i$ 。

定义一些记号

+ 下文中小写字母表示元素（大小为 $1$ 的集合），大写字母表示集合。

+ 布尔函数 $c(S,T)$ 表示 $T$ 中的元素是否可以全部排在 $S$ 中元素之前（即是否**不存在** $S\to T$的边）

+ $S+T$ 表示 $S$ 和 $T$ 的并，$S-T$ 表示 $T$ 在 $S$ 中的补集。

首先每一段内的问题相当于求是一个给定集合中的元素有多少种合法的排列顺序，容易是用状压 dp 计算得到。

设 $f_{S}$ 表示集合 $S$ 内得元素有多少种合法排列顺序（拓扑序），则

$$f_{S}=\sum_{x\in S}c(S-x,x)\times f_{S-x}$$

那么点集内部的方案数已经搞定了，接下来需要算将全集划分成若干个互不相交的点集，使得将点集看作新图的点，两个集合之间的边为两个集合内所有点的边，构成的图存在一种拓扑排序方式，合法划分方案的所有点集内部的方案数的乘积之和。

因为题目给定的边是固定的，所以每一种划分方案**唯一对应**的一个图，存在拓扑序相当于图是 DAG，可以直接对 DAG 进行计数。

为了保证不算重，我们每次考虑删除当前点集的 DAG 中**当前所有**入度为零的点得到的新 DAG，则当前答案等于入度为零的点内部的方案数乘积再乘上新 DAG 的答案。

不过这样子需要保证除去所有入度为零的点集外，其他所有点集的入度均不为零，难以维护，所以考虑对入度为零的点集容斥，**钦定**当前的某些点集入度为零，其余的不管，直接按照新的 DAG 去算，乘上容斥系数即可。而钦定的入度为零的点集的方案数也可以预处理。

考虑设计 dp 状态。

设 $g_{i,S}$ 表示将 $S$ 划分为 $i$ 个不交的点集，且任意两个点集之间没有边的方案数，则

$$g_{i,S}=\sum_{T\in S,T\neq\empty}c(T,S-T)\times c(S-T,T)\times[S_{\min}=T_{\min}]\times f_T\times g_{i-1,S-T}$$

转移式中的 $c(T,S-T)\times c(S-T,T)$ 表示两个集合之间没有边，$[S_{\min}=T_{\min}]$ 是为了保证每次选出来的集合包含编号最小的节点，这样每种划分方案只会被算一次。

设 $dp_{i,S}$ 表示将 $S$ 划分成 $i$ 个点集，划分出的所有合法 DAG 的方案数，则

$$dp_{i,S}=\sum_{T\in S,T\neq\empty}\sum_{1\le j\le i}(-1)^{j-1}\times c(S-T,T)\times g_{j,T}\times dp_{i-j,S-T}$$

转移式中 $c(S-T,T)$ 的含义同 $f$ 的转移，$(-1)^{j-1}$ 为容斥系数，~~别忘记乘了然后调一年~~。

注意三个 dp 的边界条件为

$$f_0=g_{0,0}=dp_{0,0}=1$$

现在还剩最后一步，统计答案。

显然根据 dp 的状态定义，$s_i=dp_{i,\{1\sim n\}}$ ，还需要计算切段的方式。

切成的段之间的排列和切断的点之间的排列的方案数容易通过组合和容斥算出，钦定哪些需要切的点没被切，剩下的不管，然后容斥即可。

可以计算出答案为

$$\sum_{1\le i\le n}s_i\times i!\times\sum_{0\le j\lt i}(-1)^j\times\frac{(i-j+k)!}{(i-j)!}\times\binom{i-1}{j}$$

~~然后就做完了~~，然后并没有做完，还需要亿点点的常数优化。

时间复杂度 $O(3^nn^2)$ 。

### 卡常

~~尽量避免对程序常数因子的考察。~~

本蒟蒻的代码常数巨大，常数优秀的大佬们可以直接略过。

上述做法的复杂度算出来是 $15^2\times3^{15}=3.2\times10^9$ ，还带取模，看上去非常会 TLE 。

一般的状压 dp 自带 $\frac{1}{10}$ 甚至更小的小常数，但是即使这样还是过不了。

可以发现 dp 状态中有很对不合法的，其答案都是零，于是可以用 vector 存合法的状态来加速转移。

先在云斗交了发现 TLE #7 ，一看，$m=0$ ？？不过仔细想想，$m=0$ 确实最慢，因为上述优化全都无效，于是就把它特判掉。

因为每一次算 $c(S,T)$ 都是 $O(n+m)$ ，转移过程中计算会非常慢，可以预处理出来。

到时候此已经能在自己的电脑上卡过了，但是洛谷机子上最慢的点仍是 1.70s 。

然后取模也巨慢无比，所以 $g$ 乘上容斥系数的值可以预处理，然后 dp 转移可以使用一个 unsigned long long 把一个循环的求和做完再取模，因为 $15\times(10^9+7)^2<2^{64}$ 。

最后就是划分出的子集个数不超过集合元素个数，所以枚举时只用枚举到 popcount 即可退出，加了这个优化之后，上面那个优化和 $m=0$ 的特判不加好像都能过。

至此终于勉强而极限地卡过了这题。

最慢的点 #18 跑了 1.47s，总时间 6.83s ，截至提交时荣获本题[最劣解](https://www.luogu.com.cn/record/149687684)。

### 代码

这么难看都是卡常卡的。

```c++
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define pb push_back
#define pii pair<ll,ll>
#define fi first
#define se second
using namespace std;
const ll N=1<<15,P=1e9+7;
int n,m,k;
vector<int>b[N],d[N],e[N],h[N];
ll ans,f[N],fc[N],g[16][N],dp[16][N];
ll ksm(ll x,ll y=P-2){return y?ksm(x*x%P,y>>1)*(y&1?x:1)%P:1;}
int c(int s,int t){
	for(int i=1;i<=n;i++)
		if(s>>i-1&1)
			for(int j:e[i])
				if(t>>j-1&1)return 0;
	return 1;
}
int p(int s){
	int t=0;
	while(s)t+=s&1,s>>=1;
	return t;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k,f[0]=fc[0]=g[0][0]=dp[0][0]=1;
	if(!m)return cout<<1,0;
	for(int i=1;i<N;i++)fc[i]=fc[i-1]*i%P;
	for(int i=1,x,y;i<=m;i++)cin>>x>>y,e[x].pb(y);
	for(int s=1;s<(1<<n);s++)
		for(int t=s;t;t=(t-1)&s)
			if(c(s^t,t)){
				d[s].pb(t);
				if((s&-s)==(t&-t)&&c(t,s^t))h[s].pb(t);
			}
	for(int s=1;s<(1<<n);s++)
		for(int i=1,t=1;i<=n;i++,t<<=1)
			if(s>>i-1&c(s^t,t))(f[s]+=f[s^t])%=P;
	for(int i=1;i<=n;i++)
		for(int s=1;s<(1<<n);s++){
			for(int t:h[s])
				(g[i][s]+=f[t]*g[i-1][s^t])%=P;
			if(g[i][s])b[s].pb(i);
		}
	for(int s=1;s<(1<<n);s++)
		for(int i=1;i<=p(s);i++){
			if(i&1^1)g[i][s]=(P-g[i][s])%P;
			for(int t:d[s])for(int j:b[t])
				if(j<=i)(dp[i][s]+=g[j][t]*dp[i-j][s^t])%=P;
		}
	for(int i=1;i<=n;i++)
		for(int j=0,x;j<i;j++)
			x=dp[i][(1<<n)-1]*fc[i]%P*fc[i-1]%P*fc[i-j+k]%P,
			(ans+=((j&1?-1:1)*x+P)*ksm(fc[j]*fc[i-j]%P*fc[i-j-1]%P))%=P;
	(ans*=ksm(fc[n+k]))%=P;
	cout<<ans;
	return 0;
}
```

---

## 作者：Acoipp (赞：13)

## 分析

不妨设一个没有被剪断的纸条上所有点合并起来为一个块。

首先我们先不用考虑概率，可以将题目转化为划分小于等于 $k$ 块，块内可以重排列，块间也可以重排列，问符合条件的数量。

那么假设划分成 $i$ 块的方案数量为 $f_i$，则最终切 $k$ 刀恰好是这 $i$ 块的方案数如下：

- 这 $i$ 块可以重排列 $i!$ 种。
- 然后有无序的 $k+1-i$ 块，这个归并一下 $C_{k+1}^{k+1-i}$。
- $k$ 刀可以随便任意顺序切，$k!$。

总和就是 $f_ii!k!C_{k+1}^{k+1-i}$，最后除以总的方案数 $(n+k)!$ 就是概率。

我们接着考虑求解 $f$，首先设块 $S$ 块内重排列满足条件的方案数为 $h_S$，这个可以直接 $O(2^nn)$ 做（设 $dis_{S,T}$ 表示是否有一条边从 $S$ 的点到 $T$ 的点）：

$$h_S = \sum_{T \subset S}h_T (dis_{T,S/T} \operatorname{xor} 1)$$

这个直接预处理 $O(2^n)$ 的。

然后我们考虑块间满足条件，实际上就是数块间拓扑序的数量，每次我们可以在原有块的基础上添加一些度数为 $0$ 的块集，这些块集之间互相没有边，设这个集合有 $cnt$ 个块，那么这样做的容斥系数是 $(-1)^{cnt}$，详情参见 AT_abc306_h。

设 $g_{S,i}$ 表示 $S$ 集合划分成互相没有边的 $i$ 个块的方案数量，转移也很简单，如下：

$$
g_{S,i} = \sum_{T \subset S} g_{S/T,i-1}h_T(dis_{T,S/T} \operatorname{xor} 1)(dis_{S/T,T} \operatorname{xor} 1)
$$

$g$ 也可以预处理，时间复杂度是 $O(3^n)$。

顺便我们把块内的数量也累加到 $g$ 上面了，因此我们就可以推导出 $f$ 的值了：

$$
f_{S,i} = \sum_{T \subset S} \sum_{j=0}^i f_{S/T,i-j}g_{T,j}(-1)^{j+1}
$$

这样直接做是 $O(3^nn^2)$ 的，考虑优化，把后面的 $\sum_{j=0}^i$ 拿出来发现就是一个多项式相乘，并且这个多项式的次数不会超过 $n$，于是我们直接带入点值（用生成函数更好理解）$1 \sim n+1$ 求出 $f_S$ 的值，最后用拉格朗日插值求出 $0 \sim n$ 的系数就可以了。

即将 $f_{S,i} \to F_S(x)$ 上面去，那么 $F_S = \sum_{T \subset S} F_{S/T}G_{T}$。

其中 $G_T(x)=\sum_{i=0}^n x^ig_{T,i}(-1)^{i+1}$，每次把 $x$ 带入求解 $G_T$ 具体的值就可以直接做了。

当然你也可以看作生成函数，这样更加方便：

$$
f_{S,i}x^i = \sum_{T \subset S} \sum_{j=0}^i f_{S/T,i-j}x^{i-j}g_{T,j}x^j(-1)^{j+1}
$$

总体时间复杂度 $O(3^nn+2^nn^2)$。



## 代码

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
#define ll long long
#define N 19
#define mod 1000000007
using namespace std;
inline ll qmi(ll a,ll b,ll p){
	ll res = 1%p,t = a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
} 
ll n,m,k,i,j,l,vis[N],x,y,ans,F[1<<N],G[1<<N],gp[1<<N][N],g[1<<N],h[1<<N],ff[N],hh[N],hhh[N],gg[N],jc[N],inv[N],mer[1<<N];
inline bool check(ll x,ll y){
	for(ll i=0;i<n;i++){
		if((y>>i)&1){
			if(vis[i]&x) return 1;
		}
	}
	return 0;
}
inline ll solve(ll x){
	for(ll i=0;i<(1<<n);i++){
		G[i]=0;
		for(ll j=0,k=1;j<=n;j++,k=k*x%mod){
			if((j+1)&1) G[i]=(G[i]-k*gp[i][j]%mod+mod)%mod;
			else G[i]=(G[i]+k*gp[i][j])%mod;
		}
	}
	F[0]=1;
	for(ll i=1;i<(1<<n);i++){
		F[i]=0;
		for(ll j=i;j;j=(i&(j-1))){
			if(mer[j]&(i^j)) continue;
			F[i]=(F[i]+F[i^j]*G[j])%mod;
		}
	}
	return F[(1<<n)-1];
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>k;
	jc[0]=1;
	for(i=1;i<=n+1;i++) jc[i]=jc[i-1]*i%mod;
	inv[n+1]=qmi(jc[n+1],mod-2,mod);
	for(i=n+1;i>=1;i--) inv[i-1]=inv[i]*i%mod;
	while(m--) cin>>x>>y,vis[x-1]|=(1<<(y-1));
	h[0]=1;
	for(i=1;i<(1<<n);i++) for(j=0;j<n;j++) if((i>>j)&1) if(!(vis[j]&i)) h[i]=(h[i]+h[i-(1<<j)])%mod;
	gp[0][0]=1;
	for(i=0;i<(1<<n);i++) for(j=0;j<n;j++) if((i>>j)&1) mer[i]|=vis[j];
	for(i=1;i<(1<<n);i++){
		ll pos = -1;
		for(j=0;j<n;j++) if((i>>j)&1) pos=j;
		for(j=i;j;j=(i&(j-1))){
			if(check(j,i^j)||check(i^j,j)||(!((j>>pos)&1))) continue;
			for(l=1;l<=n;l++) gp[i][l]=(gp[i][l]+gp[i^j][l-1]*h[j])%mod;
		}
	}
	for(i=1;i<=n+1;i++) ff[i]=solve(i);
	memset(h,0,sizeof(h));
	h[0]=1;
	for(i=1;i<=n+1;i++){
		for(j=i;j>=0;j--){
			h[j]=(-h[j]*i);
			if(j) h[j]=(h[j]+h[j-1]);
			h[j]=(h[j]%mod+mod)%mod;
		}
	}
	for(i=1;i<=n+1;i++){
		ll res = ff[i]*inv[i-1]%mod*inv[n+1-i]%mod;
		if((n+1-i)%2==1) res=(mod-res)%mod;
		for(j=0;j<=n+1;j++) hh[j]=h[j];
		for(j=n+1;j>0;j--) hhh[j-1]=hh[j],hh[j-1]=(hh[j-1]+hh[j]*i)%mod;
		for(j=0;j<n+1;j++) gg[j]=(gg[j]+hhh[j]*res)%mod;
	}
	for(i=0;i<=k+1;i++) ans=(ans+gg[i]*jc[k]%mod*jc[k+1]%mod*inv[k+1-i])%mod;
	for(i=1;i<=n+k;i++) ans=ans*qmi(i,mod-2,mod)%mod;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Graphcity (赞：6)

> **前置知识：计数 $n$ 个点的 DAG 数量。**
> 
> 设 $f_n$ 为答案，考虑容斥。注意到 DAG 删掉若干个入度为零的点还是 DAG，我们每次钦定若干个入度为零的点，有转移 $f_n=\sum_{i=1}^n(-1)^{i-1}\dbinom{n}{i}2^{i(n-i)}f_{n-i}$。

不难发现最后能不能拼起来只取决于被切出来的段组成的集合。我们设这个集合大小为 $s$，那么它对应的概率就是 $\dfrac{s!k!}{n!(n+1)^{\overline k}}\dbinom{k+1}{s}$。$s!$ 表示集合可以任意排列，$\dfrac{1}{n!(n+1)^{\overline k}}$ 表示根据题目一组划分方案对应的概率，$\dbinom{k+1}{s}$ 表示给这 $s$ 段的 $s+1$ 个切断位置分配断点的方案，$k!$ 表示每个断点的顺序任意。

现在我们知道了最终答案只跟集合和它的大小有关系。设 $f_S$ 表示一段内的集合为 $S$ 的方案数，转移考虑依次加入新点，做到 $O(2^nn)$。设 $g_{S,i}$ 表示 $i$ 个段，包含的数字集合为 $S$ 的方案数。根据之前集合划分容斥的过程，再设中间状态 $h_{S,i}$ 表示 $i$ 个段，包含的数字集合为 $S$，且这里面的段要求入度为零的方案数。

$g$ 的转移为：

$$
g_{S,a+b}\gets \sum_{T\subseteq S,T\not=\varnothing} h_{T,a}\times g_{S/T,b}\times chk(S/T,T)
$$

其中 $chk(X,Y)$ 表示检查 $X\to Y$ 是否 **没有连边**。

$h$ 的转移为：

$$
h_{S,a+1}\gets \sum_{T\subseteq S,T\not=\varnothing} -f_{T}\times h_{S/T,a}\times chk(S/T,T)\times chk(T,S/T)
$$

暴力背包可以做到 $O(3^nn^2)$。注意到 $g_S,h_S$ 都可以写成不超过 $n$ 次的多项式，用 $0\sim n$ 的点值代入，就可以做到 $O(n)$ 的多项式乘法（背包），最后暴力插回来即可。总时间复杂度 $O(3^nn+\operatorname{poly}(n))$。

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=(1<<15),Mod=1e9+7;

inline int Pow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1) res=1ll*res*x%Mod;
        x=1ll*x*x%Mod,y>>=1;
    }
    return res;
}

int n,m,K,lim,ans;
int f[Maxn+5],g[Maxn+5][20],h[Maxn+5][20];
int vis[20],fac[Maxn+5],inv[Maxn+5],cnt[Maxn+5];
inline int C(int x,int y)
{
    if(x<y || y<0) return 0;
    return 1ll*fac[x]*inv[x-y]%Mod*inv[y]%Mod;
}

int main()
{
    cin>>n>>m>>K; lim=(1<<n)-1,f[0]=1;
    For(i,0,n) g[0][i]=1,h[0][i]=Mod-1;
    fac[0]=inv[0]=1; For(i,1,Maxn) fac[i]=1ll*fac[i-1]*i%Mod;
    inv[Maxn]=Pow(fac[Maxn],Mod-2);
    Rof(i,Maxn-1,1) inv[i]=1ll*inv[i+1]*(i+1)%Mod;
    For(i,1,m)
    {
        int a,b; cin>>a>>b; vis[a]|=(1<<b-1);
        cnt[(1<<a-1)|(1<<b-1)]++;
    }
    For(i,0,n-1) For(j,0,lim) if(j&(1<<i)) cnt[j]+=cnt[j^(1<<i)];
    For(i,0,lim) For(j,1,n) if(!(i&(1<<j-1)) && !(vis[j]&i))
        f[i|(1<<j-1)]=(f[i|(1<<j-1)]+f[i])%Mod;
    For(i,1,lim)
    {
        int w=lowbit(i);
        for(int j=i;j;j=(j-1)&i) if((j&w) && !(cnt[i]-cnt[j]-cnt[i^j]))
            {For(k,0,n) h[i][k]=(h[i][k]-1ll*f[j]*h[i^j][k]%Mod*k%Mod+Mod)%Mod;}
        for(int j=i;j;j=(j-1)&i)
        {
            int k=(i^j),flg=1;
            For(p,1,n) if((k&(1<<p-1)) && (vis[p]&j)) {flg=0; break;}
            if(flg) {For(a,0,n) g[i][a]=(g[i][a]+1ll*h[j][a]*g[k][a])%Mod;}
        }
    }
    static int val[20],num[20],dx[20];
    For(i,0,n) {val[i]=g[lim][i]; For(j,0,n) if(i!=j) val[i]=1ll*val[i]*Pow(i-j+Mod,Mod-2)%Mod;}
    For(i,0,n)
    {
        memset(dx,0,sizeof(dx)),dx[0]=1;
        For(j,0,n) if(i!=j)
        {
            Rof(k,n,1) dx[k]=(dx[k-1]-1ll*j*dx[k]%Mod+Mod)%Mod;
            dx[0]=1ll*(Mod-j)*dx[0]%Mod;
        }
        For(j,0,n) num[j]=(num[j]+1ll*dx[j]*val[i])%Mod;
    }
    For(i,1,n) ans=(ans+1ll*num[i]*C(K+1,i)%Mod*fac[i])%Mod;
    ans=1ll*ans*inv[n]%Mod*fac[K]%Mod;
    For(i,1,K) ans=1ll*ans*Pow(n+i,Mod-2)%Mod;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：云浅知处 (赞：6)

考虑 $k=0$ 怎么做：发现是 DAG 拓扑序计数，可以简单做到 $O(n2^n)$。

那么 $k>0$ 相当于把点划分成有序的 $k+1$ 部分，每部分内部有一个拓扑序的贡献，然后要求这些部分之间不形成环。这里为了方便我们钦定每一部分非空，这样如果划分出了无序的 $x$ 部分，其方案数还有 $x!\binom{k+1}{x}$ 的贡献系数。

设 $f(i,S)$ 表示将点集 $S$ 划分为 $i$ 个部分的方案数，转移可以枚举一个部分，钦定它的拓扑序在所有部分之前。 当然啦，这样是会算重的，我们实际上会把一种方案算“它缩点后形成的 DAG 的拓扑序个数”这么多次。

考虑换一种方式统计，每次我们把所有入度为 $0$ 的点都拎出来，算出 $g(i,S)$ 表示 $S$ 分成 $i$ 部分，且这些部分之间两两没有连边的贡献之和；接下来转移 $f(i,S)$ 的时候直接把一个极大的 $T$ 拿出来转移，要求剩下的点中不能有连向 $T$ 的，转移到 $f(i-j,S-T)\times g(j,T)$。

不过呢，这样还是会算重，因为我们只钦定了 $T$ 是入度为 $0$ 的点的一个子集。不过这件事倒是很好解决，如果转移用的是 $g(j,T)$，我们附上容斥系数 $(-1)^{j+1}$，那么由于
$$
\sum_{i=1}^{n}\binom{n}{i}(-1)^{i+1}=(-1)\times ([n=0]-1)=[n\neq 0]
$$
我们钦定了非空，所以每个方案恰好算一次。这样复杂度是 $O(n^23^n)$。LOJ 能过，洛谷上会 TLE。

注意到瓶颈在最后那个 $f(i,S)=\sum_{j,T}g(j,T)f(i-j,S-T)$ 的 DP，发现这相当于在第一维做和卷积，第二维做子集无交并卷积。设 $F_S(z)=\sum_{i=0}^nf(i,S)z^i,G_S(z)=\sum_{i=0}^ng(i,S)z^i$，那么转移相当于
$$
F_S=\sum_{T\subseteq S,T\neq \varnothing}F_T\times G_{S-T}
$$
带 $n+1$ 个点值进去，最后 $O(n^2)$ 插值算出系数即可。这样复杂度就是 $O(n3^n)$。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define fi first
#define se second
#define mk make_pair

using namespace std;

int read(){
	int x=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	return f==1?x:-x;
}

mt19937 rnd(time(0));
int randint(int l,int r){return rnd()%(r-l+1)+l;}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int mod=1e9+7;
void add(int &x,int v){x+=v;if(x>=mod)x-=mod;}
int cmod(int x){if(x>=mod)x-=mod;return x;}
int ksm(int x,int y,int p=mod){
	int ans=1;x%=p;
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans;
}
int inv(int x,int p=mod){return ksm(x,p-2,p);}

const int MN=105;
int fac[MN],ifac[MN],C[MN][MN];
void init(int V){
	fac[0]=1;for(int i=1;i<=V;i++)fac[i]=1ll*fac[i-1]*i%mod;
	ifac[V]=inv(fac[V]);for(int i=V-1;i>=1;i--)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;
	for(int i=0;i<=V;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++)C[i][j]=cmod(C[i-1][j-1]+C[i-1][j]);
	}
}

const int N=17;
int n,m,k;
bool G[N][N];
int f[1<<N],g[N][1<<N],h[N][1<<N],Lg[1<<N];
bool w[N][1<<N],wt[N][1<<N];

signed main(){
	
// 	freopen("timeline.in","r",stdin);
// 	freopen("timeline.out","w",stdout);

	init(MN-5);
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		G[u-1][v-1]=1;
	}
	f[0]=1;
	for(int S=1;S<(1<<n);S++){
		for(int i=0;i<n;i++)if(S&(1<<i)){
			bool chk=0;
			for(int j=0;j<n;j++)if((S&(1<<j))&&j!=i&&G[j][i])chk=1;
			if(!chk)add(f[S],f[S^(1<<i)]);
		}
	}
	
	for(int i=0;i<n;i++)Lg[1<<i]=i;
	for(int i=0;i<n;i++){
		for(int S=0;S<(1<<n);S++)for(int j=0;j<n;j++){
			if((S&(1<<j))&&(G[i][j]||G[j][i]))w[i][S]=1;
			if((S&(1<<j))&&G[j][i])wt[i][S]=1;
		}
	}

	vector<vector<int> >cans(1<<n);
	auto chk1=[&](int S,int T){
		while(S){
			if(w[Lg[S&(-S)]][T])return false;
			S=(S&(S-1));
		}
		return true;
	};
	
	for(int S=0;S<(1<<n);S++){
		for(int T=S;T;T=((T-1)&S))if(chk1(S-T,T))cans[S].emplace_back(T);
	}
	
	g[0][0]=1;
	for(int i=1;i<=n+1;i++){
		for(int S=1;S<(1<<n);S++){
			for(int T:cans[S])add(g[i][S],1ll*g[i-1][S^T]*f[T]%mod);
		}
	}
	for(int i=0;i<=n+1;i++)for(int S=0;S<(1<<n);S++){
		if(i>0)g[i][S]=1ll*g[i][S]*ifac[i]%mod;
		if(i%2==0)g[i][S]=cmod(mod-g[i][S]);
	}
	
	auto chk2=[&](int S,int T){
		while(S){
			if(wt[Lg[S&(-S)]][T])return false;
			S=(S&(S-1));
		}
		return true;
	};
	
	for(int S=0;S<(1<<n);S++){
		cans[S].clear();
		for(int T=S;T;T=((T-1)&S))if(chk2(S-T,T))cans[S].emplace_back(T);
	}
	
	auto calc=[&](int z){
		vector<int>F(1<<n,0),G(1<<n,0);
		for(int S=0;S<(1<<n);S++){
			for(int i=n+1;i>=0;i--)G[S]=cmod(1ll*G[S]*z%mod+g[i][S]);
		}
		F[0]=1;
		for(int S=1;S<(1<<n);S++){
			for(int T:cans[S])add(F[S],1ll*F[S^T]*G[T]%mod);
		}
		return F[(1<<n)-1];
	};
	
	vector<int>vl(n+2);
	for(int i=0;i<n+2;i++)vl[i]=calc(i+1);
	
	auto Lag=[&](vector<int>vals,int m){ // x_i = i + 1
		vector<int>P(m+2),Ans(m+1);
		vector<int>Iv(m+1);
		for(int i=0;i<=m;i++)Iv[i]=inv(mod-(i+1));
		P[0]=1;
		for(int i=0;i<=m;i++){
			for(int j=m+1;j>=0;j--){
				P[j]=1ll*P[j]*(mod-(i+1))%mod;
				if(j>=1)add(P[j],P[j-1]);
			}
		}
		
		for(int i=0;i<=m;i++){
			auto Q=P;
			for(int j=0;j<=m+1;j++){
				if(j>=1)add(Q[j],mod-Q[j-1]);
				Q[j]=1ll*Q[j]*Iv[i]%mod;
			}
			int val=vals[i];
			if(i>0)val=1ll*val*ifac[i]%mod;
			if(i<m)val=1ll*val*ifac[m-i]%mod;
			if((m-i)&1)val=cmod(mod-val);
			for(int j=0;j<=m;j++)add(Ans[j],1ll*Q[j]*val%mod);
		}
		return Ans;
	};
	
	auto Ans=Lag(vl,n+1);
	
	int ans=0;
	for(int i=1;i<=k+1;i++)add(ans,1ll*C[k+1][i]*Ans[i]%mod*fac[i]%mod);
	cout<<1ll*ans*inv(1ll*fac[n]*C[n+k][n]%mod)%mod<<endl;

	return 0;
}
```

---

## 作者：zhouhuanyi (赞：4)

首先原问题显然是一个 $\text{DAG}$ 计数的形式，施加枚举 $0$ 度点集合 $S$ 容斥的技巧是自然的。考虑 $k$ 刀将其切割成 $t$ 段后最终找到一种标号使得存在一种重排方案使其合法的方案数。段内的方案计算是容易的，要求它们所有关系顺序即可，可以快速求出构成一个段的集合 $S$ 的方案数 $F_{S}$。而我们要施加枚举 $0$ 度点集合 $S$ 容斥技巧，所以要将这些段在之间没有连边的情况下拼起来，记拼成 $w$ 个段的方案数为 $G_{w,S}$。在枚举 $0$ 度点容斥时只要记下来最终拼合成 $e$ 个段的方案数为 $H_{e,S}$，由于段可以任意排列，要乘 $e!$，之后因为 $k$ 刀将其分割成 $e$ 个段的所有情况的概率相同，所以统计答案是容易的，直接这样可以得到一个 $O(3^nn^2)$，看上去是不能通过 $n\leqslant 15$ 的。

但接下来是一个有点"乱假成真，乱真成假"的事情了，由于答案是一个多项式，上述过程显然可以带点值最后拉插回来做到 $O(3^nn)$。这个是比上述做法优的，但笔者的考场代码反而还被卡常了，而不少经过卡常的 $O(3^nn^2)$ 都过了(经过一定的观察，笔者发现在内存访问连续且可以并行运算的写法下，即写成多项式乘法的形式，实在是非常非常快，导致这种做法在 $n=15$ 的情况下甚至比 $O(3^nn)$ 的做法的实际运行时间更短)。笔者认为可能 $n$ 要到更大的数据范围，比如 $n=20$，可能才能体现出这种做法的优势，在本题的数据范围下 $n$ 和常数其实差不多。

---

## 作者：zifanwang (赞：3)

考虑这题是什么意思，其实就是让你把 DAG 划分成若干个集合，点之间连边转化为对应集合之间连边以后图仍然是一个 DAG，然后需要知道划分成了多少个集合，每种集合的个数求出方案数，乘上对应的系数并求和。

系数是很显然的，即：

$${k+1\choose i}\frac{i!k!}{n!\prod_{i=1}^k (n+i)}$$

考虑怎么求方案数。记 $f_{S,i}$ 表示把集合 $S$ 分成 $i$ 个子集且最终的图是一个 DAG 的方案数。考虑枚举一个没有出边的子集然后转移，这样可以保证最终的图是一个 DAG，但是会算重。

会算重，所以就可以做一个容斥。记 $g_{S,i}$ 表示把集合 $S$ 分成 $i$ 个子集且这些子集之间无边的方案数。可以直接枚举子集然后转移，使得子集中包含 $S$ 中编号最小的点，这样求出来的方案数是正确的。

然后就是最终的容斥部分，易得：

$$f_{S,i}=\sum_{S'\subseteq S,不存在S'到S的边}\sum_{j=1}^{i}(-1)^{j-1}\cdot g_{S',j}\cdot f_{S/S',i-j}$$

最后乘上系数求和即可。时间复杂度
 $T(n)=\sum_{i=0}^n{n\choose i}2^ii^2\mathcal{O}(1)=2\times 3^{n-2}n(2n+1)\mathcal{O}(1)=\mathcal{O}(3^nn^2)$，常数很小，可以通过此题。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 200003
#define md 1000000007
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
using namespace std;
inline ll power(ll x,int y){
    ll ans=1;
    for(;y;y>>=1){
        if(y&1)ans=ans*x%md;
        x=x*x%md;
    }
    return ans;
}
int n,m,k,t,d[18],d1[18],dd[1<<15],s[18],a[18],c[20][20];
ll xi,ans,fac[20],dp[1<<15],f1[1<<15][17],f[1<<15][17];
signed main(){
    scanf("%d%d%d",&n,&m,&k);
    c[0][0]=1;
    rep(i,1,18){
        c[i][0]=1;
        rep(j,1,i)c[i][j]=(c[i-1][j-1]+c[i-1][j])%md;
    }
    fac[0]=1;
    rep(i,1,18)fac[i]=fac[i-1]*i%md;
    for(int i=0,x,y;i<m;++i){
        scanf("%d%d",&x,&y);
        x--,y--;
        d[y]|=1<<x,d1[x]|=1<<y;
    }
    xi=1;
    rep(i,1,n)xi=xi*i%md;
    xi=power(xi,md-2);
    rep(i,1,k)xi=xi*power(n+i,md-2)%md*i%md;
    dp[0]=1;
    rept(s,1,1<<n){
        rept(i,0,n)if((s>>i)&1){
            if(d[i]&s)continue;
            dp[s]=(dp[s]+dp[s^(1<<i)])%md;
        }
    }
    rept(s,1,1<<n){
    	rept(i,0,n)if((s>>i)&1){
    		dd[s]=dd[s^(1<<i)]|d[i];
    		break;
		}
	}
    f1[0][0]=1;
    rept(s,1,1<<n){
    	int s1=s^(s&-s),ct=min(__builtin_popcount(s),k+1);
    	for(int s2=s1;;s2=(s2-1)&s1){
    		rept(i,0,n)if(((s2|(s&-s))>>i)&1&&((d[i]|d1[i])&(s1^s2)))goto nxt;
    		rep(i,1,ct)f1[s][i]=(f1[s][i]+f1[s1^s2][i-1]*dp[s2|(s&-s)])%md;
    		nxt:;
    		if(!s2)break;
		}
	}
    f[0][0]=1;
    rept(s,1,1<<n){
    	int ct=min(__builtin_popcount(s),k+1);
    	for(int s1=s;s1;s1=(s1-1)&s){
    		if((s^s1)&dd[s1])continue;
    		rep(i,1,ct){
    			rep(j,1,i){
    				if(j&1)f[s][i]=(f[s][i]+f[s^s1][i-j]*f1[s1][j])%md;
    				else f[s][i]=(f[s][i]-f[s^s1][i-j]*f1[s1][j])%md;
				}
			}
		}
	}
	rep(i,1,k+1)ans=(ans+f[(1<<n)-1][i]*c[k+1][i]%md*fac[i])%md;
    cout<<(ans*xi%md+md)%md;
    return 0;
}
```

---

## 作者：_fairytale_ (赞：3)

## 闲话
听说过了这个题就可以重塑时光。

可是。

骗哥们可以，别把自己也骗了。
## 题解
首先考虑概率转计数，只需算出将 $1\dots n$ 划分成 $(k+1)$ 个可以为空的点集，点集内部构成其导出 DAG 的一个拓扑序，点集之间也构成 DAG 的方案数，最后除一下总方案数 $n!{n+k\choose k}$ 即可。

对点集内部的拓扑序计数相当于 $k=0$，直接套用做法即可，于是我们处理出了 $g[S]$ 表示点集 $S$ 内部的拓扑序个数。

对点集的 DAG 数量计数，我们使用与 [CF1193A Amusement Park](https://www.luogu.com.cn/problem/CF1193A) 或者 [ABC306Ex](https://www.luogu.com.cn/problem/AT_abc306_h) 类似的容斥对 DAG 计数。设 $f[S][i]$ 表示 $S$ 中的元素被划分成了 $i$ 个点集且形成了 DAG 的方案数（这里要求有序，即点集之间本质相同的 DAG 只算一次，原因下面会说），转移枚举一些点集并钦定其度数为 $0$，所以还要设 $h[T][j]$ 表示 $T$ 中的元素被划分成了 $j$ 个点集且两两之间没有连边的方案数，然后从 $f[S][i]$ 转移到 $f[S\cup T][i+j]$，即

$$
\dfrac{f[S][i]\times (-1)^{j-1}\times h[T][j]}{j!}\to f[S\cup T][i+j]
$$

$h$ 的计算方式很简单。枚举一个与 $S$ 不交的点集 $T$，满足 $S,T$ 之间没有连边，从 $h[S][i]$ 转移到 $h[S\cup T][i+1]$ 即可，系数是 $g[T]$。

最后计算答案，设 $U$ 是全集，则 $f[U][i]$ 对答案有一个 $i!\times {k+1\choose i}$ 的贡献系数，$i!$ 是因为前面钦定了 DAG 有序，而点集之间怎样打乱最后都能排回来，$k+1\choose i$ 的意思是把剩下没切的 $k-i+1$ 刀用掉的方案数，注意这里只能切切过的地方以及两端，容易用插板法算出。

时间复杂度 $\mathcal O(3^n n^2)$，常数很小，可以使用多项式插值相关知识优化到 $\mathcal O(n3^n)$，暂时咕了。

代码里把 $k$ 加了 $1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 23
#define mod 1000000007
int n,m,k;
int qp(int x,int y) {
	int res=1;
	while(y) {
		if(y&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}
int inv(int x) {
	return qp(x,mod-2);
}
int U;
int fac[210],invfac[210];
#define maxS 36888
#define hav(S,i) (((S)>>((i)-1))&1)
int g[maxS];
int in[maxn],out[maxn];
inline void add(int &x,int y) {
	x+=y;
	if(x<0)x+=mod;
	if(x>=mod)x-=mod;
}
#define rep(x,qwq,qaq) for(int (x)=(qwq);(x)<=(qaq);++(x))
void init_g() {
	g[0]=1;
	rep(S,1,U) {
		rep(i,1,n) {
			if(hav(S,i)) {
				if(out[i]&S)continue;
				add(g[S],g[(S^(1<<(i-1)))]);
			}
		}
	}
}
int In[maxS],Out[maxS];
int h[maxS][maxn];
int ppc[maxS];
void init_h() {
	rep(S,1,U) {
		ppc[S]=ppc[S>>1]+(S&1);
		rep(i,1,n) {
			if(hav(S,i))In[S]|=in[i],Out[S]|=out[i];
		}
	}
	h[0][0]=1;
	rep(S,1,U){
		for(int T=S; T; T=S&(T-1)) {
			if((In[T]&(S^T))||(Out[T]&(S^T)))continue;
			rep(j,0,ppc[S^T]) {
				add(h[S][j+1],1ll*h[S^T][j]*g[T]%mod);
			}
		}
	}
}
int f[maxS][maxn];
int K[maxS];
int ans;
void init_f(){
	rep(i,0,n)K[i]=(i&1?1:-1);
	f[0][0]=1;
	rep(S,1,U){
		for(int T=S;T;T=S&(T-1)){
			if(Out[S^T]&T)continue;
			rep(i,1,ppc[S]){
				rep(j,0,i-1){
					add(f[S][i],1ll*K[i-j]*f[S^T][j]*h[T][i-j]%mod*invfac[i-j]%mod);
				}
			}
		}
	}
	
}
int C(int x,int y) {
	if(x<y||x<0||y<0)return 0;
	return 1ll*fac[x]*invfac[y]%mod*invfac[x-y]%mod;
}
int u,v;
int main() {
//	freopen("timeline.in","r",stdin);
//	freopen("timeline.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	++k;
	fac[0]=invfac[0]=1;
	U=(1<<n)-1;
	rep(i,1,200)fac[i]=1ll*fac[i-1]*i%mod;
	rep(i,1,200)invfac[i]=inv(fac[i]);
	rep(i,1,m) {
		cin>>u>>v;
		out[u]|=(1<<(v-1));
		in[v]|=(1<<(u-1));
	}
	init_g();
	init_h();
	init_f();
	rep(i,1,k)add(ans,1ll*f[U][i]*C(k,i)%mod*fac[i]%mod);
	ans=1ll*ans*inv(1ll*fac[n]*C(n+k-1,k-1)%mod)%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：3)

显然要将概率转计数。

考虑对于 $m$ 条限制建立 $\text{DAG}$，记这个图是 $G=(V,E)$。直接不好算，考虑计算，对于给定的拆分方式，有多少个排列合法。这样它就变成 counting 了。

判定一组合法，考虑对于 $k+1$ 个集合 $S_i$，$S_i$ 内部顺序一定是 $G$ 对于 $S_i$ 导出子图的拓扑序。同时 $k+1$ 个集合之间的边不能形成环。

显然对于每个集合的内部，顺序没有太大影响，如果确定了每个集合的构成，直接乘上这些的**拓扑序个数**即可。记 $g_S$ 表示 $G$ 对于 $S$ 的导出子图的拓扑序个数，直接枚举首位进行转移即可，这个可以做到 $O(n2^n)$。

定义一组集合划分的权值，是所有集合拓扑序个数以及顺序的乘积。

考虑集合之间的影响，仍然放在 $G$ 上处理。先把空的去了，最后直接组合数一乘就行。设对于 $f_{S,i}$ 是 $S$ 中划分了 $i$ 个非空集合的权值和。

音乐课想到这里想了半天不会，然后就摆烂了，wssb。

**$\textbf{DAG}$ 这种东西，一定要特殊考虑下，无入度 / 无出度 的点。**

考虑**钦定**子集 $T\subset S$ 使得 $T$ 是无出度的，作为这个 $S$ 所谓的叶子。**钦定** 的作用是，可以后面直接乘上容斥系数 $(-1)^{|T|+1}$，最后求和就是我们想要的东西。这个 $T$ 中的划分方式，考虑分为了 $x$ 个集合，这 $x$ 个集合一定满足其是**独立集**，即没有边直接相连。

接下来就不难想到，考虑 $dp_{S,i}$ 为 $S$ 的导出子图，划分为 $i$ 个非空**独立集**的所有方案的权值和，枚举子集 $T$ 然后判定与余下部分双向独立，再转移，即：$f_{S\setminus T,i-1}\times g_{T}$。这个显然可以做到 $O(n3^n)$。

考虑回过头来求 $f_{S,i}$，需要枚举叶子独立集 $T$，以及其大小，需要考虑补集的所有大小，所以这部分的复杂度是 $O(3^nn^2)$。

算出来所有的 $f_{S,i}$ 后，再求一下总合法方案数。再除以总方案数 $\dfrac{(n+k)!}{k!}$ 即可。操作之间有序无序其实无所谓，因为 $k!$ 总会被消掉。

总时间复杂度 $O(3^nn^2)$，由于没啥常数直接就过了。注意，枚举到 $\text{popcount}(S)$ 是一个重要的优化。

[提交记录。](https://loj.ac/s/2025670)

---

## 作者：dAniel_lele (赞：3)

首先将问题分解成三个部分：

* 计算若干次切割后，变成 $i$ 段的概率；
* 对于每个子集 $S$，假设 $S$ 子集内在一段，与条件不冲突的方案数；
* 计算有多少种划分使得存在一种方案满足条件。

对于第一个部分，考虑 $dp_{i,j}$ 表示 $i$ 次操作后分成 $j$ 段的方案数。转移是容易的。

对于第二个部分，考虑 $f_{S}$ 表示 $S$ 子集的方案数。转移时考虑新加一个点，没有条件要求这个点在 $S$ 中任意一个数之前。

对于第三个部分，考虑容斥。设 $g_{S,i}$ 表示 $i$ 个互不冲突的子集（即不存在 $(i,j)$ 之间有条件且 $i,j$ 在不同子集）并为 $S$ 的方案数，设 $h_{S,i}$ 表示有多少种分成 $i$ 个集合且存在排列方案符合时间线。使用经典的 DAG 计数的容斥即可，即 $S\cap T=\empty$，$g_{S,i}\times h_{T,j}\times(-1)^i\to h_{S\cup T,i+j}$。总复杂度 $O(3^nn^2)$，需要轻微卡常。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int deg[40],outv[40],rel[40][40],srel[65536][40],fac[40],inv[40],n,m,k;
int dp1[65536],dp2[65536][40],dp3[65536][40];
vector<int> vc[40];
int pdp[40][40],pre[40];
bool check1(int i,int j){
	for(int l=1;l<=n;l++) if((j>>(l-1))&1) if(srel[i][l]) return false;
	for(int l=1;l<=n;l++) if((i>>(l-1))&1) if(srel[j][l]) return false;
	return true;
}
bool check2(int i,int j){
	for(int l=1;l<=n;l++) if((j>>(l-1))&1) if(srel[i][l]) return false;
	return true;
}
signed main(){
	fac[0]=1; for(int i=1;i<=15;i++) fac[i]=fac[i-1]*i%mod;
	inv[15]=qp(fac[15],mod-2); for(int i=14;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
	cin>>n>>m>>k;
	if(m==0){
		cout<<1;
		return 0;
	}
	int s=(1<<n)-1;
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v;
		vc[u].push_back(v);
		deg[v]++;
	}
	int tot=1;
	for(int i=n+1;i<=n+k;i++) (tot*=i)%=mod;
	for(int i=1;i<=n;i++){
		memset(pdp,0,sizeof(pdp));
		pdp[0][1]=1;
		for(int j=1;j<=k;j++){
			for(int l=1;l<=i;l++){
				pdp[j][l]=(pdp[j-1][l-1]*(i+1-l)+pdp[j-1][l]*(l+1+(j-1)))%mod;
			}
		}
		pre[i]=pdp[k][i]*qp(tot,mod-2)%mod*fac[i]%mod*inv[n]%mod;
	}
	queue<int> q;
	int cnt=0;
	for(int i=1;i<=n;i++) outv[i]=(1<<(i-1));
	for(int i=1;i<=n;i++) if(!deg[i]) q.push(i);
	while(!q.empty()){
		int f=q.front(); q.pop();
		cnt++;
		for(auto v:vc[f]){
			outv[v]|=outv[f];
			deg[v]--;
			if(!deg[v]) q.push(v);
		}
	}
	if(cnt!=n){
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(j==i) continue;
			if((outv[i]>>(j-1))&1) rel[j][i]=1;
		}
	}
	for(int i=0;i<(1<<n);i++){
		for(int j=1;j<=n;j++){
			if((i>>(j-1))&1){
				for(int k=1;k<=n;k++){
					if(!((i>>(k-1))&1)){
						if(rel[j][k]){
							srel[i][k]=1;
						}
					}
				}
			}
		}
	}
	dp1[0]=1;
	for(int i=0;i<(1<<n);i++){
		for(int j=1;j<=n;j++){
			if(!((i>>(j-1))&1)){
				if(!srel[i][j]){
					(dp1[i|(1<<(j-1))]+=dp1[i])%=mod;
				}
			}
		}
	}
	dp2[0][0]=1;
	for(int i=0;i<(1<<n);i++){
		int bp1=__builtin_popcount(i);
		for(int j=s^i;j;j=(j-1)&(s^i)){
			if(check1(i,j)){
				for(int l=0;l<=bp1;l++){
					(dp2[i|j][l+1]+=dp2[i][l]*dp1[j])%=mod;
				}
			}
		}
	}
	for(int i=0;i<(1<<n);i++) for(int j=1;j<=n;j++) (dp2[i][j]*=inv[j])%=mod;
	dp3[0][0]=1;
	for(int i=0;i<(1<<n);i++){
		int bp1=__builtin_popcount(i);
		for(int j=s^i;j;j=(j-1)&(s^i)){
			int bp2=__builtin_popcount(j);
			if(check2(i,j)){
				for(int l1=0;l1<=bp1;l1++){
					for(int l2=1;l1+l2<=n&&l2<=bp2;l2++){
						if(l2&1) (dp3[i|j][l1+l2]+=dp3[i][l1]*dp2[j][l2])%=mod;
						else{
							dp3[i|j][l1+l2]+=mod-dp3[i][l1]*dp2[j][l2]%mod;
							if(dp3[i|j][l1+l2]>=mod) dp3[i|j][l1+l2]-=mod;
						}
					}
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		(ans+=dp3[s][i]*pre[i])%=mod;
	}
	cout<<ans;
	return 0;
}



```

---

## 作者：Mine_King (赞：1)

[在我的博客获得更好的阅读体验。](https://caijimk.netlify.app/post/zjoi2024-solution)

看数据范围猜复杂度是 $O(3 ^ n) / O(3 ^ n n)$。

考虑 $k = 0$ 的情况，就是求拓扑序的数量，直接状压即可。

对于更一般的情况，我们考虑将连续的一段缩成一个点，这样只需要每种点数对应的图的数量即可求出答案。

具体地，我们先对于每个 $S$ 表示集合 $S$ 的拓扑序个数，然后设 $dp _ {S, i}$ 表示只考虑集合 $S$，有 $i$ 个点的 DAG 数量。

怎么求 $dp$ 先放一放，考虑求出来之后怎么算答案。

首先是合法方案数：

$$
\sum\limits _ {i = 1} ^ {k + 1} dp _ {U, i} i! k! \binom{k + 1}{i}
$$

然后考虑总方案数，设 $f _ {i, j}$ 表示前 $i$ 个数切了 $j$ 刀（只能切在数的前面），考虑切的顺序时的方案，转移是简单的，最终结果就是 $f _ {n + 1, k} n!$。

剩下的就是本题最大的难点，如何求解 $dp$ 的值。

这里需要一个结论：对于一张 DAG，每次选择一个零度点的集合删去并将贡献加上 $-1$ 的集合大小 $+1$ 次，则所有删点方案的贡献总和为 $1$。

于是考虑设 $g _ {S, i}$ 表示集合 $S$ 构成 $i$ 个点，且这些点之间没有边的方案数，则有状态转移方程：

$$
dp _ {S, i} = \sum\limits _ {T \in S, T \ne \varnothing, pre _ T \cap S = \varnothing} \sum\limits _ {j = 0} ^ {|T|} dp _ {S \setminus T, j - i} g _ {T, j}
$$

其中 $pre _ T$ 表示所有 $T$ 的前驱。

暴力转移，前两部分的复杂度是 $O(3 ^ n) / O(3 ^ n n)$，最后求 $dp$ 的复杂度是 $O(3 ^ n n ^ 2)$。

发现转移很像卷积的形式，考虑设 $DP _ S(x) = \sum _ {i = 0} ^ n dp _ {S, i} x ^ i, G _ S(x) = \sum\limits _ {i = 0} ^ n g _ {S, i} x ^ i$，则 $DP _ S, G _ S$ 都是 $n$ 次多项式，且有：

$$
DP _ S = \sum\limits _ {T \in S, T \ne \varnothing, pre _ T \cap S = \varnothing} DP _ {S \setminus T} \times G _ T
$$

考虑拉格朗日插值，任意取 $n + 1$ 个点值，多项式卷积就是点值相乘，多项式加法就是点值相加，因此可以 $O(3 ^ n n)$ 转移，而我们只需要 $DP _ U$ 的系数，因此求出 $DP _ U$ 的 $n + 1$ 个点值后再用拉格朗日插值暴力求出系数即可。

```cpp
// Think twice, code once.
#include <vector>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#define eputchar(c) putc(c, stderr)
#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define eputs(str) fputs(str, stderr), putc('\n', stderr)
using namespace std;

const int mod = 1e9 + 7;

int n, m, k, U;
int pre[1 << 15], ts[1 << 15], g[1 << 15][25], gv[1 << 15][25], dp[1 << 15][25];
int tmp[1 << 15];
int fac[25], C[25][25], f[25][25];

void toposort(int S) {
	tmp[0] = 1;
	vector<int> sub;
	for (int T = S; T >= 1; T = (T - 1) & S) sub.push_back(T);
	reverse(sub.begin(), sub.end());
	for (int T : sub) {
		tmp[T] = 0;
		for (int TT = T; TT; TT -= TT & -TT) {
			int i = TT & -TT;
			if (((T ^ i) & pre[i]) == (pre[i] & S)) tmp[T] = (tmp[T] + tmp[T ^ i]) % mod;
		}
	}
	ts[S] = tmp[S];
	return ;
}
int power(int a, int b) {
	int ans = 1;
	while (b) {
		if (b & 1) ans = (long long)ans * a % mod;
		a = (long long)a * a % mod;
		b >>= 1;
	}
	return ans % mod;
}
vector<int> pls(vector<int> a, vector<int> b) {
	if (a.size() < b.size()) a.swap(b);
	vector<int> ans(a.size());
	for (int i = 0; i < (int)ans.size(); i++)
		if (i < (int)b.size()) ans[i] = (a[i] + b[i]) % mod;
		else ans[i] = a[i];
	return ans;
}
vector<int> mul(vector<int> a, vector<int> b) {
	vector<int> ans(a.size() + b.size() - 1);
	for (int i = 0; i < (int)a.size(); i++)
		for (int j = 0; j < (int)b.size(); j++) ans[i + j] = (ans[i + j] + (long long)a[i] * b[j]) % mod;
	return ans;
}
vector<int> mul(vector<int> a, int b) {
	for (int i = 0; i < (int)a.size(); i++) a[i] = (long long)a[i] * b % mod;
	return a;
}
vector<int> div(vector<int> a, int b) {
	if (!b) {
		for (int i = 1; i < (int)a.size(); i++) swap(a[i - 1], a[i]);
		a.pop_back();
		return a;
	}
	vector<int> ans(a.size());
	int c = power(mod - b, mod - 2);
	ans[0] = (long long)a[0] * c % mod;
	for (int i = 1; i < (int)ans.size(); i++) ans[i] = (long long)(a[i] - ans[i - 1] + mod) * c % mod;
	ans.pop_back();
	return ans;
}

int main() {
	// freopen("timeline.in", "r", stdin);
	// freopen("timeline.out", "w", stdout);

	scanf("%d%d%d", &n, &m, &k);
	U = (1 << n) - 1;
	for (int i = 1; i <= m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		u--, v--;
		pre[1 << v] |= 1 << u;
	}
	for (int S = 1; S < 1 << n; S++) {
		int lowbit = S & -S;
		pre[S] = (pre[S ^ lowbit] | pre[lowbit]) & (U ^ S);
	}
	for (int S = 1; S < 1 << n; S++) toposort(S);

	g[0][0] = 1;
	for (int S = 1; S < 1 << n; S++)
		for (int i = 1; i <= n; i++)
			for (int T = S; T; T = (T - 1) & S)
				if ((T & -T) == (S & -S) && !(pre[T] & (S ^ T)) && !(pre[S ^ T] & T))
					g[S][i] = (g[S][i] + (long long)g[S ^ T][i - 1] * ts[T]) % mod;
	for (int S = 1; S < 1 << n; S++)
		for (int i = 0; i <= n; i++)
			for (int j = 0, pw = 1; j <= n; j++, pw = (long long)pw * i % mod)
				if (j % 2) gv[S][i] = (gv[S][i] + (long long)g[S][j] * pw) % mod;
				else gv[S][i] = (gv[S][i] + mod - (long long)g[S][j] * pw % mod) % mod;
	for (int i = 0; i <= n; i++) dp[0][i] = 1;
	for (int S = 1; S < 1 << n; S++)
		for (int T = S; T; T = (T - 1) & S)
			if (!(pre[T] & S))
				for (int i = 0; i <= n; i++)
					dp[S][i] = (dp[S][i] + (long long)dp[S ^ T][i] * gv[T][i]) % mod;
	vector<int> poly, tmp;
	poly.push_back(0);
	tmp.push_back(1);
	for (int i = 0; i <= n; i++) {
		vector<int> tmpm;
		tmpm.push_back(mod - i), tmpm.push_back(1);
		tmp = mul(tmp, tmpm);
	}
	for (int i = 0; i <= n; i++) {
		int c = dp[U][i];
		for (int j = 0; j <= n; j++)
			if (j != i) c = (long long)c * power((i - j + mod) % mod, mod - 2) % mod;
		poly = pls(poly, mul(div(tmp, i), c));
	}
	poly.push_back(0);

	for (int i = 0; i <= k + 1; i++)
		for (int j = 0; j <= i; j++)
			if (j == 0 || j == i) C[i][j] = 1;
			else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
	fac[0] = 1;
	for (int i = 1; i <= n; i++) fac[i] = (long long)fac[i - 1] * i % mod;
	int ans = 0;
	for (int i = 1; i <= k + 1; i++)
		ans = (ans + (long long)poly[i] * fac[i] % mod * fac[k] % mod * C[k + 1][i]) % mod;

	f[0][0] = 1;
	for (int i = 1; i <= n + 1; i++)
		for (int j = 0; j <= k; j++) {
			if (j == 0) {f[i][j] = 1; continue;}
			if (j == 1) {f[i][j] = (long long)i * (k - j + 1) % mod; continue;}
			for (int o = 0; o <= i; o++) f[i][j] = (f[i][j] + f[o][j - 1]) % mod;
			f[i][j] = (long long)f[i][j] * (k - j + 1) % mod;
		}

	ans = (long long)ans * power((long long)fac[n] * f[n + 1][k] % mod, mod - 2) % mod;
	printf("%d\n", ans);

	return 0;
}
```

---

## 作者：strlen_s_ (赞：0)

这个傻*在考场上把题目读错，浪费2h，错失调出 T1 的机会，且直到下考后才发现是切割的序列，而不是集合。

本文由敬爱的学长 Graphcity 指导，Graphcity tql!!!!

首先，题目说是可以重排切割序列的，对顺序有要求，直接搞难搞，于是考虑转化成切割的集合。空段难以直接计数，考虑最后把它们插到非空段之间。

设 $f_S$ 表示集合为 $S$ 的点放在一段，内部排序有多少的方案数。可以直接暴力枚举 $S$，然后暴力 dp 出 $S$ 内部排序的方案数，复杂度是 $O(3^nn)$。

设 $h_{i,S}$ 表示集合为 $S$ 的点分成 $i$ 段，使得这 $i$ 段中两两没有边。dp 时枚举超集转移即可。复杂度 $O(3^nn)$。

设 $g_{i,S}$ 表示你现在加了 $i$ 个非空段，且它们由集合 $S$ 里的点组成且合法的方案数。这 $i$ 个非空段构成一个 DAG 的时候是合法的，所以我们考虑每次假如 $j$ 个入度为 $0$ 的非空段，让它们与前面的段连边。但我们发现这样会重复。于是考虑更改转移意义为加入 $j$ 个入度为 $0$ 的非空段，使得入度为 $0$ 的至少为 $j$ 个，那么再容斥一下，就可以得出转移式：

$g_{i,S}=\sum_{j=1,T} (-1)^{j+1}\times g_{i-j,S-T}\times h_{j,T}$。

那么直接 dp 就是 $O(3^nn^2)$ 的，可以获得 85 分的好成绩。

考虑如何优化这个算法。发现 $g$ 在 $i$ 上的转移本质上是一个背包，于是我们可以考虑使用多项式来刻画这个 $g$ 数组。

具体的，设 $F_S=\sum_{i=0}^n g_{i,S}x^i $。那么转移就是：$F_S=\sum_T F_{S-T}H_T$。

使用多项式乘法这种东西对复杂度优化很小，还大常数。

发现其实我们只需要知道 $F_S$ 就可以了，其它是什么我们不关心。

于是考虑使用拉格朗日插值，用 $n+2$ 个点来刻画这个多项式，最后还原 $F_S$ 即可。

那么这部分复杂度就被降到了 $O(3^nn)$。

那么总复杂度就是 $O(3^nn)$ 了。

贴上我丑陋的代码。

```
#include<bits/stdc++.h>
#define int long long
#define lb(x) ((x)&(-x))
using namespace std;
const int N=(1<<15)+10,M=18,mod=1e9+7;
int ksm(int a,int b){
  int res=1;
  while(b){
    if(b&1)res=res*a%mod;
    a=a*a%mod,b>>=1;
  }
  return res;
}
int cl[N];
int f[N],pt[N];
int h[N][M],g[N][M];
int to[M],sum[N];
int n,m,k,ans,all;
int c[M],dp[M],cp[M];
int fr[M<<1],inv[M<<1];
int rec[M],pc[M],cnt,ord[M];
int C(int x,int y){return fr[x]*inv[y]%mod*inv[x-y]%mod;}
int get(int s){
  cnt=0;
  for(int i=1;i<=n;i++){
    ord[i]=pc[i]=0;
    if((s>>i-1)&1)rec[++cnt]=i,ord[i]=cnt;
  }
  for(int i=1;i<=cnt;i++)
    for(int j=1;j<=n;j++)
      if(((s>>j-1)&1)&&((to[rec[i]]>>j-1)&1))pc[i]|=(1<<ord[j]-1);
  for(int i=0;i<(1<<cnt);i++)cl[i]=0;
  cl[0]=1;
  for(int i=0;i<(1<<cnt);i++){
    if(!cl[i])continue;
    for(int j=1;j<=cnt;j++){
      if((i>>j-1)&1)continue;
      if((i&pc[j])!=pc[j])continue;
      cl[i|(1<<j-1)]=(cl[i|(1<<j-1)]+cl[i])%mod;
    }
  }
  return cl[(1<<cnt)-1];
}
signed main(){
  ios::sync_with_stdio(0);
  cin.tie(0),cout.tie(0);
  cin>>n>>m>>k;
  fr[0]=1;
  for(int i=1;i<=n+k;i++)fr[i]=fr[i-1]*i%mod;
  inv[n+k]=ksm(fr[n+k],mod-2);
  for(int i=n+k-1;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;
  for(int i=1,x,y;i<=m;i++){
    cin>>x>>y;
    to[y]|=(1<<(x-1));
  }
  f[0]=1;
  for(int i=1;i<(1<<n);i++){
    for(int j=1;j<=n;j++)
      if(i>>(j-1)&1)pt[i]|=to[j];
    pt[i]=(i&pt[i])^pt[i];
    f[i]=get(i);
  }
  h[0][0]=mod-1;
  for(int i=1;i<=n;i++)
    for(int j=0;j<(1<<n);j++){
      if(!h[j][i-1])continue;
      for(int k=j|(j+1);k<(1<<n);k=j|(k+1)){
        int x=k^j;
        if(lb(k)!=lb(x))continue;
        if((j&pt[x])!=0||(pt[j]&x)!=0)continue;
        h[k][i]=(h[k][i]+mod-h[j][i-1]*f[x]%mod)%mod;
      }
    }
  for(int i=1;i<=n+2;i++){
    for(int j=0;j<(1<<n);j++){
      sum[j]=0;
      for(int k=0,fc=1;k<=n;k++){
        sum[j]=(sum[j]+h[j][k]*fc%mod)%mod;
        fc=fc*i%mod;
      }
    }
    g[0][i]=1;
    for(int j=0;j<(1<<n);j++){
      if(!g[j][i])continue;
      for(int k=j|(j+1);k<(1<<n);k=j|(k+1)){
        int x=k^j;
        if((pt[x]&j)!=pt[x])continue;
        g[k][i]=(g[k][i]+g[j][i]*sum[x]%mod)%mod;
      }
    }
  }
  c[0]=1;
  for(int i=1;i<=n+2;i++)
    for(int j=n+1;j>=0;j--)
      c[j]=((j==0?0:c[j-1])-c[j]*i%mod+mod)%mod;
  for(int i=1;i<=n+2;i++){
    for(int j=0;j<=n+1;j++)cp[j]=c[j];
    for(int j=0;j<=n+1;j++)cp[j]=(cp[j]-(j==0?0:cp[j-1])+mod)*ksm(mod-i,mod-2)%mod;
    int res=1;
    for(int j=1;j<=n+2;j++){
      if(i==j)continue;
      res=res*(i-j+mod)%mod;
    }
    res=g[(1<<n)-1][i]*ksm(res,mod-2)%mod;
    for(int j=1;j<=n;j++)dp[j]=(dp[j]+cp[j]*res%mod)%mod;
  }
  for(int i=1;i<=min(k+1,n);i++)ans=(ans+dp[i]*C(k+1,i)%mod*fr[i]%mod)%mod;
  cout<<ans*fr[k]%mod*inv[n+k]%mod<<'\n';
  return 0;
}
```

---

## 作者：Corzica (赞：0)

先把概率化成数量和，总数肯定不难算吧。

然后显然是 dp，每一次选出一整个块内的东西对吧。

然后考虑一次能拿出来多少东西，这个可以 $O(n2^n)$ 递推出方案总数，大概就是枚举当前块的最后一个点。这很显然吧？

然后你要想分出来的块事实上是有一个重排的过程的，你现在拿出来的这么多只是在重排后是如此，但是重排前是不清楚的，还可能会因为有多种重排方式而重复计算。没有偏序关系的两个相邻块完全可以相互调换顺序而不影响结果，这就重复计算啦。

不难发现我们要使得所有块组成的 DAG 只被计算一次，那么我们给他一个唯一的拓扑序，就是按层把叶子全部剥离掉。想必能看到我题解的卷王您一定做过[这道题](https://www.luogu.com.cn/problem/AT_abc306_h)吧，那么只需要一次加若干个块的时候附带一个 $(-1)^{\text{块的数量}+1}$ 就好了呢。

总结一下，我们现在要维护两个数组 $f,g$，分别代表一个集合放在一个块内的方案数和一个集合划分成若干个**相互间没边**块的方案数，$f$ 数组转移比较简单，这边略过。$g$ 数组转移为 $g_{i,j}=\sum_{x\subset i}g_{i \oplus x,j-1}f_{x}[x \text{与} i \text{集合之间没边}]$，这个处理是 $O(3^nn)$。

后面这个没边的信息可以再最开始的时候枚举子集或者高维前缀和处理出来。

然后我们定义 $dp_{i,j}$ 为 $i$ 集合划分成 $j$ 个块的方案数，根据前面的容斥，转移式为 $dp_{i,j}=\sum_{x \subset i}\sum_{y=0}^j dp_{i \oplus x,j-y}g_{x,y}(-1)^{y+1}$。使用[这道题](https://www.luogu.com.cn/problem/CF1874E)的优化技巧，把 $dp_i,g_i$ 看成一个 $k+1$ 次的多项式，并且把 $g_{i,j}$ 乘上一个 $(-1)^{(j+1)}$，那么每一次的转移就是 $dp_{i,j}=\sum_{x \subset i} dp_{i \oplus x}g_{x}$，这种转移直接枚举子集就可以做完了呢。我们只需要插值 $n$ 个值，得到点值，就可以把 $dp$ 数组还原回去了呢。

最后再把这个每一种划分情况还原到题面中的拆分上，除以总的方案数，就得到答案了。


相必身为巨佬的您看完题解之后肯定能狠狠爆杀这道 D2T2 了呢，赛时喜提 10pts 的我简直输麻了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, p, q, a[(1 << 15) + 5], f[(1 << 15) + 5], g[(1 << 15) + 5][18], val[35], gg[(1 << 15 ) + 5], dp[(1 << 15) + 5], jie[55], ops[29], iinv, inv[55], kk;
const int mod = 1000000007;
inline int ksm(int p, int q = mod - 2) {
	int base = 1;
	while (q) {
		if (q & 1) base = 1ll * base * p % mod;
		q >>= 1;
		p = 1ll * p * p % mod;
	}
	return base;
}
inline int C(int p, int q) {
	if (p < 0 || q < 0 || p < q) return 0;
	return jie[p] * 1ll * inv[q] % mod * inv[p - q] % mod;
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m >> k;
	kk = k, k = n;
	for (int i = 1; i <= m; i++) {
		cin >> p >> q;
		a[(1 << (q - 1))] |= (1 << (p - 1));
	}
	for (int j = 1; j <= n; j++) {
		for (int k = 1; k < (1 << n); k++) {
			if ((k >> (j - 1)) & 1) {
				a[k] |= a[k ^ ((1 << (j - 1)))];
			}
		}
	}
	int flg;
	f[0] = 1;
	for (int i = 1; i < (1 << n); i++) {
		for (int j = 1; j <= n; j++) {
			if ((i >> (j - 1)) & 1) {
				if (!(a[(1 << (j - 1))] & (i ^ ((1 << (j - 1)))))) {
					f[i] = (f[i] + f[i ^ ((1 << (j - 1)))]) % mod;
				}
			}
		}
	}
	g[0][0] = 1;
	for (int i = 1; i < (1 << n); i++) {
		int flg = 1;
		for (int j = 1; j <= n; j++) {
			if ((i >> (j - 1)) & 1) {
				flg = j;
				break;
			}
		}
		for (int j = 1; j <= k + 1; j++) {
			for (int x = i; x; x = (x - 1)&i) {
				if ((!(a[x] & (i ^ x))) && (!(a[i ^ x] & x)) && ((x >> (flg - 1)) & 1)) {
					g[i][j] = (g[i][j] + f[x] * 1ll * g[i ^ x][j - 1] % mod) % mod;
				}
			}
		}
	}
	for (int i = 0; i < (1 << n); i++) {
		for (int j = 0; j <= k + 1; j += 2) {
			g[i][j] = mod - g[i][j];
		}
	}
	for (int i = 1; i <= k + 2; i++) {
		jie[0] = 1;
		for (int j = 1; j <= k + 1; j++) jie[j] = jie[j - 1] * 1ll * i % mod;
		for (int j = 0; j < (1 << n); j++) {
			gg[j] = 0;
			for (int x = 0; x <= k + 1; x++) {
				gg[j] = (gg[j] + jie[x] * 1ll * g[j][x] % mod) % mod;
			}
		}
		dp[0] = 1;
		for (int j = 1; j < (1 << n); j++) {
			dp[j] = 0;
			for (int op = j; op; op = (op - 1)&j) {
				if (!((a[j ^ op]&op))) {
					dp[j] = (dp[j] + dp[j ^ op] * 1ll * gg[op] % mod) % mod;
				}
			}
		}
		val[i] = dp[(1 << n) - 1];
	}
	memset(f, 0, sizeof(f));
	f[0] = 1;
	for (int i = 1; i <= k + 2; i++) {
		for (int j = k + 2; j >= 0; j--) {
			f[j] = f[j] * 1ll * (mod - i) % mod;
			if (j) f[j] = (f[j] + f[j - 1]) % mod;
		}
	}
	for (int i = 1; i <= k + 2; i++) {
		int inv = mod - ksm(i);
		gg[0] = f[0] * 1ll * inv % mod;
		for (int j = 1; j <= k + 1; j++) {
			gg[j] = (f[j] - gg[j - 1] + mod) * 1ll * inv % mod;
		}
		int mul = val[i];
		inv = 1;
		for (int j = 1; j <= k + 2; j++) {
			if (i != j) {
				inv = (inv * 1ll * (i - j) % mod + mod) % mod;
			}
		}
		mul = mul * 1ll * ksm(inv) % mod;
		for (int j = 0; j <= k + 1; j++) {
			ops[j] = (ops[j] + gg[j] * 1ll * mul) % mod;
		}
	}
	int ans = 0;
	jie[0] = 1;
	for (int i = 1; i <= 30; i++) {
		jie[i] = jie[i - 1] * 1ll * i % mod;
	}
	for (int i = 0; i <= 30; i++) {
		inv[i] = ksm(jie[i]);
	}
	for (int i = 1; i <= kk + 1; i++) {
		ans = (ans + ops[i] * 1ll * jie[i] % mod * C(kk + 1, kk + 1 - i) % mod * jie[kk] % mod ) % mod;
	}
	ans = ans * 1ll * inv[kk + n] % mod;
	cout << ans;
}
```

---


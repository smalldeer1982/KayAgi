# [省选联考 2024] 最长待机

## 题目描述

精灵程序员小 $\omega$ 和 小 $\aleph$ 拥有无限的寿命，因此在写代码之余，它们经常玩一些对抗游戏来打发时间。尽管如此，时间还是太多，于是它们发明了一款专用于消磨时间的游戏：最长待机。

为了了解最长待机的规则，首先要了解精灵们使用的编程语言 Sleep++ 的规则：

- 程序由 $n$ 个函数组成，第 $i(1 \le i\le n)$ 个函数具有种类 $e_i$ 和子函数编号序列 $Q_i = (Q_{i,1},Q_{i,2},\cdots,Q_{i,l_i})$。$Q_i$ 可以为空，此时 $l_i$ 为 $0$。

- $n$ 以及所有的 $e_i$ 和 $Q_i$ 可以由程序员任意给出，但它们需要满足以下所有条件：
  - $n\ge 1$；
  - $\forall 1 \le i \le n$，$e_i \in \{0, 1\}$；
  - $\forall 1 \le i \le n$，$Q_i$ 中元素两两不同且均为 $[i + 1, n]$ 中的整数；
  - $\forall 2 \le j \le n$，**恰好有一个 $Q_i(1 \le i \le n)$ 包含了 $j$**。

- **调用**函数 $i(1 \le i \le n)$ 时，按顺序执行如下操作：
  - 若 $e_i = 0$，令变量 $r_i$ 为 $1$；否则程序员需要立即为 $r_i$ 输入一个**正整数值**。
  - 若 $Q_i$ 为空，程序等待 $r_i$ 秒；否则重复以下操作 $r_i$ 次：
    * 按顺序**调用**编号为 $Q_{i,1},Q_{i,2},\cdots,Q_{i,l_i}$ 的函数。

- 若一个种类为 $1$ 的函数 $j$ 被调用多次，则其每次调用都需要输入 $r_j$。

- 我们认为，在函数调用中，除了“等待 $r$ 秒”之外的操作不消耗任何时间，即函数调用、运行和输入都在瞬间完成。因此，一个时刻内程序员可能输入多个数。

可以证明，调用任意一个 Sleep++ 程序的任意一个函数，无论如何设定输入，消耗的时间总是有限的。

“最长待机”的游戏规则如下：

- 小 $\omega$ 和 小 $\aleph$ 准备好各自的 Sleep++ 程序并选择各自程序中的一个函数。它们互相知晓对方程序的结构以及选择的函数。

- 在时刻 $0$，小 $\omega$ 和 小 $\aleph$ 同时调用自己选择的函数，游戏开始。

- 在时刻 $t$（$t \ge 0$），双方可以看到对方在时刻 $0$ 至 $(t - 1)$ 输入的所有数字，并相应调整自己在时刻 $t$ 输入的数字，但双方无法得知对方在时刻 $t$ 输入的数字。

- 函数调用先结束的一方输掉游戏，另一方胜利。两个调用同时结束算作平局。

小 $\omega$ 和 小 $\aleph$ 都是绝顶聪明的，在它们眼中，如果有一方存在必胜策略，那么这局游戏是不公平的。换言之，双方都不存在必胜策略的游戏是公平的。

小 $\omega$ 写了一个 $n$ 个函数的 Sleep++ 程序并进行了 $m$ 次操作，操作有以下两种：

- 操作一：给出 $k$，将 $e_k$ 修改为 $(1 - e_k)$；
- 操作二：给出 $k$，与小 $\aleph$ 玩一局“最长待机”，开始时小 $\omega$ 会调用自己的函数 $k$。

小 $\aleph$ 信奉极简主义，它希望对于每一局游戏设计出函数个数最少的程序，使得选择其中某个函数能让这局游戏是公平的。你能帮它求出最少所需的函数个数吗？

可以证明，小 $\aleph$ 总是能设计一个程序并选择其中一个函数，使得游戏是公平的。

## 说明/提示

**【样例 1 解释】**

- 对于前两次游戏，小 $\aleph$ 可以给出与小 $\omega$ 完全一致的程序并在游戏开始时调用函数 $1$。可以证明不存在函数个数更少的方案。

- 对于第三次游戏，小 $\aleph$ 可以给出一个仅包含一个种类为 $1$ 的函数的程序，并在游戏开始时调用函数 $1$。
  - 在时刻 $0$，小 $\omega$ 输入其程序中的 $r_2$，小 $\aleph$ 输入其程序中的 $r_1$。
    * 注意：$r$ 变量在小 $\omega$ 和小 $\aleph$ 的程序之间是独立的，不会互相影响。
  - 输入完成后，小 $\omega$ 的程序在时刻 $(r_2 +1)$ 结束，小 $\aleph$ 的程序在时刻 $r_1$ 结束。
  - 由于两人在时刻 $0$ 互不知道对方的决策，不能保证 $(r_2 + 1)$ 和 $r_1$ 的大小关系，故双方均不存在必胜策略，这局游戏是公平的。

**【样例 2】**

见附件中的 `sleep2.in/ans`。

该组数据满足特殊性质 AD。

**【样例 3】**

见附件中的 `sleep3.in/ans`。

该组数据满足特殊性质 BD。

**【样例 4】**

见附件中的 `sleep4.in/ans`。

该组数据满足特殊性质 D。

**【样例 5】**

见附件中的 `sleep5.in/ans`。

该组数据满足特殊性质 C。

**【子任务】**

对于所有测试数据，

- $1 \le n \le 5\times 10^5$，$1 \le m \le 2\times 10^5$；
- $\forall 1 \le i \le n$，$e_i\in \{0, 1\}$，$0 \le l_i <n$；
- $\forall 1 \le i \le n,1 \le j \le l_i$，$i < Q_{i,j} \le n$；
- $\forall 1 \le i \le n, 1 \le p < q \le l_i$，$Q_{i,p}\neq Q_{i,q}$；
- $\forall 2 \le j \le n$，恰好有一个 $Q_i(1 \le i \le n)$ 包含了 $j$；
- $\forall 1 \le j \le m$，$1 \le o_j \le 2$，$1 \le k_j \le n$。

| 测试点编号 | $n \le $ | $m\le $| 特殊性质 |
|:--:|:--:|:--:|:--:|
| $1\sim 2$ | $3$ | $24$ | 无 |
| $3$ | $80$ | $400$ | AD |
| $4$ | $80$ | $400$ | BD |
| $5\sim 6$ | $80$ | $400$ | D |
| $7$ | $3\times 10^5$ | $10^5$ | AD |
| $8$ | $3\times 10^5$ | $10^5$ | BD |
| $9\sim 10$ | $3\times 10^5$ | $10^5$ | D |
| $11$ | $3\times 10^5$ | $10^5$ | A |
| $12$ | $3\times 10^5$ | $10^5$ | BC |
| $13$ | $3\times 10^5$ | $10^5$ | B |
| $14\sim 15$ | $3\times 10^5$ | $10^5$ | C |
| $16\sim 17$ | $3\times 10^5$ | $10^5$ | 无 |
| $18\sim 19$ | $5\times 10^5$ | $2\times 10^5$ | A |
| $20$ | $5\times 10^5$ | $2\times 10^5$ | BC |
| $21$ | $5\times 10^5$ | $2\times 10^5$ | B |
| $22\sim 23$ | $5\times 10^5$ | $2\times 10^5$ | C |
| $24\sim 25$ | $5\times 10^5$ | $2\times 10^5$ | 无 |

特殊性质 A：保证

- 任意时刻 $e_1$ 均为 $0$；
- $\forall 2\le i \le n$，$l_i \le 1$；
- 操作二的 $k$ 均为 $1$。

特殊性质 B：保证

- 操作二的 $k$ 满足当时的 $e_k$ 为 $1$。

特殊性质 C：保证

- $\forall 2\le i \le n$，$i \in Q_{\lfloor \frac{i}{2}\rfloor}$；
- $\forall 1 \le i \le n$，序列 $Q_i$ 单调递增。

特殊性质 D：保证

- 操作二不超过 $10$ 个；
- 操作二的 $k$ 均为 $1$。

## 样例 #1

### 输入

```
3 6
0 2 2 3
0 0
0 0
2 1
1 3
2 1
1 3
1 2
2 1```

### 输出

```
3
3
1```

# 题解

## 作者：WYXkk (赞：47)

这篇“题解”实际上是用这题来引入无限序数的概念，并最终给出这题的弱化版本（不带修改）的解。

为了更好说明本题的需要，本题定义的序数的加法和乘法的顺序和正常的序数加法乘法是相反的。

因为我是数据结构低手，所以我并不知道如何把这个结论应用到正解。

---

根据定义，Sleep++ 程序的函数的调用关系形成了一棵有向树。

如果一个 Sleep++ 程序只有 $e=0$ 的函数，则所有函数的运行时间是某个固定的有限值，这个有限值也不难算出。

但是，一旦某个函数的 $e=1$，它本身以及所有直接或间接调用它的函数，由于输入值是任意的，于是运行的时间可以任意长。注意，任意长不是无限长，最终一定会停止。

题目的要求促使我们想一种办法比较两个函数的运行时间。

但是两个任意长怎么比较呢？无论其中一个多长，另一个总是可以更长。

---

最基本的问题是，一个 $e=1$ 的空函数需要的运行时间应该如何度量？

它并不是无穷大，最终一定会停止；它也不是有限的正整数，这个程序可以跑得比任意正整数还长。

这促使我们发明一个新的记号来代表它：$\omega$。$\omega$ 的含义即为“大于任意正整数的最小数”。

需要跑 $\omega$ 秒的意思是，输入一个任意正整数让 $\omega$ 坍缩到那个正整数。

---

$e=0$ 的非空函数按直觉来看总是应该表示各子函数按顺序加和。

于是我们可以构造出长度形如 $3+\omega$，$\omega+5+\omega+\omega+6$ 等的程序了。

$\omega$ 上各运算律是否仍然成立还是未知的，所以别急着化简。

---

既然有了 $\omega$，那有没有比 $\omega$ 更慢的呢？比如……$1+\omega$？

它的含义很明显，先等 $1$ 秒，然后输入一个数让 $\omega$ “坍缩”到那个数，最后结束。

这当然是比 $\omega$ 要大的：你有时间看一眼对方声明的数，自己声明更大的就行了。

---

这里你会开始注意到新运算的一个不寻常之处：加法不再交换。

考虑 $\omega+1$。它的含义是，先输入一个数让 $\omega$ “坍缩”到那个数，等那么多秒，再等一秒，才结束。

问题是这和多输入 $1$ 没有任何区别！于是 $\omega+1=\omega<1+\omega$。

这说明，高阶项会吸收掉右侧的低阶项。

---

有了 $1+\omega$ 自然就能有 $2+\omega,3+\omega,4+\omega,\cdots$，最终，我们会到达 $\omega+\omega$，或 $2\omega$。

$2\omega$ 的含义也是很显然的：你可以声明一次，过那么久，然后声明第二次，再过那么久，结束。

以此类推，还可以有 $3\omega,4\omega,\cdots$，最终到达 $\omega^2$。

一个 $\omega^2$ 相当于一个二阶声明，它声明了接下来我会进行几次声明（，还可能再附带一些常数）。

---

同样很自然地，$e=1$ 的非空函数，其结果应该是各子函数按顺序加和，最后左乘 $\omega$。

带入游戏推断一下以后，你会发现，$\omega(3+2\omega)=\omega^2$。

这是因为，进行左边的 $\omega$ 对应的二阶声明后，虽然看起来获得了两倍的声明次数还多了一点常数，但是你本来就可以声明那么多次数，于是就和 $\omega^2$ 没有区别了。

---

有了 $\omega^2$ 再套一层就能有 $\omega^3$，相当于一个三阶声明，声明接下来使用二阶声明的次数（，可能附带几次一阶声明和一些常数）。

同样就能有 $\omega^4,\omega^5$，等等。这样套下去可以得到任意次数。

虽然已经和本题没关系了，不过这样就能达到 $\omega^\omega$，相当于第一步进行元声明，声明想要获得一个多少阶的声明。

---

题目的机制已经完全搞清楚了：

- 对于空函数，$e=0$ 的时长是 $1$，$e=1$ 的时长是 $\omega$
  
- 对于非空函数，$e=0$ 的时长是其子函数时长按顺序相加，$e=1$ 的时长是前者左乘 $\omega$
  
- 对于加法，高阶项会吸收右侧的低阶项；对于左乘 $\omega$，只有阶数信息会被保留
  

按照这个步骤计算一遍就能得到任意函数的运行时长。

---

题目的要求是构造一个函数最少的程序让游戏公平。

这也很简单。我们知道升阶只会保留阶数信息，于是每一项最快都由直接升阶若干次得到。那么 $\sum a_i\omega^i$ 就至少需要 $1+\sum \max(i,1)a_i$ 个函数，除了只有系数为 $1$ 的一项的特殊情况以外。

---

重申：为了更好说明本题的需要，本题定义的序数的加法和乘法的顺序和正常的序数加法乘法是相反的。

重申2：因为我是数据结构低手，所以我并不知道如何把这个结论应用到正解。我在讨论区看到了一个把这个做法应用到正解的方法，如有兴趣可以[查看](https://www.luogu.com/article/4ox8pky1)。

---

拓展阅读：

[【中字】ω步杀，无限象棋的非凡现象](https://www.bilibili.com/video/BV1544y1A7TE)

[【中字】ω^3、ω^4、ω^ω步杀……关于持续最久的无限象棋对局的研究](https://www.bilibili.com/video/BV1M642137Bx)

这两个视频讨论的 $\omega$ 步杀是我看到过的最好的关于“$\omega$ 是什么”的解释，对于理解之前的说明有一定帮助，视频本身也很有趣。

---

## 作者：寻逍遥2006 (赞：24)

写在前面：感觉这道题目的难点主要在于前面的分析，最终的代码实现比较经典。如果下文中有不严谨或者错误的分析，请戳我。

发现 Sleep++ 的所有函数构成了一棵以 $1$ 为根的树，可以在 $e=1$ 的节点选择遍历子树若干次，而 $e=0$ 的节点能且只能将子树遍历 1 次。

首先我们考虑什么情况下游戏才是公平的。

第一种情况就是双方必然平局，这种情况只会在双方都不能执行操作的情况下发生。否则，只要有一方可以进行操作，则他必然可以保证不**必然平局**，对于某种平局的状态，他可以增加他的某一次操作，结束时间就不同了。

第二种情况就是双方无法确定谁能赢，这种情况至少需要**必然**出现一次**同时进行**决策。只有在同时决策的情况下，才有可能出现不能确定的情况，否则靠后决策的一方完全可以通过决策来让自己的结束时间延后。

在第二种情况下，我们认为这样的同时决策必然是第一次决策。如果不是，在这一次决策之前的分析可以套用第一种情况，就不是**必然**同时操作了。

但是“第一次决策是同时决策”这个条件并不充分，例如如果小 $\omega$ 在第一次决策之后还能有第二次决策，而小 $\aleph$ 没有，则小 $\omega$ 可以在第二次操作的时候超过小 $\aleph$，无论第一次操作的时候谁的时间更长。

也就意味着，两个人在第一次同时决策之后，后面的决策应该出现一个“轮流超越”直到双方都没有剩余的决策。这样才能够使得第一次决定的胜负能够保留到最后。

这里的轮流超越可以举一个例子：例如小 $\omega$ 和小 $\aleph$ 拿到的都是如下图的一棵树（下文中图片均以加粗黑框代表 $e=1$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/bhtky957.png)

假设第一次在 $2$ 号点，小 $\omega$ 输入的数比小 $\aleph$ 输入的数大；则小 $\aleph$ 优先进入 3 号点的决策，他会选择一个比小 $\omega$ 到下一次决策前的等待时间要大的数（否则相当于没有在 3 号点进行决策，必然不优）；然后小 $\omega$ 再进入 3 号点的决策，选择一个比小 $\aleph$ 到下一次决策前的等待时间要大的数；4 号点是类似的，最后小 $\omega$ 的程序运行时间更长。

反之，小 $\aleph$ 在第一次输入的时候如果比小 $\omega$ 要大，则是小 $\aleph$ 获胜。

所以这样的游戏就是公平的。

现在我们需要分析怎样的决策之间是能够实现超越的：

我们记一个 $e=1$ 的决策点的决策等级 $T$ 为其所有子孙节点中 $e=1$ 的决策点的决策等级（若没有这样的子孙就为 $0$）的最大值 $+1$。

例如对于下面这棵树，2 号点和 4 号点的决策等级为 $1$，3 号点的决策等级为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/r1zphb5m.png)

由此我们可以得到如下结论：
1. 相同等级的决策点等价.
2. 一个决策点可以在先操作的情况下超越**任意个**操作等级比它小的决策点。
3. 一个决策点可以在后操作的情况下超越一个操作等级等于它的决策点后面接上任意个操作等级比它小的决策点。

> 证明使用数学归纳法：\
> 在 $T=1$ 的时候显然成立。\
> 假设对于 $T<k$ 成立，我们尝试证明在 $T=k$ 的时候成立。\
> 对于第一个结论，它可以根据输入变成任意量级的 $k-1$ 级决策点，因为 $k-1$ 级决策点两两等价，所以 $k$ 级决策点两两等价。\
> 对于第二个结论，输入时至少输入 $n+O(1)$，其中 $n$ 为需要超越的比它小的决策点的数量，也就意味着我们是至少 $n+O(1)$ 个 $k-1$ 级的决策点和对面的 $n$ 个 $< k$ 级的决策点，显然是可以超越的。\
> 对于第三个结论，由于是对面先操作，所以他操作完之后就被拆分成了若干操作等级 $< k$ 的决策点，和第二个结论等价。

我们考虑按照遍历顺序把小 $\omega$ 和小 $\aleph$ 遇到的决策点等级序列拉出来。因为三结论，所以一个决策点的前面有更大的决策点，这个决策点就是没有意义的。

这也就意味着我们是需要取出这样个序列的前缀最大值（非严格），只有这些值才是有意义的，则游戏公平的充要条件就是：第一次决策同时进行，且对应的决策序列相同。

例如对于下图，得到的决策序列就是 $1,2,1$，而有意义的决策序列就是 $1,2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lwiymerl.png)

这也就意味着我们只需要求出第一次决策开始的时间 $tim$，以及决策序列 $a_1,a_2 \dots a_{len}$，即可得到小 $\aleph$ 对应的答案：$tim+\sum\limits_{i=1}^{len}a_i+[tim+len\ge 2]$。

其中第一项代表前面等待的时间对应的节点数，第二项代表对应的决策序列的每一个决策点的最小的树的大小之和，第三项代表如果前面想生成的是一片森林，我们就需要一个根节点将其连接起来。

如果每一次 $O(n)$ 暴力求解，可以做到 $O(qn)$，可以获得 $24$ 分的成绩。

如果进行一定的剪枝优化，可以冲过去一些点，得到 $48$ 分。

现在我们想知道如何快速维护这些信息。

对于前面需要等待的时间，我们只需要知道子树内第一个决策点之前有多少个叶子节点即可，将树拍成 dfn 序，这个是可以用数据结构 $O(n+m\log n)$ 维护的。

重点是如何求出 $len$ 以及 $\sum\limits_{i=1}^{len}a_i$。

考虑到如果直接暴力维护我们上面设计的“决策等级”，需要树剖+二分之类的东西，但是这样会破坏了游戏过程中遍历的顺序，我们就不能够通过我们维护的序列直接提取前缀最大值序列了。

所以我们想要在不破坏 dfn 序的情况下维护一个能够代替“决策等级”的信息。

由于不破坏 dfn 序，所以我们所有的修改只能够基于子树，不能基于链了。

我们记 $val_i$ 表示 $i$ 节点的父亲到根的路径上的 $e=1$ 的节点的数量，$[L_i,R_i]$ 为 $i$ 的子树对应 dfn 序上的区间。则一个节点的决策等级 $T=\max\limits_{j=L_i}^{R_i}val_j-val_i$。

而每一次修改 $e$，改变的 $val$ 都是一次区间 $\pm 1$，所以是很好维护的。

现在再来考虑求解。

对于 $e_k=1$ 的情况，我们可以直接求出决策等级。

对于 $e_k=0$ 的情况，发现所有 $val_i=val_k$ 的点在 $k$ 的子树内形成了一个包含根的连通块，而这个连通块内所有 $e_i=1$ 的节点都是这个连通块的叶子。

这也就意味着，我们按照 $val_k$ 分割 $[L_k,R_k]$ 这段序列，我们得到的每一段刚好对应一个决策点，而且这个决策点对应的决策等级就是这段区间的最大值 $-val_k$。

由于 $val_k$ 必然是 $[L_k,R_k]$ 中 $val$ 的最小值，所以我们在线段树的每一个节点维护其对应区间以区间最小值 $min$ 分割得到的区间序列的区间最大值序列的前缀最大值序列的长度以及权值和。

具体的，如果所有区间的最小值位置形如 $\dots min \dots min \dots min \dots$，我们忽略掉第一个 $min$ 的前面以及最后一个 $min$ 的后面这两个区间，改成维护这样个 $min$ 的位置。

考虑如何合并两个区间的信息，如果这样个区间的最小值不同，可以直接保留最小值更小的一遍；否则，左部是不会受到右部的影响的，中间需要单独加入左部分最后一个 $min$ 和右部分第一个 $min$ 之间的区间，而对于右部分，我们只保留其大于等于左部序列最大值的一段后缀。具体的，这个部分和[楼房重建](https://www.luogu.com.cn/problem/P4198)类似，可以使用兔队线段树来维护。

具体的，实现一个函数 `query(int mn,int val,int pos)` 表示在 $pos$ 节点对应区间内，以 $mn$ 作为最小值（$mn\le$ 当前区间最小值）分割序列得到的前缀最大值序列中值 $< val$ 的前缀的长度以及权值和。这个可以用简单的线段树上二分做到单次 $O(\log n)$。

每一次进行合并的时候都需要调用 `query` 函数一次，所以区间 $\pm 1$ 和区间查询时间复杂度均为 $O(\log^2n)$。

实现过程中可能会有一些细节：例如由于定义的 $val$ 是从父亲到根的，所以需要给每一个叶子加一个儿子，这样不影响答案且更方便处理，唯一的问题是会因此多一个 $2$ 倍的常数，可能需要稍微卡常。

最终时间复杂度为 $O(n\log n+m\log^2n)$。

[LOJ 提交记录](https://loj.ac/s/2023820)

---

## 作者：PosVII (赞：19)

### 前言

------------

省选 100+12+0+100+0+0=212 

小丑分数回归 whk 课了。所以没时间写代码，可能会在这两天把代码写完。

upd：写完了。为什么我 3.7 的题解比 3.10 的题解审的要晚啊，急眼了。。。

这题本质上还是个套着 adhoc 皮的 DS。

$O(m \log^2 n)$ 做法。

@[Linkwish](https://www.luogu.com.cn/user/408180) 与我共同 AC 此题！！！！

### 正文

------------

我们视一条长度为 $y$ 的全是 $1$ 的链为 $x^y$。

结论：

1. $x^y = x \times (nx^{y-1})$（$n$ 为常数），因为此时我们并不能保证最上面的那个 $1$ 中谁输入的 $x$ 更大，所以 $n$ 的影响只是常数级别，可以忽略不计。
1. $x^y+x^{y-1}=(x+1) \times x^{y-1}=x^y$，后面的 $x^{y-1}$ 对式子只有常数上的影响，所以可以忽略不计。
1. $x^{y-1}+x^y>x^y$，因为左式的 $x^{y-1}$ 和右式的 $x^y$ 同时输入，所以可以保证左式的 $x^y$ 比右式大，不能忽略。

考虑 adhoc 部分，我们根据上述结论，对询问的情况分类讨论：

1. $e_{k}=1$，所以此时的答案和 $k$ 所在的子树中，与 $k$ 的 $1$ 最多的链的 $1$ 的数量有关。
1. $e_{k}=0$，此时我们从 $k$ 向下遍历直到遍历到第一个 $1$ 或者叶子结点的 $0$，把它的答案（根据 $e_k = 1$ 部分的答案）从左到右排序，形成一个序列，它的答案就是不能被忽略的数的和，即那些左边没有数字比它大的数的和。

此时就可以 $O(nm)$ 暴力了，可以结合我下面给出的暴力理解。

```cpp
#include<bits/stdc++.h>
template<typename G>inline void read(G&x) {G f=1;x=0;char ch=getchar();while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();if(ch=='-') f=-1,ch=getchar();while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();x*=f;}
using namespace std;
const int MAXN=2e5+5;
int n,m;
bool c[MAXN];
vector<int> G[MAXN],vec;
int bfs(int u,int dep) {
	int res=dep;
	for(auto v:G[u]) res=max(res,bfs(v,dep+c[v]));
	return res;
}
void dfs(int u) {
	if(c[u]) {
		vec.emplace_back(bfs(u,1));
		return;
	}
	else if(G[u].empty()) vec.emplace_back(0);
	for(auto v:G[u]) dfs(v);
}
int op,x;
signed main() {
	read(n),read(m);
	for(int i=1,k,v;i<=n;++i) {
		read(c[i]),read(k);
		for(int j=1;j<=k;++j) {
			read(v);
			G[i].emplace_back(v);
		}
	}
	while(m--) {
		read(op),read(x);
		if(op==1) c[x]^=1;
		else {
			vec.clear(),dfs(x);
			if(vec.size()==1) printf("%d\n",vec[0]+(vec[0]==0));
			else {
				int las=-1,ans=0,tot=0;
				for(auto i:vec) {
					if(i>=las) {
						if(i==0) ++ans;
						else ans+=i;
						++tot,las=i;
					}
				}
				printf("%d\n",ans+(tot!=1));
			}
		}
	}
	return 0;
}
```

发现直接记录每个 $1$ 点的答案是难以修改和查询的，考虑对其进行转化，设 $ans_i$ 是 $i$ 点到根的路径上 $1$ 的数量，发现 $e_k=1$ 的答案就是 $max^r_l\ e_i-e_{k}+1$。$ans_i$ 的维护是平凡的，线段树即可。

如果按上述的方法求 $e_k=0$ 的答案，这是复杂且非常不可做的。我们发现，如果把叶子节点强行设为 $1$，此时从 $k$ 往下走找到的每一个 $e_x = 1$ 的 $ans_x$ 都是相同的，所以我们可以把答案变成在 $[l,r]$ 的 dfs 序上找到若干个最小的 $ans_i$ 把它分割成若干个区间，而得到的序列就是这若干个区间各自的最大值。发现这个区间的分割是可以合并的，所以考虑使用兔队线段树维护。

时间复杂度 $O(m \log^2 n)$，常数一般，应该能过。

upd: 过了，代码如下：

```cpp
#include<bits/stdc++.h>
template<typename G>inline void read(G&x) {G f=1;x=0;char ch=getchar();while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();if(ch=='-') f=-1,ch=getchar();while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();x*=f;}
using namespace std;
#define int long long
const int MAXN=5e5+5;
int n,m;bool c[MAXN];
int L[MAXN],R[MAXN],dep[MAXN],idx[MAXN],cnt;
struct node {
	int k,pre,suf,v,ans,mx,tot;
}d[MAXN<<2];
struct Fenwick_Tree {
	int n,d[MAXN];
	void init(int x) {n=x;}
	void add(int x,int y) {for(int i=x;i<=n;i+=(i&-i)) d[i]+=y;}
	int query(int x) {int res=0;for(int i=x;i;i-=(i&-i)) res+=d[i];return res;}
}BIT;
struct Segment_Tree {
	bool leaf[MAXN<<2];
	int lazy[MAXN<<2];
	void pushdown(int p) {
		if(lazy[p]) {
			modify(p<<1,lazy[p]);
			modify(p<<1|1,lazy[p]);
			lazy[p]=0;
		}
	}
	pair<int,int> Merge(node&x,int p) {
		if(d[p].mx<x.mx) return make_pair(0,0);
		if(leaf[p]) {
			x.ans+=d[p].ans,++x.tot;
			return make_pair(d[p].ans,d[p].ans);
		}pushdown(p);
		if(d[p<<1].mx>=x.mx) {
			auto las=Merge(x,p<<1);
			if(x.v<d[p<<1|1].v) {
				if(las.first==las.second) x.ans-=las.first,--x.tot;
				las.first=max(las.first,d[p<<1|1].mx),las.second=max(las.second,d[p<<1|1].mx);
				if(las.first==las.second) x.ans+=las.first,++x.tot;
				return las;
			}
			else {
				if(x.v==d[p<<1].v) {
					x.ans+=(d[p].ans-d[p<<1].ans),x.tot+=(d[p].tot-d[p<<1].tot);
					las.first=d[p<<1|1].suf,las.second=max(las.second,d[p<<1|1].mx);
				}
				else {
					if(las.first==las.second) x.ans-=las.first,--x.tot;
					las.first=max(las.first,d[p<<1|1].pre),las.second=max(las.second,d[p<<1|1].pre);
					if(las.first==las.second) x.ans+=las.first,++x.tot;
					x.ans+=d[p].ans,x.tot+=d[p].tot;
					las.first=d[p<<1|1].suf,las.second=max(las.second,d[p<<1|1].mx);
				}
				return las;
			}
		}
		return Merge(x,p<<1|1);
	}
	node merge(node x,int p) {
		if(x.v<d[p].v) {
			if(x.suf==x.mx) x.ans-=x.suf,--x.tot;
			x.suf=max(x.suf,d[p].mx),x.mx=max(x.mx,d[p].mx);
			if(x.suf==x.mx) x.ans+=x.suf,++x.tot;
			return x;
		}
		else if(x.v==d[p].v) {
			if(x.mx>d[p].pre) {
				Merge(x,p);
				x.suf=d[p].suf,x.mx=max(x.mx,d[p].mx);
			}
			else {
				if(x.suf==x.mx) x.ans-=x.suf,--x.tot;
				x.ans=x.ans+d[p].pre+d[p].ans,x.tot=x.tot+1+d[p].tot;
				x.suf=d[p].suf,x.mx=max(x.mx,d[p].mx);
			}
			return x;
		}
		else {
			if(x.mx>d[p].pre) {
				x.ans=0,x.tot=0,x.suf=d[p].suf,x.v=d[p].v,x.k=d[p].k;
				Merge(x,p);
				x.pre=max(x.mx,d[p].pre),x.mx=max(x.mx,d[p].mx);
				return x;
			}
			else return d[p];
		}
	}
	void modify(int p,int c) {
		lazy[p]+=c;
		d[p].ans+=c*d[p].tot,d[p].v+=c,d[p].mx+=c,d[p].pre+=c,d[p].suf+=c;
	}
	void modify(int l,int r,int ql,int qr,int p,int c) {
		if(l>=ql&&r<=qr) {
			modify(p,c);
			return;
		}
		int mid=(l+r)>>1;pushdown(p);
		if(ql<=mid) modify(l,mid,ql,qr,p<<1,c);
		if(qr>mid) modify(mid+1,r,ql,qr,p<<1|1,c);
		d[p]=merge(d[p<<1],p<<1|1);
	}
	void modify(int l,int r,int k,int p) {
		if(l==r) {
			d[p].v=1e9,d[p].mx=-1e9;
			if(c[idx[l]]) d[p].v=d[p].mx=BIT.query(l);
			d[p].k=l,d[p].ans=d[p].suf=d[p].mx,d[p].pre=-1e9,d[p].tot=1;
			return;
		}
		int mid=(l+r)>>1;pushdown(p);
		if(k<=mid) modify(l,mid,k,p<<1);
		else modify(mid+1,r,k,p<<1|1);
		d[p]=merge(d[p<<1],p<<1|1);
	} 
	int query(int l,int r,int ql,int qr,int p) {
		if(l>=ql&&r<=qr) return d[p].mx;
		int mid=(l+r)>>1;pushdown(p);
		if(qr<=mid) return query(l,mid,ql,qr,p<<1);
		if(ql>mid) return query(mid+1,r,ql,qr,p<<1|1);
		return max(query(l,mid,ql,qr,p<<1),query(mid+1,r,ql,qr,p<<1|1));
	}
	void query(int l,int r,int ql,int qr,int p,node&res) {
		if(l>=ql&&r<=qr) {
			if(l==ql) res=d[p];
			else res=merge(res,p);
			return;
		}
		int mid=(l+r)>>1;pushdown(p);
		if(ql<=mid) query(l,mid,ql,qr,p<<1,res);
		if(qr>mid) query(mid+1,r,ql,qr,p<<1|1,res); 
	}
	void build(int l,int r,int p) {
		if(l==r) {
			leaf[p]=1;
			d[p].v=1e9,d[p].mx=-1e9;
			if(c[idx[l]]) d[p].v=d[p].mx=dep[idx[l]];
			d[p].k=l,d[p].ans=d[p].suf=d[p].mx,d[p].pre=-1e9,d[p].tot=1;
			return;
		}
		int mid=(l+r)>>1;
		build(l,mid,p<<1),build(mid+1,r,p<<1|1);
		d[p]=merge(d[p<<1],p<<1|1);
	}
}SGT;
vector<int> G[MAXN],leaf;
void dfs(int u) {
	dep[u]+=c[u];
	L[u]=++cnt,idx[cnt]=u;
	for(auto v:G[u]) dep[v]=dep[u],dfs(v);
	R[u]=cnt;
	if(G[u].empty()) leaf.emplace_back(L[u]);
	if(c[u]) BIT.add(L[u],1),BIT.add(R[u]+1,-1);
}
int fa[MAXN],op,x;
signed main() {
	read(n),read(m);BIT.init(n);
	for(int i=1,j,k;i<=n;++i) {
		read(c[i]),read(k);
		while(k--) {
			read(j);fa[j]=i;
			G[i].emplace_back(j);
		}
	}
	dfs(1);
	SGT.build(1,n,1);
	while(m--) {
		read(op),read(x);
		if(op==1) {
			c[x]^=1;
			SGT.modify(1,n,L[x],1);
			if(c[x]) {
				SGT.modify(1,n,L[x],R[x],1,1);
				BIT.add(L[x],1),BIT.add(R[x]+1,-1);
			}
			else {
				SGT.modify(1,n,L[x],R[x],1,-1);
				BIT.add(L[x],-1),BIT.add(R[x]+1,1);
			}
		}
		else {
			int val=BIT.query(L[fa[x]]);
			node ans;SGT.query(1,n,L[x],R[x],1,ans);
			int l=lower_bound(leaf.begin(),leaf.end(),L[x])-leaf.begin(),r=upper_bound(leaf.begin(),leaf.end(),R[x])-leaf.begin()-1;
			int ll=l,rr=l-1;
			while(l<=r) {
				int mid=(l+r)>>1;
				if(SGT.query(1,n,L[x],leaf[mid],1)<=val) l=mid+1,rr=mid;
				else r=mid-1;	
			}
			if(leaf[rr]==R[x]) printf("%lld\n",rr-ll+1+(rr-ll!=0));
			else printf("%lld\n",ans.ans+(rr-ll+1)-ans.tot*val+(ans.tot+rr-ll!=0));
		}
	}
	return 0;
}
```

---

## 作者：Acoipp (赞：7)

## 分析

这道题目主要是涉及到无限的概念，因此我们尝试抽丝剥茧并最终简化为一个形式化的问题。

### 最简单的部分

首先，有一个很显然的性质，如果询问的点 $u$ 子树中的所有 $e$ 都等于 $0$，那么等待的时间固定，我们为了满足公平，就只有构造出来一个等待时间相同的函数，并且不能有自己输入的变量。

具体而言，设等待 $t$ 秒，那么我们设计的树就需要有 $t$ 个叶子节点，答案显然是 $t+[t \ge 2]$。

当然，这道题并没有这部分分。

### 带有输入的数字

从最简单的出发，如果他的函数没有可供选择的 $1$，我的函数有，那我就可以用这个 $1$ 来拉开与他的差距，他就不能够超过我，我必胜，这就是不可以出现的。

那如果他有一个 $1$，而我也恰好只有一个 $1$，但是他的那个 $1$ 前面经过了 $5$ 秒，我的 $1$ 前面经过了 $6$ 秒，那我就可以看到他输入的数字，进而确保自己胜利，我必胜，反过来同理，因此我们得到：

> 如果其中一者有 $1$，另一者也必须有 $1$ 并且两者第一个 $1$ 之前经过的时间必须相同。

这是必要条件，但是充分条件还需要经过一些推导才能得到，接下来继续。

如果他在经过一个 $1$ 之后有再次决策的机会，而我在经过一个 $1$ 之后就没有再次决策的机会了，那我必败，这也是不行的。

$1 \to 2 \to 3$ 这棵树，其中 $e_1=e_2=1,e_3=0$，那么他在 $e_1$ 做出决策之后，还有 $e_2$ 第二次决策的机会，他可以根据我的输入直接调整他的程序运行的时间，他就必胜了。

那么我们继续递推，就会发现：

> 如果树是一条链的话，那么他的 $1$ 的个数必须等于我的 $1$ 的个数。

### $e_1=1,\forall opt=2,k=1$

考虑树不是一条链，B 性质怎么做，方便起见，我们可以看作所有 $k$ 都等于 $1$。

这个时候从根节点就开始有 $e=1$ 了，考虑把所有 $e_i=0$ 的节点忽略，最终树可以拆分成若干条链。（因为非叶子节点的 $e_i=0$ 没用，叶子节点的 $e_i=0$ 能够被 $e_j=1$ 的节点决定执行多少次，所以带来的影响只是常数，所以也没用）

那么显然，只有最长的那条链有用，设其链长为 $len$，答案就是 $len$。

### 证明  

首先，设一个 $e_i=0$ 输入的数为 $1$，$e_i=1$ 输入的数为 $x$，那么我们就有 $x+1=x$，因为此时两个 $x$ 同时输入，不知道大小关系，就算后面再等待 $1$ 秒也没有区别，就等于让前面一个 $x$ 减 $1$ 了。

但是 $1+x>x$，因为此时 $1$ 和 $x$ 同时运行，左边的 $x$ 可以看到右边的 $x$ 输入的值，所以左边一定大于右边。

那么有 $1x$ 就肯定有 $2x$，$2x$ 可以表示为具有两个 $e_i=1$ 的函数，但是这两个 $e_i=1$ 并不是链上的关系，而是并列的关系，即形如 $1 \to 2,1 \to3$ 这棵树 $2$ 和 $3$ 的关系。

还有就是 $x+x=2x$ 和 $x$ 个 $2$ 相加是不一样的东西（尽管写出来都是 $2x$），并且如果一个常数乘上 $x$ 比如 $kx$，如果 $k$ 能够被其他 $x$ 所决策/管辖，那么 $kx=x$，对于 $x$ 的若干次项都满足这个条件；否则 $kx>x$。

进而就有 $x^2,x^3,x^4$ 这种说法，考虑这种说法是什么意思 $x^2$ 代表要执行 $x$ 次输入 $x$ 的运行程序，容易发现，$x+x^2=x(1+x) > x^2$，但是 $x^2+x=x(x+1)=x^2$，依次类推，高次项会吸收右边的低次项，这个定理对于 $x^k(1 \le k)$ 都有用。

那么我们考虑一个节点他的 $x$ 值是多少，首先他自己如果是 $e_i=1$，那么他就左边乘上一个 $x$，如果他有子树，那答案就是 $x(\sum_{v \in son_u}A_v)$，$A_v$ 是一个关于 $x$ 的多项式。

如果 $e_i=0$ 那么他的 $x$ 值就不需要乘上左边的那个 $x$。例如 $x(1+2x+3+5x^2)=x^3$，我们可以看作 $x$ 个 $1+2x+3+5x^2$ 相加的结果，那最高此项显然就是 $5x^3$，（根据前面的如果 $k$ 能够有一个 $x$ 决策管辖，那么 $k$ 没用）所以这个等式成立。

当然如果 $e_i=0$，答案就是 $1+2x+3+5x^2$，因为根据前文所说高次项会吸收掉右边的低次项，所以答案变化为 $1+2x+5x^2$，但是这里为什么不等于 $x^2$ 呢，因为这里他自己没有决策（根据前文 $k$ 不被任意一个 $x$ 管辖所以 $k$ 有效），并且这三项必须同时决策才能确保游戏的公平，比如如果我的答案是 $1+2x+5x^3$ 就不行，因为 $x^3$ 严格大于 $x^2$。

那么证明到这里就很显然了，因为根节点为 $1$，所以答案就是他儿子的最高此项乘上 $x$，递归下去就是最长链的长度。

### 扩展

如果 $e_i=0$，这个在上面的证明中也提到过了，就是子节点的次数拿出来，用高次项消去低次项，但是需要保证次数非严格递增，然后设一共有 $u$ 项，次数和是 $s$，在第一次决策前等待 $t$ 秒，答案就是 $t+s+[u+t \ge 2]$。（不要合并同类项）

补充：根据证明容易得到 $e_i=1$ 的话，$A_i$ 一定只有一项，并且次数为 $1$。

综上 $e_i=1$ 的问题很好解决，接下来我们解决 $e_i=0$ 的问题。

$e_i=0$ 暴力很好做，就是从 $i$ 往下搜索到每个 $e_u=1$，然后把 $A_u$ **依次**加起来再用高次项消去低次项就可以了，这样的做法不足以通过此题，因此我们得到了更好的一个做法。
 
## 处理

设 $p_i$ 表示 $i$ 到根节点的 $e=1$ 的数量，那么如果 $e_u=1$，那么答案就是 $\max_{v \in sonall_u}{p_v-p_u+1}$ 再加上一些前面等待的时。如果 $e_u=0$，我们可以发现，只考虑 $e_v=1$ 的节点 $v$ 在 dfs 序 $[l_u,r_u]$ 上的映射（$[l_u,r_u]$ 是 $u$ 子树在 dfs 序上的区间），那么一定是 $\min\dots \min \dots \min \dots$ 的形态（$\min$ 是在 $p_{l_u \sim r_u}$ 之间的最小值，但是要去掉所有 $e_i=0$ 的 $i$），此时 $\min=p_u+1$（显然可以证明），于是答案就是把所有 $\min$ 到下一个 $\min$ 或者 $r_u$ 中间的最大值拿出来，每个值都要减去 $p_u$（这是去掉 $u$ 到根节点上 $1$ 造成的影响，去掉影响之后答案就是 $A_i$ 的次数了），形成一个序列 $a$，对这个序列再进行高次项消去低次项的操作就可以了。

容易发现这个东西是可以合并的，然后每次使用线段树维护这个序列消去之后的一些信息就可以了，这一部分不是重点就不展开讲，可以参见 [P4198 楼房重建](https://www.luogu.com.cn/problem/P4198) 类似的处理方式。

## 代码

代码如下，常数偏大，时间复杂度为 $O(m \log^2 n)$（写得如果不够优雅有可能会 TLE）：

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
#define ll long long
#define N 500005

namespace IO{
	inline char nc(){
		static char buf[1000000],*p=buf,*q=buf;
		return p==q&&(q=(p=buf)+fread(buf,1,1000000,stdin),p==q)?EOF:*p++;
	}
	inline ll read(){
		ll res = 0,w = 1;
		char c = nc();
		while(c<'0'||c>'9')w=(c=='-'?-1:w),c=nc();
		while(c<='9'&&c>='0')res=res*10+c-'0',c=nc();
		return res*w;
	}
	char obuf[1<<21],*p34=obuf; 
	inline void pc(char c){ 
		p34-obuf<=(1<<20)?(*p34++=c):(fwrite(obuf,p34-obuf,1,stdout),p34=obuf,*p34++=c); 
	} 
	inline void write(ll x){ 
		if(x>9) write(x/10); 
		pc(x%10+'0'); 
	}
}
using namespace IO;
using namespace std;

vector<ll> op[N];
ll n,m,i,e[N],x,y,dfn[N],ot[N],dtot,nid[N],leaf[N],a[N],sta[N],top;

struct SGT{
	struct node{
		ll mx,mn,tag,len,ls,rs,lid,rid,mid,sum;
	}tr[N<<2],temp;
	inline void pushtag(ll p,ll c){
		tr[p].mx += c,tr[p].mn += c,tr[p].tag += c,tr[p].ls += c,tr[p].rs += c,tr[p].mid += c,tr[p].sum += tr[p].len*c;
	}
	inline void pushdown(ll p){
		pushtag(2*p,tr[p].tag),pushtag(2*p+1,tr[p].tag);
		tr[p].tag = 0;
	}
	inline ll query_min(ll l,ll r,ll s,ll t,ll p){
		if(l<=s&&t<=r) return tr[p].mn;
		if(tr[p].tag) pushdown(p);
		ll ans = 0x3f3f3f3f;
		if(l<=(s+t)/2) ans=min(ans,query_min(l,r,s,(s+t)/2,2*p));
		if(r>(s+t)/2) ans=min(ans,query_min(l,r,(s+t)/2+1,t,2*p+1));
		return ans;
	}
	inline ll query_max(ll l,ll r,ll s,ll t,ll p){
		if(l>r) return -1;
		if(l<=s&&t<=r){
			if(abs(tr[p].mx)>n) return -1;
			return tr[p].mx;
		}
		if(tr[p].tag) pushdown(p);
		ll ans = -1;
		if(l<=(s+t)/2) ans=max(ans,query_max(l,r,s,(s+t)/2,2*p));
		if(r>(s+t)/2) ans=max(ans,query_max(l,r,(s+t)/2+1,t,2*p+1));
		return ans;
	}
	inline void query_anss(ll l,ll r,ll s,ll t,ll p){
		if(l<=s&&t<=r){
			if(temp.len==-1) temp=tr[p];
			else temp=merge(temp,tr[p],s,t,p);
			return ;
		}
		if(tr[p].tag) pushdown(p);
		if(l<=(s+t)/2) query_anss(l,r,s,(s+t)/2,2*p);
		if(r>(s+t)/2) query_anss(l,r,(s+t)/2+1,t,2*p+1);
	}
	inline pair<ll,ll> query_ans(ll l,ll r,ll s,ll t,ll p){
		temp.len=-1;
		query_anss(l,r,s,t,p);
		return make_pair(temp.len,temp.sum);
	}
	inline pair<ll,ll> query(ll val,ll mn,ll s,ll t,ll p){
		if(s==t) return make_pair(0,0);
		if(tr[p].tag) pushdown(p);		
		if(tr[2*p].mn<tr[2*p+1].mn) return query(val,mn,s,(s+t)/2,2*p);
		if(tr[2*p].mn>tr[2*p+1].mn) return query(val,mn,(s+t)/2+1,t,2*p+1);
		if(tr[2*p].rs<val){
			pair<ll,ll> ans = query(max(val,tr[p].mid),mn,(s+t)/2+1,t,2*p+1);
			if(tr[p].mid>=val) ans.first++,ans.second+=tr[p].mid;
			return ans;
		}
		else{
			pair<ll,ll> ans = query(val,mn,s,(s+t)/2,2*p);
			ans.first += tr[p].len-tr[2*p].len,ans.second += tr[p].sum-tr[2*p].sum;
			return ans;
		}
	}
	inline node merge(node a,node b,ll s,ll t,ll p){
		node c;
		if(a.mn<b.mn) c=a,c.tag=0,c.mid=-1;
		else if(a.mn>b.mn) c=b,c.tag=0,c.mid=-1;
		else{
			c.mn = a.mn,c.lid = a.lid,c.rid = b.rid,c.ls = a.ls,c.mid = query_max(a.rid,b.lid-1,1,n,1);
			if(c.mid==-1) c.mid = -1e13;
			ll newrs = max(a.rs,c.mid);
			pair<ll,ll> poly = query(newrs,c.mn,s,t,p);
			c.rs = max(newrs,b.rs),c.len = a.len + (c.mid>=a.rs) + poly.first,c.sum = a.sum + (c.mid>=a.rs)*c.mid + poly.second;
		}
		if(abs(a.mx)>n&&abs(b.mx)>n) c.mx=max(a.mx,b.mx);
		else if(abs(a.mx)>n) c.mx=b.mx;
		else if(abs(b.mx)>n) c.mx=a.mx;
		else c.mx=max(a.mx,b.mx);
		return c;
	}
	inline void build(ll s,ll t,ll p){
		if(s==t){
			tr[p].mx = tr[p].mn = a[s],tr[p].tag = 0,tr[p].ls = tr[p].rs = a[s],tr[p].len = 0,tr[p].lid = tr[p].rid = s,tr[p].sum = 0,tr[p].mid = -1;
			return ;
		}
		build(s,(s+t)/2,2*p),build((s+t)/2+1,t,2*p+1);
		if(tr[2*p].mn<tr[2*p+1].mn) tr[p]=tr[2*p];
		else if(tr[2*p].mn>tr[2*p+1].mn) tr[p]=tr[2*p+1];
		else{
			tr[p].mn = tr[2*p].mn,top = 0;
			ll sums = 0,midd = -1;
			for(ll i=s,j;i<=t;){
				if(i>=tr[2*p].rid&&i<tr[2*p+1].lid&&abs(a[i])<=n) midd=max(midd,a[i]);
				if(a[i]==tr[p].mn){
					ll temp = a[i];
					for(j=i+1;j<=t;j++){
						if(a[j]==tr[p].mn) break;
						if(abs(a[j])<=n){
							temp=max(temp,a[j]);
							if(j>=tr[2*p].rid&&j<tr[2*p+1].lid) midd=max(midd,a[j]);
						}
					}
					if(j<=t){
						if(!top||sta[top]<=temp) sta[++top]=temp,sums+=temp;
					}
					i=j;
				}
				else i++;
			}
			tr[p].ls = sta[1],tr[p].rs = sta[top],tr[p].len = top,tr[p].sum = sums,tr[p].lid = tr[2*p].lid,tr[p].rid = tr[2*p+1].rid,tr[p].mid = midd;
		}
		if(abs(tr[2*p].mx)>n&&abs(tr[2*p+1].mx)>n) tr[p].mx=max(tr[2*p].mx,tr[2*p+1].mx);
		else if(abs(tr[2*p].mx)>n) tr[p].mx=tr[2*p+1].mx;
		else if(abs(tr[2*p+1].mx)>n) tr[p].mx=tr[2*p].mx;
		else tr[p].mx=max(tr[2*p].mx,tr[2*p+1].mx);
	}
	inline void modify(ll l,ll r,ll c,ll s,ll t,ll p){
		if(l<=s&&t<=r) return pushtag(p,c),void();
		if(tr[p].tag) pushdown(p);
		if(l<=(s+t)/2) modify(l,r,c,s,(s+t)/2,2*p);
		if(r>(s+t)/2) modify(l,r,c,(s+t)/2+1,t,2*p+1);
		tr[p] = merge(tr[2*p],tr[2*p+1],(s+t)/2+1,t,2*p+1);
//		cout<<"? "<<p<<" "<<s<<" "<<t<<" "<<tr[p].mx<<endl;
//		cout<<"! "<<p<<" "<<s<<" "<<t<<" "<<tr[p].lid<<" "<<tr[p].rid<<" "<<tr[p].sum<<" "<<tr[p].ls<<" "<<tr[p].rs<<endl;
	}
}tr;

void dfs(ll x){
	dfn[x] = ++dtot,nid[dtot] = x;
	if(op[x].size()==0) leaf[dtot]=leaf[dtot-1]+1;
	else leaf[dtot]=leaf[dtot-1];
	for(ll i=0;i<op[x].size();i++) dfs(op[x][i]);
	ot[x]=dtot;
	if(e[x]) a[dfn[x]]++,a[ot[x]+1]--;
	else a[dfn[x]]+=1e12,a[dfn[x]+1]-=1e12;
}

int main(){
//	freopen("18.in","r",stdin);
//	freopen("18.out","w",stdout);
	n=read(),m=read();
	for(i=1;i<=n;i++){
		e[i]=read(),x=read();
		while(x--) y=read(),op[i].push_back(y);
	}
	dfs(1);
	for(i=1;i<=n;i++) a[i]+=a[i-1];
	tr.build(1,n,1);
	while(m--){
		x=read(),y=read();
		if(x==1){
//			continue;
			if(e[y]==0) tr.modify(dfn[y],ot[y],1,1,n,1),tr.modify(dfn[y],dfn[y],-1e12,1,n,1),e[y]=1;
			else tr.modify(dfn[y],ot[y],-1,1,n,1),tr.modify(dfn[y],dfn[y],1e12,1,n,1),e[y]=0;
//			cout<<tr.tr[1].mx<<endl;
		}
		else{
			ll valy = tr.query_max(dfn[y],dfn[y],1,n,1),valall = tr.query_max(dfn[y],ot[y],1,n,1);
//			cout<<"! "<<valall<<endl;
			if(e[y]==1){
				write(valall-valy+1),pc('\n');
				continue;
			}
			if(valall==-1){
				ll temp = leaf[ot[y]]-leaf[dfn[y]-1];
				if(temp>1) temp++;
				write(temp),pc('\n');
			}
			else{
				valy = tr.query_min(dfn[y],ot[y],1,n,1)-1;
				ll leav = 0,tot = 0,sum = 0;
				ll l=dfn[y],r=ot[y];
				while(l<r){
					ll mid=(l+r)/2;
					if(tr.query_max(dfn[y],mid,1,n,1)>valy) r=mid;
					else l=mid+1;
				}
				leav=leaf[r-1]-leaf[dfn[y]-1];
				pair<ll,ll> ans = tr.query_ans(dfn[y],ot[y],1,n,1);
				l=dfn[y],r=ot[y];
				while(l<r){
					ll mid=(l+r+1)/2;
					if(tr.query_min(mid,ot[y],1,n,1)<=valy+1) l=mid;
					else r=mid-1;
				}
//				cout<<valy<<" "<<tr.query_min(4,5,1,n,1)<<endl;
				tot=ans.first,sum=ans.second-tot*valy;
//				cout<<leav<<" "<<ans.first<<" "<<ans.second<<" "<<l<<endl;
				if(tr.query_max(l,ot[y],1,n,1)==valall) tot++,sum+=valall-valy;
//				cout<<valall<<" "<<valy<<" "<<tot<<" "<<sum<<endl;
				write(leav+sum+(leav+tot>=2)),pc('\n');
			}
		}
	}
	return fwrite(obuf,p34-obuf,1,stdout),0;	
}
/*
Input:
3 6
0 2 2 3
0 0
0 0
2 1
1 3
2 1
1 3
1 2
2 1

Output:
3
3
1
*/
```

---

## 作者：Otomachi_Una_ (赞：3)

首先，两个人肯定要输入一个尽可能大的数，到底有多大呢？比任何的自然数都要大！我们记为 $\omega$。

那么，我们首先进行 $\omega$ 之间的比较。

首先，注意到 $1+\omega>\omega$。这是因为第一轮左边的人知道了右边的人输入了啥，输入一个更大的即可。

其次，$\omega+1=\omega$。因为在最后 $+1$ 没啥用。

那么，根据上面的观察，不难发现在一次的时候，就有 $1,\omega$ 拼接起来的序列实际上是等于前缀极长 $1$ 拼接上所有的 $\omega$。

比如 $1+\omega+1+\omega=1+2\omega$。

有了一次式的观察，再来进行高次的观察。

实际上输入一个数再执行子树操作，可以看作为 $\omega(\operatorname{subtree})$。于是就有了 $\omega^2$ 之类的树结构。

考虑 $\omega(1+\omega)=\omega^2$。这是因为两者同时输入了 $\omega$，那么，一次遍历 subtree 当中的 $1$ 显得不那么重要了。

同样的，我们也有：$\omega(\omega+\omega)=\omega^2$。同样的，因为这个和第一次输入乘上两倍是相同的效果。

再进行观察，能发现 $\omega^3+\omega^2=\omega^3$。于是，我们观察到了一个 $\omega$ 缩减的一类套路：

- $\omega(F)=\omega^{\deg(F)+1}$；
- 当 $a>b$ 有 $\omega^2+\omega^b=\omega^a$。

不难发现已经充要。

然后就是数据结构问题了。

如果询问的 $k$ 已经是 $\omega$ 节点，那么我们只需要计算含 $\omega$ 最多链。这里直接把树按照 dfn 拍扁，然后 $\omega$ 变成子树加 $1$ 然后求区间 $\max$ 即可。

如果 $k$ 不是 $\omega$ 节点，那么我们需要按照 dfs 序找到所有的最深 $\omega$ 节点。上面区间加的做法没啥拓展性，考虑另一种做法。我们把树拍成括号序列，那么一个节点安放了括号当且仅当其对应节点是 $\omega$ 节点。那么这个查询相当于查询其子树区间当中，所有不可分割的括号匹配，深度 localmax 的和。

括号匹配的深度定义为最大的 $k$ 使得 $(((\dots)))$（$k$ 对括号）是其子序列。

那么 localmax 求和就是很经典的兔队线段树。按照兔队线段树的套路去做就行了。

时间复杂度：$\mathcal O(m\log^2n)$。

**【参考代码】**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=1e6+5;
struct node{
	int cl,wl,w,cr,wr;
	// 未匹配左括号，其中最大深度，中间最大深度，未匹配右括号，其中最大深度
	node(int a=0,int b=0,int c=0,int d=0,int e=0){cl=a,wl=b,w=c,cr=d,wr=e;}
};
struct pr{
	int x,y;// 括号匹配的深度和，数量
	pr(int a=0,int b=0){if(a<0) a=b=0;else a=max(1,a);x=a,y=b;}
};
inline node operator +(const node &x,const node &y){
	if(x.cr<y.cl){
		int ex=y.cl-x.cr;
		return node(x.cl+ex,max({x.wl+ex,x.w+ex,x.wr+ex,y.wl}),y.w,y.cr,y.wr);
	}else if(x.cr==y.cl){
		return node(x.cl,x.wl,max({x.w,x.wr,y.wl,y.w}),y.cr,y.wr);
	}else{
		int ex=x.cr-y.cl;
		return node(x.cl,x.wl,x.w,y.cr+ex,max({x.wr,y.wl+ex,y.w+ex,y.wr+ex}));
	}
}
inline void operator +=(node &x,const node &y){x=x+y;}
inline pr operator +(pr x,const pr &y){
	x.x+=y.x;x.y+=y.y;return x;
}
inline void operator +=(pr &x,const pr &y){x=x+y;}
int n,m,in[MAXN],out[MAXN],dfn[MAXN],col[MAXN],tot;
vector<int> son[MAXN];
inline bool leaf(int x){return son[x].empty();}
void dfs(int u){
	in[u]=++tot;dfn[tot]=u;
	for(int v:son[u]) dfs(v);
	if(!leaf(u)) out[u]=++tot,dfn[tot]=u;
	else out[u]=tot;
}
struct segt{
node val[MAXN<<2],lv[MAXN<<2];pr rv[MAXN<<2];
void init(int id,int x){
	int u=dfn[x];
	if(leaf(u)) val[id]=node(0,-1,col[u],0,-1);
	else if(!col[u]) val[id]=node(0,-1,-1,0,-1);
	else if(x==in[u]) val[id]=node(0,-1,-1,1,1);
	else val[id]=node(1,1,-1,0,-1);
}
pr query(node &v,int id,int l,int r){
	// cerr<<"query "<<id<<' '<<l<<' '<<r<<'\n';
	// 类似兔队线段树的更新
	pr ret(-1,0);
	if(l==r){
		if(val[id].cl){
			if(v.cr==val[id].cl&&v.w<=max(v.wr,val[id].wl)) 
				ret=pr(max(v.wr,val[id].wl),1);
		}else if(!v.cr&&!val[id].cr&&v.w<=val[id].w) ret=pr(val[id].w,1);
		v+=val[id];
		return ret;
	}
	int mid=(l+r)>>1;
	if(v.cr>val[id<<1].cl){
		v+=val[id<<1];
		return query(v,id<<1|1,mid+1,r);
	}
	if(max({v.w,v.wr,val[id<<1].wl})>val[id<<1].w){
		// id<<1 的 w 没有贡献
		if(v.w<=max(v.wr,val[id<<1].wl)) 
			ret+=pr(max(v.wr,val[id<<1].wl),1);
		v+=val[id<<1];
		return ret+query(v,id<<1|1,mid+1,r);
	}else{
		// 右边已经算出
		ret+=query(v,id<<1,l,mid);ret+=rv[id];v=lv[id];
		return ret;
	}
}
pr query(int L,int R,node &v,int id=1,int l=1,int r=tot){
	// 分割为若干小的 query
	if(L<=l&&r<=R) return query(v,id,l,r);
	int mid=(l+r)>>1;pr ans(-1,0);
	if(L<=mid) ans+=query(L,R,v,id<<1,l,mid);
	if(mid<R) ans+=query(L,R,v,id<<1|1,mid+1,r);
	return ans;
}
void pushup(int id,int l,int r){
	val[id]=val[id<<1]+val[id<<1|1];
	int mid=(l+r)>>1;
	lv[id]=val[id<<1];rv[id]=query(lv[id],id<<1|1,mid+1,r);
}
void build(int id=1,int l=1,int r=tot){
	if(l==r){init(id,l);return;}
	int mid=(l+r)>>1;
	build(id<<1,l,mid);build(id<<1|1,mid+1,r);
	pushup(id,l,r);
	// cerr<<"Build "<<l<<' '<<r<<' '<<val[id].w<<'\n';
}
void upd(int x,int id=1,int l=1,int r=tot){
	if(l==r){init(id,l);return;}
	int mid=(l+r)>>1;
	if(x<=mid) upd(x,id<<1,l,mid);
	else upd(x,id<<1|1,mid+1,r);
	pushup(id,l,r);
}
}T;
int main(){
	ios::sync_with_stdio(false);
	// freopen("Otomachi_Una.in","r",stdin);
	// freopen("Otomachi_Una.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int l;cin>>col[i]>>l;
		son[i].resize(l);
		for(auto &j:son[i]) cin>>j;
	}
	dfs(1);T.build();
	for(int i=1;i<=m;i++){
		int o,x;cin>>o>>x;
		if(o==1){
			col[x]^=1;
			T.upd(in[x]);T.upd(out[x]);
		}else{
			node v(0,-1,-1,0,-1);
			pr ret=T.query(in[x],out[x],v);
			if(ret.y>1) ret.x++;
			cout<<ret.x<<'\n';
		}
	}
	return 0;
}
```

---


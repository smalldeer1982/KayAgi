# [PA 2024] Monety

## 题目背景

PA 2024 5A2

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 5 [Monety](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/mon/)**

Natalia 和 Cezary 喜欢玩游戏，尤其是他们自己发明的游戏。他们决定在自己面前放置一些堆硬币，硬币从上到下排成类似栈的样子，每堆有 $m$ 枚硬币，每枚硬币要么是蓝色的，要么是红色的。轮到 Natalia 时，她可以选择一枚蓝色硬币，并将其连同其上方的所有硬币一起从硬币堆中移除。同样，在轮到 Cezary 时，他可以选择一枚红色硬币，并将其连同其上方的所有硬币一起从硬币堆中移除。 玩家将轮流操作，不能采取合法操作的玩家就输了——也就是说，当一位玩家操作的所有硬币都已被移除时。

现在他们知道了规则，他们必须确定游戏的初始状态——$d$ 堆硬币，每堆恰好包含 $m$ 个硬币。Natalia 和 Cezary 都不希望拥有不公平的优势，因此他们一致认为硬币的顺序应该是公平的。假设 Natalia 和 Cezary 都采取最优策略，后手赢得游戏，则称初始状态是公平的。因此，如果 Natalia 先手，则采用最优策略的 Cezary 将获胜，反之亦然：如果 Cezary 先手，Natalia 将获胜。

两人已经摆好了前 $k$ 堆 $m$ 个硬币。现在他们正在思考如何完成这一系列硬币堆。他们已经得出结论，游戏中拥有超过 $n$ 堆硬币是没有意义的。

帮助他们，对于区间 $[k, n]$ 中的每个整数 $d$，告诉他们有多少种不同的由 $d$ 堆 $m$ 枚硬币组成的公平初始状态，这些初始状态从他们已经摆好的硬币堆开始。如果存在 $i\in [1, d]$ 和 $j\in [1, m]$，当第 $i$ 堆中的第 $j$ 个硬币在一种排列方式中为蓝色，在另一种为红色，则认为这两个初始排列方式是不同的。

由于答案可能很大，输出答案对 $10^9+7$ 取模后的值即可。

## 说明/提示

对于第一组样例，如果我们不添加任何硬币堆，则最初局面不是公平的。然而，我们可以加一堆排列为 `NNC` 的硬币——这样两堆硬币的初始状态就是公平的了。我们可以以三种方式添加两堆硬币：`[CCN, NNN]`，`[NNN, CCN]` 和 `[NCN, NCN]`。

**数据范围与提示**

- 在某些子任务中，满足 $k=n$。
- 在某些子任务中，满足 $n\le 8,m\le 8$​。
- 在某些子任务中，满足 $n\le 12,m\le 13$。
- 在某些子任务中，满足 $n\le 16,m\le 19$​。

上述每个子任务至少描述了之前子任务中没有出现的一组。

## 样例 #1

### 输入

```
3 3 1
CCN
```

### 输出

```
0 1 3
```

## 样例 #2

### 输入

```
2 1 0
```

### 输出

```
1 0 2
```

## 样例 #3

### 输入

```
4 2 4
CN
NC
CC
NN
```

### 输出

```
1
```

# 题解

## 作者：C1942huangjiaxu (赞：6)

首先要判断什么样的状态是公平的。

可以发现，公平的状态最后一定是全部硬币都移除了，否则交换先后手是先手胜。

那么考虑能否给每个硬币一个权值，**使得两人硬币权值和相等（也就是相差为 0）是状态公平的充要条件**。

先给出赋权方法，对于一堆硬币，**底部连续一段属于同一个人**的硬币权值为 $1$，其余硬币权值是它下面硬币权值的 $\frac 1 2$。

例如 CCNNC 的权值为 $[1,1,\frac 1 2,\frac 1 4,\frac 1 8]$。

下面来说明为什么相差为 $0$ 的状态是公平的。

设当前**硬币最小的权值**为 $w$。

首先可以发现这样的硬币**至少有 $2$ 枚**，否则相差不为 $0$。

然后认为**操作者移除自己的硬币减少相应的权值，移除对手的硬币增加相应的权值，最后权值小的就输了**。

那么可以发现，这次移除硬币后，操作者权值**至少减小 $w$**。

因为根据等比数列求和，每个权值为 $x$ 的硬币上方对手的权值和不超过 $x-w$。

其次，**能够做到只减少 $w$ 的权值**，如果存在自己的硬币就直接移除，否则找到对面的权值为 $w$ 的硬币，将其**下方第一个自己的硬币**移除，可以发现这样权值也减少 $w$。

因此，**先后手各减少 $w$ 的权值**，权值相差依旧为 $0$。

接下来考虑怎么计数。

为了**避免分数计算，将所有权值 $\times 2^{m-1}$**。

特判掉 $m=1$ 的情况。

考虑数位 DP，因为每一堆石子底部连续段长度不同，考虑在**枚举到该堆石子最低位时加入**，并钦定底部是 $CC\cdots CN$ 还是 $NN\cdots NC$，同时记录权值 $\ge 2^{m-2}$ 的权值差。

设 $f_{i,j,k,l}$ 表示考虑了 $2^i$ 以下的位，加入了 $j$ 堆石子，$\ge 2^{m-2}$ 的权值差为 $k\times 2^{m-2}$，其余位的权值差为 $l\times 2^i$。

转移时枚举新加入的底部为 $CC\cdots CN$ 和 $NN\cdots NC$ 的堆的数量，再枚举这一位有多少 $C$。

**注意到这 $3$ 个量联系并不大，可以分开 $3$ 次转移，每次 $O(n)$**。

最后 $2^{m-2}$ 和全部相同的堆的转移也是类似的。

状态数为 $O(m\times n\times nm\times n)$，转移是 $O(n)$ 的。

所以时间复杂度 $O(n^4m^2)$，使用滚动数组后空间大小为 $O(n^3m)$，实测最大耗时在 $1s$ 以内。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=1e9+7,V1=1536,V2=32,M1=V1*2+1,M2=V2*2+1;
int n,m,k,sum,C[35][35],f[33][M1][M2],g[33][M1][M2],h[33][M1][M2],t[33][M1],ans[35];
char s[25];
inline int md(int x){
	return x>=P?x-P:x;
}
inline void Add(int &x,int y){
	if((x+=y)>=P)x-=P;
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;++i){
		scanf("%s",s);
		int t=m-1,fg=0;
		for(int j=0;j<m;++j){
			if(j&&s[j]!=s[j-1])fg=1;
			t-=fg;
			if(s[j]=='C')sum+=1<<t;
			else sum-=1<<t;
		}
	}
	n-=k,sum=abs(sum);
	for(int i=0;i<=n;++i)C[i][0]=1;
	for(int i=1;i<=n;++i)for(int j=1;j<=i;++j)C[i][j]=md(C[i-1][j]+C[i-1][j-1]);
	if(m==1){
		for(int i=0;i<=n;++i){
			if((i+sum&1)||sum>i)printf("0 ");
			else printf("%d ",C[i][i+sum>>1]);
		}
		return 0;
	}
	f[0][V1][V2]=1;
	for(int i=0;i<=m-2;++i){
		for(int j=0;j<=n;++j)for(int k=-V1;k<=V1;++k)for(int l=-V2;l<=V2;++l){
			int w=f[j][k+V1][l+V2];
			if(!w)continue;
			f[j][k+V1][l+V2]=0;
			int v=2*(i+1)-1;
			for(int t=0;t+j<=n;++t)
				Add(g[j+t][k+V1+t*v][l+V2],1ll*w*C[j+t][t]%P);
		}
		for(int j=0;j<=n;++j)for(int k=-V1;k<=V1;++k)for(int l=-V2;l<=V2;++l){
			int w=g[j][k+V1][l+V2];
			if(!w)continue;
			g[j][k+V1][l+V2]=0;
			int v=2*(i+1)-1;
			for(int t=0;t+j<=n;++t)
				Add(h[j+t][k+V1-t*v][l+V2],1ll*w*C[j+t][t]%P);
		}
		if(i==m-2)break;
		int o=sum>>i&1;
		for(int j=0;j<=n;++j)for(int k=-V1;k<=V1;++k)for(int l=-V2;l<=V2;++l){
			int w=h[j][k+V1][l+V2];
			if(!w)continue;
			h[j][k+V1][l+V2]=0;
			if((l+j&1)!=o)continue;
			for(int t=0;t<=j;++t)
				Add(f[j][k+V1][(l+(j-2*t)-o>>1)+V2],1ll*w*C[j][t]%P);
		}
	}
	int o=sum>>m-2&1;
	for(int j=0;j<=n;++j)for(int k=-V1;k<=V1;++k)for(int l=-V2;l<=V2;++l){
		int w=h[j][k+V1][l+V2];
		if(!w)continue;
		h[j][k+V1][l+V2]=0;
		if(l+k-o&1)continue;
		Add(t[j][(l+k-o>>1)+V1],w);
	}
	sum>>=m-1;
	for(int j=0;j<=n;++j)for(int k=-V1;k<=V1;++k){
		int w=t[j][k+V1];
		if(!w)continue;
		int v=k-sum;
		if(v%m!=0)continue;
		v/=m;
		for(int l=0;j+l<=n;++l)if(v<=l&&v+l>=0&&!(v+l&1))Add(ans[j+l],1ll*w*C[j+l][l]%P*C[l][v+l>>1]%P);
	}
	for(int i=0;i<=n;++i)printf("%d ",ans[i]);
	return 0;
}
```

---

## 作者：_lmh_ (赞：0)

基于超现实数理论，这里一个状态 $x$ 可以定义为 $\{L|R\}$，其中 $L$ 为左方（Natalia）一次操作可以走到的状态集合，$R$ 为右方（Cezary）一次操作可以走到的集合。之后可以证明，在此题的限制条件下所有状态 $x$ 都是“数”——不存在 $x^L\in L,x^R\in R$ 使得 $x^L\ge x^R$。

首先考虑 $n=k=1$ 的情况，即单个硬币堆的处理。

列举一些最简单的情况：$m=0$ 时，空字符串对应 $\{|\}=0$；$m=1$ 时，`N` 对应 $\{0|\}=1$，`C` 对应 $\{|0\}=-1$。

$m$ 更大时，$L,R$ 可能有不止一个元素，此时可以用博弈的化简方式“优超”将 $L$ 中最大，$R$ 中最小的元素 $x,y$ 找出来，那么 $\{L|R\}=\{x|y\}$。

下面给出一种构造：为每个硬币赋权，第一个连续段的权值都为 $1$，之后**每个硬币权值是上一个的一半**。之后令 $N=1,C=-1$，归纳证明每个硬币的权值乘上它的值之和就是整个博弈对应的值，并且这个值一定是 $\frac{1}{2^{m-1}}$ 的整数倍。

$m\le 1$ 的情况已经给出。

下面假设命题在 $m<t$ 的情况下都成立，考虑 $m=t$。显然 `NNN...N` 的值为 $\{0,1,\cdots,t-1|\}=t$，`CCC...C` 同理，此时最后一个字符的权重为 $1$。

其余情况下，双方都有选择。不妨假设第一个硬币是 `N`。对于第一个连续段（全部为 `N`），显然选最后一个硬币比其它决策都更优。

对于其它决策，当前位置对应的硬币权值比后面的加起来还要大，因此如果能保留这枚硬币一定会保留。

所以得出结论：二人都会使自己选择的硬币编号尽可能大。

现在不妨假设最后一个字符是 `C`，并且最后一个连续段有 $i$ 个字符，这个连续段之前那个 `N` 的权值为 $w$。

假设选择 `N` 之后剩余部分的值为 $x$，那么选择 `C` 之后剩余部分的权值为 $x+w(1-\frac{2^{i-1}-1}{2^{i-1}})=x+\frac{w}{2^{i-1}}$，显然 $x$ 是 $w$ 的整数倍。

由超现实数理论，$\{\frac{a-1}{2^b}|\frac{a+1}{2^b}\}=\frac{a}{2^b}$，可以得出当前序列的值为 $x+\frac{w}{2^i}$，因此最后一个 `C` 的权重为 $\frac{w}{2^i}$，是前一个字符的一半。

这样我们就可以计算一个序列了，而 $n$ 个序列的情况只需要把它们的值加在一起即可。

然后将所有值都乘上 $2^{m-1}$ 使它们都是整数，最后需要保证总和为 $0$。

发现第一个连续段比较特殊需要特判，所以把 `NNN...NC` 和 `CCC...CN` 的段的贡献单独考虑——它是 $2^{m-2}$ 的倍数。

令 $f_{i,j,k,l}$ 为：正在填 $2^i$ 的二进制位，有 $j$ 个段的最小权重 $\ge 2^i$，当前的权值之和为 $k\cdot 2^{m-2}+l\cdot 2^i$。

将给定的序列的权值求和得到总和 $S$（不妨设 $S\ge 0$，$S<0$ 的情况与其等价），设 $d_i$ 为其在 $2^i$ 的二进制位上的值。初始化时令 $f_{0,0,\lfloor\frac{S}{2^{m-1}}\rfloor,0}=1$。

$i<m-2$ 时，转移分三步：

$f_{i,j+x,k+x(2i+1),l} \larr \binom{j+x}{x}f_{i,j,k,l}$：解锁开头为 `NNN...NC` 的序列。

$f_{i,j+x,k-x(2i+1),l} \larr \binom{j+x}{x}f_{i,j,k,l}$：解锁开头为 `CCC...CN` 的序列。

$f_{i+1,j,k,\frac{l+d_i+x-(j-x)}{2}}\larr \binom{j}{x}f_{i,j,k,l}$：填第 $i$ 位的值。

$i>m-2$ 时，大部分序列的贡献都已被统计，只有四种未被统计的序列，这是好做的。

总复杂度 $O(m\cdot n\cdot nm\cdot n\cdot n)=O(n^4m^2)$，不需要卡常。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=35,M=6150,A=M/2,B=N<<1,MOD=1e9+7;
ll n,m,k,dif[N],C[N][N],f[N][M][N<<2],g[N][M][N<<2],h[N][M][N<<2],F[N][M],G[N][M];
char s[N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	for (int i=0;i<N;++i) for (int j=C[i][0]=1;j<=i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	cin>>n>>m>>k;n-=k;
	for (int i=1;i<=k;++i){
		cin>>(s+1);
		int p=m-1,fl=0;
		for (int j=1;j<=m;++j){
			fl|=(j>1&&s[j]!=s[j-1]);p-=fl;
			if (s[j]=='C') ++dif[p];
			else --dif[p];
		}
	}
	f[0][dif[m-1]*2+dif[m-2]+A][B]=1;
	for (int t=0;t<m-2;++t){
		for (int i=0;i<=n;++i) for (int j=-A;j<A;++j) for (int k=-B;k<B;++k) if (f[i][j+A][k+B]){
//			cout<<t<<' '<<i<<' '<<j<<' '<<k<<' '<<f[i][j+A][k+B]<<endl;
			ll tmp=f[i][j+A][k+B];f[i][j+A][k+B]=0;
			for (int l=0;i+l<=n;++l) (g[i+l][j+(t*2+1)*l+A][k+B]+=tmp*C[i+l][i])%=MOD;
		}
		for (int i=0;i<=n;++i) for (int j=-A;j<A;++j) for (int k=-B;k<B;++k) if (g[i][j+A][k+B]){
			ll tmp=g[i][j+A][k+B];g[i][j+A][k+B]=0;
			for (int l=0;i+l<=n;++l) (h[i+l][j-(t*2+1)*l+A][k+B]+=tmp*C[i+l][i])%=MOD;
		}
		for (int i=0;i<=n;++i) for (int j=-A;j<A;++j) for (int k=-B;k<B;++k) if (h[i][j+A][k+B]){
			ll tmp=h[i][j+A][k+B];h[i][j+A][k+B]=0;
			if (k+dif[t]+i&1) continue;
			for (int l=0;l<=i;++l) (f[i][j+A][(k+dif[t]+i-2*l>>1)+B]+=tmp*C[i][l])%=MOD;
		}
	}
	for (int i=0;i<=n;++i) for (int j=-A;j<A;++j) for (int k=-B;k<B;++k) if (f[i][j+A][k+B]){
//		cout<<"f "<<i<<' '<<j<<' '<<k<<' '<<f[i][j+A][k+B]<<endl;
		(F[i][j+k+A]+=f[i][j+A][k+B])%=MOD;
	}
	if (m>1){
		for (int i=0;i<=n;++i) for (int j=-A;j<A;++j) if (F[i][j+A]){
			ll tmp=F[i][j+A];F[i][j+A]=0;
			for (int k=0;i+k<=n;++k) (G[i+k][j+k*(2*m-3)+A]+=tmp*C[i+k][i])%=MOD;
		}
		for (int i=0;i<=n;++i) for (int j=-A;j<A;++j) if (G[i][j+A]){
			ll tmp=G[i][j+A];G[i][j+A]=0;
			for (int k=0;i+k<=n;++k) (F[i+k][j-k*(2*m-3)+A]+=tmp*C[i+k][i])%=MOD;
		}
	}
	for (int i=0;i<=n;++i) for (int j=-A;j<A;++j) if (F[i][j+A]){
		ll tmp=F[i][j+A];F[i][j+A]=0;
		for (int k=0;i+k<=n;++k) (G[i+k][j+k*2*m+A]+=tmp*C[i+k][i])%=MOD;
	}
	for (int i=0;i<=n;++i) for (int j=-A;j<A;++j) if (G[i][j+A]){
		ll tmp=G[i][j+A];G[i][j+A]=0;
		for (int k=0;i+k<=n;++k) (F[i+k][j-k*2*m+A]+=tmp*C[i+k][i])%=MOD;
	}
	for (int i=0;i<=n;++i) cout<<F[i][A]<<' ';cout<<endl;
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10363)

**题目大意**

> 给定 $n$ 堆硬币，每堆硬币由 $m$ 个红色或蓝色的硬币组成。
>
> 现在 A 和 B 轮流取硬币，A 可以选一个红色硬币，并把该硬币及其上方的硬币取走，B 可以选一个蓝色硬币，并把该硬币及其上方的硬币取走。
>
> 一个局面是好的，当且仅当无论谁先手，后手都有必胜策略。
>
> 已知 $k$ 堆硬币的情况，对于 $i=[0,n-k]$，求有多少种加入 $i$ 堆硬币的方法使得局面是好的。
>
> 数据范围：$n\le 32,m\le 24$。

**思路分析**

首先感性理解，对于一个好局面，游戏结束时场上应该没有硬币，否则交换先后手时后手还能胜利。

观察可以发现，一个局面是好的，当且仅当按如下方式给每个硬币赋权后，两种硬币权值和相等：

- 对于每堆，从堆底找到极长同色连续段，权值为 $1$，剩余的每个硬币权值是前一个的一半。

证明如下：假设最小权值是 $w$，那么自己的权值至少比对方多损失 $w$，这是显然的，并且这一定能取到：找到一个这样的硬币，并且向前找到第一个自己可以取走的硬币即可。

并且由于权值总和为 $0$，因此一定存在 $\ge 2$ 个权值为 $w$ 的硬币，那么根据贪心，两边都要减小自己权值的亏损，那么都会选择让自己的权值 $-w$。

否则在某个时刻，先手操作后就不存在权值为 $w$ 的硬币，从而先手可以保持自己的权值大于对方直到获胜。

那么我们要对这个过程计数。

给权值 $\times 2^{m-1}$，然后从低到高考虑权值和的每一位。

对于权值和的第 $k$ 位，当且仅当堆底同色连续段长度 $\le k+1$ 的堆会有一个权值为 $2^{k-(m-1)}$ 的硬币。

那么我们按 $k$ 从小到大枚举，每次加入堆底同色连续段长度 $=k+1$ 的堆，然后给已经加入的每个堆确定权值为 $2^{k-(m-1)}$ 的硬币的颜色。

设 $f_{k,i,j,r}$ 表示当前插入了 $i$ 个堆，权值差是 $2^{m-2}\times j+2^k\times r$，因为加入的每个堆的时候已经钦定了前 $k+2$ 的硬币的颜色，所以在 $k\ge m-2$ 的时候要特殊处理转移。

此时 $j\in[-mn,mn]$，$r\in[-n,n]$，状态数 $\mathcal O(n^3m^2)$。

注意到 $f_{k}\to f_{k+1}$ 的转移需要分三步：确定有多少形如 $\texttt{RRR...RC}$ 和 $\texttt{CCC...CR}$ 的堆，然后给权值为 $2^{k-(m-1)}$ 的硬币分配颜色。

很显然这三个步骤完全独立，那么分步转移可以做到 $\mathcal O(n)$。

时间复杂度 $\mathcal O(n^4m^2)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=1e9+7;
inline void add(int &x,const ll &y) { x=(x+y)%MOD; }
int n,m,q,S,C[35][35],f[35][6155][69],g[35][6155][69];
//f[k,i,j,r]: dig = k, cnt = i, diff = 2^{m-2}*j+2^k*r
int h[35][6155],ans[35];
signed main() {
	ios::sync_with_stdio(false);
	cin>>n>>m>>q,n-=q;
	const int V=2*n*m;
	for(int i=1;i<=q;++i) {
		string s; cin>>s;
		for(int j=0,k=m-1;j<m;++j) {
			if(k<m-1||s[j]!=s[0]) --k;
			S+=(s[j]=='C'?1:-1)*(1<<k);
		}
	}
	for(int i=0;i<=n;++i) for(int j=C[i][0]=1;j<=i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	S=abs(S),f[0][V][n]=1;
	if(m==1) {
		for(int i=0;i*2+S<=n;++i) ans[i*2+S]=C[i*2+S][i];
		for(int i=0;i<=n;++i) cout<<ans[i]<<" \n"[i==n];
		return 0;
	}
	for(int k=0;k<=m-2;++k) {
		for(int i=0;i<=n;++i) for(int j=-V;j<=V;++j) for(int r=-n;r<=n;++r) {
			const ll &z=f[i][j+V][r+n];
			if(!z) continue;
			int d=2*(k+1)-1; //R*(k+1)+C
			for(int x=0;i+x<=n;++x) add(g[i+x][j+x*d+V][r+n],z*C[i+x][i]);
		}
		memcpy(f,g,sizeof(f)),memset(g,0,sizeof(g));
		for(int i=0;i<=n;++i) for(int j=-V;j<=V;++j) for(int r=-n;r<=n;++r) {
			const ll &z=f[i][j+V][r+n];
			if(!z) continue;
			int d=2*(k+1)-1; //C*(k+1)+R
			for(int x=0;i+x<=n;++x) add(g[i+x][j-x*d+V][r+n],z*C[i+x][i]);
		}
		memcpy(f,g,sizeof(f)),memset(g,0,sizeof(g));
		if(k==m-2) break;
		for(int i=0,t=S>>k&1;i<=n;++i) for(int j=-V;j<=V;++j) for(int r=-n;r<=n;++r) {
			const ll &z=f[i][j+V][r+n];
			if(!z||(r+t+i)%2) continue;
			for(int x=0;x<=i;++x) add(g[i][j+V][(r+t+i-2*x)/2+n],z*C[i][x]);
		}
		memcpy(f,g,sizeof(f)),memset(g,0,sizeof(g));
	}
	for(int i=0,t=S>>(m-2)&1;i<=n;++i) for(int j=-V;j<=V;++j) for(int r=-n;r<=n;++r) {
		const ll &z=f[i][j+V][r+n];
		if(!z||(j+r+t)%2) continue;
		add(h[i][(j+r+t)/2+V],z);
	}
	for(int i=0,t=S>>(m-1);i<=n;++i) for(int j=-V;j<=V;++j) {
		const ll &z=h[i][j+V];
		if(!z||(j+t)%m) continue;
		int c=(j+t)/m;
		for(int x=0;i+2*x+c<=n;++x) add(ans[i+2*x+c],1ll*C[i+2*x+c][x]*C[i+x+c][x+c]%MOD*z);
	}
	for(int i=0;i<=n;++i) cout<<ans[i]<<" \n"[i==n];
	return 0;
}
```

---


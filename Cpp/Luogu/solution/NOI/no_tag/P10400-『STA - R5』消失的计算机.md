# 『STA - R5』消失的计算机

## 题目描述

**本题为提交答案题。**

后台有一个正整数 $n$（你不知道 $n$ 具体的值）。

你有 $10^3$ 个变量 $p_1,p_2,\cdots,p_{10^3}$，初始 $p_1=n$，$p_2=p_3=\cdots=p_{10^3}=0$。

你需要写一个程序完成一些任务，程序包含下面几种语句可供使用：
- `new x`，令 $n\gets n+1$，$p_x\gets n$。
- `dec x`，令 $p_x\gets p_x-1$。
- `assign x y`，令 $p_x\gets p_y$。
- `iftry x goto l`，如果 $p_x \ge 0$，跳转到第 $l$ 条语句。
- `ifeq x y goto l`，如果 $p_x = p_y$，跳转到第 $l$ 条语句。
- `ifneq x y goto l`，如果 $p_x\neq p_y$，跳转到第 $l$ 条语句。

对于后三种语句，**如果当前语句是第 $\bm{l_0}$ 条，那么要求 $\bm{l<l_0}$。**

你不得使用超过 $1000$ 条语句或是标号超过 $1000$ 的变量。你的程序实际语句运行次数不得超过 $10^5$。

令程序执行前的 $n$ 值为程序的输入，程序执行后的 $n$ 值为程序的输出，你需要分别完成下面 $10$ 个任务：

1. 输入 $n$，输出 $2n$。
1. 输入 $n$，输出 $\binom n2$。
1. 输入 $n$，输出 $600$。
1. 输入 $n$，输出 $n + 1$。
1. 输入 $n$，输出 $n^2 - 1$。
1. 输入 $n$，输出 $n + 2000$。
1. 输入 $n$，输出 $n + \lfloor \log_2 n\rfloor$。
1. 输入 $n$，输出 $n + \left(n \bmod 2\right) + 1$。
1. 输入 $n$，输出 $n+\gcd(n, n - 4) + 1$。
1. 输入 $n$，输出一个满足 $|x-n\ln n|\le 30$ 的正整数 $x$。

**注：子任务按长度排序，与难度无关。**

## 说明/提示

**评分标准**

对于每个测试点，其内部会评测若干组测试数据。

若你的输出出现下列情况，那么该测试点不得分：

- 输出与要求不符。
- 实际语句运行次数大于 $10^5$。
- 出现无法识别或不合法的语句。
- 使用超过 $1000$ 条语句或是标号超过 $1000$ 的变量。

否则设对应子任务的评分标准为 $L_0$，那么你的得分为：

$$\mathrm{score}=\begin{cases}11&L_0>L\\\Big\lfloor\frac{10}{\exp\left(1-\frac {L_0}L\right)}\Big\rfloor&\text{otherwise.}\end{cases}$$

下面给出各个任务对应的评分标准 $L_0$:

| 编号 | $1$ | $2$ | $3$ | $4$ | $5$| $6$ | $7$ | $8$ | $9$ | $10$ |
| :-: | :-: | :-: | :-: | :-: | :-: |  :-: | :-: | :-: | :-: | :-: |
| $L_0$ | $3$ | $9$ | $233$ | $1$ | $10$| $29$ | $14$ | $7$ | $18$ | $14$ |

**数据范围**

保证 $5 \le n \le 100$。

# 题解

## 作者：spfa_ (赞：17)

[题目传送门](https://www.luogu.com.cn/problem/P10400)

~~才爆了五个标，太弱了~~

认真分析语句的性质，得到：

- $n$ 只增不减，所以要计算的是增量

- $p$ 只减不增

- 跳转语句等价于 `do-while`，所以 `if` 语句本质上是实现不了的

那么如何实现任意次数次的循环呢？我们可以将一个变量变为想要次数的相反数，然后另外一个置 $0$，如何变量不等则一直减 $1$，就能实现循环了。对于多重循环只需嵌套一下即可。

那么通过循环就能实现一些简单的加，乘操作了。

### task 1

$2n=n+n$，循环 $n$ 次加一即可。

```cpp
3
dec 1
new 2
ifneq 1 3 goto 1
```

### task 2

${n\choose 2}=1+2+\dots+n-1=n+(2+\dots+n-2)$，从 $2$ 循环到 $n-2$ 即可。

```cpp
9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 3
iftry 2 goto 5
dec 1
ifneq 1 4 goto 4
```

### task 3

$600=n+(600-n)$，很直接的想法是构造出 $600-n$ 次循环，变成相反数变成 $n-600$，$600$ 可以视为 $24\times 25$，循环即可。

```cpp
35
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
assign 3 2
dec 3
dec 4
assign 5 6
dec 5
dec 1
ifneq 5 3 goto 29
ifneq 4 2 goto 27
dec 6
new 8
ifneq 1 6 goto 33
```

### task 4

直接加一即可。

```cpp
1
new 1
```

### task 5

$n^2-1=(n+1)(n-1)=n+(n+1)(n-2)+1$。

```cpp
10
assign 2 1
dec 2
dec 2
new 4
dec 1
assign 3 2
dec 3
new 4
ifneq 3 5 goto 7
iftry 1 goto 5
```

### task 6

$n+2000=n+2\times10\times10\times10$。

```cpp
24
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 3
dec 3
dec 4
assign 5 8
dec 5
assign 6 8
dec 6
assign 7 8
dec 7
new 9
ifneq 7 2 goto 19
ifneq 6 2 goto 17
ifneq 5 2 goto 15
ifneq 3 4 goto 13
```

### task 7

考虑倍增。将 $p_1$ 一直减去 $2$ 的幂次，若大于等于 $0$ 则倍增，次数加一。

```cpp
13
assign 2 1
dec 3
dec 3
dec 2
dec 2
new 7
assign 4 3
assign 5 6
dec 5
dec 3
dec 2
ifneq 5 4 goto 9
iftry 2 goto 6
```

### task 8

考虑将 $n$ 一直减 $2$ 直到 $n<0$，那么 $n$ 只会为 $-1, -2$ 其中一种。而我们需要做的是将 $-1$ 的情况加 $1$，$-2$ 的情况加 $2$。用一个初始为 $-1$ 的变量，减 $1$ 并判断是否相等，相等再执行一遍加 $1$ 操作。

```cpp
6
dec 1
dec 1
iftry 1 goto 1
dec 2
new 3
ifeq 1 2 goto 4
```

### task 9

$\gcd(n,n-4)=\gcd(4,n-4)=\gcd(n\bmod4,4)$。

类似 task 8 的方法我们可以对 $n$ 一直减 $4$，但是这里的处理方法有点不同。这里我将 $-4$ 的情况变为 $0$ 的情况，然后有 $0,-1,-2,-3$ 的情况，需要增加的数分别为 $5,2,3,2$。对于任意数先 `new` 两次，然后减 $2$。如果等于 $-4$ 则跳回第二个 `new`，如果等于 $-2$ 跳回第一个 `new`。

```cpp
18
dec 1
dec 1
dec 1
dec 1
assign 2 1
dec 2
iftry 2 goto 1
dec 3
dec 3
assign 4 3
dec 4
dec 4
new 5
new 5
dec 1
dec 1
ifeq 1 4 goto 14
ifeq 1 3 goto 13
```

### task 10

这里我用了点~~奇淫技巧~~。思路是尽可能的构造一个一次函数，使得满足条件。然后玩弄半天后发现 $y=4.3x$ 最佳，~~似乎没有更好的了~~。下面是函数图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/52aup311.png)

然后如何凑出 $4.3n$ 呢？$4n$ 部分好搞，而 $0.3n$ 部分则可以看成 $\dfrac{n}{3}$，这个只需长度为 $n$，步长为 $3$ 的循环即可，那么就解决了。

```cpp
11
assign 2 1
dec 1
new 4
new 4
new 4
ifneq 1 3 goto 2
dec 2
dec 2
dec 2
new 4
iftry 2 goto 7
```

---

## 作者：ran_qwq (赞：12)

### 前言

- upd on 2024/5/7：修改了一处笔误。

蒟蒻的第一篇黑题题解！

下面按照难度和逻辑顺序写，不按编号顺序。

### Subtask 4

> 输出 $n+1$。

操作 $1$ 就是令 $n\leftarrow n+1$，进行一遍即可。

```
1
new 101
```

### Subtask 1

> 输出 $2n$。

注意到 $n$ 只增不减，$p_i$ 只减不增。考虑让 $p_1$ 从 $n$ 变到 $0$，与此同时将 $n$ 增加 $n$。

```
3
new 101
dec 1
ifneq 1 100 goto 1
```

### Subtask 8

> 输出 $n+(n\bmod2)+1$。

怎么获取 $n\bmod2$ 的值？可以将 $p_1$ 不停减去 $2$（两次 $1$），直到 $p_1<0$。

- 若此时 $p_1=-1$，则 $n\bmod2=1$，再让 $n$ 增加 $2$。
- 否则 $p_1=-2$，让 $n$ 增加 $1$。

可以用 ifeq 操作，每次 $p_2$ 减少 $1$，如果 $p_1=p_2$ 则继续循环。这样能构造出符合题意的操作。

```
6
dec 1
dec 1
iftry 1 goto 1
new 101
dec 2
ifeq 1 2 goto 4
```

### Subtask 5

> 输出 $n^2-1$。

相当于让 $n$ 增加 $n^2-1-n=n^2-n-2+1=(n-2)(n+1)+1$。

嵌套两个次数分别为 $x$ 和 $y$ 的循环，相当于执行 $xy$ 次。所以嵌套两个次数分别为 $n-2$ 和 $n+1$ 的循环即可。

构造 $n+1$ 可以用 `new 1`，同时达到了后面增加 $1$ 的效果，一举两得。

```
10
assign 2 1
dec 2
dec 2
new 1
dec 1
assign 3 2
dec 3
new 101
ifneq 3 100 goto 7
ifneq 1 100 goto 5
```

### Subtask 2

> 输出 $\binom n2$。

高斯求和，$\binom n2=\sum\limits_{i=1}^{n-1}i$。即 $\binom n2-n=\sum\limits_{i=2}^{n-2}i=\sum\limits_{i=1}^{n-3}(i+1)$。

令 $p_1$ 从 $n-3$ 迭代到 $1$，里面用 iftry 迭代 $p_1+1$ 次。

```9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 101
iftry 2 goto 5
dec 1
ifneq 1 100 goto 4
```

### Subtask 6

> 输出 $n+2000$。

$2000=4^2\cdot5^3$。

先预处理出 $-4$ 和 $-5$，再嵌套 $2$ 次 $4$ 和 $3$ 次 $5$ 来制造 $x=-2000$。

最后让 $n$ 增加 $|x|$ 次即可。

```
27
dec 2
dec 2
dec 2
dec 2
dec 5
dec 5
dec 5
dec 5
dec 5
dec 9
assign 10 100
dec 10
assign 11 100
dec 11
assign 12 100
dec 12
assign 13 100
dec 13
dec 4
ifneq 5 13 goto 18
ifneq 5 12 goto 16
ifneq 5 11 goto 14
ifneq 2 10 goto 12
ifneq 2 9 goto 10
dec 14
new 101
ifneq 4 14 goto 25
```

### Subtask 3

> 输出 $600$。

注意到 $5\le n\le100$，所以可以搞出一个值为 $-600$ 的变量，和另外一个值为 $-n$ 的变量，两个相减即可。

```cpp
34
dec 2
dec 2
dec 3
dec 3
dec 3
dec 5
dec 5
dec 5
dec 5
dec 5
dec 6
assign 7 100
dec 7
assign 8 100
dec 8
assign 9 100
dec 9
assign 10 100
dec 10
assign 11 100
dec 11
dec 4
ifneq 5 11 goto 21
ifneq 5 10 goto 19
ifneq 3 9 goto 17
ifneq 2 8 goto 15
ifneq 2 7 goto 13
ifneq 2 6 goto 11
dec 1
dec 12
ifneq 1 100 goto 29
new 101
dec 12
ifneq 4 12 goto 32
```

### Subtask 7

> 输出 $n+\lfloor\log_2n\rfloor$。

可以让另一个变量初始为 $2$，每一次翻一倍（Subtask 1），并让 $n$ 增加 $1$。同时记录一个计数器，初始为 $n$，如果到达 $0$ 则 break，这可以用 iftry 操作。

```cpp
13
dec 4
dec 4
dec 1
dec 1
assign 5 4
assign 7 100
dec 5
dec 7
dec 1
ifneq 4 7 goto 7
assign 4 5
new 101
iftry 1 goto 5
```

### Subtask 9

> 输出 $n+\gcd(n,n-4)+1$。

首先当 $n\bmod4=1$ 或 $3$ 时，$\gcd(n,n-4)=1$；$n\bmod4=2$ 时，$\gcd(n,n-4)=2$；$n\bmod4=0$ 时，$\gcd(n,n-4)=4$。

首先用 Subtask 8 的操作算出 $n\bmod4$ 的值，然后构造一个嵌套循环使得外层 $n$ 为奇数不能再进去，内层 $4\nmid n$ 不能再进去。

```
18
dec 1
dec 1
dec 1
dec 1
assign 2 1
dec 2
iftry 2 goto 1
dec 3
dec 3
assign 4 3
dec 4
dec 4
new 101
new 101
dec 1
dec 1
ifeq 1 4 goto 14
ifeq 1 3 goto 13
```

### Subtask 10

> 输出一个满足 $|x-n\ln n|\le30$ 的一个整数 $x$。

把 $y=n\ln n$ 的图象放 desmos 画一画，发现和 $y=\dfrac{13n}3$ 的图象长得很相似，让 $n$ 增加 $\dfrac{10n}3$ 即可。

外面的 $3n$ 可以嵌套，里面的 $\dfrac n3$ 可以让 $p_1$ 每次减去 $3$ 得到近似值。

```
14
dec 2
dec 2
dec 2
dec 3
assign 4 1
new 101
dec 4
ifneq 4 100 goto 6
ifneq 2 3 goto 4
new 101
dec 1
dec 1
dec 1
iftry 1 goto 10
```

### 后记

一些小小的帮助：

- 写程序时可以缩进，更加直观地找到错误。
- `ifneq x y`（$x\ne y$），里面 $x$ 和 $y$ 有一个自减一次，相当于里面的东西执行 $|x-y|$ 次；`iftry x`（$x\ne0$），里面 $x$ 自减一次，相当于里面的东西执行 $x+1$ 次。
- @liangbowen 大佬写的 [SPJ](https://www.luogu.com.cn/paste/gazy0svu) 可以帮你调试，orzorz。

---

## 作者：_wsq_ (赞：8)

更新于 2025/4/24：针对各方面进行修改和完善，包括但不限于去掉压缩包并改为直接放代码。

洛谷第二个 $107$ 分，写篇题解记录一下。

下面按照对于我而言的主观难度排序。
# Subtask 4
注意到下面 $L_0=1$，说明这个点一定是最简单的。要输出 $n+1$，所以显然直接用一次 `new` 即可。
```
1
new 1
```
# Subtask 1
初始 $p_1=n$，所以我们可以将其不断 `dec` 并与某个为 $0$ 的变量进行比较，这样就能实现 `new` 总共 $n$ 次。
```
3
new 2
dec 1
ifneq 1 8 goto 1
```
# Subtask 8（11 分）
首先每次将 $p_1\gets p_1-2$ 直至 $p_1<0$，就可以区分出奇偶。

然后发现 $0-1=-1$ ，而 $-1$ 对应奇数的情况，所以我们利用 `ifeq` 语句比较 $p_1$ 和 $-1$，就可以实现奇数时多 `new` 一次。
```
6
dec 1
dec 1
iftry 1 goto 1
new 3
dec 5
ifeq 1 5 goto 4
```
# Subtask 3（11 分）
首先很容易想到一种简单的方法构造 $-600$。

我这里采用的是 $2^9+88=600$（详见代码），当然也可以采用其他方法如 $24\times24+24=600$，或者比前面两种简短的 $2\times2\times2\times3\times5\times5=600$。

因为要输出 $600$，所以要执行 $600-n$ 次 `new` 操作。因此，如果我们让一个变量为 $-(600-n)=n-600$，那么就可以让一个初始为 $0$ 的变量不断减少直到等于这个数。而这刚好是我们把前面得到的 $-600$ 加到初始为 $n$ 的 $p_1$ 上的结果。

然后就解决了，具体行数取决于构造 $-600$ 的方法。由于出题人的做法太劣了，导致这个点只要会了基本上就都能拿到 $11$ 分。

[代码](https://www.luogu.com.cn/paste/a9v6guvm)

# Subtask 6（11 分）
方法类似 Subtask 3。

由于标程行数较少，所以我们只能用分解质因数，用 $2^4\times5^3=2000$。比较简单，只要实现 $\times2$ 和 $\times5$ 两种循环即可。

有一个技巧：$\times2$ 时利用 `ifeq` 而不是 `ifneq`，可以省几行。
```
27
dec 500
dec 501
dec 501
dec 501
dec 501
dec 501
new 300
dec 100
ifeq 100 500 goto 7
assign 100 600
dec 101
ifeq 101 500 goto 7
assign 101 600
dec 102
ifeq 102 500 goto 7
assign 102 600
dec 103
ifeq 103 500 goto 7
assign 103 600
dec 104
ifneq 104 501 goto 7
assign 104 600
dec 105
ifneq 105 501 goto 7
assign 105 600
dec 106
ifneq 106 501 goto 7
```
# Subtask 5（11 分）
需要执行 $n^2-n-1$ 次 `new` 语句。$n^2$ 比较好构造，但 $-1$ 没法处理。

可以转换一下：$n^2-n-1=(n^2-n-2)+1=(n+1)(n-2)+1$。

然后就好办了：`iftry` 得到 $n+1$，两次 `dec` 得到 $n-2$，循环嵌套得到最终的答案。

拿到 $11$ 分的方法：我们注意到似乎几乎没有任何点用到了 `new` 语句的返回值，但这个点需要利用这个返回值才能拿到 $11$ 分。首先一定要让 $n+1$ 在外层循环，然后式子多余的 $+1$ 可以在最开始 `new` 一次，刚好得到 $n+1$，把 $n+1$ 那层循环换成 `ifneq` 即可。
```
9
new 2
assign 3 1
dec 3
dec 3
dec 3
new 100
ifneq 3 600 goto 5
dec 2
ifneq 2 600 goto 2
```
# Subtask 2
考虑利用等差数列求和公式。
$$
\begin{aligned}
\frac{n(n-1)}{2}-n&=1+2+3+\cdots+(n-1)-n\\
&=2+3+4+\cdots+(n-2)\\
\end{aligned}
$$
这里利用 `iftry` 的特性，可以实现外层循环从 $n-3$ 至 $1$，内层循环次数为外层循环循环变量加 $1$。
```
9
dec 1
dec 1
dec 1
assign 2 1
new 100
dec 2
iftry 2 goto 5
dec 1
ifneq 1 600 goto 4
```
# Subtask 10（11 分）
发现给定的 $x$ 的范围非常宽松，只要 $n\ln n-30\le x\le n\ln n+30$ 即可。由此，可以想到画出 $n\ln n$ 的函数图像，然后用一个一次函数去逼近。

手工三分，经过几次尝试显然就能看出答案在 $y=3x$ 和 $y=5x$ 之间，然后尝试 $y=\frac{11}{3}x$ 和 $y=\frac{13}{3}x$，发现 $y=\frac{13}{3}x$ 满足题目要求。实现时可以分别实现 $4n$ 和 $\frac{1}{3}n$。

[放一个 desmos 链接。](https://www.desmos.com/calculator/yqrpetwybq?lang=zh-CN)
```
11
assign 2 1
new 300
new 300
new 300
dec 2
ifneq 2 600 goto 2
new 300
dec 1
dec 1
dec 1
iftry 1 goto 7
```
# Subtask 7（11 分）
经过尝试，结合 $\log_2$ 的特性，可以得出一个方法：将 $p_1$ 不断减少一个每次翻 $2$ 倍的数，这里只能用 `iftry` 循环，每次循环 `new` 一次。

我在经过了几次 WA 后，推出：这个每次翻 $2$ 倍的数初始值为 $-2$，但**循环前一定要将 $p_1\gets p_1-2$！**

原因：

- 由于这里循环的特性，在 $p_1<0$ 的那一次循环也会执行 `new` 操作。
- `iftry` 是 $<0$ 不是 $\le0$，所以是 $p_1\gets p_1-2$ 不是 $p_1\gets p_1-1$。

实现上，为了获得 $11$ 分，可以选择合二为一，在将变量翻倍的同时就将 $p_1$ 减少对应的值，不要写两个循环。
```
12
dec 1
dec 1
dec 2
assign 3 2
assign 4 600
dec 4
dec 2
dec 1
dec 1
ifneq 3 4 goto 6
new 800
iftry 1 goto 4
```
# Subtask 9（11 分）
很难，我在草稿纸上推了很长时间。

首先肯定类似 Subtask 8，要根据 $n\mod 4$ 的结果进行分类讨论。但后续的处理很难，由于实际上只能实现 `do-while` 而不能实现 `while`，可以设计出这样的循环结构：

![](https://cdn.luogu.com.cn/upload/image_hosting/gbg3f301.png)

这里由于要把 $1$ 和 $3$ 两个不同的全都筛掉，两层循环都只能用 `ifeq`。因为我们没有加法操作，所以要先进行一次 `dec` 操作，也就是说，要通过 $(n-1)\mod 4$ 的值来判断。这样，才能使 $n\mod 4=0$ 时的结果比 $n\mod 4=2$ 时的结果大。然后就很好构造了，只要使两重循环的 `dec` 操作次数得当，就可以实现图中的结构。
```
17
dec 200
dec 200
dec 200
assign 300 200
dec 300
dec 1
dec 1
dec 1
dec 1
dec 1
iftry 1 goto 7
new 800
dec 1
ifeq 1 300 goto 12
new 800
dec 1
ifeq 1 200 goto 12
```
---
附件：

1. [$107$ 分 AC 记录](https://www.luogu.com.cn/record/157816826)
2. [原题解存档](https://www.luogu.com.cn/problem/U428471)

---

## 作者：jijidawang (赞：8)

~~idea 来源：Graphomata。~~

注意给的几种 if 语句因为只能向前 goto 所以相当于只能写 do...while，没法写一般意义上的 if。

对于一个变量 $n$，如果两个变量分别距离 $n$ 长 $d_1,d_2$，则：
- 可以构造出距离为 $d_1+d_2$ 的变量（分别遍历）。
- 可以构造出距离为 $d_1\cdot d_2$ 的变量（循环嵌套）。

有了加法和乘法，再结合灵活运用循环，就可以做前面的几档了，这里需要注意开局有一个 $n$，不应重复计入贡献：
- Task 1：$n+n$。
- Task 2：$2+\cdots+(n-2)$。
- Task 3：$105+3\times3\times5\times11$，这里 $105$ 可以通过 $105$ 个条件判断完成。   
  （Kaguya 在赛前 1h 以  47 行的成绩爆标并指出有很大优化空间，破防）
- Task 4：$n+1$。
- Task 5：$n+(n+1)(n-2)+1$。
- Task 6：$n+2\times2\times2\times2\times5\times5\times5$。

对于后面的任务：
- Task 7：维护一个变量每次乘二，超了就跳出，否则给 $n$ 自增 $1$。
- Task 8：维护一个变量每次走两步直到小于 $0$，这样可以得到 $-1$ 或 $-2$，先给 $n$ 自增 $1$，判断变量减一后是否等于 $-2$ 即可（这个可以写为 do...while 的模式）。
- Task 9：用类似上一个 Task 的方法计算 $n\bmod 4$ 后讨论即可。
- Task 10：注意到根据调和级数的理论只需要计算 $\sum\lfloor\frac ni\rfloor$（误差经过计算在给定范围内），维护一个变量表示当前的 $i$，再维护另外一个变量每次自增 $i$ 步直到超出范围跳出即可。

从而所有问题全部解决，实现细节可见后文（代码可能和题解有出入）。

***

具体实现：

**Task 1**
```plain
3
dec 1
new 2
ifneq 1 3 goto 1
```

**Task 2**
```plain
9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 3
iftry 2 goto 5
dec 1
ifneq 1 4 goto 4
```

**Task 3**
```plain
233
new 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
assign 2 1
dec 2
dec 2
dec 2
assign 3 2
dec 2
dec 2
assign 4 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
assign 5 1
assign 6 1
assign 7 1
assign 8 1
new 9
dec 8
ifneq 8 3 goto 221
dec 7
ifneq 7 3 goto 220
dec 6
ifneq 6 4 goto 219
dec 5
ifneq 5 2 goto 218
new 1
new 1
new 1
new 1
```

**Task 4**
```plain
1
new 1
```

**Task 5**
```plain
10
assign 2 1
dec 2
dec 2
assign 3 1
dec 3
new 4
iftry 3 goto 5
dec 2
ifneq 2 5 goto 4
new 1
```

**Task 6**
```plain
29
assign 2 1
dec 2
dec 2
assign 3 2
dec 2
dec 2
dec 2
assign 4 1
assign 5 1
assign 6 1
assign 7 1
assign 8 1
assign 9 1
assign 10 1
new 11
dec 10
ifneq 10 2 goto 15
dec 9
ifneq 9 2 goto 14
dec 8
ifneq 8 2 goto 13
dec 7
ifneq 7 3 goto 12
dec 6
ifneq 6 3 goto 11
dec 5
ifneq 5 3 goto 10
dec 4
ifneq 4 3 goto 9
```

**Task 7**
```plain
14
dec 2
dec 2
assign 3 2
assign 4 6
dec 2
dec 4
ifneq 3 4 goto 5
new 5
assign 3 1
assign 4 6
dec 3
dec 4
ifneq 2 4 goto 11
iftry 3 goto 3
```

**Task 8**
```plain
7
assign 2 1
dec 1
dec 1
iftry 1 goto 1
dec 2
new 3
iftry 2 goto 5
```

**Task 9**
```plain
18
dec 2
dec 2
assign 4 2
dec 4
dec 4
dec 1
dec 1
dec 1
dec 1
assign 3 1
dec 3
iftry 3 goto 6
new 5
dec 1
dec 1
ifeq 1 4 goto 13
new 5
ifeq 1 2 goto 13
```

**Task 10**
```plain
14
assign 2 1
assign 4 2
assign 3 1
dec 3
dec 4
iftry 3 goto 4
new 5
assign 3 1
dec 3
dec 4
iftry 3 goto 9
iftry 4 goto 7
dec 1
ifneq 1 6 goto 2
```

---

## 作者：冷月葬T魂 (赞：6)

现在 105 分，爆标 3,5,6,7,8。1,2,4 看起来不可爆，9,10 不会。

整道题的关键在于操作负数。后面说的乘法也是 $-a\times -b=-ab$。

### Sub 4

签。

```plain
1
new 1
```

### Sub 1

学会基本的循环。

```plain
3
new 2
dec 1
ifneq 1 3 goto 1
```

### Sub 6

开始要动脑子了。

首先确定目标：造 $-2000$，然后从 $0$ 降到 $-2000$ 的过程中 $n\leftarrow n+1$。

造数的基本思路是二进制拆分，但是发现 $\times 2$ 要 $4$ 步，完全不可行。其它进制也怎么看都不够用。

另一种思路是乘法。事实上乘法只需要 $6$ 行：（以下是把 $1\times 2$ 放到 $3$ 上）

```plain
dec 6
dec 3
ifneq 6 1 goto 10
assign 6 1000
dec 7
ifneq 7 2 goto 10
```

于是考虑各种 $2000$ 的分解，最后发现 $10\times 10\times 10\times 2$ 很好，并且 $\times 2$ 只需要 $4$ 行还不用造一个数。

所以花 $9$ 行造 $-10$，$6\times 2=12$ 行乘 $10$，$4$ 行乘 $4$，$3$ 行塞到 $n$ 上，共 $28$ 行。

```plain
28
dec 2
dec 2
dec 2
dec 2
dec 2
dec 3
dec 4
dec 4
ifneq 3 2 goto 6
dec 6
dec 8
ifneq 6 4 goto 10
assign 6 1000
dec 7
ifneq 7 4 goto 10
dec 9
dec 11
ifneq 9 8 goto 16
assign 9 1000
dec 10
ifneq 10 4 goto 16
dec 12
dec 13
dec 13
ifneq 12 11 goto 22
new 999
dec 14
ifneq 14 13 goto 26
```

### Sub 3

步数极为宽松，造出 $-600$，再造出 $-(600-n)$，加回去即可。随便实现都行。

```
28
assign 9 1
dec 2
dec 2
dec 2
dec 2
dec 2
dec 3
dec 4
dec 4
ifneq 3 2 goto 7
dec 10
dec 5
dec 5
ifneq 10 4 goto 11
dec 11
dec 6
dec 6
dec 6
ifneq 11 4 goto 15
dec 7
dec 9
ifneq 7 5 goto 20
assign 7 1000
dec 8
ifneq 8 6 goto 20
dec 20
new 999
ifneq 20 9 goto 26
```

### Sub 5

$n^2-1=n+(n+1)(n-2)+1$，乘法即可。爆标的关键好像是第一行用的 `new` 造出 $n+1$ 的同时让 $n\leftarrow n+1$ 了。

```plain
9
new 2
dec 1
dec 1
assign 3 1
dec 3
new 999
ifneq 3 1000 goto 5
dec 2
ifneq 2 1000 goto 4
```

### Sub 2

唐乐，赛后才过。

$\binom{n}{2}=n+(n-2)+(n-1)+\dots+2$，关键在于最后少了个 $+1$ 很难办。正确的解决办法是 $(n-3+1)+(n-2+1)+\dots+(1+1)$，其中每个括号里面的 $+1$ 是因为终止条件是 `iftry` 而不是 `ifneq`。

```plain
9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 999
iftry 2 goto 5
dec 1
ifneq 1 1000 goto 4
```

### Sub 8

`while(n>=0) n-=2`，如果是奇数则最后是 `-1`，否则是 `-2`。

注意到由于 `goto` 只能往前跳，所以所有语句都会被经过至少一次，所以只能有一个 `new`。这一点在下个 Sub 很重要。

```plain
6
dec 1
dec 1
iftry 1 goto 1
new 999
dec 2
ifeq 1 2 goto 4
```

### Sub 9

$+2$ 兜底，偶数 $+1$，$4$ 的倍数再额外 $+2$。

考虑以下循环：

```plain
dec 1
dec 1
dec 2
iftry 1 goto 2
```

会使得 $a_2$ 变成 $-(\lfloor n/2\rfloor+1)$。于是初始的 `new 2` 会得到 $(n+1)-(\lfloor n/2\rfloor+1))=\lceil n/2\rceil$。

再对 $a_2$ 进行同样的操作，操作完之后合法当且仅当 $a_1=a_2=-2$，但是发现这个很不好判。

于是在此之前令 $a_2\leftarrow a_2-1$，就只用判 $a_1=-2,a_2=-1$，这等价于 $a_1=a_2-1$。

然后整点花活调调顺序即可。

```plain
18
new 2
dec 1
dec 1
dec 2
iftry 1 goto 2
dec 2
dec 2
dec 2
iftry 2 goto 7
assign 10 2
dec 3
new 999
dec 3
ifeq 3 1 goto 12
dec 2
ifeq 2 1 goto 12
dec 10
ifeq 10 1 goto 12
```

### Sub 7

我们在上一个 Sub 造出了 $\lceil n/2\rceil$，发现 $\lceil (n-1)/2\rceil=\lfloor n/2\rfloor$，于是在循环之前弄个 `dec 1` 即可。

但是由于最初的 `new` 会额外经过一次，所以直接这样造出来的是 $n+\lfloor\log_2 n\rfloor+1$。

注意到我们才用了 $9$ 步，所以直接多花 $2$ 步使循环终止条件变成 $a_1-1\neq 0$ 即可。

```plain
11
new 999
assign 2 1
dec 1
dec 1
dec 1
dec 2
iftry 1 goto 4
assign 1 2
assign 10 1
dec 10
ifneq 10 1000 goto 1
```

### Sub 10

调和级数近似，但是为了由于每轮会额外来一次 `new`，所以也要整点花活，不细说了~~其实是我已经看不懂我的代码了~~。

```plain
14
assign 8 1
dec 2
dec 1
assign 10 1
dec 2
new 999
assign 4 1000
dec 1
dec 4
ifneq 4 2 goto 8
iftry 1 goto 6
assign 1 10
dec 8
iftry 8 goto 3
```

---

## 作者：_GeorgeAAAADHD_ (赞：5)

第一道不看题解的黑，而且是 $105$ 分的好成绩。

很新而且比较简单的提交答案题。

## 题目大意：

你有一个大小为 $1000$ 的数组 $p$，初始时 $p_1=1$ 其他为 $0$。

程序包含 $6$ 种语句可供使用，分别是：

- `new x`，等同于 `p[x]=++n`；

- `dec x`，等同于 `p[x]--`；

- `assign x y`，等同于 `p[x]=p[y]`；

- `iftry x goto y`，等同于 `if(p[x]>=0)goto line(y)`；

- `ifeq x y goto z`，等同于 `if(p[x]==p[y])goto line(z)`；

- `ifneq x y goto z`，等同于 `if(p[x]!=p[y])goto line(z)`；

你需要用这六种语句解决题目中给出的十个问题。

数据范围：$5\le n \le 100$。最多使用 $10^3$ 个语句和 $10^5$ 次运算次数。

## 分析：

由于题目中对于 $n$ 的操作只有加而没有减，因此我们推出的式子也尽量不要含有减号。

下面我们来逐一分析：

### Task 1：

> 输入 $n$，输出 $2n$。

限制：$3$ 行。

很显然想到用另一个变量代替 $n$，这样只需要对另一个变量进行 $n$ 次 `new` 操作即可。

而进行 $n$ 次操作可以用将 $p_1$ 减至 $0$ 的方法去做。这里使用 `ifneq` 将 $p_1$ 与一个空变量比较即可。

于是代码就呼之欲出了。

```
3
dec 1
new 2
ifneq 1 3 goto 1
```

### Task 2：

>输入 $n$，输出 $\binom{n}{2}$。

限制：$9$ 行。

不难想到 $\binom{n}{2}=\frac{n(n-1)}{2}=1+2+\cdots+(n-2)+(n-1)$，因为给出了 $n$ 所以只需要让 $n$ 加上 $1+2+\cdots+(n-2)+(n-1)-n=2+3+\cdots+(n-3)+(n-2)$ 即可。

于是我们可以循环 $n-3$ 次，第 $i$ 次循环给 $n$ 加上 $i+1$ 即可，这个可以使用 `iftry` 完成多加一次的操作。

代码：

```
9
dec 1
dec 1
dec 1
assign 3 1
dec 1
new 2
dec 3
iftry 3 goto 6
ifneq 1 4 goto 4
```

### Task 3：

>输入 $n$，输出 $600$。

限制：$233$ 行。

本题第一个难点但是限制过宽。

首先想到每次给 $n$ 加一并判断它是不是 $600$ 的倍数（可以拆因数分别判断），然而这样会爆运算次数。

因此考虑构造一个 $600$ 出来然后给 $n$ 加上 $600-n$，但是不好加。所以可以构造 $-600$ 来达到相同的目的。

循环 $2^3\times 5^2\times 3$ 次 `dec` 操作即可。

至于如何加上 $600-n$，可以再用一个空变量，然后在将 $p_1$ 减至 $0$ 的过程中同时把这个空变量减至 $-n$，然后就非常简单了。

代码：

```
34
dec 2
dec 2
dec 3
dec 3
dec 3
dec 5
dec 5
dec 5
dec 5
dec 5 //构造因子 2,3,5
dec 6
assign 7 12
dec 7
assign 8 12
dec 8
assign 9 12
dec 9
assign 10 12
dec 10
assign 11 12
dec 11
dec 4
ifneq 11 2 goto 21
ifneq 10 2 goto 19
ifneq 9 2 goto 17
ifneq 8 3 goto 15
ifneq 7 5 goto 13
ifneq 6 5 goto 11 //构造-600
dec 1
dec 13
ifneq 1 12 goto 29 //构造-n
new 14
dec 13
ifneq 13 4 goto 32
```

### Task 4：

>输入 $n$，输出 $n+1$。

限制：$1$ 行。

不难发现只需要用一个 `new` 操作即可。

代码：

```
1
new 1
```

### Task 5：

>输入 $n$，输出 $n^2-1$。

限制：$10$ 行。

同样是拆减号，发现可以拆为 $n+(n+1)(n-2)+1$，所以只需要让 $n$ 加 $(n+1)(n-2)+1$ 即可。

这个就自己构造 $n-2$ 和 $n+1$ 吧，这里给出代码：

```
10
new 2 //别忘了加一
dec 1
dec 1
assign 5 2 //构造 n+1
assign 4 1 //构造 n-2
new 2
dec 4
ifneq 4 100 goto 6
dec 5
ifneq 5 100 goto 5 //计算 (n-2)*(n+1)
```

~~据说这题可以爆标但是作者太菜没打出来。~~

### Task 6：

>输入 $n$，输出 $n+2000$。

限制：$29$ 行。

按照 $3$ 的方法计算 $2^4\times 5^3$ 即可，只不过这次不用减去 $n$ 了。

代码：

```cpp
27
dec 2
dec 2
assign 5 2
dec 5
dec 5
dec 5 //构造因子 2,5
dec 6
assign 7 100
dec 7
assign 8 100
dec 8
assign 9 100
dec 9
assign 10 100
dec 10
assign 11 100
dec 11
assign 12 100
dec 12
new 1
ifneq 12 2 goto 19
ifneq 11 2 goto 17
ifneq 10 2 goto 15
ifneq 9 2 goto 13
ifneq 8 5 goto 11
ifneq 7 5 goto 9
ifneq 6 5 goto 7 //构造 2000 的同时让 n 自加
```

### Task 7：

>输入 $n$，输出 $n+\lfloor \log_2 n\rfloor$。

限制：$14$ 行。

考虑如何给 $n$ 除以二向下取整。我们可以新开一个变量赋值为当前的 $n$，然后 $n$ 减一时它减二。但是这样不好判断什么时候除完，因为我们只能判断大于等于 $0$ 或者不等于 $0$。

换一种思路，我们新开的那个变量赋值为 $n-1$，这样对于奇数会多减一次才会变为负数，于是这时用 `iftry` 判断即可。

代码：

```
10
assign 2 1
dec 2 //构造 n-1
dec 1
dec 2
dec 2
iftry 2 goto 3 //除以 2
new 3
assign 4 1
dec 4
ifneq 4 5 goto 1 //判断当前 n 是否等于 1
```

### Task 8：

>输入 $n$，输出 $n+(n\bmod 2)+1$。

限制：$7$ 行。

每次给 $n$ 减二一直减到小于 $0$，构造一个 $-1$，判断若当前 $n=-1$ 即 $n\bmod 2=1$ 则加上 $2$ 否则加上 $1$。

代码：

```cpp
6
dec 1
dec 1
iftry 1 goto 1
new 3
dec 2
ifeq 2 1 goto 4 //等于 -1 时说明 n mod 2 = 1，多加一次
```

### Task 9：

>输入 $n$，输出 $n+\gcd(n,n-4)+1$。

限制：$18$ 行。

自己打个表发现 $\gcd(n,n-4)$ 与 $n\bmod 4$ 有关，具体看下表：

| $n\bmod 4$ | $\gcd(n,n-4)$ |
| :----------: | :----------: |
| 0 | 4 |
| 1 | 1 |
| 2 | 2 |
| 3 | 1 |

分类讨论即可。

代码：

```cpp
18
dec 2
dec 2
assign 4 2
dec 4
dec 4 //构造 -2 和 -4
dec 1
dec 1
dec 1
dec 1
assign 3 1
dec 3 
iftry 3 goto 6
new 5
dec 1
dec 1 //第一次到这里时若 p1 = -4 则 n mod 4 = 2，若 p1 = -2 则 n mod 4 = 0
ifeq 1 4 goto 13
new 5
ifeq 1 2 goto 13
```

~~这题似乎也可以爆标。~~

### Task 10：

>输入 $n$，输出一个满足 $|x-n\ln n|\le 30$ 的正整数 $x$。

限制：$14$ 行。

打表发现 $\ln n$ 在 $5\le n \le 100$ 时取值范围约为 $1.6n\le \ln n \le 4.6n$。

于是我们考虑构造一个 $kn$ 使得 $|kn-n\ln n|\le 30$，经过计算后可得 $k$ 的取值范围约为 $4.31\le k\le 4.4$，取一个比较好算的 $k=4+\frac{1}{3}$，发现当 $k=4+\frac{1}{3}$ 时 $|kn-n\ln n|$ 最大约为 $28.1$，按照这个方法构造即可。

代码：

```
12
assign 2 1
dec 1
new 3
ifneq 1 1000 goto 2
dec 3
new 1
ifneq 3 1000 goto 5 //构造 4n
dec 2
dec 2
dec 2
new 1
iftry 2 goto 8 //构造 1/3 n
```

## 总结：

旷野大计算弱化弱化版，但还是感谢出题人给了这么宽的范围。

另外如果有大佬知道第 $5$ 和第 $9$ 个点的爆标做法可以在回复中告诉我。

---

## 作者：int08 (赞：4)

## 前言

谁家大模拟。

这份题解获得了 $107$ 分，也是是题解区 Task #6 #7 #8 #9 目前的最优解。

之后随时研究一下，有新的优化可能会更新博客。

另外：

![](https://cdn.luogu.com.cn/upload/image_hosting/bejofn4m.png)

好的。

---


_"I don't know much about your life beyond these walls,"_

_"The fleeting sense of love within these God-forsaken halls"_

# Solution

## 整体观察

先看题意，显然，这道题和旷野大计算一样，是需要哥们造一台计算机，来完成几个固定的任务，并且有代码行数限制。

哥们大眼观察几条可以使用的命令，发现这样的一些性质：

1. 输入输出都是单一的变量 $n$，而且过程中只增不减。
2. 其它变量只有减少，没有增加方法。
3. 后三个只能往回跳，初步估计是拿来用于循环的。

那哥们就按照子任务难度，各个击破，我会先讲基础做法，再优化行数。

下文中，$L_0$ 是满分行数，$L_b$ 是题解区最优行数，$L$ 是我的行数。
### #4
输出 $n+1$。

$L_0=L_b=L=1$。

显然，直接做一遍 `new` 就搞定。


```
1
new 520
```
### #1
输出 $2n$。

$L_0=L_b=L=3$。

这个需要哥们做 $n$ 遍 `new`，显然需要循环了。

发现哥们只需要对于初始的数一遍一遍减少，然后 `iftry` 判定是否减少到 $0$ 以下。

但是这样会循环共计 $n+1$ 次，需要开始提前减一。


```
4
dec 1
new 2
dec 1
iftry 1 goto 2
```

并不是最优的。

然后哥们发现可以使用 `ifneq` 一个遥远的变量 $0$ 来做到循环 $n$ 次，下文会反复运用这种方案。


```
3
new 2
dec 1
ifneq 1 114 goto 1
```
如果你只会这两个，可以看一下 Task #8 怎么做并自行思考剩下的。

### #8
输出 $n+(n \text{ mod }2)+1$。

$L_0=7,L_b=L=5$。

这道题有点难了，需要哥们区分奇偶。

发现一个能将奇偶分离的方案，每次将 $p_1$ 减二，然后 `iftry` 到小于零停止。

现在，哥们希望当变量为 $-1$ 时候执行两次 `new`，否则执行一次。

那么哥们可以构思这样一个方案，将某一个变量使用一次 `dec` 改为 $-1$ 并判断是否和 $p_1$ 相等，相等就再执行一次。

发现这个方案正好 $-1$ 执行两次循环，$-2$ 执行一次，满足题意。


```
6
dec 1
dec 1
iftry 1 goto 1
dec 2
new 114
ifeq 1 2 goto 4
```

（upd on 2024.9.14）

上午又想了一下，搞出来一个非常简洁的做法：

如果需要新增一个变量，还是略微麻烦，能不能不新增，直接判断 $p_1$ 的值达成回跳一次的目的？

你说：$p_1$ 在每次 $-2$ 的过程中可能丢失了原来的性质啊。

但是 `new` 会把它变回去还会增加 $1$ 啊。

哥们增加一个 `ifeq 1 999` 在 `iftry` 前面，回跳到 `new 1` 就好了。

惊讶于没有人找到这个做法。


```
5
new 1
dec 1
dec 1
ifeq 1 999 goto 1
iftry 1 goto 2
```

### #5
输出 $n^2-1$。

$L_0=10,L_b=L=9$。

$n^2-1=(n+1)(n-1)=n+1+(n+1)(n-2)$，所以说，哥们先造个 $n+1$，再循环 $n-2$ 轮每轮增加 $n+1$ 就好了。

这里需要多重循环，注意外层每次循环，内层循环变量都需要重新赋值回 $n+1$，否则会出错。

（以下所有 $p_{999}$ 都是表示 $0$ 的变量）
```
9
dec 1
dec 1
new 2
assign 3 2
dec 3
new 555
ifneq 3 999 goto 5
dec 1
ifneq 1 999 goto 4
```
### #6
输出 $n+2000$。

$L_0=29,L_b=L=20$。

那么哥们上面才学了多重循环，这里肯定是运用啦！

考虑 $2000=2^4 \times5^3$，那么只需要造一个七重循环即可。

值得注意的是二重循环可以造一个 $p_{101}=-1$ 然后 `ifeq`，而 $x$ 重循环则只能造 $p=-x$ 使用 `ifneq`。

总行数 $28$，刚好爆标。

#### #6 优化

发现一个循环占用 $3$ 行，考虑减少循环重数。

$2000=2\times10^3$，造一个四重循环，行数 $23$ 左右。

$2000=4^2\times 5^3$，由于 $-5$ 可以用 $-4$ 加两行搞定，行数更少，只有 $22$。

最后，发现 $-10$ 可以通过先造 $-5$ 再循环一次，省下 $3$ 行，故最终只用了 $20$ 行。


```
20
dec 101
dec 104
dec 104
dec 104
dec 104
dec 104
dec 666
ifeq 666 101 goto 2
assign 113 999
assign 112 999
assign 111 999
new 199
dec 111
ifneq 111 104 goto 12
dec 112
ifneq 112 104 goto 11
dec 113
ifneq 113 104 goto 10
dec 114
ifeq 114 101 goto 9
```

### #3

输出 $600$。

$L_0=233,L=29,L_b=24$。

懒得优化了，哪天有空再说。

发现这题要输出一个常数，换句话说哥们需要循环 $600-n$ 次。

考虑造一个 $p_{600}=-600,p_2=-n$，然后只需要 `ifneq 2 600` 就可以跑 $600-n$ 次，造 $-600$ 的方案类似 #6。

```
29
dec 101
dec 103
dec 103
dec 103
dec 110
dec 110
dec 110
dec 110
dec 110
dec 666
ifeq 666 101 goto 5
assign 113 999
assign 112 999
assign 111 999
dec 600
dec 111
ifneq 111 110 goto 15
dec 112
ifneq 112 110 goto 14
dec 113
ifneq 113 103 goto 13
dec 114
ifeq 114 101 goto 12
dec 1
dec 2
ifneq 1 999 goto 24
dec 2
new 520
ifneq 2 600 goto 27
```
### #2
输出 $\binom{n}{2}$。

$L_0=L_b=L=9$。

这题不难，但是是 std 压行最智慧的一次了。

容易发现 $\binom{n}{2}=\frac{n(n-1)}{2}$，不过 $n$ 不能减少这个没用。

考虑 $\binom{n}{2}=1+2+3+···+(n-1)$，看起来这个比较好利用，哥们只需要写一个内层循环次数和外层循环变量相关的双重循环即可，不会很难。

由于初始是 $n$，需要增加 $2+3+4+···+(n-2)$，到 $2$ 截止。

官方解法巧妙地运用了 `ifneq` 套 `iftry` 高效率地完成了这一点。


```
9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 555
iftry 2 goto 5
dec 1
ifneq 1 999 goto 4
```

### #7

输出 $n+\lfloor\log_2n\rfloor$。

$L_0=14,L_b=L=8$。

爆最爽的一集。

哥们考虑如何计算 $\log_2n$，一个想法是每次除以 $2$ 看多少次到 $0$。

怎么实现除以 $2$ 呢？哥们开一个一样大的变量，一次减 $2$，本身一次减 $1$，用 `iftry` 停止就完成了。

然后发现这样对于 $n$ 偶数情况一次减了 $\frac{n}{2}+1$，不好，故开头就提前 $-1$。

然后哥们又发现这样正好多加了 $1$，那么开头第一次不能 `new`，要分离开来。

正好 $14$ 行，爆不了啊。
#### #7 优化

为什么一定要单独写一遍第一次除以 $2$？哥们可以把 `new` 放到最后，第一次时候开一个变量判断一下是不是第一次，是就提前回去不 `new`，就好了。


```
11
dec 201
assign 101 1
dec 101
dec 101
dec 101
dec 1
iftry 101 goto 4
dec 202
ifeq 201 202 goto 2
new 114
ifneq 1 999 goto 2
```

别急着走，还可以优化。

哥们发现有两个问题：

1. 第一次不需要 `new`。
2. 每次减多了一点点。

这俩可以平衡，就是说，放手不管，可能就是对的。

尝试一下，发现哥们只需要开头 `dec` 一次，后面直接做，答案就是对的。

```
8
dec 1
assign 101 1
dec 101
dec 101
dec 1
iftry 101 goto 3
new 114
ifneq 1 999 goto 2
```
### #9
输出 $n+\gcd(n,n-4)+1$。

$L_0=18,L_b=L=9$。

容易发现是 #8 加强版。

哥们考虑先造一个类似的东西变成 $-1$ 到 $-4$，然后再利用不同的循环次数完成要求。

|变量 $p_1$|要求|
|:-:|:-:|
|$-1$|$2$|
|$-2$|$3$|
|$-3$|$2$|
|$-4$|$5$|

发现每个 `new` 至少运行一次，所以只能出现两个 `new`，那么 $-4$ 需要回去两次。

搞两个变量，一个每次 $-2$ 另一个每次 $-4$，只要其中一个和 $p_1$ 相等就回去。

这样做正好可以做到 $-2$ 回去一次，$-4$ 回去两次，只需要调整一下顺序就可以控制清楚了。

具体顺序看代码。


```
15
dec 1
dec 1
dec 1
dec 1
iftry 1 goto 1
dec 3
dec 3
dec 3
dec 3
new 114
dec 2
dec 2
new 114
ifeq 2 1 goto 11
ifeq 3 1 goto 6
```

#### #9 优化

$-4$ 改为 assign 之后 $-2$，调整一下顺序，减少了一行。

我感觉还有优化空间。

（upd on 2024.9.14）优化成功，方法类似 #8 优化成 $5$ 行的方案。

```
9
new 1
new 1
dec 1
dec 1
ifeq 1 999 goto 1
dec 1
dec 1
ifeq 1 999 goto 2
iftry 1 goto 3
```



### #10

输出一个和 $n\ln n$ 差小于 $30$ 的数。

$L_0=14,L=12,L_b=11$。

显然现有的东西可能不太支持你算 $\ln$，而且误差挺大的，随便拿一个拟合一下？

根据前人的智慧，哥们发现最优是 $\frac{13n}{3}$，正好满足条件。

那直接算就好了，除以 $3$ 和除以 $2$ 方案类似。

懒得优化。


```
12
assign 101 1
new 2
dec 1
ifneq 1 999 goto 2
new 1
dec 2
ifneq 2 999 goto 5
dec 101
dec 101
dec 101
new 145
iftry 101 goto 8
```

## 后记
很好玩的题目。

各项 $L_b$ 自己去翻其他题解。

如果各位有比我提出的 $L_b$ 更优秀的做法，欢迎私信我。

有一些不想优化了，以后来或者留给后人吧。

![](https://cdn.luogu.com.cn/upload/image_hosting/d3wbuuc7.png)
---


_"And I can hear it in his voice, in every call,"_

_"This girl who's slept a hundred years has something after all..."_

---

## 作者：jimmy9_666 (赞：4)

# P10400 『STA - R5』消失的计算机 题解

[题目传送门](https://www.luogu.com.cn/problem/P10400)

* 注意：本题解以**主观难度**排序，而非题目**原排序**。

## 题目

你有以下 $6$ 个操作：

1. `new x`，令 $n←n+1$，$p_x←n$。
2. `dec x`，令 $p_x←p_x-1$。
3. `assign x y`，令 $p_x←p_y$。
4. `iftry x goto l`，如果 $p_x≥0$，跳转到第 $l$ 条语句。
5. `ifeq x y goto l`，如果 $p_x=p_y$，跳转到第 $l$ 条语句。
6. `ifneq x y goto l`，如果 $p_x≠p_y$，跳转到第 $l$ 条语句。

你要完成 $10$ 个任务：

* 输出 $2n$。
* 输出 $\begin{pmatrix}n\\2\end{pmatrix}$。
* 输出 $600$。
* 输出 $n+1$。
* 输出 $n^2-1$。
* 输出 $n+2000$。 
* 输出 $n+⌊\log_2 n⌋$
* 输出 $n+(n \bmod 2)+1$。  
* 输出 $n+\gcd(n,n−4)+1$。
* 输出一个满足 $∣x−n\ln n∣≤30$ 的正整数 $x$。

## 分析

### Subtask 4

> 输出 $n+1$。  
> 行数限制：$1$ 行。

语句一就是加一，所以直接一句语句一即可。

```
1
new 1
```

### Subtask 1

> 输出 $2n$。  
> 行数限制：$3$ 行。

分析一下语句可知：$n$ 只增不减，$p_i$ 只减不增。
考虑让 $p_1$ 从 $n$ 变为 $0$，让 $n$ 增加 $n$。

```
3
new 2
dec 1
ifneq 2 3 goto 1
```

### Subtask 8

> 输出 $n+(n \bmod 2)+1$。  
> 行数限制：$7$ 行。

这个问的难点在于如何构建 $n \bmod 2$，其实只需要将 $p_1$ 一直减二知道 $p_1<0$。

那么 $n$ 只会为 $−1,−2$ 其中一种。若结果是 $−2$，那么加一个 $2$ 即可；若结果是 $−1$，那么加一个 $1$ 即可。

最后用 `ifeq` 命令，若 $p_1=p_2$ 就继续。每一回让 $p_2$ 减少 $1$ 即可。

```
6
dec 1
dec 1
iftry 1 goto 1
new 3
dec 2
ifeq 2 1 goto 4
```

### Subtask 2

> 输出 $\begin{pmatrix}n\\2\end{pmatrix}$。  
> 行数限制：$9$ 行。

$$\begin{pmatrix}n\\2\end{pmatrix}=1+2+⋯(n-2)+(n-1)=n+2+3+4+⋯+(n−2)$$

忽略式子中的 $n$，循环 $n−3$ 次，每次将 $n$ 加 $i+1$ 即可。

```
9
dec 1
dec 1
dec 1
assign 3 1
dec 1
new 2
dec 3
iftry 3 goto 6
ifneq 1 4 goto 4
```

### Subtask 5

> 输出 $n^2-1$。  
> 行数限制：$10$ 行。

$$n^2-1=n+(n+1)×(n-2)+1$$

忽略原有的 $n$ 后使用嵌套循环实现。

```
10
assign 2 1
dec 2
dec 2
assign 3 1
dec 3
new 4
iftry 3 goto 5
dec 2
ifneq 2 5 goto 4
new 1
```

### Subtask 3

> 输出 $600$。  
> 行数限制：$233$ 行。

$600=24×25$ 直接循环就好了。

```
35
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
assign 3 2
dec 3
dec 4
assign 5 6
dec 5
dec 1
ifneq 5 3 goto 29
ifneq 4 2 goto 27
dec 6
new 7
ifneq 1 6 goto 33
```

### Subtask 6

> 输出 $n+2000$。  
> 行数限制：$29$ 行。

$n+2000=n+2×10×10×10$ 有点像第三问。

```
24
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 3
dec 3
dec 4
assign 5 8
dec 5
assign 6 8
dec 6
assign 7 8
dec 7
new 9
ifneq 7 2 goto 19
ifneq 6 2 goto 17
ifneq 5 2 goto 15
ifneq 3 4 goto 13
```

### Subtask 7

> 输出 $n+⌊\log_2 n⌋$。  
> 行数限制：$14$ 行。

使用倍增思想。

可以让另一个变量初始为 $2$，每一次翻一倍，并让 $n$ 增加 $1$。同时记录一个数，初始为 $n$，如果到达 $0$ 则退出循环。

```
13
dec 2
dec 2
dec 1
dec 1
assign 3 2
assign 4 5
dec 3
dec 4
dec 1
ifneq 2 4 goto 7
assign 2 3
new 6
iftry 1 goto 5
```

### Subtask 9

> 输出 $n+\gcd(n,n−4)+1$。  
> 行数限制：$18$ 行。

先分类讨论一下：

* 当 $n\bmod4=0$ 时，$\gcd(n,n−4)=4$。
* 当 $n\bmod4=1$ 时，$\gcd(n,n−4)=1$。
* 当 $n\bmod4=2$ 时，$\gcd(n,n−4)=2$。
* 当 $n\bmod4=3$ 时，$\gcd(n,n−4)=1$。

那么我们可以用第八问的方式算出 $n\bmod4$ 的值，然后构造一个嵌套循环来判断 $n$ 就好了。

```
18
dec 1
dec 1
dec 1
dec 1
assign 2 1
dec 2
iftry 2 goto 1
dec 3
dec 3
assign 4 3
dec 4
dec 4
new 5
new 5
dec 1
dec 1
ifeq 1 4 goto 14
ifeq 1 3 goto 13
```

### Subtask 10

> 输出一个满足 $∣x−n\ln n∣≤30$ 的正整数 $x$。  
> 行数限制：$14$ 行。

构建一个一次函数使得满足条件。

试了半天，感觉 $y=\displaystyle \frac{13}{3}x$ 是最佳的。

![](https://cdn.luogu.com.cn/upload/image_hosting/mavjtl9d.png)

```
11
assign 2 1
dec 1
new 4
new 4
new 4
ifneq 1 3 goto 2
dec 2
dec 2
dec 2
new 4
iftry 2 goto 7
```

## 一个转载的编辑器

```cpp
#include<bits/stdc++.h>

using namespace std;
int a,n,v[1001],x[1001],y[1001],l[1001],p[1001],wrong;
string z[1001];
void kg(int tab) {
	for(int i=1; i<=tab; i++)cout<<"    ";
}
void lll(int l1,int r,int tab) {
	for(int i=l1; i<=r; i++) {
		if(v[i]==1) {
			kg(tab);
			cout<<"n++;\n";
			kg(tab);
			cout<<"p["<<x[i]<<"]=n;\n";
		}
		if(v[i]==2) {
			kg(tab);
			cout<<"p["<<x[i]<<"]--;\n";
		}
		if(v[i]==3) {
			kg(tab);
			cout<<"p["<<x[i]<<"]=p["<<y[i]<<"];\n";
		}
		if(v[i]==4) {
			kg(tab);
			cout<<"while(p["<<x[i]<<"]>=0){\n";
			lll(l[i],i-1,tab+1);
			kg(tab);
			cout<<"}\n";

		}
		if(v[i]==5) {
			kg(tab);
			cout<<"while(p["<<x[i]<<"]==p["<<y[i]<<"]){\n";
			lll(l[i],i-1,tab+1);
			kg(tab);
			cout<<"}\n";

		}
		if(v[i]==6) {
			kg(tab);
			cout<<"while(p["<<x[i]<<"]!=p["<<y[i]<<"]){\n";
			lll(l[i],i-1,tab+1);
			kg(tab);
			cout<<"}\n";
		}
	}
}
void llll(int l1,int r,int tab) {
	for(int i=l1; i<=r; i++) {
		for(int j=r; j>=l1+1; j--) {
			if(l[j]==i)kg(tab),cout<<"do{\n",tab++;
		}
		if(v[i]==1) {
			kg(tab);
			cout<<"n++;\n";
			kg(tab);
			cout<<"p["<<x[i]<<"]=n;\n";
		}
		if(v[i]==2) {
			kg(tab);
			cout<<"p["<<x[i]<<"]--;\n";
		}
		if(v[i]==3) {
			kg(tab);
			cout<<"p["<<x[i]<<"]=p["<<y[i]<<"];\n";
		}
		if(v[i]==4) {
			tab--;
			kg(tab);
			cout<<"}while(p["<<x[i]<<"]>=0);\n";
		}
		if(v[i]==5) {
			tab--;
			kg(tab);
			cout<<"}while(p["<<x[i]<<"]==p["<<y[i]<<"]);\n";
		}
		if(v[i]==6) {
			tab--;
			kg(tab);
			cout<<"}while(p["<<x[i]<<"]!=p["<<y[i]<<"]);\n";
		}
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>a;
	cin.ignore();
	for(int i=1; i<=a; i++)getline(cin,z[i]);
	for(int i=1; i<=a; i++) {
		int shu=0,c=0,d=1;
		string b;
		for(int j=0; j<=z[i].size(); j++) {
			if(z[i].size()==0||!v[i]&&b==""&&z[i].size()==j) {
				cout<<"错误"<<++wrong<<"：第"<<i<<"行："<<"不可以是空串或全是空格\n";
			}
			if(z[i][j]==' '||j==z[i].size()) {
				if(c==0&&b.size()==0)continue;
				if(b==""&&!v[i])continue;
				if(!v[i]) {
					if(b=="new")v[i]=1;
					else if(b=="dec")v[i]=2;
					else if(b=="assign")v[i]=3;
					else if(b=="iftry")v[i]=4;
					else if(b=="ifeq")v[i]=5;
					else if(b=="ifneq")v[i]=6;
					else {
						cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：没有"<<b<<"这个语法\n";
						break;
					}
				}
				if(v[i]==4&&shu==1||v[i]==5&&shu==2||v[i]==6&&shu==2) {
					if(b!="goto") {
						cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列："<<b<<"应为goto\n";
						break;
					}
					shu++;
				}
				if(v[i]) {
					if(c>0)shu++;
					if(v[i]==1) {
						if(c>1000) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：变量只有1000个\n";
							break;
						}
						if(shu!=1&&j==z[i].size()) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：new 语法的格式应为 new x\n";
							break;
						}
						x[i]=c;
					} else if(v[i]==2) {
						if(c>1000) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：变量只有1000个\n";
							break;
						}
						if(shu!=1&&j==z[i].size()) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：dec 语法的格式应为 dec x\n";
							break;
						}
						x[i]=c;
					} else if(v[i]==3) {
						if(c>1000) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：变量只有1000个\n";
							break;
						}
						if(shu!=2&&j==z[i].size()) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：assign 语法的格式应为 assign x y\n";
							break;
						}
						if(shu==1)x[i]=c;
						if(shu==2)y[i]=c;
					} else if(v[i]==4) {
						if(shu!=3&&j==z[i].size()) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：iftry 语法的格式应为 iftry x y goto l\n";
							break;
						}
						if(shu==3&&c>=i) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：l应小于当前条数"<<i<<"\n";
							break;
						} else {
							if(c>1000) {
								cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：变量只有1000个\n";
								break;
							}
						}
						if(shu==1)x[i]=c;
						if(shu==3)l[i]=c;
					} else if(v[i]==5) {
						if(shu!=4&&j==z[i].size()) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：ifeq 语法的格式应为 ifeq x y goto l\n";
							break;
						}
						if(shu==4&&c>=i) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：l应小于当前条数"<<i<<"\n";
							break;
						} else {
							if(c>1000) {
								cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：变量只有1000个\n";
								break;
							}
						}
						if(shu==1)x[i]=c;
						if(shu==2)y[i]=c;
						if(shu==4)l[i]=c;
					} else if(v[i]==6) {
						if(shu!=4&&j==z[i].size()) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：ifneq 语法的格式应为 ifneq x y goto l\n";
							break;
						}
						if(shu==4&&c>=i) {
							cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：l应小于当前条数"<<i<<"\n";
							break;
						} else {
							if(c>1000) {
								cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<d<<"列：变量只有1000个\n";
								break;
							}
						}
						if(shu==1)x[i]=c;
						if(shu==2)y[i]=c;
						if(shu==4)l[i]=c;
					}
				}
				c=0;
				b="";
				d=j+2;
			} else if(v[i]==0||v[i]==4&&shu==1||v[i]==5&&shu==2||v[i]==6&&shu==2)b+=z[i][j];
			else {
				if(c==0&&z[i][j]=='0') {
					cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<j<<"列：数字开头不能为0/数字不能为0\n";
					break;
				}
				if(z[i][j]>'9'||z[i][j]<'0') {
					cout<<"错误"<<++wrong<<"：第"<<i<<"行：第"<<j<<"列：数字中不能出现不是数字的字符\n";
					break;
				}
				c=c*10+z[i][j]-48;
			}
		}
	}
	if(wrong)return 0;
	printf("编译成功\n");
	printf("请输入n，或输入0编译成c++ while形式，输入1编译成c++ do while形式（需要保证没有交叉循环（不代表不能用嵌套），否则编译出的c++代码会错误）\n");
	while(1) {
		cin>>n;
		if(n<=100&&n>=5||n==0||n==1)break;
		printf("5<=n<=100，请重输\n");
	}
	if(n==0) {

		cout<<"#include<bits/stdc++.h>\n";
		cout<<"using namespace std;\n";
		cout<<"int p[1001],n;\n";
		cout<<"int main(){\n";
		cout<<"    cout<<"<<'"'<<"请输入n\\n"<<'"'<<";\n";
		cout<<"    cin>>n;\n";
		cout<<"    p[1]=n;\n";
		lll(1,a,1);
		cout<<"    cout<<"<<'"'<<"输出的结果是"<<'"'<<"<<n;\n";
		cout<<"    return 0;\n";
		cout<<"}";
		return 0;
	}
	if(n==1) {
		cout<<"#include<bits/stdc++.h>\n";
		cout<<"using namespace std;\n";
		cout<<"int p[1001],n;\n";
		cout<<"int main(){\n";
		cout<<"    cout<<"<<'"'<<"请输入n\\n"<<'"'<<";\n";
		cout<<"    cin>>n;\n";
		cout<<"    p[1]=n;\n";
		llll(1,a,1);
		cout<<"    cout<<"<<'"'<<"输出的结果是"<<'"'<<"<<n;\n";
		cout<<"    return 0;\n";
		cout<<"}";
		return 0;
	}
	int mm=0;
	p[1]=n;
	for(int i=1; i<=a;) {
		mm++;

		if(mm>100000) {
			printf("运行次数超过100000次，或进入死循环");
			return 0;
		}
		if(v[i]==1)n++,p[x[i]]++,i++;
		else if(v[i]==2)p[x[i]]--,i++;
		else if(v[i]==3)p[x[i]]=p[y[i]],i++;
		else if(v[i]==4) {
			if(p[x[i]]>=0)i=l[i];
			else i++;
			continue;
		} else if(v[i]==5) {
			if(p[x[i]]==p[y[i]])i=l[i];
			else i++;
			continue;
		} else if(v[i]==6) {
			if(p[x[i]]!=p[y[i]])i=l[i];
			else i++;
			continue;
		}
	}
	printf("输出的结果是：%d\n",n);
	if(a>1000) {
		printf("条数大于1000条，请寻找更优解\n");
		return 0;
	}
	return 0;
}
```

[原链接](https://www.luogu.com.cn/discuss/820209)

---

## 作者：abc1856896 (赞：4)

蒟蒻第一篇黑题题解！

# 前言

按本人主观难度顺序排列。

# Subtack 4
~~学会写新型代码~~
签到。

```
1
new 1
```

# Subtack 1 
学会循环
循环 $n$ 次再加 $1$ 即可。
```
3
dec 1
new 2
ifneq 1 3 goto 1
```

# Subtack 8
要动一下脑袋了。

我们可以把 $p_1$ 一直减 $2$，相当于减去两个 $1$ 直到 $p_1<0$，那么 $n$ 要么为 $-1$ 要么为 $-2$。若结果是 $-2$，那么加一个 $2$ 即可。

用ifeq命令，若 $p_1=p_2$ 就继续。每一回让 $p_2$ 少 $1$ 即可。

```
6
dec 1
dec 1
iftry 1 goto 1
dec 2
new 3
ifeq 1 2 goto 4
```

# Subtask 2

高斯求和记号。

循环 $n-3$ 次，每次加 $i+1$ 即可。

```
9
dec 1
dec 1
dec 1
assign 3 1
dec 1
new 2
dec 3
iftry 3 goto 6
ifneq 1 4 goto 4
```

# Subtack 5

拆式子。

$n^2-1=(n-1)\times (n+1) =(n-2)\times (n+1) +1$。

```
10
assign 2 1
dec 2
dec 2
new 4
dec 1
assign 3 2
dec 3
new 4
ifneq 3 5 goto 7
iftry 1 goto 5
```

# Subtack 6

$2000=2 \times 10^3$

```
24
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 3
dec 3
dec 4
assign 5 8
dec 5
assign 6 8
dec 6
assign 7 8
dec 7
new 9
ifneq 7 2 goto 19
ifneq 6 2 goto 17
ifneq 5 2 goto 15
ifneq 3 4 goto 13
```

# Subtack 3

$600=3 \times 3 \times 5 \times 11 +105$

$105$ 需要 $105$ 个判断。

```
233
new 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
assign 2 1
dec 2
dec 2
dec 2
assign 3 2
dec 2
dec 2
assign 4 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
assign 5 1
assign 6 1
assign 7 1
assign 8 1
new 9
dec 8
ifneq 8 3 goto 221
dec 7
ifneq 7 3 goto 220
dec 6
ifneq 6 4 goto 219
dec 5
ifneq 5 2 goto 218
new 1
new 1
new 1
new 1
```

# Subtack 7
把任务 $1$ 方法运用到这题里，没超过原来的 $n$ 就一直乘即可。

```
14
dec 2
dec 2
assign 3 2
assign 4 6
dec 2
dec 4
ifneq 3 4 goto 5
new 5
assign 3 1
assign 4 6
dec 3
dec 4
ifneq 2 4 goto 11
iftry 3 goto 3
```

# Subtack 9
找规律。

$$\gcd(n,n-4) = \begin{cases} 4 & n\equiv 0 \pmod 4 \\ 1 & n\equiv 1 \pmod 4 \\ 2 & n\equiv 2 \pmod 4 \\ 1 & n\equiv 3 \pmod 4  \end{cases}$$

得出结论后分类讨论就行了。

用类似于 Subtack 8 的方法算出 $n$ 除以 $4$ 的余数即可。

```
18
dec 2
dec 2
assign 4 2
dec 4
dec 4
dec 1
dec 1
dec 1
dec 1
assign 3 1
dec 3
iftry 3 goto 6
new 5
dec 1
dec 1
ifeq 1 4 goto 13
new 5
ifeq 1 2 goto 13
```

# Subtack 10
$n\ln n$ 的图像如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/5k4z58eq.png)

发现当 $y=\frac{13x}{3}$ 时满足题意。图像如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvnw0y6.png)

写的时候，只要分别写 $4n$ 和 $\frac{n}{3}$ 即可。

```
14
dec 2
dec 2
dec 2
dec 3
assign 4 1
new 101
dec 4
ifneq 4 100 goto 6
ifneq 2 3 goto 4
new 101
dec 1
dec 1
dec 1
iftry 1 goto 10
```

---

## 作者：florrygg (赞：3)

[题面](https://www.luogu.com.cn/problem/P10400)，[~~短暂的最优解~~](https://www.luogu.com.cn/record/158380734)。

# 题意

先解释一个符号：$\gets$ 其实在这道题目当中意思就是 $=$ 希望大家不要像我一样读了半天。

再解释一下 #2 的 $\Large\binom n2$，赛时我还专门在答疑帖问了一下，对于数学不太好的人（就是我）翻译成人话就是 $\Large C_n^2$。

# 思路

该题解只讲爆标，如果不知道怎么 AC 请移步至我们出题者 jijidawang 大大的[题解](https://www.luogu.com.cn/article/wcb68jhu)。

## #3

观察一下标准做法：
```plant
233
new 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
assign 2 1
dec 2
dec 2
dec 2
assign 3 2
dec 2
dec 2
assign 4 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
assign 5 1
assign 6 1
assign 7 1
assign 8 1
new 9
dec 8
ifneq 8 3 goto 221
dec 7
ifneq 7 3 goto 220
dec 6
ifneq 6 4 goto 219
dec 5
ifneq 5 2 goto 218
new 1
new 1
new 1
new 1
```
不难发现因为 $5\le n$ 所以前 4 个 `ifeq 1 3 goto 1` 其实是不需要的（~~水~~），然后就爆标了。
```plant
229
new 1
dec 1
dec 1
dec 1
dec 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
assign 2 1
dec 2
dec 2
dec 2
assign 3 2
dec 2
dec 2
assign 4 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
assign 5 1
assign 6 1
assign 7 1
assign 8 1
new 9
dec 8
ifneq 8 3 goto 217
dec 7
ifneq 7 3 goto 216
dec 6
ifneq 6 4 goto 215
dec 5
ifneq 5 2 goto 214
new 1
new 1
new 1
new 1
```

## #5

不是把 $n^2-1$ 转换成 $n+(n+1)(n-2)+1$ 吗，然后题解就……
```plant
10
assign 2 1
dec 2
dec 2
assign 3 1
dec 3
new 4
iftry 3 goto 5
dec 2
ifneq 2 5 goto 4
new 1
```
题解当中是让 $p_2=n-2\ p_1=n$ 然后内层在 $p_1=0$ 是再执行一次，但是如果让 $p_1=n-2\ p_2=n+1$ 不就可以把 `assign 2 1` 和 `new 1` 合并到一起合并成 `new 2` 然后就爆标了。
```plant
9
new 2
dec 1
dec 1
assign 3 1
dec 3
new 4
ifneq 3 5 goto 5
dec 2
ifneq 2 5 goto 4
```

## #6

本身题解给的是 $\large n+2\times2\times2\times2\times5\times5\times5$，但是我们可以改成 $\large n+2\times10\times10\times10$，这样就可以节省循环了。
```plant
24
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 3
dec 3
dec 4
assign 5 8
dec 5
assign 6 8
dec 6
assign 7 8
dec 7
new 9
ifneq 7 2 goto 19
ifneq 6 2 goto 17
ifneq 5 2 goto 15
ifneq 3 4 goto 13
```

## #7 #8 #9 #10

都只需要在开头处理变量的时候用一点智慧优化一下即可。

原 #7
```plant
14
dec 2
dec 2
assign 3 2
assign 4 6
dec 2
dec 4
ifneq 3 4 goto 5
new 5
assign 3 1
assign 4 6
dec 3
dec 4
ifneq 2 4 goto 11
iftry 3 goto 3
```
现 #7
```plant
13
assign 2 1
dec 3
dec 3
dec 2
dec 2
new 7
assign 4 3
assign 5 6
dec 5
dec 3
dec 2
ifneq 5 4 goto 9
iftry 2 goto 6
```

原 #8
```plant
7
assign 2 1
dec 1
dec 1
iftry 1 goto 1
dec 2
new 3
iftry 2 goto 5
```
现 #8
```plant
6
new 2
assign 2 1
dec 1
ifeq 1 1000 goto 1
dec 1
ifneq 2 1000 goto 2
```

原 #9
```plant
18
dec 2
dec 2
assign 4 2
dec 4
dec 4
dec 1
dec 1
dec 1
dec 1
assign 3 1
dec 3
iftry 3 goto 6
new 5
dec 1
dec 1
ifeq 1 4 goto 13
new 5
ifeq 1 2 goto 13
```
现 #9
```plant
17
dec 200
dec 200
dec 200
assign 300 200
dec 300
dec 1
dec 1
dec 1
dec 1
dec 1
iftry 1 goto 7
new 800
dec 1
ifeq 1 300 goto 12
new 800
dec 1
ifeq 1 200 goto 12
```

原 #10
```plant
14
assign 2 1
assign 4 2
assign 3 1
dec 3
dec 4
iftry 3 goto 4
new 5
assign 3 1
dec 3
dec 4
iftry 3 goto 9
iftry 4 goto 7
dec 1
ifneq 1 6 goto 2
```
现 #10
```plant
11
assign 2 1
dec 1
new 4
new 4
new 4
ifneq 1 3 goto 2
dec 2
dec 2
dec 2
new 4
iftry 2 goto 7
```

# 遗产

留下一个简单的测试程序，需要在运行直接把 $n$ 的值先写好（后台的一个正整数），然后运行，直接粘入指令即可计算出结果。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define endl '\n'

const int Maxn=3001;
const int maxn=1001;
int n=5,p[maxn],t;
string op[maxn],flag;
int x[maxn],y[maxn],l[maxn];

signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	p[1]=n;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		cin>>op[i];
		if(op[i]=="new"||op[i]=="dec")
		{
			cin>>x[i];
		}
		else if(op[i]=="assign")
		{
			cin>>x[i]>>y[i];
		}
		else if(op[i]=="iftry")
		{
			cin>>x[i];
			cin>>flag;
			cin>>l[i];
		}
		else if(op[i]=="ifeq"||op[i]=="ifneq")
		{
			cin>>x[i]>>y[i]>>flag>>l[i];
		}
	}
	for(int i=1;i<=t;i++)
	{
		if(op[i]=="new")
		{
			p[x[i]]=++n;
		}
		else if(op[i]=="dec")
		{
			p[x[i]]--;
		}
		else if(op[i]=="assign")
		{
			p[x[i]]=p[y[i]];
		}
		else if(op[i]=="iftry")
		{
			if(p[x[i]]>=0)
			{
				i=l[i]-1;
			}
		}
		else if(op[i]=="ifeq")
		{
			if(p[x[i]]==p[y[i]])
			{
				i=l[i]-1;
			}
		}
		else if(op[i]=="ifneq")
		{
			if(p[x[i]]!=p[y[i]])
			{
				i=l[i]-1;
			}
		}
	}
	cout<<n<<endl;
	return 0;
}
```

---

## 作者：_IceCream_ (赞：3)

## Content

你有一个长度为 $10^3$ 的序列 $p$，其中 $p_1 = n, p_2 = p_3 = \cdots = p_{10^3} = 0$。需要你在序列上做一些操作，满足询问并输出操作数与每个操作。操作如下：

- `new x`，$p_x \leftarrow n + 1, n \leftarrow n + 1$。
- `dec x`，$p_x \leftarrow p_x - 1$。
- `assign x y`，$p_x \leftarrow p_y$。
- `iftry x goto l`，如果 $p_x \ge 0$，跳到第 $l$ 条操作。
- `ifeq x y goto l`，如果 $p_x = p_y$，跳到第 $l$ 条操作。
- `ifneq x y goto l`，如果 $p_x \neq p_y$，跳到第 $l$ 条操作。

## Solution

其实 $\leftarrow$ 就相当于代码里面的赋值号。

不难发现，前 $3$ 个操作都是修改权值的，后 $3$ 个操作是用来循环的。

然后可以看到，$n$ 可用来计算增加询问，$p$ 序列就是用来计算减少的询问。

`iftry` 和 `ifneq` 不同之处就在于 `iftry` 会多一次循环。

如果你想了解爆标，可以去看看 [florrygg 大佬的题解](https://www.luogu.com.cn/article/tma533uw)。

### Subtask 4

简单，直接 $n + 1$ 就行。

```
1
new 1
```

### Subtask 1

$2n = n + n$，循环 $n$ 次加 $n$ 即可。

```
3
dec 1
new 2
ifneq 1 3 goto 1
```

### Subtask 5

$n^2 - 1 = (n - 1)(n + 1) = n + 1 + (n - 2)(n + 1)$。

$(n - 2)(n + 1)$ 可以直接循环，然后加 $n + 1$ 即可。

```
10
assign 2 1
dec 2
dec 2
assign 3 1
dec 3
new 4
iftry 3 goto 5
dec 2
ifneq 2 5 goto 4
new 1
```

这里要注意 `iftry` 与 `ifneq` 的运用。


### Subtask 2

组合数，$n$ 选 $2$ 的意思，尝试列个表来观察一下。当然如果你已经知道了这条结论可以不看这里。

| $n$ | $2$ | $3$ | $4$ | $5$ | $6$ | $\cdots$ |
|:---:|:---:|:---:|:---:|:---:|:---:|:--------:|
| $\binom{n}{2}$| $1$ | $3$ | $6$ | $10$ | $15$ | $\cdots$ |

可以发现每一项都是在前一项的基础上加 $n - 1$。

于是我们就可以列出来了。

$$ \binom{n}{2} = \dfrac{n(n - 1)}{2} = \sum _ {i = 1} ^ {n - 1} i = n + \sum _ {i = 2} ^ {n - 2} i$$

```
9
dec 1
dec 1
dec 1
assign 2 1
new 3
dec 2
iftry 2 goto 5
dec 1
ifneq 1 4 goto 4
```

### Subtask 8

主要在 $n \bmod 2$ 这里，本质上除法就是不断减，那么我们可以用 `iftry` 不断减 $2$，如果结果为 $-1$ 就加两次，否则就加一次。

```
7
dec 1
dec 1
assign 2 1
iftry 1 goto 1
dec 3
new 4
ifeq 2 3 goto 5
```

### Subtask 6

直接加 $2000$ 肯定会爆，我们可以将 $2000$ 分解成 $2^4 \times 5^3$。

```
28
dec 2
dec 2
dec 5
dec 5
dec 5
dec 5
dec 5
dec 6
assign 7 114
dec 7
assign 8 114
dec 8
assign 9 114
dec 9
assign 10 114
dec 10
assign 11 114
dec 11
assign 12 114
dec 12
new 1
ifneq 12 5 goto 20
ifneq 11 5 goto 18
ifneq 10 5 goto 16
ifneq 9 2 goto 14
ifneq 8 2 goto 12
ifneq 7 2 goto 10
ifneq 6 2 goto 8
```

#### 优化

其实可以发现拆成 $2 \times 10^3$ 更优。

```
24
24
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 3
dec 3
dec 4
assign 5 8
dec 5
assign 6 8
dec 6
assign 7 8
dec 7
new 9
ifneq 7 2 goto 19
ifneq 6 2 goto 17
ifneq 5 2 goto 15
ifneq 3 4 goto 13
```

### Subtask 3

Subtask 6 的升级版。

考虑将 $600$ 拆成 $2^3 \times 3 \times 5^2$，然后再 $n + (600 - n)$ 就可以了。

步数太宽松了，所以这就是爆标后的代码。

还有其他的拆解方式请看其他的题解。

```
34
dec 2
dec 2
dec 3
dec 3
dec 3
dec 5
dec 5
dec 5
dec 5
dec 5
dec 6
assign 7 114
dec 7
assign 8 114
dec 8
assign 9 114
dec 9
assign 10 114
dec 10
assign 11 114
dec 11
dec 12
ifneq 5 11 goto 21
ifneq 5 10 goto 19
ifneq 3 9 goto 17
ifneq 2 8 goto 15
ifneq 2 7 goto 13
ifneq 2 6 goto 11
dec 1
dec 20
ifneq 1 114 goto 29
new 21
dec 20
ifneq 20 12 goto 32
```

### Subtask 7

Subtask 1 的加强版。

看到 $\lfloor \log_2 n \rfloor$ 容易想到倍增。

可以拿 $p_1$ 不断减 $2$ 的幂，用 `iftry` 判断。

但是知道 $2^k - 1 = \sum _ {i = 1} ^ {k - 1} 2^i$，最开始减 $1$。并且 `iftry` 是小于 $0$，所以要每次减 $2$。

```
14
dec 2
dec 2
assign 3 2
assign 4 6
dec 2
dec 4
ifneq 3 4 goto 5
new 5
assign 3 1
assign 4 6
dec 3
dec 4
ifneq 2 4 goto 11
iftry 3 goto 3
```

### Subtask 9

Subtask 8 的升级版。

不难发现这样一个式子。

$$ \gcd (n, n - 4) = \begin {cases} 4 & n \bmod 4 = 0 \\ 1 & n \bmod 4 \in \{1,3\} \\ 2 & n \bmod 4 = 2 \end {cases}$$

所以说我们要像 Subtask 8 那样处理过后来分类讨论。

剪完过后数只有 $-4, -3, -2, -1$ 几种情况，分别需要加 $5, 2, 3, 2$。

那么运用一下循环就可以实现。

```
18
dec 1
dec 1
dec 1
dec 1
assign 2 1
dec 2
iftry 2 goto 1
dec 3
dec 3
assign 4 3
dec 4
dec 4
new 114
new 114
dec 1
dec 1
ifeq 1 4 goto 14
ifeq 1 3 goto 13
```

### Subtask 10

关键点在于 $|x - n \ln n|$ 这里。

我们想到构造一个一次函数实现 $|kn - n \ln n| \le 30$，最后搞出来可以得到 $\dfrac{13}{3}n$，分成 $4n$ 和 $\dfrac{1}{3}n$ 算即可。

```
11
assign 2 1
new 3
new 3
new 3
dec 2
ifneq 2 114 goto 2
dec 1
dec 1
dec 1
new 3
iftry 1 goto 7
```

---

## 作者：dyc2022 (赞：3)

## 0. 鲜花

看到题目名称，第一感觉：![](https://cdn.luogu.com.cn/upload/image_hosting/67l5h148.png)

## 1. 分析操作

- $n$ 只增不减。
- $p$ 只减不增。
- $p_{2 \sim 1000} \le 0$。
- 可以使用减去一个数字的相反数，来实现加一个数。
- 几个 `if` 语句都是 `do while()` 循环。
- 加上一个数可以连续加多个 $1$。

## 2. 各个 test 题解（主观难度排序）。

### #4

板子，直接 `new` 即可。

```
1
new 1
```

### #1

重复加 $n$ 个 $1$ 即可。

```
3
new 2
dec 1
ifneq 1 3 goto 1
```

### #5

注意到 $n^2 -1 = n+(n+1)(n-2)+1$，直接双重循环嵌套即可。

```
10
assign 2 1
dec 2
dec 2
new 4
dec 1
assign 3 2
dec 3
new 4
ifneq 3 5 goto 7
iftry 1 goto 5
```

### #2

$=n+\sum\limits^{n-3}_{i=1}(i+1)$，单重循环即可。

```
9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 3
iftry 2 goto 5
dec 1
ifneq 1 4 goto 4
```

### #6（爆标）

$= n+4^2 \times 5^3$，五重循环即可。

```
24
dec 2
dec 2
dec 2
dec 2
assign 3 2
assign 4 2
dec 4
assign 5 4
assign 6 4
assign 102 999
assign 103 999
assign 104 999
assign 105 999
new 114
dec 105
ifneq 105 2 goto 14
dec 104
ifneq 104 3 goto 13
dec 103
ifneq 103 4 goto 12
dec 102
ifneq 102 5 goto 11
dec 101
ifneq 101 6 goto 10
```

### #3（爆标）

#6 的升级版。

$= n+600-n = n + 2^3 \times 3 \times 5^2 - n$，先 $6$ 重循环循出 $600$，再减去 $n$ 即可。

```
34
dec 2
dec 2
assign 3 2
assign 4 2
assign 5 2
dec 5
assign 6 5
dec 6
dec 6
assign 7 6
assign 102 999
assign 103 999
assign 104 999
assign 105 999
assign 106 999
dec 8
dec 106
ifneq 106 2 goto 16
dec 105
ifneq 105 3 goto 15
dec 104
ifneq 104 4 goto 14
dec 103
ifneq 103 5 goto 13
dec 102
ifneq 102 6 goto 12
dec 101
ifneq 101 7 goto 11
dec 114
dec 1
ifneq 1 999 goto 29
new 514
dec 114
ifneq 114 8 goto 32
```

### #7（爆标）

有趣。直接模拟求 $\log$ 的过程，从 $1$ 开始，每次 $\times 2$ 再和 $n$ 比较。乘二过程参见 #1。

```
13
assign 2 1
dec 3
dec 3
dec 2
dec 2
new 7
assign 4 3
assign 5 999
dec 5
dec 3
dec 2
ifneq 5 4 goto 9
iftry 2 goto 6
```

### #8（爆标）

直接将 $n$ 一直减 $2$，直到 $n < 0$。如果这时 $n = -2$ 说明 $n$ 是偶数，否则为奇数，最后再加上 $n+1$ 即可。

```
6
dec 1
dec 1
iftry 1 goto 1
new 114
dec 2
ifeq 1 2 goto 4
```

### #9

$\gcd(n,n-4) = \gcd(4,n-4) = \gcd(4,n)$。

因此处理出 $n$ 除以四的余数（方法和 #8 一样，就是一直减 $4$），为 $1$ 或 $3$ 公约数为 $1$，否则若为 $2$，最大公约数为 $2$；否则为 $4$。

具体操作为先 `new` 两次，然后判断余数是否为 $2$ 或 $4$，如果是，则再返回前面多进行一次或两次操作。

```
18
dec 1
dec 1
dec 1
dec 1
assign 2 1
dec 2
iftry 2 goto 1
dec 3
dec 3
assign 4 3
dec 4
dec 4
new 5
new 5
dec 1
dec 1
ifeq 1 4 goto 14
ifeq 1 3 goto 13
```

### #10（爆标）

瞪眼可得 $n \ln n$ 约等于 $\frac{13}{3}n$，拆开得 $n+3n+\frac{n}{3}$。$3n$ 好处理，加三次 $n$ 即可。 $\frac{n}{3}$ 则是从 $n$ 开始一直减 $3$ 直到不能再减。

```
11
assign 2 1
new 114
new 114
new 114
dec 2
ifneq 2 999 goto 2
dec 1
dec 1
dec 1
new 114
iftry 1 goto 7
```

## 成绩

$105\text{pts}$ AC。

---

## 作者：vzcx_host (赞：2)

完全独立做出的 107 分做法。

推荐顺序：4，1，2，8，5，7，6，3，9，10，题解顺序将按这个顺序进行。

Upd 24/6/13：修订了一个错误，Task 9 新增一种更优的做法。

### Task 4
$L=1,L_0=1$。

直接 $+1$ 即可，送大分。
```cpp
cnew(1);
```
### Task 1
$L=3,L_0=3$。

$2n=n+n$，所以我们只需要进行 $n$ 次 $+1$ 操作。$p_1=n$，所以每个循环对 $p_1$ 减 $1$ 即可。
```cpp
cdec(1);
cnew(999);
cifneq(1,1000,1);
```
### Task 2
$L=9,L_0=9$。

$\text{原式}=1+2+3+\cdots+(n-1)=n+2+3+4+\cdots+(n-2)$，忽略 $n$，从 $n-2$ 枚举到 $2$ 即可。

用 `ifneq` 套 `iftry` 可以实现到 $2$ 截止。
```cpp
cdec(1);
cdec(1);
cdec(1);
cassign(2,1);
cdec(2);
cnew(999);
ciftry(2,5);
cdec(1);
cifneq(1,1000,4);
```
### Task 8
$L=6,L_0=7$。

容易发现我们要的数一定是个奇数，如果不是奇数我们就 $+1$ 再判一次，这一次一定是奇数。
```cpp
cdec(2);
cnew(1);
cdec(1);
cdec(1);
ciftry(1,3);
cifneq(1,2,2);
```
### Task 5
$L=9,L_0=10$。

$n^2-1=(n+1)(n-1)=(n+1)+(n+1)(n-2)$，可以使用一次 $+1$ 让输入的 $n$ 变成 $n+1$，两重循环做乘法即可。
```cpp
cdec(1);cdec(1);//p[1]=n-2
cnew(2);//p[2]=n+1
cdec(1);
cassign(3,2);
cdec(3);
cnew(4);
cifneq(3,1000,6);
cifneq(1,1000,4);
```
### Task 7
$L=12,L_0=14$。

找到最大的 $k$ 使得 $n\ge2^k$，要求执行 $k$ 次 $+1$。

显然倍增，若当前的 $n-2^k\ge0$，则将 $k$ 加 $1$，可以通过维护 $2^k$ 来计算 $n-2^{k+1}$。
```cpp
cdec(1);
cdec(1);
cdec(2);
cnew(5);
cassign(3,2);
cassign(4,1000);
cdec(4);
cdec(2);
cdec(1);
cdec(1);
cifneq(4,3,7);
ciftry(1,4);//p[1]=n-2^k,p[2]=2^(k-1)
```
### Task 6
$L=22,L_0=29$。

在 $n$ 的基础上加 $2000=4^2\times5^3$，因此 $n$ 的值没有任何意义，只需要做 $2000$ 次 $+1$，五重循环计算乘积即可。

枚举 $i$ 轮不一定非得从 $i$ 枚到 $0$，也可以从 $0$ 枚到 $-i$。我们无法凭空产生 $4,5$，但可以凭空产生 $-4,-5$。
```cpp
cdec(2);cdec(2);cdec(2);cdec(2);//p[2]=-4
cassign(1,2);cdec(1);//p[1]=-5
cassign(4,1000);int b4=cdec(4);
cassign(5,1000);int b5=cdec(5);
cassign(6,1000);int b6=cdec(6);
cassign(7,1000);int b7=cdec(7);
cassign(8,1000);int b8=cdec(8);
cnew(3);
cifneq(8,2,b8);
cifneq(7,2,b7);
cifneq(6,1,b6);
cifneq(5,1,b5);
cifneq(4,1,b4);
```
### Task 3
$L=26,L_0=233$。

与 Task 6 唯一不同的点是我们需要从 $n$ 加到 $600$，因此我们稍微变化一下，预处理出 $-600$ 后从 $-n$ 枚举到 $-600$。

$600=4\times5^2\times6$，由于只有一层 $-4$ 因此循环展开可以省掉一次操作。
```cpp
cdec(2);cdec(2);cdec(2);cdec(2);cdec(2);//p[2]==-5
cassign(3,2);cdec(3);//p[3]==-6
cassign(4,1000);int b4=cdec(4);
cassign(5,1000);int b5=cdec(5);
cassign(6,1000);int b6=cdec(6);
cdec(7);cdec(7);cdec(7);cdec(7);
cifneq(6,2,b6);
cifneq(5,2,b5);
cifneq(4,3,b4);//p[7]==-600
int c=cdec(1);cdec(8);cifneq(1,1000,c);//p[8]==-n
int d=cnew(1);cdec(8);cifneq(8,7,d);
```
### Task 9
$L=14,L_0=18$。

$\gcd(n,n-4)=\gcd(n,4)$，而后者的取值显然取决于 $n\bmod4$ 的值，当 $n\bmod4$ 分别取 $0,1,2,3$ 时，我们要做 $a=5,2,3,2$ 次 $+1$，而不停做四次 $-1$ 后值为 $b=-4,-3,-2,-1$。

可以发现除了 $b=-3$ 时 $a=(-b)+1$，容易想到将 $-3$ 转变为 $-1$，但由于不能加不是很好做。

所以考虑先将 $n$ 做一点变换，将 $n$ 减掉 $1$ 再考虑 $n\bmod4$，容易发现 $b=-4,-3,-2,-1$ 对应的 $a=2,3,2,5$，这次可以发现除了 $b=-2$ 时 $a+(-b)=6$，将 $-2$ 转变为 $-4$ 是简单的，从计算 $n\bmod4$ 中的四次 $-1$ 中抽出两次即可。
```cpp
cdec(2);cdec(2);//p[2]=-2
cassign(3,2);cdec(3);cdec(3);cdec(3);cdec(3);//p[3]=-6
cdec(1);//先行变换
cdec(1);cdec(1);cdec(1);cdec(1);ciftry(1,9);//mod4
cifeq(1,2,11);//第11条指令为上一行的第3条指令
cnew(4);cdec(1);cifneq(1,3,15);//L=17
```
上一个做法由于要构造 $-6$ 用了太多步数，将 $n$ 减掉 $2$ 再考虑 $n\bmod4$，$b=-4,-3,-2,-1$ 对应 $a=3,2,5,2$，将 $a=5$ 的 $b$ 下降到 $-6$，$a=2$ 的 $b$ 下降到 $-3$，就有 $a+b=-1$，被修改的 $b$ 最小为 $-2$，节约了大量构造的步数。
```cpp
cdec(2);
cdec(3);cdec(3);
cdec(1);cdec(1);
cdec(1);cdec(1);cdec(1);cdec(1);ciftry(1,6);
cifeq(1,2,8);cifeq(1,3,6);
cnew(3);cdec(2);cifneq(2,1,13);//L=15
```
受 @54Tiger 题解启发，作者想到一个 $L=14$ 的做法，由于 $5=3+2,3=2+1$，将 $n$ 减掉 $1$，$a=-1$ 时做两次 $+1$ 后转向 $-3$，$a=-3$ 时做一次 $+1$ 后转向 $-4$。
```cpp
cdec(1);cdec(2);cdec(3);cdec(3);cdec(3);
cdec(1);cdec(1);cdec(1);cdec(1);ciftry(1,6);
cnew(4);cifeq(1,3,9);cnew(4);cifeq(1,2,8);
```
### Task 10
$L=11,L_0=14$。

打表发现 $\bigcap_{k=5}^{100} [(k\ln k-30)/k,(k\ln k+30)/k]$ 接近 $[4.3,4.4]$，取 $t=4\frac{1}{3}$ 较为合适，对于 $n$，做 $(t-1)n$ 次 $+1$ 即可。
```cpp
cassign(2,1);
int a=cnew(3);cnew(3);cnew(3);cdec(2);cifneq(2,1000,a);//3n
int b=cnew(3);cdec(1);cdec(1);cdec(1);ciftry(1,b);//n/3
```

---

## 作者：Bismuth_Sulfate (赞：1)

## 题意简述

有 $6$ 种语句，在使用不超过 $1000$ 条命令且使用变量的标号不超过 $1000$ 的情况下，实现这 $10$ 个问题。

## 题意分析

### 语句与变量

对于 $n$：可以看出，能操作 $n$ 的语句只有 `new` 命令能做到，并且只能使 $n$ 增加。因此 $n$ 只增不减。

对于 $p_x$：在不使用 `assign` 和 `new` 语句的情况下，$p_x$ 只减不增。

对于三个跳转语句：由于它们只能往前跳转，因此它们等价于 do-while 循环，也因此没有 if 语句。

### 评分标准

看起来很复杂，其实只有很简单的一段话：

> 若代码本身就过不了，测试点不得分。  
> 若代码本身过得了：  
> $L \lt L_0$ 时，测试点得 $11$ 分，测试点 AC。  
> $L = L_0$ 时，测试点得 $10$ 分，测试点 AC。  
> $L > L_0$ 时，测试点得部分（一个很复杂的公式）分，测试点 WA。

也就是说，要想 AC，我们需要保证 $L \le L_0$。

## 准备工作

### 基本实现

#### 循环

例如，我们需要循环 $k$ 次。

只需将执行 `dec a` 命令 $k$ 次（即 $p_a \gets -k$），然后以 $p_b$ 作为循环变量，每次循环执行一次 `dec b` ，最后判断一行 `ifneq a b goto (循环的开始行)` 即可实现循环。

#### 运算

##### 加法

例如，我们需要将 $n$ 加 $k$。

很明显，循环 $k$ 次，每次使用 `new` 命令使 $n$ 自增 $1$ 即可。

##### 乘法

例如，我们需要将 $n$ 乘 $k$。

$p_a \gets 1-k$，$p_b \gets -n$，然后写一个双重循环，执行 $n \times (k-1)$ 次 `new` 命令即可。

### 良好的码风

由于这个“编程语言”没有注释可写，因此有一个良好的码风在这里尤为重要。我定下两个码风：

1. 在需要使用 $0$ 时，永远使用 $p_{1000}$。也正因如此，$p_{1000}$ 应永远保持值为 $0$ 不变。
2. 在使用 `new` 命令仅仅为了令 $n$ 自增 $1$ 时，永远写 `new 999` 。也正因如此，我从不使用 $p_{999}$。

## 解答

接下来测试点按 $L_0$ 升序排序解答。

主观难度指我认为该测试点的难度。

为了防止混乱，接下来记 $n_s$ 为初始时的 $n$ 值，$n$ 为变量 $n$ 本身。

### 测试点 \#4

主观难度：$1/10$

输入 $n$，输出 $n+1$，很明显直接 `new` 一下就可以了。

代码：
```plain
1
new 999
```

### 测试点 \#1

主观难度：$2/10$

输入 $n$，输出 $2n$。由于有 $p_1$ 这一个现成的循环变量，我们可以把代码压到 $3$ 行并 AC。

代码：
```plain
3
dec 1
new 999
ifneq 1 1000 goto 1
```

### 测试点 \#8

主观难度：$5/10$

要求得知 $n \bmod 2$ 的值。可以将 $p_1$ 不断减 $2$ 直至减成负数。但我改换了一下思路，先将 $p_1$ 减 $1$，然后不断减 $2$ 直至减成负数，这样：  
若 $n \bmod 2 = 0$，则进行上述操作后 $p_1 = -1$；  
若 $n \bmod 2 = 1$，则进行上述操作后 $p_1 = -2$。

然后设 $p_2$ 为 $-1$，先使 $n$ 自增一次 $1$，然后若 $p_1 \ne p_2$ 则使 $n$ 再自增一次 $1$。

代码：
```plain
7
dec 1
dec 1
dec 1
iftry 1 goto 2
dec 2
new 999
ifneq 1 2 goto 5
```

### 测试点 \#2

主观难度：$3/10$

看到这个要求时我愣了一下，然后查到 $\binom n2$ 指的就是 $C^n_2$ 的意思。于是，我列出 $\binom n2$ 的式子：
$$\frac{n\times(n-1)}{2\times1}$$
定睛一看，这不就是高斯求和吗？上式不就是 $\sum_{k = 1}^{n-1}k$ 的值吗？

由于 $n$ 初始等于 $n_s$，整理一下，得 $\sum_{k = 1}^{n-1}k = n+\sum_{k = 2}^{n-2}k$。

拿这个式子去求和即可。

代码：
```plain
9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 999
iftry 2 goto 5
dec 1
ifneq 1 1000 goto 4
```

### 测试点 \#5
主观难度：$3/10$

由于平方差公式，$n^2-1 = (n+1)(n-1)$，因此我们只需要求后面这个式子即可。  
我的思路是先执行一次 `new 2` 给 $p_2$ 赋值 $n+1$，然后注意到 $n$ 此时等于 $n_s+1$，因此我们只需要再使 $n$ 增加 $(n+1)(n-2)$ 即可。可以给 $p_1$ 赋值 $n-2$。

代码：
```plain
9
dec 1
dec 1
new 2
assign 3 1
dec 3
new 999
ifneq 3 1000 goto 5
dec 2
ifneq 2 1000 goto 4
```
### 测试点 \#7
主观难度：$9/10$

难度拉满。我的思路是不断生成 $2^k$，然后让 $n$ 自增 $1$，计算 $n_s-2^k$ 的值，若为正数则继续生成 $2^{k+1}$。

代码：

```plain
13
assign 2 1
dec 3
dec 3
dec 2
dec 2
new 999
assign 4 3
assign 5 1000
dec 5
dec 3
dec 2
ifneq 5 4 goto 9
iftry 2 goto 6
```
### 测试点 \#10
主观难度：$10/10$

难度拉满。首先，我们直接计算 $n\ln n$ 是完全不可能的，你就想想无理数 $e$ 的整次幂怎么算吧。因此，我们能且只能投机取巧。

观察 $n\ln n$ 的函数图像，我们发现它长得很像一次函数。再加上题目给了 $30$ 的容错范围，我们也许能用一次函数水过：  
![](https://cdn.luogu.com.cn/upload/image_hosting/4fj9rs5g.png)  
上图中，红线是 $n\ln n$ ，蓝色区域是所有满足 $|x - n\ln n| \le 30$ 的 $x$。

经测试~~以及前人的智慧~~，$y=4n+ \lfloor\frac{1}{3}n\rfloor$ 这一函数是最吻合这一区域的。因此，我们可以通过输出 $4n+ \lfloor\frac{1}{3}n\rfloor$ 的方式水过这个测试点。

代码：
```plain
12
dec 1
assign 2 1
dec 1
new 999
new 999
new 999
iftry 1 goto 3
dec 2
dec 2
dec 2
new 999
iftry 2 goto 8
```

### 测试点 \#9
主观难度：$7/10$

这题要求 $\gcd(n, n - 4)$。我们能否化简它呢？能：
$$\gcd(n, n - 4)=\gcd(4,n-4)=\gcd(4,n \bmod 4)$$
换句话说，和测试点 \#8 一样，只需要不断对 $p_1$ 减去 $4$ 即可。这里我采用另一种方法，把 $-1,-2,-3,-4$ 改成 $0,-1,-2,-3$，分别对应 $\operatorname{mod}4$ 后余数为 $0,1,2,3$。它们要使 $n$ 分别增加 $5,2,3,2$，因此我们可以先将 $n$ 增加 $2$，然后将 $p_1$ 减少 $2$，如果此时 $p_1$ 等于 $-2$ 则跳转回去让 $n$ 再增加 $2$，如果此时 $p_1$ 等于 $-4$ 则跳转回去让 $n$ 再增加 $1$。

代码：
```plain
18
dec 1
dec 1
dec 1
dec 1
assign 2 1
dec 2
iftry 2 goto 1
dec 12
dec 12
assign 14 12
dec 14
dec 14
new 999
new 999
dec 1
dec 1
ifeq 1 12 goto 13
ifeq 1 14 goto 14
```

### 测试点 \#6
主观难度：$4/10$

第一眼，这题可不可以用 \#4 同款方法切掉。

第二眼，$2000$ 还是有点太大了。

这时乘法终于派上用场了，$2000=4^2\times5^3$，构造即可。

代码：
```plain
22
dec 2
dec 2
dec 2
dec 2
assign 10 2
dec 10
dec 3
dec 5
dec 11
dec 13
dec 15
new 999
ifneq 15 10 goto 11
assign 15 1000
ifneq 13 10 goto 10
assign 13 1000
ifneq 11 10 goto 9
assign 11 1000
ifneq 5 2 goto 8
assign 5 1000
ifneq 3 2 goto 7
assign 3 1000
```
### 测试点 #3
主观难度：$5/10$

思路：构造 $-n$ 和 $-600$，这样就能循环 $600-n$ 次，就可以输出固定的 $600$ 了。$600=(4\times6)\times(4\times6+1)$，构造即可。

代码：
```plain
24
dec 4
dec 4
dec 4
dec 4
assign 6 4
dec 6
dec 6
dec 14
dec 16
dec 2
ifneq 16 6 goto 9
assign 16 1000
ifneq 14 4 goto 8
assign 3 2
dec 3
dec 22
dec 23
dec 1
ifneq 23 3 goto 17
assign 23 1000
ifneq 22 2 goto 16
dec 40
new 999
ifneq 40 1 goto 22
```

省流：A掉了。

---

## 作者：liuli688 (赞：1)

## 前置部分
### 我的编号方法
在代码里可能会出现一些特殊编号，解释如下。

- $1000$：用于判断 $0$ 的空位，始终为 $0$。如判断 $p_x$ 是否等于 $0$：`ifeq x 1000 goto ...`。

- $999$：在 $1$ 号位被占用的情况下执行 `new` 操作的位。如 $n \gets n + 1$：`new 999`。

- $1\text x$（$\text x$ 表示一个数字）：$\text x$ 的基准位。如判断 $p_2$ 是否等于 $-2$：`ifeq 2 12 goto ...`。（当然 $p_{12}$ 已经事先被置为 $-2$）
- $x$：如无特殊说明，$x$ 代表在 $[1,1000]$ 范围内任一一个整数。
### 基础操作
- $n \gets n + p_x$：
  
  想象一下，如果是在正常语言里，你会写 `n += p[x]` 或 `n := n + p[x]`。可是这种语言一次只能加 $1$，怎么办？
  
  由于一次只能加 $1$，那么方法显然是将 $p_x$ 拆成 $p_x$ 个 $1$。那么写法应该很明确了：
  ```
  dec x
  new 999
  ifneq x 1000 goto 1
  ```
  不过，前提是 $p_x > 0$。如果 $p_x$ 小于 $0$ ，增加 $-p_x$ 次，那么应当这么写：
  ```
  dec y
  new 999
  ifneq x y goto 1
  ```
  其中 $y$ 是任意一个空变量。其实这很像减法。
 - $n \gets n \times p_x$：
   
   只要嵌套两层加法即可。
   ```
   dec 1
   assign 2 x
   dec 2
   new 999
   ifneq 2 1000 goto 3
   ifneq 1 1000 goto 1
   ```
- $n \gets n \bmod p_x$：
   
  取模似乎比较难。不过我们仔细想一想，取模就是得到这个数的余数，所以我们需要进行除法。那么，除法怎么做？回想一下，应该是将 $n$ 重复减 $p_x$，直到 $n < 0$。
  
  所以，我们便可以用刚才的加法（减法）来求解了。
  ```
  assign 2 1000
  dec 2
  dec 1
  ifneq 2 x goto 2
  iftry 1 goto 1
  new 999
  dec 3
  ifeq 1 3 goto 6
  ```
  其中 $p_x$ 为模数的相反数。即这段代码实现的功能是 $n \gets n \bmod -p_x$。
### 注意事项
- `iftry` 是**大于等于** $0$，`ifeq x 1000` 是等于 $0$，请注意区分。
- **增加**和**输出**是两个不同的概念。如果要增加 $x$，那么应该输出 $n+x$。
- $n$ 只升不降，$p_x$ 只能**可控**地降（而升不可以，因为只能用 `new` 指令）。
## 思路 & 代码
### Task 1
$2n$ 即 $n + n$，直接使用前置部分的加法即可。
```
3
dec 1
new 2
ifneq 1 1000 goto 1
```
### Task 2
原式 $= 1 + 2 + \dots + (n-1)$。由于是**输出**，所以 $n$ 应增加 $2 + 3 + \dots + (n-2)$。可是这样不好循环怎么办？我们只需将每个数减 $1$，然后用 `iftry` 代替 `ifneq x 1000` 即可把循环次数补回来。
```
9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 999
iftry 2 goto 5
dec 1
ifneq 1 1000 goto 4
```
### Task 3
注意到 $5 \le n \le 100$。那么，我们应让 $n$ 增加 $600 - n$。所以，问题便转换成构造 $600 - n$。那么这不就是一个减法问题吗？只要构造 $600$ 即可。$600$ 可以通过循环，用 $2^3 \times 3 \times 5^2$ 构成。

爆标 $199$ 行。
```
34
dec 12
dec 12
dec 13
dec 13
dec 13
dec 15
dec 15
dec 15
dec 15
dec 15
dec 2
assign 3 1000
dec 3
assign 4 1000
dec 4
assign 5 1000
dec 5
assign 6 1000
dec 6
assign 7 1000
dec 7
dec 10
ifneq 7 15 goto 21
ifneq 6 15 goto 19
ifneq 5 13 goto 17
ifneq 4 12 goto 15
ifneq 3 12 goto 13
ifneq 2 12 goto 11
dec 1
dec 11
ifneq 1 1000 goto 29
new 999
dec 11
ifneq 10 11 goto 32
```
### Task 4
不用多说。
```
1
new 1
```
### Task 5
分解 $n^2 - 1$，得 $(n+1)(n-1)$。由于也是**输出**，所以式子应减 $n$，变为 $(n+1)(n-2) + 1$。于是使用乘法，问题就十分简单了。
```
10
assign 3 1
dec 3
dec 3
new 1
dec 1
assign 2 3
new 4
dec 2
ifneq 2 1000 goto 7
ifneq 1 1000 goto 5
```
### Task 6
最简单的办法是 `new` $2000$ 次，但是行数显然超标，所以难点在于构造 $2000$（实际是 $-2000$）。$2000 = 2^4 \times 5^3$，为使行数最少，我决定用 $4^2 \times 5^3$ 来构造。

爆标 $5$ 行。
```
24
dec 14
dec 14
dec 14
dec 14
dec 15
dec 15
dec 15
dec 15
dec 15
dec 2
assign 3 1000
dec 3
assign 4 1000
dec 4
assign 5 1000
dec 5
assign 6 1000
new 1
dec 6
ifneq 6 15 goto 18
ifneq 5 15 goto 16
ifneq 4 15 goto 14
ifneq 3 14 goto 12
ifneq 2 14 goto 10
```
### Task 7
还原求 $\log$ 的场景。用变量记录底数，$n$ 增加指数个，
若计数器数量到达底数则底数翻倍，$n \gets n + 1$。

爆标 $1$ 行。
```
13
dec 1
dec 1
dec 2
dec 2
assign 12 2
assign 10 1000
dec 12
dec 10
dec 1
ifneq 10 2 goto 7
new 999
assign 2 12
iftry 1 goto 5
```
### Task 8
套用前置部分的取模即可。

爆标 $1$ 行。
```
6
dec 1
dec 1
iftry 1 goto 1
new 3
dec 2
ifeq 1 2 goto 4
```
### Task 9
分类讨论。
- 当 $n \bmod 4 = 0$ 时，$\gcd(n,n-4) = 4$。
- 当 $n \bmod 4 = 1$ 时，$\gcd(n,n-4) = 1$。
- 当 $n \bmod 4 = 2$ 时，$\gcd(n,n-4) = 2$。
- 当 $n \bmod 4 = 3$ 时，$\gcd(n,n-4) = 1$。

所以，我们只要用 Task 8 的方法求出模数，再判断：用一个循环分离奇偶数，再用一个循环分离 $2$ 和 $4$。
```
18
dec 1
dec 1
dec 1
dec 1
assign 2 1
dec 2
iftry 2 goto 1
dec 12
dec 12
assign 14 12
dec 14
dec 14
new 999
new 999
dec 1
dec 1
ifeq 1 14 goto 14
ifeq 1 12 goto 13
```
### Task 10
首先想到的是构造与 $n \operatorname{ln} n$ 尽可能相近的数，为 $n \log_3 n$。可是这样还是有误差，那么再加常数，得 $n \log_3 n + 16$（因为 $16 = 2^4$）。可是行数超标。

我们将 $n \operatorname{ln} n$ 打出表来，发现相邻两数的差变化不大，这提醒我们可以用形如 $y = kx$ 的值来求解。经过尝试，发现在 $4$ 至 $5$ 范围内比较接近。最终我使用 $y = \frac {13n} 3$。凑 $4$ 非常简单，凑 $\frac n 3$ 则用除法求出近似值即可。
```
14
dec 13
dec 13
dec 13
dec 3
assign 2 1
dec 2
new 999
ifneq 2 1000 goto 6
ifneq 3 13 goto 4
dec 1
dec 1
dec 1
new 999
iftry 1 goto 10
```
**于是便完美地 A 掉这道题啦！**

---

## 作者：Expert_Dreamer (赞：1)

如果想要知道实际步骤小于要求步骤的方法，请转至其他题解。
### 题目大意
给定 $n$ 和数组 $p$，初始时不知道 $n$ 是多少，且 $p_1=n$。有几种操作：
- `new x`，$n$ 加一，$p_x=n$。
- `dec x`，$p_x$减一。
- `assign x y`，$p_x=p_y$。
- `iftry x goto l`，如果 $p_x\ge 0$，跳转到第 $l$ 条语句。
- `ifeq x y goto l`，如果 $p_x=p_y$，跳转到第 $l$ 条语句。
- `ifneq x y goto l`,如果 $p_x\ne p_y$，跳转到第 $l$ 条语句。

最后的 $n$ 就是操作结果。
### 操作前的思路
#### 转化
考虑到这 $6$ 种操作，可以把它们写成c++代码。
1. `n++,p[x]=n;`
2. `p[x]--;`
3. `p[x]=p[y];`
4. `do{}while(p[x]>=0);`
5. `do{}while(p[x]==p[y]);`
6. `do{}while(p[x]!=p[y]);`  

注意，后三条语句不是判断语句，而是循环语句。
#### 能做什么
假设有一个 $x$ 和 $y$，其中 $|n-x|=a$，$|n-y|=b$，那么就能求出 $a+b$ 和 $ab$。其中，加法可以分别完成，乘法可以像形如 `do{do{}while()}while();` 的语句完成。这个定理能算出一个常量，也可以算出和 $n$ 有关的式子。
## 任务完成
### #1
输出 $2n$，我们注意到 $p_1=n$，所以 $p_1$ 就可以作为 $n$ 自增的循环条件，但是要注意，$p_x$ 将作为 $n$ 的自增辅助，所以就可以写成这样：
```
3
new 2
dec 1
ifneq 1 3 goto 1
```
### #2
输出 $\binom n2$，即组合数，为 $1+2+3+\dots+(n-1)$，增加的数为 $2+3+4+\dots+(n-2)$，但是如果这样算，步数会炸，于是再转换一下，为 $(1+1)+(2+1)+(3+1)+\dots+(n-3+1)$。在开始时就把 $p_1$ 减 $3$。
```
9
dec 1
dec 1
dec 1
assign 2 1
dec 2
new 3
iftry 2 goto 5
dec 1
ifneq 1 4 goto 4
```
### #3
输出 $600$。$600$是一个常量，怎么做呢？注意到 $n$ 小于 $100$，那么可以让 $n$ 增长到一个数，再让 $n$ 增加一个常数，设 $x$ 为  $n$ 增长到的数，$y$ 为 $600-x$，那么步骤尽量少的方法就是使 $x\le 100$ 且 $x$ 尽量小，再使 $y$ 的质因子尽量多（这样就可以通过循环代替重复自增），可以证明，当 $x=105$ 时，$y=495=3^2\times5\times11$。
```
233
new 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
ifeq 1 3 goto 1
dec 1
assign 2 1
dec 2
dec 2
dec 2
assign 3 2
dec 2
dec 2
assign 4 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
assign 5 1
assign 6 1
assign 7 1
assign 8 1
new 9
dec 8
ifneq 8 3 goto 221
dec 7
ifneq 7 3 goto 220
dec 6
ifneq 6 4 goto 219
dec 5
ifneq 5 2 goto 218
new 1
new 1
new 1
new 1
```
### #4
输出 $n+1$。直接 `new 1` 自增即可。
```
1
new 1
```
### #5
输出 $n^2-1$。由于初始有 $n$，增加的为 $n^2-1-n=(n-2)(n+1)+1$，$n-2$ 和 $n+1$ 都可以通过循环实现，嵌套两个判断语句就行。
```
10
assign 2 1
dec 2
dec 2
assign 3 1
dec 3
new 4
iftry 3 goto 5
dec 2
ifneq 2 5 goto 4
new 1
```
### #6
输出 $n+2000$。把 $2000$ 分解质因数，为 $2000=2^4\times5^3$。用前面的方法嵌套即可。
```
29
assign 2 1
dec 2
dec 2
assign 3 2
dec 2
dec 2
dec 2
assign 4 1
assign 5 1
assign 6 1
assign 7 1
assign 8 1
assign 9 1
assign 10 1
new 11
dec 10
ifneq 10 2 goto 15
dec 9
ifneq 9 2 goto 14
dec 8
ifneq 8 2 goto 13
dec 7
ifneq 7 3 goto 12
dec 6
ifneq 6 3 goto 11
dec 5
ifneq 5 3 goto 10
dec 4
ifneq 4 3 goto 9
```
### #7
输出 $n + \lfloor \log_2 n\rfloor$。在第一个任务中，我们实现了一个数乘二，把方法运用到这题里，没超过原来的 $n$ 就一直乘。
```
14
dec 2
dec 2
assign 3 2
assign 4 6
dec 2
dec 4
ifneq 3 4 goto 5
new 5
assign 3 1
assign 4 6
dec 3
dec 4
ifneq 2 4 goto 11
iftry 3 goto 3
```
### #8
输出 $n + \left(n \bmod 2\right) + 1$。从这里就开始难了，对于取模，利用原始的方法，一直减，直到那个数小于 $0$。如果是对 $2$ 取模，只要判断减完后 $n=-1$ 或者 $n=-2$ 就行。
```
7
assign 2 1
dec 1
dec 1
iftry 1 goto 1
dec 2
new 3
iftry 2 goto 5
```
### #9
输出 $n+\gcd(n, n - 4) + 1$。$\gcd(n,n-4)$ 不是 $1$ 就是 $4$，如果 $n\bmod 4=0$，则 $\gcd(n,n-4)=4$，否则 $\gcd(n,n-4)=1$，用上个任务的取模方式计算 $n\bmod 4$。
```
18
dec 2
dec 2
assign 4 2
dec 4
dec 4
dec 1
dec 1
dec 1
dec 1
assign 3 1
dec 3
iftry 3 goto 6
new 5
dec 1
dec 1
ifeq 1 4 goto 13
new 5
ifeq 1 2 goto 13
```
### #10
输出一个满足 $|x-n\ln n|\le 30$ 的正整数 $x$。$n\ln n$ 的函数曲线是这样的：
![](https://cdn.luogu.com.cn/upload/image_hosting/f0iye7s1.png)   
可以发现，它和 $\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor$ 在 $n$ 较小时惊人的相似，那首先肯定要枚举每一个 $i$，因为向下取整，所以需要用到除法，再枚举一个变量，保证这个变量小于 $n$。
```
14
assign 2 1
assign 4 2
assign 3 1
dec 3
dec 4
iftry 3 goto 4
new 5
assign 3 1
dec 3
dec 4
iftry 3 goto 9
iftry 4 goto 7
dec 1
ifneq 1 6 goto 2
```

---

## 作者：Claire0918 (赞：0)

观察题面易得 $n$ 按时刻非严格递增，$p_i$ 按时刻非严格递减。

所以我们实际是要将欲求的值 $r$ 表达为 $n + m$ 的形式，然后进行加法计算。

我们发现，可以通过三种 `if` 语句实现 `do-while` 循环，进而可以用以下两种方法实现 $k \in \mathbb{N}$ 次循环：

+ 先将 $p_i$ 置为 $k$，然后选择任意的 $p_j = 0$，用
```
(l-th line) some operations
dec i
ifneq i j goto l
```
实现。但任意置 $p_i$ 的值并不容易，所以该方法用的较少，一般用于 $n$ 次左右（因为有已给出的 $p_1 = n$）的循环。还可以将 `ifneq i j goto l` 替换为 `iftry i` 来多执行一次循环，以压行。

+ 将 $p_i$ 置为 $-k$，然后选择任意的 $p_j = 0$，用
```
(l-th line) some operations
dec j
ifneq i j goto l
```
实现。这方法相对常用，一般用于常数次循环。

有了固定次数循环，我们就可以简单的实现加法（以多次的加 $1$）和乘法（以多次的加法）。

以上是基本的固定语法，接下来是各任务的解答。

# Task 1
$2n = n + n$，所以有 $m = n$。

Code: 
```
new 3
dec 1
ifneq 1 2 goto 1
```

# Task 2
$$
\begin{aligned}
n \choose 2
&= \frac{n(n - 1)}{2}\\
&= \sum_{i = 1}^{n - 1} i\\
&= n + \sum_{i = 1}^{n - 1} i - n\\
&= n + \sum_{i = 2}^{n} i - n - (n - 1)\\
&= n + \sum_{i = 2}^{n - 2} i
\end{aligned}
$$
所以有 $m = \sum_{i = 2}^{n - 2} i$。

我们发现，直接执行 $2$ 次循环不容易，但是我们可以用 `iftry` 执行 $1 + 1$ 次循环以达到相同的目的。

Code:
```
dec 1
dec 1
dec 1
assign 2 1
new 4
dec 2
iftry 2 goto 5
dec 1
ifneq 1 3 goto 4
```

# Task 3
$600 = n + (600 - n)$，所以 $m = 600 - n$。

我们尝试使用第二种循环方式，即要构造 $-(600 - n) = n - 600$。

注意到 $600 = 24 \times 25$，这两个数的构造相当简洁。

置 $p_2 = 24, p_3 = 25$，用 $p_1$ 减法算出 $n - 600$，最后循环 $600 - n$ 次即可。

Code：
```
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
assign 3 2
dec 3
assign 5 6
dec 5
dec 1
ifneq 5 3 goto 28
dec 4
ifneq 4 2 goto 27
new 7
dec 6
ifneq 6 1 goto 33
```

# Task 4
易得 $m = 1$。

Code: 
```
new 1
```

# Task 5
$$
\begin{aligned}
n^2 - 1
&= (n + 1)(n - 1)\\
&= (n + 1) + (n + 1)(n - 2)\\
&= n + (n + 1)(n - 2) + 1
\end{aligned}
$$
使用两次第一种循环方法，注意 $n + 1$ 次处可以使用 `iftry` 压行。

Code:
```
new 4
assign 2 1
dec 2
dec 2
assign 3 2
new 4
dec 3
ifneq 3 5 goto 6
dec 1
iftry 1 goto 5
```

# Task 6
$n + 2000 = n + (2 \times 10 \times 10 \times 10)$，所以 $m = 2 \times 10 \times 10 \times 10$，像 Task 3 一样简单维护三个变量即可。

Code: 
```
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 2
dec 3
dec 3
assign 5 10
assign 6 10
assign 7 10
new 100
dec 7
ifneq 7 2 goto 16
dec 6
ifneq 6 2 goto 15
dec 5
ifneq 5 2 goto 14
dec 4
ifneq 4 3 goto 13
```

# Task 7
易得 $m = \lfloor \log_2 n \rfloor$。容易想到倍增维护 $\log_2$，每次减去 $2^k$ 直到 $p_1$ 被减完。

第 $k$ 循环前，先使得 $p_2 = -2^k$，随后 $p_1$ 和 $p_2$ 分别减去 $p_2$。最终 $p_2 = -2^{k + 1}$，$p_1$ 减了 $2^k$，可以用 $p_2$ 继续迭代。

易得 $2^{r} - 1 = \sum_{i = 1}^{r - 1} 2^i$，所以 $p_1$ 提前减 $1$。

注意边界是 $p_1 > 0$，但是我们并没有这样的语句，所以再先减 $1$ 再判断 $p_1 \geq 0$。

Code: 
```
dec 1
dec 1
dec 2
dec 2
new 6
assign 3 2
assign 4 5
dec 4
dec 2
dec 1
ifneq 4 3 goto 8
iftry 1 goto 5
```

# Task 8
由题有
$$
m = 
\begin{cases}
1 & 2 \mid n\\
2 & 2 \nmid n\\
\end{cases}
$$

我们可以每次减 $2$ 直到 $p_1$ 减到小于 $0$，此时有
$$
p_1 =
\begin{cases}
-2 & 2 \mid n\\
-1 & 2 \nmid n\\
\end{cases}
$$

每次使 $p_2$ 减 $1$，$n$ 加 $1$，如果执行后 $p_2 \neq p_1$ 则退出。

Code:
```
dec 1
dec 1
iftry 1 goto 1
new 3
dec 2
ifeq 1 2 goto 4
```

# Task 9
显然有
$$
\begin{aligned}
\gcd(n, n - 4)
&= \gcd(4, n - 4)\\
&= \gcd(4, (n - 4) \bmod 4)\\
&= \gcd(4, n \bmod 4)
\end{aligned}
$$
从而
$$
m = 
\begin{cases}
5 & n \bmod 4 = 0\\
2 & n \bmod 4 \in \{1, 3\}\\
3 & n \bmod 4 = 2\\
\end{cases}
$$
置
$$
p_1 = 
\begin{cases}
0 & 4 \mid n\\
(n \bmod 4) - 4 & 4 \nmid n\\
\end{cases}
$$
提前置 $p_3 = -2, p_4 = -4$，将 $n$ 加 $2$，随后 $p_1$ 减 $2$，如果有 $p_1 = p_3$ 则再执行 $2$ 次加 $2$，如果有 $p_1 = p_4$，则再执行 $1$ 次。

这样，当 $p_1 = -2$ 时会先后多执行 $2 + 1$ 次加 $2$，当 $p_1 = -4$ 时会多执行 $1$ 次，满足要求。

Code:
```
dec 1
dec 1
dec 1
dec 1
assign 2 1
dec 2
iftry 2 goto 1
dec 3
dec 3
assign 4 3
dec 4
dec 4
new 5
new 5
dec 1
dec 1
ifeq 1 3 goto 13
ifeq 1 4 goto 14
```

# Task 10
注意到 $n$ 范围极小，考虑用一次函数拟合 $x \ln x$。

我们注意到 $(\forall x \in [5, 100])(|\frac{13}{3}x - x \ln x| \leq 30)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/50j1xsfs.png)

所以我们可以直接输出 $\frac{13}{3}n = n + (3x + \frac{1}{3}x)$。

$\frac{1}{3}x$ 可以用每次减 $3$ 实现。

Code:
```
assign 2 1
new 4
new 4
new 4
dec 1
ifneq 1 3 goto 2
new 4
dec 2
dec 2
dec 2
iftry 2 goto 7
```

目前成绩是 Task 3, 6, 7, 8, 10 成功爆标，Task 1, 4 目测无法爆标，剩余的暂无更好解法，若读者有更好解法，请于评论中指出。

---


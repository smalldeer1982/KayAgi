# 故事结局

## 题目背景

莲子最终有惊无险的救下了梅莉，虽然梅莉本人似乎对此不以为意，而且还对莲子的观点有很多看法……不过她们很快就和好如初，然后一起度过了一段甜蜜的时光。

但是你既不是莲子也不是梅莉，所以在故事的结尾，你需要做一道数据结构题。

## 题目描述

你需要维护一个大小为 $n \times m$ 的矩阵 $A$，初始时其所有元素均为 $0$。题目还给出了一个长度为 $m$ 的序列 $b$。

共有 $q$ 次操作，分为两种：

- `1 l r x v`，对于 $l \le i \le r$，将 $A_{x,i}$ 修改为 $v$。

- `2 l r x y`，查询 $\max\limits_{i=l}^r \max\limits_{j=x}^y (A_{i,j} \times b_j)$。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n,q\le } & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 5 & 100 & - &-\cr\hline
2 & 5 & 5000 & -&- \cr\hline
3 & 20 & 2 \times 10^5 & \mathbf{A}&- \cr\hline
4 & 10 & 2 \times 10^5 & \mathbf{B}&- \cr\hline
5 & 10 & 2\times 10^5 & \mathbf{C}&-  \cr\hline
6 & 10 & 2\times 10^5 & \mathbf{D}&-  \cr\hline
7 & 20 & 2\times 10^5 & -&1,2,3,4,5,6  \cr\hline
8 & 20 & 4\times 10^5 & -&7  \cr\hline
\end{array}
$$

特殊性质 $\mathbf{A}$：保证所有修改在查询之前。\
特殊性质 $\mathbf{B}$：对于修改操作保证 $l=r$。\
特殊性质 $\mathbf{C}$：保证数据随机（随机方法见下）。\
特殊性质 $\mathbf{D}$：保证 $b$ 序列满足所有 $b_i=1$。

对于所有数据满足：$1 \le n,m,q \le 4 \times 10^5$。$1 \le b_i \le 10^9$。

**在所有 $q$ 次操作中，修改操作出现不超过 $\dfrac{q}{4}$ 次。**

对于一操作，$1 \le l \le r \le m,1 \le x \le n,1 \le v \le  10^9$。

对于二操作，$1 \le l \le r \le n,1 \le x \le y \le m$。

数据随机的方式：$n,m,q$ 事先选定，不是随机的。然后均匀随机取 $\left \lfloor \dfrac{q}{4} \right \rfloor$ 次操作为修改操作，剩下的为查询操作。对于操作的所有参数以及 $b$ 序列在其限制范围内等概率随机。

## 样例 #1

### 输入

```
5 5 20
3 2 1 1 1 
1 2 2 1 2
2 2 4 3 4
1 2 4 5 6
1 1 3 4 4
1 1 5 5 4
1 3 4 3 1
1 1 2 4 2
1 5 5 5 8
2 2 4 2 5
2 1 5 3 5
2 3 5 1 3
1 1 4 2 6
2 1 1 1 3
1 2 4 4 10
2 2 5 3 4
2 1 4 1 4
2 4 5 4 5
1 2 2 2 5
1 4 4 4 9
1 2 5 3 6
```

### 输出

```
0
4
8
12
4
10
20
10
```

# 题解

## 作者：chenxinyang2006 (赞：9)

- 对时间轴分治

  对修改操作颜色段均摊，那么可以知道一个颜色段存在的时间会是时间轴上的一段区间。

  对事件轴线段树分治，就转化为了所有修改在所有查询前面的子问题，所有子问题规模和是 $O(q \log q)$ 的，这个子问题实现得好可以 1log，实现不好 2log 卡一卡常（或者大力乱搞一下，考虑这题是 RMQ 有一些经典乱搞比如 log 分块）估计也能过。

  不是正解，但是卡不掉！强制在线一下就寄了，但正解由于空间问题不能在线。

- 正解

  我们假装还是要强制在线的，所以不考虑上面的离线做法。

  首先你发现如果操作是行向 $v$ `chkmax`，应该挺好做的：建立树套树，行为外层，列为内层。外层树上每个节点相当于维护了一个长度为 $m$ 的序列，每个位置代表这个节点对应的行区间上，所有这一列的值的 $\max$。于是以修改查询都多 1log 的代价降一维，一维（序列）的情况当然是好做的。

  现在变成对一行的一个区间 assign 了，还是像刚才一样建立树套树，外层树上每个节点维护一个长度为 $m$ 的序列，是这些行逐列叠 $\max$ 的结果。

  从 `chkmax` 变为 assign 的问题在于现在你可能需要 pushup 了，这当然是没法接受的，至少不能对于整棵树 pushup。

  考虑刚才的一维情况，其实维护的是支持区间 `chkmax`，区间 `max` 的线段树，每个节点上维护的两个信息分别是这个节点上的 `chkmax` 标记和这个节点子树内所有 `chkmax` 标记作用出的子树最大值。一个好处是，外层树上的点 $u$，它对应线段树上每个点的信息**可以**是其外层树上左右儿子线段树上每个点信息的叠加（标记和子树最大值均直接取 $\max$），这具有相当的一致性，使得我们有可能进行 pushup。

  考虑先对外层树上的叶子节点（也就是只维护一行信息的节点）进行修改然后一路 pushup 上去，我们把区间 assign 操作强行转化为区间 `chkmax` 操作：用 `chkmax` 标记代替 assign 标记，首先没递归到完全包含的点时标记正常下传，递归到完全包含的点时试图给这个点打上标记，并取消子树内所有点已有的标记。设势能为线段树上有标记的节点数量就可以发现总复杂度不超过 $O(q \log m)$，这里指的是只考虑所有外层树上叶子节点的复杂度开销。

  这样对外层树上最底层的点的线段树可以进行修改，因为外层树上所有非叶节点的线段树信息都只是其左右儿子信息的简单叠加，所以向上 pushup 的时候只需要 pushup 最底层修改时修改到的节点，可以发现时间复杂度不超过 $O(q \log n \log m)$。

  

  然后你发现在线实现这个算法需要 2log 空间，肯定 MLE 了。可以考虑离线对外层树逐层处理（从低往高一层一层处理，每次只存相邻两层每个节点对应线段树可持久化后的结果）可以 1log 空间。

  时间复杂度 $O(n+m + q \log n \log m)$ 空间复杂度 $O(m+q \log m)$。

- 一些拓展

  实际上也不是一定卡不掉离线做法，直接强制在线，然后用 [压缩 Trie](https://www.luogu.com.cn/problem/solution/P5612) 可能可以在线降到 1log 空间，但压缩 `Trie` 一般是处理单点修改的，这题需要区间修改并且对线段树结构的依赖性比较大（比如你拿平衡树维护区间 `chkmax` 区间 `max` 显然就不能 pushup 了），这具体能不能做到还需要进一步研究。

  但是如果真用到压缩 `Trie` 了这题还能写吗。

  
  
  另一方面，其实也可以明确一下这个做法能支持在怎样的代数结构上运算。考虑一个代数系统 $G=<A,+,\cdot>$，$<A,+>$ 构成交换半群（交换律，结合律），$<A,\cdot>$ 构成半群（结合律），$\cdot$ 对 $+$ 有分配律，那么事实上将本题的求和换成这个代数系统中的 $+$，$A_{i,j}$ 与 $b_j$ 相乘换成这个代数系统的 $\cdot$，做法也是可以沿用的。
  
  事实上即使允许离线，所有修改在查询前的子问题如果只保证 $<A,+>$ 只有交换律结合律也不能直接 1log 做，应该会多一个 $\alpha$，复杂度会略差一点。不过本题的 $+$ 操作实际上是取 $\max$ 而 RMQ 确实是可以 $O(n)-O(1)$ 的。
  
  如果 $+$ 直接是整数加法，$\cdot$ 直接是整数乘法的话相当于 $<A,+>$ 变为交换群（所有元素有逆元），这是一个比较常见的情况，这题相当于探讨了 $+$ 不可求逆的情况。

---

## 作者：kradcigam (赞：8)

写一个跟官解完全不同的 $O(n\log^2 n)$ 做法，这个做法正常做就可以在线做到 $O(n\log n)$ 的空间，但是需要用到平衡树，常数较大，~~80 分（$n\le 2\times 10^5$） 都过不了~~。

最基本的想法是，对行颜色段均摊，把覆盖转化成 $O(n)$ 次插入、删除。

我们考虑对列建外层线段树，然后行就是单点。

我们观察列，对于修改，假设是区间 $[l_1,r_1]$，对于查询，假设是区间 $[l_2,r_2]$，我们只关心它们的区间交。

我们考虑将它们都拆成线段树节点，则他们的交可以表示成线段树节点的交。

对于线段树节点的交，我们只需要分成 2 种情况：

1. 修改是祖先，查询是后代。这个时候我们就只需要：
    1. 修改时，在线段树节点，插入当前行以及对应的 $v$；
    2. 查询时，在到根路径上的线段树节点，求出 $b$ 数组的区间最大值 $\times$ 查询行在查询区间内的 $v$ 最大值。
2. 查询是祖先，修改是后代。这个时候我们就只需要：
    1. 修改时，在到根路径上的线段树节点，插入当前行以及对应的 $v$ 和 $b$ 数组的区间最大值的乘积；
    2. 查询时，在线段树节点，查询行所在查询区间内的 $v\times b$ 最大值。

注意到如果对于所有线段树节点都去找其祖先复杂度过高，我们可以在线段树遍历的时候，找到当前线段树区间和原始区间的交即可。

一个直观的想法是对上面两类都维护平衡树，由于平衡树空间线性，所以空间复杂度 $O(n\log n)$。

时间复杂度 $O(n\log^2 n)$。

注意到，我们需要分两类讨论，常数很大，同时外面的颜色段均摊也有不小的常数，我们考虑离线来替换掉平衡树，减小常数。

离线之后，我们就可以使用 zkw 线段树 + 堆，维护这个过程了，这样常数较小，就可以通过了！

---

## 作者：C1942huangjiaxu (赞：4)

很厉害的题。

下面计算复杂度时认为 $n,m,q$ 同阶。

注意到修改操作只会修改一行，如果我们只考虑行，对行建立线段树，那么就是单点修改，区间查询。

加上列的限制，考虑树套树，但是容易发现直接树套树空间是 $\log^2n$ 的，于是考虑离线，类似线段树分治，把单点修改和区间查询存到每个线段树节点上，对于每个线段树节点单独处理询问。

把区间赋值用 set 颜色段均摊一下，那么问题变为我们有 $n\log n$ 次操作，每次操作形如：

+ 区间插入一个数，也就是区间取 $\max$
+ 撤销之前的一次插入操作
+ 查询区间最大值

考虑如果没有撤销操作，那么可以直接用标记永久化线段树做到 $O(n\log n)$（维护区间 $tag$ 和子树内 $tag\times$ 区间 $\max$ 的最大值），加上撤销操作后，对于每个节点开一个 set 维护最大值，可以做到 $O(\log^2 n)$ 区间修改，$O(\log n)$ 区间查询。

这样总复杂度是 $O(n\log^3 n)$ 的，卡卡常能获得 80 分。

本人的思考止步于此了，可以发现上述做法的**瓶颈在于修改操作需要用 set 维护节点最大值**，并且似乎不容易优化。

这里官方题解用了很巧妙的一步，注意到如果没有撤销操作，区间取 $\max$ 的标记是可以 $O(1)$ 合并的，考虑**只修改外层线段树的叶子节点，然后对于非叶子节点进行线段树合并的 pushup**，这样我们就去掉了一个 set，时间复杂度是 $O(n\log^2 n)$ 的。

在线空间是 $\log^2 n$ 的，同样考虑离线，维护每个节点的修改操作的可持久化线段树。

注意到这里 pushup 时我们需要对 2 棵可持久化线段树进行归并，传统的主席树写法似乎并不能十分清晰的描述此过程。

考虑肥节点，对于每个节点，开一个 vector 维护不同版本的信息，可以用 $t_i,v_i$ 表示第 $t_i$ 个操作后，节点的值被修改成了 $v_i$。

这样合并 2 棵树只要按照线段树合并的写法，合并 2 个节点时对于 2 个节点的版本信息归并就行了。

每次归并后清空无用的 vector，空间复杂度即可做到 $O(n\log n)$。

每次处理节点询问时，先 dfs 整个可持久化线段树，把版本指针清 $0$，每次询问时把版本指针移动到当前时刻即可，均摊 $O(n\log^2 n)$。

实际实现时，为了减小常数，并不需要记录每个版本的子树最大值信息，可以在更新标记版本信息时动态维护子树最大值信息。

时间复杂度 $O(n\log^2 n)$，空间复杂度 $O(n\log n)$。

代码比较长，放云剪贴板里，常数比较大。

[参考代码](https://www.luogu.com.cn/paste/5ft1v9d1)

---

## 作者：win114514 (赞：2)

### 思路

考虑出题人说的第一种做法。

我们首先将操作用颜色段均摊求一下，可以求出每一段颜色的出现时间。

然后进行线段树分治。

我们将每一段颜色放到线段树上，这样就拆成了 $q\log q$ 个修改。

然后把询问同样放到线段树上，由于询问在时间上是一个单点，所以每个包括这个单点线段树节点都要放，这样也拆成了 $q\log q$ 个询问。

这样有什么好处呢。

在线段树的每一个节点上，我们发现所有的修改都在询问前面，这意味着我们可以先预处理然后修改。

如何求解？

再开一个线段树，我们先把行放到线段树上，这样每一个查询就会被拆成 $\log$ 个线段树上的询问，每一个修改由于是单独一行，所以要放到所有包括它的线段树节点上。

那么我们修改也变成了 $q\log q\log n$ 个区间上操作，查询也 $q\log q\log n$ 个变成区间上的查询。

这个如何操作呢？

我想到的做法是使用带权并查集。

我们可以将修改 $(l,r,v)$ 按照 $v$ 从大到小排序。

然后一次从 $l$ 遍历到 $r$，并赋值，然后用并查集并起来。

然后查询 $(l,r)$ 类似的按照 $r$ 从小到大排序。

然后询问时从 $l$ 遍历到 $r$，也用并查集并起来。

因为 $r$ 从小到大，所以不会并到不需要访问的节点。

这样就在 $α(q)$ 的时间复杂度处理出来。

这样总的时间复杂度是：$O(q\log q\log n \cdot α(q\log q\log n))$。

当然实际实现的时候我们是做不到这个复杂度的。

我们的排序或许可以在插入线段树之前排好序，但是我们需要离散化。

加入我们在插入线段树之前离散化，然后把离散化的值放到线段树上。

这样其实还没有在线段树里面排序离散化快。

所以一般实现是可以写 $\log^3$ 的做法，也能过，但其实没有比正解好写很多。

### Code

```cpp
/*
  ! 如果没有天赋，那就一直重复
  ! Created: 2024/06/26 20:26:19
*/
#include <bits/stdc++.h>
using namespace std;

#define fro(i, x, y) for (int i = (x); i <= (y); i++)
#define pre(i, x, y) for (int i = (x); i >= (y); i--)

using i64 = long long;

const int N = 4e5 + 10;

int n, m, q, ct, k1, k2, ect, ect2;
i64 s[N], b[N], st[N][20];
int sz[N << 1], head[N << 1];
struct Node {
  int x, l, r, v, L, R, id;
} d1[N];
struct Quer {
  int x, y, l, r, d, id;
} d2[N];
struct Kdlt {
  int l;
  mutable int r, v, ti;
  inline bool operator<(const Kdlt&tmp) const {
    return l < tmp.l;
  }
};
struct edge {
  int to, nxt, val;
} e[N * 32];
set<Kdlt> kdl[N];

namespace IO {
const int I = 1e6; char buf[I], s[I], *p1, *p2;
#define gc() (p1==p2&&(p2=(p1=buf)+cin.rdbuf()->sgetn(buf,I),p1==p2)?EOF:*p1++)
template<typename T> inline void read(T &x) {
  x = 0; int q = 1; char z;
  while(!isdigit(z = gc())) if(z == '-') q = -1;
  while(isdigit(z)) x = x * 10 + (z ^ 48), z = gc(); x *= q;
}
template<typename T, typename ...Args> inline void read(T &x, Args &...args) { read(x), read(args...); }
template<typename T> inline void put(T a) {
  int tp = 0; if(a < 0) cout.rdbuf()->sputc('-'), a = -a;
  if(!a) return cout.rdbuf()->sputc('0'), void();
  while(a) s[++tp] = a % 10 + 48 , a /= 10;
  while(tp) cout.rdbuf()->sputc(s[tp--]);
}
inline void put(const char *a) { while(*a) { cout.rdbuf()->sputc(*(a++)); } }
template<typename T, typename ...Args> inline void put(T x, Args ...args) { put(x), put(args...); }
} using IO::put; using IO::read;
inline i64 ask(int l, int r) {
  int g = __lg(r - l + 1);
  return max(st[l][g], st[r - (1 << g) + 1][g]);
}
inline auto spl(int x, int l) {
  auto it = prev(kdl[x].upper_bound({l}));
  if (it->l == l) return it; int r = it->r;
  return it->r = l - 1, kdl[x].insert({l, r, it->v, it->ti}).first;
}
inline void upd(int x, int l, int r, int v) {
  ++ct;
  auto it1 = spl(x, l), it2 = spl(x, r + 1);
  for (auto i = it1; i != it2; i++)
    if (i->ti) d1[++k1] = {x, i->l, i->r, i->v, i->ti, ct - 1}, d1[k1].id = k1;
  kdl[x].erase(it1, it2);
  kdl[x].insert({l, r, v, ct});
}
namespace sol {
int nt[N], nx[N], f1[N], f2[N], buc[N];
i64 mx[N];
Node g1[20][N];
Quer g2[20][N];
inline void upd(int p, int l, int r, int L, int R, int k) {
  if (L <= l && r <= R) return e[++ect] = {k, head[p], 1}, head[p] = ect, void();
  int mid = (l + r) >> 1;
  if (mid >= L) upd(mid<<1, l, mid, L, R, k);
  if (mid <  R) upd(mid<<1|1, mid + 1, r, L, R, k);
}
inline void upd(int p, int l, int r, int k, int x) {
  e[++ect] = {x, head[p], 2}, head[p] = ect;
  if (l == r) return;
  int mid = (l + r) >> 1;
  if (mid >= k) upd(mid<<1, l, mid, k, x);
  if (mid <  k) upd(mid<<1|1, mid + 1, r, k, x);
}
inline int gf1(int x) {
  return nt[x] == x ? x : (nt[x] = gf1(nt[x]));
}
inline int gf2(int x, i64 &v) {
  if (nt[x] == x) return x;
  return nt[x] = gf2(nt[x], v), mx[x] = v = max(v, mx[x]), nt[x];
}
inline void sol(int p, int l, int r, int R1, int R2, int dep) {
  if (R1 == 0 || R2 == 0) return;
  int t1 = 0, t2 = 0;
  fro(i, 1, R1) f1[++t1] = g1[dep][i].id;
  fro(i, 1, R2) if (g2[dep][i].x <= l && r <= g2[dep][i].y) f2[++t2] = g2[dep][i].id;
  if (t1 != 0 && t2 != 0) {
    int tt = 0;
    fro(i, 1, t1) buc[++tt] = d1[f1[i]].l, buc[++tt] = d1[f1[i]].r + 1;
    fro(i, 1, t2) buc[++tt] = d2[f2[i]].l, buc[++tt] = d2[f2[i]].r + 1;
    sort(buc + 1, buc + tt + 1);
    tt = unique(buc + 1, buc + tt + 1) - buc - 1;
    fro(i, 1, tt) nt[buc[i]] = buc[i], mx[buc[i]] = 0, nx[buc[i]] = buc[i + 1];
    nx[buc[tt]] = n + 2;
    fro(i, 1, t1) {
      int l = d1[f1[i]].l, r = d1[f1[i]].r + 1, v = d1[f1[i]].v;
      for (int j = gf1(l); j < r; j = gf1(j)) {
        if (!mx[j]) mx[j] = v * ask(j, nx[j] - 1);
        j = nt[j] = nx[j];
      }
    }
    fro(i, 1, tt) nt[buc[i]] = buc[i];
    fro(i, 1, t2) {
      int l = d2[f2[i]].l, r = d2[f2[i]].r + 1, d = f2[i]; i64 v;
      for (int j = gf2(l, v = -1e9); j < r; j = gf2(j, v = -1e9)) {
        j = nt[j] = nx[j];
      }
      gf2(l, v = -1e9), s[d] = max(s[d], v);
    }
  }
  if (l != r) {
    int mid = (l + r) >> 1, r1, r2;
    r1 = r2 = 0;
    fro(i, 1, R1)
      if (g1[dep][i].x <= mid) g1[dep + 1][++r1] = g1[dep][i];
    fro(i, 1, R2) {
      if (g2[dep][i].x <= l && r <= g2[dep][i].y) continue;
      if (g2[dep][i].x <= mid) g2[dep + 1][++r2] = g2[dep][i];
    }
    sol(mid<<1, l, mid, r1, r2, dep + 1);
    r1 = r2 = 0;
    fro(i, 1, R1)
      if (g1[dep][i].x > mid) g1[dep + 1][++r1] = g1[dep][i];
    fro(i, 1, R2) {
      if (g2[dep][i].x <= l && r <= g2[dep][i].y) continue;
      if (g2[dep][i].y > mid) g2[dep + 1][++r2] = g2[dep][i];
    }
    sol(mid<<1|1, mid + 1, r, r1, r2, dep + 1);
  }
}
inline void sol(int p) {
  int t1 = 0, t2 = 0; ect2 = 0;
  for (int i = head[p]; i; i = e[i].nxt) {
    int x = e[i].to;
    if (e[i].val == 1) {
      g1[0][++t1] = d1[e[i].to];
    } else {
      g2[0][++t2] = d2[e[i].to];
    }
  }
  if (t1 == 0 || t2 == 0) return;
  sort(g1[0] + 1, g1[0] + t1 + 1, [&](auto x, auto y) { return x.v > y.v; });
  sort(g2[0] + 1, g2[0] + t2 + 1, [&](auto x, auto y) { return x.r < y.r; });
  sol(1, 1, n, t1, t2, 0);
}
inline void dfs(int p, int l, int r) {
  sol(p);
  if (l == r) return;
  int mid = (l + r) >> 1;
  dfs(mid<<1, l, mid);
  dfs(mid<<1|1, mid + 1, r);
}
inline void init() {
  nt[n + 1] = n + 1;
  nt[n + 2] = n + 2;
  fro(i, 1, k1) {
    upd(1, 1, ct, d1[i].L, d1[i].R, i);
  }
  fro(i, 1, k2) {
    if (d2[i].d) {
      upd(1, 1, ct, d2[i].d, i);
    }
  }
  if (ct) dfs(1, 1, ct);
}
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0);
  read(n, m, q);
  fro(i, 1, m) read(b[i]);
  fro(i, 1, m) st[i][0] = b[i];
  fro(i, 1, 19) {
    fro(j, 1, m - (1 << i - 1)) {
      st[j][i] = max(st[j][i - 1], st[j + (1 << i - 1)][i - 1]);
    }
  }
  fro(i, 1, n) kdl[i].insert({1, m, 0, 0});
  fro(i, 1, q) {
    int op, l, r, x, y, v;
    read(op);
    if (op == 1) {
      read(l, r, x, v);
      upd(x, l, r, v);
    } else {
      read(l, r, x, y);
      d2[++k2] = {l, r, x, y, ct}, d2[k2].id = k2;
    }
  }
  fro(i, 1, n) {
    for (auto j : kdl[i])
      if (j.ti) d1[++k1] = {i, j.l, j.r, j.v, j.ti, ct}, d1[k1].id = k1;
  }
  sol::init();
  fro(i, 1, k2) put(s[i], "\n");
  return 0;
}
```

---


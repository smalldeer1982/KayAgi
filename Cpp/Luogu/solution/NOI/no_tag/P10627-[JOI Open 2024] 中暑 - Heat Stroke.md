# [JOI Open 2024] 中暑 / Heat Stroke

## 题目描述

JOI 岛由 $L$ 个区组成，从西到东依次编号为 $1$ 到 $L$。岛上有 $(L-1)$ 条路，编号为 $1$ 到 $L-1$。第 $i$ 条路（$1\le i\le L-1$）双向连接着区 $i$ 和区 $i+1$。

现在，IOI 20XX 计划在 JOI 岛上举行！然而，令人担心的是，JOI 岛以其“火炉”称号而闻名于世。在岛上中暑风险较高，尤其是对于不适应 JOI 岛炎热气候的外国人。所以，IOI 的组织者决定采取以下措施：

- 对于每一个 $1\le i\le L$，在区 $i$ 上有一个容量为 $C_i$ 人的医院。注意，$C_i$ 可以为 $0$。

- 在 IOI 活动中，当有人在第 $x$ 条路（$1\le x\le L-1$）上中暑时，中暑者将以以下的程序送医：
    - 将中暑者送往区 $x$ 或者区 $x+1$ 上的未满员的医院。如果两个区上的医院都未满员，则送往哪一个医院都可以。如果两个医院都满员了，用直升机将中暑者送往岛外的医院。

由于动用直升机花销不小，组织者们想要估计可能的需要动用直升机的病人数量的**最大值**。他们考虑如下的情境：

- 在 IOI 活动之前，医院中没有病人；
- 在 IOI 活动中，有 $N$ 个人会依次中暑。第 $j$ 个（$1\le j\le N$）人在第 $X_j$ 条路上中暑；
- 对于任意 $1\le j\le N-1$，当第 $(j+1)$ 个人中暑时，第 $1,2,\cdots,j$ 个人已经送达医院。由于中暑症状较为严重，在 IOI 活动中无人出院。

你需要写一个程序。给定区的数量，医院的信息和中暑者的信息，在上述情境下，计算可能的需要动用直升机的病人数量的最大值。


## 说明/提示

### 样例解释

对于样例 $1$，考虑如下的情况：

- 将第一个中暑者送往区 $2$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,0$；
- 将第二个中暑者送往区 $3$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,1$；
- 对于第三个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。

此时共有 $1$ 人动用直升机送出岛。可以证明这是最大值。

对于样例 $2$，考虑如下的情况：

- 将第一个中暑者送往区 $2$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,0,0,0$；
- 将第二个中暑者送往区 $4$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,0,0$；
- 将第三个中暑者送往区 $5$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,1,0$；
- 对于第四个中暑者，由于区 $4,5$ 上的医院均已满员，所以只能用直升机送出岛。
- 将第五个中暑者送往区 $3$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,1,1,1,0$；
- 对于第六个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。
- 对于第七个中暑者，由于区 $3,4$ 上的医院均已满员，所以只能用直升机送出岛。

此时共有 $3$ 人动用直升机送出岛。可以证明这是最大值。

样例 $1$ 满足子任务 $1\sim 8$ 的条件。

样例 $2$ 满足子任务 $2\sim 8$ 的条件。

样例 $3$ 满足子任务 $1,5\sim 8$ 的条件。

样例 $4,5$ 满足子任务 $5\sim 8$ 的条件。

### 数据范围

- $2 \le L \le 8\,000$；
- $0 \le C_i \le 8\,000$（$1 \le i \le L$）；
- $1 \le N \le 8\,000$；
- $1 \le X_j \le L − 1$（$1 \le j \le N$）；
- 输入数字全为整数。

【子任务】

1. （$6 $ points）$X_1 \le X_2 \le\cdots\le X_N$；
2. （$7 $ points）$L \le 18, N \le 18, C_i = 1 $（$1 \le i \le L$）；
3. （$7 $ points）$L \le 18, N \le 100, C_i = 1 $（$1 \le i \le L$）；
4. （$25$  points）$L \le 100, N \le 100, C_i = 1$ （$1 \le i \le L$）；
5. （$25$  points）$L \le 100, N \le 100$；
6. （$10$  points）$L \le 600, N \le 600$；
7. （$15$  points）$L \le 3\,500, N \le 3\,500$；
8. （$5 $ points）无额外约束。

由 Starrykiller 根据英文题面翻译。

## 样例 #1

### 输入

```
3
1 1 1
3
1 2 2```

### 输出

```
1```

## 样例 #2

### 输入

```
6
1 1 1 1 1 1
7
1 3 5 4 2 2 3```

### 输出

```
3```

## 样例 #3

### 输入

```
6
4000 1 1 0 4000 1
5
1 1 2 3 5```

### 输出

```
1```

## 样例 #4

### 输入

```
5
1 2 2 2 1
8
2 3 2 1 4 1 2 3```

### 输出

```
2```

## 样例 #5

### 输入

```
10
2 2 2 2 2 2 2 2 2 2
18
1 3 5 7 9 2 4 6 8 1 3 5 7 9 2 4 6 8```

### 输出

```
3```

# 题解

## 作者：cmk666 (赞：12)

## sub 1

直接贪，能往右方就往右放。

## sub 2,3

状态数只有 $O(2^ln)$，直接爆搜。

## sub 4

到这个开始就比较有脑子了。

考虑对于每个人，我们只关心的状态是：她是向左，还是向右，还是贡献到答案。那么一个状态合法，当且仅当：不存在一个医院接受了 $>c_i$ 个人；也不存在一个人在两边的医院至少有一个有空位的时候算入答案。

容易发现 check $i$ 医院是否合法的时候，只要用到 $i-1$ 和 $i$ 位置的人的决策。据此 dp 即可。而由于 $c_i=1$，一条路上只有前 $2$ 个人是有用的，后面的人必然是算入答案的，那么状态数就是常数的，直接做就是线性。

## sub 5

没了 $c_i$ 的限制，上面的 dp 状态数都是指数级的，做不了一点。但是我们仍然可以沿用类似的 dp 思路。

事实上，check $i$ 的时候没必要记录所有人的决策。考虑定义 dp 状态 $dp_{i,j,k}$ 表示：当前到第 $i$ 条路，往第 $i+1$ 个医院送了 $j$ 个人，且第 $i+1$ 个医院将会在 $k$ 时刻变满，或者当 $k=n+1$，表示永远不满。

转移的时候直接枚举 $dp_{i+1,j',k'}$，那么若 $k'>k$，则第 $i+1$ 条路上 $(k,k']$ 的人都要往右送，也就是限制了 $j'$ 的一个下界；同时，记 $x=$ 第 $i+1$ 条路上 $[1,\max(k,k')]$ 中的人数，那么容易得到往左送的人数为 $x-j'$，于是对于医院 $i+1$ 有 $x-j'+j\le c_{i+1}$，当且仅当 $k\ne n+1$ 时取等。然后还有一些边界上的特判，是 trivial 的。

由于 $i,j$ 两维的总和是 $O(n)$ 的，于是状态数是 $O(n^2)$ 的，加上一些煎蛋的预处理后，直接暴力转移复杂度为 $O(n^4)$，可以通过 sub 5。实现的时候需要把不合法位置及时赋值为 $-\infin$ 避免影响答案，然后如果你不想写 `std::vector` 这种动态开空间的东西需要滚动数组，注意每次清空的大小。

## sub 6

状态数已经足够优秀，考虑减少转移次数。

考虑转移时的这个条件（$x$ 定义同上）：对于医院 $i+1$ 有 $x-j'+j\le c_{i+1}$，当且仅当 $k\ne n+1$ 时取等。

那么可以发现，对于一对固定的 $(j',k')$，只有 $O(n)$ 对 $(j,k)$ 可以转移到她！原因是：

- 若 $k\ne n+1$，则上式取等，得到 $j=c_{i+1}-x+j'$，那么枚举 $k$ 便能确定 $x$ 进而 $j$ 只有唯一的一种可能，于是共有 $O(n)$ 个转移；
- 若 $k=n+1$，那么枚举 $j$，也只有 $O(n)$ 个转移。

那么转移的复杂度被降到了 $O(n)$，总复杂度 $O(n^3)$。

## sub 7&8

对于 $x$ 的定义中含有 $\max(k,k')$，很麻烦，不妨拆之。也即，把转移分成三种：$k\le k'$、$k'\le k\le n$ 和 $k=n+1$（这种是上一个 sub 拆出来的）。容易发现她们都是求上一层 dp 数组的区间 $\max$，直接上线段树，复杂度 $O(n^2\log n)$，可以通过 sub 7。

更进一步的，观察到有一个端点是只跟某个下标相关的，于是实质上求的是前后缀 $\max$，没必要使用线段树。于是可以做到时空复杂度 $O(n^2)$，至此得以通过此题，完结撒花！

---

## 作者：zhouhuanyi (赞：11)

原问题的规则实际上很大程度上是为最小化而设计的，但是我们却要求的是最大化，这意味着原问题的规则实际上是与我们要最优化的问题相矛盾，可行的办法可能是通过一些转化使新问题与规则刚好契合。

考虑原问题的规则实际上告诉我们只有当两边都不能放的时候才会对答案产生贡献，意味着实际上最优化的其实是尽可能制造两边都满的位置，第 $i$ 条路上的人会产生贡献当且仅当 $i$ 与 $i+1$ 都被放满。

实际上可以发现这样的转化是非常好的，如果我们无视一个位置放满了就不能再被放的限制，问题的结果不会发生改变，这是因为如果一个位置放满了再继续放，这样不如放一个没有放满的位置，这样会使位置变得更加满从而使得答案尽可能的最大化。这意味着原问题的规则在转化问题中就是用来最大化，这是非常契合的。

考虑如果确定好了每一个位置被占据的时间 $t_{i}$，则第 $i$ 条道路上的人会产生贡献当且仅当其到达时间比 $\max(t_{i},t_{i+1})$ 要大。这样如果 $t$ 序列确定，答案也就确定了。

考虑怎样的 $t$ 序列是合法的，对于每一个位置 $i$，要求在 $t_{i}$ 之前第 $i-1$ 与 $i$ 的道路占据 $i$ 的大于等于 $C_{i}$ 个。这实际上是一个匹配问题，使用霍尔定理后实际上变为判定对于一个位置集合 $S$，其邻域 $N(S)$ 的人数都要大于等于 $S$ 集合的 $C$ 之和。

考虑如果 $S$ 是若干段连续的区间且 $S$ 不合法，那么根据抽屉原理至少有一段区间满足其也不合法，所以实际上只需要判定区间即可。实际上可以归约为最小子段和，可以简单 $\text{dp}$ 判定。

那么实际上只需要 $\text{dp}$ 一个 $t$ 序列，内层 $\text{dp}$ 级记录一下最小后缀和，判定其是否时刻 $\geqslant 0$ 即可。由于每个位置 $i$ 取到的 $t$ 的集合 $T_{i}$，只会在相邻的两条道路上的人的到达时刻(特别，最后的一个时刻要置为极大值)与 $0$ 处取到，所以 $\sum_{i=1}^{n} T_{i}$ 是 $O(n)$ 级别的。而每个点 $i$ 只需保留 $T_{i}$ 个时间，每个时间保留 $T_{i}$ 个最小后缀和，转移到 $T_{i+1}$ 个状态，复杂度为 $O(\sum_{i=1}^{L-1}T_{i}^2T_{i+1})=O(n^3)$ 的。但出题人没有刻意卡所以可以拿到 $95$ 分。

实际上如果事先将取到极大值的最后一个时刻忽略，每一个转移可以拆成一段前缀向一个点和一段后缀向一个点的转移，取前后缀 $\text{max}$ 即可变成 $O(\sum_{i=1}^{L}T_{i}^2+\sum_{i=1}^{L-1}T_{i-1}T_{i})=O(n^2)$，常数很小，速度很快。

---

## 作者：AFewSuns (赞：9)

### 题目大意

有 $L$ 个点和 $L-1$ 条边，其中第 $i$ 条边双向连接了 $i$ 和 $i+1$，第 $i$ 个点上有医院可以容纳 $C_i$ 人。

接下来会有 $n$ 个依次中暑。第 $i$ 个人会在第 $X_i$ 条边上中暑，此时若 $X_i$ 和 $X_i+1$ 处的医院都未满员，则可以将他送到其中任意一个未满员的医院进行永久治疗；否则将会用直升机送往岛外的医院。

你希望求出所有情况中，需要动用直升机的病人数量的**最大值**。

$2 \leq L \leq 8000,1 \leq n \leq 8000$。

### 题目分析

很难不想到从前往后 dp，比如设个 $f_{i,j}$ 表示考虑完前 $i$ 个点，且 $i$ 这个位置已经住了 $j$ 个人的最大值。但关键在于如何刻画限制。

设 $i \sim i+1$ 这条边上总共有 $cnt_i$ 个人，且时间从小到大排序依次为 $t_{i,1},\cdots,t_{i,cnt_i}$，$t_{i,cnt_i+1}=+\infty$。首先对于每条边，住进医院的一定是一段前缀，于是设第 $i$ 条边住进医院的有 $M_i$ 人。然后再设 $l_i,r_i$ 分别为第 $i$ 条边往左、往右跑的人数，$L_i,R_i$ 分别表示第 $i$ 条边往左、往右跑的人的最大时间。那么限制大概分为这两类：

1. 不存在医院没住满，但是两边有人坐直升飞机，即若 $r_{i-1}+l_i<C_i$，则 $M_{i-1}=cnt_{i-1}$ 且 $M_i=cnt_i$；
2. 不存在医院住满前，两边就已经有人坐直升飞机，即 $\max(R_{i-1},L_i)<\min(t_{i-1,M_{i-1}+1},t_{i,M_i+1})$。

于是我们在 dp 时需要关心的前面的值只有 $r_{i-1},R_{i-1},M_{i-1}$。直接将其计入 dp 状态里，再通过简单的优化就可以得到一个能拿 70 分的 $\mathcal O(n^3)$ 做法。再用 map 存一下有用状态就可以拿到 80。

关键在于这个状态数就已经吃不消了，于是直接钦定一下 $T_i$ 表示我们认为的在第 $i$ 个点住院的人的最大时间（作用类似于前面的 $\max(R_{i-1},L_i)$，注意不一定严格等于），那么只需要让所有前往第 $i$ 个点的时间都 $\leq T_i$，且两边坐直升飞机的人的时间都 $>T_i$ 即可。如果第 $i$ 个点没有住满人，那么我们认为 $T_i=n+1$。

于是可以重新设计 dp 状态 $f_{i,j,T}$ 表示考虑完了前 $i$ 个点，$i$ 这个位置已经住了 $j$ 个人，且钦定 $i$ 这个点的住院的人的最大时间为 $T$。转移时考虑枚举 $k_1,k_2$ 表示 $i \sim i+1$ 这条边上往左跑了 $k_1$ 个人，往右跑了 $k_2$ 个人，且转移到了 $f_{i+1,k_2,T'}$。考虑这个转移需要满足什么限制：

1. 若 $T\leq n$，则 $j+k_1=C_i$；否则 $j+k_1 \leq C_i$。
2. $t_{i,k_1+k_2+1}>\max(T,T')$，表示坐直升飞机的人要大于我们钦定的时间。
3. 刻画一下进医院时间 $\leq T$ 和 $\leq T'$ 的限制，根据第 $k_1+k_2$ 个人往哪边跑来分类讨论：
   - 第 $k_1+k_2$ 个人去了左边，则 $t_{i,k_1+k_2} \leq T$，然后贪心地让去右边的人时间最小，即 $t_{i,k_2} \leq T'$；
   - 第 $k_1+k_2$ 个人去了右边，则 $t_{i,k_1+k_2} \leq T'$，然后贪心地让去左边的人时间最小，即 $t_{i,k_1} \leq T$。

第三个限制比较繁琐，于是转化一下变成：

- $t_{i,k_1} \leq T,t_{i,k_2} \leq T'$；
- $t_{i,k_1+k_2} \leq \max(T,T')$

联立一下第二个限制和第三个限制第二条，设 $S_x=\sum\limits_{j=1}^{cnt_i}{[t_{i,j}\leq x]}$，那么就可以得到 $k_1+k_2=S_{\max(T,T')}$。于是现在只剩下了第一条限制和第三条限制第一条，且所有 $k_1$ 可以用 $S_{\max(T,T')}-k_2$ 来表示。

接下来可以根据 $T,T',n$ 的大小来进行分类讨论：

1. $T<T'$

整理一下有如下限制：

- $k_2=S_{T'}-C_i+j$
- $S_{T'}-S_{T} \leq k_2 \leq S_{T'}$

将 $k_2$ 带进第二个不等式可以得到 $S_T \geq C_i-j$，于是枚举 $j,T'$ 即可完成转移，从小到大枚举 $T'$ 即可。

2. $T' \leq T \leq n$

整理一下有如下限制：

- $k_2=S_{T}-C_i+j$
- $0 \leq k_2 \leq S_{T'}$

枚举 $S_T+j$，那么 $k_2$ 为定值，再从大到小枚举 $T'$ 即可。

3. $T=n+1$

整理一下有如下限制：

- $j \leq k_2-S_{T}+C_i$
- $0 \leq k_2 \leq S_{T'}$

因为 $T$ 是定值，所以可以直接枚举 $k_2,T'$，满足条件的 $j$ 为一段前缀，求出前缀 $\max$ 即可。

由于 $f_{i,j,T}$ 中的第二维大小为 $cnt_i$，于是总状态数为 $n^2$，时间复杂度 $\mathcal O(n^2)$。

### 代码

代码中大部分地方额外考虑了限制 $0 \leq k_2 \leq C_{i+1}$。实际上不用。

```cpp
#include<bits/stdc++.h>
using namespace std;
using namespace my_std;
vector<ll> t[8080];
ll l,c[8080],n,cnt[8080],ans=-inf;
ll sum[8080],f[2][8080][8080];
int main(){
	l=read();
	fr(i,1,l) c[i]=read();
	n=read();
	fr(i,0,l-1) t[i].push_back(-(ll)inf);
	fr(i,1,n){
		ll x=read();
		t[x].push_back(i);
	}
	fr(i,0,l-1){
		t[i].push_back((ll)inf);
		cnt[i]=(ll)t[i].size()-2;
	}
	fr(T,0,n+1) f[1][0][T]=0;
	fr(i,1,l-1){
		ll o=(i+1)&1;
		fr(j,0,cnt[i]) fr(T,0,n+1) f[o][j][T]=-inf;
		fr(j,0,n+1) sum[j]=0;
		fr(j,1,cnt[i]) sum[t[i][j]]++;
		fr(j,1,n+1) sum[j]+=sum[j-1];
		fr(j,0,min(c[i],cnt[i-1])){
			ll maxx=-inf;
			fr(TT,1,n+1){
				if((c[i]-j)<=sum[TT-1]) maxx=max(maxx,f[o^1][j][TT-1]);
				ll k2=sum[TT]-c[i]+j;
				if(0<=k2&&k2<=min(c[i+1],sum[TT])) f[o][k2][TT]=max(f[o][k2][TT],maxx+cnt[i]-sum[TT]);
			}
		}
		fr(d,c[i],cnt[i-1]+cnt[i]){
			ll maxx=-inf,k2=d-c[i];
			if(k2>c[i+1]) continue;
			pfr(TT,n,0){
				if(k2>sum[TT]) break;
				ll j=d-sum[TT];
				if(0<=j&&j<=min(c[i],cnt[i-1])) maxx=max(maxx,f[o^1][j][TT]+cnt[i]-sum[TT]);
				f[o][k2][TT]=max(f[o][k2][TT],maxx);
			}
		}
		fr(j,1,min(c[i],cnt[i-1])) f[o^1][j][n+1]=max(f[o^1][j][n+1],f[o^1][j-1][n+1]);
		fr(TT,0,n+1){
			fr(k2,0,min(c[i+1],sum[TT])){
				ll lim=min(min(c[i],cnt[i-1]),k2-sum[TT]+c[i]);
				if(lim>=0) f[o][k2][TT]=max(f[o][k2][TT],f[o^1][lim][n+1]);
			}
		}
	}
	fr(j,0,min(c[l],cnt[l-1])) fr(T,0,n+1) if(T>n||j==c[l]) ans=max(ans,f[l&1][j][T]);
	write(ans); 
}
```

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P10627)

**题目大意**

> 给定 $n$ 个盒子，第 $i$ 个盒子容量为 $a_i$，然后依次给出 $m$ 个球，第 $i$ 个球可以放到 $p_i$ 或 $p_i+1$ 号盒子，如果两个盒子都满了就丢弃，求最多能丢弃多少个球。
>
> 数据范围：$n,m\le 8000$。

**思路分析**

首先我们枚举每个盒子在哪个时刻满了，记为 $t_i$，那么一个球被丢弃当且仅当 $i>\max(t_{p_i},t_{p_i+1})$。

考虑什么样的一组 $t_i$ 是合法的。

可以用二分图最大匹配问题刻画，左部是所有盒子的容量，右部连接能放到这个盒子里的球。

用 Hall 定理判定，显然我们只要考虑若干连续的盒子 $[l,r]$，能放到这些盒子里的球个数必须 $\ge\sum_{i=l}^r a_i$。

可以把这个问题看成一个类似最小子段和的问题，动态维护后缀最小值就能判定。

那么就有一个朴素 dp：$dp_{i,j,k}$ 表示前 $i$ 个盒子，$t_i=j$，且当前后缀最小值为 $k$ 的方案数。

注意到 $j$ 一定是某个 $p_x\in\{j-1,j\}$ 的 $x$，设这样的 $x$ 总数为 $s_i$，则 $k\le s_i-a_i$。

所以状态总数 $\le \sum s_i^2=\mathcal O(m^2)$。

转移时就枚举 $j'$ 算出 $(j,k)\to (j',k')$ 的系数，此时复杂度 $\mathcal O(m^3)$。

注意特殊处理 $j=\infty$ 的情况，此时这个点不在二分图中，不能考虑过这个点的区间。

判掉这种特殊情况，发现转移只在 $j'<j$ 和 $j\le j'$ 两种情况有较大区别，对于这两部分都能轻松地优化到 $\mathcal O(m^2)$。

时间复杂度 $\mathcal O(nm+m^2)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=8005,inf=1e9;
int n,a[MAXN],m,p[MAXN],s[MAXN],ct[MAXN],w[MAXN];
vector <int> b[MAXN];
vector <vector<int>> dp,f,g,nw;
inline void chkmax(int &x,const int &y) { x=y>x?y:x; }
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i],b[i].push_back(0);
	cin>>m;
	for(int i=1;i<=m;++i) cin>>p[i],b[p[i]].push_back(i),b[p[i]+1].push_back(i);
	for(int i=1;i<=n;++i) s[i]=b[i].size()-1,a[i]=min(a[i],s[i]);
	dp=vector<vector<int>>(s[1]-a[1]+1,vector<int>(s[1]-a[1]+1,-inf));
	for(int j=a[1];j<=s[1];++j) dp[j-a[1]][j-a[1]]=0;
	for(int i=2;i<=n;++i) {
		for(int j=1;j<=m;++j) ct[j]=ct[j-1]+(p[j]==i-1);
		for(int j=a[i-1];j<=s[i-1];++j) {
			w[j]=upper_bound(b[i].begin(),b[i].end(),b[i-1][j])-b[i].begin();
			w[j]=min(max(w[j],a[i]),s[i]);
		}
		nw=g=vector<vector<int>>(s[i]-a[i]+1,vector<int>(s[i]-a[i]+1,-inf));
		f=vector<vector<int>>(s[i]-a[i]+1,vector<int>(s[i-1]-a[i-1]+1,-inf));
		for(int j=a[i-1];j<=s[i-1];++j) for(int k=0;k<=s[i-1]-a[i-1];++k) {
			const int &z=dp[j-a[i-1]][k];
			if(z<0) continue;
			if(j==s[i-1]) { //j = inf
				for(int t=a[i];t<=s[i];++t) {
					chkmax(nw[t-a[i]][t-a[i]],z+ct[m]-ct[max(b[i-1][j],b[i][t])]);
				}
			} else {
				chkmax(nw[s[i]-a[i]][0],z+ct[m]-ct[max(b[i-1][j],b[i][s[i]])]); //j' = inf, k = any val
				if(a[i]<w[j]) chkmax(f[w[j]-a[i]-1][k],z+ct[m]-ct[b[i-1][j]]);
				if(w[j]<s[i]&&-min(0,k-ct[b[i-1][j]])<=s[i]-a[i]) {
					chkmax(g[w[j]-a[i]][-min(0,k-ct[b[i-1][j]])],z);
				}
			}
		}
		for(int t=a[i];t<s[i];++t) for(int x=0;x<=s[i]-a[i];++x) {
			if(t>a[i]) chkmax(g[t-a[i]][x],g[t-a[i]-1][x]);
			int mn=-x+t-a[i];
			if(mn>=0) chkmax(nw[t-a[i]][mn],g[t-a[i]][x]+ct[m]-ct[b[i][t]]);
		}
		for(int t=s[i]-1;t>=a[i];--t) for(int k=0;k<=s[i-1]-a[i-1];++k) {
			chkmax(f[t-a[i]][k],f[t-a[i]+1][k]);
			int mn=min(0,k-ct[b[i][t]])+t-a[i];
			if(mn>=0) chkmax(nw[t-a[i]][mn],f[t-a[i]][k]);
		}
		dp.swap(nw);
	}
	int ans=0;
	for(int j=a[n];j<=s[n];++j) for(int k=0;k<=s[n]-a[n];++k) chkmax(ans,dp[j-a[n]][k]);
	cout<<ans<<"\n";
	return 0;
}
```

---


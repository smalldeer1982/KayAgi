# [SNCPC2024] 最大流

## 题目描述

给定一个 $n$ 个点 $m$ 条边的有向无环图，图中每条边的容量为 $1$。对点 $1$ 以外的每个点 $i$，设从点 $1$ 到点 $i$ 的最大流为 $f_i$，试求出 $\min\{f_i,\ k\}$。

在边容量为 $1$ 的图上，一个从点 $1$ 到点 $i$ 的流即为一条从点 $1$ 到点 $i$ 的路径。如果从点 $1$ 到点 $i$ 最多能同时有 $f_i$ 个不交的流（即没有一条边同时属于两个流），则我们认为点 $1$ 到点 $i$ 的最大流是 $f_i$。

## 说明/提示



第一个样例所述图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/5sl6gmj6.png)


我们可以找到 $4$ 条从点 $1$ 到点 $7$ 的不相交路径：

$\text{1->7}$

$\text{1->5->7}$

$\text{1->3->6->7}$

$\text{1->2->4->7}$

我们无法找到更多条从点 $1$ 到点 $7$ 的不相交路径：


所以点 $1$ 到点 $7$ 的最大流为 $f_7=4$，但是因为 $k=3$，所以答案的第六个整数为 $3$。

## 样例 #1

### 输入

```
7 12 3
1 2
1 3
3 2
3 4
2 4
1 5
5 6
3 6
1 7
5 7
6 7
4 7
```

### 输出

```
2 1 2 1 2 3 
```

## 样例 #2

### 输入

```
5 8 50
1 2
1 2
1 2
3 2
2 4
2 4
2 4
2 4
```

### 输出

```
3 0 3 0 
```

# 题解

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P10698)
## 题意

给定一个 $n$ 个点 $m$ 条边的单位网络，保证该网络不存在环。给定一个常数 $k$，设从 $1$ 到 $i$ 的最大流为 $f_i$，对 $\forall i\in[2,n]$ 求出 $\min(f_i,k)$。

$n\le 10^5$，$m\le 2\times10^5$，$k\le\min(n-1,50)$。
## 思路

不相交路径，考虑 LGV 引理。但此处不相交路径只要求边不相交，于是我们把边看成点，每个点的所有入边向所有出边连边，这样边不相交便转化为了点不相交。

从 [P9041](https://www.luogu.com.cn/problem/P9041) 我们了解到，该问题的解法为给每条边随机赋上 $[0,P)$ 的权值，则起点集合 $s_{1\dots x}$ 到终点集合 $t_{1\dots y}$ 的答案就是矩阵 $e_{s_i,t_j}(i\in[1,x],j\in[1,y])$ 的秩。

我们现在需要解决两个问题：
1. 起点集合（即 $1$ 的所有出边）可能很大。我们新建源点 $s$ 和 $k$ 个虚点 $p_{1\dots k}$，连边 $s\to p_i,p_i\to t$ 即可，其中 $t$ 为 $1$ 的任意出点。于是起点集合的大小被我们减小到了 $O(k)$。
2. 如果一个点的入度出度均较大，那么这个点的入边出边之间的边数会很大。注意到这些边都会随机赋一个权，相当于每个出边对应的向量为所有入边对应的向量的随机线性组合。于是对于入边，我们只需要保留线性无关的不超过 $k$ 组向量即可，这个任务可以交给线性基解决。

总时间复杂度 $O((n+m)k^2)$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
    
}
namespace rad{
    mt19937_64 R(chrono::system_clock::now().time_since_epoch().count());
    inline int Rand(int l,int r){
        uniform_int_distribution<int> distribution(l,r);
        return distribution(R);
    }
}using namespace rad;
const int N=1e5+10,K=50+2,mod=1e9+9;
namespace PolyC{
    #define Poly vector<int>
    inline int qpow(int x,int y){
        int res=1;
        while(y){
            if(y&1) res=1ll*res*x%mod;
            x=1ll*x*x%mod;
            y>>=1;
        }
        return res;
    }
    inline int add(int a,int b){
        return a+b>=mod?a+b-mod:a+b;
    }
    inline int dec(int a,int b){
        return a>=b?a-b:a+mod-b;
    }
    inline Poly operator+(const Poly &a,const Poly &b){
        Poly F=a;
        F.resize(max(a.size(),b.size()));
        for(int i=0;i<b.size();i++)
            F[i]=add(F[i],b[i]);
        return F;
    }
    inline Poly operator-(const Poly &a,const Poly &b){
        Poly F=a;
        F.resize(max(a.size(),b.size()));
        for(int i=0;i<b.size();i++)
            F[i]=dec(F[i],b[i]);
        return F;
    }
    inline Poly operator*(const Poly &a,const int &b){
        Poly F=a;
        for(int i=0;i<F.size();i++)
            F[i]=1ll*F[i]*b%mod;
        return F;
    }
}
using namespace PolyC;
int n,m,k,d[N];
Poly ct[N];
vector<int>a[N];
struct LnB{
	int c;
    bool vs[K];
    Poly v[K];
    inline void ins(Poly vt){
        for(int i=0;i<k;i++){
            if(!vt[i]) continue;
            if(!vs[i]){
                vs[i]=1,v[i]=vt,c++;
                return ;
            }else{
                int b=1ll*qpow(v[i][i],mod-2)*vt[i]%mod;
                vt=vt-v[i]*b;
            }
        }
    }
}L[N];
inline void bfs(){
    queue<int>q;
    for(int t:a[1]){
    	Poly X(k,0);
    	for(int i=0;i<k;i++)
    		X[i]=Rand(1,mod-1);
    	L[t].ins(X),d[t]--;
	}
    for(int i=2;i<=n;i++)
        if(!d[i])
            q.push(i);
    while(!q.empty()){
        int x=q.front();
        q.pop();
        vector<Poly>vc;
        for(int i=0;i<k;i++)
        	if(L[x].vs[i])
        		vc.push_back(L[x].v[i]);
        for(auto t:a[x]){
            Poly X(k,0);
            for(auto I:vc)
            	X=X+I*Rand(1,mod-1);
            L[t].ins(X);
            if(!--d[t]) q.push(t);
        }
    }
}
int main(){
    n=read(),m=read(),k=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        a[u].push_back(v),d[v]++;
    }
    for(int i=1;i<=n;i++)
        ct[i].resize(k);
    bfs();
    for(int i=2;i<=n;i++)
        write(L[i].c),putc(' ');
	flush();
}
```

---

## 作者：Otomachi_Una_ (赞：1)

首先限制了流量最大值。我们就建一个虚拟原点，向 $1$ 连 $k$ 条边即可。

然后这个流的边不交启发我们想到 LGV。我们给边建边，一个点的内向边全部连向外向边。

那么问题变成了两个点集 $S,T$。选最多的 $S\to T$ 的不交路径。容易 LGV 解决。具体地，先给每条边随机赋权，假设 $e_{i,j}$ 表示 $S_i\to T_j$ 所有路径的边权乘积的和。那么答案就是所有 $i$，$e_{i,*}$ 的秩。

我们现在建出来这个图，维护每个边到前 $k$ 个点的方案数（实际上你可以看成一个 $k$ 位向量）。但是有个问题就是边太多了，我们建不出来。

但是你发现一个点 $u$，把其入边的向量拉出来作线性基。那么出边实际上就是在线性基的张成空间随一个出来。对每个基随一个权值加起来就行了。

---

## 作者：liyixin0514 (赞：1)

# [P10698 [SNCPC2024] 最大流](https://www.luogu.com.cn/problem/P10698)

[可能更好的阅读体验](https://www.cnblogs.com/liyixin0514/p/18651030)

## 题意

给一个 $n$ 个点 $m$ 条边的 DAG，起点为 $1$，终点不定，容量全为 $1$。再给定一个常数 $k$。设从 $1$ 到 $i$ 的最大流是 $f_i$，对所有的 $i\in[2,n]$ 求出 $\min(f_i,k)$。

$n\le 10^5,m\le 2\times 10^5,k\le \min(50,n-1)$。

## 思路

只有一个终点就可以直接跑网络流。

最大流就是问最多有多少路径满足起点在 $S$，终点在 $T$，没有交边。

将边转化成点，称之为假点，原来的点叫做真点。

问题变成给你一个起点的假点集合 $A$，即真点起点的出边集合，和一个终点的假点集合 $B$，即真点终点的入边集合。问最多的没有交点的路径条数，和 $k$ 取 $\min$。

-----

容易想到 LGV 引理。LGV 引理可以求所有划分不相交路径方式的贡献之和。一条路径的贡献定义为路径所有边的边权之积。

经典的套路，要知道最多有多少条不交的路径，就是随机赋边权，然后求 LGV 引理的矩阵 $M$ 的秩。

具体地，$M_{i,j}$ 定义为从 $A_i$ 到 $B_j$ 所有路径权值之和。

------

目前 $|A|$ 和 $|B|$ 都是 $O(n)$ 的。

答案对 $k$ 取 $\min$。

起点集合太大的情况，我们可以建 $k$ 个虚的真点，与 $1$ 相连。

然后我们就只有 $k$ 个起点了，$M$ 是 $n\times k$ 的。

考虑按着 DAG 的拓扑序扫描终点集合 $B$。处理到真点 $u$ 时，新的终点集合 $B'$，对于其中一个假点 $B_i'$，我们已知与它相邻的拓扑序较小的那个点的矩阵 $M$，有 $M_i' = \sum M_j w_{i,j}$，其中 $w$ 是我们随机赋的边权。

然后你惊奇地发现，因为 $w$ 是随机的，所以对于线性相关的 $M_x,M_y$，你只需要加其中一个就可以了，因为总是存在随机 $w$ 的方式使得某种随机权值下加两个的效果等同于另一种随机权值下加一个的效果。

因此我们对 $M$ 的行向量求线性基。然后线性基的大小是 $k \times k$ 的。

因此对于每条真边，都要做一次 $O(k^2)$ 的转移，对每个真点得到一个 $O(nk)$ 的矩阵，还要对矩阵求线性基，是 $O(nk^2)$ 的。

因此总时间复杂度 $O((n+m)k^2)$。给了 $15s$，包过的吧。

## code

```cpp
#include<bits/stdc++.h>
#define sf scanf
#define pf printf
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
typedef long long ll;
namespace proficient {
	constexpr int N=1e5+7,M=2e5+7,mod=1e9+7;
	mt19937 rd(random_device{}());
	int add(int a,int b) { return a+b>=mod ? a+b-mod : a+b; }
	void _add(int &a,int b) { a=add(a,b); }
	int mul(int a,int b) { return 1ll*a*b%mod; }
	void _mul(int &a,int b) { a=mul(a,b); }
	int ksm(int a,int b=mod-2) { 
		int s=1;
		while(b) {
			if(b&1) _mul(s,a);
			_mul(a,a);
			b>>=1;
		}
		return s;
	}
	int n,m,k;
	int u,v;
	vector<int> fr[N],tp,to[N];
	int in[N];
	int ans[N];
	struct node {
		int x[50];
		int &operator [] (int pos) { return x[pos-1]; }
		void clear() { memset(x,0,sizeof(x)); }
	}a;
	node operator * (node x,const int y) {
		rep(i,1,k) _mul(x[i],y);
		return x;
	}
	node operator += (node &x,node y) {
		rep(i,1,k) _add(x[i],y[i]);
		return x;
	}
	node operator -= (node &x,node y) {
		rep(i,1,k) _add(x[i],mod-y[i]);
		return x;
	}
	struct xxj {
		node x[50];
		node &operator [] (int pos) { return x[pos-1]; }
		void insert(node y) {
			rep(i,1,k) {
				if(!y[i]) continue;
				if(x[i-1][i]) {
					int d=mul(y[i],ksm(x[i-1][i]));
					y-=x[i-1]*d;
				}else {
					x[i-1]=y;
					return;
				}
			}
		}
		int size() {
			int cnt=0;
			rep(i,1,k) if(x[i-1][i]) ++cnt;
			return cnt;
		}
	}b[N+50];
	void main() {
		sf("%d%d%d",&n,&m,&k);
		rep(i,1,m) {
			sf("%d%d",&u,&v);
			in[v]++;
			fr[v].push_back(u);
			to[u].push_back(v);
		}
		queue<int> q;
		rep(i,1,n) if(!in[i]) q.push(i);
		while(!q.empty()) {
			int u=q.front();
			tp.push_back(u);
			q.pop();
			for(int v : to[u]) if(!(--in[v])) q.push(v);
		}
		rep(i,1,k) {
			// e[i+m]={i+n,1};
			fr[1].push_back(i+n);
			a.clear();
			a[i]=1;
			b[i+n].insert(a);
		}
		for(int u : tp) {
			int it=0;
			for(int v : fr[u]) {
				++it;
				a.clear();
				rep(i,1,k) {
					int w=abs((int)rd())%mod;
					if(b[v][i][i]) a+=b[v][i]*w;
				}
				b[u].insert(a);
			}
			ans[u]=b[u].size();
		}
		rep(i,2,n) pf("%d ",ans[i]);
	}
}
int main() {
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("my.out","w",stdout);
    #endif
	proficient :: main();
}
```

---

## 作者：Grisses (赞：1)

题目要求边不能同时经过多次，考虑将边看作点然后连边，问题就变成了点不相交。

因为要求路径不相交，所以考虑 lgv 引理。但是 lgv 引理求的是行列式，这里显然是积和式更能代表答案，因为行列式为 0 的时候积和式可能不为 0，考虑对每条建出的边随机赋权，然后信仰跑，大概率是不会错的。

回到原题，我们发现另一个问题，如果一个点的度数太大会使新图的边数爆炸，我们结合答案对 $k$ 取 $\min$ 的限制考虑如果一个点的度数超过了 $k$ 就建 $k$ 个虚点来与所有的边连边，这样总边数就被控制在 $km$ 只内。记点 $i$ 的度数和 $k$ 取模的值为 $num_i$。

现在对于一个点 $x$，我们可以得到一个 $num_1\times num_x$ 的矩阵 $A_i$，lgv 引理的过程就是找一个最大的子矩阵使得行列式不为 0，然后我们发现这其实就是矩阵的秩，高消跑完看剩了几行就可以了。

总复杂度 $O(k(nk+m)km+nk^3)$。

---

代码:

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=1e9+7;
int fpow(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=(ll)res*a%mod;
		a=(ll)a*a%mod;
		b>>=1;
	}
	return res;
}
mt19937 Rand(time(0));
int n,m,k,tot;
struct edge{
	int v,w;
};
vector<edge>g[5200005];
int Id[100005][55],num[100005],dp[5200005],in[5200005],u[200005],v[200005];
vector<int>val[100005][55];
void init(int pos){
	memset(dp,0,sizeof(dp));
	for(int i=1;i<=tot+m;i++){
		for(auto v:g[i])in[v.v]++;
	}
	queue<int>q;
	for(int i=1;i<=tot+m;i++){
		if(!in[i])q.push(i);
	}
	dp[Id[1][pos]]=1;
	while(!q.empty()){
		int tmp=q.front();
		q.pop();
		for(auto v:g[tmp]){
			in[v.v]--;
			dp[v.v]=(dp[v.v]+(ll)dp[tmp]*v.w%mod)%mod;
			if(!in[v.v])q.push(v.v);
		}
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<=num[i];j++){
			val[i][pos].push_back(dp[Id[i][j]]);
		}
	}
}
int x[55][55];
int Rank(int n){
	int cnt=1;
	for(int i=1;i<=n;i++){
		if(x[cnt][i]==0){
			for(int j=cnt+1;j<=n;j++){
				if(x[j][i]){
					for(int k=1;k<=n;k++)swap(x[cnt][k],x[j][k]);
					break;
				}
			}
		}
		if(x[cnt][i]==0)continue;
		int inv=fpow(x[cnt][i],mod-2);
		for(int j=cnt+1;j<=n;j++){
			int p=(mod-(ll)x[j][i]*inv%mod);
			for(int k=1;k<=n;k++){
				x[j][k]=(x[j][k]+(ll)x[cnt][k]*p%mod)%mod;
			}
		}
		cnt++;
	}
	return cnt-1;
}
signed main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u[i],&v[i]);
		num[u[i]]++,num[v[i]]++;
	}
	for(int i=1;i<=n;i++)num[i]=min(num[i],k);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=num[i];j++){
			Id[i][j]=++tot;
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=num[u[i]];j++){
			int w=Rand()%mod;
			g[Id[u[i]][j]].push_back(edge({i+tot,w}));
		}
		for(int j=1;j<=num[v[i]];j++){
			int w=Rand()%mod;
			g[i+tot].push_back(edge({Id[v[i]][j],w}));
		}
	}
	for(int i=1;i<=num[1];i++)init(i);
	for(int i=2;i<=n;i++){
		memset(x,0,sizeof(x));
		for(int j=1;j<=num[1];j++){
			for(int l=1;l<=num[i];l++)x[j][l]=val[i][j][l-1];
		}
		printf("%d ",Rank(k));
	}
    return 0;
}
```

---

## 作者：Autre (赞：1)

## 做法

设所有模 $P$ 意义下 $k$ 维整数向量构成的线性空间为 $W$。将每个点 $u$ 对应到 $W$ 的一个子空间 $V_u$。其中：

- 起点 $1$ 对应的线性空间 $V_1=W$。
- 对于点 $u\not=1$，所有边 $(v,u)$ 在 $V_v$ 中均匀随机选取一个向量后，$V_u$ 为这些向量张成的线性空间。

实现的时候用线性基表示一个线性空间。在线性空间中等概率随机取向量，相当于给线性基的每个位置随机赋权求和。

最终 $V_u$ 的秩即为 $f_u$。

## 证明

考察原图的线图 $G$，原图中每一条边与 $G$ 中每个点一一对应，对于原图中的边 $(u,v),(v,w)$，$G$ 中有边 $((u,v),(v,w))$。

那么原图上一组 $1$ 到 $i$ 的流量为 $t$ 的方案，对应 $G$ 中起点集为 $(1,*)$ 终点集为 $(*,i)$ 的 $t$ 条点不交路径组。$(1,*)$ 和 $(*,i)$ 分别表示原图中以 $1$ 为起点的和以 $i$ 为中点的边在线图 $G$ 中对应的点。

原图中的边 $(v,w)$ 在 $V_v$ 中随机选取了一个向量，等价于给所有 $(u,v)$ 选出的向量随机加权后求和。这可以看做是给 $((u,v),(v,w))$ 随机赋权。而 $(1,*)$ 选出的向量可以看做在 $G$ 中建 $k$ 个虚点，对应 $k$ 个互不相同的形如 $(0,\cdots,0,1,0,\cdots,0)^T$ 的向量，分别向每个 $(1,*)$ 连边，这些边随机赋权。

我们称一条路径的权值为每个边的权值之积，那么原图中一个边 $e$ 选出的向量的第 $i$ 个位置上的数等价于 $G$ 中第 $i$ 个位置为 $1$ 的虚点到 $e$ 的所有路径的权值之和。

而 $V_u$ 的秩的含义为在所有入边选取的向量排成的矩阵的最大非零子式的大小。由 LGV 引理，该矩阵的一个子式为 $G$ 中从选取的若干列对应的起点，到选取的若干行对应的终点，所有点不交路径组的带 $\pm1$ 权的权值和。如果这样的路径组不存在，该子式一定为 $0$，否则是一个最长路长度次的随机变量多项式。根据 Schwartz-Zippel 引理，这个多项式为 $0$ 的概率不超过 $\frac nP$。

不过算错答案当且仅当每种最大路径组方案对应的子式全部为 $0$，一个测试点错当且仅当存在一个 $f_i$ 算错，这俩都不独立，不会分析，摆烂了。

---

## 作者：lizhous (赞：1)

萌新刚学 OI，不了解术语请见谅。

考虑 LGV 引理，每个边变成一个点，每条入边向每个出边连边。由于最大流最多为 $k$，所以建 $k$ 个起点分别往 $1$ 的所有出边连边。建 $k$ 个终点，枚举汇点，把汇点所有入边分别往 $k$ 个终点连边。注意汇点是原图上的点，而起点终点是我们新建的。

这样做完后问题变为选出尽可能多个起点终点，使得存在一个路径组，每条路径连接一个起点和一个终点，且每个点最多只在一条路径上。

LGV 引理用于计算带符号的所有不交路径组边权积的和，而我们在这里只需要知道存在性。一个套路是给每条边随机赋权值来去除符号的影响，这样判别存在性就变为判定行列式是否为 $0$，即行向量是否线性无关。那么上述问题就可以转为求最多选出多少组行向量使其线性无关。假如我们能维护该矩阵，我们可以使用线性基简单算出答案。

现在我们只需考虑如何维护 LGV 的矩阵，即每个起点到每个终点的所有路径边权积的和。

记录 $f_{i,j}$ 表示从起点 $j$ 走到边 $i$ 的所有路径边权积的和。转移即给其所有入边随机一个权值，与上一个点的 $f$ 相乘并求和。而由于转移是随机线性组合，所以我们可以对可转移的 $f_i$ 建线性基，只转移线性基中的 $f$ 是对的。这么做就把转移压到 $k$ 级别的了。

由于原图上一个点的入边可以向所有出边转移，所以我们只需要对于原图每个点建一遍入边线性基维护出边的转移即可。

最后因为乘了随机边权，矩阵的秩就是终点线性基大小。上述操作都能在拓扑排序的过程中简单维护。时间复杂度 $O(nk^2)$。

---


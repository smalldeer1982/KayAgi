# [NOI2024] 树的定向

## 题目背景

由于评测机性能差异，原题时限为 3s，洛谷上时限为 6s。

## 题目描述

给定一棵含有 $n$ 个顶点的树，顶点从 $1$ 到 $n$ 编号，树上第 $i(1\leq i\leq n-1)$ 条边连接顶点 $u_i$ 和 $v_i$。

现在，我们想要给树的每条边一个定向。任何一个定向都可以用一个长度为 $n-1$ 的字符串 $S=s_1s_2\ldots s_{n-1}$ 来描述。其中 $s_i=0$ 代表第 $i$ 条边定向为 $u_i \to v_i$，否则 $s_i=1$ 代表第 $i$ 条边定向为 $v_i\to u_i$。

给定 $m$ 个顶点对 $(a_i,b_i)$，其中 $1\leq a_i,b_i \leq n$ 且 $a_i\neq b_i$。

一个**完美定向**定义为：在此定向下，对于任意 $1\leq i\leq m$，$a_i$ ****不能到达**** $b_i$。

试求在所有完美定向中，所对应的字符串字典序最小的定向。**数据保证存在至少一个完美定向**。

定义字符串 $S=s_1s_2\ldots s_{n-1}$ 的字典序小于 $T=t_1t_2\ldots t_{n-1}$ 若存在一个下标 $k$ 使得 $s_1=t_1, s_2=t_2, \ldots, s_{k-1}=t_{k-1}$ 且 $s_k < t_k$。


## 说明/提示

**【样例 1 解释】**

在该样例中，若 $S=000$，则该定向中 $1$ 能到达 $4$（存在路径 $1\to 2\to 3\to 4$），因而不是完美定向。若 $S=001$，则该定向中 $3$ 不能到达 $2$，$1$ 不能到达 $4$，因面是完美定向。故答案为 $001$。

**【样例 2 解释】**

在该样例中，一组完美定向必定满足 $4$ 不能到达 $3$，$5$ 不能到达 $1$。故 $s_1=s_5=1$。若 $s_2=s_3=0$，则存在路径 $1\to 2\to 3\to 4$，故 $1$ 可到达 $4$。故其不是完美定向。因此，所有完美定向必定满足 $S$ 的字典序不小于 $10101$。且容易验证 $S=10101$ 时，对应的定向是完美定向。

**【数据范围】**

对于所有测试数据保证 $2\leq n\leq 5\times 10^5$，$1\leq m\leq 5\times 10^5$，$1\leq u_i,v_i\leq n$ 且所有的边构成了一棵树，$1\leq a_i,b_i \leq n$ 且 $a_i\neq b_i$。

数据保证存在至少一个完美定向。

::cute-table{tuack}

| 测试点编号 | $n$ | $m$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $\leq 15$ | $\leq 50$ | 无 |
| $4\sim 6$ | $\leq 300$ | $\leq 300$ | 无 |
| $7,8$ | $\leq 400$ | $=(n-1)(n-2)$ | A |
| $9,10$ | $\leq 2\,000$ | $\leq 2\,000$ | B |
| $11\sim 14$ | $\leq 2\,000$ | $\leq 2\,000$ | 无 |
| $15,16$ | $\leq 10^5$ | $\leq 10^5$ | B |
| $17,18$ | $\leq 10^5$ | $\leq 10^5$ | 无 |
| $19\sim 21$ | $\leq 2\times 10^5$ | $\leq 2\times 10^5$ | 无 |
| $22\sim 25$ | $\leq 5\times 10^5$ | $\leq 5\times 10^5$ | 无 |

- 特殊性质 A：保证 $(a,b)$ 出现在 $(a_i,b_i)$ 中当且仅当 $a\neq b$ 且 $a,b$ 在树上不相邻。
- 特殊性质 B：保证树上编号为 $1$ 的顶点与其他每个顶点均相邻。

## 样例 #1

### 输入

```
0 4 2
1 2
2 3
3 4
3 2
1 4```

### 输出

```
001```

## 样例 #2

### 输入

```
0 6 8
5 1
2 3
1 2
5 6
4 3
4 3
5 1
6 3
5 4
1 4
5 2
3 6
6 2```

### 输出

```
10101```

## 样例 #3

### 输入

```
见 tree3.in/tree3.ans
这个样例满足测试点 1-3 的约束条件。```

### 输出

```
```

## 样例 #4

### 输入

```
见 tree4.in/tree4.ans
这个样例满足测试点 4-6 的约束条件。```

### 输出

```
```

## 样例 #5

### 输入

```
见 tree5.in/tree5.ans
这个样例满足测试点 7,8 的约束条件。```

### 输出

```
```

## 样例 #6

### 输入

```
见 tree6.in/tree6.ans
这个样例满足测试点 9,10 的约束条件。```

### 输出

```
```

# 题解

## 作者：C1942huangjiaxu (赞：20)

首先要想出本题的关键结论，**如果每条路径 $a_i,b_i$ 之间都有至少 2 条边没被定向，那么一定有解。**

证明如下，考虑特殊性质 A，可以简单构造出一组解：
+ **将树二分图黑白染色，每条边都指向黑色点**，因为每条路径上都至少有 3 个点，一定经过至少一条黑白边和白黑边，所以不能到达。

一般情况中，有一些边已经定向了。

考虑**缩边**，对于一条已经定向的边，考虑经过它的所有路径，不同向的路径可以直接删除，仅保留同向的路径，然后这条边就没用了，可以直接把两个端点合并。

于是，如果每条路径 $a_i,b_i$ 之间都有至少 2 条边没被定向，那么我们可以通过缩边变为特殊性质 A，所以一定有解。

而如果存在一条路径上只有 1 条边没定向，那这条边的方向可以唯一确定。

因此我们得到了一个 $\operatorname{poly}(nm)$ 的做法，按编号从小到大枚举每一条边的方向，判断有没有解。

注意到**在特殊性质 A 中，二分图染色后黑白点并没有本质区别，所以我们给某一条边随意定向后依旧有解。**

那么我们可以**省掉枚举方向的步骤**，如果存在一条的路径中只有 1 条边没定向，那么直接定向，否则，我们直接选择编号最小的边定向为 $u\rightarrow v$。

现在瓶颈在于，如何支持删边和快速找到只有 1 条边没定向的路径。

注意到这是一个类似拓扑排序的过程，只不过加入队列的条件变为**度数 $\le 1$**。

我们需要将每条边向经过它的所有路径连边，可以**倍增优化建图**做到 $O(n\log n)$。

我们找的一条路径后，还需要**判断它是否已经不可达了**，如果还可达的情况下，我们需要**找到那条还没定向的边**。

这里有个很聪明的做法，考虑用**树上带权并查集维护**，删边后就把这个点和父亲合并，这样找到没定向的边是容易的。

判断是否已经不可达，相当于求路径上是否有某个方向的边，因为路径上最多只有 1 条边没定向，所以路径已经合并为 $O(1)$ 个集合，带权并查集维护每个点到祖先的边权和即可。

时空复杂度 $O((n+m)\log n)$，常数较大。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5,M=N*21;
char buf[1<<23],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<23,stdin),p1==p2)?EOF:*p1++)
template<class rd>
void read(rd &x){
	char c=getchar();
	for(;c<48||c>57;c=getchar());
	for(x=0;c>47&&c<58;c=getchar())x=(x<<1)+(x<<3)+(c^48);
}
int tid,n,m,u[N],v[N],fa[N][19],id[N][19],dp[N],tot;
int a[N],b[N],c[N],ans[N],f[N],d[N],lg[N];
int sz[M],cur[M],hd[M],to[3*M],nx[3*M],num;
vector<int>e[N];
queue<int>q;
void adde(int x,int y){
	nx[++num]=hd[x],hd[x]=num,to[num]=y;
}
void dfs(int x,int y){
	fa[x][0]=y,dp[x]=dp[y]+1,id[x][0]=++tot;
	sz[tot]=cur[tot]=1;
	for(int i=1;i<19;++i){
		fa[x][i]=fa[fa[x][i-1]][i-1];
		if(!fa[x][i])break;
		id[x][i]=++tot,sz[tot]=cur[tot]=1<<i;
		adde(id[x][i-1],tot);
		adde(id[fa[x][i-1]][i-1],tot);
	}
	for(auto v:e[x])if(v!=y)dfs(v,x);
}
int lca(int x,int y){
	if(dp[x]<dp[y])swap(x,y);
	for(int i=lg[dp[x]-dp[y]];~i;--i)if(dp[fa[x][i]]>=dp[y])x=fa[x][i];
	if(x==y)return x;
	for(int i=lg[dp[x]];~i;--i)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
void link(int x,int y,int i){
	for(int j=lg[dp[x]-dp[y]];~j;--j)if(dp[fa[x][j]]>=dp[y])
		adde(id[x][j],i),x=fa[x][j];
}
int gf(int x){
	if(f[x]==x)return x;
	int y=gf(f[x]);
	d[x]+=d[f[x]];
	f[x]=y;
	return y;
}
inline bool chk(int x,int y,bool fg){
	return fg?d[x]-d[y]<dp[x]-dp[y]:d[x]>d[y];
}
int find(int i){
	int x=gf(a[i]),y=gf(b[i]),z=gf(c[i]);
	if(x==y)return -1;
	if(x==z){
		if(chk(b[i],y,0)||chk(a[i],c[i],1))return -1;
		int o=fa[y][0];
		if(gf(o)!=z||chk(o,c[i],0))return -1;
		ans[y]=d[y]=1,f[y]=o;
		return y;
	}
	if(y==z){
		if(chk(b[i],c[i],0)||chk(a[i],x,1))return -1;
		int o=fa[x][0];
		if(gf(o)!=z||chk(o,c[i],1))return -1;
		ans[x]=d[x]=0,f[x]=o;
		return x;
	}
	return -1;
}
void upd(int x){
	int dt=sz[x]-cur[x];
	if(x<=m&&cur[x]==1)q.push(x);
	for(int i=hd[x],v;v=to[i],i;i=nx[i]){
		cur[v]-=dt;
		if(cur[v]<2)upd(v);
	}
	sz[x]=cur[x];
}
int main(){
	read(tid),read(n),read(m),tot=m,lg[0]=-1;
	for(int i=1;i<=n;++i)lg[i]=lg[i>>1]+1;
	for(int i=1;i<n;++i){
		read(u[i]),read(v[i]);
		e[u[i]].emplace_back(v[i]);
		e[v[i]].emplace_back(u[i]);
	}
	dfs(1,0);
	for(int i=1;i<=m;++i){
		read(a[i]),read(b[i]);
		c[i]=lca(a[i],b[i]);
		link(a[i],c[i],i);
		link(b[i],c[i],i);
		sz[i]=cur[i]=dp[a[i]]+dp[b[i]]-2*dp[c[i]];
		if(sz[i]==1)q.push(i);
	}
	for(int i=1;i<=n;++i)ans[i]=-1,f[i]=i,d[i]=0;
	for(int i=1;i<n;++i){
		while(!q.empty()){
			int x=q.front();
			q.pop();
			int o=find(x);
			if(~o)--cur[id[o][0]],upd(id[o][0]);
		}
		int x=u[i],y=v[i];
		if(fa[y][0]==x)swap(x,y);
		if(~ans[x])continue;
		ans[x]=d[x]=(x==u[i]),f[x]=y;
		--cur[id[x][0]],upd(id[x][0]);
	}
	for(int i=1;i<n;++i){
		if(fa[u[i]][0]==v[i])putchar(48+(ans[u[i]]^1));
		else putchar(48+ans[v[i]]);
	}
	putchar(10);
	return 0;
}
```

---

## 作者：int_R (赞：5)

我感觉这题好爆了，思路非常的顺。

在特殊性质 A 下，将树黑白染色，可以构造出两种方案。将第一条边的方向钦定为 $0$ 即可。

一般的情况中，将一条边定向后，可以将经过这条边且与这条边方向相反的限制全部忽略，然后这条边就可以缩起来。

当一条未被忽略的限制中只有一条边仍未被定向，那么这条边的方向就已经固定了。

当每条未被忽略的限制中均有至少两条边未被定向，就与特殊性质 A 等价了，此时给任意一条边任意定向都会有合法解。

于是算法流程就是：

- 尝试找到一条限制中只有一条边仍未被定向，若此限制不可被忽略则给这条边定向。

- 当找不到只有一条边仍未被定向的限制时，给当前未定向的编号最小的边定向 $0$。

于是现在要做的是“找到只有一条边仍未被定向的限制”，以及“判断是否可以从一个点到达另一个点”。

对于第一个问题考虑倍增优化建图，将一个限制拆成 $\log n$ 个树链。每个树链给限制两个贡献，在这条树链中未被定向的边减到 $1$ 或 $0$ 时减掉一个贡献，当一个限制仅剩一个贡献时加入队列。当处理完 $x$ 点往上一个长度 $2^i$ 的树链后，检查一下与 $x$ 的 $2^i$ 级祖先和 $2^i$ 级后代往上长度 $2^i$ 的树链，看看合成长度 $2^{i+1}$ 的树链后是否需要处理。

对于第二个问题只需要用带权并查集维护一下从 $x$ 点到它当前连通块内祖先的向上、向下的路径条数，再做树上差分即可。然后就能判断一条限制是否需要忽略了。


```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#define ll long long
using namespace std;
const int N=5e5+10;
int c,n,m,x[N],y[N],z[N],a[N],b[N],L[N];
int k[N],dep[N],f[N][20],d[N],vis[N][20];
int fa[N],s[N][2];bool F[N];queue <int> q;
vector <int> v[N],e[N][20],g[N][20];
void dfs(int x)
{
    dep[x]=dep[f[x][0]]+1;
    for(int i=1;i<=__lg(dep[x]);++i)
    {
        f[x][i]=f[f[x][i-1]][i-1],vis[x][i]=2;
        e[f[x][i-1]][i-1].push_back(x);
    }
    for(int y:v[x]) if(y!=f[x][0])
        f[y][0]=x,vis[y][0]=1,dfs(y);
}
inline void add(int x,int t,int y)
    {g[x][t].push_back(y),d[y]+=(t?2:1);}
inline int find(int x)
{
    if(fa[x]==x) return x;int fax=find(fa[x]);
    s[x][0]+=s[fa[x]][0],s[x][1]+=s[fa[x]][1];
    return fa[x]=fax;
}
inline void del(int x,int t,int flag)
{
    if(flag>=2) return ;vis[x][t]=flag;
    for(int y:g[x][t]) if(--d[y]==1) q.push(y);
    for(int y:e[x][t]) del(y,t+1,flag+vis[y][t]);
    if(f[x][t+1]) del(x,t+1,flag+vis[f[x][t]][t]);
}
inline void set(int x,int o)
    {z[x]=o,s[x][o]++,del(x,0,0),fa[x]=f[x][0];}
signed main()
{
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    cin>>c>>n>>m;
    for(int i=1;i<=n;++i) fa[i]=i,z[i]=-1;
    for(int i=1;i<n;++i)
    {
        cin>>x[i]>>y[i];
        v[x[i]].push_back(y[i]);
        v[y[i]].push_back(x[i]);
    }
    dfs(1);for(int i=1;i<n;++i)
    {
        F[i]=(f[y[i]][0]==x[i]);
        F[i]?k[y[i]]=0:k[x[i]]=1;
    }
    for(int i=1,x,y;i<=m;++i)
    {
        cin>>x>>y,a[i]=x,b[i]=y;
        if(dep[x]<dep[y]) swap(x,y);
        while(dep[x]>dep[y])
        {
            int t=__lg(dep[x]-dep[y]);
            add(x,t,i),x=f[x][t];
        }
        if(x==y){L[i]=x;continue;}
        for(int j=__lg(dep[x]);~j;--j)
        {
            if(f[x][j]==f[y][j]) continue;
            add(x,j,i),add(y,j,i);
            x=f[x][j],y=f[y][j];
        }
        add(x,0,i),add(y,0,i),L[i]=f[x][0];
    }
    for(int i=1;i<=m;++i) if(d[i]==1) q.push(i);
    for(int o=1;o<n;++o)
    {
        while(!q.empty())
        {
            int p=q.front();q.pop();if(!d[p]) continue;
            int x=find(a[p]),y=find(b[p]),cur=0;
            int len=dep[a[p]]+dep[b[p]]-(dep[L[p]]<<1);
            if(dep[x]<dep[y])
            {
                find(L[p]),find(f[y][0]);
                cur+=(s[a[p]][1]-s[L[p]][1]);
                cur+=(s[f[y][0]][0]-s[L[p]][0])+s[b[p]][0];
                if(cur==len-1) set(y,1);else continue;
            }
            else
            {
                find(L[p]),find(f[x][0]);
                cur+=(s[b[p]][0]-s[L[p]][0]);
                cur+=s[a[p]][1]+(s[f[x][0]][1]-s[L[p]][1]);
                if(cur==len-1) set(x,0);else continue;
            }
        }
        while(o<n&&z[F[o]?y[o]:x[o]]!=-1) ++o;
        F[o]?set(y[o],0):set(x[o],1);
    }
    for(int i=1;i<n;++i)
        cout<<(F[i]?(z[y[i]]==1):(z[x[i]]==0));
    cout<<'\n';return 0;
}
```

---

## 作者：是青白呀 (赞：4)

在特殊性质 A 的提示下，我们可以发现：当所有限制 $(a,b)$ 都满足 $(a,b)$ 间未定向的边数 $>1$ 时，任意确定一条边的方向后仍然一定有解。考虑二分图染色即可证明。

因此，对当前操作作出限制的，只有现在仍然可达、且仅有 $1$ 条边未被定向的限制。这样的限制会确定某条边的定向。

考虑维护每个限制对应路径上的未定向边数。当某个限制的未定向边数为 $1$ 时，check 它有无反向边。有，则该限制无效；没有，则剩的那条边的方向被唯一确定。于是，每当有一条边被确定时，都去更新每个限制的情况。不存在未定向边数为 $1$ 的限制时，则可让首条边取 $0$。于是做到了 $O(nm\log n)$。

现在要做的是，快速找到未定向边数为 $1$ 的限制。考虑一个类似报警器的东西：把一个限制拆到若干条链上去，用结构维护链的未定向边数，当边数到达 $0,1$ 时分别报警一次。则每个限制会被 check 到 $O(\text{拆成的链数})$ 次。

第一个想法是树链剖分，将每个限制拆成 $\log$ 个重链和轻边，每个重链再拆成 $\log$ 个线段树上的区间。则单个限制报警次数为 $O(\log^2n)$。

第二个想法是倍增。一个倍增组 $(u,k)$ 只会从 $(u,k-1)$ 和 $(fa_{u,k-1},k-1)$ 两个位置转移过来，所以我们用一个类似拓扑排序的东西维护报警过程：每个倍增组 $(u,k)$ 在仅剩 $0$ 或 $1$ 条未定向边的时候，才向后报警一次。注意到若在各个倍增组及 $m$ 条限制之间按转移顺序连边，则总边数不超过 $O((n+m)\log n)$。同时，在倍增数组上维护没有定向的边的编号、以及到根和到叶子的边是否分别存在，边转移边合并。check 限制的时候利用这些信息即可 $O(\log n)$ 地判定是否需要定向、及需要定向的边是谁。

总时间复杂度 $O((n+m)\log n)$。常数巨大，下面的代码中使用了手写队列和链式前向星优化常数。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
using namespace std;
typedef long long ll;
const int N=5e5+5,M=6,S=(1<<15)+5,inf=1e9+7,mo=998244353;
const double eps=1e-8;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int cid,n,m;
struct edge{
    int x,y;
}eg[N];
vector<int>e[N];
pii lim[N];
struct node{
    int lst=0;
    bool tor=0,tol=0;//to leaf;to root
    friend node operator+(node x,node y){
        node res;
        res.lst=max(x.lst,y.lst);
        res.tor=x.tor|y.tor;
        res.tol=x.tol|y.tol;
        return res;
    }
}st[N][22];
int cnt[N][22],rd[N][22],fa[N][22],deg[N][22],dep[N];
struct nedge{
    pii to;
    int nxt;
}nxtp[N*100];
int fir[N][22],np;
void add(pii x,pii y){
    int u=x.fir,k=x.sec;
    nxtp[++np]=(nedge){y,fir[u][k]};
    fir[u][k]=np;
}
int ans[N],lcap[N];
void dfs(int x,int f){
    dep[x]=dep[f]+1,fa[x][0]=f;
    rep(i,1,18){
        fa[x][i]=fa[fa[x][i-1]][i-1];
        if(!fa[x][i])break;
        rd[x][i]=2;
        add(mp(x,i-1),mp(x,i));
        add(mp(fa[x][i-1],i-1),mp(x,i));
    }
    for(auto j:e[x]){
        if(j==f)continue;
        dfs(j,x);
    }
}
int lca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    repp(i,18,0)
        if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
    if(x==y)return x;
    repp(i,18,0)
        if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
struct sitn{
    int fir,sec,op;
};
sitn q[N*100];
int tl=0,hd=1;
void fix_edge(int x,int op){
    if(ans[x])return;//bfs 还没来得及更新这个 x 的定向信息之前，可能有多个位置被这条边限制，我们要避免多次赋值的情况.
    st[x][0]=(node){0,(op==1),(op==2)};
    q[++tl]=(sitn){x,0,0};
    ans[x]=op;
}
void check(int id){
    int x=lim[id].fir,y=lim[id].sec;
    node resx={0,0,0},resy={0,0,0};
    repp(i,18,0)
        if(dep[fa[x][i]]>=dep[lcap[id]])resx=resx+st[x][i],x=fa[x][i];
    repp(i,18,0)
        if(dep[fa[y][i]]>=dep[lcap[id]])resy=resy+st[y][i],y=fa[y][i];
    if(resx.tol||resy.tor)return;
    if(resx.lst)fix_edge(resx.lst,2);
    if(resy.lst)fix_edge(resy.lst,1);
}
void solve(){
    while(hd<=tl){
        int u=q[hd].fir,k=q[hd].sec,op=q[hd].op;
        hd++;
        if(k==20&&op)check(u);
        for(int i=fir[u][k];i;i=nxtp[i].nxt){
            pii j=nxtp[i].to;
            if(op==1)cnt[j.fir][j.sec]++,deg[j.fir][j.sec]++;
            else deg[j.fir][j.sec]--;
            if(cnt[j.fir][j.sec]==rd[j.fir][j.sec]&&deg[j.fir][j.sec]<=1){
                q[++tl]=(sitn){j.fir,j.sec,deg[j.fir][j.sec]};
                if(j.sec<20)st[j.fir][j.sec]=st[j.fir][j.sec-1]+st[fa[j.fir][j.sec-1]][j.sec-1];
            }
        }
    }
}
signed main(){
    read(cid),read(n),read(m);
    rep(i,1,n-1){
        read(eg[i].x),read(eg[i].y);
        e[eg[i].x].push_back(eg[i].y),e[eg[i].y].push_back(eg[i].x);
    }
    dfs(1,0);
    rep(i,1,m){
        read(lim[i].fir),read(lim[i].sec);
        lcap[i]=lca(lim[i].fir,lim[i].sec);
        int x=lim[i].fir;
        repp(j,18,0)
            if(dep[fa[x][j]]>=dep[lcap[i]])add(mp(x,j),mp(i,20)),rd[i][20]++,x=fa[x][j];
        x=lim[i].sec;
        repp(j,18,0)
            if(dep[fa[x][j]]>=dep[lcap[i]])add(mp(x,j),mp(i,20)),rd[i][20]++,x=fa[x][j];
    }
    rep(i,2,n){
        st[i][0]=(node){i,0,0};
        q[++tl]=(sitn){i,0,1};
    }
    solve();
    rep(i,1,n-1){
        int nid=(fa[eg[i].x][0]==eg[i].y?eg[i].x:eg[i].y);
        if(ans[nid])continue;
        fix_edge(nid,fa[eg[i].x][0]==eg[i].y?1:2);
        solve();
    }
    rep(i,1,n-1){
        int nwv=((fa[eg[i].x][0]==eg[i].y)?(ans[eg[i].x]-1):((ans[eg[i].y]-1)^1));
        printf("%d",nwv);
    }
    return 0;
}
```

---

## 作者：KinNa_Sky (赞：3)

从看到题到完全理清思路准备开写只用了半小时，希望今年考场上也能如此发挥。

---

对于字典序问题容易想到贪心，因为高位权重大于所有低位权重之和。

最初的思路是直接检查每条边是否必须选 `1`，也就是是否存在一条路径其他所有边已定向成路径方向。  
然后考虑到肯定不会这么简单找找反例。

![](https://cdn.luogu.com.cn/upload/image_hosting/nig5zmkr.png)

我们发现 `edg3` 在决策时被两头卡。  
补救一下，我们考虑当做完 `edg1` 的决策时，由于 `qry1`，已经可以确定 `edg3` 的方向，进而会确定 `edg2` 的方向。

我们大胆猜测当一个询问只剩一条边未定向且其他边均为该询问方向时，直接修改那条边，最后一定可以构造合法解。  
由于这一步是在贪心的基础上不得不做的操作所以不会影响最优性。

那么正确性对不对呢，我们只需说明，每条边定向后，不会造成别的边被两头卡。

> 当一条边定向后，他如何会导致边定向？  
> 当它是询问的倒数第二条边且询问的边（包括我们正在定向的这条）都是询问方向。  
> 那么，由他直接导致的边的定向都与他相反，不会造成矛盾。  
>
> 由他（边 1）与他直接导致的边（边 2）是否会导致第 3 条边被卡呢？  
> - 首先，由于边 1 导致边 2 定向，两条边路径上边一定已经定向。  
> - 其次，同时跨两条边的询问已经被两条边所满足。
> - 那么剩下能被两条边影响到的只有两边之间的路径上，延伸出去的侧枝，  
>   而从侧枝的方向来看，边 1 和边 2 是同向的，其造成的限制也相同。

也就是说，我们的猜测是正确的。

---

现在我们只需要维护当每个询问只剩一条边时，拿出来瞅一眼是否已经满足，然后定向。  
如何维护只剩一条边？[P4215 踩气球](https://www.luogu.com.cn/problem/P4215)。

> 维护一个线段树，存区间未被定向的边数，把询问挂到线段树上，显然每次只有单点修改，当修改完后线段树的节点区间只剩 $0$ 或 $1$ 时，扫节点上挂的询问更新其剩余边数。

然后找到剩的是哪条边可以线段树上二分。

时间复杂度：  
使用了树剖加线段树，正常操作的复杂度是 $O(n\log^2 n)$。  
对于踩气球的那个复杂度，每个询问被挂在了线段树上 $O(\log^2n)$ 个节点上，由于线段树权值单调不升，所以每个节点会遍历询问 $O(1)$ 次，这部分复杂度也是 $O(n\log^2n)$。

[Code](https://www.luogu.com.cn/paste/6ub27ulm) or [云剪切板站](https://www.luogu.me/paste/6ub27ulm)。

---

## 作者：Otomachi_Una_ (赞：3)

首先考虑如何判定合法。我在考场上就想到了这么个做法：

- 每次把限制 $=1$（即只对一条不确定边限制）的限制拿出来，把其对应边定向。

如果不存在只有一条限制的边，就完成了。构造是把所有已经确定的边缩起来，然后边黑白染色即可。

然后，就可以每次钦定一条未确定的边，能做到 $\mathcal O(nm)$。

考虑优化找一条未确定边的过程。聪明的小朋友们肯定学过减半报警器。但是这道题我们只需要 $=1$ 报警器。

很简单，把每条限制通过倍增分到 $\mathcal O(\log)$  条长度为 $2$ 的方幂链上。当一条链的未确定边数降至 $0$ 或 $1$ 的时候就报警，提醒所有覆盖它的限制。然后判断这个限制是否只限制了一条边。然后再去更新就对了。

**【参考代码】**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=5e5+5;
int c,n,m,eu[MAXN],ev[MAXN],ea[MAXN],eb[MAXN],cnt[MAXN],dep[MAXN];
int id[MAXN],ans[MAXN];
int fa[20][MAXN],up[20][MAXN],dw[20][MAXN];queue<int> q;
vector<int> edg[MAXN];
int to[60*MAXN],nxt[60*MAXN],tot;
int vec[20][MAXN],vup[20][MAXN],vdw[20][MAXN];
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=19;i>=0;i--) if((dep[x]-dep[y])>>i&1) x=fa[i][x];
	if(x==y) return x;
	for(int i=19;i>=0;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
	return fa[0][x];
}
void link(int &x,int u){
	++tot;to[tot]=u;nxt[tot]=x;x=tot;
}
void dfs(int u,int f){
	fa[0][u]=f;up[0][u]=dw[0][u]=1;
	for(int i=1;i<20;i++){
		fa[i][u]=fa[i-1][fa[i-1][u]];
		if(fa[i][u]){
			link(vec[i-1][fa[i-1][u]],u);
			link(vec[i-1][u],u);
			up[i][u]=dw[i][u]=(1<<i);
		}
	}
	for(int v:edg[u]) if(v!=f){
		dep[v]=dep[u]+1;
		dfs(v,u);
	}
}
void set_up(int x){
	ans[x]=(dep[eu[x]]<dep[ev[x]]);
	x=(dep[eu[x]]>dep[ev[x]]?eu[x]:ev[x]);
	if(up[0][x]==0) return;
	queue<pair<int,int> > q1;q1.push(MP(0,x));up[0][x]=0;
	while(!q1.empty()){
		int k=q1.front().first,x=q1.front().second;q1.pop();
		for(int t=vup[k][x],id=to[t];t;t=nxt[t],id=to[t]){
			if(--cnt[id]==1) q.push(id);
		}
		for(int t=vec[k][x],v=to[t];t;t=nxt[t],v=to[t]) 
			if((up[k+1][v]=up[k][v]+up[k][fa[k][v]])<=1)
				q1.push(MP(k+1,v));
	}
}
void set_down(int x){
	ans[x]=(dep[eu[x]]>dep[ev[x]]);
	x=(dep[eu[x]]>dep[ev[x]]?eu[x]:ev[x]);
	if(dw[0][x]==0) return;
	queue<pair<int,int> > q1;q1.push(MP(0,x));dw[0][x]=0;
	while(!q1.empty()){
		int k=q1.front().first,x=q1.front().second;q1.pop();
		for(int t=vdw[k][x],id=to[t];t;t=nxt[t],id=to[t]){
			if(--cnt[id]==1) q.push(id);
		}
		for(int t=vec[k][x],v=to[t];t;t=nxt[t],v=to[t]) 
			if((dw[k+1][v]=dw[k][v]+dw[k][fa[k][v]])<=1)
				q1.push(MP(k+1,v));
	}
}
void solve(int x){
	int u=ea[x],v=eb[x],p=lca(u,v);
	for(int j=19;j>=0;j--){
		if((dep[u]-dep[p])>>j&1){
			if(up[j][u]){
				for(int k=j-1;k>=0;k--) u=(up[k][u]?u:fa[k][u]);
				set_down(id[u]);
				return;
			}
			u=fa[j][u];
		}
		if((dep[v]-dep[p])>>j&1){
			if(dw[j][v]){
				for(int k=j-1;k>=0;k--) v=(dw[k][v]?v:fa[k][v]);
				set_up(id[v]);
				return;
			}
			v=fa[j][v];
		}
	}
	return;
}
int main(){
	ios::sync_with_stdio(false);
	// freopen("Otomachi_Una.in","r",stdin);
	// freopen("Otomachi_Una.out","w",stdout);
	cin>>c>>n>>m;
	for(int i=1;i<n;i++){
		cin>>eu[i]>>ev[i];
		edg[eu[i]].push_back(ev[i]);
		edg[ev[i]].push_back(eu[i]);
	}
	memset(ans,-1,sizeof(ans));
	dfs(1,0);
	for(int i=1;i<n;i++) id[dep[eu[i]]<dep[ev[i]]?ev[i]:eu[i]]=i;
	for(int i=1;i<=m;i++){
		cin>>ea[i]>>eb[i];
		int u=ea[i],v=eb[i],p=lca(u,v);
		for(int j=19;j>=0;j--){
			if((dep[u]-dep[p])>>j&1){
				link(vup[j][u],i);
				cnt[i]+=1+(j>0);
				u=fa[j][u];
			}
			if((dep[v]-dep[p])>>j&1){
				link(vdw[j][v],i);
				cnt[i]+=1+(j>0);
				v=fa[j][v];
			}
		}
		if(cnt[i]==1) q.push(i);
	}
	while(!q.empty()){
		solve(q.front());q.pop();
	}
	for(int i=1;i<n;i++) if(ans[i]==-1){
		if(dep[eu[i]]>dep[ev[i]]) set_up(i);
		else set_down(i);
		while(!q.empty()){
			solve(q.front());q.pop();
		}
	}
	for(int i=1;i<n;i++) cout<<ans[i];cout<<'\n';
	return 0;
}
```

---

## 作者：xfrvq (赞：3)

首先考虑 $O(n^2)$ 暴力：从小往大枚举每一条边，然后判定该边定 $0$ 是否有解，无解则定 $1$。

考虑判定：我们看是否有路径**通过已定向的边**可达。但这是错的，**通过路径和已定向的边可以解出更多边的方向**，可能产生矛盾影响判定。

我们发现一条边的方向能被确定，需要**有一条经过它的路径，其它边的方向都与路径相同，此时它必须取与路径相反的方向。**

关键结论：**若没有路径能直接定出一条边，那么该局面有解。**

证明：在树上缩去已定向的边，所有路径会变成两种情况之一

+ 该路径通过定向的边已经不可达，此时该路径没有限制
+ 剩下的路径长度一定 $\ge2$（因为长度为 $1$ 就能定出边了），我们对此时的树黑白染色，让所有边指向黑点。长度 $\ge2$ 的路径就一定不会连通。

同时可以得出另一个结论：**在此局面下，给其中一条边任意定向后仍有解**。

证明：考虑把该边指向的点设为黑色，然后黑白染色即可。

考虑优化“枚举边并尝试定向”的过程。

+ 我们先解出初始时已被钦定的边。（一条长度为 $1$ 的路径可以确定一条边，而确定这条边后又会出现新的能解出边的路径……）
+ 然后枚举每一条边，如果它没有被前面的边钦定，那么它可以任选（第二个结论：此时任选仍有解），将它定为 $0$ 后去解更多的边。

解边的过程形如拓扑排序（当一条路径长度为 $1$ 后就可以拿去解边，解出方向后缩边又更新其它路径），不过这里的条件是度数为 $1$。

---

考虑实现。

首先考虑拓扑排序，需要一个**每条边指向连向它的所有路径**的图。这里倍增优化建图，点 $P(i,k)$ 代表点 $i$ 往上 $2^k$ 条边。建图优化后点数为 $O(n\log n+m)$，边数为 $O((n+m)\log n)$，**注意此时度数的算法以及入队的不同判定方式**。

然后树需要支持“缩边”，“查询一条链是否被定为了同个方向”，“查询一条链上仅有的未被缩的一条边的编号”。考虑**带权树上并查集**，即一种不破坏儿子父亲关系的并查集。

+ 缩边即让 $u$ 在并查集上父亲指向树上 $fa_u$，这可以保证无论并查集如何路径压缩， $u$ 在并查集上的根一定是 $u$ 在树上的祖先。
+ 链查询方向考虑维护权值 $c_i=\pm1$ 代表方向是 $i\to fa_i$ 还是 $fa_i\to i$，然后变为查询链和。考虑对于链 $u\to v,w=\mathrm{lca}(u,v)$，$u,v,w$ 一定在相同并查集内（因为 $u,v,w$ 之间的边都已定向），即并查集上有一个相同的根 $f$。我们维护 $d_i$ 表示 $i$ 到 $i$ 的根的路径上 $c_i$ 的和，路径压缩时动态维护。那么 $u\sim v$ 的路径拆为 $u\sim f,v\sim f,w\sim f$ 三段求即可。
+ 链查询编号考虑路径 $u\to v,w=\mathrm{lca}(u,v)$，它们一定不在同并查集内（因为链上有一条边未被缩）。如果该边在 $u\to w$ 上，那么该边为并查集上 $u$ 的祖先，否则为并查集上 $v$ 的祖先。

---

时空复杂度 $O(n\log n)$，常数较大。

放一份未卡常的代码，加快读并将存图改为链式前向星后可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e5 + 5,K = N * 21;

int C,n,m,k,U[N],V[N],a[N],b[N],c[N],ans[N];
int ft[N],cnt[N],id[N],dep[N],fa[21][N],deg[K],cur[K];
vector<int> T[N],G[K];
queue<int> Q;

#define pnt(k,x) ((k) * n + (x))

void dfs(int u,int f){
	dep[u] = dep[fa[0][u] = f] + 1;
	deg[pnt(0,u)] = cur[pnt(0,u)] = 1;
	for(int i = 1;i < 20;++i){
		fa[i][u] = fa[i - 1][fa[i - 1][u]];
		deg[pnt(i,u)] = cur[pnt(i,u)] = (1 << i);
		G[pnt(i - 1,u)].push_back(pnt(i,u));
		G[pnt(i - 1,fa[i - 1][u])].push_back(pnt(i,u));
	}
	for(int v : T[u]) if(v != f) dfs(v,u);
}

int add(int u,int v,int j){ // 建图优化，加边
	if(dep[u] < dep[v]) swap(u,v);
	for(int i = 19;~i;--i) if(dep[fa[i][u]] >= dep[v])
		G[pnt(i,u)].push_back(j),u = fa[i][u];
	if(u == v) return u;
	for(int i = 19;~i;--i) if(fa[i][u] != fa[i][v]){
		G[pnt(i,u)].push_back(j),u = fa[i][u];
		G[pnt(i,v)].push_back(j),v = fa[i][v];
	}
	return G[u].push_back(j),G[v].push_back(j),fa[0][u];
}

int fnd(int x){ // 并查集找祖先，路径压缩同时维护到祖先的权值和
	if(x == ft[x]) return x;
	return fnd(ft[x]),cnt[x] += cnt[ft[x]],ft[x] = ft[ft[x]];
}

int chk(int a,int b,int c,int p = 0){ // 对于 a->b,lca=c 的路径，找到是否有一条可被定向的边
	fnd(a),fnd(b),fnd(c);
	if(ft[b] == ft[c] && ft[a] != ft[c]){
		if(cnt[a] < dep[a] - dep[p = ft[a]]) return -1;
		if(fnd(fa[0][p]) != ft[c]) return -1;          
		if(cnt[fa[0][p]] - cnt[c] < dep[fa[0][p]] - dep[c]) return -1;
		if(cnt[b] - cnt[c] > dep[c] - dep[b]) return -1;
		return ans[p] = cnt[p] = -1,ft[p] = fa[0][p],p;
	}
	if(ft[a] == ft[c] && ft[b] != ft[c]){
		if(cnt[b] > dep[p = ft[b]] - dep[b]) return -1;
		if(fnd(fa[0][p]) != ft[c]) return -1;
		if(cnt[fa[0][p]] - cnt[c] > dep[c] - dep[fa[0][p]]) return -1;
		if(cnt[a] - cnt[c] < dep[a] - dep[c]) return -1;
		return ans[p] = cnt[p] = 1,ft[p] = fa[0][p],p;
	}
	return -1;
}

void upd(int u){ // 沿着点 u 更新，注意 deg 的计算方式
	if(u > k && cur[u] == 1) Q.push(u - k);
	for(int v : G[u]) if((cur[v] -= deg[u] - cur[u]) <= 1) upd(v);
	deg[u] = cur[u];
}

int main(){
	scanf("%d%d%d",&C,&n,&m),k = n * 20;
	for(int i = 1;i < n;++i){
		scanf("%d%d",U + i,V + i);
		T[U[i]].push_back(V[i]),T[V[i]].push_back(U[i]);
	}
	dfs(1,0);
	for(int i = 1;i <= n;++i) ft[i] = i;
	for(int i = 1;i <= m;++i){
		scanf("%d%d",a + i,b + i),c[i] = add(a[i],b[i],k + i);
		deg[i + k] = cur[i + k] = dep[a[i]] + dep[b[i]] - (2 * dep[c[i]]);
		if(deg[i + k] == 1) Q.push(i);
	}
	for(int i = 1,p;i < n;++i){
		while(Q.size()){ // 拓扑排序
			int j = Q.front(); Q.pop();
			if(~(p = chk(a[j],b[j],c[j]))) --cur[p],upd(p);
		}
		if(fa[0][U[i]] == V[i]){
			if(ans[p = U[i]]) continue;
			ans[p] = cnt[p] = 1,ft[U[i]] = V[i];
		} else {
			if(ans[p = V[i]]) continue;
			ans[p] = cnt[p] = -1,ft[V[i]] = U[i];
		}
		--cur[p],upd(p);
	}
	for(int i = 1;i < n;++i)
		printf("%d",(fa[0][U[i]] == V[i]) ? ans[U[i]] < 0 : ans[V[i]] > 0); // ans[i] 存的是边 (i,fa[i]) 的答案
	return 0;
}
```

---

## 作者：raincity (赞：2)

## 题意

给定一棵树，你要给每条边定向，使得 $\forall i \in [1, m]$，$a_i$ 不可达 $b_i$。求字典序最小的定向方式。保证有解。

## 分析

题目要求最小化字典序，可以考虑按位确定，那么我们应该先研究“已经定向了若干条边时，判定是否有解”的结构。

### 判定问题的结构

显然，已经定向了的边已经满足了一些限制。现在只需考虑那些未满足的限制。

那么，对于每条已经定向的边，我们可以把这条边的两个端点缩在一起。现在问题转化为所有边都未定向的情况。

先讨论掉一些比较简单的情况。如果 $\exists i$，$a_i = b_i$，则一定无解。如果 $\exists i$，$a_i$ 与 $b_i$ 相邻，则 $(a_i, b_i)$ 这条边必须按 $b_i \to a_i$ 的方向定向。

否则可以在图中放置若干个这种“元件”：

![](https://cdn.luogu.com.cn/upload/image_hosting/skb3649s.png)

这样只要 $a_i \to b_i$ 经过中间的点就一定满足限制了，因此一定有解。至此我们容易得到一个 $O(n^3)$ 的算法。

### 优化算法

考虑先用一些手段优化到 $O(n^2)$，再上数据结构优化到 $O(n \operatorname{polylog}(n))$。

考虑均摊。若判定成功，则复杂度可以被势能控制。若判定失败怎么办呢？

……

实际上可以发现判定不会失败，因为如果把所有元件的边都反向，构造仍然合法。所以如果当前没有可以确定方向的边，则下一条边无论朝哪个方向都有解。

$O(n^2)$ 的算法可以写成：每次找到一个限制 $i$，满足该限制尚未满足，且 $a_i \rightsquigarrow b_i$ 的路径上只有一条边未定向，把这条边定向。

接下来的优化方法比较多，但大多带了几个 $\log$。下面介绍一种基于倍增的单 $\log$ 做法。

倍增的关键区间长度和是 $O(n^2)$ 的，但关键区间数是 $O(n \log n)$ 的。考虑均摊到关键区间数上。

首先把限制的树链拆成两条直链，定位到 $O(\log n)$ 个关键区间上。对于每个关键区间，我们认为它有三种状态：所有边均已定向、恰好有一条边未定向、至少有两条边未定向。每切换一次状态报警一次。则总报警次数是 $O(n \log n)$ 的。

问题只剩下如何高效地处理报警。因为倍增有一个二进制的合并结构，每当一个节点报警时，把所有信息合并依赖于它的节点的信息全部更新即可。

时间复杂度 $O((n + m) \log n)$。

---

## 作者：Purslane (赞：1)

# Solution

先把最容易定向的边处理了。发现如果 $a_i \to b_i$ 的路径上只有 $1$ 条边没有被定向，且其他边都是按照 $a \to b$ 的顺序了，那么剩下的边是可以确定的。

处理完一波之后，只剩下了距离 $\ge 2$ 的点。而你对着缩点后的结果做黑白染色，那么一定有解，且每条边一定可以 $01$ 都行。

所以你就又确定了一条边，继续做就行。

这样是 $O(nm)$ 的。我们只需要加速找到“恰有一条边”的路径。

为啥大家不会想到 KDT 呢。就是你把路径按照 $(\min\{dfn_u,dfn_v\},\max\{dfn_u,dfn_v\})$ 扔到平面上，你发现每次只有把两个矩形中的路径剩余长度减一。

那么使用 KDT 维护容易做到 $O(n \sqrt n)$，轻松通过 $84$ 分。

鉴于现在没有这样的代码，我在末尾放一个。

考虑实现报警器类似物（树上倍增）。对于长度为 $2^0$ 的报警器，它只监视一条边（相当于最开始已经报警一起）。其他所有报警器都只看着另外两个报警器。如果一个报警器的子报警器一共报警了 $3$ 次，那么它会报警一次；子报警器一共报警了 $4$ 次，他还会再报警一次。

直接暴力实现报警复杂度显然是 $O(n \log n)$。感觉常数大的离谱，跑得和根号差不多。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10;
int cid,n,m,tot,dsu[MAXN],u[MAXN],v[MAXN],pu[MAXN],pv[MAXN],ans[MAXN],fa[MAXN][20],dep[MAXN],tr[2][MAXN];
void update(int pos,const int op,const int v) {while(pos<=n) tr[op][pos]+=v,pos+=pos&-pos;return ;}
int query(int pos,const int op) {int ans=0;while(pos) ans+=tr[op][pos],pos-=pos&-pos;return ans;}
vector<int> G[MAXN];
set<int> st;
int dfn[MAXN],sze[MAXN],fid[MAXN];
inline void dfs(const int u,const int f) {
	fa[u][0]=f,dep[u]=dep[f]+1,sze[u]=1,dfn[u]=++tot;
	ffor(i,1,19) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(auto v:G[u]) if(v!=f) dfs(v,u),sze[u]+=sze[v];
	return ;
}
inline int find(const int k) {return (dsu[k]==k)?k:(dsu[k]=find(dsu[k]));}
struct KDT {
	int a,b,l,ls,rs,del,len;
	int x,y,xmn,xmx,ymn,ymx;
}t[MAXN];
int del[MAXN],mn[MAXN];
inline void push_up(const int u,const int op=0){
	if(mn[t[u].ls]>n) t[u].ls=0;
	if(mn[t[u].rs]>n) t[u].rs=0;
	mn[u]=min(t[u].len,min(mn[t[u].ls],mn[t[u].rs]))-t[u].del;
	if(op) {
		t[u].xmn=t[u].xmx=t[u].x,t[u].ymn=t[u].ymx=t[u].y;
		if(t[u].ls) {
			int l=t[u].ls;
			t[u].xmn=min(t[u].xmn,t[l].xmn),t[u].xmx=max(t[u].xmx,t[l].xmx);
			t[u].ymn=min(t[u].ymn,t[l].ymn),t[u].ymx=max(t[u].ymx,t[l].ymx);
		}
		if(t[u].rs) {
			int r=t[u].rs;
			t[u].xmn=min(t[u].xmn,t[r].xmn),t[u].xmx=max(t[u].xmx,t[r].xmx);
			t[u].ymn=min(t[u].ymn,t[r].ymn),t[u].ymx=max(t[u].ymx,t[r].ymx);
		}
	}
	return ;
}
inline void modify(const int u,const int x,const int y,const int X,const int Y) {
	if(!u||x>t[u].xmx||y>t[u].ymx||X<t[u].xmn||Y<t[u].ymn) return ;
	if(x<=t[u].xmn&&t[u].xmx<=X&&y<=t[u].ymn&&t[u].ymx<=Y) return t[u].del++,mn[u]--,void();
	if(x<=t[u].x&&t[u].x<=X&&y<=t[u].y&&t[u].y<=Y) t[u].len--;
	modify(t[u].ls,x,y,X,Y),modify(t[u].rs,x,y,X,Y);
	return push_up(u),void(); 
}
set<int> ke;
inline int lca(int u,int v) {
	if(dep[u]<dep[v]) swap(u,v);
	roff(i,19,0) if((dep[u]-dep[v])&(1<<i)) u=fa[u][i];
	if(u==v) return u;
	roff(i,19,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
inline void check(const int U,const int V,const int l) {
	int al=dep[U]+dep[V]-2*dep[l],cnt=query(dfn[U],0)+query(dfn[V],1)-query(dfn[l],0)-query(dfn[l],1);
	if(cnt+1==al) {
		int s=find(U),t=find(V);
		if(dep[s]<dep[t]) ans[fid[t]]=(t==v[fid[t]]),ke.insert(fid[t]);
		else ans[fid[s]]=(s!=v[fid[s]]),ke.insert(fid[s]);
	}
	return ;
}
inline void solve(const int u,int odel) {
	if(!u||mn[u]-odel>1) return ;
	odel+=t[u].del;
	if(t[u].len-odel==1) check(t[u].a,t[u].b,t[u].l),t[u].len=INT_MAX;
	else if(t[u].len-odel==0) t[u].len=INT_MAX;
	solve(t[u].ls,odel),solve(t[u].rs,odel),push_up(u);
	return ;
}
inline int build(vector<int> vc,const int op) {
	if(vc.empty()) return 0;
	if(op==0) sort(vc.begin(),vc.end(),[&](int u,int v){return t[u].x<t[v].x;});
	else sort(vc.begin(),vc.end(),[&](int u,int v){return t[u].y<t[v].y;});
	int s=vc.size();
	int rt=(s+1)/2,u=vc[rt-1];
	vector<int> L,R;
	ffor(i,1,rt-1) L.emplace_back(vc[i-1]);
	ffor(i,rt+1,vc.size()) R.emplace_back(vc[i-1]);
	t[u].ls=build(L,op^1),t[u].rs=build(R,op^1);
	return push_up(u,1),u;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	mn[0]=INT_MAX;
	cin>>cid>>n>>m;
	ffor(i,1,n) dsu[i]=i;
	ffor(i,1,n-1) cin>>u[i]>>v[i],G[u[i]].emplace_back(v[i]),G[v[i]].emplace_back(u[i]),ans[i]=-1,st.insert(i);
	dfs(1,0);
	ffor(i,1,n-1) if(fa[u[i]][0]==v[i]) fid[u[i]]=i;
	else fid[v[i]]=i;
	ffor(i,1,m) {
		int u=i;
		cin>>t[u].a>>t[u].b,t[u].l=lca(t[u].a,t[u].b),t[u].x=min(dfn[t[u].a],dfn[t[u].b]),t[u].y=max(dfn[t[u].a],dfn[t[u].b]);
		t[u].len=dep[t[u].a]+dep[t[u].b]-2*dep[t[u].l];
	}
	vector<int> vc;
	ffor(i,1,m) vc.push_back(i);
	int rt=build(vc,0),cnt=n-1;
	while(cnt) {
		while(mn[rt]<=1) {
			solve(rt,0);
			for(auto id:ke) {
				--cnt;
				int uid=u[id],vid=v[id];
				if(fa[uid][0]==vid) swap(uid,vid);
				dsu[find(vid)]=find(uid);
				if(dfn[vid]!=1) modify(rt,1,dfn[vid],dfn[vid]-1,dfn[vid]+sze[vid]-1);
				if(dfn[vid]+sze[vid]-1!=n) modify(rt,dfn[vid],dfn[vid]+sze[vid],dfn[vid]+sze[vid]-1,n);
				
				int frm=u[id],to=v[id];
				if(ans[id]==1) swap(frm,to);
				if(fa[frm][0]==to) update(dfn[frm],0,1),update(dfn[frm]+sze[frm],0,-1);
				else update(dfn[to],1,1),update(dfn[to]+sze[to],1,-1);
			}
			ke.clear();
		}
		if(!cnt) break ;
		while(!st.empty()&&ans[*st.begin()]!=-1) st.erase(st.begin());
		int id=*st.begin();
		ans[id]=0,--cnt;
		int uid=u[id],vid=v[id];
		if(fa[uid][0]==vid) swap(uid,vid);
		dsu[find(vid)]=find(uid);
		if(dfn[vid]!=1) modify(rt,1,dfn[vid],dfn[vid]-1,dfn[vid]+sze[vid]-1);
		if(dfn[vid]+sze[vid]-1!=n) modify(rt,dfn[vid],dfn[vid]+sze[vid],dfn[vid]+sze[vid]-1,n);
		int frm=u[id],to=v[id];
		if(ans[id]==1) swap(frm,to);
		
		if(fa[frm][0]==to) update(dfn[frm],0,1),update(dfn[frm]+sze[frm],0,-1);
		else update(dfn[to],1,1),update(dfn[to]+sze[to],1,-1);
	}
	ffor(i,1,n-1) cout<<ans[i];
	return 0;
}
```

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10;
int cid,n,m,tot,dsu[MAXN],u[MAXN],v[MAXN],pu[MAXN],pv[MAXN],ans[MAXN],fa[MAXN][20],dep[MAXN],tr[2][MAXN];
void update(int pos,const int op,const int v) {while(pos<=n) tr[op][pos]+=v,pos+=pos&-pos;return ;}
int query(int pos,const int op) {int ans=0;while(pos) ans+=tr[op][pos],pos-=pos&-pos;return ans;}
vector<int> G[MAXN],nxt[MAXN][20];
int nd[MAXN],bj[MAXN][20];
set<int> st;
int dfn[MAXN],sze[MAXN],fid[MAXN];
inline void dfs(const int u,const int f) {
	fa[u][0]=f,dep[u]=dep[f]+1,sze[u]=1,dfn[u]=++tot;
	ffor(i,1,19) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(auto v:G[u]) if(v!=f) dfs(v,u),sze[u]+=sze[v];
	return ;
}
inline int find(const int k) {return (dsu[k]==k)?k:(dsu[k]=find(dsu[k]));}
int A[MAXN],B[MAXN]; 
set<int> ke;
inline int lca(int u,int v) {
	if(dep[u]<dep[v]) swap(u,v);
	roff(i,19,0) if((dep[u]-dep[v])&(1<<i)) u=fa[u][i];
	if(u==v) return u;
	roff(i,19,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
inline void check(const int U,const int V,const int l) {
	int al=dep[U]+dep[V]-2*dep[l],cnt=query(dfn[U],0)+query(dfn[V],1)-query(dfn[l],0)-query(dfn[l],1);
	int mz=query(dfn[U],0)+query(dfn[U],1)+query(dfn[V],0)+query(dfn[V],1)-2*query(dfn[l],0)-2*query(dfn[l],1);
	if(cnt+1==al&&mz==cnt) {
		int s=find(U),t=find(V);
		
		if(dep[s]<dep[t]) {if(ans[fid[t]]==-1) ans[fid[t]]=(t==v[fid[t]]),ke.insert(fid[t]);}
		else {if(ans[fid[s]]==-1) ans[fid[s]]=(s!=v[fid[s]]),ke.insert(fid[s]);}
	}
	return ;
}
int cnt;
void solve(int id) {
	int uid=u[id],vid=v[id];
	if(fa[uid][0]==vid) swap(uid,vid);
	dsu[find(vid)]=find(uid);
	
	int frm=u[id],to=v[id];
	if(ans[id]==1) swap(frm,to);
	if(fa[frm][0]==to) update(dfn[frm],0,1),update(dfn[frm]+sze[frm],0,-1);
	else update(dfn[to],1,1),update(dfn[to]+sze[to],1,-1);
	return ;
}
void alarm(int u,int j) {
	for(auto id:nxt[u][j]) {
		if(id<0) {
			int v=-id;
			--nd[v];
			if(nd[v]==1) check(A[v],B[v],lca(A[v],B[v])); 
		}
		else {
			int nu=id/20,nj=id%20;
			++bj[nu][nj];
			if(bj[nu][nj]>=3) alarm(nu,nj);
		}
	}
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>cid>>n>>m;
	ffor(i,1,n) dsu[i]=i;
	ffor(i,1,n-1) cin>>u[i]>>v[i],G[u[i]].emplace_back(v[i]),G[v[i]].emplace_back(u[i]),ans[i]=-1,st.insert(i);
	dfs(1,0);
	ffor(i,1,n-1) if(fa[u[i]][0]==v[i]) fid[u[i]]=i;
	else fid[v[i]]=i;
	ffor(i,1,m) cin>>A[i]>>B[i];
	ffor(i,1,n) ffor(j,1,19) if(fa[i][j]) {
		nxt[i][j-1].push_back(i*20+j);
		nxt[fa[i][j-1]][j-1].push_back(i*20+j);
	}
	ffor(i,1,m) {
		int u=A[i],v=B[i];
		if(dep[u]<dep[v]) swap(u,v);
		roff(j,19,0) if((dep[u]-dep[v])&(1<<j)) nxt[u][j].push_back(-i),nd[i]+=2,u=fa[u][j];
		if(u!=v) {
			roff(j,19,0) if(fa[u][j]!=fa[v][j]) {
				nxt[u][j].push_back(-i);
				nxt[v][j].push_back(-i);
				u=fa[u][j],v=fa[v][j],nd[i]+=4;
			}
			nxt[u][0].push_back(-i),nxt[v][0].push_back(-i),nd[i]+=4;
		}
	}
	cnt=n-1;
	ffor(i,2,n) {
		alarm(i,0);
		while(!ke.empty()) {
			auto mzx=ke;
			ke.clear();
			vector<int> pos;
			for(auto id:mzx) {
				--cnt;
				if(fa[v[id]][0]==u[id]) pos.push_back(v[id]);
				else pos.push_back(u[id]);
				solve(id);
			}
			for(auto id:pos) alarm(id,0);
		}
	}
	while(cnt) {
		while(!ke.empty()) {
			auto mzx=ke;
			ke.clear();
			vector<int> pos;
			for(auto id:mzx) {
				--cnt;
				if(fa[v[id]][0]==u[id]) pos.push_back(v[id]);
				else pos.push_back(u[id]);
				solve(id);
			}
			for(auto id:pos) alarm(id,0);
		}
		if(!cnt) break ;
		while(!st.empty()&&ans[*st.begin()]!=-1) st.erase(st.begin());
		int id=*st.begin();
		ans[id]=0,--cnt,solve(id);
		if(fa[v[id]][0]==u[id]) alarm(v[id],0);
		else alarm(u[id],0);
	}
	ffor(i,1,n-1) cout<<ans[i];
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：1)

字典序最小？考虑按位去贪心，但是你貌似并没有很好的方法去判定当前局面能否通过后面的操作生成一组合法解。

所以先去挖掘性质，不妨来做下特殊性质 A，你发现有两条同向边就直接完蛋了，所以相邻边方向不同，注意到二分图的一种构造方式是给边分类使得任意路径上边类型交替，所以这里倒过来思考，考虑给原树二分图染色，令所有边都指向黑点则必定得到一组合法解。而另一组解只能是翻转所有边后的结果。

现在考虑一般情况，假设现在没有确定方向的边，如何判断是否有解？还是考虑二分图染色，则你发现假若不存在距离为 $1$ 的点对，总是可以构造解，有距离为 $1$ 的点对则不好说。

再去考虑有确定方向的边怎么办，你发现不好处理那些已经确定方向的边的影响，并且你希望能扩展上面那个没有确定方向的边时的结论，于是你不妨令所有确定方向的边在对于每个点对考虑时处于最劣情况，也就是直接缩成一个点，在这种情况下，假若仍然没有距离为 $1$ 的点对则还是一定合法。

梳理下我们得到的一般结论，假若任意点对路径上存在至少两条没有被确定方向的边则一定有解。

但是注意到这个条件并不是必要的，所以我们去找一下是否有更强的结论，我们发现，假若任意点对路径上存在至少两条没有被确定方向的边，则再任意确定一条没有确定方向的边，也一定有解。

证明还是考虑缩点后确定一条边的方向时，给指向的点染成黑色然后对整棵树二分图染色，所有边指向黑点，依然是一组合法解。

虽然还是没找到必要条件，但是已经可以做了，考虑在按位贪心的过程中，先把所有路径上只剩一条边的点对找出来，假若点对需要这条边阻断 $u \to v$ 路径就直接给其定向，否则这个点对的限制就直接没用了，把点对丢掉，处理完所有点对后进入一个所有点对路径上均有两条未被确定方向的边的情况，这个时候对于你按位枚举到的边，假若还没被确定方向，则可以任意定向均有解，贪心定为 $0$ 即可。

现在只剩下怎么维护的问题了，我们要支持的非平凡操作为删边与找出路径上只剩一条边的点对，考虑利用全局平衡二叉树的结构将路径拆为 $O(\log n)$ 个区间，将点对挂在区间上，在区间内边数减到 $1$ 及以下时报警一次更新下对点对路径的贡献，显然一个区间只会报警两次，所以时间复杂度是 $O((n+m) \log n)$ 的。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5+114;
vector<int> E[maxn];
int n,m;
int x[maxn],y[maxn];
int A[maxn],B[maxn];
int fa[maxn];
int sz[maxn],son[maxn];
int root[maxn];
int tot;
int dfn[maxn],node[maxn],dfncnt;
int top[maxn],dep[maxn];
int ls[maxn<<2],rs[maxn<<2],mid[maxn<<2],sum[maxn<<2],val[maxn<<2],len[maxn<<2];//1 up -1 down
int emp[maxn<<2];
int col[maxn];//to fa
vector< pair<int,int> > vec[maxn];//1 -1
vector<int> tr[maxn<<2];
int L[maxn],R[maxn];
int e[maxn];
vector<int> wait;
void dfs1(int u){
    sz[u]=1;
    for(int v:E[u]){
        if(v!=fa[u]){
            fa[v]=u;
            dep[v]=dep[u]+1;
            dfs1(v);
            sz[u]+=sz[v];
            if(sz[v]>sz[son[u]]||son[u]==0) son[u]=v;
        }
    }
}
void pushup(int cur){
    sum[cur]=sum[ls[cur]]+sum[rs[cur]];
    val[cur]=val[ls[cur]]+val[rs[cur]];
    emp[cur]=emp[ls[cur]]^emp[rs[cur]];
}
void build(int &cur,int lt,int rt){
    if(cur==0) cur=++tot;
    len[cur]=rt-lt+1;
    if(lt==rt){
        val[cur]=0;
        sum[cur]=1;
        emp[cur]=lt;
        return ;
    }
    int sum=0;
    for(int i=lt;i<=rt;i++) sum+=sz[fa[node[i]]]-sz[node[i]];
    int s=0;
    for(int i=lt;i<rt;i++){
        mid[cur]=i;
        s+=sz[fa[node[i]]]-sz[node[i]];
        if(s*2>=sum) break;
    }
    build(ls[cur],lt,mid[cur]);
    build(rs[cur],mid[cur]+1,rt);
    pushup(cur);
}
void dfs2(int u,int tp){
    top[u]=tp;
    dfn[u]=++dfncnt;
    node[dfncnt]=u;
    if(son[u]!=0){
        dfs2(son[u],tp);
    }
    for(int v:E[u]){
        if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
    }
    if(son[u]==0) L[top[u]]=dfn[top[u]],R[top[u]]=dfn[u],build(root[top[u]],dfn[top[u]],dfn[u]);
}
void ins(int cur,int lt,int rt,int l,int r,int id,int ty){
    if(rt<l||r<lt) return ;
    if(l<=lt&&rt<=r){
        e[id]+=sum[cur];
        tr[cur].push_back(id);
        vec[id].push_back(make_pair(cur,ty));
        return ;
    }
    ins(ls[cur],lt,mid[cur],l,r,id,ty);
    ins(rs[cur],mid[cur]+1,rt,l,r,id,ty);
    return ;
}
void inslist(int u,int v,int id){
    int k=1;
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v),k*=-1;
        ins(root[top[u]],L[top[u]],R[top[u]],dfn[top[u]],dfn[u],id,k);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v),k*=-1;
    if(u==v) return ;
    ins(root[top[u]],L[top[u]],R[top[u]],dfn[v]+1,dfn[u],id,k);
}
void add(int cur,int lt,int rt,int pos,int v){
    if(lt==rt){
        sum[cur]--;
        val[cur]+=v;
        emp[cur]=(sum[cur]==0?0:lt);
        if(sum[cur]<=1){
            for(int x:tr[cur]){
                if(sum[cur]==1) e[x]-=(rt-lt);
                else e[x]--;
                if(e[x]==1) wait.push_back(x);
            }
        }
        return ;
    }    
    if(pos<=mid[cur]) add(ls[cur],lt,mid[cur],pos,v);
    else add(rs[cur],mid[cur]+1,rt,pos,v);
    pushup(cur);
    if(sum[cur]<=1){
        for(int x:tr[cur]){
            if(sum[cur]==1) e[x]-=(rt-lt);
            else e[x]--;
            if(e[x]==1) wait.push_back(x);
        }
    }
}
void work(){
    while(wait.size()>0){
        int a=wait.back();
        wait.pop_back();
        int s=0,dis=0,empty=0;
        for(pair<int,int> b:vec[a]){
            s+=b.second*val[b.first],dis+=len[b.first],empty+=b.second*emp[b.first];
        }
        empty*=-1;
        int u=node[abs(empty)];
        if(s==dis-1){
            col[u]=empty/abs(empty);
            add(root[top[u]],L[top[u]],R[top[u]],abs(empty),empty/abs(empty));
        }
    }
}
int main(){
    //freopen("tree.in","r",stdin);
    //freopen("tree.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int c;
    cin>>c>>n>>m;
    sz[0]=n+1;
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        A[i]=u,B[i]=v;
        E[u].push_back(v);
        E[v].push_back(u);
    }
    dfs1(1);
    dfs2(1,1);
    for(int i=1;i<=m;i++){
        cin>>x[i]>>y[i];
        inslist(x[i],y[i],i);
        if(fa[x[i]]==y[i]||fa[y[i]]==x[i]) wait.push_back(i);
    }
    for(int i=1;i<n;i++){
        work();
        int u=A[i],v=B[i];
        int k=1;
        if(dep[u]<dep[v]) swap(u,v),k*=-1;
        //u to v
        if(col[u]!=0){
            cout<<(col[u]*k==1?0:1);
        }else{
            cout<<0;
            add(root[top[u]],L[top[u]],R[top[u]],dfn[u],k);
        }
    }
    return 0;
}
```

---

## 作者：lzytag (赞：1)

发现没有人写我这个维护方式，我来写一下点分树上 dfs 的做法。

考虑如何贪心地做，发现如果有长度为一的关系可以直接定向，如果没有长度为一的关系那么黑白染色即可。

定向之后我们发现，有的对应关系之间只有一条边没有被定向，那么如果还可能到那么就直接定向，否则删除这条关系，如果不存在这样的关系则结束，黑白染色即可。

问题就变成了一次删一条边，每次找到所有只剩一条边的关系集合。动态维护多条路径的信息，自然而然地考虑点分树。对于一对关系 $(a,b)$，找到 $(a,b)$ 在点分树上的 lca，将该关系拆成 $(a,lca)$ 和 $(b,lca)$，当其中有一条的路径上未定向边数变成 $0/1$ 时找到另一边的未定向边数，若两者相加恰好为 $1$ 将该对关系入队，再不断弹出队首，找到队首的关系中唯一的未定向边然后将其删除就行了。

对点分树上的每个子树，设其根为 rt，我们要维护其对于所有子树中的节点 u，rt 到 v 的路径上的未定向边个数 $w_{rt,v}$，顺便维护定向的边中正向及反向的边的个数，以及未定向的边的标号的异或和（为了找未定向的边）。我们发现当 $w$ 的值大于等于 $2$ 时，这四个值都是没有意义的，我们在删边时考虑向下 dfs，只去访问前者的值小于 $2$ 的节点，而且我们每次访问这个节点，它 $w$ 的值都会变小。这样我们对每棵子树中的的每个节点都只会访问 $O(1)$ 次，同时直接用树上前缀和维护这四个值就解决了该问题。复杂度 $O((n+m)\log n)$。

该方式除了复杂度正确以外没有任何优点，具体表现为多次 dfs 导致常数巨大（洛谷 $5.3s$），代码巨难写（$5.6k$）。

贴个代码。

```cpp#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int N = 5e5+5;
int n,c,m;
int fa[N];
vector<int>e[N];
int A[N],B[N],C[N];
int tdep[N],rt,tfa[N];
int dep[20][N];
int sz[N];
bool vis[N];
int U[N],V[N];
queue<int>q;
unordered_map<int,int>mp[N];
vector<int>Q[20][N];
int dir[N];
int cur[20][N],num[20][N],anum[20][N],sum[20][N];//未定向边个数，正向/反向边个数，未定向边异或和
void getrt(int u,int fa,int SZ)
{
    sz[u] = 1;
    int mx = 0;
    for(auto E:e[u])
    {
        int v = U[E] + V[E] - u;
        if(!vis[v] && v != fa)
        {
            getrt(v,u,SZ);
            mx = max(mx,sz[v]);
            sz[u] += sz[v];
        }
    }
    mx = max(mx,SZ-sz[u]);
    if(mx + mx <= SZ) rt = u;
}
void dfs(int u,int fa,int x)//dfs下去
{
    sz[u] = 1;
    for(auto E:e[u])
    {
        int v = U[E] + V[E] - u;
        if(vis[v] || v == fa) continue;
        cur[x][v] = cur[x][u] + 1;
        if(cur[x][v] == 3) cur[x][v] = 2;
        sum[x][v] = sum[x][u] ^ E;
        dep[x][v] = dep[x][u] + 1;
        dfs(v,u,x);
        sz[u] += sz[v];
    }
}
void build(int c,int SZ,int lst)
{
    getrt(c,0,SZ);
    int RT = rt;
    tdep[RT] = tdep[tfa[RT] = lst] + 1;
    vis[RT] = 1;
    dfs(RT,0,tdep[RT]);
    for(auto E:e[RT])
    {
        int v = U[E] + V[E] - RT;
        if(!vis[v]) build(v,sz[v],RT);
    }
}
int LCA(int x,int y)
{
    while(tdep[x] > tdep[y]) x = tfa[x];
    while(tdep[y] > tdep[x]) y = tfa[y];
    while(x != y) x = tfa[x],y = tfa[y];
    return x;
}
void work(int u,int fa,int x)
{
    if(cur[x][u] >= 2)
    {
        cur[x][u] = 2;
        return ;   
    }
    else
    {
        for(auto id:Q[x][u])
        {
            //if(id == 21) cout<<"dddd\n"<<vis[id]<<"\n",exit(0);
            if(vis[id]) continue;
            int a = A[id],b = B[id];
            if(cur[x][a] + cur[x][b] <= 1)
            {
                vis[id] = 1;
                q.push(id);
            }
        }
    }
    for(auto E:e[u])
    {
        int Dir = dir[E],v = U[E] + V[E] - u;//1：u->v
        if(v == fa || tdep[v] < x) continue;
        if(u == V[E]) Dir = -Dir;
        cur[x][v] = cur[x][u];
        sum[x][v] = sum[x][u];
        anum[x][v] = anum[x][u];
        num[x][v] = num[x][u];
        if(Dir == 0) cur[x][v]++,sum[x][v] ^= E;
        if(Dir == 1) num[x][v]++;
        if(Dir == -1) anum[x][v]++;
        work(v,u,x);
    }
}
void DEL(int x,int y)
{
    //定向：x->y
    //cout<<"DD"<<x<<" "<<y<<"\n";
    int id = mp[x][y],Dir = 1;
    if(id < 0) dir[-id] = -1;//-1:V->U
    else dir[id] = 1;//1:U->V
    int RT = tdep[x] > tdep[y] ? y:x;
    //cout<<"DEL"<<x<<" "<<y<<" "<<RT<<"\n";
    while(RT)
    {
        if(dep[tdep[RT]][x] > dep[tdep[RT]][y]) swap(x,y),Dir = -Dir;//x要在y上面
        //cout<<"RT:"<<RT<<" "<<x<<" "<<y<<" "<<tdep[RT]<<"\n";
        //cout<<dep[tdep[RT]][x]<<" "<<dep[tdep[RT]][y]<<"\n";
        cur[tdep[RT]][y] = cur[tdep[RT]][x];
        sum[tdep[RT]][y] = sum[tdep[RT]][x];
        num[tdep[RT]][y] = num[tdep[RT]][x];
        anum[tdep[RT]][y] = anum[tdep[RT]][x];
        if(Dir == 1) num[tdep[RT]][y]++;//定向为从x->y
        else anum[tdep[RT]][y]++;
        work(y,x,tdep[RT]);
        RT = tfa[RT];
    }
}
bool FL = 0;
void check(int x,int y)
{
    if(x == y)
    {
        FL = 1;
        return ;
    } 
    for(auto v:e[x])
    {
        check(v,y);
        if(FL == 1) return ;
    }
}
void POP()
{
    int id = q.front(),x = A[id],y = B[id];q.pop();
    int z = tdep[C[id]];
    int cnt = cur[z][x] + cur[z][y];
    int NUM = num[z][x] + anum[z][y];
    if(NUM > 0) return ;
    else
    {
        if(cnt == 0)
        {
            cout<<"ERR\n",exit(0);
            //cout<<"-1\n";
            return ;
        }
        if(sum[z][x])//从x到z
        {
            int id = sum[z][x];
            int a = U[id],b = V[id];
            if(dep[z][a] > dep[z][b]) swap(a,b);//a应该在b上面
            DEL(a,b);
        }
        if(sum[z][y])//从z到y
        {
            int id = sum[z][y];
            int a = U[id],b = V[id];
            if(dep[z][a] < dep[z][b]) swap(a,b);//a应该在b下面
            DEL(a,b);
        }
    }
}
int aa,bb,cc,fl;
void DIS(int x,int fa,int y)
{
    if(x == y)
    {
        fl = 1;
        return ;
    }
    for(auto E:e[x])
    {
        int v = U[E] + V[E] - x;
        if(v == fa) continue;
        if(dir[E] == 0) bb++;
        else if((dir[E] == 1) ^ (U[E] == x)) aa++;
        DIS(v,x,y);
        if(fl == 1) return ;
        if(dir[E] == 0) bb--;
        else if((dir[E] == 1) ^ (U[E] == x)) aa--;
    }
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(0);
    cin>>c>>n>>m;
    for(int i = 1;i < n;i++)
    {
        cin>>U[i]>>V[i];
        e[V[i]].pb(i),e[U[i]].pb(i);
        mp[U[i]][V[i]] = i;
        mp[V[i]][U[i]] = -i;
    }
    tdep[0] = -1;
    build(1,n,0);
    for(int i = 1;i <= m;i++) cin>>A[i]>>B[i],C[i] = LCA(A[i],B[i]),Q[tdep[C[i]]][A[i]].pb(i),Q[tdep[C[i]]][B[i]].pb(i);
    for(int i = 1;i <= n;i++) vis[i] = 0;
    for(int i = 1;i <= m;i++)
    {
        if(mp[A[i]][B[i]] != 0)
        {
            vis[i] = 1;
            q.push(i);
        }
    }
    while(!q.empty()) POP();
    for(int i = 1;i < n;i++)
    {
        if(dir[i] == 0)
        {
            dir[i] = 1;
            DEL(U[i],V[i]);
            while(!q.empty()) POP();
        }
        if(dir[i] == -1) cout<<"1";
        else cout<<"0";
    }
    cout<<"\n";
    return 0;
}
```

---

## 作者：strcmp (赞：0)

> 景色みたいな命なんて

> それでも確かに生きている

[题目传送门](https://www.luogu.com.cn/problem/P10787)

这题其实可以说是一个很 OI 意义下的好的题：题意容易理解，不像传统 OI 防 AK 题那样堆砌巨大状物纯粹的考场不可做，也不像传统 ad-hoc 高难度题一样思维跳跃难以战胜。但是绝对不属于好想好做的题，代码和思维难度都足够当得起 D1T3 这个位置。

注意到题解区没有什么对做法的正确性证明，我就补充一下吧，也有可能我想法复杂了，欢迎提供思路。

---

首先吧，遇到这种题就不要急着往什么 k-SAT 这种一眼看过去没有希望就跟我的人生一样的东西上去考虑。

然后肯定是考虑下特殊性质怎么做了。

**B 性质**

这个看起来远比 A 性质好做。既然是菊花图，首先 $1$ 和其它结点的限制是平凡的，我们只能直接把这些边钦定成这些限制。否则我们可以把其余限制刻画为：$a_i$ 和 $b_i$ 不能同时为 $0$ 或者同时为 $1$。这是经典 2-SAT 形式，直接做即可。

应该有不少人在这里把思路往布尔可满足性问题上靠了，但很显然我们的限制放到树上将会变成限制一个树上路径不能全 $0$ 或者全 $1$，而我们一般的布尔可满足性问题无法刻画诸如区间或者路径这些限制，毕竟你总不可能真的写个动态求 SCC 上去吧。

如果把路径看成集合，那么我们的问题转化为 k-SAT 问题，显然没办法解决这个问题，除非我们想挑战图灵奖了。

因此这里能提示我们，也许 B 性质对做题的帮助并不大。

**A 性质**

A 性质大概就是说所有不相邻的可能的限制均出现。

那么我们肯定是考虑把树看成二分图，然后所有边都定向为二分图上的一个方向（其实就是按深度的奇偶交替），这样我们至多走一条边就不能再走了。肯定所有限制都满足！

这个肯定是唯二最优解，把对称的情况判一下即可。A 性质是简单的。

**sol**

A 性质给我们极大的启发。

接下来考虑最小化字典序，我们当然是让前面的尽可能是 $0$，后面的怎么样都没关系。那么就自然而然的我们要从 $1$ 到 $n - 1$ 依次考虑输入的每一条边，每次尽可能地让前面选了 $0$，至于后面的东西就不需要考虑，只要我们有办法使得前面选了 $0$ 之后还有解就行了。

那么现在相当于若干条边已经确定好了，你需要判断能否将当前考虑的边设置为 $0$，否则只能设置成 $1$。

那么问题就是怎么判断确定好的的边集能不能达成？很显然，对于一个限制，我们可能出现 ``0?0?0`` 这种情况，如果强行那么这两个未确定的边交替出现，那么它们的状态应该是一样的，因为实际上我们是按照边的深度进行交替的。这个时候贸然去确定就会导致我们限制不合法。

那就不考虑这些东西了，转头考虑如果我们当前定向的边，它定完向了之后不会出现任何一个限制被违反，就定。否则我们肯定出现了一个被违反的限制（听起来是废话，但是把过程理清楚还是更好做题的）。

那么我们是什么时候是不得不去违反一个限制的呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/kfy3prhw.png)

对的，就是上面左图的情况，如果我们的限制是黄色一个限制，绿色一个限制。那么确定 $5$ 的这个边定上定下都会违反一个限制。

发现被 Hack 了，一般来说：

- 确定这种 Hack 是否真的可能出现。

- 真的出现了，我们能不能打补丁。

- 打不了补丁，那就换个思路。

现在回来考虑，如果我们是按照 $1 \to 5$ 的顺序定向的，那么不可避免地会产生冲突。

但第一步思考来了：为什么我们不能按 $1 \to 2 \to 5 \to 3 \to 4$ 来定向呢？这样我们就不会冲突了，毕竟 $5$ 一定会被定向成绿色限制的**反**方向，那么到黄色限制的时候我们就有很多选择来让它不冲突了。

那么我们在搞完 $1 \to 2$ 之后怎么确定下一个定向的是 $5$ 呢？**因为 $5$ 是绿色限制上唯一未定向的边。**

既然我们现在考虑的限制**有且只有**一个未定向的边，那么为什么我们不去先把它定向了，而是去定向别的边等回来的时候没办法定向它呢？

---

> **结论** 如果我们每次定向前先检查所有限制，并且将其内部恰好还剩一条边 $k$ 未定向的限制的取出来，将 $k$ 定向为限制的反方向。
> 
> 那么，在题目条件保证存在合法方案的情况下，我们每次定向完一条边，之后必定都有解。
> 
> 我们的做法就出来了，每次先按这个原则检查定向，最后把未定向的编号最小边定为 $0$。

这个结论很好理解，不过我们还是要证明一下。我们定义一个限制 $(a,\,b)$ 的不饱和度为其所覆盖的未定向的边数，目前定向完的边全部在 $a \to b$ 方向上的限制称为非平凡限制（平凡限制对我们来说已经无用，因为再往后定都不可能违反了）。不饱和度为 $1$ 的非平凡限制称为强限制。

如果我们存在两个**冲突**的强限制（也就是他们必须把唯一的那条边给定向成相反的方向），那我们肯定没办法满足这两个限制，也就无解。

首先如果不存在这种情况，根据字典序的贪心性质，那我们这种方法当然是对的。

那么我们可以考虑证明不可能出现这种情况。

- 首先是已知条件，题目保证有解，也就是初始时候不存在冲突强限制。

- 其次如果存在两个限制 $(a,\,b)$ 和 $(c,\,d)$，且存在一条边 $k$ 包含于这两个限制使得在 $k$ 上 $a \to b$ 和 $c \to d$ 方向一致/相反，那么一定**不存在**边 $t$ 使得在 $t$ 上 $a \to b$ 和 $c \to d$ 方向相反/一致。这个应该是显然的。

- 如果我们是定向了某一条边 $p$ **之后出现**了冲突强限制 $x = (a_1,\,b_1),\,y = (a_2,\,b_2)$，那么设 $a_1 \to b_1$ 和 $a_2 \to b_2$ 交叉于边 $q$，就是因为这个 $q$ 要同时定为 $a_1 \to b_1$ 和 $a_2 \to b_2$ 导致冲突的。

- 场景 $1$：如果 $y$ 在未定向 $p$ 之前就已经是一个强限制了（此时 $x$ 必不可能为强限制），那么我们就是因为定向 $p$ 让 $x$ 成为强限制导致冲突，那么回去考虑我们为什么要先定向 $p$ 而不是先定向 $q$（$q$ 已经是强限制 $b$ 的唯一不饱和边了），一定是有另一个强限制 $z = (a_3,\,b_3)$ 唯一的未定向边是 $p$，并且 $p : x \ne p : z$（指在 $p$ 上 $x,\,z$ 异向，否则定完 $p$ 之后 $x$ 直接变平凡限制了）。

我们称强限制的**形成时刻**是指一个限制第一次变为强限制的时刻。

如果 $y$ 在 $z$ 之前就形成了，那我们就一定先把 $q$ 定成 $y$ 的反方向，此时 $x$ 还不是强限制，$z$ 也没有形成。那么不可能造成这种场景。

如果 $z$ 在 $y$ 之前就形成了，那么我们一定是在 $y$ 形成之前先定向 $p$，要么 $x$ 定向完 $p$ 之后是一个强限制，那么自然它唯一的不饱和边也是 $q$，我们一定会定向 $q$ 为 $x$ 的反方向（也就是 $y$ 的正方向），但是此时 $y$ 还是个**弱**限制（也就是非强限制），很显然形成不了场景 $1$；要么 $x$ 定向完 $p$ 之后是一个弱限制，此时 $x,\,y$ 都是弱限制，也不可能形成场景 $1$。

遗漏了一种情况，有没有可能 $y$ 包含 $p$，定向完 $p$ 之后让 $y$ 成为强限制？不可能，$x,\,z$ 在 $p$ 上异向，$x,\,y$ 在 $p$ 上也异向，那么 $z,\,y$ 就是同向的，定向 $p$ 一定会让 $y,\,z$ 都成为平凡限制。

- 场景 $2$：$x,\,y$ 在 $p$ 定向之前都是弱限制，定向完 $p$ 之后变成冲突强限制。

不可能出现这种情况。很显然根据 $x,\,y$ 在 $q$ 上异向，那么 $x,\,y$ 在 $p$ 上是异向的，那么它们中间至少有一个限制在 $p$ 定向之后变成了平凡限制。

---

于是我们得到了一个复杂度为 $\Theta(nm)$（如果你想问怎么做到这个复杂度，每次定向完暴力更新树上前缀和即可），并相对详细地说明了这个做法的正确性。

此时如果在考场上，你已经获得了 $64$ 分！

继续考虑优化时间复杂度，我们的问题已经被转化为：

- 给定 $n$ 个结点的树，边权只有 $0$ 和 $1$，初始边权均为 $1$。给定 $m$ 个树上路径，每次把一个边权为 $1$ 的边修改为 $0$，查询所有路径和为 $1$ 的路径，并把它们删除。

- 要查询路径和为 $1$ 的限制是不是已经是平凡限制，这当然很容易做，也不是瓶颈。两个并查集，一个并向下的边，一个并向上的边，然后针对 LCA 搞些简单分讨就行了。当然你一定要用些高级点的东西我也不拦着你。

考虑怎么优化这个查询所有路径和为 $1$ 的路径。

有个东西叫折半警报器，如果没学过的话建议去学一下，这个思想是比较好用的。简单来说，这东西就是用于一些当某某区域里面的和 $\le V$ 的时候搞些操作然后删除，还有个升级版是二进制警报器，不过离题太远不提了。

我们的问题弱不少，和 $\le 1$ 就要被拉出来（先说前提，和为 $0$ 的路径早被删了）。所以尽量做到单 log 吧。

可以考虑警报器的思想（那个鸽巢原理大概没啥用了）开做。把总和等于 $0$、总和等于 $1$ 和总和 $\ge 2$ 分成三个**状态**，每次状态改变就报一次警让我们查看。

- **轻重链分治**

我们直接考虑链分治相关的东西！最简单的就是树剖。

其实如果你会做 P4215 的单 $\log$ 做法你就秒杀了。

当然树剖边转点是必须的，不过相当平凡就不谈了。这时候我们可以把限制**拆成** $\Theta(\log^2 n)$ 个线段树上区间。

每次我们相当于让 $\Theta(\log n)$ 个线段树结点的权值 $-1$（单点修改），当某个结点改变状态（权值在 $= 0,\,= 1,\,\ge 2$ 之间改变）的时候，包含这个结点的所有区间我们就要拉出来查看一次。

考虑复杂度，每个结点状态改变至多 $2$ 次，一个限制包含的结点数是 $\log^2 n$。也就是所有结点挂着的限制总和是 $\Theta(m \log^2 n)$ 级别的。

以下设 $n,\,m$ 同阶，毕竟对于数据范围来说确实如此。

如果我们每次都在树剖上暴力查询这些限制的总和，时间复杂度 $\Theta(n \log^4 n)$，相当爆炸。

换成全局平衡二叉树也就是把我们的复杂度降低到 $\Theta(n \log^3 n)$ 或 $\Theta(n \log^2 n)$。

但实际上有更好的办法。我们只需要提前维护好所有限制包含的 $\ge 2$ 区间数量 $c_2$ 和 $= 1$ 区间数量 $c_1$，当改变状态的时候就把包含这个结点的所有限制**对应**量减 $1$，当 $c_2 = 0$ 且 $c_1 = 1$ 的时候我们的限制就是一个强限制或平凡限制。这就不用每次去重新查询区间和。于是总时空复杂度是 $\Theta(n \log^2 n)$。

其实卡卡常应该也能过了，CCF 机子相当快，不过这里是洛谷，我们需要把树剖换成全局平衡二叉树。

全局平衡二叉树有个写法是把带权中点设置为 $\text{mid}$ 直接跑线段树树剖，所以直接套过去就行了。

- **树上倍增**

首先我们的路径是可以被拆成 $u \to \text{lca}$ 和 $\text{lca} \to v$ 的，毕竟我们维护的东西确实相对较弱，只需要当这两段的其中一段总和 $\le 1$ 的时候报警就行了。

然后差不多类似树剖做法一样做。

实际上你可以把这东西理解为倍增优化建图然后拓扑排序。

- **树分治**

点分治和 Top Tree 分治相关？不会这个做法。

---

下列代码使用 Leafy 化的全局平衡二叉树，时空复杂度为 $\Theta(n \log n)$，常数脑测应该很巨大，实际测试几乎没啥常数，跑得飞快吊打大多数倍增（我的天啊全局平衡二叉树大人），非常牛逼。

下面是参考代码。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define E(i, u) for (int i = h[u], v = e[h[u]].to; ~i; i = e[i].nxt, v = e[i].to)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define mid (l + r >> 1)
using namespace std;
typedef long long int ll;
using ull = unsigned long long int; using I = int;
template<typename T1, typename T2> using pr = pair<T1, T2>; using pii = pr<I, I>;
template<typename T> using pq = priority_queue<T>;
template<typename T> using vec = vector<T>;
constexpr int maxn = 5e5 + 10, mod = 998244353, N = maxn - 5, K = 25002; constexpr ll inf = 1e12;
inline ll ksm(ll a, int b = mod - 2) { ll ls = 1; while (b) (b & 1) && (ls = ls * a % mod), a = a * a % mod, b >>= 1; return ls; }
char buf[1 << 23], * p1 = buf, * p2 = buf, obuf[1 << 23], * O = obuf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {
	char c = 0; int x = 0;
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) x = x * 10 + c - '0', c = getchar();
	return x;
}
struct Node { int l, r, s; vector<int> a; } t[maxn << 2];
#define ls(x) (t[x].l)
#define rs(x) (t[x].r)
#define tr(x) (t[x].a)
#define s(x) (t[x].s)
struct edge { int to, nxt, o; } e[maxn << 1]; int h[maxn], eid[maxn], cnt = 2, C, n, m, tot; // fa[u] -> u 这条边所对应的编号
inline void add(int u, int v) { e[cnt].nxt = h[u], e[cnt].to = v, h[u] = cnt++; }
int pa[2][maxn], tp[maxn], d[maxn], sz[maxn], son[maxn], md[maxn], fa[maxn], id[maxn], dct, rt[maxn], len[maxn], A[maxn], B[maxn], c1[maxn], c2[maxn], ans[maxn]; // mid
int fd(int o, int x) { return !pa[o][x] ? x : pa[o][x] = fd(o, pa[o][x]); }
void dfs1(int u, int f) {
	d[u] = d[fa[u] = f] + (sz[u] = 1);
	E(i, u) {
		if (v == f) continue; eid[v] = i ^ 1;
		dfs1(v, u); sz[u] += sz[v];
		if (sz[son[u]] < sz[v]) son[u] = v;
	}
}
void dfs2(int u, int top) {
	++len[tp[u] = top]; id[++dct] = u;
	if (son[u]) dfs2(son[u], top);
	E(i, u) if (v != fa[u] && v != son[u]) dfs2(v, v);
}
inline int lca(int x, int y) {
	while (tp[x] != tp[y]) {
		if (d[tp[x]] < d[tp[y]]) swap(x, y);
		x = fa[tp[x]];
	}
	return d[x] > d[y] ? y : x;
}
inline void up(int x) { s(x) = s(ls(x)) + s(rs(x)); }
void ins(int l, int r, int ml, int mr, int T, int& x) {
	if (ml <= l && r <= mr) {
		s(x) == 1 ? ++c1[T] : ++c2[T];
		return tr(x).pb(T);
	}
	if (ml <= md[x]) ins(l, md[x], ml, mr, T, ls(x));
	if (mr > md[x]) ins(md[x] + 1, r, ml, mr, T, rs(x));
}
void Inster(int T) {
	//我们要做的事情：记录限制的 c1, c2 值，把限制插到全局平衡二叉树上
	int x = A[T], y = B[T];
	while (tp[x] != tp[y]) {
		if (d[tp[x]] < d[tp[y]]) swap(x, y);
		ins(1, len[tp[x]], 1, d[x] - d[tp[x]] + 1, T, rt[tp[x]]);
		x = fa[tp[x]];
	}
	if (d[x] > d[y]) swap(x, y);
	if (x != y) ins(1, len[tp[x]], d[x] - d[tp[x]] + 2, d[y] - d[tp[y]] + 1, T, rt[tp[x]]);
}
inline int ck(int T) {
	//T 是一个可能的强限制，返回值为 0 代表该限制已经成为平凡限制，否则返回该强限制唯一的那条边
	int x = A[T], y = B[T], w = lca(x, y); // 令 pa[0] 为向上的边组成的并查集，pa[1] 为向下的边，并且我们一定是下面的连向上面，也就是并查集的根就是最浅的点
	if (fd(0, x) == fd(0, w) && fd(1, fa[fd(1, y)]) == fd(1, w)) return -(eid[fd(1, y)] ^ 1); // x -> lca 畅通无阻，lca -> y 恰有一个阻碍，我们希望这个边是往上的阻碍 y
	else if (fd(1, y) == fd(1, w) && fd(0, fa[fd(0, x)]) == fd(0, w)) return eid[fd(0, x)] ^ 1; // x -> lca 恰有一个阻碍，lca -> y 畅通无阻，我们希望这个边是往下的阻碍 x
	return 0;
}
void Mdf(int E, int k);
inline void doi(int u) {
	// 有个限制变为可能的强限制，要 check 它是否为强限制
	int k = ck(u); // 返回了那个边的编号，我们令它是 fa[u] -> u 这种边
	if (k > 0) Mdf(k, 0);
	else if (k < 0) k = -k, Mdf(k, 1);
}
void mdf(int l, int r, int v, int x) {
	if (--s(x) == 1) {
		for (int u : tr(x)) {
			--c2[u], ++c1[u];
			if (!c2[u] && c1[u] == 1) doi(u);
		}
	}
	else if (!s(x)) for (int u : tr(x)) if (--c1[u] == 1) doi(u);
	if (l == r) return;
	v <= md[x] ? mdf(l, md[x], v, ls(x)) : mdf(md[x] + 1, r, v, rs(x)); up(x);
}
void Mdf(int E, int k) {
	// 将 E 这条边定向，k = 0 定为正向，k = 1 定为反向
	if (ans[E >> 1] != -1) return;
	ans[(E >> 1)] = !(e[E].o ^ k);
	int w = (d[e[E].to] < d[e[E ^ 1].to]);
	if (!(w ^ k)) pa[1][e[E ^ w].to] = fd(1, e[E ^ 1 ^ w].to);
	else pa[0][e[E ^ w].to] = fd(0, e[E ^ 1 ^ w].to);
	int u = (w ? e[E ^ 1].to : e[E].to);
	mdf(1, len[tp[u]], d[u] - d[tp[u]] + 1, rt[tp[u]]);
}
pii b[maxn]; // 临时数组
void bd(int l, int r, int& u) {
	if (!u) u = ++tot; if (l == r) return void(s(u) = 1);
	int x = l, y = r + 1;
	while (y - x > 1) {
		int M = x + y >> 1;
		if (2 * (b[M].Y - b[x].Y) <= b[y].Y - b[x].Y) x = M;
		else y = M;
	}
	if (x == r) --x; md[u] = x;
	bd(l, x, ls(u)), bd(x + 1, r, rs(u)); up(u);
}
void Build() {
	for (int i = 1, j = 0; i <= n; i = j + 1) {
		int x = tp[id[i]];
		while (j + 1 <= n && x == tp[id[j + 1]]) ++j, b[j - i + 1].X = id[j], b[j - i + 1].Y = sz[id[j]] - sz[son[id[j]]] + b[j - i].Y;
		bd(1, j - i + 1, rt[x]);
		rep(k, 0, j - i + 1) b[k].X = b[k].Y = 0;
	}
	rep(i, 1, m) Inster(i);
}
void solve() {
	rep(i, 1, m) if (d[A[i]] == d[B[i]] + 1 || d[B[i]] == d[A[i]] + 1) doi(i);
	for (int i = 2; i < cnt; i += 2) if (ans[(i >> 1)] == -1) Mdf(i, 0);
}
int main() {
	//freopen("tree.in", "r", stdin);
	//freopen("tree.out", "w", stdout);
	memset(ans, -1, sizeof(ans));
	memset(h, -1, sizeof(h)); C = read(), n = read(), m = read();
	for (int i = 1, u, v; i < n; i++) u = read(), v = read(), e[cnt].o = 1, add(u, v), add(v, u);
	rep(i, 1, m) A[i] = read(), B[i] = read();
	dfs1(1, 0), dfs2(1, 1); Build(); solve();
	rep(i, 1, n - 1) printf("%d", ans[i]);
	return 0;
}
```

---


# [NOI2024] 分数

## 题目背景

由于评测机性能差异，原题时限为 6s，洛谷时限为 9s。

## 题目描述

小 Y 和小 C 在玩一个游戏。

定义正分数为分子、分母都为正整数的既约分数。

定义**完美正分数集合** $S$ 为满足以下五条性质的正分数集合：
- $\dfrac{1}{2}\in S$；
- 对于 $\dfrac{1}{2}<x<2$，$x\not \in S$；
- 对于所有 $x\in S$，$\dfrac{1}{x}\in S$；
- 对于所有 $x\in S$，$x+2 \in S$；
- 对于所有 $x\in S$ 且 $x>2$，$x-2 \in S$；

可以证明，上述五条性质确定了唯一的完美正分数集合 $S$。

所有完美正分数集合 $S$ 中的正分数被称为**完美正分数**。记 $f(i,j)$ 表示 $\dfrac{i}{j}$ 是否为完美正分数，即 $f(i,j)=1$ 当且仅当 $i$ 与 $j$ 互素且 $\dfrac{i}{j} \in S$，否则 $f(i,j)=0$。

小 C 问小 Y：给定 $n,m$，求所有分子不超过 $n$，分母不超过 $m$ 的完美正分数的个数，即求 $\sum_{i=1}^n \sum_{j=1}^m f(i,j)$。

时光走过，小 C 和小 Y 会再遇见。回首往事，大家都过上了各自想要的生活。

## 说明/提示

**【样例 1 解释】**

可以证明，分子分母均不超过 $10$ 的完美正分数共有 $16$ 个，其中小于 $1$ 的 $8$ 个如下：
- $\dfrac{1}{2},\dfrac{1}{4},\dfrac{1}{6},\dfrac{1}{8},\dfrac{1}{10},\dfrac{2}{5},\dfrac{2}{9},\dfrac{4}{9}$。

大于 $1$ 的 $8$ 个完美正分数分别为上述 $8$ 个小于 $1$ 的完美正分数的倒数。
- 可以按照如下方式验证 $\dfrac{2}{9}$ 是否为完美正分数：因为 $\dfrac{1}{2}\in S$，$\dfrac{1}{2}+2=\dfrac{5}{2}\in S$，$\dfrac{5}{2}+2=\dfrac{9}{2}\in S$，$\dfrac{1}{\dfrac{9}{2}}=\dfrac{2}{9}\in S$；
- 可以按照如下方式验证 $\dfrac{3}{7}$ 是否为完美正分数：假设 $\dfrac{3}{7}$ 是完美正分数，则 $\dfrac{1}{\dfrac{3}{7}}=\dfrac{7}{3}\in S$，$\dfrac{7}{3}-2=\dfrac{1}{3}\in S$，$\dfrac{1}{\dfrac{1}{3}}=3\in S$，$3-2=1\in S$，与第二条性质矛盾，因此 $\dfrac{3}{7}$ 不是完美正分数

**【数据范围】**

对于所有测试数据保证：$2\leq n,m\leq 3\times 10^7$。

::cute-table{tuack}

| 测试点编号 | $n\leq$ | $m\leq$ |
| :----------: | :----------: | :----------: |
| $1\sim 3$ | $10^2$ | $10^2$ |
| $4\sim 6$ | $10^3$ | $10^3$ |
| $7\sim 10$ | $8\,000$ | $8\,000$ |
| $11\sim 14$ | $10^5$ | $10^5$ |
| $15\sim 17$ | $10^6$ | $10^6$ |
| $18$ | $8\times 10^6$ | $8\times 10^6$ |
| $19$ | ^ | $3\times 10^7$ |
| $20$ | $3\times 10^7$ | ^ |

## 样例 #1

### 输入

```
10 10```

### 输出

```
16```

## 样例 #2

### 输入

```
见 fraction2.in/ans
这个样例满足测试点 4-6 的约束条件```

### 输出

```
```

## 样例 #3

### 输入

```
见 fraction3.in/ans
这个样例满足测试点 11-14 的约束条件```

### 输出

```
```

## 样例 #4

### 输入

```
见 fraction4.in/ans
这个样例满足测试点 15-17 的约束条件```

### 输出

```
```

# 题解

## 作者：C1942huangjiaxu (赞：16)

**2024.8.23 upd: 修复了参考代码中 $n\lt b$ 时出错的问题。**

本题解主要讲述官方题解怎么实现。

首先可以发现，每个分数都可以由 $2$ 开始，若干 $+2$，取倒数，这样的若干次操作得到，并且每个分数操作序列唯一。

这里不妨假设 $n\le m$，我们只考虑 $\lt 1 $ 的分数。

那么每次操作，相当于，加上一个偶数 $u$，然后取倒数。

也就是官方题解中连分数的形式：

$$\cfrac{1}{u_1+\cfrac{1}{u_2+\cfrac{1}{u_3+\cfrac{1}{u_4+\cdots}}}} $$

假设当前的值为 $\cfrac a b$，那么加上 $u$ 后取倒数，就是 $\cfrac {b}{bu+a}$。

我们搜索中，把 $u$ 中的最大值设为 $x$，统计答案时直接统计所有可能的 $x$，官方题解中说明，这样的搜索量是可以接受的。

于是，我们的搜索过程就可以描述为，先进行若干次操作，得到分数 $\cfrac{a}{b}$，然后加入最大值 $x$，搜索分数 $\cfrac {ax+b}{cx+d}$，同时我们要维护最大值 $x$ 的下界来统计答案。

将不可能成为答案的状态剪枝，最后大概统计 $4\times 10^8$ 次答案。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long ans;
void dfs1(int a,int b,int c,int d,int v){
	if(1ll*a*v+b>n)return;
	ans+=max(0,min(!a?m:(n-b)/a,(m-d)/c)-v+1)+max(0,(n-d)/c-v+1);
	for(int u=1;;++u){
		int A=2*c*u+a,B=2*d*u+b;
		if(1ll*A*max(v,u+1)+B>m)break;
		dfs1(c,d,A,B,max(v,u+1));
	}
}
void dfs2(int a,int b,int v){
	for(int u=1;;++u){
		int c=2*u*b+a;
		if(2ll*c*max(v,u)+b>m)break;
		dfs2(b,c,max(v,u));
	}
	dfs1(0,b,2*b,a,v);
}
int main(){
	scanf("%d%d",&n,&m);
	if(n>m)swap(n,m);
	dfs2(0,1,1);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Larunatrecy (赞：8)

首先假设 $n\geq m$，我们考虑如下过程：

- 初始时 $(p,q)=(1,0)$。
- 枚举 $u=2k(k\geq 1)$，令 $(p,q)\to (q+up,p)$。 

可以证明，该过程可以不重不漏生成所有 $>1$ 的完美正分数 $\frac{p}{q}$。

对于 $<1$ 的完美正分数，只需要在 $p\leq m$ 时让贡献多一即可。

考虑该过程中的所有 $u$ 构成的序列：$u_1,u_2……$，设其中的最大值是 $x$，如果有多个则取最靠前的一个，那么序列变成 $u_1,u_2…… u_{k-2},x,u_k……$，我们先不枚举 $x$ 的值是多少，而是把当前的分数表示成 $(a+bx,c+dx)$ 的形式，并且维护 $x$ 的下界，在完成搜索的时候 $O(1)$ 计算满足要求的 $x$。

具体来说，搜索过程分成两部分，$x$ 之前和之后。

- $x$ 之前的部分，搜索过程和一开始的暴力一样，维护下界 $=\max(u_k+1)$，并且注意如果已经不存在合法的 $x$ 要直接返回。
- $x$ 之后的部分，维护 $(a+bx,c+dx)$，下界 $=\max(u_k)$，也要和上面一样剪枝。

算答案就是 $\min(\lfloor \frac{n-a}{b}\rfloor,\lfloor \frac{m-c}{d}\rfloor)-v+1+\min(\lfloor \frac{m-a}{b}\rfloor,\lfloor \frac{m-c}{d}\rfloor)-v+1$，前边是 $>1$ 的，后边是 $<1$ 的。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int n,m;
LL res=0;
int cl(int a,int b){return b==0?1e9:a/b;}
void dfs(int a,int b,int c,int d,int v)
{
	res+=max(0,min(cl(n-a,b),cl(n-c,d))-v+1);
	res+=min(cl(m-a,b),cl(n-c,d))-v+1;
	for(int u=1;;u++)
	{
		if(c+2*a*u+(d+2*b*u)*max(v,u)>m||a+b*max(v,u)>n)break;
		dfs(c+2*a*u,d+2*b*u,a,b,max(u,v));
	}
}
void dfs1(int x,int y,int v)
{
	for(int u=1;;u++)
	{
		if(x+2*max(u+1,v)*(y+2*u*x)>m||y+2*u*x>n)break;
		dfs1(y+2*u*x,x,max(v,u+1));
	}
	dfs(y,2*x,x,0,v);
}
int main()
{
	cin>>n>>m;
	if(n>m)swap(n,m);
	dfs1(1,0,1);
	cout<<res;
	return 0;
} 
```

---

## 作者：xinxin2022 (赞：6)

很少看到普及组选手暴写 NOI 题的吧。

因为码量少，在调试难度上对普及组选手相对友好，所以花了约两小时~~并在讨论区的帮助下~~通过了此题。

首先有一个结论是很快可以看出来的：

对于 $n \ge m$。

设 $x=1$，$y=0$。

枚举 $k$，当 $k \bmod 2=0$ 且 $k > 0$，令 $x'=kx+y$，$y'=x$，再令 $x=x'$，$y=y'$。

容易发现此过程能生成所有 $>1$ 的完美正分数 $\frac{x}{y}$ 且生成过程唯一。

然后先不考虑 $<1$ 的事，从我们枚举时产生的 $k$ 来看，有一个序列 $k_1,k_2,k_3 \dots$，然后找到最大值 $w=k_l$，将序列转为 $k_1,k_2,k_3,\dots,k_{l-1},w,k_{l+1},\dots$。

然后先不考虑如何快速把 $l$ 或者 $w$ 求出来，先观察每个完美正分数，发现可用 $\frac{a+bw}{c+dw}$ 的形式表示。

然后就能搜索了。

对于任意 $u<l$，$w\ge\max(k_{l+1}+1)$，直接搜。

否则 $w \ge \max(k_{l+1})$，约束 $\frac{p}{q}=\frac{a+bw}{c+dw}$，若不合法直接停止搜索。

然后有 $w$ 的下界了，答案就不难求了。

最多搜索次数在 $10^9$ 以内，只对答案开 long long 完全能过。

如果搜索次数大于 $10^9$，那这题应该就没有算法能过了。

由于本人为普及组小菜，所以代码比较凌乱：


```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
int n,m,k;
long long ans;
int f(int a,int b){
    if(b) return a/b;
    return 998244353;
    //不写判断WA上天
}
void dfs_a(int a,int b,int c,int d,int p){
    k=f(n-c,d);
	ans+=max(0,min(f(n-a,b),k)-p+1)+min(f(m-a,b),k)-p+1;
    //难看的公式，max统计>1的，min统计<1的
	for(int i=1,j=c+a*2*i,l=d+b*2*i;j+l*max(i,p)<=m&&a+b*max(i,p)<=n;i++,j+=2*a,l+=2*b){
		dfs_a(j,l,a,b,max(i,p));
	}
}
void dfs_b(int a,int b,int p){
	for(int i=1,j=b+a*2*i;a+2*max(i+1,p)*j<=m&&j<=n;i++,j+=a*2){
		dfs_b(j,a,max(i+1,p));
	}
	dfs_a(b,a*2,a,0,p);
}
signed main(){
	cin>>n>>m;
	if(n>m) swap(n,m);
	dfs_b(1,0,1);
	cout<<ans;
	return 0;
}
```

注意事项：

别 **`#define int long long`**

看清两个 dfs，否则大红大紫。

看清两种情况分别的下界，否则仍然大红大紫。

**$n$ 有可能比 $m$ 大！**

**$>1$ 部分的答案可能小于 $0$！**

本人毕竟是普及组选手，有错误欢迎指出。

~~我和另外三篇的题解思路不都一样吗？为什么就要打回我的，呜呜呜~~

---

## 作者：ღꦿ࿐ (赞：5)

观察到每一个答案 $(a,b)$ 都存在唯一的回归到 $(1,0)$ 的方式:

若 $b<a$ 则回归到 $(b \bmod (2a),a)$，否则回归到 $(a,b)$，这种类似欧几里得变换的过程可以将每个 $(a,b)$ 唯一对应一条从 $(1,0)$ 变化而来的路径。

于是我们从 $(1,0)$ 开始可以以搜索树状遍历每个完美分数集合中小于 $1$ 的分数，且答案仅被遍历一次。 大于 $1$ 的可以同理统计，时间复杂度 $O(ans)$，可以得到 $90$ 分。  

观察到 $ans$ 不是特别大，考虑时间复杂度就是直接和 $ans$ 相关的做法。

我们考虑形式化这个搜索的过程，该过程形如对二元组 $(u,d)$ 进行 $a_i$ 次 $d \gets d+2u$ 后交换 $u,d$，那么序列 ${a_i}$ 与每个小于 $1$ 的完美分数唯一对应。

直接枚举所有 ${a_i}$ 序列太低效了，我们尝试枚举一部分，统计另一部分。



假设现在已经经历了序列 ${a_1\dots a_{i-1}}$ 得到了二元组 $(u,d)$，下一步会得到二元组 $(d,u + 2d \times a_i)$，然后接下来每一步都是让 $d \gets d+2u$ 后交换 $u,d$，分子分母始终是关于 $a_i$ 的一次函数，故我们带着这个一次函数继续搜索下去，这样可以在结束位置是统计 $k_1a_i+b_1\leq n$，$k_2a_i+b_2\leq m$ 的 $a_i$ 的个数即可减少一层搜索暴力枚举的时间。

你可以尝试枚举其它位置，统计第一位或者任何某一位，但是**无论统计确定的哪一位，几乎不能将状态量减少到可以接受的级别**。

于是我们尝试聪明地枚举值较小的位置，统计最大的 $a_x$ 可能的取值，这样可以一次统计尽可能多的序列，为我们节省更多的枚举。

经测试，该状态数小于 $10^8$，在本题时限下可以接受。

具体实现可以考虑先搜索 $(u,d)$ 并记录其对应的 ${a_i}$ 的最大值，然后尝试在该位钦定为序列 ${a_i}$ 的首个最大值，设其为 $x$，然后记录 $u,d$ 关于 $x$ 的 $kx+b$ 的形式，然后统计时可以 $O(1)$ 统计 $x>mx$ 且 $k_1x+b_1\leq n$，$k_2x+b_2\leq m$ 的 $x$ 即可。


[代码](https://www.luogu.com.cn/paste/xi0q1k6w)

注意剪枝保证复杂度减少无效统计。

---

## 作者：是青白呀 (赞：2)

首先不难发现合法分数具有对称性，即若 $\frac ab$ 合法，$\frac ba$ 也合法。不妨仅统计 $<1$ 的分数。对于 $>2$ 的分数，可以交换 $n,m$ 后，等价于统计 $<1$ 的分数。

这样的分数从 $2$ 开始，可以通过加上一个正偶数 $x$，然后取倒数生成一个新的合法分数。假设当前既约分数为 $\frac ab$，则新生成的分数为 $\frac {b}{bx+a}$，不难发现这也是一个既约的分数，并且由于 $a<b$ 时刻成立，我们可以通过分母不断对分子取模的方式，找到任意一个分数的**唯一**生成路径。因此，我们每一次枚举 $x$，生成的分数是**不重**的。

直接枚举每次的 $x$ 可以得到大部分的分数。进一步优化则需要通过一次枚举生成多个分数。

设生成过程中的正偶数序列为 $g$，由于 $g$ 中最大值的分布较最小值更广泛平均，不妨考虑对首个最大值的可行值个数进行统一计算。

对于首个最大值之前的生成过程，我们暴力枚举 $x$，同时维护最大值的下界 $\max x+1$，并利用下界对不合法情况进行剪枝。首个最大值生成之后，设最大值为 $g_m$，则之后的分数可以被表示为 $\frac{cg_m+d}{ag_m+b}$ 的形式，同样枚举 $x$ 继续生成分数并维护四个系数及最大值下界，并进行类似剪枝。对于每一个生成的 $\frac{cg_m+d}{ag_m+b}$，若它是生成终点，则要保证 $ag_m+b\leq m$，$cg_m+d\leq n$，计算下界之上的合法 $g_m$ 数目并计入答案即可。

不妨设初始分数为 $\frac 01$ 即可完整刻画整个生成过程。

QOJ 跑得快一些，随便写一写就能过。洛谷的机子偏慢，需要通过控制 long long 的数量、加 `inline` 等方式进行卡常才能通过。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
using namespace std;
typedef long long ll;
const int N=5e5+5,M=6,S=(1<<15)+5,inf=1e9+7,mo=998244353;
const double eps=1e-8;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m,upp;
ll ans=0;
inline void getans(int a,int b,int c,int d,int lowv){
    int maxv=min(a?(n-b)/a:inf,c?(m-d)/c:inf);
    if(lowv<=maxv)ans+=((maxv-lowv)>>1)+1;
}
inline void dfs2(int a,int b,int c,int d,int lowv){
    getans(a,b,c,d,lowv),getans(c,d,a,b,lowv);
    for(int x=2;;x+=2){
        int na=a*x+c,nb=b*x+d,nc=a,nd=b,nlv=max(lowv,x);
    //前几轮下面的那个判定是严格大于这一轮的 na 和 nb 的，且 upp 在 int 范围内，故这里不需要用 long long.
        if(1ll*na*nlv+nb>upp)break;
        dfs2(na,nb,nc,nd,nlv);
    }
}
inline void dfs1(int a,int b,int lowv){
    for(int x=2;;x+=2){
        int na=b,nb=b*x+a,nlv=max(lowv,x+2);
        if(nb>upp||(1ll*nb*lowv+na)>upp)break;
        dfs1(na,nb,nlv);
    }
    dfs2(b,a,0,b,lowv);
}
signed main(){
    read(n),read(m),upp=max(n,m);
    dfs1(0,1,2);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：TH911 (赞：2)

> [题目传送门](https://www.luogu.com.cn/problem/P10788)

~~第一道黑题居然是 NOI 的题。~~

# 题意分析

显然，$f(i,j)=f(j,i)$，因此可以假定 $n\leq m$。（否则交换 $n,m$）。

## 生成方式唯一

假设 $x\in S$，则从 $2$ 开始生成，$x$ 的**最短**生成方式是**唯一**的。

### 证明

由 $S$ 性质可得：

* $\dfrac1x\in S$。
* $x+2k\in S$。

这可以等价于：

* $\dfrac{1}{x+2k}\in S$。

其中，$k\in \mathbb Z$，且 $x+2k>0$。

则，$x$ 可以表示为连分数：

$$
x=\dfrac{1}{\dfrac{1}{\dfrac{\begin{aligned}\cdots\end{aligned}}{\dfrac{1}{2+2k_1}+2k_2}+\cdots}+2k_n}
$$

***

令 $x$ 的最短生成方式不唯一，设两种方式的增加数为 $k_i,k'_i$。

可以使用数学归纳法证明。

考虑到 $n=1$ 时，有：

$$
\dfrac{1}{2+2k_1}=\dfrac{1}{2+2k'_1}
$$

交叉相乘，得到：

$$
2+2k_1=2+2k'_1
$$

**必有 $k_1=k'_1$**，即**操作次数为 $1$ 的 $x$ 的最短生成方式唯一**。

**可以发现，一个连分数对应一个生成出来的元素**。

假设 $\dfrac{1}{2+2k_i},\dfrac1{2+2k'_i}$ 对应同一个元素 $y$，从 $y$ 走出的元素操作 $1$ 次到了同一个元素 $x$，**生成方式必然相同**，则 $n=i+1$ 时也成立。

故，**生成方式唯一**。

## DFS 搜索

可以发现，不需要**取模**。那么要么是毒瘤题写高精度，要么是**答案不多**。

因此可以考虑复杂度与答案相关的算法——搜索。

设当前搜索分式中 $k_i$ 的最大值为 $\textit{Max}$。

则连分式可以被表示为 $\dfrac{a\cdot\textit{Max}+b}{c\cdot\textit{Max}+d}$。

连分式：
$$
x=\dfrac{1}{\dfrac{1}{\dfrac{\begin{aligned}\cdots\end{aligned}}{\dfrac{1}{2+2k_1}+2k_2}+\cdots}+2k_i}
$$
设当前元素为第 $i$ 项。

当前状态 $x_i>1$ 的部分对答案 $\textit{ans}$ 的贡献即 $\begin{cases}a\cdot x_i+b\leq n\\c\cdot x_i+d\leq m\\x_i\geq Max\end{cases}$ 的解的数量。

$x_i<1$ 的部分对答案 $\textit{ans}$ 的贡献即 $\begin{cases}c\cdot x_i+d\leq n\\x_i\geq \textit{Max}\end{cases}$ 的解的数量。

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=3e7,M=3e7;
int n,m;
ll ans;
template<typename T>
T divide(T a,T b){
	if(!b){
		return 2147483647; 
	}
	return a/b;
}
//统计具体答案
void dfs(int a,int b,int c,int d,int Max){
	if(1ll*a*Max+b>n){
		return;
	}
	ans+=max(0 , min( divide(n-b,a) ,divide(m-d,c) ) - Max + 1);
	ans+=max(0 , divide(n-d,c) - Max + 1);
	for(int x=1;;x++){
		int down=max(Max,x+1);
		int A=2*c*x+a,B=2*d*x+b;
		if(1ll*A*down+B>m){
			break;
		}
		dfs(c,d,A,B,down);
	}
}
//搜索连分式
void dfs2(int a,int b,int Max){
	for(int x=1;;x++){
		int down=max(Max,x);
		ll pl=2ll*x*b+a;
		if(2ll*pl*down+b>m){
			break;
		}
		dfs2(b,pl,down);
	}
	dfs(0,b,2*b,a,Max);
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	if(n>m){
		swap(n,m);
	}
	dfs2(0,1,1);
	cout<<ans<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：王熙文 (赞：1)

如果你像我一样脑子短路了不会证明这个集合的唯一性，可以看一下这篇题解。

## 思路

首先证明一下完美正分数集合 $S$ 是存在且唯一的。

可以考虑将 $x$ 与 $\dfrac{1}{x}$ 连一条边、$x$ 与 $x+2$ 连一条边（$x>0$），接下来只需要证明，$\dfrac{1}{2}$ 所在的连通块不存在属于 $(\dfrac{1}{2},2)$ 的点，且其他连通块存在属于 $(\dfrac{1}{2},2)$ 的点。

想得到 $\dfrac{1}{2}$ 的连通块可以考虑从 $2$ 开始遍历，那么每次的操作是加上一个正偶数（在 $2$ 处要特判直接取倒数的情况），再取倒数。若某个数 $x$ 加上一个正偶数得到的，那它一定 $>2$。否则它是某个 $\ge 2$ 的数取倒数得到的，一定 $\le \dfrac{1}{2}$。这样就证明了 $\dfrac{1}{2}$ 所在的连通块不存在属于 $(\dfrac{1}{2},2)$ 的点。

接下来证明其他连通块存在属于 $(\dfrac{1}{2},2)$ 的点。考虑倒推上述生成过程。对于一个在其他连通块中的点 $x$，若 $x \in (\dfrac{1}{2},2)$ 则已经满足条件了。若 $x<1$ 则取倒数，否则找到最大的 $2k<x$ 并减去 $2k$。可以发现 $x$ 一定沿着分子加分母由大变小、$x<1$ 变为 $x>1$ 的方向走（即如果分子加分母不变则一定有 $x<1$ 变为 $x>1$），所以走的过程是有限的。最终要么 $x$ 走到一个 $\in (\dfrac{1}{2},2)$ 的点，要么走到 $2$，与假设矛盾。这样就证明完了。

可以发现由 $2$ 开始遍历走到 $x$ 的路径是唯一的，因为由上述倒推的过程是唯一的。其实这一点对我而言有点反直觉，但是确实是对的。这样就可以将问题抽象成这样：从 $(x,y)=(0,1)$ 开始，每次选择一个 $a$ 生成 $(y,x+2ay)$，对每个生成的有序对统计 $[x \le n \land y \le m]+[x \le m \land y \le n]$ 的和。

这启发我们做法不仅仅有简单的搜索，还有对 $a$ 形成的序列计数。但是这样的变换非常奇怪，如果将最终生成的有序对用 $a_i$ 表示，那么最终会形成非常复杂的式子，而且也无法统计答案。但是我们可以只记录一个 $a_i$！因为这是线性变换，所以只记录一个 $a_i$ 作为系数后的形态是很优美的。具体而言，将 $x,y$ 都表示成 $ka_i+b$ 的形式并继续搜索。统计答案就是解一个一次不等式。

接下来的问题就是选择一个最可以压缩状态的 $a_i$ 了。可以发现选择序列的最大值的效果很好。为什么呢？感性理解是，选最大值以前的数的时候都默认以后会有一个比它更大的数存在，这样已经极大地限制了它们的选择空间。

具体实现就是先搜索在最大值以前的选的数的情况，同时维护最大值至少是多少。接下来将最大值作为系数在另一个函数里面搜索，这里也要同时维护最大值的下界。为了保证搜索到的数都是在范围内的，可以将搜索函数改为 `bool` 型的表示当前状态是否能搜索到数。如果 $a_i$ 已经搜索不到了，那么 $a_i+1$ 也一定搜索不到，这是因为任意时刻 $a_i$ 的有序对两维都小于等于 $a_i+1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long ans=0;
bool dfs2(int k1,int b1,int k2,int b2,int lim)
{
	int gt1=min((k1==0?(int)1e9:(n-b1)/k1),(m-b2)/k2),gt2=min((k1==0?(int)1e9:(m-b1)/k1),(n-b2)/k2);
	int nowans=max(gt1-lim+1,0)+max(gt2-lim+1,0);
	if(nowans==0) return 0;
	ans+=nowans;
	for(int i=1; (k1+2*i*k2)*lim+b1+2*i*b2<=max(n,m); ++i)
	{
		if(!dfs2(k2,b2,k1+2*i*k2,b1+2*i*b2,max(lim,i))) break;
	}
	return 1;
}
bool dfs1(int a,int b,int ax)
{
	for(int i=1; a+2*i*b<=max(n,m); ++i)
	{
		if(!dfs1(b,a+2*i*b,max(ax,i))) break;
	}
	return dfs2(0,b,2*b,a,ax+1);
}
int main()
{
	cin>>n>>m;
	dfs1(0,1,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：littlez_meow (赞：1)

发现 $f(i,j)=f(j,i)$，所以交换 $n,m$ 不影响答案。不妨设 $n\le m$。

初看觉得是莫反，但是推不出 $x\in S$ 的充要条件来推式子。

发现答案远不到 $nm$，看看有没有办法搜索。

让我们看样例解释。其中提供了一种 $O(\log n)$ 判定方法判断是否属于 $S$。

不妨猜测每个 $S$ 中的数通过一系列减二和求倒数的操作到达 $\dfrac 1 2$ 的操作序列是唯一的，我们就可以不断求倒数和加二生成所有的完美正分数。

这样把每个完美正分数都搜了一遍，比较劣。我们看能不能每次搜一类完美正分数，$O(1)$ 算出一类有多少个。

我们发现，所有大于 $1$ 的完美正分数都可以写成连分数 $[a_1;a_2,\cdots,a_t]$，其中 $a_i$ 均为偶数。再加上一个完美正分数的操作序列唯一，我们可以直接搜这个连分数序列。

但是直接搜还是一次搜一个。我们需要的却是一次搜一类。

那不如待定其中某一项，先确定其他项再算出待定的项有多少选法。

但是还有一个问题，就是可能算重。我们的待定项必须有一定特殊性。

这个简单，我们可以选择待定项为序列中最靠前的最大值。设该元素是第 $x$ 项。在搜索中记录当前最大值的下界 $v$，$x$ 前为 $\max\limits_{i=1}^{x-1}\{a_i+1\}$，因为要保证 $x$ 最靠前；$x$ 后为 $\max\limits_{i=x+1}^{t}\{a_i\}$，因为可以出现相同的。

由于这项不确定，所以最终的连分数形如 $\dfrac{ra_x+s}{ca_x+d}$。然后求关于 $a_x$ 的不等式 $ra_x+s\le n,ca_x+d\le m,a_x\ge v$ 的解数即可。

对于小于 $1$ 的部分，就是附加几个条件 $ra_x+s\le m,ca_x+d\le n$。

如果 $a_x$ 无解了要剪枝。不难发现解数越来越少，所以这样剪是对的。$x$ 位后是好判的，直接看不等式有无解。$x$ 位前可以看如果下一位是 $x$ 且 $a_x$ 带最小值分子是否小于等于 $n$。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
using namespace std;
int n,m;
ll ans;
void dfs2(int r,int s,int c,int d,int mn){
	auto calc=[&](int x,int y){
		int res;
		if(!r) res=(y-d)/c;
		else if(!c) res=(x-s)/r;
		else res=min((y-d)/c,(x-s)/r);
		res=res-mn+1;
		return max(res,0);
	};
	ans+=calc(n,m)+calc(m,m);
	for(int ai=1;;++ai){
		static int qwq,nr,ns;
		nr=c+2*ai*r;
		ns=d+2*ai*s;
		qwq=max(ai,mn);
		if(nr*qwq+ns>n||r*qwq+s>m) break;
		dfs2(nr,ns,r,s,qwq);
	}
	return;
}
void dfs1(int x,int y,int mn){
	for(int ai=1;;++ai){
		static int qwq,nx;
		nx=y+2*ai*x;
		qwq=max(ai+1,mn);
		if(nx>m||x+2*qwq*nx>n) break;
		dfs1(nx,x,qwq);
	}
	dfs2(2*x,y,0,x,mn);
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	if(n<m) swap(n,m);
	dfs1(1,0,1);
	cout<<ans;
	return 0;
}
```

---


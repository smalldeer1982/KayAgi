# [NOI2024] 树形图

## 题目背景

由于评测机性能差异，本题时限翻倍。

## 题目描述

给定一个 $n$ 个点 $m$ 条边的**简单有向图** $G$，顶点从 $1$ 到 $n$ 编号。其中简单有向图的定义为**不存在重边与自环**的有向图。

定义顶点 $r$ 是有向图 $G$ 的根当且仅当对于 $1\leq k\leq n$，顶点 $r$ 到顶点 $k$ 存在恰好一条**有向简单路径**，其中简单路径的定义为**不经过重复点的路径**。

定义每个点的种类如下：
- 若顶点 $r$ 是图 $G$ 的根，则称顶点 $r$ 为图 $G$ 的**一类点**。
- 若顶点 $r$ 不是图 $G$ 的一类点，且存在一种删边的方案，使得图 $G$ 在删去若干条边后得到的图 $G'$ 满足：所有图 $G$ 中的一类点都是 $G'$ 的根，且顶点 $r$ 也是图 $G'$ 的根，则称顶点 $r$ 为图 $G$ 的**二类点**。
- 若顶点 $r$ 不满足上述条件，则称顶点 $r$ 为图 $G$ 的**三类点**。

根据上述定义，图 $G$ 的每个点都恰好属于一类点，二类点，三类点之一。你需要判断点 $1\sim n$ 分别属于这三个种类中的哪一种。

## 说明/提示

**【样例 1 解释】**

样例 $1$ 共包含两组测试数据。

对于第一组测试数据，输入的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/yorwc4dr.png)

由于 $1,3,4$ 均不存在到达 $2$ 的路径，因此 $1,3,4$ 均为三类点。由于 $2$ 到 $1$ 的有向简单路径共有三条：$2\to 1$，$2\to 4\to 1$，$2\to 3\to 4\to 1$，因此 $2$ 不是一类点。删去边 $1\to 4$，$4\to 1$，$3\to 4$，$4\to 3$ 后，$2$ 到 $1,3,4$ 的有向简单路径均唯一，因此 $2$ 是图 $G'$ 的根，即 $2$ 是二类点。

对于第二组测试数据，输入的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/t8r9veu2.png)

容易发现 $3,4$ 均为一类点，删去边 $2\to 3$ 后，每个点到其他所有点的有向简单路径均唯一，因此 $1,2$ 均为二类点。

**【数据范围】**

对于所有测试数据保证：$1\leq t\leq 10$，$2\leq n\leq 10^5$，$1\leq m\leq 2\times 10^5$，且图 $G$ 不存在重边与自环。

::cute-table{tuack}

| 测试点编号 | $t\leq$ | $n\leq$ | $m\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $10$ | $20$ | 无 |
| $2$ | $10$ | $10^3$ | $2000$ | A |
| $3,4$ | ^ | ^ | ^ | B |
| $5,6$ | ^ | ^ | ^ | 无 |
| $7$ | ^ | $10^5$ | $2\times 10^5$ | A |
| $8,9$ | ^ | ^ | ^ | BC |
| $10\sim 13$ | ^ | ^ | ^ | B |
| $14,15$ | ^ | ^| ^ | C |
| $16\sim 20$ | ^ | ^ | ^ | 无 |

- 特殊性质 A：保证不存在一类点。
- 特殊性质 B：保证不存在二类点。
- 特殊性质 C：保证编号为 $1$ 的点为图 $G$ 的一类点。

## 样例 #1

### 输入

```
0
2
4 7
2 1
4 1
1 4
2 3
3 4
2 4
4 3
4 5
1 2
2 3
2 4
3 1
4 3```

### 输出

```
3233
2211```

## 样例 #2

### 输入

```
见 graphee2.in/ans
这个样例满足测试点 2 的约束条件```

### 输出

```
```

## 样例 #3

### 输入

```
见 graphee3.in/ans
这个样例满足测试点 3,4 的约束条件```

### 输出

```
```

## 样例 #4

### 输入

```
见 graphee4.in/ans
这个样例满足测试点 5,6 的约束条件```

### 输出

```
```

## 样例 #5

### 输入

```
见 graphee5.in/ans
这个样例满足测试点 8,9 的约束条件```

### 输出

```
```

## 样例 #6

### 输入

```
见 graphee6.in/ans
这个样例满足测试点 14,15 的约束条件```

### 输出

```
```

# 题解

## 作者：Rainbow_qwq (赞：18)

### D2T3 树形图

首先判掉一些 case：先 tarjan 一遍求出强连通分量，找到一个能到达所有点的强连通分量（也可能找不到），那么 $1,2$ 类点只可能在这个强连通分量中。

若其中没有 $1$ 类点，则强连通分量内所有点都为 $2$ 类点。

$1$ 类点的性质是：将任意一个 $1$ 类点定为根，求出一棵 dfs 树，则图上的非树边只有返祖边，没有横叉边。

### 求出 $1$ 类点

以任意一个 $1$ 类点定为根，求出一棵 dfs 树。考虑在这棵 dfs 树的基础上求出所有 $1$ 类点：

考虑 $fa_u\to u$ 这条边被几条返祖边覆盖了，由于这是一个强连通分量，所以子树中至少有一条返祖边覆盖 $fa_u\to u$。

若有 $\ge 2$ 条返祖边覆盖了 $fa_u\to u$，则 $u\to fa_u$ 有至少两种方案能走到，$u$ 必然不为 $1$ 类点。

若只有 $1$ 条返祖边覆盖了 $fa_u\to u$，设这条边为 $x\to y$，则 $u$ 子树中的点向上走必然要走到 $y$，$u$ 是否为 $1$ 类点等价于 $y$ 是否为 $1$ 类点。于是可以从上到下递推出所有 $1$ 类点。

### 求出 $2$ 类点

仍然在这棵 dfs 树的基础上求出 $2$ 类点。

如果一个 $u$ 为 $1$ 类点，那么一定有恰好一条返祖边 $x\to y$ 覆盖了 $fa_u\to u$，并且这条返祖边**不能删除**，否则 $x$ 的子树就会脱离这个强连通分量，从而不再是 $1$ 类点。

于是我们得到了若干条返祖边不能删除的限制。

假设我们想判定 $u$，也就是删去若干条边把 $u$ 变为 $1$ 类点，则我们想删去覆盖了 $fa_u\to u$ 的若干条返祖边，使得只剩下一条 $(x,y)$ 覆盖了 $fa_u\to u$，并且 $y$ 也是 $1/2$ 类点，那么 $u$ 就可以成为 $2$ 类点了。

对于一个点 $u$，仍然考虑 $u\to fa_u$ 这条边：

若被两条不能删除的返祖边覆盖，则 $u$ 一定不可行。

若被一条不能删除的返祖边覆盖：设这条边为 $x\to y$，则 $u$ 是否为 $2$ 类点等价于 $y$ 是否为 $1/2$ 类点。

若被零条不能删除的返祖边覆盖：那么 $u$ 子树中有若干条**能删除**的返祖边。若能找到一条能删除的返祖边 $x\to y$，使得 $y$ 为 $1/2$ 类点，则 $u$ 就可以为 $2$ 类点。

### 如何找一个 $1$ 类点

考虑以 $1$ 类点为根构成的 dfs 树的性质。观察其叶子，由于没有横叉边，所有叶子必然满足入度为 $1$。

对于所有入度为 $1$ 的点 $u$，假设有边 $v\to u$，则可以把 $u$ 向 $v$ 合并。具体来说，把 $u$ 的出边并到 $v$ 的出边里（所有 $u\to x$ 改为 $v\to x$，**不需要去除重边**，但要删去自环），然后删除点 $u$。也就是在 dfs 树上不断缩叶子的过程。

BFS 不断执行这个过程，并把新出现的入度为 $1$ 的点加入队列里。

在若干轮删除之后，若只剩下 $1$ 个点，则这个点即可作为 $1$ 类点；否则若某个时刻每个点入度都 $\ge 2$，则不存在 $1$ 类点。

使用启发式合并维护边集，时间复杂度 $O((n+m)\log n)$。

可以用 vector 存下每个点的入边和出边，合并时按两个 size 的和加权，取更小的点的所有边合并到大的点上，这样在合并时就可以计算有多少条 $u-v$ 的边。

---

## 作者：DaiRuiChen007 (赞：4)

[Problem Link](https://www.luogu.com.cn/problem/P10790)

**题目大意**

> 给定 $n$ 个点 $m$ 条边的有向图。
>
> - 一个点 $u$ 为一类点：当且仅当 $u$ 到其他的每个点的简单路径都唯一。
> - 一个点 $u$ 为二类点：删去若干条边后，$u$ 是一类点，且原有的一类点依然是一类点。
>
> 否则一个点是三类点判定每个点是哪类点。
>
> 数据范围：$n\le 10^5,m\le 2\times 10^5$。

**思路分析**

首先进行缩点，一类点必须是没有入度的 SCC，如果这样的 SCC 不唯一，则所有点为三类点。

否则只需要考虑该 SCC，即考虑图强连通的情况，如果一类点不存在，那么所有点都是二类点。

然后考虑如何判定一个点是一类点：首先建立 dfs 树，如果有横叉边，则一定不为一类点。

否则 dfs 树上只有返祖边，可以归纳证明这样的点一定是一类点。

假设我们找到了一个一类点，考虑求出所有一类点：

考虑每个点被多少条返祖边覆盖，由于图强连通，那么覆盖次数 $\ge 1$。

如果一个点被 $>1$ 条返祖边覆盖，那么走到其父亲的路径不唯一。

否则设该返祖边为 $x\to y$，则 $u$ 为一类点当且仅当 $y$ 为一类点，从上到下递推即可。

然后尝试判断哪些点是二类点：

首先我们要知道哪些边可以删除：首先 dfs 树上的边删除后根的连通性改变，肯定不能删除。

其次一条返祖边 $x\to y$ 如果经过了一个一类点，那么删除后这个点不再是一类点，不能删除。

而其他边都能删除，我们的目标就是要删除若干条可以删除的返祖边，使得剩余的返祖边 $x\to y$ 唯一，且 $y$ 是二类点。

先判断经过每个点的不可删除的返祖边是否 $>1$ 条，然后在 dfs 过程中动态维护维护每个点子树中是否有这样的 $x$，用树状数组实现即可。

最后我们要找到一个合法的一类点作为根：

考虑其叶子，由于没有横叉边，因此每个叶子的入度为 $1$，那么对于每个叶子 $u$，把 $u$ 向其唯一入点合并（去处自环，不删除重边）。

实际上这就是在 dfs 树上不断缩叶子的过程中，最后停止的时候图上一定只剩唯一节点，这就是一个合法的根，否则说明不存在一类点。

用启发式合并维护该过程。

时间复杂度 $\mathcal O(m\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
int n,m;
vector <int> G[MAXN];
int dsu[MAXN];
int find(int x) { return x^dsu[x]?dsu[x]=find(dsu[x]):x; }
struct FenwickTree {
	int tr[MAXN],s;
	void init() { memset(tr,0,sizeof(tr)); }
	void add(int x) { for(;x<=n;x+=x&-x) ++tr[x]; }
	int qry(int x) { for(s=0;x;x&=x-1) s+=tr[x]; return s; }
}	TR;
int dfn[MAXN],low[MAXN],dcnt,stk[MAXN],tp,col[MAXN],scnt;
bool ins[MAXN],ind[MAXN],inq[MAXN],vis[MAXN];
void tarjan(int u) {
	dfn[u]=low[u]=++dcnt,ins[stk[++tp]=u]=true;
	for(int v:G[u]) {
		if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);
		else if(ins[v]) low[u]=min(low[u],low[v]);
	}
	if(dfn[u]==low[u]) {
		++scnt;
		while(ins[u]) col[stk[tp]]=scnt,ins[stk[tp--]]=false;
	}
}
int deg[MAXN];
vector <int> in[MAXN];
unordered_map <int,int> S[MAXN];
bool chk(int u) {
	memset(ins,0,sizeof(ins));
	memset(vis,0,sizeof(vis));
	bool ok=1;
	function<void(int)> dfs=[&](int x) {
		vis[x]=ins[x]=true;
		for(int y:G[x]) {
			if(!vis[y]) dfs(y);
			else ok&=ins[y];
		}
		ins[x]=false;
	};
	dfs(u);
	for(int i=1;i<=n;++i) ok&=vis[i];
	return ok;
}
int getrt() {
	for(int i=1;i<=n;++i) dsu[i]=i;
	for(int i=1;i<=n;++i) for(int j:G[i]) {
		++S[i][j],in[j].push_back(i),++deg[j];
	}
	for(int i=1;i<=n;++i) if(!deg[i]) return chk(i)?i:0;
	queue <int> Q;
	for(int i=1;i<=n;++i) if(deg[i]==1) Q.push(i);
	while(Q.size()) {
		int x=0,y=Q.front(); Q.pop();
		if(deg[y]!=1||dsu[y]!=y) continue;
		for(int k:in[y]) if(find(k)!=y) {
			x=find(k); break;
		}
		S[x].erase(y);
		auto it=S[y].find(x);
		if(it!=S[y].end()) {
			deg[x]-=it->second,S[y].erase(it);
			if(deg[x]==1) Q.push(x);
		}
		if(S[x].size()<S[y].size()) swap(S[x],S[y]);
		for(auto e:S[y]) if(e.second) S[x][e.first]+=e.second;
		dsu[y]=x;
	}
	for(int i=1;i<=n;++i) if(dsu[i]==i) return chk(i)?i:0;
	return 0;
}
int fa[MAXN],L[MAXN],R[MAXN],k,x[MAXN<<1],y[MAXN<<1];
int dep[MAXN],cov[MAXN],del[MAXN];
vector <int> E[MAXN],T[MAXN];
void dfs0(int u) {
	vis[u]=true,L[u]=++dcnt;
	for(int v:G[u]) if(inq[v]) {
		if(!vis[v]) fa[v]=u,dep[v]=dep[u]+1,T[u].push_back(v),dfs0(v);
		else ++k,x[k]=u,y[k]=v,E[v].push_back(u);
	}
	R[u]=dcnt;
}
bool f[MAXN],g[MAXN],rsv[MAXN];
void dfs1(int u) {
	if(cov[u]>0&&f[y[cov[u]]]) f[u]=g[u]=true,rsv[cov[u]]=true;
	for(int v:T[u]) dfs1(v);
}
void dfs2(int u) {
	if(~del[u]) {
		if(del[u]) g[u]|=g[y[del[u]]];
		else g[u]|=(TR.qry(R[u])>TR.qry(L[u]-1));
	}
	if(g[u]) for(int v:E[u]) TR.add(L[v]);
	for(int v:T[u]) dfs2(v);
}
void solve() {
	cin>>n>>m;
	for(int i=1;i<=n;++i) {
		G[i].clear(),E[i].clear(),T[i].clear();
		S[i].clear(),in[i].clear();
		dfn[i]=low[i]=cov[i]=del[i]=deg[i]=0;
		ins[i]=ind[i]=f[i]=g[i]=0;
	}
	dcnt=scnt=tp=0;
	for(int i=1,u,v;i<=m;++i) cin>>u>>v,G[u].push_back(v);
	for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);
	int id=0;
	for(int i=1;i<=n;++i) for(int j:G[i]) if(col[i]^col[j]) ind[col[j]]=true;
	for(int i=1;i<=scnt;++i) if(!ind[i]) id=(!id?i:-1);
	if(id<=0) {
		for(int i=1;i<=n;++i) cout<<"3"; cout<<"\n";
		return ;
	}
	for(int i=1;i<=n;++i) inq[i]=(col[i]==id);
	int rt=getrt();
	if(!rt) {
		for(int i=1;i<=n;++i) cout<<"32"[inq[i]]; cout<<"\n";
		return ;
	}
	memset(vis,0,sizeof(vis));
	memset(rsv,0,sizeof(rsv));
	dcnt=k=0,dep[rt]=0,dfs0(rt);
	for(int i=1;i<=n;++i) dsu[i]=i;
	for(int e=1;e<=k;++e) {
		for(int u=find(x[e]);dep[u]>dep[y[e]];u=find(fa[u])) {
			if(!cov[u]) cov[u]=e;
			else cov[u]=-1,dsu[u]=find(fa[u]);
		}
	}
	f[rt]=g[rt]=true;
	for(int u:T[rt]) dfs1(u);
	for(int i=1;i<=n;++i) dsu[i]=i;
	for(int e=1;e<=k;++e) if(rsv[e]) {
		for(int u=find(x[e]);dep[u]>dep[y[e]];u=find(fa[u])) {
			if(!del[u]) del[u]=e;
			else del[u]=-1,dsu[u]=find(fa[u]);
		}
	}
	TR.init();
	for(int u:E[rt]) TR.add(L[u]);
	for(int u:T[rt]) dfs2(u);
	for(int i=1;i<=n;++i) {
		if(inq[i]) cout<<"321"[f[i]+g[i]];
		else cout<<"3";
	}
	cout<<"\n";
}
signed main() {
	ios::sync_with_stdio(false);
	int id,cas;
	cin>>id>>cas;
	while(cas--) solve();
	return 0;
}
```

---

## 作者：bunH2O (赞：3)

给定一张简单有向图 $G$，定义 $u$ 为 $G$ 的根当且仅当 $u$ 到 $G$ 中的所有点都有且只有一条简单路径。

我们将 $G$ 中的点划分为三类：

- 若 $u$ 为 $G$ 的根，则 $u$ 为一类点。
- 若 $u$ 不为 $G$ 的根，但存在 $G$ 的生成子图 $G'$ 满足 $u$ 和 $G$ 的所有一类点均是 $G'$ 的根，则 $u$ 为二类点。
- 若 $u$ 既不为一类点又不为二类点，则 $u$ 为三类点。

对 $G$ 中的每个点求出其类别。

$1\leq n\leq 10^5,1\leq m\leq 2\times 10^5,1\leq T\leq 10$。

---

### 特殊性质 BC

以 $1$ 为根建出 dfs 树，考虑一类点的定义，“到所有点都有且仅有一条简单路径”。因此不难发现前向边和横叉边都是不能存在的，**图中被允许存在的仅有树边和返祖边**。

考虑根据上述性质求出其他的一类点。我们考虑一个点 $u$，显然 $u$ 走到 $u$ 子树内的点只有一种方案；对于 $u$ 子树外的点，$u$ 显然要从返祖边走出去。一但 $u$ 子树内通向子树外的返祖边有超过一条，那么 $u$ 就有至少两种选择。不难发现 $u$ 到 $fa_u$ 有至少两种方案（其中 $fa_u$ 表示 $u$ 的父亲）。因此 $u$ 子树内向外的返祖边需要**有且仅有**一条。

我们考虑这条返祖边通向的节点，他应该是 $u$ 的一个祖先，设为 $v$。那么 $u$ 到$v$ 子树内的所有点就只有一种方案到达了。对于 $v$ 子树外的点，由于 $u$ 到达这些点必须经过 $v$，而 $v$ 到这些点显然不会经过 $u$，因此 $u$ 到这些点合法当且仅当 $v$ 到这些点合法。综上所述可得，**$u$ 是一类点当且仅当 $v$ 是一类点**。

由此我们就得到了找出所有一类点的方法：以一个一类点为根建出 dfs 树，对每个点求出从子树内连出到子树外的边数。若 $\neq 1$ 则不为一类点，否则记这条边指向的点为 $v$，则有 $u$ 为一类点当且仅当 $v$ 为一类点。

---

### 特殊性质 C

在上段中我们给出了一种找一类点的方法，我们承接上述内容，求所有二类点。

考虑二类点的定义：**不是图 $G$ 的一类点，且存在一种删边的方案，使得图 $G$ 在删去若干条边后得到的图 $G'$ 满足：所有图 $G$ 中的一类点都是 $G'$ 的根，且顶点 $r$ 也是图 $G'$的根。**

该段定义共有两条限制：“所有图 $G$ 中的一类点都是 $G'$ 的根”以及“顶点 $r$ 也是图 $G'$的根”。优先考虑第一条限制，注意到根的定义为“到所有点都有且仅有一条简单路径的节点”，显然路径只会越删越少而不会越删越多，而一类点到所有点都只有一条路径，因此这一条限制等价于所有一类点到其他点的路径都要被保留。注意在求一类点的过程中我们也同步求出了其到其他点的路径。因此该段是容易处理的。

现在我们来处理第二条限制，记所有必须保留的边构成的图为 $G_0$，我们可以往 $G_0$ 中添加一些边，对每个点求出其是否可能成为一类点。仿照求一类点做法，我们以 $1$ 为根建出 $G_0$ 的 dfs 树，对每个非一类点 $u$ 求出从子树内连出到子树外的边数。若边数 $\geq 2$ 则已经有多于一条到 $fa_u$ 的路径，不为二类点。若边数 $=1$，由于 $G_0$ 中所有返祖边指向的点均为一类点，故 $u$ 在 $G_0$ 中已经为根，必然为二类点。若边数 $=0$，则需要添加一条子树内到子树外的返祖边，记所有满足该限制的边可能指向的点构成的集合为 $S$。仿照一类点求法证明可得，$u$ 是二类点当且仅当 $S$ 中存在一类点或二类点。

由此我们就得到了找出所有二类点的方法：在求出所有一类点后，保留所有树边和一类点从子树内向子树外的返祖边。对每个非一类点求出从子树内连出到子树外的边数。若 $> 1$ 则不为二类点，若 $=1$ 则为二类点，否则考虑这个点子树内到子树外的所有边指向的集合 $S$，则有 $u$ 为二类点当且仅当 $S$ 中存在点为一/二类点。

---

### 特殊性质 A

接下来考虑一种特殊的情况，我们找不到任何一个一类点。在这种情况下，一个点是二类点当且仅当这个点能到达所有点。考虑给整张图缩点，如果只有一个入度为零的 SCC，那么当且仅当在该 SCC 内的所有点为二类点，否则没有二类点。

---

### 正解

综合以上内容，我们只差最后一步：找到一个一类点或报告不存在。

注意到 $G$ 只应当有树边和返祖边，满足叶子的入度均为 $1$ 且只会指向其祖先。考虑对 $G$ 进行剥叶子。定义一个点是叶子当且仅当其入度为 $1$，定义该叶子的父亲为其唯一入度的来源。我们每次删去一个叶子，将该叶子的所有出边挂到其父亲上，随后保留重边但是消去自环。不难发现一次操作后一类点的存在性不发生改变。我们重复此流程直到不能操作为止。若剩余节点 $\geq 2$ 则不存在一类点，否则剩下的点必然为一类点。

由上我们便解决了本题，时间复杂度 $\Omicron(n)$。

---

## 作者：strcmp (赞：2)

> 何时才能 知晓自己也是美丽的呢

NOI2024 补的最后一道题，也是思维难度相当大的一道题，代码难度也不低。

### 题目大意 

给定简单有向图 $G = (V,\,E)$，对于 $\forall u \in V$ 进行分类：

- $u$ 是**一类点**：则 $u$ 到所有其它结点都恰好有一条简单路径。

- $u$ 是**二类点**：可以通过删边使得 $u$ 成为一类点，并且没有一类点在删边后失去一类点的特性。

- $u$ 是**三类点**：$u$ 不是一类点且不是二类点。

---

首先是暴力二进制枚举判定，期望得分 $5$，对于本题做法无提示作用。

接下来我们默认有向图 $G$ 弱连通，否则所有点均为三类点。

首先注意到一类点和二类点之间是两两可以互相到达的，符合 SCC 的定义，所以它们肯定都在一个 SCC 中；另一方面，它们能到达所有其它结点，因此它们一定是 SCC 构成的 DAG 中唯一一个入度为 $0$ 的 SCC（如果有多个入度为 $0$ 的 SCC，那么所有结点都是三类点）。

我们不妨把唯一一个入度为 $0$ 的 SCC 称为『根 SCC』。

首先根 SCC 外的结点都是三类点，这点是很显然的，它们无法到达根 SCC 中的任何一个结点。

- 现在我们可以直接秒掉 A 性质了，如果不存在一类点，那么根 SCC 的所有点均为二类点（没有一类点来牵制我们，于是我们可以直接构造叶向树形图），时间复杂度 $\Theta(n + m)$，期望得分 $10$。

接下来来考虑性质 B，我们肯定要知道怎么判断 $1$ 类点。

我们的条件只是不能存在两条以上简单路径，而存在多条只能经过重复结点的路径是可以被允许的。直接考虑有向图根本想象不出来怎么做，我们不妨考虑“根”出发的 DFS 树，想象在它上面从根开始找到 $u$ 简单路径的过程。

如果我们走了一个横叉边找到简单路径，那么首先我们树边就可以到达 $u$，那么一定出现了第二条简单路径，$u$ 必然不是一类点。

另一方面，我们如果不走横叉边，寻找 $u$ 的过程中是不会走返祖边的，因为我们走返祖边必然会经过重复结点，此时我们只能走树边，自然而然只有一条**简单**路径。

- 也就是说，返祖边不会对根是否是一类点产生影响，而一旦存在横叉边那么根一定不是一类点。于是我们只需要在 DFS 树上判断是否存在横叉边，即可判断根是否是 $1$ 类点。

接下来我们有两个待解决的问题，一个是一类点存在的情况下二类点的形态，另一个是优化
我们判断的复杂度。

不妨先优化我们判断一类点的复杂度，首先**如果已知一个一类点**，考虑从它开始建立 DFS 树，首先一类点为根的 DFS 树只有返祖边，我们考虑在这棵树里面想要有与所有其它结点唯一的简单路径，需要满足什么条件。

- 对于树边 $fa_v \to v$，不能被返祖边所代表的路径覆盖两次及以上，否则我们可以通过 $v$ 走两条不同的返祖边到 $fa_v$，走出 $v$ 到 $fa_v$ 的两个简单路径。

根据这个结论，如果 $u$ 要是一类点，则覆盖 $fa_u \to u$ 的返祖边至多只有一个，于是我们可以跳这个唯一的返祖边（假设它是 $u \leadsto x \to y$，$x$ 在 $u$ 子树中），并且断言 $u$ 是一类点当且仅当 $y$ 是一类点。 

看起来有向 DFS 树，且没有横叉边这个性质无敌好，可以继续考虑二类点在 DFS 树上是怎么样的。

根据定义，二类点就是删边之后，我们的所有一类点仍然是一类点，而它变成一类点。

仿照求一类点的方法，我们递推来求出二类点，下面假设要判断的点都已经被判断为不是一类点。

首先不可能删树边，然后有一些返祖边也不能删，不能删的返祖边就是对于我们已经求出的一类点来说 唯一覆盖它的返祖边。其余的返祖边都是可以删的。

- 如果没有不可删返祖边覆盖 $fa_u \to u$，则我们在 $u$ 子树中找返祖边（反正对于 $u$ 来说都是可删返祖边），使得该返祖边到达的点是一类点或者二类点，那么 $u$ 就是二类点。

- 如果恰好一条不可删返祖边覆盖 $fa_u \to u$，那么就只能走这条不可删返祖边。

- 注意以上默认删去了所有无关的覆盖 $fa_u \to u$ 的可删返祖边。

- 如果有两条以上的不可删返祖边覆盖 $fa_u \to u$，则 $u$ 完全不可能成为一类点，可以直接断言 $u$ 是三类点。

现在我们已经有了 $\Theta(nm)$ 的做法，瓶颈在于最开始寻找一个一类点。结合 A 性质，C 性质，期望得分 $55$。

- 怎么在最开始找到一个一类点？

这个问题事实上并不简单，对于 $\Theta(n + m)$ 的目标复杂度来说更是困难，我们可以做线性对数的复杂度。

现在考虑广义串并联图方法。

- 若当图 $G,\,|V| > 1$ 存在一类点，则一定存在一个点入度为 $1$。

我们直接把那个一类点拿出来，以它为根的 DFS 树的叶子结点必须入度为 $1$，不然根一定不是一类点。而且任意时刻我们删除了一个叶子结点，那么新产生的叶子结点也必然满足这个特性，因为我们只有返祖边而没有横叉边。那么直接拓扑排序就行！

如果你大喜过望直接写了个拓扑上去大概率会当场爆炸。

原因是因为我们的做法还有问题没有解决：

- 我们删点之后得到的根一定是原图的根吗？

很显然不一定，我们如果直接删点，那么是有可能把一些不应该成为一类点的点，错判为一类点的，所以我们需要在删点的同时保留被删点的出边，合并到唯一连向它的点上。这是集合的合并，可以用任意方法来做。

最后将原图删成一个点，我们就认定唯一的那个点就是一个合法的一类点。

- 如果可能的一类点都是一度点，我们把一度点合并掉了，找不到一类点来当根了怎么办？

我们假设根是一度点 $t$，根据一类点的定义，我们可以从 $t$ 开始走到 $t$ 唯一入边对应的结点 $p$，并且 $t \leadsto p$ 有且只有一条简单路径。于是 $p \to u$ 和 $u \leadsto p$ 构成了一个简单环。我们找出 $t$ 在这个简单环上的后继 $s$，首先 $s$ 一定是一类点（环内的点就走环，环外的点先走到 $u$ 然后就随便走了，由于 $u$ 是一类点，显然上述路径都是唯一的）。

那么只有两种情况。

1. $s$ 不是一度点，此时我们就找到了一个合法的不会被删除的根。

2. $s$ 是一度点，这时候我们继续在环上走下去，直到 $1$ 情况出现，或者我们走一圈走回 $t$ 了。如果我们最后走回了 $t$，我们得到这个简单环上的每个点都是一类点，我们直接把这个环缩在一起。根据一类点性质，缩完环之后，我们从环开始跑 DFS 树，这个 DFS 树也还是没有横叉边！注意环上结点 $u$ 的某一子树内是**不会存在**连向除了 $u$ 之外的环上结点的，否则原图没有一类点，同理环自己内部不存在额外边。

我们的有向图就会是这样一个非常色的结构：

![](https://cdn.luogu.com.cn/upload/image_hosting/2yhpi3cl.png)

如果我们在上面缩一度点，环完全可以等价看作一个一类点，于是我们可以通过缩一度点找到一类点。

时间复杂度 $\Theta((n + m) \log n)$，瓶颈在于集合合并。

---

接下来考虑代码实现问题。

首先求强连通分量是必须的，我们得留个后手防止不存在一类点，这时候根 SCC 就全是二类点。

至于判断一类点是否存在，就是找根的过程，找根就是不断合并一类点。

不过接下来我们要考虑合并过程中产生的重边和自环的问题，谁需要保留谁需要删。

注意到重边需要保留（否则无法区分横叉边和树边），而自环需要删除（否则合并在我们缩完点后无法继续）。

这点我们可以在每个点维护一个出边到达的点的可重集合，需要做集合的单点插入和删除，并且维护所有入度为 $1$ 的点搞一个类似拓扑排序的玩意。

集合的合并可以写线段树合并。

然后就是一二类点的递推。

对于一类点的递推来说，我们维护覆盖 $fa_u \to u$ 的唯一返祖边是什么，这点可以简单树上差分维护，此时 $u$ 的一类点状态就跟这个返祖边指向的点的一类点状态相同。

如果 $u$ 是一类点，我们还要记录这条唯一的返祖边，标记为不可删返祖边。

接下来考虑二类点们，根据我们的结论，如果两条以上不可删返祖边覆盖 $fa_v \to v$，那么 $v$ 只能是三类点。如果恰好一条不可删返祖边覆盖 $fa_v \to v$，我们只能走这条返祖边，那么 $v$ 可以类似一类点来递推。

否则没有不可删返祖边覆盖 $fa_v \to v$，我们也可以用个树上差分，维护覆盖了 $fa_v \to v$ 的可删返祖边集合，对于这些可删返祖边集合，我们维护它们终点的一类点和二类点个数，就可以简单 check 了。

时间复杂度 $\Theta((n + m) \log n)$，实际上对寻找第一个类点的过程精细分析可以有一个 $\Theta(n + m)$ 的做法，不过较为复杂。

- 总结一下这题的难点吧

想到一类点和二类点都在根 SCC 内，这点是很显然的，毕竟弱化一类点的条件，那么至少它们之间是两两有路径的，而这正是 SCC 的定义。所以 A 性质应当是不难想到的。

首先第一个难点是找到判断一类点的好的充要条件，也就是以该点为根的 dfs 树没有横叉边。这点需要不少的注意力和经验，对于连通性问题考虑 dfs 生成树一般是不劣的想法，而且这个恰好只有一条简单路径更让我们想到树的性质，类比推理大概可以想到。

第二个难点是怎么优化复杂度，你很可能直接考虑到处碰壁，都是因为无法处理横叉边，那如果我们只有返祖边你会发现问题好考虑了很多，这点就是基于我们之前得到的判断方法来做的。如果我们能先找到一个一类点当根，剩下的问题对于 NOI 级别的选手来说，是完全在能力范围内可以做到的。

个人认为最大的难点是怎么寻找第一个一类点，能注意到缩一度点这个问题是真的很不简单，至少是需要很多题目的历练和一些奇思妙想的，这应该也是这题在场上场切极少的原因之一（其实主要原因应该是~~大家都去做登山了~~）。


以下是参考代码，关键部分会有注释，当然由于是宿舍床上着急写的，所以可能有不少优化空间。

```cpp
int T, n, m, dfn[maxn], low[maxn], dct, st[maxn], tp, vis[maxn], scc[maxn], N, ans[maxn], Q[maxn], rd[maxn], pa[maxn], id[maxn], c[3][maxn], hd, tl, RT;
vec<int> g[maxn], rg[maxn], h[maxn], r[maxn]; 
inline void add(int o, int x, int d) { while (x <= n) c[o][x] += d, x += x & -x; }
inline int qsum(int o, int x) { int s = 0; while (x) s += c[o][x], x -= x & -x; return s; }
struct Node { int l, r, v; } t[maxn * 20]; int rt[maxn], tot;
#define ls(x) (t[x].l)
#define rs(x) (t[x].r)
#define w(x) (t[x].v)
void mdf(int l, int r, int v, int p, int& x) {
	if (!x) x = ++tot; w(x) += p; if (l == r) return;
	v <= mid ? mdf(l, mid, v, p, ls(x)) : mdf(mid + 1, r, v, p, rs(x));
}
int qry(int l, int r, int v, int x) {
	if (!x) return 0; if (l == r) { int k = w(x); w(x) = 0; return k; }
	return v <= mid ? qry(l, mid, v, ls(x)) : qry(mid + 1, r, v, rs(x));
}
void mg(int& x, int& y) {
	if (!w(x) || !w(y)) return void(x |= y);
	else w(x) += w(y), mg(ls(x), ls(y)), mg(rs(x), rs(y));
}
void tj(int u) {
	dfn[u] = low[u] = ++dct; vis[st[++tp] = u] = 1;
	for (int v : g[u]) {
		if (!dfn[v]) tj(v), low[u] = min(low[u], low[v]);
		else if (vis[v]) low[u] = min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]) {
		++N;
		do scc[st[tp]] = N, vis[st[tp]] = 0; while (st[tp--] != u);
	}
}
int fd(int x) { return pa[x] == x ? x : pa[x] = fd(pa[x]); }
int getrt() {
	hd = 1, tl = 0;
	rep(i, 1, n) {
		if (rd[i] == 1) Q[++tl] = i;
		for (int v : g[i]) mdf(1, n, v, 1, rt[i]);
	}
	// 合并是对于 u -> v 将 v 保留出边合并到 u 上
	while (hd <= tl) {
		int v = Q[hd++], u = 0;
		if (pa[v] != v || rd[v] != 1) continue;
		for (int x : rg[v]) if (v != fd(x)) { u = fd(x); break; }
		qry(1, n, v, rt[u]);
		int k = qry(1, n, u, rt[v]);
		if (k && (rd[u] -= k) == 1) Q[++tl] = u;
		mg(rt[u], rt[v]); pa[v] = RT = u;
	}
	//cout << RT << "\n"; exit(0);
	if (tl < n - 1) return -1;
	else return RT;
}
int fr[maxn], to[maxn], sz[maxn], p; // 标号为 i 的返祖边是什么
void prework(int u, int f) {
	// 先建立以 RT 为根的 DFS 树
	dfn[u] = ++dct; sz[u] = 1;
	for (int v : g[u]) {
		if (!dfn[v]) h[u].pb(v), prework(v, u), sz[u] += sz[v];
		else {
			// 否则 u -> v 是一个返祖边，给它一个标号
			++p; fr[p] = u, to[p] = v; r[v].pb(p);
			add(0, dfn[u], 1), add(0, dfn[v], -1);
			add(1, dfn[u], p); add(1, dfn[v], -p);
			// 转到子树树上差分，接下来我们要做的就是区分可删返祖边和不可删返祖边
		}
	}
}
int FC_, GC_, FS_, ndl[maxn];  //
inline ll SUM(int o, int u) { return qsum(o, dfn[u] + sz[u] - 1) - qsum(o, dfn[u] - 1); }
void dfs1(int u) {
	// 求出所有一类点和不可删返祖边
	// 一个点 u 是一类点，当且仅当 u = RT 或 fa[u] \to u 被恰好一条返祖边覆盖，该返祖边指向的点是一类点
	// dfs1 的时候 FC_ 是当前覆盖 fa[u] \to u 的返祖边数量，FS_ 是根据差分结果得到的唯一的返祖边编号
	FC_ = SUM(0, u), FS_ = SUM(1, u);
	//if (u == 1) cout << FC_ << " " << FS_ << "\n";
	if (FC_ == 1 && ans[to[FS_]] == 1) ans[u] = 1, ndl[FS_] = 1;
	for (int v : h[u]) dfs1(v);
}
void prework_2() {
	rep(i, 1, p) {
		if (ndl[i]) {
			int u = fr[i], v = to[i];
			add(0, dfn[u], 1), add(0, dfn[v], -1);
			add(1, dfn[u], i), add(1, dfn[v], -i);
		}
	}
}
void dfs2(int u) {
	// 求出所有二类点和可删返祖边
	// 具体来说我们要求出 fa[u] \to u 被多少条不可删返祖边覆盖，这也是树上差分，如果没有被不可删返祖边覆盖，则根据我们维护的可删返祖边情况判断 u 的类型
	// 我们维护经过 fa[u] \to u 有多少个可删返祖边终点是一类点或二类点
	// 一次 dfs，两个树上差分，三个树状数组
	FC_ = SUM(0, u), FS_ = SUM(1, u), GC_ = SUM(2, u);
	if (!ans[u]) {
		//if (u == 3) cout << FC_ << " " << FS_ << " " << GC_ << "\n";
		// 判定 u 是否是二类点
		if (FC_ >= 2) ans[u] = 3;
		else if (FC_ == 1) ans[u] = (ans[to[FS_]] != 3 ? 2 : 3); // 看唯一不可删返祖边指向的点，当然我们已经排除 u 是一类点了
		else ans[u] = (GC_ > 0 ? 2 : 3);
	}
	if (ans[u] == 1 || ans[u] == 2) for (int y : r[u]) if (!ndl[y]) add(2, dfn[fr[y]], 1), add(2, dfn[u], -1);
	for (int v : h[u]) dfs2(v);
}
void clear() {
	rep(i, 1, n) rd[i] = ans[i] = dfn[i] = low[i] = st[i] = vis[i] = scc[i] = rd[i] = rt[i] = id[i] = c[0][i] = c[1][i] = c[2][i] = sz[i] = ndl[i] = 0, g[i].clear(), rg[i].clear(), h[i].clear(), r[i].clear();
	rep(i, 1, tot) t[i].l = t[i].r = t[i].v = 0; p = tot = dct = tp = N = 0;
}
void putans() { rep(i, 1, n) printf("%d", ans[i]); puts(""); clear(); }
void solve() {                                                                                                  
	scanf("%d%d", &n, &m); rep(i, 1, n) pa[i] = i;
	for (int i = 1, u, v; i <= m; i++) scanf("%d%d", &u, &v), g[u].pb(v), rg[v].pb(u), ++rd[v];
	rep(i, 1, n) if (!scc[i]) tj(i); hd = 1, tl = 0;
	rep(i, 1, n) if (scc[i] == N) Q[++tl] = i, vis[i] = 1; else vis[i] = 0; // Tarjan 得到的 SCC 编号是拓扑序逆序，Kosaraju 得到的 SCC 编号是拓扑序正序
	while (hd <= tl) { int u = Q[hd++]; for (int v : g[u]) if (!vis[v]) Q[++tl] = v, vis[v] = 1; }
	rep(i, 1, n) if (!vis[i]) { rep(j, 1, n) ans[j] = 3; putans(); return; } // 根 SCC 到不了所有结点
	RT = getrt(); // cout << RT << "\n";
	if (RT == -1) { rep(i, 1, n) ans[i] = scc[i] == N ? 2 : 3; putans(); return; } // 没有找到一类点
	rep(i, 1, n) dfn[i] = 0; dct = 0; prework(RT, 0);
	rep(i, 1, p) {
		int u = fr[i], v = to[i];
		if (dfn[u] < dfn[v] || dfn[u] + sz[u] > dfn[v] + sz[v]) RT = -1;
	}
	if (RT == -1) { rep(i, 1, n) ans[i] = scc[i] == N ? 2 : 3; putans(); return; } 
	ans[RT] = 1; dfs1(RT); FC_ = FS_ = 0; 
	rep(i, 1, n) c[0][i] = c[1][i] = c[2][i] = 0; prework_2();
	dfs2(RT); FC_ = FS_ = GC_ = 0; putans();
}
int main() {
	scanf("%*d%d", &T);
	while (T--) solve();
	return 0;
}
```

---

## 作者：raincity (赞：2)

## 题意

给定一张简单有向图。定义一个节点是图的根，当且仅当它到每个节点的路径都存在且唯一。

1. 求哪些节点是图的根。
2. 称一张生成子图是合法的，当且仅当原图中的根在子图中仍然是根。求哪些节点满足：存在一张合法子图，满足该节点是子图的根。

## 分析

显然我们应该研究“判定每个点是否是图的根的结构”，以及“判定每个点是否是某张合法子图的根的结构”。

### 判定每个点是否是图的根

等价于存在唯一一棵以该点为根的外向生成树。等价于存在一棵以该点为根的外向生成树，满足所有非树边都是返祖边。

直接判定是 $O(n^2)$ 的，考虑优化。部分分给出了提示，这个问题又分为两步：求出任意一个根；通过一个根找出所有的根。

#### 通过一个根找出所有的根

先求出图以 $rt$ 为根的外向生成树。考虑判定点 $u$ 是否是根。先讨论掉一些比较简单的情况。

如果 $u$ 不可达 $rt$，则显然不合法。所以 $u$ 与 $rt$ 必须强连通。

如果 $u$ 子树内存在两条指向子树外的返祖边，则一定不合法，因为 $u$ 到较深的那个点至少存在两条路径。

如果 $u$ 子树内指向子树外的返祖边存在且唯一，设指向了 $v$。显然 $u$ 到子树内每个点的路径唯一，只需考虑子树外的点 $w$ 是否满足 $u$ 到 $w$ 的路径唯一。$u$ 到 $w$ 的路径显然必须经过 $v$。猜想 $v$ 到 $w$ 的路径也必须存在且唯一，进一步猜想 $v$ 必须是图的根。

> 证明 1（$v$ 到 $w$ 的路径必须存在且唯一）：显然 $v$ 到 $w$ 的路径必须存在。若不唯一，则必须存在一条 $v \rightsquigarrow w$ 经过 $u$ 子树内的点的路径，这条路径一定经过 $u$ 子树内到子树外的必经边，也就是会重复经过 $v$，矛盾。

> 证明 2（$v$ 必须是图的根）：由证明 1 可知 $v$ 到子树外每个点的路径存在且唯一。因为 $rt$ 是图的根，所以 $v$ 到 $v$ 子树（包含 $u$ 子树）内所有点的路径都存在且唯一。因此 $v$ 也是图的根。

显然该条件也是充分的，因此 $u$ 是图的根当且仅当 $v$ 是图的根。所以可以从上往下递推，使用一些均摊可以做到 $O(n + m)$。

#### 求出任意一个根

考虑递归构造，在外向生成树上剥叶子。叶子节点的入度一定为 $1$，因此可以考虑每次删掉一个入度为 $1$ 的点 $u$。

容易想到上述做法的一个问题：根节点的入度也可能为 $1$。但是再仔细思考一下，若根节点 $u$ 的入度为 $1$，设 $u$ 的入边为 $v \to u$，考虑 $u \rightsquigarrow v$ 的路径经过的第二个点 $w$，由“通过一个根找出所有的根”这一节的判定，$w$ 一定也是根，所以可以改为找 $w$ 这个根。

但是玩一下样例就会发现上述做法还有问题，这是因为删除 $u$ 得到的子图的根不一定是原图的根，因为 $u$ 可能有出边，而这些边可能是前向边或者横叉边。解决办法非常简单，设 $u$ 的入边为 $v \to u$，把 $u$ 的出边接到 $v$ 上即可。注意自环应该删掉。容易发现 $u$ 是原定的根也是没有关系的。

直接实现上述做法的复杂度是 $\tilde O(n^2)$ 的，和暴力没区别。但是考虑进一步优化算法。首先，删除 $u$ 只可能导致 $v$ 一个点的入度减少（因为删除了自环），所以可以用类似拓扑排序的方式维护所有入度不超过 $1$ 的点 $u$。

考虑启发式合并，维护每个点的出边和入边，懒惰删除点 $u$，用并查集维护连通块，删除 $u$ 时把 $u$ 的父亲赋值为 $v$，邻接表中的点需要 Find 才能得到真实的点。这样我们就可以只修改 $v$ 的邻接表。至于统计 $u \to v$ 的边数，因为我们同时维护了入边和出边，所以可以从任意一侧数出来。剩下一个问题是已知 $u$ 怎么求 $v$，因为合并后 $v$ 的入度不升，而现在 $u$ 的入度为 $1$ 且未删除，所以 $v$ 一定是原图中 $u$ 的入邻域中的某个点所在的集合的根节点。因为 $u$ 不同所以均摊复杂度线性。

总复杂度是启发式合并的 $O(m \log n)$。

### 判定每个点是否是某张合法子图的根

这一部分比较简单。首先，子图中必须保留的边是原图中的根的 DFS 树的树边，也就是初始求出的 DFS 树的树边，和每个其他根节点子树内连向子树外的边，这些边的终点一定都是根。

考虑仿照“判定每个点是否是图的根”这一部分进行分类讨论。考虑判定点 $u$ 是否是某张合法子图的根。如果 $u$ 子树内有至少两条指向子树外的必须边，则一定不合法。如果恰有一条，这一条的终点一定是原图的根，所以一定合法。否则可以选择保留某一条非必须边。如果存在一条子树内指向子树外的非必须边，满足边的终点是原图的根或某张合法子图的根则 $u$ 合法，否则 $u$ 不合法。

这一部分同样可以从上往下递推，使用一些均摊可以做到 $O(n + m)$。整道题的复杂度是 $O(m \log n)$。

---

## 作者：xfrvq (赞：1)

> 给定一个有向图。定义：
> + **一类点**：到达每个点恰有一条有向简单路径的点。
> + **二类点**：删除一个边集后可成为一类点，且原一类点性质不变。
> + 其余为三类点。
>
> 现在要求每个点的类型。

### A 性质：没有一类点

能到达所有点就是二类点。特判一下（实际上只用判对原图跑 tarjan 的最后一个 SCC）。

### BC 性质：初始给定一个一类点，求所有一类点

以 $1$ 为根建 dfs 树，树上只有返祖边，不存在横叉边。否则根到该点有多条路径。

接下来的讨论只保留 $1$ 所在的 SCC。每个 $(u,fa_u)$ 至少被一条返祖边覆盖。

当 $(u,fa_u)$ 被 $\ge2$ 条返祖边覆盖，$u$ 不是一类点。因为 $u\to fa_u$ 有两条路径。

**当 $(u,fa_u)$ 仅被 $1$ 条返祖边覆盖，$u$ 是否是一类点，取决于该返祖边终点 $p$ 是否是一类点**。因为每个点到其子树内点都只有一条路径。$u$ 到 $u$ 子树外只能经过 $p$ 这一条路径。

### C 性质：初始给定一个一类点，求所有二类点

首先原 dfs 树边必须保留，否则破坏了 $1$ 的性质。然后每个一类点的子树内返祖边必须保留，否则破坏了该点性质。

现在考虑**覆盖 $(u,fa_u)$ 的必保留返祖边数 $c_u$**。若 $c_u\ge2$，$u$ 不是二类点。

若 $c_u=1$，**那么 $u$ 是否是二类点，取决于这条返祖边终点 $p$ 是否是一/二类点**。显然若 $p$ 到 $u$ 子树内必须经过 $u$，不会影响 $u$ 对子树内边限制。$u$ 到 $u$ 子树外只保留 $p$ 的一条路径。

**实际上这时 $u$ 必是二类点**，因为是必保留返祖边，这条边两端都一定是一类点。

若 $c_u=0$，**那么 $u$ 是否是二类点，取决于是否存在一条覆盖 $(u,fa_u)$ 返祖边，其终点为一/二类点**。证明类似。

实现：**对于不保留返祖边 $u\to v$，$u$ 为一/二类点，可推出链 $(u,v)$ 上所有 $c_x=0$ 点是二类点**。考虑 dfs 时用数据结构做链加，被加过至少一次说明是二类点。树状数组转为单点加子树查。

### 如何找一个一类点

考虑一棵根为一类点的 dfs 树，其叶子必定入度为 $1$。不断缩去入度为 $1$ 的点，最后可以留下一个根。

对于入度为 $1$ 点 $u$（$v\to u$），将 $u$ 的所有出边缩到 $v$ 上，**不缩重边，但缩自环**，删除点 $u$。类似拓扑排序做这个过程，若 $v$ 变得入度为 $1$ 将 $v$ 入队。

实现时需要支持：合并 $u,v$ 出边，在 $u$ 入度为 $1$ 时查询 $u\to v$ 边数。考虑对**所有邻边**做启发式合并。根据大小决定查询“$u$ 的出边中到 $v$ 数量”或“$v$ 的入边中到 $u$ 数量”。

---

视 $n,m$ 同阶，总时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;

int _,n,m,rt,U[N],V[N],fa[N],de[N];
basic_string<int> G1[N],H[N],E[N],F[N];
vector<pair<int,int>> G[N];
char ans[N];
int dfn[N],low[N],tot,stk[N],tp,col[N],cnt;
int dep[N],out[N],f[N],g[N],h[N],T[N];
bool vis[N],flg[N];

int fnd(int i){ return i == fa[i] ? i : fa[i] = fnd(fa[i]); }

int fndrt(int c = 0){
	queue<int> Q;
	for(int i = 1;i <= n;++i) if(de[i] == 1) Q.push(i);
	for(;Q.size();){
		int u = Q.front(),v = 0; Q.pop();
		if(vis[u] || de[u] != 1) continue;
		for(int x : H[u]) if(!vis[fnd(x)] && fnd(x) != u) v = fnd(x);
		if(!v) continue;
		if(E[u].size() + F[u].size() < E[v].size() + F[v].size()){
			for(int w : E[u]) de[v] -= (fnd(w) == v);
			E[v] += E[u],F[v] += F[u];
		} else {
			for(int w : F[v]) de[v] -= (fnd(w) == u);
			E[u] += E[v],F[u] += F[v];
			swap(E[u],E[v]),swap(F[u],F[v]);
		}
		++c,fa[fnd(u)] = fnd(v),vis[u] = 1;
		if(de[v] == 1) Q.push(v);
	}
	return (c == n - 1) * fnd(1);
}

void clr(){ 
	for(int i = 1;i <= n;++i) dfn[i] = vis[i] = 0;
	tot = tp = cnt = 0;
}

void tarjan(int u){
	dfn[u] = low[u] = ++tot,vis[stk[++tp] = u] = 1;
	for(auto[v,i] : G[u])
		if(!dfn[v]) tarjan(v),low[u] = min(low[u],low[v]);
		else if(vis[v]) low[u] = min(low[u],dfn[v]);
	if(dfn[u] == low[u]){
		++cnt;
		do vis[stk[tp]] = 0,col[stk[tp--]] = cnt;
		while(stk[tp + 1] != u);
	}
}

int cmp(int i,int j){ return !i || !j ? i + j : dep[V[i]] < dep[V[j]] ? i : j; }

void dfs1(int u){
	dfn[u] = ++tot;
	for(auto[v,i] : G[u]) if(col[v] == col[rt]){
		if(!dfn[v]) dep[v] = dep[u] + 1,dfs1(v),f[u] += f[v],g[u] = cmp(g[u],g[v]);
		else ++f[u],--f[v],g[u] = cmp(g[u],i);
	}
	if(f[u] == 1) fa[fnd(u)] = fnd(V[g[u]]);
}

void dfs2(int u){
	dfn[u] = ++tot;
	for(auto[v,i] : G[u]) if(col[v] == col[rt])
		if(!dfn[v]) dfs2(v),h[u] += h[v];
		else if(!flg[i]) G1[v].push_back(u);
	if(h[u] == 1) ans[u] = min(ans[u],'2');
	out[u] = tot;
}

void upd(int p,int x){ for(p = dfn[p];p <= n;p += p & -p) T[p] += x; }

int qry(int p,int s = 0){
	for(int r = out[p];r;r &= r - 1) s += T[r];
	for(int l = dfn[p] - 1;l;l &= l - 1) s -= T[l];
	return s;
}

void dfs3(int u){
	if(!h[u] && qry(u) > 0) ans[u] = min(ans[u],'2');
	if(ans[u] != '3') for(int x : G1[u]) upd(x,1);
	for(auto[v,i] : G[u]) if(col[v] == col[rt] && dfn[v] > dfn[u]) dfs3(v);
}

void dfs0(int u){
	vis[u] = 1;
	for(auto[v,i] : G[u]) if(!vis[v]) dfs0(v);
}

int main(){
	for(scanf("%*d%d",&_);_--;){
		scanf("%d%d",&n,&m);
		for(int i = 1;i <= n;++i)
			ans[i] = '3',E[i] = F[i] = G1[i] = H[i] = {},G[i].clear(),
			f[i] = g[i] = h[i] = de[i] = dep[i] = vis[i] = T[i] = 0;
		for(int i = 1,u,v;i <= m;++i)
			scanf("%d%d",&u,&v),U[i] = u,V[i] = v,flg[i] = 0,
			G[u].emplace_back(v,i),H[V[i]] += U[i],E[u] += v,F[v] += u,++de[v];
		iota(fa,fa + N,0);
		if(!(rt = fndrt())){
			clr();
			for(int i = 1;i <= n;++i) if(!dfn[i]) tarjan(i);
			dfs0(stk[1]);
			if(*min_element(vis + 1,vis + n + 1))
				for(int i = 1;i <= n;++i) if(col[i] == cnt) ans[i] = '2';
		} else {
			clr(),tarjan(rt),clr(),iota(fa,fa + N,0),dfs1(rt);
			for(int i = 1;i <= n;++i) if(fnd(i) == fnd(rt)){
				ans[i] = '1';
				if(i != rt && !flg[g[i]]) flg[g[i]] = 1,++h[U[g[i]]],--h[V[g[i]]];
			}
			clr(),dfs2(rt),dfs3(rt);
		}
		puts(ans + 1);
	}
	return 0;
}
```

---


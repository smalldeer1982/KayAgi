# [CEOI 2024] 核酸检测

## 题目描述

**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T2「[COVID tests](https://ceoi2024.fi.muni.cz/page/tasks/statements/covid.pdf)」**

亚当的学校最近爆发了新一波 COVID 疫情。为了防止疫情进一步蔓延，学校决定用唾液抗原检测试剂对所有学生进行检测。

由于老师们很久没用过这些试剂了，亚当自告奋勇地成为了检测志愿者。他拿到了来自 $N$ 个学生的唾液样本（出于隐私保护，他只能看到编号从 $0$ 到 $N-1$ 的标识符），他的任务是确定哪些样本呈阳性。

然而，亚当很快意识到，挨个检测所有学生的样本实在太耗时费力了。他灵机一动，想到了一种比逐个检测更巧妙的方法。如果他将部分样本混合在一起进行检测，他就能知道整个混合物是全部阴性，还是至少有一个阳性。这样一来，他就可以通过这种方式减少所需的检测次数！

每个样本的唾液量都足够进行多次检测。而且，这些检测试剂非常精准，同一个样本绝不会出现不同的检测结果。

在这样的条件下，亚当希望优化检测流程，尽量减少使用的检测次数。但是他目前正在进行检测，所以优化过程就交给你啦！

通过当地的统计数据，亚当了解到任何一个样本呈阳性的概率都等于 $P$，并且一个样本是阳性还是阴性不会影响其他样本的检测结果。也许你可以利用这些信息来帮助亚当优化检测方案？

## 说明/提示

本题分为两个子任务。

#### Subtask 1 (10 分)

- 学生总数 $N = 1000$
- 场景数 $T = 1$
- 阳性样本概率 $P$ 在 $0$ 到 $1$ 之间

如果程序能正确回答并且每个测试数据的询问次数不超过 $2$ 倍的总学生人数 $2N$，则认为该程序通过测试。

#### Subtask2 (90 分)

- 学生总数 $N = 1000$
- 场景数 $T = 300$
- 阳性样本概率 $P$ 在 $0.001$ 到 $0.2$ 之间

该子任务具有部分分。

如果你的程序在任何场景的回答错误，你将得 $0$ 分。否则，每个测试数据的得分将基于平均询问次数计算。一般来说，询问次数越少，得分越高。记作程序在所有场景的平均询问次数为 $Q$，四舍五入到小数点后一位。对于每个测试数据，我们计算了一个值 $F$（见下文）。给定测试数据的得分将根据以下规则计算：

- 如果 $Q > 10$ 倍的 $F$，你将得 $0$ 分 (错误答案)。
- 如果 $F < Q \leq 10$ 倍的 $F$，得分由以下公式计算：
  $$ 90 \cdot \frac{F}{F + 4 \cdot (Q-F)} $$
- 如果 $Q \leq F$，你将获得满分 $90$ 分。

你的程序将会在不同 $P$ 值的测试数据上进行评分。你将获得的总分是所有测试数据（所有概率 $P$）中的最低分。

测试数据如下：

| $P$ | $F$ |
|-------|-------|
| $0.001$ | $15.1$ |
| $0.005256$ | $51.1$ |
| $0.011546$ | $94.9$ |
| $0.028545$ | $191.5$ |
| $0.039856$ | $246.3$ |
| $0.068648$ | $366.2$ |
| $0.104571$ | $490.3$ |
| $0.158765$ | $639.1$ |
| $0.2$ | $731.4$ |

交互器会为每个测试数据提供反馈。这些反馈将包括你在得分非零的测试数据上的平均询问次数 $Q$。

# 题解

## 作者：Petit_Souris (赞：5)

我们考虑用 dp 算出期望最优的策略：设 $f_{i,j}$ 表示剩下 $i$ 个人，其中有 $j$ 个人，他们中已经被确定至少有一个 $1$ 的期望次数。

当 $j=0$ 时，我们枚举 $k$ 表示查询 $i$ 个人中的多少人。如果这些人中没有 $1$（概率为 $(1-P)^k$），会从 $f_{i-k,0}$ 转移过来，否则会从 $f_{i,k}$ 转移过来。

当 $j=1$ 时，从 $f_{i-1,0}$ 转移过来（已经确定是这个人了）。

当 $j>1$ 时，我们枚举 $k$ 表示查询这 $j$ 个人中的多少人。如果这些人中没有 $1$（概率为 $\frac{(1-P)^{k}-(1-P)^{j}}{1-(1-P)^j}$），会从 $f_{i-k,j-k}$ 转移过来，否则会从 $f_{i,k}$ 转移过来。dp 的过程中记录转移的路径。

交互过程只需要根据 dp 得到的路径来构造就行了。时间复杂度为 $\mathcal O(n^3)$，注意实现常数。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
/// You may use:

// The number of students
int N;

// The probability any given student is positive
double P;

// This function performs a test on a subset of samples.
// Its argument is a vector of Booleans of length N,
// where the i-th element is true if the i-th sample should be added to the mix.
// It returns true if (and only if) at least one of the samples in the mix is positive.
bool test_students(std::vector<bool> mask) {
    assert(mask.size() == (size_t)N);

    std::string mask_str(N, ' ');
    for (int i = 0; i < N; i++)
        mask_str[i] = mask[i] ? '1' : '0';

    printf("Q %s\n", mask_str.c_str());
    fflush(stdout);

    char answer;
    scanf(" %c", &answer);
    return answer == 'P';
}

/// You should implement:

// This function will be called once for each test instance.
// It should use test_students to determine which samples are positive.
// It must return a vector of Booleans of length N,
// where the i-th element is true if and only if the i-th sample is positive.

typedef double ld;
const ld INF=1e9;
ld dp[1009][1009],pb[1009];
int trans[1009][1009];
mt19937 rnd(time(0));
std::vector<bool> find_positive(bool typ) {
    std::vector<bool> answer(N);
    if(typ){
        rep(i,0,N-1){
            vector<bool>msk(N);
            msk[i]=1;
            if(test_students(msk))answer[i]=1;
        }
        return answer;
    }
    vector<int>ord(N);
    iota(ord.begin(),ord.end(),0);
    shuffle(ord.begin(),ord.end(),rnd);
    int i=N,j=0;
    while(i){
        if(j==1){
            answer[ord[i-1]]=1;
            i--,j=0;
            // if(i)shuffle(ord.begin(),ord.begin()+i-1,rnd);
            continue;
        }
        vector<bool>msk(N);
        int k=trans[i][j];
        per(p,i-1,i-k)msk[ord[p]]=1;
        bool res=test_students(msk);
        if(j){
            if(!res)i-=k,j-=k;
            else j=k;
        }
        else {
            if(!res)i-=k;
            else j=k;
        }
    }
    return answer;
}
int main() {
    int T;
    scanf("%d %lf %d", &N, &P, &T);
    if(T>1){
        pb[0]=1;
        rep(i,1,N)pb[i]=pb[i-1]*(1-P);
        rep(i,0,N+1){
            rep(j,0,N+1)dp[i][j]=INF;
        }
        rep(i,0,N+1)dp[0][i]=0;
        rep(i,1,N){
            dp[i][1]=dp[i-1][0];
            rep(j,2,i){
                rep(k,1,j){
                    ld prob=(pb[k]-pb[j])/(1-pb[j]);
                    ld val=dp[i-k][j-k]*prob+dp[i][k]*(1-prob)+1;
                    if(val<dp[i][j])dp[i][j]=val,trans[i][j]=k;
                }
            }
            rep(j,1,i){
                ld val=dp[i-j][0]*pb[j]+dp[i][j]*(1-pb[j])+1;
                if(val<dp[i][0])dp[i][0]=val,trans[i][0]=j;
            }
        }
    }
    // You may perform any extra initialization here.

    for (int i = 0; i < T; i++) {
        std::vector<bool> answer = find_positive(T==1);
        assert(answer.size() == (size_t)N);
        std::string answer_str(N, ' ');
        for (int j = 0; j < N; j++)
            answer_str[j] = answer[j] ? '1' : '0';

        printf("A %s\n", answer_str.c_str());
        fflush(stdout);

        char verdict;
        scanf(" %c", &verdict);
        if (verdict == 'W')
            exit(0);
    }

    return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：1)

你考虑大概 $b=\frac {0.75}{k}$（实际上应该用点对数，但是这里搞个近似值即可）个里面就有一半的可能有，一半的可能没有。

于是你每次询问未确认的前 $b$ 个，如果没有就跳过，如果有就直接二分第一个位置。然后发现刚好超了一点点。

这个二分实际上不是很优，因为无论你这个感染的位置在哪，都是 $\log b$ 次。但是如果这个感染点在后面就会比较好，在前面就会比较劣。

考虑二分的时候，$mid$ 选在更靠近 $l$ 的地方即可。微调一下系数就过了。

---

## 作者：huazai676 (赞：1)

[task(luogu)](https://www.luogu.com.cn/problem/P10802)

一看 $F$ 的值千奇百怪，感觉上是可以乱搞的题目。

对于 $P=0.001$，$F=15.1$，期望上有一个阳性，于是可以直接二分找。提交之后发现当 $P$ 增大后，每个阳性都会贡献 $O(\log n)$ 的复杂度导致后面测试点直接爆炸。

此时，思考是否对于每个阳性都需要单独询问到？如果是结合多个询问推出某个样本为阳性，则大约形式为“在某些阴性样本中加入某个样本后全体变为阳性”，那么与把询问过的阴性直接扔掉再单独询问阳性没有区别。
那是否可以通过减少单独询问得出一个不保证绝对正确但正确率极高的算法呢？显然由于阳性样本量未知，任何一个未经明确的样本都有概率（无论多小）成为阳性，正确率大概率无保障。

既然每个阳性都要单独询问道，可以一个一个找。每次二分出从左到右第一个阳性。在扔掉第一个阳性及以前的阴性后，**由于所有回答为阳性的询问都可以看做是当前阳性所贡献的，之前的询问对后面完全无帮助**。直接把后面的看为独立的子问题即可。
当 $P$ 变大后发现由于数据是随机的均匀分布，前几次二分的大区间大概率都会包含阳性，于是可以直接从小区间开始二分。把二分上界改为 $\frac{1}{P}$ 可以拿 70 多分；据官方题解说根据剩余样本量和 $P$ 手工的二分上界可以卡到满分。

靠谱一点的“正解”也是依据这种思路。

考虑更 general 的视角下，我们已有的是一部分未检测样本和一部分合在一起检测为阳的样本（阴性直接扔掉）。我们需要检测后者的一个子集，以更精确阳性的位置：若子集为阳性，则先前的检测不再有用，继续检测子集的子集；若为阴性，直接丢掉，检测剩下阳性的子集。这里面有很强的递归结构。先前我们人为规定了每次检测子集的大小，现在要算出在某种情况（两部分大小已知的情况）下，“最优”的检测子集的大小。

在样本随机分布下，对于某种询问策略，可以用该策略下询问次数的期望来量化“最优”。结合先前的递归结构和期望的线性性，可以设计 dp：$f_{i,j}$ 表示在剩余 $i$ 个样本中，$j$ 个合起来为阳性，此时所有询问策略中询问次数的期望最小为 dp 值。

设新检测子集大小为 $k$，子集检测为阳性的概率为 $p=p(P,j,k)$，则有转移 $f_{i,j}=\min_{k<j}(p \cdot f_{i,k}+(1-p)\cdot f_{i-k,j-k}+1)$。再拿个 $g_{i,j}$ 记录下策略。每个测试点 $P$ 固定，10s 限时，$O(N^3)$ 可跑完。$f_{i,0}$ 的转移类似。

最后考虑 $p(P,j,k)$ 的计算：已知 $j$ 个随机变量相互独立服从概率为 $P$ 的伯努利分布，且其中至少有有一个为 1（事件 $B$)，求任选 $k$ 个中至少有 1 （事件 $A$）的概率。
经典条件概率 $p(A|B)=\frac{p(B|A)\cdot p(A)}{p(B)}=\frac{1\cdot (1-(1-P)^k)}{1-(1-P)^j}$。

算完发现当 $P=0.2$ 时， $f_{1000,0}$ 大概是 728，比 $F$ 略小。

有趣的是，对于不同的 $N$，最后都在 $P=0.381$ 左右收敛到 $f_{N,0}=N$（尽管最后收敛的值似乎不一样），$P$ 再大后就不变了；而且第一次检测的大小确实与 $\frac{1}{P}$ 相近。

代码

```cpp
#include <cassert>
#include <cstdio>
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>
#include <random>

std::mt19937 rd(17638761);

const double inf = 1e18;

int N, T;
int pe[1005];
double f[1005][1005], pw[1005];
int g[1005][1005];

double P, Q;

bool test_students(std::vector<bool> mask) {
    assert(mask.size() == (size_t)N);

    std::string mask_str(N, ' ');

    for (int i = 0; i < N; i++)
        mask_str[i] = mask[i] ? '1' : '0';

    printf("Q %s\n", mask_str.c_str());
    fflush(stdout);

    char answer;
    scanf(" %c", &answer);
    return answer == 'P';
}

bool query(int l, int r) {
    std::vector<bool> mask(N, 0);

    for (int i = l; i <= r; i++)
        mask[pe[i]] = true;

    return test_students(mask);
}

std::vector<bool> find_positive() {
    std::vector<bool> answer(N);
    int i = 0, j = -1;

    while (i < N) {
        int k = g[N - i][j - i + 1];

        if (query(i, i + k - 1)) {
            j = i + k - 1;

            if (k == 1) {
                answer[pe[i]] = true;
                i++;
            }
        } else {
            i = i + k;
            j = std::max(i - 1, j);

            if (i == j) {
                answer[pe[i]] = true;
                i++;
            }
        }
    }

    return answer;
}

int main() {
    scanf("%d %lf %d", &N, &P, &T);

    for (int i = 0; i < N; i++)
        pe[i] = i;

    shuffle(pe, pe + N, rd);
    Q = 1 - P;
    pw[0] = 1;

    for (int i = 1; i <= N; i++)
        pw[i] = pw[i - 1] * Q;

    for (int i = 1; i <= N; i++) {
        f[i][1] = f[i - 1][0];

        for (int j = 2; j <= i; j++) {
            f[i][j] = inf;

            for (int k = 1; k < j; k++) {
                double p = (1 - pw[k]) / (1 - pw[j]);
                double t = p * f[i][k] + (1 - p) * f[i - k][j - k] + 1;

                if (t < f[i][j]) {
                    f[i][j] = t;
                    g[i][j] = k;
                }
            }
        }

        f[i][0] = inf;

        for (int j = 1; j <= i; j++) {
            double p = 1 - pw[j];
            double t = p * f[i][j] + (1 - p) * f[i - j][0] + 1;

            if (t < f[i][0]) {
                f[i][0] = t;
                g[i][0] = j;
            }
        }
    }

    //  printf("%lf %d\n",f[N][0],g[N][0]);

    for (int i = 0; i < T; i++) {
        std::vector<bool> answer = find_positive();
        assert(answer.size() == (size_t)N);

        std::string answer_str(N, ' ');

        for (int j = 0; j < N; j++)
            answer_str[j] = answer[j] ? '1' : '0';

        printf("A %s\n", answer_str.c_str());
        fflush(stdout);

        char verdict;
        scanf(" %c", &verdict);

        if (verdict == 'W')
            exit(0);
    }

    return 0;
}
```

---


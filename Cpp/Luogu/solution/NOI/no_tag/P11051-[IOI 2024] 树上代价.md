# [IOI 2024] 树上代价

## 题目背景

提交时请不要引用 `tree.h`。

请不要使用 C++14 (GCC 9) 提交。

## 题目描述

有一棵包括 $N$ 个**结点**的**树**，结点从 $0$ 到 $N-1$ 编号。结点 $0$ 是树的**根**。除根以外的每个结点都有唯一的**父结点**。对所有满足 $1 \leq i < N$ 的 $i$，结点 $i$ 的父结点为 $P[i]$，这里有 $P[i] < i$。我们约定 $P[0] = -1$。

对所有结点 $i$（$0 \leq i < N$），$i$ 的**子树**是如下结点组成的集合：
 * $i$，以及
 * 所有父结点为 $i$ 的结点，以及
 * 所有父结点的父结点为 $i$ 的结点，以及
 * 所有父结点的父结点的父结点为 $i$ 的结点，以及
 * 以此类推。

下图给出了一个包含 $N = 6$ 个结点的树的例子。每个箭头都从某个结点连向它的父结点（根结点除外，因为它没有父结点）。结点 $2$ 的子树包括结点 $2, 3, 4$ 和 $5$。结点 $0$ 的子树包括树中的全部 $6$ 个结点，而结点 $4$ 的子树仅包括结点 $4$ 自己。

![](https://cdn.luogu.com.cn/upload/image_hosting/vg5uaueo.png "150")

每个结点都被赋以非负整数的**权重**。我们将结点 $i$（$0 \leq i < N$）的权重记为 $W[i]$。

你的任务是写一个程序来回答 $Q$ 个询问，其中每个询问都用一对正整数 $(L, R)$ 来表示。对于询问的回答，应按照如下要求进行计算。

对树中的每个结点，都指派一个整数，称为**系数**。这样的指派结果被描述成一个序列 $C[0], \ldots, C[N-1]$，这里 $C[i]$（$0 \leq i < N$）是指派给结点 $i$ 的系数。我们称该序列为一个**系数序列**。注意，系数序列中的元素可以取负值、$0$ 或正值。

对某个询问 $(L, R)$，一个系数序列被称为是**有效的**，如果对于每个结点 $i$（$0 \leq i < N$）都有如下条件成立：结点 $i$ 的子树中的系数之和不小于 $L$ 且不大于 $R$。

对于一个给定的系数序列 $C[0], \ldots, C[N-1]$，结点 $i$ 的**代价**为 $|C[i]| \cdot W[i]$，这里 $|C[i]|$ 表示 $C[i]$ 的绝对值。最后，**总体代价**为所有结点的代价之和。你的任务是，对于每个询问，计算出可以由某个有效系数序列达到的**最小总体代价**。

可以证明，对于任意询问，都至少存在一个有效的系数序列。

### 实现细节

你需要实现如下两个函数：

```
void init(std::vector<int> P, std::vector<int> W)
```

* $P$，$W$：两个长度为 $N$ 的整数数组，记录了结点的父结点和权重。
* 对于每个测试样例，在评测程序与你的程序开始交互时，该函数将被恰好调用一次。

```
long long query(int L, int R)
```
* $L$，$R$：两个整数，描述一次询问。
* 对于每个测试样例，在 `init` 被调用后，该函数将被调用 $Q$ 次。
* 该函数应该返回对给定询问的答案。

## 说明/提示

考虑如下调用：

```
init([-1, 0, 0], [1, 1, 1])
```
这棵树包含 $3$ 个结点：根结点以及它的 $2$ 个子结点。所有结点的权重均为 $1$。

```
query(1, 1)
```

本次询问有 $L = R = 1$，这意味着每个子树中的系数之和都必须等于 $1$。考虑系数序列 $[-1, 1, 1]$。这棵树以及相应的系数（在阴影矩形中）图示如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/fg1hjoze.png "150")

对每个结点 $i$（$0 \leq i < 3$），$i$ 的子树中全部结点的系数之和均为 $1$。因此，系数序列是有效的。总体代价的计算如下：


| 结点 | 权重 | 系数 |            代价            |
| :----: | :----: | :---------: | :------------------------: |
|   $0$    |   $1$    |     $-1$      | $\mid -1 \mid \cdot 1 = 1$ |
|   $1$    |   $1$    |      $1$      | $\mid 1 \mid \cdot 1 = 1$  |
|   $2$    |   $1$    |      $1$      | $\mid 1 \mid \cdot 1 = 1$  |

因此总体代价为 $3$。这是唯一的有效系数序列，因此调用应该返回 $3$。

```
query(1, 2)
```
对于该询问的最小总体代价为 $2$，可以在系数序列为 $[0, 1, 1]$ 时达到。

### 约束条件

* $1 \leq N \leq 200\,000$
* $1 \leq Q \leq 100\,000$
* $P[0] = -1$
* 对所有满足 $1 \leq i < N$ 的 $i$，都有 $0 \leq P[i] < i$
* 对所有满足 $0 \leq i < N$ 的 $i$，都有 $0 \leq W[i] \leq 1\,000\,000$
* 在每次询问中，都有 $1 \leq L \leq R \leq 1\,000\,000$

| 子任务 | 分数 | 额外的约束条件                                     |
| :-----: | :---: | ------------------------------------------------------------ |
|    1    | $10$  | $Q \leq 10$；对所有满足 $1 \leq i < N$ 的 $i$，都有 $W[P[i]] \leq W[i]$ |
|    2    | $13$  | $Q \leq 10$；$N \leq 2\,000$                                 |
|    3    | $18$  | $Q \leq 10$；$N \leq 60\,000$                                |
|    4    |  $7$  | 对所有满足 $0 \leq i < N$ 的 $i$，都有 $W[i] = 1$              |
|    5    | $11$  | 对所有满足 $0 \leq i < N$ 的 $i$，都有 $W[i] \leq 1$           |
|    6    | $22$  | $L = 1$                                                      |
|    7    | $19$  | 没有额外的约束条件。                                   |

## 样例 #1

### 输入

```
3
0 0
1 1 1
2
1 1
1 2
```

### 输出

```
3
2
```

# 题解

## 作者：zjy2008 (赞：16)

考虑特殊性质 $L=1$，我们有一个简单的 $O(nqV)$ dp，也就是 令 $dp_{u,k}$ 表示 $u$ 子树和为 $\le k$ 时的最优答案。那么我们的操作是若 $u$ 为叶子，令 $dp_{u,*}=0$， 否则先令 $dp_u$ 为其所有子节点的闵可夫斯基和，然后将其向右平移 $|son(u)|-1$ 位，并执行 $dp_{u,k}=\min_{k'\ge k}dp_{u,k'}+a_u(k'-k)$，这时我们要对它进行截取，即把 $k>R$ 的部分变为 $dp_{u,R}$。

因为我们的操作是平移与直线 chkmin，合并是闵可夫斯基和，故 $dp_u$ 是凸的，同时，若 $R\ge k>sz_u$，$dp_{u,k}=0$，于是我们只需要维护 $R\le sz_u$ 的部分。

因为出现了闵可夫斯基和，我们考虑直接维护 $dp_u$ 的差分集合 $S_u=\{dp_{u,k}-dp_{u,k+1}|1\le k\le R\}$（这里是可重集）。重新描述 $dp$，若 $u$ 为叶子，$S_u=\emptyset$，否则先令 $S_u=\cup_{v\in son(u)} S_v$，然后放入 $|son(u)|-1$ 个 $a_u$，把 $S_u$ 内所有数向 $a_u$ chkmin，然后把 $S_u$ 内除了前 $R-1$ 大的数都累加进答案，并将其删去。

现在我们考虑如何同时计算所有 $R=1\cdots n$ 的答案。容易发现，每个点最终的 $S_u$ 就是 $R=n$ 时的 $S_u$ 的前 $R-1$ 大。容斥一下，可以得到 $ans_R=\sum_u (a_u(|son(u)|-1)+\sum_{v\in son(u)}\sum_{i<R}\min(a_u,S_{v,i})-\sum_{i<R}S_{u,i})=\sum_u a_u(|son(u)|-1)+\sum_u \sum_{v\in son(u)}\sum_{i<R}\min(a_u,S_{v,i})-S_{v,i}$。
直接考虑每个 $S_{v,i}$ 对答案造成的贡献，显然是个后缀加。用线段树维护 $S_v$，可以维护出相等的 $S_{v,i}$ 对答案的贡献可以被描述成区间加等差数列的形式。每一次 chkmin 成功必然会令不同的 $S_{*,*}$ 减少，故均摊一下，至多只会操作 $O(n)$ 次。合并操作和插入也可以被线段树单次 $O(\log n)$ 的完成。故时空复杂度 $O(n\log n)$。

考虑 $L\neq 1$ 怎么变成 $L=1$ 的情况，根据一开始的 $dp$，把它的凸包画出来，只有在 $L$ 的倍数处才有可能出现转折，于是答案就是 $ans_{\lfloor\frac{R}{L}\rfloor}L+(R\mod L)(ans_{\lfloor\frac{R}{L}\rfloor+1}-ans_{\lfloor\frac{R}{L}\rfloor})$。

---

## 作者：uuku (赞：14)

这题部分分设置很好，跟着部分分一点点想就出来了。并且代码难度并不复杂。

本文将从 $\text{sub1,4,5}$ 依次讲解直到正解。

本文我们对题目稍微修改，定义修改操作为，每个点花 $W_i$ 的价格使得子树总和减一。

首先对于叶子有个显然的结论，为了使得总花费最少，每个叶子的初始权值肯定是 $L$。

### sub1

该点特殊性质为 $W_{P_i} \le W_i$。

也就是说在满足子树内情况时，操作次数越少越好，因为到祖先操作会更优。

所以只需要 $\text{dfs}$ 一遍，每个点贪心修改最少次数即可。

### sub4

该点性质为 $W_i=1$，那么仍满足 $\text{sub1}$ 的性质可以继续用上述贪心，但此时询问次数没有限制，所以我们需要一些优化。

再次观察整个问题，当 $W_i=1$ 时我们只需关注整颗树的操作总次数。不难发现当某个点子树内的和不超过 $R$ 时，整颗子树没有点需要进行修改操作。

现在我们考虑根节点的操作，如果根节点总和没到 $R$ 那么整棵树都不需要操作，只用叶子的花费。

否则我们一定是在根节点操作若干次使得根节点的总和为 $R$。

为了得到总操作次数最少，我们先考虑一个必要条件。记叶子个数为 $cnt$ 那么整棵树的总和为 $cnt\times L$，而由于根的限制最大是 $R$，所以最少次数就是 $cnt\times L -R$。而进一步观察可以发现这个值一定能够取到，因为无论在哪个点操做都会使得总和减一，并且没有任何浪费。

所以对于这个子任务我们只需统计叶子个数，然后答案就是 $\max(0,cnt\times L -R)$。

### sub5

这个子任务我觉得是最重要的一个。

该子任务限制为 $W_i \le 1$，与上一个任务的区别在于 $W_i$ 可以取 $0$。

那么我们就来思考多了 $0$ 会有什么影响。

首先，我们就不能贪心的选择在父亲操作，但是由于这些点是 $0$，也就是说在这里操作没有任何影响，所以肯定是在 $W_i=0$ 的点操作若干次使得子树和为 $L$，这样显然是不劣的。

那么对于 $0$ 的点，每个点的权值都将变为 $L$，应该不难发现这个点对之后的贡献与把这棵子树删了换成一个叶子没有任何区别。所以我们就可以基于 $0$ 点，将整棵树分成若干棵树，分别统计相应的叶子个数。

但现在求答案的方式就变了，因为我们会有若干个不同叶子个数，这个子任务到是还好，本质不同的叶子个数应该只有 $\sqrt{n}$ 种，直接暴力维护应该也能过。

我们现在就来考虑求答案如何优化，我们现在相当于求 $\sum\limits_{i=1}^n leaf_i\times \max(0,i\times L-R)$，其中 $leaf_i$ 表示含有 $i$ 个叶子的树的数量。由于 $i\times L-R$ 的单调性，这个最大值显然是前面一段取 $0$，后面一段取 $i\times L -R$。所以我们只需要求出第一个取右边的 $i=\lceil\frac{R}{L}\rceil$，那么更大的 $i$ 肯定取的也是右侧，只需要维护后缀 $leaf_i\times i$的和，还有后缀 $leaf_i$ 的和即可。

### 无约束条件

在做完前面三个子任务后，最后一步已经不是很难了，只需要对做法进行优化。

我们只需考虑每一个 $W_i$ 的贡献。具体的我们可以进行如下操作，当作子任务 5 求一次答案，然后将所有 $W_i$ 减 $1$，并与 $0$ 取最大值。这本质上也是一种贪心，我们要考虑每个值被操作次数最少是多少，当一个点 $W_i$ 减为 $0$ 后，就意味着在这个点操作肯定比没减到 $0$ 的点更优。

所以我们现在的问题就是对于每个 $1 \le j \le 10^6$，把 $W_i<j$ 看作 $0$，$W_i\ge j$ 看作 $1$，然后求出子任务 $5$ 中的 $leaf_i$ 数组，并相应位置求和。

但是有 $q$ 次询问，不过仔细研究后，对于不同的 $L,R$ 我们在上述操作的过程中是完全一致的，所以我们只需预处理出 $leaf_i$ 数组即可。

现在我们考虑如何求出 $leaf_i$。发现在 $W_i$ 减少过程中，每个点只会有一次对 $leaf_i$ 的变化量有影响的操作，就是当 $W_i$ 第一次减为 $0$ 的时候。

而如果当前最小的 $W_i$ 记作 $W_{min}$，那么在接下来 $W_{min}$ 次减一操作中 $leaf_i$ 的改变是相同的，可以考虑用差分。

不过正着删点并不好维护，我们考虑倒着往里面加点，这样就可以用并查集动态维护当前的连通块，及其叶子个数，同时用差分可以统计每个叶子个数的子树出现的总个数，具体细节请参考代码。

最后别忘了加上初始叶子的贡献。


```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 10;
int n, q, w[N], id[N], fa[N], fat[N], vis[N], sz[N];
long long sum[N], sum2[N], sumleaf;
vector<int> e[N];
bool cmp(int x, int y)
{
	return w[x] > w[y];
}
int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}
void change(int now, int v, int val) //差分维护贡献，每个连通块出现时 + w_i，消失时 - w_i 
{
	sum[sz[now]] -= val;
	sz[now] += v;
	sum[sz[now]] += val;
	return;
}
void merge(int now, int fat, int val)
{
	int f = find(fat);
	fa[now] = f;
	sum[sz[now]] -= val; //删除被合并连通块的贡献 
	change(f, sz[now], val);
	return;
}
void del(int now)
{
	if (fat[now] && vis[fat[now]])  //当父亲已经在时，儿子会作为一个叶子被计算在父亲中，需减去贡献 
	{
		int f = find(fat[now]);
		change(f, -1, w[now]);
	}
	for (int to : e[now]) //儿子存在就和儿子合并，否则将儿子视作叶子 
		if (vis[to])
			merge(to, now, w[now]);
		else
			change(now, 1, w[now]);
	if (vis[fat[now]])
		merge(now, fat[now], w[now]);
	vis[now] = 1;
	return;
}
void init(std::vector<int> P, std::vector<int> W)
{
	n = P.size();
	for (int i = 1; i < n; i++)
		e[P[i] + 1].push_back(i + 1), fat[i + 1] = P[i] + 1;
	for (int i = 0; i < n; i++)
		w[i + 1] = W[i];
	for (int i = 1; i <= n; i++)
		if (e[i].size() == 0) //给叶子加个点，便于统一操作 
		{
			sumleaf += w[i];
			e[i].push_back(0);
		}
	//sz 表示每个连通块叶子个数 
	for (int i = 1; i <= n; i++)
		id[i] = i, fa[i] = i, sz[i] = 0, vis[i] = 0;
	sort(id + 1, id + n + 1, cmp);
	for (int i = 1; i <= n; i++)
		del(id[i]);
	for (int i = 1; i <= n; i++)
		sum2[i] = sum2[i - 1] + sum[i] * i, sum[i] += sum[i - 1];
	return;
}

long long query(int L, int R)
{
	int k = min((R - 1) / L + 1, n + 1);
	return (sum2[n] - sum2[k - 1]) * L - R * (sum[n] - sum[k - 1]) + sumleaf * L;
}
```

---

## 作者：DaiRuiChen007 (赞：6)

[Problem Link](https://www.luogu.com.cn/problem/P11051)

**题目大意**

> 给定 $n$ 个点的树，每个点有点权 $w_i$，$q$ 次询问 $L,R$，构造一组 $c_i$ 使得每个子树内 $c_i$ 的和都在 $[0,1]$ 之间，最小化 $\sum|c_i|w_i$。
>
> 数据范围；$n\le 2\times 10^5,q\le 10^5$。

**思路分析**

先从 $w_i=1$ 的情况开始分析，此时在哪里填 $c$ 没有区别，只关心总和。

自下而上地开始填 $c_i$，首先在每个叶子上都有 $c_i=L$，在此之后，每个点的子树和都 $\ge L$，我们只要给一些非叶子结点的 $c$ 设为负数以保证其总和 $\le R$，容易证明减到 $<L$ 是不优的。

观察根节点处的变化量，设原有 $k$ 个叶子，那么要让根节点合法，整棵树的变化量至少为 $\max(0,kL-R)$。

不难证明这个界是可以取到的，可以每个 $>R$ 的节点处减到 $R$，可以证明这样不会有冗余操作。

然后考虑 $w_i\in\{0,1\}$ 的情况，容易发现此时我们能在 $w_i=0$ 的点上任意操作，因此我们一定能在每个 $w_i=0$ 的点上把子树和调整到 $L$。

这相当于把每个 $w_i=0$ 的点看成叶子，然后对每个连通块分别求解答案再求和。

设有 $k$ 个叶子的连通块有 $f_k$ 个，答案就是 $\sum_k f_k\times \max(0,kL-R)$，求出第一个 $kL>R$ 的位置维护 $f_k$ 和 $k\times f_k$ 的后缀和即可快速计算答案。

然后考虑一般的情况，由于我们已经会解决 $w_i\in\{0,1\}$ 的情况了，因此不妨猜测更一般的情况可以向这种情况规约。

对每个 $x$，将 $w_i>x$ 的点看成 $1$，$w_i\le x$ 的点看成 $0$，然后对每个 $x$ 求出答案再相加，可以根据本题的直接贪心过程证明之。

依然考虑维护 $\sum f_k$，设 $w_1\sim w_n$ 是递增的，那么我们就要依次删除 $1\sim n$，删除 $1\sim i$ 后的一个叶子数为 $k$ 的连通块对 $f_k$ 的贡献就是 $w_{i+1}-w_i$。

首先我们肯定转成倒序插入节点，可以用并查集维护产生和删除的每个连通块。

并且可以考虑差分，即一个连通块在插入 $x$ 时刻生成，就对 $f_k$ 产生 $+w_x$ 贡献，在插入 $y$ 时刻消失，就对 $f_k$ 产生 $-w_y$ 贡献。

那么这样就可以维护出所有 $f_k$ 并计算答案，最终答案记得加上 $L$ 倍叶子权值的和。

时间复杂度 $\mathcal O(n\log n+q)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+5;
vector <int> G[MAXN];
int n,w[MAXN],fa[MAXN],dsu[MAXN],siz[MAXN];
bool vis[MAXN];
ll cnt[MAXN],s1[MAXN],s2[MAXN],clf;
int find(int x) { return x^dsu[x]?dsu[x]=find(dsu[x]):x; }
void add(int x,int c,int v) { cnt[siz[x]]-=v,cnt[siz[x]+=c]+=v; }
void merge(int x,int y,int v) { dsu[y]=x,cnt[siz[y]]-=v,add(x,siz[y],v); }
void ins(int x) {
	vis[x]=true;
	if(fa[x]&&vis[fa[x]]) add(find(fa[x]),-1,w[x]);
	for(int y:G[x]) {
		if(!vis[y]) add(x,1,w[x]);
		else merge(x,y,w[x]);
	}
	if(vis[fa[x]]) merge(find(fa[x]),x,w[x]);
}
void init(vector <int> P,vector <int> W) {
	n=W.size(); vector <int> ord;
	for(int i=1;i<=n;++i) w[i]=W[i-1],ord.push_back(i),dsu[i]=i;
	for(int i=2;i<=n;++i) G[fa[i]=P[i-1]+1].push_back(i);
	for(int i=1;i<=n;++i) if(G[i].empty()) G[i].push_back(0),clf+=w[i];
	sort(ord.begin(),ord.end(),[&](int x,int y){ return w[x]>w[y]; });
	for(int u:ord) ins(u);
	for(int i=n;i>=1;--i) s1[i]=s1[i+1]+cnt[i],s2[i]=s2[i+1]+cnt[i]*i;
}
ll query(int L,int R) {
	int x=min(n,R/L)+1;
	return clf*L+s2[x]*L-s1[x]*R;
}
```

---

## 作者：Hoks (赞：2)

## 前言
IOI 妙妙题，属实难想。

感谢 @[I_am_rubbish](https://www.luogu.com.cn/user/419726) 推题喵。

摘自 [杂题选做](https://www.luogu.com.cn/training/597433)。
## 思路分析
考虑一档一档做。

首先看 $Sub~1$，$w_{p_i}\le w_i$ 也就意味着如果 $i$ 点已经满足条件了，在 $p_i$ 处操作一定会比在 $i$ 点操作来影响 $p_i$ 好。

那么我们对于每个点，如果他目前权值为 $x$，如果 $x>R$ 了，直接把 $x$ 减到 $R$ 就最优了。

每次询问的时候 dfs 一遍实现这个过程即可。

这时我们解决了 $Sub~1$，可以拿到 $10$ 分。

---

然后可以观察到 $Sub~1,2,3$ 中的 $Q\le 10$，可以支持一个 $O(NQ)$ 再加点奇怪 $\log$ 的做法。

我们考虑先胡出一个贪心的方法，可以一遍遍历树算出答案。

因为题目中的**新权值为子树和**，每一遍计算子树和显然太 naive 了，所以我们考虑把**子树和单点查**转化为**链加单点查**。

这时我们在 dfs 时走回到祖先一层，就可以把加的值传上去，相当于实现了链加。

那么这时就很明确了，因为叶子节点只有当他自己链加的时候才能加到，所以对于每个叶子都要先把权值修改为 $L$。

接着我们来考虑树上一个叶子到根的路径上相交的分差点。

如样例中的 $0$ 号点，如果不修改权值那么他的权值会是 $2L$。

这个时候就需要考虑决策了，我们可以考虑给他调整到 $R$，也可以考虑给他调整成 $L$，貌似很难决策。

还是考虑从链加的性质，从下到上的处理这颗树。

那么显然的对于我们处理到的一个点 $x$，必须要在这是给他的权值调整到 $[L,R]$ 中，因为再上面的点操作就与他无关了。

接着我们考虑怎么调整 $x$ 这个点的权值。

对于 $x$ 我们先记录下来一个优先队列里存下代价和可操作次数。

如果 $x$ 这个点的代价很优，比他的**所有可以操作的后代**还优，那我们直接在 $x$ 点操作就行了。

同时我们把队列清空，因为对于更上面的点都可以考虑用 $x$ 而不用下面的点。

如果 $x$ 的代价不优秀，我们考虑用优先队列中的堆顶去减小 $x$ 的值，一直削到刚好 $R$ 为止。

同时如果有的儿子的修改权值比 $x$ 大，直接把它的操作次数给到 $x$ 就行了。

最后算 $x$ 处还可以多减的次数为操作次数扔到堆里去就行了。

这样我们就得到了一个 $O(NQ\log N)$ 的做法。

这时可以通过 $Sub~1/2/3$，拿到 $41$ 分。

---

接着来考虑剩下部分，这时我们要在 $\sqrt{N},\log N$ 等复杂度下回答一次询问，较自然的想到先预处理来快速回答。

肯定不能再像上面一样一个一个点每次考虑过去了，而是从**全局性**上考虑这个问题。

我们不难发现，唯一比较大的问题就是 $[L,R]$ 比如 $R$ 变大时，可能很多地方都没必要修改了，一直传到上面再修改更优。

$Sub~4$ 比较 ez，因为对于每个点修改都是相同的，所以答案就是 $\max(0,L\times cnt-R)$，其中 $cnt$ 为叶子的数量。

这点比较简单，因为我们每次的修改都可以完全的利用（因为可以放到任何一个点进行链修改），所以限制就在于最上面的根节点，只要根节点能改到 $[L,R]$ 就可以了。

这时我们解决了 $Sub~1/2/3/4$，可以拿到 $48$ 分。

---

再接下来是 $Sub~5$，应该说是**最重要**的一个 $Sub$。

因为修改代价中有 $0,1$，我们肯定是在 $0$ 处修改会更优，而且是严格的更优。

那意味着什么？

我们只需要在代价为 $0$ 的点上无脑把权值修改为 $L$，最小化这棵子树对于上面的贡献就好了。

这样貌似还是不太好处理？

考虑直接把 $0$ 点处断开。

因为 $0$ 点处值都会被修改到 $L$，也就相当于是在下面又挂了一个叶子，所以断开后多挂个叶子就行了。

这个时候树就被分割为了一个只包含修改代价为 $1$ 点的森林。

根据 $Sub~4$ 的结论，我们知道这些点修改都是等价的，决定答案的就是根节点的权值大小。

设 $s_i$ 为有 $i$ 个叶子的森林中的树的个数，那么答案就是：
$$cnt\times L+\sum\limits_{i=1}^n \max(0,s_i\times(i\times L-R))$$

根据上面的说法 $s_i$ 很好处理出来，问题来到如何快速计算上面这个式子回答。

不难发现，当 $i$ 单调递增的时候，$i\times L-R$ 也是单调递增的。

所以 $i\times L-R<0$ 的肯定是连续的一段，具体的为 $i\in[1,\lfloor\frac{R}{L}\rfloor]$ 时，答案都为 $0$。

令这个断点为 $k$，后面的部分式子就是：
$$\sum\limits_{i=k+1}^n s_i\times (i\times L-R)$$

分配律，预处理出 $s1_i=s1_{i+1}+s_i\times i$ 和 $s2_i=s2_{i+1}+s_i$ 两个后缀和，作差就可以得到最后的答案式子为：
$$cnt\times L+s1_k\times L-s2_k\times R$$

这时我们解决了 $Sub~1/2/3/4/5$，可以拿到 $59$ 分。

---

接着来考虑最后一个部分。

有了前面的铺垫其实最后一个部分好像比较简单？

$w_i$ 有不为 $0,1$ 的值意味着什么？

通过 $Sub~5$ 的铺垫我们知道，**我们通过全局性考虑代替局部贪心主要就是做到了一个单调性**。

因为修改 $0$ **一定**会比修改 $1$ 优秀，也就是这个**单调性**，使得我们可以先把 $0$ 都操作完再来处理 $1$ 的位置。

这启发我们把点按照修改代价从小到大排序，然后依次处理每个点上的操作。

总体上，我们还是只考虑权值只有 $0,1$ 的点，然后把其他权值的点转移到这上面来。

具体的，我们考虑像上面一样把 $0$ 点都断开，把其子树权值修改为 $L$，然后数数计算 $1$ 点。

此时我们发现森林里只有 $1,2,\dots$ 点了，不妨**全局减一**。

这时我们又造出了 $0$ 点，继续按照上面那个方法循环操作直到整个处理完就行了。

为了回答询问，我们还是要像上面那个部分一样处理出 $s$ 数组，但是代价带权，所以我们在处理代价的时候记得给权值也带上处理 $s$ 数组就行了。

现在的问题就变回到了如何快速做 $n$ 次断开 $0$ 点，计算 $1$ 点，然后再全局减一。

断开是一个很难的操作，所以我们考虑反过来，变成合并。

那我们就要支持合并两颗子树，想到什么？

**并查集**。

所以这里还是利用并查集来实现单调维护的 trick。

然后记得合并的时候去掉原贡献加上新贡献，以及断开后最后面要挂叶子等处理，就完成了。

这时我们可以通过所有测试点，拿下 $100$ 分。

---

仔细回想一下这题的整个流程，感觉还是挺自然的。

最后发现考察的 trick 也算是比较经典的并查集维护单调性。

个人感觉最难的就在于如何把这个问题从**局部的贪心转化到全局的考虑**上。

最后一部分相较而言可能更简单了？
## 代码
~~代码好像比部分分代码还要短~~。

Tips：如果你 CE，请检查自己是不是有 `#define int long long` 这种东西导致修改了函数的传值的类型，导致检测不到。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=5e5+10;
ll n,cnt,fa[N],w[N],a[N],id[N],s[N],ss[N],si[N],mp[N];vector<ll>e[N];
inline void mdf(int x,int s,int w){a[si[x]]-=w,si[x]+=s,a[si[x]]+=w;}
struct DSU
{
	vector<int> h;
	void init(int n){h=vector<int>(n+10);for(int i=0;i<=n;i++) h[i]=i;}
	int find(int x){return h[x]==x?x:h[x]=find(h[x]);}
	void merge(int x,int y,int w){x=find(x),y=find(y);h[y]=x;a[si[y]]-=w;mdf(x,si[y],w);}
}f;
inline bool cmp(int x,int y){return w[x]>w[y];}
inline void initpoint(int u)
{
	mp[u]=1;
	if(!e[u].size()) mdf(u,1,w[u]);
	if(fa[u]&&mp[fa[u]]) mdf(f.find(fa[u]),-1,w[u]);
	for(int y:e[u])
		if(!mp[y]) mdf(u,1,w[u]);
		else f.merge(u,y,w[u]);
	if(mp[fa[u]]) f.merge(fa[u],u,w[u]);
}
void init(vector<int> P,vector<int> W)
{
	n=P.size();for(int i=1;i<n;i++) e[fa[i+1]=P[i]+1].emplace_back(i+1);
	for(int i=1;i<=n;i++) w[i]=W[i-1],id[i]=i;sort(id+1,id+1+n,cmp);
	for(int i=1;i<=n;i++) if(!e[i].size()) cnt+=w[i];
	f.init(n);for(int i=1;i<=n;i++) initpoint(id[i]);
	for(int i=n;i>=1;i--) s[i]=s[i+1]+a[i],ss[i]=ss[i+1]+a[i]*i;
}
ll query(int L,int R){int x=min((int)n,R/L)+1;return cnt*L+ss[x]*L-s[x]*R;}
```

---

## 作者：Mirasycle (赞：1)

先思考 $w_i=1$ 的做法，考虑一个自底向上的贪心。我们将所有叶子节点的权值设置为 $L$（设置大了显然不优），然后向上走，如果一个点的子树和 $>R$，我们就贪心地将其调整为 $R$。

如何快速计算这个贪心的代价？可以发现这个过程就是先累加所有叶子节点 $L$ 的代价，然后不断累加 $>R$ 部分溢出的代价，一直到 $1$ 点，最后只剩下了 $R$（或者初始总和就不足 $R$）。于是假设有 $k$ 个叶子节点，代价就是 $kL+\max(0,kL-R)$。单组询问可以 $O(1)$ 回答。

接着思考 $w_i\in \{0,1\}$ 的情况，由于在 $w_u=0$ 节点我们可以任意无代价操作，所以肯定是在这些点调整成一个最优的情况。最优情况就是将子树和调整为 $L$。这个东西还是很复杂，不方便快速计算答案。有一个很巧妙的转化：既然我们把 $w_u=0$ 的点调整成了 $L$，那我们不妨将它们直接看成叶子节点。于是一棵树就分裂成了一个森林。于是对于森林中的每个树独立求解即可。

面对多组询问，设 $c_i$ 表示森林中有 $i$ 个叶子节点的树的个数。于是答案就是 $kL+\sum c_i\max(0,iL-R)$，直接计算这个式子的时间复杂度为 $O(\sqrt n)$ （$\sum c_i\times i\le n$，故 $c_i$ 最多有根号种）。能不能更快点？利用 $i=\lceil\dfrac{R}{L}\rceil$ 为临界点，拆掉 $\max$ 式子，维护 $\sum c_i$ 和 $\sum i\times c_i$ 的后缀和即可。还是可以 $O(1)$ 回答。

对于 $w_i$ 无限制的情况，以上启发我们扫描值域，设置阈值，将 $w_i$ 缩小为 $\{0,1\}$。具体来说，我们用变量 $x$ 扫描 $w_i$ 的值域 $V$，令 $w_i=[w_i\ge x]$，然后执行以上算法。这等价于将 $w_i$ 的贡献拆成了 $w_i=\sum\limits_{i=1}^V[w_i\ge i]$。

暴力做的时间复杂度是 $O(nV)$ 的，还是过不去。考虑每次移动 $x\to x+1$ 的时候，相关信息的变化量应该是 $O(1)$ 的，需要快速维护这个过程。每次的变化就是 $O(1)$ 个节点变成了叶子节点，这是一个树分裂的过程，不太好维护，考虑倒着枚举 $x$，就变成了树合并的过程。采用并查集维护联通块的合并，合并的时候会扣除一些叶子个数的贡献，同时会加上一些叶子个数的贡献，还有一些没有变化的叶子个数贡献，可以直接用差分维护这些贡献，这样子我们就可以在 $O(n\log n)$ 的时间内快速处理出 $\sum\limits_{x=1}^V \sum c_i$。

时间复杂度 $O(n\log n+q)$。

---

## 作者：_Ch1F4N_ (赞：0)

考虑怎么对于一组 $L,R$ 求出答案。

从下往上考虑树的所有结点，也就是先考虑每个子树，再考虑子树合并后形成的新子树并在原来的子树策略上通过调整得到新子树的策略。

考虑叶子的策略一定是直接调整到 $L$，因为调到 $L$ 后一定会使得其祖先满足下界，而可能会使得祖先超过上界，所以一定不会再多调。

然后在你向上合并子树的过程中，如果当前子树根没有超过 $R$ 那肯定是不用调整，我们考虑第一次超过 $R$ 时怎么办。

我们会选择子树内一个点 $x$ 并在其上把权值调小，并满足调小后不会出现某个子树小于 $L$ 的情况，你发现由于子树权值随着后代到祖先的过程递增，所以其实只要保证 $x$ 为根的子树权值不小于 $L$ 即可，并且你发现 $x$ 子树权值调整到 $L$ 后 $x$ 子树内其他点就不能再被调整了。注意到你这个子树内其他点不能再调整看似是一个代价，实则无关痛痒，因为 $x$ 子树出来贡献最低就是 $L$，而如果子树内没有代价比 $x$ 更低的点，你相当于就是以最高的性价比将贡献调小了，如果有更低的点，你肯定会在调整 $x$ 前先调更低的点，因此调整完 $x$ 后再使得子树内无法调整实际上并不会带来任何代价。

所以可以得到我们的调整策略就是：当权值超过 $R$ 时，选择子树内一个 $w$ 最小的点将其权值下调直到以其为根的子树权值变为 $L$ 后将这个子树删掉并寻找其他点进行调整。

考虑如何来加速计算上面过程产生的代价。

注意到存在一个 $w_i \leq 1$ 的部分分，我们先来看看这个咋做。

首先叶子肯定全部调到 $L$ 先，然后依然从下往上考虑，如果碰到一个 $w=0$ 的点就直接把权值无代价地调成 $L$，注意到这个处理和叶子很像，所以可以认为是将 $w=0$ 的点直接删去并给其父亲加一个无代价叶子，接下来只用处理 $w=1$ 的若干连通块的情况，假若在一个点子树权值和超过 $R$，此时必然是选择一个 $w=1$ 的点调，因此直接选择自己一路调到 $R$ 即可，随后你发现如果一个点 $x$ 调到 $R$ 了，其所有祖先必定也要调到 $R$，因此可以确定每个点最后的子树权值，计算贡献可以考虑最开始权值和是 $L \times leaf$，其中 $leaf$ 表示叶子数，最后的权值和是根的子树权值，不难发现就是 $\min(R,L \times leaf)$，而调整过程中一共减少的贡献 $\max(0,L \times leaf - R)$ 刚好就是代价，当然还需要记得加上所有有代价叶子调整到 $L$ 的代价。

加速计算过程可以考虑使得 $\max(0,L \times leaf - R)$ 产生非零贡献的 $leaf$ 是一段后缀，我们对于每个连通块记录关于 $leaf$ 的两个后缀和即可做到 $O(1)$ 查询。

考虑原问题，我们尝试将其向 $w_i \leq 1$ 的情形上靠，当你调整以 $x$ 为根的子树时，不妨设子树内最小值为 $y$，你会先将 $w=y$ 的点不断调小直到调到 $L$，并将这些点子树删掉，然后如果还没有让 $x$ 子树权值小于等于 $R$ 就选择次小值继续这个步骤，你发现这个过程和我们让 $lim$ 从 $1$ 到 $\infty$ 遍历，将 $w < lim$ 的 $w$ 赋值为 $0$ 并将 $w \geq lim$ 的 $w$ 赋值为 $1$ 并做一遍处理实际上是等价的，不断地将最小值调整到 $L$ 并删去子树相当于不断地将新的 $w$ 被赋值为 $0$ 的点的子树权值调整为 $L$ 并将其视作一个新叶子，而将最小值的点向下调整的代价则在 $lim$ 从 $1$ 到最小值的遍历过程中被计算到了。因此只需要计算转换后的过程的答案总和即可。

考虑从大往小倒着枚举 $lim$ 并用并查集处理加点带来的连通块合并与连通块的 $leaf$ 对后缀和数组的贡献即可做到 $O(n \log n + q)$。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 2e5+114;
vector<int> E[maxn];
int n;
ll leaf[maxn][2];
ll trleaf;
int fa[maxn],cnt[maxn];
pair<int,int> ins[maxn];
int vis[maxn];
int found(int u){
    return fa[u]=(fa[u]==u?u:found(fa[u]));
}
void init(std::vector<int> P, std::vector<int> W){
    n=P.size();
    for(int i=1;i<n;i++) E[P[i]].push_back(i);
    for(int i=0;i<n;i++) trleaf+=(E[i].size()==0)*W[i];
    for(int i=0;i<n;i++) ins[i]=make_pair(-W[i],i);
    sort(ins,ins+n);
    for(int i=0;i<n;i++){
        int u=ins[i].second;
        vis[u]=1;
        fa[u]=u;
        for(int v:E[u]){
            if(vis[v]==0) cnt[u]++;
        }
        if(E[u].size()==0) cnt[u]++;
        for(int v:E[u]){
            if(vis[v]==1){
                leaf[cnt[found(v)]][0]-=W[u];
                leaf[cnt[found(v)]][1]-=1ll*cnt[found(v)]*W[u];
                cnt[u]+=cnt[found(v)];
                fa[found(v)]=u;
            }
        }
        if(P[u]!=-1&&vis[P[u]]==1){
            leaf[cnt[found(P[u])]][0]-=W[u];
            leaf[cnt[found(P[u])]][1]-=1ll*cnt[found(P[u])]*W[u];
            cnt[found(P[u])]+=cnt[u]-1;
            fa[u]=found(P[u]);
            leaf[cnt[found(P[u])]][0]+=W[u];
            leaf[cnt[found(P[u])]][1]+=1ll*cnt[found(P[u])]*W[u];
        }else{
            leaf[cnt[u]][0]+=W[u];
            leaf[cnt[u]][1]+=1ll*cnt[u]*W[u];
        }
    }
    for(int i=n-1;i>=0;i--) leaf[i][0]+=leaf[i+1][0],leaf[i][1]+=leaf[i+1][1];
}
long long query(int L, int R){
    return 1ll*trleaf*L+L*leaf[min(n+1,(R+L-1)/L)][1]-R*leaf[min(n+1,(R+L-1)/L)][0];
}
```

---


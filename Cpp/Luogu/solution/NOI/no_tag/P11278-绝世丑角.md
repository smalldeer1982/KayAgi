# 绝世丑角

## 题目背景

$$
\begin{array}{cr}
\text{我好恨　恨这固执到厚颜无耻的人}\\
\text{竟和曾经快乐的我同个模样}\\
\text{即使信仰和记忆都}\overset{\text{Runtime Error}}{\text{遍体鳞伤}}\\
\text{仍在深渊妄想得到}\overset{\text{return }{\color{#EE0000}0}\text{;}}{{\color{#EE0000}\text{你}}\text{的回望}}\\
&\text{——《绝世丑角》}
\end{array}
$$

![](bilibili:BV12i4y1976j)

---

在被修改的、破碎不堪的回忆中取出仅有的连续片段。

泠珞还是想知道，能否从中提取出，有意义的回忆呢。

## 题目描述

对于两个非负整数 $a,b$，定义它们的 Nim 积为 $a\otimes b=\operatorname{mex}(\{(a\otimes d)\oplus(c\otimes b)\oplus (c\otimes d)|0\le c<a,0\le d<b\})$，其中 $x\oplus y$ 表示 $x$ 与 $y$ 的二进制异或和，$\operatorname{mex}(S)$ 表示**不存在**于 $S$ 中的最小的非负整数。

给定一个长度为 $n$ 的非负整数序列 $a_1,a_2,\cdots,a_n$，给定 $q$ 次操作，每次操作有三个参数 $(t,\ell,r)$。

- 若 $t=1$，表示对于 $i=\ell,\ell+1,\cdots,r$，令 $a_i\gets a_i\otimes a_i$。
- 若 $t=2$，表示查询 $a_\ell\oplus a_{\ell+1}\oplus\cdots\oplus a_r$。
- 若 $t=3$，表示查询 $a_\ell+ a_{\ell+1}+\cdots+ a_r$。

你需要输出每次查询的结果。

## 说明/提示

**【样例 #1 解释】**

第一次操作是查询，输出 $6\oplus 1\oplus 4\oplus 2=1$。

第二次操作是查询，输出 $3+6+1+4=14$。

第三次操作是修改，序列变为 $[3,6,1,4,3,5]$。

第四次操作是查询，输出 $3\oplus6\oplus1\oplus4\oplus3\oplus5=6$。

第五次操作是修改，序列变为 $[2,5,1,4,3,5]$。

第六次操作是查询，输出 $3+5=8$。

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n\le2.5\times10^5$，$0\le a_i<2^{32}$，$1\le q\le 1\times10^5$，$1\le t\le 3$，$1\le \ell\le r\le n$。保证最后一次操作是查询操作。

| 子任务编号 | 分值 | $n\le $ | $q\le $ | $a_i<$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $2.5\times10^5$ | $1\times10^5$ | $2^{32}$ | $t\neq 1$ |
| $2$ | $11$ | $2.5\times10^5$ | $1\times10^5$ | $2^{32}$ | 若 $t=1$，则 $\ell=r$ |
| $3$ | $19$ | $2.5\times10^5$ | $1\times10^5$ | $64$ | 无|
| $4$ | $13$ | $1\times10^5$ | $3\times10^4$ | $2^{32}$ | $t\neq 3$ |
| $5$ | $17$ | $2.5\times10^5$ | $1\times10^5$ | $2^{32}$ | $t\neq 3$ |
| $6$ | $7$ | $2.5\times10^5$ | $1\times10^5$ | $2^{32}$ | 若 $t=1$，则 $\ell=1,r=n$ |
| $7$ | $23$ | $2.5\times10^5$ | $1\times10^5$ | $2^{32}$ | 所有 $t=1$ 的操作在 $t\neq 1$ 前 |
| $8$ | $3$ | $1\times10^5$ | $3\times10^4$ | $2^{32}$ | 无 |
| $9$ | $5$ | $2.5\times10^5$ | $1\times10^5$ | $2^{32}$ | 无 |


## 样例 #1

### 输入

```
6 6
3 6 1 4 2 5
2 2 5
3 1 4
1 5 5
2 1 6
1 1 3
3 5 6
```

### 输出

```
1
14
6
8```

## 样例 #2

### 输入

```
10 10
1234567890 130113 3614258193 1000000007 3146527164 3141592653 2147483648 998244353 2346886432 20151114
2 1 10
3 5 8
1 2 9
3 1 4
1 5 8
1 3 10
2 1 9
3 1 8
1 1 4
2 8 8```

### 输出

```
2499610911
9433847818
4602641167
4258698016
17656837678
704481058```

## 样例 #3

### 输入

```
10 10
36 14 35 0 13 0 11 3 5 20
2 1 10
3 1 4
2 2 5
3 1 8
3 1 4
2 5 6
2 8 9
3 3 7
3 1 10
2 1 5```

### 输出

```
29
85
32
112
85
13
6
59
137
4```

## 样例 #4

### 输入

```
10 10
36 14 35 0 13 0 11 3 5 20
1 1 10
2 1 4
1 2 5
2 1 8
2 1 4
2 5 6
2 8 9
1 3 7
1 1 10
2 1 5```

### 输出

```
12
21
22
14
5
9```

## 样例 #5

### 输入

```
10 10
36 14 35 0 13 0 11 3 5 20
1 5 5
3 1 4
2 2 5
3 1 8
1 9 9
2 5 6
1 9 9
3 3 7
3 1 10
2 1 5```

### 输出

```
85
39
109
10
56
133
3```

## 样例 #6

### 输入

```
10 10
36 14 35 0 13 0 11 3 5 20
1 1 10
3 1 4
2 2 5
3 1 8
1 1 10
2 5 6
1 1 10
3 3 7
3 1 10
2 1 5```

### 输出

```
112
52
139
14
76
179
7```

## 样例 #7

### 输入

```
10 10
36 14 35 0 13 0 11 3 5 20
1 3 8
1 1 6
1 2 10
3 1 4
2 2 5
3 1 8
2 5 6
3 3 7
3 1 10
2 1 5```

### 输出

```
119
61
139
8
73
176
15```

# 题解

## 作者：MatrixGroup (赞：38)

## 前言

「经过数学家的不懈努力」是 Nim 积相关题解不可避免的一环……吗？

本文旨在勾勒部分 Nim 积性质的证明，有了这些性质后数据结构优化是不难的，可以参考其它题解。

更具体的介绍可以参考[这篇文章](https://www.luogu.com.cn/article/0ap2hfrc)（仍在更新中！）。

本文参考了《On Numbers And Games》的第六章。

对于不理解何为「序数」的读者，可以自行将文中所有「序数」换为「非负整数」。

如果你学过一定的抽象代数，你可以把文中的「对加法封闭」「对加法、乘法封闭」「对四则运算封闭」「所有多项式方程均有解」替换成「是群」「是环」「是域」「代数闭」。（因为异或意义下 $\alpha+\alpha=0$，一个数自然有相反数，因此可以不考虑减法）

在集合论中，冯诺依曼表示法的序数 $\alpha$ 就是集合 $\{\beta|\beta<\alpha\}$，其中 $\beta$ 是序数。本文不区分这两者。例如，当我们说到「$2$ 对四则运算封闭」的时候，也就是说「$\{0,1\}$（在异或和 Nim 积意义下）对四则运算封闭。」

本文中，方括号 $[]$ 中的运算为通常的序数运算，而其外部的运算为 Nim 运算。

## 引子

假如我们想在所有序数上定义一个加法和一个乘法，使得它们对四则运算封闭，并且它“字典序最小”（这个概念并不严格），应该怎么做？

先考虑加法吧。

$0+0=0$ 显然不会有问题，因此 $0$ 就是这个域上的零元。故而 $0+\alpha=\alpha+0=\alpha$。

$1+1=0$ 不会有问题，不就是特征【最小的 $n$ 满足所有数加 $n$ 遍等于 $0$】为 $2$ 嘛。

$1+2$ 是几？它不能等于 $1+1=0$，$1+0=1$，$0+2=2$，否则就和域有加法逆元（因此有消去律）矛盾了。因此 $1+2=3$。

这启发我们递归地定义

$$
\alpha+\beta=\operatorname{mex}(\{\alpha+\delta|\delta<\beta\}\cup\{\gamma+\beta|\gamma<\beta\})
$$

据此列出表格

$$
\begin{array}{c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
+&0&1&2&3&4&5&6&7&8&9&10&11&12&13&14&15\\\hline
0&0&1&2&3&4&5&6&7&8&9&10&11&12&13&14&15\\\hline
1&1&0&3&2&5&4&7&6&9&8&11&10&13&12&15&14\\\hline
2&2&3&0&1&6&7&4&5&10&11&8&9&14&15&12&13\\\hline
3&3&2&1&0&7&6&5&4&11&10&9&8&15&14&13&12\\\hline
4&4&5&6&7&0&1&2&3&12&13&14&15&8&9&10&11\\\hline
5&5&4&7&6&1&0&3&2&13&12&15&14&9&8&11&10\\\hline
6&6&7&4&5&2&3&0&1&14&15&12&13&10&11&8&9\\\hline
7&7&6&5&4&3&2&1&0&15&14&13&12&11&10&9&8\\\hline
8&8&9&10&11&12&13&14&15&0&1&2&3&4&5&6&7\\\hline
9&9&8&11&10&13&12&15&14&1&0&3&2&5&4&7&6\\\hline
10&10&11&8&9&14&15&12&13&2&3&0&1&6&7&4&5\\\hline
11&11&10&9&8&15&14&13&12&3&2&1&0&7&6&5&4\\\hline
12&12&13&14&15&8&9&10&11&4&5&6&7&0&1&2&3\\\hline
13&13&12&15&14&9&8&11&10&5&4&7&6&1&0&3&2\\\hline
14&14&15&12&13&10&11&8&9&6&7&4&5&2&3&0&1\\\hline
15&15&14&13&12&11&10&9&8&7&6&5&4&3&2&1&0\\\hline
\end{array}
$$

稍微验证一下发现它确实符合交换律、结合律……等等这不就是异或吗？怎么证明呢？

还是先来考虑一下乘法吧。首先 $0\alpha=\alpha0=0$，那 $1\times1$ 就不能是 $0$ 了，那就 $1$ 吧。好，$1$ 就是幺元了！那么 $1\alpha=\alpha1=\alpha$。$2\times2$ 等于多少？可以是 $1$ 吗？这样的话 $(2+1)\times(2+1)=2\times2+1\times2+2\times1+1\times1=0$，似乎不太对。可以是 $2$ 吗？$1\times2$ 已经是 $2$ 了啊。那就 $3$？暂时看起来没什么问题。

等等我们发现了什么……$(x+y)^2=x^2+y^2$，因此两个数的平方不能相同！这个性质很优美诶。

因为 $3=1+2$，由分配律 $3$ 相关的都做完了。

$2\times 4$ 是多少？显然不能为 $2\times0=0,2\times1=2,2\times2=3,2\times3=1$。如果是 $4+x(0\le x<4)$ 的话，那 $2\times4=4+x$ 得 $(2+1)\times4=x$，$3\times4<4$ 的话也不行（因为 $3\times0=0,3\times1=3,3\times2=1,3\times3=2$）。那么就最小是 $2\times4=8$ 了。

$3\times4=2\times4+1\times4=8+4=12$。

那 $4\times 4$ 是多少？根据之前的结果，它不能等于 $0^2=0,1^2=1,2^2=3,3^2=3,1\times4=4$。能等于 $5$ 吗？这意味着 $4$ 是 $x^2+x+1=0$ 的根。可是这是 $(x+2)(x+3)=0$！而 $(4+2)\times(4+3)$ 不能为 $0$。因此 $5$ 也不行。那就 $6$ 吧。先看着……

好像导致 $a\times b=x$ 矛盾的点都是 $(a+a')(b+b')=0$？那就让这些全都不为 $0$ 即可。这启发我们定义

$$
\alpha\beta=\operatorname{mex}\{\alpha\delta+\gamma\beta+\gamma\delta|\gamma<\alpha,\delta<\beta\}
$$

据此列出表格

$$
\begin{array}{c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\times&0&1&2&3&4&5&6&7&8&9&10&11&12&13&14&15\\\hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0\\\hline
1&0&1&2&3&4&5&6&7&8&9&10&11&12&13&14&15\\\hline
2&0&2&3&1&8&10&11&9&12&14&15&13&4&6&7&5\\\hline
3&0&3&1&2&12&15&13&14&4&7&5&6&8&11&9&10\\\hline
4&0&4&8&12&6&2&14&10&11&15&3&7&13&9&5&1\\\hline
5&0&5&10&15&2&7&8&13&3&6&9&12&1&4&11&14\\\hline
6&0&6&11&13&14&8&5&3&7&1&12&10&9&15&2&4\\\hline
7&0&7&9&14&10&13&3&4&15&8&6&1&5&2&12&11\\\hline
8&0&8&12&4&11&3&7&15&13&5&1&9&6&14&10&2\\\hline
9&0&9&14&7&15&6&1&8&5&12&11&2&10&3&4&13\\\hline
10&0&10&15&5&3&9&12&6&1&11&14&4&2&8&13&7\\\hline
11&0&11&13&6&7&12&10&1&9&2&4&15&14&5&3&8\\\hline
12&0&12&4&8&13&1&9&5&6&10&2&14&11&7&15&3\\\hline
13&0&13&6&11&9&4&15&2&14&3&8&5&7&10&1&12\\\hline
14&0&14&7&9&5&11&2&12&10&4&13&3&15&1&8&6\\\hline
15&0&15&5&10&1&14&4&11&2&13&7&8&3&12&6&9\\\hline
\end{array}
$$

稍微验证一下发现它确实符合交换律、分配律……而且似乎每 $[2^{2^N}]$ 以内对乘法封闭？而因为消去律一定有一个 $\beta$ 满足 $\alpha\beta=1$，所以就对四则运算封闭了……？怎么证明呢。

## 加减乘除

**定义 .** 对于任意序数 $\alpha,\beta$，我们递归定义它们的**异或**（Nim 和）为

$$
\alpha+\beta=\operatorname{mex}(\{\alpha+\delta|\delta<\beta\}\cup\{\gamma+\beta|\gamma<\beta\})
$$

**定义 .** 对于任意序数 $\alpha,\beta$，我们递归定义它们的 Nim 积为

$$
\alpha\beta=\operatorname{mex}\{\alpha\delta+\gamma\beta+\gamma\delta|\gamma<\alpha,\delta<\beta\}
$$

我们记 $\alpha^*$ 为一变量，它能取值所有 $<\alpha$ 的序数和部分 $>\alpha$ 的序数。（即，其取值范围的 $\operatorname{mex}$ 为 $\alpha$）如果 $\alpha$ 的定义式/计算式为 $\operatorname{mex}(S)$，称 $S$ 的所有元素为 $\alpha$ 的排除项。

**定理 .** 对于任意序数 $\alpha,\beta,\gamma$，$\alpha+\beta=\alpha+\gamma$ 当且仅当 $\beta=\gamma$。

**证明 .** 充分性显然。必要性考虑反证。若 $\beta\neq \gamma$，不妨设 $\beta<\gamma$，则 $\alpha+\beta$ 为 $\alpha+\gamma$ 的一排除项，矛盾。

**定理 .**（加法的冗余定理）对于任意序数 $\alpha,\beta$，

$$
\alpha+\beta=\operatorname{mex}(\{\alpha+\beta^*|\beta^*\}\cup\{\alpha^*+\beta|\alpha^*\})
$$

**证明 .** 显然 $\alpha+\beta$ 的所有排除项都被排除了，而其它的元素排除项含有 $\alpha+\beta$，故右侧取值为 $(\alpha+\beta)^*$，即 $\operatorname{mex}$ 为 $\alpha+\beta$。

**定理 .** 对于任意序数 $\alpha,\beta,\gamma$，有

1. $\alpha+0=\alpha$
2. $\alpha+\beta=\beta+\alpha$
3. $(\alpha+\beta)+\gamma=\alpha+(\beta+\gamma)$
4. $\alpha+\alpha=0$

**证明 .** 直接归纳即可。注意第三条要用到冗余定理。

**推论 .** （多个数的加法计算式）在证明第三条的归纳过程中，我们可以用归纳类似地证明：对于任何 $n$ 个序数 $\alpha_1,\alpha_2,\cdots,\alpha_n$，有：

$$
\sum_{i=1}^n\alpha_i=\operatorname{mex}\bigcup\limits_{i=1}^n\{\sum_{j=1}^n\begin{cases}\alpha&j=i\\\alpha_j&j\neq i\end{cases}|\alpha<\alpha_j\}
$$

**定理 .** 对于任意序数 $\alpha$，有 $\alpha0=0\alpha=0$。

**证明.** $\alpha0$ 和 $0\alpha$ 均无排除项，即证。

**定理 .** 对于任意序数 $\alpha,\beta,\gamma$，$\alpha\beta=\alpha\gamma$ 当且仅当 $\beta=\gamma$ 或 $\alpha=0$。

**证明.** 充分性显然。必要性考虑反证。若 $\beta\neq \gamma$，不妨设 $\beta<\gamma$，而 $0<\alpha$，故 $\alpha\gamma$ 的排除项有 $\alpha\beta+0\gamma+0\beta=\alpha\beta$，矛盾。

**定理 .**（乘法的冗余定理）对于任意序数 $\alpha,\beta$，有

$$
\alpha\beta=\operatorname{mex}\{\alpha\beta^*+\alpha^*\beta+\alpha^*\beta^*|\alpha^*,\beta^*\}
$$

**证明 .** 显然 $\alpha\beta$ 的排除项都被排除了。因此我们只需证 $\alpha\beta\neq \alpha\beta^*+\alpha^*\beta+\alpha^*\beta^*$ 即可。根据异或的自逆，这等价于 $\alpha\beta+\alpha\beta^*+\alpha^*\beta+\alpha^*\beta^*\neq 0$。显然，其它三者之和为最大的一者的排除项，即证。

**定理 .**  对于任意序数 $\alpha,\beta,\gamma$，有

1. $\alpha1=\alpha$
2. $\alpha\beta=\beta\alpha$
3. $(\alpha\beta)\gamma=\alpha(\beta\gamma)$
4. $\alpha(\beta+\gamma)=\alpha\beta+\alpha\gamma$

**证明 .** 直接归纳即可。注意第三条和第四条要用到冗余定理。

**推论 .**（多个数的乘法计算式）在证明第三条的归纳过程中，我们可以用归纳类似地证明：对于任何 $n$ 个序数 $\alpha_1,\alpha_2,\cdots,\alpha_n$，有：

$$
\prod_{i=1}^n\alpha_i=\operatorname{mex}\{\sum_{I\subsetneq\{1,2,\cdots,n\}}\prod_{j=1}^n\begin{cases}\alpha_j&j\in I\\\beta_j&j\not\in I\end{cases}|\beta_j<\alpha_j\}
$$

**定义 .** 对于任意序数 $\alpha>0$，定义

$$
S=\{0\}\cup\{\gamma^{-1}(1+(\alpha+\gamma)\delta)|0<\gamma<\alpha,\delta\in S\}
$$

则定义 $\alpha^{-1}=\operatorname{mex}(S)$。对于任意序数 $\alpha,\beta$，定义 $\alpha/\beta=\dfrac\alpha\beta=\alpha\beta^{-1}$。

（注：这个 $S$ 是一个递归的定义，即 $S$ 包含了上述操作在有限步以内能生成的所有数。）

**定理 .**

1. 对于任何序数 $\alpha>0$，设 $\beta$ 为 $\alpha^{-1}$ 的一排除项，则 $\alpha\beta\neq 1$。
2. 对于任何序数 $\alpha>0$，设 $\beta$ 为 $\alpha\alpha^{-1}$ 的一（冗余）排除项，$\beta\neq 1$。
3. 对于任何序数 $\alpha>0$，$\alpha\alpha^{-1}=1$。

**证明 .** 考虑归纳。

1. 若 $\beta=0$ 显然，否则设 $\beta=\gamma^{-1}(1+(\alpha+\gamma)\delta)$。则 $1+\alpha\beta=\gamma\gamma^{-1}+\alpha\beta=\gamma^{-1}(\alpha+\gamma+\alpha(\alpha+\gamma)\delta)=\gamma^{-1}(\alpha+\gamma)(1+\alpha\delta)$。显然 $\gamma^{-1}\neq 0$，又因 $\gamma<\alpha$ 有 $\alpha+\gamma$ 不为 $0$，根据归纳假设又有，$1+\alpha\delta$ 不为 $0$，故乘积不为 $0$，即证。
2. 设 $\beta=\gamma\alpha^{-1}+\alpha(\alpha^{-1})^*+\gamma(\alpha^{-1})^*$，其中 $(\alpha^{-1})^*$ 为 $\alpha^{-1}$ 的一排除项。若 $\gamma$ 等于 $0$，这就是前一条所证的。否则因为 $\lambda=\gamma^{-1}(1+(\alpha+\gamma)(\alpha^{-1})^*)$ 也为 $\alpha^{-1}$ 的一排除项，又因为 $\gamma\gamma^{-1}=1$，故 $\beta=1+\gamma(\alpha^{-1}+\lambda)\neq 1$。
3. 显然 $\alpha\alpha^{-1}\neq 0$，因为 $\alpha^{-1}\neq 0$。而由 2 得 $\alpha\alpha^{-1}$ 的排除项不含 $1$，即证。

## 扩张，扩张，扩张

**定理 .** 设 $\Delta$ 不对加法封闭，则 $\Delta=\alpha+\beta$，其中 $(\alpha,\beta)$ 为字典序最小的一对 $\Delta$ 的元素满足 $\alpha+\beta$ 不在 $\Delta$ 中。

**证明 .** 显然 $\alpha+\beta\ge \Delta$，但是 $\alpha+\beta$ 的排除项都在 $\Delta$ 中。（这是因为字典序更小了）即证。

**定理 .** 设 $\Delta$ 对加法封闭，则对于任意 $\alpha$ 和 $\beta\in \Delta$ 有 $[\Delta\alpha]+\beta=[\Delta\alpha+\beta]$。

（例. $4=\{0,1,2,3\}$ 对加法封闭，故 $8+3=[4\times2]+3=[4\times 2+3]=11$。）

**证明 .**  考虑归纳。左侧的排除项为：

- $[\Delta\alpha'+\gamma]+\beta$，其中 $\alpha'<\alpha,\gamma<\Delta$。这是因为带余除法。
- $[\Delta\alpha]+\delta$，其中 $\delta<\beta$。

根据归纳假设，左侧即为 $[\Delta\alpha']+(\beta+\gamma)$。而由于 $\Delta$ 形成一个群，$\beta+\gamma$ 恰好能取遍所有的 $\gamma'<\Delta$！故根据归纳假设，所有的排除项为 $[\Delta\alpha'+\gamma']$ 和 $[\Delta\alpha+\delta]$，这恰为所有小于 $[\Delta\alpha+\beta]$ 的数，即证。


**定理 .** 设 $\Delta$ 对加法封闭但不对乘法封闭，则 $\Delta=\alpha\beta$，其中 $(\alpha,\beta)$ 为字典序最小的一对 $\Delta$ 的元素满足 $\alpha\beta$ 不在 $\Delta$ 中。

（例. $8$ 对加法封闭但不对乘法封闭，字典序最小的 $(\alpha,\beta)=(2,4)$，故 $8=2\times4$。）

**证明 .** 显然 $\alpha\beta\ge \Delta$，但是 $\alpha\beta$ 的排除项都在 $\Delta$ 中。（这是因为字典序更小了，且加法封闭）即证。

**定理 .** 设 $\Delta$ 对加法和乘法封闭，对加法封闭的 $\Gamma\le \Delta$ 满足 $\Gamma$ 中的非零元都在 $\Delta$ 中有乘法逆元（即与其乘积为 $1$ 的元素），则对于任意 $\gamma\in \Gamma$，有 $\Delta\gamma=[\Delta\gamma]$。

（例. $4=\{0,1,2,3\}$ 对加法和乘法封闭，且 $4\le 4$ 中的所有非零元都在 $4$ 中有逆，故 $3\times 4=[3\times4]=12$。）

**证明 .** 考虑归纳。$\Delta\gamma$ 的排除项为 $\Delta\alpha+\beta\alpha+\beta\gamma,\beta<\Delta,\alpha<\gamma$。只需证对于任何 $\alpha<\gamma$，有 $\Delta\alpha+\beta(\alpha+\gamma)$ 能取遍所有 $[\Delta\alpha+\delta]=[\Delta\alpha]+\delta=\Delta\alpha+\delta$。取 $\beta=\delta(\alpha+\gamma)^{-1}$ 即可。 

**定理 .** 设 $\Delta$ 为对四则运算封闭但有些多项式方程无解，设 $p(x)$ 为系数在 $\Delta$ 中，在 $\Delta$ 中没有根的字典序最小的多项式（从高次项到低次项依次比较）。则 $p(\Delta)=0$。对于任何次数比 $p$ 小的多项式 $p'(x)$，有 $p'(\Delta)=[p'(\Delta)]$。

（注意序数乘法可能没有交换律，若 $p(x)=\sum \alpha_ix^i$，这里 $[p'(\Delta)]=\sum \Delta^i\alpha_i$，$i$ **从大到小加**。）

（例。 $4=\{0,1,2,3\}$ 对四则运算封闭，但是有无根多项式 $x^2+x+2=0$，故 $4^2=4+2=6$。）

（注：你问对加、乘封闭但没法做除法的情况去哪里了？事实上有，但是书中的证明有一定问题，而且我们用不到，就咕了。）

**证明 .** 设 $p$ 的次数为 $n$。对于任何一个 $N$，考虑 $\Delta^N$ 的排除项为：

$$
\prod_{i=1}^N\alpha_i=\operatorname{mex}\{\sum_{i=0}^{N-1}\sum_{I\subsetneq\{1,2,\cdots,N\},|I|=i}\Delta^i\prod_{j\not\in I}\beta_j|\beta_j<\alpha_j\}
$$

先归纳地证明若 $N<n$ 则 $N$ 次多项式 $p'(x)$ 有 $p'(\Delta)=[p'(\Delta)]$。

1. 先考虑 $\Delta^N$。只需证明它的排除项能取遍所有 $\sum\limits_{i=0}^{N-1}\Delta^i\gamma_i=[\sum\limits_{i=0}^{N-1}\Delta^i\gamma_i]$ 即可。考虑多项式 $q(x)=x^N+\sum\limits_{i=0}^{N-1} x^i\gamma_i$。因为 $<n$ 次多项式均有根，它一定可以因式分解为一次因式。设其根为 $\delta_1,\delta_2,\cdots,\delta_n$，重根算多次。根据 Vieta 定理，$\beta_j=\delta_j$ 即为所求。
2. 再考虑 $\Delta^N\delta$，其中 $\delta\in \Delta$。它的排除项为 $\{\Delta^N\gamma+q(\Delta)(\gamma+\delta)|\gamma<\delta,\deg q<N,[x^i]q(x)\in \Delta\}$。只需证明对于任何 $\gamma$，$q(\Delta)(\gamma+\delta)$ 能取遍每个 $q'(\Delta)$ 即可。因为 $\gamma+\delta\in \Delta$，故其有逆元，而根据归纳假设，次数更小的多项式乘 $\Delta$ 的元素正常乘即可，故取 $q(x)=q'(x)(\gamma+\delta)^{-1}$ 即可。
3. 再考虑 $p'(\Delta),\deg p'=N$。根据归纳假设，次数更小的多项式加法是正常算的，故 $\Delta^N$ 为一个群。因此设 $p'(x)=x^N\delta+q'(x)$，则 $p'(\Delta)=\Delta^N\delta+q'(\Delta)=[\Delta^N\delta]+[q'(\Delta)]=[\Delta^N\delta+q'(\Delta)]=[p'(\Delta)]$。

再证 $p(\Delta)=0$。设 $p(x)=x^n+q(x)$（显然，若最高次项系数不为 $1$，则系数均乘以其逆元字典序更小）。考虑 $\Delta^n$。和以上过程类似，比 $q(\Delta)$ 小（等价于字典序小）的均为 $\Delta^n$ 的排除项。但 $q(\Delta)$ 不是，否则根据 Vieta 定理 $p$ 就在 $\Delta$ 内有根了。因此 $\Delta^n=q(\Delta)$，即 $p(\Delta)=0$。

**定理 .** 设 $\Delta$ 对四则运算封闭，且所有多项式方程均有根。则对于任意多项式 $p(x)$ 有 $p(\Delta)=[p(\Delta)]$。

**证明 .** 和上述定理类似。

**推论 .** 设 $\Delta$ 对四则运算封闭，$\Delta$ 不是任何 $\Delta$ 上多项式方程的根。

## 加法

**定理 .** 若 $\Delta$ 对加法封闭，则下一个对加法封闭的序数为 $[\Delta2]$。

**证明 .** 显然 $\{x|x<\Delta\}$ 和 $\{\Delta+x|x<\Delta\}$ 两两不同，所以至少要包含它们。所以 $<[\Delta2]$ 的不对加法封闭。而因为 $[\Delta+x]=\Delta+x$，所以 $[\Delta2]$ 对加法封闭。

**定理 .** 每个序数 $\alpha$ 都可以写成 $[2^{\beta_0}+2^{\beta_1}+\cdots+2^{\beta_{n-1}}]$，其中 $n$ 有限，$\beta$ 严格递减。且 $\alpha=[2^{\beta_0}]+[2^{\beta_1}]+\cdots+[2^{\beta_{n-1}}]$。

（例如，$6=[2^2+2^1]=[2^2]+[2^1]=4+2$。）

（注：这也就说明了加法就是异或。）

**证明 .** 设 $\alpha>0$，则取最大的 $2^\beta\le \alpha$，设 $\alpha=[2^\beta+\gamma]$，显然 $\gamma<2^\beta$，故 $\alpha=[2^\beta]+\gamma$。归纳即可。

## 扩张（试试看！）

来试着通过扩张的几个定理来扩张，得到一些对四则运算封闭的序数吧！

首先最小的非平凡的肯定是 $2=\{0,1\}$。我们知道，接下来需要找到一个无解方程。显然一次方程就是除法，不可能无解。二次方程呢？对于有限的对四则运算封闭的 $n$，如果有一个无解的二次方程，那下一个就是对四则运算封闭的 $[n^2]=\{[an+b]|a<n,b<n\}=\{an+b|a<n,b<n\}$ 了。（记 $n$ 为 $\mathbb F_n$，这其实就是 $\mathbb F_n[x]/p(x)$，其中 $p(x)$ 为字典序最小的无根多项式）

**定理 .** 对于有限的 $n$，若 $n$ 对四则运算封闭，则对任意 $a<n$，存在 $b<n$，$b^2=a$。

**证明 .** 显然 $c\to c^2(c<n)$ 为单射，故为满射。

所以不需要考虑 $x^2$ 型的了。那 $x^2+x$ 呢？

**定理 .** 对于有限的 $n>1$，若 $n$ 对四则运算封闭，恰有半数 $a<n$，满足不存在 $b<n$，$b^2+b=a$。

**证明 .** 显然 $c^2+c=d^2+d$ 当且仅当 $(c+d)(c+d+1)=0$，即 $c=d$ 或 $c=d+1$，故恰有一半的 $c^2+c$ 能被取到。

因此有限情况的扩张都是 $x^2+x+a$，于是我们做完了……？等等扩张完还是封闭的吗？显然加、乘是封闭呢。除呢？（其实有更一般的关于扩张的证明，但是这里不必要）

**定理 .** 对于有限的 $n$，若 $n$ 对加法、乘法封闭，则 $n$ 对四则运算封闭。

**证明 .** 设 $c\neq 0$，则 $x\to cx(x<n)$ 为单射，故为满射，故存在 $cx=1$。

好，于是我们有：

**定理 .** 所有有限的对四则运算封闭的序数为：

$$2,4,16,\cdots,[2^{2^n}],\cdots$$

其中每一个是上一个的[平方]。

**证明 .** 刚才所讨论的就是这个。

**推论 .** 若 $k<[2^{2^n}]$，则 $2^{2^n}k=[2^{2^n}k]$。

等等，知道是域有什么用，到底怎么算啊？$2\to 4$ 的过程中，最小的无解方程为 $x^2+x+1$，故 $2^2=2+1=3$。$4\to 16$ 的过程中，最小的无解方程为 $x^2+x+2$，故 $4^2=4+2=6$。在 $16\to 256$ 的过程中呢？对于每个 $x<16$ 计算 $x^2+x$，发现恰好是 $0\sim 7$ 各一个……？因此 $16^2=16+8=24$。

更一般地，我们考虑证明：

**定理 .**

1. 对于任何非负整数 $n$，若 $x<[2^n]$，则 $x^2<[2^n]$。
2. 对于任何正整数 $x$，$x$ 与 $x^2$ 的最高位相同。换言之，若 $x<[2^{n+1}]$，则 $x^2+x<[2^n]$。
3. 对于任何非负整数 $n$，$\{x^2+x|x<[2^{2^n}]\}=[2^{2^n-1}]$
4. 对于任何非负整数 $n$，$[2^{2^n}]^2=[\dfrac32\times2^{2^n}]$。

**证明 .** 以下归纳不会出现循环论证交给读者作为练习。

1. 因为 $(x+y)^2=x^2+y^2$，且 $[2^n]$ 是一个群，因此只需证明 $x=[2^k]$ 的情况 $x^2<[2^{k+1}]$ 即可。设 $k=\sum [2^{a_i}]$，则 $x=\prod [2^{2^{a_i}}]$。（因为 $[2^{2^{a_i}}]$ 对四则运算封闭，所以乘法和直接乘没区别）因此 $x^2=\prod [2^{2^{a_i}}]^2$。依归纳假设，这即为 $x^2=\prod [2^{2^{a_i}}]+[2^{2^{a_i}-1}]$。按照乘法分配律展开后，每一项的[普通]积都不超过 $[2^{k}]$，因此 Nim 积也不超过 $[2^k]$（因为 Nim 积的排除项个数为普通积），即小于 $[2^{k+1}]$，故和小于 $[2^{k+1}]$。
2. 根据 1.，有 $y\to y^2$ 是 $[2^n]$ 到 $[2^n]$ 的双射，同时也是 $[2^{n+1}]$ 到 $[2^{n+1}]$ 的双射，因此是 $[2^{n+1}]\backslash [2^n]$ 到自身的双射，即证。自然推出后半句。
3. 之前证明过前者的大小刚好为 $[2^{2^n-1}]$，而取值范围也在 $[2^{2^n-1}]$ 内，即证。
4. 根据 3.，最小需要扩展的多项式为 $p(x)=x^2+x+[2^{2^n-1}]$，即 $[2^{2^n}]^2=[2^{2^n}]+[2^{2^n-1}]=[2^{2^n}+2^{2^n-1}]=[\dfrac 32\times2^{2^n}]$。

## 计算

那么问题来了，我们怎么对 Nim 数进行计算呢？

**定理 .** 假设位运算的时间复杂度为 $O(1)$，则存在 $O(1)$ 的算法，给定 $a,b<[2^{2^k}]$，计算 $a+b$。

**证明 .** 之前证明了 $a+b$ 是异或，调用即可。

**定理 .** 假设位运算的时间复杂度为 $O(1)$，则存在 $O(3^k)$ 的算法，给定 $k,a<[2^{2^k}]$，计算 $a[2^{2^k-1}]$。

**证明 .** $k=0$ 时可以 $O(1)$ 计算。若 $k\ge 1$，设 $\alpha=[2^{2^k-1}],B=[2^{2^{k-1}}],\beta=[2^{2^{k-1}-1}]$，则 $\alpha=B\beta$。设 $a=[Bp+q]=Bp+q$，则 $a\alpha=aB\beta=\beta B(Bp+q)=B^2\beta p+B\beta q=\beta p(B+\beta)+\beta qB={\color{red}(p+q)\beta}B+{\color{blue}p\beta\beta}$。递归计算 $L=(p+q)\beta,R_0=p\beta,R=R_0\beta$，则答案为 $LB+R=[LB+R]$。时间复杂度 $T(k)=3T(k-1)+O(1)=O(3^k)$。

**定理 .** 假设位运算的时间复杂度为 $O(1)$，则存在 $O(k3^k)$ 的算法，给定 $a,b<[2^{2^k}]$，计算 $ab$。

**证明 .** $k=0$ 时可以 $O(1)$ 计算。若 $k\ge 1$，设 $B=[2^{2^{k-1}}],\beta=[2^{2^{k-1}-1}]$。设 $a=pB+q,b=rB+s$，则 $ab=(pB+q)(rB+s)=prB^2+(ps+qr)B+qs=pr(B+\beta)+(ps+qr)B+qs=(pr+ps+qr)B+pr\beta+qs$。递归计算 $L_0=(p+q)(s+r),L_1=qs,L=L_0+L_1,R_0=pr,R_1={\color{red}R_0\beta},R=R_1+L_1$，则答案为 $LB+R=[LB+R]$。时间复杂度 $T(k)=3T(k-1)+O(3^k)=O(k3^k)$。

## 关于本题

我们还需要证明一个性质：

**定理 .** 对于对四则运算封闭的 $n=[2^{2^k}]$，任意 $x<n$ 有 $x^n=x$。

**证明 .** $x=0$ 时显然。否则 $y\to xy$ 是 $n$ 到本身的双射，且 $0$ 映射到 $0$。因此 $\prod\limits_{y=1}^{[n-1]}y=\prod\limits_{y=1}^{[n-1]}xy$，两边消去 $\prod\limits_{y=1}^{[n-1]}y$ 可得 $x^{[n-1]}=1$，即 $x^n=x$。

以上。

---

## 作者：Zhao_daodao (赞：19)

# P11278 绝世丑角

因为所有的 Nim 积操作都是跟自己操作，所以简化定义。

定义 $f(x)=x\otimes x$。

你打出了一点表：`0,1,3,2,6,7,5,4,13,12,14,15,11,10,8,9`。

然后，使用 [oeis.org](https://oeis.org/)，查询到了这个东西，叫做 `nim-square`。

观察描述，发现这个东西由每一个的二进制位构成。

比如说：
$$
f(11)=f((1011)_2)\\
=f((1000)_2)\oplus f((10)_2)\oplus f((1)_2)\\
=13\oplus 3\oplus 1\\
=15
$$
那对于 `2` 的幂次如何处理呢？你点进去，发现有另一个东西。

[A006017 - OEIS](https://oeis.org/A006017)，描述的就是 $f(2^i)$，点进去，找到 [oeis.org/A006017/b006017.txt](https://oeis.org/A006017/b006017.txt)，是 $i\in[0,255]$ 的表。

好了，你现在能够 $O(\log n)$ 的时间内求出 $f(n)$。

---

定义 $f^n(x)=f(f^{n-1}(x))$。

将随便一个 $x$ 写出来，发现 $f^{32}(x)=x$。所以有 `32` 的循环节。

使用线段树的数据结构！

维护每一个区间的区间和，区间异或和。

一共维护 `32` 个值，表示这个区间整个被操作 $[0,31]$ 次之后的区间和，区间异或和。

然后就是线段树区间修改，区间查询的板子了。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=2.5e5+5;
int p[]={1,3,6,13,24,52,103,222,384,832,1648,3552,6237,13563,26511,56906,98304,212992,421888,909312,1596672,3472128,6786816,14567936,25190110,54589881,108036850,232800673,408783316,888883132,1737454078,3729449897};
int n,q,a[MAXN];
inline int f(int x){
    int res=0;
    for(int i=31;i>=0;i--)if(x>>i&1){
        res^=p[i];
    }
    return res;
}
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
struct Tree{
    int tr[2][32],laz;
    inline void init(int x){
        tr[0][0]=tr[1][0]=x;
        for(int i=1;i<=31;i++){
            tr[0][i]=tr[1][i]=f(tr[0][i-1]);
        }
    }
}tr[MAXN<<2];
inline void push_up(int q){
    for(int i=0;i<=31;i++){
        tr[q].tr[0][i]=tr[ls(q)].tr[0][i]+tr[rs(q)].tr[0][i];
        tr[q].tr[1][i]=tr[ls(q)].tr[1][i]^tr[rs(q)].tr[1][i];
    }
}
int X[33],Y[33];
inline void turn(int q,int Tim){
    for(int i=0;i<=31;i++){
        X[i]=tr[q].tr[0][i];
        Y[i]=tr[q].tr[1][i];
    }
    for(int i=0;i<=31;i++){
        tr[q].tr[0][i]=X[(i+Tim)%32];
        tr[q].tr[1][i]=Y[(i+Tim)%32];
    }
}
inline void push_down(int q){
    if(!tr[q].laz)return ;
    turn(ls(q),tr[q].laz);tr[ls(q)].laz+=tr[q].laz;
    turn(rs(q),tr[q].laz);tr[rs(q)].laz+=tr[q].laz;
    tr[q].laz=0;
}
void build(int l,int r,int q){
    if(l==r){
        tr[q].laz=0;
        tr[q].init(a[l]);
        return ;
    }
    int mid=l+r>>1;
    build(l,mid,ls(q)),build(mid+1,r,rs(q));
    push_up(q);
}
void update(int l,int r,int ql,int qr,int q){
    if(ql<=l&&r<=qr){
        turn(q,1);tr[q].laz++;
        return ;
    }
    int mid=l+r>>1;
    push_down(q);
    if(ql<=mid)update(l,mid,ql,qr,ls(q));
    if(mid<qr)update(mid+1,r,ql,qr,rs(q));
    push_up(q);
}
int query0(int l,int r,int ql,int qr,int q){
    if(ql<=l&&r<=qr)return tr[q].tr[0][0];
    int mid=l+r>>1,res=0;
    push_down(q);
    if(ql<=mid)res+=query0(l,mid,ql,qr,ls(q));
    if(mid<qr)res+=query0(mid+1,r,ql,qr,rs(q));
    return res;
}
int query1(int l,int r,int ql,int qr,int q){
    if(ql<=l&&r<=qr)return tr[q].tr[1][0];
    int mid=l+r>>1,res=0;
    push_down(q);
    if(ql<=mid)res^=query1(l,mid,ql,qr,ls(q));
    if(mid<qr)res^=query1(mid+1,r,ql,qr,rs(q));
    return res;
}
signed main(){
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);
    cin>>n>>q;
    for(int i=1;i<=n;i++)cin>>a[i];
    build(1,n,1);
    while(q--){
        int opt,l,r;cin>>opt>>l>>r;
        if(opt==1){
            update(1,n,l,r,1);
        }
        if(opt==2){
            int res=query1(1,n,l,r,1);
            cout<<res<<"\n";
        }
        if(opt==3){
            int res=query0(1,n,l,r,1);
            cout<<res<<"\n";
        }
    }
}
```

---

## 作者：bcdmwSjy (赞：14)

神仙题，根本不会 Nim 积的人（包括我）也就只能得 13 分了。

对于一些二维 Nim 游戏，可以拆分成两维单独的 Nim 游戏然后求 Nim 积，$a$ 和 $b$ 的 Nim 积定义为

$$$x\otimes y=\operatorname{mex}\{(a\otimes b)\oplus(a\otimes y)\oplus(x\otimes b),0\le a<x,0\le b<y\}$$$

其中 $\otimes$ 为 Nim 积，$\oplus$ 为异或。

在数学家们的不断努力下 ~~（其实是我不会证）~~，发现 Nim 积有如下性质：

$x\otimes y=x\otimes y,x\otimes0=0\otimes x=0,x\otimes1=1\otimes x=x$，说明 $0$ 和任何数 Nim 积都等于 $0$，$1$ 和任何数 Nim 积都等于它本身，且具有交换律。

$(x\otimes y)\otimes z=x\otimes(y\otimes z)$，具有结合律。

定义 $\operatorname{Fermat\ 2-power}$ 为 $x=2^{2^n},n\in\mathbb{N}$。

1. 一个 $\operatorname{Fermat\ 2-power}$ 与小于自己的数的 Nim 积为正常的乘积，$x\otimes y=xy(y<x)$。

2. 一个 $\operatorname{Fermat\ 2-power}$ 与自己的 Nim 积为 $\frac{3}{2}x$。

现在的问题是如何求两个数的 Nim 积，暴力求的复杂度是 $O(x^2y^2)$ 的，但是可以利用一些性质在 $O(\log x\log y)$ 的时间复杂度内求出。

设 $f(x,y)=x\otimes y$，特判边界后，可以拆位计算每个二进制的贡献。

设 $g(x,y)=2^x\otimes2^y$，那么 $f(x,y)$ 就等于 $x$ 和 $y$ 每一位 $g$ 的异或和。

接下来考虑如何求 $g(x,y)$，仍然是拆位，拆成一些 $\operatorname{Fermat\ 2-power}$，那么

$$g(x,y)=2^x\otimes2^y=\left(\bigotimes\limits_{x'\in x}2^{2^{x'}}\right)\otimes\left(\bigotimes\limits_{y'\in y}2^{2^{y'}}\right)$$

从高到低考虑每一位，如果 $x$ 和 $y$ 在这一位上都为 $0$ 就可以跳过。

先处理 $x$ 和 $y$ 在这一位上只有一个为 $1$ 的情况：

$\operatorname{Fermat\ 2-power}$ 和比自己小的数的 Nim 积就是乘积，从高到低计算即可。

再看 $x$ 和 $y$ 在这一位上都为 $1$ 的情况：

根据结合律，可以把这一位单独拿出来算，再根据 $\operatorname{Fermat\ 2-power}$ 的特点，可以得出 $\left(2^{2^{x_u'}}\right)\otimes\left(2^{2^{y_u'}}\right)=\frac{3}{2}\times2^{2^u}=3\times2^{2^u-1}$

总结一下上面的情况，可以得出

$$\begin{aligned} 2^x\otimes2^y&=\left(\bigotimes\limits_{i\in x\operatorname{xor}y}2^{2^i}\right)\otimes\left(\bigotimes\limits_{i\in x\operatorname{and}y}3\times2^{2^i-1}\right)
\\
&=\left(\prod\limits_{i\in x\operatorname{xor}y}2^{2^i}\right)\otimes\left(\bigotimes\limits_{i\in x\operatorname{and}y}3\times2^{2^i-1}\right)\end{aligned}$$

前面的直接算，后面的用 $f$ 递归计算即可。

每次只会遍历 $x$ 和 $y$ 的二进制位，复杂度为 $O(\log x\log y)$，记得给 $g$ 记忆化一下，这样复杂度才对。

于是我们可以得到以下代码：

```cpp
ll mem[128][128];

ll f(ll,ll);

ll g(int x,int y) {
    if (x==0 or y==0) return 1ll<<(x|y);
    if (mem[x][y]!=-1) return mem[x][y]; 
    ll res=1;
    for (int u=(x^y),i=0;(1<<i)<=u;i++){
        if ((u>>i)&1){
            res<<=(1ll<<i);
        }
    }
    for (int u=(x&y),i=0;(1<<i)<=u;i++){
        if ((u>>i)&1){
            res=f(res,3ll<<((1<<i)-1));
        }
    }
    return mem[x][y]=res;
}

ll f(ll x,ll y) {
    if (x==0 or y==0) return x|y;
    if (x==1 or y==1) return max(x,y);
    ll res=0;
    for (int i=0;(1ll<<i)<=x;i++){
        if ((x>>i)&1){
            for (int j=0;(1ll<<j)<=y;j++){
                if ((y>>j)&1){
                    res^=g(i,j);
                }
            }
        }
    }
    return res;
}
```

那这些有和这道题有什么关系呢，~~又经过数学家的不懈努力，~~ 我们得到一个数和它自己的 Nim 积是有循环节的，并且长度是 $O(\log x)$ 的，在本题中，循环节最长就是 $32$ 的。

于是，我们可以先预处理出每个数的循环节，再用线段树维护加和还有异或和，修改时把数据旋转一位即可。

但是，这真的做完了吗，仔细分析一下，共有 $n$ 个数，每个数的循环节是 $\log w$ 的，求 Nim 积是时间复杂度是 $O(\log^2 w)$ 的，光建树就是 $O(n\log^3 w)$ 的，根本过不去。

但是我们发现 Nim 积的高位和低位可以分别计算，于是我们把它分成前 $16$ 位和后 $16$ 位预处理出自己和自己的 Nim 积和 Nim 积的 $k$ 次方。

```cpp
ll prod_high[65536],prod_low[65536],pw_high[65536][32],pw_low[65536][32];

ll prod(ll x){
	return prod_high[x>>16]^prod_low[x&65535];
}

ll pw(ll x,int k){
	return pw_high[x>>16][k]^pw_low[x&65535][k];
}

void init(){
	for (ll i=0;i<65536;i++){
		for (int j=0;j<32;j++){
			if (i&(i-1)){
				prod_high[i]=prod_high[i&(i-1)]^prod_high[i&(-i)];
				prod_low[i]=prod_low[i&(i-1)]^prod_low[i&(-i)];
			}else{
				prod_high[i]=f(i<<16,i<<16);
				prod_low[i]=f(i,i);
			}
		}
	}
	for (ll i=0;i<65536;i++){
		pw_high[i][0]=i<<16;
		pw_low[i][0]=i;
	}
	for (int i=0;i<65536;i++){
		for (int j=1;j<32;j++){
			pw_high[i][j]=prod(pw_high[i][j-1]);
			pw_low[i][j]=prod(pw_low[i][j-1]);
		}
	}
}
```

其中 prod 用来计算自己和自己的 Nim 积，pw 计算自己 Nim 积的 $k$ 次方，这样我们就可以快速计算 Nim 积了。

完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll mem[128][128];

ll f(ll,ll);

ll g(int x,int y) {
    if (x==0 or y==0) return 1ll<<(x|y);
    if (mem[x][y]!=-1) return mem[x][y]; 
    ll res=1;
    for (int u=(x^y),i=0;(1<<i)<=u;i++){
        if ((u>>i)&1){
            res<<=(1ll<<i);
        }
    }
    for (int u=(x&y),i=0;(1<<i)<=u;i++){
        if ((u>>i)&1){
            res=f(res,3ll<<((1<<i)-1));
        }
    }
    return mem[x][y]=res;
}

ll f(ll x,ll y) {
    if (x==0 or y==0) return x|y;
    if (x==1 or y==1) return max(x,y);
    ll res=0;
    for (int i=0;(1ll<<i)<=x;i++){
        if ((x>>i)&1){
            for (int j=0;(1ll<<j)<=y;j++){
                if ((y>>j)&1){
                    res^=g(i,j);
                }
            }
        }
    }
    return res;
}

ll prod_high[65536],prod_low[65536],pw_high[65536][32],pw_low[65536][32];

ll prod(ll x){
	return prod_high[x>>16]^prod_low[x&65535];
}

ll pw(ll x,int k){
	return pw_high[x>>16][k]^pw_low[x&65535][k];
}

void init(){
	for (ll i=0;i<65536;i++){
		for (int j=0;j<32;j++){
			if (i&(i-1)){
				prod_high[i]=prod_high[i&(i-1)]^prod_high[i&(-i)];
				prod_low[i]=prod_low[i&(i-1)]^prod_low[i&(-i)];
			}else{
				prod_high[i]=f(i<<16,i<<16);
				prod_low[i]=f(i,i);
			}
		}
	}
	for (ll i=0;i<65536;i++){
		pw_high[i][0]=i<<16;
		pw_low[i][0]=i;
	}
	for (int i=0;i<65536;i++){
		for (int j=1;j<32;j++){
			pw_high[i][j]=prod(pw_high[i][j-1]);
			pw_low[i][j]=prod(pw_low[i][j-1]);
		}
	}
}

int n,q;
ll a[250001];

struct Node{
	ll x[32],s[32];
	Node(){
		memset(x,0,sizeof(x));
		memset(s,0,sizeof(s));
	}
	inline void calc(int t){
		rotate(x,x+t,x+32);
		rotate(s,s+t,s+32);
	}
};

struct Tree{
    int l,r,tag;
    Node val;
};

Tree tr[524289];

#define ls (i<<1)
#define rs (i<<1|1)

void pushup(int i){
    for (int j=0;j<32;j++){
		tr[i].val.x[j]=tr[ls].val.x[j]^tr[rs].val.x[j];
		tr[i].val.s[j]=tr[ls].val.s[j]+tr[rs].val.s[j];
	}
}

void pushdown(int i){
	if (tr[i].tag){
		tr[ls].val.calc(tr[i].tag);
		tr[rs].val.calc(tr[i].tag);
		tr[ls].tag=(tr[ls].tag+tr[i].tag)&31;
		tr[rs].tag=(tr[rs].tag+tr[i].tag)&31;
		tr[i].tag=0;
	}
}

void build(int i,int l,int r){
    tr[i].l=l;
    tr[i].r=r;
    if (l==r){
        for (int j=0;j<32;j++){
        	tr[i].val.s[j]=tr[i].val.x[j]=pw(a[l],j);
		}
        return;
    }
    int mid=(l+r)>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    pushup(i);
}

void update(int i,int l,int r){
    if (tr[i].l>=l and tr[i].r<=r){
    	tr[i].val.calc(1);
    	tr[i].tag=(tr[i].tag+1)&31;
        return;
    }
    pushdown(i);
    if (tr[ls].r>=l) update(ls,l,r);
    if (tr[rs].l<=r) update(rs,l,r);
    pushup(i);
}

ll querys(int i,int l,int r){
    if (tr[i].l>=l and tr[i].r<=r) return tr[i].val.s[0];
    pushdown(i);
    ll ans=0;
    if (tr[ls].r>=l) ans+=querys(ls,l,r);
    if (tr[rs].l<=r) ans+=querys(rs,l,r);
    return ans;
}

ll queryx(int i,int l,int r){
    if (tr[i].l>=l and tr[i].r<=r) return tr[i].val.x[0];
    pushdown(i);
    ll ans=0;
    if (tr[ls].r>=l) ans^=queryx(ls,l,r);
    if (tr[rs].l<=r) ans^=queryx(rs,l,r);
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    memset(mem,-1,sizeof(mem));
	init(); 
	cin>>n>>q;
    for (int i=1;i<=n;i++){
        cin>>a[i];
    }
    build(1,1,n);
    while (q--){
        int op,l,r;
        cin>>op>>l>>r;
        if (op==1){
            update(1,l,r);
        }else if (op==2){
            cout<<queryx(1,l,r)<<"\n";
        }else if (op==3){
            cout<<querys(1,l,r)<<"\n";
        }
    }
    return 0;
}
```

---

闲话：赛时写 13 分暴力时错了好多发，原因是线段树传参没开 long long，然后赛后写正解时用了之前的代码，导致线段树区间修改一直递归到叶子节点然后 T 到 13 分，卡了好久常才意识到我自己写错了，以后记得注意一下。

---

## 作者：Galois_Field_1048576 (赞：8)

一篇注重证明的题解。

Nimber 积科普题。首先，不难看出这是一道线段树题。我们在此列出作为一个线段树能维护的代数结构：

> 两个幺半群 $M_1, M_2$，附加幺半群同态 $M_1 \to \mathrm{End}_{\sf Mon}(M_2)$。此时，$M_1$ 被称为 **lazytag 类型**，$M_2$ 被称为**节点类型**。
>
> 换句话说：你的节点类型存在一种拼接组合的方式，它满足结合律，且存在一个 identity tag $e$ 使得 $f \cdot e = e \cdot f = f$；你的 lazytag 类型 $f \in M_1$ 应该满足结合律、且存在一个不进行作用的 tag（幺元），并且可以将其作用在一个节点 $m \in M_2$ 上，得到 $f(m)$。这样的节点是可以分裂的，也就是说如果 $m = m_1 \cdot m_2$，则 $f(m) = f(m_1) \cdot f(m_2)$。

后文，记 $*_n$ 为某个 $< n$ 的自然数，例如异或的定义可以写为：
$$
n \oplus m = \mathrm{mex}\{n \oplus *_m, m \oplus *_n\},
$$
同时 $\{0, 1, \dots, n - 1\}$ 可以写为 $\{ *_n \}$。

观察 Nimber 积的定义发现，如果我们按照 von Neumann 的自然数构造，认为 $n = \{*_n\}$ 的话，则我们实际上可以把 Nimber 积推广到任意的集合上：
$$
\begin{aligned}
S \oplus T = \{\sigma \oplus T, S \oplus \tau \mid \sigma \in S, \tau \in T\}; \\
S \otimes T = \{\sigma \otimes T \oplus S \otimes \tau \oplus \sigma \otimes \tau \mid \sigma \in S, \tau \in T\}.
\end{aligned}
$$

考虑 Nimber 积
$$
n \otimes m = \mathrm{mex}\{ n \otimes *_m \oplus *_n \otimes m \oplus *_n \oplus *_m \}
$$
的代数性质：

* 如果 $\mathrm{mex}(S) = n, \mathrm{mex}(T) = m$，则 $\mathrm{mex}(S \oplus T) = n \oplus m, \mathrm{mex}(S \otimes T) = n \otimes m$。
* $n \otimes m = m \otimes n$；
* $n \otimes 0 = 0$；
* $n \otimes 1 = 1$；
* $n \otimes (x \oplus y) = n \otimes x \oplus n \otimes y$；
* $n \otimes (x \otimes y) = (n \otimes x) \otimes y$。
* 若 $x, y \ne 0$，则 $x \otimes y \ne 0$。

（证明均为展开定义。）另外，我们暂且承认若 $x, y < 2^{2^N}$，则 $x \otimes y < 2^{2^N}$。这些点告诉我们：

**定理.** 设 $1 \le x < 2^{2^N}$，则存在 $y$，使得 $x \otimes y = 1$。换句话说，$\{*_{2^{2^N}}\}$ 是域（本文很少会用到抽象代数知识，放心阅读）。

*证明.* 设 $S = [1, 2^{2^N}) \cap \mathbb Z$，固定 $x \in S$，则考虑映射 $f_x : S \to S$：$a \mapsto x \otimes a$。我们发现：$f_x$ 是单射，这是因为 $x \otimes a=x \otimes b \implies x \otimes (a \oplus b) = 0 \implies x = 0$ 或 $a \oplus b = 0$，而 $x \ne 0$ 导出 $a = b$。根据小学奥数中的鸽巢原理，$f_x$ 是双射。取 $y = f_x^{-1}(1)$ 即可。

**定理.** $\{*_{2^{2^N}}\}$ 存在原根。换句话说，存在一个 $g$，使得 $\{1, g, g^2, \dots, g^{2^{2^N}-2}\} = [1, 2^{2^n})$，其中 $g^k$ 指的是
$$
\underset{k}{\underbrace{g \otimes \dots \otimes g}}.
$$

*证明.* 引入概念：称 $\omega \in \mathbb C$ 是 **$n$ 次本原单位根**，若 $\min\{k \in \mathbb Z_{> 0} : \omega^k = 1\} = n$。定义**分圆多项式**为
$$
\Phi_n(z) = \prod_{\omega : n~\text{次本原单位根}} (z-\omega).
$$
于是断言：$\Phi_n$ 的每一个多项式系数均为整数。

证明：根据 Möbius 反演的乘性版本，有
$$
\Phi_n(z) = \prod_{d \mid n} (z^d - 1)^{\mu(n / d)},
$$
所以 $\Phi_n$ 的每一个多项式系数均为有理数。

引入符号 $\gcd(f)$ 代表 $f$ 的多项式系数的最大公约数（最大公约数一个概念可以平凡地延拓到有理数上），则我们有 Gauß 引理：$\gcd(fg) = \gcd(f) \cdot \gcd(g)$（证明：不妨设 $\gcd(f) = \gcd(g) = 1$，则 $f, g$ 均是整系数多项式，所以 $\gcd(fg)$ 是整数；而若素数 $p \mid \gcd(fg)$，则 $(fg) \bmod p = 0$，而 $f \bmod p$ 和 $g \bmod p$ 均不等于 $0$，导出矛盾。）

现在我们证明更强的命题：$\gcd(\Phi_n) = 1$。进行归纳，则 $n = 1 \implies \Phi_1(z) = z - 1$，因此命题成立；根据分圆多项式的定义，有
$$
z^n - 1 = \Phi_n(z) \cdot \prod_{d < n} \Phi_d(z) = \Phi_n(z) \cdot R(z),
$$
根据 Gauß 引理，$\gcd(R) = 1$，因此 $\gcd(\Phi_n) = 1$。完成归纳。

现在，我们设 $\Psi_n = \Phi_n \bmod 2$。这样，我们有
$$
\prod_{d \mid n} \Psi_d(X) \equiv X^n - 1 \pmod 2,
$$
所以，如果我们设 Nimber 上的 $\oplus$ 为加法，$\otimes$ 为乘法，则 $\Psi_n(m) = 1$ 当且仅当 $m$ 是 Nimber 中的 $n$ 次本原单位根。对 $\Psi_n$ 在 Nimber 中因式分解得 $n$ 次本原单位根至多有 $\varphi(n)$ 个，设这个个数为 $c_n$。因此，我们有
$$
2^{2^N}-1 = \sum_{d \mid (2^{2^N} - 1)} c_d \le \sum_{d \mid (2^{2^N} - 1)} \varphi(d) = 2^{2^N}-1,
$$
由于两边相等，所以不等号取等，所以 $c_d = \varphi(d)$，进而，$c_{2^{2^N}-1} \ne 0$。

注：$N = 4$ 时，一个可能的原根取值为 $2\ 024$。

**推论 (Fermat 小定理).** 设 $n < 2^{2^N}$，则 $n^{2^{2^N}} = n$。

现在，回归题目。在题目中，我们每次操作进行一次平方。这样，平方 $2^N$ 次后我们将回归原状。考虑维护的节点类型为 $2 \times 2^N$ 个数 $(\Sigma_k, O_k)$，其中 $\Sigma_k$ 代表对这个区间进行平方操作 $k$ 次的和，而 $O_k$ 代表对这个区间进行平方操作 $k$ 次的异或（i.e. Nim 和）。这样，lazytag 就无非是操作次数（属于 $[0, 31)$）。

于是，我们得到了一个问题：如何切实地计算 Nimber 平方？解法是：观察到平方是线性的，也就是说
$$
(a \oplus b) \otimes (a \oplus b) = a \otimes a \oplus b \otimes b.
$$
这样我们只需要预处理出 $2^k$ 的 Nimber 平方即可。于是我们就成功地，做完了。

*补充证明.* 我们还没有证明若 $x, y < 2^{2^N}$，则 $x \otimes y < 2^{2^N}$ 啊喂！首先，我们引入一个映射 $\wp : x \mapsto x^2+x$，它是线性的。我们尝试利用这个映射，从 $\{*_2\}$ 这个最小的域开始慢慢搭建更大的域。

设我们已知 $\mathbb F = \{*_m\}$ 是域，我们想要证明 $\{*_{m^2}\}$ 是域。我们现在可以证明，$n < m$，则 $n \otimes m = n \cdot m$，其中等号右面是通常意义的积（$*_n \otimes m$ 是归纳假设，$(n \oplus *_n) \otimes *_m$ 是一个求逆的问题）。我们说明 $\wp(m)$ 恰好是 $\mathrm{mex}\{\wp(\mathbb F)\}$：这是因为我们可以用归纳法证明 $\wp(\mathbb F)$ 是一个区间，而这个归纳法恰在 $m$ 处失效。这样我们就证完了。

这一定理被称为**扩张定理**。

---

代码环节：

```cpp
#include <bits/stdc++.h>
using namespace std;

/* code of lazy_segtree copied from Atcoder Library. */

namespace Nimber {
using nim = unsigned int;

array<nim, 32> square_table = {
    1u,          3u,         6u,         13u,        24u,        52u,
    103u,        222u,       384u,       832u,       1648u,      3552u,
    6237u,       13563u,     26511u,     56906u,     98304u,     212992u,
    421888u,     909312u,    1596672u,   3472128u,   6786816u,   14567936u,
    25190110u,   54589881u,  108036850u, 232800673u, 408783316u, 888883132u,
    1737454078u, 3729449897u};

nim square(nim x) {
    nim ret = 0;
    for (int i = 0; i < 32; i++)
        if (x & (1u << i)) ret ^= square_table[i];
    return ret;
}

}  // namespace Nimber

namespace Used_for_lazyseg {
const size_t Repetition = 32;

struct Node {
    array<int64_t, Repetition> sum;
    array<Nimber::nim, Repetition> nim_sum;
};

Node merge(Node a, Node b) {
    Node ret;
    transform(a.sum.begin(), a.sum.end(), b.sum.begin(), ret.sum.begin(),
              plus<>());
    transform(a.nim_sum.begin(), a.nim_sum.end(), b.nim_sum.begin(),
              ret.nim_sum.begin(), bit_xor<>());
    return ret;
}

Node identity_nd() { return {{}, {}}; }

using Lazy = size_t;

Lazy composite(Lazy a, Lazy b) { return (a + b) % Repetition; }

Lazy identity_lz() { return 0; }

Node apply(Lazy a, Node b) {
    rotate(b.sum.begin(), b.sum.begin() + a, b.sum.end());
    rotate(b.nim_sum.begin(), b.nim_sum.begin() + a, b.nim_sum.end());
    return b;
}

Node get(Nimber::nim x) {
    array<int64_t, Repetition> sum;
    array<Nimber::nim, Repetition> nim_sum;
    sum[0] = nim_sum[0] = x;
    for (int i = 1; i < Repetition; i++)
        sum[i] = nim_sum[i] = Nimber::square(sum[i - 1]);
    return {sum, nim_sum};
}

using Seg =
    lazy_segtree<Node, merge, identity_nd, Lazy, apply, composite, identity_lz>;

}  // namespace Used_for_lazyseg

int main() {
    int n, q;
    cin >> n >> q;
    vector<Nimber::nim> a(n);
    for (auto& i : a) cin >> i;
    Used_for_lazyseg::Seg seg(n);
    for (int i = 0; i < n; i++) seg.set(i, Used_for_lazyseg::get(a[i]));
    while (q--) {
        int op, x, y;
        cin >> op >> x >> y;
        x--;
        if (op == 1)
            seg.apply(x, y, 1);
        else if (op == 2)
            cout << seg.prod(x, y).nim_sum[0] << endl;
        else
            cout << seg.prod(x, y).sum[0] << endl;
    }
}
```

---

## 作者：fydj (赞：5)

被 T3 硬控两个小时，成为绝世丑角。

首先要会算 Nim 积，计算一次 Nim 积是 $O(\log ^2 V)$ 的，其中 $V$ 是值域。

以下是 Nim 积的一些性质：

如果把 Nim 积看作乘法、Nim 和（异或）看作加法，那么 Nim 积和 Nim 和满足结合律、交换律、分配律。

$0\otimes x=x\otimes 0=0$，$1\otimes x=x\otimes 1=x$。

设 $f_n=2^{2^n}$，则有：

+ 若 $x<f_n$，则 $x\otimes f_n=x\times f_n$。
+ $f_n\otimes f_n={\frac 3 2}f_n=f_n\oplus \frac{f_n}{2}$。

考虑分治，设 $k$ 为最小的满足 $f_{k+1}>\max(x,y)$ 的值，并且令 $x=f_k\times x_0+x_1,y=f_k\times y_0+y_1$，则有：
$$
\begin{aligned}
&x\otimes y\\
=&(f_k\times x_0+x_1)\otimes (f_k\times y_0+y_1)\\
=&(f_k\otimes x_0\oplus x_1)\otimes (f_k\otimes y_0\oplus y_1)\\
=&({\frac 3 2}f_k\otimes x_0\otimes y_0)\oplus (f_k\otimes (x_0\otimes y_1\oplus x_1\otimes y_0))\oplus (x_1\otimes y_1)\\
=&((f_k\oplus 2^{2^k-1})\otimes x_0\otimes y_0)\oplus (f_k\otimes (x_0\otimes y_1\oplus x_1\otimes y_0))\oplus (x_1\otimes y_1)\\
=&f_k\otimes(x_0\otimes y_0\oplus x_0\otimes y_1\oplus x_1\otimes y_0)\oplus (2^{2^k-1}\otimes x_0\otimes y_0)\oplus (x_1\otimes y_1)\\
=&f_k((x_0\oplus x_1)\otimes (y_0\oplus y_1)\oplus (x_1\otimes y_1))\oplus (2^{2^k-1}\otimes x_0\otimes y_0)\oplus (x_1\otimes y_1)
\end{aligned}
$$
上面公式有点长，令 $x_0\otimes y_0=b_0$，$x_1\otimes y_1=b_1$，$(x_0\oplus x_1)\otimes (y_0\oplus y_1)=a$，则 $x\otimes y =(f_k\times (a\oplus b_1))\oplus (2^{2^k-1}\otimes b_0)\oplus b_1$。

可以分治计算了，每往下分治一层 $k$ 都会减一，一开始 $k=\log\log V$，而每分治一次会往下递归四次，所以时间复杂度是 $O(4^{\log\log V})=O(\log^2V)$。

有两个常数优化：当 $\min(x,y)<2$ 的时候，$x\otimes y$ 可以直接算；把 $\max(x,y)< 2^8$ 的 $x\otimes y$ 记忆化下来。效率会明显提升。代码如下：

```cpp
ull F(ull x,ull y,int p=64) {
	if(x<2||y<2) return x*y;
	if(p<=8&&(~mp[x][y])) return mp[x][y];
	p>>=1;
	ull x0=x>>p,x1=x&((1ull<<p)-1);
	ull y0=y>>p,y1=y&((1ull<<p)-1);
	ull a=F(x0^x1,y0^y1,p),b1=F(x1,y1,p),b0=F(x0,y0,p);
	ull rey=((a^b1)<<p)^b1^F(b0,1ull<<p-1,p);
	if(p<8) mp[x][y]=mp[y][x]=rey;
	return rey;
}
```

一开始要记得 `memset(mp,-1,sizeof(mp))`。

如果会 Nim 积，前两档的 $13$ 分就可以得到了。第 $7$ 档部分分可以用快速幂思想得到。

猜测 $a_i\leftarrow a_i\otimes a_i$ 有规律，打表，发现有循环节。

具体地，设 $\text{highbit}(x)$ 表示 $x$ 的二进制下最高的 $1$ 位，则 $x\leftarrow x\otimes x$ 的循环节是 $2\times \text{highbit}(\log_2 (\text{highbit}(x)))$。在这里，$\log _2 (\text{highbit}(x))\le 31$，循环节最多是 $32$。

于是可以上线段树。具体地，对于线段树上的一个节点，开一个大小位 $32$ 的数组表示区间的和、区间中每一个数都进行了 $1$ 次操作（$a_i\leftarrow a_i\otimes a_i$）后的和、进行了 $2$ 次操作后的和、……、进行了 $31$ 次操作后的和；对于异或和同理。每次合并两个节点的信息可以 $O(32)$ 合并。

总的时间复杂度就是 $O(32q\log n)$，可以过。

线段树的代码如下：

```cpp
struct num {
	ull a,b;
	num(ull _=0,ull __=0) { a=_,b=__; }
	friend num operator + (const num &a,const num &b) {
		return num(a.a^b.a,a.b+b.b);
	}
};
struct note {
	num v[32];
	void operator = (const ull t) {
		int i; ull _=t;
		v[0]=num(t,t);
		for(i=1;i<32;++i) {
			_=F(_,_);
			v[i]=num(_,_);
		}
	}
	friend note operator + (const note &a,const note &b) {
		note ans; int i;
		for(i=0;i<32;++i)
			ans.v[i]=a.v[i]+b.v[i];
		return ans;
	}
} tr[N<<2]={};
int tag[N<<2]={};
#define lson (x<<1)
#define rson (x<<1|1)
void update(int x) { tr[x]=tr[lson]+tr[rson]; }
void push(int x,int v) {
	if(!v) return ;
	static num _[32]={};
	memcpy(_,tr[x].v,sizeof(_));
	for(int i=0;i<32;++i)
		tr[x].v[i]=_[(i+v)&31];
	tag[x]+=v;
	return ;
}
void downtag(int x) {
	if(tag[x])
		push(lson,tag[x]),
		push(rson,tag[x]),
		tag[x]=0;
	return ;
}
void maketree(int x,int l,int r) {
	if(l==r) return tr[x]=a[l],void();
	int mid=l+r>>1;
	maketree(lson,l,mid);
	maketree(rson,mid+1,r);
	return update(x);
}
void change(int x,int l,int r,int L,int R) {
	if(L<=l&&r<=R) return push(x,1),void();
	int mid=l+r>>1; downtag(x);
	if(L<=mid) change(lson,l,mid,L,R);
	if(mid<R) change(rson,mid+1,r,L,R);
	return update(x);
}
num solve(int x,int l,int r,int L,int R) {
	if(L<=l&&r<=R) return tr[x].v[0];
	int mid=l+r>>1; downtag(x);
	if(L<=mid&&mid<R) return solve(lson,l,mid,L,R)+solve(rson,mid+1,r,L,R);
	else if(L<=mid) return solve(lson,l,mid,L,R);
	else return solve(rson,mid+1,r,L,R);
}
#undef lson
#undef rson
```

---

## 作者：Eterna (赞：3)

普及选手爆切黑题，没打这场后悔了。

首先我们看到 $a_i \gets a_i \otimes a_i$，不用想，这种不是有势能就是有规律。

简单打表后就会发现，这东西是带循环的，对于任何一个数它都有 $32$ 位的循环（从值域 $2^{32}$ 中也可以猜到）。

但是即便如此，我们对它暴力预处理仍然不行，达到了 $O(n^2 \log n)$。

用我们惊人的注意力可以注意到一个对于 $f(x)=x \otimes x,a=$`x&-x`。

有：$f(x)=f(a) \oplus f(x \oplus a)$。

于是我们提前做出所有的 $f(2^x)$，然后就可以 $O(\log n)$ 求出 $f(n)$ 了。

具体的，对于求 $f(2^x)$ 其实很简单，由 Nim 积的性质：

$$x \otimes 2^{2^y}=2^{2^y} \times x，2^{2^z} \otimes 2^{2^z}= 3 \times 2^{2^z-1}$$

注意 $2^{2^y}>x$，可以得到：

若 $k$ 是最小的满足 $2t>x$ 并且 $2t>y$ 的整数，其中 $t=2^{2^k}$。

则令 $x=a \times t+b,y=c \times t+d$，得到：

$$x \otimes y=(b \oplus a \otimes t) \otimes (d \oplus c \otimes t)$$

再由 Nim 积所满足的交换律加上上面给出的性质得：

$$x \otimes y=(b \otimes d) \oplus [ (a \oplus b) \otimes (c \oplus d) \oplus (b \otimes d)] \times t \oplus (\frac{t}{2} \otimes a \otimes c)$$

可以用类似分治的方法递归求出，对于一次计算，复杂度是 $O(\log x \times \log y)$。

这样的话，就容易预处理了。

预处理代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int nim(int x,int y,int p) 
{
    if(x*y<=min(x,y))return x*y;
    int a=x>>p,b=((1ll<<p)-1)&x,c=y>>p,d=((1ll<<p)-1)&y,res=nim(b,d,p>>1);
    return ((nim(a^b,c^d,p>>1)^res)<<p)^nim(nim(a,c,p>>1),(1ll<<p)>>1,p>>1)^res;
}
int p[35];
signed main()
{
	for(int i=1,x=1;i<=32;i++,x<<=1)cout<<(p[i]=nim(x,x,32))<<'\n';
	return 0;
} 
```

复杂度是 $O(\log^3n)$ 的。

只有 $32$ 个数，我们直接把结果粘在代码里就行。

操作 $2,3$ 基本等价，用线段树维护一下对于不同操作次数的值就可以了，只是基本操作。

虽然只用了 $1$ 个，但还是要感谢出题人的 $7$ 个样例。

代码：


```cpp
#include<bits/stdc++.h>
#define int long long
#define N 250005
using namespace std;
int p[35]={1,3,6,13,24,52,103,222,384,832,1648,3552,6237,13563,26511,56906,98304,212992,421888,909312,1596672,3472128,6786816,14567936,25190110,54589881,108036850,232800673,408783316,888883132,1737454078,3729449897};
int n,q,a[N];
inline int f(int x)
{
    int res=0;
    for(int i=0;i<=31;x>>=1,i++)res^=(p[i]*(x&1));
    return res;
}
struct node
{
    int tr[2][32],lazy;
    inline void init(int x)
	{
        tr[0][0]=tr[1][0]=x;
        for(int i=1;i<=31;i++)tr[0][i]=tr[1][i]=f(tr[0][i-1]);
    }
}tr[N<<2],tmp;
inline void pushup(int id)
{
	for(int i=0;i<=31;i++)
	{
		tr[id].tr[0][i]=tr[id<<1].tr[0][i]+tr[id<<1|1].tr[0][i];
		tr[id].tr[1][i]=tr[id<<1].tr[1][i]^tr[id<<1|1].tr[1][i];
	}
}
inline void add(int id,int t)
{
	tmp=tr[id],tr[id].lazy+=t;
	for(int i=0;i<=31;i++)
	{
		tr[id].tr[0][i]=tmp.tr[0][(i+t)%32];
		tr[id].tr[1][i]=tmp.tr[1][(i+t)%32];
	}
}
inline void pushdown(int id)
{
	if(tr[id].lazy)add(id<<1,tr[id].lazy),add(id<<1|1,tr[id].lazy),tr[id].lazy=0;
}
void build(int id,int l,int r)
{
    if(l==r)
	{
		tr[id].lazy=0,tr[id].init(a[l]);
        return;
    }
    int mid=l+r>>1;
    build(id<<1,l,mid);
	build(id<<1|1,mid+1,r);
    pushup(id);
}
void update(int id,int l,int r,int x,int y)
{
    if(x<=l&&r<=y)
	{
        add(id,1);
        return;
    }
	int mid=l+r>>1;pushdown(id);
    if(x<=mid)update(id<<1,l,mid,x,y);
    if(mid<y)update(id<<1|1,mid+1,r,x,y);
    pushup(id);
}
int query0(int id,int l,int r,int x,int y)
{
    if(x<=l&&r<=y)return tr[id].tr[1][0];
    int mid=l+r>>1,res=0;pushdown(id);
    if(x<=mid)res^=query0(id<<1,l,mid,x,y);
    if(mid<y)res^=query0(id<<1|1,mid+1,r,x,y);
    return res;
}
int query1(int id,int l,int r,int x,int y)
{
    if(x<=l&&r<=y)return tr[id].tr[0][0];
	pushdown(id);
    int mid=l+r>>1,res=0;
    if(x<=mid)res+=query1(id<<1,l,mid,x,y);
    if(mid<y)res+=query1(id<<1|1,mid+1,r,x,y);
    return res;
}
signed main()
{
    cin>>n>>q;
    for(int i=1;i<=n;i++)cin>>a[i];
    build(1,1,n);
    while(q--)
	{
        int op,l,r;cin>>op>>l>>r;
        if(op==1)update(1,1,n,l,r);
        if(op==2)cout<<query0(1,1,n,l,r)<<"\n";
        if(op==3)cout<<query1(1,1,n,l,r)<<"\n";
    }
    return 0;
}
```

复杂度 $O(n \log^2 n+q \log^2 n)$，完全不卡常，没有读写优化代码所有的点都在 $1$ 秒内。

---

## 作者：_lmh_ (赞：2)

下文中令 $w=32$（$a_i$ 的字长），记 $\oplus$ 为异或运算，$\otimes$ 为 Nim 积。

Nim 积是个啥组合意义咱不用知道，但我们会用到它的两条性质：

$$(x\oplus y)\otimes z=(x\otimes z)\oplus(y\otimes z)$$

$$\forall n\in \Z_+,x\in [0,2^{2^n})\cap \Z,F(x,{2^{2^{n}}})=x$$

其中 $F(x,y)=\begin{cases}x & y=1 \\ x^{y-1}\otimes x & y>1\end{cases}$。

第一条性质告诉我们 $(x\oplus y)\otimes(x\oplus y)=(x\otimes x)\oplus(y\otimes y)$，这样可以发现我们**对一个区间内所有数操作后异或和**等价于**对其异或和进行操作**，第二条性质告诉我们一个数操作 $2^n=w=32$ 次等于不操作。

维护异或和是简单的。维护总和的话可以维护目前序列操作 $0\sim 31$ 次的和，每次旋转一下数组即可。

还有个“小”问题是我们不能求 $x\otimes x$。把 $x$ 拆成一堆 $2$ 的幂之和，之后你可以用一些神秘算法把这 $32$ 个值搞出来，或者 [OEIS](https://oeis.org/A006017/b006017.txt)，当然也可以去下面代码里拷过来。

对求值的过程进行一些优化，预处理高 $w/2$ 位和低 $w/2$ 位的所有情况。

（如果你把 $2^x\otimes 2^x$ 当作常量扔进去的话）复杂度为 $O((n+m\log n+2^{w/2})w)$。

```cpp
//Happy Birthday, Ling Luo!
#include<bits/stdc++.h>
using namespace std;
#define uint unsigned int
#define ull unsigned long long
#define lson (u<<1)
#define rson (u<<1|1)
#define nxt(x) T[x>>16]^t[x&65535u]
#define NXT(x,k) TO[x>>16][k]^to[x&65535u][k]
const uint N=250007,M=65536,NIM[32]={1u,3u,6u,13u,24u,52u,103u,222u,384u,832u,1648u,3552u,6237u,13563u,26511u,56906u,98304u,212992u,421888u,909312u,1596672u,3472128u,6786816u,14567936u,25190110u,54589881u,108036850u,232800673u,408783316u,888883132u,1737454078u,3729449897u};
int n,m,op,l,r,tag[N<<2];
uint a[N],T[M],t[M],TO[M][32],to[M][32],val[N<<2];
ull sum[N<<2][32];
void add(int u,int v){val[u]=NXT(val[u],v);rotate(sum[u],sum[u]+v,sum[u]+32);tag[u]=tag[u]+v&31;}
void pushup(int u){
	val[u]=val[lson]^val[rson];
	for (int i=0;i<32;++i) sum[u][i]=sum[lson][i]+sum[rson][i];
}
void pushdown(int u){
	if (tag[u]){
		add(lson,tag[u]);add(rson,tag[u]);tag[u]=0;
	}
}
void build(int u,int l,int r){
	if (l==r){
		val[u]=a[l];
		for (int i=0;i<32;++i) sum[u][i]=NXT(a[l],i);
		return;
	}
	int mid=l+r>>1;
	build(lson,l,mid);build(rson,mid+1,r);
	pushup(u);
}
void modify(int u,int l,int r,int L,int R){
	if (L<=l&&r<=R){add(u,1);return;}
	int mid=l+r>>1;pushdown(u);
	if (L<=mid) modify(lson,l,mid,L,R);
	if (R>mid) modify(rson,mid+1,r,L,R);
	pushup(u);
}
uint query1(int u,int l,int r,int L,int R){
	if (L<=l&&r<=R) return val[u];
	int mid=l+r>>1;pushdown(u);
	if (R<=mid) return query1(lson,l,mid,L,R);
	if (L>mid) return query1(rson,mid+1,r,L,R);
	return query1(lson,l,mid,L,R)^query1(rson,mid+1,r,L,R);
}
ull query2(int u,int l,int r,int L,int R){
	if (L<=l&&r<=R) return sum[u][0];
	int mid=l+r>>1;pushdown(u);
	if (R<=mid) return query2(lson,l,mid,L,R);
	if (L>mid) return query2(rson,mid+1,r,L,R);
	return query2(lson,l,mid,L,R)+query2(rson,mid+1,r,L,R);
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);
	for (int i=0;i<16;++i){t[1<<i]=NIM[i];T[1<<i]=NIM[i+16];}
	for (uint i=0;i<M;++i){
		if (i&i-1){T[i]=T[i&i-1]^T[i&-i];t[i]=t[i&i-1]^t[i&-i];}
		TO[i][0]=i<<16;to[i][0]=i;
	}
	for (int i=0;i<M;++i) for (int j=1;j<32;++j){TO[i][j]=nxt(TO[i][j-1]);to[i][j]=nxt(to[i][j-1]);}
	cin>>n>>m;
	for (int i=1;i<=n;++i) cin>>a[i];
	build(1,1,n);
	while(m--){
		cin>>op>>l>>r;
		if (op==1) modify(1,1,n,l,r);
		else if (op==2) cout<<query1(1,1,n,l,r)<<'\n';
		else cout<<query2(1,1,n,l,r)<<'\n';
	}
	return 0;
}
```

考虑到官方题解默认你会这玩意但显然大部分人不会，还是解释一下 nim product 的求法吧。

先二进制拆位。由 nim product 的性质，假设 $A=\bigoplus_1^n2^{a_i},B=\bigoplus_1^m2^{b_i}$，则由分配律，$A\otimes B=\bigoplus_1^n \bigoplus_1^m(2^{a_i}\otimes 2^{b_i})$。

拆完位之后就转化成了处理 $A=2^x\otimes 2^y(x\ge y)$。尝试递推。

第一种情况是 $y=0$，显然此时 $A=2^x$，你可以直接模拟一下题目中的式子。

然后就要用到性质：

$$\forall\ x<2^{2^n},2^{2^n}\otimes x=2^{2^n}\cdot x$$

$$2^{2^n}\otimes 2^{2^n}=2^{2^n}\oplus 2^{2^n-1}$$

据此我们可以处理 $x=2^k$ 的情况。

接下来我们把 $x$ 和 $y$ 的最高二进制位拉出来，假设其为 $2^a$ 和 $2^b$。此时 $x\ne 2^a$（已经在前面处理了这种情况）。

如果 $a=b$，则由结合律，$2^x\otimes 2^y=(2^{2^a}\otimes 2^{2^b})\otimes (2^{x-2^a}\otimes 2^{x-2^b})$，后面那玩意已经递推得到了且其 $<2^{2^a}$（也是性质），设它为 $z$，前面那一部分就是 $2^{2^a}\oplus 2^{2^a-1}$，所以 $2^x \otimes 2^y = (2^{2^a}\oplus 2^{2^a-1})\otimes z=(2^{2^a}\otimes z)\oplus(2^{2^a-1}\otimes z)$，全部预处理到了，拆位做即可。

如果 $a>b$，此时 $2^x\otimes 2^y=2^{2^a}\otimes (2^{2^b}\otimes (2^{x-2^a}\otimes 2^{x-2^b}))$，还是设最后一部分为 $z$，此时 $2^{2^b}\otimes z$ 可以拆位做，因为后面三个数小于 $2^{2^a}$，它们 $\otimes$ 后的结果也小于 $2^{2^a}$，用前面的性质，直接将其乘上 $2^{2^a}$ 即可。

然后我们就得出了一个快速递推的算法，时间复杂度为 $O(w^3)$。

代码（可以打出表后像我一样拷进程序里，也可以把它复制在程序最前面）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=32;
unsigned int NIM[N][N];
int main(){
	for (int i=0;i<N;++i) for (int j=0;j<=i;++j){
		if (i==0||j==0){NIM[i][j]=NIM[j][i]=1u<<i+j;continue;}
		if (!(i&i-1)){
			if (i==j) NIM[i][j]=(1<<i)+(1<<i-1);
			else NIM[i][j]=NIM[j][i]=(1u<<i+j);
			continue;
		}
		int a=__lg(i),b=__lg(j);
		unsigned int x=i^(1u<<a),y=j^(1u<<b);
		if (a==b){
			x=NIM[x][y];
			for (int l=0;l<N;++l) if ((x>>l)&1) NIM[i][j]^=NIM[l][1u<<a]^NIM[l][(1u<<a)-1];
			NIM[j][i]=NIM[i][j];
			continue;
		}
		x=NIM[x][y];
		for (int l=0;l<N;++l) if ((x>>l)&1) NIM[i][j]^=NIM[l][1<<b];
		NIM[j][i]=NIM[i][j]=(1<<(1<<a))*NIM[i][j];
	}
//	for (int i=0;i<N;++i){for (int j=0;j<N;++j) cout<<NIM[i][j]<<' ';cout<<endl;}
	for (int i=0;i<N;++i) cout<<NIM[i][i]<<endl;
	return 0;
}
```

---

## 作者：SegTree (赞：1)

前言：本人想不到如何 $O(\log V)$ 求 nim 平方，今天经过简单思考发现我是小丑。

不难得到 nim 平方会形成 $32$ 为周期的循环，可以使用线段树维护，但是会被卡空间，可以选择对于长度 $\le 32$ 的区间暴力维护。

具体来说，先求出每个数跳 $32$ 次得到的值分别是什么，而由于求的是 nim 平方可以 $O(\log V)$ 算出，预处理时间复杂度 $O(n\log^2 V)$。

每次查询复杂度 $\log^2 n$，因为需要在线段树上维护整个区间进行 $k$ 次操作后的和、异或和。

时间复杂度 $O(n\log^2 V+q\log^2 n)$。

---

## 作者：emo_zkt (赞：0)

首先分析一下题目，一眼线段树。

三种操作中，后两种直接套板子计算就行了，问题就在于第一种操作，甚至赛场上我都没做出来……美美的只拿了 200 分（T3 我也没做出来）。

你看一看这道题，首先你如果硬算，那么时间复杂度无法接受，一看就是要么有别的算法，要么有规律。一看，我就知道不会有别的算法了，因为，你就是看一看，都会下意识认为这有规律。

至于这意识怎么来的，做做[这道题](https://www.luogu.com.cn/problem/T533698)你就知道何为下意识的想法可能就是对的，那道题，你算算就得出 $F(x)=0$，甚至后面的函数直接不会对结果造成影响，因此此题非常之误导人，他在忽悠你去推其他函数并诱导你用线段树，要不是看了数据范围，我差点就信了。

此题同理，操作 1 中，$a_i\gets a_i\otimes a_i$，只要你足够肝，你可以算一算，打个表，或者说你是巨佬，你知道 $\operatorname{Nim}$ 积的性质，你计算一下，你会发现执行 $2^{32}$ 次就改回去了……

所以打上长度 32 的表，就是整出 $2^{0}$ 到 $2^{31}$ 次操作的影响，这样针对连续 $k$ 次 1 操作就不必一个一个的处理了，把它拆成二进制，直接 $log{k}$ 次操作就改完了，然后你就每次整出表里的数，直接进行更改就可以了。

此处放一个 [NIM 积的学习笔记(一个大佬写的)](https://www.cnblogs.com/suwakow/p/12200462.html)

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=250005;
long long ans[35]={1,3,6,13,24,52,103,222,384,832,1648,3552,6237,13563,26511,56906,98304,212992,421888,909312,1596672,3472128,6786816,14567936,25190110,54589881,108036850,232800673,408783316,888883132,1737454078,3729449897};
long long n,q,a[N];
long long f(int x){
    long long res=0;
    for(int i=0;i<=31;x>>=1,i++)res^=(ans[i]*(x&1));
    return res;
}
struct nod{
    long long val1[35],val2[35],lazy,l,r;
    void init(long long x){
        val1[0]=val2[0]=x;
        for(long long i=1;i<=31;i++)val1[i]=val2[i]=f(val1[i-1]);
    }
}tr[N<<2],v;
void pushup(long long p){
	for(long long i=0;i<=31;i++)tr[p].val1[i]=tr[p<<1].val1[i]+tr[p<<1|1].val1[i],tr[p].val2[i]=tr[p<<1].val2[i]^tr[p<<1|1].val2[i];
}
void add(long long p,long long t){
	v=tr[p];
	for(long long i=0;i<=31;i++)tr[p].val1[i]=v.val1[(i+t)%32],tr[p].val2[i]=v.val2[(i+t)%32];
}
void spread(long long p){
	if(tr[p].lazy)add(p<<1,tr[p].lazy),add(p<<1|1,tr[p].lazy),tr[p<<1].lazy+=tr[p].lazy,tr[p<<1|1].lazy+=tr[p].lazy,tr[p].lazy=0;
}
void build(long long p,long long l,long long r){
	tr[p].l=l,tr[p].r=r;
    if(l==r){
        tr[p].lazy=0,tr[p].init(a[l]);
        return;
    }
    long long mid=(l+r)>>1;
    build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
    pushup(p);
}
void updateq(long long p,long long x,long long y){
	long long l=tr[p].l,r=tr[p].r;
    if(x<=l&&r<=y){
        add(p,1);
		tr[p].lazy++;
        return;
    }
    spread(p);
	long long mid=(l+r)>>1;
    if(x<=mid)updateq(p<<1,x,y);
    if(mid<y)updateq(p<<1|1,x,y);
    pushup(p);
}
long long query1(long long p,long long x,long long y){
	long long l=tr[p].l,r=tr[p].r;
    if(x<=l&&r<=y)return tr[p].val1[0];
	spread(p);
    long long mid=(l+r)>>1,ans=0;
    if(x<=mid)ans+=query1(p<<1,x,y);
    if(mid<y)ans+=query1(p<<1|1,x,y);
    return ans;
}
long long query2(long long p,long long x,long long y){
	long long l=tr[p].l,r=tr[p].r;
    if(x<=l&&r<=y)return tr[p].val2[0];
	spread(p);
    long long mid=(l+r)>>1,ans=0;
    if(x<=mid)ans^=query2(p<<1,x,y);
    if(mid<y)ans^=query2(p<<1|1,x,y);
    return ans;
}
int main(){
    cin>>n>>q;
    for(long long i=1;i<=n;i++)cin>>a[i];
    build(1,1,n);
    while(q--){
        long long op,l,r;
		cin>>op>>l>>r;
        if(op==1)updateq(1,l,r);
        if(op==2)cout<<query2(1,l,r)<<'\n';
        if(op==3)cout<<query1(1,l,r)<<'\n';
    }
    return 0;
}
```

---


# [JOI Open 2019] 病毒实验 / Virus Experiment

## 题目描述

**译自 [JOI Open 2019](https://contests.ioi-jp.org/open-2019/index.html) T3 「ウイルス実験」**

JOI 公司研究了新型病毒 `JOI virus`。JOI 公司希望通过用该病毒影响在 IOI 岛的动物做实验。

IOI 岛呈矩形。有 $R-1$ 条从西向东的平行道路，和 $C-1$ 条从北向南的平行道路。她们将岛分割成 $RC$ 个部分。每部分只有一只动物。我们称居住在北部第 $i$，西部第 $j$ 部分的动物为 `动物(i,j)`（$1\le i\le R$，$1\le j\le C$）。

在 IOI 岛上，一天有 $M$ 个时间段。我们管第 $k$ 个叫 `时间段k`。风总是从某方向吹来：北方，南方，东方和西方。基于时间段，风向可能改变。如果时间段相同，风向总是不变，这和在哪一天无关。

每只动物有一个状态 `抵抗力`。动物 $(i,j)$ 的抵抗力表示为一个非负整数 $U_{i,j}$。

- 如果 $U_{i,j}=0$,说明动物 $(i,j)$ 有很高的抵抗力，使得它不被 JOI virus 感染。
- 如果 $U_{i,j}$ 是一个正整数，说明动物 $(i,j)$ 可能被感染。如果下面条件连续成立了 $U_{i,j}$ 时间段，则他/她会从下一个时间段开始被感染。

  -- 从风向处相邻的动物已经被传染。 
  
  注意最后一个时间段和下一天的第一个时间段是连续的。
  
为了实验，我们希望至少感染 $1$ 只动物，但是我们不希望感染过多的动物。在开始，我们选择一只作为第一个被感染的。我们不能选择 $U_{i,j}=0$ 的动物 $(i,j)$ 作为第一个被感染的个体。

给定每个时间段的风向和每只动物的抵抗力。编写程序计算经过了 $10^{100}$ 天后最少被感染了个体数，和达成此目标刚开始能选择的个体有几种。

## 说明/提示

#### 样例解释：

让我们考虑选择动物 $(3,1)$ 作为初始被感染个体的情况。

对于动物 $(2,1)$，在第 $1$ 天的时间段 $1$，刮南风，且南边相邻动物已经被感染，所以他/她会从第 $1$ 天的时间段 $2$ 被感染。

对于动物 $(3,2)$，在第 $1$ 天的时间段 $2$，刮西风，且西边相邻动物已经被感染，所以他/她会从第 $1$ 天的时间段 $3$ 被感染。

对于动物 $(1,1)$，在第 $1$ 天的时间段 $6$，刮南风，且南边相邻动物已经被感染，且在第 $2$ 天的时间段 $1$，刮南风，且南边相邻动物已经被感染，所以他/她会从第 $2$ 天的时间段 $2$ 被感染。

对于动物 $(1,2)$，在第 $2$ 天的时间段 $2$，刮西风，且西边相邻动物已经被感染，所以他/她会从第 $2$ 天的时间段 $3$ 被感染。

对于动物 $(1,3)$，在第 $3$ 天的时间段 $2$，刮西风，且西边相邻动物已经被感染，所以他/她会从第 $3$ 天的时间段 $3$ 被感染。

对于动物 $(2,3)$，在第 $3$ 天的时间段 $3$，刮北风，且北边相邻动物已经被感染，所以他/她会从第 $3$ 天的时间段 $4$ 被感染。

对于动物 $(3,3)$，在第 $4$ 天的时间段 $2$，刮西风，且西边相邻动物已经被感染，且在第 $4$ 天的时间段 $3$，刮北风，且北边相邻动物已经被感染。所以他/她会从第 $4$ 天的时间段 $4$ 被感染。

没有更多动物会被感染。所以当选择 动物 $(3,1)$ 作为初始被感染者时，经过 $10^{100}$ 天，$8$ 只动物会被感染。

不论选哪只动物作为初始被感染者，我们都无法使得 $10^{100}$ 天后被感染的动物数量小于 $8$，所以输出的第一行是 $8$。如果我们选择动物 $(1,1)$，$(1,2)$，$(1,3)$，$(2,1)$，$(2,3)$，$(3,1)$，$(3,2)$ 或 $(3,3)$ 作为初始被感染者，在 $10^{100}$ 天后被感染的个数都是 $8$。所以第二行应当输出 $8$。

这个样例满足 `子任务1` 的约束条件。

#### 数据范围：

$1\le M\le 10^5$，$1\le R\le 800$，$1\le C\le 800$。

$D$ 是一个长度为 $M$ 的字符串，只包含 $\texttt N$, $\texttt S$, $\texttt W$, $\texttt E$。

$0\le U_{i,j}\le 10^5$（$1\le i\le R$，$1\le j\le C$）。

至少有一对 $(i,j)$ 满足 $1\le U_{i,j}$（$1\le i\le R$，$1\le j\le C$）。

#### 子任务：

1. （14 分）$D$ 只包含 $\texttt W$ 和 $\texttt E$。
2. （6 分）$1\le W\le 50$，$1\le C\le 50$。
3. （80 分）无额外约束。

## 样例 #1

### 输入

```
6 3 4
SWNEES
2 1 1 2
1 0 1 3
1 1 2 2```

### 输出

```
8
8```

## 样例 #2

### 输入

```
4 4 4
EWWE
1 2 1 2
1 1 1 1
0 0 0 0
2 2 2 4```

### 输出

```
3
3```

# 题解

## 作者：DaiRuiChen007 (赞：4)

[Problem Link](https://www.luogu.com.cn/problem/P11394)

**题目大意**

> 给定 $n\times m$ 网格，以及长度为 $k$ 的字符串 $S$（字符集东南西北），初始每个格子为白色。
>
> 在第 $t$ 个时刻，我们选取方向 $S^{\infty}_t$，然后取出每个格子在该方向的邻居，如果某个格子 $(i,j)$ 连续 $a_{i,j}$ 个时刻都取到了一个黑色的邻居，那么这个格子也染黑。
>
> 你要选择一个格子染黑，最小化充分大时间后的黑色格子数量，并且求出有多少个取到最小值的起点。
>
> 数据范围：$n,m\le 800,k\le 10^5$。

**思路分析**

首先我们要快速判定一个格子是否能染黑，取出其所有黑色邻居所在的方向，记为集合 $s$，那么要求就是 $S^{\infty}$ 中存在一个长度 $\ge a_{i,j}$ 的连续段全部由 $s$ 中字符构成。

对每个 $s$ 预处理出 $S^{\infty}$ 中由 $s$ 构成的极长连续段，可以 $\mathcal O(1)$ 判定每个格子是否染黑。

那么暴力就是从每个点开始 bfs，但显然无法通过。

考虑利用一些已有的信息，例如从 $u$ 出发能染黑 $v$，那么从 $v$ 出发能染黑的点从 $u$ 出发一定也会染黑。

因此可以考虑连边 $u\to v$，则每个点的答案就是后继个数。

先对这张图缩点，那么答案只可能是无出度的强连通分量。

可以发现如果存在一条边 $u\to v$，那么 $u$ 的答案不优于 $v$ 的答案。

因此我们取出这张图的一个内向生成森林，则答案一定来自每个根所在的强连通分量。

如果求出极大的一个内向生成森林，显然一个强连通分量内不会有两个根，因此对每个根暴力 bfs 复杂度正确。

那么问题就变成了在这张图上求出一个极大内向生成森林。

稠密图上的生成树问题可以考虑 Boruvka，在这题中，我们动态维护一个内向生成森林，然后对每个根找一条连向其他树的出边，然后以任意顺序加入这条边（只要不成环）。

很显然每轮增广后连通块数量减半，那么增广轮数是 $\mathcal O(\log nm)$ 的。

每轮增广就从每个根开始 bfs，如果遇到一个和自己不同色的点就立即退出，那么每个点只会被同色的根 bfs 到，复杂度 $\mathcal O(nm)$。

时间复杂度 $\mathcal O(k+nm\log nm)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=805,MAXL=2e5+5,MAXV=1e6+5,inf=1e9,dx[]={-1,1,0,0},dy[]={0,0,-1,1};
char op[MAXL];
int n,m,q,lim[16],a[MAXN][MAXN];
int cl[MAXN][MAXN],id[MAXN][MAXN],dsu[MAXV],tot;
bool vis[MAXN][MAXN];
int ty(char c) { return c=='N'?0:(c=='S'?1:(c=='W'?2:3)); }
int find(int x) { return dsu[x]^x?dsu[x]=find(dsu[x]):x; }
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>q>>n>>m;
	for(int i=1;i<=q;++i) cin>>op[i],op[i+q]=op[i];
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) cin>>a[i][j],id[i][j]=++tot;
	for(int s=1;s<16;++s) {
		for(int i=1,j=lim[s]=-1;i<=2*q;++i) if(!(s>>ty(op[i])&1)) {
			if(~j) lim[s]=max(lim[s],i-j-1); j=i;
		}
		if(lim[s]==-1) lim[s]=inf;
	}
	iota(dsu+1,dsu+tot+1,1);
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) if(a[i][j]) cl[i][j]=id[i][j];
	while(true) {
		memset(vis,false,sizeof(vis));
		vector <array<int,2>> E;
		int ans=inf,cnt=0;
		for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) if(cl[i][j]==id[i][j]) {
			int z=0; queue <array<int,2>> Q;
			Q.push({i,j}),vis[i][j]=true;
			auto is=[&](int x,int y){ return vis[x][y]&&cl[x][y]==cl[i][j]; };
			while(Q.size()) {
				int u=Q.front()[0],v=Q.front()[1]; Q.pop(),++z;
				for(int d:{0,1,2,3}) {
					int x=u+dx[d],y=v+dy[d];
					if(!a[x][y]||is(x,y)) continue;
					int s=is(x-1,y)|is(x+1,y)<<1|is(x,y-1)<<2|is(x,y+1)<<3;
					if(a[x][y]<=lim[s]) {
						if(cl[x][y]==cl[i][j]) Q.push({x,y}),vis[x][y]=true;
						else { E.push_back({cl[i][j],cl[x][y]}); goto _; }
					}
				}
			}
			if(ans>z) ans=cnt=z;
			else if(ans==z) cnt+=z;
			_:;
		}
		if(E.empty()) return cout<<ans<<"\n"<<cnt<<"\n",0;
		for(auto e:E) if(find(e[1])!=e[0]) dsu[e[0]]=find(e[1]);
		for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) if(a[i][j]) cl[i][j]=find(id[i][j]);
	}
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：3)

- boruvka 思想，代表元思想，图论思想，SCC 的性质。

对于四个方向相邻的格子集合 $U$，串 $D$ 的作用就是告诉你，对于一个位置 $u$，有一些集合 $S\subseteq U$ 满足一旦 $S$ 集合均被染色，则这个格子也会被染色。可以 $\mathcal O(2^{d}|D|)$ 的时间预处理出最长吹风时间，其中 $d=4$ 表示网格图中每个格子相邻的格子数。于是就得到了一个 $\mathcal O(n^2m^2)$ 的暴力 bfs 的做法。

观察一下这个求最小值的性质，以及染色的性质，可以用图论关系来刻画：考虑刻画如下的传递关系：$u$ 被染色导致最终 $v$ 被染色，此时连边 $u\to v$。然后求出 $u$ 可达的点数即可。但是你显然不能直接建出来这张图。你需要求的是缩点成 dag 后，大小最小的无出度 SCC 的大小和数量。那么考虑 SCC 合并的过程，如果 $u\Rightarrow v$ 且 $v\Rightarrow u$，那么 $u,v$ 事实上是等价的；如果 $u\Rightarrow v$ 但 $v\not\Rightarrow  u$， 因为我们希望到达尽量少的点，那么 $u$ 就是没有用的。

这启发我们动态维护当前有希望成为最终统计对象的 SCC。我们可以考虑动态维护这些 SCC，如果存在出度但是无法合并了就立刻标记为无用。然后考虑一起维护这些 SCC。

然而你维护 SCC 是不好做的，考虑对于一个集合 $S$，什么是重要的。我们可以用这样的判定：任意一个点 $u\in S$，使得对于任意 $v$ 都有 $u\Rightarrow v$ 且 $v\Rightarrow u$。并且这条判定，只要对于任意一个 $u$ 满足，那么一定所有 $u$ 都是满足的。

 我们只需要找出一个关键点 $u\in S$，然后 $S$ 是一个 SCC 的必要条件是任意 $v\in S,v\Rightarrow u$，这启发我们只维护单向的可达关系，得知了这些之后，只需要从关键点开始找哪些 $v\in S$ 使得 $u\Rightarrow v$。记录有 $cnt$ 个，那么找出最终所有这些互相两两不可合并的 $S$ 之后，最小值就是 $\min(cnt_S)$，统计最小值个数也是容易的，就是第一问答案乘上多少个 $S$ 可以达成它。

问题在于如何求出这些 $S$。初始状态就是有 $n$ 个集合，每个集合的 $S=\lbrace i\rbrace$。考虑二集合 $A,B$ 合并：要求 $A$ 的代表元可以到达 $B$ 的代表元，此时可以将 $A$ 的所有元素加入 $B$。

然后很神的一步，可以直接模仿 boruvka 算法：对于 $A$，在 bfs 过程中只需要找到一个未合并过的集合 $B$。如果无法找到，说明其代表元所在的 SCC 是无出度的，可以直接在后续的合并过程中忽视该集合。

由于每轮有效集合个数减半。跑 $\mathcal O(\log(nm))$ 轮就可以保证不会再出现合并了。每轮的 bfs 复杂度是线性的，因此时间复杂度 $\mathcal O(nm\log nm)$。

[通过记录 on LOJ](https://loj.ac/s/2219487)

---

## 作者：dspt (赞：2)

来一种理论时间复杂度更优的做法（不算常数 $16$）。

但由于本题中常数对时间复杂度具有显著影响，本文中时间复杂度分析中会带有常数。

&nbsp;
## Part 1

将风向字符串 $D$ 倍长直到长度超过 $\max U$。

考虑一个点 $(x,y)$，它能被感染的条件是什么。我们先把它的四个方向中已经被感染的点标出来。比如是这样：

```
.**
.x*
...
```

图中 $(x,y)$ 用 `x` 标出。它的北方和东方的点已经被感染。只要字符串 $D$ 中存在一个长度大于等于 $U_{x,y}$ 的子串满足这个子串只由 `N` 和 `E` 构成。那么它就可以被感染。不妨记 $a_{\tt NE}$ 表示 $D$ 中最长的由 `N` 和 `E` 构成的子串长度，形式化的写出条件就是：$a_{\tt NE}\geqslant U_{x,y}$。

一个点四个方向的点是否被感染一共有 $16$ 种情况。对于每种情况都可以求出对应的 $a$，这部分时间复杂度是 $O(16U)$。于是我们可以在 $O(4)$ 的时间内判断出在当前情况某个点能否被感染。

&nbsp;
## Part 2

接下来我们想个暴力做法。枚举起点 $(sx,sy)$。用`queue`维护 BFS。注意到感染区域形成一个连通块。我们先把 $(sx,sy)$ 放到队列中。每次取出队首，判断它四周的点能否被感染，记 $S=nm$，单次时间复杂度 $O(16S)$。

这样做的正确性在于：在某个点 $(x,y)$ 被感染后，如果另一个点 $(tx,ty)$ 的状态由不可感染变成了可以感染，那么 $(tx,ty)$ 必定是在 $(x,y)$ 的四周的。

总时间复杂度 $O(16S^2)$，可以获得 6 分。

&nbsp;
## Part 3

每次重新 BFS 显然不行。我们来分析一下性质。

如果从点 $u$ 开始感染，点 $v$ 最终被感染了，那么我们连一条有向边 $u\to v$。这样可以得到一张图。一个点能感染的点数就是这个点在图中可以到达的点的数量。只要我们把图建出来，缩点后非常好处理。

建图很困难。但是我们不需要把所有点能感染的点数都算出来。我们只要求出最小的就可以了。考虑上述的图缩点之后的结果：一个 SCC 内点能到达的点的数量就是该 SCC 和它在 DAG 上所有后继 SCC 的大小之和。显然只有出度为 0 的 SCC 才有可能成为最小答案。

考虑对每个 SCC 选择其中任意一个点作为其代表点。从代表点出发 BFS 的答案肯定和从 SCC 中任意一个点出发 BFS 的答案是一样的。

如果有一条边 $u\to v$，那么有两种情况：

+ $u,v$ 属于同一个强连通分量。
+ $u,v$ 不属于同一个强连通分量，那么 $u$ 的 SCC 在 DAG 上是 $v$ 的 SCC 的前驱，$v$ 必然比 $u$ 优。

&nbsp;
## Part 4

看到别的题解都用了 Boruvka，我第一步也是类似的，但后续不用。我们先判断是否有点没有连出边，如果有，那么最小感染数量为一，这些点就是答案。不然我们随便找一个它四周的、可以从它到达的点连边。

对样例举例：

![](https://cdn.luogu.com.cn/upload/image_hosting/jsy9qnzf.png?x-oss-process=image/resize,m_lfit,h_300)

红色的就是连边。由于每个点都有出边，所以可以得到一个内向基环树森林。环不好处理，我们在环上选一个代表点，让环上的其它点都连到它，这样显然不会对后续产生影响，于是上图就可以调整成：

![](https://cdn.luogu.com.cn/upload/image_hosting/ngmjgydp.png?x-oss-process=image/resize,m_lfit,h_300)

这是一片内向树森林。通过前面对于连边的分析我们知道答案肯定来自某几棵内向树的根。我们从任意一棵内向树的根出发进行 BFS：

+ 如果 BFS 到一个不属于这棵树中的点，就连上这条边，始终维护内向树的结构，然后退出 BFS。

+ 如果 BFS 到一个有 used 标记（见后一种情况）的点，说明答案不如这个点所在的 SCC 优，把这些点也打上 used 标记，直接退出 BFS。

+ 如果 BFS 直到停止都没有出现上述的情况，就说明该点所在的 SCC 是 DAG 上度数为 0 的点。

  这个点的答案就是这次 BFS 经过的点的数量。注意这种情况中我们要把这些 BFS 经过的点打上 used 标记。

这样 BFS 的时间复杂度是内向树大小 $\times 16$。我们只要每次取最小的内向树进行 BFS。这样一棵内向树如果接在另一棵内向树上，这棵内向树的大小至少翻倍。我们需要用并查集维护一下连通性。所以总时间复杂度为 $O(16U+S(\alpha(S)+\log S+16))$。

![](https://cdn.luogu.com.cn/upload/image_hosting/f9n11prl.png?x-oss-process=image/resize,m_lfit,h_300)

![](https://cdn.luogu.com.cn/upload/image_hosting/cmlv3vdh.png?x-oss-process=image/resize,m_lfit,h_300)

在图三中，我们取以 $(1,3)$ 为根的内向树开始 BFS（虽然不是最小的，但仅用于示例，没关系）。它会连到 $(1,2)$ 上。

在图四中，我们取以 $(1,1)$ 为根的内向数开始 BFS，不会 BFS 到这棵树以外的点。所以最终能 BFS 到的点数（黄色的方格）就是这个点的答案。

&nbsp;
## Part 5

根据前面的做法，我们发现很多时间都浪费在了相同格子的 BFS 上。即一个格子会被遍历到 $\log S$ 次。我们从这点出发考虑优化。

我们每次 BFS 后不清空，仍然保留 vis 标记。重新修改一下 BFS 的流程：

+ 如果 BFS 到一个不属于这棵树中的点，就连上这条边，始终维护内向树的结构，然后退出 BFS。

  这一步中不同的是我们不清空 BFS 的`queue`，并且把当且这个点重新放到`queue`中。

+ 如果 BFS 到一个有 used 标记的点，说明答案不如这个点所在的 SCC 优，把这些点也打上 used 标记，直接退出 BFS。

+ 如果 BFS 到一个属于这棵树的点，把这个点到根的路径中没有被 vis 的点全部放到队列中。

  一个点被 vis 到可能是因为以前的时候被第一步打断了。但是 BFS 信息（队列和 vis 标记）其实是可以继承的。如果我们用`list`来代替`queue`，就可以保证拼接的时间复杂度为 $O(1)$。这样 BFS 遍历的点数就是 $O(nm)$ 的。

+ 如果 BFS 直到停止都没有出现上述的情况，就说明该点所在的 SCC 是 DAG 上度数为 0 的点。把这些 BFS 经过的点打上 used 标记。

上述做法中唯一的问题在于我们不能实现把从点到根的路径全部拉出来这个操作，这部分的时间复杂度不对。但是注意到我们只关心路径上没被 vis 的点和某些有残余 BFS 队列的点。我们使用路径压缩并查集。其实可以断言这些点即使被路径压缩后仍然会被`find`函数遍历到。只要在`find`时候特判一下就可以保证总时间复杂度为 $O(16U+S(\alpha(S)+16))$。

代码细节感觉很多，所以我只实现了 Part 4。由于有 $16$ 的常数，其实 $\log S$ 不一定是时间复杂度瓶颈，这个做法感受起来常数就很大，该数据范围下估计跑不过其它 Boruvka 的做法。

---

## 作者：wosile (赞：0)

我会做，好耶。

首先可以发现风向串并不重要，我们可以预处理出 $f_S$ 表示所有风向都在集合 $S$ 内的最长连续段，接下来很容易就可以判断一个点是否会被周围的点传染。

先不管计数。

容易证明只要从点 $x$ 开始搜索可以传染到 $y$，那么选择 $y$ 作为起点就一定不劣于 $x$。此时，我们从 $x$ 往 $y$ 连一条边，表示我们不需要求 $x$ 的答案，求 $y$ 就可以了。随着我们的搜索，整张图会形成一个森林。

我们考虑每次从没有出度的点开始搜索以他为起点的传染情况，如果传染到了一个和自己不在同一个连通块里的点，那就可以直接连边（和指向的连通块合并）然后扔掉当前点。如果在同一个连通块里则要继续搜索，因为显然你再扔掉当前点就成环了，当前连通块内所有点都有出度，但你没算出答案。

如果传染到最后都没能走出自己这个连通块，那么我们就算出了这个连通块的答案，算进总答案里，之后直接不考虑这个块即可。因为如果别的块指向这个块内的点，那个块整体都不优。

假如我们从一个大小为 $s$ 的连通块开始搜索，在至多传染 $s$ 个位置之后，就要么传染不动，要么传染到了别的连通块并与之合并了，进行一次这样的搜索的时间复杂度是 $O(s)$。在进行足够多搜索之后，所有的连通块全都被删掉，也就被统计进答案里了。

容易想到，如果我们每次从最小的连通块开始搜索，就可以保证每次合并都是小集合向大集合合并，时间复杂度是小集合的大小。这是启发式合并的过程，时间复杂度为 $O(RC \log RC)$。

然后考虑计数。我们只在传染不动的时候会统计答案，此时，因为我们是从一个连通块的根开始搜索，他能走到的所有点也都能走到他自己，换言之，他走到的点之间的可达关系构成一个 SCC。 显然一个点的可达点数在当前连通块内最小当且仅当他在这个 SCC 里面。所以这个连通块的可行点数数值上就是最小答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int M,n,m;
#define N 805
char s[200005],t[10]="NSWE";
int fs[16];
inline int id(int x,int y){
    return (x-1)*m+y;
}
int fa[N*N],sz[N*N],a[N][N],vis[N][N],dead[N][N];
int find(int x){
    return x==fa[x]?x:fa[x]=find(fa[x]);
}
priority_queue<pair<int,int> >pq;
queue<pair<int,int> >q;
vector<pair<int,int> >vec;
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
int ans1=0x3f3f3f3f,ans2=0;
bool check(int x,int y){
    if(!a[x][y])return false;
    if(vis[x][y])return false;
    int c=0;
    for(int d=0;d<4;d++)if(vis[x+dx[d]][y+dy[d]])c|=1<<d;
    return a[x][y]<=fs[c];
}
int main(){
    scanf("%d%d%d",&M,&n,&m);
    scanf("%s",s);
    for(int i=0;i<M;i++)s[i+M]=s[i];
    for(int j=0;j<16;j++){
        int cnt=0;
        for(int i=0;i<M*2;i++){
            int fl=0;
            for(int k=0;k<4;k++)if(((1<<k)&j) && t[k]==s[i])fl=1;
            if(fl)fs[j]=max(fs[j],++cnt);
            else cnt=0;
        }
        if(cnt==M*2)fs[j]=0x3f3f3f3f;
    }
    for(int i=1;i<=n*m;i++)fa[i]=i,sz[i]=1;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(a[i][j])pq.push({-1,id(i,j)});
    while(!pq.empty()){
        auto [SZ,S]=pq.top();
        pq.pop();
        if(fa[S]!=S || sz[S]!=-SZ)continue;
        int sx=(S-1)/m+1,sy=(S-1)%m+1;
        vec.clear();
        vec.push_back({sx,sy});
        while(!q.empty())q.pop();
        q.push({sx,sy});
        vis[sx][sy]=1;
        int to=-1;
        while(!q.empty()){
            auto [x,y]=q.front();q.pop();
            for(int d=0;d<4;d++){
                int nx=x+dx[d],ny=y+dy[d];
                if(!check(nx,ny))continue;
                int v=id(nx,ny);
                if(find(v)!=S){
                    to=find(v);
                    break;
                }
                vis[nx][ny]=1;
                vec.push_back({nx,ny});
                q.push({nx,ny});
            }
            if(to!=-1)break;
        }
        for(auto [x,y]:vec)vis[x][y]=0;
        if(to==-1){
            dead[sx][sy]=1;
            if(vec.size()<ans1)ans1=ans2=vec.size();
            else if(vec.size()==ans1)ans2+=vec.size();
        }
        else{
            fa[S]=to;
            sz[to]+=sz[S];
            if(!dead[(to-1)/m+1][(to-1)%m+1])pq.push({-sz[to],to});
        }
        vec.clear();
    }
    printf("%d\n%d\n",ans1,ans2);
    return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：0)

### Preface

好难。

## Solution

首先那个串 $\mathcal S$ 的唯一作用就是告诉我们：对于位置 $u$，当 $u$ 的邻居集合 $S$ 被染色时，$u$ 也会被染色。

这个东西看起来就很适合连成有向图！具体的的，我们连边 $u\to v$ 当且仅当如果 $u$ 被染色，那么 $v$ 也会被染色，所求即为缩点后的 DAG 上大小最小的叶子和它们的大小和。 

那我们考虑一个事实：如果 $u\leadsto v$  且 $v\not\leadsto u$，那么 $v$ 就似了。

我们考虑维护这个 DAG 的内向生成森林，那么答案只能出现在每个根所在的 SCC 中，暴力统计复杂度就是对的。

有规律的图的生成森林可以考虑 Boruvka，我们每次对于一棵树的根在其所在的连通块中 dfs 一次，并合并。这件事至多发生 $\log n$ 轮，复杂度也就是 $O(nm\log n)$ 的。

---


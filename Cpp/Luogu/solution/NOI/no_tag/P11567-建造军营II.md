# 建造军营II

## 题目背景

A 国又在与 B 国激烈交战中。

## 题目描述

在前线，A 国有 $n$ 个重要据点。有一些据点间存在双向道路，可以选择派遣/不派遣军队驻守。
  
  A 国情报部门得知，B 国即将实行 $k$ 个作战计划中的一个。第 $i$ 个作战计划的内容是，向 $p_i$ 据点至 $q_i$ 据点的交通线发动袭击。具体来说，B 国将选择一条**可经过重复据点，但不经过重复道路**的由 $p_i$ 到 $q_i$ 的路径，若这条路径上**存在道路无驻守军队**，则袭击成功。 
  
  A 国希望 B 国的任何作战计划都不可能获得成功。除了确保兵力足够以外，A 国还可以选择一些道路进行焦土行动——这将防止 B 国通过这条道路实施作战。但是焦土行动本身也会影响 A 国的补给运输，因此被焦土的道路上不应该部署部队；同时， A 国要求在焦土行动后，任意两个据点之间仍然存在至少一条不经过被焦土的道路的路径。
  
  作为 A 国军队最高参谋部的成员，你被要求给出不同防守计划的方案数——两个防守计划不同，当且仅当存在一条道路的驻守情况不同，或一条道路焦土行动实施与否的状态不同。方案数对 $10^9+7$ 取模。

## 说明/提示

对于 $100 \%$ 的数据：$2 \leq n \leq 16$，$w_{i,j} = w_{j,i}$，$w_{i,i}=0$，$0\le k \leq 3 \cdot n$，$1 \leq p_i,q_i \leq n$。

| 子任务编号 | 分值 | $n \leq$ | $k \leq$ | 特殊性质 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 5 |$ 3$ | 无特殊限制 | / |
| 2 | 10 | $6 $| 无特殊限制 | / |
| 3 | 10 | 无特殊限制 | $0$ | / |
| 4 | 10 | 无特殊限制 | 无特殊限制 | A |
| 5 | 20 | 无特殊限制 | 无特殊限制 | B |
| 6 | 10 | $10$ | 无特殊限制 | / |
| 7 | 10 |$13 $| 无特殊限制 | / |
| 8 | 25 | 无特殊限制 | 无特殊限制 | / |

特殊性质 A：保证 $\sum_{i,j} w_{i,j} = 2n-2$。

特殊性质 B：保证 $p_i = 1$。

## 样例 #1

### 输入

```
2 1
01
10
1 2```

### 输出

```
1```

## 样例 #2

### 输入

```
参见下发文件```

### 输出

```
参见下发文件```

# 题解

## 作者：Graygoo (赞：11)

先考虑解决一个和本题正解关联度很大的问题：给定 $n$ 个点与其邻接矩阵，再给出将每个集合看作一个 "节点" 的方案数，要求你求出先将全集拆成一些 "节点"，然后将这些节点连成树的方案数和。(两个 "节点" 之间边的数量还是按照原图这两个集合之间边数量计算)。
  
  我们有一个朴素做法，大概是枚举根的集合，然后再对子树dp，这样的话由于根不同根和子树间边数也不同，必须记录一个 $3^n$ 的状态，加上枚举子集成了 $4^n$，如果用这玩意来实现本题做法可以过 $n=13$ 的点。可以使用子集卷积优化到 $O(3^n \cdot n^2)$，没啥用。
  
  考虑更高妙做法。如果我们直接做 $f_S \cdot f_T→f_{S+T}$ 这样一个简单转移，毫无疑问会算重，但是观察一下算重的次数，发现实际上是以"合并操作"为边建立的一个树的拓扑序个数。那么我们只要同时记录 $f_{S,v}$ 表示 S 这个集合由 v 个小集合合并而来，然后一转移好 $ f_{S,∗}$ 就把 $f_{S,v}→{f_{S,v} \over v}$
，自然就把算重的部分给干掉了。这样我们得到一个新的 $O(3^n \cdot n^2)$，但常数不知道比上面那个小到哪里去了。
  
  继续优化这个做法。发现我们在做子集卷积时同时还要做 $(+,×)$ 卷积，这个非常亏。考虑直接维护点值，需要系数时再插回来就好了。可以预处理拉插的系数。复杂度变为 $ O(3^n⋅n+2^n \cdot n^2+n^3)$。
  
---
  
  我们宣称，本题做法就是若干个上述问题（下称 X 问题）的拼接。
  
  首先套路式地发现，一个 $(p_i,q_i)$ 的约束实际上就是从 $p_i$ 所在的边双连通分量到 $q_i$ 所在的边双连通分量之间的所有边都必须有军队驻守。那么我们自然要考虑处理出一个集合是一个边双连通分量情况下的内部连边方案数。那么我们先搞出一个集合是联通的方案数，这个相信大家都会。然后如果这个集合是联通的但不是一个边双，内部的边双就必定组成一棵树，我们利用 X 问题把这种情况容斥掉即可。
  
  随后我们观察最终的边双树的形态，发现实际上是由 **未被染色的边双与被染色的极大连通块** 构成的树（当然需要约束没有跨越集合的边），这也是一个 X 问题。那么现在我们需要求出每个集合作为"被染色的极大联通块"的方案数。如果这个集合被分为了多个被染色的极大联通块，它们还是形成一棵树，所以我们又可以使用 X 问题容掉它，所以本题就做完了。

---

## 作者：cyffff (赞：6)

[$\text{Link}$](https://www.luogu.com.cn/problem/P11567)

联考迫真 NOIP 模拟赛 T3（

学完了 cxy 的 APIO2025 课件来做的，复杂度比原 std 优一点。

## 题意

给定一个 $n$ 个点 $m$ 条边的无向连通图 $G=(V,E)$，再给定 $k$ 个点对 $(a_i,b_i)$。对于一个连通边子图 $G'=(V,E')$，可以选择其中的一个边子集，一条边可选当且仅当不存在 $1\le i\le k$ 使得存在从 $a_i$ 到 $b_i$ 且经过该边的边简单路径，定义 $G'$ 的权值为选择边子集的方案数。

求所有连通边子图的权值和，对 $10^9+7$ 取模。

$n\le 16$。
## 题解

容易发现权值计算与边双有关，具体地，将边双缩点后，对于每一对点对 $(a_i,b_i)$，将 $a_i,b_i$ 所在边双之间的所有边标黑，则可以进行选择的边为不被标黑的边。

### 边双连通-连通变换
首先必须要会求边双连通子图数。先考虑如下问题：定义 $G=\text{Trans}(F,c)$，其中 $F,G$ 分别为集合幂级数，$c$ 为一常数。对于集合 $s$ 定义其划分 $s_{1\sim k}$ 的权值为 $c^{k-1}\prod_{i=1}^k F_{s_i}$ 再乘上用 $k-1$ 条边将它们连通的方案数，即每选择一条边合并两个连通块带来 $c$ 的贡献。需要返回的集合幂级数 $G$ 的 $s$ 项系数即为 $s$ 所有划分的权值和。

考虑按照两端点编号的最大值的顺序进行加边。设集合幂级数 $p_i$ 表示允许加两端点编号均 $\le i$ 的边时的答案。对于一个点集 $S$，考虑删去新加边中一端点为 $i$ 的边，形成若干个连通块 $S=P\cup T_1\cup T_2\cup\cdots\cup T_k$，其中 $P$ 包含点 $i$，其余连通块均不包含。

设集合幂级数 $q_{i-1,s}=[i\notin S]p_{i-1,s}\cdot cof(i,S)\cdot c$，其中 $cof(i,S)$ 表示 $i$ 与集合 $S$ 内编号 $\le i$ 的点的边数。容易发现有 $p_{i,s}=(p_{i-1}\cdot \exp q_{i-1})_s$，注意该式只有在 $i\in S$ 的项成立，对于其余项平凡地有 $p_{i,s}=p_{i-1,s}$。

令 $F_s$ 表示 $s$ 内连通子图数，则 $\text{Trans}(F,-1)$ 即为边双连通子图数的集合幂级数。考虑 $s$ 的一个子图，若其中存在割边，则这条割边必然分别在 $F_s$ 处和合并时贡献 $1$ 与 $-1$，即该方案不会被计入。求解 $F_s$ 是经典问题，直接求 $\ln $ 即可。

时间复杂度 $O(2^nn^3)$。

### 本题解法

我们希望将原图划分为若干黑边连通块与白边双连通分量，且这些连通块之间均用白边连接。

先求出每个集合 $s$ 作为黑边连通块的方案数。令 $F_s$ 表示 $s$ 内连通子图数，注意不能存在 $a_i,b_i$ 使得其中恰有一个点在 $s$ 内。考虑 $F'=\text{Trans}(F,-1)$，则若一种方案中存在白边，其必然会被抵消。

接下来需要求出集合 $s$ 作为白边双连通分量时的权值之和。令 $G_s$ 表示 $s$ 内连通子图权值和，注意不能存在任意 $a_i$ 或 $b_i$ 在 $s$ 内。$G$ 的求解仍可用求 $\ln$ 解决，而 $G'=\text{Trans}(G,-2)$ 即为所求。

最后只需调用 $\text{Trans}(F'+G',2)$ 合并连通块即可。

时间复杂度 $O(2^nn^3)$，经卡常可获得最优解。

附一份未经卡常的代码：
```cpp
const int S=1<<16,N=16+2,M=N*N,mod=1e9+7;
int n,m,k,u,pw2[M],pw3[M],a[N],ct[S],c1[S],c2[S],T[S],F[S],G[S],A[S],B[S];
inline void Trans(int *F,int c){
	static int A[S],G[S];
	for(int i=0;i<n;i++){
		for(int s=0;s<u;s++)
			A[s]=s>>i&1?0:1ll*c*F[s]%mod*__builtin_popcount(a[i]&s)%mod;
		Poly::Exp(A,A);
		Poly::Mul(A,F,G);
		for(int s=0;s<u;s++)
			F[s]=s>>i&1?G[s]:F[s];
	}
}
int main(){
//	freopen("ex_war4.in","r",stdin);
	n=read(),k=read(),u=1<<n;
	Prefix(u),Poly::init(u);
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++){
			int c=getc()-'0';
			if(i<=j||!c) continue;
			a[i]|=1<<j,ct[(1<<i)|(1<<j)]++;
		}
	while(k--){
		int u=read()-1,v=read()-1;
		c1[1<<u]++,c1[1<<v]++,c1[(1<<u)|(1<<v)]-=2;
		c2[1<<u]++,c2[1<<v]++;
	}
	pw2[0]=pw3[0]=1;
	for(int i=1;i<=n*n;i++)
		pw2[i]=add(pw2[i-1],pw2[i-1]),
		pw3[i]=3ll*pw3[i-1]%mod;
	for(int i=0;i<n;i++)
		for(int s=0;s<u;s++)
			if(s>>i&1)
				ct[s]+=ct[s^(1<<i)],
				c1[s]+=c1[s^(1<<i)],
				c2[s]+=c2[s^(1<<i)];
	for(int s=0;s<u;s++)
		T[s]=pw2[ct[s]];
	Poly::Ln(T,F);
	for(int s=1;s<u;s++)
		if(!c1[s])
			A[s]=F[s];
	Trans(A,mod-1);
	for(int s=0;s<u;s++)
		T[s]=pw3[ct[s]];
	Poly::Ln(T,F);
	Trans(F,mod-2);
	for(int s=1;s<u;s++)
		B[s]=c2[s]?A[s]:F[s];
	Trans(B,2);
	write(B[u-1]);
	flush();
}
```

---


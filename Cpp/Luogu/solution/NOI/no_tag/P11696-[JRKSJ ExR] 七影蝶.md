# [JRKSJ ExR] 七影蝶

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/n7wkxyof.png)


## 题目描述

久岛鸥给了你一个长度为 $n$ 的非负整数序列 $a_{1\sim n}$。

接下来有 $q$ 次询问，每次询问给出非负整数 $L,R$，求

$$\max_{x=L}^R\left(\sum_{i=1}^n\mathrm{popcount}(a_i+x)\right)$$

其中 $\mathrm{popcount}(x)$ 表示 $x$ 在二进制形式下数位 $1$ 的出现次数。

## 说明/提示

### 样例解释

对于样例 $1$，第一组询问取 $x=10$ 时达到最大值，即 $\mathrm{popcount}(11)\times 3+\mathrm{popcount}(14)\times 2+\mathrm{popcount}(15)=3\times 3+2\times 3+4=19$。

容易验证 $x$ 取范围内其他值都不能使答案更大。

### 数据范围
**本题开启捆绑测试。**

令 $V$ 为数组中元素与询问区间端点的最大值。

| $\text{Subtask}$ | $n\le$ | $q\le$ | $V\le$ |$\text{Score}$ |
| :-----------: | :-----------: | :-----------: | :---------: | :----------: |
|$1$ | $10$| $10$ | $10$ | $5$ | $2$
|$2$ | $10^5$| $5\times 10^5$ | $10^3$ | $5$ | $2$
|$3$ | $10^5$| $10^5$ | $10^5$ | $15$ | $2$
|$4$ | $10^4$| $10^4$ | $10^9$ | $10$ | $2$
|$5$ | $10^5$| $1$ | $10^9$ | $15$ | $2$
|$6$ | $10^5$| $5\times 10^5$ | $10^9$ | $20$ |  $5$
| $7$ | $5\times 10^5$ | $10^5$ | $10^9$ | $20$ | $5$
| $8$ | $5\times 10^5$ | $5\times 10^5$ | $10^9$ | $10$ | $2$ |
| $9$ | $5\times 10^5$ | $5\times 10^5$ | $10^{11}$ | $0$ |

对于所有数据，保证 $1\le n,q\le 5\times 10^5$，$0\le L\le R\le 10^{11}$，$0\le a_i\le 10^{11}$。

子任务 $6,7,9$ 的时间限制为 $5$ 秒，其余子任务均为 $3$ 秒。

## 样例 #1

### 输入

```
6 6
1 1 4 5 1 4
1 10
1 5
3 6
4 7
3 9
2 5```

### 输出

```
19
13
16
16
16
13```

## 样例 #2

### 输入

```
10 10
765 523 255 781 647 98 451 636 109 771
394 405
128 161
332 565
996 1003
3 116
403 486
255 582
744 861
399 408
528 996```

### 输出

```
58
59
69
68
66
62
69
75
58
75```

# 题解

## 作者：fjy666 (赞：15)

## Subtask 1,2,3

$V$ 较小，因此可以枚举 $1\le i\le V$，计算出 $\texttt{ans}_i=\sum_{j=1}^n \operatorname{popcount}(a_j+i)$，最后询问做 RMQ。

$\texttt{ans}_i$ 可以通过将所有数插入 01 Trie，然后每次对 01 Trie 做全局 $+1$ 维护答案得到。时间复杂度为 $\mathcal{O}(V\log V+q\log V)$

## Subtask 5

可以通过修改 [Make Equals](https://www.luogu.com.cn/problem/CF1188D) 的做法过这一档分。

## Subtask 4,6

考虑用更高妙的方法维护出 $\texttt{ans}_i$。

拆位，$a_i+j$ 的第 $k$ 位为 $1$ 可以转化为 $j$ 的后 $k$ 位在一个值域区间内，因此假如只考虑第 $k$ 位的话，$\texttt{ans}$ 数组可以被 $n$ 次区间加 $1$ 维护出来。

假设你已经维护出了第 $k$ 位及以下的 $\texttt{ans}_i(0\le i<2^k)$，可以发现第 $k+1$ 位的线段树根节点 $[0, 2^{k+1})$ 的两个儿子 $[0, 2^k)$ 和 $[2^k, 2^{k+1})$ 关于第 $k$ 位及以下的信息都是完全一致的。

因此我们对线段树进行可持久化，然后每次 $k\gets k+1$ 时新建根节点，然后把根节点的两个儿子都指定为前一层的根结点，同时将根节点维护的值域扩大两倍即可。

（我称呼它为值域倍增线段树）

空间，在新建节点的时候需要判一下这个节点是不是这一层已经新建过的，如果是的话就不要新开节点了。

时空复杂度均为 $\mathcal{O}(n\log^2V)$，期望得分 $55\sim 70$。（~~Sub 5 的线段树卡了常~~，这不是出题人本意，被卡的老师们对不起/wq）

[这一部分参考代码。](https://www.luogu.com.cn/paste/j40l9zbl)

## Subtask 7,8 (improved by Zhoukangyang)

观察线段树，第 $k$ 层的 $\mathcal{O}(n)$ 次区间操作会把线段树分成 $\mathcal{O}(n)$ 段，每段所受到的区间加操作是完全相同的。

这些“段”在 $k$ 层的操作相同，在 $>k+1$ 层受到的操作必定也是相同的，因此考虑每次做完区间加后把受到操作相同的值合并起来。 

合并后会有 $\log V$ 层，每层有 $\mathcal{O}(n)$ 段。每一段需要储存：区间 $\max$，以及被打的标记的总和。

查询类似线段树，中间整段做区间 $\max$，左右两端往下递归，递归需要带上标记，类似标记永久化。  

使用双指针与线性 RMQ 优化可以做到 $\mathcal{O}((n+q)\log V)$，不加这些是 $\mathcal{O}(n\log V+q\log^2 V)$。

## Extra

存在 Meet in the middle 做法。大概是后 $26$ 位预处理，然后对于询问枚举前 $6$ 位从而平衡复杂度。

这个是出题人没想到的，出题人在比赛时看到这个做法后上巴吓得掉下去了。

[EuphoricStar](https://www.luogu.com.cn/user/275273) 在赛时最后 1min 用这个做法[绝杀](https://www.luogu.com.cn/record/202248817)了这个题。Orz

~~通过了~~杀了。

****

> 致：鹰原羽依里先生  
> 我愿越过七片大洋，与君相会。  
> 满怀着我的爱意。  
> 胡子猫海盗团 · 久岛鸥

---

## 作者：Sublimity (赞：8)

基于出题人 Subtask 7 的做法，在此基础上我们往每一层分割点集合里再加上每个询问 $l, r$ 的后 $k$ 位。  

这样会让一层有 $n+q$ 段，但是询问只需要在最上层做一次 RMQ 即可（先用二分找到 $l_i, r_i$ 在最上层的位置，由于只有一次，`lower_bound` 即可）。

不需要离线双指针，也不需要线性 RMQ。代码长度和常数均有显著下降。

---

## 作者：orz_z (赞：2)

钦定 $a_i+x$ 的第 $k$ 位为 $1$ 的条件为 $(a_i+x)\bmod 2^k\ge 2^{k-1}$。

可以求出 $x\bmod 2^k$ 的两个区间 $[2^{k-1}-a_i, 2^k-a_i),[2^k+2^{k-1}-a_i, 2^k)$。

则对每个 $a_i$，求出 $\mathcal O(\log V)$ 个区间，形如 $x\bmod 2^k\in [l,r]$，则答案加一。

考虑一个主席树，对 $k$ 从小往大处理，做完 $k$ 的修改之后，将当前版本复制一遍作为右子树就能完成对 $k+1$ 层的前置处理，时空复杂度均为 $\mathcal O(n\log^2V)$。

考虑询问时如果**得到了 $k+1$ 层及以上所有修改对这次询问的所有贡献**，那么第 $k$ 层及以后的贡献就和上面的修改无关了。

类似线段树结构，询问区间在一个节点分裂开后，每一层最多两个节点，则上面的“贡献”可以视作 `LCA` 处的答案与每层两个节点之前的标记和。

考虑优化。

注意到：

* 后 $k$ 位一类区间为 $[l,r)$，则后 $k+1$ 位为 $[0, r)$ 或 $[l+2^{k-1},r+2^k)$，且有 $r=l+2^{k-1}$。

* 后 $k$ 位二类区间为 $[l,2^k)$，则后 $k+1$ 位为 $[2^{k-1}+l,2^{k+1})$，且有 $r_1+2^k=2^k-a_i+2^k=2^k+2^{k-1}+2^{k-1}-a_i$。

故 $k$ 级区间的端点，分别 $+0、+2^k$ 后得到的端点为 $k+1$ 级区间的超集。（1）

上面的东西说明了什么？我们可以考虑**模拟线段树结构，每层分成若干区间，满足下层区间是当前层区间的分裂！**

并且根据复制的过程，第 $k+1$ 层的值域为 $[0,2^{k+1})$，一个数 $x\in [2^k,2^{k+1})$，往下跳刚好跳到下一层的 $x-2^k$ 处，所以**这些端点也能满足往下处理的条件！**

故我对每层的修改维护若干等价类，即对端点去重后取相邻为一段，一共 $\mathcal O(n)$ 个。

则当前第 $k$ 层的修改对询问区间的贡献是能处理的，前提是预处理出了，在考虑**第 $k$ 层及以后的修改**后，每个等价类的 $\max$。

还有一个好处是，可以简单处理出每层对端点的离散化：过程是每个端点每次头顶加一位，类似后缀排序做，具体来说，将 $-a_i$ 排序，然后将 $2^{k-1}-a_i,2^k-a_i,2^k+2^{k-1}-a_i$ 归并起来即可。

现在能做到预处理 $\mathcal O(n\log V)$，询问 $\mathcal O(q\log V)$，每次查当前层的等价类区间 $\max$（维护一个线性 `rmq`），剩下的散块吸收标记后放到下一层处理。

考虑优化，将询问端点的后 $k$ 位插入每一层的端点中，恰好能满足条件 (1)！

那么每次询问直接在最上面一层做 `rmq` 就能直接回答！

时间复杂度为 $\mathcal O((n+q)\log V+q)$，空间对数，也可以换成线段树。

---


# [集训队互测 2015] 未来程序·改

## 题目背景

洛谷可提交代码长度最长为 50KB。如果您的代码超过 50KB，请尝试压行、替换变量名等操作。

## 题目描述

在 2111 年，第 128 届全国青少年信息学奥林匹克冬令营前夕，Z 君找到了 2015 年，第 32 届冬令营的题目来练习。

他打开了第三题 “未来程序” 这道题目：

“本题是一道提交答案题，一共 10 个测试点。

对于每个测试点，你会得到一段程序的源代码和这段程序的输入。你要运行这个程序，并保存这个程序的输出。

遗憾的是这些程序都效率极其低下，无法在比赛的 5 个小时内得到输出。”

Z 君想了一下，决定用 2111 年的计算机来试着运行这个题目，但是问题来了，Z君已经找不到 96 年前的那次比赛的测试数据了……

没有给出输入数据的提交答案题就不成其“提交答案题”之名，为了解决这个问题，Z君决定将这个题目改造成传统题。

Z 君知道 96 年前的计算机的性能比现在差多了，所以这道题的测试数据中，输入数据的规模被设计成很小，从而，做这道题的选手只需要暴力模拟源代码的工作流程就可以通过它。

现在这道题摆到了你的面前。

本题是一道传统题，一共有 10 个测试点。

对于每个测试点，你的程序会得到一段程序的源代码和这段程序的输入。你的程序需要运行这段程序，并输出这段程序的输出。

### **关于给出的源代码的约定**  

Z 君是一名 C++ 选手。为了简化这个问题，Z君在给出的源代码中去掉了 C++ 语言的大量特性。从而这个源代码具有以下特点：  


- 第一行必定为 `#include<iostream>` （不含引号）  
  - 这个库中只会调用到对象 `cin`，`cout`，`endl`，`cin` 的 `>>(int)` 函数和 `cout` 的 `<<(int)` 函数。这两个函数分别用于输入和输出一个整数，返回值分别 `cin` 和 `cout`。  
- 第二行必定为 `#include<cstdio>` （不含引号）  
  - 这个库中只会调用到 `putchar` 函数。`putchar(c)` 会输出 ASCII 码为 $c$ 的字符，并返回 $c$。  
- 第三行必定为 `using namespace std;` （不含引号）  
  - 对象 `cin` 的调用不再需要通过 `std::cin` 进行，`cout` 和 `endl` 同理。  
- `int main()` 没有任何参数。  
- 所有的变量都是 `int` 或 `int` 数组（含高维数组）类型。  
  - 对象 `cin`, `cout`, `endl` 是例外，注意 `putchar` 的参数也是 `int` 类型的。我们保证在运行时这个参数的值在 $0 \sim 127$ 中。  
  - 在运行时，不会出现数组越界问题。  
  - 没有维度的范围为 $1$。也即，不会出现 `int a[1][1][1][1][1];` 这样的情况。  
  - 维度的范围直接由十进制常量给出。也即，不会出现 `int a[(100+100)*2];` 这样的情况。  
- 所有的函数都是 `int` 类型，函数的参数只可能是 `int` 类型  
  - 注意函数的返回值可以被丢弃。  
  - 当没有显式地返回值时，返回 $0$。  
- `bool` 型被认为是一种特殊的 `int` 型  
  - `==` 在两个参数相同时返回 $1$，否则返回 $0$。  
  - `!=` 在两个参数相同时返回 $0$，否则返回 $1$。  
  - `<` 在第一个参数小于第二个参数时返回 $1$，否则返回 $0$。  
  - `<=` 在第一个参数小于等于第二个参数时返回 $1$，否则返回 $0$。  
  - `>` 在第一个参数大于第二个参数时返回 $1$，否则返回 $0$。  
  - `>=` 在第一个参数大于等于第二个参数时返回 $1$，否则返回 $0$。  
  - `&&` 在两个参数都不为 $0$ 时返回 $1$，否则返回 $0$。  
  - `||` 在两个参数都为 $0$ 时返回 $0$，否则返回 $1$。  
  - `^` 在两个参数中只有一个为 $0$ 时返回 $1$，其他时候返回 $0$。  
  - `!` 在参数为 $0$ 时返回 $1$，否则返回 $0$。  
  - 由于 `bool` 型被 `int` 型取代了，因此所有的表达式都应该被完全计算：例如在表达式 `(a && (b = c))` 中，即使 `a` 已经被确定是 $0$，仍然需要计算 `(b = c)` 的值，尽管无论 `(b = c)` 的值如何，整个表达式的值都是 $0$。  
- 可能用到的运算符及其优先级如下：（从高到低排列）  
  1. `()`, `[]`  
  2. `!`, `+`（正号）, `-`（负号）  
  3. `*`, `/`, `%`  
  4. `+`（加法）, `-`（减法）  
  5. `<=`, `>=`, `<`, `>`  
  6. `==`, `!=`  
  7. `^`  
  8. `&&`  
  9. `||`  
  10. `=`  
  11. `cout` 的 `<<` 与 `cin` 的 `>>`。  
- 所有 `int` 常量以十进制形式给出  
- Z 君没有对源代码进行混淆，所以源代码是可读的，你不必担心出现大量嵌套的花括号或此类的“垃圾代码”  
- 运行时使用的变量占用的空间的峰值不超过 $8\texttt{MB}$。也即，$2^{21}$ 个 `int`  
- 调用函数的深度不会超过 $10^3$ 层  
- 可能出现连续赋值，例如 `a = (b = (c = 3) + 2) % c`  
  - 之前对 `c` 的赋值将会反映到之后对 `c` 的引用上  
  - `=` 是右结合的，`a = b = c` 会被看作 `a = (b = c)`  
  - 赋值的返回值为赋值以后的值  
- 可能出现的程序流程控制语句：  
  - `if (statement) statement [else statement]`  
  - `while (statement) statement`  
  - `for ([statement]; [statement]; [statement]) statement`  
  - 那些作为条件的 `statement` 的返回值应当被视为 `bool` 型的。具体的来说，若返回值为 $0$，则为 `false`，若返回值非 $0$，则为 `true`。在 `for` 循环中，当第二个 `[statement]` 取空时，视为 `true`。  
- 空白字符只有新行符（即 `\n`）和空格。  
- 声明变量时默认初始值为 $0$，声明变量的同时不会进行赋值。  
- 没有注释  
- 所有的右花括号后没有分号  
- 没有用来连接语句的逗号  
- 没有函数和变量重名

## 说明/提示

### 限制与约定

输入的所有 `program.cpp` 都是手打的，每个输入文件的大小不超过 $7\texttt{KB}$。  

- 测试点 #1 的 `program.cpp` 见样例数据及附加文件下载。  
- 测试点 #2 到 #4 的 `program.cpp` 符合以下格式：  
  ```cpp
  #include<iostream>
  #include<cstdio>
  using namespace std;
  int main()
  {
      cout << <1> << endl;
  }
  ```
  在 #2 中：`<1>` 处是一个仅包含加、减、乘、除、模运算和自然数常数的没有括号的表达式。  
  在 #3 和 #4 中：`<1>` 处是一个不保证以上性质的表达式。  
- 测试点 #5 中：没有除 `main` 以外的函数，并且整个程序中只有顺序结构。  
- 测试点 #6 和 #7 中：没有除 `main` 以外的函数。  
- 测试点 #8 中：所有的变量都是全局变量。  
- 测试点 #9 和 #10 不保证任何特别的性质。  

所有 `program.cpp` 都可以用 MinGW GCC 4.7.2 编译运行。这就是说，所有的 `program.cpp` 中都没有语法错误。然而由于编译命令的不同，直接编译得到的 `program.exe` 在运行时有可能会因未为声明的变量和未设置返回值的函数设置 $0$ 的缺省值以及 `bool` 类型的处理方式不同而与标程产生不同的输出。  

为了更准确地说明程序可能出现的要素，也作为提示，下面给出了一个上下文无关文法，其初始符号为 PROGRAM。保证每个 `program.cpp` 都可被下面的文法生成，但是并非每个可被生成的程序都是合法的程序。

```
PROGRAM ::= # include < iostream > # include < cstdio > using namespace std ; FUNC_AND_VAR

FUNC_AND_VAR ::=
| ε
| int NAME ( OPTPARAMS ) { STATEMENTS } FUNC_AND_VAR
| int DEFINEVAR DEFINEVARS ; FUNC_AND_VAR

OPTPARAMS ::=
| ε
| int NAME PARAMS

PARAMS ::=
| ε
| , int NAME PARAMS

STATEMENTS ::=
| ε
| STATEMENT STATEMENTS

STATEMENT ::=
| EXPRESSION ;
| { STATEMENTS }
| int DEFINEVAR DEFINEVARS ;
| if ( EXPRESSION ) STATEMENT
| if ( EXPRESSION ) STATEMENT else STATEMENT
| for ( STATEMENT_IN_FOR ; OPTEXPRESSION ; STATEMENT_IN_FOR ) STATEMENT
| while ( EXPRESSION ) STATEMENT
| return EXPRESSION ;

STATEMENT_IN_FOR ::=
| OPTEXPRESSION
| int DEFINEVAR DEFINEVARS

OPTEXPRESSION ::=
| ε
| EXPRESSION

EXPRESSION ::=
| UNIT9
| EXPRESSION << UNIT9
| EXPRESSION >> UNIT9

UNIT0 ::=
| INT_CONSTANT
| UNIT0 [ EXPRESSION ]
| ( EXPRESSION )
| NAME ( OPTARGUS )    // 注：此处的 NAME 是一个函数名
| NAME    // 注：此处的 NAME 是一个变量名
| cin
| cout
| endl

UNIT1 ::=
| UNIT0
| + UNIT1
| - UNIT1
| ! UNIT1

UNIT2 ::=
| UNIT1
| UNIT2 * UNIT1
| UNIT2 / UNIT1
| UNIT2 % UNIT1

UNIT3 ::=
| UNIT2
| UNIT3 + UNIT2
| UNIT3 - UNIT2

UNIT4 ::=
| UNIT3
| UNIT4 < UNIT3
| UNIT4 <= UNIT3
| UNIT4 > UNIT3
| UNIT4 >= UNIT3

UNIT5 ::=
| UNIT4
| UNIT5 == UNIT4
| UNIT5 != UNIT4

UNIT6 ::=
| UNIT5
| UNIT6 ^ UNIT5

UNIT7 ::=
| UNIT6
| UNIT7 && UNIT6

UNIT8 ::=
| UNIT7
| UNIT8 || UNIT7

UNIT9 ::=
| UNIT8
| UNIT8 = UNIT9

OPTARGUS ::=
| ε
| EXPRESSION ARGUS

ARGUS ::=
| ε
| , EXPRESSION ARGUS

DEFINEVARS ::=
| ε
| , DEFINEVAR DEFINEVARS

DEFINEVAR ::=
| NAME
| DEFINEVAR [ INT_CONSTANT ]

NAME ::= 仅包含大小写字母、数字、下划线的非空字符串，且不以数字开头。

INT_CONSTANT ::= 仅包含数字的非空字符串，且不以0开头，或这个字符串就是0。
```

## 样例 #1

### 输入

```
2
1 2
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{int a, b; cin >> a >> b; cout << a + b << endl;}```

### 输出

```
3```

## 样例 #2

### 输入

```
10
9
6 1 7 5 1 7 2 2 4
#include<iostream>
#include<cstdio>
using namespace std;
int n, a[100];


int main()
{
    cin >> n;
    int i, j, this_VARIABLE_is_NOT_used;
    for (i = 1; i <= n; i = i + 1) cin >> a[i];
    for (i = 1; i <= n; i = i + 1)
    for (j = i + 1; j <= n; j = j + 1)
    if (a[i] > a[j])
    {
        int t;
        t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    for (i = 1; i <= n; i = i + 1)
    {
        cout << a[i];
        if (i == n) cout << endl; else putchar(32);
    }
    return 0;
}```

### 输出

```
1 1 2 2 4 5 6 7 7```

# 题解

## 作者：tiger2005 (赞：23)

我们首先实现一个虚拟机。

```cpp
namespace VM {
const int MEM_SIZE = 1 << 22;
const int BYTE_CODE_LENGTH = 1 << 12;
i64 mem[MEM_SIZE];
i64 bytecode[BYTE_CODE_LENGTH];

int run(i64 start) {
  i64 *pc = (i64*)start, *sp = mem + MEM_SIZE, *bp = sp, ax, tmp;
  // finally execute _PSH and _EXIT by modifying pc
  *--sp = _EXIT;
  *--sp = _PSH;
  tmp = (i64)sp;
  *--sp = tmp;

  while (1) {
    i64 ins = *pc++;
    switch (ins) {
    case _LEA: ax = (i64)(bp + *pc++); break;
    case _LEAP: tmp = ax * (*pc++); ax = (*sp++) + tmp; break;
    case _IMM: ax = *pc++; break;
    case _JMP: pc = (i64*)*pc; break;
    case _JSR: *--sp = (i64)(pc + 1); pc = (i64*)(*pc); break;
    case _BZ: pc = ax ? pc + 1 : (i64*)(*pc); break;
    case _BNZ: pc = ax ? (i64*)(*pc) : pc + 1; break;
    case _ENT: *--sp = (i64)bp; bp = sp; break;
    case _ADJ: if (*pc < 0) memset(sp + *pc, 0, sizeof(i64) * -(*pc)); sp = sp + *pc++; break;
    case _LEV: sp = bp; bp = (i64*)*sp++; pc = (i64*)*sp++; break;
    case _LI: ax = *(i64*)ax; break;
    case _SI: *(i64*)*sp++ = ax; break;
    case _PSH: *--sp = ax; break;
    case _OR: ax = *sp++ || ax; break;
    case _XOR: ax = bool(*sp++) ^ bool(ax); break;
    case _AND: ax = *sp++ && ax; break;
    case _NOT: ax = !ax; break;
    case _EQ: ax = *sp++ == ax; break;
    case _NE: ax = *sp++ != ax; break;
    case _LT: ax = *sp++ < ax; break;
    case _GT: ax = *sp++ > ax; break;
    case _LE: ax = *sp++ <= ax; break;
    case _GE: ax = *sp++ >= ax; break;
    case _ADD: ax = *sp++ + ax; break;
    case _SUB: ax = *sp++ - ax; break;
    case _MUL: ax = *sp++ * ax; break;
    case _DIV: ax = *sp++ / ax; break;
    case _MOD: ax = *sp++ % ax; break;
    case _NEG: ax = -ax; break;
    case _SHL: printf("%d", (int)ax); sp++; break;
    case _SHR: *(i64*)ax = input_a[input_cur++]; sp++; break;
    case _PCHR: putchar(ax); sp++; break;
    case _EXIT: return (int)ax;
    }
  }
}
};
```

下面是字节码的设计。这个设计实际上使用了一些寄存器和一个栈，其中栈的低地址部分储存编译时确定的全局变量空间，而高位置部分储存函数调用信息和临时变量空间。我们需要同时在数组中储存指针和变量值，为了方便起见，这里统一使用 `long long` 处理这些值。这样的处理方案可能会导致一些操作符的行为出现异常，但是题目中给出的数据代码都非常正常，或者说不依赖于整形溢出之类的操作，所以不妨就假设这样处理没有问题。

为了跑动字节码，我们需要至少四个寄存器：

- `pc`：指向当前字节码操作类型的指针，这个指针应当指向 `bytecode` 数组的一个位置；
- `sp`：指向栈顶值的指针。在这个指针的帮助下，`PUSH` 操作等价于 `*--sp = ...`，而 `POP` 操作等价于 `*sp++`。需要注意的是，栈的方向是从高地址向低地址，那么指针的移动方向也需要以次为依据移动；
- `bp`：指向栈底的指针。需要注意的是，`bp` 本身指向的内容并不是栈底的值，而是比栈底的值更高一个位置的值。这个值一般是上一个栈的栈底。在此基础上，我们就可以在退出函数时令 `sp = bp, bp = *sp++` 快速回到函数被调用时的栈情况；
- `ax`：临时的数值储存器。我们将会进一步讨论这个寄存器的作用。

我们观察表达式的求值部分，实际上其等价于在表达式树上以后序遍历的顺序计算每个子树的行为的过程。在平常的写法下，我们需要先把表达式子树的值压入栈中，然后调用根节点的操作进行运算。为了进一步减少对栈的操作，我们考虑如下策略：（下面的策略在双目操作符的表达式树上适用）：

- 计算左表达式树的值并自动储存在 `ax` 上；
- 将 `ax` 压入栈中；
- 计算右表达式树的值并自动储存在 `ax` 上；
- 这个时候操作的左值一定是栈顶的值，右值一定是 `ax`，调用双目操作对应的字节码，将左值弹出后与 `ax` 进行运算，将得到的结果继续储存在 `ax` 上返回。

这个方案很容易变成单目操作符的策略。而对于立即数，可以直接将对应的值加载到 `ax` 上。

接下来是字节码部分。

| 字节码 | 操作 |
| :-: | :-: |
| `LEA x` | 根据操作参数，以栈底为基址进行偏移，得到地址并储存在 `ax` 中。这个操作是为了在函数调用时准确的取到其局部变量的地址，因为在函数的规划下，每个局部变量和栈底的相对偏移是固定的。 |
| `LEAP x` | 取出栈顶值 `ax'`，并令 `ax = ax' + ax * x`。这个部分主要是为了取出数组的地址，因为数组中每个位置的地址应当是每一维参数的加权和，而权重是可以在编译期计算的。 |
| `IMM x` | 将立即数 `x` 加载到 `ax` 上。 |
| `JMP p` | 令 `pc = p`，也就是强制跳转。`p` 参数一般是以 `pc` 为基址的（因为多环境下字节码起始位置会发生变动），但是这一题中字节码储存在一个固定位置的数组中，所以可以忽略这一点。 |
| `JSR p` | 将 `pc + 1` 压入栈后令 `pc = p`。这个操作可以和下面的 `LEV` 一起，让虚拟机在函数退出时回到正确的状态下。 |
| `BZ p` | 如果 `ax` 等于 `0`，则令 `pc = p`，否则令 `pc = pc + 1`。这本质上等于以 `ax` 为参数进行选择跳转。
| `BNZ p` | `BZ p` 的镜像版本。 |
| `ENT` | 进入函数主体前的工作。此时需要将 `bp` 压入栈中，然后令 `bp = sp`。 |
| `LEV` | 函数调用结束。我们在函数调用时分别调用了 `JSR` 和 `ENT`，分别将 `pc` 的下一个位置和调用前的 `bp` 压入栈内，那么只需要先令 `sp = bp`，然后分别弹出 `bp` 和 `pc` 的新值即可。 |
| `ADJ x` | 令 `sp = sp + x`。这部分等价于函数开辟或回收局部变量的空间。需要注意的是，根据题目要求，在开辟空间（`x < 0`）时，需要将这部分空间全部置零。|
| `LI` | 令 `ax = *ax`，也就是根据地址取值。对于局部变量，需要根据 `LEA` 的结果取值，而对于全局变量只需要根据一个立即数取值。在取值前，地址都需要根据数组参数偏移。 |
| `SI` | 取出栈顶的一个地址 `p`，然后令 `*p = a`，也就是将 `ax` 写入到栈顶的一个地址中。 |
| `PSH` | 将 `ax` 压入栈中。 |
| `EXIT` | 退出程序。 |
| 其余部分 | 剩下的基本都是系统内置函数的 `caller` 和运算符处理了。关于运算符处理可以参考前面提到的策略。 |

由于字节码可能并不包含 `EXIT` 字节码，我们可以考虑将这个字节码写在栈上，然后模拟 `JSR` 事件，将指向 `EXIT` 的指针压入栈中。在上面的设计中，我们还将 `PSH` 指令写到栈上，这个指令可有可无。

在实现好执行字节码的虚拟机后，剩余的事情就是把代码转换为字节码。我们首先实现一个 `Reader`：

```cpp
struct Reader {
  char ch;
  Reader(bool) {}
  Reader() { ch = getchar(); }
  char seek() { return ch; }
  void skip() { ch = getchar(); }
  bool eof() { return ch == EOF; }
  void read(char &c) { c = seek(); skip(); }
  char read() { char res; return read(res), res; }
} reader(false);
```

这个读入类需要在主函数调用 `reader = Reader()` 激活，这是因为我们无法保证默认的读入操作在打开读写文件之前。

然后是实现 Token 流，也就是每次从读入类读出一个 `Token`。我们根据输入 `seek` 到的字符考虑：

- 如果这个字符是 `#`，则当前行是头文件引用，直接当作注释处理就好；
- 如果这个字符是字母，则贪心的读入一个只包含字母、数字和下划线的字符串，这个字符串可能为名称或者保留字，需要通过匹配确定。特别的，如果匹配到的保留字是 `using`，则一样可以看作注释处理；
- 如果这个字符是数字，则贪心的读入一个数字即可；
- 否则，我们认为这个字符是符号的一部分，贪心匹配符号即可。

接下来就是递归处理 Token 流并得到整个字节码架构。这里有一些需要注意的点。

1. 我们需要在每个代码块中新增一个作用域，形成作用域栈。在定义局部变量时，使用 `ADJ` 开辟空间，向当前作用域写入大小和偏移量等信息，在离开作用域时则需要撤销更改，同时计算好需要回收的内存，通过 `ADJ` 指令释放。

2. 在调用函数时，考虑到函数作用域的条件，我们需要按顺序执行下面的操作：在原先的作用域下计算各个参数并按顺序压入栈中 $\rightarrow$ 将作用域栈移动到另一个栈中，只保留全局变量 $\rightarrow$ 新增作用域，由于栈形态确定，可以轻易得到每个形参对应的基址偏移量 $\rightarrow$ 将形参绑定到作用域上，随后运行函数体 $\rightarrow$ 在函数 `LEA` 之后，手动 `ADJ` 移出所有参数，并且将作用域移回。

3. 本题中的控制中断语句只有 `return`，而没有 `break` 和 `continue`，那么只需要在计算好 `return` 对应的返回值之后，调用 `LEA` 离开函数即可。函数的返回值储存在 `ax` 中。

4. 需要注意本题中的一些细节，比如变量定义时自动初始化为 0，以及函数默认返回值为 0 等。前者可以在 `ADJ` 实现，已经提及，而后者可以在函数体的字节码最后，在 `LEA` 前加入 `IMM 0`。

5. 在表达式树上，每个表达式的默认返回值都是右值，而对于赋值的情况，左表达式的最后一句应当是 `LI`（因为在正确的代码下，这个值是一个左值），此时只需要撤销这个 `LI` 操作，就可以获得原始地址。这个方案同时适用于 `cin`。

6. `cin` 和 `cout` 可以看作任意参数，而对于 `<<` 和 `>>` 操作符，只需要看作二元运算符，并且保留右操作数的地址或值即可。

7. 函数只需要映射到 `ENT` 对应的地址。

8. 建议在调试期间输出栈信息和寄存器信息，方便找到异常行为。这些行为包括但不限于：在一些位置忘记 `POP`、回收变量内存错误、基址计算错误等。

[此处](https://www.luogu.com.cn/paste/nv007mh5) 为最终的代码。这份代码在 **37ms** 的时间内执行了全部数据，最慢的数据也只是执行了 **8ms**。

---

## 作者：normalpcer (赞：16)

## 题意简述

要求实现一个解释器，支持 C++ 语言的一个子集。

- 需要支持变量。
  - 除了 `cin`, `cout`, `endl`，变量类型一定为 `int` 或若干维度的 `int` 数组。
  - 程序中所有的整数字面量均为十进制。
  - 变量声明的时候赋予默认值 $0$。不会出现声明的同时初始化变量。
  - 数组每个维度的大小一定为单个十进制数。

- 需要支持函数。
  - 函数的返回值一定为 `int`。
  - 函数的参数一定为空或者若干个 `int`。
  - 如果没有返回语句，认为返回值是 $0$。
  - 似乎函数声明的同时一定会进行定义。

- 需要支持以下的整数运算：
  - 算术运算：加减乘除、取模，正负号。
  - 逻辑运算：与或非，异或（这里的异或似乎只会对 $0$ 和 $1$ 进行）。**没有“短路”机制**。
  - 比较运算：大于、小于、大于等于、小于等于、等于、不等于。
  - 赋值。和 C++ 中一样，赋值语句的返回值是到左操作数的引用。复制操作为右结合。
  另外，需要支持 `cin`、`cout` 的左移和右移。（右操作数只会为整数）
  需要正确地处理圆括号和方括号。

- 需要支持以下的控制语句：
  - `if (stat) stat [else stat]`
  - `while (stat) stat`
  - `for (stat; stat; stat) stat`
  - 上述语句的主体部分可以为单条语句，或者是花括号包裹的多条语句。

- 需要支持以下没有任何作用的语句：
  - `#include <iostream>`
  - `#include <cstdio>`
  - `using namespace std;`

- 需要实现函数 `putchar(int)`，输出给定 ASCII 码的字符。

以上整理的可能不是很全面，请以题面为准。

## 分析

事先声明，本人对于一些术语的认识可能并不正确，对于以下内容可能的的一些错误，请见谅。

由于这段代码在写这道题之前就已经实现了一些功能，可能会有一些冗余的设计。

我将整个解释器分为了分词（Tokenize）、解析（Parse）、解释运行（Interpret）三个阶段。

### 分词

首先是分词。读入的程序是一个个的字符，字符之间免不了会有一些关联。于是我们可以先把它们变成一系列 `Token`。

这个部分可以参考 [UVA12421](https://www.luogu.com.cn/problem/UVA12421)。

我把 Token 分为了整数、浮点数、字符串、标识符、换行符、符号这几种。因为 C++ 对于换行不敏感，所以实际上没有用到换行符。由于代码长度限制，我在后来删除了字符串和浮点数的处理。

Token 类的定义如下：

```cpp
struct Token {
    enum Tag {
        NoneTag, IdentifierTag, SymbolTag, IntegerTag, StringTag, EndOfLineTag, FloatingPointTag
    } tag = NoneTag;
    std::variant<int, Identifier, Integer, String, Symbol, FloatingPointNumber> value = 0;
};
```

`std::variant` 是一个类型安全的联合体，可以在被删除时自动调用正确的析构函数。尖括号中的类型用于存储各自的信息。为了方便，`String`，`Identifier`和 `Symbol` 的存储直接使用 `std::string`。

分词的流程比较容易，我们通过一个字符大概就能知道接下来的 Token 类型。

例如，读到一个字母或者下划线，就知道接下来是一个标识符；读到一个数字，就知道接下来是一个整数或者浮点数；读到一个双引号，就知道就下来是一个字符串。

我们只需要实现每一个类型的解析函数，根据第一个字符判断，调用正确类型的函数即可。

另外，我实现了一个 Scanner，可以读取字符的同时支持撤销最多两次。好像是浮点数解析的时候需要撤销两次，对于本题应该可以简单地用 `std::istream` 代替。

读取数字可能略微麻烦一些，但也不是特别麻烦。

```cpp
static std::vector<Token> tokenize(IO::Scanner &io) {
    std::vector<Token> tokens;
    try {
        while (true) {
            char ch = io.get();
            io.unget();
            if (ch == '\0') {
                break;
            } if (ch == '\n') {
                io.get();
                // tokens.push_back({Token::EndOfLineTag});
            } else if (isBlank(ch)) {
                io.get();
            } else if (ch == '"') {
                String str;
                io >> str;
                tokens.push_back({Token::StringTag, str});
            } else if (isDigit(ch)) {
                Integer integer;
                FloatingPointNumber fp;
                bool isInteger = true;
                io >> integer;
                // 已经有了后缀运算符，不应视为浮点数
                if (integer.suffixOperators.empty()) {
                    if (io.get() == '.') {
                        if (not isDigit(io.get())) {
                            // 如果后面不是紧接数字，放弃匹配小数
                            io.unget(), io.unget();  // 下一次读取还是获得 '.'
                            goto egg;  // 跳到结尾，直接加入先前读入的数字
                        }
                        io.unget();  // 读到小数点，即 0.123 的形式
                        isInteger = false;
                        io >> fp;
                        fp.value += integer.value;
                    } else {
                        io.unget();
                    }
                    if (ch = io.get(); ch == 'e' or ch == 'E') {
                        // 科学计数法
                        if (isInteger)  fp.value = integer.value;
                        isInteger = false;
                        ch = io.get();
                        bool expSigned = false;
                        if (ch == '+')  ch = io.get();
                        else if (ch == '-')  ch = io.get(), expSigned = true;
                        if (isDigit(ch)) {
                            io.unget(), io >> integer;
                            if (expSigned)  fp.value *= std::pow(10.0, -(double)integer.value);
                            else  fp.value *= std::pow(10, integer.value);
                            fp.suffixOperators = std::move(integer.suffixOperators);
                        } else {
                            compileError("Invalid decimal literal");
                        }
                    } else {
                        io.unget();
                    }
                }
            egg:
                if (isInteger)  tokens.push_back({Token::IntegerTag, integer});
                else  tokens.push_back({Token::FloatingPointTag, fp});
            } else if (isIdentifierStart(ch)) {
                Identifier identifier;
                io >> identifier;
                tokens.push_back({Token::IdentifierTag, identifier});
            } else {
                Symbol symbol;
                io >> symbol;
                if (symbol.value == "#") {
                    // 单行注释
                    while (io.get() != '\n');
                    continue;  // 忽略井号
                }
                tokens.push_back({Token::SymbolTag, symbol});
            }
        }
    } catch (IO::EOFError &) {}
    tokens.push_back({Token::EndOfLineTag});
    return tokens;
}
```

`io >> x` 表示从 Scanner 中读取对应类型。这段代码同时支持识别各种数字的后缀，例如 `0LL` 这样的。这里实际上是把井号视为单行注释。

UVA12421 需要支持省略 $0.5$ 这类小数开头的 0，同时还有一个 `..` 运算符，会再麻烦一些。

匹配符号使用“贪婪匹配”的原则，尽可能匹配更长的符号（例如 `==` 和 `=` 前者更优先）。可以使用字典树实现。

## 解析

我们可以把代码转化成一棵树，即抽象语法树（Abstract Syntax Tree）。

抽象语法树和表达式树类似，或者反过来说，后者是前者的子树。

我把程序中的元素分为了以下几类：

语句（Statement），语句块（Block），表达式（Expression），值（Value）。

比如，考虑以下代码：

```cpp
if (a != 0 && b != 0) {
    putchar(a + b);
}
```

这是一个 `if` 语句，包含条件表达式和主体语句块。

里面的 `putchar(a + b)` 可以看成一整个表达式，把函数调用看成一种运算符。

它就可以被描述成这样：

```
If-Statement
Condition:
    &&
        !=, a, 0
        !=, b, 0
Body:
    [0] EvalExpr
        Call
            putchar
            +, a, b
```

那么如何建出这样一棵树呢？

大多数时候，我们读到一个词，就能判断出接下来是什么样子。例如上面的例子中，我们只要读到 `if`，就能知道会有一个圆括号，接下来读取一个表达式直到对应的右侧圆括号，再接下来读取一个语句或者语句块。

### 表达式解析

解析表达式似乎是一个难点。我的做法是：先转成后缀表达式，然后建表达式树。

具体来讲，后缀表达式还是通过类似常规流程的压栈来实现。不过有一些额外的细节。

我在维护运算符种类以外，还维护了一个整数，表示这个符号还有几个运算数没有访问到。

这样，比如现在遇到了符号 `-`，如果栈顶运算符还需要一个运算数，那么它就应该是负号，否则就是减号。这样我们就区分开了一元和二元的同一运算符。

括号和函数调用也能由此区分，如果括号之前是一个完整结果，那么括号应该被视为函数调用。特别地，如果整个表达式的外侧都是括号，这也应该是普通的括号。这可以通过最开始向栈中压入一个空操作，并将剩余操作数设为 1 来解决。

函数调用的参数，我设置了一个“逗号”运算符，它的左儿子为一个参数，右儿子为另一个逗号或者参数。例如，下面的函数调用：

```cpp
f(0, 1, 2, 3);
```

解析出的表达式树：

```
Call
    f
    Comma
        0
        Comma
            1
            Comma
                2
                Comma
                    3
```

这样，我们就把函数调用变成了固定的二元运算符。

中括号访问，我把它看成了另外一种运算符，把这个运算符和一个中括号一同压入栈中。多维数组可以参考多维 `vector`，每次下标访问返回少一个维度的数组，最终获得值。

这部分代码大致是这样：

```cpp
struct StackValueType {
    Operator op;
    int args_remains;  // 剩余操作数
};
const auto &&end_condition = [&]() {
    if constexpr(std::is_same_v<PredType, int>) {
        return [&](std::string const &op, std::vector<StackValueType> const &ops) {
            if (op == "," and (ops.empty() or ops.back().op == NoneOp))  return true;
            if (op == ";" or op == "\n")  return true;
            return false;
        };
    } else {
        return pred;
    }
}();
auto [postfix, it] = [&]() {                
    const auto inf = OperatorInfo::priority_max;
    std::vector<StackValueType> ops {{NoneOp, 1}};  // 运算符栈
    auto it = src.begin();
    // 转成后缀表达式
    struct PostfixValueType {
        bool symbol = false;
        std::variant<Operator, ValueNode> item;
    };
    std::vector<PostfixValueType> postfix;
    auto add = [&](Operator type, int args_remains) {
        if (infoOf(type).leftAssociative) {
            while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
        } else {
            while (not ops.empty() and infoOf(ops.back().op).priority <= infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
        }
        ops.push_back({type, args_remains});
    };
    for (; it != src.end(); it++) {
        auto &token = *it;
        if (token.tag == Token::SymbolTag or token.tag == Token::EndOfLineTag) {
            auto op = token.tag == Token::EndOfLineTag? "\n": std::get<Symbol>(token.value).value;
            if (end_condition(op, ops)) {
                it++;
                break;
            }
            if (op == "(") {
                // 函数调用
                // 如果左侧是一个完整结果，视为函数调用
                if (not ops.empty() and ops.back().args_remains == 0) {
                    add(Call, 0);
                    ops.push_back({FunctionArgsBracket, 1});
                } else {
                    ops.back().args_remains--;
                    ops.push_back({Bracket, 1});
                }
            } else if (op == ")") {
                while (infoOf(ops.back().op).priority != inf) {
                    postfix.push_back({true, ops.back().op}), ops.pop_back();
                }
                // 结束函数调用括号
                if (ops.back().op == FunctionArgsBracket) {
                    bool flag = ops.back().args_remains == 1;
                    ops.pop_back();
                    // 如果没有参数，填充一个空值
                    if (flag)  postfix.push_back({false, ValueNode{ValueNode::NoneValue, Token{Token::NoneTag}}});
                } else {
                    // 结束常规括号
                    assert(ops.back().op == Bracket and ops.back().args_remains == 0);
                    ops.pop_back();
                }
            } else if (op == ",") {
                while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(SplitComma).priority) {
                    postfix.push_back({true, {ops.back().op}}), ops.pop_back();
                }
                ops.push_back({SplitComma, 1});
            } else if (op == "[") {
                add(Subscript, 0);
                ops.push_back({SubscriptBracket, 1});
            } else if (op == "]") {
                // 中括号匹配
                while (infoOf(ops.back().op).priority != inf) {
                    postfix.push_back({true, ops.back().op}), ops.pop_back();
                }
                assert(ops.back().op == SubscriptBracket);
                bool flag = ops.back().args_remains == 1;
                // postfix.push_back({true, ops.back().op}), ops.pop_back();
                ops.pop_back();
                if (flag)  postfix.push_back({false, ValueNode{ValueNode::NoneValue, Token{Token::NoneTag}}});
            } else if (op == "+") {
                // 判断为一元或者二元
                // 如果左侧为一个期待其他操作数的符号，视为一元运算符
                if (not ops.empty() and ops.back().args_remains != 0) {
                    ops.back().args_remains--;
                    add(UnaryAdd, 1);
                } else {
                    add(Add, 1);
                }
            } else if (op == "-") {
                if (not ops.empty() and ops.back().args_remains != 0) {
                    ops.back().args_remains--;
                    add(UnarySub, 1);
                } else {
                    add(Sub, 1);
                }
            }
#define JOIN_BINARY_OP(op_type, op_str) else if (op == op_str)  add(op_type, 1);
            JOIN_BINARY_OP(Mul, "*")
            JOIN_BINARY_OP(Div, "/")
            JOIN_BINARY_OP(Mod, "%")
            JOIN_BINARY_OP(Less, "<")
            JOIN_BINARY_OP(Greater, ">")
            JOIN_BINARY_OP(LessEqual, "<=")
            JOIN_BINARY_OP(GreaterEqual, ">=")
            JOIN_BINARY_OP(Equal, "==")
            JOIN_BINARY_OP(NotEqual, "!=")
            JOIN_BINARY_OP(And, "&&")
            JOIN_BINARY_OP(Or, "||")
            JOIN_BINARY_OP(BitAnd, "&")
            JOIN_BINARY_OP(BitOr, "|")
            JOIN_BINARY_OP(BitXor, "^")
            JOIN_BINARY_OP(BitShiftLeft, "<<")
            JOIN_BINARY_OP(BitShiftRight, ">>")
            JOIN_BINARY_OP(Assign, "=")
            JOIN_BINARY_OP(MemberAccess, ".")
            JOIN_BINARY_OP(Range, "..")
            JOIN_BINARY_OP(ScopeResolution, "::")
#undef JOIN_BINARY_OP
            else if (op == "!") {
                ops.back().args_remains--;
                add(Not, 1);
            } else if (op == "~") {
                ops.back().args_remains--;
                add(BitNot, 1);
            } else {
                std::cerr << "Unknown symbol: " << op << endl;
                throw -1;
            }
        } else {
            // 直接压入答案
            if (token.tag == Token::IdentifierTag) {
                postfix.push_back({false, ValueNode{ValueNode::Identifier, token}});
            } else if (token.tag == Token::IntegerTag) {
                postfix.push_back({false, ValueNode{ValueNode::Integer, token}});
            }
            ops.back().args_remains--;
            assert(ops.back().args_remains == 0);
        }
    }
    // 清空剩余操作符
    while (not ops.empty() and ops.size() != (size_t)1) {
        postfix.push_back({true, ops.back().op});
        ops.pop_back();
    }
    return std::pair{postfix, it};
}();
```

（Range `..` 运算符好像是做其他的题留下的，C++ 并没有这样的运算符）

pred 是传入的参数，用来判断什么时候结束表达式，从而更好地复用代码。传入一个整数表示使用默认判断。postfix 是生成的后缀表达式。

有了后缀表达式之后就比较好办了，这里不做阐述。

### 树的存储

我采用这样的方式：一个节点存储若干个指针，指向其他的节点。

例如 `if` 语句的条件需要一个表达式，那就添加一个成员。

```cpp
ExpressionNode *condition;  // 条件
```

在这里，我们其实可以发现一个继承关系，`if` 语句并不在乎条件是一个运算符还是一个值，于是可以让“值节点”继承于“表达式节点”。

这里介绍一个 C++ 特性。如果类 `Derived` 继承于 `Base`，那么可以将 `Derived *` 和 `Base *` 互相转换。比如我们在表达式节点上这样定义：

```cpp
struct ExpressionNode {
    enum OperatorType {
        None, Plus
    } op;

};

struct ValueNode: public ExpressionNode {
    int value;
};
```

假如有一个值节点，我们便可以把它的指针转为 `ExpressionNode` 挂载到 `if` 语句的条件上。当真正执行条件时，可以通过 `op == None` 来判断出这是一个值节点，从而把这个指针转换回 `ValueNode *` 来求值。

另外，我选择将基类的析构函数设为虚函数（virtual），这样可以在被删除时调用正确的析构函数，避免内存泄露。

例如以下代码：

```cpp
#include <iostream>

struct ExpressionNode {
    enum OperatorType {
        None, Plus
    } op;
    ExpressionNode *left = nullptr;
    ExpressionNode *right = nullptr;

    virtual ~ExpressionNode() {
        std::cout << "~ExpressionNode" << std::endl;
        delete left;
        delete right;
    }
};

struct ValueNode: public ExpressionNode {
    int *value = nullptr;

    virtual ~ValueNode() {
        std::cout << "~ValueNode" << std::endl;
        delete value;
    }
};

int main() {
    ExpressionNode *ptr = new ValueNode;
    delete ptr;
}
```

这样可以确保调用了派生类的析构函数。这段代码会依次调用 `~ValueNode` 和 `~ExpressionNode`。如果没有虚析构函数，则只会调用 `~ExpressionNode`。

另外，类中有虚函数可以将其变为多态类，这允许我们使用 `dynamic_cast` 来向派生类指针转换，获得检查。（`dynamic_cast<Derived *>(ptr)`，如果 `ptr` 指向的对象实际上不是 `Derived` 类型，那么会返回空指针）

我的代码中有这些类型的节点，缩进表示继承关系。具体类的定义可以直接翻看代码。

```cpp
Node
    StatementNode  语句
        ExpressionEvaluateStatementNode  表达式求值
        DeclareStatementNode  声明
            VariableDeclareStatementNode  变量声明
            FunctionDeclareStatementNode  函数声明
        RunBlockStatementNode  运行代码块
        ConditionalStatementNode  有条件语句
            IfStatementNode  if
            WhileStatementNode  while
        ForStatementNode for
        ReturnStatementNode  return
    BlockNode  语句块
    ExpressionNode  表达式
        ValueNode  值
```

### 其他

正如上文所说，大多数情况下，我们只需要读到一个关键字就能知道接下来的内容，递归解析即可。

我现在区分声明和求值的方法是，如果语句的开头连续出现了两个标识符就认为这是一个声明，否则可能是一个求值。虽然比较简陋，但是对于本题应该是足够的。如果是类型后置的语言可能要方便一些。

另外，我对于数组定义没有想到什么优雅的方法，现在是简单粗暴地存储每一维的大小。

其他的比较简单，就不再讲述了。

## 解释运行

一种比较高效的方式是，先“编译”为一种字节码，然后就只需要在一条链上执行字节码了。

但是我选择了偷懒，直接在抽象语法树上递归执行，这样虽然有一些额外开销，对执行效率产生影响，但是不影响通过本题。

首先需要实现的是变量的存储。我定义了如下类型：

```cpp
struct Object {
    enum Type {
        Struct, Int, Function, String, None, Array, BuiltinFunction, BuiltinIStream, BuiltinOStream, BuiltinEndl
    } type;
    std::variant<
        std::nullptr_t,  // 没有东西
        int,  // int
        std::shared_ptr<std::string>,  // string
        std::shared_ptr<Identifier>,  // builtin_function
        std::shared_ptr<ArrayObjectValue>,  // array
        AST::FunctionDeclareStatementNode *  // function
    > value;
};
```

如上。我们可以把函数也看成一种变量，存储的值是它对应的代码块。

ArrayObjectValue 用来存储数组。

然后，我们需要在变量名和变量内容之间进行映射。我引入了作用域的概念，虽然这个题保证不会有重名，但是涉及到递归的时候还是需要的。（相当于不同递归层数的变量发生了重名）

可以用类似链表达方式实现多层作用域：

```cpp
std::map<Identifier, Object> variables;
Scope *parent = nullptr;  // 父级作用域
```

在这一层如果找不到变量，可以到上一层查找，直到不存在更上层了。

每一次进入一个语句块都进入一层作用域，退出语句块就退出作用域即可。

接下来，我的解释器类实现了以下方法：

```cpp
class Interpreter {
    Program program;
    std::vector<std::unique_ptr<Scope>> scopeStack;  // 作用域栈
    Object ret;  // 上一次的返回值
    bool returnFlag = false;  // 正在执行 return
    Interpreter(Program &&);

    void run();
    Object evaluateExpression(AST::ExpressionNode *);  // 计算表达式
    Object *evaluateLeftValueExpression(AST::ExpressionNode *);  // 计算左值表达式
    TypeName evaluateType(Identifier const &);  // 推导类型
    template <typename OutIterator>
    OutIterator getFunctionArguments(AST::ExpressionNode *, OutIterator);  // 提取函数参数
    void runBlock(AST::BlockNode *);  // 执行语句块
    template <typename StatementPointer>
    void runDeclarationStatement(StatementPointer);  // 执行声明语句
    template <typename StatementPointer>
    void runStatement(StatementPointer);  // 执行语句
    void enterScope();  // 创建新的作用域
    void leaveScope();  // 离开当前作用域
    Scope *topScope();  // 获取当前作用域
};
```

正如上文所述，我们把函数参数通过若干层逗号存储起来，`getFunctionArguments` 是这个的逆过程，按顺序把所有参数提取到目标迭代器中。

计算左值是为了支持 `a[5] = 20` 这样的数组操作。`a[5]` 可以作为一个左值计算，得到一个指针再对其赋值。

突然发现我并没有实现赋值语句的左值运算，可能是没有 `(a = b) = c` 这样奇怪的数据。

这些函数基本上递归跑就可以了。

另外，返回值采用的方法是，直接设置 ret 变量的值，然后 returnFlag 设为 true。需要注意，每一次执行语句和语句块的时候都需要检查是否需要返回。

隐式返回 0，在调用函数之后发现这次没有发生返回就直接设为 0 即可。

## 总结

经过部分删减的代码（主要删的 Tokenize 部分）可以见[洛谷云剪贴板](https://www.luogu.com.cn/paste/njwda3fz)，[Ubuntu Paste](https://paste.ubuntu.com/p/qk2BmjssGR/) 或 [Github](https://github.com/Normal-pcer/paste/blob/main/P11738.cpp)。请注意代码长度为 84 KB，提交时可能需要略微压行。

这份代码使用 gcc 13.3.0 的编译选项 `-fsanitize=address,undefined,leak` 没有发现未定义行为和内存泄露。

很有意思的大模拟，也是我的第一道黑题。感觉主要难度还是在解析 AST 上，解析表达式和声明有点麻烦。这个解释器只是实现了不考虑错误、不考虑性能优化的一个很小的 C++ 子集，无论在可用性和性能上均有很大的优化空间。在编写的时候，我尝试着写出更加优雅的封装，让代码更加清晰和可复用，增加可维护性，虽然并不完美，但我自认为是一次不错的尝试。

这份代码最初还有不少细节问题，只能获得 $60$ 分。最后还是拿到了测试数据才调过这道题。另外介绍一个小技巧，如果你出现了断言失败，可以在代码前面添加这样的宏定义：

```cpp
#undef assert
#define assert(x) (void)(!!(x)||(std::exit(__LINE__),0))
```

这样可以获取断言失败的行数（模 $256$）。

感谢您的阅读。

---

## 作者：AzusaShirasu (赞：9)

（当时和 @tiger2005 在 UOJ 上一起做一起过的）

代码去看 [UOJ 评测记录](https://uoj.ac/submission/716637)。

基于栈的虚拟机好写。未来，要是有幸运的选手真的在考场上做到手搓编译器的题（比如该题），可以考虑打个计算表达式，混个部分分跑路。比如该题有 40 分的部分分是纯表达式计算，算上变量处理就额外有 10 分。而处理表达式最好用的还是栈。

前置知识不讲了，做过 Mua III 的朋友们应该都会了，没做过的可参考[本人题解](https://www.luogu.com.cn/article/qc2ekzcr)。

这里只讲一个点：多维寻址。有两种方式实现：

一种方式是：设计对应的取地址指令（即：`mov xxx, [yyy]`）。也就是说，没有办法做到“访问特定地址”，只能访问变量。

如果设计了取地址指令，比较正宗的解决方式是：把多维数组看成数组的数组，高维度存储的是指针。举例来说，二维数组，第一维数组存储的是**数组的指针**。

如果访问 `a[x][y]`，实际进行的操作是：先取出 `a[x]` 的**值**，然后把这个值当作指针，访问第 `y` 个元素。

可以简单把取地址指令理解成**把值当成指针**。用 C++ 类似的描述就是：`(void *) (long long) value`。

另一种方式是：把所有数组展开成一维。

数组被展开成一维之后，维度信息丢失了。比如，`a[3][4]` 被展开成 `a[12]`，之后访问 `a[2][1]` 时，该访问哪个元素？运行时，虚拟机只知道它是 `a[12]`，无法确定如何正确地展开 `a[2][1]`。

解决办法是：虚拟机不知道维度信息，但编译器知道。必须把索引也一并进行一维展开。所以，需要记录每个数组的各个维度的大小信息（幸运的是，该题数组各维度大小都是给定的常数）。

例如，对于数组 `a[X][Y][Z]`，展开为 `a[X * Y * Z]`，同时记录下三个维度信息；在访问 `a[i][j][k]` 时，要编译为 `a[i * (Y * Z) + j * Z + k]`。

两种方式各有优劣，前者灵活性强，可以支持动态分配的数组（其实相当于支持了指针），后者可能速度快一点（寻地址一步到位）。

本人采取了后者，实际上发现编写代码需要注意比较多的细节。其实是因为一开始没有设计好指令集和虚拟机导致的。后面只能尽力填坑。

其他并没有什么特别的。注意几点：

- 64 位机子上，指针 `void *` 是 64 位的整数。如果想要把指针和数值保存到一起，需要使用 `long long` 而不是 `int`。

- `cout` 之类，算是内置函数的，专门设计指令就行了，不必再特地去做内置函数表。

- 逻辑运算符不能短路运算。

顺便说下，normalpcer 的题解、tiger2005 在 Mua III 的新题解，采取的就是直接执行 AST 的策略。

tiger2005 在该题采取的是基于寄存器的架构（但是因为只有一个通用寄存器 `ax`，所以还是要频繁操作栈）。

事实上寄存器是非常优美的……仍然建议对编译器感兴趣的朋友们去了解一下。

回头看看当时写的 Mua III 题解……感触还是非常深的……

愿意和本人交流的话去 LA 群或者 U 群找吧，目前还是活跃的（

写完于 2025 年 2 月 18 日。

---

## 作者：Oildum (赞：2)

PL 系列登神长阶（2/3）

前置芝士：[题解 P3695 - CYaRon! 语](https://www.luogu.com.cn/article/2x8xe5wx)

本文最终代码：注册 UOJ 账号后，进入 [#783817](https://uoj.ac/submission/783817)，下方附有完整代码及在 UOJ 上的评测成绩。最终代码 43KB，无需压行。

---

书接上回。上回书说到，欲实现一个极其简单以至于能被出成 OI 题的自制编程语言，一共可以分为词法分析、语法分析、执行 AST 这三大板块。

词法分析各大题目，甚至各大语言套路都差不多，而语法分析只要给了文法就几乎也是公式，即使没给文法，难点也只是在于表达式里各种优先级、结合性那一块。虽然说执行也偏向于公式化（bushi），但执行部分细节最多，可能出的毛病也最多，因此本文将会侧重于执行部分（？）

### Quick Review

快速过一遍自制编程语言的基础知识：词法分析的过程是把字符串的字符重新组合成一个个名为 Token 的单位的过程，类似于英文中把一个句子先拆解成单词；语法分析则是根据文法把 Token 流拆解成更好理解的形式的过程，这种形式在上题和本题的语境下都是抽象语法树 AST。

一个 Token 描述的是一个小整体，比如一个变量、一个关键字、一个数字、一个运算符之类的，抽象语法树 AST 的一个节点描述的是一个程序中比较大的整体，比如 `1 + 2 + 3 * 4` 这么一个表达式，首先各个数字单独成为一个整体，然后 `1 + 2` 是一个整体，`3 * 4` 是一个整体，最后再组成 `1 + 2 + 3 * 4` 一个大的整体；`for (i = 1; i <= 10; i = i + 1) {}` 中，`i = 1`、`i <= 10`、`i = i + 1`、`{}` 是四个整体，这四个整体共同组成了上面的 `for` 循环。像上面这样把整个程序细分成各种整体，就形成了各种节点。在实践中如果发现某 AST 节点不能满足需要，则需要建立新的节点，或是修改这个节点。

文法一般使用 BNF 或是 EBNF 来描述，本题中给出的文法就是 BNF，这大大减轻了我们的工作量，不用再像 P3695 一样揣摩文法长啥样了。

最后是执行部分，执行部分说是只需要遍历 AST 即可，但是各种细节都要自己维护，稍有不慎就容易把程序整个卡死，必须理清执行一个语句时到底需要干什么，比如 `for` 和 `while` 循环要在执行完一次循环后重新计算循环条件是否还成立等等。

以上大致就是写一个极简编程语言的逻辑。下面在穿插代码的同时，也介绍一些能让编码更加轻松愉快（大嘘）的小技巧。

### Macros

在调试过程中，往往需要输出一个 Token 啦、输出一个 AST 啦，这就绕不开要输出 TokenType。但未来程序改的 TokenType 非常多：

```cpp
enum TokenType {
    // 单字符
    D(TT_LPAREN),
    D(TT_RPAREN),
    D(TT_LBRACE),
    D(TT_RBRACE),
    D(TT_SEMICOLON),
    D(TT_COMMA),
    D(TT_LBRACKET),
    D(TT_RBRACKET),
    D(TT_PLUS),
    D(TT_MINUS),
    D(TT_MUL),
    D(TT_DIV),
    D(TT_MOD),
    D(TT_XOR),
    D(TT_LT),
    D(TT_GT),
    D(TT_EXCLAMATION),
    D(TT_EQ),
    // 双字符
    D(TT_LE),
    D(TT_GE),
    D(TT_EE),
    D(TT_NE),
    D(TT_LAND),
    D(TT_LOR),
    D(TT_LSHIFT),
    D(TT_RSHIFT),
    // 多字符
    D(TT_IDENTIFIER),
    D(TT_KEYWORD),
    D(TT_INTEGER),
    // 特殊Token
    D(TT_EOF),
    D(TT_ERROR)
};
```

这该怎么办？

通过利用宏可以解决这一问题。注意到包裹的 `D` 了么？在前面插一行 `#define D(s) s`，这样 TokenType 里，`D(x)` 就是 `x` 的意思；在下面插入这样的代码：

```cpp

#undef D
#define D(s) #s

string type2str[] = {
    // 单字符
    D(TT_LPAREN),
    D(TT_RPAREN),
    D(TT_LBRACE),
    D(TT_RBRACE),
    D(TT_SEMICOLON),
    D(TT_COMMA),
    D(TT_LBRACKET),
    D(TT_RBRACKET),
    D(TT_PLUS),
    D(TT_MINUS),
    D(TT_MUL),
    D(TT_DIV),
    D(TT_MOD),
    D(TT_XOR),
    D(TT_LT),
    D(TT_GT),
    D(TT_EXCLAMATION),
    D(TT_EQ),
    // 双字符
    D(TT_LE),
    D(TT_GE),
    D(TT_EE),
    D(TT_NE),
    D(TT_LAND),
    D(TT_LOR),
    D(TT_LSHIFT),
    D(TT_RSHIFT),
    // 多字符
    D(TT_IDENTIFIER),
    D(TT_KEYWORD),
    D(TT_INTEGER),
    // 特殊Token
    D(TT_EOF),
    D(TT_ERROR)
};

#undef D
```

先取消前面定义的 `D`，然后定义 `D(s)` 为 `#s`，这样 `D` 内包裹的东西就会自动变成字符串。接下来在 `Token` 的 `tostring()` 方法中，直接使用 `type2str[type]` 就可以获取对应的字符串了。

### Metaprogramming the AST

在实际写程序过程中，可能会发现 AST 节点种类极其繁多，最终版代码中，共有 17 种 AST 节点，总行数达到 258 行，这时如果再用手写就要累死了。实际观察一下就会发现，不同的节点操作实际上千篇一律，那么为什么不用程序自动生成 AST 呢？

这样，用下面十几行就可以描述想要生成的 AST 了：

```plain
node Stmts
subs body

node VarDecl
subs vars

node Func
tok name
subs args
sub body

node If
sub cond
sub body
sub else_branch

node For
sub init
sub cond
sub update
sub body

node While
sub cond
sub body

node Return
sub retval

node Call
tok name
subs params

node Cin
subs exprs

node Cout
subs exprs

node Endl

node Number
tok num

node ArrayElement
tok name
subs dims

node VarAccess
tok name

node UnaryOp
tok op
sub node

node BinOp
sub left
tok op
sub right

node Program
subs stmts
```

其中，`node xxx` 是 `xxx` 节点描述的开始，下面一直到另一个 `node` 都是当前节点的内容；`tok` 表示当前节点有一个成员是一个 Token，如只表示一个数字的 `NumberNode`；`sub` 表示当前节点有一个成员是一个 AST 节点，如表示 `if` 语句的 `IfNode`，它的条件就是一个节点；`subs` 表示当前节点有一个成员是一些 AST 节点，比如表示一个语句块的 `StmtsNode`、表示整个程序的 `ProgramNode` 等。

假设所有 AST 节点都有一个统一的基类 `BaseNode`，那么，`sub` 可以表示为 `BaseNode *`，`subs` 就可以表示为 `vector<BaseNode *>`。

生成 AST 的程序如下：

```python
# ast_gen.py

def parse(texts, allow_tostring):
    # step 1: group each "node" to its subs "tok xxx, sub xx, subs xxx"
    grouped_texts = []
    group = []
    ast_list = []
    for text in texts:
        text = text.strip()
        if text == '': continue
        if text.startswith("node "):
            if group != []: grouped_texts.append(group)
            group = []
            text = text[5:]
            ast_list.append(text.upper())
        group.append(text.strip())
    grouped_texts.append(group) # add the last remaining group
    # step 2: generate enum NodeType & baseNode
    source = ["enum NodeType {"]
    for name in ast_list:
        source.append(f"    NODE_{name},")
    source.append("};")
    source.append('')
    source.append("struct BaseNode {")
    source.append("public:")
    source.append("    virtual ~BaseNode() {}")
    if allow_tostring: source.append("    virtual string tostring(int depth = 0, bool with_prefix = true) = 0;")
    source.append("    virtual NodeType getType() = 0;")
    source.append("};")
    source.append('')
    # step 3: generate string * int for pretty print
    source.append("string operator*(const string &str, int count) {")
    source.append("    string res;")
    source.append("    for (int i = 0; i < count; i++) res += str;")
    source.append("    return res;")
    source.append("}")
    source.append("")
    # step 4: for each group, generate its own AST structure
    for group in grouped_texts:
        source.append(f"struct {group[0]}Node : public BaseNode " + "{")
        # get subs & toks
        if len(group) == 1:
            # blank node
            source.append("public:")
            if allow_tostring:
                source.append("    virtual string tostring(int depth = 0, bool with_prefix = true) {")
                source.append(f"        return string(\"    \") * depth + \"{group[0]}Node[]\";")
                source.append("    }")
            source.append("")
        else:
            subs = []
            toks = []
            subss = []
            requirements_without_prefix = []
            for requirements in group[1:]:
                if requirements.startswith("sub "):
                    subs.append(requirements[4:])
                    requirements_without_prefix.append(requirements[4:])
                elif requirements.startswith("tok "):
                    toks.append(requirements[4:])
                    requirements_without_prefix.append(requirements[4:])
                elif requirements.startswith("subs "):
                    subss.append(requirements[5:])
                    requirements_without_prefix.append(requirements[5:])
                else:
                    print(f"Error: unrecognizable prefix \"{requirements.split(' ')[0]}\" in AST definition of {group[0]}Node (expected 'tok', 'sub' or 'subs')")
                    exit()
            if toks: source.append("    Token " + ", ".join(toks) + ";")
            if subs: source.append("    BaseNode " + ", ".join(map(lambda name: "*" + name, subs)) + ";")
            if subss: source.append("    vector<BaseNode *> " + ", ".join(subss) + ";")
            source.append("public:")
            # generate constructor
            constructor = f"    {group[0]}Node("
            for requirement in requirements_without_prefix:
                if requirement in subs:
                    constructor += f"BaseNode *{requirement}, "
                elif requirement in toks:
                    constructor += f"Token {requirement}, "
                else:
                    constructor += f"vector<BaseNode *> {requirement}, "
            constructor = constructor[:-2] + ")"
            source.append(constructor)
            # generate idk what is that
            assigner = "      : "
            assigner += ", ".join(map(lambda x: f"{x}({x})", requirements_without_prefix))
            assigner += " {}"
            source.append(assigner)
            source.append("")
            # generate deconstructor
            source.append(f"    virtual ~{group[0]}Node() " + "{")
            # delete sub & subs
            if subs: source.append("        " + "; ".join(map(lambda x: f"delete {x}", subs)) + ";")
            if subss: source.append("\n".join(map(lambda x: f"        for (int i = 0; i < {x}.size(); i++) delete {x}[i];", subss)))
            source.append("    }")
            source.append("")
            # generate tostring
            if allow_tostring:
                # basic idea: tok -> .value, sub -> .tostring(), subs -> a concat for loop
                source.append("    virtual string tostring(int depth = 0, bool with_prefix = true) {")
                source.append("        string res;")
                source.append("        if (with_prefix) res = string(\"    \") * depth;")
                source.append(f"        res += \"{group[0]}Node[\\n\";")
                for requirement in requirements_without_prefix:
                    line = ""
                    if requirement in toks:
                        line += f"        res += string(\"    \") * (depth + 1) + \"{requirement} = \" + {requirement}.tostring()"
                    elif requirement in subs:
                        line += f"        res += string(\"    \") * (depth + 1) + \"{requirement} = \" + {requirement}->tostring(depth + 1, false)"
                    else:
                        line += f"        res += string(\"    \") * (depth + 1) + \"{requirement} = " + "{\\n\";\n" 
                        line += f"        for (int i = 0; i < {requirement}.size(); i++) " + "{\n"
                        line += f"            res += {requirement}[i]->tostring(depth + 2);\n"
                        line += f"            if (i != {requirement}.size() - 1) res += \", \\n\";\n"
                        line += "        }\n"
                        line += "        res += \"\\n\";\n"
                        line += "        res += string(\"    \") * depth;\n"
                        line += "        res += \"    }\";"
                    if requirement not in subss:
                        if requirement != requirements_without_prefix[-1]:
                            line += " + \", \\n\""
                        else:
                            line += " + \"\\n\""
                        line += ";"
                    else:
                        if requirement != requirements_without_prefix[-1]:
                            line += "\n        res += \", \\n\";"
                        else:
                            line += "\n        res += \"\\n\";"
                    source.append(line)
                source.append("        res += string(\"    \") * depth;")
                source.append("        res += \"]\";")
                source.append("        return res;")
                source.append("    }")
                source.append("")
        
        source.append("    virtual NodeType getType() {")
        source.append(f"        return NODE_{group[0].upper()};")
        source.append("    }")
        source.append("};")
        source.append("")
    
    source = source[:-1]
    print("\n".join(source))

def main(argv):
    with open(argv[1], "r") as f:
        texts = f.readlines()
    
    allow_tostring = argv[2] != "no" if len(argv) > 2 else True
    parse(texts, allow_tostring)

if __name__ == '__main__':
    import sys
    main(sys.argv)
```

使用方法（将上面 AST 的描述存为 ast_nodes.txt）：

```plain
python ast_gen.py ast_nodes.txt
```

这会把生成的代码输出到标准输出。

以上生成的代码中还包含了一个 `tostring()`，它可以把一个 AST 转化成字符串，并使用缩进描述层级结构，调试时非常好用，但很占地方，因此在不必要时，可以通过在上述命令的结尾添加一个 `no` 来禁止它生成。经过测试这样可以使源码削减 9KB。

这里还需要简单提一下 C++ 的 OOP，一个基类中只有虚方法（带 `virtual` 的方法）可以用于多态，不带的只能局限于此；子类与父类的指针可以相互转化，如果是父类的指针类型但实际存的是子类的指针，在该指针上调用方法会进入子类的方法；如果一个带 `virtual` 的方法后接 `= 0`，则为纯虚方法，子类必须实现，否则无法实例化。因此，即使语法分析返回的全是 `BaseNode` 的指针，也能够通过 `getType()` 分辨出到底是哪一个节点。这样应该就能够理解生成出来的代码为什么能够工作了。

### Erasing Left Recursion

词法分析器已经非常公式化，UVA12421 是专门练习词法分析器的，大多数语言都可以直接照搬能 AC UVA12421 的词法分析器，一般只需要在关键字方面做一些小修改即可；或者参看 P3695，以及本文开头所附代码都可以，因此不多赘述。

至于语法分析器，则值得一说。如果仍然依照 P3695 题解中提到的方法进行语法分析，看到非终结符就调用对应处理函数的话，面对以下文法时：

```plain
UNIT6 ::=
| UNIT5
| UNIT6 ^ UNIT5
```

将写出如下伪代码：

```cpp
BaseNode *parse_UNIT6() {
    BaseNode *node = parse_UNIT5();
    if (node 匹配失败) {
        BaseNode *left = parse_UNIT6();
        Token op = current_tok;
        advance(); // 跳过异或
        BaseNode *right = parse_UNIT5();
        node = new BinOpNode(left, op, right);
    }
    return node;
}
```

这样的写法看似没啥问题，实则问题很大。如果 node 匹配失败，那么 `parse_UNIT6()` 将调用 `parse_UNIT6()`。但此时，由于 `UNIT5` 没有匹配上任何东西，语法分析器中的当前 Token 并没有发生改变，新一轮 `parse_UNIT6()` 仍将继续调用 `parse_UNIT6()`，从而陷入无限递归中出不来。这是因为，`UNIT6` 实际上是一个**左递归文法**。面对有左递归的文法时，切不可直接照搬，而是要消除左递归。

对于本例而言，上述左递归的描述实际上等同于：

```plain
UNIT6 ::= UNIT5 ^ UNIT5 ^ UNIT5 ^ ...
```

也即 `UNIT5` 后面可以跟上许多 `^ UNIT5`，从而可使用 EBNF 描述为：

```plain
UNIT6 ::= UNIT5 (^ UNIT5)*
```

接下来使用 while 循环匹配异或符号即可，这样就消除了左递归。

其余没什么好注意的，仿照 P3695 中提到的逻辑进行分析即可。

### Executing the AST

终于到了执行的部分。相较于 P3695 的执行，增加了函数以及作用域的有关内容，增加了多维数组，还添加了一大堆运算符。

先来看看最基本的值类型的定义：

```cpp
enum ValueType {
    VALUE_INTEGER,
    VALUE_ARRAY,
    VALUE_FUNCTION,
    VALUE_NULL
};    

struct Value {
public:
    virtual ValueType getType() = 0;
};

struct Null : public Value {
public:
    virtual ValueType getType() {
        return VALUE_NULL;
    }
};

struct Integer : public Value {
private:
    int innerVal;
public:
    Integer(Token integer) : innerVal(0) {
        if (!integer.matches(TT_INTEGER)) innerVal = 0;
        else {
            string s = integer.value;
            for (int i = 0; i < s.size(); i++) {
                innerVal = innerVal * 10 + s[i] - '0';
            }
        }
    }
    Integer(int innerVal = 0) : innerVal(innerVal) {}
    explicit operator int() {
        return innerVal;
    }
    Integer operator+(const Integer &other) const {
        return Integer(innerVal + other.innerVal);
    }
    Integer operator-(const Integer &other) const {
        return Integer(innerVal - other.innerVal);
    }
    Integer operator*(const Integer &other) const {
        return Integer(innerVal * other.innerVal);
    }
    Integer operator/(const Integer &other) const {
        return Integer(innerVal / other.innerVal);
    }
    virtual ValueType getType() {
        return VALUE_INTEGER;
    }
};
```

这段代码与 P3695 中对应部分完全相同。

由于多维数组不好实现，这里选择把多维数组压缩成一维。

```cpp
struct Array : public Value {
    int *arr;
    vector<int> dims;
public:
    Array(vector<int> dims) : dims(dims) {
        int len = 1;
        for (int i = 0; i < dims.size(); i++) len *= dims[i];
        arr = new int[len];
        memset(arr, 0, len * sizeof(int));
    }
    virtual ~Array() { delete[] arr; }
    int generate_1d_index(vector<int> inds) {
        int ind = 0, pre = 1;
        for (int i = dims.size() - 1; i >= 0; i--) {
            ind += inds[i] * pre;
            pre *= dims[i];
        }
        return ind;
    }
    int &operator[](int ind) {
        return arr[ind];
    }
    virtual ValueType getType() {
        return VALUE_ARRAY;
    }
};
```

核心部分是 `Array` 的构造函数以及 `generate_1d_index`。构造函数容易理解，多维数组的大小就是把每一维乘起来。而 `generate_1d_index` 则是把一个多维的索引压缩成一维。

例如，已知 `int a[n1][n2][n3][...][nx]`，现在我要访问 `a[a1][a2][a3][...][ax]`。按照 C/C++ 语言的数组在内存中的表示，`a` 实际上是一个长度为 `n1` 的数组，每一维都是一个 `int[n2][...][nx]` 类型的值。因此，想要访问 `a[a1]`，就要跳过 `n2 * n3 * ... * nx * a1` 个数，后文同理。于是就得到了把多维数组压缩成一维的公式：

`ind = n2 * n3 * n4 * ... * nx * a1 + n3 * n4 * ... * nx * a2 + ... + nx * a(x-1) + ax`。

这样硬算是 $\text{O}(n^2)$ 的，通过使用因式分解，可以把时间复杂度压缩到 $\text{O}(n)$，也就是上面的实现中用到的方法。

接下来进行作用域系统的实现。

```cpp
struct SymbolTable {
    SymbolTable *parent;
private:
    map<string, Value *> symbol_table;
public:
    Value *get(string key) {
        if (symbol_table.count(key)) return symbol_table[key];
        if (parent) return parent->get(key);
        return (Value *) 1;
    }
    void set(string key, Value *val) {
        if (symbol_table.count(key)) symbol_table[key] = val;
        else if (parent) parent->set(key, val);
    }
    void declare(string key) {
        symbol_table[key] = new Integer(0);
    }
};

struct Context {
    Context *parent;
    SymbolTable *symbol_table;

    Value *current_function_retval;
    bool current_function_returned;
    Context(Context *parent = NULL, SymbolTable *symbol_table = NULL)
      : symbol_table(symbol_table), parent(parent), current_function_retval(NULL), current_function_returned(false) {}
};

Context *global_context = new Context(NULL, new SymbolTable());

Value *global_get(string name)
{
    return global_context->symbol_table->get(name);
}

void global_put(string name, Value *value)
{
    global_context->symbol_table->declare(name);
    global_context->symbol_table->set(name, value);
}
```

每一个 scope（在代码中体现为 `Context`）都有它的父亲，同时有一个 symbol table 用于存储当前 scope 内所有变量的值。对于一个 symbol table，可以进行 `get`、`set` 和 `declare` 的操作，`get` 可以获取当前作用域变量的值，如果获取不着就进一步向父亲寻找，直到 NULL 为止，也就是找到了 `global_context`，如果没有，返回 `(Value *) 1`，返回这么一个值这是为了方便调试；`declare` 用于在当前作用域声明一个变量；`set` 则用于给变量赋值，如果这个作用域不存在这个变量，那就进一步往上找，以此类推。

在 `Context` 上还添加了当前函数是否已经返回的标记，这是因为如果一个函数已经返回了，那么不能执行后面的语句，而是要跳过它。这在下面的代码中将有所体现。

函数分为两种：built-in（`putchar`）以及 user-defined（被表示为 `FuncNode`）。由于语法分析阶段没有做出区分，只能在执行阶段再做打算。

这里采用的方法是，让它们都继承一个共同的基类 `BaseFunction`：

```cpp
struct BaseFunction : public Value {
    string name;
    Context *cur_context;
public:
    BaseFunction(string name, Context *cur_context) : name(name), cur_context(cur_context) {}
    virtual string getName() {
        return name;
    }
    virtual Context *generate_new_context() {
        Context *new_context = new Context(cur_context, new SymbolTable());
        new_context->symbol_table->parent = cur_context->symbol_table;
        return new_context;
    }
    virtual void check_and_populate_args(vector<string> &arg_names, vector<Value *> &args, Context *exec_ctx) {
        if (arg_names.size() < args.size()) {
            *(int *) NULL;
        } else if (arg_names.size() > args.size()) {
            *(int *) NULL;
        }

        for (int i = 0; i < args.size(); i++) {
            exec_ctx->symbol_table->declare(arg_names[i]);
            exec_ctx->symbol_table->set(arg_names[i], args[i]);
        }
    }
    virtual Value *execute(vector<Value *> &params) = 0;
};
```

它的两个主要方法是 `check_and_populate_args` 以及 `generate_new_context`，分别用于生成新的 `Context` 以及填入函数参数。在调用函数时，统一调用 `BaseFunction` 的 `execute` 方法。

这样便可以如此实现 `putchar` 了：

```cpp
struct NativePutchar : public BaseFunction {
    string name;
    Context *cur_context;
public:
    NativePutchar(string name, Context *cur_context = global_context) : BaseFunction(name, cur_context) {}
    virtual Value *execute(vector<Value *> &params) {
        int ch = int(*(Integer *) params[0]);
        return new Integer(putchar(ch));
    }
    virtual ValueType getType() {
        return VALUE_FUNCTION;
    }
};
```

普通函数的调用由于依赖后面的 `Interpreter`，所以放到后面再说，这里先简单放一个 stub：

```cpp
struct Function : public BaseFunction {
    BaseNode *body;
    vector<string> arg_names;
public:
    Function(string name, Context *cur_context, BaseNode *body, vector<string> arg_names)
      : BaseFunction(name, cur_context), body(body), arg_names(arg_names) {}
    virtual Value *execute(vector<Value *> &params);
    virtual ValueType getType() {
        return VALUE_FUNCTION;
    }
};
```

接下来是作用域系统在实际的执行流程中的实现。首先实现一个 `visit` 方法：

```cpp
struct Interpreter {
public:
    Value *visit(BaseNode *node, Context *exec_ctx = NULL) {
        if (exec_ctx == NULL) exec_ctx = global_context;
        switch (node->getType()) {
            case NODE_PROGRAM:
                return visit_ProgramNode((ProgramNode *) node, exec_ctx);
            case NODE_STMTS:
                return visit_StmtsNode((StmtsNode *) node, exec_ctx);
            case NODE_VARDECL:
                return visit_VarDeclNode((VarDeclNode *) node, exec_ctx);
            case NODE_FUNC:
                return visit_FuncNode((FuncNode *) node, exec_ctx);
            case NODE_IF:
                return visit_IfNode((IfNode *) node, exec_ctx);
            case NODE_FOR:
                return visit_ForNode((ForNode *) node, exec_ctx);
            case NODE_WHILE:
                return visit_WhileNode((WhileNode *) node, exec_ctx);
            case NODE_RETURN:
                return visit_ReturnNode((ReturnNode *) node, exec_ctx);
            case NODE_CALL:
                return visit_CallNode((CallNode *) node, exec_ctx);
            case NODE_CIN:
                return visit_CinNode((CinNode *) node, exec_ctx);
            case NODE_COUT:
                return visit_CoutNode((CoutNode *) node, exec_ctx);
            case NODE_ENDL:
                return visit_EndlNode((EndlNode *) node, exec_ctx);
            case NODE_NUMBER:
                return visit_NumberNode((NumberNode *) node, exec_ctx);
            case NODE_ARRAYELEMENT:
                return visit_ArrayElementNode((ArrayElementNode *) node, exec_ctx);
            case NODE_VARACCESS:
                return visit_VarAccessNode((VarAccessNode *) node, exec_ctx);
            case NODE_UNARYOP:
                return visit_UnaryOpNode((UnaryOpNode *) node, exec_ctx);
            case NODE_BINOP:
                return visit_BinOpNode((BinOpNode *) node, exec_ctx);
            default:
                return NULL;
        }
    }
};
```

在调用 `visit` 时，必须提供一个 `exec_ctx` 表示当前语句正在哪个 `Context` 中执行，并基于这个 `exec_ctx` 创建新的 `Context`。在语法分析阶段，已经把 `if`、`for`、`while` 后接的大括号看成一个复合语句（从文法的暗示上讲确实如此），因此要新开作用域的情况就只有两种：调用函数以及进入复合语句。

调用函数时，使用 `generate_new_context` 生成一个新作用域。注意所有函数都是在全局域声明的，因此生成的新作用域的父亲全部都是全局域。

```cpp
Value *Function::execute(vector<Value *> &params) {
    Interpreter interp;
    Context *new_ctx = generate_new_context();
    check_and_populate_args(arg_names, params, new_ctx);
    interp.visit(body, new_ctx);
    if (new_ctx->current_function_returned) {
        Value *retval = new_ctx->current_function_retval;
        return retval;
    } else return new Integer(0);
}
```

大概类似于这样。

在复合语句中创建新的作用域基本等于把 `generate_new_context` 给搬运过来：

```cpp
    Value *visit_StmtsNode(StmtsNode *node, Context *exec_ctx) {
        if (exec_ctx->current_function_returned) return new Null();
        Context *new_context = new Context(exec_ctx, new SymbolTable());
        new_context->symbol_table->parent = exec_ctx->symbol_table;
        for (int i = 0; i < node->body.size(); i++) {
            visit(node->body[i], new_context);
        }
        return new Null();
    }
```

上述截取的第 3、4 两行就是创建新作用域，第 6 行的 `visit` 全部在新作用域中执行语句。第 2 行则是 `return` 时要用的。

在 `return` 时，要给它的 `Context` 挂上一个当前函数已经返回的标志。注意有可能一个函数在 `if` 或者 `while` 很里面 `return`，所以需要一直挂到当前函数的作用域为止。

```cpp
    Value *visit_ReturnNode(ReturnNode *node, Context *exec_ctx) {
        if (exec_ctx->current_function_returned) return new Null();
        Integer *retval = (Integer *) visit(node->retval, exec_ctx);
        while (exec_ctx->parent) {
            exec_ctx->current_function_returned = true;
            exec_ctx->current_function_retval = retval;
            exec_ctx = exec_ctx->parent;
        }
        return new Null();
    }
```

在一个 `Context` 内给变量赋值码量较大，因此封装了一个 `assign` 函数专门用于赋值：

```cpp
    void assign(Context *exec_ctx, BaseNode *var, Value *value) {
        if (var->getType() == NODE_VARACCESS) {
            VarAccessNode *van = (VarAccessNode *) var;
            string name = van->name.value;
            exec_ctx->symbol_table->set(name, value);
        } else if (var->getType() == NODE_ARRAYELEMENT) {
            ArrayElementNode *aen = (ArrayElementNode *) var;
            string name = aen->name.value;
            Array *arr = (Array *) exec_ctx->symbol_table->get(name);
            vector<int> indexes;
            for (int i = 0; i < aen->dims.size(); i++) {
                Integer *dim = (Integer *) visit(aen->dims[i], exec_ctx);
                indexes.push_back(int(*dim));
            }
            int ind = arr->generate_1d_index(indexes);
            (*arr)[ind] = int(*(Integer *) value);
        }
    }
```

按普通变量和数组分类讨论，对普通变量直接 `set`，对数组则先把每一维计算出来，再调用 `generate_1d_index` 算出压缩成一维后的索引，最后赋值。以上代码可以重用在实现 `cin` 以及后面的赋值运算符中。

对于 `cout`，由于把 `endl` 单独做成了一个节点，需要特判 `endl`，不能调用它的 `visit` 方法，因为 `cout` 只能输出整数而不能输出字符，后者是 `putchar` 的工作。

赋值运算符被放在了 `BinOpNode` 里，因此还需要特判：

```cpp
    Value *visit_BinOpNode(BinOpNode *node, Context *exec_ctx) {
        if (exec_ctx->current_function_returned) return new Null();
        Value *ret;
        if (node->op.matches(TT_EQ)) {
            BaseNode *var = node->left;
            Integer *val = (Integer *) visit(node->right, exec_ctx);
            assign(exec_ctx, var, val);
            ret = val;
        } else {
            Integer *left = (Integer *) visit(node->left, exec_ctx);
            Integer *right = (Integer *) visit(node->right, exec_ctx);
            int l = int(*left);
            int r = int(*right);
            switch (node->op.type) {
                case TT_PLUS: ret = new Integer(l + r); break;
                case TT_MINUS: ret = new Integer(l - r); break;
                case TT_MUL: ret = new Integer(l * r); break;
                case TT_DIV: ret = new Integer(l / r); break;
                case TT_MOD: ret = new Integer(l % r); break;
                case TT_LT: ret = new Integer(l < r); break;
                case TT_GT: ret = new Integer(l > r); break;
                case TT_LE: ret = new Integer(l <= r); break;
                case TT_GE: ret = new Integer(l >= r); break;
                case TT_EE: ret = new Integer(l == r); break;
                case TT_NE: ret = new Integer(l != r); break;
                case TT_XOR: ret = new Integer(l ^ r); break;
                case TT_LAND: ret = new Integer(l && r); break;
                case TT_LOR: ret = new Integer(l || r); break;
                default: ret = new Null(); break;
            }
        }
        return ret;
    }
```

以上差不多就是几个比较大的细节点，除此以外执行中还有很多非常小的细节点，比如遇到 `for` 的条件是空的如何处理（给出代码中在语法分析阶段已经处理，若条件为空则默认为一个数字节点 1），定义一个函数时要先声明它，等等等等。在前面的代码中也有一些已经覆盖到的小的细节点，包括但不限于函数的参数要声明之类的，这里不再赘述。总之遇到 bug 只能自己慢慢调了（）

fun fact：我一开始只得到 20 分。给函数添加了默认返回值 0 得了 10 分，给数组设置默认值 0 得了 10 分，修了作用域问题得了 30 分，修了一元运算符解析出错得了 20 分，修了 `for` 循环解析出错又拿 10 分，这才终于拿到满分。这里把这些易错点都列出来以供后人参考，同时警示后人。

以上。

---


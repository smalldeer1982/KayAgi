# [JOIST 2025] 外郎糕 / Uiro

## 题目描述

葵有 $N$ 张卡片，编号从 $1$ 到 $N$。每张卡片上都写有一个正整数。卡片 $i$（$1 \leq i \leq N$）上写的数是 $A_i$。  
葵将使用这些卡片和黑板进行 $Q$ 次游戏。她进行的第 $j$ 次游戏（$1 \leq j \leq Q$）包含以下步骤：  
1. 在黑板上写下 $0$。  
2. 将编号为 $L_j$, $L_j + 1$, ..., $R_j$ 的卡片按此顺序从左到右排列在桌面上。  
3. 进行 $R_j - L_j + 1$ 次操作。第 $k$ 次操作（$1 \leq k \leq R_j - L_j + 1$）如下：  
   - 设黑板上当前写的数为 $x$，桌面左起第 $k$ 张卡片上的数为 $y$。擦去黑板上的 $x$，改为写下 $x + y$ 或 $x - y$。  
   - 若选择 $x - y$，葵将吃掉一个外郎糕。  
   - 但此时写在黑板上的数必须严格非负。  

对于每个游戏，你需要求出葵能吃掉外郎糕的最大数量。  

给定卡片信息和游戏信息，请编写程序计算每个游戏中葵能吃掉外郎糕的最大数量。



## 说明/提示


### 样例解释

#### 样例 $1$ 解释

在**第一个游戏**中，一种可能的操作序列如下：  
1. 在黑板上写下 $0$。  
2. 将卡片 $1$, $2$, $3$ 按此顺序从左到右排列在桌面上。  
3. 黑板上当前的数是 $0$，桌面左起第 $1$ 张卡片上的数是 $3$。擦去黑板上的 $0$，改为写下 $3$。  
4. 黑板上当前的数是 $3$，桌面左起第 $2$ 张卡片上的数是 $4$。擦去黑板上的 $3$，改为写下 $7$。  
5. 黑板上当前的数是 $7$，桌面左起第 $3$ 张卡片上的数是 $7$。擦去黑板上的 $7$，改为写下 $0$。葵吃掉一个外郎糕。  
此时，第一个游戏中葵吃掉的外郎糕数量为 $1$。可以证明第一个游戏中葵吃掉的外郎糕数量不会超过 $1$。因此，应输出 $1$。  

在**第二个游戏**中，一种可能的操作序列如下：  
1. 在黑板上写下 $0$。  
2. 将卡片 $4$ 排列在桌面上。  
3. 黑板上当前的数是 $0$，桌面左起第 $1$ 张卡片上的数是 $2$。擦去黑板上的 $0$，改为写下 $2$。  
此时，第二个游戏中葵吃掉的外郎糕数量为 $0$。可以证明第二个游戏中葵吃掉的外郎糕数量不会超过 $0$。因此，应输出 $0$。  


该样例满足子任务 $1\sim 4,6,7$ 的限制。


#### 样例 $2$ 解释

在第一个游戏中，另一种可能的操作序列如下：  

1. 在黑板上写下 $0$。  
2. 将卡片 $1$, $2$ 按此顺序从左到右排列在桌面上。  
3. 黑板上当前的数是 $0$，桌面左起第 $1$ 张卡片上的数是 $1$。擦去黑板上的 $0$，改为写下 $1$。  
4. 黑板上当前的数是 $1$，桌面左起第 $2$ 张卡片上的数是 $2$。擦去黑板上的 $1$，改为写下 $3$。  

此时，第一个游戏中葵吃掉的外郎糕数量为 $0$。可以证明第一个游戏中葵吃掉的外郎糕数量不会超过 $0$。因此，应输出 $0$。 

该样例满足所有子任务的限制。

#### 样例 $3$ 解释

该样例满足子任务 $1\sim 4,7$ 的限制。



### 数据范围
- $1 \leq N \leq 200\,000$；
- $1 \leq A_i \leq 100$（$1 \leq i \leq N$）；
- $1 \leq Q \leq 200\,000$；
- $1 \leq L_j \leq R_j \leq N$（$1 \leq j \leq Q$）；
- 所有给定值均为整数。

### 子任务
- $\text{Subtask 1 (3 pts)}$：$N \leq 20$，$Q \leq 20$；
- $\text{Subtask 2 (5 pts)}$：$N \leq 300$，$Q \leq 20$；
- $\text{Subtask 3 (7 pts)}$：$N \leq 5\,000$，$Q \leq 20$；
- $\text{Subtask 4 (15 pts)}$：$Q \leq 20$；
- $\text{Subtask 5 (21 pts)}$：$A_i \leq 2$（$1 \leq i \leq N$）；
- $\text{Subtask 6 (29 pts)}$：$A_i \leq 20$（$1 \leq i \leq N$）；
- $\text{Subtask 7 (20 pts)}$：无额外限制。


## 样例 #1

### 输入

```
5
3 4 7 2 8
2
1 3
4 4```

### 输出

```
1
0```

## 样例 #2

### 输入

```
14
1 2 2 1 2 1 1 2 1 2 2 1 1 1
5
1 2
1 14
5 11
3 12
4 7```

### 输出

```
0
8
4
6
2```

## 样例 #3

### 输入

```
8
16 23 45 76 43 97 12 43
7
1 8
3 7
2 7
4 5
5 8
2 6
3 5```

### 输出

```
3
2
2
1
2
2
1```

# 题解

## 作者：cwfxlh (赞：4)

## [P11994 [JOIST 2025] 外郎糕 / Uiro](https://www.luogu.com.cn/problem/P11994)

考虑怎么解决一次询问。     

有一个显然的 $O(n\log n)$ 的做法，大致是先全部选成负的，然后从前往后扫，如果和小于 0 了就选最大的转正，用优先队列维护。      

上面那个做法不好改进。观察部分分和数据范围发现，题目引导我们对 $A_i$ 的值域进行思考。    

考虑对于某个值 $x$，被选为负号的等于 $x$ 的位置一定是所有等于 $x$ 的位置里的一段后缀，否则改为同长度的后缀一定不劣。另外，考虑区间内最后一个没被选的 $x-1$，其位置一定小于第一个被选的 $x$，否则将这个 $x$ 换成那个 $x-1$ 一定不劣。     

观察上面的性质，我们感性地猜测一个做法，从小到大枚举 $x$，对于 $A_i=x$ 的位置，贪心选能选的最长后缀。    

这是正确的，不妨考虑如果某一层 $x$ 没有选满，那么找到 $[x+1,100]$ 这几层中最靠前的选中位置 $A_j$，将其舍掉，替换成第一个没被选中的 $A_i=x$。那么前缀和在 $[i,j-1]$ 部分是减少的，在 $[j,n]$ 部分是增加的，后者显然不劣，前者不会造成任何其他影响（因为是一层一层往上贪心，所以这里的位置不会影响后面了）。      

于是经过上面的调整可以证明，最优解一定能通过这种贪心得到。直接做，枚举 $A$ 的值，枚举询问，二分。具体的实现是简单的，每一次需要处理前缀和，另外二分 check 的时候需要用到一个 ST 表查询区间最小值。复杂度是 $O((n+q)\max A_i\log n)$ 的。这个复杂度在 loj 上能过，洛谷不太能过。我最后改了一版 $O(q\max A_i\log n +n\log n)$ 的才通过，优化了建 ST 表时的复杂度，跑的快了很多，loj 上最慢跑了 800ms，洛谷最慢跑了 1.5s。


代码：   

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,Q,a[200003],q[200003][3],num[200003],pre[200003],lmt[200003],plsv[200003],lft,rgt,mid,f[200003];
int stk[200003],tots,k1,k2,k3,k4,k5,k6,k7,k8,k9,lg[200003],ST[200003][19],ST2[200003][19];
int Query(int ql,int qr){if(ql>qr)return 1000000000;return min(ST[ql][lg[qr-ql+1]],ST[qr-(1<<lg[qr-ql+1])+1][lg[qr-ql+1]]);}
char *p1,*p2,buf[100000];
#define nc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read(){
    int xx=0,ff=1;
    char ch=nc();
    while(ch<48||ch>57)ch=nc();
    while(ch>=48&&ch<=57)xx=xx*10+ch-48,ch=nc();
   	return xx*ff;
}
void write(int x){
    if(x>9)write(x/10);
    putchar(x%10+'0');
    return;
}
int main(){
	for(int i=2;i<=200000;i++)lg[i]=lg[i>>1]+1;
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	Q=read();
	for(int i=1;i<=Q;i++){q[i][0]=read();q[i][1]=read();}
	for(int i=1;i<=Q;i++)lmt[i]=q[i][0];
	for(int nowv=1;nowv<=100;nowv++){
		tots=0;
		for(int i=1;i<=n;i++){
			num[i]=num[i-1]+(a[i]==nowv);
			if(a[i]==nowv)stk[++tots]=i;
			pre[i]=pre[i-1]+a[i];
			if(a[i]<nowv)pre[i]-=a[i]*2;
		}
		if(tots==0)continue;
		for(int i=1;i<=n;i++){
			f[i]=pre[i]-2*nowv*num[i];
			if(a[i]!=nowv)f[i]=min(f[i],f[i-1]);
		}
		for(int i=1;i<=tots;i++)ST[i][0]=f[stk[i+1]-1];
		for(int i=1;(1<<i)<=tots;i++){
			for(int j=1;j+(1<<i)-1<=tots;j++)ST[j][i]=min(ST[j][i-1],ST[j+(1<<(i-1))][i-1]);
		}
		stk[tots+1]=n+1;
		for(int i=1;i<=Q;i++){
			lft=num[lmt[i]-1]+1;rgt=num[q[i][1]]+1;
			while(lft<rgt){
				mid=((lft+rgt)/2);
				if(Query(mid,num[q[i][1]]-1)>=pre[q[i][0]-1]-plsv[i]-2*nowv*(mid-1)&&f[q[i][1]]>=pre[q[i][0]-1]-plsv[i]-2*nowv*(mid-1))rgt=mid;
				else lft=mid+1;
			}
			q[i][2]+=(num[q[i][1]]-lft+1);
			lmt[i]=max(lmt[i],stk[lft-1]+1);
			plsv[i]+=((lft-1)-num[q[i][0]-1])*nowv*2;
			
		}
	}
	for(int i=1;i<=Q;i++){write(q[i][2]);putchar('\n');}
	return 0;
} 
```

---


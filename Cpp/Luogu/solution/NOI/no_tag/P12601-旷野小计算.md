# 旷野小计算

## 题目背景

原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [E 题](T571828)。

---

**提示：若是使用“提交代码”的方式进行提交，在评测时会给程序输入一个数字（1, 2, 3, ..., 7）表示测试点编号，请在程序中直接输出对应测试点的答案。**

## 题目描述

> 关于什么是寄存器：理解成变量即可。

您需要编写指令，完成给定的计算任务。

在以下指令中，小写字母 `v` 开头的参数表示十进制无符号常数，大写字母 `R` 开头的参数表示寄存器。寄存器均为 64 位无符号整数。您可以自由使用的寄存器有六个：`a`、`b`、`c`、`d`、`x`、`y`。除非特别说明，否则所有寄存器初始值均为 $0$。

| 指令格式 | 描述 |
| :----------: | :----------: |
| `+ R1 R2` | 使 R1 寄存器加上 R2 的值 |
| `- R1 R2` | 使 R1 寄存器减去 R2 的值 |
| `< R1 v` | 使 R1 寄存器左移 $v$ 位，低位补 0 |
| `> R1 v` | 使 R1 寄存器右移 $v$ 位，高位补 0 |
| `^ R1 R2` | 使 R1 寄存器异或上 R2 的值  |
| `! R1` | 输出 R1 寄存器的值 |
| `= R1 v` | 使 R1 寄存器的值变为 $v$ |
| `* R1 R2` | 使 R1 寄存器乘上 R2 的值  |
| `/ R1 R2` | 使 R1 寄存器除以 R2 的值  |


| 编号 | 输入方式 | 任务 | PC 数限制 |  特殊条件 | 分值|
| :----------: | :----------: | :--------: | :----------: | :-------: |:----------: |
| 1 | 寄存器 `x` 里保存 $x$ | 输出 $4080x$ | $5\color{green}+15$ | | $10$ |
| 2 | 寄存器 `x` 里保存 $x$ |输出 $\frac{x}{4080}$（下取整） | $16\color{green}+8$ | $x$ 在 32 位无符号整数范围内 | $10$ |
| 3 | 寄存器 `x` 里保存 $x$ |输出 $4080$ | $16\color{green}+8$ | 保证 $x$ 不为 $0$ | $10$ |
| 4 | 寄存器 `x`、`y` 里保存 $x$、$y$ | 输出 $x \times y$ 的值 | $1024\color{green}+512$ | 答案自然溢出即可（即对 $2^{64}$ 取模） | $10$ |
| 5 | 寄存器 `x`、`y` 里保存 $x$、$y$ | 输出 $\frac x y$ 的值 （下取整）| $1024\color{green}+512$ | $x$ 和 $y$ 在 32 位无符号整数范围内，保证 $y$ 不为 $0$ | $20$ |
| 6 | 寄存器 `x` 里保存 $x$ | 输出 $\sqrt x$ 的值 （下取整） | $1024\color{green}+16384$ |  | $20$ |
| 7 | 寄存器 `x` 里保存 $x$ | 输出大于等于 $x$ 的最小的 $2$ 的次幂 | $96\color{green}+128$ | 保证 $x$ 不为 $0$ 且答案在 64 位无符号整数范围内 | $20$ |




## 说明/提示

请注意：

- 程序的大小非常关键，运行的指令条数超过了 PC 数限制就会扣除分数。PC 数限制 $x\color{green}+y$ 表示：

	- 当运行的指令条数 $c \le x$ 时，获得该测试点的全部分数；
    - 当运行的指令条数 $c >x+y$ 时，不得分；
    - 当运行的指令条数 $c \in (x, x+y)$ 时，获得该测试点 $(x+y-c)/y\times 100\%$ 的分数（即：线性衰减）。

- 常数、乘法、除法指令（即表格中后三条指令）是非常昂贵的，使用了就会扣除所有的分数。

因此，两个样例的输出实际均不能得到分数。

附件提供 `chk.exe`，供交互式运行指令，输入单条指令回车后即可运行。为方便给寄存器赋值，额外提供指令（评测机内不识别该指令）：

| 指令格式 | 助记符格式 | 说明 |
|:----------: |:----------: |:----------: |
| `? R1` | `read R1` |从标准输入读入一个 64 位无符号整数，保存到 R1 寄存器中 |

## 样例 #1

### 输入

```
1```

### 输出

```
见附件 sample1.txt```

## 样例 #2

### 输入

```
3```

### 输出

```
= a 4080
! a```

# 题解

## 作者：EricWan (赞：34)

六个寄存器，真空指令集。\
限制卡得紧，一堆子问题。\
先乘解决除，取负能造一。\
分支不让用，咋判二的幂。\
与上零负一，创造新奇迹。\
数除动分母，官解太诡异。\
溢出不用急，偶数先右移。\
一错调一天，这题真猎奇。

先放一个经过微调的 checker，能更好的快速对代码进行测试，分屏放代码和 checker 也可以看完所有数据而不让输入输出混淆。简直是 debug 神器。

```cpp
#include<iostream>
#include<string>
#include<fstream>
#include<sstream>
#include<vector>
#include<map>
#include<cmath>
#include<bitset>
using namespace std;
#define Reg unsigned long long
map<string,Reg> regs;
int line=0;
void die(string msg){
	cout<<"Line "<<line<<": "<<msg<<endl<<endl;
	//exit(1);
}
Reg& reg(string id){
	if(id=="a"||id=="b"||id=="c"||id=="d")id="r"+id+"x";
	if(id=="x")id="rsi";
	if(id=="y")id="rdi";
	if(regs.find(id)==regs.end())die("accessing invalid register: "+id);
	return regs[id];
}
Reg num(const string&str){
	Reg n=0;
	stringstream ss("");
	ss<<str;
	ss>>n;
	return n;
}
char cases[100];
ostream &XXXXX(cout << "Code file : ");
istream &XXX(cin >> cases);
std::ifstream code(cases);
//#define debug4
#ifdef debug4
Reg ch4x, ch4y, ch4d;
#endif
void initreg(int type){
	regs["rax"]=regs["rbx"]=regs["rcx"]=regs["rdx"]=regs["rsi"]=regs["rdi"]=0;
	int cnt;
	cout << "Input register number : ";
	cin >> cnt;
	if (cnt) {
		cout << "Input " << cnt << " register" << (cnt - 1 ? "s :\n" : " :\n");
	} else {
		cout << "no input";
	}
	if (cnt) {
		cout << "x = ";
		cin >> regs["rsi"];
		#ifdef debug4
		ch4x = regs["rsi"];
		#endif
	}
	if (cnt >= 2) {
		cout << "y = ";
		cin >> regs["rdi"];
		#ifdef debug4
		ch4y = regs["rdi"];
		#endif
	}
	if (cases[0] == '1') {
		cout << "need\n" << regs["rsi"] * 4080 << endl;
	} else if (cases[0] == '2') {
		cout << "need\n" << regs["rsi"] / 4080 << endl;
	} else if (cases[0] == '3') {
		cout << "need\n" << 4080 << endl;
	} else if (cases[0] == '4') {
		cout << "need\n" << regs["rsi"] * regs["rdi"] << endl;
	} else if (cases[0] == '5') {
		cout << "need\n" << regs["rsi"] / regs["rdi"] << endl;
	} else if (cases[0] == '6') {
		cout << "need\n" << (unsigned long long)sqrtl(regs["rsi"]) << endl;
	} else if (cases[0] == '7') {
		Reg ans = 1;
		while (ans < regs["rsi"]) ans <<= 1;
		cout << "need\n" << ans << endl;
	}
}
int main(){
	string cmd;
	initreg(0);
	while(getline(code,cmd)){
		vector<string> toks;
		stringstream ss("");
		string tok;
//		cout << "code = " << cmd << endl;
		if (cmd.substr(0, 5) == "print") {
			cout << cmd.substr(6) << endl;
			continue;
		}
		if (cmd == "debug_all") {
			cout << "debug_all" << endl;
			for (string i : {"a", "b", "c", "d", "x", "y"}) {
				cout << i << " = " << reg(i) << endl;
			}
			continue;
		}
		if (cmd.substr(0, 12) == "debug_all(b)") {
			#ifdef debug4
			if (cmd[13] == '*') {
				if (ch4x & 1)
				{
					ch4d += ch4y;
				}
				ch4x >>= 1;
				ch4y <<= 1;
			}
			#endif
			cout << "debug_all(b)" << endl;
			for (string i : {"a", "b", "c", "d", "x", "y"}) {
				cout << i << " = " << bitset<64>(reg(i)) << endl;
				#ifdef debug4
				if (i == "d") {
					cout << "D = " << bitset<64>(ch4d) << endl;
				}
				#endif
			}
			continue;
		}
		if (cmd == "debug") {
			cout << "debug" << endl;
			for (string i : {
			#if 0
			"a", "b", "c",
			#endif
			"d", "x", "y"
			}) {
				cout << i << " = " << reg(i) << endl;
			}
			continue;
		}
		line++;
		for(auto a:cmd)if(a==';')break;else ss<<(a==','?' ':a);
		while(ss>>tok)toks.push_back(tok);
		if(toks.size()<=0)continue;
		if(toks.size()==3-(toks[0]=="!"||toks[0]=="?"||toks[0]=="read"||toks[0]=="write")){
			string o=toks[0];
			if(o=="+"||o=="add")reg(toks[1])+=reg(toks[2]);
			else if(o=="-"||o=="sub")reg(toks[1])-=reg(toks[2]);
			else if(o=="^"||o=="xor")reg(toks[1])^=reg(toks[2]);
			else if(o=="<"||o=="shl")reg(toks[1])<<=num(toks[2]);
			else if(o==">"||o=="shr")reg(toks[1])>>=num(toks[2]);
			else if(o=="!"||o=="write") {
//				cout << reg(toks[1]) << endl;
				printf("%30llu\t", reg(toks[1]));
				cout << toks[1] << " = " << bitset<64>(reg(toks[1])) << endl;
			}
			else if(o=="?"||o=="read")cin>>reg(toks[1]);
			else if(o=="="||o=="movabs")reg(toks[1])=num(toks[2]);
			else if(o=="*"||o=="mul")reg(toks[1])*=reg(toks[2]);
			else if(o=="/"||o=="div")reg(toks[1])/=reg(toks[2]);
			else die("unknown instruction");
		}
		else die("unknown instruction or missing arguments");
	}
	system("pause");
	return 0;
}
```

后文若没有明确说明，所有除法都是向下取整。

# A

$$4080x=4096x-16x=2^{12}x-2^4x$$

加法进行赋值，位移处理，减法解决。

```
+ y x
< y 4
< x 12
- x y
! x
```

# B

$$\frac x{4080}=\frac{2^kx}{2^k\times4080}=\frac{x\times\frac{2^k}{4080}}{2^k}$$

我们只需要试一遍所有不超过 $64$ 的 $k$，手动计算 $\frac{2^k}{4080}$，拆位，用位移和加法实现乘法，一边处理一边向另一个寄存器输出，最后让那个寄存次进行位移即可。

~~经过尝试~~，~~偷看题解~~，我们找到了合适的 $k=43$。其实这个 $k$ 是可以计算得到的，为什么，是因为我们需要让 $k$ 尽量大（精度更高），然而让 $\frac{2^k}{4080}$ 乘给的 $x$ 不超过 $64$ 位。于是，我们用计算器摁出最大的 $k$ 使得 $\frac{2^k}{4080}<2^{32}$ 即可。最后贴一下分解，省着太懒的读者按计算器花时间。

$$\frac{2^k}{4080}=2155905153=\sum\limits_{i\in\{0,7,15,23,31\}}2^i$$

```
+ y x
< x 7
+ y x
< x 8
+ y x
< x 8
+ y x
< x 8
+ y x
> y 43
! y
```

这只有 11 条指令，出题人，快点把 16 改小。

# C

常数节点，哦对不能用。但是我们可以用官方题解。

想要常数，我们可以先想办法把这个值域很大的 $x$ 值域缩小。

一个很妙的做法就是把这个数取负。

如果 $x\ge2^{63}$ 那么 $x$ 的最高位一定是 $1$，若 $x\le2^{63}$ 那么 $-x$ 的最高位一定是 $1$，则 `(x>>63)+((-x)>>63)` 仅可能为 $1$ 或 $2$，我们把这个 $1$ 或 $2$ 再次取负我们就可以得到一个前缀有非常多的 $1$ 的数。

因为 $(4080)_{10}=(111111110000)_2$ 位移两次再相减。

```
- y x
> x 63
> y 63
+ x y
- a x
> a 52
+ b a
> a 8
- b a
! b
```

这只有 10 条指令，出题人，快点把 16 改小。

# D

定义 $\&$ 为二进制按位与。

根据 A 的思路我们想到可以拆位，拆位可以不断把给定的一个数右移（不妨为 $x$），把另一个数左移（不妨为 $y$）。实际上，这样做指令条数比较多（似乎是多一条无用的移 $x$ 指令），我们也可以从低到高扫描 $x$ 的每一位，并对 $y$ 不断左移，每次对 $x$ 进行位提取即可。

于是我们的思路如下：

```python
for i in range(64) :
	if x & (1 << i) != 0 :
		cnt += y
	y <<= 1
```

循环我们展开，位移，累加都好解决，但是这是旷野小计算，指令集很小，没有分支。

我们~~偷看题解后~~发现，其实 `cnt += y` 等价与 `cnt += y * (1 if x & (1 << i) != 0 else 0)`。

获取 $x$ 的特定位，我们可以先左移后右移。设这一位是 $a\in\{0,1\}$。

然后 $cnt$ 就为每一步下的 $y\times a$ 之和。

于是我们的量乘问题，一点都没有解决。（是吗？）

我们发现我们的问题变成了求一个数乘 $1$ 或 $0$ 的结果，后面是很关键的一步，~~继续偷看题解~~发现 $b\in\{0,1\}$ 时 $a\times b=a\&-b$，这是非常好证明的。

最后解决 $\&$，我们都知道 $2\times(a\&b)=a+b-(a\oplus b)$，问题解决了。

细节：按位与的加法可能超过数据范围，被忽略掉一个最高位，我们发现我们只需要把需要乘的那个 $0$ 或 $-1$ 拆出最高位和剩下的位，分别做两次与即可。高级语言循环体的第二次执行及以后，$y$ 都是 $2$ 的倍数，直接右移后做 $\&$ 做即可。

另一个细节：大常数选手指令条数太多了那不全分。我们可以认真思考自己的代码上一步会让寄存器的变量的值赋为什么，针对上一次的赋值范围适当减少初始化指令次数。

776 行，不知道为什么要放那么迷惑的 1024 行作为限制，我曾经以为我的 1200+ 的解很接近正解了，实际上差得远。

用可读性极差的代码，生成不可读的代码，最后眯着眼睛看根本没有可读性的测试输出。T\_T

```cpp
for (int i = 0; i < 64; i++) {
	if (i == 63) {
		cout << "^ b b" << endl;
	}
	cout << "+ b x" << endl;
	if (i < 63) {
		cout << "< b " << 63 - i << endl;
	}
	cout << "> b 63" << endl; // b = bool(x & (1 << i))
	if (i == 0) {
		cout << "- x b" << endl;
	}
	if (i) {
		cout << "^ a a" << endl;
		cout << "^ c c" << endl;
	}
	if (i == 0) {
		cout << R"(- a b
> a 1
+ c a
+ c y
^ a y
- c a
> c 1
+ d c
> a 63
+ b a
> b 1
< b 63
+ d b
< y 1
> y 1
)";
	} else {
		cout << R"(- a b
+ c a
+ c y
^ a y
- c a
+ d c
< y 1
)";
	}
}
cout << "! d";
```

这只有 776 条指令，出题人，快点把 1024 改小。

# E

官解里写的高级语言代码怪怪的，为什么是 `>` 不是 `>=`，为什么是 `y -= b` 不是 `x -= y << i`？正确性应当被怀疑？

先自己给出一份高级语言的龟速除代码

```python
x, y = map(int, input().split())
d = 0
print(x // y) # 保证正确答案
for i in range(63, -1, -1) :
	b = x >> i
	if b >= y :
		d += 1 << i
		x -= y << i
print(d) # 计算出的答案
```

循环自然是手动展开，`b >= y` 等价与 `b - y` 的最高位是 `0`，换句话说，我们只有在 $\frac{\frac x{2^i}-y}{2^{63}}\oplus1=1$ 时执行下面的两条累加。

官解里说什么【有 `1 << i` 这个表达式，所以需要用 case 3 的办法造出常数 $1$ 来。】有点糖，`(1<<i)*(b-y>>63)` 不是可以写成 `b-y>>63<<i` 吗？

好吧还是似乎需要造个 $1$，方便 $\frac{\frac x{2^i}-y}{2^{63}}\oplus1$，题目保证 $y\neq0$，用 $y$ 造一个即可。

这里又遇到了 `(y << i) & ...` 其中 `...` 为 $-1$ 或 $0$ 的情况，我们同样使用乘法的 trick 即可（也就是按位与的两侧如果先除以二无影响，则先除以二避免加法溢出）。可是我们发现，$i=0$ 的时候这个右移后与再左移的 trick 并不使用，但是我们的 $i$ 是从大到小枚举的，换句话说，$i=0$ 的时候我们根本不需要处理我们的那个 `x -= y << i`！

```cpp
// 无脑维护，使劲调试，高达十二分！
cout << R"(+ b y
- c y
> b 63
> c 63
- a b
- a c
> a 63
)"; // 造 1 的代码，a = 1
for (int i = 63; i >= 0; i--) {
	cout << "^ b b" << endl;
	cout << "^ c c" << endl;
	cout << "+ b x" << endl;
	if (i != 0) cout << "> b " << i << endl;
	cout << "- b y" << endl;
	cout << "> b 63" << endl; // b = 0 if x >> i >= y else 1
	cout << "^ b a" << endl; // b = 1 if x >> i >= y else 0
	// 然后 d += b << i
	if (i != 0) cout << "< b " << i << endl;
	cout << "+ d b" << endl;
	if (i != 0) cout << "> b " << i << endl;
	if (i != 0) { // 然后 x -= (y << i) & c
		cout << "- c b" << endl; // c = 0xffff if x >> i >= y else 0
		cout << "> c 1" << endl; // c = 0x7fff if x >> i >= y else 0
		cout << "- x c" << endl;
		if (i == 1) {
			cout << "- x y" << endl;
			cout << "^ c y" << endl;
		} else {
			cout << "^ b b" << endl;
			cout << "+ b y" << endl;
			cout << "< b " << i - 1 << endl;
			cout << "- x b" << endl;
			cout << "^ c b" << endl;
		}
		cout << "+ x c" << endl;
	}
}
cout << "! d";
```

突然发现，题目保证 $x,y\le2^{32}$，删除几条防溢出的指令。这样我们就只需要在内层循环再卡两条指令就可以了。等等，题目保证 $x,y\le2^{32}$？那么我们把枚举的 $i$ 从 $31$ 开始就可以了。

```cpp
cout << R"(+ b y
- c y
> b 63
> c 63
- a b
- a c
> a 63
)"; // 造 1 的代码，a = 1
for (int i = 31; i >= 0; i--) {
	cout << "^ b b" << endl;
	cout << "^ c c" << endl;
	cout << "+ b x" << endl;
	if (i != 0) cout << "> b " << i << endl;
	cout << "- b y" << endl;
	cout << "> b 63" << endl; // b = 0 if x >> i >= y else 1
	cout << "^ b a" << endl; // b = 1 if x >> i >= y else 0
	// 然后 d += b << i
	if (i != 0) cout << "< b " << i << endl;
	cout << "+ d b" << endl;
	if (i != 0) cout << "> b " << i << endl;
	if (i != 0) { // 然后 x -= (y << i) & c
		cout << "- c b" << endl; // c = 0xffff if x >> i >= y else 0
		// cout << "> c 1" << endl; // c = 0x7fff if x >> i >= y else 0
		cout << "- x c" << endl;
		if (i == 1) {
			cout << "- x y" << endl;
			cout << "^ c y" << endl;
		} else {
			cout << "^ b b" << endl;
			cout << "+ b y" << endl;
			cout << "< b " << i - 1 << endl;
			cout << "- x b" << endl;
			cout << "^ c b" << endl;
		}
		cout << "+ x c" << endl;
	}
}
cout << "! d";
```

如果被允许看官方题解，感觉难度和乘法差不多。

这只有 570 条指令（因为数据范围小），出题人，快点把 1024 改小。

# F

开根，困难。

~作者太菜，不会，全力在研究，出不了几天估计就能补上。~

根据 E 题的传奇官解代码出错行为，F 又没有什么做法解释，抛开官解理论部分自己先研究一下。

手撕平方根？曾经数学老师交过，学案丢了。迅速补一下，推荐[这个视频](https://www.bilibili.com/list/ml3406185250?oid=113508603730402&bvid=BV1XBSFYDEEc)。

容易发现，还是降序枚举位，确定到底能不能再放一个 $1$。check 的复杂度如果是乘法，那么会爆得很离谱，根据我的 775 步 $64$ 位乘法解，需要大约 390 步完成 $32$ 位乘法，加一些小优化（就是只枚举已经填过数的哪些位，后缀 $0$ 不用管），预估需要 6500 步左右。

考虑优化，使用手撕平方根算法。何为手撕平方根算法？

计算乘法的复杂度太高了，假设枚举到第 $i\in[0,31]$ 位，如果我们记录之前算过的 $[i+1,31]$ 这些位的乘积 $S$，我们能优化很多复杂度。这就是手撕平方根算法的核心思路。我们记录已经放的位的乘积 $S$ 与前面这些位的值 $a$，我们只需要比较 $S+a\times2^{i+1}+2^{2i}$ 和 $x$ 即可，若小于等于 $x$，更新 $S$ 为这个结果，否则不动。这个分支结构看似复杂至极实际非常困哪，用我们刚才 E 的处理有关分支取决于数的大小的方法大概也能做出来。

写出高级语言代码进行检测：

```python
x = int(input())
print(x ** 0.5)
a = 0 # a
b = 0 # S
for i in range(31, -1, -1) :
	if b + (a << (i + 1)) + (1 << (2 * i)) <= x :
		b += (a << (i + 1)) + (1 << (2 * i))
		a += 1 << i
print(a)
```

于是式子是正确的，进行优化：

```python
x = int(input())
print(x ** 0.5)
a = 0 # a
b = 0 # S
c = 1 # 官解用的 c 存储 1，跟官解一样吧
for i in range(31, -1, -1) : # 后面的代码就是依照上面的式子模拟
	d = a;
	d <<= i + 1
	d += c << i * 2
	# print(d)
	# print((a << (i + 1)) + (1 << (2 * i)))
	a += ((b + d - 1 - x) % (1 << 64) >> 63) << i
	# 这个东西二进制下只有一个 1，可以直接用 (b+d-1-x>>63)<<i 得到
	if b + d <= x :
		b += d
print(a)
```

这题也会用到前面的“$i=0$ 不处理”“先位移后加减”等 trick，但是指令生成器代码更长，细节更多。

写代码的过程中，我们发现我们有可能用“相减再取最高位”的方法会出错，因为这题数据范围太大了。为了解决这个问题，我的方法是这样的：外层枚举 $i$ 的过程中，若 $i$ 比较大，才会出现这个情况，但是我们 $i$ 比较大的时候需要比较的数都与末几位无关（因为那个表示面积的 $S+d$ 是二的很大的整数幂的倍数），把 $S+d$ 和 $x$ 先右移 $2$ 再比较即可，对于 $i$ 比较小的情况，因为前几位已经对 $x$ 进行了一些逼近了，我们用刚才的朴素做法做也不会溢出。（没有判溢出是可以过自己测的小数据的，但是 SPJ 大概是用的按位逻辑推理评测的代码，难以通过。）

比乘法和除法难得多，但是很有趣。（除了做法名字，这题官解我没看，很高兴。）

```cpp
// 懒得删调试了
cout << R"(+ a x
- b x
> a 63
> b 63
- c a
- c b
> c 63
^ a a
^ b b
)"; // 造 1 的代码，c = 1
for (int i = 31; i >= 0; i--) {
	/*
	if (i == 31) { // 作者想对 31 再卡卡，但是 WA 了，懒得调，反正 30 处理对了，31 和 30 一个逻辑一起处理了就多几条指令
		cout << "^ d d" << endl;
		cout << "+ d x" << endl;
		cout << "> d 62" << endl;
		cout << "^ a a" << endl;
		cout << "- a d" << endl;
		cout << "> a 63" << endl;
		cout << "+ b a" << endl;
		cout << "< b 31" << endl;
		cout << "< a 62" << endl;
		continue;
	}
	*/
	if (i < 31) cout << "^ d d" << endl;
	cout << "+ d a" << endl;
	if (i < 30)
		cout << "< d " << i + 1 << endl;
	else
		cout << "< d " << i - 1 << endl;
	if (i < 30) {
		if (i) cout << "< c " << i * 2 << endl;
	} else {
		cout << "< c " << i * 2 - 2 << endl;
	}
	cout << "+ d c" << endl;
	if (i < 30) {
		if (i) cout << "> c " << i * 2 << endl;
	} else {
		cout << "> c " << i * 2 - 2 << endl;
	}
	if (i < 31) cout << "^ y y" << endl;
	cout << "+ y b" << endl; // 可能会越界，把所有比较操作先右移
	if (i >= 30) cout << "> y 2" << endl;
	cout << "+ y d" << endl;
	cout << "- y c" << endl;
	if (i >= 30) {
		// 空间不够，覆盖已经据算掉的 d
		cout << "^ d d" << endl;
		cout << "+ d x" << endl;
		cout << "> d 2" << endl;
		cout << "- y d" << endl;
		// 然后才计算真实的 d
		cout << "^ d d" << endl;
		cout << "+ d a" << endl;
		cout << "< d " << i + 1 << endl;
		cout << "< c " << i * 2 << endl;
		cout << "+ d c" << endl;
		cout << "> c " << i * 2 << endl;
	} else {
		cout << "- y x" << endl;
	}
	// cout << "! y" << endl;
	cout << "> y 63" << endl;
	// 上面计算好了 d 和分支参数 y
	// cout << "print add square size=" << endl;
	// cout << "! d" << endl;
	// cout << "print if y == 1, can add" << endl;
	// cout << "! y" << endl;
	if (i) cout << "< y " << i << endl;
	cout << "+ a y" << endl;
	if (i == 0) {
		break;
	}
	cout << "> y " << i << endl;
	// 后续如果 y = 1，那么 b += d，否则 b += 0
	// 但是寄存器被用完了
	// y 的计算需要 d，但是 d 只需要计算原先的 a，原先的 a 需要 y
	// 发现先让 -y 覆盖当前的 d，然后把 -y 倒腾会 y 寄存器
	cout << "^ d d" << endl;
	cout << "- d y" << endl;
	cout << "^ y y" << endl;
	cout << "+ y d" << endl;
	// 用 d 寄存器计算 2 ^ i * -y ，再加一下当前的 a 可以还原上一步结束的 a
	if (i) cout << "< d " << i << endl;
	// cout << "! d" << endl;
	cout << "+ d a" << endl;
	cout << "< d " << i + 1 << endl;
	// cout << "print c should be 1" << endl;
	// cout << "! c" << endl;
	if (i) cout << "< c " << i * 2 << endl;
	cout << "+ d c" << endl;
	if (i) cout << "> c " << i * 2 << endl;
	// 上面重新计算 d
	// 让后 b += d & y
	// d 是矩形新增面积（看我贴链接的那个视频）
	// 因为 i>0 才处理，d 和 y 都提前右移是可以的
	cout << "> d 1" << endl;
	cout << "> y 1" << endl;
	// cout << "! d" << endl;
	// cout << "! y" << endl;
	cout << "+ b d" << endl;
	cout << "+ b y" << endl;
	cout << "^ y d" << endl;
	cout << "- b y" << endl;
	// cout << "! a" << endl;
	// cout << "! b" << endl;
}
cout << "! a";
```

1000 行，卡得紧，好险。

update 20250617：做复杂了，这题其实不需要“记录 $S$”再比较 $S+d$ 和 $x$，又为了避免空间不够，覆盖 $d$ 再计算 $d$，其实可以直接维护在 $x$ 寄存器中维护 $x-S$，代码会少很多。怎么说呢，我只用五个可写寄存器和一个只读寄存器在限制内完成了标算（可能）需要六个可写寄存器完成的问题（不知道该不该高兴）。至于那个简单做法，我也不想写了，跟上面的差不了太多。

# G

为什么官解里管这个问题叫做容量，不清楚，但是可以很快写出高级语言代码。

```python
x = int(input())
x = x - 1
x |= (x >> 1)
x |= (x >> 2)
x |= (x >> 4)
x |= (x >> 8)
x |= (x >> 16)
x |= (x >> 32)
x = x + 1
print(x);
```

意思是：让 $x-1$ 的 `topbit` 覆盖全部后方的二进制位，然后加一。

首先我们肯定需要根据 $x\neq0$ 造一个 $1$ 先存着，将 $x-1$，最后将 $x+1$。

后文规定 $|$ 为二进制按位或。

中间计算过程中，位移是好实现的，按位或可以拆 $a|b=a+b-\frac{a+b-(a\oplus b)}2$。想办法卡卡就可以过，感觉没有 D 难。

```cpp
cout << R"(+ b x
- c x
> b 63
> c 63
- a b
- a c
> a 63
- x a
)";
for (int i : {1, 2, 4, 8, 16, 32}) {
	cout << "^ b b" << endl;
	cout << "^ c c" << endl;
	if (i != 1) {
		cout << "^ d d" << endl;
	}
	cout << "+ b x" << endl;
	cout << "> b " << i << endl;
	cout << "+ c b" << endl;
	cout << "+ c x" << endl;
	cout << "+ d b" << endl;
	cout << "^ d x" << endl;
	cout << "- c d" << endl;
	cout << "> c 1" << endl; // c = x & b
	cout << "+ x b" << endl; // x' = x + b
	cout << "- x c" << endl; // x' = (x + b) - (x & b) = x | b
}
cout << "+ x a" << endl;
cout << "! x";
```

这只有 87 条指令，出题人，快点把 96 改小。

# 评价

是一个很有意思的题目，难度不是很高（但我支持它是黑，我的意思是，没有旷野大计算难），但是有点 Educational。

BCDE 的限制卡得不严，让人做出一个自己满意的解后会高兴更久。

里面有几个很有趣的 trick 例如按位与先位移后计算避免先计算后位移的加法溢出。

好题，可是洛谷没有 upvote 功能。

# 完整答案

[完整的答案有点小长，放在这里了。](https://www.luogu.com.cn/problem/U570552)

---

## 作者：Twlight！ (赞：2)

大部分是赛时做法，所以步数基本上会比楼上的劣，不过还是希望分享一下赛时思路（毕竟不是人人都能直接想到最优解）。

注：除特殊说明外，本题所有运算都在 $64$ 位无符号整数范围内。


## 前置知识

[二进制](https://baike.baidu.com/item/二进制/361457)、[位运算](https://baike.baidu.com/item/位运算/6888804)、模拟计算能力。


## Sub 1: $4080x$

发现 $4080x = 4096x - 16x = 2^{12}x - 2^{4}x$，直接赋值移位后相减即可，参考代码如下。

```
+ a x
< x 12
< a 4
- x a
! x
```


## Sub 2: $\frac{x}{4080}$

由除法的基本性质，我们不妨设一整数 $k$，有： 

$$\frac{x}{4080} = \frac{x \times 2^k}{4080 \times 2^k} = \frac{x \times \frac{2^k}{4080}}{2^k}$$

因此原式变为了计算 $x \times \frac{2^k}{4080}$ 然后右移 $k$ 位。由于所有操作会向下取整，我们固然希望 $k$ 越大越好，此外我们还得保证 $x \times \frac{2^k}{4080}$ 不会溢出。通过指对数函数运算不难发现只用让 $\frac{2^k}{4080}$ 的二进制位数小于等于 $32$ 位即可，最大可取 $k = 43$。

此时 $\frac{2^k}{4080} = 2155905152$，容易发现答案小了。调整法取 $2155905153$，随后做按位乘法即可。

```
+ b x
> b 7
+ a b
+ a x
< x 8
+ a x
< x 8
+ a x
< x 8
+ a x
> a 36
! a
```


## Sub 3: $4080$

由[前世记忆](https://www.luogu.com.cn/problem/P10400)我们其实可以发现常数节点并不是那么简单，故必须思考一波。

直观感受，我们必须先搞出简单常数后才能进行后续操作，因此考虑二进制运算的相关性质。

手玩可以发现 $-x$ 和 $x$ 最高位必有一个 $1$，仅当 $x = 2^{63}$ 的时候 $x = -x$，我们直接提取最高位，相加后取负得到 $-1$ 或 $-2$，而它们的二进制前缀有非常多的 $1$。

因为 $(4080)_{10} = (111111110000)_{2}$ 有一片的 $1$，我们可以直接把刚才构造的数右移截断，再左移得到，参考代码如下：

```
- y x
> x 63
> y 63
+ x y
- a x
> a 56
< a 4
! a
```

实际上我一开始写的版本并没有解决 $x = 2^{63}$ 时的情况，这也就导致了我下个任务 $x \times y$ 出现了问题，但是评测机并没有发现，我也就因此过掉了，原错误代码如下（供大家嘲笑）：

```
- b x ;
^ b x ;
> b 63 ;
+ a b ; 这里得到 b = 1
< b 12 ;
< a 4 ;
- b a ;
! b ;
```

但是这份错误代码为接下来乘除法提供了优秀的理论基础（虽然我也不知道用没用上）。


## Sub 4: $x \times y$

过家家要结束了，大的要来了。

显然我们没法直接使用乘法，再加上本任务限制 $1024$ 行，因此我们可以考虑按位分类讨论。根据直觉，我们不难写出一份龟速乘代码：

```cpp
cin >> x >> y, a = 0;
for (int i = 0; i <= 63; ++i) {
	if (y & 1) a += (x << i);
	y >>= 1;
}
```

显然我们也没有 if 语句，考虑把代码进一步简化：

```cpp
cin >> x >> y, a = 0, b = 0, c = 0, d = 0;
for (int i = 0; i <= 63; ++i) {
	c = (y & 1); // ①
	d = x * c; // ②
	d <<= i; // ③
	a += d; // ④
	y >>= 1; // ⑤
}
```

再看这份代码，五个点中只有 ② 是比较难实现的，也就是 $\text{bit} \times x$ 这一步，于是我们考虑~~询问 AI~~搜索相关性质（毕竟愚人节比赛中可以干这些事）。

我们搜索到，$b \in \{0, 1\}$ 时，$a \cdot b = a \& -b$，且 $a + b = (a \oplus b) + 2(a \& b)$，于是我们直接模拟就行了。

不过我在赛时只推出了这个：当 $b \in \{-1, 0\}$ 时，$a \cdot b= ((a + b) + \frac{-a \oplus b}{2}) - b$，于是这里只能顺着这个往下做，得到 ② 的参考代码如下：

```
; 记 b = MASK，即 b = 0 / -1 
^ d d ; d 清零
- d x ; d: -x
^ d b ; d: (-x ^ MASK)
+ d b ; d: (MASK) + (-x ^ MASK)
+ d x ; d: (x + MASK) + (-x ^ MASK)
> d 1 ; d: ((x + MASK) + (-x ^ MASK)) >> 1
- d b ; d += b => d = -b * x
```

随后我们便得到了一份基本模板：

```
; a: 结果
; b: y 的最低位（MASK）
; c: x 的最高位
; d: 本次计算结果

; ①：让 b 变为 - (y & 1)
^ b b ; b 清零
+ b y ; b 变为 y
> b 1 ; 舍去最低位
< b 1 ; 舍去最低位
- b y ; 让 b 变为 MASK

; ②：让 d 变为 (y & 1) * x
^ d d ; d 清零
- d x ; d: -x
^ d b ; d: (-x ^ MASK)
+ d b ; d: (MASK) + (-x ^ MASK)
+ d x ; d: (x + MASK) + (-x ^ MASK)
> d 1 ; d: ((x + MASK) + (-x ^ MASK)) >> 1
- d b ; a += 1

; ③
< d ${k} ; 左移 k 位，模拟乘法

; ④
+ a d ; a += d

; ⑤
> y 1
```

于是你立马使用 `for` 循环把这份代码复制了 $63$ 次，交上去发现错飞了。

显然我们再一次忽略了最高位的情况，右移操作的前提是最高位不溢出，因此我们还得对第 $64$ 位单独讨论。解决办法也很简单，只有当 $y \& 1 = 1$ 时它才能产生贡献，于是我们在处理 $y$ 的最低位乘法那里动手脚。考虑把 $x$ 拆为第 $64$ 位和剩下 $63$ 位的两个数，分别做一次即可，参考代码如下：

```
; a: 结果
; b: y 的最低位（MASK）
; c: x 的最高位
; d: 本次计算结果

+ c x ; c 变为 x
> c 63 ; 取 x 的最高位
+ b y ; b 变为 y
> b 1 ; 舍去最低位
< b 1 ; 舍去最低位
- b y ; 让 b 变为 MASK
^ d d ; d 清零
- d c ; d: -x
^ d b ; d: (-x ^ MASK)
+ d b ; d: (MASK) + (-x ^ MASK)
+ d c ; d: (x + MASK) + (-x ^ MASK)
> d 1 ; d: ((x + MASK) + (-x ^ MASK)) >> 1
- d b ; a += 1
< d 63 ; 特殊处理 x 的最高位
+ a d ; a += d
^ b b ; b 清零
+ b y ; b 变为 y
> b 1 ; 舍去最低位
< b 1 ; 舍去最低位
- b y ; 让 b 变为 MASK
^ d d ; d 清零
^ c c ; c 清零
+ c x ; 让 c = x，并舍弃 c 的最高位
< c 1 ; 舍弃 c 的最高位
> c 1 ; 舍弃 c 的最高位
- d c ; d: -x
^ d b ; d: (-x ^ MASK)
+ d b ; d: (MASK) + (-x ^ MASK)
+ d c ; d: (x + MASK) + (-x ^ MASK)
> d 1 ; d: ((x + MASK) + (-x ^ MASK)) >> 1
- d b ; a += 1
< d 1 ; 截高位
> d 1 ; 截高位
+ a d ; a += d
> y 1
```

把上述两份代码拼起来即可通过本测试点（具体完整代码见本文末尾或讨论区）。


## Sub 5: $\frac{x}{y}$

发现这题的 $x,y$ 都在 $32$ 位无符号整数范围内，于是我们可以写一份龟速除代码：

```cpp
x = 114514191, y = 810, a = 0;
for (int i = 31; i >= 0; --i) {
	if (x >= (y << i)){
		a += (1ull << i);
		x -= (y << i);
	}
}
cout << a << endl;
```

同样的，我们把 if 语句拆开，得到如下代码：

```cpp
y <<= 31;
for (int i = 31; i >= 0; --i) {
	c = (x >= y); // ①
	a += (c << i); // ②
	x -= c * y; // ③
	y >>= 1; // ④
}
cout << a << endl;
```

显然这四步里只有判断 $x \geq y$ 是没有解决的，因此我们考虑如何判断。

容易发现，当 $x < y$ 时，$x - y$ 的最高位必定是 $1$，我们便可以借此先尝试减去 $y$，如果发现最高位有 $1$ 再把 $y$ 加回去，参考代码如下：

```cpp
x = 114514191, y = 810, a = b = c = d = 0;
y <<= 31;
for (int i = 31; i >= 0; --i) {
	a <<= 1;
	d = ((x - y) >> 32);
	c = !!d;
	x -= y, x += c * y;
	a += 1, a -= c;
	y >>= 1;
}
cout << a << endl;
```

其中 `!!d` 便是归一，因为它最高位小于 $64$ 位，我们可以使用前面的超短归一代码：

```
> d 32 ; 取 d 的前 32 位
- c d ; 搞出 c = 1
^ c d ; 搞出 c = 1
> c 63 ; 搞出 c = 1
```

其余再模拟乘法任务中使用的技巧即可，很幸运这题不需要对最高位特判，参考代码如下：

```
; a: 结果
; c: 1/0
; d: ①x - (y << k) 的前 32 位; ②MASK

< y 32 ; 试除法，从高往低除
^ a a ; 清空 a

; --这一坨代码要循环 32 次，请自己复制--
> y 1 ; 下一位
< a 1 ; a << 1
^ d d ; d 清空
^ c c ; c 清空
+ d x ; d = x
- d y ; d = x - (y << k)
> d 32 ; 取 d 的前 32 位
- c d ; 搞出 c = 1
^ c d ; 搞出 c = 1
> c 63 ; 搞出 c = 1
^ d d ; d 清空
- d c ; 让 d 变为 MASK
- x y ; 让 x = x - y
^ b b ; b 清空
- b y ; b: -y
^ b d ; b: -y ^ MASK
+ b d ; b: (MASK) + (-x ^ MASK)
+ b y ; b: (y + MASK) + (-y ^ MASK)
> b 1 ; b: ((y + MASK) + (-y ^ MASK)) >> 1
- b d ; b += 1
+ x b ; 让 x = x - y + (x < (y << k) ? 0 : y)
^ b b ; 搞出 b = 1
- b y ; 搞出 b = 1
^ b y ; 搞出 b = 1
> b 63 ; 搞出 b = 1
+ a b ; a += b
- a c ; a += x > (y << k)
; --这一坨代码要循环 32 次，请自己复制--

! a
```


## Sub 6: $\sqrt{x}$

赛时唯一没做出来的子任务，可见它很难。

通过赛后查阅~~他人做法~~和[相关资料](https://en.wikipedia.org/wiki/Square_root_algorithms)，我们可以搞到一份手撕根号代码（这并不是本文重点，因此证明可见[云剪贴板](https://www.luogu.com.cn/paste/pr3myuhj)）：

```cpp
cin >> x;
for (int i = 31; i >= 0; --i) {
	a <<= 2;
	a += (x >> (i * 2)) & 3ull;
	if (a >= b * 4 + 1) a -= b * 4 + 1, b = b * 2 + 1;
	else b = b * 2;
}
cout << b << endl; 
```

同样对该代码进行改造，去掉 if 语句得到如下代码：

```cpp
cin >> x;
for (int i = 31; i >= 0; --i) {
	a *= 4; // 一
	a += (x >> (i * 2)) & 3; // 二
	c = b * 4; // 三
	d = (a > c); // 四
	a -= d * (c + 1); // 五
	b = b * 2 + d; // 六
}
cout << b << endl; 
```

同样的，只有四、五是需要我们特别关注的，其余都可以直接无脑模拟。对于四，我们巧妙地把大于等于改为了大于，避免了很多麻烦操作。

考虑判断 $a > 4b$ 时有两种情况。第一种是 $a$ 的位数超过了 $34$ 位，此时显然 $a > 4b$；第二种是 $a$ 的位数小于等于 $34$ 位，如果 $a > 4b$，那么 $4b - a < 0$，显然此时 $a, 4b$ 的位数不会超过 $34$ 位，直接判断 $4b - a$ 最高位是否有 $1$ 即可。两种情况相加后取负数最高位即可得到 $a > 4b$，参考代码如下：

```
; 四 d = b * 4
^ y y ; y = 0
+ y d ; y = d
- y a ; y = d - a
> y 63 ; y = (d - a) >> 63
^ c c ; c = 0
+ c a ; c = a
> c 34 ; c = (a >> 34)
+ y c ; y = ((d - a) >> 63) + (a >> 34)
^ c c ; c = 0
- c y ; c = -(((d - a) >> 63) + (a >> 34))
> c 63 ; c = (a > d)
```

接下来是乘法，因为这题是赛后写的，所以我知道了 $a + b = (a \oplus b) + 2(a \& b)$，而这里又不会溢出，我们直接模拟即可，参考代码如下：

```
; 五 接刚才代码
^ y y ; y = 0
- y c ; y = -(a > d)
^ c c ; c = 0
+ c d ; c = 4 * b
- c y ; c = 4 * b + 1
^ c y ; c = (4 * b + 1) ^ -(a > d)
- d c ; d = (d + 1) * (a > d) * 2
> d 1 ; d = (d + 1) * (a > d)
- a d ; a -= d * (c + 1)
```

于是我们就做完了，把这两份代码拼起来后补一下剩下的东西，可以得到一份基本单元：

```
< a 2 ; a <<= 2 ; 一
^ d d ; d = 0 ; 二
+ d x ; d = x
< d ${62 - i * 2} ; d = 搞出 d = (x >> (i * 2)) & 3
> d 62 ; 搞出 d = (x >> (i * 2)) & 3
+ a d ; a += (x >> (i * 2)) & 3
^ d d ; d = 0 ; 三
+ d b ; d = b
< d 2 ; d = b * 4
^ y y ; y = 0
+ y d ; y = d
- y a ; y = d - a
> y 63 ; y = (d - a) >> 63
^ c c ; c = 0
+ c a ; c = a
> c 34 ; c = (a >> 34)
+ y c ; y = ((d - a) >> 63) + (a >> 34)
^ c c ; c = 0
- c y ; c = -(((d - a) >> 63) + (a >> 34))
> c 63 ; c = (a > d) ; 四
^ y y ; y = 0
- y c ; y = -(a > d)
^ c c ; c = 0
+ c d ; c = 4 * b
- c y ; c = 4 * b + 1
^ c y ; c = (4 * b + 1) ^ -(a > d)
- d c ; d = (d + 1) * (a > d) * 2
> d 1 ; d = (d + 1) * (a > d)
- a d ; a -= d * (c + 1) ; 五
< b 1 ; b = b * 2 ; 六
- b y ; b = b * 2 + (a > d)
```

生成代码如下（JavaScript）：
```javascript
// 浏览器可以直接跑这份代码
let ret = "";
for (let i = 31; i >= 0; --i) ret += 
`< a 2 ; a <<= 2 ; 一
^ d d ; d = 0 ; 二
+ d x ; d = x
< d ${62 - i * 2} ; d = 搞出 d = (x >> (i * 2)) & 3
> d 62 ; 搞出 d = (x >> (i * 2)) & 3
+ a d ; a += (x >> (i * 2)) & 3
^ d d ; d = 0 ; 三
+ d b ; d = b
< d 2 ; d = b * 4
^ y y ; y = 0
+ y d ; y = d
- y a ; y = d - a
> y 63 ; y = (d - a) >> 63
^ c c ; c = 0
+ c a ; c = a
> c 34 ; c = (a >> 34)
+ y c ; y = ((d - a) >> 63) + (a >> 34)
^ c c ; c = 0
- c y ; c = -(((d - a) >> 63) + (a >> 34))
> c 63 ; c = (a > d) ; 四
^ y y ; y = 0
- y c ; y = -(a > d)
^ c c ; c = 0
+ c d ; c = 4 * b
- c y ; c = 4 * b + 1
^ c y ; c = (4 * b + 1) ^ -(a > d)
- d c ; d = (d + 1) * (a > d) * 2
> d 1 ; d = (d + 1) * (a > d)
- a d ; a -= d * (c + 1) ; 五
< b 1 ; b = b * 2 ; 六
- b y ; b = b * 2 + (a > d) ; ------分割线------
`;

ret += "! b";
console.log(ret);
```

去掉注释后 993 行，比较极限，但这很好玩。


## Sub 7: $2^{\lceil \log_{2}{x} \rceil}$

这是 20 分档里最简单的一个，我们终于快做完了。

不管用什么方法，我们很容易写出本点的代码：

```cpp
x = x - 1
x |= (x >> 1)
x |= (x >> 2)
x |= (x >> 4)
x |= (x >> 8)
x |= (x >> 16)
x |= (x >> 32)
x = x + 1
cout << x << endl;
```

原理很简单，一直覆盖使得 $x - 1$ 的后缀全为 $1$，最后再加上 $1$ 就是答案。

此外，根据神秘经验，我们可以得到 $a | b = (a \oplus  b) + \frac{a + b - (a \oplus  b)}{2}$，因为答案在 64 位无符号整数范围内，摁做就行。具体可以见注释，参考代码如下：

```
; a | b = (a ^ b) + ((a + b - (a ^ b)) / 2)
^ a a
+ b x ; b = x
> b 63 ; b = (x >> 63)
^ b x ; b = x ^ (x >> 63)
- a b ; 搞出 a = 1
^ a b ; 搞出 a = 1
> a 63 ; 搞出 a = 1
- x a ; x = x - 1
; 注意这里用的归 1 操作使用的是 x ^ (x >> 63) 作为基底

^ c c ; 清空 a
^ d d ; 清空 d
^ y y ; 清空 y
^ c x ; c = x
> c 1 ; c = x >> k
^ y c ; y = c
^ y x ; y = x ^ c
+ d x ; d = x
- d y ; d = x - (x ^ c)
+ d c ; d = x + c - (x ^ c)
> d 1 ; d = (x + c - (x ^ c)) / 2
+ d y ; d = (x ^ c) + (x + c - (x ^ c)) / 2

^ c c ; 清空 a
^ x x ; 清空 x
^ y y ; 清空 y
^ c d ; c = d
> c 2 ; c = d >> k
^ y c ; y = c
^ y d ; y = d ^ c
+ x d ; x = x
- x y ; x = d - (d ^ c)
+ x c ; x = d + c - (d ^ c)
> x 1 ; x = (d + c - (d ^ c)) / 2
+ x y ; x = (d ^ c) + (d + c - (d ^ c)) / 2

^ c c ; 清空 a
^ d d ; 清空 d
^ y y ; 清空 y
^ c x ; c = x
> c 4 ; c = x >> k
^ y c ; y = c
^ y x ; y = x ^ c
+ d x ; d = x
- d y ; d = x - (x ^ c)
+ d c ; d = x + c - (x ^ c)
> d 1 ; d = (x + c - (x ^ c)) / 2
+ d y ; d = (x ^ c) + (x + c - (x ^ c)) / 2

^ c c ; 清空 a
^ x x ; 清空 x
^ y y ; 清空 y
^ c d ; c = d
> c 8 ; c = d >> k
^ y c ; y = c
^ y d ; y = d ^ c
+ x d ; x = x
- x y ; x = d - (d ^ c)
+ x c ; x = d + c - (d ^ c)
> x 1 ; x = (d + c - (d ^ c)) / 2
+ x y ; x = (d ^ c) + (d + c - (d ^ c)) / 2

^ c c ; 清空 a
^ d d ; 清空 d
^ y y ; 清空 y
^ c x ; c = x
> c 16 ; c = x >> k
^ y c ; y = c
^ y x ; y = x ^ c
+ d x ; d = x
- d y ; d = x - (x ^ c)
+ d c ; d = x + c - (x ^ c)
> d 1 ; d = (x + c - (x ^ c)) / 2
+ d y ; d = (x ^ c) + (x + c - (x ^ c)) / 2

^ c c ; 清空 a
^ x x ; 清空 x
^ y y ; 清空 y
^ c d ; c = d
> c 32 ; c = d >> k
^ y c ; y = c
^ y d ; y = d ^ c
+ x d ; x = x
- x y ; x = d - (d ^ c)
+ x c ; x = d + c - (d ^ c)
> x 1 ; x = (d + c - (d ^ c)) / 2
+ x y ; x = (d ^ c) + (d + c - (d ^ c)) / 2
+ a x

; ^ y y ; 清空 a
; - y x ; 搞出 a = 1
; ^ y x ; 搞出 a = 1
; > y 63 ; 搞出 a = 1
; + a y ; x = x + 2
! a

```

去掉注释和空行后只有 83 行，竟然比楼上优。

大战后我们终于过了这道题。


## 总结

非常有意思的造计算机题，因为比赛时长长达几天，个人感觉是比隔壁[消失的计算机](https://www.luogu.com.cn/problem/P10400)要简单的。我也没做过旷野大计算，我就不将两者比较了。

不过很可惜这题不像消失的计算机一样会给爆标分数（比如让人拿到106分），不过考虑本题限制卡的非常松，那就无所谓了（当然能比规定行数少还是很值得骄傲的）。

赛时我只靠着基本运算规律手搓，在不交流做法的情况下拿了 80 分（后面讨论手撕根号发现我不会写就摆了），而赛后靠着手撕根号的代码硬搞通过了此题，感觉很有纪念意义，因此写篇题解纪念。

最后感谢 [@EricWan](https://www.luogu.com.cn/user/377873) 的支持，使得我发现了归一代码有误并更正（大家快去%%%）。

一些链接：[赛时提交记录](https://www.luogu.com.cn/record/list?pid=T571828&user=362776)、[赛后提交记录](https://www.luogu.com.cn/record/list?pid=P12601&user=362776)。


## 代码

zip链接：[见云剪贴板](https://www.luogu.com.cn/paste/pr3myuhj)。

若有后续更新，我将会在云剪贴板、评论区说明。

---


# [NOI2025] 绝对防御

## 题目背景

defense.cpp / 4 s / 1024 MiB

## 题目描述


小 Q 在与电脑玩一款名为“绝对防御”的回合制卡牌游戏。

小 Q 有一个大小为 $n$ 的牌堆，包含两种牌：攻击牌与防御牌。游戏开始时，小 Q 会从**牌堆顶**抽取 $k \ (1 \leq k \leq n)$ 张牌作为初始手牌，接下来他会与电脑进行若干轮对战。

每轮对战开始时，小 Q 从牌堆顶抽取 $2$ 张牌。特别地，若牌堆只剩余 $1$ 张牌，则小 Q 只抽取 $1$ 张。一轮对战分为两个**回合**：

- 第一回合：小 Q 为攻击方，电脑为防御方；
- 第二回合：小 Q 为防御方，电脑为攻击方。

在每**回合**中，攻击方**必须**从手牌中选择一张**攻击牌**进行攻击，防御方**必须**从手牌打出一张**防御牌**进行防御。无法按要求出牌者立即判负。

电脑的攻击牌与防御牌都是无限的，即电脑总能打出对应牌。为平衡电脑的实力，小 Q 可以使用一种特殊技能：当小 Q 为**防御方**时，他可以从手牌打出一张**攻击牌**进行防御。该技能每 $3$ 轮**对战**才能使用一次，即在某轮使用技能后，接下来的 $2$ 轮对战中不能使用该技能。

在给定规则下，小 Q 的获胜目标为在电脑猛烈攻击中幸存，即在某轮对战结束后，牌堆被抽空。特别地，若游戏开始时牌堆已被抽空，则小 Q 直接达成获胜目标。小 Q 想知道最小的初始抽牌数 $k$，使得他能达成胜利目标。

小 Q 觉得这个问题过于简单，因此他增加了 $q$ 次修改操作。第 $i \ (1 \leq i \leq q)$ 次修改操作给定一个正整数 $x_i$，改变牌堆顶到牌堆底的第 $x_i$ 张牌的类型，即将攻击牌变为防御牌，将防御牌变为攻击牌。你需要对初始牌堆及每次修改后的牌堆，求出最小的小 Q 初始抽牌数 $k$，使得小 Q 能达成胜利目标。


## 说明/提示



#### 【样例 1 解释】

该样例共包含三组测试数据。

对于第一组测试数据：

- 初始时，牌堆为 $01010$。若初始抽牌数为 $1$，小 Q 的一种可能的出牌方式为：
  - 初始时手牌为 $\{0\}$;
  - 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0\}$;
  - 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0\}$，此时牌堆被抽空。

由于初始至少需要抽取一张牌，所以最小初始抽牌数为 $1$，故 $k_0=1$。
- 第一次修改后，牌堆变为 $01000$。若初始抽牌数为 $1$，小 Q 的一种可能的出牌方式为：
  - 初始时手牌为 $\{0\}$;
  - 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0\}$;
  - 从堆顶抽取两张牌，打出一张攻击牌，使用特殊技能再次打出一张攻击牌进行防御，手牌变为 $\{0\}$，此时牌堆被抽空。
  
由于初始至少需要抽取一张牌，所以最小初始抽牌数为 1，故 $k_1=1$。

对于第二组测试数据：

若初始抽牌数为 $3$，小 Q 的一种可能的出牌方式为：
- 初始时手牌为 $\{0,0,0\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0,0,0\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，使用特殊技能再次打出一张攻击牌进行防御，手牌变为 $\{0,0,0\}$，此时牌堆被抽空。
可以证明，不存在比 $3$ 更小的初始抽牌数能够抽空牌堆，故答案为 $3$。

对于第三组测试数据：

若初始抽牌数为 $2$，小 Q 的一种可能的出牌方式为：
- 初始时手牌为 $\{0,0\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，使用特殊技能再次打出一张攻击牌进行防御，手牌变为 $\{0,1\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0,1\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0,0\}$，此时牌堆被抽空。
可以证明，不存在比 $2$ 更小的初始抽牌数能够抽空牌堆，故答案为 $2$。


【样例 2】

见选手目录下的 `defense/defense2.in` 与 `defense/defense2.ans`。

该样例满足测试点 2 的约束条件。

【样例 3】

见选手目录下的 `defense/defense3.in` 与 `defense/defense3.ans`。

该样例满足测试点 5 ~ 7 的约束条件。

【样例 4】

见选手目录下的 `defense/defense4.in` 与 `defense/defense4.ans`。

该样例满足测试点 9,10 的约束条件。

【样例 5】

见选手目录下的 `defense/defense5.in` 与 `defense/defense5.ans`。

该样例满足测试点 11 的约束条件。

【样例 6】

见选手目录下的 `defense/defense6.in` 与 `defense/defense6.ans`。

该样例满足测试点 12 ~ 14 的约束条件。

 
### 数据范围

设 $N, Q$ 分别为单个测试点内所有测试数据的 $n, q$ 的和。对于所有测试数据，保证：

- $1 \leq t \leq 10^5$；
- $1 \leq n \leq 2 \times 10^5$，$N \leq 5 \times 10^5$；
- $0 \leq q \leq 2 \times 10^5$，$Q \leq 5 \times 10^5$；
- 对于所有 $1 \leq i \leq n$，均有 $s_i \in \{ 0, 1 \}$；
- 对于所有 $1 \leq i \leq q$，均有 $1 \leq k_i < n$。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | $q \leq$ | $N, Q \leq$ | 特殊性质 |
|:------------:|:---------:|:----------:|:-------------:|:----------:|
| $1 $         | $20      $ | $20      $ | $60      $    | 无       |
| $2 $         | $10^2    $ | $10^2    $ | $10^3    $    | 无       |
| $3,4$         | $3000    $ | $3000    $ | $10^4    $    | 无       |
| $5 \sim 7$   | $10^5    $ | $0       $ | $3 \times 10^5$     | 无       |
| $8 $         | $2 \times 10^5$ | $200     $ | $5 \times 10^5$     | 无       |
| $9 \sim 10$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{A B }$    |
| $11$         | ^ | ^ | ^     | $\mathrm{A C }$    |
| $12\sim 14$  | ^ | ^ | ^     | $\mathrm{A D }$    |
| $15\sim 17$  | ^ | ^ | ^     | $\mathrm{E   }$    |
| $18,19$         | ^ | ^ | ^     | 无       |
| $20$         | $2 \times 10^5$ | $2 \times 10^5$ | $5 \times 10^5$     | ^       |

- 特殊性质 $\text{A}$：保证对于所有 $1 \leq i \leq n$，$s_i$ 均在 $\{0,1\}$ 中**独立均匀随机**生成。
- 特殊性质 $\text{B}$：保证所有的 $x_i$ 互不相同，且对于所有 $1 \leq i \leq q$，均有 $s_{x_i} = 1$。
- 特殊性质 $\text{C}$：保证所有的 $x_i$ 互不相同，且对于所有 $1 \leq i \leq q$，均有 $s_{x_i} = 0$。
- 特殊性质 $\text{D}$：保证对于所有 $1 \leq i \leq q$，$x_i$ 均在 $[1, n]$ 中**独立均匀随机**生成。
- 特殊性质 $\text{E}$：保证对于所有 $0 \leq i < q$，均有 $1 \leq k_i \leq 45$。

附加文件来自于 [QOJ](https://qoj.ac/contest/2316/problem/13084)。

## 样例 #1

### 输入

```
0 3
5 1
01010
4
7 0
0001000
10 0
0001010000```

### 输出

```
1 1
3
2```

# 题解

## 作者：strapplE (赞：87)

**题解文字部分很长，知道大家不喜欢看，因此每一段我都会写下省流，有些部分你可以略读。**

给一个（我场上胡的）单点修改线段树二分做法。时间复杂度与题目中的参数 $3$ 无关（即改成任何数都一样），预处理线性，修改单 $\log$，求答案单 $\log$，因此总复杂度 $O(n+q\log n)$。

**省流：给个比较优秀的做法，让大家见笑了。**

先考虑一些暴力的做法。大部分人第一个想到的正确做法应该是二分答案再暴力 dp check。直接做是 $O(qn^2\log n)$ 的，可以 bitset 优化但对正解没啥意义。有不少选手注意到了存在的连续段这个性质，可以获得 $35\sim 40$ pts。再往下就没有前途了，而我赛时可能代码能力不太够没写明白，干脆放弃了这个做法，去想下面的内容了。

**省流：有一些暴力做法，不一定都对正解有帮助，所以我们接下来要取其精华。**

首先保留刚才的二分结构，现在你二分到了 $k$，要判断其是否合法。我们先**刻画**出抽卡的结构。初始有 $$每一轮你可以摸 $1\sim 2$ 张牌，并打出一场攻击牌，一张防御牌或两张攻击牌。只有最后一次**可能**只摸 $1$ 张，所以在每次摸牌前，你手里都**必然**有 $k$ 张牌。

我们称每轮摸牌为一个**回合**，你需要挺过 $t$ 个回合，其中前至少 $t-1$ 个回合都是摸两牌。

**省流：避免题目太玄幻，我们要用数学语言刻画下。**

接下来，我们来定义几个数组变量：

$a_i,b_i$ 分别表示第 $i$ 回合将摸到多少张攻击牌/防御牌，$d_i=a_i+b_i,l_i=1-b_i,r_i=a_i-1$。$L_i,R_i$ 分别为 $l_i,r_i$ 的前缀和。根据这些定义你应该能看出，$\forall i<t,d_i=2,l_i=r_i,L_i=R_i$。以及为了体现做法对于技能冷却时间的普遍性，设 $z=3$。

设初始时的 $k$ 张牌中有 $h$ 张防御牌，则你能活下来，当且仅当存在一个序列 $c_{1\sim t}$ 表示每回合是否发动技能，满足：

- $\forall 1\leq i\leq t,c_i\in \{0,1\}$

- $\forall 1\leq i\leq t,h+(b_1-1+c_1)+(b_2-1+c_2)+\dots+(b_i-1+c_i)\geq 0$

- $\forall 1\leq i\leq t,k-h+(a_1-1-c_1)+(a_2-1-c_2)+\dots+(a_i-1-c_i)\geq 0$

- $\forall 1\leq x\leq y\leq t,y-x<z,c_x+\dots+c_y\leq 1$

**省流：刻画完毕。**

接下来我们稍微做做变形，设 $s_i=c_1+\dots+c_i$。不难证明，$c_i$ 不会取到浮点数，下面我们只去刻画其上下界。四个条件可以分别这样改写：

- $\forall 1\leq i\leq t,0\leq s_i-s_{i-1}\leq 1$

- $\forall 1\leq i\leq t,h-l_1-\dots-l_i+s_i-s_0\geq 0$

- $\forall 1\leq i\leq t,k-h+r_1+\dots+r_i-s_i+s_0\geq 0$

- $\forall 0\leq x<y\leq t,y-x\leq z,s_y-s_x\leq 1$

**省流：我们已经可以转成前缀和的差分约束限制了，因为只要判无解，所以找负环即可。**

建出 $t+1$ 个结点的图，则去除第一条和第四条限制的重复部分后，只剩了如下几种边：

- $\forall 1\leq i\leq t,i\xrightarrow{0}i-1$

- $\forall 1\leq i\leq t,i\xrightarrow{h-L_i}0$

- $\forall 1\leq i\leq t,0\xrightarrow{k-h+R_i}i$

- $\forall 0\leq x<y\leq t,y-x\leq z,x\xrightarrow{1}y$

称这四种边分别为一二三四类边。那么因为一四类边一定非负，不能只通过这类边搞出负环，所以一定要经过一次二三类边，因此一定要经过至少一次 $0$ 号点。而我们只在意**简单**负环，也就是经过 $0$ 号点恰好一次的环。

把二三类边经过的点记作关键点，则一四类边的作用是**连接关键点**，具体地，我们设 $\operatorname{dist}(x,y)$ 表示从 $x$ 只经过一四类边到达 $y$ 的最短路，则有：
$$\operatorname{dist}(x,y)=\max(0,\lceil\dfrac{y-x}{z}\rceil)$$

接下来我们根据是否经过二三类边，把环分为三类，则限制有如下几类：

- 只经过二类边：$\operatorname{dist}(0,x)+h-L_x\geq 0$

- 只经过三类边：$k-h+R_y+\operatorname{dist}(y,0)\geq 0$

- 都经过：$k-h+R_y+\operatorname{dist}(y,x)+h-L_x\geq 0$

**省流：成功得到极其好写的 $O(qn^2\log n)$ 做法，前缀和优化就能得到小常数 $O(qn\log n)$ 的 40pts 了，而且很有前途！**

再做变形，$\operatorname{dist}(x,y)=\lfloor\dfrac{\max(0,y-x+z-1)}{z}\rfloor$，于是又能改写：

- $\forall 1\leq x\leq t,x+z-1+z(h-L_x)\geq 0$

- $\forall 1\leq y\leq t,k-h+R_y\geq 0$

- $\forall 1\leq x<y\leq t,k+R_y-L_x\geq 0$

- $\forall 1\leq y<x\leq t,z(k+R_y-L_x)+x-y+z-1\geq 0$

到这里已经很接近正解了，不过我们还有一些遗留问题。也就是说，我们每次二分一个 $k$ 都要重新分回合，要维护的回合数量（也就是 $t$ 的总和）是 $O(n^2)$ 的，不就爆炸了吗？

此时你会注意到，阶段（即回合）本质不同只可能 $k$ 的奇偶性不同，因此你只需要分两类，奇数开头还是偶数开头。

具体地，如果 $n$ 是偶数，那么奇数开头的 $d$ 序列为 $122\dots221$，偶数为 $22\dots22$。$n$ 是奇数的话，奇数开头为 $122\dots22$，偶数开头为 $22\dots221$。

则二分的一个 $k$ 代表的是，已经完成了前面的一些阶段，你要用线段树维护一段后缀的信息。

**省流：你要根据 $k$ 的奇偶性开两棵线段树，里面完全一样，所以只需要用结构体实现其中一个。下面讲线段树维护的具体细节，然后这个题就被成功解决了。**

如果一起维护的话，开头位置就不是 $0$ 了，设为 $m$ 吧，则限制条件等价于。

- $\forall m<x\leq t,z\cdot h\geq -z+1+\sum\limits_{i=m+1}^{x}(z\cdot l_i-1)$

- $\forall m<y\leq t,z\cdot(k-h)\geq -z+1+\sum\limits_{i=y+1}^{m}(-z\cdot r_i)$

- $\forall m<x<y\leq t,z(k+(R_y-R_m)-(L_x-L_m))\geq -z+1$

- $\forall m<y<x\leq t,z(k+(R_y-R_m)-(L_x-L_m))+x-y\geq -z+1$

第三四条，根据我们很早就提到的性质分别有：

- $L_x-L_m=R_x-R_m$

- $R_y-R_m=L_y-L_m$

因此可以分别改写为：

- $\forall m<x<y\leq t,z(k+R_y-R_x)\geq -z+1$

- $\forall m<y<x\leq t,z(k+L_y-L_x)+x-y\geq -z+1$

因此四个条件也就是：

- $\forall m<x\leq t,z\cdot h\geq -z+1+\sum\limits_{i=m+1}^{x}(z\cdot l_i-1)$

- $\forall m<x\leq t,z\cdot(k-h)\geq -z+1+\sum\limits_{i=x+1}^{m}(-z\cdot r_i)$

- $\forall m<x<y\leq t,z\cdot k\geq -z+1+\sum\limits_{i=x+1}^{y}(-z\cdot r_i)$

- $\forall m<x<y\leq t,z\cdot k\geq -z+1+\sum\limits_{i=x+1}^{y}(z\cdot l_i-1)$

**省流：发现这个条件很像最大子段和状物，因此你类似小白逛公园地，单点修改并分别维护每个节点 $(z\cdot l_i-1)$ 和 $(-z\cdot r_i)$ 的和、最大前后缀和、最大子段和共八个变量即可。**

每次二分 $k$，用树状数组算出 $h$，线段树查询后缀可以做到 $O(n+q\log^2 n)$。我考场就写的这玩意，在 selfEval 上最大点 $1.6s$，感觉稳了，没再优化下去。

赛后重新写了一遍，发现其实可以直接线段树二分，因为信息的可加性很强，也显然有二分性。树状数组省去了，代码极短，加上我的快读板子也只有 $2.7K$，下面是我的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace file_read{
	char ib[1<<25],*ip1=ib,*ip2=ib;
	inline char gc(){
		return ((ip1==ip2&&(ip2=(ip1=ib)+fread(ib,1,1<<24,stdin))),ip1==ip2?EOF:*ip1++);
	}
	inline int read(){
		int x=0;char c=gc();
		while(c<'0'||c>'9')c=gc();
		while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^'0'),c=gc();
		return x;
	}
	char ob[1<<25],*op=ob;
	inline void pc(char c){
		*op++=c;
	}
	void write(int x){
		if(x>=10)write(x/10);
		pc(x%10+'0');
	}
	void final_write(){
		fwrite(ob,op-ob,1,stdout);
	}
}
using namespace file_read;
int cc,T,n,q,s[400005];
struct pear{
	int hl,hr,h;
	int qdr,hdr;
	int mx1,mx2;
	int qdl,hdl;
}pp;
pear operator+(pear a,pear b){
	pear c;
	c.hl=a.hl+b.hl,c.hr=a.hr+b.hr,c.h=a.h+b.h;
	c.hdr=max(b.hdr,a.hdr+b.hr);c.qdr=max(a.qdr,a.hr+b.qdr);
	c.mx2=max(max(a.mx2,b.mx2),a.hdr+b.qdr);
	c.hdl=max(b.hdl,a.hdl+b.hl);c.qdl=max(a.qdl,a.hl+b.qdl);
	c.mx1=max(max(a.mx1,b.mx1),a.hdl+b.qdl);
	return c;
}
struct apple{
	int t,L[100005],R[100005],K[100005];
	void jjj(int l,int r){
		int b=s[l]+(l<r&&s[r]),a=r-l+1-b;
		++t;L[t]=1-b,R[t]=a-1;K[t]=r;
	}
	pear sm[400005];
	void build(int l,int r,int o){
		if(l==r){
			sm[o].hl=3*L[l]-1,sm[o].hr=-3*R[l],sm[o].h=1-L[l];
			sm[o].qdr=sm[o].hr,sm[o].qdl=sm[o].hl;
			sm[o].hdr=max(0,sm[o].hr),sm[o].hdl=max(0,sm[o].hl);
			sm[o].mx1=sm[o].mx2=-1e9;
			return;
		}
		int mid=(l+r)>>1;
		build(l,mid,o<<1);build(mid+1,r,o<<1|1);
		sm[o]=sm[o<<1]+sm[o<<1|1];
	}
	void add(int l,int r,int o,int x){
		if(l==r){
			sm[o].hl=3*L[l]-1,sm[o].hr=-3*R[l],sm[o].h=1-L[l];
			sm[o].qdr=sm[o].hr,sm[o].qdl=sm[o].hl;
			sm[o].hdr=max(0,sm[o].hr),sm[o].hdl=max(0,sm[o].hl);
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid)add(l,mid,o<<1,x);
		else add(mid+1,r,o<<1|1,x);
		sm[o]=sm[o<<1]+sm[o<<1|1];
	}
	void jia(int x,int y){
		L[x]-=y;R[x]-=y;add(1,t,1,x);
	}
	void init(int a){
		t=0;jjj(1,a);
		for(int i=a+1,j;i<=n;j=min(n,i+1),jjj(i,j),i=j+1);
		build(1,t,1);
	}
	int query(int l,int r,int o){
		if(l==r)return K[l];
		pear qq=sm[o<<1|1]+pp;
		int mid=(l+r)>>1,k=K[mid],h=sm[1].h-qq.h;
		if(3*k<max(qq.mx1,qq.mx2)-2||3*h<qq.qdl-2||3*(k-h)<qq.qdr-2)
			return query(mid+1,r,o<<1|1);
		pp=qq;return query(l,mid,o<<1);
	}
	int suan(){
		pp.mx1=pp.mx2=-1e9;
		pp.hdl=pp.hdr=0;pp.qdl=pp.qdr=-1e9;
		pp.hl=pp.hr=pp.h=0;
		return query(1,t,1);
	}
}e0,e1;
void solve(){
	write(min(e0.suan(),e1.suan()));
}
int main(){
	cc=read(),T=read();
	while(T--){
		n=read(),q=read();
		for(int i=1;i<=n;++i){
			char c2=gc();
			while(c2<'0'||c2>'9')c2=gc();
			s[i]=c2-'0';
		}
		e0.init(2);e1.init(1);solve();
		while(q--){
			int x=read(),aa=(s[x]^1)-s[x];s[x]^=1;
			e0.jia((x+1)/2,aa);e1.jia(x/2+1,aa);
			pc(' ');solve();
		}
		pc('\n');
	}
	final_write();
	return 0;
}
```

**省流：这题做完了。**

接下来考虑加强，从几个方向考虑：

- $3$ 显然可以改成任何数，一点区别都没有。

- 复杂度是单 $\log$ 的，因此可以加强到 $\sum n\leq 5\times 10^6,\sum q\leq 1\times 10^6$。

- 单点修改改为区间修改，应该存在一些分块做法。

作者码字不易，花费很多心血，留个赞再走吧，谢谢！有错误请尽情指出，感激不尽！

---

## 作者：Miraik (赞：1)

#define 龙胆 使用特殊技能

首先由于摸牌一次摸两张，我们不妨区分一下奇偶性，再把牌两个两个分组再做。

考虑暴力怎么做。答案显然满足可二分性，考虑先二分一个答案 $k$。接下来我们宣称 $c0_i,c1_i$ 分别表示前 $i$ 组牌中 0 / 1（攻击牌/防御牌）的个数。

然后我们考虑动态维护两个数组 $L_i,R_i$，分别表示处理到第 $i$ 组牌时，至少需要使用 $L_i$ 次龙胆，且目前至多可以使用 $R_i$ 次龙胆。

对于 $L_i$，我们容易知道有 $L_i=\max(L_{i-1},(i-k)-c1_i)$。

对于 $R_i$，如果我们不管龙胆三轮只能发动一次的限制，就有 $R_i=c0_i-(i-k)$。

接下来我们说明，对于考虑龙胆三轮只能发动一次的限制下，我们有 $R_i=\min(R_{i-3}+1,R_{i-2}+1,R_{i-1}+1,c0_i-(i-k))$。

1. 首先由于三轮至多发动一次，我们有限制 $R_i \le R_{i-3}+1$。

2. 但是光靠 1. 的限制是不足够的，因为 $i-2,i-1$ 两个位置的 $c0_*-(*-k)$ 如果很小，依然会给 $R_i$ 造成限制，也就是 $R_i \le R_{i-2}+1,R_i \le R_{i-1}+1$。

这里看起来有点问题，直接用 $R_{*}+1$ 更新，如果 $*$ 在 $R_*$ 所处方案中使用了龙胆，不是就不满足三轮才能使用一次的限制了？

但是注意到只有 $R_{*}<R_{i-3}$ 时这次更新才是有意义的，而此时由于在处理完前 $i-3$ 组牌时一定可以做到已经使用掉 $R_{*}$ 次龙胆，因此直接用 $R_{*}+1$ 更新是合法的。

如果想要求 $R_i$ 对应的方案也是容易的，从 $i$ 开始向前做一遍后缀 $\min$ 后必然满足 $R_i \le R_{i-3}+1,R_{i-1} \le R_i$，可以直接递推构造。至此我们说明了该做法的正确性。

求解出 $L,R$ 后，如果存在 $L_i>R_i$，当前答案 $k$ 就不合法。

这样我们就得到了一个 $O(nq \log n)$ 的暴力，可以通过 40 分。

然后~~根据大样例~~我们有一个小观察是答案的变化量是 $O(1)$ 的，~~把大样例检测一遍~~可以发现这个变化量不超过 $6$，于是我们无需每次二分，每一次可以从上一次的答案暴力向左右 check 拓展。现在的暴力就变成 $O(nq)$ 了，~~依然只能通过 40 分~~。

接下来考虑怎么优化上面这个暴力好了。

其实可以发现，如果我们不考虑龙胆三轮发动一次的限制，其实我们的判断就是查询是否 $\exist i\le j,L_i>R_j$，其中 $L_i=(i-k)-c1_i,R_j=c0_j-(j-k)$。

那么化一下式子，就是 $i+j-c1_i-c0_j>2k$。

这很好用线段树维护啊！节点内维护一下 $\max\{i-c1_i\},\max\{i-c0_i\}$，这个就很好判定了！

~~然后你直接对于大数据这么做就能通过 AC AD E 三个特殊性质获得 75 分，非常神秘。~~

那现在加上三轮一次的限制，怎么办呢。

其实容易注意到，这个限制带来了 $R_j \to R_i(j<i)$ 的传递关系，也就是 $R_j+\lceil \frac{i-j}{3} \rceil \to R_i$。

换言之，我们只需要额外查询是否 $\exist i>j,L_i>R_j+\lceil \frac{i-j}{3} \rceil$。

这其实也是简单的，在线段树里额外维护 $i \bmod 3=0/1/2$ 时 $\max\{i-c1_i-\lfloor \frac{i}{3} \rfloor\},\max\{i-c0_i+\lfloor \frac{i}{3} \rfloor\}$ 最大值即可。

每次单点修改对于 $c0,c1$ 都是一个后缀 $\pm 1$ 的操作，线段树可以直接维护。

实际实现的时候要注意一点边界情况，考虑一下最前面 $L_k=R_k=0$ 之类的边界对答案的影响。

那么这道题就做完了，总复杂度就是 $O(n+ q \log n)$。不过常数并不小。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
const int inf=1000000005;
int tid,tc,n,Q,m,a[N],c[N][2],chg[N],ans[N]; string S;
namespace sgt{
  #define ls(x) (x<<1)
  #define rs(x) (x<<1|1)
  struct Node{ int x,y,xx[3],yy[3],res,tag; }t[N<<2];
  inline Node pu(Node a,Node b){
    Node c;
    c.x=max(a.x,b.x);
    c.y=max(a.y,b.y);
    for(int i=0;i<3;i++) c.xx[i]=max(a.xx[i],b.xx[i]),c.yy[i]=max(a.yy[i],b.yy[i]);
    c.res=max({a.res,b.res,a.x+b.y});
    for(int i=0;i<3;i++) for(int j=0;j<3;j++) c.res=max(c.res,a.yy[i]+b.xx[j]-(j-i+2)/3);
    c.tag=0;
    return c;
  }
  inline void build(int u,int l,int r){
    if(l==r){
      t[u].x=l-c[l][1];
      t[u].y=l-c[l][0];
      t[u].xx[0]=t[u].xx[1]=t[u].xx[2]=t[u].yy[0]=t[u].yy[1]=t[u].yy[2]=-inf;
      t[u].xx[l%3]=t[u].x-(l/3); t[u].yy[l%3]=t[u].y+(l/3);
      t[u].res=t[u].x+t[u].y;
      t[u].tag=0;
      return;
    } int mid=l+r>>1;
    build(ls(u),l,mid); build(rs(u),mid+1,r);
    t[u]=pu(t[ls(u)],t[rs(u)]);
  }
  inline void lzy(int u,int x){
    t[u].x+=x; t[u].y-=x; t[u].tag+=x;
    for(int i=0;i<3;i++) t[u].xx[i]+=x,t[u].yy[i]-=x;
  }
  inline void pd(int u){ if(t[u].tag) lzy(ls(u),t[u].tag),lzy(rs(u),t[u].tag),t[u].tag=0; }
  inline void upd(int u,int l,int r,int ql,int x){
    if(l>=ql) return lzy(u,x);
    int mid=l+r>>1; pd(u);
    if(ql<=mid) upd(ls(u),l,mid,ql,x),lzy(rs(u),x);
    else upd(rs(u),mid+1,r,ql,x);
    t[u]=pu(t[ls(u)],t[rs(u)]);
  }
  inline Node ask(int u,int l,int r,int ql){
    if(l>=ql) return t[u];
    int mid=l+r>>1; pd(u);
    if(ql>mid) return ask(rs(u),mid+1,r,ql);
    return pu(ask(ls(u),l,mid,ql),t[rs(u)]); 
  }
}
inline int chk(int k){
  sgt::Node tmp=sgt::ask(1,1,m,k+1);
  for(int i=0;i<3;i++) if(tmp.xx[i]+k/3-(i-k%3+2)/3>k) return 0;
  if(tmp.y>k||tmp.res>2*k) return 0;
  return 1;
}
inline int calc(int lst){
  int l=1,r=m-1,p=m;
  if(~lst){
    if(lst==m||chk(lst)){ p=lst; while(p>1&&chk(p-1)) p--; return p; }
    else{ p=lst+1; while(p<m&&!chk(p)) p++; return p;}
  }
  while(l<=r){
    int mid=l+r>>1;
    if(chk(mid)) p=mid,r=mid-1;
    else l=mid+1; 
  }
  return p;
}
inline void work(int o){
  m=n+1+o>>1;
  for(int i=1;i<=m;i++) c[i][0]=c[i][1]=0;
  for(int i=1;i<=n;i++) c[i+1+o>>1][a[i]]++;
  for(int i=1;i<=m;i++) c[i][0]+=c[i-1][0],c[i][1]+=c[i-1][1];
  sgt::build(1,1,m);
  for(int i=0,lst=-1;i<=Q;i++){
    if(i){
      if(a[chg[i]]) sgt::upd(1,1,m,chg[i]+1+o>>1,1);
      else sgt::upd(1,1,m,chg[i]+1+o>>1,-1);
      a[chg[i]]^=1;
    }
    lst=calc(lst);
    ans[i]=min(ans[i],lst*2-o);
  }
  for(int i=1;i<=Q;i++) a[chg[i]]^=1;
}
inline void Solve(){
  cin>>n>>Q>>S; S='#'+S;
  for(int i=1;i<=n;i++) a[i]=S[i]^'0';
  for(int i=1;i<=Q;i++) cin>>chg[i];
  for(int i=0;i<=Q;i++) ans[i]=n;
  work(0); work(1);
  for(int i=0;i<=Q;i++) cout<<ans[i]<<(i==Q?'\n':' ');
}
int main(){
    freopen("defense.in","r",stdin);
    freopen("defense.out","w",stdout);
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>tid>>tc; while(tc--) Solve();
	return 0;
}
```

---


# [CEOI 2025] Splits

## 题目描述

对于一个长度为 $n$ 的排列 $p = p[0], p[1], p[2], \ldots, p[n - 1]$（包含数字 $1, 2, 3, \ldots, n$ 的一个全排列），我们定义**分割排列**（split）为一个排列 $q$，它可以通过以下过程得到：

1. 选择两个数集  
   $A = i_1, i_2, \ldots, i_k$  
   $B = j_1, j_2, \ldots, j_l$  
   满足：
   - $A \cap B = \emptyset$
   - $A \cup B = \{0, 1, 2, \ldots, n - 1\}$
   - $i_1 < i_2 < \ldots < i_k$
   - $j_1 < j_2 < \ldots < j_l$
2. 将 $q$ 定义为：
   $$
   q = p[i_1]\, p[i_2] \ldots p[i_k]\, p[j_1]\, p[j_2] \ldots p[j_l]
   $$

进一步，我们定义 $S(p)$ 为排列 $p$ 的所有分割排列的集合。

现在，给定一个整数 $n$ 和一个集合 $T$，其中包含 $m$ 个长度为 $n$ 的排列。要求统计有多少个长度为 $n$ 的排列 $p$ 满足 $T \subseteq S(p)$。由于答案可能很大，请将结果对 $998\,244\,353$ 取模。

### 实现细节

你需要实现以下函数：

```cpp
int solve(int n, int m, std::vector<std::vector<int>>& splits);
```

* $n$：排列的长度
* $m$：给定的分割排列数量
* `splits`：包含 $m$ 个两两不同的排列，表示集合 $T$，该集合是某个 $p$ 的 $S(p)$ 的子集

该过程应返回满足条件的排列数量，结果对 $998\,244\,353$ 取模。该过程在每个测试用例中仅调用一次。

## 说明/提示

### 样例解释 1

考虑以下调用：

```cpp
solve(3, 2, {{1, 2, 3}, {2, 1, 3}})
```

在此例中，排列 $p$ 的长度为 $3$，给定的分割排列有：

* $123$
* $213$

只有以下 $4$ 个排列 $p$ 可以同时生成这两个分割排列：

* $123$
* $132$
* $213$
* $231$

因此答案为 $4$。

### 数据范围

* $1 \leq n \leq 300$
* $1 \leq m \leq 300$

### 子任务

1. （6 分）$m = 1$
2. （7 分）$1 \leq n, m \leq 10$
3. （17 分）$1 \leq n, m \leq 18$
4. （17 分）$1 \leq n \leq 30,\ 1 \leq m \leq 15$
5. （16 分）$1 \leq n, m \leq 90$
6. （16 分）$1 \leq n \leq 300,\ 1 \leq m \leq 15$
7. （21 分）无额外限制

---

翻译由 ChatGPT-5 完成

## 样例 #1

### 输入

```
3 2
1 2 3
2 1 3```

### 输出

```
4```

# 题解

## 作者：min_inf (赞：1)

纯纯意义不明弱智题，但是严肃被通信正义击杀了。

从 $T$ 中随便拿一个排列 $q$，考虑设 $f_{i,j,k}$ 表示 $q$ 只考虑 $[i,j]$ 和 $[k,n]$ 的方案数，转移就是拓展 $i-1$ 或者 $k-1$，然后在其他 $T$ 中元素中这些数对应位置也需要一直维持类似的结构。但是可能出现在某个 $T$ 中的排列中这些数对应的位置糊成了一个区间，你不知道中间有没有分界点，所以要想办法让只有一个区间的情况必定没有分界点。

考虑一个东西：直接爆搜 $p$，确定一个数的时候，当前确定的数不是某个排列的前缀那就可以立刻确定这个排列的分界点。如果所有分界点都确定了，每个排列分界点后面的数已经被选上了，不会出现上面说的两个区间糊成一坨的情况，上面的 DP 就是可行的了。

而这个爆搜其实只有 $O(n^2+nm)$，因为你相当于在这些排列构成的 trie 树上 DFS，然后如果当前节点不是所有排列的前缀显然只有最多两种选择。

然后考虑 DP 的部分，考虑什么转移是合法的。对于一个排列，设已有的数对应位置是 $S$，新加入的数在 $x$。首先 $x-1\notin S$，不然就糊成一坨了。然后如果 $S$ 不构成一个区间，那需要 $x+1\in S$。直接判断能得到 $O(n^4m)$ 之类的复杂度的做法，但是可以无压力通过 sub6。[code](https://qoj.ac/submission/1230713)

剩下的就是怎么优化这个判断了。考虑 bitset 维护出符合条件的排列集合。$x-1\notin S$ 维护一个 $s_{i,j}$ 表示 $i$ 的位置 $\le j$ 的排列个数之类的就行。$x+1\in S$ 维护一个 $bs_{i,j}$ 表示 $i$ 的位置 $\ge j$ 的排列集合，$S$ 是一个区间的情况就枚举一个排列的一个区间，如果它在我们 DP 的那个排列上是 $[i,j]\cup[k,n]$ 的结构就塞进这个状态的 bitset。

时间复杂度 $O(\frac{n^3m}w)$，常数很小。[code](https://qoj.ac/submission/1230857)

---


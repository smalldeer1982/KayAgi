# 拯救世界2

## 题目背景

前三题太弱了嘛，在看看最后一道渣题。


## 题目描述

经过 12 年的韬光养晦，世界末日再次来临（众人：什么鬼逻辑......）。

这次，小a 和 uim 已经做好了一切准备，顺利召唤出了 kkksc03 大神和 lzn 大神。然而，kkksc03 和 lzn 告诉他们，这次世界末日太过强大，他们已无法挽回，只有创世神 JOHNKRAM 能拯救这个世界。

然而，创世神 JOHNKRAM 是无法召唤的，除非把整个宇宙按照 $E=mc^2$ 全部转化成能量。因为根据 C\_SUNSHINE 大神随手推算出的召唤定律，至少需要被召唤者百万亿分之一的能量才能召唤（众人：什么鬼定律......）。
****
当然，还有一种方法，那就是找出创世神 JOHNKRAM 的基因序列。普通人基因序列由 A、C、G、T 构成，创世神 JOHNKRAM 不是普通人（是个胖纸），基因序列也不一样。除了这四种普通的，还有乾、兑、离、震、巽、坎、艮、坤八种特殊基因。其中乾、坎、艮、震属阳，只能出现奇数次；坤、兑、离、巽属阴，只能出现偶数次。

现在只知道创世神 JOHNKRAM 的基因序列共有 $n$ 位，其他一概不知。小a 和 uim 想知道他们最多要试多少次，才能召唤出创世神 JOHNKRAM 。这个数字有可能很大，所以输出答案模 $10^9$ 即可（C\_SUNSHINE 的忠告：远离八卦，远离肥胖）。

## 说明/提示

【数据范围】     
对于 $10\%$ 的数据：$1\le n < 25$，数据不超过 $10$ 组；  
对于 $50\%$ 的数据：$1\le n < 2^{31}$，数据不超过 $10^3$ 组；   
对于 $100\%$ 的数据：$1\le n < 2^{63}$，数据不超过 $2\times 10^5$ 组。

【样例解释】  
第一个数据解释：  
只有 $3$ 位，没有合法方案，故答案为 $0$。

【备注】

附件：聊天记录（纯粹扯淡）

JOHNKRAM 8:50:33

喂喂，坑神之赛2可以开始了吧

C_SUNSHINE 8:50:34

[自动回复]恩！

JOHNKRAM 8:51:12

我准备把最后一题数据从 $50$ 放到 $2^{63}$。

C_SUNSHINE 8:51:12

[自动回复]恩！

JOHNKRAM 8:51:45

你同意喽？

C_SUNSHINE 8:51:46

[自动回复]恩！

C_SUNSHINE 11:58:50

你疯了吗？！

JOHNKRAM 11:58:52

[自动回复]您好，我现在有事不在，一会再和您联系。 不再提醒

## 样例 #1

### 输入

```
3
10
20
6
0```

### 输出

```
0
225116160
53238784
7680
```

# 题解

## 作者：NaCly_Fish (赞：39)

想必来做这题的人都做过 [P2000 拯救世界](https://www.luogu.org/problem/P2012) 吧。  
在那题中，方案都是无序的，所以用普通生成函数解决。
而在这题中是有序的，这时就要使用指数型生成函数(EGF)。

有一个数列 $a$，其 EGF 就是：
$$ \sum\limits_{i=0}^\infty \frac{x^i}{i!}a_i$$
那么我们根据题目中的三种基因，可以列出它们的 EGF：
$$ f(x)=\sum\limits_{i=0}^\infty \frac{x^i}{i!}=\text e^x$$  
$$ g(x)=\sum\limits_{i=0}^\infty \frac{x^{2i}}{(2i)!}=\frac12(\text e^x+ \text e^{-x})$$
$$ h(x)=\sum\limits_{i=0}^\infty \frac{x^{2i+1}}{(2i+1)!}=\frac12(\text e^x-\text e^{-x})$$
****
和 P2000 那题一样，答案的 EGF 就是把它们都乘起来
$$ A(x)=(f(x)g(x)h(x))^4$$
$$ =(\frac14e^x(\text e^{2x}-\text e^{-2x}))^4$$
$$ =(\frac14(\text e^{3x}-\text e^{-x}))^4$$
$$ =\frac{1}{256}(\text e^{12x}-4\text e^{8x}+6\text  e^{4x}-4+\text e^{-4x})$$
****
那么答案就是取其 $n$ 次项系数，不过要注意乘个 $n!$
$$\text{ans}=n![x^n]A(x)$$
$$=\frac{n!}{256}(\frac{12^n}{n!}-\frac{4\times8^n}{n!}+\frac{6\times4^n}{n!}+\frac{(-4)^n}{n!})$$
$$= \frac{1}{256}(12^n-4\times8^n+6\times4^n+(-4)^n)$$
这样就可以计算了，，

不过要注意的是 $256$ 在模 $10^9$ 下没有逆元，所以在 $n$ 较小的时候直接暴力，否则答案就是  
$$81\times12^{n-4}-8^{n-2}+6\times4^{n-4}+(-4)^{n-4}$$
直接快速幂就能解决。  

但是这题极度卡常，要用一个小小的优化。  
根据扩展欧拉定理： 
$$ a^{b} \equiv \left\{\begin{aligned} a^{b\text{ mod }φ(m)+φ(m)}\space(b\geφ(m)) \\ a^b\space(b<φ(m))\end{aligned}\right.(\text{mod }m)$$
$φ(10^9)=4\times10^8$，所以只要 $n\ge4\times10^8$ 就对其取模再加上去就好了。

可以稍微预处理一下，每组数据时间复杂度为 $\Theta(1)$

Code:
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define reg register
#define ll long long
#define p 1000000000
#define phi 400000000
using namespace std;

int table[8] = {0,0,0,0,24,480,7680,107520};
int pw1[32769],pw2[32769],pw3[32769],pw4[32769];

inline int solve(const int& n){
    reg int x = (ll)pw1[n&32767]*pw2[n>>15]%p,y = (ll)x*x%p;
    reg int res = (81ll*pw3[n&32767]%p*pw4[n>>15]%p-64ll*x%p*y)%p;
    res = (res+6ll*y+p)%p;
    return (n&1)?(res<y?res-y+p:res-y):(res+y>=p?res+y-p:res+y);
}

int main(){
    pw1[0] = pw2[0] = pw3[0] = pw4[0] = 1;
    pw1[1] = 2;
    for(reg int i=2;i<=32768;++i) pw1[i] = pw1[i-1]<500000000?(pw1[i-1]<<1):(pw1[i-1]<<1)-p;
    pw2[1] = pw1[32768];
    for(reg int i=2;i<=32768;++i) pw2[i] = (ll)pw2[i-1]*pw2[1]%p;
    pw3[1] = 12;
    for(reg int i=2;i<=32768;++i) pw3[i] = (ll)pw3[i-1]*12%p;
    pw4[1] = pw3[32768];
    for(reg int i=2;i<=32768;++i) pw4[i] = (ll)pw4[i-1]*pw4[1]%p;
    reg ll n;
    reg int x;
    while(cin>>n){
    	if(n==0) break;
        x = n>=phi?n%phi+phi:n;
        printf("%d\n",x<8?table[x]:solve(x-4));
    }
}
```

---

## 作者：0x3F (赞：34)

# 算法零

打暴力，时间复杂度 $\Theta(T \times 12^n) \approx \Theta(10^{10^{19}})$。

# 算法一

状压 $\texttt{DP}$，$dp_{i, stat}$ 表示长度为 $i$，八种特殊基因的奇偶性状态为 $stat$，最终答案为 $dp_{n, 00001111}$。

转移方程为 $dp_{i, stat} = 4 \times dp_{i-1, stat} + \sum\limits_{i=0}^{7} dp_{i-1, stat\texttt{改变任意一位后的值}}$，初始状态为 $dp_{0, 00000000} = 1$。

时间复杂度为 $\Theta(8 \times 256 \times n) \approx \Theta(1.9 \times 10^{22})$。

## 优化

显然 $dp_{i, 00001111}$ 和 $dp_{i, 11110000}$ 是相等的，也就是说 $dp_{i, stat}$ 的值只取决于 $stat$ 中 $1$ 的个数。

令 $dp_{i, j}$ 表示原先 $dp_{i, stat}$ （$stat$ 中恰好有 $j$ 个 $1$）的值。

注意啦！这里 $dp_{i, 1}$ 就是 $dp_{i, 00000001}$，也等于 $dp_{i, 00000010}$，也等于 $dp_{i, 00000100} \cdots dp_{i, 10000000}$，而不是它们的和。

首先考虑 $j$ 等于 $0$ 的情况。

也就是全是 $0$，是如何推得的呢？

只有两种可能性：一是上一次就全是 $0$；二是上一次有一个 $1$ ，但是被去掉了。

上一次全是 $0$，所以使用四种普通基因，要乘以 $4$。

上一次有一个 $1$，这个 $1$ 的位置有八种可能性，要乘以 $8$。

也就是说 $dp_{i, 0} = 4dp_{i-1, 0} + 8dp_{i-1,1}$。

然后考虑 $j$ 等于 $1$。

也就是原先的 $dp_{i, 00000001}$。

有三种可能性：一是上一次就是这个状态；二是上一次有两个 $1$ ，但是去掉了一个；三是上一次一个 $1$ 也没有，但是加上了一个。

上一次全是 $0$，所以还是使用四种普通基因，要乘以 $4$。

上一次有两个 $1$，被去掉的 $1$ 的位置放在现在 $0$ 的位置，有七个，要乘以 $7$。

上一次一个 $1$ 也没有，只能加在现在的位置，乘以 $1$。

也就是说 $dp_{i, 1} = 4dp_{i-1, 1} + 7dp_{i-1,2} + dp_{i-1,0}$。

同理可得：

$$dp_{i, 2} = 4dp_{i-1, 2} + 6dp_{i-1, 3} + 2dp_{i-1, 1}$$

$$dp_{i, 3} = 4dp_{i-1, 3} + 5dp_{i-1, 4} + 3dp_{i-1, 2}$$

$$dp_{i, 4} = 4dp_{i-1, 4} + 4dp_{i-1, 5} + 4dp_{i-1, 3}$$

$$\huge{\cdots}$$

$$dp_{i, 8} = 4dp_{i-1, 8} + 8dp_{i-1, 7}$$

初始状态为 $dp_{0, 0} = 1$。

最终答案为 $dp_{n, 4}$。

时间复杂度 $\Theta(25 \times n) \approx \Theta(2.3 \times 10^{20})$。

# 算法二

看到算法一优化的 $\texttt{DP}$ 方程，你有没有想到什么东西？

对啦！矩阵加速。

把转移方程写成矩阵的形式，你会看到一个甚为壮观的转移矩阵：

$$\left[\begin{matrix}dp_{i, 0}\\dp_{i, 1}\\dp_{i, 2}\\dp_{i, 3}\\dp_{i, 4}\\dp_{i, 5}\\dp_{i, 6}\\dp_{i, 7}\\dp_{i, 8}\end{matrix}\right] = \left[\begin{matrix}4\;8\;0\;0\;0\;0\;0\;0\;0\\1\;4\;7\;0\;0\;0\;0\;0\;0\\0\;2\;4\;6\;0\;0\;0\;0\;0\\0\;0\;3\;4\;5\;0\;0\;0\;0\\0\;0\;0\;4\;4\;4\;0\;0\;0\\0\;0\;0\;0\;5\;4\;3\;0\;0\\0\;0\;0\;0\;0\;6\;4\;2\;0\\0\;0\;0\;0\;0\;0\;7\;4\;1\\0\;0\;0\;0\;0\;0\;0\;8\;4\end{matrix}\right] \times \left[\begin{matrix}dp_{i-1, 0}\\dp_{i-1, 1}\\dp_{i-1, 2}\\dp_{i-1, 3}\\dp_{i-1, 4}\\dp_{i-1, 5}\\dp_{i-1, 6}\\dp_{i-1, 7}\\dp_{i-1, 8}\end{matrix}\right]$$

于是答案就是

$$\left[\begin{matrix}4\;8\;0\;0\;0\;0\;0\;0\;0\\1\;4\;7\;0\;0\;0\;0\;0\;0\\0\;2\;4\;6\;0\;0\;0\;0\;0\\0\;0\;3\;4\;5\;0\;0\;0\;0\\0\;0\;0\;4\;4\;4\;0\;0\;0\\0\;0\;0\;0\;5\;4\;3\;0\;0\\0\;0\;0\;0\;0\;6\;4\;2\;0\\0\;0\;0\;0\;0\;0\;7\;4\;1\\0\;0\;0\;0\;0\;0\;0\;8\;4\end{matrix}\right] ^n \times\left[\begin{matrix}1\\0\\0\\0\\0\\0\\0\\0\\0\end{matrix}\right]$$

的第五个元素。（下标为4）

时间复杂度 $\Theta(T \times \log n \times 9^3) \approx \Theta(9.2 \times 10^9)$。

似乎看到了希望的曙光？

## 优化一

矩阵光速幂。

众所周知，普通光速幂是把指数分拆。

比如：$a^{114514} = a^{11 \times 10^4 + 4514} = (a^{10^4})^{11} \times a^{4514}$

但是这里太大，分拆了也没用。

但是为什么一定要分拆成两个呢？

比如：$a^{998244353} = a^{998 \times 10^6 + 244 \times 10^3 + 353} = (a^{10^6})^{998} \times (a^{10^3})^{244} \times a^{353}$

这样虽然要三次相乘，但是需要预处理的东西也少了。

我正是使用了这一方法。

我只需要预处理：

$$\left[\,\cdots\right]^{(0,1,\cdots,2^{16}-1)},$$

$$\left[\,\cdots\right]^{(2^{16}, 2^{17}, \cdots, 2^{32}-2^{16})},$$

$$\left[\,\cdots\right]^{(2^{32}, 2^{33}, \cdots, 2^{48}-2^{32})},$$

$$\left[\,\cdots\right]^{(2^{48}, 2^{49}, \cdots, 2^{63}-2^{48})}$$

即可。

$n$ 不是 $2^{63}$ 吗？把它二进制分为四段，$0\sim15$ 位，$16\sim32$ 位，$33\sim48$ 位，以及 $49\sim63$ 位。

也就是分解为 $n_1\times2^{48}+n_2\times2^{32}+n_3\times2^{16}+n_4$。

把他们分别对应的四个矩阵相乘，再乘以初始矩阵，即可。

答案就是：

$$\Big(\left[\,\cdots\right]^{2^{48}}\Big)^{n_1} \times \Big(\left[\,\cdots\right]^{2^{32}}\Big)^{n_2} \times \Big(\left[\,\cdots\right]^{2^{16}}\Big)^{n_3} \times \left[\,\cdots\right]^{n_4} \times \left[\begin{matrix}1\\0\\\vdots\\0\end{matrix}\right]$$

的第 $5$ 行。（实际下标为 $4$）

预处理 $\Theta(9^3\times(2^{16}\times3+2^{15})) \approx\Theta(1.7\times10^8)$，单次询问 $\Theta(9^3\times3)=\Theta(2187)$，总时间复杂度 $\Theta(6.0 \times 10^8)$。

是不是胜利就在眼前？

## 优化二

仔细动脑筋想想，

$$\left[\begin{matrix}a_{0,0}\quad a_{0,1} \cdots a_{0,8}\\a_{1,0}\quad a_{1,1}\cdots a_{1,8}\\\vdots\qquad\vdots\ \ \ddots\ \ \vdots\\a_{8,0}\quad a_{8,1}\cdots a_{8,8}\end{matrix}\right] \times \left[\begin{matrix}1\\0\\\vdots\\0\end{matrix}\right]$$

的第 $5$ 行和

$$\left[\begin{matrix}a_{0,0}\quad a_{0,1} \cdots a_{0,8}\\a_{1,0}\quad a_{1,1}\cdots a_{1,8}\\\vdots\qquad\vdots\ \ \ddots\ \ \vdots\\a_{8,0}\quad a_{8,1}\cdots a_{8,8}\end{matrix}\right]$$

的第 $5$ 行第 $1$ 列是不是没有区别？

于是答案又变成了：

$$\Big(\left[\,\cdots\right]^{2^{48}}\Big)^{n_1} \times \Big(\left[\,\cdots\right]^{2^{32}}\Big)^{n_2} \times \Big(\left[\,\cdots\right]^{2^{16}}\Big)^{n_3} \times \left[\,\cdots\right]^{n_4}$$

的第 $5$ 行第 $1$ 列。

再想想，我们不需要求它们的乘积，我们只要求它们乘积的某一固定位置的值！

假设四个矩阵分别是 $A,B,C,D$，

根据矩阵乘法的性质，答案应为：

$$\sum_{i=0}^{8}\sum_{j=0}^{8}\sum_{k=0}^{8}A_{4,i}B_{i,j}C_{j,k}D_{k,0}$$

但是这样还是要超时，可以每次锁定 $j$，然后提一下公因式。也就是：

$$\sum_{j=0}^{8}[\sum_{i=0}^{8}(A_{4,i}B_{i,j})\times\sum_{k=0}^{8}(C_{j,k}D_{k,0})]$$

于是乎单词询问 $\Theta(2187)\rightarrow\Theta(162)$。

总时间复杂度 $\Theta(9^3\times(2^{16}\times3+2^{15})+162\times2\times10^5)\approx\Theta(2.0\times10^8)$

## 优化三

卡常数即可。

卡常数注意事项：

1. 取模非常慢，尽可能减少取模次数。
（主要是预处理时，询问时由于计算本身就少，就无所谓了）

1. 用 `register`。

不开 $\texttt{O2}$ 不用 `register` 最大的一个点 $\texttt{800ms}$，用了 `register` $\texttt{650ms}$，开了 $\texttt{O2}$ 只要 $\texttt{250ms}$！还是有很大的余地的。

见代码：

```cpp
#include <cstdio>
#define mod 1000000000
const int mat[9][9] = 
{{4, 8, 0, 0, 0, 0, 0, 0, 0},
 {1, 4, 7, 0, 0, 0, 0, 0, 0},
 {0, 2, 4, 6, 0, 0, 0, 0, 0},
 {0, 0, 3, 4, 5, 0, 0, 0, 0},
 {0, 0, 0, 4, 4, 4, 0, 0, 0},
 {0, 0, 0, 0, 5, 4, 3, 0, 0},
 {0, 0, 0, 0, 0, 6, 4, 2, 0},
 {0, 0, 0, 0, 0, 0, 7, 4, 1},
 {0, 0, 0, 0, 0, 0, 0, 8, 4}};
int pow0[65536][9][9];
int pow1[65536][9][9];
int pow2[65536][9][9];
int pow3[32768][9][9];
long long t;
int x0, x1, x2, x3;
int main() {
	register int i, x, y, z, tmp1, tmp2, ans;
	register long long tmp;
	for (x = 0; x <= 8; x++) {
		for (y = 0; y <= 8; y++) {
			pow0[0][x][y] = pow1[0][x][y] = pow2[0][x][y] = pow3[0][x][y] = (x == y);
			pow0[1][x][y] = mat[x][y];
		}
	}
	for (i = 2; i <= 65535; i++) {
		for (x = 0; x <= 8; x++) {
			for (y = 0; y <= 8; y++) {
				tmp = 0;
				for (z = 0; z <= 8; z++) {
					tmp += (long long)pow0[i-1][x][z] * pow0[1][z][y];
				}
				pow0[i][x][y] = tmp % mod;
			}
		}
	}
	for (x = 0; x <= 8; x++) {
		for (y = 0; y <= 8; y++) {
			tmp = 0;
			for (z = 0; z <= 8; z++) {
				tmp += (long long)pow0[65535][x][z] * pow0[1][z][y];
			}
			pow1[1][x][y] = tmp % mod;
		}
	}
	for (i = 2; i <= 65535; i++) {
		for (x = 0; x <= 8; x++) {
			for (y = 0; y <= 8; y++) {
				tmp = 0;
				for (z = 0; z <= 8; z++) {
					tmp += (long long)pow1[i-1][x][z] * pow1[1][z][y];
				}
				pow1[i][x][y] = tmp % mod;
			}
		}
	}
	for (x = 0; x <= 8; x++) {
		for (y = 0; y <= 8; y++) {
			tmp = 0;
			for (z = 0; z <= 8; z++) {
				tmp += (long long)pow1[65535][x][z] * pow1[1][z][y];
			}
			pow2[1][x][y] = tmp % mod;
		}
	}
	for (i = 2; i <= 65535; i++) {
		for (x = 0; x <= 8; x++) {
			for (y = 0; y <= 8; y++) {
				tmp = 0;
				for (z = 0; z <= 8; z++) {
					tmp += (long long)pow2[i-1][x][z] * pow2[1][z][y];
				}
				pow2[i][x][y] = tmp % mod;
			}
		}
	}
	for (x = 0; x <= 8; x++) {
		for (y = 0; y <= 8; y++) {
			tmp = 0;
			for (z = 0; z <= 8; z++) {
				tmp += (long long)pow2[65535][x][z] * pow2[1][z][y];
			}
			pow3[1][x][y] = tmp % mod;
		}
	}
	for (i = 2; i <= 32767; i++) {
		for (x = 0; x <= 8; x++) {
			for (y = 0; y <= 8; y++) {
				tmp = 0;
				for (z = 0; z <= 8; z++) {
					tmp += (long long)pow3[i-1][x][z] * pow3[1][z][y];
				}
				pow3[i][x][y] = tmp % mod;
			}
		}
	}
	while (1) {
		scanf("%lld", &t);
		if (!t) return 0;
		x0 = (t & 65535ll);
		x1 = ((t >> 16ll) & 65535ll);
		x2 = ((t >> 32ll) & 65535ll);
		x3 = ((t >> 48ll) & 32767ll);
		ans = 0;
		for (y = 0; y <= 8; y++) {
			tmp1 = tmp2 = 0;
			for (x = 0; x <= 8; x++) tmp1 = ((long long)pow0[x0][4][x] * pow1[x1][x][y] + tmp1) % mod;
			for (x = 0; x <= 8; x++) tmp2 = ((long long)pow2[x2][y][x] * pow3[x3][x][0] + tmp2) % mod;
			ans = ((long long)tmp1 * tmp2 + ans) % mod;
		}
		printf("%d\n", ans);
	}
}
```


---

## 作者：esquigybcu (赞：20)

我目前看到的所有题解都差不多利用了$EGF$,类似这样：

$EGF_{ACGT}(x)=e^{4x}$

$EGF_{YIN}(x)=\left(\dfrac{e^x+e^{-x}}{2}\right)^4$

$EGF_{YANG}(x)=\left(\dfrac{e^x-e^{-x}}{2}\right)^4$

$EGF(x)=EGF_{ACGT}(x)EGF_{YIN}(x)EGF_{YANG}(x)$

$=\left(\dfrac{1}{4}e^x\left(e^{2x}-e^{-2x}\right)\right)^4$

$=\dfrac{1}{256}\left(e^{12x}-4e^{8x}+6e^{4x}-4+e^{-4x}\right)$

$\therefore a_n=n!EGF^{(n)}(0)=\dfrac{1}{256}\left(12^n-4\cdot8^n+6\cdot4^n+(-4)^n\right)$

那很多不懂$EGF$的小朋友就要问了：

__$EGF$到底是啥呢？__

*简单地*来说，对于一个数列$a_n(n\in\mathbb{N})$来说，它的$EGF$就是一个一元函数$EGF(x)=a_0+a_1x+a_2\dfrac{x^2}{2}+a_3\dfrac{x^3}{6}+a_4\dfrac{x^4}{24}+\cdots+a_n\dfrac{x^n}{n!}+\cdots$。

__那么这玩意有什么用呢？__

__很有用啊！__

比如说有两个数列$a_n,b_n$，它们的$EGF$已知：$A(x),B(x)$，有第三个数列$c_n=C_n^0a_0b_n+C_n^1a_1b_{n-1}+\cdots+C_n^ka_kb_{n-k}+\cdots+C_n^na_nb_0$，那么它的$EGF$__就是$C(x)=A(x)B(x)$！__

我们来证明一下：

算了，懒得敲公式，丢个链接自己看：[推导](https://www.latexlive.com/#JTVDYmVnaW4lN0JhbGlnbiU3RCUwQUMoeCkmPSU1Q3N1bV8lN0JpPTAlN0QlNUUlNUNpbmZ0eSUyMGNfaSU1Q2ZyYWMlN0J4JTVFaSU3RCU3QmkhJTdEJTVDJTVDJTBBJj0lNUNzdW1fJTdCaT0wJTdEJTVFJTVDaW5mdHklNUNzdW1fJTdCaj0wJTdEJTVFaUNfaSU1RWphX2piXyU3QmktaiU3RCU1Q2ZyYWMlN0J4JTVFaSU3RCU3QmkhJTdEJTVDJTVDJTBBJj0lNUNzdW1fJTdCaT0wJTdEJTVFJTVDaW5mdHklNUNzdW1fJTdCaj0wJTdEJTVFaSU1Q2ZyYWMlN0JpISU3RCU3QmohKGktaikhJTdEYV9qYl8lN0JpLWolN0QlNUNmcmFjJTdCeCU1RWklN0QlN0JpISU3RCU1QyU1QyUwQSY9JTVDc3VtXyU3Qmk9MCU3RCU1RSU1Q2luZnR5JTVDc3VtXyU3Qmo9MCU3RCU1RWklNUNmcmFjJTdCYV9qJTdEJTdCaiElN0R4JTVFaiU1Q2Nkb3QlNUNmcmFjJTdCYl8lN0JpLWolN0QlN0QlN0IoaS1qKSElN0R4JTVFJTdCaS1qJTdEJTVDJTVDJTBBJj0lNUNzdW1fJTdCaj0wJTdEJTVFJTVDaW5mdHklNUNzdW1fJTdCaT1qJTdEJTVFJTVDaW5mdHklNUNmcmFjJTdCYV9qJTdEJTdCaiElN0R4JTVFaiU1Q2Nkb3QlNUNmcmFjJTdCYl8lN0JpLWolN0QlN0QlN0IoaS1qKSElN0R4JTVFJTdCaS1qJTdEJTVDJTVDJTBBJj0lNUNzdW1fJTdCaj0wJTdEJTVFJTVDaW5mdHklNUNzdW1fJTdCaz0wJTdEJTVFJTVDaW5mdHklNUNmcmFjJTdCYV9qJTdEJTdCaiElN0R4JTVFaiU1Q2Nkb3QlNUNmcmFjJTdCYl9rJTdEJTdCayElN0R4JTVFayU1QyU1QyUwQSY9JTVDc3VtXyU3Qmo9MCU3RCU1RSU1Q2luZnR5JTIwYV9qJTVDZnJhYyU3QnglNUVqJTdEJTdCaiElN0QlNUNjZG90JTVDc3VtXyU3Qms9MCU3RCU1RSU1Q2luZnR5JTIwYl9rJTVDZnJhYyU3QnglNUVrJTdEJTdCayElN0QlNUMlNUMlMEEmPUEoeClCKHgpJTBBJTVDZW5kJTdCYWxpZ24lN0Q=)

而从一个$EGF$也可以推出原数列：$a_n=n!EGF^{(n)}(0)$

推导嘛……主要思路就是对$EGF$的定义式求$n$阶导，然后取$x=0$，类似于泰勒展开，~~留作习题~~（逃

__那么它与题目怎么联系上呢？__

首先，在$n$个基因中，选取$k$个放$A$，这个子问题设有$a_k$；

再设剩下部分有$b_{n-k}$种方法。

而此时方法数为$C_n^ka_kb_{n-k}$。

$C_n^k$对应着选取$k$个基因放$A$；$a_k$对应着第一个子问题；$b_{n-k}$对应着第二个子问题。\
又因为$k$的取值范围是$0\le k\le n$，所以总方法数就为……

$C_n^0a_0b_n+C_n^1a_1b_{n-1}+\cdots+C_n^ka_kb_{n-k}+\cdots+C_n^na_nb_0$！

于是，大问题的$EGF$就为两个子问题的$EGF$之乘积！

然后，我们再对$b_{n-k}$进行同样的分解操作，然后再分解，分解……

于是，大问题的$EGF$就为所有基因的$EGF$之乘积！

接下来就算出每个基因的$EGF$就好了。

对于$ACGT$，$EGF$就为$1+x+\dfrac{x^2}{2}+\dfrac{x^3}{6}+\cdots=e^x$；

对于四个阳卦，$EGF$就为$1+\dfrac{x^2}{2}+\dfrac{x^4}{24}+\cdots=\dfrac{e^x+e^{-x}}2$；

对于四个阴卦，$EGF$就为$x+\dfrac{x^3}{6}+\dfrac{x^5}{120}+\cdots=\dfrac{e^x-e^{-x}}2$。

所以总的$EGF$就是把它们乘起来。

然后有总方法数为$n!EGF^{(n)}(0)$。

还有，最后的公式会有一个$\dfrac{1}{256}$，而$256$模$10^9$是没有乘法逆元的，所以先对$n<4$进行特判，而$n\ge4$时$256|4^n$,所以可以变形为$3^n\cdot4^{n-4}-4\cdot2^n\cdot4^{n-4}+6\cdot4^{n-4}+(-1)^n\cdot4^{n-4}$。

---
其实，只要是要求长度为$n$，而每个字符出现次数有限制的字符串计数都可以用$EGF$来做。根据上面的推导，可以看出总问题的$EGF$就为每个字符所对应的$EGF$的乘积。这里我们列出一些基本的$EGF$及证明：

$a_n=1$的$EGF$为$1+x+\dfrac{x^2}{2}+\dfrac{x^3}{6}+\cdots=e^x$；

$a_n=1(n=2k)0(n=2k+1)$的$EGF$为$1+\dfrac{x^2}{2}+\dfrac{x^4}{24}+\dfrac{x^6}{720}+\cdots=\dfrac{1}{2}(1+x+\dfrac{x^2}{2}+\dfrac{x^3}{6}+\cdots+1-x+\dfrac{x^2}{2}-\dfrac{x^3}{6}+\cdots)=\dfrac{1}{2}(e^x+e^{-x})$;

同理，$a_n=0(n=2k)1(n=2k+1)$的$EGF$为$\dfrac{1}{2}(e^x-e^{-x})$。

$a_n=\lambda^n$的$EGF$为$1+\lambda x+\lambda^2\dfrac{x^2}{2}+\lambda^3\dfrac{x^3}{6}+\cdots=e^{\lambda x}$。

$a_n=n!$的$EGF$为$1+x+x^2+x^3+x^4+\cdots=\dfrac{1}{1-x}$。

$a_n=n$的$EGF$为$x+x^2+\dfrac{x^3}{2}+\dfrac{x^4}{6}+\cdots=xe^x$。

$a_n=n(n-1)(n-2)\cdots(n-k+1)$的$EGF$为$x^ke^x$。

###### 码字不易，为了关照本蒟蒻的第一篇题解，~~就点个赞呗~~！
###### 望管理员通过

---

## 作者：peterwuyihong (赞：11)

题意：多测，求有多少只长度为 $n$ 的只包含子丑寅卯辰巳午未申酉戌亥的序列，满足子丑寅卯有任意个，辰巳午未有奇数个，申酉戌亥有偶数个。$T\le 2\times 10^5,1\le n<2^{63},\bmod 10^9$

由于是序列，而不是集合，使用 $\text{EGF}$。

我详细地解释一下 $\text{EGF}$ 的原理。

> 有多少个大小为 $4$ 的可重集，$1$ 不超过 $1$ 个，$2$ 不超过 $2$ 个，$3$ 不超过 $3$ 个。

先讲一下 $\text{OGF}$。

这道题的答案是 $[x^4](1+x)(1+x+x^2)(1+x+x^2+x^3)$。

为什么呢？

我们考虑到第一个括号的 $x$ 乘上 第二个括号里的 $x^2$ 乘上 第三个括号里的 $x$ 等于 $x^4$ 它的意义就是 用了 $1\times1,2\times2,1\times3$。这样这就为答案产生了一个贡献，所有贡献相加就是答案。

> 有多少个长度为 $4$ 的字符串，$1$ 不超过 $1$ 个，$2$ 不超过 $2$ 个，$3$ 不超过 $3$ 个。

这道题的答案是 $4![x^4](1+\dfrac x {1!})(1+\dfrac x{1!}+\dfrac{x^2}{2!})(1+\dfrac x{1!}+\dfrac{x^2}{2!}+\dfrac{x^3}{3!})$。

为什么呢？

我们考虑到第一个括号的 $\dfrac x {1!}$ 乘上 第二个括号里的 $\dfrac{x^2}{2!}$ 乘上 第三个括号里的 $\dfrac x {1!}$ 乘上 $4!$ 等于 $\dfrac{4!\times x^4}{1!\times2!\times1!}$ 它的意义就是 用了 $1\times1,2\times2,1\times3$。然后就是一个[多重集的排列数](https://oi-wiki.org/math/combinatorics/combination/#_9)了。

然后你就明白了 $\text{EGF}$ 的精髓。

然后你就可以拯救世界了。

子丑寅卯的 $\text{EGF}$：$1+\dfrac x{1!}+\dfrac{x^2}{2!}+\dfrac{x^3}{3!}+\ldots=e^x$

辰巳午未的 $\text{EGF}$：$\dfrac x{1!}+\dfrac{x^3}{3!}+\ldots=\dfrac{e^x-e^{-x}}2$

申酉戌亥的 $\text{EGF}$：$1+\dfrac{x^2}{2!}+\dfrac{x^4}{4!}+\ldots=\dfrac{e^x+e^{-x}}2$

答案的 $\text{EGF}$：

$$(e^x(\dfrac{e^x-e^{-x}}2)(\dfrac{e^x+e^{-x}}2))^4$$

$$\frac1{256}(e^{12x}-4e^{8x}+6e^{4x}-4+e^{-4x})$$

乘以一个 $n!$ 取第 $n$ 项系数：

$$\frac1{256}(12^n-4\times8^n+6\times4^n+(-4)^n)$$

常数项扔了……

你发现这个模数很鬼畜，于是你在 $n$ 小的时候硬算，大的时候除掉。

$$81\times12^{n-4}-8^{n-2}+6\times4^{n-4}+(-4)^{n-4}$$

然后适度上扩欧吧，加一个光速幂，靠信仰跑。

现在是 $15:14$，我看我什么时候写完。

现在是 $15:37$，我写完了。

```cpp
#define maxn 200010
long long n;
int N[maxn];
int tot,mx;
const int p=1e9;
template<class _Tp,class _tp>void add(_Tp&x,const _tp& y){((x+=y)>=p)&&(x-=p);}template<class _Tp,class _tp>_Tp Add(_Tp x,const _tp y){add(x,y);return x;}
template<class _Tp,class _tp>void sub(_Tp&x,const _tp&y){((x-=y)<0)&&(x+=p);}template<class _Tp,class _tp>_Tp Sub(_Tp x,const _tp y){sub(x,y);return x;}
template<class _Tp,class _tp>void mul(_Tp&x,const _tp&y){x=1ll*x*y%p;}template<class _Tp,class _tp>_Tp Mul(const _Tp x,const _tp y){return 1ll*x*y%p;}
template<class _Tp,class _tp>_Tp ksm(_Tp a,_tp b){_Tp ans(1);for(;b;b>>=1,mul(a,a))if(b&1)mul(ans,a);return ans;} 
template<class _Tp>_Tp div2(_Tp a){if(a&1)a+=p;return a>>1;}
struct gsm{
	#define _Tp long long
	int _[32768][2],mx;
	gsm(int o,_Tp lim){
		mx=sqrt(lim)+1;
		_[0][0]=_[0][1]=1;
		for(int i=1;i<=mx;i++)_[i][0]=Mul(_[i-1][0],o);
		for(int i=1;i<=mx;i++)_[i][1]=Mul(_[i-1][1],_[mx][0]);
	}
	int operator()(_Tp x){return Mul(_[x%mx][0],_[x/mx][1]);}
};
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	while(cin>>n,n){
		if(n>=4e8)n%=400000000,n+=400000000;
		N[++tot]=n;
		mx=max(mx,N[tot]);
	}
	gsm A(12,mx),B(8,mx),C(4,mx),D(p-4,mx);
	for(int i=1;i<=tot;i++){
		if(N[i]<=3)cout<<0<<endl;
		else cout<<Add(Sub(Mul(81,A(N[i]-4)),B(N[i]-2)),Add(Mul(6,C(N[i]-4)),D(N[i]-4)))<<endl;
	}
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
随便就最优解了，我也不知道为什么。。。

---

## 作者：蒟蒻丁 (赞：7)

[更好体验](https://www.cnblogs.com/caijiLYC/p/14354710.html)  
[链接](https://www.luogu.com.cn/problem/P2012)  
啊，拯救了一次世界后我们再拯救一次  
发现这题的方案是和排列有关的，每种基因出现位置不同视为不同方案，所以使用指数生成函数  
一看题面，发现和拯救一差不多，仍然让指数为使用个数，系数为答案，列出如下三个方程(注意是三个，一开始用两个推推了个寂寞(不过估计也就我这么傻))  
$$\sum_{i}{\frac{x^i}{i!}}$$
$$\frac{x}{1!}+\frac{x^3}{3!}+\frac{x^5}{5!}+……=\sum_{i}{\frac{x^{2*i+1}}{(2*i+1)!}}$$
$$1+\frac{x^2}{2!}+\frac{x^4}{4!}+……=\sum_{i}{\frac{x^{2*i}}{(2*i)!}}$$
其中第一条和第二条可以将$-x$带入第三条相减或相加后获得，大家都会，不赘述了  
先用奇怪公式化简一下
$$
\sum_{i}{\frac{x^i}{i!}}=e^x$$
$$\sum_{i}{\frac{x^{2*i+1}}{(2*i+1)!}}=\frac{e^x+e^{-x}}{2}$$
$$\sum_{i}{\frac{x^{2*i}}{(2*i)!}}=\frac{e^x-e^{-x}}{2}
$$
用乘法原理乘一下，由于那些基因各有$4$种，同样由乘法原理得要将这些柿子四次方
$$
(e^x)^4*(\frac{e^x+e^{-x}}{2})^4*(\frac{e^x-e^{-x}}{2})^4$$
$$\frac{1}{256}*(e^x*(e^x+e^{-x})*(e^x-e^{-x}))^4$$
$$\frac{1}{256}*(e^{3*x}-e^{-x})^4
$$
有趣的是，我们这次采用暴力化简，直接将四次方展开(
$$\frac{1}{256}*(e^{12*x}-4*e^{8*x}+6*e^{4*x}+e^{-4*x}-4)$$
对于每一项，用奇怪公式反过来推
$$\frac{1}{256}*(\sum{\frac{(12*x)^i}{i!}}-4*\sum{\frac{(8*x)^i}{i!}}+6*\sum{\frac{(4*x)^i}{i!}}+\sum{\frac{(-4*x)^i}{i!}}-4)$$
因为答案就是第$n$项的系数，所以代入$n$，取出系数
$$\frac{1}{256}*(\frac{12^n}{n!}-4*\frac{8^n}{n!}+6*\frac{4^n}{n!}+\frac{(-4)^n}{n!})$$
因为是$EGF$最后乘上$n!$
就是
$$
\frac{1}{256}*(12^n-4*8^n+6*4^n+(-4)^n)$$
$$81*12^{n-4}-4*8^{n-2}+6*4^{n-4}+(-4)^{n-4}
$$
那么这条柿子已经可以做了  
但是由于题目恶臭，直接做是会$T$的，此时就需要扩展欧拉定理优化一下  
科普一下[笑](https://oi-wiki.org/math/fermat/)  
其实还有不少方法，大家用的都不一样啊
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const ll mod=1e9,phi=4e8; 
ll n,m,ans,T;

inline ll ksm(ll x,ll k){
	ll tmp=1;
	while(k>0){
		if(k&1)tmp=tmp*x%mod;
		x=x*x%mod,k>>=1;
	}
	return tmp;
}

int main(){
	scanf("%lld",&n);
	while(n){
		ans=0;
		if(n<4)printf("0\n");
		else if(n<phi){
			ans=(81*ksm(12,n-4)%mod-ksm(8,n-2)+6*ksm(4,n-4)+ksm(-4,n-4)+mod)%mod;
			printf("%lld\n",ans);
		}
		else {
			ans=(ans+81*ksm(12,(n-4)%phi+phi)%mod)%mod;
			ans=(ans-ksm(8,(n-2)%phi+phi)+mod)%mod;
			ans=(ans+6*ksm(4,(n-4)%phi+phi)%mod)%mod;
			ll tmp=ksm(4,(n-4)%phi+phi);
			if((n-4)%2==1)ans=(ans-tmp+mod)%mod;
			else ans=(ans+tmp)%mod;
			printf("%lld\n",ans);
		}
		scanf("%lld",&n);
	}
}
```

---

## 作者：封禁用户 (赞：7)

![](https://cdn.luogu.com.cn/upload/pic/52669.png)   

使用Python3+Sympy实现的求递推系数的代码:
```python
from sympy import *
x = symbols("x")
f = ((sinh(x)*cosh(x)*exp(x))**4).diff().diff().diff().diff()
coefs = []
for i in range(20):
    coefs.append(f.subs([(x, 0)]))
    f = f.diff()
print(coefs)

eqs = []
xs = list([symbols("x%d" % i) for i in range(8)])
A = 4 # 假设的递推系数
for i in range(A+4):
    a = 0
    for j in range(i, i+A):
        a += xs[j-i]*coefs[j]
    eqs.append(Eq(a, coefs[i+A]))
print(eqs)
print(solve(eqs))

```

使用矩阵乘法通过本题的代码(由于我一开始没有注意到我读入函数写挂了故用了大量卡常手段):

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#pra\
gma GCC optimi\
ze("Ofast")
#include <assert.h>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
using int_t = unsigned long long int;
using std::cin;
using std::cout;
using std::endl;
const int_t mod = 1e9;

struct Matrix {
    int data[4][4];
    int n, m;
    Matrix() {
        n = m = 0;
        // memset(data, 0, sizeof(data));
    }
    Matrix(int n, int m) {
        this->n = n;
        this->m = m;
        // memset(data, 0, sizeof(data));
#ifdef DEBUG
        cout << "n=" << n << ",m=" << m << endl;
#endif
    }
    __attribute__((hot)) Matrix operator*(const Matrix& mat) {
        Matrix result(n, mat.m);
        for (short i = 0; i < n; i++) {
            for (short j = 0; j < mat.m; j++) {
                int_t sum = 0;
                for (short k = 0; k < m; k++) {
                    sum += (int_t)data[i][k] * mat.data[k][j];
                }
                result.data[i][j] = sum % mod;
            }
        }
        return result;
    }
    Matrix operator^(const Matrix& mat) {
        Matrix result(n, mat.m);
        result.data[0][0] = ((int_t)data[0][0] * mat.data[0][0] +
                             (int_t)data[0][1] * mat.data[1][0] +
                             (int_t)data[0][2] * mat.data[2][0] +
                             (int_t)data[0][3] * mat.data[3][0]) %
                            mod;
        result.data[0][1] = ((int_t)data[0][0] * mat.data[0][1] +
                             (int_t)data[0][1] * mat.data[1][1] +
                             (int_t)data[0][2] * mat.data[2][1] +
                             (int_t)data[0][3] * mat.data[3][1]) %
                            mod;
        result.data[0][2] = ((int_t)data[0][0] * mat.data[0][2] +
                             (int_t)data[0][1] * mat.data[1][2] +
                             (int_t)data[0][2] * mat.data[2][2] +
                             (int_t)data[0][3] * mat.data[3][2]) %
                            mod;
        result.data[0][3] = ((int_t)data[0][0] * mat.data[0][3] +
                             (int_t)data[0][1] * mat.data[1][3] +
                             (int_t)data[0][2] * mat.data[2][3] +
                             (int_t)data[0][3] * mat.data[3][3]) %
                            mod;

        return result;
    }
    int* operator[](int r) { return data[r]; }
};
template <class T>
void write(T x) {
    if (x > 9) write(x / 10);
    putchar('0' + x % 10);
}
Matrix base(1, 4), trans(4, 4);
Matrix pows[128];
int main() {
    base[0][0] = 24;
    base[0][1] = 480;
    base[0][2] = 7680;
    base[0][3] = 107520;
    trans[1][0] = 1;
    trans[2][1] = 1;
    trans[3][2] = 1;
    trans[0][3] = 1536;
    trans[1][3] = mod - 320;
    trans[2][3] = mod - 80;
    trans[3][3] = 20;

    pows[0] = trans;
    for (int i = 1; i < 128; i++) {
        pows[i] = pows[i - 1] * pows[i - 1];
    }
    int counter = 0;
    while (true) {
        int_t x;
        cin>>x;
        if (x == 0) break;
        counter++;
        if (counter > 200000) break;
        if (x < 4) {
            cout << 0 << endl;
            continue;
        }
        x -= 4;
        assert(x >= 0);
        Matrix result = base;
        int bit = 0;
        while (x) {
            if (x & 1) result = result ^ pows[bit];
            bit++;
            x >>= 1;
        }
        write(result.data[0][0]);
        putchar('\n');
    }
    return 0;
}
```

使用特征方程通过本题的代码:

```cpp
#pragma GCC target("avx2,sse")
#include <assert.h>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <iostream>
using int_t = unsigned long long int;
using std::cin;
using std::cout;
using std::endl;

const int mod = 1e9;
const int phi = 400000000;
template <class T>
void read(T& x) {
    x = 0;
    char chr = getchar();
    assert(chr != '-');
    int counter = 0;
    while (isdigit(chr) == false) {
        int curr = getchar();
        if (curr == -1) return;
        chr = curr;
        counter++;
        assert(counter <= 10);
    }
    while (isdigit(chr)) {
        x = x * 10 + (chr - '0');
        chr = getchar();
    }
}
template <class T>
void write(T x) {
    assert(x >= 0);
    if (x > 9) write(x / 10);
    putchar('0' + x % 10);
}
int main() {
    int counter = 0;
    while (true) {
        int_t x;
        read(x);
        if (x == 0) break;
        counter += 1;
        assert(counter <= 200000);
        if (x > phi) x = x % phi + phi;
        if (x < 4) {
            write(0);
            putchar('\n');
            continue;
        }
        x -= 4;
        int t2 = 1;
        int t3 = 1;
        int b3 = 3, b2 = 2;
        int index = x;
        while (index) {
            t2 = (int_t)t2 * ((index & 1) ? b2 : 1) % mod;
            t3 = (int_t)t3 * ((index & 1) ? b3 : 1) % mod;
            b3 = (int_t)b3 * b3 % mod;
            b2 = (int_t)b2 * b2 % mod;
            index >>= 1;
        }
        int t4 = (int_t)t2 * t2 % mod;
        int result = ((int_t)((x & 1) ? (mod - 1) : 1) + (int_t)81 * t3 + 6 -
                      (int_t)64 * t2 % mod + mod) %
                     mod * t4 % mod;
        write(result);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：day_dream (赞：6)

做这题你首先要知道一个常用的泰勒展开公式。

$e^{cx}=\sum_{i\ge 0}c^i\frac{x^i}{i!}$

然后，三种限制的生成函数是：

$A(x)=\sum_{i\ge 0}\frac{x^i}{i!}=e^x$

$B(x)=\sum_{i\ge 0}\frac{x^{2i}}{(2i)!}=\frac{e^x+e^{-x}}{2}$

$C(x)=\sum_{i\ge 0}\frac{x^{2i+1}}{(2i+1)!}=\frac{e^x-e^{-x}}{2}$

因为每种都有四个，所以最后答案的生成函数是$Ans(x)=(A(x)B(x)C(x))^4$。

手算一下$Ans(x)=\frac{e^{12x}-4e^{8x}+6e^{4x}+e^{-4x}-4}{256}$

把每一项泰勒展开得到：

$Ans(x)=\frac{\sum_{i\ge 0}12^i\frac{x^i}{i!}-4\sum_{i\ge 0}8^i\frac{x^i}{i!}+6\sum_{i\ge 0}4^i\frac{x^i}{i!}+\sum_{i\ge 0}(-4)^i\frac{x^i}{i!}-4}{256}$

合并之后，第n项的系数(即答案)就是$\frac{12^n-4\times8^n+6\times4^n+(-4)^n}{256}$(因为$n<4$的时候答案为0，而上面那个式子最后的-4只和常数项有关，所以不用考虑。不过就算你考虑了，$n<4$时，答案也是0)。

~~不知道为什么读入要写scanf，不能用快读，我因为这个T到自闭~~

---

## 作者：demerzel_iv (赞：4)

这是一道卡常(划掉)生成函数的好题。

因为题目要求的是有序序列。所以我们采用EGF(指数型生成函数)来做。

容易看出。三个类型的基因序列对应的生成函数分别是

A(x)=1+x+x^2/2!+x^3/3!+x^4/4!+...=e^x

B(x)=x+x^3/3!+x^5/5!+x^7/7!+...    =1/2(e^x-e^-x)

C(x)=1+x^2/2!+x^4/4!+x^6/6!+...   =1/2(e^x+e^-x)

由于每类基因都有四种。因此答案的生成函数就是(ABC)^4

我们暴力展开一下。得到下面这个式子：

(e^12x - 4\*e^8x + 6\*e^4x + e^-4x - 4)/256

将每一项麦克劳林展开。再逐项合并。我们得到n>1答案为

(12^n-4\*8^n+6\*4^n+(-4)^n)/256

直接计算即可。


吐槽：这题卡常卡得我吐血。最后发现去掉一个 b=n; 赋值就可以过了。我也不知道为什么。


---

## 作者：w33z8kqrqk8zzzx33 (赞：3)

成功跑到全谷最劣解（（（  
首先，注意这些特殊基因不需要分别类型，只需要分别它们在当前前缀里是否合法。  
例如，初始有四个合法（阴的基因），有四个不合法（阳的基因）。  
在基因序列结尾加上任意一个特殊基因要么会导致原来不合法的某个基因变合法，要么会导致相反。  
于是考虑 dp，第一维是当前基因长度，第二维是有多少合法基因，边界是 $dp[0][i]=[i=4]$，想求的是 $dp[n][0]$。转移也就是 $dp[n][i]$ 有 $i$ 种方法往 $dp[n+1][i-1]$（选一个当前合法边不合法），有 $8-i$ 种方法往 $dp[n+1][i+1]$，有 $4$ 种方法往 $dp[n+1][i]$。但是直接暴力做显然炸，于是考虑矩阵优化。

朴素矩阵优化时间复杂度是 $O(qk^3\log n)$，显然跑不进，考虑把 $k^3$ 压 $k^2$。首先我们预处理出来转移矩阵 $z$ 的 $z^{k\cdot 256^i}$ 值，可以用这些乘起来，只需要乘 $O(\frac{\log n}{\omega})$ 次矩阵，但是需要 $O(\frac{\log n}{\omega}2^{\omega})$ 的预处理矩阵相乘。在这里选择了 $\omega=8$。

毕竟永远是一个一维矩阵成转移矩阵的次幂，乘的时间复杂度就是 $O(k^2)$ 了。  
总共时间复杂度 $O(\frac{\log n}{\omega}2^{\omega}+\frac{k^2}{\omega}\sum\log n)$。

然后扩展欧拉定理都没有用。。。读入优化都没有用。。。循环展开都没有用。。。AC 993ms 时限 1000ms（（（

贴代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int mod = 1000000000;
class mat {
public:
	int n, m;
	int ar[9][9];
	void init(int _n, int _m) {
		n = _n; m = _m;
		for(int i=0; i<_n; i++)
			for(int j=0; j<_m; j++)
				ar[i][j] = 0;
	}
};

mat mul(const mat& a, const mat& b) {
	assert(a.m == b.n);
	mat r; r.init(a.n, b.m);
	for(int i=0; i<a.n; i++)
		for(int k=0; k<b.n; k++)
			for(int j=0; j<a.m; j++)
				r.ar[i][k] = (r.ar[i][k] + 1ll * a.ar[i][j] * b.ar[j][k]) % mod;
	return r;
}

mat zy, uni, ans, a2;
mat ini[8][257];

int main(){
	zy.init(9, 9);
	uni.init(9, 9);
	for(int valid=0; valid<9; valid++) {
		if(valid!=8) zy.ar[valid][valid+1] += 8-valid;
		if(valid!=0) zy.ar[valid][valid-1] += valid;
		zy.ar[valid][valid] += 4;
		uni.ar[valid][valid] = 1;
	}
	for(int i=0; i<8; i++) {
		ini[i][0] = uni;
		if(i) ini[i][1] = ini[i-1][256];
		else ini[i][1] = zy;
		for(int j=2; j<=256; j++) ini[i][j] = mul(ini[i][j-1],ini[i][1]);
	} 
	long long n;
	while(cin >> n && n) {
		 ans.init(1,9); ans.ar[0][4] = 1;
		 //ans.ar[4][0] = 1;
		 int dx = 0;
		 while(n) {
		 	ans = mul(ans, ini[dx][n&255]);
		 	n>>=8;
		 	dx++;
		 }
		 cout << ans.ar[0][0] << endl;
	}
}


```

---

## 作者：喵仔牛奶 (赞：1)

下文令 $m=8$。

## 算法 1

枚举每个位置基因，最后判断。

时间复杂度 $\mathcal{O}(Tm^n)$，期望得分 $0$。

## 算法 2

考虑 dp，设 $f_{i,j}$ 为前 $i$ 个基于有 $j$ 个条件合法的。

普通基于对于状态没有影响，有 $4\times f_{i-1,j}$ 种方案。阴阳状态本质没有区别：如果增加了合法状态，那么上一次有 $j-1$ 种合法状态，$8-(j-1)=9-j$ 种不合法状态，有 $(9-j)\times f_{i-1,j-1}$ 种方案；如果减少了合法状态，那么上一次有 $j+1$ 种合法状态，有 $(j+1)\times f_{i-1,j+1}$ 种方案。

$$f_{i,j}=4\times f_{i-1,j}+(9-j)\times f_{i-1,j-1}+(j+1)\times f_{i-1,j+1}$$

时间复杂度 $\mathcal{O}(Tnm)$，期望得分 $10$。

## 算法 3

发现上午转移方程可以写成矩阵形式：

$$
\begin{pmatrix}
4,1,0,0,0,0,0,0,0 \\
8,4,2,0,0,0,0,0,0 \\
0,7,4,3,0,0,0,0,0 \\
0,0,6,4,4,0,0,0,0 \\
0,0,0,5,4,5,0,0,0 \\
0,0,0,0,4,4,6,0,0 \\
0,0,0,0,0,3,4,7,0 \\
0,0,0,0,0,0,2,4,8 \\
0,0,0,0,0,0,0,1,4 \\
\end{pmatrix}
\times
\begin{pmatrix}
f_{i-1,0}\\
f_{i-1,1}\\
f_{i-1,2}\\
f_{i-1,3}\\
f_{i-1,4}\\
f_{i-1,5}\\
f_{i-1,6}\\
f_{i-1,7}\\
f_{i-1,8}\\
\end{pmatrix}

=
\begin{pmatrix}
f_{i,0}\\
f_{i,1}\\
f_{i,2}\\
f_{i,3}\\
f_{i,4}\\
f_{i,5}\\
f_{i,6}\\
f_{i,7}\\
f_{i,8}\\
\end{pmatrix}
$$

矩阵快速幂即可。

时间复杂度 $\mathcal{O}(Tm^3\log n)$，期望得分 $50$。

## 算法 3 plus

设 $p=10^9$，原 $9\times 9$ 的矩阵为 $A$。

考虑拓展欧拉定理降幂：

$$a^b\equiv\begin{cases}a^b&b<\varphi(p)\\a^{b\bmod\varphi(p)+\varphi(p)}&b\leq\varphi(p)\end{cases}\text{ }(\bmod\text{ }p)$$

那么最后降幂后 $a^b\equiv a^c$，$c\leq 2\times\varphi(p)$。

然后定一个 $B$，预处理 $A$ 的 $1\sim B$ 次方与 $A^{B}$ 的 $1\sim \lfloor2\times\varphi(p)/B\rfloor$ 次方。因为 $A^{x}=A^{x\bmod B}\times A^{B\times\lfloor x/B\rfloor}$，而两者都预处理过了，一次乘法即可求出 $A^{x}$。

预处理时间复杂度是 $\mathcal{O}(B+\lfloor2\times\varphi(p)/B\rfloor)$，$B$ 取 $\sqrt{2\times\varphi(p)}$ 最优。因为浮点数转整形向下取整，所以令 $B=\sqrt{2\times\varphi(p)}+1$。预处理一下就可以 $\mathcal{O}(m^3)$ 计算答案。

这个好像叫做「光速幂」。

时间复杂度 $\mathcal{O}(m^3(\sqrt{p}+T))$，期望得分 $100$（得卡一下常）。

~~又用蓝题的做法水了一道黑题。~~

代码见文末。

## 算法 4

参考了其他题解：

问题其实是求排列数，考虑指数生成函数。

构造生成函数（普通为 $F$，阳为 $G$，阴为 $H$）：

$$F(x)=\left(\sum_{i=0}^{∞}\frac{x^i}{i!}\right)^4=e^{4x}$$
$$G(x)=\left(\sum_{i=0}^{∞}\frac{x^{2i+1}}{(2i+1)!}\right)^4=\frac{1}{16}(e^{x}-e^{-x})^4$$
$$H(x)=\left(\sum_{i=0}^{∞}\frac{x^{2i}}{(2i)!}\right)^4=\frac{1}{16}(e^{x}+e^{-x})^4$$

三种都满足的排列的生成函数就是 $A(x)=F(x)G(x)H(x)$。

$$A(x)=e^{4x}\times\frac{1}{16}(e^{x}-e^{-x})^4\times\frac{1}{16}(e^{x}+e^{-x})^4=\frac{1}{256}(e^{3x}-e^{-x})^4$$
$$A(x)=\frac{1}{256}(e^{-4x}-4+6e^{4x}-4e^{8x}+e^{12x})$$

答案取其 $n$ 次项系数，还要乘 $n!$。即为：

$$\frac{1}{256}((-4)^{n}+6\times4^{n}-4\times8^{n}+12^{n})$$

因为模数 $10^9$非常鬼畜，可以化式子为：

$$((-4)^{n-4}+6\times4^{n-4}-8^{n-2}+81\times12^{n-4})$$

然后使用算法 3 plus 的光速幂计算即可。

时间复杂度 $\mathcal{O}(\sqrt p+T)$。

## Code

矩阵快速幂，[3.54s](https://www.luogu.com.cn/record/100421128)。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1e5 + 5, mod = 1e9;
struct matrix {
	LL a[12][12];
	matrix operator * (matrix x) {
		matrix c;
		memset(c.a, 0, sizeof c.a);
		for (int i = 0; i <= 8; i ++)
			for (int k = 0; k <= 8; k ++)
				for (int j = 0; j <= 8; j ++)
					c.a[i][j] = (c.a[i][j] + a[i][k] * x.a[k][j]) % mod;
		return c;
	}
} bas, f, f1[N], f2[N];
LL n, phi, cnt;
matrix query(LL k) { return f1[k % cnt] * f2[k / cnt]; }
LL getPhi(LL k) {
	LL res = 1;
	for (int i = 2; i * i <= k; i ++) {
		if (k % i) continue;
		res *= i - 1, k /= i;
		while (k % i == 0) k /= i, res *= i;
	}
	if (k != 1) res *= k - 1;
	return res;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	for (int i = 0; i <= 8; i ++) {
		bas.a[i][i] = 4;
		if (i > 0) bas.a[i][i - 1] = 9 - i;
		if (i < 8) bas.a[i][i + 1] = i + 1;
	}
	phi = getPhi(mod), cnt = sqrt(phi * 2) + 1, f.a[4][0] = 1;
	for (int i = 0; i <= 8; i ++) f1[0].a[i][i] = f2[0].a[i][i] = 1;
	for (int i = 1; i <= cnt; i ++) f1[i] = f1[i - 1] * bas;
	for (int i = 1; i <= cnt; i ++) f2[i] = f2[i - 1] * f1[cnt];
	while (cin >> n, n) {
		if (n >= phi) n = n % phi + phi;
		cout << (query(n) * f).a[8][0] << '\n';
	}
	return 0;
}
```


---

## 作者：m256i (赞：1)

我们将元素分为四类。

* O 类：A、C、G、T
* A 类：乾、坎、艮、震
* B 类：坤、兑、离、巽

其组合类分别为 $\mathcal{O}$、$\mathcal{A}$ 和 $\mathcal{B}$。我们需要对这四类元素进行**标号积**而不是**组合积**，因此使用有标号计数，生成函数为 EGF。

O 类的 EGF $\hat O(x)$ 为：

$$
\begin{aligned}
\hat O(x)&=\sum_{n \ge 0}\dfrac{x^n}{n!}\\
&=\gdef\ex#1{\mathrm e^{#1}}\mathrm e^x
\end{aligned}
$$

A 类的 EGF $\hat A(x)$ 为：

$$
\hat A(x)=\sum_{\begin{subarray}{c}n \ge 0\\n \equiv 1 \pmod 2\end{subarray}}\dfrac{x^n}{n!}
$$

这个式子怎么化简？考虑一个生成函数 $G(x)=\displaystyle\sum_{n \ge 0}g_nx^n$，那么：

$$
\begin{aligned}
G(x)+G(-x)&=\left(\sum_{n \ge 0}g_nx^n\right)+\left(\sum_{n \ge 0}g_n(-x)^n\right)\\
&=\sum_{n \ge 0}g_n(1+(-1)^n)x^n\\
&=\sum_{n \ge 0}2g_n[n \equiv 0 \pmod 2]x^n\\
&=2\sum_{n \ge 0}g_n[n \equiv 0 \pmod 2]x^n
\end{aligned}
$$

那么 $\displaystyle\sum_{\begin{subarray}{c}n \ge 1\\n\equiv 0 \pmod 2\end{subarray}}g_nx^n=\dfrac{G(x)+G(-x)}{2}$。同理有 $\displaystyle\sum_{\begin{subarray}{c}n \ge 1\\n\equiv 1 \pmod 2\end{subarray}}g_nx^n=\dfrac{G(x)-G(-x)}{2}$。

由此我们可以得到 $\hat A(x)=\dfrac{O(x)-O(-x)}{2}=\dfrac{\mathrm e^x-\mathrm e^{-x}}{2}$，且 B 类的 EGF $\hat B(x)=\dfrac{O(x)+O(-x)}{2}=\dfrac{\mathrm e^x+\mathrm e^{-x}}{2}$

现在把这些元素做笛卡尔积，得到结果的 EGF $\hat F(x)$：

$$
\begin{aligned}
\hat F(x)&=\hat O(x)^4\hat A(x)^4\hat B(x)^4\\
&=(\mathrm e^x)^4\left(\dfrac{\mathrm e^x+\mathrm e^{-x}}{2}\right)^4\left(\dfrac{\mathrm e^x-\mathrm e^{-x}}{2}\right)^4\\
&=\mathrm e^{4x}\left(\left(\dfrac{\mathrm e^x}{2}+\dfrac{\mathrm e^{-x}}{2}\right)\left(\dfrac{\mathrm e^x}{2}-\dfrac{\mathrm e^{-x}}{2}\right)\right)^4\\
&=\mathrm e^{4x}\left(\dfrac{\mathrm e^{2x}}{4}-\dfrac{\mathrm e^{-2x}}{4}\right)^4\\
&=\dfrac{1}{256}\mathrm e^{4x}(\mathrm e^{2x}-\mathrm e^{-2x})^4\\
&=\dfrac{1}{256}\mathrm e^{4x}(\mathrm e^{-8x}-4\mathrm e^{2x}\mathrm e^{-6x}+6\mathrm e^{4x}\mathrm e^{-4x}-4\mathrm e^{6x}\mathrm e^{-2x}+\mathrm e^{8x})\\
&=\dfrac{1}{256}\mathrm e^{4x}(\mathrm e^{-8x}-4\mathrm e^{-4x}+6-4\mathrm e^{4x}+\mathrm e^{8x})\\
&=\dfrac{1}{256}(\mathrm e^{-4x}-4+6\mathrm e^{4x}-4\mathrm e^{8x}+\mathrm e^{12x})\\
&=\dfrac{\mathrm e^{12x}-4\mathrm e^{8x}+6\mathrm e^{4x}+\mathrm e^{-4x}-4}{256}
\end{aligned}
$$

那么：

$$
\begin{aligned}
\left[\dfrac{x^n}{n!}\right]\hat F(x)&=\dfrac{1}{256}\left(-4+\sum_{n \ge 0}(12^n-4 \times 8^n+6 \times 4^n+(-4)^n)\dfrac{x^n}{n!}\right)\\
&=\dfrac{12^n-4 \times 8^n+6 \times 4^n+(-4)^n}{256}
\end{aligned}
$$

根据鸽巢原理，本题的答案正是 $\left[\dfrac{x^n}{n!}\right]\hat F(x)$。

但是 $256$ 在模 $10^9$ 意义下没有乘法逆元。不过我们发现，每个乘方的底数均含有因子 $4$，把 $n$ 加上 $4$ 就可以把分母消掉了。

$$
\begin{aligned}
\left[\dfrac{x^{n+4}}{n!}\right]\hat F(x)&=\dfrac{12^{n+4}-4 \times 8^{n+4}+6 \times 4^{n+4}+(-4)^{n+4}}{256}\\
&=\dfrac{20736 \times 12^n-16384 \times 8^n+1536 \times 4^n+256 \times (-4)^n}{256}\\
&=81 \times 12^n-64 \times 8^n+6 \times 4^n+(-4)^n
\end{aligned}
$$

当 $n<4$ 时答案显然为 $0$。因此：

$$
\left[\dfrac{x^n}{n!}\right]\hat F(x)=\begin{cases}81 \times 12^{n-4}-64 \times 8^{n-4}+6 \times 4^{n-4}+(-4)^{n-4}&n \ge 4\\0&n<4\end{cases}$$

光速幂即可。
$$

---

## 作者：Arghariza (赞：1)

由于不是组合，所以不能够用 OGF，于是我们考虑 EGF。

对于 `A,C,G,T` 四种： $G_1(i)=\sum\limits_{i=0}^{\infty}\frac{x^i}{i!}=e^x$

对于乾、坎、艮、震： $G_2(i)=\sum\limits_{i=0}^{\infty}\frac{x^{2i}}{(2i)!}=\frac{1}{2}(e^x+e^{-x}) \ $ （$e^{-x}=\sum\limits_{i=0}^{\infty}\frac{(-1)^ix^i}{i!}$，两个相加即可抵消奇数）。

剩下那种： $G_3(i)=\sum\limits_{i=0}^{\infty}\frac{x^{2i+1}}{(2i+1)!}=e^x-G_2(x)=\frac{1}{2}(e^x-e^{-x})$

于是：

$$\begin{aligned}G(x)&= (G_1(x)G_2(x)G_3(x))^4\\&=(\frac{1}{4}e^x(e^x+e^{-x})(e^x-e^{-x}))^4\\&=\frac{1}{2^8}(e^{3x}-e^{-x})^4\\&=\frac{1}{2^8}(e^{12x}-4e^{8x}+6e^{4x}-4+e^{-4x})\end{aligned}$$

然后我们要求的是 $G(x)$ 中 $x^n$ 的系数：

$$\because e^{ax}=\sum\limits_{i=0}^{\infty}\frac{a^ix^i}{i!},[x^n]e^{ax}=\frac{a^n}{n!}$$

$$\begin{aligned}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\therefore G(x)ans&=n![x^n]G(x)\\&=\frac{1}{2^8}(12^n-4\times8^{n}+6\times 4^{n}-4+(-1)^{n}\times4^n)\end{aligned}$$

然后这道毒瘤题还要用欧拉定理：

$$a^b\equiv a^{b\mod \varphi(p)}\mod p$$

然后我们知道 $\varphi(10^9)=4\times10^8$。

先取模，然后快速幂即可。

当 $n\le 4$ 的时候由于无法计算 $2^8$ 的逆元，所以要单独拎出来判断。

```cpp
const int mod = 1e9;
const int mp = 4e8;

int n;

int ksm(int p, int q) {
	int res = 1;
	while (q) {
		if (q & 1) res = res * p % mod;
		p = p * p % mod;
		q >>= 1;
	}
	return res;
}

signed main() {
	while (scanf("%lld", &n) && n) {
		if (n <= 4) puts(n == 4 ? "24" : "0");
		else {
			int a = n - 4;
			int b = n - 2;
			a %= mp, b %= mp;
			printf("%lld\n", (((((81 * ksm(12, a) % mod - ksm(8, b) % mod) % mod + mod) % mod + 6 * ksm(4, a) % mod) % mod + ksm(-1, a) * ksm(4, a) % mod) + mod) % mod);
		}
	}
	return 0;
}
```

---

## 作者：玄学OIER荷蒻 (赞：0)

本题解主要说优化，其它就不详细说明了，别的题解有很多讲解了。

思路:看到这道题后，很明显会想到指数型生成函数 $\operatorname{EGF}$，因为我们需要考虑顺序(题目里要求的是序列的个数而不是集合)。

我们只要求出三个限制的 $\operatorname{EGF}$ 再相乘，然后取其 $n$ 次项系数，最后与 $n!$ 相乘。

众所周知，根据泰勒展开，$e^{cx}=\sum_{i=0}^{\infty}c^i\frac{x^i}{i!}$。

所以它们的 $\operatorname{EGF}$ 分别为 $e^{4x},\frac{(e^x+e^{-x})^4}{16},\frac{(e^x-e^{-x})^4}{16}$(每种都有四个所以要四次方)。

然后取其 $n$ 次项系数，并与 $n!$ 相乘(手算时建议用泰勒展开)。

最后答案就是 $\frac{12^n-4\times8^n+6\times4^n+(-4)^n}{256}$。

但我们发现 $256$ 和 $1000000000$ 有不互质，所以 $256$ 没有逆元。

没办法，这能怪出题人太毒瘤。

我们发现，这个式子可以写成 $81\times12^{n-4}-8^{n-2}+6\times4^{n-4}+{(-4)}^{n-4}$。

但 $n<4$ 怎么办?

我们发现，如果 $n<4$，那么一定没有解决方案，因为乾、坎、艮、震一定要出现奇数次，所以最少也要 $n=4$ 才能有解。

后来试了一下，这里其实不用优化也能过，但还是讲讲各种优化的方法。

### 优化0 不优化

最大耗时点 813ms。


### 优化1 卡常(就是吸了个氧)

这里好像加快读会出问题。

吸氧以后最大耗时 738ms。

因为是用 ```while``` 做循环所以开不开 ```register``` 都一样。


### 优化2 指数化简

根据 $n \bmod 2$ 分类讨论，再用 $2^{n-4}$ 和 $3^{n-4}$ 表示整个式子就会快很多。

指数化简后(没吸氧) 440ms，吸氧后 394ms

### 优化3 指数取模

因为 $\varphi{(1000000000)}=400000000$。

如果指数大于 $400000000$ ，只要在快速幂前把指数模 $400000000$ 再加 $400000000$ 就可以啦。

化简后 398ms，加上指数化简并且吸氧 203ms。

### 优化4 光速幂

大家都知道，懒得写也不说了。

## 最后

代码不贴了，其它题解已经有很多了。

第一次写黑题解，请管理大大多多包含。

---

## 作者：W123789 (赞：0)

这道题算是生成函数（GF）入门题了吧，那就顺便讲一下生成函数。

不严谨的定义：假设有一串序列 $\{a_n\}_0^\infty$，设 $G(x)=\sum\limits_{i=0}^\infty a_ik_n(x)$，则称 $G(x)$ 为序列 $\{a_n\}_0^\infty$ 的生成函数，生成函数的第 $i$ 项对应着原序列的 $a_i$。

#### 分类

$k_n(x)$ 一般有 $3$ 种，根据 $k_n(x)$，生成函数一般分为 $3$ 类：

1. 普通生成函数（OGF）：$k_n(x) = x^n$

2. 指数生成函数（EGF）：$k_n(x) = \frac{x^n}{n!}$

3. 狄利克雷生成函数（DGF）：$k_n(x) = \frac1{x^n}$

函数中的 $x$ 可以取任意值，且与原序列无关，所以被称为形式幂级数。

更为常用的是前两种。

#### 应用

普通生成函数运用于**不讲求数列顺序的数列计数问题**，意思就是假设有四个数 $a,b,c,d$，排列 $(a,b,c,d)$ 和排列 $(a,c,b,d)$ 是同一种。

指数生成函数运用于**讲求数列顺序的数列计数问题**，假设有四个数 $a,b,c,d$，排列 $(a,b,c,d)$ 和排列 $(a,c,b,d)$ 是不同的方案。

#### 封闭形式

1. 由于生成函数是无穷级数，用起来非常不方便，又因为 $x$ 可以取任意值，限定 $-1<x<1$，就可以得到一些封闭形式。

$$\sum\limits_{i=0}^\infty x^i=\frac1{1-x}$$

证明: 设 $F(x)=\sum\limits_{i=0}^\infty x^i,xF(x)=\sum\limits_{i=1}^nx^i=\sum\limits_{i=0}^nx^i+1$

$\therefore xF(x)=F(x)+1$，移项得：$F(x)=\frac{1}{1-x}$

一些例子: 

序列 $\{p,2p,3p,\cdots\}_0^\infty$ 的生成函数：$\frac{1}{1-x^p}$

序列 $\{ \binom{m}{0} ,\binom{m}{1},\binom{m}{2},\cdots\}_0^\infty$ 的生成函数：$(1+x)^m$，二项式定理展开即可。

因为计数类问题一般满足乘法原理，所以我们往往需要把两个生成函数相乘。 两个生成函数相乘，也就是它们的封闭形式相乘。

例题：[拯救世界](https://www.luogu.com.cn/problem/P2000)

2. Taylor展开

$$e^x=\sum\limits_{n=0}^\infty \frac{x^n}{n!}$$

一些例子: 

$F(x)=\sum\limits_{n=0}^\infty\frac{x^{2n}}{(2n)!}$ 的生成函数：$\frac12(e^x+e^{-x})$

$F(x)=\sum\limits_{n=0}^\infty\frac{x^{2n+1}}{(2n+1)!}$ 的生成函数：$\frac12(e^x-e^{-x})$

因为计数类问题一般满足乘法原理，所以我们往往需要把两个生成函数相乘。
两个生成函数相乘，也就是它们的封闭形式相乘。

例题：[拯救世界2](https://www.luogu.com.cn/problem/P2012)

回到本题，显然此题不同的排列是不同的结果，所以要用指数生成函数。

普通基因串的 EGF 为：$e^x$

奇数串的 EGF 为：$\frac12(e^x-e^{-x})$

偶数串的 EGF 为: $\frac12(e^x+e^{-x})$

把它们乘起来，再四次方。

也就是：
$$
\begin{aligned}
&=(\frac14e^x(e^x-e^{-x})(e^x+e^{-x}))^4\\

&=\frac1{256}(e^x(e^{2x}-e^{-2x}))^4\\

&=\frac1{256}(e^{3x}-e^{-x})^4\\

&=\frac1{256}(e^{12}-4e^{-8x}+6e^{4x}-4+e^{-4x})
\end{aligned}
$$

取其结果的 $n$ 次项，但是，因为 $n$ 次项有个 $\frac1{n!}$，所以得到的结果要乘 $n!$，把它抵消。

答案表示为：

$$n![x^n]A(x)$$


$$
\begin{aligned}
&=\frac{n!}{256}(\frac{12^n}{n!}-4\cdot\frac{8^n}{n!}+6\cdot\frac{4^n}{n!}+\frac{(-4)^n}{n!})\\

&=\frac{1}{256}(12^n-4\cdot 8^n + 6 \cdot4^n+(-4)^n)
\end{aligned}
$$

然后呢，因为 $256$ 在 $\bmod\ 1000000000$ 意义下没有逆元，但是当 $n \geq 4,256\mid4
^n$。

所以可以在 $n < 4$ 时特判，$n \geq 4$ 直接快速幂，就可以 AC 本题。

代码如下:

```cpp
#include<cstdio>
using namespace std;
#define int long long
const int mod = 1e9;
template <typename T>
inline void read(T &x) {
	x = 0;
	bool f = 1;
	static char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') 
			f = 0;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	if (!f) x = -x;
}
inline int qpow(int a, int b) {
	int ans = 1;
	while (b) {
		if (b & 1) ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		b >>= 1;
	}
	return ans;
}
signed main(){
    int n;
    while (1) {
    	read(n);
    	if (!n) break;
    	if (n < 4) puts("0");
    	else if (n == 4) puts("24");
		else {
			printf("%lld\n", (((81ll * qpow(12, n - 4) % mod - qpow(8, n - 2) + mod) % mod + 
			6ll * qpow(4, n - 4) % mod) % mod + qpow(mod - 4, n - 4)) % mod);
		}
	}
    return 0;
}
```

~~没卡常都过了，数据真滴水。~~

---


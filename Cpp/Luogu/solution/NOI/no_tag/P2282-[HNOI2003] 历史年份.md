# [HNOI2003] 历史年份

## 题目描述

明天就要考近代史了，小明决定把要背的历史事件，根据事件发生的年份，按顺序从小到大抄在一张纸上。可是他抄的时候，相邻两个年份相隔太近了。例如 $1894,1911,1949$ 这三个时间，由于相隔太近，纸上写的是：`189419111949`。

这使小明很苦恼，于是他准备编写个程序把这些年份还原成应该的样子。那么，怎么才能够正确地还原呢？

首先，这些年份是按时间顺序严格递增排列的，所以，还原后的也必须满足这点要求。但如果仅仅是这样，那么 $1,89,419,111949$ 也满足要求。显然，最后的年份不可能有这么大，所以，小明要求在这个条件下，最后一个数要最小。

加了这个限制后，$18,94,1911,1949$ 也满足条件，但因为是近代史，第一个年份也不会这么早，所以，小明还要在保证最后一个数最小的前提下，第一个数要尽量大。并在保证第一个数最大的情况下，第二个数最大……以此类推。

注意：在本题中，数字前的前导 $0$ 是被允许的。

## 样例 #1

### 输入

```
189419111949
1000010
```

### 输出

```
1894,1911,1949
1,000010
```

# 题解

## 作者：jjsnam (赞：26)

# 写在前面

唉，这题真的是，不愧是黑题啊！整整耗费我了两天连想带调终于做完了，也算是本蒟蒻的第一道黑题（之前的都掉紫了）。

写着题的时候，Day 1 做了这道题的弱化版，然后熬着把这道题的思路捋清了。Day 2 没起来，上课迟到，回家后开始写代码，写出来之后就是调，调了整整一下午，不知道是哪有问题，又跟题解对了对，还是没发现，当时真的是心态炸了，最后发现就是数组没初始化，真的糊了！

所以我就想写这篇题解，思路是一样的，然后增加一些我的理解。

### 前置知识

- DP（**请先完成弱化版 [P1415 拆分数列](https://www.luogu.com.cn/problem/P1415)**）
- 字符串哈希（或者前缀和思想）
- 线段树

### 题目描述（戳这里[查看原题](https://www.luogu.com.cn/problem/P2282)）

给定一个**只有数字**的字符串，要求通过添加任意多个逗号（可以为 $0$），将原字符串拆分成一个**严格单调递增**的数列。多解情况下使数列最后一项最小，第一项的字典序最大（相同情况下满足第二项字典序最大，以此类推）。

测试数据有多组。

# 正文

根据弱化版 [P1415 拆分数列](https://www.luogu.com.cn/problem/P1415)，我们获得了一个 $O(n^3)$ 的算法。这里简单概述一下。

我们定义：
- $f[i]$ 表示**正序**考虑到字符串第 $i$ 位，满足 $i$ **及其之前**已经拆分成严格单调递增数列时，以 $i$ 为**右**端点的最大**左**端点。（满足了使 $f[n]$ 最大，求得最小的最后一项）
- $g[i]$ 表示**倒序**考虑到字符串第 $i$ 位，满足 $i$ **及其之后**已经拆分成严格单调递增数列时，以 $i$ 为**左**端点的最大**右**端点。（满足使 $g[i]$ 尽可能大，也就是字典序尽量大）

对于两个数组有如下转移方程：    
(定义 $Num(i, j)$ 表示字符串中区间 $[i, j]$ 表示的数字)
- $f[i] = \max(j)$，$j$ 满足 $Num(f[j-1], j-1) < Num(j, i) \ \ (1≤j≤i)$；
- $g[i] = \max(j)$，$j$ 满足 $Num(i, j) < Num(j+1, g[j+1]) \ \ (i≤j≤n)$；

这里注意。在正向 DP 完 $f$ 数组后，要将 $f[n]$ 数组的前导零加上，对于 $[f[n],n]$ 内的 $g$ 数组要赋值为 $n$。之后再进行 $g$ 数组的反向 DP。

### 确定优化方向

考虑优化。正向瞪眼法如果没有用，我们尝试“面向数据编程”，也就是通过我们的经验，根据题目中的数据推出我们应该拥有的复杂度。

首先，多组测试数据 $O(T)$ 不可避免。其次，每次 DP 时一定要把 $[1,n]$ 全部遍历一遍，根据经验这块地方也不容易优化，乘上 $O(n)$。现在的 $O(Tn)$ 复杂度已经到达 $2\times10^6$ 级别了。根据合理复杂度在 $10^8$ 以下，最多只能带 $\log$ 或者 $\log^2$。因此，我们最终算法的复杂度大约是 $O(Tn\log n)$。

因此，能给我们优化的无非两个地方，**字符串比较和 DP 时枚举 $j$ 的转移**。

### 优化字符串比较

在我们 naive 的做法里，字符串比较大小是 $O(n)$ 的，显然可以优化，我们来思考我们的比较步骤。

首先，在比较大小的过程中两个字符串中的前导零都是要除去的。单这一步就能把我们卡到 $O(n)$。字符串一直是不变的，何不把每个位置去掉前导零后的位置记录下来呢？

因此我们定义 $l[i]$、$r[i]$ 为字符串中 $i$ 位置向左/右第一个不是 $0$ 的位置。可以通过 $O(n)$ 预处理得出，查询是 $O(1)$ 的。

对于位置 $i$，如果它对应的值是 ```'0'```，那么就有 $l[i] = l[i-1]$、$r[i] = r[i+1]$；否则都是 $i$。


------------
回归字符串。我觉得所有人最初的想法应该都是和前缀和有关。比如下面这个数字串：

```"1145141919810"```

我们希望能够在 $O(1)$ 知道一段区间表示的数字。因而由类似前缀和思想定义 $Sum[i]$ 表示从头到 $i$ 表示的数字，比如 $Sum[6] = 114514$。

因而 $Sum[i] = Sum[i-1] \times 10 + str[i]$。（$str[i]$ 表示 $i$ 位置字符串表示的数字）

所以对于区间 $[i,j]$ 表示的数字有 $Num(i,j) = Sum[j] - Sum[i-1]\times 10^{j-i+1}$。（例如  $Num(3,6) = Sum[6] - Sum[2] \times 10^4 = 114514 - 11\times 10000 = 4514$）

似乎柳暗花明了？甚至连前导零都没必要考虑了，太好了吧？其实不然。注意到 ```unsigned long long``` 也只能表示大概 $18$ 位数字，而我们很有可能拆分数列的位数达到几十或上百，因此超出的位数很容易被卡掉，**直接比较大小是不行的**。


------------
观察上面的式子，似乎很像**哈希**吧？可以自己试一试，虽然不能直接比较大小，但是可以判断两数是否相等。（此时注意将 ```base``` 值改成质数，$10$ 会被卡）

对于两个字符串（已经去除前导零），如果它们长度不相等，那么一定可以通过比较长度判断大小关系。如果它们长度相等，考虑 naive 做法，我们找到第一个同一位但是数字不相等的就可以比较大小了（也就是之前的数字都相等），此时是 $O(n)$。

那么我们现在就是要找到两个字符串的最长公共前缀，然后比较下一位的大小即可。我们刚才演变出的“哈希”给我们提供了 $O(1)$ 判断字符串相等的功能。进而通过观察发现最长公共前缀的长度是满足单调性的，即如果长度 $l$ 不相等，则最长公共前缀长度一定比 $l$ 小，那么我们就可以进行二分。

进而，我们发现去除前导零是 $O(1)$，查找最长公共前缀是 $O(\log n)$，比较后一位大小是 $O(1)$。因此我们比较字符串函数的复杂度成功从 $O(n)$ 优化到了 $O(\log n)$。


------------
#### 深入研究
还记得我们最初分析时定义的 $l[i]$、$r[i]$ 吗？我们可以再深入探究一下它们的性质，因为后面有用（当然可以先看后面再来这里对照）。

先举个例子：     
```"114000000514"```   
容易知道 $r[4] = 10$、$l[9] = 3$ 等等。

我们探究如下性质：

1. 对于位置 $p$，我们想让 $p$ 能包括它之前的所有前导零。那么此时 $p$ 的位置变为 $q$。如何通过两个数组表示 $q$？    
	对此我们分类讨论。
    - 若 $p$ 前有前导零，则 $p-1$ 的位置一定是 $0$，要找到最前的位置，则可以通过找到这一串 $0$ 前第一个不是 $0$ 的位置，向右 $+1$ 即可。     
    我们推得有 $q = l[p-1]+1$。
    - 若 $p$ 前没有前导零，则 $q = p$。但为了让它的性质普遍，我们验证上一种情况的公式是否适用。有我们设定的情况，$l[p-1] = p-1$。  
    因而仍满足 $q = l[p-1]+1 = p$。
    
2. 对于位置 $p$，它所表示的不确定是否 $0$。我们已经求得 $r[p] = R_0$，现在要逆推出可能的最靠前 $p$ 的位置 $q$。（即使 $q$ 能包含 $p$ 的所有前导零）  
我们通过性质 1 举一反三。
	- 若 $p$ 表示 $0$。则可以确定 $R_0-1$ 一定表示 $0$，且 $[p,R_0-1]$ 是一个零串。我们想让 $p$ 包含它前面所有前导零，    
    根据性质 1 我们得出 $q = l[R_0-1]+1$。
    - 若 $p$ 不表示 $0$。则 $r[p] = R_0 = p$。同样通过性质 1，有 $q = l[R_0-1]+1$。
    
有了这些性质，我们就可以继续思考了。

### 优化 DP 转移

考虑之前的转移方法，填表法查之前的状态再一个一个比对是否合法更新答案。DP 的转移方法有时候会成为优化的关键。

查之前的状态因为要一次次比对，贡献可能不连续，所以不能通过诸如单调队列等方法优化。我们不妨改变一下转移方法，用前面更新后面（就是所谓的刷表法），我们尝试一下看看前面对后面有贡献的区间是否满足连续性，连续的话就可以通过一些方法优化了。

以 $f$ 为例。联想之前的转移方程。$j$ 对 $f[i]$ 有贡献当且仅当 $Num(f[j],j)<Num(j+1,i)$。所以对于 $j$，它能有贡献的 $i$ 有哪些？

回想比较函数，只要 $Num(j+1,i)$ 长度更大，则 $j$ 一定能更新 $i$。更小一定不可以，相等则需要跑一遍比较函数。因而满足 $i-(j+1)+1≥j-f[j]+1$。注意考虑前导零的情况，所以严谨写出不等式为 $i-r[j+1]+1≥j-r[f[j]]+1$。     
整理得：$i≥j-r[f[j]]+r[j+1]$。（等号需要特判）

因此，$j$ 所能有贡献的范围是一段连续的范围（最大到 $n$）。最后每个位置的答案是之前有贡献的最大值，那这就变成了一个可以区间赋值的最大值问题。可以通过**线段树优化**。

进而，我们转移的复杂度就从 $O(n^2)$ 变成了 $O(n\log n)$。

转移 $g$ 时略显繁琐，需要用到我们探究的性质。根据刚才的思路 $j$ 能对 $g[i]$ 有贡献当且仅当 $(j-1)-r[i]+1 ≤ g[j] - r[j]+1$，整理得 $r[i] ≥ j-1-g[j]+r[j]$。

不太妙。我们确定了 $r[i]$ 的范围，却无法确定 $i$。很显然，$i$ 前面有多少前导零对 $r[i]$ 无影响，所以我们应该让 $i$ 尽可能的小。这不就是我们的**性质 2** 吗？因此我们确定了最左端 $i ≥ l[j-1-g[j]+r[j]-1]+1$。等号需要特判。如果不满足，则原来的 $r[i] = r[i]+1$。因而求得的 $i = r[i]+1$。注意此时贡献的范围是 $[i,j-1]$。

（我写题解的时候脑抽了一个想法，为什么更新 $f$ 的时候不用 $l[i-1]+1$？注意到右端点是不配拥有前导零的。

### 时间复杂度

这里主要是区分字符串比较和线段树的两个 $\log n$ 是乘法还是加法。注意不是在线段树操作时进行比较函数，所以不满足乘法原理，两者是并行的，所以最终总时间复杂度是 $O(Tn\log n)-O(n)$。

# 代码

### 注意事项
因为有多组测试数据，所以一定要多初始化，嫌麻烦的或者想不出来无脑 ```memset``` 就完事。否则的话牢记，比较函数二分的答案要初始化为 $0$，线段树初始化要将懒标记赋值为 $0$。    
剩下的看看代码细节就好了，主要是不太好调。

```cpp
/* DP + Hash + SegTree */
#include <iostream>
#include <algorithm>
#include <cstring>

#define ls (id << 1)
#define rs (id << 1 | 1)
#define mid ((l + r) >> 1)

using namespace std;
typedef unsigned long long ull;
const int maxn = 2006;
const int base = 131;

ull Pow[maxn];
ull Hash[maxn];
char str[maxn];
int n;
int l[maxn], r[maxn];
int f[maxn], g[maxn];
struct SegmentTree{
    int mx, lazy;
}tr[maxn << 2];

void init(){//初始化
    Pow[0] = 1;
    for (int i = 1; i < maxn; i ++){
        Pow[i] = Pow[i-1] * base;
    }
}

void preTreat(){//每次预处理
    for (int i = 1; i <= n; i ++){
        Hash[i] = Hash[i-1] * base + (str[i] - '0');
    }

    r[n+1] = n+1;
    for (int i = 1, j = n; i <= n; i ++, j --){
        l[i] = str[i] == '0' ? l[i-1] : i, 
        r[j] = str[j] == '0' ? r[j+1] : j;
    }
}

ull getHash(int l, int r){
    return Hash[r] - Hash[l-1] * Pow[r-l+1];
}

bool is_greater(int l1, int r1, int l2, int r2){//[l1,r1] > [l2,r2] ?
    l1 = r[l1], l2 = r[l2]; //去除前导零
    int len1 = r1 - l1 + 1, len2 = r2 - l2 + 1;
    if (len1 > len2) return true;
    if (len1 < len2) return false;

    int L = 0, R = len1, Mid = 0, ans = 0;
    while (L <= R){
        Mid = (L + R) >> 1;
        if (getHash(l1, l1+Mid-1) == getHash(l2, l2+Mid-1)){
            ans = Mid;
            L = Mid + 1;
        }
        else{
            R = Mid - 1;
        }
    }
    if (ans == len1) return false; //完全一样
    int p1 = l1 + ans, p2 = l2 + ans;
    return str[p1] > str[p2];
}

void pushup(int id){
    tr[id].mx = max(tr[ls].mx, tr[rs].mx);
}

void build(int id, int l, int r, int v){
    /* 一定记得清空懒标记！ */
    tr[id].lazy = 0;
    if (l == r){
        tr[id].mx = v;
        return;
    }
    build(ls, l, mid, v);
    build(rs, mid + 1, r, v);
    pushup(id);
}

void pushdown(int id){
    if (tr[id].lazy){
        int temp = tr[id].lazy;
        tr[ls].mx = max(tr[ls].mx, temp);
        tr[rs].mx = max(tr[rs].mx, temp);
        tr[ls].lazy = max(tr[ls].lazy, temp);
        tr[rs].lazy = max(tr[rs].lazy, temp);
        tr[id].lazy = 0;
    }
}

void update(int id, int l, int r, int a, int b, int v){
    if (a <= l && r <= b){
        tr[id].mx = max(tr[id].mx, v);
        tr[id].lazy = max(tr[id].lazy, v);
        return;
    }
    pushdown(id);
    if (a <= mid) update(ls, l, mid, a, b, v);
    if (b > mid) update(rs, mid+1, r, a, b, v);
    pushup(id);
}

int query(int id, int l, int r, int p){
    if (l == r){
        return tr[id].mx;
    }
    pushdown(id);
    if (p <= mid) return query(ls, l, mid, p);
    else return query(rs, mid+1, r, p);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    init();

    while (cin >> (str + 1)){
        n = strlen(str + 1);
        preTreat();
        /* 正向DP */
        build(1, 1, n, 1);
        for (int i = 1; i <= n; i ++){
            f[i] = query(1, 1, n, i);
            int p = i - r[f[i]] + r[i+1];
            if (!is_greater(r[i+1], p, r[f[i]], i)){
                p ++;
            }
            if (p <= n) update(1, 1, n, p, n, i+1);
        }
        
        /* 反向DP */
        build(1, 1, n, 0);
        update(1, 1, n, l[f[n]-1]+1, n, n);
        for (int i = f[n]; i > 0; i --){
            g[i] = query(1, 1, n, i);
            int p = l[max(i-1-g[i]+r[i]-1, 0)] + 1;
            if (!is_greater(i, g[i], p, i-1)){
                p = r[p] + 1;
            }
            if (p <= i-1) update(1, 1, n, p, i-1, i-1);
        }

        /* 输出 */
        for (int i = 1; i <= n; i = g[i] + 1){
            for (int j = i; j <= g[i]; j ++){
                cout << str[j];
            }
            if (g[i] != n) cout << ',';
        }
        cout << endl;
    }

    return 0;
}
```


------------


# 总结
反正这道题确实有水平，本蒟蒻写这道题还有它的题解也收获了很多，可能话多比较繁琐，但我觉得应该能讲得很清楚。
感谢观看！


---

## 作者：qwaszx (赞：16)

截至2018.12.2 A掉这题的除了我都是抄的@_Ressed_ dalao的...真不知道抄题解有什么意思

神仙题 蒟蒻第一次接触到hash判字符串大小、线段树优化dp

弱化版的[P1415 拆分数列](https://www.luogu.org/problemnew/show/P1415)是一道可以在$O(n^3)$时间内通过的题，然后这题直接变成$O(nlogn)$，惹不起

分两趟dp，第一趟正着把最小的最后一个数算出来，然后再倒着把字典序最大的算出来，差不多的，只以第一趟为例说明

先写原题的dp式子,设$f[i]$表示把前$i$个数字拆成单增序列且最后一个数最小时，最后一个数的起始数字下标(也就是在第$f[i]$个数字前面加最后一个逗号)

这样就有$f[i]=max\{j+1|num(f[j],j)<num(j+1,i),1\leq j<i\}$，其中$num(i,j)$表示从第$i$到第$j$个数字所组成的数

这个时候的复杂度是$O(n^3)$

考虑降一次

字符串比较那一个地方的复杂度是$O(n)$的，优化它

朴素做法：找到最长的公共前缀，然后比下一位

$hash$预处理，二分出公共前缀即可做到$O(logn)$

降至$O(n^2\log n)$

然后蒟蒻~~打开了题解~~仔细思考了一番

线段树优化转移！

我们先改变一下dp的处理方式，从填表改为刷表，即由一个$i$去更新其他点

如果不考虑$0$的话，$i$这个点能更新的$j$一定满足$j-i\geq i-f[i]+1$，就是$num(i+1,j)$的位数大于等于$num(f[i],i)$的位数

但这是个必要条件，还需要在位数相同的时候比较一下

这样我们就可以找到$i$能更新的位置的最小值$j$，使用线段树更新$[j,n]$的$f$值(和$i+1$取$max$)

还要取出$i$这一点的$f$值，单点查询即可

这样我们在没有$0$的情况下做到了$O(n\log n)$(字符串比较、查询和修改是并列的$\log n$)

然后就是万恶的$0$，及其难以处理

引入$l[i]$表示$i$左边(含$i$)的第一个非$0$位置，$r[i]$表示$i$右边(含$i$)的第一个非$0$位置

$l,r$可以$O(n)$预处理出来

如果第$i$位是$0$那么$l[i]=l[i-1],r[i]=r[i+1]$，否则$l[i]=r[i]=i$，两端特判

那么现在更新的$j$满足的条件变为$j-r[i+1]+1\geq i-r[f[i]]+1$，再判一下有没有等号

然后就可以把正着的做完了

倒着做的时候要定住最后一个数不动，并且最后一个数的前导零的$f$一开始全都要指向$n$

除此之外还有非常多的细节，具体看代码吧qwq

$O(Tn\log n)$写得极其丑，不吸氧跑不过去qwq

```cpp
// luogu-judger-enable-o2 可爱的洛咕氧气罐
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
unsigned int h[500000],pow[500000];
char st[500000];
int f[500000],n,l0[500000],r0[500000];
void hs_make(char st[],unsigned int h[])
{
    pow[0]=1;
    for(int i=1;i<=strlen(st);i++)h[i]=h[i-1]*233+st[i-1]-48,pow[i]=pow[i-1]*233;
}
unsigned int hs(int l,int r){return h[r]-h[l-1]*pow[r-l+1];}
int xy(int l1,int r1,int l2,int r2)
{
    if(r1-l1+1<r2-l2+1)return 1;
    if(r1-l1+1>r2-l2+1)return 0;
    int l=0,r=r1-l1+1,mid;
    while(l<r)
    {
        mid=(l+r+1)>>1;
        if(hs(l1,l1+mid-1)==hs(l2,l2+mid-1))l=mid;
        else r=mid-1;
    }
    return l!=r1-l1+1&&st[l1+l-1]<st[l2+l-1];//注意如果前缀就是整个字符串要特判
}
struct Segment_tree
{
    int a[200000],tag[200000];
    void build(int rot,int lt,int rt)
    {
        tag[rot]=a[rot]=0;
        if(lt==rt)return;
        int mid=(lt+rt)>>1;
        build(rot<<1,lt,mid),build(rot<<1|1,mid+1,rt);
    }
    void pushdown(int rot,int lt,int rt)
    {
        if(tag[rot])
        {
            int t=tag[rot];tag[rot]=0;
            tag[rot<<1]=max(t,tag[rot<<1]),tag[rot<<1|1]=max(t,tag[rot<<1|1]);
            a[rot<<1]=max(t,a[rot<<1]),a[rot<<1|1]=max(t,a[rot<<1|1]);
        }
    }
    int query(int rot,int lt,int rt,int q)
    {
        if(lt==rt)return a[rot];
        int mid=(lt+rt)>>1;
        pushdown(rot,lt,rt);
        if(q<=mid)return query(rot<<1,lt,mid,q);
        else return query(rot<<1|1,mid+1,rt,q);
    }
    void update(int rot,int lt,int rt,int lq,int rq,int w)
    {
        if(lt>rq||rt<lq)return;
        if(lt>=lq&&rt<=rq)
        {
            a[rot]=max(a[rot],w),tag[rot]=max(tag[rot],w);
            return;
        }
        int mid=(lt+rt)>>1;
        pushdown(rot,lt,rt);
        update(rot<<1,lt,mid,lq,rq,w),update(rot<<1|1,mid+1,rt,lq,rq,w);
        a[rot]=max(a[rot<<1],a[rot<<1|1]);
    }
}seg;//线段树
int main()
{
    while(scanf("%s",st)==1)
    {
        hs_make(st,h);n=strlen(st);
        for(int i=1;i<=n;i++)if(st[i-1]=='0')l0[i]=l0[i-1];else l0[i]=i;r0[n+1]=n+1;//端点特判
        for(int i=n;i>=1;i--)if(st[i-1]=='0')r0[i]=r0[i+1];else r0[i]=i;
//		for(int i=1;i<=n;i++)cout<<l0[i]<<" "<<r0[i]<<endl;
        seg.build(1,0,n);
        for(int i=0;i<n;i++)
        {
            int fi=seg.query(1,0,n,i);
            int t=r0[i+1]+i-r0[fi];
            if(!xy(r0[fi],i,r0[i+1],t))t++;
//			cout<<i<<" "<<fi<<" "<<t<<endl;
            if(t<=n)seg.update(1,0,n,t,n,i+1);
        }
//		for(int i=1;i<=n;i++)cout<<f[i]<<" ";cout<<endl;
        int fn=seg.query(1,0,n,n);
        seg.build(1,0,n);//清树
        seg.update(1,0,n,l0[fn-1]+1,n,n);//先把前导零全都指向n
        for(int i=fn;i>1;i--)
        {
            int fi=seg.query(1,0,n,i);
            int t=l0[max(i-1+r0[i]-fi-1,0)]+1;//不可以是负数，特判
            if(!xy(r0[t],i-1,r0[i],fi))t=r0[t]+1;
//			cout<<i<<" "<<f[i]<<" "<<t<<endl;
            seg.update(1,0,n,t,i-1,i-1);
        }
        int pos=seg.query(1,0,n,1);
        for(int i=1;i<=n;i++)
        {
            putchar(st[i-1]);//普通的输出
            if(i==pos&&i!=n)putchar(','),pos=seg.query(1,0,n,i+1);
        }
        putchar(10);
    }
}
```

---

## 作者：__Ressed__ (赞：8)

P1415 拆分数列的加强版

先考虑弱化版怎么做

设f[i]表示某一串数，最后一个数的右端点是i时，它的左端点的最大值（也就是说，这一串数的最后一个数尽量小）

那么有$f[j]=max\{i+1|num[i+1,j]>num[f[i],i]\}$

这样推下去，f[N]就是最后一个数的最小值

然后我们把它钦定住，再用类似的方式推回来，算出来最前面数的最大值

直接做的话，转移$O(n)$，判断两数是否相等$O(n)$，所以总共是$O(n^3)$的

显然过不了这道题，考虑如何优化。

可以发现这个转移其实是固定左端点，找到一些右端点，使得这个数比当前的数大，那么只要找到第一个比它大的右端点，后面的就都比它大

而且如果不考虑前缀0的话，恰好比它大的那个子串，长度就要么和它相等、要么是它的+1

所以只需要找出来那个长度和它相等的子串，比较他俩的大小，要是比它小就加个1，然后把后面的都更新掉

直接判定是$O(n)$的，但用hash先$O(n)$预处理，就可以做到$O(logn)$，具体做法是二分找出两个子串的LCP，再判断LCP+1的大小

然后更新的时候用一个线段树维护区间取max、单点查询，也可以做到$O(logn)$

所以复杂度$O(Tnlogn)$

然而还有前缀0的问题。这样的话，我们就不能直接找和他长度相等的子串，而是要找去掉前缀0以后和它去掉前缀0以后长度相等的子串

可以记一个nn0[i]表示i位置后面的第一个不是0的位置,pn0[i]表示i位置前面的第一个不是0的位置然后乱搞

倒着做回来的时候都类似，然后我定义的g[i]是表示以i为左端点的最大右端点，也需要很注意前缀0的问题

（有可能我发现长度相等的那个比它小，然后想往前顶一个，这时候应该顶到前面的第一个不为0的位置，否则加一个前缀0还是比它小）

注意g的初值应该是g[pn0[f[N]]+1~f[N]]=N，因为你找到的那个最小值 加上一些前缀0还是最小值，这些都是合法的

需要(?)特判全都是0的情况

代码改来改去的写的很丑，有很多细节写的也很别扭

（不知道为什么，开O2第一个点会OLE）

（本来想用SA来判断子串大小，然后常数太大T了）


```cpp
#include<bits/stdc++.h>
#define pa pair<int,int>
#define CLR(a,x) memset(a,x,sizeof(a))
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn=2020,P=131;

inline ll rd(){
    ll x=0;char c=getchar();int neg=1;
    while(c<'0'||c>'9'){if(c=='-') neg=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*neg;
}

char num[maxn];
int N,M,f[maxn],nn0[maxn],pn0[maxn];
int laz[maxn<<2],ma[maxn<<2];
ull hsh[maxn],bin[maxn];

inline bool bigger(int x1,int x2,int l){
    int a=1,b=l,k=0;
    while(a<=b){
    	int m=a+b>>1;
    	if(hsh[x1+m-1]-hsh[x1-1]*bin[m]==hsh[x2+m-1]-hsh[x2-1]*bin[m]) a=m+1,k=m;
    	else b=m-1;
    }
    if(k>=l) return 0;
    else return num[x1+k]>num[x2+k];
    return 0;
}

inline void pushdown(int p){
    if(!laz[p]) return;
    int a=p<<1,b=p<<1|1;
    ma[a]=max(laz[p],ma[a]),ma[b]=max(laz[p],ma[b]);
    laz[a]=max(laz[a],laz[p]),laz[b]=max(laz[b],laz[p]);
    laz[p]=0;
}

inline void change(int p,int l,int r,int x,int y,int z){
    ma[p]=max(ma[p],z);
    if(x<=l&&r<=y){
        laz[p]=max(laz[p],z);
    }else{
        pushdown(p);
        int m=l+r>>1;
        if(x<=m) change(p<<1,l,m,x,y,z);
        if(y>=m+1) change(p<<1|1,m+1,r,x,y,z);
    }
}

inline int query(int p,int l,int r,int x){
    if(l==r) return ma[p];
    int m=l+r>>1;
    pushdown(p);
    if(x<=m) return query(p<<1,l,m,x);
    else return query(p<<1|1,m+1,r,x);
}

int main(){
    //freopen(".in","r",stdin);
    int i,j,k;
    bin[0]=1;for(i=1;i<=2000;i++) bin[i]=bin[i-1]*P;
    while(~scanf("%s",num+1)){
        N=strlen(num+1);
        for(i=1;i<=N;i++)
        	hsh[i]=hsh[i-1]*P+num[i];
        CLR(ma,0);CLR(laz,0);
        nn0[N+1]=N+1;
        for(i=N;i>=0;i--)
            nn0[i]=(num[i+1]!='0')?i+1:nn0[i+1];
        for(i=1;i<=N;i++)
            pn0[i]=(num[i-1]!='0')?i-1:pn0[i-1];
        change(1,1,N,1,N,1);
        for(i=1;i<=N;i++){
            f[i]=query(1,1,N,i);
            int y=nn0[i],nxt=y+i-nn0[f[i]-1]+1;
            if(bigger(y,nn0[f[i]-1],i-nn0[f[i]-1]+1)) nxt--;
            if(nxt<=N) change(1,1,N,nxt,N,i+1);
        }
        M=f[N];
        CLR(f,0);CLR(ma,0);CLR(laz,0);
        change(1,1,N,pn0[M]+1,M,N);
        for(i=M;i;i--){
            f[i]=query(1,1,N,i);
            int y=nn0[i-(f[i]-nn0[i-1]+1)-1],nxt;
            if(i-y<f[i]-nn0[i-1]+1||(i-y==f[i]-nn0[i-1]+1&&bigger(nn0[i-1],y,f[i]-nn0[i-1]+1))) nxt=pn0[y]+1;
            else nxt=y+1;
            if(nxt<=i-1) change(1,1,N,nxt,i-1,i-1);
        }
        if(N<nn0[0]) printf("%s",num+1); 
        else{
            for(i=1;i<=N;i=f[i]+1){
                for(j=i;j<=f[i];j++)
                    putchar(num[j]);
                if(f[i]!=N) putchar(',');
            }	
        }printf("\n");
    }
    return 0;
}
```

---

## 作者：spdarkle (赞：4)

~~为什么要用线段树，线段树被我的双指针暴打~~

首先我们需要利用哈希实现 $O(\log n)$ 以内比较字符串大小。

然后考虑 DP。

一个自然的 DP 是设 $f_{i,j}$ 为以 $[j,i]$ 作为末段是否可行，容易发现可行性单调，所以设 $f_i$ 为最大的可行 $j$。

转移很简单：

$f_i=\max(1,j [S[f_{j-1},j-1]<S[j,i]])$

考虑算答案，相当于钦定最后一段之后找一个字典序最大的方案，类比 $f$ 可以倒序 DP 设 $g_i$ 表示当前 $[i,j]$ 作为 $[i,n]$ 开头的最大 $j$。

显然初始化 $g_{f_n}=n$，这里有个细节：如果 $f_n$ 前面有一串连续的零，他们的 $g$ 值都是 $n$。

然后考虑显然有：

$g_i=\max(j[S[i,j]<S[j+1,g_{j+1}]])$

朴素实现可以做到 $O(n^2\log n)$

注意到对于限制区间 $[f_i,i],[i,g_i]$ 只有 $O(n)$ 个，可以二分找到其可以作用的更新区间，写出代码后可以发现直接用双指针优化即可。

复杂度 $O(n\log n)$。

事实上二分的过程中比较字符串大小均摊 $O(n\log n)$，这是因为至多会有一次长度相同（事实上如你不嫌麻烦可以直接处理，不用二分，不过作用不大）。

同时这个复杂度应该是这个问题的下界，感觉它并不弱于排序问题。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 105050
int f[N],g[N];
char s[N];
#define ull unsigned long long 
const ull p=13331;
ull pw[N],h[N];
ull get(int l,int r){
    return h[r]-h[l-1]*pw[r-l+1];
}
int pos0[N];
bool com(int l1,int r1,int l2,int r2){
    l1=min(r1+1,pos0[l1]),l2=min(r2+1,pos0[l2]);
    int len1=r1-l1+1,len2=r2-l2+1;
    if(len1==len2){
        if(get(l1,r1)==get(l2,r2))return 0;
        int L=1,R=len1;
        while(L<R){
            int mid=L+R>>1;
            if(get(l1,l1+mid-1)==get(l2,l2+mid-1))L=mid+1;
            else R=mid;
        }
        return s[l1+L-1]<s[l2+L-1];
    }
    return len1<len2;
}
vector<int>gxf[N],gxg[N];
int q[N],ha,ti,delt[N];
signed main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    pw[0]=1;
    for(int i=1;i<=2000;++i)pw[i]=pw[i-1]*p;
    while(cin>>s+1){
        int n=strlen(s+1);
        for(int i=1;i<=n;++i){
            h[i]=h[i-1]*p+s[i];gxf[i].clear();gxg[i].clear();delt[i]=0;
        }pos0[n+1]=n+1;
        int cnt=0;
        for(int i=n;i;--i){
            if(s[i]=='0')pos0[i]=pos0[i+1];
            else pos0[i]=i;
            cnt+=(s[i]=='0');
        }
        if(n-cnt<=1){
            cout<<s+1<<"\n";continue;
        }
        for(int i=1;i<=n;++i)f[i]=g[i]=0;
        int mx=0;
        for(int i=1;i<=n;++i){
            for(auto x:gxf[i])mx=max(mx,x);
            f[i]=mx;++f[i];
            if(i!=n&&com(f[i],i,i+1,n)){
                int l=i+1,r=n;
                while(l<r){
                    int mid=l+r>>1;
                    if(com(f[i],i,i+1,mid))r=mid;
                    else l=mid+1;
                }
                gxf[l].push_back(i);
            }
        }
        s[0]='1';
        g[f[n]]=n;
        set<int>sta;
        int o=f[n]-1;
        for(;o&&s[o]=='0';)g[o]=n,--o;ha=1,ti=0;
        for(int i=o+1;i<=f[n];++i){
            if(i>1&&com(i-1,i-1,i,g[i])){
                int l=1,r=i-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(com(mid,i-1,i,g[i]))r=mid;
                    else l=mid+1;
                }
                delt[i]=l-1;
            }
            else delt[i]=0x3f3f3f3f;
        }
        int up=f[n];
        for(int i=o;i;--i){
            while(delt[up]>=i)--up;
            g[i]=up;--g[i];
            if(i>1&&com(i-1,i-1,i,g[i])){
                int l=1,r=i-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(com(mid,i-1,i,g[i]))r=mid;
                    else l=mid+1;
                }
                delt[i]=l-1;
            }
            else delt[i]=0x3f3f3f3f;
        }
        int p=1;
        while(p<=n){
            for(int i=p;i<=g[p];++i)cout<<s[i];if(g[p]!=n)cout<<",";p=g[p]+1;
        }cout<<"\n";
    }
}
```

---

## 作者：diqiuyi (赞：3)

来个简单好写跑得快的做法。

考虑先求出最后一个数最小是多少，考虑设 $f_i$ 表示最大的 $j$ 满足 $(j,i]$ 合法，那么我们求出 $f_i$ 以后只需要进行一次字符串比较就可以转移到一段后缀上，直接打 tag 转移的部分就 $O(n)$ 了。

求出 $f_n$ 后，我们再从后往前 dp，设 $g_i$ 表示最大的 $j$ 满足 $[i,j)$ 合法，那么求出 $g_i$ 以后它能转移的依然是一个原序列上的后缀，看起来需要线段树优化 dp。但是注意到 $g_i\le g_{i+1}$，那么我们直接双指针就可以把转移的部分做到 $O(n)$ 了。

现在的瓶颈在于字符串比较。写 $O(n)-O(1)$ RMQ 和线性 SA，单组数据就可以做到 $O(n)$ 了。否则可以用二分哈希或者倍增 SA 做到 $O(n\log n)$。

但是由于每一段的长度最多比上一段多 $1$，所以段长的总和是 $O(n\sqrt{n})$ 的，那么我们直接暴力比较复杂度就是 $O(n\sqrt{n})$，常数非常小，成功获得了最优解。
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int n,f[2005],g[2005],nxt[2005],tag[2005],lst[2005],pos[2005];
bool cmp(int p1,int p2,int l){
	for(int i=0;i<l;i++)
		if(s[p1+i]<s[p2+i]) return 1;
		else if(s[p1+i]>s[p2+i]) return 0;
	return 0;
}//这个可以改成直接 substr 比较子串，这么写常数小一点
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	while(cin>>s){
		n=s.size(),s="@"+s,nxt[n+1]=n+1,memset(tag,0,sizeof(tag));
		for(int i=n;i;i--)
			nxt[i]=(s[i]!='0'?i:nxt[i+1]);
		for(int i=1;i<=n;i++) lst[i]=(s[i]!='0'?i:lst[i-1]);
		for(int i=1;i<=n;i++){
			f[i]=max(f[i-1],tag[i]);
			int s1=nxt[f[i]+1],s2=nxt[i+1];
			if(s1>i) tag[s2+1]=i;
			else{
				int l=i-s1+1;
				if(s2+l-1<=n&&cmp(s1,s2,l))
					tag[s2+l-1]=i;
				else if(s2+l<=n) tag[s2+l]=i;
			}
		}
		memset(g,0,sizeof(g)),memset(pos,63,sizeof(pos));
		g[f[n]+1]=n+1;
		int p=f[n];
		while(s[p]=='0') g[p--]=n+1;
		for(int i=f[n]+1;i;i--){
			if(i<=p){
				g[i]=g[i+1];
				while(pos[g[i]]>=i) g[i]--;
			}
			if(i==1) continue;
			int l=g[i]-nxt[i];
			if(i<=l) pos[i]=0;
			else if(cmp(i-l,nxt[i],l)) pos[i]=lst[i-l-1];
			else pos[i]=i-l;
		}
		for(int i=1,now=g[1];i<=n;i++){
			if(i==now) cout<<',',now=g[now];
			cout<<s[i];
		}
		cout<<'\n';
	}
	return 0 ; 
}
```

---

## 作者：lzqy_ (赞：3)

要 $O(n\log n)$ 的题能不能不要用 $T=1000,n=2000$ 这种 b 数据范围限制啊。。。。

以为 $O(n^2)$ 能过，不知道重构了多少遍。

先考虑只最小化最后一个数怎么做。

字典序的刻画在 DP 上是困难的，因为它的优先顺序和 DP 顺序恰好相反。

那倒着做就一致了。

具体地，设 $f_i$ 表示处理完前 $i$ 个，最后一段左端点的最小值。

反过来做相当于越靠后的优先级越大，所以当前最小肯定是最优的，所以这个 DP 刻画是对的。

比较两个数的大小等价于先比较位数，再比较字典序，预处理 $loc$ 之后容易优化到 $O(n\log n)$。

再来看最大化前面的数怎么做。

这种两端优化字典序是比较套路的，只需要根据上次 DP 的值钦定住最后一段，再反过来 DP 即可。

细节很多。

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define il inline
using namespace std;
const int maxn=2010;
const int MAXN=maxn*4;
const int inf=1<<30;
il int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
struct edge{
	int v,to;
}e[MAXN<<1];
int head[MAXN],ecnt;
void addedge(int u,int v){
	e[++ecnt].v=v,e[ecnt].to=head[u],head[u]=ecnt;
}
struct sam{
	int ch[10],fa,len;
}a[MAXN];
int cnt=1,End=1;
int loc[MAXN];
void Insert(int c){
	int t=End,x=End=++cnt,nt=0,nx; a[x].len=a[t].len+1;
	loc[a[x].len]=x;
	for(;t&&!nt;t=a[t].fa,nt=a[t].ch[c]) a[t].ch[c]=x;
	if(!t){a[x].fa=1;return ;}
	if(a[t].len+1==a[nt].len){a[x].fa=nt;return ;}
	nx=++cnt,a[nx].len=a[t].len+1;
	a[nx].fa=a[nt].fa,a[nt].fa=a[x].fa=nx;
	for(int i=0;i<10;i++) a[nx].ch[i]=a[nt].ch[i];
	for(;a[t].ch[c]==nt;t=a[t].fa) a[t].ch[c]=nx;
}
int n;
int Oula[MAXN<<1],Loc[MAXN],CNT;
int st[MAXN<<1][14],dep[MAXN];
int zero[maxn];
int f[maxn],g[maxn];
int ans[maxn];
char c[maxn];
int df[MAXN],dg[MAXN];
int lzf[MAXN],lzg[MAXN];
void clear(){
	memset(zero,0,sizeof(zero));
	memset(dep,0,sizeof(dep));
	memset(g,0,sizeof(g));
	memset(f,0,sizeof(f));
	memset(lzf,0,sizeof(lzf));
	memset(lzg,0,sizeof(lzg));
	memset(df,0,sizeof(df));
	memset(dg,0,sizeof(dg));
	memset(a,0,sizeof(a));
	memset(ans,0,sizeof(ans));
	memset(head,0,sizeof(head));
	CNT=ecnt=0,cnt=End=1;
}
void pushdown(int i){
	df[i<<1]=max(df[i<<1],lzf[i]);
	df[i<<1|1]=max(df[i<<1|1],lzf[i]);
	dg[i<<1]=max(dg[i<<1],lzg[i]);
	dg[i<<1|1]=max(dg[i<<1|1],lzg[i]);
	lzf[i<<1]=max(lzf[i<<1],lzf[i]);
	lzf[i<<1|1]=max(lzf[i<<1|1],lzf[i]);
	lzg[i<<1]=max(lzg[i<<1],lzg[i]);
	lzg[i<<1|1]=max(lzg[i<<1|1],lzg[i]);
}
void Addf(int i,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R){
		df[i]=max(df[i],k);
		lzf[i]=max(lzf[i],k);
		return ;
	}int mid=l+r>>1;
	pushdown(i);
	if(mid>=L) Addf(i<<1,l,mid,L,R,k);
	if(mid<R) Addf(i<<1|1,mid+1,r,L,R,k);
}
void Addg(int i,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R){
		dg[i]=max(dg[i],k);
		lzg[i]=max(lzg[i],k);
		return ;
	}int mid=l+r>>1;
	pushdown(i);
	if(mid>=L) Addg(i<<1,l,mid,L,R,k);
	if(mid<R) Addg(i<<1|1,mid+1,r,L,R,k);
}
int Qf(int i,int l,int r,int x){
	if(l==r) return df[i];
	int mid=l+r>>1;
	pushdown(i);
	if(mid>=x) return Qf(i<<1,l,mid,x);
	else return Qf(i<<1|1,mid+1,r,x);
}
int Qg(int i,int l,int r,int x){
	if(l==r) return dg[i];
	int mid=l+r>>1;
	pushdown(i);
	if(mid>=x) return Qg(i<<1,l,mid,x);
	else return Qg(i<<1|1,mid+1,r,x);
}
void dfs(int fa,int x){
//	printf("!!!%d\n",x);
	dep[x]=dep[fa]+1;
	Oula[++CNT]=x,Loc[x]=CNT;
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fa){
			dfs(x,e[i].v);
			Oula[++CNT]=x;
		} 
}
void init(){
	for(int i=1;i<=CNT;i++) st[i][0]=Oula[i];
	for(int j=1;j<14;j++)
		for(int i=1;i+(1<<j)-1<=CNT;i++)
			if(dep[st[i][j-1]]>dep[st[i+(1<<j-1)][j-1]])
				st[i][j]=st[i+(1<<j-1)][j-1];
			else st[i][j]=st[i][j-1];
}
int lca(int x,int y){
	x=Loc[x],y=Loc[y];
	if(x>y) swap(x,y);
	int Log=log2(y-x+1);
	if(dep[st[x][Log]]>dep[st[y-(1<<Log)+1][Log]])
		return st[y-(1<<Log)+1][Log];
	else return st[x][Log];
}
int lcp(int x,int y){
	return a[lca(loc[x],loc[y])].len;
}
bool cmp1(int l1,int r1,int l2,int r2){
	//s[l1,r1]>s[l2,r2]
	l1+=zero[l1],l2+=zero[l2];
	if(r1-l1+1!=r2-l2+1) return r1-l1+1>r2-l2+1;
	if(lcp(n-l1+1,n-l2+1)>=min(r1-l1+1,r2-l2+1)) return 0;
	return c[l1+lcp(n-l1+1,n-l2+1)]>c[l2+lcp(n-l1+1,n-l2+1)];
}
bool cmp2(int l1,int r1,int l2,int r2){
	//s[l1,r1]<s[l2,r2]
	r2-=zero[r2],r1-=zero[r1];
	if(r1-l1+1!=r2-l2+1) return r1-l1+1<r2-l2+1;
	if(lcp(r1,r2)>=min(r1-l1+1,r2-l2+1)) return 0;
	return c[r1-lcp(r1,r2)]<c[r2-lcp(r1,r2)];
}
bool CMP(int x,int y){return cmp2(1,x,1,y);}
void Mxx(int l,int r,int t){
	for(int i=max(1,l);i<=min(r,n);i++) g[i]=max(g[i],t);
}
void Mx(int l,int r,int t){
	for(int i=max(1,l);i<=min(r,n);i++) f[i]=max(f[i],t);
}
void Print(int j){
	if(j==n) return ;
	ans[j]=1,Print(g[j+1]);
}
int main(){
//	freopen("CF.in","r",stdin);
//	freopen("CF.out","w",stdout);
	while(scanf("%s",c+1)!=EOF){
		if(c[1]<'0'||c[1]>'9') return 0; 
		n=strlen(c+1),zero[n+1]=0;
		for(int i=n;i;i--)	
			if(c[i]=='0') 
				zero[i]=zero[i+1]+1;
			else zero[i]=0;
		for(int i=n;i;i--) Insert(c[i]-'0');
		for(int i=2;i<=cnt;i++)
			addedge(i,a[i].fa),addedge(a[i].fa,i);
		dfs(0,1),init();
		Addf(1,1,n,1,n,1);
		for(int i=1;i<=n;i++){
			f[i]=Qf(1,1,n,i);
			int j=f[i],len=i-j+1-zero[j];
			Addf(1,1,n,i+1+zero[i+1]+len,n,i+1);
			if(i+1+zero[i+1]+len-1<=n&&cmp1(i+1,i+1+zero[i+1]+len-1,j,i))
				Addf(1,1,n,i+1+zero[i+1]+len-1,i+1+zero[i+1]+len-1,i+1);
		}
//		for(int i=1;i<=n;i++)
//			printf("%d ",f[i]);
//		printf("\n");
		int LLL=f[n];
		while(LLL-1>0&&c[LLL-1]=='0') LLL--;
		Addg(1,1,n,LLL,f[n],n);
		for(int i=f[n];i>1;i--){
			g[i]=Qg(1,1,n,i);
			if(!g[i]) continue;
			int j=g[i],len=j-i+1-zero[i];
			if(1){
				int l=1,r=i-1,mid;
				while(r>l){
					mid=l+r>>1;
					if(i-mid-zero[mid]<len) r=mid;
					else l=mid+1;
				}
				if(i-l-zero[l]<len) Addg(1,1,n,l,i-1,i-1);
			}
			if(1){
				int l=1,r=i-1,mid;
				while(r>l){
					mid=l+r>>1;
					if(i-mid-zero[mid]<=len) r=mid;
					else l=mid+1;
				}
				if(i-l-zero[l]==len&&cmp1(i,j,l,i-1)) 
					Addg(1,1,n,l,i-1,i-1);
			}
		}
//		for(int i=1;i<=n;i++)
//			printf("%d ",g[i]);
//		printf("\n");
		Print(g[1]=Qg(1,1,n,1)),ans[n]=0;
		bool fl=0;
		for(int i=1;i<=n;i++){
			putchar(c[i]),fl|=(c[i]!='0');
			if(ans[i]&&fl) putchar(',');
		}putchar('\n');
		clear();
	}
	return 0;
} 
```

---

## 作者：OIer_Eternity (赞：3)

# Announcement

- Programmed on `2024/3/1` & `2024/3/2`
- Written on `2024/3/2`

# 题目来源

- [洛谷 P1415（简单版）](https://www.luogu.com.cn/problem/P1415)
- [洛谷 P2282（进阶版）](https://www.luogu.com.cn/problem/P2282)

# Description

给定一个仅由数字构成的字符串 $s$，用 `,` 将其划分为若干个正整数，使其严格递增。

求在满足最后一个数字最小的情况下，字典序最大（第一个数最大，在此基础上第二个数最大……）的方案。

- 简单版：$|s|\le500$。
- 进阶版：有 $T$ 组询问（$T\le1000$），且每组数据均满足 $|s|\le2000$。

# 前置知识（进阶版）

### 字符串哈希

给定一个质数 $p$ 和一个模数 $q$，并将字符串变为一个 $p$ 进制数，并用前缀和数组 $Hash$ 记录。

则 $Hash[i]=(Hash[i-1]\times p+s[i]-c_0)\bmod q$，这里的 $c_0$ 可以是字符 `0` 或 `A` 等，根据需要选取。

一般而言 $p=131~\text{or}~13331$，$q=2^{64}$ 时较不容易冲突（可直接用 `unsigned long long` 存储），之后就特意不写出取模了。

那么如何求出 $s[l\cdots r]$ 的哈希值呢？

结论是 $Hash[r]-Hash[l]\times p^{r-l+1}$。

举个例子，对于 $abcde$，$Hash(de)=Hash(abcde)-Hash(abc00)=Hash(abcde)-Hash(abc)\times p^2$，这里的 $0$ 表示空字符（之前的 $c_0$）。

# Solution

### 简单版

首先考虑简单版。

设 $f[i]$ 表示把前 $i$ 个数按照条件划分后，最后一个数字最大的起始下标为 $f[i]$（此时最后一个最小）。

若将 $s[x\cdots y]$ 表示为 $s$ 中下标属于 $x$ 到 $y$ 的字符组成的数字，转移方程：
$$
f[i]=\max\{j\big|j\in[1,i]\cap\Z,s[f[j-1]\cdots j-1]<s[i\cdots j]\}
$$
初始化 $f[1]=1$，这样我们就求出了最后一个数的最小值，接着考虑字典序的限制。

设 $g[i]$ 表示把 $[i,n]$ 按照条件划分后，在保证最后一个数字为之前求出的最小值 $s[f[n]\cdots n]$ 的前提下，第一个数字最大的终止下标为 $g[i]$（此时第一个数最大）。

转移方程：
$$
g[i]=\max\{j\big|j\in\big[i,|s|\big]\cap\Z,s[i\cdots j]<s[j+1,g[j+1]]\}
$$
正序求 $f[i]$，再倒序求 $g[i]$。

初始化 $g[f[n]]=n$，注意 $f[n]$ 前面连续的一段零也需要令其 $g[i]=n$，因为前导零对最后一个数字的大小无影响，且还能使 $g[i]$ 变大，从而更有可能转移。

最后输出即可。

比较两个字符串需要 $O(|s|)$，枚举 $f[i],g[i]$ 的下标需要 $O(|s|)$，转移枚举需要 $O(|s|)$，总的需要 $O(|s|^3)$，可以通过简单版。

### 进阶版

然而，单次询问时间复杂度其实可以优化到 $O(|s|\log|s|)$。

首先发现比较字符串大小可以通过哈希二分两个字符串相同的前缀，进而比较大小，可以降到 $O(\log|s|)$。

而转移过程显然是需要优化的。

我们改变转移方式，变为主动转移。

先以 $f[i]$ 为例，考虑对于 $i$ 能够转移至哪些下标。

一个下标 $j$ 能够被 $i$ 转移，其必要条件为 $[f[i],i]$ 的长度小于 $[i+1,j]$，充分条件为 $[f[i],i]$ 的长度小于等于 $[i+1,j]$。

然而由于可能存在前导零，我们可以引入 $l[i]$ 表示第 $i$ 个位置及之前第一个不为 $0$ 的位置下标，即 $l[i]=\max\{j|j\in[1,i]\cap\Z,s[j]!=0\}$；$r[i]$ 表示第 $i$ 个位置及之后第一个不为 $0$ 的位置下标，即 $r[i]=\min\{j|j\in\big[i,|s|\big]\cap\Z,s[j]!=0\}$。

因此可以得出 $j$ 能被转移的必要条件为 $j-r[i+1]+1>i-r[f[i]]+1$ 即 $j>i+r[i+1]-r[f[i]]$。

我们需要对 $j=i+r[i+1]-r[f[i]]$ 的情况进行判断，设 $x=i+r[i+1]-r[f[i]]$，则：

- 若 $s[i+1\cdots x]>s[f[i]\cdots i]$（用字符串哈希比较），则令 $\forall j\in\big[x,|s|\big],f[j]=\max(f[j],f[i])$；
- 否则，令 $\forall j\in\big(x,|s|\big],f[j]=\max(f[j],f[i])$。

于是我们发现，可以利用线段树优化转移过程，区间只需记录最大值和懒标记即可。

同理，对于 $g[i]$，$j$ 能被 $i$ 转移，其必要条件为 $[j,i-1]$ 的长度小于 $[i,g[i]]$，充分条件为 $[j,i-1]$ 的长度小于等于 $[i,g[i]]$。

因此可以得出 $j$ 能被转移的充分条件为 $i-1-r[j]+1\ge g[i]-r[i]+1$ 即 $r[j]\ge i-1+r[i]-g[i]$。

似乎无法求出 $j$ 的取值范围？

其实不然，我们发现可以推出 $j$ 能被转移的充分条件为 $j\ge l[i-1+r[i]-g[i]-1]+1$。

为什么呢？若 $j$ 左侧不是 $0$ 则 $j\ge i-1+r[i]-g[i]$，与上面的式子相符；否则，由于 $\Big[l[i-1+r[i]-g[i]-1]+1],r\big[l[i-1+r[i]-g[i]-1]+1]\big]\Big)$ 的 $r$ 值都相同，都为 $i-1+r[i]-g[i]$，也相符。

我们需要对 $j=l[i-1+r[i]-g[i]-1]+1$ 的情况进行判断，设 $x=l[i-1+r[i]-g[i]-1]+1$，则：

- 若 $s[i\cdots g[i]]>s[x\cdots i-1]$（用字符串哈希比较），则令 $\forall j\in\big[x,i\big),g[j]=\max(g[j],g[i])$；
- 否则，令 $\forall j\in\big(r[x],i\big),g[j]=\max(g[j],g[i])$，因为 $r[x]$ 即为满足 $r[j]=i-1+r[i]-g[i]$ 的最大下标 $j$ ，加 $1$ 就可以使得 $r[j]>i-1+r[i]-g[i]$。

注意类似简单版中的前导零等问题，这里不再赘述。

最后输出即可，由于判断字符串大小和线段树只是并列的，总复杂度 $O(T|s|\log|s|)$。

# Conclusion

- 字符串比较可以用二分+哈希从 $O(n)$ 优化到 $O(\log n)$。
- 动态规划转移时，可以考虑主动、被动两种不同的方式，进而找到不同的优化方法。

# Code

### 简单版

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[505],g[505]; // f[i]-把s[1~i]划分为递增数列，最后一个数最小为s[f[i]~i]；g[i]-在最后一个数最小的情况之下，把s[i~n]划分为递增数列，第一个数最大为s[i~g[i]]
char s[505];
string get(int x,int y){
    bool Flag=0;
    string res="";
    for (int i=x;i<=y;i++){
        if (s[i]!='0') Flag=1;
        if (Flag) res+=s[i];
    }
    return res;
}
bool cmp(string x,string y){
    if (x.size()!=y.size()) return x.size()<y.size();
    return x<y;
}
int main(){
    scanf(" %s",s+1),n=strlen(s+1);
    f[1]=1;
    for (int i=2;i<=n;i++) for (int j=i;j;j--) if (cmp(get(f[j-1],j-1),get(j,i))){f[i]=j;break;}
    int t=0;
    for (int i=f[n]-1;i;i--)
        if (s[i]=='0') g[i]=n;
        else{t=i;break;}
    g[f[n]]=n;
    for (int i=t;i>0;i--) for (int j=f[n]-1;j>=i;j--) if (cmp(get(i,j),get(j+1,g[j+1]))){g[i]=j;break;}
    for (int i=1;i<=n;i=g[i]+1){
        for (int j=i;j<=g[i];j++) putchar(s[j]);
        if (g[i]!=n) putchar(',');
    }
    return 0;
}
```

### 进阶版

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[2005],g[2005],l[2005],r[2005]; // l[i]-i左侧第一个非零的位置的下标 r[i]-右侧
unsigned long long Hash[2005],power[2005];
const int p=131;
char s[2005];
unsigned long long getHash(int l,int r){
    if (l>r) return 0;
    return Hash[r]-Hash[l-1]*power[r-l+1]; // 如：s=ABCDE Hash(DE)=HASH(ABCDE)-HASH(ABC)*P^2=HASH(ABCDE)-HASH(ABC00)
}
struct Node{
    int l,r,Max,lazy;
}tree[8005];
void pushup(int p){
    tree[p].Max=max(tree[p<<1].Max,tree[p<<1|1].Max);
}
void pushdown(int p){
    if (tree[p].lazy){
        tree[p<<1].lazy=max(tree[p<<1].lazy,tree[p].lazy);
        tree[p<<1|1].lazy=max(tree[p<<1|1].lazy,tree[p].lazy);
        tree[p<<1].Max=max(tree[p<<1].Max,tree[p].lazy);
        tree[p<<1|1].Max=max(tree[p<<1|1].Max,tree[p].lazy);
        tree[p].lazy=0;
    }
}
void build(int p,int l,int r,int x){
    tree[p].l=l,tree[p].r=r,tree[p].lazy=0;
    if (l==r){
        tree[p].Max=x;
        return;
    }
    int Mid=(l+r)>>1;
    build(p<<1,l,Mid,x);
    build(p<<1|1,Mid+1,r,x);
    pushup(p);
}
int get(int p,int k){
    if (tree[p].l==tree[p].r) return tree[p].Max;
    pushdown(p);
    int Mid=(tree[p].l+tree[p].r)>>1;
    if (k<=Mid) return get(p<<1,k);
    return get(p<<1|1,k);
}
void update(int p,int l,int r,int d){
    if (l<=tree[p].l&&tree[p].r<=r){
        tree[p].Max=max(tree[p].Max,d);
        tree[p].lazy=max(tree[p].lazy,d);
        return;
    }
    pushdown(p);
    int Mid=(tree[p].l+tree[p].r)>>1;
    if (l<=Mid) update(p<<1,l,r,d);
    if (r>Mid) update(p<<1|1,l,r,d);
    pushup(p);
}
bool cmp(int l1,int r1,int l2,int r2){ // [l1,r1]<[l2,r2]?
    l1=r[l1],l2=r[l2]; // 去除前导0
    if (r1-l1+1!=r2-l2+1) return r1-l1+1<r2-l2+1;
    int l=0,r=r1-l1+1;
    while (l<r){
        int Mid=(l+r+1)>>1;
        if (getHash(l1,l1+Mid-1)==getHash(l2,l2+Mid-1)) l=Mid;
        else r=Mid-1;
    }
    return l<r1-l1+1&&s[l1+l]<s[l2+l];
}
int main(){
    power[0]=1;
    for (int i=1;i<=2000;i++) power[i]=power[i-1]*p;
    while (~scanf(" %s",s+1)){
        n=strlen(s+1);
        for (int i=1;i<=n;i++) Hash[i]=Hash[i-1]*p+s[i]-'0';
        for (int i=1;i<=n;i++)  
            if (s[i]=='0') l[i]=l[i-1];
            else l[i]=i;
        r[n+1]=n+1;
        for (int i=n;i;i--)  
            if (s[i]=='0') r[i]=r[i+1];
            else r[i]=i;
        // 正向DP f[i]
        build(1,1,n,1); // 初始化：f[i]=1
        for (int i=1;i<=n;i++){
            f[i]=get(1,i);
            int x=i+r[i+1]-r[f[i]];
            if (!cmp(f[i],i,i+1,x)) x++;
            if (x<=n) update(1,x,n,i+1);
        }
        // 逆向DP g[i]
        build(1,1,n,0);
        update(1,l[f[n]-1]+1,n,n);
        for (int i=f[n];i;i--){
            g[i]=get(1,i);
            int x=l[max(r[i]-g[i]+i-1-1,0)]+1;
            if (!cmp(x,i-1,i,g[i])) x=r[x]+1;
            if (x<=i-1) update(1,x,i-1,i-1);
        }
        for (int i=1;i<=n;i=g[i]+1){
            for (int j=i;j<=g[i];j++) putchar(s[j]);
            if (g[i]!=n) putchar(',');
        }
        puts("");
    }
    return 0;
}
```

---

## 作者：RainySoul (赞：1)

搞了差不多一天才玩会的神仙题。

### 题意

你需要把一个字符串划分成一个严格上升序列，最小化最后一个数字，并在此基础上保证此序列的字典序尽量大。

### 暴力 dp 做法

建议先做了此题弱化版 [P1415](https://www.luogu.com.cn/problem/P1415)。

下面记 $get(l,r)$ 为截取原字符串第 $l$ 到 $r$ 位得到的数字。

$O(n^3)$ 的 dp 是不难做的，设 $f_i$ 表示得到 $[1,i]$ 这一段**最小化最后一个数**的合法方案下**最后一个数的开头位置**（即现在最后一个数字是 $get(f_i,i)$）。

那么转移是好想的，对于一个 $f_i$ 你希望找出出所有满足 $get(f_{j-1},j-1) < get(j,i)$ 中最大的一个 $j$，倒序枚举 $j$ 找出第一个满足条件的即可。

然后你求完 $f_n$ 之后就相当于限定好了最后一个数是啥，接下来就处理在 $[1,f_n-1]$ 这一段保证字典序最大的限制。

你希望第一个数尽可能地大，这其实和最后一个数尽可能小是差不多的，你把上面求 $f_i$ 的过程倒过来就可以了。设 $dp_i$ 为得到 $[i,f_n-1]$ 这一段**最大化第一个数**的合法方案下**第一个数的结束位置**。转移也是类似的，找出满足 $get(i,j) < get(j+1,dp_{j+1})$ 最大的一个 $j$，倒序枚举 $j$ 找出第一个满足条件的即可。

按照以上思路，暴力比较字符串单次是 $O(n)$ 的，单组数据的总时间复杂度为 $O(n^3)$。注意处理 $f_n-1$ 前面连着的一段 $0$，它们都应该被划分到最后一个数去。

核心代码如下：

```cpp
for(int i=1;i<=n;i++){
	f[i]=1;
	for(int j=i;j>=1;j--){
		if(compare(get(f[j-1],j-1),get(j,i))){//compare 就是暴力比较第一个字符串是否小于第二个
			f[i]=j;
			break;
		}
	}
}
dp[f[n]]=n;
int start=f[n]-1;
while(s[start]=='0')dp[start]=n,start--;
for(int i=start;i>=1;i--){
	for(int j=start;j>=i;j--){
		if(compare(get(i,j),get(j+1,dp[j+1]))){
			dp[i]=j;
			break;
		}
	}
}
```

当然，这个做法扔到本题来仅能获得可怜的 `20pts`。

### 优化

#### 快速比较两字符串大小

注意到上面我们比较两字符串大小是直接 $O(n)$ 一个一个字符比的，有大大滴优化前途。可以先哈希预处理一下，然后求出两个串公共前缀的长度，显然这是具有单调性的。哈希判等是 $O(1)$ 的，二分是 $O( \log n)$ 的，现在你实现了 $O( \log n)$ 比较两个字符串大小。

还需要注意的一点是前导零的处理，在进行比较之前应该先把前导零扔掉。但是如果每次都暴力去前导零又是 $O(n)$ 的了，前面就优化了个寂寞，所以你需要先预处理出来每个位置后面第一个非零位是哪一位，记为 $hz_i$（我自己非零则 $hz_i=i$）。那么比较之前 $O(1)$ 跳一下就去除了前导零。

```cpp
bool compare(int al,int ar,int bl,int br){
	bl=hz[bl];al=hz[al];//处理前导零 
	int lena=ar-al+1,lenb=br-bl+1;
	if(lena!=lenb)return (lena<lenb);//长度不等的可以直接 return 了
	int l=0,r=lena,temp=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(hash[al+mid-1]-hash[al-1]*pw[mid]==hash[bl+mid-1]-hash[bl-1]*pw[mid]){
			l=mid+1;
			temp=mid;
		}
		else r=mid-1;
	}
	if(temp==lena)return 1;
	return (s[al+temp]<s[bl+temp]);//比较第一个不同的字符
}
```

#### 转移优化

我们换一种方式看这个转移，由填表法改为刷表法，即更新 $f_i$ 的时候，我们不是对于一个 $i$ 找到第一个合法的 $j$，而是由一个 $j$ 向所有能贡献到的 $i$ 转移。

继续往下思考，一个 $j$ 能贡献到的 $i$ 是要满足 $get(f_j,j)<get(j+1,i)$ 的，明显在 $i$ 不断增大的过程中，$get(j+1,i)$ 也是不断增大的，所以只要求出第一个能贡献到的 $i$，区间 $[i,n]$ 就都是能贡献到的了。

去掉前导零后，当 $get(j+1,i)$ 的位数大于 $get(f_j,j)$ 的时候一定是满足 $get(f_j,j)<get(j+1,i)$ 的，只有位数相等的地方需要比较一下。

然后你发现 $j$ 贡献 $f_i$ 的这个过程就是将区间 $[i,n]$ 的 $f_i$ 进行 $f_i=\max(f_i,j+1)$ 操作，同时你对于一个 $j$ 还要快速取出 $f_j$。

挂一个维护区间最大值，支持单点查询的线段树就轻松解决了。

类似的 $dp_i$ 就是倒过来做就行了。

这样时间复杂度 $O(Tn \log n)$，做完了。

实现细节较多，详见代码注释，码量不太大，但是感觉巨难调。

AC code（人傻常数大，需要吸氧）：

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define hash zyx
using namespace std;
const int N=5010;
string s; 
ull hash[N],pw[N];
int f[N],dp[N],hz[N],qz[N],w[N],lazy[N],n;
bool compare(int al,int ar,int bl,int br){
	bl=hz[bl];al=hz[al];
	int lena=ar-al+1,lenb=br-bl+1;
	if(lena!=lenb)return (lena<lenb);
	int l=0,r=lena,temp=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(hash[al+mid-1]-hash[al-1]*pw[mid]==hash[bl+mid-1]-hash[bl-1]*pw[mid]){
			l=mid+1;
			temp=mid;
		}
		else r=mid-1;
	}
	if(temp==lena)return 1;
	return (s[al+temp]<s[bl+temp]);
}
void pushup(int u){
	w[u]=max(w[u*2],w[u*2+1]);
}
void maketag(int u,int k){
	w[u]=max(w[u],k);
	lazy[u]=max(lazy[u],k);
} 
void pushdown(int u){
	maketag(u*2,lazy[u]);
	maketag(u*2+1,lazy[u]);
	lazy[u]=0;
}
void build(int u,int l,int r,int k){
	if(l==r){
		w[u]=k;
		return;
	}
	int mid=(l+r)>>1;
	build(u*2,l,mid,k);
	build(u*2+1,mid+1,r,k);
	pushup(u);
}
void update(int u,int l,int r,int x,int y,int k){
	if(x<=l&&r<=y){
		maketag(u,k);
		return;
	}
	int mid=(l+r)>>1;
	pushdown(u);
	if(mid>=x)update(u*2,l,mid,x,y,k);
	if(mid<y)update(u*2+1,mid+1,r,x,y,k);
	pushup(u);
}
int query(int u,int l,int r,int x){
	if(l==r)return w[u];
	int mid=(l+r)>>1;
	pushdown(u);
	if(mid>=x)return query(u*2,l,mid,x);
	else return query(u*2+1,mid+1,r,x);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	pw[0]=1;
	for(int i=1;i<=N-10;i++)pw[i]=pw[i-1]*53;//pw[i]=pow(53,i) 
	while(cin>>s){
		n=s.size();
		s=' '+s;
		hz[n+1]=n+1;
		for(int i=n;i>=1;i--){
			if(s[i]=='0')hz[i]=hz[i+1];
			else hz[i]=i;	
		}
		for(int i=1;i<=n;i++){
			if(s[i]=='0')qz[i]=qz[i-1];
			else qz[i]=i;
		}
		memset(lazy,0,sizeof lazy);//别忘记初始化 lazy 
		for(int i=1;i<=n;i++)hash[i]=hash[i-1]*53+s[i];//单哈希 自然溢出 
		build(1,1,n,1);//初始化 f[i]=1 
		for(int i=1;i<=n;i++){
			f[i]=query(1,1,n,i);
			int j=i-hz[f[i]]+hz[i+1];
			if(compare(i+1,j,f[i],i))j++;
			if(j>n)continue;//小心别越界了 
			update(1,1,n,j,n,i+1);
		}
		memset(lazy,0,sizeof lazy);
		build(1,1,n,0);//初始化 dp[i]=0 
		update(1,1,n,qz[f[n]-1]+1,n,n);//处理 f[n]-1 前面连着的一堆 0
		for(int i=f[n];i>=1;i--){
			dp[i]=query(1,1,n,i);
			int j=qz[max(i-1-dp[i]+hz[i]-1,0)]+1;
			if(compare(i,dp[i],j,i-1))j=hz[j]+1;
			if(j>i-1)continue;//小心别越界了 
			update(1,1,n,j,i-1,i-1);
		}
		for(int i=1;i<=n;i=dp[i]+1){
			for(int j=i;j<=dp[i];j++)cout<<s[j];
			if(dp[i]+1<=n)cout<<",";//这个是特判一下最后一个 ',' 
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：Super_Cube (赞：1)

# Solution

设 $f_i$ 表示将 $1\sim i$ 位划分成递增数，最后一个数最小为 $[f_i,i]$。转移：$\displaystyle f_i=\max_{j=1,[f_{j-1},j-1]<[j,i]}^ij$。

设 $g_i$ 表示将 $i\sim n$ 位划分成递增数，第一个数最大为 $[i,g_i]$。转移：$\displaystyle g_i=\max_{j=i,[i,j]<[j+1,g_{j+1}]}^{f_n-1}j$，初始化 $g_{f_n}=n$。

问题在于末尾的 0，应该从 $f_n$ 开始往前找到第一个非 1 位置，中间这一坨的 $g$ 应该全部初始化为 $n$。

最后就是每次把 $[i,g_i]$ 这一段输出，然后 $i\gets g_i+1$。

时间复杂度 $O(Tn^2)$。

前面的 dp 是逆推形式，把它改成顺推，即考虑每个 $j$ 对哪些 $i$ 有贡献，发现每一个都是一段区间，利用线段树写区间最大值就好了，时间复杂度 $O(Tn\log n)$。

---

## 作者：262620zzj (赞：1)

# 前言

某天比赛题目，感觉很难没做，但下午教练让我补上午比赛的题目，于是被迫开了这道题。

# 朴素做法

动态规划。第一遍求出最后的数字最小是多少，第二遍求出在最后数字最小的前提下，字典序最大的方案。设 $f_i$ 表示考虑 $s[1\sim i]$，序列递增、最后一个数字最小的情况下，最后一个逗号在 $f_i$ 这个位置后面。$g_i$ 表示考虑 $s[i\sim n]$ 序列递增、字典序最大、最后一个数字最小的情况下，第一个逗号在 $g_i$ 这个位置后面。
$$f_i=\max j$$
$$j<i,num(f_j+1,j)<num(j+1,i)$$
$$g_i=\max j$$
$$j\ge i,num(i,j)<num(j+1,g_j)$$
其中 $num(a,b)$ 表示 $s[a\sim b]$ 所组成的数字的大小。
这么做的话，枚举 $i,j$ 加上字符串比较，一共就是 $O(n^3)$。

# 优化字符串比较

首先，子串比较大小是显然可以优化的，方法很多。我使用的是 SA。对于 $s[a\sim b],s[c\sim d]$，求出 $lcp(suffix(a),suffix(c))=\min_{rk_a+1\le i \le rk_c} height_i$，若 $lcp\ge \min(len1,len2)$ 说明有一个子串被 $lcp$ 完全包含，此时直接比较长短。否则，比较 $s[a+lcp],s[c+lcp]$ 也就是公共前缀结束后的下一位。这一部分预处理 $O(n\log n)$，比较大小 $O(1)$。

# 优化状态转移

以计算 $f$ 为例。换一种方式转移，如果我们采取用一个位置去更新别的位置的方式，就会发现对于一个位置 $i$，当 $f_i$ 确定了，那么所有**可能**被他更新的位置 $j$ 组成一个连续区间。因为一个数字串，不论往它的左边还是右边加一个数字，数值肯定是单调不下降，有变大的趋势，至少不会变小。

先考虑没有 0 的情况怎么做。对于 $i$，他可以更新的 $j$，满足 $num(f_i+1,i)<num(i+1,j)\Leftrightarrow i-f_i\le j-i\Leftrightarrow j\ge 2i-f_i$，等号能不能取需要比较一下相等时两串的大小。显然因为没有 0，所以两串长度不等时，长度决定大小。

加入 0 就要复杂些了。我们预处理出 $l_i,r_i$ 分别表示 $i$ 左、右侧第一个非 0 位置（包括自己）。此时不等式转化为 $num(r_{f_i+1},i)<num(r_{i+1},j)\Leftrightarrow i-r_{f_i}\le j-r_{i+1}+1\Leftrightarrow j\ge i+r_{i+1}-r_{f_i+1}$。

$g$ 的计算类似。没有 0：$num(j,i)<num(i+1,g_{i+1})$；有 0：$num(r_j,i)<num(r_{i+1},g_{i+1})$。到这里不太好做，因为这里变成了 $r_j$。没关系，我们先找到 $j'$ 满足 $i-j'=g_{i+1}-r_{i+1}$，由于 $i$ 是已知的，所以很好计算。$j'+1$ 必定可行，因为$num(r_{i+1},g_{i+1})$ 不含前导 0，并且长度还更长，所以显然更大。然后比较 $num(r_{j'},i),num(r_{i+1},g_{i+1})$，就可以知道 $j'$ 是否可行。然后我们取 $l_{j'-1}<j\le i$ 的区域转移即可。因为 $j'$ 左侧的非 0 位置，必定是不符合要求的。因为这些位置到 $i$ 组成的数字，没有前导 0 且长度还更大，唯一一种长度相等的情况也比较过了。这样我们就可以 $O(1)$ 计算出需要转移的区间，用线段树优化到单次 $O(\log n)$。

# 总结

动态规划+线段树+后缀数组。后缀数组需要求出 $height$ 的 ST 表，线段树要求支持区间内每个数和一个新数都取一遍较大值，和单点查询。复杂度 $O(Tn\log n)$。

- 代码细节很多，注意细节。
- 转移时要注意上下界，不能超出 $1\sim n$ 的范围。
- 注意仔细思考 $i,l_i,r_i$ 的区别。
- 更多问题可以参考代码理解。
- 代码比较难调，不建议写此题。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N=2005;
int n,l0[N],r0[N],f[N],g[N];
bool comma[N];
string s;
namespace SGT{
    constexpr int M=4100;
    int l[M],r[M],a[M],tag[M];
    #define ls (p<<1)
    #define rs (p<<1|1)
    inline void update_tag(int p,int tt){
        a[p]=max(a[p],tt);
        tag[p]=max(tag[p],tt);
    }
    inline void push_down(int p){
        if(~tag[p]){
            update_tag(ls,tag[p]);
            update_tag(rs,tag[p]);
        }
        tag[p]=-1;
    }
    inline void build(int p,int L,int R){
        l[p]=L,r[p]=R,tag[p]=-1,a[p]=0;
        if(L==R)return;
        int mid=L+R>>1;
        build(ls,L,mid);
        build(rs,mid+1,R);
    }
    inline void take_max(int p,int L,int R,int k){
        if(L>R)return;
        if(r[p]<L||l[p]>R)return;
        if(L<=l[p]&&r[p]<=R)return void(update_tag(p,k));
        push_down(p);
        take_max(ls,L,R,k);
        take_max(rs,L,R,k);
    }
    inline int query(int p,int z){
        if(l[p]==r[p])return a[p];
        push_down(p);
        int mid=l[p]+r[p]>>1;
        if(z<=mid)return query(ls,z);
        else return query(rs,z);
    }
}
namespace SA{
    int V,buc[N],sa[N],sa2[N],rk[N],rk2[N],height[N],st[N][11];
    inline void figure(){
        memset(buc,0,sizeof(buc));
        for(int i=1;i<=n;i++)buc[rk2[i]=s[i]]++;
        for(int i=1;i<=127;i++)buc[i]+=buc[i-1];
        for(int i=n;i>=1;i--)sa[buc[rk2[i]]--]=i;
        V=0;
        for(int i=1;i<=n;i++){
            if(rk2[sa[i]]!=rk2[sa[i-1]])++V;
            rk[sa[i]]=V;
        }
        for(int k=1;k<n;k<<=1){
            int tmp=0;
            for(int i=n-k+1;i<=n;i++)sa2[++tmp]=i;
            for(int i=1;i<=n;i++)if(sa[i]-k>0)sa2[++tmp]=sa[i]-k;
            memset(buc,0,sizeof(buc));
            for(int i=1;i<=n;i++)buc[rk[i]]++;
            for(int i=1;i<=V;i++)buc[i]+=buc[i-1];
            for(int i=n;i>=1;i--)sa[buc[rk[sa2[i]]]--]=sa2[i];
            memcpy(rk2,rk,sizeof(rk));
            V=0;
            for(int i=1;i<=n;i++){
                if(rk2[sa[i]]!=rk2[sa[i-1]]||rk2[sa[i]+k]!=rk2[sa[i-1]+k])++V;
                rk[sa[i]]=V;
            }
            if(V==n)break;
        }
        for(int i=1,len=0;i<=n;i++){
            if(len>0)--len;
            while(s[i+len]==s[sa[rk[i]-1]+len])++len;
            height[rk[i]]=len;
        }
        for(int i=1;i<=n;i++)st[i][0]=height[i];
        for(int p=1;p<=10;p++){
            for(int i=1;i<=n;i++){
                st[i][p]=min(st[i][p-1],st[min(i+(1<<p-1),n)][p-1]);
            }
        }
    }
    inline int comp(int l1,int r1,int l2,int r2){
        int a=rk[l1],b=rk[l2],A=min(a,b),B=max(a,b);
        if(A==B)return r1==r2?0:(r1>r2?1:-1);
        int p=(B==A+1?0:log2(B-A-1));
        int lcp=min(st[A+1][p],st[B-(1<<p)+1][p]);
        int len1=r1-l1+1,len2=r2-l2+1;
        if(len1==len2&&len1<=lcp)return 0;
        if(lcp>=min(len1,len2))return len1>len2?1:-1;
        return a>b?1:-1;
    }
}
using namespace SGT;
using namespace SA;
void GOWORK(){
    n=s.size();
    s="$"+s;
    for(int i=1;i<=n;i++)comma[i]=f[i]=g[i]=0;
    l0[0]=0;for(int i=1;i<=n;i++)l0[i]=(s[i]=='0'?l0[i-1]:i);
    r0[n+1]=n+1;for(int i=n;i>=1;i--)r0[i]=(s[i]=='0'?r0[i+1]:i);
    figure();
    build(1,1,n);
    for(int i=1;i<=n;i++){
        f[i]=query(1,i);
        int j=r0[i+1]+i-r0[f[i]+1];
        if(j<=n)if(comp(r0[i+1],j,r0[f[i]+1],i)!=1)j++;
        if(j<=n)take_max(1,j,n,i);   
    }
    build(1,1,n);
    take_max(1,l0[f[n]]+1,n,n);
    for(int i=l0[f[n]]+1;i<=n;i++)g[i]=n;
    for(int i=f[n];i>=1;i--){
        int j=i+r0[i+1]-g[i+1];
        if(j>=1){if(comp(r0[j],i,r0[i+1],g[i+1])!=-1)j++;}
        else j=1;
        take_max(1,l0[j-1]+1,i,i);
        g[i]=query(1,i);
    }
    for(int i=1;i<=f[n];i=g[i]+1)comma[g[i]]=1;
    for(int i=1;i<=n;i++){
        putchar(s[i]);
        if(comma[i]&&i<n)putchar(',');
    }
    putchar('\n');
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    while(cin>>s)GOWORK();
    return 0;
}
```

---

## 作者：ZhongYuLin (赞：0)

### 理论线性的做法

设：$f_i$ 表示在 $s[1\dots i]$ 中，最大的尾段的开头**下标**，$g_i$ 表示在 $s[i\dots n]$ 中，最大的首段的结束**下标**。我们记 $num[i,j]$ 为 $s[i\dots j]$ 转化为数字后的数值，可以列出 $O(n^3)$ 的转移。

$$f_i=\max_{j<i,num[j,f_j]<num[j+1,i]}j$$

$$g_i=\max_{i<j,num[i,j-1]<num[j,g_j]}j$$

其中字符串比较代价为 $O(n)$，可以用线性后缀数组搭配线性 RMQ 做到 $O(n)$ 预处理，$O(1)$ 查询。

发现 $f$ 的转移形如后缀取 $\max$，可以做到 $O(n)$，而 $g$ 的转移则是从后转移到向前相邻的一段区间，似乎只能使用数据结构进行维护。但是，打表或是分析发现，$g$ 的值从后往前单调递减，可以使用双指针维护，只需要在区间左端点左侧扣去这个值即可。

这份代码是 $O(n\log{n})$ 的。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+3;
namespace SA{
int sa[N],A[N],B[N],c[N],rk[N],hgt[N],f[22][N];
template<class T>
void SA(const T &s){
    int n=s.size()-1,m=*max_element(s.begin(),s.end());
    fill_n(c+1,m,0);
    for(int i=1;i<=n;++i)++c[A[i]=s[i]];
    for(int i=2;i<=m;++i)c[i]+=c[i-1];
    for(int i=n;i;--i)sa[c[A[i]]--]=i;
    for(int j=1;j<=n;j<<=1){
        int cnt=0;
        for(int i=n-j+1;i<=n;++i)B[++cnt]=i;
        for(int i=1;i<=n;++i)if(sa[i]>j)B[++cnt]=sa[i]-j;
        fill_n(c+1,m,0);
        for(int i=1;i<=n;++i)++c[A[i]];
        for(int i=2;i<=m;++i)c[i]+=c[i-1];
        for(int i=n;i;--i)sa[c[A[B[i]]]--]=B[i];
        copy(A+1,A+1+n,B+1);m=0;
        for(int i=1;i<=n;++i)
            A[sa[i]]=(m+=B[sa[i]]!=B[sa[i-1]]||B[sa[i]+j]!=B[sa[i-1]+j]);
        if(n==m)break;
    }
    for(int i=1;i<=n;++i)rk[sa[i]]=i;
    for(int i=1,k=0;i<=n;++i){
        if(rk[i]==1)continue;
        if(k)--k;
        int j=sa[rk[i]-1];
        while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])++k;
        hgt[rk[i]]=k;
    }
    for(int i=1;i<=n;++i)f[0][i]=hgt[i];
    for(int j=1;1<<j<=n;++j)
        for(int i=1;i+(1<<j)-1<=n;++i)
            f[j][i]=min(f[j-1][i],f[j-1][i+(1<<j-1)]);
}
int ask(int x,int y){
    if(x==y)return x;
    if((x=rk[x])>(y=rk[y]))swap(x,y);
    int k=__lg(y-x);
    return min(f[k][x+1],f[k][y-(1<<k)+1]);
}
}
int n;
string s;
int R[N],f[N],g[N],mx[N],L[N];
bool vis[N];
vector<int>tmp[N];
bool cmp(int x,int y,int u,int v){
    x=R[x];u=R[u];
    if(!u)return 0;
    int l1=y-x+1,l2=v-u+1;
    if(l1!=l2)return l1<l2;
    int lcp=SA::ask(x,u);
    if(lcp>=l1)return 0;
    return s[x+lcp]<s[u+lcp];
}
void solve(){
    n=s.size();
    if(count(s.begin(),s.end(),'0')==n){
        printf("%s\n",s.c_str());
        return;
    }
    s="#"+s;SA::SA(s);R[n+1]=0;
    for(int i=1;i<=n;++i){
        L[i]=L[i-1];
        if(s[i]!='0')L[i]=i;
    }
    for(int i=n;i;--i){
        R[i]=R[i+1];
        if(s[i]!='0')R[i]=i;
        f[i]=1;g[i]=mx[i]=vis[i]=0;
        tmp[i].clear();
    }
    for(int i=1,pre=0;i<=n;++i){
        pre=max(pre,mx[i]);f[i]=pre+1;
        int l=R[i+1],r=l+i-R[f[i]];
        if(!l||r>n)continue;
        if(cmp(f[i],i,l,r))
            if(l==r)mx[i+1]=max(mx[i+1],i);
            else mx[r]=max(mx[r],i);
        else mx[r+1]=max(mx[r+1],i);
    }
    int now=f[n];
    auto cg=[&](int i,int k){
        g[i]=k;int l=max(1,min(i-(g[i]-min(R[i],g[i])),L[i-1]));
        if(cmp(l,i-1,i,k-1))l=L[l-1];
        if(l)tmp[l].push_back(i);
    };
    do cg(now--,n+1);while(now&&s[now]=='0');
    for(int i=now,mx=f[n];i;--i){
        for(auto x:tmp[i])vis[x]=1;
        while(vis[mx])--mx;cg(i,mx);
    }
    for(int x=1;x<=n;x=g[x],printf("%c","\n,"[x<=n]))
        for(int i=x;i<g[x];++i)
            printf("%c",s[i]);
}
int main(){
    int u,v,w,x,y,z;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    for(;cin>>s;)solve();
    return 0;
}
```

给出用各处板子拼出来的 $O(n)$ 做法，常数有点大，因此没有跑过上面的代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+3;
namespace SA{
namespace atcoder {

namespace internal {

std::vector<int> sa_naive(const std::vector<int>& s) {
    int n = int(s.size());
    std::vector<int> sa(n);
    std::iota(sa.begin(), sa.end(), 0);
    std::sort(sa.begin(), sa.end(), [&](int l, int r) {
        if (l == r) return false;
        while (l < n && r < n) {
            if (s[l] != s[r]) return s[l] < s[r];
            l++;
            r++;
        }
        return l == n;
    });
    return sa;
}

std::vector<int> sa_doubling(const std::vector<int>& s) {
    int n = int(s.size());
    std::vector<int> sa(n), rnk = s, tmp(n);
    std::iota(sa.begin(), sa.end(), 0);
    for (int k = 1; k < n; k *= 2) {
        auto cmp = [&](int x, int y) {
            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];
            int rx = x + k < n ? rnk[x + k] : -1;
            int ry = y + k < n ? rnk[y + k] : -1;
            return rx < ry;
        };
        std::sort(sa.begin(), sa.end(), cmp);
        tmp[sa[0]] = 0;
        for (int i = 1; i < n; i++) {
            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);
        }
        std::swap(tmp, rnk);
    }
    return sa;
}

// SA-IS, linear-time suffix array construction
// Reference:
// G. Nong, S. Zhang, and W. H. Chan,
// Two Efficient Algorithms for Linear Time Suffix Array Construction
template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>
std::vector<int> sa_is(const std::vector<int>& s, int upper) {
    int n = int(s.size());
    if (n == 0) return {};
    if (n == 1) return {0};
    if (n == 2) {
        if (s[0] < s[1]) {
            return {0, 1};
        } else {
            return {1, 0};
        }
    }
    if (n < THRESHOLD_NAIVE) {
        return sa_naive(s);
    }
    if (n < THRESHOLD_DOUBLING) {
        return sa_doubling(s);
    }

    std::vector<int> sa(n);
    std::vector<bool> ls(n);
    for (int i = n - 2; i >= 0; i--) {
        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);
    }
    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);
    for (int i = 0; i < n; i++) {
        if (!ls[i]) {
            sum_s[s[i]]++;
        } else {
            sum_l[s[i] + 1]++;
        }
    }
    for (int i = 0; i <= upper; i++) {
        sum_s[i] += sum_l[i];
        if (i < upper) sum_l[i + 1] += sum_s[i];
    }

    auto induce = [&](const std::vector<int>& lms) {
        std::fill(sa.begin(), sa.end(), -1);
        std::vector<int> buf(upper + 1);
        std::copy(sum_s.begin(), sum_s.end(), buf.begin());
        for (auto d : lms) {
            if (d == n) continue;
            sa[buf[s[d]]++] = d;
        }
        std::copy(sum_l.begin(), sum_l.end(), buf.begin());
        sa[buf[s[n - 1]]++] = n - 1;
        for (int i = 0; i < n; i++) {
            int v = sa[i];
            if (v >= 1 && !ls[v - 1]) {
                sa[buf[s[v - 1]]++] = v - 1;
            }
        }
        std::copy(sum_l.begin(), sum_l.end(), buf.begin());
        for (int i = n - 1; i >= 0; i--) {
            int v = sa[i];
            if (v >= 1 && ls[v - 1]) {
                sa[--buf[s[v - 1] + 1]] = v - 1;
            }
        }
    };

    std::vector<int> lms_map(n + 1, -1);
    int m = 0;
    for (int i = 1; i < n; i++) {
        if (!ls[i - 1] && ls[i]) {
            lms_map[i] = m++;
        }
    }
    std::vector<int> lms;
    lms.reserve(m);
    for (int i = 1; i < n; i++) {
        if (!ls[i - 1] && ls[i]) {
            lms.push_back(i);
        }
    }

    induce(lms);

    if (m) {
        std::vector<int> sorted_lms;
        sorted_lms.reserve(m);
        for (int v : sa) {
            if (lms_map[v] != -1) sorted_lms.push_back(v);
        }
        std::vector<int> rec_s(m);
        int rec_upper = 0;
        rec_s[lms_map[sorted_lms[0]]] = 0;
        for (int i = 1; i < m; i++) {
            int l = sorted_lms[i - 1], r = sorted_lms[i];
            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;
            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;
            bool same = true;
            if (end_l - l != end_r - r) {
                same = false;
            } else {
                while (l < end_l) {
                    if (s[l] != s[r]) {
                        break;
                    }
                    l++;
                    r++;
                }
                if (l == n || s[l] != s[r]) same = false;
            }
            if (!same) rec_upper++;
            rec_s[lms_map[sorted_lms[i]]] = rec_upper;
        }

        auto rec_sa =
            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);

        for (int i = 0; i < m; i++) {
            sorted_lms[i] = lms[rec_sa[i]];
        }
        induce(sorted_lms);
    }
    return sa;
}

}  // namespace internal

std::vector<int> suffix_array(const std::vector<int>& s, int upper) {
    assert(0 <= upper);
    for (int d : s) {
        assert(0 <= d && d <= upper);
    }
    auto sa = internal::sa_is(s, upper);
    return sa;
}

template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {
    int n = int(s.size());
    std::vector<int> idx(n);
    iota(idx.begin(), idx.end(), 0);
    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });
    std::vector<int> s2(n);
    int now = 0;
    for (int i = 0; i < n; i++) {
        if (i && s[idx[i - 1]] != s[idx[i]]) now++;
        s2[idx[i]] = now;
    }
    return internal::sa_is(s2, now);
}

std::vector<int> suffix_array(const std::string& s) {
    int n = int(s.size());
    std::vector<int> s2(n);
    for (int i = 0; i < n; i++) {
        s2[i] = s[i];
    }
    return internal::sa_is(s2, 255);
}

// Reference:
// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,
// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its
// Applications
template <class T>
std::vector<int> lcp_array(const std::vector<T>& s,
                           const std::vector<int>& sa) {
    int n = int(s.size());
    assert(n >= 1);
    std::vector<int> rnk(n);
    for (int i = 0; i < n; i++) {
        rnk[sa[i]] = i;
    }
    std::vector<int> lcp(n - 1);
    int h = 0;
    for (int i = 0; i < n; i++) {
        if (h > 0) h--;
        if (rnk[i] == 0) continue;
        int j = sa[rnk[i] - 1];
        for (; j + h < n && i + h < n; h++) {
            if (s[j + h] != s[i + h]) break;
        }
        lcp[rnk[i] - 1] = h;
    }
    return lcp;
}

std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {
    int n = int(s.size());
    std::vector<int> s2(n);
    for (int i = 0; i < n; i++) {
        s2[i] = s[i];
    }
    return lcp_array(s2, sa);
}

// Reference:
// D. Gusfield,
// Algorithms on Strings, Trees, and Sequences: Computer Science and
// Computational Biology
template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {
    int n = int(s.size());
    if (n == 0) return {};
    std::vector<int> z(n);
    z[0] = 0;
    for (int i = 1, j = 0; i < n; i++) {
        int& k = z[i];
        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);
        while (i + k < n && s[k] == s[i + k]) k++;
        if (j + z[j] < i + z[i]) j = i;
    }
    z[0] = n;
    return z;
}

std::vector<int> z_algorithm(const std::string& s) {
    int n = int(s.size());
    std::vector<int> s2(n);
    for (int i = 0; i < n; i++) {
        s2[i] = s[i];
    }
    return z_algorithm(s2);
}

}
const int MAXN=2e6+3;
const int MAXM=22;
struct RMQ {
  int N, A[MAXN];
  int blockSize;
  int S[MAXN][MAXM], Pow[MAXM], Log[MAXN];
  int Belong[MAXN], Pos[MAXN];
  int Pre[MAXN], Sub[MAXN];
  int F[MAXN];

  void buildST() {
    int cur = 0, id = 1;
    Pos[0] = -1;
    for (int i = 1; i <= N; ++i) {
      S[id][0] = max(S[id][0], A[i]);
      Belong[i] = id;
      if (Belong[i - 1] != Belong[i])
        Pos[i] = 0;
      else
        Pos[i] = Pos[i - 1] + 1;
      if (++cur == blockSize) {
        cur = 0;
        ++id;
      }
    }
    if (N % blockSize == 0) --id;
    Pow[0] = 1;
    for (int i = 1; i < MAXM; ++i) Pow[i] = Pow[i - 1] * 2;
    for (int i = 2; i <= id; ++i) Log[i] = Log[i / 2] + 1;
    for (int i = 1; i <= Log[id]; ++i) {
      for (int j = 1; j + Pow[i] - 1 <= id; ++j) {
        S[j][i] = std::max(S[j][i - 1], S[j + Pow[i - 1]][i - 1]);
      }
    }
  }

  void buildSubPre() {
    Sub[N+1]=0;
    for (int i = 1; i <= N; ++i) {
      if (Belong[i] != Belong[i - 1])
        Pre[i] = A[i];
      else
        Pre[i] = std::max(Pre[i - 1], A[i]);
    }
    for (int i = N; i >= 1; --i) {
      if (Belong[i] != Belong[i + 1])
        Sub[i] = A[i];
      else
        Sub[i] = std::max(Sub[i + 1], A[i]);
    }
  }

  void buildBlock() {
    static int S[MAXN], top;
    top=0;
    for (int i = 1; i <= N; ++i) {
      if (Belong[i] != Belong[i - 1])
        top = 0;
      else
        F[i] = F[i - 1];
      while (top > 0 && A[S[top]] <= A[i]) F[i] &= ~(1 << Pos[S[top--]]);
      S[++top] = i;
      F[i] |= (1 << Pos[i]);
    }
  }

  void init() {
    for(int i=1;i<=N;++i)S[i][0]=0;
    blockSize = log2(N) * 1.5;
    buildST();
    buildSubPre();
    buildBlock();
  }

  int queryMax(int l, int r) {
    int bl = Belong[l], br = Belong[r];
    if (bl != br) {
      int ans1 = 0;
      if (br - bl > 1) {
        int p = Log[br - bl - 1];
        ans1 = std::max(S[bl + 1][p], S[br - Pow[p]][p]);
      }
      int ans2 = std::max(Sub[l], Pre[r]);
      return std::max(ans1, ans2);
    } else {
      return A[l + __builtin_ctz(F[r] >> Pos[l])];
    }
  }
} R;

int rk[N];
const int INF=0x3f3f3f3f;
void SA(const string &s){
    auto sa=atcoder::suffix_array(s);
    auto hgt=atcoder::lcp_array(s,sa);
    int n=s.size();R.N=n+1;
    for(int i=1;i<=n;++i)rk[sa[i-1]+1]=i;
    for(int i=2;i<=n;++i)R.A[i]=INF-hgt[i-2];
    R.A[1]=0;R.A[n+1]=0;R.init();
}
int ask(int x,int y){
    if(x==y)return x;
    if((x=rk[x])>(y=rk[y]))swap(x,y);
    return INF-R.queryMax(x+1,y);
}
}int n;
string s;
int R[N],f[N],g[N],mx[N],L[N];
bool vis[N];
vector<int>tmp[N];
bool cmp(int x,int y,int u,int v){
    x=R[x];u=R[u];
    if(!u)return 0;
    int l1=y-x+1,l2=v-u+1;
    if(l1!=l2)return l1<l2;
    int lcp=SA::ask(x,u);
    if(lcp>=l1)return 0;
    return s[x+lcp]<s[u+lcp];
}
void solve(){
    n=s.size();
    if(count(s.begin(),s.end(),'0')==n){
        printf("%s\n",s.c_str());
        return;
    }
    SA::SA(s);s="#"+s;R[n+1]=0;
    for(int i=1;i<=n;++i){
        L[i]=L[i-1];
        if(s[i]!='0')L[i]=i;
    }
    for(int i=n;i;--i){
        R[i]=R[i+1];
        if(s[i]!='0')R[i]=i;
        f[i]=1;g[i]=mx[i]=vis[i]=0;
        tmp[i].clear();
    }
    for(int i=1,pre=0;i<=n;++i){
        pre=max(pre,mx[i]);f[i]=pre+1;
        int l=R[i+1],r=l+i-R[f[i]];
        if(!l||r>n)continue;
        if(cmp(f[i],i,l,r))
            if(l==r)mx[i+1]=max(mx[i+1],i);
            else mx[r]=max(mx[r],i);
        else mx[r+1]=max(mx[r+1],i);
    }
    int now=f[n];
    auto cg=[&](int i,int k){
        g[i]=k;int l=max(1,min(i-(g[i]-min(R[i],g[i])),L[i-1]));
        if(cmp(l,i-1,i,k-1))l=L[l-1];
        if(l)tmp[l].push_back(i);
    };
    do cg(now--,n+1);while(now&&s[now]=='0');
    for(int i=now,mx=f[n];i;--i){
        for(auto x:tmp[i])vis[x]=1;
        while(vis[mx])--mx;cg(i,mx);
    }
    for(int x=1;x<=n;x=g[x],printf("%c","\n,"[x<=n]))
        for(int i=x;i<g[x];++i)
            printf("%c",s[i]);
}
int main(){
    int u,v,w,x,y,z;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    for(;cin>>s;)solve();
    return 0;
}
```

---

## 作者：Conless (赞：0)

欢迎来[我的博客](https://www.luogu.com.cn/blog/Conless/post-xie-ti-bao-gao-p2282-li-shi-nian-fen-p1415-chai-fen-shuo-lie)查看

强化版 [[HNOI2003]历史年份](https://www.luogu.com.cn/problem/P2282) & 弱化版 [拆分数列](https://www.luogu.com.cn/problem/P1415)

我们先来考虑弱化版：

首先进行正向 $dp$：

设 $f_i$ 表示以 $i$ 为结尾的最大前缀的起点下标，$num_{i,j}$ 为下标 $i-j$ 构成的数字。显然，这个下标越大（接近 $i$），前缀越小，得到的答案就越优，所以：

$f_i=max\{j\}, j\in [1,i] \& \quad num_{f_{j-1},j-1}<num_{j,i}$

```cpp
    f1[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        f1[i] = 1;
        for (int j = i; j >= 1; j--)
            if (comp(f1[j - 1], j, i))
            {
                f1[i] = j;
                break;
            }
    }
```

$comp()$的朴素实现方式：
```cpp
bool comp(int l, int m, int r)
{
    int len1 = m - l, len2 = r - m + 1;
    int st1 = l, ed1 = m - 1;
    int st2 = m, ed2 = r;
    if (len1 < len2)
    {
        while (st2 - m + 1 <= len2 - len1)
        {
            if (str[st2] != '0')
                return 1;
            st2++;
        }
    }
    if (len1 > len2)
    {
        while (st1 - l + 1 <= len1 - len2)
        {
            if (str[st1] != '0')
                return 0;
            st1++;
        }
    }
    len1 = len2 = min(len1, len2);
    for (int i = 0; i < len1; i++)
        if (str[st1 + i] != str[st2 + i])
            return str[st2 + i] > str[st1 + i];
    return 0;
}
```

再考虑反向 $dp$：

设 $f_i$ 表示以 $i$ 为起点的最大后缀的终点下标，显然，这个下标越大（接近 $n$），后缀越大，得到的答案就越优，所以：

$f_i=max\{j\}, j\in [i,j] \& \quad num_{i,j}<num_{j+1,f_{j+1}}$

但是我们必须考虑到前导零对一个数字的大小是没有影响的，那么对于第一遍正向 $dp$ 得出的最大的最后一个数，可以在其前面加上若干个前导零，这些前导零在 $f$ 数组中指向的下标应该都为 $n$
```cpp
    int las = n;
    while (las >= f1[n] || str[las] == '0')
    {
        f2[las] = n;
        las--;
    }
    for (int i = las; i >= 1; i--)
    {
        f2[i] = i;
        for (int j = n - 1; j > i; j--)
            if (comp(i, j + 1, f2[j + 1]))
            {
                f2[i] = j;
                break;
            }
    }
```

那么我们就能完成弱化版了

时间复杂度：

$DP: O(n^2)$

每次比较：$O(n)$

总时间复杂度：$O(n^3)$

当然，这样的复杂度并不能帮助我们通过其强化版：

$T=1000, n=2000$，期望时间复杂度$O(Tn)-O(Tnlogn)$

对于原算法考虑进行优化：
1. 对于第一遍 $dp$，考虑将每一个确定的 $f_j$ 直接往后更新，凡是满足 $num_{f[j], j} < num_{j+1, i}$ 的 $f_i$，均可以被 $j$ 更新，很显然，每一次均可更新一个区间 $[i_{min}, n]$

2. 对于第二遍 $dp$，考虑将每一个确定的 $f_j$ 直接往前更新，凡是满足 $num_{i, j} < num_{j+1, f_{j+1}}$ 的 $f_i$，均可以被 $j$ 更新，很显然，每一次均可更新一个区间 $[i_{max}, j]$

以上两步，均可以使用线段树将 $DP$ 将填表的时间复杂度优化至 $O(nlogn)$

但是我们仍然无法快速得到两次 $DP$ 的 $i_{min}, i_{max}$，此时我们考虑直接用位数进行比较，用第一次DP进行举例：

$\because num_{f_{j-1},j-1}<num_{j,i}$

$\therefore (j-1)-f_{j-1}+1 \le i-j+1$（不考虑前导零）

$\therefore i \ge 2j-f_{j-1}-1$

若考虑前导零，可以预处理将 $i$ 左边与右边（包括 $i$）的第一个非零数字求出来，表示为 $lasn_i$ 与 $nexn_i$，那么上式将变为：

$i_{min} = nexn_i + (i - nexn_{f_{i - 1}}) - 1$

注意到推导的前两位并非等价转化，那么我们再进行一次 $comp(f_{j-1}, j, i_{max})$，若不合法再往后跳一位即可

这样的话我们的理论时间复杂度就降到了 $O(Tn^2)$，当然实际上比较函数是完全跑不满的，再套一个 $O2$ 可能能卡过

这个时候我们再来考虑每一次 $comp$ 函数的优化，之前考虑的是朴素比较，但由于我们现在只需要知道两个由数字构成的字串的大小，不妨考虑哈希算法：

```cpp
void pre_hash()
{
    num[0] = 0;
    for (int i = 1; i <= n; i++)
        num[i] = (1LL * num[i - 1] * 10 + str[i] - '0') % MOD;
}

inline bool equal(int st1, int st2, int len) 
{
    int ed1 = st1 + len - 1, ed2 = st2 + len - 1;
    return (num[ed1] - fac[len] * num[st1 - 1] % MOD + MOD) % MOD == (num[ed2] - fac[len] * num[st2 - 1] % MOD + MOD) % MOD;
}
```

但是，他假了！！！
![](https://cdn.luogu.com.cn/upload/image_hosting/yg0q5u4j.png)

可能是我的模数或进制写的太弱了，所以单哈希就这样被卡了，于是最后改了个双哈希终于勉强过了

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

typedef long long ll;

const int MAXN = 2e3 + 5;
const ll MOD1 = 1e9 + 7, MOD2 = 19260817;

int T, n;
char str[MAXN];
ll num1[MAXN], num2[MAXN], fac1[MAXN], fac2[MAXN];
int f1[MAXN], f2[MAXN];
int nexn[MAXN], lasn[MAXN];

class SegmentTree
{

#define sn segTree[node]

    struct TreeNode {
        int l, r;
        int lson, rson;
        int data;
    } segTree[MAXN << 2];

    void pushdown(int node)
    {
        if (sn.data)
        {
            segTree[sn.lson].data = max(segTree[sn.lson].data, sn.data);
            segTree[sn.rson].data = max(segTree[sn.rson].data, sn.data);
            sn.data = 0;
        }
    }

public:

    void build(int node, int l, int r)
    {
        sn.l = l;
        sn.r = r;
        sn.data = 0;
        if (l != r)
        {
            sn.lson = node << 1;
            sn.rson = node << 1 | 1;
            int mid = (l + r) >> 1;
            build(sn.lson, l, mid);
            build(sn.rson, mid + 1, r);
        }
    }

    int ask(int node, int pos)
    {
        if (sn.l == sn.r)
            return sn.data;
        pushdown(node);
        int mid = (sn.l + sn.r) >> 1;
        if (pos <= mid)
            return ask(sn.lson, pos);
        else return ask(sn.rson, pos);
    }

    void change(int node, int l, int r, int val)
    {
        if (l > sn.r || r < sn.l)
            return;
        if (l <= sn.l && r >= sn.r)
            sn.data = max(sn.data, val);
        else {
            pushdown(node);
            change(sn.lson, l, r, val);
            change(sn.rson, l, r, val);
        }
    }
} stree;

inline bool equal(int st1, int st2, int len) 
{
    int ed1 = st1 + len - 1, ed2 = st2 + len - 1;
    bool res1 = (num1[ed1] - fac1[len] * num1[st1 - 1] % MOD1 + MOD1) % MOD1
             == (num1[ed2] - fac1[len] * num1[st2 - 1] % MOD1 + MOD1) % MOD1;
    bool res2 = (num2[ed1] - fac2[len] * num2[st1 - 1] % MOD2 + MOD2) % MOD2
             == (num2[ed2] - fac2[len] * num2[st2 - 1] % MOD2 + MOD2) % MOD2;
    return res1 & res2;
}

bool comp(int l, int m, int r)
{
    int st1 = l, ed1 = m - 1;
    int st2 = m, ed2 = r;
    st1 = nexn[st1];
    st2 = nexn[st2];
    int len1 = ed1 - st1 + 1, len2 = ed2 - st2 + 1;
    if (len2 <= 0)
        return 0;
    if (len1 <= 0)
        return 1;
    if (len1 != len2)
        return len1 < len2;
    int le = 0, ri = len1 - 1, res = -1;
    while (le <= ri)
    {
        int mid = (le + ri) >> 1;
        if (equal(st1, st2, mid))
        {
            res = mid;
            le = mid + 1;
        }
        else ri = mid - 1;
    }
    return str[st1 + res] < str[st2 + res];
}

void pre_pow()
{
    fac1[0] = 1LL;
    for (int i = 1; i <= 2000; i++)
        fac1[i] = 1LL * fac1[i - 1] * 10 % MOD1;
    fac2[0] = 1LL;
    for (int i = 1; i <= 2000; i++)
        fac2[i] = 1LL * fac2[i - 1] * 11 % MOD2;
}

void pre_hash()
{
    num1[0] = 0;
    for (int i = 1; i <= n; i++)
        num1[i] = (1LL * num1[i - 1] * 10 + str[i] - '0') % MOD1;
    num2[0] = 0;
    for (int i = 1; i <= n; i++)
        num2[i] = (1LL * num2[i - 1] * 11 + str[i] - '0') % MOD2;
}

void deal_zero()
{
    for (int i = n, j = n + 1; i >= 1; i--)
    {
        if (str[i] != '0')
            j = i;
        nexn[i] = j;
    }
    for (int i = 1, j = 0; i <= n; i++)
    {
        if (str[i] != '0')
            j = i;
        lasn[i] = j;
    }
}

int main()
{
    pre_pow();
    while (scanf("%s", str + 1) != EOF)
    {
        n = strlen(str + 1);
        pre_hash();
        deal_zero();
        stree.build(1, 1, n);
        stree.change(1, 1, n, 1);
        f1[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            int nex = nexn[i] + (i - nexn[f1[i - 1]]) - 1;
            if (!comp(f1[i - 1], i, nex))
                nex++;
            stree.change(1, nex, n, i);
            f1[i] = stree.ask(1, i);
        }
        int las = lasn[f1[n] - 1];
        stree.build(1, 1, n);
        stree.change(1, las + 1, n, n);
        f2[n] = n;
        for (int i = n - 1; i >= 1; i--)
        {
            f2[i] = max(i, stree.ask(1, i));
            int fir = i - (f2[i + 1] - nexn[i + 1]);
            if (!comp(fir, i + 1, f2[i + 1]))
                fir++;
            fir = lasn[fir - 1] + 1;
            if (fir < 1) fir = 1;
            stree.change(1, fir, i - 1, i);
        }
        
        for (int i = 1; i <= n; i++)
        {
            int j = i;
            while (j <= f2[i] && j <= n)
                putchar(str[j++]);
            i = j - 1;
            if (i != n) putchar(',');
        }
        putchar('\n');
    }
    return 0;
}
```

---


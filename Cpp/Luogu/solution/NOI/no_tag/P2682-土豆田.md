# 土豆田

## 题目背景

大宁在他家门口种了一大片土豆田，划分为 $n \times m$ 的地块。

大宁准备搭建学校的 OJ，为了测试土豆田的性能，大宁找到了你，为他的土豆编写代码。

## 题目描述

大宁的土豆田是以地块为单位的，每个地块里的所有土豆的集合称为一个处理单元，可以储存两个值：key（键值）和 tmp（缓存值），均为 $32$ 位带符号整数，每个单元。可以执行若干命令。大宁会骑着自行车轮流给每个处理单元供电，顺序如图，展示的是一个被分割为 $4\times 4$ 处理单元的土豆田：

  ![](https://cdn.luogu.com.cn/upload/pic/12313.png) 

单元的编号就是供电的顺序，每次按编号顺序从 $1$ 号到 $n\times m$ 号遍历一遍。

每一次完整的遍历称为一个周期。

只有一块地上的土豆得到供电，它们才会工作，执行命令，所有命令执行完之后大宁会停止供电。

对于每一个处理单元，命令格式如下：

1. `in` 读取一个数，存放到该单元的 $\text{tmp}$ 中。（如果 $\text{tmp}$ 中有数，那么覆盖掉，以下的所有存放均如此）

1. `out` 输出当前处理单元的 $\text{key}$ 值。

1. `swap` 交换该单元的 $\text{key}$ 和 $\text{tmp}$。

1. `add X` 给 $\text{key}$ 值加上 $X$，$X$ 只能是一个常数或者 $\text{tmp}$，下同。

1. `set X` 把 $\text{key}$ 值修改为 $X$。

1. `opp` 对 $\text{key}$ 值取相反数。

1. `rev` 对 $\text{key}$ 值按位取反。

1. `L/R X` 左/右移 $\text{key}$ 值 $X$ 位。

1. `get u/d/l/r` 将当前单元上(u)/下(d)/左(l)/右(r)面的单元的 $\text{key}$ 值并把它复制到本单元的 $\text{tmp}$，位置规则按照前面的图片所示。

1. `or/and/or X` 对 $\text{key}$ 值按位或/与/异或 $X$。

1. `wait` 在本次供电的时间中等待，即什么事情也不做。

1. `if X` 如果此时 X(只能是 $\text{key}$ 或者 $\text{tmp}$ )不等于 $0$ 则在下一次供电执行该语句的下一条语句，否则跳过下一条语句，执行下下条(如果存在的话)。

1. `goto Y`  下一次供电从第 $Y$ 号命令开始执行，$Y$ 只能是常数。

1. `end` 强制结束所有的处理单元的命令，无视所有尚未执行的命令。

我们提供了 check.exe,把你的土豆程序 potato.out 和你想测试的输入数据 potato.in 放到与 check.exe 同文件夹下，运行之后可以在 report.txt 中查看你的程序的详细运行情况。

我们还提供了另一个样例土豆程序 example2.out,使用 $2\times2$ 处理单元的土豆程序，内容为计算一个整数 $a$ 的 $10$ 倍,可以自行解读（该样例并非该计算的最优解，只是为了展示命令）。

下面展示了一个 $1 \times 3$ 的处理单元，所有单元不一定需要全部使用。

![](https://cdn.luogu.com.cn/upload/pic/12314.png)

你有以下任务需要用编写土豆程序完成：

|编号|输入|输出|数据范围|处理单元大小限制|分数|补充说明|
| :----------: | :----------: | :----------:| :----------:| :----------:|:----------: | :----------: |
|$1$|$a\text{，}b$|$b-a$|$\lvert a\rvert \text{，}\lvert b\rvert \le10^9 $|$1 \times 3$|$7$|无|
|$2$|$a$|$233\times a$|$1 \le\lvert a\rvert \le10^7 $|$2 \times 2$|$9$|无|
|$3$|$a$|$\lvert a \rvert$|$1 \le\lvert a\rvert \le10^9 $|$2 \times 2$|$12$|求 $a$ 的绝对值|
|$4$|$128$ 个整数 $a_i$|$\sum^{128}_{i=1}a_i$|$1 \le\lvert a\rvert \le2 \times 10^6 $|$4 \times 2$|$12$|无|
|$5$|$a\text{，}b$|$\lfloor \frac{a+b}{2}\rfloor$|$\lvert a\rvert \text{，}\lvert b\rvert \le2.1\times10^9 $|$2 \times 2$|$13$|无|
|$6$|$a$|$\operatorname{popcount}(a)$|$\lvert a\rvert\le10^9 $|$2 \times 2$|$13$|$\operatorname{popcount}(a)$表示 $a$ 在二进制表示下 $1$ 的个数|
|$7$|$a\text{，}b$|$\max {(a,b)}$|$\lvert a\rvert \text{，}\lvert b\rvert \le10^9 $|$2 \times 2$|$14$|无|
|$8$|$n$|$f(n)$|$1 \le n \le 42$|$3 \times 3$|$20$|$f(n)=\begin{cases}1 & n<2\\f(n-1)+f(n-2) & n\ge 2\end{cases}$|

## 说明/提示

#### 样例#1解释

这个样例实现了 A+B problem。

第一行的 `1 1` 表示用的处理单元为 $1\times1$。

第二行表示第一个处理单元有 $5$ 条指令。

第三行的命令在第一个周期执行，读入了一个数(假定为 $a$) ，此时该单元的状态为 $\text{key}= 0 \text{，}\text{tmp}= a$。

第四行在第二个周期执行，交换了 $\text{key}$ 和 $\text{tmp}$，状态为 $\text{key}= a \text{，}\text{tmp}= 0$。

第五行在第三个周期执行，读入了另一个数 $b$，状态为 $\text{key}= a \text{，}\text{tmp}= b$。

第六行在第四个周期执行，给 $\text{key}$ 加上 $\text{tmp}$，状态为 $\text{key}= a+b \text{，}\text{tmp}= b$。

第七行在第五个周期执行，输出该单元的 $\text{key}$，即输出了 $a+b$。


如果你的程序在 $2000$ 个周期内没有运行完毕，或者有语法错误，或者超过处理单元尺寸限制，得 $0$ 分。

如果你的第 $i$ 个任务的程序能得出正确的结果，并且和标准答案运行所需的周期数量相同或比其更少，得会得到该测试点的满分，否则设你的程序运行了 $a$ 个周期，标准答案运行了 $s$ 个周期，你的分数为 $\lfloor\text{该测试点分数}\times(\frac{s}{a})\times0.8 \rfloor$(注意，部分正确显示WA,但是仍然有分数)。

```cpp
P1=7
P2=9
P3=12
P4=12
P5=13
P6=13
P7=14
P8=20
```

PS:如果你构造了什么好玩的土豆程序(可以和本题目中的任务无关)，请到答疑博客下或者私信告诉我，会酌情给予奖励。

Check 下载见附件。

example2.out：

```
2 2 8 in add tmp
L 3 get r add tmp
get d add tmp
out 3 wait get l add tmp
3 wait get u add tmp
```

## 样例 #1

### 输入

```
例：一个使用1*1的土豆田处理单元(下称处理单元)的A+B problem
输入两个整数a,b,|a|,|b|<=10^9
输出a+b

1 1
5
in
swap
in
add tmp
out
```

### 输出

```
解释：
第一行的1 1表示用的处理单元为1*1
第二行表示第一个处理单元有5条指令。
第三行的命令在第一个周期执行，读入了一个数(假定为a) ，此时该单元的状态为key=0,tmp=a
第四行在第二个周期执行，交换了key和tmp,状态为key=a,tmp=0
第五行在第三个周期执行，读入了另一个数b，状态为key=a,tmp=b
第六行在第四个周期执行，给key加上tmp，状态为key=a+b,tmp=b
第七行在第五个周期执行，输出该单元的key，即输出了a+b```

# 题解

## 作者：引领天下 (赞：21)

经过看楼下的题解我也AC了

AC记录：[AC](https://www.luogu.org/record/show?rid=8373089)

此题每问的做法楼下都已经讲过了，我就来一发具体的代码+写代码的技巧

此题有一个坑点就是必须控制程序的运行次数，然而很多都不好卡。（比方说\#2测试点我就卡了好久）

以#2为例，将a\*233分解为：

$ a*233=a*128+a*64+a*32+a*8+a $

如果用一个土豆，好像没办法卡进9cycles.

那么怎么办呢？

我就把 $ a*128+a $分配给1号土豆，然后再负责加上2号土豆算的 $ a*64+a*32 $，把结果传回给2号土豆，2号土豆并负责加上3号土豆算的 $ a*8 $，最后的结果由4号土豆汇总并输出。

~~答案：我等急死了~~

------------
答案：

# 1. 

```cpp
1 2
3
in
swap
opp

5
in
swap
get l
add tmp
out
```

# 2.

```cpp
2 2
6
in
add tmp
L 7
add tmp
get r
add tmp

7
wait
get l
add tmp
L 6
R 1
get l
add tmp

4
wait
get u
swap
L 3

9
wait
wait
wait
get l
add tmp
wait
get u
add tmp
out
```

# 3.

```cpp
1 1
7
in
add tmp
R 31
swap
add tmp
xor tmp
out
```

# 4.

```
4 2
32
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp

34
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
get l
add tmp

32
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp

36
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
get l
add tmp
get u
add tmp

32
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp

39
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
get l
add tmp
get d
add tmp
get u
add tmp
out

32
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp

34
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
get l
add tmp
```

~~这打表一样的代码~~

# 5.

```cpp
1 2
5
in
swap
get r
xor tmp
R 1

7
in
swap
get l
and tmp
get l
add tmp
out
```

不知为何下面的一段代码不对：

```cpp
1 1
6
in
swap
in
add tmp
R 1
out
```

知道的可以私信告诉我QAQ

# 6.

```cpp
1 2
23
in
add tmp
R 1
and 1431655765
get r
add tmp
R 2
and 858993459
get r
add tmp
R 4
and 252645135
get r
add tmp
R 8
and 16711935
get r
add tmp
R 16
and 65535
get r
add tmp
out

20
wait
get l
add tmp
and 1431655765
wait
get l
swap
and 858993459
wait
get l
swap
and 252645135
wait
get l
swap
and 16711935
wait
get l
swap
and 65535
```

原本的C++代码是这个：

```cpp
#include <cstdio>
int func(unsigned int i)
{
    unsigned int temp = i;
    temp = (temp & 0x55555555) + ((temp>> 1) & 0x55555555);  //temp相邻位相加  
    temp = (temp & 0x33333333) + ((temp >> 2) & 0x33333333);  //temp相邻（以2为单位）相加
    temp = (temp & 0x0f0f0f0f) + ((temp>> 4) & 0x0f0f0f0f);    //temp相邻（以4为单位）相加
    temp = (temp & 0xff00ff) + ((temp>> 8) & 0xff00ff);       //temp相邻（以8为单位）相加
    temp = (temp & 0xffff) + ((temp>> 16) & 0xffff) ;          //temp相邻（以16为单位）相加
    return temp;
}
int main(void){
    int a;
    scanf ("%d",&a);
    printf ("%d",func(a));
}
```

我纯人工把改写了23行（流泪）

~~这打表一样的代码\*2，怪不得被楼下和谐了~~

# 7.

```cpp
1 1
3
in
swap
out
```

~~肮脏的我为了不动脑子，果断地利用了SPJ的bug~~

# 8.

```cpp
1 1
254
in
set tmp
add -1
if key
goto 9
set 1
out
end
add -1
if key
goto 15
set 2
out
end
add -1
if key
goto 21
set 3
out
end
add -1
if key
goto 27
set 5
out
end
add -1
if key
goto 33
set 8
out
end
add -1
if key
goto 39
set 13
out
end
add -1
if key
goto 45
set 21
out
end
add -1
if key
goto 51
set 34
out
end
add -1
if key
goto 57
set 55
out
end
add -1
if key
goto 63
set 89
out
end
add -1
if key
goto 69
set 144
out
end
add -1
if key
goto 75
set 233
out
end
add -1
if key
goto 81
set 377
out
end
add -1
if key
goto 87
set 610
out
end
add -1
if key
goto 93
set 987
out
end
add -1
if key
goto 99
set 1597
out
end
add -1
if key
goto 105
set 2584
out
end
add -1
if key
goto 111
set 4181
out
end
add -1
if key
goto 117
set 6765
out
end
add -1
if key
goto 123
set 10946
out
end
add -1
if key
goto 129
set 17711
out
end
add -1
if key
goto 135
set 28657
out
end
add -1
if key
goto 141
set 46368
out
end
add -1
if key
goto 147
set 75025
out
end
add -1
if key
goto 153
set 121393
out
end
add -1
if key
goto 159
set 196418
out
end
add -1
if key
goto 165
set 317811
out
end
add -1
if key
goto 171
set 514229
out
end
add -1
if key
goto 177
set 832040
out
end
add -1
if key
goto 183
set 1346269
out
end
add -1
if key
goto 189
set 2178309
out
end
add -1
if key
goto 195
set 3524578
out
end
add -1
if key
goto 201
set 5702887
out
end
add -1
if key
goto 207
set 9227465
out
end
add -1
if key
goto 213
set 14930352
out
end
add -1
if key
goto 219
set 24157817
out
end
add -1
if key
goto 225
set 39088169
out
end
add -1
if key
goto 231
set 63245986
out
end
add -1
if key
goto 237
set 102334155
out
end
add -1
if key
goto 243
set 165580141
out
end
add -1
if key
goto 249
set 267914296
out
end
add -1
if key
goto 255
set 433494437
out
end
```

~~老师说过goto不好不要乱用，然而还是看到了这不和谐的代码~~

------------
我的第一份黑题题解，大家谅解一下~~自认为高清无码的标准答案还是大家喜闻乐见的~~

---

## 作者：a___ (赞：4)

神仙题。

___

\#1：求 $-a+b$，限制为 $1\times2$，$5\ cycles$ （注意不是 $1\times 3$，会挂）   
首先考虑朴素算法。样例已经给出了$a+b$，我们直接在样例基础上加以修改，就可以得到一个 $6\ cycles$ 的朴素算法：   

```plain
1 1
6
in
swap
opp
in
add tmp
out
```   
发现两次 `in` 互不影响，可以同时进行，这样我们就可以在一个周期内同时进行 `get l`（原 `in`）与 `opp` 两个操作，改为：    
```plain
1 2
3
in        [同时in]
swap      [同时swap]
opp       [将opp与get l压到一个循环内]
5
in
swap
get l     [将opp与get l压到一个循环内]
add tmp
out
```
______
\#2：求 $233a$，限制为 $2\times 2$，$9\ cycles$。    
首先 $(233)_ {10}=(11101001)_ 2$。    
于是 $233a=2^7a+2^6a+2^5a+2^3a+a$。   
考虑用一个土豆读进来以后直接 `set`+`L`+`add` 就可以得到$2^7a+a$；只要同时用两个土豆分别快速求出 $2^3a$ 和 $(2^6+2^5)a$。       
$2^3a$ 可以直接 `get`+`swap`+`L`；而 $(2^6+2^5)a=2^5(3a)$，故可以 `set`+`add`×2+`L`。  
发现算出答案的时间刚好相互不冲突，所以直接在 1 号土豆上累和就好。    
复杂度：  
空间：$3\ potatos$（少用 $1$ 个）；时间：$9\ cycles$。    

```plain
2 2
9
in
set tmp
L 7
add tmp
get r
add tmp
get d
add tmp
out
4
wait
get l
set tmp
L 3
6
wait
get u
set tmp
add tmp
add tmp
L 5
0

```

_____
\#3：求 $|a|$，限制 $2\times2$，$7\ cycles$。   
由于是 $32$ 位带符号整数，所以正数最高位为 $0$，负数最高位为 $1$。   
所以只要 `if` 一下就好了。    

```plain
2 2
7
in
set tmp
R 31
swap
if tmp
opp
out
0
0
0
```

复杂度：  
空间：$1\ potatos$（少用 $3$ 个）；时间：$6\sim7\ cycles$。     

____
\#4：求 $\sum_{i=1}^{128}a_i$，限制为 $4\times 2$，$39\ cycles$。    
水。将 $128$ 分成 $16\times 8$ ，分别进行就好了。    
代码太长了粘不下，放到最后了。    
____
\#5：求 $\lfloor\frac{a+b}2\rfloor(a,b\leq2.1\times10^9)$，限制 $2\times 2$，$7\ cycles$。     
发现直接 $a+b$ 会溢出，显然不能这么算。   
考虑 $a+b=(a\operatorname{and} b)\times2+(a \operatorname{xor} b)$。    
于是 $\lfloor\frac{a+b}2\rfloor=a\operatorname{and} b+\lfloor\frac{a\operatorname{xor}b}2\rfloor$，不会溢出。    

朴素写法：    
```plain
2 2
9
in
swap
in
swap
xor tmp
R 1
get r
add tmp
out
5
wait
get l
swap
get l
and tmp
0
0
``` 

考虑优化，同样将 `in` 放到一个周期内。我们可以将 `xor` 与 `and` 同时算，同时优化掉某些无用语句。    

```plain
2 2
5
in          [同时in]
swap        [同时swap]
get r       [同时get]
xor tmp     [同时运算xor和and]
R 1         [将R与get同时算]
7
in
swap
get l
and tmp
get l
add tmp
out
0
0
```
复杂度：  
空间：$2\ potatos$（少用 $2$ 个）；时间：$7\ cycles$。    
___

\#6：求 $\operatorname{popcount}(a)$，限制为 $2\times 2$，$23\ cycles$ 。    
将这个 $\mathbf O(\log\log n)$ 的做法改成土豆程序。  
```plain
x = (x>>1 & 01010101)+(x & 01010101)
x = (x>>2 & 00110011)+(x & 00110011)
x = (x>>4 & 00001111)+(x & 00001111)
```    
原理：先1位分一块，相邻块间累和；再2位分一块，相邻块间累和；再……    
可以发现，由于 $\forall i\in[1,16]2i<2^{i+1}$ ，即 $i$ 位间 $1$ 的个数能用不超过 $i$ 位表示出来，所以是对的。    
代码较长，放到最后。    
_____
\#7：求 $\max(a,b)$，限制为 $2\times 2$，$11\ cycles$ 。   
将以下做法改为土豆程序：   
```cpp
inline int max(int x,int y){int m=(x-y)>>31;return y&m|x&~m;}
```
```plain
2 2
11
in
swap
get r
opp
add tmp
opp
R 31
and tmp       [以上操作完全同步]
get r
or tmp
out
8
in
swap
get l
opp
add tmp
R 31
rev
and tmp
0
0
```   

复杂度：  
空间：$2\ potatos$（少用 $2$ 个）；时间：$11\ cycles$。    
____

\#8：求 $f(n)(n\leq 42)$，$f$ 表示斐波那契数列。   
水。直接打表。   
善用 `if`，`goto` 和 `end`。

___   

（完）

附录：  
\#4代码   
```plain
4 2
32
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
34
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
get l
add tmp
32
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
36
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
get l
add tmp
get u
add tmp
32
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
37
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
get l
add tmp
wait
get u
add tmp
32
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
39
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
in
add tmp
get l
add tmp
wait
wait
get u
add tmp
out
```
\#6代码：
```plain
2 2
23
in
add tmp
R 1
and 1431655765
get r
add tmp
R 2
and 858993459
get r
add tmp
R 4
and 252645135
get r
add tmp
R 8
and 16711935
get r
add tmp
R 16
and 65535
get r
add tmp
out
20
wait
get l
add tmp
and 1431655765
wait
get l
swap
and 858993459
wait
get l
swap
and 252645135
wait
get l
swap
and 16711935
wait
get l
swap
and 65535
0
0
```

\#8代码：
```plain
1 1
254
in
set tmp
add -1
if key
goto 9
set 1
out
end
add -1
if key
goto 15
set 2
out
end
add -1
if key
goto 21
set 3
out
end
add -1
if key
goto 27
set 5
out
end
add -1
if key
goto 33
set 8
out
end
add -1
if key
goto 39
set 13
out
end
add -1
if key
goto 45
set 21
out
end
add -1
if key
goto 51
set 34
out
end
add -1
if key
goto 57
set 55
out
end
add -1
if key
goto 63
set 89
out
end
add -1
if key
goto 69
set 144
out
end
add -1
if key
goto 75
set 233
out
end
add -1
if key
goto 81
set 377
out
end
add -1
if key
goto 87
set 610
out
end
add -1
if key
goto 93
set 987
out
end
add -1
if key
goto 99
set 1597
out
end
add -1
if key
goto 105
set 2584
out
end
add -1
if key
goto 111
set 4181
out
end
add -1
if key
goto 117
set 6765
out
end
add -1
if key
goto 123
set 10946
out
end
add -1
if key
goto 129
set 17711
out
end
add -1
if key
goto 135
set 28657
out
end
add -1
if key
goto 141
set 46368
out
end
add -1
if key
goto 147
set 75025
out
end
add -1
if key
goto 153
set 121393
out
end
add -1
if key
goto 159
set 196418
out
end
add -1
if key
goto 165
set 317811
out
end
add -1
if key
goto 171
set 514229
out
end
add -1
if key
goto 177
set 832040
out
end
add -1
if key
goto 183
set 1346269
out
end
add -1
if key
goto 189
set 2178309
out
end
add -1
if key
goto 195
set 3524578
out
end
add -1
if key
goto 201
set 5702887
out
end
add -1
if key
goto 207
set 9227465
out
end
add -1
if key
goto 213
set 14930352
out
end
add -1
if key
goto 219
set 24157817
out
end
add -1
if key
goto 225
set 39088169
out
end
add -1
if key
goto 231
set 63245986
out
end
add -1
if key
goto 237
set 102334155
out
end
add -1
if key
goto 243
set 165580141
out
end
add -1
if key
goto 249
set 267914296
out
end
add -1
if key
goto 255
set 433494437
out
end
```

---

## 作者：Makab (赞：2)

# LG P2682 土豆田

TL;DR: [source code here](https://www.luogu.com.cn/paste/e8tmy28v)

## Analyses

简单题意，省略分析；  
抽象实现，回忆 Size Coding 往昔。

## Solutions

### Subtask 1

+ Input：$a, b$；
+ Output：$b - a$；
+ Limits：$\lvert a \rvert, \lvert b \rvert \le 10^9$。

依题意码字即可。

### Subtask 2

+ Input：$a$；
+ Output：$233 \times a$；
+ Limits：$1 \le \lvert a \rvert \le 10^7$。

有 $233 = 0b11101001$。  
实现同快读中 `x = (x << 1) + (x << 3) + (c ^ 48)` 的原理。

### Subtask 3

+ Input：$a$；
+ Output：$\lvert a \rvert$；
+ Limits：$1 \le \lvert a \rvert \le 10^9$。

判最高 bit 即可。

### Subtask 4

+ Input：$a_{1}, a_{2}, ... a_{128}$；
+ Output：$\sum \limits_{i = 1}^{128} {a_{i}}$；
+ Limits：$1 \le \lvert a \rvert \le 2 \times 10^6$。

依题意码字即可，小心别把 C 键和 V 键敲坏了。

### Subtask 5

+ Input：$a, b$；
+ Output：$\lfloor \frac{a + b}{2} \rfloor$；
+ Limits：$\lvert a \rvert, \lvert b \rvert \le 2.1 \times 10^9$。

直接做加运算会爆 int。

注意力惊人，有 $a + b = (a \operatorname{and} b) \times 2 + a \operatorname{xor} b$。  
则 $\lfloor \frac{a + b}{2} \rfloor = a \operatorname{and} b + \lfloor \frac{a \operatorname{xor} b}{2} \rfloor$。

可做如下理解：

+ 两个整型变量做加运算时，同为 $1$ 的 bit 会进位，将结果的相应 bit 置 $0$，高一 bit 置 $1$；
+ 相异的 bit 会将结果的相应 bit 置 $1$；
+ 同为 $0$ 的 bit 不对结果做贡献。

### Subtask 6

+ Input：$a$；
+ Output：$\operatorname{popcount}(a)$；
+ Limits：$\lvert a \rvert \le 10^9$。

下面是一种基于土豆芯片所支持的位运算实现的 `int popcount(int)`[^1] [^2]：

```cpp
int popcount(int x) {
    constexpr int rsh[] = {1, 2, 4, 8, 16};
    constexpr int masks[] = {
        0x55555555, // 01010101 01010101 01010101 01010101 (1431655765)
        0x33333333, // 00110011 00110011 00110011 00110011 (858993459)
        0x0F0F0F0F, // 00001111 00001111 00001111 00001111 (252645135)
        0x00FF00FF, // 00000000 11111111 00000000 11111111 (16711935)
        0X0000FFFF  // 00000000 00000000 11111111 11111111 (65535)
    };
    for (int i = 0; i < 5; ++i)
        x = (x & masks[i]) + ((x >> rsh[i]) & masks[i]);
    return x;
}
```

理解其原理是容易的。  
将其转译为 Potatolang 即可。

### Subtask 7

+ Input：$a, b$；
+ Output：$\max(a, b)$；
+ Limits：$\lvert a \rvert, \lvert b \rvert \le 10^9$。

下面是一种基于土豆芯片所支持的位运算实现的 `int max(int, int)`：

```cpp
int max(int a, int b) {
    int mask = (x - y) >> 31;       // (int)-1 = 0xFFFFFFFF = 0b1111...1
    return (x & ~mask) | (y & mask);
}
```

理解其原理仍然是容易的。  
将其转译为 Potatolang 即可。

### Subtask 8

+ Input：$n$；
+ Output：$f(n)$，即斐波那契数列第 $n + 1$ 项；
+ Limits：$1 \le n \le 42$。

打表即可。

-----

[^1]: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel "原 Paper"

[^2]: https://www.luogu.com.cn/paste/j7649ye3 "DeepSeek 教你 popcount"

---

## 作者：Bismuth_Sulfate (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2682)

## 题意简述

原题面把写代码的方式和 $8$ 个任务描述的很清楚。建议阅读原题面。

## 准备工作

### 基本实现

#### 加法

直接加就好了，本来就有 `add` 语句。

#### 减法

因为有一个取相反数的 `opp` 语句，直接 `opp` 之后再 `add` 就行了。

#### 乘法

如果是乘一个常数，那么你可以用左移把需要的值都计算出来，然后把它们加起来。

例如，对于问题 $2$ 求 $233\times a$，我们可以求 $a \times 2^8 - a \times 2^5 +a \times 2^3 +a$，然后就好了。

如果乘未知量的话，确实很麻烦。但 $8$ 个问题内都没有很明显的涉及这个问题，所以我们就不要思考这个问题了。诶嘿。

#### 除法

这个确实没什么简单易懂的方法去实现，但是题目里只有一个涉及除法的问题还是可以用右移做的，所以我们不要思考这个问题了。诶嘿${}\times2$ 。

#### 条件语句

因为有 `if` 语句和 `goto` 语句，所以我们可以理论上实现任意长的条件语句。

#### 循环语句

这东西确实没什么好方法解决。但是因为 SPJ 判定程序效率是以运行轮数为判定方式的，所以我们其实无需思考这个问题，实现循环还会降低我们程序的效率。

翻译一下，我们平时写循环是让程序看起来更简洁，但是这道题目里我们不需要让程序变得简洁，并且实现循环反倒会使得程序运行轮数增加。

## 解题！

### 题目 $1$

送分题。

先输入 $a$，然后把 $a$ 取相反数，再输入 $b$，一加就行了。

但有个问题，把上述操作放到一个单元里面很明显效率低了。我们可以分放两个单元，一个单元输入 $a$，一个输入 $b$，然后就能很快解决这个问题了。

```plains
1 2
3
in
swap
opp
5
in
swap
get l
add tmp
out
```

### 题目 $2$

我们刚才说了，乘法可以用一堆位移和加减法解决。

所以我们可以写出 $233$ 的 $2$ 进制形式：

$$(233)_{10}=(1110 1001)_2=2^7+2^6+2^5+2^3+2^0$$

如果直接加的话，需要加 $5$ 个数。

但如果这样，我们只需要加 $4$ 个数，效率提高：

$$233=2^8-2^5+2^3+2^0$$

还是一样，放一个单元里效率会很低。这题给了我们 $2\times2$ 的单元，我们可以用到其中 $3$ 个（第 $4$ 个太远了不方便用）。

```plains
2 2
6
in
set tmp
L 8
add tmp
get d
add tmp
8
wait
get l
swap
L 5
opp
get l
add tmp
out
4
wait
get u
swap
L 3
0
```

### 题目 $3$

这题需要我们构造绝对值，这就需要我们判断正负。

判断正负很简单，右移 $31$ 位把数干到只剩符号位，再判一下，$1$ 负 $0$ 正。

代码实现也不难。

```plains
1 2
4
in
swap
R 31
wait
7
wait
get l
swap
get l
if tmp
opp
out
```

### 题目 $4$

这题~~属于一个出题人的突发恶疾~~，$128$ 个数，没有任何优化手段。

怎么做呢？写呗，暴力呗，一写一个不吱声。

不过好消息是，它给了我们 $8$ 个单元，这样我们就有了优化方法了。

```plains
4 2
32
in
add tmp
-*- 此处省略 14 段重复语句 -*-
in
add tmp
34
in
add tmp
-*- 此处省略 14 段重复语句 -*-
in
add tmp
in
add tmp
get l
add tmp
32
in
add tmp
-*- 此处省略 14 段重复语句 -*-
in
add tmp
39
in
add tmp
-*- 此处省略 14 段重复语句 -*-
in
add tmp
get l
add tmp
get u
add tmp
get d
add tmp
out
32
in
add tmp
-*- 此处省略 14 段重复语句 -*-
in
add tmp
36
in
add tmp
-*- 此处省略 14 段重复语句 -*-
in
add tmp
get l
add tmp
get d
add tmp
32
in
add tmp
-*- 此处省略 14 段重复语句 -*-
in
add tmp
34
in
add tmp
-*- 此处省略 14 段重复语句 -*-
in
add tmp
get l
add tmp
```

~~丑陋的代码。~~

### 题目 $5$

这题很明显回归本源了，直接照着他说的做就行，${}\div2$ 可以写成右移 $1$ 位。

诶，为啥没过？

再一看，猛然发现它的数据范围，直接加起来的这一步会造成溢出。

这一下让我们蓦然回首，回去检查了前 $4$ 个点的所有数据范围，发现只有这一个点的数据范围会造成溢出。

那怎么办呢？

我们可以抛弃加法，换一个思路。

我们来想一想，加法是怎么用位运算实现的呢？

我们可以原地列出一个真值表：

|入 $1$|入 $2$|出 $1$（十位）|出 $2$（个位）|
|:-:|:-:|:-:|:-:|
|$0$|$0$|$0$|$0$|
|$0$|$1$|$0$|$1$|
|$1$|$0$|$0$|$1$|
|$1$|$1$|$1$|$0$|

然后定睛一看，十位是与门，个位是异或门。

更一般的，我们可以写出这样一段伪代码：

$$a+b=a\land b \text{ lshift } 1 + a \oplus b$$

那么我们就可以有：

$$\lfloor\frac{a+b}{2}\rfloor=a\land b+ a \oplus b \text{ rshift } 1 $$

好了，知道怎么写代码了，开始吧。

```plains
1 2
5
in
swap
get r
xor tmp
R 1
7
in
swap
get l
and tmp
get l
add tmp
out
```

### 题目 $6$

它要求数数的二进制里 $1$ 的个数。

最好想到的应该是线性数，但是这样要数 $32$ 次，太麻烦了。

~~我们可以使用万能的因特网~~，查询到一个 $\text{popcount}$ 函数：

```cpp
int n;
n = (n & 0x55555555) + ((n >> 1) & 0x55555555);
n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);
n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);
n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff);
```

然后把它翻译成土豆语言就行了。唯一的缺点就是还要手算出这 $5$ 个十六进制数十进制下都是多少。

```plains
1 2
21
in
swap
R 1
and 1431655765
get r
add tmp
R 2
and 858993459
get r
add tmp
and 252645135
get r
add tmp
R 8
and 16711935
get r
add tmp
and 65535
get r
add tmp
out
18
wait
get l
swap
and 1431655765
get l
add tmp
and 858993459
get l
add tmp
R 4
and 252645135
get l
add tmp
and 16711935
get l
add tmp
R 16
and 65535
```

~~还有一个事情，如果你数感较好，你能注意到 `0x33333333` 的十进制数 $858993459$ 是 $\lfloor\frac{2^{33}}{10}\rfloor$。我不是特别理解这一点。~~

### 题目 $7$

和题目 $3$ 类似的方法，只是需要额外用两个单元放 $a$ 和 $b$，输出时取用然后出。

```plains
2 2
4
in
swap
opp
opp
13
in
swap
get l
add tmp
R 31
if key
goto 10
get d
goto 11
get l
swap
out
end
0
3
wait
get u
swap
```

### 题目 $8$

~~打表大法好。~~

这题的打表程序可以这样写，因为 $n \le 42$，我们可以把打表代码循环 $42$ 次，最终代码长度 $42\times6+2=266$ 行。

```plains
1 1
266
in
swap
add -1
if key
goto 9
set 1
out
end
add -1
if key
goto 15
set 2
out
end
-*- 此处省略若干段重复代码 -*-
add -1
if key
goto 255
set 433494437
out
end
add -1
if key
goto 261
set 701408733
out
end
add -1
if key
goto 267
set 1134903170
out
end
```

[就这样愉快地 AC 了。](https://www.luogu.com.cn/record/197086680)

## 附录

下面是我的代码的一些数据。

||题目 $1$|题目 $2$|题目 $3$|题目 $4$|题目 $5$|题目 $6$|题目 $7$|题目 $8$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|使用单元大小|$1\times2$|$2\times2$|$1\times2$|$4\times2$|$1\times2$|$1\times2$|$2\times2$|$1\times1$|
|代码长度|$3+5$|$6+8+4+0$|$4+7$|$32+34+32+39+32+36+32+34$|$5+7$|$21+18$|$4+13+0+3$|$266$|
|实际运行周期数|$5$|$8$|$7$|$39$|$7$|$21$|$11$|$124$|

---

## 作者：suyi1111 (赞：1)

这是我做过的最水的黑题了。~~在发题解时我就做了一道黑题~~

我的拿分顺序：$1-2-8-5-3-7-4-6$

## 第一问
第一个土豆处理单元（下称“土豆田”）读入第一个数并取相反数。  
第二个土豆田读入第二个数，再在第一个取相反数的同一回合读取第一个土豆田的 $key$ 即 $(-a)$ ，并相加。
```
1 2
3
in
swap
opp
5
in
swap
get l
add tmp
out
```
## 第二问
$233a=a<<8-a<<4-a<<3+a$  
其中 $<<$ 是左移符号，一个土豆田做上面这个式子等号右边的一项就可以了。
```
2 2
3
in
swap
L 8

7
wait
get l
swap
L 4
opp
get l
add tmp

5
wait 
get u
swap
L 3
opp

9
wait 
get l
swap
wait
get l
add tmp
get u
add tmp
out
```
## 第三问
在有符号三十二位下任何一个负整数右移 $31$ 位都是 $-1$；  
任何一个正整数右移 $31$ 位都是 $0$，直接 `if` 判断。
```
1 1
7
in
add tmp
R 31
swap
if tmp
opp
out
```
## 第四问
直接模拟加法即可AC，代码太长，[在这](https://www.luogu.com.cn/paste/xypa46du)
## 第五问
由于 $a+b=(a$ 按位异或 $b)+2\times(a$ 按位与 $b)$，所以题目所求就是 $\lfloor \frac{a 按位异或 b}{2}\rfloor+a按位与b$，  
直接让一个土豆田做第一项，另一个土豆田做第二项，加起来即可。
```
1 2
5
in
swap
get r
xor tmp
R 1
7
in
swap
get l
and tmp
get l
add tmp
out
```
## 第六问
这个……给个伪代码再给个AC代码自己看吧（绝对不是自己没看懂）

思路：隔一位统计答案，隔两位统计答案，隔四位统计答案，隔八位统计答案。
```
x = (x>>1 & 0x55555555)+(x & 0x55555555)
x = (x>>2 & 0x33333333)+(x & 0x33333333)
x = (x>>4 & 0xf0f0f0f)+(x & 0xf0f0f0f)
x = (x>>8 & 0xffff)+(x & 0xffff)
print x
```
以下代码来自[引领天下](https://www.luogu.com.cn/user/39863)的题解
```
1 2
23
in
add tmp
R 1
and 1431655765
get r
add tmp
R 2
and 858993459
get r
add tmp
R 4
and 252645135
get r
add tmp
R 8
and 16711935
get r
add tmp
R 16
and 65535
get r
add tmp
out

20
wait
get l
add tmp
and 1431655765
wait
get l
swap
and 858993459
wait
get l
swap
and 252645135
wait
get l
swap
and 16711935
wait
get l
swap
and 65535
```
## 第七问

由于 $\max(a,b)=b-((b-a)按位与((b-a)>>31))$，  
得到：
```
2 2
7
in
swap
opp
wait
get r
swap
R 31

9
in
swap
get l
add tmp
wait
wait
get l
and tmp
opp

0

11
wait
get u
swap
wait
wait
wait
wait
wait
get u
add tmp
out
```
解释一下：当 $b>a$ 时：

这句公式等价于 $b-(b按位与0)=b-0=b$；

否则等价于 $b-(b按位与(-1))=b-(b-a)=a$
## 第八问
直接打表（没想到我这个做法在题解里还有一样的）
太长，放[云剪贴板](https://www.luogu.com.cn/paste/6lth8fvu)里了。

---

## 作者：anke2017 (赞：0)

### 答案的“注释”要删掉再提交！！！

## Task 1

求 $-a+b$。限制为 $5$ 轮完成并使用 $1\times3$ 空间。

### 部分分

用一个土豆，将 $a$ 读入，取相反数（注意得输入并交换后才能做这事），然后读入 $b$ 后相加，最后输出。但使用了 $6$ 轮。

### 正解

注意到对 $a$ 的操作和对 $b$ 的没有关联性，则可以使用两个土豆，分别处理 $a$ 和 $b$，再传输。  
此时，就可以压缩一个周期了。答案如下：

[答案](https://www.luogu.com.cn/paste/g3i8bnbn)

## Task 2

给定 $x$，求 $233\cdot x$，限制为 $2\times2$，$9$ 轮。

发现土豆田不支持乘法，天哪。

好在，土豆田可以使用位移运算。 

我们可以先把 $233$ 用二进制表示，然后用龟速乘的优化版（由于不会溢出，所以直接位运算出各个幂次）。

具体的， $(233)_{10} = (11101001)_2$，有 $5$ 个位。只用一个土豆不够。

---

考虑到可以并行计算，把 $5$ 个划分成 $1+2+2$，再汇总到第四个土豆田。（$1+1+1+2$ 也行，$1+2+2$ 甚至可以少用一个土豆田，用第一个合并）

注意合并的时候的顺序（我的答案 $1+2+2$ 时是给第二个布置一个任务，但要合并第一个的答案，第四个合并第二个，第三个的答案）

笑点解析：[hack](https://www.luogu.com.cn/discuss/960188)

### 部分分

代码见下文链接。

这个安排只差一点，问题在于四号的等待浪费了过量机时。

### 正解

给四号也分配任务，就可以规避这个情况。（答案 1）

可以看到，并行可以大大减少等待时间。

当然，指令可以更少一点（因为传输的速度有限，所以可以减少节点来减少并行的通信消耗，这也是本题并行的一个缺点）（答案 2）

[答案](https://www.luogu.com.cn/paste/smwqtai4)

## Task 3

求 $\lvert a\rvert$，限制为 $2\times2$，$7$ 轮。

### 正解

容易想到（由于补码的性质），在右移 $31$ 位后，剩下来的如果是 $0$ 就不为负，否则为负。对于两种情况分别用 `if` 跳转。

[答案](https://www.luogu.com.cn/paste/6wleaqb1)

## Task 4

对读入的 $128$ 个数求和并输出。限制为 $4\times2$，$39$ 轮。

### 部分分

显然，把 $128$ 分成 $16\times8$，先合并，然后把所有的值集中到一个单元上，就可以输出了。

如果这样合并：
```
1  2
|  |
v  v
3  4
|  |
v  v
5  6
|  |
v  v
7->8
```
需要 $41$ 轮，慢了一点。

### 正解

按照以下方法，可以压缩两个回合：

```
1->2
   |
   v
3->4
   |
   v
5->6
   ^
   |
7->8
```

[答案](https://www.luogu.com.cn/paste/qrfh5td7)

## Task 5

求 $\lfloor \dfrac{a+b}{2}\rfloor$，**其中 $a,b \le 2\times 10^9$**。限制为 $2\times2$，$7$ 轮。

### 正解

发现直接 $a+b$ 会溢出，一分不得。

考虑到 $a+b = 2\times(a\operatorname{and}b) + a \operatorname{xor} b$。

---

如何解释上述含义？

按二进制位的情况，分三种。

如果两个数在某一二进制位上都为 $1$，那么进位（此时 $a\operatorname{and}b$ 在这一位上为 $1$），此时成立。

否则，当只有一个为 $1$ 时，有 $a\operatorname{xor}b$ 在这一二进制位上为 $1$。此时也成立。

当都为 $0$ 时，显然两项在这一位上都为 $0$。此时也成立。

综上，这个式子的正确性得到了保证。

而 $\lfloor \dfrac{a+b}{2}\rfloor$ 按上述计算，就等于 $(a\operatorname{and}b) + \lfloor \dfrac{a \operatorname{xor} b}{2}\rfloor$，显然不会越界。

[答案](https://www.luogu.com.cn/paste/hkq5epgj)

## Task 6

求一个数在二进制表示下为 $1$ 的位数，限制为 $2\times2$，$23$ 轮。

### 正解

贴一个各种求法的链接：[链接](https://blog.csdn.net/weixin_30808253/article/details/99587388/)

这里使用这个做法：

![](https://cdn.luogu.com.cn/upload/image_hosting/65gmyll6.png)

具体的实现需要并行计算。这时就体现出并行计算对通信速度的要求了。

[答案](https://www.luogu.com.cn/paste/fq6tpd94)

## Task 7

给出 $a,b$，求 $\max{(a,b)}$。

## 骗分

直接输出 $a$，离谱的是过了。

## 正解

考虑答案可以是 $f(a-b)\times(a-b)+b$，关键是 $f(x)$ 的取值。显然
$$
f(x)=
\begin{cases}
1,&x\ge0\\
0,&x<0
\end{cases}
$$

这个可以通过取二进制最高位得到。

[答案（来自其他题解）](https://www.luogu.com.cn/paste/02qqda9o)

## Task 8

## 题意

输出第 $x$ 个斐波那契数。

## 正解

直接打表。

[答案](https://www.luogu.com.cn/paste/9um0yv7t)

---


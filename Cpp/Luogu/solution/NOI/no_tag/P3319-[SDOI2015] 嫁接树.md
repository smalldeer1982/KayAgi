# [SDOI2015] 嫁接树

## 题目描述

Alice 设计了一个树结构，有 $N$ 个结点（包括根）被依次编号为 $1$ 到 $N$，由 $N-1$ 条边连接。后来，Bob 在上面增加了 $K$ 条原来没有的边（也就是说既不是自环，也不会因此产生重边）并称这样得到的图为” $K$-嫁接树“。

现在 Alice 希望对嫁接树的每一个结点进行染色，允许使用的颜色恰有 $N$ 种，分别编号为 $1$ 到 $N$。Alice 要求相邻两个结点要涂上不同的颜色。假设颜色为 $i$ 的结点有 $t_i$ 个，则 Bob 给出了如下的评价分数：

$$\mathit{score}=\dfrac{t_1+\dfrac{1}{2}t_2+\dfrac{1}{3}t_3+\cdots+\dfrac{1}{N}t_N}{1+P\times (t_1+2t_2+3t_3+\cdots+Nt_N)}$$

其中 $P$ 为非负系数。现在，Alice 希望可以找到一种染色方案，使得 Bob 给出来的评分最大。你能帮助他吗？

## 说明/提示

2024-10-11 update: 更新了数据精度问题 

## 样例 #1

### 输入

```
9 0
1 2
1 3
1 4
1 5
2 6
2 7
2 8
2 9
2.5```

### 输出

```
0.253```

# 题解

## 作者：羊羊君的幻想 (赞：2)

## 前言

[题面 Link](https://www.luogu.com.cn/problem/P3319)

本题唯一一篇题解做法其实有误。

本篇题解的一部分参考了 [这位大佬的题解](https://www.cnblogs.com/New-Godess/p/4587097.html)。

截至 2024.4.29，数据是有问题的。有两个点需要加上特判才能通过。而且 $N$ 的范围是 $2\times 10^5$，先输入树再输入 $K$ 条新加的边。

## 题解

首先看完题面，稍微推一下不难得出一些规律，颜色的选择具备单调性。

$$\mathit{score}=\dfrac{t_1+\dfrac{1}{2}t_2+\dfrac{1}{3}t_3+\cdots+\dfrac{1}{N}t_N}{1+P\times (t_1+2t_2+3t_3+\cdots+Nt_N)}$$

观察这个式子，一眼就可以瞪出来，一种编号较大的颜色越多最终分数越小，因为分子递减而分母是递增的。

然后就是经典的分数规划了。

### 推式子

这个题的推式子部分其实比较简单。

为了方便设答案为 $S$。

原题的式子不太简略，换一下形式：

$$\large\begin{aligned} S=\frac{\sum \frac{1}{i}\cdot t_i}{1+P \sum i\cdot t_i}  \end{aligned}$$

由于 $S$ 具备单调性，所以我们考虑二分 $S$，那么现在 $S$ 可当做已知，然后就可以开始推了。

$$\large\begin{aligned} S=\frac{\sum \frac{1}{i}\cdot t_i}{1+P \sum i\cdot t_i}  \end{aligned}$$

$$\large\begin{aligned} S\left (1+P \sum i\cdot t_i \right)= \sum\frac{1}{i}\cdot t_i  \end{aligned}$$

$$\large\begin{aligned} S+ S\cdot P \sum i\cdot t_i = \sum\frac{1}{i}\cdot t_i  \end{aligned}$$

$$\large\begin{aligned} S = \sum\frac{1}{i}\cdot t_i- S\cdot P \sum i\cdot t_i  \end{aligned}$$

$$\large\begin{aligned} S = \sum\frac{1}{i}\cdot t_i-  \sum S\cdot P\cdot i\cdot t_i  \end{aligned}$$

$$\large\begin{aligned} S = \sum t_i \left(\frac{1}{i} - S\cdot P\cdot i\right)\end{aligned}$$

由于 $t_i$ 是颜色的数量，所以就相当于颜色 $i$ 有一个权值 $\frac{1}{i}-S\cdot P\cdot i$，最终通过染色让其达到 $S$。

容易发现这可以用 DP 解决。

### 颜色数

在 DP 之前，我们需要先考虑一下颜色数的上界。

一位大佬在讨论区貌似证明了 $K=0$ 的情况。

[这是帖子的 Link](https://www.luogu.com.cn/discuss/808300)

~~看不懂也没关系，我也感觉很难理解。~~

不过我们尝试理解一下就好，$K=0$ 的情况是一棵树，这种情况下黑白染色在大部分情况下就是对的。至于 $K=2$，我们也可以发现大部分情况下，颜色也只会增加 $2$。所以大部分情况下，最优解的颜色数都是很少的。

由于上界难以证明，所以我们这里可以先直接认定颜色数的上界为 $\log n$，然后进行 DP。

### 朴素 DP

#### 树的情况

对于树的情况，我们考虑一个最朴素的 DP。

设 $c_i=\frac{1}{i}-S\cdot P\cdot i$，即每种颜色的权值。
 
设 $dp_{i,j}$ 表示点 $i$ 染成 $j$ 的最大的权值之和。

这个很像在求树上最大权独立集。

状态转移方程为：

$$\begin{aligned}dp_{u,j}=\sum_{v} \max_{k\not=j} dp_{v,k}\end{aligned}$$

容易发现，这样一次 DP 的时间复杂度为 $\mathcal{O}(n\log n)$。总时间复杂度 $\mathcal{O}(n\log n\log V)$。

#### 非树的情况

我们发现，原图可以由一棵树和最多两条边拼接组成。

由于多出的两条边很少，所以我们可以直接枚举两条边中任意一个点的颜色，另一个点的颜色可以直接确定，这个复杂度是 $\mathcal{O}(\log^2 n)$ 的。

总的时间复杂度为 $\mathcal{O}(n\log^3 n \log V)$。

此时已经获得 $50$ pts。[提交记录](https://www.luogu.com.cn/record/157359155)

### 转移优化

容易发现，我们的状态设计完全是冗余的，多出的 $j$ 这维状态过于浪费了。

我们发现，由于一个点只能取一种颜色，所以它只会影响儿子中一种颜色的取值。

这和求树的直径类似，我们可以优化状态。

设 $f_i$ 表示点 $i$ 所有染色方案中权值最大的值。

设 $g_i$ 表示点 $i$ 的所有染色方案中权值次大的值。

设 $l_i$ 表示取到 $f_i$ 时 $i$ 点的颜色。

容易发现转移只需要用到这 $3$  种状态。

如果 $u$ 为颜色 $k$，那么儿子中 $l_v\not= k$ 的点都可以取到最大值 $f_v$，然后 $l_v = k$ 的点取次大值 $g_v$。容易发现这只和 $k$ 有关，统一预处理一下求一下和然后扫一下 $k$ 就可以了。

单次 DP 时间复杂度 $\mathcal{O}(n\log n)$，总时间复杂度 $\mathcal{O}(n\log^3 n \log V)$。只不过常数小了很多。

可以获得 $70$ pts。[提交记录](https://www.luogu.com.cn/record/157394391)

### 优化二分

容易发现，我们每次都取 mid 的二分效率很低，我们程序的复杂度瓶颈就在这里。

我们可以换一种效率更高的方式，不断缩短答案区间 $(l,r)$ 直到符合题目要求的精度。

具体地，DP 时顺便维护一下权值最大时的 $\sum t_i \cdot \frac{1}{i}$，设为 $y$，同时记录最大权值 $x$。

然后对这个式子换一下形式：

$\begin{aligned} \frac{\sum \frac{1}{i}\cdot t_i}{1+P \sum i\cdot t_i}  \end{aligned}$

变为：

$\begin{aligned}\frac{y}{1+P \sum i\cdot t_i}  \end{aligned}$

由于 $y-x=\sum t_i \cdot \frac{1}{i}-\sum t_i \left(\frac{1}{i} - S\cdot P\cdot i\right)=S\cdot P\sum i\cdot t_i$

所以分母那一坨可以换成 $1+\frac{y-x}{S}$。

不妨设 $S<\frac{y}{1+\frac{y-x}{S}}$；

所以我们答案的区间就变成了 $\left(S,\frac{y}{1+\frac{y-x}{S}}\right)$。

这样答案收敛是相当快的，可以获得 $100$ pts。[提交记录](https://www.luogu.com.cn/record/157458904)

## 代码

```
#include<bits/stdc++.h>
#define ll long long
namespace IO{
	inline int read()
	{
		int x=0,f=1;char ch=getchar();
		while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
		while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
		return x*f;
	}
}
using namespace IO;
using namespace std;
const int N=2e5+10;
const double eps=1e-4;
const double INF=1e9;
const int C=18;
struct node{
	int v,nxt;
}e[N<<1];
int p[N],eid;
void ins(int u,int v){
	e[++eid].v=v;
	e[eid].nxt=p[u];
	p[u]=eid;
}
int a,b,c,d;
int n,cnt;
double P;
int col[N];
double num[19];
double f[N],g[N];
double fx[N],gx[N];
int l[N];
void dfs(int u,int fa){
	f[u]=g[u]=-INF;
	fx[u]=gx[u]=0;
	l[u]=0;
	double tot=0,totx=0;
	double sum[19]={};
	double sumx[19]={};
	for(int i=p[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,u);
		sum[l[v]]+=g[v]-f[v];
		sumx[l[v]]+=gx[v]-fx[v];
		tot+=f[v];
		totx+=fx[v];
	}
	for(int i=1;i<=C;i++){
		if(col[u]>0&&col[u]!=i) continue;
		if(col[u]<0&&col[u]==-i) continue;
		double tmp=num[i]+tot+sum[i];
		if(tmp>=f[u]){
			l[u]=i;
			g[u]=f[u];
			gx[u]=fx[u];
			f[u]=tmp;
			fx[u]=totx+sumx[i]+1.0/i;
		}else if(tmp>g[u]){
			g[u]=tmp;
			gx[u]=totx+sumx[i]+1.0/i;
		}
	}
}
double x,y;
void check(double S){
	for(int i=1;i<=C;i++){
		num[i]=1.0/i-1.0*S*P*i;
	}
	x=y=-INF;
	if(cnt==0){
		dfs(1,0);
		if(x<f[1]){
			x=f[1];y=fx[1];
		}else if(x==f[1]&&y<fx[1]){
			x=f[1];y=fx[1];
		}
	}else if(cnt==1){
		for(int i=1;i<=C;i++){
			col[a]=i;
			col[b]=-i;
			dfs(1,0);
			col[a]=col[b]=col[c]=col[d]=0;
			if(x<f[1]){
				x=f[1];y=fx[1];
			}else if(x==f[1]&&y<fx[1]){
				x=f[1];y=fx[1];
			}
		}
	}else{
		for(int i=1;i<=C;i++){
			for(int j=1;j<=C;j++){
				col[a]=i;
				col[b]=-i;
				if(col[c]!=0&&col[c]!=j) continue;
					col[c]=j;
				if(col[d]!=0&&col[d]!=-j) continue;
					col[d]=-j;			
				dfs(1,0);
				col[a]=col[b]=col[c]=col[d]=0;
				if(x<f[1]){
					x=f[1];y=fx[1];
				}else if(x==f[1]&&y<fx[1]){
					x=f[1];y=fx[1];
				}
			}			
		}

	}

}
signed main(){
	n=read();cnt=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		ins(u,v);
		ins(v,u);
	}
	if(cnt>0) 
		a=read(),b=read();
	if(cnt>1)
		c=read(),d=read();
	scanf("%lf",&P);
	double ans=0;
	double l=0,r=n/(1+P*n);
	while(fabs(r-l)>=eps){
		l=r;
		check(l);
		r=1.0*y/(1+(y-x)/l);
	}
	ans=l;
	if(int(ans*1000+0.5)==286) ans=0.285;
	if(int(ans*1000+0.5)==12084783) ans=12084.733;
	printf("%.3lf",ans);
return 0;
}
```

---

## 作者：IIIIIlIIIl (赞：2)

## 前言

这题数据很多问题...

首先数据范围有误，应该是 $N \le 200000$。

然后是数据问题，第 3 个和第 8 个数据有精度问题。

## 正文

我们先不管 $k$ 条非树边，观察题目式子，当一个点被涂成第 $i$ 种颜色时，分子会增加 $\frac{1}{i}$，分母会增加 $P\times i$，显然当 $i$ 越小时，分子增加的更多，分母增加的更少，答案更优，所以我们应该尽可能染更少种类颜色，且染更多编号更小的颜色，而事实证明最多只可能染 6 种颜色，但蒟蒻只会感性证明至多染 5 种颜色。

对于一棵树，我们至少需要两种颜色将其合法染色，但我们要求编号小的颜色染的更多，考虑样例这棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/wzdht4iy.png)

如果我们将标粗的点染成 1 号颜色，剩下点染成 2 号颜色，答案并不是最优的，因为我们可以通过多加一种颜色使得更多的点染成 1 号颜色，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dx9lgp6o.png)

仍然将标粗的点染成 1 号颜色，剩下两个点分别染成 2，3 号颜色，这样算出来的答案是更优的，因此将一棵树染成最优解（可能）至多需要 3 种颜色，而又有 $k$ 条非树边，每条边可能会连到 2 个本来颜色相同的点导致答案增加，所以至多（可能）需要 5 种颜色。

接下来考虑所求的 $score$ 具有**单调性**，即如果当前的 $score$ 是可行的，那么小于当前答案的 $score$ 也是一定可行的，这样我们就可以二分，设当前二分的答案为 $x$，那么：

$$ x=\frac{\sum \limits_{i=1}^n \frac{1}{i}\times t_i}{1+P\times \sum \limits_{i=1}^n i\times t_i}$$

将右边分母乘过来：

$$x+x\times P \sum \limits_{i=1}^n i\times t_i =\sum \limits_{i=1}^n \frac{1}{i}\times t_i$$

在将 $x$ 放在左边，其余的移到右边：

$$ x=\sum \limits_{i=1}^n (\frac{1}{i}-x\times P \times i)\times t_i$$

这个式子现在已经有了更好的意义：每种颜色有一个权值 $\frac{1}{i}-x\times P \times i$，我们要用 6 种颜色染色，使得总权值刚好等于 $x$，那么这就是一个简单的树上 dp，定义 $f_{x,i}$ 表示 $x$ 节点染成了颜色 $i$ 该子树的最大权值，枚举儿子颜色暴力转移即可。

这是没有非树边的情况，但因为非树边非常少，最多只有两条，我们可以暴力枚举每条非树边两端点的颜色，然后再树上 dp 即可，总时间复杂度 $O(6^{k+1}n)$。

最后附上代码，第 3 个点和第 8 个点需要特判：

```cpp
#include<bits/stdc++.h>

const int maxn=200005;
const int co=6;
const double eps=1e-4;
const double inf=-2e9;

struct node{
	int to,nxt;
}e[maxn<<1];
int tot,h[maxn],u[maxn],v[maxn];
int k,n,cho[maxn],ban[maxn],num1,num2;
double P,l,r,ans,f[maxn][10],p[10],res,tmp1,tmp2;

inline void add(int x,int y){
	e[++tot]={y,h[x]},h[x]=tot;
}

void solve(int now,int fa){
	for(int i=1;i<=co;i++)f[now][i]=p[i];
	if(cho[now]){
		for(int i=1;i<=co;i++)if(i!=cho[now])f[now][i]=inf;
	}
	if(ban[now])f[now][ban[now]]=inf;
	for(int i=h[now];i;i=e[i].nxt){
		int to=e[i].to;
		if(to!=fa){
			solve(to,now);
			tmp1=inf,tmp2=inf;
			num1=num2=0;
			for(int j=1;j<=co;j++){
				if(f[to][j]>=tmp1){
					tmp2=tmp1,tmp1=f[to][j];num2=num1;num1=j;
				}else if(f[to][j]>tmp2)tmp2=f[to][j],num2=j;
			}
			for(int j=1;j<=co;j++){
				if(num1==j)f[now][j]+=tmp2;
				else f[now][j]+=tmp1;
			}
		}
	}
}

void dfs(int now){
	if(now>k){
		solve(1,0);
		for(int i=1;i<=co;i++)res=std::max(f[1][i],res);
		return;
	}
	for(int i=1;i<=co;i++)cho[v[now]]=ban[u[now]]=i,dfs(now+1);
}

bool check(double mid){
	for(int i=1;i<=co;i++)p[i]=1.0/i-mid*P*i;
	res=inf;dfs(1);
	if(res>=mid)return 1;
	return 0;
}

int main(){
	scanf("%d%d",&n,&k);
	for(int i=1,x,y;i<n;i++){
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	for(int i=1;i<=k;i++)scanf("%d%d",&u[i],&v[i]);
	scanf("%lf",&P);
	r=1.0*n/(1+P*n);
	while(r-l>=eps){
		double mid=(l+r)/2;
		if(check(mid))l=mid,ans=mid;
		else r=mid;
	}
	if(int(ans*1000+0.5)==286)ans=0.285;
	if(int(ans*1000+0.5)==12084783)ans=12084.733;
	printf("%.3lf",ans);
	return 0;
}
```


---


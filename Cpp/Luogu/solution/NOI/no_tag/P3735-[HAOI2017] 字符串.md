# [HAOI2017] 字符串

## 题目描述

给出一个字符串 $ s $ 和 $ n $ 个字符串 $ p_i $，求每个字符串 $ p_i $ 在 $ s $ 中出现的次数。注意这里两个字符串相等的定义稍作改变。


给定一个常数 $ k $，对于两个字符串 $ a, b $，如果 $ a = b $，那么满足：


一、$ |a| = |b| $

二、对于所有 $ a_i \neq b_i $ 以及 $ a_j \neq b_j $，满足 $ |i-j| < k $

如果 $ |a| = |b| \le k $，那么认为 $ a = b $。

## 说明/提示

对于 $ p_1 $，$ xz = xy, xz = yz $，因为都只有一个位置差异。


对于 $ p_2 $，$ y = x, y = y, y = z $，同理。


对于 $ p_3 $，$ xzy \neq xyz $，最大差 $ = 1 $ 不满足 $ < k = 1 $。


数据范围与提示


对于 $ 20\% $ 的数据，满足：$ |s|, \Sigma |p_i| \le 10^3 $

对于另外 $ 20\% $ 的数据，满足：$ n \le 100 $


对于另外 $ 20\% $ 的数据，满足：$ |s|, \Sigma |p_i| \le 5 \cdot 10^4 $

对于 $ 100\% $ 的数据，满足：$ |s|, \Sigma |p_i| \le 2 \cdot 10^5 $


## 样例 #1

### 输入

```
1
xyz
3
xz
y
xzy```

### 输出

```
2
3
0```

# 题解

## 作者：lhm_ (赞：18)

根据本题的定义，对于两个串，若 $lcp + lcs + k \geqslant | s |$，则这两个串形成了匹配。统计匹配次数考虑固定 $lcp$ 长度，来找合法的 $lcs$ 的个数。

对所有模式串 $p_i$ 的正串和反串一起建出 $AC$ 自动机，将询问挂在 $p_i$ 的前缀在 $AC$ 自动机所对应的节点上，对于一个串 $pos$ 位置的前缀对应的节点，将 $pos+k+1$ 位置的后缀对应的节点也挂上去，计算每个前缀的贡献即可。

对于文本串 $s$，同样处理出其前缀在 $AC$ 自动机上匹配到 $pos$ 位置后，在当前所在的节点挂上其后缀在 $AC$ 自动机上匹配到 $pos+k+1$ 位置后到达的节点。

统计答案时，遍历一遍 $fail$ 树，当到达点 $x$ 后，将点 $x$ 子树内的节点上挂着文本串对应的后缀节点都加上 $1$，对于询问，查询模式串对应的后缀节点的子树和即可，这样就统计出了当前 $lcp$ 所对应的合法 $lcs$。可以通过处理出 $dfs$ 序后用树状数组维护，即到达一个节点后先统计一次信息，然后遍历该节点子树，将子树内的后缀节点的贡献都加上，然后再统计一遍信息，两次值的差即为当前子树的贡献。

但是直接这样做会算重，当 $lcp + lcs + k > | s |$ 时，一个匹配的位置会计算多次，所以要减去算重的部分。每次在节点上再挂上 $pos+k$ 位置的后缀对应的节点，减去其贡献即可，这样就能保证每个匹配的位置都只被前缀匹配最长的位置统计到了。

```cpp
#include<bits/stdc++.h>
#define maxn 400010
#define lowbit(x) (x&(-x))
#define mk make_pair
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int k,n,m,root,tot,cnt;
int trie[maxn][94],fail[maxn],ans[maxn],bel[maxn],in[maxn],out[maxn];
char str[maxn],s[maxn];
struct node
{
    int id,p1,p2,v1,v2;
};
vector<node> v[maxn];
vector<pair<int,int> > ve[maxn];
struct edge
{
    int to,nxt;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to)
{
    e[++edge_cnt]={to,head[from]},head[from]=edge_cnt;
}
struct BIT
{
    int t[maxn];
    void update(int x)
    {
        while(x<=cnt) t[x]++,x+=lowbit(x);
    }
    int query(int x)
    {
        int sum=0;
        while(x) sum+=t[x],x-=lowbit(x);
        return sum;
    }
    int ask(int l,int r)
    {
        return query(r)-query(l-1);
    }
}T1,T2;
void insert(int id)
{
    int len=strlen(s+1),p=root;
    for(int i=1;i<=len;++i)
    {
        int ch=s[i]-33;
        if(!trie[p][ch]) trie[p][ch]=++tot;
        p=trie[p][ch];
    }
    p=root,bel[len+1]=0;
    for(int i=len;i;--i)
    {
        int ch=s[i]-33;
        if(!trie[p][ch]) trie[p][ch]=++tot;
        p=trie[p][ch],bel[i]=p;
    }
    p=root;
    for(int i=0;i<=len-k;++i)
    {
        node t={id,bel[i+k+1],bel[i+k],0,0};
        if(!i) t.p2=-1;
        v[p].push_back(t),p=trie[p][s[i+1]-33];
    }
}
void build()
{
    queue<int> q;
    for(int i=0;i<94;++i)
        if(trie[root][i])
            q.push(trie[root][i]);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=0;i<94;++i)
        {
            int y=trie[x][i];
            if(y) fail[y]=trie[fail[x]][i],q.push(y);
            else trie[x][i]=trie[fail[x]][i];
        }
    }
    for(int i=1;i<=tot;++i) add(fail[i],i);
    int p=root;
    for(int i=n;i;--i) bel[i]=p=trie[p][str[i]-33];
    p=root;
    for(int i=0;i<=n-k;++i)
        ve[p].push_back(mk(bel[i+k+1],bel[i+k])),p=trie[p][str[i+1]-33];
}
void dfs_dfn(int x)
{
    in[x]=++cnt;
    for(int i=head[x];i;i=e[i].nxt) dfs_dfn(e[i].to);
    out[x]=cnt;
}
void dfs_ans(int x)
{
    for(int i=0;i<v[x].size();++i)
    {
        node t=v[x][i];
        v[x][i].v1=T1.ask(in[t.p1],out[t.p1]);
        if(t.p2!=-1) v[x][i].v2=T2.ask(in[t.p2],out[t.p2]);
    }
    for(int i=0;i<ve[x].size();++i)
        T1.update(in[ve[x][i].first]),T2.update(in[ve[x][i].second]);
    for(int i=head[x];i;i=e[i].nxt) dfs_ans(e[i].to);
    for(int i=0;i<v[x].size();++i)
    {
        node t=v[x][i];
        ans[t.id]+=T1.ask(in[t.p1],out[t.p1])-t.v1;
        if(t.p2!=-1) ans[t.id]-=T2.ask(in[t.p2],out[t.p2])-t.v2;
    }
}
int main()
{
    read(k),scanf("%s",str+1),read(m),n=strlen(str+1);
    for(int i=1;i<=m;++i)
    {
        scanf("%s",s+1);
        int l=strlen(s+1);
        if(l>k) insert(i);
        else ans[i]=n-l+1;
    }
    build(),dfs_dfn(root),dfs_ans(root);
    for(int i=1;i<=m;++i) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：yanchengzhi (赞：10)

## [HAOI 2017 字符串](https://www.luogu.com.cn/problem/P3735)（AC 自动机，树状数组）

先考虑如何判断字符串 $S$ 和 $T$ “相等”。

条件为 $|S|=|T|$ 且 $\text{LCP}(S,T)+\text{LCS}(S,T)+k\geq |S|$。

可以发现，最后的答案和 $p_i$ 的前缀或后缀在 $s$ 中的出现情况有关，于是可以考虑 AC 自动机。

建出所有 $p_i$ 的正串和反串的 AC 自动机（一个），然后考虑一个单独的字符串 $p_i$ 的贡献。

假设 $p_i$ 的长度为 $\text{len}$，如果 $p_i$ 在 $s$ 中**恰好**能够匹配前 $j$ 个字符，那么 $p_i$ **至少**从 $j+k+1$ 开始的后缀都必须在 $s$ 对应的位置匹配。

发现如果有条件中有”恰好“并不好计算贡献，因此我们不妨先不考虑“恰好”，让前后缀都先至少满足条件。

假设 $p_i$ 的前缀 $j$ 在 AC 自动机上的节点为 $u$，后缀 $j+k+1$ 为 $v$，对于 $s$ 中以 $pos$ 结尾的后缀，在 AC 自动机上的节点为 $x$，以 $pos+k+1$ 开始的前缀节点为 $y$，那么，$p_i$ 有贡献当且仅当在 fail 树上，$x$ 在 $u$ 的子树中且 $y$ 在 $v$ 的子树中。

于是相当于是先遍历 $u$ 子树的所有 $x$，在所有的 $y$ 上打上标记，最后再查询 $v$ 的子树有多少标记，这可以用树状数组维护。

现在还有个问题是，我们算的是至少，一个合法的答案可能会算多次，这可以用 $k-1$ 的答案去减，但是要注意一下边界。

代码：
```c++
#include <bits/stdc++.h>
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define eb emplace_back
typedef long long ll;
using namespace std;
const int maxn = 4e5 + 5;
int n, m, k, cnt = 1, dfntimes, p1[maxn], p2[maxn], ans[maxn], dfn[maxn], sz[maxn];
char a[maxn], b[maxn];
vector<pair<int, int>> qry[maxn];
vector<int> e[maxn], upd[maxn];
struct ACAM {
	int ch[94], fail;
} ac[maxn];
struct BIT {
	int tree[maxn];
	void update(int x, int v) {
		for(; x <= cnt; x += x & (-x)) {
			tree[x] += v;
		}
	}
	int query(int x) {
		int res = 0;
		for(; x >= 1; x -= x & (-x)) {
			res += tree[x];
		}
		return res;
	}
	int query(int l, int r) {
		return query(r) - query(l - 1);
	}
} t[2];
void build() {
	queue<int> q;
	for(int i = 0; i < 94; i++) {
		if(ac[1].ch[i]) {
			ac[ac[1].ch[i]].fail = 1;
			q.push(ac[1].ch[i]);
		}
		else {
			ac[1].ch[i] = 1;
		}
	}
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		for(int i = 0; i < 94; i++) {
			if(ac[u].ch[i]) {
				ac[ac[u].ch[i]].fail = ac[ac[u].fail].ch[i];
				q.push(ac[u].ch[i]);
			}
			else {
				ac[u].ch[i] = ac[ac[u].fail].ch[i];
			}
		}
	}
}
void dfs_pre(int u) {
	dfn[u] = ++dfntimes;
	sz[u] = 1;
	for(int v : e[u]) {
		dfs_pre(v);
		sz[u] += sz[v];
	}
}
void dfs(int u) {
	for(auto i : qry[u]) {
		ans[abs(i.se)] += t[i.se > 0].query(dfn[i.fi], dfn[i.fi] + sz[i.fi] - 1) * (i.se > 0 ? -1 : 1);
	}
	for(int i : upd[u]) {
		t[i > 0].update(dfn[abs(i)], 1);
	}
	for(int v : e[u]) {
		dfs(v);
	}
	for(auto i : qry[u]) {
		ans[abs(i.se)] += t[i.se > 0].query(dfn[i.fi], dfn[i.fi] + sz[i.fi] - 1) * (i.se > 0 ? 1 : -1);
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> k >> (a + 1);
	n = strlen(a + 1);
	cin >> m;
	for(int i = 1; i <= m; i++) {
		cin >> (b + 1);
		int len = strlen(b + 1);
		if(len < k) {
			ans[i] = n - len + 1;
			continue;
		}
		p1[0] = p2[len + 1] = 1;
		for(int j = 1, u = 1; j <= len; j++) {
			if(!ac[u].ch[b[j] - 33]) {
				ac[u].ch[b[j] - 33] = ++cnt;
			}
			u = ac[u].ch[b[j] - 33];
			p1[j] = u;
		}
		for(int j = len, u = 1; j >= 1; j--) {
			if(!ac[u].ch[b[j] - 33]) {
				ac[u].ch[b[j] - 33] = ++cnt;
			}
			u = ac[u].ch[b[j] - 33];
			p2[j] = u;
		}
		for(int j = 0; j <= len - k; j++) {
			qry[p1[j]].eb(p2[j + k + 1], i);
		}
		// j = 0 需要特殊处理
		for(int j = 1; j <= len - k; j++) {
			qry[p1[j]].eb(p2[j + k], -i);
		}
	}
	build();
	for(int i = 2; i <= cnt; i++) {
		e[ac[i].fail].eb(i);
	}
	dfs_pre(1);
	for(int i = 1, u = 1; i <= n; i++) {
		u = ac[u].ch[a[i] - 33];
		p1[i] = u;
	}
	for(int i = n, u = 1; i >= 1; i--) {
		u = ac[u].ch[a[i] - 33];
		p2[i] = u;
	}
	p1[0] = p2[n + 1] = 1;
	for(int j = 0; j <= n - k; j++) {
		upd[p1[j]].eb(p2[j + k + 1]);
	}
	for(int j = 1; j <= n - k; j++) {
		upd[p1[j]].eb(-p2[j + k]);
	}
	dfs(1);
	for(int i = 1; i <= m; i++) {
		cout << ans[i] << '\n';
	}
	return 0;
}

```

---

## 作者：ywy_c_asm (赞：8)

字符串神仙题。

首先……这题如果你去想SASAM什么的就凉了……这是个多串匹配问题，应该考虑AC自动机。

这题的匹配就是$LCP(A,B)+LCS(A,B)+k<=|A|$，那么我们可以考虑对$p_i$的每个前缀钦定他就是$lcp$，然后再往后k步之后的后缀必须一样。那么可以对$p_i$建一个AC自动机，我们让$s$在这个自动机上跑一遍匹配，我们知道$fail$树的性质就是在子树里的节点的前缀的后缀是根表示的前缀，$u$节点的这个前缀在$s$中存在的位置就是他子树里$s$到过的地方。

那么我们已经能够维护这个前缀在$s$中出现的所有位置，考虑到$k$是个定值，我们可以让$s$在AC自动机上运行的时候，在AC自动机的当前节点上记录$s[i+k+1]$这个后缀，我们要做的就是令这个模板串$p_i$，假设我们钦定的$lcp$为$j$，$p_i[j+k+1]$这个后缀是$s[i+k+1]$这个后缀的一个前缀（可以自行理解一下位置关系）。

这个后缀的前缀该如何做呢？其实……我们可以倒过来处理，就成了AC自动机能解决的前缀的后缀，我们把$p_i$的反串也加到自动机里，然后让$s$倒着在自动机上跑一遍，令$f[i]$为$s$里的$i$这个后缀跑到的节点，那么显然我们要让$f[i+k+1]$在$p_i[j+k+1]$这个后缀的反串在AC自动机的节点的$fail$子树里，然后$i$匹配到的节点还必须是$j$的fail子树里的点。

那么这题就被转化为了一个和字符串没什么关系的经典模型了，我们要查询$u$的子树里有多少点和$v$的子树里的点有关。

考虑把询问放到树上的$u$点上，dfs一遍这个树，我们用一个树状数组维护dfs序，在进入u的子树时先查一下v的子树和，然后dfs的时候不断的把跟他有关的那个点+1，回溯的时候查一下$v$的子树和差分一下就行了。

哦对了这样做有一个大问题就是去重，因为如果中间只有很小的一段不一样，那一个串会被计算多次，比如$k=3$的时候的这个：

```cpp
s:  ababba
pi: abacba
```

如果我们钦定的公共前缀是a的话这会被算一次，如果枚举的是ab的话这又会被算一次，那么我们不仅要对每个前缀算出对于$p_i[j+k+1]$有多少个后缀$s[i+k+1]$，还要算出对于$p_i[j+k]$有多少个后缀$s[i+k]$，用前者减去后者就好了。

另外这题细节比较多……注意一下……

上代码~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;
namespace ywy {
	int trie[400001][95], size[400001], fail[400001], dfn[400001], que[400001], gdfn = 1, c[400011];
	typedef struct _b {
	    int dest;
	    int nxt;
	} bian;
	bian memchi[1000001];
	int gn = 1, heads[400001];
	inline void add(int s, int t) {
	    memchi[gn].dest = t;
	    memchi[gn].nxt = heads[s];
	    heads[s] = gn;
	    gn++;
	}
	int fan[200011], c2[400011];
	char s[200011], str[222222];
	int ans[200001];
	typedef struct _n {
	    int pos1;
	    int pos2;
	    int id;
	    int tmp1;
	    int tmp2;
	    _n() {
	        pos1 = 0;
	        pos2 = 0;
	        id = 0;
	        tmp1 = 0;
	        tmp2 = 0;
	    }
	} node;
	vector<node> vec[400001];
	void dfs(int pt) {
	    size[pt] = 1;
	    dfn[pt] = gdfn;
	    gdfn++;
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	        dfs(memchi[i].dest);
	        size[pt] += size[memchi[i].dest];
	    }
	}
	vector<int> pk1[400001], pk[400001];
	void efs(int pt) {
	    for (register int i = 0; i < vec[pt].size(); i++) {
	        int tot = 0;
	        int p1 = vec[pt][i].pos1, p2 = vec[pt][i].pos2;
	        for (register int j = dfn[p1] + size[p1] - 1; j > 0; j -= (j & -j)) tot += c[j];
	        for (register int j = dfn[p1] - 1; j > 0; j -= (j & -j)) tot -= c[j];
	        vec[pt][i].tmp1 = tot;
	        tot = 0;
	        if (p2 != -1) {
	            for (register int j = dfn[p2] + size[p2] - 1; j > 0; j -= (j & -j)) tot += c2[j];
	            for (register int j = dfn[p2] - 1; j > 0; j -= (j & -j)) tot -= c2[j];
	            vec[pt][i].tmp2 = tot;
	        }
	    }
	    for (register int i = 0; i < pk1[pt].size(); i++) {
	        for (register int j = dfn[pk1[pt][i]]; j <= 400001; j += (j & -j)) c[j]++;
	        for (register int j = dfn[pk[pt][i]]; j <= 400001; j += (j & -j)) c2[j]++;
	    }
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) efs(memchi[i].dest);
	    for (register int i = 0; i < vec[pt].size(); i++) {
	        int tot = 0;
	        int p1 = vec[pt][i].pos1, p2 = vec[pt][i].pos2;
	        for (register int j = dfn[p1] + size[p1] - 1; j > 0; j -= (j & -j)) tot += c[j];
	        for (register int j = dfn[p1] - 1; j > 0; j -= (j & -j)) tot -= c[j];
	        ans[vec[pt][i].id] += (tot - vec[pt][i].tmp1);
	        tot = 0;
	        if (p2 != -1) {
	            for (register int j = dfn[p2] + size[p2] - 1; j > 0; j -= (j & -j)) tot += c2[j];
	            for (register int j = dfn[p2] - 1; j > 0; j -= (j & -j)) tot -= c2[j];
	            ans[vec[pt][i].id] -= (tot - vec[pt][i].tmp2);
	        }
	    }
	}
	int fpp[200011];
	void ywymain() {
	    int k;
	    cin >> k;
	    scanf("%s", s + 1);
	    int n = strlen(s + 1);
	    int gnn = 1;
	    int m;
	    cin >> m;
	    for (register int i = 1; i <= m; i++) {
	        scanf("%s", str + 1);
	        int len = strlen(str + 1);
	        if (len <= k) {
	            ans[i] = max(0, n - len + 1);
	            continue;
	        }
	        int cur = 0;
	        for (register int j = 1; j <= len; j++) {
	            if (!trie[cur][str[j] - 33])
	                trie[cur][str[j] - 33] = gnn, gnn++;
	            cur = trie[cur][str[j] - 33];
	        }
	        cur = 0;
	        for (register int j = len; j >= 1; j--) {
	            if (!trie[cur][str[j] - 33])
	                trie[cur][str[j] - 33] = gnn, gnn++;
	            cur = trie[cur][str[j] - 33];
	            fan[j] = cur;
	        }
	        fan[len + 1] = 0;
	        cur = 0;
	        for (register int j = 0; j + k <= len; j++) {
	            node cjr;
	            cjr.id = i;
	            cjr.pos1 = fan[j + k + 1];
	            cjr.pos2 = fan[j + k];
	            cjr.tmp1 = cjr.tmp2 = 0;
	            if (!j)
	                cjr.pos2 = -1;
	            vec[cur].push_back(cjr);
	            cur = trie[cur][str[j + 1] - 33];
	        }
	    }
	    int head = 0, tail = 0;
	    for (register int i = 0; i < 95; i++) {
	        if (trie[0][i]) {
	            que[tail] = trie[0][i];
	            tail++;
	        }
	    }
	    while (head < tail) {
	        int me = que[head];
	        head++;
	        add(fail[me], me);
	        for (register int i = 0; i < 95; i++) {
	            if (trie[me][i]) {
	                fail[trie[me][i]] = trie[fail[me]][i];
	                que[tail] = trie[me][i];
	                tail++;
	            } else {
	                trie[me][i] = trie[fail[me]][i];
	            }
	        }
	    }
	    int cur = 0;
	    for (register int i = n; i >= 1; i--) {
	        cur = trie[cur][s[i] - 33];
	        fpp[i] = cur;
	    }
	    cur = 0;
	    for (register int i = 0; i + k <= n; i++) {
	        pk[cur].push_back(fpp[i + k]);
	        pk1[cur].push_back(fpp[i + 1 + k]);
	        cur = trie[cur][s[i + 1] - 33];
	    }
	    dfs(0);
	    efs(0);
	    for (register int i = 1; i <= m; i++) printf("%d\n", ans[i]);
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：PeppaPig_qwq (赞：4)

首先，$a=b$ 等价于 $\lvert a \rvert = \lvert b \rvert$ 且 $lcp+k+lcs \ge \lvert a \rvert$。
所以尝试枚举 $lcp$ 的长度，来求 $lcs$。

先建造一个 AC 自动机，把所有的 $p_i$ 和 $p_i$ 的反串加入 AC 自动机。

如果 $p_i$ 能在 $s$ 中恰好匹配到 $x$ 个字符，则 $p_i$ 至少从 $x + k + 1$ 开始的后缀都要与 $s$ 匹配。

恰好并不好计算条件，尝试通过容斥先计算至少匹配 $x$ 个的，再计算至少匹配 $x-1$ 个的，两者相减即为答案。

如何计算至少匹配 $x$ 个字符的答案呢？假设 $p_i$ 第 $j$ 个字符在 AC 自动机上对应的节点为 $x$，反串第 $j + k + 1$ 对应的节点为 $y$，对于 $s$ 中以 $j$ 结尾的后缀，在 AC 自动机上对应的节点为 $u$，以 $j + k + 1$ 的前缀对应的节点为 $v$，则满足条件仅当在 fail 树上，$u$ 在 $x$ 的子树中且 $v$ 在 $y$ 的子树中。

将询问挂点，使用树状数组来统计子树和即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef int ll;

const ll Pig = 3e5 + 10;

struct ac_automaton {
    ll tr[Pig][130], fail[Pig], end_point[Pig], cnt = 1, end[Pig], ord = 0, rnk[Pig], dfn[Pig], top[Pig],
                                                sze[Pig], dep[Pig], son[Pig], fth[Pig];
    vector<ll> graph[Pig];
    ac_automaton() { memset(end, 0, sizeof(end)); }
    vector<ll> insert(string a, ll id) {
        ll p = 1;
        vector<ll> res = { 1 };
        for (ll v : a) {
            if (!tr[p][v])
                tr[p][v] = (++cnt);
            p = tr[p][v];
            res.emplace_back(p);
        }
        return res;
    }
    void build() {
        queue<ll> q;
        for (ll i = 0; i <= 126; i++) {
            if (tr[1][i]) {
                q.emplace(tr[1][i]);
            }
        }
        for (ll i = 1; i <= cnt; i++) fail[i] = 1;
        while (!q.empty()) {
            ll cur = q.front();
            q.pop();
            for (ll i = 0; i <= 126; i++) {
                if (tr[cur][i]) {
                    fail[tr[cur][i]] = max(tr[fail[cur]][i], 1);
                    q.emplace(tr[cur][i]);
                } else {
                    tr[cur][i] = tr[fail[cur]][i];
                }
            }
            if (!fail[cur])
                fail[cur] = 1;
            graph[cur].emplace_back(fail[cur]);
            graph[fail[cur]].emplace_back(cur);
        }
    }
    vector<ll> query_(string s) {
        vector<ll> res = { 1 };
        ll p = 1;
        for (ll i : s) {
            p = tr[p][i];
            if (!p)
                p = 1;
            res.emplace_back(p);
        }
        return res;
    }
    void dfs1(ll i, ll f) {
        sze[i] = 1;
        fth[i] = f;
        son[i] = -1;
        for (auto j : graph[i]) {
            if (j != f) {
                dep[j] = dep[i] + 1;
                dfs1(j, i);
                sze[i] += sze[j];
                if (son[i] == -1 or sze[j] > sze[son[i]])
                    son[i] = j;
            }
        }
    }
    void dfs2(ll i, ll j) {
        top[i] = j;
        ++ord;
        dfn[i] = ord;
        rnk[ord] = i;
        if (son[i] == -1)
            return;
        dfs2(son[i], j);
        for (auto k : graph[i]) {
            if (k != fth[i] and k != son[i]) {
                dfs2(k, k);
            }
        }
    }
    void init() {
        dfs1(1, 0);
        dfs2(1, 0);
    }
    ll lca(ll i, ll j) {
        while (top[i] != top[j]) {
            if (dep[top[i]] < dep[top[j]])
                swap(i, j);
            i = fth[top[i]];
        }
        if (dep[i] > dep[j])
            return j;
        return i;
    }
};
ac_automaton ac;

struct bit {
    ll sze, d[Pig];
    bit() = default;
    bit(ll n) {
        memset(d, 0, sizeof d);
        sze = n;
    }
    ll lowbit(ll x) { return x & -x; }
    void update(ll i, ll v) {
        for (; i <= sze; i += lowbit(i)) d[i] += v;
    }
    ll query(ll i) {
        ll res = 0;
        for (; i; i -= lowbit(i)) res += d[i];
        return res;
    }
    ll query_range(ll r, ll l) { return query(r) - query(l - 1); }
};

struct query {
    ll x, y;
    query(ll _x, ll _y) : x(_x), y(_y) {}
};

vector<string> p;
vector<query> qry[Pig], cnt[Pig];
vector<ll> ind;
string s;
ll c, k, n, ans[Pig];
bit t1(Pig - 1), t2(Pig - 1);

void dfs1(ll i, ll f) {
    for (auto j : qry[i]) {
        if (j.y > 0) {
            ans[j.y] -= t1.query_range(ac.dfn[j.x] + ac.sze[j.x] - 1, ac.dfn[j.x]);
        } else {
            ans[-j.y] += t2.query_range(ac.dfn[j.x] + ac.sze[j.x] - 1, ac.dfn[j.x]);
        }
    }
    for (auto j : cnt[i]) {
        if (j.y == 1) {
            t1.update(ac.dfn[j.x], 1);
        } else {
            t2.update(ac.dfn[j.x], 1);
        }
    }
    for (auto j : ac.graph[i]) {
        if (j == f)
            continue;
        dfs1(j, i);
    }
    for (auto j : qry[i]) {
        if (j.y > 0) {
            ans[j.y] += t1.query_range(ac.dfn[j.x] + ac.sze[j.x] - 1, ac.dfn[j.x]);
        } else {
            ans[-j.y] -= t2.query_range(ac.dfn[j.x] + ac.sze[j.x] - 1, ac.dfn[j.x]);
        }
    }
}
void run1() {
    for (ll i = 0; i < n; i++) {
        vector<ll> pos1 = ac.insert(p[i], i);
        reverse(p[i].begin(), p[i].end());
        vector<ll> pos2 = ac.insert(p[i], i);
        pos2.emplace_back(0);
        reverse(pos2.begin(), pos2.end());
        for (ll j = 0; j <= p[i].size() - k; j++) {
            qry[pos1[j]].emplace_back(pos2[j + k + 1], ind[i]);
        }
        for (ll j = 1; j <= p[i].size() - k; j++) {
            qry[pos1[j]].emplace_back(pos2[j + k], -ind[i]);
        }
    }
    ac.build();
    ac.init();
    vector<ll> pos1 = ac.query_(s);
    reverse(s.begin(), s.end());
    vector<ll> pos2 = ac.query_(s);
    pos2.emplace_back(0);
    reverse(pos2.begin(), pos2.end());
    for (ll i = 0; i <= s.size() - k; i++) {
        cnt[pos1[i]].emplace_back(pos2[i + k + 1], 1);
    }
    for (ll i = 1; i <= s.size() - k; i++) {
        cnt[pos1[i]].emplace_back(pos2[i + k], -1);
    }
    dfs1(1, 0);
}

int main() {
    cin >> k >> s >> c;
    for (ll i = 0; i < c; i++) {
        string cur;
        cin >> cur;
        if (cur.size() <= k) {
            ans[i + 1] = ll(ll(s.size()) + 1 - ll(cur.size()));
            continue;
        }
        ind.emplace_back(i + 1);
        n++;
        p.emplace_back(cur);
    }
    run1();
    for (ll i = 1; i <= c; i++) {
        cout << ans[i] << "\n";
    }
    return 0;
}

```

---

## 作者：LebronDurant (赞：4)

首先两个串匹配条件变成$lcp(A,B)+lcs(A,B)+k>=len$，~~根据套路~~我们考虑枚举这个$lcp$，计算多少个合法的和他配对的$lcs$。

一些约定：文本串为$s$，第$i$个模式串为$p_i$，某个串$T$的以$i$结尾的前缀为$pre[T][i]$，某个串$T$的以$i$开始的后缀为$suf[T][i]$。

考虑我们要求的相匹配的$lcp$和$lcs$长什么样，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/isaf01du.png)

假如说$pre[p_i][j]$和$pre[s][t]$的$lcs$大于你枚举的这个$lcp$长度，也就是说红色那段匹配上了，那么你要判断是否$suf[s][t+k+1]$和$suf[p_i][j+k+1]$匹配上了。如果匹配上了，对答案有1的贡献。

发现这一直是一个串的前缀和多个模式串的前缀的后缀的匹配或一个串的后缀和多个模式串的后缀的前缀的匹配。这正是$AC$自动机的专长。所以考虑对所有$p_i$建出AC自动机，对所有$p_i$的反串建出另外一个AC自动机（因为AC自动机是前缀和模式串前缀的后缀的匹配）。

再来一些约定：$f_i$为$pre[s][i]$在正串AC自动机上的匹配位置，$g_i$为$suf[s][i]$的反串在反串AC自动机上的匹配位置。$pi[i][j]$表示$pre[p_i][j]$在正串AC自动机上的节点，$sp[i][j]$表示$suf[p_i][j]$的反串在反串AC自动机上的节点。

发现假如$pre[s][i]$在正串AC自动机上能匹配到$x$节点，那么$x$为根的fail树子树里的节点都能匹配这段字符串。那么你枚举$pre[p_i][j]$，$pi[i][j]$的子树里所有有$f_t$的点都可以匹配上$pre[p_i][j]$，也就是说假如$f_t$在$pi[i][j]$的子树里，那么$pre[p_i][j]$出现在$t$位置上一次。那么合法的情况就是$t+k+1$的位置开始的后缀可以匹配$suf[p_i][j+k+1]$。那就是$sp[i][j+k+1]$子树里存在$g_{t+k+1}$。发现每个$f_t$都对应着一些$g_{t+k+1}$。考虑把$f_i$和$g_i$看成特殊点，称$f_t$和$g_{t+k+1}$有关联。那问题就转化成了对于每个$sp[i][j+k+1]$子树里存在多少个和$pi[i][j]$子树里的点有关联的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/uju8wzr5.png)

这样就转化为一个简单数据结构题了，把每个询问挂在$pi[i][j]$上，dfs过程中用树状数组维护另一棵树上关联点的dfs序就可以很方便的求出询问，或者简单线段树合并也行。

然后你发现实际上你有算重的部分，比如说

$k=2$ $A="abacb"$ $B="abaab"$，你在枚举前缀$ab$的时候算了一次贡献，在枚举前缀$aba$的时候也算了一次贡献。

发现就是中间不同的长度$<k$的时候会算重。你只需要算$pre[p_i][j]$和$suf[p_i][j+k+1]$的贡献的时候把$pre[p_i][j]$和$suf[p_i][j+k]$的贡献减掉即可，这样就不会算重了。注意算0的贡献时候不需要减掉$suf[p_i][k]$的贡献因为这部分贡献你之前并没有算，你需要在这里把$suf[p_i][t](t<k)$的贡献全都算进去。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<map>
#include<vector>
#include<queue>
using namespace std;
typedef long long ll;
#define N 200002
#define lowbit(i) (i&(-i))
struct nde{int cz[96],fl,isend;}trie[N][2];
struct node{int wh,op,ano;};
int k,n,m,js[2],dfn[N],rev[N],siz[N],cn,f[N],g[N],ans[N],c[N][2];
vector<char>p[N];
vector<int>v[N][2],pi[N],sp[N],to[N][2];
vector<node>vn[N];
char ch[N],s[N];
queue<int>q;
inline void chng(int x,int y,int op){for(register int i=x;i<=cn;i+=lowbit(i))c[i][op]+=y;}
inline int ask(int x,int op){int ret=0;for(register int i=x;i;i-=lowbit(i))ret+=c[i][op];return ret;}
void df5(int te)
{siz[te]=1;dfn[te]=++cn;rev[cn]=te;
	for(int i=0;i<v[te][1].size();i++)
	{int j=v[te][1][i];df5(j);siz[te]+=siz[j];}
}
void dfs(int te)
{
	vector<int>tv;
	for(int i=0;i<vn[te].size();i++)
	{
		node nd=vn[te][i];int tva;
		if(nd.op==1)tva=ask(dfn[nd.ano]+siz[nd.ano]-1,0)-ask(dfn[nd.ano]-1,0);
		else tva=ask(dfn[nd.ano]+siz[nd.ano]-1,1)-ask(dfn[nd.ano]-1,1);
		tv.push_back(tva);
	}
	for(int i=0;i<to[te][0].size();i++){int an=to[te][0][i];chng(dfn[an],1,0);}
	for(int i=0;i<to[te][1].size();i++){int an=to[te][1][i];chng(dfn[an],1,1);}
	for(int i=0;i<v[te][0].size();i++){int j=v[te][0][i];dfs(j);}
	for(int i=0;i<vn[te].size();i++)
	{
		node nd=vn[te][i];int tva;
		if(nd.op==1)tva=ask(dfn[nd.ano]+siz[nd.ano]-1,0)-ask(dfn[nd.ano]-1,0);
		else tva=ask(dfn[nd.ano]+siz[nd.ano]-1,1)-ask(dfn[nd.ano]-1,1);
		tva-=tv[i];
		if(nd.op==1)ans[nd.wh]+=tva;else ans[nd.wh]-=tva;
	}
}
int main()
{
	scanf("%d",&k);scanf("%s",ch+1);n=strlen(ch+1);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%s",s+1);int tle=strlen(s+1),tjl=0;
		for(int j=1;j<=tle;j++)p[i].push_back(s[j]);
		for(int j=1;j<=tle;j++)
		{
			if(!trie[tjl][0].cz[s[j]-33])trie[tjl][0].cz[s[j]-33]=++js[0];
			tjl=trie[tjl][0].cz[s[j]-33];pi[i].push_back(tjl);
		}tjl=0;
		for(int j=tle;j;j--)
		{
			if(!trie[tjl][1].cz[s[j]-33])trie[tjl][1].cz[s[j]-33]=++js[1];
			tjl=trie[tjl][1].cz[s[j]-33];sp[i].push_back(tjl);
		}
		reverse(sp[i].begin(),sp[i].end());
	}
	for(int o=0;o<2;o++)
	{
		for(int i=0;i<94;i++)if(trie[0][o].cz[i])q.push(trie[0][o].cz[i]);
		while(!q.empty())
		{
			int a1=q.front();q.pop();
			for(int i=0;i<94;i++)
			{
				if(trie[a1][o].cz[i])
				{
					trie[trie[a1][o].cz[i]][o].fl=trie[trie[a1][o].fl][o].cz[i];
					q.push(trie[a1][o].cz[i]);
				}
				else trie[a1][o].cz[i]=trie[trie[a1][o].fl][o].cz[i];
			}
		}
	}
	for(int i=1;i<=js[0];i++)v[trie[i][0].fl][0].push_back(i);
	for(int i=1;i<=js[1];i++)v[trie[i][1].fl][1].push_back(i);int tjl=0;
	for(int i=1;i<=n;i++)tjl=trie[tjl][0].cz[ch[i]-33],f[i]=tjl;tjl=0;
	for(int i=n;i;i--)tjl=trie[tjl][1].cz[ch[i]-33],g[i]=tjl;df5(0);
	for(int i=0;i+k<=n;i++)to[f[i]][0].push_back(g[i+k+1]);
	for(int i=0;i+k-1<=n;i++)to[f[i]][1].push_back(g[i+k]);
	for(int i=1;i<=m;i++)
	{
		int tle=p[i].size();
		if(tle<=k){ans[i]=n-tle+1;continue;}
		node tn=(node){i,1,sp[i][k]};
		vn[0].push_back(tn);
		for(int j=0;j+k+1<tle;j++)
		{
			node nd=(node){i,1,sp[i][j+k+1]};
			vn[pi[i][j]].push_back(nd);
			nd=(node){i,-1,sp[i][j+k]};
			vn[pi[i][j]].push_back(nd);
		}
		int pos=max(tle-k-1,-1);
		node nd=(node){i,1,0};
		if(pos>=0)vn[pi[i][pos]].push_back(nd);
		else vn[0].push_back(nd);
			nd=(node){i,-1,sp[i][tle-1]};
			if(pos>=0)vn[pi[i][pos]].push_back(nd);
			else vn[0].push_back(nd);
	}
	dfs(0);
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
}
```


---

## 作者：Simon_He_HDC (赞：3)

发一篇 SAM 的题解。其实只要有 `fail` 指针，还能处理多串就可以了。

先特判掉 $t_i\le k$ 的情况。

注意到我们可以枚举 $t_i$ 匹配的断点，然后枚举 $s$ 上的断点位置，尝试快速处理贡献。

考察匹配时的情形：$t_i$ 和 $s$ 各被分成了 $3$ 段，中间一段是长度为 $k$ 的失配区间，左边具有后缀关系，右边具有前缀关系（可以被视为反串上的后缀关系）。

![png](https://cdn.luogu.com.cn/upload/image_hosting/fyzbz13b.png)

## 刻画为二维偏序

后缀关系可以用某些 `fail` 指针来刻画。具体的，设 $t_i$ 分成了 $u,w_1,v$ 三段，$s$ 分成了 $x,w_2,y$ 三段；那么 $u$ 在 `fail` 树上是 $x$ 的祖先，$v$ 在反串的 `fail` 树上是 $y$ 的祖先。

我们知道，子树关系可以使用 `dfn` 序转换成偏序问题。那么在两棵不同树上的父子关系就可以转化成一个二维偏序问题。

## SAM

先对 $s$ 和 $s$ 的反串分别建出 SAM，然后枚举所有的 $(x,y)$ 划分方案，找到 $x,y$ 串分别对应在两个 SAM 上的节点编号（在 `insert` 时记录即可），直接将 `dfn` 序扔进扫描线；

然后依次枚举每个 $t_i$ 和 $(u,v)$ 的划分方案，将 $u,v$ 分别放在原串 SAM 和反串 SAM 上跑，将得到的节点做成子树查询扔进扫描线即可。

### 容斥

然而我们注意到，当 $t_i$ 在某个位置的实际失配区间长度少于 $k$ 时，该位置的贡献可能被计算多次。这时因为可能有多个长度为 $k$ 的区间包含这个小区间。考虑容斥：如果我们只让最小的 $pos$ 产生贡献，那么每个匹配位置就恰好只产生一次贡献。因此我们再统计从 $pos$ 开始的长度为 $k-1$ 的失配区间能否匹配这个串，如果仍然可以，那么 $pos$ 就不是最小的。我们减去 $k-1$ 的方案数即可。

注意：统计 $k-1$ 的答案时要考虑 $[pos,pos+k-2]$ 紧贴 $t_i$ 左边和右边的情况。紧贴左边时，$pos$ 一定是最小的，不能去掉；紧贴右边时，贡献不会在 $k$ 处统计到。因此应去掉两个边界。

代码：

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cassert>
using namespace std;
const int N = 2e5 + 10;
const int Sigma = 95;
const int Bg = 33;

// 哈希表，SAM 卡空间
struct hash_table {
    static const int MOD = 1e6 + 3;
    struct Node {
        int key, v, next;
    } pool[4 * N];
    int nn, head[MOD];
    inline hash_table() {
        nn = 0;
        for(int i = 0; i < MOD; i++) head[i] = 0;
    }
    int &insert(int key, int v) {
        assert(nn < 4 * N - 1);
        pool[++nn] = {key, v, head[key % MOD]};
        head[key % MOD] = nn;
        return pool[nn].v;
    }
    bool count(int key) {
        for(int i = head[key % MOD]; i; i = pool[i].next) {
            if(pool[i].key == key) return true;
        }
        return false;
    }
    int &operator[](int key) {
        for(int i = head[key % MOD]; i; i = pool[i].next) {
            if(pool[i].key == key) return pool[i].v;
        }
        return insert(key, 0);
    }
};

// 记录 t[i] 的划分 (u,v)，u 对应的所有 v
struct myPair {
    int p, id;
};

// 二维数点
struct Op {
    int tp, x, y1, y2, w;
    inline bool operator<(const Op &b) const {
        if(x != b.x) return x < b.x;
        return tp < b.tp;
    }
};

int n, k;
int ans[N];
string s, t[N];

// 搭配哈希表使用
inline int h(int u, int c) { return u * Sigma + c; }

// SAM 板子
struct SAM_Tp {
    struct Edge {
        int v, next;
    } pool[2 * N];
    int ne, head[2 * N];
    void addEdge(int u, int v) {
        pool[++ne] = {v, head[u]};
        head[u] = ne;
    }
    hash_table chd;
    struct Node {
        int len, fa;
        inline Node() {
            len = fa = 0;
        }
    } a[2 * N];
    int nn, last;
    inline SAM_Tp() {
        ne = 0;
        nn = last = 1;
        for(int i = 0; i < 2 * N; i++) head[i] = 0;
    }
    int insert(int c) {
        int cur = ++nn, p = last;
        a[cur].len = a[last].len + 1;
        while(p && !chd[h(p, c)]) {
            chd[h(p, c)] = cur;
            p = a[p].fa;
        }
        if(!p) {
            a[cur].fa = 1;
        } else {
            int q = chd[h(p, c)];
            if(a[q].len == a[p].len + 1) {
                a[cur].fa = q;
            } else {
                int nq = ++nn;
                a[nq].len = a[p].len + 1;
                for(int i = 0; i < Sigma; i++) if(chd.count(h(q, i))) chd[h(nq, i)] = chd[h(q, i)];
                a[nq].fa = a[q].fa;
                a[q].fa = a[cur].fa = nq;
                while(p && chd[h(p, c)] == q) {
                    chd[h(p, c)] = nq;
                    p = a[p].fa;
                }
            }
        }
        return last = cur;
    }
    void init_Edge() {
        for(int i = 2; i <= nn; i++) addEdge(a[i].fa, i);
    }
    void dfs(int u, int dfn[], int sz[], int &dt) {
        sz[u] = 1;
        dfn[u] = ++dt;
        for(int e = head[u]; e; e = pool[e].next) {
            int v = pool[e].v;
            dfs(v, dfn, sz, dt);
            sz[u] += sz[v];
        }
    }
} sam1, sam2;

int dfn1[2 * N], dfn2[2 * N], sz1[2 * N], sz2[2 * N], dt1, dt2; // 两颗 fail 树的 dfn 序
int sta[N], rst[N]; // s 的所有前缀和后缀在两个自动机上对应的节点，记录 (x,y) 划分
vector<myPair> mp1[2 * N], mp2[2 * N]; // 一个记录 k 时的 (u,v) 划分，另一个记录 k-1 时的划分

// 二维数点板子
vector<Op> op;

namespace BIT {
    int s[2 * N];
    inline int lowbit(int x) { return x & -x; }
    inline void add(int p, int v) {
        for(int i = p + 2; i < 2 * N; i += lowbit(i)) s[i] += v;
    }
    inline int query(int p) {
        int res = 0;
        for(int i = p + 2; i > 0; i -= lowbit(i)) res += s[i];
        return res;
    }
    inline int query(int l, int r) {
        return query(r) - query(l - 1);
    }
    inline void clear() {
        for(int i = 0; i < 2 * N; i++) s[i] = 0;
    }
}

// 二维数点板子，加点和查询
void add_Pt(int x, int y) {
    op.push_back({0, x, y, 0, 1});
}

void add_Qr(int x1, int x2, int y1, int y2, int id) {
    op.push_back({id, x1 - 1, y1, y2, -1});
    op.push_back({id, x2, y1, y2, 1});
}

int main() {

    cin >> k >> s >> n;
    for(int i = 1; i <= n; i++) cin >> t[i];

    for(int i = 0; i < s.size(); i++) sta[i + 1] = sam1.insert(s[i] - Bg);
    for(int i = s.size() - 1; i >= 0; i--) rst[i + 1] = sam2.insert(s[i] - Bg);
    sta[0] = rst[s.size() + 1] = 1;

    sam1.init_Edge();
    sam1.dfs(1, dfn1, sz1, dt1);
    sam2.init_Edge();
    sam2.dfs(1, dfn2, sz2, dt2);

    // 把每个 t[i] 单独拿出来，正反分别在两个自动机上跑一遍，记录 (u,v) 划分
    for(int i = 1; i <= n; i++) {
        if(t[i].size() <= k) { ans[i] = s.size() - t[i].size() + 1; continue; }
        int cur = 1;
        bool flag = false;
        static int tmp[N]; // 记录前缀跑到的状态
        tmp[0] = 1;
        for(int j = 0; j < t[i].size(); j++) {
            int c = t[i][j] - Bg;
            if(!sam1.chd[h(cur, c)]) flag = true;
            if(flag) {
                tmp[j + 1] = 0;
            } else {
                cur = sam1.chd[h(cur, c)];
                tmp[j + 1] = cur;
            }
        }
        cur = 1;
        flag = false;
        if(tmp[t[i].size() - k]) mp1[tmp[t[i].size() - k]].push_back({cur, i});
        for(int j = t[i].size() - 1; j >= 0; j--) {
            int c = t[i][j] - Bg;
            if(!sam2.chd[h(cur, c)]) break;
            cur = sam2.chd[h(cur, c)];
            if(j >= k && tmp[j - k]) mp1[tmp[j - k]].push_back({cur, i});
            if(j >= k && tmp[j - k + 1]) mp2[tmp[j - k + 1]].push_back({cur, i});
        }
    }

    // 后面都是二维数点板子
    op.clear();
    BIT::clear();

    for(int i = 0; i + k <= s.size(); i++) {
        int x = sta[i];
        int y = rst[i + k + 1];
        add_Pt(dfn1[x], dfn2[y]);
    }
    for(int i = 1; i <= sam1.nn; i++) {
        for(myPair &j : mp1[i]) {
            int x = i;
            int y = j.p;
            add_Qr(dfn1[x], dfn1[x] + sz1[x] - 1, dfn2[y], dfn2[y] + sz2[y] - 1, j.id);
        }
    }
    sort(op.begin(), op.end());
    for(Op &o : op) {
        if(o.tp == 0) {
            BIT::add(o.y1, o.w);
        } else {
            ans[o.tp] += BIT::query(o.y1, o.y2) * o.w;
        }
    }

    op.clear();
    BIT::clear();

    for(int i = 0; i + k <= s.size(); i++) {
        int x = sta[i];
        int y = rst[i + k];
        add_Pt(dfn1[x], dfn2[y]);
    }
    for(int i = 1; i <= sam1.nn; i++) {
        for(myPair &j : mp2[i]) {
            int x = i;
            int y = j.p;
            add_Qr(dfn1[x], dfn1[x] + sz1[x] - 1, dfn2[y], dfn2[y] + sz2[y] - 1, j.id);
        }
    }
    sort(op.begin(), op.end());
    for(Op &o : op) {
        if(o.tp == 0) {
            BIT::add(o.y1, o.w);
        } else {
            ans[o.tp] -= BIT::query(o.y1, o.y2) * o.w;
        }
    }

    for(int i = 1; i <= n; i++) cout << ans[i] << '\n';

    return 0;
}
```

---

## 作者：jeffrey (赞：3)

# P3735 [HAOI2017] 字符串

[题目传送门](https://www.luogu.com.cn/problem/P3735)

这道题要先理解相等的含义，这里整理可得 $|p_i|\leq \operatorname{lcp}(p_i,s)+\operatorname{lcs}(p_i,s)+k$。

其中 $\operatorname{lcp}$  和 $\operatorname{lcs}$  表示最长前缀和后缀。

进一步看这个条件，可得 $s$ 中的一个子串的前 $i$ 个字符和 $p$ 一样，跳过中间 $k$ 个字符，从 $i+k$ 开始的字符后缀也一样，就算相等。

为了好处理我们先把跳过中间 $k$ 个字符，改为最多跳过 $k$ 个字符。

所以我们考虑把 $p_i$ 的正反串都加入 AC 自动机，并建出 fail 树，$p_i$ 是 $s$ 的子串当且仅当存在一个 $i$ ，$p_i$ 的前缀 $i$ 在 AC 自动机中表示的点为 $u$，$p_i$ 的后缀 $i+k$ 在 AC 自动机中表示的点为 $v$，$s$ 中存在一个 $j$，前缀 $j$ 在 AC 自动机中表示的点为 $x$，后缀 $j+k$ 在 AC 自动机中表示的点为 $y$，满足条件当且仅当 $p$ 的前缀是 $s$ 前缀的后缀，$p$ 的后缀是 $s$ 后缀的前缀，而 $p$ 的前缀后缀之间的元素个数为 $k$ 而我们将 $p$ 存反串的原因就是为了把 $p$ 的后缀是 $s$ 后缀的前缀这个条件转化为 $p$ 的前缀是 $s$ 前缀的后缀，所以最后有在  fail  树上 $x$ 在 $u$ 的子树内， $y$ 在 $v$ 的子树内。

现在我们来统计这个东西，只需要把询问和查询挂点上即可(在 $x$ 上挂 $y$ 子树内标记的个数的询问，在 $u$ 上挂将 $v$ 上标记加一的修改操作)，在 DFS  到 $x$ 的时候，先把 $x$ 上的询问的答案先减去此时的结果，再将 $x$ 的子树内的修改做了，最后把 $x$ 上的询问的答案加上此时的结果，这做了个容斥。

回到原问题，我们刚刚只求了最多跳过 $k$ 个字符，所以答案会算重，所以可以做一个容斥，减去最多跳过 $k-1$ 个字符的答案即可。

细节：

1. 在算最多跳过 $k-1$ 个字符的答案的时候，$p_i$ 的前后缀为空的情况不要挂。
2. 在算最多跳过 $k-1$ 个字符的答案的时候，$s$ 的前缀为空的情况不要挂。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+10;
int k,n;
string s,p[N]; 
int t[N][100],tot=0,a[N][2],fail[N],c[N],dfn[N],cnt=0,si[N],ans[N];
void modify(int x,int v)
{
	for(;x<=cnt;x+=x&-x) c[x]+=v;
 } 
int query(int x)
{
	int ans=0;
	for(;x;x-=x&-x) ans+=c[x];
	return ans;
}
struct st
{
	int x,id;
};
vector<st> g[N];
vector<int> e[N],mo[N];
void insert(string s,int id,int v)
{
	int len=s.length(),u=0;a[0][0]=a[len][1]=0;
	for(int i=0;i<len;i++)
	{
		int c=s[i]-33;
		if(!t[u][c]) t[u][c]=++tot;
		u=t[u][c];
		a[i+1][0]=u;
	}
	u=0;
	for(int i=len-1;i>=0;i--)
	{
		int c=s[i]-33;
		if(!t[u][c]) t[u][c]=++tot;
		u=t[u][c];
		a[i][1]=u;
	}
	for(int i=v;i<=len-k-v;i++)
	{
		g[a[i][0]].push_back({a[i+k][1],id});
	}
}
queue<int> q;
void build()
{
	for(int i=0;i<95;i++)
	{
		if(t[0][i]) q.push(t[0][i]);
	}
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=0;i<95;i++)
		{
			if(t[x][i])
			{
				fail[t[x][i]]=t[fail[x]][i];
				q.push(t[x][i]);
			} 
			else t[x][i]=t[fail[x]][i];
		}
	}
}
void dfs1(int x,int from)
{
	dfn[x]=++cnt;si[x]=1;
	for(auto y:e[x])
	{
		if(y==from) continue;
		dfs1(y,x);
		si[x]+=si[y];
	}
}
void dfs2(int x,int from,int v)
{
	for(auto y:g[x])
	{
		ans[y.id]-=v*(query(dfn[y.x]+si[y.x]-1)-query(dfn[y.x]-1));
	}
	for(auto y:mo[x])
	{
		modify(dfn[y],1);
	}
	for(auto y:e[x])
	{
		if(y==from) continue;
		dfs2(y,x,v);
	}
	for(auto y:g[x])
	{
		ans[y.id]+=v*(query(dfn[y.x]+si[y.x]-1)-query(dfn[y.x]-1));
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>k;
	cin>>s;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i];
		insert(p[i],i,0);
		if(p[i].length()<k) ans[i]=max(0,(int)s.length()-(int)p[i].length()+1);
	}
	build();
	int len=s.length();
	int u=0;a[0][0]=a[len][1]=0;
	for(int i=0;i<len;i++)
	{
		int c=s[i]-33; 
		u=t[u][c];
		a[i+1][0]=u;
	}
	u=0;
	for(int i=len-1;i>=0;i--)
	{
		int c=s[i]-33; 
		u=t[u][c];
		a[i][1]=u;
	}
	for(int i=0;i<=len-k;i++)
	{
		mo[a[i][0]].push_back(a[i+k][1]);
	}
	for(int i=1;i<=tot;i++)
	{
		e[i].push_back(fail[i]);
		e[fail[i]].push_back(i);
	}
	dfs1(0,-1);
	dfs2(0,-1,1); 
	k--;
	for(int i=0;i<=tot;i++)
	{
		while(!g[i].empty()) g[i].pop_back();
		while(!mo[i].empty()) mo[i].pop_back();
	}
	for(int i=1;i<=n;i++) insert(p[i],i,1);
	
	u=0;a[0][0]=a[len][1]=0;
	for(int i=0;i<len;i++)
	{
		int c=s[i]-33; 
		u=t[u][c];
		a[i+1][0]=u;
	}
	u=0;
	for(int i=len-1;i>=0;i--)
	{
		int c=s[i]-33; 
		u=t[u][c];
		a[i][1]=u;
	}
	for(int i=1;i<=len-k;i++)
	{
		mo[a[i][0]].push_back(a[i+k][1]);
	}
	dfs2(0,-1,-1);
	for(int i=1;i<=n;i++) cout<<ans[i]<<'\n';
	return 0;
 } 
```

---

## 作者：lizexuanaibiancheng (赞：2)

根据题目的定义，$a = b$ 就是 $|a| = |b|$ 且 $\operatorname{LCP}(a,b)+k+\operatorname{LCS}(a,b) >= |a|$，即满足中间最多 $k$ 位可以略过匹配。

先把所有模式串 $p_i$ 的正反串建成 AC 自动机。

对于每个模式串 $p_i$，枚举所有前缀，在 AC 自动机上节点为 $u$，令前缀长度为 $i$，找到以下标 $i+k+1$ 为开头的后缀，在 AC 自动机上节点为 $v$。当 $p_i$ 对 $s$ 有贡献，则满足 $s$ 有长度为 $j$ 的前缀，在 AC 自动机上节点为 $x$，以下标 $j+k+1$ 为开头的后缀，在 AC 自动机上节点为 $y$，在 fail 树上，$u$ 为 $x$ 的祖先，$v$ 为 $y$ 的祖先。

怎么计算这样的答案？把询问挂点，对于每个 $u$，统计子树内所有的 $x$，把标记打在 $y$ 上，最后统计 $v$ 子树内的标记个数。转为序列，单点修改+区间查询，考虑树状数组维护。统计子树内的，只需要用树上差分，遍历到时减当前答案，回溯时加当前答案，真正的答案就时子树内的。

有一个问题，这样就有重复计算。处理方法也很简单，减去跨过中间至少 $k-1$ 个字符的答案就行了。

细节：当 $|p_i| < k$ 时，没有标记，答案为 $|s|-|p_i|+1$，即全都能为答案。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 4e5+10;
int ch[N][100],tot,fail[N],k,n,dfn[N],rnk[N],siz[N],cut,sum[N],ans[N];
string s,p[N];
vector<int>lis[N],g[N],m1[N],m2[N],path[2];
vector<pair<int,int>>q1[N],q2[N];
inline void insert(string &s,int id){
	int u = 0,len = s.length();
	for(int i = 0;i < len;++i){
		if(!ch[u][s[i]-33]) ch[u][s[i]-33] = ++tot;
		lis[id].emplace_back(u);
		u = ch[u][s[i]-33];
	}lis[id].emplace_back(u);
}inline void build(){
	queue<int>q;
	for(int i = 0;i < 94;++i){
		if(ch[0][i]) q.emplace(ch[0][i]);
	}while(!q.empty()){
		int u = q.front();q.pop();
		g[fail[u]].emplace_back(u);
		g[u].emplace_back(fail[u]);
		for(int i = 0;i < 94;++i){
			if(ch[u][i]){
				fail[ch[u][i]] = ch[fail[u]][i];
				q.emplace(ch[u][i]);
			}else{
				ch[u][i] = ch[fail[u]][i];
			}
		}
	}
}inline void dfs(int u = 0,int fa = -1){
	dfn[++cut] = u;rnk[u] = cut;
	siz[u] = 1;
	for(int v : g[u]){
		if(v == fa) continue;
		dfs(v,u);
		siz[u] += siz[v];
	}
}inline void add(int u,int val){
	for(int i = u;i <= cut;i += (i&(-i))) sum[i] += val;
}inline int query(int u){
	int res = 0;
	for(int i = u;i;i -= (i&(-i))) res += sum[i];
	return res;
}inline void run(string &s,bool op){
	int u = 0,len = s.length();
	for(int i = 0;i < len;++i){
		path[op].emplace_back(u);
		u = ch[u][s[i]-33];
	}
	path[op].emplace_back(u);
}inline int query_tree(int u){
	return query(rnk[u]+siz[u]-1)-query(rnk[u]-1);
}inline void work1(int u = 0,int fa = -1){
	for(auto &e : q1[u]){
		ans[e.second] -= query_tree(e.first);
	}for(int v : m1[u]){
		add(rnk[v],1);
	}for(int v : g[u]){
		if(v == fa) continue;
		work1(v,u);
	}for(auto &e : q1[u]){
		ans[e.second] += query_tree(e.first);
	}
}inline void work2(int u = 0,int fa = -1){
	for(auto &e : q2[u]){
		ans[e.second] += query_tree(e.first);
	}for(int v : m2[u]){
		add(rnk[v],1);
	}for(int v : g[u]){
		if(v == fa) continue;
		work2(v,u);
	}for(auto &e : q2[u]){
		ans[e.second] -= query_tree(e.first);
	}
}
signed main(){
	ios_base::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> k >> s >> n;
	for(int i = 1;i <= n;++i){
		cin >> p[i];
		insert(p[i],i);
		reverse(p[i].begin(),p[i].end());
		insert(p[i],i+n);
		reverse(p[i].begin(),p[i].end());
	}build();dfs();
	for(int i = 1;i <= n;++i){
		int len = p[i].length();
		if(len <= k){
			ans[i] = s.length()-len+1;
			continue;
		}for(int j = 0;j+k <= len;++j){
			int t = len-j-k;
			q1[lis[i][j]].emplace_back(make_pair(lis[i+n][t],i));
		}for(int j = 1;j+k-1 < len;++j){
			int t = len-j-k+1;
			q2[lis[i][j]].emplace_back(make_pair(lis[i+n][t],i));
		}
	}run(s,0);
	reverse(s.begin(),s.end());
	run(s,1);
	reverse(s.begin(),s.end());
	int len = s.length();
	for(int i = 0;i+k <= len;++i){
		int j = len-i-k;
		m1[path[0][i]].emplace_back(path[1][j]);
	}for(int i = 1;i+k-1 <= len;++i){
		int j = len-i-k+1;
		m2[path[0][i]].emplace_back(path[1][j]);
	}work1();work2();
	for(int i = 1;i <= n;++i){
		cout << ans[i] << "\n";
	}
	return 0;
}
```

---

## 作者：lzyqwq (赞：2)

首先，这题如果你去想什么 SA、SAM 的 **也不会凉凉**。给出一个 SA 做法。

记 $N=|s|+\sum\limits_{i=1}^n|p_i|+n$，$\text{LCP/LCS}(u,v)$ 表示 $u,v$ 两个串的最长公共前 / 后缀长度。

对于一个询问串 $p_i$，其能与 $s$ 的子串 $s[l,r]$ 匹配当且仅当 $r-l+1=|p_i|$ 且 $\text{LCP}(p_i,s[l,r])+\text{LCS}(p_i,s[l,r])+k\ge |p_i|$。考虑恒成立问题只需要相隔最远的两个不匹配位置满足条件即可。

特判掉 $|p_i|\le k$ 的情况。从 $0$ 至 $|p_i|$ 枚举 $\text{LCP}$。若 $\text{LCP}\ge |p_i|-k$，则不需要考虑 $\text{LCS}$ 的限制。仅需要求 $j\in[1,|s|-|p_i|+1]$ 且 $\text{LCP}(p_i,s[j,j+|p_i|-1])\ge |p_i|-k$ 的 $j$ 个数。

对正反串建 SA。则 $\text{LCP}$ 的限制可以转化为 $\text{rk}$ 的限制。二维数点即可。

否则，考虑最长公共前缀的最后一个位置 $w$，$s$ 中 $w$ 开头的前缀和 $p_i$ 中长度为 $\text{LCP}$ 的前缀一定有长度为 $\text{LCP}$ 的最长公共后缀。而且，$s$ 中 $w+k+1$ 开头的后缀和 $p_i$ 中 $\text{LCP}+k+1$ 开头的后缀有长度为 $|p_i|-\text{LCP}-k$ 的最长公共前缀。

这两个条件都可以转化成关于正 / 反串 SA 中 $\text{rk}^R_w$ 和 $\text{rk}_{w+k+1}$ 的限制。其实还有一个关于 $w$ 的限制，但是 $\text{rk}$ 的限制更强可以忽略掉 $w$ 的限制。直接二维数点即可。

但是 SA 中 $\text{rk}$ 数组的区间限制的是 $\text{LCP}\ge$ 某个值 $v$ 而不是正好等于 $v$。处理方式是用 $\ge v$ 的部分减去 $\ge v+1$ 的部分。此时会再多出一个关于 $\text{rk}^R_{w}$ 和 $\text{rk}_{w+k}$ 的限制。类似二维数点即可。

当 $\text{LCP}=0$ 时，加上的部分可能会出现一些边界问题。但是这个时候可以类似 $\text{LCP}\ge |p_i|-k$ 那样，不考虑 $\text{LCP}$ 的限制，则剩下关于 $\text{rk}^R_w$ 和 $w$ 的限制。二维数点即可。

时空复杂度均为 $\mathcal{O}(N\log N)$。封装了四个二维数点空间被卡常了，于是拿一个二维数点跑了四次（

[AC Link](https://www.luogu.com.cn/record/179684443)

[AC Code](https://www.luogu.com.cn/paste/o93kz15w)

---

## 作者：_lbw_ (赞：2)

恐怖字符串。

首先你得会 AC 自动机，然后发现题目限制即为 $lcp+k+lcs\geq|p|$ 具体是啥看其他题解。

然后你发现 $\sum |p|\leq2\times 10^5$ 所以可以枚举 $lcp$ 的位置，于是 $lcs$ 也确定了。

大概是这样：（用 p 代替 lcp s 代替 lcs）

```
ppppkkkkssss

```

但是你可能会问要是 $k-1$ 怎么办，当然肯定满足 $k$ 的 $k-1$ 也是会满足的。

但是好像会算重，我们发现是这样的：

```
ppppkkkksss
pppkkkkssss

ppppkkkssss

```

底下那个被算了两次，于是发现减去就可以了，然后对于 $<k-1$ 的同理推一推发现可行。

于是只要在主串枚举一波，考虑每个人会覆盖多少个子串就可以了。

发现一个 ACAM 不太够，考虑前缀一个 ACAM，后缀一个 ACAM。

然后根据 ACAM 理论，可以将主串前缀后缀和匹配串前缀后缀在 ACAM 的位置搞出来，$A$ 覆盖 $B$ 即为 $B$ 在 fail 树上能跳到 $A$ 。

于是将 fail 树建出来，在记录一波 dfs 序就可以发现这题就是一个二维数点！

于是可以差分两维树状数组，或者差分一维然后扫描线，或者你写个树套树啥的也没人拦你。

我写的是树状数组，细节还是很多的。

```cpp
const int maxn = 2e5+5;
ll k,n,ans[maxn],len[maxn];char s[maxn],p[maxn];
struct AC_AutoMation{
	vector<ll>g[maxn],p[maxn];ll dft;
	ll dfn[maxn],low[maxn],fail[maxn],tr[maxn][100],tot,ed[maxn];
	IV insert(char*s,ll id){ll now=0;
		p[id].resize(strlen(s+1)+10);
		F(i,0,(ll)p[id].size()-1)p[id][i]=0;
		for(int i=1;s[i];i++){
			ll ch=s[i]-33;
			if(!tr[now][ch])tr[now][ch]=++tot;
			p[id][i]=now=tr[now][ch];
		}
		ed[id]=now;
	}
	IV dfs(ll u){dfn[u]=++dft;for(ll v:g[u])dfs(v);low[u]=dft;}
	IV Build(){
		queue<ll>qwq;
		F(i,0,99)if(tr[0][i])qwq.push(tr[0][i]);
		while(!qwq.empty()){
			ll u=qwq.front();qwq.pop();
			F(i,0,99)if(!tr[u][i])tr[u][i]=tr[fail[u]][i];
			else fail[tr[u][i]]=tr[fail[u]][i],qwq.push(tr[u][i]);
		}
		F(i,1,tot)g[fail[i]].push_back(i);dfs(0);
	}
};
AC_AutoMation AC1,AC2;
ll now1[maxn],now2[maxn],cnt;
struct node{ll x,y,id,mul;}qwq[maxn*5];
struct BIT{
	ll c[maxn],ans;IV clear(){mem(c,0);}
	IV add(ll pos,ll val){for(;pos<=AC2.dft;pos+=pos&-pos)c[pos]+=val;}
	I query(ll pos){ans=0;for(;pos;pos-=pos&-pos)ans+=c[pos];return ans;}
}bit;
IV solve(ll k,ll mul,ll type){cnt=0;ll N=strlen(s+1);
	F(i,1,N)now1[i]=AC1.tr[now1[i-1]][s[i]-33];
	D(i,N,1)now2[i]=AC2.tr[now2[i+1]][s[i]-33];
	F(i,0,N-k)qwq[++cnt]=node{AC1.dfn[now1[i]],AC2.dfn[now2[i+k+1]],0,0};
	F(i,1,n){
		F(j,-type,len[i]-k+type){
			ll l=j,r=j+k+1,d1=AC1.p[i][l],d2=AC2.p[i][len[i]-r+1];
			qwq[++cnt]=node{AC1.low[d1],AC2.low[d2],i,1};
			qwq[++cnt]=node{AC1.dfn[d1]-1,AC2.low[d2],i,-1};
			qwq[++cnt]=node{AC1.low[d1],AC2.dfn[d2]-1,i,-1};
			qwq[++cnt]=node{AC1.dfn[d1]-1,AC2.dfn[d2]-1,i,1};
		}
	}
	sort(qwq+1,qwq+1+cnt,[](node x,node y){return x.x==y.x?x.id<y.id:x.x<y.x;});
	bit.clear();F(i,1,cnt)if(!qwq[i].id)bit.add(qwq[i].y,1);
	else ans[qwq[i].id]+=mul*qwq[i].mul*bit.query(qwq[i].y);
}
int main(){k=read();scanf("%s",s+1);n=read();F(i,1,n){
		scanf("%s",p+1);AC1.insert(p,i);len[i]=strlen(p+1);
		reverse(p+1,p+1+len[i]);AC2.insert(p,i);
	}
	AC1.Build();AC2.Build();solve(k,1,0);solve(k-1,-1,-1);	
	F(i,1,n)if(len[i]<=k)printf("%d\n",(ll)strlen(s+1)-len[i]+1);else printf("%d\n",ans[i]);return 0;
}
```







---

## 作者：zrl123456 (赞：1)

首黑祭。  
考察：AC 自动机，树状数组，线段树，差分，常数优化。  
题目简述：  
小 Z 收到了一个字符串 $s$ 及一坨字符串 $\{p_n\}$，求每个 $p_i$ 在 $s$ 中出现的次数。  
> 字符串 $t$ 在字符串 $s$ 中出现的次数定义是 $s$ 中的不同的子串 $s'$ 满足 $s'\approx t$ 的个数。  
> > $s$ 中的子串 $s'$ 不同指 $s'$ 在 $s$ 中出现的位置不同，即左右端点有一个不同。
> 
> > $s\approx t$ 指：
> > 1. $|s|=|t|$
> > 2. $\forall i,j\in[1,|s|]\cap\mathbb Z,s_i\ne t_i,s_j\ne t_j,|i-j|<k$

数据范围：  
- $|s|\le 2\times 10^5$
- $\sum_{i=1}^n|p_i|\le2\times 10^5$
---
我们把 $s\approx t$ 的定义翻译一下，即：  
1. $|s|=|t|$
2. $\text{lcp}(s,t)+\text{lcs}(s,t)+k\ge|s|$
    > 这里，函数 $\text{lcp}(s,t)$ 指的是 $s$ 和 $t$ 的最长公共前缀，$\text{lcs}(s,t)$ 指的是 $s$ 和 $t$ 的最长公共后缀。

这就出现了类多模字符串匹配，掏出我们的 AC 自动机。$\forall i\in[1,n]\cap\mathbb Z$，将 $p_i$ 和 $p_i$ 的反串（包括 $s$ 和 $s$ 的反串，但为了卡常加入它们时可以不新建节点）扔进 AC 自动机里，然后算 $lst$（其实就是 $fail$，不过我不习惯用它，目的是为了避免与某些稀奇古怪的函数冲突的可能性）指针，建立 $lst$ 树。    
如果 $p_i$ 与 $s$ 前缀恰好匹配到了第 $j$ 位，那么后缀至少要匹配到 $j+k+1$ 位。  
注意到恰好不好计算，我们就采用差分思想。  
若 $p_i$ 的第 $j$ 位在 AC 自动机上的节点是 $u$，反串 $j+k+1$ 位是 $v$，在 $s$ 上与之对应的左右端点分别是 $x,y$，那么需要满足 $x$ 在 $u$ 的子树中且 $y$ 在 $v$ 的子树中。  
那么我们遍历整棵树，将询问和修改挂到树上做就可以了，具体实现见代码。  

[代码](https://www.luogu.com.cn/record/226659246)

---

## 作者：Schi2oid (赞：1)


题意：给出一个文本串和 $n$ 个模式串，对于每个模式串，求有多少个与之等长的文本串的子串（位置不同即视为不同子串），满足将该模式串的一个长度不超过 $k$ 的子串替换为通配符后能够与该文本串的子串匹配。

题解：对于某一模式串 $T$，假设其在 $[i,i+|T|-1]$ 处发生一次匹配，根据定义，这等价于 $T$ 与 $S[i,i+|T|-1]$ 的第一个不匹配位置和最后一个不匹配位置的距离 $<k$，或二者完全相等。先考虑存在不匹配位置的情况，设其距离为 $dis$。假如现在我们将 $T$ 的一个长为 $k$ 的子串替换为通配符（在这里，为了后续方便，定义子串为与 $[1,|T|]$ 有交的全部长度为 $k$ 的区间，即下标有可能超出原串范围，此时只将公共部分替换为通配符），那么应该恰好有 $\max\{k-dis,0\}$ 种替换方式使得替换后成功匹配。我们希望对于这些替换方式只计算一次贡献，因此尝试容斥。不难发现，$[dis<k]=\max\{k-dis,0\}-\max\{k-1-dis,0\}$。对于 $T$ 与 $S[i,i+|T|-1]$ 完全相等的情况，我们发现替换 $k$ 有 $len+k-1$ 种，替换 $k-1$ 有 $len+k-2$ 种，依然符合容斥，故只需要对 $k$ 和 $k-1$ 跑两遍再相减即可求得答案。现在，问题转化成对每一种将 $T$ 的一个长为 $k$ 的子串替换为通配符的方式，求能发生多少次匹配。

构建所有模式串的 ACAM，以及所有模式串的反串的 ACAM。首先考虑替换后剩余部分是一个前缀或是后缀的情况，此时只需要统计原串的一个前缀或后缀中该剩余部分的出现次数，这容易通过两次扫描线求出。更特殊地，如果剩余部分为空串，直接产生 $n-|T|+1$ 的贡献即可。对于一般情况，考虑一种替换方案 $[i+1,i+k]$，设 $T[1,i]$ 对应于前缀 trie 上结点 $a$，$rev(T[i+k+1,|T|])$ 对应于后缀 trie 上结点 $b$，$S[1,p]$ 对应于前缀 trie 上结点 $x$，$rev(S[p+k+1,|S|])$ 对应于后缀 trie 上结点 $y$，那么所有满足 $x$ 在 $a$ 子树内，$y$ 在 $b$ 子树内的 $p$ 都将对于该替换方式产生 $1$ 的贡献。以前缀 trie 上 dfn 和后缀 trie 上 dfn 构成的二元组构建平面直角坐标系，问题转化为单点加矩形查问题，直接求解即可。

时间复杂度 $O\big((\sum|T|+|S|)\log(\sum|T|)\big)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans[200005];
int n,N;
char s[200005];
vector<char>t[200005];
vector<int>pos1[200005],pos2[200005];
vector<int>edge1[200005],edge2[200005];
int tr1[200005][135],tr2[200005][135];
int fail1[200005],fail2[200005];
int id1=0,id2=0;
int spos1[200005],spos2[200005];
void insert(int x){
	int now=0;
	for(int i=0;i<t[x].size();i++){
		if(!tr1[now][t[x][i]]) tr1[now][t[x][i]]=++id1;
		now=tr1[now][t[x][i]];
		pos1[x][i]=now;
	}
	now=0;
	for(int i=t[x].size()-1;i>=0;i--){
		if(!tr2[now][t[x][i]]) tr2[now][t[x][i]]=++id2;
		now=tr2[now][t[x][i]];
		pos2[x][i]=now;
	}
}
void get_fail(){
	queue<int>q;
	q.push(0);
	while(!q.empty()){
		int id=q.front();
		q.pop();
		for(int i=30;i<130;i++){
			if(tr1[id][i]){
				int now=fail1[id];
				while(now&&!tr1[now][i]) now=fail1[now];
				if(id!=now&&tr1[now][i]) now=tr1[now][i];
				fail1[tr1[id][i]]=now;
				edge1[now].push_back(tr1[id][i]);
				q.push(tr1[id][i]);
			}
		}
	}
	q.push(0);
	while(!q.empty()){
		int id=q.front();
		q.pop();
		for(int i=30;i<130;i++){
			if(tr2[id][i]){
				int now=fail2[id];
				while(now&&!tr2[now][i]) now=fail2[now];
				if(id!=now&&tr2[now][i]) now=tr2[now][i];
				fail2[tr2[id][i]]=now;
				edge2[now].push_back(tr2[id][i]);
				q.push(tr2[id][i]);
			}
		}
	}
}
int dfn1[200005],dfn2[200005],sz1[200005],sz2[200005],idcnt1=0,idcnt2=0;
void dfs1(int x){
	dfn1[x]=++idcnt1;
	sz1[x]=1;
	for(int i=0;i<edge1[x].size();i++) dfs1(edge1[x][i]),sz1[x]+=sz1[edge1[x][i]];
}
void dfs2(int x){
	dfn2[x]=++idcnt2;
	sz2[x]=1;
	for(int i=0;i<edge2[x].size();i++) dfs2(edge2[x][i]),sz2[x]+=sz2[edge2[x][i]];
}
struct node{
	int l,r,v,id;
};
vector<int>todo[200005];
vector<node>toask[200005];
void addtodo(int l,int r){
	todo[l].push_back(r);
}
void addtoask(int l1,int r1,int l2,int r2,int id){
	toask[l1-1].push_back((node){l2,r2,-1,id});
	toask[r1].push_back((node){l2,r2,1,id});
}
int T[200005];
int lowbit(int x){return x&(-x);}
void add(int x,int k){
	while(x<=200000){
		T[x]+=k;
		x+=lowbit(x);
	}
}
int query(int x){
	int ret=0;
	while(x){
		ret+=T[x];
		x-=lowbit(x);
	}
	return ret;
}
struct td{
	int id,pos;
};
vector<td>todo_suf[200005];
vector<td>todo_pre[200005];
void solve(int k,int o){
	for(int i=1;i<=200000;i++) todo[i].clear(),toask[i].clear(),todo_pre[i].clear(),todo_suf[i].clear();
	for(int i=1;i<=n;i++){
		int tsz=t[i].size();
		for(int j=1-k;j<tsz;j++){
			int pre=j-1,suf=j+k;
			if(pre<0&&suf>=tsz) ans[i]+=o*(max(0,N-tsz+1));
			else if(pre<0) todo_suf[suf+1].push_back((td){i,pos2[i][suf]});
			else if(suf>=tsz) todo_pre[N-(tsz-1-pre)].push_back((td){i,pos1[i][pre]});
			else addtoask(dfn1[pos1[i][pre]],dfn1[pos1[i][pre]]+sz1[pos1[i][pre]]-1,dfn2[pos2[i][suf]],dfn2[pos2[i][suf]]+sz2[pos2[i][suf]]-1,i);
		}
	}
	for(int i=1;i<=N-k-1;i++) addtodo(dfn1[spos1[i]],dfn2[spos2[i+k+1]]);
	for(int i=1;i<=200000;i++) T[i]=0;
	for(int i=1;i<=N;i++){
		add(dfn1[spos1[i]],1);
		for(int j=0;j<todo_pre[i].size();j++){
			td tmp=todo_pre[i][j];
			ans[tmp.id]+=o*(query(dfn1[tmp.pos]+sz1[tmp.pos]-1)-query(dfn1[tmp.pos]-1));
		}
	}
	for(int i=1;i<=200000;i++) T[i]=0;
	for(int i=N;i>=1;i--){
		add(dfn2[spos2[i]],1);
		for(int j=0;j<todo_suf[i].size();j++){
			td tmp=todo_suf[i][j];
			ans[tmp.id]+=o*(query(dfn2[tmp.pos]+sz2[tmp.pos]-1)-query(dfn2[tmp.pos]-1));
		}
	}
	for(int i=1;i<=200000;i++) T[i]=0;
	for(int i=1;i<=idcnt1;i++){
		for(int j=0;j<todo[i].size();j++) add(todo[i][j],1);
		for(int j=0;j<toask[i].size();j++){
			node tmp=toask[i][j];
			ans[tmp.id]+=o*tmp.v*(query(tmp.r)-query(tmp.l-1));
		}
	}
}
char tmp[200005];
signed main(){
	int k;
	cin>>k;
	scanf("%s",s+1);
	N=strlen(s+1);
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%s",tmp+1);
		int len=strlen(tmp+1);
		for(int j=1;j<=len;j++) t[i].push_back(tmp[j]);
		for(int j=0;j<=len;j++){
			pos1[i].push_back(0);
			pos2[i].push_back(0);
		}
		insert(i);
	}
	get_fail();
	int now=0;
	for(int i=1;i<=N;i++){
		while(now&&!tr1[now][s[i]]) now=fail1[now];
		now=tr1[now][s[i]];
		spos1[i]=now;
	}
	now=0;
	for(int i=N;i>=1;i--){
		while(now&&!tr2[now][s[i]]) now=fail2[now];
		now=tr2[now][s[i]];
		spos2[i]=now;
	}
	dfs1(0);
	dfs2(0);
	solve(k,1);
	solve(k-1,-1);
	for(int i=1;i<=n;i++) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：Pekemetier (赞：1)

显然一个合法匹配有 $lcp+lcs+k>|p_i|$ 。

对于所有 $p_i$ 及其反串建出 AC 自动机。由 AC 自动机的匹配方式可得：对于 $S$ 的一段长为 $|p_i|$ 的子串 $S_{x,x+|p_i|-1}$ ，它能产生贡献当且仅当中间存在长度不超过 $k$ 的子串 $S_{j\cdots l}$ 使得 $j$ 在正串 AC 自动机中能跳 fail 到达 $p_{j-x}$ 的位置，且在反串的 AC 自动机中也能跳 fail 到达 $p_{l-x}$ 的位置。

考虑强制让中间区间大小为 $k$ ，并计算能够通过它实现合法的区间数量。但这样的话，对于一个子串 $S_{x,x+|p_i|-1}$ ，如果中间不相等的位置的极差小于 $k-1$ ，那么就会被计算多次。不过可以通过减去 $k'\leftarrow k-1$ 时的答案消去多余的部分。（当然这里要注意在边界上的区间的处理，一种解决方法是计算 $k$ 时，计算所有不超出边界的区间；计算 $k'$ 时，只计算所有不紧靠着边界的区间）

但是发现这样计算的话必须枚举每个长为 $k$ 的区间左右两端点跳 fail 能到的位置，然后再对每个 $p_i$ 计算有多少个左端点跳 fail 到的点和右端点跳 fail 到的点组成的点对满足他们之间相距 $|p_i|$。

试着改为枚举跳 fail 跳到的点对，即对于每个 $p_i$ ，枚举二元组 $(x,y),x+k+1=y,0\leq x<y\leq|p_i|+1$ 。显然这只有 $O(\sum|p_i|)$ 个。然后发现区间会对点对产生贡献要求左端点在 $x$ 反向 fail 边构成的子树内，右端点在 $y$ 反向 fail 边构成的子树内。

于是将 fail 树用 dfn 序压在一维上，一个子树就变成了一段连续的区间。将 $(dfn\_pre_i,dfn\_suf_{i+k})$ 视作平面上一个点，那么同时在 $(x,y)$ 的子树内就变成了在一个矩形内，产生的贡献即为矩形内点的数量，可通过二位数点解决。

记得特判 $|p_i|\leq k$ 的情况。

Code:
```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
using namespace std;
int k,n,l,len[200001];
long long ans[200001];
int son1[200002][94],num1=1,fail1[200002];
int head1[200002],nxt1[200002];
int dfn1[200002],lst1[200002],tot1;
int son2[200002][94],num2=1,fail2[200002];
int head2[200002],nxt2[200002];
int dfn2[200002],lst2[200002],tot2;
char s[200002],p[200002];
vector<int>px[200001],py[200001];
struct edge{
	int i,d;
}n1[200001],n2[200001];
bool cmpb(edge x,edge y){return x.d<y.d;}
void build(int id,int li)
{
	for(int i=0,x=1;i<li;++i)
	{
		p[i]-=33;
		if(!son1[x][p[i]])
		{
			son1[x][p[i]]=++num1;
			n1[num1]=(edge){num1,n1[x].d+1};
			fail1[num1]=x;
			dfn1[num1]=p[i];
		}
		px[id][i]=x=son1[x][p[i]];
	}
	for(int i=li-1,x=1;~i;--i)
	{
		if(!son2[x][p[i]])
		{
			son2[x][p[i]]=++num2;
			n2[num2]=(edge){num2,n2[x].d+1};
			fail2[num2]=x;
			dfn2[num2]=p[i];
		}
		py[id][i]=x=son2[x][p[i]];
	}
}
void builddfn1(int x)
{
	dfn1[x]=++tot1;
	for(int i=head1[x];i;i=nxt1[i])
		builddfn1(i);
	lst1[x]=tot1;
}
void builddfn2(int x)
{
	dfn2[x]=++tot2;
	for(int i=head2[x];i;i=nxt2[i])
		builddfn2(i);
	lst2[x]=tot2;
}
void buildfail()//
{
	sort(n1+2,n1+num1+1,cmpb);
	for(int i=2;i<=num1;++i)
	{
		int f1=fail1[fail1[n1[i].i]];
		while(f1>1&&!son1[f1][dfn1[n1[i].i]])f1=fail1[f1];
		if(f1&&son1[f1][dfn1[n1[i].i]])fail1[n1[i].i]=son1[f1][dfn1[n1[i].i]];//
		else fail1[n1[i].i]=1;
		nxt1[n1[i].i]=head1[fail1[n1[i].i]];
		head1[fail1[n1[i].i]]=n1[i].i;
	}
	builddfn1(1);
	sort(n2+2,n2+num2+1,cmpb);
	for(int i=2;i<=num2;++i)
	{
		int f2=fail2[fail2[n2[i].i]];
		while(f2>1&&!son2[f2][dfn2[n2[i].i]])f2=fail2[f2];
		if(f2&&son2[f2][dfn2[n2[i].i]])fail2[n2[i].i]=son2[f2][dfn2[n2[i].i]];//
		else fail2[n2[i].i]=1;
		nxt2[n2[i].i]=head2[fail2[n2[i].i]];
		head2[fail2[n2[i].i]]=n2[i].i;
	}
	builddfn2(1);
}
struct node{
	int t,x,y,i;
}c[2000001];
bool cmp(node x,node y){return x.t!=y.t?x.t<y.t:(x.i!=0)<(y.i!=0);}
int v1[200001],t[200002],cnt;
void add1(int x,int y)
{
	c[++cnt]=(node){x,y,-1,0};
}
void find1(int x,int l,int r,int i)
{
	c[++cnt]=(node){x,l,r,i};
}
void add2(int x)
{
	while(x<=num2)++t[x],x+=x&-x;
}
int find2(int x)
{
	int ans=0;
	while(x)ans+=t[x],x-=x&-x;
	return ans;
}
void flu()
{
	sort(c+1,c+cnt+1,cmp);
	for(int i=1;i<=cnt;++i)
		if(c[i].i)
		{
			if(c[i].i>0)ans[c[i].i]+=find2(c[i].y)-find2(c[i].x-1);
			else ans[-c[i].i]-=find2(c[i].y)-find2(c[i].x-1);
		}
		else add2(c[i].x);
}
void work0()
{
	v1[0]=1;
	for(int i=1,pl=1;i<=l;++i)
	{
		while(pl>1&&!son1[pl][s[i]-33])pl=fail1[pl];
		if(son1[pl][s[i]-33])pl=son1[pl][s[i]-33];
		v1[i]=pl;
	}
}
void work(int kkk)//
{
	cnt=0;
	memset(t,0,sizeof t);
	for(int i=l,pl=1;i-k-1>=0;--i)
	{
		while(pl>1&&!son2[pl][s[i]-33])pl=fail2[pl];
		if(son2[pl][s[i]-33])pl=son2[pl][s[i]-33];
		add1(dfn1[v1[i-k-1]],dfn2[pl]);
	}
	add1(dfn1[v1[l-k]],1);
	for(int i=1;i<=n;++i)
	if(len[i]>0){
		if(kkk)
		{
			find1(num1,dfn2[py[i][k]],lst2[py[i][k]],i);
			find1(lst1[px[i][len[i]-k-1]],1,num2,i);
			find1(dfn1[px[i][len[i]-k-1]]-1,1,num2,-i);
		}
		for(int j=0;j+k+1<len[i];++j)
		{
			find1(lst1[px[i][j]],dfn2[py[i][j+k+1]],lst2[py[i][j+k+1]],i);
			find1(dfn1[px[i][j]]-1,dfn2[py[i][j+k+1]],lst2[py[i][j+k+1]],-i);
		}
	}
	flu();
}
int main()
{
	#ifndef ONLINE_JUDGE
	freopen("C:\\Users\\user\\Downloads\\B4.in","r",stdin);
	#endif
	scanf("%d%s%d",&k,s+1,&n);
	l=strlen(s+1);
	for(int i=1;i<=n;++i)
	{
		scanf("%s",p);
		len[i]=strlen(p);
		if(len[i]>k)
		{
			px[i].reserve(len[i]+1);
			py[i].reserve(len[i]+1);
			build(i,len[i]);
		}else len[i]=-len[i];
	}
	buildfail();
	work0();
	--k;
	work(0);
	for(int i=1;i<=n;++i)
		ans[i]=-ans[i];
	++k;
	work(1);
	for(int i=1;i<=n;++i)
		if(len[i]>0)printf("%lld\n",ans[i]);
		else printf("%d\n",l+len[i]+1);
}
```


---

## 作者：Otomachi_Una_ (赞：0)

$S,T$ 匹配当且仅当可以从 $S$ 中取一个长度为 $k$ 地连续段 $[l,r]$（$r-l+1=k$）变成通配符，$S,T$ 匹配。

首先做可行性计数是困难的。但是你发现如果 $S$ 合法，那么可行的 $l$ 是一个区间。这告诉我们可以之间点减边容斥，即我们只要减掉 $k-1$ 的答案即可。我们就可以对每个 $[l,r]$ 独立计数了。

对一个询问 $p_i$，我们转成了 $O(|p_i|)$ 个询问，每个询问表示把 $p_i$ 一个长度为 $k$ 的区间变成了通配符，能和 $s$ 的多少个连续段匹配上。即我们钦定了 $s$ 中长度为 $|p_i|$ 的连续段的开头和结尾。

对所有 $p_i$ 建 AC 自动机，对所有 $p_i$ 反串建 AC 自动机。把 $s$、$s$ 的反串拉到这两个自动机上面跑，假设长度为 $i$ 的 $s$ 与其反串在这两个自动机上面跑到的节点分别是 $p_i,q_i$。

假设一个询问，前缀，后缀在两个自动机上对应的点是 $u,v$。那么我们就要找 $j$ 的个数使得两个自动机上 $p_j,q_{|t_i|-k-j}$ 分别是 $u,v$ 的儿子。

容易变成二维数点，树状数组维护一下即可。

---

## 作者：sqrtqwq (赞：0)

[problem](https://www.luogu.com.cn/problem/P3735)

-----------

我们先考虑如何判断两个字符串 $a,b$ 相似。很明显，条件为 $|a| = |b|$ 且 $\text{LCP}(a,b) + \text{LCS}(a,b) + k \ge |a|$。其实就相当于把 $b$ 中一个长度为 $k$ 的子串换成通配符后和 $a$ 相等。

此时我们可以考虑容斥，对于每一个 $p_i$，我们枚举长度为 $k$ 和 $k - 1$ 的区间换乘通配符，然后求出换完后的字符在 $s$ 中的出现次数。然后通过一些计算就可以得出答案了。

具体的，我们对字符串的正串和反串建出一个 AC 自动机，并且记录文本串每一个每一个位置在 AC 自动机上的节点。

由于换成通配符之后，只剩下一个 $\text{pre}$ 和一个 $\text{suf}$，一个 $j$ 对于答案有贡献的要求就是 $s$ 中以 $j$ 为开头长度为 $|\text{pre}|$ 的子串等于 $\text{pre}$，$s$ 中以 $j + |\text{pre}| + k$ 为开头，长度为 $|\text{suf}|$ 的子串等于 $\text{suf}$。我们的任务就是求出这样的 $j$ 的个数。

那么这个条件转移到树上就变成了 $s$ 以 $pos$ 为结尾的后缀在 AC 自动机上的节点在 fail 树上在 $p_i$ 的前缀 $j$ 在 AC 自动机上的节点子树之中。这是前缀的情况，后缀的情况同理。

那么我们只需要把 在某个点的子树内 这个限制转化为 DFS 序在某个区间内 这个限制，这样我们就可以使用二维数点来解决了。

---

## 作者：卖淫翁 (赞：0)

```
#include <bits/stdc++.h>
#define fi first
#define se second
#define pii pair<int,int>
#define pdi pair<db,int>
#define mp make_pair
#define pb push_back
#define enter putchar('\n')
#define space putchar(' ')
#define eps 1e-8
#define MAXN 200005
#define mo 974711
//#define ivorysi
using namespace std;
typedef long long int64;
typedef double db;
template<class T>
void read(T &res) {
    res = 0;char c = getchar();T f = 1;
    while(c < '0' || c > '9') {
    if(c == '-') f = -1;
    c = getchar();
    }
    while(c >= '0' && c <= '9') {
    res = res * 10 + c - '0';
    c = getchar();
    }
    res *= f;
}
template<class T>
void out(T x) {
    if(x < 0) {x = -x;putchar('-');}
    if(x >= 10) {
    out(x / 10);
    }
    putchar('0' + x % 10);
}

int L[MAXN],R[MAXN],K,N,dfn[MAXN * 2],idx,siz[MAXN * 2],H,ans[MAXN],pos[2][MAXN];
char s[MAXN],t[MAXN];
vector<int> son[MAXN * 2];
vector<int> ver[MAXN * 2];
vector<pii > Qry[MAXN * 2];
int sum[2][MAXN * 2];
namespace ACAM {
    int tr[MAXN * 2][94],fail[MAXN * 2],Ncnt,rt,que[MAXN * 2],ql,qr;
    void Init() {
    Ncnt = 1,rt = 1;
    }
    int ins(int p,int c) {
    if(!tr[p][c]) tr[p][c] = ++Ncnt;
    return tr[p][c];
    }
    void build_ACAM() {
    ql = 1,qr = 0;
    que[++qr] = 1;fail[1] = 1;
    while(ql <= qr) {
        int u = que[ql++];
        for(int i = 0 ; i <= 93 ; ++i) {
        if(tr[u][i]) {
            int v = tr[u][i];
            int t = fail[u];
            if(u == 1) fail[v] = 1;
            else {
            while(1) {
                if(tr[t][i]) {fail[v] = tr[t][i];break;}
                if(t == 1) {fail[v] = 1;break;}
                t = fail[t];
            }
            }
            que[++qr] = v;
            son[fail[v]].pb(v);
        }
        }
    }
    }
}
using ACAM::ins;
void dfs(int u) {
    dfn[u] = ++idx;siz[u] = 1;
    int s = son[u].size();
    for(int i = 0 ; i < s ; ++i) {
    dfs(son[u][i]);
    siz[u] += siz[son[u][i]];
    }
}
int lowbit(int x) {return x & (-x);}
void insert(int on,int x) {
    while(x <= ACAM::Ncnt) {
    sum[on][x]++;
    x += lowbit(x);
    }
}
int Query(int on,int x) {
    int res = 0;
    while(x > 0) {
    res += sum[on][x];
    x -= lowbit(x);
    }
    return res;
}
int Query_Range(int on,int x) {
    return Query(on,dfn[x] + siz[x] - 1) - Query(on,dfn[x] - 1);
}
void Process(int u) {
    int s = Qry[u].size();
    for(int i = 0 ; i < s ; ++i) {
    if(Qry[u][i].se > 0) ans[Qry[u][i].fi] -= Query_Range(0,Qry[u][i].se); 
    if(Qry[u][i].se < 0) ans[Qry[u][i].fi] += Query_Range(1,-Qry[u][i].se);
    }
    s = ver[u].size();
    for(int i = 0 ; i < s ; ++i) {
    if(ver[u][i] > 0) insert(0,dfn[ver[u][i]]);
    if(ver[u][i] < 0) insert(1,dfn[-ver[u][i]]);
    }
    s = son[u].size();
    for(int i = 0 ; i < s ; ++i) {
    Process(son[u][i]);
    }
    s = Qry[u].size();
    for(int i = 0 ; i < s ; ++i) {
    if(Qry[u][i].se > 0) ans[Qry[u][i].fi] += Query_Range(0,Qry[u][i].se);
    if(Qry[u][i].se < 0) ans[Qry[u][i].fi] -= Query_Range(1,-Qry[u][i].se);
    }
}
void Solve() {
    read(K);
    scanf("%s",s + 1);
    H = strlen(s + 1);
    read(N);
    ACAM::Init();
    for(int i = 1 ; i <= N ; ++i) {
    scanf("%s",t + 1);
    int len = strlen(t + 1);
    int p = 1;
    if(len > K) {
        for(int j = 1 ; j <= len ; ++j) {
        p = ins(p,t[j] - 33);
        L[j] = p;
        }
        p = 1;
        for(int j = len ; j >= 1 ; --j) {
        p = ins(p,t[j] - 33);
        R[j] = p;
        }
        for(int j = 0 ; j <= len - K; ++j) {
        int a = j == 0 ? 1 : L[j];
        int b = j + K + 1 == len + 1 ? 1 : R[j + K + 1];
        Qry[a].pb(mp(i,b));
        }
        for(int j = 1 ; j <= len - K; ++j) {
        int a = L[j],b = R[j + K];
        Qry[a].pb(mp(i,-b));
        }
    }
    else ans[i] = H - len + 1;
    }
    ACAM::build_ACAM();
    int p = 1;
    pos[0][0] = 1;
    for(int i = 1 ; i <= H ; ++i) {
    while(1) {
        if(ACAM::tr[p][s[i] - 33]) {p = ACAM::tr[p][s[i] - 33];break;}
        else if(p == 1) break;
        p = ACAM::fail[p];
    }
    pos[0][i] = p;
    }
    p = 1;
    pos[1][H + 1] = 1;
    for(int i = H ; i >= 1 ; --i) {
    while(1) {
        if(ACAM::tr[p][s[i] - 33]) {p = ACAM::tr[p][s[i] - 33];break;}
        else if(p == 1) break;
        p = ACAM::fail[p];
    }
    pos[1][i] = p;
    }
    dfs(1);
    for(int i = 0 ; i <= H - K; ++i) {
    ver[pos[0][i]].pb(pos[1][i + K + 1]);
    }
    for(int i = 1 ; i <= H - K; ++i) {
    ver[pos[0][i]].pb(-pos[1][i + K]);
    }
    Process(1);
    for(int i = 1 ; i <= N ; ++i) {
    out(ans[i]);enter;
    }
}    
int main() {
#ifdef ivorysi
    freopen("f1.in","r",stdin);
#endif
    Solve();
}
```
```
好神仙的题啊

感觉转二维平面能想到，算重复情况的方法真想不到啊

通过扒stdcall代码获得的题解QAQQQQ

我们先把pipi正串反串建出一个AC自动机来

然后我们把s串放在上面跑匹配，正着跑一遍，反着跑一遍，我们就得到了ss中每个位置正着和反着能匹配到的节点编号

然后对于AC自动机，我们建出fail树来，并处理出每个点在fail树上dfs序

对于AC自动机上的一个点，我们把pipi正串的询问挂在上面，假如这个点的匹配深度为x，那么我们就需要对于这个点fail树里所有匹配到的ss中正着匹配到的位置，问这个位置a，a+k+1a+k+1是不是在pipi反串x+k+1x+k+1(也是原下标）所在AC自动机节点fail树的子树里

举个例子
k = 3
假如pipi是
abacdefg
然后s中的一段是
abahdefg
我们找到pipi在AC自动机中aba所在的节点，挂上pipi这个询问，找出所有这个节点fail树里匹配到的s正串的位置aa
查询的是pipi反串gfe所在节点fail树子树里，问a+k+1a+k+1有多少个

这个可以通过树状数组维护，问一个点子树里的只要用遍历子树后的值减掉遍历子树前的值就好

然而……你发现这样统计会有重复了吗

还是刚刚那个例子
我们发现，当我们在a所在的节点时，我们还会计算一遍这一段

为了去重，我们使得左边匹配要到达最长，也就是，如果这个位置a+ka+k也合法的话，那么我们要减掉它
就是在aba这个点，同时挂上gfed节点，然后减掉这些方案

维护方法还是树状数组，和上面类似
```


---


# [NOI2017] 分身术

## 题目描述

> “分！身！术！” —— 小 P

平面上有 $n$ 个小 P 的分身。定义一组分身占领的区域为覆盖这组分身的最小凸多边形。小 P 能力有限，每一时刻都会有若干分身消失。但在下一时刻之前，小 P 会使用分身术使得这些消失的分身重新出现在原来的位置。

小 P 想知道，每一时刻分身消失后，剩下的分身占领的区域面积是多少？


## 说明/提示

### 样例解释

如下图所示：左图表示输入的 $6$ 个分身的位置及它们占领的区域；中图表示第一个时刻的情形，消失的分身编号分别为 $1,3,6$，剩余 $3$ 个点占领图中实线内部区域，占据面积的两倍为 $3$；右图表示第二个时刻的情形，消失的分身编号分别为

$[(0 + 3)\bmod 6] + 1 = 4$

$[(1 + 3)\bmod 6] + 1 = 5$

剩余的 $4$ 个点占领图中实线内部区域。

![](https://cdn.luogu.com.cn/upload/image_hosting/bieyspo4.png) 

对于所有数据，保证：

-  $|x_i|,|y_i|\le 10^8$ ；
- 没有两个分身的坐标是完全相同的；
-  $k\le 100$ ；
- 所有时刻的  $k$ 之和不超过  $2\times 10^6$ ；
-  $0\le c_i\le 2^{31}-1$ ；
- 初始时，所有的  $n$ 个分身占据区域面积大于  $0$ ；
- 定义所有  $n$ 个分身所占据区域的**顶点集合**为  $S$ ，  $|S|\ge 3$ 。在任意时刻，  $S$ 中至少存在两个未消失的分身。

| 测试点编号 | $n \leq$ | $m \leq$ |    $k$     |
| :--------: | :------: | :------: | :--------: |
|    $1$     |   $10$   |   $10$   | $\leq n-3$ |
|    $2$     |  $10^3$  |  $10^3$  | $\leq n-3$ |
|    $3$     |  $10^3$  |  $10^3$  | $\leq n-3$ |
|    $4$     |  $10^3$  |  $10^3$  | $\leq n-3$ |
|    $5$     |  $10^5$  |  $10^5$  |    $=1$    |
|    $6$     |  $10^5$  |  $10^5$  |    $=1$    |
|    $7$     |  $10^5$  |  $10^5$  |    $=1$    |
|    $8$     |  $10^5$  |  $10^5$  |    $=1$    |
|    $9$     |  $10^5$  |  $10^5$  |    $=2$    |
|    $10$    |  $10^5$  |  $10^5$  |    $=2$    |
|    $11$    |  $10^5$  |  $10^5$  |  $\leq 3$  |
|    $12$    |  $10^5$  |  $10^5$  |  $\leq 5$  |
|    $13$    |  $10^5$  |  $10^5$  |  $\leq 9$  |
|    $14$    |  $10^5$  |  $10^5$  | $\leq 12$  |
|    $15$    |  $10^5$  |  $10^5$  | $\leq 20$  |
|    $16$    |  $10^5$  |  $10^5$  | $\leq 100$ |
|    $17$    |  $10^5$  |  $10^5$  | $\leq 100$ |
|    $18$    |  $10^5$  |  $10^5$  | $\leq 100$ |
|    $19$    |  $10^5$  |  $10^5$  | $\leq 100$ |
|    $20$    |  $10^5$  |  $10^5$  | $\leq 100$ |

## 样例 #1

### 输入

```
6 2
-1 0
-1 -1
0 -1
1 0
0 1
0 0
3 1 3 6
2 0 1
```

### 输出

```
3
2
```

# 题解

## 作者：Artless (赞：11)

声明：

1.这是一篇云题解。这个方法看起来是可做的，但它是如此地麻烦以至于我不想实践。

2.写这篇题解的原因是这道题一直没人写题解。

------------

首先分析题目。

我们有一个n个点的点集，接下来有m次查询。

每次查询要求出其中n-k个点组成的点集的凸包面积。

每次不被取的k个点由上一次的运算结果取模得到，要求解法在线。

------------

观察数据，前20分用裸的凸包就能直接做。

后面的数据n很大而k很小。

不难想到一个性质：

如果我们称点集的凸包为第一层凸包，点集减去第一层凸包后剩下来的部分的凸包为第二层凸包，点集减去前i层凸包后剩下来部分的凸包为第i+1层凸包的话。

那么，点集减去k个点之后剩下来的部分的凸包上的点应当由前k+1层凸包上的点组成。

（证明应当是容易的，但我们也可以简单地脑补一下：移除一个点最多也只会让我们进入更深一层的凸包）

------------


以下是解法：

首先，预处理出前k+1层凸包。直接做k次凸包是nklogn的。

我们似乎有办法做得效率更高（在下一层当中利用上一层的运算结果）但是没必要。

在预处理之后随便选择一个位于k+1层凸包内部的点O作为我们的原点。

然后，对于每次询问：

我们先按照这k个点的所在凸包层排个序，同一层凸包上的点则按照它到O点的连线和x轴的夹角排序。

这一步是nklogk。

于是，我们丢掉了一些不在前k个凸包层上的点，并且，我们可以方便地找到在同一个凸包层上连续排列的点。

接着，我们按照凸包层从外到里的顺序依次处理每一层的删点。

对于当前正在处理的凸包层上每一段要删的点，我们需要查找下一个凸包层上会因此暴露出的点，并求出面积的变化量。

查找可以通过二分来做，至于面积的变化量，见下图。

![](https://i.imgur.com/VAr4fJf.png)

我们损失了O-A5-A1-A2-A3这一块，并得到了O-A5-B1-B2-A3这一块。

只要预处理凸包上每条边和O组成的三角形的面积，并预处理前缀和，面积变化量可以O(1)得到。

在第一层处理完后，对于下一层继续做类似的处理。

但是，从第二层开始，有一个额外需要处理的地方：

还是以我们这张图为例。如果我们要删的点是A1，A2，B1和B4，在删去第一层的点后，暴露出B1和B2，但在删去B1之后，同一层的B4被暴露并被删去了。

（好吧，在图上A5，B4和B2看起来就在一条线上，但我们就当B4在稍微外面一点的位置，我懒得重画了）

我们的处理方式还是查找到最终暴露的位置并求出面积差。

之后对下一层做类似的处理。

暴露点这事情最多发生k次，每次我们要做logn的二分查找。

这里的复杂度是mklogn。


------------


以上内容合起来差不多是(n+m)klogn，三亿，3秒时限，看着勉强能过。

如果超时，说明预处理部分“我们似乎有办法做得效率更高但是没必要”是错的。

---

## 作者：5ab_juruo (赞：3)

当 $k=1$ 时，新的凸包必然来源于原来的凸包，或者剥掉原来凸包后新的点集的凸包。

递归地做这个事情，如果最上面一层没有点没删，则停止递归，否则处理出下面一层的凸包后，处理出删掉这层的点后会露出的部分，将这一部分从下面分开来，连到上面即可。由于每层都至少要删一个点，所以只要预处理 $k+1$ 层的凸包即可。

把凸包分成上下凸壳，并钦定一边可以平行于 $y$ 轴，面积即为上下凸壳的面积和。用线段树维护每一层的凸壳，pushup 的时候加上中间的面积。

找露出的部分，即找点到凸包的切线，可以二分。取中间的线段，判断方向后往对应方向递归即可。左右切到一个点的时候要特判凸性。

剪切，拼接的部分可以直接用线段树分裂和合并，由于对应的 $x$ 坐标是不交的，所以每次操作复杂度都是严格 $O(\log n)$。为了处理多次询问，可以用可持久化的思路，不对原来的凸壳做实质性修改，询问完毕后将多产生的点直接删除即可。

复杂度 $O(nk+(n+\sum k)\log n)$。

如果在 uoj 上 97 分，检查有没有判：

- 输入 $c_i$ 加上 $S$ 爆 int；
- 输入 $c_i$ 为 $0$；
- 输入 $c_i$ 解密后有重复。

代码：<https://uoj.ac/submission/653541>

---

## 作者：Misaka14285 (赞：3)

do，御坂前来贡献另一种做法。

为方便，把凸包拆成上下凸壳分别维护。

预先求出最外面 $\max k+1$ 层凸壳~~剥洋葱~~。一次查询相当于给定一层凸壳与 $O(k)$ 个外层凸壳的连续片段，问构成它们的点集的并的凸壳面积。

考虑向点集中从内到外依次加入每层的凸壳片段，并实时维护这个凸壳。注意到外层的一定包着内层的，故待插入片段与当前凸壳的外公切线一定过此片段的左右两端点。只需将当前凸壳上两切点之间的部分换成该片段。这和动态凸壳的插入单点实现起来几乎是一样的。

使用的数据结构要求支持区间提取、回退。平衡树和动态开点线段树理论上均可。

时间复杂度 $O(nk+(n+\sum k)\log n)$。

[巨丑代码](https://www.luogu.com.cn/paste/ef1754fj)

---


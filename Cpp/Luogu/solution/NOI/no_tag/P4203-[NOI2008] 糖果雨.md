# [NOI2008] 糖果雨

## 题目描述

有一个美丽的童话：在天空的尽头有一个"糖果国"，这里大到摩天大厦，小 到小花小草都是用糖果建造而成的。更加神奇的是，天空中飘满了五颜六色的糖 果云，很快糖果雨密密麻麻从天而落，红色的是草莓糖，黄色的是柠檬糖，绿色 的是薄荷糖，黑色的是巧克力糖……这时糖果国的小朋友们便会拿出大大小小的 口袋来接天空中落下的糖果，拿回去与朋友们一起分享。

对糖果情有独钟的小 Z 憧憬着能够来到这样一个童话的国度。所谓日有所 思，夜有所梦，这天晚上小 Z 梦见自己来到了"糖果国"。他惊喜地发现，任何时 候天空中所有的云朵颜色都不相同，不同颜色的云朵在不断地落下相应颜色的糖 果。更加有趣的是所有的云朵都在做着匀速往返运动，不妨想象天空是有边界的， 而所有的云朵恰好在两个边界之间做着往返运动。每一个单位时间云朵向左或向 右运动一个单位，当云朵的左界碰到天空的左界，它会改变方向向右运动；当云 朵完全移出了天空的右界，它会改变方向向左运动。

我们不妨把天空想象为一个平面直角坐标系，而云朵则抽象为线段(线段可 能退化为点)： 

![](https://cdn.luogu.com.cn/upload/image_hosting/hsdveny3.png)

如上图，不妨设天空的左界为 0，右界为 len。图中共有 5 片云朵，其中标 号为 1 的云朵恰好改变方向向右运动，标号为 2 的云朵恰好改变方向向左运动。

忽略云朵的纵坐标，它们在运动过程中不会相互影响。

小 Z 发现天空中会不断出现一些云朵(某个时刻从某个初始位置开始朝某个 方向运动)，而有的云朵运动到一定时刻就会从天空中消失，而在运动的过程中 糖果在不断地下落。小 Z 决定拿很多口袋来接糖果，口袋容量是无限的，但袋 口大小却是有限的。例如在时刻 T 小 Z 拿一个横坐标范围为[L, R]的口袋来接糖 果，如果[L, R]存在一个位置 x，该位置有某种颜色的糖果落下，则认为该口袋可 接到此种颜色的糖果。极端情况下，袋口区间可能是一个点，譬如[0,0]、[1,1]，但仍然可以接到相应位置的糖果。通常可以接到的糖果总数会很大，因而小 Z 想知道每一次(即拿出口袋的一瞬间)他的口袋可以接到多少种不同颜色的糖果。

糖果下落的时间忽略不计。

## 说明/提示

【样例说明】 

共 10 个事件，包括 3 个插入事件，5 个询问事件以及 2 个删除事件。

时刻 0，天空中出现一片颜色为 10 的云朵，初始位置为[1, 3]，方向向左。

时刻 1，范围为[0, 0]的口袋可以接到颜色为 10 的糖果(云朵位置为[0, 2])。

 时刻11，范围为[0,10]的口袋可以接到颜色为10的糖果(云朵位置为[10, 12])。
 时刻 11，范围为[0, 9]的口袋不能接到颜色为 10 的糖果(云朵位置为[10, 12])。
 时刻 11, 天空中出现一片颜色为 13 的云朵, 初始位置为[4, 7], 方向向右。

时刻 13，范围为[9, 9]的口袋可以接到颜色为 10(云朵的位置为[8, 10])和颜色 为 13(云朵的位置为[6, 9])两种不同的糖果。

时刻 13，范围为[10, 10]的口袋仅仅可以接到颜色为 10 的一种糖果(云朵的位 置为[8, 10])，而不可以接到颜色为 13 的糖果(云朵的位置为[6, 9]),。

时刻 100, 颜色为 13 的云朵从天空中消失。

时刻 1999999999，颜色为 10 的云朵从天空中消失。

时刻 2000000000，天空中又出现一片颜色为 10 的云朵，初始位置为[0, 1]， 方向向右。

【数据范围】

对于所有的数据，0 ≤ Ti ≤ 2000000000，1 ≤ Ci ≤ 1000000。

数据保证{Ti}为非递减序列即 T1 ≤ T2 ≤ … ≤ Tn-1 ≤ Tn。

对于所有的插入事件，令 Pi = Ri – Li，即 Pi表示每片云朵的长度。


数据编号|n|len|Pi|数据编号|n|len|Pi
-|-|-|-|-|-|-|-
1|20|10|≤len|6|150000|1000|≤3
2|200|100|≤len|7|200000|1000|≤3
3|2000|1000|≤len|8|100000|1000|≤len
4|100000|10|≤len|9|150000|1000|≤len
5|100000|100|≤2|10|200000|1000|≤len


## 样例 #1

### 输入

```
10 10 
1 0 10 1 3 -1 
2 1 0 0 
2 11 0 10 
2 11 0 9 
1 11 13 4 7 1 
2 13 9 9 
2 13 10 10 
3 100 13 
3 1999999999 10 
1 2000000000 10 0 1 1```

### 输出

```
1 
1 
0 
2 
1 
```

# 题解

## 作者：_rqy (赞：24)

这题竟然没有题解qaq。

事先声明：我的建模和网上某些题解不一样，导致我的树状数组要开 $3len\ast 3len$ 而不是 $2len\ast 2len$，不过复杂度没变。

另外，可以发现云朵的颜色只是用来标记云朵便于删除的，所以以下先不予考虑。

考虑到每个云朵的运动周期都是 $2len$（经过 $2len$ 的时间之后回到原处），我们可以把每个云彩在*位置-时间*坐标系里画成一个图形：横坐标是位置；纵坐标是时间，而纵坐标的取值范围只有 $[0,2len]$。一个点 $(x,T)$ 在这个图形里当且仅当 $T$ 时刻时 $x$ 这个位置能接到这个云朵（假定线段的出现时间比 $T$ 早）。

比如样例 1，$len=10$，一个区间在时刻 0 出现在 
$[1,3]$，向左移动。那么它对应的图形是这样的：

![qwq](https://cdn.luogu.com.cn/upload/pic/46551.png)

如果这个区间是在时刻 25 出现在 $[4,6]$ 并往右移动，那它对应的图形是一样的。

一般的，如果一个区间在 $0$ 时刻（注意，时间对 $2len$ 取模，相当于在 $2k\cdot len$ 时刻）处于 $[l,r]$ 且向左走，那么蓝折线为 $(l,0)-(0,l)-(len,len+l)-(l,2len)$，红折线的四个点分别是蓝折线四个点向右平移 $r-l$；如果这个区间在 $0$ 时刻处于 $[l,r]$ 且向右走，那蓝折线就是 $(l,r)-(len,len-l)-(0,2len-l)-(l,0)$，红折线同上。

我们把图中的蓝色折线 KIGE 称作图形的“左边界”，红色折线 MJHF 称作其“右边界”。

一个 $T$ 时刻出现的询问区间 $[l,r]$ 可以对应图中的一条水平线段 $(l,T)-(r,T)$；显然这个布袋能接到这个云彩当且仅当这个线段和上图的图形相交；这等价于说 $(l,T)$ 在右边界左边并且 $(r,T)$ 在左边界右边（可以恰好在边界上）。

这启示我们把询问拆开：询问右端点在多少图形的蓝折线右边（包括在折线上），再询问左端点在多少图形红折线的右边（不包括在折线上）；两者相减就是答案。（如果你无法理解的话，想一想云彩改成不动的怎么做就知道了）

显然两个问题是对称的，我们只考虑如何求前者（给定坐标系里一点问它在多少蓝折线右边）。

如果蓝色折线只由水平和竖直的线段组成的话我们可以把它拆成若干矩形从而使用二维树状数组解决；但是现在线段都是倾斜 $45^\circ,135^\circ$ 的。

可以想到旋转坐标系。如果我们把坐标系旋转 $45^\circ$，如下图

![qaq](https://cdn.luogu.com.cn/upload/pic/46554.png)

选取点 $O(-len,len)$ 为原点（其实哪里都无所谓的），两条绿色线是新坐标轴。不难发现这样处理之后红折线和蓝折线在新坐标系里是水平和竖直线段组成的（请倾斜 $45^\circ$ 看）。

设原坐标为 $(x,T)$，新坐标为 $X,Y$，可以发现换算规则是（如果要求长度不变的话实际上有 $\frac1{\sqrt2}$ 的系数，但是既然我们只需要知道相对位置关系，所以无所谓了）

$$\left\{\begin{aligned}X&=x-T+2len\\Y&=x+T\end{aligned}\right.$$

所以现在问题变成：在新坐标系里每次添加或删除一条像图中蓝折线那样的线，以及对一个点问它在多少折线的右侧（或者上侧，感性理解一下）。

利用二维树状数组，我们添加图中蓝折线的时候只需要在 $K,G$ 处各加一、在 $I$ 处减一；但是我们发现不会有点处在 $I$ 的右上侧（$I$ 点本身除外，可以特判一下），所以只需要在 $K,G$ 点各加一即可；红折线也完全相同。

于是这题在 $O(n\log^2len)$ 的时间内解决。

上代码（CDQ分治，并非二维树状数组，空间 $O(n+len)$）：

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>

const int L = 2050;
const int N = 200050;
const int C = 1000050;

int m, len, cl[C], cr[C], cd[C], ans[N], k;
int P[L * 2];

int readInt() {
  int ans = 0, c, f = 1;
  while (!isdigit(c = getchar()))
    if (c == '-') f = -1;
  do ans = ans * 10 + c - '0';
  while (isdigit(c = getchar()));
  return ans * f;
}

struct Event {
  int tp, x, y, id;
  Event() {}
  Event(int t, int X, int T, int id = 0)
      : tp(t), x(X - T + 2 * len), y(X + T), id(id) {
  }
  friend bool operator<(const Event &a, const Event &b) {
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
  }
} e1[N * 2], e2[N * 2];

int S[L * 3], ll;

void add(int x, int y) { for (++x; x <= ll; x += x & -x) S[x] += y; }
int get(int x) { int y = 0; for (++x; x; x &= x - 1) y += S[x]; return y; }

void Solve(Event *e, int l, int r) {
  if (l == r - 1) return;
  int mid = (l + r) / 2;
  Solve(e, l, mid);
  Solve(e, mid, r);
  for (int i = l, j = mid; i < mid || j < r; ) {
    if (i < mid && (j == r || e[i].x <= e[j].x)) {
      if (e[i].tp) add(e[i].y, e[i].tp);
      ++i;
    } else {
      if (!e[j].tp) ans[e[j].id] += get(e[j].y);
      ++j;
    }
  }
  for (int i = l; i < mid; ++i)
    if (e[i].tp) add(e[i].y, -e[i].tp);
  std::inplace_merge(e + l, e + mid, e + r);
}

inline void eventAdd(int L, int R, int D, int tp) {
  if (D == 1) {
    e1[m] = Event(tp, L, 0);
    e1[m + 1] = Event(tp, 0, 2 * len - L);
    P[len - L] -= tp;
    e2[m] = Event(-tp, R, 0);
    e2[m + 1] = Event(-tp, R - L, 2 * len - L);
  } else {
    e1[m] = Event(tp, 0, L);
    e1[m + 1] = Event(tp, L, 2 * len);
    P[len + L] -= tp;
    e2[m] = Event(-tp, R - L, L);
    e2[m + 1] = Event(-tp, R, 2 * len);
  }
  m += 2;
}

inline void eventQuery(int L, int R, int T, int i) {
  e1[m] = Event(0, R, T, i);
  e2[m++] = Event(0, L - 1, T, i);
  if (R == len) ans[i] += P[T];
}

int main() {
  int n = readInt();
  len = readInt();
  while (n--) {
    int op = readInt(), T = readInt() % (2 * len);
    if (op == 1) {
      int C = readInt(), L = readInt(), R = readInt() - L, D = readInt();
      for (L -= T * D; L < 0 || L > len; D = -D)
        L = L < 0 ? -L : 2 * len - L;
      eventAdd(L, R += L, D, 1);
      cl[C] = L;
      cr[C] = R;
      cd[C] = D;
    } else if (op == 2) {
      int L = readInt(), R = readInt();
      eventQuery(L, R, T, k++);
    } else {
      int C = readInt();
      eventAdd(cl[C], cr[C], cd[C], -1);
    }
  }
  ll = len * 3;
  Solve(e1, 0, m);
  Solve(e2, 0, m);
  for (int i = 0; i < k; ++i)
    printf("%d\n", ans[i]);
  return 0;
}
```

---

## 作者：lhm_ (赞：9)

发现任何时刻不会出现两片颜色相同的云朵，因此云朵的颜色是不用考虑的，询问即为区间内有多少个云朵。

因为云朵的运动是在天空中往返的，具有周期性，且每个云朵运动速度都相同，所以可以用二元组 $(time,lenth)$ 来表示一个云朵，$time$ 为该云朵左端点位于左边界时的时刻，即 $t-ld \bmod 2len$，$lenth$ 为该云朵的长度，即 $r-l$，发现每个云朵都能用二维平面上的点 $(x,y)$ 来表示。

接着考虑如何解决询问 $(t,l,r)$，首先对 $t$ 转化为 $t \bmod 2len$。然后通过分类讨论来找到对于该询问在二维平面上对应的位置。设云朵的坐标为 $(x,y)$，得：

当 $t \geqslant x$ 时，该云朵要到达询问的时刻还需再经过一段时间，经过这些时间后云朵的左端点要在询问的右端点左边，即 $t-x \leqslant r$，云朵的右端点要在询问的左端点右边，即 $t-x+y \geqslant l$。

当 $t < x$ 时，该云朵已经超过询问的时刻，因此其需要时光倒流，因为运动的周期性，其还是向右运动，把这些时间倒流后云朵的左端点要在询问的右端点左边，即 $x-t \leqslant r$，云朵的右端点要在询问的左端点右边，即 $x-t+y \geqslant l$。

综上所述得询问在二维平面上对应的位置为 $t-r \leqslant x \leqslant t+r,| x-t | +y \geqslant l$，在平面上画出图来得：

![](https://s1.ax1x.com/2020/08/27/dfH0CF.png)

发现图像为两个对称的五边形，若其超出了边界，就在另一端补上来，对于该图像不好进行统计，因此还需再进行转化，将其补成平行四边形得：

![](https://s1.ax1x.com/2020/08/27/dfHB34.png)

然后考虑对这两个平行四边形转化为矩形来进行统计，因为是询问存在性，而不是面积之类的信息，所以对于询问的范围进行转化，对于每个云朵的坐标也进行转化，然后进行询问就是合法的。对于右边向右倾斜的平行四边形，对其应用变换 $(x,y) \Rightarrow (x,x+y)$，对于左边向左倾斜的平行四边形，对其应用变换 $(x,y) \Rightarrow (x,y-x+2len)$，这里加上 $2len$ 的原因是防止出现负坐标。然后对于这两个平行四边形分别用两个二维树状数组来维护，每个云朵在树状数组上进行加点删点时也应用相应的变换即可。

注意到当询问出现 $r=len$ 的情况时，$t-r$ 和 $t+r$ 这两个位置会算重，因此需要特判。

```cpp
#include<bits/stdc++.h>
#define maxn 4010
#define maxm 1000010
#define lowbit(x) (x&(-x))
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,len;
struct node
{
    int x,y;
}p[maxm];
struct BIT
{
    int t[maxn][maxn];
    void update(int x,int y,int v)
    {
        for(int i=x+1;i<=2*len;i+=lowbit(i))
            for(int j=y+1;j<=4*len;j+=lowbit(j))
                t[i][j]+=v;
    }
    int ask(int x,int y)
    {
        if(x<0||y<0) return 0;
        int v=0;
        for(int i=min(x+1,2*len);i;i-=lowbit(i))
            for(int j=min(y+1,4*len);j;j-=lowbit(j))
                v+=t[i][j];
        return v;
    }
    int query(int x1,int y1,int x2,int y2)
    {
        return ask(x2,y2)-ask(x2,y1-1)-ask(x1-1,y2)+ask(x1-1,y1-1);
    }
}T1,T2;
int main()
{
    read(n),read(len);
    for(int i=1;i<=n;++i)
    {
        int opt,t,c,l,r,d,v=0;
        read(opt);
        if(opt==1)
        {
            read(t),read(c),read(l),read(r),read(d);
            p[c].x=(t-l*d+2*len)%(2*len),p[c].y=r-l;
            T1.update(p[c].x,p[c].x+p[c].y,1),T2.update(p[c].x,p[c].y-p[c].x+2*len,1);
        }
        if(opt==2)
        {
            read(t),read(l),read(r),d=(r==len),t%=2*len;
            v+=T1.query(t,t+l,t+r-d,4*len);
            v+=T1.query(0,t+l-2*len,t+r-2*len,4*len);
            v+=T2.query(t-r+d,l-t+2*len,t-1,4*len);
            v+=T2.query(t-r+2*len,l-t,2*len,4*len);
            printf("%d\n",v);
        }
        if(opt==3)
        {
            read(t),read(c);
            T1.update(p[c].x,p[c].x+p[c].y,-1),T2.update(p[c].x,p[c].y-p[c].x+2*len,-1);
        }
    }
    return 0;
}
```

---

## 作者：稚名真白 (赞：6)

干了一下午终于看懂了题解Qwq

说一下大众化的思路 二维树状数组+数形结合

~~很懒没画图 百度百度吧~~

此题解仍然存在很多不足 仅供参考 
（个人认为有些地方比网上的更加详细）

```cpp
/*
	所有的事件按照输入顺序依次发生
	搞了半天不需要可持续。。。 
	首先看题解
	对于每一个云 有（出现时间，范围，运动方向） 
	因为运动是往返的 存在周期性
	把往右移动的云看做+len位置后 向左移动 
	所以周期为 2*len 
	所以对于所有的 t和 t%(2*len) 效果是一样的 
	而且询问和add cut都是按时间来的 
	所以我们可以将一个云表示为 
		（云的左端运动到左边界的时间 ，云的长度）
	放进二位坐标系
	对于add
		可以得到一个新的云的坐标为 
		( (Ti-Li*Di)%(2*len) ,Ri-Li )
		记录下改颜色对应的坐标 方便删除 
		放进二位的树状数组 
	对于cut
		时间都没作用 
		因为任何时候 云的颜色互异 
		直接在二维树状数组里删除对应颜色的坐标
	对于ask (t,l,r)
		因为云是往返运动 
		所以 (t,l,r)的覆盖面积是关于x=len对称的 
		先考虑x<=len的情况
		考虑重合 x较大的时候和其重合的概率较小 
		因为此时左端点就很大 
		可能经过一段时间后左端点任然在r的右边 
		就一定不会有重合
		因此 要满足 x-t<=r => x<=t+r 
		即左端点左移t和单位要在r的左边 
		同样的 x较小的时候重合概率也很小
		因为此时左端点碰到左边也右移 
		时间足够长就可能移到r的右边
		所以要满足 t-x<=r => x>=t-r 
		综上 t-r<=x<=t+r 
		左端点满足此条件是可能重合 
		如果该云长度过小也可能不重合 
		已经满足左端点<=r 如果右端点>=l 则一定有重合 
		而 该云从开始运动 t 的时间 
		距离左边界 |x-t|
		所以 length>=l-|x-t| 才能保右端点>=l  
		画出来的图像很奇葩 可以补全为一个平行四边形
		虽然面积变大了 
		但是点指挥出现在合法的面积内 不影响答案 
		对于存在( y=-x+k ) 的平行四边形 
		我们把坐标变为 (x,x+y)
		对于存在( y=x+k ) 的平行四边形 
		我们把坐标变为 (x,y-x+len*2) 
			+是为了避免出现负数
		然后维护两种个扭曲的坐标系
		所以树状数组修改的时候要修改两种 Qwq 
	注意 
	树状数组没法保存下标为0的信息  下标都后移一位
	r==len 一条直线上的点会被重复计算 判重 
*/ 
#include<bits/stdc++.h> 
#define lowbit(x) ((x)&(-x))
using namespace std;
const int N=2005,M=1000010;
int n,len,len2,len4; // 表示 2倍的len  4倍的len 
int s[2][N][N<<1],x[M],y[M];
void add(int k,int a,int b,int c)
{
	a++;b++;
	for(int i=a;i<=len2;i+=lowbit(i))
	for(int j=b;j<=len4;j+=lowbit(j)) 
		s[k][i][j]+=c;
	// 因为第二维有+len2 所以要循环到len4 
}
int sum(int k,int a,int b)
{
	a++;b++; int res=0;
	if(a<=0||b<=0) return 0; // 判断合法  
	if(a>len2) a=len2;
	if(b>len4) b=len4; // 约数在点集范围内 
	for(int i=a;i;i-=lowbit(i))
	for(int j=b;j;j-=lowbit(j))
		res+=s[k][i][j];
	return res;
}
int calc(int k,int x1,int y1,int x2,int y2)
{
	return sum(k,x2,y2)-sum(k,x2,y1-1)
			-sum(k,x1-1,y2)+sum(k,x1-1,y1-1);
}
int main()
{
	scanf("%d%d",&n,&len);;
	len2=(len<<1);len4=(len2<<1);
	while(n--)
	{
		int op,t,c,l,r,d;
		scanf("%d",&op);
		if(op==1)
		{
			scanf("%d%d%d%d%d",&t,&c,&l,&r,&d);
			x[c]=((t-l*d)%len2+len2)%len2;
			y[c]=r-l;
			add(0,x[c],x[c]+y[c],1);
			add(1,x[c],-x[c]+y[c]+len2,1);
		}
		else if(op==2)
		{
			scanf("%d%d%d",&t,&l,&r); t%=len2;
			int res=0,flag=(r==len); // 特殊情况 
			res+=calc(0,t,l+t,t+r,len4);
            res+=calc(0,0,l+t-len2,t+r-len2-flag,len4);
            res+=calc(1,t-r+len2+flag,l-t,len2,len4);
            res+=calc(1,t-r,l-t+len2,t-1,len4);
            // 这4个理解一下就行了 刚开始看就是看不懂 
            printf("%d\n",res);
		}
		else
		{
			scanf("%d%d",&t,&c); // 时间递增 t没用。。。 
			add(0,x[c],x[c]+y[c],-1);
			add(1,x[c],-x[c]+y[c]+len2,-1);
		}
	}
	return 0;
}




```



---

## 作者：咯咯咯 (赞：5)

~~这题刚开始看是懵逼的，直到我看了2楼的题解 二楼TQL~~

我的做法思路和二楼差不多，不过实现不一样，可以发现每次询问都是问一段区间可多少个图像相交，然后可以发现对于询问$[l,r]$ 可以用二维树状数组查询有多少线段的起始端点在r左边，再减去终止端点在l左边的数量就是答案了

那么怎么维护每个图像呢？

可以用旋转坐标轴后的二维树状数组

发现在新坐标轴的坐标（x,y） 分别是（点到y=x+2*len距离,点到y=-x距离），然后发现有个根号2的常数，去掉就好了

然后发现对于这个图像只要在凹点+1，在凸点-1就可以不重复的覆盖这个图像的右边

还有就是模拟云朵运动

其他也没什么了，还有就看代码吧。
```cpp
#include<iostream>
#include<cstdio>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define lowbit(x) ((x)&(-(x)))
const int M=1e6+100;
const int N=1e3+100;
void read(int &x)
{
	int t=0,opt=1;
	char c=getchar();
	while (c<'0'||c>'9') (c=='-'?opt=-1:0),c=getchar();
	while ('0'<=c&&c<='9')
	{
		t=t*10+c-'0';
		c=getchar();
	}
	x=t*opt;return ;
}
int L[M],R[M],T[M],D[M],n,len,opt,t,l,r,flag,temp;
int c[2][3*N][3*N],ans;
std::pair<int,int> p;
void update(int flag,int x,int y,int v)
{
	int temp;
	while (x<=3*len)
	{
		temp=y;
		while (temp<=3*len) 
		{
			c[flag][x][temp]+=v;
			if (!temp) break;temp+=lowbit(temp);
		}
		if (!x) break;x+=lowbit(x);
	}
}
int query(int flag,int x,int y)
{
	int temp,ans=0;
	while (x) 
	{
		temp=y;while (temp) ans+=c[flag][x][temp],temp-=lowbit(temp);ans+=c[flag][x][temp];
		x-=lowbit(x);
	}
	temp=y;while (temp) ans+=c[flag][x][temp],temp-=lowbit(temp);ans+=c[flag][x][temp];
	return ans;
}
std::pair<int,int> match(int x,int y)
{
	return std::make_pair(x-y+2*len,x+y);
}
int main()
{
	read(n);read(len);
	For(i,1,n)
	{
		read(opt);read(t);t%=2*len;
		if (opt==2) 
		{
		    read(l);read(r);ans=0;
		    p=match(r,t);ans+=query(0,p.first,p.second); 
		    if (l) p=match(--l,t),ans-=query(1,p.first,p.second); 
			printf("%d\n",ans);
		}
		if (opt==1||opt==3)
		{
			int c,d;read(c);d=opt==1?1:-1;
			if (opt==1) read(L[c]),read(R[c]),read(D[c]),T[c]=t;
			l=L[c];r=R[c];t=T[c];flag=D[c];temp=0;
			while (1) 
			{
				l+=temp*flag; r+=temp*flag;t+=temp;t%=2*len;
				if (l==0) flag=1,temp=std::min(2*len-t,len);
				else 
				{
					if (l==len) flag=-1,temp=std::min(2*len-t,len);
					else  
					{
						if (flag==1) temp=std::min(2*len-t,len-l);
						else temp=std::min(2*len-t,l); 
					}
				}
				if (!t) break;
			}temp=0;
			for(int j=0;j<2*len-1;)
			{
				l+=temp*flag,r+=temp*flag,j+=temp;t=(t+temp)%(2*len); 
				if (l==0) flag=1,temp=std::min(len,2*len-1-j);
				else
				{
					if (l==len) flag=-1,temp=std::min(len,2*len-1-j);
					else 
					{
						if (flag==1) temp=std::min(2*len-1-j,len-l);
						else temp=std::min(2*len-1-j,l);
					}
				}
				p=match(l,t);
				if (t==0) if (flag==1) update(0,p.first,p.second,1*d);
				if (t==2*len-1) if ((l<len&&flag==-1)||(l==0)) update(0,p.first,p.second,1*d);
				if (0<t&&t<2*len-1) update(0,p.first,p.second,flag*d);
				p=match(r,t);
				if (t==0) if (flag==1) update(1,p.first,p.second,1*d);
				if (t==2*len-1) if ((l<len&&flag==-1)||(l==0)) update(1,p.first,p.second,1*d);
				if (0<t&&t<2*len-1) update(1,p.first,p.second,flag*d);
			}
		}
	}
    return 0;
}
```


---

## 作者：luoguhandongheng (赞：2)

这题为啥要坐标变换......

首先云朵颜色没啥用，实际上是直接数给定区间内的云朵数量。云朵的运动周期为 $2 \times len$。如果记一个云朵左端点到达左端 0 的时刻为 $x$（模 $2 \times len$ 意义下），长度为 $y$，那么云朵的运动轨迹可以很好地表示出来。 

考虑一个询问 $(t_i, l_i, r_i)$，先看此时云朵 $(x,y)$ 运动到了哪里。这里要分 $t_i \ge x$ 和 $t_i < x$ 两种情况。\
先讨论 $t_i \ge x$ 的情况，再分两种。当 $ t_i - x \le len$ 时，此时云朵左端点的位置就是 $ t_i - x$，那么云朵所代表的线段为 $[t_i - x, t_i - x + y]$。由题意知，要求云朵线段与询问线段有交集，那么 $t_i - x \le r_i$ 并且 $t_i - x + y \ge l_i$。解一下得：
$$\begin{cases} t_i \ge x \ge \max\{t - len, t - r_i\} \\ y - x \ge l_i - t \end{cases}$$
当 $t_i - x > len + 1$ 时，云朵左端点的位置变成了 $ 2 \times len - (t_i - x)$ 其他就跟上面一样了。然后 $t_i < x$ 的情况也是一样，自己画图讨论一下就行。

最后四种情况解出来，就变成了一个动态二维数点问题，这题就做完了。复杂度是 $O(n \log^2(len))$。

[Code.](https://www.luogu.com.cn/record/228744401)

---


# [NOI2006] 聪明的导游

## 题目背景

输入数据下载地址：

https://pan.baidu.com/s/1jJX0E3c

数据由1584432137提供。

Upd on 2022.8.7：输入文件在附件。

## 题目描述

小佳最近迷上了导游这个工作，一天到晚想着带游客参观各处的景点。正好 M 市在举行 NOI，来参观的人特别的多。不少朋友给小佳介绍了需要导游的人。

M 市有$n$个著名的景点，小佳将这些景点从$1$至$n$编号。有一些景点之间存在双向的路。小佳可以让游客们在任何一个景点集合，然后带着他们参观，最后也可以在任何一个景点结束参观。不过，来参观的游客们都不愿去已经参观过的地方。所以，小佳不能带游客们经过同一个景点两次或两次以上。

小佳希望你帮助他设计一个方案, 走可行的路线, 带游客们参观尽可能多的地方。

## 说明/提示

【说明】

这是一道提交答案式的题目，你不需要提供任何源代码，只需要将自己的输出文件放在与*.in 同一个目录即可。

【样例说明】				
题目可能有多解，该样例有 4 个解，你只需输出其中任何一个解。

::cute-table{tuack}

|解 $1$|解 $2$|解 $3$|解 $4$|
| :----------: | :----------: | :----------: | :----------: |
|4  |4  |4  |4  |
|1  |1  |3  |3  |
|2  |2  |2  |2  |
|4  |5  |4  |5  |
|5  |4  |5  |4  |

【评分方法】

你的评分将由你的答案与标准答案之间的差异来给定。设你的答案正确且参观的景点数为 $x$，我们所给出的结果为 $\mathit{ans}$，则按下表计算你的得分：

::cute-table{tuack}

|得分|条件|得分|条件|
| :-----------: | :-----------: | :-----------: | :-----------: |
|$12$  |$x>ans$  |$5$  |$x \leq ans \times 0.93$  |
|$10$  |$x=ans$  |$4$  |$x \leq ans \times 0.9$  |
|$9$  |$x \leq ans-1$  |$3$  |$x \leq ans \times 0.8$  |
|$8$  |$x \leq ans-2$  |$2$  |$x \leq ans \times 0.7$  |
|$7$  |$x \leq ans-3$  |$1$  |$x \leq ans \times 0.5$  |
|$6$  |$x \leq ans \times 0.95$  |$0$  |$x \leq ans < 0.5$  |

如果有多项满足，则取满足条件中的最高得分。

## 样例 #1

### 输入

```
5 5
1 2
3 2
2 4
2 5
4 5
```

### 输出

```
4
1
2
4
5
```

# 题解

## 作者：mrsrz (赞：19)

图的直径QAQ

第9,10个点是一棵树的形态，显然是树的直径。

这提醒我们把图的问题转化成树的问题。

那么我们考虑每次随机图的一棵生成树，然后求它的直径。

这样可以跑出第1个点的情况，第2个点的情况有较小概率跑出最优解（试很多次才会出）。但后面的点，只能得合法解的分。

我们的目的是要让这棵生成树的直径最长。那么我们最好在建树的时候就尽可能满足这个目的。

考虑如果有一个节点度数很大的话，它连出去的边就会很多，答案就会不优。

所以我们就有一个想法：从一个点开始dfs遍历，每次走一个度数最小的没被访问过的点。度数相同则概率接受。

按这样的方法建树，跑树的直径，得到的答案是较优的。

走到一个点以后，更新一下其他节点的度数即可。

这样除了第2个点有些特殊，怎么跑都只能跑到次优解以外，其他点都能跑到最优。

而第2个点的解通过纯随机的方法是可以得到的，而且数据较小，可以手玩。

这样就做完了。

## Code：
```cpp
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<ctime>
#include<cstring>
#include<vector>
#define N 10005
int n,m,fa[N],s,t,dep[N],deg[N],vis[N],T;
std::vector<int>vec;
struct edge{
	int u,v;
}e[N];
inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
std::vector<int>G[N];
inline void addedge(int u,int v){G[u].push_back(v),G[v].push_back(u);}
namespace Rand{
	std::vector<int>G[N];
	void clear(){for(int i=1;i<=n;++i)G[i].clear();}
	inline void addedge(int u,int v){G[u].push_back(v),G[v].push_back(u);}
	void dfs(int u,int pre){
		for(int i:G[u])if(i!=pre)dep[i]=dep[u]+1,dfs(i,fa[i]=u);
	}
}
void dfs(int u){
	for(int i:G[u])--deg[i];
	vis[u]=1;
	int mx,d;
	do{
		mx=1e9;	
		for(int i:G[u])if(!vis[i]){
			if(deg[i]<mx||deg[i]==mx&&rand()*1./RAND_MAX>.7)mx=deg[i],d=i;
		}
		if(mx==1e9)break;
		Rand::addedge(d,u);
		dfs(d);
	}while(1);
}
int main(){
	srand(time(0));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)
	scanf("%d%d",&e[i].u,&e[i].v),addedge(e[i].u,e[i].v);
	const int lim=n>=300?10000:70000;
	for(T=1;(T==1||m>=n)&&T<=lim;++T){
		memset(deg,0,sizeof deg);
		for(int i=1;i<=m;++i)++deg[e[i].u],++deg[e[i].v];
		Rand::clear();
		if(n<=50){
			std::random_shuffle(e+1,e+m+1);
			for(int i=1;i<=n;++i)fa[i]=i;
			for(int i=1;i<=m;++i){
				int x=e[i].u,y=e[i].v;
				if(find(x)!=find(y))Rand::addedge(x,y),fa[find(x)]=find(y);
			}
		}else
		dfs(T%n+1);
		memset(dep,0,sizeof dep);
		memset(vis,0,sizeof vis);
		memset(fa,0,sizeof fa);
		Rand::dfs(rand()%n+1,0);
		int mx=-1;
		for(int i=1;i<=n;++i)if(dep[i]>mx)mx=dep[i],s=i;
		memset(dep,0,sizeof dep);
		memset(fa,0,sizeof fa);
		Rand::dfs(s,0);
		mx=-1;
		for(int i=1;i<=n;++i)if(dep[i]>mx)mx=dep[i],t=i;
		if(mx+1>vec.size()){
			vec.clear();
			for(int i=t;i;i=fa[i])vec.push_back(i);
		}
	}
	if(n==26)return puts("21\n16\n15\n1\n5\n24\n10\n26\n8\n19\n21\n13\n2\n23\n12\n14\n25\n7\n22\n18\n20\n4")&0;
	printf("%d\n",vec.size());
	for(int i:vec)printf("%d\n",i);
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：5)

测试点 $1,2$ 直接肉眼观察或暴力枚举。测试点 $9,10$ 是树的直径。

我们已经有 $40$ 分了！

ranker 告诉我对于测试点 $5,6,7,8$ 可以随机一个点作为起点爆搜，多测几次就直接得到了正确答案。

我们已经有 $80$ 分了！

自己做了一下测试点 $3,4$，发现他们的答案一个是 $n-1$ 一个是 $n$。也就是我们尽可能想构造一颗链出来。

- 对测试点 $3$，每个点的度数比较小，那么每个点大概率向度数为 $1$ 的点连，小概率向其他点得到的生成树。多随几次求直径即可拿到 $99$ 的爆标答案。
- 对测试点 $4$，每个点度数差不多，答案是 $n$，每个点只向当前度数最小的一个点连（度数相同等概率取）跑就一点即可。

---

## 作者：dehsirehC (赞：5)

## 前言

联考要讲这题，所以写了篇题解。~~然后太菜了做了一上午才做出来。~~

## 解法

可以观察到第 $9,10$ 个测试点为一棵树，而树的直径可以通过时间复杂度 $O(n)$ 的 `树上DP` 求得。

可以发现一定存在某棵原图的生成树的直径为该图的直径，这启示我们找较优的生成树求树的直径。

可以想到 `DFS树` 的直径比较长，给所有点定一个优先顺序， `DFS` 时先搜优先级较高的点。

加上模拟退火退到一定程度长时间随机调整（爬山）即可 AC 本题，~~但讲题人随了一个小时才过第 $4$ 个测试点。~~

感悟一下可以发现走出度比较大的点比较劣，因为出度小的点之后再访问时很难继续走别的点，无法串起来。

这样的话不需要调整基本也能 AC ，是一个非常优秀的做法，~~讲题人做法被吊着打。~~

---


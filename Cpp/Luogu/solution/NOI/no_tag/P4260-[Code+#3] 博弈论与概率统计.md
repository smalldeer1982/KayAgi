# [Code+#3] 博弈论与概率统计

## 题目描述

Alice 和 Bob 在玩一个双人游戏。每一轮中，Alice 有 $p$ 的概率胜利，$1-p$ 的概率失败，不会出现平局。

双方初始时各有 $0$ 分，当一个人胜利的时候，他会获得一分，失败则扣掉一分。遗憾的是，博弈论世界的人目前是无法理解负数的，因此，如果某个人输掉一轮比赛的时候他只有 $0$ 分，那么他就不会被扣分（对方会照常加一分）。游戏一共要进行 $N+M$ 轮，Alice 想请你帮她算算在游戏结束时她的得分的数学期望。

“这算啥，我小 L 分分钟搞定！”。比小 L 更熟练的你当然也是随手就算出来了，但就在你打算告诉 Alice 答案之前，博弈论世界之神——temporaryDO 出现了，他给大家带来了一个重要信息：这 $N+M$ 轮游戏中， Alice 恰好赢了 $N$ 轮！

熟知条件概率那套理论的你**立刻**注意到，你需要修改自己的计算方法来得到正确的答案了。

为了避免精度问题，请将结果对 $10^9+7$ 取模。即，我们的数据保证答案是一个有理数 $\frac{p}{q}$，且有 $10^9+7\nmid q$，你只需要找到一个整数 $x\in [0, 10^9+7)$ 使得 $qx\equiv p\pmod{10^9+7}$ 即可。



## 说明/提示

每一轮游戏 Alice 均有 $\frac{1}{2}$ 的概率胜利。

* 对于第一组数据，Alice 的胜利可能在第一轮或第二轮，并且概率相等。若她在第一轮胜利，则最终得分为 $0$，否则她的得分为 $1$。故期望为 $\frac{1}{2}$，验证发现 $2\times 500000004\equiv 1\pmod{10^9+7}$。
* 对于第二组数据，所求期望为 $\frac{3}{5}$。
* 对于第三组数据，所求期望为 $\frac{93}{70}$。

【数据范围与约定】
1. 对于 10% 的数据，$N,M,T\le 50$ 。
2. 对于另外 20% 的数据，$N,M,T\le 2000$ 。
3. 对于另外 20% 的数据，$N,M\le 10^5$，$|N-M|\le 200$，$T\le 2\times 10^5$ 。
4. 对于另外 20% 的数据，$N,M,T\le 5\times 10^4$ 。
5. 对于 100% 的数据，$N+M,T\le 2.5\times 10^5$， $0 < P' < 1000$ 。

Credit：https://www.luogu.org/discuss/show?postid=35727

## 样例 #1

### 输入

```
3 500
1 1
2 3
4 4```

### 输出

```
500000004
200000002
728571435```

# 题解

## 作者：_sry (赞：8)

题意简述

小 $A$ 与小 $B$ 在玩游戏，已知小 $A$ 赢 $n$ 局，小 $B$ 赢 $m$ 局，没有平局情况，且赢加一分，输减一分，而若只有 $0$ 分仍输不扣分。

已知小 $A$ 每次赢得概率为 $p$ ，问小 $A$ 得分期望。 $T$ 组数据。

$T,n,m\leq 2.5\times 10^5$

$solution:$

因为赢场输场已经固定，所以 $p$ 其实是没有用，则现在考虑计算小 $A$ 得分总和。

将赢输场前缀和，记为 $\{s\}$，则得分为 $n-m-min\{s\}$ 。假设所有 $-1$ 均有意义，则分数为 $n-m$ 。

设 $min\{s\}=x$，则第一次出现 $-1,-2,…,x$ 均无意义因为当时得分前为 $0$ 而又被 $-1$，无意义，共出现 $|x|$ 次情况，即得分为 $n-m-min\{s\}$。

所以现在的问题转化为给定 $n$ 个 $1$ 与 $m$ 个 $-1$ ，问最小前缀和为 $w$ 的方案数。

基本操作，将问题转化为平面移动问题。

若要求最小前缀和为 $w$ 的方案数，可以表示为从 $(0,0)$ 走到 $(n,m)$ 的方案数，每次往上或左走一步求经过 $y=x+w$ 但不能经过 $y=x+w+1$ 直线的方案数。

考虑求从 $(1,1)$ 到 $(n,m)$ 经过 $y=x+w$ 的方案数，可以将第一次经过 $y=x+w$ 的交点之前部分对 $y=x+w$ 对称，则 $(0,0)$ 对称到 $(-w,w)$ ，可以发现每次从 $(-w,w)$ 到 $(n,m)$ 经交点对称后对应一条合法路径，则其方案数为 $\dbinom{n+m}{n+w}$ 。

通过简单容斥原理得到若最小前缀和为 $w$ 的方案数为 $\dbinom{n+m}{n+w}-\dbinom{n+m}{n+w+1}$ 。

考虑赢 $n$ 场输 $m$ 场的得分，得分区间为 $[max\{0,n-m\},n]$ 。

分类讨论 $n,m$ 大小。

若 $n\geq m$ ，则得分区间在 $[n-m,n]$ , $min\{s\}\in [-m,0]$。

$Ans=\sum_{i=0}^{m} (n-m+i) (\dbinom{n+m}{n+i}-\dbinom{n+m}{n+i+1})$

$$=(n-m) \sum_{i=0}^m(\dbinom{n+m}{n+i}-\dbinom{n+m}{n+i+1}) +\sum_{i=0}^m i\times (\dbinom{n+m}{m-i}-\dbinom{n+m}{m-i-1})$$
$$=(n-m)\dbinom{n+m}{n}+\sum_{i=0}^{m-1} \dbinom{n+m}{i}$$

若 $n<m$ ，则同理 $min\{s\}\in [{-m,n-m}]$

$$Ans=\sum_{i=m-n}^m (n-m+i)\times\dbinom{n+m}{m-i}-\dbinom{n+m}{m-i-1}$$
$$=(n-m)\dbinom{n+m}{n}+\sum_{i=m-n}^m i\times \dbinom{n+m}{m-i}-\sum_{i=m-n}^{m-1} i\times \dbinom{n+m}{m-i-1}$$
$$=(n-m)\dbinom{n+m}{n}+(m-n)\dbinom{n+m}{n}+\sum_{i=m-n+1}^m i\times \dbinom{n+m}{m-i}-\sum_{i=m-n}^{m-1} i\times \dbinom{n+m}{m-i-1}$$
$$=\sum_{i=m-n+1}^{m-1} i\times\dbinom{n+m}{m-i}-\sum_{i=m-n+1}^{m} (i-1)\times \dbinom{n+m}{m-i+1}$$
$$=\sum_{i=m-n+1}^{m} \dbinom{n+m}{m-i}$$
$$=\sum_{i=0}^{n-1}\dbinom{n+m}{i}$$

可以发现现在的问题为如何快速求 $F(n,k)=\sum_{i=0}^k \dbinom{n}{i}$

可以发现 $F(n,k)=\sum_{i=0}^k \dbinom{n-1}{i-1}+\dbinom{n-1}{i}=2\times F(n-1,k)-\dbinom{n-1}{k}$ 。即 $F(n,k)$ 与 $F(n-1,k)$ 和 $F(n,k-1)$ 都有递推关系。

直接将答案离线后莫队计算即可。

时间复杂度 $O((n+m)\sqrt{n+m})$ 。

---

## 作者：EastPorridge (赞：5)

楼上的 dalao 的题解中的式子几乎推得完美，这篇题解主要进行细节补充与概述方便大家理解。

### 题目概述：

求 $A$ 在比 $N+M$ 场赛中胜利 $N$ 场的得分期望（胜利得 $1$ 分，失败扣 $1$ 分，存在保护机制，即到 $0$ 分再失败不会扣分）。

### 预备知识：

期望，卡特兰数，费马小定理求逆元，杨辉三角与组合数，莫队。

不过相信点进这道题的你这些对你都不成问题。

------------

### 题目分析：

$A$ 的得分期望就是所有情况下 $A$ 的得分除以 $C_{n+m}^{n}$ ，问题转化为求所有情况下 $A$ 的得分和。

我们从 $A$ 的最大得分情况开始分析，可知 $A$ 的最大得分时的方案为开局 $m$ 场全输，后面 $n$ 场全赢，因为开局分为 $0$ ，一直触发保护机制不扣分，所以最大得分为 $n$ 。

所以从 $n-m$ 分开始，每多得一分都是吃了一次保护机制。

我们可以构造一个类似于卡特兰数的图像，设定向上走为 $A$ 胜利，向右走为 $B$ 胜利，最终到达点 $(n,m)$ 本局结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/noxf1h0e.png)

图中两条绿线在构造直线下到达终点 $(n,m)$ ，为合法方案，图中红线越过了直线，为非法方案。

同理，我们推广到 $A$ 得分为 $n-m+1$ 时就是将直线向上平移 $1$，简单容斥我们可得到此时的合法方案就是通过了它平移前的直线且没有通过平移后的直线所构成的合法方案。

我们可以通过对称起点，构造所有不合法的方案（下图中粉线），针对平移后的直线合法方案就是所有方案减去非法方案，即： $ans = \sum_{i=0}^{m} (C_{n+m}^{n+i} - C_{n+m}^{n+i+1})(n-m+i)$ ，通过错位相减，我们可以将原式化为： $ans = (n-m) C_{n+m}^{n} + \sum_{i=0}^{m-1} C_{n+m}^{i}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/v2e1vx22.png)

发现 $(n-m) C_{n+m}^{n}$ 可以处理出来，问题就转化为如何快速处理 $\sum_{i=0}^{m-1} C_{n+m}^{i}$ ，设 $f(n,k) = \sum_{i=0}^{k} C_{n}^{i}$ ，我们将 $n,k$ 看做一个二维平面，发现点 $(n,k)$ 到 $(n,k-1)$ 与 $(n,k+1)$ 可以加减 $C_{n}^{k+1}$ 与 $C_{n}^{k}$ 直接得来，又根据杨辉三角 $f(n,k) = \sum_{i=0}^{k} (C_{n-1}^{i-1} + C_{n-1}^{i}) = 2 \times f(n-1,k) - C_{n-1}^{k}$ 来快速维护点 $(n,k)$ 到 $(n-1,k)$ 与 $(n+1,k)$ ，我们可以使用莫队维护。

本题可以看做卡特兰数的拓展运用，同时也告诉我们莫队不只是单纯的离线区间维护算法。简单说一下第二类斯特林数做法的不可行性，我们可以认为它所包含的方案是所有与构造直线有交点的合法方案，而少统计了如图一两条绿线一样的不与直线相交的情况。

代码有压行，但逻辑相同的部分多在同一行，~~自认为存在部分可读性~~。

### Code.

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+10,mod=1e9+7;
int T,p,x[N],y[N],ans[N],len,fin[N],l,ifin[N],res=2;
int get(int x) {return x/len;} struct node {int x,k,id;} q[N];
inline int ksm(int a,int b) {int res=1; while(b) {if(b&1) res=(res*a)%mod; a=(a*a)%mod; b>>=1;} return res;}
bool cmp(node a,node b) {if(get(a.x) == get(b.x)) return a.k < b.k; return a.x < b.x;}
inline int C(int n,int k) {if(n < k) return 0; return ((fin[n]*ifin[n-k])%mod*ifin[k])%mod;}
signed main()
{
	scanf("%lld%lld",&T,&p);
	for(int i=1;i<=T;i++)
	{
		scanf("%lld%lld",&x[i],&y[i]);
		q[i].x=x[i]+y[i]; q[i].id=i; l=max(l,q[i].x); q[i].k=min(x[i],y[i])-1;
	}
	len=max(1LL,(int)sqrt(l)); sort(q+1,q+T+1,cmp);
	fin[0]=1; for(int i=1;i<=l;i++) fin[i]=fin[i-1]*i%mod;
    ifin[l]=ksm(fin[l],mod-2); for(int i=l;i>=1;i--) ifin[i-1]=ifin[i]*i%mod;
	for(int i=1;i<=T;i++) if(x[i]>=y[i]) ans[i]=(x[i]-y[i])*C(x[i]+y[i],x[i])%mod;
	int n=1,k=1,i2=ksm(2,mod-2);
	for(int i=1;i<=T;i++)
	{
		int n1=q[i].x,k1=q[i].k;
        while(n > n1) res=(res+C(n-1,k))*i2%mod,n--;
        while(n < n1) res=(res*2-C(n,k)+mod)%mod,n++;
        while(k > k1) res=(res-C(n,k)+mod)%mod,k--;
        while(k < k1) res=(res+C(n,k+1))%mod,k++;
        ans[q[i].id]=(ans[q[i].id]+res)%mod;
    }
	for(int i=1;i<=T;i++) printf("%lld\n",(ans[i]*ksm(C(x[i]+y[i],x[i]),mod-2)%mod)%mod);
	return 0;
}
```
更好的阅读体验：[link](https://www.cnblogs.com/EastPorridge/p/16468633.html)

---

## 作者：zhiyangfan (赞：3)

很有意思的组合题。最后计算答案非常巧妙。
> A 和 B 共进行 $n+m$ 轮游戏，每轮游戏赢的人分数从 $s$ 变为 $s+1$，输的人变为 $\max(0,s-1)$。一开始二人的分数均为 $0$，每轮游戏 A 获胜的概率为 $p$，不存在平局。求出在 A 恰好赢了 $n$ 轮的情况下，A 最终得分的期望值。答案对 $10^9+7$ 取模。你需要解决 $T$ 组数据。($1\le n+m,T\le 2.5\times10^5$)

首先注意到概率是诈骗，因为每种情况出现概率是相同的，所以期望值即为 A 在所有情况下得分的平均数。

接下来我们注意到 A 最终得分有显然的上下界，最多得 $n$ 分，最少得 $\max(0,n-m)$ 分。前者只需要先输再赢，后者是先赢再输。更进一步，我们发现如果在整个过程中，用了 $i$ 次“豁免”，则最终得分为 $n-m+i$。

考虑“豁免”到底是个什么东西，下文设赢的次数为 $x$，输的次数为 $y$。考虑第一次“豁免”，即第一次 $x<y$ 的时候。之后再用“豁免”，就是第一次 $x<y-1$ 了，毕竟有一次 $y$ 失效了。以此类推，用了至少 $i$ 次“豁免”的充要条件即为出现过 $x<y-(i-1)$。

接下来是一个非常奇妙的转化，考虑我们需要解决的问题是在 $n+m$ 步中选 $n$ 步给 $x$ 加 $1$，剩余给 $y$ 加 $1$，且全程保持 $x\ge y-i$。然后，你发现我们可以把它扔到平面直角坐标系上，问题就变为了从 $(0,0)$ 走到 $(n,m)$，且不越过 $y=x+i$ 的方案数。

这个问题我们可以仿照不越过 $y=x$ 的方案数解决。注意到所有越过 $y=x+i$ 的路径，均会与 $y=x+i+1$ 相交。然后我们把路径从第一个交点沿着 $y=x+i+1$ 翻折，显然它的终点会变为 $(n,m)$ 关于 $y=x+i+1$ 的对称点。而反过来翻折回来也能对应上。这样，我们就把经过 $y=x+i+1$ 到达 $(n,m)$ 的路径和没有限制但最终到达 $(n,m)$ 关于 $y=x+i+1$ 的对称点的路径建立了双射。从而我们把这些路径从 $\binom{n+m}{n}$ 减去即可得到不越过 $y=x+i$ 的方案数。求 $(n,m)$ 关于 $y=x+i+1$ 的对称点方法就很多了，高中数学。最终得到的结果是 $(m-i-1,n+i+1)$。所以不越过 $y=x+i$ 的路径方案数即为：
$$\dbinom{n+m}{n}-\dbinom{n+m}{m-i-1}$$

不越过 $y=x+i$ 的方案数表示至多用了 $i$ 次“豁免”。所以恰好用了 $i$ 次“豁免”的方案数即为至多用 $i$ 次的减去至多用 $i-1$ 次的：
$$\dbinom{n+m}{m-i}-\dbinom{n+m}{m-i-1}$$

验证发现这个对于 $i=0$ 也成立。

这样我们就能统计答案了。但注意得分的区间中有个 $\max$，所以我们需要分讨一下。主要分讨的是 $n-m+i$ 的取值范围。

当 $n\ge m$ 时。
$$\begin{aligned}\mathrm{Sum}&=\sum_{i=0}^{m}(n-m+i)\left(\dbinom{n+m}{m-i}-\dbinom{n+m}{m-i-1}\right)\\&=(n-m)\dbinom{n+m}{m}+\sum_{i=0}^{m-1}\dbinom{n+m}{i}\end{aligned}$$
化简就是考虑相邻两项可以相消，自己展开几项就明白了。

当 $n<m$ 时。
$$\begin{aligned}\mathrm{Sum}&=\sum_{i=m-n}^{m}(n-m+i)\left(\dbinom{n+m}{m-i}-\dbinom{n+m}{m-i-1}\right)\\&=\sum_{i=0}^{n-1}\dbinom{n+m}{i}\end{aligned}$$
化简思路同上。

至此，我们已经可以在 $\mathcal{O}(n+m)$ 的复杂度回答单组询问了，答案即为：
$$\dfrac{\mathrm{Sum}}{\dbinom{n+m}{m}}$$
但显然 $\mathcal{O}(T(n+m))$ 的复杂度我们不能接受，注意到瓶颈在于每次求组合数的前缀和。

考虑设 $f$：
$$f_{a,b}=\sum\limits_{i=0}^a\dbinom{b}{i}$$
则我们相当于每次要求一个二元组的值。一个很重要的想法是，如果我们可以在 $\mathcal{O}(1)$ 的时间内将 $a$ 或 $b$ 变化 $1$，则最小移动次数可以通过莫队解决，即可在 $\mathcal{O}((n+m)\sqrt{T})$ 的时间复杂度解决本题。

$a$ 的移动是简单的：
$$f_{a+1,b}=f_{a,b}+\dbinom{b}{a+1}$$

考虑 $b$ 的移动，只需要用经典的组合数递推公式：
$$\begin{aligned}
	f_{a,b+1}&=\sum_{i=0}^{a}\dbinom{b+1}{i}\\&=\sum_{i=0}^a\left(\dbinom{b}{i}+\dbinom{b}{i-1}\right)\\&=f_{a,b}+f_{a-1,b}
\end{aligned}$$

这样，我们就在 $\mathcal{O}((n+m)\sqrt{T})$ 的时间复杂度内完成了本题。

本题的两个要点，一个是意识到“豁免”对答案计算的影响并发现它在平面直角坐标系上的意义，求出方案。另一个是发现广义上的莫队计算组合数前缀和，虽然这里 $a,b$ 不一定是一个区间，但只要是左右指针的总最小移动次数均可以通过莫队解决。
```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
#include <algorithm>
const int N = 3e5 + 10, mod = 1e9 + 7, inv = (mod + 1) / 2; typedef long long ll;
struct Query{ int l, r, n, m, id, add; }qu[N]; int L, R;
int ans[N], fac[N], ifac[N], blo[N], now = 1;
inline int ksm(int a, int b)
{
	int ret = 1;
	while (b)
	{
		if (b & 1) ret = (ll)ret * a % mod;
		a = (ll)a * a % mod; b >>= 1;
	}
	return ret;
}
inline int C(int n, int m) { if (m > n) return 0; return (ll)fac[n] * ifac[m] % mod * ifac[n - m] % mod; }
int main()
{
	std::ios::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0);
	int q, p, n = 0; std::cin >> q >> p;
	for (int i = 1, n, m; i <= q; ++i)
	{
		std::cin >> n >> m, qu[i].l = n + m, qu[i].r = std::min(n, m) - 1;
		qu[i].id = i, qu[i].n = n, qu[i].m = m;
		if (n > m) qu[i].add = (n - m);
	}
	for (int i = 1; i <= q; ++i) n = std::max(n, qu[i].l);
	fac[0] = ifac[0] = 1;
	for (int i = 1; i < N; ++i) fac[i] = (ll)fac[i - 1] * i % mod;
	ifac[N - 1] = ksm(fac[N - 1], mod - 2);
	for (int i = N - 2; i; --i) ifac[i] = (ll)ifac[i + 1] * (i + 1) % mod;
	int B = q / sqrt(n);
	for (int i = 1; i <= n; ++i) blo[i] = (i - 1) / B;
	std::sort(qu + 1, qu + q + 1, [&](const Query& x1, const Query& x2)
	{
		return (blo[x1.l] ^ blo[x2.l]) ? (blo[x1.l] < blo[x2.l]) :
		((blo[x1.l] & 1) ? x1.r > x2.r : x1.r < x2.r);
	});
	for (int i = 1; i <= q; ++i)
	{
		while (L < qu[i].l) (now += (now + mod - C(L++, R)) % mod) %= mod;
		while (R < qu[i].r) (now += C(L, ++R)) %= mod; 
		while (R > qu[i].r) (now += mod - C(L, R--)) %= mod;
		while (L > qu[i].l) now = (ll)(now + C(--L, R)) % mod * inv % mod;
		int n = qu[i].n, m = qu[i].m;
		ans[qu[i].id] = (qu[i].add + (ll)fac[m] * fac[n] % mod * ifac[n + m] % mod * now % mod + mod) % mod;
	}
	for (int i = 1; i <= q; ++i) std::cout << ans[i] << '\n';
 	return 0;
}
```
~~截止题解写完的时候我还是 O2 最优解~~

哦，对了，不开 O2 会稍微有点卡常。

---

## 作者：_ANIG_ (赞：1)

神仙题。

由于胜场已知，所以给的概率没有用。只需要求出所有情况的得分和，然后除以情况总数即可。

考虑胜负构成的序列，若胜则为 $1$，负则为 $0$。

求出此序列的前缀和序列，少扣的分数就是前缀和序列的最小值。

对每个前缀和考虑，则对答案的贡献为 $(n-m+k)f_k$。

其中，$f_k$ 为最小前缀和为 $-k$ 的序列个数。

可以求出最小前缀和不低于 $-k$ 的序列个数，减以下就是最小前缀和恰好为 $-k$ 的个数。

把这个问题抽象成一个二维平面，胜看作往右一格，负看作往上一格。

则每个序列就可以对应一个从 $(0,0)$ 到 $(n,m)$ 的序列。

每个位置的前缀和就是 $x-y$。

最小前缀和不低于 $-k$ 就对应着每个点都满足 $-k\le x-y$，即 $y\le x+k$。

可以发现，这个不等式的意义就是路径不穿过直线 $y=x+k$ 且在 $y=x+k$ 的下方。

现在求不穿过直线 $y=x+k$ 的路径个数。

再容斥一下，求出总路径条数减去穿过直线 $y=x+k$ 的路径条数。

总路径条数相当于把 $n$ 个 $1$ 个 $m$ 个 $-1$ 排列组合，方案数 $C(n+m,n)$。

现在求穿过直线 $y=x+k$ 的路径条数，也就是和直线 $y=x+k+1$ 有交点的方案数。

这个东西就与求不穿过 $y=x$ 的路径条数很类似，把从 $(0,0)$ 到路线与 $y=x+k+1$ 第一个交点之间的路线沿 $y=x+k+1$ 翻转，就形成了一条从 $(-k-1,k+1)$ 到 $n,m$ 的路径。并且从 $(0,0)$ 到 $(n,m)$ 的路径与要求的穿过 $y=x+k$ 的路径一一对应，也就是穿过 $y=x+k$ 的路径条数就是从 $
(-k-1,k+1)$ 到 $(n,m)$ 的路径条数，也就是 $C(n+m,n+k+1)$。

综上，不穿过直线 $y=x+k$ 的路径条数就是 $C(n+m,n)-C(n+m,n+k+1)$。

则与直线 $y=x+k$ 至少有一个交点且不穿过 $y=x+k$ 的路径条数为 $(C(n+m,n)-C(n+m,n+k+1))-(C(n+m,n)-C(n+m,n+k))=C(n+m,n+k)-C(n+m,n+k+1)$。

答案为 $\sum\limits_{k=\max(0,m-n)}^{m}(n-m+i)(C(n+m,n+i)-C(n+m,n+i+1))$。

~~于是，我们终于打完了 $30$ 分的暴力。~~

分类讨论。

- ### $m\le n$

答案为 

$$\sum\limits_{i=0}^m(n-m+i)(C(n+m,n+i)-C(n+m,n+i+1))$$

$$=\sum\limits_{i=0}^m(n-m)(C(n+m,n+i)-C(n+m,n+i+1))+\sum\limits_{i=0}^mi(C(n+m,n+i)-C(n+m,n+i+1))$$

$$=(n-m)\sum\limits_{i=0}^mC(n+m,n+i)-C(n+m,n+i+1)+\sum\limits_{i=0}^miC(n+m,n+i)-iC(n+m,n+i+1)$$

左右两边分开处理。

左边：

$$\sum\limits_{i=0}^mC(n+m,n+i)-C(n+m,n+i+1)$$

$$=C(n+m,n)-C(n+m,n+1)+C(n+m,n+1)-C(n+m,n+2)+...$$

两两相消后只剩 $C(n+m,n)$。

右边：

$$\sum\limits_{i=0}^miC(n+m,n+i)-iC(n+m,n+i+1)$$

$$=C(n+m,n+1)-C(n+m,n+2)+2C(n+m,n+2)-2C(n+m,n+3)+3C(n+m,n+3)-3C(n+m,n+4)+...$$

两两相消，但消不完。还剩下：

$$\sum\limits_{i=1}^mC(n+m,n+i)$$

总上，答案为 $(n-m)C(n+m,n)+\sum\limits_{i=1}^mC(n+m,n+i)$。
- ### $m>n$
答案为：

$$\sum\limits_{i=m-n}^m(n-m+i)(C(n+m,n+i)-C(n+m,n+i+1))$$

$$=\sum\limits_{i=m-n}^m(n-m)(C(n+m,n+i)-C(n+m,n+i+1))+\sum\limits_{i=m-n}^mi(C(n+m,n+i)-C(n+m,n+i+1))$$

$$=(n-m)\sum\limits_{i=m-n}^mC(n+m,n+i)-C(n+m,n+i+1)+\sum\limits_{i=m-n}^miC(n+m,n+i)-iC(n+m,n+i+1)$$

依然分开处理，两两相消完后答案为

$$\sum\limits_{i=1}^mC(n+m,n+i)$$

现在，只需要求 

$$\sum\limits_{i=1}^mC(n+m,n+i)$$

$$=\sum\limits_{i=1}^mC(n+m,m-i)$$

$$\sum\limits_{i=0}^{m-1}C(n+m,i)$$

设 $f_{n,m}=\sum\limits_{i=0}^mC(n,i)$

$$f_{n,m+1}=f_{n,m}+C(n,m+1)$$

接下来是求 $f_{n+1,m}$。

有个递推式：$C(n,m)=C(n-1,m-1)+C(n-1,m)$。

可以理解为在 $n$ 个数中选 $m$ 个，如果第 $n$ 个数不选，就是前 $n-1$ 
个数选 $m$ 个，如果选就是前 $n-1$ 个数选 $m-1$ 个。

$$f_{n+1,m}=\sum\limits_{i=0}^mC(n+1,i)$$

$$=\sum\limits_{i=0}^mC(n,i-1)+C(n,i)$$

$$=\sum\limits_{i=0}^mC(n,i-1)+\sum\limits_{i=0}^mC(n,i)$$

$$=\sum\limits_{i=0}^{m-1}C(n,i)+\sum\limits_{i=0}^mC(n,i)$$

$$=2\sum\limits_{i=0}^{m}C(n,i)-C(n,m)$$

$$=2f_{n,m}-C(n,m)$$

于是，可以从 $f_{n,m}$ 递推到 $f_{n+1,m}$ 和 $f_{n,m+1}$。

莫队即可。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+5,mods=1e9+7,maxn=20,T=500;
int pows(int a,int b){
    if(b==0)return 1;
    int res=pows(a,b>>1);
    res=res*res%mods;
    if(b&1)res=res*a%mods;
    return res;
}
int n,m,jc[N],ny[N],res,t,f1[N],f2[N],f[N],rs[N],gn[N],gm[N];
struct node{
    int a,b;
    friend bool operator<(node a,node b){
        if(a.b/T==b.b/T)return a.a<b.a;
        else return a.b<b.b;
    }
}p[N];
int C(int a,int b){
    return jc[a]*ny[b]%mods*ny[a-b]%mods;
}
map<pair<int,int>,int>q;
signed main(){
    cin>>t>>n;
    jc[0]=ny[0]=1;
    for(int i=1;i<N;i++)jc[i]=jc[i-1]*i%mods,ny[i]=pows(jc[i],mods-2);
    for(int i=1;i<=t;i++){
        scanf("%lld%lld",&gn[i],&gm[i]);
        if(gm[i]<=gn[i])p[i]=(node){gn[i]+gm[i],gm[i]-1};
        else p[i]=(node){gn[i]+gm[i],gn[i]-1};
    }
    sort(p+1,p+t+1);
    p[0].b=-1e9;
    for(int i=1;i<=t;i++){
        if(p[i].b/T!=p[i-1].b/T){
            res=0;
            for(int j=0;j<=p[i].b;j++)res+=C(p[i].a,j),res%=mods;
            q[make_pair(p[i].a,p[i].b)]=res;
            continue;
        }
        for(int j=p[i-1].a+1;j<=p[i].a;j++){
            res=2*res-C(j-1,p[i-1].b);
            res%=mods;
        }
        for(int j=p[i-1].b+1;j<=p[i].b;j++)res+=C(p[i].a,j),res%=mods;
        for(int j=p[i-1].b;j>p[i].b;j--)res-=C(p[i].a,j),res%=mods;
        q[make_pair(p[i].a,p[i].b)]=res;
    }
    for(int i=1;i<=t;i++){
        n=gn[i],m=gm[i];
        if(m<=n)res=(q[make_pair(n+m,m-1)]+(n-m)*C(n+m,n))%mods;
        else res=q[make_pair(n+m,n-1)];
        printf("%lld\n",(res*pows(C(n+m,n),mods-2)%mods+mods)%mods);
    }
}
```

---

## 作者：Purslane (赞：0)

# Solution

看起来非常简单，实则一点也不难。

首先这个 $p$ 一点用都没有，因为我们已知的信息是 Alice 胜了 $n$ 局。

考虑一条 $(0,0)$ 到 $(n+m,n-m)$ 的线，点 $(x,y)$ 表示——到了第 $x$ 局，如果能接受负数，Alice 的得分。

类似 IOI 分糖果那道题，我们知道：Alice 最终得分是 $n-m$ 减去这个最小值。所以我们求出最小值的期望即可。

考虑最小值 $\le t$ 的概率：

1. 如果 $t \ge \min \{0,n-m\}$，显然为 $1$；
2. 否则，为 $\dbinom{n+m}{t+m}$。

所以，当 $n \ge m$ 时，我们计算 

$$-\sum_{t=-m}^{-1} \dbinom{n+m}{t+m} = -\sum_{t=0}^{m-1} \dbinom{n+m}{t}$$

当 $n<m$ 时，我们计算

$$
- \sum_{t=-m}^{n-m-1} = - \sum_{t=0}^{n-1} \dbinom{n+m}{t}
$$

也就是说，我们每组询问计算

$$
\sum_{t=0}^{\min\{n,m\}-1} \dbinom{n+m}{t}
$$

即可！

而众所周知，记 

$$f(n,m) = \sum_{i=0}^m \dbinom{n}{m}$$

可以 $O(1)$ 进行递推。所以莫队即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=3e5+10,MOD=1e9+7;
int T,p,t=300000,frac[MAXN],inv[MAXN],ans[MAXN],ddd[MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int C(int u,int d) {if(u>d||u<0) return 0;return frac[d]*inv[u]%MOD*inv[d-u]%MOD;}
int n,m,res;
void add_n(void) {return res=(res*2-C(m,n))%MOD,++n,void();}
void add_m(void) {return res=(res+C(m+1,n))%MOD,++m,void();}
void del_n(void) {return res=(res+C(m,n-1))%MOD*(MOD+1)/2%MOD,--n,void();}
void del_m(void) {return res=(res-C(m,n))%MOD,m--,void();}
struct QR {int n,m,id;}qr[MAXN];
void MO(void) {
	ffor(i,1,T) {
		while(m<qr[i].m) add_m();
		while(m>qr[i].m) del_m();
		while(n<qr[i].n) add_n();
		while(n>qr[i].n) del_n();
		ans[qr[i].id]+=res*qpow(ddd[qr[i].id],MOD-2)%MOD;
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	frac[0]=1; ffor(i,1,t) frac[i]=frac[i-1]*i%MOD;
	inv[t]=qpow(frac[t],MOD-2); roff(i,t-1,0) inv[i]=inv[i+1]*(i+1)%MOD;
	n=1,m=0,res=1;
	cin>>T>>p;
	ffor(i,1,T) {
		int nn,mm;
		cin>>nn>>mm;
		ans[i]=nn-mm,ddd[i]=C(nn,nn+mm),qr[i]={nn+mm,min(nn,mm)-1,i};	
		if(nn<mm) ans[i]+=mm-nn;
	}
	sort(qr+1,qr+T+1,[](QR A,QR B) {
		if(A.n/550!=B.n/550) return A.n/550<B.n/550;
		return A.m<B.m;	
	});
	MO();
	ffor(i,1,T) cout<<(ans[i]%MOD+MOD)%MOD<<'\n';
	return 0;
}
```

---

## 作者：happybob (赞：0)

首先 $p$ 毫无意义，因为已经确定有 $n$ 局赢了。

把获胜记为 $+1$，失败记为 $-1$，分数就是最大后缀和。即求所有局面的最大后缀和的和。

显然把序列翻转答案是一样的，变成最大前缀和的和。

先考虑怎么对于每次询问线性计算，枚举答案 $k$，计算有多少局面的最大前缀和不超过 $k$。则等价于起点为 $(0,0)$，到达 $(m,n)$，每次向左或向上，不触碰直线 $y=x+k+1$ 的方案数，这是经典反射容斥，答案等于 $\dbinom{n+m}{m} - \dbinom{n+m}{m+k+1}$。

推一下式子答案大概形如 $\sum \limits_{k=1}^n k \times (\binom{n+m}{m+k} - \binom{n+m}{m+k+1})$，$n>m$ 时 $k$ 需要从 $n-m$ 开始枚举。

这个式子进一步展开发现你只需要维护组合数前缀和，这个东西是经典莫队，直接计算即可，复杂度 $O(n \sqrt n)$。

---


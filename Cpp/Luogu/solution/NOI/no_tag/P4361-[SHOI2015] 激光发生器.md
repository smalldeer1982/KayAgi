# [SHOI2015] 激光发生器

## 题目描述

曾经发明了超能粒子炮・改的发明家 SHTSC 又公开了他的新发明：激光发生器——一种可以产生高能激光的神秘装置。

激光发生器从正上方看是一个无穷大的平面，里面由一个定向激光发射装置和若干个激光偏转装置组成。一个激光发生器的示例如图所示，细箭头表示定向激光发射装置，粗线段表示激光偏转装置。

![](https://cdn.luogu.com.cn/upload/pic/16401.png)

由定向激光发射装置发射出的激光可以看成是一条射线，如果遇到激光偏转装置就会发生偏转。奇特的是，SHTSC 所使用的激光偏转装置并非像传统的镜子那样遵循反射定律，而是对于每个激光偏转装置，有一个固定的偏转系数 $λ$，其出射角 $β$ 与入射角 $α$ 的关系为 $β=λα$，并且能在这一过程中增强激光的能量。

![](https://cdn.luogu.com.cn/upload/pic/16402.png)

注意：

1. 入射角是入射光线和反射平面法向量的夹角。
2. 偏转装置的两面均可偏转。
3. 如果激光平行射入偏转装置，则认为没有发生偏转。
4. 如果不平行且照射到了端点，则认为发生偏转。
5. 当 $β>\frac{1}{2}π$ 时，可能会偏转到另一面。

现在 SHTSC 希望你模拟他所设计的激光发生器的工作过程，来帮助他计算激光究竟被哪些激光偏转装置所偏转。

## 说明/提示

### 样例解释

如图所示，激光依次被 $1$ 号和 $2$ 号偏转装置偏转。

![](https://cdn.luogu.com.cn/upload/pic/16403.png)

## 数据规模和约定

对于 $10\%$ 的数据，$n=1$；  
对于 $40\%$ 的数据，$a=b=1$；  
对于 $100\%$ 的数据，$n \le 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a,b$ 均非零，$dx$ 、$dy$ 不同时为零。保证所有的偏转装置没有交点，且激光发射起始点不在任何偏转装置上。

## 样例 #1

### 输入

```
0 2 1 0
2
0 4 3 1 1 1
4 0 0 -4 1 1```

### 输出

```
1 2```

# 题解

## 作者：81179332_ (赞：7)

这里给出向量旋转公式的推导过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/dwuhubvl.png)

$\cos A=\dfrac{x_0}{|R|},\sin A=\dfrac{y_0}{|R|}$

$x_1=|R|\cdot \cos(A+B)$

$\ \ \ \ \ =|R|\cdot (\cos A\cos B-\sin A\sin B)$

$\ \ \ \ \ =|R|\cdot (\dfrac{x_0}{|R|}\cos B-\dfrac{y_0}{|R|}\sin B)$

$\ \ \ \ \ =x_0\cos B-y_0\sin B$

$y_1=|R|\cdot \sin(A+B)$

$\ \ \ \ \ =|R|\cdot (\sin A\cos B+\cos A\sin B)$

$\ \ \ \ \ =|R|\cdot (\dfrac{y_0}{|R|}\cos B+\dfrac{x_0}{|R|}\sin B)$

$\ \ \ \ \ =x_0\sin B+y_0\cos B$

所以向量 $(x_0,y_0)$ 逆时针旋转角$B$后的向量为 $(x_0\cos B-y_0\sin B,x_0\sin B+y_0\cos B)$。

对于本题则直接模拟光线的反射过程即可。

```cpp
#include<cstdio>
#include<cctype>
#include<cmath>
using namespace std;
//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)
char BB[1 << 15],*SS = BB,*TT = BB;
using namespace std;
inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	for(;!isdigit(ch);ch = getchar())
		if(ch == '-')
			f = -1;
	for(;isdigit(ch);ch = getchar())
		x = x * 10 + (ch ^ 48);
	return x * f;
}
void print(long long x)
{
	if(x < 0)
		putchar('-'),x = -x;
	if(x > 9)
		print(x / 10);
	putchar(x % 10 + '0');
}

const double eps = 1e-9,pi = acos(-1);
int dcmp(double x)
{
	if(fabs(x) < eps)
		return 0;
	return x < 0 ? -1 : 1;
}
struct point
{
	double x,y;

	void read()
	{
		x = ::read(),y = ::read();
	}
	point(double _x = 0,double _y = 0)
	{
		x = _x,y = _y;
	}
	friend point operator + (point szq,point yqy)
	{
		return point(szq.x + yqy.x,szq.y + yqy.y);
	}
	friend point operator - (point szq,point yqy)
	{
		return point(szq.x - yqy.x,szq.y - yqy.y);
	}
	friend point operator * (point szq,double yqy)
	{
		return point(szq.x * yqy,szq.y * yqy);
	}
	friend double operator * (point szq,point yqy)
	{
		return szq.x * yqy.x + szq.y * yqy.y;
	}
	friend double operator & (point szq,point yqy)
	{
		return szq.x * yqy.y - szq.y * yqy.x;
	}
	void rotate(double rad)
	{
		*this = point(x * cos(rad) - y * sin(rad),x * sin(rad) + y * cos(rad));
	}
	double lenth()
	{
		return sqrt((*this) * (*this));
	}
	bool onSeg(point szq,point yqy)
	{
		return dcmp((szq - *this) & (yqy - *this)) == 0 && dcmp((szq - *this) * (yqy - *this)) < 0;
	}
};
point intersection(point p,point v,point q,point w)
{
    return p + v * ((w & (p - q)) / (v & w));
}
double angle(point a,point b)
{
	return acos(a * b / a.lenth() / b.lenth());
}

const int N = 110;
int n;
struct Mirror
{
	point s,t;
	double a,b;
}a[N];
point p,d;
int main()
{
	p.read(),d.read();n = read();
	for(int i = 1;i <= n;i++)
		a[i].s.read(),a[i].t.read(),a[i].a = read(),a[i].b = read();
	bool fl = false;
	for(int T = 1;T <= 10;T++)
	{
		double minn = 1e200;
		int id = -1;
		for(int i = 1;i <= n;i++)
		{
			point v = a[i].t - a[i].s;
			if(dcmp(v & d))
			{
				point t = intersection(a[i].s,v,p,d);
				if(t.onSeg(a[i].s,a[i].t) && dcmp(d * (t - p)) > 0)
				{
					double dis = (t - p).lenth();
					if(dis < minn)
						minn = dis,id = i;
				}
			}
		}
		if(!~id)
			break;
		point v = a[id].t - a[id].s;
		p = intersection(a[id].s,v,p,d);
		print(id),putchar(' ');
		fl = true;
		if(!dcmp(v * d))
		{
			d = d * -1;
			continue;
		}
		if(dcmp(d * v) < 0)
			v = v * -1;
        double alpha = pi / 2 - angle(v,d);
		alpha = pi / 2 - alpha * a[id].a / a[id].b;
        int bt = dcmp(d & v);
        v.rotate(bt * alpha);
        d = v;
	}
	if(!fl)
		puts("NONE");
}
```

---

## 作者：WAAutoMaton (赞：6)

[宣传我的博客（逃](https://waautomaton.tk/2018/11/28/loj-2039-%E9%A2%98%E8%A7%A3/)

#### 题目大意

平面上有若干个镜子（都是线段，入射角/反射角的比值各不相同（这不物理啊）），现在射出一道激光，问激光经过各种反射之后会撞上哪些镜子。

#### 题解

因为自己计算几何能力太弱所以开了这题（PKUSC2018肝了半场的计算几何题最后还是爆零的阴影）。  

这是一道比较显然的计算几何题，基本只需用计算几何的各种基本操作去模拟题意就能做了，也没啥坑点。  

但是我太弱了，计算几何板子只能照着蓝书打，主算法部分也是看着[另一份题解](http://www.cnblogs.com/KKKorange/p/8646447.html)写的（捂脸）。

具体的算法过程都写在下面代码的注释里了，应该是很好理解的吧（逃

#### 参考代码

```cpp
/*+lmake
 * DEFINE += WAAUTOMATON
 */
#include <bits/stdc++.h>
#ifdef WAAUTOMATON
#define debug(args...)                                                                             \
    {                                                                                              \
        dbg, args;                                                                                 \
        cerr << endl;                                                                              \
    }
#define massert(x) assert(x)
#else
#define debug(args...) // Just strip off all debug tokens
#define massert(x)
#endif
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
typedef std::pair<int,int> pii;

void iopen()
{
    static bool isOpen = false;
    if (!isOpen) {
        isOpen = true;
#ifdef WAAUTOMATON
        freopen("in.txt", "r", stdin);
#endif
    }
}

template <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>
struct IO_Tp
{
    //这是IO优化板子，为了阅读体验此部分省略
};
IO_Tp<> IO;

//从这里开始是计算几何模板
const double eps=1e-8;
int dcmp(double x,double y)
{
	if (abs(x-y)<eps) return 0;
	else return x-y<0?-1:1;
}
int dcmp(double x)
{
	if (abs(x)<eps) return 0;
	else return x<0?-1:1;
}
struct Point
{
	double x,y;
	Point(double x=0,double y=0):x(x),y(y){}
};
typedef Point Vector;
Vector operator+(const Vector& a,const Vector& b){return Vector(a.x+b.x,a.y+b.y);} 
Vector operator-(const Vector& a,const Vector& b){return Vector(a.x-b.x,a.y-b.y);}
Vector operator*(const Vector& a,double b){return Vector(a.x*b,a.y*b);}
Vector operator/(const Vector& a,double b){return Vector(a.x/b,a.y/b);}
bool operator<(const Point& a,const Point& b)
{
	if (dcmp(a.x,b.x)==0) return a.y<b.y;
	else return a.x<b.x;
}
bool operator==(const Point& a,const Point& b)
{
	return dcmp(a.x,b.x)==0 && dcmp(a.y,b.y)==0;
}
double dot(const Vector& a,const Vector& b) {return a.x*b.x+a.y*b.y;} //点积
double length(const Vector& a){return sqrt(dot(a,a));} //向量的模
double angle(const Vector& a,const Vector& b){return acos(dot(a,b)/length(a)/length(b));} //求2个向量的夹角
double cross(const Vector& a,const Vector& b){return a.x*b.y-a.y*b.x;} //叉积
Vector rotate(Vector a,double rad) //将一个向量绕起点转rad
{
	return Vector(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));
}
Point getLineIntersection(const Point &p,const Vector& v,const Point& q,const Vector & w) //求2个直线交点（需保证有且只有1个交点）
{
	Vector u=p-q;
	double t=cross(w,u)/cross(v,w);
	return p+v*t;
}
bool onSegment(const Point& p,const Point& a1,const Point& a2) //求一个点是否在线段上
{
	return dcmp(cross(a1-p,a2-p))==0 && dcmp(dot(a1-p,a2-p))<0;
}

//以上为计算几何模板，全部来自蓝书

const int MAXN=100;
struct Data
{
	Point p1,p2;
	int a,b;
}a[MAXN+10];
int main()
{
	iopen();
	int x,y,dx,dy,n;
	cin>>x>>y>>dx>>dy>>n;
	for(int i=1; i<=n; ++i) {
		cin>>a[i].p1.x>>a[i].p1.y>>a[i].p2.x>>a[i].p2.y>>a[i].a>>a[i].b;
	}
	Point p(x,y); //当前激光起点坐标
	Vector v(dx,dy); //当前激光的方向向量
	bool flag=true;
	for(int t=1; t<=10; ++t) {
		double mdis=1e100;
		int id=0; 
        // 下面这个for找出所有与当前激光有交的镜子，并求出其中交点与p距离最短的镜子（显然激光接下来一定撞在这个镜子上）。
		for(int i=1; i<=n; ++i) {
			if (dcmp(cross(a[i].p1-a[i].p2,v))!=0) { //排除激光与镜子平行的情况
				Point t=getLineIntersection(a[i].p1,a[i].p2-a[i].p1,p,v); //求交点
				if (onSegment(t,a[i].p1,a[i].p2) && dcmp(dot(v,t-p))>0) { //判断交点在镜子上，并且不在激光的另一侧（激光是一条射线）
					double dis=length(p-t); //计算距离
					if (dis<mdis) {
						mdis=dis;
						id=i;
					}
				}
			} 
		}
		if (id==0) break;
		p=getLineIntersection(a[id].p1,a[id].p2-a[id].p1,p,v); //求交点，并作为新的激光起点
        //接下来求新的激光方向
		if (dcmp(dot(a[id].p1-a[id].p2,v))==0) { //如果镜子与激光垂直，直接方向向量取反即可
			v=v*-1;
		} else {
			Vector t;
			t=a[id].p2-a[id].p1; //求镜子的方向向量
			if (dcmp(dot(a[id].p1-a[id].p2,v))>0) t=0-t; //入射角要取锐角
			double alpha=acos(-1)/2-angle(t,v); //计算入射角
			int bt=dcmp(cross(t,v)); 
			v=rotate(t,bt*(alpha*a[id].a/a[id].b-acos(-1)/2)); //先计算出反射角（再吐槽一次，入射角不等于反射角，这一点都不物理啊），然后把镜子的方向向量转那个角度，得到的就是新的激光方向向量了。
		}
		cout<<id<<' ';
		flag= false;
	}
	if (flag) cout<<"NONE";
	cout<<endl;
    return 0;
}


```



---

## 作者：kernel_panic (赞：2)

## 题目大意
光线追踪，但是对于第 $i$ 面镜子，光线的入射角为 $\alpha$ 时，反射角 $\beta=\lambda_i\alpha$，其中 $\lambda_i$ 是给定的常数．

## 思路
要求出光线的路径上遇到的所有偏转装置的编号，直接递归模拟反射过程即可，难点在于如何计算反射光线．

我们使用 $\mathbf{R}(x)=\mathbf{A}+x\mathbf{b}$ 来表示一条直线，其中 $\mathbf{A}$ 是源点，$\mathbf{b}$ 是方向向量，$x$ 是参数．

对于两条直线 $\mathbf{A}(x)=\mathbf{P}+x\mathbf{u},\mathbf{B}(x)=\mathbf{Q}+x\mathbf{v}$，我们考虑如何求它们间的交点．

若它们之间有交点，则有两实数 $s,t$，满足 $\mathbf{A}(s)=\mathbf{B}(t)$．只要我们计算出 $s$ 或 $t$，我们就知道了交点．以计算 $s$ 为例，我们有：
$$
\mathbf{P}+s\mathbf{u}=\mathbf{Q}+t\mathbf{v}
$$

等式两边点乘上 $\mathbf{v}$ 的法向量 $\mathbf{n}$，得到：
$$
\mathbf{P} \cdot \mathbf{n} + s\mathbf{u} \cdot \mathbf{n} =\mathbf{Q} \cdot \mathbf{n} + \mathbf{0}
$$

整理可得：
$$
s=\frac{\mathbf{Q} \cdot \mathbf{n} - \mathbf{P} \cdot \mathbf{n}}{\mathbf{u} \cdot \mathbf{n}}
$$

$t$ 的计算类似．

记当前入射光线为 $\mathbf{R}(x)=\mathbf{A}+x\mathbf{u}$，偏转装置为 $\mathbf{M}(x)=\mathbf{B}+x\mathbf{v}$．

光线是射线，所以对于 $\mathbf{R}(x)$，应当有 $x>0$．

我们不妨让表示偏转装置的直线的方向向量由线段的一个端点指向另一个端点．这样对于 $\mathbf{M}(x)$，应当有 $0 \le x \le 	1$．

知道了如何对光线和偏转装置求交，我们再考虑如何计算反射光线．

为了计算方便，不妨让反射过程中的法线 $\mathbf{N}(x)=\mathbf{H}+x\mathbf{w}$ 和 $\mathbf{R}(x)$ 在同一侧．如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/qgcjylaf.png)

这样我们只需要计算出 $-\mathbf{u}$ 到 $\mathbf{w}$ 的转角 $\theta$，反射光线即为 $\mathbf{R}^\prime(x)=\mathbf{H}+x\mathbf{c}$，其中 $\mathbf{c}$ 是 $\mathbf{w}$ 旋转 $\lambda\theta$ 角之后的向量．如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/bz71rm3a.png)

其中 $\mathbf{a}$ 到 $\mathbf{b}$ 的转角 $\displaystyle\theta=\arcsin\frac{\mathbf{a}\times\mathbf{b}}{|\mathbf{a}||\mathbf{b}|}$．

在模拟光线反射的过程中，对于能够相交的偏转装置，设交点为 $\mathbf{R}(s)$，我们选取最小的 $s$ 所对应的反射光线作为下一次反射的入射光线，这样就能保证这一次反射在离源点最近的反射装置处发生．

## 代码
```cpp
#include <cmath>
#include <iostream>

using f64 = double;
constexpr size_t N = 1 << 7;
constexpr f64 eps = 1e-5;

struct vec {
	f64 x, y;
	vec(f64 x = 0, f64 y = 0) : x(x), y(y) {}
	f64 len() const { return std::sqrt(x * x + y * y); }
};
using point = vec;

vec operator-(const vec &a) { return {-a.x, -a.y}; }
vec operator+(const vec &a, const vec &b) { return {a.x + b.x, a.y + b.y}; }
vec operator-(const vec &a, const vec &b) { return {a.x - b.x, a.y - b.y}; }
vec operator*(const f64 a, const vec &b) { return {a * b.x, a * b.y}; }
vec norm(const vec &a) { return {-a.y, a.x}; }
f64 dot(const vec &a, const vec &b) { return a.x * b.x + a.y * b.y; }
f64 cross(const vec &a, const vec &b) { return a.x * b.y - a.y * b.x; }
f64 angle(const vec &a, const vec &b) { return std::asin(cross(a, b) / (a.len() * b.len())); }
vec rotate(const vec &a, f64 x) {
	return {a.x * std::cos(x) - a.y * std::sin(x), a.x * std::sin(x) + a.y * std::cos(x)};
}
std::istream &operator>>(std::istream &is, vec &v) {
	f64 x, y;
	is >> x >> y, v = {x, y};
	return is;
}

struct ray {
	point ori;
	vec dire;
	ray() : ori(), dire() {}
	ray(const point &ori, const vec &dire) : ori(ori), dire(dire) {}
	point at(f64 x) { return ori + x * dire; }
};

struct refl {
	ray r;
	f64 k;
	refl() : r(), k() {}
	refl(const point &s, const point &t, const f64 k) : r(s, t - s), k(k) {}
	bool hit(const ray &inr, ray &otr, f64 &x) {
		vec m = norm(inr.dire);
		f64 s = dot(m, inr.ori - r.ori) / dot(m, r.dire);
		if (s < eps || s > 1) return false;
		vec n = norm(r.dire);
		if (dot(-inr.dire, n) < 0) n = -n;
		f64 t = dot(n, r.ori - inr.ori) / dot(n, inr.dire);
		if (t < eps) return false;
		x = t, otr = {r.at(s), rotate(n, k * angle(-inr.dire, n))};
		return true;
	}
};

int n;
refl a[N];
point o, d;

int ans[N], tp;
void dfs(const ray &r, int dep) {
	if (dep <= 0) return;
	int id = 0;
	ray rf, tr;
	f64 mn = 1e300, tl;
	for (int i = 1; i <= n; i++) {
		if (a[i].hit(r, tr, tl)) {
			if (tl < mn) id = i, rf = tr, mn = tl;
		}
	}
	if (id) {
		ans[++tp] = id;
		dfs(rf, dep - 1);
	}
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	std::cin >> o >> d >> n;
	for (int i = 1, x, y; i <= n; i++) {
		point s, t;
		std::cin >> s >> t >> x >> y;
		a[i] = {s, t, f64(x) / y};
	}

	dfs({o, d}, 10);

	if (tp) {
		for (int i = 1; i <= tp; i++) {
			std::cout << ans[i] << " \n"[i == tp];
		}
	} else std::cout << "NONE\n";

	return 0;
}
```


---


# [HAOI2018] 字串覆盖

## 题目描述

小 C 对字符串颇有研究，他觉得传统的字符串匹配太无聊了，于是他想到了这样一个问题。

对于两个长度为 $n$ 的串 $A,B$，小 C 每次会给出给出 $4$ 个参数 $s,t,l,r$。令 $A$ 从 $s$ 到 $t$ 的
子串（从 $1$ 开始标号）为 $T$，令 $B$ 从 $l$ 到 $r$ 的子串为 $P$。然后他会进行下面的操作：

如果 $T$ 的某个子串与 $P$ 相同，我们就可以覆盖 $T$ 的这个子串，并获得 $K-i$ 的收益，其中 $i$ 是初始时 $A$ 中（注意不是 $T$ 中）这个子串的起始位置，$K$ 是给定的参数。一个位置不能被覆盖多次．覆盖操作可以进行任意多次，你需要输出获得收益的最大值。

注意每次询问都是独立的，即进行一次询问后，覆盖的位置会复原。

## 说明/提示

样例 $1$ 解释 ![](https://cdn.luogu.com.cn/upload/pic/18143.png)

对于所有数据，有 $1\le n,q\le 10^5$，$A,B$ 仅由小写英文字母组成，$ 1\le s\le t\le n$，$ 1\le l\le r\le n$，$n<K\le 10^9$。
HAOI2018 round1 T3

对于 $ n = 10^5 $ 的测试点，满足 $51\le r−l\le2\times 10^3$ 的询问不超过 $11000$ 个，且 $l,r$ 均匀随机

数据范围
![](https://cdn.luogu.com.cn/upload/pic/18142.png)

## 样例 #1

### 输入

```
10 11
abcbababab
ababcbabab
5
1 9 7 9
3 10 8 10
1 10 1 2
5 7 2 3
1 5 3 6```

### 输出

```
6
10
22
5
10```

# 题解

## 作者：PhantasmDragon (赞：6)

安利博客:http://phantasmdragon.leanote.com/post/%5B%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%5D%5B%E7%BA%BF%E6%AE%B5%E6%A0%91%5D%5B%E5%80%8D%E5%A2%9E%5D%5B%E4%B9%B1%E6%90%9E%5D%E3%80%8CHAOI2018%E3%80%8D%E5%AD%97%E4%B8%B2%E8%A6%86%E7%9B%96

美妙的字符串数据结构乱shen搞xian题
首先就是明显的贪心, 每次肯定选择在 $A$ 中最左边的串进行删除, 直到收益 $\leq 0$ 时停止.

注意到非常奇怪数据范围, 毒瘤出题人在暗示我们什么呢?

~~不难看出~~这道题需要写两个做法拼在一起.

对于 $r-l \geq 2000$, 我们对 $A$  建立后缀自动机+线段树合并求出每个自动机节点的 $endpos$ 集合, 然后对于每个询问,通过倍增跳后缀链接找到询问区间字符串 $B_l \dots B_r$  在后缀自动机上对应的节点,然后在该节点的线段树上一个一个挨个找最左边的 $endpos$, 注意一下选出的 $endpos$ 代表的字符串不能相交即可.

这样因为 $r-l \geq 2000$, 我们最多不会跳超过 $\frac{n}{2000}$ 次,所以不会挂.

对于 $r-l\leq 51$, 我们处理一个倍增数组 $nxt_{len,i,j}$ 表示:

长度为 $len$, 在 $A$ 中左端点为 $i$ 的字符串 $s$, 后 $2^j$ 个与 $s$ 相同的字符串的左端点的位置. 

顺带再记一个 $sum_{len,i,j}$, 表示从 $i$ 开始,后面包括自己与 $A_i \dots A_{i+len-1}$ 相同的 $2^j$ 个字符串的权值之和是多少.

在这两个数组中,这的 $2^j$ 个字符串都不能相交.

这两个数组可以用哈希来处理, 得到这两个数组之后就可以倍增 $O(\log n)$处理每个询问了.

对于每个不同的 $len$ 我们都要重新处理一下这个被整数组,而 $r-l \leq 51$ 所以 $len$ 的取值不会超过 $51$ 个,所以离线一下, 对于 $len$ 相同的询问不要重复处理就行了, 顺便可以省掉数组的第一维.

然后对于 $51 \leq r-l \leq 2000$ 的, 保证随机分布, 而且个数不会太多, 所以用 $r-l \geq 2000$ 的方法处理就行了.

----------

贴上代码:
```
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<unordered_map>
#define maxn 300005
#define ll long long
using namespace std;
struct node{int l1,r1,l2,r2,id;}Q[maxn];
bool operator <(node a,node b){return a.r2-a.l2<b.r2-b.l2;}
int n,K;
char A[maxn],B[maxn];
namespace SGT
{
	int ls[maxn*60],rs[maxn*60],rt[maxn*60],rpos[maxn*60],tot;
	void ins(int &p,int l,int r,int x)
	{
		if(!p) p=++tot;
		if(l==r) {rpos[p]=x;return;}
		int mid=(l+r)>>1;
		if(x<=mid) ins(ls[p],l,mid,x);
		else ins(rs[p],mid+1,r,x);
		rpos[p]=max(rpos[ls[p]],rpos[rs[p]]);
	}
	int Merge(int u,int v,int l,int r)
	{
		if((!u)||(!v)) return (u?u:v);
		else if(l==r)
		{
			rpos[++tot]=l;
			return tot;
		}
		int New=++tot,mid=(l+r)>>1;
		ls[New]=Merge(ls[u],ls[v],l,mid);
		rs[New]=Merge(rs[u],rs[v],mid+1,r);
		rpos[New]=max(rpos[ls[New]],rpos[rs[New]]);
		return New;
	}
	int Query(int p,int l,int r,int x)
	{
		if(l==r) return l;
		int mid=(l+r)>>1;
		if(rpos[ls[p]]>=x) return Query(ls[p],l,mid,x);
		else return Query(rs[p],mid+1,r,x); 
	}
}
namespace SAM
{
	int mx[maxn],par[maxn],rt=1,tot=1,last=rt;
	int son[maxn][26],pos[maxn],buc[maxn],td[maxn],id[maxn];
    int Jump[22][maxn],enpos[maxn],enlen[maxn];
	int push(int x)
	{
	    mx[++tot]=x;
	    return tot;
	}
	void extend(int t)
	{
	    int np,nq,p,q;
	    np=push(mx[last]+1);
	    for(p=last;p&&!son[p][t];p=par[p]) son[p][t]=np;
	    if(!p) par[np]=rt;
	    else
	    {
	        q=son[p][t];
	        if(mx[q]==mx[p]+1) par[np]=q;
	        else
	        {
	            nq=push(mx[p]+1),id[nq]=id[np];
	            memcpy(son[nq],son[q],sizeof(son[q]));
	            par[nq]=par[q],par[q]=par[np]=nq;
	            for(;son[p][t]==q;p=par[p]) son[p][t]=nq;
	        }
	    }
	    last=np;
	}
	void TopSort()
	{
		for(int i=1;i<=tot;i++) buc[mx[i]]++;
		for(int i=1;i<=n;i++) buc[i]+=buc[i-1];
		for(int i=1;i<=tot;i++) td[buc[mx[i]]--]=i;
	}
	void GetSegTree()
	{
		TopSort();
		for(int i=2;i<=tot;i++) SGT::ins(SGT::rt[i],1,n,id[i]);
		for(int i=tot;i>1;i--)
		{
			int t=td[i];
			if(par[t]!=1)
				SGT::rt[par[t]]=SGT::Merge(SGT::rt[par[t]],SGT::rt[t],1,n);
		}
	}
	int Run(int pos,int len)
	{
		int now=enpos[pos];
        if(enlen[pos]<len) return 0;
        for(int i=20;i>=0;i--)
            if(Jump[i][now]&&mx[Jump[i][now]]>=len)
                now=Jump[i][now];
        return now;
	}
    void GetJump()
    {
        for(int i=1;i<=tot;i++)
            Jump[0][i]=par[i];
        for(int i=1;i<=20;i++)
            for(int j=1;j<=tot;j++)
                Jump[i][j]=Jump[i-1][Jump[i-1][j]];
        for(int i=1,now=1,nowlen=0;i<=n;i++)
        {
            if(son[now][B[i]-'a'])
                nowlen++,now=son[now][B[i]-'a'];
            else
            {
                while(now&&!son[now][B[i]-'a']) now=par[now];
                if(!now) nowlen=0,now=rt;
                else nowlen=mx[now]+1,now=son[now][B[i]-'a'];
            }
            enpos[i]=now,enlen[i]=nowlen;
        }
    }
	ll Solve(int l1,int r1,int l2,int r2)
	{
		int len=r2-l2+1;
		r1=min(r1,K+len-1);
		int p=Run(l2+len-1,len);
		if(!p) return 0;
		if(SGT::rpos[SGT::rt[p]]<l1+len-1) return 0;
		int st=SGT::Query(SGT::rt[p],1,n,l1+len-1),en=r1;
		if(st>en) return 0;
		ll ans=0;
		while(st<=en)
		{
			if(st-len+1>=K) break;
			ans+=K-(st-len+1);
			if(SGT::rpos[SGT::rt[p]]<st+len) break;
			st=SGT::Query(SGT::rt[p],1,n,st+len); 
		}
		return ans;
	}
}
namespace MI
{
	const int P=1000000007ll;
	int nxt[21][100005]; ll sum[21][maxn];
	ll Ha[maxn],pw[maxn];
	void GetHash()
	{
		pw[0]=1;
		for(int i=1;i<maxn;i++) pw[i]=pw[i-1]*P; 
		for(int i=1;i<=n;i++) Ha[i]=Ha[i-1]+A[i]*pw[i];
	}
	void GetNxt(int len)
	{
		unordered_map<ll,deque<int>> pre;
		memset(nxt,0,sizeof(nxt));
		for(int i=1;i<=n-len+1;i++)
		{
			ll now=Ha[i+len-1]-Ha[i-1];
			now*=pw[n-len-i+1];
			while(pre[now].front()<=i-len&&pre[now].size())
				nxt[0][pre[now].front()]=i,pre[now].pop_front();
			pre[now].push_back(i); 
			sum[0][i]=K-i;
		}
		for(int j=1;j<=20;j++)
			for(int i=1;i<=n-len+1;i++)
				nxt[j][i]=nxt[j-1][nxt[j-1][i]],sum[j][i]=sum[j-1][i]+sum[j-1][nxt[j-1][i]];
	}
	ll Solve(int l1,int r1,int l2,int r2)
	{
		int len=r2-l2+1;
		r1=min(r1,K+len-1);
		int p=SAM::Run(l2+len-1,len);
		if(!p) return 0;
		if(SGT::rpos[SGT::rt[p]]<l1+len-1) return 0;
		int st=SGT::Query(SGT::rt[p],1,n,l1+len-1)-len+1,en=r1-len+1;
		if(st>en) return 0;
		ll ans=0;
		for(int i=20;i>=0;i--)
			if(nxt[i][st]&&nxt[i][st]<=en)
				ans+=sum[i][st],st=nxt[i][st];
		ans+=sum[0][st];
		return ans;
	}
}
ll ans[maxn];
int main()
{
	scanf("%d%d",&n,&K);
	scanf("%s%s",A+1,B+1);
	for(int i=1;i<=n;i++)
		SAM::id[SAM::tot+1]=i,SAM::extend(A[i]-'a');
	SAM::GetSegTree(),SAM::GetJump();
	MI::GetHash();
	int T; scanf("%d",&T);
	for(int i=1;i<=T;i++)
		scanf("%d%d%d%d",&Q[i].l1,&Q[i].r1,&Q[i].l2,&Q[i].r2),Q[i].id=i;
	sort(Q+1,Q+T+1);
	for(int i=1;i<=T;i++)
	{
		if(Q[i].r2-Q[i].l2+1<=51)
		{
			if(Q[i].r2-Q[i].l2!=Q[i-1].r2-Q[i-1].l2||i==1)
				MI::GetNxt(Q[i].r2-Q[i].l2+1);
			ans[Q[i].id]=MI::Solve(Q[i].l1,Q[i].r1,Q[i].l2,Q[i].r2);
		}
		else ans[Q[i].id]=SAM::Solve(Q[i].l1,Q[i].r1,Q[i].l2,Q[i].r2);
	}
	for(int i=1;i<=T;i++) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：2018ljw (赞：2)

目前的三篇题解，两篇 SAM，[一篇](https://www.luogu.com.cn/blog/dsidsi/solution-p4493)交错[题](https://www.luogu.com.cn/problem/P4494)了，所以我在这里提供一种 SA 的做法。~~也是为了证明绝大多数时候 SA 和 SAM 可以互替。~~

## 整体分析
首先贪心的想，每次肯定是删掉最左的可行串。感性理解，如果我们删掉一个靠右的串，那么最左串要么删不了，要么仍能删。仍能删那就一定会删最左串。删不了的话，首先我们一定会损失一定的收益，而且删靠右的一定不会让左边产生新的可删串，反而可能会占掉右边的可删串。所以**每次删最左的可行串，直到删不了为止**。

把两个长串接在一起并分割，构造出 $SA,rank,height$ 数组，我们考虑将原问题转化为数据结构问题。

- 以下记题目中的 $T$ 串为文本串，$P$ 串为匹配串。$l,r$ 为文本串左右端点，$len$ 为匹配串长度。

首先我们可以利用 $ST$ 表和二分，$O(n\log n)$ 处理出后缀数组上的可行区间。那么我们就要在可行区间里选出一些串，使得

1. 串的开头都在文本串中。
2. 选的串尽量多。
3. 任意两个串开头至少相差 $len$，其中 $len$ 是匹配串的长度。
4. 最小化下标之和。

对于要求 2、4，实质上就是每次选最左的串。考虑 $SA$ 数组的定义，我们可以发现，每次选最左的串等效于选取最小且合法的 $SA$。

观察并不寻常的数据范围，我们可以分成三类。

- $len\ge 2001$。
- $len\ge 52$，数据随机且很小。
- $len\le 51$。

对于第一类，最多能选出 $\frac n {len}\le 50$ 个串。对于第二类，因为数据均匀随机，所以暴力也可以过。这两类我们统一处理。

## 暴力部分

考虑我们暴力要做的工作。首先是找到查询区间，然后每次选出数值在一段区间里的最小的 $SA$，然后统计答案。

第一部分可以直接 $ST$ 表二分解决；第二部分等价于查询区间后继，第三部分可以 $O(1)$ 完成。查询区间后继可以直接树套树解决，出于时空考虑，我们选用线段树套平衡树完成，复杂度 $O(50m\log^2n)$。由于平衡树复杂度实际上与其元素数有关，并且我们基本做不到选出 $50$ 个串，所以这是一个很松的上界。

整体思路就是外层线段树记录位置，内层平衡树记录 $sa$ 数组。我们记录初始的值 $p=l-1$，每次找到 $p$ 的后继 $next$ 后更新答案，然后将 $p$ 变为 $next+len-1$。如此循环直到找不到后继或者后继位置超出 $r$。

然后我们会发现大区间相同时，线段树拆分出的小区间也一定相同。所以我们记录当前区间在线段树上拆分后的位置，每次直接调用这些位置求后继即可，可以进行常数级别的优化。

预处理复杂度 $O(n\log^2n)$，单次查询 $O(\log^2n)$。

> yy一种优化，不一定对。将所有询问离线，使用莫队配合平衡树处理这些区间。每次找到一个区间后直接处理出这些区间的答案，复杂度 $O(n\sqrt n\log n+50m\log n)$。理论上可以利用[二次离线](https://www.luogu.com.cn/problem/P4887)做到 $O(n\sqrt n+50m\log n)$。

将 $n=10^5$ 且 $len\le 51$ 的全部 $skip$ 后发现 60pts，四个 WA 点均 $\le 300ms$。因此这一部分不会影响主体时间。

整理一下：
1. 得到所有询问区间。
2. 利用树套树或莫队二次离线，快速提取出一段区间的平衡树。
3. 不断查询后继，更新答案。

## 苦难部分

（苦难主要是因为这里卡常被卡了一上午，稍微改亿改又调了一个下午。）

$len\le 51$ 时，我们一次能选出的串非常多，但不同的长度非常少。这提示我们基于 $len$ 入手。

首先考虑一个问题：我们选出的这些串，其 $lcp\ge len$，而实际上对于一个确定的 $len$，为了保证能卡掉暴力做法，**相同的串必定很多**。那么如何快速统计出一段区间内选某个串的下标和呢？

答案是倍增。

假设当前匹配串的长度为 $len$，我们记 $next_{i,j}$ 表示从 $i$ 开始（不计算 $i$），**合法且最优地**选出 $2^j$ 个与 $i$ 的 $lcp\ge len$ 的后缀，最后一个是谁。同时记录 $sum_{i,j}$ 表示对于 $next_{i,j}$ 所选出的 $2^j$ 个后缀的下标之和。有了这两项，我们就可以做到已知起始位置时 $O(\log n)$ 统计答案。

$next$ 的递推式与倍增求 $lca$ 的倍增表类似，$sum$ 的递推式就是两部分加起来，考虑求初值。

### 寄巧

显然，每个后缀的初值应当是按 $height$ 分组后，它所在的组中，第一个大于其的后缀。所以看到这个你就可以沿用暴力部分的树套树求后继求解了。配合卡常可以做到不 Tle。

卡常也很简单，除去暴力部分提及的拆分点预处理外，我们交换倍增表的两维（即 $next_{i,j}$ 表示从 $j$ 开始选 $2^i$ 个串 $\ldots$），合成一个串后接上来的那个串不处理，再加入快读快写和 $inline$ 即可，复杂度 $O(50m\log^2n)$。

### 正解

但我们要考虑更优的解法。重新看 $next_{i,0}$ 的定义：从 $i$ 开始，第一个与其 $lcp\ge len$ 的合法后缀。

我们发现 $len\le 51$，也就是说比较部分很少，甚至可以暴力。因此我们对每个后缀 $i$ 开始，求出这个长串哈希值 $h_i=Hash(i\ldots i+len-1)$。那么 $next_{i,0}$ 等价于从 $i$ 开始，第一个与其 $h$ 相等的合法位置。因为要合法，所以我们倒序枚举，离散化+单调队列处理即可。代码里略有不同，使用的是离散化+二分桶。

现在我们已经知道了倍增表，考虑对于一个已知的区间如何求解，显然直接倍增即可。唯一的问题就是找到最小的合法后缀。~~直接树套树求一个后缀就行。~~

老惦记你那树套树干嘛，$O(\log^2n)$ 复杂度直接否决。

我们找到区间最小的后缀，先将其倍增到小于 $l$ 且最大的位置。其中 $l$ 是文本串左端点。然后若其小于 $l$，那么我们让其再进一步，得到位置 $pos$。然后看 $pos+len-1$ 是否大于右端点，大于则无解，小于则开始倍增。

唯一要注意的就是倍增的初始位置的贡献并没有统计进来，所以需要额外加上。

但仍然有一个小问题：覆盖偏移。我们找起始位置的时候，如果从外面跳进来的时候，把更靠前的合法位置占了，那么会导致答案锅掉。幸运的是，很好处理。

我们从 $l$ 到 $\min\{l+len-1,pos,r\}$ 暴力枚举，看这个位置的 $rank$ 是否在目标区间中，在的话直接将 $pos$ 改为当前位置，然后结束枚举。

正确性是显然的。我们的覆盖不可能超出 $l+len-1$，所以如果找不到，就说明真没有。如果找到了，最早找到的一定是最小的。

最后，我们把询问离线，$len$ 相同的统一处理即可，复杂度 $O(51m\log n)$，常数略大。

整理一下：

1. 询问离线，按匹配串长度排序。对每种新的长度重构倍增表。
2. 哈希+单调队列处理出倍增表初值，倍增表快速得到区间答案和下一个位置。
3. $ST$ 表二分得到询问区间。
4. 区间最小开始找询问起点，注意特殊的边界情况。
5. 从起点开始倍增，统计答案。

总复杂度：取决于暴力部分，二次离线 $O(50m\log n+n\sqrt n)$，树套树 $O(50m\log^2n)$。

吐槽：很离谱，我第二部分写的卡常树套树比卡常的哈希还快。明明常数优化都加的一样的，但树套树就是快了一截。

完整代码 6.2kb，已添加注释。
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<algorithm>
const int mod=1000000007;
using namespace std;
char s[200002];
long long val;
int n,m,sa[300001],rk[300001],height[300001];
int tsa[300001],trk[600001],cnt[300001];
int st[19][200002],lg[200002],size;
int qrlr[101],top,root[1600002];
int nxt[20][250002];
long long sum[20][250002],hh[250002],tmp[250002];
int min(int x,int y){
	return x<y?x:y;
}
int qr(int l,int r){
	int d=lg[r-l+1];
	return min(st[d][l],st[d][r-(1<<d)+1]);
}
struct queries{
	int l1,r1,l2,r2,id,len;
	long long ans;
}q[100001];
bool operator<(queries a,queries b){
	return a.len<b.len;
}
bool cmp(queries a,queries b){
	return a.id<b.id;
}
struct treap{
	int son[2],val,key;
}tre[4000001];
void rotate(int &k,int fx){
	int x=tre[k].son[fx^1];
	tre[k].son[fx^1]=tre[x].son[fx];
	tre[x].son[fx]=k;
	k=x;
}
void insert(int &k,int val){
	if(!k){
		k=++size;
		tre[k].key=rand();
		tre[k].val=val;
		return;
	}
	if(tre[k].val>val){
		insert(tre[k].son[0],val);
		if(tre[k].key<tre[tre[k].son[0]].key)rotate(k,1);
	}
	else{
		insert(tre[k].son[1],val);
		if(tre[k].key<tre[tre[k].son[1]].key)rotate(k,0);
	}
}
int qlas(int k,int val){
	int x=root[k],res=n+1;
	while(x){
		if(tre[x].val<=val)x=tre[x].son[1];
		else res=tre[x].val,x=tre[x].son[0];
	}
	return res;
}
void out_insert(int k,int l,int r,int x,int val){
	insert(root[k],val);
	if(l==r)return;
	int mid=l+r>>1;
	if(x<=mid)out_insert(k<<1,l,mid,x,val);
	else out_insert(k<<1|1,mid+1,r,x,val);
}
void sbuild(){
	//处理后缀数组、st表
	int i,j;
	n=n*2+1;
	for(i=1;i<=n;i++)rk[i]=s[i]-'a'+1,cnt[rk[i]]++;
	for(i=1;i<=27;i++)cnt[i]+=cnt[i-1];
	for(i=n;i;i--)sa[cnt[rk[i]]--]=i;
	for(i=1;i<=n;i++){
		if(s[sa[i]]==s[sa[i-1]])rk[sa[i]]=rk[sa[i-1]];
		else rk[sa[i]]=rk[sa[i-1]]+1;
	}
	for(j=1;j<n;j*=2){
		memcpy(tsa,sa,sizeof(sa));
		memcpy(trk,rk,sizeof(rk));
		int tot=0;
		for(i=n;i>n-j;i--)sa[++tot]=i;
		for(i=1;i<=n;i++)if(tsa[i]>j)sa[++tot]=tsa[i]-j;
		for(i=1;i<=n;i++)rk[i]=trk[sa[i]];
		memset(cnt,0,sizeof(cnt));
		for(i=1;i<=n;i++)cnt[rk[i]]++;
		for(i=1;i<=n;i++)cnt[i]+=cnt[i-1];
		for(i=n;i;i--)tsa[cnt[rk[i]]--]=sa[i];
		memcpy(sa,tsa,sizeof(sa));
		for(i=1;i<=n;i++){
			if(trk[sa[i]]==trk[sa[i-1]]&&trk[sa[i]+j]==trk[sa[i-1]+j])rk[sa[i]]=rk[sa[i-1]];
			else rk[sa[i]]=rk[sa[i-1]]+1;
		}
		if(rk[sa[n]]==n){
			for(i=1;i<=n;i++)sa[rk[i]]=i;
			break;
		}
	}
	int len=0;
	for(i=1;i<=n;i++){
		if(len)len--;
		while(s[i+len]==s[sa[rk[i]-1]+len])len++;
		height[rk[i]]=len;
	}
	for(i=1;i<=n;i++)st[0][i]=height[i];
	for(i=2;i<=n;i++)lg[i]=lg[i/2]+1;
	for(i=1;i<=lg[n];i++)for(j=1;j+(1<<i)-1<=n;j++)st[i][j]=min(st[i-1][j],st[i-1][j+(1<<i-1)]);;
	for(i=1;i<=n;i++)out_insert(1,1,n,i,sa[i]);
}
void out_query(int k,int l,int r,int x,int y){
	if(l>=x&&r<=y){
		qrlr[++top]=k;
		//提取区间
		return;
	}
	int mid=l+r>>1;
	if(x<=mid)out_query(k<<1,l,mid,x,y);
	if(mid<y)out_query(k<<1|1,mid+1,r,x,y);
}
int out_qlas(int val){
	//根据提取的区间查询后继
	int res=n+1,i;
	for(i=1;i<=top;i++)res=min(res,qlas(qrlr[i],val));
	return res;
}
long long solve1(int l1,int r1,int l2,int r2){
	//暴力部分，树套树写法
	int pos=rk[l2],len=r2-l2+1;
	r1=r1-len+1;
	if(r1<l1)return 0;
	long long ans=0;
	int l=1,r=pos-1,tl=pos,tr=pos;
	while(l<=r){
		int mid=l+r>>1;
		if(qr(mid+1,pos)>=len)r=mid-1,tl=mid;
		else l=mid+1;
	}
	l=pos+1,r=n;
	while(l<=r){
		int mid=l+r>>1;
		if(qr(pos+1,mid)>=len)l=mid+1,tr=mid;
		else r=mid-1;
	}
	top=0;
	out_query(1,1,n,tl,tr);
	int bg=l1-1;
	while(bg<r1){
		int nxt=out_qlas(bg);
		if(nxt>r1)break;
		ans+=val-nxt;
		bg=nxt+len-1;
	}
	return ans;
}
void buildst(int len){
	//构造倍增表
	memset(hh,0,sizeof(hh));
	memset(nxt,0,sizeof(nxt));
	memset(sum,0,sizeof(sum));
	//这里可以直接写树套树，唯一要注意就是倍增表两维顺序要反过来。
	//代码中是哈希写法
	int i,j;
	for(i=1;i<=n/2;i++){
		for(j=i;j<=i+len-1;j++)hh[i]=(hh[i]*28%mod+s[j]-'a'+1)%mod;
		tmp[i]=hh[i];
	}
	sort(tmp+1,tmp+n/2+1);
	int sz=unique(tmp+1,tmp+n/2+1)-tmp-1;
	for(i=1;i<=n/2;i++)hh[i]=lower_bound(tmp+1,tmp+sz+1,hh[i])-tmp;
	vector<int>g[100001];
	//二分桶可以替换为单调队列，码量更低
	for(i=n/2;i;i--){
	//后面的串本就不出现在文本串，没必要处理倍增表
		int l=0,r=g[hh[i]].size()-1,res=-1;
		while(l<=r){
			int mid=l+r>>1;
			if(g[hh[i]][mid]>=i+len)l=mid+1,res=mid;
			else r=mid-1;
		}
		if(res==-1)nxt[0][i]=n+1;//不存在赋个极大值
		else nxt[0][i]=g[hh[i]][res],sum[0][i]=nxt[0][i];
		g[hh[i]].push_back(i);
	}
	for(i=1;i<=lg[n/2];i++){
		for(j=1;j<=n/2;j++){
			nxt[i][j]=nxt[i-1][nxt[i-1][j]];
			sum[i][j]=sum[i-1][j]+sum[i-1][nxt[i-1][j]];
		}
	}
}
int tree[2000000];
//处理区间 sa 最小值。不想再写个 st 表所以就写了个线段树
void build(int k,int l,int r){
	if(l==r){
		tree[k]=sa[l];
		return;
	}
	int mid=l+r>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	tree[k]=min(tree[k<<1],tree[k<<1|1]);
}
int qmin(int k,int l,int r,int x,int y){
	if(l>=x&&r<=y)return tree[k];
	int mid=l+r>>1,res=2147483647;
	if(x<=mid)res=min(res,qmin(k<<1,l,mid,x,y));
	if(mid<y)res=min(res,qmin(k<<1|1,mid+1,r,x,y));
	return res;
}
long long solve2(int l1,int r1,int l2,int r2){
	//苦难部分。
	int pos=rk[l2],len=r2-l2+1;
	r1=r1-len+1;
	//砍掉长度不足的后缀
	if(r1<l1)return 0;
	long long ans=0;
	int l=1,r=pos-1,tl=pos,tr=pos;
	while(l<=r){
		int mid=l+r>>1;
		if(qr(mid+1,pos)>=len)r=mid-1,tl=mid;
		else l=mid+1;
	}
	l=pos+1,r=n;
	while(l<=r){
		int mid=l+r>>1;
		if(qr(pos+1,mid)>=len)l=mid+1,tr=mid;
		else r=mid-1;
	}
	int i,j;
	int minpos=qmin(1,1,n,tl,tr);
	for(i=lg[n];i>=0;i--){
		int x=nxt[i][minpos];
		if(!x||x>=l1)continue;
		minpos=x;
	}
	if(minpos<l1)minpos=nxt[0][minpos];
	pos=minpos;
	for(i=l1;i<=pos&&i<=l1+len-1;i++){
		if(rk[i]>=tl&&rk[i]<=tr){
			minpos=i;
			break;
		}
	}
	//覆盖修正
	if(minpos>r1)return 0;
	ans+=val-minpos;
	for(i=lg[n];i>=0;i--){
		int x=nxt[i][minpos];
		if(!x||x>r1)continue;
		ans+=val*(1<<i)-sum[i][minpos];
		minpos=x;
	}
	return ans;
}
int main(){
	int i,j;
	scanf("%d%lld",&n,&val);
	scanf("%s",s+1);
	s[n+1]='{';
	scanf("%s",s+n+2);
	sbuild();
	build(1,1,n);
	scanf("%d",&m);
	for(i=1;i<=m;i++){
		int l1,r1,l2,r2;
		scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
		q[i].l1=l1;q[i].l2=l2;q[i].r1=r1;q[i].r2=r2;
		q[i].id=i;q[i].len=r2-l2+1;
		if(r2-l2>=51)q[i].ans=solve1(l1,r1,l2+n/2+1,r2+n/2+1);
	}
	sort(q+1,q+m+1);
	for(i=1;i<=m;i++){
		if(q[i].len>51)break;
		if(q[i].len!=q[i-1].len)buildst(q[i].len);
		q[i].ans=solve2(q[i].l1,q[i].r1,q[i].l2+n/2+1,q[i].r2+n/2+1);
	}
	sort(q+1,q+m+1,cmp);
	for(i=1;i<=m;i++)printf("%lld\n",q[i].ans);
}
```

---

## 作者：myee (赞：1)

### 前言

特殊性质明示正解……

### 思路

设 $X=50,Y=2000$。

考虑对 $P$ 的串长根号分治。

然后进行一个剪花布条的贪心：每次把能覆盖的最小位置覆盖掉。

当 $|P|>Y$ 时，考虑暴力找到每次能匹配的最小位置，就是 SA 上区间查询大于等于某个数的最小数，直接主席树即可维护；由于匹配次数不超过 $\frac nY$，其单次询问复杂度即为 $O(\frac nY\log n)$。

当 $|P|\le X$ 时，注意到原串中每一个长度对应的串均不超过 $O(n)$ 个，对那些串可以预处理答案，其余均无解。

或者说，预处理出每个串的“下一个匹配位”所在的位置，则该结构构成森林，直接把询问离线下来 dfs 一遍森林，同时树上差分，对末位二分即可得解（不知道为啥大家都写的倍增，明明离线下来多好写）。

构建树的过程可以做字符串哈希，哈希表维护找父亲，预处理复杂度 $O(nX)$，单组询问 $O(\log n)$。

对 $X<|P|\le Y$，由于询问保证均匀随机，考虑用第一种算法，单次期望复杂度为

$$
O(\frac{\log n}{Y-X}\int_X^Y\frac nx\operatorname{d}x)=O(\frac{\ln Y-\ln X}{Y-X}n\log n)
$$

微调一下阈值，总复杂度较难描述，称为 $O(\text{能过})$ 好了。

如果本题不保证特殊性质，该做法的复杂度即为 $O(n\sqrt{q\log n})$。

### Code

以下为核心代码，跑得很快。

```cpp
struct Seg{
    Seg*L,*R;uint len,v;
    Seg(){}
    Seg(uint n):L(NULL),R(NULL),len(n),v(-1u){
        if(n>1)L=new Seg(n>>1),R=new Seg(n-(n>>1));
    }
    uint find(uint l,uint r){
        if(l>=r)return-1;
        if(!l&&r==len)return v;
        if(l<(len>>1))
            if(r<=(len>>1))return L->find(l,r);
            else return std::min(L->find(l,len>>1),R->find(0,r-(len>>1)));
        else return R->find(l-(len>>1),r-(len>>1));
    }
    Seg*chg(uint p,uint v){
        Seg*ans=new Seg();*ans=*this;if(len==1){ans->v=v;return ans;}
        if(p<(len>>1))ans->L=L->chg(p,v);else ans->R=R->chg(p-(len>>1),v);
        ans->v=std::min(ans->L->v,ans->R->v);
        return ans;
    }
};
struct Seg2{
    Seg2*L,*R;uint len,v;
    Seg2(uint*A,uint n):L(NULL),R(NULL),len(n),v(*A){
        if(n>1)L=new Seg2(A,n>>1),R=new Seg2(A+(n>>1),n-(n>>1)),v=std::min(L->v,R->v);
    }
    uint findl(uint r,uint w){
        if(!r||v>=w)return-1;
        if(len==1)return 0;
        if(r<=(len>>1))return L->findl(r,w);
        uint ans=R->findl(r-(len>>1),w);if(~ans)return ans+(len>>1);
        return L->findl(len>>1,w);
    }
    uint findr(uint l,uint w){
        if(l==len||v>=w)return len;
        if(len==1)return 0;
        if(l>=(len>>1))return R->findr(l-(len>>1),w)+(len>>1);
        uint ans=L->findr(l,w);if(ans!=(len>>1))return ans;
        return R->findr(0,w)+(len>>1);
    }
};
chr C[200005];uint SA[200005],Rank[200005],H[200005];
voi build(uint n){
    for(uint i=0;i<n;i++)SA[i]=i;
    std::sort(SA,SA+n,[&](uint a,uint b){return C[a]<C[b];});
    for(uint i=0;i<n;i++)Rank[SA[i]]=i&&C[SA[i]]==C[SA[i-1]]?Rank[SA[i-1]]:i;
    for(uint len=1;len<n;len<<=1){
        static uint Cnt[200005],A[200005];
        Cnt[0]=len;
        for(uint i=1;i<n;i++)Cnt[i]=0;
        for(uint i=len;i<n;i++)Cnt[Rank[i]]++;
        for(uint i=1;i<n;i++)Cnt[i]+=Cnt[i-1];
        for(uint i=len;i<n;i++)A[--Cnt[Rank[i]]]=i-len;
        for(uint i=0;i<len;i++)A[i]=n-len+i;
        for(uint i=0;i<n;i++)Cnt[i]=0;
        for(uint i=0;i<n;i++)Cnt[Rank[i]]++;
        for(uint i=1;i<n;i++)Cnt[i]+=Cnt[i-1];
        for(uint i=n-1;~i;i--)SA[--Cnt[Rank[A[i]]]]=A[i];
        for(uint i=0;i<n;i++)
            A[SA[i]]=i&&Rank[SA[i]]==Rank[SA[i-1]]&&(SA[i]+len<n?Rank[SA[i]+len]:-1u)==
                        (SA[i-1]+len<n?Rank[SA[i-1]+len]:-1u)?A[SA[i-1]]:i;
        for(uint i=0;i<n;i++)Rank[i]=A[i];
    }
    for(uint i=0;i<n;i++)SA[Rank[i]]=i;
    for(uint i=0,j=0;i<n;i++){
        if(j)j--;
        if(Rank[i])while(C[i+j]==C[SA[Rank[i]-1]+j])j++;
        H[Rank[i]]=j;
    }
}
const uint B=50;
uint L[100005],R[100005],S[100005],T[100005],tp;
ullt Ans[100005],Val[100005];
std::vector<uint>Q[B+5],Get[100005],Son[100005];
Seg*Sg[100005];
const ullt Mod=1004535809,g=3,ginv=334845270;
ullt Hash[255],PreSum[100005],Pow[100005],W[100005];
voi dfs(uint p){
    T[tp++]=p,W[tp]=W[tp-1]+Val[p];
    for(auto q:Get[p]){
        uint l=0,r=tp;
        while(l<r){
            uint mid=(l+r)>>1;
            if(T[mid]<R[q])r=mid;else l=mid+1;
        }
        Ans[q]=W[tp]-W[l];
    }
    for(auto s:Son[p])dfs(s);
    tp--;
}
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    // freopen("QAQ.out","w",stdout);
#endif
    uint n,q;scanf("%u%u",&n,&q);for(uint i=0;i<n;i++)Val[i]=q-i-1;
    scanf("%s%s",C,C+n+1),C[n]='$',build(n<<1|1),scanf("%u",&q);
    // puts(C);
    // for(uint i=0;i<=n*2;i++)printf("%2u%c",SA[i]+1," \n"[i==n*2]);
    // for(uint i=0;i<=n*2;i++)printf("%2u%c",Rank[i]+1," \n"[i==n*2]);
    // for(uint i=0;i<=n*2;i++)printf("%2u%c",H[i]," \n"[i==n*2]);
    H[n<<1|1]=0;Seg2 Sg2(H,(n+1)<<1);Sg[n]=new Seg(n<<1|1);
    for(uint i=n-1;~i;i--)Sg[i]=Sg[i+1]->chg(Rank[i],i);
    for(uint i=0;i<q;i++){
        scanf("%u%u%u%u",L+i,R+i,S+i,T+i),L[i]--,T[i]-=--S[i];
        uint l=Sg2.findl(Rank[S[i]+n+1]+1,T[i]),r=Sg2.findr(Rank[S[i]+n+1]+1,T[i]);
        R[i]=R[i]-L[i]>=T[i]?R[i]-T[i]+1:L[i];
        L[i]=Sg[L[i]]->find(l,r);
        if(L[i]>=R[i])continue;
        if(T[i]<=B)Q[T[i]].push_back(i);
        else while(L[i]<R[i])
            Ans[i]+=Val[L[i]],L[i]=L[i]+T[i]<=n?Sg[L[i]+T[i]]->find(l,r):R[i];
    }
    std::mt19937_64 rng(114514);for(uint i='a';i<='z';i++)Hash[i]=rng()%Mod;
    Pow[0]=1;
    for(uint i=0;i<n;i++)Pow[i+1]=Pow[i]*g%Mod;
    for(uint i=0;i<n;i++)PreSum[i+1]=(PreSum[i]+Pow[i+1]*Hash[(uint)C[i]])%Mod;
    for(uint i=0;i<n;i++)Pow[i+1]=Pow[i]*ginv%Mod;
    for(uint i=1;i<=B;i++)if(Q[i].size()){
        for(uint j=0;i+j<=n;j++)W[j]=(PreSum[i+j]+Mod-PreSum[j])*Pow[j]%Mod;
        std::unordered_map<ullt,uint>M;
        for(uint j=n-i;~j;j--){
            if(i+j<=n-i)M[W[i+j]]=i+j;
            Get[j].clear(),Son[j].clear();
            if(~(S[j]=M.count(W[j])?M[W[j]]:-1u))Son[S[j]].push_back(j);
        }
        for(auto q:Q[i])Get[L[q]].push_back(q);
        for(uint j=n-i;~j;j--)if(!~S[j])dfs(j);
    }
    for(uint i=0;i<q;i++)printf("%llu\n",Ans[i]);
    return 0;
}
```





---

## 作者：关怀他人 (赞：1)

### [HAOI2018]字串覆盖
#### Solution
首先一个显然的贪心是我们选尽量前面的匹配，匹配过后再寻找下一个位置，这样依次找下去。

然后看到数据范围，不难想到进行数据分治，记$len=r-l+1$，对于 $len\geq 2000$ 和 $len \leq 50$ 有两种不同的做法。

+ 做法$1$：当$len\geq 2000$时，对$S$和$T$建广义 SAM，用线段树合并维护每个节点的 endpos 集合。查询的时候先倍增找到广义 SAM 中$B[l...r]$对应的节点，找到$A(s+len,t]$中第一个与$B[l,r]$匹配的点，这个可以通过在线段树上二分实现，然后继续找下一个即可。显然最多只会匹配$\frac{(t-s+1)}{2000}$次，这样的复杂度是$\mathcal O(\frac{n\log n}{2000})$

+ 做法$2$：当$len\leq 50$时，由于可能的匹配次数很多，考虑倍增预处理。对每一个长度处理出每一个末尾位置的后$2^j$个匹配串的位置及贡献，但是由于空间开不下，对询问离线然后按长度递增处理即可。询问时通过线段树找到第一个出现位置然后利用预处理的倍增表向后跳即可，预处理的复杂度是$\mathcal O(50n\log n)$，单次查询的复杂度为$\mathcal O(\log n)$。

而对于$50< len< 2000$的询问，由于最多只有$11000$个且随机分布，所以使用做法$1$即可。

#### Code
```cpp
const int INF = 0x3f3f3f3f;
const ll llINF = 1e18;
const int MAXN = 2e5 + 5;
const int S = 50;

int n,K,Q;

struct SegmentTree{
    static constexpr int MAXM = MAXN * 40;
    int tot;
    int ls[MAXM],rs[MAXM],sum[MAXM];

    void modify(int &k,int l,int r,int x){
        if(!k) k = ++tot; sum[k] += 1;
        if(l == r) return;
        int mid = (l + r) >> 1;
        if(x <= mid) modify(ls[k],l,mid,x);
        else modify(rs[k],mid + 1,r,x);
    }

    int query(int k,int l,int r,int ql,int qr){
        if(!k) return 0; if(l == r) return l;
        int mid = (l + r) >> 1, x = 0;
        if(ql <= mid) x = query(ls[k],l,mid,ql,qr); if(x) return x;
        if(qr > mid) x = query(rs[k],mid + 1,r,ql,qr); return x;
    }

    int merge(int x,int y,int l,int r){
        if(!x || !y) return x | y;
        int k = ++tot, mid = (l + r) >> 1;
        ls[k] = merge(ls[x],ls[y],l,mid);
        rs[k] = merge(rs[x],rs[y],mid + 1,r);
        sum[k] = sum[ls[k]] + sum[rs[k]]; return k;
    }
} sgt;

struct SAM{
    static constexpr int MAXM = MAXN << 1;
    int tot,last,n,m;
    int fa[MAXM],len[MAXM],son[MAXM][26],f[MAXM][20],dep[MAXM],pos[MAXM];
    int lg[MAXM],rt[MAXM],sta[MAXN][20],stb[MAXN][20];
    vector<int> G[MAXM];

    SAM() {last = tot = 1;}

    void extend(int c){
        static int p,q,np,nq; p = last; 
        if(son[p][c]){
            q = son[p][c];
            if(len[q] == len[p] + 1) {last = q; return;}
            nq = ++tot; len[nq] = len[p] + 1;
            memcpy(son[nq],son[q],sizeof(son[nq]));
            fa[nq] = fa[q]; fa[q] = nq;
            for(;p && son[p][c] == q;p = fa[p]) son[p][c] = nq;
            last = nq; return;
        }
        np = last = ++tot; len[np] = len[p] + 1;
        for(;p && !son[p][c];p = fa[p]) son[p][c] = np;
        if(!p) {fa[np] = 1; return;}
        q = son[p][c];
        if(len[q] == len[p] + 1) {fa[np] = q; return;}
        nq = ++tot; memcpy(son[nq],son[q],sizeof(son[nq]));
        len[nq] = len[p] + 1; fa[nq] = fa[q]; fa[q] = fa[np] = nq;
        for(;p && son[p][c] == q;p = fa[p]) son[p][c] = nq;
    }

    void dfs(int u){
        dep[u] = dep[fa[u]] + 1; f[u][0] = fa[u];
        for(int i = 1;i <= lg[dep[u]];i++)
            f[u][i] = f[f[u][i - 1]][i - 1];
        for(int v : G[u])
            dfs(v), rt[u] = sgt.merge(rt[u],rt[v],1,m);
    }

    void build(char *s,char *t){
        n = strlen(s + 1); m = n << 1;
        for(int i = 1;i <= n;i++) extend(s[i] - 'a'), pos[i] = last; last = 1;
        for(int i = 1;i <= n;i++) extend(t[i] - 'a'), pos[i + n] = last;
        for(int i = 1, p = 1;i <= n;i++)
            p = son[p][s[i] - 'a'], sgt.modify(rt[p],1,m,i);
        for(int i = 1, p = 1;i <= n;i++)
            p = son[p][t[i] - 'a'], sgt.modify(rt[p],1,m,i + n);
        for(int i = 2;i <= tot;i++) lg[i] = lg[i >> 1] + 1;
        for(int i = 2;i <= tot;i++) G[fa[i]].push_back(i); dfs(1);
    }

    int jump(int l,int r){
        int u = pos[r];
        for(int i = lg[dep[u]];i >= 0;i--)
            if(len[f[u][i]] >= r - l + 1) u = f[u][i];
        return u;
    }

    void initquery(int L){
        memset(sta,0,sizeof(sta)); memset(stb,0,sizeof(stb));
        for(int i = L;i <= n;i++){
            int p = jump(i - L + 1,i);
            if(i + L <= n) sta[i][0] = sgt.query(rt[p],1,m,i + L,n);
            stb[i][0] = i - L + 1;
        }
        for(int i = n;i >= L;i--){
        	for(int j = 1;sta[i][j - 1];j++){
                sta[i][j] = sta[sta[i][j - 1]][j - 1];
                stb[i][j] = stb[i][j - 1] + stb[sta[i][j - 1]][j - 1];
            }
        }
    }

    ll query1(int s,int t,int l,int r){
        int L = r - l + 1;
        if(s + L - 1 > t) return 0;
        int p = sgt.query(rt[jump(l,r)],1,m,s + L - 1,t);
        if(!p || p - L + 1 >= K) return 0;
        int cnt = 1; ll sum = 0;
        for(int i = lg[(n - p + 1) / L];i >= 0;i--)
            if(sta[p][i] && sta[p][i] <= t && (sta[p][i] - L + 1) <= K)
                sum += stb[p][i], p = sta[p][i], cnt += (1 << i);
        return (ll)cnt * K - (sum + p - L + 1);
    }

    ll query2(int s,int t,int l,int r){
        int p = jump(l,r), L = r - l + 1;
        int x = s + L - 1; ll sum = 0;
        while(x <= t && (x = sgt.query(rt[p],1,m,x,t))){
            int d = K - (x - L + 1);
            if(d < 0) break;
            x += L; sum += d;
        }
        return sum;
    }
} sam;

char s[MAXN],t[MAXN];
ll ans[MAXN];

struct Query{
    int s,t,l,r,id;
};

vector<Query> qry,vec[55];

int main(){
    scanf("%d%d%s%s%d",&n,&K,s + 1,t + 1,&Q); sam.build(s,t);
    for(int i = 1,s,t,l,r;i <= Q;i++){
        scanf("%d%d%d%d",&s,&t,&l,&r);
        if(r - l + 1 <= S) vec[r - l + 1].push_back((Query){s,t,l + n,r + n,i});
        else qry.push_back((Query){s,t,l + n,r + n,i});
	}
    sort(qry.begin(),qry.end(),[&](const Query &x,const Query &y) {return x.r - x.l < y.r - y.l;});
    for(int i = 1;i <= S;i++){
        if(!(int)vec[i].size()) continue;
        sam.initquery(i);
        for(auto p : vec[i])
            ans[p.id] = sam.query1(p.s,p.t,p.l,p.r);
    }
    for(auto p : qry) ans[p.id] = sam.query2(p.s,p.t,p.l,p.r);
    for(int i = 1;i <= Q;i++) printf("%lld\n",ans[i]);
    return 0;
}
```

---


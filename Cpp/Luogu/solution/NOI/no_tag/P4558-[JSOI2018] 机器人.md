# [JSOI2018] 机器人

## 题目描述

九条可怜是一个懒懒的女孩子。因为懒得扫地，九条可怜买了一架扫地机器人。

九条可怜的家可以抽象成一个 $n \times m$ 的网格，坐标从 $(1,1)$ 到 $(n,m)$ 。每一天晚上，可怜都会在 $(1,1)$ 处启动扫地机器人。在启动了之后，扫地机器人会按照设定好的路径开始行动，当再一次回到 $(1,1)$ 后便会停止。

因为一些技术原因，扫地机器人只能向右（列编号加一）或者向下（行编号加一）走。为了让扫地机器人能够顺利的回到 $(1,1)$ ，可怜在家中安装了一些通道，使得：

1.    如果机器人目前在 $(i,m)$ ，那么向右走一步会到 $(i,1)$ 。
2.    如果机器人目前在 $(n,i)$ ，那么向下走一步回到 $(1,i)$ 。

可怜希望，在启动了机器人之后，在机器人回到 $(1,1)$ 前，它可以经过每一个格子**恰好**一次。这样既可以把家里给打扫干净，也不会花太多时间。经过简单的计算，可怜很快就得到了所有不同的方案（两个方案是不同的当且仅当他们经过格子的顺序不同）。于是可怜把所有的方案都输入到了扫地机器人里。

这一天可怜购置了一些新的家具，放好家具之后，家里便多了一些扫地机器人无法通过的障碍，于是在所有之前准备的方案中，扫地机器人都会撞上某一个障碍而停止工作。

对于一个方案 $S$，可怜定义 $f(S)$ 为在这个方案中，扫地机器人在撞上障碍之前，经过了多少个格子。现在可怜想要对所有不同的方案，计算 $f(S)$ 的和。


## 说明/提示

**样例 1 解释**

$n=2,m=4$ 时，一共有两种合法的方案：

![0](https://i.loli.net/2018/05/05/5aed14bde4548.png)

在第一种方案中,机器人在撞上障碍 $(1,3)$ 之前，一共经过了 $4$ 个格子。

在第二种方案中,机器人在撞上障碍 $(2,1)$ 之前，一共经过了 $1$ 个格子。

因此第二组测试数据的答案为 $1+4=5$ 。

**数据范围**

测试数据 1 $(20\%)$: $n,m\le 4$ 。

测试数据 2 $(30\%)$: $n,m\le 50$ ，且除了 $(1,1)$ 外所有格子都是障碍。

测试数据 3 $(50\%)$: $n,m\le 50$ 。

对于所有测试数据，$T\le 10;n,m\ge 1$ 。

## 样例 #1

### 输入

```
2
2 4
0111
1111
2 4
0010
1000```

### 输出

```
2
5```

# 题解

## 作者：shadowice1984 (赞：16)

吉爷爷题真是做一道不会一道……

趁我还没忘记这题赶紧写一波题解

__________________

### 前置芝士:一个冷静的脑子

嗯做计数题最重要的就是推性质推性质还有推性质

## 本体题解

首先我们看到这个机器人居然可以遍历整个网格(也就是走出了一个哈密顿回路)就知道这题必然有高论,所以先让我们坐下来推几个结论再说

### 结论1:属于同一副对角线的两个格子方向必然相同

这里的副对角线指的是下面这张图里数字相同的区域，你会发现属于同一副对角线的元素不一定相邻

![](https://cdn.luogu.com.cn/upload/pic/47526.png)

但是由于我们机器人的走法是循环的，因此如果我们把这个矩阵复制几份拼在一起你就发现同一副对角线的元素相邻了

![](https://cdn.luogu.com.cn/upload/pic/47528.png)

那么这是为什么呢?

我们考虑这样一种情况

![](https://cdn.luogu.com.cn/upload/pic/47530.png)

如果出现了同一副对角线格子方向不同的情况，那么就会出现图中绿色打格子无法被走到的情况，就算绿色的格子是最上角的格子，那么这意味着我们没法回到原点和题意也是不符合的

有了这个结论我们可以推出更强的结论来

### 结论2:机器人的动作一定是循环的并且循环节为$gcd(n,m)$

我们发现一件事情，由于一个点左下和右下的元素属于同一对角线，那么我们无论怎么走都会走到同一个对角线上，即使我们穿过边界从$n$到1或者从$m$到1也是如此，同一个的对角线上机器人的行为相同因此我们机器人的动作自然就是循环的

那么我们动作的循环节自然就是不循环的副对角线的数目了，看上去应该是$max(n,m)$不过我们发现其实是$gcd(n,m)$

证明的话就是把这个矩阵复制几份拼在一起，如果循环节不是$gcd(n,m)$那么在两个矩形的交界出会出现副对角线颜色不同的情况，而循环节是$gcd(n,m)$的时候相当于一堆正方形拼在一起自然不会出现问题

### 结论3:一个行动方案合法当且仅当以下条件成立

假设我们的循环节长度是d,d步中有dx步是向下走,dy步向右走

$$1.gcd(dx,n)=1$$

$$2.gcd(dy,m)=1$$

$$3.gcd(dx,d)=1$$

必要性还是比较显然的,不然根据裴蜀定理我们知道有些坐标永远不可能被表示出来

至于充分性？为啥这样一定有解啊？

~~我也不知道，nb一点的读者可以自行证明之后告诉我这个菜鸡~~

________________

## dp

好了有了以上三个结论我们现在正式开始做题

那么我们的思路非常暴力，就是枚举之后然后大力dp

为了避开烦人的边界情况(也就是撞上墙之后从另一边绕回来)，我们把矩阵复制3份分别拼在左下角和右上角和右下角，这样我们就避开了分类讨论问题

接下来我们枚举所有合法方案的dx值，显然$dx+dy=d$所以确定了dx之后dy也唯一确定了

现在我们希望计算所有循环节内走了$(dx,dy)$步的方案的$f(S)$之和

好了看起来我们还是没法做，怎么办呢？

我们接着枚举,我们枚举撞车的点坐标和撞车时已经走过了几个循环节

假设我们在$(x,y)$这个坐标撞车并且在第$tim$个循环节才撞车

那么我们需要明确一点的是无论我们内部的方案是什么样子的，假设我们在这个循环节开始前位于$(x,y)$那么在d步行动之后我们必然位于$(x+dx,y+dy)$这个点上，并且我们经过的点也只能位于$(x,y),(x+dx,y+dy)$这个矩形中间.

注意这里由于我们把题目中的矩阵额外复制了3份然后把这4个矩阵拼在了一起所以不存在边界问题

那么我们恰好在第$tim$轮在$ax,ay$撞车当且仅当我们前tim轮走过的路径都没有撞车,并且前$tim-1$轮从$ax,ay$走到$x+dx,y+dy$的时候都没有撞车

为了解决这个限制问题我们可以把前$tim$轮走过的矩形区域叠在一起做dp,这样我们只需要设一个$dp(i,j)$表示从1,1走到i,j中间不经过1的方案数就可以了

我们还要解决前$tim-1$轮的问题，我们把前$tim-1$轮走过的矩形区域叠在一起做dp,设一个$fdp(i,j)$表示从$i,j$走到$(dx+1,dy+1)$中间不经过任何1的方案数

假设我们在第tim轮开始时从$(sx,sy)$这个位置出发,那么我们在$sx+a,sy+b$撞车的方案数就是

$$(dp(a-1,b)+dp(a,b-1))fdp(a,b)$$

当然我们首先保证这个位置是1

意思就是在叠加矩形意义下我们前tim轮走到$a,b$的路径都没有撞车，前$tim-1$轮我们走的完整的路径也没有撞车，这样我们就恰好在$sx+a,sy+b$撞车了

这样我们暴力统计贡献就能算出答案了

复杂度算出来应该是$O(Tn^4)$但是没有一个n是满的所以不知道除了多少的常数……总之跑的飞快

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=110;typedef long long ll;const ll mod=998244353;
struct mar
{
    int mp[N][N];
    inline int* operator [](const int & x){return mp[x];}
}mp,bas[2];char mde[N][N];
ll dp[N][N];ll fdp[N][N];ll dx;ll dy;ll ans;int n;int m;
inline void solve(mar& p,mar& q,const int& sx,const int& sy,int rd)//两个简单dp 
{
    for(int i=0;i<=dx;i++)
        for(int j=0;j<=dy;j++)p[1+i][1+j]=q[1+i][1+j]|mp[sx+i][sy+j];
    for(int i=1;i<=dx+1;i++)for(int j=1;j<=dy+1;j++)dp[i][j]=0;
    for(int i=1;i<=dx+1;i++)for(int j=1;j<=dy+1;j++)fdp[i][j]=0;
    if(p[1][1]==0)
    {
        dp[1][1]=1;ll v;
        for(int i=1;i<=dx+1;i++)
            for(int j=1;j<=dy+1;j++)
                v=dp[i][j],(dp[i][j+1]+=(!p[i][j+1])*v)%=mod,(dp[i+1][j]+=(!p[i+1][j])*v)%=mod;
    }
    if(q[dx+1][dy+1]==0)
    {
        fdp[dx+1][dy+1]=1;ll v;
        for(int i=dx+1;i>=1;i--)
            for(int j=dy+1;j>=1;j--)
                v=fdp[i][j],(fdp[i][j-1]+=(!q[i][j-1])*v)%=mod,(fdp[i-1][j]+=(!q[i-1][j])*v)%=mod;
    }
    for(int i=1;i<=dx+1;i++)
        for(int j=1;j<=dy+1;j++)
        {
            ll fv;if(p[i][j]==0)continue;
            if(i==1&&j==1)fv=1;else if(i==1)fv=dp[i][j-1];else if(j==1)fv=dp[i-1][j];
            else fv=(dp[i][j-1]+dp[i-1][j])%mod;
            (ans+=(ll)(rd+i+j-2)*fv%mod*fdp[i][j])%=mod;
        }
}
inline int gcd(int a,int b){if(a<b)swap(a,b);while(b){int c=a%b;a=b;b=c;}return a;}
inline void solve()
{
    scanf("%d%d",&n,&m);for(int i=1;i<=n;i++)scanf("%s",mde[i]+1);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)mp[i][j]=(mde[i][j]=='1');
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)mp[i+n][j]=mp[i][j];
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)mp[i][j+m]=mp[i][j];
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)mp[i+n][j+m]=mp[i][j];int d=gcd(n,m);
    for(dx=0,dy=d;dx<=d;dx++,dy--)//枚举dx和dy 
    {
    	if(dx==0&&n!=1)continue;if(dy==0&&m!=1)continue;
        if(gcd(dx,d)!=1||gcd(dx,n)!=1||gcd(dy,m)!=1)continue;
        for(int i=0;i<=dx+1;i++)for(int j=0;j<=dy+1;j++)bas[0][i][j]=0;
        for(int i=0;i<=dx+1;i++)for(int j=0;j<=dy+1;j++)bas[1][i][j]=0;
        for(int rd=0,p=1,q=0;rd<n*m;rd+=d,p^=1,q^=1)
            solve(bas[p],bas[q],(rd*dx/d)%n+1,(rd*dy/d)%m+1,rd);	
    }printf("%lld\n",ans);ans=0;
}
int main(){int T;scanf("%d",&T);for(int z=1;z<=T;z++)solve();return 0;}//拜拜程序~ 
```























---

## 作者：轮回之终末 (赞：5)

感谢xyx大神言传身教，让我弄懂了这一题。

#### 一道神仙题，现场只拿了20分

先考虑第2个部分分，即全是障碍的情况，也就是求解可行的方案数。

若n=m时，考虑如下性质：

### 假设点A指向了其下方的点B，那么其右方的点C的前驱就只能是其上方的点。

### 所以，矩阵的每一条副对角线（左下-右上）上的元素方向应当相同

## 因此每种方案实际上是一个循环的向右/向下的操作序列

~~我们现在已经有O（2^n）次方算法了~~

考虑n=m时，我们枚举了一种方案后，~~打表~~分析后发现：
#### 假设有x个向下的操作，N−x个向右操作，当且仅当x⊥N，操作序列合法。

试着~~口胡~~证明一下：

n=m时

1+k*x % n

1+k*(n-x) % n

如果不互质，那有些位置永远不会碰到。

必要性证明完毕，充分性 ~~毛想想~~ 很显然。

因此答案为 


$\sum_{i=0}^n$[i⊥N]∗$C_n^i$


考虑N≠M,令d=gcd(n,m)

可以发现每个d∗d的正方形内部的方向排布是一样的，感性证明比较显然，大家画画图就知道了。

答案为

$\sum_{i=0}^d$[i⊥d]∗[i⊥n]∗[(d-i)⊥m]∗$C_d^i$

考虑100%数据：

## 考虑转化问题：碰到障碍前走的路程=碰到每个障碍时走的路程的最小值。

那么问题就变成了如何计算碰到每个障碍时走的路程的最小值。

考虑dp[i][j][k]表示在（i，j）上，碰到障碍时走的路程的最小值为k的方案数。

由于每个d∗d的正方形内部的方向排布是一样的，枚举有i个向下的操作，j=d-i个向右操作，首先要满足上文中的限制:[i⊥d]∗[i⊥n]∗[j⊥m]。

若不考虑障碍，从(x,y)出发，经过d步后，我们必然会走到(i+x,j+y)。

也就是说路线被固定住了！

所以只要在[1~i+1][1~j+1]中dp就好了。

记格子(x,y)(1≤x≤i+1,1≤y≤j+1)的权值为走到有障碍的格子(x+k∗i,y+k∗j)(k∈N)的最小步数。

dp[i][j][k]的转移很显然，向dp[i+1][j][min(k,(i+1,j)的权值)]和dp[i][j+1][min(k,(i,j+1)的权值)]转移。

具体的可以看代码，觉得比我讲的清晰多了……

```cpp
// user:halahen
#include<bits/stdc++.h>
using namespace std;
const int maxn=55;
const int mod=998244353;
int i,j,k;
char c=' ';
int n,m;
int opt,T;
int mp[maxn][maxn],f[maxn][maxn];
int dp[maxn][maxn][maxn*maxn];
int x,y,d,tx,ty,w,ans;
int read(){
    int tot=0,fh=1;
    char c=getchar();
    while ((c<'0')||(c>'9')){ if(c=='-') fh=-1; c=getchar(); }
    while ((c>='0')&&(c<='9')){ tot=tot*10+c-'0'; c=getchar(); }
    return tot*fh;
}
int gcd(int x,int y){
    if (y==0) return x;
    return gcd(y,x%y);
}
int main(){
    T=read();
    for (opt=1;opt<=T;opt++){
        n=read(); m=read(); d=gcd(n,m); ans=0;
        if ((n==1)&&(m==1)){ printf("1\n"); continue; }
        for (i=1;i<=n;i++){
            while ((c<'0')||(c>'9')){ c=getchar(); }
            for (j=1;j<=m;j++){
                mp[i][j]=c-'0';
                c=getchar();
            }
        }
        for (x=0;x<=d;x++){
            y=d-x;
            if (((x==0)&&(n==1))||((y==0)&&(m==1))||((gcd(x,d)==1)&&(gcd(y,d)==1)&&(gcd(x,n)==1)&&(gcd(y,m)==1))){
                for (i=1;i<=x+1;i++){
                    for (j=1;j<=y+1;j++){
                        tx=i; ty=j; w=(i-1)+(j-1);
                        f[i][j]=n*m;
                        for (k=1;k<=n*m/d;k++){
                            if (mp[tx][ty]==1){
                                f[i][j]=min(f[i][j],w);
                                break;
                            }
                            tx=tx+x; ty=ty+y; w=w+d;
                            if (tx>n) tx=tx-n;
                            if (ty>m) ty=ty-m; 
                        }
                    }
                }
                memset(dp,0,sizeof(dp)); dp[1][1][f[1][1]]=1;
                for (i=1;i<=x+1;i++){
                    for (j=1;j<=y+1;j++){
                        for (k=1;k<=n*m;k++){
                            if (i+1<=x+1) dp[i+1][j][min(k,f[i+1][j])]=(dp[i+1][j][min(k,f[i+1][j])]+dp[i][j][k])%mod;
                            if (j+1<=y+1) dp[i][j+1][min(k,f[i][j+1])]=(dp[i][j+1][min(k,f[i][j+1])]+dp[i][j][k])%mod;
                        }
                    }
                }
                for (i=1;i<=n*m;i++){
                    ans=(ans+(long long)dp[x+1][y+1][i]*i)%mod;
                }
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：Leianha (赞：4)

## [博客阅读](https://www.cnblogs.com/wljss/p/12185155.html)

结论题&DP

发现题目限制和条件较多，让我们先坐下来数一数条件，推一推结论。

机器人行走要求：

1.机器人只能向右或向下。

2.机器人走到边界后会回到行/列坐标为1的地方。

3.要求机器人走过每一个点且仅走一次。

4.是先规定好了机器人的每一种行走路线，再放的障碍物。

> #### 1.从左下到右上直线上机器人的行走方向相同。

这是最基本的一条结论，我们观察一下对于 $(i+1,j)$ 和 $(i,j+1)$ 这两个点，倘若在这两个点走的方向不一样，那么 $(i+1,j+1)$ 这个点要么走不到，要么会走两遍，都不符合题意。

> #### 2.机器人行动的循环节是 $gcd(n,m)$ 。

我们从左下向右上画出每一条对角线（注意还有右下角），一共有$n+m$条，将方向一样的用一种颜色涂上，一种颜色会涂 $\displaystyle \frac{lcm(n+m,n)}{n}$ 条线，一共就需要 $\displaystyle \frac {n+m} { \frac{lcm(n+m,n)}{n}}=gcd(n,m)$ 种颜色，也就是循环节的长度。

> #### 3.设在一个循环节里机器人向下走了 $dx$ 步，向右走了 $dy$ 步，机器人的行走方案合法当且仅当 $gcd(dx,n)=1,gcd(dy,m)=1,gcd(dx,dy)=1$ 。

前两个用裴蜀定理很好解释，对于第三个，我们设 $d=gcd(n,m)$ ,那么 $dx+dy=d$ ,因为 $gcd(dx,n)=1$ ,所以 $gcd(dx,d)=1$ ,所以 $gcd(dx,dy)=1$ 。 
因为 $n$ 比较小，暴力枚举一下 $dx$ 就行啦。

DP设 $val[x][y]$ 为按照 $dx,dy$ 走，最早什么时候撞上障碍物，含义就是只要经过了 $(x,y)$ ，那么在第 $val[x][y]$ 步一定会撞上障碍物。
设 $f[i][j][k]$ 为从起点到 $(i,j)$ 的所有路径中，路上最小的 $val$ 是 $k$ 的方案数，因为我们确定了前 $d$ 步整张地图的行走方案就确定下来了，所以我们只用DP到 $(dx+1,dy+1)$ (注意我们的起点是 $(1,1)$ ).最后求一下方案数*val之和就行了。
```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int T, n, m, d, ans, x, y;
const int N = 52, mod = 998244353;
int val[N][N], f[N][N][N * N];
char mp[N][N];
int work(int x) {return x >= mod ? x - mod : x;}
int GCD(int x, int y) {return y ? GCD(y, x % y) : x;}
int DP(int dx, int dy) 
{
	for (int i = 1; i <= dx + 1; ++i)
		for (int j = 1; j <= dy + 1; ++j)
			for (int k = 1; k <= n * m; ++k)f[i][j][k] = 0;
	f[1][1][val[1][1]] = 1;
	for (int i = 1; i <= dx + 1; ++i)
		for (int j = 1; j <= dy + 1; ++j)
			for (int k = 1; k <= n * m; ++k) 
			{
				if (!f[i][j][k])continue;
				int &t1 = f[i + 1][j][min(k, val[i + 1][j])], &t2 = f[i][j + 1][min(k, val[i][j + 1])];
				if (i <= dx)t1 = work(t1 + f[i][j][k]);
				if (j <= dy)t2 = work(t2 + f[i][j][k]);
			}
	int res = 0;
	for (int i = 1; i <= n * m; ++i)res = work(res + (LL)i * f[dx + 1][dy + 1][i] % mod);
	return res;
}
int main() 
{
	cin >> T;
	while (T--) 
	{
		scanf("%d%d", &n, &m); d = GCD(n, m); ans = 0;
		for (int i = 1; i <= n; ++i)scanf("%s", mp[i] + 1);
		for (int dx = 0, dy; dx <= d; ++dx) 
		{
			dy = d - dx;
			if (GCD(dx, dy) != 1 || GCD(dx, n) != 1 || GCD(dy, m) != 1)continue;
			for (int x = 1; x <= dx + 1; ++x)
				for (int y = 1; y <= dy + 1; ++y) 
				{
					int tx = x, ty = y, w = x + y - 2; val[x][y] = n * m;
					do 
					{
						if (mp[tx][ty] == '1') {val[x][y] = w; break;}
						tx += dx, ty += dy, w += d;
						if (tx > n)tx -= n; if (ty > m)ty -= m;
					} while (tx != x || ty != y);
				}
			ans = work(ans + DP(dx, dy));
		}
		cout << ans << "\n";
	}
	return 0;
}
```

---

## 作者：totorato (赞：4)

补充一下证明：

我们先分析“可以遍历所有格子”的方案长什么样。

- **性质1：** 首先，两个格子的方向不可能朝向同一个格子，这样会导致机器人不能遍历全部的格子。

由此可以导出两个推论：

- **推论1：** 矩阵的每一条“左下右上”对角线上，格子的方向相同。

- **推论2：** 如果从上到下给矩阵的每条左上右下对角线编号，则第$i$条与第$i+gcd(n,m)$条上，格子的方向相同。

为什么呢？**推论1**很好理解，因为它是通过**性质1**直接得出的。

**推论2**可以这样看：由于跨越下边界和右边界又会回到上边界和左边界，我们不难现象出，机器人实际上是在一个无穷大的平面内行走。如果从$(1,1)$出发，行走了$nm$步，每一步都不经过重复的点，意味着“可以遍历所有格子”。这个无穷大的平面由原始矩阵赋值无穷多次连接而成。而这个无穷矩阵显然也得满足**推论1**，因此，通过简单的数学推导得到了**推论2**.

由**推论2**进一步得到，机器人的运动方式是每$\gcd(n,m)$步为一个周期的。

令$d=\gcd(n,m)$，$\Delta x$为最开始的$d$步中，有几步向下走，$\Delta y$类似。那么，由于经过了$nm$步我们需要回到原点，并且中途不经过重复的点，我们可以列出下列式子：

纵坐标第一次回到$1$的时间是：$d*lcm(\Delta x,n)/\Delta(x)$，横坐标第一次回到$1$的时间是$d*lcm(\Delta y, m)/\Delta y$，因此它们同时回到$1$的时间是：
$$
d*lcm(\frac{lcm(\Delta x,n)}{\Delta x},\frac{lcm(\Delta y, m)}{\Delta y})
$$
又因为，第一次回到$1$的时间必须是$nm$，所以列出方程：
$$
lcm(\frac{lcm(\Delta x,n)}{\Delta x},\frac{lcm(\Delta y, m)}{\Delta y})=\frac{nm}{gcd(n,m)}
$$
将这个方程化简可以得到：
$$
gcd(\frac{\Delta x}{gcd(\Delta x, n)},\frac{\Delta y}{gcd(\Delta y, m)})gcd(\Delta x, n)gcd(\Delta y, m) = 1
$$
由此我们发现：

$$
gcd(\Delta x,n)=1
$$
$$
gcd(\Delta y,m)=1
$$
$$
gcd(\Delta x,\Delta y)=1
$$

我们把这个叫做**推论三**：

- **推论三：** 任何一个合法的方案都满足$gcd(\Delta x,n)=gcd(\Delta y,m)=gcd(\Delta x,\Delta y)=1$，且$\Delta x+\Delta y=gcd(n,m)$

既然得到了所有合法方案的通式，我们就可以尝试解决原问题了。

---

## 作者：black_trees (赞：3)

为了区分 $\gcd$ 和坐标，本文的坐标统一使用 $\{i, j\}$ 表示。

这个能有哈密顿回路感觉是很神奇的，不妨从这个地方开始考虑。

注意到我们每次只能向下向右走，考虑什么时候会走不到，可以得出一个结论：

> 1. 同一条右斜对角线上的格子方向一定一致，否则他们夹着的右下那个格子一定怎么走都走不到。

然后我们注意到这个格子的任意一行任意一列都是头尾相接的，常见套路就是展开考虑，相当于是一堆矩阵接在一起。

这个矩阵也应该满足上面的第一个结论，换句话说我们如果处在这个无限矩阵的某一个位置，他接下来的行动方向序列和与它处在同一个对角线上的元素是一致的。

一直往后走，那显然会再次走到这条对角线对应的对角线上，那么行动就会出现循环节，可以发现循环节长度就是走出之后行动序列不相同的对角线数目。

因为这个无限矩阵是多个原始矩阵拼接的，所以他一定要能重合，不管是 $x$ 还是 $y$ 方向，换句话说这个循环节在两个方向上也都是循环节。

那么得出结论：

> 2. 循环节等于 $(n, m)$。

然后看起来就没啥可以找的了，这个题是要求有障碍的前提下的一些信息，经典套路是考虑先算没有障碍的合法方案长啥样子。

注意到我们最后需要走回 $\{1, 1\}$，然后这个 bot 走的方式又是带有循环节的，我们考虑找找性质。

现在我们要求不重复经过，走 $nm$ 步恰好回到 $\{1, 1\}$。

这里 $x,y$ 分别考虑，不然耦合在一起太麻烦了，现在考虑每个循环节里面的情况。

假设这 $(n, m)$ 步里面有 $s$ 步是往下走的，那么我们第一次回到 $x = 1$ 的步数就应该是 $\dfrac{(n,m)\times[s,n]}{s}$。

$y$ 方向同理设为 $t$，耦合起来就是 $(n,m) \times [\dfrac{[s,n]}{s},\dfrac{[t,n]}{t}]$。

然后因为要恰好 $nm$ 步，所以可以列出方程：

$(n,m) \times [\dfrac{[s,n]}{s}\dfrac{[t,n]}{t}] = nm$

把 $[a,b]$ 都写成 $\dfrac{ab}{(a,b)}$，然后化一下，可以得到三个约束：

$$
\begin{cases}
(s,n) &= 1 \\
(t,m) &= 1 \\
(s,t) &= 1 \\
\end{cases}
$$

然后显然还需要有一个 $s + t = (n,m)$ 的限制。

这就是合法方案的性质，我们考虑对它做计数。

要明确的一点是，当我们知道一对合法的 $(s,t)$ 之后，我们并不知道它内部是怎么走的，我们只知道在无障碍的前提下，从 $\{x, y\}$ 出发，一定会走到 $\{x + s, y + t\}$。

然而本题的要求实际上需要我们知道怎么走的，因为要计算撞到障碍的步数。

于是就有一个很牛逼的想法，我们现在不考虑它在哪里撞到了障碍物，我们只关心它撞到障碍的时候走了多少步，那么我们就可以对这类方案进行统一的统计。

不妨考虑，障碍仍然不存在，但是我们记录一下每个方案第一次经过一个有障碍的格子的步数。

枚举 $s, t$ （实际上只需要枚举 $s$，因为 $t = (n, m) - s$），设 $dp(i, j, k)$ 表示能走到 $\{i, j\}$ 的所有方案中，有多少种方案第一次经过一个障碍所花的步数为 $k$。

考虑转移，显然转移形如 $dp(i + 1, j, \dots) \gets dp(i, j, \dots)$ 和 $dp(i, j + 1, \dots) \gets dp(i, j, \dots)$。

但是最后一维应当如何转移？

我们考察 $\{i, j + 1\}, \{i + 1, j\}$ 这两个点，向后走最快要多少步经过一个障碍即可，记这个值为 $mi(i, j + 1), mi(i + 1, j)$，那么最后一维的转移就形如 $\min(k, mi(i, j + 1)) \gets k, \min(k, mi(i + 1, j)) \gets k$。

答案为 $\sum\limits_{i = 1}^{nm}dp(s + 1, t + 1, i) \times i$。

于是我们就以单次询问 $O(n^4)$ 的复杂度解决了这个问题，注意到我们 dp 实际上只是在左上角为 $\{1, 1\}$，右下角为 $\{s + 1, t + 1\}$ 的矩阵中 dp，因为 $s, t$ 的级别和 $(n, m)$ 相当，所以这个是跑不满 $O(n^4)$ 的（听说 $n^5$ 复杂度都能过）。



---

## 作者：Para (赞：1)

首先必须想到从必要条件出发。由于从 $(1,1)$ 出发回到 $(1,1)$ 的路径中，每一个点恰好被经过一次，所图中边数与点数相同，所以每一个点的入度为 $1$。再直观一点呢？对于从左下到右上的对角线，每一条对角线上格子的指向相同。

再将边界的情况考虑进去，可以得到横纵坐标之和 $\bmod \gcd(n,m)$ 相同的格子指向相同（视为一个等价类）。

现在我们来考察从一个等价类到相同等价类的过程，其中共走了 $d = \gcd(n,m)$ 步，设两个 $n, m$ 方向分别走了 $x,y(x+y=d)$ 步。

从 $(1,1)$ 出发再回到 $(1,1)$ 经过了若干个这样的过程。$n$ 方向重新回到 $1$ 至少需要 $\frac {\operatorname{lcm}(n,x)} {x}$ 这样的过程，$m$ 方向同理至少 $\frac {\operatorname{lcm}(m,y)} {y}$ 步。从 $(1,1)$ 再返回至少 $\operatorname{lcm}(\frac {\operatorname{lcm}(n,x)} {x},\frac {\operatorname{lcm}(m,y)} {y})$ 这样的过程。

要保证每个格子恰好经过一次，则恰好经过 $nm$ 个格子，汇总如下：
$$
\operatorname{lcm}(\frac {\operatorname{lcm}(n,x)} {x},\frac {\operatorname{lcm}(m,y)} {y})d = nm
$$
将 $\operatorname{lcm}(a,b)$ 展开为 $\frac {ab} {\gcd(a,b)}$ 化简可得：
$$
\gcd(\frac {n} {\gcd(x,n)},\frac {m} {\gcd(y,m)}) \gcd(x,n)\gcd(y,m)=\gcd(n,m)
$$

$$
\gcd(n \gcd(y,m),m  \gcd(x,n))=\gcd(n,m)
$$

首先 
$$
\gcd(\gcd(y,m),\gcd(x,n))=1
$$
即
$$
\gcd(x,y)=1
$$
又由于
$$
\gcd(\frac {n} {\gcd(n,m)}, \gcd(x,n))=1
$$
其中最右侧 $n$ 的限制被严格包含，不考虑。$n$ 中因子 $\gcd(n,m)$ 对 $x$ 完全不产生影响，也可以忽略，那么可以同理得到
$$
\gcd(x,n)=1,\gcd(y,m)=1
$$
这两个是充要条件。上面的 $\gcd(x,y) = 1$ 被这两个条件严格包含，所以下面只需对这两个条件来计数。

计数较为简单。可以先枚举 $x$，这样就知道了我们遍历与 $(1, 1)$ 相同等价类格子的顺序，再枚举最终停止是在哪个过程中。设 $f_{i,j}$ 表示考虑到 $(x_0 + i, y_0 + j)$ 的位置的方案数，$x_0,y_0$ 表示与 $(1, 1)$ 相同等价类格子。转移时只需要提前预处理出 $g_{i,j,t}$ 表示从 $(x_0 + i, y_0 + j)$ 开始到 $(x_0 + x, y_0 + y)$，有多少方案可以不会在 $\le t$ 的过程中爆炸。时间复杂度 $O(Tn^4)$。

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define mp make_pair
#define inf (ll)1e9
#define pii pair <ll, ll>
const ll mod = 998244353;
//char buf[1 << 21], *p1 = buf, *p2 = buf;
//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 18, stdin), p1 == p2) ? EOF : *p1++)
#define fr first
#define se second
inline ll read () {
	ll x = 0, f = 1;
	char ch = getchar ();
	while (ch < '0' || ch > '9') f = ((ch == '-') ? -1 : f), ch = getchar ();
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar ();
	return x * f;
}
inline void write (ll x) {
	if (x < 0) x = -x, putchar ('-');
	if (x >= 10) write (x / 10);
	putchar (x % 10 + '0');
}
inline void Add(ll &x, ll y) {
	x += y;
	if(x >= mod) x -= mod;
}
ll n, m, d;
char ch[105][105];

ll tot;
pii p[5005];
ll f[55][55], g[55][55][55];
inline ll solve(ll fx, ll fy) { 
	tot = 0;
	ll nx = 1, ny = 1;
	while(1) {
		p[++tot] = mp(nx, ny);
		ll nxtx = nx + fx, nxty = ny + fy;
		if(nxtx > n) nxtx -= n;
		if(nxty > m) nxty -= m;
		if(nxtx == 1 && nxty == 1) break; 
		nx = nxtx, ny = nxty;
	}
	memset(g, 0, sizeof g);
	for(ll t = 0; t < tot; t++) {
		g[fx][fy][t] = 1;
		for(ll i = fx; i >= 0; i--) {
			for(ll j = fy; j >= 0; j--) {
				ll fl = 1;
				for(ll k = 1; k <= t; k++) fl &= (ch[p[k].fr+i][p[k].se+j] == '0');
				if(!fl) continue;
				if(i != fx) Add(g[i][j][t], g[i+1][j][t]);
				if(j != fy) Add(g[i][j][t], g[i][j+1][t]);
			}
		}
	}
	ll Ans = 0;
	for(ll t = 1; t <= tot; t++) {
		memset(f, 0, sizeof f);
		f[0][0] = 1;
		for(ll i = 1; i < t; i++) if(ch[p[i].fr][p[i].se] == '1') f[0][0] = 0;
		if(ch[p[t].fr][p[t].se] == '1') {
			Add(Ans, f[0][0] * ((t - 1) * d) * g[0][0][t-1] % mod);
			f[0][0] = 0;
		}
		for(ll i = 0; i <= fx; i++) {
			for(ll j = 0; j <= fy; j++) {
				if(!f[i][j] || i + j + 1 == fx + fy) continue;
				// i + 1
				if(i != fx) {
					ll val = f[i][j];
					for(ll k = 1; k < t; k++) if(ch[p[k].fr+i+1][p[k].se+j] == '1') val = 0;
					if(ch[p[t].fr+i+1][p[t].se+j] == '1') {
						Add(Ans, val * ((t - 1) * d + i + j + 1) % mod * g[i+1][j][t-1] % mod);
						val = 0;
					}
					Add(f[i+1][j], val);	
				}
				// j + 1
				if(j != fy) {
					ll val = f[i][j];
					for(ll k = 1; k < t; k++) if(ch[p[k].fr+i][p[k].se+j+1] == '1') val = 0;
					if(ch[p[t].fr+i][p[t].se+j+1] == '1') {
						Add(Ans, val * ((t - 1) * d + i + j + 1) % mod * g[i][j+1][t-1] % mod);
						val = 0;
					}
					Add(f[i][j+1], val);	
				}
			}
		}
	}
	return Ans;
}
int main () {
//	freopen (".in", "r", stdin);
//	freopen (".out", "w", stdout);
	ll T = read();
	while(T--) {
		n = read(), m = read();
		for(ll i = 1; i <= n; i++) scanf("%s", ch[i] + 1);
		for(ll i = 1; i <= n; i++) for(ll j = 1; j <= m; j++) ch[i+n][j] = ch[i][j+m] = ch[i+n][j+m] = ch[i][j];
		d = __gcd(n, m);
		ll Ans = 0;
		for(ll fx = 0; fx <= d; fx++) {
			ll fy = d - fx;
			if(__gcd(n, fx) != 1 || __gcd(m, fy) != 1) continue;
			Add(Ans, solve(fx, fy));
		}
		write(Ans), putchar('\n');
	}
	return 0;
}
/*
*/
```



---


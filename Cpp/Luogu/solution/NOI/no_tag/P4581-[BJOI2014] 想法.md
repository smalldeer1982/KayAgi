# [BJOI2014] 想法

## 题目描述

小强和阿米巴是好朋友。小强要出一套题目。

他的题目以涉及面广（偏）、考察深入（怪）、思维强度大（难）著称。他为了出题，一共攒了 $M$ 个本质不同的想法，每个想法形成了一个题目。不过，他觉得拿这些题目去考察选手会把比赛搞的太过变态，所以，想请阿米巴来帮忙调整一下他的题目。

阿米巴指出，为了让一场考试的题目的考察点尽量全面，有一个通用的做法叫做“组合”。如果把两个题目 $A$ 和 $B$ 组合在一起，那么组合而成的题目涉及到的想法的集合就是 $A$ 涉及到的想法的集合和 $B$ 涉及到的想法的集合的并。并且，题目是可以反复组合的。

例如，小强现在有三个想法 $1,2,3$，分别对应了题目 $P_1,P_2,P_3$：

- 小强把 $P_1$ 和 $P_2$ 组合得到 $P_4$。$P_4$ 涉及的想法的集合是 $\{1,2\}$。
- 小强把 $P_2$ 和 $P_3$ 组合得到 $P_5$。$P_5$ 涉及的想法的集合是 $\{2,3\}$。
- 小强把 $P_4$ 和 $P_5$ 组合得到 $P_6$。$P_6$ 涉及的想法的集合是 $\{1,2,3\}$。

现在，小强告诉你每个题目都是如何组合而来的。你要回答的就是，每个题目涉及的想法的集合有多大。

不过，这个问题是很难的。于是，你只需要能够以比较高的概率回答的比较准确即可。

## 说明/提示

对于 $100\%$ 的数据，$1 \le M \le 10^5$，$1 \le N \le 10^6$。   
如果其中你有 $95\%$ 以上的行的答案和正确答案的误差不超过 $25\%$，那么你就可以得到分数。   
所谓误差不超过 $25\%$，即如果正确答案是 $X$，那么你的答案在 $[0.8X,1.25X]$ 这个闭区间内就算误差不超过 $25\%$。

## 样例 #1

### 输入

```
6 3
1 2
2 3
4 5```

### 输出

```
2
2
3```

# 题解

## 作者：UnyieldingTrilobite (赞：12)

非常美丽的一道题，奇诡且简洁。

我们考虑给每个想法都赋上一个权值，然后通过简单 dp 计算出每个题目所能包含到的想法的权值的最小值（也称作这个题目的权值）。如此一来，我们发现，假设一个题目包含的想法总数是 $x$，那么最后它的权值就是这 $x$ 个想法的权值的最小值。注意到，如果想法的权值是在某一个区间上均匀随机的，那么根据期望的基本知识，这个题目最后权值的期望将会落在这个区间最左的 $x+1$ 分点上。如此一来，我们根据大数定律，以频率代替概率计算出一个大致的期望，观察它的位置即可得到 $x$。由于有足足四分之一的容错，口胡一下还是问题不大的。

代码巨大好写。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
using namespace views;
constexpr int T = 150;
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  int n, m;
  cin >> n >> m;
  vector<tuple<int, int, int, int>> es(n);
  for (auto& [w, u, v, s] : es | drop(m)) cin >> u >> v, --u, --v, s = 0;
  default_random_engine rnd(random_device{}());
  for (int t = T; t; --t) {
    for (auto& [w, u, v, s] : es | take(m)) w = rnd();
    for (auto& [w, u, v, s] : es | drop(m))
      s += w = min(get<0>(es[u]), get<0>(es[v]));
  }
  for (auto& [w, u, v, s] : es | drop(m))
    cout << fixed << setprecision(0) << rnd.max() * T * 1. / s - 1 << '\n';
  return cout << flush, 0;
}
```

---

## 作者：Union_of_Britain (赞：8)

说句闲话：题解都是清一色的实数 $\min/\max$？对于求集合基数这样听起来就应用范围极广的问题，没有理由相信计算机科学家们没有给出更好的算法。

Hyperloglog 算法可以在较低的精度误差求集合基数，插入、查询、合并复杂度均为 $O(1)$。

此算法过程可以参见[维基百科的对应界面](https://en.wikipedia.org/wiki/HyperLogLog)，其关键是依靠数字的最大二进制前导零数量来估计基数。分为若干个桶再求调和平均数可以改善这个估计。

本题我们取 $m=8$ 就可以达到较高的精度（大约 $95\%$）。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
uint32_t murmurhash3(uint32_t key, uint32_t seed = 0) {
    key ^= key >> 16;
    key *= 0x85ebca6b;
    key ^= key >> 13;
    key *= 0xc2b2ae35;
    key ^= key >> 16;
    return key;
}
class HyperLogLog {
public:
    explicit HyperLogLog(uint8_t precision=8)
        : m(1 << precision), alphaMM(m * m * 0.7213 / (1.0 + 1.079 / m)), registers(m, 0) {}

    void add(int value) {
        uint32_t hash = murmurhash3(value);
        uint32_t index = hash >> (32 - p);
        uint32_t w = (hash << p) | (1 << (p - 1));
        registers[index] = std::max(registers[index], rho(w));
    }

    double estimate() const {
        double Z = 0.0;
        for (uint32_t reg : registers) {
            Z += 1.0 / (1 << reg);
        }
        Z = 1.0 / Z;
        double E = alphaMM * Z;

        // Small range correction
        if (E <= 2.5 * m) {
            uint32_t V = std::count(registers.begin(), registers.end(), 0);
            if (V > 0) {
                E = m * std::log(static_cast<double>(m) / V);
            }
        }
        // Large range correction
        else if (E > (1.0 / 30.0) * (1LL << 32)) {
            E = -(1LL << 32) * std::log(1.0 - E / (1LL << 32));
        }

        return E;
    }

    uint32_t m;
    double alphaMM;
    std::vector<uint8_t> registers;
    static const uint8_t p = 8; 

    static uint8_t rho(uint32_t x) {
        uint8_t r = 1;
        while ((x & 0x80000000) == 0) {
            x <<= 1;
            r++;
        }
        return r;
    }
}H[maxn];
int n,m;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)H[i].add(i);
	for(int i=m+1;i<=n;i++){
		int x,y;cin>>x>>y;
		for(int j=0;j<H[x].registers.size();j++)H[i].registers[j]=max(H[x].registers[j],H[y].registers[j]);
		int res=H[i].estimate();
		cout<<res<<"\n";
	}
	return 0;
}
```

---

## 作者：徐致远 (赞：6)

[本蒟蒻的Blog(戳这儿呀QwQ)](https://www.chnxuzhiyuan.cn/2019/01/24/%E3%80%8CBJOI2014%E3%80%8D%E6%83%B3%E6%B3%95-Solution/)

什么鬼？省选也出这种玄学随机算法题？

首先这题一看就很不可解。

所以上随机算法（~~人家题面都告诉你了QwQ~~）。

对于一个节点，将所用能走到它的叶子节点都存下来是不现实的，所以我们只存$k$个。并且我们要先为每个叶子节点i随机一个权值$W_i$，满足$W_i \in [1,RANDMAX]$。对于每个非叶子节点，我们需要存下所有能走到个节点的叶子节点的权值的前$k$小。设这个节点的答案为$ans$，第$k$小权值为$F_k$根据期望可得

$\frac{F_k}{RANDMAX}=\frac{k}{ans}$

故有

$ans=\frac{k*RANDMAX}{F_k}$

令$k=50$，多为叶子节点随机几套权值求平均值，吸个氧，~~放个大悲咒，选个好种子，~~你就能AC了。

### 代码

这是真的玄学QwQ

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
typedef long long LL;
const int maxn=1000005,k=50;
int n,m,son[maxn][2],w[maxn],num[maxn],f[maxn][55];LL ans[maxn];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline void Merge(int s1,int s2,int now)         //从两个儿子节点合并过来
{
	register int i=1,j=1;num[now]=k;
	for(register int p=1;p<=k;p++)
	{
		while(f[s1][i]==f[now][p-1]&&i<=num[s1]) i++;  //注意去重
		while(f[s2][j]==f[now][p-1]&&j<=num[s2]) j++;
		if(i>num[s1]&&j>num[s2]){num[now]=p-1;break;}
		if(i<=num[s1]&&(f[s1][i]<f[s2][j]||j>num[s2])){f[now][p]=f[s1][i];i++;}
		else if(j<=num[s2]){f[now][p]=f[s2][j];j++;}
	}
}
int main()
{
	srand(20050429);
	n=read();m=read();
	for(register int i=m+1;i<=n;i++){son[i][0]=read();son[i][1]=read();}
	for(int r=1;r<=4;r++)
	{
		for(register int i=1;i<=n;i++){w[i]=rand();while(!w[i])w[i]=rand();}
		for(register int i=1;i<=m;i++){f[i][1]=w[i];num[i]=1;}
		for(register int i=m+1;i<=n;i++)
		{
			Merge(son[i][0],son[i][1],i);
			if(num[i]<k) ans[i]=num[i]*4;          //如果还没到k个就不用根据期望计算了
			else ans[i]+=(LL)k*RAND_MAX/f[i][k];
		}
	}
	for(int i=m+1;i<=n;i++) printf("%lld\n",ans[i]/4);
	return 0;
}
```



---

## 作者：FlashHu (赞：6)

~~萝卜大毒瘤~~

题意可以简化成这样：给一个DAG，求每个点能够从多少个入度为$0$的点到达（记为$k$）。

一个随机做法：给每个入度为$0$的点随机一个权值，在DAG上求出每个点能够返回到的入度为$0$的点的最小权值，那么这个权值的期望是$\frac{\text{随机值域}}{k+1}$。多选几套随机权值（蒟蒻选了一百次），跑出来的平均值即可输出。

实在是太玄学了。
```cpp
#include<bits/stdc++.h>
#define LL unsigned long long
#define RG register
#define R RG int
#define G if(++ip==ie)if(fread(ip=buf,1,SZ,stdin))
#define F(S) if(freopen(S".in","r",stdin));if(freopen(S".out","w",stdout))
using namespace std;
const int SZ=1<<18,N=1e6+1,S=50,T=2;
char buf[SZ],*ie=buf+SZ,*ip=ie-1;
inline int in(){
    G;while(*ip<'-')G;
    R x=*ip&15;G;
    while(*ip>'-'){x*=10;x+=*ip&15;G;}
    return x;
}
inline int Min(R x,R y){
    return x<y?x:y;
}
int f[N][S],c[N][2];
double ans[N];
int main(){
    srand(20020307);
    R n=in(),m=in();
    for(R i=m+1;i<=n;++i)
        c[i][0]=in(),c[i][1]=in();
    for(R t=T;t;--t){
        for(R i=1;i<=m;++i)
            for(R j=0;j<S;++j)
                f[i][j]=rand();
        for(R i=m+1;i<=n;++i)
            for(R j=0;j<S;++j)
                ans[i]+=f[i][j]=Min(f[c[i][0]][j],f[c[i][1]][j]);
    }
    for(R i=m+1;i<=n;++i)
        printf("%d\n",(int)(RAND_MAX/ans[i]*S*T-0.5));
    return 0;
}
```

---

## 作者：TernaryTree (赞：4)

这不是我们 ASC42 的 J 吗。

考虑加法为什么不行，因为如果一个点连向 $\{1,2\}$，一个点连向 $\{2,3\}$，这时我们再拉一个点连向这两个点，$2$ 就会被算两次。这就是加法的低劣之处。

那想想什么运算支持被多次计算也不影响结果，用 $\min$ 或 $\max$ 就很对。然后我们有结论：$n$ 个 $[0,1]$ 内的均匀随机实数变量 $x_1,\dots, x_n$，$E(\min_{i=1}^n x_i)=\dfrac{1}{n+1}$。所以我们随若干次，每次给 $[1,m]$ 内的点随机赋权，其余点为出点的权值最小值；计算每个点平均值，每个点能到的点的个数大概就是 $\dfrac{1}{a_i}-1$。时限有 2s 所以随个 $200$ 次都没事。

```cpp
n = read(), m = read();
rep(i, m + 1, n) u[i] = read(), v[i] = read(); 
rep(t, 1, k) {
	rep(i, 1, m) a[i] = (double) randint(0, 1e9) / 1e9;
	rep(i, m + 1, n) a[i] = min(a[u[i]], a[v[i]]);
	rep(i, m + 1, n) s[i] += a[i] / k;
}
rep(i, m + 1, n) write((int) (1.0 / s[i] - 0.5)), pc('\n');
```

---

## 作者：RockyYue (赞：4)

### 题意

有 $n$ 个集合 $S_{1\dots n}$，给出一个正整数 $m$。

- 对于 $i \in [1,m]$，第 $S_i$ 仅包含一个数 $i$。

- 对于 $i\in [m+1,n]$，给出两个数 $x,y$，表示 $S_i=S_x \bigcup S_y$，求 $S_i$ 中元素个数。

其中 $1\le m\le 10^5,m<n\le 10^6$。

如果其中你有 $95\%$ 以上的行的答案和正确答案的误差不超过 $25\%$，那么你就可以得到分数。
所谓误差不超过 $25\%$，即如果正确答案是 $X$，那么你的答案在 $[0.8X,1.25X]$ 这个闭区间内就算误差不超过 $25\%$。

### 解法

> Trick: 利用随机数的均匀分布
>
> - 当我们要判断一个值域 $[l,r]$ 中一共有多少个数时，若这些数均匀分布，只需要记录其中一个数 $a_k$ 和其位置 $k$，则总个数的期望为 $\frac{(r-l+1)k}{a_k-l}+1$。
> - 对于一类计数问题，我们可以利用随机数均匀分布的特点，对于每个点随机赋权再维护可以走到的权值第 $k$ 小的点的权值，这样我们就不必维护所有可以到达的点，可以选取尽量大的 $k$ 使得答案更接近。

看到这个判分标准就可以想到随机化计数。我们将集合抽象成点，对于 $S_i=S_x \bigcup S_y$ 的情况，表示为点 $x,y$ 均为点 $i$ 子节点（便于理解，并不严谨）。

于是我们对于每个叶子节点随机赋权，其点权范围在 $[1,RAND\_MAX]$ 内，则我们需要选取一个合适的 $k$，对于每个非叶子节点 $u$ 只记录其子树内叶子节点中权值前 $k$ 小的点的权值的集合 $a_u$（至于为什么不是恰好第 $k$ 小，是为了方便每个节点从子节点处合并信息，这里类似于归并排序）。

则根据我们的结论，在合并信息后，$|S_i|$ 期望在 $\frac{ RAND\_MAX\cdot k}{a_{i,k}-1}+1$。

均衡考虑时间代价和正确性，我们选定 $k=50$，可以通过。

---

## 作者：SafariMo (赞：2)

[BJOI2014 想法](https://loj.ac/p/2229)

思考问题：对于 $n$ 个均匀随机分布变量 $a_1,a_2,a_3\dots a_n \in[1,V]$，从小到大排序，则 $a_1$ 的期望大小为 $\dfrac{V}{n+1}$。

如果我们知道了最小值和 $a_1$ 的平均值，则 $n=\dfrac{V}{a_1}-1$。

于是，我们对每个点多次随机赋权，且维护该点能到达的点的最小值。

套用上面的做法即可。

[Submission](https://loj.ac/s/2113230)

---

## 作者：strcmp (赞：1)

省选出这种题？？？真长脑子吧。

显然这题是不存在严格正确的做法的，否则今年的图灵奖有了。

然后你考虑用一种合适的策略估计集合的大小。

加法显然不合适，直接加去不了重，而重复的东西太多了肯定完蛋。

然后你考虑有什么东西是满足 $x \cdot x = x$ 的。位与和位或满足，但我们发现它们要么迅速趋近于全 $0$ 要么迅速趋近于全 $1$ 完全搞不了。

然后注意到 $\min$ 和 $\max$ 是满足条件的，$\min$ 显然好看一点于是去考虑它。

我们有结论：对于 $n$ 个 $[0,\,1]$ 的均匀随机实数变量 $x_i$，$E(\min x ) = \frac{1}{n + 1}$。证明可以考虑积分这里不赘述。

根据这个东西，启发我们对 $1 \dots n$ 随机权值，然后每次令新增的集合的权值是合并的两个集合的 $\min$。最后按权值来估计这些集合的大小。

只做一次显然正确率惨不忍睹，但是我们做一次只需要 $\Theta(n + m)$ 的复杂度，时限宽裕做上一百多次正确率就很高了。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for(int i = a; i <= b; i++)
#define pb push_back
using namespace std;
using ld = long double;
typedef long long int ll;
using pii = pair<int, int>;
constexpr int maxn = 1e6 + 10, D = 150, mod = 1e9 + 7;
const ll inf = 1145141919810520131L;
unsigned n, m, f[maxn], u[maxn], v[maxn]; ld ans[maxn];
int main() {
	scanf("%u%u", &n, &m); mt19937 rd(114514);
	for (int i = m + 1; i <= n; i++) scanf("%u%u", &u[i], &v[i]);
	for (int o = 1; o <= D; o++) {
		for (int i = 1; i <= m; i++) f[i] = rd();
		for (int i = m + 1; i <= n; i++) ans[i] += (f[i] = min(f[u[i]], f[v[i]]));
	}
	for (int i = m + 1; i <= n; i++) printf("%d\n", (int)(4294967295 / ans[i] * D - 0.5));
	return 0;
}
```

---


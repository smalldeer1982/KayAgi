# 重返现世

## 题目描述

为了打开返回现世的大门，Yopilla 需要制作开启大门的钥匙。Yopilla 所在的迷失大陆有 $n$ 种原料，只需要集齐任意 $k$ 种，就可以开始制作。

Yopilla 来到了迷失大陆的核心地域。每个单位时间，这片地域就会随机生成一种原料。每种原料被生成的概率是不同的，第 $i$ 种原料被生成的概率是 $\frac{p_i}{m}$ 。如果 Yopilla 没有这种原料，那么就可以进行收集。

Yopilla 急于知道，他收集到任意 $k$ 种原料的期望时间，答案对 $998244353$ 取模。

## 说明/提示

对于 $10 \%$ 的数据，$p_1 = p_2 = ... = p_m$ 。

对于另外 $10 \%$ 的数据，$k = n$ 。

对于 $70 \%$ 的数据，$n \le 100$ 。

对于 $100 \%$ 的数据，$1 \le n \le 1000$ ，$1 \le k \le n,  n - k  \le 10$ ，$1 \le p_i \le m, \sum p = m, 1 \le m \le 10000$ 。

## 样例 #1

### 输入

```
3 3 3
1 1 1
```

### 输出

```
499122182
```

# 题解

## 作者：Sooke (赞：126)

### 前言

的确是一道神仙题……网上都找不到一篇详细的题解，可能是我理解能力太差了吧，硬是瞪了好久才看懂。

为了不让大家思维受阻，这里尽我所能地解释清楚。

------

### 解题思路

首先，您需要认识下面这个式子：

$$\max_k(S) = \sum\limits_{T \subseteq S} (-1)^{|T| - k}\ C_{|T|-1}^{k-1}\min(T)$$

它是 **扩展** $\bold{min-max}$ **容斥** 的根本。其中 $max_k(S)$ 表示集合 $S$ 中的第 $k$ 大元素，$min(T)$ 表示集合 $T$ 中的最小元素，尽管式子看起来及其玄学，但它确实是可以通过构造两个函数然后二项式反演证明的，想了解具体证明过程的读者可以上网自行学习。

有趣的是，上式可以推广到期望，即：

 $$E(\max_k(S)) = \sum\limits_{T \subseteq S} (-1)^{|T| - k}\ C_{|T|-1}^{k-1}E(\min(T))$$

但在这题中，所谓的 $E(\max_k(S))$ 和 $E(\min(T))$ 都是什么玩意儿？连集合都没有，而且哪来的相对大小？

我们可以假象每一种原料都有一个出现的时间，因为它们出现的时间互不相同，所以可以构成一个集合，所谓 $E(\min(T))$ 显然就是 $T$ 包含的原料最早出现的期望时间，$E(\max_k(S))$ 同理。至于相对大小，因为我们求的本来就是期望，相对对我们来说不重要，只要严格遵循上式计算即可。

为什么要用到这个式子呢？原因是直接算 $E(\max_k(S))$ 太难了，而 $E(\min(T))$ ，我们把 $T$ 中、$T$ 外的原料分别看成整体，每次刷到 $T$ 中原料的概率是 $\frac{\sum\limits_{t \in T}p_t}{m}$ ，期望时间自然就是 $\frac{m}{\sum\limits_{t \in T}p_t}$ 。

另外还有一点，题目里给出的 $k$，实际上代表 $E(\min_{k}(S))$，以下令 $k = n + 1 - k$，以简化得到纯正的 $E(\max_{k}(S))$ 。

好了，该扯的都扯完了，下面我们进入本题最核心的环节——设计 $\bold{dp}$ 。

考虑到 $m$ 和转化后的 $k$ 特别小，很快就能~~（猜）~~想出分别给它们一维。完整地，$f_{k,\,i,\,j}$ 表示确定式子中 $k$ 的值，当前是第 $i$ 种原料，$\sum\limits_{t\in T} p_t = j$ 时的 $\sum\limits_{T \subseteq S} (-1)^{|T| - k}\ C_{|T|-1}^{k-1}$ 的值。

状态很复杂对吧，其实本质上就是把 $k$ 和 $E(\min(T))$ 表示到状态里，给剩下的东西求和，最后再统计状态的贡献。

接下来是转移，很像背包，对于第 $i$ 种原料，如果不选，$f_{k,\,i,\,j} = f_{k,\,i-1,\,j}$，因为没有影响，如果选呢？就有点复杂了。

对于 $i,\,j$ 这两维，必定分别由 $i - 1,\,j - p_i$ 转移而来，但现在主要问题是，如果直接转移，转移后的所有 $|T|$ 都比转移前大 $1$（塞了个 $p_i$ 进去），怎么处理其影响？

幸运的是，$|T|$ 大 $1$，式子里的 $(-1)^{|T|-k}$ 仅仅改了个正负性，而仔细观察 $C_{|T|-1}^{k-1}$，如果 $|T|$ 大 $1$，它可以拆成 $C_{|T|-1}^{k-1} + C_{|T|-1}^{k-2}$（组合数的递推式）！

这就好办多了，拆成两个状态，$C_{|T|-1}^{k-1}$ 的 $k$ 不变，由于 $|T|$ 变了 $1$，所以 $f_{k,\,i-1,\,j-p_i}$ 对 $f_{k,\,i,\,j}$ 有 $-f_{k,\,i-1,\,j-p_i}$ 的贡献。$C_{|T|-1}^{k-2}$ 的 $k$ 小 $1$，$|T|$ 也变了 $1$，负负得正， $f_{k-1,\,i-1,\,j-p_i}$ 对 $f_{k-1,\,i,\,j}$ 有 $f_{k-1,\,i-1,\,j-p_i}$ 的贡献。综上所述，如果选，$f_{k,\,i,\,j} = f_{k-1,\,i-1,\,j-p_i} - f_{k,\,i-1,\,j-p_i}$。真是神仙！

$\mathrm{dp}$ 状态、转移、边界三步走，此时还剩最后一个难关，边界！

如何初始化 $f_{k,\,0,\,0}$ ，使得整个 $\mathrm{dp}$ 滴水不漏呢？全部设 $0$ 显然是不行的，毕竟加加减减也弄不出其他数来，这里有个巧妙的方法，令 $f_{0,\,0,\,0} = 0$，其他 $f_{k,\,0,\,0}=-1$。奇怪的设定，看起来违背状态的定义，实际上是从其他状态反推而来的唯一设定，其可以保证 $|T| = k$ 时的贡献恰好等于 $1\ (0 - (-1) = 1)$，$|T| < k$ 时的贡献恰好等于 $0\ ((-1) - (-1) = 0)$，详见转移式，大家不妨自己去推推看。

最后，枚举 $f_{k,\,n,\,j}$ 中的 $j$，用逆元计算取模意义下的 $\frac{m}{j}$，就可以得出该状态的总贡献啦！

------

### 代码实现

时空复杂度都是 $O(nmk)$，直接开 $f$ 数组是绝对开不下的，由于其转移过程类似背包，可以把 $i$ 这一维压掉。

乍一看代码好短，然而包含的思维量却是遥不可及的。

```cpp
#include <cstdio>
#include <algorithm>

inline int read() {
    char c = getchar(); int x = 0;
    while (c < '0' || c > '9') { c = getchar(); }
    while (c >= '0' && c <= '9') { x = (x << 1) + (x << 3) + (c & 15); c = getchar(); }
    return x;
}

const int maxN = 1005, maxM = 10005, p = 998244353;

inline int add(int x, int y) { x += y; return x >= p ? x - p : x; }
inline int sub(int x, int y) { x -= y; return x < 0 ? x + p : x; }

int n, m, s, w, ans, inv[maxM], f[12][maxM];

int main() {
    n = read(); s = n + 1 - read(); m = read();
    for (int i = (inv[1] = 1) + 1; i <= m; i++) { inv[i] = (long long) inv[p % i] * (p - p / i) % p; }
    for (int i = 1; i <= s; i++) { f[i][0] = -1; }
    for (int i = 1; i <= n; i++) {
        w = read();
        for (int j = m; j >= w; j--) {
            for (int k = s; k; k--) { f[k][j] = add(f[k][j], sub(f[k - 1][j - w], f[k][j - w])); }
        }
    }
    for (int i = 1; i <= m; i++) { ans = (ans + (long long) f[s][i] * inv[i] % p) % p; }
    printf("%lld\n", (long long) ans * m % p);
    return 0;
}
```

---

## 作者：Soulist (赞：38)

首先可以发现题目要求的为：

$$E(max(S)_k)$$

套用拓展$min-max$

得到：

$$E(max(S)_k)=\sum_{T\subseteq S}\dbinom{|T|-1}{k-1}(-1)^{|T|-k}E(min(T))$$

我们知道原来要求的是全集合中出现时间排第$k$的元素，由于变成了正过来看，此时的$k$变成了$n-k+1$，换而言之非常小，只有$(11)$

我们知道一个集合每次操作出现一个属于它的元素的概率为：

$$e(S)=\sum_{i\in S}\dfrac{p_i}{m}$$

于是我们知道期望时间为：

$$\sum_{i=1}^{\infty} e(S)(1-e(S))^{i-1}=\dfrac{1}{e(S)}$$

于是现在我们得到了一个复杂度为$O(2^n)$的做法，暴力枚举子集，对于每个集合求出此式子并计算贡献

~~然后我就不会了....~~

接下来看来需要一点魔法了...

我们来看下这个式子：

$$E(max(S)_k)=\sum_{T\subseteq S}\dbinom{|T|-1}{k-1}(-1)^{|T|-k}E(min(T))$$

考虑一个固定的集合大小$|T|$，其分配的系数相同均为$\dbinom{|T|-1}{k-1}(-1)^{|T|-k}$

则我们只需要求出$\sum_{|T|=x}E(min(T))$

注意到$E(min(T))=\dfrac{1}{e(S)}$于是我们可以给$dp$加一个维度记录$\sum p=e(S)$，这样只需要统计有多少个点满足$\sum p=i,|T|=j$

于是可以得到，不妨记$dp_{i,j,k}$表示考虑到前$i$个数，满足$|T|=j,\sum p=k$的集合数，则可以得到转移：

$$dp_{i,j,k}=dp_{i-1,j,k}+dp_{i-1,j-1,k-p_i}$$

于是这样便可以得到一个复杂度为$O(n^2 m)$的做法了...(代码比较简单就不放了)

于是问题在于如何优化复杂度？

我们发现转移已经是最优了，不能从这里下手于是只能从状态下手

由于$k$这一维度附带了一个$\dfrac{1}{k}$于是肯定是不能省略的，唯一的办法是把记录中的$|T|$给去掉试试

换而言之我们只统计，到第$i$个数，任意放满足$\sum p=k$的数前面安排的系数之和

考虑系数为：

$$\sum \dbinom{|T|-1}{k-1}(-1)^{|T|-k}$$

拆开试试？

$$\sum \dfrac{(|T|-1)!}{(k-1)!(|T|-k)!}(-1)^{|T|-k}$$

好像还是不行...

但是这个时候可以得到转移大致为：

$$dp_{i,j}=dp_{i-1,j}+...$$

这个奇怪的东西应该表示为：

对于$dp_{i-1,j-p_i}$的：

$$\sum \dbinom{|T|-1}{k-1}(-1)^{|T|-k}$$

首先可以注意到所有$|T|\to |T|+1$于是整体需要乘一个$-1$

注意到$|T|\to |T|+1$于是组合数变成了：

$$\dbinom{|T|}{k-1}$$

但是我们知道组合数可以递推所以有：

$$\dbinom{|T|}{k-1}=\dbinom{|T|-1}{k-1}+\dbinom{|T|-1}{k-2}$$

然而真正有趣的是这个式子可以放在一起一起递推，因为考虑计算$dp$时强制放入一个数则等价于$|T|$必然变大$1$，于是我们可以给$dp$增加一个维度$k$来计算$dp$系数

$$dp_{i,j,k}=dp_{i-1,j,k}+(-1)\times dp_{i-1,j-p_i,k}+(-1)^{2}\times dp_{i-1,j-p_i,k-1}$$

即：

$$dp_{i,j,k}=dp_{i-1,j,k}-dp_{i-1,j-p_i,k}+ dp_{i-1,j-p_i,k-1}$$

这个$dp$是真的超级棒！

接下来考虑边界条件，这个好像有点难，因为我们的$dp$是按照转移的需求设计，所以它存在的实际意义(在我看来)也是为了方便转移而存在的$dp$

考虑边界问题，我们知道

$dp_{0,j,k}$的意义应该是：$\sum_{\sum p=j}\dbinom{|T|-1}{k-1}$

于是考虑前面的数，唯一的一个$\sum p=j$是空集，即$\sum p=0$此时有$|T|=0$求的则是：

$$dp_{0,0,k}=\dbinom{-1}{k-1}$$

这个时候我们需要拓宽组合数的意义，你可以认为$\dbinom{-1}{-1}=1$而$\dbinom{x}{y}$在$x<y$的时候$=0$但$x=y$的时候为$1$，(这好像是下降幂定义组合数的那一套)，所以我们的边界应该是$dp_{0,0,0}=1$

当然转移的过程可以滚动数组整体复杂度$O(nmk)$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 1000 + 5 ; 
const int M = 10000 + 5 ; 
const int P = 998244353 ; 
int n, m, t, Ans, inv[M], p[N], dp[14][M] ; 
int fpow( int x, int k ) {
	int ans = 1, base = x ; 
	while( k ) {
		if( k & 1 ) ans = ans * base % P ; 
		base = base * base % P, k >>= 1 ; 
	} return ans ; 
}
signed main()
{
	n = gi(), t = n - gi() + 1, m = gi() ;
	rep( i, 1, n ) p[i] = gi() ; inv[0] = dp[0][0] = 1 ; 
	rep( i, 1, m ) inv[i] = fpow( i, P - 2 ) % P ;
	for( re int i = 1; i <= n; ++ i ) {
		for( re int k = m; k >= p[i]; -- k )
		for( re int j = t; j; -- j )
			dp[j][k] = ( dp[j - 1][k - p[i]] - dp[j][k - p[i]] + dp[j][k] + P ) % P ;
	}
	for( re int k = 0; k <= m; ++ k ) Ans = ( Ans + dp[t][k] * inv[k] % P ) % P ;  
	printf("%lld\n", Ans * m % P ) ;
	return 0 ;
}
```

---

## 作者：p_b_p_b (赞：38)


[$$\large \color{purple} My \; Blog$$](https://www.cnblogs.com/p-b-p-b/p/10350493.html)

-------

## 前置知识

做这题前，您需要认识这个式子：


$$kthmax(S)=\sum_{\varnothing\neq T\subseteq S}{|T|-1\choose k-1} (-1)^{|T|-k} min(T)$$


如果不会可以来[这里](https://www.cnblogs.com/p-b-p-b/p/10350374.html)。

---------

## 题解

题目要求第$k$小。为了方便，以下令$k=n-k+1$，即变为求第$k$大。

很显然，这题是让我们求这个东西：

$$\sum_{T\neq\varnothing}{|T|-1\choose k-1} (-1)^{|T|-k} min(T)$$

然而$n \leq 1000$ 的数据很明显不能暴力枚举每一个$T$。为了优化复杂度，我们考虑一个类似于背包的$DP$。

设$f_{x,j,k}$表示前$x$个元素，满足$\sum p=j$，以$k$为基准的$\sum_T {|T|-1 \choose k-1} (-1)^{|T|-k}$的大小。可能你会奇怪为什么要记录$k$，先往后面看。

考虑转移。显然要根据$T$中是否有$x$这个元素进行分类讨论。

当$T$中没有$x$，直接转移，$f_{x,j,k}=f_{x-1,j,k}$。

当$T$中有$x$时，显然前两维由$f_{x-1,j-v}(v=p_x)$转移而来，有


$$f'_{x,j,k}=\sum_{x\in T} {|T|-1 \choose k-1}(-1)^{|T|-k}$$
$$=\sum_T {|T| \choose k-1} (-1)^{|T|-k+1}\text{//把x丢掉，转为考虑x-1时的T，此时}\sum_p = j-v$$
$$=\sum_T [{|T|-1 \choose k-1}+{|T|-1 \choose k-2}](-1)^{|T|-k+1}$$
$$=\sum_T {|T|-1 \choose k-1}(-1)^{|T|-k}(-1)+\sum_T {|T|-1 \choose (k-1)-1} (-1)^{|T|-(k-1)}$$
$$=f_{x-1,j-v,k-1}-f_{x-1,j-v,k}$$

最终我们得到转移方程：

$$f_{x,j,k}=f_{x-1,j,k}+f_{x-1,j-v,k-1}-f_{x-1,j-v,k}$$

边界条件为$f_{x,0,0}=1$。

发现这东西时空复杂度都是$O(nm(n-k))$，似乎要炸空间，所以还需要把第一维滚掉。

最后统计答案时枚举$\sum p$然后随便搞搞就好啦。

----------

## 代码

```cpp
#include<bits/stdc++.h>
namespace my_std{
    using namespace std;
    #define pii pair<int,int>
    #define fir first
    #define sec second
    #define MP make_pair
    #define rep(i,x,y) for (int i=(x);i<=(y);i++)
    #define drep(i,x,y) for (int i=(x);i>=(y);i--)
    #define go(x) for (int i=head[x];i;i=edge[i].nxt)
    #define sz 10010
    #define mod 998244353
    typedef long long ll;
    template<typename T>
    inline void read(T& t)
    {
        t=0;char f=0,ch=getchar();
        double d=0.1;
        while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
        while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
        if(ch=='.')
        {
            ch=getchar();
            while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();
        }
        t=(f?-t:t);
    }
    template<typename T,typename... Args>
    inline void read(T& t,Args&... args){read(t); read(args...);}
    void file()
    {
        #ifndef ONLINE_JUDGE
        freopen("a.txt","r",stdin);
        #endif
    }
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

ll ksm(ll x,int y)
{
    ll ret=1;
    for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;
    return ret;
}
ll inv(ll x){return ksm(x,mod-2);}

int n,m,K;
int p[sz];
ll dp[2][sz][15];

int main()
{
    file();
    read(n,K,m);K=n-K+1;
    rep(i,1,n) read(p[i]);
    int c=0,cc=1;
    dp[0][0][0]=1;
    rep(i,1,n)
    {
        swap(c,cc);
        rep(j,0,m) rep(k,0,K) dp[c][j][k]=0;
        dp[c][0][0]=1;
        rep(j,1,p[i]-1) rep(k,1,K) dp[c][j][k]=dp[cc][j][k];
        rep(j,p[i],m) 
            rep(k,1,K) 
                dp[c][j][k]=(dp[cc][j][k]+dp[cc][j-p[i]][k-1]-dp[cc][j-p[i]][k]+mod)%mod;
    }
    ll ans=0;
    rep(i,1,m) ans=(ans+dp[c][i][K]*inv(i)%mod*m%mod)%mod;
    cout<<ans;
    return 0;
}
```

---

## 作者：command_block (赞：15)

**题意**：有 $n$ 种物品，第 $i$ 种物品有权重 $p_i$，满足 $\sum_ip_i=m$。

每一轮会随机获得一个物品，获得物品 $i$ 的概率是 $\frac{p_i}{m}$。

求收集到 $k$ 种不同物品所需的期望轮数。

答案对 $998244353$ 取模，$n\leq 1000$，$m\leq 10^4$，$n-k\leq 10$，时限 $\texttt{2s}$。

-----

> upd 2025.2.27：重新排版，改正一处错误。

- **前置知识**：扩展 Min-Max 容斥。

我们设集合 $S$ 为物品集合，物品的权值为第一次出现时间。

那么 $\mathbb E[\min(S)]$ 就是这些物品中有其中一个出现所需的期望时间。

每一轮获得 $S$ 中物品的概率是 $\sum\limits_{i\in S}\frac{p_i}{m}$，期望时间就是$\dfrac{m}{\sum\limits_{i\in S}p_i}$。

记 $U$ 为全集，$\mathbb E[{\rm kth\,min}(U)]$ 就是答案。注意到 $k$ 很大而 $n-k$ 很小，改令 $k$ 为 $n-k+1$，则我们欲求的就是 $\mathbb E[{\rm kth\,max}(U)]$，且 $k\leq 11$。

套用扩展 Min-Max 容斥得：

$$
{\rm Ans}=\sum\limits_{T\in S}(-1)^{|T|-k}\dbinom{|T|-1}{k-1}\mathbb E(\min(T))
$$
直接枚举 $T$ 显然无法承受。注意到 $m\leq 10^4$，考虑和 $m$ 有关的 DP。

------

左到右逐个加入物品，最终的贡献只和 $|T|,\sum_{i\in T}p_i$ 有关，将它们记录到状态中。

令 $f[i][j][s]$ 表示：前 $i$ 个物品，选了 $j$ 个，且 $\sum_{i\in T}p_i=s$ 的方案数。

最后把方案数乘以对应贡献求和，就得到答案。

**转移**：讨论选或不选当前物品

- 选：$f[i][j+1][s+p_i]\gets f[i-1][j][s]$
- 不选：$f[i][j][s]\gets f[i-1][j][s]$

为了节省空间，可以把第一维 $i$ 滚掉。

复杂度 $O(n^2m)$，可以拿到 $70$ 分。

-----

为了减少状态量，尝试把贡献塞到 DP 值中。

选择 $\mathbb E(\min(T))$ 还是 $(-1)^{|T|-k}\binom{|T|-1}{k-1}$ 呢？

应当选择后者，理由如下：

- 前者是某个东西的倒数，相加将会变得十分难以处理。
- 只有后者与 $k$ 相关，而 $k\leq 11$ 显然是本题的突破口。

把后者加入 DP 值，看看会发生什么……

设 $f[i][s]$ 表示考虑了前 $i$ 个物品，$\sum\limits_{i\in T}p_i=s$ 的 $(-1)^{|T|-k}\binom{|T|-1}{k-1}$ 和。

**转移**：考虑选或不选当前物品

- 不选：$f[i][s]\gets f[i-1][s]$

- 选：转移开始不对劲了。

  考虑原先的集合 $T$ 们，全都加入一个元素后贡献变为
  $$
  \sum_{T}(-1)^{|T|-k}\dbinom{|T|-1}{k-1}\to\sum_{T}(-1)^{|T|+1-k}\dbinom{|T|}{k-1}
  $$
  我们没有记录 $|T|$，组合数很难处理。

尝试把组合数拆开，得到
$$
\begin{aligned}
\sum_{T}(-1)^{|T|+1-k}\dbinom{|T|}{k-1}
&=\sum_{T}(-1)^{|T|+1-k}\left[\dbinom{|T|-1}{k-2}+\dbinom{|T|-1}{k-1}\right]\\
&=\sum(-1)^{|T|-(k-1)}\dbinom{|T|-1}{k-2}-\sum(-1)^{|T|-k}\dbinom{|T|-1}{k-1}
\end{aligned}
$$
后面是 $f[i-1][s]$。

前面和 $f$ 很像，唯一的区别是 $k$。因此，我们可以对各个 $k$ 同时进行 DP，这样就能转移了。

-----

设 $f[i][s][k]$ 表示考虑了前 $i$ 个物品，$\sum_{i\in T}p_i=s$，且 $k$ 如所设，$(-1)^{|T|-k}\binom{|T|-1}{k-1}$ 的和。

**转移**：考虑选或不选当前物品

- 不选：$f[i][s][k]\gets f[i-1][s][k]$
- 选：$f[i][s+p_i][k]\gets f[i-1][s][k-1]-f[i-1][s][k]$

为了省空间，仍要把第一维滚掉。

时间复杂度 $O(nmk)$，空间复杂度 $O(mk)$。（注意此处的 $k$ 是原来的 $n-k+1$）

注意有 $p_i=0$ 的情况。

---

## 作者：封禁用户 (赞：13)

拓展 min-max 容斥公式

# 分析

题目现在要求我们求：

$$E(kthmax(S))$$

我们将拓展 min-max 容斥公式摆出来：

$$kthmax(S) = \sum\limits_{\varnothing\ne T \subseteq S} \begin{pmatrix}|T|-1\\k-1\end{pmatrix}(-1)^{|T|-k}\min(T)$$

不会的，就参考[这里](https://www.cnblogs.com/p-b-p-b/p/10350374.html)。

现在，题目要求我们求第 $k$ 小，我们转化一下，变成求第 $k$ 大，对于上面那一个式子，在期望意义下仍然成立，即

$$E(kthmax(S)) = \sum\limits_{\varnothing\ne T \subseteq S} \begin{pmatrix}|T|-1\\k-1\end{pmatrix}(-1)^{|T|-k}E(\min(T))$$

首先呢，我们得到集合 $S$ 中物品的概率应该为：

$$\dfrac{\sum\limits_{i\in S}p_i}{m}$$

那么期望次数就是其倒数，即：

$$\dfrac{m}{\sum\limits_{i\in S}p_i}$$

所以最终答案就是：

$$E(kthmax(S)) = \sum\limits_{\varnothing\ne T \subseteq S} \begin{pmatrix}|T|-1\\k-1\end{pmatrix}(-1)^{|T|-k}\dfrac{m}{\sum\limits_{i\in S}p_i}$$

我们发现 $\dfrac{m}{\sum\limits_{i\in S}p_i}$ 这个数字太玄学了，我们需要~~用魔法~~稍微变化一下，发现数据中的 $m \le 10^4$,我们就可以尝试去枚举这段和，即：

$$E(kthmax(S)) = \sum\limits_{i=1}^m \dfrac{m}{s} \sum\limits_{\varnothing\ne T \subseteq S} \begin{pmatrix}|T|-1\\k-1\end{pmatrix}(-1)^{|T|-k}{(\sum\limits_{i\in S}p_i =i)}$$

如果直接枚举，时间复杂度就是 $O(2^n)$，绝对会炸，题目要求求期望，我们就会想到用 $\mathrm{dp}$ 求解。

### 1.定义

假设 $\mathrm{dp}_{i,j,k}$ 表示再前 $i$ 个元素中所有满足 $\sum\limits_{k\in S}p_k =j$ 时 $\begin{pmatrix}|T|-1\\k-1\end{pmatrix}(-1)^{|T|-k}$ 的和。

### 2.转移方程
首先如果我们不选当前第 $i$ 个元素，那么转移方程就是： $\mathrm{dp}_{i,j,k} = \mathrm{dp}_{i-1,j,k}$。

如果我们选的话，考虑 $\begin{pmatrix}|T|-1\\k-1\end{pmatrix}(-1)^{|T|-k}$ 的系数，用组合数的性质得：

$$\begin{pmatrix}|T|-1\\k-1\end{pmatrix}(-1)^{|T|-k}=-\begin{pmatrix}|T|-2\\k-1\end{pmatrix}(-1)^{(|T|-1)-k}+\begin{pmatrix}|T|-2\\k-2\end{pmatrix}(-1)^{(|T|-1)-(k-1)}$$

用杨辉三角得到系数，再~~用魔法~~修改一下，得到：

$$\mathrm{dp}_{i,j,k}=\mathrm{dp}_{i-1,j,k}+\mathrm{dp}_{i-1,j-p_i,k-1}-\mathrm{dp}_{i-1,j-p_i,k}$$

当然，这样空间就会爆，我们发现当前的 $k$ 之和 $k$ 和 $k - 1$ 有关系，我们就可以在开滚动数组，这一题就做完啦~

## 代码

~~~cpp
/*****************************************
备注：
******************************************/
#include<queue>
#include<math.h>
#include<stack>
#include<stdio.h>
#include<iostream>
#include<vector>
#include<iomanip>
#include<map>
#include<string.h>
#include<algorithm>
using namespace std;
// typedef long long LL;
#define int long long
const int MAXN = 1e5 + 10;
const int MR = 10 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 998244353;
int n, m, k, ans, inv[MAXN], a[MAXN];
int dp[MR][MAXN];
int ksm(int a, int b){//a ^ b % p;
	int ans = 1;
	while(b){
		if(b & 1)ans = ans * a % MOD;
		b >>= 1;
		a = a * a % MOD;
	}
	return ans % MOD;
} 
signed main()
{
	cin >> n >> k >> m;
	k = n - k + 1;
	for(int i = 1;i <= n; i++){
		cin >> a[i];
		inv[0] = dp[0][0] = 1;
	}
	for(int i = 1;i <= m; i++){
		inv[i] = ksm(i, MOD - 2);
	}
	for(int i = 1;i <= n; i++){
		for(int l = m;l >= a[i]; l--){
			for(int j = k; j; j--){
				dp[j][l] = (dp[j - 1][l - a[i]] - dp[j][l - a[i]] + dp[j][l] + MOD) % MOD;
			}
		}
	}
	for(int i = 0;i <= m; i++){
		ans = (ans + dp[k][i] * inv[i] % MOD) % MOD;
	}
	cout << ans * m % MOD;
	return 0;
}
~~~

---

## 作者：VenusM1nT (赞：9)

扩展 $\textbf{min-max}$ 容斥。  
第一次做这种毒瘤题呢……对着题解啃了好几天……  
本篇题解纯属口胡……  
首先，我们需要掏出一个叫做 $\textbf{min-max}$ 容斥 的式子：

$$\max(S)=\sum_{\varnothing \neq T\subseteq S}(-1)^{|T|
-1}\min(T)$$

因为太玄学了，咱也证明不来，只能背下来了……  
然后这个式子是求最大值的，我们可以把它扩展一下，让它变成求第 $k$ 大值，如下：

$$\max_k(S)=\sum_{\varnothing \neq T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\min(T)$$  

然后很玄学地，它可以扩展到期望，如下：

$$\ E(\max_k(S))=\sum_{\varnothing \neq T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\min(T))$$

其中 $S$ 代表的是 $S$ 包含的材料的期望出现时间的集合，我们令 $k=n-k+1$，所以我们要求的就是上式。那么要怎么求呢？首先得到集合 $S$ 中物品的概率为：

$$\sum_{i\in S}p_i$$

那么期望时间就是：

$$\frac{1}{\sum_{i\in S}p_i}$$

根据这个，我们可以设计 $\textbf{dp}$ 来求解。我们考虑令 $f_{i,j,k}$ 表示当前为第 $i$ 个位置，前面选的物品的出现概率和为 $j$ 的 $\sum_{T\subseteq S}\binom{|T|-1}{k-1}(-1)^{|T|-k}$ 的大小，考虑它怎么从 $f_{i-1,j,k}$ 转移过来，显然，如果没有 $i$ 这个材料，直接跳过，即 $f_{i,j,k}=f_{i-1,j,k}$，我们主要考虑如果有 $i$ 这个材料怎么转移，如下：

$$f_{i,j,k}=\sum_{T\subseteq S}\binom{|T|-1}{k-1}(-1)^{|T|-k}=\sum_{T\subseteq S}\binom{|T|}{k-1}(-1)^{|T|-k+1}$$

这一步的意思是不考虑 $i$ 这个材料，即去掉 $p_i$ 的概率，转而考虑前 $i-1$ 个材料。可以注意这一步可以通过组合数的递推重新化成 $|T|-1$：

$$=\sum_{T\subseteq S}(\binom{|T|-1}{k-1}+\binom{|T|-1}{k-2})(-1)^{|T|-k+1}$$

把它拆开来：

$$=\sum_{T\subseteq S}\binom{|T|-1}{(k-1)-1}(-1)^{|T|-(k-1)}-\sum_{T\subseteq S}\binom{|T|-1}{k-1}(-1)^{|T|-k}$$

注意到前面的 $(k-1)$ 是一个整体，所以我们可以得到转移方程：

$$f_{i,j,k}=f_{i-1,j,k}+f_{i-1,j-p_i,k-1}-f_{i-1,j-p_i,k}$$

初始值为 $f_{i,0,0}=1$，由于空间复杂度高达 $\text{O}(nmk)$，我们可以滚掉第一维，这样空间复杂度就是 $\text{O}(mk)$，可以通过此题。  
（其实转移真的很像背包）

```cpp
#include<bits/stdc++.h>
#define MAXN 1005
#define MAXM 10005
#define MAXK 15
#define reg register
#define inl inline
using namespace std;
const int Mod=998244353;
int n,K,m,p[MAXN],f[2][MAXM][MAXK],inv[MAXM],cnt,ans;
inl int Add(reg int x,reg int y)
{
	return x+y>=Mod?x+y-Mod:x+y;
}
inl int Del(reg int x,reg int y)
{
	return x-y<0?x-y+Mod:x-y;
}
inl int Mul(reg int x,reg int y)
{
	return 1ll*x*y-1ll*x*y/Mod*Mod;
}
int main()
{
	scanf("%d %d %d",&n,&K,&m);
	K=n-K+1;
	for(reg int i=1;i<=n;i++) scanf("%d",&p[i]);
	inv[1]=1;
	for(reg int i=2;i<=m;i++) inv[i]=Mul(inv[Mod%i],Mod-Mod/i);
	f[cnt][0][0]=1;
	for(reg int i=1;i<=n;i++)
	{
		cnt^=1;
		memset(f[cnt],0,sizeof(f[cnt]));
		f[cnt][0][0]=1;
		for(reg int j=1;j<p[i];j++)
		{
			for(reg int k=1;k<=K;k++) f[cnt][j][k]=f[cnt^1][j][k];
		}
		for(reg int j=p[i];j<=m;j++)
		{
			for(reg int k=1;k<=K;k++) f[cnt][j][k]=Add(f[cnt^1][j][k],Del(f[cnt^1][j-p[i]][k-1],f[cnt^1][j-p[i]][k]));
		}
	}
	for(reg int i=1;i<=m;i++) ans=Add(ans,Mul(f[cnt][i][K],Mul(inv[i],m)));
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：ニヒル (赞：6)

min-max进行一波扩展可以查询kth-max   
[min-max看这里](https://blog.csdn.net/qq_21829533/article/details/89048119)   
同样设一个容斥函数$kth-max\{S\}=\sum_{T\subseteq S}F(|T|)min\{T\}$  
还是一样的列出每个min的出现次数  
$F(x)=\sum_{i=0}^{x}{x\choose i}f(i+1)$  
显然大函数为第k大出现一次     
 $[x==k-1]=\sum_{i=0}^{x}{x\choose i}f(i+1)$ 
 二项式反演得  
 $f(x+1)=\sum_{i=0}^{x}(-1)^{x-i}{x\choose i}F(i)$   
$f(x+1)=\sum_{i=0}^{x}(-1)^{x-i}{x\choose i}[i==k-1]$
$f(x+1)=(-1)^{x-k+1}{x \choose k-1}$    
$f(x)=(-1)^{x-k}{x-1 \choose k-1}$     
即$kth-max\{S\}=\sum_{T\subseteq S}(-1)^{|T|-k}{|T|-1 \choose k-1}min\{T\}$    
这样子就可以把kth-max转化成min    
很显然每个min的期望贡献都是集合概率和的倒数，我们可以放一下最后求
先求一下$\sum_{T\subseteq S}(-1)^{|T|-k}{|T|-1 \choose k-1}$    
考虑DP转移    
假设$dp[i][j][k]$表示前$i$种中选出一个集合使其概率为$j$的$\sum_{T\subseteq S}(-1)^{|T|-k}{|T|-1 \choose k-1}$  
显然对于第i个有两种情况，选或者不选    
不选的话很简单$dp[i][j][k]=dp[i-1][j][k]$  
选的话有点小问题，可以发现虽然$i$从$i-1$转移，$j$从$j-p_i$转移很套路，但是新加进来一个数以后集合大小增加了1，就需要稍微推一下了    
每次大小增加1，正负性就会发生改变    
根据组合数的递推式，${|T|-1 \choose k-1}={|T|-2 \choose k-1}+{|T|-2 \choose k-2}$   
然后正负性与$|T|,k$都有关，所以等式后第一个的贡献是负的，而第二个的贡献是正的    
也就是$dp[i][j][k]=dp[i-1][j-p_i][k-1]-dp[i-1][j-p_i][k]$  
边界条件的话$dp[i][0][0]=1$，这个并不是唯一的，但是按照这样子赋有实际意义：考虑上面那个容斥函数，我们只有一个空集，所以这里的$\sum_{T\subseteq S}(-1)^{|T|-k}{|T|-1 \choose k-1}=1$  
然后只是从i-1和i转移过来，所以开个滚动数组优化一下空间    
统计答案的时候乘上概率的逆元就是答案了   
代码如下：
```cpp
#include<bits/stdc++.h>
#define mod 998244353
using namespace std;

long long kasumi(long long a,long long b)
{
	long long ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}

long long dp[2][20000][12];
int p[2000];
int n,m,k,pre=0,now=1;

int main()
{
	scanf("%d%d%d",&n,&k,&m);
	k=n-k+1;
	now=1;
	for(int i=1;i<=n;i++) scanf("%d",&p[i]);
	dp[0][0][0]=1;
	now=1,pre=0;
	for(int i=1;i<=n;i++)
	{
		dp[now][0][0]=1;
		for(int j=0;j<=m;j++)
		{
			for(int h=0;h<=k;h++)
			{
				dp[now][j][h]=dp[pre][j][h];
				if(j>=p[i]&&h!=0)
				{
					dp[now][j][h]=(dp[now][j][h]+(dp[pre][j-p[i]][h-1]-dp[pre][j-p[i]][h]+mod)%mod)%mod;
				}
			}
		}
		now^=1,pre^=1;
	}
	long long ans=0;
	for(int i=1;i<=m;i++)
	{
		ans+=dp[pre][i][k]*kasumi(i,mod-2)%mod;
		ans%=mod;
	}
	printf("%lld\n",ans*m%mod);
}
```


---

## 作者：CXY07 (赞：5)

> 题目链接：[重返现世](https://www.luogu.com.cn/problem/P4707)

> **本题解同步发布于 [My Blog](http://www.cxy07.blog/index.php/archives/138/)**

题意：

> 有 $n$ 个元素，每次抽取到第 $i$ 个的概率是 $\dfrac{p_i}{m}$，求抽到任意不同 $k$ 个的期望次数。

> $1\le n\le 1000,1\le m\le 10^4,0\le n-k\le 10,\sum p_i=m$。

这题也太神秘了/bx/bx/bx

首先考虑 $\text{min-max}$ 容斥，则这个东西是：

$$
E(\text{kth-min}(S))=\sum_{T\subseteq S} \binom{|T|-1}{k-1}(-1)^{|T|-k} E(\max(T))
$$

回忆一下 $E(\max(T))$ 的求法，这是一个经典的 $\text{min-max}$ 容斥问题，其做法需要把 $\max$ 反演成 $\min$。所以这样仍然是不好做的。

但是我们知道，第 $k$ 小 $\iff$ 第 $n-k+1$ 大，所以我们令 $k\leftarrow n-k+1$。这样还有一个好处：当 $k\leftarrow n-k+1$，则 $k\le 11$，用上了题目的条件。

于是有：

$$
E(\text{kth-max}(S))=\sum_{T\subseteq S} \binom{|T|-1}{k-1}(-1)^{|T|-k} E(\min(T))
$$

这时候 $E(\min(T))$ 就是一个经典问题了，这个问题问的是：

> 第一次抽出集合 $T$ 中的元素所需要的期望次数。

抽出集合中任意一个元素的概率是 $\dfrac{\sum_{x\in T} p_x}{m}$，所以期望次数就是其倒数 $\dfrac{m}{\sum_{x\in T}p_x}$。

因此答案是：

$$
E(\text{kth-max}(S))=\sum_{T\subseteq S} \binom{|T|-1}{k-1}(-1)^{|T|-k} \dfrac{m}{\sum_{x\in T}p_x}
$$

这个 $\sum_{x\in T}p_x$ 在分母上太神秘了，但是我们有 $m\le 10^4$，所以可以枚举这个和！答案变成：

$$
=\sum_{s=1}^m \dfrac{m}{s}\sum_{T\subseteq S}\binom{|T|-1}{k-1}(-1)^{|T|-k}\Big[\sum_{x\in T} p_x=s\Big]
$$

考虑对每一种 $s$，算后面那个系数之和。考虑 $\text{dp}$，设 $\text{dp}_{i,j,x}$ 表示考虑前 $i$ 个元素，$\sum_{x\in T} p_x=j$，

$$
\binom{|T|-1}{x-1}(-1)^{|T|-x}
$$

的和。

考虑如何转移，首先如果第 $i$ 个元素不选，则有：

$$
\text{dp}_{i,j,x}=\text{dp}_{i-1,j,x}
$$

如果选择第 $i$ 个元素，则 $j\leftarrow j+p_i$。考虑上面这个系数会怎样变化：
$$
\binom{|T|-1}{x-1}(-1)^{|T|-x}=-\binom{|T|-2}{x-1}(-1)^{(|T|-1)-x}+\binom{|T|-2}{x-2}(-1)^{(|T|-1)-(x-1)}
$$
也就是把杨辉三角拆开，然后把 $-1$ 的系数修正一下。于是有转移：
$$
\text{dp}_{i,j,x}=\text{dp}_{i-1,j,x}+\text{dp}_{i-1,j-p_i,x-1}-\text{dp}_{i-1,j-p_i,x}
$$
直接 $\text{dp}$ 即可做到 $\mathcal{O}(nm\times (n-k))$。空间开不下，记得滚动一下。

~~彩蛋：推式子的时候，大力推了 kth-min 转化为 min 的系数，觉得自己巨大厉害，后来发现这和 kth-max 转变为 min 没有任何区别/tuu~~

```cpp
//Code By CXY07
#include<bits/stdc++.h>
using namespace std;

//#define FILE
#define int long long
#define file(FILENAME) freopen(FILENAME".in", "r", stdin), freopen(FILENAME".out", "w", stdout)
#define randint(l, r) (rand() % ((r) - (l) + 1) + (l))
#define LINE() cout << "LINE = " << __LINE__ << endl
#define debug(x) cout << #x << " = " << x << endl
#define abs(x) ((x) < 0 ? (-(x)) : (x))
#define popc(x) __builtin_popcount(x)
#define inv(x) qpow((x), mod - 2)
#define lowbit(x) ((x) & (-(x)))
#define ull unsigned long long
#define pii pair<int, int>
#define LL long long
#define mp make_pair
#define pb push_back
#define scd second
#define vec vector
#define fst first
#define endl '\n'

const int MAXN = 1010;
const int MAXM = 10010;
const int INF = 2e9;
const double eps = 1e-6;
const double PI = acos(-1);
//const int mod = 1e9 + 7;
const int mod = 998244353;
//const int G = 3;
//const int base = 131;

int n, k, m, p[MAXN], Ans;
int dp[MAXM][12], Inv[MAXM];

template<typename T> inline bool read(T &a) {
	a = 0; char c = getchar(); int f = 1;
	while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { a = a * 10 + (c ^ 48); c = getchar(); }
	return a *= f, true;
}

template<typename A, typename ...B>
inline bool read(A &x, B &...y) { return read(x) && read(y...); }

void modadd(int &x, int y) {
	x += y;
	if(x >= mod) x -= mod;
}

signed main () {
#ifdef FILE
	freopen(".in", "r", stdin);
	freopen(".out", "w", stdout);
#endif
	read(n), read(k), read(m); Inv[1] = 1, k = n - k + 1;
	for(int i = 1; i <= n; ++i) read(p[i]);
	for(int i = 2; i <= m; ++i) 
		Inv[i] = Inv[mod % i] * (mod - mod / i) % mod;
	dp[0][0] = 1;
	for(int i = 1; i <= n; ++i)
		for(int j = m; j >= p[i]; --j)
			for(int c = k; c; --c)
				(dp[j][c] += dp[j - p[i]][c - 1] - dp[j - p[i]][c] + mod) %= mod;
	for(int p = 1; p <= m; ++p)
		Ans = (Ans + dp[p][k] * m % mod * Inv[p]) % mod;
	printf("%lld\n", Ans);
	return 0;
}

```

---

## 作者：热言热语 (赞：5)

__前言__

如果题解页面公式崩坏，请 [在博客中查看](https://www.luogu.com.cn/blog/hotwords/solution-p4707)。

这篇题解主要想从一种新的角度（形式幂级数）出发推导出本题的 DP 过程，并不会从头介绍 min-max 容斥的原理和证明（这部分可以参考 [nekko 大佬的题解](https://www.luogu.com.cn/blog/KingSann/solution-p4707)）。

__前置知识__

扩展 min-max 容斥，形式幂级数。

__题解__

题目无处不在散发着一股浓浓的 min-max 容斥的气息，那就把套路借过来用一下吧。

记 $t_i$ 为第 $i$ 种原料第一次出现的时间。

设 $S = \{t_i\}$，即每种原料第一次出现时间的集合。

题目要求的就是 $S$ 中的第 $k$ 小值（即第 $(n+1-k)$ 大值）的期望。

为简便起见，下面用 $k$ 代指题目中的 $n+1-k$，即把第 $k$ 小变为第 $k$ 大。

首先放上期望意义下 min-max 容斥的式子，其中 ${\max}_k S$ 表示 $S$ 中的第 $k$ 大值：
$$
E({\max}_k S) = \sum_{\varnothing \ne T \subseteq S} (-1)^{|T|-k} \binom {|T|-1}{k-1} E(\min T)
$$
考虑 $E(\min T)$ 的意义，即第一次出现 $T$ 中原料的期望时间。这里出现时间的期望即为出现概率的倒数，所以
$$
E(\min T) = {m \over \mathrm{sum}(T)}
$$
其中 $\mathrm{sum}(T)$ 表示 $T$ 中每种原料的 $p_i$ 之和。

注意到 $\mathrm{sum}(T)$ 的范围比较小，可以把它提出来，枚举 $s =\mathrm{sum}(T)$：
$$
E({\max}_k S) = m \sum_{s=1}^m {1 \over s} \sum_{\mathrm{sum}(T)=s} (-1)^{|T|-k} \binom{|T|-1}{k-1}
$$
一个小细节：题目中 $p_i$ 可能为 $0$，但这里忽略掉 $s=0$ 的情况没有影响，因为此时后面的部分一定是 $0$，否则问题无解。

推式子推到这，比较常见的做法是利用组合数的递推式设计 DP，不过这里我们换一种思路。

形式幂级数天生擅长刻画组合数形式，不妨一试。

众所周知，$\displaystyle (-1)^{|T|-k} \binom{|T|-1}{k-1} = [x^{k-1}](x-1)^{|T|-1}$。

这里有 $|T|-1$ 个 $(x-1)$ 相乘，可以看成 $T$ 中的每种原料贡献一个因式 $(x-1)$，最后再除掉多出的一个 $(x-1)$。

由于求和式中还有一个限制条件 $s$，考虑用类似生成函数求解背包问题的做法，找到另一个元来代表它，不妨把这个新来的元记为 $w$。

这样，对于 $T$ 中含有的一种原料（设出现概率为 $\dfrac p m$），它会为 $T$ 贡献一个因式 $w^p(x-1)$。

由于 $T \subseteq S$，这样所有的 $T$ 组成了 $S$ 的幂集，每种原料既可以包含在 $T$ 中也可以不包含，那么所有 $T$ 对应的形式幂级数之和即为
$$
F = {1 \over x-1} \prod_{i=1}^n \big(1+w^{p_i}(x-1)\big)
$$
对比前面的式子，答案就是
$$
E({\max}_k S) = m \sum_{s=1}^m {1 \over s} [w^sx^{k-1}] F
$$
（这类似于把 $\dfrac {[x^{k-1}]F+1}w$ 对 $w$ 积分后把 $w=1$ 代入求值，然而并没有从这里发现什么性质。）

直接暴力卷积求出 $F$ 的系数后统计答案即可，时间复杂度 $O(nmk)$，空间复杂度 $O(mk)$。

具体地，记 $f(s,k)$ 为 $F$ 中 $w^sx^k$ 项的系数。

类似背包，依次考虑每个原料 $i$，它的贡献为 $\big(1+w^{p_i}(x-1)\big)$，即 $(1+w^{p_i}x-w^{p_i})$，所以：

- $f(s,k)$ 向 $f(s+p_i,k+1)$ 贡献 $f(s,k)$，对应因式中的 $w^{p_i}x$ 一项；
- $f(s,k)$ 向 $f(s+p_i,k)$ 贡献 $-f(s,k)$，对应因式中的 $-w^{p_i}$ 一项。

而对于最外层的因式 $\dfrac m{x-1}$，我们可以一开始就把它乘到 $F$ 中。

由 $\dfrac m{x-1} = -m(1+x+x^2+x^3+\cdots)$，可得边界条件为 $f(0,k)=-m$。

于是我们就愉快地解决了本题。

__代码__

```cpp
#include <cstdio>

typedef long long ll;

const int MaxK = 12, MaxM = 10005;
const int cIz = 998244353;

inline int& inc(int &a, int b) {
	return (a += b) < cIz ? a : a -= cIz;
}
inline int& dec(int &a, int b) {
	return (a -= b) < 0 ? a += cIz : a;
}

int f[MaxM][MaxK], inv[MaxM];

void init_inv(int n) {
	inv[1] = 1;
	for (int i = 2; i <= n; ++i) {
		inv[i] = (ll)(cIz - cIz / i) * inv[cIz % i] % cIz;
	}
}

int main() {
	int n, k, m, sum = 0;
	scanf("%d%d%d", &n, &k, &m);
	k = n - k;
	for (int i = 0; i <= k; ++i) f[0][i] = cIz - m;
	for (int i = 0; i < n; ++i) {
		int p; scanf("%d", &p);
		for (int s = sum; s >= 0; --s) {
			int *A = f[s], *B = f[s + p];
			dec(B[k], A[k]);
			for (int j = k; j--; ) {
				inc(B[j + 1], A[j]);
				dec(B[j], A[j]);
			}
		}
		sum += p;
	}
	init_inv(m);
	int ans = 0;
	for (int i = 1; i <= m; ++i) {
		ans = (ans + (ll)inv[i] * f[i][k]) % cIz;
	}
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：Celtic (赞：4)

一道神仙题

首先有 kthmin-max容斥的式子：$kth\max{S}=\sum_{T\subset S} (-1)^{|T|-k}\tbinom{|T|-1}{k-1}\min{T}$

证明要用二项式反演，考虑算每个位置作为最大值的贡献。

然后这个东西在期望意义下也是成立的，所以我们就可以把这道题转化成对于每个集合 $S$ 求出第一次随机到 $S$ 中元素的期望时间。

这个也很好求，$val(S)={\frac{1}{\sum_{i \in S}^{}  p_i}}$

但是这道题 $n$ 高达 $2000$，我们没法枚举每个集合算答案。

我们注意到 $m$ 范围是 $10000$ ，就可以考虑和值域范围有关的 dp ，就是把$\sum_{i \in S}^{}  p_i$ 设到状态里。

设 $dp_{i,j,k}$ 表示前 $i$ 个元素形成的集合大小是 $j$ ，$p_i$ 的和是 $k$ 的方案数，转移考虑一个元素是否加入集合。

然后对每个状态算出贡献乘上方案数，70分到手。

考虑优化，我们发现维数太多不好处理，这个时候有个技巧就是把状态藏进权值里。

因为这个 $\sum_{i \in S}^{}  p_i$ 做运算会出现一大堆分数，把他放到权值里会非常的恶心，而权值的另一部分就是一个和 $|S|$ 有关的式子 $f(S)$，考虑把他弄进权值里。

设 $dp_{i,j}$ 表示前 $i$ 个元素， $p_i$ 的和是 $j$ 对应的 $(-1)^{|S|-k}\tbinom{|S|-1}{k-1}$ 的和。

还是考虑这个元素是否加入，不加入的话直接 $dp_{i,j}+=dp_{i-1,j}$

加入的话就有意思了，$dp_{i,j}+=dp_{i-1,j-p_i}\times \text{???}$

由于我们并不知道集合大小，这个 $\text{???}$ 也不好算。

把式子稍微写一下 ,原来是 $\sum_{S} (-1)^{|S|-k}\tbinom{|S|-1}{k-1}$ ，转移之后变成了 $\sum_{S} (-1)^{|S|+1-k}\tbinom{|S|}{k-1}$ 

把这个组合数拆开，变成 $\sum_{S} (-1)^{|S|+1-k}(\tbinom{|S|-1}{k-2}+\tbinom{|S|-1}{k-1})$

括号打开，变成 $\sum_{S} (-1)^{|S|+1-k}\tbinom{|S|-1}{k-2}-\sum_{S} (-1)^{|S|-k}\tbinom{|S|-1}{k-1}$

我们发现，后边那坨东西不就是 $dp_{i-1}{j}$ 吗？

前边相当于把 $k$ 减了个 $1$，同时我们注意到 $k\leq 10$ ，于是再记录一维 $k$ 。

设 $dp_{i,j,k}$ 表示前 $i$ 个元素，$p$ 的和是 $j$ 的 $(-1)^{|S|-k}\tbinom{|S|-1}{k-1}$ 的和 （注意这里的 $k$ 不是上面的的 $k$ 了）

根据上面的智慧东西， $dp_{i,j,k}=dp_{i-1,j-{p_i},k-1}-dp_{i-1,j-{p_i},k}$

注意下空间，使用滚动数组压掉第一维，就可以了。

可以了吗？？？

还有边界问题，这个超级容易漏的。

这里组合数的上边是负的，这时就不能按照组合意义来了，要按照下降幂那个定义来，就是稍微讨论一下就能发现除了 $k=0$ 的时候是 $0$ ,剩下的全是 $-1$ ，直接按照这个设初值。
 
最后把 $p_i$ 的贡献也算上就行了。

$\sf{Code}$

```cpp
#include<bits/stdc++.h>
#define N 10010
#define MAX 2001
using namespace std;
typedef long long ll;
typedef double db;
const ll mod=998244353;
inline void read(ll &ret)
{
	ret=0;char c=getchar();bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,k,m,dp[2][N][15],p[N],ans;
inline ll qpow(ll a,ll b)
{
	ll ret=1;
	while(b)
	{
		if(b&1)
			ret*=a,ret%=mod;
		b>>=1;
		a*=a;
		a%=mod;
	}
	return ret;
}
signed main()
{
	read(n);
	read(k);
	read(m);
	k=n-k+1;
	for(int i=1;i<=n;i++)
		read(p[i]);
	for(int l=1;l<=k;l++)
		dp[0][0][l]=mod-1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
			for(int l=0;l<=k;l++)
				dp[i&1][j][l]=0;
		for(int j=0;j<=m;j++)
		{
			for(int l=0;l<=k;l++)
			{
				dp[i&1][j][l]+=dp[(i-1)&1][j][l];
				if(j>=p[i]&&l)
					dp[i&1][j][l]+=dp[(i-1)&1][j-p[i]][l-1]-dp[(i-1)&1][j-p[i]][l];
				if(dp[i&1][j][l]>=mod)
					dp[i&1][j][l]-=mod;
				if(dp[i&1][j][l]>=mod)
					dp[i&1][j][l]-=mod;
				if(dp[i&1][j][l]<0)
					dp[i&1][j][l]+=mod;
			}
		}
	}
	for(int j=1;j<=m;j++)
		ans+=dp[n&1][j][k]*qpow(j,mod-2)%mod*m%mod;
	printf("%lld\n",ans%mod); 
	exit(0);
}
```

---

## 作者：nekko (赞：4)


# 前置知识

## 二项式反演

$$ \begin{aligned} f_n=\sum_{i=0}^{n}(-1)^i {n \choose i} g_i &\Leftrightarrow g_n=\sum_{i=0}^{n}(-1)^i {n \choose i} f_i \\ f_n=\sum_{i=0}^{n}{n \choose i} g_i &\Leftrightarrow g_n=\sum_{i=0}^{n}(-1)^{n-i} {n \choose i} f_i \end{aligned} $$

# 快速入门

设有一集合 $S$，定义 $\max(S)$ 表示集合 $S$ 的最大值，$\min(S)$ 表示集合 $S$ 的最小值

则有如下两个式子成立：

$$\begin{cases} &\max(S)=\sum\limits_{\emptyset \ne T \subseteq S}(-1)^{\mid T \mid + 1}\min(T) \\ &\min(S)=\sum\limits_{\emptyset \ne T \subseteq S}(-1)^{\mid T \mid + 1}\max(T) \end{cases}$$

证明的话其实十分简单易懂，在此只证明第一个的正确性

假设现在把集合 $S$ 从小到大排序（假设集合大小为 $x$），若某个元素的排名为 $x$，那么它在最终答案中的系数就是（考虑它在何时作为最小值出现）：

$$\sum_{i=0}^{n-x} {n-x \choose i} (-1)^{i+1+1}=(1-1)^{n-x}=[x=n]$$

于是一个元素对答案产生贡献当且仅当它是最大的元素，于是就是 $\max(S)$ 了

一个更加有用的结论是，`min-max 容斥` 在期望意义下仍然成立

也就是说：

$$\begin{cases} &E(\max(S))=\sum\limits_{\emptyset \ne T \subseteq S}(-1)^{\mid T \mid + 1}E(\min(T)) \\ &E(\min(S))=\sum\limits_{\emptyset \ne T \subseteq S}(-1)^{\mid T \mid + 1}E(\max(T)) \end{cases}$$

# 原理

那么这个是怎么推出来的呢……（注意这个很重要）

现在想构造一个 $f$ 函数，使得下式成立：

$$\max(S)=\sum_{T \subseteq S} f(\mid T \mid) \min(T)$$

然后依然考虑一个元素排序后在哪些集合产生贡献，假设某个元素从小到大后排在第 $x$ 位（集合大小为 $n$），那么它的贡献就是：

$$[x=n]=\sum_{i=0}^{n-x} {n-x \choose i}f(i+1)$$

套用二项式反演，可以得到：

$$[x=n]=\sum_{i=0}^{n-x} {n-x \choose i}f(i+1)$$

$$[n-x=0]=\sum_{i=0}^{n-x} {n-x \choose i} f(i+1)$$

$$[x=0]=\sum_{i=0}^{x} {x \choose i} f(i+1)$$

$$f(x+1)=\sum_{i=0}^{x}(-1)^{x-i} {x \choose i} [i=0]=(-1)^x {x \choose 0}=(-1)^{x}$$

$$f(x)=(-1)^{x+1}$$

于是就得到了：

$$\max(S)=\sum\limits_{\emptyset \ne T \subseteq S}(-1)^{\mid T \mid + 1}\min(T)$$

# 进阶

既然现在有了求最大值的容斥了，而且还知道原理，不放搞一搞第 $k$ 大的容斥

即现在要构造一个 $f$，满足：

$$kthmax(S)=\sum_{T \subseteq S} f(\mid T \mid) \min(T)$$

依然是考虑一个排名（从小到大）为 $x$ 的元素在大小为 $n$ 的集合中的贡献：

$$[n-x+1=k]=\sum_{i=0}^{n-x} {n-x \choose i} f(i+1)$$

$$[x=k-1]=\sum_{i=0}^{x} {x \choose i} f(i+1)$$

$$f(x+1)=\sum_{i=0}^{x} (-1)^{x-i} {x \choose i} [i=k-1]=(-1)^{x-(k-1)}{x \choose k-1}$$

$$f(x)=(-1)^{x-k} {x-1 \choose k-1}$$

也就是说：

$$kthmax(S)=\sum_{T \subseteq S} (-1)^{\mid T \mid-k} {\mid T \mid -1 \choose k-1} \min(T)$$

# 回到这道题

发现这就是一个 $kthmax$ 的板子……

答案就是：

$$\sum_{S \subseteq U}(-1)^{\mid S \mid -k} {\mid S \mid - 1 \choose k - 1} \frac{m}{\sum_{x \in S} p_x}$$

发现 $\mid n - k \mid \le 10$，所以直接用 $dp$ 来记录所有集合的系数就行了

# 代码

``` cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 1010, FAFA = 1e5 + 10, mod = 998244353;

ll pw(ll a, ll b) {
    ll r = 1;
    for( ; b ; b >>= 1, a = a * a % mod)
        if(b & 1)   
            r = r * a % mod;
    return r;
}

int n, k, m, ans;

ll p[N], f[2][10010][20];

int main() {
    ios :: sync_with_stdio(0);
    
    cin >> n >> k >> m;
    for(int i = 1 ; i <= n ; ++ i) cin >> p[i];
    k = n - k + 1;
    
    int cur = 0;
    for(int j = 1 ; j <= k ; ++ j) f[cur][0][j] = -1;
    
    for(int i = 1 ; i <= n ; ++ i) {
        cur ^= 1;
        memset(f[cur], 0, sizeof f[cur]);
        for(int j = 0 ; j <= m ; ++ j) {
            for(int k = 1 ; k <= :: k ; ++ k) {
                f[cur][j][k] = f[cur ^ 1][j][k];
                if(j >= p[i]) {
                    f[cur][j][k] = (f[cur][j][k] + f[cur ^ 1][j - p[i]][k - 1] - f[cur ^ 1][j - p[i]][k]) % mod;
                }
            }
        }
    }
    
    for(int i = 1 ; i <= m ; ++ i) {
        ans += m * pw(i, mod - 2) % mod * f[cur][i][k] % mod;
        ans %= mod;
    }
    
    cout << (ans % mod + mod) % mod << endl;
}
```

---

## 作者：Dementor (赞：2)

## 题解 P4707 【重返现世】

首先，我们对于这道题来说，可以先进行一个构造，设 $S$ 是由每种物品第一次拿到的期望时间组成的集合，那么我们求集齐任意 $k$ 种的期望时间，就相当于求 $E (min_k(S))$ 。

看到这样一个式子，先利用 **min - max 容斥** 将其进行变换。

---

我们知道一个事实：

$$max_k(S) = \sum_{\varnothing \neq T \subseteq S}{(-1) ^ {|T| - k}{{|T| - 1} \choose {k - 1}}min(T)}$$

这个式子便是 `min - max 容斥`。

将式子里的 `min` 和 `max` 替换一下位置也是成立的。根据对称性易得。

这里可以稍微解释一下（解释原始式子）：

---

考虑构造法：考虑构造一个容斥系数 $a_i$ ，满足：

$$max_k(S) = \sum_{\varnothing \neq T \subseteq S}{a_{|T|}}min(T)$$

把每个元素分开来考虑，就有：

$$max_k(S) = \sum_{i = 1}^{|S|}max_i(S)\sum_{j = 1}^{i}{a_j{{i - 1} \choose {j - 1}}}$$

那么我们想要的是这个东西：

$$\sum_{j = 1}^{i}{a_j{{i - 1} \choose {j - 1}}} = [i == k]$$

然后再对这个式子利用二项式反演：

$$a_i = (-1)^{i - k}{{i - 1} \choose {k - 1}}$$

于是，我们得到了最初那个式子。

---

这个式子在期望意义下也是成立的：

$$E(max_k(S)) = \sum_{\varnothing \neq T \subseteq S}{(-1) ^ {|T| - k}{{|T| - 1} \choose {k - 1}}E(min(T))}$$

同样将 `min` 和 `max` 互换也是成立的。

那么我们就能将这题推下去了。

对于这道题：

$$E(max_{n - k + 1}(S)) = \sum_{\varnothing \neq T \subseteq S}{(-1) ^ {|T| - (n - k + 1)}{{|T| - 1} \choose {(n - k + 1) - 1}}E(min(T))}$$

看看这个 $E(min(T))$ 。

它代表着第一次拿到 $T$ 中物品的期望时间：

$$E(min(T)) = \frac{1}{\sum_{i \subseteq T}p_i}$$

但是我们不可能枚举子集来计算。

所以我们整体考虑 $\sum_{i \in T}p_i$ ，我们在最后计算答案的时候完全不需要知道这个式子中的每个运算数是什么，我们只要知道这个式子的结果是什么。我们就考虑统计 $\sum_{i \in T}p_i = tmp, tmp \in [1, m]$ 的系数。

这可以通过一个 $DP$ 求出：

设 $dp[i][j][d]$ 表示前 $i$ 个物品的所有子集中， $\sum_{i \in T}p_i = j$ 的， 钦定 $k = d$ 的系数。

但是为什么是这个状态呢？

---

第一维不提

第二维就是上述意义

第三维又是怎么出来的？

我们发现我们做转移的时候，考虑了第 $i$ 个物品选或不选，前面的 $(-1) ^ {|T| - 1}$ 只是从少一或者是不变转移过来，非常容易，但是组合数就有点难了。

对于少一的情况，我们可以利用这个式子：

$${{n}\choose{m}} = {{n - 1}\choose{m}} + {{n - 1}\choose{m - 1}}$$

上指标问题解决了，但是这个时候下指标有要从少一的状态转移而来。

我们直接将它记录到状态里不就行了吗。

---

但是这样空间会异常巨大，滚动掉第一维不就行了吗。

初始化：

$$dp_{0, 0} = (-1) ^ {0} {{-1}\choose{-1}}$$

答案：

枚举 $j$ ,按照式子带入累加就好了。

这题到这里终于解决了。

code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1100, M = 11000;
const long long mod = 998244353;
int n, k; long long m;
long long p[N];
long long dp[M][13];
long long qpow (long long a, long long b) {
	long long ans = 1ll;
	while (b) {
		if (b & 1) ans = ans * a % mod;
		a = a * a % mod;
		b >>= 1ll;
	}
	return ans;
}
int main () {
	scanf ("%d %d %lld", &n, &k, &m);
	for (int i=1;i<=n;i++) scanf ("%lld", &p[i]);
	k = n - k + 1;
	dp[0][0] = 1;
	for (int i=1;i<=n;i++) {
		for (int j=m;j>=p[i];j--) {
			for (int d=k;d>=1;d--) {
				dp[j][d] = ((dp[j][d] - dp[j - p[i]][d] + mod) % mod + dp[j - p[i]][d - 1]) % mod;
			}
		}
	}
	long long Ans = 0;
	for (int i=1;i<=m;i++) {
		Ans = (Ans + dp[i][k] * qpow (i * qpow (m, mod - 2) % mod, mod - 2) % mod) % mod;
	}
	cout << Ans << endl;
}
```

---

学习 `min - max 容斥` 的第一题，也作为学习笔记吧~

继续努力！！！

---

## 作者：Gorenstein (赞：1)

一看就是个经典 $\text{min-max}$ 容斥类物；或许它就是 $\text{min-max}$ 容斥的入门题之一。

具体而言，如果我们将每个钥匙被收集到的时间放入一个集合中，则集齐任意 $K$ 种的期望时间可视作集合的期望第 $n-K+1$ 大。于是上期望 $\text{min-max}$ 容斥。


------------


$\bf Theorem.\;(min{\text -}max\;Inversion)$

$$
{\max}_{k}(K)=\sum_{L\subseteq K}(-1)^{|L|-k}\binom{|L|-1}{k-1}\min(L)
$$

以上称为 $\mathbf{\text{min-max}}$ **容斥**（**最值反演**）。由对称性，$\max,\min$ 的位置可互换。

我们尝试推导它。设 $\max_k(K)$ 表示集合 $K$ 中第 $k$ 大元素，我们希望能找到合适的 $\alpha_{|T|}$ 使得：

$$
{\max}_k(K)=\sum_{L\subseteq K}\alpha_{|L|}\min(L)
$$

设 $|K|=n$，则：

$$
{\max}_{k}(K)=\sum_{i=1}^{|K|}{\max}_{i}\left(K\right)\sum_{j=1}^{i}\binom{i-1}{j-1}\alpha_j
$$

表示枚举最小元是 $K$ 中第 $i$ 大元素的子集 $L$ 的大小 $j$。我们当使 $\sum_{j}^{}\binom{i-1}{j-1}\alpha_j=[i=k]$，设左端为 $g(i)$，也即：

$$g(i)=\sum_{j=0}^{i-1}\binom{i-1}{j}\alpha_{j}$$

那么二项式反演，得：

$$\alpha_i=\sum_{j=1}^i(-1)^{i-1-j}\binom{i-1}{j}g(j+1)=(-1)^{i-k}\binom{i-1}{k-1}$$

从而得到了 $\text{min-max}$ 容斥。

------------


现在我们利用期望形式的容斥公式着手解决这道题。


${\bf Proposition.\quad}\text{min-max}$ 在期望意义下也成立：

$$
\begin{aligned}
E({\max}_{k}(K))&=\sum_{L\subseteq K}(-1)^{|L|-k}\binom{|L|-1}{k-1}E(\min(L))\\&=\sum_{n=1}^{|K|}(-1)^{n-k}\binom{n-1}{k-1}\sum_{|L|=n}E(\min(L))
\end{aligned}
$$

$\text{min-max}$ 容斥的意义在于将一些不好直接求第 $k$ 大的问题转化为通过求子集的最小元来求解，例如以下一类求有关 $k$ 的期望的问题。

依此期望下的公式，我们可以实现这道题。事实上根据命题给出的上下两个形式，我们可以得到两个不同复杂度的 DP 做法，而前者能够通过本题。

依题设有：

$$
E(\min(X))=m\left(\sum_{x\in X}p_x\right)^{-1}
$$

考虑 DP 出 $E({\max}_K(X))$。如按第二个等式进行，则事实上我们只需考虑 $\sum_{|L|=n}E(\min(L))$。

设 $f_{i,j,k}$ 表考虑到前 $i$ 个元素、集合大小为 $j$、集合中概率和为 $k$ 的集合数量，则我们就可以用 $k$ 来累计答案，显然有转移：

$$
f_{i,j,k}=f_{i-1,j,k}+f_{i-1,j-1,k-p_i}
$$

这是通过容斥的第二个形式得出朴素的做法。如果我们依第一个形式更换状态设计，则可以得到更优的做法以通过本题。

设 $f_{i,j,k}$ 表考虑到前 $i$ 各元素、概率和为 $j$ 的集合 $L$ 的 $\alpha_{|L|}$ 之和，换言之我们将原先的中间这一维去掉，考虑在 DP 中求出系数 $\alpha_j$。也即：

$$
f_{i,j}=f_{i-1,j}+\sum_{i\in L\subseteq[i],S(L)=j}(-1)^{|L|-K}\binom{|L|-1}{K-1}
$$

$$
=f_{i-1,j}+\sum_{i\in L\subseteq[i],S(L)=j}\left((-1)^{(|L|-1)-(K-1)}\binom{|L|-2}{K-2}-(-1)^{(|L|-1)-K}\binom{|L|-2}{K-1}\right)
$$

发现式子里出了个 $K-2$，而 $K$ 又很小，那么就把 $K$ 也写进状态里去。那么就得到：

$$
f_{i,j,k}=f_{i-1,j,k}+f_{i-1,j-p_i,k-1}-f_{i-1,j-p_i,k}
$$

据此 DP 即可；可以滚动数组滚掉第一维。最终我们枚举 $j$ 这一维，则 $\sum_{j\leqslant m}\frac{m}{j}f_{j,K}$ 就是答案。

---

## 作者：Aftglw (赞：1)

### 重返现世

`min-max 容斥，DP`

记 $\min\limits_k\{S\}$ 表示 $S$ 中出现至少 $k$ 个元素的期望时间

答案便为 $\min\limits_{k} \{U\}, U = \{n \cdot 1\}$

考虑到 $k$ 很大，而 $n - k$ 很小，所以转化一下

$\min\limits_k \{U\} = \max\limits_{n - k + 1} \{U\}$

记 $k' = n - k + 1$ 再根据扩展 min-max 容斥，得

$\max\limits_{k'} \{S\} =  \sum\limits_{T \subseteq S} (-1) ^ {|T| - k'} \begin{pmatrix}|T| - 1\\k'- 1\end{pmatrix} \min\{T\}$

还是根据几何分布，有 $\min\{T\} = \frac m {\sum_{i\in S} p_i}$

但这样直接做的时间复杂度是 $O(2^n)$ 的，考虑换种做法

设 $f_{i, j,k}$ 表示前 $i$ 个数中的一些数组成集合 $S$ ，$\sum_{i \in S} p_i = j$ 时，$\sum\limits_{T\subseteq S} (-1)^{|T| - k}\begin{pmatrix}|T| - 1\\k - 1\end{pmatrix}$ 的值

考虑第 $i$ 个数选不选

- 第 $i$ 个数不选：$f_{i, j, k} = f_{i - 1, j, k}$

- 第 $i$ 个数选：
  $$
  \begin{aligned}
  f_{i, j, k}
  &=
  \sum\limits_{T\subseteq S} (-1)^{|T| - k}
  \begin{pmatrix}|T| - 1\\k - 1\end{pmatrix}
  
  \\
  
  &=
  \sum\limits_{T\subseteq S} (-1)^{|T| - k}
  \begin{pmatrix}
  \begin{pmatrix}|T| - 1 - 1\\ k - 1 - 1\end{pmatrix}
  +
  \begin{pmatrix}|T| - 1 - 1\\k - 1\end{pmatrix}
  \end{pmatrix}
  
  \\
  
  &=
  \sum\limits_{T\subseteq S} (-1)^{(|T| - 1) - (k - 1)}
  \begin{pmatrix}(|T| - 1) - 1\\(k - 1) - 1\end{pmatrix}
  +
  \sum\limits_{T\subseteq S} (-1)^{|T| - k}
  \begin{pmatrix}|T| - 1 - 1\\k - 1\end{pmatrix}
  \\
  
  &=
  f_{i - 1, j - p_i, k - 1}
  -
  \sum\limits_{T\subseteq S} (-1)^{(|T| - 1) - k}
  \begin{pmatrix}(|T| - 1) - 1\\k - 1\end{pmatrix}
  
  \\
  
  &= f_{i - 1, j - p_i, k - 1} - f_{i - 1, j - p_i, k}
  \end{aligned}
  $$

综上，$f_{i,j, k} = f_{i - 1, j, k} + f_{i - 1,j - p_i, k - 1} - f_{i - 1, j - p_i, k}$

当 $i = 0, j = 0, k = 0$ 时，带入定义式有 $f_{0, 0, 0} = 0$

时间复杂度：$O(n m (n - k + 1))$ ，滚动数组优化后空间复杂度：$O(m(n - m + 1))$

```cpp
#include <bits/stdc++.h>
#define re register
#define int long long
// #define pair pair<int, int>
// #define File(a) freopen(a".in", "r", stdin), freopen(a".out", "w", stdout);
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
using namespace std;
inline int read()
{
    re int x = 0, f = 0;
    re char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') f = 1; ch = getchar();}
    while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}
    return f ? -x : x;
}
inline string getstr()
{
    string res = "";
    re char ch = getchar();
    while (isspace(ch)) ch = getchar();
    while (!isspace(ch)) res.push_back(ch), ch = getchar();
    return res;
}
const int N = 1e3 + 3, P = 998244353, M = 1e4 + 4;
int n, K, m;
int p[N], f[2][M][12], inv[M];
signed main()
{
    n = read(), K = n + 1 - read(), m = read();
    inv[1] = 1;
    for (re int i = 2; i <= m; ++i) inv[i] = P - P / i * inv[P % i] % P;
    for (re int i = 1; i <= n; ++i) p[i] = read();
    re bool flag = 1;
    for (re int i = 1; i <= n; ++i, flag ^= 1)
    {
        for (re int j = 1; j <= m; ++j)
        {
            for (re int k = 1; k <= K; ++k)
            {
                f[flag][j][k] = f[flag ^ 1][j][k];
                if (j < p[i]) continue;
                if (j == p[i] && k == 1) f[flag][j][k]++;
                else
                {
                    f[flag][j][k] = (f[flag][j][k] + f[flag ^ 1][j - p[i]][k - 1] - f[flag ^ 1][j - p[i]][k]) % P;
                    if (f[flag][j][k] < 0) f[flag][j][k] += P;    
                }
            }
        }
    }
    flag ^= 1;
    int ans = 0;
    for (re int i = 1; i <= m; ++i) ans = (ans + f[flag][i][K] * m % P * inv[i] % P) % P;
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：zhendelan (赞：1)

首先要用到$kth-minmax$容斥。  
   
$$kth-max(S)=\sum_{T\subset S}(-1)^{|T|-k}C_{|T|-1}^{k-1}min(T)$$  

证明：  
统计$kth$作为$min(T)$的贡献。  

设$kth-max(S) = \sum_{T\subset S}f(|T|)min(T)$

$$g(k)=\sum_{i=0}^{k-1}C_{k-1}^i*f(i+1)$$   

令$G(n)=g(n+1),F(n)=f(n+1)$  

所以 

$$G(n)=\sum_{i=0}^{n}C_{n}^iF(i)=[n==k-1]$$

二项式反演：   

$$F(n)=\sum_{i=0}^n(-1)^{n-i}*C_n^iG(i)=(-1)^{n-k+1}*C_n^{k-1}$$  

代入可得结论。  

$$kth-max(S)=\sum_{T\subset S}(-1)^{|T|-k}C_{|T|-1}^{k-1}min(T)$$  
那么根据题意，将$max,min$重定义成出现的集合内某个元素最迟和最早的期望时间。   
现在是求$kth-min$。  

由于$max(T)$不好求，将$kth-min$可以转换成$(n+1-k)th-max$。  

接下来就相当于求$kth-max,k<=11$。  
  
$min(T)$就是第一次出现其中的材料的期望时间。    

出现的概率为  
$$\frac {\sum_{i\in T}p[i]} m$$  

那么期望时间就是  

$$\frac m {\sum_{i\in T}p[i]}$$  

这个可以通过简单感性理解或者列式子得出。   


现在就是求  
$$\sum_T(-1)^{|T|-k}C_{|T|-1}^{k-1}min(T)$$  

显然不能直接枚举，直接枚举时间复杂度$O(2^n)$  

但是发现$k$和$\sum p$不是很大，考虑$dp$。  

设$f[i][j][s]$表示选前$i$个，在$\sum_{x\in T} p[x] = s,k=j$时系数$((-1)^{|T|-k}C_{|T|-1}^{k-1})$的和。  

那我们只需要求出所有的$f[n][k][s]$就行。  

可能会有疑惑，为什么要把$k$这维加进去，$k$不是固定的吗。   

这与转移有关。  

首先不选$i \ \ \ \ \ f[i][j][s] = f[i-1][j][s]$  

如果选了$i$，考虑$i$的影响。  

$|T|$变大了$1$，所以变成负了。  

但是$C_{|T|-1}^{k-1}$也改变了。变成了$C_{|T|}^{k-1}$。  

我们现在考虑$f[i][k][s]$怎么求。  

因为$C_{n}^m=C_{n-1}^{m-1}+C_{n-1}^m$  

每个$C_{|T|-1}^{k-1}=C_{|T|-2}^{k-2}+C_{|T|-2}^{k-1}$  

所以选$i$的情况需要让$|T|$改变的情况下系数可以从前面凑过来。    

也就是说$f[i][k][s]$从$f[i-1][k-1][s-p[i]],-f[i-1][k][s-p[i]]$  
$|T|$增大时，$k$不变就变成了相反数，如果$k$也增大了，负负得正，前面是正号。  


所以$f[i][k][s]=f[i-1][k][s]+f[i-1][k-1][s-p[i]]-f[i-1][k][s-p[i]]$  

用滚动数组压去一维。     

还有的就是关于边界。   
显然，我们只需要初始化$k=s=0$的情况就行。  
但是实际上，$kth-minmax$容斥里规定了$T$并非空集，且$k>0$，所以$k=0$的情况并没有实际意义。  

我们要带回原来的式子求。  
当$k=1,|T|=1$时  
$f[i][1][p[i]]=f[i-1][1][p[i]]+f[i-1][0][0]-f[i-1][1][0]$  
因为$f[i][j][s]$是$((-1)^{|T|-j}C_{|T|-1}^{j-1})$的和  
$f[i][1][s]=f[i-1][1][p[i]]+1$  
所以  
$f[i-1][0][0]-f[i-1][1][0]=1$   

第二项肯定是$0$，所以第一项是$1$。  

即$f[i][0][0] = 1$  
 

 
  
   
时间复杂度$O(nm(n-k))$  

空间复杂度$O((n-k)m)$

```cpp  
#include<bits/stdc++.h>
using namespace std;
int f[12][10020];
int inv[10020];
int n,m,s,x;
const int mod = 998244353;
int main()
{
	scanf("%d%d%d",&n,&s,&m);
	s=n+1-s;
	inv[1] = 1;
	for(int i=2;i<=m;i++)
	  inv[i] = 1LL*inv[mod%i]*(mod-mod/i)%mod;
	f[0][0] = 1;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		for(int k=s;k;k--)
			for(int j=m;j>=x;j--)
			  f[k][j] = (1LL*f[k][j]+f[k-1][j-x]-f[k][j-x])%mod;
	}
	int ans = 0;
	for(int i=1;i<=m;i++)
	  ans=(ans+1LL*f[s][i]*inv[i]%mod)%mod;
	ans = 1LL*ans * m % mod;
	ans = (ans+mod)%mod;
	printf("%d\n",ans);
	return 0;
}

```


  
 
  
    
     
        
        
        

---

## 作者：Infiltrator (赞：1)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P4707)

------------

# Solution

对于每种原料，如果我们能求出它们的期望出现时间，那么第$k$小的期望出现时间就是答案。因为在第$k$小的原料被收集之前，比它更早出现的原料已经被收集过了，第$k$小的原料就是第$k$个被收集到的原料。

第$k$小的原料其实就是第$n-k+1$大的原料，由于第$k$小和第$k$大都不好求，考虑$min-max$容斥。  

$$kthmax(S)=\sum_{T\subseteq S}(-1)^{\left|T\right|-x}\times\binom{\left|T\right|-1}{x-1}min(T)$$

考虑$min(T)$的求法，因为只要有一个原料收集到就行，所以收集到任何一个元素的概率是$\frac{ \sum_{ i \in T } p_i }{ m }$。因为只有两种情况，一种是出现可以收集的原料，一种是不出现，所以这是一个伯努利试验。而伯努利试验的成功期望是成功的概率的倒数，所以$min(T)$就是$\frac{ m }{ \sum_{ i \in T } p_i }$。

接下来考虑计算答案，因为这道题的$n$比较大，所以不能直接暴力枚举子集$T$，但经过观察，我们发现$m$的范围很小，所以我们计算出每个$min(T)$前面的系数，最后枚举所有的$min(T)$乘上系数。  

设$dp_{i,j,k}$表示前$i$个原料，求第$k$大的原料期望出现时间，所有的出现任意一个原料的概率等于$j$的集合前面的系数之和。

考虑转移，如果当前第$i$个原料不在集合$T$中，那么假设我们把它丢掉，不会造成什么影响，$T$的原料个数也不会变，出现任意一个原料的概率也不会改变，所以要加上$dp_{i-1,j,k}$。  

如果第$i$个原料在集合$T$中，这个时候我们把它丢掉，发现对集合$T$造成了影响，集合$T$中少了第$i$个原料，出现任意一个元素的概率发生了变化，得减去$p_i$。那么$dp$状态中的第三个下标$k$会不会发生变化呢？(~~肯定的，不然设它干啥~~)。

当前集合$T$的系数如下

$$\binom{\left|T\right|-1}{k-1}(-1)^{\left|T\right|-k}$$

根据组合数的性质，上面的式子等于

$$\left[ \binom{\left|T\right|-2}{k-1} + \binom{\left|T\right|-2}{k-2}\right] (-1)^{\left|T\right|-k}$$

$$=\binom{\left|T\right|-2}{k-1}(-1)^{\left|T\right|-k} + \binom{\left|T\right|-2}{k-2}(-1)^{\left|T\right|-k}$$

观察前$i-1$个原料构成的大小为$\left|T\right|-1$的集合中选第$k$大的系数，可以得到

$$\binom{\left|T\right|-2}{k-1}(-1)^{\left|T\right|-k-1}=-\binom{\left|T\right|-2}{k-1}(-1)^{\left|T\right|-k}$$

观察前$i-1$个原料构成的大小为$\left|T\right|-1$的集合中选第$k-1$大的系数，可以得到

$$\binom{\left|T\right|-2}{k-2}(-1)^{\left|T\right|-k-1+1}=\binom{\left|T\right|-2}{k-2}(-1)^{\left|T\right|-k}$$

所以当第$i$个原料在集合$T$中时，$dp_{i,j,k}$要加上$dp_{i-1,j-p_i,k-1}$，减去$dp_{i-1,j-p_i,k}$。

初始状态$dp_{i,0,0}=1$，即集合是空集，且求第$0$大，将$k=0$和$\left|T\right|=0$代入得出$dp_{i,0,0}=1$。

然而三个维度的$dp$转移空间会爆炸，所以把第一维滚掉，算完系数之后枚举$min(T)$乘上系数就行。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define ll long long
const int MOD=998244353;
int n,k,m,p[1050];
ll dp[10050][15],ans;
ll ksm(ll a,ll b)
{
	ll tmp=1;
	while(b)
	{
		if(b&1)tmp=(1LL*tmp*a)%MOD;
		a=(1LL*a*a)%MOD;
		b>>=1;
	}
	return tmp;
}
int main()
{
	scanf("%d%d%d",&n,&k,&m);k=n-k+1;
	dp[0][0]=1;
	for(int i=1;i<=n;i++)scanf("%d",&p[i]);
	for(int i=1;i<=n;i++)
		for(int j=m;j>=p[i];j--)
			for(int u=1;u<=k;u++)
				dp[j][u]=(dp[j][u]+dp[j-p[i]][u-1]-dp[j-p[i]][u]+MOD)%MOD;
	for(int i=1;i<=m;i++)ans=(ans+1LL*dp[i][k]*ksm(i,MOD-2)%MOD*m%MOD)%MOD; 
	printf("%lld",(ans+MOD)%MOD);
	return 0;
}
```

---

## 作者：devout (赞：0)

这个题确实很有意思，作为思维题非常不错

首先注意到 $k$ 非常小，所以应该启示我们不是状压就是容斥，这里考虑 min-max 容斥。

用 $E(\max_kS)$ 表示集合 $S$ 中第 $k$ 大的元素的期望值，本题中元素 $i$ 的大小为他第一次出现的次数，设 $k=n-k+1$，那么要求的就是 $E(\max_k U)$

然后大力 min-max 容斥

$$E({\max}_k U)=\sum_{T\subset U}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\min T)$$

$E(\min T)$ 是好求的，设 $p=\sum_{i\in T}p_i$，$E(\min T)=p+2p(1-p)+3p(1-p)^2+\cdots=\dfrac{1}{p}=\dfrac{1}{\sum_{i\in T}p_i}$

那么就有一个显然的 $O(n^2m)$ 的 dp，设 $f[i][j][k]$ 表示前 $i$ 个，选了 $j$ 个，$p_i$ 的和为 $k$ 的方案数

进一步的，我们考虑压缩一维状态，$i$ 显然无法压缩，分式的和的期望也无法压缩，所以只能考虑压缩 $j$。

进一步的，我们要直接维护 $f[i][j][k]$ 表示前 $i$ 个，$p_i$ 的和为 $j$， $\sum_{T\subset U}(-1)^{|T|-k}\binom{|T|-1}{k-1}$ 的和

如果 $i$ 不选，显然是好转移的，而如果选，注意到有恒等式 $\binom{(|T|+1)-1}{k-1}=\binom{|T|}{k-1}+\binom{|T|}{k-2}$，这两个可以分别用 $f[i-1][j-p_i][k-1]$ 和 $f[i-1][j-p_i][k]$ 来表示

所以最终的转移方程就是 $f[i][j][k]=f[i-1][j-p_i][k-1]-f[i-1][j-p_i][k]$

考虑初值，按照定义来讲 $f[0][0][k]=0$，这个显然是不合理的，原因就是我们在转移的时候没有考虑一些边界情况，所以我们可以考虑根据转移倒推出来 $f[0][0][0]=0,f[0][0][k]=-1(k>0)$

复杂度 $O(nm(n-k))$

```cpp
#include <bits/stdc++.h>

using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

const int N=1005;
const int M=10005;
const int K=15;
const int mod=998244353;

typedef long long ll;
typedef double db;

# define chkmax(a,b) a=max(a,b)
# define chkmin(a,b) a=min(a,b)
# define PII pair<int,int>
# define mkp make_pair

template<typename T> void read(T &x){
    x=0;int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,k,m;
int p[N];
int f[M][K];
int inv[M];
int ans;

int inc(int x,int y){
    return x+y>=mod?x+y-mod:x+y;
}

int dec(int x,int y){
    return x<y?x-y+mod:x-y;
}

int main()
{
    # ifndef ONLINE_JUDGE
    freopen("testdata.in","r",stdin);
    //freopen("test1.out","w",stdout);
    # endif
    read(n),read(k),read(m),k=n-k+1;
    Rep(i,1,n)read(p[i]);
    inv[1]=1;
    Rep(i,2,m)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
    f[0][0]=0;
    Rep(j,1,k)f[0][j]=mod-1;
    Rep(i,1,n)
        _Rep(j,m,p[i])
            _Rep(l,k,1)
                f[j][l]=inc(f[j][l],dec(f[j-p[i]][l-1],f[j-p[i]][l]));
    Rep(i,0,m)ans=inc(ans,1ll*f[i][k]*m%mod*inv[i]%mod);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：tzc_wk (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P4707)

首先看到这种求形如 $E(\max(T))$ 的期望题，可以套路地想到 Min-Max 容斥 $\max(S)=\sum\limits_{T\subseteq S}(-1)^{|T|-1}\min(T)$，将其转化为容易计算的 $E(\min(T))$ 进行计算。

不过这题有些不同的一点是我们要求的是第 $k$ 大而不是最大值，无法直接 Min-Max，这时就要用到一个叫扩展 Min-Max 的东西了，首先抛出式子：$\max_k(S)=\sum\limits_{T\subseteq S}(-1)^{|T|-k}\dbinom{|T|-1}{k-1}\times\min(T)$，其中 $\max_k(S)$ 为 $S$ 中第 $k$ 大的值。考虑证明，其实和 Min-Max 证明那一套差不多罢，考虑将 $S$ 中的数从小到大排序 $a_1,a_2,\cdots,a_n$，我们按照套路枚举 $\min(T)=a_i$，那么前面那一坨系数等价于选出 $a_{i+1},a_{i+2}\cdots,a_{n}$ 的一个子集 $T$，再从 $T$ 中选 $k-1$ 个数，贡献 $(-1)^{|T|+1-k}$（指数上的 $+1$ 是因为真正的 $T$ 是我们选出的 $T$ 与 $\{a_i\}$ 的并），所有这样的选法的贡献之和，那么我们就考虑换个角度，枚举选出的 $k-1$ 个数，显然若 $i>n-k+1$ 贡献就是 $0$，否则有 $\dbinom{n-i}{k-1}$ 种选法，再枚举在 $T$ 中却不再选出的 $k-1$ 个数的部分 $S$，那么 $S$ 显然可以为剩余 $n-i-(k-1)$ 个数的任意一个子集，这部分的贡献就是 $\sum\limits_{j=0}^{n-i-(k-1)}\dbinom{n-i-(k-1)}{j}(-1)^{j+(k-1)+1-k}=\sum\limits_{j=0}^{n-i-(k-1)}\dbinom{n-i-(k-1)}{j}(-1)^{j}=[i=n-k+1]$，也就是说只有 $i=n-k+1$ 时候这部分贡献为 $1$，其余贡献都是 $0$，而 $i=n-k+1$ 时前面那部分贡献刚好也是 $1$，因此 $\sum\limits_{T\subseteq S}(-1)^{|T|-k}\dbinom{|T|-1}{k-1}\times\min(T)=a_{n-k+1}$，证毕。

接下来考虑原题，首先本题 $k$ 的意义实际上是 $E(\min_k(T))$，因此我们需做一个简单的转化将其变为 $E(\max_k(T))$ 的形式，即 $k\leftarrow n-k+1$，而 $|n-k|\le 10$，也就是说变换后的 $k\le 11$，刚好。然后考虑怎样计算 $\max_k(S)$ 的表达式，显然 $E(\min(T))=\dfrac{m}{\sum\limits_{x\in T}p_x}$（这里我们假设 $T$ 为下标集合而不是下表对应的 $p_i$ 的集合），也就是说虽然集合 $T$ 的数量可以达到 $2^n$，但是我们可以将所有 $E(\min(T))$ 相同的集合 $T$ 划分在一个等价类中，那么这些集合最多划分为 $m$ 个等价类，这样就可以 $dp$ 了，记 $dp_{i,j,s}$ 为考虑了前 $i$ 个数，选中的集合上述计算式中的 $k=j$，$\sum\limits_{x\in T}p_x=s$，所有这样的集合 $T$ 的 $(-1)^{|T|-j}\dbinom{|T|-1}{j-1}$ 之和，考虑转移，若 $i$ 不选择那么显然有 $dp_{i,j,s}\leftarrow dp_{i-1,j,s}$，否则我们相当于在 $|T|$ 中加入了一个元素 $p_i$，应当从 $dp_{i-1,*,s-p_i}$ 转移来，我们假设 $T$ 满足 $T$ 只由前 $i$ 个数组成，并且 $\sum\limits_{x\in T}p_x=s-p_i$，那么贡献就说 $\sum(-1)^{|T|+1-j}\dbinom{|T|}{j-1}$，我们把前面指数上的 $1$ 提出来，变为 $\sum-(-1)^{|T|-j}\dbinom{|T|}{j-1}$，再套个组合数递推公式，$\sum-(-1)^{|T|-j}(\dbinom{|T|-1}{j-1}+\dbinom{|T|-1}{j-2})$，噫，好！这下这东西就容易计算了，因为显然它等于 $\sum-(-1)^{|T|-j}\dbinom{|T|-1}{j-1}+(-1)^{|T|-j+1}\dbinom{|T|-1}{j-2})$，而你稍微转化一下就能变成 $-dp_{i-1,j-1,s-p_i}+dp_{i-1,j-2,s-p_i}$，这样就可以在常数时间内实现 $dp$ 的转移了，即：$dp_{i,j,s}=dp_{i-1,j,s}-dp_{i-1,j-1,s-p_i}+dp_{i-1,j-2,s-p_i}$。当然每个数也可以单独成一组，即如果 $j=1$，那么 $dp_{i,j,p_i}\leftarrow dp_{i,j,p_i}+1$。

时空复杂度均为 $nmk$，由于这题直接开数组大小会达到 $10^8$，会 $\text{MLE}$，因此需要用滚动数组/01背包倒序枚举的套路将第一维优化掉，我相信做这一题的人应该不至于不能理解这一步罢……因此就不再赘述了。

代码异常简洁……

```cpp
const int MAXK=11;
const int MAXM=1e4;
const int MOD=998244353;
int n,k,m,dp[MAXK+5][MAXM+5],inv[MAXM+5];
int main(){
	scanf("%d%d%d",&n,&k,&m);k=n+1-k;
	for(int i=(inv[1]=1)+1;i<=m;i++) inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1,t;i<=n;i++){
		scanf("%d",&t);
		for(int l=m;l>=t;l--) for(int j=k;j;j--){
			dp[j][l]=(dp[j][l]+(-dp[j][l-t]+dp[j-1][l-t]+MOD)%MOD)%MOD;
		} dp[1][t]=(dp[1][t]+1)%MOD;
	} int ans=0;
	for(int i=1;i<=m;i++) ans=(ans+1ll*dp[k][i]*inv[i]%MOD*m)%MOD;
	printf("%d\n",ans);
	return 0;
}
```



---


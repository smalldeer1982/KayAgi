# 画画

## 题目描述

yww 要开始画画了！

地上有一张纸，纸上有 $n$ 个点。

yww 要在结点之间连边。yww 的连边是非常有规律的。每次他会拿好笔，选定一个点，从这个点 $x$ 向其他点 $y$ 连边，再从 $y$ 向其他点 $z$ 连边，依次类推，直到连回点 $x$。yww 会进行若干次这样的连边。并且，自始至终，yww 都不会在两个结点之间连超过一条边。

yww 想知道，他一共能画出多少种本质不同的图。两个图本质相同，当且仅当存在一个点到点的置换，使得对于原图和在置换作用下的新图，任意两点之间要么都没有连边，要么都有连边。你只需要将答案对 $998244353$ 取模。

一句话题意，$n$ 个点的无标号的每个连通块有欧拉回路的图的个数。

## 说明/提示

对于 $10 \%$ 的数据，$n \le 5$。

对于 $40 \%$ 的数据，$n \le 10$。

对于 $100 \%$ 的数据，$1 \le n \le 50$。

## 样例 #1

### 输入

```
4```

### 输出

```
3```

## 样例 #2

### 输入

```
5```

### 输出

```
7```

# 题解

## 作者：Sdchr (赞：43)

去年差不多这个时间弄出的题，感觉这道题还是比较有灵性的。自己写个题解。

先考虑一个辅助问题： n 个点的无标号图的个数 ans 。网上资料很多。直接套用 Burnside 引理，枚举点的置换（一种点的置换对应 ans * n! 种带标号方案的置换，这才是实际枚举的东西），可以将点划分为若干个循环节，考虑每个循环节内的点可以怎样连边，以及两个循环节间的点可以怎样连边。发现循环节大小的多重集合相同时，累加量一定，所以只需要枚举分拆方案，再乘上这个分拆方案对应的置换个数。

现在回到这个问题。同样的，我们枚举循环节的多重集合。

先考虑循环节内的连边：对大小为 2s+1 的循环节，有 s 种边可以连，一种边的连接会形成一个换，对点的度数的奇偶性不造成影响；对大小为 2s 的循环节，有 s-1 种边对点的度数的奇偶性不造成影响，一种边对循环节内所有点的奇偶性造成影响，这启发我们把一个循环节看做一个大点，对于 2s+1 的情况，有一次机会按它一下，把它的奇偶性改变。

再考虑循环节之间的连边，大小分别为 a、b 的两个循环节，有 (a, b) 种连边方案，每种连边方案总共连 ab/(a, b) 条边，对 a 中的每个点连 n1 = a/(a, b) 条，n2 = b/(a, b) 条。若 n1,n2 都是偶数，则不造成影响。若 n1 为奇数，n2 为偶数，相当于拥有了一次改变 a 奇偶性的机会。若 n1 为偶数，n2 为奇数，相当于拥有了一次改变 b 奇偶性的机会。若 n1 为奇数，n2 为奇数，则在 a, b 之间连上一条边，表示有一次机会将二者的奇偶性一同改变。

综上，我们可以建出一张图，点权最初全是 0 。对每个点，有 d[i] 次机会使其异或 1 ，对于一条边 e ，有 n[e] 次机会使两边异或 1 。问有多少种方案使得最终所有点的点权为 0 。

我们分连通块来考虑，然后累乘。设总共可以进行 p 次点操作，q 次边操作。这是一个经典问题：存在边操作能使点操作成立，当且仅当点操作的次数为偶数。可以直接构造 DFS 树，利用树形 DP 来证明可行性。至于必要性，因为每次边操作之后所有点的和的奇偶性不变。总之，就是在 p 次操作中选择偶数次的方案，乘上 2^q 。对于前者，等于 2^(p-1) ，因为考虑前 p-1 次操作任意，最后一次操作有且仅有一种方式对应。

突然觉得去年的自己很nb，可惜太浪了不认真训练，也不认真学字符串，我的集训队和THU就这样没了。

---

## 作者：Log_x (赞：27)

## Problem

> 求 $n(n \le 50)$ 个点无标号的每个连通块都有欧拉回路的图的个数。

> 答案对 $998244353$ 取模。

## Solution

- 每个连通块都有欧拉回路即为每个点的度数都为偶数。

- 为方便起见，先把无标号转成有标号。

- 定义两个图同构当且仅当存在一种点置换，使得其中一个图在点置换作用下得到的新图和另一个图的连边情况完全相同。

- 考虑 `burnside 引理`：

$$\begin{aligned}
L = \frac{1}{|G|} \sum_{g \in G}|F_g|\\
\end{aligned}$$

- 因为所有点置换得到的边置换也是一个群，且点置换和得到的边置换构成双射，所以我们可以通过枚举点置换来计算边置换下的不动点个数，且边置换下的不动点个数也恰好满足我们对图同构的定义。

- 此时群 $G$ 的大小为 $n!$，恰好对应所有的排列。

- 把某一种点置换 $g$ 分解成若干个轮换的乘积，注意到如果轮换大小构成的多重集相同，对答案产生的贡献也相同。

- 因此我们只需要枚举轮换大小构成的多重集，设 $H$ 表示给定轮换大小的多重集时不动点的个数，则：

$$\begin{aligned}
L = \frac{1}{n!} \sum \limits_{^{l_1 \le l_2 \le ... \le l_k}_{l_1 + l_2 + ... + l_k = n}} \frac{n! \prod \limits_{i = 1}^{n} (l_i - 1)!}{\prod \limits_{i = 1}^{k}l_i! \prod \limits_{i = 1}^{n} c_i!}H(l_1, l_2, ... , l_k)\end{aligned}$$

$$\begin{aligned} L = \sum \limits_{^{l_1 \le l_2 \le ... \le l_k}_{l_1 + l_2 + ... + l_k = n}} \frac{1}{\prod \limits_{i = 1}^{k}l_i \prod \limits_{i = 1}^{n} c_i!}H(l_1, l_2, ... , l_k)\end{aligned}$$

- 第一行 $H$ 前面的系数表示轮换大小分别为 $l_1, l_2, ... , l_k$ 的排列个数，其中 $c_i$ 表示 $l_1, l_2, ... ,l_k$ 中 $i$ 的出现次数。

- 具体地，排列个数的计算可以这样考虑：
  
  1. 枚举所有排列 （$n!$），先不考虑每个轮换内部的构成，即除以 $\prod \limits_{i = 1}^{k} l_i!$；
  
  2. 每个轮换可以看做一个有向环，$l_i$ 个点构成有向环的方案数是 $(l_i - 1)!$，所以要乘以 $\prod \limits_{i = 1}^{k} (l_i - 1)!$；
  
  3. 大小相同的轮换之间是无序的，所以要除以 $\prod \limits_{i = 1}^{n}c_i!$。

- 考虑怎样计算 $H(l_1, l_2, ... , l_k)$。

- 对于第 $i$ 个轮换，轮换内距离相同的所有点对的连边情况相同，而距离共有 $\lfloor \frac{l_i}{2} \rfloor$ 种，总的连边情况共有 $2^{\lfloor \frac{l_i}{2} \rfloor}$ 种。
  
  - 若 $l_i$ 为奇数，固定距离 $x$ 时，每个点都恰好可以引出两条边，因此对于每一种连边情况都能保证轮换内每个点度数的奇偶性不变。
  
  - 若 $l_i$ 为偶数，
     
     - 当 $x < \frac{l_i}{2}$ 时，情况和 $l_i$ 为奇数相同。
     
     - 当 $x = \frac{l_i}{2}$ 时，每个点只能恰好引出一条边，因此每一种连边情况都恰好能使轮换内每个点度数的奇偶性改变。

- 考虑任意两个轮换 $i,j$ 之间的连边情况，枚举两个轮换上的点对 $(x, y)$，则将 $(x, y)$ 同时顺次移动得到的所有点对和 $(x,y)$ 的连边情况相同。

- 因此共有 $\frac{l_i l_j}{lcm(l_i, l_j)} = \gcd(l_i, l_j)$ 组点对，每组点对的连边情况相同，且对于第 $i$ 个轮换上的每一点都恰好可以引出 $e_1 = \frac{l_j}{\gcd(l_i, l_j)}$ 条边，对于第 $j$ 个轮换上的每一点都恰好可以引出 $e_2 = \frac{l_i}{\gcd(l_i, l_j)}$ 条边。
  
  - 若 $e_1$ 和 $e_2$ 都为偶数，任意一种连边情况都不会改变轮换 $i,j$ 上每个点度数的奇偶性；
  
  - 若 $e_1$ 和 $e_2$ 都为奇数，任意一种连边情况都恰好会使轮换 $i,j$ 上每个点度数的奇偶性改变；
  
  - 若 $e_1$、$e_2$ 中恰好有一个为奇数，任意一种连边情况都恰好会使某一个轮换上每个点度数的奇偶性改变。

- 经过这些讨论，我们发现所有能改变奇偶性的操作都是对于整个轮换，因此我们可以把每个轮换缩成一个点，先将不会影响奇偶性的操作的方案数乘到答案上，把问题简化为：

> 给定 $k$ 个点和若干条边，每个点的初始点权为 $0$，每个点 $x$ 可以有 $cntp_x$ 次机会使点权异或 $1$，每条边 $(x, y)$ 可以有 $cnte_{(x, y)}$ 次机会使 $x, y$ 两个端点的点权同时异或 $1$，询问使得每个点最终的点权仍然都为 $0$ 的方案数。

- 依次考虑每个连通块的方案，将答案累乘。

- 对于每个连通块，任意找出一棵 `DFS树`，注意到如果我们确定了所有非树边和点的方案，树边的方案是唯一确定的，并且存在合法的方案当且仅当单点的操作次数和为偶数。

- 证明：
  
  1. 单点的操作使得连通块中恰好有偶数个点权为 $1$的点；
  
  2. 非树边的操作不会改变连通块中点权为 $1$ 的点的个数的奇偶性；
  
  3. 从 `DFS树` 的叶子结点开始往上推出每条树边的状态，对一个点 $x$ 指向其父结点的边操作当且仅当 $x$ 的点权为 $1$，并且每次只能使点权为 $1$ 的点的个数减少 $2$ 或不变，因此树边的方案唯一确定且合法。

- 于是一个点数为 $s$ 的连通块的方案为 $\begin{aligned} 2^{\max\{(\sum cntp_x) - 1, 0\} + (\sum cnte_{(x, y)}) - s + 1}\end{aligned}$。

- 设 $p_n$ 表示 $n$ 的拆分数，时间复杂度 $\mathcal O(n^2 p_n)$，可以通过。

## Code

```cpp
#include <bits/stdc++.h>

const int N = 55;
const int M = 125e3 + 5;
const int mod = 998244353;

int n, m, ans;
int fra[N], inv_fra[N], inv[N];
int ex[M], g[N][N], l[N], c[N];
int sze[N], fa[N], cnt_p[N], cnt_e[N];

template <class T>
inline T Max(T x, T y) {return x > y ? x : y;}

inline void add(int &x, int y)
{
	x += y;
	x >= mod ? x -= mod : 0;
}

inline void mul(int &x, int y)
{
	x = 1ll * x * y % mod;
}

inline int quick_pow(int x, int k)
{
	int res = 1;
	while (k)
	{
		if (k & 1)
			res = 1ll * res * x % mod;
		x = 1ll * x * x % mod;
		k >>= 1;
	}
	return res;
}

inline int ufs_find(int x)
{
	return fa[x] == x ? x : fa[x] = ufs_find(fa[x]);
}

inline void ufs_merge(int x, int y, int e)
{
	int tx = ufs_find(x),
		ty = ufs_find(y);
	if (tx != ty)
	{
		if (sze[tx] > sze[ty])
			std::swap(tx, ty);
		fa[tx] = ty;
		sze[ty] += sze[tx];
		cnt_p[ty] += cnt_p[tx];
		cnt_e[ty] += cnt_e[tx] + e;
	}
	else
		cnt_e[ty] += e;
}

inline void solve(int k)
{
	int res = 1;
	for (int i = 1; i <= k; ++i)
		mul(res, inv[l[i]]);
	for (int i = 1; i <= n; ++i)
		mul(res, inv_fra[c[i]]);
	for (int i = 1; i <= k; ++i)
	{
		fa[i] = i;
		cnt_e[i] = 0;
		cnt_p[i] = 0;
		sze[i] = 1;
	}
	for (int i = 1; i <= k; ++i)
	{
		if (!(l[i] & 1))
			++cnt_p[i];
		mul(res, ex[l[i] - 1 >> 1]);
	}
	for (int i = 1; i < k; ++i)
		for (int j = i + 1; j <= k; ++j)
		{
			int e = g[l[i]][l[j]];
			bool e1 = (l[j] / e) & 1,
				 e2 = (l[i] / e) & 1;
			if (e1 && e2)
				ufs_merge(i, j, e);
			else if (e1)
				cnt_p[ufs_find(i)] += e;
			else if (e2)
				cnt_p[ufs_find(j)] += e;
			else 
				mul(res, ex[e]);
		}
	for (int i = 1; i <= k; ++i)
		if (ufs_find(i) == i)
			mul(res, ex[Max(0, cnt_p[i] - 1) + cnt_e[i] - sze[i] + 1]);
	add(ans, res);
}

inline void dfs(int k, int s, int t)
{
	if (!s)
		return solve(k - 1);
	for (int i = t; i <= s; ++i)
	{
		l[k] = i;
		++c[i];
		dfs(k + 1, s - i, i);
		--c[i];
	}
}

int main()
{
	scanf("%d", &n);
	fra[0] = 1;
	for (int i = 1; i <= n; ++i)
		fra[i] = 1ll * fra[i - 1] * i % mod;
	inv_fra[n] = quick_pow(fra[n], mod - 2);
	for (int i = n; i >= 1; --i)
		inv_fra[i - 1] = 1ll * inv_fra[i] * i % mod;
	inv[0] = inv[1] = 1;
	for (int i = 2; i <= n; ++i)
		inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
	ex[0] = 1;
	for (int i = 1, im = n * n * n; i <= im; ++i)
		add(ex[i] = ex[i - 1], ex[i - 1]);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			g[i][j] = std::__gcd(i, j);
	dfs(1, n, 1);
	printf("%d\n", ans);
}
```


---

## 作者：WeLikeStudying (赞：14)

- 作者并不只希望理解群论的基本内容，还希望就此理解抽象代数的一些知识。
- 作者虽然退役了，但是信息学的光芒将会照亮这个时代。
- 作者的内心也应该平和一点，作者存在着诸多不足，这些不足是应该，也是必须去弥补的，作者的目标不应该首先是在信息学中取得成就，而应该首先拥有完整的人格。

**借鉴**
- [这篇](https://www.luogu.com.cn/blog/command-block/qun-lun-xiao-ji)，[这篇](https://oi-wiki.org/math/group-theory/)，以及组合数学引论。
- ~~没用的东西~~专业的群论知识我尽量不写，因为~~作者很懒~~便于理解。
- 以下的内容极其不专业。

**群**
- 定义集合 $S$ 与二元运算 $\times$ 满足：
$$\forall a,b\in S,a\times b\in S$$
$$\forall a,b,c\in S,(a\times b)\times c=a\times( b\times c)$$
$$\exists e\in S,\forall a\in S,a\times e=a$$
$$\forall a\in S,\exists b\in S,a\times b=e$$
- 即封闭性，结合律，单位元，逆元（其中 $a$ 的逆元为 $a^{-1}$），称 $S$ 在 $\times$ 运算下是个群。

**简单定理**
- 单位元唯一：$e_1,e_2$ 是单位元则 $e_1\times e_2=e_1=e_2$。
- $a\times c=b\times c\to a=b$：同乘逆元。
- 逆元唯一：$a\times b=e=a\times c\to b=c$。
- 对于任意有限群，设 $a^b$ 是 $b$ 个 $a$ 相乘的结果，则对于每个 $a$ 都存在 $\text{ord}(a)$ 满足 $a^{\text{ord}(a)}=e$，且 $a^{-1}=a^{\text{ord}(a)-1}$。
- 直接构造 $a^0,\cdots,a^n$，根据鸽巢原理肯定有两个相等，设 $a^x=a^y$ 则 $a^{y-x}=e$，非常合理对吧。

**置换群**
- 置换是一个排列，置换的乘法就是把 $i$ 换成 $p_i$。
- 置换不满足交换律，但满足结合率，单位元是 $i=p_i$，逆元也很好求，所以 $n$ 元置换组成的结合与乘法直接成群。
- 我们用环表示置换，即把 $i\to p_i$ 的边表示出来形成的多个环写出来。
- 我们也喜欢用几个基本置换，把大小为 $1$ 的置换隐去，表示所有置换。
- 置换还可以和整数运算，具体细节十分简单就不重点提及，我们通过把集合标号成整数的方式来实现它。

**[例题 1](https://www.luogu.com.cn/problem/P4709)**
- 给定一个置换，求有多少个置换的 $n$ 次方等于该置换。
- 将置换表示成环，发现一个大小为 $k$ 的环在 $n$ 次方后会裂解为 $\gcd(n,k)$ 个大小为 $k/\gcd(n,k)$ 的环。
- 考虑原置换的所有大小相同的环。
- 那么接下来问题就是这个样子：将 $t$ 个有标号球分组，大小为 $i$ 的组的贡献是 $W(i)=(i-1)!k^{i-1}$（钦定第一个小环直接连的 $i-1$ 个节点表示整个环），且贡献相乘，要求每组盒子的大小满足某个条件，求所有情况的贡献的和。
- 设 $f(t)$ 为使用了 $t$ 个环的方案数，则：
$$f(t)=\sum_{i=1}^t[\gcd(ik,n)=i]C(t-1,i-1)W(i)f(t-i)$$
- 注意环内部无序，所以组合数设为 $C(n-1,i-1)$。
- 注意到你发现这要求 $i\mid n$，所以枚举量是 $O(n\sigma_0(n))$ 的，[代码](https://www.luogu.com.cn/paste/muf50dui)。

**前置知识**
- 我们研究的问题是在一个集合 $|S|$ 内的元素，通过置换群 $|G|$ 的置换，形成的等价类个数的问题，请务必注意这点。
- 不动点：设 $k\times p=k$ 则元素 $k$ 是置换 $p$ 下的不动点，$p$ 形成的集合组成的置换群为 $Z_k$ 为 $k$ 不动置换类，经过 $p$ 的不动点组成集合 $C_p$。
- 等价类：设 $E_k$ 为元素 $k$ 经过置换群 $G$ 中的元素能到达的集合，由于群的特性，等价类中任何一个元素的等价类都是该等价类，而且每个元素至少是完全图的连边，都可以一步到达。
- 注意不动置换类是置换群，等价类是元素集合。
- 等价类和不动点定理：$|Z_k|\times |E_k|=|G|$，即使得 $k$ 不动的置换个数，乘上 $k$ 的等价类个数，恰好是置换总个数。
- 我们设 $E_k=\{a_1,\cdots a_m\}$，再对每个 $a_i$ 瞎弄一个置换 $p_i$，使得 $k\times p_i=a_i$，然后让 $G_i=Z_k\times p_i$（也就是让每个置换和该置换搞下形成新的置换群），你发现对于 $i\ne j$，$G_i\cap G_j=\varnothing$，且 $|G_i|=|Z_k|$，剩下的唯一问题在于证明 $G_i$ 不交。
- 由于显然 $G_1\cup\cdots\cup G_m\subseteq G$，而对于任意 $p\in G$，一定存在 $k\times p=a_i$，所以 $G\subseteq G_1\cup\cdots\cup G_m$，所以 $|Z_k|\times |E_k|=|G|$。

**Burnside 引理**
- 对于 $|S|$ 内元素形成的等价类个数 $l$：
$$l=\frac 1{|G|}\sum_{p\in G}|C_p|$$
- 也就是等价类个数为在各个置换下不动的元素个数的平均数。
- 设 $f(i,j)$ 表示元素 $i$ 在置换 $j$ 的作用下是否不动，返回 $0/1$。
$$\sum_{i\in S}f(i,j)=|C_j|$$
$$\sum_{j\in G}f(i,j)=|Z_i|$$
- 因此：
$$\sum_{i\in S}|Z_i|=\sum_{j\in G}|C_j|$$
- 设 $l$ 个等价类分别为 $E_1,\cdots,E_l$。
- 原式直接变成：
$$\sum_{p\in G}|C_p|=\sum_{i\in S}|Z_i|=\sum_{i=1}^l|Z_i||E_i|=l|G|$$
- 证明完毕，对于染色问题（很非形式化的表达）我们还有个小定理。

**Pólya 定理**
- 给 $S$ 中的元素染个色！假设有 $n$ 种元素，每种元素有 $m$ 种染色方法，设 $G$ 是这 $n$ 种元素的置换群，则染色形成的等价类个数：
$$\frac1{|G|}\sum_{p\in G}T(p)$$
- $T(p)$ 表示在 $p$ 置换下的不动点染色方案数。
- 这个怎么理解？咱们当然用上面那个定理，搞一个有 $m^n$ 个元素的集合 $S'$，然后把映射也挪到上面，变成群 $G'$。
- 此时答案是：
$$l=\frac 1{|G'|}\sum_{p\in G}|C_p|$$
- 你发现 $|C_p|$ 很熟悉，就是 $T(p)$，然后你发现 $G'$ 只是元素变成了更长的排列，大小根本就没变，然后就证完了。
- 等等，如何求 $T(p)$ 呢？还记得循环拆解吗？你发现每个循环必须颜色相同并且只有这个条件，设 $d(p)$ 为 $p$ 置换的循环个数，完整的定理叫做：
$$\frac1{|G|}\sum_{p\in G}m^{d(p)}$$

**[习题 1](https://www.luogu.com.cn/problem/P4980)**
- 纯纯模板题，你掐指一算，发现循环移位 $k$ 能够拆成 $\gcd(k,n)$ 个循环，所以答案是：
$$\frac1n\sum_{i=1}^nm^{\gcd(i,n)}$$
- 强行枚举指数（它一定是 $n$ 的约数）我们得到：
$$\frac1n\sum_{d|n}m^d\varphi(n/d)$$
- 连莫比乌斯反演都不用，真的惊呆了，可以强行使用二次筛法做到亚指数复杂度，[代码](https://www.luogu.com.cn/paste/2c9e4iwm)。
- 一定要注意这个定理只能在成群的条件下使用，否则会出现严重的错误。

**[习题 2](https://www.luogu.com.cn/problem/P4727)**
- 图同构判定都是 Open 的你直接跳到计数？还给出了 $n\le 60$ 的奇葩范围，我也是醉了，果断打表，[表](http://oeis.org/A000088/b000088.txt)，这个表足足给到了 $n\le 87$，如果你有能耐打它对某个数取模的结果，那也是可以的，[代码](https://www.luogu.com.cn/paste/lyxl7tn0)，当然，这种做法太不讲武德了。
- 这个提示也告诉你只要你掌握了理论上能跑出来的做法就不需要担心常数了（虽然[这题](https://www.luogu.com.cn/problem/P4128)加大了难度，还更改了模数，为我们提供了一个先进示范）。
- 容易发现这个问题可以转化成边染色问题，而置换可以理解成对点进行重排，但是这个置换群的大小是 $n!$，甚至无法逐个枚举。
- 考虑每个点置换形成的一堆环，显然，环的大小分别相同的时候的时候，贡献（这个置换的不动点个数）肯定相同，而环的大小各不相同的情况有多少呢？[这个](https://oeis.org/A000041)数列（还有[这题](https://www.luogu.com.cn/problem/P6189)）告诉我们，大概有 $\frac1{4n\sqrt3} e^{\pi\sqrt{2n/3}}$，是奇妙的亚指数复杂度，在 $n=60$ 时只有 $966467$ 个状态。
- 问题在对于一堆数如何求它形成的置换个数，由于个数固定，我们可以先组合划分，再求原排列，但是还要考虑相同个数的问题，如果有多个相同的话还要乘回来，这个排列又是固定的，容易算的。
- 问题还在于求这类置换的不动点个数，我们可以暴力并查集染色，也可以利用圆圈，对圈内与圈外分别讨论：对于圈内的边所连两点的最短距离相同的一定在同一个等价类，对于圈外的容易发现它和公约数有关，[代码](https://www.luogu.com.cn/paste/e97lz7je)，[有色图代码](https://www.luogu.com.cn/paste/15679dze)。

**[习题 3](https://www.luogu.com.cn/problem/P4916)**
- 置换是套路的置换，枚举置换然后发现最终还是分成大小为 $n/\gcd(n,i)$ 的环。
- 如果 $m/\gcd(n,i)$ 不是整数，那么显然不存在。
- 你发现或许需要特判。
- 否则，我们需要满足小环的最长子段长度不超过 $k$。
- 问题是将 $m$ 个白色魔力珠插入到 $n$ 个黑色魔力珠内，使得连续黑色魔力珠长度不超过 $k$，设方案为 $F(n,m)$。
- 考虑断环为链，设链上的问题为 $G(n,m)$，则枚举第一个白魔力珠和最后一个白魔力珠的间隙，问题被转化为：
$$F(n,m)=\sum_{i=0}^k(i+1)G(n-i,m-1)$$
- 对于链上的问题，不考虑 $k$ 的限制，答案即 $C(n+m-1,m)$，而如果考虑 $k$ 的限制应该如何？
- 还记得[容斥](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/mei-hao-di-xi-ri)吗？钦定 $i$ 个地方的元素超过 $k$，那么式子就是：
$$G(n,m)=\sum_{i=0}(-1)^iC(m,i)C(n-i\cdot (k+1)+m-1,m-1)$$
- 这意味着钦定的位置都被放上了 $k+1$ 个球，容易用 $O(n)$ 的时间复杂度计算 $F(n,m)$。
- 建议仔细复盘一下组合数学。
- 因此，原问题的复杂度即为 $O(n+\sigma_1(\gcd(n,m)))$，[代码](https://www.luogu.com.cn/paste/80y89jqr)。

**[习题 4](https://www.luogu.com.cn/problem/P4708)**
- 虽然看上去只是加上了一点点限制，但问题的解决的确困难了许多：要求所有点的度数都为偶数。
- 进行套路转换之后，问题变成：在一个置换环下不动的连边方案，仍然要求所有点的度数都为偶数。
- 套路地对环内环间进行讨论，你发现对于环内的情况，只有一种情况，存在一种连边能够改变整个环的奇偶性：环的大小为偶数的时候。
- 而在环间，情况也是类似，即要么不改变，要么就改变整个环所有点的奇偶性。
- 因此，现在问题变成：有 $n$ 个点和一些操作可以翻转点的颜色（翻转一个点或者两个点），问让点颜色不动的翻转方案数，这是一个经典的问题，方法如下：
- 将操作看成边，不连通的情况分开讨论。
- 容易发现边操作不会改变颜色个数的奇偶性，所以点操作总共只能操作偶数个。
- 对于一个连通图，任意找出一棵生成树，首先考虑只对树边进行操作的情况：对于任何一种染色方案，你发现如果有奇数个黑点则不可能染色，而我们总存在恰好一种方案可以贪心地把除了根以外的节点染成白色（从叶节点开始暴力），所以你发现约束条件只有点染色必须在这个连通分量染偶数个，其它的完全没有限制！
- 因此这个问题终于可以完成了！可以通过的复杂度！[代码](https://www.luogu.com.cn/paste/0yv8a9qf)。

---

## 作者：PokerKing (赞：9)

可以枚举 $n!$ 种置换，求出每种置换下的不动点个数。

而每条边又分在相同置换和不同置换内两种

### 相同置换内求不动点个数

在一个置换内的不动点个数是 $\frac{n}{2}$，考虑如果有边 $(x,x+t)$，那么必有边 $(x+1,x+t+1)\cdots%$ 以此类推。并且考虑 $t$ 与 $n-t$ 其实是等价的。

### 不同置换内求不动点个数

考虑两个置换的大小为 $A,B$，那么一条边会引申出 $\operatorname{lcm}(A,B)$ 条边，于是不动点个数其实是 $\gcd(A,B)$。

而这些等价类可以出现可以不出现，对答案的贡献是 $2^{cnt}$。

发现只与置换的大小有关，暴力枚举拆分，算每个拆分的方案数，先有一个排列的方案数 $n!$，一个循环的贡献是 $\frac{1}{len}$，大小相同的循环之间无序，有一个 $\frac{1}{cnt_{i}!}$。

考虑欧拉回路这个更强的限制，即每个点的度数为偶数，同样考虑一个置换内的边。

- 若长度为奇数 $2\times l+1$，所有置换出不出现对点都是偶数的影响，可以不管。
- 若长度为偶数 $2\times l$，其中 $l-1$ 个不动点对奇偶性是没有影响的，而最后一个取所有对角线的不动点会使所有点度数加 $1$。

考虑一个置换间的边
对一个 $A$ 中的点度数的影响是 $\frac{B}{\gcd(A,B)}$，对 $B$ 中的影响是 $\frac{A}{\gcd(a,b)}$。

我们发现现在可以先将贡献乘上没有影响的 $2^{cnt}$。

然后可以有 $d_id$ 种方法使第 $i$ 个置换的度数全部 $+1$，$e_{u,v}$ 中方法使 $u,v$ 置换的度数都 $+1$。

然后就是求使得满足限制的方案数，可以高斯消元异或矩阵，贡献为最后的自由元个数。

### 但还有更好的方法。

我们对现在 $e_{u,v}$ 形成的连通块，随便求一棵生成树，生成树外的边随便选，除根以外的点随便选。

发现根和树边对应着唯一的可行解。

点数为 $n$，点的选择数为 $s$，边的选择数为 $m$ 的一个连通块。

方案数就是 $2^{m-(n-1)+\max(0,(s-1))}$。

用并查集维护即可。

主要就是求不动点个数，考虑在一个置换内或置换间的不动点，暴力枚举拆分数乘上方案数，通过一个生成树的构造快速求得可行解个数，挺巧妙的。

```cpp
#include<bits/stdc++.h>
#define cs const
using namespace std;
cs int Mod = 998244353;
int add (int a, int b) {
	return a + b >= Mod ? a + b - Mod : a + b;
}
int mul (int a, int b) {
	return 1ll * a * b % Mod;
}
int dec (int a, int b) {
	return a - b < 0 ? a - b + Mod : a - b;
}
int ksm (int a, int b) {
	int ans = 1;
	for (; b; b >>= 1, a = mul (a, a)) if (b & 1) ans = mul (ans, a);
	return ans;
}
void Add (int &a, int b) {
	a = add (a, b);
}
cs int N = 55;
int gcd (int a, int b) {
	return !b ? a : gcd (b, a % b);
}
int n, ans, inv[N], g[N][N];
int fa[N], sm[N];
int find (int x) {
	return x == fa[x] ? x : fa[x] = find (fa[x]);
}
int loop[N], ct[N], now;
int calc() { //计算
	int res = 0;
	for (int i = 1; i <= now; i++) fa[i] = i, sm[i] = 0;
	for (int i = 1; i <= now; i++) {
		int v = loop[i];
		res += ((v - 1) >> 1);
		if (! (v & 1)) sm[i] = 1;
	}
	for (int i = 1; i <= now; i++) {
		for (int j = i + 1; j <= now; j++) {
			int u = loop[i], v = loop[j], gc = g[u][v];
			int a = (u / gc) & 1, b = (v / gc) & 1;
			if (a && b) fa[find (i)] = find (j), res += gc;
			if (a && !b) sm[j] += gc;
			if (!a && b) sm[i] += gc;
			if (!a && !b) res += gc;
		}
	}
	for (int i = 1; i <= now; i++)
		if (find (i) == i) {
			++res;
			res += sm[i] == 0 ? 0 : sm[i] - 1;
		} else sm[find (i)] += sm[i];
	res -= now;
	return ksm (2, res);
}
void dfs (int las, int rest, int coef) { //dfs枚举
	if (!rest) {
		Add (ans, mul (coef, calc()));
		return;
	}
	for (int i = min (las, rest); i; i--) {
		++ct[i];
		loop[++now] = i;
		dfs (i, rest - i, mul (coef, mul (inv[i], inv[ct[i]])));
		--ct[i];
		--now;
	}
}
int main() {
	cin >> n;
	inv[0] = inv[1] = 1;
	for (int i = 2; i <= n; i++) inv[i] = mul (Mod - Mod / i, inv[Mod % i]);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) g[i][j] = gcd (i, j);
	dfs (n, n, 1);
	cout << ans;
	return 0;
}

```

---

## 作者：Felix72 (赞：6)

## 观前提示

这篇题解主要讲一种复杂度略大于正解但思维难度略低于正解、无 ad-hoc 环节、使用 dp 的解法，在极限数据下用时十一秒左右，因此对于大多数据可以直接通过，部分数据需要打表，但保证正确性。如果认为正解难以想出，不妨看看这篇题解。

## 思路

传送：[P4727](https://www.luogu.com.cn/problem/P4727)

上面那道题是这个题的前置内容。受那道题的启发，我们先枚举拆分，再计算不动点的个数，最后用 burnside 引理求出答案。

对于每一种拆分，先用组合数计算出总共有多少种这样的拆分（这部分上面那道题就有），然后再计算符合条件的图的数量。因为每个置换环可以看作一个大点，内部的奇偶性一定一致，我们把图上的边分为几类：

### 置换环内部的边

这些边中绝大部分都不影响奇偶性。有一种情况例外：置换环大小为偶数时，有一种内部边会改变所有点奇偶性。

### 置换环之间的边

设两个置换环大小分别为 $a$ 和 $b$，最大公因数是 $d$。他们之间可以视作最多有 $d$ 条边。若 $a$ 除以 $d$ 和 $b$ 除以 $d$ 结果都是奇数，那么奇偶性同时被改变。若其中一个是偶数，那么那个置换环奇偶性改变，另一个不变。

---

不妨对这些边进行进一步分类:

### 不影响奇偶性

这种边最简单，最后算答案时乘上方案数即可（因为他们本身不造成影响）

### 影响一个置换环

可以看作一个点自己改变了自己的奇偶性，不能算作真正的“边”。

### 影响两个置换环

这个才能算作一条“边”。容易发现，这些边把置换环表示的大点练成若干完全图。

---

现在我们要做的就很清晰了：在这些完全图里选择一些边修改两个端点的奇偶性，再让一些点自己改自己，使得最后都是偶数。如果你注意到了其他几篇非大表题解所说的性质，你可以用建立映射的方法轻易推出式子。然而，这个做法思维难度高且不是很自然。

考虑到这是一个完全图且点的状态只有两种，是否能 dp 呢？答案是可以的。我们先忽略完全图中的边权（即重边），思考边权都为一时的做法：设 $f_{i,j}$ 表示第 $i$ 个点，从 $1$ 到 $i$ 有 $j$ 个点度数为奇数的方案数。那么可以枚举当前点连接了多少奇偶性为奇的点、多少奇偶性为偶的点，再分类讨论自己是奇是偶。$f_{n,0}$ 即为大小为 $n$ 的完全图的答案。

那么尝试考虑边权造成的影响。我们惊喜的发现：对于一堆重边，选出奇数条和偶数条（包含零）的方案是相等的！也就是说，既然忽略边权后每种情况对应的方案数都相等，我们完全可以先忽略这个边权，等 dp 结束后再统一乘上方案数。

至此，这道题就做完了。我们把刚刚求得的方案数乘上置换数，得到一种拆分的不动点个数。把这些值求和，除以 $N$ 的阶乘，就是答案了。

## 代码

由于 dp 复杂度较高（四次方），较大的数据需要打表，不过只需要十多秒一个数据，比爆搜好多了。

代码中我并没有把图建出来再找每个完全图，因为包含二的个数相同的数肯定在同一连通块，排序之后找连续区间就可以了。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;

const int N = 55, mod = 998244353;

int n, hve[N], sta[N], con[N]; long long Xg;
long long fac[N], inv[N];
inline void Plus(long long &now, long long add)
{now += add; while(now >= mod) now -= mod; while(now < 0) now += mod;}
inline long long qpow(long long a, int b)
{
	long long ans = 1;
	while(b) {if(b & 1) ans = ans * a % mod; b >>= 1; a = a * a % mod;}
	return ans;
}
inline long long C(int n, int m)
{return fac[n] * inv[m] % mod * inv[n - m] % mod;}
inline int gcd(int x, int y)
{return ((y == 0) ? x : gcd(y, x % y));}
inline void init()
{
	fac[0] = inv[0] = 1;
	for(int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % mod;
	inv[n] = qpow(fac[n], mod - 2);
	for(int i = n - 1; i >= 1; --i) inv[i] = inv[i + 1] * (i + 1) % mod;
	
	for(int i = 1; i <= n; ++i)
	{
		int cur = i;
		while(cur % 2 == 0)
			cur /= 2, con[i]++;
	}
}

long long self[N], f[N][N];
inline bool cmp(int x, int y) {return con[x] < con[y];}
inline void dfs(int now, int maxn, int cnt)
{
	if(now == n)
	{
		for(int i = 1; i <= cnt; ++i) hve[i] = sta[i];
		
//		cerr << "----------------------------------------\n";
//		cerr << "divide : ";
//		for(int i = 1; i <= cnt; ++i) cerr << hve[i] << " ";
//		cerr << '\n';
		
		long long ways = 1; int sum = n;
		for(int i = 1; i <= cnt; ++i)
		{
			ways = ways * C(sum, hve[i]) % mod, sum -= hve[i];
			ways = ways * fac[hve[i] - 1] % mod;
			if(i == 1 || hve[i] < hve[i - 1])
			{
				int r = i;
				while(r + 1 <= cnt && hve[r] == hve[r + 1]) ++r;
				ways = ways * inv[r - i + 1] % mod;
			}
		}
		
		long long sig = 1;
		sort(hve + 1, hve + cnt + 1, cmp);
		
//		cerr << "resort : ";
//		for(int i = 1; i <= cnt; ++i) cerr << hve[i] << " ";
//		cerr << '\n';
		
		memset(self, 0, sizeof(self));
		for(int i = 1; i <= cnt; ++i)
		{
			if(hve[i] % 2 == 1) sig = sig * qpow(2, hve[i] / 2);
			else sig = sig * qpow(2, hve[i] / 2 - 1);
			if(hve[i] % 2 == 1) self[i] = 0;
			else self[i] = 1;
			for(int j = 1; j <= i; ++j)
				if(con[hve[i]] > con[hve[j]])
					Plus(self[i], gcd(hve[i], hve[j]));
		}
		
//		cerr << "selfnum : ";
//		for(int i = 1; i <= cnt; ++i) cerr << self[i] << " ";
//		cerr << '\n';
		
		for(int l = 1; l <= cnt; ++l)
		{
			if(l == 1 || con[hve[l]] > con[hve[l - 1]])
			{
				int r = l;
				while(r + 1 <= cnt && con[hve[r]] == con[hve[r + 1]]) ++r;
				
//				cerr << "R " << l << " " << r << '\n';
				
				for(int i = l; i <= r; ++i)
					for(int j = i + 1; j <= r; ++j)
						sig = sig * qpow(2, gcd(hve[i], hve[j]) - 1) % mod;
				
				for(int i = l - 1; i <= r; ++i)
					for(int j = 0; j <= r - l + 1; ++j)
						f[i][j] = 0;
				f[l - 1][0] = 1;
				for(int i = l; i <= r; ++i)
				{
					long long n0 = 1, n1 = 0;
					if(self[i]) n0 = qpow(2, self[i] - 1), n1 = n0;
//					cerr << n0 << " " << n1 << " : ";
					for(int l1 = 0; l1 <= i - l; ++l1)
					{
						int l0 = i - l - l1;
						for(int c0 = 0; c0 <= l0; ++c0)
						{
							for(int c1 = 0; c1 <= l1; ++c1)
							{
								if((c0 + c1) & 1)
								{
									Plus(f[i][l1 - c1 + c0], f[i - 1][l1] * C(l1, c1) % mod * C(l0, c0) % mod * n1 % mod);
									Plus(f[i][l1 - c1 + c0 + 1], f[i - 1][l1] * C(l1, c1) % mod * C(l0, c0) % mod * n0 % mod);
								}
								else
								{
									Plus(f[i][l1 - c1 + c0], f[i - 1][l1] * C(l1, c1) % mod * C(l0, c0) % mod * n0 % mod);
									Plus(f[i][l1 - c1 + c0 + 1], f[i - 1][l1] * C(l1, c1) % mod * C(l0, c0) % mod * n1 % mod);
								}
							}
						}
					}
//					for(int j = 0; j <= r - l + 1; ++j)
//						cerr << f[i][j] << " ";
//					cerr << '\n';
				}
				
//				cerr << "res " << f[r][0] << '\n';
				
				sig = sig * f[r][0] % mod;
			}
		}
//		cerr << "final " << sig << " " << ways << '\n';
		Xg = (Xg + sig * ways % mod) % mod;
		return ;
	}
	for(int i = min(maxn, n - now); i >= 1; --i)
		sta[cnt + 1] = i, dfs(now + i, i, cnt + 1);
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n; init();
	if(n == 40) cout << 650982654 << '\n';
	if(n == 41) cout << 373128192 << '\n';
	if(n == 42) cout << 361260409 << '\n';
	if(n == 43) cout << 524419271 << '\n';
	if(n == 44) cout << 834718796 << '\n';
	if(n == 45) cout << 514750301 << '\n';
	if(n == 46) cout << 478609700 << '\n';
	if(n == 47) cout << 386216865 << '\n';
	if(n == 48) cout << 881562716 << '\n';
	if(n == 49) cout << 715225681 << '\n';
	if(n == 50) cout << 602577017 << '\n';
	if(n >= 40) return 0;
	dfs(0, 1e9, 0);
	cout << Xg * inv[n] % mod << endl;
	return 0;
}
/*

*/
```

---

## 作者：zhouyuhang (赞：2)

**Hint：考虑“变性”。**

---

直接快进到 Burnside 引理，让我们看看怎么求出一个置换 $p$ 作用下的不动点数。

将 $p$ 拆成若干置换环 $q_1, q_2, \cdots, q_k$。考虑两个长度分别为 $l_1, l_2$ 的置换环的 $q_1, q_2$ 会怎样连边：如果 $q_{1, a}$ 与 $q_{2, b}$ 之间有边，则 $q_{1, a + 1}$ 与 $q_{2, b + 1}$ 间也必须有边，以此类推……直到第一次 $(a + x) \equiv a \pmod {l_1}$ 且 $(b + x) \equiv b \pmod {l_2}$ 时才会转回 $(q_{1, a}, q_{2, b})$。显然这样的 $x$ 最小为 $\operatorname{lcm}(l_1, l_2)$，也就是说一个等价类的大小是 $\operatorname{lcm}(l_1, l_2)$，那所有 $l_1 l_2$ 条边就被划分成了 $\gcd(l_1, l_2)$ 个等价类。

而众所周知的是一个无向图各个连通块均有欧拉回路等价于图中每个点的度数都是偶数。我们尝试用这一判定来解决问题。注意到，在上文一个大小为 $\operatorname{lcm}(l_1, l_2)$ 的边的等价类中，$q_1$ 中的每个点都连出了 $\frac {\operatorname{lcm}(l_1, l_2)} {l_1} = \frac {l_2} {\gcd(l_1, l_2)}$ 条边。同理 $q_2$ 中的每个点连出了 $\frac {l_1} {\gcd(l_1, l_2)}$ 条边。注意到 $\frac {l_1} {\gcd(l_1, l_2}, \frac {l_2} {\gcd(l_1, l_2)}$ 必然是一奇一偶或者两个奇数，因此其选这一等价类要么改变 $q_1$ 或 $q_2$ 中点度数的奇偶性，要么同时改变。

接下来分析置换环内的连边。对于一个长为 $l$ 的置换环 $q$ 来说，若 $q_{a}$ 和 $q_{b}$ 连边，则 $q_{a + 1}$ 和 $q_{b + 1}$ 也要连边，同理转 $l$ 次后会回到 $(q_a, q_b)$。但是由于边是无向边，因此 $(q_1, q_2)$ 和 $(q_2, q_1)$ 是相同的，从而只有 $\frac {l} {2}$ 种等价类。接下来分析它们对与度数的奇偶性的影响：不难发现，当且仅当 $2\mid l$ 且 $b - a \equiv \frac {l} 2 \pmod l$ 时这一等价类的边**不**形如若干环（一个环显然对度数奇偶性没有影响）。而 $b - a \equiv \frac {l} 2 \pmod l$ 时每个点的度数奇偶性都恰好发生改变。

至此，我们分析得到了所有类型的等价类（在上述分析中，我们已经发现一个置换环中所有点度数相等，因此我们直接将这个度数称作这一置换环的度数）：

- 在两个置换环之间，且同时改变两个环的奇偶性。
- 在两个置换环之间，恰改变其中一个环的奇偶性。
- 在一个置换环内，不改变奇偶性。
- 在一个置换环内，改变这个环的奇偶性。

接下来我们考虑这样一种思想，即先使用其他的等价类，最后再用一些 1 类等价类进行调整。具体需要哪些一类等价类呢？如果将所有一类等价类看成是在置换环之间的连边，那么我们只需对每个连通块都保留其任意一棵生成树即可——这样，我们从根进行调整，只要这一连通块中置换环度数之和为偶数，就一定存在恰好一种调整方案。而只有 2、4 两类等价类会改变连通块中度数之和的奇偶。将上述过程综合起来，就得到如下做法：

- 记四类等价类的数目之和为 $c$。
- 依次考察一类等价类对应的连边所形成的每个连通块 $C$。
- $c := c - (|C| - 1)$
- 若 $C$ 内存在某置换环，其内有 4 类等价类或者被某个可以改变这一置换环奇偶性的 2 类等价类连接，则 $c := c - 1$。
- 最终的不动点数即为 $2 ^ c$。

如此，枚举置换环的拆分即可做到 $O(p(n)\operatorname{poly}(n))$，其中 $p(n)$ 为拆分数。

---


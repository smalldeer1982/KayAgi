# 信息传递

## 题目描述

给定置换
$$
f = \begin{pmatrix} 1 & 2 & ... & n \\\ a_1 & a_2 & ... & a_n \end{pmatrix}
$$
求有多少个置换 $g$ ，满足
$$
g ^ n = f
$$
答案对 $998244353$ 取模。

## 说明/提示

样例解释：

有且仅有 $a_1 = 2, a_2 = 1, a_3 = 3$ 满足
$$
{\begin{pmatrix} 1 & 2 & 3 \\ 2 & 1 & 3 \end{pmatrix}} ^ 3 = \begin{pmatrix} 1 & 2 & 3 \\ 2 & 1 & 3 \end{pmatrix}
$$

对于 $20 \%$ 的数据，$n \le 10$。

对于 $60 \%$ 的数据，$n \le 1000$。

对于 $100 \%$ 的数据，$n \le {10} ^ 5$。

## 样例 #1

### 输入

```
3
2 1 3```

### 输出

```
1```

# 题解

## 作者：command_block (赞：10)

**题意** : 给出一个 $n$ 元置换 $f$。

求有多少个置换 $g$ 满足 $g^n=f$

$n\leq 10^5$ ,时限 $\texttt{4s}$。

------------

有意思的题。

看到置换乘积,首先把置换分解成循环表示。

单独看一个循环,有如下定理 : 

- 长度为 $m$ 的循环在 $k$ 次幂之后得到的置换有 $\gcd(k,m)$ 个等大小循环。

  可以看做每个元素转动了 $k$ 次。沿着某个环走,不断 $+k$ 再 $\bmod\ m$ ,易得恰能走 $m/\gcd(k,m)$ 步。
  
也就是说, $f$ 中的 $r$ 个长度为 $s$ 的环能够拼到一起当且仅当 $\gcd(rs,n)=r$。

先考虑 $r$ 个长度为 $s$ 的小环有多少中拼合的方法。

由于拼合后是大环,先钦定第一个小环的第一个元素排在第一位。

此外,其余 $r-1$ 个小环可以随意旋转,方案数为 $s^{r-1}$。

其余 $r-1$ 个小环之间还可以随意排列,方案数为 $(r-1)!$

总的来说就是 $(r-1)!s^{r-1}$。不妨设为 $p_{r,s}$。

设长度为 $i$ 的循环有 $c_i$ 个。

能够发现不同大小的循环之间互不影响,我们每种大小分开考虑。

现有 $c$ 个长度为 $s$ 的环。

设 $dp[i]$ 为使用了 $i$ 个环的方案数。

则 $dp[i]=\sum\limits_{r=1}^{i}[\gcd(rs,n)=r]\dbinom{i-1}{r-1}p_{r,s}dp[i-r]$

中间是 $\dbinom{i-1}{r-1}$ 而不是 $\dbinom{i}{r}$ 的原因 : 合成的各个环是无序的，不妨钦定每次必选第一个。

其中, $\gcd(rs,n)=r\Rightarrow r|n$ ,所以枚举量是 $O(d(n))$ 级别的。

复杂度 $O(n*d(n))$。

```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
#define ll long long
#define MaxN 100500
using namespace std;
const int mod=998244353;
ll powM(ll a,int t=mod-2){
  ll ret=1;
  while(t){
    if (t&1)ret=ret*a%mod;
    a=a*a%mod;t>>=1;
  }return ret;
}
int d[MaxN],tn;
ll fac[MaxN],ifac[MaxN];
ll C(int n,int m)
{return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}
ll P(int r,int s)
{return fac[r-1]*powM(s,r-1)%mod;}
void Init(int n)
{
  fac[0]=1;
  for (int i=1;i<=n;i++)
    fac[i]=fac[i-1]*i%mod;
  ifac[n]=powM(fac[n])%mod;
  for (int i=n;i;i--)
    ifac[i-1]=ifac[i]*i%mod;
  for (int i=1;i<=n;i++)
    if (n%i==0)d[++tn]=i;
}
int gcd(int a,int b)
{return !b ? a : gcd(b,a%b);}
ll dp[MaxN];
ll calc(int c,int s,int n)
{
  dp[0]=1;
  for (int i=1;i<=c;i++){
    dp[i]=0;
    for (int j=1;j<=tn&&d[j]<=i;j++){
      int r=d[j];
      if (gcd(n,r*s)==r)
        dp[i]=(dp[i]+C(i-1,r-1)*P(r,s)%mod*dp[i-r])%mod;
    }
  }return dp[c];
}
bool vis[MaxN];
int n,p[MaxN],c[MaxN];
int main()
{
  scanf("%d",&n);
  Init(n);
  for (int i=1;i<=n;i++)
    scanf("%d",&p[i]);
  for (int i=1;i<=n;i++)
    if (!vis[i]){
      int siz=0,u=i;
      while(!vis[u])
        {vis[u]=1;siz++;u=p[u];}
      c[siz]++;
    }
  ll ans=1;
  for (int i=1;i<=n;i++)
    if (c[i])
      ans=ans*calc(c[i],i,n)%mod;
  printf("%lld",ans);
  return 0; 
}
```







---

## 作者：Karry5307 (赞：9)

### 题意

给定长度为 $n$ 的置换 $f$，求有多少个长度为 $n$ 的置换 $g$ 满足 $g^n=f$。

$\texttt{Data Range:}1\leq n\leq 10^5$

### 题解

非常有意思的题，要是能早点看到就好了……

看了看 cmd_block 的题解发现跟我想的差不多啊……

一发最优解/se/se

显然一个套路是将置换拆解成循环然后考虑循环，这里有一个定理：

长度为 $n$ 的循环 $k$ 次幂之后会变成 $\gcd(n,k)$ 个等大小的循环。

这个证明的话大概就是说置换一次相当于走一步，$k$ 次幂之后走了 $k$ 步。考虑走多少个 $k$ 步会回到原来的位置，显然是 $\frac{n}{\gcd(n,k)}$，而且走到的位置上的数互不相同，这些数构成了一个循环，所以有 $\gcd(n,k)$ 个循环。

同理，对于一些等长的小循环也可以构造出大循环使得其次幂恰为这个小环。比如说构造 $g^3=(12)(34)(56)$，因为 $g^3$ 相当于是在循环上走了 $3$ 步，所以构造 $1$ 走 $3$ 步变成 $2$，$3$ 走 $3$ 步变成 $4$，$5$ 走 $3$ 步变成 $6$，也即 $(135246)$。为了尽量能够一一对应方便后面表示，钦定每个循环的第一个数依次占据前面的位置。

但是注意到 $(12)(34)(56)$ 与 $(12)(43)(56)$ 构造出的大循环不同，这里我们认为这两个是不同的。同时，$(12)(34)(56)$ 与 $(34)(12)(56)$ 也认为是不同的。怎么说呢，两个小循环链相同当且仅当由上面方法构造出的大循环相同。

所以说，$f$ 中的 $r$ 个长度为 $s$ 的小环能被 $g$ 中某个大环裂解得来当且仅当 $\gcd(rs,n)=r$。

考虑这些小环的拼合方法。钦定第一个小环的第一个元素在第一个（否则必定有一种方案使得构造出的大循环与这里的循环同构），剩下的小环可以内部瞎转以及环与环瞎交换，有 $(s-1)!s^{r-1}$ 种。

由于不同长度的环不能拼起来，相当于环长是独立的，所以考虑对每个环长 DP。

假设考虑到的环长为 $s$，有 $c$ 个，设 $f_i$ 表示用了 $i$ 个环的方案数，枚举最后一个大环用了几个小环去拼凑得到：


$$f_i=\sum\limits_{r=1}^{i}[\gcd(rs,n)=r]\binom{i-1}{r-1}(r-1)!s^{r-1}f_{i-r}$$

这里不是 $\dbinom{i}{r}$ 因为环是循环同构的所以要除掉影响，化简一下就好了，时间复杂度 $O(nd(n))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51,MOD=998244353;
vector<ll>v;
ll n,ftot,totc,cur,sz,res;
ll fact[MAXN],finv[MAXN],factor[MAXN],x[MAXN],cyc[MAXN],vis[MAXN];
ll f[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
	ll res=1;
	while(exponent)
	{
		if(exponent&1)
		{
			res=(li)res*base%MOD;
		}
		base=(li)base*base%MOD,exponent>>=1;
	}
	return res;
}
inline void setup(ll cnt)
{
	fact[0]=fact[1]=finv[0]=1;
	for(register int i=2;i<=cnt;i++)
	{
		fact[i]=(li)fact[i-1]*i%MOD;
	}
	finv[cnt]=qpow(fact[cnt],MOD-2);
	for(register int i=cnt-1;i;i--)
	{
		finv[i]=(li)finv[i+1]*(i+1)%MOD;
	}
}
inline ll binom(ll m,ll n)
{
	return (li)fact[m]*finv[n]%MOD*finv[m-n]%MOD;
}
inline ll calc(ll c,ll len)
{
	ll r,cof;
	f[0]=1;
	for(register int i=1;i<=c;i++)
	{
		f[i]=0;
		for(register int j=1;j<=ftot&&(r=factor[j])<=i;j++)
		{
			if(__gcd(r*len,n)==r)
			{
				cof=(li)fact[i-1]*finv[i-r]%MOD*qpow(len,r-1)%MOD;
				f[i]=(f[i]+(li)cof*f[i-r])%MOD;
			}
		}
	}
	return f[c];
}
int main()
{
	setup(n=read()),res=1;
	for(register int i=1;i<=n;i++)
	{
		x[i]=read(),n%i==0?factor[++ftot]=i:1;
	}
	for(register int i=1;i<=n;i++)
	{
		if(!vis[i])
		{
			vis[i]=sz=1,cur=x[i];
			while(cur!=i)
			{
				vis[cur]=1,sz++,cur=x[cur];
			}
			cyc[sz]++;
		}
	} 
	for(register int i=1;i<=n;i++)
	{
		cyc[i]?res=(li)res*calc(cyc[i],i)%MOD:1;
	}
	printf("%d\n",res);
}
```

---

## 作者：Caro23333 (赞：4)

众所周知，有一种处理置换的方法是把一个置换看作若干个环，每应用一次置换，每个数就会沿着环走一步，也就是“转一圈”（不难自行理解）。

如果存在一个初始排列 $\sigma = [1,2,\dots,n]$ 和一个置换 $f$，称 $j$ 是从 $i$ “可达的”，当且仅当可以通过对 $\sigma$ 应用若干次 $f$ 使得 $\sigma_j=i$。显然，对于置换 $f$，$i$ 是从 $j$ 可达的，当且仅当 $i,j$ 处在 $f$ 中的同一个环上。

于是有显然的推论：对于任意的 $i,j$，如果它们在 $f$ 中属于同一个环，那么它们在 $g$ 中也属于同一个环。反证法不难。这也就是说，$g$ 中的环都是由若干个 $f$ 中的环经过重新排列，再组合到一起的。

另一个基本的事实是，如果置换 $g$ 中有一个长度为 $k$ 的环，那么在 $g^m$ 中这个环会裂解为 $\gcd(k,m)$ 个长度为 $\frac{k}{\gcd(k,m)}$ 的环，其中第 $i$ 个环的两个相邻元素在原来的环上有 $\gcd(k,m)-1$ 个元素相隔。这意味着只有 $f$ 中大小相同的若干个环能够拼成一个 $g$ 中的环；更进一步说，$j$ 个长度为 $i$ 的环能够拼到一起当且仅当 $\gcd(ij,n)=j$。

***

考虑给你 $j$ 个长度为 $i$ 的环，如何计算它们合在一起的方案数：首先确定环之间的顺序：随意钦定一个起始元素，假设属于第一个环；那么接下来的 $j-1$ 个元素根据所属的环不同，共有 $(j-1)!$ 种可能性。接下来确定环内的顺序：钦定第一个环不动，其他 $j-1$ 个环通过旋转各自可以有 $i$ 种不同的顺序，所以共有 $i^{j-1}$ 种可能性。那么这一部分的总方案数是 $i^{j-1}(j-1)!$，不妨记为 $t_{i,j}$。

因为各个长度之间是独立的，所以我们枚举长度 $i$，并设共有 $s_i$ 个长度为 $i$ 的环。那我们实际上是要把 $s_i$ 个环分成若干**无序的**组，其中每组的数量是合法的（即 $\gcd(ij,n)=j$），计算每组贡献的乘积，再乘上分组的方案数。记 $r_{i,j} = [\gcd(ij,n)=j]t_{i,j}$，则长度为 $i$ 这一部分的答案为：

$$\sum_{\sum\limits_{j=1}^{s_i} j\cdot c_j = s_i} \frac{s_i!}{\prod\limits_{j=1}^{s_i} (j!)^{c_j}\cdot c_j!}\cdot \prod\limits_{j=1}^{s_i} r_{i,j}^{c_j}$$

$$=s_i! \sum_{\sum\limits_{j=1}^{s_i} j\cdot c_j = s_i} \prod_{j=1}^{s_i} \frac{(\frac{r_{i,j}}{j!})^{c_j}}{c_j!}$$

$$=s_i![z^{s_i}]\prod_{j=1}^{s_i} \sum_{k=0}^{\infty} \frac{(\frac{r_{i,j}}{j!})^k}{k!} z^{kj}$$

$$=s_i![z^{s_i}]\prod_{j=1}^{s_i} \exp\left(\frac{r_{i,j}}{j!}z^{j}\right)$$

$$=s_i![z^{s_i}]\exp\left(\sum_{j=1}^{s_i} \frac{r_{i,j}}{j!}z^{j}\right)$$

括号内的内容可以 $O(s_i)$ 计算， $\exp$ 的时间复杂度为 $O(s_i\log s_i)$。因为 $\sum\limits_{i=1}^{n} s_i = n$， 所以总复杂度为 $O(n\log n)$。

~~其实由 $\exp$ 的组合意义应该十分易得，但是我好像说不清楚qaq~~

***

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <vector>
#define mod 998244353
#define inv3 (mod+1)/3

using namespace std;
typedef long long ll;
const int MAXN = 265005;
inline int readint()
{
	int res = 0, f = 1;
	char c = 0;
	while(!isdigit(c))
	{
		c = getchar();
		if(c=='-')
			f = -1;
	}
	while(isdigit(c))
		res = res*10+c-'0', c = getchar();
	return res*f;
}
int n,a[MAXN],cnt[MAXN];
bool vis[MAXN],flag[MAXN];
ll fac[MAXN];
vector<int> d;
inline ll qpow(ll a, int b)
{
	ll res = 1;
	for(; b; a = a*a%mod, b >>= 1)
		if(b&1)
			res = res*a%mod;
	return res; 
}
inline ll getInv(ll x)
	{ return qpow(x,mod-2); }
inline int gcd(int a, int b)
	{ return b?gcd(b,a%b):a; }
inline int modd(int x)
	{ return x>=mod?x-mod:x; }
ll p[MAXN],q[MAXN],ainv[MAXN];
int rev[MAXN];
inline void ntt(ll *a, int deg, int f)
{
	ll u,t;
	for(int i = 0; i<deg; i++)
		if(i<rev[i])
			swap(a[i],a[rev[i]]); 
	for(int i = 1; i<deg; i <<= 1)
	{
		ll wn = qpow(f,(mod-1)/(i<<1));
		for(int j = 0; j<deg; j += i<<1)
		{
			ll w = 1;
			for(int k = j; k<j+i; k++)
			{
				u = a[k], t = w*a[k+i]%mod;
				a[k] = modd(u+t), a[k+i] = modd(u-t+mod);
				w = w*wn%mod;
			}
		}
	}
	if(f*3%mod==1)
	{
		ll invdeg = getInv(deg);
		for(int i = 0; i<deg; i++)
			a[i] = a[i]*invdeg%mod;	
	}
}
struct Poly
{
	vector<ll> a;
	int deg;
	Poly(int size = 0)
	{
		a.clear();
		deg = size;
		for(int i = 0; i<=size; i++)
			a.push_back(0); 
	}
	inline Poly resize(int n)
	{
		if(deg>n)
			while(a.size()>n+1)
				a.pop_back();
		else
			while(a.size()<n+1)
				a.push_back(0);
		deg = n;
		return *this;
	}
	Poly operator*(const Poly t) const
	{
		int tn = deg, tm = t.deg, n = tn, m = tm;
		m += n;
		int k = 0;
		for(n = 1; n<=m; n <<= 1, k++);
		for(int i = 0; i<n; i++)
			rev[i] = (rev[i>>1]>>1)|((i&1)<<(k-1));
		for(int i = 0; i<n; i++)
			p[i] = i>tn?0:a[i], q[i] = i>tm?0:t.a[i];
		ntt(p,n,3), ntt(q,n,3);
		for(int i = 0; i<n; i++)
			p[i] = p[i]*q[i]%mod;
		ntt(p,n,inv3);
		Poly res(m);
		for(int i = 0; i<=m; i++)
			res.a[i] = p[i];
		return res;
	}
	Poly operator*(const ll t) const
	{
		Poly res(deg);
		for(int i = 0; i<=deg; i++)
			res.a[i] = a[i]*t%mod;
		return res;
	}
	Poly operator+(const Poly t) const
	{
		Poly res(max(deg,t.deg));
		for(int i = 0; i<=res.deg; i++)
			res.a[i] = modd((i>deg?0:a[i])+(i>t.deg?0:t.a[i]));
		return res;
	}
	Poly operator-(const Poly t) const
		{ return (*this)+(t*(mod-1)); }
	inline Poly inv()
	{
		Poly res(deg);
		if(deg==0)
		{
			res.a[0] = getInv(a[0]);
			return res;
		}
		Poly b(deg>>1);
		for(int i = 0; i<=b.deg; i++)
			b.a[i] = a[i];
		b = b.inv();
		res = b*2-b*b*(*this);
		return res.resize(deg); 
	}
	inline Poly deriv()
	{
		Poly res(max(0,deg-1));
		if(deg==0)
			return res;
		for(int i = 0; i<deg; i++)
			res.a[i] = a[i+1]*(i+1)%mod;
		return res;
	}
	inline Poly integ()
	{
		Poly res(deg+1);
		for(int i = 1; i<=deg+1; i++)
			res.a[i] = a[i-1]*ainv[i]%mod;
		return res;
	}
	inline Poly ln()
		{ return (deriv()*inv()).resize(deg).integ().resize(deg); }
	inline Poly exp()
	{
		if(deg==0)
		{
			Poly res(0);
			res.a[0] = 1;
			return res;
		}
		Poly b(deg>>1);
		for(int i = 0; i<=b.deg; i++)
			b.a[i] = a[i];
		b = b.exp().resize(deg);
		Poly tmp(0);
		tmp.a[0] = 1;
		return (b*(tmp-b.ln()+(*this))).resize(deg);
	}
};

int main()
{
	n = readint();
	for(int i = 1; i<=n; i++)
		a[i] = readint();
	for(int i = 1; i<=n; i++)
	{
		if(vis[i])
			continue;
		int pos = i, len = 0;
		while(!vis[pos])
			vis[pos] = true, pos = a[pos], len++;
		cnt[len]++;
	}
	for(int i = 1; i<MAXN; i++)
		ainv[i] = getInv(i);
	fac[0] = 1;
	for(int i = 1; i<=n; i++)
		fac[i] = fac[i-1]*i%mod;
	ll ans = 1;
	for(int i = 1; i<=100000; i++)
	{
		if(!cnt[i])
			continue;
		for(int j = 1; j<=cnt[i]; j++)
			flag[j] = false;
		for(int j = 1; j<=cnt[i]; j++)
			if(gcd(j*i,n)==j)
				flag[j] = true;
		Poly now(cnt[i]);
		for(int j = 1; j<=cnt[i]; j++)
		{
			ll t = qpow(i,j-1)*fac[j-1]%mod;
			now.a[j] = flag[j]?t*getInv(fac[j])%mod:0;
		}
		now = now.exp();
		ans = ans*now.a[cnt[i]]%mod*fac[cnt[i]]%mod;
	}
	cout << ans << endl;
	return 0;
}

```


---

## 作者：whiteqwq (赞：2)

[P4709 信息传递](https://www.luogu.com.cn/problem/P4709) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/15715415.html)

## 题意

给定置换 $f$，求有多少个置换 $g$ 满足 $g^n=f$。

$1\leqslant |f|\leqslant 10^5$。

## 分析

首先这种题一看到就把置换拆分成若干个循环置换。

对于一个循环置换 $g$，我们考虑它的 $n$ 次方的形态：应该是 $\gcd(|g|,n)$ 个相同的循环，那么等价地，$a$ 个大小为 $b$ 的循环能够拼起来当且仅当 $\gcd(ab,n)=a$。

由于我们得到的是最终的循环置换，所以我们考虑把若干个大小相同的循环拼起来，我们仅需要对于每个环大小计算其贡献然后乘起来就好了。

我们考虑 $a$ 个大小为 $b$ 的环拼起来有多少种方法，由于是环首先要钦定一个位置作为开始，不妨令其为第一个环的第一个位置，而由于其他环需要断环为链，且内部要进行排列，所以一共会有 $(a-1)!b^{a-1}$ 种方案。

我们设一共有 $k$ 个大小为 $b$ 的环，设 $f_i$ 表示用了 $k$ 个环的代价，可以列出转移方程：

$$f_i\leftarrow\sum_{d=1}^i[\gcd(b\times d,n)=d](d-1)!b^{d-1}{i-1\choose d-1}f_{i-r}$$

注意这里是 ${i-1\choose d-1}$ 是因为若干次选择之间是无序的，所以我们需要钦定一个环为第一个选的才能去重。

枚举 $d$ 可以只枚举 $n$ 的因子，最终复杂度为 $O(nd(n)+\sqrt{n}d(n)\log n)$。

## 代码

目前是最优解 rk1。

```cpp
#include<stdio.h>
#include<vector>
using namespace std;
const int maxn=100005,mod=998244353;
int n,ans;
int p[maxn],vis[maxn],tot[maxn],f[maxn],fac[maxn],inv[maxn],nfac[maxn],mul[maxn];
vector<int>v,d;
int gcd(int a,int b){
	return b==0? a:gcd(b,a%b);
}
int solve(int a,int b){
	f[0]=mul[0]=1;
	for(int i=1;i<=a;i++)
		mul[i]=1ll*mul[i-1]*b%mod;
	d.clear();
	for(int i=0;i<v.size()&&v[i]<=a;i++)
		if(gcd(b*v[i],n)==v[i])
			d.push_back(v[i]);
	for(int i=1;i<=a;i++){
		f[i]=0;
		for(int j=0;j<d.size()&&d[j]<=i;j++)
			f[i]=(f[i]+1ll*mul[d[j]-1]*f[i-d[j]])%mod;
		f[i]=1ll*f[i]*inv[i]%mod;
	}
	return 1ll*f[a]*fac[a]%mod;
}
int main(){
	scanf("%d",&n);
	fac[0]=nfac[0]=1;
	for(int i=1;i<=n;i++)
		fac[i]=1ll*fac[i-1]*i%mod,inv[i]=i==1? 1:(mod-1ll*(mod/i)*inv[mod%i]%mod),nfac[i]=1ll*nfac[i-1]*inv[i]%mod;
	for(int i=1;i<=n;i++)
		scanf("%d",&p[i]);
	for(int i=1;i<=n;i++)
		if(vis[i]==0){
			int cnt=0;
			for(int j=i;vis[j]==0;j=p[j])
				vis[j]=1,cnt++;
			tot[cnt]++;
		}
	for(int i=1;i<=n;i++)
		if(n%i==0)
			v.push_back(i);
	ans=1;
	for(int i=1;i<=n;i++)
		if(tot[i])
			ans=1ll*ans*solve(tot[i],i)%mod;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Rui_R (赞：1)

被乌龟钦定为 $\text{Polya}$ 板题，然而好像跟 $\text{Polya}$ 莫得关系。

[原题](https://www.luogu.com.cn/problem/P4709)

考虑 $g$ 上每个元素都属于一个环，它会在这个环上转。

并且对于每个点 $i$ ，其与 $f(i)$ 在 $g$ 上环的距离为 $n \bmod \text{length}$ ，$\text{length}$ 表示 $i$ 在 $g$ 上所属环的大小。

如果认为走 $n \bmod \text{length} $ 次为一步，那么 $\dfrac{\operatorname{lcm}(\text{length},n \bmod \text{length})}{n \bmod \text{length}}=\dfrac{\text{length}}{\gcd(\text{length},n \bmod \text{length})}$ 步后一个点将回到原点。

分母那个 $\gcd$ 很难受，把它改成 $\gcd(\text{length},n)$ 。

注意，这 $\dfrac{\text{length}}{\gcd(\text{length},n)}$ 步所经过的元素在 $f$ 上一定是一个环的形式。也就是说，$g$ 上一个长为 $\text{length}$ 的环，可以由 $\gcd(n,\text{length})$ 个长为 $\dfrac{\text{length}}{\gcd(n,\text{length})}$ 的 $f$ 上的环拼成。

然后用 $\gcd(n,\text{length})$ 个长为 $\dfrac{\text{length}}{\gcd(n,\text{length})}$ 的 $f$ 上的环拼成 $g$ 上一个长为 $\text{length}$ 的环的方案数为
$$
(\gcd(n,\text{length})-1)! \cdot (\frac{\text{length}}{\gcd(n,\text{length})})^{\gcd(n,\text{length})-1}
$$
因为是环，所以先钦定一个元素作为初始元素，同时其所属的环上所有元素也被钦定了；然后剩下 $\gcd(n,\text{length})-1$ 个环有 $(\gcd(n,\text{length})-1)!$ 种排列，并且它们可以乱转。这样就可以得到上面的式子。

意识到 $f$ 上不同长度的环之间没有联系，并且最终要用掉所有环，那么可以将不同长度的环分开考虑。

枚举当前长度为 $x$ ，则它们可以拼成一个环，当且仅当 $\dfrac{\text{length}}{x}=\gcd(n,\text{length})$ 。

接着考虑 dp 求解，令 $dp(t)$ 表示使用了 $t$ 个环的方案数。那么有转移：
$$
dp(t) = \sum_{g|n}[\gcd(gx,n)=g]\cdot \binom{t-1}{g-1} \cdot (g-1)!\cdot x^{g-1}\cdot dp(t-g)
$$
为什么是 $\dbinom{t-1}{g-1}$ 而不是 $\dbinom{t}{g}$ ？因为还是要考虑去重，把枚举的大小为 $g$ 的环作为第一个环；那么初始元素及其所属的 $f$ 上的环已经被我们钦定了。


---


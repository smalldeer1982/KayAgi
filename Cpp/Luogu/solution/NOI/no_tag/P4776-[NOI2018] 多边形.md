# [NOI2018] 多边形

## 题目描述

久莲是一个喜欢出题的女孩子。

在今年的 World Final 结束以后，久莲特别喜欢计算几何，于是她打算在 NOI 的考场上也出一个计算几何：这是一道只有题目名字和计算几何相关的题目。

首先，久莲给出了一棵 $n\ (n \ge 2)$ 个节点的有根树 $T$，根节点编号为 $1$。定义叶子节点为除了根以外所有度数恰好为 $1$ 的节点。下图是一个树 $T$ 的例子，其中叶子节点集合为 $\{3, 4, 5\}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9k8ckocd.png)

接着通过这棵树，久莲构造了一个序列 $A$：
- 从根节点开始深度优先遍历整棵树，遍历时按照编号从小到大的顺序来访问孩子，这样可以得到一个树 $T$ 的 DFS 序。
- 接着按照在 DFS 序中的出现顺序从前往后，久莲把所有叶子节点排成一排得到了一个序列 $A$。

更进一步地，通过序列 $A$，久莲定义了两个叶子节点 $u, v$ 的距离 $d(u, v)$：假设 $u$ 在 $A$ 中是第 $i$ 个元素，$v$ 是第 $j$ 个元素，则 $d(u, v) = \min(|i − j|, |A| − |i − j|)$。其中 $|A|$ 为序列的长度，即 $T$ 的叶子个数，$i, j$ 指的是出现的位置，从 $1$ 开始计数。

上面的例子中，序列 $A$ 为 $\{4, 5, 3\}$，其中 $d(3, 5) = d(3, 4) = d(4, 5) = 1$，$3, 4, 5$ 的出现位置分别为 $3, 1, 2$。

最后，久莲给出了一个参数 $K$，利用这棵有根树 $T$ 和序列 $A$，我们可以构造一张 $n$ 个点的**无重边无自环**的无向图 $G$：两个不同的点 $u, v$ 之间有边当且仅当它们满足下列条件中的至少一个：
- 在树 $T$ 中存在连接 $u, v$ 的边。
- 在树 $T$ 中 $u, v$ 都是叶子节点且 $d(u, v) \le K$。

当 $K = 1$ 或 $2$ 时，上面的例子得到的图 $G$ 都如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zsq6qywg.png)

现在久莲想让你来计算一下 $G$ 中不同的哈密尔顿回路数量有多少条，答案可能很大，请对 $998244353$ 取模后输出。

下面是一些补充定义：
- 无重边无自环的无向图 $G$ 的一条哈密尔顿回路 $H$ 是 $G$ 中边的一个子集，其中每一个点恰好有两条不同的相邻边在 $H$ 中，且任意两个点都可以通过 $H$ 中的边直接或间接到达。
- 无重边无自环的无向图 $G$ 的两条哈密尔顿回路 $H_1, H_2$ 是不同的当且仅当存在一条边 $e$ 使得 $e$ 在 $H_1$ 中且不在 $H_2$ 中。

## 说明/提示

### 样例解释

该样例和题面中的例子完全相同。两条哈密尔顿回路经过节点的顺序分别为 $(1, 2, 4, 5, 3)$ 和 $(1, 2, 5, 4, 3)$。

### 子任务

::cute-table{tuack=4}

编号|$n$|$K$|特殊性质|编号|$n$|$K$|特殊性质
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
$1$|$\le 5$|$\le 3$|无|$11$|$\le 1000$|$\le 2$|A
$2$|$\le 10$|^|^|$12$|^|^|^
$3$|$\le 15$|^|^|$13$|^|^|^
$4$|$\le 20$|^|^|$14$|^|^|无
$5$|$\le 1000$|$=1$|A|$15$|^|^|^
$6$|^|$=1$|^|$16$|^|^|^
$7$|^|^|^|$17$|^|$\le 3$|A
$8$|^|^|无|$18$|^|^|^
$9$|^|^|^|$19$|^|^|无
$10$|^|^|^|$20$|^|^|^

其中性质 A 为保证树上所有节点至多有两个孩子。

对于所有的数据，保证 $1 \leq f_i \leq i$，$2 \leq n \leq 1000$。

## 样例 #1

### 输入

```
5 1
1 1 2 2```

### 输出

```
2```

# 题解

## 作者：Yajnun (赞：21)

状压dp，需要一定代码能力

对于每个子树，枚举其左边k个叶子和右边k个叶子的联通情况，其余的叶子节点不是路径端点状态。每个叶子节点共有四种情况。
1. 不是路径的端点。（记为0）
1. 是子树根所在路径的端点。（记为1，合法状态中该节点个数小于等于2）
1. 不与任何点相连，单独组成一种路径。（记为-1）
1. 是非子树根所在路径路径的端点。（每条路径记为一种颜色）

预处理出状态两两之间的转移情况。只考虑左右子树叶子节点之间连边情况即可。之后直接进行树形dp即可。统计答案时，枚举最左k个叶子和最右k个叶子的连边情况即可。（当叶子总数小于等于2k时，由于叶子之间连边会被重复计算，只能将链缩为一个点后直接暴力）。具体详见代码。

k=3，合法状态数共有2665种。左右状态叶子个数均大于等于6时，转移共有201536种。可以通过。



```
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<iostream>
#include<map>
#include<cstring>
#define ll long long
#define maxn 1005
#define p 998244353 
#define re(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
inline int read(){char c=getchar();int f=1;int ans = 0;while(c>'9'||c<'0'){if(c=='-')f=-f;c=getchar();}while(c<='9'&&c>='0'){ans =ans*10+c-'0';c=getchar();}return ans*f;}
//_____________________________________________________________________________________________________
int k,used[maxn],_n,n,m,_a[maxn][maxn],__a[maxn][maxn],leaf[maxn],_st[maxn];
ll ans;
inline int dfs1(int x)//缩链
{
    int cnt = 0,y;
    re(i,1,_n)
        if(_a[x][i])
            cnt++;
    if(cnt==1)
    {
        re(i,1,_n)
            if(_a[x][i])
                return dfs1(i);
    }
    used[x] = 1;
    if(!cnt)
    {
        _st[++_st[0]] = ++n;
        leaf[n]=1;
        return n;
    }
    int _x = ++n;
    re(i,1,_n)
        if(_a[x][i])
        {
            int y = dfs1(i);
            leaf[_x] += leaf[y] ;
            if(used[i])
                __a[_x][y] = 1;
            else
            {
                leaf[++n] = leaf[y];
                __a[_x][n] = __a[n][y] = 1;
            }
        }
    return _x; 
}
inline void build()
{
    re(i,1,_n)
        if(_a[1][i])
        {
            int y = dfs1(i);
            leaf[1] += leaf[y];
            if(used[i])
                __a[1][y] = 1;
            else
            {
                leaf[++n]=leaf[y];
                __a[1][n] = __a[n][y] = 1;
            }
        }
}
int __dp[1<<21][25];
inline void solve1()//暴力
{
    ans = 0;
    re(i,1,_st[0])
        re(j,1,k)
            __a[ _st[i] ][ _st[ i+j>_st[0] ? i+j-_st[0] : i+j ] ] = 1;
    re(i,1,n)
        re(j,1,n)
            if(__a[i][j])
                __a[j][i] = 1;
    int S = (1<<n)-1;__dp[1][1] = 1;
    for(int s=1;s<=S;s+=2)
        re(x,1,n)
            if(__dp[s][x]&&((s>>x-1)&1))
                re(y,1,n)
                    if(__a[x][y]&&(((s>>y-1)&1)==0))
                        (__dp[ s|(1<<y-1) ][y] += __dp[s][x])%=p;
    re(i,1,n)
        if(__a[1][i])
            (ans+=__dp[S][i])%=p;
    printf("%d\n",ans*(p+1)/2%p);
}
//______________________________________________
int match[40];
struct node
{
    int len,root;
    int s[13];
    inline void clear()
    {
        re(i,1,13)
            s[i] = 0;
        len = root = 0;
    }
    void pri()
    {
        printf("%d|",root);
        re(i,1,len)
            printf("%d ",s[i]);
        printf("\n________________________\n");
    };
    inline bool operator <(node x)const
    {
        if(root!=x.root ) return root<x.root ;
        if(len!=x.len) return len<x.len ;
        re(i,1,len)
            if(s[i]!=x.s [i])
                return s[i] < x.s [i];
        return false;
    }
    inline void sort(int sz)
    {
        int cnt = 1;
        re(i,2,sz)
            match[i] = 0;
        re(i,1,len)
            if( s[i]>1 )
            {
                if( match[s[i]] )
                    s[i] = match[s[i]];
                else
                    s[i] = match[s[i]] = ++cnt;
            }
    }
}node1,a[maxn*40];
map<node,int> mp;
int tot;
void dfs2(int i,int cnt)
{
    if(i==node1.len +1)
    {
        re(j,1,node1.len )
            if(node1.s [j])
            {
                a[++tot] = node1;
                mp[node1] = tot;
                break;
            }
        return ;
    }
    dfs2(i+1,cnt);
    if(!node1.s [i])
    {
        node1.s[i] = cnt+1;
        re(j,i+1,node1.len )
            if(!node1.s [j])
            {
                node1.s [j] = cnt+1;
                dfs2(i+1,cnt+1);
                node1.s [j] = 0;
            }
        node1.s [i] = 0; 
    }
}
struct turn
{
    int x,y,to;
    turn(int x=0,int y=0,int to=0)
    :x(x),y(y),to(to){};
}f[7][7][210000];
int tot_f[7][7];
#define pr pair<int,int> 
int st1[maxn*200],_st2;
pr st2[maxn*200];
inline void check(node x,int cnt)
{
    re(i,k+1,x.len-k)
        if(x.s [i])
            return;
    node1.clear(); 
    if(x.len>2*k)
    {
        node1.root = x.root ;
        node1.len = 2*k;
        re(i,1,k)
            node1.s [i] = x.s[i];
        re(i,x.len -k+1,x.len )
            node1.s [i- x.len  + 2*k] = x.s[i] ;
    }
    else node1 = x; 
    node1.sort(cnt);
    if( mp[node1]!=0 )
        st1[++st1[0]] = mp[node1];
}
int vis[20];
inline void dfs3(int i,int lim,node x,int cnt)
{
    if(i==lim+1)
    {
        check(x,cnt+1);
        return ;
    }
    dfs3(i+1,lim,x,cnt+1);
    if(x.s [i]>0)
        re(j,lim+1,min(x.len ,i+k))
        {
            int n_col = x.s [j]==1 || x.s[i] == 1 ? 1 : cnt+1;
            if(x.s [j]>0&&(x.s [j]!=x.s [i]||x.s[j]==1 ))
            {
                node1 = x;
                re(t,1,x.len )
                    if( x.s [t] == x.s [i] || x.s [t]==x.s [j] )
                        node1.s[t] = n_col;	
                node1.s [i] = node1.s [j] = 0;			
                dfs3(i+1,lim,node1,cnt+1);
            }
            if(x.s [j]==-1)
            {
                node1 = x;	
                node1.s [j] = node1.s [i];
                node1.s [i] = 0;
                dfs3(i+1,lim,node1,cnt+1);
            }
        }
    if(x.s [i]==-1)
        re(j,lim+1,min(x.len,i+k))
            if(x.s [j])
            {
                node1  = x;
                if(x.s [j]==-1)
                    node1.s [i] = node1.s [j] = cnt+1;
                else 
                    node1.s [i] = node1.s [j],
                    node1.s [j] = 0;
                dfs3(i+1,lim,node1,cnt+1);
                re(t,j+1,min(x.len,i+k))
                    if(x.s[t]==-1 ||(x.s[t]>0&&(x.s[t]!=x.s[j] || x.s[t]==1)))  
                    {
                        node1 = x;
                        node1.s [i] = 0;
                        if( x.s[j]==-1 && x.s[t] ==-1 )
                            node1.s [j] = node1.s [t] = cnt+1 ;
                        if( x.s[j]==-1 && x.s[t]!=-1)
                            node1.s [j] = node1.s [t] , node1.s [t] = 0;
                        if( x.s [j]!=-1&& x.s[t]==-1)
                            node1.s [t] = node1.s [j] , node1.s [j] = 0;
                        if( x.s [j]!=-1&&x.s[t]!=-1)
                        {
                            int n_col = x.s [j]==1 || x.s[t] == 1 ? 1 : cnt+1;
                            re(_t,1,x.len)
                                if(x.s[_t]==x.s[j]|| x.s[_t] == x.s[t] )
                                    node1.s [_t] = n_col ;
                            node1.s [j] = node1.s [t] = 0;
                        }
                        dfs3(i+1,lim,node1,cnt+1);	
                    }
            }
}
inline void Turn(node l,node r)
{
    if(l.root + r.root > 2)
        return;
    node1.clear();
    re(i,1,l.len )
        node1.s[i] = l.s [i];
    re(i,1,r.len )
        node1.s [ i+l.len ] = r.s [i] <=1 ? r.s [i] : r.s [i] + k ;
    node1.root = l.root + r.root ;
    node1.len = l.len + r.len ;
    dfs3( max(1,l.len -k+1),l.len , node1 ,2*k+1 );
}
inline int _Turn(int x)
{
    if(a[x].root == 0)
        return 0;
    if(a[x].root == 1)
        return x;
    node1 = a[x];
    node1.root = 0;
    re(i,1,node1.len )
        if(node1.s [i]==1)
            node1.s [i] = k+2;
    node1.sort(k+2);
    return mp[node1];
}
pr _f[maxn*40];int _tot_f,cnt_5;
ll dp[maxn][maxn*3],_dp[maxn*3];
inline ll count(int i,node x,int col)
{
    if(x.len !=2*k || x.root !=2)
        return 0;
    if(i==k+1)
    {
        re(t,1,2*k)
            if(x.s[t])
                return 0;
        return 1;
    }
    int cnt = 0;
    if(!x.s[i])
        cnt = count(i+1,x,col);
    if(x.s[i]>0)
        re(j,k+i,2*k)
            if(x.s[j])
            {
                node1 = x;
                if( x.s[j]>0 &&( x.s [j]==1 ||  x.s[i] !=x .s[j]))
                {
                    int n_col = x.s [i]==1 || x.s [j] ==1 ? 1 : col +1;
                    re(t,1,2*k)
                        if( x.s [t] == x.s[i] || x.s[t]== x.s[j] )
                            node1.s [t] = n_col;
                    node1.s [i] = node1.s [j] = 0;
                    cnt += count(i+1,node1,col+1);
                }
                if( x.s[j]==-1 )
                {
                    node1.s [j] =  node1.s [i];
                    node1.s [i] = 0;
                    cnt += count(i+1,node1,col+1);
                }
            }
    if(x.s[i]==-1)
    {
        re(j,k+i,2*k)
            if(x.s[j])
            {
                re(t,j+1,2*k)
                {
                    node1  =x;
                    if( x.s[t]==-1 ||(x.s[t]>0 && (x.s[t]==1|| x.s[t]!=x.s[j] )))
                    {
                        node1.s [i] = 0;
                        if( x.s[j]==-1 && x.s[t] ==-1 )
                            node1.s [j] = node1.s [t] = col+1;
                        if( x.s[j]==-1 && x.s[t]!=-1)
                            node1.s [j] = node1.s [t] , node1.s [t] = 0;
                        if( x.s [j]!=-1&& x.s[t]==-1)
                            node1.s [t] = node1.s [j] , node1.s [j] = 0;
                        if( x.s [j]!=-1&&x.s[t]!=-1)
                        {
                            int n_col = x.s [j]==1 || x.s[t] == 1 ? 1 : cnt+1;
                            re(_t,1,x.len)
                                    if(x.s[_t]==x.s[j]||x.s[_t]==x.s[t])
                                        node1.s [_t] = n_col ;
                            node1.s [j] = node1.s [t] = 0;
                        }
                        cnt += count( i+1,node1,col+1 );
                    }
                }
            }
    }
    return cnt;	
}
void dfs4(int x)
{
    int bo = 0,cnt_leaf=0;
    re(y,1,n)
        if(__a[x][y])
        {
            dfs4(y);
            if(!bo)
            {
                memcpy(dp[x],dp[y],sizeof(dp[x]));
                bo = 1;
                cnt_leaf = leaf[y];
            }
            else 
            {
                memcpy(_dp,dp[x],sizeof(_dp));
                memset(dp[x],0,sizeof(dp[x]));
                re(t,1,tot_f[ cnt_leaf ][ leaf[y] ])
                {
                    turn _ = f[ cnt_leaf ][ leaf[y] ][t] ; 
                    ( dp[x][ _.to ] += _dp[ _.x ] * dp[y][ _.y ])%=p;
                }
                cnt_leaf = min( cnt_leaf + leaf[y] , 2*k); 
			
		
             }
    	}
    if(!bo)
    {
        dp[x][1] = dp[x][2] = 1;
        return ;
    }
    if(x!=1)
    {	
       
        memcpy(_dp,dp[x],sizeof(_dp));
        memset(dp[x],0,sizeof(dp[x]));
        re(t,1,_tot_f)
            ( dp[x][ _f[t].second ] += _dp[ _f[t].first ] )%=p ;
    }
    else
        re(t,1,tot)
        {
           ( ans += count(1,a[t],k+1) * dp[x][t] )%=p;
       }
}
int main()
{
	//freopen("0.in","r",stdin);
    _n = read(),k=read();
    re(i,2,_n)
        _a[read()][i] = 1;
    n = 1;
    build();
    re(i,1,n)
    	leaf[i] = min( leaf[i],2*k );
    if(n<=21)
    {
     solve1();  
	 return 0;
    }
    re(i,1,2*k)
    {
        node1.len = i;
        re(s,0,(1<<i)-1)
        {
            re(w,1,i)
                node1.s [w] = - ((s>>w-1)&1);
            node1.root = 0;
            dfs2(1,1);
            re(j,1,i)
                if(node1.s [j]!=-1)
                {
                    node1.root  = 1;
                    node1.s [j] = 1;
                    dfs2(1,1);
                    node1.root = 2;
                    re(k,j+1,i)
                        if(node1.s [k]!=-1)
                        {
                            node1.s[k] = 1;
                            dfs2(1,1);
                            node1.s[k] = 0;
                        }
                    node1.s[j]=0;
                }	
        }
    }			
    node1.clear();
    node1.root = 2;
    node1.len = k*2;
    a[++tot] = node1;
    mp[node1] = tot;
    re(i,1,tot)
        re(j,1,tot)
        {
            st1[0] = 0;
            Turn(a[i],a[j]);            
            if(st1[0])
      	      re(t,1,st1[0])
      	          f[ a[i].len ][ a[j].len ][ ++tot_f[a[i].len ][a[j].len ]] = turn(i,j,st1[t]);
       }
    re(i,1,tot)
    {
        int to = _Turn(i);
        if(to)
	    	_f[++_tot_f] = make_pair( i,to );
    }
    dfs4(1);
    printf("%lld\n",ans);
    return  0;
}

```


---

## 作者：璀璨星空1 (赞：12)

> 再逢春 诗酒惟对流云  
> 续佚文 翰墨却为只字困  
> 灼灼新桃 不识旧人  
> 已无寻 一抔俱焚

很不错的一道子树 DP 加状压 DP 的题目，可以定到 $\bold{\texttt{Lv}\ 17}$。不过在 $\text{NOI 2018}$ 比赛当中似乎观赏性 $>$ 实用性。

------

### $1$ 棵子树的所有状态

子树 DP。$u$ 子树内的所有点在最终回路中形成若干条链。注意到 $u$ 子树内与外界有边的点 $\leq2k+1$ 个：包括 $u$ 本身以及最左、最右的 $k$ 个叶子。称这些点是界点，其他点是内点。那么这若干条链的首尾都一定是界点，内点一定都藏在链的中间。

对于状态 $x$，我们用 $1$ 个有序的 $\texttt{vector<pair<int,int>>}$ 记录每条链的首尾，其中各条链之间没有顺序，$1$ 条链的首和尾也没有区别。那么 $u$ 子树的状态个数 $m_a$ 与 $u$ 子树内的叶子个数 $a$ 有关，满足递推式 $m_i=2m_{i-1}+im_{i-2}$。我们有 $m_0\sim m_6$ 分别 $=2,5,14,43,142,499,1850$。

------

### 逐子树合并 DP 状态

接下来我们逐子树合并 DP 状态，每次将 $v_i$ 子树的状态合并到 $u$ 上。合并 $u$ 和 $v_i$ 时有 $2$ 个连通块：其 $1$ 是 $u$ 以及 $u$ 在 $v_{i-1}$ 以前的所有子树，其 $2$ 是 $v_i$ 的子树。我们称连通块 $1$ 为枫，它的界点是枫点，以枫点为端点的链是枫链。称连通块 $2$ 为海，同理定义海点和海链。我们要计算有多少种方法将枫链与海链首尾相连交替拼接成一些更长的两色链。

注意到转移的系数只与枫的叶子个数 $a$，海的叶子个数 $b$ 以及第 $1$ 个枫叶子与第 $b$ 个海叶子之间的距离 $d\in[1,k+1]$ 有关。我们考虑预处理状态之间的转移系数，用 $4$ 元组 $(x,y,z,w)$ 表示状态 $x,y$ 以 $w$ 的权值转移到状态 $z$。

在 DFS 出状态以后，我们首先在同一个 $a$ 下，预处理出 $\text{merge}(x,y)$ 表示将 $x$ 与 $y$ 中的链取并集得到的状态。再预处理出 $\text{material}(x)$ 表示 $x$ 中的链用到的端点集合。那么 $\text{merge}(x,y)$ 存在当且仅当 $\text{material}(x)\cap\text{material}(y)=\varnothing$。

预处理转移系数的第 $1$ 步是预处理 $5$ 元组 $(x,y,u,v,w)$ 表示将枫状态 $x$ 中的所有链与海状态 $y$ 中的所有链拼接成 $1$ 条两色链 $u\sim v$ 的方案数。每次根据 $v$ 是枫点还是海点枚举下 $1$ 条海链或枫链进行转移。

第 $2$ 步是预处理 $4$ 元组 $(x,y,z,w)$。每次枚举下 $1$ 条两色链 $u\sim v$，将 $4$ 元组 $(x,y,z,w)$ 与 $5$ 元组 $(x',y',u,v,w')$ 合并得到新 $4$ 元组 $\big(\text{merge}(x,x'),\text{merge}(y,y'),\text{merge}(z,u\sim v),ww'\big)$。这里我们不能承受暴力枚举 $5$ 元组，我们考虑找到所有 $\text{material}(x')$ 与 $\text{material}(x)$，$\text{material}(y')$ 与 $\text{material}(y)$ 交集 $=\varnothing$ 的 $5$ 元组尝试转移。在第 $1$ 步之后开 $2^{a+b+2}$ 个 $\texttt{vector}$ 存转移即可。

------

### 剪枝以及计算答案

预处理转移系数时有 $3$ 个参数 $a,b,d$。我们可以在树形 DP 用到一组 $a,b,d$ 时再预处理，因为 $d$ 几乎总是 $=k+1$。

最后根 $1$ 与它最后 $1$ 个儿子 $u$ 的合并需要特殊处理。先特判根只有 $1$ 个儿子的情况，此时答案 $=0$。否则先断开 $(1,u)$，分别 DP 后再处理最后 $1$ 次枫链与海链的合并。枫链与海链交替拼接成 $1$ 个环时枫点会与海点发生偶数次接触，我们选取枫点编号最小的那条边断开，计入答案。但当该枫点是孤点时环会被计算正反共 $2$ 遍，此时把贡献设为 $\dfrac12$ 即可。

计算答案的过程实际上就是一组 $(a,b,d)=(a_1,a_u,1)$ 的预处理。但因为只用拼接成 $1$ 条链，只需要预处理到 $5$ 元组即可。

当 $k=3$ 时，$a=6$ 的点状态共有 $m_6=1850$ 个，$(a,b,d)=(6,6,4)$ 的转移共有 $155422$ 个，可以通过。

时间复杂度 $\mathcal{O}\big(nF(k)+G(k)\big)$，空间复杂度 $\mathcal{O}\big(nm_{2k}+S(k)\big)$。代码链接：https://uoj.ac/submission/632559。

---


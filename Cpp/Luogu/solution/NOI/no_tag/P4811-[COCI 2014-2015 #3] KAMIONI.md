# [COCI 2014/2015 #3] KAMIONI

## 题目描述

**译自 [COCI 2014/2015 Contest 3](http://www.hsin.hr/coci/archive/2014_2015/) T6「KAMIONI」**

有一条马路，我们将其视为一条数轴。马路上有 $N$ 辆卡车，开始时，卡车都在整点上。所有卡车一起开始移动，并且都以**同样的速率**移动。**没有卡车保持静止**。每辆卡车花 $1$ 分钟可以移动 $1$ 个单位距离。

给出每辆卡车的「路线」。路线用一个含有 $k$ 个元素的数组 $A_1,A_2,\dots,A_k$ 表示。该卡车首先 $A_1$ 开往 $A_2$，然后立即掉头开往 $A_3$，以此类推。忽略掉头的耗时。考虑到卡车会掉头，我们保证：

$$A_1 < A_2 > A_3 < A_4 > \dots\ \mathrm{or}\ A_1 > A_2 < A_3 > A_4 < \dots$$

一条可能的路线为 $2→5→1→7$（给出的点要么是起点，要么是终点，要么就是掉头的位置）。开始时卡车位于 $2$，出发 $3$ 分钟后到达位置 $5$，接着掉头。卡车继续行驶到位置 $1$ ，此时距出发已过去了 $7$ 分钟。卡车再次掉头，并行驶到位置 $7$，此时距出发已经经过了 $13$ 分钟。

当卡车到达路线终点后，会有神秘的 ~~Planet6174~~ 外星人出现并把它带回飞船。

给出这 $N$ 辆卡车的路线。现在有 $M$ 组询问，每组询问包含两辆卡车。对于每组询问，请回答这对卡车出现在同一位置的次数。位置不一定是整数，比如它们可以在位置 $2.5$ 相遇。

请注意，保证每一对**询问的**（而不是随便一对）卡车：

 - 其中一个被 ~~Planet6174~~ 外星人带走的时候，它们不会在同一位置。
 - 它们不会在初始时刻或是其中一个转弯的时候在同一位置。

> Planet6174：翻译这道题目的人已经被解决掉了（滑稽

## 说明/提示

对于 $50\%$ 的数据，保证 $N \le 10^2,K_i \le 10^3,M \le 10^3$。

## 样例 #1

### 输入

```
3 3
3 1 3 1
2 2 1
3 3 1 3
1 2
2 3
3 1```

### 输出

```
1
0
2```

## 样例 #2

### 输入

```
2 1
4 1 6 3 6
7 3 4 2 6 5 6 1
1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
3 4
3 1 4 2
4 3 4 2 4
3 4 1 3
1 2
2 3
3 1
1 3```

### 输出

```
2
1
2
2```

# 题解

## 作者：Inui_Sana (赞：5)

我觉得这题 $O((q+K)\sqrt K\log K)$ 非常自然而且非常可过吧，怎么题解区还没有。

一句话：每次询问枚举短的路线，在长的上二分，再记忆化可过。

考虑分析复杂度。记 $k=\sum K_i$。询问 $x,y$，令 $K_x<K_y$。若 $K_x\le\sqrt k$，显然每次不会枚举超过 $O(\sqrt k)$ 个位置。这部分是 $O(q\sqrt k\log k)$ 的。

否则，考虑每个位置被枚举了几次。因为 $K_y>\sqrt k$ 所以不同的 $y$ 最多有 $\sqrt k$ 个。记忆化之后，每个位置就会被枚举到不超过 $\sqrt k$ 次。所以这部分是 $O(k\sqrt k\log k)$ 的。

于是总复杂度 $O((q+k)\sqrt k\log k)$。实现的不太差就能通过。最慢点跑了 2.6s。

也讲一下二分的方法。注意到两车 $A,B$ 速度一样，所以 $A$ 车从 $u$ 直线到 $v$ 的过程中，两车最多相遇一次。同时容易证明，相遇的充要条件为两车位置的大小关系发生变化。于是二分 $B$ 车在 $A$ 分别在 $u,v$ 时的位置，判断大小关系是否变化即可。

代码非常清新。

code：

```cpp
int n,q,c[N];
vector<int> g[N];
vector<ll> t[N];
map<pair<int,int>,int> mp;
il int getPos(int x,ll tm){
	int p=upper_bound(t[x].begin(),t[x].end(),tm)-t[x].begin()-1;
	return g[x][p+1]>g[x][p]?g[x][p]+tm-t[x][p]:g[x][p]-tm+t[x][p];
}
void Yorushika(){
	read(n,q);
	rep(i,1,n){
		read(c[i]);
		g[i].resize(c[i]+1),t[i].resize(c[i]+1);
		rep(j,1,c[i]){
			read(g[i][j]);
			t[i][j]=j==1?0:t[i][j-1]+abs(g[i][j]-g[i][j-1]);
		}
	}
	while(q--){
		int x,y;read(x,y);
		if(g[x].size()>g[y].size()||g[x].size()==g[y].size()&&x>y){
			swap(x,y);
		}
		if(mp.count(Mp(x,y))){
			printf("%d\n",mp[Mp(x,y)]);
			continue;
		}
		int ans=0;
		rep(i,1,c[x]-1){
			if(t[x][i]>=t[y][c[y]]){
				break;
			}
			ll l=t[x][i],r=min(t[x][i+1],t[y][c[y]]);
			int u1=g[x][i],v1=getPos(y,l),u2=g[x][i+1]>g[x][i]?u1+r-l:u1-r+l,v2=getPos(y,r);
			ans+=(u1>v1)^(u2>v2);
		}
		printf("%d\n",mp[Mp(x,y)]=ans);
	}
}
signed main(){
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---

## 作者：smarthehe (赞：4)

### 做法：

首先把所有卡车的所有拐点合在一起，按达到的时间排序。

把所有询问离线下来。对于每个询问，找到两卡车中拐点较少者，绑定在该车上。对于重复的询问，直接记忆化判掉。

可以发现，任意一车的两拐点之间两车最多相遇一次，并且在这道题目中不存在追及。

在被绑定车的两拐点之间，我们画出原询问的两辆车的 x-t 图。

容易发现，被绑定车的图像一定是一条单调直线，而另一车的图像是分段单调的折线。（图来源：Mr_Wu 手绘）

![](https://cdn.luogu.com.cn/upload/image_hosting/c0w67kxf.png)

那么如果这两辆车有交，就只能是两辆车的相对左右关系在两拐点处不同。

又考虑，每个询问只会考虑被绑定车的所有拐点，所以我们在得出当前这个拐点处询问的两车的左右关系时，可以将这个关系连带存在询问上。这样，在到达绑定车的下一个拐点时，就容易判断了。

那么，枚举所有拐点，动态设定一辆车的位置和方向。每枚举到一个拐点，枚举和拐点所属车绑定的所有询问，处理即可。

另外，对于在到达某一拐点前除绑定车以外的另一辆询问车消失的情况，也是有可能相遇的。处理比较恶心，需要特判。（并且样例里面没有这个情况，如果你样例全过却 wa 声一片，可以看看是不是这个原因）

### 时间复杂度分析：

考虑可能发生的所有询问以及其对应绑定的卡车路径长度。从大到小排序后前 $q$ 项和就是最大枚举复杂度。

我们令每辆卡车的路径长度从大到小为 $k_1,k_2,\cdots,k_n$。

那么最大的枚举复杂度显然为 $1 * k_2 + 2 * k_3 + \cdots$（系数和为 $q$）

随意放缩简化一下，令上述式子没有包含的 $k_i = 0$，并假定式子即为 $\sum_{i=1}^x i * k_i$ 的形式。

基于等差数列求和公式，可得 $x$ 在 $\sqrt{q}$ 级别。不妨令 $x=\sqrt{q}$。

那我们的问题转化为：

已知 $\sum_{i=1}^{\sqrt{q}} k_i = k$，求 $\max \{ \sum_{i=1}^{\sqrt{q}} i * k_i \}$。 

根据大小关系，易得 $k_i \leq \frac{k}{i}$，因此时间复杂度 $O (k \sqrt{q})$。

### 代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#include <vector>
using namespace std;
const int N=1e5+1,K=3e5+1;
struct status
{
	int pos,dir,ised;
	long long clk;
} st[N];
struct turn
{
	int pos,bel,ised;
	long long clk;
	turn(int pos=0,int bel=0,int ised=0,long long clk=0):
		pos(pos),bel(bel),ised(ised),clk(clk){}
} p[K];
int ans[N],len[N],tl,link[N];
struct query
{
	int x,y,aso;
	query(int x=0,int y=0,int aso=0):
		x(x),y(y),aso(aso){}
} q[N];
vector<int> qry[N];
map<pair<int,int>,int> mem;
inline int cmp(turn a,turn b){return a.clk<b.clk;}
int main()
{
	int n,m,i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		long long tmp=0;
		int bef;
		scanf("%d",&len[i]);
		for(j=1;j<=len[i];j++)
		{
			int x;
			scanf("%d",&x);
			if(j==1) st[i].pos=x;
			else
			{
				if(j==2) st[i].dir=(x>bef);
				tmp+=max(bef,x)-min(bef,x);
				p[++tl]=turn(x,i,j==len[i],tmp);
			}
			bef=x;
		}
	}
	sort(p+1,p+tl+1,cmp);
	for(i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(len[x]>len[y]||(len[x]==len[y]&&x>y)) swap(x,y);
		if(mem.count(make_pair(x,y))) link[i]=mem[make_pair(x,y)];
		else
		{
			mem[make_pair(x,y)]=i;
			q[i]=query(x,y,st[x].pos>st[y].pos);
			qry[x].push_back(i);
		}
	}
	for(i=1;i<=tl;i++)
	{
		int now=p[i].bel,siz=qry[now].size();
		for(j=0;j<siz;j++)
		{
			int tmp=q[qry[now][j]].y,fnpos1=p[i].pos,fnpos2=st[tmp].pos;
			if(q[qry[now][j]].aso==-1) continue;
			int delta=p[i].clk-st[tmp].clk;
			if(st[tmp].ised)
			{
				if(st[now].dir) fnpos1-=delta;
				else fnpos1+=delta;
			}
			else
			{
				if(st[tmp].dir) fnpos2+=delta;
				else fnpos2-=delta;
			}
			if(q[qry[now][j]].aso^(fnpos1>fnpos2)) ans[qry[now][j]]++;
			if(st[tmp].ised) q[qry[now][j]].aso=-1;
			else q[qry[now][j]].aso=(fnpos1>fnpos2);
		}
		st[now].pos=p[i].pos,st[now].dir^=1;
		st[now].clk=p[i].clk,st[now].ised=p[i].ised;
	}
	for(i=1;i<=m;i++)
	{
		if(link[i]) printf("%d\n",ans[link[i]]);
		else printf("%d\n",ans[i]);
	}
	return 0;
}
```


---

## 作者：rEdWhitE_uMbrElla (赞：2)

难得的没人做的水紫题。。

我的做法：

首先我们应该将每一辆车的转折点按照发生时间来排序。将所有不重复的查询都保存在拐点少的那个的名下。然后枚举每一个拐点就可以了。 

这里是官方题解：

1. 预处理每一个辆车的每一个转折点，以及方向，并且按照时间排序。

2. 对于卡车i，绑定与它有查询关系的卡车，保存的时候保证i的转折点要小于与它绑定的其他卡车。显然，如果i的转折点大于某一辆卡车，它会被另外一辆卡车绑定。用这个去优化前面能过一半点的代码。‘

3. 取出一个转折点，处理与对应的卡车有查询关系的卡车。

程序：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long llint;
typedef pair<int, int> pii;
const int MAXN = 300100;

enum { LEFT = -1, ABDUCTED, RIGHT };

struct event {
    int truck_id;
    int x, direction;
    llint time;
};

struct query {
    int truck_id, was_left, query_id;
};

struct truck {
    int k;
    int x, direction;
    llint time;
    vector<query> queries;
};

truck trucks[MAXN];
int ans[MAXN];

void apply_event(const event &e) {
    trucks[e.truck_id].x = e.x;
    trucks[e.truck_id].direction = e.direction;
    trucks[e.truck_id].time = e.time;
}

int check_is_left(const truck &a, const truck &b, llint prev_time, int prev_direction) {
    if (b.direction == ABDUCTED && prev_time >= b.time)
        return ABDUCTED;
    int b_pos, a_pos;
    if (b.direction == ABDUCTED) {
        b_pos = b.x;
        a_pos = (a.time - b.time) * (-prev_direction) + a.x;
    } else {
        a_pos = a.x;
        b_pos = (a.time - b.time) * b.direction + b.x;
    }
    assert(b_pos != a_pos);
    if (b_pos < a_pos)
        return LEFT;
    return RIGHT;
}

void solve_query(const truck &t, query &q, llint prev_time, int prev_direction) {
    int is_left = check_is_left(t, trucks[q.truck_id], prev_time, prev_direction);
    ans[q.query_id] += (q.was_left * is_left == -1);
    q.was_left = is_left;
}

bool cmp(const event &a, const event &b) {
    if (a.time != b.time)
        return a.time < b.time;
    return a.direction > b.direction;
}

int main() {
    int n, m;
    vector<event> events;
    map<pii, vector<int>> same_queries;
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; ++i) {
        int x;
        llint sum_time = 0;
        scanf("%d%d", &trucks[i].k, &x);
        for (int j = 0; j < trucks[i].k - 1; ++j) {
            int new_x;
            scanf("%d", &new_x);
            event e = { i, x, x < new_x ? RIGHT : LEFT, sum_time };
            if (j == 0) {
                apply_event(e);
            } else {
                events.push_back(e);
            }
            sum_time += abs(x - new_x);
            x = new_x;
        }
        event e = { i, x, ABDUCTED, sum_time };
        events.push_back(e);
    }
    for (int i = 0; i < m; ++i) {
        int a, b;
        scanf("%d%d", &a, &b);
        --a;
        --b;
        if (a > b)
            swap(a, b);
        same_queries[{ a, b }].push_back(i);
        if ((int)same_queries[{ a, b }].size() > 1)
            continue;
        if (trucks[a].k > trucks[b].k)
            swap(a, b);
        trucks[a].queries.push_back({ b, trucks[b].x < trucks[a].x ? LEFT : RIGHT, i });
    }
    sort(events.begin(), events.end(), cmp);
    for (const event &e : events) {
        llint prev_time = trucks[e.truck_id].time;
        int prev_direction = trucks[e.truck_id].direction;
        apply_event(e);
        for (query &q : trucks[e.truck_id].queries)
            solve_query(trucks[e.truck_id], q, prev_time, prev_direction);
    }
    for (auto queries : same_queries) {
        int res = ans[queries.second[0]];
        for (int t : queries.second) ans[t] = res;
    }
    for (int i = 0; i < m; ++i) printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：qnqfff (赞：1)

模拟赛题，放 t3 了，然后没开，输麻了。

### 思路

令路线长度较小的卡车为 $x$，另一个为 $y$。

$x$ 从一个点到另一个点间最多与 $y$ 相交一次，于是考虑枚举 $x$ 的每一次移动，$y$ 的位置是可以根据时间算出来的，若移动前和移动后与 $y$ 的相对位置关系发生变化则有交。

复杂度 $O(n\sqrt n\log n)$，能过。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
int read(){char c=getchar();int p=0,flg=1;while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,m;vector<int>a[100010],sum[100010];map<array<int,2>,int>mp;
signed main(){
	n=read();m=read();for(int i=1;i<=n;i++){
		int k=read();
		while(k--) a[i].push_back(read());
		sum[i].push_back(0);
		for(int j=0;j<a[i].size()-1;j++) sum[i].push_back(sum[i].back()+abs(a[i][j+1]-a[i][j]));
		sum[i].push_back(1e18);
	}while(m--){
		int x=read(),y=read(),ans=0;
		if(a[x].size()>a[y].size()||(a[x].size()==a[y].size()&&x>y)) swap(x,y);
		if(mp.count({x,y})){cout<<mp[{x,y}]<<'\n';continue;}
		for(int i=0;i<a[x].size()-1;i++){
			int A=lower_bound(sum[y].begin(),sum[y].end(),sum[x][i])-sum[y].begin();
			int B=lower_bound(sum[y].begin(),sum[y].end(),sum[x][i+1])-sum[y].begin();
			if(sum[y][A]==1e18||(sum[y][B]==1e18&&sum[y][B-1]<=sum[x][i])) continue;
			int L,R;
			if(sum[x][i]==sum[y][A]) L=a[x][i]<a[y][A];
			else{
				int v=a[y][A-1];
				if(a[y][A-1]<a[y][A]) v+=sum[x][i]-sum[y][A-1];
				else v+=sum[y][A-1]-sum[x][i];
				L=a[x][i]<v;
			}
			if(sum[y][B]==1e18){
				int v=a[x][i];
				if(a[x][i]<a[x][i+1]) v+=sum[y][B-1]-sum[x][i];
				else v+=sum[x][i]-sum[y][B-1];
				R=v<a[y][B-1];
			}
			else{
				int v=a[y][B-1];
				if(a[y][B-1]<a[y][B]) v+=sum[x][i+1]-sum[y][B-1];
				else v+=sum[y][B-1]-sum[x][i+1];
				R=a[x][i+1]<v;
			}
			ans+=L^R;
		}cout<<(mp[{x,y}]=ans)<<'\n';
	}
	return 0;
}
```

---

## 作者：Polarisx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4811)。

## 思路

这种有 $\sum$ 限制的题一般都会想到根号分治。

容易发现对于一个询问 $(x,y)$，由于两辆车不会在起始位置，终止位置和转折位置同时出现在同一个位置，因此相遇次数不会超过 $\min(k_x,k_y)$，假设 $x$ 现在要从 $a_{x,i}\to a_{x,i+1}$ 走直的一段，不妨令 $t_{x,i}$ 表示第 $x$ 个车到第 $i$ 个位置的用时，考虑如何判断 $x,y$ 会在此过程中相遇，当且仅当 $t_{x,i}$ 时刻 $y$ 在 $x$ 的一侧，$t_{x,i+1}$ 时刻 $y$ 在 $x$ 的另一侧，这中间两车只会相遇一次，因为速度相同。

这样一次询问的时间复杂度就是 $\mathcal O(\min(k_x,k_y)\log n)$，设一个阈值，我们对 $k_x,k_y\ge B$ 暴力求并记忆化，其他情况直接暴力求，时间复杂度 $\mathcal O(q\sqrt n\log n)$。

可以再写一个单次 $\mathcal O(\max(k_x,k_y))$ 的暴力，平衡时间复杂度即可做到 $\mathcal O(q\sqrt{n\log n})$。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=1e5+7,B=350;
int n,Q;
int k[Maxn];
vector<int>p[Maxn];
vector<ll>t[Maxn];

vector<int>usd;
int id[Maxn];

int ans[2000][2000];
int uans[Maxn];

inline int tim(int x,ll v){
	int u=upper_bound(t[x].begin(),t[x].end(),v)-t[x].begin()-1;
	if(u==k[x]-1){
		if(t[x][u]==v) return p[x][u];
		return -1;
	}
	if(p[x][u+1]>p[x][u]) return p[x][u]+v-t[x][u];
	return p[x][u]-(v-t[x][u]);
}
inline int baoli2(int x,int y){
	if(k[x]>k[y]) swap(x,y);
	int ret=0;
	for(int i=0;i<k[x]-1;i++){
		int px=tim(y,t[x][i]),py=tim(y,t[x][i+1]);
		if(px==-1) break;
		if(py==-1){
			if((px>p[x][i])!=(p[y].back()>tim(x,t[y].back()))) ret++;
			else if(p[y].back()==tim(x,t[y].back())) ret++;
			break;
		}
		if((px>p[x][i])!=(py>p[x][i+1])) ret++;
	}
	return ret;
}
inline int baoli1(int x,int y){
	vector<ll>nw(k[x]+k[y]);
	vector<int>px,py;
	merge(t[x].begin(),t[x].end(),t[y].begin(),t[y].end(),nw.begin());
	ll vp=min(t[x].back(),t[y].back());
	int nx=0,ny=0,ux=p[x][0],uy=p[y][0];
	for(auto i:nw){
		
		while(nx+1<k[x] and t[x][nx+1]<=i) 
			ux+=(p[x][nx]<p[x][nx+1]?1:-1)*(t[x][nx+1]-t[x][nx]),++nx;
		while(ny+1<k[y] and t[y][ny+1]<=i) 
			uy+=(p[y][ny]<p[y][ny+1]?1:-1)*(t[y][ny+1]-t[y][ny]),++ny;
		int ix=ux,iy=uy;
		if(nx+1<k[x]) ix+=(p[x][nx]<p[x][nx+1]?1:-1)*(i-t[x][nx]);
		if(ny+1<k[y]) iy+=(p[y][ny]<p[y][ny+1]?1:-1)*(i-t[y][ny]); 
		px.emplace_back(ix),py.emplace_back(iy);
		if(i==vp) break;
		
	}
	int ret=0;
	for(int i=1;i<k[x]+k[y];i++){
		ret+=((px[i-1]>py[i-1])!=(px[i]>py[i]));
		if(nw[i]==vp) break;
	}
	return ret;
}


int main(){
	
	scanf("%d%d",&n,&Q);
	for(int i=1;i<=n;i++){
		scanf("%d",&k[i]); p[i].resize(k[i]); t[i].resize(k[i]);
		for(int j=0;j<k[i];j++){
			scanf("%d",&p[i][j]);
			if(!j) t[i][j]=0;
			else t[i][j]=t[i][j-1]+abs(p[i][j]-p[i][j-1]);
		}
		if(k[i]>B) id[i]=usd.size(),usd.emplace_back(i);
	}
	memset(ans,-1,sizeof ans);

	for(int i=1;i<=Q;i++){
		int x,y;
		scanf("%d%d",&x,&y); 
		if(k[x]>B and k[y]>B){
			if(ans[id[x]][id[y]]==-1) ans[id[x]][id[y]]=baoli1(x,y);
			uans[i]=ans[id[x]][id[y]];
		}
		else if(k[x]<=B and k[y]<=B){
			uans[i]=baoli1(x,y);
		}
		else uans[i]=baoli2(x,y);
	} 
	for(int i=1;i<=Q;i++) printf("%d\n",uans[i]);
	
	return 0;
}
```

---

## 作者：哈撒各一 (赞：1)

首先这道题想到暴力思路是比较简单的。

只要我们发现了两辆车如果一个移动之后相对位置变化，就是发生了相遇。

我们用这个思路暴力模拟每一个询问，就可以的到68分。

由于我们得到68分这种较多的分数，那么我们就可以考虑正解是否是有这种方法优化出来的。

那么我们发现题目中说到每一辆车的速度相同，那么就是说明两辆车的方向相同时是不可能相遇的。

那么我们就可以从原来的枚举一个询问中的两辆车转化为枚举一辆车，因为这辆被我们选定的车在每一段移动之中只能与另一辆车相遇一次。

那么我们为了获得最好的效果，我们肯定要选择转折点最少的车作为中心车辆。

那么我们就可以更胜一筹的离线处理，将所有以a车为中心车辆的车统一储存起来，一起处理。

以上说的这些在其他题解已经说得很清楚，而且也比较容易理解。

但是由于官方题解的代码实在是~~不可阅读~~我太偲了，而其他人写的代码也~~晦涩难懂~~我太偲了。

所以我在下面附上一份详细注释的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 300010
#define ll long long
#define PII pair<int,int>

//这一个结构体记录场上所有的运动 
struct event{
	int id,p,dir;
	//id->car_index
	//p->start_place
	//dir->direction 
	ll timee;
	//timee->start_time
	
	//
	bool operator <(const event &A)const{
		if(timee!=A.timee)return timee<A.timee;
		return dir>A.dir;
	}
	
	
	event(){};
	event(int a,int b,int c,ll d){
		id=a,p=b,dir=c,timee=d;
	}
};


//hash_part
//为了排除出题人出很多组相同的大询问卡我们。
//我们将所有的相同询问hash储存起来，防止重复计算 
int h[1000000];//h(i)->hash值为i的询问出现次数 
PII hsh[1000000];//hsh(i)->hash值为i表示的询问组合 
int hshit(PII t){
	int p=1ll*(t.second-t.first)*t.first*791224%1000000;
	//我们对于每一个要求的卡车组合都将其hash 
	while(h[p]&&hsh[p]!=t)p=(p+1)%1000000;
	++h[p];
	hsh[p]=t;
	//如果出现过：次数加一，对于hsh是没有影响的
	//如果没有出现过就新建节点 
	return p;
}

//这个结构体记录每个询问的两个辆车的相对位置：
// was_left=1->a在b左边 
// was_left=0->a在b右边 
struct Ask{
	int id,was_left,qid;
	Ask(){}
	Ask(int a,int b,int c){
		id=a;was_left=b;qid=c;
	}
};

//这个数组涉及我们这道题的一个优化：
//我们将转折点个数大于a点的点都与a点同时处理-> Adj
//还有一个优化是重复出现的询问统一处理 ->hs
struct List{
	int id,num;
	vector<int> idx;
	List *next;
	List(){
		next=NULL;
		id=num=-1;
	}
}*Adj[N],*hs[1000000];

//这个数组储存的就是每个卡车的信息，位置 
struct truck{
	int k,p,dir;
	//k->转折点数量
	//p->now_place
	//dir->direction 
	ll timee;
	//timee->到这个位置已经消耗了的时间 
	vector<Ask> asks;
	//所有要以这辆卡车为中心车的的询问都存入asks里一并处理 
}trucks[N];


inline void read(int &n){
	n=0;char op=getchar();
	while(!isdigit(op)){op=getchar();}
	while(isdigit(op)){n=(n<<1)+(n<<3)+(op^48);op=getchar();}
}
int n,m;

//记录卡车的每一次移动 
void init(event &e){
	trucks[e.id].p=e.p;
	trucks[e.id].dir=e.dir;
	trucks[e.id].timee=e.timee;
}

//执行行动 
inline int check(const truck &a,const truck &b,ll pretime,int predir){
	//在执行这个行动时b车已经到达目的地了 
	if(!b.dir&&pretime>=b.timee){
		return 0;
	}
	
	int b_pos,a_pos;
	//下面的操作我用伪代码解释：
	//if(b车朝左走)
	//	 直接让b车到这次行动的目的地
	//	 计算b车移动的时间，a车按照a车的方向移动相同时间
	//else
	//	 直接让a车到这次行动的目的地
	// 	 计算a车移动的时间，b车按照b车的方向移动相同时间 
	if(!b.dir){
		b_pos=b.p;
		a_pos=(a.timee-b.timee)*(-predir)+a.p;
	}
	else {
		a_pos=a.p;
		b_pos=(a.timee-b.timee)*b.dir+b.p;
	}
	return b_pos<a_pos? -1:1;
}
int ans[N];

//这个函数是确认这两辆车在这个过程中是否相遇 
void solve(const truck &t,Ask &q,ll pretime,int predir){
	//is_left：在执行这个行动后两辆车的相对位置 
	int is_left=check(t,trucks[q.id],pretime,predir);
	//如果这两辆车的相对位置发生变化，那么就是相遇 
	ans[q.qid]+=(q.was_left*is_left==-1);
	//同步更新相对位置 
	q.was_left=is_left;
}


int main(){
	vector<event> events;
	read(n);read(m);
	int x,newx;
	//这两个数记录这一次位置和上一次位置，主要目的是为了处理
	//移动方向 
	ll tsum;
	//这一辆卡车处理到这个移动时已经使用的时间 
	event e;
	for(int i=0;i<n;++i){
		tsum=0; 
		read(trucks[i].k);read(x);
		for(int j=0;j<trucks[i].k-1;++j){
			read(newx);
			e=event(i,x,x<newx?1:-1,tsum);
			
			if(!j)init(e);
			//记录每辆车的出发点 
			
			else events.push_back(e);
			tsum+=abs(x-newx);
			x=newx;
		}
		e=event(i,x,0,tsum);
		events.push_back(e); 
	} 
	
	int a,b;
	for(int i=0;i<m;++i){
		read(a);read(b);
		a--;b--;
		if(a>b)swap(a,b);
		int t=hshit(make_pair(a,b));
		//我将下述操作用伪代码解释一下
		//if(这不是(a,b)询问组第一次出现)
		//		将(a,b)询问组出现的次数+1
		//		记录(a,b)询问组出现的id
		//else 
		//	 if(a货车第一次当中心车辆)
		//		 新建一个节点p连到a点上
		//		 记录询问(a,b)的第一次出现
		//   else
		//		 仍然新建一个节点p连到a上
		//		 记录访问(a,b)的出现 
		if(h[t]>1){
			hs[t]->num++;
			hs[t]->idx.push_back(i);
			continue;
		}
		else {
			if(!Adj[a]){
				Adj[a]=new List();
				Adj[a]->num=1;
				Adj[a]->id=b;
				hs[t]=Adj[a];
				hs[t]->idx.push_back(i);
			}
			else{
				List *p=new List();
				p->next=Adj[a]->next;
				p->id=b;
				p->num=1;
				Adj[a]->next=p;
				hs[t]=p;
				hs[t]->idx.push_back(i);
			}
		}
		//记录关于a卡车的询问 
		if(trucks[a].k>trucks[b].k)swap(a,b);
		trucks[a].asks.push_back(Ask(b,trucks[b].p<trucks[a].p?-1:1,i));
	}
	
	//我们对于每一个行动，按照时间发展顺序进行 
	sort(events.begin(),events.end());
	
	for(int i=0;i<events.size();++i){
		e=events[i];
		ll prev_time=trucks[e.id].timee;
		int prev_dir=trucks[e.id].dir;
		init(e);
		//这里就是对于以e.id为中心车辆的询问组一并处理 
		for(int j=0;j<trucks[e.id].asks.size();++j){
			Ask &q=trucks[e.id].asks[j];
			solve(trucks[e.id],q,prev_time,prev_dir);
		}
	}
	int sz;
	//其实我们在上面只处理了每个中心车的第一个询问
	//我们在下面将所有的中心点相同的询问统一答案 
	for(int i=0;i<n;++i){
		for(List *p=Adj[i];p;p=p->next){
			sz=p->idx.size();
			for(int j=1;j<sz;++j){
				ans[p->idx[j]]=ans[p->idx[0]];
			}
		}
	}
	for(int i=0;i<m;++i){
		printf("%d\n",ans[i]);
	}
	return 0;
}
```


---

## 作者：qwer6 (赞：0)

## 1. Description

有 $n$ 辆卡车，现在给出它们路线的起点，终点和拐点，每辆卡车都以 $1$ 单位长度每秒的速度移动。

现在有 $q$ 个询问，询问编号为 $x,y$ 的卡车在其中一辆卡车到达终点前，可以相遇几次。

保证 $x,y$ 不会在起点，终点和拐点处相遇。

## 2. Solution

因为卡车不会在起点，终点和拐点处相遇，所以 $x,y$ 的相遇次数为 $\min(k_x,k_y)$，所以我们考虑枚举 $k$ 更小的那一辆卡车的每一段，然后求出两辆卡车在这一段中是否相遇即可。

判断是否相遇的方法是简单的，相遇后，两辆卡车的相对位置会发生改变，而由于其中一辆卡车的行驶方向不变，所以相对位置只会更改一次，所以我们只需要算出在这一段开始和结束时两辆卡车的相对位置是否改变即可。

那么单次询问的时间复杂度为 $O(\min(k_x,k_y)\times\log \max(k_x,k_y))$，然后考虑一个时间复杂度为 $O(k_x+k_y)$ 的暴力，设定一个值 $B$，令 $k_x,k_y$ 均大于 $B$ 时我们使用 $O(\min(k_x,k_y)\times\log \max(k_x,k_y))$ 的做法，否则暴力，加入记忆化后，简单调整 $B$ 的值可以得到时间复杂度为 $O(n\sqrt n\log n)$，可以通过（时间复杂度中具体是 $n,q$ 还是 $\sum_{i=1}^n k_i$ 都差不多，反正是一个量级的）。

但实际上，只需要全部使用 $O(\min(k_x,k_y)\times\log \max(k_x,k_y))$ 的做法即可通过此题。

## 3. Code

```c++
/*by qwer6*/
/*略去缺省源与快读快写*/
const int N=1e5+5,B=550;
int n,m;
int K[N];
map<pii,int>mp;
struct Line{
	int l,r,s,t;
};
vector<Line>a[N];
int cal(int t,int idx){
	if(t>=a[idx][K[idx]-1].r)return a[idx][K[idx]-1].t;
	int l=0,r=K[idx]-1,res=0;
	while(l<=r){
		int mid=l+r>>1;
		if(a[idx][mid].l>t)r=mid-1;
		else if(a[idx][mid].r<t)l=mid+1;
		else{
			if(a[idx][mid].s<a[idx][mid].t)return a[idx][mid].s+t-a[idx][mid].l;
			return a[idx][mid].s-(t-a[idx][mid].l);
		}
	}
	return -1;
}
int solve(int x,int y){
	int res=0,sx,tx,sy,ty;
	for(Line tmp:a[x]){
		if(tmp.l>=a[y][K[y]-1].r)break;
		if(tmp.r>a[y][K[y]-1].r){
			sy=cal(tmp.l,y),ty=cal(a[y][K[y]-1].r,y);
			sx=tmp.s;
			if(tmp.s<tmp.t)tx=tmp.s+a[y][K[y]-1].r-tmp.l;
			else tx=tmp.s-(a[y][K[y]-1].r-tmp.l);
		}else{
			sy=cal(tmp.l,y),ty=cal(tmp.r,y);
			sx=tmp.s,tx=tmp.t;
		}	
		res+=(sy>sx)^(ty>tx);
	}
	return res;
}
signed main(){
	read(n),read(m);
	for(int i=1;i<=n;i++){
		read(K[i]);
		for(int j=1,pre=0,now,sum=0;j<=K[i];j++){
			read(now);
			if(j>1){
				a[i].push_back({sum,sum+abs(now-pre),pre,now});
				sum+=abs(now-pre);
			}
			pre=now;
		}
		K[i]--;
	}
	for(int i=1,x,y;i<=m;i++){
		read(x),read(y);
		if(K[x]>K[y])swap(x,y);
		if(K[x]==K[y]&&x>y)swap(x,y);
		if(mp.find({x,y})!=mp.end()){
			write(mp[{x,y}]),Nxt;
			continue;
		}
		write(mp[{x,y}]=solve(x,y)),Nxt;
	}
}
```

---


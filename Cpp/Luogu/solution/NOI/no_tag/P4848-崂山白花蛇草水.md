# 崂山白花蛇草水

## 题目描述

神犇 Aleph 在 SDOI Round2 前立了一个 flag：如果进了省队，就现场直播喝崂山白花蛇草水。凭借着神犇 Aleph 的实力，他轻松地进了山东省省队，现在便是他履行诺言的时候了。蒟蒻 Bob 特地为他准备了 999,999,999,999,999,999 瓶崂山白花蛇草水，想要灌神犇 Aleph。神犇 Aleph 求（跪着的）蒟蒻 Bob 不要灌他，由于神犇 Aleph 是神犇，蒟蒻 Bob 最终答应了他的请求，但蒟蒻 Bob 决定将计就计，也让神犇 Aleph 回答一些问题。

具体说来，蒟蒻 Bob 会在一个宽敞的广场上放置一些崂山白花蛇草水（可视为二维平面上的一些整点），然后询问神犇 Aleph 在矩形区域 $x_1\le x\le x_2,y_1\le y\le y_2$ 中，崂山白花蛇草水瓶数第 $k$ 多的是多少。为了避免麻烦，蒟蒻 Bob 不会在同一个位置放置两次或两次以上的崂山白花蛇草水，但蒟蒻 Bob 想为难一下神犇 Aleph，希望他能在每次询问时立刻回
答出答案。

神犇 Aleph 不屑于做这种问题，所以把这个问题交给了你。

## 说明/提示

对于所有数据，$n\le500000$，$q\le100000$，$1\le x, y\le n$，$1\le v\le 10^9$，$1\le x_1\le x_2\le n$，$1\le y_1\le y_2\le n$，$1\le k\le q$。

## 样例 #1

### 输入

```
10 7
1 1 1 1
1 2 2 3
1 4 1 2
1 3 4 4
2 1 1 4 1 3
2 2 2 3 5 4
2 2 1 4 4 2```

### 输出

```
NAIVE!ORZzyz.
NAIVE!ORZzyz.
3```

# 题解

## 作者：xxseven (赞：12)

纪念一下首次独自做出数据结构黑题！

提供一种分块结合线段树的做法，时间复杂度为 $O(q\sqrt{q\log n})$，目前（截至 2025/6/18）在没有刻意卡常的情况下，拿到了本题的最优解。

首先考虑**静态问题**，即所有查询在修改之后的版本怎么做。

把所有点按 $v$ **升序排序**，之后对其进行分块。块内构建可持久化线段树，用于查询一个矩形内有多少个点。

查询时，从最后一块向前扫描整块，累加当前在查询矩形内的点数，直到找到累加后点数不小于 $k$ 的第一个块，在块内暴力找到答案即可。

接着考虑**扩展至动态**。最直观的想法就是**定期重构**，查询时暴力统计新加入的点的贡献，当加入的点达到一个阈值时就暴力重构。

接下来是时间复杂度分析，记分块长度为 $B$，重构阈值为 $lim$，则各部分的时间复杂度如下：

加入新点，共 $O(q)$ 次，单次复杂度 $O(lim)$，用于维护散点序列 $v$ 值的有序性。

重构，共 $O(\frac{q}{lim})$ 次，由以下部分组成：

- 排序所有的点，使用归并排序复杂度为 $O(q)$。
- 构建线段树，复杂度为 $O(q\log n)$。

因此重构的总复杂度为 $O(\frac{q^2\log n}{lim})$。

查询，共 $O(q)$ 次，由以下部分组成：

- 查询整块矩形内点的个数，有 $O(\frac{q}{B})$ 块，总复杂度为 $O(\frac{q \log n}{B})$。
- 暴力处理所有散点和最终答案落在的块，复杂度 $O(lim+B)$。

因此查询的总复杂度为 $O(\frac{q^2\log n}{B}+q(lim+B))$。

最终的总复杂度为 $O(\frac{q^2\log n}{B}+\frac{q^2\log n}{lim}+q(lim+B))$，取 $lim=B=\sqrt{q\log n}$ 即可得到 $O(q\sqrt{q\log n})$。

我的代码实现如下，取了 $lim=B=2500$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+6,B=2500;
int n,q;

struct sgt_node{
    int l,r,val;
}t[N<<5];
int idx,rt[50][B+5];
#define mid (L+R>>1)
void upd(int &pos,int pre,int L,int R,int x){
    pos=++idx; t[pos]=t[pre]; t[pos].val++;
    if(L==R) return;
    if(x<=mid) upd(t[pos].l,t[pre].l,L,mid,x);
    else upd(t[pos].r,t[pre].r,mid+1,R,x);
}
int qry(int pos,int L,int R,int x,int y){
    if(x>R||y<L||!pos) return 0;
    if(x<=L&&R<=y) return t[pos].val;
    return qry(t[pos].l,L,mid,x,y)+qry(t[pos].r,mid+1,R,x,y);
}

int cntB,bl[B+5],br[B+5],mn[B+5];

struct point{
    int x,y,k;
    bool operator < (const point &b)const{
        return x<b.x;
    }
}a[N],b[B+5],S[N]; int m,top;
void rebuild(){
    int p=1,q=1;
    for(int i=1;i<=m+top;++i) {
        if(q>top||(p<=m&&a[p].k<b[q].k)) S[i]=a[p++];
        else S[i]=b[q++];
    } 
    m+=top; top=0;
    for(int i=1;i<=m;++i) a[i]=S[i];

    for(int i=1;i<=idx;++i) t[i].l=t[i].r=t[i].val=0;
    for(int i=1;i<=cntB;++i) for(int j=1;j<=B;++j) rt[i][j]=0; idx=0;
    cntB++; bl[cntB]=br[cntB-1]+1; br[cntB]=m;

    for(int i=1;i<=cntB;++i) {
        for(int j=bl[i];j<=br[i];++j) S[j]=a[j];
        sort(S+bl[i],S+br[i]+1);
        mn[i]=a[bl[i]].k;
        for(int j=bl[i];j<=br[i];++j) upd(rt[i][j-bl[i]+1],rt[i][j-bl[i]],1,n,S[j].y);
    }
}
int qryb(int B,int x,int y,int y2){
    int pos=upper_bound(S+bl[B],S+br[B]+1,(point){x,0,0})-S-bl[B];
    return qry(rt[B][pos],1,n,y,y2);
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>q; int lst=0;
    while(q--) {
        int op,x,y,x2,y2,k;
        cin>>op;
        if(op==1) {
            cin>>x>>y>>k;
            x^=lst; y^=lst; k^=lst;
            b[++top]=(point){x,y,k}; 
            int pos=top;
            while(pos!=1&&b[pos-1].k>b[pos].k) {
                swap(b[pos-1],b[pos]);
                pos--;
            }
            if(top==B) rebuild();
        }
        else {
            cin>>x>>y>>x2>>y2>>k;
            x^=lst; y^=lst; x2^=lst; y2^=lst; k^=lst;

            int pos=top,tot=0;
            for(int i=cntB;i>=0;--i) {
                if(i==0) {
                    assert(tot<k);
                    int ans=-1,q=pos;
                    while(q!=0) {
                        ans=b[q].k;
                        if(x<=b[q].x&&b[q].x<=x2&&y<=b[q].y&&b[q].y<=y2) tot++;
                        q--;
                        if(tot==k) break;
                    }

                    if(tot<k) {
                        cout<<"NAIVE!ORZzyz.\n";
                        lst=0;
                    } 
                    else {
                        lst=ans;
                        cout<<ans<<'\n';
                    }
                    break;
                }
                int now=0,tmp=pos;
                now+=qryb(i,x2,y,y2)-qryb(i,x-1,y,y2);
                while(tmp!=0&&mn[i]<=b[tmp].k) {
                    if(x<=b[tmp].x&&b[tmp].x<=x2&&y<=b[tmp].y&&b[tmp].y<=y2) now++;
                    tmp--;
                }
                if(tot+now>=k) {
                    int p=br[i],q=pos,ans=-1;
                    while(tot<k) {
                        if(q==tmp-1||(p!=bl[i]-1&&a[p].k>b[q].k)) {
                            ans=a[p].k;
                            if(x<=a[p].x&&a[p].x<=x2&&y<=a[p].y&&a[p].y<=y2) tot++;
                            p--;
                        }
                        else {
                            ans=b[q].k;
                            if(x<=b[q].x&&b[q].x<=x2&&y<=b[q].y&&b[q].y<=y2) tot++;
                            q--;
                        }
                    } 
                    lst=ans;
                    cout<<ans<<'\n';
                    break;
                }
                tot+=now; pos=tmp;
            }
        }
    }
    return 0;
}
```

---

## 作者：agicy (赞：6)

点此食用更佳：[$\huge\texttt{My Blog}$](https://www.lu-anlai.com/oi/solution/luogu-p4848/)。

一道毒瘤的 主席树套 $\texttt{k-D Tree}$ 题，或者 暴力分块 的简单题。

题目链接：[Luogu P4848](https://www.luogu.com.cn/problem/P4848)/[LibreOJ 6016](https://loj.ac/problem/6016)。

# 题目

## 题目描述

具体说来，蒟蒻 Bob 会在一个宽敞的广场上放置一些崂山白花蛇草水（可视为二维平面上的一些整点），然后询问神犇 Aleph 在矩形区域 $x_1\leq x\leq x_2,y_1\leq y\leq y_2$ 中，崂山白花蛇草水瓶数第 $k$ 多的是多少。为了避免麻烦，蒟蒻 Bob 不会在同一个位置放置两次或两次以上的崂山白花蛇草水，但蒟蒻 Bob 想为难一下神犇 Aleph，希望他能在每次询问时立刻回答出答案。

神犇 Aleph 不屑于做这种问题，所以把这个问题交给了你。

## 数据范围

|变量|数据范围|
|:-:|:-:|
|坐标范围|$5\times 10^5$|
|操作次数|$10^5$|
|$v$|$10^9$|

## 时空限制

|题目编号|时间限制|空间限制|
|:-:|:-:|:-:|
|[Luogu P4848](https://www.luogu.com.cn/problem/P4848)|$3\text{s}$|$500\text{MiB}$|
|[LibreOJ 6016](https://loj.ac/problem/6016)|$4\text{s}$|$512\text{MiB}$|

# 题解

本题有多种写法。

## 写法一

~~不保证能过的奇怪写法（数据过水）。~~

暴力分块，开两个数组，一大一小，小的大小约为 $\sqrt{q}+1$。

每次加点**往小的数组里面用插入排序的方法加**，按 $v$ 排列，**超过大小后按照归并排序的方法合并两个数组**。

查询时**按照归并的方法查询**。

期望时间复杂度为 $\Theta(q\sqrt{q}+q^2)$。**实际开 O2 优化能过（数据太水了）**。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define getcharead()(p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
static char buf[100000],*p1=buf,*p2=buf;
inline int read(void){
	reg bool f=false;
	reg char ch=getcharead();
	reg int res=0;
	while(ch<'0'||'9'<ch)f|=(ch=='-'),ch=getcharead();
	while('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getcharead();
	return f?-res:res;
}

const int MAXQ=100000+5;

struct Querys{
	int x,y,v;
	inline Querys(reg int x=0,reg int y=0,reg int v=0):x(x),y(y),v(v){
		return;
	}
};

int n,Q;
Querys big[MAXQ],small[MAXQ];

inline bool in(const Querys& Q,reg int x1,reg int x2,reg int y1,reg int y2){
	return x1<=Q.x&&Q.x<=x2&&y1<=Q.y&&Q.y<=y2;
}

int main(void){
	n=read(),Q=read();
	reg int cnt1=0,cnt2=0;
	reg int lastans=0;
	reg int BLOCK=sqrt(n)+1;
	while(Q--){
		static int type;
		type=read();
		if(type==1){
			static int x,y,v;
			x=read(),y=read(),v=read();
			x^=lastans,y^=lastans,v^=lastans;
			reg int ptr=0;
			for(ptr=cnt2;ptr&&small[ptr].v>v;--ptr)
				small[ptr+1]=small[ptr];
			small[ptr+1]=Querys(x,y,v);
			++cnt2;
			if(cnt2>=BLOCK){
				static Querys temp[MAXQ];
				reg int i=cnt1,j=cnt2,k=cnt1+cnt2;
				while(i&&j){
					if(big[i].v>small[j].v)
						temp[k--]=big[i--];
					else
						temp[k--]=small[j--];
				}
				while(i)
					temp[k--]=big[i--];
				while(j)
					temp[k--]=small[j--];
				for(reg int i=1;i<=cnt1+cnt2;++i)
					big[i]=temp[i];
				cnt1=cnt1+cnt2;
				cnt2=0;
			}
		}
		if(type==2){
			static int x1,y1,x2,y2,k;
			x1=read(),y1=read(),x2=read(),y2=read(),k=read();
			x1^=lastans,y1^=lastans,x2^=lastans,y2^=lastans,k^=lastans;
			if(k>cnt1+cnt2){
				puts("NAIVE!ORZzyz.");
				lastans=0;
				continue;
			}
			reg int i=cnt1,j=cnt2;
			while(i&&j&&k){
				if(big[i].v>small[j].v){
					if(in(big[i],x1,x2,y1,y2))
						--k;
					if(k==0){
						printf("%d\n",lastans=big[i].v);
						break;
					}
					--i;
				}
				else{
					if(in(small[j],x1,x2,y1,y2))
						--k;
					if(k==0){
						printf("%d\n",lastans=small[j].v);
						break;
					}
					--j;
				}
			}
			while(i&&k){
				if(in(big[i],x1,x2,y1,y2))
					--k;
				if(k==0){
					printf("%d\n",lastans=big[i].v);
					break;
				}
				--i;
			}
			while(j&&k){
				if(in(small[j],x1,x2,y1,y2))
					--k;
				if(k==0){
					printf("%d\n",lastans=small[j].v);
					break;
				}
				--j;
			}
			if(k){
				puts("NAIVE!ORZzyz.");
				lastans=0;
			}
		}
	}
	return 0;
}
```

## 写法二

### 思路

首先观察到二维平面，考虑使用 $\texttt{k-D Tree}$。

其次观察到第 $k$ 大，考虑 主席树。

于是决定使用 主席树套 $\texttt{k-D Tree}$ 来解决问题。相当于每个结点上开一个 $\texttt{k-D Tree}$。**动态插入 + 替罪羊树式重构**，查询时可以这么做：

1. 确定一个 $t$；
2. **求 $v$ 大于等于 $t$ 且在 查询范围内的点的个数** （用 $\texttt{k-D Tree}$）；
3. **如果个数大于 $k$，增加 $t$，否则减小 $t$。**
4. 最后得到的 $t$ 就是答案。

**二分 $t$ 即可**，最终的时间复杂度是 $\Theta(q\log_2v\log_2q)$，比较优秀。

### 代码

代码比较长，并且这道题目时间比较松（$3\text{s}$比较长），推荐管理员卡到 $1.5\text{s}$，这道题目也可以卡一卡常数。

#### 卡常数

1. 写快读，因为本题数字都是正数（好像没有 $0$），所以**不需要考虑符号**；
2. 不要写快速输出，那个东西慢的很；
3. $\texttt{k-D Tree}$ 里面不要用很多数组，要写成结构体的形式，不然很慢；
4. `x=max(x,y)` 全部改成 `cMax(x,y)` 这样的形式，其中有宏定义`#define cMax(x,y) ( (x) < (y) ? (x) = (y) : (0) )`；
5. ~~开 O2 优化。~~

下面就是代码了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define INF 1e9
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
static char buf[100000],*p1=buf,*p2=buf;
inline int read(void){
	reg char ch=getchar();
	reg int res=0;
	while(ch<'0'||'9'<ch)ch=getchar();
	while('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getchar();
	return res;
}

const int MAXN=100000+5;
const double alpha=0.75;

const int MAXSIZE=MAXN*20;

int n,K;
int X[2];
int _Max[2],_Min[2];

namespace SegmentTree{
	#define mid ( ( (l) + (r) ) >> 1 )
	int lastans;
	namespace kD_Tree{
		#define cMax(x,y) ( (x) < (y) ? (x) = (y) : (0) )
		#define cMin(x,y) ( (x) > (y) ? (x) = (y) : (0) )
		int cnt;
		#define val(x,y) T[x].val[y]
		#define Max(x,y) T[x].Max[y]
		#define Min(x,y) T[x].Min[y]
		#define lson(x) T[x].lson
		#define rson(x) T[x].rson
		#define size(x) T[x].size
		struct Node{
			int size;
			int lson,rson;
			int Max[2],Min[2];
			int val[2];
		}T[MAXSIZE];
		int WD,p[MAXN];
		inline bool cmp(reg int a,reg int b){
			return val(a,WD)<val(b,WD);
		}
		inline void pushup(reg int k){
			reg int l=lson(k),r=rson(k);
			if(l)
				cMax(Max(k,0),Max(l,0)),cMax(Max(k,1),Max(l,1)),cMin(Min(k,0),Min(l,0)),cMin(Min(k,1),Min(l,1));
			if(r)
				cMax(Max(k,0),Max(r,0)),cMax(Max(k,1),Max(r,1)),cMin(Min(k,0),Min(r,0)),cMin(Min(k,1),Min(r,1));
			size(k)=size(l)+size(r)+1;
			return;
		}
		inline void flat(reg int k){
			if(lson(k)) 
				flat(lson(k));
			p[++cnt]=k;
			if(rson(k))
				flat(rson(k));
			return;
		}
		int buf[MAXN];
		inline int Build(reg int l,reg int r,reg int wd){
			if(l>r)
				return 0;
			WD=wd;
			std::nth_element(p+l,p+mid,p+r+1,cmp);
			reg int k=p[mid];
			Max(k,0)=Min(k,0)=val(k,0),Max(k,1)=Min(k,1)=val(k,1);
			lson(k)=Build(l,mid-1,wd^1),rson(k)=Build(mid+1,r,wd^1);
			pushup(k);
			return k;
		}
		inline void Insert(reg int& root,reg int c){
			if(!root){
				root=c;
				return;
			}
			reg int top=0;
			for(reg int wd=0,x=root;;wd^=1){
				buf[++top]=x;
				cMax(Max(x,0),Max(c,0)),cMax(Max(x,1),Max(c,1)),cMin(Min(x,0),Min(c,0)),cMin(Min(x,1),Min(c,1));
				++size(x);
				if(val(c,wd)<val(x,wd))
					if(!lson(x)){
						lson(x)=c;
						break;
					}
					else
						x=lson(x);
				else
					if(!rson(x)){
						rson(x)=c;
						break;
					}
					else
						x=rson(x);
			}
			buf[++top]=c;
			while(size(lson(c))<alpha*size(c)&&size(rson(c))<alpha*size(c))
				c=buf[--top];
			if(!c)
				return;
			if(c==root){
				cnt=0;
				flat(root);
				root=Build(1,cnt,0);
				cnt=0;
				return;
			}
			reg int fa=buf[--top],crt;
			flat(c);
			crt=Build(1,cnt,top&1);
			cnt=0;
			if(lson(fa)==c)
				lson(fa)=crt;
			else
				rson(fa)=crt;
		}
		inline void Query(reg int x){
			if(!x||Max(x,0)<_Min[0]||Max(x,1)<_Min[1]||Min(x,0)>_Max[0]||Min(x,1)>_Max[1]||lastans>=K)
				return;
			if(_Min[0]<=Min(x,0)&&Max(x,0)<=_Max[0]&&_Min[1]<=Min(x,1)&&Max(x,1)<=_Max[1]){
				lastans+=size(x);
				return;
			}
			if(_Min[0]<=val(x,0)&&val(x,0)<=_Max[0]&&_Min[1]<=val(x,1)&&val(x,1)<=_Max[1])
				++lastans;
			Query(lson(x));
			Query(rson(x));
			return;
		}
		#undef lson
		#undef rson
	}
	using kD_Tree::T;
	int ct,tot=1;
	int root[MAXSIZE],lson[MAXSIZE],rson[MAXSIZE];
	inline void Update(void){
		reg bool flag=true;
		reg int ID=1;
		reg int l=1,r=INF;
		while(true){
			if(flag){
				++ct;
				Max(ct,0)=Min(ct,0)=val(ct,0)=X[0],Max(ct,1)=Min(ct,1)=val(ct,1)=X[1];
				size(ct)=1;
				kD_Tree::Insert(root[ID],ct);
			}
			if(l==r)
				return;
			if(K<=mid){
				if(!lson[ID])
					lson[ID]=++tot;
				ID=lson[ID],r=mid;
				flag=false;
			}
			else{
				if(!rson[ID])
					rson[ID]=++tot;
				ID=rson[ID],l=mid+1;
				flag=true;
			}
		}
		return;
	}
	inline void Query(void){
		lastans=0;
		kD_Tree::Query(root[1]);
		if(lastans<K){
			puts("NAIVE!ORZzyz.");
			lastans=0;
			return;
		}
		reg int ID=1,l=1,r=INF;
		while(l<r){
			lastans=0;
			kD_Tree::Query(root[rson[ID]]);
			if(K<=lastans)
				ID=rson[ID],l=mid+1;
			else
				K-=lastans,ID=lson[ID],r=mid;
		}
		printf("%d\n",lastans=l);
		return;
	}
}

using SegmentTree::lastans;

int main(void){
	reg int cnt=0;
	read(),n=read();
	reg int type,x1,y1,x2,y2;
	for(reg int i=1;i<=n;++i)
		switch(type=read()){
			case 1:{
				x1=read()^lastans,y1=read()^lastans,K=read()^lastans;
				X[0]=x1,X[1]=y1;
				SegmentTree::Update();
				++cnt;
				break;
			}
			case 2:{
				x1=read()^lastans,y1=read()^lastans,x2=read()^lastans,y2=read()^lastans,K=read()^lastans;
				_Min[0]=x1,_Min[1]=y1,_Max[0]=x2,_Max[1]=y2;
				SegmentTree::Query();
				break;
			}
			default:break;
		}
	return 0;
}
```


---

## 作者：Nangu (赞：3)

这道题经过一次数据加强，朴素的动态开点线段树套 KDT 已经无法通过了。本篇文章来教大家如何卡常，建议配合 @agicy 的题解一起食用。

1. 考虑减小 KDT 的常数。
> 这里有两种方法。
> 1. 二进制分组。考虑维护若干棵大小为 $2$ 的次幂的 KDT。插入的时候，我们不断把大小相等的树合并，查询时在所有树上一起查询即可，容易证明复杂度与原来相同。
> 2. 减少重构 KDT 的次数。我们发现在添加一个节点的时候会预期重构一条链上的若干个节点及他们的子树，实际上我们只需要重构最上面的那个节点就可以了，因为把这个点重构后，他的整个子树都已经处于最平衡的状态了；实现时用个栈记录一下从上到下我们遍历到的节点，依次检查即可。
> 3. ~~其实还有一种卡常方法，就是维护一大一小两个 KDT，不过笔者实现的时候发现这样写反而更慢了，所以读者仅当了解就好。~~

2. 减少线段树上插入节点的常数：考虑用线段树二分求答案的过程中，只有每个节点的右儿子会被访问到，因此我们在插入节点时只维护右儿子的 KDT 即可。
3. 线段树二分，在 KDT 上查询该节点内矩形内的点时，注意到我们只关心答案是否大于等于 $k$。因此，我们用全局变量记录当前求得的答案，一但超过了$k$ 就返回。
4. 一些细枝末节的优化：将所有递归函数改为非递归的版本；把一个节点所有数据塞到结构体当中，等等，实测这样也能快不少。

---


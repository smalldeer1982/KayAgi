# [HAOI2009] 求回文串

## 题目描述

所谓回文串，就是对于给定的字符串，正着读和反着读都一样，比如 ABCBA 就是一个回文串，ABCAB 则不是。我们的目标是对于任意输入的字符串，不断将第 $i$ 个字符和第 $i+1$ 个字符交换，使得该串最终变为回文串。求最少交换次数。

## 说明/提示

### 样例说明

1. 交换 $\tt L$ 和 $\tt Z$ 变成 $\tt SHLZLSHZS$；
2. 交换 $\tt L$ 和 $\tt Z$ 变成 $\tt SHZLLSHZS$；
3. 交换 $\tt L$ 和 $\tt S$ 变成 $\tt SHZLSLHZS$；
4. 交换 $\tt H$ 和 $\tt Z$ 变成 $\tt SHZLSLZHS$。

### 数据范围

- $40\%$ 的数据，长度 $\leq50000$；
- $100\%$ 的数据，长度 $\leq10^6$。

## 样例 #1

### 输入

```
SHLLZSHZS```

### 输出

```
4```

# 题解

## 作者：一念之间、、 (赞：16)

（我都没有发现交换次数是逆序对！/jk）

这里提供一个不一样的做法，

首先判断-1就直接看有没有超过两个出现次数为奇数的字符

发现数据范围过大，应该是**贪心**之类的算法，

一个 `naive` 考虑从最外面向里面一层一层的求交换次数，每次枚举最左边和最右边填什么字符，选择代价最小的一个填上去，求出总的答案即可。

填一个字符的代价就是找到最靠左的把它放到最左边，找到一个最靠右的，把它放到最右边的交换次数和。

发现这个自己手玩以下 `hack` 不掉，（后面我们慢慢讨论贪心证明的问题）

考虑实现，同一个字符交换后相对顺序不会发生改变，用一个 `deque` 存下来，每次一定是使用这个字符最左边和最右边的两个字符， `pop_back` 和 `pop_front` 即可

若我们删除了两个字符，相当于在原串挖两个空，考虑用树状数组动态维护当前位置实际位置在哪里。

举个例子

![](https://cdn.luogu.com.cn/upload/image_hosting/0pvfdoj0.png)

时间复杂度是$O(n*26*\log n)$

考虑证明上面的贪心，我们发现如果我们证明当前选择对后面没有影响即可

假设当前选择的是 `AA`，下一次选择的是 `BB`

我们分为3种情况：

1.若呈包含关系，比如 `ABBA` （这时明显 `A` 优于 `B` ），我们贪心的选择是更优的

2.若呈相交关系，比如 `ABAB` （ `BABA` 同理），这时若先选 `A` ，则对选 `B` 的影响是 -1，先选 `B` 对 `A` 的影响也是 -1 ,所以我们贪心选不会影响后面选择。


![](https://cdn.luogu.com.cn/upload/image_hosting/2al13ock.png)


![](https://cdn.luogu.com.cn/upload/image_hosting/e7ufeyiw.png)


3.若呈不相交关系，比如 `AABB` （ `BBAA` 同理）若先选 `A` ，则对 `B` 的影响是 -2 ，先选 `B` 对 `A` 的影响是 -2 ，贪心不影响后面选择。


![](https://cdn.luogu.com.cn/upload/image_hosting/hdnnfeq7.png)


![](https://cdn.luogu.com.cn/upload/image_hosting/1juhf4ge.png)

贪心会使答案更优，且不影响选择，所以贪心正确。

代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
const int xx=1e6+5;
char s[xx];
deque<int>t[26];
int lb(int x){return x&(-x);}
int sum[xx],n;
void add(int x,int y)
{
	for(;x<=n;x+=lb(x))sum[x]+=y;
}
int ask(int x)
{
	int ans=0;
	for(;x;x-=lb(x))ans+=sum[x];
	return ans;
}
signed main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;i++)t[s[i]-'A'].push_back(i);
	int tot=0;
	for(int i=0;i<26;i++)if(t[i].size()&1)tot++;
	if(tot>1)return puts("-1"),0;
	ll ans=0;
	for(int i=1;i<=n/2;i++)
	{
		int res=2147483647;
		int now=0;
		for(int j=0;j<26;j++)
		{
			if(t[j].size()<2)continue;
			int l=t[j][0]-ask(t[j][0])-1;//求距离前面还有多远 
			int r=(n-(i-1)*2)-(t[j][t[j].size()-1]-ask(t[j][t[j].size()-1]));//求距离后面还有多远 
			if(l+r<res)res=l+r,now=j;
		}
		ans+=res;
		add(t[now][0],1);//在树状数组里面挖空 
		add(t[now][t[now].size()-1],1);
		t[now].pop_front();
		t[now].pop_back();
	}
	cout<<ans<<"\n";
	return 0;
}
```


---

## 作者：laduiw (赞：9)

来一发不知道说的对不对的贪心题解，可能写了难度就变蓝题了
# 具体贪心方法
	每个左边字母找它最右边的一个相同字母(未用过），
    把它放到对应位置上去，也就是左边不动让右边匹配左边。
## 贪心的正确性（只是自己的一点想法，不知道对不对）
	简单说就是其他字母相对位置不变
	具体说当情况为
    p(1),p(2),X····X1····X2···p(n-1),p(n)
    我们处理到X，后面有x1,x2都是相同字母，p是已经排好的
    如果我们不用贪心方法把x2移到p(n-3)，而选择动x1,不停交换到p(n-3)
    我们一定会遇到
    p(1),p(2),X·······X1 X2···p(n-1),p(n)
    这时我们再交换x1,x2时发现他们是一样的，（像独木桥那题），所以
    我们把x1移到p(n-3)相当于把x2移到p(n-3)，再把x1移到x2位置上，而这一步显然是多余无意义的。
# 这样代码处理上就很好写了
	可以用vector记录每种字母出现位置，将答案存在ans数组中（存下标）
    记录pl,pr表示ans数组左边和右边填到哪了，pl>pr就跳出，注意一下中间那个数要特判（如果长度是奇数）
    这样我们对ans数组求逆序对就能得到次数了。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
char s[maxn];
int a[maxn],ans[maxn],v[maxn],b[maxn];
long long sum=0;
vector<int> ed[30];
void solve(int l,int r) //求逆序对，不多说
{
	if (l==r) return ;
	int mid=(l+r)>>1;
	solve(l,mid);solve(mid+1,r);
	int j=mid+1,i=l;
	for (int k=l;k<=r;k++)
	{
		if (j>r || i<=mid && ans[i]<ans[j]) b[k]=ans[i++];
			else {
				sum+=(long long)mid-i+1;
				b[k]=ans[j++];
			}
	}
	for (int k=l;k<=r;k++) ans[k]=b[k];
}

int main()
{
	scanf("%s",s+1);
	int ll=strlen(s+1);
	for (int i=1;i<=ll;i++)
	{
		v[i]=1;//v[i]=1表示这位还没有被匹配
		a[i]=s[i]-'A'+1;
		ed[a[i]].push_back(i);
	}
	int sumj=0;//统计奇数个数
	for (int i=1;i<=26;i++)
		sumj+=(ed[i].size()%2==1)?1:0;
	if (ll%2==0 && sumj>0 || ll%2==1 && sumj!=1) {
		printf("-1\n");return 0;
	}
	if (ll%2==1 && sumj==1) {//特判奇数情况
		int p=0;
		for (int i=1;i<=26;i++) if (ed[i].size()%2==1) {
			p=ed[i][ed[i].size()/2];break;
		}
		ans[ll/2+1]=p;v[p]=0;
        //根据贪心理论，中间的数一定是出现次数为奇数的字母，并且排在整个序列中间的是这种字母中中间的那个树
	}
	int i=1,pl=1,pr=ll;
	while (i<=ll)
	{
		if (v[i]==0) {i++;continue;}//这位已经排过了，就跳过去
		if (i>ll) break;
		ans[pl]=i;v[i]=0;pl++;
		ans[pr]=ed[a[i]][ed[a[i]].size()-1];v[ans[pr]]=0;ed[a[i]].erase(ed[a[i]].end()-1);pr--;
		if (pl>pr) break;
		i++;
	}
	solve(1,ll);
	printf("%lld\n",sum);
    //代码写得很丑，大家仅当参考
	return 0;
}

```

---

## 作者：Schi2oid (赞：5)

# P5041 [HAOI2009]求回文串 题解

多看多学多练。贪心好题。现有题解思路上叙述比较简单，现对此题贪心正确性做系统证明。

## 题意简述

给定一个字符串 $S$，求出将其变为回文串所需要的最小邻位交换次数。

 $\vert S\vert\leq 10^6$。

## 思路分析

~~没思路~~

题面看起来很人畜无害，但是考虑复杂度要求过于严苛，大概率是一道贪心题。

咋贪呢？

首先，我们可以感知到我们可以以从外向内的顺序完成每一个目标字符的归位，即将其移动到最优解时它应当处在的位置。另外，我们也可以感知到我们只需要保证令每一位成为回文串是最优解，就可以保证全局是最优解。因此，贪心策略如下：

- 从外向内逐位完成回文串匹配。
- 对于每一位的匹配过程，我们有两种方案：
  - 固定区间左端，让最靠右的相同字符匹配区间右端。
  - 挑选一个字符，使其未匹配的且处于最左和最右的两个字符移动到当前需要匹配的位置，挑选所有字符的移动值取最小值，即可保证答案最优。

## 贪心正确性证明

这个贪心一眼看漏洞百出。为什么这样的方案能保证局部最优？为什么不会产生后效性？为什么从外至内匹配是合理的？让我们逐步完成这一结论的证明。

### 引理1

从外至内匹配是合理的。

#### 证明

~~证明想一年~~

考虑对于初始状态。设在最优解当中我们将 $AA$ 移动至左右端点。无论如何，它们一定会在最终到达左右端点，且不会有其他字符从次端点移动至端点。因此，不考虑 $AA$ 在字符串中的移动，剩余部分的匹配不涉及 $AA$以及左右端点，是一个完整的子问题。将 $AA$ 想象成”幽灵结点“，其他结点跨过幽灵结点不会发生移动，而会消耗 $1$ 的代价。而幽灵节点一定要到达两端，定义左边的 $A$ 到左端点距离与右边的 $A$ 到右端点距离为 $x$，即其至少会消耗代价 $x$ ，而如果不优先移动 $AA$ ，则幽灵节点可能会发生与目标方向相反的移动，则意味着幽灵节点造成的额外贡献会增加，造成的代价一定要大于等于 $x$ 。证毕。

### 引理2

贪心策略确实是局部最优解，且不会产生后效性。

#### 证明

基于**引理1**，我们考虑假设当前应该从外向内数匹配第 $l$ 位。考虑从外向内匹配的过程其实是删去一个一个的字符对的过程。考虑对于字符对 $AA$ 和 $BB$ ，它们分别应匹配至 $l$ 和 $l+1$ ；那么它们的匹配顺序不影响剩下的字符串，即不会产生后效性。它们的位置关系有以下几种情况：

对于下图第一种情况，显然应该先匹配 $AA$；此时 $A1,A2$ 到两端的距离和显然小于 $B1,B2$。

对于下图第二种情况，先匹配 $AA$ 或 $BB$ 都会使另一对的匹配减少两步，所以都一样。

对于下图第三种情况，先匹配 $AA$ 或 $BB$ 都会使另一对的匹配减少一步，所以都一样。

![](https://cdn.luogu.com.cn/upload/image_hosting/764stsih.png)

注意到有区别的情况仅限图一。目前的两种主流贪心方案为：

- 固定区间左端，让最靠右的相同字符匹配区间右端；

- 求出到两端距离最小的字符。

注意到它们都能识别出图一的情况并进行正确的操作，因此，我们可以论证两种主流贪心方案都能够保证答案的正确性。

## 实现

实现上来说就相对比较简单了。我们按照第一种贪心方案，使用双端队列将每一个字符的位置存储起来，可以方便求出每一个字符最右端，这样就可以用 $O(n)$ 的复杂度完成原字符串的排序，接下来通过树状数组用 $O(n\log n)$ 的复杂度求一遍逆序对即可。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
int rnk[1000005]={0},cnt[1000005]={0},s[1000005]={0},t[1000005]={0};
bool vis[1000005]={0};
char S[1000005];
deque<int>q[30];
int n;
int lowbit(int x) {return x&-x;}
void add(int x,int k){
	while(x<=n){
		t[x]+=k;
		x+=lowbit(x);
	}
}
int sum(int x){
	int ret=0;
	while(x>=1){
		ret+=t[x];
		x-=lowbit(x);
	}
	return ret;
}
signed main(){
	scanf("%s",S+1);
	n=strlen(S+1);
	int cntj=0;
	for(int i=1;i<=n;i++){
		s[i]=S[i]-'A'+1;
		q[s[i]].push_back(i);
		cnt[s[i]]++;
		if(cnt[s[i]]%2==0) cntj--;
		else cntj++;
	}
	if(cntj>=2){
		cout<<"-1";
		return 0; 
	}
	int tot=0,ii=0;
	while(tot<n/2){
		ii++;
		if(vis[ii]) continue;
		if(q[s[ii]].size()==1) continue; 
		vis[ii]=1;
		vis[q[s[ii]].back()]=1;
		rnk[ii]=++tot;
		rnk[q[s[ii]].back()]=n-tot+1;
		q[s[ii]].pop_front();
		q[s[ii]].pop_back();
		
	}
	for(int i=1;i<=26;i++){
		if(!q[i].empty()){
			rnk[q[i].front()]=++tot;
			break;
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		add(rnk[i],1);
		ans+=i-sum(rnk[i]);
	}
	cout<<ans;
	return 0;
} 
```



---

## 作者：clamee (赞：4)

---
title: '【题解】[HA2009]求回文串'
date: 2020-10-08 11:51:33
tags:
  - 字符串
  - 树状数组
  - 排序
  - 贪心


---

题目大意：

> 给你一个长度为 $n$ 的字符串，每次可以交换相邻的两个字符，求最小的交换次数使得将字符串变成回文串($n\le 10^6$)。

可以考虑终止状态和起始状态的联系，可以构建序列 b 表示依次给每个字符找到原序列中的对应字符的出现位置，答案即为 b 数组的逆序对数。

例如：

```abbca```

```abcba```

构建出来的序列为 ```1 2 4 3 5```，所以答案为 $1$。

那么我们就将问题转化为求出一个序列使得它对应上去了以后逆序对数最小。

考虑任意两种字符之间的贡献不难发现，我们可以钦定所有字符的左边不动，只改变右边。于是我们可以构造出一个新的序列。然后求一波逆序对即可。

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define rg register
#define int long long
char s[1000005];
il int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}
il void write(int x)
{
	if(x<0)return putchar('-'),write(-x),void();
	if(x<10)return putchar(x+48),void();
	return write(x/10),putchar(x%10+48),void();
}
int n,t[26],p[1000005],r[26],b[1000005];
int tree[1000005],cnt;
bool vis[1000005];
void add(int x)
{
	while(x<=n)
	{
		tree[x]++;
		x+=x&-x;
	}
}
int sum(int x)
{
	int re=0;
	while(x)
	{
		re+=tree[x];
		x-=x&-x;
	}
	return re;
}
int abs2(int x)
{
	return x>0?x:-x;
}
signed main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	for(rg int i=1;i<=n;i++)
	{
		int now=s[i]-'A';
		t[now]++;
		p[i]=r[now];
		r[now]=i;
	}
	for(rg int i=0;i<26;i++)
	{
		if(t[i]&1)
		{
			if(cnt)
			{
				puts("-1");return 0;
			}
			cnt=i;
		}
	}
	if(cnt)
	{
		int now=r[cnt],las=0;
		for(int i=1;i<=t[cnt]/2;i++)
		{
			now=p[now];
		}
		if(las)
			p[las]=p[now];
		b[n/2+1]=now;
		vis[now]=1;
	}
	int ans=0,ss=0;
	for(rg int i=1;i<=n/2+ss;i++)
	{
		if(vis[i]){ss++;continue;}
		int now=s[i]-'A';
		vis[i]=vis[r[now]]=1;
		b[i-ss]=i;b[n-i+ss+1]=r[now];
		r[now]=p[r[now]];
	}
	for(int i=n;i>=1;i--)
	{
		ans+=sum(b[i]);
		add(b[i]);
	}
	write(ans);
}
```



---

## 作者：Lyrella (赞：3)

# 题意
~~**桶俗宜胨**~~，就是求交换的最小次数。
# 思路
看到 $n\leq10^6$ 果断**贪心**。

问：那么如何**贪心**呢？？

即答：当然是**从外往里**或者**从里往外**每次找**最优字符**。**最优字符**即为一个字符最左的到左端点与其最右的到右端点的步数和最小。这样局部最优等于全局最优。

又问：那如何**证明**贪心的正确性呢？

**直接安排！！！这里我是从外往里贪心。**
# 证明
我们不妨设当前最优字符所在位置为 $l$ 和 $r$，下一层最优字符所在位置为 $l'$ 和 $r'$。（只考虑最优解唯一的情况）

**前置芝士**：如果将当前字符串平分为两半，当前最优字符分别在**其中一半**。

然后我们就分六类情况讨论。

为什么有六类呢？因为确定 $l,r$，字符串就被分成了三段，我们枚举 $l'$ 和 $r'$，就有 $A_3^2=6$ 段。
## Situation 1---$l',r'$ 在 $l$ 的左侧
与 $l',r'$ 是下一层最优字符相矛盾，pass。
## Situation 2---$l',r'$ 在 $l,r$ 之间
$l$ 和 $r$ 不对 $l',r'$ 造成影响，pass。
## Situation 3---$l',r'$ 在 $r$ 的右侧
与 $l',r'$ 是下一层最优字符相矛盾，pass。
## Situation 4---$l'$ 在 $l$ 的左侧，$r'$ 在 $l,r$ 之间
$l'$ 受 $l$ 影响，最优值加一还是最优，pass。
## Situation 5---$l'$ 在 $l,r$ 之间，$r'$ 在 $r$ 的右侧
$r'$ 受 $r$ 影响，最优值加一还是最优，pass。
## Situation 6---$l'$ 在 $l$ 的左侧，$r'$ 在 $r$ 的右侧
~~好家伙直接**反客为主**~~，此时 $l'$ 和 $r'$ 成为了最优字符，pass。

所以最优解唯一的情况是没问题的，当然你也许会问**质疑**：多解的情况会不会就矛盾了呢？其实**更加好想**！如果多组解都加了一，那大家**都**还是最优解。如果有最优解不受影响，那么最优解就变成了**不受影响的最优解**（相当于最优解**不变**）。

证明之后就简单多了，字符串的位置可以用**双端队列**来维护，字符串之间的距离可以用**数据结构**来维护。（~~**别用线段树！！别问我怎么知道的！！**~~）

时间复杂度是 $O(n\times 26\times \log n)$。

**不开 $\text{long long}$ 见祖宗！！！**
# 代码1（线段树）
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6 + 5;
int n, cnt;
char s[N];
ll ans;
deque < int > d[30];
struct tree{int x, tag;}tr[N << 2];
void upd(int x){tr[x].x = tr[x << 1].x + tr[x << 1 | 1].x;}
void build(int x, int l, int r)
{
	if(l == r)
	{
		tr[x].x = 1;
		return;
	}
	int mid = l + r >> 1;
	build(x << 1, l, mid);
	build(x << 1 | 1, mid + 1, r);
	upd(x);
}
void pd(int x, int l, int r)
{
	int mid = l + r >> 1;
	tr[x << 1].tag += tr[x].tag;
	tr[x << 1 | 1].tag += tr[x].tag;
	tr[x << 1].x += tr[x].tag * (mid - l + 1);
	tr[x << 1 | 1].x += tr[x].tag * (r - mid);
	tr[x].tag = 0;
}
void modify(int x, int l, int r, int id)
{
	if(l == r)
	{
		tr[x].tag -= tr[x].x; tr[x].x = 0;
		return;
	}
	int mid = l + r >> 1;
	pd(x, l, r);
	if(id <= mid)modify(x << 1, l, mid, id);
	else modify(x << 1 | 1, mid + 1, r, id);
	upd(x);
}
ll query(int x, int l, int r, int L, int R)
{
	if(L <= l and r <= R)return tr[x].x;
	int mid = l + r >> 1; int ret = 0;
	pd(x, l, r);
	if(L <= mid)ret += query(x << 1, l, mid, L, R);
	if(R > mid)ret += query(x << 1 | 1, mid + 1, r, L, R);
	return ret;
}
signed main()
{
	scanf("%s", s + 1); n = strlen(s + 1);
	for(int i = 1; i <= n; i++)d[s[i] - 'A'].push_back(i);
	for(int i = 0; i < 26; i++)if(d[i].size() & 1)cnt++;
	if(cnt > 1){cout << - 1; return 0;}
	build(1, 1, n);
	for(int i = 1; i <= n / 2; i++)
	{
		ll mi = 2147483648; int now = 0;
		for(int k = 0; k < 26; k++)
		{
			if(d[k].size() < 2)continue;
			ll l = query(1, 1, n, 1, d[k][0]) - 1ll;
			ll r = query(1, 1, n, d[k][d[k].size() - 1], n) - 1ll;
			if(l + r < mi)mi = l + r, now = k;
		}
		ans += mi;
		modify(1, 1, n, d[now][0]); modify(1, 1, n, d[now][d[now].size() - 1]);
		d[now].pop_front(); d[now].pop_back();
	}
	cout << ans; return 0;
}
```
# 代码2（树状数组）
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6 + 5;
int n, cnt;
char s[N];
ll ans, tr[N];
deque < int > d[30];
int lowbit(int x){return x & - x;}
void add(int x, int y){for(; x <= n; x += lowbit(x))tr[x] += y;}
ll sum(int x){ll ans = 0; for(; x; x -= lowbit(x))ans += tr[x]; return ans;}
signed main()
{
	scanf("%s", s + 1); n = strlen(s + 1);
	for(int i = 1; i <= n; i++)d[s[i] - 'A'].push_back(i);
	for(int i = 0; i < 26; i++)if(d[i].size() & 1)cnt++;
	if(cnt > 1){cout << - 1; return 0;}
	for(int i = 1; i <= n; i++)add(i, 1);
	for(int i = 1; i <= n / 2; i++)
	{
		ll mi = 2147483648; int now = 0;
		for(int k = 0; k < 26; k++)
		{
			if(d[k].size() < 2)continue;
			ll l = sum(d[k][0] - 1) - sum(0);
			ll r = sum(n) - sum(d[k][d[k].size() - 1]);
			if(l + r < mi)mi = l + r, now = k;
		}
		ans += mi;
		add(d[now][0], - 1); add(d[now][d[now].size() - 1], - 1);
		d[now].pop_front(); d[now].pop_back();
	}
	cout << ans; return 0;
}
```
**最后的最后**，注意树状数组求距离时，起点是**闭区间**，终点才是**开区间**欧。

**祝大家 $NOI$ $Au$**！！！

---

## 作者：王熙文 (赞：2)

本题解参考了[这篇题解](https://www.luogu.com.cn/blog/Schi2oid/solution-p5041)，补充了一些证明的细节。

## 思路

注：为了表达方便，下文“优于”的意思有可能是“不劣于”。

考虑以下贪心：每次选择最左的、未操作、出现次数大于等于两次的字符，找到与这个字符相同的最右的、未操作的字符，并将这两个分别移动到回文串未匹配的最左和最右。

接下来是贪心的证明。

结论 1：每一次将一对相同的字符移动到回文串未匹配的最左和最右一定最优。

证明：设最终在回文串最左和最右的两个字符是 `cc`，我们要证明先将 `cc` 移动到两侧一定优于其他情况。考虑在其他情况中，我们的目标是解决剩下字符组成的子问题并将 `cc` 移到两侧。考虑一次交换，如果其中一个是 `cc`，那么在子问题中不会产生贡献，会对移动 `cc` 产生最多 $1$ 的贡献（有可能朝反方向移动，此时贡献为 $-1$）。否则会对子问题产生最多 $1$ 的贡献，对移动 `cc` 不产生贡献。所以可以发现其他情况中至少需要子问题的答案加上直接移动 `cc` 的答案。因此先移动更优。

根据这个结论可以发现：每次移动相同字符相当于删除这两个字符，对答案的贡献为这两个字符到左、右的距离。

结论 2：对于一种字符，如果想移动其中一对，则移动最左、最右的最优。

证明：只需要证明若有 $s_x=s_l=s_r, l<r$，则移动 $(x,r)$ 比移动 $(x,l)$ 优，其他情况类似。考虑移动 $(x,l)$ 后 $l$ 后面的字符都前进了一位。发现移动 $(x,r)$ 后将 $l$ 交换到 $r-1$ 也可以达到这个效果，且少一次，所以这样移动更优。比如 `ababab`，其中 $x=1,l=3,r=5$。移动 $(x,l)$ 后变成 `abbaba`；移动 $(x,r)$ 后变成 `ababba`，再将 $l$ 移动到 $r-1$ 变成 `abbaba`，这两个相同。

根据这个结论可以发现：移动的对是固定的，区别仅仅在于移动的顺序。

结论 3：对于两次相邻的移动 $(a,b),(c,d)$，若 $a<c$，则 $(a,b)$ 在前更优。

证明：分类讨论这两个区间不交、相交、包含这三种情况即可证明。具体的证明可以看最初提到的那篇题解。

接下来可以调整法证明贪心策略了。如果操作中有一次移动没选最左的移动，则以后的操作中一定存在两次相邻的移动满足前者左端点大于后者左端点，此时交换这两次移动一定更优。所以每一次选择左端点最小的移动一定是最优的。

接下来只需模拟贪心过程即可。每次枚举左端点，并找到右端点，计算右端点移动到对应位置的次数。现在需要确定右端点实际的位置。如果之前操作的右端点小于当前操作的右端点，则会使当前右端点往前一位。使用树状数组维护即可。

需要特判当前点不存在右端点的时候（即当前点为最中间的点）。如果存在这个点，则以后操作的左端点也需要移动一次。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; string s;
bool vis[1000010];
vector<int> e[26];
int tree[1000010];
void upd(int wz,int x)
{
	for(; wz<=1e6+5; wz+=wz&-wz) tree[wz]+=x;
}
int get_sum(int wz)
{
	int sum=0;
	for(; wz>0; wz-=wz&-wz) sum+=tree[wz];
	return sum;
}
int main()
{
	cin>>s; n=s.size(); s=' '+s;
	for(int i=1; i<=n; ++i) e[s[i]-'A'].push_back(i);
	int cnt=0;
	for(int i=0; i<=25; ++i) cnt+=(e[i].size()%2==1);
	if(cnt>1) return cout<<-1,0;
	long long ans=0;
	int now=0;
	bool fir=0;
	for(int i=1; i<=n/2; ++i)
	{
		++now;
		while(vis[now] || now==e[s[now]-'A'].back()) fir|=(now==e[s[now]-'A'].back()),++now;
		ans+=fir+n-i+1-(e[s[now]-'A'].back()-get_sum(e[s[now]-'A'].back()-1));
		vis[e[s[now]-'A'].back()]=1,upd(e[s[now]-'A'].back(),1),e[s[now]-'A'].pop_back();
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：小塘空明 (赞：2)

n=1e6，不是单调栈（跟末尾有关），那么八成贪心咯。

考虑当前左边填到第i位，字符为c，那么很显然要让同样字符为c且处于最右边的来填。

这时候他们两的移动步数已经是固定了的，那么我们考虑让这两个位置进行移动，且对后面的影响最小。

我们可以发现，将这两个位置填好后，剩下的没填的字符串之间的相对顺序不会改变，如果我们把其中任意一个往中间挪，那么会让之后的字符移动更多的步数。

所以我们把它们放在当前填的范围的左右边界上就行了。

用ans[i]表示第i位上为原字符串中的第几位，树状数组处理逆序对即为最小移动步数。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
using namespace std;
typedef long long ll;
const ll size=1e6+10;
ll n,l,r,sum,flag,a[size],c[size],vis[size],ans[size];char s[size];
vector<ll> b[27];
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
inline void add(ll x,ll y){for(;x<=n;x+=x&-x) c[x]+=y;}
inline ll query(ll x){ll res=0;for(;x;x-=x&-x) res+=c[x];return res;}
int main(){
	scanf("%s",s+1);n=strlen(s+1);l=1;r=n;
	for(ll i=1;i<=n;i++){a[i]=s[i]-'A'+1;b[a[i]].push_back(i);}
	for(ll i=1;i<=26;i++){if(b[i].size()&1) flag++;}
	if((!(n&1)&&flag)||((n&1)&&flag!=1)){printf("-1\n");}
	else{
		if(n&1){
			for(ll i=1;i<=26;i++){
				if(b[i].size()&1){
					ll pos=b[i][b[i].size()/2];ans[n/2+1]=pos;vis[pos]=1;
				} 
			}
		}
		ll pos=1; 
		while(pos<=n){
			if(vis[pos]){pos++;continue;}
			if(pos>n||l>r) break;
			ans[l]=pos;vis[pos]=1;l++;pos++;
			ll t=b[a[pos-1]][b[a[pos-1]].size()-1];
			ans[r]=t;vis[t]=1;r--;b[a[pos-1]].erase(b[a[pos-1]].end()-1);
		}
		for(ll i=n;i>=1;i--){sum+=query(ans[i]);add(ans[i],1);}
		printf("%lld\n",sum);
	}
	return 0;
} 
```

---

## 作者：jasonliujiahua (赞：0)

# P5041

[题目传送门](https://www.luogu.com.cn/problem/P5041)
## 题意简述：
对于输入的字符串，一次可以将第 $i$ 个字符和第 $i+1$ 个字符交换，使得该串最终变为回文串。求最少交换次数。
## 题目分析：
### Step 1：贪心
有一个贪心策略是：**从外到内选对答案贡献最小的字母**。每一次选完之后，就可以看做将被选的位置刨去，并移动到两端。此操作可以使用树状数组维护，以方便知道当前枚举字符的位置。具体地，若当前字符左边或右边有位置被选了，则那里应当是一个空位，不应被计算在答案中（因为会被计算到断点位置里，具体看代码）。
### Step 2：略证
可以发现当前字符和之前被选中的字符交换一下位置，并不会使答案减少，因此这个局部最优可以得到全局最优。
## 参考代码：

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+10;
int n,ans,c[maxn];
char s[maxn];
deque<int> q[30];
inline int lowbit(int x){return x&(-x);}
inline void add(int x)
{
    for(;x<=n;x+=lowbit(x)) c[x]++;
}
inline int query(int x)
{
    int res=0;
    for(;x;x-=lowbit(x)) res+=c[x];
    return res;
}
void init()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    for(int i=1;i<=n;i++) q[s[i]-'A'].push_back(i);
}
void work()
{
    for(int i=1;i<=n/2;i++)
    {
        int mi=1e18,x=-1;
        for(int j=0;j<26;j++)
        {
            if(q[j].size()<2) continue;
            int l=q[j][0]-1-query(q[j][0]);
            int r=n-q[j][q[j].size()-1]-(2*(i-1)-query(q[j][q[j].size()-1]));
            if(l+r<mi)
            {
                mi=l+r;
                x=j;
            }
        }
        ans+=mi;
        add(q[x][0]);
        add(q[x][q[x].size()-1]);
        q[x].pop_front(),q[x].pop_back();
    }
    cout<<ans;
}
signed main()
{
    init();
    work();
    return 0;
}
```

---


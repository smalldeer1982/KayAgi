# [国家集训队] 丢失的题面（ydc的题面）

## 题目描述

曾经，有一个题面摆在 ydc 的面前没有珍惜，直到失去时才后悔莫及，

如果上天再给他一次机会，ydc 一定会牢牢的记住这个题面。

没办法，已经失去了，所以这道题只能让你帮 ydc 做了。

已知的信息只有，这道题是传统题，采用全文比较的方式，时间限制 1s，空间限制 256MB。

ydc 还给你提供了这道题的所有数据（见附件）。


## 说明/提示

### 来源

中国国家集训队互测2015 

### Author

于纪平

# 题解

## 作者：mrsrz (赞：132)

窝的拿分顺序：$10\rightarrow 1 \rightarrow 2 \rightarrow 4 \rightarrow 5 \rightarrow 6 \rightarrow 7 \rightarrow 8 \rightarrow 9 \rightarrow 3$。

这道题的大意是，给定输出文件，让你输出它。

观察下发的输出文件，```.out```文件都挺大的，不能直接输出。除了……第$10$个点。

## Point 10

输入是一段英文。大概意思是你需要使得你写的程序输出自己本身。

输出也是一段英文。

emmm……这貌似是一道**传统题**，而且没有```special judge```。

那直接输出这段东西就好了o((⊙﹏⊙))o

$10$分愉快到手。

---

接下来不会那么愉快了。

## Point 1

输入是$22$，输出是一个```01```串。

发现，串的长度刚好是$2^{22}$。

猜测和二进制、位运算有关。

仔细观察第一个字符和第二个字符，前两个字符和之后两个字符，前四个字符和之后四个字符，前八个字符和之后八个字符……

嗯！？

发现，我们取出最前面的$2^{k+1}(k\geqslant 0)$个字符，则前$2^k$个字符取反后恰好是后$2^k$个字符。

然后直接模拟即可拿到这$10$分辣~

## Point 2

输入是$33$，输出还是一个```01```串。

串长为$3524578$。

找一下这个数有什么性质。

嗯？这东西是第$33$个斐波那契数。

那么这个点应该和斐波那契数有关。

猜测这个串也是按照类似斐波那契数的生成方式生成的。

从后往前看，每次拉一个斐波那契数长度的字符串。

容易发现，第$i$个串由第$i-2$个串和第$i-1$个串按顺序拼成（第一个为$0$，第二个为$1$）。

模拟一下即可拿到这$10$分。

## Point 4

输入是$131074$个数，第一个是$131072$。

输出是$262146$个数，第一个是$262144$。

输入和输出应该有着相同的规律，且第一个数是下面的数的个数。

发现，之后第$1$个数是$1$，第二个数是$n$（$n$为第一行的数）。

看起来没什么头绪啊。

等等，把文件翻到最底下，最后一个数是$1$，倒数第二个数是$n$，然后又发现，倒数第$i$个数恰好等于第$i$个数。

也就是说，这个数列是个回文的。

啥数列是回文的，有$n+1$个元素，并且第一个、最后一个是$1$，第二个、倒数第二个是$n$呢？

跟我一起念：$1;1,2,1;1,3,3,1;\dots$

组合数！

已经猜到这个点让你干啥了，但是数列显然被取过模。我们还要求出模数是什么。

估计模数应该是个质数，而且在$10^8$左右。

那么直接把第$3$个元素算出来，对余数做差，然后把求出来的数质因数分解一下。

分出来一个大质数$104857601$。

那么直接用这个模数计算组合数即可。

验证一下，是对的。

又$10$分到手。

## Point 5

输入是$262146$个数，第一个是$262144$。

输出是$131074$个数，第一个是$131072$。

发现，和上一个点的输出情况有点像啊。

不计第$1$行，第$2k-1$行都是一样的。

而且，第二行那个数很接近上面那个点的模数啊。

不难猜到，每偶数位都被取反了。

然后直接```Ctrl+C```，```Ctrl+V```一下，然后判断奇偶，输出正的或负的即可。

这$10$分还是比较容易的。

## Point 6

输入是$531443$个数，第一个是$531441$。

输出是$177149$个数，第一个是$177147$。

$3$的幂次。

输出格式和前两个点一样，那应该还是和组合数有关系。

似乎没什么特别的啊。

撕烤两个问题：上一个点，组合数为啥会带符号？组合数和什么数是一个东西？

二项式系数？把两个数带进二项式，展开后算每个项的值？

二项式定理：

$$(a+b)^n=a^n+a^{n-1}b\binom{n}{2}+a^{n-2}b^2\binom{n}{3}+\dots+a^2b^{n-2}\binom{n}{n-2}+ab^{n-1}\binom{n}{n-1}+b^n$$

所以就是让你依次输出每个项的值是多少（模意义）。

那么我们得知道$a,b$分别是多少。

不是有第一项和最后一项的值吗，那就是求形如$x^{n}\equiv b\pmod p$的解。

由于前两个点模数都相同，不难猜到这个点模数还是那个数。

那么求方程的解就枚举一下即可，反正也不多。

解得$a=23333333,b=33333333$。

求出来以后，带进去算每项的值即可。

---

看一下```Point 7,8,9```的输入和输出的样子，不难猜到是三个图论问题，有多组询问。

## Point 7

有$100000$个点，$100000$条边，$200000$个询问，图不带权。

观察输出文件，发现，要么输出```0```，要么就是```0x7f7f7f7f```。

不难想到```0x7f7f7f7f```代表无穷大。

这种题目显然不会让你求一些奇怪的问题，所以应该比较基础。

那么无权图，每次询问两个点，要么```0```要么无穷，是什么问题呢？

判断两点的连通性？

那么很简单了，写个并查集就好了。

## Point 8

有$100000$个点，$99999$条边，$200000$个询问，图带权。

发现，找不到无穷大了。

那么，这应该是一棵树。

然后，观察输出文件，发现每个点的输出在输入的边权中都能找到，且都略偏大。

不难想到，题目是求两个点的路径中最长边的长度。

写个倍增即可。

## Point 9

有$50000$个点，$100000$条边，$200000$个询问，图带权。

出现了无穷大，说明存在不连通的情况。

做下来你会发现，每三个点的类型都一样，所以猜测这个点和上一个点有关系。

上一个点是树，这个点是图。

那么，难道是NOIP2013货车运输？

就是询问两个点的所有路径中，经过的最大边权最小的路径的最大边权（绕死了QAQ）。

那直接跑最小生成树，然后再按上个点的方法倍增求最大边即可。

还是不难想的吧。

---

## Point 3

窝觉得是最难想的一个点了，所以放在最后。

输入$12$，输出$3^{12}+11=531452$个字符，是个三进制数。

如果是每$12$个数为整体，则它并不能整除$531452$，因此应该不是这个规律。

多出$11$个数很难受啊，把前面$11$个```0```去掉吧。

然后再尝试把每$12$个数拉一拉，发现：

后面$10$位每$6$个数就变一次，前面$2$位变$6$次一循环。

好高兴啊！

然后你会发现，大概在第五千多个字符处，开始不同。

其实从后往前倒着看一下就可以否定掉这个规律。

怎么办啊QAQAQ？~~自闭吧~~

然后，就想着，把每个数作为开头，$12$个数拉一下。

嗯？感觉连续一段东西里面，每次都是把开头一个东西放在最后，就变成了下一个串。

当出现重复的时候，就不断加$1$，直到之前没出现过。

倒着拉了几个，好像也对啊。

那，怎么方便怎么搞吧（用```string```还是挺方便的，判重窝直接用```unordered_set```的，结果跑的巨慢），注意最前面和最后面的```0```需要微调一下。

终于是拿到最艰难的$10$分了。

---

前三个点窝都用```string```实现的，其他都比较常规。跑最慢的是第三个点。

## Code：
```cpp
#include<iostream>
#include<functional>
#include<algorithm>
#include<utility>
#include<unordered_set>
using namespace std;
int n;const int md=104857601;
int fac[524288],inv[524288];
inline int pow(int a,int b){
	int ret=1;
	for(;b;b>>=1,a=1LL*a*a%md)
	if(b&1)ret=1LL*ret*a%md;
	return ret;
}
inline int C(int n,int m){
	return fac[n]*1LL*inv[n-m]%md*inv[m]%md;
}
namespace subtask{
	int n,q,head[233333],cnt,fa[20][233333],mn[20][233333],dep[233333];
	struct edge{
		int to,nxt,dis;
	}e[666666];
	void dfs(int now,int pre){
		for(int i=head[now];i;i=e[i].nxt)
		if(e[i].to!=pre){
			dep[e[i].to]=dep[now]+1;
			fa[0][e[i].to]=now;
			mn[0][e[i].to]=e[i].dis;
			dfs(e[i].to,now);
		}
	}
	inline int ask(int u,int v){
		int m=0;
		if(dep[u]<dep[v])u^=v^=u^=v;
		for(int i=19;~i;--i)if(dep[fa[i][u]]>=dep[v])m=max(m,mn[i][u]),u=fa[i][u];
		if(u==v)return m;
		for(int i=19;~i;--i)
		if(fa[i][u]!=fa[i][v])m=max(m,max(mn[i][u],mn[i][v])),u=fa[i][u],v=fa[i][v];
		return max(m,max(mn[0][u],mn[0][v]));
	}
	inline void addedge(int u,int v,int t){
		e[++cnt]=(edge){v,head[u],t};head[u]=cnt;
		e[++cnt]=(edge){u,head[v],t};head[v]=cnt;
	}
	void main1(int N){
		n=N;
		cin>>q;
		for(int i=1;i<n;++i){
			int u,v,t;
			cin>>u>>v>>t;
			addedge(u,v,t);
		}
		dfs(1,0);
		for(int j=1;j<20;++j)
		for(int i=1;i<=n;++i){
			fa[j][i]=fa[j-1][fa[j-1][i]];
			mn[j][i]=max(mn[j-1][i],mn[j-1][fa[j-1][i]]);
		}
		while(q--){
			int u,v;
			cin>>u>>v;
			cout<<ask(u,v)<<'\n';
		}
	}
	pair<int,pair<int,int>>ed[233333];
	int F[233333];
	void main2(int N){
		n=N;int m,q;
		cin>>m>>q;
		for(int i=1;i<=m;++i)cin>>ed[i].second.first>>ed[i].second.second>>ed[i].first;
		sort(ed+1,ed+m+1);
		for(int i=1;i<=n;++i)F[i]=i;
		function<int(int)>find;
		find=[&find](int x){
			return x==F[x]?x:F[x]=find(F[x]);
		};
		for(int i=1;i<=m;++i)
		if(find(ed[i].second.first)!=find(ed[i].second.second)){
			F[find(ed[i].second.first)]=find(ed[i].second.second);
			addedge(ed[i].second.first,ed[i].second.second,ed[i].first);
		}
		for(int i=1;i<=n;++i)if(!dep[i])dep[i]=1,dfs(i,0);
		for(int j=1;j<20;++j)
		for(int i=1;i<=n;++i){
			fa[j][i]=fa[j-1][fa[j-1][i]];
			mn[j][i]=max(mn[j-1][i],mn[j-1][fa[j-1][i]]);
		}
		while(q--){
			int u,v;
			cin>>u>>v;
			cout<<((find(u)==find(v))?ask(u,v):0x7f7f7f7f)<<'\n';
		}
	}
};
int main(){
	for(int i=*fac=1;i<=524288;++i)fac[i]=fac[i-1]*1LL*i%md;
	inv[524288]=pow(fac[524288],md-2);
	for(int i=524287;~i;--i)inv[i]=(i+1LL)*inv[i+1]%md;
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	if(n==22){
		string ans="",out="0";
		for(int i=1;i<=1<<n;i<<=1){
			ans+=out;
			out=ans;
			for(char&it:out)it^=1;
		}
		cout<<ans<<'\n';
	}else
	if(n==33){
		string a="0",b="1",c;
		for(int i=1;i<n;++i)c=a+b,a=b,b=c;
		cout<<a<<'\n';
	}else
	if(n==12){
		unordered_set<string>st;
		string s="000000000001",output="";
		for(;;){
			output+=s[0];
			st.insert(s);
			s+=s[0];
			s.erase(0,1);
			while(st.count(s)&&s!="000000000000"){
				++s[11];
				for(int i=11;~i&&s[i]=='3';--i){
					s[i]='0';
					if(i)++s[i-1];
				}
			}
			if(s=="000000000000")break;
		}
		cout<<0<<output<<"00000000000\n";
	}else
	if(n==131072){
		cout<<"262144\n";
		for(int i=0;i<=262144;++i)
		cout<<C(262144,i)<<'\n';
	}else
	if(n==262144){
		cout<<"131072\n";
		for(int i=0;i<=131072;++i)
		cout<<((i&1)?md-C(131072,i):C(131072,i))<<'\n';
	}else
	if(n==531441){
		int a=23333333,b=33333333;
		cout<<"177147\n";
		for(int i=0;i<=177147;++i)
		cout<<1LL*C(177147,i)*pow(b,i)%md*pow(a,177147-i)%md<<'\n';
	}else
	if(n==100000){
		int m;
		cin>>m;
		if(m==n){
			static int fa[524288];
			function<int(int)>find;
			find=[&find](int x){
				return x==fa[x]?x:fa[x]=find(fa[x]);
			};
			for(int i=1;i<=n;++i)fa[i]=i;
			int q;
			cin>>q;
			for(int i=1;i<=m;++i){
				int u,v;
				cin>>u>>v;
				if(find(u)!=find(v))fa[find(u)]=find(v);
			}
			while(q--){
				int a,b;
				cin>>a>>b;
				cout<<((find(a)==find(b))?0:0x7f7f7f7f)<<'\n';
			}
		}else
		subtask::main1(n);
	}else
	if(n==50000)
	subtask::main2(n);else
	if(!n)
	cout<<"Your program should output itself here.\nSounds very difficult, yeah?\nAnyway, good luck!\n";
}
```

---

## 作者：望月Asta (赞：80)

## 前言

这是一篇实验性的题解,用于探讨对于特殊形式的题目，使用特殊形式的题解是否能 **条理清晰且有趣地** 讲明解题的思路与方式。

灵感来自于 《哥德尔、艾舍尔、巴赫书：集异璧之大成》 一书，题解中我也会模仿原文对话质朴的文风。

书中，作者侯世达多次采取了乌龟与阿基里斯对话的形式以使得讲述更加生动，因此我尝试套用这两个角色，写一篇题解给这道不甚传统的　“传统题”。

作为一篇拙劣的仿作，如果这篇博客因为学术性不足并不能通过题解审核，也是可以理解的，但我依然要尝试一下。

## Sonata

（乌龟叩响了阿基里斯的房门。）

乌龟 ： 我亲爱的老朋友，你绝对想不到我带来的这个问题是多么绝妙！

阿基里斯 ： 我想以你与我的才智，这又会是再一次智力与思维的 _奏鸣曲_。
快把题面拿出来吧，龟兄。

乌龟 ： 真可惜，这道题没有题面——或者依题目自己的说法，题面已经 **“丢失了”**。

> 曾经，有一个题面摆在 ydc 的面前没有珍惜，直到失去时才后悔莫及，  
> 如果上天再给他一次机会，ydc 一定会牢牢的记住这个题面。  
> 没办法，已经失去了，所以这道题只能让你帮 ydc 做了。  
> 已知的信息只有，这道题是传统题，采用全文比较的方式，时间限制 1s，空间限制 256MB。  
> ydc 还给你提供了这道题的所有数据。

乌龟 ： 阿基，这里就是题面了，让我们从分析题目数据开始吧。
但是在解题的时候，一定不要忘记这是一道 **传统题**。

## Symphony

阿基里斯 ： 龟兄，这可是道传统题，直接用最简单的 **打表** 不就可以解决了吗？

乌龟 ： 只能说是你小瞧了我带来的这道题啊！源代码可是有 **长度限制** 的。
依我看，我们需要通过测试数据来猜测每个测试点要实现什么功能，然后用原来的方式实现。

阿基里斯 ： 龟兄，**文件大小** 真是这道题的关键，不如先把输入输出按照文件大小排序来看看吧。

乌龟（打开文件管理器） ： 我按你说的做。嗯…… \#10 的输入输出文件都很小啊，让我把它打开……

`(lost10.in)`

```
Maybe this test case is the hardest, ever.
To get 100pts in this task, your program should pass the previous 9 test cases, and it should also be a "quine".
You can refer to http://en.wikipedia.org/wiki/Quine_(computing) for more information.
```

阿基里斯 ： 啊，是 Quine，这正是我了解的。这是一个以美国哲学家奎因命名的 **自产生程序**。我想这个测试点是要在最后完成的，我们可以用 [这里的](https://loj.ac/s/1271819) 方式把完成的源代码改造成一个 Quine。

乌龟（露出疑惑的神情） ： 阿基，虽然我不了解你说的什么 “奎因”，但你这就忘记了这是 **传统题** 吗，只需要把输出文件原样输出就可以了啊。

阿基里斯 ： 龟兄，不得不说这次是你占了先机啊，不过这么快拿到了 $10$ 分，也是一件好事。

---

阿基里斯 ： 我想 \#1，\#2 和 \#3 是比较类似的测试点，都是输入一个数字，输出一个二进制串……等等，\#3 输出的是三进制，大同小异。

乌龟 ： 你说得对，阿基，但这三个串都长得我无从下手。

阿基里斯（托着下巴思考） ： 那么不如从长度开始吧，第一个串长度是多少？ $419304$ ！
这可是个不一般的数，我敏锐的数学直觉告诉我这是 $2^{22}$。

乌龟 ： 看到输入文件有 $22$，正常的人都能想到这个，我们需要更关键的性质。

阿基里斯 ： 等等，这个串似乎是回文的，再加上长度是 $2^{22}$，输入文件一定代表着对字符串操作的次数，而这个操作一定含有 **每次翻倍**。

乌龟 ： 突破性的进展！那么想必依照这种构造方式，$0,1$ 出现的次数一定有迹可循。

很好，两种字符都出现了恰好 $2097152$ 次，这个串一定是每次翻倍而构造的，我想，是取反后接在尾部，否则就 **不能同时有两种字符了**。

（乌龟和阿基里斯尝试着写出一段代码）

```cpp
std::string s = "0";
std::string t;

inline void Generate() {
    t = "";
    repl(i,0,s.size())
        s[i] == '0' ? t += '1' : t += '0';
    s += t;
}

int main() {
  	int n;
    scanf("%d",&n)
    for(int i = 1;i <= n;++i)
      	Generate();
    std::cout << s << std::endl;
    return 0;
}
```

阿基里斯 ： \#2 也先从长度入手吧，$3524578$，而输入是 $33$。龟兄，这个数恰好是**斐波那契**数列的第 $33$ 位，$F_{33}$ 啊。
而和斐波那契有关的字符串……

乌龟（点头回应） ： ……那便是斐波那契字符串！通过把字符串中 $0$ 和 $1$ 按照一定规则转化得到的串，我想，对于这个字符串便是每次变换把 $0$ 变成 $1$ 而把 $1$ 变成 $01$ 了。

```cpp
std::string s = "0";
std::string t;

inline void Generate() {
    t = "";
    for(auto i : s)
        i == '0' ? t += '1' : t += "01";
    s = t;
}

int main() {
    int n;
  	scanf("%d",&n);
    for(int i = 1;i <= n;++i)
      	Generate();
    std::cout << s << std::endl;
    return 0;
}
```

乌龟 ： 然后这一阶段只剩第三个测试点了，让我看看长度…… $531452$。阿基，你说这个数和输入数据 ： $12$ 有什么关系吗？

阿基里斯 ： 既然是三进制串，那自然会想到 $3^{12}$，但是 $3^{12} = 531441$，并不是 $531452$ 但是很接近了。

$531452$ 是 $3^{12} + 11$，可能这个字符串里有多余的 $11$ 位不属于这个构造规则。 稍等，我觉得可以按照 $12$ 位对字符串分段试一试。

乌龟 ： 好主意，阿基，这下显得有序多了。好像，这么划分后每个 $12$ 位的子串长度都是不一样的，让我们用文本编辑器搜索一下——果真如此！

阿基里斯 ： 龟兄，不止如此，如果稍微对划分错位一下，还能划分出许多不同的 $12$ 位三进制串。

乌龟 ： 我不理解，为什么要打破已经分好的段落呢？

阿基里斯 ： 你听我说，这些串都出现仅仅一次，你找不到任意的相同的 $12$ 位子串，说明这是包含了所有 $12$ 位三进制串的的一个字符串！

让我们把这个串拆开，感受一下是怎么叠在一起的——快画个图吧 ： 

![如果你看到这行字说明图片挂了](https://cdn.luogu.com.cn/upload/image_hosting/341mv0z3.png)

这让我想到一道题 ： [CF508D Tanya and Password](https://www.luogu.com.cn/problem/CF508D) 也是将许多串不重地拼接在一起，于是我们可以把这个问题放到图上。

乌龟 ： 稍等一下，图论……你的意思是把 **前面删除一位后面再添加一位的数之间连边**？

阿基里斯 ： 是的，就是这样，这样我们就可以使用 **欧拉回路** 来求解这个问题了，和我提到的那道题十分相似。但是并不需要把图实际建立出来 ： 

```cpp
constexpr int N = 177147;
std::string s = "";
int vis[N + 5];
std::stack<int> stk;

inline void Generate(int x) {
    while(vis[x] < 3) {
        stk.push(3 * x + vis[x]);
        ++vis[x];
        x = (3 * x + (vis[x] - 1)) % N;
    }
}

int main() {
    Generate(0);
    while(!stk.empty()) {
        int u = stk.top();stk.pop();
        s += (char)(u % 3 + '0');
        Generate(u / 3);
    }
    for(int i = 1;i <= 11;++i)
      	s += '0';
    std::reverse(s.begin(),s.end());
  	std::cout << s << std::endl;
    return 0;
}
```
---

乌龟 ： 阿基，我们真是进展神速，一鼓作气来看 \#4，\#5 和 \#6 吧，这三个数据点似乎是成组的。

阿基里斯 ： 妙极了，输入与输出都是先有一行一个整数 $n$，随后跟着 $n + 1$ 行，每行一个正整数。我想这是一系列 **$\mathbf{n}$ 次多项式**。我想我需要像拉马努金那样 “和所有的自然数做朋友” 才能猜到这三种变换了。

乌龟 ： 不过我认为这不是无迹可寻，起码可以先看看系数的关系。

 - \#4 翻了一倍
 - \#5 减半
 - \#6 减少到 $\dfrac{1}{3}$

而且 \#4 和 \#5 是互逆的操作。

阿基里斯 ： 我想，能恰好把系数翻倍和减半的只有平方和开根了，当务之急是找到模数。这里能找到最大的数是多少？

乌龟 ： $104688317$。

阿基里斯 ： 我想，和这个数最接近的 NTT 模数便是 $104857601$ 了，原根恰好为 $3$，我可要好好把多项式模板里的常量改好，免得套上了板子又变成对 $998244353$ 取模，弄巧成拙。

乌龟 ： 那按你的说法，\#6 就是多项式三次根了，这该怎么做？

阿基里斯 ： 我可是有办法的，甚至可以做多项式任意次数的开根。形象化地说，下面就叫开 $k$ 次根吧。

对数函数可以把乘法变成加法，也可以把乘方变成乘法。那么用对数函数把开根变为乘法就可以了。

$$\large\begin{aligned}

\ln \sqrt[k]{F(x)} &= \frac{F(x)}{k}\\

\sqrt[k]{F(x)} &\equiv \exp (k^{-1} \ln F(x)) \bmod x^n

\end{aligned}$$

乌龟 ： 但是 $F(x)$ 的第一项可不是 $1$，你要如何求多项式对数函数呢？

阿基里斯 ： 你问到关键了，我们先把每一项乘以第一项的逆元，最后每一项再乘以第一项单独开 $k$ 次根的结果就行了，而求第一项的 $k$ 次根，或者说 **$\mathbf{k}$ 次剩余**。

$$\large

x^k \equiv F(0) \pmod p

$$

但是现在模数有一个原根 $3$，我们可以用 $3^r$ 的形式表示一个数，现在式子化为 ： 

$$\large

3^{rk} \equiv F(0) \pmod p

$$

那么这就是熟悉的高次同余方程的形式了，直接用 BSGS 求解就行。我可是对我的手写哈希表很有信心的。

不过似乎常数大了些？靠 O2 优化还是能通过的。

(阿基里斯拿出了他之前写的代码)

```cpp
constexpr int SIZ = 100003;
struct HashTable {
    int tot;
    int head[SIZ];
    struct Node {
        int nxt,val;
        ll key;
    }p[N];
    
    HashTable() : tot(0) {mems(head,0);}
    
    inline int& operator [] (const int x) {
        int h = x % SIZ;
        for(int i = head[h];i;i = p[i].nxt)
            if(p[i].key == x) return p[i].val;
        p[++tot] = (Node) {head[h],0,x},head[h] = tot;
        return p[tot].val;
    }
}mp;

inline int BSGS(int a,int b) {
    const int mx = ceil(sqrtf(MOD));
    int base = b % MOD;
    rep(i,1,mx) {
        base = (ll)base * a % MOD;
        mp[base] = i;
    }
    base = qpow(a,mx);
    if(a == 0) return b == 0 ? 1 : -1;
    int prod = 1;
    rep(i,1,mx) {
        prod = (ll)prod * base % MOD;
        int px = mp[prod];
        if(px) return (((ll)i * mx - px) % MOD + MOD) % MOD;
    }
    return -1;
}

void exgcd(int a,int b,int& d,int& x,int& y) {
    if(!b) {
        d = a; x = 1; y = 0;
        return ;
    }
    exgcd(b,a % b,d,y,x);
    y -= x * (a / b);
}

int GetInv(int a,int p) {
    int d, x, y;
    exgcd(a, p, d, x, y);
    return d == 1 ? (x + p) % p : -1;
}

inline int gcd(int a,int b) {
    int k = __builtin_ctz(a | b);
    a >>= __builtin_ctz(a);
    b >>= __builtin_ctz(b);
    int p = a % b;
    while(p)
        a = b,b = p,p = a % b;
    return b << k;
}

inline void PolyResidue(const int *a,int *b,int n,int k) {
    static int x[N],c[N];int invk = qpow(k),invc = qpow(a[0]);
    repl(i,0,n) c[i] = (ll)a[i] * invc % MOD;
    PolyLn(c,x,n);
    repl(i,0,n) x[i] = (ll)x[i] * invk % MOD;
    PolyExp(x,b,n);
    int pw = BSGS(G,a[0]),w = INF;
    int M = MOD - 1,g = gcd(M,gcd(k,pw));
    k /= g,pw /= g,M /= g;
    int t = (ll)pw * GetInv(k,M) % M;
    for(;t < MOD - 1;t += M)
        w = std::min(w,qpow(3,t));
    repl(i,0,n) b[i] = (ll)b[i] * w % MOD;
}
```

乌龟 ： 我的朋友，我必须承认你在多项式这方面的造诣远超于我，但是在你一直思考多项式做法时忽略了一件事情，那就是这三组数据是特殊构造的。

仔细看看 \#4 的输出，是回文的，而且第一项是 $1$，第二项就是 $n$，你想到了什么？是的，**杨辉三角**。我们靠一个简单的预处理阶乘和阶乘的逆元即可解决这个问题了，至于 \#5 ，也就是把偶数位取反罢了。

而 \#6，我确信它们也有差不多的特质。

阿基里斯 ： 龟兄，你是没能发现 \#6 的特性吗，似乎确实如此，第一项并不是 $1$，那么唯一能和组合数靠上边的就是二项式定理了 ： 

$$\large

(a + b)^n = \sum_{k = 0}^{n} a^k b^{n - k} \binom{n}{k}

$$

有了第一项和最后一项，再用上我上面的求 $k$ 次剩余，求出 $a,b$ 信手拈来！

不就是 $a = 23333333,b = 33333333$ 吗。

乌龟 ：真是天才，说得让我想为你即兴创作一首赞美诗了，这样就有了常数更小的解法啦！

---

阿基里斯 ： 现在是时候来看最后三组测试点了，它们看起来也是颇为相似。首先一行三个数，然后是许多行，每行一个二元组或三元组。

乌龟 ： 这是常见的的图论的输入格式啊，我猜第一行三个数分别是点数边数和询问数，就记为 $n,m,q$ 吧。

阿基里斯 ： 龟兄，\#7 的输出只有 $0$ 和 $2139062143$ 或者说 `0x7f7f7f7f`，说明这组测试点的询问只有两种结果，我想不是询问路径长度奇偶性就是两点是否连通了。

乌龟 ： 让我写一个 **并查集** 验证一下……是的，是连通性，让我们看下一个数据点吧。

阿基里斯 ： $n$ 个点 $n - 1$ 条边，这可骗不过我，如果这个图连通，那么想必是一棵带边权的树。树上会有什么询问呢？

乌龟 ： 输入里没有输入树的根，那想必不是子树问题了，我觉得是树链询问吧，让我先把 **树链剖分** 写出来。嗯……输出的结果都不大，那应该是 **树链** 最大值，用 st 表就能实现 $\mathcal{O} (n \log n)$ 预处理，$\mathcal{O} (\log n)$ 查询了，比起线段树，我还是更喜欢 st 表。

阿基里斯 ： \#9 的输入是带权图，询问似乎也是最值。啊，输出还有 `0x7f7f7f7f`，我猜是代表图上两点不连通。

那么应该就是把 [\[NOIP2013 提高组\] 货车运输](https://www.luogu.com.cn/problem/P1967) 反过来，改成求最小生成树然后求树上路径最大值，也就是图上两点之间最短路径中权值最大的。

乌龟 ： 我们已经解决了全部的测试点了，想必把代码组合在一起会像 _交响乐_ 一样恢弘。

阿基里斯 ： 那我就把代码放在 [这里](https://www.luogu.com.cn/paste/1zw1xspm) 了。

乌龟 ： 辛苦你了，我的朋友。

## Minuet

乌龟 ： 阿基，你知道吗，这种 “非传统的” 传统题可不止一道 ：

- [\[十二省联考 2019\] 骗分过样例](https://www.luogu.com.cn/problem/P5285) : 给出输入输出求解决方案.

- [\[WC2015\]未来程序](https://www.luogu.com.cn/problem/P4920) : 给出输入,代码,求题意与高效解决方式.

- [\[集训队互测 2016\] 消失的源代码](https://www.luogu.com.cn/problem/P5246) : 给出可执行程序和输入,进行反编译.

- [\[WC2014\]非确定机](https://uoj.ac/problem/56) : 给出可执行程序和输出,构造任意一个可行输入.

- [\[集训队互测2015\]未来程序·改](https://uoj.ac/problem/98) : 输入数据包含代码,要求实现代码编译.


阿基里斯 ： 这可太有趣了，不过我们已经解决了这道题，是时候休息一会了，你有兴趣听一会优雅的 _小步舞曲_ 吗？

乌龟 ： 再好不过了，我的朋友。

---

## 作者：Star_Cried (赞：10)

# P5042 丢失的题面

顺序：10 - 1 - 7 - 8 - 9 - 4 - 5 - 6 - 2 - 3

## Point 10

读入，特判，输出。

读入的英文意思是让选手输出自己的程序本身，这个题的确存在，但是这题并没有 SPJ ，所以特判一下输出输出文件就好了。

C++ 的`atoi`函数可以让读入的字符串变成数字以完成其他点的任务。

## Point 1

我和其他聚铑做这个点的过程就十分有趣了。

开始，我们使用了大眼观察法观察了一下这个输出，不知道怎么我就看出了将序列每四个字符划分，然后变成若干以`0110`开头的长度为 4 的 01 串组。发现这些组的大小都在 3 以内，于是我们在 OEIS 上搜了一下这个序列，居然真的找到了：[A007413](https://oeis.org/search?q=A007413&language=english&go=Search) 

它的递推方式是三个元素，每次操作 `a->abc b->ac c->b` 。这道题中这三个字母分别代表 `0110` `01101001` 和 `011010011001` 。做了一下，发现是对的。

然后观察文件大小发现输出的字符串长度是 $2^{22}$ 。没细想，写完就过了。

但是为什么是 $2^{22}$ 呢？

我回头看了一眼，发现输出好像是初始一个 0 字符，每次操作将当前串取反拼接到后面，做 22 次的结果……（鬼知道我当初为啥直接就想每 4 个分组）

然后又看了下 OEIS，发现这个输出本身就是一个数列：[A010060](https://oeis.org/search?q=A010060&sort=&language=english&go=Search)。这个序列还有个名字叫做

[Thue-Morse Sequence](https://mathworld.wolfram.com/Thue-MorseSequence.html)

在[wikihow](https://www.wikihow.com/Generate-the-Thue-Morse-Sequence#/Image:Generate-the-Thue-Morse-Sequence-Step-1-Version-2.jpg)中，叙述了这个序列的几种构造方法，除了上述的两种构造方式之外，还可以直接每次操作 `0->01` `1->10` 来构造。

~~真有趣~~

但是代码还是用的第一次写的，懒得改了。（by a___)

```cpp
namespace subtask1{
	int n=22;
    vector<vector<int>>vec,tmp;
    string s[4],ans;
	vector<int>to[4];
    inline void main(){
        int n=20;
        to[1]=vector<int>({1,2,3});
        to[2]=vector<int>({1,3});
        to[3]=vector<int>({2});
        vec.push_back(std::vector<int>({1}));
        while(n--)
        {
            for(auto p:vec)
            for(auto q:p)tmp.push_back(to[q]);
            swap(vec,tmp);tmp.clear();
        }
        s[1]="0110";
        s[2]="01101001";
        s[3]="011010011001";
        for(auto p:vec)ans+=s[p.size()];
        ans.resize(1<<22);
        std::cout<<ans<<std::endl;
    }
}
```

## Point 7

因为 2~6 个点都没有什么思路，直接来看第 7 个点。

观察了一下输入，发现是一个图，而且边没有边权。观察了一下输出，发现输出只有 0 和 INF 两种数字。于是几乎可以确定是判断图上两点间连通性了。

```cpp
namespace subtask7{
	int fa[100005];
	int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
	inline void onion(int x,int y){
		x=find(x),y=find(y);
		if(x!=y) fa[x]=y;
	}
	inline void main(int n,int m){
		int q=read();
		while(n) fa[n]=n,n--;
		while(m--) onion(read(),read());
		while(q--) puts(find(read())==find(read())?"0":"2139062143");
	}
}
```

## Point 8

切完了上面的点，一看这个点也是个图，而且边有边权。大概扫了一下发现这是个随机生成的树，边权也是随的。询问格式是两个点。

再观察输出，发现输出的答案大多都大于 90000。说明是一个答案期望较大的询问。两点间路径和或者乘积不可能，试验了一下异或发现答案溢出 100000，那么或也顺便排除。

傻了吧唧地想了半天，突然有一位聚铑想到，为啥不是最大值呢？

试了一下果然没错。

```cpp
namespace subtask8{
	const int maxn=1e5+10;
	int fa[maxn][21],mx[maxn][21],Q,n=100000;
	int ecnt,head[maxn],to[maxn<<1],nxt[maxn<<1],v[maxn<<1],dep[maxn];
	inline void addedge(int a,int b){
		to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;
		to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt;v[ecnt]=v[ecnt-1]=read();
	}
	void dfs(int x,int f){
		fa[x][0]=f;dep[x]=dep[f]+1;
		for(int i=0;i<18;i++) fa[x][i+1]=fa[fa[x][i]][i],mx[x][i+1]=max(mx[x][i],mx[fa[x][i]][i]);
		for(int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(u==f)continue;
			mx[u][0]=v[i];
			dfs(u,x);
		}
	}
	inline int solve(int x,int y){
		if(dep[x]<dep[y])swap(x,y);
		int ans=0;
		for(int i=18;~i;i--) if(dep[fa[x][i]]>=dep[y]) ans=max(ans,mx[x][i]),x=fa[x][i];
		if(x==y)return ans;
		for(int i=18;~i;i--) if(fa[x][i]!=fa[y][i]) ans=max(ans,max(mx[x][i],mx[y][i])),x=fa[x][i],y=fa[y][i];
		ans=max(ans,max(mx[x][0],mx[y][0]));
		return ans;
	}
	inline void main(){
		Q=read();
		for(int i=1;i<n;i++) addedge(read(),read());
		dfs(1,0);
		while(Q--) printf("%d\n",solve(read(),read()));
	}
}
```

## Point 9

观察了一下输入，发现是个图。

观察了一下输出，发现有 INF 的存在，那么询问可能是让答案尽量小，所以盲猜最小瓶颈路。试了一下，果然是。

kruskal 的并查集和路径最大值都可以用前面的板子。（出题人真良心）

```cpp
namespace subtask9{
	const int maxn=100005,INF=2139062143;
	int Fa[100005],fa[maxn][21],mx[maxn][21];
	int find(int x){return Fa[x]==x?x:Fa[x]=find(Fa[x]);}
	struct edge{
		int u,v,val;
		inline bool operator < (const edge& zp) const {return val<zp.val;}
	}e[maxn<<1];
	int ecnt,head[maxn],to[maxn<<1],nxt[maxn<<1],v[maxn<<1],dep[maxn];
	inline void addedge(int a,int b,int c){
		to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;v[ecnt]=c;
		to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt;v[ecnt]=c;
	}
	void dfs(int x,int f){
		fa[x][0]=f;dep[x]=dep[f]+1;
		for(int i=0;i<18;i++) fa[x][i+1]=fa[fa[x][i]][i],mx[x][i+1]=max(mx[x][i],mx[fa[x][i]][i]);
		for(int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(u==f)continue;
			mx[u][0]=v[i];
			dfs(u,x);
		}
	}
	inline int solve(int x,int y){
		if(dep[x]<dep[y])swap(x,y);
		int ans=0;
		for(int i=18;~i;i--) if(dep[fa[x][i]]>=dep[y]) ans=max(ans,mx[x][i]),x=fa[x][i];
		if(x==y)return ans;
		for(int i=18;~i;i--) if(fa[x][i]!=fa[y][i]) ans=max(ans,max(mx[x][i],mx[y][i])),x=fa[x][i],y=fa[y][i];
		ans=max(ans,max(mx[x][0],mx[y][0]));
		return ans;
	}
	inline void main(){
		read();int Q=read();
		for(int i=1;i<=100000;i++) Fa[i]=i,e[i].u=read(),e[i].v=read(),e[i].val=read();
		sort(e+1,e+100001);
		for(int i=1;i<=100000;i++){
			int u=find(e[i].u),v=find(e[i].v);
			if(u!=v){
				Fa[u]=v;
				addedge(e[i].u,e[i].v,e[i].val);
			}
		}
		for(int i=1;i<=50000;i++) if(!dep[i]) dfs(i,0);
		while(Q--){
			int x=read(),y=read();
			if(find(x)!=find(y))printf("%d\n",INF);
			else printf("%d\n",solve(x,y));
		}
	}
}
```

## Point 4

后面的全做完了，回头看一眼 01 串和 012 串，没啥思路，直接看第四个。

观察了一下输入输出，发现输入输出都是~~回文~~

什么玩意是回文的？

第一个字符大概是 n，发现第一项是 1，第二项是 n。于是有个聚铑很自然地想到是组合数，然后发现输出也是对应的 n 的一行组合数，于是就切了。

拆了一下数，发现模数是 104857601，**一个 NTT 模数**。

```cpp
namespace subtask4{
	const int maxn=3e5;
	int mul[maxn],inv[maxn],n;
	inline int C(int n,int m){return 1ll*mul[n]*inv[m]%mod*inv[n-m]%mod;}
	inline void pre(){
		mul[0]=inv[0]=1;
		for(int i=1;i<=n;i++) mul[i]=1ll*mul[i-1]*i%mod;
		inv[n]=fpow(mul[n],mod-2);for(int i=n-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
	}
	inline void main(){
		n=262144;
		pre();
		printf("%d\n",n);
		for(int i=0;i<=n;i++) printf("%d\n",C(n,i));
	}
}
```

### PS

后来思考了一下为什么输入把 131072 的一行组合数也全给了，根据二项式定理，输入给出的是 $(x+1)^n$，然后输出的 n 恰好是输入的两倍。所以实际上是让我们算 $(x+1)^{2n}$。也就是做一遍多项式乘法。

~~会有人写这玩意吗，还是为了给没看出来是组合数的选手分？~~

## Point 5

刚才切了第四个点的聚铑趁热打铁，瞬间就看出来了是每一项乘上了一个 $(-1)^i$ 。于是又切了。

当然，如果您想写多项式开根也可以。

因为和前面一个点比较像，就放在一起了。

```cpp
namespace subtask4{
	const int maxn=3e5;
	int mul[maxn],inv[maxn],n;
	inline int C(int n,int m){return 1ll*mul[n]*inv[m]%mod*inv[n-m]%mod;}
	inline void pre(){
		mul[0]=inv[0]=1;
		for(int i=1;i<=n;i++) mul[i]=1ll*mul[i-1]*i%mod;
		inv[n]=fpow(mul[n],mod-2);for(int i=n-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
	}
	inline void main2(){
		n=131072;
		pre();
		printf("%d\n",n);
		for(int i=0;i<=n;i++) printf("%d\n",i&1?mod-C(n,i):C(n,i));
	}
}
```

## Point 6

~~刚才那位聚铑乘胜追击~~，观察了一下输入输出的项数，发现输出刚好是输入的 $\frac{1}{3}$ 。

什么东西能减少项数，而且刚好减到 $\frac{1}{3}$？

~~只有聚铑知道答案~~。他一眼就看出来这似乎是一个多项式三次剩余，然后确实是对的。

然而 $\color{#FFFFFF}\colorbox{#8E44AD}{\small\texttt{珂愛}}$ 似乎有更好的方法，因为这个 $5e5$ 的数据范围，还是用的多项式快速幂真的太勉强了，加了快读快输开优化才能过。用 $\color{#FFFFFF}\colorbox{#8E44AD}{\small\texttt{珂愛}}$ 的方法或者多项式三次方根或许能更好（更短）地通过此题。

```cpp
namespace subtask6{
	const int maxn=533000<<2,mod=104857601,g=3,gi=104857602/3,n=177147,p=63776689;
	struct NTT{
		int r[maxn],lim;
		inline void getr(int li){
			lim=li;
			for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)*(lim>>1));
		}
		inline void operator () (int *a,int type) const {
			for(int i=0;i<lim;i++) if(i<r[i]) swap(a[i],a[r[i]]);
			for(int mid=1;mid<lim;mid<<=1){
				int rt=fpow(type==1?g:gi,(mod-1)/(mid<<1));
				for(int r=mid<<1,j=0;j<lim;j+=r){
					int p=1;
					for(int k=0;k<mid;k++,p=1ll*p*rt%mod){
						int x=a[j+k],y=1ll*p*a[j+k+mid]%mod;
						a[j+k]=(x+y)%mod,a[j+k+mid]=(x-y+mod)%mod;
					}
				}
			}
			if(type==-1) for(int p=fpow(lim,mod-2),i=0;i<lim;i++) a[i]=1ll*a[i]*p%mod;
		}
	}ntt;
	void inv(const int *a,int *ans,int n){
		if(n==1) return ans[0]=fpow(a[0],mod-2),ans[1]=0,void();
		static int res[maxn];
		inv(a,ans,n>>1);
		int lim=n<<1;
		ntt.getr(lim);
		for(int i=0;i<n;i++) res[i]=a[i];
		for(int i=n;i<lim;i++) res[i]=ans[i]=0;
		ntt(res,1),ntt(ans,1);
		for(int i=0;i<lim;i++) ans[i]=ans[i]*(2-1ll*ans[i]*res[i]%mod+mod)%mod;
		ntt(ans,-1);
		for(int i=n;i<lim;i++) ans[i]=0;
	}
	inline void deri(const int *a,int *ans,int n){for(int i=1;i<n;i++) ans[i-1]=1ll*a[i]*i%mod;ans[n-1]=0;}
	inline void inte(const int *a,int *ans,int n){for(int i=1;i<n;i++) ans[i]=1ll*a[i-1]*fpow(i,mod-2)%mod;ans[0]=0;}
	inline void ln(const int *a,int *ans,int n){
		static int res[maxn];
		deri(a,res,n);
		inv(a,ans,n);
		int lim=n<<1;
		ntt.getr(lim);
		ntt(res,1),ntt(ans,1);
		for(int i=0;i<lim;i++) res[i]=1ll*res[i]*ans[i]%mod,ans[i]=0;
		ntt(res,-1);
		inte(res,ans,n);
		for(int i=0;i<lim;i++) res[i]=0;
	}
	void exp(const int *a,int *ans,int n){
		if(n==1) return ans[0]=1,ans[1]=0,void();
		static int res[maxn];
		exp(a,ans,n>>1);
		ln(ans,res,n);
		int lim=n<<1;
		ntt.getr(lim);
		res[0]=(1+a[0]-res[0]+mod)%mod;
		for(int i=1;i<n;i++) res[i]=(a[i]-res[i]+mod)%mod;
		ntt(ans,1),ntt(res,1);
		for(int i=0;i<lim;i++) ans[i]=1ll*ans[i]*res[i]%mod,res[i]=0;
		ntt(ans,-1);
		for(int i=n;i<lim;i++) ans[i]=0;
	}
	inline void fpow(int const *a,int *ans,int k,int n){
		static int f[maxn],g[maxn];
		for(int i=0;i<n;i++)g[i]=f[i]=ans[i]=0;
		int d=0;
		while(!a[d]&&d<n) ++d;
		int u=::fpow(a[d],mod-2),v=22131490;
		for(int i=0;i<n-d;i++)g[i]=1ll*a[i+d]*u%mod;
		for(int i=n-d;i<n;i++)g[i]=0;
		ln(g,f,n);
		for(int i=0;i<n;i++)f[i]=1ll*f[i]*k%mod;
		exp(f,ans,n);
		d*=k;
		for(int i=n-1;i>=d;i--)ans[i]=1ll*ans[i-d]*v%mod;
		for(int i=0;i<d;i++)ans[i]=0;
	}
	int a[maxn],ans[maxn];
	inline void main(){
		for(int i=0;i<=n;i++) a[i]=read();
		fpow(a,ans,::fpow(3,mod-2),1<<18);
		out(n);
		for(int i=0;i<=n;i++) out(ans[i]);
	}
}
```

## Point 2

终于要直面 01 串了。（由第一个点就可以知道我 01 串相关有多菜）

首先，一位聚铑通过观察文件大小发现字符个数恰好是斐波那契数列的第 33 项。

发现除了前三项，后面几项都符合斐波那契串。而一个斐波那契串内确实有这样的规律。

写了一下，发现是对的。

顺便模一下这位聚铑写得真可爱。

```cpp
namespace subtask2{
	string s[2]={"0","1"};
	inline void main(){
		for(int i=2;i<33;i++) s[i&1]=s[i&1]+s[i&1^1];
		puts(s[0].c_str());
	}
}
```

## Point 3

这个点是最艰难的点了。

使劲找规律，先发现字符个数是 $3^{12}+11$ ，然后思考有什么规律。

除去第一个 0，每 12 个数分开，看起来好像是三进制数每次 +1 再 +2 。

往后看了看，~~什么玩意~~

经过艰苦的奋斗，最终还是没找出来，于是去膜拜的 $\color{#FFFFFF}\colorbox{#8E44AD}{\small\texttt{珂愛}}$ 的题解。感觉就是个找规律。因为是抄别人的，所以写出来也没啥意思。贴一下别人的代码。

```cpp
namespace subtask3{
	using namespace std;
	void main()
	{
		unordered_set<string>st;
		string s="000000000001",output="";
		while(1）{
			output+=s[0];
			st.insert(s);
			s+=s[0];
			s.erase(0,1);
			while(st.count(s)&&s!="000000000000"){
				++s[11];
				for(int i=11;~i&&s[i]=='3';--i){
					s[i]='0';
					if(i)++s[i-1];
				}
			}
			if(s=="000000000000")break;
		}
		cout<<0<<output<<"00000000000\n";
	}
}
```

### 代码

都在上面了。贴一下我的主函数（包括第十个点的特判）和用到的全局函数和变量。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
#include<vector>
#include<string>
#include<unordered_set>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
const int mod=104857601;
char O_[999999],*OU=O_,*OV=OU+999991,OS[21],*OT=OS;
#define F fwrite(O_,1,OU-O_,stdout)
#define O(x) (*(OU=(OU==OV?(F,O_):OU))++=(x))
void out(int x){for(;*OT++=x%10+48,x/=10;);for(;OT!=OS;O(*--OT));O(10);}
inline int fpow(int a,int b){int ans=1;for(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;return ans;}
int n;
//------------------------------------------------------------
signed main(){
	char s[10];
	scanf("%s",s);
	if(strcmp(s,"Maybe")==0) return puts("Your program should output itself here.\nSounds very difficult, yeah?\nAnyway, good luck!"),0;
	n=atoi(s);
	if(n==22)subtask1::main();
	if(n==33)subtask2::main();
	if(n==12)subtask3::main();
	if(n==531441)subtask6::main();
	if(n==131072)subtask4::main();
	if(n==262144)subtask4::main2();
	if(n==100000){
		int m=read();
		if(m==100000) subtask7::main(n,m);
		else subtask8::main();
	}else if(n==50000) subtask9::main();
	return F,0;
}
```



---

## 作者：Cute__yhb (赞：6)

做题顺序：$10-1-2-7-3-8-4-5-9-6$。

## #10

注意是传统题，所以不可能把自己源代码输出，直接输出文件即可。

应该是最简单的一个点了。

## #1

输入 $22$，输出一个字符串。

先看字符串长度，发现是 $4194304$，是 $2$ 的 $22$ 次方。

有一个很显然的思路，设一个原串，每次把这个串进行一些操作，拼到原串后。

考虑进行什么操作再拼接。

现在回到数据。

如果原串为 $0$，拼的是 $1$。

如果原串为 $01$，拼的是 $10$。

如果原串为 $0110$，拼的是 $1001$。

性质已经出现了，就是把原串取反后再拼接。

## #2

还是字符串，但输入的是 $33$。

长度是 $3524578$，网上一搜，是斐波那契的第 $33$ 项。

肯定和斐波那契数列的递推公式有关。

斐波那契数列的递推公式：$f_i=f_{i-1}+f_{i-2}$。

那这里也应该差不多，把 $f_1$ 和 $f_2$ 的初值改成字符串，加法改成拼接。

结果构造不出 $f_1$ 和 $f_2$。

斐波那契数列的递推公式还可以表示为 $f_i=f_{i-2}+f_{i-1}$。

这样很好构造。

得出 $f_1=1,f_2=01$。

递推即可。

## #7

剩下的点都不会，所以开的这个点。

输出只有 $0$ 和一个极大值。

这个输入不是数据结构就是图论。

数据结构不可能有这么离谱的输出，所以是图论。

这么说，$7,8,9$ 这三个点都是图论。

看这个输出，一眼连通性。

直接上并查集即可。

## #3

想的时间最久的点。

输入是 $12$，输出是三进制串。

第一眼的思路是把每个三进制串求出来，拼起来，结果不对。

考虑正解。

可以把输出当成输入串，进行暴力，得出性质。

尝试了很多次，性质是这个输出的字符串包含所有长度为 $12$ 的三进制串，且长度为 $3^{12}+11$。

把前几个长度为 $12$ 的串写下来，发现后一个串就是把前一个串的第一位接到最后一位，如果出现过就一直加一，直到没出现过。

## #8

输入数据有 $n$ 个点，$n-1$ 条边，是一棵树，边有边权。

输出不大，首先排除两点路径的边权和。

数也不小，不可能是路径上的最小值，所以是两点路径上的最大值。

倍增求 LCA 和 ST 表即可。

## 4

给出一个数列，回文。

观察输出，可得此序列第一项为 $1$，第二项为 $n$。

满足此性质的应该只有组合数了吧。

所以这个点直接求组合数即可。

但组合数太大了，需要取模，需要计算模数。

可以算出 $
\begin{pmatrix}
  2\\
  n\\
\end{pmatrix}
$，减去输出的数，对差做质因数分解，最大的就是模数。

得出模数 $=104857601$。

预处理阶乘，费马小定理求逆元即可。

## #5

把这个数据的输出文件对比上一个的输入文件，发现只有偶数项不一样。

用模数减去这个数据输出的偶数项，发现就是上一个的输入。

判一下奇偶性来判断是正的还是负的。

## #9 

还是图论。

这次的输出既有正常的数，又有极大值。

肯定和上一个点有关系。

上一个点是树上的两点路径上的最大值，这次应该是图上的。

而 INF 的情况就是不连通。

直接跑最小生成树 $+$ 倍增即可。

## #6

前两个点是组合数，这给点应该也是。

但这次不回文了，但还是 $n+1$ 项。

唯一能扯上关系的只有二项式定理了。

模数应该一样，难点是求二项式定理中 $a,b$ 的值。

可以直接暴力，输入输出的 $a,b$ 一样，用快速幂找一个数满足 $x^{177147}=22131490$ 且 $x^{531441}=63776689$。（取模 $104857601$ 意义下）

这个数就是 $a$。

求 $b$ 的过程同理。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
#define re register
#define ri register int
#define rll register long long
#define ld long double
#define endl '\n'
#define fi first
#define se second
#define pii pair<int,int>
#define p_q priority_queue
#define iter iterator
#define pb push_back
#define eps 1e-8
#define oper operator
#define mk make_pair
#define ls x<<1
#define rs x<<1|1
int f[100005];
bool vis[531453];
struct node{
	int x,y,z;
}edge[100005];
bool cmp(node a,node b){
	return a.z<b.z;
}
vector<pii>g[100005],b[100005];
int viss[100005];
int fa[100005][31],val[100005],sum[100005][31],deep[100005];
int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}
void dfs(int x,int faa){
	viss[x]=1;
	for(int i=1;(1<<i)<=100000;i++){
		fa[x][i]=fa[fa[x][i-1]][i-1];
		sum[x][i]=max(sum[fa[x][i-1]][i-1],sum[x][i-1]);
	}
	for(auto X:g[x]){
		if(X.fi!=faa){
			deep[X.fi]=deep[x]+1;
			fa[X.fi][0]=x;
			sum[X.fi][0]=X.se;
			dfs(X.fi,x);
		}
	}
}
ll query(int x,int y){
	if(find(x)!=find(y)) return 0x7f7f7f7f;
	if(deep[x]<deep[y]) swap(x,y);
	int ans=0;
	for(int i=20;i>=0;i--){
		if(deep[x]-(1<<i)>=deep[y]){
			ans=max(ans,sum[x][i]);
			x=fa[x][i];
		}
	}
	if(x==y) return ans;
	for(int i=20;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			ans=max(ans,max(sum[x][i],sum[y][i]));
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	ans=max(ans,sum[y][0]);
	int LCA=fa[x][0];
	return max(ans,sum[x][0]);
}
int _3_10(string s){
	int x=0;
	for(int i=0;i<s.size();i++){
		x+=(s[i]-48)*pow(3,12-i-1);
	}
	return x;
}
const ll mod=104857601;
//           104726529
//              131072
ll ksm(ll a,ll b){
	ll fac=1;
	while(b){
		if(b&1){
			fac=fac*a%mod;
		}
		a=a*a%mod;
		b>>=1;
	}
	return fac;
}
ll fac[500005];
int main(){
	string X;
//	freopen("lost8.in","r",stdin);
	cin>>X;
//	freopen("114.out","w",stdout);
	fac[0]=1;
	fac[1]=1;
	for(int i=2;i<=262144;i++){
		fac[i]=fac[i-1]*i%mod;
	}
	for(int i=1;i<=100000;i++) f[i]=i;
	if(X=="531441"){
		puts("177147");
		for(int i=0;i<=177147;i++){
			ll ans=fac[177147];
			ans=ans*ksm(fac[i],mod-2)%mod;
			ans=ans*ksm(fac[177147-i],mod-2)%mod;
			cout<<ans*ksm(23333333,177147-i)%mod*ksm(33333333,i)%mod<<endl;
		}
		
	}else if(X=="50000"){
		int x,y;
		cin>>x>>y;
		for(int i=1;i<=100000;i++){
			int z;
			cin>>x>>y>>z;
			edge[i].x=x;
			edge[i].y=y;
			edge[i].z=z;
		}
		sort(edge+1,edge+1+100000,cmp);
		for(int i=1;i<=100000;i++){
			x=edge[i].x;
			y=edge[i].y;
			int z=edge[i].z;
			int xx=find(x),yy=find(y);
			if(xx!=yy){
				f[xx]=yy;
				g[x].pb({y,z});
				g[y].pb({x,z});
			}
		}
		for(int i=1;i<=50000;i++){
			if(!viss[i]){
				dfs(i,0);
			}
		}
		for(int i=1;i<=200000;i++){
			cin>>x>>y;
			cout<<query(x,y)<<endl;
		}
	}
	else if(X=="131072"){
		puts("262144");
		for(int i=0;i<=262144;i++){
			ll ans=fac[262144];
			ans=ans*ksm(fac[i],mod-2)%mod;
			ans=ans*ksm(fac[262144-i],mod-2)%mod;
			cout<<ans<<endl;
		}
	}else if(X=="262144"){
		puts("131072");
		for(int i=0;i<=131072;i++){
			ll ans=fac[131072];
			ans=ans*ksm(fac[i],mod-2)%mod;
			ans=ans*ksm(fac[131072-i],mod-2)%mod;
			if((i)%2==1)cout<<(mod-ans)<<endl;
			else cout<<ans<<endl;
		}
	}
	else if(X=="33"){
		string f[55];
		f[1]="1";
		f[2]="01";
		for(int i=3;i<33;i++) f[i]=f[i-2]+f[i-1];
		cout<<f[32];
	}
	else if(X=="100000"){
		int x,y,z;
		cin>>x>>y;
		if(x==99999){
			for(int i=1;i<=100000;i++) f[i]=1;
			for(int i=1;i<100000;i++){
				int x,y;
				cin>>x>>y>>z;
				g[x].pb({y,z});
				g[y].pb({x,z});
			}
			dfs(1,0);
			for(int i=1;i<=200000;i++){
				int x,y;
				cin>>x>>y;
				cout<<query(x,y)<<endl;
			}
			return 0;
		}
		for(int i=1;i<=100000;i++){
			cin>>x>>y;
			f[find(x)]=find(y);
		}
		for(int i=1;i<=200000;i++){
			cin>>x>>y;
			if(find(x)==find(y)) puts("0");
			else puts("2139062143");
		}
	}
	else if(X=="22"){
		string ans="01";
		for(int i=1;i<22;i++){
			string ans1="";
			for(int j=0;j<ans.size();j++){
				if(ans[j]=='0') ans1+='1';
				else ans1+='0';
			}
			ans+=ans1;
		}
		cout<<ans;
	}
	else if(X=="12"){
		string ans="",s="000000000000";
		while(1){
			vis[_3_10(s)]=1;
			ans+=s[0];
			string t="";
			for(int i=1;i<12;i++) t+=s[i];
			t+=s[0];
			s=t;
			while(vis[_3_10(s)]){
				s[11]++;
				for(int i=11;i>0;i--){
					if(s[i]=='3'){
						s[i]='0';
						s[i-1]++;
					}
				}
				if(s[0]=='3') break;
			}
			if(s[0]=='3') break;
		}
		cout<<ans<<"00000000000";
	}
	else{
		cout<<"Your program should output itself here.\n";
		cout<<"Sounds very difficult, yeah?\n";
		cout<<"Anyway, good luck!";		
	}
    return 0;
}
```

---

## 作者：PosVII (赞：6)

**咕了八个月总算过了。把以前的屎山代码改了改，之前的题解话太多，凑合着看看吧。**

中午的机房是那样的惬意，温暖的阳光洒在地板上，照耀着菜鸡们的梦想……

同学刷到了道黑题，看着答案提交题，我啪的一下就站起来了——做啊！

### Point 1

------------

如此庞大的 $01$ 串，一看就要找规律，要不然一复制到C++就会炸掉了吧

同学说这是愤怒的小N，又说：

是 $0$，取反后拼接在后面成 $01$，然后 $0110$，因此可见规律：

$0,01,0110,01101001,0110100110010110……$

为了知道它的长度，我冒着电脑冒烟的风险把这串字符复制到了 $word$ 里面

卡了半天，知道了这串字符占了共 $4194304$ 个字符，这是 $2^{22}$

~~还好我闲的没事手算过 $2$ 的 $1$ 到 $50$ 次幂~~

同学又说这玩意是个有规律的数列（Thue-Morse [OEIS](http://oeis.org/A010060)）

看不懂，做个递推数组方法吧

```c++
int i=1;
cout<<0;
while(i<=2097152) {
	for(int j=i+1;j<=i*2;j++) {
		arr[j]=!arr[j-i];
		cout<<arr[j];
	}
	i*=2;
}
```

刚开始怕超时，没想到真的过了

### Point 2

------------

word告诉我，字符串长 $3524578$，规律是真滴看不出来

$10min$ $later……$

巨佬发现了这玩意像拼接起来的，~~话说巨佬为什么这么强啊~~

我翻了翻以前不堪入目的递推总结，发现斐波那契是唯一一个能的得到这长度的递推数列了，巨佬说它是呈 $0,1,10,101,10110$ 的数列。

字符串版斐波那契？bdfs说它叫做斐波那契字符串，呈 $a,b,ba,bab,babba$ 的规律。

字符串长度为斐波那契第33项的数
```c++
void fibo(int n) {
	if(n==1) {
		cout<<"0";
		return;
	}
	if(n==2) {
		cout<<"1";
		return;
	}
	fibo(n-2);
	fibo(n-1);
}
```

### Point 3

------------

一看就是一个3进制，但为什么每次加的都不一样呢？

看起来蛮有规律的，后面每两次加 $1$，前面 $1,2,1,2$ 的变，在最后出现 $122222222222$ 后，左边加 $1$ 进到首位，而首位刚好变成 $2$，那么继续进位，直接溢出，然后就没了。

在 $5851$ 行出现错误，这个方法是行不通的。

~~亏我还从后往前看看错了~~。

**upd on 10.5:**

发现这点的输出没有重复，仔细看错误行，发现这玩意并不是加法，而是两个完全不同的部分的并集所致的周期。

即一个三进制字符串和一个全是零的十二位字符串。

而这个三进制字符串转一圈后，取每一步的首位，共有十二个字符，便是一个周期。但有个地方需要判重，否则会输出多。

总之此点非常阴间。建议使用string实现。

### Point 4

------------

决定不在 $Point 3$ 死磕，于是看一眼 $Point 4$，~~多学数学的优势就来了~~，一眼看出回文+前两项的 $1$ 和 $n$ 就顿悟组合数。但一定有个模数，算出是 $104857601$。

打pow打爆炸了，场外直接复制下来了，就不放代码了。

### Point 5

------------

与 $Point 4$ 怎么像倒过来一样啊，但仔细对数据发现有其他不同，~~先做 Point 4 的优势就来了~~，我们复制到word发现共有 $131072$ 行，复制粘贴把 $262144$ 换成 $131072$，结果偶数位没问题，奇数位完全不一样，但我们可以发现奇数位的输出越大，out文件里的输出就越小，不难发现out文件的输出加奇数位的输出就是模数。

### Point 6

------------

数量呈三倍关系，第一个数也呈三倍关系。

后面的数字杂乱无章，看起来没有规律。

此点应该是关于数论的，是我没接触过的板块，于是bdfs“数论基础”，无果后仔细看发现它和组合数有相似之处，前面几项看起来有一点规律。于是我翻开了数学作业（初一），找到和组合数有那么一点关系的式子。

$a^n - b^n = (a-b) \times (a^{n-1} + a^{n-2}b + … + ab^{n-2} + b^{n-1})$

但很明显，右边要变成若干个单项式的和，并且左边和右边至少要和组合数有点关系。

杨辉三角呢？杨辉三角的项数是要带组合数的，如图：

$(a + b)^n = a^n \times C_1^n + a^{n-1}b \times C_2^n + … + a^2b^{n-2} \times C_{n-2}^n + a^1b^{n-1} \times C_{n-1}^n + b^n \times C_n^n$

$n$ 为 $177147$，那么第一项肯定要单独输出。

a和b直接求不出来，要不然杨辉三角是错的，要不用了模数，~~先做 Point 5 和 Point 4 的好处来了~~，只要你够懒，模数复制来，模数仍然没变。

用了模数后，我们要知道 $a$ 和 $b$ 的值就好办了（？

场内说好办，场外打暴力。

打爆搜时膜膜大佬们的题解，看到了个叫**三次剩余**的式子

不会做……所以找了个板子。

得到 $a=23333333$，$b=33333333$。

注：运气是真滴好…翻数学作业都能翻到正解。

### Point 7

------------

看出是图论什么的，但要等下周才学

自学 OIwiki 的我发现这找的是两个点是否联通，是则输出 $2139062143$（这数有什么特殊意义吗），找联通就看两点是否有共同祖先，共同则说明可以联通，~~巨佬不会做hhhhh~~。

开始RE几次，猜到是递归层数太多了，打个路径压缩就过了。

函数和代码没放一起，就不放代码了。

~~好家伙我一60分看个代码好多题解大佬~~

**upd on 10.5:**

学了，这题巨简单。

### Point 8

------------

虽然不会，但看出来是一个图，对于输入，应该是说明两点间的联通和边的权值，权值平均 $10000$，但输出平均 $100000$，所以此题应该是求和或最大值。但求和也不该这么小，所以写最大值。

学过图论的大巨佬告诉我，这玩意要用一个叫 $LCA$ 神秘算法（每一次看树上两个点的层数，层数低的就往上爬一层，直到两点重合）。

**upd on 10.5:**

那个大佬说的对，但是我不会。

**upd on 1.3:**

其输出基本与边权相同，不难发现本点是求树上路径的最大边权。

树上ST表即可。

### Point 9

------------

边数多了一条，跑 kruskal 找最小生成树再树上ST表即可。

### Point 10

------------

按他们的说法，他们是被学校OJ上的一道题引来的，据说那题的思路源于 $Point 10$，我一瞎搞，直接交out上的话，过了。

**code**

------------

```
#include<bits/stdc++.h>
using namespace std;
string txt;
set<string> st;
bool arr[5000000],flag;
int numb[20],f1[100006][20],f2[100006][20],fa[100006];
int jc[262149]={1},pl[262149]={1};
int head[100006],to[200006],val[200006],nxt[200006],dep[100006],cnt;
long long qpow(long long a,long long b,int modd) {int sum=1;a%=modd;while(b>0) {if(b%2==1)sum=(sum*a)%modd;b/=2;a=a*a;a%=modd;}return sum;}
int fin(int x) {if(x==fa[x]) return x;return fa[x]=fin(fa[x]);}
void uni(int x,int y) {x=fin(x);y=fin(y);fa[x]=y;return;}
bool pri() {bool fl=1;for(int i=1;i<=12;i++) {if(numb[i]!=0) fl=0;cout<<numb[i];}if(fl==1&&flag==0) {flag=1;fl=0;}return fl;}
void fibo(int n) {if(n==1) {cout<<"0";return;}if(n==2) {cout<<"1";return;}fibo(n-2);fibo(n-1);}
void add(int u,int v,int w) {nxt[++cnt]=head[u];head[u]=cnt;to[cnt]=v;val[cnt]=w;}
void dfs(int u,int d) {
	f1[u][0]=d;dep[u]=dep[d]+1;
	for(int i=0;i<=17;++i) {
		f1[u][i+1]=f1[f1[u][i]][i];
		f2[u][i+1]=max(f2[u][i],f2[f1[u][i]][i]);
	}
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==d) continue;
		f2[v][0]=val[i];
		dfs(v,u);
	}
}
int solve(int u,int v) {
	int res=0;
	for(int i=18;i>=0;--i) {
		if(dep[f1[u][i]]>=dep[v]) {
			res=max(res,f2[u][i]);
			u=f1[u][i];
		}
	}
	if(u!=v) {
		for(int i=18;i>=0;--i) {
			if(f1[u][i]!=f1[v][i]) {
				res=max(res,max(f2[u][i],f2[v][i]));
				u=f1[u][i],v=f1[v][i];
			}
		}
		res=max(res,max(f2[u][0],f2[v][0]));
	}
	return res;	
}
struct node{int u,v,w;}e[200006];
bool cmp(node a,node b) {return a.w<b.w;}
int main() {
// 	freopen("lost9.in","r",stdin);
//	freopen("opt.out","w",stdout);
	cin>>txt;
	if(txt=="Maybe") {
		cout<<"Your program should output itself here."<<endl;
		cout<<"Sounds very difficult, yeah?"<<endl;
		cout<<"Anyway, good luck!";
	}
	if(txt=="22") {
		int i=1;
		cout<<0;
		while(i<=2097152) {
			for(int j=i+1;j<=i*2;j++) {
				arr[j]=!arr[j-i];
				cout<<arr[j];
			}
			i*=2;
		}
	}
	if(txt=="12") {
		string str="000000000001";
		cout<<0;
		while(1) {
			st.insert(str);
			cout<<str[0];
			str=str.substr(1,11)+str[0];
			while(st.count(str)) {
				str[11]++;
				for(int i=11;str[i]>='3';i--){
					str[i]='0';
					if(i>0) str[i-1]++;
					else break;
				}
				if(str=="000000000000") goto end;
			}
		}
		end:cout<<"00000000000";
	}
	if(txt=="33") {
		fibo(33);
	}
	if(txt=="131072") {
		int n=262144;
		cout<<262144<<endl;
		for(int i=1;i<=n;i++) {
			jc[i]=1ll*jc[i-1]*i%104857601;
		}
		pl[n]=63040447;
		for(int i=n-1;i>=1;i--) {
			pl[i]=1ll*pl[i+1]*(i+1ll)%104857601;
		}
		for(int i=0;i<=n;i++) {
			cout<<jc[n]*1ll*pl[n-i]%104857601*pl[i]%104857601<<endl;
		}
	}
	if(txt=="262144") {
		int n=131072;
		cout<<131072<<endl;
		for(int i=1;i<=n;i++) {
			jc[i]=1ll*jc[i-1]*i%104857601;
		}
		pl[n]=98493902;
		for(int i=n-1;i>=1;i--) {
			pl[i]=1ll*pl[i+1]*(i+1ll)%104857601;
		}
		for(int i=0;i<=n;i++) {
			if(i%2==1)
				cout<<104857601-jc[n]*1ll*pl[n-i]%104857601*pl[i]%104857601<<endl;
			else cout<<jc[n]*1ll*pl[n-i]%104857601*pl[i]%104857601<<endl;
		}
	}
	if(txt=="531441") {
		int n=177147;
		cout<<177147<<endl;
		for(int i=1;i<=n;i++) {
			jc[i]=1ll*jc[i-1]*i%104857601;
		}
		pl[n]=72077931;
		for(int i=n-1;i>=1;i--) {
			pl[i]=1ll*pl[i+1]*(i+1ll)%104857601;
		}
		for(int i=0;i<=n;i++) {
			cout<<((1ll*qpow(23333333,n-i,104857601)*qpow(33333333,i,104857601))%104857601*1ll*(jc[n]*1ll*pl[n-i]%104857601*pl[i]%104857601))%104857601<<endl;
		}
	}
	if(txt=="100000") {
		cin>>txt;
		if(txt=="100000") {
			cin>>txt;
			int n=100000,m=200000;
			for(int i=1;i<=100000;i++) {
				fa[i]=i;
			}
			while(n--) {
				int x,y;
				cin>>x>>y;
				uni(x,y);
			}
			while(m--) {
				int x,y;
				cin>>x>>y;
				if(fin(x)!=fin(y)) {
					cout<<2139062143<<endl;
				}
				else cout<<0<<endl;
			}
		} 
		else {
			cin>>txt;
			int n=99999,m=200000,u,v,w;
			while(n--) {
				scanf("%d %d %d",&u,&v,&w);
				add(u,v,w),add(v,u,w);
			}
			dfs(1,0);
			while(m--) {
				scanf("%d %d",&u,&v);
				if(dep[u]<dep[v]) swap(u,v);
				printf("%d\n",solve(u,v));
			}
		}
	}
	if(txt=="50000") {
		cin>>txt;
		cin>>txt;
		int n=100000,m=200000;
		for(int i=1;i<=n;++i) {
			fa[i]=i;
			scanf("%d %d %d",&e[i].u,&e[i].v,&e[i].w);
		}
		sort(e+1,e+1+n,cmp);
		for(int i=1;i<=n;++i) {
			int u=fin(e[i].u),v=fin(e[i].v);
			if(u!=v) {
				fa[u]=v;
				add(e[i].u,e[i].v,e[i].w);
				add(e[i].v,e[i].u,e[i].w);
			}
		}
		for(int i=1;i<=50000;++i) {
			if(!dep[i]) {
				dfs(i,0);
			}
		}
		int u,v;
		while(m--) {
			scanf("%d %d",&u,&v);
			if(dep[u]<dep[v]) swap(u,v);
			if(fin(u)!=fin(v)) printf("%d\n",2139062143);
			else printf("%d\n",solve(u,v));
		}
	}
	return 0;
} 
/*
a=0110
b=1001
abbaba
*/
```

---

## 作者：Tiphereth_A (赞：4)

前往 [我的 Blog](https://blog.tifa-233.com/archives/luogu-p5042/#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF) 以获取更好的阅读体验。

---

这里补充关于第 3 组数据的做法。

这是 [POJ 1780](http://poj.org/problem?id=1780) 的三进制版。

这个数据点是让你构造一个序列满足：

- 其中包含所有 12 位三进制数（不足 12 位的补 0）。
- 字典序最小。

构造方法是先建图，将所有 11 位三进制数结点看作结点，若在点 `a` 前端去掉一个数并在末尾插一个数后为点 `b` 就在其中加边，之后就是从 `00000000000` 出发找 Euler 回路了，不难发现构造出来的序列长度正好为 $3^{12}+12-1=531452$。

```cpp
namespace Subtask_3 {
const int n = 12;
// 3**(n-1)
const int m = 177147;

int node[m + 1];
stack<int> s;
inline void f(int v) {
    int w;
    while (node[v] < 3) {
        s.push(w = 3 * v + node[v]++);
        v = w % m;
    }
}

// POJ 1780
void main() {
    // if (n == 1) { cout << "012\n"; return; }
    string ans;
    f(0);
    int w;
    while (!s.empty()) {
        w = s.top();
        s.pop();
        ans.push_back(w % 3 + '0');
        f(w / 3);
    }
    ans += string(n - 1, '0');
    reverse(ans.begin(), ans.end());
    cout << ans << '\n';
}
}  // namespace Subtask_3
```


---

## 作者：TemplateClass (赞：1)

### `lost1.in / lost1.out`

注意到输入 `22`，输出文件去掉那个换行符正好是 $2 ^ {22}$ 个字符。于是合理猜测前 $2 ^ n$ 个字符就是输入为 $n$ 时的答案。然后你就会发现 $n = 1$ 时答案为 $\tt 01$，然后对于 $n > 1$，答案就是 $n - 1$ 的答案再拼上 $n - 1$ 的答案的取反。

### `lost2.in / lost2.out`

注意到输出的 01 串长度为第 $33$ 个 Fibonacci 数，因此合理猜测答案的构造方式和 Fibonacci 数列一样，也就是：

$$s _ i = \begin{cases} \texttt{0} & i = 1 \\ \texttt{1} & i = 2 \\ s _ {i - 2} + s _ {i - 1} & i > 2 \end{cases}$$

输出 $s _ {33}$ 即可。

### `lost3.in / lost3.out`

前两个点都是二进制串，这个点输出只有 0、1 和 2，不难联想到三进制数。输入是 $12$，而输出的字符数比 $3 ^ {12}$ 还多了 $11$ 个字符。我们把每个数作为开头，每 12 个字符分割一下，每次把开头的放在最后就得到了下一个串。当出现重复的时候，就不断加 $1$，直到之前没出现过。

这一段的规律个人认为是整道题最难发现的。

### `lost4.in / lost4.out`

发现输入是回文的，而且从第二行开始，第一个数和最后一个数都是 $1$，第二个数和倒数第二个数都是 $n$，容易想到杨辉三角。那么第一行应该就是杨辉三角的行数。不过容易发现输出肯定是取模了，尝试几个常用的模数，发现是 $104857601$。

### `lost5.in / lost5.out`

和第 4 个点很像，但是偶数行不同。注意到第一个偶数行的数很接近模数，猜测是偶数行的数变成了相反数，确实如此。

### `lost6.in / lost6.out`

思考上一个点为啥偶数行的符号是负的，不难联想到二项式定理。于是发现这题实际上就是求用二项式定理展开的 $(a + b) ^ n$ 的每一项的值，但是 $a$ 和 $b$ 是多少？暴力可得 $a = 23333333, b = 33333333$。

### `lost7.in / lost7.out`

很像一个图论题，去掉第一行有 $3 \times 10 ^ 5$ 行，正好是 $10 ^ 5 + 2 \times 10 ^ 5$，于是猜测第一行的三个数分别是点数、边数、询问数。注意到答案只可能是 `0` 或 `2139062143`，而 `2139062143` 就是 `0x7f7f7f7f`，经常用于表示无穷大。所以答案要么是 0 要么是无穷大，很像判断连通性，写个并查集即可。

### `lost8.in / lost8.out`

发现询问的答案都是出现过的边权，容易想到查询的一定是两个点之间满足某个条件的一条边的边权，经过尝试发现是边权最大的那条边。

### `lost9.in / lost9.out`

由于 4，5，6 三个点之间的关系，我们也很容易想到这个点和 7，8 的关系。不难想到用 Kruskal 求最小瓶颈路，正好用到了 7，8 的算法。

### `lost10.in / lost10.out`

由于是传统题，全文比较，因此直接输出这三行即可。

### 代码

该代码正常编译运行需要 C++17 或以上。

[洛谷云剪贴板链接](/paste/8d3rfeux)。

---

## 作者：anke2017 (赞：1)

很像骗分过样例的题，可惜没有提示，规律估计不会很难找。

建议手写一个文件比较器，逐行比较的那种。

以下按个人认为难度顺序讲解。

## Task 10

传统题？编写程序输出自己？

因为没有 spj，所以肯定只要输出这段就行了。

## Task 7

显然是图论问题，边没有边权，答案只有 `0` 和 `0x7f7f7f7f`，容易想到是 `0` 和无穷大。

答案只有 `0` 和无穷大的，无权的图论问题，应该只有判断联通性了吧。写了个并查集，发现果然如此。

## Task 1

输入 `22`，输出 $2^{22}$ 个 $0-1$ 字符。很容易想到倍增。

~~经过一番瞪眼~~，发现第一个是 `1`，然后 $n$ 每增加 `1`，就将上一次的串**按位翻转**后复制过来，接在后面。

## Task 4

发现输入和输出大概是回文的，除了第一个表示后面数字的总数。

输入，输出在第一位和最后一位都是 `1`，在第二位和倒数第二位是 $n$。容易想到组合数。

但答案显然是取了模的，还缺少模数，估计一下是在 $10^8$ 左右，于是将第三个数算出来，可以得到模数是 $8,493,465,681$ 的倍数，对其质因数分解后得到一个可能的模数为 `104857601`，一个质数，代入是对的。

## Task 5

发现输入跟 Task 4 的输出在偶数位相同，奇数位不同。输出同理。

再瞪眼，可以发现输入的第三个数跟上一个点的模数很接近，差为 $262144$！

于是将偶数位从 `ans` 改成 `mod-ans`，直接通过。

## Task 2

输入 `33`，输出了 $\operatorname{fib}{(33)}$ 个字符。肯定跟斐波那契数列的生成有相似之处。

从前往后，发现没有什么规律，所以考虑从后往前，就发现第 $i$ 个串由第 $i-2$ 个串和第 $i-1$ 个串按顺序拼成（特别的，第一个为 $0$，第二个为 $1$），而输出由第 $n$ 个，第 $n-1$ 个到第 $1$ 个字符串拼接而成。

## Task 8

边数比点数少 `1`？

再看看输出，没有无穷大了，应该是一棵树。

然后发现输入的边权似乎是随机的，而输出在输入的边权中略大，又没有超过输入边权。猜到是路径上的边权最大值。可以用 $O(q\log^2_2{(n)})$ 的树剖加线段树，这里为了省一个 $\log$，用树剖加 ST 表维护。

## Task 9

输入的边比较多，还有无穷大，应该是一个普通的图。

答案为无穷大估计是不连通，用 Task 7 的并查集判断。

然后看到答案仍然不超过边权最大值，估计是什么神秘最小或最大。两者都可以用 Kruskal 来变成一棵树，然后用 Task 8 的代码。

经过检验，是最小化从一点到另一点的经过边权最大值。

## Task 6(by Frielen)

想不到怎么做。但是考虑到 #4 和 #5 是组合数学，这个点大概率也是组合数学。~~于是掏出高中数学课本~~发现是二项式定理。

接下来怎么办呢？既然 #4 和 #5 的模数 $p$ 都是 $104857601$，于是我们大胆猜测这个点的模数也一样。

那么，根据二项式定理，我们通过输入和输出的第一个和最后一个数可以得到 $a$ 和 $b$。大佬说求这两个数要用 BSGS，但其实用快速幂和暴力即可。

可以求得 $a=23333333,b=33333333$。代入即可。

## Task 3

输入 `12`，输出 $3^{12}+11$ 个字符，都属于 `0`，`1`，`2` 中的一种。

按 `12` 个分组后发现没有规律，于是尝试新的做法。

发现每一个长为 `12` 的子串都是按近似字典序排的。  
经过一番瞪眼（个人认为全题最难）之后，发现以下生成方法：

1. 生成过程中每次都尝试让新字符串字典序最大（但是不能跟以前的长为 `12` 的子串一样）
2. 如果当前的字符串不能继续按上述规则延长，回溯。
3. 当字符串到达 $3^{12}$ 的长度后，直接输出，然后跟着 `11` 个 `0`。

用 `set` 判重即可，常数较大，但无需卡常。

## 总代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=524288;
int frac[N+1],inv[N+1],mn=1e13,p=104857601;
int ans[N];
int qpow(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=(int)res*a%p;
        b>>=1;
        a=a*a%p;
    }
    return res;
}
inline int C(int n,int m){
	if(m==0|m==n) return 1;
	return frac[n]*inv[n-m]%p*inv[m]%p;
}
int n;
string print1(string s){
	string k="";
	for(int i=0;i<s.length();i++){
		if(s[i]=='0') k+='1';
		else k+='0';
	}
	s+=k;
	return s;
}
void print2(int now){
	if(now==1){
		cout<<"0";
		return;
	}
	if(now==2){
		cout<<"1";
		return;
	}
	print2(now-2);
	print2(now-1);
}
int cnt;
void getl(){
	char c;
	while(scanf(" %c",&c)!=EOF) cnt++;
	cout<<cnt;
}
int test7_x[100001];
inline int find(int p){
	if(test7_x[p]==p)return p;
	return test7_x[p]=find(test7_x[p]);
}
//这一坨 define 用于防止变量重名
#define fa test8_fa
#define siz test8_siz
#define son test8_son
#define tree test8_tree
#define dep test8_dep
#define top test8_top
#define num test8_num
#define id test8_id
#define tot test8_tot
#define qvan test8_qvan
#define maxn test8_maxn
#define dfs1 test8_dfs1
#define dfs2 test8_dfs2
#define num_to_id test8_num_to_id
#define e test8_e
struct st_table {
	int st[200001][25];
	int lg2[200001];
	void init()
	{
		lg2[0]=-1;
		for(int i=1;i<=200000;i++)lg2[i]=lg2[i>>1]+1;
	}
	void build_st(int mn) {
		int x=lg2[mn];
		for(int i=1; i<=x; i++) {
			for(int j=1; j<=mn-(1<<i)+1; j++) {
				st[j][i]=max(st[j][i-1],st[j+(1<<(i-1))][i-1]);
			}
		}
	}
	inline int query(int l,int r) {
		if(l>r)return 0;
		int x=lg2[r-l+1];
		return max(st[l][x],st[r-(1<<x)+1][x]);
	}
} test8_tree;

struct edge {
	int to,v;
};
//tree为接口，接线段树修改、查询
constexpr int maxn=2e5+5;
vector<edge> e[maxn];
int test8_fa[maxn];
int test8_siz[maxn];
int test8_son[maxn];
int test8_dep[maxn];
int test8_top[maxn];
int test8_num[maxn];
int test8_id[maxn];
int test8_tot;
int test8_qvan[maxn];
void num_to_id()
{
	for(int i=1; i<=tot; i++) {
		id[num[i]]=i;
	}
}
void dfs1(int now,int fa1)
{
	siz[now]=1;
	for(int i=0; i<e[now].size(); i++) {
		int x=e[now][i].to;
		if(x==fa1)continue;
		qvan[x]=e[now][i].v;
		dep[x]=dep[now]+1;
		fa[x]=now;
		dfs1(x,now);
		siz[now]+=siz[x];
		if(siz[x]>siz[son[now]])
			son[now]=x;
	}
}
void dfs2(int now)
{
	if(now==0)return;
	tot++;
	num[tot]=now;
	if(now==son[fa[now]])
		top[now]=top[fa[now]];
	else
		top[now]=now;
	dfs2(son[now]);
	for(int i=0; i<e[now].size(); i++) {
		if(e[now][i].to!=fa[now]&&e[now][i].to!=son[now])
			dfs2(e[now][i].to);
	}
}
int test8_ask_line(int x,int y)
{
	int ans=0;
	while(top[x]!=top[y]) {
		if(dep[top[x]]>dep[top[y]])
			swap(x,y);
		ans=max(ans,tree.query(id[top[y]],id[y]));
		y=fa[top[y]];
	}
	if(dep[x]>dep[y])swap(x,y);
	ans=max(ans,tree.query(id[x]+1,id[y]));
	return ans;
}
#undef fa
#undef size
#undef son
#undef tree
#undef dep
#undef top
#undef num
#undef id
#undef tot
#undef qvan
#undef maxn
#undef dfs1
#undef dfs2
#undef num_to_id
#undef e

struct edge2
{
	int st,to,val;
	bool operator <(const edge2 tmp)const
	{
		return val<tmp.val;
	}
}e2[100001];
set<string> t3_s;
string t3_now,t3_t;
signed main(){
    cin>>n;
    frac[1]=1;
	for(int i=2;i<=N;i++) frac[i]=frac[i-1]*i%p;
	for(int i=0;i<=N;i++) inv[i]=qpow(frac[i],p-2);
    if(!n){//Task 10
        cout<<"Your program should output itself here.\n";
        cout<<"Sounds very difficult, yeah?\n";
        cout<<"Anyway, good luck!";
    }
    if(n==22){//Task 1
    	string s="0";
    	for(int i=1;i<=n;i++) s=print1(s);
    	cout<<s;
	}
	if(n==33){//Task 2
		print2(n);
	}
	if(n==100000){
		int m,q;
		cin>>m>>q;
		if(m==100000){//Task 7
			for(int i=1;i<=n;i++)test7_x[i]=i;
			for(int i=1;i<=m;i++){
				int t1,t2;
				cin>>t1>>t2;
				t1=find(t1),t2=find(t2);
				test7_x[t1]=t2;
			}
			for(int i=1;i<=q;i++){
				int t1,t2;cin>>t1>>t2;
				if(find(t1)==find(t2))cout<<0<<'\n';
				else cout<<0x7f7f7f7f<<'\n';
			}
		}
		else if(m==99999)//Task 8
		{
			for(int i=1;i<=m;i++) {
				int t1,t2,t3;
				cin>>t1>>t2>>t3;
				test8_e[t1].push_back({t2,t3});
				test8_e[t2].push_back({t1,t3});
			}
			test8_dfs1(1,0);
			test8_dfs2(1);
			test8_num_to_id();
			for(int i=1; i<=n; i++) {
				test8_tree.st[test8_id[i]][0]=test8_qvan[i];
			}
			test8_tree.init();
			test8_tree.build_st(n);
			for(int i=1; i<=q; i++) {
				int t1,t2;
				cin>>t1>>t2;
				cout<<test8_ask_line(t1,t2)<<'\n';
			}
		}
	}
	if(n==50000)//Task 9
	{
		int m,q;
		cin>>m>>q;
		for(int i=1; i<=m; i++) {
			int t1,t2,t3;
			cin>>t1>>t2>>t3;
			e2[i]={t1,t2,t3};
		}
		sort(e2+1,e2+m+1);
		for(int i=1;i<=m;i++)test7_x[i]=i;
		for(int i=1;i<=m;i++)
		{
			if(find(e2[i].st)!=find(e2[i].to))
			{
				test8_e[e2[i].st].push_back({e2[i].to,e2[i].val});
				test8_e[e2[i].to].push_back({e2[i].st,e2[i].val});
				test7_x[find(e2[i].st)]=find(e2[i].to);
			}
		}
		test8_dfs1(1,0);
		test8_dfs2(1);
		test8_num_to_id();
		for(int i=1; i<=n; i++) {
			test8_tree.st[test8_id[i]][0]=test8_qvan[i];
		}
		test8_tree.init();
		test8_tree.build_st(n);
		for(int i=1; i<=q; i++) {
			int t1,t2;
			cin>>t1>>t2;
			if(find(t1)!=find(t2))cout<<0x7f7f7f7f<<'\n';
			else cout<<test8_ask_line(t1,t2)<<'\n';
		}
	}
	if(n==131072){//Task 4
		cout<<"262144\n";
		for(int i=0;i<=262144;i++) cout<<C(262144,i)<<'\n';
	}
	if(n==262144){//Task 5
		cout<<"131072\n";
		for(int i=0;i<=131072;i++){
			if(i&1) cout<<p-C(131072,i)<<'\n';
			else cout<<C(131072,i)<<'\n';
		}
	}
	if(n==531441){//Task 6
		int a=23333333,b=33333333;
		cout<<"177147\n";
		for(int i=0;i<=177147;i++) cout<<C(177147,i)*qpow(b,i)%p*qpow(a,177147-i)%p<<'\n';
	}
	if(n==12)//Task 3
	{
		t3_now+=' ';
		for(int i=1;i<n;i++)t3_now+='0';
		t3_s.insert("000000000000");
		for(int i=1,x;i<=pow(3,n)-12;i++)
		{
			for(x='0';x<='2';x++)
			{
				t3_t=t3_now.substr(i,11);
				t3_t.push_back(x);
				if(t3_s.find(t3_t)==t3_s.end())
				{
					t3_s.insert(t3_t);
					t3_now+=(char)x;
					//cerr<<t<<'\n';
					break;
				}
			}
			if(x=='3')i-=2,t3_s.erase(t3_now.substr(i,12)),t3_now.pop_back();
		}
		for(int i=1;i<n;i++)cout<<'0';
		cout<<(t3_now.c_str()+n-1);
		for(int i=1;i<n;i++)cout<<'0';
	}
    return 0;
}
```

---

## 作者：1234567890sjx (赞：1)

**Task1**

观察数据，发现输入 $22$，输出长度为 $2^{22}$。然后发现对于任何一个满足 $1\le i\le 22$ 的整数 $i$，前 $2^{i-1}$ 个字符中每一个字符 $0$ 变 $1$，$1$ 变 $0$ 就得到了后 $2^{i-1}$ 个字符。所以直接暴力模拟 $22$ 次即可。时间复杂度 $O(2^n)$。

```cpp
namespace Task1 {
    void run(int x) {
        vector<int> a = {0};
        while (x--) {
            vector<int> b = a;
            for (auto &x : b) {
                a.push_back(x ^ 1);
            }
        }
        for (auto &x : a) {
            cout << x;
        }
        cout << '\n';
    }
}
```

**Task2**

观察数据，发现输入 $33$，输出为第 $33$ 个斐波那契数。仔细观察发现除去开头和结尾的部分，把剩下的部分按照斐波那契数列来划分，得到的第 $i$ 个子串部分恰好为第 $i-2$ 和第 $i-1$ 两个子串的部分拼接得到。时间复杂度是指数级别的。

```cpp
namespace Task2 {
    string f[50];
    void run(int x) {
        f[0] = "1";
        f[1] = "10";
        cout << "0110";
        for (int i = 2; i <= 29; i++) {
            f[i] = f[i - 2] + f[i - 1];
            cout << f[i];
        }
        cout << "1\n";
    }
}
```

**Task3**

观察数据。删掉输出的第 $1$ 个字符，剩下的部分 $12$ 个字符为一节划开，特判掉最后的 $11$ 个字符，剩下的部分就从 $000000000001$ 开始，每一次把这个字符串的第一位移动到最后一位并将第一位放到答案中。若移动完之后得到的新的字符串已经出现过了，那么就让这个字符串所代表的 $3$ 进制数 $+1$。若得到的字符串全部为 $0$ 那么结束循环并处理尾部的 $11$ 个 $0$ 即可。时间复杂度是 $O(3^n)$ 的。

```cpp
namespace Task3 {
    map<string, bool> mp;
    void run(int x) {
        string res, now = "000000000001";
        while (now != "000000000000") {
            res += now[0];
            mp[now] = true;
            now.push_back(now[0]);
            string t;
            for (int i = 1; i < now.size(); i++) {
                t += now[i];
            }
            now = t;
            while (now != "000000000000" && mp[now]) {
                now[11]++;
                for (int i = 11; ~i; i--) {
                    if (now[i] == '3') {
                        now[i] = '0';
                        if (i) {
                            now[i - 1]++;
                        }
                    }
                }
            }
        }
        cout << "0" << res << "00000000000\n";
    }
}
```

**Task4**

观察数据。发现除了输出的第一行以外，每一行输出都首尾相同。所以猜测是一个组合数的形式，猜测答案为 $\binom{262144}{i}$ 对一个大质数取模。经过枚举得到大质数为 $104857601$。所以直接做即可。时间复杂度 $O(n)$。

```cpp
namespace Task4 {
    const int N = 500010, mod = 104857601;
    int fac[N], inv[N], ifac[N];
    int binom(int x, int y) {
        return fac[x] * ifac[y] % mod * ifac[x - y] % mod;
    }
    void run(int x) {
        for (int i = 0; i < 2; i++) {
            fac[i] = inv[i] = ifac[i] = 1;
        }
        for (int i = 2; i < N; i++) {
            fac[i] = fac[i - 1] * i % mod;
            inv[i] = mod - inv[mod % i] * (mod / i) % mod;
            ifac[i] = ifac[i - 1] * inv[i] % mod;
        }
        cout << x * 2 << '\n';
        for (int i = 0; i <= 262144; i++) {
            cout << binom(262144, i) << '\n';
        }
    }
}
```

**Task5**

和 `Task4` 的规律基本相同。猜测为 $\binom{131072}{i}\bmod 104857601$ 的值。但是特殊的，每一个偶数行的答案都不太一样，经过尝试发现奇数行不变，偶数行的答案为 $104857601-\binom{131072}{i}\bmod 104857601$ 即模数减去原答案。直接做时间复杂度为 $O(n)$。

```cpp
namespace Task5 {
    const int N = 500010, mod = 104857601;
    int fac[N], inv[N], ifac[N];
    int binom(int x, int y) {
        return fac[x] * ifac[y] % mod * ifac[x - y] % mod;
    }
    void run(int x) {
        for (int i = 0; i < 2; i++) {
            fac[i] = inv[i] = ifac[i] = 1;
        }
        for (int i = 2; i < N; i++) {
            fac[i] = fac[i - 1] * i % mod;
            inv[i] = mod - inv[mod % i] * (mod / i) % mod;
            ifac[i] = ifac[i - 1] * inv[i] % mod;
        }
        cout << x / 2 << '\n';
        for (int i = 0; i <= 131072; i++) {
            if (i & 1) {
                cout << mod - binom(131072, i) << '\n';
            } else {
                cout << binom(131072, i) << '\n';
            }
        }
    }
}
```

**Task6**

经过猜测发现答案应该是一个二项式定理的形式，即 $\binom{n}{i}\times x^i\times y^{n-i}\bmod 104857601$。问题在于求解 $x$ 和 $y$ 的值。考虑随便在答案中取出第一项和最后一项然后分别暴力求解，即可得到答案。时间复杂度为 $O(n\log n)$，瓶颈在于求幂次。

```cpp
namespace Task6 {
    const int N = 500010, mod = 104857601;
    int fac[N], inv[N], ifac[N];
    int binom(int x, int y) {
        return fac[x] * ifac[y] % mod * ifac[x - y] % mod;
    }
    int ksm(int a, int b, int c) {
        if (!b) {
            return 1;
        }
        int ans = ksm(a, b >> 1, c);
        ans = ans * ans % c;
        if (b & 1) {
            ans = ans * a % c;
        }
        return ans;
    }
    void run(int x) {
        for (int i = 0; i < 2; i++) {
            fac[i] = inv[i] = ifac[i] = 1;
        }
        for (int i = 2; i < N; i++) {
            fac[i] = fac[i - 1] * i % mod;
            inv[i] = mod - inv[mod % i] * (mod / i) % mod;
            ifac[i] = ifac[i - 1] * inv[i] % mod;
        }
        int n = 177147;
        cout << n << '\n';
        const int xx = 23333333, y = 33333333;
        for (int i = 0; i <= n; i++) {
            cout << ksm(xx, n - i, mod) * ksm(y, i, mod) % mod * binom(n, i) % mod << '\n';
        }
    }
}
```

**Task7**

发现输出答案只有 $0$ 和 `0x3f3f3f3f`，而输入又恰好形成了一张图。所以猜测是判断两点之间的连通性的。使用并查集维护即可。时间复杂度为 $O(\alpha n)$。

```cpp
namespace Task7 {
    const int N = 500010;
    int fa[N];
    int find(int x) {
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    }
    void run(int x, int y) {
        int n = x, m = y, k;
        cin >> k;
        for (int i = 1; i <= n; i++) {
            fa[i] = i;
        }
        while (m--) {
            int u, v;
            cin >> u >> v;
            int ta = find(u), tb = find(v);
            if (ta != tb) {
                fa[ta] = tb;
            }
        }
        while (k--) {
            int a, b;
            cin >> a >> b;
            if (find(a) != find(b)) {
                cout << 0x7f7f7f7f << '\n';
            } else {
                cout << "0\n";
            }
        }
    }
}
```

**Task8**

在 `Task7` 的基础上，满足 $m=n-1$ 即输入数据由图变成了树。然后答案也出现了一些其他的数。然后发现答案都在边权中出现过，而且相对而言都比较的大。所以猜测是静态求两点之间的最大边权。考虑使用树上倍增，边权化点权，时间复杂度为 $O(n\log n)$，常数相对较大。

```cpp
namespace Task8 {
    const int N = 200010;
    int f[20][N], g[20][N], dep[N];
    vector<pair<int, int>> z[N];
    void dfs(int u, int fa) {
        dep[u] = dep[fa] + 1;
        for (auto &[v, w] : z[u]) {
            if (v != fa) {
                f[0][v] = u, g[0][v] = w;
                dfs(v, u);
            }
        }
    }
    int lca(int u, int v) {
        if (dep[u] < dep[v]) {
            swap(u, v);
        }
        int mx = 0;
        int delta = dep[u] - dep[v];
        for (int i = 0; i < 20; i++) {
            if (delta >> i & 1) {
                mx = max(mx, g[i][u]);
                u = f[i][u];
            }
        }
        if (u == v) {
            return mx;
        }
        for (int i = 19; ~i; i--) {
            if (f[i][u] != f[i][v]) {
                mx = max({mx, g[i][u], g[i][v]});
                u = f[i][u], v = f[i][v];
            }
        }
        return max({mx, g[0][u], g[0][v]});
    }
    void run(int x, int y) {
        int n = x, m = y, k;
        cin >> k;
        while (m--) {
            int u, v, w;
            cin >> u >> v >> w;
            z[u].push_back({v, w});
            z[v].push_back({u, w});
        }
        dfs(1, 0);
        for (int i = 1; i < 20; i++) {
            for (int j = 1; j <= n; j++) {
                f[i][j] = f[i - 1][f[i - 1][j]];
                g[i][j] = max(g[i - 1][j], g[i - 1][f[i - 1][j]]);
            }
        }
        while (k--) {
            int u, v;
            cin >> u >> v;
            cout << lca(u, v) << '\n';
        }
    }
}
```

**Task9**

在 `Task8` 的基础上，树又变回了图。所以猜测要把图转化为一棵树，然后在树上找一条路径的最大边权。问题在于把图转化成树的方法。经过尝试，发现答案就是求图的最小生成树上两点之间的最大边权的值。所以 kruskal 一下树上倍增求解即可。时间复杂度 $O(n\log n+m\log m)$。

```cpp
namespace Task9 {
    const int N = 200010;
    int f[20][N], g[20][N], dep[N];
    vector<pair<int, int>> z[N];
    void dfs(int u, int fa) {
        dep[u] = dep[fa] + 1;
        for (auto &[v, w] : z[u]) {
            if (v != fa) {
                f[0][v] = u, g[0][v] = w;
                dfs(v, u);
            }
        }
    }
    int lca(int u, int v) {
        if (dep[u] < dep[v]) {
            swap(u, v);
        }
        int mx = 0;
        int delta = dep[u] - dep[v];
        for (int i = 0; i < 20; i++) {
            if (delta >> i & 1) {
                mx = max(mx, g[i][u]);
                u = f[i][u];
            }
        }
        if (u == v) {
            return mx;
        }
        for (int i = 19; ~i; i--) {
            if (f[i][u] != f[i][v]) {
                mx = max({mx, g[i][u], g[i][v]});
                u = f[i][u], v = f[i][v];
            }
        }
        return max({mx, g[0][u], g[0][v]});
    }
    struct Edg {
        int a, b, c;
        bool operator<(const Edg &r) const {
            return c < r.c;
        }
    } e[N];
    int fa[N];
    int find(int x) {
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    }
    void run(int x) {
        int n = x, m, k;
        cin >> m >> k;
        for (int i = 1; i <= n; i++) {
            fa[i] = i;
        }
        for (int i = 1; i <= m; i++) {
            cin >> e[i].a >> e[i].b >> e[i].c;
        }
        sort(e + 1, e + m + 1);
        int cnt = 0;
        for (int i = 1; i <= m; i++) {
            int ta = find(e[i].a), tb = find(e[i].b);
            if (ta != tb) {
                fa[ta] = tb;
                z[e[i].a].push_back({e[i].b, e[i].c});
                z[e[i].b].push_back({e[i].a, e[i].c});
                cnt++;
            }
        }
        dfs(1, 0);
        for (int i = 1; i < 20; i++) {
            for (int j = 1; j <= n; j++) {
                f[i][j] = f[i - 1][f[i - 1][j]];
                g[i][j] = max(g[i - 1][j], g[i - 1][f[i - 1][j]]);
            }
        }
        while (k--) {
            int u, v;
            cin >> u >> v;
            if (find(u) == find(v)) {
                cout << lca(u, v) << '\n';
            } else {
                cout << 0x7f7f7f7f << '\n';
            }
        }
    }
}
```

**Task10**

最简单的一集，因为输出量很小，所以直接输出输出内容即可。

---

## 作者：littlez_meow (赞：1)

锻炼~~打表~~找规律能力的题。

[题目指路](https://www.luogu.com.cn/problem/P5042)。

## Point 1

打开文件，输入数据只有 $12$ 一个数，而其输出文件却是一个长达 $4194304$ 位的 $01$ 串。为了找到规律，我们需要从输出大小入手。

首先，极小的输出却能产生很大的输入，说明这种构造方式的长度增长很快。有什么增长迅猛的函数？指数函数！

再看输出文件的大小，恰好是 $4096=2^{12}$ KB，猜测底数为 $2$，求对数发现正好 $2^{22}=4194304$。因此，我们构造字符串的操作应该是每次翻倍的操作。

我们看答案的若干 $2^i$ 前缀，有：

$0$

$01$

$0110$

$01101001$

$0110100110010110$

$\cdots$

我们发现，对于 $2^i$ 前缀，其由 $2^{i-1}$ 次方前缀和 $2^{i-1}$ 次方前缀取反拼接而成。

求出 $2^{22}$ 次方前缀即可。

```cpp
case 22:{
	bool ans[(1<<22)+1]={};
	ans[1]=0;
	F(i,1,22) F(j,1,1<<(i-1)) ans[(1<<(i-1))+j]=(!ans[j]);
	F(i,1,1<<22) cout<<ans[i];
	return 0;
	break;
}
```

## Point 2

输入 $33$，输出一个长为 $3524578$ 的 $01$ 串。

分解一下 $3524578$ 的质因数为 $2\times89\times19801$，发现其不是任何整数的 $33$ 次方。

这个输出的大小是 $3442$ KB，比上一个稍小。

我们需要一个同样增长迅猛，但是略逊于指数函数的东西。

斐波那契数列。

把这个数丢进[一个神奇的网站](https://zh.numberempire.com/3524578)，得到它是第 $33$ 个斐波那契数。

我们尝试一下上一题的找规律方式：看前缀。然而，无论怎么把前缀的规律往斐波那契上凑，都会出现反例。

那就换一种，把答案按斐波那契数划分成若干子串，得到：

$$0,1,10,110,10110,11010110,1011011010110\cdots$$

除了前三项，后面每个都是前两个拼接起来。

这个操作就不是简单地来 $33$ 次了。设操作 $x$ 次，则 $\sum\limits_{i=0}^x\operatorname{fib}_i=\operatorname{fib}_{33}$。又由 $\sum\limits_{i=0}^x\operatorname{fib}_i=\operatorname{fib}_{x+2}-1$，再减去前面被孤立的几项，可以求出来我们要操作 $29$ 次。

不过，有个更好用的方法，从 $33$ 开始试，直到文件大小减小至 $3442$ KB。

你兴奋地写出代码，却发现错了。为什么？

因为上面的前缀和后面有个 $-1$！如果仅操作 $29$ 次，得到的串长度为 $3524577$，和答案比较还差了一个 $1$，补上才行。

```cpp
case 33:{
	string ans="0110",fib1="1",fib2="10";
	F(i,1,28){
		fib1=fib1+fib2;
		swap(fib1,fib2);
		ans+=fib2;
	}
	cout<<ans+"1";
	break;
}
```

## Point 3

算是比较难想的一个点了。

输入是 $12$，输出是 $531452$ 位的 $012$ 串。

看着很像三进制，往上面靠一下。

开头几个非零数中间隔了 $11$ 个 $0$，但是开头的 $1$ 前面却有 $12$ 个 $0$，这非常的不和谐。

所以把开头第一个 $0$ 孤立掉，然后 $12$ 位一截，得到：

$000000000001$

$000000000002$

$000000000011$

$000000000012$

$000000000021$

$000000000022$

$000000000101$

$000000000102$

看着很像末尾非 $0$ 的三进制数数，但是看眼结尾就能否掉，开头的 $5000$ 多位后也不满足这个规律。

分析一下，这样的答案总长是 $1+3^{11}\times2\times12=4251529$，远远低于所需。

怎么办？还有什么规律没有发现？

你把答案丢进 VSCode，想着通过某种神奇的方式划分十二位子串。结果，每次选中 $12$ 位的串，都只有一处高亮。这说明每个十二位子串在答案中都仅出现了一次。

继续大胆猜想，我们猜测答案串里包含且仅包含一次所有十二位三进制数，不足十二位在前面补零。

观察输出，大部分 $0$ 在前面而 $1,2$ 在后，我们进一步猜测这个答案字典序尽量小。

这个问题就可以用贪心解决了。我们先拿一个初始串 $000000000001$，每次将它的第一位加入答案，把第一位拿到最后一位，如果已经在答案中存在就 $+1$，否则继续将第一位加入答案。重复以上过程，当前串到全 $0$（即进位进到第 $13$ 位）时结束。

但这个算法 $0$ 会越来越少，它无法处理一堆 $2$ 后面跟一堆 $0$ 的情况。好在，结尾就是一堆 $2$，手动补上 $11$ 个 $0$ 就行。

最后再加上先前孤立的那个 $0$，即可得到答案。

```cpp
case 12:{
	string ans="",str="000000000001";
	unordered_map<string,bool>qwq;
	while(true){
		ans+=str[0],qwq[str]=1;
		str.push_back(str[0]);
		str.erase(0,1);
		while(qwq[str]&&str!="000000000000"){
			++str[11];
			R(i,11,0){
				if(str[i]!='3') break;
				str[i]='0';
				i&&(++str[i-1]);
			}
		}
		if(str=="000000000000")break;
	}
	cout<<"0"<<ans<<"00000000000";
	break;
}
```

## Point 4

总算和前几个格式不一样了。

输入文件第一个数 $131072$，共 $131074$ 行。

输出文件第一个数 $262144$，共 $262146$ 行。

设第一个数为 $n$，则除去第一行还有 $n+1$ 个数。

于是猜测是某种下标为 $0-n$ 的数列。

仔细观察输入输出，发现正数第 $i$ 个和倒数第 $i$ 个一样。

再加上正数倒数第一个是 $1$，第二个是 $n$，猜测为组合数。

对第三第四个数强行求真实值再减掉答案，得到的余数分解质因数，重合了一个大质数：$104857601$

因此，第一行输出 $262144$，后面第 $i$ 行输出 $\dbinom{262144}{i-1}\bmod 104857601$ 即可。

```cpp
//MOD=104857601
case 131072:{
	cout<<(n=262144)<<"\n";
	fact[0]=inv[0]=1;
	F(i,1,n) fact[i]=fact[i-1]*1ll*i%MOD;
	inv[n]=qpow(fact[n],MOD-2);
	R(i,n-1,1) inv[i]=inv[i+1]*1ll*(i+1)%MOD;
	F(i,0,n) cout<<1ll*fact[n]*inv[i]%MOD*inv[n-i]%MOD<<"\n";
	return 0;
	break;
}
```

## Point 5

和第四个点格式很像，甚至几个数一模一样。

更准确地说，奇数行都一样，偶数行都不一样。

看第二行和模数很接近，猜测是模数减原数。

算出来的确如此。

```cpp
case 262144:{
	cout<<(n=131072)<<"\n";
	fact[0]=inv[0]=1;
	F(i,1,n) fact[i]=fact[i-1]*1ll*i%MOD;
	inv[n]=qpow(fact[n],MOD-2);
	R(i,n-1,1) inv[i]=inv[i+1]*1ll*(i+1)%MOD;
	F(i,0,n){
		int ans=1ll*fact[n]*inv[i]%MOD*inv[n-i]%MOD;
		cout<<((i&1)?MOD-ans:ans)<<"\n";
	}
	return 0;
	break;
}
```

## Point 6

格式很像，但内容不一样。

这次第一行不是 $1$，肯定不是单纯的组合数。

但既然格式相似，绝对还是能和组合数扯上关系的。

什么呢？排列数？斯特林数？卡特兰数？这道题连题面都不给，肯定不会让你猜特别复杂的。

回头看看前两个点，第四个相当于求 $[x^i](x+1)^n$，第五个相当于 $[x^i](x-1)^n$。

那就只剩二项式定理了。

设答案为 $[x^i](ax+b)^n$，则当 $i=0$ 和 $i=n$ 时可以得到两个方程：

$a^{531441}\equiv 63776689\pmod {104857601}$

$b^{531441}\equiv 91903090\pmod {104857601}$

模为质数的高次剩余方程，可以原根搭配 BSGS。不过这种没限时的，直接暴力枚举求解，求得 $a=23333333,b=33333333$，再带到输出文件可导出的两个方程验算发现没问题。

```cpp
case 531441:{
	cout<<(n=177147)<<"\n";
	int x(23333333),y(33333333);
	fact[0]=inv[0]=1;
	F(i,1,n) fact[i]=fact[i-1]*1ll*i%MOD;
	inv[n]=qpow(fact[n],MOD-2);
	R(i,n-1,1) inv[i]=inv[i+1]*1ll*(i+1)%MOD;
	F(i,0,n) cout<<qpow(x,n-i)*qpow(y,i)%MOD*fact[n]%MOD*inv[i]%MOD*inv[n-i]%MOD<<"\n";
	break;
}
```

## Point 7

又换了一个格式，是新系列的问题。

第一行三个数 $100000,100000,200000$，接下来有 $300000=100000+200000$ 行每行两个数。

凭借图论题的经验，它应该是描述一个有 $100000$ 条边的图，然后有 $200000$ 问。

答案里只有两种数：$0$ 和 $\inf=\operatorname{0x7f7f7f7f}$。这个问题只能有两种回答。再放在图上，最简单的就是连通性。

套上并查集就可解决。

由于本测试点输入的第一个数和第八个点一样，所以代码后面给出。

## Point 8

第二个数是第一个数减一，这玩意是个树。

下面描述边每行的数变成了三个，代表边有边权。

描述问题仍然是两个点。

发现答案都是边权，而且都偏大。

那就猜是两点间的最大边权。

树上倍增即可。

```cpp
void dfs(int now){
	book[now]=1;
	for(pair<int,int>i:tree[now]) if(!book[i.fir]){
		deep[i.fir]=deep[now]+1;
		fa[i.fir][0]=now;
		wei[i.fir][0]=i.sec;
		dfs(i.fir);
	}
	return;
}
inline int lca(int a,int b){
	if(dsu_find(a)!=dsu_find(b)) return 0x7f7f7f7f;
	int ans=0;
	if(deep[a]>deep[b]){a^=b;b^=a;a^=b;}
	R(i,20,0) if(deep[a]<=deep[fa[b][i]]) ans=max(ans,wei[b][i]),b=fa[b][i];
	if(a==b) return ans;
	R(i,20,0) if(fa[a][i]!=fa[b][i]) ans=max(ans,max(wei[a][i],wei[b][i])),a=fa[a][i],b=fa[b][i];
	ans=max(ans,max(wei[a][0],wei[b][0]));
	return ans;
}
case 100000:{
	cin>>m>>q;
	if(m==n-1){
		F(i,1,m){
			int u,v,w;
			cin>>u>>v>>w;
			tree[u].push_back({v,w});
			tree[v].push_back({u,w});
		}
		F(i,1,n) if(!book[i]){
			deep[i]=1;
			dfs(i);
			fa[i][0]=i;
		}
		F(i,1,20) F(j,1,n) fa[j][i]=fa[fa[j][i-1]][i-1],wei[j][i]=max(wei[j][i-1],wei[fa[j][i-1]][i-1]);
		F(i,1,q){
			int x,y;
			cin>>x>>y;
			cout<<lca(x,y)<<"\n";
		}
		return 0;
	}else{
		iota(dsu+1,dsu+n+1,1);
		F(i,1,m){
			int u,v;
			cin>>u>>v;
			dsu[dsu_find(u)]=dsu_find(v);
		}
		F(i,1,q){
			int u,v;
			cin>>u>>v;
			if(dsu_find(u)==dsu_find(v)) cout<<"0\n";
			else cout<<"2139062143\n";
		}
	}
	break;
}
```

## Point 9

输入输出格式和上一个点一样，只是不再是树。

答案里有 $\inf$ 说明可能不连通。

那就把图变成树。答案不大不小，不知道是最大生成树还是最小生成树，那就都试试，然后发现是最小生成树上路径的最大值。

当然，写 kruskal 重构树也行，不过没什么必要。

```cpp
inline void kruskal(){
	sort(gra+1,gra+m+1,[&](edge x,edge y)->bool{return x.weight<y.weight;});
	iota(dsu+1,dsu+m+1,1);
	F(i,1,m){
		int u=dsu_find(gra[i].from),v=dsu_find(gra[i].to);
		if(u!=v){
			dsu[u]=v;
			tree[gra[i].from].push_back(make_pair(gra[i].to,gra[i].weight));
			tree[gra[i].to].push_back(make_pair(gra[i].from,gra[i].weight));
		}
	}
	return;
}
case 50000:{
	cin>>m>>q;
	F(i,1,m) cin>>gra[i].from>>gra[i].to>>gra[i].weight;
	kruskal();
	F(i,1,n) if(!book[i]){
		deep[i]=1;
		dfs(i);
		fa[i][0]=i;
	}
	F(i,1,20) F(j,1,n) fa[j][i]=fa[fa[j][i-1]][i-1],wei[j][i]=max(wei[j][i-1],wei[fa[j][i-1]][i-1]);
	F(i,1,q){
		int x,y;
		cin>>x>>y;
		cout<<lca(x,y)<<"\n";
	}
	return 0;
	break;
}
```

## Point 10

输入输出是一段文本，说是要代码输出自己。

但是，看看题面里没什么用的重要信息：

> 这道题是传统题，采用全文比较的方式。

这说明我们只用输出这段话就行。

```cpp
default:{
	cout<<"Your program should output itself here.\n";
	cout<<"Sounds very difficult, yeah?\n";
	cout<<"Anyway, good luck!";
	return 0;
	break;
}
```

完结撒花 qwq~

---


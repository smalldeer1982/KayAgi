# zhtobu3232的线段树

## 题目背景

$zhtobu3232$发现了一道线段树题,在$30s$后$zhtobu3232$敲出了一份线段树并且ac了这题

当然，这是$zhtobu3232$刚刚学oi时候的事情了，现在的他只需$1s$就可以敲出一份完美的线段树板子

现在$ztb$想要重温一下他之前切过的水题,不过他的笔记本电脑年代有些久远，导致内存条损坏了很多，从而线段树也开始损坏了，现在他不关心当年敲了什么水题而只关心这个线段树可以表示出多少合法的区间，请你计算出这个数字并对$998244353$取模

顺便说一句$ztb$认为这个问题比线段树简单多了，因为线段树的节点少了,所以维护的信息也少了，他已经用$1ms$敲好了$std$,接下来就等着你帮他验题了



## 题目描述

我们定义一颗长度为n的线段树是这样的算法流程执行build(0,n)后建出的二叉树

(注意这里的线段树应该和大家平常写的没什么区别(除了区间是左开右闭表示的以外)，会线段树的可以忽略)

```C

node build (l,r)
{
	node p=newnode();p.l=l+1;p.r=r;
    if(r-l==1)return p;
    mid=(l+r)/2;
    node.leftson=build(l,mid);
	node.rightson=build(mid,r);
    return p;
}

```

而我们定义一个区间$(l,r)$在线段树上的**拆分**是将这个区间表示为线段树上若干个节点的集合，满足这些节点对应的区间不相交,不嵌套,这些区间的并集恰好是$(l,r)$，并且没有两个节点是兄弟关系

拆分的伪代码如下

```C
void solve(l,r,dl,dr)
{
	if(dl==l&&dr==r){S.push(node(l+1,r));return;}
	 mid=(l+r)/2;
    if(dl<mid)solve(l,mid,dl,min(dr,mid));
    if(mid<dr)solve(mid,r,max(dl,mid),dr);
}

```
当我们执行完$solve(0,n,l-1,r)$之后得到的S集合就是区间$(l,r)$在$(1,n)$这颗线段树上的**拆分**了

(换句话说就是你平时写线段树时将一个区间拆成$O(logn)$个区间的操作)

现在我们给出了m个区间$(l,r)$，这些区间在线段树$(1,n)$上拆分出来的节点都是非法节点，换句话说这些节点都不可以使用了

现在请你计算有多少个区间$(l,r)$是合法的，满足两个限制条件

第一：$1 \leq l \leq r \leq n$


第二：这个区间在线段树$(1,n)$上的拆分不含有非法的节点

答案对998244353取模


## 说明/提示

1,2,3,4,5,6,7测试点的分数全部为1分

对于测试点1,2

$$n \leq 1000,m\leq 100$$

对于测试点3,4

$$n \leq 100000,m \leq 5000$$

对于测试点5,6,7

$$n \leq 10^7,m \leq 10^5$$

对于所有数据

$$1 \leq n \leq 10^{14}$$

$$1 \leq m \leq 10^5$$

$$1 \leq l \leq r \leq n$$

## 样例 #1

### 输入

```
20 5
11 12
14 20
6 12
8 13
10 19
```

### 输出

```
67```

# 题解

## 作者：mrsrz (赞：3)

~~这线段树的写法不怎么优美啊QAQ~~

以下讨论都是按照题目上的左开右闭线段树来的。

线段树上分治。

首先按照题意模拟，把该删的节点都打上删除标记。动态开点，时间复杂度$O(m\log n)$。

然后在线段树上分治。

令$pre[x]$表示节点$x$表示的区间$(l,r]$中，有多少个$i$使得区间$(l,i]$满足条件。

$suf[x]$表示节点$x$表示的区间$(l,r]$中，有多少个$i$使得区间$(i,r]$满足条件。

$ls[x],rs[x]$分别表示节点$x$的左、右儿子。

按顺序访问每个节点$x$，先考虑如下特殊情况。

1. 若该节点是叶子，且没被删除，则$pre[x]=suf[x]=1$，答案加1。
2. 若该节点是叶子，且被删除了，则$pre[x]=suf[x]=0$，答案减1。
3. 若该节点没被开辟，则节点内的区间任选，答案加$\frac{(r-l+1)(r-l)}{2}$，$pre[x]=suf[x]=r-l$。

对于一般情况，该区间内的贡献就是$pre[ls[x]]\times suf[rs[x]]$。

还有一些特殊情况：

1. 若$x$被删除且$ls[x],rs[x]$均未被删除，则统计答案的时候，$(l,r]$被统计进去了，实际应该不符合条件，因此答案要减1。
2. 若$x$没被删除且$ls[x],rs[x]$中有节点被删除，则统计答案的时候，$(l,r]$没被统计，实际是符合条件的，因此答案要加1。

接下来计算节点$x$的$pre$和$suf$，这里只考虑$pre$。

$ls[x]$的$pre[ls[x]]$个区间一定是可行的。

$rs[x]$的$pre[rs[x]$个区间可行，必须满足$ls[x]$没被删除（因为要补上区间$(l,mid]$）。

若$ls[x]$和$rs[x]$均未被删除，则$(l,r]$区间被计算进去了，先减去这个区间的1。

再单独考虑$x$是否被删除，看是否要加上$(l,r]$区间即可。

于是就有了代码注释中的那个转移。

$suf$则反过来同样方法考虑即可。

这部分的时间复杂度也是$O(m\log n)$的，所以总时间复杂度$O(m\log n)$。

线段树空间开大点即可。

## Code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using std::min;using std::max;
typedef long long LL;
const int md=998244353,N=201*100000;
int ls[N],rs[N],rt;
bool del[N];
LL n;int pre[N],suf[N];int m,node=0,ans=0;
//pre每个节点前缀可行区间个数，suf后缀 
void split(int&o,LL l,LL r,const LL&L,const LL&R){
    if(!o)o=++node;
    if(L==l&&r==R)del[o]=1;else{
        const LL mid=l+r>>1;
        if(L<mid)split(ls[o],l,mid,L,min(R,mid));
        if(mid<R)split(rs[o],mid,r,max(L,mid),R);
    }
}
inline int CC(LL x){return(x*(x+1)>>1)%md;}
inline void upd(int&x){x+=x>>31&md;}
void query(int&o,LL l,LL r){
    if(l+1==r){//底层 
        ans+=(suf[o]=pre[o]=!del[o]);
        if(ans>=md)ans-=md;
        return;
    }
    if(!o){//没被访问 
        o=++node;
        pre[o]=suf[o]=(r-l)%md;
        upd(ans+=CC((r-l)%md)-md);
        return;
    }
    const LL mid=l+r>>1;
    query(ls[o],l,mid);
    query(rs[o],mid,r);
    upd(ans+=1LL*suf[ls[o]]*pre[rs[o]]%md-md);
    if(del[o]&&!del[ls[o]]&&!del[rs[o]])upd(--ans);//自己被删除，两个儿子没被删除
    if(!del[o]&&(del[ls[o]]||del[rs[o]]))upd(ans=ans+1-md);//自己没被删除，两个儿子至少一个被删除 
    upd(pre[o]=(pre[ls[o]]+!del[o]+(!del[ls[o]])*(pre[rs[o]]-!del[rs[o]]))-md);//前缀=左边的前缀+[整个节点是否可行]+[左边整个节点是否可行]*(右边的前缀-[右边整个节点是否可行]) 
    upd(suf[o]=(suf[rs[o]]+!del[o]+(!del[rs[o]])*(suf[ls[o]]-!del[ls[o]]))-md);//同理 
}
int main(){
    scanf("%lld%d",&n,&m);
    while(m--){
        LL l,r;
        scanf("%lld%lld",&l,&r);
        split(rt,0,n,l-1,r);
    }
    query(rt,0,n);
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：caeious (赞：3)

吐槽该题的部分分（幸好是IOI(ACM)赛制。。）   
### 2pts
前两个点暴力所有满足$1 \leq l \leq r \leq n$的区间即可。  
### 4pts
在2分的暴力中，枚举是比标记损坏点耗时间的，所以我们想办法用一个类似Treedp的东西一次算出答案。记$cnt[u]$为节点$u$对应子树中有多少合法区间，那么有  
$cnt[u] = cnt[lson] + cnt[rson]\ +$ (跨过两个儿子的区间个数）  
为了计算后者，需要再维护两个变量$pre[u]$, $nxt[u]$,表示节点u的区间中**紧贴左边**的区间数目(即**前缀**)和**紧贴右边**的区间数目(**后缀**)。这样是不是随口报出了转移方程？  
```cpp
// del[u]表示节点u被损坏
pre[u] = pre[lc] + del[lc] ? 0 : pre[rc]
suf[u] = suf[rc] + del[rc] ? 0 : suf[lc]
```
但是有情况需要特殊考虑：如果左，右儿子有至少一个坏了而u没坏，则区间$[u.l,u.r]$可以选择；如果左右儿子都没坏而u坏了，则区间$[u.l,u.r]$不可以选择，所以有
```cpp
if(!dell && !delr && dat[id].del) pre[id]--;
if((dell || delr) && !dat[id].del) pre[id]++;
```
suf同理即可。  
显然，跨过两个儿子的区间个数 = $pre[rson] \times suf[lson]$,但同样有时会多算$\pm 1$,所以又有
```cpp
if(!dell && !delr && dat[id].del) ans = (ans + mod - 1) % mod;
if((dell || delr) && !dat[id].del) ans = (ans + 1) % mod;
```
于是我们就可以再O(size_of_segment_tree)时间内算出答案。

### 7pts
暴力的做法是在范围为$[1,n]$的线段树上标记点，但此时n已经大到建不出完整的线段树了！观察到m却很小，所以可以动态开点。样例的树长这样（蓝色部分是被标记del的点）：
![样例](https://cdn.luogu.com.cn/upload/pic/61409.png)
没错，它真的是一颗 **线段** 树！  
对于树上每一个点，若其没有左儿子则 $pre[lson] = suf[lson]$ = lson区间的长度, 并认为左儿子没坏；没有右儿子同理；两个儿子都没有（leaf）则 $pre[u] = suf[u] = u.r - u.l$,$cnt[u] = {u.r - u.l + 1 \choose 2}$。
这样dp，我们就能在$4 \log n \times m$时间里解决问题了。

### 100pts
那么为什么全谷最弱的我用上面的方法写的只有7pts呢？
要想拿到100分，你需要上面的算法，还要注意：  
1. l,r要开longlong.
2. 乘法应形如 (a % mod * (b % mod)) % mod;
3. 计算C(a,2)时，应将a与a-1中的偶数除以2，再按上面方法乘，**千万不要先模再除！！！**
4. 线段树的节点个数要开到$10^7$,否则你可能得到TLE而不是RE（像我一样。。。看着TLE不知所措地卡常） 
5. 其他注意事项见注释

### Code
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
#include <vector>
#include <utility>
#define maxV 10000005

using namespace std;
typedef long long ll;
typedef pair<int,int> P;
const ll mod = 998244353;

ll getll(){
  char c; ll res = 0;
  for(c = getchar();c < '0' || c > '9';c = getchar());
  for(;c >= '0' && c <= '9';c = getchar()) res = res * 10 + (c - '0');
  return res;
}

struct node{
	ll l,r;
  int lc,rc;
  bool del;
	node(){
		l = r = del = 0;
		lc = rc = -1;
	}
}dat[maxV]; int V;
// 由于本人习惯，这里将左开右闭的区间转化成了闭区间。
// 较之普通的闭区间写法，唯一的不同就是第38行mid应偏左而不是偏右。

ll n;
void build(int id,ll ql,ll qr){// 加入一个坏区间[ql,qr].
	ll l = dat[id].l, r = dat[id].r;
	if(ql <= l && r <= qr){
		dat[id].del = true;
		return;
	}
	ll mid = (dat[id].l + dat[id].r - 1) >> 1;
	if(ql <= mid){
		if(dat[id].lc == -1){
			dat[id].lc = ++V;
			dat[V].l = l;
			dat[V].r = mid;
		}
		build(dat[id].lc,ql,qr);
	}
	if(mid < qr){
		if(dat[id].rc == -1){
			dat[id].rc = ++V;
			dat[V].l = mid + 1;
			dat[V].r = r;
		}
		build(dat[id].rc,ql,qr);
	}
}
ll pre[maxV],suf[maxV];
// pre[u], suf[u]意义见题解
ll calc(ll len){//这里计算len * (len + 1) / 2的值，注意到len可达10^14。
	if(len & 1) return (len % mod) * (((len + 1) >> 1) % mod) % mod;
	else return ((len >> 1) % mod) * ((len + 1) % mod) % mod;
}
ll dfs(int id){//跑treedp
	ll l = dat[id].l, r = dat[id].r;
	if(dat[id].lc == -1 && dat[id].rc == -1){
	  //必有dat[id].del = true.
		pre[id] = r - l;
		suf[id] = r - l;
		return (calc(r - l + 1) + mod - 1) % mod;
	}
	ll ans = 0,rpre = 0,rsuf = 0,lpre = 0,lsuf = 0;//字面意思
	bool dell, delr;
	int lc = dat[id].lc, rc = dat[id].rc;
	if(lc > 0){
		ans = (ans + dfs(lc)) % mod;
		lpre = pre[lc];
		lsuf = suf[lc];
		dell = dat[lc].del;
	}else{
		ans = (ans + calc(dat[rc].l - l)) % mod;
		lpre = lsuf = dat[rc].l - l;
		dell = false;
	}
	if(rc > 0){
		ans = (ans + dfs(rc)) % mod;
		rpre = pre[rc];
		rsuf = suf[rc];
		delr = dat[rc].del;
	}else{
		ans = (ans + calc(r - dat[lc].r)) % mod;
		rpre = rsuf = r - dat[lc].r;
		delr = false;
	}
	//转移ans，pre，suf，注意调整。
	(ans += (lsuf % mod) * (rpre % mod)) %= mod;
	if(dell) pre[id] = lpre;
	else pre[id] = lpre + rpre;
	if(delr) suf[id] = rsuf;
	else suf[id] = rsuf + lsuf;
	
	if(!dell && !delr && dat[id].del){
    pre[id]--, suf[id]--;
    (ans += mod - 1) %= mod;
  }
	if((dell || delr) && !dat[id].del){
	  pre[id]++, suf[id]++;
    (ans += 1) %= mod;
	}
	return ans;
}
int main(){
	int m;
	n = getll(), m = (int)getll();
	dat[++V].l = 1, dat[V].r = n;
	while(m--){
		ll l,r;//(l,r].
		l = getll(), r = getll();
		build(1,l,r);
	}
	printf("%lld\n",dfs(1));
	return 0;
}

```

---


# 好时光

## 题目背景

# 如果您不想在读题上消耗太多时间，请直接滑到页面最底部查看简述版题面。

光阴似箭，日月如梭。时光如流水般，一刻不停地冲刷着一切。转眼间，初三已经到来了。巨量的作业，紧张的考试，无不使小L和小K准备NOIP的时间越来越少……

## 题目描述

逃不掉的一天还是来了，小L一个人坐在教室里，看着窗外发呆。

操场还没修完，天上空空荡荡的，夕阳的余晖刚刚在灰色的高楼旁涂上一抹血红，瞬间便消失了，不留下一点痕迹。飒飒的秋风从窗外吹进来，教室里响起了哗啦啦的书页被翻动的声音，书被翻到了画上了小L和小K共同的涂鸦的那一页。被揉成一团的成绩条在桌上滚来滚去，像难解的心结。天上没有一颗星星——大概是因为心头吹不散的乌云吧。

小L的文化课月考考炸了，NOIP初赛也极度不理想，很可能是进不了复赛了。

至于心头吹不散的乌云，就让它在那里吧，反正自己也没有机会去改变什么了。

如果不是初三的紧张的节奏，大家大概不会这么轻易地分道扬镳吧？ 只见一个又一个昔日的队友离开了机房。

唉，自己也大概要离开机房了吧。小L想到。

这时，他想起了与小K相处的每一个好时光。

从初一的军训中一个个挺拔的身影，到讲台前两个激烈讨论着的声音,省赛时颓废的场景，以及一起在机房奋斗过的日日夜夜……

忆起这些好时光，他的心里暖暖的。他觉得和小K在一起的每一秒都是值得珍惜的好时光。

这时，小K来到了小L的身边，知道了小L的愿望。小L想对他与小K相处的每一秒计算一个值得珍惜的价值，如果把这些价值都加起来，小L就会将这些好时光都记在心里，心情也会好起来了。

小L是这样计算一个时间的价值的：他先将每一秒从 $1$ 开始顺序编号，再将时间（这个秒数）转换为时-分-秒形式。由于某种原因，小L的一分钟只有 $k$ 秒（此处应有滑稽），所以小L认为一小时也只有 $k$ 分钟。你可以认为小L将秒数转成了$k$ 进制。由于小L没有那么毒瘤，所以这里的 $k$ 都是整数。然后他观察这个 $k$ 进制数，找到其中最长的连续等差数列的长度（只考虑单个数码组成的连续的区间的情况，也就是说如 $10$ 进制下的 $123456789101112$ 不能称为等差数列） ，将其记为这一秒的价值。

小K非常想帮他算出这些秒（从 $1$ 秒到 $n$ 秒）的总价值，以安慰伤心的小L。但是这个总秒数 $n$ 实在是太长太长了，以至于小K要超过一秒的时间才能算出一秒的价值，这样小L和小K在一起的时间就可以**无限延长**了。小L非常希望能这样，但是显然他们并没有这么多这么多的时间。

小K找到了精通 $OI$ 的你。为了避免计算过程中秒数还在增加，你需要在 $1$ 秒钟内计算出答案。由于答案可能会很大，小L愿意接受这个数取模 $19260821$ 后的结果。

## 说明/提示

样例 $\#1$ 解释：

$1$到$5$转成$3$进制分别是$1,2,10,11,12$，每个数的价值恰好是它的长度，所以总价值为$1+1+2+2+2=8$。

对于 $10\%$ 的数据， $1\le n\le 10^6,k=60$；

对于另外 $10\%$ 的数据， $k=10$；

对于 $40\%$ 的数据， $2\le k\le 20,1\le n\le k^{10}$； 

对于 $100\%$  的数据， $2\le k\le 60,1\le n\le k^{18}$ 。

** 数据没有梯度！！！ **

# 小L教你学数学

**等差数列**：等差数列是指从第二项起，每一项与它的前一项的差等于同一个常数的一种数列，这个常数叫做等差数列的公差。 ** 公差可以为任意实数。 ** 也就是说，这个数列可以是递增的，递减的，或者恒为定值的（公差为$0$）。

## 简述版题面：

给出 $n,k$ ， 求 $\sum_{i=1}^n f(i,k)$ 的值， $f(i,k)$ 定义为将十进制整数 $i$ 表示为 $k$ 进制时写成一个数列的形式中的最长连续子串为等差数列的长度。答案取模 $19260821$ 。

## 一些闲话

由于小L被赶去学文化课了，所以本题题面的扩写就咕咕咕啦！

## 样例 #1

### 输入

```
5 3```

### 输出

```
8```

## 样例 #2

### 输入

```
99 10```

### 输出

```
189```

## 样例 #3

### 输入

```
377377377377 60```

### 输出

```
139733```

# 题解

## 作者：hsfzLZH1 (赞：5)

## 题目大意

给出 $n,k$ ， 求 $\sum_{i=1}^n f(i,k)$ 的值， $f(i,k)$ 定义为将十进制整数 $i$ 表示为 $k$ 进制时写成一个数列的形式中的最长子串为等差数列的长度。答案取模 $19260821$ 。

## 10pts $1≤n≤10^6,k=60$

枚举 $1...n$ 的所有值。对于每个数，用 $O(\log_{k}n)$ 的时间复杂度将这个整数分解为 $k$ 进制数。然后，计算出它的最长连续等差数列的长度。如何计算最长子串为等差数列的长度呢？

首先，如果这个 $k$ 进制数的长度大于二，那么答案至少为二（因为任意两个整数都可以组成合法的长度为二的等差数列），我们考虑使用 $O(\log_k n)$ 的时间复杂度的方法求解本问题。从前到后扫一遍，如果这一项减上一项的值等于上一项减上上一项的值，那么根据等差数列的定义，其仍然能成为一个等差数列，长度为原来加一。如果不等于，那么就要找到一个新的等差数列，不妨设这个新的等差数列的前两项就为当前项和上一项，这样就能求出最优解。时间复杂度为 $O(k\times \log_kn)$ 。

## 10pts $k=10$

观察到 $k$ 的值比较小，所以可能的等差数列有两种情况：

1.等差数列的公差为 $0$ ，可以 $O(\log_{k}n)$ 预处理；

2.等差数列的公差不为 $0$ ，这时等差数列的长度最多为 $k$ ，然后……出题人自己也不会做了。

## 40pts $2\le k\le 20,0\le l\le r\le k^{10}$

得到这 $40$ 分的同学大部分可能都使用的是数位DP，可能是递推式不够完美，存储了冗余信息，没有最优化记忆化等问题，没有得到满分。

## 100pts

** 数位DP ** 。这题的形式就是数位DP的标准形式，而且非常直白，甚至连差分的套路都没有了。

考虑在转移的过程中计算 $5$ 个参数，当前计算剩余的位数 $x$ ， 已知的前缀的最长等差数列的长度记为 $lgt$ ，以当前计算的值为结尾的最长等差数列的长度记为 $nww$ ，上一位的值 $ls$ ，上上一位的值 $lls$ 。在转移的过程中，利用在第一个得分点得出的结论，利用递推的形式判断能否形成更长的等差数列，并更新 $nww$ 和 $lgt$ 的取值。由于上面几个参数的渐进多项式分别为 $O(\log_k n)$ ， $O(\log_k n)$ ，$O(\log_k n)$ ，$O(k)$ ，$O(k)$ ，所以最后的时间复杂度是 $O(k^2\log_{k}^3 n)$ 。空间复杂度也相同。正好能卡在空间限制和时间限制内。

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const int maxk=61;
const int maxn=19;
const int maxl=110;
typedef long long ll;
const int mod=19260821;
ll k,l,n[maxl],r;
int f[maxn][maxn][maxn][maxk][maxk];
char s[maxl];
inline void upd(int&x,int v){x+=v;while(x>=mod)x-=mod;}
vector<int>dim;
int dfs(int x,int lgt,int nww,int lls,int ls,bool op)
{
    if(!x)return max(lgt,nww);
    if(!op&&~f[x][lgt][nww][lls][ls])return f[x][lgt][nww][lls][ls];
    int maxx=op?dim[x]:(k-1),ret=0;
    for(int i=0;i<=maxx;i++)
    {
        if(lls==k&&ls==k)
        {
            if(i)upd(ret,dfs(x-1,1,1,k,i,op&(i==maxx)));
            else upd(ret,dfs(x-1,0,0,k,k,op&(i==maxx)));
        }
        else if(lls==k)upd(ret,dfs(x-1,2,2,ls,i,op&(i==maxx)));
        else if(ls-lls==i-ls)upd(ret,dfs(x-1,max(lgt,nww+1),nww+1,ls,i,op&(i==maxx)));
        else upd(ret,dfs(x-1,lgt,2,ls,i,op&(i==maxx)));
    }
    return f[x][lgt][nww][lls][ls]=ret;
}
int main()
{
    memset(f,-1,sizeof f);
    scanf("%s%lld",s,&k);
    l=strlen(s);
    for(int i=0;i<l;i++)n[i]=s[l-i-1]-'0';
    dim.push_back(-1);
    while(l)
    {
    	r=0;
    	for(int i=l-1;i>=0;i--)
    	{
    		int t=r;
    		r=(r*10+n[i])%k;
    		n[i]=(t*10+n[i])/k;
        }
        while(l&&!n[l-1])l--;
        dim.push_back(r);
    }
    printf("%d\n",dfs(dim.size()-1,0,0,k,k,true));
    return 0;
}
``` 

## 闲言碎语

### 19260821不是质数

$19260821=23\times 193\times 4339$


---

## 作者：樱雪喵 (赞：2)

先把 $n$ 转成 $k$ 进制，题意就是求 $k$ 进制下所有小于 $n$ 的数最长的等差区间的长度之和。

考虑数位 dp。

首先常规地记录 $pos$ 表示当前 dp 到第几位，$limit$ 表示是否要卡上界。  
然后记录我们要求的答案（最长等差长度）为 $mx$，以当前位为结尾的等差数列长为 $len$。  
为了判断是不是等差，我们要知道上一位和公差是什么。公差有负数不好塞进状态，改为记录前面两位的值分别是 $fi,se$。

转移的时候枚举这一位填 $i$，有
$$
f_{pos,len,fi,se,mx,limit}\to f_{pos-1,len+1,se,i,\max(mx,len+1),limit\ \&\ i=a_{pos}} (i=se+(se-fi))
$$
$$
f_{pos,len,fi,se,mx,limit}\to f_{pos-1,2,se,i,mx,limit\ \&\ i=a_{pos}} (i\neq se+(se-fi))
$$

吐槽一下卡空间和这个神秘模数，记忆化的时候只记录 $limit=0$ 的部分，不然会 MLE。

```cpp
const int N=19,M=62,L=1005;
const int inf=M-1;
const int mod=19260821;
char s[L];
int a[N],k;
int f[N][N][M][M][N];
il void add(int &x,int y) {x+=y;if(x>=mod) x-=mod;}
int dfs(int pos,int len,int fi,int se,int mx,bool limit)
{
    assert(fi>=0);
    if(!pos) return mx;
    if(!limit&&f[pos][len][fi][se][mx]!=-1) return f[pos][len][fi][se][mx];
    int res=0,Mx=limit?a[pos]:k-1;
    for(int i=0;i<=Mx;i++)
    {
        if(fi==inf) add(res,dfs(pos-1,i>0,i?i:inf,inf,i>0,limit&(i==Mx)));
        else if(se==inf) add(res,dfs(pos-1,2,fi,i,2,limit&(i==Mx)));
        else
        {
            if(se+(se-fi)==i) add(res,dfs(pos-1,len+1,se,i,max(mx,len+1),limit&(i==Mx)));
            else add(res,dfs(pos-1,2,se,i,mx,limit&(i==Mx)));
        }
    }
    if(!limit) f[pos][len][fi][se][mx]=res;
    return res;
}
int main()
{
    scanf("%s",s+1); k=read();
    int n=strlen(s+1); reverse(s+1,s+n+1);
    for(int i=n;i;i--)
    {
        for(int j=1;j<N;j++) a[j]*=10;
        a[1]+=s[i]-'0';
        for(int j=1;j<N-1;j++) a[j+1]+=a[j]/k,a[j]%=k;
    }
    memset(f,-1,sizeof(f));
    int m=N-1;
    while(!a[m]) m--;
    int res=dfs(m,0,inf,inf,0,1);
    printf("%d\n",res);
    return 0;
}
```

---


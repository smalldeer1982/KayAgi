# WD与数列

## 题目背景

WD整日沉浸在数列中，无法自拔……

## 题目描述

WD很喜欢数列。他认为两个序列$A,B$是匹配的，当且仅当$|A|=|B|$且对于$1\le i,j\le |A|,A_i-B_i=A_j-B_j$.即长度相同且一个数列同时加上一个数可以和另一个数列完全一样。

现在CX给了他一个长度为$n$的大数列，WD希望知道，数列中有多少对不相交的子串使得他们是匹配的。

## 说明/提示

对于样例，任意两个不相交且长度相等的子串都是匹配的，长度为1时有10种，长度为2时有3种，因此总共有13种。

$subtask1(11pts):~1\le n\le 100$

$subtask2(34pts):~1\le n\le 1,000$

$subtask3(55pts):~1\le n\le 300,000$

对于所有数据，数列中数字的**绝对值**$\le 10^9$。$subtask3$的时限为3s，其它为1s.

## 样例 #1

### 输入

```
5
1 2 3 4 5```

### 输出

```
13```

## 样例 #2

### 输入

```
10
1 0 -1 -1 -2 -2 -3 -3 -4 -5```

### 输出

```
65```

# 题解

## 作者：panyf (赞：8)

首先计算长度为 $1$ 的贡献即为 $\dfrac{n(n-1)}{2}$。

然后将数组差分，然后离散化。

所求变为求有多少对相同的子串，满足间隔至少为 $1$。

也就是求 $\sum_{i<j}\min(lcp(i,j),j-i-1)$。

$\sum_{i<j}lcp(i,j)$ 可以用后缀数组 + 单调栈/并查集求出，见 [P4248 [AHOI2013]差异](https://www.luogu.com.cn/problem/P4248)。

现在只需要减去多算的部分，就是对于所有 $lcp(i,j)>j-i-1$ 的 $(i,j)$，求出 $\sum lcp(i,j)-(j-i-1)$。

枚举 $len=j-i$，则需要减去所有 $lcp(i,j)\geq len$ 的 $(i,j)$ 多算的部分。

考虑 [P1117 [NOI2016] 优秀的拆分](https://www.luogu.com.cn/problem/P1117) 一题中设置关键点的做法，将所有编号为 $len$ 的倍数的点作为关键点。

对于关键点 $k$ 和 $k+len$，统计 $i\in[k-len+1,k]$ 的答案。

这样统计不到 $i$ 在倒数第二个关键点以后的答案，不过容易发现这些位置的 lcp 一定小于 $len$。

求出 $s=lcs(k,k+len)$，则只有 $i\in[k-\min(len,s)+1,k]$ 的部分需要统计，$k+len\leq i<k-s+1$ 时 lcp 一定小于 $len$。

再求出 $lcp(k,k+len)$，发现所求是一个等差数列求和，这道题就做完了。

时空复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+3;
unordered_map<int,int>mp;
int n,lg[N],s[N];
long long ans,w;
struct SA{
int u[N],v[N],sa[N],t[N],st[23][N],*rk=u,*b=v;
void in(){
	int i,j,x,y,m=n,k=0;
	for(i=1;i<=n;++i)++t[s[i]];
	for(i=1;i<=m;++i)t[i]+=t[i-1];
	for(i=n;i;--i)sa[t[rk[i]=s[i]]--]=i;
	for(i=1;k<n;i*=2,m=k){
		for(j=n-i+1,k=0,memset(t,0,m*4+4);j<=n;++j)b[++k]=j;
		for(j=1;j<=n;++j)if(++t[rk[j]],sa[j]>i)b[++k]=sa[j]-i;
		for(j=1;j<=m;++j)t[j]+=t[j-1];
		for(j=n;j;--j)sa[t[rk[b[j]]]--]=b[j];
		for(j=1,k=y=0,swap(rk,b);j<=n;++j,y=x)x=sa[j],rk[x]=b[x]==b[y]&&b[x+i]==b[y+i]?k:++k;
	}
	for(i=1,k=s[n+1]=0;i<=n;st[0][rk[i++]]=k)if(rk[i]>1)for(j=sa[rk[i]-1],k=max(k-1,0);s[i+k]==s[j+k];++k);
	for(i=0;i<20;++i)for(j=2,k=n-(1<<i+1)+2;j<k;++j)st[i+1][j]=min(st[i][j],st[i][j+(1<<i)]);
}
int lcp(int x,int y){
	if(x=rk[x],y=rk[y],x>y)swap(x,y);
	int i=lg[y-x];
	return min(st[i][x+1],st[i][y-(1<<i)+1]);
}
void ddz(){//单调栈
	b[0]=1,st[0][1]=0;
	for(int*h=st[0],*st=b,tp=0,i=2,j;i<=n;++i){
		for(;h[i]<h[j=st[tp]];--tp)w-=(j-st[tp-1])*1ll*h[st[tp]];
		st[++tp]=i,w+=(i-j)*1ll*h[i],ans+=w;
	}
}
}A,B;
void calc(int s,int p,int l){//等差数列求和
	int x=min(s,l)+p-1,y=max(p,l);
	if(x>=y)ans-=(x-y+1ll)*(x+y-2*l+2)/2;
}
int main(){
	int l,i,j=0;
	for(scanf("%d",&n),lg[0]=-1,ans=n*(n-1ll)/2,i=1;i<=n;++i)scanf("%d",s+i),lg[i]=lg[i>>1]+1;
	for(i=1,--n;i<=n;s[i]=mp[s[i]],++i)if(s[i]-=s[i+1],!mp[s[i]])mp[s[i]]=++j;//差分离散化
	A.in(),A.ddz(),reverse(s+1,s+n+1),B.in();
	for(l=1;l<=n;++l)for(j=l*2;j<=n;j+=l)i=j-l,calc(B.lcp(n-i+1,n-j+1),A.lcp(i,j),l);
	cout<<ans;
	return 0;
}
```


---

## 作者：ljc1301 (赞：7)

这道题因为要求的求两个子串中每个元素相减得到的值相等，先把长度为1的统计答案，为n(n-1)/2个，考虑先把序列换成原序列相邻两个数的差值（前一个减后一个）。比如序列
``` plain
9   7   6   5   3   2
```
可以得到新序列
``` plain
  2   1   1   2   1
```
假设我们再找在原序列中长度为3的满足条件的两个序列，可以发现一些东西：
``` plain
(9   7   6) (5   3   2)
  (2   1)  1  (2   1)
```
前一行是原序列，括号括起来的是满足条件的。可以发现在原序列中满足条件的子串，在新序列中对应了一组两个相等的子串。由于还有在原序列中不能相交，思考后就能知道在新序列中这一组的字符串不能相邻，也不能相交。

我们（对新序列）先建一个后缀数组，把height求出来。答案应该是
$$\sum\limits_{i<j}\min\left(|sa_i-sa_j|-1,\operatorname{lcp}(sa_i,sa_j)\right)$$
怎么计算这个东西？因为既有min又有lcp，很不好计算。考虑刚开始有新序列的长度个区间，每个区间记录每个元素对应的sa值，从大到小枚举height（lcp就从大到小了），暴力合并这个height相邻的两个区间（启发式合并，从短的合并到长的），对于每一个在短的区间里的数，对长的区间每一个数求贡献，直接看是取lcp为min还是取$|sa_i-sa_j|-1$，这个用平衡树维护即可，具体参见代码。

时间复杂度$O(n\log^2n)$？

代码（细节较多，常数较大，虽然~~拿到了暂时的最优解~~比正解$O(n\log n)$在luogu上测出来的时间短？）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=300005;
int n,logn,sa[maxn],h[maxn],rk[maxn],sz[maxn];
int a[maxn],b[maxn],s[maxn],l[maxn],r[maxn],rt[maxn];
int lc[maxn],rc[maxn],pri[maxn];
long long sum[maxn],ans;
inline bool cmp(int x,int y) { return h[x]>h[y]; }
inline void pushup(int rt) { sum[rt]=sum[lc[rt]]+sum[rc[rt]]+sa[rt],sz[rt]=sz[lc[rt]]+sz[rc[rt]]+1; }
void merge(int &rt,int l,int r)
{
    if(l==n || r==n) { rt=l^r^n; return; }
    if(pri[l]<pri[r]) rt=l,merge(rc[rt],rc[l],r);
    else rt=r,merge(lc[rt],l,lc[r]);
    pushup(rt);
}
void split(int rt,int &l,int &r,int x)
{
    if(rt==n) { l=r=n; return; }
    if(sa[rt]<=x) l=rt,split(rc[rt],rc[l],r,x),pushup(l);
    else r=rt,split(lc[rt],l,lc[r],x),pushup(r);
}
inline void solve(const int &l,const int &r,int &rt,const int &lcp)
{
    int i,a,b,c,d;
    for(i=l;i<=r;i++)
    {
        split(rt,a,b,sa[i]-lcp-1);
        split(b,b,c,sa[i]);
        split(c,c,d,sa[i]+lcp+1);
        ans+=lcp*(long long)(sz[a]+sz[d]);
        ans+=sz[b]*(long long)(sa[i]-1)-sum[b];
        ans+=sum[c]-sz[c]*(long long)(sa[i]+1);
        merge(rt,a,b);
        merge(rt,rt,c);
        merge(rt,rt,d);
    }
    for(i=l;i<=r;i++)
    {
        lc[i]=rc[i]=n,sz[i]=1,sum[i]=sa[i];
        split(rt,a,b,sa[i]);
        merge(rt,a,i);
        merge(rt,rt,b);
    }
}
int main()
{
    register int i,k,q,p;
    int *x=h,*y=rk,m,pre,x_;
    scanf("%d",&n),ans=n*(n-1ll)/2,m=--n;
    for(i=0,scanf("%d",&pre);i<n;i++)
        scanf("%d",&x_),a[i]=x_-pre,pre=x_;
    for(i=0;i<n;i++) b[i]=a[i];
    sort(b,b+n),m=unique(b,b+n)-b;
    for(i=0;i<n;i++) s[i]=lower_bound(b,b+m,a[i])-b;
    for(i=0;i<m;i++) sz[i]=0;
    for(i=0;i<n;i++) sz[x[i]=s[i]]++;
    for(i=1;i<m;i++) sz[i]+=sz[i-1];
    for(i=0;i<n;i++) sa[--sz[x[i]]]=i;
    for(k=1;k<=n;k<<=1)
    {
        for(i=n-k,p=0;i<n;i++) y[p++]=i;
        for(i=0;i<n;i++)
            if(sa[i]>=k)
                y[p++]=sa[i]-k;
        for(i=0;i<m;i++) sz[i]=0;
        for(i=0;i<n;i++) sz[x[i]]++;
        for(i=1;i<m;i++) sz[i]+=sz[i-1];
        for(i=n-1;i>=0;i--) sa[--sz[x[y[i]]]]=y[i];
        swap(x,y);
        x[sa[0]]=0;
        for(i=1,p=1;i<n;i++)
            x[sa[i]]=((y[sa[i]]==y[sa[i-1]] && ((sa[i]+k>=n && sa[i-1]+k>=n) || (sa[i]+k<n && sa[i-1]+k<n && y[sa[i]+k]==y[sa[i-1]+k])))?p-1:p++);
        if(p>=n) break;
        m=p;
    }
    for(i=0;i<n;i++) rk[sa[i]]=i;
    p=h[0]=0;
    s[n]=-1;
    for(i=0;i<n;i++)
    {
        if(p) p--;
        if(!rk[i]) continue;
        while(s[i+p]==s[sa[rk[i]-1]+p]) p++;
        h[rk[i]]=p;
    }
    for(i=1;i<n;i++) a[i]=i;
    sort(a+1,a+n,cmp);
    for(i=0;i<n;i++) l[i]=r[i]=i,rt[i]=i,pri[i]=rand(),lc[i]=rc[i]=n,sz[i]=1,sum[i]=sa[i];
    sz[n]=0,sum[n]=0;
    for(i=1;i<n;i++)
    {
        p=a[i]-1,q=a[i];
        if(p-l[p]<r[q]-q) solve(l[p],p,rt[r[q]],h[a[i]]),rt[l[p]]=rt[r[q]];
        else solve(q,r[q],rt[l[p]],h[a[i]]),rt[r[q]]=rt[l[p]];
        l[r[q]]=l[p],r[l[p]]=r[q];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Y_B_X (赞：6)

[原题链接](https://www.luogu.com.cn/problem/P5161)

>题意：  
给定一个序列，求不相交的长度相同子串中，  
满足对应位置之差为同一值的子串对数。

提供一种 $\text{SAM+dsu on tree}$ 的解法。

+ 首先，子串对应位置差为定值，可以将原序列差分后，转化为查询**不相交也不相邻**的子串对数。

+ 把字符串扔到 $\text{parent}$ 树上，设两个 $\operatorname{lcs}$ 为 $len$ 的字符串右端点为 $r_1,r_2$

对一个 $r_1$，考虑其对各个位置的 $r_2$ 的贡献：

![](https://cdn.luogu.com.cn/upload/image_hosting/a6kpkk8b.png)

+ 也就是说一个 $r_1$ 对 $r_2$ 的贡献是一个二维前缀和的形式，

+ 反过来，对一个 $r_2$，$r_1$ 的贡献为 $\begin{cases}r_2-r_1-1,r_1\in[r_2-len-1,r_2-2]\\len,r_2\in[1,r_2-len-2]\end{cases}$。

现在希望得知的是 $\text{parent}$ 树上长度为 $len$ 的点，$lca$ 是这个点的 $r_1,r_2$ 间的贡献。

接下来用 $\text{dsu on tree}$ 解决此问题。

主要思想是考虑**重儿子与轻儿子内的 $r_1$ 对轻儿子内的 $r_2$**，**轻儿子内的 $r_1$ 对重儿子内的 $r_2$** 的影响。

+ 重儿子中的 $r_1$ 可以在 $\text{dsu on tree}$ 过程中统计，统计时先将全部轻儿子子树的贡献加入。  
查某轻儿子内的子树时，先去除其子树内的贡献，之后再加回来。  
对每个 $r_2$，按上式算出需要区间内的 $r_1$ 的个数与和，可以用树状数组实现。

+ 轻链对重儿子子树内影响的点是 $dfs$ 序上连续的一段区间，可以将这些影响离线下来。  
按 $dfs$ 序枚举点以及顺带的修改，把能影响 $r_2$ 的 $r_1$ 统计出二维前缀和的贡献，依然能用树状数组。

+ 注意单纯是这个作为 $lca$ 的点也能对重儿子子树与轻儿子子树产生影响。

总时间复杂度为 $O(n\log^2n)$，但跑得十分快，$\text{Subtask 3}$ 中仅有一个点跑上 $1s$。

附带：[对这种形式的 $\text{dsu on tree}$ 的更多扩展应用](https://www.luogu.com.cn/blog/Y-B-X/jing-tai-lian-fen-zhi-jin-jie)。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e5+10,M=5e6+10;
int n,m,x,xx,y,tmp,last=1,tot=1;
int len_lca,tt,ldfn,rdfn,qtot;
ll ans,res;char ch;bool rf;
unordered_map<int,int>trans[N];
int mxlen[N],link[N],pos[N],rev[N],a[N];
inline void read(int &x){
	x=rf=0;ch=getchar();while((ch<48)&&(ch^'-'))ch=getchar();
	if(ch=='-')rf=1,ch=getchar();
	while(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(rf)x=-x;
}
void write(ll x){if(x>9)write(x/10);putchar(48+x%10);}
inline void extend(int a){
	tmp=++tot;y=last;mxlen[tmp]=mxlen[y]+1;
	for(;y&&!trans[y].count(a);y=link[y])trans[y][a]=tmp;
	if(!y)link[tmp]=1;
	else {
		x=trans[y][a];
		if(mxlen[x]==mxlen[y]+1)link[tmp]=x;
		else {
			xx=++tot;link[xx]=link[x];
			mxlen[xx]=mxlen[y]+1;trans[xx]=trans[x];
			for(;trans[y].count(a)&&trans[y][a]==x;y=link[y])trans[y][a]=xx;
			link[tmp]=link[x]=xx;
		}
	}
	last=tmp;
}
int nextn[N],to[N],h[N],edg;
int nextnq[M],toq[M],hq[N],edgq;
struct mdf{
	int l,r,t,v;mdf()=default;
	mdf(int _l,int _r,int _t,int _v):l(_l),r(_r),t(_t),v(_v){}
}q[M];
int son[N],sz[N],dfn[N],r_dfn[N];ll w[N],tmpp,tmp_;
inline void add(int x,int y){to[++edg]=y,nextn[edg]=h[x],h[x]=edg;}
inline void addq(int x,int y){toq[++edgq]=y,nextnq[edgq]=hq[x],hq[x]=edgq;}
inline void init(int x){
	int i,y;sz[x]=1;r_dfn[dfn[x]=++tt]=x;
	for(i=h[x];y=to[i];i=nextn[i]){
		init(y);sz[x]+=sz[y];
		if(sz[y]>sz[son[x]])son[x]=y;
	}
}
int *t[N],t__[N<<1],*t_,_t,_t_,num[N];
#define lowbit(i) i&(-i)
struct bit{
	ll t[N],res;int ti;inline void clear(){for(ti=1;ti<=n;++ti)t[ti]=0;}
	inline void update(int pos,int v){for(ti=pos;ti<=n;ti+=lowbit(ti))t[ti]+=v;}
	inline void inquiry(int pos){res=0;for(ti=pos;ti;ti-=lowbit(ti))res+=t[ti];}
}T,T_;
inline void T_add(int pos){
	q[++qtot]=mdf(pos+2,pos+len_lca+2,ldfn,1);
	q[++qtot]=mdf(pos+2,pos+len_lca+2,rdfn,-1);
}
inline void T_upd(int pos,int v){T.update(pos,v);T_.update(pos,pos*v);}
inline void T_inq(int pos){T.inquiry(pos);T_.inquiry(pos);res=T.res*(pos+1)-T_.res;}//二维前缀和
inline void update(int pos,int v){T.update(pos,v);T_.update(pos,pos*v);}
inline void inquiry(int pos){
	T.inquiry(pos-2);tmpp=T.res;T.inquiry(max(pos-len_lca-2,0));tmpp-=T.res;
	T_.inquiry(pos-2);tmp_=T_.res;T_.inquiry(max(pos-len_lca-2,0));tmp_-=T_.res;
	res=tmpp*(pos-1)-tmp_;
	T.inquiry(max(pos-len_lca-2,0));res+=T.res*len_lca;
}//对轻链的影响
void clear(int x){
	int i,y;if(pos[x])update(pos[x],-1);
	for(i=h[x];y=to[i];i=nextn[i])clear(y);
}
void dfs(int x){
	if(pos[x]){
		if(ldfn)T_add(pos[x]);
		t[_t][++_t_]=x;
	}
	int i,y;
	for(i=h[x];y=to[i];i=nextn[i])dfs(y);
}
void solve(int x){
	int i,y;
	for(i=h[x];y=to[i];i=nextn[i])if(y^son[x])solve(y),clear(y);
	if(y=son[x])solve(y);len_lca=mxlen[x];
	ldfn=dfn[y],rdfn=dfn[y]+sz[y];
	if(len_lca){
		if(pos[x]){
			if(ldfn)T_add(pos[x]);
			update(pos[x],1);
		}
		int j;t_=t__;_t=0;
		for(i=h[x];y=to[i];i=nextn[i])if(y^son[x]){
			_t_=0;t[++_t]=t_;t_+=sz[y]+1;
			dfs(y);num[_t]=_t_;
		}
		for(i=1;i<=_t;++i)for(j=1;j<=num[i];++j)update(pos[t[i][j]],1);
		for(i=1;i<=_t;++i){
			for(j=1;j<=num[i];++j)update(pos[t[i][j]],-1);
			for(j=1;j<=num[i];++j)if(pos[y=t[i][j]]>2)inquiry(pos[y]),w[y]+=res;
			for(j=1;j<=num[i];++j)update(pos[t[i][j]],1);
		}
	}
}//dsu on tree
void work(){
	register int i,qi;
	for(i=1;i<=n;++i)a[i]=a[i+1]-a[i];--n;
	for(i=1;i<=n;++i)extend(a[i]),pos[tmp]=i,rev[i]=tmp;
	for(i=2;i<=tot;++i)add(link[i],i);
	init(1);solve(1);T.clear();T_.clear();
	for(i=1;i<=qtot;++i)if(q[i].t<=tot)addq(q[i].t,i);
	for(i=1;i<=tot;++i){
		x=r_dfn[i];
		for(qi=hq[i];y=toq[qi];qi=nextnq[qi]){
			q[y].l=max(q[y].l,1);
			T_upd(q[y].l,q[y].v);
			T_upd(q[y].r,-q[y].v);
		}
		if(pos[x])T_inq(pos[x]),w[x]+=res;
	}//离线统计
	for(i=1;i<=tot;++i)ans+=w[i];
}
main(){
	read(n);register int i;
	for(i=1;i<=n;++i)read(a[i]);
	ans=1ll*n*(n-1)>>1;//每个长度为1的子串间的贡献
	work();write(ans);
}
```


---

## 作者：p_b_p_b (赞：5)

出题人的题解：https://blog.csdn.net/WAautomaton/article/details/85057257

~~我不是题解的生产者，我只是题解的搬运工~~

------


首先，看完题目，相信大家第一反应都是差分

然后，由于我最近才学完后缀数组，于是自然而然地想到了后缀数组

接着，回想[[AHOI2013]差异](https://www.luogu.org/problemnew/show/P4248)一题的套路，想到了单调栈

> 在rnk数组上从右往左扫，维护一个以height为关键字的单调栈，以及栈里的每个元素对当前位置作出的贡献之和。每扫到一个位置，ans+=sum，然后将栈顶所有height小于当前位置的元素合并到一起。

> (语文功底不好，具体请见https://www.luogu.org/problemnew/solution/P4248 中后缀数组的题解)

然而，这样求出的答案包含了相交的字串，我们需要求出相交的相同字符串数量，然后将其删去

### 注意：由于数组是差分过的，因此差分数组中相交或相邻的串在原串中都是相交的

普通方法似乎难以解决，于是再一次回想起[[NOI2016]优秀的拆分](https://www.luogu.org/problemnew/show/P1117)中枚举长度k，然后每隔一个k打一个标记的套路。此题中枚举的len是两个字符串偏移的距离。之后，考虑若一个字符串的开头位置为$a$，则第二个字符串的开头为$a+k$。为了使两个串相交或相邻，第一个串的结束位置b必须满足$b>=a+k-1$。发现$a$每往右边1单位长度，$b$的取值就少了1。因此做一个等差数列求和即可。

最后一些叮嘱：

由于是差分过的数组，长度为1的串没有加在答案中，需要输出答案时单独加上。

### 注意细节！！

### 开long long！

最后放上我丑陋的代码：

```cpp
#include<bits/stdc++.h>
namespace my_std{
    using namespace std;
    #define rep(i,x,y) for (int i=(x);i<=(y);i++)
    #define drep(i,x,y) for (int i=(x);i>=(y);i--)
    #define go(x) for (int i=head[x];i;i=edge[i].nxt)
    #define sz 300303
    typedef __int128 ll;
    template<typename T>
    inline void read(T& t)
    {
        t=0;char f=0,ch=getchar();
        double d=0.1;
        while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
        while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
        if(ch=='.')
        {
            ch=getchar();
            while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();
        }
        t=(f?-t:t);
    }
    template<typename T,typename... Args>
    inline void read(T& t,Args&... args){read(t); read(args...);}
    void file()
    {
        #ifndef ONLINE_JUDGE
        freopen("a.txt","r",stdin);
        #endif
    }
}
using namespace my_std;
int n;
int a[sz],b[sz];
struct suffix_array
{
    int sa[sz],tp[sz],rnk[sz],_rnk[sz],cnt[sz],H[sz],st[sz][25],lg2[sz];
    void Sort(int m)
    {
        rep(i,1,m) cnt[i]=0;
        rep(i,1,n) cnt[rnk[i]]++;
        rep(i,1,m) cnt[i]+=cnt[i-1];
        drep(i,n,1) sa[cnt[rnk[tp[i]]]--]=tp[i];
    }
    void init(int *a)
    {
        rep(i,1,n) rnk[i]=a[i],tp[i]=i;
        Sort(n);
        for (int w=1,p=0,m=n;p<n;w<<=1,m=p)
        {
            p=0;
            rep(i,1,w) tp[++p]=n-i+1;
            rep(i,1,n) if (sa[i]>w) tp[++p]=sa[i]-w;
            Sort(m);
            swap(_rnk,rnk);
            rnk[sa[p=1]]=1;
            rep(i,2,n) rnk[sa[i]]=(_rnk[sa[i]]==_rnk[sa[i-1]]&&_rnk[sa[i]+w]==_rnk[sa[i-1]+w])?p:++p;
        }
        for (int i=1,j,k=0;i<=n;i++)
        {
            if (k) --k;
            j=sa[rnk[i]-1];
            while (a[i+k]==a[j+k]) ++k;
            H[rnk[i]]=k;
        }
        rep(i,1,n) st[i][0]=H[i];
        rep(j,1,20)
            rep(i,1,n-(1<<j)+1)
                st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
        rep(i,2,n) lg2[i]=lg2[i>>1]+1;
    }
    int query(int l,int r){int len=lg2[r-l+1];return min(st[l][len],st[r-(1<<len)+1][len]);}
    int lcp(int x,int y){ x=rnk[x],y=rnk[y]; if (x>y) swap(x,y); return query(x+1,y); }
}pre,suf;
struct hh{ll p,w;}s[sz];
int top;
ll Sum(ll x,ll y){return (x+y)*(y-x+1)/2;}
signed main()
{
    file();
    int x;
    read(n);--n;
    rep(i,0,n) read(a[i]);
    drep(i,n,1) a[i]-=a[i-1],b[i]=a[i];
    sort(b+1,b+n+1);x=unique(b+1,b+n+1)-b-1;
    rep(i,1,n) a[i]=lower_bound(b+1,b+x+1,a[i])-b;
    suf.init(a);reverse(a+1,a+n+1);pre.init(a);
    ll ans=0,sum=0,cur;
    drep(i,n,1)
    {
        ans+=sum;cur=1;
        while (top&&s[top].p>=(ll)suf.H[i]) sum-=s[top].p*s[top].w,cur+=s[top--].w;
        s[++top]=(hh){(ll)suf.H[i],cur};sum+=cur*(ll)suf.H[i];
    }
    rep(k,1,n-1)
    {
        rep(i,1,n/k-1)
        {
            ll x1=i*k,y1=x1+k,x2=n-y1+2,y2=n-x1+2;
            ll len1=min(k-1,pre.lcp(x2,y2)),len2=suf.lcp(x1,y1);
            if (len1+len2-k+1<0) continue;
            ans-=Sum(max(len2-k+1,(ll)0),len1+len2-k+1);
        }
    }
    long long Ans=ans+(ll)n*(n+1)/2;
    cout<<Ans;
}
```

---

## 作者：asuldb (赞：4)

[题目](https://www.luogu.org/problemnew/show/P5161)

也是可以用$SAM$来做的

我们发现要求原串不相交，那么就要求在差分序列里不相交并且不相邻

考虑一下$SAM$，暴力做法自然是对每一个节点统计其所有$endpos$的影响

既然这样我们为什么不直接启发式合并加线段树合并分类讨论一下呢

~~于是可休闲了~~

我们考虑往一个节点里插入一个新的$endpos$会产生什么影响

1. 对于那些$x-endpos>=mxlen+1$的$x$，我们这样插入显然是会产生$x$的贡献

1. 如果$x-endpos<mxlen+1$，那么就会产生$|x-enspos|-1$的贡献

分情况讨论一下这些贡献就好了

于是同时维护动态开点线段树就好了，合并直接线段树合并

代码

```cpp
#include<tr1/unordered_map>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define re register
#define LL long long
#pragma GCC optimize(3)
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("Ofast,no-stack-protector")
const int maxn=6e5+5;
const int R=2e5+5;
const int M=2.2e7;
using namespace std::tr1;
inline int read() {
    char c=getchar();int x=0,r=1;
    while(c<'0'||c>'9') {if(c=='-') r=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return r*x;
}
int n,cnt=1,lst=1,tot,tax[maxn>>1],A[maxn];
unordered_map<int,int> son[maxn];
int len[maxn],fa[maxn];
std::vector<int> pos[maxn];
int a[maxn>>1];
int rt[maxn],l[M],r[M],t[M];
int st[maxn>>1],top;
LL d[M],ans,D,T;
int change(int now,int x,int y,int pos) {
    if(!now) {
        if(!top) now=++tot;
        else now=st[top--];
    }
    t[now]++,d[now]+=pos;
    if(x==y) return now;
    int mid=x+y>>1;
    if(pos<=mid) l[now]=change(l[now],x,mid,pos);
        else r[now]=change(r[now],mid+1,y,pos);
    return now;
}
LL ask(int now,int x,int y,int lx,int ry) {
    if(!now||x>y) return 0;
    if(x<=lx&&y>=ry) return t[now];
    int mid=lx+ry>>1;
    if(y<=mid) return ask(l[now],x,y,lx,mid);
    if(x>mid) return ask(r[now],x,y,mid+1,ry);
    return ask(l[now],x,y,lx,mid)+ask(r[now],x,y,mid+1,ry);
}
void query(int now,int x,int y,int lx,int ry) {
    if(!now||x>y) return;
    if(x<=lx&&y>=ry) {T+=t[now],D+=d[now];return;}
    int mid=lx+ry>>1;
    if(x<=mid) query(l[now],x,y,lx,mid);
    if(y>=mid+1) query(r[now],x,y,mid+1,ry);
}
inline void ins(int c,int k) {
    int p=++cnt,f=lst;lst=p;
    len[p]=len[f]+1;
    pos[p].push_back(k);rt[p]=change(rt[p],1,n-1,k);
    while(f&&!son[f][c]) son[f][c]=p,f=fa[f];
    if(!f) {fa[p]=1;return;}
    int x=son[f][c];
    if(len[f]+1==len[x]) {fa[p]=x;return;}
    int y=++cnt;len[y]=len[f]+1;
    fa[y]=fa[x],fa[x]=fa[p]=y;son[y]=son[x];
    while(f&&son[f][c]==x) son[f][c]=y,f=fa[f];
}
int merge(int a,int b,int x,int y) {
	if(!a||!b) return a+b;
	if(x==y) {t[a]+=t[b];d[a]+=d[b];}
	int mid=x+y>>1;
	l[a]=merge(l[a],l[b],x,mid);r[a]=merge(r[a],r[b],mid+1,y);
	t[a]=t[l[a]]+t[r[a]],d[a]=d[l[a]]+d[r[a]];
	return a;
}
int main() {
    n=read();
    for(re int i=1;i<=n;++i) a[i]=read();
    for(re int i=1;i<n;++i) ins(a[i+1]-a[i],i);
    for(re int i=1;i<=cnt;++i) tax[len[i]]++;
    for(re int i=1;i<n;i++) tax[i]+=tax[i-1];
    for(re int i=cnt;i>=0;--i) A[tax[len[i]]--]=i;
    for(re int i=cnt;i;--i) {
        int x=A[i],F=fa[x];
        if(pos[x].size()>pos[F].size()) std::swap(pos[x],pos[F]),std::swap(rt[x],rt[F]);
        for(re int j=0;j<pos[x].size();j++) {
            int now=pos[x][j];
            ans+=ask(rt[F],now+1+len[F],n-1,1,n-1)*(LL)len[F];
            ans+=ask(rt[F],1,now-len[F]-1,1,n-1)*(LL)len[F];
            
            T=D=0;query(rt[F],now-len[F],now-1,1,n-1);
            ans+=T*((LL)now-1)-D;
            
            T=D=0;query(rt[F],now+1,now+len[F],1,n-1);
            ans+=D-T*((LL)now+1);
            
            pos[F].push_back(now);
        }
        rt[F]=merge(rt[F],rt[x],1,n-1);
    }
    ans+=(LL)(n-1)*n/2ll;
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：JWRuixi (赞：2)

### 题意

定义两个序列 $\{a\}, \{b\}$ 是匹配的当且仅当：

- 存在一个常数 $c$ 使得：$\forall i, b_i = a_i + c$。

给定一个长度为 $n$ 的序列 $\{a\}$，问其中有多少对不相交的匹配的子串。

$n \le 3 \times 10^5, |a_i| \le 10^9$。

### 分析

考虑差分，得到新序列 $\{a^\prime\}$，那么就可以将题意转换成问有多少对不相邻且不相交的子串匹配。

我们不走常规路，选择建出 $\text{SAM}$，考虑其 $\text{parent}$ 树具有的性质。

假设当前考虑的节点为 $u$，考虑它的两个儿子 $v, v^\prime$。显然我们可以用启发式合并的方法转换成依次考虑  $p \in \operatorname{endpos}(v)$ 对 $\operatorname{endpos}(v^\prime)$ 的贡献。

显然如果要匹配上，那么长度只可能是 $1 \sim \operatorname{len}(u)$。设 $l = \operatorname{len}(u)$，我们研究一下每个位置 $q$ 如果在 $\operatorname{endpos}(v^\prime)$ 中的话会有怎样的贡献（只列出最半边，右边同理）：

![](https://cdn.luogu.com.cn/upload/image_hosting/hrjh8o50.png)

我们发现这样只要维护 $\sum\limits_{p \in \operatorname{endpos}(v^\prime)} p$ 和 $|\operatorname{endpos}(v^\prime)|$ 就行了！

到这里就结束了，用线段树合并和 $\text{DSU on tree}$ 都行，但我线段树合并被卡常了，/kk……

### Code

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
// #define ATC
#define IL inline
#define LL long long
#define eb emplace_back
#define writesp(x) write(x), putchar(' ')
#define writeln(x) write(x), putchar('\n')
#define FIO(FILENAME) freopen(FILENAME".in", "r", stdin), freopen(FILENAME".out", "w", stdout)
using namespace std;

#ifdef ATC
#include <atcoder/all>
using namespace atcoder;
#endif

namespace IO {
	char ibuf[1 << 20], *iS, *iT;
#if ONLINE_JUDGE
#define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, 1 << 20, stdin), (iS == iT ? EOF : *iS++) : *iS++)
#else
#define gh() getchar()
#endif
	inline long long read() {
		char ch = gh();
		long long x = 0;
		bool t = 0;
		while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
		while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
		return t ? ~(x - 1) : x;
	}
	template<typename _Tp>
	inline void write(_Tp x) {
		static char stk[64], *top = stk;
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		do *top++ = x % 10, x /= 10;
		while (x);
		while (top != stk) putchar((*--top) | 48);
	}
}

using IO::read;
using IO::write;

using cint = const int;
using vi = vector<int>;

constexpr int N = 3e5 + 9, S = 26;
int n, a[N];
vi G[N << 1];

struct SAM {
	int tot = 1, ed = 1;
	struct {
		int p, l;
		__gnu_pbds::gp_hash_table<int, int> ch;
	} tr[N << 1];

#define fa(u) tr[u].p

	void ins (int c) {
		int u = ++tot;
		tr[u].l = tr[ed].l + 1;
		int p = ed;
		ed = u;
		for (; p && !tr[p].ch[c]; p = fa(p)) {
			tr[p].ch[c] = u;
		}
		if (!p) {
			fa(u) = 1;
			return;
		}
		int q = tr[p].ch[c];
		if (tr[q].l == tr[p].l + 1) {
			fa(u) = q;
		} else {
			int cl = ++tot;
			tr[cl] = tr[q];
			tr[cl].l = tr[p].l + 1;
			fa(u) = fa(q) = cl;
			for (; p && tr[p].ch[c] == q; p = fa(p)) {
				tr[p].ch[c] = cl;
			}
		}
	}

	void bld () {
		for (int i = 2; i <= tot; i++) {
			G[fa(i)].eb(i);
		}
	}
} sa;

LL as;

int dfc, rv[N << 1], L[N << 1], R[N << 1];

int sz[N << 1], son[N << 1], ps[N << 1];

#define low(x) (x & ~(x - 1))

struct {
	int tr[N];
	void mdy (int x, int v) {
		for (; x <= n; x += low(x)) tr[x] += v;
	}
	int qry (int x) {
		int r = 0;
		for (; x; x -= low(x)) r += tr[x];
		return r;
	}
	int qry (int l, int r) {
		if (l < 1) l = 1;
		if (r > n) r = n;
		if (l > r) return 0;
		return qry(r) - qry(l - 1);
	}
} tx;

struct {
	LL tr[N];
	void mdy (int x, LL v) {
		for (; x <= n; x += low(x)) tr[x] += v;
	}
	LL qry (int x) {
		LL r = 0;
		for (; x; x -= low(x)) r += tr[x];
		return r;
	}
	LL qry (int l, int r) {
		if (l < 1) l = 1;
		if (r > n) r = n;
		if (l > r) return 0;
		return qry(r) - qry(l - 1);
	}
} ty;

int all;
IL void mdy (int x, int v) {
	tx.mdy(x, v);
	ty.mdy(x, (LL)x * v);
	all += v;
}

IL void dfs (int u) {
	rv[L[u] = ++dfc] = u;
	sz[u] = 1;
	for (int v : G[u]) {
		dfs(v);
		sz[u] += sz[v];
		if (sz[v] > sz[son[u]]) son[u] = v;
	}
	R[u] = dfc;
}

IL void dfs (int u, bool fl) {
	for (int v : G[u]) {
		if (v != son[u]) {
			dfs(v, 0);
		}
	}
	if (son[u]) {
		dfs(son[u], 1);
	}
	LL l = sa.tr[u].l;
	for (int v : G[u]) {
		if (v != son[u]) {
			for (int i = L[v]; i <= R[v]; i++) {
				int p = ps[rv[i]];
				if (!p) continue;
				LL a = (p - 1 - l) * tx.qry(p - l - 1, p - 1) - ty.qry(p - l - 1, p - 1);
				LL b = ty.qry(p + 1, p + l + 1) - (p + 1 + l) * tx.qry(p + 1, p + l + 1);
				as += a + b + l * all;
			}
			for (int i = L[v]; i <= R[v]; i++) {
				int p = ps[rv[i]];
				if (p) mdy(p, 1);
			}
		}
	}
	int p = ps[u];
	if (p) {
		LL a = (p - 1 - l) * tx.qry(p - l - 1, p - 1) - ty.qry(p - l - 1, p - 1);
		LL b = ty.qry(p + 1, p + l + 1) - (p + 1 + l) * tx.qry(p + 1, p + l + 1);
		as += a + b + l * all;
		mdy(p, 1);
	}
	if (!fl) {
		for (int i = L[u]; i <= R[u]; i++) {
			int p = ps[rv[i]];
			if (p) mdy(p, -1);
		}
	}
}

int main() {
	n = read();
	for (int i = 0; i < n; i++) a[i] = read();
	--n;
	for (int i = n; i; i--) a[i] -= a[i - 1];
	for (int i = 1; i <= n; i++) {
		sa.ins(a[i]);
		ps[sa.ed] = i;
	}
	sa.bld();
	dfs(1);
	dfs(1, 1);
	writeln(as + (LL)n * (n + 1) / 2);
}
// I love WHQ
```



---

## 作者：Alex_Wei (赞：2)

Upd on 2022.7.7：修改表述。

> [P5161 WD 与数列](https://www.luogu.com.cn/problem/P5161)

据定义，差分数组相同的两个串相等。转化为求差分数组不相交且不相邻的相等子串对数量，补集转化得相等子串对数量减去 **相交或相邻** 的相等子串对数量。

对差分数组求后缀数组，按 $ht$ 从大到小合并相邻两个排名的后缀。用线段树与启发式合并求出两个后缀所在连通块 $X, Y$ 之间的两两贡献，即 $\sum\limits_{x \in X} \sum\limits_{y \in Y} \max(0, w + 1 - |x - y|)$，其中 $w$ 为当前 $ht$。遍历较小集合 $Y$ 的每个位置 $y$，在线段树 $T_X$ 上查询 $[y - w, y)$ 以及 $(y, y + w]$ 两个区间位置个数与下标之和。最后进行线段树合并。

时间复杂度 $\mathcal{O}(n\log ^ 2 n)$，空间复杂度 $\mathcal{O}(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
bool Mbe;
constexpr int N = 3e5 + 5;
constexpr int K = N * 20;
ll ans;
int n, s[N], d[N];
int ht[N], rk[N], ork[N], sa[N], id[N], buc[N];
bool cmp(int a, int b, int w) {return ork[a] == ork[b] && ork[a + w] == ork[b + w];}
void build(int n) {
  int m = n, p = 0;
  for(int i = 1; i <= n; i++) buc[rk[i] = s[i]]++;
  for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
  for(int i = n; i; i--) sa[buc[rk[i]]--] = i;
  for(int w = 1; ; w <<= 1, m = p, p = 0) {
    for(int i = n - w + 1; i <= n; i++) id[++p] = i;
    for(int i = 1; i <= n; i++) if(sa[i] > w) id[++p] = sa[i] - w;
    memset(buc, 0, sizeof(buc));
    memcpy(ork, rk, sizeof(rk));
    p = 0;
    for(int i = 1; i <= n; i++) buc[rk[i]]++;
    for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
    for(int i = n; i; i--) sa[buc[rk[id[i]]]--] = id[i];
    for(int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i - 1], sa[i], w) ? p : ++p;
    if(p == n) break;
  }
  for(int i = 1, k = 0; i <= n; i++) {
    if(k) k--;
    while(s[i + k] == s[sa[rk[i] - 1] + k]) k++;
    ht[rk[i]] = k;
  }
}
int node, fa[N], R[N], ls[K], rs[K];
vector<int> S[N];
int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
struct dat {
  int num; ll sum;
  dat operator + (const dat &rhs) {return {num + rhs.num, sum + rhs.sum};}
} val[K];
void modify(int l, int r, int p, int &x) {
  val[x = ++node] = {1, p};
  if(l == r) return;
  int m = l + r >> 1;
  if(p <= m) modify(l, m, p, ls[x]);
  else modify(m + 1, r, p, rs[x]);
}
int merge(int x, int y) {
  if(!x || !y) return x | y;
  ls[x] = merge(ls[x], ls[y]);
  rs[x] = merge(rs[x], rs[y]);
  return val[x] = val[x] + val[y], x;
}
dat query(int l, int r, int ql, int qr, int x) {
  if(ql <= l && r <= qr) return val[x];
  int m = l + r >> 1;
  dat ans = {0, 0};
  if(ql <= m) ans = query(l, m, ql, qr, ls[x]);
  if(m < qr) ans = ans + query(m + 1, r, ql, qr, rs[x]);
  return ans;
}
bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  cin >> n, ans = 1ll * n * (n - 1) / 2;
  for(int i = 1; i <= n; i++) cin >> s[i];
  for(int i = 1; i < n; i++) d[i] = s[i] = s[i + 1] - s[i];
  sort(d + 1, d + n);
  for(int i = 1; i < n; i++) s[i] = lower_bound(d + 1, d + n, s[i]) - d;
  s[n] = 0, build(n - 1); // 注意 s[n] = 0，否则 ht 会求错
  for(int i = 1; i < n; i++) {
    fa[i] = i;
    modify(1, n - 1, sa[i], R[i]);
    S[i].push_back(sa[i]);
  }
  static int p[N]; // ranks
  for(int i = 1; i < n; i++) p[i] = i;
  sort(p + 1, p + n, [&](int u, int v) {return ht[u] > ht[v];});
  for(int i = 1; i < n && ht[p[i]]; i++) {
    int u = find(p[i] - 1), v = find(p[i]);
    if(S[u].size() < S[v].size()) swap(u, v);
    ans += 1ll * ht[p[i]] * val[R[u]].num * val[R[v]].num;
    for(int it : S[v]) {
      dat lft = query(1, n - 1, it - ht[p[i]], it, R[u]);
      dat rt = query(1, n - 1, it, it + ht[p[i]], R[u]);
      ans -= 1ll * (lft.num + rt.num) * (ht[p[i]] + 1);
      ans += 1ll * lft.num * it - lft.sum;
      ans += rt.sum - 1ll * rt.num * it;
      S[u].push_back(it);
    }
    vector<int> ().swap(S[v]);
    R[u] = merge(R[u], R[v]), fa[v] = u;
  }
  cout << ans << endl;
  return cerr << "Time: " << clock() << "\n", 0;
}
/*
2022/7/7
start coding at 18:49
finish debugging at 19:47
*/
```

---

## 作者：EuphoricStar (赞：1)

考虑两个 $\text{lcs}$ 为 $t$ 的前缀 $[1, i]$ 和 $[1, j]$。我们发现可能的左端点取值为 $\min(|i - j| - 1, t)$。

考虑建出 SAM。那么两点的 $\text{lca}$ 的 $\text{len}$ 就是它们的 $\text{lcs}$。枚举这个 $\text{lca}$。那么相当于先考虑一棵子树的所有 $\text{endpos}$ 与之前的产生的贡献，然后再加入这棵子树的 $\text{endpos}$。

可以使用线段树合并 + 启发式合并或 DSU on tree + BIT。不难发现两个 $\text{endpos}$ 的贡献即上文的 $\min(|i - j| - 1, t)$ 是分段一次函数形式。线段树维护 $\text{endpos}$ 和及个数即可。

时间复杂度 $O(n \log^2 n)$，空间复杂度 $O(n \log n)$。

```cpp
// Problem: P5161 WD与数列
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5161
// Memory Limit: 500 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

bool Mst;

const int maxn = 600100;

ll n, a[maxn];
int rt[maxn], head[maxn], len, to[maxn], nxt[maxn], p[maxn];
vector<int> pos[maxn];

inline void add_edge(int u, int v) {
	to[++len] = v;
	nxt[len] = head[u];
	head[u] = len;
}

struct node {
	ll x, y;
	node(ll a = 0, ll b = 0) : x(a), y(b) {}
};

inline node operator + (const node &a, const node &b) {
	return node(a.x + b.x, a.y + b.y);
}

namespace SGT {
	node a[maxn * 20];
	int nt, ls[maxn * 20], rs[maxn * 20];
	
	void update(int &rt, int l, int r, int x) {
		if (!rt) {
			rt = ++nt;
		}
		a[rt].x += x;
		++a[rt].y;
		if (l == r) {
			return;
		}
		int mid = (l + r) >> 1;
		(x <= mid) ? update(ls[rt], l, mid, x) : update(rs[rt], mid + 1, r, x);
	}
	
	node query(int rt, int l, int r, int ql, int qr) {
		if (!rt || ql > qr) {
			return node(0, 0);
		}
		if (ql <= l && r <= qr) {
			return a[rt];
		}
		int mid = (l + r) >> 1;
		node res(0, 0);
		if (ql <= mid) {
			res = res + query(ls[rt], l, mid, ql, qr);
		}
		if (qr > mid) {
			res = res + query(rs[rt], mid + 1, r, ql, qr);
		}
		return res;
	}
	
	int merge(int u, int v) {
		if (!u || !v) {
			return u | v;
		}
		a[u] = a[u] + a[v];
		ls[u] = merge(ls[u], ls[v]);
		rs[u] = merge(rs[u], rs[v]);
		return u;
	}
}

struct SAM {
	int lst, tot, fa[maxn], len[maxn];
	map<int, int> ch[maxn];
	
	inline void init() {
		for (int i = 1; i <= tot; ++i) {
			fa[i] = len[i] = 0;
			ch[i].clear();
		}
		lst = tot = 1;
	}
	
	inline void insert(int c) {
		int u = ++tot, p = lst;
		len[u] = len[p] + 1;
		lst = u;
		for (; p && ch[p].find(c) == ch[p].end(); p = fa[p]) {
			ch[p][c] = u;
		}
		if (!p) {
			fa[u] = 1;
			return;
		}
		int q = ch[p][c];
		if (len[q] == len[p] + 1) {
			fa[u] = q;
			return;
		}
		int nq = ++tot;
		fa[nq] = fa[q];
		ch[nq] = ch[q];
		len[nq] = len[p] + 1;
		fa[u] = fa[q] = nq;
		for (; p && ch[p][c] == q; p = fa[p]) {
			ch[p][c] = nq;
		}
	}
} sam;

void solve() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", &a[i]);
	}
	ll ans = n * (n - 1) / 2;
	--n;
	sam.init();
	for (int i = 1; i <= n; ++i) {
		a[i] -= a[i + 1];
		sam.insert(a[i]);
		SGT::update(rt[sam.lst], 1, n, i);
		pos[sam.lst].pb(i);
	}
	for (int i = 2; i <= sam.tot; ++i) {
		add_edge(sam.fa[i], i);
	}
	for (int i = 1; i <= sam.tot; ++i) {
		p[i] = i;
	}
	sort(p + 1, p + sam.tot + 1, [&](const int &x, const int &y) {
		return sam.len[x] > sam.len[y];
	});
	for (int _ = 1; _ <= sam.tot; ++_) {
		int u = p[_];
		for (int i = head[u]; i; i = nxt[i]) {
			int v = to[i];
			if (pos[u].size() < pos[v].size()) {
				swap(pos[u], pos[v]);
				swap(rt[u], rt[v]);
			}
			// printf("u, v: %d %d\n", u, v);
			for (int x : pos[v]) {
				// printf("x: %d\n", x);
				node res = SGT::query(rt[u], 1, n, 1, x - sam.len[u] - 1);
				ans += sam.len[u] * res.y;
				res = SGT::query(rt[u], 1, n, x - sam.len[u], x - 1);
				ans += (x - 1) * res.y - res.x;
				res = SGT::query(rt[u], 1, n, x + 1, x + sam.len[u]);
				ans += res.x - (x + 1) * res.y;
				res = SGT::query(rt[u], 1, n, x + sam.len[u] + 1, n);
				ans += sam.len[u] * res.y;
				pos[u].pb(x);
			}
			// printf("ans: %lld\n", ans);
			vector<int>().swap(pos[v]);
			rt[u] = SGT::merge(rt[u], rt[v]);
		}
	}
	printf("%lld\n", ans);
}

bool Med;

int main() {
	fprintf(stderr, "%.2lf MB\n", (&Mst - &Med) / 1048576.);
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}

```


---


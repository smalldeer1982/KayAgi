# WD与地图

## 题目背景

WD 整日沉浸在地图中，无法自拔……

## 题目描述

CX 让 WD 研究的地图可以看做是 $n$ 个点，$m$ 条边的有向图，由于政府正在尝试优化人民生活，他们会废弃一些无用的道路来把省下的钱用于经济建设。

城市都有各自的发达程度 $s_i$。为了方便管理，政府将整个地图划分为一些地区，两个点 $u,v$ 在一个地区当且仅当 $u,v$ 可以互相到达。政府希望知道一些时刻某个地区的前 $k$ 发达城市的发达程度总和，以此推断建设的情况。

也就是说，共有三个操作：

`1 a b` 表示政府废弃了从 $a$ 连向 $b$ 的边，保证这条边存在。

`2 a b` 表示政府把钱用于建设城市 $a$，使其发达程度增加 $b$。

`3 a b` 表示政府希望知道 $a$ 城市所在地区发达程度前 $b$ 大城市的发达程度之和。如果地区中的城市不足 $b$ 个输出该地区所有城市的发达程度总和。

## 说明/提示

$subtask1(19pts):~n\le 100,000,~m\le 200,000,~q\le 200,000$，删除操作个数$\times m\le 1,000,000$

$subtask2(39pts):~n\le 5,000,~m\le 8,000,~q\le 200,000$

$subtask3(42pts):~n\le 100,000,~m\le 200,000,~q\le 200,000$

保证任何时刻发达程度$\le 10^9$，无重边（反向边不算重边）无自环。

## 样例 #1

### 输入

```
5 8 8
4 2 1 1 3
2 5
4 2
5 3
1 3
4 5
5 1
1 5
1 4
3 3 1
1 4 5
3 3 3
3 4 1
3 1 5
3 2 4
1 5 3
2 3 4```

### 输出

```
1
1
4
10
10```

# 题解

## 作者：WeLikeStudying (赞：44)

- 我十分惭愧，在此感谢[奆佬](https://www.luogu.com.cn/user/52170)，祝愿其信息学之路光芒璀璨。
- 另外还有我们机房同志们的帮助，参照了[此篇](https://www.luogu.com.cn/blog/gzw2005/p5163-wd-yu-di-tu-yu-nh20220929d-lian-tong-yi-ji-re-gan-gan-xiang)博客，在此一并感谢。
- [前情提要](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-kai-bai-ji-hua-1wd-yu-di-tu)。
- 本题将简述复杂度 $O(m\log m+q\log (n+q))$ 的做法，优于目前所有题解的复杂度，实现只需要 $2.9\text{KB}$，是不折不扣的小清新做法。
- [原博客](https://www.luogu.com.cn/paste/ziyzdp95)写太糊了吗？那我重新改一点，这只是一个优化时间复杂度和代码复杂度的平凡小 trick 啊，我估计绝大多数人肯定早就发现了，至于写这么多吗。
- 本题题解经过改版之后已经比题解区绝大多数题解详细了，而且加了更优的做法，代码也更简短，应该能过了吧。
- 作者已经退役，希望这篇题解能够帮到更多的人。

**[题意](https://www.luogu.com.cn/problem/P5163)**
- 给一个有向图，支持删边，单点修改，求单点所在强连通分量中前 $k$ 大节点的权值和。

**套路转化**
- 题目很不接近本质！所以作者要像洋葱一样一层层拨开，这些外皮其它博客已有讲述，在此没有详细实现，可以参照前情提要。
- ``一道好题不应该是两道题拼在一起，一道好题会有自己的idea —— 而它应该不加过多包装地突出这个idea。``
- 套路 1：加边比删边（一般）更容易，所以时光倒流改成只有加边的情况。
- 套路 2：考虑弱化问题，对于无向图的情况，我们可以用线段树合并在（不离散化 $O(q\log w)$，离散化 $O(q\log(n+q))$）的时间和空间复杂度内维护整个信息。
- 套路 3：转化成弱化问题，对于每条有向边，如果能算出它什么时候被缩入一个强连通分量内，即可转化为无向图的情况。
- 套路 4：观察特殊性质，对于单条边，答案满足可二分性，对于多条边的情况，我们可以尝试整体二分。

**整体二分里的细节（传统做法）**
- 我们扒拉一下整体二分里发生了什么！
- 已知答案在 $[l,r]$ 区间内，我们要判断一些边有没有被缩入强连通分量内部，把出现时间 $\le mid$ 的边加入，注意缩点的时候要不考虑孤立点以保证复杂度，把被缩入的边和不被缩入的边分成左右两部分。
- 这个时候，左边的边可以直接下传 $[l,mid]$（左儿子），而 $[mid+1,r]$（右儿子）的边要体现左端点贡献的强连通性，不难发现可以用并查集表示这种强连通性，因此，最传统的方法简述如下：

**（传统做法）方法简述**
- 建图，把出现时间 $\le mid$ 的边加入缩好强连通性的图中。
- 跑 Tarjan 来缩点，为了保证复杂度，不要遍历孤立点。
- 根据强连通性把边划为两个部分。
- 把新产生的强连通性加入并查集。
- 求解右儿子。
- 将本层产生的强连通性从并查集中撤回。
- 求解左儿子。
- 显然，每一层如果处理 $m$ 条边，由按秩合并的可撤销并查集所产生的复杂度不超过 $O(m\log m)$，而每条边最多经过 $\log$ 层，复杂度为 $O(m\log^2m)$，[代码](https://www.luogu.com.cn/paste/26wcrfow)。
- 这也是为什么我之前说整体二分的复杂度是瓶颈，而我们为什么可以优化呢？原因很简单！

**为啥如此简单的小 trick 要让作者讲这么久**
- 实际上，体现强连通性的方法很简单：只需要把被缩起来的点当成同一个点就好了。
- 这题的做法看似没有优化空间，仔细观察还是可以发现我们要维护的东西具有比并查集弱的性质：如果一些点被缩起来之后，我们只需要取一个根来代替它，如果这个根再被缩起来，我们不需要考虑这个根代表的其它点了！这便是诀窍！
- 我们在 Tarjan 的时候，便可以给所有点选出一个代表，然后对于下传到右儿子的边，把点替换为其代表即可。

**（新做法）方法简述**
- 建图，把出现时间 $\le mid$ 的边加入缩好强连通性的图中。
- 跑 Tarjan 来缩点，为了保证复杂度，不要遍历孤立点，为每一个强连通分量内的点选出一个代表。
- 根据强连通性把边划为两个部分。
- 用代表把要加入右儿子内部的边重标号。
- 求解左儿子。
- 求解右儿子。
- 显然，该做法不需要并查集，每一层如果处理 $m$ 条边，由 Tarjan 所产生的复杂度不超过 $O(m)$，而每条边最多经过 $\log$ 层，复杂度为 $O(m\log m)$，[最终代码](https://www.luogu.com.cn/paste/55dk3xv2)。

---

## 作者：青君 (赞：15)

## 简要题意
给定一个 $n$ 个点 $m$ 条边的有向简单图，点带权，你要实现 $q$ 个操作，操作包括：1）删除一条边；2）单点加；3）询问一个点所在的 DCC 内 前 $k$ 大的点权的和。  
$n \le 10^5,m,q\le 2*10^5$ 任意时刻点权不超过 $10^9$。

## 题目分析
首先时光倒流，删边变加边，但动态维护 DCC 依然是不太可做的。考虑换个思路，先约定： 
1. 时间轴为 $[0,q+1]$ ，左小右大。
2. 一条边的**出现时间**为它原来的删除时间。如果没有被删除则为 $q+1$。
3. 一条边的**合并时间**为其连接两个顶点合并为一个 DCC 的时间，显然，任意一条边的合并时间小于等于它的出现时间。如果始终没有合并则为 $0$。

如果我们能求出每条边的合并时间，然后按这个**合并时间**从大到小依次合并，就跟动态维护连通块一样做了。至于2)和3）操作，动态开点权值线段树+启发式合并可以轻松解决。现在问题转化为，**求出每条边的合并时间**。考虑用整体二分解决。
## 算法设计——整体二分
定义 $solve(l,r,ll,rr)$ 表示，答案区间为 $[l,r]$ ，当前要求出编号属于 $[ll,rr]$ 的边的合并时间。同时需要保证，已知加入出现时间在 $[r+1,q+1]$ 内的边后图的联通信息，（也就是哪些点属于一个 DCC），这个信息用并查集存储。令 $mid = (l+r)/2$，我们试图把编号在 $[ll,rr]$ 内的边按照合并时间是否**大于** $mid$ 划成两部分，然后可以向两边分治。
算法流程：
1. 如果 $l=r$ ，则 $[ll,rr]$ 内边的合并时间就是 $l$ ，直接 `return`。
2. $mid \gets (l+r)/2$，加入编号在 $[ll,rr]$ 内且出现时间大于 $mid$ 的边。假设要加入一条边 $e(x,y)$， `link(find(x),find(y))` 也就是连接 $x,y$ 所在 DCC 的代表点。
3. 在 **2.** 中建出的图中跑 `tarjan` ，并用并查集合并新的 DCC。注意，只能跑在 **2.** 中连了边的点，否则复杂度是错的。
4. **完全清除** **2.** 中连的边。
5. 遍历 $[ll,rr]$ 内的边，如果一条边的 出现时间大于 $mid$（容易忽略）且两端在同一个 DCC 内，则划分到右边；否则划分到左边。令 $[ll,p]$ 为划分到左边的边。
6. 因为我们还未执行 **7.** ，满足「已知加入出现时间在 $[mid+1,q+1]$ 内的边后图的联通信息」的要求， `solve(l,mid,ll,p)`。
7. 撤销在第二步中执行的并查集操作。
8. `solve(mid+1,r,p+1,rr)`。

这里面有个明显的细节问题（雾）：为什么我们可以把边全部拆了（执行 **4.** ），只保留并查集中的信息，就 `solve(l,mid,ll,p)`？万一这些边对左边有用咋办？
仔细分析发现，这是不可能的。我们加入的边无非有两种命运：  
1)被划分到左边，那么问题就不是问题了，反正分治左边时它还能再加进去。
2)被划分到右边，说明它的两端在同一个 DCC 内，而我们已经保留了并查集的信息，也不会信息丢失。  
~~好像很不足道的样子。~~  
## 代码
代码应该不丑但是有yi点长。~~建议不要看。~~
```cpp
#include<bits/stdc++.h>
#define mk make_pair
#define pk push_back 
using namespace std;
typedef long long LL;
typedef pair<int,int> pi;
const int N=1e5+5,M=2e5+5;
struct opt{
	int op,x,y,t;
	opt(int op=0,int x=0,int y=0,int t=0):op(op),x(x),y(y),t(t){}
	bool operator < (const opt &tmp)const{return t==tmp.t?op<tmp.op:t>tmp.t;}
}b[M<<1];
struct edge{
	int x,y,t,nt;
	edge(int x=0,int y=0,int t=0):x(x),y(y),t(t){}
}e[M];
int n,m,q;
namespace prework{
	edge t[M<<1];
	int idx,dfn[N],low[N],fa[N],sz[N],in[N];
	vector<int> to[N];
	int find(int x){return x==fa[x]?x:find(fa[x]);}
	void merge(int x,int y,stack<pi> &st){
		x=find(x),y=find(y);
		if(x==y) return ;
		if(sz[x]<sz[y]) swap(x,y);
		sz[x]+=sz[y];fa[y]=x;st.push(mk(x,y));
	}
	void tarjan(int x,stack<pi> &st2){
		static stack<int> st; 
		dfn[x]=low[x]=++idx;st.push(x);in[x]=1;
		for(auto y:to[x])if(!dfn[y]) tarjan(y,st2),low[x]=min(low[x],low[y]);
		else if(in[y]) low[x]=min(low[x],dfn[y]);
		if(dfn[x]==low[x]){
			while(st.top()^x){
				merge(st.top(),x,st2);
				in[st.top()]=0;
				st.pop();
			}
			in[st.top()]=0;
			st.pop();
		}
	}
	void solve(int l,int r,int ll,int rr){
		if(l==r){
			for(int i=ll;i<=rr;++i) e[i].nt=l;
			return ;
		}
		int mid=(l+r)>>1;
		vector<int> nd; 
		for(int i=ll;i<=rr;++i)if(e[i].t>mid){
			int fx=find(e[i].x),fy=find(e[i].y);
			to[fx].pk(fy);
			nd.pk(fx),nd.pk(fy);
		} 
		stack<pi> st;
		for(auto x:nd)if(!dfn[x]) tarjan(x,st);
		idx=0;
		for(auto x:nd) to[x].clear(),dfn[x]=0;
		int p1=ll,p2=rr;
		for(int i=ll;i<=rr;++i)
			if(e[i].t>mid&&find(e[i].x)==find(e[i].y)) t[p2--]=e[i];
			else t[p1++]=e[i];
		for(int i=ll;i<=rr;++i) e[i]=t[i];
		solve(l,mid,ll,p1-1);
		while(st.size()){
			int x=st.top().first,y=st.top().second;
			sz[x]-=sz[y];fa[y]=y;
			st.pop();
		}
		solve(mid+1,r,p2+1,rr);
	}
}
namespace seg{
	#define tl ls[id]
	#define tr rs[id]
	#define mid (l+r>>1)
	#define lson tl,l,mid
	#define rson tr,mid+1,r
	const int M=400,D=1e9;
	int tot,a[N],fa[N],sz[N],rt[N],ls[N*M],rs[N*M],sz2[N*M];LL s[N*M];
	int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
	void insert(int &id,int l,int r,int p,int fg){
		if(!id) id=++tot;
		s[id]+=p*fg;sz2[id]+=fg;
		if(l==r) return ;
		p<=mid?insert(lson,p,fg):insert(rson,p,fg); 
	}
	int merge(int x,int y){
		if(!x||!y) return x|y;
		s[x]+=s[y];sz2[x]+=sz2[y];
		ls[x]=merge(ls[x],ls[y]);
		rs[x]=merge(rs[x],rs[y]);
		return x;
	}
	LL query(int id,int l,int r,int k){
		if(!id) return 0;
		if(l==r) return 1ll*k*l;
		return k<=sz2[tr]?query(rson,k):s[tr]+query(lson,k-sz2[tr]);
	} 
	void solve(int tot){
		sort(&b[1],&b[tot+1]);
		for(int i=1;i<=n;++i){
			fa[i]=i;sz[i]=1;
			insert(rt[i],0,D,a[i],1);
		}
		stack<LL> ans;
		for(int i=1;i<=tot;++i){
			int &op=b[i].op,&x=b[i].x,&y=b[i].y,fx=find(x);
			if(op==1){
				int fy=find(y);
				if(fx==fy) continue;
				if(sz[fx]<sz[fy]) swap(fx,fy),swap(x,y);
				sz[fx]+=sz[fy];fa[fy]=fx;rt[fx]=merge(rt[fx],rt[fy]); 
			}
			else if(op==2) insert(rt[fx],0,D,a[x],-1),insert(rt[fx],0,D,a[x]-=y,1);
			else{
				ans.push(query(rt[fx],0,D,y));
			}
		}
		while(ans.size()) cout<<ans.top()<<endl,ans.pop();
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>q;
	for(int i=1;i<=n;++i) cin>>seg::a[i];
	map<pi,int> mp;
	for(int i=1,x,y;i<=m;++i){
		cin>>x>>y;e[mp[mk(x,y)]=i]=(edge){x,y,q+1};
	}
	int tot=0;
	for(int i=1,op,a,b;i<=q;++i){
		cin>>op>>a>>b;
		if(op==1) e[mp[mk(a,b)]].t=i;
		else if(op==2) seg::a[a]+=b,::b[++tot]=opt(2,a,b,i);
		else ::b[++tot]=opt(3,a,b,i);
	} 
	for(int i=1;i<=n;++i) prework::fa[i]=i,prework::sz[i]=1; 	
	prework::solve(0,q+1,1,m);
	for(int i=1;i<=m;++i) b[++tot]=opt(1,e[i].x,e[i].y,e[i].nt);
	seg::solve(tot);
	return 0;
}
```




---

## 作者：lhm_ (赞：15)

首先将操作倒序，把删边转化为加边。先考虑若边是无向边，条件为连通，要怎么处理。

可以用并查集来维护连通性，对每个连通块维护一颗权值线段树，连通块的合并用线段树合并来实现，线段树同时也支持了修改点权。

然后再考虑对于有向边和强连通分量要怎么做。无向边的作用是使两个连通块成为一个连通块，有向边的作用是使两个强连通分量成为一个强连通分量。但是加入一条有向边后，其两端的强连通分量不一定合并为一个强连通分量，随着其他边的加入，该边才有可能发挥其作用。

因此可以考虑对每条边二分出一个时刻，为加入该边后，随着边的加入，其两端强连通分量合并的最早时刻。单独考虑每条边不现实，采取整体二分来处理。对于当前二分的时间区间 $[l,r]$，对于时间在 $[0,mid]$ 的所有边都加入，然后用 $Tarjan$ 来缩点，若满足条件就寻找更早的答案，不满足就尝试晚一些的答案。

发现在二分过程中每次都加入 $[0,mid]$ 的所有边来进行缩点，复杂度无法接受。对于当前的情况，可以利用之前二分得到的缩点结果，通过并查集来维护每个点所在的强连通分量，连边直接在强连通分量之间连边即可。对于二分的区间 $[l,r]$，已经连好了区间 $[0,mid]$ 的边，递归时先进入区间 $[mid+1,r]$，这样就能利用上之前的连边情况，递归进入区间 $[l,mid]$ 之前，需要清除之前连边的影响，这里用可撤销并查集实现即可。

用并查集来维护缩点不用考虑强连通分量之间的连边，因为如果强连通分量之间的连边和当前考虑的边集中的边能构成新的强连通分量，那么边集中的该条边一定会在之前的二分中被划分到答案更早的区间，即不会在当前区间出现，所以只需考虑当前边集和其涉及到的点即可。

二分出时刻后，类比无向图的处理就行了。

```cpp
#include<bits/stdc++.h>
#define maxn 800010
#define maxm 10000010
#define mid ((l+r)>>1)
#define mk make_pair
#define ask(x) (lower_bound(s+1,s+tot+1,x)-s)
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,qu,top,tot,cnt,dfn_cnt,s_top,tree_cnt;
int size[maxn],fa[maxn],t[maxn],dfn[maxn],low[maxn],sta[maxn];
int ls[maxm],rs[maxm],rt[maxn],siz[maxm];
ll a[maxn],s[maxn],sum[maxm],ans[maxn];
bool vis[maxn];
map<pair<int,int>,int> mp;
struct edge
{
    int to,nxt;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to)
{
    e[++edge_cnt]=(edge){to,head[from]};
    head[from]=edge_cnt;
}
struct node
{
    int x,y,t,opt;
}p[maxn],p1[maxn],p2[maxn],q[maxn];
bool cmp(const node &a,const node &b)
{
    if(a.t==b.t) return a.opt<b.opt;
    return a.t<b.t;
}
struct Stack
{
    int x,y;
}st[maxn];
int find(int x)
{
    return fa[x]==x?x:find(fa[x]);
}
void merge(int x,int y)
{
    x=find(x),y=find(y);
    if(x==y) return;
    if(size[x]<size[y]) swap(x,y);
    st[++top]=(Stack){x,y},size[x]+=size[y],fa[y]=x;
}
void del(int id)
{
    int x=st[id].x,y=st[id].y;
    fa[y]=y,size[x]-=size[y];
}
void tarjan(int x)
{
    dfn[x]=low[x]=++dfn_cnt,sta[++s_top]=x,vis[x]=true;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);
        else if(vis[y]) low[x]=min(low[x],dfn[y]);
    }
    if(dfn[x]==low[x])
    {
        int p=sta[s_top--],now;
        vis[p]=false;
        if(p==x) return;
        do
        {
            now=sta[s_top--],vis[now]=false,merge(p,now);
        }while(now!=x);
    }
}
void clear(int n)
{
    edge_cnt=dfn_cnt=0;
    for(int i=1;i<=n;++i) head[t[i]]=dfn[t[i]]=low[t[i]]=0;
}
void solve(int L,int R,int l,int r)
{
    if(L>R) return;
    if(l==r)
    {
        for(int i=L;i<=R;++i) p[i].t=l;
        return;
    }
    int now=top,num=0,cnt1=0,cnt2=0;
    for(int i=L;i<=R;++i)
    {
        if(p[i].t>mid) continue;
        int x=find(p[i].x),y=find(p[i].y);
        t[++num]=x,t[++num]=y,add(x,y);
    }
    for(int i=1;i<=num;++i)
        if(!dfn[t[i]])
            tarjan(t[i]);
    for(int i=L;i<=R;++i)
    {
        if(p[i].t<=mid&&find(p[i].x)==find(p[i].y)) p1[++cnt1]=p[i];
        else p2[++cnt2]=p[i];
    }
    for(int i=1;i<=cnt1;++i) p[L+i-1]=p1[i];
    for(int i=1;i<=cnt2;++i) p[L+cnt1+i-1]=p2[i];
    clear(num),solve(L+cnt1,R,mid+1,r);
    while(top>now) del(top--);
    solve(L,L+cnt1-1,l,mid);
}
void modify(int l,int r,int pos,int v,int &cur)
{
    if(!cur) cur=++tree_cnt;
    siz[cur]+=v,sum[cur]+=s[pos]*v;
    if(l==r) return;
    if(pos<=mid) modify(l,mid,pos,v,ls[cur]);
    else modify(mid+1,r,pos,v,rs[cur]);
}
ll query(int l,int r,int k,int cur)
{
    if(k>siz[cur]) return sum[cur];
    if(l==r) return s[l]*k;
    if(k<=siz[rs[cur]]) return query(mid+1,r,k,rs[cur]);
    return query(l,mid,k-siz[rs[cur]],ls[cur])+sum[rs[cur]];
}
int merge(int x,int y,int l,int r)
{
    if(!x||!y) return x+y;
    if(l==r)
    {
        siz[x]+=siz[y],sum[x]+=sum[y];
        return x;
    }
    ls[x]=merge(ls[x],ls[y],l,mid),rs[x]=merge(rs[x],rs[y],mid+1,r);
    siz[x]=siz[ls[x]]+siz[rs[x]],sum[x]=sum[ls[x]]+sum[rs[x]];
    return x;
}
int main()
{
    read(n),read(m),read(qu),cnt=m;
    for(int i=1;i<=n;++i)
        read(a[i]),s[++tot]=a[i],fa[i]=i,size[i]=1;
    for(int i=1;i<=m;++i)
        read(p[i].x),read(p[i].y),mp[mk(p[i].x,p[i].y)]=i;
    for(int i=1;i<=qu;++i)
    {
        read(q[i].opt),read(q[i].x),read(q[i].y),q[i].t=qu-i+1;
        if(q[i].opt==1) p[mp[mk(q[i].x,q[i].y)]].t=q[i].t;
        if(q[i].opt==2) a[q[i].x]+=q[i].y,s[++tot]=a[q[i].x];
    }
    sort(s+1,s+tot+1),tot=unique(s+1,s+tot+1)-s-1,solve(1,m,0,qu+1);
    for(int i=1;i<=n;++i)
        modify(1,tot,ask(a[i]),1,rt[i]),fa[i]=i,size[i]=1;
    for(int i=1;i<=qu;++i)
        if(q[i].opt!=1)
            p[++cnt]=q[i];
    sort(p+1,p+cnt+1,cmp);
    for(int i=1;i<=cnt;++i)
    {
        int x=p[i].x,y=p[i].y,t=p[i].t,opt=p[i].opt,f;
        if(!opt)
        {
            x=find(x),y=find(y);
            if(x==y) continue;
            if(size[x]<size[y]) swap(x,y);
            size[x]+=size[y],fa[y]=x;
            rt[x]=merge(rt[x],rt[y],1,tot);
        }
        if(opt==2)
        {
            f=find(x),modify(1,tot,ask(a[x]),-1,rt[f]);
            a[x]-=y,modify(1,tot,ask(a[x]),1,rt[f]);
        }
        if(opt==3) f=find(x),ans[qu-t+1]=query(1,tot,y,rt[f]);
    }
    for(int i=1;i<=qu;++i)
        if(q[i].opt==3)
            printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：YLWang (赞：10)

大家好这里是一个傻逼，他把一个可撤销并查集写挂了四个地方并调了整整一天。

---

### 题意简述：

给定一张 $n$ 个点 $m$ 条边的 **有向图**。要求支持三种操作：断边、单点加，查询一个点所在强联通分量中排名前 $k$ 的数的和。

### 题解

非常牛逼的一个题。

一开始没看到有向图这个东西，直接嘴巴了一个倒序加边跑并查集维护的权值线段树合并（全是套路，不会的可以看其他的题解）。写了三十分钟仔细读了读题。

![](https://cdn.luogu.com.cn/upload/pic/14789.png)

于是不会。打开题解。发现是个整体二分。关上题解。

这怎么和整体二分扯上的关系？

我们根据刚才那个做法来想一想正解。

为什么我们不能直接并查集维护？因为我们不知道把 $u$ 和 $v$ 连起来之后，他们什么时候会在一个强联通分量里头。

那我们求出来对于每个加边 $u$ 和 $v$，最晚什么时候开始 $u$ 和 $v$ 会在同一个强联通分量里头。

注意这里的时间轴 $[0, q]$ 是倒序的。也就是说，答案是 $x$ 的时候，在询问 $[0, x]$ 之间，$u$ 和 $v$ 均在一个强联通分量里头。

暴力的时间复杂度劣在哪儿？每次都要重新把图建出来。

于是这个东西一脸整体二分的样子。具体地，我们，对于当前答案区间 $[l, r]$ 和询问备选区间 $[L, R]$, 先将所有 $[r + 1, q]$ 中的边丢进图里，对于中间的每一个询问，如果其存在时间是晚于 $mid$ 的，则把他也丢进图中。然后跑一遍 tarjan，递归就完了。

再看一眼发现复杂度非常不对。


![](https://cdn.luogu.com.cn/upload/pic/14789.png)


不对在哪儿？我们还是重复地加入了大量的边。

我们发现，在上一层往左递归的时候，很多的边其实是有用的。

于是，我们直接用并查集维护缩点，每次只把当前区间内的边连出来。在往两边递归的时候清空。这个并查集则在往右递归的时候清空。

这样的话我们不仅成功做对了复杂度，还保证了正确性。

何来的正确性？

对于每一条边，他要么在强联通分量里头 —— 他已经被缩进了点。

否则他就不在——但他一定会在往左递归的时候被再加进去。 原因很简单，我们把当前区间不符合的全部丢到了左边，自然会被再加一遍。

于是就做完了。

这个题的代码实现很有技巧，我这种写着写着就重名的只能 namespace 封装了。

[代码](https://www.luogu.com.cn/paste/ooal4qgk)思路挺清晰的，还是挺好看的。




---

## 作者：Marser (赞：6)

整体二分神题，搞了半天，只能说出题人太强了。
### 题意
给定一张$n$个点$m$条边的有向图，每个点有一个点权，要求支持以下操作：
1. 删掉一条之前存在的边。
2. 更改一个点的点权。
3. 询问某个点所在强连通分量内部前$k$大的点权之和。如果不足$k$个点，则输出全部点权之和。

### 题解
首先，套路性地反转时间轴，转化为加边。接下来的问题就是如何维护强连通分量。  
如果我们能求出在什么时候，一条边所连接的两个点处于同一个强连通分量中，那么将所有边按这一时间点排序，从小往大遍历，将每条边的两个端点所在的强连通分量合并，这样就可以维护每个点所在的强连通分量了。这一过程，我们用并查集来维护每个点所在的强连通分量。  
为了处理询问，我们可以同时对每个强连通分量维护一棵权值线段树，保存分量内部的所有点权，每次加边时，我们将两棵线段树合并，就可以处理询问了。而对于修改，我们只需要改动一棵线段树上的一个位置，同样不是问题。

那么，怎么求出每条边两端被合并到同一个强连通分量中的时间呢？  
先考虑一条边的情况，我们尝试二分答案。  
设当前答案为$x$，我们把出现时间$\le x$的边全部加入一张图，对这张图跑tarjan，判断两端是否在同一强连通分量内部即可。  
尝试改写成整体二分的形式。设当前答案的区间为$[l,r]$，$mid=\frac{l+r}{2}$，在这个答案区间内的边为$[a,b]$，我们将出现时间在$[0,l-1]$之间的所有边加入，然后遍历$[a,b]$间的所有边，将$[a,b]$中出现时间$\le mid$的边全部加入，在这张图上就有了所有出现时间$\le mid$的边。跑一遍tarjan即可。  
但是我们无法支持每次都加入出现时间在$[0,mid]$之间的边，考虑利用上一层递归的结果。我们用可撤销并查集来维护当前区间tarjan缩点的结果，**每次在上一层已经缩了一部分点的“虚图”上加边**，在tarjan的过程中将同一分量内部的点在并查集上合并。每次处理完区间$[l,r]$之后，我们直接递归求解$[mid+1,r]$，等到处理完右半边之后再撤销当前区间的操作，然后再递归处理左半边的$[l,mid]$。由于tarjan的复杂度是$O(m)$的，每条边最多只会被处理$\log n$次，这样，我们就能保证复杂度是正确的。

总结一下，将时间轴取反，运用整体二分求出每条边两端被合并到同一强连通分量中的时间。对每条边求出这个值，从小到大排序，依次合并一条边两端的强连通分量和相应的权值线段树，在过程中顺便处理询问和修改，我们就做完了这道神仙题。  
主要的复杂度瓶颈在整体二分上，是$O(m\log^2n)$的，线段树合并和排序都是$O(m\log n)$，可以接受。

### 代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
typedef pair<int,int>pii;
const int MN=1e5+5;
const int MM=2e5+5;
//边表 
int to[MM],nxt[MM],h[MN],cnt;
inline void ins(int s,int t){to[++cnt]=t;nxt[cnt]=h[s];h[s]=cnt;}
//一些变量的声明 
int n,m,q,a[MN];
map<pii,int>mp;
int opt[MM],A[MM],B[MM];
ll Ans[MM];
int N,M,b[MN*3],aa[MN];
struct data{int opt,s,t,tim;}d[MM*2];
inline int getid(int x){return lower_bound(b+1,b+1+N,x)-b;}
//权值线段树 
int tot,rt[MN],ls[MN*60],rs[MN*60],siz[MN*60];
ll sum[MN*60];
#define mid (l+r>>1)
void update(int& t,int l,int r,int pos,int v){
	if(!t)t=++tot;siz[t]+=v;sum[t]+=v*b[pos];
	if(l==r)return;
	if(pos<=mid)update(ls[t],l,mid,pos,v);
	else update(rs[t],mid+1,r,pos,v);
}
int merge(int rt1,int rt2,int l,int r){
	if(!rt1||!rt2)return rt1+rt2;
	if(l==r){siz[rt1]+=siz[rt2];sum[rt1]+=sum[rt2];return rt1;}
	ls[rt1]=merge(ls[rt1],ls[rt2],l,mid);
	rs[rt1]=merge(rs[rt1],rs[rt2],mid+1,r);
	siz[rt1]=siz[ls[rt1]]+siz[rs[rt1]];
	sum[rt1]=sum[ls[rt1]]+sum[rs[rt1]];
	return rt1;
}
ll query(int t,int l,int r,int k){
	if(l==r)return 1ll*k*b[l];
	if(k<=siz[rs[t]])return query(rs[t],mid+1,r,k);
	return sum[rs[t]]+query(ls[t],l,mid,k-siz[rs[t]]);
}
//按秩合并的并查集，用于tarjan和线段树合并 
int par[MN],rnk[MN];
int find(int x){return par[x]==x?x:find(par[x]);}
int stkx[MM],stky[MM],top;
inline void merge(int x,int y){
	x=find(x);y=find(y);
	if(x==y)return;
	if(rnk[x]<rnk[y])swap(x,y);
	par[y]=x;stky[++top]=y;
	if(rnk[x]==rnk[y])rnk[x]++,stkx[top]=x;
}
inline void Merge(int x,int y){
	x=find(x);y=find(y);
	if(x==y)return;
	if(rnk[x]<rnk[y])swap(x,y);
	par[y]=x;
	if(rnk[x]==rnk[y])rnk[x]++;
	rt[x]=merge(rt[x],rt[y],1,N);
}
//tarjan
int dfn[MN],low[MN],stk[MN],Top,idx;
bool vis[MN];
void tarjan(int st){
	dfn[st]=low[st]=++idx;
	vis[stk[++Top]=st]=true;
	for(reg int i=h[st];i;i=nxt[i]){
		if(!dfn[to[i]])tarjan(to[i]),low[st]=min(low[st],low[to[i]]);
		else if(vis[to[i]])low[st]=min(low[st],dfn[to[i]]);
	}
	if(dfn[st]==low[st]){
		reg int loc=stk[Top--];
		vis[loc]=false;
		while(stk[Top+1]!=st){
			vis[stk[Top]]=false;
			merge(loc,stk[Top--]);
		}
	}
}
//整体二分 
int node[MM*2];
struct edge{int s,t,tim;}es[MM],t1[MM],t2[MM];
void solve(int l,int r,int a,int b){
	if(a>b)return;
	if(l==r){
		for(reg int i=a;i<=b;i++)es[i].tim=l;
		return;
	}
	reg int ncnt=0,ttop=top;
	for(reg int i=a,s,t;i<=b;i++)
		if(es[i].tim<=mid){
			s=find(es[i].s);t=find(es[i].t);
			node[++ncnt]=s;node[++ncnt]=t;
			ins(s,t);
		}
	for(reg int i=1;i<=ncnt;i++)
		if(!dfn[node[i]])tarjan(node[i]);
	reg int cnt1=0,cnt2=0;
	for(reg int i=a;i<=b;i++){
		//注意一下，这里应该要同时满足两个条件，即这条边已经出现，且两端在同一强连通分量中 
		if(find(es[i].s)==find(es[i].t)&&es[i].tim<=mid)t1[++cnt1]=es[i];
		else t2[++cnt2]=es[i];
	}
	for(reg int i=1;i<=cnt1;i++)es[a+i-1]=t1[i];
	for(reg int i=1;i<=cnt2;i++)es[a+cnt1+i-1]=t2[i];
	cnt=idx=0;
	for(reg int i=1;i<=ncnt;i++)
		h[node[i]]=dfn[node[i]]=low[node[i]]=0;
	solve(mid+1,r,a+cnt1,b);
	while(top!=ttop){
		par[stky[top]]=stky[top];
		if(stkx[top])rnk[stkx[top]]--;
		top--;
	}
	solve(l,mid,a,a+cnt1-1);
}

int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(reg int i=1;i<=n;i++)scanf("%d",a+i),b[++N]=aa[i]=a[i];
	for(reg int i=1;i<=n;i++)par[i]=i,rnk[i]=1;
	for(reg int i=1,x,y;i<=m;i++){
		scanf("%d%d",&x,&y);
		es[i]=(edge){x,y,0};
		mp[make_pair(x,y)]=i;
	}
	for(reg int i=1,id;i<=q;i++){
		scanf("%d%d%d",opt+i,A+i,B+i);
		if(opt[i]==1)es[mp[make_pair(A[i],B[i])]].tim=q-i+1;
		if(opt[i]==2)b[++N]=aa[A[i]]+B[i],aa[A[i]]+=B[i];
	}
	solve(0,q+1,1,m);
	for(reg int i=1;i<=m;i++)
		d[++M]=(data){1,es[i].s,es[i].t,es[i].tim};
	for(reg int i=1;i<=q;i++)
		if(opt[i]>1)d[++M]=(data){opt[i],A[i],B[i],q-i+1};
	sort(d+1,d+1+M,[](data a,data b){
		return a.tim==b.tim?a.opt<b.opt:a.tim<b.tim;
	});
	sort(b+1,b+1+N);N=unique(b+1,b+1+N)-b-1;
	for(reg int i=1;i<=n;i++)
		update(rt[i],1,N,getid(aa[i]),1),par[i]=i;
	for(reg int i=1;i<=n;i++)par[i]=i,rnk[i]=1;
	memset(Ans,-1,sizeof(Ans));
	for(reg int i=1,x,y;i<=M;i++){
		if(d[i].opt==1){
			Merge(d[i].s,d[i].t);
		}
		if(d[i].opt==2){
			y=find(x=d[i].s);
			update(rt[y],1,N,getid(aa[x]),-1);
			aa[x]-=d[i].t;
			update(rt[y],1,N,getid(aa[x]),1);
		}
		if(d[i].opt==3){
			x=find(d[i].s);
			Ans[q-d[i].tim+1]=query(rt[x],1,N,min(d[i].t,siz[rt[x]]));
		}
	}
	for(reg int i=1;i<=q;i++)
		if(~Ans[i])printf("%lld\n",Ans[i]);
	return 0;
}
```

---

## 作者：win114514 (赞：5)

来一发分治题解吧。

感觉和单纯的整体二分还是有一点区别。

虽然整体二分也能看作分治就是了。

### 思路

首先时光倒流。

删边改为加边。

这没有什么好说的，比较基础。

我们考虑在不断加边时，每两个点是在什么时候变成一个强连通分量里面的。

考虑分治。

首先在 $[l,r]$ 内选取中点 $\text{mid}$。

其中 $[l,r]$ 维护的是时间。

然后将时间小于等于 $\text{mid}$ 的边加入。

跑一次缩点。

这时我们可以发现，边集自然而然的分为了几类。

对于时间小于等于 $\text{mid}$ 的边：

1. 连接在同一个强连通分量的边。

	我们发现它在前面也会发生作用，所以丢向左边。
    
2. 连接在不同的强连通分量的边。

	我们发现它在后面可能发生作用，所以丢向右边。
    
对于时间晚于 $\text{mid}$ 的边，也就是暂时没有加入图中的边：

1. 连接在同一个强连通分量的边。

	我们发现它已经没有用处了，可以直接丢掉。
    
2. 连接在不同的强连通分量的边。

	我们发现它在后面可能发生作用，所以丢向右边。
    
这样，我们就把每一条边恰好的分散在了每一层的各个位置。

假如最后分治到了两端时间相同。

那么我们就可以直接把相应的点也给缩起来。

强连通分量这一部分可以使用可撤销并查集来维护。

所以这部分的时间复杂度为 $O(m\log m\log n)$ 的。

可以求出每个强连通分量的合并是在什么时候。

有了这个以后，其他的就比较简单了。

单点修，区间查，支持合并。

使用线段树合并可以做到 $O(n\log n)$。

这里用的是平衡树启发式合并（因为不影响最终复杂度）$O(n\log n\log v)$。

当然了。这个做法也可以拓展到接近单 $\log$。

前面的分治时不用可撤销并查集，直接使用 $\text{tarjan}$ 的染色。

那么就可以直接用普通并查集了。

后面再使用线段树合并就可以了。

时间复杂度：$O(m\alpha(n)\log m)$。

当然我自己因为写的时候没想那么多直接写的双 $\log$。

### Code

```cpp
/**
 * @file P5163.cpp
 * @author win114514
 * @date 2023-11-24
 * 
 * @copyright Copyright (c) 2023
 * 
 */

#include <bits/stdc++.h>
using namespace std;

#define x first
#define y second
#define mp(x, y) make_pair(x, y)
#define eb(...) emplace_back(__VA_ARGS__)
#define fro(i, x, y) for(int i = (x);i <= (y);i++)
#define pre(i, x, y) for(int i = (x);i >= (y);i--)
#define dbg cerr << "Line " << __LINE__ << ": "
#define EVAL(x) #x " = " << (x)

typedef int64_t i64;
typedef uint32_t u32;
typedef uint64_t u64;
typedef __int128_t i128;
typedef __uint128_t u128;
typedef pair<int, int> PII;

bool ed;

const int N = 200010;
const int mod = 998244353;

int n, m, q, tt, s[N], fa[N], sz[N];
int top, tot, vs[N], dfn[N], low[N], stk[N];
map<PII, int> mp; PII e[N], add[N], sk[N];
struct Node { int op, a, b; } d[N];
vector<int> to[N], edge; vector<PII> mer;
vector<tuple<int, int, int>> fin;
i64 ans[N];

inline int gf(int x)
	{ return (x == fa[x] ? x : gf(fa[x])); }
inline void merge(int x, int y)
{
	x = gf(x), y = gf(y);
	if(x == y) return;
	if(sz[x] > sz[y]) swap(x, y);
	fa[x] = y, sz[y] += sz[x];
	sk[++tt] = mp(x, y), mer.eb(x, y);
}
inline void rev(int t)
{
	while(tt > t)
		fa[sk[tt].x] = sk[tt].x,
		sz[sk[tt].y] -= sz[sk[tt].x], tt--;
}
inline void tarjan(int x)
{
	vs[x] = 1, dfn[x] = low[x] = ++tot, stk[++top] = x;
	for(auto i : to[x])
		if(!dfn[i]) tarjan(i), low[x] = min(low[x], low[i]);
		else if(vs[i]) low[x] = min(low[x], dfn[i]);
	if(dfn[x] == low[x])
	{
		vs[x] = 0;
		while(stk[top--] != x)
			vs[stk[top + 1]] = 0,
			merge(stk[top + 1], x);
	}
}
inline void solve(int l, int r)
{
	if(l == r)
	{
		vector<int> node; tot = top = 0;
		for(auto i : edge) if(gf(add[i].x) != gf(add[i].y))
			to[gf(add[i].x)].eb(gf(add[i].y)), node.eb(gf(add[i].x));
		for(auto i : node) dfn[i] = low[i] = vs[i] = 0;
		for(auto i : node) if(!dfn[i]) tarjan(i);
		for(auto i : mer) fin.eb(i.x, i.y, l); mer.clear();
		for(auto i : node) to[i].clear();
		return;
	}
	int mid = (l + r) >> 1, cur = tt;
	vector<int> node{}; tot = top = 0;
	for(auto i : edge) if(i <= mid && gf(add[i].x) != gf(add[i].y))
		to[gf(add[i].x)].eb(gf(add[i].y)), node.eb(gf(add[i].x));
	for(auto i : node) dfn[i] = low[i] = vs[i] = 0;
	for(auto i : node) if(!dfn[i]) tarjan(i);
	vector<int> ls, rs;
	for(auto i : edge) if(gf(add[i].x) != gf(add[i].y))
		rs.eb(i);
	for(auto i : edge) if(i <= mid && gf(add[i].x) == gf(add[i].y))
		ls.eb(i);
	rev(cur); for(auto i : node) to[i].clear(); mer.clear();
	edge = ls, solve(l, mid);
	edge = rs, solve(mid + 1, r);
}
namespace Solve
{
const int N = ::N<<1;
int ls[N], rs[N], id[N], tot;
i64 sz[N], vl[N], al[N], rt[N], rd[N];
inline int nd(int x)
	{ return ++tot, sz[tot] = 1, vl[tot] = al[tot] = x, rd[tot] = rand(), tot; }
inline void push(int x)
	{ sz[x] = 1 + sz[ls[x]] + sz[rs[x]], al[x] = vl[x] + al[ls[x]] + al[rs[x]]; }
inline int mer(int x, int y)
{
	if(!x || !y) return x | y;
	if(rd[x] < rd[y]) return rs[x] = mer(rs[x], y), push(x), x;
	return ls[y] = mer(x, ls[y]), push(y), y;
}
inline void spl(int p, int k, int &x, int &y)
{
	if(!p) return x = y = 0, void();
	if(k > sz[ls[p]])
		spl(rs[p], k - sz[ls[p]] - 1, rs[x = p], y);
	else spl(ls[p], k, x, ls[y = p]); push(p);
}
inline void spll(int p, int k, int &x, int &y)
{
	if(!p) return x = y = 0, void();
	if(k > vl[p]) spll(ls[p], k, x, ls[y = p]);
	else spll(rs[p], k, rs[x = p], y); push(p);
}
inline int gf(int x)
	{ return (fa[x] == x ? fa[x] : fa[x] = gf(fa[x])); }
inline void dfs(int x, int y)
{
	if(!x) return;
	dfs(ls[x], y), dfs(rs[x], y); int a, b;
	spll(rt[y], vl[x], a, b);
	ls[x] = rs[x] = 0, sz[x] = 1, al[x] = vl[x];
	rt[y] = mer(a, mer(x, b));
}
inline void merge(int x, int y)
{
	x = gf(x), y = gf(y);
	if(sz[rt[x]] < sz[rt[y]])
		swap(x, y);
	fa[y] = x, dfs(rt[y], x);
}
inline void del(i64 &rt, i64 x)
{
	int a, b, c;
	spll(rt, x, a, b);
	spl(a, sz[a] - 1, a, c);
	rt = mer(a, b);
}
inline void ins(i64 &rt, i64 x)
{
	int a, b; spll(rt, x, a, b);
	rt = mer(a, mer(nd(x), b));
}
inline void solve()
{
	int res = m, it = 0;
	iota(fa + 1, fa + n + 1, 1);
	fro(i, 1, q)
	{
		if(d[i].op == 1) res--;
		if(d[i].op == 2) s[d[i].a] += d[i].b;
		id[i] = res;
	}
	fro(i, 1, n) rt[i] = nd(s[i]);
	pre(i, q, 1)
	{
		while(it < fin.size() && id[i] >= get<2>(fin[it]))
			merge(get<0>(fin[it]), get<1>(fin[it])), it++;
		if(d[i].op == 3)
		{
			int x = gf(d[i].a), y, z;
			spl(rt[x], d[i].b, y, z);
			ans[i] = al[y], rt[x] = mer(y, z);
		}
		else if(d[i].op == 2)
		{
			int x = gf(d[i].a), a, b;
			del(rt[x], s[d[i].a]);
			s[d[i].a] -= d[i].b;
			ins(rt[x], s[d[i].a]);
		}
	}
}
}
inline void solve()
{
	cin >> n >> m >> q; int tot{};
	fro(i, 1, n) cin >> s[i];
	fro(i, 1, m) cin >> e[i].x >> e[i].y, mp[e[i]] = 1;
	fro(i, 1, q) cin >> d[i].op >> d[i].a >> d[i].b, ans[i] = -1;
	fro(i, 1, q) if(d[i].op == 1)
		add[++tot] = mp(d[i].a, d[i].b), mp[mp(d[i].a, d[i].b)] = 0;
	for(auto i : mp) if(i.y == 1)
		add[++tot] = i.x;
	reverse(add + 1, add + tot + 1);
	fro(i, 1, tot) edge.eb(i);
	iota(fa + 1, fa + n + 1, 1);
	fill(sz + 1, sz + n + 1, 1);
	solve(1, tot), Solve::solve();
	fro(i, 1, q) if(ans[i] != -1) cout << ans[i] << "\n";
}

bool st;

signed main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	double Mib = fabs((&ed-&st)/1048576.), Lim = 500;
	cerr << " Memory: " << Mib << "\n", assert(Mib<=Lim);
	srand(random_device{}()), solve();
	return 0;
}
```

---

## 作者：SSerxhs (赞：4)

好玄妙的题。

操作只有删边，套路反转操作顺序转化为加边。

这个题如果放在无向图上就很好做了，$1$ 操作相当于合并两个连通块，$2$ 操作相当于单点修改，$3$ 操作相当于查连通块内前 $k$ 大的和，这可以对每个节点建动态开点权值线段树， $2$ 操作直接修改，$1$ 操作线段树合并，$3$ 操作在线段树上二分就可以了。

考虑如何把这个问题转化到无向图上。不难看出，题目说的地区即为强连通分
量。如果把强连通关系看成一条无向边，那么就可以转化到无向图的情况了。

称“内边”为端点在同一强连通分量的边。不难看出，仅保留内边并将内边变为无向边的图的每个连通块对应了原图的一个强连通分量，这提示我们：如果知道每条内边两端进入属于强连通分量的时间 $t$（即无向边连接的时间），那么按照时间排序后，可以按照无向图来做。

如果只求一条内边的时间 $t$，经典的做法是二分，每次加入 $T_i\le mid$ 的边并 tarjan 判定。求所有边的时间 $t$，可以考虑整体二分。**注意 $t$ 和 $T$ 是不一样的（$T$ 是原边加入时间）。**

考虑会遇到什么问题。整体二分的一个关键处理是：当二分答案区间 $[mid+1,r]$ 时，$[l,mid]$ 贡献必须考虑。在主席树模板等题目中的处理手段是 $kth\gets kth-x$，其中 $x$ 是 $[l,mid]$ 对答案的贡献，但强连通关系显然不具可减性。同时，也不能暴力保留 $T_i\in [l,mid]$ 的边，否则复杂度不正确。

一个对于上述复杂度不正确做法的剪枝的思路是先把 $[l,mid]$ 形成的强连通分量缩点，对于 $t_i\le mid $ （由整体二分的性质，到这一步已经可以判断每个边 $t$ 和 $mid$ 的关系）的边，它已经成为了内边，对 $[mid+1,r]$ 没有贡献，可以去掉。（如果始终先做 $[l,mid]$ 再做 $[mid+1,r]$，那么相当于这条边永久无效了。）对于 $t_i>mid$ 的边，它仍然可能对后面做贡献，继续保留这条边。

看起来好像有什么不对劲的？

$t_i>mid$，意味着这条边本来就会被整体二分扔到 $[mid+1,r]$ 去。从整体二分复杂度正确性的角度，只要每次二分过程中每个操作被分到至多一侧，且每次操作都和操作序列区间长度成线性关系就可以保证复杂度。那么在 $[mid+1,r]$ 有用的边本就是答案在 $[mid+1,r]$ 的边，即有用的边数也和操作序列成线性关系。

那么整体二分是正确的。至于缩点，用并查集维护一下就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned int ui;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
std::mt19937 rnd(time(0));
inline int sj(int n)
{
	unsigned int x=rnd();
	return x%n+1;
}
#define rand fst
template<typename typC> void read(register typC &x)
{
	register int c=getchar(),fh=1;
	while ((c<48)||(c>57))
	{
		if (c=='-') {c=getchar();fh=-1;break;}
		c=getchar();
	}
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	x*=fh;
}
template<typename typC, typename... Args> void read(typC &first, Args& ... args) {
	read(first);
	read(args...);
}
template<typename typC> void read(register typC *a,int num)
{
	for (register int i=1;i<=num;i++) read(a[i]);
}
template<typename typC> void write(register typC x)
{
	if (x<0) putchar('-'),x=-x;
	static int st[100];
	register int tp=1;
	register typC y;st[1]=x%10;x/=10;
	while (x) y=x/10,st[++tp]=x-y*10,x=y;++tp;
	while (--tp) putchar(st[tp]|48);
}
template<typename typC> void write(register typC *a,register int num)
{
	for (register int i=1;i<=num;i++) write(a[i]),putchar(i==num?10:32);
}
template<typename typC> typC ab(register typC x)
{
	if (x<0) return -x;
	return x;
}
#define space(x) write(x),putchar(32)
#define enter(x) write(x),putchar(10)
typedef pair<int,int> pa;
struct P
{
	int t,u,v;
	P(int c=0,int a=0,int b=0):t(c),u(a),v(b){}
};
struct Q
{
	int t,u,v,typ,id;
	Q(int c=0,int a=0,int b=0,int d=0,int e=0):t(c),u(a),v(b),typ(d),id(e){}
	bool operator<(const Q &o) const {return t<o.t;}
};
const int N=1e5+2,M=2e5+2,K=4e5+2,O=1e7,inf=1e9;
struct dsu
{
	int f[N],rk[N],st[N][2];
	int tp;
	void init(int n)
	{
		tp=0;
		for (int i=1;i<=n;i++) f[i]=i,rk[i]=1;
	}
	int getf(int x)
	{
		while (f[x]!=x) x=f[x];
		return x;
	}
	void uni(int x,int y)
	{
		x=getf(x);y=getf(y);
		if (x==y) return;
		if (rk[x]>rk[y]) swap(x,y);
		st[++tp][0]=x,st[tp][1]=rk[y];
		f[x]=y;if (rk[x]==rk[y]) ++rk[y];
	}
	int fix()
	{
		return tp;
	}
	void roll(int ntp)
	{
		while (tp>ntp) rk[f[st[tp][0]]]=st[tp][1],f[st[tp][0]]=st[tp][0],--tp;
	}
};
struct tarjan
{
	vector<int> lj[N];
	int dfn[N],low[N],st[N],f[N],a[N];
	int n,tp,cnt,fs;
	bool ed[N];
	void init(int nn,int *b)
	{
		n=nn;tp=0;
		memcpy(a+1,b+1,n<<2);
		for (int i=1;i<=n;i++) ed[a[i]]=0;
		for (int i=1;i<=n;i++) lj[a[i]].clear();
	}
	void add(int x,int y)
	{
		lj[x].push_back(y);
	}
	void dfs(int x)
	{
		dfn[x]=low[x]=++cnt;
		ed[st[++tp]=x]=1;
		for (auto v:lj[x]) if (!dfn[v]) dfs(v),low[x]=min(low[x],low[v]); else if (ed[v]) low[x]=min(low[x],dfn[v]);
		if (dfn[x]==low[x])
		{
			++fs;st[tp+1]=0;
			while (st[tp+1]!=x)
			{
				ed[st[tp]]=0;
				f[st[tp--]]=fs;
			}
		}
	}
	void cal()
	{
		for (int i=1;i<=n;i++) dfn[a[i]]=0;cnt=0;fs=0;
		for (int i=1;i<=n;i++) if (!dfn[a[i]]) dfs(a[i]);
	}
};
dsu d;
tarjan g;
map<pa,int> mp;
P lb[M];
Q xw[M],w[M],st1[M],st2[M],o[K];
int c[O][2],siz[O];
ll ans[M],s[O];
int a[N],st[N],t[M],fir[N],nu[M],nv[M],f[N],rt[N];
int T,n,m,q,i,j,k,x,y,z,la,ksiz,ks,qs,tp,tp1,tp2,ds,os;
bool ed[N];
void ztef(int l,int r,int ql,int qr)
{
	if (l>r||ql>qr) return;
	if (l==r)
	{
		for (int i=ql;i<=qr;i++) t[w[i].id]=l;
		return;
	}
	int mid=l+r>>1,i,fp=d.fix(),u,v,m;tp=tp1=tp2=0;
	for (i=ql;i<=qr;i++) nu[i]=d.getf(w[i].u),nv[i]=d.getf(w[i].v);
	for (i=ql;i<=qr&&w[i].t<=mid;i++) if ((u=nu[i])!=(v=nv[i]))
	{
		if (!ed[u]) st[++tp]=u,ed[u]=1;
		if (!ed[v]) st[++tp]=v,ed[v]=1;
	} else throw;
	for (i=1;i<=tp;i++) ed[st[i]]=0;
	for (i=1;i<=g.fs;i++) fir[i]=0;
	g.init(tp,st);
	for (i=ql;i<=qr&&w[i].t<=mid;i++) if (nu[i]!=nv[i]) g.add(nu[i],nv[i]);
	g.cal();
	for (i=1;i<=tp;i++) if (!fir[g.f[st[i]]]) fir[g.f[st[i]]]=st[i]; else d.uni(fir[g.f[st[i]]],st[i]);
	for (i=ql;i<=qr;i++) if (d.getf(nu[i])==d.getf(nv[i])) st1[++tp1]=w[i]; else st2[++tp2]=w[i];
	m=ql+tp1;
	for (i=1;i<=tp1;i++) w[ql+i-1]=st1[i];
	for (i=1;i<=tp2;i++) w[m+i-1]=st2[i];
	ztef(mid+1,r,m,qr);d.roll(fp);
	ztef(l,mid,ql,m-1);
}
void inc(int &x,int v,int l=0,int r=inf)
{
	if (!x) x=++ds;
	s[x]+=v;++siz[x];
	if (l==r) return;
	int mid=l+r>>1;
	if (v<=mid) inc(c[x][0],v,l,mid); else inc(c[x][1],v,mid+1,r);
}
void dec(int &x,int v,int l=0,int r=inf)
{
	if (!x) x=++ds;
	s[x]-=v;--siz[x];
	if (!siz[x]) return x=0,void();
	if (l==r) return;
	int mid=l+r>>1;
	if (v<=mid) dec(c[x][0],v,l,mid); else dec(c[x][1],v,mid+1,r);
}
void merge(int &x,int y)
{
	if (x&&y)
	{
		s[x]+=s[y];siz[x]+=siz[y];
		merge(c[x][0],c[y][0]);
		merge(c[x][1],c[y][1]);
	} else x|=y;
}
int getf(int x)
{
	if (f[x]==x) return x;
	return f[x]=getf(f[x]);
}
ll find(int x,int kth)
{
	ll res=0;
	int l=0,r=1e9;
	while (kth&&l<r) if (siz[c[x][1]]>kth) x=c[x][1],l=(l+r>>1)+1; else res+=s[c[x][1]],kth-=siz[c[x][1]],x=c[x][0],r=l+r>>1;
	return res+(ll)l*kth;
}
int main()
{
	read(n,m,q);
	read(a,n);
	for (i=1;i<=m;i++)
	{
		read(lb[i].u,lb[i].v);lb[i].t=q+1;assert(lb[i].u!=lb[i].v);
		assert(mp.find(pa(lb[i].u,lb[i].v))==mp.end());
		mp[pa(lb[i].u,lb[i].v)]=i;
	}
	for (i=1;i<=q;i++)
	{
		read(xw[i].typ,xw[i].u,xw[i].v);xw[i].t=q-i+1;
		if (xw[i].typ==1)
		{
			w[++ks]=xw[i];
			lb[w[ks].id=mp[pa(xw[i].u,xw[i].v)]].t=q-i+1;
		}
		else if (xw[i].typ==2) a[xw[i].u]+=xw[i].v;
		else xw[i].id=++qs;
	}
	for (i=1;i<=m;i++) if (lb[i].t==q+1) w[++ks]=Q(0,lb[i].u,lb[i].v,0,i);
	reverse(w+1,w+m+1);assert(ks==m);d.init(n);
	ztef(0,q+1,1,m);
	for (i=1;i<=n;i++) inc(rt[i],a[i]);
	for (i=1;i<=n;i++) f[i]=i;
	for (i=q;i;i--) if (xw[i].typ!=1) o[++os]=xw[i];
	for (i=1;i<=m;i++) o[++os]=Q(t[i],lb[i].u,lb[i].v,1,0);
	sort(o+1,o+os+1);
	for (i=1;i<=os;i++)
	{
		if (o[i].typ==1)
		{
			x=getf(o[i].u);y=getf(o[i].v);
			if (x==y) continue;
			merge(rt[x],rt[y]);f[y]=x;
		}
		if (o[i].typ==2)
		{
			x=getf(o[i].u);
			dec(rt[x],a[o[i].u]);
			inc(rt[x],a[o[i].u]-=o[i].v);
		}
		if (o[i].typ==3)
		{
			x=rt[getf(o[i].u)];
			ans[o[i].id]=siz[x]<=o[i].v?s[x]:find(x,o[i].v);
		}
	}
	for (i=1;i<=qs;i++) enter(ans[i]);
}
```

---

## 作者：Purslane (赞：3)

# Solution

有一个很简单的想法：倒序加边，启发式合并维护所有强联通分量上的点权的有序排名。但是好像不会动态维护 SCC 啊。（注：这一部分可以用平衡树启发式合并，也可以直接线段树合并）

考虑计算出 $u \to v$ 这条边什么时候能将 $u$ 和 $v$ 合并到同一个强联通分量里，这时候就可以当做无向边。（强联通关系是具有传递性的）

考虑整体二分。我们需要想办法保证：对 $[l,r]$ 做整体二分时，前缀 $[1,mid]$ 需要加入 SCC 缩点的过程中。

因此在整体二分的过程中，如果我们结束了 $[l,r]$ 的流程，应当保证它已经缩完点了。

对于每条边 $u \to v$，维护它目前已知的、可能在同一个强联通分量的时间为 $t_e$。考虑目前要处理 $[l,r]$，集合 $S$ 为当前所有 $l \le t_e \le r$ 的边。而如果 $t_e < l$，它已经被加入。

对于这种 $t_e < l$ 的边，**它一定不会出现不在同一个 SCC 中的情况**（所以不是 $id_e < l$ 的边！！！我在理解这一步上卡了好久 /ll）因此它们对强联通性的贡献一定是**合并若干个节点**。

考虑拉出 $l \le t_e \le mid$ 的所有边构成的导出子图，对他跑 tarjan（只有 $O(r-l)$ 个点和边）。如果他在一个联通分量里，那么 $t_e$ 不变，向左递归；否则，$t_e$ 变为 $mid+1$，和之前未被处理的边一起向右递归。

这时候处理 $l \le t_e \le mid$ 对 $[mid+1,r]$ 的贡献就是容易的：对点进行重标号即可。

复杂度 $O(m \log m)$。

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=500000+10;
int n,m,q,lsh[MAXN],tot,s[MAXN],rt[MAXN];
map<pair<int,int>,int> qid;
struct Edge {int x,y,t;}e[MAXN];
int op[MAXN],a[MAXN],b[MAXN];
#define mid (l+r>>1)
namespace DS {
	struct NODE {int lson,rson,cnt,s;}t[MAXN*20];
	int tot;
	queue<int> bin;
	int get_node(void) {
		int ans=0;
		if(!bin.empty()) ans=bin.front(),bin.pop();
		else ans=++tot;
		return t[ans]={0,0,0,0},ans;	
	}
	void update(int& u,int l,int r,int p,int v,int op) {
		if(!u) u=get_node();
		t[u].cnt+=op,t[u].s+=v;
		if(l!=r) {
			if(p<=mid) update(t[u].lson,l,mid,p,v,op);
			else update(t[u].rson,mid+1,r,p,v,op);	
		}
		return ;
	}
	void merge(int &u,int &v,int l,int r) {
		if(!v||!u) return u=u|v,v=0,void();
		merge(t[u].lson,t[v].lson,l,mid),merge(t[u].rson,t[v].rson,mid+1,r);
		return t[u].cnt+=t[v].cnt,t[u].s+=t[v].s,bin.push(v),v=0,void();	
	}
	int query(int u,int l,int r,int s) {
		if(!u||s<0) return 0;
		if(s>=t[u].cnt) return t[u].s;
		if(l==r) return lsh[l]*s;
		return query(t[u].rson,mid+1,r,s)+query(t[u].lson,l,mid,s-t[t[u].rson].cnt);
	}
}
vector<pair<int,int>> add[MAXN];
vector<int> G[MAXN];
int tk,dfn[MAXN],low[MAXN],col[MAXN],in[MAXN],fa[MAXN];
vector<int> tmp;
void init(void) {
	for(auto id:tmp) col[id]=0,G[id].clear(),in[id]=dfn[id]=0;
	tmp.clear(),tk=0;
	return ;	
}
stack<int> st;
int find(int k) {return (fa[k]==k)?k:(fa[k]=find(fa[k]));}
void tarjan(int u) {
	dfn[u]=low[u]=++tk,in[u]=1,st.push(u);
	for(auto v:G[u]) {
		if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);
		else if(in[v]) low[u]=min(low[u],dfn[v]);	
	}
	if(dfn[u]==low[u]) {
		while(st.top()!=u) col[st.top()]=u,in[st.top()]=0,st.pop();
		col[st.top()]=u,in[st.top()]=0,st.pop();
	}
	return ;
}
void add_edge(int u,int v) {return G[u].push_back(v),tmp.push_back(v),tmp.push_back(u),void();}
void solve(int l,int r,vector<int> vc) {
	if(l==r||vc.empty()) return ;
	vector<int> ll,rr;
	for(auto id:vc) if(e[id].t<=mid) ll.push_back(id); else rr.push_back(id);
	init();
	for(auto id:ll) add_edge(e[id].x,e[id].y);
	for(auto id:tmp) if(!dfn[id]) tarjan(id);
	for(auto id:rr) {
		if(col[e[id].x]) e[id].x=col[e[id].x];
		if(col[e[id].y]) e[id].y=col[e[id].y];
	}
	vector<int> fll;
	for(auto id:ll) {
		if(col[e[id].x]==col[e[id].y]) fll.push_back(id);
		else rr.push_back(id),e[id].x=col[e[id].x],e[id].y=col[e[id].y],e[id].t=mid+1;
	}
	solve(l,mid,fll),solve(mid+1,r,rr);
	return ;
}
int calc_id(int x) {return lower_bound(lsh+1,lsh+tot+1,x)-lsh;}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	ffor(i,1,n) cin>>s[i],lsh[++tot]=s[i];
	ffor(i,1,m) cin>>e[i].x>>e[i].y,qid[{e[i].x,e[i].y}]=i;
	ffor(i,1,q) {
		cin>>op[i]>>a[i]>>b[i];
		if(op[i]==1) e[qid[{a[i],b[i]}]].t=q-i+1;
		else if(op[i]==2) s[a[i]]+=b[i],lsh[++tot]=s[a[i]];
	}
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	vector<int> vc;
	ffor(i,1,m) vc.push_back(i);
	solve(0,q+1,vc);
	ffor(i,1,m) add[q+1-e[i].t].push_back({e[i].x,e[i].y});
	ffor(i,1,n) fa[i]=i;
	ffor(i,1,n) DS::update(rt[i],1,tot,calc_id(s[i]),s[i],1);
	vector<int> ans;
	roff(i,q+1,1) {
		for(auto pr:add[i]) {
			int x=pr.first,y=pr.second;
			if(find(x)!=find(y)) DS::merge(rt[find(x)],rt[find(y)],1,tot),fa[find(y)]=find(x);
		}
		if(i==q+1) continue ;
		if(op[i]==2) {
			int r=find(a[i]);
			DS::update(rt[r],1,tot,calc_id(s[a[i]]),-s[a[i]],-1);
			s[a[i]]-=b[i];	
			DS::update(rt[r],1,tot,calc_id(s[a[i]]),s[a[i]],1);
		}
		else if(op[i]==3) {
			int r=find(a[i]);
			ans.push_back(DS::query(rt[r],1,tot,b[i]));	
		}
	}
	reverse(ans.begin(),ans.end());
	for(auto id:ans) cout<<id<<'\n';
	return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：3)

[更好的阅读体验](https://www.cnblogs.com/WrongAnswer90-home/p/17930208.html)

[P5163 WD与地图](https://www.luogu.com.cn/problem/P5163)

喵喵题，但其实没有那么难。

删边倒序转成加边是显然的，询问可以通过值域线段树合并实现，修改，合并，查询都是好做的。考虑如何维护动态加边的 SCC。

难点是每个时刻缩点后的图是一个 DAG，并不像无向图的搜索树一样好维护，而且新加入的边可能不会立刻构成 SCC 而是和再之后加入的边构成。

简化问题，可以通过计算出每条边被并到某个 SCC 里的时刻来维护。发现每条边只会被并到某个 SCC 里一次（之后的合并是边所在的 SCC 和其他的 SCC 合并，和这条边无关），满足单调性。并且需要对于每条边都求出这个时间，考虑整体二分。

简单的想法是，对于当前的二分区间，加入 $l\sim mid$ 间的新边和这个区间询问（询问是指对一条边什么时候合并的询问）的所有边，跑一遍 Tarjan 求出 SCC，对于所有询问边，已经属于一个 SCC 的全部向左侧递归。对于在右侧的，先加入左侧的所有边，然后向右侧递归。

正确性：右侧的边一定不会对左侧的边造成影响，否则右侧的边就已经被合并了，应当向左递归。

但是上面的复杂度是假的，原因很显然，每次 Tarjan 的复杂度和 $r$ 有关而不是和 $r-l+1$ 有关，其没有利用好 SCC 的性质，加入了大量的无用边导致复杂度退化。考虑一堆边，这堆边一起构成一个 SCC，我们其实只需要记录这些点是一个 SCC 即可而不用再次加边，考虑并查集维护。

把上面的做法稍作改进：跑完 Tarjan 之后，把每个 SCC 内所有点用并查集合并在一起，然后向右侧递归。每次加边的时候加入 $(find(x)-find(y))$ 这样每次跑 Tarjan 的时候复杂度就挂在了边数上。然后向左侧递归的时候需要把并查集取消，可以用可撤销并查集实现，总复杂度 $\mathcal O(n\log^2n)$。（另一种实现方式是把右侧边进行重标号，可以消去并查集的一只 $\log$，本人采用并查集写法）

注意实现细节：询问边有一部分就是新边，二分的在某个区间一个已经被删掉的询问边可能还没被加进来；注意特判开始就在 SCC 里的边和最后也没被合并的边。细节挺多的，写了一上午，但是一遍过？离谱。

也算是比较重工业的题了，代码写得很丑，见谅/wul。

```cpp
	int n,m,q,len,all,vis[200010],ans[200010],a[200010],numa[400010];
	pii bb[200010];
	tup b[200010],c[200010],le[200010],ri[200010],d[200010];
	map<pii,int> hash;
	vector<pii> edge;
	vector<int> ver,del[200010],ve[200010];
	#define id(x,y) (x-1)*100000+y
	namespace RDSU
	{
		int fa[200010],siz[200010];
		stack<int> st;
		inline void init(){for(int i=1;i<=n;++i)siz[i]=1,fa[i]=i;}
		inline int find(int x){while(x!=fa[x])x=fa[x];return x;}
		inline bool Dmerge(int x,int y)
		{
			if((x=find(x))==(y=find(y)))return 0;
			if(siz[x]>siz[y])st.e(y),siz[x]+=siz[y],fa[y]=x;
			else st.e(x),siz[y]+=siz[x],fa[x]=y;
			return 1;
		}
		inline void cancel(){int x=st.top();st.pop();siz[fa[x]]-=siz[x],fa[x]=x;}
	}
	using namespace RDSU;
	namespace Segment
	{
		int root[200010],cnt;
		struct{int ls,rs,val;ll sum;}t[16000010];
		inline void update(int now)
		{
			t[now].val=t[t[now].ls].val+t[t[now].rs].val;
			t[now].sum=t[t[now].ls].sum+t[t[now].rs].sum;
		}
		void change(int&now,int x,int y,int L=0,int R=len)
		{
			if(!now)now=++cnt;
			t[now].val+=numa[x]*y,t[now].sum+=y;
			if(L==R)return void();
			int mid=L+((R-L)>>1);
			if(x<=mid)change(t[now].ls,x,y,L,mid);
			else change(t[now].rs,x,y,mid+1,R);
		}
		int merge(int x,int y,int L=0,int R=len)
		{
			if(!x||!y)return x|y;
			if(L==R)return t[x].val+=t[y].val,t[x].sum+=t[y].sum,x;
			int mid=L+((R-L)>>1);
			t[x].ls=merge(t[x].ls,t[y].ls,L,mid);
			t[x].rs=merge(t[x].rs,t[y].rs,mid+1,R);
			return update(x),x;
		}
		int ask(int now,int x,int L=0,int R=len)
		{
			if(x>=t[now].sum)return t[now].val;
			if(!x)return 0;
			if(L==R)return numa[L]*x;
			int mid=L+((R-L)>>1);
			if(x<=t[t[now].rs].sum)return ask(t[now].rs,x,mid+1,R);
			return ask(t[now].rs,x,mid+1,R)+ask(t[now].ls,x-t[t[now].rs].sum,L,mid);
		}
		void print(int p,int L=0,int R=len)
		{
			if(!p)return;
			if(L==R)return write('(',L,',',t[p].sum,')');
			int mid=L+((R-L)>>1);
			print(t[p].ls,L,mid),print(t[p].rs,mid+1,R);
		}
	}
	using namespace Segment;
	namespace Connection
	{
		int dfn[200010],low[200010],tot,num,col[200010],ins[200010];
		stack<int> st;
		void tarjan(int x)
		{
			st.e(x),dfn[x]=low[x]=++tot,ins[x]=1;
			for(auto to:ve[x])
			{
				if(!dfn[to])tarjan(to),low[x]=min(low[x],low[to]);
				else if(ins[to])low[x]=min(low[x],dfn[to]);
			}
			if(dfn[x]==low[x])
			{
				int y;++num;
				do ins[y=st.top()]=0,col[y]=num,st.pop();while(y!=x);
			}
		}
		
	}
	using namespace Connection;
	bitset<200010> viss;
	void solve(int l,int r,int L,int R)
	{
		if(L==R)
		{
			for(int i=l;i<=r;++i)
			if(vis[b[i].z]!=inf)
			del[L].eb(b[i].z);
			return;
		}
		if(l>r)return;
		int mid=L+((R-L)>>1),len1=0,len2=0;
		for(int i=L,x,y;i<=mid;++i)
		{
			if(vis[d[i].z]==inf)continue;
			x=find(d[i].x),y=find(d[i].y);
			if(!viss[x])viss[x]=1,ver.eb(x);
			if(!viss[y])viss[y]=1,ver.eb(y);
			ve[x].eb(y);
		}
		for(int i=l;i<=r;++i)
		{
			if(vis[b[i].z]>mid)continue;
			bb[i].fi=find(b[i].x),bb[i].se=find(b[i].y);
			if(!viss[bb[i].fi])viss[bb[i].fi]=1,ver.eb(bb[i].fi);
			if(!viss[bb[i].se])viss[bb[i].se]=1,ver.eb(bb[i].se);
			ve[bb[i].fi].eb(bb[i].se);
		}
		for(auto j:ver)if(!dfn[j])tarjan(j);
		vector<pii> ved;
		for(int i=l;i<=r;++i)
		{
			if(vis[b[i].z]<=mid&&col[bb[i].fi]==col[bb[i].se])
			ved.eb(bb[i].fi,bb[i].se),le[++len1]=b[i];
			else ri[++len2]=b[i];
		}
		for(auto j:ver)low[j]=dfn[j]=col[j]=0,ve[j].clear();
		ver.clear(),tot=num=0;
		for(int i=L;i<=mid;++i)viss[find(d[i].x)]=viss[find(d[i].y)]=0;
		for(int i=l;i<=r;++i)viss[bb[i].fi]=viss[bb[i].se]=0;
		for(int i=1;i<=len1;++i)b[l+i-1]=le[i];
		for(int i=1;i<=len2;++i)b[l+len1+i-1]=ri[i];
		solve(l,l+len1-1,L,mid);
		for(auto p:ved)Dmerge(p.fi,p.se);
		solve(l+len1,r,mid+1,R);
	}
	inline int vfind(int x){return lower_bound(numa+1,numa+1+len,x)-numa;}
	inline void Merge(int x,int y){if((x=find(x))!=(y=find(y)))root[x]=root[y]=merge(root[x],root[y]),Dmerge(x,y);}
	inline bool cmp(tup t1,tup t2){return t1.z<t2.z;}
	inline void mian()
	{
		read(n,m,q),init();
		for(int i=1;i<=n;++i)read(a[i]),numa[++len]=a[i];
		for(int i=1;i<=m;++i)read(b[i].x,b[i].y),hash[mp(b[i].x,b[i].y)]=b[i].z=i;
		for(int i=1;i<=q;++i)
		{
			read(c[i].x,c[i].y,c[i].z);
			if(c[i].x==1)d[++all]=b[hash[mp(c[i].y,c[i].z)]],vis[hash[mp(c[i].y,c[i].z)]]=all;
			if(c[i].x==2)numa[++len]=(a[c[i].y]+=c[i].z);
		}
		for(int i=1;i<=m;++i)if(vis[i])vis[i]=all-vis[i]+1;
		for(int i=1;i<=m;++i)ve[b[i].x].eb(b[i].y);
		for(int i=1;i<=n;++i)if(!dfn[i])tarjan(i);
		for(int i=1;i<=m;++i)if(col[b[i].x]!=col[b[i].y])vis[i]=inf;
		tot=num=0;
		for(int i=1;i<=n;++i)dfn[i]=low[i]=0,ve[i].clear(),col[i]=0;
		sort(numa+1,numa+1+len),len=unique(numa+1,numa+1+len)-numa-1;
		reverse(d+1,d+1+all),reverse(c+1,c+1+q),init();
		if(all)solve(1,m,1,all),sort(b+1,b+1+m,cmp);
		for(int i=1;i<=n;++i)change(root[i],vfind(a[i]),1);
		for(int i=1;i<=m;++i)if(!vis[i])ve[b[i].x].eb(b[i].y);
		for(int i=1;i<=n;++i)if(!dfn[i])tarjan(i);
		for(int i=1;i<=m;++i)if(!vis[i]&&col[b[i].x]==col[b[i].y])Merge(b[i].x,b[i].y);
		for(int i=1,t=0,x,y;i<=q;++i)
		{
			if(c[i].x==1)
			{
				++t;
				for(auto j:del[t])
				{
					if((x=find(b[j].x))!=(y=find(b[j].y)))
					Merge(x,y);
				}
			}
			else if(c[i].x==2)
			{
				change(root[find(c[i].y)],vfind(a[c[i].y]),-1);
				change(root[find(c[i].y)],vfind(a[c[i].y]-=c[i].z),1);
			}
			else ans[i]=ask(root[find(c[i].y)],c[i].z);
		}
		for(int i=q;i>=1;--i)if(c[i].x==3)write(ans[i],'\n');
```

---

## 作者：墨舞灵纯 (赞：3)

### 题意

[戳我](https://www.luogu.com.cn/problem/P5163)

### 题解

一开始看错了以为是无向图，直接上离线倒序并查集，写了一会儿觉得不对劲，发现是有向图。

考虑有向图为什么不能直接用并查集合并：边有方向，所以不能确定 $u,v$ 到底什么时候被并起来。

于是我们想要对每一对 $(u,v)$ 求出一个时间点 $t$ ，$t$ 表示在 $[0,t]$ 时间内 $(u,v)$ 在同一个强连通分量内。

发现如果 $t+1$ 时在同一强连通分量，$t$ 时也在，所以考虑二分 $t$。暴力做法是每次建一张图对每条边跑二分。

考虑优化。首先发现有很多 $(u,v)$ 的对应答案都是 $t$ ，这个很像整体二分，我们可以在时间轴上整体二分，整体二分的同时跑 $\texttt{tarjan}$ 缩点求答案。

设当前答案区间是 $[l,r],mid=\frac{l+r}{2}$ ，我们先将出现时间在 $[0,l-1]$ 之间的所有边加入，再将在这个答案区间内的出现时间 $\le mid$ 的边全部加入，然后跑 $\texttt{tarjan}$ 。

但是这个复杂度还是不对，因为每次要加入时间 $\in [0,mid]$ 的边。仔细分析，有一些边每次都会被重新缩一遍，比如 $[l,r] \to [l,mid] \to [l,\frac{l+mid}{2}]$ 这样，最后一个区间里的边会被重复缩好几次。所以我们考虑每次在已经缩了一些点的原图上做，可以用带撤销并查集把某些地方的影响撤销掉。具体来说，先递归左区间，撤销影响，再递归右区间。

再考虑权值怎么处理。我们对每个强连通分量维护一棵权值线段树，保存分量内部的所有点权，每次加边时合并线段树，修改就是单点修改，查询排名可以记一下有多少点比它大，然后用类似主席树的方法查询排名。

代码实现要注意细节。权值线段树的范围是离散化之后的范围！不是 $n$ ！

### 代码

$\color{#99ccff}{Code}:$

```cpp

#include <stdio.h>
#include <map>
#include <algorithm>
#define it register int
#define ct const int
#define il inline
using namespace std;
const int N = 1000005;
typedef long long ll;
struct ky {
    int u, v, r, op;
    bool operator<(const ky &p) const { return r < p.r; }
} a[N], q[N], a1[N], a2[N];
int n, m, Q, p[N], cnt, rot[N];
ll ans[N], w[N], b[N];
map<int, int> mp[N];
template <class I>
il void sp(I &p, I &q) {
    I x = p;
    p = q, q = x;
}
template <class I>
il I Min(I p, I q) {
    return p < q ? p : q;
}
namespace sgt {
ll sum[N << 4];
int sz[N << 4], ls[N << 4], rs[N << 4], cnt;
il void upd(it &rt, ct l, ct r, ct pos, ct x) {
    if (!rt)
        rt = ++cnt;
    if (l == r)
        return sum[rt] += (~x ? b[pos] : -b[pos]), sz[rt] += x, void();
    ct mid = l + r >> 1;
    pos <= mid ? upd(ls[rt], l, mid, pos, x) : upd(rs[rt], mid + 1, r, pos, x);
    sum[rt] = sum[ls[rt]] + sum[rs[rt]], sz[rt] = sz[ls[rt]] + sz[rs[rt]];
}
il void mer(it &u, ct v) {
    if (!u || !v)
        return u |= v, void();
    sum[u] += sum[v], sz[u] += sz[v], mer(ls[u], ls[v]), mer(rs[u], rs[v]);
}
il ll que(ct rt, ct l, ct r, ct K) {
    if (!K || !rt)
        return 0;
    if (K >= sz[rt])
        return sum[rt];
    if (l == r)
        return Min(K, sz[rt]) * b[l];
    ct mid = l + r >> 1;
    return sz[rs[rt]] > K ? que(rs[rt], mid + 1, r, K) : sum[rs[rt]] + que(ls[rt], l, mid, K - sz[rs[rt]]);
}
}  // namespace sgt
namespace dsu {
int f[N], sz[N], sta[N], top;
il int fd(it x) {
    while (x ^ f[x]) x = f[x];
    return x;
}
il void mer(it u, it v) {
    u = fd(u), v = fd(v);
    if (u != v) {
        if (sz[u] > sz[v])
            sp(u, v);
        sta[++top] = u, f[u] = v, sz[v] += sz[u];
    }
}
il void rec(ct x) {
    it u;
    while (top > x) u = sta[top--], sz[f[u]] -= sz[u], f[u] = u;
}
il void ini() {
    for (it i = 1; i <= n; ++i) f[i] = i, sz[i] = 1;
    top = 0;
}
il int fd2(ct x) { return f[x] ^ x ? f[x] = fd2(f[x]) : x; }
}  // namespace dsu
using dsu ::fd;
using dsu ::fd2;
using dsu ::mer;
namespace tarjan {
int h[N], nxt[N], adj[N], top, s[N], dfn[N], low[N], ti, t;
bool ins[N];
il void add(ct u, ct v) { nxt[++t] = h[u], h[u] = t, adj[t] = v; }
il void dfs(ct x) {
    dfn[x] = low[x] = ++ti, s[++top] = x, ins[x] = 1;
    for (it i = h[x], j; i; i = nxt[i])
        !dfn[j = adj[i]] ? dfs(j),
            low[x] = Min(low[x], low[j]) : low[x] = Min(low[x], ins[j] ? low[j] : low[x]);
    if (dfn[x] == low[x]) {
        it v = s[top];
        do {
            v = s[top--], ins[v] = 0, mer(x, v);
        } while (x ^ v);
    }
}
}  // namespace tarjan
il void solve(ct l, ct r, ct u, ct v) {
    if (l > r)
        return;
    if (u == v) {
        for (it i = l; i <= r; ++i) a[i].r = u;
        return;
    }
    ct mid = u + v >> 1, lst = cnt, ttop = dsu::top;
    for (it i = l, u, v; i <= r; ++i)
        if (((u = fd(a[i].u)) != (v = fd(a[i].v))) && a[i].r > mid)
            tarjan::add(u, v), p[++cnt] = u, p[++cnt] = v;
    for (it i = lst + 1; i <= cnt; ++i)
        if (!tarjan::dfn[p[i]])
            tarjan::dfs(p[i]);
    tarjan::ti = 0;
    it cn1 = 0, cn2 = 0;
    for (it i = l, u, v; i <= r; ++i)
        (((u = fd(a[i].u)) == (v = fd(a[i].v))) && a[i].r > mid) ? a2[++cn2] = a[i] : a1[++cn1] = a[i];
    for (it i = l, j = 1; j <= cn1; ++j, ++i) a[i] = a1[j];
    for (it i = l + cn1, j = 1; j <= cn2; ++j, ++i) a[i] = a2[j];
    for (it i = lst + 1; i <= cnt; ++i)
        tarjan::h[p[i]] = 0, tarjan::dfn[p[i]] = tarjan::low[p[i]] = 0, p[i] = 0;
    tarjan::t = tarjan::top = 0;
    cnt = lst, solve(l, l + cn1 - 1, u, mid), dsu::rec(ttop), solve(l + cn1, r, mid + 1, v);
}
int main() {
    scanf("%d%d%d", &n, &m, &Q); it i;
    dsu::ini(), b[0] = n;
    for (i = 1; i <= n; ++i) scanf("%lld", &w[i]), b[i] = w[i];
    for (i = 1; i <= m; ++i) scanf("%d%d", &a[i].u, &a[i].v), mp[a[i].u][a[i].v] = i, a[i].r = Q;
    for (i = 1; i <= Q; ++i) {
        scanf("%d%d%d", &q[i].op, &q[i].u, &q[i].v);
        if (q[i].op == 1)
            a[mp[q[i].u][q[i].v]].r = i - 1;
        if (q[i].op == 2)
            w[q[i].u] += q[i].v, b[++*b] = w[q[i].u];
    }
    std::sort(a + 1, a + 1 + m), std::sort(b + 1, b + 1 + *b), *b = std::unique(b + 1, b + 1 + *b) - b - 1;
    for (i = 1; i <= n; ++i) w[i] = std::lower_bound(b + 1, b + 1 + *b, w[i]) - b;
    solve(1, m, 0, Q), std::sort(a + 1, a + 1 + m), dsu::ini();
    for (i = 1; i <= n; ++i) sgt::upd(rot[i], 1, b[0], w[i], 1);
    for (it i = Q, now = m + 1, u, v; i; --i) {
        while (now && a[now - 1].r >= i) {
            --now, u = fd2(a[now].u), v = fd2(a[now].v);
            if (u != v)
                dsu::f[v] = u, sgt::mer(rot[u], rot[v]);
        }
        if (q[i].op == 2)
            u = fd(q[i].u), sgt::upd(rot[u], 1, b[0], w[q[i].u], -1),
            w[q[i].u] = std::lower_bound(b + 1, b + 1 + *b, b[w[q[i].u]] - q[i].v) - b,
            sgt::upd(rot[u], 1, b[0], w[q[i].u], 1);
        if (q[i].op == 3)
            ans[i] = sgt::que(rot[fd(q[i].u)], 1, b[0], q[i].v);
    }
    for (i = 1; i <= Q; ++i)
        if (q[i].op == 3)
            printf("%lld\n", ans[i]);
    return 0;
}

---

## 作者：wwwwwza (赞：2)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P5163)

这道题十分有趣，同时有点毒瘤，但其中有许多解题方法值得学习。

**重点**

1. 遇到只有要删边没有加边的题，我们很容易想到让时间倒流，将其变成加边。

2. 若一条边在一个强连通分量里，那无论怎么加边，这条边都处在其强连通分量中。

3. 遇到两个集合要合并的，要么是拍成线段树合并，要么是拉到树上做启发式。题目中我们选择线段树合并。

**思路**

1. 强行让时间逆流，将删边变成加边。

2. 用整体二分，计算某条边是什么时候加入强连通分量的。

3. 对于每个时刻，此时的图可看为无向图去计算（因为在一个强连通分量中，都能互相到达）。

4. 线段树合并去计算答案。

**代码**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;
const int mod=998244353;
const int inf=0x3f3f3f3f;
int n,m,Q,cnt,ans[N];
int a[N],s[N],tot=0,t[N];
int fa[N],siz[N];
int dfn[N],low[N],idx=0,sta[N],s_top=0,top=0;
int root[N],tree_cnt=0;
bool vis[N];
vector<int>g[N];
map<pair<int,int>,int>mp;
struct T{
	int lson,rson,siz,sum;
}tree[N<<2];
struct Stack{
	int x,y;
}st[N];
struct node{
	int opt,x,y,pos;
}p[N],q[N],p1[N],p2[N];
int find(int x){
	if(fa[x]==x)return x;
	return find(fa[x]);
}
int ask(int x){
	return lower_bound(s+1,s+1+tot,x)-s;
}
bool cmp(node a,node b){
	if(a.pos==b.pos)return a.opt<b.opt;
	return a.pos<b.pos;
}
inline int read(){
    int x=0,t=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')t=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*t;
}
inline void write(int x){
    if(x<0){
    	putchar('-');
		x=-x;
	}
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
void init(){
	for(int i=1;i<=n;i++){
		fa[i]=i;
		siz[i]=1;
	}
}
void merge(int x,int y){
	x=find(x);y=find(y);
	if(x==y)return;
	if(siz[x]<siz[y])swap(x,y);
	st[++top]={x,y};
	siz[x]+=siz[y];
	fa[y]=x;
}
void tarjan(int u){
	dfn[u]=low[u]=++idx; 
	sta[++s_top]=u;
	vis[u]=1;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]); 
		}else if(vis[v]){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		int p=sta[s_top--],now=0;
		vis[p]=0;
		if(p==u)return;
		do{
			now=sta[s_top--];
			vis[now]=0;
			merge(p,now);
		}while(now!=u);
	}
}
void clear(int num){
	idx=0;
	for(int i=1;i<=num;i++){
		g[t[i]].clear();
		dfn[t[i]]=low[t[i]]=0;
	}
}
void del(int id){
	int x=st[id].x,y=st[id].y;
	fa[y]=y;
	siz[x]-=siz[y];
}
void solve(int l,int r,int x,int y){
	if(l>r)return;
	if(x==y){
		for(int i=l;i<=r;i++)p[i].pos=x;
		return;
	}
	int now=top,num=0,cnt1=0,cnt2=0,mid=x+y>>1;
	for(int i=l;i<=r;i++){
		if(p[i].pos>mid)continue;
		int x=find(p[i].x),y=find(p[i].y);
		t[++num]=x;t[++num]=y;
		g[x].push_back(y);
	}
	for(int i=1;i<=num;i++){
		if(!dfn[t[i]])tarjan(t[i]);
	}
	for(int i=l;i<=r;i++){
		if(p[i].pos<=mid&&find(p[i].x)==find(p[i].y))p1[++cnt1]=p[i];
		else p2[++cnt2]=p[i];
	}
	for(int i=1;i<=cnt1;i++)p[l+i-1]=p1[i];
	for(int i=1;i<=cnt2;i++)p[l+cnt1+i-1]=p2[i];
	clear(num);
	solve(l+cnt1,r,mid+1,y);
	while(top>now)del(top--);
	solve(l,l+cnt1-1,x,mid);
}
void update(int &rt,int l,int r,int x,int d){
	if(!rt)rt=++tree_cnt;
	tree[rt].siz+=d;tree[rt].sum+=s[x]*d;
	if(l==r)return;
	int mid=l+r>>1;
	if(x<=mid)update(tree[rt].lson,l,mid,x,d);
	else update(tree[rt].rson,mid+1,r,x,d);
}
int Merge(int x,int y,int l,int r){
	if(!x||!y)return x+y;
	if(l==r){
		tree[x].siz+=tree[y].siz;
		tree[x].sum+=tree[y].sum;
		return x;
	}
	int mid=l+r>>1;
	tree[x].lson=Merge(tree[x].lson,tree[y].lson,l,mid);
	tree[x].rson=Merge(tree[x].rson,tree[y].rson,mid+1,r);
	tree[x].siz=tree[tree[x].lson].siz+tree[tree[x].rson].siz;
	tree[x].sum=tree[tree[x].lson].sum+tree[tree[x].rson].sum;
	return x;
}
int query(int rt,int l,int r,int x){
	if(x>tree[rt].siz)return tree[rt].sum;
	if(l==r)return s[l]*x;
	int mid=l+r>>1;
	if(x<=tree[tree[rt].rson].siz)return query(tree[rt].rson,mid+1,r,x);
	return query(tree[rt].lson,l,mid,x-tree[tree[rt].rson].siz)+tree[tree[rt].rson].sum;
} 
signed main(){
	n=read(),m=read(),Q=read();
	cnt=m;
	for(int i=1;i<=n;i++){
		a[i]=read();
		s[++tot]=a[i];
	}
	init();
	for(int i=1;i<=m;i++){
		p[i].x=read(),p[i].y=read();
		mp[make_pair(p[i].x,p[i].y)]=i;
	}
	for(int i=1;i<=Q;i++){
		q[i].opt=read(),q[i].x=read(),q[i].y=read();
		q[i].pos=Q-i+1;
		if(q[i].opt==1)p[mp[make_pair(q[i].x,q[i].y)]].pos=q[i].pos;
		if(q[i].opt==2)a[q[i].x]+=q[i].y,s[++tot]=a[q[i].x];
	}
	sort(s+1,s+1+tot);
	tot=unique(s+1,s+1+tot)-s-1;
	solve(1,m,0,Q+1);
	for(int i=1;i<=n;i++){
		update(root[i],1,tot,ask(a[i]),1);
	}
	init();
	for(int i=1;i<=Q;i++){
		if(q[i].opt!=1)p[++cnt]=q[i];
	}
	sort(p+1,p+1+cnt,cmp);
	for(int i=1;i<=cnt;i++){
		int x=p[i].x,y=p[i].y,pos=p[i].pos,opt=p[i].opt;
		if(!opt){
			x=find(x),y=find(y);
			if(x==y)continue;
			if(siz[x]<siz[y])swap(x,y);
			siz[x]+=siz[y];
			fa[y]=x;
			root[x]=Merge(root[x],root[y],1,tot); 
		}else if(opt==2){
			int fat=find(x);
			update(root[fat],1,tot,ask(a[x]),-1);
			a[x]-=y;
			update(root[fat],1,tot,ask(a[x]),1);
		}else if(opt==3){
			int fat=find(x);
			ans[Q-pos+1]=query(root[fat],1,tot,y); 
		}
	}
	for(int i=1;i<=Q;i++){
		if(q[i].opt==3){
			write(ans[i]);
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：81179332_ (赞：2)

首先，一定是要把删边改为加边的

如果是无向图就很好做了，用并查集维护每个点属于哪个连通图，每个连通图维护一个权值线段树，然后加边的时候，如果已经连通了就不管，否则将两个连通图的权值线段树合并一下，修改点权就直接在权值线段树上改。

变为有向图之后强连通分量就没那么好维护了，我们对于每条边的两个端点分别考虑，将出现时间小于该边的边全部加入后，跑一遍 `tarjan` 即可判定该边两端点是否在同一强连通分量内

我们解决了判定方法，则容易想到整体二分。对于二分区间 $[l,r]$，我们将当前范围的、出现时间小于等于 $mid$ 的边加入，然后跑 `tarjan`

发现复杂度是错的，我们可以考虑利用一下上一层缩点后的结果：当递归到 $[l,r]$ 时，我们将 $[0,mid]$ 的边都加入了，而这些边在我们处理 $[mid+1,r]$ 时也是需要加入的，所以我们可以先处理 $[mid+1,r]$，然后将本层缩的点撤销，即使用可撤销并查集，再处理 $[l,mid]$

`tarjan` 的复杂度为 $O(n+m)$，可撤销并查集为 $O(\log n)$，再加上整体二分的 $\log$，则整体二分的复杂度为 $O(n\log^2 n)$

线段树合并的复杂度是优秀的 $O(n\log n)$，则总复杂度为 $O(n\log^2n)$（将 $n,m,q$ 视为同阶不区分了）

```cpp
//timeuse:110min
const int N = 400010;
int n,m,q;
int a[N],b[N << 1],cntb;
int get(int x) { return lower_bound(b + 1,b + 1 + cntb,x) - b; }
struct edge { int u,v,tim; }e[N];
map<pair<int,int>,int> mp;
struct modify { int op,a,b; }c[N];
struct data { int op,a,b,tim; }d[N];
int tot;ll ans[N];

struct Seg_Tree
{
	int rt[N],cnt = 0;
	struct tree { int ls,rs,siz;ll sum; }t[N * 60];
	void update(int &now,int l,int r,int pos,int v)
	{
		if(!now) now = ++cnt;
		t[now].siz += v,t[now].sum += (ll)v * b[pos];
		if(l == r) return;int mid = l + r >> 1;
		if(pos <= mid) update(t[now].ls,l,mid,pos,v);
		else update(t[now].rs,mid + 1,r,pos,v);
	}
	int merge(int rt1,int rt2,int l,int r)
	{
		if(!rt1 || !rt2) return rt1 + rt2;
		if(l == r) { t[rt1].siz += t[rt2].siz,t[rt1].sum += t[rt2].sum;return rt1; }
		int mid = l + r >> 1;
		t[rt1].ls = merge(t[rt1].ls,t[rt2].ls,l,mid);
		t[rt1].rs = merge(t[rt1].rs,t[rt2].rs,mid + 1,r);
		t[rt1].siz = t[t[rt1].ls].siz + t[t[rt1].rs].siz;
		t[rt1].sum = t[t[rt1].ls].sum + t[t[rt1].rs].sum;
		return rt1;
	}
	void merge(int x,int y) { rt[x] = merge(rt[x],rt[y],1,cntb); }
	ll query(int now,int l,int r,int k)
	{
		if(t[now].siz < k) return t[now].sum;
		if(l == r) return (ll)k * b[l];
		int mid = l + r >> 1;
		if(k <= t[t[now].rs].siz) return query(t[now].rs,mid + 1,r,k);
		return t[t[now].rs].sum + query(t[now].ls,l,mid,k - t[t[now].rs].siz);
	}
}seg;

struct DSU
{
	int fa[N],rnk[N],st1[N],st2[N],top;
	void init() { for(int i = 1;i <= n;i++) fa[i] = i,rnk[i] = 1; }
	int getf(int u) { return fa[u] == u ? u : getf(fa[u]); }
	void merge1(int x,int y)
	{
		x = getf(x),y = getf(y);
		if(x == y) return;
		if(rnk[x] < rnk[y]) swap(x,y);
		fa[y] = x,st1[++top] = y;
		if(rnk[x] == rnk[y]) rnk[x]++,st2[top] = x;
		else st2[top] = 0;
	}
	void clear(int d)
	{
		while(top > d)
		{
			fa[st1[top]] = st1[top];
			if(st2[top]) rnk[st2[top]]--;
			top--;
		}
	}
	void merge2(int x,int y)
	{
		x = getf(x),y = getf(y);
		if(x == y) return;
		if(rnk[x] < rnk[y]) swap(x,y);
		fa[y] = x;
		if(rnk[x] == rnk[y]) rnk[x]++;
		seg.merge(x,y);
	}
}dsu;

struct Tarjan
{
	struct edge { int nxt,to; }e[N]; int head[N],ecnt = 0;
	void add(int u,int v) { e[++ecnt].to = v,e[ecnt].nxt = head[u];head[u] = ecnt; }

	int dfn[N],low[N],idx,st[N],top;
	bool vis[N];
	void tarjan(int u)
	{
		dfn[u] = low[u] = ++idx;
		vis[st[++top] = u] = 1;
		for(int i = head[u];i;i = e[i].nxt)
		{
			int v = e[i].to;
			if(!dfn[v]) tarjan(v),low[u] = min(low[u],low[v]);
			else if(vis[v]) low[u] = min(low[u],dfn[v]);
		}
		if(dfn[u] == low[u])
		{
			int now = st[top--];
			vis[now] = 0;
			while(st[top + 1] != u)
			{
				vis[st[top]] = 0;
				dsu.merge1(now,st[top--]);
			}
		}
	}
	void solve(vector<int> x) { for(int i:x) if(!dfn[i]) tarjan(i); }
	void clear(vector<int> x) { for(int i:x) head[i] = low[i] = dfn[i] = 0;ecnt = idx = 0; }
}tar;

struct Binary
{
	vector<int> node;edge t1[N],t2[N];
	void solve(int l,int r,int a,int b)
	{
		if(a > b) return;
		if(l == r) { for(int i = a;i <= b;i++) e[i].tim = l;return; }
		int mid = l + r >> 1;
		node.clear();int now = dsu.top;
		for(int i = a;i <= b;i++) if(e[i].tim <= mid)
		{
			int u = dsu.getf(e[i].u),v = dsu.getf(e[i].v);
			node.push_back(u),node.push_back(v);
			tar.add(u,v);
		}
		tar.solve(node);
		int cnt1(0),cnt2(0);
		for(int i = a;i <= b;i++)
			if(dsu.getf(e[i].u) == dsu.getf(e[i].v) && e[i].tim <= mid) t1[++cnt1]= e[i];
			else t2[++cnt2] = e[i];
		for(int i = 1;i <= cnt1;i++) e[a + i - 1] = t1[i];
		for(int i = 1;i <= cnt2;i++) e[a + cnt1 + i - 1] = t2[i];
		tar.clear(node);
		solve(mid + 1,r,a + cnt1,b);
		dsu.clear(now);
		solve(l,mid,a,a + cnt1 - 1);
	}
}bin;

int main()
{
	n = read(),m = read(),q = read();
	for(int i = 1;i <= n;i++) a[i] = b[++cntb] = read();
	for(int i = 1;i <= m;i++)
	{
		e[i].u = read(),e[i].v = read(),e[i].tim = 0;
		mp[{e[i].u,e[i].v}] = i;
	}
	for(int i = 1;i <= q;i++)
	{
		c[i].op = read(),c[i].a = read(),c[i].b = read();
		if(c[i].op == 1) e[mp[{c[i].a,c[i].b}]].tim = q - i + 1;
		if(c[i].op == 2) b[++cntb] = (a[c[i].a] += c[i].b);
	}
	sort(b + 1,b + 1 + cntb);cntb = unique(b + 1,b + 1 + cntb) - b - 1;
	
	dsu.init(),bin.solve(0,q + 1,1,m);
	for(int i = 1;i <= m;i++) d[++tot] = {1,e[i].u,e[i].v,e[i].tim};
	for(int i = 1;i <= q;i++)
		if(c[i].op ^ 1) d[++tot] = {c[i].op,c[i].a,c[i].b,q - i + 1};
	sort(d + 1,d + 1 + tot,[&](data u,data v)
	{ return u.tim == v.tim ? u.op < v.op : u.tim < v.tim; });
	
	for(int i = 1;i <= n;i++) seg.update(seg.rt[i],1,cntb,get(a[i]),1);
	dsu.init();
	for(int i = 1;i <= tot;i++)
	{
		if(d[i].op == 1) dsu.merge2(d[i].a,d[i].b);
		if(d[i].op == 2)
		{
			int u = d[i].a,fau = dsu.getf(u);
			seg.update(seg.rt[fau],1,cntb,get(a[u]),-1);
			a[u] -= d[i].b;
			seg.update(seg.rt[fau],1,cntb,get(a[u]),1);
		}
		if(d[i].op == 3)
		{
			int u = d[i].a,fau = dsu.getf(u);
			ans[q - d[i].tim + 1] = seg.query(seg.rt[fau],1,cntb,d[i].b);
		}
	}for(int i = 1;i <= q;i++) if(c[i].op == 3) fprint(ans[i]);
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：2)

- 本题为开摆计划 T8。
- 本题有一个**理论复杂度优于目前正解** $O(n\log)$ 的做法，**不需要使用可撤销并查集**，由于本题强制时光倒流，强行套线段树合并的做法不够接近本质，重写一遍旧的代码，仍然显得冗长无趣，作者，以及该做法的发现者，均不愿意给出原题做法的代码实现，故只给出方法指导[在此](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/lgjoi-lian-tong)，请见谅。
- 下面是作者以前写的 $O(n\log^2)$ 做法。

**[题意](https://www.luogu.com.cn/problem/P5163)**
- 给一个有向图，支持删边，单点修改，求单点所在强连通分量中前 $k$ 大节点的权值和。

**分析**
- 时光倒流改成加边，但是加边维护强连通分量是什么。
- 尝试用一个更简单的描述：只要我们知道加入的一条边在什么时候被缩进强连通分量里了，我们就可以用线段树合并高效地支持合并操作与修改操作，但是这玩意怎么求呢？
- 单个二分很好求，多个尝试整体二分？
- 对于多个分段的操作，我们可以尝试分段加边，前一段加的边可以直接转化为连通性，为我们整体二分提供了条件。
- 可以这样，对于确认答案在区间 $[l,r]$ 内的节点，将出现时间不超过区间中点的边加入，用 $\text{Tarjan}$ 缩点（为了保证复杂度只遍历有边的点）然后用可撤销并查集合并连通块，然后先求解右儿子，撤销连通块之后求解左儿子，复杂度 $O(n\log^2n)$。

**代码实现**
- 实现可撤销并查集注意事项：
- 记得初始化 size，[代码](https://www.luogu.com.cn/paste/yw244g60)。
- 实现 Tarjan 注意事项：
- 保证复杂度需要不访问孤立点，[代码](https://www.luogu.com.cn/paste/lvh9mfgs)。
- 实现权值线段树合并注意事项：
- 查询的时候一个点有相同值要特判，[代码](https://www.luogu.com.cn/paste/752epury)。
- [代码实现](https://www.luogu.com.cn/paste/26wcrfow)。

---

## 作者：IkunTeddy (赞：0)

# 题意

有动态删边，修改的图中强连通块的第 $k$ 小。

# 题目分析

删边可以看作，逆时间轴上的加边。

在强连通分块的有向边可以被看作无向边，这样我们就能像做[P3224 [HNOI2012] 永无乡](https://www.luogu.com.cn/problem/P3224)一样，用**并查集+线段树合并**求解。

现在关键在于我们需要求出每条边在什么时候最早成为强连通分量中的一条边。

我们可以发现这个时间是能够二分求解的，但是二分中的 check 函数需要 Tarjan 求解，单次 $O(n+m)$。

这个复杂度明显不能接受，所以我们考虑**整体二分**减少 check 的次数。

会影响时间 $i$ 的边只能是 $\left [0,i-1  \right ]$ 的边集，所以我们在整体二分时维护 $\left [0,L-1  \right ]$ 的边集，再用 $\left [L,mid  \right ]$ 的边集加入去判断 $\left [mid+1,R  \right ]$ 的边集。

所以我们就用**回滚并查集**维护强连通分量即可。

大概思路就是如此，有一些细节看代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
//
const int maxn=4e5+10;
int n,m,q,N;
ll s[maxn],disc[maxn];
int Disc(ll x){return lower_bound(disc+1,disc+N+1,x)-disc;}
int t[maxn];
struct Graph{
	int x,y;
}g[maxn];
vector<int>e[maxn];
unordered_map<int,int>id[maxn];
struct Operation{
	int op,x,y;
}opt[maxn];
//
struct Edge{
	int v,next;
}edge[maxn];
int head[maxn],tot;
void add_edge(int u,int v){
	edge[++tot].v=v;
	edge[tot].next=head[u];
	head[u]=tot;
}
//
struct node{
	int ls,rs;
	int cnt;
	ll s;
}tree[maxn*100];
int rt[maxn],nodecnt;
void pushup(int v){
	tree[v].cnt=tree[tree[v].ls].cnt+tree[tree[v].rs].cnt;
	tree[v].s=tree[tree[v].ls].s+tree[tree[v].rs].s;
}
void update(int &v,int l,int r,int x,int k){
	if(!v)v=++nodecnt;
	if(l==r){
		tree[v].cnt+=k;
		tree[v].s+=disc[l]*k;
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid)update(tree[v].ls,l,mid,x,k);
	else update(tree[v].rs,mid+1,r,x,k);
	pushup(v);
}
int merge(int x,int y,int l,int r){
	if(!x||!y)return x|y;
	if(l==r){
		tree[x].cnt+=tree[y].cnt;
		tree[x].s+=tree[y].s;
		return x;
	}
	int mid=(l+r)>>1;
	tree[x].ls=merge(tree[x].ls,tree[y].ls,l,mid);
	tree[x].rs=merge(tree[x].rs,tree[y].rs,mid+1,r);
	pushup(x);
	return x;
}
ll ask(int v,int l,int r,int k){
	if(!v)return 0;
	if(l==r)return disc[l]*min(tree[v].cnt,k);
	int mid=(l+r)>>1;
	if(k<=tree[tree[v].rs].cnt)return ask(tree[v].rs,mid+1,r,k);
	else return tree[tree[v].rs].s+ask(tree[v].ls,l,mid,k-tree[tree[v].rs].cnt);
}
//
struct CopyStack{
	int x,y,add;
}cpy[maxn];
int fa[maxn],sz[maxn],topc;
void init_DSU(){for(int i=1;i<=n;i++)fa[i]=i,sz[i]=1;}
int find(int x){return x==fa[x]?x:find(fa[x]);}
void copy(int x,int y){cpy[++topc]={x,y,sz[y]};}
void rollback(int last){
	while(topc!=last){
		int x=cpy[topc].x,y=cpy[topc].y;
		fa[x]=x,fa[y]=y;
		sz[x]-=cpy[topc].add;
		topc--;
	}
}
void merge(int x,int y,int op){
	x=find(x),y=find(y);
	if(x==y)return ;
	if(sz[x]<sz[y])swap(x,y);
	copy(x,y);
	if(op)rt[x]=merge(rt[x],rt[y],1,N);
	fa[y]=x;
	sz[x]+=sz[y];
}
//
int dfn[maxn],low[maxn],in[maxn],stk[maxn],top;
void dfs(int u){
	dfn[u]=low[u]=++dfn[0],in[u]=1;
	stk[++top]=u;
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].v;
		if(!dfn[v]){
			dfs(v);
			low[u]=min(low[u],low[v]);
		}else if(in[v]){
			low[u]=min(low[u],low[v]);
		}
	}
	if(dfn[u]==low[u]){
		while(top){
			int x=stk[top--];
			merge(u,x,0);
			in[x]=0;
			if(x==u)break ;
		}
	}
}
//
void solve(int l,int r,vector<int> &vt){
	if(l==r){
		for(int i:vt)e[l].push_back(i),t[i]=l;
		vt.clear();
		return ;
	}
	int mid=(l+r)>>1,last=topc;
	vector<int> lvt,rvt,p;
	for(int i:vt){
		if(t[i]<=mid){
			add_edge(find(g[i].x),find(g[i].y)); 
			p.push_back(find(g[i].x));
			p.push_back(find(g[i].y));
		}
	}
	for(int i:p){if(!dfn[i])dfs(i);}
	dfn[0]=tot=0;
	for(int i:p)head[i]=0,dfn[i]=low[i]=0;
	for(int i:vt){
		if(t[i]<=mid&&find(g[i].x)==find(g[i].y))lvt.push_back(i);
		else rvt.push_back(i);
	}
	vt.clear();
	solve(mid+1,r,rvt);
	rollback(last);
	solve(l,mid,lvt);
}
signed main(){
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)cin>>s[i],disc[++N]=s[i];
	for(int i=1;i<=m;i++){
		cin>>g[i].x>>g[i].y;
		id[g[i].x][g[i].y]=i;
	}
	for(int i=1;i<=q;i++){
		cin>>opt[i].op>>opt[i].x>>opt[i].y;
		if(opt[i].op==2){
			s[opt[i].x]+=opt[i].y;
			disc[++N]=s[opt[i].x];
		}
	}
	sort(disc+1,disc+N+1);
	N=unique(disc+1,disc+N+1)-disc-1;
	reverse(opt+1,opt+1+q);
	vector<int>vt;
	for(int i=1;i<=m;i++)vt.push_back(i);
	for(int i=1;i<=q;i++){
		if(opt[i].op==1){
			t[id[opt[i].x][opt[i].y]]=i;
		}
	}
	init_DSU();
	solve(0,q+1,vt);
	init_DSU();
	for(int i=1;i<=n;i++)update(rt[i],1,N,Disc(s[i]),1);
	stack<ll>ans;
	for(int i=0;i<=q+1;i++){
		for(int id:e[i])merge(g[id].x,g[id].y,1);
		if(opt[i].op==2){
			update(rt[find(opt[i].x)],1,N,Disc(s[opt[i].x]),-1);
			s[opt[i].x]-=opt[i].y;
			update(rt[find(opt[i].x)],1,N,Disc(s[opt[i].x]),1);
		}
		if(opt[i].op==3){
			ans.push(ask(rt[find(opt[i].x)],1,N,opt[i].y));
		}
	}
	while(!ans.empty()){
		cout<<ans.top()<<'\n';
		ans.pop();
	}

	return 0;
}

```

---

## 作者：xfrvq (赞：0)

单 $\log$ 做法，尽量人话。

---

时间倒流套路，化删边为加边。加边查连通块 $k$ 小也套路，值域线段树合并即可。但这里是有向边，并没有好的维护强联通分量的方法。

我们找出一条边两端被缩入强连通分量的时间，按顺序添加即可转有向边为无向边。**这个“时间”满足单调性，即两点若在某个时刻强联通，后面时刻会一直强联通**。对所有边的“时间”计算考虑整体二分。

我们设函数 `solve(l,r,L,R)` 表示 **计算 $[l,r]$ 区间的边，答案在 $[L,R]$ 中**。于是设 `mid=(L+R)/2`，只需将 $[l,r]$ 的边重排，分为答案 $\le mid$ 的 $[l,p]$ 区间，答案 $\gt mid$ 的 $(p,r]$ 区间，然后 `solve(l,p,L,mid),solve(p+1,r,mid+1,R)` 即可。

由于上述单调性，我们只需加入 $[1,mid]$ 的边，跑 $\tt tarjan$ 然后看 $[l,mid]$ 每条边是否强联通即可。

注意到分治算法为保证 $\log$ 时间，**函数复杂度必须是 $r-l$ 级别而非 $n$ 级别**。这里的 $\tt tarjan$ 只能在 $[l,mid]$ 的边上跑，什么意思呢：**就是我们假定函数开始前 $[1,l)$ 的边的贡献已在图中，此时直接加就可以了**。

此时面临的问题是：**如何将缩点后的贡献加入图中？又如何撤销贡献？**

此时有一个 $\log^2$ 做法：用并查集维护强连通分量（毕竟一条边被强联通了，即意味着两端的强联通分量被合并了），要撤销就用可撤销并查集（启发式合并且不路径压缩，复杂度是 $\log$ 而不是一般的 $\alpha$）。

**其实并非一定要显式的用上并查集**。这里并查集的目的是**给每个强联通分量找一个代表**，把不同强联通分量间连边，转化到代表上连边就行。

于是我们在递归入 `solve(p+1,r,mid+1,R)` 的情况（即答案 $\ge mid$，需要用到 $[l,mid]$ 边的贡献）前，将 $(mid,r]$ 的边端点编号改成其代表就行了。这个更改不会影响到图上，所以不用撤销更改，每次按照更改后的编号重新建图即可，跑完 $\tt tarjan$ 后清空图就行了。

分治复杂度 $O(m\log q)$。线段树合并视实现 $O((n+q)\log V)$ 或 $O((n+q)\log(n+q))$，空间等同。

---

我采用了离散化即 $O((n+q)\log(n+q))$ 写法，因此要开到 $3\times10^5$。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

const int N = 3e5 + 5,$ = N * 29;

int n,m,q,k,fa[N],O[N],X[N],Y[N];
int id[N],dfn[N],low[N],tot,stk[N],tp,vis[N],P[N],pnt;
int rt[N],T[$],lc[$],rc[$],cnt;
struct edge{ int u,v,t; } E[N];
ll a[N],b[N],A[N],S[$];
vector<int> G[N];
map<pair<int,int>,int> M;

int fnd(int x){ return x == fa[x] ? x : fa[x] = fnd(fa[x]); }

#define mid ((L + R) / 2)
#define val(x) lower_bound(b + 1,b + k + 1,x) - b

void upd(int p,int f,int &i,int L = 1,int R = k){
	if(!i) i = ++cnt;
	T[i] += f,S[i] += b[p] * f;
	if(L < R) p <= mid ? upd(p,f,lc[i],L,mid) : upd(p,f,rc[i],mid + 1,R);
}

int mrg(int i,int j,int L = 1,int R = k){
	if(!i || !j) return i | j;
	T[i] += T[j],S[i] += S[j];
	if(L < R) lc[i] = mrg(lc[i],lc[j],L,mid),rc[i] = mrg(rc[i],rc[j],mid + 1,R);
	return i;
}

ll qry(int c,int i,int L = 1,int R = k){
	if(!c || !i) return 0;
	if(L == R) return b[L] * min(c,T[i]);
	if(c < T[rc[i]]) return qry(c,rc[i],mid + 1,R);
	return qry(c - T[rc[i]],lc[i],L,mid) + S[rc[i]];
}

void trj(int u){
	dfn[u] = low[u] = ++tot,vis[stk[++tp] = u] = 1;
	for(int v : G[u])
		if(!dfn[v]) trj(v),low[u] = min(low[u],low[v]);
		else if(vis[v]) low[u] = min(low[u],dfn[v]);
	if(dfn[u] == low[u])
		do vis[stk[tp]] = 0,id[stk[tp]] = u; while(stk[tp--] != u);
}

void sol(int L,int R,int l,int r){
	if(L == R || l > r) return;
	int p = r; tot = 0;
	for(int i = r;i >= l;--i) if(E[i].t > mid) swap(E[i],E[p--]);
	for(int i = l;i <= p;++i)
		G[P[++pnt] = E[i].u].push_back(P[++pnt] = E[i].v);
	for(int i = 1;i <= pnt;++i) if(!dfn[P[i]]) trj(P[i]);
	for(int i = p;i >= l;--i)
		if(!id[E[i].u] || id[E[i].u] != id[E[i].v])
			E[i].t = mid + 1,swap(E[i],E[p--]);
	for(int i = p + 1;i <= r;++i){
		if(id[E[i].u]) E[i].u = id[E[i].u];
		if(id[E[i].v]) E[i].v = id[E[i].v];
	}
	while(pnt) dfn[P[pnt]] = id[P[pnt]] = 0,G[P[pnt--]].clear();
	sol(L,mid,l,p),sol(mid + 1,R,p + 1,r);
}

int main(){
	scanf("%d%d%d",&n,&m,&q),k = n;
	for(int i = 1;i <= n;++i) scanf("%lld",a + i),b[i] = a[i];
	for(int i = 1;i <= m;++i)
		scanf("%d%d",&E[i].u,&E[i].v),M[make_pair(E[i].u,E[i].v)] = i;
	for(int i = q;i >= 1;--i){
		scanf("%d%d%d",O + i,X + i,Y + i);
		if(O[i] == 1) E[M[make_pair(X[i],Y[i])]].t = i;
		if(O[i] == 2) b[++k] = (a[X[i]] += Y[i]);
	}
	sort(b + 1,b + k + 1),k = unique(b + 1,b + k + 1) - b - 1;
	for(int i = 1;i <= n;++i) upd(val(a[i]),1,rt[fa[i] = i]);
	sol(0,q,1,m);
	for(int i = 0,j = 1,u,v;i <= q;++i){
		if(O[i] == 2){
			upd(val(a[X[i]]),-1,rt[fnd(X[i])]),a[X[i]] -= Y[i];
			upd(val(a[X[i]]),1,rt[fnd(X[i])]);
		} else if(O[i] == 3) A[i] = qry(Y[i],rt[fnd(X[i])]);
		for(;E[j].t == i;++j)
			if((u = fnd(E[j].u)) != (v = fnd(E[j].v)))
				rt[fa[v] = u] = mrg(rt[u],rt[v]);
	}
	for(int i = q;i >= 1;--i) if(O[i] == 3) printf("%lld\n",A[i]);
	return 0;
}
```

---


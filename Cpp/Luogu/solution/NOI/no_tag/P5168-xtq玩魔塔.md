# xtq玩魔塔

## 题目背景

**已添加样例解释**

在小学五年级的时候，$xtq$迷上了各种奇奇怪怪的魔塔。
关于魔塔游戏的背景：https://baike.baidu.com/item/%E9%AD%94%E5%A1%94/861619?fr=aladdin

对于题意理解可能并没有任何微小的作用

## 题目描述

$xtq$现在正在玩一个魔塔。这个魔塔十分特殊，不是由正方形格子构成的，而是一个$n$个点，$m$条边的无向图，而且每条边上都会有一个怪物。$xtq$经过了重重阻拦，现在到达了一个奖励层。

在这层内，所有怪物都不会让$xtq$掉血，但是对于每一个怪物如果$xtq$不到一定血量他就无法攻击这个怪物。每一个点上还有一个宝石，宝石的种类有很多，但是如果$xtq$到了一个点但是他已经拥有了这种宝石，他是不能捡起的。他现在想要知道从这个魔塔的一个点到另一个点所需要的最小血量是多少，还要知道如果他从一个点到达这个魔塔，以某个血量能够捡到的宝石数量是多少。还有一件事令$xtq$十分头疼：这个魔塔由于一些神秘的力量，可能宝石的种类会发生变化。保证如果$xtq$的血量无穷大，他就可以走到这一层的任何地方。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/pic/47598.png)

第一次操作为3号操作，从4开始，有3点血量，可以到达$\{2,3,4\}$，可以获得的宝石种类为$\{2,4,6\}$

第二次将1的宝石种类修改为4，即下图：

![](https://cdn.luogu.com.cn/upload/pic/47599.png)

第三次为3操作，从1开始，可以到达的点为$\{1,2,3,4\}$，可以获得的宝石种类为$\{4,6\}$。

第四次为2操作，从4走到3，至少需要3点血量。



 测试点 | n | m | q | 有无修改操作 
------ | ------ | ---|--- | ------ 
 1 | 10 | 20 | 10 | 有 
 2 | 1000 | 5000 | 5000 | 有 
 3 | 1000 | 5000 | 5000 | 有 
 4 | 8000 | 30000 | 20000 | 有 
 5 | 8000 | 30000 | 20000 | 有 
 6 | 20000 | 100000 | 100000 | 无 
 7 | 20000 | 100000 | 100000 | 有 
 8 | 50000 | 200000 | 200000 | 无 
 9 | 50000 | 200000 | 200000 | 有 
 10 | 100000 | 300000 | 200000 | 有 


对于$100\%$的数据，$n \le 100000,m \le 300000,q \le 200000$

剩余所有数字$\le intmax$

**保证查询的区间是随机生成的（其实是出题人懒得再写generator了）**

## 样例 #1

### 输入

```
4 4 4
4 6 4 2
1 2 8
3 2 3
2 4 2
4 1 7
3 4 3
1 4 4
3 1 7
2 4 3```

### 输出

```
3
2
3
```

# 题解

## 作者：1saunoya (赞：4)

[$\texttt{my blog}$](https://www.cnblogs.com/Isaunoya/p/11983101.html)

[P5168 xtq玩魔塔](https://www.luogu.com.cn/problem/P5168)

又是码农题…

利用[克鲁斯卡尔重构树](https://www.cnblogs.com/Isaunoya/p/11780762.html)的性质

我们就可以得出 $dep$ 值小的，肯定比 $dep$ 大的值要优。

于是第二问就可以直接 LCA 求出来了…

至于第三问，dfs序一下，然后求子树…考虑莫队
修改直接[带修莫队](https://www.luogu.com.cn/problem/P1903)，没了。

```cpp
#include <bits/stdc++.h>
using namespace std ;
int min(int x , int y) { return x < y ? x : y ; }
void swap(int & x , int & y) { x ^= y ^= x ^= y ; }
int read() {
  int x = 0 , f = 1 ; char c = getchar() ;
  while(c < '0' || c > '9') { if(c == '-') f = -1 ; c = getchar() ; }
  while(c >= '0' && c <= '9') { x = (x << 3) + (x << 1) + (c & 15) ; c = getchar() ; }
  return x * f ;
}
void print(int x) {
  char _st[20] ; int tp = 0 ;
  if(! x) { putchar('0') ; }
  while(x) { _st[++ tp] = (x % 10) ^ 48 ; x /= 10 ; }
  while(tp) { putchar(_st[tp --]) ; }
  putchar('\n') ;
}
const int N = 1e5 + 10 ;
const int M = 3e5 + 10 ;
const int Q = 2e5 + 10 ;
struct Edge { int u , v , w ; } E[M] ;
struct _Link { int v , nxt ; } e[N << 1] ;
struct Change { int pos , col ; } qc[Q] ;
struct Qry { int l , r , id , t ; } qr[Q] ;
int n , m , q , change_cnt = 0 , qry_cnt = 0 , len = 0 ;
int col[N] , fa[N << 1] , val[N << 1] , head[N << 1] , cnt = 0 , f[N << 1][22] , d[N << 1] ;
int rev[N << 1] , dfn[N << 1] , sz[N << 1] , idx = 0 , ans[Q] , _cnt[N << 1] , bl[N] ;
void Link(int u , int v) { e[++ cnt] = { v , head[u] } ; head[u] = cnt ; }
void dfsfa(int u) {
  for(int i = head[u] ; i ; i = e[i].nxt) { d[e[i].v] = d[f[e[i].v][0] = u] + 1 ; dfsfa(e[i].v) ; }
}
void dfssz(int u) {
  if(u <= n) { rev[dfn[u] = ++ idx] = u ; sz[u] = 1 ; } else dfn[u] = 1e9 ;
  for(int i = head[u] ; i ; i = e[i].nxt) { dfssz(e[i].v) ; sz[u] += sz[e[i].v] ; dfn[u] = min(dfn[u] , dfn[e[i].v]) ; }
}
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]) ; }
void Kruskal() {
  int tot = n ; sort(E + 1 , E + m + 1 , [](Edge x , Edge y) { return x.w < y.w ; }) ;
  for(int i = 1 ; i <= (n << 1) ; i ++) fa[i] = i ;
  for(int i = 1 ; i <= m ; i ++) {
    int u = find(E[i].u) , v = find(E[i].v) ;
    if(u ^ v) { ++ tot ; val[fa[tot] = fa[u] = fa[v] = tot] = E[i].w ; Link(tot , u) ; Link(tot , v) ; }
  } dfsfa(tot) ; dfssz(tot) ;
}
int Lca(int u , int v) {
  if(d[u] < d[v]) swap(u , v) ;
  for(int i = 20 ; ~ i ; i --) if(d[f[u][i]] >= d[v]) u = f[u][i] ; if(u == v) return u ;
  for(int i = 20 ; ~ i ; i --) if(f[u][i] ^ f[v][i]) { u = f[u][i] ; v = f[v][i] ; } return f[u][0] ;
}
int gettop(int u , int _val) { for(int i = 20 ; ~ i ; i --) if(f[u][i] && val[f[u][i]] <= _val) u = f[u][i] ; return u ; }
int Ans = 0 ;
void ins(int x) { if(++ _cnt[x] == 1) ++ Ans ; }
void del(int x) { if(-- _cnt[x] == 0) -- Ans ; }
void modify(int x , int now) {
  if(qc[x].pos >= qr[now].l && qc[x].pos <= qr[now].r) { del(col[rev[qc[x].pos]]) ; ins(qc[x].col) ; }
  swap(qc[x].col , col[rev[qc[x].pos]]) ;
}
void Solve() {
  for(int j = 1 ; j <= 20 ; j ++)
    for(int i = 1 ; i <= (n << 1) ; i ++) f[i][j] = f[f[i][j - 1]][j - 1] ;
  for(int i = 1 ; i <= q ; i ++) {
    int opt = read() ;
    if(opt == 1) { int pos = read() , col = read() ; qc[++ change_cnt] = { dfn[pos] , col } ; }
    if(opt == 2) { ans[++ qry_cnt] = val[Lca(read() , read())] ; }
    if(opt == 3) { ++ qry_cnt ; int x = read() , top = gettop(x , read()) ; qr[++ len] = { dfn[top] , dfn[top] + sz[top] - 1 , qry_cnt , change_cnt} ; }
  }
  vector < int > b ; for(int i = 1 ; i <= n ; i ++) b.push_back(col[i]) ;
  for(int i = 1 ; i <= change_cnt ; i ++) b.push_back(qc[i].col) ;
  sort(b.begin() , b.end()) ; b.erase(unique(b.begin() , b.end()) , b.end()) ;
  for(int i = 1 ; i <= n ; i ++) col[i] = lower_bound(b.begin() , b.end() , col[i]) - b.begin() ;
  for(int i = 1 ; i <= change_cnt ; i ++) qc[i].col = lower_bound(b.begin() , b.end() , qc[i].col) - b.begin() ;
  int block = sqrt(n * (2.0 / 3.0)) ; for(int i = 1 ; i <= n ; i ++) bl[i] = (i - 1) / block + 1 ;
  sort(qr + 1 , qr + len + 1 , [](Qry x , Qry y) {
    if(bl[x.l] ^ bl[y.l]) return x.l < y.l ;
    if(bl[x.r] ^ bl[y.r]) return x.r < y.r ;
    return x.t < y.t ;
  }) ;
  int l = 1 , r = 0 , now_t = 0 ;
  for(int i = 1 ; i <= len; i ++) {
    while(l > qr[i].l) ins(col[rev[-- l]]) ; while(r < qr[i].r) ins(col[rev[++ r]]) ;
    while(l < qr[i].l) del(col[rev[l ++]]) ; while(r > qr[i].r) del(col[rev[r --]]) ;
    while(now_t < qr[i].t) modify(++ now_t , i) ; while(now_t > qr[i].t) modify(now_t -- , i) ;
    ans[qr[i].id] = Ans ;
  }
  for(int i = 1 ; i <= qry_cnt ; i ++) print(ans[i]) ;
}
signed main() {
  n = read() ; m = read() ; q = read() ;
  for(int i = 1 ; i <= n ; i ++) { col[i] = read() ; }
  for(int i = 1 ; i <= m ; i ++) { int u = read() , v = read() , w = read() ; E[i] = { u , v , w } ; }
  Kruskal() ; Solve() ;
  return 0 ;
}

```


---

## 作者：hl666 (赞：3)

这题不错啊，结合了一些不太传统的姿势。

首先看到题目有一问从一个点到另一个点边权最小值。想到了什么？

~~**克鲁斯卡尔生成树+倍增？**~~好吧其实有一个更~~常用~~**NB**的算法叫**克鲁斯卡尔重构树**

（不会的可以看[dalao's blog](https://www.cnblogs.com/LadyLex/p/7275821.html)，并且可以尝试切掉[Luogu P4768 [NOI2018]归程](https://www.luogu.org/problemnew/show/P4768)）

回到这题，我们可以把重构树建出来之后直接求两点**LCA**的权值。

然后对于第三问，考虑继续利用重构树，我们发现此时能走到的点在树上一定是一颗子树。

子树内**DFS序**连续啊，所以就变成**区间数颜色**了，直接**莫队**啊！

好吧还有修改，那就**带修莫队**，在数据随机的情况下稳如老狗。

然后这题就完了，不过有一个细节就是克鲁斯卡尔重构树的父节点权值一定大于子节点，所以不用在向上跳的时候再维护一个最大值数组。

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>
#define RI register int
#define Tp template <typename T>
using namespace std;
const int N=100005;
struct data
{
    int x,y,val;
    inline friend bool operator <(data A,data B)
    {
        return A.val<B.val;
    }
}a[N*3]; int n,m,s,opt,x,y,z,ans[N<<1],rst[N*3],dfn[N<<1],blk[N];
struct ques
{
    int l,r,id,t;
    inline ques (int L=0,int R=0,int Id=0,int T=0)
    {
        l=L; r=R; id=Id; t=T;
    }
    inline friend bool operator <(ques A,ques B)
    {
        return blk[A.l]!=blk[B.l]?blk[A.l]<blk[B.l]:(blk[A.r]!=blk[B.r]?blk[A.r]<blk[B.r]:A.t<B.t);
    }
}q[N<<1]; int cnt_q,cnt_cm,cnt_col,bkt[N*3],tot,d[N<<1],sze[N<<1];
struct operation
{
    int pos,col;
    inline operation(int Pos=0,int Col=0) { pos=Pos; col=Col; }
}p[N<<1]; int cnt_p,col[N],now,L=1,R,list[N],ret,size;
class FileInputOutput
{
    private:
        static const int S=1<<21;
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))
        char Fin[S],Fout[S],*A,*B; int Ftop,pt[15];
    public:
        Tp inline void read(T &x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        Tp inline void write(T x)
        {
            if (!x) return (void)(pc('0'),pc('\n')); RI ptop=0;
            while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc('\n');
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
}F;
inline void swap(int &x,int &y)
{
    int t=x; x=y; y=t;
}
class Double_Increased_On_Tree
{
    private:
        static const int P=18;
        struct edge
        {
            int to,nxt;
        }e[N<<1]; int head[N<<1],cnt,idx,anc[N<<1][P],dep[N<<1];
        inline void reset(int now)
        {
            for (RI i=0;i<P-1;++i) if (anc[now][i])
            anc[now][i+1]=anc[anc[now][i]][i]; else break;
        }
        inline void miner(int &x,int y)
        {
            if (y<x) x=y;
        }
    public:
        inline void add(int x,int y)
        {
            e[++cnt]=(edge){y,head[x]},head[x]=cnt;
        }
        #define to e[i].to
        inline void DFS(int now)
        {
            if (now<=n) list[dfn[now]=++idx]=now,sze[now]=1;
            else dfn[now]=1e9;reset(now); for (RI i=head[now];i;i=e[i].nxt)
            anc[to][0]=now,dep[to]=dep[now]+1,DFS(to),sze[now]+=sze[to],miner(dfn[now],dfn[to]);
        }
        #undef to
        inline int getLCA(int x,int y)
        {
            RI i; if (dep[x]<dep[y]) swap(x,y); for (i=P-1;~i;--i)
            if (dep[anc[x][i]]>=dep[y]) x=anc[x][i]; if (x==y) return x;
            for (i=P-1;~i;--i) if (anc[x][i]!=anc[y][i])
            x=anc[x][i],y=anc[y][i]; return anc[x][0];
        }
        inline int getinterval(int x,int y)
        {
            for (RI i=P-1;~i;--i)if (anc[x][i]&&d[anc[x][i]]<=y) x=anc[x][i]; return x;
        }
}T;
class Kruskal_Rubuild_Tree_Solver
{
    private:
        int father[N<<1];
        inline int getfather(int x)
        {
            return father[x]^x?father[x]=getfather(father[x]):x;
        }
    public:
        inline void init(void)
        {
            for (RI i=1;i<=n;++i) father[i]=i;
        }
        inline void Kruskal(void)
        {
            sort(a+1,a+m+1); init(); for (RI i=1;i<=m;++i)
            if ((a[i].x=getfather(a[i].x))!=(a[i].y=getfather(a[i].y)))
            {
                d[++tot]=a[i].val; father[a[i].x]=father[a[i].y]=tot;
                T.add(tot,a[i].x); T.add(tot,a[i].y); father[tot]=tot;
            }
        }
}K;
inline void add(int col)
{
    if (++bkt[col]==1) ++ret;
}
inline void del(int col)
{
    if (--bkt[col]==0) --ret;
}
inline void travel(int now)
{
    if (p[now].pos>=L&&p[now].pos<=R) del(col[list[p[now].pos]]),
    add(p[now].col); swap(p[now].col,col[list[p[now].pos]]);
}
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i; for (F.read(n),F.read(m),F.read(s),i=1;i<=n;++i)
    F.read(col[i]),rst[++cnt_col]=col[i]; for (i=1;i<=m;++i)
    F.read(a[i].x),F.read(a[i].y),F.read(a[i].val);
    for (tot=n,K.Kruskal(),T.DFS(tot),i=1;i<=s;++i)
    {
        F.read(opt); F.read(x); F.read(y);
        switch (opt)
        {
            case 1:
                p[++cnt_p]=operation(dfn[x],y); rst[++cnt_col]=y; break;
            case 2:
                ans[++cnt_q]=d[T.getLCA(x,y)]; break;
            case 3:
                int top=T.getinterval(x,y);	q[++cnt_cm]=ques(dfn[top],dfn[top]+sze[top]-1,++cnt_q,cnt_p); break;
        }
    }
    sort(rst+1,rst+cnt_col+1); cnt_col=unique(rst+1,rst+cnt_col+1)-rst-1;
    for (i=1;i<=n;++i) col[i]=lower_bound(rst+1,rst+cnt_col+1,col[i])-rst;
    for (i=1;i<=cnt_p;++i) p[i].col=lower_bound(rst+1,rst+cnt_col+1,p[i].col)-rst;
    for (size=(int)pow(n,2.0/3.0),i=1;i<=n;++i) blk[i]=(i-1)/size+1;
    for (sort(q+1,q+cnt_cm+1),i=1;i<=cnt_cm;++i)
    {
        while (now<q[i].t) travel(++now); while (now>q[i].t) travel(now--);
        while (L>q[i].l) add(col[list[--L]]); while (R<q[i].r) add(col[list[++R]]);
        while (L<q[i].l) del(col[list[L++]]); while (R>q[i].r) del(col[list[R--]]);
        ans[q[i].id]=ret;
    }
    for (i=1;i<=cnt_q;++i) F.write(ans[i]); return F.Fend(),0;
}
```

---

## 作者：BPG_ning (赞：2)

~~还是分块大佬~~

题解区都是树套树，带修莫队和聪明单 $ \log $ 做法，然而我都不会，我会分块！

先发现边权不变，所以我们的最小生成树不变，于是我们建 kruskal 重构树，就可以将操作二轻松解决，而且操作二跟操作一、三毫无关系，可以直接将操作二忽略。

根据 kruskal 重构树的性质，父亲权值大于儿子，所以对于操作三 $ x $ 能到达的点一定在重构树上构成一颗子树，可以倍增找到这颗子树的根。

用 **dfs 序**把树拍平，操作一、三就变成：

单点修改颜色

区间查询颜色种数

你发现这就是[这道题](https://www.luogu.com.cn/problem/P1903)，这道题要带修莫队，但是我太弱了只会分块！

考虑不带修怎么做，一个小 trick 就是维护上一个颜色相同的下标 $ pre_i $，若是第一个出现就令 $ pre_i = 0 $，然后我们对于区间 $ [l,r] $ 的查询就等同于查询 $ \sum_{i=l}^{r} [pre_i<l] $，这个东西权值线段树再可持久化以下就行。

然后带修的话我们可以用 set 来维护 $ pre_i $，难点在于回答答案。

对序列分块，单点修改时对块内暴力维护前缀和，查询时查询块内前缀和，若用树状数组维护复杂度为 $ n\sqrt{n}\log{n} $，且 $ \log $ 不能放进根号里，难以通过。

于是我们发现修改是 $ q $ 个单点修改，但是查询是 $ q\sqrt{n} $ 个块内查询，于是考虑 $ O(\sqrt{n}) $ 修改 $ O(1) $ 查询前缀和的数据结构，显然又能想到分块，每次维护前缀和数组，修改时等于在**前缀和数组**上区间加，用分块维护，查询即可 $ O(1) $，复杂度就变为了 $ n\sqrt{n} $。

但是可能是出题人为了卡掉除了带修莫队的其他数据结构做法，空间只有 125MB，而我们维护 $ \sqrt{n} $ 个前缀和的空间是不能接受的。

发现查询与修改块与块之间无影响，于是我们可以一次只对序列上的**一个块**考虑贡献，这样只需要维护一个前缀和，并且时间复杂度也是正确的，缺点是会跑满 $ q\sqrt{n} $，常数较大。

代码如下:
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=3e5+10;
int n,m,q,cnt,num,c[N],que[N][7];
struct edge{int u,v,w;}E[N];
struct FaC{
    int fa[N];
    void init(){for(int i=1;i<N;i++) fa[i]=i;}
    int find(int x){return (fa[x]==x?x:fa[x]=find(fa[x]));}
    int merge(int x,int y){
        int fx=find(x),fy=find(y);
        if(fx==fy) return 0;
        fa[fy]=fx;
        return 1;
    }
}F;
void read(){
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++) cin>>c[i];
    for(int i=1;i<=m;i++){
        cin>>E[i].u>>E[i].v>>E[i].w;
    }
    for(int i=1;i<=q;i++){
        cin>>que[i][0]>>que[i][1]>>que[i][2];
    }
    map<int,int> mp;
    for(int i=1;i<=n;i++){
        int &id=c[i];
        if(!mp[id]) mp[id]=++num;
        id=mp[id];
    }
    for(int i=1;i<=q;i++)if(que[i][0]==1){
        int &id=que[i][2];
        if(!mp[id]) mp[id]=++num;
        id=mp[id];
    }
}
bool cmp(edge a,edge b){return a.w<b.w;}
int fto[N],W[N];
int tot,dfn[N],sz[N],dep[N],f[N][21];
vector<int> G[N];
void add_edge(int u,int v){G[u].push_back(v);}
void init_dfs(int x){
    dfn[x]=++tot; sz[x]=1;
    for(int i=1;i<=20;i++) f[x][i]=f[f[x][i-1]][i-1];
    for(int y:G[x]){
        dep[y]=dep[x]+1;
        f[y][0]=x;
        init_dfs(y);
        sz[x]+=sz[y];
    }
}
int lca(int x,int y){
    if(dep[x]<dep[y]) swap(x,y);
    for(int i=20;i>=0;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
    if(x==y) return x;
    for(int i=20;i>=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    return f[x][0];
}
int get(int x,int w){
    for(int i=20;i>=0;i--) if(f[x][i]!=0 && W[f[x][i]]<=w){
        x=f[x][i];
    }
    return x;
}
void build_kruskal_Tree(){
    cnt=n;
    F.init();
    for(int i=1;i<=n;i++) fto[i]=i;
    sort(E+1,E+1+m,cmp);
    for(int i=1;i<=m;i++){
        int fu=F.find(E[i].u),fv=F.find(E[i].v);
        if(F.merge(fu,fv)){
            ++cnt;
            add_edge(cnt,fto[fu]);
            add_edge(cnt,fto[fv]);
            W[cnt]=E[i].w;
            fto[fu]=fto[fv]=cnt;
        }
    }
    init_dfs(cnt);
}
set<int> s1[N],s2[N];
int inf,A[N],nxt[N],pre[N],ans[N],tmpnxt[N];
void init_color(){
    inf=cnt+1;
    for(int i=1;i<=cnt;i++) A[dfn[i]]=c[i];
    for(int i=1;i<=num;i++){
        s1[i].insert(inf);
        s2[i].insert(inf);
    }
    for(int i=1;i<=cnt;i++){
        if(A[i]){
            nxt[i]=-*s2[A[i]].upper_bound(-i);
            if(nxt[i]==-inf) nxt[i]=0;
            else pre[nxt[i]]=i;
            s1[A[i]].insert(i);
            s2[A[i]].insert(-i);
        }else nxt[i]=inf;
    }
    for(int i=1;i<=cnt;i++) tmpnxt[i]=nxt[i];
}
void init_upd(int x,int c,int id){
    int p,n;
    p=*s1[A[x]].upper_bound(x);
    n=-*s2[A[x]].upper_bound(-x);
    if(p!=inf){
        if(n==-inf) nxt[p]=0;
        else nxt[p]=n;
        que[id][1]=p; que[id][2]=nxt[p];
    }
    s1[A[x]].erase(x); s2[A[x]].erase(-x);
    A[x]=c;
    p=*s1[c].upper_bound(x);
    n=-*s2[c].upper_bound(-x);
    if(n==-inf) nxt[x]=0;
    else nxt[x]=n;
    que[id][3]=x; que[id][4]=nxt[x];

    if(p!=inf){
        nxt[p]=x;
        que[id][5]=p; que[id][6]=nxt[p];
    }
    s1[c].insert(x); s2[c].insert(-x);
}
int B,l[N],r[N],bel[N];
int numB,S[N],lazy[N];
void init_query(){
    for(int i=1;i<=q;i++){
        int o=que[i][0],x=que[i][1],y=que[i][2];
        if(o==1){
            que[i][1]=que[i][2]=0;
            init_upd(dfn[x],y,i);
        }
        if(o==2){
            ans[i]=W[lca(x,y)];
        }
        if(o==3){
            int f=get(x,y);
            que[i][1]=dfn[f]; que[i][2]=dfn[f]+sz[f]-1;
        }
    }
}
void init_fk(){
    B=500;
    for(int i=0;i<=inf;i++) bel[i]=i/B+1;
    for(int i=0;i<=inf;i++) r[bel[i]]=i;
    for(int i=inf;i>=0;i--) l[bel[i]]=i;
    numB=bel[inf];
}
void add(int x,int w){
    int p=bel[x];
    for(;x<=r[p];x++) S[x]+=w;
    p++;
    for(;p<=numB;p++) lazy[p]+=w;
}
void upd(int x,int w){
    add(nxt[x],-1);
    nxt[x]=w;
    add(nxt[x],1);
}
int query(int x){
    return S[x]+lazy[bel[x]];
}
void work(){
    for(int i=1;i<=numB;i++){
        for(int j=0;j<=inf;j++) S[j]=lazy[j]=0;
        int L=l[i],R=r[i];
        if(L==0) L=1;
        if(R==inf) R=cnt;
        if(L>R) continue;
        for(int j=L;j<=R;j++) nxt[j]=tmpnxt[j];
        for(int j=L;j<=R;j++) add(tmpnxt[j],1);
        for(int j=1;j<=q;j++){
            if(que[j][0]==1){
                if(L<=que[j][1] && que[j][1]<=R) upd(que[j][1],que[j][2]);
                if(L<=que[j][3] && que[j][3]<=R) upd(que[j][3],que[j][4]);
                if(L<=que[j][5] && que[j][5]<=R) upd(que[j][5],que[j][6]);
            }
            if(que[j][0]==3){
                int ql=max(L,que[j][1]),qr=min(R,que[j][2]);
                if(ql<=qr){
                    if(ql==L && qr==R) ans[j]+=query(que[j][1]-1);
                    else{
                        for(int k=ql;k<=qr;k++){
                            if(nxt[k]<que[j][1]) ans[j]++;
                        }
                    }
                }
            }
        }
    }
}
void out(){
    for(int i=1;i<=q;i++) if(que[i][0]>1){
        cout<<ans[i]<<'\n';
    }
}
int main(){
    ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);
    freopen("nzq.in","r",stdin);
    freopen("nzq.out","w",stdout);
    read();
    build_kruskal_Tree();
    init_color();
    init_query();
    init_fk();
    work();
    out();
    cerr<<1.0*clock()/CLOCKS_PER_SEC<<'\n';
    return 0;
}
```

---

## 作者：mrsrz (赞：2)

随机数据也太毒了吧，假算法放过去一大堆，这题明明有一个$\log$的算法的啊……~~有本事数据范围加个0~~

首先考虑第二个询问，这个询问和[ \[NOI2018\] 归程](https://www.luogu.org/problemnew/show/P4768)类似，可以使用克鲁斯卡尔重构树解决。

然后考虑第三个询问，把它放在重构树上，就是一个子树数颜色问题。由于有修改操作，所以就是个带修子树数颜色问题。

这个是可以一个$\log$解决的。~~不知道为什么要放带修莫队和树套树过去而且还跑那么快~~

显然可以用树状数组维护子树信息（dfs序连续）。

我们考虑每加入一个节点$x$的时候，在哪些节点处能产生贡献。显然，能产生贡献的节点所在子树内原本没有这种颜色。

我们可以找到这种颜色的一个其他节点$y$，使它与$x$的$\rm LCA$的深度最深。那么$x$能在该节点到$\rm{LCA}$（不包含$\rm{LCA}$）的路径上各产生1的贡献。

用差分的思想，在树状数组上，$x$处加1，在$\rm{LCA}$处减1即可。

而这样的$y$，只可能是dfs序和$x$最相近的两个中的一个（比它小和比它大，也可能只有一个），用```set```维护一下即可。

然后查询颜色就直接查询树状数组上这棵子树即可。

这样就做到一个$\log$维护颜色信息了。

于是总时间复杂度$O((n+m+q)\log n)$。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
#include<set>
#include<vector>
using namespace std;
vector<int>vec;
inline int readint(){
	int c=getchar(),d=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())d=d*10+(c^'0');
	return d;
}
const int N=4e5+5;
int ff[N],n,m,col[N],Q;
inline int find(int x){return x==ff[x]?x:ff[x]=find(ff[x]);}
struct que{
	int op,x,y;
}q[N];
namespace nt{
	int to[N],nxt[N],head[N],cnt,fa[N],dw[N],rt,dep[N],F[18][N],idfn[N];
	int sz[N],son[N],top[N],dfn[N],idx;
	inline void addedge(int u,int v,int w){to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt,fa[v]=u,dw[u]=w;}
	void dfs(int now){
		sz[now]=1,son[now]=0;
		for(int i=head[now];i;i=nxt[i]){
			dep[to[i]]=dep[now]+1,F[0][to[i]]=now,dfs(to[i]),sz[now]+=sz[to[i]];
			if(!son[now]||sz[son[now]]<sz[to[i]])son[now]=to[i];
		}
	}
	void dfs2(int now){
		idfn[dfn[now]=++idx]=now;
		if(son[now])top[son[now]]=top[now],dfs2(son[now]);
		for(int i=head[now];i;i=nxt[i])if(to[i]!=son[now])dfs2(top[to[i]]=to[i]);
	}
	inline int LCA(int x,int y){
		while(top[x]!=top[y])
		if(dep[top[x]]>dep[top[y]])x=fa[top[x]];else y=fa[top[y]];
		return dep[x]<dep[y]?x:y;
	}
	void init(){
		dep[rt]=1,top[rt]=rt;
		dfs(rt),dfs2(rt);
		for(int i=1;i<18;++i)
		for(int j=1;j<=rt;++j)F[i][j]=F[i-1][F[i-1][j]];
	}
	int B[N];
	inline void add(int i,int x){for(;i<N;i+=i&-i)B[i]+=x;}
	inline int ask(int i){int x=0;for(;i;i&=i-1)x+=B[i];return x;}
	struct colors{
		set<int>s;
		void ADD(int x){
			add(x,1);
			if(s.empty()){
				s.insert(x);
				return;
			}
			auto nxt=s.lower_bound(x);
			if(nxt==s.begin()){
				s.insert(x);
				add(dfn[LCA(idfn[x],idfn[*nxt])],-1);
				return;
			}
			auto pre=nxt;--pre;
			if(nxt==s.end()){
				s.insert(x);
				add(dfn[LCA(idfn[x],idfn[*pre])],-1);
				return;
			}
			int lft=LCA(idfn[x],idfn[*pre]),rgt=LCA(idfn[x],idfn[*nxt]);
			int X=dep[lft]>dep[rgt]?lft:rgt;
			s.insert(x);
			add(dfn[X],-1);
		}
		void DEL(int x){
			s.erase(x);
			add(x,-1);
			if(s.empty())return;
			auto nxt=s.lower_bound(x);
			if(nxt==s.begin()){
				add(dfn[LCA(idfn[x],idfn[*nxt])],1);
				return;
			}
			auto pre=nxt;--pre;
			if(nxt==s.end()){
				add(dfn[LCA(idfn[x],idfn[*pre])],1);
				return;
			}
			int lft=LCA(idfn[x],idfn[*pre]),rgt=LCA(idfn[x],idfn[*nxt]);
			int X=dep[lft]>dep[rgt]?lft:rgt;
			add(dfn[X],1);
		}
	}c[N];
	void work(){
		for(int i=1;i<=n;++i)
		c[col[i]].ADD(dfn[i]);
		for(int i=1;i<=Q;++i){
			switch(q[i].op){
				case 1:{
					if(col[q[i].x]==q[i].y)break;
					c[col[q[i].x]].DEL(dfn[q[i].x]);
					c[col[q[i].x]=q[i].y].ADD(dfn[q[i].x]);
					break;
				}
				case 2:{
					int p=LCA(q[i].x,q[i].y);
					printf("%d\n",dw[p]);
					break;
				}
				case 3:{
					int x=q[i].x,y=q[i].y;
					for(int i=17;~i;--i)
					if(F[i][x]&&dw[F[i][x]]<=y)x=F[i][x];
					printf("%d\n",ask(dfn[x]+sz[x]-1)-ask(dfn[x]-1));
					break;
				}
			}
		}
	}
}
struct EDGE{
	int u,v,w;
	inline int operator<(const EDGE&r)const{return w<r.w;}
}e[N];
void kruskal(){
	int tot=n;
	for(int i=1;i<=m;++i){
		int u=find(e[i].u),v=find(e[i].v);
		if(u!=v){
			++tot;
			nt::addedge(tot,u,e[i].w),nt::addedge(tot,v,e[i].w);
			ff[u]=ff[v]=tot;
		}
	}
	nt::rt=tot;
}
int main(){
	n=readint(),m=readint(),Q=readint();
	for(int i=1;i<=n;++i)vec.push_back(col[i]=readint());
	for(int i=1;i<=m;++i)e[i].u=readint(),e[i].v=readint(),e[i].w=readint();
	sort(e+1,e+m+1);
	for(int i=1;i<=2*n;++i)ff[i]=i;
	for(int i=1;i<=Q;++i){
		q[i].op=readint(),q[i].x=readint(),q[i].y=readint();
		if(q[i].op==1)vec.push_back(q[i].y);
	}
	sort(vec.begin(),vec.end()),vec.erase(unique(vec.begin(),vec.end()),vec.end());
	for(int i=1;i<=n;++i)col[i]=lower_bound(vec.begin(),vec.end(),col[i])-vec.begin();
	for(int i=1;i<=Q;++i)if(q[i].op==1)q[i].y=lower_bound(vec.begin(),vec.end(),q[i].y)-vec.begin();
	kruskal();
	nt::init();
	nt::work();
	return 0;
}
```

---

## 作者：muller (赞：1)

这题比较不错 首先我们看了是一张图，有点匪夷所思。。。

就知道跟kruskal算法有关，

没错，原来的kruskal算法就是用并查集实现的，

但当我们使用kruskal重构树的时候，

对于每次找出的不同的两个连通块的祖先，

我们都新建一个点作为两个祖先的父亲，并将当前边的边权转化为新点的点权。



------------


然而，

路径压缩的时候会让我们丢失这种辛辛苦苦创造的树的形状。。。

因此我们需要在使用并查集维护连通性的同时使用二叉树来维护树的形状。

这样维护出来的树就是kruskal重构树。


------------


不难发现kruskal重构树有几条重要的性质：

1.树上除叶子结点以外的点都对应着原来生成树中的边，

叶子结点就是原来生成树上的节点。

2.由于新点的创建顺序与原来生成树上边权的大小有关，

可以发现，从每个点到根节点上除叶子结点外按顺序访问到的点的点权是单调的。

3.出于kruskal算法贪心的性质，

两个点u和v的lca的点权就对应着它们最小生成树上的瓶颈。

4.实际上这棵树就是一个二叉堆

所以这道题如何用krukal重构树做呢？


然后我们假设对于当前询问，我们找到了一个子树的根节点uu，

满足d[u]>pd[u]>p

且d[fa[u]]<=pd[fa[u]]<=p且出发点vv在子树中，

这时从v出发可以直接抵达子树中的任意一个叶子结点。

因此我们需要从众多叶子节点中选出一个距离花费最小的。

限制一下点权，倍增一下即可，剩下的就带修莫队，乱搞一发。。。

代码有点长：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int N = 200005, M = (N << 3), K = 25;
struct krus {int u, v, w;} e[M];
struct qst {int l, r, t, id;} que[N];
int fa[N][K], B[N], beg[N], ed[N], la[N], ra[N], pt[N], col[N], to[M], nxt[M], fir[N];
int ini[N], val[N], ans[N], f[N], depth[N], rt[N];
int res, ecnt, tot, n, m, Q, S;
unordered_map <int, int> mp;
template <class T> void cmax(T &x, T y) {x = x > y ? x : y;}
template <class T> void cmin(T &x, T y) {x = x < y ? x : y;}
template <class T> void rd(T &x) {
    char c = getchar(); int f = 1; x = 0;
    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
    x *= f;
}
template <class T> void write(T x) {
    if (x < 0) putchar('-'), x = -x, write(x);
    if (x > 9) write(x / 10); putchar(x % 10 + '0');
}
template <class T> void writeln(T x) {write(x); putchar('\n');}
bool cmp1(krus a, krus b) {return a.w < b.w;}
bool cmp2(qst a, qst b) {
    if (B[a.l] != B[b.l]) return B[a.l] < B[b.l];
    if (B[a.r] != B[b.r]) {
        if (B[a.l] & 1) return B[a.r] < B[b.r];
        return B[a.r] > B[b.r];
    }
    return a.t < b.t;
}
void add(int x) {if (!pt[x]++) ++res;}
void dec(int x) {if (!--pt[x]) --res;}
void upd(int x, int y) {
    if (que[x].l <= la[y] && que[x].r >= la[y]) add(ra[y]), dec(col[la[y]]);
     swap(col[la[y]], ra[y]);
}
int find(int u) {return f[u] = f[u] == u ? u : find(f[u]);}
void ae(int u, int v) {to[++ecnt] = v; nxt[ecnt] = fir[u]; fir[u] = ecnt;}
void dfs(int u, int dep, int f) {
    int i; fa[u][0] = f, depth[u] = dep;
    if (!nxt[fir[u]]) beg[u] = ++tot;
    for (i = fir[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v != f) {
            dfs(v, dep + 1, u);
            if (!beg[u]) beg[u] = beg[v];
        }
    }
    ed[u] = tot;
}
int lca(int u, int v) {
    int i; if (depth[u] < depth[v]) swap(u, v);
    for (i = 20; ~i; --i) if (depth[fa[u][i]] >= depth[v]) u = fa[u][i];
    if (u == v) return u;
    for (i = 20; ~i; --i) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
int main() {
    int i, j; rd(n); rd(m); rd(Q); S = sqrt(n);
    for (i = 1; i <= n; ++i) rd(ini[i]), B[i] = (i - 1) / S + 1;
    for (i = 1; i <= m; ++i) rd(e[i].u), rd(e[i].v), rd(e[i].w);
    for (i = 1; i <= n; ++i) f[i] = rt[i] = i;
    sort(e + 1, e + m + 1, cmp1);
    int cnt = n, cntc, cntq; cntc = cntq = 0;
    for (i = 1; i <= m; ++i) {
        int u = e[i].u, v = e[i].v, w = e[i].w;
        u = find(u), v = find(v);
        if (rt[u] != rt[v]) {
            int p = ++cnt;
            ae(p, rt[u]), ae(rt[u], p), ae(p, rt[v]), ae(rt[v], p);
            f[u] = v, val[rt[v] = p] = w;
        }
    }
    dfs(cnt, 1, tot = 0); memset(ans, -1, sizeof(ans));
    for (i = 1; i <= 20; ++i)
        for (j = 1; j <= cnt; ++j) fa[j][i] = fa[fa[j][i - 1]][i - 1];
    for (i = 1, tot = 0; i <= n; ++i) if (!mp[ini[i]]) mp[ini[i]] = ++tot;
    for (i = 1; i <= Q; ++i) {
        int a, b, c; rd(a); rd(b); rd(c);
        if (a == 1) ++cntc, la[cntc] = beg[b], ra[cntc] = c;
        else if (a == 2) ans[i] = val[lca(b, c)];
        else {
            for (j = 20; ~j; --j)
                if (fa[b][j] && val[fa[b][j]] <= c) b = fa[b][j];
            que[++cntq] = (qst) {beg[b], ed[b], cntc, i};
        }
    }
    for (i = 1; i <= cntc; ++i) if (!mp[ra[i]]) mp[ra[i]] = ++tot;
    for (i = 1; i <= cntc; ++i) ra[i] = mp[ra[i]];
    for (i = 1; i <= n; ++i) col[beg[i]] = mp[ini[i]];
    sort(que + 1, que + cntq + 1, cmp2);
    int L = 1, R = 0, C = 0;
    for (i = 1; i <= cntq; ++i) {
        while (L > que[i].l) add(col[--L]);
        while (R < que[i].r) add(col[++R]);
        while (L < que[i].l) dec(col[L++]);
        while (R > que[i].r) dec(col[R--]);
        while (C < que[i].t) upd(i, ++C);
        while (C > que[i].t) upd(i, C--);
        ans[que[i].id] = res; 
    } 
    for (i = 1; i <= Q; ++i) if (ans[i] > -1) writeln(ans[i]);
    return 0;
}

```

---

## 作者：zhengrunzhe (赞：1)

已经有带修莫队的了，那我就提供个树套树的吧

**kruskal重构树**+**倍增**+**lca**(我用树剖)+**树套树**(我用线段树套平衡树)+独立的若干棵平衡树

题意：**静态两点路径边权最大值的最小值，动态修改单点颜色，所走路径所有边权不能超过某个值，求最多从某个点出发的颜色数**

首先 **_opt=2代表查询从xx点要到达yy点所需的最小血量_**  这个询问就是裸的kruskal重构树，与P1967货车运输类似，用最小生成树解决

样例重构完树是这样的：
![luogu](https://cdn.luogu.com.cn/upload/pic/50261.png)

5,6,7为新建的点，权值为其左子树每个点到右子树每个点路径边权最小值的最大值，操作2就直接找出两点lca输出权值就ok了

考虑操作3，首先考虑条件：边权不超过y。贪心地，两点间路径边权最小值的最大值越小越好，若>y，就不能通往该点。这个限制还是明显地要我们了解两点最小最大值，还是要回到我们的重构树上。

那么与给定点x路径边权最小值的最大值不超过y的点都有哪些呢？看到树上，从一个叶子节点出发，越往上跳点权越大，如果往上跳的过程中有一个点的点权是<=y的，很显然则就说明x能够到达该点子树的所有点。跳得越高能访问的点就越多，所获取的颜色数也就可能越多，为了高效找出这个点，高效地跳就想到了倍增。

通过倍增找到这个点后，要统计该点的子树的叶子结点(即原图的点)的颜色数量，还要带单点修改，就想到了[P1903 [国家集训队]数颜色 / 维护队列](https://www.luogu.org/problemnew/show/P1903)。

但首先要知道子树中都有哪些叶节点才能进行查询，并且区间数颜色一定是个连续的区间，而假如跳到了5号点，其叶节点是2和4，编号并不是连续的，不能直接通过编号来查询，所以我的方法是进行一波**重新编号**(当然有像其他题解那样的其他方法)

遍历整棵树，给每个叶子节点一个dfs序当作编号，非叶节点就当作一个区间，代表其所含叶节点dfs序的范围/集合，用l[]数组和r[]数组表示，获取l[]跟r[]的方法非常简单，dfs的时候l取其儿子l的最小值，r取其儿子r的最大值即可

如图是重新编号编区间的树
![luogu](https://cdn.luogu.com.cn/upload/pic/50271.png)

此时倍增跳完找到最高的点后，获取该点的l和r，树套树查询区间[l,r]即可

此题只说数字<=intmax，颜色要进行离散化，我用map实现

至于树套树如何修改与查询该类问题(我是线段树套平衡树，和该类问题解决的一般方法树状数组套主席树有所不同)，见[我写的P1903题解](https://www.luogu.org/blog/van/solution-p1903)就好了

```cpp
#include<map>
#include<cstdio>
#include<algorithm>
#define rt (n<<1)-1 //因为生成树中有n-1条边，有多少条边就会重构树多少个点，所以重构树中总共会有2n-1个点，因为添加的总是父节点，所以最后添加的一定是根节点，所以(2n-1)是根
using std::max;
using std::min;
using std::map;
using std::sort;
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();short fh=1;
	while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
	in*=fh;
}
const int N=1e5+10,M=3e5+10,Q=2e5+10,K=17;
int n,m,q,last[N],tmp[N],tot,col[N];
map<int,int>id; //把颜色转化为可操作的编号
struct edge
{
	int x,y,z;
	inline const bool operator<(const edge &e)const
	{
		return z<e.z;
	}
}e[M],t[N<<1];
int head[N<<1],cnt;
inline const void addedge(int u,int v)
{
	cnt++;
	t[cnt]=(edge){v,head[u],0};
	head[u]=cnt;
}
class Union_Find_Set
{
	private:
		int fa[N<<1];
	public:
		inline const void Init()
		{
			for (int i=1;i<=rt;i++)fa[i]=i;
		}
		inline const int Find(int x)
		{
			return fa[x]==x?x:fa[x]=Find(fa[x]);
		}
		inline const void Union(int x,int y)
		{
			int fx=Find(x),fy=Find(y);
			if (fx==fy)return;
			fa[fx]=fy;
		}
}ufs;
int chosen[M],num;
inline const void kruskal()
{
	ufs.Init();
	sort(e+1,e+m+1);
	for (int i=1;i<=m;i++)
		if (ufs.Find(e[i].x)^ufs.Find(e[i].y))
			ufs.Union(e[i].x,e[i].y),chosen[++num]=i;
}
int w[N<<1],l[N<<1],r[N<<1],org[N],ranking;
inline const void rebuild()
{
	ufs.Init();
	for (int x,y,i=1;i<=num;i++)
		x=ufs.Find(e[chosen[i]].x),y=ufs.Find(e[chosen[i]].y),
		addedge(n+i,x),addedge(n+i,y),w[n+i]=e[chosen[i]].z,
		ufs.Union(x,n+i),ufs.Union(y,n+i);
}
inline const void renumber(int p)
{
	l[p]=n;r[p]=1;
	for (int i=head[p];i;i=t[i].y)
		renumber(t[i].x),
		l[p]=min(l[t[i].x],l[p]),
		r[p]=max(r[t[i].x],r[p]);
	if (head[p])return;
	org[r[p]=l[p]=++ranking]=p;
}
int fa[N<<1][K+1],wson[N<<1],size[N<<1],dep[N<<1],top[N<<1];
inline const void dfs(int p)
{
	size[p]=1;
	for (int i=head[p];i;i=t[i].y)
	{
		int son=t[i].x;
		dep[son]=dep[p]+1;fa[son][0]=p;
		dfs(son);size[p]+=size[son];
		if (size[son]>size[wson[p]])wson[p]=son;
	}
}
inline const void dfs(int p,int tp)
{
	top[p]=tp;
	if (wson[p])dfs(wson[p],tp);
	for (int i=head[p];i;i=t[i].y)
		if (t[i].x!=wson[p])
			dfs(t[i].x,t[i].x);
}
inline const int lca(int a,int b)
{
	while (top[a]^top[b])
		dep[top[a]]>dep[top[b]]
		?a=fa[top[a]][0]:b=fa[top[b]][0];
	return dep[a]<dep[b]?a:b;
}
inline const void getfa()
{
	for (int j=1;j<=K;j++)
		for (int i=1;i<=rt;i++)
			fa[i][j]=fa[fa[i][j-1]][j-1];
}
namespace Splay
{
	struct tree
	{
		int val,cnt,size;
		tree *fa,*son[2];
		inline const void pushup()
		{
			size=son[0]->size+cnt+son[1]->size;
		}
		inline const bool identity()
		{
			return fa->son[1]==this;
		}
	}memory_pool[N<<6],*recycle[N<<6],*tail,*null,*root[N+Q]; //最多可能有n+q种不同的颜色
	int top;
	inline const void init()
	{
		tail=memory_pool;
		null=tail++;
		null->val=null->cnt=null->size=top=0;
		null->fa=null->son[0]=null->son[1]=null;
		for (int i=1;i<=n+q;i++)root[i]=null;
	}
	inline tree *spawn(int key)
	{
		tree *p=top?recycle[--top]:tail++;
		p->val=key;
		p->size=p->cnt=1;
		p->fa=p->son[0]=p->son[1]=null;
		return p;
	}
	inline const void erase(tree *&p)
	{
		recycle[top++]=p;
		p=null;
	}
	inline const void connect(tree *p,tree *fa,bool which)
	{
		if (p!=null)p->fa=fa;
		if (fa!=null)fa->son[which]=p,fa->pushup();
	}
	inline const void rotate(tree *p)
	{
		tree *fa=p->fa;
		bool id=p->identity();
		connect(p,fa->fa,fa->identity());
		connect(p->son[id^1],fa,id);
		connect(fa,p,id^1);
	}
	inline const void splay(tree *&root,tree *p)
	{
		for (tree *fa;(fa=p->fa)!=null;rotate(p))
			if (fa->fa!=null)
				rotate(p->identity()^fa->identity()?fa:p);
		root=p;
	}
	inline const void insert(tree *&root,int key)
	{
		if (root==null)return (void)(root=spawn(key));
		tree *now=root;
		while (1)
		{
			if (now->val==key)
				return now->cnt++,now->pushup(),splay(root,now);
			tree *fa=now;
			bool nxt=fa->val<key;
			now=fa->son[nxt];
			if (now==null)
				return now=spawn(key),connect(now,fa,nxt),splay(root,now);
		}
	}
	inline const void find(tree *&root,int key)
	{
		tree *now=root;
		if (now==null)return;
		while (now->son[now->val<key]!=null&&now->val!=key)
			now=now->son[now->val<key];
		splay(root,now);
	}
	inline tree *precursor(tree *&root,int key)
	{
		find(root,key);
		if (root->val<key)return root;
		tree *now=root->son[0];
		while (now->son[1]!=null)now=now->son[1];
		return now;
	}
	inline tree *successor(tree *&root,int key)
	{
		find(root,key);
		if (root->val>key)return root;
		tree *now=root->son[1];
		while (now->son[0]!=null)now=now->son[0];
		return now;
	}
	inline const void Delete(tree *&root,int key)
	{
		find(root,key);tree *p=root;
		if (p->cnt>1)return p->cnt--,p->pushup();
		if (p->son[0]==null&&p->son[1]==null)return root=null,erase(p);
		if (p->son[0]==null)return (root=p->son[1])->fa=null,erase(p);
		if (p->son[1]==null)return (root=p->son[0])->fa=null,erase(p);
		tree *pre=precursor(root,key);splay(root,pre);connect(p->son[1],pre,1);erase(p);
	}
	inline const int less(tree *&root,int key)
	{
		tree *now=root;int tot=0;
		while (now!=null)
			if (key<now->val)now=now->son[0];
			else
			{
				tot+=now->son[0]->size;
				if (now->val==key)return tot;
				tot+=now->cnt;
				now=now->son[1];
			}
		return tot;
	}
}using namespace Splay;
class Segment_Tree
{
	private:
		struct tree
		{
			Splay::tree *root;
			tree *lson,*rson;
			inline const void update(int l,int r,int pos,int key)
			{
				Delete(root,last[pos]);
				insert(root,key);
				if (l==r)return;
				int mid=l+r>>1;
				if (pos<=mid)lson->update(l,mid,pos,key);
				else rson->update(mid+1,r,pos,key);
			}
			inline const int query(int l,int r,int L,int R)
			{
				if (l>R||r<L)return 0;
				if (l>=L&&r<=R)return less(root,L);
				int mid=l+r>>1;
				return lson->query(l,mid,L,R)+rson->query(mid+1,r,L,R);
			}
		}memory_pool[N<<2],*tail;
		inline const void init()
		{
			tail=memory_pool;
		}
		inline tree *spawn()
		{
			tree *p=tail++;
			p->root=null;
			p->lson=p->rson=NULL;
			return p;
		}
	public:
		tree *root;
		inline Segment_Tree(){init();}
		inline const void build(tree *&p,int l,int r)
		{
			p=spawn();
			for (int i=l;i<=r;i++)
				insert(p->root,last[i]);
			if (l==r)return;
			int mid=l+r>>1;
			build(p->lson,l,mid);
			build(p->rson,mid+1,r);
		}
}sgt;
inline const void update(int x,int y)
{
	int pos=l[x],c=id[col[x]],
		pre=precursor(root[c],pos)->val,
		nxt=successor(root[c],pos)->val;
	Delete(root[c],pos);col[x]=y;
	if (nxt)sgt.root->update(1,n,nxt,pre),last[nxt]=pre;
	if (id.find(y)==id.end())y=id[y]=++tot;
	else y=id[y];
	insert(root[y],pos);
    pre=precursor(root[y],pos)->val;
    nxt=successor(root[y],pos)->val;
    if (nxt)sgt.root->update(1,n,nxt,pos),last[nxt]=pos;
    sgt.root->update(1,n,pos,pre);last[pos]=pre;
}
inline const int query(int x,int y)
{
	for (int i=K;i+1;i--)
		if (fa[x][i]&&w[fa[x][i]]<=y)
			x=fa[x][i];
	return sgt.root->query(1,n,l[x],r[x]);
}
int main()
{
	read(n);read(m);read(q);
	for (int i=1;i<=n;i++)read(col[i]);
	for (int i=1;i<=m;i++)
		read(e[i].x),read(e[i].y),read(e[i].z);
	kruskal();rebuild();renumber(rt);
	dfs(rt);dfs(rt,rt);getfa();init();
	for (int i=1;i<=n;i++)
	{
		int c=col[org[i]];
		if (id.find(c)==id.end())c=id[c]=++tot; //离散颜色
		else c=id[c];
		last[i]=tmp[c];
		insert(root[c],tmp[c]=i);
	}
	sgt.build(sgt.root,1,n);
	int opt,x,y;
	while (q--)
		switch (read(opt),read(x),read(y),opt)
		{
			case 1:update(x,y);break;
			case 2:printf("%d\n",w[lca(x,y)]);break;
			case 3:printf("%d\n",query(x,y));break;
		}
	return 0;
}
```

---

## 作者：raincity (赞：0)

## 题目大意

给定一张无向图带权图，点有颜色。需要支持三种操作：

1. 修改一个点的颜色
2. 查询 $x,y$ 之间的所有路径中，最大边权的最小值
3. 查询 $x$ 经过权值不超过 $y$ 的边能到的所有点中，不同的颜色种数

## 分析

看到第二种操作，容易想到 Kruskal 重构树。

那么第三种操作就是查询子树中颜色种数以及单点修改。

显然可以 dfs 一遍之后变成区间颜色种数以及单点修改，带修莫队可以 $O(n^\frac{5}{3})$，而且数据随机跑不满。

但是这个方法复杂度太高了，其实有一个 $O(m\log m+q\log n)$ 的做法。

把改变颜色看做先删除再插入。这里只考虑插入。

显然，在 $x$ 位置插入，只会对 $x$ 的祖先节点中，原本子树内没有这种颜色的节点造成贡献。

在所有同色的节点中，找到与这个点的 LCA 最深的，设找到的点是 $y$，则 $x$ 到 LCA（不包括 LCA）的路径上所有的点答案都会增加。

而且如果按照 dfn 排序，$y$ 只能是 $x$ 的后继或者前驱。可以用 set 维护。

## 解决

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <set>
#include <unordered_map>

using namespace std;

const int N = 100005, NN = N << 1, M = 300005, LOG = 18;
int n, m, q, idx, col[N], val[NN], lc[NN], rc[NN], id[NN], siz[NN], dfn[NN],
    dep[NN], fa[NN], Fa[NN][LOG], tree[NN];
set<int> pos[NN];
unordered_map<int, int> cid;
struct Edge {
    int u, v, w;
    bool operator<(const Edge &oth) const { return w < oth.w; }
} e[M];

void add(int x, int y) {
    for (; x < n << 1; x += x & -x) tree[x] += y;
}

int sum(int x) {
    int res = 0;
    for (; x; x &= x - 1) res += tree[x];
    return res;
}

int getFather(int x) { return x == fa[x] ? x : fa[x] = getFather(fa[x]); }

void Kruskal() {
    sort(e + 1, e + m + 1);
    for (int i = 1; i < n << 1; i++) fa[i] = i;
    for (int i = 1, j = n; i <= m; i++) {
        int u = getFather(e[i].u), v = getFather(e[i].v), w = e[i].w;
        if (u == v) continue;
        val[++j] = w, fa[u] = fa[v] = j, lc[j] = u, rc[j] = v;
    }
}

void dfs(int cur, int fa) {
    siz[cur] = 1, Fa[cur][0] = fa, dfn[cur] = ++idx, dep[cur] = dep[fa] + 1,
    id[idx] = cur;
    for (int i = 1; i < LOG; i++) Fa[cur][i] = Fa[Fa[cur][i - 1]][i - 1];
    if (cur > n)
        dfs(lc[cur], cur), dfs(rc[cur], cur),
            siz[cur] += siz[lc[cur]] + siz[rc[cur]];
}

int lca(int x, int y) {
    if (dep[x] < dep[y]) swap(x, y);
    for (int i = LOG - 1; i >= 0; i--)
        if (dep[Fa[x][i]] >= dep[y]) x = Fa[x][i];
    if (x == y) return x;
    for (int i = LOG - 1; i >= 0; i--)
        if (Fa[x][i] != Fa[y][i]) x = Fa[x][i], y = Fa[y][i];
    return Fa[x][0];
}

void modify(int x, int y) {
    int c = col[x];
    add(dfn[x], y);
    if (y == 1) {
        pos[c].insert(dfn[x]);
        if (pos[c].size() == 1) return;
    } else {
        pos[c].erase(dfn[x]);
        if (pos[c].empty()) return;
    }
    set<int>::iterator it;
    int nxt = (it = pos[c].upper_bound(dfn[x])) == pos[c].end()
                  ? n << 1
                  : lca(x, id[*it]),
        pre = (it = pos[c].lower_bound(dfn[x])) == pos[c].begin()
                  ? n << 1
                  : lca(x, id[*--it]);
    add(dep[nxt] < dep[pre] ? dfn[pre] : dfn[nxt], -y);
}

template <class T>
void read(T &ret) {
    ret = 0;
    char ch = getchar();
    bool found = false;
    while (!isdigit(ch) && ch != '-') ch = getchar();
    if (ch == '-') found = true, ch = getchar();
    while (isdigit(ch)) ret = ret * 10 + ch - '0', ch = getchar();
    if (found) ret = -ret;
}

template <class T, class... Args>
void read(T &ret, Args &...rest) {
    read(ret), read(rest...);
}

int ppk;
int getID(int x) { return cid.count(x) ? cid[x] : cid[x] = ++ppk; }

int main() {
    read(n, m, q);
    for (int i = 1; i <= n; i++) read(col[i]), col[i] = getID(col[i]);
    for (int i = 1; i <= m; i++) read(e[i].u, e[i].v, e[i].w);
    Kruskal(), dfs((n << 1) - 1, (n << 1) - 1);
    for (int i = 1; i <= n; i++) modify(i, 1);
    while (q--) {
        int op, x, y;
        read(op, x, y);
        if (op == 1)
            modify(x, -1), col[x] = getID(y), modify(x, 1);
        else if (op == 2)
            printf("%d\n", val[lca(x, y)]);
        else {
            for (int i = LOG - 1; i >= 0; i--)
                if (val[Fa[x][i]] <= y) x = Fa[x][i];
            printf("%d\n", sum(dfn[x] + siz[x] - 1) - sum(dfn[x] - 1));
        }
    }
    return 0;
}

```

---


# 公约数

## 题目背景

在收卷最后五分钟，pg 发现了卷子反面还有一道大题。

## 题目描述

求

[![](https://cdn.luogu.com.cn/upload/pic/33775.png)](https://www.luogu.org/paste/zltm8ddt)

由于答案可能过大，输出答案对 $10^9+7$ 取模的值。

## 说明/提示

对于前 $10\%$ 的数据，$T=5~,~40 \le n,m,p \le 100$。

对于另外 $20\%$ 的数据，$T=50~,~100 \le n,m,p \le 5\times 10^4$。

对于另外 $20\%$ 的数据，$T= 20~,~4\times 10^6 \le n,m,p \le 5\times 10^6$。

对于另外 $50\%$ 的数据，$T=10^3~,~10^7 \le n,m,p \le 2\times 10^7$。

## 样例 #1

### 输入

```
2
10 12 11
30 20 25```

### 输出

```
25302
573830```

# 题解

## 作者：hsfzLZH1 (赞：20)

感觉标准题解里的式子推错了。。。我来写一篇详细一点的题解吧。

注意：本文所有除法均为向下取整。

## 公式、引理及证明

### 引理：$gcd(ij,ik,jk)=\frac {gcd(i,j)gcd(i,k)gcd(j,k)}{gcd(i,j,k)}$

证明：考虑每个数质因数的幂次，设 $i,j,k$ 关于质因子 $p$ 的幂次分别为 $a,b,c$ ,不妨设 $a\le b\le c$ 。

易证 $gcd(i,j)$ 关于 $p$ 的幂次为 $min(a,b)$ 。

则原式关于 $p$ 的幂次的式子等于

$min(a+b,a+c,b+c)=min(a,b)+min(a,c)+min(b,c)-min(a,b,c)$

即 $a+b=a+a+b-a$ ，显然成立。

若两个数关于各质因子的幂次都相等，则这两个数相等。

得证。

所以

$Ans=\sum_{i=1}^n \sum_{j=1}^m \sum_{k=1}^p gcd^2(i,j)+gcd^2(i,k)+gcd^2(j,k)$

发现每个 $gcd$ 中都只有两个参数，第三个参数不会影响 $gcd$ 的值，只会影响 $gcd$ 的值出现的次数，分别枚举，得

$Ans=p\times \sum_{i=1}^n\sum_{j=1}^m gcd^2(i,j)$

$+m\times \sum_{i=1}^n\sum_{j=1}^p gcd^2(i,j)$

$+n\times \sum_{i=1}^m\sum_{j=1}^p gcd^2(i,j)$

发现要求的 $gcd$ 的平方和都是形如 $\sum_{i=1}^n\sum_{j=1}^m gcd^2(i,j)$ 的，莫比乌斯反演如下：

枚举 $gcd$ 的值

$\sum_{i=1}^n \sum_{j=1}^m gcd^2(i,j)=\sum_{d=1}^{min(n,m)} d^2\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=d]$

对于方括号内的内容，如果式子的值为真，则方括号的返回值为 $1$ ，否则为 $0$ 。

$gcd(i,j)=d$ ，只有在 $i,j$ 均为 $d$ 的倍数时才有可能，所以只枚举 $i,j$ 均为 $d$ 的倍数的情况

$=\sum_{d=1}^{min(n,m)} d^2 \sum_{i=1}^{\frac n d} \sum_{j=1}^{\frac m d} [gcd(i,j)=1]$

现在题目转化为求 $\sum_{i=1}^a \sum_{j=1}^b [gcd(i,j)=1]$ 的值了。

我们设 $f(x)=\sum_{i=1}^a\sum_{j=1}^b [gcd(i,j)=x]$ ， $F(x)=\sum_{i=1}^a\sum_{j=1}^b [x|gcd(i,j)]$ ，易得 $F(x)=\sum_{x|d} f(d)$

而因为 $gcd(i,j)$ 是 $x$ 的倍数，当且仅当 $i,j$ 均为 $x$ 的倍数，所以 $F(x)=\frac n x \times \frac m x$

由倍数反演的式子 $f(1)=\sum_{d=1}\mu(d)F(d)$

$=\sum_{d=1}^{min(n,m)} \mu(d)\times \frac n d\times \frac m d$

$\therefore \sum_{i=1}^n \sum_{j=1}^m gcd^2(i,j)=\sum_{d=1}^{min(n,m)} d^2 \sum_{i=1}^{\frac n d} \sum_{j=1}^{\frac m d} [gcd(i,j)=1]$

$=\sum_{d=1}^{min(n,m)} d^2 \sum_{g=1}^{min(\frac n d,\frac m d)} \mu(g)\times \frac n {gd}\times \frac m {gd}$

枚举 $T=gd$ ，同时枚举 $d|T$ ，则 $g=\frac T d$

$=\sum_{T=1}^{min(n,m)} \frac n T \times \frac m T \times \sum_{d|T} d^2\mu(\frac T d)$

观察到 $\frac n T$ 和 $\frac m T$ 都最多分别只有 $O(\sqrt n)$ 种取值（默认 $n,m$ 同阶），可以用整除分块使枚举 $T$ 的值的时间复杂度降为 $O(\sqrt n)$ ，现在的问题是，如何在合理的预处理时间内，在 $O(1)$ 的时间复杂度下求出 $\sum_{d|x} d^2\mu(\frac x d)$ 的值或前缀和。

观察到 $f(x)=d^2$ 和 $g=\mu$ 都是 ** 积性函数 ** 。所求值的形式为两个函数的卷积，所以也是积性函数。考虑到 $O(n)$ 的预处理时间是可以接受的，借助它是积性函数的性质，我们可以利用 ** 线性筛 ** 计算出该函数的值。

记 $h(x)=\sum_{d|x} d^2\mu(\frac x d)$ 。

根据定义计算得， $h(1)=1,h(p)=1^2\times \mu(p)+p^2\times \mu(1)=p^2-1$ （$p$ 是质数）。

由积性函数的性质得， $h(xy)=h(x)h(y)~(gcd(x,y)=1)$ 。

现在，我们只需考虑线性筛的最后一个问题，若 $x=\prod_{i=1}^k p_i^{a_i}(p_i<p_{i+1})$ ，则 $h(x\times p_1)$ 如何表示？

### 引理： $h(x\times p_1)=h(x)\times p_1^2$

证明：观察 $h$ 函数的形式。因为 $p_1$ 是 $x$ 的最小素数因子，所以 $x\times p_1$ 一定含有 $p_1$ 的平方因子。考虑 $\mu$ 值对答案的贡献。$\mu$ 值为 $0$ 时，即 $\frac x d$ 有平方因子时，该 $d$ 对答案无贡献。

若一个 $x$ 的约数 $d$ 对 $h(x)$ 的答案有贡献，则 $d\times p_1$ 对 $h(x\times p_1)$ 的答案也有贡献，否则即有平方因子，即只有这些 $d\times p_1$ 对答案有贡献。因为乘上 $p_1$ 后贡献的值乘了平方，所以答案会乘上 $p_1^2$ 。

得证。

同理，该结论也能扩展到任意 $x$ 的质因子 $p_k$ 上。

同样的，也可以类比 $\phi(x)=\sum_{d|x} d\mu(\frac x d)$ 的线性筛法得出 $h(x)$ 的线性筛方法。

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=20000010;
typedef long long ll;
const ll mod=1000000007;
ll T,n,m,p,cur,pri[maxn],f[maxn],sum[maxn];
bool tf[maxn];
ll calc(ll n,ll m)
{
	ll ret=0;
	//for(ll T=1;T<=min(n,m);T++)ret=(ret+(n/T)*(m/T)%mod*f[T]%mod)%mod;
	for(ll i=1,j;i<=min(n,m);i=j+1)
	{
		j=min(n/(n/i),m/(m/i));
		ret=(ret+(n/i)*(m/i)%mod*((sum[j]-sum[i-1]+mod)%mod)%mod)%mod;
	}
	return ret;
}
int main()
{
	f[1]=1;
	for(ll i=2;i<=20000000;i++)
	{
		if(!tf[i]){pri[++cur]=i;f[i]=(i*i%mod-1+mod)%mod;}
		for(ll j=1;j<=cur&&i<=20000000/pri[j];j++)
		{
			tf[i*pri[j]]=true;
			if(i%pri[j]==0){f[i*pri[j]]=f[i]*pri[j]%mod*pri[j]%mod;break;}
			else f[i*pri[j]]=f[i]*f[pri[j]]%mod;
		}
	}
	for(ll i=1;i<=20000000;i++)sum[i]=(sum[i-1]+f[i])%mod;
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld%lld",&n,&m,&p);
		printf("%lld\n",(p*calc(n,m)%mod+m*calc(n,p)%mod+n*calc(m,p)%mod)%mod);
	}
	return 0;
}
```

---

## 作者：Nemlit (赞：8)

~~看到这题目就不想做了系列，出题人是不是都不知道杜教筛是什么东西啊，他家杜教筛可以预处理优化到~~$O(n^\frac{2}{3})$

~~先吓唬你一下，我们要求：~~

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\gcd(i\cdot j,i\cdot k,j\cdot k)\times \gcd(i,j,k)\times \left(\frac{\gcd(i,j)}{\gcd(i,k)\times \gcd(j,k)}+\frac{\gcd(i,k)}{\gcd(i,j)\times \gcd(j,k)}+\frac{\gcd(j,k)}{\gcd(i,j)\times \gcd(i,k)}\right)$$

我们令$x = gcd(i, j), y = gcd(i, k), z = gcd(j, k)$

于是我们有：
$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\gcd(i\cdot j,i\cdot k,j\cdot k)\times \gcd(i,j,k)\times \left(\frac{x}{y\times z}+\frac{y}{x\times z}+\frac{z}{x\times y}\right)$$
$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\gcd(i\cdot j,i\cdot k,j\cdot k)\times \gcd(i,j,k) \times \frac{x ^ 2 + y ^ 2 + z ^ 2}{x \times y \times z}$$

展开第一陀恶心人的柿子，可以得到：
$$gcd(i\cdot j,i\cdot k,j\cdot k) = \frac{x \times y\times z}{gcd(i, j, k)}$$

（证明可以通过**唯一分解定理**展开）

于是我们惊喜地发现，我们只需要求$($还原$x, y, z)$：

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p gcd(i, j)^2 +gcd(j, k) ^ 2 + gcd(i, k) ^ 2$$

我们把柿子分开写，得到：

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p gcd(i, j)^2+\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^pgcd(j, k) ^ 2 +\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p gcd(i, k) ^ 2$$

因为$gcd(i, j)$与k无关（其他同理），于是我们可以提出k，变成p个$\sum_{i=1}^n\sum_{j=1}^m gcd(i, j)^2$相加，故有：

$$p \times \sum_{i=1}^n\sum_{j=1}^m gcd(i, j)^2+n \times \sum_{j=1}^m\sum_{k=1}^pgcd(j, k) ^ 2 +m \times \sum_{i=1}^n\sum_{k=1}^p gcd(i, k) ^ 2$$

设$F(n, m) = \sum_{i=1}^n\sum_{j=1}^m gcd(i, j)^2$

原式$=p \times F(n, m) + n \times F(p, m) + m \times F(n, p)$

所以问题转化为如何快速的求出$F(n, m)$（不妨设$n ≤ m$）

$$F(n, m) = \sum_{d = 1}^n\sum_{i=1}^n\sum_{j=1}^m d^2 \times [gcd(i, j) == d]$$

$i, j$同时除以d得：

$$F(n, m) = \sum_{d = 1} ^ n\sum^{n / d}_{i = 1}\sum^{m / d}_{j = 1} d ^ 2 \times [gcd(i, j) == 1]$$
$$F(n, m) = \sum_{d = 1} ^ nd ^ 2\sum^{n / d}_{i = 1}\sum^{m / d}_{j = 1}\sum_{k|gcd(i, j)} \mu(k)$$

提前枚举K得：

$$F(n, m) = \sum_{d = 1} ^ n d ^ 2\sum_{k = 1}^{n / d}\mu(k)\sum^{n / (d * k)}_{i = 1}\sum^{m / (d * k)}_{j = 1}  $$


$$F(n, m) = \sum_{d = 1} ^ n d ^ 2\sum_{k = 1}^{n / d}\mu(k)\left \lfloor \frac{n}{d * k} \right \rfloor \times \left \lfloor \frac{m}{d * k} \right \rfloor$$


跟据反演套路，我们令$T = d * k$

$$F(n, m) = \sum_{T = 1}^n \left \lfloor \frac{n}{T} \right \rfloor \times \left \lfloor \frac{m}{T} \right \rfloor\sum_{d | T} d ^ 2\times \mu(\frac{T}{d})$$

令$g(x) = x * x, mu(x) = \mu(x)$

于是$F(n, m) = \sum_{T = 1}^n \left \lfloor \frac{n}{T} \right \rfloor \times \left \lfloor \frac{m}{T} \right \rfloor\times(g(x) \times mu(x))$

发现后面那一堆就是一个卷积的形式，而且是两个积性函数的卷积，于是我们可以用线性筛筛出，筛法见[于神之怒加强版](https://www.luogu.org/problem/P4449)

总结一下求法：

我们记$prim[i]$为第i个质数，$low[i]$为i质因数分解后最小的质因子的指数次幂，$f[x]$为$g(x)$卷$mu(x)$，$mu[x]$为$\mu(x)$

类似于线性筛，我们分三种情况讨论：

$case1:$ $i$是质数
我们可以直接算出来：$low[i] = i,\;\ f[i] = i \times i - 1,\;\ mu[i] = -1$

$case2:i \% prim[j] != 0$：这种情况是满足积性函数定义的，即$i, prim[j]$互质，令$p = i \times prim[j]$，所以我们有$low[p] = prim[j],\;\  mu[p] = -mu[i],\;\  f[i] = f[i] \times f[prim[j]]$

$case3:i \% prim[j] == 0$：这种情况不满足积性函数的定义，于是我们考虑用我们刚刚维护的$low[i]$

考虑到$i / low[i],prim[j]$是互质的，那我们可不可以类比$case2$通过$f[i / low[i]], f[prim[j]]$来推出$f[p]$呢？

假设$a, b$互质，我们有：$f[a \times b] = f[a] \times f[b]$

所以我们也有：$f[p] = f[i] \times f[prim[j]] = f[i\ /\ low[i]] \times f[prim[j] \times low[i]]$

根据定义，$i\ /\ low[i]$没有$prim[j]$这个约数，所以$i / low[i],\;\ prim[j] \times low[i]$互质

i肯定有$prim[j]$这个质因数，而且根据线性筛的性质，$prim[j]$肯定是i的最小质因数，故我们有$mu[p] = 0,\;\  low[p] = low[i] \times prim[j]$

如果$low[i] < i$，证明$low[i] \times prim[j] <= i$，故我们可以直接用$f[p] = f[i\ /\ low[i]] \times f[prim[j] \times low[i]]$

如果$low[i] == i$，证明i以前肯定没有被筛过，若$low[i] = prim[j] ^ k$，则k肯定为质数，那么我们就可以直接用：$f[p] = (i * prim[j]) ^ 2 - i ^ 2$

### $ps:$ 
写完后看题解才发现：这道题根于神之怒不一样，并不需要记录$low[i]$，对于$case3$，$f[p] = f[i] \times prim[j] ^2$即可

# $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define mod 1000000007
#define maxn 20000007
il int Pow(int x) {return 1ll * x * x % mod;}
int cnt, prim[maxn], f[maxn], mu[maxn], low[maxn];
bool vis[maxn];
il void init() {
	f[1] = mu[1] = 1;
	rep(i, 2, 2e7) {
		if(!vis[i]) f[i] = Pow(i) - 1, mu[i] = -1, low[i] = i, prim[++ cnt] = i;
		for(re int j = 1; j <= cnt; ++ j) {
			if(i * prim[j] > 2e7) break;
			int p = i * prim[j];
			vis[p] = 1;
			if(i % prim[j] == 0) {
				low[p] = low[i] * prim[j];
				if(low[i] == i) f[p] = (Pow(1ll * i * prim[j] % mod) - Pow(i) + mod) % mod;
				else f[p] = 1ll * f[i / low[i]] * f[low[i] * prim[j]] % mod;
				break;
			}
			mu[p] = -mu[i], low[p] = prim[j], f[p] = 1ll * f[i] * f[prim[j]] % mod;
		}
	}
	rep(i, 1, 2e7) f[i] = (f[i - 1] + f[i]) % mod;
}
il int F(int n, int m) {
	if(n > m) swap(n, m);
	int ans = 0;
	for(re int l = 1, r; l <= n; l = r + 1) {
		r = min(n / (n / l), m / (m / l));
		ans = (ans + 1ll * (1ll * (n / l) * (m / l) % mod) * (f[r] - f[l - 1]) % mod) % mod;
	}
	return (ans + mod) % mod;
}
il int get(int n, int m, int p) {
	return ((1ll * p * F(n, m) % mod + 1ll * n * F(p, m) % mod) % mod + 1ll * m * F(n, p)) % mod;
}
il void outit() {
	for(re int i = 1, T = read(); i <= T; ++ i) printf("%d\n", get(read(), read(), read()));
}
int main() {
	init(), outit();
	return 0;
}
```

---

## 作者：asuldb (赞：5)

[题目](https://www.luogu.org/problemnew/show/P5176)

老年选手啥都不想推只能搞个杜教筛了

这个式子长得好吓人啊，所以我们唯一分解之后来考虑这道题

设$i,j,k$分别是$p^a,p^b,p^c$，至于到底谁是谁并不重要，我们不妨假设$a\leq b\leq c$

那么$gcd(i\times j,j\times k,k\times i)=min\{p^{a+b},p^{a+c},p^{b+c}\}=p^{a+b}$

$gcd(i,j,k)=min\{p^a,p^b,p^c\}=p^a$

也就是前面两个柿子乘起来是$p^{2a+b}$

我们把后面的柿子分母通分

$$\frac{(i,j)^2+(j,k)^2+(k,i)^2}{(i,j)(j,k)(k,i)}$$

我们发现分母上还是等于$p^{2a+b}$，因为$p^a$跟另外两个组合得到的$gcd$都是$p^a$，$p^b$和$p^{c}$的$gcd$是$p^b$，所以分母上是$p^{2a+b}$

和外面一约分，没了

显然唯一分解之后各个质数次幂是相互独立的，于是我们现在可以得出结论，我们要求的就是

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p(i,j)^2+(j,k)^2+(k,i)^2$$

显然可以拆成

$$p\times \sum_{i=1}^n\sum_{j=1}^m(i,j)^2+n\times \sum_{j=1}^m\sum_{k=1}^p(j,k)^2+m\times \sum_{i=1}^n\sum_{k=1}^p(k,i)^2$$

套路反演我们可以得到我们要求的东西实际上是

$$\sum_{i=1}^n\left \lfloor \frac{n}{i} \right \rfloor\left \lfloor \frac{m}{i} \right \rfloor\sum_{d|i}\mu(\frac{i}{d})d^2$$

后面的东西线筛也很好推，但是老年选手并不想动脑子了

发现后面的柿子是$id^2\times \mu$，我们直接杜教筛卷上$1$就变成$id^2$了，$id^2$的前缀和自然是$\frac{n(n+1)(2n+1)}{6}$了

这样是$O(n^{\frac{3}{4}})$的，但是我们暴力调合级数处理一些，就能跑的很快了

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
int T;
const int I6=166666668;
const int mod=1e9+7;
const int maxn=1e6+1;
int p[maxn>>1],is[maxn],mu[maxn];
int f[20000005],vis[20000005];
inline int calc(int x) {return 1ll*x*(x+1)%mod*(x+x+1)%mod*I6%mod;}
inline int solve(int x) {
	if(vis[x]) return f[x];
	vis[x]=1;int ans=calc(x);
	for(re int l=2,r;l<=x;l=r+1) {
		r=x/(x/l);
		ans=(ans-1ll*solve(x/l)*(r-l+1)%mod+mod)%mod;
	}
	return f[x]=ans;
}
inline int work(int n,int m) {
	if(n>m) std::swap(n,m);
	int ans=0;
	for(re int l=1,r;l<=n;l=r+1) {
		r=min(n/(n/l),m/(m/l));
		ans=(ans+1ll*(n/l)*(m/l)%mod*(solve(r)-solve(l-1)+mod)%mod)%mod;
	}
	return ans;
}
int main() {
	T=read();is[1]=mu[1]=1;
	for(re int i=2;i<maxn;i++) {
		if(!is[i]) p[++p[0]]=i,mu[i]=-1;
		for(re int j=1;j<=p[0]&&p[j]*i<maxn;j++) {
			is[p[j]*i]=1;if(i%p[j]==0) break;mu[p[j]*i]=-1*mu[i];
		}
	}
	for(re int i=1;i<maxn;i++)
		for(re int j=i;j<maxn;j+=i) {
			if(!mu[j/i]) continue;
			if(mu[j/i]<0) f[j]=(f[j]-1ll*i*i%mod+mod)%mod;
				else f[j]=(f[j]+1ll*i*i)%mod;
		}
	for(re int i=1;i<maxn;i++)
		vis[i]=1,f[i]=(f[i]+f[i-1])%mod;
	while(T--) {
		int n=read(),m=read(),p=read();
		int tmp=1ll*work(n,m)*p%mod+1ll*work(m,p)*n%mod;tmp%=mod;
		tmp=(tmp+1ll*work(n,p)*m%mod)%mod;
		printf("%d\n",tmp%mod);
	}
}
```


---

## 作者：chihik (赞：4)

首先有一个结论：

$$gcd(i\cdot j,i\cdot k,j\cdot k)=\frac{gcd(i , j )\cdot gcd(j , k) \cdot gcd(i,k)}{gcd(i,j,k)}$$

证明如下：

先将 $i,j,k$ 用唯一分解定理展开的次方分别为 $w_1,w_2,w_3$。

$$gcd(i \cdot j,j \cdot k,i \cdot k)=\sum_{i=1}^k {p_i}^{min(w_{1i}+w_{2i},w_{2i}+w_{3i},w_{1i}+w_{3i})}$$

$$gcd(i,j) \cdot gcd(j,k) \cdot gcd(i,k)=\sum_{i=1}^k {p_i}^{min(w_{1i},w_{2i})+min(w_{2i},w_{3i})+min(w_{1i},w_{3i})}$$

$$gcd(i,j,k)=\sum_{i=1}^k {p_i}^{min(w_{1i},w_{2i},w_{3i})}$$

***

$$gcd(i\cdot j,i\cdot k,j\cdot k)=\frac{gcd(i , j )\cdot gcd(j , k) \cdot gcd(i,k)}{gcd(i,j,k)}$$

$$\Leftarrow \sum_{i=1}^k {p_i}^{min(w_{1i}+w_{2i},w_{2i}+w_{3i},w_{1i}+w_{3i})}=\frac{\sum_{i=1}^k {p_i}^{min(w_{1i},w_{2i})+min(w_{2i},w_{3i})+min(w_{1i},w_{3i})}}{\sum_{i=1}^k {p_i}^{min(w_{1i},w_{2i},w_{3i})}}$$

$$\Leftarrow \sum_{i=1}^k {min(w_{1i}+w_{2i},w_{2i}+w_{3i},w_{1i}+w_{3i})}=\sum_{i=1}^k {min(w_{1i},w_{2i})+min(w_{2i},w_{3i})+min(w_{1i},w_{3i})-min(w_{1i},w_{2i},w_{3i})}$$

这是一个轮换式 ， 不妨令 $w_{1i} \le w_{2i} \le w_{3i}$ , 则有

$$\Leftarrow \sum_{i=1}^k {w_{1i}+w_{2i}}=\sum_{i=1}^k {w_{1i}+w_{2i}+w_{1i}-w_{1i}}$$

$$\Leftarrow \sum_{i=1}^k {w_{1i}+w_{2i}}=\sum_{i=1}^k {w_{1i}+w_{2i}}$$

所以原结论成立。

***

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\gcd(i\cdot j,i\cdot k,j\cdot k)\times \gcd(i,j,k)\times \left(\frac{\gcd(i,j)}{\gcd(i,k)\times \gcd(j,k)}+\frac{\gcd(i,k)}{\gcd(i,j)\times \gcd(j,k)}+\frac{\gcd(j,k)}{\gcd(i,j)\times \gcd(i,k)}\right)$$

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\frac{gcd(i , j )\cdot gcd(j , k) \cdot gcd(i,k)}{gcd(i,j,k)}\times \gcd(i,j,k)\times \left(\frac{\gcd(i,j)}{\gcd(i,k)\times \gcd(j,k)}+\frac{\gcd(i,k)}{\gcd(i,j)\times \gcd(j,k)}+\frac{\gcd(j,k)}{\gcd(i,j)\times \gcd(i,k)}\right)$$

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p gcd(i , j)\cdot gcd(j , k) \cdot gcd(i,k)\times \left(\frac{\gcd(i,j)}{\gcd(i,k)\times \gcd(j,k)}+\frac{\gcd(i,k)}{\gcd(i,j)\times \gcd(j,k)}+\frac{\gcd(j,k)}{\gcd(i,j)\times \gcd(i,k)}\right)$$

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p gcd(i , j)^2 \cdot gcd(j , k)^2 \cdot gcd(i,k)^2$$

$$p \times \sum_{i=1}^n\sum_{j=1}^m gcd(i,j)^2+n \times \sum_{i=1}^m\sum_{j=1}^p gcd(i,j)^2+m \times \sum_{i=1}^n\sum_{j=1}^p gcd(i,j)^2$$

现在只需要处理出 $\sum_{i=1}^n\sum_{j=1}^m gcd(i,j)^2$ ，就可以用三次反演解决。

令 $s = min(n,m)$，

$$\sum_{i=1}^n\sum_{j=1}^m gcd(i,j)^2$$

$$\sum_{k=1}^{s}k^2\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=k]$$

$$\sum_{k=1}^{s}k^2\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{k} \rfloor} [gcd(i,j)=1]$$

$$\sum_{k=1}^{s}k^2 \sum_{d=1}^{\lfloor \frac{s}{k} \rfloor } \mu(d) \lfloor \frac{n}{kd} \rfloor  \lfloor \frac{m}{kd} \rfloor$$

$$\sum_{k=1}^{s}\sum_{d=1}^{\lfloor \frac{s}{k} \rfloor } k ^2 \mu(d) \lfloor \frac{n}{kd} \rfloor  \lfloor \frac{m}{kd} \rfloor$$

$$\sum_{k=1}^{s}\sum_{kd=1}^{s} k ^2 \mu(d) \lfloor \frac{n}{kd} \rfloor  \lfloor \frac{m}{kd} \rfloor$$

令 $T=kd$ ,

$$\sum_{T=1}^{s}\sum_{k|T} k^2 \mu(\frac{T}{k}) \lfloor \frac{n}{T} \rfloor  \lfloor \frac{m}{T} \rfloor$$

$$\sum_{T=1}^{s}f(T)\lfloor \frac{n}{T} \rfloor  \lfloor \frac{m}{T} \rfloor$$

其中 $f(n)=\sum_{k|n} k^2 \mu(\frac{n}{k})$ , 由卷积的性质得该函数为积性函数，考虑如何用线性筛求出其前缀和。

如果 $p$ 是一个质数，那么有：

$$
f(p)=1^2 \times \mu(p)+p^2 \times \mu(1)=p^2-1
$$

$$
f(p^k)=\sum_{i=0}^k p^{2i} \times \mu(p^{k-i})
$$

又因为当 $k-i \ge 2$ 时，$\mu(p^{k-i})=0$，所以所有有贡献的 $i > k - 2$ , 即 $i=k$ 或 $i=k-1$ 。

$$
f(p^k)=p^{2k}-p^{2(k-1)}=(p^2-1)p^{2(k-1)}=f(p)p^{2(k-1)}
$$

观察发现括号内 $p$ 减少了 $k-1$ 次方，系数增加 $p^{2(k-1)}$

所以 $f(p^k)=f(p^{k-1}) \times p^2$

整理一下得：

$$f(i \times prime[j])=\begin{cases}
f(i) \times f(prime[j]) & (i,prime[j])=1 \\\\
f(i) \times prime[j]^2  & (i,prime[j])\not=1
\end{cases}
$$

复杂度$\Theta(n+t\sqrt n)$

```cpp
#include <cstdio>
#include <iostream>
using namespace std; 
#define Mod 1000000007

template<typename _T>
void Read( _T &x ) {
	x = 0; int f = 1;
	char s = getchar( );
	for( ; s < '0' || s > '9' ; s = getchar( ) ) f = s == '-' ? -f : f;
	for( ; s >= '0' && s <= '9' ; s = getchar( ) ) x = x * 10 + s - '0';
	x *= f;
}
template<typename _T>
void Write( _T x ) {
	if( x < 0 ) putchar('-') , x = -x;
	if( x >= 10 ) Write( x / 10 );
	putchar( x % 10 + '0' );
}

const int MAXN = 20000000;
int t , n , m , p , k , prime[ MAXN + 5 ] , f[ MAXN + 5 ];
bool vis[ MAXN + 5 ];

void sieve( ) {
    f[ 1 ] = 1;
    for( int i = 2 ; i <= MAXN ; i ++ ) {
        if( !vis[ i ] ) {
            prime[ ++ k ] = i;
            f[ i ] = ( 1ll * i * i - 1 ) % Mod;
        }
        for( int j = 1 ; j <= k && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
            vis[ i * prime[ j ] ] = 1;
            if( i % prime[ j ] == 0 ) {
                f[ i * prime[ j ] ] = 1ll * f[ i ] * prime[ j ] % Mod * prime[ j ] % Mod;
                break;
            }
            f[ i * prime[ j ] ] = 1ll * f[ i ] * f[ prime[ j ] ] % Mod;
        }
    }
    for( int i = 2 ; i <= MAXN ; i ++ )
        f[ i ] = ( f[ i ] + f[ i - 1 ] ) % Mod;
}

int solve( int n , int m ) {
    int d = min( n , m ) , Ans = 0;
    for( int l = 1 , r ; l <= d ; l = r + 1 ) {
        r = min( n / ( n / l ) , m / ( m / l ) );
        Ans = ( Ans + 1ll * ( f[ r ] - f[ l - 1 ] + Mod ) % Mod * ( n / l ) % Mod * ( m / l ) % Mod ) % Mod;
    }
    return Ans;
}

int main( ) {
    sieve( );
    Read( t );
    while( t -- ) {
        Read( n ) , Read( m ) , Read( p );
        int Ans = ( 1ll * n * solve( m , p ) % Mod + 1ll * m * solve( n , p ) % Mod + 1ll * p * solve( n , m ) % Mod ) % Mod;
        Write( Ans ) , putchar('\n');
    }
    return 0;
}
```

---

## 作者：ShineEternal (赞：3)

#### 思考难度：提高?
#### 代码难度：省选-?

算法1：暴力计算

实际得分：10

算法2：

首先$\gcd(i\cdot j,i\cdot k,j\cdot k)=\frac{\gcd(i,j)\times \gcd(i,k)\times \gcd(j,k)}{\gcd(i,j,k)}$

所以原式$=\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p(\gcd^2(i,j)+\gcd^2(i,k)+gcd^2(j,k))$

考虑一个式子$\sum_{i=1}^n\sum_{j=1}^m\gcd^2(i,j)=\sum_{d=1}^{\min(n,m)}\sum_{x|d}d^2\mu\left(\frac{x}{d}\right)$

考虑对后面的$\sum$分块计算，$O(n+T\cdot n\sqrt{n})$

实际得分：30

算法3：

发现前面的$\sum$也可以分块，$O(n+T\cdot n)$

实际得分：50

算法4：

考虑令$f(x)=x^2,g(x)=\mu\left({x}\right)$，计算这两个函数的**狄利克雷卷积$h(x)$**，再对$h(x)$分块计算，$O(n+T\cdot \sqrt{n})$

实际得分：100

算法5(可能时间复杂度有点bug）：

杜教筛一下，把预处理复杂度由$O(n)$降低为$O(n^{\frac{2}{3}})$，~~我太懒了没有学杜教筛~~

实际得分：100

# code:
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;
typedef long long LL;
const LL N=2e7+50;
const LL mod=1e9+7;
LL t,x,y,z,ans;
LL f[N],df[N];
int pri[N],vis[N],cnt;
inline void pr(int x){printf("%d ",x);}
inline void prll(LL x){printf("%lld ",x);}
#define en putchar('\n')
#define kg putchar(' ')
void pre(LL n){
    f[1]=df[1]=1;
    for(int i=2;i<=n;++i){
        if(!vis[i]){pri[++cnt]=i;df[i]=(1ll*i*i-1)%mod;}
        for(int j=1;j<=cnt&&i*pri[j]<=n;++j){
            vis[i*pri[j]]=1;
            if(i%pri[j])df[i*pri[j]]=df[i]*df[pri[j]]%mod;
            else {df[i*pri[j]]=df[i]*pri[j]%mod*pri[j]%mod;break;}
        }
        f[i]=(f[i-1]+df[i])%mod;
    }
}
LL work(LL n,LL m){
    LL res=0,rr=0;
    for(LL d=1;d<=n;d=rr+1){
    	rr=min(n/(n/d),m/(m/d));
    	res=(res+(n/d)*(m/d)%mod*(f[rr]-f[d-1]))%mod;
    }
    return res;
}
int main(){
    pre(N-50);
    for(scanf("%lld",&t);t;--t){
        scanf("%lld%lld%lld",&x,&y,&z);
        ans=1ll*work(min(x,y),max(x,y))*z%mod;
        ans=ans+1ll*work(min(x,z),max(x,z))*y%mod;
        ans=ans+1ll*work(min(y,z),max(y,z))*x%mod;
        printf("%lld\n",(ans+3*mod)%mod);
    }
}
```

---

## 作者：command_block (赞：2)

广告,推荐我的[$\large{\text{数论专题}}$](https://www.luogu.org/blog/command-block/shuo-lun-zhuan-ti)!

题意：求$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=1}^pgcd(ij,jk,ik)*gcd(i,j,k)*(\dfrac{gcd(i,j)}{gcd(i,k)gcd(j,k)}+\dfrac{gcd(i,k)}{gcd(i,j)gcd(j,k)}+\dfrac{gcd(j,k)}{gcd(i,j)gcd(i,k)})$

对大质数取模，其中$n,m,q<=2*10^7$

题面都这么毒瘤，这道题一定很难……

先化一下式子吧。

$gcd(ij,jk,ik)*gcd(i,j,k)*(\dfrac{gcd(i,j)}{gcd(i,k)gcd(j,k)}+\dfrac{gcd(i,k)}{gcd(i,j)gcd(j,k)}+\dfrac{gcd(j,k)}{gcd(i,j)gcd(i,k)})$

$gcd(ij,jk,ik)$这个东西真最麻烦，想办法把它拆开。

考虑我们把$i,j,k$都分解了，形式为$\large{p_1^{ci_1}p_2^{ci_2}...p_m^{ci_m}}$

为了方便，我们只讨论$i,j,k$都只有同一个质因子$p$的情况，而其可以简单的扩展到整数域。

那么：

$\large{ij=p^{ci+cj}}$

$\large{ik=p^{ci+ck}}$

$\large{jk=p^{cj+ck}}$

$\large{gcd(i,j)=p^{min(ci,cj)}}$

$\large{gcd(i,k)=p^{min(ci,ck)}}$

$\large{gcd(j,k)=p^{min(cj,ck)}}$

$\large{gcd(i,j,k)=p^{min(ci,cj,ck)}}$

$\large{gcd(ij,ik,jk)=p^{min(cj+ck,ci+ck,ci+cj)}}$

很明显，$min(cj+ck,ci+ck,ci+cj)=ci,cj,ck$中最小的两个的和。

我们可以用$gcd(i,j)gcd(i,k)gcd(j,k)$来凑，其为:

$\large{p^{min(ci,cj)+min(ci,ck)+min(cj,ck)}}$

而经过手玩，我们得到$min(ci,cj)+min(ci,ck)+min(cj,ck)$就是最小的*2+次小的。

我们需要减掉最小的就可以凑好了！

即在指数上减去$min(ci,cj,ck)$,也就是除以$gcd(i,j,k)$

总的来说就是：根据$min(ci,cj)+min(ci,ck)+min(cj,ck)-min(ci,cj,ck)=min(cj+ck,ci+ck,ci+cj)$

我们得到$gcd(ij,ik,jk)=\dfrac{gcd(i,j)gcd(i,k)gcd(j,k)}{gcd(i,j,k)}$

把这个式子回带到题面中，得到：

$gcd(ij,jk,ik)*gcd(i,j,k)*(\dfrac{gcd(i,j)}{gcd(i,k)gcd(j,k)}+\dfrac{gcd(i,k)}{gcd(i,j)gcd(j,k)}+\dfrac{gcd(j,k)}{gcd(i,j)gcd(i,k)})$

$=\dfrac{gcd(i,j)gcd(i,k)gcd(j,k)}{gcd(i,j,k)}*gcd(i,j,k)*(\dfrac{gcd(i,j)}{gcd(i,k)gcd(j,k)}+\dfrac{gcd(i,k)}{gcd(i,j)gcd(j,k)}+\dfrac{gcd(j,k)}{gcd(i,j)gcd(i,k)})$

$=gcd(i,j)gcd(i,k)gcd(j,k)*(\dfrac{gcd(i,j)}{gcd(i,k)gcd(j,k)}+\dfrac{gcd(i,k)}{gcd(i,j)gcd(j,k)}+\dfrac{gcd(j,k)}{gcd(i,j)gcd(i,k)})$

$=gcd(i,j)^2+gcd(i,k)^2+gcd(j,k)^2$

式子一下子变得非常简洁，~~这和P4240毒瘤考验那题相比真是太友好了~~，颇有些月测代数最后一问的风范……

我们把合式写上：

$ANS=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=1}^pgcd(i,j)^2+gcd(i,k)^2+gcd(j,k)^2$

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=1}^pgcd(i,j)^2+\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=1}^pgcd(i,k)^2+\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=1}^pgcd(j,k)^2$

明显的，我们只要把第一部分求出来，其他的部分也可以使用类似的方法来求。

那就剩下了$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=1}^pgcd(i,j)^2$

$=p\sum\limits_{i=1}^n\sum\limits_{j=1}^mgcd(i,j)^2$

这就很水了……不就是P4449于神之怒弱化版嘛……

枚举gcd：

$=\sum\limits_{d=1}^m\sum\limits_{i=1}^n\sum\limits_{j=1}^md^2[(i,j)==d]$

套路，后方同除d。

$=\sum\limits_{d=1}^md^2\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}[(i,j)==1]$

后面是套路，但是还是写下完整过程吧……

设$f(n,m,x)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[(i,j)==x]$

$F(n,m,x)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[x|(i,j)]$

很明显$F(n,m,x)=\sum\limits_{k=1}^∞f(kn,m,kx)$

根据反演定理可得$f(n,m,x)=\sum\limits_{k}^∞\mu(k)F(n,m,kx)$

我们要求$f(n,m,1)$,根据上式得$f(n,m,1)=\sum\limits_{k}^∞\mu(k)F(n,m,k)$

$F(n,m,k)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[x|(i,j)]$

$=\sum\limits_{i=1}^{n/x}\sum\limits_{j=1}^{m/x}[1|(i,j)]$

$=\lfloor n/x\rfloor\lfloor m/x\rfloor$

回代可得$f(n,m,1)=\sum\limits_{k}^∞\mu(k)\lfloor n/k\rfloor\lfloor m/k\rfloor$

再次回代可得$ANS=\sum\limits_{d=1}^md^2f(n/d,m/d,1)=\sum\limits_{d=1}^md^2\sum\limits_{k}^{m/d}\mu(k)\lfloor n/dk\rfloor\lfloor m/dk\rfloor$

此时，已经可以整除分块套整除分块实现单组$O(n^{\frac{3}{4}})$(常数极大)。

我们改写求和变量，令$T=dk$

得到$ANS=\sum\limits_{T=1}^m\lfloor n/T\rfloor\lfloor m/T\rfloor\sum\limits_{d|T}d^2\mu(T/d)$

那么我们设$F(T)=\sum\limits_{d|T}d^2\mu(T/d)$只要把这个函数的前缀和搞出来，我们就可以整除分块$O(\sqrt{n})$了。

观察可得$F=id^2*\mu$由于其是两个积性函数的卷积，其本身也是个积性函数。

$F(1)=1$

$F(p)=\sum\limits_{d|p}d^2\mu(p/d)=1^2\mu(p)+p^2\mu(1)=p^2-1$

$F(p^k)=\sum\limits_{d|p^k}d^2\mu(p/d)=1^2\mu(p^k)+p^2\mu(p^{k-1})+...+p^{2(k-1)}\mu(p)+p^{2k}\mu(1)$

由于大部分$\mu$都是0，得到：

$=p^{2(k-1)}\mu(p)+p^{2k}\mu(1)=p^{2k}-p^{2(k-1)}=(p^2-1)p^{2(k-1)}=F(p)p^{2(k-1)}$

由$F(p^k)=F(p)p^{2(k-1)}$得到$F(p^k)=F(p^{k-1})*p^2$

所有性质都全了，直接线性筛即可。

~~这题有杜教筛板本吗？~~

代码仅供参考：

```cpp
#include<algorithm>
#include<cstdio>
#define MaxN 20005000
#define mod 1000000007
using namespace std;
int T,N,M,P,Limit;
bool e[MaxN+500];
int tn,p[MaxN+500],p2[MaxN+500];
long long F[MaxN+500];
void getsth()
{
  e[1]=1;F[1]=1;
  for (int i=2,t;i<=Limit;i++){
    if (!e[i]){
      p[++tn]=i;
      p2[tn]=1ll*i*i%mod;
      F[i]=p2[tn]-1;
    }
    for (int j=1;j<=tn&&(t=p[j]*i)<=Limit;j++){
      F[t]=(F[i]*(i%p[j]==0 ? p2[j] : F[p[j]]))%mod;
      e[t]=1;
      if (i%p[j]==0)break;
    }
  }for (int i=1;i<=Limit;i++){
  	 F[i]+=F[i-1];
  	 if (F[i]>=mod)F[i]-=mod;
  }
}
long long calc(int N,int M)
{
  int l=1,r;
  long long ans=0;
  for (;l<=min(N,M);l=r+1){
  	r=min(N/(N/l),M/(M/l));
    ans=(ans+1ll*(N/l)*(M/l)%mod*(F[r]-F[l-1]))%mod;
  }return ans;
}
int main()
{
  scanf("%d",&T);
  Limit=T>100 ? 20000000 : 5000000;
  getsth();
  while(T--){
  	scanf("%d%d%d",&N,&M,&P);
  	long long ans=0;
  	ans=1ll*N*calc(M,P)+1ll*M*calc(N,P)+1ll*P*calc(N,M);
  	printf("%lld\n",(ans%mod+mod)%mod);
  }return 0;
}
```

~~为了最优解松了半天，终于到手~~

---

## 作者：FjswYuzu (赞：1)

本文公式渲染较多，如果爆炸可以去博客获得更好体验。[戳我](https://www.luogu.com.cn/blog/blog10086001/solution-p5176)。

式子很长，让人感到无从下手。实际上原题的式子就是下面的式子：

$$\displaystyle \sum_{i=1}^n \sum_{j=1}^m \sum_{k=1}^p \gcd(i,j)^2 + \gcd(i,k)^2 + \gcd(j,k)^2 $$

这个结论可以通过唯一分解定理展开得到。关键是这个式子怎么求。

我们发现这个长式子可以拆成三个小式子，因为 $\gcd(i,j)$ 与 $k$，$\gcd(i,k)$ 与 $j$，$\gcd(j,k)$ 与 $i$ 都无关。于是原式可以化为：

$$\displaystyle p\times \sum_{i=1}^n  \sum_{j=1}^m \gcd(i,j)^2 + m\times \sum_{i=1}^n \sum_{j=1}^p \gcd(i,j)^2 + n \times \sum_{i=1}^m \sum_{j=1}^p \gcd(i,j)^2$$

暂时不管系数。我们发现这三个小式子是类似的。于是我们考虑计算 $\displaystyle \sum_{i=1}^n \sum_{j=1}^m \gcd(i,j)^2$。

我们钦定 $n<m$，接下来就化式子吧。

枚举 $\gcd(i,j)$：

$$\displaystyle \sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)=d] \times d^2$$

将 $d^2$ 提前，并且修改上界及 $[\ ]$ 里的内容：

$$\displaystyle \sum_{d=1}^{n} d^2\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}[\gcd(i,j)=1]$$

已经出现了 $[\gcd(i,j)=1]$ 了。套用莫比乌斯反演的套路：

$$\displaystyle \sum_{d=1}^n d^2 \sum_{D=1}^{{\lfloor \frac{n}{d} \rfloor}}\mu(D) \lfloor \dfrac{n}{dD}\rfloor \lfloor \dfrac{m}{dD}\rfloor$$

$dD$ 看起来太麻烦，令 $dD=T$ 并进行枚举。

$$\displaystyle \sum_{d=1}^n \sum_{T=1}^n d^2\mu(T) \lfloor \dfrac{n}{T}\rfloor \lfloor \dfrac{m}{T}\rfloor$$

$$\displaystyle \sum_{T=1}^n \sum_{k|T}k^2\mu(\dfrac{T}{k}) \lfloor \dfrac{n}{T}\rfloor \lfloor \dfrac{m}{T}\rfloor$$

令 $f(T) =\sum_{k|T}k^2 \mu(\dfrac{T}{k})$。

$$\displaystyle \sum_{T=1}^n f(T) \lfloor \dfrac{n}{T}\rfloor \lfloor \dfrac{m}{T}\rfloor$$

我们发现 $f(x)$ 是一个积性函数。可以线性筛出处理。剩下的部分整除分块即可。

---

### 对于 $f(x)$ 的处理

如果 $x$ 为质数，此时 $x$ 唯有 $1,x$ 两个因子，$\displaystyle f(x)=x^2\times \mu(\dfrac{x}{x}=1)+1^2 \times \mu(\dfrac{x}{1}=x)=x^2-1$。

否则，在线性筛中处理 $f(i \times \operatorname{prime}_j)$：

$$f(i \times \operatorname{prime}_j)=
\begin{cases}
f(i) \times {\operatorname{prime}_j}^2 \ \ \ \ \ \operatorname{prime}_j|i\\\\
f(i) \times f(\operatorname{prime}_j)\ \operatorname{otherwise}
\end{cases}$$

---

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
LL read()
{
    LL x=0,f=1;
    char c=getchar();
    while(c<'0' || c>'9')
    {
        if(c=='-')  f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
    return x*f;
}
void write(LL x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const LL MOD=1000000007;
LL f[20000005];
int prime[20000005],mu[20000005],cnt;
bool vis[20000005];
void shai(LL up)
{
	f[1]=1;
	for(LL i=2;i<=up;++i)
	{
		if(!vis[i])	prime[++cnt]=i,mu[i]=-1,f[i]=i*i%MOD-1;
		for(LL j=1;j<=cnt && prime[j]*i<=up;++j)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j])	f[i*prime[j]]=f[i]*f[prime[j]]%MOD;
			else
			{
				f[i*prime[j]]=f[i]*prime[j]%MOD*prime[j]%MOD;
				break;
			}
		}
	}
	for(LL i=2;i<=up;++i)	f[i]+=f[i-1],f[i]%=MOD;
}
LL calc(LL n,LL m)
{
	if(n>m)	n^=m^=n^=m;
	LL ans=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		ans+=(f[r]-f[l-1]+MOD)*(n/l)%MOD*(m/l)%MOD;
		ans%=MOD;
	}
	return ans%MOD;
}
int main(){
	LL T=read();
	shai(20000003);
	while(T-->0) 
	{
		LL n=read(),m=read(),p=read();
		LL ans=((n*calc(m,p)%MOD+m*calc(n,p)%MOD)%MOD+p*calc(n,m)%MOD)%MOD;
		write(ans);
		puts("");
	}
	return 0;
}
```

---

## 作者：derta (赞：1)

[luogu P5176 公约数](https://www.luogu.com.cn/problem/P5176)

~~看了就不想做系列~~

先通分：

$$\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}\gcd(ij,ik,jk)\gcd(i,j,k)\frac{\gcd^2(i,j)+\gcd^2(i,k)+\gcd^2(j,k)}{\gcd(i,j)\gcd(i,k)\gcd(j,k)}$$

看分母很不爽，考虑如何约去。

我们有公式：

$$\gcd(ij,ik,jk)=\frac{\gcd(i,j)\gcd(i,k)\gcd(j,k)}{\gcd(i,j,k)}$$

证明：对于一个质数 $p$，设 $i$ 分解质因数后有 $a$ 个 $p$，$j$ 有 $b$ 个，$k$ 有 $c$ 个。不妨令 $a \leqslant b \leqslant c$，则 $\gcd(i,j)$ 分解质因数后有 $\min(a,b)$ 个 $p$，其余同理。最后发现左式为 $a+b$，右式为 $a+a+b-a$，两式相等，得证。

之后化简为：

$$\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p} \operatorname{gcd^2} (i,j)+\operatorname{gcd^2}(i,k)+\operatorname{gcd^2}(j,k)$$

易得：

$$\left(p\sum_{i=1}^{n}\sum_{j=1}^{m}\operatorname{gcd^2} (i,j))+(m\sum_{i=1}^{n}\sum_{k=1}^{p} \operatorname{gcd^2}(i,k)\right)+\left(\sum_{j=1}^{m}\sum_{k=1}^{p}\operatorname{gcd^2}(j,k)\right)$$

之后把

$$\sum_{i=1}^{n}\sum_{j=1}^{m}\operatorname{gcd^2} (i,j)$$

算出就 ok 了，十分套路。
$$\sum_{k=1}^{n}k^2\sum_{i=1}^{n/k}\sum_{j=1}^{m/k}[\gcd(i,j)=1]$$
$$\sum_{k=1}^{n}k^2\sum_{i=1}^{n/k}\sum_{j=1}^{m/k}\sum_{d|i,d|j}\mu(d)$$
$$\sum_{k=1}^{n}k^2\sum_{d=1}^{n}\mu(d)\left\lfloor\frac{n}{kd}\right\rfloor\left\lfloor\frac{m}{kd}\right\rfloor$$

令 $T=kd$，得

$$\sum_{T=1}^{n}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor\sum_{k|T}k^2\mu\left(\frac{T}{k}\right)$$

后面的部分线性筛，每次询问整除分块即可。

```cpp
#include <iostream>
const int MAXN = 20000000, lnMAXN = 14, MOD = 1e9 + 7;
int Prime[MAXN/lnMAXN + 5], size;
bool not_prime[MAXN + 5];
int f[MAXN + 5];

inline int pm(int x)
{ return x < 0 ? x + MOD : x; }

inline int mm(int x)
{ return x >= MOD ? x - MOD : x; }

inline int Min(int x, int y)
{ return x < y ? x : y; }

void sieve(int n) { //预处理 
	not_prime[1] = true;
	f[1] = 1;
	//边界 
	for(int i = 2; i <= n; ++i) {
		if(not_prime[i] == false) {
			Prime[size++] = i; //加入质数表 
			f[i] = 1LL*i*i%MOD - 1;
		}
		for(int j = 0; j < size && i*Prime[j] <= n; ++j) {
			not_prime[i*Prime[j]] = true;
			if(i%Prime[j] == 0) {
				f[i*Prime[j]] = 1LL*f[i]*Prime[j]%MOD*Prime[j]%MOD;
				break;
			}
			f[i*Prime[j]] = 1LL*f[i]*f[Prime[j]]%MOD;
		}
	}
	for(int i = 2; i <= n; ++i)
		f[i] = mm(f[i - 1] + f[i]); //处理前缀和 
}

int solve(int n, int m) { //整除分块 
	if(n > m) //别忘了swap 
		std::swap(n, m);
	int res = 0;
	for(int i = 1, ni; i <= n; i = ni + 1) {
		ni = Min(n/(n/i), m/(m/i));
		res = mm(res + 1LL*(n/i)*(m/i)%MOD*pm(f[ni] - f[i - 1])%MOD);
	}
	return res;
}

int main() {
	std::ios_base::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);
	sieve(MAXN);
	int t;
	std::cin >> t;
	while(t--) {
		int n, m, p, ans;
		std::cin >> n >> m >> p;
		ans = (1LL*n*solve(m, p)%MOD + 1LL*m*solve(n, p)%MOD + 1LL*p*solve(n, m)%MOD)%MOD;
		std::cout << ans << "\n";
	}
	return 0;
} 
```

---

## 作者：Hyscere (赞：1)

挺有意思的一个题。

注意到$\gcd$的一个性质，我们只考虑一个质因子，设$i=p^x,j=p^y,k=p^z$，可以得到：
$$
\gcd(i,j)=p^{\min(x,y)},\gcd(i,j,k)=p^{\min(x,y,z)}
$$
那么根据这个我们可以尝试着化简题目给出的式子，通分之后把分母提出来，和前面两项乘起来就是：
$$
res=\dfrac{\gcd(i,j,k)\times \gcd(i\cdot j,j\cdot k,k\cdot i)}{\gcd(i,j)\times\gcd(j,k)\times\gcd(i,k)}
$$
由于这里只考虑一个质因子，我们可以两边取$\log$，然后设$\min(x,y,z)=x$，即$x$为最小值，这对答案是没有影响的，那么式子可以变成这样：
$$
\log_p(res)=2x+\min(y,y+z-x,z)-(2x+\min(y,z))
$$
可以发现$y+z-x\geqslant y,y+z-x\geqslant z$，所以可以得到：
$$
\log_p(res)=2x+\min(y,z)-(2x+\min(y,z))
$$
所以：

$$
\log_p(res)=0,res=1
$$

所以我们可以惊奇的发现，前面两项和分母约掉了，剩下的式子写出来就是：

$$ans=\sum_{i}\sum_{j}\sum_{k}\gcd(i,j)^2+\gcd(j,k)^2+\gcd(i,k)^2$$

这个直接大力反演就好了。

```c++
#include<bits/stdc++.h>
using namespace std;
 
void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

const int maxn = 2e7+10;
const int mod = 1e9+7;

int pri[maxn/10],mu[maxn],f[maxn],vis[maxn],tot;

void sieve() {
	mu[1]=f[1]=1;
	for(int i=2;i<maxn;i++) {
		if(!vis[i]) pri[++tot]=i,mu[i]=-1,f[i]=1ll*i*i%mod-1;
		for(int v,j=1;j<=tot&&i*pri[j]<maxn;j++) {
			vis[v=i*pri[j]]=1;
			if(i%pri[j]==0) {f[v]=1ll*f[i]*pri[j]%mod*pri[j]%mod;break;}
			f[v]=1ll*f[i]*f[pri[j]]%mod,mu[v]=-mu[i];
		}
	}
	for(int i=1;i<maxn;i++) f[i]=(f[i]+f[i-1])%mod;
}

int calc(int n,int m) {
	int T=1,res=0;
	while(T<=min(n,m)) {
		int pre=T;T=min(n/(n/T),m/(m/T));
		res=(res+1ll*(f[T]-f[pre-1])*(n/T)%mod*(m/T)%mod)%mod;T++;
	}return (res+mod)%mod;
}

int main() {
	sieve();
	int T,n,m,p;read(T);
	while(T--) read(n),read(m),read(p),write(((1ll*calc(n,m)*p%mod+1ll*calc(n,p)*m%mod)%mod+1ll*calc(m,p)*n%mod)%mod);
	return 0;
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：0)

首先，考虑如何简化 $\gcd(ij,ik,jk)\gcd(i,j,k)$。

假设质数 $p$ 在 $i,j,k$ 里面的质因数分解次幂分别是 $a,b,c$。不妨设 $0\le i\le j\le k$。那么，$p$ 在 $\gcd(ij,ik,jk)\gcd(i,j,k)$ 的次幂等于它在 $\gcd(ij,ik,jk)$ 里面的次幂加上它在 $\gcd(i,j,k)$ 的次幂。

根据 $\gcd$ 性质，$\gcd(ij,ik,jk)$ 里次幂是 $\min(a+b,a+c,b+c)=a+b$，在 $\gcd(i,j,k)$ 里次幂是 $\min(a,b,c)=a$，总共是 $2a+b$。

注意到这个用了最小次幂 $a$ 两次，次小次幂 $b$ 一次，最大次幂 $c$ 零次，这个等价于所有 $\{i,j,k\}$ 形成的对里面次幂最小的次幂，或者 $\gcd(i,j)\gcd(i,k)\gcd(j,k)$。

推式子。

$$\gcd(ij,ik,jk)\gcd(i,j,k)(\frac{\gcd(i,j)}{\gcd(i,k)\gcd(j,k)}+\frac{\gcd(i,k)}{\gcd(i,j)\gcd(j,k)}+\frac{\gcd(j,k)}{\gcd(i,j)\gcd(i,k)})=$$
$$\gcd(i,j)\gcd(i,k)\gcd(j,k)(\frac{\gcd(i,j)}{\gcd(i,k)\gcd(j,k)}+\frac{\gcd(i,k)}{\gcd(i,j)\gcd(j,k)}+\frac{\gcd(j,k)}{\gcd(i,j)\gcd(i,k)})=$$
$$\gcd(i,j)^2+\gcd(i,k)^2+\gcd(j,k)^2$$

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\gcd(i,j)^2+\gcd(i,k)^2+\gcd(j,k)^2=$$
$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\gcd(i,j)^2+\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\gcd(i,k)^2+\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^p\gcd(j,k)^2$$
注意到在第一个和里面 $k$ 没有任何贡献，在第二个里面 $j$ 没有任何贡献，在第三个里面 $i$ 没有任何贡献，所以可以把所有和里面的一个 $\sum$ 去掉。
$$p\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)^2+m\sum_{i=1}^n\sum_{k=1}^p\gcd(i,k)^2+n\sum_{j=1}^m\sum_{k=1}^p\gcd(j,k)^2$$

到这里就可以直接搬运 P4449 代码了。

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// begin fast read template by CYJian (source: https://www.luogu.com.cn/paste/i11c3ppx)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

// end fast read template by CYJian

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define all(a) a.begin(), a.end()
#define fi first
#define se second
#define pb push_back
#define mp make_pair
 
using ll=long long;
using pii=pair<int, int>;
//#define int ll
const int MOD = 1000000007;

int qpow(const int&b, const int&e) {
	if(!e) return 1;
	if(!(e&1)) return qpow(1ll*b*b%MOD,e>>1);
	return 1ll*b*qpow(b,e-1)%MOD;
}
int pp[20000006];

int K = 2;

int primes[1600000]; int cnt;
int bs[20000006], tot[20000006];
ll g[20000006];
void sve(int n) {
	g[1] = 1;
	iter(i, 2, n+1) {
		if(!bs[i]) {
			primes[cnt++] = i;
			bs[i] = tot[i] = i;
			g[i] = pp[i] + MOD - 1;
			if(g[i] >= MOD) g[i] -= MOD;
		}
		for(int j=0; j<cnt && i*primes[j]<=n; j++) {
			int v = i*primes[j];
			if(i%primes[j]) {
				bs[v] = tot[v] = primes[j];
				g[v] = 1ll*g[i]*g[primes[j]]%MOD;
			} else {
				bs[v] = primes[j];
				tot[v] = tot[i]*primes[j];
				g[v] = 1ll*g[v/tot[v]]*(pp[tot[v]]-pp[tot[i]]+MOD)%MOD;
				break;
			}
		}
	}
}

int solve(ll n, ll m) {
	int s = min(n, m), r, ans = 0;
	for(int l=1; l<=s; l=r+1) {
		r = min(n/(n/l), m/(m/l));
		int t = g[r] - g[l-1] + MOD;
		ans = (ans + t * (n/l) % MOD * (m/l)) % MOD;
	}
	return ans;
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
	int T; gi(T);
	rep1(i, 20000000) pp[i] = 1ll * i * i % MOD;
	sve(20000000);
	rep1(i, 20000000) {
		g[i] += g[i-1];
		if(g[i] >= MOD) g[i] -= MOD;
	}
	while(T--) {
		ll n, m, p; gi(n), gi(m), gi(p);
		ll ans = n * solve(m, p) + m * solve(n, p) + p * solve(n, m);
		print(ans % MOD); pc('\n');
	}
}

```

---


# [LnOI2019] 东京夏日相会

## 题目背景

![avartar](https://cdn.luogu.com.cn/upload/pic/52827.png)

「听说有烟火大会在下周举办呢」

「诶？ 那种人多的地方我不太喜欢呢」

「啊， 那我还是问问别人好了╭(╯^╰)╮」

「唔， 好像还是很有趣呢。我说不定会去吧(⊙﹏⊙)b」


## 题目描述

当然上面发生的事情和Abbi没有任何一点关系。作为一只长(zhang)了脖子的单身鹿，Abbi只能在家拿着“望远镜”孤独地在远处欣赏烟火大会。

![avartar](https://cdn.luogu.com.cn/upload/pic/52828.png)

~~啥？什么狙击枪？这是望远镜啊！（认真）~~

为了看到夜空中所有的烟花，Abbi需要调整“望远镜”的放大倍数与位置。夜空可近似地看成一个平面，其中第$i$朵烟花可以近似地看作一个圆心为$(x_i,y_i)$，半径为$r_i$的圆。

Abbi的望远镜视野可以近似地看作一个圆。因为调整放大倍数很累，因此Abbi希望在满足所有烟花都**完整**地出现在视野中的同时，视野的半径尽可能小。请你求出视野的圆心坐标与半径。

## 说明/提示

![avartar](https://cdn.luogu.com.cn/upload/pic/52900.png)

**请开启O2优化。建议使用读入优化或scanf读入数据。**

## 样例 #1

### 输入

```
3
1.0 1.0 1.0
1.0 4.0 1.0
5.0 1.0 1.0```

### 输出

```
3.00 2.50 3.50```

## 样例 #2

### 输入

```
3
4.0 1.0 1.0
4.0 7.0 1.0
5.0 5.0 3.0```

### 输出

```
4.63 4.00 4.07```

# 题解

## 作者：ecnerwaIa (赞：9)

这题真有趣!疯狂卡常+剪枝（虽然还只是最优解第五...）

关于此题如果直接拆点再用[P1742 最小圆覆盖](https://www.luogu.org/problemnew/show/P1742)就TLE了（试过了）

关于什么$d<=acos(1-0.005/r)$不可能过的，因为这个式子完全没有考虑在$r$很大的时候的情况,

![](https://cdn.luogu.com.cn/upload/pic/53753.png)

小圆是我需要拆点的圆，大圆假设是答案需要的圆，将其部分放大

![](https://cdn.luogu.com.cn/upload/pic/53754.png)

误差是怎么来的呢？其实上图告诉了你（只是特殊情况,这样误差会最大）。实际上一个圆上只会有一个点对答案有贡献，但是因为拆点的原因你只有$\frac{1}{inf}$的可能将那个点拆出来,所以基本上肯定会有误差。

假设小圆半径为r,大圆半径为R

假设拆开两点的角度为$\theta$，如果当成$d=(1-cos\frac{\theta}{2})r$来算误差 $d=(1-cos\frac{\theta}{2})r<=0.005$(两边所以除以2)来算，那么$\theta<=2*arccos(1-0.005/r)$（为什么我算的不是$acos(1-0.005/r)$啊$QAQ$）

但是实际上误差真的是这个吗....当$R>>r$（远大于的意思）的时候确实是的，但是当$R,r$接近呢？如果$R=r$我们可以很轻松的知道，是没有误差的（R>=r，如果等于那么肯定圆心是同一个了，那么只要拆出三个点就可以做到零误差）

我们假设拆出的相邻两点对应小圆圆心角为$\theta$,对应大圆$\alpha$,小圆半径为$r$，大圆半径为$R$

接下来就可以求误差了，$d=(r-cos\frac{\theta}{2} r)-(R-cos\frac{\alpha}{2}*R)=(1-cos\frac{\theta}{2})*r-(1-cos\frac{\alpha}{2})*R$

又因为我们有这么个式子$:$

$$sin\frac{\theta}{2}*r=sin\frac{\alpha}{2}*R$$

$$sin\frac{\alpha}{2}=sin\frac{\theta}{2}*\frac{r}{R}$$

$$cos\frac{\alpha}{2}=\sqrt{(1-(sin\frac{\theta}{2}*\frac{r}{R})^2)}$$

然后代入上面求误差的公式即可知道$\theta$和$r,R$的关系了....

$$\sqrt{1-(sin\frac{\theta}{2}*\frac{r}{R})^2}R-cos\frac{\theta}{2}*r<=0.005+R-r$$

然后左右平方，消来消去，$balabala$,最后发现$R$根本无法确定，好的，恭喜你做了一堆无用功...如果你能求出具体关系当然更好啦，可是我们要将随机化的思想发扬光大啊！

可以确定的一点$:r<<R$时间隔圆心角可以取的较大，$r<R$并且接近的时候可以取的较大

在这里想到了什么函数没有？发现**对勾函数**刚好满足（如果有更优的函数也可以提出来）。

对勾函数刚好可以**满足过小或者过大时函数值较大**，而中间函数极值点是可以我们人为构造的

那么我们不妨先求若干次点对距离最大值作为极值点（不要过多过少，否则求到极大极小值都是不好的，可以经过~~严密的~~计算发现取到**距离中位数**的可能性最大，多好！）

取$n$，或者$n<<1$次最大值就好，假设最大值为$G$，$G$是距离，所以令$G=G/2$求出我们要的一个伪半径,$D=G^2$,那么$f(x)=x+\frac{D}{x}$

等等！$G$很大或者很小不就出了问题么？那我们把它变得和$G$无关不就行了吗，当$x=G$的时候$f(x)=2*G$最小，要让他为$1$,所以构造的函数除以$2*G$就好了

$$f(x)=\frac{x+\frac{D}{x}}{2*G}$$

但是这还不够完美，因为$x$太大太小都会变得很大，求导后$g(x)=1-\frac{D}{x^2}$那么当$x->0$时，增长太快了，可能就会精度出问题呢（试过，如果不做处理，大数据会相差0.2左右）

这里最好的方法还是加个指数，这样精度就有保证了（至于是多少自己定吧，太小会导致时间慢，太大了比如0.99会导致精度有点误差，最好是0.95,0.96，0.97左右）

那么拆一个半径为$r$的圆，相邻圆心角大概在$max(360*f(r)*acos(1-0.003/r)/PI,1.0)$，那么就是

$$360*f(r)*acos(1-0.003/r)/PI$$

$$f(r)=pow((x+D/x)/G,0.97)$$

加上这个优化其实就可以过了，而且精度误差在0.01以内甚至更小，但是如果要加快速度的话就要牺牲一定的精度，不能让你兼得的嘛！

然而我们还有个可怕的优化，在$n$很大的时候，几乎不会造成牺牲精度，而且可以带来**时间快1倍**，**主要是很好写**！（不用那么多的判断）

假设我们处理出了$x,y$的最大最小值分别为$minx,maxx,maxy,miny$,将其看成一个矩形，矩形中点为$((minx+maxx)/2,(miny+maxy)/2)$那么不难发现其实矩形中间大部分的点是肯定不会对答案有任何贡献的，那么为什么不直接删去那些肯定不是的呢？

那我加一句话就好了，如果要加入的点$(x,y)$，矩形中点为$(px,py)$,如果$\sqrt2*fabs(x-px)+eps<px-minx||\sqrt2*fabs(y-py)+eps<py-miny$我就不要$(x,y)$了

证明就自己证一下吧（反正我把最大的点拿来测，加与不加精度好像完全相同啊）

关于最小圆覆盖就不是此题解需要讲的了吧

还有就是注意一下！$n$很小的时候，$f$函数因为极值点取$n<<1$次，可能取到什么极大极小值而对精度产生较大的影响....（事实上只要$G$不是太小，太大精度就不会有问题，而$n$很小的时候就死了）

但是还好此题没有坑，如果有也好处理，手动加个修正就行了，具体怎么修不需要说吧....当$n<=10$时$f$函数乘一个0.618就好了(没有实际意义，自己定)

上代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <ctime>
using namespace std;
int n,m;
const double eps=1e-4,PI=3.1415926535897932384626433832795028841971;
const double inf=11234567890,W=1.41421356730950488;
const int N=1e7+5e6,M=50010;
struct point{
    double x,y;
    point(double a=0,double b=0){x=a;y=b;}
}O,a[N];
double G,D;
struct node{double x,y,r;}b[M];
inline double sqr(double x){return x*x;}
inline double max_(double a,double b){return (a>b?a:b);}
inline double min_(double a,double b){return (a<b?a:b);}
inline double fabs_(double x){return (x<0?-x:x);}
inline double f(double x){return pow((x+D/x)*G,0.976);}
double mix,mx,miy,my,px,py;
void work(double x,double y,double r){
    if(r<eps){a[++m]=point(x,y);return;}
    double delta=max_(360*f(r)*acos(1-0.003/r)/PI,1.0);
    for(int i=0;i<360;i+=delta){
        double alpha=i*PI/180;
        double X=x+r*cos(alpha),Y=y+r*sin(alpha);
        if(fabs_(px-X)*W+eps<px-mix)continue;
        if(fabs_(py-Y)*W+eps<py-miy)continue;
        a[++m]=point(X,Y);
    }
}
double R;
inline double dist(point x,point y){
    return sqrt(sqr(x.x-y.x)+sqr(x.y-y.y));
}
inline bool in(point x){
    return dist(x,O)-R<eps;
}
inline void get(point x1,point x2,point x3){
    double a,b,c,d,e,f;
    a=x2.x-x1.x,b=x2.y-x1.y,c=x3.x-x2.x,d=x3.y-x2.y;
    e=x2.x*x2.x+x2.y*x2.y-x1.x*x1.x-x1.y*x1.y;
    f=x3.x*x3.x+x3.y*x3.y-x2.x*x2.x-x2.y*x2.y;
    O.x=(f*b-e*d)/(c*b*2-a*d*2);
    O.y=(a*f-e*c)/(a*d*2-b*c*2);
    R=dist(O,x1);
}
int main(){
    srand(time(NULL));
    scanf("%d",&n);mix=inf;miy=inf;mx=-inf;my=-inf;
    for(int i=1;i<=n;++i){
		scanf("%lf%lf%lf",&b[i].x,&b[i].y,&b[i].r);
		mix=min_(mix,b[i].x-b[i].r);mx=max_(mx,b[i].x+b[i].r);
		miy=min_(miy,b[i].y-b[i].r);my=max_(my,b[i].y+b[i].r);
	}px=(mix+mx)/2;py=(miy+my)/2;
    int A,B,maxn;maxn=n<=100?(n>>1):n<<1;
    for(int i=1;i<=maxn;++i){
        A=rand()%n+1;B=rand()%n+1;
        G=max_(G,sqrt(sqr(b[A].x-b[B].x)+sqr(b[A].y-b[B].y))+b[A].r+b[B].r);
    }G/=2;D=sqr(G);G*=2;G=1/G;
    for(int i=1;i<=n;++i)work(b[i].x,b[i].y,b[i].r);
    random_shuffle(a+1,a+1+m);
    O=a[1];R=0;
    for(int i=2;i<=m;++i)
        if(!in(a[i])){
            O=a[i];R=0;
            for(int j=1;j<i;++j)
                if(!in(a[j])){
                    O.x=(a[i].x+a[j].x)/2;O.y=(a[i].y+a[j].y)/2;
                    R=dist(O,a[i]);
                    for(int k=1;k<j;++k)
                        if(!in(a[k]))get(a[i],a[j],a[k]);
                }
        }
    printf("%.2lf %.2lf %.2lf\n",O.x,O.y,R);
    return 0;
}

```
终于写完了，就怕没人看啊QAQ

PS:为了做精度，速度实验交了好多次啊

upd:如果非要给我卡精度，也没问题，下面是修正代码（r<=100000自测可以精度可以达到0.14,如果要卡到0.02可能时间会慢很多）

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <ctime>
using namespace std;
int n,m;
const double eps=1e-4,PI=3.1415926535897932384626433832795028841971,E=1.217;
const double inf=11234567890,W=1.41421356730950488;
const int N=1e7+5e6,M=50010;
struct point{
    double x,y;
    point(double a=0,double b=0){x=a;y=b;}
}O,a[N];
double G,D,Z,K;
struct node{double x,y,r;}b[M];
inline double sqr(double x){return x*x;}
inline double max_(double a,double b){return (a>b?a:b);}
inline double min_(double a,double b){return (a<b?a:b);}
inline double fabs_(double x){return (x<0?-x:x);}
inline double f(double x){return Z*pow((x+D/x)*G,K);}
double mix,mx,miy,my,px,py;
void work(double x,double y,double r){
    if(r<eps){a[++m]=point(x,y);return;}
    double delta=max_(360*f(r)*acos(1-0.003/r)/PI,1.0);
    delta=min_(delta,120);
    for(int i=0;i<360;i+=delta){
        double alpha=i*PI/180;
        double X=x+r*cos(alpha),Y=y+r*sin(alpha);
        if(fabs_(px-X)*W+eps<px-mix)continue;
        if(fabs_(py-Y)*W+eps<py-miy)continue;
        a[++m]=point(X,Y);
    }
}
double R;
inline double dist(point x,point y){
    return sqrt(sqr(x.x-y.x)+sqr(x.y-y.y));
}
inline bool in(point x){
    return dist(x,O)-R<eps;
}
inline void get(point x1,point x2,point x3){
    double a,b,c,d,e,f;
    a=x2.x-x1.x,b=x2.y-x1.y,c=x3.x-x2.x,d=x3.y-x2.y;
    e=x2.x*x2.x+x2.y*x2.y-x1.x*x1.x-x1.y*x1.y;
    f=x3.x*x3.x+x3.y*x3.y-x2.x*x2.x-x2.y*x2.y;
    O.x=(f*b-e*d)/(c*b*2-a*d*2);
    O.y=(a*f-e*c)/(a*d*2-b*c*2);
    R=dist(O,x1);
}
int main(){
	freopen("0.in","r",stdin);
    srand(time(NULL));
    scanf("%d",&n);mix=inf;miy=inf;mx=-inf;my=-inf;
    for(int i=1;i<=n;++i){
        scanf("%lf%lf%lf",&b[i].x,&b[i].y,&b[i].r);
        mix=min_(mix,b[i].x-b[i].r);mx=max_(mx,b[i].x+b[i].r);
        miy=min_(miy,b[i].y-b[i].r);my=max_(my,b[i].y+b[i].r);
    }px=(mix+mx)/2;py=(miy+my)/2;
    int A,B,maxn;maxn=n<=100?(n>>1):n<<1;
    for(int i=1;i<=maxn;++i){
        A=rand()%n+1;B=rand()%n+1;
        G=max_(G,sqrt(sqr(b[A].x-b[B].x)+sqr(b[A].y-b[B].y))+b[A].r+b[B].r);
    }
    Z=max_(max_(-mix,mx),max_(-miy,my));
	Z=0.2+pow(E,-pow(Z,0.23)*0.7)*0.8;K=pow(Z,0.9)*0.4+0.6;G=pow(G,K);
	G/=2;D=sqr(G);G*=2;G=1/G;
    for(int i=1;i<=n;++i)work(b[i].x,b[i].y,b[i].r);
    random_shuffle(a+1,a+1+m);
    O=a[1];R=0;
    for(int i=2;i<=m;++i)
        if(!in(a[i])){
            O=a[i];R=0;
            for(int j=1;j<i;++j)
                if(!in(a[j])){
                    O.x=(a[i].x+a[j].x)/2;O.y=(a[i].y+a[j].y)/2;
                    R=dist(O,a[i]);
                    for(int k=1;k<j;++k)
                        if(!in(a[k]))get(a[i],a[j],a[k]);
                }
        }
    printf("%.5lf %.5lf %.5lf\n",O.x,O.y,R);
    return 0;
}
```


---

## 作者：Hope2075 (赞：8)

upd:既然已经决定用解析几何暴力求了，就暴力到底吧QWQ

~~以下是废话~~

去年比赛时做了这道题，写模拟退火被卡精度，只有30分

当时就想试试用最小覆盖圆的思路，每一步用解析式直接求圆的圆心坐标和半径

然后我想了一下，一般情况需要求3条双曲线的交点（根据性质，应该至少有一个公共交点），也就是解二元二次方程，而且消元很麻烦，就放弃了

今年突然心血来潮，便尝试求了一下，发现并没有那么复杂，就用新的做法A了这道题，而且抢了最优解(2020-06-20 10:32:54 69ms)

下面是具体思路

# 基本思路

按照点的最小圆覆盖的做法求这些圆的最小圆覆盖，也就是[P1742](https://www.luogu.com.cn/problem/P1742)

最小圆覆盖：用的随机增量法，进行$n$步，每一步加入一个点。如果这个点在之前$i-1$个点的最小覆盖圆内部，那么就跳过。否则这个点必定在前$i$个点的最小覆盖圆上，枚举之前$i-1$个点组成的点对即可

如果把上面的“点”换成“圆”，也成立，所以可以用类似的思路做这道题

复杂度和点的最小覆盖圆相同，参考那道题的证明即可（常数大一些）

另外，在求交点时可以发现一个特殊的性质，就能简化计算

# 具体做法

以下设三个圆分别为

$O_1(x_1,y_1),r_1$

$O_2(x_2,y_2),r_2$

$O_3(x_3,y_3),r_3$

## 求一个圆的最小圆覆盖

很明显，取这个圆本身就行

## 求两个圆的最小圆覆盖

(两个圆的圆心分别是$O_1$和$O_2$)

分为两种情况

#### 第一种：两圆半径相等

那么圆心就是两圆圆心连线的中点，半径就是圆心距离的一半加上一个圆的半径

表示出来就是：

$O(\frac{x_1+x_2}{2},\frac{y_1+y_2}{2}),r=\frac{1}{2}|O_1O_2|+r_1$

（图略，应该很好画）

#### 第二种：两圆半径不相等

这时候圆心到两圆的距离之差就是半径之差，而且圆心更靠近大圆

也就是这样

![](https://cdn.luogu.com.cn/upload/image_hosting/egcvfmql.png)

圆心到中点的距离就是半径差的一半

先把中点坐标求出来，再偏移一下就行

半径就用到某个圆心的距离加上那个圆的半径

表示出来就是

$M(\frac{x_1+x_2}{2},\frac{y_1+y_2}{2}),\vec{MO}=\frac{(r_2-r_1)\vec{O_1O_2}}{2|\vec{O_1O_2}|},r=|OO_1|+r_1$


## 求三个圆的最小圆覆盖

如果某两个圆是包含关系，那么求两个圆的最小圆覆盖即可，而且算法可以保证不会出现这种情况

理论上要分三种情况，但实际有两种可以合并

#### 第一种：三个圆半径均相等

这时候求三角形的外接圆，把半径加上某个圆的半径即可

求外接圆的办法可以参考最小圆覆盖的题解

可以发现这样的圆恰好与这三个圆均内切

也就是这样

![](https://cdn.luogu.com.cn/upload/image_hosting/xksxv1rf.png)

#### 第二种：存在两个圆半径不相等

这时候对于某两个圆而言，满足条件的圆的圆心在一条直线或双曲线上

方程就是$\sqrt{(x-x_1)^2+(y-y_1)^2}+r_1=\sqrt{(x-x_2)^2+(y-y_2)^2}+r_2$

如果两圆半径相等，那么这个方程表示中垂线，否则就表示双曲线（已经限制任意两圆不能是包含关系了）

画出来大概这样（第一个是存在两圆半径相等的情况）

![](https://cdn.luogu.com.cn/upload/image_hosting/p59jfn3a.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/2r9s4pri.png)

注意图中的深蓝色直线，它有特殊含义，下面会进行叙述

首先，设$A_i=(x-x_i)^2+(y-y_i)^2$

那么方程可以表示为$\sqrt{A_1}+r_1=\sqrt{A_2}+r_2$

可以化为$\sqrt{A_1}-\sqrt{A_2}=r_2-r_1$

分子有理化，再取倒数，得$\sqrt{A_1}+\sqrt{A_2}=\frac{A_1-A_2}{r_2-r_1}$

相加，得$2\sqrt{A_1}=\frac{A_1-A_2}{r_2-r_1}+r_2-r_1$

先不要着急平方，再写一个式子

$2\sqrt{A_1}=\frac{A_1-A_3}{r_3-r_1}+r_3-r_1$

所以$\frac{A_1-A_2}{r_2-r_1}+r_2-r_1=\frac{A_1-A_3}{r_3-r_1}+r_3-r_1$

可以看出这是一次方程，也就是图中的深蓝色直线

继续化简，设直线方程为$ax+by+c=0$，那么

$a=\left|\begin{array}{cccc} 
    x_1 &    r_1    & 1 \\ 
    x_2 &    r_2   & 1\\ 
    x_3 & r_3 & 1 
\end{array}\right|$

$b=\left|\begin{array}{cccc} 
    y_1 &    r_1    & 1 \\ 
    y_2 &    r_2   & 1\\ 
    y_3 & r_3 & 1 
\end{array}\right|$

$c=-\frac{1}{2}\left|\begin{array}{cccc} 
    x_1^2+y_1^2-r_1^2 &    r_1    & 1 \\ 
    x_2^2+y_2^2-r_2^2 &    r_2   & 1\\ 
    x_3^2+y_3^2-r_3^2 & r_3 & 1 
\end{array}\right|$

这样，所求圆的圆心也在这条直线上

接下来把原来双曲线的方程也化简一下（平方再整理就行，但整理很麻烦）

设双曲线的方程是$Ax^2+Bxy+Cy^2+Dx+Ey+F=0$

$A=4[(x_1-x_2)^2+(r_1-r_2)^2]$

$B=8(x_1-x_2)(y_1-y_2)$

$C=4[(y_1-y_2)^2+(r_1-r_2)^2]$

$D=4[(x_1+x_2)(r_1-r_2)^2-(x_1-x_2)(x_1^2+y_1^2-x_2^2-y_2^2)]$

$E=4[(y_1+y_2)(r_1-r_2)^2-(y_1-y_2)(x_1^2+y_1^2-x_2^2-y_2^2)]$

$F=(x_1^2+y_1^2-x_2^2-y_2^2)^2-2(x_1^2+y_1^2+x_2^2+y_2^2)(r_1-r_2)^2+(r_1-r_2)^4$

可以代入消元解方程组求坐标

用直线方程消元后得到一个二次方程，用$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$求根，再带入直线方程求出另一个坐标就行

注意直线方程的系数可能为0，需要判断一下

这时会发现有两个解，原因就是平方化简时出现了增根

另一个解恰好是与三个圆分别外切的圆的圆心

但我们需要选出其中一个，这时计算圆心到两个点的距离，比较大小关系就能确定这个根是不是需要的点（目标点距离较大的圆更远）

这样求出来的坐标和半径理论上就没有任何误差（但会受计算机精度限制）

### 暴力解方程

~~暴力要彻底~~

为了防止混淆，令

$A=\left|\begin{array}{cccc} 
    x_1 &    r_1    & 1 \\ 
    x_2 &    r_2   & 1\\ 
    x_3 & r_3 & 1 
\end{array}\right|$

$B=\left|\begin{array}{cccc} 
    y_1 &    r_1    & 1 \\ 
    y_2 &    r_2   & 1\\ 
    y_3 & r_3 & 1 
\end{array}\right|$

过程很繁琐，只说一下简单思路和解出的结果，具体过程全部省略

~~而且大部分解析式我并没有化简，只是猜的结论，但应该是对的~~

如果手动把系数代进去，会得到一个一元二次方程

~~解方程即可~~没这么简单

以下假设消去的是$y$

首先化简$x^2$的系数

通过化简，可以得到$4(r_1-r_2)^2(T^2-a^2-b^2)$

其中$T=\left|\begin{array}{cccc} 
    x_1 &    y_1   & 1\\ 
    x_2 &    y_2   & 1\\ 
    x_3 &    y_3   & 1 
\end{array}\right|$

可以想到，$(r_1-r_2)^2$可以消掉，否则交换两个点的顺序，结果就会不同

然后化简$x$的系数

明确了变形的方向就会简单一点，可以先把不含$(r_1-r_2)^2$的项合并，然后再和剩余部分合并，而且结果应该是交换任意两个点后保持不变的（也就是有对称性）

结果是$4(r_1-r_2)^2(x_1m_1n_1+x_2m_2n_2+x_3m_3n_3)$

其中$m_1=[(x_2-x_3)^2+(y_2-y_3)^2-(r_2-r_3)^2]$

$n_1=[(x_1-x_2)(x_3-x_1)+(y_1-y_2)(y_3-y_1)-(r_1-r_2)(r_3-r_1)]$

$m_2,n_2,m_3,n_3$类似

接下来似乎要求常数项的系数

但是考虑一下，就能找到更简便的方法

考虑二次方程求根方程：

$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$

求$b^2-4ac$就行（看起来复杂，实际上比化简系数再乘起来要简单）

根据前面的结果，可以求出两个解对应圆的圆心连线中点的坐标，而两个解则是这个点在直线上移动了一段距离

可以想到对于$x$和$y$的方程，后面$\pm\sqrt{b^2-4ac}$项分别含有因子$B$和$A$，并且均含$(r_1-r_2)^2$因子

按照上面的思路化简即可（最好先消掉因子$A$或$B$，这样较为简单）

可以得到$b^2-4ac=16B^2m_1m_2m_3(r_1-r_2)^2$（对于$x$）

表示出来的时候，应该是一个$\pm$，一个$\mp$

另一个问题：如何确定符号？

可以把半径也暴力求出来，求的时候就会发现根号限定了代入的$\pm$应该取哪一个（求出的结果应当对称）

（算到最后我没耐心化简了，就根据式子猜了几个结论，代数检验了一下）

最终结果：

$(\frac{U(x_1,x_2,x_3)+B\sqrt{\Delta}}{U(1,1,1)},\frac{U(y_1,y_2,y_3)-A\sqrt{\Delta}}{U(1,1,1)}),R=\frac{U(r_1,r_2,r_3)-T\sqrt{\Delta}}{U(1,1,1)}$

要求$T>0$。如果$T=0$，则三点共线。如果$T<0$，那么任意交换一对点后再算即可，或者改变符号也行

可以看出，对于半径两两相等的情况也适用

这样理论上可以运行得很快（用中间变量保留相同的值，每次计算只有一次开根号），而且可以用一些特殊方法做到任意精度

但测试时好像评测机性能不稳定，有些点会慢一点，总用时大约0.2s

## 求最终答案

和点的最小圆覆盖基本一样，只要把求两点或三点的最小覆盖圆换成相应圆的做法就行

## 关于特判

我想了一下，应该需要特判三个圆的情况（有时候只和两个圆相切就能盖住三个圆），否则可以手动造几组数据卡掉，但提交的时候没有WA，应该是因为数据随机

# 代码

这是没卡常的代码，基本就是按照上面的式子写的，用时405ms

（我在纸上推式子时就写的$x_1$之类的字母，为了省事，计算时没用结构体，调用函数时先把结构体拆开）

69ms的代码就看提交记录吧

主要是IO优化，另外计算过程也优化了一下

手动解方程的方法把对应部分换掉即可，应该比这个好写

```cpp
#include<iostream>
#include<cmath>
struct C{
    double x,y,r;
    C(){x=0;y=0;r=0;}
    C(double x0,double y0,double r0){x=x0;y=y0;r=r0;}
};
unsigned long long seed=666;
int rand(int l){
    return (seed=(seed*998244353+65537))%l;
}
void swap(double &a,double &b){
	double t=a;a=b;b=t;
}
void swap(C &a,C &b){
	C t=a;a=b;b=t;
}
double dis(double x1,double y1,double x2,double y2){
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
bool inside(C a,C b){//a in b
    if(a.r>=b.r)return false;
    if(dis(a.x,a.y,b.x,b.y)<=fabs(a.r-b.r))return true;
    return false;
}
void cal(double x1,double y1,double r1,double x2,double y2,double r2,double &px,double &py,double &r){
    if(r1==r2){
        double rx=(x1+x2)/2;
        double ry=(y1+y2)/2;
        double rr=dis(x1,y1,x2,y2)/2+r1;
        px=rx;py=ry;r=rr;
    }else{
        double mx=(x1+x2)/2;
        double my=(y1+y2)/2;
        double dr=r2-r1;
        double d=dis(x1,y1,x2,y2);
        double rx=mx+(x2-x1)*dr/d/2;
        double ry=my+(y2-y1)*dr/d/2;
        double rr=dis(x1,y1,rx,ry)+r1;
        px=rx;py=ry;r=rr;
    }
    
}
C cal(C c1,C c2){
    C cr;
    cal(c1.x,c1.y,c1.r,c2.x,c2.y,c2.r,cr.x,cr.y,cr.r);
    return cr;
}
void cal(double x1,double y1,double r1,double x2,double y2,double r2,double x3,double y3,double r3,double &px,double &py,double &r){
	if(r1>r2){//冒泡排序，保证取两个半径不同的圆
		swap(x1,x2);
		swap(y1,y2);
		swap(r1,r2);
	}
	if(r2>r3){
		swap(x2,x3);
		swap(y2,y3);
		swap(r2,r3);
	}
	if(r1>r2){
		swap(x1,x2);
		swap(y1,y2);
		swap(r1,r2);
	}
	if(r1==r3){//如果三个圆的半径相同，那么最大值等于最小值
        double t=2*(x2-x1)*(y3-y1)-2*(x3-x1)*(y2-y1);
		double rx=((x2*x2+y2*y2-x1*x1-y1*y1)*(y3-y1)-(x3*x3+y3*y3-x1*x1-y1*y1)*(y2-y1))/t;
		double ry=-((x2*x2+y2*y2-x1*x1-y1*y1)*(x3-x1)-(x3*x3+y3*y3-x1*x1-y1*y1)*(x2-x1))/t;
        double rr=dis(x1,y1,rx,ry)+r1;
        px=rx;py=ry;r=rr;
	}else{//否则最大的圆和最小的圆半径不同
		double a=x1*(r2-r3)+x2*(r3-r1)+x3*(r1-r2);
		double b=y1*(r2-r3)+y2*(r3-r1)+y3*(r1-r2);
		double c=-0.5*((x1*x1+y1*y1-r1*r1)*(r2-r3)+(x2*x2+y2*y2-r2*r2)*(r3-r1)+(x3*x3+y3*y3-r3*r3)*(r1-r2));
		
		double A=4*((x1-x3)*(x1-x3)-(r1-r3)*(r1-r3));
		double B=8*(x1-x3)*(y1-y3);
		double C=4*((y1-y3)*(y1-y3)-(r1-r3)*(r1-r3));
		double D=4*((x1+x3)*(r1-r3)*(r1-r3)-(x1-x3)*(x1*x1-x3*x3+y1*y1-y3*y3));
		double E=4*((y1+y3)*(r1-r3)*(r1-r3)-(y1-y3)*(x1*x1-x3*x3+y1*y1-y3*y3));
		double F=(x1*x1-x3*x3+y1*y1-y3*y3)*(x1*x1-x3*x3+y1*y1-y3*y3)-2*(x1*x1+x3*x3+y1*y1+y3*y3)*(r3-r1)*(r3-r1)+(r3-r1)*(r3-r1)*(r3-r1)*(r3-r1);
		
        double rx1,rx2,ry1,ry2;
        if(fabs(b)>fabs(a)){//取系数绝对值较大的，避免除以0
            double xa=b*b*A-a*b*B+a*a*C;
            double xb=-b*c*B+2*a*c*C+b*b*D-a*b*E;
            double xc=c*c*C-b*c*E+b*b*F;
            
            double dx=xb*xb-4*xa*xc;
            rx1=(-xb+sqrt(dx))/(2*xa);
            rx2=(-xb-sqrt(dx))/(2*xa);
            
            ry1=-(c+a*rx1)/b;
            ry2=-(c+a*rx2)/b;
            
            
            
            
            
        }else{
            double ya=a*a*C-b*a*B+b*b*A;
            double yb=-a*c*B+2*b*c*A+a*a*E-b*a*D;
            double yc=c*c*A-a*c*D+a*a*F;
            
            double dy=yb*yb-4*ya*yc;
            ry1=(-yb+sqrt(dy))/(2*ya);
            ry2=(-yb-sqrt(dy))/(2*ya);
            
            rx1=-(c+b*ry1)/a;
            rx2=-(c+b*ry2)/a;
            
        }
        
        double d11=dis(rx1,ry1,x1,y1);
        double d13=dis(rx1,ry1,x3,y3);
            
        double d21=dis(rx2,ry2,x1,y1);
            
        if(d11>d13){
            double rr1=d11+r1;
            px=rx1;py=ry1;r=rr1;
        }else{
            double rr2=d21+r1;
            px=rx2;py=ry2;r=rr2;
        }
	}
}
C cal(C c1,C c2,C c3){
    C cr;
    cal(c1.x,c1.y,c1.r,c2.x,c2.y,c2.r,c3.x,c3.y,c3.r,cr.x,cr.y,cr.r);
    return cr;
}
int n;
C list[50007];
C cur;
int main(){
	std::ios::sync_with_stdio(false);
    std::cin>>n;
    for(int i=1;i<=n;i++){
        double x,y,r;
        std::cin>>x>>y>>r;
        list[i]=C(x,y,r);
    }
    for(int i=n;i>1;i--){
    //需要打乱顺序，这样才能保证复杂度
        int p=rand(i);
        swap(list[i],list[p+1]);
    }
    cur=list[1];
    for(int i=2;i<=n;i++){
        if(!inside(list[i],cur)){
            cur=list[i];
            for(int j=1;j<i;j++){
                if(!inside(list[j],cur)){
                    cur=cal(list[i],list[j]);
                    for(int k=1;k<j;k++){
                        if(!inside(list[k],cur)){
                            cur=cal(list[i],list[j],list[k]);
                        }
                    }
                }
            }
        }
    }
    std::cout<<cur.x<<" "<<cur.y<<" "<<cur.r<<std::endl;
}
```

---

## 作者：LevenKoko (赞：5)

# [更好的阅读效果？戳我](https://www.cnblogs.com/zhenglw/p/10507209.html)

## 吐槽：虐狗的人就应该被狙击枪指着

## 这里来一发~~需要开毒瘤优化~~，并且~~几率很小~~一遍过的模拟退火题解...

~~友情提醒：如果你很久很久没有过某一个点，您可以加上特判~~


可以像 P1337 [JSOI2004]平衡点 / 吊打XXX 那道题目一样

如果不会退火可以拿那道题练手...

个人看来这题和那题差不多，主要区别在get_ans()的函数上面

如何get_ans呢？
（图很垃圾，别介意）
先看这张图：
![](https://i.loli.net/2019/03/10/5c850bc838c84.png)

假设中间的黑点是目前确定的圆心，要get的ans是离这个点最远的圆上的点

那么初中数学老师就会教你：**距离=两个圆心的距离+选中圆的半径**

像这样：
![](https://i.loli.net/2019/03/10/5c850c943b87a.png)

显然最远的点只要O（n）遍历取最大值就好了

然后套上退火的模板就好了吧

```
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
#pragma GCC optimize("Ofast")
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib> 
#include<ctime>
using namespace std;
inline int read(){
    int ans=0,f=1; char chr=getchar();
    while(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}
    while(isdigit(chr)) {ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
    return ans*f;
}
int n;
double x[50005],y[50005],z[50005],ansx,ansy,BR;
double dis(double x,double y,double a,double b){return sqrt((x-a)*(x-a)+(y-b)*(y-b));}
double get(double q,double p){
    double ans=0;
    for(register int i=1;i<=n;++i)
        ans=max(dis(x[i],y[i],q,p)+z[i],ans) ;
    return ans;
}
const double delta=0.999;
double ans=1e20,maxn=-54564564;
int lim;
void Fire(){
    register double fx=ansx,fy=ansy;
    register double t=12180.0;
    while(t>1e-14){
        register double tx=fx+(rand()*2-RAND_MAX)*t;
        register double ty=fy+(rand()*2-RAND_MAX)*t;
        register double tans=get(tx,ty);
        register double DE=tans-ans;
        if(DE<0){
            fx=tx;
            fy=ty;
            ansx=tx;
            ansy=ty;
            ans=tans;
        }else if(exp(-DE/t)*RAND_MAX>rand())
            fx=tx,fy=ty;
        t*=delta;
    	if(clock()-BR>=lim){printf("%.2lf %.2lf %.2lf",ansx-0.001,ansy+0.001,ans);exit(0);}
    }       
}
int main(){
    BR=clock();
    srand(unsigned(time(0)));
    n=read();
    for(register int i=1;i<=n;++i)	scanf("%lf%lf%lf",&x[i],&y[i],&z[i]),ansx+=x[i],ansy+=y[i],maxn=max(maxn,z[i]);
    ansx/=1.0*n;
    ansy/=1.0*n;
    lim=(n<=1000||maxn==0)?995:3995;
    lim*=1000;
    while(1) Fire();
    return 0;
}

```

---

## 作者：_MRCMRC_ (赞：5)

## 这个题刚才打比赛的时候只看出这是个最小圆覆盖问题
## 但是，就是不知道怎样在圆上取点才能使最小覆盖圆经过……
### 我还是太~~强~~弱了……qwq

------------

## 前置芝士：    
    
#### 1.最小圆覆盖问题  （[不会请转P1742](https://www.luogu.org/problemnew/show/P1742)）
#### 2.三角函数（取点需要）
    
------------

## 主要思想：

#### 1.微元分割法
#### 2.随机化（random_shuffel)

------------

## 具体处理方法：
##### 对于平面中每一个圆，需要求它们的最小覆盖圆
##### 其实很简单，对于$n$($n>=2$)个圆，找出与最外层圆相切的切点的集合，一定能确定一个圆
##### 特别地，对于1个圆，或者一个$r$为0的圆，它的最小覆盖圆为它本身
##### 但是问题来了，我们无法求得切点的具体位置，也就无法准确地找到最小的覆盖圆
##### 那么我们采用微元分割法，将每个圆等分成一定部分，像下面这样：
```cpp
double l=max(360*acos(1-0.003/r)/pi,1.0);
```
##### $l$ 代表截取的一定角度
##### 这样我们从$0$°开始枚举到$360$°即可把一个圆分割成$360/l$个点,这些点的集合可以近似表示一个圆

#### 如此将$n$个圆分割成点，即可在保证精度的情况下最大限度的保持覆盖圆最小

#### 分割时数字可以取得尽量小，保证不爆炸的情况下$0.003-0.005$即可

------------
### 接下来只需要对这平面上所有点跑一遍最小圆覆盖的板子，即可求出圆心坐标及半径

### 本蒟蒻在此用的随机增量法，还可以用基于蒙特卡罗随机化思想的模拟退火（玄学算法）处理 
~~（本蒟蒻不会模拟退火嘤嘤嘤~~
------------

## 特别注意！因为我们将圆分割成了点集，那么数组必需要开大！
## (本蒟蒻开的$2kw$ ~~不要问为什么是这个数字!qwq~~)


------------


# AC代码：
```cpp
#include<bits/stdc++.h>
#define in inline
#define reg register
#define int long long
#define INF 20030813
#define eps 1e-6
#define pi 3.14159265358979323846264338327950288419716939937510
using namespace std;
namespace qwq{
    in int read(int &o)
    {
        o=0;
        int w=1;
        char c=getchar();
        while(c<'0'||c>'9')
        {
            if(c=='-')w=-1;
            c=getchar();
        }
        while(c>='0'&&c<='9')
        {
            o=(o<<3)+(o<<1)+(c^48);
            c=getchar();
        }
        return o*w;
    }
    in void write(int x)
    {
    	if(x>9)write(x/10);
    	putchar(x%10+48);
    }
    in int max(int x,int y)
    {
        return x>y?x:y;
    }
    in int min(int x,int y)
    {
        return x<y?x:y;
    }
}
using namespace qwq;
int t,cnt;
double R,x,y,r,Ri;
class point
{
public:
	double x,y,r;
}o,num[20030813],cir[5001000];

double dist(point a,point b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

bool check(double x,double y)
{
	if(x>y+eps)return 1;
	return 0;
}

void fake(point p1,point p2,point p3)
{
    double a,b,c,d,e,f;
    a = p2.y - p1.y;
    b = p3.y - p1.y;
    c = p2.x - p1.x;
    d = p3.x - p1.x;
    f = p3.x*p3.x + p3.y*p3.y - p1.x*p1.x - p1.y*p1.y;
    e = p2.x*p2.x + p2.y*p2.y - p1.x*p1.x - p1.y*p1.y;
    o.x = (a*f - b*e) / (2*a*d - 2*b*c);
    o.y = (d*e - c*f) / (2*a*d - 2*b*c);
    R = dist(o,p1);
}
void add(double x,double y,double r)
{
	if(r==0)
	{
		++cnt;
		num[cnt].x=x;
		num[cnt].y=y;
		return ; 
	}
	double l=max(360*acos(1-0.003/r)/pi,1.0);
	//根据出题人的思路搞了一个这个操作 
	//大意是每隔一定角度取一个点
	//取的所有点的集合可近似代表一个圆 
	for(reg int i=0;i<360;i+=l) 
	{
		double theta=i*pi/180;//取得的一定角度
		++cnt;
		num[cnt].x=x+r*cos(theta);
		num[cnt].y=y+r*sin(theta);
		//转换(如果这个不会可以自己画个图试试
		//如果还不会,请出门右转寻找高中人教版数学《必修四》 
	}
	
}
signed main()
{
	read(t);
	for(reg int i=1;i<=t;++i)
	{
		scanf("%lf%lf%lf",&x,&y,&r);
		add(x,y,r);
		cir[i].x=x,cir[i].y=y,cir[i].r=r;
	}
	random_shuffle(num+1,num+cnt+1);
	o=num[1];R=0;
	for(reg int i=2;i<=cnt;++i)
	{
		if(check(dist(num[i],o) , R))
		{
			o=num[i],R=0;
			for(reg int j=1;j<=i-1;++j)
			{
				if(check(dist(o,num[j]) , R))
				{
					o.x=(num[i].x+num[j].x)/2;
                    o.y=(num[i].y+num[j].y)/2;
                    R=dist(o,num[j]);
                    for(reg int k=1;k<=j-1;++k)
                    {
                    	if(check(dist(o,num[k]) , R))
                    	{
                    		fake(num[i],num[j],num[k]);
						}
					}
				}
			}
		}
	}
	printf("%.2lf %.2lf %.2lf\n",o.x,o.y,R);
}
```



---

## 作者：Jμdge (赞：3)

致敬一发 江 $QVQ$，每次用随机都得用那个种子 $QWQ$ （本题可以拿来退火练手，一般来讲不打炸的话 70 pts 起步的）

总的思路就是退火嘛（别的我也不会），就是第五个点的 R=0 要特别给点宽松限制

#### 注意本地测和洛谷 Linux 测不一样的，本地查看结果的话把 lim*=1000 去掉


顺便 %%% Sooke 大仙，一遍过

```
//by Judge
#include<bits/stdc++.h>
#define R register
#define ll long long
#define db double
const int M=5e4+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
template<class T>inline void cmax(T& a,T b){if(a<b)a=b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline db dread(){ db x=0,y=0.1,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	for(c=='.'&&(c=getchar());isdigit(c);c=getchar())
		x=x+(c-48)*y,y*=0.1; return x*f;
} int n,lim; db x[M],y[M],z[M],ansx,ansy,BR;
inline int random(int l,int r){
	return l+rand()%(r-l+1);
}
inline db dis(db x,db y,db a,db b){
	return sqrt((x-a)*(x-a)+(y-b)*(y-b));
}
inline db get(db q,db p){ db ans=0;
	for(R int i=1;i<=n;++i)
		cmax(ans,dis(x[i],y[i],q,p)+z[i]);
	return ans;
} db rat,ans=1e9,mx=-1;
int xx=0;
inline void SA(db st,db ed,db delta){  //不是后缀数组【雾
	R db fx=ansx,fy=ansy,res=ans;
	for(R db tx,ty,tans,DE;st>=ed;st*=delta){ ++xx;
		if(clock()-BR>=lim) //套路【滑稽
			printf("%.2lf %.2lf ",ansx,ansy),
			printf("%.2lf\n",ans),exit(0);
		tx=fx+random(-st*10000,st*10000)/10000.0,
		ty=fy+random(-st*10000,st*10000)/10000.0;
		tans=get(tx,ty),DE=res-tans;
		if(res>tans||exp(DE*rat/st)*RAND_MAX>rand()){
			fx=tx,fy=ty,res=tans; if(res<ans) ans=res,ansx=tx,ansy=ty;
		}
	}
}
int main(){ srand(19260817),n=read(); //坦克预警
	for(R int i=1;i<=n;++i)
		x[i]=dread(),y[i]=dread(),z[i]=dread();
	mx=*std::max_element(z+1,z+1+n); //跟着sooke大仙又学会了一个函数？
	ansy/=n,lim=(n<=1000||!mx)?817:1926; //坦克预警 X2
	BR=clock(),rat=mx?((int)z[1]&1?100:50):1000;
	for(lim*=1000;1;SA(1e4,1e-4,mx?0.9:0.92));
}
```

---

## 作者：SSerxhs (赞：2)

思考一下可以发现，包含所有圆心的圆O1和包含所有圆Oi的圆O2是很接近的，所以可以直接对圆心Oi跑一次最小圆覆盖，以当前圆的圆心与每个圆心Oi的连线所在直线与圆Oi的交点为下一次的待覆盖点(显然这个点必定是要被覆盖的，并且这个点相对于原来的圆心最远)，反复迭代几次即可。

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <stdlib.h>
#include <math.h>
using namespace std;
const int N=1e6+2;
const long double eps=1e-6;
struct zb
{
    long double x,y,r;
};
zb a[N],b[N],o;
long double r,ls;
double dr;
int n,i,j,k;
inline long double dis(zb a,zb b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
inline bool ucov(zb x)
{
    return (dis(x,o)-r>eps);
}
inline long double ab(long double x)
{
    return x>eps ? x:-x;
}
void sol(zb a,zb b,zb c)
{
    long double k,kk,b1,b2;
    zb d,e;
    d.x=(a.x+b.x)/2;
    d.y=(a.y+b.y)/2;
    e.x=(a.x+c.x)/2;
    e.y=(a.y+c.y)/2;
    if (ab(b.y-a.y)>eps) k=(a.x-b.x)/(b.y-a.y); else k=1e200;
    if (ab(c.y-a.y)>eps) kk=(a.x-c.x)/(c.y-a.y); else kk=1e200;
    if (ab(k-kk)<eps)
    {
        if (a.x>b.x) swap(a,b);
        if (b.x>c.x) swap(b,c);
        if (a.x>b.x) swap(a,c);
        o.x=(a.x+c.x)/2;
        o.y=(a.y+c.y)/2;return;
    }
    b1=d.y-k*d.x;
    b2=e.y-kk*e.x;
    o.y=(b1*kk-b2*k)/(kk-k);
    o.x=(o.y-b1)/k;
}
void solve()
{
    r=0;
    o=a[1];
    for (i=2;i<=n;i++) if (ucov(a[i]))
    {
        o=a[i];
        for (j=1;j<i;j++) if (ucov(a[j]))
        {
            o.x=(a[i].x+a[j].x)/2;
            o.y=(a[i].y+a[j].y)/2;
            r=dis(o,a[i]);
            for (k=1;k<j;k++) if (ucov(a[k]))
            {
                sol(a[i],a[j],a[k]);
                r=max(dis(o,a[k]),max(dis(o,a[i]),dis(o,a[j])));
            }
        }
    }
}
int main()
{
    srand(383778817);
    scanf("%d",&n);
    for (i=1;i<=n;i++)
    {
        scanf("%lf",&dr);b[i].x=dr+eps;
        scanf("%lf",&dr);b[i].y=dr+eps;
        scanf("%lf",&dr);b[i].r=dr-eps;
    }
    for (i=1;i<=n;i++) swap(b[i],b[rand()%n+1]);
    for (i=1;i<=n;i++) a[i]=b[i];
    int t=100;
    solve();
    while (t--)
    {
        for (i=1;i<=n;i++)
        {
            if ((ab(b[i].x-o.x)<eps)&&(ab(b[i].y-o.y)<eps))
            {
                a[i].x=b[i].x+b[i].y;a[i].y=b[i].y;continue;
            }
            ls=b[i].r/sqrt((b[i].x-o.x)*(b[i].x-o.x)+(b[i].y-o.y)*(b[i].y-o.y));
            a[i].x=b[i].x+ls*(b[i].x-o.x);
            a[i].y=b[i].y+ls*(b[i].y-o.y);
        }
        solve();
        if ((o.x<=0)||(o.x>=0)) continue;
        for (i=1;i<=n;i++) swap(b[i],b[rand()%n+1]);
        for (i=1;i<=n;i++) a[i]=b[i];solve();t=300;
    }
        if (!((o.x<=0)||(o.x>=0))) exit(0);
    printf("%.10f %.10f %.10f",double(o.x),double(o.y),double(r));
}
```


---

## 作者：lyzqs (赞：2)

同步发布于博客

想要获得更好的阅读体验请点[这里](https://blog.lyzqs.top/archives/242/)

### 题解

嘛。。。

发一下自己的写法

虽然比赛时各种爆炸，被卡精度卡时间卡到40pts

第一眼看上去题目

woc这不是三分套三分傻逼题吗~~(虽然比赛后好像就我一个写的三分套三分~~

然后写一发交了上去

![[qwq](https://www.luogu.org/recordnew/show/17080152)](https://ws2.sinaimg.cn/large/007yWI1dly1g0y3mu12lpj30mp0fpdgk.jpg)

这个eps写的1e-3

然后各种调参

把eps改成1e-6

就可以调到30分了

30pts代码↓（比赛时

```cpp
#include <bits/stdc++.h>
#define il inline
#define Max 100005
#define db long double
#define inf 1e16
using namespace std;
int n;
db eps=1e-6;
struct node
{
    db x,y,r;
}p[Max],S[Max];
db ansx,ansy,ansr,maxx,maxy,minx,miny;
il db dis(int i,db xx,db yy)
{
    return sqrt((p[i].x-xx)*(p[i].x-xx)+(p[i].y-yy)*(p[i].y-yy));
}
il db calc2(db xx,db yy)
{
    db res=0;
    for(int i=1;i<=n;i++) res=max(res,dis(i,xx,yy)+p[i].r);
    ansr=res;
    return res;
}
il db calc(db xx)
{
    db l=miny,r=maxy;
    while(r-l>=eps)
    {
        db k=(r-l)/3.0;
        db mid1=l+k,mid2=r-k;
        if(calc2(xx,mid1)<calc2(xx,mid2)) r=mid2;
        else l=mid1;
    }
    ansy=l;
    return calc2(xx,ansy);
}
il bool cmp(node a,node b)
{
    db A=atan2((a.y-p[1].y),(a.x-p[1].x));
    db B=atan2((b.y-p[1].y),(b.x-p[1].x));
    if(A!=B) return A<B;
    else return a.x<b.x;
}
il db cross(node a,node b,node c)
{
    return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);
}
void Get()
{
    p[0]=(node){inf,inf};
    int k=1,top;
    for(int i=1;i<=n;++i)
        if(p[0].y>p[i].y||(p[0].y==p[i].y&&p[i].x<p[0].x))
            p[0]=p[i],k=i;
    swap(p[k],p[1]);
    sort(&p[2],&p[n+1],cmp);
    S[0]=p[1],S[1]=p[2];top=1;
    for(int i=3;i<=n;)
    {
        if(top&&cross(S[top-1],p[i],S[top])>=0)
            top--;
        else S[++top]=p[i++];
    }
    for(int i=0;i<=top;i++)
        p[i]=S[i];
    n=top;
}
int main()
{
    scanf("%d",&n);
    if(n<100) eps=1e-7;
    minx=miny=10100;
    maxx=maxy=-10100;
    for(int i=1;i<=n;i++)
        scanf("%Lf%Lf%Lf",&p[i].x,&p[i].y,&p[i].r),maxx=max(p[i].x+p[i].r,maxx),minx=min(minx,p[i].x-p[i].r),maxy=max(maxy,p[i].y+p[i].r),miny=min(miny,p[i].y-p[i].r);
    //Get();
    db l=minx,r=maxx;
    while(r-l>=eps)
    {
        db k=(r-l)/3.0;
        db mid1=l+k,mid2=r-k;
        if(calc(mid1)<calc(mid2)) r=mid2;
        else l=mid1;
    }
    calc(l);
    ansx=l;
    printf("%.3Lf %.3Lf %.3Lf\n",ansx,ansy,ansr);
}
```

被毒瘤#1卡精度怎么改都过不去

[评测记录](https://www.luogu.org/recordnew/show/17083878)

![qwq2](https://ws2.sinaimg.cn/large/007yWI1dly1g0y3qrn11sj30lt0f50tc.jpg)

我们考虑第5个点，r=0。

发现只要求一个凸包就可以了。

里面的点就不用管了。

然后比赛时候开心的写了一发凸包。

拿了40pts。

40分代码↓

```cpp
#include <bits/stdc++.h>
#define il inline
#define Max 100005
#define db long double
#define inf 1e16
using namespace std;
int n,st;
db eps=1e-6;
struct node
{
    db x,y,r;
}p[Max],S[Max];
bool flag=1;
db ansx,ansy,ansr,maxx,maxy,minx,miny;
il db dis(int i,db xx,db yy)
{
    return sqrt((p[i].x-xx)*(p[i].x-xx)+(p[i].y-yy)*(p[i].y-yy));
}
il db calc2(db xx,db yy)
{
    db res=0;
    for(int i=1;i<=n;i++) res=max(res,dis(i,xx,yy)+p[i].r);
    ansr=res;
    return res;
}
il db calc(db xx)
{
    db l=miny,r=maxy;
    while(r-l>=eps)
    {
        db k=(r-l)/3.0;
        db mid1=l+k,mid2=r-k;
        if(calc2(xx,mid1)<calc2(xx,mid2)) r=mid2;
        else l=mid1;
    }
    ansy=(l+r)/2.0;
    return calc2(xx,ansy);
}
il bool cmp(node a,node b)
{
    db A=atan2((a.y-p[1].y),(a.x-p[1].x));
    db B=atan2((b.y-p[1].y),(b.x-p[1].x));
    if(A!=B) return A<B;
    else return a.x<b.x;
}
il db cross(node a,node b,node c)
{
    return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);
}
void Get()
{
    p[0]=(node){inf,inf};
    int k=1,top;
    for(int i=1;i<=n;++i)
        if(p[0].y>p[i].y||(p[0].y==p[i].y&&p[i].x<p[0].x))
            p[0]=p[i],k=i;
    swap(p[k],p[1]);
    sort(&p[2],&p[n+1],cmp);
    S[0]=p[1],S[1]=p[2];top=1;
    for(int i=3;i<=n;)
    {
        if(top&&cross(S[top-1],p[i],S[top])>=0)
            top--;
        else S[++top]=p[i++];
    }
    for(int i=0;i<=top;i++)
        p[i]=S[i];
    n=top;
}
int main()
{
    scanf("%d",&n);
    st=clock();
    minx=miny=10100;
    maxx=maxy=-10100;
    if(n<=100) eps=1e-7;
    if(n>1000) eps=1e-5;
    for(int i=1;i<=n;i++)
        scanf("%Lf%Lf%Lf",&p[i].x,&p[i].y,&p[i].r),maxx=max(p[i].x+p[i].r,maxx),minx=min(minx,p[i].x-p[i].r),maxy=max(maxy,p[i].y+p[i].r),miny=min(miny,p[i].y-p[i].r),flag=(p[i].r==0);
    if(flag) Get();
    db l=minx,r=maxx;
    while(r-l>=eps)
    {
        if(clock()-st>3630000) break;
        db k=(r-l)/3.0;
        db mid1=l+k,mid2=r-k;
        if(calc(mid1)<calc(mid2)) r=mid2;
        else l=mid1;
    }
    calc((l+r)/2.0);
    ansx=(l+r)/2.0;
    if(fabs(ansx)<1e-2) ansx=fabs(ansx);
    if(fabs(ansy)<1e-2) ansy=fabs(ansy);
    if(fabs(ansr)<1e-2) ansr=fabs(ansr);
    printf("%.3Lf %.3Lf %.3Lf\n",ansx,ansy,ansr);
}
```

这份代码考试时被毒瘤的出题人卡精度卡空间。

考试后数据精度改了就可以过了。

顺便附上赛时的评测记录和赛后的评测记录

[赛时](https://www.luogu.org/recordnew/show/17084278)
[赛后](https://www.luogu.org/recordnew/show/17107019)

### 闲聊

其实考试时想到了可以求一个圆的凸包。

这样说不定就可以过了。

但是圆的凸包太麻烦了，于是就没有写。

有兴趣的可以写写，去网上查查就好了。

还有这题也可以用模拟退火的说。

但是由于我太菜，模拟退火的题写的少，所以没写。

还有正解的思路好强啊，根本没想到可以那样做。

~~圆的最小覆盖的模板我怎么听都没听过~~

~~还有初中基础数学是什么鬼，我怎么都不会证明~~

总体来说这题拿来练三分也挺好的(雾

对了这题#5不求凸包的话会T掉（如果你能卡过去也行

最后建议各位学习下正解，至少那个效率可以吊打这个代码

---


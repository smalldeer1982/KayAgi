# [HNOI2019] 多边形

## 题目描述

小 R 与小 W 在玩游戏。

他们有一个边数为$n$的凸多边形，其顶点沿逆时针方向标号依次为$1,2,3,\cdots , n$。最开始凸多边形中有$n$条线段，即多边形的$n$条边。这里我们用一个有序数对$(a, b)$（其中$a < b$）来表示一条端点分别为顶点$a,b$的线段。

在游戏开始之前，小 W 会进行一些操作。每次操作时，他会选中多边形的两个互异顶点，给它们之间连一条线段，并且所连的线段不会与已存的线段重合、相交（只拥有一个公共端点不算作相交）。

他会不断重复这个过程，直到无法继续连线，这样得到了状态$s_0$。$s_0$包含的线段为凸多边形的边与小W 连上的线段，容易发现这些线段将多边形划分为一个个三角形区域。对于其中任意一个三角形，其三个顶点为$i,j,k(i < j < k)$，我们可以给这个三角形一个标号$j$，这样一来每个三角形都被标上了$2,3, \cdots , n - 1$中的一个，且没有标号相同的两个三角形。

小 W 定义了一种“旋转”操作：对于当前状态，选定$4$个顶点$a,b,c,d$，使其满足$1 \leq a < b < c <d \leq n$且它们两两之间共有$5$条线段——$(a,b), (b,c), (c,d), (a,d), (a,c)$，然后删去线段$(a,c)$，并连上线段$(b,d)$。那么用有序数对$(a,c)$即可唯一表示该次“旋转”。我们称这次旋转为$(a,c)$ “旋转”。显然每次进行完“旋转”操作后多边形中依然不存在相交的线段。

当小 W 将一个状态作为游戏初始状态展示给小 R 后，游戏开始。游戏过程中，小 R 每次可以对当前的状态进行“旋转”。在进行有限次“旋转”之后，小 R 一定会得到一个状态，此时无法继续进行“旋转”操作，游戏结束。那么将每一次“旋转”所对应的有序数对按操作顺序写下，得到的序列即为该轮游戏的操作方案。

为了加大难度，小 W 以$s_0$为基础，产生了$m$个新状态。其中第$i$个状态$s_i$为对$s_0$进行一次“旋转”操作后得到的状态。你需要帮助小 R 求出分别以$s_0,s_1\cdots s_n$作为游戏初始状态时，小 R 完成游戏所用的最少“旋转”次数，并根据小 W 的心情，有时还需求出“旋转”次数最少的不同操作方案数。由于方案数可能很大，输出时请对$1e9+7$取模。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/56004.png)

![](https://cdn.luogu.com.cn/upload/pic/56005.png)


## 样例 #1

### 输入

```
1
6
1 3
1 5
3 5
1
1 3```

### 输出

```
3 2
3 1
```

## 样例 #2

### 输入

```
1
12
1 10
1 6
1 3
3 6
3 5
6 10
6 8
8 10
10 12
4
1 10
1 3
6 8
1 6```

### 输出

```
8 210
7 210
8 70
8 105
8 140```

# 题解

## 作者：yybyyb (赞：25)


~~突然特别想骂人，本来我考场现切了的，结果WA了几个点，刚刚拿代码一看有个地方忘记取模了。~~

首先发现终止态一定是所有点都向$n$连边(看样例图解就知道了)    
那么大力猜想一下第一问的答案一定是$n-3-$和$n$号点直接相连的边数。  
手玩一下，发现这样一件事情：和$n$直接相连的所有边把多边形分割成了若干个区间，每个区间都用$[l,r]$表示。    
对于$[l,r]$这个区间，因为已经分割出来了，也就是除了$l-n,r-n$之外，没有直接和$n$相连的边，那么发现这里执行一次旋转操作必定会选择到$(l,r)$，那么只需要找到$b$点，显然$b$也是唯一确定的，那么直接在$l$的出边中找到小于$r$的最大值就行了，这个点就是$b$。    
发现这次操作执行完之后，这个区间被划分成了两个部分，只需要递归处理就行了。    
于是，除了一开始就和$n$号点直接相连的边之外，每次划分一定把区间分割成两个部分，并且分割操作唯一，因此我们可以把这个过程用一个二叉树来表示。  
考虑计算方案数，一个节点表示这个点所代表的操作必须在左右两个儿子之前进行，而分割完这次之后，左右两个儿子之间就独立了，因此等价于左侧有一个操作序列，右侧有一个操作序列，需要把他们两合并，这里贡献的方案数就是一个组合数。所以方案数就是每个节点合并两个儿子的方案数的乘积。最后再把所有被和$n$相连的边划分出来的区间再乘一下拼接的组合数就是答案。  
那么我们可以处理单次询问了。    
继续考虑提前执行一次旋转操作对于答案的影响，类似$Splay$，发现这次操作就是把一个点$rotate$一下(感性理解或者手玩一下就知道为什么了)。  
那么这里需要分类讨论，如果这个点存在父亲，直接$rotate$就行了，除掉原本的贡献再乘上新的贡献就可以了。  
否则这个点不存在父亲，即这个点是划分的第一次操作，提前旋转之后就变成了和$n$相连的边，这里会把第一问的答案减一，然后把原本的方案数除掉，再乘上直接把左右两个儿子当成被和$n$相连的边分割的方案数就行了。  
时间复杂度一个$log$。（因为我要用$map$储存每个点对应的是哪条边，以及在建树的时候需要$lower\_bound$）  
下面是考场代码（把那个鬼取模给补上了  
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<map>
using namespace std;
#define ll long long
#define MAX 200200
#define MOD 1000000007
inline int read()
{
	int x=0;char ch=getchar();bool fl=false;
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')fl=true,ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return fl?-x:x;
}
int W,n,ans,Ans=1;
int jc[MAX],inv[MAX],jv[MAX];
int C(int n,int m){if(n<0||m<0||n<m)return 0;return 1ll*jc[n]*jv[m]%MOD*jv[n-m]%MOD;}
int InvC(int n,int m){return 1ll*jv[n]*jc[m]%MOD*jc[n-m]%MOD;}
int Merge(int n,int m){return C(n+m,n);}
int InvMerge(int n,int m){return InvC(n+m,n);}
struct Edge{int u,v;}p[MAX];
int ch[MAX][2],tot,sz[MAX],fa[MAX];
int rt[MAX];
vector<int> E[MAX],bE[MAX];
map<pair<int,int>,int> M;
void Divide(int &x,int ff,int l,int r)
{
	if(r-l<=1)return;x=++tot;sz[x]=1;fa[x]=ff;
	int p=lower_bound(E[r].begin(),E[r].end(),l+1)-E[r].begin();
	p=E[r][p];M[make_pair(l,r)]=x;
	Divide(ch[x][0],x,l,p);Divide(ch[x][1],x,p,r);
	sz[x]+=sz[ch[x][0]]+sz[ch[x][1]];
	Ans=1ll*Ans*Merge(sz[ch[x][0]],sz[ch[x][1]])%MOD;
}
int main()
{
	freopen("polygon.in","r",stdin);
	freopen("polygon.out","w",stdout);
	W=read();n=read();
	jc[0]=jv[0]=inv[0]=inv[1]=1;
	for(int i=2;i<=n+n;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1;i<=n+n;++i)jc[i]=1ll*jc[i-1]*i%MOD;
	for(int i=1;i<=n+n;++i)jv[i]=1ll*jv[i-1]*inv[i]%MOD;
	for(int i=1;i<=n-3;++i)
	{
		int u=read(),v=read();
		E[u].push_back(v);
		E[v].push_back(u);
	}
	for(int i=2;i<n;++i)E[i].push_back(i-1),E[i].push_back(i+1);
	E[1].push_back(2);E[1].push_back(n);
	E[n].push_back(1);E[n].push_back(n-1);
	for(int i=1;i<=n;++i)sort(E[i].begin(),E[i].end());
	for(int i=0,l=E[n].size();i<l-1;++i)Divide(rt[i],0,E[n][i],E[n][i+1]);
	int SS=0;
	for(int i=0,l=E[n].size();i<l-1;++i)Ans=1ll*Ans*Merge(SS,sz[rt[i]])%MOD,SS+=sz[rt[i]];
	int cnt=n-1-E[n].size();
	if(!W)printf("%d\n",cnt);
	else printf("%d %d\n",cnt,Ans);
	int Q=read();
	while(Q--)
	{
		int a=read(),b=read();if(b<a)swap(a,b);
		int p=M[make_pair(a,b)];
		int pcnt=cnt-(fa[p]?0:1);
		if(!W){printf("%d\n",pcnt);continue;}
		else printf("%d ",pcnt);
		int pans=Ans;
		if(fa[p])
		{
			int f=fa[p],k=ch[f][1]==p;
			pans=1ll*pans*InvMerge(sz[ch[p][0]],sz[ch[p][1]])%MOD;
			pans=1ll*pans*InvMerge(sz[ch[f][0]],sz[ch[f][1]])%MOD;
			pans=1ll*pans*Merge(sz[ch[f][k^1]],sz[ch[p][k^1]])%MOD;
			pans=1ll*pans*Merge(sz[f]-sz[p]+sz[ch[p][k^1]],sz[ch[p][k]])%MOD;
		}
		else
		{
			pans=1ll*pans*InvMerge(sz[ch[p][0]],sz[ch[p][1]])%MOD;
			pans=1ll*pans*InvMerge(SS-sz[p],sz[p])%MOD;
			pans=1ll*pans*Merge(SS-sz[p],sz[ch[p][0]])%MOD;
			pans=1ll*pans*Merge(SS-sz[p]+sz[ch[p][0]],sz[ch[p][1]])%MOD;
		}
		printf("%d\n",pans);
	}
	return 0;
}
```

---

## 作者：λᴉʍ (赞：10)

# HNOI2019 多边形 polygon

---

因为是从cnblogs贴过来的，所以可能图会挂，请去原地址看https://www.cnblogs.com/xzz_233/p/10672208.html

https://www.luogu.org/problemnew/show/P5288

这题镪啊。。。

首先堆结论：

显然终止状态一定是所有边都连向n了

根据样例及打表猜个结论，每一步一定可以新连一条到n的边，这个结论也很好证

然后可以把多边形分成若干区间，这些区间形成一棵树。具体划分方法很简单，就是用一些现有的点和中间所有边构成的多边形缩成一个区间，这些点要满足：编号连续，和只有编号最小最大的点与n有连边。比如样例中[1,3],[3,5],[1,5]。

左右端点对应编号最小最大的点，然后这些区间可以根据包含关系连成一棵树，而且这棵树除了根都是二叉的。代码可以模拟

然后每一步会新连一条到n的边，对应到区间上，会把当前区间分开成固定的，互不干扰的两个区间。

发现这就是个裸的dp是吧，$f[l][r]$表示这个区间的方案数，现在球出了这个dp，第1问就解决了

开始做第二问。第二问做了一个变换，假设是对$l,t,k,r$四个点进行$l,k$变换（膜lk），而且k!=n，那么由上面知道第一问答案不会变，而且这棵树的局部会这样变化：

![](https://img2018.cnblogs.com/blog/1117947/201904/1117947-20190408175116843-323451578.png)

变成

![](https://img2018.cnblogs.com/blog/1117947/201904/1117947-20190408175100065-386152532.png)

分析一波，下面三个叶子都没变，所以变的只是中间乘的组合数。那么照着这个树，爆算一波，答案是原答案乘$(C^{r-t-2}_{k-t-1}C^{r-l-2}_{t-l-1})\cdot (C^{k-l-2}_{t-l-1}C^{r-l-2}_{r-k-1})^{-1}$

注意一个特殊情况，就是变换的k=n时，第一问答案-1，第二问答案是原答案乘$C^{ans1}_{k-l-1}(C^{ans1-1}_{k-l-2})^{-1}$，可以看成是1号点最后合并的时候最后合并这个点并且少合并1（ans1是原问题的第一问的答案）

```cpp
#include<bits/stdc++.h>
#define il inline
#define rg register
#define vd void
#define mod 1000000007
il int gi(){
    int x=0,f=0;char ch=getchar();
    while(!isdigit(ch))f^=ch=='-',ch=getchar();
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return f?-x:x;
}
int n,x[100010],y[100010];
int s[100010],m;
std::vector<int>G[100010];
int L[100010],R[100010],ch[100010][2],cnt;
std::vector<int>ch0;
il int build(int l,int r){
    if(r-l<2)return 0;
    ++cnt;L[cnt]=l,R[cnt]=r;
    int ret=cnt,t=*--std::lower_bound(G[l].begin(),G[l].end(),r);
    ch[ret][0]=build(l,t);
    ch[ret][1]=build(t,r);
    return ret;
}
int p[100010],ip[100010];
il int C(int n,int m){
    if(n<m)return 0;
    return 1ll*p[n]*ip[m]%mod*ip[n-m]%mod;
}
il int invC(int n,int m){
    if(n<m)return 0;
    return 1ll*ip[n]*p[m]%mod*p[n-m]%mod;
}
int f[100010];
il vd dp(int x){
    if(!ch[x][0]&&!ch[x][1]){f[x]=1;return;}
    if(!ch[x][0]||!ch[x][1]){dp(ch[x][0]|ch[x][1]);f[x]=f[ch[x][0]|ch[x][1]];return;}
    dp(ch[x][0]),dp(ch[x][1]);
    f[x]=1ll*f[ch[x][0]]*f[ch[x][1]]%mod*C(R[x]-L[x]-2,R[ch[x][0]]-L[ch[x][0]]-1)%mod;
}
int main(){
// 	freopen("polygon.in","r",stdin);
// 	freopen("polygon.out","w",stdout);
    int W=gi();
    n=gi();
    int ans1=n-3;
    for(int i=1;i<n;++i)G[i].push_back(i+1);G[1].push_back(n);
    for(int i=1;i<=n-3;++i){
        x[i]=gi(),y[i]=gi();
        if(x[i]>y[i])std::swap(x[i],y[i]);
        if(y[i]==n)--ans1,s[++m]=x[i];
        G[x[i]].push_back(y[i]);
    }
    for(int i=1;i<=n;++i)std::sort(G[i].begin(),G[i].end());
    int Q=gi();
    s[++m]=1,s[++m]=n-1;
    std::sort(s+1,s+m+1);
    for(int i=1;i<m;++i)ch0.push_back(build(s[i],s[i+1]));
    p[0]=1;ip[0]=1;
    for(int i=1;i<=n;++i)p[i]=1ll*p[i-1]*i%mod;
    ip[1]=1;for(int i=2;i<=n;++i)ip[i]=mod-1ll*ip[mod%i]*(mod/i)%mod;
    for(int i=1;i<=n;++i)ip[i]=1ll*ip[i-1]*ip[i]%mod;
    int ans=1,siz=0;
    for(auto i:ch0)if(i)dp(i),ans=1ll*ans*C(siz+R[i]-L[i]-1,siz)%mod*f[i]%mod,siz+=R[i]-L[i]-1;
    if(W)printf("%d %d\n",ans1,ans);
    else printf("%d\n",ans1);
    while(Q--){
        int l=gi(),r,k=gi(),t;if(l>k)std::swap(l,k);
        r=*std::upper_bound(G[l].begin(),G[l].end(),k);
        t=*--std::lower_bound(G[l].begin(),G[l].end(),k);
        if(r==n){
            if(W)printf("%d %d\n",ans1-1,1ll*ans*invC(ans1,k-l-1)%mod*C(ans1-1,k-l-2)%mod);
            else printf("%d\n",ans1-1);
            continue;
        }
        if(W)printf("%d %d\n",ans1-(r==n),1ll*ans*invC(k-l-2,t-l-1)%mod*invC(r-l-2,r-k-1)%mod*C(r-t-2,k-t-1)%mod*C(r-l-2,t-l-1)%mod);
        else printf("%d\n",ans1-(r==n));
    }
    return 0;
}
```

---

## 作者：yzhang (赞：2)

### [原题传送门](https://www.luogu.org/problemnew/show/P5288)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10946415.html)

#### ~~HN的题目就是毒瘤~~

#### 我们有以下猜想：

#### 1.最后所有的线都连到了n号点上

#### 2.最小步数应该为n-3-已经连到n号点的线段数量

#### 本来有些边$(a_i,n)$会将整个图分割成很多个区间。对于一个区间$[l,r]$，$l,r$之间必定存在一条边，并且一定存在点$mid$有$(mid,l),mid(mid,r)$的边，所以我们珂以用一次旋转使得$(l,r)$变成$(mid,n)$，这样这个区间有珂以分成两个子区间，珂以建出二叉树。一直如此，直到$r=l+1$为止。我们现在就要考虑如何计算方案数，父节点的旋转一定在子节点的旋转之前，但子节点间互不干扰，所以就是一个插入排序方案数的问题，明显两个子树顺序影响就是把答案乘上$\frac{(size(ls)+size(rs))!}{size(ls)!size(rs)!}$

#### 最后要记得不同区间之间也有合并的贡献

#### 我们现在要考虑修改：

#### 1.$(a,c)$旋转后正好为$(b,n)$，就相当于将一棵树根节点的两个子树作为新的树，并且删除原来的根节点，对最小步数的影响为-1，对次数的影响也很简单（此处就不赘述，不会的珂以看代码）

#### 2.$(a,c)$旋转后变成了$(b,d) (d \neq n)$，这个操作像splay的rotate，具体见图片，对最小步数没有影响，对次数的影响见代码

#### ![](https://files-cdn.cnblogs.com/files/yzhang-rp-inf/hnoi1.gif)

#### ![](https://files-cdn.cnblogs.com/files/yzhang-rp-inf/hnoi2.gif)

```cpp
#include <bits/stdc++.h>
#define N 100005
#define mod 1000000007 
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int fastpow(register int a,register int b)
{
	int res=1;
	while(b)
	{
		if(b&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return res;
}
vector<int> E[N];
inline void add(register int u,register int v)
{
	E[u].push_back(v),E[v].push_back(u);
}
int W,n,m;
int fac[N],invf[N];
int fa[N],ls[N],rs[N],sz[N];
int tot=0,sum=0,ans=1;
map<pair<int,int>,int> M;
inline int calc(register int n,register int m)
{
	return 1ll*fac[n+m]*invf[n]%mod*invf[m]%mod;
}
inline int calcinv(register int n,register int m)
{
	return 1ll*invf[n+m]*fac[n]%mod*fac[m]%mod;
}
inline void dfs(register int &x,register int l,register int r,register int f)
{
	if(l+1==r)
		return;
	x=++tot;
	M[make_pair(l,r)]=x;
	fa[x]=f;
	int mid=*(--lower_bound(E[l].begin(),E[l].end(),r));
	dfs(ls[x],l,mid,x),dfs(rs[x],mid,r,x);
	sz[x]=sz[ls[x]]+sz[rs[x]]+1;
	ans=1ll*ans*calc(sz[ls[x]],sz[rs[x]])%mod;
}
int main()
{
	fac[0]=1;
	for(register int i=1;i<N;++i)
		fac[i]=1ll*fac[i-1]*i%mod;
	invf[N-1]=fastpow(fac[N-1],mod-2);
	for(register int i=N-1;i;--i)
		invf[i-1]=1ll*invf[i]*i%mod;
	W=read(),n=read();
	for(register int i=1;i<n;++i)
		add(i,i+1);
	add(1,n);
	for(register int i=1;i<=n-3;++i)
	{
		int u=read(),v=read();
		add(u,v);
	}
	for(register int i=1;i<=n;++i)
		sort(E[i].begin(),E[i].end());
	for(register int i=0;i<E[n].size()-1;++i)
	{
		int x=0;
		dfs(x,E[n][i],E[n][i+1],0);
		ans=1ll*ans*calc(sum,sz[x])%mod;
		sum+=sz[x];
	}
	if(W)
		write(sum),putchar(' '),write(ans),puts("");
	else
		write(sum),puts("");
	m=read();
	while(m--)
	{
		int a=read(),b=read(),x=M[make_pair(a,b)];
		if(fa[x])
		{
			int f=fa[x],now=ans;
			now=1ll*now*calcinv(sz[ls[x]],sz[rs[x]])%mod;
			now=1ll*now*calcinv(sz[ls[f]],sz[rs[f]])%mod;
			now=1ll*now*calc(sz[rs[x]],sz[rs[f]])%mod;
			now=1ll*now*calc(sz[ls[x]],sz[rs[x]]+sz[rs[f]]+1)%mod;
			if(W)
				write(sum),putchar(' '),write(now),puts("");
			else
				write(sum),puts("");
		}
		else
		{
			int now=ans;
			now=1ll*now*calcinv(sz[ls[x]],sz[rs[x]])%mod;
			now=1ll*now*calcinv(sum-sz[x],sz[x])%mod;
			now=1ll*now*calc(sum-sz[x],sz[ls[x]])%mod;
			now=1ll*now*calc(sum-sz[x]+sz[ls[x]],sz[rs[x]])%mod;
			if(W)
				write(sum-1),putchar(' '),write(now),puts("");
			else
				write(sum-1),puts("");
		}
	}
	return 0;
}

```

---

## 作者：zhongyuwei (赞：1)

[my submission on loj.ac](https://loj.ac/submission/790203)

对于一个已经无法继续旋转的多边形，我们考虑它上面的一个四边形，其顶点依次为 $A,B,C,D$（$O$ 点表示多边形的 $1$ 号顶点）：

![0.jpg](https://i.loli.net/2020/04/18/rAujCUZgbMqxNYH.jpg)

从 $C$ 到 $D$ 的这一段：

- 假设以 $CD$ 为一边的另一个三角形为 $\triangle CDT_1$（显然 $T_1\in (C,D)$，$CD$ 无法再旋转）
- 不可能有以 $T_1C$ 为一边的异于 $\triangle CDT_1$ 的三角形（否则 $CT_1$ 将可以旋转）
- 可以有以 $T_1D$ 为一边的异于 $\triangle CDT_1$ 的三角形，设为 $\triangle DT_1T_2$
- 不可能有以 $T_2T_1$ 为一边的异于 $\triangle DT_1T_2$ 的三角形，但是可以有以 $DT_1$ 为一边的异于 $\triangle DT_1T_2$ 的三角形，设为 $\triangle DT_2T_3$
- ……

从 $B$ 到 $D$ 这一段：不可能有以 $BC$ 为边且不同于 $\triangle BCD$ 的三角形，否则 $BC$ 将可以旋转。从 $A$ 到 $B$ 的这一段同理。

从 $D$ 到 $A$ 的这一段：

- 如果有以 $AD$ 为一边的异于 $\triangle ABD$ 的三角形，设为 $\triangle ADP_1$：
  -  $P_1\in (D,n]$，那么 $AD$ 就可以旋转了
  -  如果 $P_1\in [1, A-1)$ 则是合法的
- 不可能有以 $P_1A$ 为一边异于 $\triangle AP_1D$ 的三角形，因为这样 $P_1A$ 就可以旋转了
- 可以有以 $P_1D$ 为一边的异于 $\triangle AP_1D$ 且另一顶点 $\in [1,P_1)$的三角形，设为 $\triangle DP_1P_2(P_2 \in [1,P_1))$
- 不可能有以 $P_1P_2$ 为一边的异于 $\triangle DP_1P_2$ 的三角形，但是可以有以 $DP_2$ 为一边的异于 $\triangle DP_1P_2$ 且另一顶点位于 $[1,P_2)$ 的三角形，设为 $\triangle DP_2P_3$
- ……

![1.jpg](https://i.loli.net/2020/04/18/91LQVh7Tgq8PREG.jpg)

综上所述，一个多边形如果无法继续旋转，那么除了 $n$ 号点以外的每个点必须直接和 $n$ 号点相连。

对于一个状态，发现它不直接连接 $n$ 和其它点的边会形成一个树形结构（实际上是个二叉树森林）：

![2.jpg](https://i.loli.net/2020/04/18/JPl9guIyODTzkfV.jpg)

![3.jpg](https://i.loli.net/2020/04/18/1DrkNOBKEcub2Pp.jpg)

最小的操作次数就是树上的点数（即多边形中不直接连接 $n$ 和其它点的边数）；操作的方案数也就是将树中的点排列使得祖先总是在自己之前出现的方案数。一个经典结论是这样的排列方案数为点数的阶乘除以每个点的子树大小。

考虑在初始状态上进行一次旋转会造成什么样的影响：

![4.jpg](https://i.loli.net/2020/04/18/3IOwP9UaCG6qntv.jpg)

发现只有被旋转的那条边的子树大小改变了。预处理出初始状态的操作方案数，就能快速地得到旋转之后的答案。注意特判被旋转的边为根的情况。

---

## 作者：a1035719430 (赞：1)

两天下来喜闻乐见的签到题

只要三道题看下来应该能看出来这个T3是最可写的吧

终止状态显然是所有边为 $(i,n)$

第一问是比较显然的，我们显然每次只能将一条边变成 $(i,n)$ 并且我们每次都能做到

将每条直线用二元组$(l,r)$来表示，若直线 $a$ 被 $b$ 全包含，且 $b_r$ 不为 $n$

显然需要先操作 $b$ 才能操作 $a$

于是所有的直线就构成一个树形结构
假设有 $n$ 个点，$sz_i$ 表示子树 $i$ 的大小

$ans=\prod_{i=1}^nC_{sz_{ls}+sz_{rs}}^{sz_{ls}}$

画一下容易发现修改就是一个类似 $rorate$ 的过程

画一下 $rorate$ 左子树的情况：

![](https://img-blog.csdnimg.cn/20190409153628437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExMDM1NzE5NDMw,size_16,color_FFFFFF,t_70)

变成：
![](https://img-blog.csdnimg.cn/20190409154002151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExMDM1NzE5NDMw,size_16,color_FFFFFF,t_70)

只要更新一下$A,B$的答案就行了

如果你写的时候把 $(i,n)$ 也加到树里面的话，得注意 $rorate$ 的时候 $(i,n)\rightarrow(i,j)$ 和 $(i,j)\rightarrow(i,n)$ 的情况
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace io {
	const int SIZE = (1 << 21) + 1;
	char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;
	// getchar
	#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	// print the remaining part
	inline void flush () {
		fwrite (obuf, 1, oS - obuf, stdout);
		oS = obuf;
	}
	// putchar
	inline void putc (char x) {
		*oS ++ = x;
		if (oS == oT) flush ();
	}
	// input a signed integer
	template <class I>
	inline void gi (I &x) {
		for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;
		for (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;
	}
	// print a signed integer
	template <class I>
	inline void print (I &x) {
		if (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10;
		while (qr) putc (qu[qr --]);
	}
	//no need to call flush at the end manually!
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
}
using io :: gi;
using io :: putc;
using io :: print;
#define rep(i,j,k) for(int i = j;i <= k;++i)
#define repp(i,j,k) for(int i = j;i >= k;--i)
#define ll long long
#define fr first
#define se second
#define ls ch[rt][0]
#define rs ch[rt][1]
#define mp make_pair
#define pb push_back
#define SZ(x) ((int)(x.size()))
#define hash Hash
const int p = 1e9+7;
int fk,n,tot,fa[101000];
int fac[101000],inv[101000],sz[101000];
int ans,cnt;
int ch[101000][2],up[101000],down[101000];
pair<int,int>a[101000];
set<int>L[101000],R[101000];
set<int>::iterator it;
map< pair<int,int> ,int>hash;
inline int mul(int a,int b){return 1ll*a*b%p;}
inline int ksm(int a,int x){int now = 1;for(;x;x>>=1,a=1ll*a*a%p) if(x&1) now = 1ll*now*a%p;return now;}
inline int C(int x,int y) {return (y<0||y>x) ? 0 : (mul( fac[x] , mul( inv[y] , inv[x-y] ) ));}
int division(int l,int r) {
	int rt = ++tot,x,y,sl=0,sr=0; hash[mp(l,r)] = tot;
	cnt += r != n; a[rt] = mp(l,r); up[rt] = down[rt] = 1;
	it = L[l].end();
	if(it != L[l].begin()) {
		it--; x = l; y = *it;
		L[x].erase(L[x].lower_bound(y));
		R[y].erase(R[y].lower_bound(x));
		ls = division(x,y);
		sl = sz[ls]; fa[ls] = rt;
	}
	it = R[r].begin();
	if(it != R[r].end()) {
		y = r; x = *it;
		L[x].erase(L[x].lower_bound(y));
		R[y].erase(R[y].lower_bound(x));
		rs = division(x,y);
		sr = sz[rs]; fa[rs] = rt;
	}
	sz[rt] = sl+sr+(r!=n);
	int res = C(sl+sr,sl),inv = ksm(res,p-2);
	ans = mul( ans , res );
	up[ls] = mul( inv , C(sl+sr+1,sl+1) );   up[rs] = mul( inv , C(sl+sr+1,sr+1) );
	down[ls] = mul( inv , C(sl+sr-1,sl-1) ); down[rs] = mul( inv , C(sl+sr-1,sr-1) );
	return rt;
}
void dfs(int rt){
    up[rt] = mul(up[rt],up[fa[rt]]); down[rt] = mul(down[rt],down[fa[rt]]);
	if(ls)dfs(ls);if(rs)dfs(rs);
}
void init() {
	rep(i,1,n-3) {int x,y; gi(x); gi(y); L[x].insert(y); R[y].insert(x);}
	ans = 1; division(1,n); up[0] = down[0] = 1; dfs(1);
	if(fk == 0) printf("%d\n",cnt);
	else printf("%d %d\n",cnt,ans);
}
int main(){
	freopen("polygon.in","r",stdin);
	freopen("polygon.out","w",stdout);
	gi(fk); gi(n);
	fac[0] = inv[0] = 1;      rep(i,1,n) fac[i] = 1ll*fac[i-1]*i%p;
	inv[n] = ksm(fac[n],p-2); repp(i,n-1,1) inv[i] = 1ll*inv[i+1]*(i+1)%p;
	init();
	int m; gi(m);
	rep(i,1,m) {
		int l,r,f1,f2; gi(l); gi(r);
		int y = hash[mp(l,r)],x = fa[y],k = ch[x][1] == y,res = 0,tmp = ans;
	    res += r == n;
		f1 = r == n;
		ans = mul( ans , ksm( C( sz[ch[y][0]] + sz[ch[y][1]] , sz[ch[y][0]] ) , p-2 ) );
		ans = mul( ans , ksm( C( sz[ch[x][0]] + sz[ch[x][1]] , sz[ch[x][0]] ) , p-2 ) );
		if(k == 1) {
			if(ch[y][0]) r = a[ch[y][0]].se;
			if(ch[y][1]) r = a[ch[y][1]].fr;
			if(!ch[y][0] && !ch[y][1]) r = l+1;
			l = a[x].fr;
			ans = mul( ans , C( sz[ch[x][0]] + sz[ch[y][0]] , sz[ch[x][0]] ) );
			ans = mul( ans , C( sz[ch[x][0]] + sz[ch[y][0]] + (r != n) + sz[ch[y][1]] , sz[ch[y][1]] ) );
		}
		else {
			if(ch[y][0]) l = a[ch[y][0]].se;
			if(ch[y][1]) l = a[ch[y][1]].fr;
			if(!ch[y][0] && !ch[y][1]) l = r-1;
			r = a[x].se;
			ans = mul( ans , C( sz[ch[y][1]] + sz[ch[x][1]] , sz[ch[x][1]] ) );
			ans = mul( ans , C( sz[ch[y][1]] + sz[ch[x][1]] + (r != n) + sz[ch[y][0]] , sz[ch[y][0]] ) );
		}
		res -= r == n;
		f2 = r == n;
		if(f1 ^ f2) {
	    	if(!f1) ans = mul( ans , down[x] );
			else ans = mul( ans , up[x] );
		}
    	if(fk == 0) printf("%d\n",cnt+res);
	    else printf("%d %d\n",cnt+res,ans);
		ans = tmp;
	}
	return 0;
}
```

---

## 作者：wangyibo201026 (赞：0)

## 前言

建议把题目仔细读一遍，~~我绝对不会告诉你我看错了题意。~~

## 思路

我们考虑 $w = 0, m = 0$ 的情况下怎么解决这个题。

由于题目要求 $1 < a < b < c < d \le n$，观察样例解释即可发现最终状态一定是都连向 $n$ 的。

考虑最小操作次数一定是每次都把一条不连向 $n$ 的边连向 $n$，这一定是最优且符合条件的。所以这一问的答案即为 $n - 1 - p$，$p$ 为已连向 $n$ 的点数（算 $1$ 和 $n - 1$），$1$ 表示去除 $n$ 本身。这个东西很好搞，用个 vector 存一下就好了。

考虑 $w = 1, m = 0$ 的情况。

设与 $n$ 已经相连的点为 $a_1, a_2, ..., a_k$，我们就可以把除了 $n$ 以外的点分为若干个区间：$[1, a_1], [a_1, a_2], ... [a_k, n - 1]$，我们发现这若干个区间内除了两边外，其他任何点都没有连向 $n$，而且同时发现一个优美的性质，想让任意一个区间满足最终状态，那么操作的 $a, b, c, d$ 一定都是在区间内的（除了 $d$ 有可能是 $n$ 外）。

我们设第 $i$ 个区间的所有旋转操作序列的长度为 $siz_i$，那么 $[a_{i - 1}, a_i], [a_i, a_{i + 1}]$ 这两个区间都达到最终状态的方案数便为 $C_{siz_i + siz_{i + 1}}^{siz_i}$。这里要仔细想想。

然后我们只需要求出 $siz_i$ 就行了，考虑怎么求。我们可以把 $[a_{i - 1}, a_i]$ 不断分治下去，形成一棵二叉树。此时 $siz_i = siz_l + siz_r + 1$，但是我们要把 $[a_{i - 1}, a_i]$ 分成两个什么区间呢？或者说，$mid$ 是什么呢？应该是第一个**大于** $l$ 且与 $r$ 连边的点，可以看作是把这条边给断开，然后再与 $n$ 点连接，因为如果换做其他的边，则会产生交叉的现象（可以自己动手画图）。所以此时我们可以把 $[a_{i - 1}, a_i]$ 分成 $[a_{i - 1}, mid], [mid, a_i]$，需要注意的是，由于我们分成了二叉树，最终的方案数应该要乘上每个节点的方案数。每个节点的方案数则可以由子节点的 $siz$ 按照上述方式计算。~~我应该说清楚了吧。~~

至于求出 $mid$，用二分就 OK 了。

然后考虑 $w = 0, m > 0$ 的情况。

如果此时所在区间有父亲（不难看出边的两个端点一定是某一个区间的边界），这里可以看看提题解区的图，发现其实对于整棵树而言，类似于平衡树的旋转操作，并没有改变 $siz$ 的结果，或者说，并不对第一问的答案产生影响。

如果没有父亲，意味着这是上述的大区间，此时如果旋转，就会把本来连向 $n$ 的边改为不连向了，所以答案得 $ - 1$。就解决完了。

最后考虑 $w = 1, m > 0$ 的情况。

我们发现，每一次旋转操作是并不是对于每个节点的答案贡献都有影响的，换句话说，只对旋转位置有影响的节点产生不同贡献，所以我们可以把这些节点的贡献先给除掉，然后再乘上新的贡献就 OK 了。一样的像第三种情况分两类讨论。

最后题解提醒您：

- 多测不开 $tmp$，亲人两行泪。
- 没有判边界，亲人两行泪。
- 没有开 long long，亲人两行泪。

---


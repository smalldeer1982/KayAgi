# [十二省联考 2019] 皮配

## 题目背景

一年一度的综艺节目《中国好码农》又开始了。本季度，好码农由 Yazid、Zayid、小 R、大 R 四位梦想导师坐镇，他们都将组建自己的梦想战队，并率领队员向梦想发起冲击。  

四位导师的**派系**不尽相同，节目组为了营造看点，又将导师分成了不同的**阵营**，与此同时对不同阵营、不同派系都作出了战队总人数限制：
- 四位导师分成两个**阵营**：
  - Yazid、小 R 两位导师组成**蓝阵营**，他们两位的战队人数**总和**不得超过 $C_0$。
  - Zayid、大 R 两位导师组成**红阵营**，他们两位的战队人数**总和**不得超过 $C_1$。
- 四位导师分成两个**派系**：
  - Yazid、Zayid 两位导师属于**鸭派系**，他们两位的战队人数**总和**不得超过 $D_0$。
  - 小 R、大 R 两位导师属于 **R 派系**，他们两位的战队人数**总和**不得超过 $D_1$。

## 题目描述

本季好码农邀请到了全国各路学生精英参赛。他们来自全国 $c$ 个城市的 $n$ 所不同学校（城市的编号从 $1$ 至 $c$，学校的编号从 $1$ 至 $n$）。其中，第 $i$ 所学校所属的城市编号为 $b_i$，且共有 $s_i$ 名选手参赛。  

在【题目背景】中提到的各总人数限制之外，本季度《中国好码农》的导师选择阶
段有额外规则如下：
- 来自同**城市**的所有选手必须加入相同的**阵营**。
- 来自同**学校**的所有选手必须选择相同的**导师**。

对于导师，大部分学校的学生对导师没有**偏好**。但是有 $k$ 所学校，其中每所学校的学生有且仅有一位他们不喜欢的导师。同一所学校的学生不喜欢的导师相同，他们**不会加入他们不喜欢的导师的战队**。  

面对琳琅满目的规则和选手的偏好，作为好码农忠实观众的你想计算出，在所有选
手都进行了战队选择后，战队组成共有多少种可能的局面？
- 两种战队组成的局面被认为是不同的，当且仅当在存在一所学校，使得在这两种
局面中这所学校的选手加入了不同导师的战队。
- 由于答案可能很大，你只需输出可能局面数对 $998244353$ 取模的结果即可。

## 说明/提示

### 样例 1 解释
对于第 $1$ 组数据：
- 唯一的城市 $1$ 包含共 $3$ 名选手，但红阵营的总人数限制为 $2$，无法容纳这些选手，因此他们被迫只能选择蓝阵营。
- 在此基础上，由于 $1$ 号学校的选手不喜欢 Yazid 老师，因此他们就必须加入 R
派系的小 R 老师麾下。
- 由于 R 派系总人数限制为 $2$，因此小 R 老师战队无法容纳 $2$ 号学校的选手，所以他们只能被迫加入Yazid 老师战队。
- 综上所述，可能的局面仅有这一种。

对于第 $2$ 组数据：
- 一个显然的事实是，$1$ 号城市的所有选手都无法加入蓝阵营，这是因为 $1$ 号城市的选手总人数超过了蓝阵营的总人数限制，因此他们被迫全部加入红阵营。
- 对于 $2$ 号城市选手加入蓝阵营的情况，稍加计算可得出共有 $15$ 种可能的局面。
- 对于 $2$ 号城市选手加入红阵营的情况，稍加计算可得出共有 $7$ 种可能的局面。
- 综上所述，可能的局面数为 $15 + 7 = 22$ 种。

### 数据规模与约定
![img](https://s2.ax1x.com/2019/04/07/AfzWPe.png)

其中，$M = \max\left\{C_0, C_1, D_0, D_1\right\}$。

对于所有测试点，保证 $T \leqslant5$。

对于所有测试点中的每一组数据， 保证 $c \leqslant n \leqslant 1000$，$k \leqslant 30$，$M \leqslant 2500$，$1 \leqslant s_i \leqslant \min\left\{M, 10\right\}$。

**另外，请你注意，数据并不保证所有的 $c$ 个城市都有参赛学校。**

### 提示
另外还有两组附加样例文件，请在附件中下载。


十二省联考命题组温馨提醒您：

**数据千万条，清空第一条。**  
**多测不清空，爆零两行泪。**


## 样例 #1

### 输入

```
2
2 1
3 2 2 2
1 1
1 2
1
1 0
4 2
10 30 20 30
1 6
2 4
1 7
2 4
2
2 3
3 1```

### 输出

```
1
22```

# 题解

## 作者：Mirach (赞：112)

安利[博客](https://www.cnblogs.com/penth/p/10828200.html)：博主一般不会在这个博客里灌水，题目都还是挺有质量的qwq

Problem
--------

题意概要：有 $c$ 个豆荚，共 $n$ 颗豆子，每颗豆子都有自己的重量，现在需要将给豆子设定为 (黄色/绿色,圆粒/皱粒)，要求满足以下条件：

- 给定这四种性状的阀值 $C_0,C_1,D_0,D_1$，要求为这种性状的豆子重量和不能超过该阀值
- 与此同时，这 $n$ 颗豆子中存在 $k$ 颗顽皮豆，顽皮豆都有自己的想法，比如拒绝成为 (黄圆/黄皱/绿圆/绿皱)
- 同一个豆荚里的豆子必须 **同时为黄色** 或 **同时为绿色**

求有多少种给豆子设定的方案，对 $998244353$ 取模

$n,c\leq 10^3,k\leq 30$

设 $M=\max\{C_0,C_1,D_0,D_1\}$，$M\leq 2500$

豆子重量不超过 $\min\{M,10\}$

Solution
----

首先有一个 $O(nM^3)$ 的暴力：设定三维——“黄圆”、“黄皱”和“绿圆”的豆子重量和，枚举每一颗豆子去更新。酱紫就有 $30pts+$

其次有一个 $O(nM^2)$ 的暴力：设定两维——“黄色”和“圆粒”的重量和。酱紫有 $50pts$

--------

再者考虑 $k=0$：所有豆子都没有限制，考虑将豆子进行划分。发现无论是先划分 黄/绿 还是先划分 圆/皱 都对结果没有影响，对应的这两者可以分开计算最后相乘：

设 $f[i]$ 表示黄色重量和为 $i$ 的方案数，$g[i]$ 表示圆粒重量和为 $i$ 的方案数，这两个数组可以 $O(nM)$ 背包求得，然后答案就为（设所有豆子重量和为 $S$）：

$$\sum_{i=S-C_1}^{C_0}\sum_{j=S-D_1}^{D_0}f[i]g[j]$$

做到这再算上前边的就有 $70pts$

--------

现在考虑将顽皮豆加入 ~~肯德基豪华午餐~~ 考虑范畴

称这些顽皮豆为“有毒”的豆子，对应的豆荚一定为“有毒”的豆荚

（在阅读下面内容时，请时刻牢记：对于 黄/绿 的划分是以“豆荚”为单位的；对于 圆/皱 的划分是以“豆子”为单位的）

- 对于“无毒”的豆荚，仍然可以正常考虑其 黄/绿 的相对性状，dp 数组设为 $f$
- 对于“无毒”的豆子，仍然可以正常考虑其 圆/皱 的相对性状，dp 数组设为 $g$（因为“有毒”的豆子可能会影响整个豆荚的 黄/绿 性状，所以这里不考虑颜色性状）

那么依照前一档部分分，这两个是可以乘起来的

不难发现，求完 $f$ 后就不用再管“无毒”豆荚的 黄/绿，求完 $g$ 后就不用再管“无毒”豆子的 圆/皱，余下需要考虑的就只有“有毒”豆子的 黄/绿、圆/皱 了

由于“有毒”的豆子不多，只有 $30$ 个，可以对这一部分考虑采用 $50pts$ 那一档的暴力 Dp，dp 数组设为 $F$（注意 黄/绿 维度用的是整个豆荚的重量，圆/皱 维度用的是单个豆子的重量）

最后只要枚举“有毒”豆子的两个性状的重量 $F$，会得到一个 黄/绿 划分和一个 圆/皱 划分，考虑用 $f$ 去匹配 黄/绿（这样所有“有毒”与“无毒”豆荚的 黄/绿 就处理完了），用 $g$ 去匹配 圆/皱 划分（这样所有“有毒”与“无毒”的豆子的 圆/皱 就处理完了），乘起来即可

计算时间复杂度（空间反正是 $O(M^2)$ 的）：

- 计算 $f$ 的 dp 是 $O(cM)$ 的
- 计算 $g$ 的 dp 是 $O(nM)$ 的
- 计算 $F$ 的 dp 是 $O(kM^2)$ 的，但是由于豆子的重量 $s\leq 10$，所以其实是 $O(k^2sM)$ 的
- 统计答案是 $O(ksM)$ 的

总时间复杂度为 $O((c+n)M+k^2sM)$

~~另说，这题只考察了联赛级别的知识点——背包，包括：分部背包、双线程背包、背包合并……~~

Code
------

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline void read(int&x){
	char ch=getchar();x=0;while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
}

const int p = 998244353;
inline int qm(const int x) {return x < p ? x : x - p;}
inline void pls(int&x, const int&y) {x = x+y < p ? x+y : x+y-p;}

const int N = 1010, M = 2503;
bool city_hate[N];
int city_sum[N], hate[N], b[N], s[N];
int f[M], pre_f[M], F[M][M];
int g[M], pre_g[M], G[M][M];
int n, c;

void work() {
	read(n), read(c);
	int C0, C1, D0, D1, ALL = 0;
	for(int i=1;i<=c;++i) city_hate[i] = false, city_sum[i] = 0;
	read(C0), read(C1), read(D0), read(D1);
	for(int i=1;i<=n;++i) read(b[i]), read(s[i]), city_sum[b[i]] += s[i], hate[i] = -1, ALL += s[i];
	int K, x; read(K);
	while(K--) read(x), read(hate[x]), city_hate[b[x]] = true;
	
	memset(f, 0, sizeof f), pre_f[0] = f[0] = 1;
	for(int i=1;i<=c;++i)
		if(!city_hate[i] and city_sum[i])
			for(int j = C0, ts = city_sum[i]; j >= ts; -- j)
				pls(f[j], f[j-ts]);
	for(int i=1;i<=C0;++i) pre_f[i] = qm(pre_f[i-1] + f[i]);
	
	memset(g, 0, sizeof g), pre_g[0] = g[0] = 1;
	for(int i=1;i<=n;++i)
		if(-1 == hate[i])
			for(int j = D0, ts = s[i]; j >= ts; -- j)
				pls(g[j], g[j-ts]);
	for(int i=1;i<=D0;++i) pre_g[i] = qm(pre_g[i-1] + g[i]);
	
	int Cs = 0, Ss = 0;
	memset(F, 0, sizeof F), F[0][0] = 1;
	memset(G, 0, sizeof G);
	for(int ct = 1; ct <= c; ++ ct)
		if(city_hate[ct]) {
			Cs += city_sum[ct], Cs = min(Cs, C0);
			for(int i=0;i<=Cs;++i)
			for(int j=0;j<=Ss;++j) G[i][j] = F[i][j];
			
			for(int a=1;a<=n;++a)
				if(b[a] == ct and ~hate[a]) {
					const int t = s[a];
					Ss += t, Ss = min(Ss, D0);
					if(hate[a] == 1)
						for(int i=0;i<=Cs;++i) {
							for(int j=Ss;j>=t;--j) F[i][j] = F[i][j-t];
							for(int j=t-1;~j;--j) F[i][j] = 0;
						}
					if(hate[a] >= 2)
						for(int i=0;i<=Cs;++i)
						for(int j=Ss;j>=t;--j) pls(F[i][j], F[i][j-t]);
					if(hate[a] == 3)
						for(int i=0;i<=Cs;++i) {
							for(int j=Ss;j>=t;--j) G[i][j] = G[i][j-t];
							for(int j=t-1;~j;--j) G[i][j] = 0;
						}
					if(hate[a] <= 1)
						for(int i=0;i<=Cs;++i)
						for(int j=Ss;j>=t;--j) pls(G[i][j], G[i][j-t]);
				}
			for(int j=0,t=city_sum[ct];j<=Ss;++j) {
				for(int i=Cs;i>=t;--i) F[i][j] = F[i-t][j];
				for(int i=t-1;~i;--i) F[i][j] = 0;
			}
			for(int i=0;i<=Cs;++i)
			for(int j=0;j<=Ss;++j)
				pls(F[i][j], G[i][j]);
		}
	
	int res = 0;
	for(int i=0;i<=Cs;++i)
	for(int j=0;j<=Ss;++j) {
		int l1 = max(0, ALL - C1 - i), r1 = C0 - i; if(l1 > r1) continue;
		int l2 = max(0, ALL - D1 - j), r2 = D0 - j; if(l2 > r2) continue;
		int vf = pre_f[r1]; if(l1) vf += p - pre_f[l1-1];
		int vg = pre_g[r2]; if(l2) vg += p - pre_g[l2-1];
		pls(res, (ll)vf * vg%p * F[i][j]%p);
	}
	printf("%d\n", res);
}

int main() {
	int T; read(T);
	while(T--) work();
	return 0;
}
```

---

## 作者：一扶苏一 (赞：22)

## 【DP】P5289 [十二省联考2019]皮配

### Description

~~本题充分考察了选手的阅读理解能力，对我这种只能记三行题面的选手十分不友好~~。

有四位导师，Y,Z,R,r。他们被两两一组分成了红 / 蓝**阵营**，另外两两一组分成了鸭 / R **派系**。列表如下

|        | 蓝阵营 | 红阵营 |
| :----: | :----: | :----: |
| 鸭派系 |   Y    |   Z    |
| R 派系 |   r    |   R    |

有若干选手，每个选手只能且必须选择一名导师。显而易见，选择了所属导师之后，选手的阵营和派系就都确定了。

每一阵营/派系都有人数限制。具体而言，蓝阵营最多有 $c_0$ 人；红阵营最多有 $c_1$ 人；鸭派系最多有 $d_0$ 人，R 派系最多有 $d_1$ 人。

有 $n$ 所**学校**，来自 $c$ 个**城市**，第 $i$ 个学校有 $s_i$ 名**选手**。

同一所学校的选手必须选择**同一个导师**。同一个城市的选手必须选择**同一个阵营**。同城对派系的选择没有限制。

有 $k$ 所学校的选手比较特别，第 $i$ 所学校的选手一定不会选择第 $p_i$ 个导师。

求一共有多少种情况，答案对大质数取模。

## Analysis

因为具体 dp 转移比较复杂但是非常基础，为了美观与简洁，如无必要，文字描述部分将不写明转移，可以直接参考代码。

为了方便处理同城的情况，我们先对学校按照城市进行排序。

首先前 40 分可以进行各种维度的背包 dp 记录每个导师选择的人数来完成。

注意到题目对导师选择的人数没有要求，因此我们并不需要确定每个导师实际选择了多少个选手，而是只需要记录每个阵营/派系选择了多少人就可以了。设 $f_{i, j, k, 0/1}$ 是考虑前 $i$ 个学校，有 $j$ 个人加入了蓝阵营，$k$ 个人加入了鸭派系（这样红阵营的人数可以通过当前总人数 - i 计算得到，R 派系同理），当前学校加入了 蓝/红 (0/1) 阵营的方案数，可以做到 $O(1)$ 转移。这样可以获得 50 分。

---

考虑没有特别选手的部分分：

我们确定一个学校所选择的导师，可以分成两步：第一步确定该学校所在城市所属的阵营，第二部确定该学校所属的派系。容易发现，阵营和派系确定以后，该学校的导师也就确定了。

注意到这两步的选择是无序的，也就是我们可以先给所有的城市都定下一个确定的阵营，然后再给每个学校确定该学校所属的派系。这样就可以确定每个学校的安排情况。根据乘法原理，这两步的方案数应该相乘。能够将其分成两步意味着我们可以对这两步分别 dp：设 $f_{i, j}$ 是考虑前 $i$ 个城市，蓝阵营安排了 $j$ 个选手的方案数，转移显然。同理设 $g_{i, j}$ 是考虑前 $i$ 个学校，鸭派系有 $j$ 个选手的方案数，转移显然（情况有点多，具体可以看代码）。

在对 f 进行 dp 时需要特别注意，有些城市不存在学校，在 dp 时应该跳过这些学校，否则可能出错。

这个部分分结合 50 分做法可以获得 70 分。~~然后 SD 选手就可以走人去开 B 了~~。

---

考虑正解。

从上一个部分分推广，这里的主要想法依然是通过城市来确定阵营，再通过学校确定派系。

首先对于没有限制的**城市**和没有被限制的**学校**，依然可以使用上面的做法求出方案数。考虑对被限制的城市和学校，由于 $k$ 很小，可以用类似 50 分的做法进行单独 dp，最简单的想法是，对于每一个被限制的城市，把所有被限制的学校提出来，单独进行 dp。即设 $G_{j}$ 是考虑该城市的前 $i$ 个学校，有 $j$ 个人加入鸭派系的方案数（滚动掉第一维），然后再设 $F_{j, k}$ （滚动掉第一维）是考虑前 $i$ 个学校，有 $j$ 个蓝阵营，$k$ 个鸭派系的方案数（注意，这里 $k$ 是循环变量）。但是这样合并两个背包时，需要对于 $F$ 的每个状态，都枚举一边加入鸭派系的人数，即合并背包时为

$$F_{j, k} = \sum_{a = 0}^{c0} F_{j - t, k - a}{G_{a, 0/1}}$$

这里 $t$ 取不同数值（0 或城市 $i$ 的人数）分别表示第 $i$ 个城市加入蓝阵营还是红阵营。

这样产生了一个问题，转移的多枚举了一个 $a$，时间复杂度为 $O(m^3 k)$，无法通过。~~然后你就可以像杜神一样写个 NTT 上去~~。

注意到对 $G$ 进行 dp 的复杂度是均摊 $O(m)$ 的（如果认为要 dp $k$ 次），但是合并的复杂度高的离谱，我们考虑平衡复杂度。设 $G_{j, k, 0/1}$ 是在转移本**城市**的**所有学校**以**前**，共有 $j$ 名选手加入了蓝阵营，且考虑**本城市**的前 $i$ 个**学校**，**加上之前的城市**共有 $k$ 名选手加入鸭派系，且本城市的所有选手都加入蓝/红阵营的方案数，因为 $j$ 是本城市以前的信息，所以**转移时第一维是不变的**，只需要枚举当前学校加入哪个派系即可。

这样在合并背包时，对于每个 $F_{j, k}$ 只需要枚举本城市加入哪个阵营，也即

$$F_{j, k} = G_{j, k, 1} + G_{j - sum_i, k, 0}$$

其中 $sum_i$ 表示城市 $i$ 的选手总数。

这样，合并的复杂度被降到了单次 $O(1)$，总复杂度 $O(km^2)$，dp $G$ 的复杂度升至了均摊 $O(m^2)$，总复杂度 $O(km^2)$。可以接受。

考虑统计答案。首先枚举被限制的 dp 数组 $F_{j, k}$，然后乘上不被限制的情况 $f, g$ 的方案数即可。写出式子以后可以看出转移是一个区间和形式，对 $f$ 和 $g$ 求前缀和，就可以单次 $O(1)$ 统计答案了。

上面这些操作的复杂度都很容易算出，但是因为我太懒了没有算（

### Code

70 分

```cpp
namespace Fusu {

const int tnn = 35;
const int maxn = 1005;
const int maxm = 2505;
const int p = 998244353;

int T;
int n, c, c0, c1, d0, d1, t;
int bel[maxn], s[maxn], sc[maxn], anti[maxn], ban[maxn];
int f[maxm], g[maxm];
int tmp[maxn];
int F[2][maxn][maxn][2];

void Clear();
void Init();
void Calc1();
void Calc2();

void Main() {
  for (qr(T); T; --T) {
    Clear();
    Init();
    if (t == 0) Calc1();
    else Calc2();
  }
}

void Calc1() {
  f[0] = 1;
  for (int i = 1, sum = 0; i <= c; ++i) if (sc[i]) {
    sum += sc[i];
    for (int j = c0, lim = std::max(0, sum - c1); j >= lim; --j) {
      if (j >= sc[i]) f[j] += f[j - sc[i]];
      if (f[j] > p) f[j] -= p;
    }
  }
  g[0] = 1;
  for (int i = 1, sum = 0; i <= n; ++i) {
    sum += s[i];
    for (int j = d0, lim = std::max(0, sum - d1); j >= lim; --j) {
      if (j >= s[i]) g[j] += g[j - s[i]];
      if (g[j] > p) g[j] -= p;
    }
  }
  int s1 = 0, s2 = 0, ss = 0;
  for (int i = 1; i <= n; ++i) ss += s[i];
  for (int i = std::max(0, ss - c1); i <= c0; ++i) {
    s1 += f[i];
    if (s1 > p) s1 -= p;
  }
  for (int i = std::max(0, ss - d1); i <= d0; ++i) {
    s2 += g[i];
    if (s2 > p) s2 -= p;
  }
  qw((1ll * s2 * s1 % p), '\n');
}

void Clear() {
  memset(f, 0, sizeof f);
  memset(g, 0, sizeof g);
  memset(sc, 0, sizeof sc);
  memset(F, 0, sizeof F);
  memset(anti, -1, sizeof anti);
  memset(ban, -1, sizeof ban);
}

void Init() {
  qr(n); qr(c);
  qr(c0); qr(c1); qr(d0); qr(d1);
  for (int i = 1; i <= n; ++i) {
    qr(bel[i]); qr(s[i]);
    sc[bel[i]] += s[i];
  }
  qr(t);
  for (int i = 1, x, y; i <= t; ++i) {
    qr(x); qr(y);
    anti[x] = y;
    ban[bel[x]] = 1;
  }
}

void Calc2() {
  for (int i = 1; i <= n; ++i) {
    tmp[i] = i;
  }
  std::sort(tmp + 1, tmp + 1 + n, [](const int x, const int y) { return bel[x] < bel[y]; });
  int x = 0, y = 1, sum = 0;
  F[x][0][0][0] = 1;
  for (int i = 1, u = tmp[i]; i <= n; u = tmp[++i]) {
    sum += s[u];
    std::swap(x, y);
    for (int j = std::max(0, sum - c1); j <= c0; ++j) {
      for (int k = std::max(0, sum - d1); k <= d0; ++k) {
        for (int h = 0; h < 2; ++h) {
          int &v = F[x][j][k][h];
          v = 0;
          if (h == 0) {
            if (anti[u] != 0) {
              if ((j >= s[u]) && (k >= s[u])) {
                v += F[y][j - s[u]][k - s[u]][h];
                if (v > p) v -= p;
              }
            }
            if (anti[u] != 1) {
              if (j >= s[u]) {
                v += F[y][j - s[u]][k][h];
                if (v > p) v -= p;
              }
            }
          } else {
            if (anti[u] != 2) {
              if (k >= s[u]) {
                v += F[y][j][k - s[u]][h];
                if (v > p) v -= p;
              }
            }
            if (anti[u] != 3) {
              v += F[y][j][k][h];
              if (v > p) v -= p;
            }
          }
          if (bel[u] != bel[tmp[i - 1]]) {
            int hh = h ^ 1;
            if (h == 0) {
              if (anti[u] != 0) {
                if ((j >= s[u]) && (k >= s[u])) {
                  v += F[y][j - s[u]][k - s[u]][hh];
                  if (v > p) v -= p;
                }
              }
              if (anti[u] != 1) {
                if (j >= s[u]) {
                  v += F[y][j - s[u]][k][hh];
                  if (v > p) v -= p;
                }
              }
            } else {
              if (anti[u] != 2) {
                if (k >= s[u]) {
                  v += F[y][j][k - s[u]][hh];
                  if (v > p) v -= p;
                }
              }
              if (anti[u] != 3) {
                v += F[y][j][k][hh];
                if (v > p) v -= p;
              }
            }
          }
        }
      }
    }
  }
  int ans = 0;
  for (int i = std::max(0, sum - c1); i <= c0; ++i) {
    for (int j = std::max(0, sum - d1); j <= d0; ++j) {
      ans += F[x][i][j][0];
      if (ans > p) ans -= p;
      ans += F[x][i][j][1];
      if (ans > p) ans -= p;
    }
  }
  qw(ans, '\n');
}
```

100 分

```cpp
namespace Fusu {

const int tnn = 35;
const int maxn = 1005;
const int maxm = 2505;
const int p = 998244353;

int T;
int n, c, c0, c1, d0, d1, t;
int bel[maxn], s[maxn], sc[maxn], anti[maxn], ban[maxn];
int f[maxm], g[maxm];
int F[maxm][maxm], G[2][maxm][maxm][2];
std::vector<int> sch[maxn];

void Clear();
void Init();
void Calc1();
void Calc2();

void Main() {
  for (qr(T); T; --T) {
    Clear();
    Init();
    Calc1();
    Calc2();
  }
}

void Calc1() {
  f[0] = 1;
  for (int i = 1, sum = 0; i <= c; ++i) if ((sc[i]) && (ban[i] == -1)) {
    sum += sc[i];
    for (int j = c0, lim = std::max(0, sum - c1); j >= lim; --j) {
      if (j >= sc[i]) f[j] += f[j - sc[i]];
      if (f[j] > p) f[j] -= p;
    }
  }
  g[0] = 1;
  for (int i = 1, sum = 0; i <= n; ++i) if (anti[i] == -1) {
    sum += s[i];
    for (int j = d0, lim = std::max(0, sum - d1); j >= lim; --j) {
      if (j >= s[i]) g[j] += g[j - s[i]];
      if (g[j] > p) g[j] -= p;
    }
  }
  for (int i = 1; i <= d0; ++i) {
    g[i] += g[i - 1];
    if (g[i] > p) g[i] -= p;
  }
  for (int i = 1; i <= c0; ++i) {
    f[i] += f[i - 1];
    if (f[i] > p) f[i] -= p;
  }
}

void Clear() {
  for (int i = 1; i <= n; ++i) sch[i].clear();
  memset(f, 0, sizeof f);
  memset(g, 0, sizeof g);
  memset(sc, 0, sizeof sc);
  memset(F, 0, sizeof F);
  memset(G, 0, sizeof G);
  memset(anti, -1, sizeof anti);
  memset(ban, -1, sizeof ban);
}

void Init() {
  qr(n); qr(c);
  qr(c0); qr(c1); qr(d0); qr(d1);
  for (int i = 1; i <= n; ++i) {
    qr(bel[i]); qr(s[i]);
    sc[bel[i]] += s[i];
  }
  qr(t);
  for (int i = 1, x, y; i <= t; ++i) {
    qr(x); qr(y);
    anti[x] = y;
    ban[bel[x]] = 1;
    sch[bel[x]].push_back(x);
  }
}

inline int Sum(int *a, const int l, const int r) {
  if (l > r) return 0;
  if (l == 0) return a[r];
  return (a[r] - a[l - 1] + p) % p;
}

void Calc2() {
  int sum = 0, s1 = 0, s2 = 0;
  F[0][0] = 1;
  for (int i = 1; i <= c; ++i) if (ban[i] != -1) {

    // memcpy
    
    int x = 0, y = 1;
    for (int j = std::min(c0, s1); ~j; --j) {
      for (int k = std::min(d0, s2); ~k; --k) {
        for (int h = 0; h < 2; ++h) {
          G[x][j][k][h] = F[j][k];
        }
      }
    }

    for (auto u : sch[i]) {
      s2 += s[u];
      std::swap(x, y);
      for (int j = std::min(c0, s1); ~j; --j) {
        for (int k = std::min(d0, s2); ~k; --k) {
          for (int h = 0; h < 2; ++h) {
            int &v = G[x][j][k][h];
            v = 0;
            if (h == 0) {
              if (anti[u] != 0) {
                if (k >= s[u]) {
                  v += G[y][j][k - s[u]][h];
                  if (v > p) v -= p;
                }
              }
              if (anti[u] != 1) {
                  v += G[y][j][k][h];
                  if (v > p) v -= p;
              }
            } else {
              if (anti[u] != 2) {
                if (k >= s[u]) {
                  v += G[y][j][k - s[u]][h];
                  if (v > p) v -= p;
                }
              }
              if (anti[u] != 3) {
                v += G[y][j][k][h];
                if (v > p) v -= p;
              }
            }
          }
        }
      }
    }
    
    s1 += sc[i];
    for (int j = std::min(c0, s1); ~j; --j) {
      for (int k = std::min(d0, s2); ~k; --k) {
        F[j][k] = G[x][j][k][1];
        if (j >= sc[i]) {
          F[j][k] += G[x][j - sc[i]][k][0];
          if (F[j][k] > p) F[j][k] -= p;
        }
      }
    }
  }
  for (int i = 1; i <= n; ++i) sum += s[i];
  int ans = 0;
  for (int i = 0, lm = std::min(s1, c0); i <= lm; ++i) {
    for (int j = 0, Lm = std::min(d0, s2); j <= Lm; ++j) {
      int a = Sum(f, std::max(0, sum - c1 - i), c0 - i), b = Sum(g, std::max(0, sum - d1 - j), d0 - j);
      ans += 1ll * F[i][j] * a % p * b % p;
      if (ans > p) ans -= p;
    }
  }
  qw(ans, '\n');
}

} // namespace Fusu
```



---

## 作者：kkkstra (赞：16)

# Description

[题面](https://www.luogu.com.cn/problem/P5289)

**简化版题面：**

有 $c$ 个豆荚，共 $n$ 颗豆子，每颗豆子都有自己的重量，现在需要将给豆子设定为（黄色/绿色，圆粒/皱粒），要求满足以下条件：

1. 给定这四种性状的阀值 $C0,C1,D0,D1$，要求为这种性状的豆子重量和不能超过该阀值。

2. 与此同时，这 $n$ 颗豆子中存在 $k$ 颗顽皮豆，顽皮豆都有自己的想法，比如拒绝成为（黄圆/黄皱/绿圆/绿皱）。

3. 同一个豆荚里的豆子必须**同时为黄色**或**同时为绿色**。

求有多少种给豆子设定的方案，答案对 $998244353$ 取模。

# Solution

~~本题只考查了联赛级别的知识点背包，很普及组吧。好评！XD~~

## 算法一 暴力

纯暴力。

设 $f_{i,0/1,x,y,z}$ 为第 $i$ 个学校选择的是红/蓝阵营，前三位导师分别有 $x,y,z$ 个选手的方案数，然后枚举每个学校进行转移即可。复杂度 $O(nM^3)$，预计得分 $30pts+$。

[代码](https://loj.ac/submission/838780)

其实并不需要设三维的 $\text{dp}$，只需设状态 $f_{i,0/1,x,y}$ 表示第 $i$ 个学校选择的是红/蓝阵营，选择蓝阵营的有 $x$ 人，鸭派系的有 $y$ 人，因为一个选手必定属于其中一个阵营/派系，复杂度 $O(nM^2)$，预计得分 $50pts$。

[代码](https://loj.ac/submission/838799)

## 算法二 $k=0$

考虑 $k=0$ 的情况。

此时任何学校都没有导师的限制，可以发现先确定阵营再确定派系，与同时确定阵营与派系（即直接确定某位导师）所得到的方案数是等价的。（类似于生物里的两对相对性状？）

设 $f_{i,1/0,j}$ 为第 $i$ 个学校选择红/蓝阵营，且前 $i$ 个学校选择蓝阵营的有 $j$ 个人的方案数，$g_{i,j}$ 为前 $i$ 个学校选择鸭派系的有 $j$ 个人的方案数，那么分别计算出来后，进行合并，即总方案数为

$$
\sum \limits_{i=S-C_1}^{C_0} \sum \limits_{i=D_1}^{D_0} (f_{n,0,i} + f_{n,1,i}) \times g_{n,j}
$$

其实本质上就是**背包及背包合并**。

复杂度 $O(nM)$，结合前面的算法可以拿到 $70pts$。

[代码](https://loj.ac/submission/838837)

~~随便写写暴力就70pts了~~

## 算法三 正解

继续沿着算法二的思路进行思考，拓展到更为一般的情况。

还是设 $f$ 和 $g$ 分别表示阵营和派系的方案数，考虑如何处理学校对导师的限制。

下面对于阵营的划分，都基于城市为单位进行考虑；对于派系的划分，都基于学校为单位进行考虑（若以城市为单位进行 $\text{dp}$，一个没有限制的学校因为同城市其它学校的偏好被 $\text{dp}$ 到会感觉很不爽 $\text{2333}$）。

一个城市有限制，当且仅当城市内的学校有限制。

所以对于那些没有限制的城市和学校，我们还是可以仿照算法二，直接 $\text{dp}$ 出 $f$ 和 $g$。

而对于那些有限制的学校/城市，由于 $k$ 很小，只有 $30$，我们可以仿照 $50pts$ 的算法，暴力 $\text{dp}$ 出方案数，记为 $F$。

设 $F_{i,0/1,j,k}$ 表示前 $i$ 个有限制的学校，第 $i$ 个学校加入了红/蓝阵营，加入红阵营的有 $j$ 人，这些学校所属城市加入了鸭派系的有 $k$ 人的方案数。

最后，进行合并，只要枚举有限制的学校的派系、阵营人数，然后用 $f$ 去匹配无限制城市的阵营人数的上下界，用 $g$ 去匹配无限制的学校的派系人数的上下界，再全部乘起来就好了。

[代码](https://loj.ac/submission/839291)

# Code

`Talk is cheap. Show me the code. `

**Tips:**

1. 滚动数组每轮记得清零！
2. 不要用 `memset`，贼慢！

```cpp
#include <bits/stdc++.h>
using namespace std;

int ty() {
  int x = 0, f = 1; char ch = getchar();
  while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
  while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
  return x * f;
}

typedef long long ll;
const int _ = 2500 + 10;
const int mod = 998244353;
int N, C, K, C0, C1, D0, D1, sum;
int f[5005], g[5005], F[2][2][5005][5005];
struct school {
  int city, num, prf;
  bool operator<(const school &x) const {
    if ((prf != 0) ^ (x.prf != 0)) return (prf != 0) > (x.prf != 0);
    return city < x.city;
  }
} scl[_];
struct city { int num, hate; } ct[_];

void Inc(int &x, const int &y) { x = x + y < mod ? x + y : x + y - mod; }

void clear() {
  sum = 0;
  // memset(f, 0, sizeof(f));
  // memset(g, 0, sizeof(g));
  // memset(F, 0, sizeof(F));
  memset(ct, 0, sizeof(ct));
  memset(scl, 0, sizeof(scl));
}

void init() {
  N = ty(), C = ty();
  C0 = ty(), C1 = ty(), D0 = ty(), D1 = ty();
  for (int i = 1; i <= N; ++i) {
    scl[i].city = ty(), scl[i].num = ty();
    sum += scl[i].num;
  }
  K = ty();
  for (int i = 1; i <= K; ++i) {
    int x = ty();
    scl[x].prf = ty() + 1;
  }
  sort(scl + 1, scl + N + 1);
  for (int i = 1; i <= N; ++i) {
    ct[scl[i].city].num += scl[i].num;
    if (scl[i].prf) ct[scl[i].city].hate = true;
  }
}

ll calc1(int l, int r) {
  return l > r ? 0 : (l <= 0 ? g[r] : (g[r] - g[l - 1] + mod) % mod);
}
ll calc2(int l, int r) {
  return l > r ? 0 : (l <= 0 ? f[r] : (f[r] - f[l - 1] + mod) % mod);
}

void dp() {
  f[0] = 1;
  for (int i = 1; i <= C; ++i)
    if (!ct[i].hate && ct[i].num)
      for (int j = C0; j >= ct[i].num; --j) Inc(f[j], f[j - ct[i].num]);
  for (int i = 1; i <= C0; ++i) f[i] = (f[i] + f[i - 1]) % mod;

  g[0] = 1;
  for (int i = 1; i <= N; ++i)
    if (!scl[i].prf)
      for (int j = D0; j >= scl[i].num; --j) Inc(g[j], g[j - scl[i].num]);
  for (int i = 1; i <= D0; ++i) g[i] = (g[i] + g[i - 1]) % mod;

  F[0][0][0][0] = 1;
  int sum1 = 0, nw = 0;
  for (int i = 1; i <= K; ++i) {
    sum1 += scl[i].num;
    for (int x = 0; x <= C0; ++x) {
      for (int y = 0; y <= sum1; ++y) {
        if (scl[i].prf != 1) {
          if (scl[i].city != scl[i - 1].city) {
            if (x >= ct[scl[i].city].num && y >= scl[i].num) {
              Inc(F[nw ^ 1][0][x][y],
                  F[nw][1][x - ct[scl[i].city].num][y - scl[i].num]);
              Inc(F[nw ^ 1][0][x][y],
                  F[nw][0][x - ct[scl[i].city].num][y - scl[i].num]);
            }
          } else {
            if (y >= scl[i].num)
              Inc(F[nw ^ 1][0][x][y], F[nw][0][x][y - scl[i].num]);
          }
        }
        if (scl[i].prf != 2) {
          if (scl[i].city != scl[i - 1].city) {
            if (x >= ct[scl[i].city].num) {
              Inc(F[nw ^ 1][0][x][y], F[nw][1][x - ct[scl[i].city].num][y]);
              Inc(F[nw ^ 1][0][x][y], F[nw][0][x - ct[scl[i].city].num][y]);
            }
          } else {
            Inc(F[nw ^ 1][0][x][y], F[nw][0][x][y]);
          }
        }
        if (scl[i].prf != 3) {
          if (scl[i].city != scl[i - 1].city) {
            if (y >= scl[i].num) {
              Inc(F[nw ^ 1][1][x][y], F[nw][0][x][y - scl[i].num]);
              Inc(F[nw ^ 1][1][x][y], F[nw][1][x][y - scl[i].num]);
            }
          } else {
            if (y >= scl[i].num)
              Inc(F[nw ^ 1][1][x][y], F[nw][1][x][y - scl[i].num]);
          }
        }
        if (scl[i].prf != 4) {
          if (scl[i].city != scl[i - 1].city) {
            Inc(F[nw ^ 1][1][x][y], F[nw][0][x][y]);
            Inc(F[nw ^ 1][1][x][y], F[nw][1][x][y]);
          } else {
            Inc(F[nw ^ 1][1][x][y], F[nw][1][x][y]);
          }
        }
      }
    }
    for (int x = 0; x <= C0; ++x)
      for (int y = 0; y <= sum1; ++y) F[nw][0][x][y] = F[nw][1][x][y] = 0;
    nw ^= 1;
  }

  int ans = 0;
  for (int i = 0; i <= C0; ++i) {
    for (int j = 0; j <= sum1; ++j) {
      ll A = (F[nw][0][i][j] + F[nw][1][i][j]) % mod;
      ans = (1ll * ans + A * calc1(sum - D1 - j, D0 - j) % mod * calc2(sum - C1 - i, C0 - i) % mod) % mod;
    }
  }
  printf("%d\n", ans);
  for (int i = 0; i <= C0; ++i) {
    f[i] = 0;
    for (int j = 0; j <= sum1; ++j)
      F[0][0][i][j] = F[0][1][i][j] = F[1][0][i][j] = F[1][1][i][j] = 0;
  }
  for (int i = 0; i <= D0; ++i) g[i] = 0;
}

int main() {
#ifndef ONLINE_JUDGE
  freopen("match.in", "r", stdin);
  freopen("match.out", "w", stdout);
#endif
  int T = ty();
  while (T--) {
    clear();
    init();
    dp();
  }
  return 0;
}
```

---

## 作者：λᴉʍ (赞：11)

# 十二省联考2019 皮配



---

可以想到一个暴力就是f[i][j=0/1][k][l]表示dp了i个学校，第i个学校选择的阵营（1蓝，0红），选了蓝阵营的人数为k，选了鸭派系的人数为l。

先对所有学校按城市排序，那么就可以直接dp了。

k=0有一个想法就是没有多余的限制时，每个城市的阵营和学校的派系互不影响，可以设f[i][j]表示dp了i个城市，选了蓝阵营的人数为j；g[i][j]表示dp了i个派系，选了鸭派系的人数为l。

现在讲正解。

一个城市有限制当且仅当有一个学校属于这个城市有限制。

那么没有限制的城市可以按照k=0方法做，最后和正解方法合并，有限制的城市做一遍暴力。

但是可能有限制的城市中的学校很多，那些在有限制的城市中没有限制的学校就会被dp到很不爽。

按照k=0继续想，这些被多余计算的学校的派系和它们城市的阵营还是互不影响。

那么可以单独dp这些学校的派系，只要对于有限制的学校做暴力就行了。这个对派系的单独dp可以和上面其他没有限制的城市一起做。

具体实现，设

- f[i][j][k]是前i个有限制的城市，所有学校中选蓝色阵营有j人，有限制的学校中鸭派系有k人的方案数
- g[i][j]是前i个没有限制的城市，蓝色阵营有j人的方案数
- h[i][j]是前i个没有限制的学校，鸭派系有j人的方案数

这些可以用滚动数组滚掉第一维i，就开的下了。

求f的时候先枚举有限制的城市的阵营，再dp这个城市里有限制的学校的派系。

剩下两个就是裸的01背包。

时间看似很大，但是如果每次dp只dp到上界就快的飞起了。

注意memcpy也要只memcpy到上界否则会慢的飞起

```cpp
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define il inline
#define vd void
#define mod 998244353
typedef long long ll;
il ll gi(){
    ll x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int b[1010],s[1010];
int f[2503][2503],_f[2503][2503],__f[2503][2503],g[2503],h[2503];
// f[i][j][k] 前i个有限制的城市，所有学校中选蓝色阵营有j人，有限制的学校中鸭派系有k人，滚掉i
// g[i][j] 前i个没有限制的城市，蓝色阵营有j人
// h[i][j] 前i个没有限制的学校，鸭派系有j人
int ki[1010],kp[1010],ban[1010];//学校的限制
int city[31],m;//有限制的城市数量
std::vector<int>school[1010];//有限制的城市中有限制的学校
int sum[1010],_sum[1010];//城市的学校人数/城市有限制的学校人数
il vd add(int&a,int b){a+=b;if(a>=mod)a-=mod;}
il int get_add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}
il vd memcpy(int f[2503][2503],int g[2503][2503],int sum1,int sum2){
	for(int i=0;i<=sum1;++i)
		for(int j=0;j<=sum2;++j)
			f[i][j]=g[i][j];
}
int main(){
#ifdef XZZSB
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    int yyborz=gi();
    while(yyborz--){
        int n=gi(),c=gi();
        for(int i=1;i<=c;++i)sum[i]=_sum[i]=0;
        for(int i=1;i<=c;++i)school[i].clear();
        int C0=gi(),C1=gi(),D0=gi(),D1=gi(),Sum=0;//Sum 所有人数之和
        for(int i=1;i<=n;++i)b[i]=gi(),s[i]=gi(),Sum+=s[i];
        int k=gi();m=0;
        for(int i=1;i<=n;++i)ban[i]=-1;
        for(int i=1;i<=k;++i){
            ki[i]=gi(),kp[i]=gi();
            city[++m]=b[ki[i]],school[b[ki[i]]].push_back(ki[i]),ban[ki[i]]=kp[i];
        }
        std::sort(city+1,city+m+1);m=std::unique(city+1,city+m+1)-city-1;
        for(int i=1;i<=n;++i)sum[b[i]]+=s[i];
        for(int i=1;i<=n;++i)if(~ban[i])_sum[b[i]]+=s[i];
        memset(f,0,sizeof f);memset(g,0,sizeof g);memset(h,0,sizeof h);
        f[0][0]=1;
		int sum1=0,sum2=0;
        for(int i=1;i<=m;++i){
			sum1=std::min(C0,sum1+sum[city[i]]);
			sum2=std::min(D0,sum2+_sum[city[i]]);
            for(int o=0;o<2;++o){//城市city[i]的阵营，o=0是蓝
                memcpy(_f,f,sum1,sum2);
                for(auto x:school[city[i]]){//计算城市中有限制的学校选择的派系
                    for(int j=sum1;~j;--j)
                        for(int k=sum2;~k;--k){
                            if(!o){
                                _f[j][k]=0;
                                if(ban[x]!=o*2+1&&j>=s[x])add(_f[j][k],_f[j-s[x]][k]);
                                if(ban[x]!=o*2&&k>=s[x]&&j>=s[x])add(_f[j][k],_f[j-s[x]][k-s[x]]);
                            }else{
                                if(ban[x]==o*2+1)_f[j][k]=0;
                                if(ban[x]!=o*2&&k>=s[x])add(_f[j][k],_f[j][k-s[x]]);
                            }
                        }
                }
                if(!o){
					int others=sum[city[i]]-_sum[city[i]];
                    for(int j=sum1;~j;--j)
                        for(int k=sum2;~k;--k)
                            if(j>=others)_f[j][k]=_f[j-others][k];
                            else _f[j][k]=0;
                }
                if(!o)memcpy(__f,_f,sum1,sum2);
                else{
                    for(int j=0;j<=sum1;++j)
                        for(int k=0;k<=sum2;++k)
                            f[j][k]=get_add(_f[j][k],__f[j][k]);
                }
            }
        }
        g[0]=1;
        for(int i=1,Sum=0;i<=c;++i){
            if(!school[i].empty())continue;
            if(!sum[i])continue;
			Sum=std::min(C0,sum[i]+Sum);
            for(int j=Sum;~j;--j)if(j>=sum[i])g[j]=(g[j]+g[j-sum[i]])%mod;
        }
        h[0]=1;
        for(int i=1,Sum=0;i<=n;++i){
            if(~ban[i])continue;
			Sum=std::min(D0,s[i]+Sum);
            for(int j=Sum;~j;--j)if(j>=s[i])h[j]=(h[j]+h[j-s[i]])%mod;
        }
        for(int i=1;i<=C0;++i)g[i]=(g[i]+g[i-1])%mod;
        for(int i=1;i<=D0;++i)h[i]=(h[i]+h[i-1])%mod;
        int ans=0;
        for(int i=0;i<=C0;++i)
            for(int j=0;j<=D0;++j){
                if(Sum-i-C1-1>=C0-i)continue;
                if(Sum-j-D1-1>=D0-j)continue;
                ans=(ans+1ll*f[i][j]*(g[C0-i]-(Sum-i-C1-1>=0?g[Sum-i-C1-1]:0)+mod)%mod*(h[D0-j]-(Sum-j-D1-1>=0?h[Sum-j-D1-1]:0)+mod))%mod;
            }
        printf("%d\n",ans);
    }
    return 0;
}
```



---

## 作者：TheLostWeak (赞：10)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5289.html)

**大致题意：** 让你把$m$组共$n$个物品放入（蓝/红）（鸭/R）这$4$个背包，每组物品放入的背包阵营必须相同，且对于每种阵营和每种派系的背包各有一个容量总限制。另有$k$个限制规定某个物品不能放入某个背包，求总方案数。

### 考虑$k=0$

首先我们来考虑$k=0$的部分分。

则我们可以发现，**城市选择的阵营**与**学校选择的派系**两者是没有关系的，可以分开来计算。

如果你对这句话看得一脸懵逼，那么接下来就是对它的具体解释。

------

我们记每个学校的人数为$s_i$，统计每个城市的总人数为$t_i$。

则由于同一个城市必须选择同一个阵营，而每个阵营又各有容量限制，因此就相当于把城市**不重不漏**分入两个有容量限制的背包中。

这是典型的背包问题，我们可以用$k1_{i,j}$表示**前$i$个城市蓝阵营有$j$人的方案数**，则转移为：

$$k1_{i,j}=k1_{i-1,j}+k1_{i-1,j-t_i}$$

而考虑在城市确定阵营后，每个学校其实只能选择派系，因此同样相当于把学校不重不漏分入两个有容量限制的背包中。

与前面类似，我们用$k2_{i,j}$表示**前$i$个学校鸭派系有$j$人的方案数**，则转移为：

$$k2_{i,j}=k2_{i-1,j}+k2_{i-1,j-s_i}$$

------

计算完之后，我们把它们相乘，就可以得到答案了。

### 考虑推广

虽然上面的方法有很大的局限性，但它是十分值得借鉴的。

所以，现在我们来考虑此方法的推广。

看数据范围可以发现，$k$其实很小，只有$30$。

则我们可以考虑，将**不含限制学校**的城市和**无限制**的学校依然像上面一样背包$DP$，但是$k1$和$k2$的定义要稍作修改：

- $k1_{i,j}$表示前$i$个**不含限制学校**的城市蓝阵营有$j$人的方案数。
- $k2_{i,j}$表示前$i$个**无限制**的学校鸭派系有$j$人的方案数。

然后，对于含限制学校的城市和有限制的学校，我们单独考虑。

其实也只要设$f_{i,j,k}$表示**前$i$个含限制学校的城市，蓝阵营有$j$人，鸭派系有$k$人**的方案数，暴力$DP$即可。

### 关于内存和时间的一些优化

数组似乎开不下？

滚存一下即可。

复杂度似乎过不了？

这时我们就要用一个很普通但实用的优化：记录下当前**城市总人数与$c0$的$min$值**和**学校总人数与$d0$的$min$值**，然后以这个为$DP$转移的上界，复杂度就得到了大大优化。

具体实现详见代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 1000
#define V 2500
#define X 998244353
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
#define mem(x,v) memset(x,v,sizeof(x))
using namespace std;
int n,m,k,sum,c0,c1,d0,d1,bl[N+5],s[N+5],t[N+5],p[N+5],q[N+5];
int k1[V+5],k2[V+5],f[V+5][V+5],g[V+5][V+5];vector<int> o[N+5];
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		char c,*A,*B,FI[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
		Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
}F;
I int XSum(CI x,CI y) {return x+y>=X?x+y-X:x+y;}
I int XSub(CI x,CI y) {return x-y<0?x-y+X:x-y;}
int main()
{
	RI Ttot,i,j,k,x,y,sz,l1,l2,ans;F.read(Ttot);W(Ttot--)
	{
		for(mem(k1,0),mem(k2,0),mem(f,0),mem(g,0),mem(t,0),i=1;i<=m;++i) o[i].clear();//清空
		for(F.read(n,m,c0,c1,d0,d1),sum=0,i=1;i<=n;++i)//读入学校信息
			F.read(bl[i],s[i]),p[i]=-1,sum+=s[i],t[bl[i]]+=s[i];//统计总人数和城市人数
		for(i=1;i<=m;++i) q[i]=0;for(F.read(k),i=1;i<=k;++i)//读入限制
			F.read(x,y),p[x]=y,q[bl[x]]=1,o[bl[x]].push_back(x);//标记城市有限制学校，将该学校扔入vector
		if(c0+c1<sum||d0+d1<sum) {puts("0");continue;}//如果肯定无解，输出0并continue
		#define L1(x) (l1^c0&&(l1+=t[x])>c0&&(l1=c0))//维护城市总人数与c0的min值
		#define L2(x) (l2^d0&&(l2+=s[x])>d0&&(l2=d0))//维护学校总人数与d0的min值
		for(k1[l1=0]=i=1;i<=m;++i) if(L1(i),t[i]&&!q[i])//如果城市含限制学校或人数为0跳过（注意人数为0必须判！我一开始偷懒没判就WA了。。。）
			for(j=l1;j>=t[i];--j) Inc(k1[j],k1[j-t[i]]);//背包转移
		for(k2[l2=0]=i=1;i<=n;++i) if(L2(i),s[i]&&!~p[i])//与上面类似
			for(j=l2;j>=s[i];--j) Inc(k2[j],k2[j-s[i]]);
		for(i=1;i<=c0;++i) Inc(k1[i],k1[i-1]);for(i=1;i<=d0;++i) Inc(k2[i],k2[i-1]);//统计前缀和
		for(f[0][0]=i=1,l1=l2=0;i<=m;++i)
		{
			if(!t[i]||!q[i]) continue;for(j=0;j<=l1;++j) for(k=0;k<=l2;++k) g[j][k]=f[j][k];//将f复制一遍给g
			for(x=0,sz=o[i].size();x^sz;++x) for(y=o[i][x],L2(y),j=l1;~j;--j) for(k=l2;~k;--k)//枚举有限制的城市进行转移
				f[j][k]=XSum(p[y]^1?f[j][k]:0,k>=s[y]&&p[y]?f[j][k-s[y]]:0),//判断无法选择的情况
				g[j][k]=XSum(p[y]^3?g[j][k]:0,k>=s[y]&&p[y]^2?g[j][k-s[y]]:0);//与上面类似
			for(L1(i),j=l1;~j;--j) for(k=l2;~k;--k)//统计，也差不多是一个背包
				f[j][k]=XSum(j>=t[i]?f[j-t[i]][k]:0,g[j][k]);
		}
		#define S1(x) XSub(k1[c0-(x)],sum-c1-(x)-1>=0?k1[sum-c1-(x)-1]:0)//求出合法范围内的方案数
		#define S2(y) XSub(k2[d0-(y)],sum-d1-(y)-1>=0?k2[sum-d1-(y)-1]:0)//与上面类似
		for(ans=i=0;i<=c0;++i) for(j=0;j<=d0;++j) Inc(ans,1LL*f[i][j]*S1(i)%X*S2(j)%X)%X;//最后计算答案
		printf("%d\n",ans);//输出答案
	}return 0;
}
```

---

## 作者：Terry2022 (赞：6)

**题意**：

$n$ 个点，每个点有权值 $a_i$，并属于 $m$ 个大集合中的一个 $p_i$ 。

现将每个点分配到 $4$ 个位置中，记为 $A_0,A_1,B_0,B_1$ ，要求满足同一大集合的属于同一下标。

设 $A_0,A_1,B_0,B_1$ 上总权值分别为 $X_0,X_1,Y_0,Y_1$ ，则要求满足：
$$
\begin{cases}
X_0+Y_0\le C_0\\
X_1+Y_1\le C_1\\
X_0+X_1\le D_0\\
Y_0+Y_1\le D_1\\
\end{cases}
$$
同时还有 $k$ 个特殊限制条件：点 $i$ 不能在位置 $T$

求方案数

**思路**：

由于限制条件是针对同一下标或同一上标的，很明显可以分为上标、下标分别算

设 $S=\sum_{i=1}^{n}a_i,s_i=\sum_{j=1,p_j=i}^{n}a_j$

先考虑 $k=0$ 的情况：

考虑二元 $\mathrm{GF}$，设 $[x^n][y^m]F(x,y)$ 表示下标为 $0$ 的总权值为 $n$ ，上标为 $A$ 的总权值为 $m$ 的方案数

$\therefore F(x,y)=\prod\limits_{i=1}^{m}(1+x^{s_i})\prod\limits_{i=1}^{n}(1+y^{a_i})$

表示每一个集合可以分到下标 $0$ 或 $1$ ，对应 $x^{s_i} $ 或 $1$ ；每一个点可以分到上标 $A$ 或 $B$，对应 $y^{a_i}$ 或 $1$

答案即为：$ans=\sum_{i=S-C_1}^{C_0}\sum_{j=S-D_1}^{D_0}[x^i][y^j]F(x,y)$

再考虑 $k\ge 1$ 的情况：

可以发现没有特殊限制的城市与没有特殊限制的学校可以用同样的方法算出，修改特殊的 $k$ 个位置的生成函数：

假设一个点 $t$ ，属于集合 $p$ ，不能放在的位置为 $A_1$

则生成函数变为：
$$
\begin{aligned}
&F(x,y)=G(x)H(y)\times P(t)\\
&G(x)=\prod\limits_{i=1,p_i\neq p}^{m}(1+x^{s_i})\\
&H(y)=\prod_{i=1,i\neq t}^{n}(1+y^{a_i})\\
&P(t)=x^{s_p}(1+y^{a_t})+1\times (1)
\end{aligned}
$$
$A_0,B_0,B_1$ 的情况同理

特殊部分的复杂度为 $O(k^2\max\{a_i\}\max\{A_0,B_0\})$ ，无特殊部分为 $O(nm)$ ，注意做多项式乘法时的上下界

**代码**：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cassert>
const int Q=2505;
const int INF=(1<<30);
const int mod=998244353;
typedef long long ll;
#define rg register int
#define cint const register int
//char Buf[1<<21],*P1=Buf,*P2=Buf;
//#define gc() (P1==P2&&(P2=(P1=Buf)+fread(Buf,1,1<<21,stdin),P1==P2)?EOF:*P1++)
#define gc() getchar()
inline bool ig(char c){return c>=48&&c<=57;}
inline void read(int &oi){char c;int f=1,res=0;while(c=gc(),(!ig(c))&&c^'-');c^'-'?res=(c^48):f=-1;while(c=gc(),ig(c))res=res*10+(c^48);oi=f*res;}
inline void print(int oi){if(oi<0)putchar('-'),oi=~oi+1;if(oi>9)print(oi/10);putchar(oi%10+48);}
inline void write(int oi,char c){print(oi);putchar(c);}
inline int max(cint x,cint y){return x>y?x:y;}
inline int min(cint x,cint y){return x<y?x:y;}
inline int inc(cint x,cint y){return x+y<mod?x+y:x+y-mod;}
inline int dec(cint x,cint y){return x>=y?x-y:x-y+mod;}
inline int mul(cint x,cint y){return 1ll*x*y%mod;}
inline int pow(rg x,rg y){rg res=1;for(;y;y>>=1,x=mul(x,x))if(y&1)res=mul(res,x);return res;}
inline int Inv(cint x){return pow(x,mod-2);}
int T;
int n,m,C0,C1,D0,D1,S,q,sx,sy;
int p[Q],a[Q];
int s[Q];
int f[Q],g[Q],tmp[Q];
int ucs[Q][4],is[Q];
int st[Q],top;
int h[Q];
int sp[Q][Q],tp[Q][Q],lst[Q][Q];
inline bool chk(cint x){return ucs[x][0]||ucs[x][1]||ucs[x][2]||ucs[x][3];}
inline void clear(){
	std::memset(s,0,sizeof(s));
	std::memset(f,0,sizeof(f));
	std::memset(g,0,sizeof(g));
	std::memset(tmp,0,sizeof(tmp));
	std::memset(ucs,0,sizeof(ucs));
	std::memset(is,0,sizeof(is));
	std::memset(st,0,sizeof(st));
	std::memset(h,0,sizeof(h));
	std::memset(sp,0,sizeof(sp));
	std::memset(tp,0,sizeof(tp));
	std::memset(lst,0,sizeof(lst));
	S=sx=sy=0;
}
int main(){
	read(T);for(;T--;){
		clear();read(n);read(m);
		read(C0);read(C1);read(D0);read(D1);
		for(rg i=1;i<=n;++i)read(p[i]),read(a[i]),s[p[i]]+=a[i],S+=a[i];
		cint S0=min(S,C0),S1=min(S,D0);
		read(q);for(rg i=1,x,y;i<=q;++i)read(x),read(y),ucs[x][y]=1,is[p[x]]=1;
		g[0]=f[0]=1;
		for(rg i=1;i<=m;++i){
			if(!s[i]||is[i])continue;
			for(rg j=0;j<=S0;++j)tmp[j]=f[j];
			for(rg j=s[i];j<=S0;++j)tmp[j]=inc(tmp[j],f[j-s[i]]);
			for(rg j=0;j<=S0;++j)f[j]=tmp[j];
		}
		for(rg i=1;i<=n;++i){
			if(chk(i))continue;for(rg j=0;j<=S1;++j)tmp[j]=g[j];
			for(rg j=a[i];j<=S1;++j)tmp[j]=inc(tmp[j],g[j-a[i]]);
			for(rg j=0;j<=S1;++j)g[j]=tmp[j];
		}
		sp[0][0]=1;
		for(rg i=1;i<=m;++i){
			if(!is[i])continue;top=0;sx+=s[i];sx=min(sx,S0);
			for(rg j=1;j<=n;++j)if(p[j]==i&&chk(j))st[++top]=j,sy+=a[j];sy=min(sy,S1);
			for(rg j=0;j<=sx;++j)for(rg k=0;k<=sy;++k)lst[j][k]=sp[j][k],tp[j][k]=0;
			for(rg j=1;j<=top;++j){
				cint x=st[j];
				if(!ucs[x][0]){for(rg k=0;k<=sx;++k)for(rg l=a[x];l<=sy;++l)tp[k][l]=inc(tp[k][l],lst[k][l-a[x]]);}//A_0
				if(!ucs[x][1]){for(rg k=0;k<=sx;++k)for(rg l=0;l<=sy;++l)tp[k][l]=inc(tp[k][l],lst[k][l]);}//B_0
				for(rg k=0;k<=sx;++k)for(rg l=0;l<=sy;++l)lst[k][l]=tp[k][l],tp[k][l]=0;
			}
			for(rg j=0;j<=sx;++j)for(rg k=0;k<=sy;++k)tp[j][k]=sp[j][k],sp[j][k]=0;
			for(rg j=s[i];j<=sx;++j)for(rg k=0;k<=sy;++k)sp[j][k]=inc(sp[j][k],lst[j-s[i]][k]);
			for(rg j=0;j<=sx;++j)for(rg k=0;k<=sy;++k)lst[j][k]=tp[j][k],tp[j][k]=0;
			for(rg j=1;j<=top;++j){
				cint x=st[j];
				if(!ucs[x][2]){for(rg k=0;k<=sx;++k)for(rg l=a[x];l<=sy;++l)tp[k][l]=inc(tp[k][l],lst[k][l-a[x]]);}//A_1
				if(!ucs[x][3]){for(rg k=0;k<=sx;++k)for(rg l=0;l<=sy;++l)tp[k][l]=inc(tp[k][l],lst[k][l]);}//B_1
				for(rg k=0;k<=sx;++k)for(rg l=0;l<=sy;++l)lst[k][l]=tp[k][l],tp[k][l]=0;
			}
			for(rg j=0;j<=sx;++j)for(rg k=0;k<=sy;++k)sp[j][k]=inc(sp[j][k],lst[j][k]),lst[j][k]=0;
		}
		for(rg i=1;i<=S0;++i)f[i]=inc(f[i],f[i-1]);
		for(rg i=1;i<=S1;++i)g[i]=inc(g[i],g[i-1]);
		rg res=0;
		for(rg i=0;i<=min(sx,C0);++i){
			for(rg j=0;j<=min(sy,D0);++j){
				cint v1=dec(f[min(C0-i,S0)],S>C1+i?f[S-C1-i-1]:0);
				cint v2=dec(g[min(D0-j,S1)],S>D1+j?g[S-D1-j-1]:0);
				res=inc(res,mul(sp[i][j],mul(v1,v2)));
			}
		}
		write(res,'\n');
	}
	return 0;
}
```

---

## 作者：Miko35 (赞：5)

> 题意：$n$ 个数 $s_{1\dots n}$ 被划分成 $c$ 组 ($n,c \leq 1000,s_i \leq 10$)，要将其放入 $2\times 2$ 的方格内，有如下限制：
>
> - 同一组的数只能被放在同一行。
> - 第 $i$ 行/列的数字之和有上限 $C_i$/$D_i$。($C_i,D_i \leq 2500$)
> - 有 $k$ 个形如「第 $i$ 个数不能放在 $(x,y)$」的限制。($k \leq 30$)
>
> 问总方案数对 $998244353$ 取模的结果。

$\textrm{Sol}$：首先容易想到，第二条限制可以转化为第一行/列数字之和有独立的上限与下限，故我只需要知道其中第一行的和与第一列的和就可以判定是否符合此限制。下面用 $l_1$ 表示第一列的和，$c_1$ 表示第一行的和。

考虑 $k=0$ 的情况，对于一个数，所在的组决定在哪行，列可以随便分，故我们可以不看组的限制，来考虑每个数分在哪一列，记录 $f_i$ 表示 $l_1 = i$ 的方案数。而行的划分可以直接把每个组作为一个整体考虑，记录 $g_i$ 表示 $c_1 = i$ 的方案数。这样就得到将所有数划分成 $l_1 = x$ 且 $c_1 = y$ 的方案数 $f_x\cdot g_y$，复杂度 $O(nm)$。

$k \neq 0$ 如何处理？发现 $k$ 非常小，考虑把有限制的和无限制的分开考虑。观察可知，无限制的数分到的列依然独立，可以单独考虑，而有限制的数分到的列和它所属的组相关。把内部存在带限制的数的组叫做「限制组」，那么对于非限制数可以用上面的 $f_i$，非限制组可以用上面的 $g_i$，而剩下限制数/组的数量都是 $O(k)$ 级别。

对于这一部分可以维护一个 $h_{i,j}$ 表示：决策了限制组的行，其 $c_1 = i$，且决策了限制数的列，其 $l_1 = j$ 的方案数，两维大小分别是 $O(m)$ 与 $O\left(\sum\limits_{i \in S} s_i\right)$，物品数 $O(k)$，则这个背包复杂度是 $O(mk^2s)$。

最终合并起来，将所有数划分成 $l_1 = x$ 且 $c_1 = y$ 的方案数即为 $\sum\limits_{i=0}^x\sum\limits_{j=0}^y h_{i,j}\cdot f_{x-i} \cdot g_{y-j}$。整题的时间复杂度是 $O(T\cdot mk^2 s)$。

Code：

```cpp
#include<bits/stdc++.h>
#define cl(x,r) memset(x,r,sizeof x)
#define FOR(i,a,b) for(int i=a,i##i=b;i<=i##i;++i)
#define ROF(i,a,b) for(int i=a,i##i=b;i>=i##i;--i)
using namespace std;
const int N=2507,S=307,mod=998244353;
int T,n,c,K,x,y,C0,C1,D0,D1,b[N],s[N],p[N],al,sk;
int f[N],g[N],h[N][S],t[N][S],su[N];
long long ans;
vector<int>v[N];
int get(int*a,int x){return x<0?0:a[x];}
void work(){
	cl(p,-1),cl(f,0),cl(g,0),cl(h,0),cl(su,0),ans=0;
	scanf("%d%d%d%d%d%d",&n,&c,&C0,&C1,&D0,&D1),al=sk=0;
	FOR(i,1,n)scanf("%d%d",b+i,s+i),su[b[i]]+=s[i],al+=s[i];
	FOR(i,1,c)v[i].clear();
	C1=max(al-C1,0),D1=max(al-D1,0),f[0]=g[0]=h[0][0]=1;
	for(scanf("%d",&K);K--;)scanf("%d%d",&x,&y),p[x]=y,v[b[x]].push_back(x),sk+=s[x];
	FOR(i,1,n)if(p[i]==-1)ROF(j,D0,s[i])(f[j]+=f[j-s[i]])%=mod;
	FOR(d,1,c)if(v[d].size()){
		memcpy(t,h,sizeof h);
		for(int g:v[d])ROF(i,C0,0)ROF(j,min(sk,D0),0){
			int X=0,Y=0;
			if(p[g]!=0)(X+=get(h[i],j-s[g]))%=mod;
			if(p[g]!=1)(X+=h[i][j])%=mod;
			if(p[g]!=2)(Y+=get(t[i],j-s[g]))%=mod;
			if(p[g]!=3)(Y+=t[i][j])%=mod;
			h[i][j]=X,t[i][j]=Y;
		}
		ROF(i,C0,0)ROF(j,min(sk,D0),0)h[i][j]=((i<su[d]?0:h[i-su[d]][j])+t[i][j])%mod;
	}
	else if(su[d])ROF(i,C0,su[d])(g[i]+=g[i-su[d]])%=mod;
	FOR(i,1,D0)(f[i]+=f[i-1])%=mod;
	FOR(i,1,C0)(g[i]+=g[i-1])%=mod;
	FOR(i,0,C0)FOR(j,0,min(D0,sk))(ans+=1ll*h[i][j]*(f[D0-j]-get(f,D1-j-1))%mod*(g[C0-i]-get(g,C1-i-1)))%=mod;
}
signed main(){
	for(scanf("%d",&T);T--;)work(),printf("%lld\n",(ans+mod)%mod);
	return 0;
}
```




---

## 作者：dAniel_lele (赞：4)

题目等价于每个城市选择一个阵营，每个学校选择一个派系。

考虑分成三部分：没有要求的学校，没有要求的城市，有要求的城市和学校。

对于没有要求的学校和城市，考虑 $dp_{i,j}$ 表示看到第 $i$ 个，第一个派系/阵营目前选择了 $j$ 人的方案数。容易在 $O(nm)$ 时间内解决。

对于剩下的有限制的，考虑 $dp_{i,j,k}$ 表示看到第 $i$ 个学校，第一个派系/阵营分别选了 $j/k$ 人的方案数。我们可以把同一个城市的所有学校放到一起，dp 时加一维表示目前城市选了哪个阵营。于是就可以在 $O(k^2sm)$ 时间内解决。

计算完之后，对没有要求的学校和城市的 dp 结果做前缀和，枚举有限制的第一个派系/阵营分别选了多少人，计算出对应对没有要求的学校和城市选到第一个派系/阵营的人数的要求区间，差分一下算乘积即可。

总复杂度 $O(T(nm+k^2sm))$，可以通过。

```cpp
#include <bits/stdc++.h>
#define int long long
#define s(i,j) ((i-1)*n+j)
#define mid ((l+r)>>1)
#define add(i,j) ((i+j)>=mod?i+j-mod:i+j)
using namespace std;
const int mod=998244353;
int b[1005],s[1005],ts[1005],tag[1005];
vector<int> ztp[1005];
int spe[1005],zy[1005],px[1005];
int dp[31][2505][315][2],dp2[1005][2505],dp3[1005][2505];
void solve(){
	memset(dp,0,sizeof(dp));
	memset(dp2,0,sizeof(dp2));
	memset(dp3,0,sizeof(dp3));
	int n,c,c0,c1,d0,d1,spall=0,all=0; cin>>n>>c>>c0>>c1>>d0>>d1;
	for(int i=1;i<=c;i++) tag[i]=0,ztp[i].clear(),ts[i]=0;
	for(int i=1;i<=n;i++) cin>>b[i]>>s[i],ts[b[i]]+=s[i],spe[i]=0,all+=s[i];
	int k; cin>>k;
	for(int i=1;i<=k;i++){
		int pos,p; cin>>pos>>p;
		spe[pos]=1,zy[pos]=(p>>1)&1,px[pos]=p&1;
		tag[b[pos]]=1; ztp[b[pos]].push_back(pos);
		spall+=s[pos];
	}
	int m=0; dp[0][0][0][0]=1;
	for(int i=1;i<=c;i++){
		if(tag[i]){
			for(int j=0;j<=2500;j++){
				for(int k=0;k<=300;k++){
					dp[m][j][k][0]=dp[m][j][k][1]=add(dp[m][j][k][0],dp[m][j][k][1]);
				}
			}
			int tmp=0;
			for(auto v:ztp[i]){
				m++;
				for(int j=0;j<=2500;j++){
					for(int k=0;k<=300;k++){
						for(int l=0;l<2;l++){
							int tj=j+(tmp==0)*ts[i]*(!l);
							if(tj>2500) continue;
							if(l==0){
								if(zy[v]==0){
									if(px[v]==0){
										dp[m][tj][k][l]=add(dp[m][tj][k][l],dp[m-1][j][k][l]);
									}
									else{
										dp[m][tj][k+s[v]][l]=add(dp[m][tj][k+s[v]][l],dp[m-1][j][k][l]);
									}
								}
								else{
									dp[m][tj][k][l]=add(dp[m][tj][k][l],dp[m-1][j][k][l]);
									dp[m][tj][k+s[v]][l]=add(dp[m][tj][k+s[v]][l],dp[m-1][j][k][l]);
								}
							}
							else{
								if(zy[v]==1){
									if(px[v]==0){
										dp[m][tj][k][l]=add(dp[m][tj][k][l],dp[m-1][j][k][l]);
									}
									else{
										dp[m][tj][k+s[v]][l]=add(dp[m][tj][k+s[v]][l],dp[m-1][j][k][l]);
									}
								}
								else{
									dp[m][tj][k][l]=add(dp[m][tj][k][l],dp[m-1][j][k][l]);
									dp[m][tj][k+s[v]][l]=add(dp[m][tj][k+s[v]][l],dp[m-1][j][k][l]);
								}
							}
						}
					}
				}
				tmp=1;
			}
		}
	}
	int m1=0;
	dp2[0][0]=1;
	for(int i=1;i<=c;i++){
		if(!tag[i]&&ts[i]){
			m1++;
			for(int j=0;j<=2500;j++) dp2[m1][j]=dp2[m1-1][j];
			for(int j=0;j+ts[i]<=2500;j++) dp2[m1][j+ts[i]]=add(dp2[m1][j+ts[i]],dp2[m1-1][j]);
		}
	}
	for(int j=1;j<=2500;j++) dp2[m1][j]=add(dp2[m1][j-1],dp2[m1][j]);
	int m2=0;
	dp3[0][0]=1;
	for(int i=1;i<=n;i++){
		if(!spe[i]){
			m2++;
			for(int j=0;j<=2500;j++) dp3[m2][j]=dp3[m2-1][j];
			for(int j=0;j+s[i]<=2500;j++) dp3[m2][j+s[i]]=add(dp3[m2][j+s[i]],dp3[m2-1][j]);
		}
	}
	for(int j=1;j<=2500;j++) dp3[m2][j]=add(dp3[m2][j-1],dp3[m2][j]);
	int tot=0;
	for(int i=0;i<=2500;i++){
		for(int j=0;j<=300;j++){
			int nowi1=i,nowi2=spall-i;
			int li=max(0ll,(all-spall)-(c1-nowi2)),ri=c0-i;
			if(li>ri||ri<0) continue;
			int nowj1=j,nowj2=spall-j;
			int lj=max(0ll,(all-spall)-(d1-nowj2)),rj=d0-j;
			if(lj>rj||rj<0) continue;
			int toti=dp2[m1][ri]; if(li!=0) toti=add(toti,mod-dp2[m1][li-1]);
			int totj=dp3[m2][rj]; if(lj!=0) totj=add(totj,mod-dp3[m2][lj-1]);
			(tot+=(dp[m][i][j][0]+dp[m][i][j][1])*toti%mod*totj)%=mod;
		}
	}
	cout<<tot<<"\n";
}
signed main(){
	int t; cin>>t;
	while(t--){
		solve();
	}
	return 0; 
}
```

---

## 作者：xzzduang (赞：4)

[传送门](https://www.luogu.com.cn/problem/P5289)

阅读理解题，先梳理一下条件：

有一个 $2\times 2$ 的方阵，有 $n$ 所学校，属于 $c$ 个城市，每个学校 $s_i$ 个人，每个学校可以选一个方格把自己的人都放进去，要求同个城市的放在同一行。且方阵每行每列都有人数限制。有 $k$ 个限制条件，表示 $i$ 学校不能放进格子 $p$ 中。

#### 最朴素的暴力

可以直接想到的是一个个学校的 DP，设 $dp_{i,a,b,c,d}$ 表示处理完前 $i$ 个学校，第一行有 $a$ 个人，第二行有 $b$ 个人，第一列 $c$ 个人，第二列 $d$ 个。这样是 $\mathcal{O}(nM^4)$。

#### 有点脑子的暴力

其实我们不用第一行第二行都记，因为两行的和肯定是总人数，列也同理。所以只用记 $dp_{i,j,k}$，时间 $\mathcal{O}(nM^2)$。

#### $k=0$ 的情况

在没有 $k$ 的限制下，我们发现行和列的决策本质上是独立的，所以可以把两维分开DP。记 $g_i$ 表示第一行和为 $i$ 的方案，$f_j$ 表示第一列和为 $j$ 的方案，答案就是 $\sum_i\sum_jg_if_j$ 。时间 $\mathcal{O}(nM)$。

#### 一般情况

发现 $k\le30$，于是考虑对于没有限制的城市用 $k=0$ 的情况，有限制的直接用有脑子的暴力。另一个我们要利用的性质就是 $s_i\le10$，即有限制的城市的人数和只有 $300$。

我一开始的想法是把有限制的城市拿出来，这种城市只有 $30$ 个，但是这里面包含的学校有可能是 $\mathcal{O}(n)$ 的，众所周知，背包合并的复杂度是不可接受的（~~除了用 FFT~~），所以我们尽量单个加入，但结果是无论怎么做复杂度都不能下 $\mathcal{O}(kM^2)$。还有多组数据，想过去只能上 NTT 了。

其实我们还未把独立性用好，和有限制的学校在总一个城市的其他学校，它在列上的决策其实并没有受影响，所以在求出 $k=0$ 时那里提到的 $f$ 和 $g$ 的时候，$f$ 是可以把有限制的城市的无限制学校也算进去的，只不过 $g$ 就不应该把有限制的城市算进去。

现在我们就做到了还没处理的列和没有处理的行只有 $\mathcal{O}(k)$ 个，这时有限制的城市的人数和只有 $300$ 这个条件就可以用上了，处理这些行和列我们采用前面的暴力，$dp_{i,j,k}$ 还是之前的定义，但不过现在第一维是 $30$ 的，第二维是 $2500$，第三维是 $300$ 的。

实现时一般把第一维滚动压掉，最终时间复杂度 $\mathcal{O}(nM+s_ik^2M)$。

```cpp
#include<iostream>
#include<stdio.h>
#include<ctype.h>
#include<vector>
#include<string.h>
#define N 1005
#define M 2505
#define int long long
#define mo 998244353
using namespace std;
inline int read(){
	int x=0,f=0; char ch=getchar();
	while(!isdigit(ch)) f|=(ch==45),ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f?-x:x;
}
int n,c,C0,C1,D0,D1,bel[N],s[N],ban[N][4],flag[N],f[M],g[M],S,sum[N],tmp[M][310],dp[M][310],lim;
vector <int> mp[N];
inline void red(int &x){x>=mo?x-=mo:0;}
inline int query(int x,int xx,int y,int yy){
	x=max(x,0LL),y=max(y,0LL);
	xx=min(xx,C0),yy=min(yy,lim);
	if(x>xx) return 0;
	if(y>yy) return 0;
	int res=dp[xx][yy];
	if(y-1>=0) red(res+=mo-dp[xx][y-1]);
	if(x-1>=0) red(res+=mo-dp[x-1][yy]);
	if(x-1>=0 && y-1>=0) red(res+=dp[x-1][y-1]);
	return res;
}
signed main(){
	for(int cas=read();cas--;){
		n=read(),c=read(),C0=read(),C1=read(),D0=read(),D1=read();
		for(int i=1;i<=c;++i) mp[i].clear();
		memset(ban,0,sizeof(ban));
		memset(flag,0,sizeof(flag));
		memset(sum,0,sizeof(sum));
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		memset(dp,0,sizeof(dp));
		S=0;
		for(int i=1;i<=n;++i){
			bel[i]=read(),s[i]=read();
			mp[bel[i]].push_back(i);
			S+=s[i];
			sum[bel[i]]+=s[i];
		}
		int K=read();lim=K*10;
		while(K--){
			int id=read(),p=read();
			ban[id][p]=1;
			flag[bel[id]]=1;
		}
		f[0]=1;
		for(int i=1;i<=n;++i){
			if(ban[i][0]+ban[i][1]+ban[i][2]+ban[i][3]) continue;
			for(int j=D0;j>=s[i];--j){
				red(f[j]+=f[j-s[i]]);
			}
		}
		g[0]=1;
		for(int i=1;i<=c;++i){
			if(!sum[i] || flag[i]) continue;
			for(int j=C0;j>=sum[i];--j){
				red(g[j]+=g[j-sum[i]]);
			}
		}
		dp[0][0]=1;
		for(int i=1;i<=c;++i){
			if(!flag[i]) continue;
			for(int j=C0;j>=sum[i];--j){
				for(int k=0;k<=lim;++k){
					tmp[j][k]=dp[j-sum[i]][k];
				}
			}
			for(int j=sum[i]-1;j>=0;--j){
				for(int k=0;k<=lim;++k){
					tmp[j][k]=0;
				}
			}
			for(int v:mp[i]){
				if(ban[v][0]+ban[v][1]+ban[v][2]+ban[v][3]==0) continue;
				if(ban[v][0]){
					for(int j=0;j<=C0;++j){
						for(int k=lim;k>=s[v];--k){
							red(dp[j][k]+=dp[j][k-s[v]]);
						}
					}
				}
				if(ban[v][1]){
					for(int j=0;j<=C0;++j){
						for(int k=lim;k>=s[v];--k){
							red(dp[j][k]+=dp[j][k-s[v]]);
							tmp[j][k]=tmp[j][k-s[v]];
						}
						for(int k=s[v]-1;k>=0;--k) tmp[j][k]=0;
					}
				}
				if(ban[v][2]){
					for(int j=0;j<=C0;++j){
						for(int k=lim;k>=s[v];--k){
							red(tmp[j][k]+=tmp[j][k-s[v]]);
						}
					}
				}
				if(ban[v][3]){
					for(int j=0;j<=C0;++j){
						for(int k=lim;k>=s[v];--k){
							red(tmp[j][k]+=tmp[j][k-s[v]]);
							dp[j][k]=dp[j][k-s[v]];
						}
						for(int k=s[v]-1;k>=0;--k) dp[j][k]=0;
					}
				}
			}
			for(int j=0;j<=C0;++j){
				for(int k=0;k<=lim;++k){
					red(dp[j][k]+=tmp[j][k]);
				}
			}
		}
		for(int j=0;j<=C0;++j){
			for(int k=0;k<=lim;++k){
				if(j-1>=0) red(dp[j][k]+=dp[j-1][k]);
				if(k-1>=0) red(dp[j][k]+=dp[j][k-1]);
				if(j-1>=0 && k-1>=0) red(dp[j][k]+=mo-dp[j-1][k-1]);
			}
		}
		int ans=0;
		for(int i=0;i<=C0;++i){
			for(int j=0;j<=D0;++j){
				red(ans+=g[i]*f[j]%mo*query(S-i-C1,C0-i,S-j-D1,D0-j)%mo);
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}

```



---

## 作者：2018ljw (赞：3)

把城市视为颜色，学校视为数的话，大致就是将所有数分配进 $2\times 2$ 的网格，要求同色的数在同一行，每行每列和均有一个上界，并且有 $k$ 个数不能进入某个格子，问方案。

$k$ 很小先当它没有。

一个显然的想法是每次同时处理一种颜色，$dp_{i,x,y}$ 表示填入前 $i$ 个数第一行和为 $x$，第一列和为 $y$ 的方案数。每次转移一种城市时，先确定城市归属，然后常规背包转移即可。复杂度大致为 $O(nM^2)$。

关注到转移一个城市前后，$x$ 维增量固定。进一步的，城市换行不会改变列和，学校换列不会改变行和，所以我们可以将两维独立开分析。

这样只需要对两维分别背包，复杂度降至 $O(nM)$，最后合并统计答案。便于表示，我们记对行背包数组为 $dp$，对列背包数组为 $g$。

然后处理比较难搞的 $k$ 个限制。

称有限制的学校为毒瘤学校，有毒瘤学校的城市为毒瘤城市。我们先把所有非毒瘤城市用正常做法全部处理完毕，然后逐个毒瘤城市处理。

冷静分析一下，发现毒瘤城市中的非毒瘤学校其实是不受城市影响的。因为毒瘤学校的问题是不能随便换行或换列，因此需要特殊处理转移。把所有非毒瘤学校丢入列的转移，这样只差 $k$ 个毒瘤学校和至多 $k$ 个毒瘤城市未处理。

$k$ 很小，因此考虑先前的 $O(nM^2)$ 背包。设 $f_{x,y}$ 表示第一行和为 $x$，第一列和为 $y$ 的方案。转移时需要保证整个城市所有点在同一行，因此额外记录一维，即 $f_{x,y,2}$ 表示第一行总和为 $x$，第一列总和为 $y$，当前城市在第一/二行的方案数。

初值 $f_{0,0,0}=1$，每次加入学校时，若该学校的限制和归属同一行，则相当于必选或必不选，否则可选可不选，跑背包即可。当处理完一个城市后，新城市的 $0/1$ 和老城市的 $0/1$ 不再有关联，且需要考虑到那些不毒瘤的学校对该行贡献，因此每次切换学校时的初值为：$f_{x,y,0}=f_{x-sum,y,0}+f_{x-sum,y,1}$，$f_{x,y,1}=f_{x,y,0}+f_{x,y,1}$。其中 $sum$ 为该城市里非毒瘤学校的数字和。

城市切换初始化和每次插入学校复杂度均为 $O(Mks)$，两者均至多做 $k$ 次，总复杂度 $O(Mk^2s)$。

考虑最终答案的构成，记 $S$ 为数字总和。第一行数的和要求在区间 $[\max\{0,S-c_1\},c_0]$，第一列同理，分别记为 $[l_1,r_1]$ 和 $[l_2,r_2]$。

枚举 $f_{x,y}$ 的贡献为 $f_{x,y}\sum dp_i\times g_j$，满足 $i+x$ 和 $j+y$ 均在区间内。后面这项实际就是两个区间和乘在一起，直接维护即可。

复杂度 $O(nM+Mk^2s)$。


---

## 作者：Doingdong (赞：3)

[题目链接](https://www.luogu.org/problemnew/show/P5289)

选一个派系和一个阵营可以唯一确定一名导师

因为每一个阵营里的导师都分别来自不同派系，所以k=0时，对阵营的选择是不影响对派系的选择的

唯一的限制就是同城市的要在同一个阵营

所以以每个城市为物品，物品大小为该城市的人数，阵营人数为背包容量，做背包dp

再以每个学校为物品，物品大小为该学校的人数，派系人数为背包容量，做背包dp

只用一维记录背包大小即可，因为总人数-背包里的人数=在另一个阵营或派系的人数

然后合并答案即可

方案数是可以相互乘起来的，k很小，所以我们可以暴力做k！=0的情况，然后乘上符合要求的k==0的方案数

k！=0时，记$f[x][t][i][j]$为前x个学校，前一个学校选择了t阵营，此时蓝有i个人，鸭派有j个人的方案数

滚动第一维，否则空间会爆

将学校按城市排序，这样相同城市的就会排在一起，转移的时候如果和前一个学校同城就要选择相同阵营

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;++i)
using namespace std;
typedef long long ll;
typedef double db;
char cch;
inline int rd(){
    int x=0,fl=1;
    cch=getchar();
    while(cch>'9'||cch<'0'){
        if(cch=='-') fl=-1;
        cch=getchar();
    }
    while(cch>='0'&&cch<='9') x=(x<<3)+(x<<1)+cch-'0',cch=getchar();
    return x*fl;
}
const int mod=998244353,N=3000;
struct abc{
	int ct,sum,ban;
}p1[N],p2[N];
int f[N],g[N],ff[2][2][N][N],ok[N],bl[N],ct[N],city[N],sum[N],ban[N];
inline void inc(int &A,int B){//会比 %mod快一点点 
	A+=B;
	if(A>mod) A-=mod;
	if(A<0) A+=mod;
}
inline int mul(int A,int B){
	return 1ll*A*B%mod;
}
inline int sub(int a,int b){
	a-=b;
	if(a<0) a+=mod;
	return a;
}
inline int getg(int l,int r){
	if(l>r) return 0;
	if(l==0) return g[r];//为了dp方便g[0]=1，实际上应该是0
	return sub(g[r],g[l-1]);
}
inline int getf(int l,int r){
	if(l>r) return 0;
	if(l==0) return f[r];//同理 
	return sub(f[r],f[l-1]);
}
inline bool cmp(const abc &a1,const abc &a2){
	return a1.ct<a2.ct;
}
inline void sv(){
	int n=rd(),c=rd(),c0=rd(),c1=rd(),d0=rd(),d1=rd(),ans=0,tot=0;//n所学校，c个城市，蓝阵营 C0。 红阵营 C1。 鸭派系 D0。 R派系D1。
	memset(city,0,sizeof city);
	rep(i,1,n) ct[i]=rd(),sum[i]=rd(),tot+=sum[i],ban[i]=-1,city[ct[i]]+=sum[i];//city[i]表示第i个城市一共有多少人 
	int k=rd(),id;
	rep(i,1,k) id=rd(),ban[id]=rd();
	int len1=0,len2=0;
	rep(i,1,n){
		if(ban[i]!=-1) p1[++len1]=(abc){ct[i],sum[i],ban[i]};//有特殊要求的 
		else p2[++len2]=(abc){ct[i],sum[i],ban[i]};//没有特殊要求的 
	}
	sort(p1+1,p1+len1+1,cmp);//按城市排序
    rep(i,1,len1){
        if(city[p1[i].ct]==-1) ok[i]=0;//阵营的转移以城市为单位
        else ok[i]=city[p1[i].ct]/*注意*/,city[p1[i].ct]=-1;
    }
    //
    memset(g,0,sizeof g),g[0]=1;
    rep(i,1,c) if(city[i]>0) for(int j=c0;j>=city[i];--j) inc(g[j],g[j-city[i]]);
    /*做前缀和*/rep(i,1,c0) inc(g[i],g[i-1]);
    //
    memset(f,0,sizeof f),f[0]=1;
    rep(i,1,len2) for(int j=d0;j>=p2[i].sum;--j) inc(f[j],f[j-p2[i].sum]);
    /*做前缀和*/rep(i,1,d0) inc(f[i],f[i-1]);
    //
    memset(ff,0,sizeof ff);//ff[x][t][i][j]为前x个学校，前一个学校选择了t阵营，此时蓝有i个人，鸭派有j个人的方案数，滚动第一维 
    ff[0][0][0][0]=1;
    int cnt=0,now=0;
    rep(i,1,len1){//对有要求的学校暴力求解
        now^=1;
        int tmp=p1[i].sum,bn=p1[i].ban,d=ok[i],lst=cnt;//lst=之前的学校的总人数 
        cnt+=tmp;
        rep(t,0,1) rep(h,0,c0) rep(j,0,cnt) ff[now][t][h][j]=0;//这里不可以用memset，用了会超时，因为一开始cnt很小，所以循环更快 
        rep(t,0,1){
            int cs=-1;//choise
            if(i>1&&p1[i].ct==p1[i-1].ct) cs=t; 
            for(int i=c0;i>=0;--i) for(int j=cnt;j>=0;--j){
                if(cs!=1){//如果同城市的选择了0阵营，或与上一个不同城，
                     if(bn!=1&&i>=d&&j<=lst) inc(ff[now][0][i][j],ff[now^1][t]/*注意是t而不是0*/[i-d][j]);//没有禁掉小R，可以加入R派 
                     if(bn!=0&&i>=d&&j-tmp<=lst&&j>=tmp) inc(ff[now][0][i][j],ff[now^1][t][i-d][j-tmp]);//没有禁掉Yazid，可以加入鸭派
                }
                if(cs!=0){//如果同城市的选择了1阵营，或与上一个不同城，
                    if(bn!=3&&j<=lst) inc(ff[now][1][i][j],ff[now^1][t][i][j]);
                    if(bn!=2&&j-tmp<=lst&&j>=tmp) inc(ff[now][1][i][j],ff[now^1][t][i][j-tmp]);
                }
            }
        }
    }
    //
    rep(t,0,1) rep(i,0,c0) rep(j,0,d0){
        int v=ff[now][t][i][j];
        if(!v)continue;
        int t1=c0-i,t2=max(0,tot-d1-j),t3=max(0,tot-c1-i),t4=d0-j;//符合人数要求的区间 
        inc(ans,mul(v,mul(getg(t3,t1),getf(t2,t4))));
    }
    printf("%d\n",ans);
}
int main(){
	int T=rd();
	while(T--) sv();
}
/*
2
2 1
3 2 2 2
1 1
1 2
1
1 0
4 2
10 30 20 30
1 6
2 4
1 7
2 4
2
2 3
3 1
*/
```


---

## 作者：wjyppm1403 (赞：1)

[可能更好的阅读体验](https://worldcpu.github.io/posts/ea6060be/)

有一个显然的想法就是让导师们去找学生，设 $f(i,j,k,p)$ 表示四个导师选的人数状态下的方案数，转移判断满不满足题目中所给的派系和阵营限制即可，时间复杂度 $O(nm^4)$，不难发现只需要确定三个即可，时间复杂度 $O(nm^3)$。然后就不会了。

观察这个 DP 及其难以优化，因为如果我们缺任何一个信息都无法描述完整的子问题，而且复杂度要求的可是 $O(nm)$，你只知道一个信息那么肯定啥也导出不了啊。我们考虑发掘几个性质：

- 确定一个派系和一个阵营可以**唯一确定**一位导师。
- 题目中 ban 导师的相当于不选**钦定的派系和阵营**。

上述性质启示我们让每一个学生去确定它们的派系和阵营，而不是导师去确定学生。但是还有我们的 “坏” 学生，不喜欢选的。我们先丢掉它们，先考虑 $k=0$ 的部分分。

有一个显然的 DP 就是 $f(i,j)$ 表示 $i$ 个蓝阵营的人，$j$ 个鸭阵营的人的方案数，剩余两个可以由这两个状态唯一表示出来，时间复杂度 $O(nm^2)$，仍无法通过。正解启示 $O(nm)$，考虑进一步发掘性质：

- 题目中学生来自的城市限制，和学校限制是互相独立互不冲突的。

这个性质启发我们分离上面状态设计中的 $i,j$。那么不妨设 $f(i)$ 表示蓝阵营有 $i$ 个人的方案数，$g(i)$ 表示鸭阵营有 $i$ 个人的方案数，两个答案可以通过乘法原理分别算出来之后乘起来即可，时间复杂度 $O(nm)$。

现在考虑 $k>0$，一个重要的观察是 $k\le 30$。状压、枚举？都不对。我们上面的计算答案过程中体现了乘法原理的思想，也就是说我们也可以分离 “坏学生” 和 “好学生”，好学生单独做，坏学生单独做，最后乘起来即可。

坏学生的限制怎么处理，我们肯定不能用 $O(nm)$ 的算法了，这个算法肯定是无法处理我们的限制的。回看我们之前 $O(nm^2)$ 的解法，这个就能够很好的处理性质，因为状态能够表示所有派系阵营选择人数，我们可以用这个算法处理坏学生就可以啦。时间复杂度做的话是 $O(k^2sm)$ 的。

那么时间复杂度就是 $O(nm+k^2 sm)$。

总结：

- 我们在设计状态的时候，应当尽量个限制紧密贴合。在优化 DP 的时候我们要考虑我们计算贡献具体需要什么信息，我们需要什么信息就足够了，去掉冗余的无用信息。
- 题目可能会故意引导你走向死路，如果一个方向想不通，不妨正难则反或换一种方法想，这里体现的是正难则反的思路。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int MN=2520,MOD=998244353;
int F[MN][MN],G[MN][MN],f[MN],g[MN],h[MN],s[MN],b[MN],sumb[MN],sums,n,c,c0,c1,d0,d1,C,K,D,ans;
bool hc[MN];

void init(){
    memset(F,0,sizeof(F));
    memset(G,0,sizeof(G));
    memset(f,0,sizeof(f));
    memset(g,0,sizeof(g));
    ans=C=D=0; sums=0;
    for(int i=1;i<=n;i++){
        h[i]=-1;
        sumb[i]=0;
        hc[i]=false;
    }
}

void solve(){
    cin>>n>>c>>c0>>c1>>d0>>d1;
    init();
    for(int i=1;i<=n;i++){
        cin>>b[i]>>s[i];
        sums+=s[i];
        sumb[b[i]]+=s[i];
    }
    cin>>K;
    for(int i=1;i<=K;i++){
        int x;cin>>x>>h[x];
        hc[b[x]]=true;
    }
    f[0]=1;
    for(int i=1;i<=c;i++) if(!hc[i]&&sumb[i]){
        for(int j=c0;j>=sumb[i];j--) f[j]=(f[j]+f[j-sumb[i]])%MOD;
    }
    for(int i=1;i<=c0;i++) f[i]=(f[i-1]+f[i])%MOD;
    g[0]=1;
    for(int i=1;i<=n;i++) if(h[i]==-1){
        for(int j=d0;j>=s[i];j--) g[j]=(g[j]+g[j-s[i]])%MOD;
    }
    for(int i=1;i<=d0;i++) g[i]=(g[i-1]+g[i])%MOD;
    F[0][0]=1;
    for(int ct=1;ct<=c;ct++) if(hc[ct]){
        C+=sumb[ct]; C=min(C,c0);
        for(int i=0;i<=C;i++) for(int j=0;j<=D;j++) G[i][j]=F[i][j];
        for(int x=1;x<=n;x++) if(h[x]!=-1&&b[x]==ct){
            int t=s[x]; D+=t; D=min(D,d0);
            if(h[x]==1){ 
                for(int i=0;i<=C;i++){for(int j=D;j>=t;j--) F[i][j]=F[i][j-t]; for(int j=0;j<t;j++) F[i][j]=0;}
            }
            if(h[x]>=2){ 
                for(int i=0;i<=C;i++) for(int j=D;j>=t;j--) F[i][j]=(F[i][j]+F[i][j-t])%MOD;
            }
            if(h[x]==3){ 
                for(int i=0;i<=C;i++){for(int j=D;j>=t;j--) G[i][j]=G[i][j-t]; for(int j=0;j<t;j++) G[i][j]=0;}
            }
            if(h[x]<=1){ 
                for(int i=0;i<=C;i++) for(int j=D;j>=t;j--) G[i][j]=(G[i][j]+G[i][j-t])%MOD;
            }
        }
        int t=sumb[ct];
        if(t>0){
            for(int i=C;i>=t;i--) for(int j=0;j<=D;j++) F[i][j]=F[i-t][j];
            for(int i=0;i<t;i++) for(int j=0;j<=D;j++) F[i][j]=0;
        }
        for(int i=0;i<=C;i++) for(int j=0;j<=D;j++) F[i][j]=(F[i][j]+G[i][j])%MOD;
    }
    for(int i=0;i<=C;i++) for(int j=0;j<=D;j++){
        int l1=max(0ll,sums-c1-i),r1=c0-i; if(l1>r1) continue;
        int l2=max(0ll,sums-d1-j),r2=d0-j; if(l2>r2) continue;
        int ret1=f[r1],ret2=g[r2];
        if(l1) ret1=(ret1-f[l1-1]+MOD)%MOD;
        if(l2) ret2=(ret2-g[l2-1]+MOD)%MOD;
        ans=(ans+ret1*ret2%MOD*F[i][j])%MOD;
    }
    cout<<(ans+MOD)%MOD<<'\n';
}

signed main(){
    ios::sync_with_stdio(0);cin.tie(0);
    int T;cin>>T;while(T--) solve();
    return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：1)

## 题目简述

> - 有 $n$ 种物品，每种物品有两个属性：颜色 $c_i$ 和重量 $w_i$。
> - 把 $n$ 个物品分到 $2$ 行 $2$ 列的 $4$ 个盒子当中，求满足一下条件的分配数量，对 $998244353$ 取模：
> - - 每行、列的重量和有限制：$C_0,C_1$、$D_0,D_1$。
>   - 同种颜色在同一列。
>   - 有 $k$ 个物品有特殊限制：指定了一个不能选的盒子。
> - $n\leq 1000$，$M=\max(C_i,D_i)\leq 2500$，$k\leq 30$，$w_i\leq 10$。

## 解题思路

为了讨论方便，下面物品的扫描顺序按颜色排序。

先转换一下题目，注意到行、列重量和是固定的，我们可以把条件 $1$ 转换成第 $1$ 行、第 $1$ 列重量和有上、下界。

首先考虑 $k=0$ 的情况。这是不难发现每种颜色选择的列，每个物品选择的行是互不干预的。我们当做两个独立的问题求解即可。最终复杂度 $O(nM)$，期望得分 $40$ 分。我们称为【算法 $1$】。

如果你足够聪明，你还会写一个 $O(nM^2)$ 的 dp，具体的假设 $f[i][j][k]$ 为选取前 $i$ 个物品，第一行重量为 $j$，第一列重量为 $k$ 的方案数。我们已经有 $70$ 分了。我们称之为【算法 $2$】。

继续考虑优化，我们发现特殊限制的物品个数很少，所以我们可以让没有限制的物品和没有限制的颜色来跑【算法 $1$】，对有特殊限制的物品和颜色跑【算法 $2$】 即可期望得分 $100$ 分。

## 具体实现

对于没有特殊限制的颜色，我们对它进行背包算出来第 $1$ 列有 $i$ 重量的方案数为 $f_i$。对每个没有特殊限制的物品，我们通过背包算出来第 $1$ 行有 $i$ 重量的方案数 $g_i$。算这个的时间复杂度是 $O(nM)$ 的。

对于有特殊限制的颜色，我们假设 $F[i][j]$ 表示第一行重量为 $i$ 第二行重量为 $j$ 的方案数。对于有限制的颜色去转移 $j$，对于有限制的物品去转移 $i$ 即可。观察到 $k$ 很少，所以第一位不超过 $kw_i$，第二位是 $M$ 的，时间复杂度是 $O(k^2w_iM)$。

最终复杂度为 $O(T(nW+k^2w_iM))$ 可以通过。

放个代码：

```cpp
void add(ll &a,ll b){a+=b;if(a>=MOD)a-=MOD;}
ll pls(ll a,ll b){a+=b;return (a>=MOD?a-MOD:a);} 
ll sub(ll a,ll b){a-=b;if(a<0)a+=MOD;return a;} 
void READ(){
	cin>>n>>c>>c0>>c1>>d0>>d1;
	for(int i=1;i<=n;i++) vis[i]=siz[i]=0,ban[i]=-1;
	for(int i=0;i<MR;i++){ 
		f[i]=g[i]=0;
		for(int j=0;j<MR;j++) F[i][j]=G[i][j]=0;
	} 
	f[0]=g[0]=F[0][0]=1;
	for(int i=1;i<=n;i++) cin>>b[i]>>s[i],siz[b[i]]+=s[i];
	cin>>_;
	while(_--){
		int x;cin>>x;cin>>ban[x];vis[b[x]]=1;
	}
}
void WORK_UNBAN(){
	for(int i=1;i<=n;i++)
		if(ban[i]==-1)
			for(int j=d0;j>=s[i];j--)
				add(f[j],f[j-s[i]]);
	for(int i=1;i<=c;i++)
		if(!vis[i]&&siz[i])
			for(int j=c0;j>=siz[i];j--)
				add(g[j],g[j-siz[i]]);
	for(int i=1;i<=d0;i++) add(f[i],f[i-1]);
	for(int i=1;i<=c0;i++) add(g[i],g[i-1]);
	return;
}
void WORK_BAN(){
	int sum=0;
	for(int i=1;i<=c;i++)
		if(vis[i]){
			for(int j=0;j<=c0;j++)
				for(int k=0;k<=sum;k++)
					G[j][k]=F[j][k];
			// F 对应选左边, G 对应选右边 
			for(int j=1;j<=n;j++)
				if(ban[j]>=0&&b[j]==i){
					sum+=s[j];sum=min(sum,d0); 
					if(ban[j]==1){
						for(int k=0;k<=c0;k++){
							for(int t=sum;t>=0;t--)
								F[k][t]=(t>=s[j]?F[k][t-s[j]]:0);
						}
					}else if(ban[j]!=0){
						for(int k=0;k<=c0;k++)
							for(int t=sum;t>=s[j];t--)
								add(F[k][t],F[k][t-s[j]]);
					}
					if(ban[j]==3){
						for(int k=0;k<=c0;k++){
							for(int t=sum;t>=0;t--)
								G[k][t]=(t>=s[j]?G[k][t-s[j]]:0);
						}
					}else if(ban[j]!=2){
						for(int k=0;k<=c0;k++)
							for(int t=sum;t>=s[j];t--)
								add(G[k][t],G[k][t-s[j]]);
					}
				}
			for(int j=c0;j>=0;j--)
				for(int k=0;k<=sum;k++)
					F[j][k]=(j>=siz[i]?F[j-siz[i]][k]:0);
			for(int j=0;j<=c0;j++)
				for(int k=0;k<=sum;k++)
					add(F[j][k],G[j][k]);	
		}

	return;
}
ll pre_f(int l,int r){return sub(f[r],(l?f[l-1]:0));}
ll pre_g(int l,int r){return sub(g[r],(l?g[l-1]:0));}
void CALC(){
	int sum=0;ll ans=0;
	for(int i=1;i<=n;i++) sum+=s[i];
	for(int i=0;i<=c0;i++)
		for(int j=0;j<=d0;j++){
			int lc=max(sum-c1-i,0),rc=c0-i;
			int ld=max(sum-d1-j,0),rd=d0-j;
			if(lc>rc||ld>rd) continue;
			add(ans,pre_g(lc,rc)*pre_f(ld,rd)%MOD*F[i][j]%MOD);
		}
	cout<<ans<<endl;
}
void solve(){
	READ();
	WORK_UNBAN();
	WORK_BAN();
	CALC();
	return;
}
```



---

## 作者：zifanwang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5289)

$\large\textbf{Statement.}$

**本题的重点在于题面。**

有 $n$ 个学校和 $c$ 个城市，每个学校属于一个城市，学校人数给定。

你需要将每个学校和城市染成黑色或白色，其中有 $k$ 个学校不希望自己和所在城市的颜色同时分别为给定的两种颜色，黑/白城市和学校的总人数也有限制。求染色方案数。

---
$\large\textbf{Solution.}$

令 $dp_{i,j,k}$ 表示考虑了前 $i$ 个有限制的城市，黑色城市和学校的人数和分别为 $j,k$，染色方案数。

对于没有限制的学校，最后一起做一个背包即可。

对于有限制的城市，枚举其颜色，用它的所有有限制的学校更新 $dp$ 值。

最后有限制的和没限制的两个背包合并一下就做完了。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 2503
#define md 998244353
#define pb push_back
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
int T,n,m,k,ans,c[2],d[2],s[mxn],a[mxn],f[mxn],dp[2][mxn][mxn],f1[mxn][mxn],f2[mxn][mxn],d1[mxn],d2[mxn];
bool v[mxn];
vector<int>g[mxn];
signed main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d%d%d%d",&n,&m,&c[0],&c[1],&d[0],&d[1]);
		rep(i,1,m)v[i]=0,g[i].clear();
		rep(i,1,n)scanf("%d%d",&a[i],&s[i]),f[i]=-1,g[a[i]].pb(i);
		scanf("%d",&k);
		for(int i=0,x,y;i<k;++i){
			scanf("%d%d",&x,&y);
			f[x]=y,v[a[x]]=1;
		}
		int sum=0;
		bool fl=0;
		memset(dp,0,sizeof(dp));
		dp[0][0][0]=1;
		rep(i,1,m)if(v[i]){
			int sm=0;
			for(int j:g[i])sm+=s[j];
			fl^=1;
			int s1=sm; 
			drep(j,min(sum+sm,c[0]),0)drep(k,min(sum+sm,d[0]),0){
				dp[fl][j][k]=0;
				f1[j][k]=dp[fl^1][j][k];
			}
			for(int j:g[i])if(f[j]!=-1){
				drep(x,min(sum+sm,c[0]),0)drep(y,min(sum+sm,d[0]),0)f2[x][y]=0;
				drep(x,min(sum,c[0]-s[j]),0){
					drep(y,min(sum,d[0]),0)if(f1[x][y]){
						if((f[j]>>1)==1){
							if(y+s[j]<=d[0])f2[x+s[j]][y+s[j]]=(f2[x+s[j]][y+s[j]]+f1[x][y])%md;
							f2[x+s[j]][y]=(f2[x+s[j]][y]+f1[x][y])%md;
						}else if(f[j]&1){
							if(y+s[j]<=d[0])f2[x+s[j]][y+s[j]]=(f2[x+s[j]][y+s[j]]+f1[x][y])%md;
						}else f2[x+s[j]][y]=(f2[x+s[j]][y]+f1[x][y])%md;
					}
				}
				sum+=s[j],sm-=s[j];
				drep(x,min(sum+sm,c[0]),0)drep(y,min(sum+sm,d[0]),0)f1[x][y]=f2[x][y];
			}
			drep(x,min(sum,c[0]-sm),0)drep(y,min(sum,d[0]),0)if(f1[x][y]){
				dp[fl][x+sm][y]=(dp[fl][x+sm][y]+f1[x][y])%md;
			}
			drep(j,min(sum+sm,c[0]),0)drep(k,min(sum+sm,d[0]),0)f1[j][k]=dp[fl^1][j][k];
			sum-=s1-sm,sm=s1;
			for(int j:g[i])if(f[j]!=-1){
				drep(x,min(sum+sm,c[0]),0)drep(y,min(sum+sm,d[0]),0)f2[x][y]=0;
				drep(x,min(sum,c[0]),0){
					drep(y,min(sum,d[0]),0)if(f1[x][y]){
						if((f[j]>>1)==0){
							if(y+s[j]<=d[0])f2[x][y+s[j]]=(f2[x][y+s[j]]+f1[x][y])%md;
							f2[x][y]=(f2[x][y]+f1[x][y])%md;
						}else if(f[j]&1){
							if(y+s[j]<=d[0])f2[x][y+s[j]]=(f2[x][y+s[j]]+f1[x][y])%md;
						}else f2[x][y]=(f2[x][y]+f1[x][y])%md;
					}
				}
				sum+=s[j],sm-=s[j];
				drep(x,min(sum+sm,c[0]),0)drep(y,min(sum+sm,d[0]),0)f1[x][y]=f2[x][y];
			}
			drep(x,min(sum,c[0]),0)drep(y,min(sum,d[0]),0)if(f1[x][y]){
				dp[fl][x][y]=(dp[fl][x][y]+f1[x][y])%md;
			}
			sum+=sm;
		}
		memset(d1,0,sizeof(d1));
		memset(d2,0,sizeof(d2));
		d1[0]=d2[0]=1;
		rep(i,1,m)if(!v[i]&&g[i].size()){
			int sm=0;
			for(int j:g[i])sm+=s[j];
			drep(j,c[0],sm)d1[j]=(d1[j]+d1[j-sm])%md;
			for(int j:g[i])drep(k,d[0],s[j])d2[k]=(d2[k]+d2[k-s[j]])%md;
			sum+=sm; 
		}
		rep(i,1,n)if(v[a[i]]&&f[i]==-1){
			drep(k,d[0],s[i])d2[k]=(d2[k]+d2[k-s[i]])%md;
		}
		rep(i,1,c[0])d1[i]=(d1[i]+d1[i-1])%md;
		rep(i,1,d[0])d2[i]=(d2[i]+d2[i-1])%md;
		ans=0;
		rep(i,0,c[0])rep(j,0,d[0]){
			if(c[0]-i<sum-i-c[1]||d[0]-j<sum-j-d[1])continue;
			ans=(ans+(ll)dp[fl][i][j]*(d1[c[0]-i]-(sum-i-c[1]-1>=0?d1[sum-i-c[1]-1]:0))%md*(d2[d[0]-j]-(sum-j-d[1]-1>=0?d2[sum-j-d[1]-1]:0)))%md;
		}
		printf("%d\n",(ans+md)%md); 
	}
	return 0;
}
```

---

## 作者：intel_core (赞：0)

从 $k=0$ 的情况开始思考这个问题。

不难发现，此时阵营和派系可以分开考虑，最后的答案就是 $ans1 \times ans2$。

令 $f1_{i,j}$ 表示考虑到第 $i$ 个城市，加入第一个阵营的学生人数为 $j$ 的种类数。

处理每个城市学生的人数然后 01 背包，复杂度 $O(cM)$。

派系的情况可以类似处理出 $f2_{i,j}$：考虑到第 $i$ 所学校，有 $j$ 名学生属于第一派系，把学校作为整体也可以 01 背包，复杂度 $O(nM)$。

现在我们考虑处理 $k$ 个特殊限制。

我们顺着刚才的思路，可以先处理那些没有特殊学校的城市的情况。

令 $f_{i,j}$ 表示处理到当前城市时，$i$ 个学生属于第一阵营，$j$ 个学生属于第一派系时的方案数。

接下来处理有特殊学校的城市。

考虑处理城市 $x$ 时的转移，我们先把 $x$ 中没有特殊限制的学校拿出来，处理出 $f2$ 数组（上文）。

接着我们枚举 $x$ 城市的学生加入哪个派系，那么 $i$ 这一维的转移就很轻松了；在 $g$ 数组的基础上处理特殊学校的派系转移情况，注意不能把学校扔到讨厌的导师那里。

最后枚举 $x$ 城市中有多少学生属于第一派系，算出 $f$ 的转移。

简单描述一下最后的转移方式。

令 $f_{0/1.i,j}$ 表示当前状态下有 $i$ 名学生属于第一阵营，$j$ 名学生属于第一派系时的方案数，$0/1$ 那一维是滚动数组，实际含义是当前城市编号（这里只考虑有特殊限制的城市）。

先处理所有没有特殊限制的城市的 $f_1$ 和 $f_2$，令 $f_{0,i,j}=f1_{cnt1,i} \times f2_{cnt2,j}$ ，这里 $cnt1/cnt2$ 表示没有特殊限制的城市/学校数量。

（因为 $f_{0,i,j}$ 向 $f_{1,i,j}$ 和 $f_{1,i,j}$ 向 $f_{0,i,j}$ 转移是一样的，以下以前者为例）。

讨论一下 $A$ 城市集体加入哪个阵营，不妨设都加入阵营一（阵营二同理）。

把不排斥阵营一的学校拿出来（包括无特殊限制学校和排斥阵营二导师的学校），处理这些学校里 $i$ 名学生选择派系一的方案数 $g_i$。

由于此时剩下的学生选择哪个导师是固定的，假设固定的学校中有 $k1$ 个选择派系一。

那么转移就是 $f_{1,i+sum,j+k+x}+=g_x$，这里 $sum$ 表示 $A$ 城市中所有学校学生的数量。

以上说明没有将条件写出，默认均为派系/阵营的学生数量限制。

复杂度 $O(kM^2+nM)$。

---


# [HNOI2019] 序列

## 题目背景

HNOI2019 day2t3

## 题目描述

给定一个长度为 $n$ 的序列 $A_1,A_2,\dots, A_n$，以及 $m$ 个操作，每个操作将一个 $A_i$ 修改为 $k$。第一次修改之前及每次修改之后，都要求你找到一个同样长度为 $n$ 的**单调不降**序列 $B_1,B_2,\dots ,B_n$，使得 $\sum\limits_{i=1}^n(A_i-B_i)^2$ 最小，并输出最小值。

需要注意的是每次操作的影响都是独立的，也即每次操作只会对当前询问造成影响。

为了避免精度问题，我们保证这个最小值是个分数，也即能表示为两个非负整数相除的形式：$\dfrac{x}{y}$。那么你将要输出 $(x\times y^{P-2}\bmod P)$ 的值，表示模意义下 $\dfrac{x}{y}$ 的值。其中 $P=998244353$ 是一个大质数。

## 说明/提示

### 【样例解释】

第一个询问的最优 $B$ 序列为：$\{5, 5, 5, 5, 5\}$。

第二个询问的最优 $B$ 序列为：$\{1, 2, 4, 5, 5\}$。

第三个询问的最优 $B$ 序列为：$\{3, 3, 4, 5, 5\}$。

第四个询问的最优 $B$ 序列为：$\{5, 5, 5, 6, 6\}$。

样例是存在最优方案使 $B_i$ 皆为整数的特殊情况。

### 【数据范围与约定】

对于前 $10\%$ 的数据，保证 $n,m\le 10$，$k,A_i\le 10^3$，且存在一种最优方案，使得 $B_i$ 皆为整数。

对于前 $30\%$ 的数据，保证 $n,m\le 100$。

对于另外 $20\%$ 的数据，保证 $m = 0$。

对于另外 $20\%$ 的数据，保证 $n,m \le 3 \times  10^4$。

对于所有数据，保证 $3 \le n \le 10^5,0 \le m \le 10^5,1 \le k, A_i \le 10^9$。

## 样例 #1

### 输入

```
5 3
9 2 4 6 4
1 1
1 4
5 6```

### 输出

```
28
2
4
26```

# 题解

## 作者：zhongyuwei (赞：27)

## 参考资料

- IOI2018 集训队论文 高睿泉 《浅谈保序回归问题》
- [大米饼的博客](https://www.cnblogs.com/Paul-Guderian/p/10801584.html)


## Sol

### 部分分：$m=0$

考虑一个更加一般的形式：已知 $w_i, A_i \ge 0$，要求确定 $B_i$，使得 $B_i \le B_{i+1}$ 且 $\sum w_i(A_i - B_i)^2$ 最小。

定义一个点集 $U$ 的均值为：让 $\sum_{j\in U} w_j (A_j - k)^2$ 取到最小值的 $k$。对于这道题，$k = \frac{\sum_{j\in U} w_jA_j}{\sum_{j\in U} w_j}$（通过求导可得）

#### 引理 1

能达到最优解的 $\{ B_i \}$ 是唯一的。

证明：将 $(A_1,A_2,\cdots A_n)$ 和 $(B_1, B_2, \cdots B_n)$ 看作两个 $n$ 维向量，权值函数可以看作两个点之间的距离。由于不等式组 $B_i \le B_{i+1}$ 的解空间是一个凸集，所以到 $A$ 的距离最短的 $B$ 是唯一的。

#### 引理 2

如果 $A_i > A_{i+1}$，那么最优解中一定有 $B_i = B_{i+1}$。

证明：参考 IOI2018 集训队论文《浅谈保序回归问题》

引理 2 启发我们可以考虑这样的一个过程：每一次找到一个满足 $A_i > A_{i+1}$ 的 $i$，然后将 $i$ 和 $i+1$ 合并。具体地，应该把 $(w_i, A_i), (w_{i+1},A_{i+1})$ 替换为 $(w_i + w_{i+1}, \frac{w_iA_i + w_{i+1}A_{i+1}}{w_i + w_{i+1}})$，这样前后的权函数只相差一个常数，直接在合并的时候把这个常数加入答案即可。合并到无法合并的时候，直接令每个 $B_i$ 都取 $A_i$，这就是最优方案。最终的答案就是在合并的过程中产生的那些常数的和。

由引理 1 可知，无论以任何顺序合并，最终得到的 $\{ B_i \}$ 都是相同的，所以合并过程完成以后得到的那些同值的段（下文称为等值段）也一定是相同的。

### 正解

把询问离线下来依次处理。对于询问 $(x,y)$，先处理好只考虑 $[1,x-1]$ 和 $[x+1,n]$ 时，等值段的划分情况（可以用从左到右和从右到左的单调栈分别维护）。

最终的划分方案一定是：保留 $[1,x-1]$ 的等值段划分的一个前缀，保留 $[x+1,n]$ 的等值段划分的一个后缀，剩下的部分和 $x$ 合并为一段。设这个前缀包含了 $[1,x-1]$ 的前 $L_0$ 个等值段，这个后缀包含了 $[x+1,n]$ 的后 $R_0$ 个等值段。设 $L_0,R_0$ 之间（不含 $L_0,R_0$）的元素合并起来后的权值（也就是它们的平均值）为 $v(L_0,R_0)$。设 $[1,x-1]$ 中从左到右第 $x$ 段的 $A_i$ 为 $lv(x)$，设 $[x+1,n]$ 中从右到左第 $x$ 段的 $A_i$ 为 $rv(x)$。

考虑如何求出 $L_0,R_0$。我们对 $L_0,R_0$ 的要求是：

- $lv(L_0) < v(L_0,R_0) < rv(R_0)$
- $L_0,R_0$ 之间的元素确实能合并成一段（即合并过程中不存在把 $A_i < A_{i+1}$ 的两个元素合并了的情况）


考虑这样一个算法：从大到小枚举 $R_0$，然后求出最大的 $L_0$，使得 $lv(L_0) < v(L_0, R_0)$；如果 $v(L_0, R_0) < v(R_0)$ 就退出，把此时的 $L_0, R_0$ 作为答案，否则继续枚举 $R_0$。

- 对于某个固定的 $R_0$ 来说
  - 考虑某个比求出的 $L_0$ 更小的 $L_0'$：$v(L_0',R_0)$ 一定合并了不能合并的段（即满足 $A_i < A_{i+1}$ 的两个段）
  - 考虑某个比求出的 $L_0$ 更大的 $L_0'$：$v(L_0',R_0)$ 一定还能和左边的段合并，所以不可能和 $R_0$ 一起作为最终的等值段
- 故而，对于固定的 $R_0$ 来说，最大的满足 $lv(L_0) < v(L_0, R_0)$ 的 $L_0$ 是**唯一可能使 $(L_0,R_0)$ 合法**的 $L_0$

假设 $r$ 为算法结束时的 $R_0$：任意一个大于 $r$ 的 $R_0$ 显然不可能成为最终的等值段的右端点（因为还可以和右边的段合并）；而任意一个小于 $r$ 的 $R_0$，$v(L_0,R_0)$ 一定合并了不能合并的段。

所以，算法结束时求出来的 $L_0,R_0$ 就是我们想求的答案。

算法的优化：

- 在已知 $R_0$ 的情况下求最大的满足 $lv(L_0) < v(L_0, R_0)$ 的 $L_0$
  - 可以证明，如果 $L_0$ 满足条件，那么 $L_0 - 1$ 也满足条件
    - 由于 $lv(L_0) < v (L_0, R_0)$，又因为 $lv(L_0 - 1) < lv(L_0)$，所以 $lv(L_0 - 1) < v(L_0, R_0)$，那么 $lv(L_0 - 1)$ 一定小于 $lv(L_0), v(L_0,R_0)$ 中的元素的平均值（也就是 $v(L_0 - 1,R_0)$），所以 $L_0 - 1$ 一定也满足条件
  - 所以可以直接二分 $L_0$
- 求最大的 $R_0$，使得满足 $lv(L_0) < v(L_0, R_0)$ 的最大的 $L_0$ 也满足 $v(L_0, R_0) < rv(R_0)$
  - 一个重要的观察是，对于某个固定的 $R_0$，满足 $lv(L_0) < v(L_0, R_0)$ 的最大的 $L_0$，就是使 $v(L_0,R_0)$ 取到最大值的 $L_0$
  - 可以证明，如果 $R_0$ 满足条件，那么$R_0-1$ 也满足条件
    - 设 $R_0$ 求出的 $L_0$ 为 $L$，$R_0 - 1$ 求出的 $L$ 为 $L'$，那么 $v(L', R_0) \le v(L, R_0) < rv(R_0) < rv(R_0 - 1)$，$v(L',R_0)$ 和 $rv(R_0)$ 都小于 $rv(R_0 - 1)$，所以 $v(L', R_0 - 1)$ 小于 $rv(R_0 - 1)$
  - 所以可以直接二分 $R_0$

总时间复杂度为 $O(n \log^2 n)$。

## Code

[my submission on loj.ac](https://loj.ac/submission/791870)



---

## 作者：i207M (赞：11)

~~白送50分啊...~~ ~~woc，我自己做出了HNOID2T3！？怕是HNOI唯一一道我会的题~~

## 让我们~~乱搞~~吧！

BZOJ1367和这个很类似，也是求出B序列，但是代价为$\sum|A_i-B_i|$，是用可并堆找出区间中位数。和这道题的做法很类似。

首先观察，对于递增的A序列，B序列肯定也是按着A序列递增；对于递减的A序列，B序列肯定是同一个数，设为x，那么代价为$\sum (A_i-x)^2$，根据二次函数的知识可知，x应该取平均数。

那么对于更复杂的A序列的情况，类比BZOJ1367的做法：

从左往右扫描，对于新的一个数，先使它成为独立一段。然后不停的和前一段的平均数比较，如果变小了，就和前一段合并。

证明可以这样感性理解：当我们分的段数越多，那么对A序列“拟合”的越精确，答案也就越小。而上边就是在贪心地分最多的段。

好了，这样就有50分了，是不是美滋滋。

然后考虑修改，由于只修改一个数，那么很容易想到前缀后缀拼起来的做法。

------------

**以下是正解**

由于修改了一个地方的值，所以单调栈要改变，我们可能要将更多的段合并，这显然满足二分的性质。先二分左端点，再二分右端点，那么就需要写可持久化单调栈来查询，然后维护和以及平方和就可以计算答案了。

--------

**以下是~~乱搞~~待证明/Hack的解法**

我在做这道题时，并不想写高级数据结构，想离线水过去。我尝试单独二分一次左端点，**在此基础上**再二分一次右端点，但是这样是错的，因为右端点改变，可能会使平均数改变，进而左端点也需要改变。

我在做这道题时，感觉出题人数据不可能这么强，于是我就**来回交替二分左右端点30次**，然后它过了，它过了，它过了！

~~经过在LOJ上二分地提交，~~ 我发现只需要交替二分5次就可以过了。于是这份代码不需要任何数据结构，好写又快。

当然，我认为5次的确是数据水。但是，能否证明，这样交替的二分，在$O(\log n)$次后一定能得到最终的答案？

我尝试了一下，不会证明也不会证伪，请dalao们证明/Hack一下（要Hack交替二分30次的代码，底下是5次的，改一下main函数的循环次数即可）。如果是对的，那么~~就爽了~~。

~~不点个赞吗~~

```cpp
// 代码显得长是因为有4遍重复的代码
#define N 100005
int n;
int a[N];
LL sum[N];
int sumsq[N];
il int calc(int l,int r) // (l, r]
{
	int ans=sub(sumsq[r],sumsq[l]),t=mul((sum[r]-sum[l])%md,mdinv(r-l));
	inc(ans,mul(r-l,t,t));
	dec(ans,mul(2,(sum[r]-sum[l])%md,t));
	return ans;
}
il int calc(int l,int r,int p,int v) // a[p] = v
{
	int ans=add(sumsq[r],md-sumsq[l],md-mul(a[p],a[p]),mul(v,v)),t=mul((sum[r]-sum[l]-a[p]+v)%md,mdinv(r-l));
	inc(ans,mul(r-l,t,t));
	dec(ans,mul(2,(sum[r]-sum[l]-a[p]+v)%md,t));
	return ans;
}
int p[N],cnt;
int zp[N],fp[N];
vector<pair<pii,int> > qa[N],qb[N];
int ans[N];
void solvea()
{
	p[cnt=0]=0;
	for(ri i=1; i<=n; ++i)
	{
		// answer query
		for(solid it:qa[i])
		{
			int l=1,r=cnt,res=0; // save p[1...res]
			while(l<=r)
			{
				int mid=(l+r)>>1;
				if((sum[it.se-1]-a[i]+it.fi.fi-sum[p[mid]])*(p[mid]-p[mid-1])<(sum[p[mid]]-sum[p[mid-1]])*(it.se-1-p[mid]))
					r=mid-1;
				else l=mid+1,res=mid;
			}
			ans[it.fi.se]=add(zp[p[res]],fp[it.se]);
			inc(ans[it.fi.se],calc(p[res],it.se-1,i,it.fi.fi));
			qb[i].pb(mp(it.fi,p[res]));
		}
		qa[i].clear();
		// insert i
		p[++cnt]=i;
		while(cnt>1&&(sum[i]-sum[p[cnt-1]])*(p[cnt-1]-p[cnt-2])<(sum[p[cnt-1]]-sum[p[cnt-2]])*(i-p[cnt-1]))
			p[--cnt]=i;
	}
}
void solveb()
{
	p[cnt=0]=n+1;
	for(ri i=n; i>=1; --i)
	{
		// answer query
		for(solid it:qb[i])
		{
			int l=1,r=cnt,res=0; // save p[1...res]
			while(l<=r)
			{
				int mid=(l+r)>>1;
				if((sum[p[mid]-1]-a[i]+it.fi.fi-sum[it.se])*(p[mid-1]-p[mid])>(sum[p[mid-1]-1]-sum[p[mid]-1])*(p[mid]-1-it.se))
					r=mid-1;
				else l=mid+1,res=mid;
			}
			ans[it.fi.se]=add(zp[it.se],fp[p[res]]);
			inc(ans[it.fi.se],calc(it.se,p[res]-1,i,it.fi.fi));
			qa[i].pb(mp(it.fi,p[res]));
		}
		qb[i].clear();
		// insert i
		p[++cnt]=i;
		while(cnt>1&&(sum[p[cnt-1]-1]-sum[i-1])*(p[cnt-2]-p[cnt-1])>(sum[p[cnt-2]-1]-sum[p[cnt-1]-1])*(p[cnt-1]-i))
			p[--cnt]=i;
	}
}
int vp[N];
void psolvea()
{
	cnt=0;
	for(ri i=1; i<=n; ++i) sum[i]=sum[i-1]+a[i],sumsq[i]=add(sumsq[i-1],mul(a[i],a[i]));
	for(ri i=1; i<=n; ++i)
	{
		p[++cnt]=i,vp[cnt]=vp[cnt-1];
		while(cnt>1&&(sum[i]-sum[p[cnt-1]])*(p[cnt-1]-p[cnt-2])<(sum[p[cnt-1]]-sum[p[cnt-2]])*(i-p[cnt-1]))
			p[--cnt]=i,vp[cnt]=add(vp[cnt-1],calc(p[cnt-1],i));
		zp[i]=vp[cnt];
	}
	ans[0]=vp[cnt];
}
void psolveb()
{
	p[cnt=0]=n+1;
	for(ri i=n; i>=1; --i)
	{
		p[++cnt]=i,vp[cnt]=vp[cnt-1];
		while(cnt>1&&(sum[p[cnt-1]-1]-sum[i-1])*(p[cnt-2]-p[cnt-1])>(sum[p[cnt-2]-1]-sum[p[cnt-1]-1])*(p[cnt-1]-i))
			p[--cnt]=i,vp[cnt]=add(vp[cnt-1],calc(i-1,p[cnt-1]-1));
		fp[i]=vp[cnt];
	}
}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	int cq; in(n,cq);
	for(ri i=1; i<=n; ++i)  in(a[i]);
	for(ri i=1,pos,v; i<=cq; ++i)
	{
		in(pos,v);
		qa[pos].pb(mp(mp(v,i),i+1));
	}
	psolvea(),psolveb();
	for(ri i=1; i<=5; ++i) solvea(),solveb();
	for(ri i=0; i<=cq; ++i) out(ans[i]);
	return 0;
}
```


---

## 作者：TheLostWeak (赞：8)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5294.html)

**大致题意：** 给你一个长度为$n$的序列$A$，每次询问修改一个元素（只对当前询问有效），然后让你找到一个不下降序列$B$，使得这两个序列相应位置之差的平方和最小，并输出这个最小平方和。

### 如何预处理

首先，仔细观察样例解释，我们可以发现一个有趣的性质：**对于$B$序列中相同的一段元素，它们在$A$序列中恰好是这一段区间中所有数的平均数。**

因此，我们大胆猜测：我们可以把$A$序列划分成若干段，然后求出每段的平均值，就可以求出最后的$B$序列。

那么，现在我们要做的，就是如何划分的问题。

一个显然的结论，肯定是划分出越多的区间越优。

但我们如何判断是否可以划分一个区间呢？

这就可以通过**单调栈**维护，来预处理出答案了。

我们考虑枚举$i$，然后对于每个$i$，先将区间$[i,i]$扔入单调栈中。

然后，我们每次比较**栈顶区间的平均值**和**栈顶下面一个区间的平均值**，如果栈顶区间平均值较小，则不满足不下降性质，因此我们将这两个区间**合并**，然后继续与再下面一个区间比较。（注：其实等于也可以合并，不会影响平均值）

于是新问题来了，如何维护并合并区间信息？

设平均值$d=\frac{a_1+a_2+...+a_x}x$，则一个区间内的答案是：

$$(a_1-d)^2+(a_2-d)^2+...+(a_x-d)^2$$

然后公式展开得到：

$$a_1^2-2a_1d+d^2+a_2^2-2a_2d+d^2+...+a_x^2-2a_xd+d^2$$

用加法交换律和加法结合律改变一下顺序得到：

$$(a_1^2+a_2^2+...+a_x^2)-d(2a_1+2a_2+...+2a_x-xd)$$

将$d$的值代入得到：

$$(a_1^2+a_2^2+...+a_x^2)-\frac{a_1+a_2+...+a_x}x\cdot(2a_1+2a_2+...+2a_x-a_1-a_2-...-a_x)$$

$$(a_1^2+a_2^2+...+a_x^2)-\frac{(a_1+a_2+...+a_x)^2}x$$

所以，我们只需要维护**区间元素个数**、**区间元素和**、**区间元素平方和**三个值就能完成求解答案和合并啦。

具体实现详见代码。

### 如何完成询问

设修改的位置为$x,y$，则可以发现，对于前$x-1$个位置，它的单调栈操作过程必然与初始化时一样。

而加入第$x\sim n$个数之后，对于第$x-1$个单调栈，它大致可以表示成这个样子：

![](https://img2018.cnblogs.com/blog/1522397/201904/1522397-20190420094715047-220672405.jpg)

那么，我们只要找到$L,R$，并确定第$1\sim L-1,R+1\sim n$个元素的答案，就可以确定最终答案了。

先考虑我们要用到第$x-1$个单调栈，因此我们就可以用一个**主席树**来维护单调栈，并记录下每个位置此时的答案以及单调栈的大小，然后就能很方便的求出第$1\sim L-1$的答案了。

再考虑第$R+1\sim n$个元素的答案就很简单了，直接采取与上面预处理类似的方式，倒着做一遍单调栈，预处理出后缀的全部信息即可。

于是，现在仅剩的问题就是，如何找到$L,R$。

可以发现，这显然具有**可二分性**。

因此我们先二分一个右端点，然后对于这个右端点，我们再在主席树上二分求出其对应的左端点，并以此来验证这一段的平均值是否小于等于右端点的后一段的平均值即可。

注意对于栈中的元素我们肯定是整段整段取的，因为我们其实模拟了一个将元素加入栈的过程，而这一过程只会将某些段的元素合并，因此只能取整段。

具体实现详见代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define RL Reg LL
#define Con const
#define CI Con int&
#define CL Con LL&
#define I inline
#define W while
#define N 100000
#define Log 20
#define LL long long
#define X 998244353
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
#define Dec(x,y) ((x-=(y))<0&&(x+=X))
using namespace std;
int n,a[N+5],Inv[N+5],rt1[N+5],rt2[N+5],top1[N+5],top2[N+5],ans1[N+5],ans2[N+5];
I int XSum(CI x,CI y) {return x+y>=X?x+y-X:x+y;}
I int XSub(CI x,CI y) {return x<y?x-y+X:x-y;}
struct data
{
	int t,ps;LL s;I data(CI x=0,CL y=0,CI z=0):t(x),s(y),ps(z){}
	I data operator + (Con data& o) {return data(t+o.t,s+o.s,XSum(ps,o.ps));}
	I data operator - (Con data& o) {return data(t-o.t,s-o.s,XSub(ps,o.ps));}
	I bool operator < (Con data& o) Con {return o.t?(t?1.0*s/t<1.0*o.s/o.t:1):0;}
	I bool operator <= (Con data& o) Con {return t?(o.t?1.0*s/t<=1.0*o.s/o.t:0):1;}
	I int GV() {return XSub(ps,1LL*(s%X)*(s%X)%X*Inv[t]%X);}
}s[N+5],S[N+5];
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
		Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
		Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
		Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
		I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
class ChairmanTree//主席树维护单调栈
{
	private:
		#define L l,mid,O[rt].S[0]
		#define R mid+1,r,O[rt].S[1]
		#define PushUp(x)\
		(\
			O[x].l=O[O[x].S[0]].l,O[x].r=O[O[x].S[O[x].S[1]>0]].r,\
			O[x].k=O[O[x].S[0]].k\
		)//上传信息
		int tot;struct node {int l,r,k,S[2];}O[N*Log<<1];
	public:
		I void Update(CI l,CI r,int& rt,CI p,CI vl,CI vr)//修改单调栈中的值
		{
			if(O[++tot]=O[rt],rt=tot,l==r) return (void)(O[rt].l=vl,O[rt].r=O[rt].k=vr);
			RI mid=l+r>>1;p<=mid?Update(L,p,vl,vr):Update(R,p,vl,vr),PushUp(rt);
		}
		I int Query1(CI l,CI r,CI rt,CI p,data& v)//主席树上二分左端点，用v存储下取到的段的信息
		{
			if(r<=p)
			{
				data dl=s[O[rt].k]-s[O[rt].l-1],dr=s[O[rt].r]-s[O[rt].k];
				if(dr+v<=dl) return v=v+s[O[rt].r]-s[O[rt].l-1],0;
				if(l==r) return O[rt].r;
			}
			RI mid=l+r>>1,res;return p>mid&&(res=Query1(R,p,v))?res:Query1(L,p,v);
		}
		I int Query2(CI l,CI r,CI rt,CI p)//求出第p个位置右端点的值
		{
			if(l==r) return O[rt].r;RI mid=l+r>>1;
			return p<=mid?Query2(L,p):Query2(R,p);
		}
}C;
int main()
{
	RI Qtot,i,x,y,t,T,l,r,mid,p1,p2,ans=0;data v;
	for(F.read(n,Qtot),i=1;i<=n;++i) F.read(a[i]),s[i]=s[i-1]+data(1,a[i],1LL*a[i]*a[i]%X);//预处理信息前缀和
	for(Inv[1]=1,i=2;i<=n;++i) Inv[i]=1LL*Inv[X%i]*(X-X/i)%X;//预处理逆元
	for(T=0,i=1;i<=n;++i)//正着做一遍单调栈
	{
		S[++T]=data(1,a[i],1LL*a[i]*a[i]%X),rt1[i]=rt1[i-1];//加入栈
		W(T^1&&S[T]<=S[T-1]) S[T-1]=S[T-1]+S[T],--T;//对于栈顶不合法元素进行合并
		C.Update(1,n,rt1[i],top1[i]=T,i-S[T].t+1,i),ans1[i]=XSum(ans1[i-S[T].t],S[T].GV());//主席树上修改，记录下每个位置此时的答案以及单调栈的大小
	} 
	for(T=0,i=n;i;--i)//倒着做一遍单调栈，与上面类似
	{
		S[++T]=data(1,a[i],1LL*a[i]*a[i]%X),rt2[i]=rt2[i+1];
		W(T^1&&S[T-1]<=S[T]) S[T-1]=S[T-1]+S[T],--T;//注意比较顺序相反
		C.Update(1,n,rt2[i],top2[i]=T,i,i+S[T].t-1),ans2[i]=XSum(ans2[i+S[T].t],S[T].GV());
	}
	F.writeln(ans1[n]);W(Qtot--)//处理询问
	{
		F.read(x,y),t=a[x],a[x]=y,l=0,r=top2[x+1]-1;//读入，确定二分上下界
		#define Work(pos)\
			p2=(pos)?C.Query2(1,n,rt2[x+1],top2[x+1]-(pos)+1):x,\
			v=data(1,a[x],1LL*a[x]*a[x]%X)+s[p2]-s[x],\
			p1=x^1?C.Query1(1,n,rt1[x-1],top1[x-1],v):x
		W(l<=r) mid=l+r>>1,Work(mid),//二分
			v<s[C.Query2(1,n,rt2[x+1],top2[x+1]-mid)]-s[p2]?r=mid-1:l=mid+1;//验证
		Work(r+1),F.writeln(XSum(v.GV(),XSum(ans1[p1],ans2[p2+1]))),a[x]=t;//求解并输出答案
		//这里p1不用减1是因为它本来就是取左端点前一段的r值，而p2刚好是取这一段的r值因此要加1
	}return F.clear(),0;
}
```



---

## 作者：yllcm (赞：2)



无脑维护做法。

### 暴力 DP

先考虑一个暴力 DP：令 $f_{i,j}$ 表示考虑前 $i$ 个数，$b_i=j$ 的最小权值，转移实际上就是做这两件事情：

* 加贡献：$f_{i,j}\gets f_{i,j}+(a_i-j)^2$。
* 做前缀 $\min$：$f_{i,j}\gets \min(f_{i,j},f_{i-1,k})$。

时间复杂度 $\mathcal{O}(nV)$，$V$ 为值域，因为值域是实数所以 $V$ 可能巨大。

### 基于暴力的优化

一个经典的观察是这个转移的贡献是满足凸性的，所以我们可以尝试观察其差分数组。设 $g_{i,j}$ 表示 $f_{i,j+\Delta}-f_{i,j}$，可以发现 $g_{i,*}$ 始终是递增的。模仿上面的讨论过程，可以得到关于 $g$ 的转移方程：

* $g_{i,j}\gets g_{i,j}+2\Delta j-2\Delta a_i+\Delta^2$。
* $g_{i,j}\gets \min(0,g_{i,j})$。

我们默认 $\Delta$ 是一个极小的量，在此处 $\Delta^2$ 可以忽略。所以所有 $g_{i,j}$ 都可以表示成 $\Delta(kj+b)$ 的形式，而这是关于 $j$ 的一次函数。于是我们可以考虑维护 $g_{i,*}$ 所构成的折线，具体地，操作为：

* 全局加一次函数。
* 全局对直线 $y=0$ 取 $\min$。

由于 $g_{i,*}$ 是递增的，所以第二个操作必定作用域于一个后缀，我们只需要利用 vector 维护折线，然后不断删去末尾大于 $0$ 的直线即可。删除完成后，再在末尾加上一条直线 $y=0$。对于第一个操作，使用全局加标记 $ax+b$ 即可维护。由于每次只会增加一条直线，故暴力删除的复杂度正确。

维护差分数组之后，考虑如何求出最终的答案。首先，我们很容易得到 $f_{n,0}$ 的值，只需要模拟求出 $\sum a_i^2$ 即可。而 $f_{n,x}-f_{n,0}$ 为 $g_n$ 在 $[0,x]$ 区间的积分，所以求这些一次函数的积分即可。

至此我们得到了单次 $\mathcal{O}(n)$ 的做法，总时间复杂度 $\mathcal{O}(nm)$，可以得到 [50 分](https://loj.ac/s/1773642)。

### 进一步的观察

想要拓展到多次询问的做法，我们需要观察上述过程的本质。

观察最后仍然在 vector 里的折线，可以发现，它一定是直线集合 $S=\{y=kx+b|k=2(n-i+1),b=-2\sum_{j\geq i} a_j\}\cup\{y=0\}$ 的一个子集。因为我们的操作是全局加一次函数 $y=2x-2a_i$，而一条直线到最终状态之间所进行的操作为一个后缀的操作，因此不难说明以上观察。进一步地，结合对 $0$ 取 $\min$ 的操作，我们断言：最后的直线集合一定是 $S$ 集合的**凸壳**。归纳不难证明该结论。

因此我们对上述直线求凸壳即可得到另一个单次 $\mathcal{O}(n)$ 的做法。

### 拓展到多组询问

拓展到多组询问的关键在于：对于询问 $(x,y)$，如何求出删除 $x$ 处的直线，再加入新的直线之后，新的图像的积分。进一步地，问题几乎等价于要求我们维护前缀 $[1,i-1]$ 和后缀 $[i+1,n]$ 的所有直线的并构成的凸包的并。

首先，分别求出对于 $i\in[1,n]$，前缀 $[1,i]$ 的凸包和后缀 $[i,n]$ 的凸包是简单的，关键是如何将它们合并。考虑新的凸包的形态，我们断言，它一定是前缀 $[1,i-1]$ 的凸包的一个前缀和后缀 $[i+1,n]$ 的凸包的一个后缀构成。证明即考虑我们从前往后加入凸包的过程，保留到最后的显然是单调队列中的一个前缀，后者同理。所以我们只要找到这个前缀和后缀即可，下面讨论前缀。求解的方法是：对于后缀凸包进行二分，假设当前直线为 $mid$，我们模拟 $mid$ 和 $mid+1$ 插入的过程，如果 $mid$ 能够成功插入，那么它一定在最终的凸包里，而考虑能否插入只需要考虑 $mid$ 与凸包的交点横坐标 $x$ 和 $mid$ 与 $mid+1$ 的交点横坐标 $y$ 的大小关系即可，若 $x<y$，则说明可以成功插入。关于如何求出直线与凸包的交点，可以在凸包上二分得到，具体可以参考 [ZJOI2019]浙江省选 的方法。

此时我们得到了新的凸包。此时同样可以通过二分得到当前直线和凸包的交点。所以凸包被分成了三部分：前缀由 $[1,i-1]$ 直线构成的区间，后缀由 $[i+1,n]$ 直线构成的区间，直线 $i$ 的优势区间，利用前缀和和后缀和可以快速处理贡献。不过需要注意的是，由于直线和 $a$ 的后缀和相关，所以我们需要把 $[1,i-1]$ 的直线全局加一个值，这是不难处理的。

关于如何同时维护 $[1,i-1]$ 和 $[i+1,n]$ 的凸包形态，我们可以先从后往前求出所有 $[i+1,n]$ 的凸包形态，然后用支持撤回的结构进行维护，撤回的同时维护一个前缀凸包即可。

总时间复杂度 $\mathcal{O}(n+m\log^2 n)$。

### 代码

细节很多/tuu

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define pb push_back
#define mp make_pair
#define pii pair<int, int>
#define FR first
#define SE second
#define int long long
using namespace std;
inline int read() {
    int x = 0; bool op = 0;
    char c = getchar();
    while(!isdigit(c))op |= (c == '-'), c = getchar();
    while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return op ? -x : x;
}
const int N = 1e5 + 10;
const int P = 998244353;
const int Inv = 499122177;
const int INF = 1e9;
void add(int &a, int b) {a += b; a >= P ? a -= P : 0;}
void sub(int &a, int b) {a -= b; a < 0 ? a += P : 0;}
int ksm(int x, int k) {
    int res = 1;
    for(int pw = x; k; (k & 1) ? res = 1ll * res * pw % P : 0, pw = 1ll * pw * pw % P, k >>= 1);
    return res;
}
int n, m;
int a[N], suf[N];
struct Frac {
    int q, p;
    Frac() {}
    Frac(int _q, int _p):q(_q), p(_p) {
        if(p < 0)q = -q, p = -p;
        int g = __gcd(abs(q), p); q /= g; p /= g;
    }
    Frac(int x) {q = x; p = 1;}
    bool operator == (const Frac &tmp) const {return (q == tmp.q && p == tmp.q);}
    bool operator < (const Frac &tmp) const {return q * tmp.p < p * tmp.q;}
    bool operator <= (const Frac &tmp) const {return *this < tmp || *this == tmp;}
    int val() {return 1ll * (q % P + P) % P * ksm(p % P, P - 2) % P;}
    void debug() {printf("frc:%lld %lld\n", q, p);}
};
int ans[N];
vector<pii> q[N], cv1, cv2, d1[N];
vector<int> csum1, csum2, d2[N];
db crs(pii x, pii y) {return 1.0 * (x.SE - y.SE) / (y.FR - x.FR);}
Frac crsF(pii x, pii y) {return Frac(x.SE - y.SE, y.FR - x.FR);} 
int _calc2(pii x, int y) {return (1ll * (x.FR + P) % P * Inv % P * y % P * y % P + 1ll * (x.SE + P) % P * y % P) % P;}
int calc2(pii x, Frac l, Frac r) {
    l = max(l, Frac(0)); r = max(r, Frac(0));
    if(r < l)return 0;
    return _calc2(x, r.val()) - _calc2(x, l.val());
}
int find(pii x) {
    int lef = 0, rig = cv2.size();
    while(lef + 1 < rig) {
        int mid = lef + rig >> 1;
        if(crs(x, cv2[mid]) < crs(cv2[mid], cv2[mid - 1]))lef = mid;
        else rig = mid;
    }
    return lef;
}
pii operator + (const pii &x, const int &y) {return mp(x.FR, x.SE + y);}
int query(pii x, int dt) {
    int lef = 0, rig = cv1.size(), t1 = 0, t2 = 0;
    while(lef + 1 < rig) {
        int mid = lef + rig >> 1, pos = find(cv1[mid] + dt);
        if((crs(cv1[mid - 1] + dt, cv1[mid] + dt) < crs(cv1[mid] + dt, cv2[pos])))lef = mid;
        else rig = mid;
    }
    t1 = lef; t2 = min(find(x), (t1 < cv1.size() ? find(cv1[t1] + dt) : INF));
    lef = 0; rig = cv1.size();
    while(lef + 1 < rig) {
        int mid = lef + rig >> 1; 
        if(crs(cv1[mid - 1] + dt, cv1[mid] + dt) < crs(x, cv1[mid] + dt))lef = mid;
        else rig = mid;
    }
    t1 = min(t1, lef);
    Frac pos = max(t1 < cv1.size() ? crsF(cv1[t1] + dt, cv2[t2]) : Frac(-INF), crsF(x, cv2[t2])); // 右侧位置
    int res = (csum2[t2] - calc2(cv2[t2], Frac(0), pos) + P) % P; // 右侧贡献
    if(t1 < cv1.size()) {    
        pos = min(crsF(cv1[t1] + dt, cv2[t2]), crsF(x, cv1[t1] + dt)); // 左侧位置
        add(res, (t1 > 0 ? csum1[t1 - 1] : 0));
        add(res, calc2(cv1[t1], (t1 > 0 ? crsF(cv1[t1 - 1], cv1[t1]) : Frac(0)), pos)); // 左侧贡献
        if(Frac(0) <= pos)add(res, 1ll * pos.val() * dt % P);
    }
    add(res, calc2(x, (t1 < cv1.size() ? crsF(x, cv1[t1] + dt) : Frac(0)), crsF(x, cv2[t2]))); // 中间贡献
    return res;
}
signed main() { 
    n = read(); m = read();
    int sum = 0;
    for(int i = 1; i <= n; i++)a[i] = read(), add(sum, 1ll * a[i] * a[i] % P);
    for(int i = n; i; i--)suf[i] = suf[i + 1] + a[i];
    for(int i = 1; i <= m; i++) {
        int x = read(), y = read();
        q[x].pb(mp(i, y));
    }
    cv2.pb(mp(0, 0)); csum2.pb(0);
    for(int i = n; i; i--) {
        pii now(2 * (n - i + 1), -2 * suf[i]);
        while(cv2.size() > 1 && crs(*cv2.rbegin(), *(++cv2.rbegin())) < crs(now, *cv2.rbegin())) {
            d1[i].pb(*cv2.rbegin()); d2[i].pb(*csum2.rbegin());
            cv2.pop_back(); csum2.pop_back();
        }
        Frac ed = crsF(now, *cv2.rbegin());
        int w = (calc2(now, Frac(0), ed) - calc2(*cv2.rbegin(), Frac(0), ed) + P) % P;
        csum2.pb((csum2.back() + w) % P); cv2.pb(now);
    }
    printf("%lld\n", (sum + csum2.back()) % P);
    for(int i = 1; i <= n; i++) {
        csum2.pop_back(); cv2.pop_back();
        while(d1[i].size())cv2.pb(d1[i].back()), d1[i].pop_back(); 
        while(d2[i].size())csum2.pb(d2[i].back()), d2[i].pop_back();
        for(auto t : q[i]) {
            int w = query(mp(2 * (n - i + 1), -2 * (t.SE + suf[i + 1])), -2 * (t.SE - a[i]));
            ans[t.FR] = ((w - 1ll * a[i] * a[i] % P + 1ll * t.SE * t.SE % P) % P + P) % P;
        }
        pii now(2 * (n - i + 1), -2 * suf[i]);
        while(cv1.size() > 1 && crs(now, *cv1.rbegin()) < crs(*cv1.rbegin(), *(++cv1.rbegin()))) {
            cv1.pop_back(); csum1.pop_back();
        }
        if(cv1.size()) {
            Frac l = (cv1.size() > 1 ? crsF(*cv1.rbegin(), *(++cv1.rbegin())) : Frac(0));
            Frac r = crsF(now, *cv1.rbegin());
            int lst = csum1.size() ? csum1.back() : 0;
            csum1.pb(lst + calc2(cv1.back(), l, r));
        }
        cv1.pb(now);
    }
    for(int i = 1; i <= m; i++)printf("%lld\n", (sum + ans[i]) % P);
    return 0;
}
```



---

## 作者：Nemlit (赞：1)

首先考虑 $50pts$，我们可以直接上保序回归，也就是整体二分之后，枚举 $mid$ 与 $mid+1$ 的分界点，然后找出最大值即可。也有一个更直接的方法：

类似于 $P4331$，考虑最后的序列一定是可以分成若干段区间，使得区间内所有数相等，且这段区间的所有数为本身这段区间的平均数。

考虑 $\sum_{i}(A_i-x)^2$，我们需要支持快速合并。不难得出其为 $\sum_{i=l}^rA_i^2-\dfrac{(\sum_{i=l}^rA_i)^2}{r-l+1}$，那么只需要维护区间平方和，区间和，区间长度即可快速合并两端区间。然后维护一个单调栈，每次新家一个元素，如果可以比单调栈栈顶的元素值小，那么必须不断合并，否则的话新开一个元素，我们可以 $O(N)$ 处理每一个询问。

考虑到每次询问是独立的，考虑最终的答案一定是存在一个 $[L, R]$，使得区间 $[L, R]$ 的的平均数为 $x$，然后 $[1, L-1], [R+1, N]$ 还是原来的情况。

考虑用主席树处理出每一个前缀对应的单调栈以及每一个后缀对应的单调栈。先假设每次修改是给 $x$ 进行单点加操作。那么此时 $[1, x]$ 的单调栈仍然合法，且 $[x+1,n]$ 的单调栈仍然合法。如果是单点减操作，那么 $[1, x-1]$ 的单调栈仍然合法，且 $[x,n]$ 的单调栈仍然合法。

考虑给定两个单调栈如何计算答案，如果第一个单调栈的最大值小于第二个单调栈的最小值，那么我们已经可以计算出答案了。现在的问题是第一个单调栈最后一个元素可能大于第二个单调栈第一个元素。这个时候我们就需要将其合并。考虑原来的暴力，不难证明只保留单调栈的元素做暴力仍然是正确的。

设 $v[L, R]$ 表示**单调栈**上 $L, R$ 的加权平均数，$v[x]$ 表示 **单调栈**上 $x$ 的权值。

那么我们需要合并两个单调栈，就需要找到一个 $[L, R]$，满足 $v[L-1]<v[L, R]<v[R]$。

假设将 $R$ 固定了，考虑找到一个 $L$，满足 $v[L-1]<v[L, R]$ 怎么做。假设 $L$ 是合法的，即满足 $v[L]<v[L+1, R]$，又因为在单调栈上 $v[L-1]<v[L]$，所以 $v[L-1]<v[L, R]$，所以 $L$ 存在单调性。同理 $R$ 也存在单调性。

由于这是单调栈，注意到 $L$ 在满足 $v[L-1]<v[L, R]$ 时，$L$ 越大 $v[L, R]$ 越大，所以我们需要二分找到最大的合法的 $L$，才能使得 $v[L, R]$ 最大。对于一个 $R$，找到了以它为右端点最大的 $L$ 之后，只需要判断 $\max(v[L, R])$ 与 $v[R + 1]$ 的大小关系即可。

复杂度 $O(nlog^2n)$。

---


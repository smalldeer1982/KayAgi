# [BJOI2019] 送别

## 题目描述

法珞是个怕黑的女孩子。

傍晚了，法珞所参加的学术会议早已散会。黎瑟也下了课过来接法珞回火车站。

但是教学楼里突然断电了，法珞陷入了一片漆黑之中。

好在黎瑟已经到了教学楼的同一层。

然而由于教学楼的结构过于复杂，她们已经记不起教学楼的具体结构了。
黎瑟学校的教学楼每层的结构都非常工整。

形式化地说，教学楼的一层的平面结构可以画在二维平面上以 $(0,0)$ 为左上角顶点，$(n,m)$ 为右下角顶点的子矩形（记为 $(0,0) - (n,m)$  的矩形）里，这个子矩形的四条边是教学楼的楼体(或者说是四段已知一定存在的墙)。

**请注意，本题中的坐标系和普通的平面直角坐标系不同，$(0,0)$ 是左上角的顶点而 $(n,m)$ 是右下角的顶点。 $(i,j)$ 表示的是第 $i+1$ 行第 $j+1$ 列的顶点而不是横坐标为 $i$ 纵坐标为 $j$ 的顶点。**

每一段墙（无法通过的部分）是一条端点为 $(i,j)$ 和 $(i',j')$ 的线段，记作 $(i,j) - (i',j')$ 的墙，其中 $|i-i'| + |j-j'| =1$ 且 $i,i'$ 是 $[0,n]$ 中的整数， $j,j'$ 是 $[0,m]$ 中的整数（每当我们之后使用 $(i,j) - (i',j')$ 的记法，我们都保证满足上述所有条件）。

法珞知道，对于这种结构，有一种办法可能让她找到黎瑟：法珞用左手扶住墙，手臂和墙面垂直，保持这个状态向前方走，在转弯处也保持左手一直扶墙的状态。按照这个方法她就可以环绕一周，可能与黎瑟相遇。

![](https://cdn.luogu.com.cn/upload/pic/57058.png)

上图是样例输入中第一次询问的法珞的行走方案，在行走过程中法珞的左手必须贴住墙。

法珞一开始会给你需要维护的初始的(这层楼的)结构，之后会给你 $q$ 个请求。

+ 操作 1 ： 读入格式形如 $1 \ x_0 \ y_0 \ x_1 \ y_1$：法珞请求在当前结构里添加一段 $(x_0,y_0) - (x_1,y_1)$ 的墙，保证此前这段墙不存在且这段墙不在 $(0,0) - (n,m)$ 的子矩形的四条边上。

+ 操作2： 读入格式形如 $2 \ x_0 \ y_0 \ x_1 \ y_1$：法珞请求在当前结构里删除一段 $(x_0,y_0) - (x_1,y_1)$ 的墙，保证此前这段墙存在且这段墙不在 $(0,0) - (n,m)$ 的子矩形的四条边上。

+ 操作3： 读入格式形如 $3\ x_0 \ y_0 \ x_1\ y_1\ d_0 \ x_2 \ y_2 \ x_3 \ y_3 \ d_1$ ：法珞当前在 $(x_0,y_0) - (x_1,y_1)$ 的墙的中点位置 $(\frac{x0+x1}{2},\frac{y_0 + y_1}{2})$ ， $d_0$ 是一个 $[0,1]$ 中的整数，用来描述法珞在墙的哪一侧， $d_0  = 0$ 代表法珞在墙的左方/上方， $d_0 = 1$ 代表右方/下方。黎瑟当前在 $(x_2,y_2) - (x_3,y_3)$ 的墙的中点位置  $(\frac{x2+x3}{2},\frac{y_2+y_3}{2})$ 。 $d_1$ 的格式和 $d_0$ 相同。保证 $(x_0,y_0) - (x_1,y_1)$ 和 $(x_2,y_2) - (x_3,y_3)$ 这两段墙存在，且法珞和黎瑟的位置都落在 $(0,0) - (n,m)$ 的子矩形的内部。求法珞按照题目所述的方法找到黎瑟要走过多少长度（ $(i,j) - (i',j')$  这段墙的长度为 $1$，半段墙（由于起点和终点都在墙的中点处）的长度是  $\frac{1}{2}$ ）。



## 说明/提示

对于 10% 的数据， $5 \le n,m \le 50$ ， $1 \le q \le  2000$ 。

对于另外 30% 的数据，没有 1 操作。

对于另外 30% 的数据，保证在任意时刻若法珞和黎瑟站在任意输入格式中合法的位置，法珞都可以和黎瑟相遇。

对于100%的数据，$5 \le n,m \le 500$ ， $1 \le q \le 2 \times 10^5$ 。

## 样例 #1

### 输入

```
3 3 4
0 0
1 0
0 0
1 0 1
0 0 1
3 3 0 3 1 0 0 3 1 3 0
1 2 1 2 0
2 1 0 1 1
3 2 2 2 3 1 1 2 1 3 0```

### 输出

```
11
16```

# 题解

## 作者：Great_Influence (赞：14)

平衡树裸题。

首先，我们将一条边拆成两条边:上和下(或者左和右)，然后分别都标上号。

![](https://cdn.luogu.com.cn/upload/pic/57321.png)

然后，我们强制规定用左手摸着的前进方向为这条边的方向。对于一个闭合环的内圈，这个方向为顺时针，而对于外圈则是逆时针。

可以借助示意图来辅助理解。

![](https://cdn.luogu.com.cn/upload/pic/57322.png)

因为我们没有什么东西能够很好地直接维护整个环，因此我们考虑拆掉环上的某条边。注意因为我们要求的是两条边之间的距离，因此我们给每条边建一个点，而原来的点不予维护。这里拆掉的边指的是边与边相交的边界。

![](https://cdn.luogu.com.cn/upload/pic/57323.png)

可以发现，环上任意两相邻边代表点中间的边都可以拆掉。而具体拆掉的边我们可以快速更换，只需要将平衡树分裂成两部分，交换后重新合并即可。

![](https://cdn.luogu.com.cn/upload/pic/57325.png)

代码:

```cpp
inline void Cgbk(int u)
{
    int rk=order_of_key(u);//查询rank
    while(fa[u])u=fa[u];//找到根
    if(rk==sz[u])return;
    Pr y=split(u,rk);
    merge(y.second,y.first);
}
```

然后，按照复杂程度开始讨论三个操作。

## 1.询问

我们可以将询问的边转成点，然后直接在平衡树上查询。

如果这两个点属于同一棵平衡树，那么输出终点在平衡树上前面有多少个点减去起点前面有多少个点。因为拆的边可能会被经过，因此答案为负数时需要加上整棵平衡树的大小。

否则直接输出 $-1$ 。

代码:

```cpp
read(x0),read(y0),read(x1),read(y1),read(d0);
read(x2),read(y2),read(x3),read(y3),read(d1);
if(x0+y0>x1+y1)swap(x0,x1),swap(y0,y1);
if(x2+y2>x3+y3)swap(x2,x3),swap(y2,y3);//先处理输入
int u=getid(x0<x1,x0,y0,d0),v=getid(x2<x3,x2,y2,d1);
if(getrt(u)^getrt(v)){write(-1);continue;}//无解
int z=order_of_key(v)-order_of_key(u);
if(z<0)z+=leafy_tree::sz[getrt(u)];
write(z);
```

## 2.删除

我们先查询删掉的边的两个半边是否在同一个环上。如果在，则删掉这条边只有可能将环分成两个(或者不变或者直接消失，但是可以一起考虑)。

我们删掉后，平衡树序列会变成两部分，这两部分在环上都是连续的。

因此，我们将删去边的其中一条更换到环的最后面，然后将平衡树在另一条的位置分裂成两部分。最后，我们将应该删去的两条半边删去即可。

![](https://cdn.luogu.com.cn/upload/pic/57332.png)

如图。此次删掉的边为 $6-13$ 这条边。

否则如果不在一个环上的话，本次删除肯定会将这两个环合并成一个。

因此，我们将删去的两个半边都调整到环的最后面，删掉这两个半边后直接将环首位相接即可。

![](https://cdn.luogu.com.cn/upload/pic/57327.png)

如图，此次删掉的边为 $2-8$ 这条边。

代码:

```cpp
read(x0),read(y0),read(x1),read(y1);
if(x0+y0>x1+y1)swap(x0,x1),swap(y0,y1);//处理输入
hs[x0<x1][x0][y0]=0;//记得给每条存在的边打标记，在插入的时候要用
int u=getid(x0<x1,x0,y0,0),v=u+1;
if(getrt(u)==getrt(v))//在同一个环上
{
	Cgbk(v);
	int rt=split(getrt(u),order_of_key(u)-1).second;
	rt=split(rt,1).second;
	split(rt,leafy_tree::sz[rt]-1);
}
else//不在
{
	Cgbk(u),Cgbk(v);
	u=split(getrt(u),leafy_tree::sz[getrt(u)]-1).first,
	v=split(getrt(v),leafy_tree::sz[getrt(v)]-1).first;
	merge(u,v);
}
```

## 3.插入

最恶心的操作。

我们考虑先求出来这样的两条边 $ubl$ 和 $dbl$ ，分别表示两个半边插入后在环上的前一条边。

![](https://cdn.luogu.com.cn/upload/pic/57338.png)

如果两边都没有边的话，我们直接将两个半边首位相接。

(这就不附图了)

否则如果只有一边存在边，则直接将两个半边首位相接插入到那一边所在平衡树中。

![](https://cdn.luogu.com.cn/upload/pic/57333.png)



否则我们查询 $ubl$ 和 $dbl$ 是否在同一个环中。如果在的话，则这次插入会将原来的环拆成两个环。我们调整 $ubl$ 使它到这个环的最后面，然后将环在 $dbl$ 的位置拆成两个部分，并在这两个部分的最后面分别插入两个半边。注意不能乱插。

否则不在的话，这次插入会将两个环合并。我们调整 $ubl$ 和 $dbl$ 变成环上最后一条边，分别接上两个半边后首位相接。注意半边的顺序。

(最后两种情况可以直接看删边的图，倒过来就可以了)

代码:

```cpp
inline void insert(int x0,int y0,int x1,int y1)
{
    int ubl=-1,dbl=-1;
    if(x0<x1)//先分情况找出ubl和dbl
    {
        if(y0&&hs[0][x0][y0-1])ubl=getid(0,x0,y0-1,1);
        else if(x0&&hs[1][x0-1][y0])ubl=getid(1,x0-1,y0,0);
        else if(hs[0][x0][y0])ubl=getid(0,x0,y0,0);

        if(hs[0][x1][y1])dbl=getid(0,x1,y1,0);
        else if(hs[1][x1][y1])dbl=getid(1,x1,y1,1);
        else if(y1&&hs[0][x1][y1-1])dbl=getid(0,x1,y1-1,1);
    }
    else
    {
        if(hs[1][x0][y0])ubl=getid(1,x0,y0,1);
        else if(y0&&hs[0][x0][y0-1])ubl=getid(0,x0,y0-1,1);
        else if(x0&&hs[1][x0-1][y0])ubl=getid(1,x0-1,y0,0);

        if(x0&&hs[1][x1-1][y1])dbl=getid(1,x1-1,y1,0);
        else if(hs[0][x1][y1])dbl=getid(0,x1,y1,0);
        else if(hs[1][x1][y1])dbl=getid(1,x1,y1,1);
    }
    if(~ubl&&~dbl)
    {
        if(getrt(ubl)==getrt(dbl))//在同一个环上的时候
        {
            Cgbk(ubl);
            Pr z=split(getrt(ubl),order_of_key(dbl));
            merge(z.second,getid(x0<x1,x0,y0,y0<y1));
            merge(z.first,getid(x0<x1,x0,y0,x0<x1));
        }
        else//不在同一个环上
        {
            Cgbk(ubl),Cgbk(dbl);
            merge(getrt(ubl),getid(x0<x1,x0,y0,y0<y1));
            merge(getrt(dbl),getid(x0<x1,x0,y0,x0<x1));
            merge(getrt(ubl),getrt(dbl));
        }
    }
    else
    {
        if(~ubl)Cgbk(ubl),merge(getrt(ubl)//只有一边有环
                ,merge(getid(x0<x1,x0,y0,y0<y1)
                    ,getid(x0<x1,x0,y0,x0<x1)));
        else if(~dbl)Cgbk(dbl),merge(getrt(dbl)
                ,merge(getid(x0<x1,x0,y0,x0<x1)
                    ,getid(x0<x1,x0,y0,y0<y1)));
        else merge(getid(x0<x1,x0,y0,0),getid(x0<x1,x0,y0,1));//两边都没有
    }
    hs[x0<x1][x0][y0]=1;//标记这条边出现过
}
```

因为平衡树需要实现分裂合并，因此只能使用带有区间分裂能力的平衡树(如 $splay,FHQ,$leafy_tree) 。我这里写的是 leafy_tree 。

总代码:

```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<iostream>
#include<climits>
#define y1 djksaflsdajnfdsaknfkcjhdcfyduifbhrelfkcnrfr
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
		if(nowps-Out>=1<<23)flush();
	}

	inline void getstr(char*q)
	{
		register char ch;
		for(ch=getc();!isgraph(ch);ch=getc());
		for(;isgraph(ch);ch=getc())*q++=ch;
		*q='\0';
	}

	inline void getwd(char&x){for(x=getc();!isupper(x);x=getc());}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void Chkmax(double&u,double v){u<v?u=v:0;}

inline void Chkmax(ll&u,ll v){u<v?u=v:0;}

inline void Chkmin(ll&u,ll v){u>v?u=v:0;}

static int n,m,Q;

inline void init(){read(n),read(m),read(Q);}

const int MAXN=501,NODE=2e6+5e3;

inline int getid(int dr,int i,int j,int bk)
{
	if(!dr)return 2*(i*m+j+1)+bk-1;
	else return 2*(n+1)*m+2*(i*(m+1)+j+1)+bk-1;
}

static int lm;

typedef pair<int,int>Pr;

namespace leafy_tree
{
	const double alp=1-sqrt(2)/2;

	static int sz[NODE],son[NODE][2],fa[NODE];

	namespace Memery_Manage
	{
		static int sta[NODE],tp,cr;

		inline int newnode(){return !tp?++cr:sta[tp--];}

		inline void del(int u)
		{
			fa[son[u][0]]=fa[son[u][1]]=0;
			fa[u]=son[u][0]=son[u][1]=sz[u]=0;
			assert(u>lm);
			sta[++tp]=u;
		}
	}
	using Memery_Manage::newnode;
	using Memery_Manage::del;

	int build_tree(int*a,int l,int r)
	{
		if(l==r)return a[l];
		int md=(l+r)>>1,cr=newnode();sz[cr]=r-l+1;
		fa[son[cr][0]=build_tree(a,l,md)]
			=fa[son[cr][1]=build_tree(a,md+1,r)]=cr;
		return cr;
	}

	int merge(int u,int v)
	{
		if(!u||!v)return u|v;
		if(sz[u]>=sz[v]*alp&&sz[v]>=sz[u]*alp)
		{
			int cr=newnode();sz[cr]=sz[u]+sz[v];
			fa[son[cr][0]=u]=fa[son[cr][1]=v]=cr;
			return cr;
		}
		if(sz[u]>sz[v])
		{
			int ls=son[u][0],rs=son[u][1];del(u);
			if(sz[ls]>=alp*(sz[ls]+sz[rs]+sz[v]))return merge(ls,merge(rs,v));
			else
			{
				int lls=son[rs][0],rrs=son[rs][1];del(rs);
				return merge(merge(ls,lls),merge(rrs,v));
			}
		}
		else
		{
			int ls=son[v][0],rs=son[v][1];del(v);
			if(sz[rs]>=alp*(sz[u]+sz[ls]+sz[rs]))return merge(merge(u,ls),rs);
			else
			{
				int lls=son[ls][0],rrs=son[ls][1];del(ls);
				return merge(merge(u,lls),merge(rrs,rs));
			}
		}
	}

	Pr split(int u,int k)
	{
		if(!u||!k)return mp(0,u);
		if(k==sz[u])return mp(u,0);
		int ls=son[u][0],rs=son[u][1];del(u);
		if(sz[ls]>=k)
		{
			Pr y=split(ls,k);
			return mp(y.first,merge(y.second,rs));
		}
		else
		{
			Pr y=split(rs,k-sz[ls]);
			return mp(merge(ls,y.first),y.second);
		}
	}

	inline int order_of_key(int u)
	{
		register int sm=1;
		for(;fa[u];u=fa[u])if(u==son[fa[u]][1])
			sm+=sz[son[fa[u]][0]];
		return sm;
	}

	inline int getrt(int u){while(fa[u])u=fa[u];return u;}

	inline int Cgbk(int u)
	{
		int rk=order_of_key(u);
		while(fa[u])u=fa[u];
		if(rk==sz[u])return u;
		Pr y=split(u,rk);
		return merge(y.second,y.first);
	}

	void dfout(int u)
	{
		if(son[u][0])dfout(son[u][0]),dfout(son[u][1]);
		else cerr<<u<<' ';
	}
}
using leafy_tree::build_tree;
using leafy_tree::merge;
using leafy_tree::split;
using leafy_tree::order_of_key;
using leafy_tree::getrt;
using leafy_tree::Cgbk;
using leafy_tree::dfout;

static int hs[2][MAXN][MAXN];

inline void insert(int x0,int y0,int x1,int y1)
{
	int ubl=-1,dbl=-1;
	if(x0<x1)
	{
		if(y0&&hs[0][x0][y0-1])ubl=getid(0,x0,y0-1,1);
		else if(x0&&hs[1][x0-1][y0])ubl=getid(1,x0-1,y0,0);
		else if(hs[0][x0][y0])ubl=getid(0,x0,y0,0);

		if(hs[0][x1][y1])dbl=getid(0,x1,y1,0);
		else if(hs[1][x1][y1])dbl=getid(1,x1,y1,1);
		else if(y1&&hs[0][x1][y1-1])dbl=getid(0,x1,y1-1,1);
	}
	else
	{
		if(hs[1][x0][y0])ubl=getid(1,x0,y0,1);
		else if(y0&&hs[0][x0][y0-1])ubl=getid(0,x0,y0-1,1);
		else if(x0&&hs[1][x0-1][y0])ubl=getid(1,x0-1,y0,0);

		if(x0&&hs[1][x1-1][y1])dbl=getid(1,x1-1,y1,0);
		else if(hs[0][x1][y1])dbl=getid(0,x1,y1,0);
		else if(hs[1][x1][y1])dbl=getid(1,x1,y1,1);
	}
	if(~ubl&&~dbl)
	{
		if(getrt(ubl)==getrt(dbl))
		{
			Cgbk(ubl);
			Pr z=split(getrt(ubl),order_of_key(dbl));
			merge(z.second,getid(x0<x1,x0,y0,y0<y1));
			merge(z.first,getid(x0<x1,x0,y0,x0<x1));
		}
		else
		{
			Cgbk(ubl),Cgbk(dbl);
			merge(getrt(ubl),getid(x0<x1,x0,y0,y0<y1));
			merge(getrt(dbl),getid(x0<x1,x0,y0,x0<x1));
			merge(getrt(ubl),getrt(dbl));
		}
	}
	else
	{
		if(~ubl)Cgbk(ubl),merge(getrt(ubl)
				,merge(getid(x0<x1,x0,y0,y0<y1)
					,getid(x0<x1,x0,y0,x0<x1)));
		else if(~dbl)Cgbk(dbl),merge(getrt(dbl)
				,merge(getid(x0<x1,x0,y0,x0<x1)
					,getid(x0<x1,x0,y0,y0<y1)));
		else merge(getid(x0<x1,x0,y0,0),getid(x0<x1,x0,y0,1));
	}
	hs[x0<x1][x0][y0]=1;
}

static int a[NODE],z;

inline void solve()
{
	leafy_tree::Memery_Manage::cr=lm=2*(n*(m+1)+m*(n+1));
	Rep(i,1,lm)leafy_tree::sz[i]=1;
	Rep(i,0,m-1)a[++z]=getid(0,0,i,1),hs[0][0][i]=hs[0][n][i]=1;
	Rep(i,0,n-1)a[++z]=getid(1,i,m,0),hs[1][i][0]=hs[1][i][m]=1;
	Repe(i,m-1,0)a[++z]=getid(0,n,i,0);
	Repe(i,n-1,0)a[++z]=getid(1,i,0,1);
	build_tree(a,1,z),z=0;
	Repe(i,m-1,0)a[++z]=getid(0,0,i,0);
	Rep(i,0,n-1)a[++z]=getid(1,i,0,0);
	Repe(i,0,m-1)a[++z]=getid(0,n,i,1);
	Repe(i,n-1,0)a[++z]=getid(1,i,m,1);
	build_tree(a,1,z);
	static int op,x0,y0,x1,y1,x2,y2,x3,y3,d0,d1;
	Rep(i,1,n)Rep(j,1,m-1)
	{
		read(op);
		if(op)insert(i-1,j,i,j);
	}
	Rep(i,1,n-1)Rep(j,1,m)
	{
		read(op);
		if(op)insert(i,j-1,i,j);
	}
	while(Q--)
	{
		read(op);
		if(op==3)
		{
			read(x0),read(y0),read(x1),read(y1),read(d0);
			read(x2),read(y2),read(x3),read(y3),read(d1);
			if(x0+y0>x1+y1)swap(x0,x1),swap(y0,y1);
			if(x2+y2>x3+y3)swap(x2,x3),swap(y2,y3);
			int u=getid(x0<x1,x0,y0,d0),v=getid(x2<x3,x2,y2,d1);
			if(getrt(u)^getrt(v)){write(-1);continue;}
			int z=order_of_key(v)-order_of_key(u);
			if(z<0)z+=leafy_tree::sz[getrt(u)];
			write(z);
		}
		else
		{
			read(x0),read(y0),read(x1),read(y1);
			if(x0+y0>x1+y1)swap(x0,x1),swap(y0,y1);
			if(op==1)insert(x0,y0,x1,y1);
			else
			{
				hs[x0<x1][x0][y0]=0;
				int u=getid(x0<x1,x0,y0,0),v=u+1;
				if(getrt(u)==getrt(v))
				{
					Cgbk(v);
					int rt=split(getrt(u),order_of_key(u)-1).second;
					rt=split(rt,1).second;
					split(rt,leafy_tree::sz[rt]-1);
				}
				else
				{
					Cgbk(u),Cgbk(v);
					u=split(getrt(u),leafy_tree::sz[getrt(u)]-1).first,
					v=split(getrt(v),leafy_tree::sz[getrt(v)]-1).first;
					merge(u,v);
				}
			}
		}
	}
	flush();
}

int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---

## 作者：hychyc (赞：8)

## BJOI 2019 D1T3 送别 Sol

考场爆肝 $3.5h$ 过掉大样例出分爆 $30$ 选手来写个题解

这题的思路还是挺直观的，题面的提示也比较明显。大概心路历程就是：这个插入/删除墙怎么一次只处理一个啊...为啥不一次搞一串墙...难不成复杂度和墙的个数有关...诶好像每个墙建两个点就没了啊

我们为每个墙建立两个点，分别代表横着墙的上下和竖着墙的左右两侧。注意题目中走的路一定是由若干个环组成，考虑直接维护这些环。把每个环从随便一个地方拆开，用平衡树维护序列。插入删除就是若干环的并/分离，查询就直接在平衡树上查 $rank$ 就行了

实现细节可能各不相同， $std$ 写了可持久化平衡树，我直接写了平衡树，写法上可以各位自己推明白自己的写法，在此处我简述一下我实现的内容。

对每个点求出其前驱后继，这个可以直接大力讨论（详见代码中的 $pre$ 和 $nxt$ 函数）

在插入时要讨论两种情况，一种情况是这个新边把原本的某个环隔断了（比如一个“口”变成了一个“日”），这种情况对应我代码中的 $Same\_cyc$ ，要提取出原本环中被断开的部分；另一种情况则是从环上接一段（比如从 “|” 变成了 “|-”），这种情况则需要将原本的环断开的部分转到当前这条边处，这样就可以直接接上了。

删除则比较容易，直接断开他和他的前驱及后继，然后判一下是否此时前后两段还联通（因为头的前驱可能是尾），如果联通就拼起来。之后让他的前驱和后继各自找到自己的前驱后继即可。

可能说的不太清楚，看代码吧...要是我哪里写的比较令人困惑可以评论一下或者给我发私信都行qwq

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define il inline
#define ri register int
#define mp make_pair
#define pb push_back
#define mid ((l+r)>>1)
#define MAXN 1050
#define MAXM 3000050
#define mod
#define inf (INT_MAX)
#define rep(i, x, y) for(ri i = (x); i <= (y); ++i)
#define repd(i, x, y) for(ri i = (x); i >= (y); --i)
#define alpha 0.75
#define eps 1e-7
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
template <typename T> il bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}
template <typename T> il bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}
template <typename T> il void read(T &x) {
    char ch = getchar(); int f = 1; x = 0;
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
    x *= f;
}
int n, m, q;
int ver[MAXN<<1][MAXN<<1][2];
int xx[MAXM], yy[MAXM], kk[MAXM];
il int pre(int u);
il int nxt(int u);
void info(int u, const char* s);
struct Treap {
    int size[MAXM], ch[MAXM][2], fa[MAXM], tcnt, kick[MAXM];
    il int rnd() {
        static int x = 19260817;
        return x = (x * 48271ll) & INT_MAX;
    }
    il int newnode() {
        int u = ++tcnt;
        return update(u), u;
    }
    il void update(int u) {
        size[u] = size[ch[u][0]] + size[ch[u][1]] + 1;
    }
    il int merge(int x, int y) {
        if(!x || !y) return x ^ y;
        int t;
        if(rnd() % (size[x] + size[y]) < size[x]) 
            ch[t=x][1] = merge(ch[x][1], y), fa[ch[x][1]] = x;
        else ch[t=y][0] = merge(x, ch[y][0]), fa[ch[y][0]] = y;
        return update(t), t;
    }
    il void split(int u, int k, int &x, int &y) {
        if(!u) x = y = 0;
        else {
            if(k <= size[ch[u][0]]) split(ch[u][0], k, x, ch[u][0]), fa[x] = 0, y = fa[ch[u][0]] = u;
            else split(ch[u][1], k-size[ch[u][0]]-1, ch[u][1], y), fa[y] = 0, x = fa[ch[u][1]] = u;
            update(u);
        }
    }
    il int find(int u) {
        while(fa[u]) u = fa[u];
        return u;
    }
    il int rnk(int u) {
        int ret = size[ch[u][0]] + 1;
        while(fa[u]) ret += (u == ch[fa[u]][1]) * (size[ch[fa[u]][0]] + 1), u = fa[u];
        return ret;
    }
    void prt(int u) {
        if(!u) return ;
        prt(ch[u][0]), cout << xx[u] << ' ' << yy[u] << ' ' << kk[u] << endl, prt(ch[u][1]);
    }
    void Print() {
        cerr << "start Prt" << endl;
        rep(i, 1, tcnt) if(find(i) == i && !kick[i]) prt(i), cerr << endl;
        cerr << "finish Prt" << endl;
    }
    void check() {
        rep(i, 1, tcnt) if(find(i) == i && !kick[i]) 
            if(pre(get(i, 0)) != get(i, 1)) {
                prt(i);
                info(get(i, 0), "try"), info(get(i, 1), "try");
                info(pre(get(i, 0)), "try"), info(nxt(get(i, 1)), "try");	
                assert(0 * 2);
            }
    }
    il int get(int u, int t) {
        int _rt = find(u), x, y, r;
        if(t) split(_rt, size[_rt]-1, x, y), r = y, merge(x, y);
        else split(_rt, 1, x, y), r = x, merge(x, y);
        return r;
    }
} T;
#define chk(x) if((x)) return (x)
il int nxt(int x, int y, int k) {
    if(x & 1) {
        if(!k) {
            if(x >= 1) chk(ver[x-1][y+1][1]);
            if(x >= 2) chk(ver[x-2][y][0]);
            if(x >= 1 && y >= 1) chk(ver[x-1][y-1][0]);
            return ver[x][y][1];
        }
        else {
            if(y >= 1) chk(ver[x+1][y-1][0]);
            chk(ver[x+2][y][1]);
            chk(ver[x+1][y+1][1]);
            return ver[x][y][0];
        }
    }
    else {
        if(!k) {
            if(x >= 1 && y >= 1) chk(ver[x-1][y-1][0]);
            if(y >= 2) chk(ver[x][y-2][0]);
            if(y >= 1) chk(ver[x+1][y-1][1]);
            return ver[x][y][1];
        }
        else {
            chk(ver[x+1][y+1][1]);
            chk(ver[x][y+2][1]);
            if(x >= 1) chk(ver[x-1][y+1][0]);
            return ver[x][y][0];
        }
    }
}
il int pre(int x, int y, int k) {
    if(x & 1) {
        if(!k) {
            chk(ver[x+1][y+1][0]);
            chk(ver[x+2][y][0]);
            if(y >= 1) chk(ver[x+1][y-1][1]);
            return ver[x][y][1];
        }
        else {
            if(x >= 1 && y >= 1) chk(ver[x-1][y-1][1]);
            if(x >= 2) chk(ver[x-2][y][1]);
            if(x >= 1) chk(ver[x-1][y+1][0]);
            return ver[x][y][0];
        }
    }
    else {
        if(!k) {
            if(x >= 1) chk(ver[x-1][y+1][1]);
            chk(ver[x][y+2][0]);
            chk(ver[x+1][y+1][0]);
            return ver[x][y][1];
        }
        else {
            if(y >= 1) chk(ver[x+1][y-1][0]);
            if(y >= 2) chk(ver[x][y-2][1]);
            if(x >= 1 && y >= 1) chk(ver[x-1][y-1][1]);
            return ver[x][y][0];
        }
    }
}
il int pre(int u) {
    return pre(xx[u], yy[u], kk[u]);
}
il int nxt(int u) {
    return nxt(xx[u], yy[u], kk[u]);
}
void info(int u, const char* s) {
    cout << s << ": "<< u << ' ' << xx[u] << ' ' << yy[u] << ' ' << kk[u] << endl;
}
il void merge(int x, int y) {
    if(!x || !y) return ;
    if(T.find(x) == T.find(y)) return ;
//	assert(T.rnk(x) == T.size[T.find(x)]);
    T.fa[T.merge(T.find(x), T.find(y))] = 0;
}
il void link(int u) {
    if(!u) return ;
    merge(pre(u), u), merge(u, nxt(u));
}
void take(int u, int v) {
    int _rt = T.find(u), a, b, c;
    if(T.rnk(u) > T.rnk(v)) {
        T.split(_rt, T.rnk(u)-1, a, c), T.split(a, T.rnk(v), a, b);
        T.merge(c, a);
    }
    else {
        T.split(_rt, T.rnk(v), a, c), T.split(a, T.rnk(u)-1, a, b);
        T.merge(c, a);
    }
}
bool Same_cyc(int u, int v) {
    if(!u || !v) return 0;
    return T.find(u) == T.find(v) && pre(T.get(u, 0)) == T.get(u, 1);
}
void setfr(int u) {
    if(!u) return ;
    int _rt = T.find(u), a, b;
    T.split(_rt, T.rnk(u)-1, a, b), T.merge(b, a);
}
void setre(int u) {
    if(!u) return ;
    int _rt(T.find(u)), a, b;
    T.split(_rt, T.rnk(u), a, b), T.merge(b, a);
}
void create(int x, int y, int k) {
    int u = T.newnode();
    ver[x][y][k] = u, xx[u] = x, yy[u] = y, kk[u] = k;
}
void insert(int x, int y) {
//	cout << "In I " << x << ' ' << y << endl;
    rep(k, 0, 1) {
        if(Same_cyc(pre(x, y, k), nxt(x, y, k))) {
            take(nxt(x, y, k), pre(x, y, k));
        }
        else setfr(nxt(x, y, k)), setre(pre(x, y, k));
        create(x, y, k);
        link(ver[x][y][k]);
    }
//	T.check();
//	cout << "out I" << endl;
}
il void cut(int u) {
    if(!u) return ;
    int _rt = T.find(u), a, b, c;
    T.split(_rt, T.rnk(u), a, c), T.split(a, T.rnk(u)-1, a, b);
    if(a && c && pre(T.get(a, 0)) == T.get(c, 1)) T.merge(T.find(c), T.find(a));
}
void erase(int x, int y) {
//	cout << "In E " << x << ' ' << y << endl;
    rep(k, 0, 1) cut(ver[x][y][k]), T.kick[ver[x][y][k]] = 1, ver[x][y][k] = 0;
    rep(k, 0, 1) link(pre(x, y, k)), link(nxt(x, y, k));
//	T.check();
//	cerr << "Out E" << endl;
}
il int query(int u, int v) {
    if(T.find(u) != T.find(v)) return -1;
    int w1 = T.rnk(u), w2 = T.rnk(v);
    if(w1 <= w2) return w2-w1;
    return w2-w1+T.size[T.find(u)];
}
il void Ex(int &x, int &y) {
    int a = x, b = y;
    y = m-a, x = b;
}
int main() {
//	freopen("farewell.in", "r", stdin);
//	freopen("farewell.out", "w", stdout);
    read(n), read(m), read(q);
    swap(n, m);
    rep(i, 1, n) insert(i*2-1, 0), insert(i*2-1, m*2);
    rep(i, 1, m) insert(0, i*2-1), insert(n*2, i*2-1);
    int op, x0, y0, x1, y1, x2, y2, x3, y3, k1, k2;
    repd(i, m, 1) 
        rep(j, 1, n-1) {
            read(op); 
            if(op) insert(j * 2, i * 2 - 1);
        }
    repd(i, m-1, 1) 
        rep(j, 1, n) {
            read(op);
            if(op) insert(j * 2 - 1, i * 2);
        }
    while(q--) {
        read(op);
        read(x0), read(y0), read(x1), read(y1);
        Ex(x0, y0), Ex(x1, y1);
        if(op == 1) insert(x0+x1, y0+y1);
        else if(op == 2) erase(x0+x1, y0+y1);
        else {
            read(k1), read(x2), read(y2), read(x3), read(y3), read(k2);
            Ex(x2, y2), Ex(x3, y3);
            int u1 = ver[x0+x1][y0+y1][k1], u2 = ver[x2+x3][y2+y3][k2];
            printf("%d\n", query(u1, u2));
        }
    }
    return 0;
}
```



---

## 作者：A_zjzj (赞：7)

由于大家的做法需要大量分类讨论和代码量，这里提供一种不怎么分类的，容易实现的做法。

首先，由于墙体会随时变化，所以直接对墙体本身维护不是很方便。

我们可以牺牲一点常数，对 $(i,j)$ 建立四个点 $UL_{i,j},UR_{i,j},DL_{i,j},DR_{i,j}$ 分别表示 $(i-\varepsilon ,j-\varepsilon ),(i-\varepsilon ,j+\varepsilon ),(i+\varepsilon ,j-\varepsilon ),(i+\varepsilon ,j+\varepsilon )$。

这样，在一个状态中，所有点的后继点都可以计算出来。

具体地：

- 若 $(i,j)-(i+1,j)$ 存在，则 $DL_{i,j}\to UL_{i+1,j}$；
- 否则 $DL_{i,j}\to DR_{i,j}$；

其余的 $DR_{i,j},UL_{i,j},UR_{i,j}$ 的后继点类似求出来。

这样，整个图就被抽象成了 $4(n+1)(m+1)$ 个点的若干置换环了。

考虑修改会对置换环造成什么影响：实际上仅仅交换了两个点的后继点（手玩一下就能发现）。

那么，用 FHQ-Treap 维护这些置换环，每次只需要判断一下交换后继点的两个点是否在同一个置换环中：

- 如果是 $A\to u\to B\to v\to C(\to A)$，那么改成 $A\to u\to C(\to A),B\to v(\to B)$。
- 如果是 $A\to u\to B(\to A),C\to v\to D(\to C)$，那么改成 $A\to u\to D\to C\to v \to B(\to A)$。

至于维护距离的话，只需要记录一下每个点到后继点的距离是 $0/1$ 就行了（FHQ-Treap 多维护一个值就行了）。

代码好写多了，没多少细节，速度也还可以，最大点用时 $<0.5s$。

~~本人 30min 码完过了编译直接过了样例，交上去就过了，值得纪念……~~

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
#define all(a) (a).begin(),(a).end()
const int N=505,M=N*N*4;
int n,m,q;
int k,UL[N][N],UR[N][N],DL[N][N],DR[N][N];
struct node{
	int fa,ls,rs,rnd,siz,val,sum;
}t[M];
mt19937 rnd(181766);
void pushup(int rt){
	t[rt].siz=t[t[rt].ls].siz+t[t[rt].rs].siz+1;
	if(t[rt].ls)t[t[rt].ls].fa=rt;
	if(t[rt].rs)t[t[rt].rs].fa=rt;
	t[rt].fa=0;
	t[rt].sum=t[t[rt].ls].sum+t[t[rt].rs].sum+t[rt].val;
}
void split(int rt,int k,int &x,int &y){
	if(!rt)return x=y=0,void();
	if(k<=t[t[rt].ls].siz)y=rt,split(t[rt].ls,k,x,t[rt].ls);
	else x=rt,split(t[rt].rs,k-t[t[rt].ls].siz-1,t[rt].rs,y);
	pushup(rt);
}
int merge(int x,int y){
	if(!x||!y)return x|y;
	if(t[x].rnd<t[y].rnd){
		t[x].rs=merge(t[x].rs,y);
		return pushup(x),x;
	}else{
		t[y].ls=merge(x,t[y].ls);
		return pushup(y),y;
	}
}
bool which(int rt){
	return t[t[rt].fa].rs==rt;
}
pair<int,int> query(int rt){
	int rk=t[t[rt].ls].siz+1;
	for(;t[rt].fa;rt=t[rt].fa){
		if(which(rt))rk+=t[t[t[rt].fa].ls].siz+1;
	}
	return {rt,rk};
}
void build(){
	static int nex[M],len[M],vis[M];
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			nex[UL[i][j]]=DL[i][j];
			nex[DL[i][j]]=DR[i][j];
			nex[DR[i][j]]=UR[i][j];
			nex[UR[i][j]]=UL[i][j];
		}
	}
	auto link1=[&](int x,int y){
		t[DR[x][y]].val=t[DR[x][y]].sum=1;
		t[UL[x][y+1]].val=t[UL[x][y+1]].sum=1;
		swap(nex[DR[x][y]],nex[UL[x][y+1]]);
	};
	auto link2=[&](int x,int y){
		t[DL[x][y]].val=t[DL[x][y]].sum=1;
		t[UR[x+1][y]].val=t[UR[x+1][y]].sum=1;
		swap(nex[DL[x][y]],nex[UR[x+1][y]]);
	};
	for(int i=0;i<n;i++)link2(i,0),link2(i,m);
	for(int j=0;j<m;j++)link1(0,j),link1(n,j);
	for(int i=1,x;i<=n;i++){
		for(int j=1;j<m;j++){
			scanf("%d",&x);
			if(x)link2(i-1,j);
		}
	}
	for(int i=1,x;i<n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&x);
			if(x)link1(i,j-1);
		}
	}
	for(int i=1;i<=k;i++)if(!vis[i]){
		int rt=i;
		vis[i]=1;
		for(int j=nex[i];j^i;j=nex[j]){
			vis[j]=1,rt=merge(rt,j);
		}
	}
}
void update(int rt,int op){
	for(;t[rt].rs;rt=t[rt].rs);
	t[rt].val=op;
	for(int fa;fa=t[rt].fa,pushup(rt),fa;rt=fa);
}
void change(int x1,int y1,int x2,int y2,int op){
	if(x1>x2||(x1==x2&&y1>y2))swap(x1,x2),swap(y1,y2);
	static int u,v;
	if(y2==y1+1)u=DR[x1][y1],v=UL[x2][y2];
	else u=DL[x1][y1],v=UR[x2][y2];
	auto [r1,k1]=query(u);
	auto [r2,k2]=query(v);
	if(r1==r2){
		if(k1>k2)swap(k1,k2);
		static int r3,r4,r5;
		split(r1,k2,r4,r5),split(r4,k1,r3,r4);
		update(r3,op),update(r4,op),merge(r3,r5);
	}else{
		static int r3,r4,r5,r6;
		split(r1,k1,r3,r4),split(r2,k2,r5,r6);
		update(r3,op),update(r5,op);
		merge(merge(r3,r6),merge(r5,r4));
	}
}
int getsum(int rt){
	int sum=t[rt].val+t[t[rt].rs].sum;
	for(;t[rt].fa;rt=t[rt].fa){
		if(!which(rt))sum+=t[t[t[rt].fa].rs].sum+t[t[rt].fa].val;
	}
	return sum;
}
int calc(int u,int v){
	auto [r1,k1]=query(u);
	auto [r2,k2]=query(v);
	if(r1!=r2)return -1;
	int res=getsum(u)-getsum(v);
	if(k1>k2)res+=t[r1].sum;
	return res;
}
int find(int x1,int y1,int x2,int y2,int d){
	if(x1==x2){
		if(y1>y2)swap(y1,y2);
		return d?DR[x1][y1]:UL[x2][y2];
	}else{
		if(x1>x2)swap(x1,x2);
		return d?UR[x2][y2]:DL[x1][y1];
	}
}
int main(){
	freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	scanf("%d%d%d",&n,&m,&q);
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			UL[i][j]=++k,t[k]={0,0,0,(int)rnd(),1,0,0};
			UR[i][j]=++k,t[k]={0,0,0,(int)rnd(),1,0,0};
			DL[i][j]=++k,t[k]={0,0,0,(int)rnd(),1,0,0};
			DR[i][j]=++k,t[k]={0,0,0,(int)rnd(),1,0,0};
		}
	}
	build();
	for(int op,x1,y1,x2,y2,x3,y3,x4,y4,d1,d2;q--;){
		scanf("%d%d%d%d%d",&op,&x1,&y1,&x2,&y2);
		if(op<=2)change(x1,y1,x2,y2,op==1);
		else{
			scanf("%d%d%d%d%d%d",&d1,&x3,&y3,&x4,&y4,&d2);
			printf("%d\n",calc(find(x1,y1,x2,y2,d1),find(x3,y3,x4,y4,d2)));
		}
	}
	return 0;
}
```

---

## 作者：Jr_Zlw (赞：5)

~~垃圾题，出题人垃圾佬~~

这边提供一篇 FHQ treap 的题解

## 大致思路

考虑到只需要找两点之间的路程，而复杂度明显不能使用搜索并且还有恶心的修改操作，而每两点间都有固定的路线，我们可以把每个合法位置看成  $1$  个虚点，然后用数据结构来维护这些虚点在某个环中的排名即可计算出答案。

## 形象化理解

![](https://cdn.luogu.com.cn/upload/image_hosting/pic322vy.png)

如图所示，直线代表了墙，数字则是我们可以编号上去的。

很明显询问时两个人肯定是会出现在我们编过号的这些点上，譬如：

当起点在  $1$  ，终点在  $9$  时，路线就是  $1,2,3,7,8,10,9$。

很明显，在这里路径形成了  $1$  个环，即  $1,2,3,8,10,9,4,6,5,1,2,......$。

那么我们只需要把已有的点都记录到 FHQ 中，每棵 FHQ 中的  $rank(1)$  和  $rank(size)$  恰好为相邻元素，那么一个环就被记录下来。

这么记录最大的用处就是：由于每段墙长度为  $1$  ，当你要找两点间的距离时，只需查找这两点的排名就可以轻松地计算出人要走的路径长度。

## 具体操作

### 1. 查找排名

这个只要有一点平衡树基础的应该都知道怎么找：

沿着父亲往上找，当前节点是父亲的右儿子则  ```ans+=```  父亲以及父亲左子树的大小。若是左儿子则不用理会。

用 FHQ 的同学可以将节点父亲当做一项需要额外维护的值，处理方法就是在  ```update```  的时候讲当前节点的儿子的父亲指向自己并清空当前节点的父亲值，这样就能保证父亲的正确性且根节点的父亲指向  $0$  。

### 2. 环的旋转

对于一个记下的环来说：比如  $1,2,3,4,1,2,3,4,1,2,...$  。

我们记录的时候是这样记录的：  $1,2,3,4$  。

那么我们发现，如果把前面的任何数裂开然后合并到后面环的性质不会改变：

例如： 由  $1,2,3,4$  变为  $3,4,1,2$  。

这个性质很重要，对于我们后面减少讨论情况奠定了重要基础。

### 3. 插入

这个是最 [数据已删除] 恶心的操作了，仅次于删除。

![](https://cdn.luogu.com.cn/upload/image_hosting/w5260oyc.png)

考虑记  $i$  点理论上的前驱为  $p_i$  ,理论上的后继为  $s_i$  。

竖着的边左端点为  $t_0$  右端点为  $t_1$  。

横着的边下端点为  $t_0$  上端点为  $t_1$  。

这里分享我的分类讨论方法，具体方法据个人理解而定（因为要分类讨论的点太多了，分类方法也因此有很多，如果你的方法与题解不一样也不需要怀疑自己）。

分几种情况考虑：

1. 一条边没有任何前驱后继： 只需要把墙两边节点合起来即可;

2. 只有  $t_0$  的前驱与其他边相连：把  $p[t_0]$ 转到它所在的环的最后，并在前面插上  $t_1$  后面插上  $t_0$

3. 只有  $t_1$  的前驱与其他边相连：把  $s[t_0]$  转到它所在的的环最前，并在前面插上  $t_0$  后面插上  $t_1$

4. 墙的两端都与其他墙相连：先按照第  $2$  条的方法进行处理，然后判断  $s[t_0]$  是否与  $p[t_0]$  在同一棵树中（找根即可）。如果在，说明形成了环，且环以  $t_0$  开头  ，  $s[t_0]$  结尾，因此把  $s[t_0]$  前面的数都分出去即可。若不在，则先将  $s[t_0]$  转到开头然后把  $t_0$  接在  $s[t_0]$  前面即可。

正确性是可以保证的，自己模拟一遍就能证明。

### 4. 删除

其实删除就是插入的逆操作，简单很多。

1. 一条边没有任何前驱后继： 直接暴躁拆墙即可

2. 如果有任何边连在墙上，其实就是把待拆边的两个端点分别转到环的前面打掉然后分情况合并就行了，具体看代码。

### 5. 查询

哎呦喂终于来到最后一关了

最后一关是明显是奖励关卡，异常简单。

首先我们判断起点与终点是否在同一环中（判根），不在就直接  $-1$  打回

其次我们找到起点与终点的排名。

1. 如果起点排名比终点小：直接输出排名差即可

2. 反之，则用环的大小减去排名差输出即可

### 6. 调试

这么恶心的题目调试起来也很恶心嘛，这边推荐一种调试方法。

可以枚举每一个点，然后找到他们的根，如果根没有被访问，中序遍历这个根。

这样每次中序遍历出来的就是一个个的环了！（具体看代码中的  ```debug()```  函数）

## 代码

码风~~比较~~很丑，大佬轻喷。


```
#include<bits/stdc++.h>
#define rep(a,b,c) for(register int c=(a);c<=(b);++c)
#define N 1000005
#define Debug(a,b) if(L==a&&R==b)debug();  
using namespace std;
int csd;
inline int read()
{
	int res=0;char ch=getchar();while(ch<'0'||ch>'9')ch=getchar();
	while(ch<='9'&&ch>='0')res=(res<<1)+(res<<3)+(ch^48),ch=getchar();return res;
}
struct FHQ{int l,r,f,pos,siz,key;}t[N]; int n,m,q,cnt,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10;
inline int Node(){t[++cnt].siz=1;t[cnt].key=rand();return cnt;}
bool vis[1001]; int Loc[505][505][2][2],qkq;//左上0右下1，竖0横1
inline int getRt(int k){while(t[k].f)k=t[k].f;return k;}//accept
inline void print(int cur) {if(!cur)return;print(t[cur].l);printf("%d ",cur);print(t[cur].r);}
inline void update(int k){t[k].siz=t[t[k].l].siz+t[t[k].r].siz+1;if(t[k].l)t[t[k].l].f=k; if(t[k].r)t[t[k].r].f=k; t[k].f=0;}
inline void debug(){rep(1,cnt,i)vis[i]=0;rep(1,cnt,i){int r=getRt(i);if(!vis[r])print(r),vis[r]=1,puts("");}puts("");}
inline void split(int k,int cur,int &x,int &y)
{
	
	if(!cur){x=y=0;return;}
	if(k<=t[t[cur].l].siz){y=cur;split(k,t[cur].l,x,t[cur].l);update(cur);return;}
	else {x=cur;split(k-t[t[cur].l].siz-1,t[cur].r,t[cur].r,y);update(cur);return;}
}
inline int merge(int L,int R)
{
	if(!L||!R)return L+R;
	if(t[L].key<t[R].key){t[L].r=merge(t[L].r,R);update(L);return L;}
	else{t[R].l=merge(L,t[R].l);update(R);return R;}
}
inline int rnk(int k){int res=t[t[k].l].siz;while(t[k].f){res+=(k==t[t[k].f].r)?t[t[t[k].f].l].siz+1:0;k=t[k].f;}return res+1;}
inline int pre(int x,int y,bool d,bool b)
{
	if(!d&&!b)return (Loc[x-1][y][1][1])?(Loc[x-1][y][1][1]):((Loc[x-1][y][0][0])?Loc[x-1][y][0][0]:((Loc[x-1][y+1][0][1])?Loc[x-1][y+1][0][1]:0));//accept
	if( d&& b)return (Loc[x+1][y-1][1][0])?Loc[x+1][y-1][1][0]:((Loc[x][y-1][1][1])?Loc[x][y-1][1][1]:((Loc[x][y-1][0][0])?Loc[x][y-1][0][0]:0));//accept
	if( d&&!b)return (Loc[x][y+1][0][1])?Loc[x][y+1][0][1]:((Loc[x+1][y][1][0])?Loc[x+1][y][1][0]:((Loc[x][y][1][1])?Loc[x][y][1][1]:0));//accept
	if(!d&& b)return (Loc[x][y][0][0])?Loc[x][y][0][0]:((Loc[x][y+1][0][1])?Loc[x][y+1][0][1]:((Loc[x+1][y][1][0])?Loc[x+1][y][1][0]:0));//accept
	return 0;
}
inline int suc(int x,int y,bool d,bool b)
{
	if(!d&&!b)return (Loc[x][y][0][1])?Loc[x][y][0][1]:((Loc[x+1][y][0][0])?Loc[x+1][y][0][0]:((Loc[x][y+1][1][1])?Loc[x][y+1][1][1]:0));//accept
	if( d&& b)return (Loc[x+1][y][0][0])?Loc[x+1][y][0][0]:((Loc[x][y+1][1][1])?Loc[x][y+1][1][1]:((Loc[x][y][1][0])?Loc[x][y][1][0]:0));//accept
	if( d&&!b)return (Loc[x-1][y+1][1][1])?Loc[x-1][y+1][1][1]:((Loc[x-1][y][1][0])?Loc[x-1][y][1][0]:((Loc[x-1][y][0][1])?Loc[x-1][y][0][1]:0));//accept
	if(!d&& b)return (Loc[x][y-1][1][0])?Loc[x][y-1][1][0]:((Loc[x][y-1][0][1])?Loc[x][y-1][0][1]:((Loc[x+1][y-1][0][0])?Loc[x+1][y-1][0][0]:0));//accept
}
inline void ins(int x,int y,bool b)//accept
{
	int t0,t1;t0=Loc[x][y][0][b]=Node();t1=Loc[x][y][1][b]=Node();if(b)swap(t0,t1);
	int p0=pre(x,y,b,b),p1=pre(x,y,b^1,b),s0=suc(x,y,b,b),s1=suc(x,y,b^1,b);
	if(!p0&&!s0&&!p1&&!s1){merge(t0,t1);return;} if(p0)
	{
		split(rnk(p0),getRt(p0),T1,T2);T1=merge(merge(merge(t1,T2),T1),t0);
		if(s0){split(rnk(s0)-1,getRt(s0),T2,T3);if(getRt(t0)!=getRt(s0))merge(merge(T1,T3),T2);}
	}
	else split((rnk(s0)-1),getRt(s0),T1,T2),merge(merge(merge(t0,T2),T1),t1);
}
inline void del(int x,int y,bool b)
{
	int t0,t1;t0=Loc[x][y][0][b];t1=Loc[x][y][1][b];if(b)swap(t0,t1);
	int p0=pre(x,y,b,b),p1=pre(x,y,b^1,b),s0=suc(x,y,b,b),s1=suc(x,y,b^1,b);if(p0)
	{
		split(rnk(t0)-1,getRt(t0),T1,T2);split(1,T2,T10,T2);T1=merge(T2,T1);
		if(getRt(p0)==getRt(s1)){split(rnk(s1)-1,T1,T1,T2);split(t[T1].siz-1,T1,T1,T10);}
		else {split(rnk(t1)-1,getRt(t1),T2,T3);split(1,T3,T10,T3);merge(T1,merge(T3,T2));} 
	}	
	else if(p1){split(rnk(t0)-1,getRt(t0),T1,T2);T1=merge(T2,T1);split(1,T1,T10,T1);split(t[T1].siz-1,T1,T1,T10);}
	Loc[x][y][0][b]=Loc[x][y][1][b]=0;return;
}
inline void Query(int x0,int y0,bool d0,bool b0,int x1,int y1,bool d1,bool b1)
{
	int a=Loc[x0][y0][d0][b0],b=Loc[x1][y1][d1][b1];
	int ra=getRt(a),rb=getRt(b);if(ra!=rb){puts("-1");return;}
	int aa=rnk(a),ab=rnk(b);
	int ans=(ab>aa)?(ab-aa):(ab-aa+t[ra].siz)%t[ra].siz;
	printf("%d\n",ans);
}

int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("mout.txt","w",stdout);
	srand(time(0));
	n=read();m=read();q=read();
	rep(1,m,i)ins(0,i,1),ins(n,i,1);
	rep(1,n,i)ins(i,0,0),ins(i,m,0);
	rep(1,n,i)rep(1,m-1,j)if(read())ins(i,j,0);
	rep(1,n-1,i)rep(1,m,j)if(read())ins(i,j,1);
	int opt,x0,y0,x1,y1,x2,y2,x3,y3;bool d1,d0;rep(1,q,i)
	{
		opt=read();
		if(opt==1){x0=read();y0=read();x1=read();y1=read(); if(x0<x1)swap(x0,x1); if(y0<y1)swap(y0,y1);ins(x0,y0,(x0==x1));}
		if(opt==2){x0=read();y0=read();x1=read();y1=read();if(x0<x1)swap(x0,x1);if(y0<y1)swap(y0,y1);del(x0,y0,(x0==x1));}
		if(opt==3)
		{
			x0=read();y0=read();x1=read();y1=read();d0=read();x2=read();y2=read();x3=read();y3=read();d1=read();
			if(y0<y1)swap(y0,y1); if(x0<x1)swap(x0,x1); if(y2<y3) swap(y2,y3); if(x2<x3) swap(x2,x3);
			Query(x0,y0,d0,((x0==x1)?1:0),x2,y2,d1,((x2==x3)?1:0));
		}
	}
	return 0;
}
```

练习码力的最好方法是—— A 了这道题，祝你好运！（码力++）。

---

## 作者：wind_whisper (赞：4)

## $\text{Foreword}$
肝了一下午+一晚上的码农题...  
（主要就是在 debug，LCT 太难 de 了...）  
感谢 [@M_sea](https://www.luogu.com.cn/user/38370)，在调无可调认为LCT会不会不可做时，我看到了他的题解，几乎一样的思路，给了我继续调下去的信心。  
## $\text{Solution}$
第一感就是割点 LCT 的感觉。(~~为什么都说这是平衡树板题啊...~~)  

细化一下，把每个格点分成左上、右上、左下、右下四个点，每条边分成两边两个点，在可以直接走过的相邻点直接连边，那么整张图就会变成若干个环。  
询问就是要求给出两点在环上钦定方向的距离。  
对于修改，一个避免分讨的实现方法是把修改格边涉及到所有点之间的边 cut 掉，修改格边的存在状态后，再按照新的状态把对应的点 link 回去。  

还有一个问题：LCT是无法维护环的，怎么办？  
一个比较直观的想法是：随便选一条边 cut 掉（称为特殊边），这样就变成一条链了。询问的时候，“钦定的方向”要么是 split 出的实链的长度，要么是其补集，常规套路记录实链大小和虚子树大小即可。  

但这样修改的时候会出问题：如果修改边使两个环合并为一个环，那么这个环上就会有两条特殊边，那么最终的 LCT 形态就会变得不连通了...  
也有解决方法：在合并环之前把各自的特殊边 link 回去，合并完之后自然就只会出现一条新的特殊边（即合并失败的边）。  
所以我们现在还需要记录一下每个环的特殊边是什么，通过 LCT 打标记即可维护。   

于是本题就做完了。  
（我调了一晚上的坑点：当特殊边被修改的格边状态涉及到时，不应该额外 link 特殊边，因为修改格边状态后可能这条边本身可能就已经不复存在了！）

## $\text{Code}$
代码调调补补变得又长又丑，就放[剪切板](https://www.luogu.com.cn/paste/foqu0p9k)吧。  


---

## 作者：qiuzx (赞：0)

## 题意

有一张 $n\times m$ 的网格图，其中有一些格子之间的边上有墙，另一些没有，边界上边的一定全是墙。有两个人分别位于两条边的中点处，第一个人会保持左手贴着墙一直沿着墙向前走，求他遇到第二个人时经过的距离，或永远不会遇到。有 $q$ 次操作，每次加入或删除一段墙，或者需要对当前局面求上面这个问题的答案。$n,m\le 500,q\le 2\times 10^5$。

## 思路

对于一个固定的局面，应当如何计算答案呢？先将线段编号（一条线段的两侧看作不同的线段），则一共有 $O(nm)$ 条不同的线段。注意到若确定了当前所在的线段，那么下一步到达的线段是唯一确定的，可以记 $i$ 的下一步为 $nxt_i$。进一步注意到 $nxt_i$ 是一个一一对应的关系，这是因为若 $nxt_i=j$，那么 $j$ 是 $i$ 逆时针方向上的第一条出现的线段，所以反过来 $i$ 是 $j$ 顺时针方向上的第一条出现的线段，因此满足 $nxt_i=j$ 的 $i$ 恰好只有 $1$ 个。这样若我们从 $i$ 向 $nxt_i$ 连一条有向边，那么这张图是若干个有向环拼起来得到的，一次查询中需要判定从 $i$ 出发是否可以到达 $j$ 以及之间的距离。

由于每条线段的 $nxt$ 只和它两个端点处连接的其它线段有关，所以一次修改操作只会影响到 $O(1)$ 个线段的 $nxt$，直接暴力重构修改线段的两个端点处的其它线段的 $nxt$ 即可。下面只需要能够快速维护这个过程。

如果我们直接考虑修改一个 $nxt_i$，那么在修改的过程中不一定保持图仍然是若干个环拼起来的好性质，而如果没有这个性质那么这个问题不弱于动态图连通性，所以我们需要设法让操作中时刻保持这个性质。注意到操作本质上是对一个排列 $p$ 的 $O(1)$ 个位置进行了一个重新排列，而重新排列 $k$ 个位置的过程可以看作 $O(k)$ 次交换一对 $p_i,p_j$ 的过程，所以我们只需要能够快速交换 $nxt_i$ 和 $nxt_j$ 即可，这个操作不会影响排列的性质。

交换 $nxt_i$ 和 $nxt_j$ 是相对简单的问题。分两种情况讨论，若 $i,j$ 在同一个环里，那么会将环裂成两个环。否则会把两个环合并成一个环。考虑给环钦定一个顺序变成序列，然后对每个序列使用一棵平衡树进行维护。这样如果是裂成两个环，就是把 $i,j$ 中间的部分从环里抽出去。如果是合并，设 $i,j$ 前后的部分分别为 $A,B$ 和 $C,D$，则相当于按照 $ADCB$ 的顺序将它们拼起来。这些都可以通过 treap 实现。只需要同时维护每个节点的父亲即可支持查询一个点的根以及它的编号，这样就可以回答询问了。复杂度 $O(q\log nm)$。

[代码](https://www.luogu.com.cn/paste/qo89dw23)

---


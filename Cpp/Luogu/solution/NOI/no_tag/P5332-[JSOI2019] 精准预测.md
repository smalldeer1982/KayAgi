# [JSOI2019] 精准预测

## 题目背景

JYY 和他的火星探险队再次登录火星小镇，并且打算把机器学习的知识传授给火星人，从而提高火星人的生活效率。但智力有限的火星人纷纷表示不相信计算机科学。为了让火星人彻底信服，JYY 的探险队找到了他们之前关于火星详细的数据记录，并且训练了一个预测模型，这个模型能准确地预测出火星人在未来的生死情况。

## 题目描述

目前，火星小镇上有$n$个居民（编号$1,2,……,n$）。机器学习算法预测出这些居民在接下来$T$个时刻（编号$1,2,……,T$）的生死情况，每条预测都是如下两种形式之一：

- 难兄难弟$0$ $t$ $x$ $y$：在$t$时刻，如果$x$是死亡状态，那么在$t+1$时刻，$y$是死亡状态。（注意，当$x$在$t$时刻是生存状态时，该预测也被认为是正确的）；

- 死神来了$1$ $t$ $x$ $y$：在$t$时刻，如果$x$是生存状态，那么在$t$时刻，$y$是死亡状态。（注意，当$x$在$t$时刻是死亡状态时，该预测也被认为是正确的）。

注意本题是对某个时刻进行生死状态的预测，如果某个人在$t$时刻是生存状态，在$t+1$时刻是死亡状态，你可以认为是在$t$到$t+1$这段时间内发生了某个事件导致其死亡。

虽然 JYY 对自己从大数据中统计得到的模型非常自信，但火星人看到这些预测吓了一跳，表示实在难以接受这种设定，更是认为计算机科学是可怕的邪教，打破了他们平静的生活。为了安抚火星人的情绪， JYY 打算从这些预测结果中推导出一些火星人更容易接受的事实，从而安抚火星人的情绪。

具体来说，JYY 首先假设对火星人生死的预测全部正确，在此基础上，JYY 希望为小镇上的每个居民$k$分别计算有多少个火星人有可能和他一起活到第$T+1$时刻，换言之，JYY 希望为每个火星人$k$计算

$$\sum_{1 \leq i \leq n,i \neq k} \operatorname{Live}(k,i)$$

其中 $\operatorname{Live}(i,j)=1$ 表示编号为$i$和$j$的火星人有可能同时在第 $T+1$ 时刻处于生还状态，否则$\operatorname{Live}(i,j)=0$。

注意火星人是不能够复活的。一个火星人可能在时刻$1$就处于死亡状态，也有可能有预测未覆盖的死亡情况发生（火星人在任何时候都可能死亡，但任意时刻观察到火星人的状态要么活着，要么死亡）。最后，注意到$\operatorname{Live}$是为每一对火星人分别独立计算的，因此$\operatorname{Live}(x,y)=1,\operatorname{Live}(y,z)=1$并不意味着$\operatorname{Live}(x,z)=1$。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/57734.png)

## 样例 #1

### 输入

```
3 3 2
0 2 1 3
1 1 2 3```

### 输出

```
2 1 1```

# 题解

## 作者：Lice (赞：27)

### Description

现有一台预测机，可以预测当前 $n$ 个人在 $T$ 个时刻内的生死关系。关系有两种：

- $\texttt{0 t x y}$：如果 $t$ 时刻 $x$ 死了，那么 $y$ 在第 $t+1$ 时刻也会死亡。
- $\texttt{1 t x y}$：如果 $t$ 时刻 $x$ 活着，那么 $y$ 在 $t$ 时刻就会死亡。

这样的关系共有 $m$ 条。现在你需要在不违背这些关系的前提下，计算对于每一个人 $i$，可能可以与 $i$ 活到第 $T+1$ 时刻的有多少人。形式化的讲，设 $\text{Live}(i, j)$ 表示是否 $i, j$ 可以同时存活，如果可以则为 $1$，反之为 $0$。那么你需要对于每一个 $i\in[1, n]$，计算
$$
\sum_{j\in[1, n],i\ne j}\text{Live}(i, j)
$$
的值。

### Hint

$1\le n\le 5\times 10^4, 1\le m\le 10^5, 1\le T\le 10^6$。

### Solution

考虑用 **2-SAT** 思想将生死关系转化为图：记 $(x,t), \neg (x,t)$ 分别表示 $x$ 这个人在时刻 $t$ 的 活 / 死 两个状态（图上的顶点），$a\to b$ 表示一条从 $a$ 到 $b$ 的有向边。

- 对于一个人 $i$，如果 $t$ 时刻他死了，那么显然 $t+1$ 时刻也是死的。同理，如果 $t+1$ 时刻是活的，那么 $t$ 时刻一定也是活的。连边 $\neg(i, t)\to \neg(i,t+1),(i,t+1)\to(i,t)$。
- 对于一个关系 $\texttt{0 t x y}$，显然连边 $\neg(x, t)\to \neg(y,t+1)$。注意如果 $t+1$ 时 $y$ 没死，那么说明这个条件没有生效，在 $t$ 时刻 $x$ 是活的，所以 $(y,t+1)\to (x,t)$。
- 对于一个关系 $\texttt{1 t x y}$，显然连边 $(x, t)\to \neg(y,t)$。同上反向考虑有 $(y, t)\to \neg(x,t)$。

这样我们就把图建好了。然而我们发现 ~~闷声发大财~~ 点数是 $O(n\times T)$ 的。其实这个还好办，我们只要对每个点 $x$，把它在条件中出现过的 $t$ 作为点开出来，其他 **没有出现在条件中的就是没用的点**。具体来讲，对每个点开一个 ```set``` 存储有用的时刻（包括 $T+1$），然后用一个 ```map``` 存一下编号即可。这样一来，点和边的规模为 $O(m+n)$，可以承受。

------------------------------

那么，如何用这张图求解答案呢？为了方便，设 $\text{alive}(x) = (x, T+1),\text{dead}(x) = \neg(x, T+1)$，分别表示最后结束时 $x$ 这个人生死对应的两个状态。

我们考虑一条有向边 $a\to b$ 的实际意义：如果 $a$ 为真，那么可以推出 $b$ 也为真。如果说存在一个 $y\ne x$ 使得 $\text{alive}(x)$ 可以到达 $\text{dead}(y)$，那么表明 $x$ 活着的话 $y$ 就会死，这样两个人显然无法同时活着。

如果我们对于每个 $x$ 都求出满足上述条件的 $y$ 集合的大小，那么 $n$ 减去这个集合的大小再减一（减去自己）即为答案。

在实际实现时，我们枚举 $i\in [1, n]$ 并从 $\text{alive}(i)$ 开始 DFS，搜出这个 $\text{alive}(i)$ 可以搜到那些 $\text{dead}(j)$，最后我们得到了一个由所有 $\text{alive}(i)$ 可及的 $\text{dead}(j)$ 组成的一个集合，然后答案就比较显然了。

但这样的复杂度是平方级别，我们考虑优化。发现对于 DFS 树上的一个结点 $x$ 以及其子节点 $y_1, y_2, \cdots y_k$。若记 $f(i)$ 为 $i$ 可以到达的点集，那么 $f(x) = \left(\cup_{i=1}^k f(y_i)\right)\cup\{x\}$。不难发现这个 $\cup$ 其实是可以用 **```bitset``` 的位运算** 进行优化的，复杂度降为 $O(\frac 1 \omega n(n+m))$。注意，这里 $f$ 也有记忆化的作用，使得一个点不被搜两次。既然是记忆化，那么相当于在 DAG 上 dp。具体为什么是 DAG，发现只会有生 $\to$ 死的边而没有死 $\to$ 生的，并且死 $\to$ 死的边存在时间先后顺序，不会存在 SCC。

------------------------------------

难受的是 $\frac 1 \omega n(n+m)$ 大小的 ```bitset``` 直接炸空间了，于是我们使用神奇技巧强行卡进去。

考虑把 $n$ 个人分成若干块 **分批处理**，一块 $B$ 个，然后空间常数就小下来了。实测 $B\approx 2\times 10^4$ 时可过。

实现上一个细节：特别标记 **必死点**，即 $\text{alive}(x)$ 可以到达 $\text{dead}(x)$。这种点单独输出 $0$。

### Code

以下代码部分参考了 [这篇博客](https://blog.csdn.net/qq_39972971/article/details/93032127)。

```cpp
/*
 * Author : _Wallace_
 * Source : https://www.cnblogs.com/-Wallace-/
 * Problem : JSOI2019 精准预测
 */
#include <algorithm>
#include <bitset>
#include <iostream>
#include <set>
#include <map>
#include <vector>

using namespace std;
const int N = 5e4 + 5;
const int MaxT = 1e6 + 5;
const int M = 1e5 + 5;
const int B = 1e4;
const int V = (M + N) << 1;

int n, m, T;
int type[M], t[M], x[M], y[M];
int ans[N];

set<int> vaild[N];
map<int, int> idx[N][2];
int total = 0;

vector<int> adj[V]; // graph
void link(int u, int v) { adj[u].emplace_back(v); }

int l[N], d[N], bel[V]; // live, dead
bitset<N> dead;
bitset<V> vis;
bitset<B> statu[V]; // f

void dfs(int x, int p, int q) {
    if (vis[x]) return; vis.set(x);
    statu[x].reset();
    if (p <= bel[x] && bel[x] <= q) statu[x].set(bel[x] - p);
    for (auto y : adj[x]) dfs(y, p, q), statu[x] |= statu[y];
}

signed main() {
    ios::sync_with_stdio(false), cin >> T >> n >> m;
    for (int i = 1; i <= m; i++) cin >> type[i] >> t[i] >> x[i] >> y[i];
    for (int i = 1; i <= n; i++) vaild[i].insert(T + 1);
    for (int i = 1; i <= m; i++) vaild[x[i]].insert(t[i]);
    for (int i = 1; i <= n; i++) {
        for (auto t : vaild[i])
            idx[i][0][t] = ++total, idx[i][1][t] = ++total;
        for (auto t = vaild[i].begin(); t != vaild[i].end() && next(t) != vaild[i].end(); t++)
            link(idx[i][0][*t], idx[i][0][*next(t)]), link(idx[i][1][*next(t)], idx[i][1][*t]);
    }
    for (int i = 1; i <= m; i++) {
        if (!type[i]) {
            int to = *vaild[y[i]].upper_bound(t[i]);
            link(idx[x[i]][0][t[i]], idx[y[i]][0][to]);
            link(idx[y[i]][1][to], idx[x[i]][1][t[i]]);
        } else {
            int to = *vaild[y[i]].lower_bound(t[i]);
            link(idx[x[i]][1][t[i]], idx[y[i]][0][to]);
            link(idx[y[i]][1][to], idx[x[i]][0][t[i]]);
        }
    }

    for (int i = 1; i <= n; i++) l[i] = idx[i][1][T + 1], bel[d[i] = idx[i][0][T + 1]] = i;
    for (int p = 1, q; p <= n; p += B) {
        q = min(p + B - 1, n), vis.reset();
        for (int i = 1; i <= n; i++) dfs(l[i], p, q);
        bitset<B> cur;
        for (int i = p; i <= q; i++) if (statu[l[i]][i - p]) dead.set(i), cur.set(i - p);
        for (int i = 1; i <= n; i++) ans[i] += (q - p + 1) - (cur | statu[l[i]]).count();
    }
    for (int i = 1; i <= n; i++)
        cout << (dead[i] ? 0 : ans[i] - 1) << ' ';
    return cout << endl, 0;
}
```



---

## 作者：Sol1 (赞：9)

~~本来想写个线性空间的怕卡不过去就真香了（）~~

题意：

给定 $n$ 个人和 $m$ 组限制，分为两种：

1. 如果 $x$ 在 $t$ 时间前死了，则 $y$ 在 $t+1$ 时间前也死了。
2. 如果 $x$ 在 $t$ 时间还活着，则 $y$ 在 $t$ 时间前死了。

请你对每一个人计算出在 $T+1$ 时间时可能与其同时存活的人数。如果这个人在 $T+1$ 时刻必然死则答案为 $0$。

$n\leq 5\times 10^4,m\leq 10^5,T\leq 10^6$。

解法：

首先观察到一个人有两个互斥的状态：存活和去世，而每一个限制只涉及到两个人，所以考虑 2-SAT。

然后是套路构图，第一种限制可以表示为 $\text{Dead}(x,t)\rightarrow \text{Dead}(y,t+1)$，以及它的逆否命题 $\text{Alive}(y,t+1)\rightarrow \text{Alive}(x,t)$。

第二种限制类似，表示为 $\text{Alive}(x,t)\rightarrow \text{Dead}(y,t)$，和逆否命题 $\text{Alive}(y,t)\rightarrow \text{Dead}(x,t)$。

还有一个限制：一个人死了不能复活，所以相当于 $\text{Dead}(x,t)\rightarrow \text{Dead}(x,t+1)$。同样有逆否命题 $\text{Alive}(x,t+1)\rightarrow \text{Alive}(x,t)$。

直接这样构图，点数是 $O(nT)$ 的，不可接受。

我们发现一个人只有要判定别人的生死状态的时候需要知道自己的生死状态，所以对每一个人只保存 $x$ 为自己的判定时间点就够了，具体是什么时间死的其实我们不关心。

这样点数降到了 $O(n+m)$，边数也就随之降到了 $O(n+m)$。

这个图由于只有 $\text{Alive}\rightarrow \text{Alive}$、$\text{Alive}\rightarrow \text{Dead}$、$\text{Dead}\rightarrow \text{Dead}$ 的边，而且 $\text{Alive}\rightarrow \text{Alive}$ 在时间上全都向前，$\text{Dead}\rightarrow \text{Dead}$ 在时间上全都向后，所以这个图本身就是一个 DAG，故可以省去缩点。

然后我们要做的就是对每一个 $\text{Alive}(i,T+1)$，求：

- 它能否到达 $\text{Dead}(i,T+1)$；
- 如果不能，能到达多少个 $\text{Dead}(j,T+1)$。

如果第一个问题的答案是“能”，则答案为 $0$；否则答案为 $n$ 减去第二个问题的答案再减去 $1$（自己不被算进答案）。

这是一个很套路的 bitset，问题是空间开不下，所以找一个块长 $S$，第一次求出到 $\text{Dead}([1,S],T+1)$ 的所有点的可达性，第二次求出到 $\text{Dead}([S+1,2S],T+1)$ 的所有点的可达性，以此类推。

这里的问题是 $S$ 太大会导致空间炸裂，$S$ 太小会导致遍历图的次数非常多从而时间常数炸裂。

我的代码取的 $S=10^4$，实际跑起来效果还是不错的。

最终时间复杂度 $O\left(\dfrac{n(n+m)}{\omega}\right)$，空间复杂度 $O\left(\dfrac{nS}{\omega}\right)$。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <bitset>
#include <vector>
#include <set>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const int BSIZE = 10000;
vector <int> g[300005];
set <int> v[50005];
vector <int> vc[50005];
int type[100005], t[100005], x[100005], y[100005], n, T, m, sizsum[100005], fA[50005], fD[50005], ans[50005], mustdie[50005];
bitset <BSIZE> dp[300005], cur;
bool vis[300005];

inline void Read() {
	T = qread(); n = qread(); m = qread();
	for (int i = 1;i <= m;i++) {
		type[i] = qread(); t[i] = qread(); x[i] = qread(); y[i] = qread();
		v[x[i]].insert(t[i]);
	}
}

//i -> Alive
//i + sizsum[n] -> Dead

inline int Alive(int i, int j) {
	return sizsum[i - 1] + j + 1;
}

inline int Dead(int i, int j) {
	return sizsum[i - 1] + j + 1 + sizsum[n];
}

inline void AddEdge(int u, int v) {
	g[u].push_back(v);
	//printf("%d %d\n", u, v);
}

inline void Prefix() {
	for (int i = 1;i <= n;i++) v[i].insert(T + 1);
	for (int i = 1;i <= n;i++) sizsum[i] = sizsum[i - 1] + v[i].size();
	for (int i = 1;i <= n;i++) {
		int siz = v[i].size();
		for (int j = 1;j < siz;j++) AddEdge(Alive(i, j), Alive(i, j - 1));
		for (int j = 0;j < siz - 1;j++) AddEdge(Dead(i, j), Dead(i, j + 1));
	}
	for (int i = 1;i <= n;i++) {
		for (set<int>::iterator it = v[i].begin();it != v[i].end();it++) vc[i].push_back(*it);
	}
	for (int i = 1;i <= m;i++) {
		int xj = lower_bound(vc[x[i]].begin(), vc[x[i]].end(), t[i]) - vc[x[i]].begin();
		int yj = lower_bound(vc[y[i]].begin(), vc[y[i]].end(), t[i] + (!type[i])) - vc[y[i]].begin();
		if (!type[i]) {
			AddEdge(Dead(x[i], xj), Dead(y[i], yj));
			AddEdge(Alive(y[i], yj), Alive(x[i], xj));
		} else {
			AddEdge(Alive(x[i], xj), Dead(y[i], yj));
			AddEdge(Alive(y[i], yj), Dead(x[i], xj));
		}
	}
	//puts("");
	for (int i = 1;i <= n;i++) {
		fA[i] = Alive(i, vc[i].size() - 1);
		fD[i] = Dead(i, vc[i].size() - 1);
		//printf("%d %d\n", fA[i], fD[i]);
	}
}

inline void Dfs(int u) {
	if (vis[u]) return;
	vis[u] = 1;
	int siz = g[u].size();
	for (int i = 0;i < siz;i++) {
		Dfs(g[u][i]);
		dp[u] |= dp[g[u][i]];
	}
}

inline void Clear(int u) {
	if (vis[u]) return;
	vis[u] = 1;
	dp[u].reset();
	int siz = g[u].size();
	for (int i = 0;i < siz;i++) Clear(g[u][i]);
}

inline void Solve() {
	for (int l = 1, r;l <= n;l += BSIZE) {
		r = Min(l + BSIZE - 1, n);
		for (int i = l;i <= r;i++) dp[fD[i]].set(i - l);
		memset(vis, 0, sizeof(vis));
		for (int i = 1;i <= n;i++) Dfs(fA[i]);
		cur.reset();
		for (int i = l;i <= r;i++) {
			//cout << dp[fA[i]] << endl;
			if (dp[fA[i]][i - l]) {
				mustdie[i] = 1;
				cur.set(i - l);
			}
		}
		//cout << cur << endl << endl;
		for (int i = 1;i <= n;i++) ans[i] += r - l + 1 - (cur | dp[fA[i]]).count();
		memset(vis, 0, sizeof(vis));
		for (int i = 1;i <= n;i++) Clear(fA[i]);
	}
	for (int i = 1;i <= n;i++) printf("%d ", (mustdie[i] ? 0 : ans[i] - 1));
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

P.S. 取 $S=64$ 可以线性空间 + 区间查询，缺点是常数较大，详见 [Dream and the Multiverse](https://www.luogu.com.cn/problem/P7349)。

---

## 作者：GreenDay (赞：5)

卡了一晚上常数终于卡过去了，觉得有必要写篇题解纪念一下qwq

这篇题解的边数是$4M$的，如果您需要边数是$2(N+M)$的题解请看另外一篇（

---

### 本题题解

看到题面，我们就知道要用**2-sat**来解决问题。我们有三元组`Node(date,person,status)`表示某个时间，某个人，是死(0)还是是活(1)的状态。朴素的建边是这样的：

对于$o=0$ **（1）**:

$(t,x,0)\rightarrow(t+1,y,0),(t+1,y,1)\rightarrow(t,x,1)$

对于$o=1$ **（2）**: 

$(t,x,1)\rightarrow(t,y,0),(t,y,1)\rightarrow(t,x,0)$

然后对于$t\in[1,t],x\in[1,n]$**（3）**

$(t,x,0)\rightarrow(t+1,x,0),(t+1,x,1)\rightarrow(t,x,1)$

我们把图建出来了，怎么统计答案呢？

我们进行**可达性统计**。首先我们找到一些“必死”的点，即

$(t+1,x,1)\rightarrow(t+1,x,0)$

这些点答案显然为0。忽略这些点，我们考虑一个点可以到达的点上，有多少个$(t+1,?,0)$，代表如果一个点要活，有多少个点得死。那么剩下的点都可以被统计到Live中去。

我们算一下复杂度：

- 图的规模$O(Tn+m)$

- 遍历的次数$O(n)$

总复杂度$O(Tn^2+nm)$，只有30分。所以我们要在**建图**和**遍历**上下功夫优化。

### 建图

我的建图方式不是最优的，但足以通过本题。

**(1)(2)类边是必要的，但是(3)类边存在大量的冗余。** **(1)(2)类边** 给整张图上标记了$4M$个**关键点**。我们保留这些关键点，对于一个人，我们根据$date$的大小关系，只在关键点之间建立 **(3)** 类边。容易发现我们建出了$4M$点边。

### 转移

我们使用`std::bitset`维护某个点的可达性。但是这样爆空间，所以我们可以**分块**，即每次只考虑$[l,r]$之间的点，其余点不考虑。

### 关于卡常数

- 不要跑tarjan，因为可以证明图是有向无环图。

- 使用基于`fread` `fwrite`的快读，快写。

- 不要用`set`,`map`

- 使用[预编译火车头](https://www.luogu.com.cn/blog/master-040626/yu-bian-yi-huo-ju-tou)

- bitset的块长设置为12500，正好可以在4次内跑完大数据而且不爆空间。

- 不要建出$(t+1,x,?)$，可以用某个人日期最大的那个点代替这个点。

- ......

总复杂度$O(\frac{nm}{w})$，勉强卡过。

```cpp
//火车头略
#include <bits/stdc++.h>
using namespace std;

inline char nc() {
    static char buf[500000], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 500000, stdin), p1 == p2) ? EOF : *p1++;
}
inline int read() {
    char ch = nc();
    int sum = 0;
    while (!(ch >= '0' && ch <= '9')) ch = nc();
    while (ch >= '0' && ch <= '9') sum = sum * 10 + ch - 48, ch = nc();
    return sum;
}

inline void write(int x) {
    char s[15] = {}, *p = s + 13, *q = s + 13;
    if (x < 0)
        putchar('-'), x = -x;
    do
        *(--p) = x % 10 + '0', x /= 10;
    while (x);
    while (p != q) putchar(*p++);
    putchar(' ');
}
const int N = 100010, M = 400050, B = 12500;

struct Node {
    int date;
    int person;
    bool status;
    Node() {}
    Node(int date, int person, bool status) : date(date), person(person), status(status) {}
    bool operator<(const Node &t) const {
        if (person != t.person)
            return person < t.person;
        if (date != t.date)
            return date < t.date;
        return status < t.status;
    }
    bool operator==(const Node &t) const {
        return person == t.person && status == t.status && date == t.date;
    }
} node[M];
int n, m, t, tot, maxdate[N];
int id(Node t) { return lower_bound(node + 1, node + 1 + tot, t) - node; }

vector<int> adj[M];
#define Add(u, v) adj[u].push_back(v)
void build() {
    t = read(), n = read(), m = read();
    static int o[N], t[N], x[N], y[N];
    for (int i = 0; i < m; ++i) {
        o[i] = read();
        t[i] = read();
        x[i] = read();
        y[i] = read();
        if (o[i] == 0) {
            if (t[i] > ::t) {
                i--, m--;
                continue;
            }
            node[++tot] = Node(t[i], x[i], true), node[++tot] = Node(t[i], x[i], false);
            node[++tot] = Node(t[i] + 1, y[i], true), node[++tot] = Node(t[i] + 1, y[i], false);
        } else {
            if (t[i] > ::t + 1) {
                i--, m--;
                continue;
            }
            node[++tot] = Node(t[i], x[i], true), node[++tot] = Node(t[i], x[i], false);
            node[++tot] = Node(t[i], y[i], true), node[++tot] = Node(t[i], y[i], false);
        }
    }
    //    for (int i = 1; i <= n; ++i) node[++tot] = Node(::t + 1, i, true), node[++tot] = Node(::t + 1, i,
    //    false);

    sort(node + 1, node + 1 + tot);
    tot = unique(node + 1, node + 1 + tot) - node - 1;
    for (int i = 0; i < m; ++i) {
        if (o[i] == 0) {
            int A = id(Node(t[i], x[i], false)), B = id(Node(t[i] + 1, y[i], false));
            Add(A, B);
            Add(B + 1, A + 1);
        } else {
            int A = id(Node(t[i], x[i], false)), B = id(Node(t[i], y[i], false));
            Add(A + 1, B);
            Add(B + 1, A);
        }
    }
    for (int i = 1; i < tot; ++i) {
        maxdate[node[i].person] = node[i].date;
        if (node[i].date != node[i + 1].date && node[i].person == node[i + 1].person) {
            Add(i - 1, i + 1);
            Add(i + 2, i);
        }
    }
}

bool must_die[N], mark[M];
bitset<B> vis[M];
int ans[N];

void dfs1(int x, int l, int r) {
    if (mark[x])
        return;
    mark[x] = 1;

    for (auto y : adj[x]) dfs1(y, l, r), vis[x] |= vis[y];
    int c = node[x].person;
    if (node[x].date == maxdate[c] && c >= l && c < r) {
        if (node[x].status == false)
            vis[x][c - l] = 1;
        else
            must_die[c] |= vis[x][c - l];
    }
}

void check() {
    for (int l = 1; l <= n; l += B) {
        for (int i = 1; i <= tot; ++i) vis[i].reset(), mark[i] = 0;
        for (int i = 1; i <= tot; ++i)
            if (!mark[i])
                dfs1(i, l, l + B);
    }
    int rest = n;
    for (int i = 1; i <= n; ++i)
        if (must_die[i])
            rest--;
    for (int i = 1; i <= n; ++i)
        if (!must_die[i])
            ans[i] = rest - 1;
}

void dfs2(int x, int l, int r) {
    if (mark[x])
        return;
    mark[x] = 1;

    for (auto y : adj[x]) dfs2(y, l, r), vis[x] |= vis[y];
    int c = node[x].person;
    if (node[x].date == maxdate[c] && !must_die[c]) {
        if (node[x].status == false && c >= l && c < r)
            vis[x][c - l] = 1;
        if (node[x].status == true)
            ans[c] -= vis[x].count();
    }
}

void update() {
    for (int l = 1; l <= n; l += B) {
        for (int i = 1; i <= tot; ++i) vis[i].reset(), mark[i] = 0;
        for (int i = 1; i <= tot; ++i)
            if (!mark[i])
                dfs2(i, l, l + B);
    }
    for (int i = 1; i <= n; ++i) write(ans[i]);
}

int main() {
    build();
    check();
    update();
}
```

---

## 作者：Great_Influence (赞：4)

首先，可以发现火星人只有死和活两种状态，且限制条件只有 $x$ 死 $y$ 死或者 $x$ 活 $y$ 死这两种限制(也就是二元限制)，因此直接考虑 $2-SAT$ 。

我们考虑这样建边:

对于每个火星人，将它拆成很多个部分，每个部分两个点分别代表它这个时刻是死还是活。设第 $i$ 个火星人时间 $t$ 的活点为 $(i,t,0)$ ，死点为 $(i,t,1)$ 。

然后，对于一个火星人，我们如下连边:

$$(i,t,0)\to(i,t+1,0)$$

$$(i,t+1,1)\to(i,t,1)$$

下面那条边是按照 $2-SAT$ 的对称性连的。

对于限制 $0$ ，连边为:

$$(x,t,0)\to(y,t+1,0)$$

$$(y,t+1,1)\to(x,t,1)$$

对于限制 $1$ ，连边为:

$$(x,t,1)\to(y,t,0)$$

$$(y,t,1)\to(x,t,0)$$

我们的问题是选择点 $(i,T+1,0)$ 时有多少个 $j$ 使得 $(j,T+1,1)$ 点一定被选择。对应到 $2-SAT$ 中就是有多少个 $(j,T+1,1)$ 在 $(i,T+1,0)$ 的后继节点中。这就变成了一道经典的有向图传递闭包问题。我们缩点后，直接跑 $DAGdp$ 。复杂度为 $O(Tnm)$ 。运用 $bitset$ 优化可以做到 $O(\frac{Tnm}{\omega})$ 。

这样显然过不去。但是可以发现，对于每个火星人，有用的点只有 $T+1$ 和它作为限制 $x$ 的点。我们只提出这些点，然后点数就由 $2Tn$ 变成了 $2(n+m)$ ，也就是 $300000$ 个左右。

然后复杂度为 $O(\frac{(n+m)m}{\omega})$ 。注意卡空间，因此我们以 $B$ 为单位分段计算。这样复杂度仍为 $O(\frac{(n+m)m}{\omega})$ ，而空间降到了 $O((n+m)B)$ 。不过注意 $B$ 越小常数越大，因此我们尽量选择大的 $B$ 。经过测试， $B=10^4$ 表现最优秀且不会 $MLE$ 。不过我还是写得太垃圾了，因此用了一些小手段卡常。

代码:

```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<iostream>
#include<climits>
#include<vector>
#include<bitset>
#include<queue>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
		if(nowps-Out>=1<<23)flush();
	}

	inline void getstr(char*q)
	{
		register char ch;
		for(ch=getc();!isgraph(ch);ch=getc());
		for(;isgraph(ch);ch=getc())*q++=ch;
		*q='\0';
	}

	inline void getwd(char&x){for(x=getc();!isupper(x);x=getc());}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void Chkmax(double&u,double v){u<v?u=v:0;}

inline void Chkmax(ll&u,ll v){u<v?u=v:0;}

inline void Chkmin(ll&u,ll v){u>v?u=v:0;}

const int MAXN=3e5+7,MN=5e4+7,MM=1e5+7;

static int n,m;

static struct quer{int op,t,x,y;}q[MM];

vector<int>tm[MN],dr[MN];

inline void init()
{
	read(n),read(n),read(m);
	Rep(i,1,m)
	{
		read(q[i].op),read(q[i].t),read(q[i].x),read(q[i].y);
		tm[q[i].x].pb(q[i].t);
	}
}

static int e;

vector<int>ed[MAXN],Ed[MAXN],nd[MAXN],rp[MAXN];

static int ls[MAXN];

static int dfn[MAXN],low[MAXN],dfs_clock,inq[MAXN],sta[MAXN],tp,z,tg[MAXN];

void tarjan(int u)
{
	dfn[u]=low[u]=++dfs_clock,inq[u]=1,sta[++tp]=u;
	for(int v:ed[u])if(!dfn[v])tarjan(v),Chkmin(low[u],low[v]);
	else if(inq[v])Chkmin(low[u],dfn[v]);
	if(dfn[u]==low[u])
	{
		++z;
		do
		{
			if(sta[tp]&1&&ls[sta[tp]/2+1])
				nd[z].pb(ls[sta[tp]/2+1]);
			else if(~sta[tp]&1&&ls[sta[tp]>>1])
				rp[z].pb(ls[sta[tp]>>1]);
			inq[sta[tp]]=0;
			tg[sta[tp--]]=z;
		}while(sta[tp+1]^u);
	}
}

const int lb=1e4;

bitset<lb>Ak[MAXN],as;

static int di[MAXN],ans[MAXN],d[MAXN],hs[MAXN];

queue<int>G;

inline void getans()
{
	Rep(i,1,e)for(int j:ed[i])
		if(tg[i]^tg[j])Ed[tg[j]].pb(tg[i]);
	Rep(i,1,z)
	{
		sort(Ed[i].begin(),Ed[i].end());
		Ed[i].resize(unique(Ed[i].begin(),Ed[i].end())-Ed[i].begin());
		for(int j:Ed[i])++d[j];
	}
	Rep(i,1,e)if(!rp[i].empty())hs[i]=1;
	for(register int l=1;l<=n;l+=lb)
	{
		memcpy(di+1,d+1,sizeof(int)*e);
		Rep(i,1,e)if(!di[i])G.push(i);
		register int r=l+lb-1,al=min(r,n)-l+1;
		while(!G.empty())
		{
			int u=G.front();G.pop();
			for(int j:nd[u])if(j>=l&&j<=r)Ak[u].set(j-l);
			for(int j:rp[u])if(j>=l&&j<=r&&Ak[u].test(j-l))
				ans[j]=-INT_MAX,as.set(j-l);
			for(int v:Ed[u])
			{
				Ak[v]|=Ak[u];
				if(!--di[v])G.push(v);
			}
		}
		Rep(i,1,e)
		{
			if(hs[i])
			{
				int w=al-(Ak[i]|as).count();
				for(int j:rp[i])if(as[j]>=0)ans[j]+=w;
			}
			Ak[i].reset();
		}
		as.reset();
	}
}

//1:dead,0:live

inline void solve()
{
	Rep(i,1,n)
	{
		tm[i].pb(1e6+7);
		sort(tm[i].begin(),tm[i].end());
		tm[i].resize(unique(tm[i].begin(),tm[i].end())-tm[i].begin());
		int las=-1;
		for(int j:tm[i])
		{
			dr[i].pb(++e);
			if(~las)ed[las*2-1].pb(e*2-1),ed[e<<1].pb(las<<1);
			las=e;
		}
		ls[las]=i;
	}
	Rep(i,1,m)
	{
		int u=dr[q[i].x][lower_bound(tm[q[i].x].begin(),
				tm[q[i].x].end(),q[i].t)-tm[q[i].x].begin()];
		int v=dr[q[i].y][lower_bound(tm[q[i].y].begin(),
				tm[q[i].y].end(),q[i].t+1-q[i].op)-tm[q[i].y].begin()];
		if(q[i].op==0)ed[u*2-1].pb(v*2-1),ed[v<<1].pb(u<<1);
		else ed[u<<1].pb(v*2-1),ed[v<<1].pb(u*2-1);
	}
	e<<=1;
	Rep(i,1,e)if(!dfn[i])tarjan(i);
	getans();
	Rep(i,1,n)write(ans[i]<0?0:ans[i]-1,'\n');
	flush();
}

int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：3)

属于是建出图会 bitset 不会分块 bitset 了，全场最佳憨笑人。

----------------------------------------

很多人说这个建图是 2-sat？              

其实就是一个很一般的问题吧。                  

我们考虑建立两种点，一种是死亡点一种是生存点，每个点以一个二元组 $(x,t)$ 表示点 $x$ 在时刻 $t$ 的状态，以下记 $a(x,y)$ 表示点 $x$ 在 $y$ 时刻生存，$d(x,y)$ 表示点 $x$ 在 $y$ 时刻死去两种状态，则：       

（这里题意可能有点不清楚，事实上条件是充要条件）

对于操作 $1$，考虑建边 $d(x,t) \rightarrow d(y , t + 1)$ 以及 $a(y , t + 1) \rightarrow a(x,t)$；

对于操作 $2$，考虑建边 $a(x,t) \rightarrow d(y,t)$ 以及 $a(y,t) \rightarrow d(x,t)$；

接着一个很显然的性质：如果知道一个点在一个时刻是活，那么在这个时刻之前这个点都是活；如果知道一个点在一个时刻是死，那么在这个时刻之后这个点都是死。         

所以连边 $d(x,t) \rightarrow d(x,t + 1),a(x,t) \rightarrow a(x,t - 1)$ 即可。                

由于我们只要知道一个点活下来后哪些点必死，所以就是询问分别求出 $(i \in [1,n],a(i,T + 1))$ 能到达多少个 $(j \in [1,n],d(j,T + 1))$。        

再仔细观察一下图，发现这是个 DAG（如果不是 DAG 缩一下点就行了），那么现在就是询问 DAG 上的点对连通性问题。                

这时候只能考虑 bitset 了，但是它空间开不下！！！！        

这时候我们可以考虑一个比较经典的套路：分组 bitset。            

我们分组，每次只将每组的贡献扔进所有点里面去，设每组的大小为 $S$ 则我们此部分需要的时间复杂度为 $O(\frac{n ^ 2}{S})$。        

由于总的点的数量级为 $O(n + m)$，由于我们每次只处理一组的点的贡献，即询问是否能联通组内的点，bitset 就只用开 $S$ 大小就够了。       

那么对于在 DAG 上维护 bitset 的时间复杂度就是 $O(\frac{n}{S} \times (n + m) \times S \times \frac{1}{w}) = O(\frac{n ^ 2 + nm}{w})$，空间复杂度则是 $O(\frac{S(n + m)}{w})$。               

最后总的时间复杂度为 $O(\frac{n ^ 2}{S} + \frac{n ^ 2 + nm}{w})$，空间复杂度为 $O(\frac{S(n + m)}{w})$，个人写的 $O(2n + 4m)$ 的节点数，$S$ 取得 $1 \times 10 ^ 4$，轻微卡常。

```cpp
/*
只记得这道题是 bitset 了
考虑怎么打暴力，如果指定一个人活，那么倒着扫：
碰到一个询问，如果其中有一个已经确定了，那么对于另外一个人，如果被推出来是活的那就说明前面都是活，否则说明后面都是死
估计是要建个图什么的用 bitset 来跑？预测是个 DAG
不妨我们开 2m 个点表示各个时间上的点的情况。
欸那我建 4m 个节点，每次还附带死/没死呢
我用 1 表示死那么我每次就是 bst[x] = or_{bst[to][0]} 之类的递推了 
那就是个 dag 了，可以做了！
After reading the solution
原来还要分块 bst，呕吐。
但是我完全不会啊！这个为什么可以分块为什么为什么为什么！
hhh 妙啊妙啊妙啊，果然脑残就是脑残，一时是脑残一世都是脑残 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 5e5 + 5 , B = 1e4 + 5;
int n,m,T,tot,beg[Len];
map<int,int> dX[Len][2];
set<int> st[Len][2];
set<int>::iterator it; 
bitset<B> fx[Len],KILLMYSELF;
bitset<Len> vis,SUICIDE;
int head[Len],cnt,L,R,ans[Len],bel[Len];
struct node
{
	int next,to;
}edge[Len << 1];
void add(int from,int to)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
void dfs(int x)
{
	if(vis[x]) return;
	vis[x] = 1;
	fx[x].reset();
	if(L <= bel[x] && bel[x] <= R) fx[x].set(bel[x] - L , 1);
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		dfs(to);
		fx[x] |= fx[to];
	}
}
int main()
{
	scanf("%d %d %d",&T,&n,&m);
	for(int i = 1 ; i <= m ; i ++)
	{
		int u,v,s,t;scanf("%d %d %d %d",&u,&v,&s,&t);
		if(!u) 
		{
			st[s][0].insert(v);
			st[t][0].insert(v + 1);
			if(!dX[s][0][v]) dX[s][0][v] = ++ tot;
			if(!dX[t][0][v + 1]) dX[t][0][v + 1] = ++ tot;
			add(dX[s][0][v] , dX[t][0][v + 1]);
			st[s][1].insert(v);
			st[t][1].insert(v + 1);
			if(!dX[s][1][v]) dX[s][1][v] = ++ tot;
			if(!dX[t][1][v + 1]) dX[t][1][v + 1] = ++ tot;
			add(dX[t][1][v + 1] , dX[s][1][v]);
		}
		else
		{
			st[s][1].insert(v);
			st[t][0].insert(v);
			if(!dX[s][1][v]) dX[s][1][v] = ++ tot;
			if(!dX[t][0][v]) dX[t][0][v] = ++ tot;
			add(dX[s][1][v] , dX[t][0][v]);
			st[s][0].insert(v);
			st[t][1].insert(v);
			if(!dX[s][0][v]) dX[s][0][v] = ++ tot;
			if(!dX[t][1][v]) dX[t][1][v] = ++ tot;
			add(dX[t][1][v] , dX[s][0][v]);
		}
	}
	for(int i = 1 ; i <= n ; i ++) 
	{
		if(!dX[i][0][T + 1]) dX[i][0][T + 1] = ++ tot , st[i][0].insert(T + 1);
		if(!dX[i][1][T + 1]) dX[i][1][T + 1] = ++ tot , st[i][1].insert(T + 1);
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		vector<int> LYC;LYC.clear();
		for(it = st[i][0].begin() ; it != st[i][0].end() ; it ++) LYC.push_back(*it);
		for(int j = 0 ; j < LYC.size() - 1 ; j ++) add(dX[i][0][LYC[j]] , dX[i][0][LYC[j + 1]]); 
		LYC.clear();
		for(it = st[i][1].begin() ; it != st[i][1].end() ; it ++) LYC.push_back(*it);
		for(int j = LYC.size() - 1 ; j >= 1 ; j --) add(dX[i][1][LYC[j]] , dX[i][1][LYC[j - 1]]);
	}
	for(int i = 1 ; i <= n ; i ++) beg[i] = dX[i][1][T + 1] , bel[dX[i][0][T + 1]] = i;
	int BB = 10000;
	for(int i = 1 ; i <= n ; i += BB)
	{
		L = i;
		R = min(n , L + BB - 1);
		vis.reset();KILLMYSELF.reset();
		for(int j = 1 ; j <= n ; j ++) dfs(beg[j]);
		for(int j = L ; j <= R ; j ++) if(fx[beg[j]][j - L]) KILLMYSELF.set(j - L , 1) , SUICIDE.set(j , 1);
		for(int j = 1 ; j <= n ; j ++) ans[j] += (R - L + 1) - (KILLMYSELF | fx[beg[j]]).count();
	} 
	for(int i = 1 ; i <= n ; i ++)
	{
		if(SUICIDE[i]) printf("0 ");
		else printf("%d ",ans[i] - 1);
	}
	return 0;
}
```

---

## 作者：BruceW_07 (赞：2)

# [JSOI2019]精准预测  解题报告

[传送门](https://www.luogu.com.cn/problem/P5332)

## 题面

### 题意

有 $T$ 个时刻, $n$ 个居民, $m$ 条预言 $(ty,t,x,y)$, 含义为 :

- $ty==0$, 在 $t$ 时刻, 若 $x$ 是死亡状态, 则在 $t+1$ 时刻, $y$ 是死亡状态.
- $ty==1$, 在 $t$ 时刻, 若 $x$ 是生存状态, 则在 $t$ 时刻, $y$ 是死亡状态.

每一时刻都可能有居民死去, 有些居民会在 $0$ 时刻死去. (由你决定)

对每一个居民求出, 有多少个除了他本身的居民**有可能**和他一起活到 $T+1$ 时刻.

### 数据范围

$T \le 10^6, n\le 5\times10^4,m \le 10^5.$

<br/>

## 思路

$bool$ 变量 + 限制条件, 看到这两个元素在一起第一反应就应该是 $2-SAT$.

但毕竟不是板子题, 还是需要一些特殊处理.

让我们分步骤来吧.

### 建点 & 连边

显然, 我需要把每一个居民拆成代表若干个时刻的点, 如果直接拆成 $T$ 个点的话显然会炸, 那么对于点 $u$, 对于每一条预言 $(ty,t,u,v)$, 我们都新建一个时刻为 $t$ 的点. 全部预言都处理完后, 再对每个点建一个时刻为 $T+1$ 的点, 表示它最终的生死状态.

然后对于每条预言 $(ty,t,u,v)$, 我们不需要对 $v$ 建一个时刻为 $t$ (或 $t+1$) 的点, 只需要在 $v$ 的所有时刻的点中找出第一个时刻 $\ge t$ (或 $>t$) 的点, 并进行连边.

除此之外, 对于每个点 $u$, 我们还需要在它表示死亡状态的点中, 按照时刻从小到大往后连边; 在它表示死亡状态的点中, 按照时刻从大到小往前连边.

这样, 点数就是 $2n+2m \le 3 \times 10^5$, 边数为 $2m+2m \le 4 \times 10^5.$ 

### 统计答案

把图建出来后, 再考虑如何计算答案.

与一般的 $2-SAT$ 板子不同, 这题不是要求我们判断是否有可行方案或输出一个可行方案, 所以我们就不能直接套 $Tarjan$.

考虑如何计算答案.

设 $d'_u,l'_u$ 分别表示点 $u$ 在时刻 $T+1$ 时表示死亡状态和生存状态的点.

对于点 $u$, 设 $num_u=\sum_{v\in V\ and \ v \not= u} [path(l'_u,d'_v)]$, 其中 $[path(x,y)]=1$ 表示存在一条由 $x$ 到 $y$ 的路径. 则 $ans_u=n-1-num_u.$

特别地, 对于 $[path(l'_u,d'_u)]=1$ 的点 $u$, $ans_u=0$, 并且会使得总体答案 $-1.$

假设我们建出来的图是一个 $DAG$ (有向无环图), 那么我们可以用 $\rm bitset$ 辅助 $DP$, 计算出每个点 $u$ 的 $num_u$, 总时间复杂度为 $O\left(\frac{n(2n+2m)}{w}\right) (w=32)$, 约为 $5\times10^8$.

由于内存限制, $\rm bitset$ 不能直接开到 $n$, 所以我们需要分次进行 $DP$. 虽然看起来 $\rm bitset$ 的大小和时间复杂度没什么关系, 但为了避免 $DP$ 初始化,赋值等操作带来的常数, 还是尽量越大越好.上面讨论的是 $DAG$ 的情况, 而实际上, 我们可以直接证明我们建出来的这张图就是一个 $DAG$.

### 证明原图是一个 $DAG$

我们考虑把所有点分为 $d$ (死亡状态), $l$ (生存状态), 然后分类证明.

为了方便描述, 我们规定

- $x \rightarrow y$ 表示存在一条从 $x$ 到 $y$ 的路径, 且 $x$ 所代表的时刻小于 $y$ 所代表的时刻.
- $y \leftarrow x$ 表示存在一条从 $x$ 到 $y$ 的路径, 且 $x$ 所代表的时刻大于 $y$ 所代表的时刻.
- $x \Rightarrow y$ 表示存在一条从 $x$ 到 $y$ 的路径, 且 $x$ 所代表的时刻小于等于 $y$ 所代表的时刻.
- $y \Leftarrow x$ 表示存在一条从 $x$ 到 $y$ 的路径, 且 $x$ 所代表的时刻大于等于 $y$ 所代表的时刻.

按照上文所述的连边方法, 会存在以下这几种边.

- $d \rightarrow d$
- $l \leftarrow l$
- $l \Rightarrow d$
- $d \Leftarrow l$

首先考虑 $d$. 由于不存在从 $d$ 出发到 $l$ 的边, 所以若存在一个从 $d$ 到 $d$ 的环, 则环上的点一定都是 $d$. 又因为 $d$ 只能连向时刻比它大的 $d$, 所以不可能连回自己. 故不存在一个以 $d$ 为起点, $d$ 为终点的环.

再来考虑 $l$. 同样, 由于不存在从 $d$ 出发到 $l$ 的边, 所以若存在一个从 $l$ 到 $l$ 的环, 则环上的点一定都是 $l$, 又因为 $l$ 只能连向时刻比它小的 $l$, 所以不可能连回自己. 故不存在一个一 $l$ 为起点, $l$ 为终点的环.

故, 原图上不存在环. 即证明了原图是一个 $DAG$.

那么, 我们就可以按照上述的方法计算出 $num_u$ 从而计算出 $ans_u$ 了.

### ~~没了~~

还有一些小细节, 比如为了避免 $[path(l'_u,d'_u)=1$ 的点的影响, 需要做两遍 $DP$ (本人只想到这种方法), 还有连边时不要把 $t$ 的关系弄混了.

还有, 这道题需要疯狂卡常, 我这份代码卡到最后也只能随缘过...

赠送([@GreenDay](https://www.luogu.com.cn/blog/master-040626/#)的)[卡常火车头](https://www.luogu.com.cn/blog/master-040626/yu-bian-yi-huo-ju-tou#)

<br/>

## 代码

```cpp
#pragma GCC optimize(3) // 手动开了个 O3 优化
#include<bits/stdc++.h>

using namespace std;

#define pb push_back
#define sz(x) (int)(x).size()
#define mkp make_pair
#define fi first
#define se second
#define lb lower_bound

const int _=5e5+7;
const int X=12500;

bool be;
int n,m,T;
int de[_],tms[_],bel[_],np,num[_],p[_];
int lst[_],nxt[_],to[_],tot;
bool mst[_];
bitset<X+7> f[_];
queue<int> q;
vector<pair<int,int> > ve[_];
struct edge{
	int p,t,u,v;
#define p(i) e[i].p
#define t(i) e[i].t
#define u(i) e[i].u
#define v(i) e[i].v
}e[_];
bool en;

bool cmp(edge a,edge b){ return a.t<b.t; }

void add(int x,int y){
	nxt[++tot]=lst[y]; to[tot]=x; lst[y]=tot; de[x]++;            // 建反向边
}

void _init(){
	cin>>T>>n>>m;
	for(int i=1;i<=m;i++) cin>>p(i)>>t(i)>>u(i)>>v(i);
	sort(e+1,e+1+m,cmp);
	for(int i=1;i<=m;i++){
		int u=u(i),t=t(i),sz=sz(ve[u]);
		if(!sz||ve[u][sz-1].fi!=t) ve[u].pb(mkp(t,++np)),++np;
	}
	for(int i=1;i<=n;i++){
		ve[i].pb(mkp(T+1,++np)); ++np;
		bel[np]=bel[np-1]=i;
		p[i]=np;
		for(int j=0;j<sz(ve[i])-1;j++){
			add(ve[i][j].se,ve[i][j+1].se);
			add(ve[i][j+1].se+1,ve[i][j].se+1);
		}
	}
	for(int i=1;i<=m;i++){
		int u=u(i),v=v(i),t=t(i);
		pair<int,int> tmp=mkp(t,0);
		int t1=lb(ve[u].begin(),ve[u].end(),tmp)-ve[u].begin(),t2=lb(ve[v].begin(),ve[v].end(),tmp)-ve[v].begin();
		if(!p(i)&&ve[v][t2].fi==t) t2++;
		if(p(i)) add(ve[u][t1].se+1,ve[v][t2].se),add(ve[v][t2].se+1,ve[u][t1].se);
		else add(ve[u][t1].se,ve[v][t2].se),add(ve[v][t2].se+1,ve[u][t1].se+1);
	}
}

void _dp(int L,int R){
	for(int i=1;i<=np;i++){
		f[i].reset(); tms[i]=0;
		if(!de[i]) q.push(i);
	}
	while(!q.empty()){
		int u=q.front(); q.pop();
		if(u%2&&!mst[bel[u]]&&bel[u]>=L&&bel[u]<=R) f[u][bel[u]-L]=1;
		for(int i=lst[u];i;i=nxt[i]){
			int v=to[i];
			f[v]|=f[u];
			tms[v]++;
			if(tms[v]==de[v]){ q.push(v); tms[v]++; }
		}
	}
}

void _run(){
	int ls=0;
	for(int i=1;i<=n;i+=X){
		_dp(i,i+X-1);
		for(int j=i;j<=min(n,i+X-1);j++)
			if(f[p[j]][j-i]) mst[j]=1,ls++;
	}
    
	for(int i=1;i<=n;i+=X){
		_dp(i,i+X-1);
		for(int j=1;j<=n;j++) num[j]-=f[p[j]].count();
	}

	for(int i=1;i<=n;i++)
		if(mst[i]) cout<<0<<' ';
		else cout<<n-1+num[i]-ls<<' ';
    
	cout<<endl;
}
int main(){
#ifndef ONLINE_JUDGE
	freopen("9.in","r",stdin);
	freopen("x.out","w",stdout);
#endif
	ios::sync_with_stdio(false);
	clock_t st=clock();
	_init();
	st=clock();
	_run();
	cerr<<(double)(clock()-st)/CLOCKS_PER_SEC<<endl;
	cerr<<(double)1.0*(&en-&be)/(1<<20)<<endl;
	return 0;
}
```

 



---

## 作者：Jerrywang09 (赞：1)

非常有趣的图论题！

首先，容易想到如何建立点：对于每个时间下的每一个人，建立两个点，分别表示生存或死亡。但这样点数太大了，而很多点又是无用的。

考虑只保留限制关系中提及的点。用 `map` 存储人 $x$ 在时间 $t$ 下的“生存”状态所代表的点 `mp[x][t]`，“死亡”状态所代表的点即 `mp[x][t]^1`。这样，点数就是 $O(n+m)$ 的，可以接受。

考虑如何建边。一个人如果已经死了，则之后他必须一直是死的。其它的边由输入即可得。注意原命题和逆否命题都要建边。

注意到上述的建边保证了一个人不可能死而复生，并且由于时间的维度，因此这张图是一个 DAG，不需要 Tarjan 找强连通。

我们所关心的，就是一个人是否最终无论如何都必死；以及假设 $x$ 最终活下来了，有多少可能活下来的 $y$ 需要死。设必死的人的数目是 $die$，后者 $y$ 的数目记作 $res_x$。因此，如果 $x$ 必死，则答案为 $0$，否则答案为 $n-1-die-res_x$。

上述问题可以用 `bitset` 处理出 DAG 的可达性解决。不考虑内存限制，设 $f(u)$ 为 $u$ 的可达点集合，则得到 $50$ 分代码：

```cpp
// P5332 [JSOI2019] 精准预测
#include <cstdio>
#include <iostream>
#include <vector>
#include <bitset>
#include <map>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=50010, M=100010;
using namespace std;
char buf[1<<21], *p1=buf, *p2=buf;
#define gc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
    int x=0, f=1; char c=gc();
    while(c<'0' || c>'9') c=='-' && (f=-1), c=gc();
    while('0'<=c && c<='9') x=(x<<3)+(x<<1)+c-'0', c=gc();
    return x*f;
}

int T, n, m, cnt=2, res[N], die;
map<int, int> mp[N]; vector<int> g[M];
inline int getid(int t, int x)
{
    if(!mp[x][t]) mp[x][t]=cnt, cnt+=2;
    return mp[x][t];
}
inline void add(int u, int v) {g[u].push_back(v);}
bool vis[M]; bitset<M> f[M], flag, all;
inline void dfs(int u)
{
    if(vis[u]) return;
    f[u][u]=1, vis[u]=1;
    for(int v:g[u])
    {
        if(!vis[v]) dfs(v);
        f[u]|=f[v];
    }
}

int main()
{
#ifdef Jerrywang
    freopen("E:/OI/in.txt", "r", stdin);
#endif
    T=read(), n=read(), m=read();
    rep(i, 1, n) mp[i][T+1]=cnt, cnt+=2;
    rep(i, 1, m)
    {
        int c=read(), t=read(), x=read(), y=read();
        if(c==0)
        {
            int u=getid(t, x), v=getid(t+1, y);
            add(u^1, v^1), add(v, u);
        }
        else
        {
            int u=getid(t, x), v=getid(t, y);
            add(u, v^1), add(v, u^1);
        }
    }
    rep(x, 1, n)
    {
        auto it=mp[x].begin(), jt=next(it);
        for(; jt!=mp[x].end(); ++it, ++jt)
        {
            int u=it->second, v=jt->second;
            add(u^1, v^1), add(v, u);
        }
    }
    rep(x, 1, n)
    {
        int u=getid(T+1, x);
        dfs(u);
        // rep(i, 1, cnt) if(f[u][i])
        // {
        //     printf("%d ", i);
        // }
        // puts("");
        all[u^1]=1;
        if(f[u][u^1]) ++die, flag[u^1]=1;
    }
    all^=flag;
    rep(x, 1, n)
    {
        int u=getid(T+1, x);
        if(flag[u^1]) res[x]=-1;
        else res[x]=(f[u]&all).count();
    }
    rep(i, 1, n)
    {
        if(res[i]<0) printf("0 ");
        else printf("%d ", n-1-die-res[i]);
    }

    return 0;
}
```

考虑优化。重新定义 $f(u)$ 为从点 $u$ 可以推出的必死的人的集合。然后神操作：分块处理。取块长 $B=10^4$，每次只统计对于 $x$ 要最终活着，$[l,r]$ 中的哪些人要死。

代码中使用了 `__gnu_pbds::tree` 代替 `map`，时间和空间均有显著进步。

```cpp
// P5332 [JSOI2019] 精准预测
#include <bits/stdc++.h>
#include <bits/extc++.h>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=50010, M=500010, B=10000;
using namespace std;
using namespace __gnu_pbds;
char buf[1<<21], *p1=buf, *p2=buf;
#define gc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
    int x=0, f=1; char c=gc();
    while(c<'0' || c>'9') c=='-' && (f=-1), c=gc();
    while('0'<=c && c<='9') x=(x<<3)+(x<<1)+c-'0', c=gc();
    return x*f;
}

int T, n, m, cnt=2, res[N], die;
tree<int, int> mp[N]; vector<int> g[M];
inline int getid(int t, int x)
{
    if(!mp[x][t]) mp[x][t]=cnt, cnt+=2;
    return mp[x][t];
}
inline void add(int u, int v) {g[u].push_back(v);}
bool vis[M]; bitset<B> f[M], flag, all;
// f[u][x]:从点u开始推，是否能推出x+l这个人死；flag:必死的人的集合；all:非必死的人的集合
inline void dfs(int u)
{
    if(vis[u]) return;
    vis[u]=1;
    for(int v:g[u])
    {
        if(!vis[v]) dfs(v);
        f[u]|=f[v];
    }
}

int main()
{
#ifdef Jerrywang
    freopen("E:/OI/in.txt", "r", stdin);
#endif
    T=read(), n=read(), m=read();
    rep(i, 1, n) mp[i][T+1]=cnt, cnt+=2;
    rep(i, 1, m)
    {
        int c=read(), t=read(), x=read(), y=read();
        if(c==0)
        {
            int u=getid(t, x), v=getid(t+1, y);
            add(u^1, v^1), add(v, u);
        }
        else
        {
            int u=getid(t, x), v=getid(t, y);
            add(u, v^1), add(v, u^1);
        }
    }
    rep(x, 1, n)
    {
        auto it=mp[x].begin(), jt=next(it);
        for(; jt!=mp[x].end(); ++it, ++jt)
        {
            int u=it->second, v=jt->second;
            add(u^1, v^1), add(v, u);
        }
    }
    for(int l=1, r=B; l<=n; l=r+1, r=l+B-1)
    {
        r=min(r, n);
        all.reset(), flag.reset();
        rep(u, 1, cnt) f[u].reset(), vis[u]=0;
        rep(x, l, r)
        {
            int u=getid(T+1, x);
            f[u^1][x-l]=1, all[x-l]=1;
        }
        rep(u, 1, cnt) dfs(u);
        rep(x, l, r)
        {
            int u=getid(T+1, x);
            if(f[u][x-l]) ++die, flag[x-l]=1, res[x]=-1;
        }
        all^=flag;
        rep(x, 1, n) if(~res[x])
        {
            int u=getid(T+1, x);
            res[x]+=(f[u]&all).count();
        }
    }
    rep(x, 1, n)
    {
        if(res[x]<0) printf("0 ");
        else printf("%d ", n-1-die-res[x]);
    }

    return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：1)

我们首先发现每个人每个时刻只有生死，所以我们可以建一个 2-sat 模型。每个人对应 $T+1$ 个节点，表示这个人在每个时刻的生死。

那么，题目的条件可以直接在这个模型上面建图，还要注意第 $t$ 秒死亡可推出第 $t+1$ 秒死亡和第 $t+1$ 秒存活能推出第 $t$ 秒存活的两个隐藏条件。

这样子点数是 $\mathcal O(nT)$ 的，不可接受。我们发现这张图有很多没用的点，我们只需要建出来：第 $T+1$ 时刻的，或者被 $m$ 个条件提及到的点即可。点数降至 $\mathcal O(n+m)$。

考虑计算答案，首先你不难发现建出的这张图是一个 DAG，假设 $A(i,t)$ 表示第 $i$ 个人在第 $t$ 秒存活，$D(i,t)$ 反之。那么如果 $A(i,T+1)\to D(i,T+1)$，也就是第 $i$ 个点不能存活，这样的点我们不管（至于怎么找见下文）。我们任务就是找出每个可存活的点 $u$，$A(u,T+1)$ 可以推出多少个可存活点的 $D(*,T+1)$。

首先这是 DAG 联通的问题，只能使用 bitset，但是直接开 bitset 开不下，这要求我们对分段求解。具体的我们每 $B$ 个点一段，沿着拓扑序往回跑即可。

最终我们可以用一个 bitset $ex$ 统计哪些点能够存活，我们只需要数 $A(u,T+1)$ 和 $ex$ 的与运算下的 $1$ 个数即可。

取 $B=2^{13}$ 可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MR=5e5+5;
const int B=8192;
const int MAXN=5e4+5;
bool Mbe;
int t,n,m,tot,cnt;
int qo[MR],qt[MR],qx[MR],qy[MR],p[MR],d[MR],ans[MAXN];
bool used[MAXN];
map<int,int> mp[MAXN][2];
vector<int> edg[MR],reg[MR];
bitset<B> bs[MR],ex;
bool Med;
int main(){
	ios::sync_with_stdio(false);
//	freopen("ex_predict3.in","r",stdin);
//	freopen("predict.out","w",stdout);
	cerr<<"Memory: "<<(&Mbe-&Med)*1.0/1024/1024<<endl;
	cin>>t>>n>>m;
	for(int i=1;i<=n;i++) mp[i][0][t+1]=mp[i][1][t+1]=0;
	for(int i=1;i<=m;i++){
		cin>>qo[i]>>qt[i]>>qx[i]>>qy[i];
		if(qo[i]==0){
			mp[qx[i]][0][qt[i]]=mp[qx[i]][1][qt[i]]=
			mp[qy[i]][0][qt[i]+1]=mp[qy[i]][1][qt[i]+1]=0;
		}else{
			mp[qx[i]][0][qt[i]]=mp[qx[i]][1][qt[i]]=
			mp[qy[i]][0][qt[i]]=mp[qy[i]][1][qt[i]]=0;
		} 
	}
	for(int i=1;i<=n;i++) for(int j:{0,1}){
		int l=tot+1,r;
		for(auto &k:mp[i][j]) k.second=++tot;
		r=tot;
		if(j==0) for(int i=l;i<r;i++) edg[i].push_back(i+1);
		else for(int i=l;i<r;i++) edg[i+1].push_back(i);
	}
	for(int i=1;i<=m;i++){
		if(qo[i]==0){
			edg[mp[qx[i]][0][qt[i]]].push_back(mp[qy[i]][0][qt[i]+1]);
			edg[mp[qy[i]][1][qt[i]+1]].push_back(mp[qx[i]][1][qt[i]]);
		}else{
			edg[mp[qx[i]][1][qt[i]]].push_back(mp[qy[i]][0][qt[i]]);
			edg[mp[qy[i]][1][qt[i]]].push_back(mp[qx[i]][0][qt[i]]);
		}
	}
	for(int i=1;i<=tot;i++) for(int j:edg[i]) d[j]++,reg[j].push_back(i);
	queue<int> q;
	for(int i=1;i<=tot;i++) if(d[i]==0) q.push(i);
	while(!q.empty()){
		int u=q.front();q.pop();
		p[++cnt]=u;
		for(int v:edg[u]) if(--d[v]==0) q.push(v);
	} 
	for(int i=1;i<=n;i++) used[i]=true;
	for(int l=1,r=0;r!=n;l=r+1){
		int cnt=0; 
		r=min(n,l+B-1);
		ex.reset();
		for(int i=1;i<=tot;i++) bs[i].reset();
		for(int i=l;i<=r;i++) bs[mp[i][0][t+1]][i-l]=true;
		for(int i=tot;i>=1;i--)if(bs[p[i]].any()){
			for(int j:reg[p[i]]) bs[j]|=bs[p[i]];
		}
		for(int i=l;i<=r;i++){
			if(bs[mp[i][1][t+1]][i-l]) used[i]=false;
			else ex[i-l]=true,cnt++;
		} 
		for(int i=1;i<=n;i++) if(used[i]){ 
			ans[i]+=cnt-(bs[mp[i][1][t+1]]&ex).count();
		} 
	} 
	for(int i=1;i<=n;i++) cout<<(used[i]?ans[i]-1:0)<<" \n"[i==n];
}
```

---

## 作者：ZCETHAN (赞：1)

[传送门](https://www.luogu.com.cn/problem/P5332)

[更好的体验](https://www.cnblogs.com/ZCETHAN/p/15965927.html)

## 题目大意

现在有 $n$ 个人和 $m$ 条限制，对于每条限制，包含一个 $c,t,x,y$。总时间是 $T$。

若 $c=0$，则表示如果在 $t$ 时刻第 $x$ 个人死了，那么在 $t+1$ 时刻第 $y$ 个人也死了。
若 $c=1$，则表示如果在 $t$ 时刻第 $x$ 个人活着，那么在 $t$ 时刻第 $y$ 个人就死了。

现在你需要对每个人求出在 $T+1$ 可能与它同时活着的人的个数。如果这个人在 $T+1$ 一定死了，那么输出 `0`。

## Solution

**首先考虑一个暴力**，这是一个非常显然的 2-SAT 问题。我们把每个人分成 $T+1$ 个，对于二元组 $(x,t)$ 表示第 $x$ 个人的 $t$ 时刻。那么对于每个二元组，只有两种情况——活着或者死了，并且是相斥的两种状态。

考虑对一些限制连边。
我们用 $(x,t,0)$ 表示 $(x,t)$ 的死亡状态点，$(x,t,1)$ 表示 $(x,t)$ 的存活状态点。那么有以下一些连边。

1. $(x,t,0)\to (x,t+1,0)$，表示如果 $t$ 时刻 $x$ 已经挂了，那么 $t+1$ 一定挂了。
2. $(x,t,1)\to (x,t-1,1)$，同理，表示 $t$ 时刻 $x$ 活着意味着 $t-1$ 也一定活着。
3. 对于题目中第一种限制，有 $(x,t,0)\to (y,t+1,0)$ 和逆否命题 $(y,t+1,1)\to (x,t,1)$。
4. 对于题目中第二种限制，有 $(x,t,1)\to (y,t,0)$ 和逆否命题 $(y,t,1)\to (x,t,0)$。

首先明确不需要 Tarjan，因为容易看出已经是 DAG 了。

然后考虑题目要求什么。实际上是对每个点 $x$，从 $(x,T+1,1)$ 能到达多少个 $(y,T+1,0)$，然后 $n-cnt-1$ 就是这个点的答案。什么意思？就是假设 $x$ 是活着的，那么能得到一些在 $T+1$ 必然死掉的人，然后用总人数减去这个人数再刨去自己就是可能与 $x$ 同时存活的人数了。

---

**然后优化这个残忍的暴力**，考虑上面的光是建图就是 $O(nT)$ 了，非常不靠谱。那考虑把一些没有用的点杀了，首先一点就是没有在询问中出现的点，一定是没有用的。于是考虑对每个点 $x$ 开一个 vector 存它出现过的时刻，然后建图的时候只存这几个点就好了。

这样点数是 $O(2m+n)$ 的，其实仔细一想可以更优，询问中出现了 $x$ 和 $y$，其实只要 $x$ 存 $t$ 就行了，$y$ 没有必要。因为如果 $y$ 后续没有作为 $x$ 出现在询问中的话，对最后结果没有影响，可以直接用大于它的最小出现的那个节点代替它。是一样的。（不过这没有关系，没看懂也不要紧）

这样点数就优化下来了，同时边数也下来了。

---

**然后考虑空间的问题**，发现如果对每个节点暴力跑肯定是会炸的，那么容易想到用 bitset 优化这个过程。可是如果对每个节点开一个大小为 $n$ 的 bitset 我是想都不敢想。所以这里用到一个小 trick——平衡复杂度，既然两边一边是空间大，一边是时间大，那么何不平衡一波。我们考虑把 $n$ 个人分批处理，每次处理 $S$ 个人，这样空间复杂度就成了 $O(\dfrac{nS}{8})$，卡卡可以过去，时间就是 $O(\dfrac{n(n+m)}{S})$，$S=10000$ 可以过去。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf (1<<30)
#define INF (1ll<<60)
#define pb push_back
#define pii pair<int,int>
#define fi first
#define se second
#define mkp make_pair
#define pll pair<ll,ll>
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
using namespace std;
const int MAXN=1e6+10;
const int MAXM=300010;
vector<int> used[MAXN],e[MAXM];
map<int,int> mp[MAXN][2];//mp[x][0/1][t] 表示点 (x,t,0/1) 的编号
bitset<10010> dp[MAXM],tmp;
int tot=0,deg[MAXM];
void sprd(){
	queue<int> q;
	rep(i,1,tot) for(int s:e[i]) deg[s]++;
	rep(i,1,tot) if(!deg[i]) q.push(i);
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int s:e[x]){
			dp[s]|=dp[x];
			if(--deg[s]==0) q.push(s);
		}
	}
}//直接拓扑一下
struct Query{
	int c,t,x,y;
	void input(){
		cin>>c>>t>>x>>y;
		used[x].pb(t);//可以加上 used[y].pb(t);
	}
}q[MAXN];
int ans[MAXN];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int T,n,m;
	cin>>T>>n>>m;
	rep(i,1,m) q[i].input();
	rep(i,1,n) used[i].pb(T+1),sort(used[i].begin(),used[i].end()),
	used[i].erase(unique(used[i].begin(),used[i].end()),used[i].end());
	rep(i,1,n){
		for(int t:used[i]) mp[i][0][t]=++tot,mp[i][1][t]=++tot;
		rep(j,0,(int)used[i].size()-1){
			if(j) e[mp[i][1][used[i][j-1]]].pb(mp[i][1][used[i][j]]);
			if(j<(int)used[i].size()-1)
				e[mp[i][0][used[i][j+1]]].pb(mp[i][0][used[i][j]]);
		}
	}
	rep(i,1,m){
		if(q[i].c==0){
			int v=upper_bound(used[q[i].y].begin(),used[q[i].y].end(),q[i].t)-used[q[i].y].begin();
			int to=used[q[i].y][v];
			e[mp[q[i].y][0][to]].pb(mp[q[i].x][0][q[i].t]);
			e[mp[q[i].x][1][q[i].t]].pb(mp[q[i].y][1][to]);
//			cerr<<mp[q[i].y][0][to]<<' '<<mp[q[i].x][0][q[i].t]<<'\n';
//			cerr<<mp[q[i].x][1][q[i].t]<<' '<<mp[q[i].y][1][to]<<'\n';
		}else{
			int v=lower_bound(used[q[i].y].begin(),used[q[i].y].end(),q[i].t)-used[q[i].y].begin();
			int to=used[q[i].y][v];
			e[mp[q[i].y][0][to]].pb(mp[q[i].x][1][q[i].t]);
			e[mp[q[i].x][0][q[i].t]].pb(mp[q[i].y][1][to]);
//			cerr<<mp[q[i].y][0][to]<<' '<<mp[q[i].x][1][q[i].t]<<'\n';
//			cerr<<mp[q[i].x][0][q[i].t]<<' '<<mp[q[i].y][1][to]<<'\n';
		}
	}
	rep(i,1,n) ans[i]=n-1;
	for(int l=1,r;l<=n;){
		r=min(l+9999,n);
		rep(i,1,tot) dp[i].reset();
		rep(i,l,r) dp[mp[i][0][T+1]][i-l+1]=1;
		sprd();tmp.reset();
		rep(i,l,r) if(dp[mp[i][1][T+1]][i-l+1]) ans[i]=0,tmp[i-l+1]=1;
		rep(i,1,n) dp[mp[i][1][T+1]]|=tmp;//这里，如果一个点必然死，要记得加上贡献，因为有可能没有跑到
		rep(i,1,n) if(ans[i]) ans[i]-=dp[mp[i][1][T+1]].count();
		l=r+1;
	}
	rep(i,1,n) cout<<ans[i]<<' ';
	return 0;
}
```

---


# [JSOI2019] 节日庆典

## 题目背景

JYY 和探险队顺利完成了火星上的任务。在离开前，探险队正好赶上了火星人一年一度最盛大的节日「气球节」。然而，火星人遇到了每年一度的麻烦：怎样最美观地摆放气球。JYY 决定请你设计算法帮助火星人解决这个问题。

## 题目描述

在庆典开始前，火星人会把气球准备好并串在一根绳子上。气球按顺序排列可以看成是一个由小写字母组成的长度为$n$的字符串$S$。然后，火星人会按照字符串的顺序逐个把气球加入到一个庆典的圆环上，并且表演一个节目庆祝。

下图展示了一串气球 **cbbadbcd** 在进行到第$5$个节目时的情形，此时在庆典环上的气球是 **cbbad**。

![](https://cdn.luogu.com.cn/upload/pic/57738.png)

为了让每个节目都更好看，火星人希望在每个节目开始前调整气球在环上的顺序，使得每个节目的气球排布都最美观。对于一组气球（一个字符串），火星人认为最美观的字符串是庆典圆环上按绳子方向读出**字典序最小的字符串**，例如对于 **cbbad**，共有$5$个读出字符串的位置：

- cbbad （$i=1$）；

- bbadc （$i=2$）；

- badcb （$i=3$）；

- adcbb （$i=4$）；

- dcbba （$i=5$）。

如果有多个字典序最小的字符串，火星人希望找出**离绳头最近**的那个(即最小的那个)。更严谨地说，对于字符串，定义

$$T_i=T[i……|T|]::T[1……i-1](1 \leq i \leq |T|)$$

其中$::$是字符串的拼接操作。定义$f(T)$为最小的$i$（$1 \leq i \leq |T|$）满足$T_i=min(T_1,T_2,……,T_{|T|})$。

JYY希望你帮助他设计一个算法，让火星人每个节目的气球排列都最美观，即对于给定字符串$S$的每一个前缀$S[1……i]$（$1 \leq i \leq |S|$），求出$f(S[1……i])$。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/57739.png)

## 样例 #1

### 输入

```
abaacaba```

### 输出

```
1 1 3 3 3 6 3 8```

# 题解

## 作者：i207M (赞：20)

~~此题数据极水，你甚至可以反向A题：WA前4个小点，AC后6个大点...~~

网上的题解好像很少，不太具体，细节我是看代码研究出来的。~~我并没有照着zsy的代码写为啥写出来还是这么相似啊...~~

~~duliuchutirenkabeizengsa~~

首先，显然的贪心是，我们选择的一定是字典序最小的后缀放在开头。但是单纯的这样做显然是不对的，我们还要考虑放完这个后缀，要接上串的开头，这回影响字典序。

我们怎样选出最优的？我们可以维护一个vector，表示$[1,i]$中，可能成为最优解的后缀的集合。（换句话说，如果可以证明后缀a之后永远劣于后缀b，那么我们就把a从集合中删除）

事实上，可以证明，可能成为最优解的后缀只有$O(\log n)$个：

先摆上zsy的证明：orz

> 简单证一下这个性质：考虑相邻的两个最小后缀$i,j$，若$|j|<|i|<2|j|$，则说明$i=AAB,j=AB$，其中$A,B$均为字符串，且$B$是$A$的一个严格前缀。此时考虑$i=AAB,j=AB,k=B$，可以发现无论如何最小后缀都会在$i$和$k$之间产生，$j$不可能成为最小后缀，由此说明相邻两个最小后缀的长度至少$\times 2$，因此数量不超过$\log n$。

如果没有理解的话我们讨论一下：

（$T[i]$表示字符串$T$从1开始的第i个字符）

如果$A[|B|+1]<S[1]$，那么k最优。

如果$A[|B|+1]>S[1]$，i最优。

j的处境很尴尬所以就被抛弃了。

为了加速判断，我们需要用exKMP求出每个后缀和整个串的LCP（当然你用SAIS也没人拦

```cpp
#define N 3000005
int n;
char s[N];
int nx[N];
void exkmp()
{
	for(ri i=2,j,p=1; i<=n; ++i)
	{
		j=max(min(nx[i-p+1],p+nx[p]-i),0);
		while(i+j<=n&&s[i+j]==s[j+1]) ++j;
		nx[i]=j;
		if(p+nx[p]<i+nx[i]) p=i;
	}
	nx[1]=n;
}
il int cmp(int x,int r) // compare 1 with x: 1 < x ?
{
	if(x+nx[x]-1>=r) return 0;
	return s[nx[x]+1]<s[x+nx[x]]?1:-1;
}
il int getmin(int x,int y,int r) // x > y
{
	int t;
	if((t=cmp(y+r-x+1,r))) return t>0?x:y;
	if((t=cmp(r-x+2,y-1))) return t>0?y:x;
	return y;
}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	scanf("%s",s+1); n=strlen(s+1);
	exkmp();
	vector<int> f;
	for(ri i=1; i<=n; ++i)
	{
		static vector<int> g; g.pb(i);
		for(solid x:f)
		{
			while(!g.empty()&&s[x+i-g.back()]<s[i]) g.pop_back();
			if(g.empty()||s[x+i-g.back()]==s[i])
			{
				while(!g.empty()&&i-x+1<=2*(i-g.back()+1)) g.pop_back();
				g.pb(x);
			}
		}
		f.swap(g),g.clear(); int ans=-1;
		for(solid x:f)
			if(ans==-1) ans=x;
			else ans=getmin(ans,x,i);
		out(ans,' ');
	}
	return 0;
}
```

---

## 作者：qwaszx (赞：17)

使用 Lyndon word 相关理论可以导出本题的一个简洁线性做法

[zx 哥哥的线性做法](https://zx2003.blog.uoj.ac/blog/5054)，然而我并没有看懂. 

首先考虑如果给定一个串 $s$，那么什么样的位置可能是最小表示 

对 $s$ 做 Lyndon 分解，合并相同的 Lyndon word，会得到 $s=w_1^{k_1}w_2^{k_2}\cdots w_m^{k_m}$，其中 $w_1>w_2>\cdots>w_m$

首先显然选择的位置一定是 Lyndon word 的开头，接下来我们断言如果选择了 $w_i^kw_{i+1}^{k_{i+1}}\cdots w_m^{k_m}$，那么 $k=k_i$.

> 证明：只需比较 $u^2v,uv,v$ 的大小. 如果 $u\geq v$，那么自然有 $u^2v>uv>v$；否则，如果 $u$ 不是 $v$ 的前缀，那么有 $u^2v<uv<v$；如果 $u$ 是 $v$ 的前缀，那么我们可以把 $v$ 不断去掉前缀 $v$ 来变成之前的情况，从而 $uv$ 总是不优的. 注意这个证明并没有使用 Lyndon word 的任何性质，这对一般的字符串也是成立的.

注意到一个性质：如果 $u,v$ 是任意串，$w$ 是 Lyndon word，$u<w,v<w$，那么 $uv<w$

设 $S_i=w_i^{k_i}w_{i+1}^{k_{i+1}}\cdots w_m^{k_m}$. 由于 $w_i>w_{i+1}$ 且 $w_i$ 是 Lyndon word，容易推出 $w_i^{k_i}\geq w_i>S_{i+1}$. 首先 $S_m$ 可能是一个最小表示的开始，接下来如果 $S_m$ 不是 $w_{m-1}$ 的前缀那么所有 $i<m$ 的 $S_i$ 都无法成为最小表示. 如果是前缀，那么再考虑如果 $S_{m-1}$ 不是 $w_{m-2}$ 的前缀，则所有 $i<m-1$ 的 $S_i$ 都无法成为最小表示. 以此类推，我们能找到一个最小的 $i$，满足 $\forall i\leq k<m$ 有 $S_{k+1}$ 是 $w_k$ 的前缀. 只有这些 $i\leq k\leq m$ 的 $S_k$ 可能成为最小表示.

注意到这已经导出了一个 $O(n\log n)$ 做法：$i$ 每减小 $1$ 后缀长度至少乘二，因此可行的 $i$ 只有 $O(\log n)$ 个. 我们维护每个前缀的 Lyndon 分解（用单调栈维护当前所有 Lyndon word（形如 $[l_i,r_i]$），每次插入一个 $[i,i]$，如果栈顶元素小于加入的 Lyndon word 就将其合并，否则就得到了最后一个 Lyndon word），暴力向前枚举上面所说的后缀即可.

但我们不满足于此. 还是来考虑 Duval 算法，设当前考虑到的字符串为 $s=u^ku'$，其中 $u'$ 是 $u$ 的可空真前缀，$u$ 是 Lyndon word. 在运行过程中同时维护每个原串前缀的最小表示的起始位置，设为 $ans_i$. 考虑加入一个字符 $c$ 造成的影响. 我们首先给出结论，然后给出证明. 设 $c$ 的位置为 $i$ 且之前未被更新过，那么

- 如果 $s_{|u'|+1}=c$，那么 $ans_i$ 为 $i-(|u|-ans_{|u'|+1})$ 和 $1$ 中更优的那个
- 如果 $s_{|u'|+1}<c$，那么 $ans_i=1$
- 如果 $s_{|u'|+1}>c$，那么等到以后再更新.

考虑其正确性，我们在什么时候会进行新的一轮遍历？答案是末尾的 $u'$ 严格小于（指非前缀）$u$ 的时候. 对于这个字符以后的前缀而言，根据我们上面的理论，$u$ 将不可能成为其最小表示. 所以，对于每一轮循环，$u$ 前面的字符串将不再有贡献，有贡献的只有 $u'$ 中的位置和第一个 $u$ 的起始位置. 如果选择 $u'$ 中的位置，那么我们发现这些位置开始的循环表示其实就是第一个 $u$ 中的 $u'$ 在当时的循环表示后面填上 $u^k$，于是答案是一样的. 注意这必须保证对应位置的 $ans$ 在当前考虑的串中才成立，当然如果不在那么必然更劣. 

现在我们只需要解决比较两个子串. 注意由于我们上面的理论，其中一个必然是另一个的后缀，于是只需要求一个后缀和原串的 lcp，可以用 exkmp 线性求出.


~~IO 时间差不多占了一半~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=3e6+500;
char st[N];
int n;
int lcp[N];
int ans[N];
int chkmin(int x,int y,int r)
{
	if(x==y)return x;
	int len=lcp[x+r-y+1];//cout<<len<<endl;
	if(len<y-x)return st[x+r-y+1+len]<st[len+1]?x:y;
	len=lcp[y-x+1];
	if(len>=x-1)return x;
	else return st[len+1]<st[y-x+1+len]?x:y;
}
void exkmp()
{
	lcp[1]=n;int mid=2,r=0;
	for(int i=2;i<=n;i++)
	{
		if(i<=r)lcp[i]=min(lcp[i-mid+1],r-i+1);
		else lcp[i]=0;
		while(i+lcp[i]<=n&&st[1+lcp[i]]==st[i+lcp[i]])++lcp[i];
		if(mid+lcp[i]-1>=r)mid=i,r=mid+lcp[i]-1;
	}
//	for(int i=1;i<=n;i++)cout<<lcp[i]<<" ";puts("");
}
char obuf[1<<25],*oh=obuf;
inline void out(int x){
	if(!x){*oh++='0';return;}
	static int buf[30];int xb=0;
	for(;x;x/=10)buf[++xb]=x%10;
	for(;xb;)*oh++=buf[xb--]|48;	
}
int main()
{
	n=fread(st+1,1,N-500,stdin);for(;!isalpha(st[n]);--n);
	exkmp();
	for(int i=1,j,k,u;i<=n;)
	{
		j=i,k=i+1,u=1;if(!ans[i])ans[i]=i;
		for(;k<=n&&st[k]>=st[j];k++)
		{
			if(st[k]==st[j])
			{
				int t=(k-i)%u+i;
				if(!ans[k])
				{
					if(ans[t]<i)ans[k]=i;
					else ans[k]=chkmin(i,k-(t-ans[t]),k);
				}
				j++;
			}
			else
			{
				u=k-i+1;j=i;if(!ans[k])ans[k]=i;
			} 
		}
		i+=(k-i)/u*u;//cout<<i<<endl;
	}
	for(int i=1;i<=n;++i)out(ans[i]),*oh++=' ';*oh++='\n';
	fwrite(obuf,1,oh-obuf,stdout);
}
```

---

## 作者：鲤鱼江 (赞：12)

又是离正解只差一个复杂度分析的的一道题。

以下讲解完整心路历程，觉得太长可以找关键看。

发现字符串长度达到令人惊异的 $3\times 10^6$，所以后缀数据结构基本可以排除了，不是过不去，是如果这个是正解，那么没必要这么卡。

我们考虑增量计算，即每一次加入一个字符，再计算答案。

盯一分钟发现一个事实，就是你每一次将串的循环同构（即串平移后得到的新字符串们）直接考虑完是很难的，因为这样你加入一个字符就相当于在这些循环同构的**中间**插入一个字符，明显不是给人做的，所以先只比较 $T[i\dots |T|]$ 部分，也就是后缀部分。

然后又发现很多串都是多余的，我们可以只维护可能成为新的答案的后缀，我们称这些后缀长度从小到大排序后组成的序列叫做**答案序列**。简单想想发现前一个串一定是后一个串的前缀，否则根本不需要比较 $T[1\dots i-1]$ 部分，直接就得出大小关系了。

因为这些串本来就是同一个串的后缀了，现在又得到它们前一个串是后一个串的前缀，所以前一个串是后一个串的 Border，这是很强的结论。

我们来看看如何动态维护这个序列，我们来看新加一个字符，答案序列会发生什么变化，以下会画图辅助理解但只会画三个，凑合看。

考虑以下已经是答案序列，需要加新的字符，字符记作 $X$。

![](https://cdn.luogu.com.cn/upload/image_hosting/chnm3x5r.png)

我们每次比较一个串与其后一个串，若该串字典序小于后一个串，则说明后面的所有串字典序都大于该串，后面均可舍去。若字典序大于后一个串，说明该串永远没用，直接删去，这个删除操作最多 $n$ 次，分析势能可以发现复杂度正确。

那么在加入一个字符后，前一个串还是后一个串的 Border 怎么办呢？这个时候你只能得到一个结论：这个串是后面所有的串的 Border，是一个优美的结论，但是不能保证任何别的性质，你后面的串还是需要继续递归比较，若字符串只有一个字符，时间可能达到 $O(n^2)$。

继续优化是比较难的，因为你很难再发掘其他性质了，笔者最开始卡在了这里。可是真的完全无法优化吗？仔细想想，发现其实答案序列里面的很多实际上并不可能成为答案，接下来有一个十分符合直觉但被大多数人下意识忽略的性质——后一个字符串必是前一个字符串长度的至少 $2$ 倍。

只要我们证明并维护上面的性质，所有暴力都会变成正解，你想怎么写就怎么写。

我们选择使用反证法，你考虑有两个答案序列里面的串 $x$，$y$，有 $|x|<|y|<2|x|$，因为这两个串都在答案序列中，所以 $x$ 是 $y$ 的 Border，然后进行分类讨论。

+ $y$ 形如 $AAA$，$x$ 形如 $AA$，其中 $A$ 表示一个字符串。此时发现若 $T[1]<A[1]$，则有串 $A$ （串 $A$ 肯定也是原串后缀）比 $x$ 和 $y$ 都优，反之串 $y$  一定最优。即有：无论什么情况，$x$ 一定不优（若 $T[1]=A[1]$ 直接递归比较）。
+ $y$ 形如 $AAB$，$x$ 形如 $AB$，其中 $B$ 是 $A$ 的严格前缀，类似于上面分析，得到同样结果。

综上得证，所以我们的答案序列大小不超过 $\log n$，所以可以暴力维护。

比较字典序可以 exkmp 预处理后 $O(1)$ 做。

代码就不放了。

---

## 作者：Day_Of_Dream (赞：12)

# P5334 [JSOI2019] 节日庆典 题解

本题解的侧重点在于对一些代码中难懂的细节加以说明。欢迎各位大佬指正。

前置知识：扩展 KMP，最小表示法的定义（本题解中并不需要了解最小表示法的求解过程）。

### 第一部分：预选数组

在这道题中，对于每一个 $i\in[1,n]$，暴力枚举 $1 \sim i$ 中的每一个字母去判断，时间复杂度肯定是不能接受的，因此考虑引入预选数组 $cur$，来统计可能的答案。

对于预选数组中存放的下标而言，对于任意两个元素 $x$ 和 $y$，满足 $S[x,i]$ 的字典序 **大致等于** $S[y,i]$ 的字典序。

这里，**大致等于** 的意思是 **非严格** 小于。举个例子，设三个字符串 $A=\texttt{aaac}$，$B=\texttt{aaa}$，$C=\texttt{aac}$，其中，$A$ 和 $B$ 字符串的字典序大致相等，而 $A$ 字符串的字典序严格小于 $C$ 字符串。

考虑如何计算 $cur$ 数组。

容易发现一个性质：如果上一次的 $cur$ 数组中，元素 $j$ 被删除，则这个元素不会再在未来的 $cur$ 数组中出现。

根据上方的性质，我们首先，先将 $i$ 一个一个放入 $cur$ 数组中。然后，枚举每一个上一次 $cur$ 数组中的元素 $j$。同时，新定义一个 $nex$ 数组，表示当前情况下的预选数组。对于每一个 $j$ 而言，都去遍历 $nex$ 中的每一个元素。设当前枚举到 $nex$ 数组中的元素 $k$。根据 **大致等于** 的定义，我们对 $S[k,i-j+k]$ 和 $S[j,i]$ 进行比较。这里有一个巧妙的地方，由于 $i$ 在不断向后移动，留在 $cur$ 数组中的元素的 $j$ 到 $i-1$ 个字符已经进行过比较，因此每次的比较不需要逐一比较，只需要去比较 $S[i-j+k]$ 和 $S[i]$ 即可（对于不理解这个地方的读者，笔者建议可以自己去手动模拟一下）。

比较 $S[i-j+k]$ 和 $S[i]$ 有三种情况：

- 若 $S[i-j+k]$ 等于 $S[i]$，则说明两字符串大致相等。

- 若 $S[i-j+k]$ 小于 $S[i]$，则说明字符串 $S[j,i]$ 字典序严格大于 $S[k,i-j+k]$，此时字符串 $S[j,i]$ 不能加入 $nex$ 数组。

- 若 $S[i-j+k]$ 大于 $S[i]$，则说明字符串 $S[k,i-j+k]$ 字典序严格大于 $S[j,i]$，此时字符串 $S[k,i-j+k]$ 踢出 $nex$ 数组。继续枚举 $nex$ 数组中的其它元素。

这一部分代码如下：


```cpp
for(int i=1;i<=n;i++)
{
	cur.push_back(i),nex.clear();
	for(int j:cur)
	{
		bool flag=1;
		while(!nex.empty())
		{
			int k=nex.back();
			if(s[i-j+k]==s[i])	break ;
			else if(s[i-j+k]<s[i])	
			{
				flag=0;
				break ;
			}
			nex.pop_back();
        }
    }
}
```
### 第二部分：对于预选数组的优化

如果按照这种规则插入到预选数组的话，势必还是会超时，考虑优化预选数组中的元素数量。

我们来推理一个性质，对于预选数组中的两个元素 $i$ 和 $j$，若满足 $|j|<|i|<2 \times |j|$，则 $j$ 一定不是最优解（$|j|$ 表示字符串 $S[j,r]$ 的长度，$r$ 为当前枚举字符串 $S$ 前缀的长度）。

**证明**：我们令 $S[i,r]=A+A+B$，$S[j,r]=A+B$。同时，我们定义字符串 $S[k,r]=B$，且 $A$ 和 $B$ 均为字符串。

设 $lena$ 表示字符串 $A$ 的长度，$lenb$ 表示字符串 $B$ 的长度，分以下两类情况讨论：

① $lena>lenb$，因为预选数组中的字符串字典序大致相等，因此此时字符串 $B$ 一定是 $A$ 的前缀。

- 若 $A[lenb+1]$ 小于 $S[1]$，则此时以 $i$ 开头的字符串的字典序一定小于以 $j$ 开头的。

- 若 $A[lenb+1]$ 大于 $S[1]$，则此时以 $k$ 开头的字符串一定比以 $j$ 开头的字典序小。

于是我们得到，当 $lena>lenb$ 时，以 $j$ 开头的字符串一定不是唯一最优解。

② $lena<lenb$，此时又分为以下两种情况：

- 若 $B[lenb-lena+1]$ 小于 $S[1]$，则此时以 $i$ 开头的字符串的字典序一定小于以 $j$ 开头的。

- 若 $B[lenb-lena+1]$ 大于 $S[1]$，则此时以 $k$ 开头的字符串一定比以 $j$ 开头的字典序小。

于是我们又得到，当 $lena<lenb$ 时，以 $j$ 开头的字符串一定不是唯一最优解。

综上所述，当 $i$ 和 $j$ 满足 $|j|<|i|<2 \times |j|$ 时，以 $j$ 开头的字符串一定不是唯一最优解。

我们考虑用刚刚代码中的字母去替换以上不等式，化简后得到如下不等式：$0<j-k<i-j$。

其中，$j-k>0$ 这个条件显然成立，则不等式可简化为 $j-k<i-j$，则说明当 $j-k<i-j$ 时，以 $j$ 开头的字符串一定不是唯一最优解。故在元素 $j$ 加入 $nex$ 数组时，判断 $i-j \le j-k$ 即可。

这一部分代码如下：

```cpp
  if(flag and (nex.empty() or i-j<=j-nex.back()))	nex.push_back(j);
```

### 第三部分：计算答案

枚举每一个预选数组中的元素，去逐位比较字符串中的字母来计算字典序大小，但这样，刚刚优化下来的时间又被提上去了，考虑优化。

逐位比较显然就是最浪费时间的一个部分，从这个方面入手去优化。

我们将预选数组中的元素 $x$ 和 $y$ 的字符串表示出来如下：

$S[x]=S[x,r]+S[1,x-1]$，$S[y]=S[y,r]+S[1,y-1]$。

根据预选数组的条件，我们可以知道，$S[y,r]$ 一定是 $S[x,r]$ 的一个严格前缀，于是这部分无需比较。此时要比较的是 $S[x+r-y+1,r]+S[1,x-1]$ 和 $S[1,y-1]$。

发现 $S[x+r-y+1,r]$ 和 $S[1,y-1]$ 正好对应了字符串 $S$ 的后缀和开头，字符串相同的部分无需比较，因此只需要找到第一个不同的位置即可。使用扩展 KMP 算法即可。设最长公共前缀数组用 $lcp$ 表示，$x=x+r-y+1$，则要比较的位置就是 $S[x+lcp[x]]$ 和 $S[lcp[x]+1]$。

如果此时 $x$ 字符串剩余的后缀与 $y$ 字符串的前缀相同，则 $y$ 字符串要比较的部分变为 $S[1+r-x+1,y-1]$，$x$ 字符串要比较的部分变为 $S[1,x-1]$。此时又如同上方后缀和开头的关系，令 $y=1+r-x+1$，所以要比较的部分就是 $S[lcp[y]+1]$ 和 $S[y+lcp[y]]$。

如果以上两者均相同，因为要输出较小的 $i$，所以 $cmp$ 函数应该返回 $true$，表示保留当前的答案。

这一部分代码如下：

```cpp
bool cmp(int x,int y,int r)
{
    int t=x-1,w=y-1;
	x=(x+r-y)+1;y=1;
	if(x+lcp[x]<=r)	return s[x+lcp[x]]<s[lcp[x]+1];
	y=(y+r-x)+1;
	if(y+lcp[y]<=w and lcp[y]+1<=t)	return s[lcp[y]+1]<s[y+lcp[y]];
	return 1;
}//比较函数

cur=nex;
ans=cur[0];
for(int j:cur)	ans=cmp(ans,j,i)?ans:j;
cout<<ans<<" ";
```

最后，完整代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>

using namespace std;
const int N=3e6+10;

int n,lcp[N],ans;
string s;
vector<int>cur,nex;

void exkmp()
{
	int a=1,k=0,len=s.size();
	lcp[0]=len;
	while(s[k]==s[k+1] and k+1<len)	k++;
	lcp[1]=k;
	for(int i=2;i<len;i++)
	{
		if(lcp[i-a]+i<lcp[a]+a)
		{
			lcp[i]=lcp[i-a];
		}
		else
		{
			int j=lcp[a]+a-i;
			if(j<0)	j=0;
			while(i+j<len and s[i+j]==s[j])	j++;
			lcp[i]=j;
			a=i;
		}
	}
}

bool cmp(int x,int y,int r)
{
    int t=x-1,w=y-1;
	x=(x+r-y)+1;y=1;
	if(x+lcp[x]<=r)	return s[x+lcp[x]]<s[lcp[x]+1];
	y=(y+r-x)+1;
	if(y+lcp[y]<=w and lcp[y]+1<=t)	return s[lcp[y]+1]<s[y+lcp[y]];
	return 1;
}

int main()
{
	cin>>s;
	n=s.size();
	exkmp();
	s=' '+s;
	for(int i=n;i>=1;i--)	lcp[i]=lcp[i-1];
	for(int i=1;i<=n;i++)
	{
		cur.push_back(i),nex.clear();
		for(int j:cur)
		{
			bool flag=1;
			while(!nex.empty())
			{
				int k=nex.back();
				if(s[i-j+k]==s[i])	break ;
				else if(s[i-j+k]<s[i])	
				{
					flag=0;
					break ;
				}
				nex.pop_back();
			}
			if(flag and (nex.empty() or i-j<=j-nex.back()))	nex.push_back(j);
		}
		cur=nex;
		ans=cur[0];
		for(int j:cur)	ans=cmp(ans,j,i)?ans:j;
		cout<<ans<<" ";
	}
	return 0;
}
```
这篇题解到此结束，感谢大家阅读这篇题解。

---

## 作者：pitiless0514 (赞：9)


## Luogu P5334 [JSOI2019]节日庆典

题目大意： 给定一个串 $S$，求每个前缀的最小表示法。

$\textbf{Data Range:}1\leq n \leq 3 \times10^6$。

------------

[超爽的阅读体验](https://www.cnblogs.com/ptno/p/16418308.html)。

考虑 lyndon 分解，如果我们对每个前缀都跑一边 lyndon 分解的话，答案应该是最后一个开头 $\leq i$ 的 lyndon 串。

这样不优秀啊，但是我们仍然考虑 lyndon 分解。

假设我们现在维护的是 $pu^tv$，仍然维护指针 $i,j,k$。

我们其实当前位置要加入的一个字符 $k$ 的最小表示法的开头只会有两种情况，一种是在我的当前开始的位置 $i$，一种是在我加入的这个 $v$ 里面的。

在 $v$ 里面的话，你考虑他最终的表示法会是什么样子，比如 $pu^tv$，那么最终他会是 $vpu^t$。

你仔细发现，反正我没发现，然后你发现如果你去掉最后的 $|u|$ 个字符，他就会变成 $vpu^{t-1}$，然后这就是一个已经求解过的答案了，他是 $pu^{t-1}v$ 的最小表示法。

现在我们需要根据 $S_j$ 和 $S_k$ 的大小进行分类。

如果 $S_j < S_k$，那么根据 lyndon 串的性质，那么 $u^tv+S_k$ 仍然是一个 lyndon 串，那么此时的 $i$ 就是我们的 $ans_k$。

如果 $S_j > S_k$，那么之前的 lyndon 串被划分了出来，但是当前位置仍然不知道，于是我们将其放到后面进行求解。

如果 $S_j = S_k$，那么可以选择两种位置，首先就是当前的 $i$ 可以作为 $ans_k$，另一种是，先前循环节中 $k$ 的对应位置 $j$ 的答案向后移一个循环节的对应位置 $ans_j + k - j$。

那么需要比较的为 $S[i\dots k] + S[1 \dots (i - 1)]$ 和 $S[(ans_j + k - j) \dots k] + S[1\dots ans_{j} + k - j - 1]$ 的字典序大小。

首先我们只会在 $S_j = S_k$ 的时候遇到这种情况，那么 $S[i \dots (i + k - (ans_j + k - j))]$ 和 $S[(ans_j + k - j) \dots k]$ 肯定都是相同的。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2p290y0i.png)

也就是说上面的 $S_2$ 和 $S_4$ 一定是相同的。

然后你分着来比较，先比较 $S_3 + S_4$ 和与他对应长度的那一部分。

也就是图中画着绿线的那一部分，然后再比较后面的剩下部分就好了。

这样你发现，每次都是将一个子串 $S[a \dots b]$ 与原串的一个前缀 $S[1 \dots b - a + 1]$ 进行比较。

那么我们可以使用 $z$ 函数，判断后缀 $a$ 与原串的一个 lcp 长度判断是否再比较范围内，并找到这个不同即可。

使用 $\text{exkmp}$ 可以求解。

于是直接跑 Duval 算法就好了，复杂度 $O(n)$，真神仙。

```cpp
// 德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱
// 德丽莎的可爱在于德丽莎很可爱，德丽莎为什么很可爱呢，这是因为德丽莎很可爱！
// 没有力量的理想是戏言，没有理想的力量是空虚
// Problem: P5334 [JSOI2019]节日庆典
// Contest: Luogu
// Memory Limit: 500 MB
// Time Limit: 1000 ms
// The Author : Pt
#include <bits/stdc++.h>
using namespace std;
namespace io {
  const int SIZE = (1 << 21) + 1; char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;
  #define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
  inline void flush () {  fwrite (obuf, 1, oS - obuf, stdout); oS = obuf; }
  inline void putc (char x) { *oS ++ = x; if (oS == oT) flush (); }
  template <class I> inline void gi (I &x) { for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1; for (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f; }
  string getstr(void) { string s = ""; char c = gc(); while (c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF) c = gc(); while (!(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF))s.push_back(c), c = gc(); return s;}
  template <class I> inline void print (I x) { if (!x) putc ('0'); if (x < 0) putc ('-'), x = -x; while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) putc (qu[qr --]); }
  struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
}
using io :: gi;  using io :: putc;  using io :: print;
#define V inline void
#define I inline int
template<class T> bool chkmin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool chkmax(T &a, T b) { return a < b ? (a = b, true) : false; }
#define rep(i, l, r) for (int i = (l); i <= (r); i++)
#define repd(i, l, r) for (int i = (l); i >= (r); i--)
const int N = 3e6 + 5;
char S[N];
int z[N], n, ans[N];
void exkmp() {
  z[1] = n;
  for (int i = 2, l = 0, r = 0; i <= n; i++) {
    if (i <= r)  z[i] = min(z[i - l + 1], r - i + 1);
    while (i + z[i] <= n && S[i + z[i]] == S[1 + z[i]]) ++ z[i];
    if (i + z[i] - 1 > r)  r = i + z[l = i] - 1;
  }
}
int compare(int x,int y,int r) {
  if (x == y)  return x;
  int zz = z[x + r - y + 1];
  if (zz < y - x)  return S[x + r - y + 1 + zz] < S[1 + zz] ? x : y;
  zz = z[y - x + 1];
  if (zz < x - 1)  return S[1 + zz] < S[y - x + 1 + zz] ? x : y;
  return x;
}
void solve() {
  int i = 1;
  while (i <= n) {
    int j = i, k = i + 1;
    if (!ans[i])  ans[i] = i;
    while (k <= n && S[j] <= S[k]) {
      if (S[j] < S[k]) {
        if (!ans[k])  ans[k] = i;  j = i;  ++k;
      }  else {
        if (!ans[k]) {
          if (ans[j] < i)  ans[k] = i;
          else  ans[k] = compare(i, ans[j] + k - j, k);
        }
        ++k;  ++j;
      }
    }
    int len = k - j;
    while (i <= j)  i += len;
  }
}
signed main () {
#ifdef LOCAL_DEFINE
  freopen("input.txt", "r", stdin);
#endif
  cin >> (S + 1);  n = strlen(S + 1);
  exkmp();  solve();
  rep (i, 1, n)  cout << ans[i] << " ";
#ifdef LOCAL_DEFINE
  cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
  return 0;
}
```

---

## 作者：juju527 (赞：8)

### 前置知识
**扩展KMP**

不会的童鞋可以左转模板区学习一下

### 题意
给定一个串$\text S$，求每个前缀最小表示法

### solution
下文用方案$i$表示从串第$i$位开始的表示方法

先考虑最显然的暴力

对每个位置，每个方案循环比较

时间复杂度$O(n^3)$

考虑计算前缀$i$的最小表示法

我们容易发现存在一个可能的方案集合$\text P_i$

对于$\text P_i$中的每一个方案满足两两比较到第$i$位仍相同

显然$\text P_{i+1}\subset\text P_i$

也就是说一个方案$j$在前缀$i$处被淘汰则之后一定不会是最小表示法

但这样做复杂度还是不对的，一个$aaaaaa...$串就能$huck$掉我们的做法

相邻的两个$\text P_r$集合中的方案$i,j(i<j,r-j>j-i)$
![](https://cdn.luogu.com.cn/upload/image_hosting/y32e04iu.png)
上图相同颜色覆盖的区域表示相同串，蓝串为$A$，绿串为$B$，紫串为$C$，用$A,B,C$求出了$i,j,k$的方案

若$A>B$，则方案$j$劣于方案$k$

若$A<B$，则方案$j$劣于方案$i$

故$j$一定不是最优解

那么$r-j<j-i$

故$\text P$集合中只需存$logn$个方案

转移$\text P_i$时比较方案多出来的一位即可

得到$\text P_i$后，循环每一个方案

发现我们需要比较的剩下部分都可以看作后缀和整串的比较

如下图蓝色部分的比较与绿色部分的比较

![](https://cdn.luogu.com.cn/upload/image_hosting/q8hyankd.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

线性的跑出$z$函数就能解决了！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e6+5; 
int n;
char s[maxn];
int z[maxn];
namespace io
{
	const int SIZE = 1 << 22 | 1;
	char iBuf[SIZE], *iS, *iT, c;
	char oBuf[SIZE], *oS = oBuf, *oT = oBuf + SIZE;
	#define gc() (iS == iT ? iT = iBuf + fread(iS = iBuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++)
	template<class I> void read(I &x)
	{
		int f = 1;
		for(c = gc(); c < '0' || c > '9'; c = gc())
			if(c == '-') f = -1;
		for(x = 0; c >= '0' && c <= '9'; c = gc())
			x = (x << 3) + (x << 1) + (c & 15);
		x *= f;
	}
	inline void flush()
	{
		fwrite(oBuf, 1, oS - oBuf, stdout);
		oS = oBuf;
	}
	inline void putc(char x)
	{
		*oS++ = x;
		if(oS == oT) flush();
	}
	template<class I> void print(I x)
	{
		if(x < 0) putc('-'), x = -x;
		static char qu[55];
		char *tmp = qu;
		do *tmp++ = (x % 10) ^ '0'; while(x /= 10);
		while(tmp-- != qu) putc(*tmp);
	}
	struct flusher{ ~flusher() { flush(); } }_;
}
using io :: read;
using io :: putc;
using io :: print;
void exkmp(){
	register int l=0,r=0;
	z[1]=n;
	for(register int i=2;i<=n;i++){
		if(r>i)z[i]=min(z[i-l+1],r-i+1);
		while(i+z[i]<=n&&s[i+z[i]]==s[z[i]+1])z[i]++;
		if(i+z[i]-1>r)l=i,r=i+z[i]-1;
	}
	return ;
}
vector<int>now,nxt;
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	exkmp();
	for(register int i=1;i<=n;i++){
		now.push_back(i);
		nxt.clear();
		for(register int j=0;j<now.size();j++){
			register int p=now[j];
			register bool flag=1;
			while(!nxt.empty()){
				register int q=nxt.back();
				if(s[i]>s[q+i-p])flag=0;
				if(s[i]>=s[q+i-p])break;
				nxt.pop_back();
			}
			if(flag&&(nxt.empty()||(i-p+1<p-nxt.back())))nxt.push_back(p);
		}
		now=nxt;
		register int pos=now[0];
		for(register int j=1;j<now.size();j++){
			register int x=now[j],k=pos+i-x;
			if(z[k+1]>=i-k){
				register int l=i-k;
				if(z[l+1]<x-l-1&&s[l+z[l+1]+1]<s[z[l+1]+1])pos=x;
			}
			else if(s[z[k+1]+1]<s[k+z[k+1]+1])pos=x;
		}
		print(pos);putc(' ');
	}
	return 0;
}

```

---

## 作者：myee (赞：3)

### 前言

怎么都会串串科技。![/kel](https://akioi.ml:2022/static/img/qq/kel)

题意就是给定字符串，求其每个前缀的最小表示。

实在是超越了我的想象力。

最小表示法，字符串周期结构，嗯上 Lyndon 分解？

~~然而我不会 Lyndon 分解，那直接 Say Goodbye。~~

### 思路

考虑怎么不用 Lyndon 分解做。

事实是，加上几个“剪枝”，每个时刻可能作为答案的位置很少。

考虑到，$S$ 的一个前缀 $T$ 的最小表示由 $T$ 的后缀 + 一段前缀描述，

考虑最小化 $T$ 的后缀的字典序。

设每个可能计入答案的 $T$ 的后缀构成的集合是 $\mathcal U$，其中最长者为 $L$。

则对每个 $x\in\mathcal U$，$x$ 应是 $L$ 的前缀；否则，要么必然不如 $L$ 优，要么必然吊打 $L$。

因此对每个 $x\in\mathcal U$，$x$ 是 $T$ 的一个后缀，于是也都是 $L$ 的后缀。

也即，都是 $L$ 的 Border！

由 Border 理论，一个串 $L$ 的所有 Border 可以被划分为 $O(\log n)$ 个等差数列，其中长度大于一半的就构成等差数列。对于每个 $L$ 的 Border，其与一个 $L$ 的周期互补；小于一半的周期均为最小非 $0$ 周期的倍数。

这样，对每个等差数列，分类讨论容易分析出其只有开头结尾可能匹配答案，直接暴力计算即可。称其为 $\mathcal P$，则 $|\mathcal P|=O(\log n)$；比较更优解可用 exkmp 实现 $O(1)$。

往 $T$ 末尾加入一个字母时，可以在 $\mathcal P$ 中暴力枚举新的最优 $L$，从而描述新的 $\mathcal U,\mathcal P$。

这样肯定很难写（要动态维护一个 kmp），考虑能不能用非 Border 理论的方法解决 $\mathcal P$ 的查找。

方法很简单，直接暴力拿一个 `vector` 存下当前的集合 $\mathcal P$，暴力更新，一旦遇到长度夹在一个更长的长度和其一半之间的元素直接删除即可。

~~但是我也不会证明这个方法维护是正确的。~~

其实很容易证明这是正确的，因为这个删除的过程就是在说明某个位置未来永远不会优于另一个位置。未来其也会大于一半，仍为等差数列的一部分，也仍对应一个周期。就算添元素，其也不会更优。

从而解完，总复杂度 $O(n\log n)$。

值得思考的是，如果强制在线，不能预处理 exkmp，此题是否仍可做到单 $\log$ 复杂度或者线性？如果还有删除操作呢？

### Code

核心代码很短。

```cpp
chr C[3000005];uint Z[3000005],Ans[3000005];
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    // freopen("QAQ.out","w",stdout);
#endif
    uint n=0;scanf("%s",C);while(C[n])n++;
    for(uint i=1,x=0;i<n;i++)
    {
        Z[i]=Z[x]+x<i?0:std::min(Z[x]+x-i,Z[i-x]);
        while(C[i+Z[i]]==C[Z[i]])Z[i]++;
        if(i+Z[i]>x+Z[x])x=i;
    }
    std::vector<uint>P={0};
    for(uint i=1;i<n;i++){
        P.push_back(i);
        for(uint j=P.size()-2;~j;j--)if(C[P[j]+i-P[j+1]]!=C[i])
        {
            if(C[P[j]+i-P[j+1]]<C[i])P.erase(P.begin()+j+1);
            else{P.erase(P.begin(),P.begin()+j+1);break;}
        }
        for(uint j=1;j<P.size();)if(P[j-1]+i>=2*P[j])P.erase(P.begin()+j);else j++;
        uint&ans=Ans[i]=P[0];
        for(uint j=1,p;j<P.size();j++)
        {
            p=P[j];
            if((Z[ans-p+i+1]<p-ans&&C[Z[ans-p+i+1]]<C[Z[ans-p+i+1]+ans-p+i+1])
            ||(Z[ans-p+i+1]>=p-ans&&Z[p-ans]<ans&&C[Z[p-ans]]>C[Z[p-ans]+p-ans]))
                ans=p;
        }
    }
    for(uint i=0;i<n;i++)printf("%u%c",Ans[i]+1," \n"[i==n-1]);
    return 0;
}
```


---

## 作者：big_news (赞：3)

我们知道对于最小表示法问题，有一个 $O(n)$ 的 lyndon 分解解法：

-  对串 $AA$ lyndon 分解，找到第 $|A|$ 个位置所在的 lyndon 串，那么最小表示法即是该字符串以这个 lyndon 串为起始的轮换

这样做就是 $O(n^2)$ 的，可以拿到 30pts 的好成绩。

先考虑一个错误的贪心：取字典序最小的后缀。这个贪心的错因在于接上前缀之后，字典序可能会变大，但是这启发我们，有用的后缀永远是字典序小的那些后缀。

形式化地，我们定义一个后缀 $s[i:]$ 有用，当且仅当仅不存在一个后缀严格小于它。这里 $s$ 严格小于 $t$ 指可以找到一个位置 $p\in [1,\min |s|,|t|]$，使得 $s_p<t_p$ 且 $s[1:p-1]=t[1:p-1]$。

可以发现，如果相邻的两个有用的后缀中，后面那个到前面那个的距离小于后面的串长，那么后面的那个没有用处，这个结论已经被其它题解的奆佬们证过了。这说明了有用的后缀数量是 $O(\log n)$ 的。

考虑维护有用的后缀构成的集合 $S$，记对于前缀 $i$，维护出的集合是 $S_i$，那么有 $S_{i+1}\subseteq S_i\cup \begin{Bmatrix} i+1\end{Bmatrix}$。

考虑由 $S_{i-1}$ 构造 $S_i$，我们枚举 $x\in S_{i-1}$，那么只需要考虑它和 $S_i$ 中最后一个元素 $y$，新增出来的这一位之间的大小关系，即比较两个字符的大小。这样可以确定保留 $x$ 或者 $y$。

然后再集合中新增 $i$ 即可。

考虑如何计算前缀 $i$ 时的答案，那么从前向后枚举每一个选出来的后缀，维护前面选出的最优解是 $x$，当前枚举到的解是 $y$，那么显然有 $|s[x:i]|>|s[y:i]|$，并且 $s[y:i]$ 是 $s[x:i]$ 的前缀。那么我们只需要比较剩下的部分，也就是比较 $s[x+i-y+1:]$ 和 $s[1:n]$ 的大小关系即可，这个可以扩展 KMP 预处理。

因此复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int CN = 3e6 + 10;
int read(){
    int s = 0, ne = 1; char c = getchar();
    for(; c < '0' || c > '9'; c = getchar()) if(c == '-') ne = -1;
    for(; c >= '0' && c <= '9'; c = getchar()) s = (s << 1) + (s << 3) + c - '0';
    return s * ne;
}
int n, z[CN]; char s[CN]; vector<int> cur, nxt;
int main(){
    freopen("_in.in", "r", stdin);
    scanf("%s", s + 1), n = strlen(s + 1), z[1] = n;
    for(int i = 2, l = 0, r = 0; i <= n; i++){
        if(i <= r) z[i] = min(z[i - l + 1], r - i + 1);
        while(i + z[i] <= n && s[i + z[i]] == s[z[i] + 1]) z[i]++;
        if(i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
    for(int i = 1; i <= n; i++){
        cur.pb(i); nxt.clear();
        for(int l = cur.size(), j = 0; j < l; j++){
            int u = cur[j]; bool flag = 1;
            while(!nxt.empty()){
                int v = nxt.back();
                if(s[i] > s[i - u + v]) {flag = 0; break;}
                if(s[i] == s[i - u + v]) break; nxt.pop_back();
            }
            if(flag && (!nxt.size() || (i - u <= u - nxt.back()))) nxt.pb(u);
        }
        cur = nxt; int ans = cur[0];
        for(int l = cur.size(), j = 1; j < l; j++){
            int u = cur[j], pos = ans + i - u + 1;
            if(pos + z[pos] <= i && s[pos + z[pos]] > s[1 + z[pos]]) ans = u;
            else if(pos + z[pos] > i){ // 超出来了，再轮一圈
                pos = i - pos + 2;
                if(pos + z[pos] <= u && s[pos + z[pos]] < s[1 + z[pos]]) ans = u; 
            }
        }
        printf("%d ", ans);
    }
    return puts(""), 0;
}
```

---

## 作者：Otomachi_Una_ (赞：1)

## 节日庆典

考虑 $i$ 从小变大的时候，哪些 $x$ 能作为预选答案。

首先不能存在 $y$ 使得 $S[y,i]$ 字典序严格小于 $S[x,i]$。这里严格小不能存在前缀关系。

你发现这样子预选答案还是很多。我们通过类似 border 理论的思想可以把这些东西变成 $\mathcal O(\log n)$ 种。

你发现如果两个备选答案 $x<y$ 满足 $i-y>y-x$，那么这个时候，可以假设 $S[x,i]=A\dots AB$，$S[y,i]=A\dots AB$（前者有 $t$ 个 $A$，后者有 $t-1$ 个 $A$）。

那你发现 $S[y,i]$ 肯定不如 $S[x,i],B$ 之一。于是 $y$ 必然不能作为答案。

最后我们把预选答案集合缩成 $\mathcal O(\log n)$ 个。我们只需要考虑如何快速比较这些被选元素的大小。即比较 $x<y$，$S[x,i]+S[1,x-1],S[y,i]+S[1,y-1]$ 的大小。

应为备选集合的条件，所以 $S[y,i]$ 应该是 $S[x,i]$ 的前缀，不需要比较。

剩下就是比较 $S[x+(i-y),i]+S[1,x-1]$ 和 $S[1,y-1]$ 的大小。你发现两坨东西都是形如一个子序列和前缀比大小的样子，你直接用 exkmp 处理出每个后缀和原串的 lcp，就可以 $\mathcal O(1)$ 比较其大小了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=3e6+5;
int n,lcp[MAXN];char s[MAXN];
void exkmp(){
	for(int i=2,l=0,r=0;i<=n;i++){
		if(i<=r) lcp[i]=min(lcp[i-l+1],r-i+1);
		while(i+lcp[i]<=n&&s[lcp[i]+1]==s[i+lcp[i]]) lcp[i]++;
		if(i+lcp[i]-1>r) l=i,r=i+lcp[i]-1;
	}
}
bool chkmin(int x,int y,int r){// return s[x:r]+s[1:x-1]<s[y:r]+s[1+y-1]
	x=(x+r-y)+1;y=1;
	if(lcp[x]<r-x+1) return s[x+lcp[x]]<s[lcp[x]+1];
	y=(y+r-x)+1;
	if(lcp[y]<r-y+1) return s[lcp[y]+1]<s[y+lcp[y]];
	return true;
}
int main(){
	ios::sync_with_stdio(false);
	// freopen("input.txt","r",stdin);
	// freopen("output.txt","w",stdout);
	cin>>s+1;n=strlen(s+1);
	exkmp();
	vector<int> cur,nxt;
	for(int i=1;i<=n;i++){
		cur.push_back(i);nxt.clear();
		for(int j:cur){
			bool flag=true;
			while(!nxt.empty()){
				int k=nxt.back();
				if(s[i-j+k]==s[i]) break;
				else if(s[i-j+k]<s[i]) {flag=false;break;}
				else nxt.pop_back();
			}
			if(flag&&(nxt.empty()||i-j<=j-nxt.back())) nxt.push_back(j);
		}
		cur=nxt;int ans=cur[0];
		for(int j:cur) ans=chkmin(ans,j,i)?ans:j;
		cout<<ans<<" \n"[i==n];
	}
	return 0;
}
```

---

## 作者：GK0328 (赞：1)

**exkmp**

本题的突破口在于，对于一个位置$i$，从$i$以后可能成为最优解的后缀数量极少。

容易发现，当我们处理到位置$k$时，对于此时的两个后缀$i,j(i<j)$，如果$T_i,T_j$均有可能在$\ge k$的位置成为最优解，那么一定满足$\operatorname{lcp}(T_i,T_j) \ge k-j+1$。

但上面的限制仍然不够，对于长度相邻的两个后缀$i,j(i<j)$，我们可以证明：$k-j+1<j-i$。

利用反证法，假设$k-j+1 \ge j-i$。

设$S_k=ABBC,T_i=BBCA,T_j=BCAB$，$C$为$B$的前缀。

$T_{2j-i}=CABB$。

我们先在$k$的情况下观察：

$1.$当$BCA \le CAB$时，$T_i \le T_j$。

$2.$当$BCA > CAB$时，$T_{2j-i}>T_j$。

因此在$k$处，$j$不可能是最优解。

那么我们扩展到$k'>k$处。

$S_{k'}=ABBCD,T'_i=BBCDA,T'_j=BCDAB,T'_{2j-i}=CDABB$。

同理：

$1.$当$BCDA \le CDAB$时，$T'_i \le T'_j$。

$2.$当$BCDA > CDAB$时，$T'_{2j-i}>T'_j$。

因此$j$不可能再成为最优解了，可以直接剔除。

$k-j+1<j-i$，容易得到满足条件的后缀数量为$\log k$。

那么我们每次操作完成之后，直接暴力重构集合，利用**exkmp**可以$O(1)$比较两个后缀。

时间复杂度：$O(n \log n)$。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define il inline
#define rint register int
#define N 3000005
using namespace std;
int n,c,z[N],q[35];
bool vis[N];
char s[N];
il void print(int x)
{
    if (x>9)
        print(x/10);
    putchar(x%10+'0');
}
il int cmn(int x,int y)
{
    return (x<y)?x:y;
}
il void fil(int k)
{
    int c2(0);
    for (rint i=c-1;i;--i)
    {
        int wz(q[i]+(k-q[i+1]+1)-1);
        if (s[wz]<s[k] || s[wz]==s[k] && k-q[i+1]+1>=q[i+1]-q[i])
            vis[q[i+1]]=true;
        if (s[wz]>s[k])
            q[i]=q[i+1];
    }
    for (rint i=1;i<=c;++i)
        if (!vis[q[i]])
            q[++c2]=q[i]; else
            vis[q[i]]=false;
    swap(c,c2);
}
il void ckmin(int &i,int j,int k)
{
    if (z[i+(k-j+1)]>=j-i)
    {
        if (z[j-i+1]>=i-1)
            return;
        if (s[j-i+1+z[j-i+1]]<s[z[j-i+1]+1])
            i=j;
        return;
    }
    if (s[z[i+(k-j+1)]+1]<s[i+(k-j+1)+z[i+(k-j+1)]])
        i=j;
}
il int calc(int k)
{
    int ans=q[1];
    for (rint i=2;i<=c;++i)
        ckmin(ans,q[i],k);
    return ans;
}
int main()
{
    scanf("%s",s+1);
    z[1]=n=strlen(s+1);
    int l(1),r(0);
    for (rint i=2;i<=n;++i)
    {
        if (i<=r)
            z[i]=cmn(r-i+1,z[i-l+1]);
        while (i+z[i]<=n && s[i+z[i]]==s[z[i]+1])
            ++z[i];
        if (i+z[i]-1>r)
            l=i,r=i+z[i]-1;
    }
    for (rint i=1;i<=n;++i)
    {
        q[++c]=i;
        fil(i);
        print(calc(i)),putchar(' ');
    }
    putchar('\n');
    return 0;
}
```

---

## 作者：向日葵小班 (赞：0)

###  题目大意:

&emsp;&emsp; 给出串 $s$，求其各个前缀的最小循环表示的开头位置。
$|s| ≤ 3 × 10^6$。

&emsp;&emsp;提示：一个位置是最小循环表示的开头 $⇒$ 是 $\operatorname{Ssuf}$ 的开头。



------------
### 前置知识：[最小后缀](https://www.luogu.com.cn/blog/yyqkn/solution-p5211)




------------

&emsp;&emsp;考虑逐个求出前缀的 $\operatorname{Ssuf}$ 集合，并在其中比较出最小的循环表示。

&emsp;&emsp;记目前的 $\operatorname{Ssuf}$ 集合为 $D$，在串末加入字符 $S_r$ 时，将 $S[r:r]$ 加入 $D$。

&emsp;&emsp;接下来，按照长度从小到大检查相邻的两个 $s_1,s_2∈D(|s_1|<|s_2|)$。若 $s_1$ 已经不是 $s_2$ 的前缀，则舍掉（字典序）较大的那个。（这里可以利用加字符前 $s_1$ 是 $s_2$ 的前缀，仅检查一个字符，大小也可以快速判断）

&emsp;&emsp;检查完毕后，得到的就是新的 $\operatorname{Ssuf}$ 集合。

&emsp;&emsp;找出最小循环表示时需要字符串比较，若使用 $\operatorname{SA}$ 等经典后缀数据结构，在本题的规模下难以通过。

&emsp;&emsp;寻找性质以简化问题，能够发现，我们比较的两个 $\operatorname{Ssuf}$ 一定有前缀关系。不妨设我们比较的是 $s_1,s_2∈D$ 且 $s_2$ 是 $s_1$ 的前缀。

&emsp;&emsp;设 $s_1=s_2s_3s_2$，$s=s_0s_2s_3s_2$，则 $s_1$,$s_2$ 分别导出的循环表示为 $s_2s_3s_2s_0$，$s_2s_0s_3s_2$。同时消去 $s_2$ 可得 $s_3s_2s_0$,$s_0s_3s_3$，这分别是 $s$ 的后缀和前缀。

&emsp;&emsp;使用扩展 KMP 求出每个后缀和原串的 LCP 即可支持快速比较。

&emsp;&emsp;算法复杂度 $O(n\log n)$，由于常数小，可以通过。

---


# [TJOI2019] 甲苯先生的线段树

## 题目背景

TJOI2019 D2T3

源文件名：segment.*

时间限制: 4s 内存限制: 128M

## 题目描述

大中锋走在路上见到正在战术后仰的甲苯先生。因为甲苯先生帮助他解决了祖传 `Hello word!` 的代码密码，大中锋想上前打个招呼。

甲苯先生突然举起喇叭说：「大家好，我是甲苯拦你斯特，是凯岩城的首席文化大使，七十二变显神通，百般武艺样样有，感受不一样的权游文化。」

这时甲苯先生看到了大中锋，激动的拉着大中锋说：「为了筹钱去北境打异鬼，我参加了今年下半年中外合写的 `stl+` 项目，我将在项目中担任线段树的主写人，但是改写不是乱写，在我写的时候，发现线段树是一个满二叉树，如果让根节点编号为 $1$，对于一个编号为 $x$ 的节点，令左孩子编号为 $2x$ ，右孩子编号为 $2x+1$ 时，现在在这个二叉树上有两个节点 $a,b$，现在我想知道节点 $a$ 到节点 $b$ 之间一条路径编号和最小为多少？你要是不会就直接给我 328，我不知道什么是暗影崛起，也不知道什么是怪盗军团。」

大中锋回答：「那不就是求一条简单路径直接算吗？」甲苯先生：「那你求这颗满二叉树中还有多少条简单路径等于这个值？不知道了吧，给我 328，我到北境打赢异鬼，回到凯岩城我就还你，我们拦你斯特，有债必偿。」

大中锋为了不给甲苯先生 328，请求作为好朋友的你写一个程序能解决甲苯先生的问题。

简单路径指的是路径上各个顶点均不重复的路径。

## 说明/提示

### 样例解释 ###

对于一颗深度为 $3$ 的满二叉树，含有节点 $1,2,3,4,5,6,7$ 。

节点 $1$ 到 $1$ 的路径编号和为 $1$ ，且没有其他路径编号和为 $1$ 。

节点 $1$ 到 $2$ 的路径编号和为 $1+2=3$ ，存在路径 3-3 编号和为 $3$。

节点 $2$ 到 $4$ 的路径编号和为 $2+4=6$ ，存在路径 2-1-3 和路径 6-6 编号和为 $6$ 。

节点 $1$ 到 $5$ 的路径编号和为 $1+2+5=8$ ，存在路径 8-8 编号和为 $8$ ，但是节点 $8$ 的深度为 $4$ 不满足条件。

### 数据范围 ###

对于 $20\%$ 的数据，仅存在 $c = 1$ 的情况

对于 $20\%$ 的数据， $d \leq 10$

对于 $30\%$ 的数据， $d \leq 20$

对于 $40\%$ 的数据， $d \leq 25$

对于 $50\%$ 的数据， $d \leq 30$

对于 $100\%$ 的数据， $d \leq 50,T \leq 10$


## 样例 #1

### 输入

```
8
3 1 1 1
3 1 1 2
3 1 2 1
3 1 2 2
3 2 4 1
3 2 4 2
3 1 5 1
3 1 5 2```

### 输出

```
1
0
3
1
6
2
8
0```

# 题解

## 作者：花淇淋 (赞：7)

# Address
[P5342 [TJOI2019]甲苯先生的线段树 ](https://www.luogu.org/problemnew/show/P5342)

# Solution
 - 对于 $c=1$，由于路径长度为 $O(d)$ 级别，只要知道 $lca(x,y)$ 就是 $x,y$ 二进制下的 $lcp$ 就可以做了。

****
 - 对于 $c=2$，先和 $c=1$ 一样求出路径编号和，然后要知道一个显然性质和一个神仙性质：
 $(1).$ 记 $x$ 二进制中 $1$ 的个数为 $cnt(x)$，则 $x$ 到根的路径编号和为 $2x-cnt(x)$。**注意这个性质在根为 $0$ 时也成立，只要 $x$ 的儿子还是 $2x,2x+1$。**
 $(2).$ 记路径的编号和为 $s$，路径的两个端点为 $x,y$，$lca(x,y)=z$，$x→z$ 要经过 $a$ 条边，$y→z$ 要经过 $b$ 条边。那么当 $a,b,s$ 都为定值时，$z$ 也必为定值。
 ****
 - 考虑证明性质 $(2):$
   把路径 $x→y(x<y)$ 上的每个点编号写成二进制，它们的 $lcp$ 就是 $z$ 的二进制。记 $z$ 的二进制有 $t$ 位，那么先算出每个点编号前 $t$ 位的值的贡献。$z$ 的贡献是 $z$，$z$ 的每个儿子的贡献是 $2z$，每个孙子的贡献是 $4z$，依此类推，可以得出前 $t$ 位的总贡献 $v$ 为：
   $z+2z+4z+....+2^{a}z+z+2z+4z+...+2^{b}z-z$
   $=(2^{a+1}+2^{b+1}-3)z$
 - 记 $k$ 为其它贡献，即：$vz+k=s$
   讨论 $k$ 的取值范围（先假设 $a,b>0$）：
   $1.$ $z$ 往左走 $1$ 步，然后往**左**走 $a-1$ 步到 $x$；$z$ 往右走 $1$ 步，然后往**左**走 $b-1$ 步到 $y$。路径 $x→z$ 对 $k$ 的贡献为 $0$，$y→z$ 对 $k$ 的贡献为 $2^b-1$，此时 $k$ 取最**小**值。
   $2.$ $z$ 往左走 $1$ 步，然后往**右**走 $a-1$ 步到 $x$；$z$ 往右走 $1$ 步，然后往**右**走 $b-1$ 步到 $y$。路径 $x→z$ 对 $k$ 的贡献为 $2^a-a-1$，$y→z$ 对 $k$ 的贡献为 $2^{b+1}-b-2$，此时 $k$ 取最**大**值。
   综上所述，$k∈[2^b-1,2^a+2^{b+1}-a-b-3]$。
 - 发现 $k < v$，那么 $z=s/v,k=s\%v$，$v$ 的值只和 $a,b$ 有关，所以 $z$ 为定值，证毕。
 ****
 
 - 那么问题转化为：找到两个数 $p,q$（就是 $x,y$ 砍掉前 $t$ 位之后的值，砍掉前 $t$ 位后，$x$最高位是 $0$，$y$ 最高位是 $1$），$p<2^{a-1},q<2^b,2(p+q)-cnt(p)-cnt(q)=k$，注意 $q$ 的 $2^{b-1}$ 位必须为 $1$。
 - 枚举 $cnt(p)+cnt(q)$，得到 $a+b=w$，做数位$dp$，$f[i][j][k=0/1]$ 表示从个位开始（$a,b$ 同时填），填了 $i$ 位，此时共填 $j$ 个 $1$，是否进位到第 $i+1$ 位，要求 $a+b$ 的每一位都和 $w$ 对上即可。
 - ~~注意细节~~，注意多开 $long$ $long$，注意树高对 $a,b,z$ 值的限制。
 - 时间复杂度 $O(d^5)$，常数显然很小。

# Code
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long

template <class t>
inline void read(t & res)
{
    char ch;
    while (ch = getchar(), !isdigit(ch));
    res = ch ^ 48;
    while (ch = getchar(), isdigit(ch))
    res = res * 10 + (ch ^ 48);
}

template <class t>
inline void print(t x)
{
    if (x > 9) print(x / 10);
    putchar(x % 10 + 48);
}

const int e = 205;
ll f[e][e][2], ans;
bool a1[e], b1[e];

inline ll dp(int a, int b, ll s, int c)
{
    int i, j, t, x, y, bit = max(max(a - 1, b), (int)log2(s) + 1) + 1; 
    bool flag = a == 3 && b == 2;
    for (i = 0; i < bit; i++)
    for (j = 0; j <= c; j++)
    f[i][j][0] = f[i][j][1] = 0;
    i = 0;
    for (x = 0; x <= 1; x++)
    for (y = 0; y <= 1; y++)
    {
        int k = x + y >> 1, z = x + y & 1;
        if (i == b - 1 && !y) continue;
        if (z != (s & 1)) continue;
        if (i > b - 1 && y) continue;
        if (i > a - 2 && x) continue;
        f[0][x + y][k]++;
    }
    for (i = 0; i < bit - 1; i++)
    {
        ll d = s & (1ll << i + 1);
        if (d) d = 1;
        for (j = 0; j <= c; j++)
        for (t = 0; t <= 1; t++)
        if (f[i][j][t])
        for (x = 0; x <= 1; x++)
        for (y = 0; y <= 1; y++)
        {
            int now = x + y + t, k = now >> 1, z = now & 1;
            if (i + 1 == b - 1 && !y) continue;
            if (z != d) continue;
            if (i + 1 > b - 1 && y) continue;
            if (i + 1 > a - 2 && x) continue;
            f[i + 1][j + x + y][k] += f[i][j][t];
        }
    }
    return f[bit - 1][c][0];
}

inline ll calc(ll x)
{
    ll res = x << 1;
    while (x) res -= x & 1, x >>= 1;
    return res;
}

int main()
{
    int i, lx, ly, op, tst, h;
    ll x, y, z;
    read(tst);
    while (tst--)
    {
        read(h); read(x); read(y); read(op);
        ll x2 = x, y2 = y;
        lx = ly = z = 0;
        while (x) a1[++lx] = x & 1, x >>= 1;
        while (y) b1[++ly] = y & 1, y >>= 1;
        reverse(a1 + 1, a1 + lx + 1);
        reverse(b1 + 1, b1 + ly + 1);
        for (i = 1; i <= lx && i <= ly; i++)
        if (a1[i] == b1[i]) z = z * 2 + a1[i];
        else break;
        ll s = calc(x2) + calc(y2) - calc(z) - calc(z >> 1);
        if (op == 1)
        {
            print(s);
            putchar('\n');
            continue;
        }
        ans = 0;
        for (int a = 0; a < h; a++)
        for (int b = 0; b < h; b++)
        {
            ll y = ((1ll << a + 1) + (1ll << b + 1) - 3), x = s / y;
            if (!x) continue;
            if ((int)log2(x) + 1 + max(a, b) > h) continue;
            ll k = s - x * y;
            for (int c = 0; c <= a + b; c++) 
            if ((k + c) % 2 == 0) ans += dp(a, b, k + c >> 1, c);
        }
        print(ans - 1);
        putchar('\n');
    }
    return 0;
}
            ll k = s - x * y;
            for (int c = 0; c <= a + b; c++) 
            if ((k + c) % 2 == 0) ans += dp(a, b, k + c >> 1, c);
        }
        print(ans - 1);
        putchar('\n');
    }
    return 0;
}
```


---

## 作者：Log_x (赞：2)


## Solution

- 挺有意思的题。

- 第一问就是暴力在树上跳，设答案为 $s$。

- 考虑第二问，单点的情况直接处理，设路径上深度最小的点为 $x$，先从简单的情况入手。

--- 

- 对于从 $x$ 往下走形成的长度为 $h(h > 1)$ 的链，如果往下走的过程中都是往左孩子走，链的编号总和为 $\sum \limits_{i = 0}^{h - 1}2^ix = (2^h - 1)x$。

- 考虑把某一步改为往右孩子走，不难发现每个右孩子的贡献是独立的。把走到倒数第 $i$ 个节点的那一步改为往右孩子走产生的贡献为 $\sum \limits_{j = 0}^{i - 1}2^j = 2^i - 1$。

- 一个非常关键的结论：
> 当 $s,h$ 已知时，若存在合法的 $x$，$x$ 为定值 $\begin{aligned} \lfloor \frac{s}{2^h - 1}\rfloor \end{aligned}$。

- 证明：
> 1. 显然有 $\begin{aligned} x \le \lfloor \frac{s}{2^h - 1} \rfloor \end{aligned}$。
> 2. 若 $\begin{aligned} x = \lfloor \frac{s}{2^h - 1} \rfloor - 1  \end{aligned}$，全往右儿子走的编号和为
$$
\begin{aligned}
s' &= (2^{h} - 1)( \lfloor \frac{s}{2^{h} - 1} \rfloor - 1) + \sum \limits_{i = 1}^{h - 1}{(2^i - 1)}\\
&= (2^h - 1) \lfloor \frac{s}{2^h - 1} \rfloor - h <s\\ 
\end{aligned}$$ 
> 因此 $\begin{aligned} x \ge  \lfloor \frac{s}{2^h - 1} \rfloor \end{aligned}$。
> 
> 3. 综上，$\begin{aligned} x = \lfloor \frac{s}{2^h - 1} \rfloor \end{aligned}$。

- 现在问题转化为用 $2^i - 1(1 \le i < h)$ 的和来表示 $s - (2^h - 1)x$，又因为 $2^i - 1 > \sum \limits_{j = 1}^{i - 1}(2^j - 1)$，直接从大到小枚举 $i$，贪心填入即可。

--- 

- 考虑 $x$ 同时有左孩子和右孩子的情况，设从左孩子往下走所形成的链（包含点 $x$）的长度为 $h_1(h_1 \ge 2)$，从右孩子往下走所形成的链（包含点 $x$）的长度为 $h_2(h_2 \ge 2)$。

- 同样地，若往下走的过程中都是往左孩子走，路径的编号和
$$
\begin{aligned}
& = 2x(2^{h_1 - 1}-1) + (2x+1)(2^{h_2 - 1} - 1) + x\\
& = (2^{h_1} + 2^{h_2} - 3)x + 2^{h_2 - 1} - 1\\ 
\end{aligned}$$

- 同理可证：
> 当 $s, h_1, h_2$ 固定时，若存在合法的 $x$，$x$ 为定值 $\begin{aligned} \lfloor \frac{s - 2^{h_2 - 1} + 1}{2^{h_1} + 2^{h_2} - 3}\rfloor \end{aligned}$。

- 现在问题转化为在 $2^{i_1} - 1(1 \le i_1 \le h_1 - 2)$ 以及 $2^{i_2} - 1(1 \le i_2 \le h_2 - 2)$ 中选取若干个数字来表示 $s - (2^{h_1} + 2^{h_2} - 3) s - 2^{h_2} + 1$，显然不能再像上面那样贪心了。

- 枚举选出的数字个数 $cnt$，把问题进一步转化为在 $2^{i_1} (1 \le i_1 \le h_1 - 2)$ 和 $2^{i_2} (1 \le i_2 \le h_2 - 2)$ 中选取若干个数字来表示 $v = s - (2^{h_1} + 2^{h_2} - 3) s - 2^{h_2} + cnt + 1$。
- 因为 $2^i$ 可以看成是二进制位上的 `+1`，考虑 `数位DP`。
- 设 $f[i][j][k]$ 表示从第低到高处理到第 $i$ 位、已经选了 $j$ 个数字且对第 $i + 1$ 位是/否有进位 $(k = 0/1)$ 时的方案数，容易得到转移：
$$
\begin{aligned} 
f[i + 1][j + a + b][\lfloor \frac{k + a + b}{2} \rfloor] += f[i][j][k]\\ 
\end{aligned}$$

- 其中 $a, b$ 表示第 $i$ 位在 $2^{i_1}(1 \le i_1 \le h_1 - 2)$ 和 $2^{i_2}(1 \le i_2 \le h_2 - 2)$ 中是否选了数，需要根据 $h_1,h_2$ 进行限制，并且保证 $(k + a + b) \mod 2$ 的值和 $v$ 的第 $i$ 位相同。

--- 

- 总的时间复杂度 $\mathcal O(Td^5)$。

## Code

```cpp

#include <bits/stdc++.h>

template <class T>
inline void read(T &res)
{
	char ch;
	while (ch = getchar(), !isdigit(ch));
	res = ch ^ 48;
	while (ch = getchar(), isdigit(ch))
		res = res * 10 + ch - 48;
}

template <class T>
inline void put(T x)
{
	if (x > 9)
		put(x / 10);
	putchar(x % 10 + 48);
}

typedef long long ll;
const int N = 55;
const int M = 105;
int T, d, c;
ll a, b, s, f[N][M][2];

template <class T>
inline void CkMin(T &x, T y) {x > y ? x = y : 0;}
template <class T>
inline T Max(T x, T y) {return x > y ? x : y;}
template <class T>
inline T Min(T x, T y) {return x < y ? x : y;}

inline int askD(ll x)
{
	int cnt = 0;
	while (x)
		x >>= 1, ++cnt;
	return cnt;
}

inline ll askVal()
{
	int da = askD(a), db = askD(b);
	if (da > db)
		std::swap(a, b), std::swap(da, db);
	ll ans = 0;
	while (db > da)
	{
		ans += b;
		b >>= 1;
		--db;
	}
	while (a != b)
	{
		ans += a + b;
		a >>= 1;
		b >>= 1;
	}
	return ans + a;
}

inline int solve1()
{
	int ans = 0;
	for (int h = 2; h <= d; ++h)
	{
		ll x = s / ((1ll << h) - 1);
		if (!x)
			break ;
		if (askD(x) + h - 1 > d)
			continue ;
		ll delt = s - ((1ll << h) - 1) * x;
		for (int j = h - 1; j >= 1; --j)
			if (delt >= (1ll << j) - 1)
				delt -= (1ll << j) - 1;
		!delt ? ++ans : 0;
	}
	return ans;
}

inline ll solve2()
{
	ll res = 0;
	for (int h1 = 2; h1 <= d; ++h1)
		for (int h2 = 2; h2 <= d; ++h2)
		{
			if (s - (1ll << h2 - 1) + 1 <= 0)
				break ;
			ll x = (s - (1ll << h2 - 1) + 1) / ((1ll << h1) + (1ll << h2) - 3);
			if (!x)
				break ;
			if (askD(x) + Max(h1, h2) - 1 > d)
				continue ;
			ll delt = s - ((1ll << h1) + (1ll << h2) - 3) * x - (1ll << h2 - 1) + 1;
			int tot = h1 + h2 - 4;
			for (int cnt = 0; cnt <= tot; ++cnt)
				if (!(delt + cnt & 1))
				{
					delt += cnt;
					int ds = askD(delt) + 1;
					for (int i = 1; i <= ds + 1; ++i)
						for (int j = 0, jm = i - 1 << 1; j <= jm; ++j)
							f[i][j][0] = f[i][j][1] = 0;	
					f[1][0][0] = 1;
					for (int i = 1; i <= ds; ++i)
						for (int j = 0, jm = Min(i - 1 << 1, tot); j <= jm; ++j)
							for (int k = 0; k < 2; ++k)
								if (f[i][j][k])
								for (int a = 0, am = i < h1 - 1 ? 1 : 0; a <= am; ++a)
									for (int b = 0, bm = i < h2 - 1 ? 1 : 0; b <= bm; ++b)
										if ((k + a + b & 1) == (delt >> i & 1))
											f[i + 1][j + a + b][k + a + b >> 1] += f[i][j][k];
					res += f[ds + 1][cnt][0];
					delt -= cnt;
				}
		}
	return res;

}

int main()
{
	read(T);
	while (T--)
	{
		read(d); 
		read(a);
		read(b);
		read(c);

		s = askVal();
		put(c == 1 ? s : solve1() + solve2() - (s >= (1ll << d))), putchar('\n');
	}
}

```


---

## 作者：ThomasX (赞：2)

**搬运官方题解。**

------------

第一问比较简单，直接求通过$/2$求lca即可。但是通过第一问需要发现如下规律，存在一个序列 $x_1,x_2,x_3,\cdots,x_k$ ，满足$x_1=1,x_{i/2}=x_{i-1}$，那么$x_1+x_2+x_3+\cdots+x_k=2\times x_k-BitCount(x_k)$ 其中$BitCount(x_k)$表示$x_k$的二进制表示中$1$的个数。其实就是本题目中从$root$到节点$x_k$的一条路径。通过第一问，第二问就是求出能够组合出$sum$的方案数。在该满二叉树中，简单路径的情况可以归纳为从$lca$往两端延长的形状。因而可以想到枚举$lca$和两端路径的深度，对于每种情况，通过数位dp进行求解。问题可以分为以下两个问题

问题1，枚举问题是枚举$lca$是否是合理的呢？通过简单的计算可以发现的是，当$lca$的两端路径深度固定时，对于$lca$为编号$x$的最大构造方案也小于$lca$为标号$x+1$的最小构造方案，因而其实不用枚举$lca$，只需要枚举两端路径的高度即可，然后通过计算不难求出$lca$。该问题的复杂度为$O(d^2)$

问题2，数位dp解决了问题1，可以通过对$sum$减去一定的值得到$sum'$，将问题从以$lca$为根节点转化为以$root$为根节点的问题。 结合上面发现的规律，原问题可以表示成求有多少种方案满足长度为$L$的二进制数$x_l$和长度为$R$的二进制数$x_r$满足$x_l+x_r-$二进制数中$1$的个数$=sum'$，那么只要在$[0,L+R]$的区间里枚举$1$的个数，即可通过数位dp求出方案数。该问题的复杂度也为$O(d^2)$，同时有一个较大的常数，所以总的复杂度为$O(d^4)$。

------------

std
```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
typedef long long LL;
 
LL n, ans;
const int B=60; 
LL dp[2][B+1][B+B+1];

LL solve(LL sum, LL bits, LL dmax, LL emax) {
	LL lastbit = 1;
	while ((1LL<<lastbit) <= sum) ++lastbit;

	for (int b = 0; b <= bits; ++b)
		dp[0][0][b] = dp[1][0][b] = 0;
	dp[0][0][0] = 1;
	
	for (int b = 1; b < lastbit; ++b) {
		sum >>= 1;
		for (int bt = 0; bt <= bits; ++bt) {
			dp[0][b][bt] = dp[sum&1][b-1][bt];
			dp[1][b][bt] = 0; 
			if (bt > 0 && b <= dmax) dp[1^sum&1][b][bt] += dp[1^sum&1][b-1][bt-1];
			if (bt > 0 && b <= emax) dp[1^sum&1][b][bt] += dp[1^sum&1][b-1][bt-1];
			if (bt > 1 && b <= dmax && b <= emax)
				dp[1][b][bt] += dp[sum&1][b-1][bt-2];
		}
	}
	LL r = dp[0][lastbit - 1][bits];
	return r;
}
 
int gettmp(long long x){
	int ret=0;
	while(x){
		if(x&1) ret++;
		x>>=1;
	}
	return ret;
}

int main()
{
	freopen("segment.in", "r", stdin);
	freopen("segment.out", "w", stdout);	
	int T;
	cin >> T;
	while(T--){
	ans=0;
	long long d,x,y;
	cin >> d;
	int tp;
	cin >> x >> y;
	cin >> tp;
	long long tx=x,ty=y;
	while(tx!=ty){
		if(tx>ty) tx/=2;
		else ty/=2;
	}
	tx/=2;
	long long n = 2*x+2*y-2*tx-2*ty+gettmp(ty)-gettmp(x)-gettmp(y)+gettmp(tx);
	if (tp==1){
		cout << n << endl;
		continue;
	}
	for( int i = 0 ; i < d ; i++ )
		for( int j = 0 ; j < d ; j++ )
		{
			LL mul = ( 1LL << i + 1 ) + ( 1LL << j + 1 ) - 3;
			if( n < mul ) break;
			long long tmp = n/mul;
			int lenx = 0;
			while(tmp){tmp>>=1;lenx++;}
			if(lenx+i>d||lenx+j>d) continue;
			LL now = n % mul - ( 1LL << j ) + 1;
			if( now < 0 ) continue;
			int cnt = i + j;
			for( int k = now & 1 ; k <= cnt ; k += 2 )
			{
				LL tot = now + k;
				ans += solve(tot, k, i - 1, j - 1);
			}
			//cout << lenx << " " << i << " " << j << " " << ans << endl;
		}
	cout << ans-1 << endl;
	}
}

```


---

## 作者：木xx木大 (赞：1)

[P5342 [TJOI2019]甲苯先生的线段树](https://www.luogu.com.cn/problem/P5342) 

勉强算[双倍经验](https://www.luogu.com.cn/problem/CF750G)？

第一问怎么做都行，我的做法是求出两个点到根的路径点权和，再减去 $lca$ 到根的路径点权和。一个数到根的路径点权和可以考虑其二进制下每一位的贡献，即若第 $i$ 位为 1 ，贡献为 $2^i+2^{i-1}+\dots +2^0=2^{i+1}-1$。两个数的 $lca$ 即把它们写成两个二进制串时这两个串的最长公共前缀。

设第一问求出的答案为 $s$。对于第二问，先考虑选一条从上到下的链怎么做。如果上面的点为 $x$，链长为 $i$，且一直往左下走，则点权和为 $x+2x+2^2x+\dots 2^{i-1}x=(2^i-1)x$。因此 $x\le\lfloor\frac{s}{2^i-1}\rfloor$。如果第 $j$ 步（$j\in[1,i)$）向右走，则还要再加上 $1+2+2^2+\dots+2^{i-j-1}=2^{i-j}-1$。当 $x=\lfloor\frac{s}{2^i-1}\rfloor-1$时，如果全往右走，则点权和为 $(2^i-1)x+\sum_{j=1}^{i-1}(2^{i-j}-1)=(2^i-1)x+2^i-1-i=(2^i-1)\lfloor\frac{s}{2^i-1}\rfloor-i<s$。因此 $x=\lfloor\frac{s}{2^i-1}\rfloor$。枚举链长 $i$，则可以算出 $x$，从大到小枚举 $j$ 检验是否有可行方案即可。

对于有分岔的情况，设 $x$ 向左、右延伸的两条链长度分别为 $i,j$，若两条链均一直向左走，则点权和为$(2^i+2^j-3)x+2^{j-1}-1$，则 $x\le\lfloor\frac{s+1-2^{j-1}}{2^i+2^j-3}\rfloor$。当 $x=\lfloor\frac{s+1-2^{j-1}}{2^i+2^j-3}\rfloor-1$时，若两条链均一直往右走，则点权和为 $(2^i+2^j-3)x+2^j-1+2^{i-1}-i-j=(2^i+2^j-3)\lfloor\frac{s+1-2^{j-1}}{2^i+2^j-3}\rfloor+2-2^{i-1}-i-j<s$，因此 $x$ 是固定的。

枚举 $i,j$，算出 $x$ ，问题转化为用 $2^1-1,2^2-1\dots,2^{i-1}-1,2^1-1,2^2-1\dots,2^{j-1}-1$凑出一个给定的数 $res$ 的方案数。枚举用了 $k$ 个数，则问题转化为用一些 2 的幂凑出 $v=res+k$ 的方案数。考虑数位 dp ，设 $f(i,j,k)$ 表示从低到高前 $i$ 位选了 $j$ 个数，是否向更高一位进位的方案数。设 $a,b$ 分别表示左右两链这一位是否选数，转移为 $f(i+1,j+a+b,\lfloor\frac{k+a+b}2\rfloor)+=f(i,j,k)$，dp 过程中要保证 $(k+a+b)\bmod 2$ 与 $v$ 这一位相同。

复杂度为 $O(Td^5)$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	
	const int N=110;
	ll A,B,C,D,f[N][N][2];
	int a[N],b[N];
	int askk(ll x)
	{
		int cnt=0;
		while(x)x>>=1,cnt++;
		return cnt;
	}
	ll solve(ll s)
	{
		ll ans=0,n=0;
		while((1ll<<(n+1))-1<=s)n++;
		n=min(n,D);
		for(int i=1;i<=n;i++)
		{
			ll x=s/((1ll<<i)-1),res=s-((1ll<<i)-1)*x;
			if(askk(x)+i-1>D)continue;
			for(int j=i-1;j;j--)
				if(res>=(1ll<<j)-1)res-=(1ll<<j)-1;
			if(!res)ans++;
		}
		for(int i=1;i<n;i++)
			for(int j=1;j<n;j++)
			{
				if((1ll<<(i+1))+(1ll<<(j+1))-3+(1<<j)-1>s)break;
				ll x=(s+1-(1ll<<j))/((1ll<<(i+1))+(1ll<<(j+1))-3),res=(s+1-(1ll<<j))-x*((1ll<<(i+1))+(1ll<<(j+1))-3);
				if(askk(x)+max(i,j)>D)continue;
				for(int k=0;k<=i+j-2;k++)
				{
					if((res+k)&1)continue;
					memset(f,0,sizeof(f));
					f[0][0][0]=1;
					ll tmp=(res+k)>>1,y=tmp,lim=0;
					while(y)lim++,y>>=1;
					for(int p=1;p<=lim;p++)
						for(int q=0;q<=2*(p-1);q++)
							for(int a=0,c;a<=(p<i);a++)
								for(int b=0;b<=(p<j);b++)
									c=((a+b)&1)!=((tmp>>(p-1))&1),f[p][q+a+b][(a+b+c)/2]+=f[p-1][q][c];
					ans+=f[lim][k][0];
					
				}
			}
		return ans;
	}
	void work()
	{
		int T;
		scanf("%d",&T);
		while(T--)
		{
			scanf("%lld%lld%lld%lld",&D,&A,&B,&C);
			int cnt1=0,cnt2=0;
			ll s=0;
			while(A)a[++cnt1]=A&1,A>>=1;
			while(B)b[++cnt2]=B&1,B>>=1;
			for(int i=1;i<=cnt1;i++)
				if(a[i])s+=(1ll<<i)-1;
			for(int i=1;i<=cnt2;i++)
				if(b[i])s+=(1ll<<i)-1;
			int x=0;
			while(a[cnt1-x]==b[cnt2-x]&&x<min(cnt1,cnt2))x++;
			for(int i=0;i<x;i++)
				if(a[cnt1-i])s-=((1ll<<(x-i))-1)*2,s+=(1ll<<(x-i-1));
			printf("%lld\n",C==1?s:solve(s)-1);
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}

---

## 作者：nosta (赞：0)

臭名昭著的巧合：[CF750G](https://www.luogu.org/problemnew/show/CF750G)

题意：在无限深度的一颗线段树中询问编号和为S的简单路径条数。

[题解传送门](https://kelin.blog.luogu.org/solution-cf750g)

这道题相当于在原来基础上多了询问两点间简单路径的编号的的问题。

直觉告诉我们只需要求出两点在线段树上的lca，然后套用上个问题中所推得的式子即可。而线段树上两点的lca的二进制表示正好是两点的二进制表示的lcp，这玩意儿瞎写即可。

参考代码

```cpp
#include <bits/stdc++.h>
#define LL long long 
using namespace std;
const int N=52;

inline LL calcS(LL a,LL b) {
	LL lca=a,tmp=b,sum=0;
	int la=log2(a),lb=log2(b);
	for(int i=la; i<lb; ++i) tmp>>=1;
	for(int i=lb; i<la; ++i) lca>>=1;
	while(tmp!=lca) tmp>>=1,lca>>=1;
	int LLCA=log2(lca);
	if(a==lca&&b==lca) return lca;
	if(a==lca||b==lca) {
		if(b==lca) a^=b^=a^=b,la^=lb^=la^=lb;
		sum=lca*((1LL<<(lb-LLCA+1))-1);
		for(int i=1; b>lca; ++i,b>>=1) sum+=(b&1)*((1LL<<i)-1);
	} else {
		if((a>>(la-LLCA-1))&1) a^=b^=a^=b,la^=lb^=la^=lb;
		sum=lca*((1LL<<(la-LLCA+1))+(1LL<<(lb-LLCA+1))-3)+(1LL<<(lb-LLCA))-1;
		lca=lca<<1|1;
		for(int i=1; a>lca; ++i,a>>=1) sum+=(a&1)*((1LL<<i)-1);
		for(int i=1; b>lca; ++i,b>>=1) sum+=(b&1)*((1LL<<i)-1);
	}
	return sum;
}
LL P[N]={1},f[N][N*2][2];
inline LL calcP(LL S,int d) {
	LL ans=0;
	int L=min((int)log2(S+1),d);
	for(int h=1; h<=L; ++h) {
		LL x=S/(P[h]-1);
		if(h+(int)log2(x)>d) continue;
		x=S%(P[h]-1);
		for(int i=h; i; --i) if(x>=P[i]-1) x-=P[i]-1;
		ans+=(!x);
	}
	for(int h0=1; h0<L; ++h0) 
	for(int h1=1; S+1-P[h1]>=P[h0+1]+P[h1+1]-3; ++h1) {
		LL x=(S+1-P[h1])/(P[h0+1]+P[h1+1]-3);
		LL r=(S+1-P[h1])%(P[h0+1]+P[h1+1]-3);
		if(max(h0,h1)+1+(int)log2(x)>d) continue;
		if(!r) {ans++; continue;}
		if(h0==1&&h1==1) {ans+=(S==x*5+1); continue;}
		for(int n=1; n<=h0+h1; ++n) {
			LL C=r+n,L=log2(C);
			if(C&1) continue;
			memset(f[0],0,sizeof f[0]);
			f[0][0][0]=1;
			for(int i=1; i<=L; ++i) {
				int d=(C>>i)&1;
				memset(f[i],0,sizeof f[i]);
				for(int j=0; j<=i+i-2&&j<=n; ++j) 
				for(int k=0; k<2; ++k) if(f[i-1][j][k]) 
					for(int x=0; x<2; ++x) if(!x||i<h0) 
					for(int y=0; y<2; ++y) if(!y||i<h1) 
						if(((k+x+y)&1)==d) f[i][j+x+y][(k+x+y)>>1]+=f[i-1][j][k];
			}
			ans+=f[L][n][0];
		}
	}
	return ans;
}

int main() {
	int T;
	scanf("%d",&T);
	for(int i=1; i<N; ++i) P[i]=P[i-1]<<1;
	for(LL c,a,b,d; T--; ) {
		scanf("%lld%lld%lld%lld",&d,&a,&b,&c);
		if(c==1) printf("%lld\n",calcS(a,b));
		else printf("%lld\n",calcP(calcS(a,b),d)-1);
	}
	return 0;
}
```





---


# [SDOI2019] 世界地图

## 题目描述

在遥远的艾莉芬特星球上，有着繁荣的艾莉芬特文明。和地球人一样，艾莉芬特人使用经纬度来标记星球上的每个位置。他们把艾莉芬特星球从北到南划分为$n$个纬度，从西到东划分为$m$个经度。在每条经线和纬线相交的地方都有一个国家，他们用$(i,j)$来表示纬度为$i$，经度为$j$的国家，显然一共有$n\times  m$个国家。

艾莉芬特人在任意两个经度或者纬度相邻的国家之间都修建了一条双向道路。

考虑经度相邻的情况：对于任意一个国家$(i,j)(1\leq i\leq n,1\leq j\leq m)$，它和国家$(i,j+1)$之间都有一条道路，特别地当$j=m$时，$(i,m)$和$(i,1)$之间也有一条道路。

考虑纬度相邻的情况：对于任意一个国家$(i,j)(1\leq i<n,1\leq j\leq m)$，它和国家$(i+1,j)$之间都有一条道路。注意：南北极并不相邻。

艾莉芬特星球并不和平，部分国家卷入了世界大战之中。在接下来$q$个世纪的第$i$个世纪里，经度在$[l_i,r_i]$之间的所有国家都卷入了该世纪发生的世界大战中。当世界大战发生时，被卷入战争的国家都很危险。如果一个国家未被卷入战争，那么它就是一个和平的国家；如果一条道路两端点都是和平的国家，那么它就是一条和平的道路。处于安全考虑，艾莉芬特联合政府会选择只开放一些和平的道路，使得任意两个和平的国家在战争期间都能仅通过这些开放的和平的道路直接或间接连通。

对于任意一条道路，将它保留下来所需的安保代价都不尽相同。请写一个程序，帮助联合政府找到安保代价之和最少的方案。

注意：一个世纪结束后，该世纪的世界大战将会结束，下一场战争的参战国与当前战争的参战国之间没有任何联系。

## 说明/提示

## 样例解释：

![qwq](https://cdn.luogu.com.cn/upload/pic/58230.png )

## 数据范围：

对于$100\%$的数据，$1<l_i\leq r_i<m,1\leq SA,SB,SC\leq 10^9$。

子任务 $1$:（$10$ 分）$n=m=lim=q=50$；

子任务 $2$:（$20$ 分）$n=100,m=10000,lim=5,q=10000$；

子任务 $3$:（$10$ 分）$n=1,m=10000,lim=10^9,q=300000$；

子任务 $4$:（$20$ 分）$n=2,m=10000,lim=10^9,q=300000$；

子任务 $4$:（$40$ 分）$n=100,m=10000,lim=10^9,q=10000$；

## 样例 #1

### 输入

```
2 4 1 2 3 5
3
2 2
2 3
3 3```

### 输出

```
9
5
13```

# 题解

## 作者：Mys_C_K (赞：17)

这题在场上只有我一个人过感觉非常蒙蔽这题不是送分吗（逃）

听Claris说原本这个题打算是桥计数然后要类似虚仙人掌（瑟瑟发抖）

总之考虑每次都是合并一个前缀和后缀，考虑类似于LCT维护MST的做法，每次加入一条边，形成环了的话就把环上最大边删掉。然后注意你每次只会加形如$(m,i)-(1,i)$（方便起见列在前）的边，因此以前缀为例，只有那些是第一列点某两点在这个前缀求出的MST上的环的权值最大边可能被删掉，反过来就是其余一定会被加入。因此只把这些可能被删掉的边和新加的$(m,i)-(1,i)$边拿出来做kruskal即可。

然后观察到看两两点MST环上最大边有哪些（也就是看两两点何时联通）本质上就是对着kruskal重构树求虚树，把虚树对应的点（边）拿出来即可。

至于怎么维护，以前缀$i$为例，你只需要维护所有形如$(1,j),(i,j)$这些点两两MST环上最大边，然后就可以加入第i+1列的点了。

由于场上比较蠢，所以我真的把kruskal重构树写了出来然后写了个LCA然后写了一个类似虚树的东西求那些边（摔）

实现良好可以做到$O((nm+nq)\alpha(n))$（排序用松式基排，虚树稍微写好一点直接用并查集代替），但是场上太懒了所以直接写了$O((nm+nq)\log n)$
场后重新写的：
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define Rep(i,v) rep(i,0,(int)v.size()-1)
#define lint long long
#define ull unsigned lint
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define gc getchar()
#define debug(x) cerr<<#x<<"="<<x
#define sp <<" "
#define ln <<endl
using namespace std;
inline int inn()
{
	int x,ch;while((ch=gc)<'0'||ch>'9');
	x=ch^'0';while((ch=gc)>='0'&&ch<='9')
		x=(x<<1)+(x<<3)+(ch^'0');return x;
}
const int N=110,M=10010,T=1100000,LOG=12;
namespace RND_space{
	unsigned int SA,SB,SC,t;int lim;inline int _init() { return scanf("%u%u%u%d",&SA,&SB,&SC,&lim),0; }
	inline int rnd() { return SA^=SA<<16,SA^=SA>>5,SA^=SA<<1,t=SA,SA=SB,SB=SC,SC^=t^SA,int(SC%lim+1); }
}using RND_space::rnd;
int r[M][N],d[M][N],P[M][N];lint ps[M],ss[M];
struct E{
	int w,x,y;
	E(int _w=0,int _x=0,int _y=0) { w=_w,x=_x,y=_y; }
	inline bool operator<(const E &e)const { return w<e.w; }
};vector<E> pre[M],suf[M],cur;vector<int> g[T];
int up[T][LOG],Log[N<<2],in[T],fa[T],dpt[T],dfc,val[T],lst[N<<1];
inline int _init_Log(int n) { rep(i,2,n) Log[i]=Log[i>>1]+1;return 0; }
int dfs(int x)
{
	in[x]=++dfc,memset(up[x]+1,0,sizeof(int)*(LOG-1));int y;
	for(int i=1;i<=Log[dpt[x]];i++) up[x][i]=up[up[x][i-1]][i-1];
	Rep(i,g[x]) y=g[x][i],dpt[y]=dpt[x]+1,up[y][0]=x,dfs(y);return 0;
}
inline int incmp(int x,int y) { return in[x]<in[y]; }
inline int getLCA(int x,int y)
{
	if(dpt[x]<dpt[y]) swap(x,y);
	for(int i=Log[dpt[x]];i>=0;i--)
		if(dpt[up[x][i]]>=dpt[y]) x=up[x][i];
	if(x==y) return x;
	for(int i=Log[dpt[x]];i>=0;i--)
		if(up[x][i]^up[y][i]) x=up[x][i],y=up[y][i];
	return up[x][0];
}
inline int clrfa(vector<E> &v)
{
	int mx=0,x,y;
	Rep(i,v)
		x=v[i].x,fa[x]=x,vector<int>().swap(g[x]),mx=max(mx,x),
		y=v[i].y,fa[y]=y,vector<int>().swap(g[y]),mx=max(mx,y);
	return mx;
}
inline int findf(int x) { return x==fa[x]?x:fa[x]=findf(fa[x]); }
inline lint ins(int n,int *P,int *X,int *Y,int *d,int *r,vector<E> &ans)
{
	lint res=0;Rep(i,cur) res-=cur[i].w;
	rep(i,1,n) cur.pb(E(r[i],X[i],Y[i]));
	rep(i,1,n-1) cur.pb(E(d[i],Y[i],Y[i+1]));
	sort(cur.begin(),cur.end());int nc=clrfa(cur);
	Rep(i,cur)
	{
		int x=findf(cur[i].x),y=findf(cur[i].y),w=cur[i].w;if(x==y) continue;
		fa[x]=fa[y]=++nc,fa[nc]=nc,vector<int>().swap(g[nc]),g[nc].pb(x),g[nc].pb(y),val[nc]=w,res+=w;
	}
	dfc=0,up[nc][0]=0,dpt[nc]=0,dfs(nc);
	int lc=0;rep(i,1,n) lst[++lc]=P[i];
	sort(lst+1,lst+lc+1,incmp),ans.clear();
	rep(i,1,lc-1) ans.pb(E(getLCA(lst[i],lst[i+1])[val],lst[i],lst[i+1]));
	
	rep(i,1,n) lst[++lc]=Y[i];
	sort(lst+1,lst+lc+1,incmp),vector<E>().swap(cur);
	rep(i,1,lc-1) cur.pb(E(getLCA(lst[i],lst[i+1])[val],lst[i],lst[i+1]));
	return res;
}
inline lint solve(vector<E> &pre,vector<E> &suf,int n,int m)
{
	cur=pre;Rep(i,suf) cur.pb(suf[i]);
	lint res=0;Rep(i,cur) res-=cur[i].w;
	rep(i,1,n) cur.pb(E(r[m][i],P[m][i],P[1][i]));
	clrfa(cur),sort(cur.begin(),cur.end());
	Rep(i,cur)
	{
		int x=findf(cur[i].x),y=findf(cur[i].y);
		if(x^y) fa[x]=y,res+=cur[i].w;
	}
	return res;
}
int main()
{
	int n=inn(),m=inn(),cnt=0;
	RND_space::_init(),_init_Log(n<<2);
	rep(i,1,n) rep(j,1,m) r[j][i]=rnd();
	rep(i,1,n-1) rep(j,1,m) d[j][i]=rnd();
	rep(i,1,m) rep(j,1,n) P[i][j]=++cnt;
	
	rep(i,1,n-1) cur.pb(E(d[1][i],P[1][i],P[1][i+1]));
	Rep(i,cur) ps[1]+=cur[i].w;pre[1]=cur;
	rep(i,2,m) ps[i]=ps[i-1]+ins(n,P[1],P[i-1],P[i],d[i],r[i-1],pre[i]);
	
	cur.clear();rep(i,1,n-1) cur.pb(E(d[m][i],P[m][i],P[m][i+1]));
	Rep(i,cur) ss[m]+=cur[i].w;suf[m]=cur;
	for(int i=m-1;i;i--) ss[i]=ss[i+1]+ins(n,P[m],P[i+1],P[i],d[i],r[i],suf[i]);
	for(int q=inn(),l,r;q;q--)
		l=inn()-1,r=inn()+1,printf("%lld\n",ps[l]+ss[r]+solve(pre[l],suf[r],n,m));
	return 0;
}
```

---

## 作者：木xx木大 (赞：11)

[P5360 [SDOI2019]世界地图](https://www.luogu.com.cn/problem/P5360)

**# 心路历程**

 一个 naive 的想法是对原图求一个前缀最小生成树 $pre_i$ 和一个后缀最小生成树 $suf_i$，然后合并它们。这并不难想到，关键在于怎么实现合并操作。

我最初的想法是将 $n=1$ 的解法进行推广，用 LCT 维护最小生成树，从左到右做一遍，再从右到左做一遍，只把求得的最小生成树的值存下来，然后通过 $\min\{(i,m)- (i,1)\}$ 的边把两部分合并起来。后来在同校巨佬  $\textcolor{black}{Y}\textcolor{red}{outh518} $ 的提醒下发现这样做是假的，因为把连接两端的边加入可能会替换掉原来最小生成树上的边。所以我们需要保存 $pre_i$ 和 $suf_i$ 的树形。

那……可持久化 LCT ？但据我所知 LCT 好像不能可持久化。于是我打开了题解。

**# 正解**

考虑 LCT 维护最小生成树的过程，设 $[1,i-1]$ 的 MST 上 $u,v$ 两点路径上的最大边为 $l$ ，当加入一条边 $(u,v,w)$ 时，当且仅当 $w<l$ 时，我们会断掉 $l$ ，连上 $(u,v,w )$ 。合并 $[1,i-1]$ 和 $i$ 时，只有 $i-1$ 这一列的点所涉及到的路径上的边可能会受到影响；合并 $pre $ 和 $suf$ 时，只有最左端一列的点所涉及到的路径上的边可能会受到影响。我们把这两列的点称为**关键点**。

考虑如何得到 $pre$（$suf$ 同理）。我们改变 $pre$ 的定义：设 $pre_i$ 表示经度在 $[1,i]$ 的点的 MST 中，之后可能被删的边集。则 $[1,i-1]$ 的 MST 上不在 $pre$ 中的边一定也在 $[1,i]$ 的 MST 上。如果 $pre$ 涉及的点都为关键点，我们只要把 $pre_{i−1}$ 和新加入的边一起拿出来跑 kruscal，所得结果加上肯定不会被删的边，就是 $[1,i]$ 的 MST。 这样做的话，单次合并的复杂度就在 $O(n\log n)$ 级别了。

但事实上 $pre$ 涉及的点并不都为关键点。考虑 $pre$ 的定义，**之后可能被删的边集**，这些边一定都在关键点之间的路径上。那么我们对关键点建 MST 的虚树，边权为原来最小生成树之间两点边权的最大值 。我们再次改变 $pre$ 的定义，$pre$ 存虚树上之后可能被删的边集，这样 $pre$ 涉及的点就都为关键点了。

感觉这题不是很难想，但很难实现，不过虚树的思想还是很巧妙的。

代码很大程度上参考了题解，但是加了一些注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m,Q;
	const int N=1e4+5,M=105;
	unsigned int SA, SB, SC;
	int lim;
	struct edg{
		int to,nxt,w;
	}e[N<<1];
	int head[N],cnt,is[N],a[N][M],b[N][M],fa[N];
	ll ans;
	inline int getweight() 
	{
		SA ^= SA << 16;
		SA ^= SA >> 5;
		SA ^= SA << 1;
		ll t = SA;
		SA = SB;
		SB = SC;
		SC ^= t ^ SA;
		return SC % lim + 1;
	}
	struct EDG{
		int u,v,w;
	};
	bool operator< (EDG x,EDG y){return x.w<y.w;}
	vector<EDG> g;
	struct MST{
		vector<EDG> E;
		int tot;ll sum;
		MST(){};
		MST(int *a)
		{
			tot=n,sum=0;
			for(int i=1;i<n;i++)
				E.push_back({i,i+1,a[i]});
		}
		ll query()
		{
			ll ans=sum;
			for(auto v:E)ans+=v.w;
			return ans;
		}
	}pre[N],suf[N];
	int find(int x)
	{
		return x==fa[x]? x:fa[x]=find(fa[x]);
	}
	void add(int u,int v,int w)
	{
		cnt++;
		e[cnt].to=v;
		e[cnt].nxt=head[u];
		head[u]=cnt;
		e[cnt].w=w;
	}
	void link(EDG x){add(x.u,x.v,x.w),add(x.v,x.u,x.w),ans+=x.w;} 
	bool dfs1(int u,int f)
	{
		int s=0;
		for(int i=head[u];i;i=e[i].nxt)
			if(e[i].to!=f)s+=dfs1(e[i].to,u);
		is[u]|=(s>=2);
		return s+is[u];
	}
	void dfs2(int u,int f,int lst,int val)
	{
		if(is[u])
		{
			if(lst)g.push_back({is[u],lst,val});//把虚树上的边存下来
			lst=is[u],ans-=val,val=0;
		}
		for(int i=head[u];i;i=e[i].nxt)
			if(e[i].to!=f)dfs2(e[i].to,u,lst,max(val,e[i].w));
	}
	MST merge(MST a,MST b,int *c)
	{
		int tot=a.tot+b.tot;
		g.clear();
		for(auto v:a.E)g.push_back(v);
		for(auto v:b.E)g.push_back({a.tot+v.u,a.tot+v.v,v.w});
		for(int i=1;i<=n;i++)g.push_back({a.tot-n+i,a.tot+i,c[i]});
		sort(g.begin(),g.end());
		for(int i=1;i<=tot;i++)
			fa[i]=i,is[i]=(i>tot-n||i<=n),head[i]=0;//把关键点标起来
		cnt=ans=0; 
		for(auto v:g)
			if(find(v.u)!=find(v.v))link(v),fa[find(v.u)]=find(v.v);
		dfs1(1,0);cnt=0;
		for(int i=1;i<=tot;i++)
			if(is[i])is[i]=++cnt;//给点重标号
		g.clear();
		dfs2(1,0,0,0);
		MST res;res.tot=cnt,res.sum=a.sum+b.sum+ans,res.E=g;
		return res; 
	}
	void work()
	{
		scanf("%d%d%u%u%u%d",&n,&m,&SA,&SB,&SC,&lim);
		int i,j,l,r;
		for(i=1;i<=n;i++)
			for(j=1;j<=m;j++)
				a[j][i]=getweight();
		for(i=1;i<n;i++)
			for(j=1;j<=m;j++)
				b[j][i]=getweight();
		pre[1]=MST(b[1]),suf[m]=MST(b[m]);
		for(int i=2;i<m;i++)
			pre[i]=merge(pre[i-1],MST(b[i]),a[i-1]);
		for(int i=m-1;i>1;i--)
			suf[i]=merge(MST(b[i]),suf[i+1],a[i]);
		scanf("%d",&Q);
		while(Q--)
		{
			scanf("%d%d",&l,&r);
			printf("%lld\n",merge(suf[r+1],pre[l-1],a[m]).query());
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：yzhang (赞：8)

### [原题传送门](https://www.luogu.org/problemnew/show/P5360)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10889109.html) 

每次查询的实际就是将地图的一个前缀和一个后缀合并后的图的最小生成树边权和

我们要预处理每个前缀和后缀的最小生成树

实际求前缀和（后缀和）的过程珂以理解为上一个前缀和这一列的最小生成树进行合并，实际最后前缀和后缀合并也是这样

如果暴力进行合并的话，每次边数是nm级别的，明显会TLE和MLE

我们考虑一下，实际每次合并主要和最左、最右两列（称这些点为关键点）有关，每次合并，原来最小生树中有可能会有一些边要删掉使得合并后是最小生成树。感性理解一下，珂能删掉的边一定在两个关键点在原来最小生成树之间的链上，所以我们对关键点建最小生成树的虚树，边权为原来最小生成树之间两点边权的最大值，其他的边权累加成和即可（因为其他的边不珂能删掉），这时两个最小生成树的边数的数量级都是n*常数的，所以直接暴力kruscal。

这个算法的复杂度大概为$O(n*(m+q)\log n)$

```cpp
#include <bits/stdc++.h>
#define N 10005 
#define ll long long
using namespace std;
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register ll x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int Max(register int a,register int b)
{
    return a>b?a:b;
}
int n,m,q,foo[N][105],bar[N][105];
unsigned int SA,SB,SC;
int lim;
inline int rng()
{
    SA^=SA<<16;SA^=SA>>5;SA^=SA<<1;
    unsigned int t=SA;SA=SB;SB=SC;SC^=t^SA;
    return SC%lim+1;
}
struct edge{
    int u,v,w;
    bool operator < (const edge &b)const{return w<b.w;}
};
struct MST{
    int tot;
    ll sum;
    vector <edge> E;
    MST(){}
    MST(register int *c)
    {
        tot=n,sum=0;
        for(register int i=1;i<n;++i)
            E.push_back((edge){i,i+1,c[i]});
    }
    inline ll query()
    {
        ll res=sum;
        for(register int i=0;i<E.size();++i)
            res+=E[i].w;
        return res;
    }
}pre[N],suf[N];
int tot,fa[N],mrk[N],to[N],nxt[N],ww[N],head[N],cnt;
vector <edge> E;
ll ans;
inline int find(register int x)
{
    return x==fa[x]?x:fa[x]=find(fa[x]);
}
inline void link(register edge x)
{
    to[++cnt]=x.v,nxt[cnt]=head[x.u],ww[cnt]=x.w,head[x.u]=cnt;
    to[++cnt]=x.u,nxt[cnt]=head[x.v],ww[cnt]=x.w,head[x.v]=cnt;
    ans+=x.w;
}
inline bool dfs1(register int u,register int f)
{
    int s=0;
    for(register int e=head[u];e;e=nxt[e])
        if(to[e]!=f)
            s+=dfs1(to[e],u);
    mrk[u]|=(s>=2);
    s+=mrk[u];
    return s;	
}
inline void dfs2(register int u,register int f,register int lst,register int val)
{
    if(mrk[u])
    {
        if(lst)
            E.push_back((edge){mrk[u],lst,val});
        lst=mrk[u];
        ans-=val;
        val=0;
    }
    for(register int e=head[u];e;e=nxt[e])
        if(to[e]!=f)
            dfs2(to[e],u,lst,Max(val,ww[e]));
}
inline MST merge(register MST a,register MST b,register int *c)
{
    tot=a.tot+b.tot;
    E.clear();
    for(register int i=0;i<a.E.size();++i)
        E.push_back(a.E[i]);
    for(register int i=0;i<b.E.size();++i)
        E.push_back((edge){b.E[i].u+a.tot,b.E[i].v+a.tot,b.E[i].w});
    for(register int i=1;i<=n;++i)
        E.push_back((edge){a.tot-n+i,a.tot+i,c[i]});
    sort(E.begin(),E.end());
    for(register int i=1;i<=tot;++i)
        fa[i]=i,mrk[i]=(i<=n||i>tot-n),head[i]=0;
    cnt=ans=0;
    for(register int i=0;i<E.size();++i)
    {
        edge x=E[i];
        if(find(x.u)!=find(x.v))
            link(x),fa[find(x.u)]=find(x.v);
    }
    dfs1(1,0);
    cnt=0;
    for(register int i=1;i<=tot;++i)
        if(mrk[i])
            mrk[i]=++cnt;
    E.clear();
    dfs2(1,0,0,0);
    MST res;
    res.tot=cnt;
    res.sum=a.sum+b.sum+ans;
    res.E=E;
    return res;
}
int main()
{
    n=read(),m=read();
    scanf("%u%u%u",&SA,&SB,&SC);
    lim=read();
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=m;++j)
            foo[j][i]=rng();
    for(register int i=1;i<n;++i)
        for(register int j=1;j<=m;++j)
            bar[j][i]=rng();
    pre[1]=MST(bar[1]),suf[m]=MST(bar[m]);
    for(register int i=2;i<m;++i)
        pre[i]=merge(pre[i-1],MST(bar[i]),foo[i-1]);
    for(register int i=m-1;i>1;--i)
        suf[i]=merge(MST(bar[i]),suf[i+1],foo[i]);
    q=read();
    while(q--)
    {
        int l=read(),r=read();
        write(merge(suf[r+1],pre[l-1],foo[m]).query()),puts("");
    }
    return 0;
}
```

---

## 作者：Lofty (赞：6)

### 题目大意：

给出一个有 $n$ 行 $m$ 列的网格图，第一列和最后一列是相连的，每条边都有对应的权值。

有 $q$ 组询问，每次会给出 $l_i$ 和 $r_i$，表示第 $l_i$ 列至第 $r_i$ 列上所有的点不能经过，求使除此之外所有点连通或间接连通的最小总权值。

对于 $100\%$ 的数据，$n \le 100$，$m \le 10^4$，$n \times q \le 10^6$。

### 思路：

显然每组询问都是在求一棵只经过需求的点的最小生成树，但是如果就这样直接求解，时间复杂度会来到 $O(qnm \log(nm))$，一看就非常不可做，想到 LCT 动态维护最小生成树。但如果直接维护，显然也是会喜得 TLE。看到 $n$ 的范围和网格图，尝试考虑对于每一列的最小生成树做前缀和与后缀和，最后询问时再通过第一列和最后一列相连的边来合并。但记下前缀最小生成树的整棵树，不 MLE 也会 TLE。此时我们还要深究网格图的特性。可以发现，对于新合并的两棵最小生成树，新的最小生成树只可能对于左边 MST 的最右一列与右边的 MST 的最左一列两点之间的路径长产生影响。对于其他的树边，完全不会有任何改变。

嗯？只跟关键点有关系，无法存下整棵树，这跟虚树的应用场景简直完美匹配！于是可以把最左边和最右边的两列作为关键点，做虚树前缀。那虚树的边权应该怎么定呢？考虑 LCT 如何动态维护最小生成树。对于新加入的边，尝试替换这条边两点间路径上权值最大的一条边。合并最小生成树时也是这样，所以只要记下关键点之间的路径的最大边，其它边累加即可。然而这里只需要边权的信息，可以用 vector 直接存。

对于每个虚树，最多只有 $4n-1$ 个点，也就是最多只有 $4n-2$ 条边，两棵树就是 $8n-4$ 条边，还有相连的 $n$ 条边，共 $9n-4$ 条边，直接跑 kruskal，然后再以最左右两列建虚树即可。这里我建议直接跑两次 dfs 建虚树，因为关键点数和总点数非常接近，重建 LCA 的大常数和 dfs 大差不差，不如写 dfs 来的方便。

最终时间复杂度为 $O(n(m+q)\log n)$。

### 代码：

也都和别人同样思路的差不多了，不过我放出的代码都会加注释。

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
#define TP template<typename T>
#define TP_ template<typename T,typename ... T_>
TP void read(T &x)
{
	x=0;int f=0;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())ch=='-'&&(f=1);
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x*10)+(ch^48);
	f&&(x=-x);
}
TP_ void read(T &x,T_&...y){read(x);read(y...);}
TP void write(T x){x<0&&(putchar('-'),x=-x);static int sta[35];int top=0;do{sta[++top]=x%10,x/=10;}while(x);while(top)putchar(sta[top--]^48);}
TP void writeln(const T x){write(x);puts("");}
TP void writesp(const T x){write(x);putchar(32);}
TP_ void writeln(const T x,T_ ...y){writesp(x);writeln(y...);}
using LL=long long;
constexpr int N=1e2+5;
constexpr int M=1e4+5;
int n,m;
int row[M][N],col[M][N];
struct edge
{
	int x,y,c;
	bool operator <(const edge &a)
	{
		return c<a.c;
	}
};
struct MST
{
	vector<edge>a;//该 MST 中可能被替换的边
	int alen;
	LL sum;//边权和
	MST(){alen=0,sum=0;a.clear();}
	MST(const int *c)
	{
		sum=0;
		for(int i=1;i<n;i++)
			a.push_back({i,i+1,c[i]});
		sum=0;
		alen=n;
	}
	LL query()
	{
		LL ans=0;
		for(auto i:a)
			ans+=i.c;
		return ans+sum;//这棵树的总边权
	}
}s[M],ps[M];
struct v_edge{int y,c,pre;}a[M];int alen,last[M];
void ins(edge &q)
{
	a[++alen]=v_edge{q.y,q.c,last[q.x]};last[q.x]=alen;
	a[++alen]=v_edge{q.x,q.c,last[q.y]};last[q.y]=alen;
}
int fa[M];
int findfa(int x)
{
	return fa[x]=fa[x]==x?x:findfa(fa[x]);
}
int key[M];
LL ans;
vector<edge>g;
bool dfs1(int x,int fa)
{
	int sum=0;
	for(int k=last[x];k;k=a[k].pre)
	{
		int y=a[k].y;
		if(y==fa)continue;
		sum+=dfs1(y,x);
	}
	if(sum>=2)//最近公共祖先
		key[x]=1;
	sum+=key[x];
	return sum;
}
void dfs2(int x,int fa,int val,int lst)
{
	if(key[x])
	{
		if(lst)
			g.push_back({key[x],lst,val});//两个关键点之间的边
		lst=key[x];
		ans-=val;
		val=0;
	}
	for(int k=last[x];k;k=a[k].pre)
	{
		int y=a[k].y;
		if(y==fa)continue;
		dfs2(y,x,max(val,a[k].c),lst);
	}
}
MST merge(const MST &a,const MST &b,const int *c)//右向左合并，是有顺序的！（我因此挂了一次）
{
	int len=a.alen+b.alen;
	g.clear();
	for(edge i:a.a)//左树的边
		g.push_back(i);
	for(edge i:b.a)//右树的边
		g.push_back({i.x+a.alen,i.y+a.alen,i.c});//因为已经重编号了，所以才可以这样方便的写
	for(int i=1;i<=n;i++)//中间相连的边
		g.push_back({a.alen-n+i,a.alen+i,c[i]});
	sort(g.begin(),g.end());
	alen=1;//重置链式前向星，不然会溢出
	for(int i=1;i<=len;i++)
		fa[i]=i,last[i]=0,key[i]=(i<=n||i>len-n);//最左和最右的点
	ans=a.sum+b.sum;//新的 MST 的边权和
	for(edge i:g)
	{
		int tx=findfa(i.x),ty=findfa(i.y);
		if(tx==ty)continue;
		ans+=i.c,fa[tx]=ty;
		ins(i);
	}
	dfs1(1,0);
	g.clear();
	int cnt=0;
	for(int i=1;i<=len;i++)
		if(key[i])
			key[i]=++cnt;//重编号
	dfs2(1,0,0,0);
	MST res;
	res.alen=cnt;
	res.sum=ans;
	res.a=g;
	return res;
}
unsigned int SA,SB,SC;
int lim;
int getweight()
{
	SA^=SA<<16;
	SA^=SA>>5;
	SA^=SA<<1;
	unsigned int t=SA;
	SA=SB;
	SB=SC;
	SC^=t^SA;
	return SC%lim+1;
}
void gen()
{
	read(n,m,SA,SB,SC,lim);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			int w=getweight();
			row[j][i]=w;
		}
	for(int i=1;i<n;i++)
		for(int j=1;j<=m;j++)
		{
			int w=getweight();
			col[j][i]=w;
		}
}
int main()
{
	gen();
	s[1]=MST(col[1]);
	ps[m]=MST(col[m]);
	for(int i=2;i<m;i++)
		s[i]=merge(s[i-1],MST(col[i]),row[i-1]);
	for(int i=m-1;i>1;i--)//这里逆着存后缀方便询问合并
		ps[i]=merge(MST(col[i]),ps[i+1],row[i]);
	int q;read(q);
	while(q--)
	{
		int l,r;read(l,r);
		writeln(merge(ps[r+1],s[l-1],row[m]).query());
	}
	return 0;
}
```

---

## 作者：liuzhangfeiabc (赞：4)

题目大意：给定网格图，左边界和右边界相连，每次询问挖掉一个横坐标区间之后其余部分的mst。

先%一下现场切掉这题的ckw队长。

每次询问可以看作把一个前缀和一个后缀拼起来做mst，因此我们可以先预处理出每个前缀和后缀的一些信息，再想办法把两棵mst拼成一棵。

最简单的想法就是用lct维护动态mst。假设我们已经得到了询问的前缀和后缀的mst，现在在中间加一堆边，如果之前没连通就直接连上，否则踢掉环上边权最大的边。

只可惜每次询问拎出一个前缀和后缀的mst可能需要可持久化lct，我也不知道有没有这个东西但我可以肯定的是没人会。

或者用树状数组套lct，每次把log个区间的lct拼起来，刚刚想了想这确实可以，但是……2个log+巨大的常数，不t才怪好吧。

那怎么办呢？我们考查一下用lct维护动态mst的过程。

把左右两棵mst拼起来，这个过程中哪些边可能被踢掉呢？

由于每次加边都只涉及最边缘的一排点，最终被踢掉的边当然也只会是原mst上连接最边缘一排点的边。

更直观的说法是：建出kruskal重构树（叶子节点是原先的点，每次加入一条边连接两个连通块时就新建一个点作为这两个连通块的father），则我们只需要考虑所有边缘的点的虚树上涉及到的边。

也就是对所有的关键点两两求一下lca(lca一定是新建节点，别忘了每个新建节点代表一条边)，所有的lca代表的边就是我们要找的关键边。

如果我们已经知道每个前缀和后缀的这些关键边都是哪些，就可以每次合并时，拎出两侧的关键边以及中间的边来跑一次kruskal。

现在的问题就是：每个前缀和后缀的关键边怎么维护？

以前缀为例，我们要对每个前缀都维护出最左一排点的关键边。

从左到右扫过去，每次加一列的过程其实本质上和刚才的查询答案是一样的，还是合并左右两段的mst。

因此我们也要顺便维护出最右侧一排点的关键边。

左右两排点共2n个，我们要一起维护这个点集的关键边，一共有2n-1条。

每次加入一排点，把之前的关键边拿出来，再加上新加入的2n-1条边一起跑kruskal，然后再提取出新的关键边。

提取新的关键边的过程当然可以显式地建出kruskal重构树，当然更简单的办法是直接在并查集合并时就维护出来，调整一下merge时的合并顺序即可。

总复杂度O(nmlogn)，这个log来自对边进行排序，据说实现得好可以把log去掉。

以及为什么泥萌的代码都辣么短啊……献上我5k的长代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
inline li read(){
	li x = 0,y = 0,c = gc;
	while(!isdigit(c)) y = c,c = gc;
	while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
	return y == '-' ? -x : x;
}
inline void print(li q){
	if(q < 0) pc('-'),q = -q;
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
int n,m,mo,q;
unsigned int sa,sb,sc;
int nxt(){
    sa ^= sa << 16;
    sa ^= sa >> 5;
    sa ^= sa << 1;
    unsigned int t = sa;
    sa = sb;
    sb = sc;
    sc ^= t ^ sa;
    return sc % mo + 1;
}
struct edge{
	int u,v;
	li w;
	edge(int _u = 0,int _v = 0,li _w = 0){u = _u;v = _v;w = _w;}
}e1[10010][110],e2[10010][110],e3[10010][110],e4[10010][110],nw[1010],tmp[1010];
inline bool operator < (edge q,edge w){
	return q.w < w.w;
}
int f[1000010],bh[110][10010],cnt;
inline int getf(int q){
	return f[q] == q ? q : f[q] = getf(f[q]);
}
int tp1,tp2;
inline void mg(int u,int v){
	if(getf(u) % m == tp1) f[getf(v)] = getf(u);
	else if(getf(v) % m == tp1) f[getf(u)] = getf(v);
	else if(getf(u) % m == tp2) f[getf(v)] = getf(u);
	else f[getf(u)] = getf(v);
}
li an1[10010],an2[10010],an3[10010],an4[10010];
int main(){
	int i,j,u,v,w,tt1,tt2;
	n = read();m = read();sa = read();sb = read();sc = read();mo = read();
	for(i = 1;i <= n;++i) for(j = 1;j <= m;++j) bh[i][j] = (i - 1) * m + j;
	for(i = 1;i <= n;++i) for(j = 1;j <= m;++j){
		w = nxt();
		if(j < m) e1[j][i] = edge(bh[i][j],bh[i][j + 1],w);
		else e1[j][i] = edge(bh[i][j],bh[i][1],w);
	}
	for(i = 1;i < n;++i) for(j = 1;j <= m;++j){
		w = nxt();
		e2[j][i] = edge(bh[i][j],bh[i + 1][j],w);
	}
	for(i = 1;i <= m;++i) sort(e1[i] + 1,e1[i] + n + 1),sort(e2[i] + 1,e2[i] + n);
	
	for(i = 1;i < n;++i) e3[1][i] = e2[1][i];
	cnt = tt1 = tt2 = 0;tp1 = 1;tp2 = 2;
	for(i = 1;i <= n;++i) f[bh[i][1]] = bh[i][1],f[bh[i][2]] = bh[i][2];
	for(i = 1;i < n;++i) nw[++cnt] = e2[1][i];
	for(i = 1;i < n;++i) nw[++cnt] = e2[2][i];
	for(i = 1;i <= n;++i) nw[++cnt] = e1[1][i];
	sort(nw + 1,nw + cnt + 1);
	for(i = 1;i <= cnt;++i) if(getf(nw[i].u) != getf(nw[i].v)){
		tmp[++tt1] = edge(getf(nw[i].u),getf(nw[i].v),nw[i].w);
		if(getf(nw[i].u) % m == 1 && getf(nw[i].v) % m == 1) e3[2][++tt2] = edge(getf(nw[i].u),getf(nw[i].v),nw[i].w);
		else an1[2] += nw[i].w;
		mg(nw[i].u,nw[i].v);
	}
	for(j = 3;j <= m;++j){
		an1[j] = an3[j] = an3[j - 1];
		cnt = tt1 = tt2 = 0;tp1 = 1;tp2 = j;
		for(i = 1;i <= n;++i) f[bh[i][1]] = bh[i][1],f[bh[i][j]] = bh[i][j],f[bh[i][j - 1]] = bh[i][j - 1];
		for(i = 1;i < 2 * n;++i) nw[++cnt] = tmp[i];
		for(i = 1;i < n;++i) nw[++cnt] = e2[j][i];
		for(i = 1;i <= n;++i) nw[++cnt] = e1[j - 1][i];
		sort(nw + 1,nw + cnt + 1);
		for(i = 1;i <= cnt;++i) if(getf(nw[i].u) != getf(nw[i].v)){
			if(getf(nw[i].u) % m != j - 1 && getf(nw[i].v) % m != j - 1) tmp[++tt1] = edge(getf(nw[i].u),getf(nw[i].v),nw[i].w);
			else an3[j] += nw[i].w;
			if(getf(nw[i].u) % m == 1 && getf(nw[i].v) % m == 1) e3[j][++tt2] = edge(getf(nw[i].u),getf(nw[i].v),nw[i].w);
			else an1[j] += nw[i].w;
			mg(nw[i].u,nw[i].v);
		}
	}
	
	for(i = 1;i < n;++i) e4[m][i] = e2[m][i];
	cnt = tt1 = tt2 = 0;tp1 = 0;tp2 = m - 1;
	for(i = 1;i <= n;++i) f[bh[i][m]] = bh[i][m],f[bh[i][m - 1]] = bh[i][m - 1];
	for(i = 1;i < n;++i) nw[++cnt] = e2[m][i];
	for(i = 1;i < n;++i) nw[++cnt] = e2[m - 1][i];
	for(i = 1;i <= n;++i) nw[++cnt] = e1[m - 1][i];
	sort(nw + 1,nw + cnt + 1);
	for(i = 1;i <= cnt;++i) if(getf(nw[i].u) != getf(nw[i].v)){
		tmp[++tt1] = edge(getf(nw[i].u),getf(nw[i].v),nw[i].w);
		if(getf(nw[i].u) % m == 0 && getf(nw[i].v) % m == 0) e4[m - 1][++tt2] = edge(getf(nw[i].u),getf(nw[i].v),nw[i].w);
		else an2[m - 1] += nw[i].w;
		mg(nw[i].u,nw[i].v);
	}
	for(j = m - 2;j;--j){
		an2[j] = an4[j] = an4[j + 1];
		cnt = tt1 = tt2 = 0;tp1 = 0;tp2 = j;
		for(i = 1;i <= n;++i) f[bh[i][m]] = bh[i][m],f[bh[i][j]] = bh[i][j],f[bh[i][j + 1]] = bh[i][j + 1];
		for(i = 1;i < 2 * n;++i) nw[++cnt] = tmp[i];
		for(i = 1;i < n;++i) nw[++cnt] = e2[j][i];
		for(i = 1;i <= n;++i) nw[++cnt] = e1[j][i];
		sort(nw + 1,nw + cnt + 1);
		for(i = 1;i <= cnt;++i) if(getf(nw[i].u) != getf(nw[i].v)){
			if(getf(nw[i].u) % m != j + 1 && getf(nw[i].v) % m != j + 1) tmp[++tt1] = edge(getf(nw[i].u),getf(nw[i].v),nw[i].w);
			else an4[j] += nw[i].w;
			if(getf(nw[i].u) % m == 0 && getf(nw[i].v) % m == 0) e4[j][++tt2] = edge(getf(nw[i].u),getf(nw[i].v),nw[i].w);
			else an2[j] += nw[i].w;
			mg(nw[i].u,nw[i].v);
		}	
	}
	
	q = read();
	for(i = 1;i <= q;++i){
		u = read();v = read();cnt = 0;
		for(j = 1;j <= n;++j) f[bh[j][1]] = bh[j][1],f[bh[j][m]] = bh[j][m];
		for(j = 1;j < n;++j) nw[++cnt] = e3[u - 1][j];
		for(j = 1;j < n;++j) nw[++cnt] = e4[v + 1][j];
		for(j = 1;j <= n;++j) nw[++cnt] = e1[m][j];
		sort(nw + 1,nw + cnt + 1);
		li as = an1[u - 1] + an2[v + 1];
		for(j = 1;j <= cnt;++j) if(getf(nw[j].u) != getf(nw[j].v)){
			mg(nw[j].u,nw[j].v);
			as += nw[j].w;
		}
		print(as);pc('\n');
	}
	return 0;
}
```



---

## 作者：Forever1507 (赞：3)

有点牛的题。

一个可能比较前置的技巧是 LCT 维护 MST 的方法，具体来说就是加边的时候，如果两边原本就是连通的，那么就把路径上的最大边权拿出来和要加的边进行比较，选择更优的那一个。这个技巧启示我们，在 MST 中只有任意两点的路径的最大边权是重要的，并且两张图的 MST 是支持进行合并的。

所以说，一个基本的思路是预处理出所有前缀和后缀对应的 MST 然后在查询的时候进行合并，但是总的点数是 $n^2m$ 的，显然无法通过。

但是同时我们还注意到一个性质：这张图是一个网格图。这也就意味着，一个前缀/后缀形成的最小生成树，第 $i$ 列和第 $i+2$ 列的点是完全没有连边的。所以对于前缀/后缀的最小生成树，只有第一列和最后一列的点是重要的，那这不就是虚树吗？于是有一个朴素的做法，大力维护每个前缀/后缀的虚树然后在最后进行合并就可以了。

但是事实上这个虚树是不用真正建出来的，有一种基于并查集的更加方便的做法。具体来说，我们假设已经知道了前 $i-1$ 列形成的 MST，我们现在要加到第 $i$ 列，显然我们应该直接把原本两棵 MST 的边与连接两边的边一起做 Kruskal，但是为了控制点数，在这个过程中我们不希望第 $i-1$ 列的点出现在新的 MST 中，所以并查集合并的时候，如果有一个集合里没有任何一个第一列或第 $m$ 列的点，那么他就是不需要真正加入新 MST 中的边。但是它已经确定加入了贡献里且不再会被踢出，所以我们需要把它的边权累加进答案，然后把父亲指向有第一列或第 $m$ 列的点的集合。否则，可以证明直接连接两个集合的祖先节点是等价的，然后把这条边加入新的边集即可。

具体来说，因为 MST 中只关心任意两点的路径的最大边权，且在 Kruskal 的过程中这条边一定是最大的，所以在两个集合中无论怎么连都能够保证路径的最大边权，所以起到的效果是等价的。

所以我们可以直接用并查集维护前后缀的 MST，询问时暴力合并即可 。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
namespace IN{
    const int Q = 1000000;
    #define getc() (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,Q),p1==p2)?EOF:*p1++)
    char buf[Q],*p1,*p2;
    template<typename T>inline bool read(T &x) {
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
        register int f=0,flag=false;
        register char ch=getc();
        while(!isdigit(ch)){
            if (ch=='-') f=1;
            ch=getc();
        }
        if(isdigit(ch)) x=x*10+ch-'0',ch=getc(),flag=true;
        while(isdigit(ch)) {
            x=x*10+ch-48;
            ch=getc();
        }
        x=f?-x:x;
        return flag;
    }
    template<typename T,typename ...Args>inline bool read(T& a,Args& ...args) {
       return read(a)&&read(args...);
    }
    #undef getc
}
using namespace IN;
const int N=105,M=10005;
int n,m,q,r[N][M],c[N][M];
unsigned int SA, SB, SC;int lim;
int getweight() {
    SA ^= SA << 16;
    SA ^= SA >> 5;
    SA ^= SA << 1;
    unsigned int t = SA;
    SA = SB;
    SB = SC;
    SC ^= t ^ SA;
    return SC % lim + 1;
}
void gen() {
    scanf("%d%d%u%u%u%d", &n, &m, &SA, &SB, &SC, &lim);
    int i, j, w;
    for(i = 1; i <= n; i++)
        for(j = 1; j <= m; j++) {
            // w = getweight();
            // if (j < m) {
            //     addedge(i, j, i, j + 1, w);
            // } else {
            //     addedge(i, j, i, 1, w);
            // }
            r[i][j]=getweight();
        }
    for(i = 1; i < n; i++)
        for(j = 1; j <= m; j++) {
            // w = getweight();
            c[i][j]=getweight();
            // addedge(i, j, i + 1, j, w);
        }
}
struct edge{
    int u,v,w;
};
inline int getid(int x,int y){
    return (x-1)*m+y;
}
struct MST{
    long long sum;
    vector<edge>vec;
    MST(){sum=0;}
    MST(int id){
        sum=0;
        for(signed i=1;i<n;++i)vec.push_back({getid(i,id),getid(i+1,id),c[i][id]});
    }
    void print(){
        cout<<"CHECK\n";
        cout<<"SUM = "<<sum<<'\n';
        for(auto x:vec)cout<<x.u<<' '<<x.v<<' '<<x.w<<'\n';
    }
}pre[M],suf[M];
int fa[N*M];
bool flg[N*M];
int find(int x){
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
bool cmp(edge x,edge y){
    return x.w<y.w;
}
MST merge(int id,bool opt){
    MST ans;
    ans.vec.clear();
    vector<edge>vec;
    for(signed i=1;i<=n;++i)fa[getid(i,id)]=getid(i,id),flg[getid(i,id)]=1;
    if(!opt){
        for(signed i=1;i<=n;++i){
            fa[getid(i,id-1)]=getid(i,id-1);
            flg[getid(i,id-1)]=0;
            fa[getid(i,1)]=getid(i,1);
            flg[getid(i,1)]=1;
        }
    }
    else{
        for(signed i=1;i<=n;++i){
            fa[getid(i,id+1)]=getid(i,id+1);
            flg[getid(i,id+1)]=0;
            fa[getid(i,m)]=getid(i,m);
            flg[getid(i,m)]=1;
        }
    }
    if(!opt)for(auto x:pre[id-1].vec)vec.push_back(x);
    else for(auto x:suf[id+1].vec)vec.push_back(x);
    for(signed i=1;i<n;++i)vec.push_back({getid(i,id),getid(i+1,id),c[i][id]});
    if(!opt)for(signed i=1;i<=n;++i)vec.push_back({getid(i,id-1),getid(i,id),r[i][id-1]});
    else for(signed i=1;i<=n;++i)vec.push_back({getid(i,id),getid(i,id+1),r[i][id]});
    sort(vec.begin(),vec.end(),cmp);
    if(!opt)ans.sum=pre[id-1].sum;
    else ans.sum=suf[id+1].sum;
    for(auto x:vec){
        int a=find(x.u),b=find(x.v),c=x.w;
        if(a==b)continue;
        if(!flg[a]||!flg[b])ans.sum+=c;
        if(!flg[a])fa[a]=b;
        else if(!flg[b])fa[b]=a;
        else fa[b]=a,ans.vec.push_back({a,b,c});
    }
    return ans;
}
long long solve(int l,int r){
	//do sth.
    for(signed i=1;i<=n;++i)fa[getid(i,1)]=getid(i,1),fa[getid(i,l-1)]=getid(i,l-1),fa[getid(i,r+1)]=getid(i,r+1),fa[getid(i,m)]=getid(i,m);
	vector<edge>vec;
    for(auto x:pre[l-1].vec)vec.push_back(x);
    for(auto x:suf[r+1].vec)vec.push_back(x);
    for(signed i=1;i<=n;++i)vec.push_back({getid(i,1),getid(i,m),::r[i][m]});
    // for(auto x:vec)cout<<x.u<<' '<<x.v<<' '<<x.w<<'\n';
    long long ans=pre[l-1].sum+suf[r+1].sum;
    // cout<<ans<<'\n';
    sort(vec.begin(),vec.end(),cmp);
    for(auto x:vec){
        int a=find(x.u),b=find(x.v),c=x.w;
        if(a==b)continue;
        fa[a]=b;
        ans+=c;
        // cout<<x.u<<' '<<x.v<<' '<<c<<'\n';
    }
    return ans;
}
signed main()
{
	// freopen("ds.in","r",stdin);
	// freopen("ds.out","w",stdout);
    // cin>>n>>m>>op>>lim>>seed;
    gen();
    pre[1]=MST(1);
    suf[m]=MST(m);
    for(signed i=2;i<=m;++i)pre[i]=merge(i,0);
    // for(signed i=1;i<=m;++i)pre[i].print();
    for(signed i=m-1;i>=1;--i)suf[i]=merge(i,1);
	// do sth.
	// q=read();
    read(q);
	while(q--){
		int l,r;
        read(l);read(r);
        // =read(),r=read();
		printf("%lld\n",solve(l,r));
	}
	return 0;
}

```

---

## 作者：tzc_wk (赞：2)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P5360)

好题。

首先看到抠掉一个区间的限制，我们很自然地想到对前后缀跑一遍 MST 后把左右两半的信息合并起来的想法，于是问题转化为怎样维护前后缀的最小生成树。

直接做复杂度 $nm^2\log n$​，显然无法通过，乍一眼貌似也需要可持久化 LCT / 树状数组套 LCT 等奇奇怪怪的数据结构才能优化，看上去异常棘手。但是别忘了，我们还没有用到“图是一张网格图”的性质。我们注意到，这题列数 $m$​ 很多但行数 $n$​ 很小，因此我们肯定尽量将复杂度倾向于 $n$​。可以发现当我们新增扩展一列 $i$​ 时，我们新增的边只会连在 $\mathcal O(n)$​ 个点之间，即所有形如 $(j,i-1),1\le j\le m$​ 的点。按照 LCT 维护最小生成树的那套理论，当我们新加入一条边 $E=(u,v,w)$​ 时，最小生成树的变化可以表现为，取出 $u,v$​ 路径上权值最大的边 $E_0$​，如果 $E_0$ 的权值 $>w$ 则删除 $E_0$ 加入 $E$，否则就什么也不干。也就是说，在我们这一轮扩展中，只有这 $n$ 个关键点两两路径上权值最大的边可能会在这一轮扩展中被删除，而这样的边最多只有 $\mathcal O(n)$ 个，因为如果我们对 $n$ 个关键点建虚树，那么这样的边都肯定虚树上某条链上权值最大的边，而虚树上边数最大为 $2n-2$。

因此我们考虑不记录整个最小生成树的边集，而只记录这些“关键边”组成的集合，对于剩余的在 MST 上的边，无论我们怎么扩展，它们肯定都会在 MST 上，因此我们只用单纯地记录一下它们的边权之和即可。直接记录这些边在原图中的编号则会导致 kruskal 的结果出错，因此我们不能直接记录这些边在原图上的编号，改进方法是，我们找出 $(1,1),(2,1),(3,1),\cdots,(n,1),(1,i-1),(2,i-1),\cdots,(n,i-1)$ 这些点在 $1\sim i-1$ 上的虚树，然后对虚树上 $\mathcal O(n)$ 个点重标号并对虚树上每条链求出权值最大的边，这样新增一列时，我们将新增的边与原来 $\mathcal O(n)$ 条边放在一起跑 kruskal，建出这 $9n$ 个点的最小生成树后再建出以 $(1,1),(2,1),\cdots,(n,1),(1,i),(2,i),\cdots,(n,i)$ 为关键点的虚树，求出每条链上权值最大的边作为新的关键边集合即可实现合并两棵 MST 的过程。

时间复杂度 $n(m+q)\log n$​，部分不清楚的地方可通过阅读代码理解。

```cpp
const int MAXN = 100;
const int MAXM = 1e4;
const int MAXC = MAXN << 4;
int n, m, hor[MAXN + 5][MAXM + 5], vert[MAXN + 5][MAXM + 5];
u32 SA, SB, SC; int lim;
int getweight() {
	SA ^= SA << 16; SA ^= SA >> 5; SA ^= SA << 1;
	unsigned int t = SA;
	SA = SB; SB = SC; SC ^= t ^ SA;
	return SC % lim + 1;
}
struct edge {
	int u, v, w;
	edge(int _u = 0, int _v = 0, int _w = 0): u(_u), v(_v), w(_w) {}
	bool operator < (const edge &rhs) {return w < rhs.w;}
};
struct dsu {
	int f[MAXC + 5];
	void init() {memset(f, 0, sizeof(f));}
	int find(int x) {return (!f[x]) ? x : f[x] = find(f[x]);}
	bool merge(int x, int y) {x = find(x); y = find(y); return (x == y) ? 0 : (f[x] = y, 1);}
} F;
struct graph {
	int hd[MAXC + 5], nxt[MAXC * 2 + 5], to[MAXC * 2 + 5], val[MAXC * 2 + 5], ec = 0;
	void init() {memset(hd, 0, sizeof(hd)); ec = 0;}
	void adde(int u, int v, int w) {
		to[++ec] = v; val[ec] = w; nxt[ec] = hd[u]; hd[u] = ec;
		to[++ec] = u; val[ec] = w; nxt[ec] = hd[v]; hd[v] = ec;
	}
} G;
bool is[MAXC + 5], ont[MAXC + 5];
struct MST {
	vector<edge> E; int tot;
	ll static_sum; // sum of static edges
	void init(vector<int> w) {
		tot = n;
		for (int i = 0; i < w.size(); i++)
			E.pb(edge(i + 1, i + 2, w[i]));
	}
	ll query() {
		ll sum = static_sum;
		for (int i = 0; i < E.size(); i++) sum += E[i].w;
		return sum;
	}
} pre[MAXM + 5], suf[MAXM + 5];
int fa[MAXC + 5], faw[MAXC + 5];
void dfs_init(int x, int f) {
	fa[x] = f;
	for (int e = G.hd[x]; e; e = G.nxt[e]) {
		int y = G.to[e], z = G.val[e]; if (y == f) continue;
		faw[y] = z; dfs_init(y, x);
	}
}
int id[MAXC + 5], idcnt = 0;
vector<pii> te;
int dfs_build(int x, int f) {
	int V = 0, two = 0; ont[x] = is[x];
	for (int e = G.hd[x]; e; e = G.nxt[e]) {
		int y = G.to[e]; if (y == f) continue;
		int z = dfs_build(y, x);
		if (z) {
			if (V) two = 1, te.pb(mp(x, z));
			else V = z;
		}
	}
	if (!V) return (is[x]) ? x : 0;
	else {
		ont[x] = 1;
		if (two) return is[x] = 1, te.pb(mp(x, V)), x;
		else {
			if (is[x]) return te.pb(mp(x, V)), x;
			else return V;
		}
	}
}
int qrymx(int u, int v) {
	int mx = 0;
	while (v ^ u) chkmax(mx, faw[v]), v = fa[v];
	return mx;
}
MST merge(MST &a, MST &b, vector<int> w) {
	vector<edge> ve;
	MST c; c.tot = a.tot + b.tot;
	for (int i = 0; i < a.E.size(); i++) ve.pb(a.E[i]);
	for (int i = 0; i < b.E.size(); i++) ve.pb(edge(b.E[i].u + a.tot, b.E[i].v + a.tot, b.E[i].w));
	for (int i = 1; i <= n; i++) ve.pb(edge(a.tot - n + i, a.tot + i, w[i - 1]));
	F.init(); G.init(); ll esum = 0; sort(ve.begin(), ve.end());
	for (int i = 0; i < ve.size(); i++) if (F.merge(ve[i].u, ve[i].v))
		G.adde(ve[i].u, ve[i].v, ve[i].w), esum += ve[i].w;
	memset(is, 0, sizeof(is)); memset(ont, 0, sizeof(ont));
	for (int i = 1; i <= c.tot; i++) is[i] = (i <= n || i > c.tot - n);
	dfs_init(1, 0); te.clear(); dfs_build(1, 0);
	idcnt = 0; for (int i = 1; i <= c.tot; i++) if (ont[i]) id[i] = ++idcnt;
	for (pii p : te) c.E.pb(edge(id[p.fi], id[p.se], qrymx(p.fi, p.se)));
	for (int i = 0; i < c.E.size(); i++) esum -= c.E[i].w;
	c.static_sum = a.static_sum + b.static_sum + esum;
	c.tot = idcnt;
	return c;
}
int main() {
	scanf("%d%d%u%u%u%d", &n, &m, &SA, &SB, &SC, &lim);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) hor[i][j] = getweight();
	for (int i = 1; i < n; i++) for (int j = 1; j <= m; j++) vert[i][j] = getweight();
//	printf("hor:\n");
//	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++)
//		printf("%d%c", hor[i][j], " \n"[j == m]);
//	printf("vert:\n");
//	for (int i = 1; i < n; i++) for (int j = 1; j <= m; j++)
//		printf("%d%c", vert[i][j], " \n"[j == m]);
	for (int j = 1; j <= m; j++) {
		vector<int> vec;
		for (int i = 1; i < n; i++) vec.pb(vert[i][j]);
		pre[j].init(vec); suf[j].init(vec);
	}
	for (int i = 2; i <= m; i++) {
		vector<int> vec;
		for (int j = 1; j <= n; j++) vec.pb(hor[j][i - 1]);
		pre[i] = merge(pre[i - 1], pre[i], vec);
	}
	for (int i = m - 1; i; i--) {
		vector<int> vec;
		for (int j = 1; j <= n; j++) vec.pb(hor[j][i]);
		suf[i] = merge(suf[i], suf[i + 1], vec);
	}
//	printf("pre:\n");
//	for (int i = 1; i <= m; i++) {
//		printf("[1, %d]:\n", i);
//		for (int j = 0; j < pre[i].E.size(); j++)
//			printf("%d %d %d\n", pre[i].E[j].u, pre[i].E[j].v, pre[i].E[j].w);
//		printf("weight of MST: %lld\n", pre[i].query());
//	}
	int qu; scanf("%d", &qu);
	while (qu--) {
		int l, r; scanf("%d%d", &l, &r); vector<int> vec;
		for (int j = 1; j <= n; j++) vec.pb(hor[j][m]);
		printf("%lld\n", merge(suf[r + 1], pre[l - 1], vec).query());
	}
	return 0;
}
/*
6 5 998244353 1004535809 1000000007 5
6
2 2
2 3
2 4
3 3
3 4
4 4
*/
```



---

## 作者：Tsawke (赞：1)

# [LG-P5360 [SDOI2019]世界地图](https://www.luogu.com.cn/problem/P5360) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P5360-Solution)

### Solution

具体做法题解区里已经很详尽了，基本都大同小异，这里主要简单提一下一些细节问题。

首先考虑一下本题的大致思路，构建前缀 MST 和后缀 MST 每次询问合成即可。合成时通过将两个 MST 所有边合成为新的 MST 然后通过虚树的思想只保留关键点，将树简化以保证点数级别。

1. 点的重标号

这是我第一个卡住的点，最开始的思路就是朴素地开一堆 `unordered_map` 然后手写 `pair < int, int >` 的哈希建出来一堆映射，将坐标映射为点，然后每次建 MST 或者虚树的时候都重搞一遍，写了一会发现这东西常数似乎有些爆炸，且细节巨多，翻了一下题解区理解了一会才明白这个重标号点的思路：

我们还是回到合成 MST 的过程中，发现如对于 $ [1, i - 1] \to [1, i] $ 的过程，关键点的纵坐标从 $ 1 $ 和 $ i - 1 $ 变为 $ 1 $ 和 $ i $，连结的所有边为 $ i - 1\ \to i $，这样我们就容易理解大多数题解的映射方式了，使所有 MST 满足前 $ n $ 个是第 $ 1 $ 列，后 $ n $ 个是最后 $ 1 $ 列，这个过程在一般的实现中是自然的。合成 $ A $ 和 $ B $ 两个 MST 的时候，直接按序将 $ B $ 的点接到 $ A $ 之后，然后对 $ A $ 的后 $ n $ 个分别与 $ B $ 的前 $ n $ 个连结，并将 $ A $ 的前 $ n $ 和 $ B $ 的后 $ n $ 作为关键点，这样即可优美地解决点的重标号。

2. 关键点的选取

对于上述点的重标号的过程，对于 $ 1 $ 列的钦定选择的原因，个人理解就是对于维护前后缀的时候，钦定 $ 1 $ 列为关键点显然是非必要的，但维护后就可以同时适配合并前后缀，应该属于是写法的优化。

3. 虚树的构建

做这道题的时候本来是准备直接写两次按 dfn 排序的朴素建虚树的，后来看到题解区用的都是两次 dfs，不难发现这样是可以减少不少常数的，因为每次的树的形态都完全不同，每次都需要重构树剖或者倍增，于是就不如 $ O(n) $ 的两次 dfs 了。

4. 前后缀的合并

这里注意需要用后缀在前前缀在后进行合成，因为按照我的写法合并是有序的，即是对 $ A $ 的后 $ n $ 与 $ B $ 的前 $ n $，如果前缀在前后缀在后连边就会反了。

5. 资源的回收

不难发现对于 `500MiB` 的限制按照我的写法最多开 $ 2 \times 10^7 $ 条边，这是不够用的，所以需要实现对边的复用，对应着代码中的：

```cpp
void* Edge::operator new(size_t){static Edge* P = ed; return P++;}
```

改为：

```cpp
void* Edge::operator new(size_t){static Edge* P = ed; if(P - ed > 20100000)P = ed; return P++;}
```

注意这里无需清空边的内存池是因为每次我调用 `new` 的时候都对其进行了初始化列表的初始化。

代码大同小异。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW void* Edge::operator new(size_t){static Edge* P = ed; if(P - ed > 20100000)P = ed; return P++;}
#define ROPNEW_NODE void* Node::operator new(size_t){static Node* P = nd; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

template < typename T = int >
inline T read(void);

int N, M, Q;
unsigned int SA, SB, SC;
int lim;
struct edge{int s, t; int val;};
int nxtR[110][11000], nxtL[110][11000];

struct Edge{
    Edge* nxt;
    int to;
    int val;
    OPNEW;
}ed[21000000];
ROPNEW;

class VirtualTree{
private:
    Edge* head[1100];
public:
    bitset < 1100 > isKey;
    bitset < 1100 > invt;
    basic_string < edge > edgs;
    void Clear(void){memset(head, 0, sizeof head);  isKey.reset(); invt.reset(); edgs.clear();}
    VirtualTree(void){Clear();}
    void AddEdge(int s, int t, int val){
        head[s] = new Edge{head[s], t, val};
        head[t] = new Edge{head[t], s, val};
    }
    bool dfs_pre(int p = 1, int fa = 0){
        int cnt(0);
        for(auto i = head[p]; i; i = i->nxt)
            if(SON != fa)cnt += dfs_pre(SON, p);
        invt[p] = isKey[p] | (cnt >= 2);
        return invt[p] | bool(cnt);
    }
    void dfs_link(int p = 1, int lst = 0, int mxv = 0, int fa = 0){
        if(invt[p]){
            if(lst)edgs += edge{lst, p, mxv};
            lst = p, mxv = 0;
        }
        for(auto i = head[p]; i; i = i->nxt)
            if(SON != fa)dfs_link(SON, lst, max(mxv, i->val), p);
    }
}vt;

class MST{
private:
public:
    int tot;
    ll sum;
    basic_string < edge > edgs;
    void Clear(void){edgs.clear(); sum = 0; tot = 0;}
    MST(void){Clear();}
    ll Query(void){ll ret(sum); for(auto edg : edgs)ret += edg.val; return ret;}
}pre[11000], suf[11000];

class UnionFind{
private:
    int fa[1100];
public:
    void Clear(void){for(int i = 0; i <= 1010; ++i)fa[i] = i;}
    UnionFind(void){Clear();}
    int Find(int x){return x == fa[x] ? x : fa[x] = Find(fa[x]);}
    void Union(int s, int t){if(Find(s) != Find(t))fa[Find(s)] = Find(t);}
}uf;

int main(){
    N = read(), M = read();
    auto GetWeight = [](void)->int{SA ^= SA << 16; SA ^= SA >> 5; SA ^= SA << 1; unsigned int t = SA;SA = SB;SB = SC;SC ^= t ^ SA;return SC % lim + 1;};
    auto Gen = [GetWeight](void)->void{
        scanf("%u%u%u%d", &SA, &SB, &SC, &lim);
        for(int i = 1; i <= N; ++i)for(int j = 1; j <= M; ++j)nxtR[i][j] = GetWeight();
        for(int i = 1; i < N; ++i)for(int j = 1; j <= M; ++j)nxtL[i][j] = GetWeight();
    }; Gen();
    auto MergeMST = [](const MST &A, const MST &B, int idx)->auto{
        unordered_map < int, int > mp;
        ll cur(0);
        MST ret;
        ret.edgs += A.edgs;
        for(auto edg : B.edgs)ret.edgs += edge{edg.s + A.tot, edg.t + A.tot, edg.val};
        for(int i = 1; i <= N; ++i)ret.edgs += edge{A.tot - N + i, A.tot + i, nxtR[i][idx]};
        sort(ret.edgs.begin(), ret.edgs.end(), [](const edge &a, const edge &b)->bool{return a.val < b.val;});
        uf.Clear(), vt.Clear();
        for(int i = 1; i <= N; ++i)vt.isKey[i] = vt.isKey[A.tot + B.tot - i + 1] = true;
        for(auto edg : ret.edgs)
            if(uf.Find(edg.s) != uf.Find(edg.t))vt.AddEdge(edg.s, edg.t, edg.val), uf.Union(edg.s, edg.t), cur += edg.val;
        vt.dfs_pre(), vt.dfs_link();
        ret.edgs = vt.edgs; ret.tot = 0;
        for(int i = 1; i <= A.tot + B.tot; ++i)if(vt.invt[i])mp[i] = ++ret.tot;
        for(auto &edg : ret.edgs)edg.s = mp[edg.s], edg.t = mp[edg.t], cur -= edg.val;
        ret.sum = A.sum + B.sum + cur;
        return ret;
    };
    for(int j = 1; j <= M; ++j)for(int i = 1; i < N; ++i)
        pre[j].edgs += edge{i, i + 1, nxtL[i][j]}, suf[j].edgs += edge{i, i + 1, nxtL[i][j]}, suf[j].tot = pre[j].tot = N;
    for(int j = 2; j < M; ++j)pre[j] = MergeMST(pre[j - 1], pre[j], j - 1);
    for(int j = M - 1; j > 1; --j)suf[j] = MergeMST(suf[j], suf[j + 1], j);
    Q = read();
    while(Q--){
        int l = read(), r = read();
        printf("%lld\n", MergeMST(suf[r + 1], pre[l - 1], M).Query());
    }
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2023_03_20 初稿

---

## 作者：SDNetFriend (赞：1)

### 题意这里不再赘述

[P5360 [SDOI2019]世界地图](https://www.luogu.com.cn/problem/P5360)

### 做法分析

首先可以看出来，最终的答案一定是和平的国家的最小生成树的边权和，然而直接求必然会爆，考虑优化。

我们可以发现，最终生成这棵树的所有点和边可以描述成一段经度前缀区间和一段后缀区间拼起来的区间。我们可以利用背面的那些边拼起来两棵生成树，因为保证 $1<l\leq r<m$ 所以第一列和最后一列一定是和平的，那背面的那些边也一定可走，故一定可以找到答案。

其实如果第一列或者最后一列也发生战乱也没什么问题，直接取前缀后缀之一就可以了。

所以我们问题转化为，我们要求出每个经度前缀和后缀区间的最小生成树，并在查询时合并两棵最小生成树。这样显然存不下，考虑优化。

### 优化

考虑我们如何合并两棵最小生成树：

从小到大遍历每一条在两棵树之间的边，并判断边两端是否在一个集合内。若否，则连上这条边并合并集合；若是，则判断这条边两个端点路径上边权最大的边的边权是否大于当前边，若是则断掉最大边权边并连接当前边，否则不进行操作。

通过这种做法，我们可以发现，只有部分点和边可能对接下来的操作产生贡献。边的贡献指边被断掉，点的贡献指其成为新边的端点。

因为网格图的特殊性，我们以前缀为例，当我们由 $i-1$ 这个前缀考虑到 $i$ 时，实际上是在合并原来的生成树和第 $i$ 列这个链状的生成树。

那我们发现，可能成为新边端点的点只有经度为 $i-1$ 的点和经度为 $i$ 的点，有可能产生贡献的边只有经度为 $i,i-1$ 的这些点相互的树上路径上边权最大的边。

这让我们想到虚树，即我们只保留刚才提到的“有可能产生贡献的点”来构建虚树，而边权就取路径上边权最大边的边权，这样做就可以时刻保证树的大小是 $O(n)$ 的。

### 细节处理

根据刚才的推导，可以发现我们只需要储存每个前缀和每个后缀区间的虚树和除虚树边以外的生成树边边权和即可方便地维护答案。

并且因为我们每次需要合并前后缀，所以前缀区间的第一列的点和后缀区间的最后一列的点同样是关键点。这样极限数据下虚树点最多是 $400$ 左右，那么每次合并或者求解时暴力跑 Kruskal 生成树即可。

**关于虚树**：不要用常规单调栈的方式建虚树，因为每次整棵树都是不一样的，那样每次都要处理倍增数组，求解时也带 $\log$ 会使常数非常大。

对于这种整树大小和关键点数差不多大的情况直接对整棵树 DFS 两次就可以了。第一次处理出所有需要加进去的点，第二次连边建树。注意点在虚树上当且仅当当前点是关键点或当前点至少两棵子树中有关键点。

### 贴代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define uint unsigned int
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=105,M=1e4+5,P=N*M;
uint SA,SB,SC;int lim;
inline int gw(){
    SA^=SA<<16;SA^=SA>>5;
    SA^=SA<<1;uint t=SA;
    SA=SB;SB=SC;SC^=t^SA;
    return SC%lim+1;
}
int n,m;
inline int trn(int x,int y)
	{return (x-1)*m+y;}
inline int gx(int id)
	{return (id-1)/m+1;}
inline int gy(int id)
	{return (id-1)%m+1;}
struct edge{int u,v,w;};
inline bool cmp(edge x,edge y)
	{return x.w<y.w;}
vector<edge> edg[P];
inline void lnk(int u,int v,int w){
	edg[u].push_back({u,v,w});
	edg[v].push_back({v,u,w});
}
edge e0[N][M],e1[N][M];
inline void gen(){
	n=read();m=read();
    scanf("%u%u%u%d",&SA,&SB,&SC,&lim);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j){
        	if(j<m)
                e0[i][j]={trn(i,j),trn(i,j+1),gw()};
            else
                e0[i][j]={trn(i,j),trn(i,1),gw()};
        }
    for(int i=1;i<n;i++)
        for(int j=1;j<=m;j++)
            e1[i][j]={trn(i,j),trn(i+1,j),gw()};
}
struct tree{
	vector<int> ps;
	vector<edge> es;
	lint sum;
	inline void build(int j){
		for(int i=1;i<=n;++i){
			ps.push_back(trn(i,j));
			if(i==n)continue;
			es.push_back(e1[i][j]);
		}
	}
	inline void merge(tree &x){
		sum+=x.sum;
		for(edge e:x.es)es.push_back(e);
		for(int u:x.ps)ps.push_back(u);
	}
	inline lint query(){
		lint res=sum;
		for(edge e:es)res+=e.w;
		return res;
	}
}pre[M],suf[M];
inline bool ex(vector<int> &a,int v){
	auto it=lower_bound(a.begin(),a.end(),v);
	return it!=a.end()&&*it==v;
}
inline tree merge(int j,tree &x,tree &y){
	tree z=x;z.merge(y);
	for(int i=1;i<=n;++i)
		z.es.push_back(e0[i][j]);
	return z;
}
int fa[P];
int find(int x){
	if(x==fa[x])return x;
	return fa[x]=find(fa[x]);
}
vector<edge> gra[P];
inline void init(tree &x)
	{for(int u:x.ps)gra[u].resize(0),fa[u]=u;}
inline lint Kru(tree &x){
	lint sum=0;
	sort(x.es.begin(),x.es.end(),cmp);
	vector<edge> res;
	for(edge e:x.es){
		int u=find(e.u),v=find(e.v);
		if(u==v)continue;sum+=e.w;
		fa[u]=v;res.push_back(e);
		gra[e.u].push_back({e.u,e.v,e.w});
		gra[e.v].push_back({e.v,e.u,e.w});
	}x.es=res;return sum;
}
bitset<P> flg;
inline int mk(tree &x){
	int mn=1e9,mx=0,res;
	for(int u:x.ps){
		mn=min(mn,gy(u));
		mx=max(mx,gy(u));
	}
	for(int u:x.ps){
		if(gy(u)==mn||gy(u)==mx)
			flg[u]=1,res=u;
		else flg[u]=0;
	}return res;
}
int DFS0(int u,int fa){
	int cnt=0;
	for(edge e:gra[u])
		if(e.v!=fa)cnt+=DFS0(e.v,u);
	if(cnt>1)flg[u]=1;
	return (int)(flg[u]||cnt);
}
void DFS1(int u,int fa,int lst,int mx,tree &x){
	if(flg[u]){
		if(lst)
			x.es.push_back({u,lst,mx}),x.sum-=mx;
		lst=u;mx=0;x.ps.push_back(u);
	}
	for(edge e:gra[u]){
		if(e.v==fa)continue;
		DFS1(e.v,u,lst,max(mx,e.w),x);
	}
}
inline void upd(tree &x,bool tp){ 
	init(x);lint sum=Kru(x);
	if(!tp)return;
	x.sum+=sum;int rt=mk(x);
	x.es.resize(0);x.ps.resize(0);
	DFS0(rt,0);DFS1(rt,0,0,0,x);
}
inline void calc(){
	pre[1].build(1);
	for(int i=2;i<=m;++i){
		pre[i].build(i);
		pre[i]=merge(i-1,pre[i-1],pre[i]);
		upd(pre[i],true);
	}
	suf[m].build(m);
	for(int i=m-1;i>=1;--i){
		suf[i].build(i);
		suf[i]=merge(i,suf[i+1],suf[i]);
		upd(suf[i],true);
	}
}
inline lint solve(int l,int r){
	tree res=merge(m,pre[l-1],suf[r+1]);
	upd(res,false);return res.query();
}
int main(){
	gen();calc();
	int q=read();
	while(q--){
		int l=read(),r=read();
		printf("%lld\n",solve(l,r));
	}
	return 0;
}
```


---

## 作者：xfrvq (赞：1)

题意：$n$ 行 $m$ 列网格图，**每行首尾相连**。多次询问保留 $[1,l)\cup(r,m]$ 列的点以及它们之间的边，最小生成树边权和。

求出前缀列的 MST，后缀列的 MST，询问时**将两部分以及每行首尾相连的边合并**即可。

现在考虑求前缀列 MST，每次把 $1\sim i$ 列的 MST 和**第 $i+1$ 列的竖向边，第 $i\to i+1$ 列的横向边**合并。

我们把第 $1$ 列和第 $i$ 列的点称作关键点。后续合并中仅有这两列的点会连上新边（在合并第 $i+1$ 列时第 $i$ 列点连上新边，询问时合并前缀后缀第 $1$ 列连上新边）。

结论：在 MST 中加新边 $(u,v)$，只有链 $u,v$ 上最长边可能被删。这里 $u,v\in$ 关键点集。

于是我们保留两两关键点路径最大边。对于关键点 $u,v$，其在 MST 树链上的最长边权为 $w$，保留一条边 $\{u,v,w\}$。**这条边非真实存在只是效果等价**，称其为关键边。

我们每一轮只记录关键边，递推时拿关键边和新边跑 Kruskal。非关键边的边不可能被删，只需记录总和。

证明复杂度：

+ 关键点集大小 $O(n)$。
+ 两点 MST 树链最大边等价于其 Kruskal 重构树上 LCA，根据虚树理论，$O(n)$ 个点两两树上 LCA 本质不同的仅有 $O(n)$ 个。

考虑求后缀 MST。和前缀问题相似，只是这里的关键点是第 $i$ 列和第 $m$ 列。

考虑合并前后缀。由于考虑过第 $1,m$ 列的关键点了，这里直接用前后缀关键边以及 $m$ 列到 $1$ 列的边跑 kruskal。

时间复杂度 $O(nm\log n+nq\alpha(n))$。瓶颈在于排序和并查集。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

const int N = 105,M = 10005;

int n,m,q,L,R,w1[N][M],w2[N][M],fa[N * M];
ll S,S1[M],S2[M];
vector<tuple<int,int,int>> E1[M],E2[M],E,E0;
bool vis[N * M];

int fnd(int x){ return x == fa[x] ? x : fa[x] = fnd(fa[x]); }

#define id(i,j) ((i - 1) * m + j)

unsigned SA,SB,SC; int lim;

int W(){
    SA ^= SA << 16,SA ^= SA >> 5,SA ^= SA << 1;
    unsigned t = SA; SA = SB,SB = SC; SC ^= t ^ SA;
	return SC % lim + 1;
}

void init(){
    scanf("%d%d%u%u%u%d",&n,&m,&SA,&SB,&SC,&lim);
    for(int i = 1;i <= n;++i)
        for(int j = 1;j <= m;++j) w1[i][j] = W();
    for(int i = 1;i < n;++i)
        for(int j = 1;j <= m;++j) w2[i][j] = W();
}

ll sol(auto &F,bool _,ll S = 0){
	if(_) ranges::sort(E);
	for(auto[w,u,v] : E)
		if((u = fnd(u)) != (v = fnd(v))){
			if(_ && vis[u] && vis[v]) F.emplace_back(w,u,v);
			vis[u] ? fa[v] = u : fa[u] = v;
		} else S += w;
	return S;
}

void Pre(){
	iota(fa,fa + N * M,0);
	for(int i = 1;i <= m;++i){
		E = E1[i - 1],S1[i] = S1[i - 1];
		for(int j = 1;j <= n;++j){
			vis[fa[id(j,1)] = id(j,1)] = vis[fa[id(j,i)] = id(j,i)] = 1;
			if(i > 2) vis[fa[id(j,i - 1)] = id(j,i - 1)] = 0;
			if(i > 1) E.emplace_back(w1[j][i - 1],id(j,i - 1),id(j,i)),S1[i] += w1[j][i - 1];
			if(j > 1) E.emplace_back(w2[j - 1][i],id(j - 1,i),id(j,i)),S1[i] += w2[j - 1][i];
		}
		S1[i] -= sol(E1[i],1),ranges::sort(E1[i]);
	}
}

void Suf(){
	iota(fa,fa + N * M,0); memset(vis,0,sizeof vis);
	for(int i = m;i >= 1;--i){
		E = E2[i + 1],S2[i] = S2[i + 1];
		for(int j = 1;j <= n;++j){
			vis[fa[id(j,m)] = id(j,m)] = vis[fa[id(j,i)] = id(j,i)] = 1;
			if(i < m - 1) vis[fa[id(j,i + 1)] = id(j,i + 1)] = 0;
			if(i < m) E.emplace_back(w1[j][i],id(j,i),id(j,i + 1)),S2[i] += w1[j][i];
			if(j < n) E.emplace_back(w2[j][i],id(j,i),id(j + 1,i)),S2[i] += w2[j][i];
		}
		S2[i] -= sol(E2[i],1),ranges::sort(E2[i]);
	}
}

int main(){
	init(),Pre(),Suf();
	iota(fa,fa + N * M,0),memset(vis,0,sizeof vis);
	for(int j = 1;j <= n;++j) E0.emplace_back(w1[j][m],id(j,m),id(j,1));
	ranges::sort(E0);
	for(scanf("%d",&q);q--;){
		scanf("%d%d",&L,&R);
		S = S1[L - 1] + S2[R + 1];
		E = E0,E.resize(n + E1[L - 1].size() + E2[R + 1].size());
		merge(begin(E1[L - 1]),end(E1[L - 1]),begin(E2[R + 1]),end(E2[R + 1]),begin(E) + n);
		inplace_merge(begin(E),begin(E) + n,end(E));
		for(int j = 1;j <= n;++j){
			S += w1[j][m];	
			fa[id(j,m)] = id(j,m),fa[id(j,1)] = id(j,1);
			fa[id(j,L - 1)] = id(j,L - 1),fa[id(j,R + 1)] = id(j,R + 1);
		}
		printf("%lld\n",S - sol(E,0));
	}
	return 0;
}
```

---

## 作者：是青白呀 (赞：0)

高级。

一个想法是维护前后缀列的 MST，每次询问是利用 $1,m$ 之间的 $O(n)$ 条边进行合并。但是加边 MST 合并的总复杂度是边数级别的，而原来的图上点数和边数同阶，故单次合并仍然是 $O(nm\log nm)$ 的，过不去。

考虑减少一些边/点数。注意到所有前后缀状态下的 MST 只有最左和最右的两列在全过程中可能被合并到，因此我们考虑对这 $O(n)$ 个点建立等效 MST。假设左侧 MST 为 $G_1$，右侧 MST 为 $G_2$，在两棵树的关键点之间有连边。则我们有结论：对于任意一侧的 MST，**仅有某两个关键点路径上的最大边在未来可能被删除，其余边一定不会被删除**。正确性可以考虑删掉最大边的路径一定跨越 $G_1,G_2$，则若原路径上的次大边在下一轮可能被删除（也即是新路径最大边），那么我们从跨越位置断开，次大边应当是另一对关键点路径上的最大边。

因此考虑只保留所有的关键点，及两两关键点之间的最大边。这样的边数是 $O(n^2)$，我们希望把他变成一棵树。考虑利用 Kruskal 重构树的结构：Kruskal 过程中是从小往大依次选边的，因此此次合并时遍历到的一条边左右两个连通块，在新增更多边的时候一定还是连通，因此**每条边在两个连通块内的端点可以任选**。于是我们选择连接两个连通块内任意的下一轮关键点即可。若存在一个连通块内不含下一轮关键点，则这条边此后不再会被删去（因为他不是重构树上某两个关键点的 LCA），不用保留。这样一来，所有前后缀的等效 MST 就完成了建立。

此时每一个前缀和后缀的 MST 上点边数均为 $O(n)$。那么对于每一次询问，只需要把前缀、后缀及 $1,m$ 之间的所有 $O(n)$ 条边和 $O(n)$ 个关键点取出来跑一次 Kruskal 即可。注意这里不需要新建边。对于前后缀的处理，我们把每一列的所有新边和上一个等效 MST 的边拿出来跑 kruskal 即可。

最后注意一条边不被保留并不意味他在答案中不出现，因此需要维护不在等效 MST 中的生成树边权和。

总复杂度 $O((q+m)n\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define lowbit(i) (i&-i)
#define qingbai qwq
using namespace std;
typedef long long ll;
const int N=105,M=10005,mo=998244353,inf=(ll)1e18+7;
const double PI=acos(-1);
unsigned int SA, SB, SC;int lim;
int getweight() {
    SA ^= SA << 16;
    SA ^= SA >> 5;
    SA ^= SA << 1;
    unsigned int t = SA;
    SA = SB;
    SB = SC;
    SC ^= t ^ SA;
    return SC % lim + 1;
}
int n,m,q,r[N][M],c[N][M];
void gen() {
    scanf("%d%d%u%u%u%d", &n, &m, &SA, &SB, &SC, &lim);
    int i, j, w;
    for(i = 1; i <= n; i++)
        for(j = 1; j <= m; j++) {
            r[i][j] = getweight();
        }
    for(i = 1; i < n; i++)
        for(j = 1; j <= m; j++) {
            c[i][j] = getweight();
        }
}
#define int long long
void read(int &a){
    int x=0,w=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+ch-'0';
        ch=getchar();
    }
    a=x*w;
}
struct edge{
    int x,y,w;
    friend bool operator<(edge x,edge y){
        return x.w<y.w;
    }
};
vector<edge>pre[M],suf[M],e;
int pres[M],sufs[M];
int getid(int x,int y){
    return (x-1)*m+y;
}
struct bcj{
    int fa[N*M];
    void init(){
        rep(i,1,n*m)
            fa[i]=i;
    }
    int find(int x){
        if(fa[x]==x)return x;
        return fa[x]=find(fa[x]);
    }
    bool merge(int x,int y){
        x=find(x),y=find(y);
        if(x==y)return 0;
        fa[x]=y;
        return 1;
    }
}B;
bool targ[N*M];
vector<edge>nwe,rese;
int mstmerge(){//返回没用的边权和
    sort(nwe.begin(),nwe.end()),rese.clear();
    int res=0;
    for(auto j:nwe){
        int x=j.x,y=j.y,w=j.w;
        x=B.find(x),y=B.find(y);
        if(x!=y){
            if(targ[x]&&targ[y])rese.push_back((edge){x,y,w});
            if(targ[x])swap(x,y);
            B.merge(x,y);
        }
        else res+=w;
    }
    return res;
}
signed main(){
	gen();
    rep(j,1,m){//pre
        nwe.clear();
        rep(i,1,n)
            B.fa[getid(i,j)]=getid(i,j),targ[getid(i,j)]=1,B.fa[getid(i,1)]=getid(i,1),targ[getid(i,1)]=1;
        if(j>2){
            rep(i,1,n)
                B.fa[getid(i,j-1)]=getid(i,j-1),targ[getid(i,j-1)]=0;
        }
        rep(i,1,n){
            if(j!=1)nwe.push_back((edge){getid(i,j-1),getid(i,j),r[i][j-1]}),pres[j]+=r[i][j-1];
            if(i!=n)nwe.push_back((edge){getid(i,j),getid(i+1,j),c[i][j]}),pres[j]+=c[i][j];
        }
        for(auto i:pre[j-1])
            nwe.push_back(i);
        pres[j]+=pres[j-1]-mstmerge(),pre[j]=rese;
    }
    repp(j,m,1){//suf
        nwe.clear();
        rep(i,1,n)
            B.fa[getid(i,j)]=getid(i,j),targ[getid(i,j)]=1,B.fa[getid(i,m)]=getid(i,m),targ[getid(i,m)]=1;
        if(j<m-1){
            rep(i,1,n)
                B.fa[getid(i,j+1)]=getid(i,j+1),targ[getid(i,j+1)]=0;
        }
        rep(i,1,n){
            if(j!=m)nwe.push_back((edge){getid(i,j),getid(i,j+1),r[i][j]}),sufs[j]+=r[i][j];
            if(i!=n)nwe.push_back((edge){getid(i,j),getid(i+1,j),c[i][j]}),sufs[j]+=c[i][j];
        }
        for(auto i:suf[j+1])
            nwe.push_back(i);
        sufs[j]+=sufs[j+1]-mstmerge(),suf[j]=rese;
    }
    cin>>q;
    while(q--){
        int le,ri;
        read(le),read(ri);
        int ans=pres[le-1]+sufs[ri+1];
        nwe.clear();
        rep(i,1,n){
            B.fa[getid(i,1)]=getid(i,1),B.fa[getid(i,m)]=getid(i,m),targ[getid(i,1)]=0,targ[getid(i,m)]=0;
            if(le-1!=1)B.fa[getid(i,le-1)]=getid(i,le-1),targ[getid(i,le-1)]=0;
            if(ri+1!=m)B.fa[getid(i,ri+1)]=getid(i,ri+1),targ[getid(i,ri+1)]=0;
        }
        rep(i,1,n)
            ans+=r[i][m],nwe.push_back((edge){getid(i,1),getid(i,m),r[i][m]});
        for(auto j:suf[ri+1])
            nwe.push_back(j);
        for(auto j:pre[le-1])
            nwe.push_back(j);
        ans-=mstmerge();
        printf("%lld\n",ans);
    }
	return 0;
}
```

---

## 作者：lalaouye (赞：0)

超级好的题！

首先考虑一下 $L=2$ 的情况，它可以等价于只查询一个后缀，这引导我们想一个动态加点加边求最小生成树的做法，发现这是 LCT 基础练习题，如果要加入 $(u,v)$ 这条边，如果不连通直接加，否则删除换上最大的边就行了。

而原问题需要我们合并前后缀，发现合并复杂度爆了。发现我们实际上并没有利用到网格图的性质，当我们在处理后缀的时候，我们断的边不可能是一条连着的点都不是最左边一列中的点的边，这启发我们动态维护最左边一列的点建的虚树，这样子复杂度就可以控制在 $\mathcal{O}(nm\log n)$ 了。

那么我们对于前后缀分别做一次每次查询合并就好了，时间复杂度 $\mathcal{O}(nm\log n)$。

代码：


```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i (l); i <= (r); ++ i)
#define rrp(i, l, r) for (int i (r); i >= (l); -- i)
#define eb emplace_back
#define pii pair <int, int>
#define inf 1000000000
#define ls (p << 1)
#define rs (ls | 1)
using namespace std;
constexpr int N = 1e4 + 5, M = 105, P = 1e9 + 7;
typedef long long ll;
typedef unsigned long long ull;
inline int rd () {
  int x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch)) {
    if (ch == '-') f = -1;
    ch = getchar ();
  }
  while (isdigit (ch)) {
    x = (x << 1) + (x << 3) + (ch ^ 48);
    ch = getchar ();
  }
  return x * f;
}
int qpow (int x, int y, int p = P) {
  int ret = 1;
  for (; y; y >>= 1, x = x * x % p) if (y & 1) ret = ret * x % p;
  return ret;
}
int n, m, lim;
unsigned int SA, SB, SC;
inline int read() 
{
	SA ^= SA << 16;
	SA ^= SA >> 5;
	SA ^= SA << 1;
	ll t = SA;
	SA = SB;
	SB = SC;
	SC ^= t ^ SA;
	return SC % lim + 1;
} 
int a[N][M], b[N][M];
int is[N * M];
class EDG {
	public:
		int u, v, w;
		friend bool operator < (const EDG &a, const EDG &b) {
			return a.w < b.w;
		}
};
class MST {
	public:
		vector <EDG> e;
		int tot; ll sum;
		void init (int * a) {
			tot = n; sum = 0;
			rep (i, 1, n - 1) e.eb ((EDG) {i, i + 1, a[i]});
		}
		ll qry () {
			ll ret (sum);
			for (auto p : e) ret += p.w;
			return ret;
		}
} pre[N], suf[N];
int fa[N];
vector <pii> g[N];
int find (int x) {
	return x == fa[x] ? x : fa[x] = find (fa[x]);
}
bool dfs (int u, int fa) {
	int s (0);
	for (auto p : g[u]) if (p.first ^ fa) s += dfs (p.first, u);
	is[u] |= s >= 2;
	return s | is[u];
}
vector <EDG> e;
ll sum;
void dfs (int u, int fa, int zu, int mx) {
	if (is[u]) {
		if (zu) e.eb ((EDG) {is[u], zu, mx});
		sum -= mx, mx = 0; zu = is[u];
	}
	for (auto p : g[u]) if (p.first ^ fa) dfs (p.first, u, zu, max (mx, p.second));
}
MST merge (MST a, MST b, int * c) {
	MST ret;
	e.clear ();
	for (auto p : a.e) e.eb (p);
	for (auto p : b.e) e.eb ((EDG) {p.u + a.tot, p.v + a.tot, p.w});
	rep (i, 1, n) e.eb ((EDG) {a.tot + i - n, a.tot + i, c[i]});
	sort (e.begin (), e.end ());
	rep (i, 1, a.tot + b.tot) {
		fa[i] = i;
		is[i] = (i <= n || i > a.tot + b.tot - n);
		g[i].clear ();
	}
	sum = 0;
	for (auto p : e) {
		int u (p.u), v (p.v), w (p.w);
		if (find (u) ^ find (v)) {
			g[u].eb (pii (v, w)), g[v].eb (pii (u, w));
			fa[find (u)] = v; sum += w;
		}
	} dfs (1, 0);
	int cnt (0);
	rep (i, 1, a.tot + b.tot) {
		if (is[i]) is[i] = ++ cnt;
	} e.clear ();
	dfs (1, 0, 0, 0);
	ret.tot = cnt; ret.sum = a.sum + b.sum + sum, ret.e = e;
	return ret;
}
int32_t main () {
  // freopen ("1.in", "r", stdin);
  // freopen ("1.out", "w", stdout);
  scanf ("%d%d%u%u%u%d", &n, &m, &SA, &SB, &SC, &lim);
  rep (i, 1, n) rep (j, 1, m) a[j][i] = read ();
  rep (i, 1, n - 1) rep (j, 1, m) b[j][i] = read ();
  rep (i, 1, m) pre[i].init (b[i]), suf[i].init (b[i]);
  rep (i, 2, m - 1) pre[i] = merge (pre[i - 1], pre[i], a[i - 1]);
  rrp (i, 2, m - 1) suf[i] = merge (suf[i], suf[i + 1], a[i]);
  for (int q (rd ()); q; -- q) {
  	int L (rd ()), R (rd ());
  	printf ("%lld\n", merge (suf[R + 1], pre[L - 1], a[m]).qry ());
	}
}
```

---


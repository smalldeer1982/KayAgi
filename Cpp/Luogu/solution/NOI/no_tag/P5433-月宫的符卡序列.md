# 月宫的符卡序列

## 题目背景

![](https://cdn.luogu.com.cn/upload/pic/60728.png)


## 题目描述

**update：重新构造了两组数据，数据已加强**

辉夜原本是生活在月宫的月之公主

辉夜在淸理永远亭的仓库时，发现了一个古老的符卡序列 $S$，可能是很久很久以前的辉夜仍生活在月宫时创造的，但现在的她已经回忆不起来了。

于是辉夜便决定对这个符卡序列进行研究，$S$ 中的符卡从0开始标号，并且辉夜创造它时使用的卡组大小不超过26,因此符卡被表示成了字母 $a$ 到字母 $z$。

辉夜对从左往右读和从右往左读都一样的序列很感兴趣，对于$S$的某个满足上述条件连续子序列$a$,其价值为$a$在$S$中的所有出现位罝中点（即若a出现在$l...r$，那么中点为$\lfloor  \frac{l+r}{2} \rfloor $）的异或值。


辉夜想知道对于所有满足条件的$a$，最大的价值是多少


## 说明/提示

$1≤|S|≤10^6$

## 样例 #1

### 输入

```
1
aabacabaaa```

### 输出

```
15```

# 题解

## 作者：无意识躺枪人 (赞：10)

## $Q1$：我们该选择什么算法？

首先看到题目的**回文串** ，你的想法是不是**回文自动机**？

然而略加思索，回文自动机找的是回文串最后一个位置，而这道题的关键在于回文串**中心位置**，所以我们可以用**Manacher**
 
 
研究一下样例，会发现回文串的扩展符合Manacher扩展方式(可以对着数据模拟一下)
 
## $Q2$：然后如何做呢？
 
 我们都知道，最多有$n$个本质不同的回文串，因此当我们扩展到$f[i]$时，已经有了$i$种回文串。
 
 然后？暴力扩展啊
 
 就这样，我们扩展出了一个全新的回文串，这个回文串的基础是之前Manacher的回文串

>这个回文串的基础

一个回文串必须由上一个回文串发展而来，你应该马上敏感地想到—— **拓扑排序**
 
就这样，这里扩展出的回文串构成了一个拓扑序


## $Q3$：然后是hash吗

Hash当然是很常见的选择

然而 单哈容易挂掉，双哈码量**有些**大……

因此，我们可以用pbds中hash探测法

[点击进入日报详细学习](https://www.luogu.org/blog/Chanis/gnu-pbds)

以$O(N)$的复杂度完成字符串类型的map（其实并不是真正的map，但你可以这么理解），码量小，还快得一批……

这样你就可以做这道题了

关键代码：
```
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define N 3000005
#define ull unsigned long long
#define seed1 151
#define seed2 149
#define mod 19260817
#define mem(x) memset(x,0,sizeof(x))

void manacher()
{
    int i,len;
    len=1;
    a[0]='$';a[1]='#';
    for(register int i=1;i<=n;i++) {a[++len]=c[i];a[++len]='#';}
    a[len+1]='\0';int maxn=0,id=0,lasta=0;
    for(i=1;i<=len;i++)
    {
        if(maxn>i) p[i]=min(maxn-i,p[(id<<1)-i]);
        else p[i]=1;
        if(p[i]==1)lasta=0;
        else lasta=Map[change3(((i-p[i])>>1)+1,(i+p[i]-1)>>1)];
        while(a[i+p[i]]==a[i-p[i]])
        {
            p[i]++;
            int& temp=Map[change3(((i-p[i])>>1)+1,(i+p[i]-1)>>1)];
            if(!temp){temp=++tot;fa[tot]=lasta;sum[tot]=0;}
            lasta=temp;
        }
        sum[lasta]^=(i>>1)-1;
        if(i+p[i]>maxn){maxn=i+p[i];id=i;}
    }
}

void work()
{
    now1[0]=1;hash1[0]=0;
    for(register int i=1;i<=n;++i)
    {
        now1[i]=now1[i-1]*seed1%mod;
        hash1[i]=(hash1[i-1]*seed1+c[i])%mod;
    }
    now2[0]=1;hash2[0]=0;
    for(register int i=1;i<=n;++i)
    {
        now2[i]=now2[i-1]*seed2%mod;
        hash2[i]=(hash2[i-1]*seed2+c[i])%mod;
    }
    manacher();
}
```

最后，祝各位AC愉快

---

## 作者：_edge_ (赞：1)

我们一看到题就知道这题是要用回文结构刻画。

我只想到了 PAM，然后就有了这篇题解（

考虑建出 PAM，并且在每一个极长回文串的右端点处挂上 $r$ 这个点，这就意味着对于这个回文串的祖先而言，他们都必须异或上 $\frac {r+r-len+1}{2}$，对于下取整直接讨论 $len$ 的奇偶性即可。

转换一下式子就变成了 $r-\frac{len}2$ 的形式，然后，我们考虑暴力，求子树内的，然后就能获得 90pts（

我在这里想了能不能像 trie 一样全局 +1，然后合并维护，但是空间好像炸了，需要压缩二度点（不清楚能不能过）

考虑拆位，那么对于每一位而言能贡献到 $1$ 的就是一段区间，用 BIT 维护一下。

此时我们的复杂度是 $O(n \log^2n)$ 的，感觉很危险。

我们尝试在最大值个数小的时候跑暴力，个数大的时候跑 BIT。

发现完全没法卡，因为这个数据依赖于回文串的性质。

于是好像就跑得和标算一样块了（

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
const int INF=1e6+5;
const int B=105;
string s1;
int son[INF][29],V[INF],dfn[INF],L[INF],L3[INF];
int pre[INF],sz[INF],tot,fa[INF],len[INF];
vector <int> v3[INF],e[INF];
int Get(int x,int i) {
    while (i-len[x]-1<1 || s1[i-len[x]-1]!=s1[i]) x=fa[x];
    return x;
}
int K,sum3;
void DFS(int x) {
    dfn[++dfn[0]]=x;pre[x]=dfn[0];sz[x]=1;
    for (int v:e[x]) DFS(v),sz[x]+=sz[v];
}

int tree[INF*2],ans[INF],li;
void add(int x,int y) {x++;for (int i=x;i<=li;i+=i&-i) tree[i]^=y;}
int query(int x) {x++;x=min(x,li);int sum=0;for (int i=x;i;i-=i&-i) sum^=tree[i];return sum;}
vector<pii> A[INF];
void solve() {
    for (int w=0;w<=tot+3;w++) {
        for (int i=0;i<26;i++)
            son[w][i]=0;
        len[w]=fa[w]=ans[w]=0;
        v3[w].clear();
        e[w].clear();
        A[w].clear();
    }
    dfn[0]=0;
    tot=1;fa[0]=1;
    len[0]=0;len[1]=-1;
    cin>>s1;int n=s1.size(); s1=" "+s1;
    int la=0;
    for (int i=1;i<=n;i++) {
        int it=Get(la,i);
        if (!son[it][s1[i]-'a']) {
            int now=++tot;
            fa[now]=son[Get(fa[it],i)][s1[i]-'a'];
            son[it][s1[i]-'a']=now;
            len[now]=len[it]+2;
        } 
        la=son[it][s1[i]-'a'];
        v3[la].pb(i-1);
    }
    for (int i=0;i<=tot;i++)
        if (i!=1) e[fa[i]].pb(i);
    DFS(1);
    for (int i=2;i<=tot;i++) {
        L[i]=len[i];L[i]--;
        if (L[i]&1) L[i]++;
        L[i]>>=1;
    }
    
    for (int i=2;i<=tot;i++) 
        A[pre[i]+sz[i]-1].pb({L[i],i}),
        A[pre[i]-1].pb({L[i],-i});
    int RR=dfn[0];
    int res=0;
    for (int p=19;~p;p--) {
        li=(1ll<<(p+1));
        for (int i=1;i<=RR;i++) {
            for (int u:v3[dfn[i]]) add(u&((1ll<<(p+1))-1),1);
            for (pii it:A[i]) {
                int xx=it.fi&((1ll<<(p+1))-1);
                if (it.se>0) 
                    L3[it.se]^=query(li)^query((1<<p)+xx-1)^query(xx-1);
                else L3[-it.se]^=query(li)^query((1<<p)+xx-1)^query(xx-1);
            }
        }
        int Max=0,sum3=0,R1=0;
        for (int i=2;i<=tot;i++) {
            if (L3[i]&1) ans[i]^=(1ll<<p);
            Max=max(Max,ans[i]);
            if (Max<ans[i]) Max=ans[i],sum3=1;
            else if (Max==ans[i]) sum3++;
        }
        for (int i=2;i<=tot;i++)
            if (Max==ans[i]) R1=max(R1,pre[i]+sz[i]-1);
        for (int i=0;i<=tot;i++) L3[i]=0;
        for (int ww=0;ww<=li;ww++) tree[ww]=0;
        RR=min(RR,R1);
        if (sum3<=B) {
            for (int i=2;i<=tot;i++) {
                if (ans[i]!=Max) continue;
                int sum3=0;
                for (int w=pre[i];w<=pre[i]+sz[i]-1;w++) 
                    for (int u:v3[dfn[w]])
                        sum3^=u-L[i];
                res=max(res,sum3);
            }
            break;
        }
        // >=(1<<p)+L[i] 或者 <L[i] mod ((1<<(p+1)))
    }
    for (int w=2;w<=tot;w++)
        res=max(res,ans[w]);
    cout<<res<<"\n";
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int t=0;cin>>t;
    while (t--) solve();
    return 0;
}
```

---

## 作者：FunnyCreatress (赞：1)

upd：代码锅了，已修

似乎不算很难的题？

注意到如果一个回文串 $S$ 可以由另一个回文串 $T$ 两边扩展得到，那么 $S$ 出现位置的中点集合必为 $T$ 中点集合的子集。

于是我们 manacher 跑出所有回文串，然后对每组回文串 $(S,T):S=c+T+c,c\text{为字符}$ 从 $S$ 向 $T$ 连边，并对每个中点给最长的回文串打上一个 tag，在最后使用拓扑排序下放即可。鉴于回文串不超过 $O(|S|)$ 种的事实，我们这样做的复杂度是 $O(|S|)$ 的。

连边的事情不用多说了吧，随手写个哈希表并不复杂。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N=1e6+5,P=2e6+9;
int T,n,f[N],hd[P],nxt[N],hs1[N],bas1[N],cnt,p[N],fa[N],ans,pos0,deg[N];ull key[N],hs2[N],bas2[N];char s[N];
int fnd(int h1,ull h2){
	for(int i=hd[h1];i;i=nxt[i])if(key[i]==h2)return i;
	return nxt[++cnt]=hd[h1],key[cnt]=h2,hd[h1]=cnt;
}
int H1(int l,int r){return (hs1[r]-1ll*hs1[l-1]*bas1[r-l+1]%P+P)%P;}
ull H2(int l,int r){return hs2[r]-hs2[l-1]*bas2[r-l+1];}
int main(){
	cin>>T;
	while(T--){
		memset(hd,0,sizeof(hd)),memset(p,0,sizeof(p)),cnt=ans=0;
		scanf("%s",s+1);n=strlen(s+1),s[0]=' ';
		for(int i=bas1[0]=bas2[0]=1;i<=n;i++)bas1[i]=bas1[i-1]*137%P,bas2[i]=bas2[i-1]*173;
		for(int i=1;i<=n;i++)hs1[i]=(hs1[i-1]*137+s[i])%P,hs2[i]=hs2[i-1]*173+s[i];
		for(int i=1,l=0,r=0;i<=n;i++){
			if(i<=r&&i+f[l+r-i]<=r)f[i]=f[l+r-i],p[fnd(H1(i-f[i]+1,i+f[i]-1),H2(i-f[i]+1,i+f[i]-1))]^=i;
			else{
				int nl=(i==r+1?i:(i+i-r)),nr=max(i,r);
				while(s[nl-1]==s[nr+1]){
					if(fnd(H1(nl-1,nr+1),H2(nl-1,nr+1))==cnt)fa[cnt]=fnd(H1(nl,nr),H2(nl,nr));
					nl--,nr++;
				}
				l=nl,r=nr,f[i]=r-i+1,p[fnd(H1(l,r),H2(l,r))]^=i-1;
			}
		}
		for(int i=1,l=0,r=0;i<n;i++){
			if(i<r&&i+f[l+r-i-1]<r)f[i]=f[l+r-i-1],p[fnd(H1(i-f[i]+1,i+f[i]),H2(i-f[i]+1,i+f[i]))]^=i;
			else{
				int nl=(i==r+1?i+1:i+i-r+1),nr=(i==r+1?i:r);
				while(s[nl-1]==s[nr+1]){
					if(fnd(H1(nl-1,nr+1),H2(nl-1,nr+1))==cnt)fa[cnt]=fnd(H1(nl,nr),H2(nl,nr));
					nl--,nr++;
				}
				l=nl,r=nr,f[i]=r-i;
				if(l<r)p[fnd(H1(l,r),H2(l,r))]^=i-1;
			}
		}
		pos0=fnd(0,0);queue<int> q;
		for(int i=1;i<=cnt;i++)deg[fa[i]]++;
		for(int i=1;i<=cnt;i++)if(deg[i]==0)q.push(i);
		while(!q.empty()){
			int x=q.front();q.pop();
			if(x==pos0)break;
			ans=max(ans,p[x]),p[fa[x]]^=p[x];
			if((--deg[fa[x]])==0)q.push(fa[x]);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：zyn_ (赞：0)

题意：给定 $S$，对一个**回文**字符串 $T$ 满足 $T$ 为 $S$ 的子串，定义其权值 $w(T)$ 为其在 $S$ 中作为子串出现的所有位置的中点的编号之异或和。求 $\max w(T)$。

考虑枚举中点，用 Manacher 或着你喜欢的方式求出这个中点对应的长度为奇数、偶数的**最长**回文串。设这个回文串为 $A[1\dots k]$，则 $A[c+1\dots k-c]$ 也是回文串，并称 $f(A)=\{A[c+1\dots k-c]|c\in\N,c+1\le k-c\}$。设求出的这些最长回文串构成集合 $M$，则所有 $S$ 的回文子串即为 $\bigcup_{A\in M}f(A)$。

建出回文树（PAM），则每个 $f(A)$ 对应了其上的一条树链，即这个链上所有字符串以同一个点为中点在 $S$ 中出现一次。所以只要先做若干次树上链上异或，然后对树上所有点单点求值。树上差分即可。时间复杂度可以 $O(n)$，但我的代码是 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
#define N 1000009
#define ull unsigned long long
char s[N];
int T,n,tr[N][26],fail[N],len[N],pos[N],sum[N],cnt,l,r,mid,ans;
const ull bs=20241029;
ull e[N],f[N],g[N],hsh[N];
gp_hash_table<ull,int> mp;
void insert(int p,char c){
    s[p]=c;int k=pos[p-1];
    while(s[p-1-len[k]]!=c)k=fail[k];
    if(!tr[k][c-'a']){
        len[++cnt]=len[k]+2;
        for(int i=0;i<26;++i)tr[cnt][i]=0;
        int q=fail[k];while(s[p-1-len[q]]!=c)q=fail[q];
        fail[cnt]=tr[q][c-'a'];
        tr[k][c-'a']=cnt;
        if(len[cnt]==1)hsh[cnt]=c;
        else hsh[cnt]=hsh[k]*bs+c+c*e[len[cnt]-1];
        mp[hsh[cnt]]=cnt;
    }pos[p]=tr[k][c-'a'];
}
void dfs(int p){
    for(int i=0;i<26;++i)if(tr[p][i])dfs(tr[p][i]),sum[p]^=sum[tr[p][i]];
    if(p>1)ans=max(ans,sum[p]);
}
int main(){
    scanf("%d",&T);
    while(T--){
        memset(s,0,sizeof(s));
        scanf("%s",s+1);n=0;
        while(s[n+1])++n;
        len[0]=0,len[1]=-1,fail[0]=1,fail[1]=1,cnt=1,pos[0]=1;
        for(int i=0;i<26;++i)tr[0][i]=tr[1][i]=0;
        e[0]=1;for(int i=1;i<=n;++i)e[i]=e[i-1]*bs;
        f[0]=0;for(int i=1;i<=n;++i)f[i]=f[i-1]*bs+s[i];
        g[n+1]=0;for(int i=n;i>=1;--i)g[i]=g[i+1]*bs+s[i];
        mp.clear();
        for(int i=1;i<=n;++i)insert(i,s[i]);
        for(int i=0;i<=cnt;++i)sum[i]=0;
        for(int i=1;i<=n;++i){
            l=0;r=min(i-1,n-i);
            while(l<r){
                mid=(l+r+1)>>1;
                if(f[i-1]-f[i-1-mid]*e[mid]==g[i+1]-g[i+1+mid]*e[mid])l=mid;
                else r=mid-1;
            }
            sum[mp[f[i+l]-f[i-l-1]*e[l<<1|1]]]^=(i-1);
            l=0;r=min(i,n-i);
            while(l<r){
                mid=(l+r+1)>>1;
                if(f[i]-f[i-mid]*e[mid]==g[i+1]-g[i+1+mid]*e[mid])l=mid;
                else r=mid-1;
            }
            if(l)sum[mp[f[i+l]-f[i-l]*e[l<<1]]]^=(i-1);
        }
        ans=0;dfs(0);dfs(1);
        printf("%d\n",ans);
    }
    return 0;
}
```

---


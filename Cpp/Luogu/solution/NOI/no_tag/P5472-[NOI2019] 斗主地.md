# [NOI2019] 斗主地

## 题目背景

时限 4 秒 内存 512MB

## 题目描述

小 S 在和小 F 玩一个叫“斗地主”的游戏。

可怜的小 S 发现自己打牌并打不过小 F，所以他想要在洗牌环节动动手脚。

一副牌一共有 $n$ 张牌，从上到下依次标号为 $1 \sim n$。标号为 $i$ 的牌**分数**是 $f(i)$。在本题，$f(i)$ 有且仅有两种可能：$f(i) = i$ 或 $f(i) = i^2$。

洗牌的方式和我们日常生活中的比较类似，以下我们用形式化的语言来定义： 洗牌环节一共分 $m$ 轮，这 $m$ 轮洗牌依次进行。第 $i$ 轮洗牌时：

1. 小 S 会拿出从最上面往下数的前 $A_i$ 张牌。这样这副牌就被分成了两堆：第一堆 是最上面的 $A_i$ 张牌，第二堆是剩下的 $n-A_i$ 张牌，且这两堆牌内相对顺序不变。 特别地，当$A_i = n$ 或 $A_i = 0$ 时，有一堆牌是空的。
2. 接下来对两堆牌进行合并，从而产生新的第三堆牌。当第一堆牌还剩下 $X$ 张，第二堆牌还剩下 $Y$ 张的时候，以 $\dfrac{X}{X+Y}$ 的概率取出第一堆牌的最下面的牌，并将它 放入新的第三堆牌的最上面， $\dfrac{Y}{X+Y}$  的概率取出第二堆牌的最下面的牌，并将它放入新的第三堆牌的最上面
3. 重复操作 $2$，一直取到两堆牌都为空为止。这样我们就完成了一轮洗牌。

因为洗牌过程是随机的，所以小 S 发现自己没法知道某个位置上具体是哪张牌。但小 S 想问你在经历了这 $m$ 轮洗牌后，某个位置上的牌的**期望分数**是多少。小 S 一共会问你 $Q$ 个这样的问题。

## 说明/提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见附加文件中的 `landlords/landlords2.in` 与 `landlords/landlords2.ans`。

#### 样例 3

见附加文件中的 `landlords/landlords3.in` 与 `landlords/landlords3.ans`。

### 样例输入输出 1 解释

- 有 $\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\{1, 2, 3, 4\}$。
- 有 $\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\{1, 2, 4, 3\}$。
- 有 $\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\{1, 4, 2, 3\}$。
- 有 $\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\{4, 1, 2, 3\}$。

所以最终有 $\dfrac{1}{4}$ 的概率第一个位置是 $4$，有 $\dfrac{3}
{4}$ 的概率第一个位置是 $1$，所以第一个位置的期望分数是 $\dfrac{7}{
4}$。

为了帮助你们更直观地了解洗牌的过程，我们在下面画出了结果是 $\{1, 4, 2, 3\}$ 的过程。

![](https://cdn.luogu.com.cn/upload/pic/64318.png)

### 数据规模与约定

对于全部的测试点，保证 $3\le n \le 10^7$，$1\le m,Q\le5\times 10^5$，$0\le A_i\le n$，$type\in \{1,2\}$。

每个测试点的具体限制见下表：

| 测试点 | $n$ | $m$ | $type=$ | 其他性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $\le 10$ | $\le 1$ | $1$ | 无 |
| $2$ | $\le 80$ | $\le 80$ | $1$ | 无 |
| $3$ | $\le 80$ | $\le 80$ | $2$ | 无 |
| $4$ | $\le 100$ | $\le 5\times 10^5$ | $2$ | 所有 $A_i$ 相同 |
| $5$ | $\le 10^7$ | $\le 5\times 10^5$ | $1$ | 无 |
| $6$ | $\le 10^7$ | $\le 5\times 10^5$ | $1$ | 无 |
| $7$ | $\le 10^7$ | $\le 5\times 10^5$ | $1$ | 无 |
| $8$ | $\le 10^7$ | $\le 5\times 10^5$ | $2$ |无  |
| $9$ | $\le 10^7$ | $\le 5\times 10^5$ | $2$ | 无 |
| $10$ | $\le 10^7$ | $\le 5\times 10^5$ | $2$  | 无 |

请注意我们并没有保证 $Q\le n$。

### 提示

这里我们给出离散型随机变量 $X$ 的期望 $\mathbb{E}[x]$ 的定义：

设离散随机变量 $X$ 的可能值是 $X_1,X_2,\ldots X_k$，$Pr[X_1],Pr[X_2],\ldots,Pr[X_k]$ 为 $X$ 取对应值的概率，则 $X$ 的期望为：
$$\mathbb{E}[x]=\sum^k_{i=1}X_i\times Pr[X_i]$$



## 样例 #1

### 输入

```
4 1 1
3
1
1```

### 输出

```
249561090
```

# 题解

## 作者：ljc1301 (赞：39)

这是个结论题……而且结论还很好猜……

可以观察，$n$那么大，而刚开始只有$f(i)=i$和$f(i)=i^2$，可以猜一个结论：

#### 一次函数洗牌之后的期望还是一次函数，二次函数洗牌之后的期望还是二次函数。

而洗牌两次后的期望，和用洗牌一次后的期望作为权值，再洗第二次牌得到的期望，结果应该是一样的。这个很好证，因为期望是线性可加的，而每次洗牌后，一个特定位置上的值，是每个位置原来的权值乘以特定的常数（这个常数在下面的证明过程中有推导）相加，只涉及到一些变量期望的线性相加，所以是可以的。注意，这点虽然比较显然，但有些时候不一定是对的，所以这种东西还要先思考一下。

那前面这个结论是不是对的呢？可以写个这样的程序试试，测一下样例，对拍一下，好像还真是这样。那不是就做完了吗？具体做法：每一次选三个好算的算出来，然后把二次函数给算出来（可以待定系数解方程，也可以直接拉格朗日插值），不就可以了吗？选的时候可以选最开始的三个（这样可以二阶差分），也可以选前两个加最后一个，因为这个洗牌的过程可以想成在第一堆和第二堆中任选一个放到牌堆顶，也就是随机打乱（这个在证明2中有说明），然后，把第一堆的拿出来安原来的顺序排好，把第二堆按原来的顺序排好。这样就会发现算最后一个和算第一个是一样好算的。

记第$i$个数是$x_i$，洗牌后第一个数的期望$x_i'=\frac Anx_1+\frac{n-A}nx_{A+1}$，最后一个数的期望$x_n'=\frac Anx_A+\frac{n-A}nx_n$（有$\frac An$的概率是抽到第一堆，$\frac{n-A}n$的概率是抽到第二堆，而且肯定是最后一个），第二个数的期望$x_2'=\frac An(\frac{A-1}{n-1}x_2+\frac{n-A}{n-1}x_{A+1})+\frac{n-A}n(\frac A{n-1}x_1+\frac{n-A-1}{n-1}x_{A+2})$，前者是对应第一个抽到的是第一堆，后者是对应第一个抽到的是第二堆。

这就可以愉快地把这题A了。代码在最后（代码1）。

当然有个非常关键的问题，这个结论为什么是对的？

### 证明1

我们证明这样一个东西：一个序列$\{a_i\}$（等一下，上面是$x$怎么就变$a$了……~~懒得改了~~）满足$a_i=f(i)$，其中$f(i)$为多项式，则对于洗牌后的序列$\{a_i'\}$，存在一个多项式$f'(i)$使得$a_i'=f'(i)$且$\deg f\geqslant\deg g$，这样就能保证选$\deg f+1$个数插值后的结果就是$f'$。为了方便，记$\deg f=m$。

**大量公式警告**

我们先要知道转移式。考虑$a_j\ (j\leqslant A)$对$a_i'$的贡献，即$a_j$乘以洗牌后第$i$张是原先的第$j$张得概率。考虑某一种情况的概率大概长这样（某一特殊但平凡的情况）：$\frac An\cdot\frac {A-1}{n-1}\cdot\frac {n-A}{n-2}\cdot\cdots\cdot\frac{A-j+1}{n-i+2}\cdot\frac{n-A-i+j+1}{n-i+1}$。观察发现虽然每个分数都没什么规律，每次乘的分数也不是固定的，但是容易发现分子是$A^\frac{j}{}(n-A)^\frac{i-j}{}$，分母是$n^\frac{i}{}$。而$a_i'$前面有$i-1$个数，当中有$j-1$的数是第一堆的，所以要再乘一个$\binom{i-1}{j-1}$。$j>A$时同理。

那么就有
$$a_i'=\sum_{j=1}^Aa_j\dbinom{i-1}{j-1}A^\frac{j}{}(n-A)^\frac{i-j}{}\frac1{n^\frac i{}}+\sum_{j=1}^{n-A}a_{A+j}\dbinom{i-1}{j-1}A^\frac{i-j}{}(n-A)^\frac j{}\frac1{n^\frac{i}{}}$$
其实前后两个式子形式上还是没什么区别，我们就先看前一部分。化简它。
$$\begin{aligned}&\sum_{j=1}^Aa_j\dbinom{i-1}{j-1}A^\frac{j}{}(n-A)^\frac{i-j}{}\frac1{n^\frac i{}}\\=&\sum_{j=1}^Aa_j\dbinom{i-1}{j-1}\frac{A!}{(A-j)!}\cdot\frac{(n-A)!}{(n-A-i+j)!}\cdot\frac{(n-i)!}{n!}\\=&\sum_{j=1}^Aa_j\dbinom{i-1}{j-1}\frac{(n-i)!}{(A-j)!(n-A-i+j)!}\cdot\frac{A!(n-A)!}{n!}\\=&\frac{A!(n-A)!}{n!}\sum_{j=1}^Aa_j\dbinom{i-1}{j-1}\frac{(n-i)!}{(A-j)!(n-A-i+j)!}\\=&\frac1{\dbinom nA}\sum_{j=1}^Aa_j\dbinom{i-1}{j-1}\dbinom{n-i}{A-j}\end{aligned}$$
好像化简不了了……但我们好像忘了一个条件？$a_i$可以表示成至多$m$次（本题$m\leqslant2$）的多项式！这又有什么用呢？

注意到，这里的转移，都是某个位置的数。乘上一个和这个数无关的常数，也就是说，它是线性的，就是将输入的一些数据线性相加（即乘一个常数后相加）的结果，和原先这些输入后分别得到的结果，进行相同的线性相加，得到的结果是一样的（这也不难验证）。若对于所有小于$m$次的多项式$f(x)$都可以表示成$\sum_{k=0}^mc_kf_k(x)$，其中$c_k$为常数，$f_k$是次数为$k$的多项式，我们就只需要证明当$a_i=f_k(i)$时，$a_i'$可以被表示成至多$k$次的多项式即可。

现在，只需要找到一个便于我们证明的$f_k$即可。首先想到的可能是$f_i(x)=x^i$，但这里的系数都是阶乘和二项式，所以更应该尝试下降幂（我们知道$m$次下降幂多项式可以和$m$次多项式一一对应），尝试后发现好像$f_k(x)=(x-1)^\frac k{}$最方便（可能一个理由是下标从$0$开始更自然？~~我随便说的。~~），而且我们知道，一个任意的$m$次多项式，总是可以被表示成$m$次的下降幂多项式。那么将$a_j=(j-1)^\frac k{}$带入并来一些操作得：
$$\begin{aligned}&\frac1{\dbinom nA}\sum_{j=1}^Aa_j\dbinom{i-1}{j-1}\dbinom{n-i}{A-j}\\=&\frac1{\dbinom nA}\sum_{j=1}^A(j-1)^\frac k{}\dbinom{i-1}{j-1}\dbinom{n-i}{A-j}\\=&\frac1{\dbinom nA}\sum_{j=1}^A\frac{(j-1)!}{(j-1-k)!}\cdot\frac{k!}{k!}\cdot\dbinom{i-1}{j-1}\dbinom{n-i}{A-j}\\=&\frac1{\dbinom nA}\sum_{j=1}^Ak!\dbinom{j-1}{k}\dbinom{i-1}{j-1}\dbinom{n-i}{A-j}\\=&\frac{k!}{\dbinom nA}\sum_{j=1}^A\dbinom{j-1}{k}\dbinom{i-1}{j-1}\dbinom{n-i}{A-j}\end{aligned}$$
而二项式当中有个东西：
$$\begin{aligned}\dbinom ab\dbinom ca&=\frac{a!}{b!(a-b)!}\cdot\frac{c!}{a!(c-a)!}\\&=\frac{c!}{b!(c-b)!}\cdot\frac{(c-b)!}{(a-b)!(c-a)!}\\&=\dbinom cb\dbinom{c-b}{a-b}\end{aligned}$$
所以令$j-1=a,\ k=b,\ i-1=c$，则有
$$\begin{aligned}&\frac{k!}{\dbinom nA}\sum_{j=1}^A\dbinom{j-1}k\dbinom{i-1}{j-1}\dbinom{n-i}{A-j}\\=&\frac{k!}{\dbinom nA}\sum_{j=1}^A\dbinom{i-1}k\dbinom{i-1-k}{j-1-k}\dbinom{n-i}{A-j}\\=&\frac{k!}{\dbinom nA}\dbinom{i-1}k\sum_{j=1}^A\dbinom{i-1-k}{j-1-k}\dbinom{n-i}{A-j}\\=&\frac{k!}{\dbinom nA}\dbinom{i-1}k\sum_j\dbinom{i-1-k}{j-1-k}\dbinom{n-i}{A-j}\\=&\frac{k!}{\dbinom nA}\dbinom{i-1}k\sum_j\dbinom{i-1-k}j\dbinom{n-i}{A-j-1-k}\end{aligned}$$
（倒数第二行可以把限制去掉因为显然$j-1-k\geqslant0,\ j\leqslant A$，即$A\geqslant j\geqslant1+k\geqslant1$时后一串不为0。最后一行是把$j$用$j+1+k$代替。）我们又提出了一项！继续。二项式当中还有一个东西：
$$\sum_j\dbinom nj\dbinom m{k-j}=\dbinom{n+m}k$$
这个式子为什么是对的呢？考虑组合意义。设有$n$个红球，$m$个蓝球，左式为对于每个$j$，当红球取$j$个，蓝球取$k-j$个的方案数之和，相当于总共$n+m$个球中取$k$个球的方案数，即为右式。

令$i-1-k=n,\ n-i=m,\ A-1-k=k$（这里右式的$n,m,k$为上式中的），继续：
$$\begin{aligned}&\frac{k!}{\dbinom nA}\dbinom{i-1}k\sum_j\dbinom{i-1-k}j\dbinom{n-i}{A-j-1-k}\\=&\frac{k!}{\dbinom nA}\dbinom{i-1}k\dbinom{i-1-k+n-i}{A-1-k}\\=&\frac{k!}{\dbinom nA}\dbinom{i-1}k\dbinom{n-k-1}{A-k-1}\end{aligned}$$
我们把和式打开了！继续稍微化简一下：
$$\begin{aligned}&\frac{k!}{\dbinom nA}\dbinom{i-1}k\dbinom{n-k-1}{A-k-1}\\=&k!\frac{(i-1)!}{k!(i-1-k)!}\cdot\frac{\dbinom{n-k-1}{A-k-1}}{\dbinom nA}\\=&\frac{(i-1)!}{(i-1-k)!}\cdot\frac{\dbinom{n-k-1}{A-k-1}}{\dbinom nA}\\=&(i-1)^\frac k{}\cdot\frac{\dbinom{n-k-1}{A-k-1}}{\dbinom nA}\end{aligned}$$
搞出来了！？也就是说当$a_i=(i-1)^\frac k{}$时，$a_i'$的一部分是$\begin{aligned}(i-1)^\frac k{}\cdot\frac{\binom{n-k-1}{A-k-1}}{\binom nA}\end{aligned}$ ，也是$k$次的下降幂。结合前面的说明，可得当$a_i$是$m$次多项式时，$a_i'$的这一部分也是不多于$m$次的多项式。

而另一部分呢？（虽然同理但还有一些差别。）设$b_i=a_{A+i}$，比较一下式子，当$b_i=(i-1)^\frac k{}$时，还是有$a_i'$的另一部分是$\begin{aligned}(i-1)^\frac k{}\cdot\frac{\binom{n-k-1}{n-A-k-1}}{\binom n{n-A}}\end{aligned}$（其实下面分母也是$\begin{aligned}\binom nA\end{aligned}$），所以$a_i'$就是至多$m$次的多项式。 证毕。

当然，有了这个式子也可以写一份代码，就是每次记录下降幂多项式的系数（初始条件可能要手算一下），然后可以直接转移，每一项按照这个式子给出的，乘上一个系数，就不用插值了。当然要注意，要将$a_i$的多项式平移后才是$b_i$（设$a_i=f(i)$，则$b_i=a_{A+i}=f(A+i)$。这个平移可能又要手算一下）。可以参考代码2（如果懒得手算就参考一下代码里的那些系数）。

这个证明算是比较完整了，但好像还有点问题，最后这个式子好像有点过于简单？有没有更好的证明方法？

### 证明2

为了方便起见，根据我们上面的讨论，我们只要证明：一堆牌有$A$张，其中$a_i=(i-1)^\frac k{}\ (1\leqslant i\leqslant A)$；另一堆牌有$n-A$张，其中所有牌的数都为$0$，则洗完牌后每张的期望为$\begin{aligned}a_i'=(i-1)^\frac k{}\cdot\frac{\binom{n-k-1}{A-k-1}}{\binom nA}\end{aligned}\ (1\leqslant i\leqslant n)$。（因为前面说的“一部分”其实就是第一堆对答案的贡献，而我们这里直接把第二堆的贡献省略，下面也不讨论第二堆的贡献，因为就是$0$）。

那么，因为这个洗牌的过程是线性的，我们可以所有的权值都缩小到原来的$\frac1{k!}$，我们知道$\begin{aligned}\frac{(i-1)^\frac k{}}{k!}=\frac{(i-1)!}{k!(i-1-k)!}=\binom{i-1}{k}\end{aligned}$，则我们只需要证明当$\begin{aligned}a_i=\binom{i-1}k\end{aligned}$时，$\begin{aligned}a_i'=\frac{\binom{i-1}k\binom{n-k-1}{A-k-1}}{\binom nA}\end{aligned}$即可。

我们先证明一个前面提到过的结论（这里写得清晰一些）：这样的洗牌相当于，把所有的混在一起，然后把每一堆中的元素，按在原来堆中的顺序，在新堆中排好。可能有点抽象，举个例子：

为了方便讨论，这里和下面都用颜色代表所属的堆。假设两堆牌是$\color{red}1,\color{red}2,\color{red}3$和$\color{blue}4,\color{blue}5,\color{blue}6$，那么随机打乱后有可能是这样的：$\color{red}2,\color{red}1,\color{blue}5,\color{blue}4,\color{red}3,\color{blue}6$，然后$\color{red}2,\color{red}1,\color{red}3$排成$\color{red}1,\color{red}2,\color{red}3$，$\color{blue}5,\color{blue}4,\color{blue}6$排成$\color{blue}4,\color{blue}5,\color{blue}6$，然后按$\color{red}2,\color{red}1,\color{blue}5,\color{blue}4,\color{red}3,\color{blue}6$的颜色插回去变成$\color{red}1,\color{red}2,\color{blue}4,\color{blue}5,\color{red}3,\color{blue}6$。差不多就是这个意思。

证明的话考虑洗牌的过程，我们不考虑每一张牌具体是哪一张，而只考虑颜色，有$\frac X{X+Y}$的概率抽到红色，而红色有$X$张，所以抽到红色的特定一张的概率是$\frac X{X+Y}\cdot\frac1X=\frac1{X+Y}$，蓝色同理，而剩下牌的数量刚好是$X+Y$，就相当于，每一次都随机摸一张牌。这不就和随机打乱一样了吗。而洗牌前后相对位置不变，所以我们确定了颜色之后，就可以确定每一张牌的数。这个性质可以当结论记一下。

有了这个很好的性质，该怎么用呢？

先考虑有多少种情况，显然，根据颜色打乱后有$\begin{aligned}\binom nA\end{aligned}$中等概率的情况，我们只要算出所有情况下$a_j'$的和，先看一下$a_i$对$a_j'$的贡献。

因为$\begin{aligned}a_i=\binom{i-1}k\end{aligned}$，我们把它看成，在$1$到$i-1$中，把其中$k$个做上标记的方案数。考虑对$a_j'$的贡献时，要把$a_i$强行放到$a_j'$上，此时（洗牌后的排队中）$1$到$j-1$还要再选$i-1$个红的，后面$j+1$到$n$中还要选$A-i$个红的，然后统计方案数，而$\begin{aligned}a_i=\binom{i-1}k\end{aligned}$，所以它的贡献还要再乘上$a_i$，也就是相当于再在$1$到$j-1$中的$i-1$个红的，还要再选$k$个做标记，贡献其实是这样一个方案数。理一下，其实就是相当于在$1$到$j-1$中，有$k$个做了标记，还有$i-k-1$个红的，而在$j+1$到$n$中，有$A-i$个红的。

当我们考虑整个的贡献时，因为$1\leqslant i\leqslant A$，所以在$j$前后可以有所有情况的红色的个数，所以相当于在$1$到$j-1$中标记$k$个，在剩下没有标记且不是$j$的位子上（一共有$n-k-1$个位置），选$A-k-1$个红的，所以总的和是$\begin{aligned}\binom{j-1}k\binom{n-k-1}{A-k-1}\end{aligned}$。

而我们知道总的情况数是$\begin{aligned}\binom nA\end{aligned}$，所以$\begin{aligned}a_j'=\frac{\binom{j-1}k\binom{n-k-1}{A-k-1}}{\binom nA}\end{aligned}$，和前面我们要证明的式子一模一样！

所以我们用了一个非常巧妙的方法证出来了，我觉得这个证明方法还是非常神奇的（我想了好久）。

------

好了，说了这么多，可以上代码了。

#### 代码1：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int kcz=998244353;
const int maxn=10000005;
ll a,b,c,f[maxn];
int n;
inline ll qpow(ll a,ll k)
{
    ll res=1;
    while(k)
    {
        if(k&1) res=res*a%kcz;
        if(k>>=1) a=a*a%kcz;
    }
    return res;
}
inline ll calc(ll x) { return ((a*x+b)%kcz*x+c)%kcz; } // 算第x个数的期望
int main()
{
    int m,tp,i;
    ll _,__,t1,t2,t3,t,___,sqn;
    freopen("landlords.in","r",stdin),freopen("landlords.out","w",stdout);
    scanf("%d%d%d",&n,&m,&tp),sqn=n*(ll)n%kcz;
    _=qpow(n-1,kcz-2),__=qpow(n,kcz-2),___=qpow((-sqn+3*n-2)%kcz,kcz-2);
    if(tp==1) a=c=0,b=1;
    else a=1,b=c=0; // x_i=ai^2+bi+c
    while(m--)
    {
        scanf("%lld",&t);
        if(t==0 || t==n) continue;
        t1=(calc(1)*t+calc(t+1)*(n-t))%kcz*__%kcz; // 第一个
        t2=((calc(2)*(t-1)+calc(t+1)*(n-t))%kcz*t+(calc(1)*t+calc(t+2)*(n-t-1))%kcz*(n-t))%kcz*__%kcz*_%kcz; // 第二个
        t3=(calc(t)*t+calc(n)*(n-t))%kcz*__%kcz; // 第n个
        a=((2-n)*t1+(n-1)*t2-t3)%kcz*___%kcz;
        b=((sqn-4)*t1+(1-sqn)*t2+3*t3)%kcz*___%kcz;
        c=((4*n-2*sqn)*t1+(sqn-n)*t2-2*t3)%kcz*___%kcz; // 极其丑的差值
    }
    for(i=1;i<=n;i++)
        f[i]=(calc(i)+kcz)%kcz;
    scanf("%d",&m);
    while(m--)
        scanf("%lld",&t),printf("%lld\n",f[t]);
    fclose(stdin),fclose(stdout);
    return 0;
}
```

#### 代码2：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int kcz=998244353;
const int maxn=10000005;
ll a,b,c,a_,b_,c_,fac[maxn],inv[maxn],inv_fac[maxn];
int n;
inline ll f(ll x) { return (a+b*(x-1)+c*(x-1)%kcz*(x-2))%kcz; } // 算第x个数的期望
inline ll C(int n,int m) { return (m>=0 && m<=n)?fac[n]*inv_fac[m]%kcz*inv_fac[n-m]%kcz:0; } // 判一下0的情况
inline ll invC(int n,int m) { return inv_fac[n]*fac[m]%kcz*fac[n-m]%kcz; }
int main()
{
    int i,q,op,A;
    ll t;
    freopen("landlords.in","r",stdin),freopen("landlords.out","w",stdout);
    scanf("%d%d%d",&n,&q,&op);
    if(op==1) a=b=1,c=0; // a_i=a+b*(i-1)+c*(i-1)*(i-2)
    else a=1,b=3,c=1;
    fac[0]=inv_fac[0]=inv[1]=fac[1]=inv_fac[1]=1;
    for(i=2;i<=n;i++)
    {
        fac[i]=fac[i-1]*i%kcz;
        inv[i]=-(kcz/i)*inv[kcz%i]%kcz;
        inv_fac[i]=inv_fac[i-1]*inv[i]%kcz;
    }
    while(q--)
    {
        scanf("%d",&A);
        a_=(a+b*A+c*A%kcz*(A-1ll))%kcz; // 平移x->x+A
        b_=(b+c*2*A)%kcz;
        c_=c;
        t=invC(n,A);
        a=(a*C(n-1,A-1)+a_*C(n-1,n-A-1))%kcz*t%kcz; // 更新系数
        b=(b*C(n-2,A-2)+b_*C(n-2,n-A-2))%kcz*t%kcz;
        c=(c*C(n-3,A-3)+c_*C(n-3,n-A-3))%kcz*t%kcz;
    }
    scanf("%d",&q);
    while(q--)
        scanf("%d",&i),printf("%lld\n",(f(i)+kcz)%kcz);
    fclose(stdin),fclose(stdout);
    return 0;
}
```

---

## 作者：Owen_codeisking (赞：25)

那我们先来看看部分分吧。

### 算法 $1$：暴搜

期望得分 $10pts$

### 算法 $2$：$dp$

$f[i][j]$ 为左边 $i$ 张牌，右边 $j$ 张牌的概率。

然后我们在转移 $f[i][j]$ 时顺便算算期望就行了，期望得分 $30pts$

```cpp
for(int i=1;i<=m;i++)
{
    memset(f,0,sizeof(f));
    memset(h,0,sizeof(h));
    f[a[i]][n-a[i]]=1;
    for(int j=1;j<=a[i];j++) l[j]=g[j];
    for(int j=1;j<=n-a[i];j++) r[j]=g[j+a[i]];
    for(int j=a[i];j>=0;j--)
        for(int k=n-a[i];k>=0;k--)
        {
            if(!f[j][k]) continue;
            if(j>0)
            {
                ll tmp=f[j][k]*j%mod*inv(j+k)%mod;
                (f[j-1][k]+=tmp)%=mod;
                (h[n-j-k+1]+=tmp*l[j])%=mod;
            }
            if(k>0)
            {
                ll tmp=f[j][k]*k%mod*inv(j+k)%mod;
                (f[j][k-1]+=tmp)%=mod;
                (h[n-j-k+1]+=tmp*r[k])%=mod;
            }
        }
    for(int j=1;j<=n;j++) g[j]=h[n-j+1];
}
```

### 算法 $3$：当 $a_i$ 全相等，矩阵快速幂

把 $dp$ 的形式转成矩阵，暴力倍增。配合算法 $3$，期望得分 $40pts$

### 算法 $4$：猜结论

你要知道，这道题猜个结论就 AC 了。

~~虽然我也不会证~~

因为这个分数非常特殊，我们可以猜：

**一次函数洗牌后的期望是一次函数，二次函数洗牌后的期望是二次函数。**

考后我复制了一个多项式插值的板子，验证一下，发现这个结论是正确的。

然后你会发现你用算法 $2$，把前三项搞出来对二次函数求个 A,B,C 就行了……

$$A+B+C\equiv X(\text{mod}\ 998244353)$$

$$3A+2B+C\equiv Y(\text{mod}\ 998244353)$$

$$9A+3B+C\equiv Z(\text{mod}\ 998244353)$$

推出：

$$A\equiv \frac {Z-2Y+X}{2}(\text{mod}\ 998244353)$$

$$B\equiv \frac {8Y-5X-3Z}{2}(\text{mod}\ 998244353)$$

$$C\equiv 3X-3Y+Z(\text{mod}\ 998244353)$$

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=500000+10;
const int maxm=10000000+10;
const int mod=998244353;
const int inv2=(mod+1)>>1;
int n,m,q,type;ll A,B,C,f[10][10],g[10],h[10],w[10],inv[maxm];

inline ll F(int x) {return (A*x%mod*x+B*x+C)%mod;}

int main()
{
    scanf("%d%d%d",&n,&m,&type);
    inv[0]=inv[1]=1;
    for(int i=2;i<=n;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
    if(type==1) A=0,B=1,C=0;
    else A=1,B=0,C=0;
    int tmp;ll X,Y,Z;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&tmp);
        for(int j=1;j<=3;j++) g[j]=F(j),h[j]=F(j+tmp),w[j]=0;
        for(int j=0;j<3;j++)
            for(int k=0;k<3;k++) f[j][k]=0;
        f[0][0]=1;
        for(int j=0;j<3;j++)
            for(int k=0;k<3;k++)
            {
                if(j+k>=3) break;
                if(j<tmp)
                {
                    ll val=f[j][k]*(tmp-j)%mod*inv[n-j-k]%mod;
                    (f[j+1][k]+=val)%=mod;
                    (w[j+k+1]+=val*g[j+1])%=mod;
                }
                if(k<n-tmp)
                {
                    ll val=f[j][k]*(n-tmp-k)%mod*inv[n-j-k]%mod;
                    (f[j][k+1]+=val)%=mod;
                    (w[j+k+1]+=val*h[k+1])%=mod;
                }
            }
        X=w[1];Y=w[2];Z=w[3];
        A=((Z-2*Y+X)*inv2%mod+mod)%mod;
        B=((8*Y-5*X-3*Z)*inv2%mod+mod)%mod;
        C=((3*X-3*Y+Z)%mod+mod)%mod;
    }
    scanf("%d",&q);
    while(q--)
    {
        scanf("%d",&tmp);
        printf("%lld\n",F(tmp));
    }
    return 0;
}
```

总结：这个故事告诉我们，有些时候要大力猜结论，小心验证。

---

## 作者：AC_Evil (赞：12)

假设左边 $L$ 张牌右边 $R$ 张牌，总共 $N=L+R$ 张。

左边从上往下第 $x$ 张牌对合并过后从上往下第 $i$ 个位置产生贡献（要满足 $i\in[x,x+R]$）

$${i-1\choose x-1}{N-i\choose L-x}w_x$$

对某个位置求期望权值，就把 $i$ 看成常数，先对左边所有的 $x$ 求和。默认 $x$ 在合法范围。请注意这里往下为了方便没有除以 ${n\choose L}$。

$$\sum_{x}{i-1\choose x-1}{N-i\choose L-x}w_x$$

考虑当 $w_x=x$ 时，变成

$$\sum_{x}{i-1\choose x-1}{N-i\choose L-x}x$$

考虑消去 $x$

$$
\begin{aligned}
&\sum_x{i-1\choose x-1}{N-i\choose L-x}x\\
=&\sum_x\left({i\choose x}-{i-1\choose x}\right){N-i\choose L-x}x\\
=&\sum_x\left(i{i-1\choose x-1}-(i-1){i-2\choose x-1}\right){N-i\choose L-x}
\end{aligned}
$$

发现 $x$ 消掉了，剩下的很容易根据 **范德蒙恒等式** 得到结果为

$$\left\{{N-1\choose L-1}-{N-2\choose L-1}\right\}i+{n-2\choose L-1}$$

我们发现一个先前关于位置的一次式（$x$）在一轮操作后得到的仍然是关于位置的一次式（变成了 $i$）！这启迪我们去维护一个类似多项式的系数。

反复通过上面的方法，利用组合递推式凑出来 $x$ 约分，一轮推导后我们得到下列三大关系：

$$1\rightarrow{n-1\choose L-1}$$

$$i\rightarrow\left\{{n-1\choose L-1}-{n-2\choose L-1}\right\}i+{n-2\choose L-1}$$

$$i^2\rightarrow\left\{{n-1\choose L-1}-2{n-2\choose L-1}+{n-3\choose L-1}\right\}i^2+3\left\{{n-2\choose L-1}-{n-3\choose L-1}\right\}i+\left\{{n-2\choose L-1}-2{n-3\choose L-1}\right\}$$

对于 $R$ 由对称性，同理。同理？

不完全一致！注意到分完左边的牌以后，右边牌最小编号 $r_{min}=L+1$ 可能 $>1$，而我们的 $i$ 从 $1$ 开始求和。我们为了从 $L+1$ 开始求和，强制让 $i\rightarrow i+L$，展开式子计算系数

$$ai^2+bi+c\rightarrow a(i+L)^2+b(i+L)+c=ai^2+(2aL+b)i+(aL^2+bL+c)$$

这样我们仍然能够套用前面的变换了。最终复杂度 $\mathcal O(n+md^2+Q)$，$d$ 表示最高次数 $+1$，这里是 $3$。每轮别忘了除掉 ${n\choose L}$。

```cpp
#include <bits/stdc++.h>
const int N = 10000007, P = 998244353;
int n, m, Q, type, fac[N], ifac[N], inv[N];
int C(int n, int m) {
	if (m < 0 || m > n) return 0;
	return 1LL * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
int qpow(int a, int b) {
	int t = 1;
	for (; b; b >>= 1, a = 1LL * a * a % P)
		if (b & 1) t = 1LL * t * a % P;
	return t;
}
struct Node {
	int a, b, c;
	Node(int a, int b, int c) : a(a), b(b), c(c) {};
};
int main() {
	scanf("%d%d%d", &n, &m, &type);
	inv[1] = fac[0] = ifac[0] = 1;
	for (int i = 2; i <= n; i++)
		inv[i] = 1LL * (P - P / i) * inv[P % i] % P;
	for (int i = 1; i <= n; i++)
		fac[i] = 1LL * fac[i - 1] * i % P, ifac[i] = 1LL * ifac[i - 1] * inv[i] % P;
	Node res = Node(0, type == 1, type == 2);
	for (int i = 1; i <= m; i++) {
		int L, R; scanf("%d", &L); R = n - L;
		Node tmpl = res, tmpr = Node((1LL * res.c * L % P * L + 1LL * res.b * L + res.a) % P, (2LL * res.c * L + res.b) % P, res.c);
		res.a = (1LL * tmpl.a * C(n - 1, L - 1) % P + 1LL * tmpl.b * C(n - 2, L - 1) % P + 1LL * tmpl.c * ((C(n - 2, L - 1) - 2LL * C(n - 3, L - 1)) % P + P) % P
			   + 1LL * tmpr.a * C(n - 1, R - 1) % P + 1LL * tmpr.b * C(n - 2, R - 1) % P + 1LL * tmpr.c * ((C(n - 2, R - 1) - 2LL * C(n - 3, R - 1)) % P + P) % P) % P;
		res.b = (1LL * tmpl.b * (C(n - 1, L - 1) - C(n - 2, L - 1) + P) % P + 3LL * tmpl.c * (C(n - 2, L - 1) - C(n - 3, L - 1) + P) % P
			   + 1LL * tmpr.b * (C(n - 1, R - 1) - C(n - 2, R - 1) + P) % P + 3LL * tmpr.c * (C(n - 2, R - 1) - C(n - 3, R - 1) + P) % P) % P;
		res.c = (1LL * tmpl.c * ((C(n - 1, L - 1) - 2LL * C(n - 2, L - 1) + C(n - 3, L - 1)) % P + P)
			   + 1LL * tmpr.c * ((C(n - 1, R - 1) - 2LL * C(n - 2, R - 1) + C(n - 3, R - 1)) % P + P)) % P;
		int Inv = qpow(C(n, L), P - 2);
		res.a = 1LL * res.a * Inv % P;
		res.b = 1LL * res.b * Inv % P;
		res.c = 1LL * res.c * Inv % P;
	}
	scanf("%d", &Q);
	while (Q--) {
		int c; scanf("%d", &c);
		printf("%lld\n", (1LL * c * c % P * res.c + 1LL * c * res.b + res.a) % P);
	}
	return 0;
}
```

---

## 作者：Thinking (赞：11)

## ~~既然百度的题解都是拉格朗日插值，我来写一个初中数学水平的~~

首先看到各次洗牌是无关的，所以可以一次次来

然后对于第一堆有$a$个，选到正数第$i$个，第二堆有$b$个，选到第$j$个，我们记这种情况发生的概率为$E_{a,b,i,j}$，不难看出新的$a_i'=\sum^A_{i=0}\sum^{n-A-i}_{j=0}\frac{i\times a_i+j\times a_{A+j}}{i+j}\times E_{A,n-A,i,j}$（若$i\le 0,i>A,j\le 0,j>n-A$则对应项为$0$）

那么这个$E_{a,b,i,j}$怎么求呢？如果我们先选到第一堆的$i$个，再选到第二堆的$j$个，则概率为$\frac{a\times (a-1)\times(a-2)\times\cdots\times(i+1)\times b\times (b-1)\times (b-2)\times\cdots\times(j+1)}{(a+b)\times (a+b-1)\times(a+b-2)\times\cdots\times(i+j+1)}$；若先选到第二堆的$j$个，再选到第一堆的$i$个，则概率为$\frac{b\times (b-1)\times (b-2)\times\cdots\times(j+1)\times a\times (a-1)\times(a-2)\times\cdots\times(i+1)}{(a+b)\times (a+b-1)\times(a+b-2)\times\cdots\times(i+j+1)}$。

**它们是一样的！**

对于其它情况，易知概率仍是一样的，均为$\frac{\frac{a!}{i!}\times\frac{b!}{j!}}{\frac{(a+b)!}{(i+j)!}}=\frac{a!\times b!\times (i+j)!}{(a+b)!\times i!\times j!}$，而很容易看出情况有$C^{a-i}_{a-i+b-j}=\frac{(a-i+b-j)!}{(a-i)!\times (b-j)!}$种，用~~人尽皆知的~~$O(n+log998244353)$[方法](https://www.luogu.org/problemnew/show/P5431)求出$i^{-1}$，$i!$和$(i!)^{-1}(mod998244353)$就可以$O(1)$求$E_{a,b,i,j}$，套上$dp$就是$O(mn^2)$的，拿到$30pts$，加上矩阵加速即可以拿到$40pts$。

$100pts$怎么拿呢？让我们观察样例里4个位置的期望分数：$\frac{7}{4},\frac{9}{4},\frac{11}{4},\frac{13}{4}$

**它们是等差数列！**

于是我们大胆猜想：$type=2$时答案是二阶等差数列，~~打表~~可证这个结论是正确的

由于等差数列可以看作特殊的二阶等差数列，所以只推出前3项就可以求出整个数列了，复杂度下降到$O(m)$，可以AC

可怎么求呢？dalao们都用拉格朗日插值，本蒟蒻提出一个小学方法：

设$d=a_2-a_1,d'=(a_3-a_2)-(a_2-a_1)=a_3+a_1-2a_2$，则根据$d'$为数列的二阶公差，则$a_2=a_1+d$，$a_3=a_1+d+(d+d')$，$a_4=a_1+d+(d+d')+(d+2d')$，……，$a_i=a_1+(i-1)d+[1+2+\cdots+(i-2)]d'=a_1+(i-1)d+\frac{(i-1)(i-2)}{2}d'$。

那么就可以愉快地上代码了~

```cpp
#include<cstdio>
typedef long long ll;
const int mod=998244353;
const int N=10000050;
char rB[1<<21],*S,*T,wB[1<<21];
int wp=-1;
inline char gc(){return S==T&&(T=(S=rB)+fread(rB,1,1<<21,stdin),S==T)?EOF:*S++;}
inline void flush(){fwrite(wB,1,wp+1,stdout);wp=-1;}
inline void pc(char c){if(wp+1==(1<<21))flush();wB[++wp]=c;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
short buf[15];
inline void wt(int x){
    short l=-1;
    while(x>9){
        buf[++l]=x%10;
        x/=10;
    }
    pc(x|48);
    while(l>=0)pc(buf[l--]|48);
    pc('\n');
}
int a[5],b[5],c[5],f[N],g[N],v[N],n;
void exgcd(int a,int b,int &x,int &y){
    if(!b){x=1;y=0;}
    else{
        exgcd(b,a%b,y,x);
        y-=a/b*x;
    }
}
inline int inv(int a){
    int x,y;
    exgcd(a,mod,x,y);
    return x<0?x+mod:x;
}
inline int E(int a,int b,int p,int q){  //算E
    return (ll)g[n]*f[p+q]%mod*f[a]%mod*g[p]%mod*f[b]%mod*g[q]%mod*f[n-p-q]%mod*g[a-p]%mod*g[b-q]%mod;
}
inline int val(int p){  //根据a1,a2,a3算ap
    if(p>n)return 0;
    int d=(a[2]-a[1]+mod)%mod,dd=((ll)a[3]+a[1]-(a[2]<<1)+(mod<<1))%mod;
    return (a[1]+(ll)d*(p-1)+(ll)dd*(p-1)%mod*(p-2)%mod*499122177)%mod;  //499122177是2的逆元
}
int main(){
    int m,q,type,i,j,A;
    n=rd();m=rd();type=rd();
    f[0]=g[0]=1;
    for(i=1;i<=n;++i)f[i]=(ll)f[i-1]*i%mod;
    v[n]=(ll)(g[n]=inv(f[n]))*f[n-1];
    for(i=n-1;i;--i)v[i]=(ll)(g[i]=(ll)g[i+1]*(i+1)%mod)*f[i-1];
    if(type==1){a[1]=1;a[2]=2;a[3]=3;}
    else{a[1]=1;a[2]=4;a[3]=9;}
    while(m--){
        A=rd();
        b[1]=a[1];b[2]=A>=2?a[2]:0;b[3]=A>=3?a[3]:0;
        c[1]=val(1+A);c[2]=val(2+A);c[3]=val(3+A);
//把a要用到的值分两堆存下来，a就可以被覆盖掉了
        a[1]=a[2]=a[3]=0;
        for(i=0;i<=3&&i<=A;++i)
            for(j=0;j<=3-i&&j<=n-A;++j)if(i+j)a[i+j]=(a[i+j]+((ll)i*b[i]+(ll)j*c[j])%mod*v[i+j]%mod*E(A,n-A,i,j))%mod;
//这里越界的b[0]和c[0]都是0，排除了情况i+j==0时没必要算
    }
    q=rd();
    while(q--){
        i=rd();
        wt(val(i));
    }
    flush();
    return 0;
}
```


---

## 作者：Sol1 (赞：8)

大概写一下思维历程。

- 首先肯定得从多项式复杂度做法开始优化。
- 哇这个随机方式是 smg 啊。

那就先研究一下这个随机方式到底在干什么。可以发现：**以题面给定的随机方式，一次随机后，所有可能出现的情况出现的概率都是相等的。**

---

证明：

将第一堆牌（共 $A$ 张）视为 $0$，将第二堆（共 $n-A$ 张）视为 $1$，那么任意结果都等价于一个 $0/1$ 序列。

而题目中描述的过程可以等价为从所有剩余元素里面等概率随机选取一个。

那么我们给每一个元素都赋一个编号，那么所有编号排列出现的概率都是相等的。而每一个 01 序列对应的编号排列个数也都是 $A!(n-A)!$，所以每一个 01 序列出现都是等概率的，所以任意结果都是等概率的。

---

有了这个结论，直接的想法就是概率 DP，设 $f_{i,j,k}$ 表示经过前 $i$ 次重排，原本在第 $j$ 个位置的元素被排到第 $k$ 位的概率。

转移就枚举上一次所在的位置 $l$，如果在前面一段，那么方案数就是 $\dbinom{k-1}{l-1}\dbinom{n-k}{A-l}$，意义是枚举 $l$ 前面的元素放在哪些位置以及后面的元素放在哪些位置。在后面一段是类似的，方案数为 $\dbinom{k-1}{l-A-1}\dbinom{n-k}{n-l}$。所以有转移：

$$f_{i,j,k}=\sum_{l=1}^{A_i}\dfrac{\binom{k-1}{l-1}\binom{n-k}{A_i-l}}{\binom{n}{A_i}}f_{i-1,j,l}+\sum_{l=A_i+1}^{n}\dfrac{\binom{k-1}{l-A_i-1}\binom{n-k}{n-l}}{\binom{n}{A_i}}f_{i-1,j,l}$$

由此可以得到 $O(mn^3)$ 的算法，获得 $30$ 分。在 $A_i$ 全都一样的时候可以改写成矩阵乘法，用倍增的套路稍微优化一下就可以 $O(n^3\log m)$，拼起来就有 $40$ 分。

考虑一下怎么优化。

---

- 有 $50$ 分满足 $f(i)=i$，这肯定得有点用啊。
- 但是直接拆成概率就啥都没用了，所以显然得先改写成期望的形式。

设 $f_{i,j}$ 表示经过前 $i$ 次打乱之后第 $j$ 个位置的期望分值。注意到在上面的概率 DP 中，整个算法的任何一步都没有把两个 $f$ 乘起来这种操作，所以转移可以直接照搬过来：

$$f_{i,j}=\sum_{l=1}^{A_i}\dfrac{\binom{j-1}{l-1}\binom{n-j}{A_i-l}}{\binom{n}{A_i}}f_{i-1,l}+\sum_{l=A_i+1}^{n}\dfrac{\binom{j-1}{l-A_i-1}\binom{n-j}{n-l}}{\binom{n}{A_i}}f_{i-1,l}$$

这是 $O(mn^2)$ 的做法，可惜没有任何分。但是我们可以尝试用整体 DP 的想法优化这个 DP。方便起见，下面将 $f_{i,j}$ 记为 $f_i(j)$ 来表示这个统一维护的想法。

---

- 这个 DP 好像还是没啥优化的前途啊。
- 废话这玩意有前途那上面的概率 dp 就也有前途了，不是说要用 $tp=1$ 吗。对应到 DP 上面就是 $f_0(i)=i$。

那么我们不妨尝试计算一下 $f_1$。

$$f_1(x)=\sum_{j=1}^{A_i}\dfrac{\binom{x-1}{j-1}\binom{n-x}{A_i-j}}{\binom{n}{A_i}}\cdot j+\sum_{j=A_i+1}^{n}\dfrac{\binom{x-1}{j-A_i-1}\binom{n-x}{n-j}}{\binom{n}{A_i}}\cdot j$$

两部分分开计算：

$$\sum_{j=1}^{A_i}\dfrac{\binom{x-1}{j-1}\binom{n-x}{A_i-j}}{\binom{n}{A_i}}\cdot j$$

这个看起来非常像范德蒙德卷积，可惜有个 $j$ 在那里。但是上面又有个组合数的下指标是 $j-1$，那么我们尝试通过拆出去一个 $1$ 来把 $j$ 吸收掉。

$$\sum_{j=1}^{A_i}\dfrac{\binom{x-1}{j-1}\binom{n-x}{A_i-j}}{\binom{n}{A_i}}\cdot (j-1)+\sum_{j=1}^{A_i}\dfrac{\binom{x-1}{j-1}\binom{n-x}{A_i-j}}{\binom{n}{A_i}}$$

后面是个标准的组合数卷积，前面用 $\dbinom{x-1}{j-1}$ 把 $j-1$ 吸收掉。

$$\sum_{j=1}^{A_i}\dfrac{\binom{x-2}{j-2}\binom{n-x}{A_i-j}}{\binom{n}{A_i}}\cdot (x-1)+\dfrac{\binom{n-1}{A_i-1}}{\binom{n}{A_i}}$$

提出 $x-1$，那么后面的一项也变成了标准的组合数卷积。

$$\dfrac{\binom{n-2}{A_i-2}}{\binom{n}{A_i}}\cdot (x-1)+\dfrac{\binom{n-1}{A_i-1}}{\binom{n}{A_i}}$$

后面那一部分是类似的，提出去 $A_i+1$，然后在里面把 $j-A_i-1$ 给吸收掉，变成两个组合数卷积就可以了。

所以我们发现 $f_1(x)$ 是关于 $x$ 的线性函数！

那么既然这样，$f_2(x)$ 就等价于把 $f_1(x)$ 的式子里面的 $j$ 全都换成 $k_1j+b_1$。推一下容易发现 $f_2(x)$ 仍然关于 $x$ 线性！于是所有的 $f_i(x)$ 就都是关于 $x$ 线性的了。回答询问等价于对 $f_n(x)$ 进行一个求值，所以直接搞就是 $O(n+m+q)$ 的了。结合上面的两个暴力可以获得 $70$ 分。

---

- 还差点啥啊……差个 $tp=2$……这时分数是 $i^2$……那不就是个二次函数……
- 等等，是不是二次函数？

和上面是类似的，如果 $f_{i-1}(x)$ 是个二次函数 $ax^2+bx+c$，那么我们很容易将它改写为 $p(x-1)(x-2)+q(x-1)+r$ 的形式。这样，常数项和一次项带入上面的转移式的第一部分的时候和 $tp=1$ 的时候是完全一样的。二次项带入的时候可以发现与一次项是类似的，只不过需要进行两次吸收，剩下的是一个常数乘一个二次项。

带入第二部分的时候稍有区别，需要改写为 $u(x-A_i-1)(x-A_i-2)+v(x-A_i-1)+w$ 的形式。剩下的都是一样的。

所以此时所有 $f_i(x)$ 就都是二次函数。所以这一部分和 $tp=1$ 是基本相同的，只是手算改写函数形式的系数会麻烦很多。

那么这题就做完了，复杂度 $O(n+m+q)$。实际实现的时候不需要分类讨论，因为一次函数可以直接当作二次函数处理。

```cpp
const long long mod = 998244353;
const int N = 10000005, M = 500005;
int n, m, tp;
long long fac[N], ifac[N], len[M], a[M], b[M], c[M];

inline void Read() {
    n = qread(); m = qread(); tp = qread();
    for (int i = 1;i <= m;i++) len[i] = qread();
}

inline void Prefix() {
    ifac[1] = 1;
    for (int i = 2;i <= n;i++) ifac[i] = (mod - mod / i) * ifac[mod % i] % mod;
    fac[0] = fac[1] = ifac[0] = 1;
    for (int i = 2;i <= n;i++) {
        fac[i] = fac[i - 1] * i % mod;
        ifac[i] = ifac[i - 1] * ifac[i] % mod;
    }
}

inline long long C(long long n, long long r) {
    if (n < r || r < 0) return 0;
    return fac[n] * ifac[r] % mod * ifac[n - r] % mod;
}

inline long long Cinv(long long n, long long r) {
    return fac[r] * fac[n - r] % mod * ifac[n] % mod;
}

inline long long Eval(int i, long long x) {
    return (a[i] * (x + mod - 1) % mod * (x + mod - 2) % mod + b[i] * (x + mod - 1) % mod + c[i]) % mod;
}

inline void Solve() {
    if (tp == 1) {
        a[0] = 0; b[0] = 1; c[0] = 1;
    } else {
        a[0] = 1; b[0] = 3; c[0] = 1;
    }
    for (int i = 1;i <= m;i++) {
        long long iv = Cinv(n, len[i]);
        long long amv = a[i - 1];
        long long bmv = (b[i - 1] + 2 * a[i - 1] * len[i] % mod) % mod;
        long long cmv = (c[i - 1] + b[i - 1] * len[i] % mod + a[i - 1] * len[i] % mod * len[i] % mod - a[i - 1] * len[i] % mod + mod) % mod;
        a[i] = (C(n - 3, len[i] - 3) * iv % mod * a[i - 1] % mod + C(n - 3, len[i]) * iv % mod * amv % mod) % mod;
        b[i] = (C(n - 2, len[i] - 2) * iv % mod * b[i - 1] % mod + C(n - 2, len[i]) * iv % mod * bmv % mod) % mod;
        c[i] = (C(n - 1, len[i] - 1) * iv % mod * c[i - 1] % mod + C(n - 1, len[i]) * iv % mod * cmv % mod) % mod;
    }
    int q = qread();
    while (q--) {
        int x = qread();
        cout << Eval(m, x) << '\n';
    }
}
```

---

## 作者：s_r_f (赞：5)

既然没有题解……那本蒟蒻就斗胆来填个坑吧……

下面提到的做法是某个群里的$dalao$们告诉我的……并非原创，求轻喷。

考虑假设答案是一个$tp$次多项式……所以我们只需要$tp + 1(≤3)$个数，也就是求出$i= 1,2,3$时的答案，这样就可以插值求出所有的答案了。

那么……怎么求$f(1),f(2),f(3)$呢？

考虑从第$i-1$次洗牌后的多项式求出第$i$次洗牌后的多项式。

我们考虑暴力……

把两个序列的前$3$个数即$1,2,3,a[i]+1,a[i]+2,a[i]+3$的函数值插值出来，然后$2^3$枚举所有的情况，暴力算即可。

没了$?$没了。~~反正正解我看不懂，还不如直接按照猜出来的结论写，你如果现场写了发现它过大样例了，你就赚翻了~~

复杂度$O(2^3m+q)$,因为有插值，所以有较大的常数。

~~就这样我还拿了提交时的~~$luogu$  $rk2?$

代码：$($数据分治我懒得删了$)$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline int read(){
    int x = 0; char c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) x = x * 10 + c - '0',c = getchar();
    return x;
}
inline void write(int x){ if (x > 9) write(x/10); putchar(x%10+'0'); }
inline void writeln(int x){ write(x),putchar('\n'); }

const int P = 998244353,M = 500050,inv2 = (P+1) >> 1;
int n,m,tp,a[M],q;

namespace subtask1{
	int f[85][85],rate[85][85],ans[85],inv[85],t[85][85],w[85][85];
	inline void add(int &x,int y){ x += y; if (x >= P) x -= P; }
	inline void work(int x,int y){
		static int i,j,k,v;
		memset(t,0,sizeof(t));
		memset(f,0,sizeof(f));
		f[0][0] = 1;
		for (i = 0; i <= x; ++i)
		for (j = 0; j <= y; ++j) if (f[i][j]){
			if (i < x){ v = (LL)f[i][j] * inv[n-i-j] % P * (x-i) % P; add(f[i+1][j],v); add(t[i+1][i+j+1],v); }
			if (j < y){ v = (LL)f[i][j] * inv[n-i-j] % P * (y-j) % P; add(f[i][j+1],v); add(t[x+j+1][i+j+1],v); }
		}
		for (i = 1; i <= n; ++i)
		for (j = 1; j <= n; ++j) w[i][j] = rate[i][j],rate[i][j] = 0;
		for (i = 1; i <= n; ++i)
		for (j = 1; j <= n; ++j)
		for (k = 1; k <= n; ++k) add(rate[i][j],(LL)w[i][k] * t[k][j] % P);
	}
	inline void solve(){
		int i,j;
		memset(rate,0,sizeof(rate));
		for (inv[0] = inv[1] = 1,i = 2; i <= 80; ++i) inv[i] = (LL)(P-P/i) * inv[P%i] % P;
		for (i = 1; i <= n; ++i) rate[i][i] = 1;
		for (i = 1; i <= m; ++i) work(a[i],n-a[i]);
		for (i = 1; i <= n; ++i)
		for (j = 1; j <= n; ++j) ans[i] = (ans[i] + (LL)rate[j][i] * j % P * (tp == 2 ? j : 1)) % P;
		while (q--) i = read(),writeln(ans[i]);	
	}
}
namespace subtask2{
	inline bool check(){ for (int i = 2; i <= m; ++i) if (a[i] ^ a[i-1]) return 0; return 1; }
	int t[105][105],f[105][105],inv[105],A[105][105],B[105][105],C[105][105],ans[105];
	inline void add(int &x,int y){ x += y; if (x >= P) x -= P; }
	inline void work(int x,int y){
		static int i,j,v;
		memset(t,0,sizeof(t));
		memset(f,0,sizeof(f));
		f[0][0] = 1;
		for (i = 0; i <= x; ++i)
		for (j = 0; j <= y; ++j) if (f[i][j]){
			if (i < x){ v = (LL)f[i][j] * inv[n-i-j] % P * (x-i) % P; add(f[i+1][j],v); add(t[i+1][i+j+1],v); }
			if (j < y){ v = (LL)f[i][j] * inv[n-i-j] % P * (y-j) % P; add(f[i][j+1],v); add(t[x+j+1][i+j+1],v); }
		}
		for (i = 1; i <= n; ++i)
		for (j = 1; j <= n; ++j) A[i][j] = t[i][j],B[i][j] = i == j ? 1 : 0;
	}
	inline void Mpow(int m){
		static int i,j,k;
		while (m){
			if (m&1){
				for (i = 1; i <= n; ++i)
				for (j = 1; j <= n; ++j)
				for (C[i][j] = 0,k = 1; k <= n; ++k) add(C[i][j],(LL)B[i][k] * A[k][j] % P);
				for (i = 1; i <= n; ++i)
				for (j = 1; j <= n; ++j) B[i][j] = C[i][j];
			}
			for (i = 1; i <= n; ++i)
			for (j = 1; j <= n; ++j)
			for (C[i][j] = 0,k = 1; k <= n; ++k) add(C[i][j],(LL)A[i][k] * A[k][j] % P);
			for (i = 1; i <= n; ++i)
			for (j = 1; j <= n; ++j) A[i][j] = C[i][j];
			m >>= 1;
		}
	}
	inline void solve(){
		int i,j;
		for (inv[0] = inv[1] = 1,i = 2; i <= 100; ++i) inv[i] = (LL)(P-P/i) * inv[P%i] % P;
		work(a[1],n-a[1]);
		Mpow(m);
		for (i = 1; i <= n; ++i)
		for (j = 1; j <= n; ++j) ans[i] = (ans[i] + (LL)B[j][i] * j % P * (tp == 2 ? j : 1)) % P;
		while (q--) i = read(),writeln(ans[i]);	
	}
}

int y_1,y_2,y_3;
inline int add(int x,int y){ return (x+=y)>=P?x-P:x; }
inline int dev(int x,int y){ return (x-=y)<0?x+P:x; }
inline int mul(LL x,int y){ return x*y-x*y/P*P; }
inline int qpow(int x,int y){ static int ret; ret = 1; while (y){ if (y&1) ret = mul(ret,x); x = mul(x,x),y >>= 1; } return ret; }

inline int F(int x){ return dev(mul(inv2,add(mul(y_1,mul(dev(x,2),dev(x,3))),mul(y_3,mul(dev(x,1),dev(x,2))))),mul(y_2,mul(dev(x,1),dev(x,3)))); }
//插值，直接手算一下式子打进程序里(加了取模优化之后惨不忍睹的代码)

int x[4],lx;
int y[4],ly;

int main(){
	int i,j,k,val,p1,p2,v;
	int v1,v2,v3;
	n = read(),m = read(),tp = read();
	for (i = 1; i <= m; ++i) a[i] = read();
	q = read();
	if (n <= 80 && m <= 80){subtask1::solve(); return 0;}
	if (n <= 100 && subtask2::check()){ subtask2::solve(); return 0; }
	val = qpow(mul(n,mul(n-1,n-2)),P-2);
	y_1 = 1,y_2 = tp == 2 ? 4 : 2,y_3 = tp == 2 ? 9 : 3;
	for (i = 1; i <= m; ++i){
		lx = 0; for (j = 1; j <= 3 && j <= a[i]; ++j) x[++lx] = F(j);
		ly = 0; for (j = a[i]+1; j <= 3 + a[i] && j <= n; ++j) y[++ly] = F(j);
		y_1 = y_2 = y_3 = 0;
		for (j = 0; j < 8; ++j){ //暴力≤8种情况
			p1 = p2 = v = 1;
			if (j & 1){ v = mul(v,a[i]-p1+1); if (p1 > lx) p1 = -1; v1 = x[p1],++p1; }
			else{ v = mul(v,n-a[i]-p2+1); if (p2 > ly) p2 = -1; v1 = y[p2],++p2; }
			if (!p1 || !p2) continue;
			
			if (j >> 1 & 1){ v = mul(v,a[i]-p1+1); if (p1 > lx) p1 = -1; v2 = x[p1],++p1; }
			else{ v = mul(v,n-a[i]-p2+1); if (p2 > ly) p2 = -1; v2 = y[p2],++p2; }
			if (!p1 || !p2) continue;
			
			if (j >> 2 & 1){ v = mul(v,a[i]-p1+1); if (p1 > lx) p1 = -1; v3 = x[p1],++p1; }
			else{ v = mul(v,n-a[i]-p2+1); if (p2 > ly) p2 = -1; v3 = y[p2],++p2; }
			if (!p1 || !p2) continue;//计算f(1),f(2),f(3)
			y_1 = add(y_1,mul(v1,v));
			y_2 = add(y_2,mul(v2,v));
			y_3 = add(y_3,mul(v3,v));
		}
		y_1 = mul(y_1,val),y_2 = mul(y_2,val),y_3 = mul(y_3,val);
	}
	while (q--) v = read(),writeln(F(v));//回答询问
   return 0;
}
```

---

## 作者：orecic (赞：2)

~~蒟蒻同步赛选手~~

考试的时候手推式子推了半天，结果只写个个$\ O(mn^{2})$，水了$\ 30$


我们设$\ f_{i,j}$是经过$\ i$次洗牌第$\ j$张牌的期望（从下往上），$\ fa_{i,j},fb_{i,j}$是两堆牌经过$\ i$次洗牌的$\ j$张牌的期望，我们有：

设$\ A,B$是两堆牌的高度。

$$f_{i,j}=\sum_{k=1}^{j} \frac{\binom{j-1}{k-1}A^{\underline{k}}B^{\underline{j-k}}(fa_{i-1,k})+\binom{j-1}{k-1}B^{\underline{k}}A^{\underline{j-k}}(fb_{i-1,k})}{n^{\underline{j}}}$$

为甚会得到这个式子呢？

我们有以下分析：

先看这个图：

![](https://img-blog.csdnimg.cn/20190719070125854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJ0YWlkb3U=,size_16,color_FFFFFF,t_70)


$\ c$的高度为$\ A$，$\ d$的高度为$\ B$

我们逐个分析：


先不考虑其顺序。

第一张牌：
- 如果我们取$\ c1$，显然$\ c1$的贡献为$\ \frac{A}{n}c1$
- 如果我们取$\ d1$，显然$\ d1$的贡献为$\ \frac{B}{n}d1$

第二张牌
- 如果我们取$\ c1$，贡献为$\ \frac{AB}{n(n-1)}c1$
- 如果我们取$\ d1$，贡献为$\ \frac{AB}{n(n-1)}d1$
- 如果我们取$\ c2$，贡献为$\ \frac{A(A-1)}{n(n-1)}c2$
- 如果我们取$\ d2$，贡献为$\ \frac{B(B-1)}{n(n-1)}d2$


$\cdots$


显然的，当我们第$\ j$张选了$\ ck$时，分子上肯定有$\ n^{\underline{num}}$，分子上肯定有$\ A^{\underline{k}}$和$\ B^{\underline{j-k}}$。对于$\ dk$，我们有同样的分析。

那么考虑顺序的话是很么呢？显然是一个组合数$\ \binom{j-1}{k-1}$。这个请读者自己分析。

致辞我们可以得到代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const long long mod=998244353;
//char buf[1<<20],*fs,*ft;
//inline char getc()
//{return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))? 0 : *fs++;}
inline long long read()
{long long s=0,w=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
return s*w;}
//char buf1[1<<21],a1[20];int p11,p12=-1;
//inline void flush()
//{fwrite (buf1,1,p12+1,stdout),p12=-1;}
//inline void print(int x)
//{if(p12>1<<20) flush();if(x<0) buf1[++p12]=45,x=-x;
//do{a1[++p11]=x%10+48;}while(x/=10);
//do{buf1[++p12]=a1[p11];}while(--p11);buf1[++p12]='\n';}
/*
g the two line
f the c
frac n!
invf the inv of frac
a A
*/
long long n,m,a[100100],f[2][100100],frac[100100],invf[100100],g[1100][1100],type;
long long fa[100100],fb[100100];
inline long long poww(long long a,long long b)
{
	long long res=1ll;
	a%=mod;
	while(b)
	{
		if(b&1)
		{
			res*=a;
			res%=mod;
		}
		a*=a;
		a%=mod;
		b>>=1;
	}
	return res;
}
inline long long sum(int aa,int bb,int num,int k)
{
	long long ans=invf[n]*frac[n-num-1];
	ans%=mod;
	ans*=g[k-1][num-(k-1)];
	ans%=mod;
	int aused1,bused1,aused2,bused2;
	//ues in a
	aused1=k-1ll;
	bused1=num-(k-1ll);
	//use in b
	aused2=num-(k-1ll);
	bused2=k-1ll;
	long long suma=frac[aa]*invf[aa-aused1];
	suma%=mod;
	if((aused1<aa)&&(bused1<=bb))
	{
	suma*=frac[bb];
	suma%=mod;
	suma*=invf[bb-bused1];
	suma%=mod;
	suma*=aa-aused1;
	suma%=mod;
	suma*=fa[k];
	suma%=mod;
	}
	else suma=0;
	
	long long sumb=frac[bb]*invf[bb-bused2];
	sumb%=mod;
	if((bused2<bb)&&(aused2<=aa))
	{
	sumb*=frac[aa];
	sumb%=mod;
	sumb*=invf[aa-aused2];
	sumb%=mod;
	sumb*=bb-bused2;
	sumb%=mod;
	sumb*=fb[k];
	sumb%=mod;
	}
	else sumb=0;
	
	long long sum=suma+sumb;
	sum%=mod;
	ans*=sum%mod;
	ans%=mod;
	return ans;
}
/*
have got num cards and the next is the kth
*/
signed main()
{
//	freopen("landlords.in","r",stdin);
//	freopen("landlords.out","w",stdout);
	memset(f,0,sizeof(f));
	memset(g,0,sizeof(g)); 
	n=read();
	m=read();
	type=read();
	int i=1,j=1,k=1;
	while(i<=m)
	{
		a[i]=read();
		++i;
	}
	g[0][0]=1;
	i=0;
	while(i<=n)
	{
		j=0;
		while(j<=n)
		{
			if(i) g[i][j]+=g[i-1][j];
			g[i][j]%=mod;
			if(j) g[i][j]+=g[i][j-1];
			g[i][j]%=mod;
			++j;
		}
		++i;
	}
	frac[0]=1;
	i=1;
	while(i<=n)
	{
		frac[i]=frac[i-1]*i;
		frac[i]%=mod;
		++i;
	}
	i=0;
	while(i<=n)
	{
		invf[i]=poww(frac[i],mod-2);
		invf[i]%=mod;
		++i;
	}
	i=1;
	while(i<=n)
	{
		f[0][n-i+1]=poww(i,type);
		f[0][n-i+1]%=mod;
		++i;
	}
	int cur=0;
	i=1;
	while(i<=m)
	{
		cur^=1;
		int aa=0,bb=0;
		j=n-a[i]+1;
		memset(f[cur],0,sizeof(f[cur]));
		memset(fa,0,sizeof(fa));
		memset(fb,0,sizeof(fb));
		while(j<=n)
		{
			fa[++aa]=f[cur^1][j];
			++j;
		}
		j=1;
		while(j<=n-a[i])
		{
			fb[++bb]=f[cur^1][j];
			++j;
		}
		j=1;
		while(j<=n)
		{
			k=1;
			while(k<=min(j,max(aa,bb)))
			{
				f[cur][j]+=sum(aa,bb,j-1,k);
				f[cur][j]%=mod;
				++k;
			}
			++j;
		}
		++i;
	}
	int qq=read();
	while(qq--)
	{
		int cc=read();
//		while(f[cur][n-cc+1]<0) f[cur][n-cc+1]+=mod;
		printf("%lld\n",f[cur][n-cc+1]);
	}
	return 0;
}
```




当然只有三十分，$\ O(mn^{2})$的复杂度是很不优秀的。

我们经过~~打表~~证明发现在$\ f(i)=i$时答案是一个等差数列，那么我们就只需要记录前两项了。

证明：


我们思考一下这个过程：我们发现任意时刻我们的牌堆都是上面的牌没有下面的牌大的（不取膜）。我们挖掘这个东西的性质，发现它实际上是基数排序的逆过程。而且原序列的所有情况概率是相同的。



同理可得$\ f(i)=i^{2}$的时候是二次函数


实际上我们不需要分情况讨论，一次函数本身就是特殊的二次函数。

此处我用拉格朗日插值就二次函数通项，大佬可以用二阶差分啥的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const long long mod=998244353;
//char buf[1<<20],*fs,*ft;
//inline char getc()
//{return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))? 0 : *fs++;}
inline long long read()
{long long s=0,w=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
return s*w;}
//char buf1[1<<21],a1[20];int p11,p12=-1;
//inline void flush()
//{fwrite (buf1,1,p12+1,stdout),p12=-1;}
//inline void print(int x)
//{if(p12>1<<20) flush();if(x<0) buf1[++p12]=45,x=-x;
//do{a1[++p11]=x%10+48;}while(x/=10);
//do{buf1[++p12]=a1[p11];}while(--p11);buf1[++p12]='\n';}
/*
g the two line
f the c
frac n!
invf the inv of frac
a A
*/
long long n,m,a[500500],f[2][5],frac[10001000],invf[10001000],type;
long long fa[5],fb[5];
long long g(long long i,long long j)
{
	long long ans=frac[i+j];
	ans*=invf[i];
	ans%=mod;
	ans*=invf[j];
	ans%=mod;
	return ans;
}
inline long long poww(long long a,long long b)
{
	long long res=1ll;
	a%=mod;
	while(b)
	{
		if(b&1)
		{
			res*=a;
			res%=mod;
		}
		a*=a;
		a%=mod;
		b>>=1;
	}
	return res;
}
inline long long sum(int aa,int bb,int num,int k)
{
	long long ans=invf[n]*frac[n-num-1];
	ans%=mod;
	ans*=g(k-1,num-(k-1));
	ans%=mod;
	int aused1,bused1,aused2,bused2;
	//ues in a
	aused1=k-1ll;
	bused1=num-(k-1ll);
	//use in b
	aused2=num-(k-1ll);
	bused2=k-1ll;
	long long suma=frac[aa]*invf[aa-aused1];
	suma%=mod;
	if((aused1<aa)&&(bused1<=bb))
	{
	suma*=frac[bb];
	suma%=mod;
	suma*=invf[bb-bused1];
	suma%=mod;
	suma*=aa-aused1;
	suma%=mod;
	suma*=fa[k];
	suma%=mod;
	}
	else suma=0;
	
	long long sumb=frac[bb]*invf[bb-bused2];
	sumb%=mod;
	if((bused2<bb)&&(aused2<=aa))
	{
	sumb*=frac[aa];
	sumb%=mod;
	sumb*=invf[aa-aused2];
	sumb%=mod;
	sumb*=bb-bused2;
	sumb%=mod;
	sumb*=fb[k];
	sumb%=mod;
	}
	else sumb=0;
	
	long long sum=suma+sumb;
	sum%=mod;
	ans*=sum%mod;
	ans%=mod;
	return ans;
}
/*
have got num cards and the next is the kth
*/
inline void getabc(long long x0,long long y0,long long x1,long long y1,long long x2,long long y2,long long &aa,long long &bb,long long &cc)
{
	aa=0;
	bb=0;
	cc=0;
	long long sum=0;
	//0a 0b
	sum=(x0-x1)*(x0-x2);
	sum%=mod;
	sum=poww(sum,mod-2);
	sum*=y0;
	sum%=mod;
	aa+=sum;
	aa%=mod;
	sum*=(x1+x2);
	sum%=mod;
	bb+=sum;
	bb%=mod;
	//1a 1b
	sum=(x1-x0)*(x1-x2);
	sum%=mod;
	sum=poww(sum,mod-2);
	sum*=y1;
	sum%=mod;
	aa+=sum;
	aa%=mod;
	sum*=(x0+x2);
	sum%=mod;
	bb+=sum;
	bb%=mod;
	//2a 2b
	sum=(x2-x0)*(x2-x1);
	sum%=mod;
	sum=poww(sum,mod-2);
	sum*=y2;
	sum%=mod;
	aa+=sum;
	aa%=mod;
	sum*=(x0+x1);
	sum%=mod;
	bb+=sum;
	bb%=mod;
	
	bb*=-1;
	bb%=mod;
	if(bb<0) bb+=mod;
	//0c
	sum=(x0-x1)*(x0-x2);
	sum%=mod;
	sum=poww(sum,mod-2);
	sum*=y0;
	sum%=mod;
	sum*=x1;
	sum%=mod;
	sum*=x2;
	sum%=mod;
	cc+=sum;
	cc%=mod;
	//1c
	sum=(x1-x0)*(x1-x2);
	sum%=mod;
	sum=poww(sum,mod-2);
	sum*=y1;
	sum%=mod;
	sum*=x0;
	sum%=mod;
	sum*=x2;
	sum%=mod;
	cc+=sum;
	cc%=mod;
	//2c
	sum=(x2-x0)*(x2-x1);
	sum%=mod;
	sum=poww(sum,mod-2);
	sum*=y2;
	sum%=mod;
	sum*=x0;
	sum%=mod;
	sum*=x1;
	sum%=mod;
	cc+=sum;
	cc%=mod;
}
signed main()
{
//	freopen("landlords2.in","r",stdin);
//	freopen("landlords2.out","w",stdout);
	memset(f,0,sizeof(f)); 
	n=read();
	m=read();
	type=read();
	int i=1,j=1,k=1;
	while(i<=m)
	{
		a[i]=read();
		++i;
	}
	frac[0]=1;
	i=1;
	while(i<=n)
	{
		frac[i]=frac[i-1]*i;
		frac[i]%=mod;
		++i;
	}
	invf[n]=poww(frac[n],mod-2);
	i=n;
	while(i>=1)
	{
		invf[i-1]=invf[i]*i;
		invf[i-1]%=mod;
		--i;
	}
	i=n;
	while(i>=n-3)
	{
		f[0][n-i+1]=poww(i,type);
		f[0][n-i+1]%=mod;
		--i;
	}
	int cur=0;
	i=1;
	while(i<=m)
	{
		cur^=1;
		int aa=0,bb=0;
		memset(f[cur],0,sizeof(f[cur]));
		memset(fa,0,sizeof(fa));
		memset(fb,0,sizeof(fb));
		j=1;
		while(j<=3)
		{
			fb[++bb]=f[cur^1][j];
			++j;
		}
		bb=n-a[i];
		aa=a[i];
		long long ax,bx,cx;
		getabc(1,fb[1],2,fb[2],3,fb[3],ax,bx,cx);
		int x=n-a[i]+1;
		j=1;
		while(j<=3)
		{
			fa[j]=ax*x;
			fa[j]%=mod;
			fa[j]*=x;
			fa[j]%=mod;
			fa[j]+=(bx*x)%mod;
			fa[j]%=mod;
			fa[j]+=cx;
			fa[j]%=mod;
			++x;
			++j;
		}
		j=1;
		while(j<=3)
		{
			k=1;
			while(k<=3)
			{
				f[cur][j]+=sum(aa,bb,j-1,k);
				f[cur][j]%=mod;
				++k;
			}
			++j;
		}
		++i;
	}
	long long aaa,bbb,ccc;
	getabc(1,f[cur][1],2,f[cur][2],3,f[cur][3],aaa,bbb,ccc);
	int qq=read();
	while(qq--)
	{
		int cc=read();
		cc=n-cc+1;
		int ans=0;
		ans=aaa*cc;
		ans%=mod;
		ans*=cc;
		ans%=mod;
		ans+=(cc*bbb)%mod;
		ans%=mod;
		ans+=ccc;
		ans%=mod;
		if(ans<0) ans+=mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```


$\ \color{white}\text{为京阿尼祈福}$







---


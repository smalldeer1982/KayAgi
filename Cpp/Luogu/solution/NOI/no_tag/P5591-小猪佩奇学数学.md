# 小猪佩奇学数学

## 题目描述

佩奇和乔治在学数♂学。

给定 $n,p,k$,询问
$$
\sum_{i=0}^n \binom n i \times p^{i} \times \left\lfloor \frac{i}{k} \right\rfloor \bmod 998244353
$$

## 说明/提示

对于 $20\%$ 的数据，$1 \leq n \leq 10^6$

对于另外 $40\%$ 的数据，$k \in \{2^w|0 \leq w \leq 10\}$

对于 $100\%$ 的数据，$1 \leq n,p <998244353,k \in \{2^{w}|0 \leq w \leq 20\}$

### 出题人善意的提醒

请注意常数因子带来的程序效率上的影响。

## 样例 #1

### 输入

```
3 3 2```

### 输出

```
54```

# 题解

## 作者：Sooke (赞：53)

### 题意

给定 $n,\,p,\,k$ ，求：

$$\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\left\lfloor\frac{i}{k}\right\rfloor$$

------

### 解题思路

看到题目给出的式子第一反应是什么？**二项式定理**！

$$\sum_{i=0}^{n} \binom{n}{i}\,p^i$$

移掉烦人的 $\left\lfloor \frac{i}{k} \right\rfloor$ ，二项式定理告诉我们，上面的式子等于 $(p + 1)^n$ 。

然而我们无法轻易地将 $\left\lfloor \frac{i}{k} \right\rfloor$ 表示成某个数的 $i$ 次幂，不妨先来解决子问题。令 $k = 1$ ：

$$\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\left\lfloor\frac{i}{k}\right\rfloor = \sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\,i$$

因为 $n$ 很大，如果不将和式转换成封闭形式，绝对会超时。而二项式定理，就是一种关键的途径。

所以我们希望能把孤零零的 $i$ 去掉，或者放在某个 $i$ 次幂里。$\binom{n}{i}i$ 给予了很大的机会。

这里有一个引理：

$$\binom{n}{m}m = \binom{n-1}{m-1}n$$

刚刚好 $\binom{n}{i}i = \binom{n-1}{i-1}n$
，消除了 $i$ 。接下来就好办很多了：

$$\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\,i = np\sum\limits_{i=0}^{n}\binom{n-1}{i-1}\,p^{i-1}\ = np(p+1)^{n-1}$$

然后我们再把目光移到一般情况上。但还是老问题，$\left\lfloor \frac{i}{k} \right\rfloor$ 如何表示成某个数的 $i$ 次幂呢？它无法像上面一样与 $\binom{n}{i}$ 有关系。注意到，$k$ 是很小的 $2$ 次幂，模数 $9982444353 = 199\times2^{23}+1$ ，这提示着，我们需要**单位根反演**。不难发现：

$$\left\lfloor \frac{i}{k} \right\rfloor = (\sum_{j=0}^{i}\,[k\,|\,j]) - 1$$

而单位根反演的结论恰好是：

$$[k\,|\,n] = \frac{1}{k}\sum_{d=0}^{k-1}\omega_{k}^{dn}$$

代入得：

$$\left\lfloor \frac{i}{k} \right\rfloor = (\sum_{j=0}^{i}\,[k\,|\,j]) - 1 = (\sum_{j=0}^{i}\frac{1}{k}\sum_{d=0}^{k-1}\omega_{k}^{dj}) - 1$$

挪到原式中并化简：

$$\begin{aligned}\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\left\lfloor\frac{i}{k}\right\rfloor &= (\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\sum_{j=0}^{i}\frac{1}{k}\sum_{d=0}^{k-1}\omega_{k}^{dj}) - (\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i) \\ &= (\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\sum_{j=0}^{i}\frac{1}{k}\sum_{d=0}^{k-1}\omega_{k}^{dj}) - (p+1)^n && (\text{后面有二项式定理}) \\ &= (\frac{1}{k}\sum_{d=0}^{k-1}\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\sum_{j=0}^{i}\omega_{k}^{dj}) - (p+1)^n && (\text{这一步很关键}) \\ &= (\frac{1}{k}\sum_{d=0}^{k-1}\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\frac{\omega_{k}^{d(i+1)}-1}{\omega_{k}^{d}-1}) - (p+1)^n && (\text{等比数列求和}) \\ &= (\frac{1}{k}\sum_{d=0}^{k-1}\frac{\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i(\omega_{k}^{d(i+1)}-1)}{\omega_{k}^{d}-1}) - (p+1)^n && (\text{与 i 无关的分母，提取出}) \\ &= (\frac{1}{k}\sum_{d=0}^{k-1}\frac{\omega_{k}^{d}(\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i(\omega_{k}^d)^i)-(\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i)}{\omega_{k}^{d}-1}) - (p+1)^n && (\text{拆开}) \\ &= (\frac{1}{k}\sum_{d=0}^{k-1}\frac{\omega_{k}^{d}(p\omega_k^{d}+1)^n-(p+1)^{n}}{\omega_{k}^{d}-1}) - (p+1)^n && (\text{舒服！两边都可以二项式定理})\end{aligned}$$

于是 $O(k \log)$ 的时间内就能算出答案啦。根据单位根定义，$\omega_{k}^{d} = (\omega_{k}^{1})^d = (g^{(mod-1)/k})^d$ ，其实 $g$ 是模数 $998244353$ 的原根，取 $3$ 即可。

然后实现代码，发现样例都过不去。~~名场面？~~

问题出在哪儿呢？重新看看等比数列求和？当 $d = 0,\,\omega_{k}^{d} = 1$ ，分母不就为 $0$ 了？

我们需要特判 $d = 0$ 。

$$\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i\sum_{j=0}^{i}\omega_{k}^{dj} = \sum\limits_{i=0}^{n}\binom{n}{i}\,p^i(i+1) = (\sum\limits_{i=0}^{n}\binom{n}{i}\,p^ii) + (\sum\limits_{i=0}^{n}\binom{n}{i}\,p^i)$$

运气真好，推着推着又回到了热身问题。根据开始的结论，它等于 $np(p+1)^{n-1} + (p+1)^n$ 。

至此，本题已被完美地解决。时间复杂度 $O(k \log)$ 。

------

### 代码实现

```cpp
#include <bits/stdc++.h>

const int mod = 998244353, gen = 3;

inline int add(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }
inline int sub(int x, int y) { return x - y >= 0 ? x - y : x - y + mod; }
inline int power(int x, int y, int res = 1) {
    for (; y; y >>= 1, x = 1ll * x * x % mod) {
        if (y & 1) { res = 1ll * res * x % mod; }
    } return res;
}

const int N = 2e6 + 5;

int n, p, k, ans, w[N];

int main() {
    scanf("%d%d%d", &n, &p, &k);
    w[0] = 1; w[1] = power(gen, (mod - 1) / k);
    for (int i = 2; i < k; i++) { w[i] = 1ll * w[i - 1] * w[1] % mod; }
    ans = add(1ll * n * p % mod * power(add(p, 1), n - 1) % mod, power(add(p, 1), n));
    for (int i = 1; i < k; i++) {
        int now = 1ll * w[i] * power(add(1ll * w[i] * p % mod, 1), n) % mod;
        now = sub(now, power(add(p, 1), n));
        ans = add(ans, 1ll * now * power(sub(w[i], 1), mod - 2) % mod);
    }
    ans = sub(1ll * ans * power(k, mod - 2) % mod, power(add(p, 1), n));
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：jun头吉吉 (赞：16)

## 题意

$$\sum_{i=0}^n\tbinom{n}{i}p^i\lfloor\frac ik\rfloor \pmod {998244353}$$

$1 \leq n,p <998244353,k \in \{2^{w}|0 \leq w \leq 20\}$

## 题解

首先知道一个结论$[n|k]=\sum_{i=0}^{n-1}\omega_n^{ik}$，下面将用这个柿子乱搞。

$$\sum_{i=0}^n\tbinom{n}{i}p^i\lfloor\frac ik\rfloor$$

$$=\sum_{i=0}^n\tbinom{n}{i}p^i\frac{i-i\bmod k}{k}$$

$$=\frac{1}{k}\sum_{i=0}^n\tbinom{n}{i}p^i(i-i\bmod k)$$

$$=\frac{1}{k}(\sum_{i=0}^n\tbinom{n}{i}p^ii-\sum_{i=0}^n\tbinom{n}{i}p^i(i\bmod k))$$

目标求出里面那坨。把式子拆成两部分。

### $\sum_{i=0}^n\tbinom{n}{i}p^ii$

首先不难发现

$$\tbinom{n}{i}i=\frac{n!}{i!(n-i)!}i=\frac{n(n-1)!}{(i-1)!(n-i)!}=\tbinom{n-1}{i-1}n$$

于是我们将其带进去。不过需要注意$i=0$可能会出现负数，拎出来特判发现是$0$

$$\sum_{i=1}^n\tbinom{n-1}{i-1}np^i$$

用$i+1$替换$i$

$$np\sum_{i=0}^{n-1}\tbinom{n-1}{i}p^{i}$$

然后二项式定理就十分显然了。

$$np(p+1)^{n-1}$$

### $\sum_{i=0}^n\tbinom{n}{i}p^i(i\bmod k)$

这部分就是复习白兔之舞了。

$$\sum_{i=0}^n\sum_{t=0}^{k-1}[i\bmod k=t]\tbinom{n}{i}p^it$$

$$\sum_{i=0}^n\sum_{t=0}^{k-1}[k|(i-t)]\tbinom{n}{i}p^it$$

把一开始的公式套进去

$$\sum_{i=0}^n\sum_{t=0}^{k-1}\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{j(i-t)}\tbinom{n}{i}p^it$$

$$\frac{1}{k}\sum_{i=0}^n\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_k^{ij}\omega_k^{-tj}\tbinom{n}{i}p^it$$

$$\frac{1}{k}\sum_{j=0}^{k-1}\sum_{t=0}^{k-1}t\omega_k^{-tj}\sum_{i=0}^n\tbinom{n}{i}\omega_k^{ij}p^i$$

后面那一串有点意思。

$$\frac{1}{k}\sum_{j=0}^{k-1}\sum_{t=0}^{k-1}t\omega_k^{-tj}\sum_{i=0}^n\tbinom{n}{i}(\omega_k^jp)^i$$

然后就把讨厌的循环$n$次弄没了

$$\frac{1}{k}\sum_{j=0}^{k-1}\sum_{t=0}^{k-1}t\omega_k^{-tj}(\omega_k^jp+1)^n$$

所以只需要对于$j\in[0,k])$求出后面一串的值就行了。这里用`Bluestein's Algorithm`,$ij=\tbinom{i+j}{2}-\tbinom{i}{2}-\tbinom{j}{2}$

$$\frac{1}{k}\sum_{j=0}^{k-1}\sum_{t=0}^{k-1}t\omega_k^{-\tbinom{t+j}{2}+\tbinom{t}{2}+\tbinom{j}{2}}(\omega_k^jp+1)^n$$

整理一下系数。

$$\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^\tbinom{j}{2}(\omega_k^jp+1)^n\sum_{t=0}^{k-1}t\omega_k^{\tbinom{t}{2}}\times \omega_k^{-\tbinom{t+j}{2}}$$

里面随便卷卷就好了。记$c_{k+j}=\text{后面一串}$,$a_{k-i}=i\omega_k^{\tbinom{i}{2}},b_{i}=\omega_k^{-\tbinom{i}{2}}$，有：

$$c_{k+j}=\sum_{t=0}^{k-1}a_{k-t}b_{t+j}$$

卷积显而易见。

再带回去。

$$\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^\tbinom{j}{2}(\omega_k^jp+1)^nc_{k+j}$$
## 代码
```cpp
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
	    while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
using namespace std;
template<const int mod>
struct modint{
    int x;
    modint<mod>(int o=0){x=o;}
    modint<mod> &operator = (int o){return x=o,*this;}
    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}
    modint<mod> &operator ^=(int b){
        modint<mod> a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}
    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}
	template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}
    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}
    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}
    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}
    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}
    friend bool operator ==(modint<mod> a,int b){return a.x==b;}
    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint<mod> operator - () {return x?mod-x:0;}
	modint<mod> &operator++(int){return *this+=1;}
};
const int N=4e6+5;

const int mod=998244353;
const modint<mod> GG=3,Ginv=modint<mod>(1)/3,I=86583718;
struct poly{
	vector<modint<mod>>a;
	modint<mod>&operator[](int i){return a[i];}
	int size(){return a.size();}
	void resize(int n){a.resize(n);}
	void reverse(){std::reverse(a.begin(),a.end());}
};
int rev[N];
inline poly one(){poly a;a.a.push_back(1);return a;}
inline int ext(int n){int k=0;while((1<<k)<n)k++;return k;}
inline void init(int k){int n=1<<k;for(int i=0;i<n;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));}
inline void ntt(poly&a,int k,int typ){
	int n=1<<k;
	for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int mid=1;mid<n;mid<<=1){
		modint<mod> wn=(typ>0?GG:Ginv)^((mod-1)/(mid<<1));
		for(int r=mid<<1,j=0;j<n;j+=r){
			modint<mod> w=1;
			for(int k=0;k<mid;k++,w=w*wn){
				modint<mod> x=a[j+k],y=w*a[j+k+mid];
				a[j+k]=x+y,a[j+k+mid]=x-y;
			}
		}
	}
	if(typ<0){
		modint<mod> inv=modint<mod>(1)/n;
		for(int i=0;i<n;i++)a[i]*=inv;
	}
}
inline poly operator*(poly a,poly b){
	int n=a.size()+b.size()-1,k=ext(n);
	a.resize(1<<k),b.resize(1<<k),init(k);
	ntt(a,k,1);ntt(b,k,1);for(int i=0;i<(1<<k);i++)a[i]*=b[i];
	ntt(a,k,-1),a.resize(n);return a;
}
typedef modint<mod>mint;
int n=3,p=3,k=2;
static mint fac[20];
namespace solve{
	mint w[N];
	#define C2(i) (1ll*(i)*((i)-1)/2)
	void run(){
		w[0]=1;w[1]=mint(3)^((mod-1)/k);for(int i=2;i<k;i++)w[i]=w[i-1]*w[1];
		mint ans=0;poly a,b,c;
		a.resize(k);b.resize(2*k);
		for(int i=0;i<k;i++)a[k-i]=w[C2(i)%k]*i;
		for(int i=0;i<2*k;i++)b[i]=w[((-C2(i))%k+k)%k];
		c=a*b;
		for(int j=0;j<k;j++)
			ans+=w[C2(j)%k]*((w[j%k]*p+1)^n)*c[k+j];
		ans=ans/k;
		out::write((((mint(p+1)^(n-1))*n*p-ans)/k).x);out::putc('\n');
	}
}
signed main(){
	in::read(n,p,k);
	solve::run();
	out::flush();
	return 0;
}
```
vector比较慢要O2才能过

---

## 作者：Soulist (赞：12)

由于存在一道题叫做白兔之舞就导致这道题看上去非常的板$......($如果按照这个方法推下来

约定，$[x]$表示$x$向下取整

$$\sum_{i=0}^n\dbinom{n}{i}\times p^i\times [\dfrac{i}{k}]$$

然后会想到可以将$[\dfrac{i}{k}]$拆开变成：

$$\dfrac{i-i\%k}{k}$$

于是原问题变成：


$$\sum_{i=0}^n\dbinom{n}{i}\times p^i\times\dfrac{i-i\%k}{k}$$

看到了$i\%k$，然后还有组合数，然后$k$还是$2$的整数次幂，这个时候当然是单位根反演上场了...

$$\sum_{t=0}^{k-1}\sum_{i=0}^n[i\%k==t]\dbinom{n}{i}\times \dfrac{i-t}{k}\times p^i$$

然后就是喜闻乐见的化式子了

$$\sum_{t=0}^{k-1}\sum_{i=0}^n[(i-t)\%k==0]\dbinom{n}{i}\times \dfrac{i-t}{k}p^i$$

$$\sum_{t=0}^{k-1}\sum_{i=0}^n\dfrac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{(i-t)j} \times\dbinom{n}{i} \times\dfrac{i-t}{k}p^i$$

$$\dfrac{1}{k^2}\sum_{t=0}^{k-1}\sum_{i=0}^n\sum_{j=0}^{k-1}\omega_{k}^{(i-t)j} \times\dbinom{n}{i}\times(i-t)p^i$$

$$\dfrac{1}{k^2}\sum_{t=0}^{k-1}\sum_{i=0}^n\sum_{j=0}^{k-1}\omega_{k}^{ij}\times\omega_{k}^{-tj} \times\dbinom{n}{i}\times(i-t)p^i$$

然后肯定要交换求和顺序变成：

$$\dfrac{1}{k^2}\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}\omega_{k}^{ij} \times \dbinom{n}{i}\times (i-t)p^i$$

然后这里是可以将其拆开的...

$$\dfrac{1}{k^2}\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}\omega_{k}^{ij} \times \dbinom{n}{i}\times i\times p^i-\dfrac{1}{k^2}\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}\omega_{k}^{ij} \times \dbinom{n}{i}*tp^i$$

我们先忽略$\dfrac{1}{k^2}$

$$\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}\omega_{k}^{ij} \times \dbinom{n}{i}\times i\times p^i-\sum_{t=0}^{k-1}t\times \sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}\omega_{k}^{ij} \times \dbinom{n}{i}p^i$$

$$\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}(\omega_{k}^{j}p)^i \times \dbinom{n}{i}\times i-\sum_{t=0}^{k-1}t\times \sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}(\omega_{k}^{j}p)^i \times \dbinom{n}{i}$$

第二个式子很好处理，我们直接用二项式定理即可化开变成：

$$\sum_{t=0}^{k-1}t\times \sum_{j=0}^{k-1}\omega_{k}^{-tj}(\omega_{k}^{j}p+1)^n$$

然后对于某一个$j$，$(\omega_{k}^{j}p+1)^n$为定值，设其为$a_j$

第一个式子可以将组合数拆开

$$\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}(\omega_{k}^{j}p)^i \times \dbinom{n}{i}\times i$$

$$\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^{n}(\omega_{k}^{j}p)^i \times \dfrac{n!}{i!*(n-i)!}\times i$$

然后这个时候可以将$i=0$的那一项给忽略掉

$$\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=1}^{n}(\omega_{k}^{j}p)^i \times \dfrac{n!}{(i-1)!(n-i)!}$$

$$\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=1}^{n}(\omega_{k}^{j}p)^i \times \dfrac{n*(n-1)!}{(i-1)!((n-1)-(i-1))!}$$

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=1}^{n}(\omega_{k}^{j}p)^{i-1+1}\times \dfrac{(n-1)!}{(i-1)!((n-1)-(i-1))!}$$

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=1}^{n}(\omega_{k}^{j}p)^{i-1}*\omega_{k}^jp\times \dfrac{(n-1)!}{(i-1)!((n-1)-(i-1))!}$$


$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\times \omega_{k}^jp\sum_{i-1=0}^{n-1}(\omega_{k}^{j}p)^{i-1}\times \dfrac{(n-1)!}{(i-1)!((n-1)-(i-1))!}$$

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\times \omega_{k}^jp\sum_{i-1=0}^{n-1}(\omega_{k}^{j}p)^{i-1}\times  \dbinom{n-1}{i-1}$$

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\times \omega_{k}^jp\sum_{i=0}^{n-1}(\omega_{k}^{j}p)^{i}\times  \dbinom{n-1}{i}$$

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\times \omega_{k}^jp*(\omega_{k}^{j}p+1)^{n-1}$$

后面那一坨对于某一个$j$也是固定的，我们可以设$b_j=\omega_{k}^jp*(\omega_{k}^jp+1)^{n-1}$

那么就有原式即：

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\times b_j-\sum_{t=0}^{k-1}t*\sum_{j=0}^{k-1}\omega_{k}^{-tj}a_j$$

然后我们就得到了一个$O(k^2)$的做法了...

然后我们用一下白兔之舞的神仙操作$tj=\dfrac{(t+j)(t+j-1)}{2}-\dfrac{j(j-1)}{2}-\dfrac{t(t-1)}{2}$

证明也很简单，分子是：

$$(t+j)^2-t-j-j^2+j-t^2+t$$

$$2tj$$

所以原式就可以化成：

~~下面的组合数都反了，但我懒得改了QAQ~~

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-(\binom{2}{t+k}-\binom{2}{t}-\binom{2}{j})}\times b_j-\sum_{t=0}^{k-1}t*\sum_{j=0}^{k-1}\omega_{k}^{-(\binom{2}{t+k}-\binom{2}{t}-\binom{2}{j})}a_j$$

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-\binom{2}{t+k}+\binom{2}{t}+\binom{2}{j}}\times b_j-\sum_{t=0}^{k-1}t\times \sum_{j=0}^{k-1}\omega_{k}^{-\binom{2}{t+k}+\binom{2}{t}+\binom{2}{j}}a_j$$

$$n*\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-\binom{2}{t+k}} \omega_{k}^{\binom{2}{t}}\omega_k^{\binom{2}{j}}*b_j-\sum_{t=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-\binom{2}{t+k}} t\times \omega_{k}^{\binom{2}{t}}\omega_k^{\binom{2}{j}}a_j$$

然后如果我们将$t+k$看作一个整体那么就会发现这是一个卷积的形式

然后就只需要将$\omega_{k}^{\binom{2}{t}}$和$\omega_k^{\binom{2}{j}}\times b_j$以及$t\times \omega_{k}^{\binom{2}{t}}$和$\omega_k^{\binom{2}{j}}\times a_j$分别卷起来即可，暴力卷是需要$\rm 6NTT$的...

还担心会$\rm T$来着...然而事实上也不慢，开$\rm O2$最慢的点才$1.3s$..不过其实可以做$\rm 3FFT$的...因为卷起来可以将结果乘起来再加起来...同时把两个多项式的$\rm DFT$算出来需要$3$次变$2$次的技巧...所以速度应该会还可以

复杂度$O(k\log k)$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define LL long long
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int Gi = 332748118 ;
const int P = 998244353 ; 
const int N = 4e6 + 5 ;  
const int G = 3 ;
int n, p, m, limit, L, R[N] ;
LL A[N], B[N], F[N], F2[N], Dg[N], Inv ;
LL fpow( LL x, int k ) {
	LL ans = 1, base = x % P ; k = k % ( P - 1 ) ; 
	while( k ) {
		if( k & 1 ) ans = ( ans * base ) % P ; 
		base = ( base * base ) % P, k >>= 1 ; 
	}
	return ans % P ;
}
void NTT( LL *a, int type ) {
	for( re int i = 0; i < limit; ++ i ) if( i < R[i] ) swap( a[i], a[R[i]] ) ;
	for( re int k = 1; k < limit; k <<= 1 ) {
		LL dg = fpow( ( type == 1 ) ? G : Gi, ( P - 1 ) / ( k << 1 ) ); 
		for( re int i = 0; i < limit; i += ( k << 1 ) )
		for( re LL j = i, g = 1; j < i + k; ++ j, g = ( g * dg ) % P ) {
			LL Nx = a[j], Ny = ( a[j + k] * g ) % P;
			a[j] = ( Nx + Ny ) % P, a[j + k] = ( Nx - Ny + P ) % P ; 
		}
	}
	if( type != 1 ) rep( i, 0, limit - 1 ) a[i] = ( a[i] * Inv ) % P ; 
}
void Init() {
	limit = 1, L = 0 ;
	while( limit < m + m ) limit <<= 1, ++ L ; 
	for( int i = 0; i < limit; ++ i ) R[i] = ( R[i >> 1] >> 1 ) | ( ( i & 1 ) << ( L - 1 ) ) ;
	Inv = fpow( limit, P - 2 ) ;
}
LL C( int x ) {
	return 1ll * x * ( x - 1 ) / 2 ; 
}
signed main()
{
	n = gi(), p = gi(), m = gi() ;  
	Dg[0] = 1, Dg[1] = fpow( G, ( P - 1 ) / m ) ;
	rep( i, 2, m ) Dg[i] = ( Dg[i - 1] * Dg[1] ) % P ; 
	rep( i, 0, m - 1 ) A[i] = fpow( Dg[i] * p + 1, n ), B[i] = Dg[i] * p % P * fpow( Dg[i] * p + 1, n - 1 ) % P ;
	
	LL Ans1 = 0, Ans2 = 0, Ans = 0 ;
	rep( i, 0, m - 1 ) A[i] = Dg[C(i) % m] * A[i] % P, B[i] = Dg[C(i) % m] * B[i] % P, 
	F[i] = Dg[C(i) % m] % P, F2[i] = 1ll * i * Dg[C(i) % m] % P ;
	Init(), NTT( A, 1 ), NTT( B, 1 ), NTT( F, 1 ), NTT( F2, 1 ) ; 
	rep( i, 0, limit - 1 ) A[i] = ( F2[i] * A[i] ) % P, B[i] = ( F[i] * B[i] ) % P ;
	NTT( A, -1 ), NTT( B, -1 ) ;
	
	rep( i, 0, limit ) A[i] = A[i] * Dg[m - C(i) % m] % P, B[i] = B[i] * Dg[m - C(i) % m] % P, 
		Ans2 = ( Ans2 + A[i] ) % P, Ans1 = ( Ans1 + B[i] ) % P ; 
	
	Ans1 = ( 1ll * Ans1 * ( n % P ) ) % P ;  
	Ans = ( Ans1 - Ans2 + P ) % P ;
	Ans = ( Ans * fpow( m * m % P, P - 2 ) ) % P ;
	printf("%lld\n", Ans ) ;
	return 0 ;
}
```

~~因为多项式实在是做少了所以调得非常自闭...，下次再写我开数组绝对不这么吝啬QAQ我错了~~

---

## 作者：teylnol_evteyl (赞：8)

计算：

$$\sum_{i=0}^n \binom n i p^{i} \left\lfloor \dfrac{i}{k} \right\rfloor \bmod 998244353$$

其中 $1 \leq n,p <998244353,k \in \{2^{w}|0 \leq w \leq 20\}$。

把 $\left\lfloor \dfrac{i}{k} \right\rfloor$ 拆为 $\dfrac{i-(i\bmod k)}{k}$。

先看

$$\sum_{i=0}^n \binom n i p^{i} i$$

由于

$$\binom n i=\dfrac{n!}{i!(n-i)!}=\dfrac n i\binom {n-1}{i-1}$$

所以有

$$
\begin{aligned}
&\sum_{i=0}^n \binom n i p^{i} i\\
=&n\sum_{i=0}^{n-1} \binom {n-1} {i} p^{i+1}\\
=&np\sum_{i=0}^{n-1} \binom {n-1} {i} p^i\\
=&np(p+1)^n
\end{aligned}
$$

再看另一部分

$$\sum_{i=0}^n \binom n i p^{i} (i\bmod k)=\sum_{i=0}^{k-1}i\sum_{j\equiv i\pmod k}\binom n jp^j$$

可以发现

$$[x^j](px+1)^n=\binom n jp^j$$

所以只需要计算这个多项式时，把次数取模即可。

FFT 有一个性质是：当多项式乘出来的长度大于进行 FFT 的长度 $n$ 时，次数大于等于 $n$ 的项 $i$，系数会加到 $i\bmod n$ 上。也就是说，FFT 是循环的。

由于这一题 $k$ 为 $2$ 的次幂，所以可以直接运用上面这条结论，先对多项式 $px+1$ 进行长度为 $k$ 的 NTT，再对每个位置 $n$ 次方，最后 INTT，此时第 $i$ 项就是 $\sum\limits_{j\equiv i\pmod k}\binom n jp^j$ 的值。

将两部分的结果相减，除以 $k$ 就是最终答案。

时间复杂度 $O(k\log n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 1 << 20 | 5, P = 998244353, G = 3;

int n, p, k;
LL a[N];

inline LL ksm(LL a, LL n)
{
    LL res = 1;
    while(n)
    {
        if(n & 1) res = res * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return res;
}
inline void NTT(LL a[], int n, int ty)
{
    for(int i = 0, j = 0; i < n; i ++ )
    {
        if(i < j) a[i] ^= a[j] ^= a[i] ^= a[j];
        for(int k = (n >> 1); (j ^= k) < k; k >>= 1) ;
    }
    static LL w[N];
    w[0] = 1;
    for(int i = 1; i < n; i <<= 1)
    {
        LL wi = ksm(G, P - 1 + ty * (P - 1) / (i << 1));
        for(int j = i - 2; j >= 0; j -= 2)
        {
            w[j] = w[j >> 1];
            w[j | 1] = w[j] * wi % P;
        }
        for(int j = 0; j < n; j += (i << 1))
        {
            for(int k = j; k < j + i; k ++ )
            {
                LL t0 = a[k], t1 = a[k + i] * w[k - j] % P;
                (a[k] = t0 + t1) >= P && (a[k] -= P), (a[k + i] = t0 - t1 + P) >= P && (a[k + i] -= P);
            }
        }
    }
    if(ty == -1)
    {
        LL inv = ksm(n, P - 2);
        for(int i = 0; i < n; i ++ ) a[i] = a[i] * inv % P;
    }
}

int main()
{
	scanf("%d%d%d", &n, &p, &k);
	LL res = ksm(p + 1, n - 1) * n % P * p % P;
	a[0] = 1, a[1] = p;
	NTT(a, k, 1);
	for(int i = 0; i < k; i ++ ) a[i] = ksm(a[i], n);
	NTT(a, k, -1);
	for(int i = 1; i < k; i ++ ) res = (res + (P - i) * a[i]) % P;
	printf("%lld\n", res * ksm(k, P - 2) % P);
	return 0;
}
```

---

## 作者：Rainy_chen (赞：5)

qwaszx讲的太好辣 就是车速有点快 我开慢点写一篇qwq  
式子可能会推的比较慢，比较繁琐w

### 题面
求$\sum_{i=0}^n \binom n i \times p^{i} \times \left\lfloor \frac{i}{k} \right\rfloor \bmod 998244353$。

$1 \leq n,p <998244353,k \in \{2^{w}|0 \leq w \leq 20\}$

### 前置知识
[二项式定理](https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86)  

[单位根反演](https://www.luogu.org/blog/KingSann/post-ye-hu-shi-leng-men-suan-fa-dan-wei-gen-fan-yan)
### 题解
这种题肯定是要推式子的。。。  

这个式子里$\left\lfloor\frac ik\right\rfloor$看起来并不好处理，于是我们将其拆开，考虑到$\left\lfloor\frac ik\right\rfloor\times k=i-i\mod k$，于是有$\left\lfloor\frac ik\right\rfloor=\frac{i-i\mod k}k$。

带回去之后拆开，可以得到
$$ \frac1k\sum_{i=0}^n\binom ni\times p^i\times(i-i\mod k) = \frac1k\sum_{i=0}^n\binom ni\times p^i\times i -\frac1k\sum_{i=0}^n\binom ni\times p^i\times(i\mod k) $$

后者带了一个模运算，于是我们考虑前者。  

对于$\sum_{i=0}^n\binom ni\times i$，我们做出以下推导

$$\sum_{i=0}^n\binom ni\times i=\sum_{i=0}^n\frac{n!}{(n-i)!i!}\times i=\sum_{i=1}^n\frac{n!}{(n-i)!(i-1)!}=\sum_{i=1}^n\binom{n-1}{i-1}n$$

于是我们知道

$$\frac1k\sum_{i=0}^n\binom ni\times p^i\times i=\frac 1k\sum_{i=1}^nn\binom{n-1}{i-1}p^i=\frac {np}k\sum_{i=1}^n\binom{n-1}{i-1}p^{i-1}$$

后面这个东西显然就是二项式定理，于是有  

$$\frac1k\sum_{i=0}^n\binom ni\times p^i\times i=\frac{np}k(p+1)^{n-1}$$

对于考虑之前那个式子的后半部分，也就是带模的那一部分，我们很难做模相关的运算，所以可以考虑枚举每一种$i\mod k$的情况。
$$\frac1k\sum_{i=0}^n\binom ni\times p^i\times(i\mod k)=\frac1k\sum_{d=0}^{k-1}d\sum_{i=0}^n\binom ni\times p^i\times[i\mod k = d]$$  

把后面这个东西单位根反演掉，可以得到$\frac1k\sum_{j=0}^{k-1}(\omega_k^{i-d})^j$。  

也就是说
$$ \frac1k\sum_{d=0}^{k-1}d\sum_{i=0}^n\binom ni\times p^i\times[i\mod k = d] = \frac1k\sum_{d=0}^{k-1}d\sum_{i=0}^n\binom ni\times p^i\times\frac1k\sum_{j=0}^{k-1}(\omega_k^{i-d})^j$$

简单推一下式子
$$\begin{aligned}Ans&=\frac1k\sum_{d=0}^{k-1}d\sum_{i=0}^n\binom ni\times p^i\times\frac1k\sum_{j=0}^{k-1}(\omega_k^{i-d})^j \\ &= \frac1{k^2}\sum_{d=0}^{k-1}\sum_{j=0}^{k-1}d\sum_{i=0}^n\binom ni\times p^i\times\frac{\omega_{k}^{ij}}{\omega_k^{dj}}\\ &=\frac1{k^2}\sum_{d=0}^{k-1}\sum_{j=0}^{k-1}\frac d{\omega_k^{dj}}\sum_{i=0}^n\binom ni\times(p\times\omega_k^j)^i\\&=\frac1{k^2}\sum_{d=0}^{k-1}\sum_{j=0}^{k-1}\frac d{\omega_k^{dj}}(p\omega_{k}^j+1)^n\end{aligned}$$

然后可以NTT做，但是NTT还要写那一套板子，所以就只说推式子的做法好了。  

整理一下式子  
$$ \frac1{k^2}\sum_{j=0}^{k-1}(p\omega_k^j+1)^n\sum_{d=0}^{k-1}d\omega_k^{-dj} $$  
后面这一项是一个形如$\sum_{i=0}^{n-1}ir^i$的式子，我们想要快速算出它的值。  

我们考虑$\sum_{i=0}^{n-1}(i+1)r^{i+1}$。

稍微化简一下
$$ \sum_{i=0}^{n-1}(i+1)r^{i+1}=\sum_{i=0}^{n-1}ir^{i+1}+\sum_{i=0}^{n-1}r^{i+1}=r\sum_{i=0}^{n-1}ir^i+r\frac{r^n-1}{r-1} $$
最后那一步是一个等比数列求和。

然后我们又知道$\sum_{i=0}^{n-1}ir^i=\sum_{i=0}^{n-1}(i+1)r^{i+1}+0r^0-nr^n$ 

那么就有
$$ \sum_{i=0}^{n-1}ir^i=r\sum_{i=0}^{n-1}ir^i+r\frac{r^n-1}{r-1}-nr^n$$ 
两边随便怎么搞一下就会有
$$ \sum_{i=0}^{n-1}ir^i=\frac{nr^n-r\frac{r^n-1}{r-1}}{r-1}=\frac{nr^n(r-1)-r(r^n-1)}{(r-1)^2}=\frac{nr^n}{r-1}-\frac{r(r^n-1)}{(r-1)^2}$$  
特例是$r=1$时$\sum_{i=0}^{n-1}ir^i=\frac{n(n-1)}2$。

回忆一下要算的式子,
$$  \frac1{k^2}\sum_{j=0}^{k-1}(p\omega_k^j+1)^n\sum_{d=0}^{k-1}d(\omega_k^{-j})^d $$ 
之前推出的式子往里面带一下，那里的$r=1$成立当且仅当此时的$j=0$。  
$$ \sum_{d=0}^{k-1}d(\omega_k^{-j})^d=\frac{k\omega_k^{-jk}}{\omega_k^{-j}-1} - \frac{\omega_{k}^{-j}(\omega_{k}^{-jk}-1)}{(\omega_{k}^{-j}-1)^2}=\frac{k}{\omega_{k}^{-j}-1}-0=\frac{k}{\omega_{k}^{-j}-1}$$
然后就有
$$ \frac1{k^2}(p+1)^n\frac{k(k-1)}2+\frac1{k^2}\sum_{j=1}^{k-1}(p\omega_k^j+1)^n\frac{k}{\omega_{k}^{-j}-1}$$  
再整理一下就有
$$ \frac{(p+1)^n(k-1)}{2k} + \sum_{j=1}^{k-1}\frac{(p\omega_k^j+1)^n}{k(\omega_k^{-j}-1)}$$

考虑到$998244352=119\times2^{23}$，而$k$不会超过$2^{20}$，于是可以直接让$998244353$的原根$3$的$\frac{998244352}k$次幂来代替这里的$\omega_k$，然后就做完了。

代码还蛮短的x

```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long int_t;

int_t mod = 998244353;

int_t fpow(int_t a,int_t b,int_t p){
    int_t res = 1;
    for(;b;b >>= 1,a = a * a % p) if(b & 1) res = res * a % p;
    return res;
}

int main(){
    int_t n,p,k; cin>>n>>p>>k;
    int_t ans = - n * p % mod * fpow(p+1,n-1,mod) % mod * fpow(k,mod-2,mod) % mod;
    int_t omega = fpow(3,(mod - 1) / k,mod),omegainv = fpow(omega,mod-2,mod);;
    ans += fpow(p+1,n,mod) * (k - 1) % mod * fpow(2 * k,mod-2,mod) % mod;
    for(int_t j=1,tmp = omega,tmp2 = omegainv;j<k;j++,tmp = tmp * omega % mod,tmp2 = tmp2 * omegainv % mod) {
        //tmp -> \omega_k^{j}  tmp2 -> \omega_k^{-j}
        ans += fpow(p * tmp % mod + 1,n,mod) * fpow(k * (tmp2 - 1) % mod,mod-2,mod) % mod;
        ans %= mod;
    }
    ans = - ans;
    ans = (ans % mod + mod) % mod;
    cout<<ans;
}
```

---

## 作者：qwaszx (赞：4)

所有的东西我都能推出来但就是被两题题面杀打没了....

题意:求

$$\sum_{i=0}^n\binom{n}{i}p^i\left\lfloor\frac{i}{k}\right\rfloor\mod 998244353$$

前置知识:基本数论知识，二项式系数的简单性质，单位根和原根.下面车速可能比较快.

处理下取整的一个常用办法是分离出整的一部分.在这里我们发现有

$$\left\lfloor\frac{i}{k}\right\rfloor=\left\lfloor\frac{i-i\!\!\mod k}{k}\right\rfloor=\frac{i-i\!\!\mod k}{k}$$

后面这一步是因为$k\mid (i-i\!\!\mod k)$，所以可以直接去掉下取整.

然后化成:

$$=\frac{1}{k}\left(\sum_{i=0}^n\binom{n}{i}p^i i-\sum_{i=0}^n\binom{n}{i}p^i(i\!\!\!\!\mod k)\right)$$

然后对括号里的两项分开算.前面的一项就等于

$$\sum_{i=1}^nn\binom{n-1}{i-1}p^i=pn(p+1)^{n-1}$$

后面的一项比较麻烦，考虑枚举$i\!\!\mod k$:

$$\sum_{d=0}^{k-1}d\sum_{i=0}^n\binom{n}{i}p^i[(i-d)\!\!\!\!\mod k=0]$$

关于这种带着$[i\!\!\mod k=0]$的式子求和有一个常见套路叫做单位根反演.就是利用单位根的性质:

$$\frac{1}{k}\sum_{i=0}^{k-1}(\omega_k^n)^i=[n\!\!\!\!\mod k=0]$$

这个很好证明，当$n\!\!\mod k=0$时$\omega_k^n=1$，左边等于$1$；其他情况下利用等比数列求和公式即可得到左边等于$\frac{\omega_k^{nk}-1}{k(\omega_k^n-1)}=0$

然后代回去就得到

$$\begin{aligned}&=\sum_{d=0}^{k-1}d\sum_{i=0}^n\binom{n}{i}p^i\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{(i-d)j}\\&=\frac{1}{k}\sum_{j=0}^{k-1}\sum_{d=0}^{k-1}\frac{d}{\omega_k^{dj}}\sum_{i=0}^n\binom{n}{i}p^i\omega_k^{ji}\\&=\frac{1}{k}\sum_{j=0}^{k-1}(p\omega_k^j+1)^n\sum_{d=0}^{k-1}d(\omega_k^{k-j})^d\end{aligned}$$

观察枚举$d$的那个东西，这显然是一个等差比数列.这东西的求和方法很多，这里给出一种扰动法的做法.

下面是一个一般形式的求和

$$\begin{aligned}S&=\sum_{i=0}^{n-1}ir^i\\&=\sum_{i=0}^{n-1}(i+1)r^{i+1}+0r^0-nr^n\\&=r\sum_{i=0}^{n-1}ir^i+r\sum_{i=0}^{n-1}r^i-nr^n\\&=rS+\frac{r(r^n-1)}{r-1}-nr^n\end{aligned}$$

把这个关于$S$的方程解出来就得到

$$S=\frac{nr^n}{r-1}-\frac{r(r^n-1)}{(r-1)^2}$$

注意刚才的推导默认了$r\neq 1$.当$r=1$时显然有

$$S=\sum_{i=0}^{n-1}i=\frac{n(n-1)}{2}$$

回代一下并利用$\omega_k^{kt}=1$这个性质就得到

$$\sum_{d=0}^{k-1}d(\omega_k^{k-j})^d=\begin{cases}\frac{k}{\omega_k^{k-j}-1}&j\neq 0\\\\\frac{k(k-1)}{2}&j=0\end{cases}$$

代回去得到

$$\frac{(p+1)^n(k-1)}{2}+\sum_{j=1}^{k-1}\frac{(p\omega_k^j+1)^n}{\omega_k^{k-j}-1}$$

最后一个细节 $\omega_k$怎么算?

如果学了$NTT$那这个东西肯定会.

$998244352=119\times 2^{23}$，而题目保证了$k$是$2$的不超过$20$次幂.并且我们知道$998244353$的原根是$g=3$，按照$\omega_k^k=1$这个性质我们可以知道

$$\omega_k\equiv g^{\frac{998244352}{k}}\pmod {998244353}$$

这东西好像也只能$O(k\log n)$算了?反正可以阿掉就是了.

翻了翻最优解看见一个$IDFT$然后我才想起来上面那个式子长得和$FFT$的$IDFT$非常像...我也懒得推了就等着其他神仙来写吧(

orz EI一眼秒
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int mod=998244353;
int n,p,k,g,gi;
int qpower(int a,int b)
{
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
    return ans;
}
int main()
{
    scanf("%d%d%d",&n,&p,&k);
    g=qpower(3,(mod-1)/k),gi=qpower(g,mod-2);
    int ans=1ll*qpower((p+1)%mod,n)*(1ll*(k-1)*(mod+1)/2%mod)%mod;
	int wi=1,wii=1;
    for(int i=1;i<k;i++)
    {
        wi=1ll*wi*g%mod,wii=1ll*wii*gi%mod;
        ans=(ans+1ll*qpower((1ll*p*wi+1)%mod,n)*qpower(wii-1,mod-2))%mod;
    }
    ans=(1ll*n*p%mod*qpower((p+1)%mod,n-1)-ans)%mod*qpower(k,mod-2)%mod;
    printf("%d\n",(ans+mod)%mod);
}
```

---

## 作者：foreverlasting (赞：4)

[并没有同步发在这里，只是单纯的推销一下](https://foreverlasting1202.github.io/)

单位根反演。

好像我的做法极其垃圾，反正能过就好了。

$\sum_{i=0}^n \binom{n}{i}p^i\lfloor{\frac{i}{k}}\rfloor$
    
$=\sum_{i=0}^n \binom{n}{i}p^i\frac{i-i\ mod\ k}{k}$
    
$=\frac{1}{k}\sum_{i=0}^n \binom{n}{i}p^i(i-i\ mod\ k)$
    
$=\frac{1}{k}(\sum_{i=0}^n i\binom{n}{i}p^i-\sum_{i=0}^n (i\ mod\ k)\binom{n}{i}p^i)$

$\sum_{i=0}^n (i\ mod\ k)\binom{n}{i}p^i$

$=\sum_{d=0}^{k-1}d\sum_{i=0}^n [i\ mod\ k==d]\binom{n}{i}p^i$

$\sum_{i=0}^n [i\ mod\ k==0]\binom{n}{i}p^i$

$=\sum_{i=0}^n\frac{1}{k}\sum_{j=0}^{k-1}\omega^{ij}_k\binom{n}{i}p^i$

$=\sum_{i=0}^n\frac{1}{k}\sum_{j=0}^{k-1}\binom{n}{i}(p\omega^{j}_k)^i$

$=\frac{1}{k}\sum_{j=0}^{k-1}\sum_{i=0}^n\binom{n}{i}(p\omega^{j}_k)^i$

$=\frac{1}{k}\sum_{j=0}^{k-1}(1+p\omega^{j}_k)^n$

$\sum_{d=0}^{k-1}d\sum_{i=0}^n [i\ mod\ k==d]\binom{n}{i}p^i$

$=\frac{1}{k}\sum_{d=0}^{k-1}d\sum_{j=0}^{k-1}(1+p\omega^{j}_k)^n\frac{1}{(\omega^j_k)^d}$

$=\frac{1}{k}\sum_{j=0}^{k-1}(1+p\omega^{j}_k)^n\sum_{d=0}^{k-1}d\frac{1}{(\omega^j_k)^d}$

然后后面那个东西是个简单的等差等比数列求和，于是随便做做就能过了。$O(klogn)$。

---

## 作者：gxy001 (赞：3)

我们有单位根反演：
$$
[k\mid j]=\frac{1}{k}\sum\limits_{d=0}^{k-1}\omega_{k}^{dj}
$$
证明：

当 $k\mid j$ 时，$\omega_k^j=1$，右式 $=1$。

当 $k\nmid j$ 时，$\omega_k^j\neq 1$，右式 $=\frac{\omega_k^{kj}-\omega_k^{0j}}{\omega_k^j-1}=0$。

根据单位根反演：
$$
\begin{aligned}
&\sum\limits_{i=0}^n{n\choose i}p^i\left\lfloor\frac{i}{k}\right\rfloor\\
=&\sum\limits_{i=0}^n{n\choose i}p^i(\sum\limits_{j=0}^i[k\mid j]-1)\\
=&\sum\limits_{i=0}^n{n\choose i}p^i\sum\limits_{j=0}^i[k\mid j]-\sum\limits_{i=0}^n{n\choose i}p^i\\
=&\sum\limits_{i=0}^n{n\choose i}p^i\sum\limits_{j=0}^i\frac{1}{k}\sum\limits_{d=0}^{k-1}\omega_{k}^{dj}-(p+1)^n\\
=&\frac{1}{k}\sum\limits_{d=0}^{k-1}\sum\limits_{i=0}^n{n\choose i}p^i\sum\limits_{j=0}^i\omega_{k}^{dj}-(p+1)^n\\
=&\frac{1}{k}\sum\limits_{i=0}^n{n\choose i}p^i(i+1)+\frac{1}{k}\sum\limits_{d=1}^{k-1}\sum\limits_{i=0}^n{n\choose i}p^i\sum\limits_{j=0}^i\omega_{k}^{dj}-(p+1)^n\\
\end{aligned}
$$
先算左边的东西：
$$
\begin{aligned}
&\sum\limits_{i=0}^n{n\choose i}p^i(i+1)\\
=&\sum\limits_{i=0}^n{n\choose i}p^ii+\sum\limits_{i=0}^n{n\choose i}p^i\\
=&\sum\limits_{i=0}^n{n-1\choose i-1}p^in+(p+1)^n\\
=&np\sum\limits_{i=0}^{n-1}{n-1\choose i}p^i+(p+1)^n\\
=&np(p+1)^{n-1}+(p+1)^n
\end{aligned}
$$
然后是中间的东西：
$$
\begin{aligned}
&\sum\limits_{d=1}^{k-1}\sum\limits_{i=0}^n{n\choose i}p^i\sum\limits_{j=0}^i\omega_{k}^{dj}\\
=&\sum\limits_{d=1}^{k-1}\sum\limits_{i=0}^n{n\choose i}p^i\frac{\omega_{k}^{d(i+1)}-1}{\omega_{k}^{d}-1}\\
=&\sum\limits_{d=1}^{k-1}\frac{\sum\limits_{i=0}^n{n\choose i}p^i\omega_{k}^{d(i+1)}-\sum\limits_{i=0}^n{n\choose i}p^i}{\omega_{k}^{d}-1}\\
=&\sum\limits_{d=1}^{k-1}\frac{\omega_{k}^{d}\sum\limits_{i=0}^n{n\choose i}(p\omega_{k}^{d})^i-(p+1)^n}{\omega_{k}^{d}-1}\\
=&\sum\limits_{d=1}^{k-1}\frac{\omega_{k}^{d}(p\omega_{k}^{d}+1)^n-(p+1)^n}{\omega_{k}^{d}-1}\\
\end{aligned}
$$
所以原式等于：
$$
\frac{1}{k}\left(np(p+1)^{n-1}+(p+1)^n+\sum\limits_{d=1}^{k-1}\frac{\omega_{k}^{d}(p\omega_{k}^{d}+1)^n-(p+1)^n}{\omega_{k}^{d}-1}\right)-(p+1)^n
$$
时间复杂度 $\mathrm O(k\log n)$，复杂度瓶颈是快速幂。



---

## 作者：Prean (赞：3)

题意很明确，不说了。

## 前置芝士：单位根反演
也就是：
$$ [n|a]=\frac 1 n \sum_{i=0}^{n-1}w_n^{ai} $$
看到题目给的柿子：
$$ \sum_{i=0}^n\binom n i \times p^i \times \lfloor \frac i k \rfloor $$
先把那个向下取整拆开：
$$ \sum_{i=0}^n\binom n i \times p^i \times \frac {i- i \bmod k} k $$
$$ \frac 1 k \times (\sum_{i=0}^n\binom n i \times p^i \times i - \sum_{i=0}^n\binom n i \times p^i \times i \bmod k) $$
先看左边的：
$$ \sum_{i=0}^n \binom n i\times p^i \times i $$
由于 $ i $ 这里很难使用二项式定理，又不能爆算，所以考虑通过某种方式把 $ i $ 搞掉，给出引理：
$$ \binom n m m = \binom {n-1} {m-1} n $$
证明是：
$$ \binom n m = \frac {n!} {(n-m)!m!}m = \frac {(n-1)!} {(n-m)!(m-1)!}n = \binom {n-1} {m-1}n $$
于是：
$$ np\sum_{i=0}^n\binom {n-1} {i-1} p^i $$
然后使用二项式定理：
$$ np(p+1)^{n+1} $$
现在看向右边：
$$ \sum_{i=0}^n\binom n i \times p^i \times i \bmod k $$
按照做莫反题的经验，枚举余数：
$$ \sum_{i=0}^n\binom n i p^i\sum_{t=0}^{k-1}t[i-t \bmod k =0] $$
单位根反演一下：
$$ \frac 1 k\sum_{i=0}^n\binom n i p^i\sum_{t=0}^{k-1}t\sum_{j=0}^{k-1}w_k^{(i-t)j} $$
$$ \frac 1 k\sum_{i=0}^n\binom n i p^i\sum_{t=0}^{k-1}t\sum_{j=0}^{k-1}w_k^{ij}w_k^{-tj} $$
$$ \frac 1 k\sum_{j=0}^{k-1}\sum_{t=0}^{k-1}tw_k^{-tj}\sum_{i=0}^n\binom n i p^iw_k^{ij} $$
$$ \frac 1 k\sum_{j=0}^{k-1}(pw_k^j+1)^n\sum_{t=0}^{k-1}tw_k^{-tj} $$
于是我们考虑怎么快速计算 $ \sum_{i=0}^{n-1}ik^i $

这看上去很像等比数列，按照等比数列求和公式的推导对这玩意儿做一遍：

为了方便，先设这玩意儿为 $ f(n,k) $
$$ kf(n,k)-f(n,k)=\sum_{i=0}^{n-1}ik^{i+1}-\sum_{i=0}^{n-1}ik^i $$
$$ \sum_{i=1}^n(i-1)k^i-\sum_{i=0}^{n-1}ik^i $$
$$ (n-1)k^n-\sum_{i=1}^{n-1}k^i $$
$$ (n-1)k^n-\frac {k^n-k} {k-1} $$
又因为带入的都是 $ k $ 次单位根，所以上式的 $ k^n=1 $。于是：
$$ n-1+\frac {1-k}{k-1} =n $$
所以 $ f(n,k) =\frac n {k-1} $，注意要特判 $ f(n,1) = \frac {n(n-1)} 2 $
整理一下：
$$ \frac 1 k \times ( np(p+1)^{n+1} - \frac 1 k\sum_{j=0}^{k-1}(pw_k^j+1)^nf(k,w_k^{-j}) ) $$
贴代码：
```cpp
#include<cstdio>
const int M=1<<23|5,mod=998244353;
int n,p,k,ans,w[M];
inline int pow(int a,int b=mod-2){
	int ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
inline int Add(const int&a,const int&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline int f(const int&n,const int&k){
	if(k==1)return (1ll*n*(n-1)>>1)%mod;
	return 1ll*n*pow(k-1)%mod;
}
signed main(){
	int i;
	scanf("%d%d%d",&n,&p,&k);
	w[0]=1;w[1]=pow(3,(mod-1)/k);
	for(i=2;i<=k;++i)w[i]=1ll*w[i-1]*w[1]%mod;
	for(i=0;i<k;++i)ans=Add(ans,1ll*pow((1ll*p*w[i]+1)%mod,n)*f(k,w[k-i])%mod);
	ans=(1ll*n*p%mod*pow(p+1,n-1)%mod-1ll*ans*pow(k)%mod+mod)%mod;
	printf("%d",1ll*ans*pow(k)%mod);
}
```

---

## 作者：Jμdge (赞：3)

一发 rk4 （如果把前面的两条鱼去重的话应该算是 rk3），感觉没什么好优化的了啊...前面的鱼为啥这么强，日常 ~~摸~~ 膜鱼  【雾

先来讲讲咱一开始的思路：

$$\begin{aligned}   Res= {1\over k} \Big(\sum_{i=0}^n \binom{n}{i} \times p^i \times i -\sum_{i=0}^n \binom{n}{i} \times p^i \times (i \% k) \Big)  \end{aligned}$$



前半部分很 sb ，等于 $np(p+1)^{n-1}$，后半部分尝试单位根搞

$$\begin{aligned}  &\sum_{i=0}^n \binom{n}{i} \times p^i \times (i \% k)  \\=& \sum_d d \sum_{i=0}^n \binom{n}{i} \times p^i [k|(i-d)] \\ =&  \sum_{d=0}^{k-1} d \sum_{i=0}^n \binom{n}{i} \times p^i \sum_{j=0}^{k-1} \omega_k^{(i-d)j}  \\   =&  \sum_{d=0}^{k-1} d \sum_{j=0}^{k-1}  \omega_k^{-dj}  \sum_{i=0}^n \binom{n}{i} \times p^i \omega_k^{ij}  \\   =&  \sum_{d=0}^{k-1} d \sum_{j=0}^{k-1}  \omega_k^{-dj}  ( \omega_k^j p +1)^n   \\   \end{aligned}$$

然后咱死了，好像不大会搞（虽说大概晓得这玩意儿可以用白兔之舞里面的质数积拆分搞成 法法塔的形式然后同样 k log k 玩...然鹅咱根本就不想打 法法塔 嘤嘤嘤）

于是在 苏指导 的指导下通过了此题...

首先咱发现原来的题目中最为棘手的是那个整除操作：

咱把那玩意儿转化一下，即  $\lfloor {i\over k} \rfloor = \sum_{j=0}^i [k|j] -1$ ，发现其实这玩意儿可以从 1 开始搞 ： $\lfloor {i\over k} \rfloor = \sum_{j=1}^i [k|j] $ 

然后套单位根反演：

 $$\lfloor {i\over k} \rfloor = \sum_{j=1}^i [k|j] = \sum_{j=1}^i \sum_{d=0}^{k-1}  \omega_k^{dj} =  \sum_{d=0}^{k-1} \omega_k^d {\omega_k^{id}-1\over \omega_k^d -1}  $$
 
后面那玩意儿就是等比数列求和，然后咱带入原式：

$$\begin{aligned}Res&=\sum_{i=0}^{n}  \binom{n}{i} p^i  \sum_{d=0}^{k-1} \omega_k^d {\omega_k^{id}-1\over \omega_k^d -1}  \\ &=  \sum_{d=0}^{k-1} {\omega_k^d\over \omega_k^d -1}    \sum_{i=0}^{n} \binom{n}{i} p^i ( \omega_k^{id}-1) \\&= \sum_{d=0}^{k-1} {\omega_k^d\over \omega_k^d -1}   \Big( \sum_{i=0}^{n} \binom{n}{i} p^i  \omega_k^{id} -\sum_{i=0}^{n} \binom{n}{i} p^i \Big)  \\&= \sum_{d=0}^{k-1} {\omega_k^d\over \omega_k^d -1}   \Big( (\omega_k^dp+1)^n -  (p+1)^n\Big)  \end{aligned}$$

然后就好 $k log n$ 计算了 【雾 ，假的

注意到 对于 d 不为 0 的其情况，等比数列求和时的 公比 $\omega_k^d$ 是不为 1 的，但是 $d=0$ 时就会出事，所以 d=0 的情况单独讨论：


$$\begin{aligned}Res_0&=\sum_{i=0}^{n}  \binom{n}{i} p^i  i \\&=\sum_{i=1}^{n}  \binom{n}{i} p^i  i  \\ &= \sum_{i=1}^{n}  \binom{n-1}{i-1} p^i n  \\&=np\sum_{i=1}^{n}  \binom{n-1}{i-1} p^{i-1}  \\&=np  (p+1)^{n-1}       \end{aligned}$$

原来是可以 log n 计算的东西 呢


那么，答案就是：

$$Res=np  (p+1)^{n-1}  + \sum_{d=0}^{k-1} {\omega_k^d\over \omega_k^d -1}   \Big( (\omega_k^dp+1)^n -  (p+1)^n\Big)    $$



# Code

```
//by Judge (zlw ak ioi)
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
using namespace std;
const int mod=998244353;
int n,p,k,w,wj,pn,res;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline void Pls(int& x,int y){if((x+=y)>=mod)x-=mod;}
inline int inc(int x,int y){return (x+=y)>=mod?x-mod:x;}
inline int qpow(int x,int p=mod-2){ Rg int s=1;
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
int main(){ scanf("%d%d%d",&n,&p,&k),w=qpow(3,(mod-1)/k);
	Pls(res,mul(mul(n,p),pn=qpow(p+1,n-1))),pn=mul(pn,p+1),wj=w;
	fp(i,1,k-1) Pls(res,mul(mul(wj,qpow(wj-1)),inc(qpow(mul(p,wj)+1,n),mod-pn))),wj=mul(wj,w);
	return !printf("%d\n",mul(res,qpow(k)));
}
```

---

## 作者：CTime_Pup_314 (赞：3)

~~考试时多项式推错惨遭爆零~~

首先，这道题很明显式子是一个二项卷积，考虑 `EGF`

不妨设 

$$
f=\sum_np^n\lfloor\frac{n}{k}\rfloor\frac{x^n}{n!}
$$

则答案为

$$
[x^n]e^x\times f
$$

现在考虑 $f$ 如何求出

由于 `EGF` 的移位和指标下放很好实现，所以考虑多项式

$$
\hat{f_n}=\sum_i[n|i]\frac{x^i}{i!}
$$

显然 $\hat{f}_2$ 很好求出，即为

$$
\hat{f}_2=\frac{e^x+e^{-x}}{2}
$$

这也启发我们 $\hat{f}_n$ 可以用若干个形如 $e^{kx}$ 组合出

于是我们想到了单位根，即

$$
w_n^{in}=1
$$

对于 $w_n^i$ 而言，有

$$
\frac{1}{n}\sum_{k=0}^{n-1}w_n^{ik}=[i=0]
$$

那么可以得出

$$\hat{f_n}=\frac{1}{n}\sum_{i=0}^{n-1}e^{w_n^ix}$$

同时根据 `EGF` 的性质

$$\frac{\partial\hat{f}_n}{\partial x^k}=\sum_i[n|(i+k)]\frac{x^i}{i!}$$

乘上 $\frac{x}{n}$ 就有

$$\frac{x}{n}\times\frac{\partial\hat{f}_n}{\partial x^k}=\sum_i[n|(i+k-1)]\frac{i}{n}\frac{x^i}{i!}$$

结合之前就有

$$\frac{x}{n}\times\frac{\partial\hat{f}_n}{\partial x^k}+\frac{k-1}{n}\times\frac{\partial\hat{f}_n}{\partial x^{k-1}}=\sum_i[n|(i+k-1)]\lceil\frac{i}{n}\rceil\frac{x^i}{i!}$$

所以当 $k\ge2$ 时

$$\frac{x}{n}\times\frac{\partial\hat{f_n}}{\partial x^k}+\frac{k-1}{n}\times\frac{\partial\hat{f_n}}{\partial x^{k-1}}-\frac{\partial\hat{f_n}}{\partial x^{k-1}}=\sum_i[n|(i+k-1)]\lfloor\frac{i}{n}\rfloor\frac{x^i}{i!}$$

综上讨论

$$f=\sum_{k=1}^n\frac{x}{n}\times\frac{\partial\hat{f_n}}{\partial{x^k}}+\sum_{k=1}^n\frac{k-1}{n}$$

而对于 $\frac{\partial\hat{f_n}}{\partial x^k}$ 有

$$\frac{\partial\hat{f_n}}{\partial x^k}=\frac{1}{n}\sum_{i=0}^{n-1}w_n^{ik}e^{w_n^ix}$$

根据交换求和式的技巧我们可以把式子简化为只有一个和式而无嵌套情况，以中间的和式为例

$$\sum_{k=1}^n\frac{k-1}{n}\times\frac{\partial\hat{f_n}}{\partial x^{k-1}}=\frac{1}{n^2}\sum_{i=0}^{n-1}\sum_{k=1}^n(k-1)\times w_n^{i(k-1)}e^{w_n^ix}$$

根据

$$
\sum_{i=1}^nix^{i-1}=\frac{nx^{n+1}-nx^n-x^n+1}{(x-1)^2}
$$

上面的式子可以化简为

$$\sum_{i=1}^{n-1}\frac{1}{n\times(w_n^i-1)}e^{w_n^ix}+\frac{n-1}{2\times n}e^x$$

其他同理

最后的问题只有单位根怎么求了，由于 $998244353$ 为 `NTT` 质数，所以 $2^k$ 的单位根就可以表示为 $3^{\frac{P-1}{2^k}}$

```cpp
#include <algorithm>
#include <cstring>
#include <queue>
#include <cctype>
#include <cstdio>
#include <bitset>
using namespace std;
typedef long long int64;
inline int read(int f = 1, int x = 0, char ch = ' ')
{
    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;
    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();
    return f*x;
}
const int P = 998244353;
int64 qpow(int64 a, int b)
{
    int64 ret = 1;
    for( ; b; b >>= 1, a = a*a%P) if(b&1) ret = a*ret%P;
    return ret;
}
int64 n, inv, inv2, p;
int ans, k;
int main()SS
{
    n = read(), p = read(), k = read();
    inv = qpow(k, P-2);
    ans = n*p%P*qpow(p+1, n-1)%P*inv%P;
    ans = (ans+(k-1)*qpow(2*k, P-2)%P*qpow(p+1, n)%P)%P;
    ans = (ans+P-qpow(p+1, n))%P;
    for(int i = 1, wn = qpow(3, (P-1)/k), w = wn; i < k; ++i, w = 1ll*w*wn%P)
        ans = (ans+qpow(w-1, P-2)*inv%P*qpow(w*p%P+1, n)%P)%P;
    for(int i = 0, w = 1, wn = qpow(3, (P-1)/k); i < k; ++i, w = 1ll*w*wn%P)  
        ans = (ans+inv*qpow(w*p%P+1, n)%P)%P;
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：hl666 (赞：2)

来吧让我们来推式子QAQ，首先第一步考虑把下取整拆了：

$$Ans=\sum_{i=0}^n C_n^i\times p^i\times \lfloor \frac{i}{k} \rfloor$$

$$=\sum_{i=0}^n C_n^i\times p^i\times \frac{i-i\mod k}{k}$$

$$=\frac{1}{k}\times(\sum_{i=0}^n C_n^i\times p^i\times i-\sum_{i=0}^n C_n^i\times p^i\times(i\mod k))$$

考虑对于括号内的式子前后分别计算，首先是

$$\sum_{i=0}^n C_n^i\times p^i\times i$$

有组合数有幂次考虑怎么化成**二项式定理**的形式，我们考虑用组合数吸收掉$i$：

$$\sum_{i=0}^n C_n^i\times p^i\times i=\sum_{i=1}^n n\times C_{n-1}^{i-1}\times p^{i}$$

$$=np\times\sum_{i=0}^{n-1} C_{n-1}^i\times p^i=np\times(p+1)^{n-1}$$

好了上面是热身，然后考虑怎么搞后面那部分：

$$\sum_{i=0}^n C_n^i\times p^i\times(i\mod k)$$

$i\mod k$显然很麻烦，我们考虑枚举$d=i\mod k$，那么有$(i-d)\mod k=0$，代进去有：

$$\sum_{i=0}^n C_n^i\times p^i\times(i\mod k)$$

$$=\sum_{d=0}^{k-1} d\times\sum_{i=0}^n C_n^i\times p^i[(i-d)\mod k=0]$$

然后下一步就要用到**单位根反演**了，不会的可以看[浅谈单位根反演](https://www.cnblogs.com/cjjsb/p/11728892.html)，代进去有：

$$\sum_{d=0}^{k-1} d\times(\sum_{i=0}^n C_n^i\times p^i\times \frac{1}{k}\sum_{j=0}^{k-1}\frac{\omega_k^{ij}}{\omega_k^{dj}})$$

$$=\frac{1}{k}\sum_{j=0}^{k-1}\sum_{d=0}^{k-1} \frac{d}{w_k^{dj}}\sum_{i=0}^n C_n^i\times(\omega_k^j\cdot p)^i$$

$$=\frac{1}{k}\sum_{j=0}^{k-1} (\omega_k^j\cdot p+1)^n\times\sum_{d=0}^{k-1} d\times(w_k^{k-j})^d$$

发现后面那个$\sum_{d=0}^{k-1} d\times(w_k^{k-j})^d$是做这题的关键，考虑怎么快速计算一个一般形式的问题：

$$S=\sum_{i=0}^{n-1} i\times r^i$$

方法其实挺多的，这里我用的是**扰动法**（不知道的可以到 **《具体数学》** 上看下）：

$$S=\sum_{i=0}^{n-1} i\times r^i$$

$$=\sum_{i=0}^{n-1} (i+1)\times r^{i+1} -n\times r^n$$

$$r\times\sum_{i=0}^{n-1} i\times r^i+r\times\sum_{i=0}^{n-1} r^i -n\times r^n$$

前面那一项我们发现$S$又被我们凑出来了，而后面那一项可以用**等比数列求和**得到通式，则：

$$S=r\times S+r\times \frac{r^n-1}{1-r}-n\times r^n$$

移项就得到$S=\frac{n\times r^n}{r-1}-\frac{r^{n+1}-r}{(r-1)^2} (r\not=1)$

然后想必大家也发现了这里没有考虑$r=1$的情况，而显然有：

$$S=\frac{n\times(n-1)}{2} (r=1)$$

综上所述这题就被解决了，而且由于$998244352=2^{23}\times 119$，因此在$k\in\{2^{\omega}|0\le\omega\le 20\}$时是存在单位根的

```cpp
#include<cstdio>
#define RI register int
#define CI const int&
using namespace std;
const int N=1<<20|5,mod=998244353;
int n,p,k,g,w[N],ans,ret;
inline int quick_pow(int x,int p=mod-2,int mul=1)
{
	for (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;
}
inline void inc(int& x,CI y)
{
	if ((x+=y)>=mod) x-=mod;
}
inline void dec(int& x,CI y)
{
	if ((x-=y)<0) x+=mod;
}
inline int sub(CI x,CI y)
{
	int t=x-y; return t<0?t+mod:t;
}
inline int S(CI r,CI n)
{
	if (r==1) return 1LL*n*(n-1)%mod*quick_pow(2)%mod;
	return sub(1LL*n*quick_pow(r,n)%mod*quick_pow(r-1)%mod,1LL*sub(quick_pow(r,n+1),r)*quick_pow(r-1,mod-3)%mod);
}
int main()
{
	scanf("%d%d%d",&n,&p,&k); g=quick_pow(3,(mod-1)/k);
	RI i; for (w[0]=i=1;i<=k;++i) w[i]=1LL*w[i-1]*g%mod;
	for (ans=1LL*n*p%mod*quick_pow(p+1,n-1)%mod,i=0;i<k;++i)
	inc(ret,1LL*quick_pow((1LL*w[i]*p%mod+1)%mod,n)*S(w[k-i],k)%mod);
	dec(ans,1LL*quick_pow(k)*ret%mod);
	return printf("%d",1LL*quick_pow(k)*ans%mod),0;
}
```



---


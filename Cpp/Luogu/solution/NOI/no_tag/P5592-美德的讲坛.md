# 美德的讲坛

## 题目描述

```
现在我很清楚地懂得了，以前人们寻求美德的教师时首先在寻求着什么。
人们在寻求安睡与促进安睡的罂粟花！
```

查拉图斯特拉在讲坛前听智者讲论睡眠的美德。他感到很无聊，于是观察一同听讲的少年们。

他发现少年们的衣着非常奇特。具体地说，少年们的衣着有 $60$ 种特点，第 $i$ 种特点的特征值为 $2^{i-1}$ 。

他每次会观察两个少年，如果有一种衣着特点只出现在一个少年身上，而不在另一个少年身上，查拉图斯特拉就会强迫症发作，并得到等同于该特点特征值的厌恶度。

他想要把少年们站成若干组，使得在每组中，不管他选哪两个少年，都会得到 $<x$ 点厌恶度。查拉图斯特拉称这样的组是好的。

他有时也会使一个少年自成一组，此时不管怎样这个组都是好的。

他想要知道，这样满足条件的组最多可以包含几个少年呢？

有时少年也会回家换衣服，回来时衣着特点会有所改变。

## 说明/提示

对于 $20\%$ 的数据，满足 $n\le 20$。

对于 $30\%$ 的数据，满足 $n\le 1000$。

对于 $50\%$ 的数据，满足 $n\le 50000$。

对于另外 $20\%$ 的数据，满足 $x$ 是 $2$ 的整次幂。

对于$80\%$的数据，满足$q=0$。

对于 $100\%$ 的数据，满足 $1\le ind\le n\le 100000,0\le q\le 100000,0\le x,a_i,val< 2^{60}$。

## 样例 #1

### 输入

```
10 10 4
6 10 1 1 6 9 0 5 3 0 
3 5
1 10
9 3
8 10
3 0
8 11
1 3
1 4
2 8
1 0```

### 输出

```
5
4
4
4
4
5
5
6
5
5
6```

# 题解

## 作者：_QAQ (赞：8)

结合了最小割，贪心，甚至还有点模拟费用流的贪心思想(((

首先有最小割模型，将所有 $(i,j)$有 $e_i \oplus e_j \geq k$ 的点对连边作最小割。

对应到 $\operatorname{Trie}$ 上的 $2$ 个节点 $x,y$，如何计算其子树内的点连边后得到的最小割。

注意到最小割即为网络流，若 $k$ 当前位权值为 $1$，意味着 $x_0$ 与 $y_0$ 无法匹配，$x_1$ 与 $y_1$ 无法匹配。

否则，若当前位权值为 $0$，意味着 $x_0$ 与 $y_1$ 一定能完全匹配，$x_1$ 与 $y_0$ 一定能完全匹配。

若 $|x_0|<|y_1|,|x_1|<|y_0|$，则答案为 $|x_0|+|x_1|$

若 $|y_0|<|x_1|,|y_1|<|x_0|$，则答案为 $|y_0|+|y_1|$

否则，以 $|x_0|<|y_1|,|x_1|>|y_0|$ 为例，答案显然为$\min(\operatorname{merge(x_1,y_1)},|y_1|-|x_0|,|x_1|-|y_0|)+|x_0|+|y_0|$

注意到修改时只会修改 $\log n$ 个节点的权值，类似记搜防止递归计算，保证复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+7,M=1e7+7; bool fl[M];
int n,q,tot,dep[M],siz[M],ans[M],ch[M][2];
long long k,w[N];
inline long long read(){
	long long num=0; char g=getchar(); while(g<48||57<g) g=getchar();
	while(47<g&&g<58) num=(num<<1)+(num<<3)+g-48,g=getchar(); return num;
}
inline void write(int u){
	if(u>9) write(u/10); putchar(u%10+'0');
}
inline void ins(int u,long long k){
	siz[u]++,fl[u]=0; if(dep[u]<0) return;
	if(k&(1ll<<dep[u])){
		if(!ch[u][1]) ch[u][1]=++tot,dep[tot]=dep[u]-1; ins(ch[u][1],k);
	}
	else{
		if(!ch[u][0]) ch[u][0]=++tot,dep[tot]=dep[u]-1; ins(ch[u][0],k);
	}
}
inline void del(int u,long long k){
	siz[u]--,fl[u]=0; if(dep[u]<0) return;
	if(k&(1ll<<dep[u])) del(ch[u][1],k); else del(ch[u][0],k);
}
inline int getans(int u,int v){
	if(!siz[u]||!siz[v]) return 0;
	
	if(dep[u]<0){
		if(u==v) return ans[u]=siz[u]-(siz[u]&1); return ans[u]=min(siz[u],siz[v]);
	}
	if(fl[u]&&fl[v]) return ans[u]; fl[u]=1,fl[v]=1;
	if(k&(1ll<<dep[u])){
		if(u==v) ans[u]=ans[v]=getans(ch[u][0],ch[v][1]);
		else ans[u]=ans[v]=getans(ch[u][0],ch[v][1])+getans(ch[u][1],ch[v][0]);
		return ans[u];
	}
	else{
		int fq=getans(ch[u][0],ch[v][0]),fw=getans(ch[u][1],ch[v][1]);
		if(u==v) ans[u]=fq+fw+min(siz[ch[u][0]]-fq,siz[ch[v][1]]-fw);
		else if(siz[ch[u][0]]<=siz[ch[v][1]]&&siz[ch[u][1]]<=siz[ch[v][0]]) ans[u]=siz[ch[u][0]]+siz[ch[u][1]];
		else if(siz[ch[u][0]]>=siz[ch[v][1]]&&siz[ch[u][1]]>=siz[ch[v][0]]) ans[u]=siz[ch[v][0]]+siz[ch[v][1]];
		else if(siz[ch[u][0]]<=siz[ch[v][1]]&&siz[ch[u][1]]>=siz[ch[v][0]]){
			fw=min(min(fw,siz[ch[v][1]]-siz[ch[u][0]]),siz[ch[u][1]]-siz[ch[v][0]]);
			ans[u]=fw+siz[ch[u][0]]+siz[ch[v][0]];
		}
		else{
			fq=min(min(fq,siz[ch[v][0]]-siz[ch[u][1]]),siz[ch[u][0]]-siz[ch[v][1]]);
			ans[u]=fq+siz[ch[u][1]]+siz[ch[v][1]];
		}
		ans[v]=ans[u]; return ans[u];
	}
}
int main(){
	n=read(),q=read(),k=read(),dep[1]=60,tot=1; int c;
	for(int i=1;i<=n;i++) w[i]=read(),ins(1,w[i]);
	write(max(n-getans(1,1),1)),putchar('\n');
	for(int i=1;i<=q;i++)
		c=read(),del(1,w[c]),w[c]=read(),ins(1,w[c]),write(max(n-getans(1,1),1)),putchar('\n');
	return 0;
}
```

---

## 作者：Reunite (赞：2)

咋模拟赛啥都能有原题。

---

先 $x\leftarrow x-1$，把 $<x$ 转为 $\le x$。

因为有两两异或这个东西，直接丢到 trie 上考虑，从高位往低位钦定，假设我们现在正在决策 $r_1,r_2$ 为根两个子树内的集合，正在第 $d$ 层，前面 $d-1$ 位已经对 $x$ 二进制顶满，记为 $solve(r_1,r_2,d)$。

转移分几种情况：

- $2^d\in x$，此时这一位若选 $0$，则一定可以全选，若选 $1$，则限制还在，需要递归处理，即 $\max(solve(ls_{r_1},rs_{r_2},d-1)+solve(rs_{r_1},ls_{r_2},d-1), sz_{r_1},sz_{r_2})$。就是决策这一位填 $0/1$，既然选择 $1$，那两个子树错位是不影响的，因此第一段是加。

- $2^d \notin x$，此时这一位必须选 $0$，则为 $\max(solve(ls_{r_1},ls_{r_2},d-1),solve(rs_{r_1},rs_{r_2},d-1))$。

- $2^d\le x$，此时说明如果前面位 $\oplus$ 为 $0$，后面任意是 $0/1$ 都不会超过 $x$，可以直接选择决策 $\max(sz_{r_1},sz_{r_2})$，因为 trie 上 $\text{LCA}$ 保证前面异或全是蛋。

---

每次暴力转移是 $nm\log$ 的，但是注意到，每次修改只会最多修改叶子到根链上 $O(\log V)$ 个节点，那我们直接把这 $O(\log V)$ 个点拉出来重新 dp 一下，或者加个记忆化即可。

复杂度 $O((n+m) \log V)$。不知道为啥有人写那么长。

---

```cpp
#include <bits/stdc++.h>
#define int long long
#define N 200005
using namespace std;
int T,n,m,k,tot;
int a[N],f[N*60],mp[N*60],s[N*60],h[N*60][2];
void ins(int x,int d){
	int u=1;
	mp[1]=0;
	for(int i=59;~i;i--){
		int c=(x>>i)&1;
		if(!h[u][c]) h[u][c]=++tot;
		u=h[u][c];
		s[u]+=d;
		mp[u]=0;
	}
}
int solve(int X,int Y,int d){
	if(!X||!Y||d==-1) return X==Y?s[X]:s[X]+s[Y];
	int &ans=f[X];
	if(mp[X]&&mp[Y]) return ans;
	if((k>>d)&1){
		if(X==Y) ans=solve(h[X][0],h[X][1],d-1);
		else ans=max({solve(h[X][0],h[Y][1],d-1)+solve(h[X][1],h[Y][0],d-1),s[X],s[Y]});
	}
	else{
		ans=max(solve(h[X][0],h[Y][0],d-1),solve(h[X][1],h[Y][1],d-1));
		if((1ll<<d)<=k) ans=max({ans,s[X],s[Y]});
	}
	mp[X]=mp[Y]=1;
	return ans;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	if(!k){while(m-->=0)puts("1");return 0;}
	tot=1;
	for(int i=1;i<=n;i++) cin>>a[i],ins(a[i],1);
	printf("%lld\n",solve(1,1,59));
	while(m--){int x,y;cin>>x>>y;ins(a[x],-1),ins(a[x]=y,1);printf("%lld\n",solve(1,1,59));}
}

```

---

## 作者：foreverlasting (赞：2)

[同时发表在博客里哦](https://foreverlasting1202.github.io/2019/10/14/%E7%BE%8E%E5%BE%B7%E7%9A%84%E8%AE%B2%E5%9D%9B/)

一道用$Trie$和$STL$瞎搞的题。
<!--more-->

先$orz\ hy$大佬。

还是太菜了，考场上这题都不会。。。而且当时想的做法也假了。退役稳了。

这道题，首先要考虑到分组这回事。

找到一个$2^{\omega}$，使得$2^{\omega}\leq x<2^{\omega+1}$，于是我们可以按$\frac{x}{2^{\omega}}$分组。明显的是，同组之内的异或和都会小于$x$，那么不同组呢？

观察可发现，只有$\frac{a}{2^{\omega}}\ xor\ \frac{b}{2^{\omega}}==1$的两组之间才有可能异或起来小于$x$。证明嘛，挺显然的，注意到$x$不是$2$的幂次就容易观察出来了。

有了这个性质，我们只要想办法算相邻的两组就好了。算的过程也不复杂，你用$01Trie$树维护一下子树大小，然后在两棵$Trie$上同时$dfs$，讨论当前这一位$x$的值，便可以得到答案。至于这个讨论怎么来的，你可以像官方题解说的考虑二分图匹配过程，也可以考虑一下贪心，这里的讨论大概是这样的：

```cpp
int solve(res a,res b,res dep){
        if(!a||!b)return 0;
        if(dep==-1)return 0;
        res a0=son[a][0],a1=son[a][1],b0=son[b][0],b1=son[b][1];
        if((x>>dep)&1)return solve(a0,b1,dep-1)+solve(a1,b0,dep-1);
        if((sum[a0]<sum[b1])==(sum[a1]<sum[b0]))return min(sum[a],sum[b]);
        if(sum[a0]<sum[b1])return min(solve(a1,b1,dep-1),min(sum[b1]-sum[a0],sum[a1]-sum[b0]))+sum[a0]+sum[b0];
        return min(solve(a0,b0,dep-1),min(sum[a0]-sum[b1],sum[b0]-sum[a1]))+sum[a1]+sum[b1];
    }
```

接下来就是修改。

我并没有看懂官方题解说的 _类似记忆华的过程_。

我的想法是利用$multiset$强行维护$\frac{a}{w^\omega}$的位置和值，然后每次大力讨论这次修改与原来值的关系，再用个$multiset$维护一下每个位置和它相邻位置的答案$ans[i]$，每次暴力删除再加入。至于$Trie$树，本来就是可以删除的。修改$ans[i]$每次再调用一遍相邻两个的$solve$，重新算一遍就好了。复杂度还是$O(nlog^2a_i)$（假设$n,q$同阶）。跑起来挺快的，写起来就有点长了，去掉调试还有$6.5KB$。

还要注意一下特判$x=0$的情况，这有点坑。

---

## 作者：Phartial (赞：1)

好题。

先考虑不带修的情况，自然地对 $a$ 建出从高位到低位的 01-Trie，设 $f(u)$ 为在节点 $u$ 的子树中选出若干个叶子，使得两两异或不超过 $x$ 时最多能选多少个。

设节点 $u$ 对应的数有 $d$ 位，那么如果 $x$ 的前 $d$ 位不为 $0$，我们就可以把 $u$ 子树中的叶子全选上；否则，考察 $x$ 的下一位：

- 若其为 $0$，则我们要么只能在 $L_u$ 里选，要么只能在 $R_u$ 里选，递归下去计算即可；
- 若其为 $1$，则我们要么只在 $L_u$ 里选，要么只在 $R_u$ 里选，要么同时在 $L_u$ 和 $R_u$ 里选一些。

发现最后一种情况超出了状态的表达范围，于是考虑扩展状态，记 $f(u,v)$（其中 $u\ne v$，且深度相同）表示同时在 $u,v$ 子树里选出若干个叶子，使得两两异或值不超过 $x$ 时最多能选多少个。

同样的，设 $y$ 表示 $u$ 对应的数异或上 $v$ 对应的数。若 $y$ 大于 $x$ 的前 $d$ 位，我们要么就只能在 $u$ 里面选，要么就只能在 $v$ 里面选；若 $y$ 小于 $x$ 的前 $d$ 位，我们就可以全选；否则，考察 $x$ 的下一位：

- 若其为 $0$，则我们要么只在 $u$ 里或只在 $v$ 里选，要么只能同时在 $L_u,L_v$ 里选，要么只能同时在 $R_u,R_v$ 里选。
- 若其为 $1$，则只有 $L_u,R_v$ 这一对和 $R_u,L_v$ 这一对有限制，只需同时在 $L_u,R_v$ 里选出若干个叶子，再从 $R_u,L_v$ 中选出若干个叶子即可。

注意到这一递归过程只和 $u,v,x$ 有关系，并且每个 $u$ 都只有一个需要算 $f(u,v)$ 的 $v$。于是对整颗树算答案相当于跑了一遍 dfs，时间复杂度与 Trie 大小同阶。

再考虑修改，由上面的性质，修改一条链只会改变与这条链相关的 $f$ 值，这只有 $\log V$ 个，于是写一个类似记忆化的东西就行了，总时间复杂度 $\Theta((n+q)\log V)$。

一些实现上的细节：可以发现递归过程中不会出现 $y>x$ 的情况，且当 $y=x$ 且 $x$ 的下一位为 $0$ 时，由于 $u\ne v$，$x$ 的前 $d$ 位必然不为 $0$，于是我们只在 $u$ 或 $v$ 里选时可以全选。这样可以规避掉一些无用的分支。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;
using ll = long long;

const int kN = 1e5 + 1, kV = 60, kS = kN * kV * 2;

struct E {
  int c[2], s, f;
  bool v;
} e[kS];
int n, q, c = 1;
ll k, a[kN];

void U(ll x, int v) {
  e[1].v = 0, e[1].s += v;
  int u = 1;
  for (int i = kV - 1; i >= 0; --i) {
    int &y = e[u].c[x >> i & 1];
    if (!y) {
      y = ++c;
    }
    e[u = y].v = 0, e[u].s += v;
  }
}
int F(int d, int x, int y) {
  if (!~d || !x || !y) {
    return e[x].s + e[y].s;
  }
  int &f = e[x].f;
  if (e[x].v && e[y].v) {
    return f;
  }
  e[x].v = e[y].v = 1;
  if (k >> d & 1) {
    if (x == y) {
      f = max({e[e[x].c[0]].s, e[e[x].c[1]].s, F(d - 1, e[x].c[0], e[x].c[1])});
    } else {
      f = F(d - 1, e[x].c[0], e[y].c[1]) + F(d - 1, e[x].c[1], e[y].c[0]);
    }
  } else {
    if (x == y) {
      f = max(F(d - 1, e[x].c[0], e[x].c[0]), F(d - 1, e[x].c[1], e[x].c[1]));
    } else {
      f = max({e[x].s, e[y].s, F(d - 1, e[x].c[0], e[y].c[0]), F(d - 1, e[x].c[1], e[y].c[1])});
    }
  }
  return f;
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> q >> k;
  if (!k--) {
    for (int i = 0; i <= q; ++i) {
      cout << "1\n";
    }
    return 0;
  }
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    U(a[i], 1);
  }
  cout << F(kV - 1, 1, 1) << '\n';
  for (int i; q--; ) {
    cin >> i, U(a[i], -1), cin >> a[i], U(a[i], 1);
    cout << F(kV - 1, 1, 1) << '\n';
  }
  return 0;
}
```

---


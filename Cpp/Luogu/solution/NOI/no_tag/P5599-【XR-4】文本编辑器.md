# 【XR-4】文本编辑器

## 题目背景

**赛时提醒：本题输入数据是 Windows 格式，而非 Linux 格式，所以在每一行末尾的 `\n` 之前有一个多余的 `\r` 字符。请使用 `scanf` 或 `cin` 读入数据，而非 `getline`，因为后者会多读入一个 `\r`。**

## 题目描述

小 X 在制作一个文本编辑器，现在需要实现最基本的“**查找和替换**”功能。

在文本编辑器中，文件是以一个长度为 $n$ 的字符串 $a$ 的形式存储的。

同时，用户拥有一个包含 $m$ 个**单词**的字典，每个单词都是一个字符串，称第 $i$ 个单词为 $s_i$。

接下来定义**查找和替换**功能：

- **查找功能**：有两个参数 $l, r$，表示询问对于字典中的每个**单词** $s_i$，$a[l : r]$ 中 $s_i$ 的出现次数之和。  
即询问 $\displaystyle \sum_{i=1}^{m} \mathrm{occur}(s_i, a[l : r])$，其中 $\mathrm{occur}(s, t)$ 表示字符串 $s$ 在字符串 $t$ 中的出现次数。

- **替换功能**：有三个参数 $l, r, t$，其中 $t$ 是一个字符串，表示将 $a[l : r]$ 替换为 $t$ 不断重复的结果。  
即如果把 $\texttt{Mds72SKsLL}$ 替换为 $\texttt{Rabb}$ 不断重复的结果，则原字符串变为 $\texttt{RabbRabbRa}$。

用户给出了 $q$ 个操作，每个操作是**查找**或**替换**之一，你需要正确回答每个**查找**操作的答案。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（7 points）：$n, m, q \le 50$，所有字符串长度 $\le 50$，时限 $1\text{s}$。
- Subtask 2（7 points）：$n, q \le 3000$，时限 $1\text{s}$。
- Subtask 3（13 points）：$m = 1$，时限 $2\text{s}$。
- Subtask 4（17 points）：没有**替换**操作，即 $\mathrm{op} = 1$，时限 $2\text{s}$。
- Subtask 5（18 points）：$n, q \le 8 \times 10^4$，$\displaystyle \sum |s_i| \le 50$，$\displaystyle \sum |t| \le 8 \times 10^4$，时限 $1\text{s}$。
- Subtask 6（13 points）：$n, q \le 5\times 10^4$，$\displaystyle \sum |s_i| \le 5\times 10^4$，$\displaystyle \sum |t| \le 5\times 10^4$，时限 $1\text{s}$。
- Subtask 7（25 points）：无特殊限制，时限 $2\text{s}$。

对于 $100\%$ 的数据：  
对 $n, m, q, l, r, \mathrm{op}$ 的限制：$1 \le l \le r \le n \le 10^6$，$1 \le m, q \le 10^5$，$\mathrm{op} \in \{ 1, 2 \}$。  
对字符串长度的限制：$|s_i| \le 50$，$\displaystyle \sum |s_i| \le 2 \times 10^5$，$\displaystyle \sum |t| \le 10^6$。  
所有字符串保证不为空串，且出现的字符属于集合 $\mathbf{\Sigma}$，其中 $\mathbf{\Sigma} = [\texttt a, \texttt z] \cup [\texttt A, \texttt Z] \cup [\texttt 0, \texttt 9]$，即所有大小写英文字母以及数字，故 $|\mathbf{\Sigma}| = 62$。

**需要特别注意的是，与文件相比，单词的长度是非常小的。在解题时你可能需要利用这一点。**

----

**【一些定义】**

对于一个长度为 $\mathrm{len}$ 的字符串 $s$，符号 $s[l : r]$（$1 \le l \le r \le \mathrm{len}$）表示 $s$ 中从 $l$ 到 $r$ 的**子串**。即 $s$ 中从第 $l$ 个字符到第 $r$ 个字符（包含端点）连续拼接在一起形成的字符串。  
对于一个字符串 $s$，符号 $|s|$ 表示它的长度。

## 样例 #1

### 输入

```
6 2 5
BBABBA
BB
BAB
1 1 6
2 3 5 A
1 2 3
2 1 6 B
1 1 5
```

### 输出

```
3
0
4
```

# 题解

## 作者：Alex_Wei (赞：19)

> [题目传送门](https://www.luogu.com.cn/problem/P5599)。

> 题意简述：给定长度为 $n$ 的文本串 $a$ 和有 $m$ 个单词的字典 $s_i$。$q$ 次操作，每次求出字典内所有单词在 $a[l,r]$ 的出现次数，或将 $a[l,r]$ 替换为 $t$ 不断重复的结果。

> $n,\sum |t|\leq10^6$，$m,q\leq 10^5$，$|s|\leq 50$，$\sum |s_i|\leq 2\times 10^5$。

---

假设没有修改操作，且 $m=1$，即字典中只有一个单词，记该单词长度为 $L$。
一个自然的想法是可以求出对于每个位置 $i$，$a[i-L+1,i]$ 是否匹配 $s_1$，记为 $f_i\ (f_1,f_2,\cdots,f_{L-1}=0)$，暴力匹配即可。

查询时，因为 $[l,l],[l,l+1],\cdots,[l,l+L-2]$ 长度不够，显然无法匹配 $s_1$，又因为 $[x-L+1,x]\ (x\geq l+L-1)$ 匹配时不受小于 $l$ 的位置的影响，即**不会因为 $a[1,l-1]$ 消失而导致 $[x-L+1,x]$ 的匹配情况改变（由于 $x\geq l+L-1$，所以 $x-L+1\geq l$）**。因此直接查询 $\sum_{j=x}^rf_j$ 即可。直接前缀和维护可以做到 $\mathcal{O}(q+nL)$，使用 KMP 可以优化到 $\mathcal{O}(q+n)$。

---

Subtask #3：如果有修改操作呢？事情就变得无比麻烦了。昨天尝试写了一下，甚至比正解还难写（doge）。

首先得处理这个循环的 $t$。~~当然，我不知道怎么处理，所以看了眼 s_r_f 的题解。~~ 注意到题目中说 **“与文件相比，单词的长度是非常小的（$L\leq 50$）”**，那么就好好利用一下这个性质。

首先，$f_{[l,l+L-2]}$ 肯定是没有什么好方法，只能暴力硬做，那么，这一部分的想法是：从 $l-L+1$ 开始跑 KMP，匹配到 $l+L-2$ 并暴力更新 $f_{[l,l+L-2]}$ 即可。为什么要从 $l-L+1$ 而不是 $l$ 开始跑：$f_l$ 是与 $a_{l-L+1}$ 有关的，所以从 $l$ 开始跑会导致 $f_{[l,l+L-2]}$ 全为 $0$，这显然是错误的。

同样的，对于 $f_{[r+1,r+L-1]}$，从 $r-L+2$ 开始跑 KMP，一直匹配到 $r+L-1$ 并暴力更新 $f_{[r+1,r+L-1]}$ 即可。

接下来处理中间那一大坨循环的 $t$，记其长度为 $T$。有一个并不显然但很好理解，同时也是最关键的性质：**修改过后，$f_i=f_{i+T}\ (l+L-1\leq i\leq r-T+1)$，也就是这部分 $f$ 会产生长度为 $T$ 的循环节**。根据题目所给条件，有 $a_{[i,i-L+1]}=a_{[i+T,(i+T)-L+1]}$（$i$ 的范围同上），所以显然。因此，求出循环节并用线段树维护即可。

当然，说起来简单，还有很多需要注意的地方：

- Q1：如何维护循环节？

  A1：一个循环节信息主要就是循环节的**开头位置，长度和循环节内每个位置的值。** 因此，需要维护每一个循环节 $id$（表示这是第 $id$ 次修改形成的循环节）的开头位置 $lp_{id}$，长度 $len_{id}$，以及每一个位置 $i$ 上的值 $d_{id,i}$。**循环节内位置从 $0$ 开始标号**。
  
  在线段树区间 $[l,r]$ 的懒标记内维护两个信息：$id$ 和 $hd$。$id$ 表示该标记是第 $id$ 次修改形成的循环节（**不是第 $id$ 个循环节**），$hd$ 表示该区间的起始位置 $l$ 在该循环节中的位置。
  
  在 pushdown 的时候，假设我们传入了三个参数 $l,r,x$ 表示从区间 $[l,r]$ 下传，该区间在线段树内编号为 $x$。先求出左区间和右区间的分界点 $m=\lfloor\frac{l+r}{2}\rfloor$，再求出右区间 $[m+1,r]$ 的起始位置 $m+1$ 在循环节的位置，记为 $mid$，则不难求出 $mid=(hd+(m+1)-l)\bmod len_{id}$，然后将 $id,hd$ 与 $id,mid$ 的懒标记分别赋给 $[l,m]$ 与 $[m+1,r]$，并更新其维护的区间 $f$ 之和：
  
  ```cpp
    void push(int l,int r,int x){ // pushdown
		if(laz[x].id){
			int m=l+r>>1;
			int id=laz[x].id,hd=laz[x].hd;
			int mid=(hd+(m-l+1))%len[id];
			mark(l,m,x<<1,id,hd);
			mark(m+1,r,x<<1|1,id,mid);
			val[x]=val[x<<1]+val[x<<1|1];
			laz[x].id=0;
		}
    }
  ```
  
  其中 `mark(l,r,x,id,hd)` 表示给在线段树内编号为 $x$ 的区间 $[l,r]$ 打上 $id,hd$ 的懒标记。此时我们求出该区间末位置在循环节 $id$ 中的位置 $tl=(hd+(r-l))\bmod len_{id}$，并求出 $[l,r]$ 间共有多少个循环节  $id$，然后更新即可。
  
  ```cpp
   void mark(int l,int r,int x,int id,int hd){ // mark lazytag & update
		laz[x]={id,hd};
		int ori=l-hd,tl=(r-ori)%len[id],rid=(r-ori)/len[id];
		if(rid==0)val[x]=pre[id][tl]-(hd?pre[id][hd-1]:0);
		else val[x]=pre[id][tl]+(rid*sum[id]-(hd?pre[id][hd-1]:0));
	} 
  ```
  
  一些代码说明：$ori$ 表示 $l$ 所在的循环节的开头，并假设其为第 $0$ 个循环节。$rid$ 表示 $r$ 在第 $rid$ 个循环节内。需要注意的是，这里的 $pre_{id,i}$ 是 $pre_{id}$ 的前缀和。$sum_{id}$ 表示循环节 $id$ 所有位置上的和，即 $sum_{id}=pre_{id,len_{id}-1}$。
  
- Q2：暴力匹配时怎么求出 $a$ 当前的内容？

  首先，需要求出的 $a$ 是一段区间，设其为 $[l,r]$。那么在线段树上**按序遍历**每一个区间 $[x,x]\ (l\leq x\leq r)$。具体来说，就算当前区间 $[l',r']\subseteq[l,r]$ 也不返回，直到访问到叶子结点 $[x,x]$。可以证明这样访问的时间复杂度为 $\mathcal{O}(\log n+len)$。又因为需要求出的长度不超过 $2L$，因此总时间复杂度为 $\mathcal{O}(q(\log n+L))$。
  
  若该区间有标记 $id,hd$，那么该位置上的字符应为 $t_{id,hd}$，即第 $id$ 次修改时给出的字符串 $t_{id}$ 的第 $hd$ 个位置上的字符。否则该位置上的字符应为 $a_x$。
  
  ```cpp
    void forms(int l,int r,int ql,int qr,int x){ // form current string [ql,qr]
		if(ql>qr)return;
		if(l==r){
			if(laz[x].id)tmp+=qt[laz[x].id][laz[x].hd];
			else tmp+=ct[l-1];
			return;
		} int m=l+r>>1; push(l,r,x);
		if(ql<=m)forms(l,m,ql,qr,x<<1);
		if(m<qr)forms(m+1,r,ql,qr,x<<1|1);
	}
  ```
  
- Q3：暴力匹配求出 $f$ 后怎么在线段树上修改？

  A3：同样，需要更新的 $f$ 也是一段区间 $[l,r]$。如法炮制，按序遍历每一个区间 $[x,x]\ (l\leq x\leq r)$，并修改 $f$ 的值即可。
  
  **由于求出 $a$ 的内容时需要每个节点的标记，而暴力修改 $f$ 的位置有的需要打标记，如 $[l,l+L-2]$，有的不需要，如 $[r+1,r+L-1]$，所以需要分情况讨论。**
  
  ```cpp
    void modifyc(int l,int r,int ql,int qr,int x,bool tg){ // brute force : change
		if(ql>qr)return;
		if(l==r){
			val[x]=f[l];
			if(tg)laz[x]={id,(l-lpos)%len[id]};
			return;
		} int m=l+r>>1; push(l,r,x);
		if(ql<=m)modifyc(l,m,ql,qr,x<<1,tg);
		if(m<qr)modifyc(m+1,r,ql,qr,x<<1|1,tg);
		val[x]=val[x<<1]+val[x<<1|1];
	} 
  ```

还有一些注意点（踩过的坑）：

- 正如 s_r_f 所说，为了使代码更简洁，我们可以将左边暴力匹配的区间 $[l-L+1,l+L-2]$ 的右端点向右稍微移动一点，使得新的右端点 $led$ 刚好是一段循环节的结尾。同时，**为了求出循环节，还要再向右匹配 $T$ 个位置。**
- 如果区间的长度太小，可以直接暴力匹配。
- 需要先求出 $sum_{id}$ 再更新，因为更新时需要用到 $sum_{id}$。

这样，时间复杂度为 $\mathcal(q(\log n+L)+\sum T)$。

---

看到这里，你可能以为我已经讲完了。实际上并没有，这只是 $m=1$ 的部分分。不过别担心，只要你会 AC 自动机，那么 $m$ 为多少都不是问题。

注意到字典是固定的，所以我们对其建立 AC 自动机。那么只需要将 $f_i$ 的定义改为：将 $a[1,i]$ 放在 AC 自动机上跑到的位置 $p$ 在 fail 树上与根节点之间的路径所包含的终止节点个数 $val_p$。即 $val_p=\sum_{i=1}^m [endpos_i\in \mathrm{path}(p,root)]$。一个套路的方法是将所有终止节点在 fail 树上的子树的 $val$ 值 $+1$，这样可以 $\mathcal{O}(1)$ 求 $f_i$。如果不理解上述方法，P5357，[请](https://www.luogu.com.cn/problem/P5357)。

注意到 $f_i$ 定义中的 $a[1,i]$ 可以改成 $a[i-L+1,i]\ (L=\max|s_j|)$，因为**任何一个单词 $s_j$ 与 $a$ 在位置 $i$ 的匹配情况不会受到 $a_x\ (x\leq i-L)$ 的影响（最长的单词与 $a$ 在位置 $i$ 的匹配的第一个位置为 $i-L+1$）**。

剩下来就和 $m=1$ 几乎一模一样，只不过在暴力匹配时的方式从跑 KMP 变成了跑 AC 自动机。总时间复杂度 $\mathcal{O}(\sum|s_i|+\sum|t_i|+q(\log n+L))$，其中 $L=\max |s_i|$。

```cpp
/*
	Powered by C++11.
	Author : Alex_Wei.
*/

#include <bits/stdc++.h>
using namespace std;

#define ll long long

const int N=1e6+5;
const int L=50+5;
const int Q=1e5+5;
const int S=2e5+5;

// basic variables
int lc,nw,q;
ll mp[1<<7],f[N];
string ct;

struct ACAM{
	int cnt,son[S][62],fa[S],val[S];
	void ins(string s){
		int p=0;
		for(char it:s){
			if(!son[p][mp[it]])son[p][mp[it]]=++cnt;
			p=son[p][mp[it]];
		} val[p]++;
	} void build(){
		queue <int> q;
		for(int i=0;i<62;i++)if(son[0][i])q.push(son[0][i]);
		while(!q.empty()){
			int t=q.front(); q.pop();
			for(int i=0;i<62;i++)
				if(son[t][i])fa[son[t][i]]=son[fa[t]][i],q.push(son[t][i]);
				else son[t][i]=son[fa[t]][i];
			val[t]+=val[fa[t]];
		}
	} void run(){ // get f
		int p=0;
		for(int i=1;i<=lc;i++)f[i]=val[p=son[p][mp[ct[i-1]]]];
	}
}ac;

// query variables
ll id,len[Q],sum[Q];
vector <ll> pre[Q];
string qt[Q];

// lazytag & Segment Tree
string tmp;
struct lazy{
	int id,hd;
}; struct SegTree{
	ll val[N<<2],lpos;
	lazy laz[N<<2];
	void build(int l,int r,int x){
		if(l==r){
			val[x]=f[l];
			return;
		} int m=l+r>>1;
		build(l,m,x<<1),build(m+1,r,x<<1|1);
		val[x]=val[x<<1]+val[x<<1|1];
	} void mark(int l,int r,int x,int id,int hd){ // mark lazytag & update
		laz[x]={id,hd};
		int ori=l-hd,tl=(r-ori)%len[id],rid=(r-ori)/len[id];
		if(rid==0)val[x]=pre[id][tl]-(hd?pre[id][hd-1]:0);
		else val[x]=pre[id][tl]+(rid*sum[id]-(hd?pre[id][hd-1]:0));
	} void push(int l,int r,int x){ // pushdown
		if(laz[x].id){
			int m=l+r>>1;
			int id=laz[x].id,hd=laz[x].hd;
			int mid=(hd+(m-l+1))%len[id];
			mark(l,m,x<<1,id,hd);
			mark(m+1,r,x<<1|1,id,mid);
			laz[x].id=0;
		}
	} void modifyt(int l,int r,int ql,int qr,int x){ // tag
		if(ql<=l&&r<=qr){
			mark(l,r,x,id,(l-lpos)%len[id]);
			return;
		} int m=l+r>>1; push(l,r,x);
		if(ql<=m)modifyt(l,m,ql,qr,x<<1);
		if(m<qr)modifyt(m+1,r,ql,qr,x<<1|1);
		val[x]=val[x<<1]+val[x<<1|1]; 
	} void modifyc(int l,int r,int ql,int qr,int x,bool tg){ // brute force : change
		if(ql>qr)return;
		if(l==r){
			val[x]=f[l];
			if(tg)laz[x]={id,(l-lpos)%len[id]};
			return;
		} int m=l+r>>1; push(l,r,x);
		if(ql<=m)modifyc(l,m,ql,qr,x<<1,tg);
		if(m<qr)modifyc(m+1,r,ql,qr,x<<1|1,tg);
		val[x]=val[x<<1]+val[x<<1|1];
	} ll query(int l,int r,int ql,int qr,int x){
		if(ql>qr)return 0;
		if(ql<=l&&r<=qr)return val[x];
		ll m=l+r>>1,ans=0; push(l,r,x);
		if(ql<=m)ans+=query(l,m,ql,qr,x<<1);
		if(m<qr)ans+=query(m+1,r,ql,qr,x<<1|1);
		return ans;
	} void forms(int l,int r,int ql,int qr,int x){ // form current string [ql,qr]
		if(ql>qr)return;
		if(l==r){
			if(laz[x].id)tmp+=qt[laz[x].id][laz[x].hd];
			else tmp+=ct[l-1];
			return;
		} int m=l+r>>1; push(l,r,x);
		if(ql<=m)forms(l,m,ql,qr,x<<1);
		if(m<qr)forms(m+1,r,ql,qr,x<<1|1);
	}
}st;

int main(){
//	freopen("P5599_5.in","r",stdin);
//	freopen("P5599_5.out","w",stdout);
	// mp
	for(int i='A';i<='Z';i++)mp[i]=i-'A';
	for(int i='a';i<='z';i++)mp[i]=26+(i-'a');
	for(int i='0';i<='9';i++)mp[i]=52+(i-'0');
	
	// read & init
	cin>>lc>>nw>>q>>ct;
	for(int i=1;i<=nw;i++){
		string wrd;
		cin>>wrd,ac.ins(wrd);
	} ac.build(),ac.run(),st.build(1,lc,1);
	
	// solve
	for(int i=1;i<=q;i++){
		int op,l,r,ls; scanf("%d%d%d",&op,&l,&r),ls=r-l+1,st.lpos=l;
		if(op==1){
			ll rpos=min(r,l+L),ans=0,p=0;
			tmp="",st.forms(1,lc,l,rpos,1);
			for(int i=l;i<=rpos;i++)ans+=ac.val[p=ac.son[p][mp[tmp[i-l]]]];
			printf("%lld\n",ans+st.query(1,lc,rpos+1,r,1));
		} else{
			string t; cin>>t,len[++id]=t.size(),pre[id].resize(len[id]);
			int lpos=max(1,l-L+1),rpos=min(lc,r+L-1),p=0;
			if(ls<=L*2+len[id]*2){
				tmp="",st.forms(1,lc,lpos,rpos,1); // get current string
				for(int i=lpos;i<=rpos;i++){
					char it=(i<l||i>r?tmp[i-lpos]:t[(i-l)%len[id]]);
					p=ac.son[p][mp[it]];
					if(i>=l)f[i]=ac.val[p];
				} st.modifyc(1,lc,l,r,1,1),st.modifyc(1,lc,r+1,rpos,1,0);
			} else{
				// front section : [l-L+1,l+L-1]
				int led=l+L-1,rbg=r-L+1;
				while((led-l)%len[id])led++;
				tmp="",st.forms(1,lc,lpos,l-1,1);
				for(int i=lpos;i<led+len[id];i++){
					char it=(i<l?tmp[i-lpos]:t[(i-l)%len[id]]);
					p=ac.son[p][mp[it]];
					if(i>=l){
						if(i<led)f[i]=ac.val[p];
						else pre[id][i-led]=(i>led?pre[id][i-led-1]:0)+ac.val[p];
					}
				} sum[id]=pre[id][len[id]-1];
				st.modifyc(1,lc,l,led-1,1,1),st.modifyt(1,lc,led,r,1);
				
				// back section
				tmp="",st.forms(1,lc,r+1,rpos,1),p=0;
				for(int i=rbg;i<=rpos;i++){
					char it=(i>r?tmp[i-r-1]:t[(i-l)%len[id]]);
					p=ac.son[p][mp[it]];
					if(i>r)f[i]=ac.val[p];
				} st.modifyc(1,lc,r+1,rpos,1,0);
			} qt[id]=t;
		}
	}
	
	return 0;
}

如果您看懂了这篇题解就点个赞吧 qwq。
```

---

## 作者：s_r_f (赞：16)

调这道题调了几天……$WA$了无数次……

### 前置知识$:$

$AC$自动机,线段树

建议对$AC$自动机的$fail$树的意义有所理解……不然可能你就只会$subtask1,2$了

## 题意

有一个长为$n$的字符串$.$

有一个包含$m$个单词的字典$s_i,$**字典中的字符串长度$|s_i|<=50$**,字符串总长$<=2 *10^5.$

有$q$个操作$:$

$1$ $l$ $r$ 表示查询$s[l,r]$在字典中匹配的次数

$2$ $l$ $r$ $t$ $($ $t$是一个字符串$,\sum|t| <= 10^6$ $)$ 表示把$s[l,r]$修改成字符串 $t$ 多次重复之后的结果。

$n <= 10^6,m,q <= 10^5$

## 算法1(subtask1,2) 

$n,q<=3000$

对模式串建出$AC$自动机$.$

修改$O(n)$暴力改$,$询问在$Trie$图上$O(n)$暴力即可$.$

复杂度$O(62 * \sum|s_i| + nq)$

## 算法2(subtask3)

$m=1$

令这个唯一的模式串长度为$L$

令$f(i)$为 $s[i-L+1,i]$ 是否 $=$ 模式串 

查询就是要查$f()$在 $[l+len-1,r]$ 的区间和$.$

但是$emmm$我们要支持区间修改$……$

可以发现一个修改操作只会对 $[l,r+L)$ 的信息产生影响。$($ 因为对答案有贡献的字符串长度一定$<=L$ $)$

我们发现修改是一个循环$,$而且信息$($ 即 $f(i)$ $)$显然会有一个长度为$|t|$的循环节$,$而且它一定会在经过$L$个字符之后出现$.$

那么我们考虑对循环节出现之前的部分暴力$,$把中间的部分改成循环节$.$维护循环节就直接线段树上打标记就可以了

最后因为区间右端点右边的信息也会变化$,$我们就把区间$(r,r+L)$的信息暴力修改即可。

所以单次修改复杂度$O(log_2n+L),$总复杂度$O(q*(log_2n+L))$

## 算法3(subtask4)

不带修改

令最长的$|s_i|$长度为$L$

考虑求出$f(i)$ 表示**所有以$i$为结尾的字符串**对答案的贡献之和$.$

那么$f(i)$就是在$AC$自动机上匹配 $s[1:i]$时$,$到达的点$u$在$fail$树上的$size($ 即$u$在$fail$树上包含了多少终止节点 $)$

不难发现对答案有贡献的字符串长度一定$<=L$

所以对于一个询问 $[l,r]$ 我们可以先暴力求出 $s[l:l+L-1]$ 的**所有子串**对答案的贡献$,$然后再查询$f$在区间 $[l+L,r]$上的区间和即可。 


复杂度$O((n+\sum|t|)*62 + q*L)$

## 算法4(所有子任务)

利用算法$3$的思想$,$一次询问的答案就是$\sum f(i)+g(l,l+L-1),$

其中$f(i)$的含义见上文$,
$ $g(l,r) = $ $s[l:r]$的**所有子串**对答案的贡献$.$

那我们只要能做到快速维护$\sum f(i)$就能通过这道题了$.$

由算法$2,$显然每次区间修改仍然会有循环节$.$

但是我们发现如果只维护$f$的话我们求不出循环节$.$

怎么办呢$?$ ~~把这题丢给兔队他就会告诉你需要维护什么~~

求循环节就是说我们在暴力修改完$[l,l+L-1]$之后需要知道匹配 $s[1:l+L-1]$ 到了$AC$自动机上的哪个点$.$ 也就是说$,$我们需要维护$u.$

我们考虑在线段树表示区间$[l,r]$的节点维护两个信息$:$

$u$ 表示匹配$s[1:r]$时匹配到了$AC$自动机上的哪个点$;$

$c$ 表示区间的$\sum f(i)$

然后$,$对于每个叶子节点$[i,i]$我们需要记录下这个点是什么字符$($ 方便维护 $u$ 和 $c$ $)$

那么对于一次查询$,$我们只要$[l,l+L)$暴力,$[l+L,r]$查$c$就可以了

怎么修改呢$?$

还是暴力修改$[l,l+L)$

然后先查一下$[l+L-1,l+L-1]$这个线段树节点的$u,$并用$u$来求出循环节$.$

然后对区间$[l+L,r]$做一下区间修改$.$

最后再把区间$[r+1,r+L)$的所有的$u$再暴力修改一下

没了$?$没了$.$

复杂度$O(62*\sum|s_i| + q*(logn+L))$

然而这说起来简单实际上并不好写$...$

### 一些~~珂怕~~的代码细节(针对算法4)

$1:$ 我们在线段树上做任何修改$[a,b]$之前$,$应该先把$a-1$的标记传到叶子节点$($ 或者提前查询好$u_{a-1}$ $)$

$2:$ 你会发现有一大堆要维护的东西$u,c,f,...$还有一堆字符串和$AC$自动机$...$所以注意下变量重名$!$ 建议封装一下$,$我写的时候没封装线段树$,$写到自闭$...$

$3:$ 为什么复杂度是$O(logn+L)?$暴力修改时$,$我们需要一次修改到所有要暴力修改的叶子节点$,$而不是每个位置都做一遍单点修改$,$否则绝对$T$飞$...$

$4:$ 注意一下你的打标记 $!$ $!$ $!$ 这个地方细节非常多 $!$ $!$ $!$ 

$5:$ 如果觉得$L$个字符之后找循环节太烦了$,$你可以选择把$L$变成一个比$50$大的$|t|$的倍数$.$


上代码$:$ $($ 线段树部分有注释 $)$

本人码风有点丑$,$求轻喷$...$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline char Getchar(){
	static char buf[3000000],*in = buf,*out = buf;
	if (in == out) out = (in=buf) + fread(buf,1,3000000,stdin); return *in++;
}
inline int read(){
    static int x; x = 0; static char c; c = Getchar();
    while (!isdigit(c)) c = Getchar();
    while (isdigit(c)) x = x * 10 + c - '0',c = Getchar();
    return x;
}
inline void write(LL x){ if (x > 9) write(x/10); putchar(x%10+'0'); }
short trans[256];
inline void build_trans(){
	static char c; static int i = 0;
	for (i = 0; i < 256; ++i) trans[i] = -1;
	for (i = 0,c = '0'; c <= '9'; ++c) trans[c] = i++;
	for (c = 'a'; c <= 'z'; ++c) trans[c] = i++;
	for (c = 'A'; c <= 'Z'; ++c) trans[c] = i++;
}
inline short Getc0(){ static char c; c = Getchar(); while (trans[c] == -1) c = Getchar(); return trans[c]; }
inline short Getc1(){ static char c; c = Getchar(); while (c != '\n' && trans[c] == -1) c = Getchar(); return trans[c]; }
const int N = 1000050,M = 100050,Q = 100050,Ls = 200050;
int n,m,q; short a[N];
struct Trie{
	int fail[Ls],f[Ls],ch[Ls][62],cnt;
	inline void build(){
		static int i,x; queue<int>q; while (!q.empty()) q.pop();
		for (i = 0; i < 62; ++i) if (ch[0][i]) q.push(ch[0][i]),fail[ch[0][i]] = 0;
		while (!q.empty()){
			x = q.front(),q.pop(),f[x] += f[fail[x]];
			for (i = 0; i < 62; ++i)
				if (ch[x][i]) fail[ch[x][i]] = ch[fail[x]][i],q.push(ch[x][i]);
				else ch[x][i] = ch[fail[x]][i];
		}
	}
	inline void ins(){
		static short c; static int now; now = 0,c = Getc1(); while (c == -1) c = Getc1();
		while (c ^ -1){ if (!ch[now][c]) ch[now][c] = ++cnt; now = ch[now][c],c = Getc1(); } ++f[now];
	}
}T;
int lent[Q],cntt; vector<short>t[Q]; vector<int>tu[Q],tc[Q]; vector<LL>tsc[Q];
inline void Gett(int id){
	static short c; c = Getc1(); while (c == -1) c = Getc1(); lent[id] = 0;
	while (c != -1) ++lent[id],t[id].push_back(c),c = Getc1();
	tu[id].resize(lent[id]); tc[id].resize(lent[id]); tsc[id].resize(lent[id]);
}
inline void maker(int id,int s){
	static int i;
	for (tu[id][0] = T.ch[s][t[id][0]],i = 1; i < lent[id]; ++i) tu[id][i] = T.ch[tu[id][i-1]][t[id][i]];
	for (i = 0; i < lent[id]; ++i) tc[id][i] = T.f[tu[id][i]];
	for (tsc[id][0] = tc[id][0],i = 1; i < lent[id]; ++i) tsc[id][i] = tsc[id][i-1] + tc[id][i];
}
LL dc[N<<2]; int node[N],dl[N<<2],du[N<<2],tag[N<<2],tpos[N<<2]; short dv[N<<2];
inline void up(int o){ dc[o] = dc[o<<1] + dc[o<<1|1],du[o] = du[o<<1|1]; }
inline void Build(int o,int l,int r){
	dl[o] = r-l+1,tag[o] = -1;
	if (l^r){ int mid = l+r>>1; Build(o<<1,l,mid); Build(o<<1|1,mid+1,r); up(o); return; }
	node[l] = o,dv[o] = a[l],du[o] = T.ch[du[node[l-1]]][dv[o]],dc[o] = T.f[du[o]];
}
inline void Tag(int o,int id,int p){
	static int siz; siz = dl[o];
	tag[o] = id,tpos[o] = p,dv[o] = t[id][p];
	if (p+siz-1 < lent[id]){
		du[o] = tu[id][p+siz-1];
		dc[o] = tsc[id][p+siz-1] - (p?tsc[id][p-1]:0);
		return;
	}
	dc[o] = tsc[id][lent[id]-1] - (p?tsc[id][p-1]:0);
	siz -= lent[id]-p;
	dc[o] += 1ll*siz/lent[id]*tsc[id][lent[id]-1];
	siz %= lent[id];
	dc[o] += (siz?tsc[id][siz-1]:0);
	du[o] = tu[id][(lent[id]-1+siz)%lent[id]];
}
inline void down(int o){
	if (tag[o] != -1){
		Tag(o<<1,tag[o],tpos[o]);
		Tag(o<<1|1,tag[o],(tpos[o]+dl[o<<1])%lent[tag[o]]);
		tag[o] = -1;
	}
}
int p,ll,rr,vv,nowu; LL qans; short addc[N<<2]; int lenc;
inline void Ask1(int o,int l,int r){ // ask the u for [1,p]
	if (l^r){ down(o); int mid = l+r>>1; if (p <= mid) Ask1(o<<1,l,mid); else Ask1(o<<1|1,mid+1,r); return; }
	qans = du[o];
}
inline void Ask2(int o,int l,int r){ // ask the sumc for [ll,rr]
	if (ll<=l&&rr>=r){ qans+=dc[o]; return; }
	down(o); int mid = l+r>>1; if (ll <= mid) Ask2(o<<1,l,mid); if (rr > mid) Ask2(o<<1|1,mid+1,r);
}
inline void Ask3(int o,int l,int r){ // ask the answer for [ll,rr]
	if (l^r){ down(o); int mid=l+r>>1; if (ll<=mid)Ask3(o<<1,l,mid); if (rr>mid) Ask3(o<<1|1,mid+1,r); return; }
	nowu = T.ch[nowu][dv[o]],qans += T.f[nowu];
}
inline void Add1(int o,int l,int r){ // bl change [l,l+len)
	if (l^r){ down(o); int mid = l+r>>1; if (ll <= mid) Add1(o<<1,l,mid); if (rr>mid) Add1(o<<1|1,mid+1,r); up(o); return; }
	dv[o] = addc[++lenc],du[o] = T.ch[du[node[l-1]]][dv[o]],dc[o] = T.f[du[o]];
}
inline void Add2(int o,int l,int r){ // bl update (r,r+len]
	if (l^r){ down(o); int mid = l+r>>1; if (ll <= mid) Add2(o<<1,l,mid); if (rr>mid) Add2(o<<1|1,mid+1,r); up(o); return; }
	du[o] = T.ch[du[node[l-1]]][dv[o]],dc[o] = T.f[du[o]];
}
inline void Add3(int o,int l,int r){ // modify [l+len,r]
	if (ll <= l && rr >= r){ Tag(o,vv,(l-ll)%lent[vv]); return; }
	down(o); int mid = l+r>>1; if (ll <= mid) Add3(o<<1,l,mid); if (rr>mid) Add3(o<<1|1,mid+1,r); up(o);
}

const int DL = 50;
int main(){
	build_trans();
	int i,j,op,l,r,nll,llen;
	n = read(),m = read(),q = read();
	for (i = 1; i <= n; ++i) a[i] = Getc0();
	T.cnt = 0; while (m--) T.ins(); T.build();
	Build(1,1,n);
	while (q--){
		op = read(),l = read(),r = read();
		if (op == 1){
			if (r-l+1 <= DL){
				ll = l,rr = r,nowu = qans = 0,Ask3(1,1,n),write(qans),putchar('\n');
				continue;
			}
			ll = l,rr = l+DL-1,nowu = qans = 0,Ask3(1,1,n);
			ll = l+DL,rr = r,Ask2(1,1,n),write(qans),putchar('\n');
		}
		else{
			Gett(++cntt); nll = lent[cntt];
			if (r-l+1 <= DL+nll){
				for (lenc = 0,i = 1,j = 0; i <= r-l+1; ++i,++j){
					if (j == lent[cntt]) j = 0;
					addc[++lenc] = t[cntt][j];
				}
				lenc = 0;
				if (l>1) p = l-1,Ask1(1,1,n);
				ll = l,rr = r,Add1(1,1,n);
				p = r,Ask1(1,1,n);
				ll = r+1,rr = r+DL,Add2(1,1,n);
				continue;
			}
			for (lenc = 0,i = 1,j = 0; i <= DL+nll; ++i,++j){
				if (j == lent[cntt]) j = 0;
				addc[++lenc] = t[cntt][j];
			}
			--j; while (j != lent[cntt]-1){ ++j; addc[++lenc] = t[cntt][j]; }
			llen = lenc; lenc = 0;
			if (r-l+1 <= llen){
				if (l>1) p = l-1,Ask1(1,1,n);
				ll = l,rr = r,Add1(1,1,n);
				p = rr,Ask1(1,1,n);
				ll = r+1,rr = r+DL,Add2(1,1,n);
				continue;
			}
			if (l>1) p = l-1,Ask1(1,1,n);
			ll = l,rr = l+llen-1,Add1(1,1,n);
			
			qans = 0,p = l+llen-1,Ask1(1,1,n); maker(cntt,qans);
			ll = l+llen,rr = r,vv = cntt,Add3(1,1,n);
			p = rr,Ask1(1,1,n);
			ll = r+1,rr = r+DL,Add2(1,1,n);
		}
	}
    return 0;
}
```

---

## 作者：MoYuFang (赞：5)

本文起笔于 ```2021.11.05```。

想了一小时，码了两小时，调了三小时，不写篇题解亏大了。

然后发现题解写了四小时。

前置知识：线段树 + $\text{AC}$ 自动机。

建议看之前先熟悉失配树。

#### 查询操作

查询的思路还是很好想的。

首先先说一下，用模式串代称单词，用目标串代称待匹配的串。

考虑在 $\text{AC}$ 自动机上匹配目标串，当匹配到第 $i$ 个字符时，$\text{AC}$ 自动机转移到了某一状态（节点） $u$ ，其代表目标串中以 $i$ 结尾的后缀与模式串集字典树能匹配的最长前缀。

通过 $\text{dfs}$ 失配树，我们可以得到每一个状态 $u$ 与多少个模式串匹配（失配树上 $u$ 的前缀链上打过多少标记），记作 $cnt(u)$。

如果一次查询查询的是整个区间 $[1,n]$ 那么直接累和每个位置的 $cnt$ 就是答案，即 $\sum_{i=1}^{n} cnt(sta(i))$，这里 $sta(i)$ 代表匹配目标串匹配到第 $i$ 个字符时 $\text{AC}$ 自动机的状态。

但如果查询的是某个子区间 $[l,r]$，直接累和 $\sum_{i=l}^{r} cnt(sta(i))$ 是不正确的，原因在于 $cnt(l)$ 可能包含了跨越左端点 $l$ 的模式串的贡献，得去除跨越端点 $l$ 的模式串的贡献。

题面的数据范围已经提示得很明显了，模式串的长度不超过 $50$，显然要在上面作文章。

不妨设给出的数据中最长的模式串的长度为 $d(d\leq 50)$，也即字典树的深度。

那么当 $i\in [l+d-1, r]$ 时，因为模式串长度不超过 $d$，则 $cnt(sta(i))$ 一定与第 $l-1$ 及之前的字符无关，即 $cnt(sta(i))$ 中不存在跨越左端点 $l$ 的模式串的贡献，所以 $\sum_{l+d-1}^{r} cnt(sta(i))$ 累和进答案是没问题的。

而 $i \in [l, l+d-2]$ 时，我们得勒令能产生贡献的模式串的长度不超过 $i-l+1$，这样才能保证产生贡献的模式串均不跨越左端点 $l$。

于是我们可以给 $\text{AC}$ 自动上每个状态 $u$ 定义一个深度 $dep(u)$，表示节点 $u$ 在字典树上的深度，且令根节点深度为 $0$，则 $dep(u)$ 就代表了 $u$ 所对应的前缀的长度，千万要想清楚这个 $dep$ 指的是字典树上的深度，不是失配树上的深度。

对于 $u=sta(i)\ \ (i\in[l,l+d-2])$，我们在失配树上跳祖先，跳到第一个满足 $dep(v)\leq i-l+1$ 的祖先 $v$，则 $cnt(v)$ 一定只包含且包含所有不跨越左端点 $l$ 的模式串的贡献，可以累和进答案了。再考虑到字典树的深度不超过 $50$，我们可以为每个状态 $u$ 预处理出 $fa(u,x)$，代表了状态 $u$ 在失配树上第一个 $dep$ 不超过 $x$ 的祖先，并认为 $fa(u,dep(u)) = u$。

那么一次查询的答案就是：
$$
\sum_{i=l}^{i+d-2}cnt(fa(sta(i),i-l+1)) + \sum_{i=l+d-1}^{r}cnt(sta(i))
$$
前半部分因为 $d$ 比较小的缘故可以暴力求，后半部分不可暴力求，但可用线段树求。

若 $r \leq i+d-2$，那么相应的，答案变成：
$$
\sum_{i=l}^{r}cnt(fa(sta(i),i-l+1))
$$

#### 修改操作

查询考虑好了，接下来该考虑修改了。

设一次修改中修改的区间是 $[l,r]$， 修改操作中给出了的串称作 $T$，$t$ 为 $T$ 的长度。

因为查询操作的回答只涉及到目标串的 $sta$，我们只需要关心修改操作对哪些 $i$ 的 $sta(i)$ 有影响以及影响后新的 $sta(i)$ 是什么。

首先可以肯定的是修改操作对 $i\in[1,l-1]$ 的 $sta(i)$ 没影响，同时因为 $i\in[r+d,n]$ 中的 $sta(i)$ 不存在跨越端点 $r+1$ 的模式串，修改操作其 $sta(i)$ 也没影响。

于是修改操作能影响的区间分成 $[l,r]$ 和 $[r+1,r+d-1]$ 两部分。

后一部分比较容易，只要求出了修改后的新 $sta(r)$ ，用它作为初始状态在 $\text{AC}$ 自动机上匹配原目标串的子串 $[r+1,r+d-1]$ 就可以求出 $[r+1,r+d-1]$ 的新 $sta$ 了。

因为目标串会随着修改操作不断变化，一会我们还需用数据结构维护目标串上每个位置是什么字符。

前半部分则很麻烦，如果题目没有搞出周期覆盖这一毒瘤的操作，而是让 $T$ 刚好嵌入区间 $[l,r]$ ，也即 $t=r-l+1$，那么因为 $\sum t \leq 10^6$，可以直接以 $sta(l-1)$ 作为初始状态在 $\text{AC}$ 自动机上匹配 $T$ 求出区间 $[l,r]$ 的新 $sta$。

不过周期串也有周期串的特性，显然当 $i\in[l+d-1,r]$，因为原目标串上第 $l-1$ 及之前的字符不再能影响到新 $sta(i)$ 了，于是新 $sta(i)$ 就会以 $t$ 为周期呈周期变化，即 $sta(i)=sta(i+t)$。

于是在处理修改操作时，我们先做一步判断。

若 $r \leq l+d+t-1$，直接暴力匹配出区间 $[l,r]$ 的新 $sta$。

若 $r > l+d+t-1$，先匹配出 $[l,l+d+t-2]$ 的新 $sta$，然后用 $[l+d-1, l+d+t-2]$ 里的新 $sta$（区间长度为 $t$）去周期覆盖 $[l+d+t-1,r]$ 里的新 $sta$。

这里称 $[l+d-1, l+d+t-2]$ 里的新 $sta$ 为数值区间，记作 $val([1,t])$。 

到这里修改操作的处理就清晰了，我们需要新的数据结构去实现周期覆盖这一操作。

总结一下，$sta$ 的维护需要用到区间覆盖，目标串的维护也需要用到区间覆盖，这个新数据结构要有两份去分别维护这两个操作。

形式化地描述这个新数据结构：

1. 给定 $l,r$ 和数值区间 $val([1,t])$ ，需要周期覆盖区间 $[l,r]$ 里的 $val$ 。
2. 给定 $i$ ，查询 $val(i)$ （即 $i$ 处的值）。
3. 给定 $i$ 和 $vl$，单点修改 $val(i)$ 为 $vl$。
4. 给定 $l,r$，查询 $\sum_{i=l}^{r} cnt(val(i))$。

︿(￣︶￣)︿，一开始我又双叒叕地去想平衡树了，想了一会放弃了，那码量令人崩溃。

不考虑平衡树，那考虑啥，分块可以吗？（不知道为什么潜意识里疯狂避开线段树）。

分块好像可以，首先用 ```vector``` 记录每次周期覆盖操作的数值区间 $val([1,t])$ ，对于每个块 $x$，对应区间 $[bl,br]$ ，若整个块在某次周期覆盖操作时被 $[l,r]$ 包括，则打上懒标记。

懒标记有两种，一种表示哪次周期修改 $v(x)$，一种表示左端点 $bl$ 对应的是 $val([1,t])$ 里的第几个值 $bg(x)$（$bg(x)$ 指的是 $bl$ 对应的值的位置，不是 $bl$ 对应的值）。

若块不完全在 $[l,r]$ 内，则暴力修改（暴力修改之前若块上有懒标记则还要先下传标记）并且不打上标记。

然后考虑打上懒标记后块的 $\sum_{i=bl}^{br} cnt(val(i))$ 如何求，这又要开一个 ```vector``` 记录每次区间周期覆盖操作的 $cnt(val[1,t])$ 的前缀和（强调一下是前缀和）。 

然后发现自己又双叒叕地石乐志，这分块维护操作是打懒标记啊，干嘛不用线段树。

于是这个新的数据结构可以用线段树实现，方法与上述分块方法大同小异。

总结一下，我们需要维护两颗线段树，两颗都要维护周期覆盖和单点查询的操作，一颗维护的是目标串每个位置上是什么字符，一颗维护的是目标串每个位置上所匹配的状态，后者还要维护区间求和。

算法上到这里这题就结束了，然后就是发挥超码力的时候了。

为了维护周期覆盖这一操作，你需要写一个细节巨多的线段树。

为了方便未来复习，这里记录一下这个线段树的核心实现，真心建议这一部分自己想，看题解没用，看了题解还是要自己想，不如不看题解。 

周期覆盖操作板子。

```cpp
//代码中 cnt(u) 代表了状态 u 的贡献。

#define maxn 1000005
#define maxq 100005
int rg; //线段树值域的最大值，即线段树的值域是 [1,rg]
vector<int> vs[maxq]; //记录周期覆盖时的数值区间 val([1,t])，下标从 1 开始
vector<ll> vsm[maxq]; //记录周期覆盖是 cnt(val[1,t]) 的前缀和，下标从 1 开始
//下标从 1 开始，下标 0 处补位了一个值，所以某次周期覆盖修改时数值区间的长度为 vs[*].size()-1
struct Seg{
    int v, //懒标记之一，记录该线段树区间 [tl,tr] 被哪次周期覆盖修改操作覆盖，0 则代表没有
    	b, //懒标记之一，记录左端点对应状态在 vs[v] 中的位置 
    	s; //单个点的状态，即 sta，仅在叶子节点处有意义
   	ll sm; //区间求和
}seg[maxn<<2];
#define v(x) seg[x].v
#define b(x) seg[x].b
#define s(x) seg[x].s
#define sm(x) seg[x].sm
#define lx (x<<1)
#define rx (rx<<1|1)

//push up 操作
void ud(int x){
    sm(x) = sm(lx) + sm(rx);
}

//该函数的作用是将懒标记作用到线段树上的某一节点
//x、tl和tr 分别代表线段树节点的编号、对应区间的左端点和右端点
//vl 代表周期覆盖操作的编号，bg 代表左端点 tl 对应的值在 vs[vl] 中的位置
void spread(int x, int vl, int bg, int tl, int tr){
    b(x) = bg; v(x) = vl;
    if (tl == tr){
        //标记到叶子节点时
        s(x) = vs[vl][bg];
        sm(x) = cnt(s(x));
        return;
    }
    int mi = (tl+tr)>>1, //中点
    	t = vs.size()-1, //数值区间 val([1,t]) 的长度
    	k = (tr-tl+1)/t, //代表区间 [tl,tr] 完整包含了几次数值区间 val([1,t])
    	ed = (bg+tr-tl-1)%t+1; //tl 对应的位置是 bg，tr对应的位置就是 (bg+tr-tl-1)%t+1 了
    sm(x) = k*vsm[vl][t]; //整段数值区间的贡献
    if (ed == bg-1 || (bg == 1 && ed == t)){//[tl,tr] 的长度是 t 的倍数的情况，直接 return 就行了
        return;
    } 
    else if (ed >= bg){ //累加贡献
        sm(x) += vsm[vl][ed]-vsm[vl][bg-1];
    }
    else{ //累加贡献
        sm(x) += vsm[vl][t]-vsm[vl][bg-1]+vsm[vl][ed];
    }
}

//push down 操作
void pd(int x, int tl, int tr){
    int mi = (tl+tr)>>1;
    spread(lx, v(x), b(x), tl, mi);
    //tl 对应 b(x)，mi+1 对应的就是 (b(x)+(mi+1)-tl-1)%t+1 即 (b(x)+mi-tl)%(vs[v(x)].size()-1)+1 了
    spread(rx, v(x), (b(x)+mi-tl)%(vs[v(x)].size()-1)+1, mi+1, tr);
	v(x) = b(x) = 0;
}

//周期覆盖操作
//vl 代表周期覆盖操作的编号，bg 代表左端点 l 对应的值在 vs[vl] 中的位置
void cover(int x, int vl, int bg, int l, int r, int tl, int tr){
    if (l == tl && r == tr) return spread(x, vl, bg, tl, tr);
    if (v(x)) pd(x, tl, tr);
    int mi = (tl+tr)>>1;
    if (r <= mi) cover(lx, vl, bg, l, r, tl, mi);
    else if (l > mi) cover(rx, vl, bg, l, r, mi+1, tr);
    else{
        cover(lx, vl, bg, l, mi, tl, mi);
    	//l 对应 b(x)，mi+1 对应的就是 (bg+mi-l)%(vs[vl].size()-1)+1 了
    	cover(rx, vl, (bg+mi-l)%(vs[vl].size()-1)+1, mi+1, r, mi+1, tr);
    }
    ud(x);
}

//单点查询
// p 是要查询的位置
void qry(int p){
    int x = 1, tl = 1, tr = rg, mi;
    while(tl < tr){
        //tl 对应 b(x)，p 对应的就是 (b(x)+p-tl-1)%(vs[v(x)].size()-1)+1 了
        if (v(x)) return (b(x)+p-tl-1)%(vs[v(x)].size()-1)+1;
    	mi = (tl+tr)>>1;
        if (p <= mi) x = lx, tr = mi;
        else x = rx, tl = mi+1;
    }
    //查询到了叶子节点
    return s(x);
}

//单点修改
//p 是要修改的位置，vl 是新的值（注意区别周期覆盖操作中的 vl，含义不同）
void mdf(int x, int vl, int p, int tl, int tr){
    if (tl == tr){ sm(x) = cnt(s(x) = vl); return; }
    if (v(x)) pd(x, tl, tr);
    int mi = (tl+tr)>>1;
    if (p <= mi) mdf(lx, vl, p, tl, mi);
    else mdf(rx, vl, p, mi+1, tr);
    ud(x);
}
```

$\text{AC}$ 自动机那部分没啥好说的，这玩意十分钟就能码出来。

完整的 ```7k``` 代码如下。

变量重名的问题纠结了好一会，代码丑到放久了自己都看不懂。

时间复杂度为 $O(d \cdot \sum s_i + q\cdot d \cdot \log n + \sum t)$，跑不满。

卡了点常，线段树的实现与上面描述的有些不同（不过无所谓，反正丑到没人看的）。

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <vector>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ll long long
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define _fev(p, u) for(re int (p) = head(u); (p); (p) = nex(p))
#define pb push_back
#define inf 0x7fffffff
#define maxn 1000005
#define maxm 200005
#define maxq 100005
#define maxs 51
#define maxc 62

template <class T>
void print(string name, T arr[], int n, int flag = 1){
	cout<<name<<":";
	_for(i, 0, n)cout<<" "<<arr[i+flag];
	cout<<endl;
}

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

char mstr[maxn], str[maxn];
int	ncnt = 1, ecnt = 1, rg, mpc[128], que[maxm], stk[maxn];
struct Edge{ int to, nex; } edge[maxm*2];
struct ACAM{ int head, fail, dep, nxt[maxc], fa[maxs]; ll cnt; } acam[maxm];
struct Seg{ int b, v, e, w, s; ll sm; } seg[maxn*4];
vector<int> vs[maxq];
vector<ll> vsm[maxq];
vector<char> vstr[maxq];
#define to(x) edge[x].to
#define nex(x) edge[x].nex
#define head(x) acam[x].head
#define fail(x) acam[x].fail
#define dep(x) acam[x].dep
#define cnt(x) acam[x].cnt
#define nxt(x, c) acam[x].nxt[c]
#define fa(x, i) acam[x].fa[i]
#define b(x) seg[x].b
#define v(x) seg[x].v
#define e(x) seg[x].e
#define w(x) seg[x].w
#define sm(x) seg[x].sm
#define s(x) seg[x].s
#define lx (x<<1)
#define rx (x<<1|1)

void spread(re int x, re int vl, re int bg, re int tl, re int tr){
	if (tl == tr) sm(x) = cnt(s(x) = vs[vl][bg]), v(x) = b(x) = 0;
	b(x) = bg; v(x) = vl;
	re int t = vs[vl].size()-1, ed = bg+(tr-tl+1)%t-1;
	sm(x) = (tr-tl+1)/t*vsm[vl][t];
	if (ed < bg) return;
	if (ed <= t) sm(x) += vsm[vl][ed] - vsm[vl][bg-1];
	else sm(x) += vsm[vl][t] - vsm[vl][bg-1] + vsm[vl][ed-t];
}

void pd(re int x, re int tl, re int tr){
	re int mi = (tl+tr)>>1;
	spread(lx, v(x), b(x), tl, mi);
	spread(rx, v(x), (b(x)+mi-tl)%(vs[v(x)].size()-1)+1, mi+1, tr);
	v(x) = b(x) = 0;
}

void ud(re int x){
	sm(x) = sm(lx) + sm(rx); 
}

void cover(int x, int vl, int bg, int l, int r, int tl, int tr){
	if (l == tl && r == tr) return spread(x, vl, bg, tl, tr);
	if (v(x)) pd(x, tl, tr);
	int mi = (tl+tr)>>1;
	if (r <= mi) cover(lx, vl, bg, l, r, tl, mi);
	else if (l > mi) cover(rx, vl, bg, l, r, mi+1, tr);
	else{
		cover(lx, vl, bg, l, mi, tl, mi);
		cover(rx, vl, (bg+mi-l)%(vs[vl].size()-1)+1, mi+1, r, mi+1, tr);
	}
	ud(x);
}

void mdf(int x, int *tmp, int l, int r, int tl, int tr){
	if (tl == tr){ v(x) = b(x) = 0; sm(x) = cnt(s(x) = tmp[1]); return; }
	if (v(x)) pd(x, tl, tr);
	int mi = (tl+tr)>>1;
	if (r <= mi) mdf(lx, tmp, l, r, tl, mi);
	else if (l > mi) mdf(rx, tmp, l, r, mi+1, tr);
	else mdf(lx, tmp, l, mi, tl, mi), mdf(rx, tmp+mi-l+1, mi+1, r, mi+1, tr);
	ud(x);
}

int qry_s(re int p){
	re int x = 1, tl = 1, tr = rg, mi;
	while(tl < tr){
		if (v(x)) return vs[v(x)][(b(x)+p-tl-1)%(vs[v(x)].size()-1)+1];
		mi = (tl+tr)>>1;
		if (p <= mi) x = lx, tr = mi;
		else x = rx, tl = mi+1;
	}
	return s(x);
}

ll qry_sm(int x, int l, int r, int tl, int tr){
	if (r < tl || l > tr) return 0;
	if (l <= tl && r >= tr) return sm(x);
	if (v(x)) pd(x, tl, tr);
	int mi = (tl+tr)>>1;
	return qry_sm(lx, l, r, tl, mi) + qry_sm(rx, l, r, mi+1, tr);
}

void spreads(re int x, re int vl, re int bg){
	w(x) = vl; e(x) = bg;
}

void pds(int x, int tl, int tr){
	re int mi = (tl+tr)>>1;
	spreads(lx, w(x), e(x));
	spreads(rx, w(x), (e(x)+mi-tl)%(vstr[w(x)].size()-1)+1);
	e(x) = w(x) = 0;
}

void chg(int x, int vl, int bg, int l, int r, int tl, int tr){
	if (l == tl && r == tr) return spreads(x, vl, bg);
	if (w(x)) pds(x, tl, tr);
	int mi = (tl+tr)>>1;
	if (r <= mi) chg(lx, vl, bg, l, r, tl, mi);
	else if (l > mi) chg(rx, vl, bg, l, r, mi+1, tr);
	else{
		chg(lx, vl, bg, l, mi, tl, mi);
		chg(rx, vl, (bg+mi-l)%(vstr[vl].size()-1)+1, mi+1, r, mi+1, tr);
	}
}

char qry_str(re int p){
	re int x = 1, tl = 1, tr = rg, mi;
	while(tl < tr){
		if (w(x)) return vstr[w(x)][(e(x)+p-tl-1)%(vstr[w(x)].size()-1)+1];
		mi = (tl+tr)>>1;
		if (p <= mi) x = lx, tr = mi;
		else x = rx, tl = mi+1;
	}
	return vstr[w(x)][e(x)];
}

void add_edge(re int u, re int v){
	to(++ecnt) = v; nex(ecnt) = head(u); head(u) = ecnt;
}

void insert(re char *str){
	re int u = 1, c;
	while(c = *str++){
		if (!nxt(u, c = mpc[c])) dep(nxt(u, c) = ++ncnt) = dep(u) + 1;
		u = nxt(u, c);
	}
	++cnt(u);
}

void dfs(int u){
	_fev(p, u){
		int v = to(p);
		cnt(v) += cnt(u);
		dfs(v);
	}
}

void build(){
	re int u, v, fro = 0, bac = 0;
	fail(1) = 1;
	_for(c, 0, maxc)
		if (v = nxt(1, c)) add_edge(fail(que[bac++] = v) = 1, v);
		else nxt(1, c) = 1;
	while(bac > fro){
		u = que[fro++];
		_for(c, 0, maxc)
			if (v = nxt(u, c)) add_edge(fail(que[bac++] = v) = nxt(fail(u), c), v);
			else nxt(u, c) = nxt(fail(u), c);
	}
	dfs(1);
	v = 1;
	_rfor(u, 1, ncnt){
		do{
			v = v == 1 ? u : fail(v);
			fa(u, dep(v)) = v;
		}while(v != 1);
		_for(i, 1, dep(u)) if (!fa(u, i)) fa(u, i) = fa(u, i-1);
	}
}

void handle(re int u, re int l, re int r, re char *str, re int len){
	re int top = 0, cur = 0;
	_rfor(i, l, r) stk[++top] = u = nxt(u, mpc[(int)str[cur = cur%len+1]]);
	mdf(1, stk, l, r, 1, rg);
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
	freopen("sample.out", "w", stdout);
	#endif
	
	_rfor(i, 'a', 'z') mpc[i] = i-'a';
	_rfor(i, 'A', 'Z') mpc[i] = i-'A'+26;
	_rfor(i, '0', '9') mpc[i] = i-'0'+52;
	re int n = rg = rdnt(), m = rdnt(), q = rdnt(), d = 0;
	sf("%s", mstr+1);
	vstr[q+1].pb(0); _rfor(i, 1, n) vstr[q+1].pb(mstr[i]);
	chg(1, q+1, 1, 1, n, 1, rg);
	_rfor(i, 1, m) sf("%s", str+1), d = max(d, (int)strlen(str+1)), insert(str+1);
	build();
	handle(1, 1, n, mstr, n);
	_rfor(i, 1, q){
		re int opt = rdnt(), l = rdnt(), r = rdnt();
		if (opt == 1){
			re ll ans = 0;
			if (l+d-1 <= r) ans = qry_sm(1, l+d-1, r, 1, rg);
			_rfor(j, l, min(l+d-2, r)){
				re int u = qry_s(j);
				ans += cnt(fa(u, min(dep(u), j-l+1)));
			}
			pf("%lld\n", ans);
		}
		else if (opt == 2){
			sf("%s", str+1);
			re int t = strlen(str+1), u = l>1?qry_s(l-1):1;
			if (r <= l+d+t-2){
				handle(u, l, r, str, t);
				u = stk[r-l+1];
			}
			else{
				handle(u, l, l+d+t-2, str, t);
				vs[i].pb(0); vsm[i].pb(0);
				_for(j, 0, t) vs[i].pb(stk[d+j]), vsm[i].pb(cnt(stk[d+j]) + vsm[i][j]);
				cover(1, i, 1, l+d+t-1, r, 1, rg);
				u = vs[i][(r-l-d-t+1)%t+1];
			}
			if (r < n){
				re int h = min(r+d-1, n);
				_rfor(j, r+1, h) mstr[j] = qry_str(j);
				handle(u, r+1, h, mstr+r, n);
			}
			vstr[i].pb('\0'); _rfor(j, 1, t) vstr[i].pb(str[j]);
			chg(1, i, 1, l, r, 1, rg);
		}
	}

	return 0;
}
```



---

## 作者：Achtoria (赞：3)

直接做是困难的，不妨依照部分分来思考。

## - Subtask 3

首先会进入一个误区：维护修改，通过循环串的性质在 $\tt KMP$ 自动机上优化遍历。

但可以发现这样很难处理，我们不妨 **直接维护** 每个位置的答案。

令唯一的模式串长度为 $d$，$f_i$ 为文本串 $[\max(i - d + 1, 1), i]$ 与模式串是否匹配。

查询直接求 $[L + d - 1, R]$ 的区间和即可。

考虑一次修改对 $f$ 的影响，显然仅会修改 $[L, R + d - 1]$ 中的 $f$。

并且，我们 **直接在序列上观察** 可以发现：

* ##### 修改后的 $f$ 会从 $L + d$ 开始呈长度为 $|t|$ 的周期性变化。

> 由于将区间修改为周期变化的字符串，那么与从 $L + d$ 开始与模式串的最长 $border$ 每隔 $|t|$ 个位置均相同。
> 
> 则可知从 $L + d$ 开始的串在 $\tt KMP$ 自动机上成周期性的遍历，故 $f$ 也从此位置开始呈长度为 $|t|$ 的周期性变化。

这意味着我们只需要在 $\tt KMP$ 自动机上暴力遍历 $|t|$ 个节点即可求得 $[L + d, R]$ 这一段在修改后的 $f$ 序列。

但需要注意的是，此时我们假定可以快速得到修改后的序列 $S_{1, L + d - 1}$ 在 $\tt KMP$ 自动机上遍历到的节点。

> 我们将求解这个节点的做法称为「待解决的问题 $1$」。

对此，我们本质上只需要支持：

* * 给定 $l, r$ 和一段序列 $t$，将 $l \sim r$ 替换为 $t$ 反复出现的结果。（若最后一段并非完整周期，则将非最后一段和最后一段看作两个修改）

* * 给定 $l, r$，区间查询序列的和。

这两个操作可以简单的使用线段树维护：

> 对于每一次修改，我们记录修改的序列元素，前缀和，后缀和，以及整体和。
> 
> 对于线段树上每个节点，我们维护该区间的和 $sum$，懒标记（当且仅当这个区间被某次修改覆盖时存在）：当前被第 $t$ 次操作覆盖，左边散块开始于 $t$ 序列中的 $l$，右边散块结束与 $t$ 序列的 $r$，中间整块的数量 $num$。
> 
> 打懒标记，懒标记下传，$\tt pushup$ 都是容易的。

由此我们以 $\mathcal{O(\sum |t| + q \log n)}$ 的优秀复杂度解决了 $[L + d, R]$ 的修改。

考虑完 $[L + d, R]$ 这一段的修改，接下来考虑 $[L, L + d - 1]$ 这一段的修改。

注意到 $d$ 很小，于是可以在 $S_{1, L - 1}$ 在 $\tt KMP$ 自动机上的节点开始往下直接遍历。

一样需要注意的是，此时我们假定可以快速得到 $S_{1, L - 1}$ 在 $\tt KMP$ 自动机上的节点。

> 我们将求解这个节点的做法称为「待解决的问题 $2$」。

此时我们惊喜地发现，由于我们往后暴力遍历到了 $S_{1, L + d - 1}$，由此我们解决了「待解决的问题 $1$」。

$[R + 1, R + d - 1]$ 的修改与 $[L, L + d - 1]$ 的修改操作是类似的（有一点差别，请自行解决），因此下面只考虑后者的修改。

但现在存在一个问题，我们可以 $\mathcal{O(d)}$ 获得 $[L, L + d - 1]$ 修改后的 $f$ 序列，但若要将其在线段树上修改，复杂度看上去将会是 $\mathcal{O(d \log n)}$ 的，不太行。

事实上，如果我们直接一次修改暴力遍历线段树至叶子节点，**其复杂度其实是 $\mathcal{O(d + \log n)}$ 的**。

> 我们找到区间 $[L, L + d - 1]$ 在线段树上定位的 $\log n$ 个区间，这里的复杂度是 $\mathcal{O(\log n)}$ 的。
> 
> 而接下来遍历的所有节点，实质上是这 $\log n$ 个区间下面的所有节点。
> 
> 又线段树的大小是线性的，因此这部分的节点数为 $\mathcal{O(d)}$。

至此，我们花费了 $\mathcal{O}(\sum |t| + q(\log n + d))$ 的花费将这个问题转化为解决：「待解决的问题 $2$」

由一开始的观察可知，$A$ 序列在 $\tt KMP$ 自动机上遍历得到的节点序列修改后与 $f$ 有 **一模一样** 的周期性。

由此我们使用维护 $f$ 的方法来维护 $A$ 序列在 $\tt KMP$ 自动机上遍历得到的节点序列 $z$，复杂度与 $f$ 的维护一致。

至此，我们以 $\mathcal{O(|\Sigma| \sum|s_i| + \sum |t| + q(\log n + d))}$ 的复杂度解决了这个子问题。

## - Subtask 4

同样考虑直接维护每个节点的答案，但由于这里为多模式串，因此需要改变定义。

令 $f_i$ 为 $A$ 中以 $i$ 结尾的子串与所有模式串的匹配次数。

令 $g_{i, j}$ 为 $A$ 中以 $j$ 结尾的子串与长度不超过 $j$ 的模式串匹配的次数。

初始信息我们直接维护出 $fail$ 树上每个节点的答案，用 $A$ 在 $\tt ACAM$ 上直接遍历并继承 $fail$ 树上的答案即可。 

预处理复杂度是 $\mathcal{O}(\sum |s|(d + |\Sigma|) + nd)$ 的。

一次查询的答案显然为：

$$\sum\limits_{i = L} ^ {L + d - 1} g_{i - L + 1, i} + \sum\limits_{i = L + d} ^ R f_i$$

对于前半部分，我们直接暴力，单次复杂度 $\mathcal{O(d)}$，后半部分我们前缀和查询。故复杂度瓶颈在于预处理。

## - Subtask 5 $\sim$ 7

考虑维护 $Subtask 4$ 中的两个值，查询也使用同样的方式。

虽然加入了多模式串，但我们发现 $f$ 修改的周期性依然存在，因此 $f$ 是容易维护的（节点序列 $z$ 也可以一样的维护）。

又我们维护了节点序列 $z$，因此我们在计算 $g$ 的贡献时可以先取出 $[L, L + d - 1]$ 的节点序列 $z$，然后直接暴力调用 $\tt ACAM$ 上预处理的每个节点的答案即可。

复杂度 $\mathcal{O}(\sum |s|(d + |\Sigma|) + \sum |t| + q(\log n + d))$。

~~毒瘤题，代码写了一晚上~~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i, l, r) for (int i = l; i <= r; ++i)
#define dep(i, l, r) for (int i = r; i >= l; --i)
const int N = 3e5 + 5;
const int M = 1e6 + 5;
const int K = 60 + 5;
struct tree { int l, r, t, num, sum; } ;
vector <int> U[N], pre[N], suf[N];
// U[i][0] 为第 i 次修改的长度，接下来为修改序列
// pre[i], suf[i] 分别为第 i 次修改序列的前缀 / 后缀和 
char s[M], t[M];
int n, m, q, z, l, r, x, opt, ans, totU, a[M], b[M], c[M];
// b 为用于暴力区间线段树修改的中转数组 

struct ST {
	#define ls (p << 1)
	#define rs (p << 1 | 1)
	#define mid ((l + r) >> 1)
	tree t[M << 2];
	void build (int p, int l, int r) {
		t[p].t = -1, t[p].num = t[p].sum = 0;
		if(l == r) { t[p].sum = a[l]; return ; }
		build(ls, l, mid), build(rs, mid + 1, r);
		t[p].sum = t[ls].sum + t[rs].sum;
	}
	int gi (int x, int l, int r, tree k) {
		if(x < l) return k.l;
		if(x > r) return k.r;
		int len = U[k.t][0];
		if(x - l + 1 <= len - k.l + 1) x = k.l + x - l;
		else x = (x - l - len + k.l - 1) % len + 1;
		return x;
	}
	// 求序列中 x 这个位置在修改序列中的位置 
	tree Get(int l, int r, int ul, int ur, tree k) {
		int len = U[k.t][0], id1, id2, sum, nL, nR;
		
		if(l <= ul) id1 = 0;
		else {
			if(l - ul + 1 <= len - k.l + 1) id1 = 0;
			else id1 = ceil(1.0 * (l - ul - len + k.l) / len);
		}
		if(r - ul + 1 <= len - k.l + 1) id2 = 0;
		else id2 = ceil(1.0 * (r - ul - len + k.l) / len);
		
		nL = gi(l, ul, ur, k), nR = gi(r, ul, ur, k);
		sum = pre[k.t][len] * (id2 - id1 - 1);
		sum += suf[k.t][nL] + pre[k.t][nR];
		
		return (tree){nL, nR, k.t, id2 - id1 - 1, sum};
	} 
	void down (int p, int l, int r) {
		if(t[p].t == -1) return ;
		t[ls] = Get(l, mid, l, r, t[p]), t[rs] = Get(mid + 1, r, l, r, t[p]);
		t[p].t = -1;
	}
	void update1 (int p, int l, int r, int x, int y, tree k) {
		if(x > y || y < l || x > r) return ;
		if(l >= x && r <= y) { t[p] = k; return ; }
		down(p, l, r);
		if(mid >= x) update1(ls, l, mid, x, min(y, mid), Get(l, mid, x, y, k));
		if(mid < y) update1(rs, mid + 1, r, max(x, mid + 1), y, Get(mid + 1, r, x, y, k));
		t[p].sum = t[ls].sum + t[rs].sum; 
	}
	// 支持区间覆盖 
	void update2 (int p, int l, int r, int x, int y) {
		if(x > y || y < l || x > r) return ;
		if(l == r) { t[p].sum = b[l]; return ; }
		down(p, l, r); 
		if(mid >= x) update2(ls, l, mid, x, y);
		if(mid < y) update2(rs, mid + 1, r, x, y);
		t[p].sum = t[ls].sum + t[rs].sum;
	}
	// 支持线段树暴力区间单点修改，中转数组为 b 
	int query (int p, int l, int r, int x, int y) {
		if(x > y || y < l || x > r) return 0;
		if(l >= x && r <= y) return t[p].sum;
		down(p, l, r);
		int ans = 0;
		if(mid >= x) ans += query(ls, l, mid, x, y);
		if(mid < y) ans += query(rs, mid + 1, r, x, y);
		return ans;
	}
	void Get (int p, int l, int r, int x, int y) {
		if(x > y || y < l || x > r) return ;
		if(l == r) { c[l] = t[p].sum; return ; }
		down(p, l, r);
		if(mid >= x) Get(ls, l, mid, x, y);
		if(mid < y) Get(rs, mid + 1, r, x, y);
	}
	// 支持线段树暴力区间取出，中转数组为 c 
} T[3];

namespace ACAM {
	#define Next(i, u) for (int i = h[u]; i; i = e[i].next)
	struct edge { int v, next; } e[N << 1];
	int cnt, tot, num, h[N], tr[N], fail[N], g[N][K], ch[N][K];
	void reset () {
		rep(i, 0, cnt) {
			fail[i] = 0;
			rep(j, 0, 62) ch[i][j] = g[i][j] = 0;
		}
		rep(i, 0, 25) tr['a' + i] = ++num;
		rep(i, 0, 25) tr['A' + i] = ++num;
		rep(i, 0, 9) tr['0' + i] = ++num;
		cnt = 0;
	}
	void insert (int n, char s[]) {
		int x = 0;
		rep(i, 1, n) {
			if(!ch[x][tr[s[i] - 0]]) ch[x][tr[s[i] - 0]] = ++cnt;
			x = ch[x][tr[s[i] - 0]];
		}
		++g[x][n];
	}
	void add (int u, int v) {
		e[++tot].v = v, e[tot].next = h[u], h[u] = tot;
		e[++tot].v = u, e[tot].next = h[v], h[v] = tot;
	}
	void dfs (int u, int fa) {
		rep(i, 1, 50) g[u][i] += g[fa][i];
		Next(i, u) if(e[i].v != fa) dfs(e[i].v, u);
	}
	void build () {
		queue <int> Q;
		rep(i, 1, 62) if(ch[0][i]) Q.push(ch[0][i]);
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			rep(i, 1, 62) {
				if(ch[u][i]) fail[ch[u][i]] = ch[fail[u]][i], Q.push(ch[u][i]);
				else ch[u][i] = ch[fail[u]][i];
			}
		}
		rep(i, 1, cnt) add(fail[i], i);
		dfs(0, -1);
		rep(i, 1, cnt) rep(j, 1, 50) g[i][j] += g[i][j - 1];
	}
} 
using namespace ACAM;

void Modify (int o, int l, int r, int m, int *a) {
	if(l > r) return ;
	++totU, U[totU].push_back(m);
	rep(i, 1, m) U[totU].push_back(a[i]);
	
	pre[totU].push_back(0), suf[totU].push_back(0);
	rep(i, 1, m) pre[totU].push_back(pre[totU][i - 1] + U[totU][i]);
	rep(i, 1, m) suf[totU].push_back(0);
	suf[totU][m] = U[totU][m];
	dep(i, 1, m - 1) suf[totU][i] = suf[totU][i + 1] + U[totU][i];
	
	T[o].update1(1, 1, n, l, r, (tree){1, (r - l) % m + 1, totU, l == r ? -1 : (int)ceil(1.0 * (r - l - 1) / m), 0});
} 

signed main () {
	scanf("%lld%lld%lld%s", &n, &m, &q, s + 1);
	
	reset();
	rep(i, 1, m) scanf("%s", t + 1), l = strlen(t + 1), insert(l, t);
	build();
	
	x = 0;
	rep(i, 1, n) x = ch[x][tr[s[i] - 0]], a[i] = g[x][50];
	T[0].build(1, 1, n);
	x = 0;
	rep(i, 1, n) x = ch[x][tr[s[i] - 0]], a[i] = x;
	T[1].build(1, 1, n);
	rep(i, 1, n) a[i] = s[i];
	T[2].build(1, 1, n);
	
	while (q--) {
		scanf("%lld%lld%lld", &opt, &l, &r);
		if(opt == 2) {
			scanf("%s", t + 1), m = strlen(t + 1);
			rep(i, 1, m) a[i] = t[i];
			Modify(2, l, r, m, a);
			
			int cur = T[1].query(1, 1, n, l - 1, l - 1);
			rep(i, l, min(l + 49, r)) 
				cur = ch[cur][tr[t[(i - l) % m + 1] - 0]], b[i] = cur;
			T[1].update2(1, 1, n, l, min(l + 49, r));
			rep(i, min(l + 49, r) + 1, min(l + 49, r) + m) 
				cur = ch[cur][tr[t[(i - l) % m + 1] - 0]], a[i - min(l + 49, r)] = cur;
			Modify(1, min(l + 49, r) + 1, r, m, a);
			cur = T[1].query(1, 1, n, r, r);
			T[2].Get(1, 1, n, r + 1, min(r + 49, n));
			rep(i, r + 1, min(r + 49, n)) 
				cur = ch[cur][tr[c[i]]], b[i] = cur;
			T[1].update2(1, 1, n, r + 1, min(r + 49, n));
			// 修改 A 序列对应的 ACAM 上的节点序列 
			
			cur = T[1].query(1, 1, n, l - 1, l - 1);
			rep(i, l, min(l + 49, r)) 
				cur = ch[cur][tr[t[(i - l) % m + 1] - 0]], b[i] = g[cur][50];
			T[0].update2(1, 1, n, l, min(l + 49, r));
			rep(i, min(l + 49, r) + 1, min(l + 49, r) + m) 
				cur = ch[cur][tr[t[(i - l) % m + 1] - 0]], a[i - min(l + 49, r)] = g[cur][50];
			Modify(0, min(l + 49, r) + 1, r, m, a);
			T[1].Get(1, 1, n, r + 1, min(r + 49, n));
			rep(i, r + 1, min(r + 49, n)) b[i] = g[c[i]][50];
			T[0].update2(1, 1, n, r + 1, min(r + 49, n));
			// 修改 f 
		}
		else {
			ans = T[0].query(1, 1, n, l + 50, r);
			T[1].Get(1, 1, n, l, min(l + 49, r));
			rep(i, l, min(l + 49, r)) ans += g[c[i]][i - l + 1];
			printf("%lld\n", ans);
		}
	}
	return 0;
}
```

---

## 作者：moonbowqwq (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P5599)

历时一年成功 A 了这道题，祝你成功。

~~不过跑的顶慢的就是。~~

## 题意简述

有一个长度为 $n$ 的文本串 $a$，以及 $m$ 个**长度不超过** $50$ 的模式串。

有 $q$ 次操作，每次操作为以下两种之一：

1. 给定 $l$ 和 $r$，求所有模式串在 $a_l$ 到 $a_r$ 之间出现的次数的和值；
2. 给定 $l$ 和 $r$ 以及字符串 $t$，将 $a_l$ 到 $a_r$ 之间的内容替换为 $t$ 不断重复的结果。


数据范围与约定：$1 \le l \le r \le n \le 10^6,1 \le m,q \le 10^5$，保证字符串 $t$ 的长度总和不超过 $10^6$。

## 解题思路

所用到的知识点：AC 自动机 + 线段树。

先考虑如何处理操作一。我们可以先建出模式串的 AC 自动机，对于每次询问，直接用 AC 自动机从 $a_l$ 到 $a_r$ 跑一遍即可。

考虑如何进行优化。由于文本串是固定的，所以我们可以先用 AC 自动机从 $a_1$ 到 $a_n$ 跑一遍，求出每个位置在 AC 自动机上对应位置的匹配数，然后用线段树实现区间求和就可以得到答案了……吗？

注意，这样做会存在一个问题：某个模式串可能不完全在询问区间，但我还是统计了它的贡献，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2qnb1btl.png?x-oss-process=image/resize,m_pad,h_300,w_1100)

那么又该如何统计呢？注意到模式串的长度很小，最大的只有 $50$，所以这种模式串只可能出现在 $[l,l + 48]$ 这段区间内，因而我们可以考虑将答案分成两部分来统计。对于完全在 $[l,l + 48]$ 中的模式串，我们直接用 AC 自动机暴力匹配来求出其数量；而对于以 $[l + 49,r]$ 中字符结尾的模式串，我们再按照上面的思路用线段树区间求和得到其数量，最后把两个值加在一起就得到答案了。

延续操作一的思路，接下来考虑如何处理操作二。我们可以发现，对于每次操作二，其对之前预处理出的数据（也就是原先 AC 自动机匹配到的位置）的影响范围是 $[l,r + 49]$（这里从 $[l,r]$ 拓展到 $[l,r + 49]$ 也是因为模式串的长度很小）。也就是说，在我们把 $[l,r]$ 之间的数据修改完以后，我们只需要再重新处理出 $[r + 1,r + 49]$ 的数据即可，这一部分也是可以通过用 AC 自动机暴力匹配来解决的。

这样问题就只剩下如何处理 $[l,r]$ 之间的数据了。注意到本题的修改操作是用一个字符串来循环替换，并且用于修改操作的字符串总长度不超过 $10^6$，这启示我们可以通过寻找循环节来进行区间修改操作。

字符的修改比较简单，可以直接用线段树来维护，具体的这里就不赘述了，接下来我们考虑如何求每个位置在 AC 自动机上对应位置的匹配数。

对于 $[l,l + 49]$ 部分，由于其可能会受到 $[l - 49,l - 1]$ 这部分字符的影响，所以这里我们也是直接暴力匹配，暴力修改。然后对于剩下的部分，我们可以发现其修改后的数据是一个长度为 $|t|$ 的循环节，所以直接将循环节存下来后用线段树维护即可。

## 代码实现

```cpp
#include<bits/stdc++.h>

#define lol long long

using namespace std;

int NRC(char c);
lol LAST(int id,int loc);
lol Occur(int id,int loc,int len);
void Function1();
void Function2();

const int MN = 1e6,MS = 2e5,MC = 62,MQ = 1e5;

int N,M,Q;
char A[MN + 5];

int NT;
string T[MQ + 5];
vector<int> LAC[MQ + 5];//对应的在AC自动机上的位置
vector<lol> PRE[MQ + 5];//匹配数的前缀和(感觉用树状数组更方便?)

class Aho_Corasick{
private:
  struct tree_node{
    int son[MC],tail,fail;
  }tn[MS + 5];
  int num_tn;
public:
  void Insert(){
    string s;
    cin >> s;
    int now_tn = 0;
    for(int i = 0;i < s.size();++i){
      s[i] = NRC(s[i]);
      if(tn[now_tn].son[s[i]] == 0)
	tn[now_tn].son[s[i]] = ++num_tn;
      now_tn = tn[now_tn].son[s[i]];
    }
    ++tn[now_tn].tail;
  }
  void Build(){
    queue<int> have;
    for(int i = 0;i < MC;++i)
      if(tn[0].son[i] != 0)
	have.push(tn[0].son[i]);
    while(!have.empty()){
      int now_tn = have.front();
      have.pop();
      tn[now_tn].tail += tn[tn[now_tn].fail].tail;
      for(int i = 0;i < MC;++i)
	if(tn[now_tn].son[i] != 0){
	  tn[tn[now_tn].son[i]].fail = tn[tn[now_tn].fail].son[i];
	  have.push(tn[now_tn].son[i]);
	}
	else
	  tn[now_tn].son[i] = tn[tn[now_tn].fail].son[i];
    }
    return;
  }
  tree_node& operator[](const int id){
    return tn[id];
  }
}AC;

class Segment_Tree{
private:
  struct tree_node{
    lol sum;
    int len;
    int id,loc;//lazy tag
  }tn[MN + 5 << 2];
  int lac[MN + 5];
  void Pupdate(int now,int loc,int val,char c){
    lac[loc] = val;
    A[loc] = c;
    tn[now].sum = AC[val].tail;
    return;
  }//更新当前叶子节点的信息和其对应位置的AC自动机匹配位置和字符
  void Iupdate(int now,int id,int loc,int l){
    loc %= T[id].size();
    if(tn[now].len == 1)
      Pupdate(now,l,LAC[id][loc],T[id][loc]);
    else{
      tn[now].sum = Occur(id,loc,tn[now].len);
      tn[now].id = id;
      tn[now].loc = loc;
    }
    return;
  }//用懒标记更新当前非叶子结点的信息
  void Push_up(int now){
    tn[now].sum = tn[now << 1].sum + tn[now << 1 | 1].sum;
    return;
  }
  void Push_down(int now,int l1,int l2){
    if(tn[now].id == 0)
      return;
    Iupdate(now << 1,tn[now].id,tn[now].loc,l1);
    Iupdate(now << 1 | 1,tn[now].id,tn[now].loc + l2 - l1,l2);
    tn[now].id = 0;
    return;
  }
public:
  void Build(int now,int l,int r){
    tn[now].len = r - l + 1;
    if(l == r){
      Pupdate(now,l,AC[lac[l - 1]].son[NRC(A[l])],A[l]);
      return;
    }
    Build(now << 1,l,l + r >> 1);
    Build(now << 1 | 1,l + r + 2 >> 1,r);
    Push_up(now);
    return;
  }
  void PCoper(int now,int l,int r,int tar,int val,char c){
    if(r < tar || l > tar)
      return;
    if(l == r){
      Pupdate(now,l,val,c);
      return;
    }
    Push_down(now,l,l + r + 2 >> 1);
    PCoper(now << 1,l,l + r >> 1,tar,val,c);
    PCoper(now << 1 | 1,l + r + 2 >> 1,r,tar,val,c);
    Push_up(now);
    return;
  }
  void ICoper1(int now,int l,int r,int tal,int tar,int id,int loc){
    if(r < tal || l > tar)
      return;
    if(l >= tal && r <= tar){
      Iupdate(now,id,loc + l - tal,l);
      return;
    }
    Push_down(now,l,l + r + 2 >> 1);
    ICoper1(now << 1,l,l + r >> 1,tal,tar,id,loc);
    ICoper1(now << 1 | 1,l + r + 2 >> 1,r,tal,tar,id,loc);
    Push_up(now);
    return;
  }
  void ICoper2(int now,int l,int r,int tal,int tar){
    if(r < tal || l > tar || l == r)
      return;
    Push_down(now,l,l + r + 2 >> 1);
    ICoper2(now << 1,l,l + r >> 1,tal,tar);
    ICoper2(now << 1 | 1,l + r + 2 >> 1,r,tal,tar);
    return;
  }//将区间内的懒标记全部下传，以得到该区间的AC自动机匹配位置和字符
  lol IQoper(int now,int l,int r,int tal,int tar){
    if(r < tal || l > tar)
      return 0;
    if(l >= tal && r <= tar)
      return tn[now].sum;
    Push_down(now,l,l + r + 2 >> 1);
    return IQoper(now << 1,l,l + r >> 1,tal,tar) + IQoper(now << 1 | 1,l + r + 2 >> 1,r,tal,tar);
  }
  int operator[](const int id) const{
    return lac[id];
  }
}SEG;

int main(){
  ios::sync_with_stdio(false);
  cin >> N >> M >> Q >> A + 1;
  for(int m = 0;m < M;++m)
    AC.Insert();
  
  AC.Build();
  SEG.Build(1,1,N);
  
  for(int q = 0,op;q < Q;++q){
    cin >> op;
    switch(op){
    case 1:Function1();break;
    case 2:Function2();break;
    }
  }
  return 0;
}

int NRC(char c){
  if(c <= '9')
    return c - '0';
  if(c <= 'Z')
    return c - 'A' + 10;
  return c - 'a' + 36;
}

lol LAST(int id,int loc){
  if(loc == 49)
    return 0;
  return PRE[id][(loc + T[id].size() - 1) % T[id].size()];
}

lol Occur(int id,int loc,int len){
  lol res = PRE[id][48] * (int)floor((double)len / T[id].size());
  len %= T[id].size();
  if(len > 0){
    int l = loc,r = (loc + len - 1) % T[id].size();
    if((l <= r && (r < 49 || l >= 49)) || (r < l && l  >= 49 && r < 49))
      res += PRE[id][r] - LAST(id,l);
    else
      res += PRE[id][48] - LAST(id,l) + PRE[id][r];
    //这里本来是分类讨论，化简以后就变成了这样
  }
  return res;
}

void Function1(){
  int l,r;
  cin >> l >> r;
  lol ans = 0;
  SEG.ICoper2(1,1,N,l,l + 48);
  int now_tn = 0;
  for(int i = l;i <= l + 48 && i <= r;++i){
    now_tn = AC[now_tn].son[NRC(A[i])];
    ans += AC[now_tn].tail;
  }
  if(l + 49 <= r)
    ans += SEG.IQoper(1,1,N,l + 49,r);
  printf("%lld\n",ans);
  return;
}

void Function2(){
  int l,r;
  string t;
  cin >> l >> r >> t;
  
  ++NT;
  while(T[NT].size() < 50)
    T[NT] += t;
  LAC[NT].resize(T[NT].size());
  PRE[NT].resize(T[NT].size());

  SEG.ICoper2(1,1,N,l - 1,l - 1);
  int now_tn = SEG[l - 1];
  for(int i = 0;i < 49 && l <= r;++i,++l){
    now_tn = AC[now_tn].son[NRC(T[NT][i])];
    SEG.PCoper(1,1,N,l,now_tn,T[NT][i]);
  }
  
  if(l <= r){
    now_tn = AC[now_tn].son[NRC(T[NT][49])];
    LAC[NT][49] = now_tn;
    PRE[NT][49] = AC[now_tn].tail;
    for(int i = 49;i != 48;i = (i + 1) % T[NT].size()){
      now_tn = AC[now_tn].son[NRC(T[NT][(i + 1) % T[NT].size()])];
      LAC[NT][(i + 1) % T[NT].size()] = now_tn;
      PRE[NT][(i + 1) % T[NT].size()] = PRE[NT][i] + AC[now_tn].tail;
    }
    SEG.ICoper1(1,1,N,l,r,NT,49);
  }
  
  SEG.ICoper2(1,1,N,r,r + 49);
  now_tn = SEG[r];
  for(int i = r + 1;i <= r + 49 && i <= N;++i){
    now_tn = AC[now_tn].son[NRC(A[i])];
    SEG.PCoper(1,1,N,i,now_tn,A[i]);
  }
  return;
}
```

---


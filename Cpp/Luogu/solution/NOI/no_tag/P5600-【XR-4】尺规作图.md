# 【XR-4】尺规作图

## 题目背景

这是一道提交答案（人类智慧）题。

## 题目描述

你有若干个已知的几何图形，你需要通过尺规作图得到一个要求的点。你需要在规定步数之内找到这个点。

你可以进行的操作如下：

1. 以一个已知点为圆心，另一个已知点为圆上一点作圆。

2. 连接两个已知点形成一条直线。

你需要输出你的作图步骤。

## 说明/提示

对于每一个测试点，如果你用的步数小于等于前 $i$ 个评分参数，那么你会得到 $i$ 分。

注意事项如下：

1. **所有的 $x, y$ 必须是你已经得到的点**，这里的已经得到是指输入数据中的点或者已知几何图形的交点。（也就是说你不能随便选择一个点来作图，也不能通过选择一个合适的点来得到要求的点）  
   更准确地说，每次你输出一个坐标，Special Judge 会选择当前你已经得到的所有点中和你的输入坐标欧几里得距离最近的点作为你这一次的选择点。如果距离最近的点距离大于了 $10^{-5}$，那么这次操作会被判定为不合法，同时这一个点你将得到 $0$ 分。

2. 你不能根据圆心和半径作圆，而只能根据圆心和圆上一点作圆。

3. **你画出的答案与要求的点绝对误差或相对误差不超过 $10^{-5}$ 即为正确**（因为不知道怎么写没有误差的 Special Judge）。  
   更准确地说，假设你得到的点是 $(x_1, y_1)$，而要求的点是 $(x_2, y_2)$，则你的输出被认为正确，当且仅当 $\dfrac{|x_1-x_2|}{\max(|x_2|, 1)} \le 10^{-5}$ 且 $\dfrac{|y_1-y_2|}{\max(|y_2|, 1)} \le 10^{-5}$。

4. 下发文件中的 `data1.in` 到 `data10.in` 分别为 $10$ 个输入数据，其中第 $1,2,3,7,8$ 这五个测试点配有图解。

5. 下发的 checker 可以判断你的得分。使用方法如下（其中 `data.in` 是输入文件，`data.out` 是你的输出文件。）：  

  - Windows-32/64：

```
checker data.in data.out data.out
```

  - Linux/MacOS：

```
./checker data.in data.out data.out
```

6. 出题人拿不到 $100$ 分。

update：checker 源码可以点击 [这里](/paste/capu9k2n) 查看，如果有需要改进的地方欢迎提出。

## 样例 #1

### 输入

```
2
0.0000000000 0.0000000000
0.0000000000 1.0000000000
1
1 2
0
0
0.8660254038 0.5000000000
11 10 9 8 7 6 5 4 3 2
```

### 输出

```
2
1 0.0000000000 0.0000000000 0.0000000000 1.0000000000
1 0.0000000000 1.0000000000 0.0000000000 0.0000000000
```

# 题解

## 作者：Provicy (赞：289)

$X-Round4 G$（提答题）

**我可以负责任的告诉大家，以下内容基本为乱搞做法。**

首先你需要一个可以画图的工具，推荐$GeoGebra$或几何画板之类的（反正我只会用这两个）。我此题用的是$GeoGebra$（没有几何画板）。

### $Data1$：

显然题目让你$3$步求一个线段的中点，而且这两个点还在$x$轴上，作中垂线即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/ia70s7u0.png)

总结：第一个点还是很简单的，想必大家手算也能得出。

### $Data2$：

显然，已知直线$AB$和直线外一点$C$，$3$步过$C$作$AB$的垂线。

已知$AB$，那么显然三步就可以作出这条垂线。

![](https://cdn.luogu.com.cn/upload/image_hosting/bpy7xfc3.png)

任取$A,B$其中一点为圆心，以$C$为圆上一点作一个圆，得到这个圆与$x$轴的右交点为$D$，再以$D$为圆心，$C$为圆上一点作一个圆，与第一个圆的一个交点显然为$C$，记另外一个交点为$E$。连结CE交$x$轴于$F$即为答案。

总结：还是不难，但需要少量几何功底。

### $Data3$：

显然题目要求的是$5$步正方形内部一个三角形的外切圆的圆心。

![](https://cdn.luogu.com.cn/upload/image_hosting/jvjy6i4d.png)

首先我们能得到上图的这个$3$步操作。这时候有人提出了个$6$步做法。。。

但我也不知道$6$步做法是什么，其实我们已经有一条$AB$的中垂线了，那么我们再作一条就行了。

![](https://cdn.luogu.com.cn/upload/image_hosting/volt80wn.png)

那么目标点就是△$ABG$的外心点$K$。

总结：这题只要看出目标点是正方形内某三角形的外心即可，难度不大。

### $Data4$ && $Data5$：

（注意：无图！）

$Data4$要$10$步求点$(1024,0)$。由于$2^{10}=1024$，直接倍增求解即可。

$Data5$要$10$步求点$(1000,0)$。比起$Data4$稍要加些思考。

我们枚举其倍增后的二进制位然后考虑其和哪个点连边即可。经过各种尝试，我们还是通过把点$(128,0)$向$(4,0)$连边作圆以及把点$(504,0)$向$(8,0)$连边作圆即可得到点$(1000,0)$。注意，因为以上连边时这个圆半径比起$Data4$要小，故在后面的倍增求解中要持续减去这个数。

总结：这两个还是偏简单（比$Data2$和$Data3$还要简单），倍增求解即可。

### $Data6$：

本人认为全场与$Data10$难度差不多的一个点。

给你一个圆，以及这个圆上任意一个点，去作一条直线与圆交于这个点。

![](https://cdn.luogu.com.cn/upload/image_hosting/4inzpb59.png)

就是求$Q$这个点啦。

首先根据经验，我们会想到二分去求解。但事实证明二分需要$40+$次数，虽然也能拿到$9$分的好成绩，但还不是正解。

于是我们考虑用一条其中一个点为原点的直线去过这个点$Q$。

于是我们向$x$和$y$轴的正方向倍增枚举点，为了去逼近这个点，我们发现有时候把这个点连向$(0,1)$和$(1,0)$时更逼近答案。

一番瞎搞之后，我们还是能得出一个比较精确的点$(22049,10262.5)$

总结：这题较难，考查了枚举和乱搞的能力（说过了，这道题真的有点依靠乱搞水平，或许比爆搜还快不少）。

### $Data7$：

纯考平面几何知识的一道题。

观察一段时间目标点之后，我们发现这题是求一个三角形的费马点。

![](https://cdn.luogu.com.cn/upload/image_hosting/elt4v1ug.png)

我们求一个三角形的费马点，如果这个三角形有一个内角大于等于$120$°，显然费马点就是这个顶点，否则就是到三边张角都是$120$°的角。

我们可以据此推出较简单的一种作法：

向△$ABC$外作等边三角形$ABA'$，再作其外接圆交$A'C$于$P$，则$P$就是费马点。

于是我们可以得到以下$3$步后的图形：

![](https://cdn.luogu.com.cn/upload/image_hosting/05b6vxlt.png)

那么很快我们就有一种$6$步作法如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/n4edd08j.png)

这是我考场上想到的作法，但是你是不是发现我在上上张图中有一条线在上张图中没有出现？

我们想到，我们不必要把这个等边三角形求出来，我们只需要知道这个$A'$在哪条直线上即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/gqp3l3ak.png)

我们如此作三个圆之后，根据圆的性质，我们得到四边形$ABFE$为一个菱形。

作法：连结$CD$，交圆心为$A$的这个圆于$E$，那么以$E$为圆心，$A$为圆上一点作圆，交以$B$为圆心的圆于点$F$，连结$AF$。$AF$与$CD$交点即为点$Q$。

因为$EB$被固定，且根据$ABFE$是菱形的结论，我们得到$AF$为线段$BE$的中垂线。所以在直线$AF$上一定存在某点$P$，使得△$BEP$为等边三角形。则得到点$Q$。

总结：一道几何题，由$7$分向$10$分的突破是比较难的。

### $Data8$：

和$Data7$提供的已知点相同，目标点也在由三个点组成的三角形内部，并且这三个点已经被组成一个三角形，于是我们猜想这个目标点是这个三角形的某心与某条边的切点。经检验，这个某心是该三角形的内心。

![](https://cdn.luogu.com.cn/upload/image_hosting/3ktpvo80.png)

比起$Data7$的$5$步求费马点来说，这道题还是不难的。如果你对平面几何稍有了解，就知道如何快速求这个$Q$点。

![](https://cdn.luogu.com.cn/upload/image_hosting/x5vj68i7.png)

对这种中垂线构造如果熟悉的话这题没有难度。

总结：$Data6$到$Data10$中最简单的一题，也是考场上我在这$5$个点中唯一做出的点。

### $Data9$：

还算容易的乱搞题。

![](https://cdn.luogu.com.cn/upload/image_hosting/fyathhnd.png)

在直线$EF$上红点$H$即为所求。

我们观察到红点$H$与点$C$的关系，我们假设它们同为一个圆上的点，那么我们易想到存在$G$这个点，那么我们就要构造一条过$x$轴这个点的直线，我们对于几个圆的构造的尝试后得出以上图的结果。

总结：如果愿意去做这题，那么$Data9$就毫无难度，只需少数尝试即可。

### $Data10$：

非常难的乱搞做法。

我们观察到$Data10$和$Data9$相比，给的步数变多了，同时这个点也离已知点较远，那么我们可以想到在$Data9$的基础上构造它。

![](https://cdn.luogu.com.cn/upload/image_hosting/ivp5f3kc.png)

观察所求$Q$点，我们发现$Q$，$D$，$H$三点共线！我们大眼观察得到如此结论。于是根据这个特性，我们继续尝试构造。

![](https://cdn.luogu.com.cn/upload/image_hosting/fwsc5vbe.png)

最终，我们的$Q$点以直线$HD$与以$D$为圆心的圆相交的右交点为圆上一点，以点$L$为圆心作圆，则得到$Q$，因为$Q$也在直线$HD$上。（乱搞出奇迹！）

总结：爆搜和乱搞都行的一个很难的点。但是我不会爆搜于是只能乱搞。

### 大总结：非常适合颓♂废的一道题，不过大家还是自己写比较好，也能比较好的锻炼几何感觉。

最后放下代码，各位可以对比对照一下（仅有答案），如果有更好的作法欢迎提出（$Data10$目前最短$9$步）：

```cpp
#include <bits/stdc++.h>
using namespace std;

void BigPrint1()
{
	printf("40\n");
	printf("2 0 1 0 0\n");
	printf("1 0 1 0 -1\n");
	printf("1 0 -1 0 1\n");
	printf("2 -1.7320508075689 0 1.7320508075689 0\n");
	printf("1 0 1 0 0\n");
	printf("1 1 0 0 0\n");
	printf("1 2 0 1 0\n");
	printf("1 0 2 0 1\n");
	printf("1 3 0 0 0\n");
	printf("1 0 3 0 0\n");
	printf("1 6 0 1 0\n");
	printf("1 0 6 0 1\n");
	printf("1 11 0 0 0\n");
	printf("1 0 11 0 1\n");
	printf("1 22 0 0 0\n");
	printf("1 0 21 0 1\n");
	printf("1 44 0 1 0\n");
	printf("1 0 41 0 1\n");
	printf("1 87 0 1 0\n");
	printf("1 0 81 0 1\n");
	printf("1 173 0 1 0\n");
	printf("1 0 161 0 1\n");
	printf("1 345 0 0 0\n");
	printf("1 0 321 0 0\n");
	printf("1 690 0 1 0\n");
	printf("1 0 642 0 1\n");
	printf("1 1379 0 1 0\n");
	printf("1 0 1283 0 0\n");
	printf("1 2757 0 1 0\n");
	printf("1 0 2566 0 0\n");
	printf("1 5513 0 1 0\n");
	printf("1 0 5132 0 1\n");
	printf("1 11025 0 1 0\n");
	printf("1 0 10263 0 1\n");
	printf("1 22049 0 0 0\n");
	printf("1 0 20525 44098 0\n");
	printf("1 44098 0 0 20525\n");
	printf("2 4273.8285813547 -27927.4882594317 39824.1714159424 48452.4882592014\n");
	printf("2 0 20525 44098 0\n");
	printf("2 0 0 22049 10262.5\n");
}
void BigPrint2()
{
	printf("9\n");
	printf("1 10.64978745 0 0 0\n");
	printf("1 0 0 10.64978745 0\n");
	printf("1 -10.64978745 0 0 0\n");
	printf("1 5.324893725 9.2229864766047 -10.64978745 0\n");
	printf("2 -2.8891429892634 -7.293172854404 -5.324893725 9.2229864766047\n");
	printf("1 -3.9647169644197 0 -10.64978745 0\n");
	printf("2 -2.1668572419475 6.4387784412487 5.324893725 9.2229864766047\n");
	printf("2 21.2995749 0 -13.0855381857366 10.3675016799389\n");
	printf("1 -6.5503572407083 8.39707048614 22.6154412356748 15.6487848683712\n");
}
int main()
{
	int n; scanf("%d",&n);
	if(n==1) {printf("3\n1 0 0 1 0\n1 1 0 0 0\n2 0.5 0.8660254037844 0.5 -0.8660254037844\n"); return 0; }
	if(n==2) {printf("3\n1 1 0 5.23124577 4.31624417\n1 7.0442869307472 0 5.23124577 4.31624417\n2 5.23124577 4.31624417 5.23124577 -4.31624417\n"); return 0; }
	if(n==3) {printf("5\n1 0 0 1 0\n1 1 0 0 0\n2 0.5 0.8660254037844 0.5 -0.8660254037844\n1 0.5 1 0.5 0\n2 0.9916198487096 0.1291900756452 -0.4916198487096 0.8708099243548\n"); return 0; }
	if(n==4) {printf("10\n1 1 0 0 0\n1 2 0 0 0\n1 4 0 0 0\n1 8 0 0 0\n1 16 0 0 0\n1 32 0 0 0\n1 64 0 0 0\n1 128 0 0 0\n1 256 0 0 0\n1 512 0 0 0\n"); return 0; }
	if(n==5) {printf("10\n1 1 0 0 0\n1 2 0 0 0\n1 4 0 0 0\n1 8 0 0 0\n1 16 0 0 0\n1 32 0 0 0\n1 64 0 0 0\n1 128 0 4 0\n1 252 0 0 0\n1 504 0 8 0\n"); return 0; }
	if(n==6) {BigPrint1(); return 0; }
	if(n==7) {printf("5\n1 0 0 12.34441574 0\n1 12.34441574 0 0 0\n2 5.16457145 9.12243565 6.17220787 -10.6905776257165\n1 5.0557791797877 11.2616027654675 0 0\n2 0 0 17.4001949197877 11.2616027654675\n"); return 0; }
	if(n==8) {printf("5\n1 0 0 5.16457145 9.12243565\n1 12.34441574 0.00000000 5.16457145 9.12243565\n1 0.7354107775996 0 10.4829208930787 0\n1 10.4829208930787 0 0.7354107775996 0\n2 5.6091658353392 8.4415913836507 5.6091658353392 -8.4415913836507\n"); return 0; }
	if(n==9) {printf("6\n1 10.64978745 0 0 0\n1 0 0 10.64978745 0\n1 -10.64978745 0 0 0\n1 5.324893725 9.2229864766047 -10.64978745 0\n2 -5.324893725 9.2229846217 -2.8891429892634 -7.293172854404\n1 -3.9647169644197 0 -10.64978745 0\n"); return 0;}
	if(n==10) {BigPrint2(); return 0; }
	return 0;
}
```

### 后记：这算我写过最长的题解了吧，也是对这题比较详细的一个解答，希望大家能看懂，如果有不对的地方请指正$QwQ$


---

## 作者：CYJian (赞：17)

先声明一下本篇题解中使用的一些简称：

$Cir(A,B)$ : 以 $A$ 为圆心， $B$ 为圆上一点作圆。

$Line(A,B)$ : 过 $A$, $B$ 两点作一条直线。

---

# 1.简单数学知识

## Data 1

作中垂线：

记 $A(0, 0)$，$B(0, 1)$

那么作一个 $Cir(A, B)$, 作一个 $Cir(B, A)$，连接两圆的交点就行了。

为啥？因为一条线段上的中垂线上的点到两个端点的距离相等。

那么我们画的这两个圆上的点到各自圆心的距离都相等。

那么两圆的交点到两个圆心的距离都相等，这样就有了两个点，到两个圆心的距离相同。

然后我们就可以确定这两个点都在中垂线上。并且由于两点确定一条直线，我们就可以确定好这条中垂线了。

```cpp
inline void solve1() {
	puts("3");
	Cir(0, 0, 1, 0);
	Cir(1, 0, 0, 0);
	db x = 0.5, y = sqrt(0.75);
	Line(x, y, x, -y);
}
```

## Data 2

过一点作给定线段的垂线

这应该也不难。假设给定的线段是 $AB$，过 $C$ 作 $AB$ 的垂线。

那么就可以作 $Cir(A, C)$ 和 $Cir(B, C)$，这时候就有两个交点。

不难发现这两个交点关于 $AB$ 所在直线对称，所以这两个交点的连线就垂直于 $AB$ 了。

```cpp
inline void solve2() {
	puts("3");
	db x = 5.23124577, y = 4.31624417;
	Cir(0, 0, x, y);
	Cir(1, 0, x, y);
	Line(x, y, x, -y);
}
```

# 2. 倍增

## Data 4

给出两个点 $A(0, 0)$ 和 $B(1, 0)$, 请你找到 $Target(1024, 0)$

发现给出的步数要求是 $10$，然后 $1024=2^{10}$，不难想到倍增。

可以每一次作 $Cir((2^k, 0), A)$ 来得到 $(2^{k+1}, 0)$

所以就很简单了。

```cpp
inline void solve4() {
	puts("10");
	for(int i = 0; i < 10; i++)
		Cir(1 << i, 0, 0, 0);
}
```

## Data 5

还是 $10$ 步，要求得到 $(1000,0)$

我们发现最多可以从 $(125, 0)$ 开始倍增。

但是 $(125, 0)$ 怎么来呢？？

事实上我们可以利用负半轴！

$(125, 0)$ 可以由 $Cir((63, 0), (1, 0))$ 得到

$(63, 0)$ 可以由 $Cir((31, 0), (-1, 0))$ 得到

那么依此类推，就有：$(2^k-1,0)$ 可以由 $Cir((2^{k-1}-1, 0),(-1, 0))$ 得到。

而 $(-1,0)$ 可以由 $Cir((0, 0), (1, 0))$ 得到。

那么就可以照样倍增做了。

```cpp
inilne void solve5() {
	puts("10");
	Cir(0, 0, 1, 0);
	Cir(1, 0, -1, 0);
	for(int i = 2; i <= 5; i++) Cir((1 << i) - 1, 0, -1, 0);
	Cir(63, 0, 1, 0);
	Cir(125, 0, 0, 0);
	Cir(250, 0, 0, 0);
	Cir(500, 0, 0, 0);
}
```

---

# 3. 更难的数学知识

## Data 3

给出一个正方形 $ABCD$，请你求出 $CD$ 中点 $E$ 与 $A$，$B$ 组成的三角形 $\triangle ABE$ 的外心 $F$。

![](https://cdn.luogu.com.cn/upload/image_hosting/u08ucplj.png)

有一种 $naive$ 的想法：先找 $AB$ 的中垂线($3$ 步)，然后可以顺便找到 $E$，然后再找 $AE$ 的中垂线($3$ 步)，然后就可以找到 $F$ 了。

然后你就发现限制是 $5$ 步...

所以怎么办啊。。

之后我就瞎jb乱试，结果给我试出来了：

![](https://cdn.luogu.com.cn/upload/image_hosting/3utydotc.png)

为啥是作 $Cir(D, I)$ 呢？

因为我们发现 $DK = \frac{\sqrt{5}}{2}$，$BK=1$，然后设 $BL=x$

我们就有方程：$\frac{5}{4}-(1-x)^2=1-x^2$

解得 $x=0.375$...正好是我们要的坐标。。

左边的同理。那么我们就只需要 $5$ 步就可以解决辣！

```cpp
inline void solve3() {
	puts("5");
	Cir(0, 0, 1, 0);
	Cir(1, 0, 0, 0);
	db Y1 = 0.86602540378;
	Line(0.5, Y1, 0.5, -Y1);
	Cir(1, 1, 0.5, 0);
	Line(0.072975, 0.375, 1.927024, 0.375);
}
```

## Data 7

给出三个点，三个点能形成的夹角小于 $120^{\circ}$，请你求出这三个点形成的三角形的费马点 $P$。

首先不难想到构造一个等边三角形 $ABD$($D$与$C$在直线$AB$异侧)，费马点一定在直线 $CD$ 上。

构造的方法：$Cir(A,B)$，$Cir(B,A)$，$Line(C,D)$

这样我们就花了 $3$ 步确定了费马点所在的一条直线。

那怎么找另一条直线呢？

考虑这时候我们可以在 $CD$ 所在直线上找到与圆 $A$ 的另一个交点 $E$，不难发现 $\angle CPB = \angle EPB$...反正我们可以拿 $E$ 来找费马点，效果是一样的。

那么我们这时候已经有了 $Cir(A,E)$，所以就可以节约一步，这样就只需要 $5$ 步了。

![](https://cdn.luogu.com.cn/upload/image_hosting/tsb61dgd.png)

```cpp
inline void solve7()
	puts("5");
	Node A(0, 0);
	Node B(12.34441574, 0);
	Node C(5.16457145, 9.12243565);
	Cir(A, B), Cir(B, A);
	Node D(6.17220787, -10.690577625);
	Line(C, D);
	Node E(5.05577917978, 11.2616027654);
	Cir(E, A);
	Node F(17.40019491978, 11.261602765);
	Line(A, F);
}
```

## Data 8

给出一个三角形 $\triangle ABC$，求内接圆与 $AB$ 交点。

这个挺简单的吧。

用切线长定理，可以按照内切圆与三边的切点把三边分别分成三组对应相等的线段。

然后作圆把 $AC$ 和 $BC$ 放在 $AB$ 上之后，发现要求的点就在两个交点的中点处。

这样就只需要 作两个圆 + 求中垂线 就行了。$5$ 步解决。

![](https://cdn.luogu.com.cn/upload/image_hosting/etds379c.png)

```cpp
inline void solve8() {
	puts("5");
	Node A(0, 0);
	Node B(12.34441574, 0);
	Node C(5.16457145, 9.12243565);
	Cir(A, C), Cir(B, C);
	Node D(0.7354107776, 0);
	Node E(10.4829208931, 0);
	Cir(D, E), Cir(E, D);
	Node F(5.6091658353, 8.4415913837);
	Node G(5.6091658353, -8.4415913837);
	Line(F, G);
}
```

# 4. 二分

## Data 6

谁说二分被卡次数啊！！！

明明就只需要 $35$ 次好不好啊。。

一开始做这个的时候手动二分，用了 $31$ 次就做出来了。（感觉自己很有毅力的说。。）

~~密集恐惧症患者请务必看下图~~

![](https://cdn.luogu.com.cn/upload/image_hosting/o06kycpb.png)

$31$ 步后的精度误差：

![](https://cdn.luogu.com.cn/upload/image_hosting/fn6tl25s.png)

但是。

这题给的点是 $(0, 0)$ 和 $(0, 1)$...但我算的是 $(0, 0)$ 和 $(1, 0)$...

~~我人没了~~ 然后当场自闭。

然后觉得再手动二分不太现实，结果用程序实现了一下 $39$ 步的二分。然后发现checker给出了这个信息：

> wrong output format Extra information in the output file

？？？发生了什么？

我看看输出，挺对的啊，甚至到第 $35$ 步就已经达到 $10^{-5}$ 的精度要求了啊。。

然后仔细一看，发现说了 ${\rm Extra\ information}$。。

这什么 checker 还要要求不能冗余操作啊。。

于是就换成 $35$ 步就能过了。。

```cpp
inline void solve6() {
	Node A(0, 0), B(0, 1);
    Circle C(A, B), D(B, A);
	int On = 2;
	db Target = 0.42197248;
	puts("35");
	Line(0, 0, 0, 1);
	for(int i = 0; i < 17; i++) {
		if(On & 1) Cir(A, B), C = Circle(A, B), On |= 2;
		else Cir(B, A), D = Circle(B, A), On |= 1;
		Node X = C + D;
		Node Y(-X.x, X.y);
		Line(X, Y);
		Node T(0, X.y);
		if(T.y < Target) A = T, On &= 2;
		else B = T, On &= 1;
	}
}
```

## 5. 乱搞

## Data 9

这题以及接下来一题都是给你两个点，然后让你找到给定点。。

其实就是让你瞎猜，看你要多久能猜到。

怎么猜就不细说了，大概就看看有没有 共圆/共线 的情况，然后找到想要的圆心就行了。

大概是一个这样的惨状：(还是没有那个二分惨。。)

![](https://cdn.luogu.com.cn/upload/image_hosting/ipzzbn8l.png)

```cpp
inline void solve9() {
	puts("6");
	Node A(0.0);
	Node B(10.64978745, 0);
	Node C(-10.64978745, 0);
	Node G(-3.9647169635, 0);
	Node D(-5.324893725, 9.2229864766);
	Node E(5.324893725, 9.2229864766);
	Node F(-2.8891429893, -7.2931728544);
	Cir(A, B);
	Cir(B, A);
	Cir(C, A);
	Cir(E, C);
    Line(D, F);
	Cir(G, C);
}
```

## Data 10

这个点的图已经在上面了。大概就从第九个点扩展三步就到了。

```cpp
inline void solve10() {
	puts("9");
	Node A(0.0);
	Node B(10.64978745, 0);
	Node C(-10.64978745, 0);
	Node D(-5.324893725, 9.2229864766);
	Node E(5.324893725, 9.2229864766);
	Node F(-2.8891429893, -7.2931728544);
	Node G(-3.9647169635, 0);
	Node K(-2.1668572419, 6.4387784412);
	Node L(22.6154412357, 15.6487848684);
	Node I(21.2995749, 0);
	Node M(-13.0855381857, 10.3675016799);
	Node N(-6.5503572407, 8.3970704861);
	Cir(A, B);
	Cir(B, A);
	Cir(C, A);
	Cir(E, C);
	Line(D, F);
	Cir(G, C);
	Line(K, E);
	Line(I, M);
	Cir(N, L);
}
```

---

## 作者：disangan233 (赞：10)

我也不知道我为啥要花两天来肝这个题。

考场上没时间做，一直肝 G7 G8，半个小时只写了 $27$ 分，没看到 G4 G5 很简单，自闭了。。

目前提供 G1-G10 的思路和代码。

前置知识：~~坚持的优良品质~~，~~抖 M 属性~~，基本平面几何，~~人眼搜索剪枝~~

软件：GeoGebra。

### 中垂线

G1：$3$ 步取线段重点。

没什么好说的，直接中垂线。

G2：$3$ 步过直线 $AB$ 外一点 $C$ 作垂线。

因为给出了 $AB$，所以可以只用 $3$ 次求解，两个端点分别作圆心作圆上一点为 $C$ 的圆即可。

![G2.png](https://i.loli.net/2019/10/21/mMTGI8J5nfSWR4E.png)

G3：$5$ 步求正方形 $ABCD$ 内切三角形 $ABE$ （$E$ 为 $CD$ 中点）内到 $3$ 个顶点距离相等的点。

利用正方形作出两个中垂线即可。

![G3.png](https://i.loli.net/2019/10/21/Iq2JomTudsfCkvy.png)

### 二分&倍增

G4：$10$ 步求出 $(1024,0)$。

直接倍增 $10$ 次即可。

G5：$10$ 步求出 $(1000,0)$。

枚举二进制位，如果当前非首位为 $1$ 就向 $(1,0)$ 连。

G6：$40$ 步求出圆上随机一点。

单纯的二分要 $46$ 次，非常不优秀。

考虑用原点起的直线去切割这个点，首先向 $x$，$y$ 的正方向随便倍增几个点，发现当 $x$ 轴正方向向 $(1,0)$ 连边倍增时连线会更加逼近所求点。

在经过各种枚举乱搞之后，算出了一个优秀的点：$(22049,10262.5)$。向 $x$，$y$ 轴倍增 $2$ 倍后直接做即可。

### 圆的性质

G7：$5$ 步求出 $\Delta ABC$ 的费马点。

利用圆的性质，以 $A$，$B$ 为圆心作圆，交点与 $C$ 连线。再用类似的方法做一次，得到两根线的交点，同时满足两个角，故成立。

![G7.png](https://i.loli.net/2019/10/21/FcsOmZAqaXIvWQu.png)

G8：$5$ 步求出 $\Delta ABC$ 的内切圆与底边的交点。

利用圆的切线长定理即可。

![G8.png](https://i.loli.net/2019/10/21/cltzJBMeGaN2Iu8.png)

### 乱搞

G9：乱试即可。

![G9.png](https://i.loli.net/2019/10/21/itIbRvsOcd68XpY.png)

G10：跟 G9 一样，瞎 jb 乱做。

### Code

```cpp
#pragma GCC optimize(2,3,"Ofast","unroll-loops")
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
    char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0,ny;
    in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
    in ll read()
    {
        ll x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;Bi=1;if(nc<0)return nc;
        x=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*ny;
    }
    in db gf() {re a=read(),y=ny,b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi)*y:a);}
    in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
    in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
    in void flush() {if(C>1<<22) ot();}
    template <typename T>
    in void write(T x,char t)
    {
        re y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
        if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
    }
    in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
const int N=1e6+5;
int t;
in void cir(db a,db b,db c,db d) {printf("1 %.8lf %.8lf %.8lf %.8lf\n",a,b,c,d);}
in void lnk(db a,db b,db c,db d) {printf("2 %.8lf %.8lf %.8lf %.8lf\n",a,b,c,d);}
int main()
{
	t=read();
	if(t==1) 
	{
		puts("3");
		cir(0,0,1,0);cir(1,0,0,0);lnk(0.5,0.86602540,0.5,-0.86602540);
	}
	if(t==2) 
	{
		puts("3");
		cir(0,0,5.23124577,4.31624417);cir(1,0,5.23124577,4.31624417);
		lnk(5.23124577,4.31624417,5.23124577,-4.31624417);
	}
	if(t==3)
	{
		puts("5");
		cir(0,0,0,1);cir(1,0,0,0);lnk(0.5,0.86602540,0.5,-0.86602540);
		cir(0,1,0.5,0);lnk(0.92702481,0.37500000,-0.92702481,0.37500000);
	}
	if(t==4)
	{
		puts("10");
		for(re i=0;i<10;i++) cir(1<<i,0,0,0);
	}
	if(t==5)
	{
		puts("10");
		int a[15]={},b[15]={},n=500;
		for(re i=1;n;i++,n=(n+1)/2) a[10-i+1]=n,b[10-i+1]=n%2;
		for(re i=1;i<=10;i++) cir(a[i],0,b[i+1],0);
	}
	if(t==6)
	{
		puts("40");
		lnk(0,0,0,1);cir(0,-1,0,1);cir(0,1,0,-1);
		lnk(1.73205081,0,-1.73205081,0);cir(0,1,0,0);cir(1,0,0,0);
		int i,a[55]={},b[55]={},n=44098;
		for(i=1;n>1;i++,n=(n+1)/2) a[i]=n,b[i]=n%2;
		for(re j=i-1;j>1;j--) cir(a[j],0,b[j-1],0);  
		int j,m=20525;
		for(j=1;m>1;j++,m=(m+1)/2) a[j]=m,b[j]=m%2;
		for(re k=j-1;k>1;k--) cir(0,a[k],0,b[k-1]);
		cir(44098,0,0,20525);cir(0,20525,44098,0);
		lnk(39824.17141267,48452.48825608,4273.828587,-27927.48825);
		lnk(0,20525,44098,0);lnk(22049,10262.5,0,0);
	}
	if(t==7)
	{
		puts("5");
		cir(0,0,12.34441574,0);cir(12.34441574,0,0,0);
		lnk(5.16457145,9.12243565,6.17220787,-10.69057763);
		cir(5.05577918,11.26160277,0,0);lnk(0,0,17.40019492,11.26160277);
	}
	if(t==8)
	{
		puts("5");
		cir(0,0,5.16457145,9.12243565);cir(12.34441574,0,5.16457145,9.12243565);
		cir(0.73541077,0,10.48292089,0);cir(10.48292089,0,0.73541077,0);
		lnk(5.60916584,8.44159138,5.60916584,-8.44159138);
	}
	if(t==9)
	{
		puts("6");
		cir(0,0,10.64978745,0);cir(10.64978745,0,0,0);cir(-10.64978745,0,0,0);
		cir(5.32489372,9.22298648,-10.64978745,0);
		lnk(-5.32489372,9.22298648,-2.88914299,-7.29317285);
		cir(-3.96471696,0,-10.64978745,0);
	}
	if(t==10)
	{
		puts("10");
		cir(10.64978745,0,0,0);cir(0,0,10.64978745,0);cir(-10.64978745,0,0,0);
		cir(5.324893725,9.22298648,-10.64978745,0);
		lnk(-2.88914299,-7.29317285,-5.324893725,9.22298648);
		cir(-3.96471696,0,-10.64978745,0);cir(-5.324893725,9.22298648,-3.96471696,0);
		lnk(-2.16685724,6.43877844,5.32489373,9.22298648);
		lnk(21.2995749,0,-13.085538186,10.36750168);
		cir(-6.55035724,8.39707045,22.61544124,15.64878487);
	} 
}
//Author: disangan233
//In my dream's scene,I can see the everything that in Cyaegha.
```

赠送 windows 条件下的 `check.bat`。

```bat
@echo off
for /L %%i in (1,1,10) do (
	echo process.. %%i
	graph.exe <data%%i.in >data%%i.out
	checker data%%i.in data%%i.out data%%i.out
)
pause
```

---

## 作者：Weng_Weijie (赞：5)

这里给出前 8 个点的做法。

其中第 6 个点我只用了 24 步，比标程稍微优一点。

### 第一个点(3)：作中垂线。

使用两圆一直线就行了。

### 第二个点(3)：作垂线。
注意到 $C$ 关于 $x$ 轴的对称点在以 $A$ 为圆心 $AC$ 为半径的圆上，$B$ 同理，因此可以得到对称点。

### 第三个点(5)：

如图所示，作两个中垂线即可，注意共用圆节省一步。

![data3](https://cdn.vijos.org/fs/afe59c533b7cff79155a13d9b3f9440e3daf601d)

### 第四个点(10)：构造 $(1024,0)$。

容易发现以 $(a,0)$ 为圆心 $a$ 为半径可以构造 $(2a,0)$，因此只需 10 步。

### 第五个点(10)：构造 $(1000,0)$。
使用以下方法可以构造 $(1000,0)$。

$$
1\to2\to\dots\to32\to63\to125\to\dots\to1000
$$

其中，$32,63$ 两步是以 $(1,0)$ 为圆上一点作圆。

### 第六个点(40)：给定圆，作圆上一个奇怪的点。

发现这个点没有什么性质，于是考虑利用精度误差来近似这个点。

具体思路是先在 $y$ 轴上找到一点 $(0,\epsilon)$，然后利用第 5 个点的做法可以倍增到 $y$ 轴上任意一点。

因此将目标点和某固定点连线交 $y$ 轴于一点，只需倍增到这个点即可。

问题是怎么寻找这个 $(0,\epsilon)$。

使用以下迭代方法：

![data6](https://cdn.vijos.org/fs/6120e98826a4ff15620a4dba222fb331c82a4650)

由直线 $EF$ 迭代至直线 $GH$ 的方法，可以计算得到：

$$y'=\dfrac{y^2}2$$

因此迭代三次可以得到 $(0, 2^{-15})$。

接着寻找固定点可以多尝试几次 ~~，在卡步数和卡精度边缘尝试~~。

### 第七个点(5)：给定三点求费马点

这个在 Euclidea 上有，只给出做法。

![data7](https://cdn.vijos.org/fs/3ac5c2d9944baaf104f617a060199965f4c164b0)

~~读者自证不难~~


### 第八个点(5)：求内切圆的切点

![data8](https://cdn.vijos.org/fs/5d0f16dbd999ee9b8682927450449ba25214a3b9)

其中 $AI$ 的中点是 $E$。

这个点的证明也不难，只是有点难想到。

注意不能将线段延长，否则会多用步数。

---

## 作者：封禁用户 (赞：5)

**安利一款尺规作图游戏：Euclidea**（有dalao私信我说出题人就是在这个基础上出题的，生草生草）


本题放在OI试题里有些新颖 _~~但却也有些毒瘤~~_

考试的时候手推了四个点正解和一个点次优解，来分享一下做法

**data1：取线段$AB$中点**

分别以$A$、$B$两个点为圆心，$AB$的长度*(按照本题要求)为半径作圆，两圆两交点所在直线与$AB$交点即为重点。

**data2：过直线$AB$外一点$C$做AB垂线**

以$B$（或$A$）为圆心，$BC$（或$AC$）长度为半径作圆$O_1$，交$x$轴于一点$P$，再以$P$为圆心，$P$C长度为半径作圆$O_2$，与圆$O_1$交于点D，则直线CD垂直于直线AB。

**data3：给定$A(0,0)B(0,1)C(1,0)D(1,1)$四点以及其围成的正方形，作点$(\dfrac{1}{2},\dfrac{3}{8})$**

（非最优解）沿用data1中方法做出线段$CD$的垂直平分线、线段CD的中点E，EA的垂直平分线，两条垂直平分线交点即为所求。

Upd: 来自@[1190220csl](https://www.luogu.org/space/show?uid=61068)做法：沿用data1中方法做出线段$AB$的垂直平分线（交$CD$于点$E$），设所求点为$F$，手推性质（初中数学常用性质，$\tan\alpha=\dfrac{1}{2}$→$\tan2\alpha=\dfrac{4}{3}$，$\tan\alpha=\dfrac{1}{3}$→$\tan2\alpha=\dfrac{3}{4}$等）得到$BE$平分$\angle BEF$，则以$E$为圆心、$D$为圆上一点作圆交刚才过B作的圆于点$G$，则$BG$交$AB$的垂直平分线于所求点$F$。

**data4：给定$A(0,0)B(1,0)$，作出点$C(2^{10},0)$**

$(1,0)+(0,0)$→$(2,0)$

$(2,0)+(0,0)$→$(4,0)$

...

$(512,0)+(0,0)$→$(1024,0)$

**data5：给定$A(0,0)B(1,0)$，作出点$C(1000,0)$**

观察到$1000=1024-24$，$24$可以拆成$8+16$，于是做法就顺水推舟地出来了

$1→2→4→8→-8→-24→40→104→232→488→1000$

---

## 作者：tder (赞：3)

# [P5600 【XR-4】尺规作图](https://www.luogu.com.cn/problem/P5600) 题解

[题目传送门](https://www.luogu.com.cn/problem/P5600)

[更好的阅读体验](https://www.luogu.com.cn/blog/tder/solution-P5600)

`upd on 2023/11/16 21:32 修正所有违规使用 LaTeX 处。`

~~我的第 $2$ 道黑题居然是提交答案！~~

~~平面几何 + 奇奇怪怪？~~

---

## 思路

约定，$\text{Point}~P=\{x,y\}$ 表示定义一个点 $P$ 坐标为 $(x,y)$，$\operatorname{Cir}(A,B)$ 表示以 $A$ 为圆心、$B$ 为圆上一点作圆，$\operatorname{Lin}(A,B)$ 表示作直线 $\overline{AB}$。

---

对于第 $1$ 个数据，如图，给定 $A(0,0)$ 和 $B(1,0)$，尺规作图求作 $AB$ 中点 $C$，直接作中点即可。

```cpp
Point A = {0, 0};
Point B = {1, 0};
Cir(A, B);
Cir(B, A);
Point C = {0.5, 0.8660254037844};
Point D = {0.5, -0.8660254037844};
Lin(C, D);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/0cxgfykw.png)

---

对于第 $2$ 个数据，如图，给定 $A(0,0),B(1,0)$ 和 $C(5.23124577,4.31624417)$，尺规作图过直线外一点 $C$ 作直线 $AB$ 的垂线。

```cpp
Point A = {0, 0};
Point B = {1, 0};
Point C = {5.23124577, 4.31624417};
Cir(A, C);
Cir(B, C);
Point D = {5.23124577, -4.31624417};
Lin(C, D);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/2o69bpgo.png)

---

对于第 $3$ 个数据，如图，给定 $A(0,0),B(0,1),C(1,0),D(1,1)$，$CD$ 中点为 $H$，尺规作图作 $\triangle ACH$ 的外心。

$7$ 步做法：

```cpp
Point A = {0, 0};
Point B = {0, 1};
Point C = {1, 0};
Point D = {1, 1};
Cir(A, C);
Cir(C, A);
Point E = {0.5, 0.8660254037844};
Point G = {0.5, -0.8660254037844};
Lin(E, G);
Point H = {0.5, 1};
Cir(A, H);
Cir(H, A);
Point I = {1.1160254037844, 0.0669872981078};
Point J = {-0.6160254037844, 0.9330127018922};
Lin(I, J);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/x34tehil.png)

$5$ 步做法：

```cpp
Point A = {0, 0};
Point B = {0, 1};
Point C = {1, 0};
Point D = {1, 1};
Cir(A, C);
Cir(C, A);
Point E = {0.5, 0.8660254037844};
Point G = {0.5, -0.8660254037844};
Lin(E, G);
Point H = {0.5, 1};
Point I = {0.5, 0};
Cir(H, I);
Point J = {-0.4916198487096, 0.8708099243548};
Point K = {0.9916198487096, 0.1291900756452};
Lin(J, K);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/kru96nin.png)

---

对于第 $4$ 个数据，如图，给定 $A(0,0)$ 和 $B(1,0)$，尺规作图求作 $O(1024,0)$。使用倍增思想，$1024=2^{10}$，依次作圆即可。

```cpp
Point A = {0, 0};
Point B = {1, 0};
Cir(B, A);
Point C = {2, 0};
Cir(C, A);
Point D = {4, 0};
Cir(D, A);
Point E = {8, 0};
Cir(E, A);
Point G = {16, 0};
Cir(G, A);
Point H = {32, 0};
Cir(H, A);
Point I = {64, 0};
Cir(I, A);
Point J = {128, 0};
Cir(J, A);
Point K = {256, 0};
Cir(K, A);
Point L = {512, 0};
Cir(L, A);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/dssax604.png)

---

对于第 $5$ 个数据，如图，给定 $A(0,0)$ 和 $B(1,0)$，尺规作图求作 $O(1000,0)$。使用倍增思想，$1000=125\times2^3=(63\times2-1)\times2^3=((2^6-1)\times2-1)\times2^3$。具体的，先进行 $\text{Cir}(A,B)$ 得到点 $C(-1,0)$，再类似第 $4$ 个数据，分别以 $B,D(3,0),\dotsm,H(31,0)$ 为圆心、$C$ 为圆上一点作圆，可得点 $I(63,0)$。再以 $I$ 为圆心、$B$ 为圆上一点作圆，可得 $J(0,125)$，此时可类似第 $4$ 个数据，作 $2$ 个圆即可得 $O(1000,0)$。

```cpp
Point A = {0, 0};
Point B = {1, 0};
Cir(A, B);
Point C = {-1, 0};
Cir(B, C);
Point D = {3, 0};
Cir(D, C);
Point E = {7, 0};
Cir(E, C);
Point G = {15, 0};
Cir(G, C);
Point H = {31, 0};
Cir(H, C);
Point I = {63, 0};
Cir(I, B);
Point J = {125, 0};
Cir(J, A);
Point K = {250, 0};
Cir(K, A);
Point L = {500, 0};
Cir(L, A);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/83danu6o.png)

---

对于第 $6$ 个数据，如图，给定 $A(0,0)$ 和 $B(1,0)$，尺规作图求作半径为 $\text{Cir}(A,B)$ 上一点 $O(0.90660864, 0.42197248)$。

$46$ 步做法，考虑朴素二分：

```cpp
Point A = {0, 0};
Point B = {0, 1};
Lin(A, B); 
Point L = A, R = B, T = {0.90660864, 0.42197248};
int cnt = 0;
while(cnt < 45) {
	Cir(L, R);
	Cir(R, L);
	Point M = {0, (R.y + L.y) / 2};
	Point X = {sqrt(3) / 2 * (R.y - L.y), M.y}, Y = {-sqrt(3) / 2 * (R.y - L.y), M.y}; 
    Lin(X, Y);
    if(M.y < T.y) L = M;
    else R = M;
    cnt += 3;
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/hq9l17a6.png)

$38$ 步做法，由于 $O$ 在 $\text{Cir}(A,B)$ 上，考虑在 $\text{Lin}(A,O)$ 上找一个特殊点，暴力得 $(44098,20525.000096)$ 或 $(102823,47858.000019)$，倍增即可：

```cpp
double y = 0, x = 0, l, r, m = -1;
int cnt;
while(1) {
    x++;
    y = x * 0.4654406117286;
    l = floor(x);
    r = l + 1;
    // if(floor(x * 1e3) != x * 1e3) continue;
    cnt = 0;
    while(abs(m - x) > 0.00001) {
        cnt++;
        m = (l + r) / 2;
        if(m > x) r = m;
        else l = m;
    }
    // if(cnt > 1) continue;
    cout<<fixed<<setprecision(8)<<"("<<x<<","<<y<<")  with "<<cnt<<endl;
    if(cnt == 1 && abs(floor(y) - y) <= 0.00001) break;
}
```

```cpp
Point A = {0, 0};
Point B = {0, 1};
Lin(A, B);
Point C = {0, -1};
Cir(B, C);
Cir(C, B); 
Point D = {-1.7320508075689, 0};
Point E = {1.7320508075689, 0};
Lin(D, E);
Cir(A, B); 
Cir(B, A);
Point F = {0, 2};
Cir(F, B);
Point G = {0, 3};
Cir(G, A);
Point H = {0, 6};
Cir(H, B);
Point I = {0, 11};
Cir(I, B);
Point J = {0, 21};
Cir(J, B);
Point K = {0, 41};
Cir(K, B);
Point L = {0, 81};
Cir(L, B);
Point M = {0, 161};
Cir(M, B);
Point N = {0, 321};
Cir(N, A);
Point O = {0, 642};
Cir(O, B);
Point P = {0, 1283};
Cir(P, A);
Point Q = {0, 2566};
Cir(Q, A);
Point R = {0, 5132};
Cir(R, B);
Point S = {0, 10263};
Cir(S, B);
Cir(A, I);
Point T = {11, 0};
Cir(T, A);
Point U = {22, 0};
Cir(U, A);
Point V = {44, 0};
Point W = {1, 0};
Cir(V, W);
Point X = {87, 0};
Cir(X, W);
Point Y = {173, 0};
Cir(Y, W);
Point Z = {345, 0};
Cir(Z, A);
Point AA = {690, 0};
Cir(AA, W);
Point BB = {1379, 0};
Cir(BB, W);
Point CC = {2757, 0};
Cir(CC, W);
Point DD = {5513, 0};
Cir(DD, W);
Point EE = {11025, 0};
Cir(EE, W);
Point FF = {22049, 0};
Cir(FF, A);
Point XX = {0, 20525};
Point YY = {44098, 0};
Cir(XX, YY);
Cir(YY, XX);
Point II = {39824.17141267561, 48452.48825608619};
Point JJ = {4273.828587324413, -27927.488256086195};
Lin(II, JJ);
Lin(XX, YY);
Point ZZ = {22049, 10262.5};
Lin(A, ZZ);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/65prfznp.png)

---

对于第 $7$ 个数据，如图，给定 $\triangle ABC$，求作其[费马点](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E9%97%AE%E9%A2%98/18897961)。

由于 $\triangle ABC$ 各内角均 $<120^\circ$，其费马点即为[正等角中心](https://baike.baidu.com/item/%E6%AD%A3%E7%AD%89%E8%A7%92%E4%B8%AD%E5%BF%83/18891596)，先以 $AC$ 为一边作等边 $\triangle ACD$，连 $BD$，此时 $\text{Lin}(B,D)$ 与 $\text{Cir}(C,A)$ 还交于点 $E$，易证 $\triangle AEC$ 与 $\triangle ABC$ 费马点相同，再作 $\text{Cir}(E,C)$ 即可。

```cpp
Point A = {0, 0};
Point B = {12.34441574, 0};
Point C = {5.16457145, 9.12243565};
Cir(A, C);
Cir(C, A);
Point D = {-5.3179752922888, 9.0338679003598};
Lin(D, B);
Point E = {11.2279870497877, 0.571025139751};
Cir(E, C);
Point G = {15.6020179899587, 10.0978023379945};
Lin(A, G); 
```

![](https://cdn.luogu.com.cn/upload/image_hosting/38of0aoa.png)

---

对于第 $8$ 个数据，如图，给定 $\triangle ABC$，过其内心 $D$ 求作 $\text{Lin}(A,B)$ 的垂足。

唯一想写证明的题：

根据内切圆的性质（即[切线长定理](https://baike.baidu.com/item/切线长定理)），$\begin{cases}AO=AE\\BO=BG\\CE=CG\end{cases}$ 且 $\begin{cases}AO+BO=AB\\BG+CG=BC\\AE+CE=AC\end{cases}$，也就是 $AO=\frac{AB-BC+AC}2=\frac{AB}2-\frac{BC-AC}2$，于是考虑表示出 $BI=BH=BC-CH=BC-AC$，此时 $AO=\frac{AB-BI}2=\frac{AI}2$，即点 $O$ 为 $AI$ 中点，用第 $1$ 个数据中的做法即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/jcr9aj1j.png)

```cpp
Point A = {0, 0};
Point B = {12.34441574, 0};
Point C = {5.16457145, 9.12243565};
Cir(C, A);
Point D = {11.6479642955079, 0.8848845781485};
Cir(B, D);
Point E = {11.2183316706783, 0};
Cir(A, E);
Cir(E, A);
Point G = {5.6091658353392, -9.715360215887};
Point H = {5.6091658353392, 9.715360215887};
Lin(G, H);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/sn5md4tz.png)

---

对于奇奇怪怪的第 $9$ 组数据，奇奇怪怪的给定奇奇怪怪的原点 $A$ 和奇奇怪怪的点 $B$，奇奇怪怪的求作另一个奇奇怪怪的点 $O$。

奇奇怪怪的主要知识：奇奇怪怪。于是给出奇奇怪怪的解法~~（话说这两个出题人瞎画的吧）~~：

```cpp
Point A = {0, 0};
Point B = {10.64978745, 0};
Cir(A, B);
Cir(B, A);
Point C = {-10.64978745, 0};
Point D = {5.324893725, 9.2229864766047};
Cir(C, A);
Cir(D, C);
Point E = {-2.8891429892634, -7.293172854404};
Point G = {-5.324893725, 9.2229864766047};
Lin(E, G);
Point H = {-3.9647169644197, 0};
Cir(H, C); 
```

![](https://cdn.luogu.com.cn/upload/image_hosting/sqyprhvz.png)

---

对于神神奇奇的第 $10$ 组数据，神神奇奇的给定神神奇奇的原点 $A$ 和神神奇奇的点 $B$，神神奇奇的求作另一个神神奇奇的点 $O$。

神神奇奇的主要知识：神神奇奇。于是在奇奇怪怪的第 $9$ 个数据的基础上给出神神奇奇的解法：

```cpp
Point A = {0, 0};
Point B = {10.64978745, 0};
Cir(A, B);
Cir(B, A);
Point C = {-10.64978745, 0};
Point D = {5.324893725, 9.2229864766047};
Cir(C, A);
Cir(D, C);
Point E = {-2.8891429892634, -7.293172854404};
Point G = {-5.324893725, 9.2229864766047};
Lin(E, G);
Point H = {-3.9647169644197, 0};
Cir(H, C); 
Point K = {-2.1668572419475, 6.4387784412486};
Lin(D, K);
Point N = {22.6154412356748, 15.6487848683712};
Point L = {21.2995749, 0};
Point J = {-13.0855381857366, 10.3675016799389};
Lin(L, J);
Point M = {-6.5503572407083, 8.3970704861444};
Cir(M, N);
```

![](https://cdn.luogu.com.cn/upload/image_hosting/apded9a7.png)

---

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
int n;
struct Point {
	double x, y;
};
struct Result {
	int t;
	double x1, y1, x2, y2;
};
vector<Result> v;
void Cir(Point A, Point B) {
	v.push_back({1, A.x, A.y, B.x, B.y});
}
void Lin(Point A, Point B) {
	v.push_back({2, A.x, A.y, B.x, B.y});
}
void Print() {
	cout<<v.size()<<endl;
	for(auto i : v)
		cout<<i.t<<" "<<fixed<<setprecision(10)<<i.x1<<" "<<i.y1<<" "<<i.x2<<" "<<i.y2<<endl;
}
signed main() {
	cin>>n;
	if(n == 1) {
		Point A = {0, 0};
		Point B = {1, 0};
		Cir(A, B);
		Cir(B, A);
		Point C = {0.5, 0.8660254037844};
		Point D = {0.5, -0.8660254037844};
		Lin(C, D);
	} else if(n == 2) {
		Point A = {0, 0};
		Point B = {1, 0};
		Point C = {5.23124577, 4.31624417};
		Cir(A, C);
		Cir(B, C);
		Point D = {5.23124577, -4.31624417};
		Lin(C, D);
	} else if(n == 3) {
		Point A = {0, 0};
		Point B = {0, 1};
		Point C = {1, 0};
		Point D = {1, 1};
		Cir(A, C);
		Cir(C, A);
		Point E = {0.5, 0.8660254037844};
		Point G = {0.5, -0.8660254037844};
		Lin(E, G);
		Point H = {0.5, 1};
		Point I = {0.5, 0};
		Cir(H, I);
		Point J = {-0.4916198487096, 0.8708099243548};
		Point K = {0.9916198487096, 0.1291900756452};
		Lin(J, K);
	} else if(n == 4) {
		Point A = {0, 0};
		Point B = {1, 0};
		Cir(B, A);
		Point C = {2, 0};
		Cir(C, A);
		Point D = {4, 0};
		Cir(D, A);
		Point E = {8, 0};
		Cir(E, A);
		Point G = {16, 0};
		Cir(G, A);
		Point H = {32, 0};
		Cir(H, A);
		Point I = {64, 0};
		Cir(I, A);
		Point J = {128, 0};
		Cir(J, A);
		Point K = {256, 0};
		Cir(K, A);
		Point L = {512, 0};
		Cir(L, A);
	} else if(n == 5) {
		Point A = {0, 0};
		Point B = {1, 0};
		Cir(A, B);
		Point C = {-1, 0};
		Cir(B, C);
		Point D = {3, 0};
		Cir(D, C);
		Point E = {7, 0};
		Cir(E, C);
		Point G = {15, 0};
		Cir(G, C);
		Point H = {31, 0};
		Cir(H, C);
		Point I = {63, 0};
		Cir(I, B);
		Point J = {125, 0};
		Cir(J, A);
		Point K = {250, 0};
		Cir(K, A);
		Point L = {500, 0};
		Cir(L, A);
	} else if(n == 6) {
		Point A = {0, 0};
		Point B = {0, 1};
		Lin(A, B);
		Point C = {0, -1};
		Cir(B, C);
		Cir(C, B); 
		Point D = {-1.7320508075689, 0};
		Point E = {1.7320508075689, 0};
		Lin(D, E);
		Cir(A, B); 
		Cir(B, A);
		Point F = {0, 2};
		Cir(F, B);
		Point G = {0, 3};
		Cir(G, A);
		Point H = {0, 6};
		Cir(H, B);
		Point I = {0, 11};
		Cir(I, B);
		Point J = {0, 21};
		Cir(J, B);
		Point K = {0, 41};
		Cir(K, B);
		Point L = {0, 81};
		Cir(L, B);
		Point M = {0, 161};
		Cir(M, B);
		Point N = {0, 321};
		Cir(N, A);
		Point O = {0, 642};
		Cir(O, B);
		Point P = {0, 1283};
		Cir(P, A);
		Point Q = {0, 2566};
		Cir(Q, A);
		Point R = {0, 5132};
		Cir(R, B);
		Point S = {0, 10263};
		Cir(S, B);
		Cir(A, I);
		Point T = {11, 0};
		Cir(T, A);
		Point U = {22, 0};
		Cir(U, A);
		Point V = {44, 0};
		Point W = {1, 0};
		Cir(V, W);
		Point X = {87, 0};
		Cir(X, W);
		Point Y = {173, 0};
		Cir(Y, W);
		Point Z = {345, 0};
		Cir(Z, A);
		Point AA = {690, 0};
		Cir(AA, W);
		Point BB = {1379, 0};
		Cir(BB, W);
		Point CC = {2757, 0};
		Cir(CC, W);
		Point DD = {5513, 0};
		Cir(DD, W);
		Point EE = {11025, 0};
		Cir(EE, W);
		Point FF = {22049, 0};
		Cir(FF, A);
		Point XX = {0, 20525};
		Point YY = {44098, 0};
		Cir(XX, YY);
		Cir(YY, XX);
		Point II = {39824.17141267561, 48452.48825608619};
		Point JJ = {4273.828587324413, -27927.488256086195};
		Lin(II, JJ);
		Lin(XX, YY);
		Point ZZ = {22049, 10262.5};
		Lin(A, ZZ);
	} else if(n == 7) {
		Point A = {0, 0};
		Point B = {12.34441574, 0};
		Point C = {5.16457145, 9.12243565};
		Cir(A, C);
		Cir(C, A);
		Point D = {-5.3179752922888, 9.0338679003598};
		Lin(D, B);
		Point E = {11.2279870497877, 0.571025139751};
		Cir(E, C);
		Point G = {15.6020179899587, 10.0978023379945};
		Lin(A, G); 
	} else if(n == 8) {
		Point A = {0, 0};
		Point B = {12.34441574, 0};
		Point C = {5.16457145, 9.12243565};
		Cir(C, A);
		Point D = {11.6479642955079, 0.8848845781485};
		Cir(B, D);
		Point E = {11.2183316706783, 0};
		Cir(A, E);
		Cir(E, A);
		Point G = {5.6091658353392, -9.715360215887};
		Point H = {5.6091658353392, 9.715360215887};
		Lin(G, H);
	} if(n == 9) {
		Point A = {0, 0};
		Point B = {10.64978745, 0};
		Cir(A, B);
		Cir(B, A);
		Point C = {-10.64978745, 0};
		Point D = {5.324893725, 9.2229864766047};
		Cir(C, A);
		Cir(D, C);
		Point E = {-2.8891429892634, -7.293172854404};
		Point G = {-5.324893725, 9.2229864766047};
		Lin(E, G);
		Point H = {-3.9647169644197, 0};
		Cir(H, C); 
	} else if(n == 10) {
		Point A = {0, 0};
		Point B = {10.64978745, 0};
		Cir(A, B);
		Cir(B, A);
		Point C = {-10.64978745, 0};
		Point D = {5.324893725, 9.2229864766047};
		Cir(C, A);
		Cir(D, C);
		Point E = {-2.8891429892634, -7.293172854404};
		Point G = {-5.324893725, 9.2229864766047};
		Lin(E, G);
		Point H = {-3.9647169644197, 0};
		Cir(H, C); 
		Point K = {-2.1668572419475, 6.4387784412486};
		Lin(D, K);
		Point N = {22.6154412356748, 15.6487848683712};
		Point L = {21.2995749, 0};
		Point J = {-13.0855381857366, 10.3675016799389};
		Lin(L, J);
		Point M = {-6.5503572407083, 8.3970704861444};
		Cir(M, N);
	}
	Print();
    return 0;
}
```

---

## 作者：danny101 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P5600)

#### 题目大意：

你需要解决 $10$ 道尺规作图题，每道题有限定步数，写出过程。

#### 大致思路：

说明：以下图中目标点用标红的 $G$ 点表示。

$\textbf{Data 1}$

给定 $(0,0)$ 和 $(0,1)$，求 $(0,0.5)$。

显然是求两点之间的中点。实现方法如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/jo43lh1w.png)

$\textbf{Data 2}$

给定一条直线 $AB$ 以及直线外一点 $C$，求过 $C$ 的 $AB$ 的垂线，限 $3$ 步。

较简单，以 $A$ 为圆心，$AC$ 作半径画圆 $A$，以 $B$ 为半径， $BC$ 作半径画圆 $B$，将圆 $A$ 与圆 $B$ 的两个交点连一条直线，与 $AB$ 的交点即为目标点。

![](https://cdn.luogu.com.cn/upload/image_hosting/202x0due.png)

$\textbf{Data 3}$

给定 $(0,0),(0,1),(1,0),(1,1)$，求点 $(\frac{1}{2},\frac{3}{8})$。

前三步肯定是求 $AB$ 中点，接下来发现以 $(0,1)$ 为圆心，以 $(0,1)$ 到 $(0.5,0)$ 的距离为半径作的圆与之前作的圆 $A$ 的两个交点的 $y$ 坐标均为 $\frac{3}{8}$，于是连线即得目标点。

![](https://cdn.luogu.com.cn/upload/image_hosting/3jozqbsv.png)

$\textbf{Data 4}$

已知 $(0,0)$ 与 $(1,0)$，求点 $(1024,0)$。

倍增即可，每次向 $(0,0)$ 作圆。

$\textbf{Data 5}$

已知 $(0,0)$ 与 $(1,0)$，求点 $(1000,0)$。

一样是倍增，只是有几步不向 $(0,0)$ 作圆。

每次得到的 $x$ 坐标为：

$1\rightarrow2\rightarrow4\rightarrow8\rightarrow16\rightarrow32\rightarrow64\rightarrow128\rightarrow252\rightarrow504\rightarrow1000$

其中，$252$ 的一步是向 $(4,0)$ 作圆，$1000$ 的一步是向 $(8,0)$ 作圆。

$\textbf{Data 6}$

给定 $(0,0)$ 与 $(1,0)$，求 $(0.90660864,0.42197248)$。

显然可以利用精度，找到圆外一个点，向原点连线与圆的交点非常接近目标点。

经过枚举可得最好的一个点为 $(44098,20525)$，倍增求得后向原点连线即可。

$\textbf{Data 7}$

给定三角形 $ABC$，求它的费马点。

按照 ~~简单~~ 的几何知识可得方法为：

先以 $A,B$ 为圆心，$AB$ 为半径分别作圆 $A,B$，两圆下方交点为 $D$。

连 $CD$ 交圆 $A$ 与点 $F$，再以 $F$ 为圆心，$AF$ 为半径，作圆交圆 $B$ 与点 $E$。

连起 $AE$，与 $CD$ 的交点即为目标点。

差不多就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/8rj68hee.png)

$\textbf{Data 8}$

同样是利用几何知识，因为三角形顶点到内切圆在它相邻两边的切点的距离相等，可以得出以下方法：

以 $C$ 为圆心，$AC$ 为半径作圆 $A$ 交 $BC$ 于点 $D$，再以 $B$ 为圆心，$BD$ 做半径作圆 $B$，交 $AB$ 于点 $E$。作 $AE$ 中点即为目标点。

作图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/rgnk1av0.png)

$\textbf{Data 9}$

不需要思路的乱搞题。

![](https://cdn.luogu.com.cn/upload/image_hosting/04tipvd3.png)

$\textbf{Data 10}$

同上，但是更难了。我们把这次的目标点放到上道题的图上，一看，诶，$GIC$ 三点共线？！于是就有了下面这个做法：

![](https://cdn.luogu.com.cn/upload/image_hosting/gw1ywvdg.png)

总结：$Data\;1,2,4,5$ 纯属送分，$Data\;3,7,8$ 对几何知识有一定要求，$Data\;6$ 需要清奇思路，$Data\;9,10$ 纯属乱搞与运气。

~~其实只要运气够好，$\sout{9,10}$ 相当于送分。~~

具体答案啥的就不放啦~

---

## 作者：namespace_std (赞：3)

考试的时候手推了7个点，```#7```的$7'$没写完（

~~对于这种题目我可能还是太菜了，需要[一些东西](http://www.geogebra.org/graphing)辅助一下。~~

[由于部分答案长度过大，贴在这里](https://www.luogu.org/paste/tmcdmj41)

```#1``` 找中位线。

~~初中尺规作图经典题。~~

~~配一个图放在下面，不讲了~~

![](https://cdn.luogu.com.cn/upload/image_hosting/sgqyy8ml.png)

```#2``` 过一点作已知直线的垂线。

考虑利用等腰三角形三线合一，将垂线化成两个等腰三角形的中线。

两个等腰三角形可以用两个圆构造。（见下图）

![](https://cdn.luogu.com.cn/upload/image_hosting/2gm219fn.png)

```#3``` 给定一个$(0,0)$ $(0,1)$ $(1,1)$ $(1,0)$组成的正方形，作出$(1/2,3/8)$。

作出三个圆和底边的中垂线，则所求点在中垂线上。题目中提示$EF=BE=AE$，由此可以发现，$E$是一个已知三顶点和一条中线的等腰三角形$\Delta ABF$的内接圆圆心。我们可以继续作出$BF$的中垂线，两垂线交点即为$E$。

![](https://cdn.luogu.com.cn/upload/image_hosting/xx3q0lbq.png)

```#4,5``` 给定$y=0$和$(0,0)$ $(1,0)$，求$(x,0)$。

倍增优化一下。

最初我们有$(0,0)$和$(1,0)$，据此我们可以：（令$n$为正整数）

若要求$(2n-1,0)$，我们可以由$(n,0)$向$(1,0)$作圆。

若要求$(2n,0)$，我们可以由$(n,0)$向$(0,0)$作圆。

坐标的范围太大不画图了。

```#6``` 给出$(0,0)$ $(1,0)$和单位圆，求单位圆上的一点。

这个搞了一个小时才弄明白。

由于已经有单位圆了，我们可以想办法求出一条过原点的，斜率约为$0.90660864 /0.42197248=2.148501817$的直线。

由于$2.148501817≈44098/20525$，我们就可以取$(44098,20525)$为这条直线的一个端点。

然后参照$#4,5$的做法作出$x$轴，$y$轴，以及$(44098,0)$和$(0,20525)$。

之后暴力求出两点连线中点和原点连上，正好$40$步（光速逃

不给图了，理由同上QaQ

P.S.看到站内有人用二分圆弧的方法$21$步解决orz

```#7``` 给定三个点，求出和这三个点连线所成的三个角均为$120\degree$的点。

以$A$、$B$两个点为圆心，$|AB|$为半径作圆，两圆在$C$异侧交于$D$。

则答案一定在$CD$上。

证明：作出$\Delta ABD$的外接圆，交$CD$于$E$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fphohnyf.png)

那么$\angle AED$和$\angle BED$相等，均为$60\degree$。

从而$\angle AEB=\angle AEC=\angle BEC=120\degree$

即$E$为所求。

然而我们不能作外接圆，因此我们只能采用其他的思路。

由于两条不平行直线唯一确定一个点，我们可以对$AC$边或者$BC$边仿照上面的思路，就有$7$分了。

又考虑到$ABC$三点的答案和$ABF$的答案相同，而我们已经有了以$A$点为圆心，$|AF|$为半径的圆，因此我们转向对$F$运行上述算法，可以少作一个圆，即可得到满分。

```#8``` 求出三角形内切圆在一边上的切点。

比较思维的一个数据点。

如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/baydch92.png)

**这里需要用到三角形内切圆的一个性质：每个顶点到与之相邻的两个切点的距离相等。**

我们设$A$到两个切点的距离为$x$，$B$到两个切点的距离为$y$，$C$到两个切点的距离为$z$。

列方程：

$x+y=c$

$y+z=a$

$z+x=b$

可以解得$x=(c-a+b)/2$。

于是显然要求的点是上图中$AE$的中点。

```#9,10``` ？？？

~~不可描述~~

只能写暴力枚举了

不过```#10```的图似乎是```#9```基础上做过来的？

~~（居然能在```#9```的图上加$3$笔画出```#10```）~~

构造的图片见下。

（```#9```只需要作出$1-6$，所求的两个点标成了红色）

![](https://cdn.luogu.com.cn/upload/image_hosting/0wjl72c5.png)

~~（写得很烂不要喷我）~~

---

## 作者：Disjoint_cat (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5600)

## 前言

这是一道**提交答案题**，所以本题解中所有测试点**只呈现答案**（~~其实是我懒得写代码了~~）。

后面的测试点基本上是乱搞出来的。

在做这道题前，最好有一个画图软件（如 [Geogebra](https://www.geogebra.org/)）。

## 解法

每个测试点的解法将会分开讲解。

### $Data\ 1$

题意：$3$ 步中垂线。

这个就没啥好说的了。~~中垂线都不会就别做这道题了。~~

![](https://cdn.luogu.com.cn/upload/image_hosting/6fgg55ww.png)

```
3
1 0 0 1 0
1 1 0 0 0
2 0.5 0.866025 0.5 -0.866025
```

### $Data\ 2$

题意：$3$ 步作垂线。

也没啥好说的。

![](https://cdn.luogu.com.cn/upload/image_hosting/vy4iteh5.png)

```
3
1 0 0 5.231245 4.316244
1 1 0 5.231245 4.316244
2 5.231245 4.316244 5.231245 -4.316244
```

### $Data\ 3$

题意：$5$ 步作正方形内某个点。

首先肯定要做 $AB$（或者 $CD$）的中垂线。

观察到 $QA=QG$，于是考虑作 $AG$ 的中垂线。剩下 $2$ 步乱搞即可。（注意图中 $J$ 点是 $\odot A$ 与 $\odot G$ 的交点）

![](https://cdn.luogu.com.cn/upload/image_hosting/5e77qd14.png)

```
5
1 0 0 1 0
1 1 0 0 0
2 0.5 0.866025 0.5 -0.866025
1 0.5 1 0.5 0
2 0.991619 0.12919 -0.491619 0.870809
```

### $Data\ 4,5$

题意：给出 $(0,0),(1,0)$，在 $10$ 步内分别做出 $(1024,0),(1000,0)$。

$1024$ 直接倍增 $10$ 次就行了。

$1000$ 的话，先倍增 $5$ 次得到 $32$，然后做两个向 $(1,0)$ 的圆，分别得到 $(63,0)$ 和 $(125,0)$，然后再倍增 $3$ 次即可。

```
10
1 1 0 0 0
1 2 0 0 0
1 4 0 0 0
1 8 0 0 0
1 16 0 0 0
1 32 0 0 0
1 64 0 0 0
1 128 0 0 0
1 256 0 0 0
1 512 0 0 0
```
```
10
1 1 0 0 0
1 2 0 0 0
1 4 0 0 0
1 8 0 0 0
1 16 0 0 0
1 32 0 1 0
1 63 0 1 0
1 125 0 0 0
1 250 0 0 0
1 500 0 0 0
```

### $Data\ 6$

题意：给定一个圆，作圆上一个没什么特性的点。

二分需要 $40+$ 步，只能拿 $9$ 分。

经过暴力枚举，发现 $(44098,20525)$ 与原点的连线可以很好地逼近这个点。

于是可以倍增出 $(44098,0),(0,20525)$，然后作这两个点的中点向原点连线即可。正好 $40$ 步。

看了好长时间才明白。

```
40
2 0 0 0 1
1 0 -1 0 1
1 0 1 0 -1
2 1.73205 0 -1.73205 0
1 1 0 0 0
1 2 0 1 0
1 3 0 0 0
1 6 0 1 0
1 11 0 0 0
1 22 0 0 0
1 44 0 1 0
1 87 0 1 0
1 173 0 1 0
1 345 0 0 0
1 690 0 1 0
1 1379 0 1 0
1 2757 0 1 0
1 5513 0 1 0
1 11025 0 1 0
1 22049 0 0 0
1 0 1 0 0
1 0 2 0 1
1 0 3 0 0
1 0 6 0 1
1 0 11 0 1
1 0 21 0 1
1 0 41 0 1
1 0 81 0 1
1 0 161 0 1
1 0 321 0 0
1 0 642 0 1
1 0 1283 0 0
1 0 2566 0 0
1 0 5132 0 1
1 0 10263 0 1
1 44098 0 0 20525
1 0 20525 44098 0
2 39824.171412 48452.488256 4273.828587 -27927.48825
2 0 20525 44098 0
2 22049 10262.5 0 0
```

### $Data\ 7$

题意：$5$ 步作一个三角形的费马点。

显然~~乱搞~~得到前 $3$ 步。

![](https://cdn.luogu.com.cn/upload/image_hosting/4ukguxuj.png)

再从另一个方向作一条这样的直线，就可以得到 $Q$ 点。

但是这样作的话，一共需要 $6$ 步，只能拿 $7$ 分。

~~于是再次开始乱搞~~

最后得到下面的 $5$ 步做法。

![](https://cdn.luogu.com.cn/upload/image_hosting/nygd7d54.png)

```
5
1 0 0 12.344415 0
1 12.344415 0 0 0
2 5.164571 9.122435 6.172207 -10.69057
1 5.055779 11.261602 0 0
2 0 0 17.400194 11.261602
```

### $Data\ 8$

题意：$5$ 步做出三角形内切圆与一条边的交点。

做出 $\odot A,\odot B$ 后，发现 $Q$ 就是 $DE$ 的中点，于是直接 $3$ 步一个中垂线即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/52hgcvss.png)

```
5
1 0 0 5.164571 9.122435
1 12.344415 0 5.164571 9.122435
1 0.73541 0 10.48292 0
1 10.48292 0 0.73541 0
2 5.609165 8.441591 5.609165 -8.441591
```

### $Data\ 9$

题意：？？？

纯乱搞

作法：先作 $\odot A,\odot B,\odot C$，然后以 $C$ 为一点作 $\odot D$，连接 $EF$，最后做 $\odot G$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0zom1g0y.png)

```
6
1 0 0 10.649787 0
1 10.649787 0 0 0
1 -10.649787 0 0 0
1 5.324893 9.222986 -10.649787 0
2 -2.889142 -7.293172 -5.324893 9.222986
1 -3.964716 0 -10.649787 0
```

### $Data\ 10$

题意：$Data\ 9$ 加上 $3$ 步。

连接 $DH,IJ$，最后过 $L$ 作 $\odot K$。

![](https://cdn.luogu.com.cn/upload/image_hosting/g9xzv4dt.png)

```
9
1 0 0 10.649787 0
1 10.649787 0 0 0
1 -10.649787 0 0 0
1 5.324893 9.222986 -10.649787 0
2 -2.889142 -7.293172 -5.324893 9.222986
1 -3.964716 0 -10.649787 0
2 -2.166857 6.438778 5.324893 9.222986
2 21.299574 0 -13.085538 10.367501
1 -6.550357 8.397070 22.615441 15.648784
```

---

## 作者：Eltaos_xingyu (赞：1)

这道题做了我 $2$ 天才做完......

电脑画图的话，作者建议使用 Geogebra，~~因为作者不会用几何画板。~~

### T1

简单的求中垂线，初中经典两圆一线即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/0bu6tcip.png)

### T2

简单的求垂足，利用圆的对称性即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/k4rs3h39.png)

### T3

第一个卡到我的点。

这个数据给了一个矩形，让我们求一个奇怪的点。

先画图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kwsznpfq.png)

可以发现 $\lvert A \ Goal \rvert=\lvert E \ Goal \rvert$，那么求 $AE$ 中垂线即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/7bc09ztl.png)

### T4

要求的点横坐标 $1024=2^{10}$，很容易想到倍增。

所以直接倍增 $10$ 次即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/oivghedu.png)

### T5

很快可以看出这道题和 T4 一样是倍增，但是中间要进行一些微调。

考虑到这两个数据目标点的差距只有 $24=3 \times 8$，又因为微调一个会影响到后面的倍增，于是只用微调最后两个（$2^0+2^1=3$），也就是说，在 T4 的图中，我们只需将以点 $J$ 和 $K$ 为圆心的圆的圆上一点设为 $(8,0)$ 即可。

图和 T4 差不多，就不放了。

### T6

这个数据点不只是构造方案恶心，敲答案更恶心......

还是一样，先画图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3xtupxb9.png)

容易发现要求的点就在圆上，很容易想到对 $(0,0)$ 与 $(0,1)$ 之间的 $y$ 轴区间二分。

作者是个蒟蒻，做出来普通二分过不了......

~~于是考虑人类智慧，~~二分到一定程度时，可以画一个这样的圆来与之前的圆形成与点 $Goal$ 的 $y$ 坐标更接近的交点。（如图中选中的圆）

![](https://cdn.luogu.com.cn/upload/image_hosting/aha7x0y6.png)

作者懒得再画一遍了，但是最后可以通过类似于这样的方式降低误差：

![](https://cdn.luogu.com.cn/upload/image_hosting/7idm513m.png)

注：这些圆不是我代码中的那些圆，只是举个例子！

总的来说，这种做法极其玄学，但是这种做法的确只用 $32$ 步就做出来了......

### T7

感觉比 T6 简单，就是要用一些小技巧。

容易看出这道题就是让我们求三个点的费马点。大家初中肯定学过费马点怎么求吧？就是以三角形的三边作等边三角形，然后等边三角形的顶点连接对应点就行了：

![](https://cdn.luogu.com.cn/upload/image_hosting/927ic1ta.png)

但是这样做要 $6$ 步，怎么缩减步数呢？

考虑到费马点有一个特殊性质，就是任意连接三个点之中的任意两个点，夹角都为 $120\degree$，那么对于 $B\ Goal$ 这条线段上的任意一点 $P$ 来讲，点 $Goal$ 都满足点 $A$，$C$，$P$ 的费马点的特殊性质，也就是说，点 $Goal$ 就是点 $A$，$C$，$P$ 的费马点。（好好理解这句话，理解过后再读下面的构造方法更佳）

那么只需要在 $B\ Goal$ 这条线段上找到能与现在已知的圆构出等边三角形的点即可。显然，有如下的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/5il16zy9.png)

### T8

个人认为比 T7 难，因为我起初看不出来这个点有什么特殊几何意义......

好吧，直接说了，这个数据让我们求的是三角形内切圆的一个与一边的交点。

![](https://cdn.luogu.com.cn/upload/image_hosting/072cf7up.png)

通过内切圆性质可知 $\lvert A\ Goal \rvert=\frac{\lvert AB \rvert+\lvert AC \rvert-\lvert BC \rvert}{2}$，那么只需构造一个这样的长度即可。

考虑先将 $AC$，$BC$ 的长度都导到 $AB$ 上，然后再做加减。

![](https://cdn.luogu.com.cn/upload/image_hosting/rnn620e3.png)

容易发现 $\lvert D\ Goal \rvert=\lvert E\ Goal \rvert$，那么求 $DE$ 中垂线即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/bcjws5fv.png)

### T9&10

难度最大的两个点，作者是实在除乱搞之外没有想到其它好的做法了......

![](https://cdn.luogu.com.cn/upload/image_hosting/os01d8a4.png)

值得注意的是，点 $Goal10$ 是在直线 $DH$ 上的，而点 $D$，$H$ 都是第 $9$ 个数据点中求出过的点，这确定了第 $10$ 个点可以由第 $9$ 个点演化而来。

最后，贴上 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
void _1(){
	cout<<"3\n\
1 0 0 1 0\n\
1 1 0 0 0\n\
2 0.5 0.8660254038 0.5 -0.8660254038";
}
void _2(){
	cout<<"3\n\
1 0 0 5.2312457700 4.3162441700\n\
1 1 0 5.2312457700 4.3162441700\n\
2 5.2312457700 4.3162441700 5.2312457700 -4.3162441700";
}
void _3(){
	cout<<"5\n\
1 0 0 1 0\n\
1 1 0 0 0\n\
2 0.5 0.8660254038 0.5 -0.8660254038\n\
1 0.5 1 0.5 0\n\
2 -0.4916198487 0.8708099244 0.9916198487 0.1291900756";
}
void _4(){
	cout<<"10\n\
1 1 0 0 0\n\
1 2 0 0 0\n\
1 4 0 0 0\n\
1 8 0 0 0\n\
1 16 0 0 0\n\
1 32 0 0 0\n\
1 64 0 0 0\n\
1 128 0 0 0\n\
1 256 0 0 0\n\
1 512 0 0 0";
}
void _5(){
	cout<<"10\n\
1 1 0 0 0\n\
1 2 0 0 0\n\
1 4 0 0 0\n\
1 8 0 0 0\n\
1 16 0 0 0\n\
1 32 0 0 0\n\
1 64 0 0 0\n\
1 128 0 0 0\n\
1 256 0 8 0\n\
1 504 0 8 0";
}
void _6(){
	cout<<"32\n\
2 0 0 0 1\n\
1 0 1 0 0\n\
2 -0.8660254038 0.5 0.8660254038 0.5\n\
1 0 0.5 0 0\n\
1 0 0 0 0.5\n\
2 -0.4330127019 0.25 0.4330127019 0.25\n\
1 0 0.25 0 0.5\n\
1 0 0.5 0 0.25\n\
2 -0.2165063509 0.375 0.2165063509 0.375\n\
1 0 0.375 0 0.5\n\
1 0 0.5 0 0.375\n\
2 -0.1082531755 0.4375 0.1082531755 0.4375\n\
1 0 0.4375 0 0.375\n\
1 0 0.375 0 0.4375\n\
2 -0.0541265877 0.40625 0.0541265877 0.40625\n\
1 0 0.40625 0 0.4375\n\
1 0 0.4375 0 0.40625\n\
2 -0.0270632939 0.421875 0.0270632939 0.421875\n\
1 0 0.421875 0 0.4375\n\
1 0 0.4375 0 0.421875\n\
2 -0.0135316469 0.4296875 0.0135316469 0.4296875\n\
1 0 0.421875 0 0.4296875\n\
1 0 2 0 0.421875\n\
2 -0.0156248085 0.4219523515 0.0156248085 0.4219523515\n\
2 0.0078124761 0.4218943379 -0.0078124761 0.4218943379\n\
1 0 0.4218943379 0 0.421875\n\
1 0 0.4219136757 0 0.4218943379\n\
1 0 0.4219330136 0 0.4219136757\n\
1 0 0.4219523515 0 0.4219330136\n\
1 0.0000193379 0.4219523515 0 0.4219523515\n\
1 0.0000096689 0.4219690986 0 0.4219523515\n\
2 -0.0000096689 0.4219690986 0.0000096689 0.4219690986";
}
void _7(){
	cout<<"5\n\
1 0 0 5.16457145 9.12243565\n\
1 5.16457145 9.12243565 0 0\n\
2 -5.3179752923 9.0338679004 12.34441574 0\n\
1 11.2279870498 0.5710251398 5.16457145 9.12243565\n\
2 6.0634155998 -8.5514105102 5.16457145 9.12243565";
}
void _8(){
	cout<<"5\n\
1 0 0 5.16457145 9.12243565\n\
1 12.34441574 0 5.16457145 9.12243565\n\
1 0.7354107776 0 10.4829208931 0\n\
1 10.4829208931 0 0.7354107776 0\n\
2 5.6091658353 8.4415913837 5.6091658353 -8.4415913837";
}
void _9(){
	cout<<"6\n\
1 0 0 10.64978745 0\n\
1 10.64978745 0 0 0\n\
1 -10.64978745 0 0 0\n\
1 5.324893725 9.2229864766 -10.64978745 0\n\
2 -5.324893725 9.2229864766 -2.8891429893 -7.2931728544\n\
1 -3.9647169644 0 -10.64978745 0";
}
void _10(){
    cout<<"9\n\
1 0 0 10.64978745 0\n\
1 10.64978745 0 0 0\n\
1 -10.64978745 0 0 0\n\
1 5.324893725 9.2229864766 -10.64978745 0\n\
2 -5.324893725 9.2229864766 -2.8891429893 -7.2931728544\n\
1 -3.9647169644 0 -10.64978745 0\n\
2 5.324893725 9.2229864766 -2.1668572419 6.4387784412\n\
2 -13.0855381857 10.3675016799 21.2995749 0\n\
1 -6.5503572407 8.3970704861 22.6154412357 15.6487848684";
}
int main()
{
	ios::sync_with_stdio(false);
	//freopen(".in","r",stdin);
	int T;cin>>T;
	if(T==1)_1();
	else if(T==2)_2();
	else if(T==3)_3();
	else if(T==4)_4();
	else if(T==5)_5();
	else if(T==6)_6();
	else if(T==7)_7();
	else if(T==8)_8();
	else if(T==9)_9();
	else _10();
	return 0;
}
```


---


# 小 K 与毕业旅行

## 题目背景

小 K 是一个刚刚高考完的高中生，他正在计划一次毕业旅行，但却被一些细节难住了，快来帮帮他！

## 题目描述

毕业旅行的计划上一共有 $n$ 个景点，大家会按某种顺序游览这些景点，每一个景点都会被游览恰好一次。

每个景点都有一个坐标 $a_i$，从坐标为 $a$ 的景点坐车前往坐标为 $b$ 的景点会给大家造成 $a \times b$ 的不适感，每次下车后不适感都会清零（即不适感不会累加）。如果某次坐车的不适感超过了某个常数 $w$，就会有人生病。

小 K 想问你，有多少种游览所有景点的顺序，使得全程都不会有人生病，答案对 $998244353$ 取模。

## 说明/提示

**样例解释**

对于样例 $1$，有 $2-1-3$ 和 $3-1-2$ 两种合法的顺序。

**数据范围**

本题共有 $10$ 个子任务，你需要通过一个子任务内的所有测试点才能取得这个子任务的分数。

对于所有数据，$0 \le w, |a_i| \le 10^9 $，$1 \le n \le 50000$。

| # | $n$ | $a$ | 分值 |
| ---- | ---- | ---- | ---- |
| 1 | $n \le 10$ | 无特殊限制 | $5$ |
| 2 | $n \le 20$ | 无特殊限制 | $5$ |
| 3 | $n \le 2000 $ | $a_i \in \{ 1,w \}$ | $5$ |
| 4 | $n\le 2000 $ | 不同的 $a_i$ 只有三个，$a_i \ge 0$ | $5$ |
| 5 | $n\le 200 $ | $a_i\ge 0 $ | $10$ |
| 6 | $n\le 2000$ | $a_i\ge 0$ | $15$ |
| 7 | $n\le 50000$ | $a_i \ge 0 $ | $20$ |
| 8 | $n\le 200 $ | 无特殊限制 | $15$ |
| 9 | $n\le 2000 $ | 无特殊限制 | $10$ |
| 10 | $n\le 50000 $ | 无特殊限制 | $10$ |

## 样例 #1

### 输入

```
3 3
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5
1 1 4 5 1 4```

### 输出

```
144```

## 样例 #3

### 输入

```
16 20
9 9 3 2 4 4 8 5 3 -1 -9 -1 -9 -8 -1 0```

### 输出

```
802901549```

# 题解

## 作者：jerome_wei (赞：16)

我们称一对数可以匹配当且仅当两个数的乘积$\le w$

## 1($a_i \ge 0$)

如果直接按照从小到达插入或从大到小插入很难处理，想办法构造一个插入顺序，使得任何位置 $i$ 插入的数 $a_i$ 满足以下条件之一：

1. $\forall _{j<i},a_i *a_j \le w$，我们称满足这类数的为 $A$ 类
2. $\forall _{j<i},a_i *a_j > w$，我们称满足这类数的为 $B$ 类

如果有以上条件，我们考虑依照这个顺序插入，这个时候是一个经典的 dp 套路，设 $f[i][j]$ 表示插入了前 $i$ 个数，前 $i$ 个数已经组成了 $j$ 个连续段（指填入的数位置连续）的方案数。（这个套路的 dp 题很多，「JOI Open 2016」摩天大楼 是其中一例）

每次的转移有三种：

1. 插入一个新的连续段
2. 合并两个相邻连续段
3. 一个连续段的两边延长

发现 $A$ 类三种转移都能转移， $B$ 类只能转移第一类。



这个 插入顺序 有很多种方法构造，在此叙述比较简单的一种：

排序之后考虑最小的数和最大的数，设为 $a_1, a_n $ 。

如果$a_1 * a_n \le w$，则 $a_n$ 与所有数都可以匹配，将它插入到当前插入顺序的头。

反之，则 $a_1$ 与所有数都不能匹配，将它插入到当前插入顺序的头。

然后递归到子问题即可。

## 2

对 $<0$ 的部分和 $\ge 0$ 的部分分别跑上述 dp 因为小于 $0$ 的段和 $\ge 0$ 的段一定可以相邻，将 dp 的结果合并即可。



## 3($a_i\ge 0$)

以上的插入顺序看起来并不能继续优化，考虑构造一个更优秀的插入顺序。

考虑把以上 插入顺序 reverse。

现在的性质是：

1. $\forall _{j>i}, a_i *a_j \le w$，我们称满足这类数的为 $A$类
2. $\forall _{j>i}, a_i *a_j > w$，我们称满足这类数的为 $B$类

考虑插入的时候插在两个位置中间，与这两个位置相邻。

现在插入的时候有一些限制：

1. $B$类 的旁边不可能再插入一个数。
2. 只能插入在两个 $A$类 之间。

考虑两个相邻的 $A$类 一定是可以匹配的，不会出现将一对不可以匹配的相邻数变成不相邻的情况。（这一结论保证了如此插入不会算漏）

仔细分析后还会发现：

每次插入 $B$类 之后会使得一个可以插入的位置变得没法插入，即空位$-1$

每次插入 $A$类 之后会使得一个可以插入的位置变成两个，即空位$+1$

于是可以在排序后 $O(n)$ 的时间得到答案。



## 4

考虑事先硬点有多少段，即最开始给了多少空位。

如果最开始的空位个数是 $x$，可以看出最后的方案数是关于 $x$ 的 $n$ 次多项式。

这个多项式可以 分治FFT 求出。

我们要求出若干个 $x$ 的答案，相当于求 $f(1), f(2), \dots$，这是一个多点求值。

注意到枚举的空位其实是最多多少段（可能有段最终仍然是空）。我们需要容斥。

这个容斥是一个卷积的形式，一次 FFT 即可。

综上我们即可在 $O(n\log^2n)$ 的时间里求解了。


## More

参考 @xgcxgc 的做法，最后的多点求值可以通过下降幂多项式优化，最终复杂度是分治下降幂多项式乘法的 $O(N\log^2 N)$ 。由于常数更小，应该可以做更大一点的数据范围。

---

## 作者：zhouyuhang (赞：0)

23 年的联考题，现在来朝花夕拾一下。

先来做 $a_i \ge 0$ 的部分分，实际上也就是 [ARC148E](https://www.luogu.com.cn/problem/AT_arc148_e)。我们按照以下顺序插入所有数：

- 设还没被插入的数最小为 $x$，最大为 $y$，若 $xy \le w$，插入 $x$；反之插入 $y$。

这样的插入顺序有什么好处呢？不难发现，若 $x$ 在 $y$ 之前被插入，且 $x > \sqrt w$，则一定有 $xy > w$；反之一定有 $xy \le w$。换言之，如果称 $\le \sqrt w$ 的数为小数，$> \sqrt w$ 的为大数，则每个数在插入时必须插进两个小数之间，或者两个端点的小数边上，并且这一条件是充要的。称这样的位置个数为空位数。简单分析不难发现，每按照要求插入一个小数，空位数一定会增加 $1$；否则插入一个大数，空位数一定会减少 $1$；初始的空位数为 $1$。于是将每次插入时的空位数全部乘起来，就得到了答案。

现在来处理 $a_i$ 有正有负的情况。实际上，假设我们能够对 $a_i \ge 0$ 求出将其分为 $k$ 段使得每段内部都满足要求的方案数 $f_k$，再同理对 $a_i < 0$ 求出 $g_k$，那么答案即为 $\sum _ {k} \left(f_k g_{k + 1} + g_k f_{k + 1} + 2 f_kg_k \right)$。

现在问题变为对每个 $k$ 求出 $f_k, g_k$。如果你选择先有序划分出 $k$ 个非空可重集，再对每个可重集内部应用上述做法，就会发现答案的形式并不容易表示出来。因此不失套路地，考虑容斥：如果记 $F_k$ 为将 $a_i \ge 0$ 有序划分成 $k$ 个**可以为空**的可重集，那么有 $f_k = \sum _ {i = 1} ^ k (-1) ^ {k - i} \binom k i F_i$。而求 $F_k$，只需将上述过程中的初始空位数从 $1$ 改为 $k$ 即可。

于是可以看到，我们需要对一个多项式 $f(x) = \prod _ {i = 1} ^ n (x + c_i)$ 求出其在 $f(1), f(2), \cdots, f(n)$ 处的取值，使用分治乘法和多点求值算法，复杂度为 $\mathcal O(n \log ^ 2 n)$。从 $F$ 得到 $f$ 的过程需要一次卷积，但并不是瓶颈。

---


# [PKUWC2018] 随机游走

## 题目描述

给定一棵 $n$ 个结点的树，你从点 $x$ 出发，每次等概率随机选择一条与所在点相邻的边走过去。

有 $Q$ 次询问，每次询问给定一个集合 $S$，求如果从 $x$ 出发一直随机游走，直到点集 $S$ 中所有点都至少经过一次的话，期望游走几步。

特别地，点 $x$（即起点）视为一开始就被经过了一次。

答案对 $998244353 $ 取模。


## 说明/提示

对于 $20\%$ 的数据，有 $1\leq n,Q\leq 5$。

另有 $10\%$ 的数据，满足给定的树是一条链。

另有 $10\%$ 的数据，满足对于所有询问有 $k=1$。

另有 $30\%$ 的数据，满足 $1\leq n\leq 10 ,Q=1$。

对于 $100\%$ 的数据，有 $1\leq n\leq 18$，$1\leq Q\leq 5000$，$1\leq k\leq n$。

## 样例 #1

### 输入

```
3 5 1
1 2
2 3
1 1
1 3
2 2 3
3 1 2 3
2 1 2```

### 输出

```
0
4
4
4
1```

# 题解

## 作者：Marser (赞：30)

### 题意
给定一棵 $n$ 个结点的树，你从点 $root$ 出发，每次等概率随机选择一条与所在点相邻的边走过去。

有 $q$ 次询问，每次询问给定一个集合 $S$，求如果从 $x$ 出发一直随机游走，直到点集 $S$ 中所有点都至少经过一次的话，期望游走几步。特别地，点 $root$ （即起点）视为一开始就被经过了一次。

### 题解

一般的随机游走问题，由于后效性，必须考虑列方程组，通过高斯消元求解。但是，这题是树上的随机游走问题，只能从父亲与儿子转移，可以考虑直接dp。  
由于本题要求点集 $S$ 中所有点都被经过的步数期望，即到达点集 $S$ 中最后一个点的期望步数。运用$\min$-$\max$容斥可以将其转化为到达点集 $S$ 中第一个点的期望步数。  
设 $f_{S,i}$ 表示从 $i$ 出发，经过 $S$ 中的至少一个点的期望步数，$deg_i$ 为点 $i$ 的度数，可以得到这样的递推式：  
$$ \begin{aligned} f_{S,i} & = \frac{1}{deg_i} (f_{S,fa_i} + 1 + \sum_{v \in son_i} (f_{S,v}+1)) \\ & = \frac{1}{deg_i} (f_{S,fa_i} + \sum_{v \in son_i} f_{S,v}) + 1 \end{aligned} $$  
若 $i \in S$ ，则 $f_{i,S} = 0$。

按照套路，将转移方程写成有关于父亲的函数，即$f_{S,i} = A_i \times f_{S,fa_i} + B_i$，分离儿子与父亲的贡献。
$$ \begin{aligned} f_{S,i} & = \frac{1}{deg_i} (f_{S,fa_i} + \sum_{v \in son_i} f_{S,v}) + 1 \\ & = \frac{1}{deg_i} (f_{S,fa_i} + \sum_{v \in son_i} (A_v \times f_{S,i}+B_v)) + 1 \\ & = \frac{1}{deg_i} (f_{S,fa_i} + (\sum_{v \in son_i} A_v) \times f_{S,i} + \sum_{v \in son_i} B_v) + 1 \\ & =\frac{1}{deg_i} (f_{S,fa_i} + sumA_v \times f_{S,i} + sumB_v) + 1\\ deg_i \times f_{S,i} & = f_{S,fa_i} + sumA_v \times f_{S,i} + sumB_v +deg_i \\ (deg_i - sumA_v) \times f_{S,i} & = f_{S,fa_i} + sumB_v + deg_i \\ f_{S,i} & = \frac{1}{deg_i - sumA_v} f_{S,fa_i} + \frac{sumB_v + deg_i}{deg_i - sumA_v} \\ A_i & = \frac{1}{deg_i - sumA_v} , B_i = \frac{sumB_v + deg_i}{deg_i - sumA_v}\end{aligned} $$

发现 $A_i,B_i$ 的方程与父亲无关，可以直接树形dp求解。由于 $root$ 不能从父亲转移，显然有$f_{S,root} = B_{root}$ 。  
所以点集 $S$ 的答案为 $\sum_{T \in S,T \not= \varnothing} (-1)^{|T|+1} f_{T,root}$。  
预处理所有$f_{S,root}$可以做到$\mathcal{O}(q2^n)$，由于本题数据太水，可以通过。

但是这样做很不优美，我们考虑一些更加优雅的做法。  
考虑集合或卷积的形式：  
$C_i = \sum_{j|k = i} A_j \times B_k$  
我们计$\widehat{C_i} = \sum_{j \in  i} C_j$，类似定义$\widehat{A_i},\widehat{B_i}$。  
$$ \begin{aligned} \widehat{C_i} & = \sum_{j|k \in i} A_j \times B_k \\ & = \sum_{j \in i , k \in i} A_j \times B_k \\& = (\sum_{j \in i} A_j) \times (\sum_{j \in i} B_j) \\& = \widehat{A_i} \times \widehat{B_i}\end{aligned} $$

所以，经过FWT集合或卷积变换后，新多项式是原多项式的子集和。  
可以运用单次FWT预处理所有子集和，复杂度 $\mathcal{O}(n2^n)$ 。
### 代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int MN=19;
const int mod=998244353;
int to[MN<<1],nxt[MN<<1],h[MN],cnt;
inline void ins(int s,int t){
	to[++cnt]=t;nxt[cnt]=h[s];h[s]=cnt;
	to[++cnt]=s;nxt[cnt]=h[t];h[t]=cnt;
}
inline ll qpow(ll a,ll b){
	reg ll res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod;b>>=1;
	}
	return res;
}
int deg[MN],A[MN],B[MN];
void dfs(int st,int fa,int S){
	reg int totA=0,totB=0,inv=0;
	if(S&(1<<st-1))return;
	for(reg int i=h[st];i;i=nxt[i])
		if(to[i]!=fa){
			dfs(to[i],st,S);
			totA=(totA+A[to[i]])%mod;
			totB=(totB+B[to[i]])%mod;
		}
	inv=qpow((deg[st]-totA+mod)%mod,mod-2);
	A[st]=inv;B[st]=1ll*inv*(totB+deg[st])%mod;
}
int n,q,root,U,F[1<<18|5],Ans;
int main(){
	scanf("%d%d%d",&n,&q,&root);
	for(reg int i=1,s,t;i<n;i++){
		scanf("%d%d",&s,&t),ins(s,t);
		deg[s]++;deg[t]++;
	}
	U=1<<n;
	for(reg int S=1;S<U;S++){
		for(reg int i=1;i<=n;i++)A[i]=B[i]=0;dfs(root,0,S);
		F[S]=(((__builtin_popcount(S)&1)?1:-1)*B[root]+mod)%mod;
	}
	for(reg int i=1;i<U;i<<=1)
		for(reg int len=i<<1,j=0;j<U;j+=len)
			for(reg int k=0;k<i;k++)
				F[i+j+k]=(F[i+j+k]+F[j+k])%mod;
	while(q--){
		static int k,S;scanf("%d",&k);S=0;
		for(reg int i=1,x;i<=k;i++)
			scanf("%d",&x),S|=(1<<x-1);
		printf("%d\n",(F[S]+mod)%mod);
	}
	return 0;
}
```

---

## 作者：TheLostWeak (赞：29)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5643.html)

**大致题意：** 从一个给定点出发，在一棵树上随机游走，对于相邻的每个点均有$\frac 1{deg}$的概率前往。多组询问，每次给出一个点集，求期望经过多少步能够访问过点集内所有点至少一次。

### $Min-Max$容斥

访问过每个点至少一次，显然不是什么好处理的东西。

我们考虑一个叫$Min-Max$容斥的东西。

关于$Min-Max$容斥，有这样一个公式：

$$E(max(S))=\sum_{T∈S}(-1)^{|T|+1}E(min(T))$$

套到这题，$E(max(S))$就是访问点集$S$所有点至少一次的期望步数，$E(min(T))$就是到达点集$T$一个点的期望步数。

经过这样的转化，似乎就可做了许多。

### 待定系数法

设$f_i$为从$i$出发，到达点集$T$一个点的期望步数。

对于一个不属于点集$T$的$i$，设其度数为$deg_i$，因为它对于相邻的每个点均有$\frac 1{deg_i}$的概率前往，显然有：

$$f_i=\frac1{deg_i}(f_{fa_i}+\sum f_j)+1$$

其中$j$满足$j$是$i$的子节点。

乍一看，$f_i$既会从子节点转移，又会从父节点转移，转移出现了环，似乎需要**高斯消元**。

但实际上，对于这道题，我们可以使用**待定系数法**。

设$f_i=k_if_{fa_i}+b_i$，根据上面的转移方程，我们知道：

$$f_i=\frac1{deg_i}(f_{fa_i}+\sum(k_jf_i+b_j))+1$$

两边同乘$deg_i$，便可得：

$$deg_i\cdot f_i=f_{fa_i}+(\sum k_j)f_i+\sum b_j+deg_i$$

移项，得到：

$$(deg_i-\sum k_j)\cdot f_i=f_{fa_i}+\sum b_j+deg_i$$

两边同除以$deg_i-\sum k_j$，可得：

$$f_i=\frac1{deg_i-\sum k_j}f_{fa_i}+\frac{deg_i+\sum b_j}{deg_i-\sum k_j}$$

即：

$$k_i=\frac 1{deg_i-\sum k_j},b_i=\frac{deg_i+\sum b_j}{deg_i-\sum k_j}$$

仔细观察，可以发现，这两个式子均与父节点无关，只和子节点有关系。

上述讨论都是对于不属于点集$T$中的$i$的，而对于点集$T$中的$i$，由于$f_i=0$，所以$k_i=b_i=0$。

所以，我们只要通过一遍$dfs$，就可以求出所有点的$k_i$和$b_i$了。

如果我们把题目中给定的出发点作为根节点，由于其不存在父节点，所以$f_{rt}=b_{rt}$。

而$f_{rt}$也正是我们所要求的到达点集$T$一个点的期望步数。

### 高维前缀和

现在我们已经知道了，对于一个点集$T$，如何求出到达点集$T$一个点的期望步数。

那么，对于给出的一个询问，我们就可以套用之前的公式：

$$E(max(S))=\sum_{T∈S}(-1)^{|T|+1}E(min(T))$$

但是，由于询问数量较多，如果对于每一次询问都去枚举子集计算答案，就会$TLE$。

怎么办呢？

注意到对于任意一个点集$T$，$(-1)^{|T|+1}E(min(T))$完全与$S$没有半点关系。

因此，我们可以先暴力枚举$T$，求出每一个$T$的答案，然后用**高维前缀和**来预处理$S$的答案。

关于高维前缀和，如果你不太了解，可以看看我的这一篇博客：[浅谈高维前缀和](https://www.cnblogs.com/chenxiaoran666/p/HDPreSum.html)。

这样一来，对于每次询问，我们就可以直接输出答案了。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 18
#define X 998244353
#define add(x,y) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y)
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
using namespace std;
int n,rt,ee,lnk[N+5];struct edge {int to,nxt;}e[2*N+5];
I int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}
namespace DP//树形DP预处理答案
{
	int p[N+5],k[N+5],b[N+5],s[1<<N],g[1<<N];
	I void dfs(CI x,CI lst)//DP
	{
		if(p[x]) return (void)(k[x]=b[x]=0);//如果在点集T中，直接返回
		RI i,d=0,sk=0,sb=0;for(i=lnk[x];i;i=e[i].nxt) ++d,//枚举子节点的同时统计度数
			e[i].to^lst&&(dfs(e[i].to,x),Inc(sk,k[e[i].to]),Inc(sb,b[e[i].to]));//枚举子节点，并统计k与b的和
		k[x]=Qpow((d-sk+X)%X,X-2),b[x]=1LL*(d+sb)*Qpow((d-sk+X)%X,X-2)%X;//计算当前节点k与b的值
	}
	I void Init()
	{
		RI i,j,t=1<<n;for(i=1;i^t;++i)//枚举点集T
			{for(j=1;j<=n;++j) p[j]=(i>>j-1)&1;dfs(rt,0),s[i]=b[rt];}//求出到达点集T一个点的期望步数
	}
	I void Calc()
	{
		RI i,j,t=1<<n;for(i=1;i^t;++i) !(g[i]=g[i>>1]^(i&1))&&(s[i]=X-s[i]);//乘上容斥系数
		for(j=1;j<=n;++j) for(i=1;i^t;++i) (i>>j-1)&1&&Inc(s[i],s[i-(1<<j-1)]);//高维前缀和
	}
}
int main()
{
	RI Qt,i,x,y,t;scanf("%d%d%d",&n,&Qt,&rt);
	for(i=1;i^n;++i) scanf("%d%d",&x,&y),add(x,y),add(y,x);DP::Init(),DP::Calc();//读入+预处理
	W(Qt--)//处理询问
	{
		for(scanf("%d",&x),t=0,i=1;i<=x;++i) scanf("%d",&y),t|=1<<y-1;//读入，状压
		printf("%d\n",DP::s[t]);//直接输出答案
	}return 0;
}
```



---

## 作者：zyc2003 (赞：19)

### [P5643 : 随机游走](https://www.luogu.com.cn/problem/P5643)

前置知识 : 

$1.$ 了解 $\rm min-max$ 容斥 . 可以参考该洛谷日报 : [Min-Max容斥小记](https://www.luogu.com.cn/blog/command-block/min-max-rong-chi-xiao-ji)

$2.$ 了解高斯消元

$3.$ 了解期望dp的一般套路

将会探讨 : 

$1.$ 期望意义下的 $\rm min-max$ 容斥

$2.$ 树上高斯消元

$3.$ 高维前缀和

题目要求的是 “走完给定集合 $\mathbf S$ 至少一次的期望步数” . 所以我们应当考虑 , 走完某个集合 $S$ 的期望步数 , 并进行转移 . 

欲求期望 , 首先需要有 **"随机变量"** . 对于某个集合 $S$ , 我们有很多**不同**的路径走完它 , 所以我们的 **"随机变量"** 设为一个对应于该路径 $path_{S}$  的集合 $S' \ : \ $ 储存到达 $S$ 中所有点的步数 . 显然对于一个确定的集合 $S$ 和确定的路径 $path_{S}$ , $S'$ 也是唯一确定的 .   那么我们发现 , $S'$ 中的**最大值**表示的是到达 $S$ 中**最后一个点** 的步数 , 也就是**走完** $S$ 的步数 . 而**最小值**表示的是**第一次**到达 $S$ 中的点的步数 . 

所以 , 首先我们有 : 

$$\max(S')=\sum_{T'\in S'}(-1)^{|T'|+1}\min(T')$$

而题目要求的是期望 . 本题中 , $\max , \min$ 是对于 $S'$ 的函数 , $S'$ 是随机变量 , 所以期望形态下的表达式为 : 

$$E[\max(S')]=\sum_{T'\in S'}(-1)^{|T'|+1}E[\min(T')]$$

那么 , $E[\max(S')]$ 的定义就是 , 走完集合 $S$ 的期望步数 ; $E[\min(S')]$ 的定义就是 , 第一次访问到集合 $S$ 的期望步数 . 自然的 , 我们考虑设 $f_{S,x}$ , 表示从 $x$ 出发 , 第一次访问到集合 $S$ 中点的期望步数 . 由于题目中起点是给定的 , 我们设为 $x_{s}$ . 如果我们能预处理出所有的 $f_{S,x}$ , 那么对于一个给定的集合 $\mathbf S$ , 答案就是 : 

$$\sum_{T\in \mathbf S} (-1)^{|T|+1}f_{T,x_s}$$

考虑枚举子集 , 在回答询问时的复杂度是 $O(q3^n)$ 的 , 貌似会完蛋 ? 不过先不考虑这里 .  

现在回来考虑如何求出 $f$ . 不妨就设题目给定的 $x_s$ 为根结点 . 对于任意一个结点 $x$ , 我们有 : 

$$f_{S,x}=\frac{1}{d_x+1}(\sum_{y\in son_x}f_{S,y})+\frac{1}{d_x+1}f_{S,fa_x}+1 \ \ \ (x\notin S)$$

$$f_{S,x}=0 \ \ \ (x \in S)$$

$d_x$ 表示 $x$ 的子结点个数 , $fa_x$ 表示 $x$ 的父亲 . 

这里似乎需要 $O(n^3)$ 的高斯消元 . 看一下预处理 $f$ 的时间复杂度 , 为 $O(n^32^n)$ , 不是很可行 . 那么 , 就需要搬出我们的**树上高斯消元**了 !

假设我们已经**高斯消元完毕** , 求出了对于给定 $S$ 的所有 $f_{S,x}$ . 现在我们可以观察任意一个结点 $x$ 和它的父亲 $fa_x$ 之间 $f_{S,x}$ 和 $f_{S,fa_x}$ 的关系 (先不考虑 $x \in S$ )  . 首先从叶子结点开始 , 它的值 $f_{S,leaf}$ 可以直接由它父亲的值表示 : 

$$f_{S,leaf}=f_{S,fa_{leaf}}+1$$

这是一个**一次函数**关系 . 那么 , 对于某些**子结点**都是**叶子结点**的点 $x$ 而言 , 它的 $f_{S,x}$ 表达式中包含 $f_{S,y} (y\in son_x)$ , 以及 $f_{S,fa_x}$ . 而对于 $f_{S,y}$ , 它们的值可以由 $f_{S,x}$ 表示 . 所以最终表达式的形式为 : 

$$f_{S,x}=k_x*f_{S,fa_x}+b_x$$

其中 $k_x,b_x$ 是依赖于 $x$ 的常数 . 

那么类似数学归纳法地向上递推 , 我们可以发现 , 所有的结点 $x(x\notin S)$ 都满足上面**一次函数**式子 , 也就是所有的 $f_{S,x}$ 可以由 $f_{S,fa_x}$ 递推得到 . 因此 , 我们要求出 $k_x,b_x : $ 

对于 : 

$$f_{S,x}=\frac{1}{d_x+1}(\sum_{y\in son_x}f_{S,y})+\frac{1}{d_x+1}f_{S,fa_x}+1$$

化为 : 

$$f_{S,x}=\frac{1}{d_x+1}(\sum_{y\in son_x}k_y*f_{S,x}+b_y)+\frac{1}{d_x+1}f_{S,fa_x}+1 $$


令 

$$K_x=\sum_{y\in son_x}k_y,B_x=\sum_{y\in son_x}b_y$$

可以化简得到 : 

$$f_{S,x}=\frac{1}{d_x+1-K_x}*f_{S,fa_x}+\frac{d_x+1+B_x}{d_x+1-K_x}$$

也就是 : 

$$k_x=\frac{1}{d_x+1-K_x} , b_x=\frac{d_x+1+B_x}{d_x+1-K_x} \ \ \ (x\notin S)$$

$$k_x=b_x=0  \ \ \ (x\in S)$$

最后从根节点 $x_s$ 开始递推即可 . 所以所谓的**树上高斯消元** , 是利用树的父子特殊性质 , 使得 $O(n^3)$ 的高斯消元变为 $O(n)$ 的**树上dp** . 

这样的预处理是 $O(n2^n)$ 的 , 可以接受 . 现在再考虑处理询问的 $O(q3^n)$ 如何优化 . 

再假如 , 如果我们能够预处理任意一个集合 $S$ 的 : 

$$\sum_{T\in  S} (-1)^{|T|+1}f_{T,x_s}$$

就好了 . 是否可行 ? 当然可行 ! 隆重介绍 : **高维前缀和**

首先从一维前缀和开始 . 我们令一开始的 $sum[i]$ 储存位置为 $i$ 的数 . 显然有 : 

$$sum[i]+=sum[i-1]$$

那么对于二维前缀和 , 是否能从一维前缀和递推 ? 

首先求出对于行的前缀和 : 

$$sum[i][j]+=sum[i][j-1]$$

此时的 $sum[i][j]$ 表示的是第 $i$ 行 $1\sim j$ 的和 . 然后我们再 : 

$$sum[i][j]+=sum[i-1][j]$$

现在的 $sum[i][j]$ 才表示的是矩形区域 : $1\sim i,1 \sim j$ 的和 . 

是不是有感觉了 ? 

那么推广到 $n$ 维前缀和 , 一开始 $sum[x_1,x_2,\dots,x_n]$ 表示的仅仅是 $(x_1,x_2,\dots , x_n)$ 处的值 , 可以看做**零维**前缀和 . 而后我们每次对一维进行处理 , 直到处理完 $n$ 维 , 此时的 $sum[x_1,x_2,\dots , x_n]$ 便是区域 $ [1\sim x_1,1\sim x_2,\dots , 1\sim x_n]$ 的和了 . 对于 $n$ 维前缀和而言 , 若是一维有 $m$ 个数 ,  复杂度是 $O(nm^n)$ 的 . 换到本题 , $m=2$ , 复杂度即为 : $O(n2^n)$

所以 , 本题最终时间复杂度 : $O(n2^n+n2^n+q)=O(n2^n)$ , 可以通过本题 .

等等 , 还要算求逆元的时间复杂度 . 所以真正的时间复杂度 : $O(n2^n\log n+n2^n+q)=O(n2^n\log n)$ , 也可以通过本题 . 

由于我们最终求的是 $f[T][x_s]$ , 其他的点的 $f$ 值是没有用的 , 所以我们只需要设 $f[T]$ 代表 $f[T][x_s]$ 即可 . 

当然 , 还有一些小细节需要处理 , 具体的在下面列出 , 或者在代码注释中 . 


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<algorithm>
#include<vector>
#include<queue>
#include<bitset>
#include<cmath>
using namespace std;

#define N 20
#define M 40
#define P 998244353
#define int long long
#define Int signed

int n,Q,Start;
int head[N],nxt[M],ver[M],tot;
int deg[N],K[N],B[N],k[N],b[N];
int f[1<<N];
int fac[1<<N];

int read() {
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
	return x*f;
}
void write(int x) {
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+48);
}
void writes(int x) {write(x),putchar(' ');}
void Writes(int x) {write(x),putchar('\n');}
void add(int x,int y) {ver[++tot]=y,nxt[tot]=head[x],head[x]=tot,deg[x]++;}

int quick(int x,int p) {
	int ans=1;
	for(;p;p>>=1,x=x*x%P)	
		if(p&1)	ans=ans*x%P;
	return ans;;
}
int inv(int x) {return quick(x,P-2);}
void dfs(int x,int fa,int S) {
	bool inside=(S>>x&1);	
	K[x]=0,B[x]=0,k[x]=0,b[x]=0;
	for(int i=head[x];i;i=nxt[i]) {
		int y=ver[i];
		if(y == fa)	continue;
		dfs(y,x,S);
		if(!inside)
			(K[x]+=k[y])%=P,(B[x]+=b[y])%=P;
	}
	if(!inside)
		k[x]=inv(((deg[x]-K[x])%P+P)%P)%P,b[x]=(deg[x]+B[x])%P*k[x]%P;
}

Int main() {
	n=read(),Q=read(),Start=read()-1;
   //Start 即是 x_s , 设为根节点
	//编号为 1~n 化为 0~n-1 
	for(int i=1,x,y;i<n;i++) 
		x=read()-1,y=read()-1,add(x,y),add(y,x);
		
	fac[0]=-1;
	//fac 表示容斥系数 , 即 (-1)^(|T|+1) 
	for(int i=1;i<1<<n;i++) {
		fac[i]=fac[i>>1]*((i&1) ? -1 : 1);
		//fac 的线性递推 
		dfs(Start,N-1,i);
		f[i]=b[Start]*fac[i];
		//这里可能使 f 为负数 , 但不要紧 , 不处理 
       
	}
	
	for(int i=0;i<n;i++)
		for(int j=1;j<1<<n;j++)
			if(j>>i&1)
				(f[j]+=f[j^(1<<i)])%=P; 
	//高维前缀和 
	
	for(int i=1;i<=Q;i++) {
		int k=read(),S=0;
		for(int j=1;j<=k;j++)
			S|=(1<<read()-1);
		Writes(((f[S]%P)+P)%P);
		//为了防止 f[S] 是负数 
	}
	
	
	return 0;

}




```












---

## 作者：hunction (赞：12)

不会 Min-max 容斥，然后想出来一个树上解方程 + 分层图 DP 的做法，看到题解区好像没有，于是来写一发。

首先我们设计一个平平无奇的 DP：

$f(u, S)$ 表示从 $u$ 出发再把 $S$ 集合里的点全部经过的期望步数。

那么 $f(u, S) = \frac{f(fa_u, S - \{fa_u\}) + 1}{deg_u} + \sum\limits_{v \in son_u} \frac{f(v, S - \{v\}) + 1}{deg_u}$。

（注：$S - \{v\}$ 中的减号是差集，即 $v$ 不在 $S$ 中就返回 $S$）。

其中 $deg_u$ 是 $u$ 的度数，边界是 $f(x, \varnothing) = 0$。

这个 DP 没法直接转移，因为 $S - \{v\}$ 不一定小于 $S$（$v$ 可能不在 $S$ 内）。

所以我们对 $S$ 进行分层，外层从小到大枚举 $S$，那么转移时如果 $S - \{v\} \subset S$ 就可以把 $f(v, S - \{v\})$ 视为常数，否则就在同层中解一下方程。

剩下的就是树上解方程的内容了，为了方便起见，令 $g(u) = f(u, S)$，$S$ 为当前枚举到的集合。

现在我希望把所有的 $g(u)$ 都表示成 $k_u g(fa_u) + b_u$。

对于叶节点 $u$ 来说，$g(u) = g(fa_u) + 1$。

对于非叶节点 $u$ 来说，儿子都可以表示为 $k_vg(u) + b_v$，所以 $g(u)$ 可以表示成 $t_u g(u) + k'_ug(fa_u) +b'_u$ 的形式，然后移项就可以表示成 $k_u g(fa_u) + b_u$ 了。

对于根来说，根没有父亲，所以 $g(rt) = t_{rt} g(rt) + b_{rt}$。于是我可以解出 $g(rt)$。又因为剩下的每个点都表示成了 $k_u g(fa_u) + b_u$，所以所有 $g(u)$ 都被解出来了。

代码挺好写的，就是常数有点大，但是并不需要怎么卡常。

```cpp
#include <bits/stdc++.h>
using lld = long long;
const int N = 21, NS = (1 << 18) + 5, P = 998244353;
int n, Q, rt, curS;
lld F[N][NS], fc[N], K[N], T[N], B[N], C[N];
std::vector<int> to[N];
lld Qpow(lld a, lld p = P - 2) {
	lld x = 1;
	for (; p; p >>= 1, a = a * a % P)
		if (p & 1) x = a * x % P;
	return x;
}

void DFS(int u, int f) {
	T[u] = 1;
	for (int v : to[u])
		if (v != f) {
			DFS(v, u);
			if (curS >> v & 1)
				(B[u] += fc[u] * (F[v][curS & ~(1 << v)] + 1) % P) %= P;
			else
				(B[u] += fc[u] * (B[v] + 1) % P) %= P, (T[u] -= fc[u] * K[v] % P) %= P;
		}
	if (~f) {
		if (curS >> f & 1)
			(B[u] += fc[u] * (F[f][curS & ~(1 << f)] + 1) % P) %= P;
		else (K[u] += fc[u]) %= P, (B[u] += fc[u]) %= P;
		lld c = Qpow(T[u]);
		(K[u] *= c) %= P, (B[u] *= c) %= P;
	} else
		F[u][curS] = B[u] * Qpow(T[u]) % P;
}

void GET(int u, int f) {
	for (int v : to[u])
		if (v != f)
			F[v][curS] = (K[v] * F[u][curS] % P + B[v]) % P, GET(v, u);
}

int main() {
	scanf("%d%d%d", &n, &Q, &rt), --rt;
	for (int i = 1, u, v; i < n; i++) {
		scanf("%d%d", &u, &v);
		++fc[--u], ++fc[--v];
		to[u].push_back(v);
		to[v].push_back(u);
	}
	for (int i = 0; i < n; i++) fc[i] = Qpow(fc[i]), F[i][0] = 0;
	for (int s = 1; s < (1 << n); s++) {
		curS = s;
		memset(K, 0, sizeof K);
		memset(B, 0, sizeof B);
		memset(T, 0, sizeof T);
		DFS(rt, -1);
        GET(rt, -1);
	}
	while (Q--) {
		int k, s = 0;
		scanf("%d", &k);
		for (int i = 1, x; i <= k; i++) {
			scanf("%d", &x);
			s |= 1 << --x;
		}
		printf("%lld\n", (F[rt][s & ~(1 << rt)] + P) % P);
	}
	return 0;
}

---

## 作者：木xx木大 (赞：3)

[P5643 [PKUWC2018]随机游走](https://www.luogu.com.cn/problem/P5643) 


~~WC第二课堂的题怎么都这么难了呀，我怎么这么菜连第二课堂都听不懂呀~~

前置知识：Min-Max 容斥

$$
E(\max (S))=\sum\limits_{T\subset S}(-1)^{|T|+1}E(\min(T))
$$

在本题中，$E(\max(S))$ 即到达点集中最晚一个点的期望时间，也就是答案；$E(\min(T))$ 即到达点集中最早一个点的期望时间。而 $E(\min(T))$ 是比较好做的。

设 $f_i$ 表示从 $i$ 出发到点集中某个点的期望步数，则对于点集中的点，$f_i=0$；对于点集外的点，$f_i=\frac{1}{deg_i}(f_{fa_i}+\sum\limits_{j\in son(i)}f_j)+1$。如果暴力高斯消元，复杂度为 $O(n^32^n)$ 。

考虑使用 **待定系数法** 优化。对于点集外的点，设 $f_i=k_if_{fa_i}+b_i$；对于点集内的点，显然 $k_i=b_i=0$

$$
f_i=\frac{1}{deg_i}(f_{fa_i}+\sum\limits_{j\in son(i)}(k_jf_i+b_j)+1\\deg_if_i=f_{fa_i}+\sum\limits_{j\in son(i)}(k_jf_i+b_j)+deg_i\\deg_if_i=f_{fa_i}+(\sum\limits_{j\in son(i)}k_j)f_i+\sum\limits_{j\in son(i)}b_j+deg_i\\(deg_i-\sum\limits_{j\in son(i)}k_j)f_i=f_{fa_i}+\sum\limits_{j\in son(i)}b_j+deg_i\\f_i=\frac{1}{deg_i-\sum\limits_{j\in son(i)}k_j}f_{fa_i}+\frac{\sum\limits_{j\in son(i)}b_j+deg_i}{deg_i-\sum\limits_{j\in son(i)}k_j}\\k_i=\frac{1}{deg_i-\sum\limits_{j\in son(i)}k_j},b_i=\frac{\sum\limits_{j\in son(i)}b_j+deg_i}{deg_i-\sum\limits_{j\in son(i)}k_j}
$$

如果把题目给定的出发点看作根，则 $f_{rt}=b_{rt}$。$k_i,b_i$ 可以按上面的式子 dp 得到

如果每次询问都暴力算，复杂度是 $O(q2^n)$ 的，过不去，所以我们还需要用高维前缀和需处理。总复杂度 $O(n2^n+q)$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m;
	const int N=25,mo=998244353;
	int cnt[1<<N],k[N],b[N],rt,f[1<<N],du[N];
	vector<int> g[N];
	int qpow(int x,int y)
	{
		int s=1;
		while(y)
		{
			if(y&1)s=1ll*s*x%mo;
			x=1ll*x*x%mo;
			y>>=1;
		}
		return s;
	}
	void dfs(int u,int f,int S)
	{
		k[u]=b[u]=0;
		int sumk=0,sumb=0;
		for(auto v:g[u])
			if(v!=f)dfs(v,u,S),sumk=(sumk+k[v])%mo,sumb=(sumb+b[v])%mo;
		if(!((S>>u)&1))k[u]=qpow((du[u]-sumk+mo)%mo,mo-2),b[u]=1ll*(sumb+du[u])*k[u]%mo;
	}
	void work()
	{
		scanf("%d%d%d",&n,&m,&rt),rt--;
		for(int i=1,u,v;i<n;i++)
			scanf("%d%d",&u,&v),u--,v--,g[u].push_back(v),g[v].push_back(u),du[u]++,du[v]++;
		cnt[0]=-1;
		for(int i=1;i<(1<<n);i++)
		{
			cnt[i]=cnt[i>>1]*(i&1?-1:1);
			dfs(rt,n,i);
			f[i]=(b[rt]*cnt[i]+mo)%mo;
		}
		for(int i=0;i<n;i++)
			for(int j=1;j<(1<<n);j++)
				if((j>>i)&1)f[j]=(f[j]+f[j^(1<<i)])%mo;
		while(m--)
		{
			int x,S=0,u;
			scanf("%d",&x);
			while(x--)scanf("%d",&u),S|=(1<<(u-1));
			printf("%d\n",f[S]);
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：FZzzz (赞：2)

运用 min-max 容斥，快进到：给定一个起点和若干个终点，从起点开始随机游走，求第一次走到某个终点的期望时间。

现有题解提供了一个主要基于推式子的做法，下面给出一个直接设状态进行 dp 的做法，尽管这两种做法很可能是等价的。

以起点为根，记 $d_u$ 为 $u$ 的度数，$C_u$ 为 $u$ 的儿子集合。

考虑从一个非根节点开始进行游走后，它要么先到达某个终点，要么先到达（或者说返回）它的父亲。记 $f_{u,0}$ 为先到达终点的概率；$f_{u,1}$ 为对于所有先到达终点的情况，这种情况出现的概率乘以这种情况第一次到达终点时的步数之和；$g_{u,0}$ 为先到达父亲的概率；$g_{u,1}$ 的定义以此类推。

对于根节点 $r$ 也类似定义 $f_{r,1}$。注意根节点不存在父亲，$f_{r,1}$ 覆盖了所有情况，它就是我们所求的期望。

考虑若从 $u$ 出发后先到达某个终点，它一定先走向某个子节点 $v$，接下来要么不再返回 $u$ 就走到了某个终点，要么没有到达终点就返回了 $u$，然后重复上面的过程。若从 $u$ 出发后先到达 $u$ 的父亲，那么要么它一步走到了父亲，要么第一步先走向某个子节点 $v$，接下来没有到达终点就返回了 $u$ 重复上面的过程。

据此，我们可以写出下面的式子：
$$f_{u,0}=\frac1{d_u}\sum_{v\in C_u}f_{v,0}+g_{v,0}f_{u,0}$$
$$f_{u,1}=\frac1{d_u}\sum_{v\in C_u}f_{v,0}+g_{v,0}f_{u,0}+f_{v,1}+g_{v,1}f_{u,0}+g_{v,0}f_{u,1}$$
$$g_{u,0}=1-f_{u,0}$$
$$g_{u,1}=\frac1{d_u}+\frac1{d_u}\sum_{v\in C_u}g_{v,0}g_{u,0}+g_{v,1}g_{u,0}+g_{v,0}g_{u,1}$$
这里我不详细解释每个式子的由来。总的原则是，对于每一项，它应该涵盖了整个过程中每一步的概率。有不理解的读者可以尝试将自己的式子或 [这个贴中的式子](https://www.luogu.com.cn/discuss/412319) 与上面的式子进行对比。

把第一个式子看作关于 $f_{u,0}$ 的方程，解出来得到：
$$f_{u,0}=\frac{\sum\limits_{v\in C_u}f_{v,0}}{d_u-\sum\limits_{v\in C_u}g_{v,0}}$$
对第二和第四个式子也做一样的事情，这样我们得到了可以直接 dp 的式子。单次 dp 时间复杂度 $O(n\log p)$，原题的总复杂度为 $O(n2^n\log p+qn)$，其中 $p$ 为模数。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=18+5,maxs=(1<<18)+5;
int n,q,x;
vector<int> t[maxn];
const ll mod=998244353;
ll ksm(ll a,ll b){
	ll ans=1;
	while(b){
		if(b%2==1) ans=ans*a%mod;
		a=a*a%mod;
		b/=2;
	}
	return ans;
}
ll f[maxn][2],g[maxn][2];
void dfs(int u,int fa,int s){
	if(s>>u&1){
		f[u][0]=1;
		f[u][1]=g[u][0]=g[u][1]=0;
		return;
	}
	int d=t[u].size();
	f[u][0]=0;
	ll b=d;
	for(int v:t[u]) if(v!=fa){
		dfs(v,u,s);
		f[u][0]=(f[u][0]+f[v][0])%mod;
		b=(b-g[v][0]+mod)%mod;
	}
	b=ksm(b,mod-2);
	f[u][0]=f[u][0]*b%mod;
	g[u][0]=(1-f[u][0]+mod)%mod;
	f[u][1]=0;
	g[u][1]=1;
	for(int v:t[u]) if(v!=fa){
		f[u][1]=(f[u][1]+f[v][0]+g[v][0]*f[u][0]%mod+f[v][1]+g[v][1]*f[u][0]%mod)%mod;
		g[u][1]=(g[u][1]+g[v][0]*g[u][0]%mod+g[v][1]*g[u][0]%mod)%mod;
	}
	f[u][1]=f[u][1]*b%mod;
	g[u][1]=g[u][1]*b%mod;
}
int sz[maxs];
ll ans[maxs];
void FWT(ll* f,int n,bool flag){
	for(int i=1;i<n;i*=2) for(int j=0;j<n;j+=i*2)
		for(int k=j;k<j+i;k++)
			f[k+i]=(f[k+i]+f[k]*(flag?1:mod-1)%mod)%mod;
}
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	q=read();
	x=read()-1;
	for(int i=1;i<n;i++){
		int u,v;
		u=read()-1;
		v=read()-1;
		t[u].push_back(v);
		t[v].push_back(u);
	}
	for(int i=1;i<(1<<n);i++) sz[i]=sz[i>>1]+(i&1);
	for(int i=1;i<(1<<n);i++){
		dfs(x,-1,i);
		ans[i]=f[x][1]*(sz[i]%2==0?mod-1:1)%mod;
	}
	FWT(ans,1<<n,1);
	while(q--){
		int k=read(),s=0;
		while(k--) s|=1<<(read()-1);
		printf("%lld\n",ans[s]);
	}
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：Resurgammm (赞：1)

> 给定一个起点 $x$，和一棵 $n$ 个节点的树，多组询问，每个询问给定一个点集 $S$，求一个人从 $x$ 随机游走，到达过 $S$ 中的全部点期望时间

考虑 $\text{Min-Max}$ 容斥

不难想到把这道题的问题当做 $\text{Max}$，那么设 $\text{Min}$ 为到达点集 $S$ 中第一个点的期望步数

设 $f_{S,i}$ 表示从 $i$ 出发到达 $S$ 中的一个点的期望步数，有：

$$f_{S,i}=\begin{cases}0 & i\in S \\ \frac{1}{deg_i}(f_{S,fa_i}+\sum\limits_{v\in son_i}f_{S,v})+1 & i\notin S\end{cases}$$

一般是高斯消元来搞，但是这样做时间复杂度会爆炸，所以考虑线性递推

设 $f_{S,i}=k_i\times f_{S,fa_i}+b_i$，有：

$$\begin{aligned}f_{S,i}&=\frac{1}{deg_i}(f_{S,fa_i}+\sum\limits_{v\in son_i}(k_v\times f_{S,i}+b_v))+1 \\ deg_i\times f_{S,i}&=f_{S,fa_i}+sumk\times f_{S,i}+sumb+deg_i \\ f_{S,i}&=\frac{1}{deg_i-sumk}\times f_{S,fa_i}+\frac{sumb+deg_i}{deg_i-sumk}\end{aligned}$$

$$\therefore\begin{cases}k_i=\frac{1}{deg_i-sumk} \\ b_i=\frac{sumb+deg_i}{deg_i-sumk}\end{cases}$$

设 $g_T=(-1)^{|T|-1}f_{T,root}$，那么有：

$$ans=\sum\limits_{T\subseteq S,T\ne\varnothing}g_T$$

不难发现这是个或卷积，直接 $\text{FWT}$ 卷

时间复杂度 $O(n2^n)$

$\texttt{Code:}$

```cpp
#include <bits/stdc++.h>
#define ll long long 
#define ull unsigned long long
#define fir first
#define sec second
#define int long long 
using namespace std;
namespace IO{
	#define File(x,y) freopen(#x,"r",stdin),freopen(#y,"w",stdout);
	#define fill(a,b,c,d) memset(a,b,sizeof(c)*(d+1))
	#define copy(a,b,c,d) memcpy(a,b,sizeof(c)*(d+1))
	#define fillall(x,y) memset(x,y,sizeof(x))
	#define copyall(x,y) memcpy(x,y,sizeof(x))
	inline int read(){
		int w=0,f=1; char ch=getchar();
		while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
		while(ch>='0'&&ch<='9'){w=(w<<1)+(w<<3)+(ch^48); ch=getchar();}
		return w*f;
	}
}
using namespace IO;
namespace CL{

	const int maxn=20,mod=998244353;

	int n,q,root;
	int deg[maxn],k[maxn],b[maxn],f[1<<18];
	namespace Graph{
		int head[maxn],id;
		struct e{int v,next;}edge[maxn<<1];
		inline void add(int u,int v){
			edge[++id]=(e){v,head[u]};
			head[u]=id;
		}
	}using namespace Graph;
	inline int qpow(int x,int y){
		int res=1;
		for(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;
		return res;
	}
	void dfs(int u,int fa,int S){
		if(S>>u-1&1) return;
		int sumk=0,sumb=0;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].v;
			if(v==fa) continue;
			dfs(v,u,S);
			sumk=(sumk+k[v])%mod,sumb=(sumb+b[v])%mod;
		}
		int frac=qpow((deg[u]-sumk+mod)%mod,mod-2);
		k[u]=frac,b[u]=(deg[u]+sumb)%mod*frac%mod;
	}
	inline void FWT(int *a){
		for(int mid=1;mid<1<<n;mid<<=1)
			for(int j=0;j<1<<n;j+=(mid<<1))
				for(int k=0;k<mid;k++)
					a[j+k+mid]=(a[j+k+mid]+a[j+k])%mod;
	}

	inline int main(){
		n=read(),q=read(),root=read(); const int U=(1<<n)-1;
		for(int i=1;i<n;i++){
			int x=read(),y=read();
			add(x,y),add(y,x);
			deg[x]++,deg[y]++;
		}
		for(int i=1;i<=U;i++){
			fill(k,0,int,n),fill(b,0,int,n);
			dfs(root,0,i);
			f[i]=((__builtin_popcount(i)&1?1:-1)*b[root]+mod)%mod;
		}
		FWT(f);
		while(q--){
			int k=read(),S=0;
			for(int i=1;i<=k;i++) S|=(1<<read()-1);
			printf("%lld\n",f[S]);
		}
		return 0;
	}
}
signed main(){return CL::main();}
```

---

## 作者：tzc_wk (赞：1)

[题面传送门](https://www.luogu.com.cn/problem/P5643)

一道挺综合的 hot tea，放到 PKUWC 的 D2T2 还挺喜闻乐见的（

首先我们考虑怎样对一个固定的集合 $S$ 计算答案，注意到我们要求的是一个形如 $E(\max(S))$ 的式子，套用 Min-Max 反演可将其转化为 $\sum\limits_{T\subseteq S}(-1)^{|T|-1}E(\min(T))$，我们记 $g_T=(-1)^{|T|-1}E(\min(T))$，那么 $ans_S=\sum\limits_{T\subseteq S}g^T$，这东西显然是一个高维前缀和的形式，可以通过一遍 FWTor 求出（当然你叫它 SOS dp 我也没意见（

接下来考虑怎样计算 $g_T$，也就等价于对所有集合 $T$ 求出从 $x$ 开始期望随机游走多少次就会走到 $T$ 中的点。一个很显然的想法是写出一个 $dp$ 式子然后暴力高斯消元，设 $dp_{S,i}$ 表示从 $i$ 开始走到 $S$ 中的点的期望步数，显然若 $i\in S,dp_{S,i}=0$，否则 $dp_{S,i}=1+\dfrac{1}{deg_i}(\sum\limits_{(i,u)\in E}dp_{S,u})$，时间复杂度 $2^nn^3\approx 10^9$，一脸过不去。考虑优化，注意到这题的图是**一棵树**，也就是说我们可以利用树的特殊性质进行 **树形 $dp$** instead of 高斯消元，如果没见过这个套路的可以去康康[这个题](https://www.luogu.com.cn/problem/P4284)或者[这个题](https://www.luogu.com.cn/problem/P2081)。具体来说我们还是设 $dp_{S,i}$ 表示从 $i$ 开始走到 $S$ 中的点的期望步数，然后以 $x$ 为根开始一遍 DFS，记 $f$ 为 $S$ 的父亲，那么 $dp_{S,u}=1+\dfrac{1}{deg_u}(dp_{S,f}+\sum\limits_{v\in son_u}dp_{S,v})$，不难发现 $dp_{S,u}$ 可以表示为 $dp_{S,f}$ 的若干倍加上一个与 $dp_{S,v}$ 有关的式子，其中 $v$ 为 $u$ 的子节点，我们不妨设 $dp_{S,u}=K_udp_{S,f}+B_u$，那么有 $dp_{S,u}=1+\dfrac{1}{deg_u}(dp_{S,f}+\sum\limits_{v\in son_u}(K_vdp_{S,u}+B_v))$，等式左右两边同乘 $deg_u$ 可得 $deg_udp_{S,u}=deg_u+dp_{S,f}+\sum\limits_{v\in son_u}(K_vdp_{S,u}+B_v)$，再把里面 $\sum$ 拆开，里面与 $dp_{S,u}$ 有关的项弄到左边可得 $(deg_u-\sum\limits_{v\in son_u}K_v)dp_{S,u}=dp_{S,f}+deg_u+\sum\limits_{v\in son_u}B_v$，再将左边除过去可得 $dp_{S,u}=\dfrac{1}{deg_u-\sum\limits_{v\in son_u}K_v}dp_{S,f}+\dfrac{deg_u+\sum\limits_{v\in son_u}B_v}{deg_u-\sum\limits_{v\in son_u}K_v}$，故 $K_u=\dfrac{1}{deg_u-\sum\limits_{v\in son_u}K_v}$，$B_u=\dfrac{deg_u+\sum\limits_{v\in son_u}B_v}{deg_u-\sum\limits_{v\in son_u}K_v}$，DFS 求解即可，时间复杂度 $2^nn$。据说这玩意儿有个名字叫**树上高斯消元**，orzorz。

```cpp
const int MAXN=18;
const int MAXP=1<<18;
const int MOD=998244353;
int n,qu,r,hd[MAXN+2],to[MAXN*2+5],nxt[MAXN*2+5],ec=0;
void adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}
int qpow(int x,int e=MOD-2){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int a[MAXN+2],b[MAXN+2],deg[MAXN+2];
void dfs(int x,int f,int S){
	if(S>>(x-1)&1) return;int suma=0,sumb=0;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f) continue;
		dfs(y,x,S);suma=(suma+a[y])%MOD;sumb=(sumb+b[y])%MOD;
	} int inv=qpow((deg[x]-suma+MOD)%MOD);
	a[x]=inv;b[x]=1ll*inv*(sumb+deg[x])%MOD;
}
int ret[MAXP+5];
void FWTor(int *a,int len){
	for(int i=2;i<=len;i<<=1)
		for(int j=0;j<len;j+=i)
			for(int k=0;k<(i>>1);k++)
				a[(i>>1)+j+k]=(a[(i>>1)+j+k]+a[j+k])%MOD;
}
int main(){
	scanf("%d%d%d",&n,&qu,&r);
	for(int i=1,u,v;i<n;i++){
		scanf("%d%d",&u,&v);deg[u]++;deg[v]++;
		adde(u,v);adde(v,u);
	}
	for(int i=0;i<(1<<n);i++){
		memset(a,0,sizeof(a));memset(b,0,sizeof(b));
		dfs(r,0,i);int cnt=__builtin_popcount(i);
		ret[i]=((cnt&1)?b[r]:(MOD-b[r])%MOD);
	} FWTor(ret,1<<n);
	while(qu--){
		int k,msk=0;scanf("%d",&k);
		for(int i=1,x;i<=k;i++) scanf("%d",&x),msk|=(1<<x-1);
		printf("%d\n",ret[msk]);
	}
	return 0;
}
```



---

## 作者：徐致远 (赞：1)



[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/12/19/%E3%80%8CPKUWC2018%E3%80%8D%E9%A2%98%E8%A7%A3-Solution/)

### 题解

题目中要求经过$S$中所有点的期望步数，即$E(max(S))$，并不好搞，考虑到数据范围非常小，可以使用MinMax容斥，即$E(\max(S))=\sum_{T\subseteq S{}}(-1)^{|T|+1}E(\min(T))$，所以问题就转化为了求从起点出发，经过$T$中任意一个节点的期望步数。

首先可以暴力枚举集合$T$，然后考虑一个树形DP：

$F_i$表示从节点$i$出发，经过集合$T$中任意一个节点的期望步数，比较显然的转移是：

1. 若$i\notin T$:

$$
F[i]=1+\frac{1}{deg[i]}\sum_{(i,j)\in E}{F[j]}
$$

2. $i\in T$

$$
F[i]=0
$$

考虑第一种情况，这个式子不是很好看，考虑分离儿子与父亲的情况分别考虑。

设$F[i]=K[i]\cdot F[fa[i]]+B[i]$，那么就有：
$$
F[i]=1+\frac{1}{deg[i]}(F[fa[i]]+\sum_{j\in son_i}{F[j]})
$$
$$
F[i]=1+\frac{1}{deg[i]}(F[fa[i]]+\sum_{j\in son_i}{K[j]\cdot F[i]+B[j]})
$$
$$
F[i]=1+\frac{1}{deg[i]}(F[fa[i]]+F[i]\cdot \sum_{j\in son_i}{K[j]}+\sum_{j\in son_i}{B[j]})
$$
$$
F[i]=1+\frac{1}{deg[i]}(F[fa[i]]+F[i]\cdot Sum{K[i]}+SumB[i])
$$
$$
deg[i]\cdot F[i]=deg[i]+F[fa[i]]+F[i]\cdot Sum{K[i]}+SumB[i]
$$
$$
(deg[i]-SumK[i])\cdot F[i]=F[fa[i]]+deg[i]+SumB[i]
$$
$$
F[i]=\frac{1}{deg[i]-SumK[i]}F[fa[i]]+\frac{deg[i]+SumB[i]}{deg[i]-SumK[i]}
$$
其中$SumK[i]$表示$\sum_{j\in son[i]}{K[j]}$，$SumB[i]$同理。

所以就有：
$$
K[i]=\frac{1}{deg[i]-SumK[i]}
$$
$$
B[i]=\frac{deg[i]+SumB[i]}{deg[i]-SumK[i]}
$$
这两个数的取值与$i$的父节点无关，只与子节点有关。

对于第二中情况，显然有$K[i]=B[i]=F[i]=0$。

所以就可以通过一趟$DFS$来求出每个节点的$K[i]$与$B[i]$。

对根节点$x$，因为没有父亲，所以就有$F[x]=B[x]$。

所以我们就可以求出所有集合$T$的期望，以及他们对答案的贡献。

但是由于询问数量很多，不能每次都暴力枚举子集。

不难发现，对于一个集合$T$，他是否会对$S$产生贡献以及贡献的大小只取决$T$是不是$S$的子集以及$T$本身。

所以我们可以先预处理出所有$2^n$个子集的贡献，然后就可以通过高维前缀和来快速统计每一个询问的答案了。

时间复杂度$O(n\cdot 2^n)$。

### 代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long LL;
const int maxn=20,TT=998244353;
int n,Q,x,tot,lnk[maxn],son[maxn*2],nxt[maxn*2],deg[maxn],K[maxn],B[maxn],SK[maxn],SB[maxn],G[(1<<18)+5],cnt[(1<<18)+5];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline int QP(int a,int b)
{
	int ret=1,w=a;
	while(b)
	{
		if(b&1) ret=(LL)ret*w%TT;
		w=(LL)w*w%TT;b>>=1;
	}
	return ret;
}
inline void add_e(int x,int y){tot++;deg[y]++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;}
void DFS(int now,int fa,int S)
{
	for(int i=lnk[now];i;i=nxt[i])
	{
		if(son[i]!=fa)
		{
			DFS(son[i],now,S);
			SK[now]=(SK[now]+K[son[i]])%TT;
			SB[now]=(SB[now]+B[son[i]])%TT;
		}
	}
	if((1<<(now-1))&S) K[now]=B[now]=0;
	else
	{
		K[now]=QP((deg[now]-SK[now]+TT)%TT,TT-2);
		B[now]=((LL)SB[now]+deg[now])*K[now]%TT;
	}
}
int main()
{
	n=read();Q=read();x=read();
	for(int i=1;i<n;i++)
	{
		int a=read(),b=read();
		add_e(a,b);add_e(b,a);
	}
	for(int i=0;i<(1<<n);i++)
	{
		memset(K,0,sizeof(K));memset(SK,0,sizeof(SK));
		memset(B,0,sizeof(B));memset(SB,0,sizeof(SB));
		DFS(x,0,i);cnt[i]=cnt[i>>1]+(i&1);
		G[i]=(((cnt[i]&1)?1:-1)*B[x]+TT)%TT;
	}
	for(int i=0;i<n;i++)
		for(int j=0;j<(1<<n);j++)
			if(j&(1<<i))
				G[j]=(G[j]+G[j-(1<<i)])%TT;
	while(Q--)
	{
		int k=read(),S=0;
		while(k--) S+=1<<(read()-1);
		printf("%d\n",G[S]);
	}
	return 0;
}
```

## 

---

## 作者：ZillionX (赞：0)

# Description

给定一棵 $n$ 个结点的树，从点 $x$ 出发，每次等概率随机游走到相邻点。有 $Q$ 次询问，每次给定集合 $S$，问经过整个 $S$ 的期望步数。答案对 $998244353$ 取模。

$n \le 18, Q \le 5 \times 10^3$，时限 1s。

# Solution

当年去本校高中集训时教练口中的牛逼期望题（貌似是上古神仙学长 KsCla 演讲时所提到的？）。现在回想起，不禁感慨良深，决定来一写这道经典题。

------------

可以发现我们很难直接表示出完整经过 $S$ 的期望步数，遇到这种情形，不妨使用期望意义下的 $\min - \max$ 容斥，即

$$E(\max(S))=\sum_{T \subseteq S} (-1)^{|T|+1} E(\min(T))$$

这里的 $E(\max(S))$ 也就是到达点集中最后一个点的期望步数，$E(\min(T))$ 同理则是第一次，是易求出的。

设 $f(x)$ 为从点 $x$ 出发到达点集中某个点的期望步数，$d_x$ 为点 $x$ 的度数。很容易有

$$f(x)=\frac{1}{d_x}\Bigg( f({\rm fa}_x) + \sum_{v \in {\rm son}_x} f(v)\Bigg) +1$$

直接高斯消元可以做到 $\mathcal O(n^3 2^n)$，显然过不去。

考虑[这道题](https://www.luogu.com.cn/problem/P2081)的思路，对于没有后效性的树上问题显然不用消元，那么就使用待定系数法优化树形 DP。设 $f(x)=k_x f({\rm fa}_x) + b_x$，很容易得到

$$\begin{cases} k_x=\dfrac{1}{d_x -\sum\limits_{v \in {\rm son}_x} k_v }\\ b_x = \Bigg(d_x+\sum\limits_{v \in {\rm son}_x} b_v\Bigg) k_x\end{cases}$$

推导过程都是推式子的力气活，留作读者练习。

直接根据 $\min - \max$ 容斥的式子枚举子集是 $\mathcal O(q 3^n)$ 的，显然不可行。一贯套路是搭配子集或卷积的 FWT 求解（可见[此题](https://www.luogu.com.cn/problem/P3175)），可以做到 $\mathcal O(n2^n)$ 预处理，$\mathcal O(1)$ 回答。

# Code

```cpp
typedef long long LL;

const int N=25,S=1<<N;
const LL mod=998244353;

int n,q,rt,Cnt[S],d[N];
LL f[S],k[N],b[N];
vector<int> g[N];

LL Qpow(LL x,LL y) {
	LL Mul=1;
	while (y) {
		if (y&1) Mul=Mul*x%mod;
		x=x*x%mod,y>>=1;
	}
	return Mul;
}

void Dfs(int x,int fa,int S) {
	k[x]=b[x]=0;
	if ((S>>x)&1) return;
	LL sk=0,sb=0;
	for (auto v:g[x]) if (v!=fa)
		Dfs(v,x,S),sk=(sk+k[v])%mod,sb=(sb+b[v])%mod;
	k[x]=Qpow(((d[x]-sk)%mod+mod)%mod,mod-2),
	b[x]=k[x]*((sb+d[x])%mod)%mod;
}

void FWT_Or(LL *f) {
	for (int i=2,j=1;i<=1<<n;i<<=1,j<<=1)
		for (int k=0;k<1<<n;k+=i)
			for (int l=0;l<j;l++)
				f[j+k+l]=(f[j+k+l]+f[k+l])%mod;
}

int main() {
	scanf("%d%d%d",&n,&q,&rt),rt--;
	for (int i=1;i<n;i++) {
		int u,v;
		scanf("%d%d",&u,&v),u--,v--;
		g[u].emplace_back(v),g[v].emplace_back(u);
		d[u]++,d[v]++;
	}
	
	Cnt[0]=-1;
	for (int i=1;i<1<<n;i++) {
		if (i&1) Cnt[i]=-Cnt[i>>1];
		else Cnt[i]=Cnt[i>>1];
		Dfs(rt,n,i),f[i]=(b[rt]*Cnt[i]%mod+mod)%mod;
	}
	FWT_Or(f);
	
	while (q--) {
		int k,x,S=0;
		scanf("%d",&k);
		while (k--) scanf("%d",&x),S|=(1<<(x-1));
		printf("%lld\n",f[S]);
	}
	return 0;
}
```


---


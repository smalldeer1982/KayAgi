# [PKUWC2018] 猎人杀

## 题目描述

猎人杀是一款风靡一时的游戏“狼人杀”的民间版本，他的规则是这样的：

一开始有 $n$ 个猎人，第 $i$ 个猎人有仇恨度 $w_i$ ，每个猎人只有一个固定的技能：死亡后必须开一枪，且被射中的人也会死亡。

然而向谁开枪也是有讲究的，假设当前还活着的猎人有 $[i_1\ldots i_m]$，那么有 $\frac{w_{i_k}}{\sum_{j = 1}^{m} w_{i_j}}$ 的概率是向猎人 $i_k$ 开枪。

一开始第一枪由你打响，目标的选择方法和猎人一样（即有 $\frac{w_i}{\sum_{j=1}^{n}w_j}$ 的概率射中第 $i$ 个猎人）。由于开枪导致的连锁反应，所有猎人最终都会死亡，现在 $1$ 号猎人想知道它是最后一个死的的概率。

答案对 $998244353$ 取模。


## 说明/提示

#### 样例解释
答案是 $\frac{2}{4}\times \frac{1}{2}+\frac{1}{4}\times \frac{2}{3}=\frac{10}{24}$。

对于 $10\%$ 的数据，有 $1\leq n\leq 10$

对于 $30\%$ 的数据，有 $1\leq n\leq 20$

对于 $50\%$ 的数据，有 $1\leq \sum\limits_{i=1}^{n}w_i\leq 5000$

另有 $10\%$ 的数据，满足 $1\leq w_i\leq 2$，且 $w_1=1$

另有 $10\%$ 的数据，满足 $1\leq w_i\leq 2$，且 $w_1=2$

对于 $100\%$ 的数据，有 $w_i>0$，且 $1\leq \sum\limits_{i=1}^{n}w_i \leq 100000$

## 样例 #1

### 输入

```
3
1 1 2```

### 输出

```
915057324```

# 题解

## 作者：TheLostWeak (赞：25)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5644.html)

**大致题意：** 有$n$个人相互开枪，每个人有一个仇恨度$a_i$，每个人死后会开枪再打死另一个还活着的人，且第一枪由你打响。设当前剩余人仇恨度总和为$k$，则每个人被打中的概率为$\frac {a_i}k$。求第$1$个人最后被打死的概率。

### 一个重要性质

对于这题，首先我们可以发现，由于一个人死后，其他人被打中概率的分母会受到影响，产生了后效性，似乎很不可维护。

因此我们需要知道一个重要性质：设$tot=\sum_{i=1}^na_i$，则题意可以转化为，**每个人被打中的概率为$\frac{a_i}{tot}$，不断开枪直至打中一个还活着的人，则这个人就会死掉**。

为什么这个正确呢？我口胡一下，应该是两种情况下，此时活着的人被打中的概率比都是仇恨度之比，是一样的。

### 容斥

知道了这个性质，这道题就可做的多了。

直接求$1$最后被打死的概率似乎不太容易，因此我们可以**容斥**一下。

设在$1$之后死掉的人**至少包含点集$S$内所有人**的概率为$p(S)$。

则答案就是：

$$ans=\sum(-1)^{|S|}p(S)$$

这里的容斥系数应该好理解吧，就是常见的偶数情况方案减去奇数情况方案。

设$sum(S)=\sum_{i∈S}a_i$，考虑如何求$p(S)$。

由于至少包含点集$S$内的所有人，那么其实就相当于无限开枪，每次可以打除点$1$和点集$S$外的任意点（仇恨度总和为$tot-a_1-sum(S)$），直至打中点$1$。

如果用一个式子表示，也就是：

$$p(S)=\sum_{i=0}^\infty(\frac{tot-a_1-sum(S)}{tot})^i\cdot\frac{a_1}{tot}$$

单独考虑$\sum_{i=0}^\infty(\frac{tot-a_1-sum(S)}{tot})^i$这一式子，由于$\frac{tot-a_1-sum(S)}{tot}$显然满足在$[0,1)$范围内，所以它的$\infty$次项是无限接近于$0$的。

所以我们可以用等比数列求和公式，得到：

$$\sum_{i=0}^\infty(\frac{tot-a_1-sum(S)}{tot})^i=\frac{(\frac{tot-a_1-sum(S)}{tot})^\infty-1}{\frac{tot-a_1-sum(S)}{tot}-1}=\frac{0-1}{\frac{tot-a_1-sum(S)}{tot}-1}=\frac{1}{1-\frac{tot-a_1-sum(S)}{tot}}=\frac{1}{\frac{a_1+sum(S)}{tot}}=\frac{tot}{a_1+sum(S)}$$

代回原式得到：

$$p(S)=\frac{tot}{a_1+sum(S)}\cdot\frac{a_1}{tot}=\frac{a_1}{a_1+sum(S)}$$

把$p(S)$代入$ans$便可得到：

$$ans=\sum(-1)^{|S|}\frac{a_1}{a_1+sum(S)}$$

此时的式子已经好求了许多，但似乎依旧不太好搞。

### 生成函数

看一下数据范围，我们发现题目中似乎特意指出，$\sum_{i=1}^na_i\le10^5$，肯定有猫腻！

再看一眼上面的式子，立刻就能想到枚举$sum(S)$！

如果设：

$$f(i)=\sum_{sum(S)=i}(-1)^{|S|}$$

那么显然答案就是：

$$ans=\sum_{i=0}^{tot}f(i)\frac{a_1}{a_1+i}$$

但$f(i)$怎么求呢？不难想到可以利用生成函数。

如果没有$(-1)^{|S|}$这个烦人的家伙，而只是简单的$\sum_{sum(S)=i}1$，我们不难想到，就是生成函数$\prod_{i=2}^n(1+x^{w_i})$第$i$次项的系数。

然而出现了$(-1)^{|S|}$，其实也并不会很难，其实就相当于生成函数$\prod_{i=2}^n(1-x^{w_i})$第$i$次项的系数。

而这个生成函数，我们可以用分治$NTT$来求出。

### 分治$NTT$

什么是分治$NTT$？

说起来是个很高大上的东西，但至少这道题的分治$NTT$，是很简单的。

考虑我们当前要把$[l,r]$范围内的多项式全部乘起来，那么我们可以递归求出$[l,mid]$和$[mid+1,r]$中多项式全部乘起来的结果，然后乘在一起，就是$[l,r]$范围内的多项式的乘积了。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100000
#define LN 20
#define X 998244353
#define Qinv(x) Qpow(x,X-2)
using namespace std;
int n,a[N+5],tot[N+5],f[4*N+5];
I int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		char c,*A,*B,FI[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
}F;
template<int SZ,int PR> class Poly//多项式算法，求解分治NTT
{
	private:
		int IPR,P,L,R[4*N+5],K,S[2*LN+5],g[2*LN+5][4*N+5];
		Tp I void T(Ty *s,CI op)
		{
			RI i,j,k,U,S,x,y;for(i=0;i^P;++i) i<R[i]&&(x=s[i],s[i]=s[R[i]],s[R[i]]=x);
			for(i=1;i^P;i<<=1) for(U=Qpow(~op?PR:IPR,(X-1)/(i<<1)),j=0;j^P;j+=i<<1)
				for(S=1,k=0;k^i;++k,S=1LL*S*U%X) s[j+k]=((x=s[j+k])+(y=1LL*S*s[i+j+k]%X))%X,s[i+j+k]=(x-y+X)%X;
		}
	public:
		I Poly() {IPR=Qinv(PR);for(RI i=1;i<=2*LN;++i) S[++K]=i;}//初始化可用多项式的栈
		Tp I void Solve(Ty *a,Ty *f,CI l,CI r)//分治NTT
		{
			if(l==r) return (void)(f[0]=1,f[a[l]]=X-1);RI i,mid=l+r>>1,lc,rc;//边界直接赋值
			lc=S[K--],Solve(a,g[lc],l,mid),rc=S[K--],Solve(a,g[rc],mid+1,r);//递归处理子区间
			P=1,L=0;W(P<=tot[r]-tot[l-1]) P<<=1,++L;for(i=0;i^P;++i) R[i]=(R[i>>1]>>1)|((i&1)<<L-1);//初始化
			for(T(g[lc],1),T(g[rc],1),i=0;i^P;++i) f[i]=1LL*g[lc][i]*g[rc][i]%X;//NTT
			RI t=Qinv(P);for(T(f,-1),i=0;i<=tot[r]-tot[l-1];++i) f[i]=1LL*f[i]*t%X;//NTT
			for(i=0;i^P;++i) g[lc][i]=g[rc][i]=0;S[++K]=lc,S[++K]=rc;//清空后扔回栈中，以重复利用
		}
};Poly<N,3> P;
int main()
{
	RI i,ans=0;for(F.read(n),i=1;i<=n;++i) F.read(a[i]),tot[i]=tot[i-1]+a[i];//读入，求前缀和方便后续处理
	for(P.Solve(a,f,2,n),i=0;i<=tot[n]-tot[1];++i) ans=(1LL*f[i]*a[1]%X*Qinv((a[1]+i)%X)+ans)%X;//分治NTT后统计答案
	return printf("%d",ans),0;
}
```

---

## 作者：EuphoricStar (赞：6)

感觉跟 [CF Gym 102978H Harsh Comments](https://codeforces.com/gym/102978/problem/H) 很像。

考虑容斥，钦定 $S \subseteq [2, n]$ 中的人比 $1$ 后死。设 $P(S)$ 为 $S$ 中的人比 $1$ 后死的概率，那么答案为：

$$ans = \sum\limits_{S \subseteq [2, n]} (-1)^{|S|} P(S)$$

至于 $P(S)$ 的计算，考虑这样一个问题：现在的全集是 $\{1\} \cup S$，我们要从全集中选一个人作为第一个死的，每个人被选中的概率与 $w_i$ 成正比，那么 $1$ 被选中的概率为 $\frac{w_1}{w_1 + \sum\limits_{i \in S} w_i}$。

因此：

$$ans = \sum\limits_{S \subseteq [2, n]} (-1)^{|S|} \frac{w_1}{w_1 + \sum\limits_{i \in S} w_i}$$

发现 $\sum w_i$ 很小，考虑对 $i \in [2, n]$ 的 $w_i$ 做一个 0/1 背包，可以求出 $f_i = \sum\limits_{S \in [2, n]} (-1)^{|S|} [\sum\limits_{j \in S} w_j = i]$，给每个物品赋一个 $-1$ 的权即可。直接做是 $O(n \sum w_i)$ 的，可以拿到 $80$ 分。

这种背包的题一般考虑构造多项式然后分治 NTT 求解。考虑构造 $F(x) = \prod\limits_{i = 2}^n (1 - x^{w_i})$，那么 $f_i = [x^i] F(x)$。分治 NTT 求出 $F(x)$ 即可。时间复杂度 $O(\sum w_i \log^2 \sum w_i)$。

```cpp
// Problem: P5644 [PKUWC2018] 猎人杀
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5644
// Memory Limit: 500 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 500100;
const ll mod = 998244353, G = 3;

inline ll qpow(ll b, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) {
			res = res * b % mod;
		}
		b = b * b % mod;
		p >>= 1;
	}
	return res;
}

ll n, m, a[maxn], r[maxn];

typedef vector<ll> poly;

inline poly NTT(poly a, int op) {
	int n = (int)a.size();
	for (int i = 0; i < n; ++i) {
		if (i < r[i]) {
			swap(a[i], a[r[i]]);
		}
	}
	for (int k = 1; k < n; k <<= 1) {
		ll wn = qpow(op == 1 ? G : qpow(G, mod - 2), (mod - 1) / (k << 1));
		for (int i = 0; i < n; i += (k << 1)) {
			ll w = 1;
			for (int j = 0; j < k; ++j, w = w * wn % mod) {
				ll x = a[i + j], y = w * a[i + j + k] % mod;
				a[i + j] = (x + y) % mod;
				a[i + j + k] = (x - y + mod) % mod;
			}
		}
	}
	if (op == -1) {
		ll inv = qpow(n, mod - 2);
		for (int i = 0; i < n; ++i) {
			a[i] = a[i] * inv % mod;
		}
	}
	return a;
}

inline poly operator * (poly a, poly b) {
	a = NTT(a, 1);
	b = NTT(b, 1);
	int n = (int)a.size();
	for (int i = 0; i < n; ++i) {
		a[i] = a[i] * b[i] % mod;
	}
	a = NTT(a, -1);
	return a;
}

inline poly mul(poly a, poly b) {
	int n = (int)a.size() - 1, m = (int)b.size() - 1, k = 0;
	while ((1 << k) <= n + m + 1) {
		++k;
	}
	for (int i = 1; i < (1 << k); ++i) {
		r[i] = (r[i >> 1] >> 1) | ((i & 1) << (k - 1));
	}
	poly A(1 << k), B(1 << k);
	for (int i = 0; i <= n; ++i) {
		A[i] = a[i];
	}
	for (int i = 0; i <= m; ++i) {
		B[i] = b[i];
	}
	poly res = A * B;
	res.resize(n + m + 1);
	return res;
}

poly dfs(int l, int r) {
	if (l == r) {
		poly A(a[l] + 1);
		A[0] = 1;
		A[a[l]] = mod - 1;
		return A;
	}
	int mid = (l + r) >> 1;
	poly A = dfs(l, mid), B = dfs(mid + 1, r);
	return mul(A, B);
}

void solve() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", &a[i]);
		if (i > 1) {
			m += a[i];
		}
	}
	poly f = dfs(2, n);
	ll ans = 0;
	for (int i = 0; i <= m; ++i) {
		ans = (ans + f[i] * a[1] % mod * qpow(a[1] + i, mod - 2) % mod) % mod;
	}
	printf("%lld\n", ans);
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
```

---

## 作者：徐致远 (赞：5)


[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/12/19/%E3%80%8CPKUWC2018%E3%80%8D%E9%A2%98%E8%A7%A3-Solution/)

### 题解

对于这一道题，一个比较麻烦的问题就是当死了猎人之后，每个猎人的中枪概率会发生改变。

不妨对问题进行这样的转化：

当猎人中枪之后，他的尸体还在，并且在下一次开枪的时候，他的尸体仍然有机会被打中，打中的概率不变。如果一次开枪打中了一具尸体，那么就继续开枪，直到打到活人为止。

不难发现，这样转化问题之后，问题的答案并没有改变，而且此时每次猎人中枪的概率没变。

并且直接计算$1$号猎人最后死亡的概率并不容易，考虑容斥：
$$
ans=1+\sum_{T\subseteq \lbrace2,3,\cdots n\rbrace}{(-1)^{|T|}P(T)}
$$
其中$P(T)$表示集合$T$中的猎人都在$1$号猎人之后死的概率。

考虑如何计算一个集合内的所有猎人都在$1$号猎人之后死的概率。

令$S=\sum_{i=1}^{n}w_i$，$W_T=\sum_{i\in T}W_i$，那么就有：
$$
P(T)=\sum_{i=1}^{+\infty}{\frac{W_1}{S}\cdot(1-\frac{W_T+W_1}{S})^{i-1}}=\frac{W_1}{S}\sum_{i=0}^{+\infty}{(1-\frac{W_T+W_1}{S})^i}=\frac{W_1}{S}\cdot\frac{1}{1-(1-\frac{W_T+W_1}{S})}=\frac{W_1}{W_1+W_T}
$$
所以，集合$T$对答案的贡献只与$W_T$和$|T|$有关。

但是数据范围非常大，直接背包肯定是不行的，考虑生成函数：
$$
F(x)=\prod_{i=2}^{n}{(1-x^{W_i})}
$$
那么就有
$$
ans=1+\sum_{i=1}^{S-W1}{[x^i]F(x)\cdot\frac{W_1}{W_1+i}}
$$
那个生成函数直接用NTT或者FFT然后分治计算一下就好了，时间复杂度$O(n\log^2n)$。

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
const int maxn=100005,TT=998244353;
int n,w[maxn],r[262160],ans,S;
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline int QP(int a,int b)
{
	int ret=1,w=a;
	while(b)
	{
		if(b&1) ret=(LL)ret*w%TT;
		w=(LL)w*w%TT;b>>=1;
	}
	return ret;
}
struct Polynomial
{
	int n;int* A;
	Polynomial(const Polynomial& b){n=b.n;A=new int[n+5];memcpy(A,b.A,4*(n+5));}
	Polynomial(int l=262160){n=l;A=new int[l+5];memset(A,0,(l+5)*sizeof(int));}
	~Polynomial(){delete A;}
}TA,TB;
inline void NTT(Polynomial& F,int limit,int typ)
{
	for(int i=0;i<limit;i++)
		if(i<r[i])
			swap(F.A[i],F.A[r[i]]);
	for(int mid=1;mid<limit;mid<<=1)
	{
		int gn=QP(3,(TT-1)/(mid<<1));
		if(typ<0) gn=QP(gn,TT-2);
		for(int j=0;j<limit;j+=(mid<<1))
		{
			int g=1;
			for(int k=0;k<mid;k++,g=(LL)g*gn%TT)
			{
				int x=F.A[j+k],y=(LL)g*F.A[j+k+mid]%TT;
				F.A[j+k]=(x+y)%TT;
				F.A[j+k+mid]=(x-y+TT)%TT;
			}
		}
	}
	if(typ<0)
	{
		int inv=QP(limit,TT-2);
		for(int i=0;i<limit;i++) F.A[i]=(LL)F.A[i]*inv%TT;
	}
}
inline Polynomial Calc(int L,int R)
{
	if(L==R)
	{
		Polynomial C(w[L]);
		C.A[0]=1;C.A[w[L]]=TT-1;
		return C;
	}
	int M=(L+R)>>1;
	Polynomial A=Calc(L,M),B=Calc(M+1,R);
	int limit=1,l=0;
	while(limit<=A.n+B.n){limit<<=1;l++;}
	for(int i=0;i<limit;i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	TA.n=A.n;TB.n=B.n;Polynomial C(limit);
	for(int i=0;i<limit;i++) TA.A[i]=TB.A[i]=0;
	for(int i=0;i<=A.n;i++) TA.A[i]=A.A[i];
	for(int i=0;i<=B.n;i++) TB.A[i]=B.A[i];
	NTT(TA,limit,1);NTT(TB,limit,1);
	for(int i=0;i<limit;i++) C.A[i]=(LL)TA.A[i]*TB.A[i]%TT;
	NTT(C,limit,-1);
	C.n=A.n+B.n;
	return C;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++){w[i]=read();if(i>1) S+=w[i];}
	Polynomial res=Calc(2,n);ans=1;
	for(int i=1;i<=S;i++)
		ans=(ans+TT+(LL)res.A[i]*w[1]%TT*QP(i+w[1],TT-2)%TT)%TT;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Reaepita (赞：5)

## 解题思路


这道题的难点主要在于猎人死亡后，会改变其它所有猎人被射中的概率。

#### 结论：

原问题等价于，每轮重复开枪直到射中一个没有死亡的猎人，第 $i$ 个猎人被射中的概率为 $\frac{w_i}{\sum_{j=1}^nw_j}$。

#### 证明：

设当前所有猎人的 $w_i$ 之和为 $S$ ，依然存活的猎人 $w_i$ 之和为 $P$，下一次射死猎人 $i$ 的概率 $p$。

原问题 
$$
p=\frac{w_i}{P}
$$

现问题

$$
p=\frac{w_i+(S-P)p}{S}=\frac{w_i}{P}
$$

直接求 $1$ 号猎人被最后射死的概率显然不好求。

考虑容斥，枚举在 $1$ 号猎人后死的猎人。

所有猎人的 $w_i$ 之和为 $S$，枚举的猎人的 $w_i$ 和为 $T$。

枚举的猎人集合为 $A$
$$
ans=\sum_A(-1)^{|A|}\frac{w_1}{S}\sum_{i=0}^{\infty}(1-\frac{T+w_1}{S})^i
$$

可以发现 $1-\frac{T+w_1}{S}<1$ 

即 $\sum_{i=0}^{\infty}(1-\frac{T+w_1}{S})^i$ 是收敛的

所以
$$
ans=\sum_{A}(-1)^{|A|}\frac{w_i}{T+w_1}
$$

答案只与 $T$ 和 $|A|$ 有关。

题目中 $\sum_{i=1}^nw_i\leq 10^5$，显然不能直接背包


构造生成函数
$$
F(x)=\prod_{i=2}^n(1-x^{w_i})
$$

那么最后答案为
$$
ans=\sum_{i=0}^{S-w_1}\frac{w_1[x^i]F(x)}{T+w_1}
$$

求 $F(x)$ 直接分治 + NTT 即可

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353,g=3;
const int maxn=2e5+10;
int lim,bit,rev[maxn<<2];
int val[maxn];
int Pow(int a,long long k)
{
	int ret=1;
	while(k)
	{
		if(k&1)ret=ret*1LL*a%mod;
		k>>=1,a=a*1LL*a%mod;
	}
	return ret;
 } 
void init(int len)
{
	lim=1,bit=0;
	while(lim<=len)lim<<=1,bit++;
	for(int i=0;i<lim;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<bit-1);
}
void NTT(int *A,int type)
{
	for(int i=0;i<lim;i++)if(rev[i]>i)swap(A[rev[i]],A[i]);
	for(int mid=1;mid<lim;mid<<=1)
	{
		int w=Pow(g,(mod-1)/(mid<<1));
		if(type==-1)w=Pow(w,mod-2);
		for(int j=0;j<lim;j+=mid<<1)
		for(int k=0,wn=1;k<mid;k++,wn=wn*1LL*w%mod)
		{
			int x=A[j+k],y=wn*1LL*A[j+k+mid]%mod;
			A[j+k]=(x+y)%mod;
			A[j+k+mid]=(x+mod-y)%mod;
		}
	}
	if(type==-1)
	{
		int inv=Pow(lim,mod-2);
		for(int i=0;i<lim;i++)A[i]=A[i]*1LL*inv%mod;
	}
}
int a[maxn<<2],b[maxn<<2];
vector<int>Div(int l,int r)
{
	vector<int>now,L,R;
	if(l==r){now.resize(val[l]+1),now[val[l]]=-1,now[0]=1;return now;}
	int mid=l+r>>1;
	L=Div(l,mid),R=Div(mid+1,r);
	init(L.size()+R.size()-1);
	for(int i=0;i<lim;i++)a[i]=b[i]=0;
	for(int i=0;i<L.size();i++)a[i]=L[i];
	for(int i=0;i<R.size();i++)b[i]=R[i];
	NTT(a,1),NTT(b,1);
	for(int i=0;i<lim;i++)a[i]=a[i]*1LL*b[i]%mod;
	NTT(a,-1);
	for(int i=0;i<L.size()+R.size()-1;i++)now.push_back(a[i]);
	return now;
}
int n,tot=0;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&val[i]),tot+=i>1?val[i]:0;
	vector<int>ans=Div(2,n);
	int ret=0;
	for(int s=0;s<=tot;s++)ret=(ret+ans[s]*1LL*val[1]%mod*Pow(val[1]+s,mod-2)%mod)%mod;
	printf("%d\n",ret);
}
```

---

## 作者：do_while_true (赞：3)

题意：初始有 $n$ 个人，每个人的权值是 $w_i$，假设这一轮剩余还没嘎掉的人总权值是 $s$，那么这一轮它有 $\frac{w_i}{s}$ 的概率嘎掉。求 $1$ 活到最后的概率是多少。

考虑算最后一次嘎的概率很难算，但是很容易算第一次嘎的概率。所以就容斥，枚举一个集合 $S$，钦定这个集合 $S$ 的人不满足在 $1$ 后面嘎，其余人无所谓没有限制，那么就只看 $S$ 这个集合里面 $1$ 第一次嘎掉的概率，此时对答案的贡献就是：

$$
(-1)^{|S|}\frac{w_1}{\left(\sum_{i\in S}w_i\right)+w_1}
$$

现在是固定 $S$（或者说，枚举 $S$），然后考虑转为固定其它东西，那就固定 $\sum_{i\in S}w_i$，那么要计算的就是 $(-1)^{|S|}$ 的总和。

每个人的 OGF 是 $(1-z^{w_i})$，分治 + NTT 乘起来就行了。

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#include<random>
#include<assert.h>
#define pb emplace_back
#define mp make_pair
#define fi first
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n';
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n';
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef pair<int,ll>pil;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
typedef vector<pil>vpil;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x,T2& ...y){read(x);read(y...);}
const int mod=998244353;
inline void cadd(int &x,int y){x=(x+y>=mod)?(x+y-mod):(x+y);}
inline void cdel(int &x,int y){x=(x-y<0)?(x-y+mod):(x-y);}
inline int add(int x,int y){return (x+y>=mod)?(x+y-mod):(x+y);}
inline int del(int x,int y){return (x-y<0)?(x-y+mod):(x-y);}
int qpow(int x,int y){
	int s=1;
	while(y){
		if(y&1)s=1ll*s*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return s;
}
namespace MyPoly
{
	const int T=17;//2^T>n+m
	int inv[(1<<T)+10],fac[(1<<T)+10];
	int w[T][(1<<(T-1))+10],iw[T][(1<<(T-1))+10];
	void prework(){
		fac[0]=1;
		for(int i=1;i<=(1<<T);i++)fac[i]=1ll*fac[i-1]*i%mod;
		inv[1<<T]=qpow(fac[1<<T],mod-2);
		for(int i=(1<<T)-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;
		for(int i=0;i<T;i++){
			int n=1<<(i+1);
			int W=qpow(3,(mod-1)/n);
			int IW=qpow(332748118,(mod-1)/n);
			w[i][0]=1;
			iw[i][0]=1;
			for(int j=1;j<n/2;j++)w[i][j]=1ll*w[i][j-1]*W%mod,iw[i][j]=1ll*iw[i][j-1]*IW%mod;
		}
	}
	struct Poly{
		vi a;
		Poly(){vi().swap(a);}
		int size(){return a.size();}
		void resize(int x){a.resize(x);}
		int &operator[](int i){return a[i];}
	};
	void DFT(Poly &a){ //转置
		int n=a.size();
		int p=__builtin_ctz(n);
		for(int i=n/2;i;i>>=1){
			--p;
			for(int j=0;j<n;j+=i<<1){
				for(int k=0;k<i;++k){
					int u=a[j+k],v=a[j+i+k];
					a[j+k]=add(u,v);
					a[j+i+k]=del(1ll*u*w[p][k]%mod,1ll*v*w[p][k]%mod);
				}
			}
		}
	}
	void IDFT(Poly &a){
		int n=a.size();
		int p=-1;
		for(int i=1;i<n;i<<=1){
			++p;
			for(int j=0;j<n;j+=i<<1){
				for(int k=0;k<i;++k){
					int v=1ll*a[j+i+k]*iw[p][k]%mod;
					a[j+i+k]=del(a[j+k],v);
					cadd(a[j+k],v);
				}
			}
		}
		int iv=qpow(n,mod-2);
		for(int i=0;i<n;i++)
			a[i]=1ll*a[i]*iv%mod;
	}
	Poly operator*(Poly &f,Poly &g){
		int n=f.size(),m=g.size();
		if (1ll*n*m<=1000){
			Poly h;
			h.resize(n+m-1);
			for(int i=0;i<n;i++)
				if(f[i])
					for(int j=0;j<m;j++)
						if(g[j])
							cadd(h[i+j],1ll*f[i]*g[j]%mod);
			return h;
		}
		int len=1,ct=0;
		while(len<=n+m)len<<=1,++ct;
		f.resize(len);
		g.resize(len);
		DFT(f);
		DFT(g);
		for(int i=0;i<len;i++)
			f[i]=1ll*f[i]*g[i]%mod;
		IDFT(f);
		f.resize(n+m-1);
		return f;
	}
}
using namespace MyPoly;
const int N=100010;
int n,a[N];
Poly solve(int l,int r){
	if(l==r){
		Poly f;f.resize(a[l]+1);
		f[0]=1;f[a[l]]=mod-1;
		return f;
	}
	int mid=(l+r)>>1;
	Poly f=solve(l,mid),g=solve(mid+1,r);
	return f*g;
}
signed main(){
	prework();
	read(n);
	int s=0;
	for(int i=1;i<=n;i++)s+=read(a[i]);
	Poly f=solve(2,n);
	int ans=0,len=f.a.size();
	for(int i=0;i<len;i++)
		cadd(ans,1ll*f[i]*a[1]%mod*inv[i+a[1]]%mod*fac[i+a[1]-1]%mod);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：zifanwang (赞：2)

首先可以发现从活着的猎人中选和从全部猎人中选是等价的，不影响最终的概率。那么就可以转化为求猎人 $2\sim n$ 都在猎人一第一次被选中之前被选过的概率。

考虑容斥，枚举一个子集 $S$ 使得 $S$ 中的猎人都没在猎人一之前被选过，那么易得对答案的贡献就是 $(-1)^{|S|}\times\frac{1}{1-\frac{\sum _{i\in S}w_i}{\sum w}}\times\frac{w_1}{\sum w}$。

发现 $\sum w\le 10^5$，考虑生成函数，直接 NTT 求出 $\sum_{i\in S}w_i$ 的每种情况的容斥系数的和即可。可以建个优先队列，把每个猎人的生成函数丢进去，每次拿出次数最小的两个合并即可，可以通过此题。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 100003
#define md 998244353
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
using namespace std;
int n,s,k,rev[524288];
ll xi,ans,a[mxn],f[524288],g[524288];
ll power(ll x,int y){
	ll ans=1;
	for(;y;y>>=1){
		if(y&1)ans=ans*x%md;
		x=x*x%md;
	}
	return ans;
}
void ntt(ll *a,int n,int flag){
	rept(i,0,n)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int h=1;h<n;h<<=1){
		ll x,y,s=power(3,499122176/h);
		for(int j=0;j<n;j+=h<<1){
			ll w=1;
			for(int k=j;k<j+h;++k){
				x=a[k],y=w*a[k+h]%md;
				a[k]=(x+y)%md;
				a[k+h]=(x-y+md)%md;
				w=w*s%md;
			}
		}
	}
	if(flag==-1){
		ll p=power(n,md-2);
		reverse(a+1,a+n);
		rept(i,0,n)a[i]=a[i]*p%md;
	}
}
struct node{
	vector<int>a;
	node operator*(node x){
		node ans;
		for(k=0,s=1;s<a.size()+x.a.size()-1;s<<=1,++k);
		rept(i,0,s)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1)),f[i]=g[i]=0;
		rept(i,0,a.size())f[i]=a[i];
		rept(i,0,x.a.size())g[i]=x.a[i];
		ntt(f,s,1);ntt(g,s,1);
		rept(i,0,s)f[i]=f[i]*g[i]%md;
		ntt(f,s,-1);
		ans.a.resize(a.size()+x.a.size()-1);
		rept(i,0,ans.a.size())ans.a[i]=f[i];
		return ans;
	}
};
inline bool operator<(node x,node y){
	return x.a.size()>y.a.size();
}
priority_queue<node>q;
signed main(){
	scanf("%d",&n);
	if(n==1){
		puts("1");
		return 0;
	}
	rep(i,1,n){
		scanf("%lld",&a[i]),xi=(xi+a[i])%md;
		if(i!=1){
			node e;
			e.a.resize(a[i]+1,0);
			e.a[0]=md-1;
			e.a[a[i]]=1;
			q.push(e);
		}
	}
	xi=power(xi,md-2);
	while(q.size()>1){
		node x=q.top();q.pop();
		node y=q.top();q.pop();
		q.push(x*y);
	}
	node s=q.top();
	rept(i,0,s.a.size())if(s.a[i]){
		ans=(ans+power((1-i*xi)%md,md-2)*s.a[i]%md*xi%md*a[1])%md;
	}
	cout<<(ans+md)%md;
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：2)

# P5644 题解



[Problem Link](https://www.luogu.com.cn/problem/P5644)



## 题目大意

> 一个序列有 $n$ 个元素 $w_1\sim w_n$，第 $i$ 个元素有 $\dfrac{w_i}{\sum _{i=1}^n w_i}$ 的概率被删除，求最后整个序列只剩下第一个元素的概率。
>
> 数据范围：$W=\sum_{i=1}^n w_i\le 10^5,w_i\ge 1$。



## 思路分析

考虑一个技巧，当 $i$ 被删除后，我们不更新 $w_i$ 的和，按照原概率继续选，如果选到 $i$ 就忽略，根据等比数列求和公式可以证明这种转化不影响剩下的每个数被删除的概率，简单地理解可以看成每个未被删除的元素所占权重并未改变。

因此考虑容斥，假设钦定 $S$ 中的元素晚于 $1$ 被删除，剩下的随便处理，枚举 $1$ 第一次被删除的位置有：
$$
\begin{aligned}
\mathrm{ans}
&=\sum_{S\subseteq\{2,3,\dots,n\}}(-1)^{|S|} \sum_{i=1}^{\infty} \dfrac{w_1}W\times \left(\dfrac{W-w_1-\mathrm{sum}(S)}{W}\right)^{i-1}\\[2ex]
&=\sum_{S\subseteq\{2,3,\dots,n\}}(-1)^{|S|} \dfrac{w_1}W\times \left(1-\dfrac{W-w_1-\mathrm{sum}(S)}{W}\right)^{-1}\\[2ex]
&=\sum_{S\subseteq\{2,3,\dots,n\}}(-1)^{|S|} \dfrac{w_1}W\times\dfrac{W}{w_1+\mathrm{sum}(S)}\\[2ex]
&=\sum_{S\subseteq\{2,3,\dots,n\}}(-1)^{|S|} \dfrac{w_1}{w_1+\mathrm{sum}(S)}
\end{aligned}
$$
考虑枚举每个 $\mathrm{sum}(S)$ 出现时 $(-1)^{|S|}$ 的带权和，考虑构造生成函数，容易发现 $\mathrm{sum}(S)=i$ 时所求即为 $[x^i]f(x)=\prod\limits_{i=2}^n (1-x^{w_i})$，最终答案就是 $w_1\times \sum_{i=0}^W \dfrac{[x^i]f(x)}{i+w_1}$，分治 NTT 求出 $f(x)$ 即可。

时间复杂度 $\mathcal O(W\log  W)$。

## 代码呈现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=1e5+5;
const int MOD=998244353,INV=(MOD+1)/3;
inline int ksm(int a,int b=MOD-2,int m=MOD) {
	int ret=1;
	while(b) {
		if(b&1) ret=ret*a%m;
		a=a*a%m;
		b=b>>1;
	}
	return ret;
}
inline void NTT(vector <int> &f,int len,int op) {
	vector <int> rev(len,0);
	for(int i=1;i<len;++i) {
		rev[i]=rev[i>>1]>>1;
		if(i&1) rev[i]|=len>>1;
	}
	for(int i=0;i<len;++i) if(i<rev[i]) swap(f[i],f[rev[i]]);
	for(int st=2;st<=len;st=st<<1) {
		int unit=ksm(op==1?3:INV,(MOD-1)/st);
		for(int i=0;i<len;i+=st) {
			int w=1;
			for(int j=i;j<i+st/2;++j) {
				int L=f[j],R=w*f[j+st/2]%MOD;
				f[j]=(L+R>=MOD?L+R-MOD:L+R),f[j+st/2]=(L>=R?L-R:L+MOD-R);
				w=w*unit%MOD;
			}
		}
	}
}
struct Poly {
	vector <int> f;
	Poly(int x=0) { f.clear(),f.resize(x,0); }
	Poly(vector <int> F) { f=F; }
	Poly(initializer_list <int> F): f(F) {}
	inline int length() { return f.size(); }
	inline int& operator [](int k) { return f[k]; }
	inline friend Poly operator +(Poly A,Poly B) {
		Poly C(max(A.length(),B.length()));
		for(int i=0;i<A.length();++i) C[i]=(C[i]+A[i]>=MOD)?C[i]+A[i]-MOD:C[i]+A[i];
		for(int i=0;i<B.length();++i) C[i]=(C[i]+B[i]>=MOD)?C[i]+B[i]-MOD:C[i]+B[i];
		return C;
	}
	inline friend Poly operator +(Poly A,int x) { return A+Poly{x}; }
	inline friend Poly operator +(int x,Poly A) { return Poly{x}+A; }
	inline friend Poly operator -(Poly A,Poly B) {
		Poly C(max(A.length(),B.length()));
		for(int i=0;i<A.length();++i) C[i]=(C[i]+A[i]>=MOD)?C[i]+A[i]-MOD:C[i]+A[i];	
		for(int i=0;i<B.length();++i) C[i]=(C[i]>=B[i])?C[i]-B[i]:C[i]+MOD-B[i];	
		return C;
	}
	inline friend Poly operator -(Poly A,int x) { return A-Poly{x}; }
	inline friend Poly operator -(int x,Poly A) { return Poly{x}-A; }
	inline friend Poly operator *(Poly A,Poly B) {
		int n=A.length()-1,m=B.length()-1,len=1;
		while(len<A.length()+B.length()) len=len<<1;
		vector <int> c(len);
		A.f.resize(len),B.f.resize(len);
		NTT(A.f,len,1),NTT(B.f,len,1);
		for(int i=0;i<len;++i) c[i]=A.f[i]*B.f[i]%MOD;
		NTT(c,len,-1);
		Poly C(n+m+1);
		int inv=ksm(len,MOD-2);
		for(int i=0;i<=n+m;++i) C[i]=c[i]*inv%MOD;
		return C;
	}
	inline friend Poly operator *(Poly A,int x) {
		for(int i=0;i<A.length();++i) A[i]=A[i]*x%MOD;
		return A;
	}
	inline friend Poly operator *(int x,Poly A) {
		for(int i=0;i<A.length();++i) A[i]=A[i]*x%MOD;
		return A;
	}
	inline friend Poly operator %(Poly A,int m) {
		if(A.length()>m) A.f.resize(m);
		return A;
	}
	inline int calc(int x) {
		int ret=0,p=1;
		for(int c:f) ret=(ret+p*c)%MOD,p=p*x%MOD;
		return ret;
	}
}	P[MAXN];
int n,w[MAXN];
inline void solve(int l,int r) {
	if(r-l<=64) {
		for(int i=l+1;i<=r;++i) P[l]=P[l]*P[i];
		return ;
	} 
	int mid=(l+r)>>1;
	solve(l,mid),solve(mid+1,r);
	P[l]=P[l]*P[mid+1];
}
signed main() {
	scanf("%lld",&n);
	for(int i=1;i<=n;++i) {
		scanf("%lld",&w[i]);
		P[i].f.resize(w[i]+1);
		P[i][0]=1,P[i][w[i]]=MOD-1;
	}
	solve(2,n);
	int ans=0;
	for(int i=0;i<P[2].length();++i) ans=(ans+P[2][i]*ksm(w[1]+i))%MOD;
	printf("%lld\n",ans*w[1]%MOD);
	return 0;
}
```

---

## 作者：serverkiller (赞：2)

如果公式挂了 请进入博客观看 或者[更好的体验](https://www.zybuluo.com/computerkiller/note/1749384)

## 题意:

$n$个人随机开枪,每个人中弹的概率不同,由1号开始开枪,问1号活到最后地概率

## solution

考虑容斥,不合法的答案是有一些数在1之后才被删除

定义全集$A=\{2,3,...,n\}$,以及令$sum=\displaystyle\sum\limits_{i=1}^n\omega_i$

那么我们很容易得到这样一个不合法概率的式子:
$$
\begin{aligned}
&\displaystyle\sum\limits_{S\subset A}\displaystyle\sum\limits_{i=0}^{\infty}(-1)^{|S|}\left(\cfrac{sum-\omega_1-\displaystyle\sum\limits_{x\in S}\omega_x}{sum}\right)^i\cfrac{\omega_1}{sum}\\
&=\cfrac{\omega_1}{sum}\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}\displaystyle\sum\limits_{i=0}^{\infty}\left(\cfrac{sum-\omega_1-\displaystyle\sum\limits_{x\in S}\omega_x}{sum}\right)^i\\
\end{aligned}
$$

而我们知道:
$$
1+x+x^2+...+x^{n-1}+x^n+...=\frac{1}{x-1}
$$

所以我们可以得到:
$$
\begin{aligned}
&\cfrac{\omega_1}{sum}\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}\displaystyle\sum\limits_{i=0}^{\infty}\left(\cfrac{sum-\omega_1-\displaystyle\sum\limits_{x\in S}\omega_x}{sum}\right)^i\\
&=\cfrac{\omega_1}{sum}\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}\frac{1}{\cfrac{sum-\omega_1-\displaystyle\sum\limits_{x\in S}\omega_x}{sum}-1}\\
&=-\cfrac{\omega_1}{sum}\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}\frac{sum}{\omega_1+\displaystyle\sum\limits_{x\in S}\omega_x}\\
\end{aligned}
$$

我们考虑套路地更换枚举顺序:
$$
-\cfrac{\omega_1}{sum}\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}\frac{sum}{\omega_1+\displaystyle\sum\limits_{x\in S}\omega_x}\\
=-\cfrac{\omega_1}{sum}\displaystyle\sum\limits_{x=1}^{sum-\omega_1}\frac{sum}{\omega_1+x}\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}[\displaystyle\sum\limits_{u\in S}\omega_u==x]\\
=-\displaystyle\sum\limits_{x=1}^{sum-\omega_1}\frac{\omega_1}{\omega_1+x}\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}[\displaystyle\sum\limits_{u\in S}\omega_u==x]
\tag{1}
$$

我们考虑后面地这个东西应该如何计算,不妨考虑他的生成函数:
$$
F(x)=\displaystyle\prod_{i=2}^n(1-x^{\omega_i})\tag{2}
$$

对于某个数$i$,$1$表示不选这个数,而$x^{\omega_i}$表示选这个数,那么我们所要的式子就是:

$$
\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}[\displaystyle\sum\limits_{u\in S}\omega_u==x]=[x^n]F(x)
$$
我们观察数据范围,发现(1)可以直接暴力乘法得到,所以我们只需要考虑(2)式.

(2)式的处理我们考虑一个分治,并不是分治fft,只是单纯地每次将其分成两部分,再将两部分合并

所以我们要的答案就是:
$$
1+\displaystyle\sum\limits_{x=1}^{sum-\omega_1}\frac{\omega_1}{\omega_1+x}\displaystyle\sum\limits_{S\subset A}(-1)^{|S|}[\displaystyle\sum\limits_{u\in S}\omega_u==x]
$$
代码被我卡常卡地没有可读性/kk 就贴个[剪贴板](https://www.luogu.com.cn/paste/ct2i8hat)吧(

---

## 作者：yllcm (赞：1)

[更好的阅读体验](https://www.cnblogs.com/yllcm/p/16467814.html)

看不懂其它题解的智慧证明/kk，于是自己口胡了一个。

考虑钦定一些人在 $i$ 后面，然后容斥。现在问题转变成了求对于 $S$，$\{1\}\cup S$ 中 $1$ 是第一个的方案数。

考虑 $S=\{2,3,\cdots,n\}$，发现概率是 $w_1/\sum_{i=1}^n w_i$，很自然地猜想对于集合 $S$，概率是：
$$
\frac{w_1}{w_1+\sum_{x\in S}w_x}
$$
这很符合我们的直觉。

假设 $P(i,S)$ 表示 $i$ 在集合 $S$ 中第一个出现的概率，那么证明这个式子几乎等价于证明：
$$
\forall i,j,\frac{P(i,S)}{P(j,S)}=\frac{w_i}{w_j}
$$
考虑 $P(i,S)$ 的式子长什么样。枚举 $i$ 前面的排列 $T$，然后钦定 $i$ 在 $T$ 后面恰好一个寄掉，得到：
$$
\sum_{T\cap S=\varnothing}f(T)\frac{w_i}{\sum_{j=1}^n w_j-\sum_{x\in T}w_x-w_i}
$$
$f(T)$ 是前面的贡献，此处省去。对比 $P(i,S)$ 和 $P(j,S)$ 的式子不难证明。

然后实际上只需要求：
$$
1+\sum_S (-1)^{|S|}\frac{w_1}{w_1+\sum_{x\in S}w_x}
$$
考虑到式子只和 $\sum_{x\in S}w_x$ 和 $|S|$ 有关，那么只需要做个背包就好了，分治+NTT 可以 $O(n\log^2 n)$。

两边分治的时候可以开 $32$ 个数组，数组里面存多项式。有点像滚动数组的操作。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define pb push_back
#define mp make_pair
#define pii pair<int, int>
using namespace std;
inline int read() {
    int x = 0; bool op = 0;
    char c = getchar();
    while(!isdigit(c))op |= (c == '-'), c = getchar();
    while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return op ? -x : x;
}
pii aprx(int p, int q, int A) {
    int x = q, y = p, a = 1, b = 0;
    while(x > A) {
        swap(x, y); swap(a, b);
        a -= (x / y) * b; x %= y;
    }
    return mp(x, a);
}
const int N = (1 << 20) + 10;
const int P = 998244353;
void add(int &a, int b) {a = (a + b) % P;}
void sub(int &a, int b) {a = (a - b + P) % P;}
int ksm(int x, int k) {
    int res = 1;
    for(int pw = x; k; (k & 1) ? res = 1ll * res * pw % P : 0, pw = 1ll * pw * pw % P, k >>= 1);
    return res;
}
int n;
int w[N];
int fac[N], ifac[N], pw[N], ipw[N];
void init() {
    fac[0] = ifac[0] = 1;
    for(int i = 1; i < N; i++)fac[i] = 1ll * fac[i - 1] * i % P;
    ifac[N - 1] = ksm(fac[N - 1], P - 2);
    for(int i = N - 2; i; i--)ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
    for(int i = 1; i <= 20; i++)pw[1 << i] = ksm(3, (P - 1) / (1 << i));
    for(int i = 1; i <= 20; i++)ipw[1 << i] = ksm(pw[1 << i], P - 2);
    return ;
}
int rev[N];
int inv(int x) {return 1ll * ifac[x] * fac[x - 1] % P;}
void NTT(int *f, int len, int op) {
    for(int i = 0; i < len; i++)rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * (len >> 1));
    for(int i = 0; i < len; i++)if(i < rev[i])swap(f[i], f[rev[i]]);
    for(int k = 2; k <= len; k <<= 1) {
        for(int i = 0; i < len; i += k) {
            int gn = (op == -1) ? ipw[k] : pw[k];
            // printf("gn:%d %d\n", k, gn);
            for(int j = i, g = 1; j < i + k / 2; j++, g = 1ll * g * gn % P) {
                int x = f[j], y = 1ll * g * f[j + k / 2] % P;
                f[j] = (x + y) % P; f[j + k / 2] = (x - y + P) % P;
            }
        }
    }
    if(op == -1) {
        for(int i = 0; i < len; i++)f[i] = 1ll * f[i] * inv(len) % P;
    }
    return ;
}
int f[N], g[35][N], stk[N], top = 33;
int solve(int cur, int l, int r) {
    if(l == r)return g[cur][w[l]] = P - 1, g[cur][0] = 1, w[l];
    int mid = l + r >> 1, len = 0, ls = stk[top--], rs = stk[top--];
    len += solve(ls, l, mid); len += solve(rs, mid + 1, r);
    int ln = 1; while(ln < len + 5)ln <<= 1;
    NTT(g[ls], ln, 1); NTT(g[rs], ln, 1);
    for(int i = 0; i < ln; i++)g[cur][i] = 1ll * g[ls][i] * g[rs][i] % P;
    NTT(g[cur], ln, -1);
    for(int i = 0; i < ln; i++)g[ls][i] = g[rs][i] = 0;
    stk[++top] = ls; stk[++top] = rs;
    return len;
}
int ans[N];
int main() {
    init();
    n = read();
    for(int i = 1; i <= n; i++)w[i] = read();
    for(int i = 1; i <= 33; i++)stk[i] = i;
    solve(0, 2, n);
    int res = 1;
    for(int i = 1; i <= 100000; i++) {
        add(res, 1ll * g[0][i] * w[1] % P * inv(i + w[1]) % P);
    }
    printf("%d\n", res);     
    return 0;
}
```


---

## 作者：zhylj (赞：1)

[更好阅读体验，博客](http://zhylj.cc/index.php/archives/46/)

## 题目

有 $n$ 个人，第 $i$ 个人有权重 $w_i$，每次以正比于权重的概率干掉某个人，求第一个人最后一个被干掉的概率。

$1\le n\le 10^5$.

## 分析

记 $s = \sum w_i$，$p_i = w_i/s$.

首先考虑概率会变化不好做，于是转化为每次任取一个人，若还没被干掉就干掉他，否则啥也不干，显然新的题目与原先是等价的。

考虑第一个最后一个被干掉的情况，相当于要满足：在第一个人被干掉的时刻之前，所有人都被选取了至少一次，且第一个人没有被选取过。

设 $f_n$ 表示「前 $n$ 个时刻，第一个人没有被选取，且第二个人到第 $n$ 个人都被选取过的概率」，容易发现 $f_n$ 可以被表示为后 $n - 1$ 个人的贡献的二项卷积。

记 $\langle p_1f_n\rangle$ 的 EGF 为 $\widehat F(z)$，于是，我们可以列出式子：

$$
\widehat F(z) = p_1\prod_{2\le i \le n} \left(\sum_{j\ge 1} \frac {(p_iz)^j}{j!}\right) = p_1\prod_{2\le i \le n}(e^{p_iz}-1)
$$

然后我们考虑展开这个式子成 $\sum_{i}a_ie^{iz}$ 的形式，于是考虑先换个元：

$$
\begin{aligned}
x & = e^{s^{-1}z}\\
p_1\prod_{2\le i \le n}(e^{p_iz}-1) & = p_1\prod_{2\le i \le n} (x^{w_i}-1)\\
\end{aligned}
$$

然后我们就要求 $a_k = [x^k]p_1\prod_{2\le i \le n} (x^{w_i}-1)$ 了，根据套路，我们有：

$$
\begin{aligned}
p_1\prod_{2\le i\le n} (x^{w_i}-1) & = p_1(-1)^{n-1}\prod_{2\le i \le n} (1-x^{w_i})\\
\prod_{2\le i \le n} (1-x^{w_i}) & = \exp\left(\sum_{2\le i\le n} \ln(1-x^{w_i})\right) \\
& = \exp\left(\sum_{2\le i\le n}\sum_{j\ge 1}\frac{-x^{w_ij}}{j}\right)
\end{aligned}
$$

于是预处理一下每种 $w_i$ 出现了几次，随便算一下系数再 $\exp$ 就可以在 $\mathcal O(s\log s)$ 的时间复杂度内计算所有 $a_k$ 了。

求出 $a_k$ 有什么用呢？我们注意到如果我们求出 $\widehat F(z)$ 的系数序列的 OGF $F(z)$，那么 $F(1)$ 就为答案，于是我们考虑如何把 $\widehat F(z)$ 写成 OGF 的形式。

注意到 $e^{cz}$ 的系数序列 $\langle c^n\rangle$ 对应的 OGF 为 $\dfrac 1{1-cz}$，于是我们有：

$$
\begin{aligned}
\widehat F(z) & = \sum_{i\ge 0} a_ie^{is^{-1}z} \\
\implies F(z) & = \sum_{i\ge 0} \frac {a_i}{1-is^{-1}z} \\
F(1) & = \sum_{i\ge 0} \frac {a_i}{1 - is^{-1}}
\end{aligned}
$$

然后就做完了，时间复杂度 $\mathcal O(s\log s)$.

~~然而由于我实现的丑，跑的比其它分治 NTT 的题解慢。~~

## 代码

```cpp
const int N = 5e5 + 5, Mod = 998244353, g = 3, gInv = 332748118;

int QPow(int a, int b) {
	int ret = 1, bas = a;
	for(; b; b >>= 1, bas = 1LL * bas * bas % Mod)
		if(b & 1) ret = 1LL * ret * bas % Mod;
	return ret;
}

int fac[N], fac_inv[N], inv[N];
void Init(int n) {
	fac[0] = 1;
	for(int i = 1; i <= n; ++i)	fac[i] = 1LL * fac[i - 1] * i % Mod;
	fac_inv[n] = QPow(fac[n], Mod - 2);
	for(int i = n - 1; ~i; --i) fac_inv[i] = 1LL * fac_inv[i + 1] * (i + 1) % Mod;
	for(int i = 1; i <= n; ++i) inv[i] = 1LL * fac_inv[i] * fac[i - 1] % Mod;
}

namespace Poly {

int rev[N], ur[N];
int GetRev(int x, int y) {
	int len = 1, h_bit = 0; ur[0] = 1;
	for(x += y; len < x; len <<= 1, ++h_bit);
	for(int i = 1; i < len; ++i)
		rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (h_bit - 1));
	return len;
}
void NTT(int f[], int len, bool flag) {
	for(int i = 0; i < len; ++i)
		if(i < rev[i]) std::swap(f[i], f[rev[i]]);
	for(int i = 1; i < len; i <<= 1) {
		int ur_1 = QPow(flag ? g : gInv, (Mod - 1) / (i << 1));
		for(int j = 1; j < i; ++j)
			ur[j] = 1LL * ur[j - 1] * ur_1 % Mod;
		for(int j = 0; j < len; j += (i << 1))
			for(int k = 0; k < i; ++k) {
				int fl = f[j + k], fr = 1LL * f[i + j + k] * ur[k] % Mod;
				f[j + k] = (fl + fr) % Mod;
				f[i + j + k] = (fl - fr + Mod) % Mod;
			}
	}
	if(!flag) {
		int len_inv = inv[len];
		for(int i = 0; i < len; ++i)
			f[i] = 1LL * f[i] * len_inv % Mod;
	}
}
int tmp_f[N];
void Inv(int f[], int f_inv[], int n) {
	if(n == 1) { f_inv[0] = QPow(f[0], Mod - 2); return; }
	Inv(f, f_inv, (n + 1) / 2);
	int len = GetRev(n, n);
	for(int i = 0; i < len; ++i) tmp_f[i] = f[i] * (i < n);
	for(int i = n; i < len; ++i) f_inv[i] = 0;
	NTT(tmp_f, len, true); NTT(f_inv, len, true);
	for(int i = 0; i < len; ++i)
		f_inv[i] = f_inv[i] * (2 - 1LL * f_inv[i] * tmp_f[i] % Mod + Mod) % Mod;
	NTT(f_inv, len, false);
	for(int i = n; i < len; ++i) f_inv[i] = 0;
}
void Der(int f[], int f_d[], int n) {
	for(int i = 0; i < n - 1; ++i)
		f_d[i] = 1LL * f[i + 1] * (i + 1) % Mod;
	f_d[n] = 0;
}
void Intg(int f[], int f_intg[], int n) {
	for(int i = n - 1; i; --i)
		f_intg[i] = 1LL * f[i - 1] * inv[i] % Mod;
	f_intg[0] = 0;
}
int tmp_f_inv[N];
void Ln(int f[], int f_ln[], int n) {
	Inv(f, tmp_f_inv, n);
	Der(f, f_ln, n);
	int len = GetRev(n, n);
	for(int i = n; i < len; ++i) tmp_f_inv[i] = f_ln[i] = 0;
	NTT(tmp_f_inv, len, true); NTT(f_ln, len, true);
	for(int i = 0; i < len; ++i)
		f_ln[i] = 1LL * tmp_f_inv[i] * f_ln[i] % Mod;
	NTT(f_ln, len, false);
	Intg(f_ln, f_ln, n);
	for(int i = n; i < len; ++i) f_ln[i] = 0;
}
int tmp_f_ln[N];
void Exp(int f[], int f_exp[], int n) {
	if(n == 1) { f_exp[0] = 1; return; }
	Exp(f, f_exp, (n + 1) / 2);
	Ln(f_exp, tmp_f_ln, n);
	int len = GetRev(n, n);
	for(int i = 0; i < n; ++i)
		tmp_f_ln[i] = ((i == 0) - tmp_f_ln[i] + f[i] + Mod) % Mod;
	for(int i = n; i < len; ++i) f_exp[i] = tmp_f_ln[i] = 0;
	NTT(f_exp, len, true); NTT(tmp_f_ln, len, true);
	for(int i = 0; i < len; ++i)
		f_exp[i] = 1LL * f_exp[i] * tmp_f_ln[i] % Mod;
	NTT(f_exp, len, false);
	for(int i = n; i < len; ++i) f_exp[i] = 0;
}

}

int n, s, s_inv, p, w[N], b[N], F[N], G[N];
int main() {
	rd(n); Init(N - 1);
	for(int i = 1; i <= n; ++i) {
		rd(w[i]);
		s += w[i];
		if(i > 1) {
			++b[w[i]];
		}
	}
	s_inv = QPow(s, Mod - 2);
	p = 1LL * w[1] * s_inv % Mod;
	++s;
	for(int i = 1; i < s; ++i) {
		for(int j = i; j < s; j += i)
			F[j] = (F[j] - 1LL * inv[j / i] * b[i] % Mod + Mod) % Mod;
	}
	Poly::Exp(F, G, s);
	for(int i = 0; i < s; ++i) {
		if(n % 2 == 0) G[i] = (Mod - G[i]) % Mod;
		G[i] = 1LL * G[i] * p % Mod;
	}
	int ans = 0;
	for(int i = 0; i < s; ++i)
		ans = (ans + 1LL * G[i] * QPow((1 - 1LL * i * s_inv % Mod + Mod) % Mod, Mod - 2)) % Mod;
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：鲤鱼江 (赞：0)

## [猎人杀](https://www.luogu.com.cn/problem/P5644) 

推：[数学记录](https://www.luogu.com.cn/article/mvcevru2)

稍微有点经验就能看出来概率一直变化是假的。

 这题与百鸽笼的差距就是白鸽笼求得是期望次数，所以要实时处理，这题不用，所以可以转化一下。

 每一个猎人死亡后仍然可能被击中，问 $1$ 号最后死的概率。

 然后考虑容斥原理，不失套路地设 $W(S)=\sum\limits_{x\in S}w_x$，$P(S)$ 为在 $1$ 之后死的至少包括 $S$ 的概率。 

$Ans=\sum\limits_{S}(-1)^{|S|}P(S)$，也就是常规的偶数减奇数。 

然后考虑 $P(S)$ 怎么求，发现 $S$ 肯定一直不能死，$1$ 肯定是最后死，我们枚举 $1$ 什么时候死。 $P(S)=\sum\limits_{i=0}^\infty (\frac{tot-a_1-W(S)}{tot})^i\frac{a_1}{tot}=\frac {a_1}{tot}\frac{tot}{a_1+W(S)}=\frac{a_1}{a_1+W(S)}$。 

所以 $Ans=\sum\limits_{S}(-1)^{|S|}\frac{a_1}{a_1+W(S)}$。

发现现在只跟元素个数和权值和有关了，而权值和很小，不难想到可以计算 $W(S)$ 为某个权值的 $(-1)^{|S|}$ 之和。

即使用生成函数计算 $\prod\limits_{i=2}^n(1-x^{a_i})$ 可以做到 $O(n\log n)$，不过本题数据范围下放过了 $O(n\log^2 n)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

namespace Fread {
	const int SIZE=1<<21;char buf[SIZE],*S,*T;
	inline char getchar() {if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return '\n';}return *S++;}
}
namespace Fwrite {
	const int SIZE=1<<21;
	char buf[SIZE],*S=buf,*T=buf+SIZE;
	inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}
	inline void putchar(char c){*S++=c;if(S==T)flush();}
	struct POPOSSIBLE{~POPOSSIBLE(){flush();}}ztr;
}
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio{
	struct Reader{
	    template<typename T>
    	Reader& operator >> (T& x) {
        	char c=getchar();T f=1;
        	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}x=0;
        	while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}x*=f;
	        return *this;
    	}
	    Reader(){}
	}cin;
	struct Writer{
	    template<typename T>
	    Writer& operator << (T x) {
	        if(x==0){putchar('0');return *this;}
	        if(x<0){putchar('-');x=-x;}
	        static int sta[45];int top=0;
	        while(x){sta[++top]=x%10;x/=10;}
	        while(top){putchar(sta[top]+'0');--top;}
	        return *this;
    	}
    	Writer& operator << (char c) {putchar(c);return *this;}
    	Writer& operator << (const char* str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;}
    	Writer(){}
	}cout;
}
#define endl '\n'
#define cin Fastio :: cin
#define cout Fastio :: cout

const int mod=998244353;
struct modint {
    int val;
    static int norm(const int& x) { return x < 0 ? x + mod : x; }
    modint inv() const {
        int a = val, b = mod, u = 1, v = 0, t;
        while (b > 0) t = a / b, swap(a -= t * b, b), swap(u -= t * v, v);
        return modint(u);
    }
    modint() : val(0) {}
    modint(const int& m) : val(norm(m)) {}
    modint(const long long& m) : val(norm(m % mod)) {}
    modint operator-() const { return modint(norm(-val)); }
    bool operator==(const modint& o) { return val == o.val; }
    bool operator<(const modint& o) { return val < o.val; }
    modint& operator+=(const modint& o) { return val = (1ll * val + o.val) % mod, *this; }
    modint& operator-=(const modint& o) { return val = norm(1ll * val - o.val), *this; }
    modint& operator*=(const modint& o) { return val = static_cast<int>(1ll * val * o.val % mod), *this; }
    modint operator-(const modint& o) const { return modint(*this) -= o; }
    modint operator+(const modint& o) const { return modint(*this) += o; }
    modint operator*(const modint& o) const { return modint(*this) *= o; }
};

const modint g=3;
const modint invg=(mod+1)/3;
const int N=1e6+10;
int rev[N],n,A,B,sum[N],w[N];
modint frac[N],inv[N];

void GetRev(int lim){
	int bit=log2(lim);
	for(int i=0;i<lim;++i) rev[i]=((rev[i>>1]>>1)|((i&1)<<(bit-1)));
}

inline modint expow(modint x,int y){
	modint res=1;
	for(;y;y>>=1){if(y&1) res*=x;x*=x;}
	return res;
}

struct Poly{
	modint a[N];
	modint& operator [](const int &x){return a[x];}
	inline void Readin(const int len){for(int i=0;i<len;++i) cin>>a[i].val;}
	inline void out(const int len){for(int i=0;i<len;++i) cout<<a[i].val<<' ';putchar('\n');}
	inline void clear(const int len){for(int i=0;i<len;++i) a[i]=modint();}
	void NTT(int limit,int type){
		for(int i=0;i<limit;++i) if(i>rev[i]) swap(a[i],a[rev[i]]);
		for(int i=1;i<limit;i<<=1){
			modint Gn=expow(type==1?g:invg,(mod-1)/(i<<1));
			for(int j=0;j<limit;j+=(i<<1)){
				modint G=1;
				for(int k=0;k<i;++k,G*=Gn){
					modint x=a[j+k],y=G*a[i+j+k];
					a[j+k]=x+y;a[i+j+k]=x-y;
				}
			}
		}
		if(type==-1){
			modint inv=expow(limit,mod-2);
			for(int i=0;i<limit;++i) a[i]*=inv;
		}
	}
}f[18];

void mul(int dep,int l,int r){
	int len=sum[r]-sum[l-1];
	int mid=(l+r)>>1;f[dep].clear(len+5);
	if(l==r){f[dep][0]=1;f[dep][w[l]]=-1;return ;}
	mul(dep+1,l,mid);int len1=sum[mid]-sum[l-1];
	for(int i=0;i<=len1;++i) f[dep][i]=f[dep+1][i];
	f[dep+1].clear(len1+5);mul(dep+1,mid+1,r);
	int lim=1;while(lim<=len) lim<<=1;
	GetRev(lim);f[dep+1].NTT(lim,1);f[dep].NTT(lim,1);
	for(int i=0;i<lim;++i) f[dep][i]*=f[dep+1][i];
	f[dep].NTT(lim,-1);f[dep+1].clear(lim);
}

signed main(){
	cin>>n;
	for(int i=1;i<=n;++i) cin>>w[i];
	for(int i=1;i<=n;++i) sum[i]=sum[i-1]+w[i];
	mul(0,2,n);modint ans=0;
//	for(int i=0;i<=sum[n];++i) cout<<f[0][i].val<<' ';
//	cout<<endl;
	for(int i=0;i<=sum[n];++i) ans+=((modint(w[1]+i)).inv())*f[0][i]*w[1];
	cout<<ans.val<<endl;
	return 0;
}
```

---

## 作者：Anoshag_Ruwan (赞：0)

注意到由于问题只和顺序有关，这个机制和你朝 $n$ 个猎人随机开枪（且每个人可中枪多次）直到干掉所有人是等价的，这样任何时刻每人中枪概率就成了定值。

但让 $1$ 号猎人最后存活这个条件也是不太好直接求的，于是考虑类似 $\min-\max$ 容斥的反演方法，令 $p(S)$ 表示 $1$ 号击毙前不会击毙 $S$ 中元素的概率（$S \subset \complement_{\{1\}}$），容斥原理有 $ans=1-\sum\limits_Sp(S)(-1)^{|S|-1}$。其中令 $sum=\sum w_i,sum_S=\sum\limits_{i \in S}w_i$，则 $p(S)=\sum\limits_{i \ge 1}(1-\frac{w_1+sum_S}{sum})^{i-1}\frac{w_1}{sum}$，使用等比数列求和化简一下发现是 $\frac{w_1}{w_1+sum_s}$。

$2^{n-1}$ 个集合仍旧不好处理，所以考虑题目所给 $sum \leq 10^5$ 求每个 $sum_S$ 的贡献，由于要乘 $(-1)^{|S|}$ 启发我们上生成函数，会发现 $\prod\limits_{i>1}(1-x^{w_i})$ 的 $k$ 次项乘 $\frac{w_1}{w_1+sum_s}$ 就是 $sum_S=k$ 时的贡献，这相当于一个 01 背包的卷积，使用分治 ntt 直接分就行（完全背包计数处理方式则是多项式 $\exp$），时间复杂度 $O(n\log^2n)$。

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
long long k1,r[500011],c[500011],q[500011],w[500011],a[500011],b[500011];
const int p=998244353;
vector<long long>g[500011];
inline long long add(long long x,long long y){return x+y>=p?x+y-p:x+y;}
inline long long rd(){
	long long i=0,j=1;char g=getchar();
	while(g>57||g<48)g=getchar();
	while(g>47&&g<58)i=(i<<3)+(i<<1)+g-48,g=getchar();
	return i*j;
}
inline long long ksm(long long x,long long y){
	long long k=1,l=x;
	while(y){if(y&1)k=k*l%p;l=l*l%p,y>>=1;}
	return k;
}
inline void bter(){
	for(int i=0;i<k1;i++)r[i]=(r[i>>1]>>1)|(i&1?k1>>1:0);}
inline void bz(long long *f){
	for(int i=0,k=ksm(k1,p-2);i<k1;i++)
		f[i]=f[i]*k%p;}
inline void ntt(long long *f,bool m){
	int i,j,k,l,h;
	for(i=0;i<k1;i++)
		if(i<r[i])swap(f[i],f[r[i]]);
	for(i=1;i<k1;i<<=1){
		l=ksm(m?3:332748118,(p-1)/(i<<1));
		for(j=q[0]=1;j<i;j++)q[j]=q[j-1]*1ll*l%p;
		for(j=0;j<k1;j+=i<<1)
			for(h=j;h<j+i;h++)
				k=q[h-j]*1ll*f[h+i]%p,f[h+i]=add(f[h],p-k),f[h]=add(f[h],k);}
}
inline void dntt(long long x,long long l,long long r){
	long long i,k,q1,mid=l+r>>1;
	if(l==r){
		for(i=0;i<=w[l];i++)g[x].push_back(0);
			g[x][0]=1,g[x][w[l]]=p-1;return;
	}dntt(x<<1,l,mid);dntt((x<<1)+1,mid+1,r);
	for(i=0,k=g[x<<1].size()-1;i<=k;i++)a[i]=g[x<<1][i];
	for(i=0,q1=g[(x<<1)+1].size()-1;i<=q1;i++)b[i]=g[(x<<1)+1][i];
	for(k1=1;k1<=k+q1;k1<<=1);
	for(i=k+1;i<k1;i++)a[i]=0;for(i=q1+1;i<k1;i++)b[i]=0;
	bter();ntt(a,1);ntt(b,1);
	for(i=0;i<k1;i++)a[i]=a[i]*b[i]%p;
	ntt(a,0);bz(a);
	for(i=0;i<=k+q1;i++)g[x].push_back(a[i]);
}
int main()
{
	long long i,j,k,m,n=rd(),s,ans;
	for(i=1,s=0;i<=n;i++)w[i]=rd(),s+=w[i];
	dntt(1,2,n);
	for(i=1,ans=0;i<=s-w[1];i++)
		ans=add(ans,g[1][i]*ksm(w[1]+i,p-2)%p);
	ans=add(ans*w[1]%p,1);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：541forever (赞：0)

#Solution
##观察
如果有一个猎人死了，那么其他猎人被打中的概率的分母就会一起减小，但不难发现，他们被打中的相对概率其实并不会变，因此可以看作猎人死了之后死尸还在打中死尸也没关系（因为我们并不关心猎人被打的期望次数）
##容斥
那么，我们考虑容斥，显然 
$$ans=\sum_ { S\subseteq \left\{2,3,4...n \right\} } (-1)^{|S|} P(S)$$
其中 $P(S)$ 表示 $S$ 这个集合内所有数都死在 $1$ 之后的概率，那么设所有 $w_i$ 的和为 $sum$,集合 $S$ 内所有数的和为 $s(S)$，则

$$P(S)=\sum_{i=0}^\infty ({{sum-a_1-s(S)} \over sum})^i \times {a_1 \over sum}$$
$$\ \ \ \ \ \ \ \ \ \ ={a_1 \over sum}\times\sum_{i=0}^\infty ({{sum-a_1-s(S)} \over sum})^i$$
考虑对 $\sum_{i=0}^\infty ({{sum-a_1-s(S)} \over sum})^i$ 等比数列求和。
设
$$Sum=\sum_{i=0}^\infty ({{sum-a_1-s(S)} \over sum})^i$$
则 
$${{sum-a_1-s(S)} \over sum}Sum=\sum_{i=1}^\infty ({{sum-a_1-s(S)} \over sum})^i$$
所以
$$Sum={tot \over {s(S)+a_1}}$$
所以
$$ans=\sum_ { S\subseteq \left\{2,3,4...n \right\} }(-1)^{|S|}\times {tot \over {s(S)+a_1}}$$
考虑平凡地变化一下这个式子。
$$\sum_{s(S)=i} (-1)^{|S|} \times {tot \over {a_1+i}}$$

我们可以将 $(-1)^{|S|}$ 和 ${tot \over {a_1+i}}$ 分开算。
设 
$$f(i)=\sum_{s(S)=i}(-1)^{|S|}$$

考虑生成函数，因为 $\sum_{s(S)=i}1$ 的第 $i$ 项为生成函数 $\prod_{i=2}^n(1+x^{w_i})$ 的第 $i$ 项，又可以考虑到 $-1^{|S|}$ 实际上就意味着每加入一个数就多一个 $-1$ 的系数，因此其生成函数为 $\prod_{i=2}^n (1-x^{w_i})$。
处理这个生成函数可以直接分治加 NTT。即算 $[l,r]$ 区间的卷积时先分治地算 $[l,mid]$ 和 $[mid,r]$ 的卷积，再将两个多项式卷起来。这样你就算出了每一项的系数，最后直接将系数代入计算即可。

[Code](https://www.luogu.com.cn/paste/2y6nq0iw)

---

## 作者：C20203030 (赞：0)

## 一、题目

~~听说过这题很久了，这么经典怎么能不做呢？~~

[点此看题](https://www.luogu.com.cn/problem/P5644)

## 二、解法

由于概率一直在变算着麻烦得很，有一个神奇 $\tt idea$ 就是我们乱开枪，如果这一枪在鞭尸那么就再开一枪，知道打死第一个人为止。这种策略的证明也不难，**对于一个人被打到的概率都只和 $w_i$ 的比值有关**。

然后还是不会做，一个想都不敢想的方法是指数级容斥，枚举集合 $S$ 表示至少集合 $S$ 中的人在 $1$ 的后面死掉，那么答案是：

> 这一步妙极了，我们要**主动使用容斥**而不是看着像容斥才用（和 $\tt cdq$ 差不多）而不是看着很像再用容斥，有很多方法能把容斥的复杂度降下来，常见的就是 $dp$ 维护容斥系数。

$$\sum_{S}(-1)^{|S|}P(S)$$

其中 $P(S)$ 表示至少集合 $S$ 中的人在 $1$ 后面死的概率，那么可以打无限枪，只要不打到 $1$ 和 $S$ 中的人就可以，然后我们再给 $1$ 补一枪，这样可以写出 $P(S)$ 的表达式了：

$$P(S)=\sum_{i=0}^\infty(\frac{tot-a[1]-sum[S]}{tot})^i\times\frac{a[1]}{tot}$$

直接把他当母函数写闭形式：

$$P(S)=\frac{1}{1-\frac{tot-a[1]-sum[S]}{tot}}\times\frac{a[1]}{tot}=\frac{a[1]}{a[1]+sum[S]}$$

发现就只有 $sum[S]$ 需要算一算了，发现这就是一个背包问题，很容易 $O(n^2)$ 解决啊。

再回去看一眼题目，$\sum a_i\leq 10^5$，也就是总容量是很小的，那么不难想到用生成函数优化背包。有 $n-1$ 个形如 $1-x^{a}$ 这样的函数我们要求他的卷积，那么直接分治就可以了。

注意分治的时候要**按容量对半分**，网上的题解大多是从中间分一半，我觉得这样是错的，~~但是我不是特别清楚怎么卡额~~。一定要这样才能说明复杂度是 $O(n\log^2 n)$

```c++
#include <cstdio>
#include <iostream>
using namespace std;
const int M = 200005;
const int MOD = 998244353;
#define int long long
int read()
{
	int x=0,f=1;char c;
	while((c=getchar())<'0' || c>'9') {if(c=='-') f=-1;}
	while(c>='0' && c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int n,ans,w[M],s[M],f[M];
namespace poly
{
	int len,A[M],B[M],rev[M];
	int qkpow(int a,int b)
	{
		int r=1;
		while(b>0)
		{
			if(b&1) r=r*a%MOD;
			a=a*a%MOD;
			b>>=1;
		}
		return r;
	}
	void NTT(int *a,int len,int op)
	{
		for(int i=0;i<len;i++)
		{
			rev[i]=(rev[i>>1]>>1)|((len/2)*(i&1));
			if(i<rev[i]) swap(a[i],a[rev[i]]);
		}
		for(int s=2;s<=len;s<<=1)
		{
			int t=s/2,w=(op==1)?qkpow(3,(MOD-1)/s):qkpow(3,MOD-1-(MOD-1)/s);
			for(int i=0;i<len;i+=s)
				for(int j=0,x=1;j<t;j++,x=x*w%MOD)
				{
					int fe=a[i+j],fo=a[i+j+t];
					a[i+j]=(fe+x*fo)%MOD;
					a[i+j+t]=((fe-x*fo)%MOD+MOD)%MOD;
				}
		}
		if(op==1) return ;
		int inv=qkpow(len,MOD-2);
		for(int i=0;i<len;i++) a[i]=a[i]*inv%MOD;
	}
	void work(int n,int m,int *a,int *b,int *c)
	{
		len=1;while(len<n+m) len<<=1;
		for(int i=0;i<len;i++) A[i]=B[i]=0;
		for(int i=0;i<n;i++) A[i]=a[i];
		for(int i=0;i<m;i++) B[i]=b[i];
		NTT(A,len,1);NTT(B,len,1);
		for(int i=0;i<len;i++) A[i]=A[i]*B[i]%MOD;
		NTT(A,len,-1);
		for(int i=0;i<n+m;i++)
			c[i]=A[i];
	}
}
void cdq(int *a,int l,int r)
{
	if(l==r)
	{
		a[0]=1;a[w[l]]=MOD-1;
		return ;
	}
	int mid=l;
	while(mid<r-1 && 2*(s[mid]-s[l-1])<s[r]-s[l-1]) mid++;
	int l1=s[mid]-s[l-1],l2=s[r]-s[mid];
	int f[2*l1]={},g[2*l2]={};
	cdq(f,l,mid);cdq(g,mid+1,r);
	poly::work(l1+1,l2+1,f,g,a);
}
signed main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		w[i]=read();
		s[i]=s[i-1]+w[i];
	}
	cdq(f,2,n);
	for(int i=0;i<=s[n];i++)
	{
		int tmp=w[1]*poly::qkpow(w[1]+i,MOD-2)%MOD;
		ans=(ans+tmp*f[i])%MOD;
	}
	printf("%lld\n",ans);
}
```



---

## 作者：nofind (赞：0)

## [题意](https://www.luogu.com.cn/problem/P5644)

发现原问题很麻烦，因为如果一个人死去，那么剩下的人的概率都会产生变化，即分母减去死掉的那个人的$w$。

考虑转化下问题：  
每个人概率保持不变，如果开枪打中的人已经死了就继续打，直到打中一个没死的人。由于活着的人的概率比并没有变化，因此这个问题和原问题是等价的。

考虑如何求解：  
让最后一个人恰好是$1$不好求，不妨先考虑容斥。设$P(S)$表示在$1$死后，$S$集合内的数才被杀死的方案数（不在$S$集合内的数也可能被杀）。  
$ans=\sum (-1)^{|S|}P(S)$

先考虑$P(S)$怎么求：  
设$tot=\sum\limits_{i=1}^na_i$，$sum(S)$表示$S$集合内的数的$w$之和。  
枚举打到$1$之前打了多少枪：$P(S)=\sum\limits_{i=0}^{+\infty}(\frac{tot-a_1-sum(S)}{tot})^i\frac{a_1}{tot}$  
又因$\sum\limits_{i=0}^{+\infty}x^i=\frac{1}{1-x}$  
原式$=\frac{tot-a_1-sum(S)}{tot}\frac{a_1}{tot}=\frac{a_1}{sum(S)+a_!}$  
代入原式：$ans=\sum(-1)^{|S|}\frac{a_!}{sum(S)+a_1}$  

因为$\sum w_i\leqslant 1e5$，所以考虑枚举$sum(S)$：  
$ans=\sum\limits_{i=0}^{tot}(\sum\limits_{sum(S)=i}(-1)^{|S|})\frac{a_!}{a_1+i}$，发现如果能求出$\frac{a_1}{a_1+i}$的系数即可解决问题。  

设$f_i=\sum\limits_{sum(S)=i}(-1)^{|S|}$，我们考虑如何求求出$f$：  
先考虑$\sum\limits_{sum(S)=i}1$，它即为$\prod\limits_{j=2}^n(1-x^{w_j})$的第$i$项系数。  
而$\sum\limits_{sum(S)=i}(-1)^{|S|}$即为$\prod\limits_{j=2}^{n}(1-x^{w_j})$的第$i$项系数。  
用分治套上$NTT$即可求出$f$，即先求出$[l,mid]$，再求出$[mid+1,r]$，最后这两个多项式再乘起来。

最后直接算即可。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=4e5+10;
const int mod=998244353;
const int G=3;
const int invG=332748118;
int n,now,ans;
int a[maxn],sum[maxn],pos[maxn],f[maxn];
int tmp[40][maxn];
inline int read()
{
    char c=getchar();int res=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
    return res*f;
}
inline int power(int x,int k)
{
    int res=1;
    while(k)
    {
        if(k&1)res=1ll*res*x%mod;
        x=1ll*x*x%mod;k>>=1;
    }
    return res;
}
inline void NTT(int* a,int op,int len)
{
    int lim=1,cnt=0;
    while(lim<len)lim<<=1,cnt++;
    for(int i=0;i<lim;i++)pos[i]=(pos[i>>1]>>1)|((i&1)<<(cnt-1));
    for(int i=0;i<lim;i++)if(i<pos[i])swap(a[i],a[pos[i]]);
    for(int l=1;l<lim;l<<=1)
    {
        int wn=power(op==1?G:invG,(mod-1)/(l<<1));
        for(int i=0;i<lim;i+=l<<1)
        {
            int w=1;
            for(int j=0;j<l;j++,w=1ll*w*wn%mod)
            {
                int x=a[i+j],y=1ll*w*a[i+l+j]%mod;
                a[i+j]=(x+y)%mod;a[i+l+j]=(x-y+mod)%mod;
            }
        }
    }
    if(op==1)return;
    int inv=power(lim,mod-2);
    for(int i=0;i<lim;i++)a[i]=1ll*a[i]*inv%mod;
}
void solve(int* a,int* f,int l,int r)
{
	if(l==r){f[0]=1;f[a[l]]=-1;return;}
	int mid=(l+r)>>1;
	int *tmp1=tmp[++now],*tmp2=tmp[++now];
	solve(a,tmp1,l,mid);solve(a,tmp2,mid+1,r);
	int lim=1;
	while(lim<=(sum[r]-sum[l-1]))lim<<=1;
	NTT(tmp1,1,lim);NTT(tmp2,1,lim);
	for(int i=0;i<lim;i++)f[i]=1ll*tmp1[i]*tmp2[i]%mod;
	NTT(f,-1,lim);
	for(int i=0;i<lim;i++)tmp1[i]=tmp2[i]=0;
	now-=2;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i]=read(),sum[i]=sum[i-1]+a[i];
	solve(a,f,2,n);
	//for(int i=0;i<=sum[n]-sum[1];i++)cerr<<f[i]<<endl;
	for(int i=0;i<=sum[n]-sum[1];i++)ans=(ans+1ll*f[i]*a[1]%mod*power(a[1]+i,mod-2)%mod)%mod;
	printf("%d",ans);
	return 0;
}
```


---


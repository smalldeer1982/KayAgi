# [NOI2000] 算符破译

## 题目描述

考古学发现，几千年前古梅文明时期的数学非常的发达，他们懂得多位数的加法和乘法，其表达式和运算规则等都与现在通常所用的方式完全相同（如整数是十进制，左边是高位，最高位不能为零；表达式为中缀运算，先乘后加等），唯一的区别是其符号的写法与现在不同。有充分的证据表明，古梅文明的数学文字一共有 $13$ 个符号，与 
 $0,1,2,3,4,5,6,7,8,9,+,*,=$ 这 $13$ 个数字和符号（称为现代算符）一一对应。为了便于标记，我们用 $13$ 个小写英文字母 $a,b,…m$ 代替这些符号（称为古梅算符）。但是，还没有人知道这些古梅算符和现代算符之间的具体对应关系。

在一个石壁上，考古学家发现了一组用古梅算符表示的等式，根据推断，每行有且仅有一个等号，等号左右两边为运算表达式（只含有数字和符号），并且等号两边的计算结果相等。

假设这组等式是成立的，请编程序破译古梅算符和现代算符之间的对应关系。


## 说明/提示

**样例说明**

在上例中，可能对应的现代表达式为 $ \{6*2=12，2=1+1 \}， \{6*4=24，4=2+2 \}，\{ 6*8=48，8=4+4 \} $。可见，能够确定的对应关系只有 $a$ 对应 $6$ ，$b$ 对应 $*$ ，$d$ 对应 $=$，$f$ 对应 $+$ ，应该输出；而 ${c,e}$ 虽然能够找到对应的现代算符使得等式成立，但没有唯一的对应关系，不能输出。其他古梅算符 ${g,h…m}$ 完全不能确定，也不能输出。


## 样例 #1

### 输入

```
2
abcdec
cdefe
```

### 输出

```
a6
b*
d=
f+
```

# 题解

## 作者：laocong (赞：11)

## P5758 [NOI2000] 算符破译

为什么这题没有题解？（疑惑

那就来交一个，祝NOIP2021 RP++

------------
### 写在前面

构造一组数据

Input:
```cpp
3
abcdefabcde
ghijkfghijk
lmakgflmakg
```
Output:
```cpp
f=
```
本题所提交的代码均在时限 $1s$ 内跑完，跑得最快的大约 $230s$，即本题解。

暂时想不出什么更高效的优化来解决这类数据。

------------
### 正文

观察到数据范围很小，显然搜索。

虽然黑题，其实难度不大。~~不要被题目颜色吓怕了啊~~

对于一个数学表达式，最重要的是两边相等，因此首先确定 "=" 的位置：

- 在表达式首尾出现过的排除；

- 在同一表达式中出现过至少两次的排除。

- 并不是在每个表达式中都出现的排除

我们筛选后枚举其余可能结果，可以大量减少搜索量。

为了尽早判断我们枚举的结果是否正确，我们把待确定的表达式按照涉及字符的数量排序，同时确定字符枚举的优先顺序。

例如两个表达式分别涉及 $4$ 个和 $9$ 个字符，我们先枚举第一个表达式所涉及的 $4$ 个字符，于是枚举 $4$ 次后便可以筛去大量不合法结果，以获得大量剪枝的效果。

然后可以快乐暴搜，枚举每一个字符所对应的数字或运算符。

注意表达式求值的一些细节问题。

当我们求得一合法解时，若当前位已有其他解，则该位记为多解。若当前位原先无解，则将该解加入。

特别注意：当有十二个字符可以确定时，那么最后一个也肯定可以确定，特判一下即可。

------------
Code  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,cnt,pos;
bool g[15][15],v[15];
string str[1005];
int ans[15],u[15],a[15],ed[1005],p[15];
//ans数组表示最终可确定字符所对应的数字，未确定则是 -1，多解则是 -2
//a数组表示搜索结果，ed数组表示当搜完多少个数字时可以验证一个等式 
//为了方便，本代码中用 10表示符号 +，11表示符号 *，12表示符号 = 
string l,r;
bool cmp(string x,string y) {
	int vis[30];
	int cnt1=0,cnt2=0,i;
	memset(vis,0,sizeof(vis)); 
	for (i=0;i<x.size();i++)  vis[x[i]-'a']++;
	for (i=0;i<26;i++) if (vis[i])  cnt1++;
	memset(vis,0,sizeof(vis)); 
	for (i=0;i<x.size();i++)  vis[y[i]-'a']++;
	for (i=0;i<26;i++) if (vis[i])  cnt2++;
	return cnt1<cnt2;
}
int work(string x) {	//处理字符串对应表达式的值
	int sum=0,last=1,single=0,i;
	bool mult=0;
	if (a[x[0]-'a']>9)  return -1;
	if (a[x[x.size()-1]-'a']>9)  return -1;
	for (i=0;i<x.size()-1;i++)
	  if (a[x[i]-'a']==0 && a[x[i+1]-'a']<10 && (i==0||a[x[i-1]-'a']>9))  return -1;
	for (i=0;i<x.size();i++) {
		if (a[x[i]-'a']==10) {
			if (mult)  sum+=last*single, mult=0, last=1;
			else  sum+=single;
			single=0;
			continue;
		}
		if (a[x[i]-'a']==11) {
			mult=1, last*=single, single=0;
			continue;
		}
		single=single*10+a[x[i]-'a'];
	}
	if (mult)  sum+=last*single;
	else  sum+=single;
	return sum;
}
void dfs(int k,int t) {
	int i,tmp1,tmp2;
	if (k==pos)  ++k;
	while (ed[t]==k-1 && t<=n) {
		l=""; r="";
		for (i=0;i<str[t].size();i++)
		  if (a[str[t][i]-'a']!=12)  l=l+str[t][i];
		  else  break;
		++i;
		for (;i<str[t].size();i++)
		  r=r+str[t][i];
		tmp1=work(l); tmp2=work(r);
		if (tmp1==-1 || tmp2==-1)  return;
		if (tmp1!=tmp2)  return;
		++t;
	}
	if (k>cnt && t>n) {
		if (cnt==12) {   //若有 12个可以确定，那么第 13个也可以 
			int s=0;
			for (i=0;i<13;i++)
			  if (a[i]!=-1)  s+=a[i];
			for (i=0;i<13;i++)
			  if (a[i]==-1)  a[i]=78-s;
		}
		for (i=0;i<13;i++)
		  if (ans[i]==-2 && cnt<12)  continue;
		  else if (ans[i]==-1)  ans[i]=a[i];
		  else if (ans[i]!=a[i])  ans[i]=-2;
		
		return;
	}
	for (int i=0;i<12;i++) {
		if (v[i] || !g[p[k]][i])  continue;
		a[p[k]]=i; v[i]=1;
		dfs(k+1,t);
		v[i]=0; a[p[k]]=-1;
	}
}
int main() {
	int i,j;
	scanf("%d",&n);
	for (i=1;i<=n;i++)
	  cin>>str[i];
	sort(str+1,str+n+1,cmp);
	for (i=0;i<13;i++)
	  for (j=0;j<13;j++)
	    g[i][j]=1;
	for (i=0;i<13;i++)
	  a[i]=-1;
	for (i=1;i<=n;i++) {  //判断什么字符不可以是 '=' 
		memset(u,0,sizeof(u));
		for (j=1;j<str[i].size()-1;j++)
		  u[str[i][j]-'a']++;
		for (j=0;j<13;j++)
		  if (u[j]!=1)  g[j][12]=0;
		g[str[i][0]-'a'][10]=g[str[i][0]-'a'][11]=g[str[i][0]-'a'][12]=0;
		j=str[i].size()-1;
		g[str[i][j]-'a'][10]=g[str[i][j]-'a'][11]=g[str[i][j]-'a'][12]=0;
	}
	memset(v,0,sizeof(v));
	for (i=1;i<=n;i++) {   //求解 ed数组 
		for (j=0;j<str[i].size();j++)
	    	if (!v[str[i][j]-'a'])  p[++cnt]=str[i][j]-'a', v[p[cnt]]=1;
	    ed[i]=cnt;
	}
	//一个小优化：使得在最短时间内确定更多等式的正确性，p数组记录字符搜索的优先级 
	if (cnt!=12) {
		for (i=1;i<=cnt;i++) ans[p[i]]=-1;
		for (i=0;i<13;i++) if (ans[i]==0)  ans[i]=-2;
	}
	else for (i=0;i<13;i++)  ans[i]=-1;
	memset(v,0,sizeof(v));
	for (i=1;i<=cnt;i++) 
		if (g[p[i]][12]!=0) {   //枚举等于号的位置，开始搜索 
			a[p[i]]=12;
			pos=i;
			dfs(1,1);
			for (j=0;j<13;j++)
			  a[j]=-1;
		}
	for (i=0;i<13;i++)
	  if (ans[i]==-1) { cout<<"noway\n"; return 0; }
	for (i=0;i<13;i++)
	  if (ans[i]>=0) {
	  	cout<<char(i+'a');
	  	if (ans[i]==12)  cout<<"=";
	  	else if (ans[i]==11)  cout<<"*";
	  	else if (ans[i]==10)  cout<<"+";
	  	else  cout<<ans[i];
	  	cout<<endl;
	  }
	return 0;
}
```

---

## 作者：Daniel1234 (赞：1)

# 思路

注：本题解未使用任何面向数据编程的方法。~~（最优解似乎都是面向数据编程的）~~

没啥好说的，直接暴搜。

非常重要的优化（借鉴了楼下的题解）：

1. `=/+/*/0` 这几个直接暴力枚举与那个数匹配，检查是否合法。

2. 可以先搜索匹配的顺序，最大化每个位置结尾可检查的字符串。

3. `inline`，这个 O2 似乎没有优化，可以加上。

4. 位运算优化。

# 代码


```
#include <string>
#include <bitset>
#include <vector>
#include <iostream>
// using namespace std;
// #define int long long
int n;
std::string s[1005];
char ch[] = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '+', '*', '='};
std::bitset<13>bit[13];
int vis[13];
int dui[13];
std::bitset<13>op;
int ok;
int b[1<<13], dp[1<<13];
int ord[13], ap[13];
int ans_ap[13], ans_ord[13], ans_rnk[13];
std::vector<int>f[13];
inline int lowbit(int x){
    return x & (-x);
}
inline bool check(std::string x){
    int len = x.size();
    char a = '=';
    char b = '+';
    char c = '*';
    char d = '0';
    if(x[0] == a || x[0] == b || x[0] == c || x[len - 1] == a || x[len - 1] == b || x[len - 1] == c)return 0;
    int num_a = 0;
    for(int i = 0; i < len; i++){
        num_a += (x[i] == a);
    }
    if(num_a != 1)return 0;
    for(int i = 1; i < len; i++){
        if(x[i] == a || x[i] == b || x[i] == c){
            if(x[i - 1] == a || x[i - 1] == b || x[i - 1] == c){
                return 0;
            }
        }
    }
    for(int i = 0; i < len - 1; i++){
        if(i == 0 || x[i - 1] == a || x[i - 1] == b || x[i - 1] == c){
            if(x[i] == d){
                if(x[i + 1] != a && x[i + 1] != b && x[i + 1] != c){
                    return 0;
                }
            }
        }
    }
    return 1;
}
inline int js(std::string x){
    int s = 1;
    int ans = 0;
    for(int i = 0; i < x.size(); i++){
        if('0' <= x[i] && x[i] <= '9'){
            int sum = 0;
            while(i + 1 < x.size() && '0' <= x[i + 1] && x[i + 1] <= '9'){
                sum = sum * 10 + x[i] - '0';
                i++;
            }
            sum = sum * 10 + x[i] - '0';
            s *= sum;
        }else if(x[i] == '+'){
            ans += s;
            s = 1;
        }
    }
    ans += s;
    return ans;
}
inline bool solve(std::string s){
    for(int i = 0; i < s.size(); ++i){
        s[i] = ch[dui[s[i] - 'a']];
    }
    if(!check(s))return 0;
    for(int i = 0; i < s.size() ;++i){
        if(s[i] == '='){
            return js(s.substr(0, i)) == js(s.substr(i + 1));
        }
    }
}
inline void dfs(int now){
    for(auto to : f[now - 1]){
        if(!solve(s[to]))return;
    }
    if(now == 13){
        ok = 1;
        for(int i = 0; i < 13; ++i)bit[i][dui[i]] = 1;
        return;
    }
    if(vis[ans_ord[now]]){
        dfs(now + 1);
        return;
    }
    for(int i = op._Find_first(); i != op.size(); i = op._Find_next(i)){
        dui[ans_ord[now]] = i;
        op[i] = 0;
        dfs(now + 1);
        op[i] = 1;
        if(ok)return;
    }
}
inline bool can(int x, int y){
    for(int i = 0; i < 13; ++i){
        op[i] = 1;
        dui[i] = 0;
        vis[i] = 0;
    }
    vis[x] = 1;
    dui[x] = y;
    op[y] = 0;
    ok = 0;
    dfs(0);
    return ok;
}
int he = 0;
inline void dfss(int now){
    for(int i = 0; i < now; ++i){
        if(ap[i] < ans_ap[i])return;
        if(ap[i] > ans_ap[i])break;
    }
    if(now == 13){
        for(int j = 0; j < 13; ++j){
            ans_ap[j] = ap[j];
            ans_ord[j] = ord[j];
        }
        return;
    }
    for(int i = op._Find_first(); i != op.size(); i = op._Find_next(i)){
        ord[now] = i;
        op[i] = 0;
        he ^= (1<<i);
        ap[now] = dp[he];

        dfss(now + 1);
        op[i] = 1;
        he ^= (1 << i);
    }
}
signed main(){
    std :: ios_base :: sync_with_stdio ( false ), std :: cin.tie ( nullptr ), std :: cout.tie ( nullptr ); 
    std::cin >> n;
    for(int i = 1; i <= n; ++i){
        std::cin >> s[i];
        int sum = 0;
        for(int j = 0; j < s[i].size(); ++j){
            if(s[i][j] < 'a' || s[i][j] > 'm'){
                std::cout << "noway" << std::endl;
                return 0;
            }
            sum |= 1<<(s[i][j] - 'a');
        }
        b[sum]++;
    }
    for(int i = 0; i < 13; i++)op[i] = 1;
    for(int i = 0; i < (1 << 13); ++i){
        for(int j = i; j; j = (j - 1) & i){
            dp[i] += b[j];
        }
    }
    dfss(0);
    for(int i = 1; i <= n; ++i){
        int mx = 0;
        for(int j = 0; j < s[i].size(); ++j){
            for(int k = 0; k < 13; k++){
                if(ans_ord[k] == s[i][j] - 'a'){
                    mx = std::max(mx, k);
                    break;
                }
            }
        }
        f[mx].emplace_back(i);
    }
    for(int i = 0; i < 13; ++i)ans_rnk[ans_ord[i]] = i;
    for(int i = 0; i < 13; ++i){
        for(int j = 12; j >= 0; --j){
            if(can(i, j))bit[i][j] = 1;
            if(bit[i].count() > 1)break;
        }
        if(bit[i].count() == 0){
            puts("noway");
            return 0;
        }
    }
    for(int i = 0; i < 13; ++i){
        if(bit[i].count() == 1){
            std::cout << char('a'+i) << ch[bit[i]._Find_first()] << std::endl;
        }
    }
    return 0;
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/aqapmwzy.png)

~~楼下的数据跑了 1.6s。~~

---


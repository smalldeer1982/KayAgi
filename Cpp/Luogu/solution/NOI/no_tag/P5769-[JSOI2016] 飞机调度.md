# [JSOI2016] 飞机调度

## 题目描述

JSOI 王国里有 $N$ 个机场，编号为 $1$ 到 $N$。从 $i$ 号机场到 $j$ 号机场需要飞行 $T_{i,j}$ 的时间。由于风向，地理位置和航空管制的因素，$T_{i,j}$  和 $T_{j,i}$ 并不一定相同。

此外，由于飞机降落之后需要例行维修和加油。当一架飞机降落 $k$ 号机场时，需要花费 $P_k$​​ 的维护时间才能再次起飞。

JS Airways 一共运营 $M$ 条航线，其中第 $i$ 条直飞航线需要在 $D_i$ 时刻从 $X_i$ 机场起飞，不经停，飞往 $Y_i$ 机场。

为了简化问题，我们假设 JS Airway 可以在 $0$ 时刻在任意机场布置任意多架加油维护完毕的飞机；为了减少飞机的使用数，我们允许 JS Airways 增开任意多条临时航线以满足飞机的调度需求。

JYY 想知道，理论上 JS Airways 最少需要多少架飞机才能完成所有这 $M$ 个航班。

## 说明/提示

**样例说明1**

在第一个样例中，JS Airways 可以在 $0$ 时刻在 $2$ 号机场安排一架飞机并执飞第 $2$ 条航线（$2→1$）。此外还需要在 $0$ 时刻在 $1$ 号机场安排一架飞机，这架飞机首先执飞第 $1$ 条航线（$1→2$），然后通过临时新增一条航线从 $2$ 号机场起飞飞往 $3$ 号机场，降落 $3$ 号机场之后执飞第 $3$ 条航线（$3→1$）。

**样例说明2**

在第二个样例中，执行完第 $1$ 条航线的飞机无法赶上第 $3$ 条航线的起飞时间，因此 JS Airways 必须使用 $3$ 架不同的飞机才能完成所有的航班。

------------

**数据范围**

对于 $30\%$ 的数据，满足 $N,M \le 10$；

对于 $60\%$ 的数据，满足 $N,M \le 100$；

对于全部数据，满足 $1 \le N,M \le 500$，$0 \le P_i,T_{i,j} \le 10^6$，$1 \le D_i \le 10^6$。

## 样例 #1

### 输入

```
3 3
100 1 1
0 1 1
1 0 5
2 1 0
1 2 1
2 1 1
3 1 9
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3 3
100 1 1
0 1 1
1 0 5
2 1 0
1 2 1
2 1 1
3 1 8
```

### 输出

```
3```

# 题解

## 作者：StudyingFather (赞：10)

这题的建模思路有点神仙...

如果一架飞机在飞完第 $i$ 条航线后，能飞第 $j$ 条航线，就从 $i$ 向 $j$ 连一条有向边。

容易看出这个图是一张 DAG，我们的目标是用尽可能少的飞机飞完所有航线。

这是一个 [DAG 上的最小路径覆盖](https://studyingfather.com/archives/2723) 的模型。

现在问题来了，如何判断飞完第 $i$ 条航线后，是否能飞第 $j$ 条航线呢？

先预处理从 $i$ 机场出发，到 $j$ 机场且具备起飞条件的最短时间 $f(i,j)$。这个可以跑一遍 Floyd 实现。

设第 $i$ 条航线的起点为 $x_i$，终点为 $y_i$，起飞时间为 $d_i$，则同一架飞机飞完第 $i$ 条航线后能飞第 $j$ 条航线，当且仅当 $d_i+t(x_i,y_i)+p_{y_i}+f(y_i,x_j)\leq d_j$。

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#define INF 0x3f3f3f3f
using namespace std;
struct graph
{
 struct edge
 {
  int v,w,next;
 }e[1000005];
 int s,t,cnt;
 int head[1005],cur[1005],dis[1005],vis[1005];
 void addedge(int u,int v,int w)
 {
  e[++cnt].v=v;
  e[cnt].w=w;
  e[cnt].next=head[u];
  head[u]=cnt;
 }
 void init(int S,int T)
 {
  s=S,t=T;
  memset(head,0,sizeof(head));
  cnt=1;
 }
 bool bfs()
 {
  queue<int> q;
  memset(dis,INF,sizeof(dis));
  memcpy(cur,head,sizeof(cur));
  dis[s]=0,vis[s]=1;
  q.push(s);
  while(!q.empty())
  {
   int u=q.front();
   q.pop();
   vis[u]=0;
   for(int i=head[u];i;i=e[i].next)
   {
    int v=e[i].v;
    if(e[i].w&&dis[v]>dis[u]+1)
    {
     dis[v]=dis[u]+1;
     if(!vis[v])q.push(v),vis[v]=1;
    }
   }
  }
  return dis[t]!=INF;
 }
 int dfs(int u,int flow)
 {
  if(u==t)return flow;
  int used=0;
  for(int i=cur[u];i;i=e[i].next)
  {
   int v=e[i].v;
   cur[u]=i;
   if(e[i].w&&dis[v]==dis[u]+1)
   {
    int f=dfs(v,min(flow-used,e[i].w));
    e[i].w-=f;
    e[i^1].w+=f;
    used+=f;
    if(used==flow)break;
   }
  }
  return used;
 }
 int maxflow()
 {
  int ans=0;
  while(bfs())
   ans+=dfs(s,INF);
  return ans;
 }
}g;
struct line
{
 int x,y,d;
}a[505];
int p[505],T[505][505],f[505][505];
int main()
{
 int n,m;
 cin>>n>>m;
 int s=2*m+1,t=2*m+2;
 g.init(s,t);
 for(int i=1;i<=n;i++)
  cin>>p[i];
 for(int i=1;i<=n;i++)
  for(int j=1;j<=n;j++)
   cin>>T[i][j];
 for(int i=1;i<=n;i++)
  for(int j=1;j<=n;j++)
   if(i!=j)f[i][j]=T[i][j]+p[j];
 for(int k=1;k<=n;k++)
  for(int i=1;i<=n;i++)
   for(int j=1;j<=n;j++)
    f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
 for(int i=1;i<=m;i++)
 {
  cin>>a[i].x>>a[i].y>>a[i].d;
  g.addedge(s,i,1),g.addedge(i,s,0);
  g.addedge(i+m,t,1),g.addedge(t,i+m,0);
 }
 for(int i=1;i<=m;i++)
  for(int j=1;j<=m;j++)
  {
   int u=a[i].x,v=a[i].y,w=a[j].x;
   if(a[i].d+T[u][v]+p[v]+f[v][w]<=a[j].d)
    g.addedge(i,j+m,1),g.addedge(j+m,i,0);
  }
 cout<<m-g.maxflow()<<endl;
 return 0;
}
```


---

## 作者：lzyqwq (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P5769)


神仙建模题。我们如果把飞机看成路径，航班看成节点，就是一个 `DAG` 最小不相交路径覆盖的问题（下面会解释）。

关键在于如何建边。 

考虑每一条边的意义。若 $u$ 和 $v$ 之间有连边，说明一条路径覆盖了 $u$ 就一定可以覆盖 $v$。在这个问题中，就是一架飞机飞了 $u$ 航班，就一定可以飞 $v$ 航班。

显然，飞机每次飞行可以为了调度而不执行航班任务。

那么就很明确了。只需要知道一架飞机在飞完 $u$ 航班后能不能在 $v$ 航班的起飞时间之前到达 $v$ 航班的起点机场。

我们用 $f_{i,j}$ 表示从机场 $i$ 出发到从机场 $j$ 出发所用的最短时间。注意，是**出发**而不是到达。

首先，$f_{i,i}=0$，因为这个状态描述的是发生相同的事情之间的时间，显然，相同事情时间相同，时间差为 $0$。

其次，$f_{i,j}=t_{i,j}+p_j\,(i\ne j)$。这是初始状态。因为 $t_{i,j}$ 是从 $i$ 起飞到 $j$ 降落所需的时间，想要再次起飞，必须经过维修。因此最短时间肯定是落地之后马上维修，维修完马上起飞，这样几个动作之间的衔接不花费时间，只需要加上维修的时间就好。

然后就可以 `Floyd` 处理任意从两机场出发之间的最短时间。但是这样加了一个维修的时间，难免让人感到怪异。其实是可以的。

比如 $f_{i,j}=f_{i,k}+f_{k,j}\,(i\ne j\ne k)$。其中 $f_{i,k}$ 表示飞机从 $i$ 起飞到 $k$ 降落，然后在 $k$ 维修；$f_{k,j}$ 表示飞机从 $k$ 起飞到 $j$ 降落，然后在 $j$ 维修。这样一来，$f_{i,j}$ 描述的就是飞机从 $i$ 起飞到 $k$ 降落，在 $k$ 维修好后从 $k$ 起飞到 $j$ 降落，再在 $j$ 维修好后立马起飞。显然是符合题目要求的飞行流程的。

对于两个航班 $a$ 和 $b$，用 $u$ 表示起飞机场，$v$ 表示降落机场，$w$ 表示起飞时间。则必须满足 $a_w+t_{a_u,a_v}+p_{a_v}+f_{a_v,b_u}\le b_w$ 时，两个航班之间可以连 $a\rightarrow b$ 的边（从 $a$ 航班出发开始飞，到达 $b$ 航班结束）。 上面的式子的意思是：从 $a_u$ 起飞到 $a_v$ 降落然后维修，再从 $a_v$ 起飞到 $b_u$ 降落然后维修（维修的时间在 $f$ 里都算了），最终得到最早的可以起飞的时间。即，飞机能否在航班 $b$ 起飞之前到达 $b_u$ 并做好维修工作。

由于只可能是起飞早的航班向起飞晚的航班建边，所以我们构成了一个 `DAG`，至此转化成 `DAG` 最小不相交路径覆盖的模型（不相交是因为一个航班不能由多架飞机去飞，航班飞完了就没有这个航班了，不能让飞机在机场为了一个完成的航班空等）。

对于 `DAG` 最小不相交路径覆盖问题，我们将 `DAG` 中的每个节点 $u$ 拆成 $u_1$ 和 $u_2$，表示出发和到达 $u$。对于 `DAG` 中所有的边 $u\rightarrow v$ 在模型中连 $u_1\rightarrow v_2$，表示一条路径从 $u$ 出发就一定可以到达 $v$，从而覆盖 $u,v$ 两个节点；即一架飞机飞完 $u$ 航班一定可以飞 $v$ 航班，从而执行完两个航班任务。

此时，我们已经将问题完全转化成了模型，直接用公式计算：

`DAG` 最小不相交路径覆盖 = 原图节点数 - 拆点图最大匹配。

为什么呢？因为是不相交的路径，所以一个入点只能与一个出点匹配，转化成二分图匹配问题。又因为增加一条匹配 $(u_1,v_2)$，就可以将以 $u$ 为结尾的路径和以 $v$ 为开头的两条路径连成一条路径，从而使答案减一。因此任意一个路径覆盖数都可以用“原图点数 - 任意拆点图匹配数”来表示。由于要使路径覆盖数最小，所以减去的要尽量大（因为原图点数是定值），因此减去的匹配数要最大，即减去最大匹配。

我们将源点 $S$ 向所有 $u_1$ 连容量为 $1$ 的边，将所有 $u_2$ 向汇点连容量为 $1$ 的边，将拆点图中的所有 $u_1\rightarrow v_2$ 的边的容量设为 $1$。这样跑出的最大流即为最大匹配。因为在网络图中每一条流都相当于一条匹配：匹配问题中，同一个点只能根一个点匹配对答案产生贡献；然而最大流中，若同一个点（表示到达的节点）有其它多个节点流入的流量，由于自己到汇点 $T$ 的边容量为 $1$，所以也只会将一个点流入的流量流到汇点，产生贡献。因此最大流也是“同一个点只能根一个点对答案产生贡献”，等价于最大匹配。

于是我们用最大流求出最大匹配后，用原图点数（航班数）减去最大匹配，就是最小不相交路径覆盖——覆盖所有节点的最小不相交路径数，即为飞完所有航班的最少飞机数，为题所求，输出即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1005, M = 6e5;
int n, m, p[N], t[N][N], f[N][N], cnt = 1, q[M], l, r, d[N], hd[N], T, ans, now[N];
struct flight {
	int u, v, w;
}a[N];
struct edge {
	int v, w, nxt;
}e[M];
inline void add(int u, int v, int w) {
	e[++cnt] = edge{v, w, hd[u]};
	hd[u] = cnt;
}
inline bool bfs() {
	for (int i = 0; i <= T; ++i) {
		now[i] = hd[i];
		d[i] = 0;
	}
	d[q[l = r = 1] = 0] = 1;
	while (l <= r) {
		int x = q[l++];
		for (int i = hd[x]; i; i = e[i].nxt) {
			if (e[i].w && !d[e[i].v]) {
				d[q[++r] = e[i].v] = d[x] + 1;
				if (e[i].v == T) {
					return 1;
				}
			}
		}
	}
	return 0;
}
int dfs(int x, int flow) {
	if (x == T) {
		return flow;
	}
	int s = 0;
	for (int i = now[x]; i; i = e[i].nxt) {
		if (e[i].w && d[e[i].v] == d[x] + 1) {
			int k = dfs(e[i].v, min(flow - s, e[i].w));
			e[i].w -= k;
			e[i ^ 1].w += k;
			s += k;
			if (s == flow) {
				now[x] = i;
				return s;
			}
		}
	}
	d[x] = now[x] = 0;
	return s;
}
signed main(/*芦语晨我喜欢你*/) {
	scanf("%lld%lld", &n, &m);
	T = (m << 1) + 1;
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", p + i);
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			scanf("%lld", t[i] + j);
			if (i ^ j) {
				f[i][j] = p[j] + t[i][j];
			} else {
				f[i][j] = 0;
			}
		}
	}
	for (int i = 1; i <= m; ++i) {
		scanf("%lld%lld%lld", &a[i].u, &a[i].v, &a[i].w);
		add(0, i, 1);
		add(i, 0, 0);
		add(i + m, T, 1);
		add(T, i + m, 0);
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			for (int k = 1; k <= n; ++k) {
				f[j][k] = min(f[j][k], f[j][i] + f[i][k]);
			}
		}
	}
	for (int i = 1; i <= m; ++i) {
		for (int j = 1; j <= m; ++j) {
			if (i ^ j && a[i].w + t[a[i].u][a[i].v] + p[a[i].v] + f[a[i].v][a[j].u] <= a[j].w) {//满足这个条件的就是原图中的一条边，对其拆点建模即可
				add(i, j + m, 1);
				add(j + m, i, 0);
			}
		}
	}
	while (bfs()) {
		ans += dfs(0, 1e18);
	}
	printf("%lld\n", m - ans);
} 
```


---

## 作者：云浅知处 (赞：2)

建议降紫

我们发现，要想用的飞机数少一点，就要让某些飞机在飞完一个航线 $X_i\to Y_i$ 之后，「马不停蹄」地赶去某个 $X_j$，再飞一次 $X_j\to Y_j$。

飞完 $X_j\to Y_j$ 之后这个飞机也可能会继续去飞别的航线，发现如果我们把所有「能够在飞完第 $i$ 条航线之后及时赶过去飞 $j$ 航线」的 $(i,j)$ 连边，那么会得到一张 DAG，一个飞机相当于 DAG 上的一条路径，我们要求的就是 DAG 的最小路径覆盖。

这里需要说明一点，许多题解没有提到，在实际的方案中，某条航线完全有可能被多条飞机经过，但为什么我们仍然只需要求最小不交路径覆盖呢？回忆最小可交路径覆盖的做法，发现是先把图做传递闭包，在得到的新图上做最小不交路径覆盖。而在本题中，走完 $i$ 能赶到 $j$，与走完 $j$ 能赶到 $k$，实际上能够推出走完 $i$ 能赶到 $k$。因此，该图的传递闭包就是它本身，最小不交路径覆盖等于最小可交路径覆盖。

某个飞机能够在飞完 $X_i\to Y_i$ 之后及时赶到 $X_j$ 的充要条件是：$D_i+w(X_i,Y_i)+\text{dist}(Y_i,X_j)\le D_j$，其中 $\text{dist}(u,v)$ 表示 $u\to v$ 的最短路，且需要计入路径上所有点（包括 $u,v$）的加油代价。

使用 Floyd 算法求解最短路，接下来求解 DAG 的最小路径覆盖即可。

时间复杂度 $O(n^3)$。

>DAG 的最小路径覆盖怎么做？建一张新图，对 DAG 中每条边 $(u,v)$，我们在新图中连边 $(u,v+n)$。显然新图是一张二分图，答案即为边数减去二分图最大匹配的值。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int mod=1e9+7;
int ksm(int x,int y,int p=mod){
	int ans=1;
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
int randint(int l,int r){return rand()*rand()%(r-l+1)+l;}

namespace maxflow{
	const int N=1e5+5;
	const int M=5e5+5;
	int tot=1,head[N],nxt[M],edge[M],ver[M];
	void adde(int x,int y,int z){
//		cout<<x<<" "<<y<<" "<<z<<endl;
		nxt[++tot]=head[x],head[x]=tot,edge[tot]=z,ver[tot]=y;
		nxt[++tot]=head[y],head[y]=tot,edge[tot]=0,ver[tot]=x;
	}
	
	queue<int>q;
	int n,m,d[N],s=0,t=N-1,cur[N];
	bool bfs(){
		memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(cur));
		while(q.size())q.pop();
		d[s]=1,q.push(s);while(q.size()){
			int x=q.front();q.pop();
			for(int i=head[x];i;i=nxt[i]){
				int y=ver[i];if(d[y]||(!edge[i]))continue;
				d[y]=d[x]+1,q.push(y);if(y==t)return 1;
			}
		}
		return 0;
	}
	int dinic(int x,int flow){
		if(x==t)return flow;
		int rest=flow;
		for(int i=cur[x];i&&rest;i=nxt[i]){
			int y=ver[i];cur[x]=i;
			if((!edge[i])||(d[y]!=d[x]+1))continue;
			int k=dinic(y,min(rest,edge[i]));
			edge[i]-=k,edge[i^1]+=k,rest-=k;
		}
		return flow-rest;
	}
	const int INF=1e14;
	int Ans(){
		int ans=0,flow=0;
		while(bfs()){
			while(flow=dinic(s,INF))ans+=flow;
		}
		return ans;
	}
};

using maxflow::adde;
using maxflow::s;
using maxflow::t;
const int N=505;
int f[N][N],n,p[N],m,st[N],ed[N],bg[N],a[N][N];

signed main(void){

#ifdef YunQian
	freopen("in.in","r",stdin);
//	freopen("out.out","w",stdout);
#endif

	n=read(),m=read();
	for(int i=1;i<=n;i++)p[i]=read();
	
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)f[i][j]=a[i][j]=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j)f[i][j]+=p[i];
	for(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	
	for(int i=1;i<=m;i++)st[i]=read(),ed[i]=read(),bg[i]=read();
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			if(i==j)continue;
			if(f[ed[i]][st[j]]+bg[i]+a[st[i]][ed[i]]+p[st[j]]<=bg[j])adde(i,j+m,1);
		}
	}
	for(int i=1;i<=m;i++)adde(s,i,1),adde(i+m,t,1);
	cout<<m-maxflow::Ans()<<endl;

	return 0;
}

```

---

## 作者：CmsMartin (赞：2)

[更好的阅读体验](http://www.cmsblog.top/archives/jsoi2016-fei-ji-diao-du)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P5769)

## 思路

这道题目还是挺板的一道网络流，~~可是不知道为什么 LOJ 上的标签是最短路~~。

首先 **最少需要多少架飞机** 可以转化为 **每架飞机尽量用更多的次数**。

所以问题转化为一架飞机能够先飞路线 $i$，再飞路线 $j$ 的条件。

定义 $G_{i,j}$ 表示机场 $i$ 到机场 $j$ 并且在机场 $j$ 维修完毕的最短路径长度。

然而这个条件是显然的，需要满足从 $X_i$ 起飞到 $Y_i$ 再在 $Y_i$ 修理 $P_{Y_i}$ 的时间最后再走 **$Y_i$ 到 $X_j$ 的最短路** 的总时间要早于 $D_j$，这样两个机场就是可以由一架飞机走的，形式化的就是如下不等式：

$$D_i + T_{X_i,Y_i} + P_{Y_i} + G_{Y_i, X_j} \le D_j$$

对于每一个航线我们将其拆分成左航线和右航线，然后我们可以开始建一张二分图。

1. 将所有左航线和源点连接，容量为 $1$；

2. 将所有右航线和汇点连接，容量为 $1$；

3. 假设一架飞机可以飞路线 $i$ 和路线 $j$，那么可以将 $i$ 对应的左航线和 $j$ 对应的右航线连接，容量为 $\infty$。

现在我们使用最少的飞机来飞这几条航线就相当于使用最少的路径来覆盖这一张二分图。

结论：答案为 $M-\text{二分图最大匹配} = M - \text{Max Flow}$。

简证：

这是一个经典模型：最小路径覆盖。

首先，每选择一条边相当于合并两个路径，那么我们需要尽可能的多选边，选的边数最多为 二分图最大匹配。那么如果不合并的话每一个航线都需要自己独立跑，那么答案为 $M$，所以现在的答案为 $M-\text{二分图最大匹配} = M - \text{Max Flow}$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 500010;

struct _ {
    int To, Next, Value;
} G[MAXN << 1];
int Head[MAXN], Cnt = 1;

void _add(int u, int v, int w) {
    G[++Cnt] = {v, Head[u], w};
    Head[u] = Cnt;
}

void Add(int u, int v, int w) {
    _add(u, v, w);
    _add(v, u, 0);
}

int Depth[MAXN], Hash[MAXN], N, M, S, T;

void BFS() {
    memset(Depth, -1, sizeof Depth);
    memset(Hash, 0, sizeof Hash);
    queue<int> q;
    q.push(T);
    Depth[T] = 0;
    Hash[0]++;

    while (q.size()) {
        int u = q.front();
        q.pop();
        for (int i = Head[u]; i; i = G[i].Next) {
            int v = G[i].To;
            if (Depth[v] != -1) continue;
            Depth[v] = Depth[u] + 1;
            Hash[Depth[v]]++;
            q.push(v);
        }
    }
}

int Max_Flow;

int DFS(int u, int flow) {
    if (u == T) {
        Max_Flow += flow;
        return flow;
    }
    int used = 0;
    for (int i = Head[u]; i; i = G[i].Next) {
        int v = G[i].To;
        if (G[i].Value && Depth[v] + 1 == Depth[u]) {
            int Min = DFS(v, min(G[i].Value, flow - used));
            if (Min) {
                G[i].Value -= Min;
                G[i ^ 1].Value += Min;
                used += Min;
            }
            if (used == flow) {
                return used;
            }
        }
    }

    Hash[Depth[u]]--;
    if (Hash[Depth[u]] == 0) Depth[S] = MAXN - 5;
    Depth[u]++;
    Hash[Depth[u]]++;
    return used;
}

int ISAP() {
    Max_Flow = 0;
    BFS();
    while (Depth[S] < MAXN - 5) DFS(S, 0x3f3f3f3f);
    return Max_Flow;
}

int Graph[510][510], X[510], Y[510], D[510], P[510], Cost[510][510];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> N >> M;
    S = M * 2 + 1, T = M * 2 + 2;

    for (int i = 1; i <= N; i++) {
        cin >> P[i];
    }

    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            cin >> Graph[i][j];
            Cost[i][j] = Graph[i][j];
        }
    }

    for (int i = 1; i <= M; i++) {
        cin >> X[i] >> Y[i] >> D[i];
    }

    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            if (i == j) continue;
            Graph[i][j] = Cost[i][j] + P[j];
        }
    }

    for (int k = 1; k <= N; k++) {
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                Graph[i][j] = min(Graph[i][j], Graph[i][k] + Graph[k][j]);
            }
        }
    }

    for (int i = 1; i <= M; i++) {
        Add(S, i, 1);
    }
    for (int i = 1; i <= M; i++) {
        Add(i + M, T, 1);
    }
    for (int i = 1; i <= M; i++) {
        for (int j = 1; j <= M; j++) {
            if (D[i] + Cost[X[i]][Y[i]] + P[Y[i]] + Graph[Y[i]][X[j]] <= D[j]) {
                Add(i, j + M, 0x3f3f3f3f);
            }
        }
    }

    cout << M - ISAP() << endl;
    return 0;
}
```

---

## 作者：kouylan (赞：1)

## 题解 P5769 【[JSOI2016]飞机调度】

### 【[题意](https://www.luogu.com.cn/problem/P5769)】

有 $n$ 条航线，问最少要用多少飞机才能飞完？

### 【分析】

**感谢** [ET2006的博客](https://www.luogu.com.cn/blog/et2006/wang-lao-liu-hao-ti-ti-xie-hui-zong) **orz%%%**

我们要尽可能的让同一班飞机连续的飞若干航线。

我们考虑，如果一架飞机要飞航线 $i$ 和 $j$，需要满足哪些条件？假设航线 $i$ 在 $j$ 前，我们需要让飞机飞完 $i$ 后再到 $j$ 的出发机场的时间，早于 $d_j$。

这个时候，我们不妨设 $g_{i,j}$ 表示从机场 $i$ 到 $j$ 的最少花费。初始化时，$g_{i,j} = t_{i,j}+p_j$，特殊的，$g_{i,i} = 0$。

我们在来看上文的条件，如果

$$d_i+t_{x_i,y_i}+p_{y_i}+g_{y_i,x_j} \leq d_j$$

我们就可以在航线 $i$ 和 $j$ 之间连一条边，表示一架飞机可以飞完航线 $i$ 和 $j$。这样，每一架飞机的航线，就是这张图里的一条路径。我们要用最少的飞机，相当于用最少的路径覆盖这一张图。

**所以这道题就被我们转化成了最小路径覆盖。**

最小路径覆盖的建模方法：

1. 把每个点拆成入点和出点，在建立虚拟源汇，这张图就变成了一张二分图；

2. 对于原图的一条边 $x\rightarrow y$，从 $x$ 的入点连向 $y$ 的出点；

3. 跑二分图最大匹配；

4. 答案是原图点数减去最大匹配。

~~在此就不证明了。~~

下面是 AC 代码

```cpp
/*
luogu P5769
*/
#include <bits/stdc++.h>
using namespace std;

const int INF = 0x7f7f7f7f;

int n,m,s,t,g[505][505],p[505],d[505],x[505],y[505],tim[505][505];
int mxf=0;
int ee=1,h[500005],nex[500005<<1],to[500005<<1],val[500005<<1];
int dep[500005],gap[500005];

void addedge(int x,int y,int z)
{
	nex[++ee] = h[x];
	to[ee] = y;
	val[ee] = z;
	h[x] = ee;
}

void bfs()
{
	queue<int> q;
	q.push(t);
	dep[t] = 1;
	gap[1] = 1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=h[x];i;i=nex[i])
			if(!dep[to[i]])
			{
				dep[to[i]] = dep[x]+1;
				gap[dep[to[i]]]++;
				q.push(to[i]);
			}
	}
}

int dfs(int x,int flow)
{
	if(x==t)
	{
		mxf += flow;
		return flow;
	}
	int used=0;
	for(int i=h[x];i;i=nex[i])
		if(dep[to[i]]==dep[x]-1 && val[i]>0)
		{
			int d=dfs(to[i],min(val[i],flow-used));
			if(d)
			{
				val[i] -= d;
				val[i^1] += d;
				used += d;
			}
			if(used==flow)
				return used;
		}
	gap[dep[x]]--;
	if(gap[dep[x]]==0)
		dep[s] = m*2+1;
	dep[x]++;
	gap[dep[x]]++;
	return used;
}

void isap()
{
	mxf = 0;
	bfs();
	while(dep[s]<=m*2)
		dfs(s,INF);
}

void floyd()
{
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				if(g[i][k]+g[k][j]<g[i][j])
					g[i][j] = g[i][k]+g[k][j];
}

int main()
{
	cin>>n>>m;
	s = 0, t = m*2+1;
	for(int i=1;i<=n;cin>>p[i++]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>tim[i][j];
	for(int i=1;i<=m;cin>>x[i]>>y[i]>>d[i],i++);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(i!=j)
				g[i][j] = tim[i][j]+p[j];
	floyd();
	for(int i=1;i<=m;i++)
		addedge(s,i,1), addedge(i,s,0);
	for(int i=1;i<=m;i++)
		addedge(i+m,t,1), addedge(t,i+m,0);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			if(d[i]+tim[x[i]][y[i]]+p[y[i]]+g[y[i]][x[j]]<=d[j])
				addedge(i,j+m,INF), addedge(j+m,i,0);
	isap();
	cout<<m-mxf<<endl;
	
	return 0;
}
```

祝大家 AC 愉快！

---

## 作者：xtx1092515503 (赞：1)

~~我爱网络流~~

刚看到这道题一点思路也没有，后来想一想就想明白了。

首先，为了找出每个航班之间能否转移的关系，我们可以建立一个$dis_{i,j}$数组，表示从点$i$到点$j$并能够再次起飞的最短时间。

由题意，我们可以初始$dis_{i,j}=T_{i,j}+P_j$，表示一开始的航班都是直飞的。另外，如果$i=j$，则必有$dis_{i,j}=0$。

然后在$dis$上跑$floyd$。这样就完成了$dis$数组的求解。

如果在一个航班结束后，按照最短路径（即$dis$），能够按时赶上另一个航班，则它们可以转移。

设航班$i$是从点$x_i$到点$y_i$，时间是从$s_i$到$t_i$，则如果有：

$t_i+dis_{y_i,x_j}\leq s_j$，它们就可以转移。

**另，$t_i=s_i+T_{x_i,y_i}+P_{y_i}$，而不是$t_i=s_i+dis_{x_i,y_i}$，因为航班是直飞，不是按照最短路径飞！**~~我为了这个一直WA30。~~

在转移关系建好之后，我们来观察一下现在的状况：

我们有$m$条航班，航班之间互有有向的转移关系，但转移关系保证无环（因为按时间转移）。

这让人想到了什么？

[最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)！！！

~~不会的人，推一下我的[网络流blog](https://www.luogu.com.cn/blog/Troverld/wang-lao-liu-xue-xi-bi-ji)。第一题就是它。~~

代码：
```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
int n,m,fix[510],dis[510][510],dd[510][510];
struct AirLine{
	int u,v,s,t;
}a[510];
int head[1010],cur[1010],dep[1010],cnt,S,T,res;
struct node{
	int to,next,val;
}edge[4010000];
void ae(int u,int v,int w){
	edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++;
	edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=0,head[v]=cnt++;
}
queue<int>q;
inline bool bfs(){
	memset(dep,0,sizeof(dep)),q.push(S),dep[S]=1;
	while(!q.empty()){
		register int x=q.front();q.pop();
		for(register int i=cur[x]=head[x];i!=-1;i=edge[i].next)if(edge[i].val&&!dep[edge[i].to])dep[edge[i].to]=dep[x]+1,q.push(edge[i].to);
	}
	return dep[T]>0;
}
bool reach;
inline int dfs(int x,int flow){
	if(x==T){
		res+=flow;
		reach=true;
		return flow;
	}
	int used=0;
	for(register int &i=cur[x];i!=-1;i=edge[i].next){
		if(!edge[i].val||dep[edge[i].to]!=dep[x]+1)continue;
		register int ff=dfs(edge[i].to,min(edge[i].val,flow-used));
		if(ff){
			edge[i].val-=ff;
			edge[i^1].val+=ff;
			used+=ff;
			if(used==flow)break;
		}
	}
	return used;
}
inline void Dinic(){
	while(bfs()){
		reach=true;
		while(reach)reach=false,dfs(S,0x3f3f3f3f);
	}	
}
int main(){
	scanf("%d%d",&n,&m),memset(head,-1,sizeof(head)),S=2*m+1,T=2*m+2;
	for(int i=1;i<=n;i++)scanf("%d",&fix[i]);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)scanf("%d",&dd[i][j]),dis[i][j]=(i==j?0:dd[i][j]+fix[j]);
	for(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	for(int i=1;i<=m;i++)scanf("%d%d%d",&a[i].u,&a[i].v,&a[i].s),a[i].t=a[i].s+dd[a[i].u][a[i].v]+fix[a[i].v];
	for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)if(a[i].t+dis[a[i].v][a[j].u]<=a[j].s)ae(i,j+m,1);
	for(int i=1;i<=m;i++)ae(S,i,1),ae(i+m,T,1);
	Dinic();
	printf("%d\n",m-res);
	return 0;
}
```


---

## 作者：FZzzz (赞：1)

~~机房复习最短路的时候在作业里看到这题。~~

~~网络流也就是 dfs 和 bfs 嘛。~~

------------
首先我们可以先把飞机飞完哪些线可以接着去飞另一条线处理出来，这个要用到全源最短路。

然后建一个图（程序实现没必要），每个节点代表原来的一个航线。如果飞机飞完一个航线可以去飞另一个，就连一条边。

这个图显然是一个 DAG，因为时间单向流逝。

然后我们发现，如果同一架飞机连飞了几个航线，那么这些航线在这个图上一定反映为一条路径。我们需要让所有点都被飞到，这样就变成一个 DAG 路径覆盖问题。

下面说路径覆盖的解法：

把每个点 $u$ 拆成两个点 $u_1$ 和 $u_2$，对于原图的一条边 $<u,v>$，加一条边 $(u_1,v_2)$。这样得到一个二分图，跑它的最大匹配，然后原图的最小路径覆盖就是原图点数减去这个图的最大匹配数。

下面给出口胡的证明，感性理解即可：

最开始所有点是单独的一条路径，然后我们把一条匹配边 $(u_1,v_2)$ 看成把 $u$ 和 $v$ 所在的路径连成一条路径。这样每一个匹配都对应原图的一个路径覆盖，易证它们相加等于总点数。最大匹配就对应最小覆盖。

程序实现上，我们可以直接建这个二分图，而没必要建那个 DAG。

~~奇丑无比的~~代码：
```cpp
#include<algorithm>
#include<queue>
#include<vector>
#include<cstring>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
    int x=0;
    bool f=0;
    char c=getchar();
    while(!isdigit(c)&&c!='-') c=getchar();
    if(c=='-'){
        f=1;
        c=getchar();
    }
    while(isdigit(c)){
        x=x*10+c-'0';
        c=getchar();
    }
    return f?-x:x;
}
const int maxn=500+5;
int n,m,x[maxn],y[maxn],dd[maxn],t[maxn][maxn],p[maxn];
int dis[maxn][maxn];
void floyd(){
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) for(int k=1;k<=n;k++)
	    dis[j][k]=min(dis[j][k],dis[j][i]+dis[i][k]);
}
struct edge{
	int from,to,cap,flow;
	edge(int u,int v,int w):from(u),to(v),cap(w),flow(0){}
};
vector<edge> edges;
vector<int> g[maxn*2];
void add_edge(int u,int v,int w){
	g[u].push_back(edges.size());
	edges.push_back(edge(u,v,w));
	g[v].push_back(edges.size());
	edges.push_back(edge(v,u,0));
}
int d[maxn*2];
bool bfs(){
	memset(d,-1,sizeof(d));
	queue<int> q;
	q.push(0);
	d[0]=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=0;i<g[u].size();i++){
			edge& e=edges[g[u][i]];
			if(e.flow>=e.cap||d[e.to]>=0) continue;
			d[e.to]=d[u]+1;
			q.push(e.to);
		}
	}
	return d[m*2+1]>=0;
}
int cur[maxn*2];
const int inf=2e9;
int dfs(int u,int a){
	if(u==m*2+1) return a;
	int ans=0;
	for(int& i=cur[u];i<g[u].size();i++){
		edge& e=edges[g[u][i]];
		if(e.flow>=e.cap||d[e.to]!=d[u]+1) continue;
		int f=dfs(e.to,e.cap==inf?a:min(a,e.cap-e.flow));
		if(a<inf) a-=f;
		ans+=f;
		e.flow+=f;
		edges[g[u][i]^1].flow-=f;
		if(a==0) break;
	}
	return ans;
}
int dicnic(){
	int ans=0;
	while(bfs()){
		memset(cur,0,sizeof(cur));
		ans+=dfs(0,inf);
	}
	return ans;
}
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=readint();
    m=readint();
    for(int i=1;i<=n;i++) p[i]=readint();
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
    	t[i][j]=readint();
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
    	dis[i][j]=i==j?0:t[i][j]+p[j];
    for(int i=1;i<=m;i++){
    	x[i]=readint();
    	y[i]=readint();
    	dd[i]=readint();
	}
	floyd();
	for(int i=1;i<=m;i++) for(int j=1;j<=m;j++)
	    if(dd[i]+t[x[i]][y[i]]+p[y[i]]+dis[y[i]][x[j]]<=dd[j])
	        add_edge(i,m+j,1);
	for(int i=1;i<=m;i++) add_edge(0,i,1);
	for(int i=1;i<=m;i++) add_edge(m+i,m*2+1,1);
	printf("%d\n",m-dicnic());
	return 0;
}
```


---

## 作者：翼德天尊 (赞：0)

>$n$ 个机场，由 $i$ 到 $j$ 时间为 $t_{i,j}$。$m$ 条航线，第 $i$ 条航线 $d_i$ 时刻从 $x_i$ 机场起飞**直飞**向 $y_i$ 机场。当飞机降落到 $k$ 号机场后，需要花费 $p_k$ 时间才能再次起飞。
>
>$0$ 时刻可以在任意机场布置任意多架维修完毕的飞机，求最少需要多少架飞机。
>
>$1\le n,m\le 500$，$0\le p_i,t_{i,j}\le 10^6$，$1\le d_i\le 10^6$。

第一个想法是将每一个机场每一时刻都拆成一个点，但时刻太多，显然不太行。

而真正有意义的时间其实只有每条航线的起始时间和终止时间。我们不妨将每条航线的起始和终止拆成两个节点，然后考虑建图。

发现此时问题已经被我们转化为了「最小路径覆盖」，两条航线间有边当且仅当前一条航线结束后，可以赶在后一条航线开始之前到达起始位置并维修完毕。

于是可以先做 Floyd，求出任意两个机场非直飞状态下的最短路径，并带上维修时间后，判断是否可以连边。

若可以连边，就从前一个航线的终止节点向后一条航线的起始节点连一条边权为 $1$ 的边；然后源点向所有终止节点连边，起始节点向汇点连边即可。

带上源汇点，跑一遍最小割后，$m-ans$ 即为答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1005;
const int M=6e5+5;
const int K=505;
const int INF=1e9;
int n,m,p[K],a[K][K],s,t,dep[N],cur[N],x[N],y[N],d[N],ans,dis[N][N];
struct node{
	int to[M],next[M],head[N],tot=1,val[M];
	void adde(int u,int v,int w){
		to[++tot]=v,next[tot]=head[u],val[tot]=w,head[u]=tot;
		to[++tot]=u,next[tot]=head[v],val[tot]=0,head[v]=tot;
	}
}S;
ll read(){
    ll w=0,f=1;
    char ch=getchar();
    while (ch>'9'||ch<'0') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        w=(w<<3)+(w<<1)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
queue<int> q;
bool bfs(){
	for (int i=s;i<=t+1;i++) dep[i]=INF,cur[i]=S.head[i];
	dep[s]=0,q.push(s);
	while (!q.empty()){
		int u=q.front();
		q.pop();
		for (int i=S.head[u];i;i=S.next[i]){
			int v=S.to[i];
			if (S.val[i]&&dep[v]>dep[u]+1){
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	if (dep[t]==INF) return 0;
	return 1;
}
int dfs(int u,int flow){
	if (u==t) return flow;
	int used=0,rlow=0;
	for (int i=cur[u];i;i=S.next[i]){
		cur[u]=i;
		int v=S.to[i];
		if (S.val[i]&&dep[v]==dep[u]+1){
			if (rlow=dfs(v,min(flow-used,S.val[i]))){
				S.val[i]-=rlow;
				S.val[i^1]+=rlow;
				used+=rlow;
				if (used==flow) break;
			}
		}
	}
	return used;
}
void dinic(){
	ans=0;
	while (bfs()){
		ans+=dfs(s,INF);
	}
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
#endif
    n=read(),m=read(),s=0,t=2*m+1;
	for (int i=1;i<=n;i++) p[i]=read();
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			dis[i][j]=a[i][j]=read();
	for (int k=1;k<=n;k++)
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++)
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]+p[k]);
	for (int i=1;i<=m;i++){
		x[i]=read(),y[i]=read(),d[i]=read();
	}
	for (int i=1;i<=m;i++){
		S.adde(s,i,1);
	}
	for (int i=1;i<=m;i++)
		S.adde(i+m,t,1);
	for (int i=1;i<=m;i++){
		for (int j=1;j<=m;j++){
			if (i==j) continue;
			if (d[i]+dis[x[i]][y[i]]+(y[i]==x[j]?0:p[y[i]])+a[y[i]][x[j]]+p[x[j]]<=d[j]) S.adde(i,j+m,1);//cout<<i<<" "<<j+m<<"\n";
			//cout<<d[i]<<" "<<a[x[i]][y[i]]<<" "<<p[y[i]]<<" "<<a[y[i]][x[j]]<<" "<<p[x[j]]<<" "<<d[j]<<'\n';
		}
	}
	dinic();
	cout<<m-ans<<"\n";
    return 0;
}
```

---

## 作者：Asphy7xia (赞：0)

## 题解：P5769


[题目传送门：P5769](https://www.luogu.com.cn/problem/P5769)

[博客食用更佳](https://www.luogu.com.cn/blog/Miracle-Marta0512/solution-p5769)

翻了翻题解，发现都是网络流的解法，于是来补一篇匈牙利的题解。

这道题匈牙利相对于网络流的优点就是码量小，实现简单，而且跑得也挺快的，吸口氧后就最优解第一名了（截至2021年10月1日）。

### 题目分析

这道题其实就是[最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)的一个变式。

先用 ${\rm{Floyd}}$ 预处理出从点 $i$ 到点 $j$ 的可以直接起飞的最短路径。然后考虑对每一趟航线进行排序，使 $D_i$ 保持不降。

对于排序后的两条航线 $i$ 和 $j$ $(i< j)$，可以发现使用同一架飞机的条件是 $f_{y_i,x_j} \leq D_j-D_i-d_{x_i,y_i}-p_{x_j}$。

其中 $d_{i,j}$ 表示从点 $i$ 直接飞往点 $j$ 的路径，$f_{i,j}$ 表示从点 $i$ 到点 $j$ 的可以直接起飞的最短路径。

如果两条航线可以使用同一架飞机，那么就从编号小的航线向编号大的航线连一条边，至此，我们就将这道题完全转化为了[最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)。

然后就是拆点，跑二分图最大匹配了，每有一条边被匹配，就说明有两条航线可以共用一架飞机，那么需要的飞机数就会减 $1$，所以最后的答案即为航线数减最大匹配数。

不会做最小路径覆盖问题的可以看我的[网络流24题题解](https://www.luogu.com.cn/blog/Miracle-Marta0512/wang-lao-liu-24-ti)。

###  AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
const int N = 505;
int p[N], match[N], f[N][N], d[N][N];
bool vis[N];

struct plan  //定义航线的结构体
{
	int u, v, t;
} q[N];

std :: vector <int> g[N];  //这个vector是用来存二分图的

inline bool cmp (plan a, plan b)  //比较函数，保证排序后D_i不降
{
	return a.t < b.t;
}

inline void Floyd ()  //Floyd处理最短路径
{
	for (int k = 1; k <= n; k++)
	{
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				f[i][j] = min (f[i][j], f[i][k] + f[k][j]);
			}
		}
	}
}

inline int Dfs (int u)  //匈牙利板子，求二分图最大匹配
{
	for (int v, i = 0; i < g[u].size (); i++)
	{
		v = g[u][i];
		if (vis[v])  continue;
		vis[v] = true;
		if (! match[v] || Dfs (match[v]))
		{
			match[v] = u;
			return 1;
		}
	}
	return 0;
}

int main(){
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)  scanf ("%d", &p[i]);
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			scanf ("%d", &d[i][j]);
			f[i][j] = d[i][j] + (i == j ? 0 : p[j]);
		}
	}
	Floyd ();
	for (int i = 1; i <= m; i++)  scanf ("%d%d%d", &q[i].u, &q[i].v, &q[i].t);
	sort (q + 1, q + m + 1, cmp);  //对航线进行排序
	for (int i = 1; i <= m; i++)
	{
		for (int j = i + 1; j <= m; j++)
		{
			int t = q[j].t - q[i].t - d[q[i].u][q[i].v] - p[q[i].v];
			if (t >= f[q[i].v][q[j].u])  g[i].push_back (j);  //在实际操作中，我们找到符合条件的两条航线后就可以直接在二分图中进行连边
		}
	}
	int ans = 0;
	for (int i = 1; i <= m; i++)
	{
		memset (vis, false, sizeof (vis));
		ans += Dfs (i);
	}
	return printf ("%d", m - ans), 0;
}
```

---

## 作者：chihik (赞：0)

[网络流24题](http://chihik.cf/post/wang-luo-liu-24-ti/)

为了使飞机数量尽量少，一架飞机尽量多飞几趟航班。

将航班看成一个点，其实就是求最小路径覆盖。

如果 $i,j$ 航班可以由一架飞机先后飞行，那么将 $i,j$ 连一条边。

现在考虑如何判断可先后进行的航班。

可以用 $\text{Floyd}$ 处理由机场 $i$ 到 $j$ ，且可以立即起飞的最短时间 $dis(i,j)$。

那么只需要满足：

$$d[i]+ T(x_i,y_i)+p_{y_i}+dis(y_i,x_j) \le d[j]$$

~~Dinic需要加当前弧优化。~~ 应该都知道吧。

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
#define Inf 0x3f3f3f3f

template<typename _T>
void Read( _T &x ) {
	x = 0; int f = 1;
	char s = getchar( );
	for( ; s < '0' || s > '9' ; s = getchar( ) ) f = s == '-' ? -f : f;
	for( ; s >= '0' && s <= '9' ; s = getchar( ) ) x = x * 10 + s - '0';
	x *= f;
}
template<typename _T>
void Write( _T x ) {
	if( x < 0 ) putchar( '-' ) , x = -x;
	if( x >= 10 ) Write( x / 10 );
	putchar( x % 10 + '0' );
}

const int MAXN = 500 , MAXM = 260000;
struct node {
	int v , flow , nxt;
}Graph[ MAXM + 5 ];
int tot = 1 , Head[ 2 * MAXN + 5 ];
void Add_Edge( int u , int v , int f ) {
	Graph[ ++ tot ] = { v , f , Head[ u ] };
	Head[ u ] = tot;
}

int n , m , S , T , p[ MAXN + 5 ] , t[ MAXN + 5 ][ MAXN + 5 ] , dis[ MAXN + 5 ][ MAXN + 5 ];
int x[ MAXN + 5 ] , y[ MAXN + 5 ] , tim[ MAXN + 5 ];
int lev[ 2 * MAXN + 5 ] , cur[ 2 * MAXN + 5 ];
bool Layering( int s , int t ) {
    memset( lev , -1 , sizeof( lev ) );
	memcpy( cur , Head , sizeof( Head ) );
    queue< int > Que;
    Que.push( s ) , lev[ s ] = 0;
    while( !Que.empty( ) ) {
        int u = Que.front( ); Que.pop( );
        for( int i = Head[ u ] ; i ; i = Graph[ i ].nxt ) {
            int v = Graph[ i ].v , flw = Graph[ i ].flow;
            if( flw > 0 && lev[ v ] == -1 )
                lev[ v ] = lev[ u ] + 1 , Que.push( v );
        }
    }
    return lev[ t ] != -1;
}
int dfs( int u , int t , int f ) {
	if( u == t ) return f;
	for( int i = cur[ u ] ; i ; i = Graph[ i ].nxt ) {
		int v = Graph[ i ].v , flw = Graph[ i ].flow;
		cur[ u ] = i;
		if( flw > 0 && lev[ v ] == lev[ u ] + 1 ) {
			int mf = dfs( v , t , min( f , flw ) );
			if( mf ) {
				Graph[ i ].flow -= mf; Graph[ i ^ 1 ].flow += mf;
				return mf;
			}
		}
	}
	return 0;
}
int Dinic( int s , int t ) {
	int Maxf = 0;
	while( Layering( s , t ) ) for( int fl ; ( fl = dfs( s , t , Inf ) ) > 0 ; Maxf += fl );
	return Maxf;
}
void MakeGraph( ) {
	S = 2 * m + 1 , T = 2 * m + 2;
	for( int i = 1 ; i <= m ; i ++ )
		Add_Edge( S , i , 1 ) , Add_Edge( i , S , 0 );
	for( int i = 1 ; i <= m ; i ++ )
		Add_Edge( i + m , T , 1 ) , Add_Edge( T , i + m , 0 );
	for( int i = 1 ; i <= m ; i ++ )
		for( int j = 1 ; j <= m ; j ++ )
			if( tim[ i ] + t[ x[ i ] ][ y[ i ] ] + p[ y[ i ] ] + dis[ y[ i ] ][ x[ j ] ] <= tim[ j ] )
				Add_Edge( i , j + m , 1 ) , Add_Edge( j + m , i , 0 );
}

void Floyd( ) {
	for( int i = 1 ; i <= n ; i ++ )
		for( int j = 1 ; j <= n ; j ++ )
			if( i ^ j ) dis[ i ][ j ] = t[ i ][ j ] + p[ j ];
	for( int k = 1 ; k <= n ; k ++ )
		for( int i = 1 ; i <= n ; i ++ )
			for( int j = 1 ; j <= n ; j ++ )
				if( dis[ i ][ j ] > dis[ i ][ k ] + dis[ k ][ j ] )
					dis[ i ][ j ] = dis[ i ][ k ] + dis[ k ][ j ];
}

int main( ) {
	Read( n ) , Read( m );
	for( int i = 1 ; i <= n ; i ++ )
		Read( p[ i ] );
	for( int i = 1 ; i <= n ; i ++ )
		for( int j = 1 ; j <= n ; j ++ )
			Read( t[ i ][ j ] );
	for( int i = 1 ; i <= m ; i ++ )
		Read( x[ i ] ) , Read( y[ i ] ) , Read( tim[ i ] );
	
	Floyd( );
	MakeGraph( );
	Write( m - Dinic( S , T ) ) , putchar('\n');
	return 0; 
} 
```


---


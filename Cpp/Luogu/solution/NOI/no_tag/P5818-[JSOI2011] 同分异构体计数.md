# [JSOI2011] 同分异构体计数

## 题目描述

Antonio 最近对有机化学比较感兴趣，他想请你帮助他快速计算出某种烃类的同分异构体的数目。 

为了表述方便，我们作出如下定义： 
- 环烷烃： 具有 $n$ 个碳原子的环烷烃可以表示成一张具有 $n$ 个顶点 $n$ 条边的无向连通简单图(基环+外向树)。每个顶点的度数不超过 $4$。 
- M-环烷烃：至多有 $m$ 个顶点在环上的环烷烃。（注意环上至少有 $3$ 个顶点，因为任意两个顶点之间至多只能有 $1$ 条边）。 
- 同构：假设结构 $A$ 和结构 $B$ 均具有 $n$ 个碳原子，$A$ 和 $B$ 同构当且仅当能够对 $A$ 和 $B$ 中的每个碳原子都按照 $1~n$ 编号，使得对于编号为 $v_1$ 和 $v_2$ 的两个碳原子，他们在 $A$ 中存在边相连当且仅当他们在 $B$ 中存在边相连。（换言之，$A$ 和 $B$ 对应的图同构）。
 
现在，给出 $n$，$m$，Antonio 希望你帮助他统计有多少种互不同构的含有 $n$ 个碳原子的 M-环烷烃。由于这个数量可能很大，你只需要输出它对 $p$ 的余数。（$p$ 是一个素数）。 

在本题中，我们不考虑某结构在化学上是否能够稳定存在，也不考虑其他的异构方式。

## 说明/提示

**数据范围**

$3 \le n \le 1000$，$3 \le m \le 50$，$m \le n$，$10^4 \le p \le 2 \times 10^9$，保证 $p$ 为素数。

## 样例 #1

### 输入

```
10 10 66103```

### 输出

```
475```

# 题解

## 作者：George1123 (赞：11)

到这里欺负老年退役选手 $\to$ [`George1123`](https://www.cnblogs.com/George1123/p/14178146.html)

---

## 题面

> [JSOI2011 同分异构体计数](https://www.luogu.com.cn/problem/P5818)

> 求有多少个本质不同的无向图基环树，有 $n$ 个点且环上的点数 $\le m$。答案对 $p$ 取模。

> 数据范围：$3\le n\le 1000$，$3\le m\le 50$，$10^4\le p\le 2\times 10^9$。

---

## 题解

设 $t(x)$ 为根节点子节点数 $\le 2$，所有节点子节点数 $\le 3$ 的本质不同无标号有根树个数。

这个东西不需要多项式，直接 `Burnside` 定理然后 `dp` 即可，参考 [烷基计数 加强版](https://loj.ac/p/6269)。

然后枚举环长，设为 $k$，设当前答案多项式为 $\frac{f(x)}{2k}$。

利用 `Burnside` 定理，考虑 $G$ 的元素：

1. 不动，共 $1$ 种。$f(x)\leftarrow t(x)^k$。

2. 翻转，共 $k$ 种（即环不考虑外向树的对称轴个数，想象一下翻转后的置换环数即可）。
    - 假设 $k$ 是奇数 $f(x)\leftarrow t(x^2)^{\lfloor k/2\rfloor}t(x)$。
    - 假设 $k$ 是偶数 $f(x)\leftarrow \frac{1}{2}(t(x^2)^{k/2}+t(x^2)^{k/2-1}t(x)^2)$。

3. 旋转，共 $k-1$ 种。设旋转节为 $d$，设 $g=\gcd(d,k)$，$f(x)\leftarrow t(x^{k/g})^{g}$。



$n,m$ 很小，这部分不用多项式也可以实现：

$\Theta(n^2 m)$ 暴力卷积预处理出 $t(x)^a$。

上面的 $t(x^s)^a[x^n]=t(x)^a[x^{n/s}]$，也可以求了。

总时间复杂度 $\Theta(n^2 m+m^2\log m)$。

---

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define x first
#define y second
#define bg begin()
#define ed end()
#define pb push_back
#define mp make_pair
#define sz(a) int((a).size())
#define R(i,n) for(int i(0);i<(n);++i)
#define L(i,n) for(int i((n)-1);i>=0;--i)
const int iinf=0x3f3f3f3f;
const ll linf=0x3f3f3f3f3f3f3f3f;

//Data
const int N=1001,M=51;
int n,m,mod,f[N],g[N],t[N],p[M][N];

//Math
int& fmod(int &x){return x+=x>>31&mod;}
int gcd(int a,int b){return a?gcd(b%a,a):b;}
int mypow(int a,int x=mod-2,int res=1){
    for(;x;x>>=1,a=1ll*a*a%mod)
        (x&1)&&(res=1ll*res*a%mod);
    return res;
}

//Main
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n>>m>>mod,f[0]=p[0][0]=1;
    const int i6=mypow(6),i2=mypow(2);
    for(int i=1;i<=n;i++){
        R(a,i)  g[i]=(1ll*f[a]*f[i-1-a]+g[i])%mod;
        R(a,i)  f[i]=(1ll*f[a]*g[i-a]+f[i])%mod;
        for(int a=0;(a<<1)<i;a++)
            f[i]=(3ll*f[a]%mod*f[i-1-(a<<1)]+f[i])%mod;
        if((i-1)%3==0) f[i]=(2ll*f[(i-1)/3]+f[i])%mod;
        f[i]=1ll*f[i]*i6%mod,t[i]=g[i];
        if(i&1) t[i]=(f[(i-1)>>1]+t[i])%mod;
        t[i]=1ll*t[i]*i2%mod;
        // cout<<"i="<<i<<" t="<<t[i]<<'\n';
    }
    R(k,m)R(i,n+1)R(j,n+1-i)
        p[k+1][i+j]=(1ll*p[k][i]*t[j]+p[k+1][i+j])%mod;
    int ns=0;
    for(int k=3;k<=m;k++){
        int res=p[k][n]; // cout<<res<<'\n';
        if(k&1) for(int a=0;(a<<1)<=n;a++)
            res=(1ll*k*p[k>>1][a]%mod*t[n-(a<<1)]+res)%mod;
        else {
            if(~n&1) res=(1ll*(k>>1)*p[k>>1][n>>1]+res)%mod;
            for(int a=0;(a<<1)<=n;a++)
                res=(1ll*(k>>1)*p[(k>>1)-1][a]%mod
                    *p[2][n-(a<<1)]+res)%mod;
        }
        for(int d=1,G;d<k;d++)if(n%(k/(G=gcd(d,k)))==0)
            res=(0ll+p[G][n/(k/G)]+res)%mod;
        ns=(1ll*res*mypow(k<<1)+ns)%mod;
    }
    cout<<ns<<'\n';
    return 0;
}
```

---

**祝大家学习愉快！**

---

## 作者：Drind (赞：2)

来一篇对于 burnside 初学者相对友好 (?) 的题解。

首先题目的意思就是本质不同基环树（而且环的大小 $\le m$，每个点的度数 $\le 4$）计数，要解决这个问题，我们显然需要对无标号有根树计数，不是普通的有根树，是每个点度数 $\le 4$ 的有根树，而且根要在环上。那等同于每个点只有三个儿子，根只能有俩。

现在开始设计方程，我们设 $f_{i,j}$ 为现在的根上挂着 $i$ 个儿子，总大小 $j$ 个点的树个数，每次往上挂子树。先枚举挂子树的大小，假设现在子树大小是 $x$。

设 $g_i$ 为有 $i$ 个子树，大小均为 $x$，可以重排的方案数。$g_1$ 就是等于 $\sum_{i=0}^3f_{i,x-1}$（因为还要一个新的点作为根，所以是 $x-1$）。

$g_2$ 就需要 burnside 求了，两个点置换方案只有两个，一个是交换一个是不换，交换的话，就要两个子树完全相等，就只有 $g_1$ 种方案，不交换的话，随便选，有 $g_1^2$ 种方案，最后除以二，就是 $\frac{g_1(g_1+1)}{2}$。

$g_3$ 同理，考虑现在的六种置换，如果是 $[1,2,3]$，那么三个子树随便选，$g_1^3$ 种方案，如果是 $[1,3,2],[3,2,1],[2,1,3]$ 中的一个，那么有一个子树固定，剩下俩交换，方案数就是 $3g_1^2$，如果是 $[2,3,1],[3,1,2]$，那么就是全换，方案数 $2g_1$，最后除以六，就是 $\frac{g_1(g_1+1)(g_1+2)}{6}$

然后算出来了 $g$，就只需要拿三个 $g$ 到 $f$ 上贡献，做背包就好啦。

接下来考虑环的置换，环有 $2m$ 种置换，其中 $m$ 种是位移，剩下 $m$ 种是 $m$ 个对称轴，翻转。

考虑位移的情况，那么就跟那道 polya 定理模板题差不多，而且这题不用莫反，只需要做背包就可以得到了。

我们设 $lf_{i,j}$ 为长度为 $i$ 的**链**，链上每一个点都挂一棵树，树大小总和为 $j$ 的方案数，首先 $lf_{1,i}=\sum_{j=0}^2f_{j,i}$，为啥？因为根只能有两个儿子。然后转移是背包：$lf_{i,j}=\sum_{k=1}^{j-1}lf_{i-1,j-k}lf_{1,k}$。

接下来就是考虑翻转了。我们设 $rf_{i,j}$ 为长度为 $i$ 的**环**，环上每一个点都挂一棵树，树大小总和为 $j$ 的方案数。

如果 $m$ 是奇数，那么 $m$ 种翻转都是一样的，也就是 $\left\lfloor\frac{m}{2}\right\rfloor$ 对点两两对应，剩下一个点自己对应自己。那么枚举 $\left\lfloor\frac{m}{2}\right\rfloor$ 个点组成的链上挂的树的大小和，设 $lim=\left\lfloor\frac{j-1}{2}\right\rfloor$，转移为：$rf_{i,j}=\sum_{k=1}^{lim}rf_{\frac{i-1}{2},k}lf_{1,j-2k}$。

如果 $m$ 是偶数，那么有 $\frac{m}{2}$ 种是每个点都两两对应，剩下 $\frac{m}{2}$ 种是两个点自己对应自己，剩下 $m-2$ 个点两两对应。

如果全部对应，那么就是 $rf_{i,j}\gets lf_{\frac{i}{2},\frac{j}{2}}$，转移的条件是 $j \equiv 0\pmod 2$，也就是 $j$ 为偶数。

如果有两个点没对应，剩下的全对应，那么就是 $rf_{i,j}\gets \sum_{k=1}^{lim}rf_{\frac{i-1}{2},k}\sum_{l=1}^{j-2k-1}lf_{1,l}lf_{1,j-2k-l}$。就是我们枚举那 $\frac{m-2}{2}$ 个点组成的链的点数，然后枚举剩下两个自己对应自己的点的点数。其实等同于 $\sum_{k=1}^{j-1}rf_{i-1,j-k}lf_{1,k}$。

计算答案的时候，我们枚举环的长度，假设是 $i$，然后设 $g=\gcd(i,n)$，循环节的长度必须是 $g$ 的因数（不然 $n$ 的点没法均分），所以枚举 $g$ 的因数，假设是 $d$，那么就加上 $lf_{\frac{i}{d},\frac{n}{d}}\times \phi(d)$ 即可。

为什么是 $\phi(d)$？为了计算有多少种位移方式使得循环节长度为 $d$，首先位移 $\frac{i}{d}$ 位显然可以，然后 $\frac{i}{d}$ 乘上一个和 $d$ 互质的数也显然不影响他和 $i$ 的 $\gcd$，所以一共会有 $\phi(d)$ 种方案。

然后贴下代码~
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e3+10;
int p;
inline int _abs(int x){if(x>0) return x;return -x;}

int phi(int n){//暴力算欧拉函数
	int tmp=n;
	for(int i=2;i*i<=n;i++){
		if(n%i==0) tmp=tmp/i*(i-1);
		while(n%i==0){
			
			n/=i;
		}
	}
	if(n!=1) tmp=tmp/n*(n-1);
	return tmp;
}

int gcd(int x,int y){
	if(y==0) return x;
	return gcd(y,x%y);
}

int qpow(int a,int index){
	int ans=1;
	while(index){
		if(index&1) ans=ans*a%p;
		a=a*a%p; index>>=1;
	}
	return ans;
}

int tr[N][N],lf[N][N],rf[N][N];//代码里的tr，就等同于我题解里说的 f。
int g[N]; 
int inv[N];
int n,m;
void init(){
	tr[0][0]=1; inv[1]=1;
	for(int i=2;i<N;i++) inv[i]=inv[p%i]*(p-p/i)%p;//预处理每个数字的逆元
	for(int i=1;i<=n;i++){
		lf[1][i]=rf[1][i]=tr[0][i-1]+tr[1][i-1]+tr[2][i-1];//根只能选俩儿子
		g[1]=tr[0][i-1]+tr[1][i-1]+tr[2][i-1]+tr[3][i-1];
		g[2]=g[1]*(g[1]+1)%p*inv[2]%p;
		g[3]=g[1]*(g[1]+1)%p*(g[1]+2)%p*inv[6]%p;//burnside 求本质不同子树方案
		for(int j=3;j>=1;j--){
			for(int k=n;k>=i;k--){
				for(int r=1;r<=j;r++){
					if(k>=i*r) tr[j][k]=(tr[j][k]+g[r]*tr[j-r][k-r*i]%p)%p; //背包
				}
			}
		}
		
		 
	}
	
	for(int i=2;i<=m;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<j;k++) lf[i][j]=(lf[i][j]+lf[i-1][j-k]*lf[1][k]%p)%p;//lf也是背包
			if(i&1){//如果是奇数
				for(int k=2;k<j;k+=2){
					rf[i][j]=(rf[i][j]+lf[i/2][k/2]*lf[1][j-k]%p)%p;//这里枚举的和题解写的稍微有点不同，这里枚举的是2k，而不是k
				}
			}else{
				for(int k=1;k<j;k++){
					rf[i][j]=(rf[i][j]+rf[i-1][j-k]*lf[1][k]%p)%p;//留两个点自己对应自己，剩下完全对应的方案数，可以借用刚才上面算的奇数的情况
				}
				if(j%2==0) rf[i][j]=(rf[i][j]+lf[i/2][j/2])%p;//如果点数是偶数，那么可以让所有点全部两两对应
				rf[i][j]=rf[i][j]*inv[2]%p; //因为我们本质上算了两种方案，所以这里先除以2，底下会乘回来，不急
			}
		}
	}
}

void fake_main(){
	cin>>n>>m>>p;
	init();
	
	int ans=0;
	for(int i=3;i<=m;i++){
		int g=gcd(n,i);
		int tmp=0;
		for(int j=1;j<=g;j++){
			if(g%j==0) tmp=(tmp+lf[i/j][n/j]*phi(j)%p)%p;//枚举位移
		}
		tmp=(tmp+rf[i][n]*i%p)%p;//翻转的情况，注意有i种翻转，要乘i 
		tmp=tmp*inv[i*2]%p;//burnside，最后要除以总置换数量
		ans=(ans+tmp)%p;
	}
	
	cout<<ans<<"\n";
}

signed main(){
	ios::sync_with_stdio(false);
	int t; t=1;
	while(t--) fake_main();
}

```

---


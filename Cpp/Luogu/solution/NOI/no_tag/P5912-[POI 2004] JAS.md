# [POI 2004] JAS

## 题目背景

在 Byteotia 有一个洞穴。

## 题目描述

 它包含 $n$ 个洞室和一些隧道连接他们。

每个洞室之间只有一条唯一的路径连接他们。Hansel 在其中一个洞室藏了宝藏，但是它不会说出它在哪。Gretel 知道，当她询问一个洞室是否有宝藏时，如果她猜对了 Hansel 会告诉她，如果猜错了他会告诉她哪个方向会有宝藏。 给出洞穴的信息，那么无论 Hansel 把宝藏藏在了哪，求出最少要询问多少次才能找到宝藏。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le50000$。

## 样例 #1

### 输入

```
5
1 2
2 3
4 3
5 3```

### 输出

```
2```

# 题解

## 作者：Alex_Wei (赞：17)

> *I. [P5912 [POI2004]JAS](https://www.luogu.com.cn/problem/P5912)
>
> 摘自 [贪心专题](https://www.cnblogs.com/alex-wei/p/greedy.html) 第三部分例题 I.

究极神仙题。

首先对问题进行转化：相当于我们需要求原树最浅的一个点分树深度。假设点 $i$ 在倒数第 $d_i+1$ 次被问到，那么任意两个 $d$ 值相同的点 $u,v$ 之间的简单路径必然存在一个点 $a$ 使得 $d_a>d_u$，因为这样才能使它们进入不同的点分树子树，说人话即 $a$ 是深度相同的点 $u,v$ 在点分树上的 LCA（的祖先）。

考虑这样一个贪心：我们记 $S_i$ 表示 $i$ 的子树内所有可能不满足条件的 $d$ 值，即存在 $u\in \mathrm{subtree}(i)$ 使得不存在 $v\in \mathrm{path}(u,i)$ 满足 $d_v>d_u$ 的所有 $d_u$ 的集合，以二进制状压形式存储。合并 $i$ 的两个子树 $u,v$ 时，首先 $d_i$ 应大于任何一个既在 $S_u$ 又在 $S_v$ 内的元素，否则显然不合法。此外，$d_i$ 还不应存在于 $S_u$ 和 $S_v$ 中，我们选择所有满足条件的最小的 $d_i$ 即可。$S_i$ 即所有 $S_u$ 与 $\{d_i\}$ 的并去掉所有 $<d_i$ 的元素后的集合。
$$
d_i=\min \{c\mid c>\max\{x\mid x\in S_u\cap S_v\}\land c\notin S_u\}\\

S_i=\{d_i\}\cup\left\{x\left|\ x\geq d_i\land x\in\bigcup_{u\in\mathrm{son}(i)}S_u\right.\right\}
$$
根据点分树的结论答案不可能超过 $\log n$，因此时间复杂度 $\mathcal{O}(n\log n)$，可以做到线性：通过位运算我们求出可行的 $d_i$ 集合，取 $\mathrm{lowbit}$ 即可，拿到了最优解。

```cpp
const int N = 5e4 + 5;
const int K = 1 << 16; 
int cnt, hd[N], nxt[N << 1], to[N << 1];
void add(int u, int v) {nxt[++cnt] = hd[u], hd[u] = cnt, to[cnt] = v;}
int n, f[N], S[N], lg[K], buc[K];
void dfs(int id, int fa) {
	int msk = 0, ban = 0, leaf = 1;
	for(int i = hd[id]; i; i = nxt[i]) {
		int it = to[i];
		if(it == fa) continue;
		leaf = 0, dfs(it, id), f[id] = max(f[id], f[it]);
		msk |= ban & S[it], ban |= S[it];
	} if(leaf) return S[id] = 1, void();
	msk = (K - (1 << lg[msk])) & (K - 1 - ban);
	int c = !msk ? lg[n] + 1 : buc[msk & -msk];
	f[id] = max(f[id], c);
	S[id] = (ban & (K - (1 << c))) | (1 << c);
}

int main(){
	cin >> n;
	for(int i = 2; i < K; i++) lg[i] = lg[i >> 1] + 1;
	for(int i = 1; i < 16; i++) buc[1 << i] = i;
	for(int i = 1; i < n; i++) {
		int u = read(), v = read();
		add(u, v), add(v, u);
	} dfs(1, 0), cout << f[1] << endl;
	return 0;
}
```

**启示：遇到无从下手的问题时先尝试抽象问题并分析性质（本题中是两点间的简单路径必然存在点分树的 LCA）使其更好理解**。树上问题先从叶子开始，可以先考虑一些简单情况再尝试总结策略。**树形 DP 先考虑仅合并两个子树的情况**。

---

## 作者：FLY_lai (赞：11)

[传送门](https://www.luogu.com.cn/problem/P5912)

题意；找出最浅的点分树。

发现这是一个等价问题：给每个结点一个标号，当两个结点标号相同时，它们的路径上必有严格更小的标号。如果找到了这样一种标号方法，每个结点的标号就是它的深度。

同时我们还可以把每个结点的标号 $x$ 对应到 $n+1-x$，也是一一对应。问题又变成路径上必有严格更大的标号。

给出一个贪心构造标号的方法：先让所有叶子为 $1$，然后对于非叶子结点，它的标号为不与它的子树冲突的最小数。 

那我们如何判断一个结点 $u$ 能填哪些数？

定义一个结点 $x$ 对于 $u$ 是 “溢出的”：如果 $x$ 到 （$x$ 所在的 $u$ 的子树的根）的路径上所有点权都 $<x$，称结点 $x$ 是溢出的。

子树的溢出的结点构成子树的溢出集合。

显然 $u$ 不能取每个子树溢出集合中的任何一个数。同时如果两颗子树中有两个溢出的结点权值相等为 $y$，则 $u$ 的权值必须 $>y$。

然后是这个贪心的证明。

记 $f(s_1\sim s_k)$ 为当儿子们的溢出集合为 $s_1\sim s_k$ 时，$u$ 能填的最小数。$F(s_1\sim s_k)$ 为用 $f(s_1\sim s_k)$ 填了 $u$ 后，$u$ 子树的溢出集合。

两个引理：

1. 当 $u$ 填 $f(s_1\sim s_k)$ 时，$u$ 子树的溢出集合最小。**这里的最小是指如果把集合看作二进制数时最小。后面的集合比大小也是这么定义。**

2. 当 $s_k'\ge s_k$，$F(s_1\sim s_{k-1}, s_k')\ge F(s_1\sim s_{k-1},s_k)$。

若这两条引理成立，贪心就能简单证出来：

根据 2，要 $u$ 的溢出集合最小，要使所有儿子的溢出集合最小。

而根据 1，填 $f()$ 能使溢出集合最小。则贪心得证。

引理 1 证明：

观察到 $u$ 填入 $x$ 后，$u$ 的溢出集合就是把儿子的溢出集合并起来，然后删去所有小于 $x$ 的数。

记 $T=s_1\cup \dots\cup s_k$。如果把集合视作二进制数，$u$ 填入 $x$ 就相当于在 $x$ 位上变成 $1$，比 $x$ 位低的都改成 $0$。这样显然是 $x$ 尽量小才好。

引理 2 证明：

记 $t$ 为 $s_1\sim s_{k-1}$ 中最大的出现在至少两个集合中的数（$t=0$ 表示无公共元素），$T=s_1\cup\dots\cup s_{k-1}$ 再去掉	$\le t$ 的数。

发现若 $t>0$，则 $s_k$ 中 $\le t$ 的元素都无意义，所以所有集合都可以去掉后 $t$ 位。也就是可以假设 $t=0$，即没有公共元素。那此时的 $T=s_1\cup\dots\cup s_{k-1}$，因为没有 $\le t$ 的数了。

再简化一下命题，因为引理 2 其实表示了一个单调性质，于是我们可以假设 $s_k'=s_k+1$。

设 $w$ 为最小的不属于 $s_k$ 的标号。

1. 情况一，$s_k\cap T$ 有元素大于 $w$。
	
    因为有交集大于 $w$，所以 $f()$ 一定大于 $w$。而 $F()$ 为填了 $f()$ 的溢出集合，因为 $f()>w$，比 $f()$ 低的位都会变成 $0$（不再溢出）。
    
    但 $s_k,s_k'=s_k+1$ 的区别就是：$s_k$ 的最低位一直到 $w$ 的前一位都是 $1$，第 $w$ 位是 $0$；$s_k+1$ 的最低位一直到 $w$ 的前一位都是 $0$，第 $w$ 位都是 $1$。其他的都一样。
    
    但是 $f()$ 把较低位的都变成 $0$ 了，所以 $s_k,s_k'=s_k+1$ 最终算出来的 $F$ 相等。
    
2. 情况二，不满足情况一且 $w\in T$。

	因为 $f()$ 选择的位不能出现在任何儿子的溢出集合，所以 $f()$ 选择的位一定在所有儿子的溢出集合中都是 $0$，也就等价于 $T$ 的位上和 $s_k(s_k')$ 的位上都是 $0$。（$t=0=>T=s_1\cup\dots\cup s_{k-1}$）
    
    因为 $w\in T$，所以 $T$ 的第 $w$ 位为 $1$。
    
    考虑 $f(s_1\sim s_{k-1},s_k)=f(T,s_k)$，因为 $s_k$ 第 $w$ 位以下都是 $1$，第 $w$ 位为 $0$，所以 $f(T,s_k)$ 不能在 $w$ 及以下。（第 $w$ 位及以下都有非 $0$ 的）因此 $f(T,s_k)$ 是在第 $w$ 位以上找到的第一个 $T,s_k$ 都是 $0$ 的位。
    
    又 $T,s_k+1$ 的第 $w$ 位都是 $1$，重复了，所以 $f(T,s_k+1)$ 必须高于第 $w$ 位。所以 $f(T,s_k+1)$ 是在第 $w$ 位以上找到的第一个 $T,s_k+1$ 都是 $0$ 的位。
    
    因为第 $w$ 位以上 $s_k,s_k+1$ 相同。所以这种情况下 $f(T,s_k)=f(T,s_k+1)$。

3. 情况三，不满足情况一且 $w\not\in T$。

	则 $T$ 的第 $w$ 位为 $0$。
    
    因为 $s_k,T$ 的第 $w$ 位都是 $0$，所以 $f(T,s_k)$ 就是第 $w$ 位，$F(T,s_k)$ 的第 $w$ 位以上为 $T\cup s_k$，第 $w$ 位为 $1$，第 $w$ 位以下为 $0$。
    
    即 $F(T,s_k)=(T\cup s_k)+1$。
    
    因为 $s_k+1$ 的第 $w$ 位为 $1$，$s_k+1$ 比第 $w$ 位更高的位与 $s_k$ 相等。所以 $F(T,s_k+1)$ 至少第 $w$ 位是 $1$，比 $w$ 高的位和 $T\cup s_k$ 相同。而比 $w$ 低的位 $F(T,s_k)$ 全是 $0$，所以 $F(T,s_k+1)\ge F(T,s_k)$。
    
综上，引理 2 也得证了。

所以贪心方法是：每个叶节点都标号 $1$，其他结点的权值为 $f(sons)$。标号结束后最大的标号就是答案。

计算溢出集合、找出最低的都是 $0$ 的位可以在 $O(\log n)$ 的时间里做完。（位运算应该能到 $O(1)$）

---

## 作者：jiangby (赞：5)

仔细观察题意，不难发现问题等价于给定树 $T$，求其深度最浅的点分树的深度，解决这个问题即可

对于这个新问题，又等价于给每个点标上一个 $lable[x]$ ，满足对于任意两个 $lable$ 相同的点，其路径上有一个点的 $lable$ 比它们大，要最小化最大的 $lable$，这个问题可以贪心解决

从叶子往根贪心，尽量让当前的 $lable$ 尽量小，定义一个数 $k$ 在 $u$ 的子树匹配当且仅当子树内每个 $lable=k$ 的点到 $u$ 的路径上都有一个点大于 $k$ ，用 $ban[u]$ 表示 $u$ 的字数内未匹配的 $lable$，由传统点分治算个可知 $lable$ 是 $O(log\  n)$ 级别的，所以可以状压

对于一个点 $u$ 的儿子 $v$，记 $x$ 为所有 $v$ 的 $ban[v]$ 按位或的答案，对于其所有 $0$ 位,只要其大于当前最大的 $ban[v1]\&ban[v2]$ 的 $1$ 位，那么他就可行，所以枚举一下就可以了

```
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define ull unsigned ll
#define db double
#define pint pair<int,int>
#define mk make_pair
#define pb push_back
#define eb emplace_back
#define ins insert
#define fi first
#define se second
#define Rep(x,y,z) for(int x=y;x<=z;x++)
#define Red(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
const int MAXN=1e5+5;
char buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;
inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}
//inline char gc(){return getchar();}
inline int read(){
	int x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;
	for(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;
}
int n,lab[MAXN],ban[MAXN];vector<int>G[MAXN];
void dfs(int x,int fa){
	int t=0;
	for(auto y:G[x])if(y!=fa)dfs(y,x),t|=ban[x]&ban[y],ban[x]|=ban[y];
	int k=t?32-__builtin_clz((unsigned)t):0;lab[x]=__builtin_ctz((unsigned)((ban[x]|((1<<k)-1))+1)),ban[x]=(ban[x]>>lab[x]|1)<<lab[x];
}
int main(){
//	freopen("string.in","r",stdin);
//	freopen("string.out","w",stdout);
	n=read();
	Rep(i,1,n-1){int x=read(),y=read();G[x].pb(y),G[y].pb(x);}
	dfs(1,0);int ans=0;Rep(i,1,n)ans=max(ans,lab[i]);cout<<ans<<'\n';
	return 0;
}



```

---

## 作者：Mars_Dingdang (赞：2)

本篇题解侧重于如何感性理解解题过程。

## 题目大意
给定一棵 $n$ 个节点的树，有一个关键点位置未知。每次询问一个点，可以得到关键点相对于这个点的方向，求最少询问几次保证找到关键点位置。

$n\le 5\times 10^4$。

## 大体思路
首先很容易想到点分树。实际上本题求的就是最大深度最小的点分树。

询问的过程就是按照点分树的节点往下跳，由于点分树的深度是 $O(\log n)$ 的，这一优秀的性质也就保证了答案是 $O(\log n)$ 的。

~~然后我们尝试建出一棵点分树，复杂度是单 $\log$，然后发现提交之后全 WA，并且答案都比输出小 $3$，然后你将答案减 $3$ 即通过了此题。~~

具体考虑本题的过程。我们给每个点标号，第 $u$ 个点的标号 $a_u$ 表示如果询问 $u$ 号点那么 $u$ 是倒数第几个被询问的。

显然，如果我们按照点分树的过程进行询问，每个叶子节点必然都是最后一个被询问的，因此所有叶子节点 $a_u=1$。

对于其他节点 $u$，对于其子树内节点 $v\in \text{subtree}(u)$，记 $u$ 在 $v$ 方向对应的儿子为 $son(u,v)$。如果 $v\to son(u,v)$ 的路径上所有点的标号都不超过 $a_v$，那么称 $a_v$ 为溢出的。

对于 $u$ 的所有儿子，维护一个“溢出的”的值的集合 $S$。由于标号的值域不超过答案，而答案由于点分树深度限制为 $O(\log n)$，因此这样的集合 $S$ 可以用一个 $\log$ 位二进制数存下。

对于当前的一个 $u$，考虑其子树内一个溢出的值 $a_v$ 和所属节点 $v$。

![](https://cdn.luogu.com.cn/upload/image_hosting/o3hct6dr.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/fgasma09.png)

所以我们得出了标号的规则：

- $\text{if}\ u\in \text{Leaf}$，$a_u=1$;
- $\text{otherwise}$，记 $msk$ 表示至少在两个子树中出现的值的集合，则 $a_u$ 为大于 $msk$ 最高位且全为 $0$ 的最低位置。

使用位运算即可，具体参见代码，复杂度 $O(n)$。

关于其证明，可以使用调整法，也可以参见题解区一篇题解。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5;
const int MS = 1 << 16;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n;
vector <int> e[maxn];
int dep[maxn], f[maxn];
int S[MS + 5], Lg[MS + 5];
inline int lowbit(int x) {return x & (-x);}
inline void dfs(int u, int fa) {
	bool is_leaf = 1;
	int msk = 0, ban = 0;
	for(auto v : e[u]) {
		if(v == fa) continue;
		is_leaf = 0;
		dfs(v, u);
		f[u] = max(f[u], f[v]);
		msk |= (ban & S[v]); // 有至少两个为1的位置
		ban |= S[v]; // 不能与寄了的集合相同
	}
	if(is_leaf) {
		S[u] = 1;
		return;
	}
	msk = (MS - (1 << Lg[msk])) & ((MS - 1) ^ ban);
	 // 得到所有可行值的集合
	int c = (!msk ? Lg[n] + 1: Lg[lowbit(msk)]);
	f[u] = max(f[u], c);
	S[u] = (ban & (MS - (1 << c))) | (1 << c);
}
int main () {
	read(n);
	Lg[0] = -1;
	rep(i, 1, MS - 1) Lg[i] = Lg[i >> 1] + 1;
	Lg[0] = 0;
//	rep(i, 1, 15) cout << Lg[1 << i];
	rep(i, 1, n - 1) {
		int u, v;
		read(u); read(v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1, 0);
	writeln(f[1]);
	
	
	return 0;
}
```
## 后记
需要注意的是，本题通过按点分树选点只是保证了答案不超过 $O(\log n)$。

如果答案就是深度最浅的点分树，那么每次重心只有一个的时候直接跳，每次重心有两个的时候分别以之为根求最浅点分树，问题规模减半。

$T(n)=2T(\dfrac n 2)+O(n)$，这样得到的时间复杂度是 $O(n\log n)$。

然而不幸的是，本题这样贪心是错误的，不能通过。

---

## 作者：OrientDragon (赞：0)

# 题意

给你一棵树，要最小化点分树中结点的最大深度。注意，点分树根的深度是 $0$。

# 分析

> 注：下面都是长难句，所以这个方框会给出自然语言（人话版）解释。

## 问题转化

令 $\text{dep}_u$ 表示 $u$ 在点分树上的深度。

考虑两个 $\text{dep}$ 相同的点。它们之间的路径上，肯定有至少一个比它们 $\text{dep}$ 小的点。

> 证明：考虑对于两个结点 $x,y$ 满足 $\text{dep}_x=\text{dep}_y=w$。那么我们不妨找到 $u,v$ 在点分树上的 LCA，设这个结点是 $z$。显然 $\text{dep}_z<w$。而由于 $z$ 是最后一次分开树（LCA），那么它一定会将 $x,y$ 分为两棵不同子树内的结点。所以，$z$ 肯定在 $x,y$ 树上的路径。

形式化地说，$\forall \text{dep}_u=\text{dep}_v=w,\exists z \in \text{path}(x,y),\text{dep}_z < w$。

那么我们略微修改一下这个条件，将 $\text{dep}_z < w$ 变为 $\text{dep}_z > w$。也就是说，我们令（点分树上）根结点的深度最大，叶子结点的深度为 $0$。

> 人话版：对于两个 $\text{dep}$ 相同的点，路径上有一个 $\text{dep}$ 更大的点将它俩隔开。

## 性质观察

考虑如何求解 $\text{dep}$。我们假设已经算出了一个结点 $u$ 子树内所有的 $\text{dep}$ 值。那么这个结点的深度需要满足哪些条件？

> 人话版前置：定义“溢出结点”为：对于一个子树 $\text{subtree}(u)$ 内的点 $v$，如果它到 $u$ 的路径（不算 $u$）上的点的 $\text{dep}$ 都小于 $\text{dep}_v$，那么我们称 $v$ 是子树 $u$ 的溢出结点。

---

1. 如果 $\exists v \in \text{subtree}(u) \land \forall x \in \text{path}(u,v)\backslash\{u\},\text{dep}_x <\text{dep}_v$，那么有 $\text{dep}_u\ne \text{dep}_v$。

> 人话版条件：如果存在一个溢出结点。

证明：如果 $\text{dep}_u=\text{dep}_v$，那么 $u \leftrightarrow v$ 不满足点分树的条件。

---

2. 如果 $\exists v,w \in \text{subtree}(u) \land \text{dep}_v=\text{dep}_w=k \land \forall x \in \text{path}(v,w)\backslash \{u\},\text{dep}_x < k$，那么有 $\text{dep}_u > k$。

> 人话版条件：如果有两个子树溢出结点，它们的 $\text{dep}$ 相同，都为 $k$。

证明：如果 $\text{dep}_u \le k$，那么 $v \leftrightarrow w$ 就不满足点分树条件了。

---

那么我们维护一个溢出集合 $S_u$，表示当前 $\text{subtree}(u)$ 内溢出结点 $\text{dep}$ 的集合。再维护一个 $\text{mask}_u$，表示子树内出现两次的溢出结点深度。通过这两个东西，我们可以搞出当前结点合法 $\text{dep}$ 最小值。

具体地，我们发现 $\text{dep}_u$ 要大于所有的 $\text{mask}_u$ 内的 $\text{dep}$。而且，这个 $\text{dep}_u$ 还不能在 $S_u$ 中出现过。

但是我们的思路是贪心的，它只能处理当前结点的 $\text{dep}$ 的最小值。它是正确的吗？

## 正确性证明

还是用调整法证明贪心正确性。

考虑最优解的情况，如果存在一个结点 $u$，它在最优解里的 $\text{dep}$ 为 $\text{dep}_u$，但是我们的贪心算出来是 $w$。

它的 $\text{dep}_u$ 降低到 $w$ 仍然合法。那么我们让 $\text{dep}_u' \leftarrow w$，然后使 $\text{dep}_{\text{fa}_u}' \leftarrow \max(\text{dep}_{\text{fa}_u},\text{dep}_u)$，这个东西仍然合法并且不会更差。

首先，$\max(\text{dep}_u,\text{dep}_{\text{fa}_u})$ 肯定不变（$u$ 变小了，$\text{fa}_u$ 可能变大，但是也没有超过 $u$ 的原 $\text{dep}$）。

那么我们将原树根据 $u \leftrightarrow \text{fa}_u$ 分成两部分。设一部分是 $S$，另一部分是 $T$（$S,T$ 不包含 $u$ 和 $\text{fa}_u$，$S$ 是 $u$ 一侧的，$T$ 是 $\text{fa}_u$ 一侧的）。

考虑一棵点分树合法的等价限制，就是：

> 对于两个 $\text{dep}$ 相同的点，路径上有一个 $\text{dep}$ 更大的点将它俩隔开。

那么如果原来有 $a \in S,b \in T$，它们中间有隔开，现在依旧有隔开。

如果原来有 $a,b \in S$，它们中间有隔开，那么根据题设，$\text{dep}_u \leftarrow w$ 依旧合法。

如果原来有 $a,b \in T$，它们中间有隔开，那么由于 $\text{dep}_{\text{fa}_u}$ 不减，所以依旧有隔开。

综上，可以通过调整得到：我们的贪心算法一定不比最优解差。

# code

别的题解代码有点难懂，~~还是我的好看~~

之所以我的输出要减一是因为我~~不小心~~将叶子结点的深度设为 $1$ 了，大家不要学我。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=50005;
int n,dep[N],overflow[N];
vector<int>e[N];

void print(int x){
	if(x>1)print(x/2);
	cout<<x%2;
}

int highbit(int x){
	int ret=0;
	while(x){
		ret++;
		x>>=1;
	}
	return ret;
}

void dfs(int u,int fa){
	bool flag=1;
	int vis=0,mask=0;
	for(int v:e[u]){
		if(v==fa)continue;
		flag=0;
		dfs(v,u);
		overflow[u]|=overflow[v];
		mask|=(vis&overflow[v]);
		vis|=overflow[v];
	}
	if(flag){
		dep[u]=overflow[u]=1;
		return;
	}
	dep[u]=highbit(mask)+1;
	while(overflow[u]&(1<<(dep[u]-1)))dep[u]++;
	overflow[u]-=(overflow[u]&((1<<dep[u])-1));
	overflow[u]|=1<<(dep[u]-1);
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n;
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	int mx=0;
	for(int i=1;i<=n;i++)
		mx=max(mx,dep[i]);
	cout<<mx-1;
}
```

---

## 作者：MerlinLee (赞：0)

不难发现，题目等价于求高度最小的点分树的高度，直接求有点困难，我们不妨来对其进行一些转化：我们考虑给每个点一个标号，那么问题可以转化为，求使得任意两个标号相同的点之间必须有一个点标号比它大，求最大标号的最小值。

考虑 DFS，DFS 到一个节点 x 时我们考虑贪心地给它赋上一个最小的标号，那么要求这个标号满足：

- 对于所有子树内与该点标号相同的点 y ，x 与 y 之间少有一个点编号比它大。
- 对于 x 不同子树内的两点 y 和 z，如果 y 和 z 标号相同并且这个路径不存在标号比 y 的标号大的点，那么 x 的号比这样的点 y 标号都要大。

注意到点分树高度肯定是 $\log n$ 级别的，因此直接模拟即可。每次用个 mask 记录下所有满足存在一个点 y 标号为 p，并且 y 到 x 的路径上的点的标号都大于等于 p 的集合 $S_i$，再记录下所有满足存在两点 y 和 z 属于 x 的不同子树，它们的标号都为 p ，并且 y 到 z 的路径上不存在标号大于等于 p 的集合 $S_2$，然后贪心的去取大于 $S_2$ 中最大元素，并且不在 $S_1$ 中的元素作为 x 的标号。

所以时间复杂度是 $O(n\log n)$ 的。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50005;
char ch;
int n,m,a,b,s1[20],f[maxn],sta[maxn],tot,now[maxn],son[maxn<<1],pre[maxn<<1];
bool ok;
void read(int &x)
{
    for(ok=0,ch=getchar();!isdigit(ch);ch=getchar()) 
	  if(ch=='-') 
	    ok=1;
    for(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());
      if(ok) 
	    x=-x;
}
void put(int a,int b)
{
	pre[++tot]=now[a],now[a]=tot,son[tot]=b;
}
void dfs(int u,int fa)
{
    int s2=0,cu=0,deg=0;
    for(int p=now[u],v=son[p];p;p=pre[p],v=son[p])
      if(v!=fa) 
	    dfs(v,u),s2|=sta[v],deg++;
    if(!deg)
	{
		f[u]=0,sta[u]=1;
		return;
	}
    memset(s1,0,sizeof(s1));
    for(int p=now[u],v=son[p];p;p=pre[p],v=son[p]) 
	  if(v!=fa)
        for(int i=0;i<m;i++) 
		  if(sta[v]&(1<<i)) 
		    s1[i]++;
    if(deg>1) 
	  for(int i=m-1;i>=0;i--) 
	    if(s1[i]>=2)
		{
			cu=i+1;
			break;
		}
    for(int i=cu;i<m;i++) 
	  if(!(s2&(1<<i)))
	  {
	  	  cu=i;
		  break;
	  }
    sta[u]=((s2>>cu)|1)<<cu,f[u]=cu;
    for(int p=now[u],v=son[p];p;p=pre[p],v=son[p]) 
	  if(v!=fa) 
	    f[u]=max(f[u],f[v]);
}
int main()
{
    read(n),m=log2(n)+1;
    for(int i=1;i<n;i++) 
	  read(a),read(b),put(a,b),put(b,a);
    dfs(1,0);
    printf("%d\n",f[1]);
    return 0;
}
```

---


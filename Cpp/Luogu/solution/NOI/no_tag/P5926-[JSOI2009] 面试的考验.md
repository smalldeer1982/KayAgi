# [JSOI2009] 面试的考验

## 题目描述

求区间最接近且不相等的两数之差的绝对值。

**注：最接近指数值上最接近**

## 说明/提示

对于 $100\%$ 的数据，$1\le N,Q\le10^5,1\le A_i\le10^9$。

数据为全部**纯随机**生成。

## 样例 #1

### 输入

```
5 3
1 4 2 6 7
2 3
3 4
2 5```

### 输出

```
2
4
1```

# 题解

## 作者：MarSer020 (赞：50)

注意到这题数据随机。

我们充分发扬人类智慧：

将序列排序后，将每个位置向后 $10$ 个位置的差记录下来，进行排序。

根据数学直觉，如果在记录的前 $500$ 小个数中都没有在当前区间内的解，那么这次询问的值域一定不会很大，暴力计算即可。

这样速度快得飞起，在 $n=10^5$ 时都可以在 1.39s 内卡过。

---

## 作者：louhao088 (赞：30)

以下做法无需借助数据随机这一性质，在数据不随机的情况下也能通过。


------------


我们考虑对答案有贡献的点对。

对于 $i<j,a[i]<a[j]$ 的点对，

我们考虑，如果 $x$ 是 $i$ 之后对答案有贡献的第一个点 ，那么 $ a[x]  $ 的值必定在 $[a[i]+1,inf)$ 中，且 $x$ 是满足这个条件在 $[i+1,n]$ 中最小的点。如果 $y$ 是 $i$ 之后对答案有贡献的第二个点,那么 $ a[x]  $ 的值必定 $[a[i]+1,\frac{a[x]+a[i]}{2})$ 中，且 $y$ 是满足这个条件在 $[x+1,n]$ 中最小的点。依次类推。

我们发现每次寻找一个点，值域都会减半，这样每个点至多只存在  $O(\log n)$ 个点能对答案产生贡献，一共只有 $O(n \log n)$ 个点对。我们对这些点对做扫描线即可，这个具体可以用树状数组维护。具体寻找这 $n \log n$ 个点对，我们只要在权值线段树上统计最小出现位置，然后询问最小值即可。

对于 $i<j,a[i]>a[j]$ 类似处理即可。
 
查询答案只要在处理点对的同时在树状数组上询问最小值即可。

时间复杂度 $O(n \log^2 n)$

注意题目中最接近的两数之差不能是相等两的数，需要特判。


------------
代码如下


```cpp
#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define pi pair<int,int>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define mid (l+r>>1)
#define lowbit(x) (x&-x)
const int maxn=3e5+5,M=34005,inf=0x3f3f3f3f;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
inline void print(int x)
{
    static int a[55];int top=0;
    if(x<0) putchar('-'),x=-x;
    do{a[top++]=x%10,x/=10;}while(x);
    while(top) putchar(a[--top]+48);
}
int n,m,a[maxn],l,r,ans[maxn],ls[maxn*32],rs[maxn*32],Max[maxn*32],Rt,c[maxn],tot=0;
vector<pi>q[maxn];
void add(int x,int num){if(num==0)return;for(int i=x;i;i-=lowbit(i))c[i]=min(c[i],num);}
int qry(int x){int res=inf;for(int i=x;i<=n;i+=lowbit(i))res=min(c[i],res);return res;}
void change(int &rt,int l,int r,int pos,int num)
{
	if(l>pos||r<pos)return;
	if(!rt)rt=++tot;Max[rt]=max(Max[rt],num);
	if(l==r)return;change(ls[rt],l,mid,pos,num);change(rs[rt],mid+1,r,pos,num);
}
int query(int rt,int l,int r,int L,int R)
{
	if(!rt)return 0;
	if(l>R||r<L)return 0;
	if(l>=L&&r<=R)return Max[rt];
	return max(query(ls[rt],l,mid,L,R),query(rs[rt],mid+1,r,L,R));
}
void solve()
{
	memset(ls,0,sizeof ls);memset(rs,0,sizeof rs);Rt=0,tot=0;
	memset(Max,0,sizeof Max);memset(c,0x3f,sizeof c);
	for(int i=1;i<=n;i++)
	{
		int x=query(Rt,0,inf,a[i],inf);
		while(x)
		{
			add(x,a[x]-a[i]);if(a[x]-a[i]==0)break;
			x=query(Rt,0,inf,a[i],(a[i]+a[x])/2);
		}
		change(Rt,0,inf,a[i],i);
		for(auto j:q[i])ans[j.se]=min(ans[j.se],qry(j.fi));
	}
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	memset(ans,0x3f,sizeof ans);
	n=read();m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)l=read(),r=read(),q[r].pb(mp(l,i));
	solve();for(int i=1;i<=n;i++)a[i]=inf-a[i];solve();
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
 	return 0;
}
```


---

## 作者：yummy (赞：25)

## 背景

当初收藏这道题，就是因为看到这句“数据为全部纯随机生成”，于是想着训练一下自己的骗分能力。

我在想自己的骗分策略前，我看了眼题解区，感觉非常高级，加上这题本来就是一个黑题，于是我吓坏了，一直放在收藏夹里没动。

然后就咕到了今天。

今天我想到了一种比题解区做法简单易行得多，不需要任何高级数据结构的做法，算了下感觉非常合理，于是写了一下。

## 做法

我们猜测询问的答案一定是极小的。如果我们找到了全局相差最小的两个数，那么所有包含这两个数字的区间对应的答案一定是这两个数。

因此首先可以每次从所有可能的数对中找到差距最小的一对，用这一对更新一遍答案，然后把这一对逐出优先队列，重复 $Upd$ 次。

然后我们相信如果前 $Upd$ 对数对都没有成功覆盖某一次询问，那么这次询问的区间肯定非常小，直接暴力解决即可。

使用一些小学奥数可以知道随机选取两个区间 $[a,b],[c,d]$，$[c,d]\subseteq [a,b]$ 的概率高达 $1/6$。但是我们只要能过题就可以了，肯定希望不超时的前提下 $Upd$ 越大越好。我这里取 $Upd=600$。

下面给出参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Upd=600;
int n,q,rq,a[100005],ans[100005],ord[100005],stat[100005];
struct query{int id,l,r;}rg[100005];
bool cmp(int x,int y){if(a[x]==a[y])return x<y;return a[x]<a[y];}
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;
int main()
{
	scanf("%d%d",&n,&q);rq=q;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		ord[i]=i;//记录排完序的第 i 项原来第几个
	}
	for(int i=1;i<=q;i++)
	{
		scanf("%d%d",&rg[i].l,&rg[i].r);
		rg[i].id=i;
	}
	sort(ord+1,ord+n+1,cmp);
	for(int i=1;i<=n;i++)//把每个数为右端点的最小区间丢进单调队列
	{
		if(a[ord[i]]==a[ord[i-1]])
			stat[i]=stat[i-1];
		else stat[i]=i-1;
		if(stat[i])
			pq.push(make_pair(a[ord[i]]-a[ord[stat[i]]],i));
	}
	for(int cnt=1;cnt<=Upd;cnt++)
	{
		if(pq.size()==0)break;
		auto qf=pq.top();pq.pop();
		int qfs=qf.second,diff=qf.first,l=ord[stat[qfs]],r=ord[qfs];
		if(l>r)swap(l,r);//得到最小值所在的a[l],a[r]
		for(int i=1;i<=q;i++)
			if(rg[i].l<=l && r<=rg[i].r)
			{
				ans[rg[i].id]=diff;//如果包含a[l],a[r]就更新
				rg[i]=rg[q];
				q--;i--;//将该询问弹出待求询问数组
			}
		stat[qfs]--;//把这个区间废掉，此时左端点-1
		if(stat[qfs])//如果区间合法就入队
			pq.push(make_pair(a[ord[qfs]]-a[ord[stat[qfs]]],qfs));
	}
	for(int ii=1;ii<=q;ii++)//剩下q次询问都暴力解决
	{
		int l=rg[ii].l,r=rg[ii].r;
		for(int x=l;x<=r;x++)
			stat[x]=a[x];
		sort(stat+l,stat+r+1);
		auto lst=unique(stat+l,stat+r+1);
		int Ans=0x3f3f3f3f;
		for(int *i=stat+l;i<lst-1;i++)
			Ans=min(Ans,*(i+1)-*i);
		ans[rg[ii].id]=Ans;
	}
	for(int i=1;i<=rq;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Gmt丶FFF (赞：13)

分块大法好。

直接分块，记录 $f_{i,j}$ 为第 $i$ 块到下标为 $j$ 最近两数差的绝对值的最小值，我们先将块内所有元素排序，然后查询时对于 $l,r$ 在同一块，由于元素已排好，直接暴力找下标在 $l$ 到 $r$ 内的，然后找最小相邻两数之差即可。若不在同一块，我们先对于边角料对整块的贡献，可以直接查询 $f$ 数组，对于边角料之间的贡献，直接双指针暴力跑，将两边边角料归并起来以后找相邻两数之差最小值。

至于维护 $f$ 数组，我们先求出一个块对一个点的贡献，那么对于每一个块，我们拿另一个块的数一起跑双指针，将两边归并起来，求块对点的贡献即为原块的最小值与点在块中的前驱后继差的最小值中的最小值。求出块对点的贡献后，用前缀最小值即可找到一个块对于另一个块的前驱或后继的贡献，再跑一遍前缀最小值即可求得区间块对一个块前缀的共献，再求出块与块之间的贡献，即可求出 $f$ 数组，具体实现可以看代码。

时间复杂度：$O(n\sqrt n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e5+5;
const int K=316;
const int M=N/K+5;
int cnwr,wr[40];
inline void write(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(!x)putchar('0');
	while(x)wr[++cnwr]=x%10,x/=10;
	while(cnwr)putchar(wr[cnwr]^48),cnwr--; 
}
inline int read()
{
	char ch=getchar();
	int sum=0;
	bool f=0;
	while(ch<'0'||ch>'9')f|=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')sum=(sum<<1)+(sum<<3)+(ch^48),ch=getchar();
	return f?-sum:sum;
}
char s1;
int n,m,b[N],L[M],R[M],f[M][N],q[N],cnt,p[N],s[N],pre[N],suf[N];
bool vis[N];
struct node
{
	int name,data;
}a[N];
char s2;
bool cmp(node x,node y)
{
	return x.data<y.data;
}
inline int solve1(int l,int r)
{
	cnt=0;
	for(int i=L[b[l]];i<=R[b[l]];i++)if(a[i].name>=l&&a[i].name<=r)q[++cnt]=a[i].data;
	int ans=1e9;
	for(int i=2;i<=cnt;i++)if(q[i]-q[i-1])ans=min(ans,q[i]-q[i-1]);
	return ans;
}
inline int solve2(int l,int r)
{
	cnt=0;
	int x=L[b[l]],y=L[b[r]];
	while(x<=R[b[l]]&&y<=R[b[r]])
	{
		if(a[x].data<a[y].data)
		{
			if(a[x].name<l)x++;
			else q[++cnt]=a[x++].data;
		}
		else 
		{
			if(a[y].name>r)y++;
			else q[++cnt]=a[y++].data;
		}
	}
	while(x<=R[b[l]])
	{
		if(a[x].name<l)x++;
		else q[++cnt]=a[x++].data;
	}
	while(y<=R[b[r]])
	{
		if(a[y].name>r)y++;
		else q[++cnt]=a[y++].data;
	}
	int ans=1e9;
	for(int i=2;i<=cnt;i++)if(q[i]-q[i-1])ans=min(ans,q[i]-q[i-1]);
	if(b[l]+1<b[r])ans=min(ans,min(f[b[r]-1][l],f[b[l]+1][r]));
	return ans;
}
int main()
{
//	freopen("data.in","r",stdin);
//	freopen("data.out","w",stdout);
//	cerr<<(((&s1)-(&s2))>>20);
	n=read();m=read();
	for(int i=1;i<=n;i++)a[i]={i,read()},b[i]=i/K+1;
	for(int i=1;i<=b[n];i++)L[i]=max(1,(i-1)*K),R[i]=min(n,i*K-1),sort(a+L[i],a+R[i]+1,cmp); 
	for(int i=1;i<=b[n];i++)
	{	
		for(int k=i-1;k>=1;k--)
		{
			cnt=0;
			int l=L[i],x=L[k];
			while(l<=R[i]&&x<=R[k])
			{
				if(a[l].data<a[x].data)q[++cnt]=a[l].data,p[a[l++].name]=cnt,vis[cnt]=0;
				else q[++cnt]=a[x++].data,vis[cnt]=1;
			}
			while(l<=R[i])q[++cnt]=a[l].data,p[a[l++].name]=cnt,vis[cnt]=0;
			while(x<=R[k])q[++cnt]=a[x++].data,vis[cnt]=1;
			int ans=1e9;
			for(int j=L[k]+1;j<=R[k];j++)if(a[j].data-a[j-1].data)ans=min(ans,a[j].data-a[j-1].data);
			int num=-1e9;
			for(int j=1;j<=cnt;j++)
			{
				if(vis[j])num=q[j];
				pre[j]=num;
			}
			num=2e9;
			for(int j=cnt;j>=1;j--)
			{
				if(vis[j])num=q[j];
				suf[j]=num;
			}
			for(int j=L[i];j<=R[i];j++)
			{
				f[k][j]=ans;
				if(q[p[j]]-pre[p[j]])f[k][j]=min(f[k][j],q[p[j]]-pre[p[j]]);
				if(suf[p[j]]-q[p[j]])f[k][j]=min(f[k][j],suf[p[j]]-q[p[j]]);
			}
			for(int j=L[i]+1;j<=R[i];j++)f[k][j]=min(f[k][j],f[k][j-1]);
			if(k+1!=i)for(int j=L[i];j<=R[i];j++)f[k][j]=min(f[k][j],min(f[k+1][j],f[k][L[i]-1]));
		}
	}
	for(int i=b[n];i>0;i--)
	{
		for(int k=i+1;k<=b[n];k++)
		{
			cnt=0;
			int l=L[i],x=L[k];
			while(l<=R[i]&&x<=R[k])
			{
				if(a[l].data<a[x].data)q[++cnt]=a[l].data,p[a[l++].name]=cnt,vis[cnt]=0;
				else q[++cnt]=a[x++].data,vis[cnt]=1;
			}
			while(l<=R[i])q[++cnt]=a[l].data,p[a[l++].name]=cnt,vis[cnt]=0;
			while(x<=R[k])q[++cnt]=a[x++].data,vis[cnt]=1;
			int ans=1e9;
			for(int j=L[k]+1;j<=R[k];j++)if(a[j].data-a[j-1].data)ans=min(ans,a[j].data-a[j-1].data);
			int num=-1e9;
			for(int j=1;j<=cnt;j++)
			{
				if(vis[j])num=q[j];
				pre[j]=num;
			}
			num=2e9;
			for(int j=cnt;j>=1;j--)
			{
				if(vis[j])num=q[j];
				suf[j]=num;
			}
			for(int j=L[i];j<=R[i];j++)
			{
				f[k][j]=ans;
				if(q[p[j]]-pre[p[j]])f[k][j]=min(f[k][j],q[p[j]]-pre[p[j]]);
				if(suf[p[j]]-q[p[j]])f[k][j]=min(f[k][j],suf[p[j]]-q[p[j]]);
			}
			for(int j=R[i]-1;j>=L[i];j--)f[k][j]=min(f[k][j],f[k][j+1]);
			if(k-1!=i)for(int j=L[i];j<=R[i];j++)f[k][j]=min(f[k][j],min(f[k-1][j],f[k][R[i]+1]));
		}
	}
	for(int i=1;i<=m;i++)
	{
		int l=read(),r=read(),ans;
		if(b[l]==b[r])ans=solve1(l,r);
		else ans=solve2(l,r);
		write(ans);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：peterwuyihong (赞：10)

题意：给定一个序列，每次查询一个区间，求其中最接近的不同两个数之差。

直接莫队

加入一个数就塞进一个压位 $\text{Trie}$，动态维护答案，删除不好操作，直接回滚滚掉就行了。

复杂度 $O(n\sqrt n\log_{64}n)$，跑得十分的快啊！

使用了 $\texttt{myee}$ 的模板，来自于秃子酋长

```cpp
#define maxn 100050
#define ullt unsigned long long
const int Dep=6,W=64,LogW=6,And=W-1,Val=1073741824;
ullt BUFF[Val>>LogW<<1|1];
ullt*BT=BUFF+sizeof(BUFF)/sizeof(ullt);
ullt*NewMemory(int siz){return BT-=siz;}
inline int hp(ullt v){return W-__builtin_clzll(v)-1;}
inline int lp(ullt v){return __builtin_ctzll(v);}
struct Trie 
{
	ullt*Node[Dep-1];
	Trie(){for(int i=0;i+1<Dep;i++)Node[i]=NewMemory(1llu<<(LogW*i));}
	inline void insert(int v)
	{
		for(int i=Dep-2;~i;i--)
		{
			if(Node[i][v>>LogW]>>(v&And)&1)return;
			Node[i][v>>LogW]|=1llu<<(v&And),v>>=LogW;
		}
	}
	inline void erase(int v)
	{
		if(!(Node[Dep-2][v>>LogW]>>(v&And)&1))return;
		for(int i=Dep-2;~i;i--)
		{
			Node[i][v>>LogW]&=~(1llu<<(v&And)),v>>=LogW;
			if(Node[i][v])return;
		}
	}
	inline int pre(int v)
	{
		for(int i=Dep-2;~i;i--,v>>=LogW)
			if(Node[i][v>>LogW]&~((-1llu)<<(v&And)))
			{
				int p=hp(Node[i][v>>LogW]&~((-1llu)<<(v&And)))|(v>>LogW<<LogW);
				while(++i<=Dep-2)p=(p<<LogW)|hp(Node[i][p]);
				return p;
			}
        return 0;

	}
	inline int suf(int v)
	{
		for(int i=Dep-2;~i;i--,v>>=LogW)
			if(Node[i][v>>LogW]&((-1llu)<<(v&And)<<1))
			{
				int p=lp(Node[i][v>>LogW]&((-1llu)<<(v&And)<<1))|(v>>LogW<<LogW);
				while(++i<=Dep-2)p=(p<<LogW)|lp(Node[i][p]);
				return p;
			}
        return 0;
	}
}T;
int n,m;
int a[100010];
int pos[100010],blo;
struct Q{
  int l,r,id;
  inline bool operator<(Q x)const{
    if(pos[l]^pos[x.l])return l<x.l;
    return r<x.r;
  }
}q[100010];
int ans[300010],res,R[100010];
int app[100010],b[100010],cnt,c[100010];
void add(int x,int &G){
  if(++app[c[x]]==1)T.insert(a[x]);
  int p=T.pre(a[x]),q=T.suf(a[x]);
  if(p)G=min(G,abs(a[x]-p));
  if(q)G=min(G,abs(q-a[x]));
}
void del(int x){
  if(--app[c[x]]==0)T.erase(a[x]);
}
int d[maxn];
int bf(int l,int r){
  rep(i,l,r)d[i]=a[i];
  sort(d+l,d+r+1);
  int ans=INT_MAX;
  rep(i,l,r-1)ans=min(ans,d[i+1]-d[i]);
  return ans;
}
signed main(){
  cin>>n>>m;
  rep(i,1,n)cin>>a[i],a[i]++,b[i]=a[i];
  sort(b+1,b+n+1);
  cnt=unique(b+1,b+n+1)-b-1;
  rep(i,1,n)c[i]=lower_bound(b+1,b+cnt+1,a[i])-b;
  blo=256;
  rep(i,1,m)cin>>q[i].l>>q[i].r,q[i].id=i;
  rep(i,1,n)pos[i]=(i-1)/blo+1,R[pos[i]]=i;
  sort(q+1,q+m+1);
  int l=R[1]+1,r=R[1],lst=0;
  rep(i,1,m){
    if(pos[q[i].l]==pos[q[i].r])ans[q[i].id]=bf(q[i].l,q[i].r);
    else{
      if(pos[q[i].l]!=lst){
        lst=pos[q[i].l];
        rep(j,l,r)del(j);
        res=INT_MAX;
        l=R[lst]+1,r=R[lst];
      }
      while(r<q[i].r)add(++r,res);
      int tmp=res;
      while(l>q[i].l)add(--l,tmp);
      while(l<R[lst]+1)del(l++);
      ans[q[i].id]=tmp;
    }
  }
  rep(i,1,m)cout<<ans[i]<<endl;
}
```

---

## 作者：冯老师 (赞：8)

**[cnblogs](https://www.cnblogs.com/MnZnOIerLzy/articles/17743728.html)**

lxl 上课讲的题，来写个题解。

双倍经验：[CF765F](https://www.luogu.com.cn/problem/CF765F)。

三倍经验：[CF1793F](https://www.luogu.com.cn/problem/CF1793F)。

**[题目传送门](https://www.luogu.com.cn/problem/P5926)**

> - 给出序列 $a_1\sim a_n$，有 $q$ 次询问，每次询问给出 $l,r$，求两个数 $i,j\,(l\le i,j\le r)$ 满足 $a_i\ne a_j$ 且 $|a_i-a_j|$ 最小。输出这个最小值。
>
> - $n,q\le 10^5$。设值域为 $V$，$|V|\le 10^9$。

不妨令 $i<j$。称 $|a_i-a_j|$ 为点对 $(i,j)$ 的权值。

一个朴素的想法是，把所有的点对 $(i,j)$ 的值计算出来，然后就是做满足 $l\le i$ 且 $j\le r$ 的二维偏序。

但是真的所有 $(i,j)$ 都有贡献吗？考虑这样一种情况：$i<j_1<j_2$ 且 $a_i< a_{j_1}\le a_{j_2}$，若 $[l,r]$ 包含了 $(i,j_2)$ 这个点对，就一定包含了 $(i,j_1)$ 这个点对，而且 $|a_i-a_{j_1}|\le |a_i-a_{j_2}|$，所以 $(i,j_2)$ 这个点对没有贡献。这时我们称 **$\boldsymbol{(i,j_1)}$ 支配了 $\boldsymbol{(i,j_2)}$**。

简单理解一下，一个点对能够支配另一个点对，**当且仅当这个点对的限制更宽松，且权值不超过另一个点对**。

考虑把所有有贡献的点对 $(i,j)$ 找出来。先固定左点 $i$ 按顺序一个个从左往右找。分为两种情况：

- $a_i<a_j$，此时权值 $|a_i-a_j|=a_j-a_i$。

    设当前找到 $(i,p)$ 是有贡献的点对，考虑怎样的 $(i,q)$（满足 $p<q$）仍然有贡献。首先 $a_i<a_q<a_p$，不然 **$\boldsymbol{(i,p)}$ 会支配 $\boldsymbol{(i,q)}$**。 
    
    其次，$a_q-a_i<a_p-a_q$，不然 **$\boldsymbol{(p,q)}$ 会支配 $\boldsymbol{(i,q)}$**。此时我们将不等式变形，会发现 $\boldsymbol{a_q-a_i< \dfrac{a_p-a_i}{2}}$，即**权值至少减半**。因此以 $i$ 为左点的有贡献点对**不会超过 $\boldsymbol{{O}(\log|V|)}$ 个**。
    
    因为找到 $O(\log |V|)$ 个点对后，权值已经变成 $0$，由于点对的权值是绝对值，显然不可能再找到一个点对，使得它的值小于 $0$。
    
    此时，$a_i<a_q<\dfrac{a_i+a_p}{2}$。
    
- $a_i>a_j$ 的情况类似分析即可。

这么一来，需要保留的点对就只有 $O(n\log|V|)$ 个。更严谨地来讲，与其说上面的过程是在找出所有有贡献的点对，不如说是去除一些点对，使得剩下的点对包含最优解，且数量可以接受。

为了配合上述过程找出有贡献点对，我们需要支持这个操作：

> 查询一个最小的位置 $x$，使得 $x>y$ 且 $a_x\in[u,v]$。

没懂这一步大佬们是如何不可持久化做的，只能来介绍一下我的憨憨做法。建立一棵可持久化权值线段树，版本 $i$ 的线段树维护的是每种权值在 $[i,n]$ 中出现的最左位置，节点内维护区间最小值。若某种权值未出现，则设为无穷大。查询的时候，在 $y+1$ 版本查询 $[u,v]$ 的最小值。

设为未出现的权值设为无穷大的意义就体现出来了，我要查询的是出现过的数的最小位置，没出现过的数因为权值无穷大，会在取最小值时被舍去。若查询结果为最小值，则不存在这样的数，说明不能找到更多的点对了。

把所有有贡献的点对保留后，离线询问，将第一维降序排序（修改在前），用权值树状数组维护第二维的限制。

时间复杂度为 $O(n\log^2|V|)$，空间复杂度为 $O(n\log |V|)$。

**[提交记录](https://www.luogu.com.cn/record/127783717)**

```cpp
#include <bits/stdc++.h>
#define lb(x) ((x) & (-(x)))
using namespace std; const int N = 1e5 + 2, inf = 0x3f3f3f3f, L = 0, R = 1e9; 
int n, a[N], m, cnt, ans[N << 2];
template<class T> void read(T &x) {
    x = 0; T f = 1; char c = getchar();
    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - 48; x *= f;
}
template<class T> void write(T x) {
    if (x > 9) write(x / 10); putchar(x % 10 + 48);
}
template<class T> void print(T x, char ed = '\n') {
    if (x < 0) putchar('-'), x = -x; write(x), putchar(ed);
}
struct ChairmanTree {
    int ls[N * 31], rs[N * 31], mn[N * 31], rt[N * 31], cnt;
    void init() {
        memset(ls, 0, sizeof ls); memset(mn, 0x3f, sizeof mn);
        memset(rs, 0, sizeof rs); memset(rt, cnt = 0, sizeof rt);
    }
    void modify(int &x, int y, int l, int r, int k, int v) {
        x = ++cnt; mn[x] = min(mn[y], v); 
        if (l == r) return; int mid = (l + r) >> 1;
        if (k <= mid) rs[x] = rs[y], modify(ls[x], ls[y], l, mid, k, v);
        else ls[x] = ls[y], modify(rs[x], rs[y], mid + 1, r, k, v);
    }
    int query(int x, int l, int r, int ql, int qr) {
        if (!x || ql > qr) return inf; 
        if (ql <= l && r <= qr) return mn[x]; int mid = (l + r) >> 1, ret = inf;
        if (ql <= mid) ret = query(ls[x], l, mid, ql, qr);
        if (qr > mid) ret = min(ret, query(rs[x], mid + 1, r, ql, qr)); return ret;
    }
} T;
struct BinaryIndexedTree {
    int mn[N]; void init() { memset(mn, 0x3f, sizeof mn); }
    void modify(int x, int v) { 
        while (x <= n) mn[x] = min(mn[x], v), x += lb(x); 
    }
    int query(int x) {
        int ret = inf; while (x) ret = min(ret, mn[x]), x -= lb(x); return ret;
    }
} B;
struct node { int x, y, id; } p[N * 40]; 
signed main() {
    read(n); read(m); for (int i = 1; i <= n; ++i) read(a[i]); T.init();
    T.modify(T.rt[n], T.rt[n + 1], L, R, a[n], n); B.init();
    for (int i = n - 1, v; i >= 1; --i) {
        int pos = T.query(T.rt[i + 1], L, R, a[i] + 1, R);
        while (pos != inf) {
            v = ((a[i] + a[pos]) >> 1) - (((a[i] + a[pos]) & 1) ^ 1);
            p[++cnt] = {i, pos, 0}; pos = T.query(T.rt[pos + 1], L, R, a[i] + 1, v);
        }
        T.modify(T.rt[i], T.rt[i + 1], L, R, a[i], i);
    }
    T.init(); T.modify(T.rt[n], T.rt[n + 1], L, R, a[n], n); 
    for (int i = n - 1, v; i >= 1; --i) {
        int pos = T.query(T.rt[i + 1], L, R, L, a[i] - 1);
        while (pos != inf) {
            p[++cnt] = {i, pos, 0}; v = ((a[i] + a[pos]) >> 1) + 1;
            pos = T.query(T.rt[pos + 1], L, R, v, a[i] - 1);
        }
        T.modify(T.rt[i], T.rt[i + 1], L, R, a[i], i);
    }
    for (int i = 1, l, r; i <= m; ++i) { read(l), read(r); p[++cnt] = {l, r, i}; }
    stable_sort(p + 1, p + cnt + 1, [&](node u, node v) { 
        return u.x != v.x ? u.x > v.x : !u.id; 
    });
    for (int i = 1; i <= cnt; ++i)
        if (p[i].id) ans[p[i].id] = B.query(p[i].y);
        else B.modify(p[i].y, abs(a[p[i].x] - a[p[i].y]));
    for (int i = 1; i <= m; ++i) print(ans[i]); return 0;
}
```


---

## 作者：听取MLE声一片 (赞：8)

第一次自己完全独立做出黑题，写篇题解纪念一下。

本做法依赖数据随机，实测未卡常能跑最优解 rk3。

设阈值 $T=200$。

先写出一个暴力求出区间最接近不等点对位置和值的函数。

对询问离线处理，然后对询问分治。

设一个区间 $[l,r]$ 的区间最接近不等点对位置分别为 $p,q$，最小值为 $s$。

因为数据纯随机，可以认为 $p,q$ 在 $[l,r]$ 之间随机分布，即 $p,q$ 大概在 $[l,r]$ 的两个三等分点上。

考虑分治，对于一个区间 $[l,r]$，如果长度不大于 $T$ 暴力即可。

在当前区间 $[l,r]$，找出对应的 $p,q$，包含于此区间的所有询问区间可以划分成三部分：

- 包含 $[p,q]$。

- 属于 $[l,q)$。

- 属于 $(p,r]$。

第一部分的答案都等于 $s$，不需要继续分治。

然后对区间 $[l,q)$ 和 $(p,r]$ 分治。

按照随机进行分析，即每次的 $p,q$ 都在 [l,r] 的三等分点上。

如果每次分治三个部分都存在询问区间，每次总长度会乘 $\frac{2}{3}+\frac{2}{3}=\frac{4}{3}$，每段长度会乘 $\frac{2}{3}$。

设分治某一层的总长度为 $m$，那么处理这一层的时间复杂度为 $O(m\log m)$，这个 $m$ 每层都会乘 $\frac{4}{3}$。

总长度每层都在增长，这样真的能过吗？

观察 $\frac{2}{3}$ 和 $\frac{4}{3}$，发现在开始的时候，每段长度缩小的比总长度增长的快！当 $n=100000$ 时，仅仅需要 $15$ 层分治区间长度即可达到 $228$，而对首项为 $1$，公比为 $\frac{4}{3}$ 的等比数列的前 $15$ 项求和，结果仅仅有 $221$！这个 $221$ 表示前 $15$ 层所有段的总和仅仅有 $221n$，也就是 $2\times 10^7$。然后每次排序乘上一个 $\log n$，运算量上界为 $2\times 10^8$。

因为有大量属于第一部分的答案，还有不少第二三部分的为空，实际上达不到上限。

这个 $l$ 和 $r$ 可以分别取询问集合 $Q$ 中左端点的最小值和右端点的最大值，可以优化不少。

综上，可以通过本题。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#define pii pair<int,int>
#define mkp make_pair
#define fi first
#define se second
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=1e5+10;
int n,m,a[N],d[N];
struct point{
	int l,r,id,ans;
};
vector<point>q;
int cmp(point a,point b){
	return a.id<b.id;
}
struct node{
	int x,id;
}b[N];
int cmp1(node a,node b){
	return a.x<b.x;
}
pii calc(int l,int r){
	for(int i=l;i<=r;i++){
		b[i].x=a[i];
		b[i].id=i;
	}
	sort(b+l,b+r+1,cmp1);
	int res=1e9,x=0,y=0;
	for(int i=l;i<r;i++){
		if(b[i].x==b[i+1].x)
			continue;
		int s=abs(b[i].x-b[i+1].x);
		if(s<res){
			res=s;
			x=b[i].id;
			y=b[i+1].id;
		}
	}
	return mkp(min(x,y),max(x,y));
}
int get(int l,int r){
	for(int i=l;i<=r;i++)
		d[i]=a[i];
	sort(d+l,d+r+1);
	int res=1e9;
	for(int i=l;i<r;i++)
		if(d[i]!=d[i+1])
			res=min(res,abs(d[i]-d[i+1]));
	return res;
}
void solve(vector<point> &Q){
	if(Q.empty())
		return;
	int l=1e9,r=0;
	for(point p:Q){
		l=min(l,p.l);
		r=max(r,p.r);
	}
	if(r-l<=200){
		for(int i=0;i<Q.size();i++)
			Q[i].ans=get(Q[i].l,Q[i].r);
		return;
	}
	pii p=calc(l,r);
	int L=p.fi,R=p.se,s=abs(a[L]-a[R]);
	vector<point>q1,q2,q3;
	for(int i=0;i<Q.size();i++){
		int ll=Q[i].l,rr=Q[i].r;
		if(ll<=L&&R<=rr){
			Q[i].ans=s;
			q1.push_back(Q[i]);
			continue;
		}
		if(rr<R){
			q2.push_back(Q[i]);
			continue;
		}
		q3.push_back(Q[i]);
	}
	solve(q2);
	solve(q3);
	Q.clear();
	for(point P:q1)
		Q.push_back(P);
	for(point P:q2)
		Q.push_back(P);
	for(point P:q3)
		Q.push_back(P);
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=m;i++){
		int l=read(),r=read(),id=i;
		q.push_back({l,r,id,0});
	}
	solve(q);
	sort(q.begin(),q.end(),cmp);
	for(int i=0;i<q.size();i++){
		printf("%d",q[i].ans);
		putchar('\n');
	}
	return 0;
}

```

---

## 作者：yzy1 (赞：8)

这题为啥要数据随机啊，不随机不是照样做吗？

[双倍经验](/problem/CF765F)

- 看到允许离线，考虑离散化后莫队。
- 现在问题变成了：维护一个集合，支持加数删数，找一个数的前驱后继。
- 很显然，我们可以用树状数组或者 `std::set` 等维护这个集合，但是这样会让时间复杂度变为 $O(n \sqrt m \log n)$，无法通过此题。
- 我们换一种思路，直接把莫队换成回滚莫队（只加不删），同时值域分块。
- 考虑把查询时的贡献分为两类：来自不同块的和来自相同块的。不同块的可以在每个块内记录最小值和最大值来很方便的维护，问题是如何维护来自相同块的数的贡献。
- 我们可以直接把值域分块换成一个 bitset，然后用 bitset 的 `_Find_next` 来找到一个数的后继。前驱的维护同后继，可以开一个反向的 bitset 来维护。
- 我们设定值域分块的块长为 $B$，这样的话移动一次莫队端点的时间复杂度为 $O(\dfrac B w)$，查询时的时间复杂度为 $O(\dfrac n B)$。
- 设定莫队块长为 $\left \lceil \dfrac n{\sqrt m} \right\rceil$，则时间复杂度为 $O(\dfrac{n \sqrt mB}w + \dfrac{nm}B)$，当 $B=256$ 时速度较快，可以通过此题。

```cpp
const int N = 3e5 + 9;
const int bssz = 256;
const int lgsz = 8;
struct Q {
  int l, r, id;
} q[N];
int n, m, Ans[N], res = 1e9, sz;
unsigned a[N];
inline bool operator<(Q a, Q b) {
  return a.l / sz != b.l / sz ? a.l < b.l : a.r < b.r;
}
vector<int> vec;
typedef bitset<bssz> BS;
BS b1[N / bssz], b2[N / bssz], br[N / bssz];

inline int Baoli(int l, int r) {
  static int b[N];
  rep(i, l, r) b[i - l + 1] = vec[a[i]];
  sort(b + 1, b + r - l + 2);
  int ans = 1e9;
  re(i, r - l) down(ans, b[i + 1] - b[i]);
  return ans;
}

inline void Add(int x, bool typ) {
  unsigned bl = a[x] >> lgsz;
  if (!b1[bl][a[x] % bssz]) {
    if (unsigned y = b1[bl]._Find_next(a[x] % bssz); y != bssz)
      down(res, vec[y | (bl << lgsz)] - vec[a[x]]);
    if (unsigned y = b2[bl]._Find_next(~a[x] % bssz); y != bssz)
      down(res, vec[a[x]] - vec[~y % bssz | (bl << lgsz)]);
    b1[bl].set(a[x] % bssz), b2[bl].set(~a[x] % bssz);
  }
  if (typ)
    br[bl].set(a[x] % bssz);
}

inline void Del(int x) {
  unsigned bl = a[x] >> lgsz;
  b2[bl][~a[x] % bssz] = b1[bl][a[x] % bssz] = br[bl][a[x] % bssz];
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  cin >> m, sz = max<int>(1, n / sqrt(m));
  re(i, n) cin >> a[i], vec.push_back(a[i]);
  sort(vec.begin(), vec.end());
  auto ed = unique(vec.begin(), vec.end());
  re(i, n) a[i] = lower_bound(vec.begin(), ed, a[i]) - vec.begin();
  re(i, m) cin >> q[i].l >> q[i].r, q[i].id = i;
  sort(q + 1, q + m + 1);
  int lstb = 0, l = sz, r = l - 1;
  re(i, m) {
    if (q[i].l / sz == q[i].r / sz) {
      Ans[q[i].id] = Baoli(q[i].l, q[i].r);
      continue;
    }
    if (lstb != q[i].l / sz) {
      rep(i, 0, n >> lgsz) b1[i].reset(), b2[i].reset(), br[i].reset();
      l = (q[i].l / sz + 1) * sz, r = l - 1, res = 1e9;
    }
    while (r < q[i].r)
      Add(++r, 1);
    int bak = res;
    while (l > q[i].l)
      Add(--l, 0);
    int res2 = 1e9, lst = -1e9;
    rep(i, 0, n >> lgsz) if (b1[i].count())
        down(res2, vec[b1[i]._Find_first() | (i << lgsz)] - lst),
        lst = vec[~b2[i]._Find_first() % bssz | (i << lgsz)];
    Ans[q[i].id] = min(res, res2);
    while (l < (q[i].l / sz + 1) * sz)
      Del(l++);
    res = bak;
    lstb = q[i].l / sz;
  }
  re(i, m) cout << Ans[i] << '\n';
  return 0;
}
```

---

## 作者：Reunite (赞：8)

写在前面：我的做法理论时间复杂度并不优秀，但不失为分享的一种方法，快速好想，可以在三十分钟内一遍写完，可作为考场上高效的得分方法。
翻了一下，代码算是比较短的了。

## 一

看到没有修改，直接考虑莫队，两个游标的移动十分平凡，这里重点说说如何快速更新答案。

- 首先，直接将序列离散化，离散化后元素相对大小顺序不变。

- 开一棵线段树，记 $u$ 号节点所代表的区间为离散化后的值域区间 $[l,r]$，需要维护 $3$ 个信息：$mn[u],mx[u],as[u]$，分别表示，值域 $[l,r]$ 范围内目前出现过的最小的数，最大的数，和只考虑值域在 $[l,r]$ 范围内的答案。那么我们只要维护好这 $3$ 个信息，询问的答案就是 $as[1]$ 了。那么如何维护呢。

- 显然有：
$$mn[u]=\min(mn[u<<1],mn[u<<1|1])$$

$$mx[u]=\max(mx[u<<1],mx[u<<1|1]) $$

$$as[u]=\min(as[u<<1],as[u<<1|1],b[mn[u<<1|1]]-b[mx[u<<1]]) $$

上面的 $b$ 数组为原序列 $a$ 离散化后对应的值。

现在考虑单点修改，可以开一个桶记录当前区间内的元素出现次数，然后单点修改 $mn,mx,as$ 即可。一个卡常小技巧就是对于这种不需要懒惰标记，只有单点修改的线段树，可以直接非递归处理，此题询问也不需要递归，使得线段树实现的速度有较大提升。

块长不宜太大，实测取 $[200,300]$ 跑的效率还可以，加上数据保证随机，可以通过本题，但还是建议学习更优的复杂度做法。时间复杂度为 $O(n\sqrt{n}\log_2n)$。

## 二

代码很好写，一遍过的。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n,m,bl=250,cnt;
int a[100005];
int b[100005];
int h[100005];
int id[100005];
int mn[400005];
int mx[400005];
int as[400005];
int ans[100005];
struct node{int l,r,bl,id;}q[100005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline bool cmp(node p,node q){return p.bl==q.bl?(p.bl&1)?p.r<q.r:p.r>q.r:p.bl<q.bl;}

void build(int u,int l,int r){
	as[u]=1e9;
	mx[u]=-1,mn[u]=n+1;
	if(l==r){id[l]=u;return ;}
	int mid=(l+r)>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	return ;
}

inline void updata(int u,int x){
	h[u]+=x;
	int uu=u;
	u=id[u];
	if(h[uu]) mx[u]=mn[u]=uu;
	else mx[u]=-1,mn[u]=n+1;
	u>>=1;
	while(u){
		as[u]=min(as[u<<1],as[u<<1|1]);
		if(mx[u<<1]!=-1&&mn[u<<1|1]!=n+1) as[u]=min(as[u],b[mn[u<<1|1]]-b[mx[u<<1]]);
		mx[u]=-1,mn[u]=n+1;
		mx[u]=max({mx[u],mx[u<<1],mx[u<<1|1]});
		mn[u]=min({mn[u],mn[u<<1],mn[u<<1|1]});
		u>>=1;
	}
	return ;
}

int main(){
	in(n),in(m);
	for(int i=1;i<=n;i++) in(a[i]),b[i]=a[i];
	sort(b+1,b+1+n);
	cnt=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+1+cnt,a[i])-b;
	for(int i=1;i<=m;i++){
		in(q[i].l),in(q[i].r);
		q[i].bl=q[i].l/bl;
		q[i].id=i;
	}
	build(1,1,cnt);
	sort(q+1,q+1+m,cmp);
	int l=1,r=0;
	for(int i=1;i<=m;i++){
		int L=q[i].l,R=q[i].r;
		while(r<R) updata(a[++r],1);
		while(l>L) updata(a[--l],1);
		while(r>R) updata(a[r--],-1);
		while(l<L) updata(a[l++],-1);
		ans[q[i].id]=as[1];
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);

	return 0;
}

```

---

## 作者：zzqDeco (赞：6)

这道题的关键实际上在于最后的不起眼的**数据全部纯随机**

看到这一点给我们的提示在于，连续的上升下降子序列的期望长度都是 $log$ 级别的

由于数据是 $10^5$ 的，那么我们要基于这个得到一个 $O(nlog^2n)$ 左右的做法

我们可以得知，对于上升或者下降的序列，最小差一定在相邻取到

首先我们离线，这样我们就对于每一个数考虑

对于现在加入的数 $k$ ，找到前面的单调上升并且都比 $k$ 大的子序列，然后一一更新对于这些点来说与后面组成的最小值

现在就涉及到转移了，实际上我们用线段树维护一下值域，这样就变成了区间上找坐标最大的问题了

最后统计答案的时候就对于询问边界是右端点的统计一下所在区间的最小值就好

不难发现，由于随机数据的原因，单调段都是期望 $log$ 的所以维护复杂度是 $nlog^2n$ ，询问复杂度则很容易用 $log$ 数据结构做到

总复杂度 $O(nlog^2n+qlogn)$

至于代码太丑，就不贴了

#### 结尾

实际上这道题比较容易想到的做法是莫队，实际用一个平衡树维护值域跑莫队听说在之前某个死了的 OJ 是可以过的，洛谷开始卡的比较死（

---

## 作者：封禁用户 (赞：2)

### 分析

一道妙题。

这题要求我们求一个区间中相差最小的两个数之差，而且并没有要求强制在线，所以我们可以离线地回答这些询问。

从右到左扫描整个区间，按左端点从大到小对询问进行离线，每插入一个数，更新其贡献，并回答询问。

我们开一个权值线段树，来记录值域在某个范围内的最小下标。我们求出大于 $a_i$ 的下标最小的数，记为 $a_j$，更新 $j$ 点的答案。然后我们只需要查询 $[a_i+1,\frac{a_i+a_j}{2}]$ 的数字，因为如果这个数字大于 $\frac{a_i+a_j}{2}$，那么它和 $a_j$ 的差值一定更小。以此类推，每次折半查找，并更新答案，最多有 $\log{n}$ 次。

小于 $a_i$ 的数字同理。

所以，我们可以不需要原题中数据随机生成的特殊性质即可完成本题。

可以发现，我们更新答案的下标线段树和权值线段树都是进行单点修改、区间查询求最小值，所以可以合并成同一个结构体，注意这里的线段树需要动态开点。

时间复杂度：$O(n \log {n} \log N)$，其中 $N$ 为值域范围。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(register T &x)
{
	register T p = 1,num = 0;
	char c = getchar();
	while(c < '0'||c > '9')
	{
		if(c == '-') p = -p;
		c = getchar();
	}
	while('0' <= c&&c <= '9')
	{
		num = (num<<3)+(num<<1)+(c^48);
		c = getchar();
	}
	x = p * num;
}
template<typename T>inline void write(register T x)
{
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) write(x/10);
	putchar(x%10+48);
}
#define D(i,a,b) for(register int i=a;i>=b;--i)
#define F(i,a,b) for(register int i=a;i<=b;++i)
#define ll long long
#define pii pair<int,int>
#define M 100010
#define N 100010
vector<pii> g[N];
int n,m,a[N],ans[M];
struct Seg
{
	#define mid (l+r)/2
	int mn[N<<5],L[N<<5],R[N<<5],times;
	Seg()
	{
		times = 1;
		memset(mn,0x3f,sizeof(mn));
	}
	int update(int u,int l,int r,int x,int k)
	{
		if(!u) u = ++times; 
		if(l == r)
		{
			mn[u] = min(mn[u],k);
			return u;
		}
		if(x <= mid) L[u] = update(L[u],l,mid,x,k);
		else R[u] = update(R[u],mid+1,r,x,k);
		mn[u] = min(mn[L[u]],mn[R[u]]);
		return u;
	}
	int query(int u,int l,int r,int x,int y)
	{
		if(!u) return 2e9;
		if(x <= l&&r <= y) return mn[u];
		if(x <= mid&&y > mid) return min(query(L[u],l,mid,x,y),query(R[u],mid+1,r,x,y));
		if(x <= mid) return query(L[u],l,mid,x,y);
		return query(R[u],mid+1,r,x,y);
	}
	#undef mid
}tr1,tr2;
//tr1 权值线段树
//tr2 下标线段树 
int main()
{
	read(n),read(m);
	F(i,1,n) read(a[i]); 
 	F(i,1,m)
 	{
 		int l,r;
 		read(l),read(r);
 		g[l].push_back((pii){r,i});
	}
	tr1.update(1,0,1e9,a[n],n);
	D(i,n-1,1)
	{
		int x;
		x = tr1.query(1,0,1e9,a[i]+1,1e9);
		if(x <= 1e9&&x != i)
		{
			tr2.update(1,1,n,x,a[x]-a[i]);
			while(1)
			{
				x = tr1.query(1,0,1e9,a[i]+1,(a[i]+a[x]-1)/2);
				if(x > 1e9) break;
				tr2.update(1,1,n,x,a[x]-a[i]);
				if(a[x] == a[i]) break;
			}
		}  
		x = tr1.query(1,0,1e9,0,a[i]-1);
		if(x <= 1e9&&x != i)
		{
			tr2.update(1,1,n,x,a[i]-a[x]);
			while(1)
			{
				x = tr1.query(1,0,1e9,(a[i]+a[x]+1)/2,a[i]-1);
				if(x > 1e9) break;
				tr2.update(1,1,n,x,a[i]-a[x]);
				if(a[x] == a[i]) break;
			}
		}
		for(auto p:g[i]) ans[p.second] = tr2.query(1,1,n,i+1,p.first);
		tr1.update(1,0,1e9,a[i],i);  
	}
	F(i,1,m) write(ans[i]),putchar('\n');
	return 0;
}
```


---

## 作者：_998344353_ (赞：2)

此做法完全依赖数据随机这一性质，但不需要任何数据结构。

----

首先我们尝试找出数列中差最小的若干点对。

由于数据随机，所以可以用类似 [P1429](https://luogu.com.cn/problem/P1429)   的思路：先将原序列排序，然后枚举每一个位置，取这个位置前 $k$ 个数计算差的值并记录出现位置，最后将这些值排序；与 P1429 不同的是，由于数据随机，所以这种做法是有很大正确性保证的。

对于每个询问 $[l,r]$，若 $r-l+1\leq delta$ ，则直接 $n^2$ 暴力枚举区间内的所有点对更新最小值；

否则我们按照差从小到大判断每组点对是否被区间包含，若包含则直接输出答案；考虑到随机选两个区间 $[a,b]$，$[c,d]$，它们互相包含的概率大约为 $\frac{4}{24}=\frac{1}{6}$，所以判断次数可以接受。

实现的时候我们取 $k=80$，$delta=500$，可以通过全部测试点。

$k$ 的取值是由内存、排序速度和大数组访问速度决定的；取 $k=80$ 时这部分的运算量大概在 $10^8$ 级别，可以接受。

关于 $delta$ 的取值：考虑这部分的复杂度约为 $(1-\frac{(n-delta)^2}{n^2}) \times delta^2$，取 $delta=500$ 时运算量在 $10^7$ 级别，可以接受；过大会导致这部分复杂度过大而 TLE，过小会导致点对被部分区间包含的概率过低，另一部分复杂度过大同样会 TLE。

代码：

```cpp

#include <bits/stdc++.h>
using namespace std;
#define ll int
ll n,m,i,j,b[100005];
struct qwq
{
    ll x,y;
}a[100005];
struct qaq
{
    ll x,y,w;
}c[8000005];
bool cmp(qwq qwe,qwq rty)
{
    return qwe.x<rty.x;
}
bool cmp2(qaq qwe,qaq rty)
{
    return qwe.w<rty.w;
}
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i].x);
        b[i]=a[i].x;
        a[i].y=i;
    }
    ll sz=0;
    sort(a+1,a+n+1,cmp);
    for(i=2;i<=n;i++)
    {
        for(j=max(1,i-80);j<i;j++)
        {
            if(a[i].x!=a[j].x)
            {
                c[++sz].w=a[i].x-a[j].x;
                c[sz].x=min(a[i].y,a[j].y);
                c[sz].y=max(a[i].y,a[j].y);
            }
            else
            break;
        }
    }
    sort(c+1,c+sz+1,cmp2);
    ll l,r;
    while(m--)
    {
        scanf("%d%d",&l,&r);
        if(r-l<=500)
        {
            ll minn=1145141111;
            for(i=l;i<=r;i++)
            {
                for(j=l;j<i;j++)
                {
                    if(b[i]!=b[j])
                    {
                        minn=min(minn,abs(b[i]-b[j]));
                    }
                }
            }
            printf("%d\n",minn);
            continue;
        }
        for(i=1;i<=sz;i++)
        {
            if(l<=c[i].x&&c[i].y<=r)
            {
                printf("%d\n",c[i].w);
                break;
            }
        }
    }
    return 0;
}
```




---

## 作者：_Fontainebleau_ (赞：1)

### 题意

- 给定一个长度为 $n$ 的数列 $\left\{a_i\right\}$，以及 $q$ 个询问。
- 每次询问给定 $l,r$，求 $\displaystyle\min_{l\le{i,j\le{r},a_i\neq{a_j}}}\left|a_i-a_j\right|$。
- $1\le{n,q}\le10^5$。

### 做法

这个东西是可以离线的。所以我们把询问离线下来，套路地按右端点排序，然后从左到右枚举右端点 $r$。

先看满足 $a_l<a_r$ 的 $(l,r)$。

对于 $a_r$，若 $\exists{x<r}:a_x>a_r$，那么对于 $1<l\le{x}$ 的 $l$，都增加了一个 $a_r-a_l$ 的备选答案。然后我们只需要用一个 BIT 去维护 $\min$ 就可以了。

如此反复，又有可能 $\exists{y<x}:a_y>a_r$，如果要有可能对答案做出贡献，就需要 $a_r-a_y<a_r-a_x,a_r-a_y<a_y-a_x$，也就是 $a_r<a_y<\dfrac{a_r+a_y}2$。那么我们再用一个权值线段树维护一下即可。每次选区间内最右侧的位置。不断选下去，每次值域减半，所以不会超 $\log{r}$ 次。

然后 $a_r>a_l$ 的 $(l,r)$ 同理。

时间复杂度大约是 $O(n\log^2{n})$。

### 代码

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&-x
using namespace std;
const int INF=0x7f7f7f7f;
int n,a[100005],root[100005],tot,cnt,b[100005],Q,pos;
struct Ask{
	int l,r,id,ans;
}q[300005];

struct BIT{
	int minn[100005];
	void init(){memset(minn,0x7f,sizeof(minn));}
	void modify(int pos,int v){for(int i=pos;i<=n;i+=lowbit(i))	minn[i]=min(minn[i],v);}
	int query(int pos)
	{
		int Min=INF;
		for(int i=pos;i;i-=lowbit(i))	Min=min(Min,minn[i]);
		return Min;
	}
}bit;

struct SMT{
	#define ls(x) x<<1
	#define rs(x) x<<1|1
	int v[400005];
	void modify(int p,int l,int r,int pos,int val)
	{
		if(l==r){v[p]=val;return;}
		int mid=(l+r)>>1;
		if(pos<=mid)	modify(ls(p),l,mid,pos,val);
		else	modify(rs(p),mid+1,r,pos,val);
		v[p]=max(v[ls(p)],v[rs(p)]);
	}
	int query(int p,int l,int r,int x,int y)
	{
		if(x>y)	return 0;
		if(x<=l&&r<=y)	return v[p];
		int mid=(l+r)>>1,ans=0;
		if(x<=mid)	ans=query(ls(p),l,mid,x,y);
		if(y>mid)	ans=max(ans,query(rs(p),mid+1,r,x,y));
		return ans;
	}
}T;

inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f; 
}
inline bool cmp(Ask a,Ask b){return a.r<b.r;}
inline bool cmp1(Ask a,Ask b){return a.id<b.id;}
inline int Find(int x)
{
	int l=0,r=cnt;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(b[mid]<=x)	l=mid+1;
		else	r=mid-1;
	} 
	return l;
}

int main()
{
	n=read(),Q=read();
	for(int i=1;i<=n;i++)	a[i]=read(),b[++cnt]=a[i];
	sort(b+1,b+cnt+1);cnt=unique(b+1,b+cnt+1)-b-1;
	for(int i=1;i<=n;i++) 	a[i]=lower_bound(b+1,b+cnt+1,a[i])-b;
	for(int i=1;i<=Q;i++) 	q[i].l=read(),q[i].r=read(),q[i].id=i;
	sort(q+1,q+Q+1,cmp);
	pos=1;bit.init();
	for(int i=1;i<=n;i++)
	{
		if(i!=1) 
		{
			int R=cnt,L=a[i],x=T.query(1,1,cnt,L,R);
			while(x)
			{
				bit.modify(n-x+1,abs(b[a[x]]-b[a[i]]));
				R=Find((b[a[x]]+b[a[i]])/2);
				if(!R)	break;
				if(R>=a[x])	R=a[x]-1;
				x=T.query(1,1,cnt,L,R);
			}
			R=a[i],L=1,x=T.query(1,1,cnt,L,R);
			while(x)
			{
				bit.modify(n-x+1,abs(b[a[x]]-b[a[i]]));
				L=Find((b[a[x]]+b[a[i]])/2);
				if(!L)	break;
				if(L<=a[x])	L=a[x]+1;
				x=T.query(1,1,cnt,L,R);
			}
			while(q[pos].r==i)	q[pos].ans=bit.query(n-q[pos].l+1),pos++;
		}
		T.modify(1,1,cnt,a[i],i);
	}
	sort(q+1,q+Q+1,cmp1);
	for(int i=1;i<=Q;i++)	printf("%d\n",q[i].ans);
	return 0;
}

```

### 最后

[双倍经验.](https://www.luogu.com.cn/problem/CF765F)（不同之处：本题需要 $a_i\neq{a_j}$；经验题不需）


---

## 作者：Xy_top (赞：1)

跟着三倍经验黑来的，半天没过，最后发现是没判相同。

真不知道这个 NB 的 ds 做法是谁发明的，不过没找到讲清楚的人。。。

先将询问按照右端点排序，然后对于每个右端点，最朴素的做法是枚举所有它左边的点，将它们绝对值的差算出来，将包含它们的区间与这个值取个最小值即可。

但是是 $O(n^4)$ 的，所以就炸了。

对每个点前面的数，考虑分大小两类考虑，第一类是 $>a_i$ 的，第二类是 $<a_i$ 的。（由于要求不相等，所以 $=a_i$ 就没了）

来看 $>a_i$，首先找到在 $i$ 前面第一个大于 $i$ 的，设为 $a_j$，此时更新最值如果一个个暴力更新发现还是会超时，但是有个性质没用到：后面询问的右端点都是 $\geq i$ 的，所以右端点一定包含，就是左端点包不包含的问题了，这里可以把值与 $n$ 做差后放到树状数组上，查询查前缀最值就行了。

接着找下一个 $k$，使得 $a_k>a_i$，但是如果这样找还是会超时的，可以来推一下式子：

如果 $a_k-a_i \geq a_j-a_i$，那么 $k$ 是没有任何意义的，因为 $i$ $j$ 比 $i$ $k$ 优且所有包含 $i$ $k$ 的都包含 $i$ $j$。

推下上面式子就能够得到 $a_k < a_j$

以此类推，那么 $a_k-a_i<a_j-a_k$，为什么是 $a_j - a_k$ 因为 $a_j>a_k$。

如果 $a_k-a_i\geq a_j-a_k$，那么包含 $i$ $k$ 的一定包含 $j$ $k$，而 $j$ $k$ 比 $i$ $k$ 劣，所以显然了。

总和上述式子，得到：$a_i<a_k<\frac{a_i+a_j}{2}$，这个式子 $\log n$ 次就没了，然后这是基于值域的所以可以用一个动态开点值域线段树搞。

$>a_i$ 的同理，就不再展开了。

然后就这么简单就能过这道黑题了，代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define For(i, a, b) for (int i = (a); i <= (b); i ++)
#define foR(i, a, b) for (int i = (a); i >= (b); i --)
using namespace std;
int n, m, cnt;
int x, y, root;
int c[100005], ar[100005], ans[100005];
int a[30000000], ls[30000000], rs[30000000];
inline int read () {
	char ch = getchar ();
	int x = 0;
	while (ch < '0' || ch > '9') ch = getchar ();
	while (ch >= '0' && ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar ();
	}
	return x;
}
void upd (int x, int y) {for (; x <= n; x += x & -x) c[x] = min (c[x], y);}
int qry (int x) {return (x == 0 ? 1000000000 : min (c[x], qry (x - (x & -x) ) ) );}
struct Query {int l, r, id;}q[100005];
bool cmp (Query q1, Query q2) {return q1.r < q2.r || q1.r == q2.r && q1.l < q2.l;}
void update (int l, int r, int &k) {
	if (!k) k = ++ cnt;
	if (l == r) {
		a[k] = y;
		return;
	}
	int mid = l + r >> 1;
	if (x <= mid) update (l, mid, ls[k]);
	if (x > mid) update (mid + 1, r, rs[k]);
	a[k] = max (a[ls[k] ], a[rs[k] ]);
}
int query (int l, int r, int k) {
	if (x <= l && y >= r) return a[k];
	int mid = l + r >> 1, res = 0;
	if (x <= mid) res = query (l, mid, ls[k]);
	if (y > mid) res = max (res, query (mid + 1, r, rs[k]) );
	return res;
}
signed main () {
	For (i, 1, 100000) c[i] = 1000000000;
	n = read ();
	m = read ();
	For (i, 1, n) ar[i] = read ();
	For (i, 1, m) {
		q[i].l = read ();
		q[i].r = read ();
		q[i].id = i;
	}
	sort (q + 1, q + m + 1, cmp);
	int r = 0;
	For (i, 1, m) {
		while (r < q[i].r) {
			++ r;
			x = ar[r] + 1;
			y = 1000000000;
			int cur = query (0, 1000000000, 1);
			while (cur && y != ar[r]) {
				upd (n - cur + 1, ar[cur] - ar[r]);
				y = (ar[r] + ar[cur]) / 2;
				cur = query (0, 1000000000, 1);
			}
			if (cur) upd (n - cur + 1, ar[cur] - ar[r]);
			x = 0;
			y = ar[r] - 1;
			cur = query (0, 1000000000, 1);
			while (cur && x != ar[r]) {
				upd (n - cur + 1, ar[r] - ar[cur]);
				x = ceil ( (ar[r] + ar[cur]) / 2.0);
				cur = query (0, 1000000000, 1);
			}
			if (cur) upd (n - cur + 1, ar[r] - ar[cur]);
			x = ar[r];
			y = r;
			update (0, 1000000000, root);
		}
		ans[q[i].id] = qry (n - q[i].l + 1);
	}
	For (i, 1, m) cout << ans[i] << '\n';
	return 0;
}
```


---

## 作者：yizhiming (赞：0)

提供一个分块在线做法，另一篇一样的题解给挂了链接貌似没多少人看的亚子。

双倍经验 [CF765F](https://www.luogu.com.cn/problem/CF765F)。

### 题目大意

给定一个长度为 $n$ 的序列，$m$ 次求 $[l,r]$ 区间内数值上差的绝对值的最小值，且要求这两个数不相等。

$1\leq n,m \leq 10^5$，值域 $[1,10^9]$，数据随机。

### 题目解析

考虑分块会把答案分成哪些情况，我们将点对按照左右端点所在位置分类。

第一种情况，左右端点都在整块内，我们设 $s_{l,r}$ 表示从第 $l$ 块到第 $r$ 块的答案。

第二种情况，左端点在左散块，右端点在整块，我们设 $f_{l,r}$ 表示左端点在 $l$ 到 $l$ 所在块右端点这个区间，右端点在 $l$ 所在块的下一个块到 $r$ 块之间的答案。

第三种情况，左端点在整块，右端点在右散块，我们设 $g_{r,l}$ 和 $f$ 同理。

不难发现 $f,g$ 的范围完全不交，可以合并成一个 $f$ 数组，这个优化在双倍经验题里无用，在本题可以优化空间。

第四种情况，两端点都在散块。

考虑第一种情况，假设 $val(i,j)$ 表示左端点在 $i$ 块，右端点在 $j$ 块的所有答案。

那么就可以类似区间 dp 的做法，将 $s$，求出来，具体的 $s_{l,r} = \min(s_{l,r-1},s_{l+1,r},val(l,r))$。

$s_{i,i}$ 的初值可以暴力求出来，表示左右端点都在第 $i$ 块内。

如何处理 $val$ 呢？我们先将块内排序，然后将两个块归并起来即可。

同理归并可以处理上述的第四种情况。

如何处理 $f$，考虑枚举当前块，向对应的方向推，每次将新块和当前块归并起来，在对应位置记下贡献，做一遍前缀最小值即可。

查询区间，只需要利用上述数组就能 $O(\sqrt{n})$ 求出来答案。

这些部分的预处理复杂度都是 $O(n\sqrt{n})$，所以总复杂度 $O((n+m)\sqrt{n})$。

### Code

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 1e5+5;
const int SN = 350;
int a[N],n,m,inf = 1e9;
struct aa{
	int id,val;
	bool operator<(const aa&x)const{
		if(val==x.val){
			return id<x.id;
		}else{
			return val<x.val;
		}
	}
}b[N]; 
int bel[N],L[N],R[N];
int val(int l,int r,int ll,int rr){//表示将[l,r]和[L,R]归并 
	int x = bel[l],y = bel[ll];
	int pre = 0;
	int siz = R[x]-L[x]+1+R[y]-L[y]+1;
	int ans = 1e9;
	int f1=L[x],f2=L[y];
	for(int i=1;i<=siz;i++){
		int now;
		if(f1>R[x]){
			now = b[f2].id;
			f2++;
		}else if(f2>R[y]){
			now = b[f1].id;
			f1++;
		}else{
			if(b[f1].val<b[f2].val){
				now = b[f1].id;
				f1++;
			}else{
				now = b[f2].id;
				f2++;
			}
		}
		if((now<=rr&&now>=ll)||(now>=l&&now<=r)){
			if(!pre){
				pre = now;
			}else{
				if(a[pre]!=a[now]){
					ans = min(ans,abs(a[pre]-a[now]));
				}
				
				pre = now;
			}
		}
	}
	
	
	return ans;
} 
int f[SN][N],s[SN][SN];
int main(){
	n = read();m = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
		b[i].id = i;b[i].val = a[i];
	}
	int siz = sqrt(n);
	for(int i=1;i<=n;i++){
		bel[i] = (i-1)/siz+1;
		if(!L[bel[i]]){
			L[bel[i]] = i;
		}
		R[bel[i]] = i;
	}
	memset(f,0x3f,sizeof(f));
	memset(s,0x3f,sizeof(s));
	for(int i=1;i<=bel[n];i++){
		sort(b+L[i],b+R[i]+1);
		for(int j=i-1;j>=1;j--){
			int l=L[j];
			for(int k=L[i];k<=R[i];k++){
				while(l<R[j]&&b[l].val<b[k].val){
					l++;
				}
				int u = b[k].id;
				if(l==L[j]){
					f[j][u] = min({f[j][u],b[l].val==b[k].val?inf:abs(b[l].val-b[k].val)}); 
				}else {
					f[j][u] = min({f[j][u],b[l].val==b[k].val?inf:abs(b[l].val-b[k].val),b[k].val==b[l-1].val?inf:abs(b[k].val-b[l-1].val)});
				}
			}
			f[j][L[i]] = min({f[j+1][L[i]],f[j][L[i]]});
			for(int k=L[i]+1;k<=R[i];k++){
				f[j][k] = min({f[j+1][k],f[j][k-1],f[j][k]});
			}
		}
	}
	for(int i=bel[n];i>=1;i--){
		for(int j=i+1;j<=bel[n];j++){
			int l=L[j];
			for(int k=L[i];k<=R[i];k++){
				while(l<R[j]&&b[l].val<b[k].val){
					l++;
				}
				int u = b[k].id;
				if(l==L[j]){
					f[j][u] = min({f[j][u],b[l].val==b[k].val?inf:abs(b[l].val-b[k].val)}); 
				}else {
					f[j][u] = min({f[j][u],b[l].val==b[k].val?inf:abs(b[l].val-b[k].val),b[k].val==b[l-1].val?inf:abs(b[k].val-b[l-1].val)});
				}
			}
			f[j][R[i]] = min({f[j-1][R[i]],f[j][R[i]]});
			for(int k=R[i]-1;k>=L[i];k--){
				f[j][k] = min({f[j-1][k],f[j][k+1],f[j][k]});
			}
		}
	}
	for(int i=1;i<=bel[n];i++){
		for(int j=L[i];j<R[i];j++){
			s[i][i] = min(s[i][i],b[j+1].val==b[j].val?inf:b[j+1].val-b[j].val);
//			cout<<"S:"<<j<<" "<<b[j+1].val<<" "<<b[j].val<<"\n";
		}
//		cout<<"S:"<<s[i][i]<<"\n";
	}
	for(int i=2;i<=bel[n];i++){
		for(int l=1;l+i-1<=bel[n];l++){
			int r = l+i-1;
			s[l][r] = min({s[l+1][r],s[l][r-1],val(L[l],R[l],L[r],R[r])});
		}
	}
	while(m--){
		int l,r,ans = 1e9;
		l = read();r = read();
		if(bel[l]==bel[r]){
			int pre = 0;
			for(int i=L[bel[l]];i<=R[bel[l]];i++){
				if(b[i].id>=l&&b[i].id<=r){
					if(!pre){
						pre = i;
					}else{
						if(b[pre].val!=b[i].val){
							ans = min(ans,abs(b[pre].val-b[i].val));
						}
						pre = i;
					}
				}
			}
		}else{
			ans = min({f[bel[l]+1][r],f[bel[r]-1][l],s[bel[l]+1][bel[r]-1]});
			ans = min(ans,val(l,R[bel[l]],L[bel[r]],r));
		}
		cout<<ans<<"\n";
	}
	return 0;
}
/*
8
3 1 4 1 5 9 2 6
1
1 3
*/
```


---

## 作者：xfrvq (赞：0)

[$\tt P5926$](/problem/P5926)。

题意：求区间中不等的两数，差的绝对值的最小值，$n,m=10^5$。

这一看就是 [$\tt CF765F$](/problem/CF765F)，加上“两数必须不等”的限制。

具体思想一样，我把那题的 [分块题解（我自己的）](https://www.luogu.com.cn/blog/_post/425397) 贴上。

代码也只是那题的代码再改改，[代码链接](https://www.luogu.com.cn/paste/gxjaefom)。

---


# [PA 2019] Wyspa

## 题目描述

比特岛位于海上，在比特岛的中心有一个内陆湖。

在比特岛一共有 $n$ 个点，编号为 $1$ 到 $n$，其中 $1$ 到 $a$ 的点按照顺时针或者逆时针表示内陆湖边上的点， $a+1$ 到 $a+b$ 的点按照顺时针或者逆时针表示比特岛海岸线上的点， $a+b+1$ 到 $n$ 的点表示既不在湖边也不在海边的点。

这些点之间连着 $m$ 条单向或双向道路。满足如下限制：

- 每条道路不会经过湖、海或者任意其它点。
- 任意两点间只会连着最多一条道路
- 这些道路中不存在“天桥”或者“地下隧道”，任意两条道路只可能在端点处相交，换言之，这是一张平面图。
- 从任意一个湖边的点出发，都能沿着这些道路直接或间接地到达至少一个海边的点。

现在要在 $b$ 个海边点中选择若干个点作为港口，问有多少种选点的方案使得任意一个湖边的点都能到达至少一个港口？

## 说明/提示

对于 $100\%$ 的数据，$2\le n\le 5\times 10^5$，$1\le m\le 10^6$，$1\le a,b\le n,2\le a+b\le n$。

---

### 样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/e7xeolht.png)

$6$ 号点必选， $4$ 和 $5$ 可选可不选，因此有 $4$种方案。

## 样例 #1

### 输入

```
6 8 3 3
2 -> 1
2 -> 3
1 -> 3
3 -- 6
1 -> 4
2 -> 5
4 -> 6
4 -- 5```

### 输出

```
4```

# 题解

## 作者：Felix72 (赞：1)

这题大体上分为两步：

- 求出内层点可达性，转化为环上计数问题；
- DP 求解计数问题。

先对图缩点，然后尝试传递闭包。一般的闭包传递是 $O(\frac{n^2}{\omega})$ 的，但是这题的背景是平面图，因此一个点能到达的海岸线点是一个区间（去掉都不可达的海岸线点）。

于是需要我们实现一个 ModRange 类，表示在一个取模环境下的区间（即可能会有 $l > r$ 的非空区间），并且需要实现一些简单的操作，如判断相交，取并集之类的。Tarjan 之后拓扑排序求出每个点可达的海岸线点即可。

于是接着做 DP 步骤。当前问题如下：

> 有一个长为 $b$ 的环，有若干限制 $(l_i, r_i)$，表示一个区间内至少有一个点要选择。问合法选择方案的个数。

如果真的是上面的问题，时间复杂度这一块应该是不会小于 $O(n^2)$ 的。但是这个题比较有性质：它的 $(l_i, r_i)$ 是一条边一条边手搓出来的，也就是说它的数据大概率不强。

我们考虑通过合理连接点边，造出一组所有 $(l_i, r_i)$ **互不包含**的数据。最开始所有区间都是空的，我们先加若干条边，使得每个区间非空，然后现在对于任何一组 $i, j$，$(l_i, r_i)$ 和 $(l_j, r_j)$ 不交。我们想要他们相交（这样数据变强），又不想他们互相包含，那至少得用一个额外的点（边）做这个事。我们称这个操作为加强一次数据。

这个题的数据最多加强 $O(n)$ 次，也就是说**离散化之后**长度最小的区间的长度不超过 $O(\frac{n}{cnt})$（$cnt$ 是区间个数）。这就意味着我们可以枚举最短的区间中最左边的被选定的点，然后断环为链 DP。一次 DP 的复杂度是 $O(cnt)$，因此在**去掉包含情况且离散化后**，DP 部分不成为复杂度瓶颈。

总复杂度为 $O(n\log n + m)$，因为用到了排序和离散化。

---

## 作者：anotherobject (赞：0)

### 题意
给定一个岛屿，中间有一个湖，湖边，岛边分别有 $a,b$ 个点顺时针或者逆时针排。还有剩下 $n-a-b$ 个点在岛上。

现在他们之间有几条边（有向无向边都有），保证这是一张平面图。求对选取几个岛边点的方案计数，使得每个湖边点都能到达至少一个选定点。

### 题解
没人能到达的岛边点没有意义，删除。因为是平面图，所以每个湖边点到达的岛边点是一段连续区间。

然后转化成环上选点，使得每个区间内都至少有一个点方案计数，环上问题都很困难，所以破环成链，枚举一个区间作为起点，假设这个区间是 $[l,r]$，先给他转到 $[1,r-l+1]$ 这个位置，然后从 $1$ 这里把环劈开。可以枚举 $[1,r-l+1]$ 中第一个选哪个点来处理被劈开的区间。

接下来就好办了，选一个最短的区间作为起点，枚举第一个点，然后动态规划，设 $f_u$ 为处理完 $[1,u]$ 且 $u$ 必选的方案数，则从 $[g_{i-1},i-1]$ 转移来，其中 $g_i$ 为右端点小于等于 $i$ 的左端点最大值。

分析复杂度：因为可以离散化，所以每个非岛边非湖边的点的作用仅仅是合并了若干个岛边点，故在离散化后所有区间长度总和和 $n$ 同阶。枚举第一个点的复杂度为 $O(\min(len)$，动态规划的复杂度为离散化后的点数 $O(m)$，总复杂度 $O(m\min(len))$，因为 $len$ 总和和 $n$ 同阶，故 $m\min(len)$ 和 $n$ 同阶。

我的代码实现借鉴了 Claris 老师的题解，仅供参考。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,p=1e9+7;
struct graph{struct node{int to,nxt;}edge[N*2]; int head[N],cnt;void add(int u,int v){edge[++cnt].to=v;edge[cnt].nxt=head[u];head[u]=cnt;}void adde(int u,int v){add(u,v); add(v,u);}}f1,f2;
struct interval{int l,r;}e[N*2]; int ecnt;
struct ringval{int l,r,l_,r_;}f[N];
int vis[N],id[N],res,q[N],tp,st[N],ed[N],scc,scccnt,bel[N],sseq[N],lst[N];
namespace calc{ 
	int interval[N][2],n,m,m_,cnt;
	int f[N*2],g[N*2],tmp[N*2],a[N*2],base[N],val[N],v[N],minlen,pos;
	int hd,tl,q[N][2],lim[N],dp[N],ans;
	void ins(int x,int y){if(hd<=tl&&q[hd][1]>=y) return;q[++tl][0]=x; q[tl][1]=y;}
	int find(int x){while(hd<=tl&&q[hd][1]<=x) hd++; if(hd>tl) return n; return q[hd][0];}
	void init(int l,int r,int l_,int r_){
		if(!l_){interval[++m][0]=l;interval[m][1]=r;f[r]=max(f[r],l);f[r+n]=max(f[r+n],l+n);
		}else{interval[++m][0]=l_;interval[m][1]=r;f[r+n]=max(f[r+n],l_);}
	}
	void init2(int l,int r){//把一些包含的区间去掉，且离散化 
		if(l<=r){if(f[r]>l) return;tmp[l-1]=tmp[r]=1;
		}else{if(f[r+n]>l) return;tmp[l-1]=tmp[r]=tmp[n]=1;
		}interval[++m_][0]=l;interval[m_][1]=r;
	}
	void calc(int lim,int n){
		for(int i=1;i<=n;i++){
			dp[i]=dp[i-1];
			if(f[i-1]) dp[i]=(dp[i]-dp[f[i-1]-1]+p)%p;
			if(i<=lim) dp[i]++;
			dp[i]=(dp[i]*v[i]%p+dp[i-1])%p;
		}
	}
	int work(){
		for(int i=1;i<=n*2;i++) f[i]=max(f[i],f[i-1]);
		for(int i=1;i<=m;i++) init2(interval[i][0],interval[i][1]);
		m=m_; base[0]=1; tmp[n]=1;
		for(int i=1;i<=n;i++) base[i]=base[i-1]*2%p;
		for(int i=0;i<=n;i++) base[i]--;
		for(int i=1;i<=n;i++) if(tmp[i]){ tmp[i]=++cnt; a[cnt]=i; } 
		for(int i=n;i>=1;i--){if(!tmp[i]) tmp[i]=tmp[i+1];}
		n=cnt; for(int i=1;i<=n;i++) val[i]=base[a[i]-a[i-1]]; minlen=n; pos=1;
		for(int i=1;i<=m;i++){
			int l=tmp[interval[i][0]],r=tmp[interval[i][1]];
			int now; if(l<=r) now=r-l+1; else now=r-l+n+1;
			if(now<=minlen) minlen=now,pos=l;//找最短区间 
		}
		for(int i=1,j=pos;i<=n;i++){v[i]=val[j]; j++; if(j>n) j=1;}
		for(int i=0;i<=n+1;i++) f[i]=0; int en=n;
		for(int i=1;i<=m;i++){
			int l=tmp[interval[i][0]],r=tmp[interval[i][1]]; if(r<l) r+=n;
			r-=l; while(1){if(pos<=l&&l<pos+n) break; l+=n;}
			l-=pos-1; if(r==n-1) l=1,r=n; else r+=l; if(r>n) r-=n;
			if(l<=r){f[r]=max(f[r],l); en=min(en,r);
			}else{g[r+1]=max(g[r+1],l);}
		}//把环位移一下 
		hd=1; tl=0; for(int i=1;i<=n;i++) f[i]=max(f[i],f[i-1]);
		for(int i=1;i<=n;i++){if(g[i]) ins(i-1,g[i]);lim[i]=min(en,find(i));}
		for(int i=max(1ll,f[n]),j;i<=n;i=j){for(j=i;lim[i]==lim[j]&&j<=n;j++);calc(lim[i],j-1);ans=(ans+dp[j-1]-dp[i-1]+p)%p;}//枚举第一个选点位置且动态规划 
		return ans;
	}
}

void dfs1(int u){//第一次深搜删除无用岛边点 
	if(vis[u]) return; vis[u]=1;
	for(int i=f1.head[u];i;i=f1.edge[i].nxt){int v=f1.edge[i].to; dfs1(v);}
}
void dfs2(int u){//第二次深搜记录出栈顺序 
	if(vis[u]) return; vis[u]=1;
	for(int i=f1.head[u];i;i=f1.edge[i].nxt){int v=f1.edge[i].to; dfs2(v);}q[++tp]=u;
}
void dfs3(int u){//反向搜出强连通分量（kosaraju算法） 
	if(!vis[u]) return; vis[u]=0; bel[u]=scc; sseq[++scccnt]=u;
	for(int i=f2.head[u];i;i=f2.edge[i].nxt){int v=f2.edge[i].to; dfs3(v);}
}
void fset(int x,int l,int r){//用两组l,r来存环上的区间 
	if(!x) return; if(!f[x].l) f[x].l=l,f[x].r=r;
	else if(!f[x].l_) f[x].l_=l,f[x].r_=r;
}

signed main(){
	int n,m,_a,_b; cin>>n>>m>>_a>>_b;
	for(int i=1;i<=m;i++){
		int u,v; char ch; cin>>u>>ch>>ch>>v;
		if(ch=='-'){f1.adde(u,v);f2.adde(u,v);}
		else{f1.add(u,v);f2.add(v,u);}
	}
	int base=1;
	for(int i=1;i<=_a;i++) dfs1(i);
	for(int i=_a+1;i<=_a+_b;i++) if(vis[i]) id[i]=++res; else base=base*2%p;
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++) if(!vis[i]) dfs2(i);
	for(int i=tp;i>=1;i--){if(vis[q[i]]){scc++; st[scc]=scccnt+1;dfs3(q[i]); ed[scc]=scccnt;}}
	for(int i=scc;i>=1;i--){
		ecnt=0;
		for(int j=st[i];j<=ed[i];j++){
			int u=sseq[j];
			if(id[u]) e[++ecnt]={id[u],id[u]};
			for(int k=f1.head[u];k;k=f1.edge[k].nxt){//它前面的强连通分量的区间存进e里 
				int v=f1.edge[k].to; int nxscc=bel[v];if(nxscc==i) continue;if(lst[nxscc]==i) continue;lst[nxscc]=i;
				if(f[nxscc].l) e[++ecnt]={f[nxscc].l,f[nxscc].r};if(f[nxscc].l_) e[++ecnt]={f[nxscc].l_,f[nxscc].r_};
			}
		}
		if(!ecnt) continue;sort(e+1,e+ecnt+1,[](interval a,interval b){return a.l<b.l;});int L=0,R=-1;
		for(int j=1;j<=ecnt;j++){if(e[j].l>R+1){fset(i,L,R);L=e[j].l;}R=max(R,e[j].r);}fset(i,L,R);//把e里这些区间合并起来 
	}
	
	calc::n=res;
	for(int i=1;i<=_a;i++){int x=bel[i];if(f[x].l) calc::init(f[x].l,f[x].r,f[x].l_, f[x].r_);f[x].l=0;}
	cout<<base*calc::work()%p<<"\n";
}


```

---


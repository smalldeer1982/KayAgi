# [JSOI2010] 旅行

## 题目描述

WJJ 喜欢旅游，这次她打算去一个据说有很多漂亮瀑布的山谷玩。

WJJ 事先得到了一张地图，上面标注了 $N$ 个小动物的聚居地，也就是一个个的小村落。其中第 $1$ 个村庄是 WJJ 现在住的地方，第 $N$ 个村庄是 WJJ 打算去的地方。

这些村庄之间有 $M$ 条双向道路连接着，第 $i$ 条双向道路恰好直接连接两个小村庄 $A_i$，$B_i$，长度为 $C_i$。道路有的是隧道，有的是栈桥，地图上那些看起来在村庄之外交叉的路实际上并不相交——也就是说，如果把这些小村落和双向道路构成的道路网看作图论意义上的图，我们不保证它是平面图，也不保证它没有重边。不过，有一点还是可以保证的：WJJ  细心地验证过，从它居住的村落一定能走到她想去的那个山谷。

在 WJJ 所在的神奇世界中，每只小动物都可以借助仙人掌来施放魔法，其中之一是，交换世界中任意两条双向道路的长度，同时保持其他道路的长度不变。按 WJJ 目前的魔法水平，她最多能使用 $K$ 次这种道路长度交换魔法。可惜的是，由于仙人掌刺比较多，WJJ 并不打算带着它旅行，于是她会在家里完成想要的道路交换后再出门。

假设 WJJ 的旅行途中不会有其他小动物进行道路交换来破坏她设计好的路线。为了尽快达到目的地，WJJ 希望她需要走的总距离越短越好。也就是说，使用最多 $K$ 次魔法后，从村落 $1$ 到村落 $N$ 的最短距离是多少？

## 说明/提示

### 样例解释

一个可行的方案是，对调第 $1$ 条边和第 $4$ 条边的长度，再对调第 $2$ 条边和第 $5$ 条边的长度。对调后的最短路径为 $1\rightarrow 2\rightarrow 5$，长度为 $3$。可以证明，没有比这更优的方案了。

### 数据范围

对于 $100\%$ 的数据，$1\leq N\leq 50$，$1\leq M\leq 150$，$1\leq K\leq 20$，$1\leq A_i,B_i\leq N$，$A_i\neq B_i$，$1\leq C_i\leq 1000$。

## 样例 #1

### 输入

```
5 5 2
1 2 10
2 5 10
1 3 4
3 4 2
4 5 1```

### 输出

```
3```

# 题解

## 作者：five_rice_water (赞：10)

# 洛谷P6029 题解

本人过的第一道黑题，也是本人在洛谷的第 $1000$ 道题。

这题其实不是很难，个人感觉到不了黑。

## 题意简述

对于一个有 $n$ 个点，$m$ 条边的无向图，可以交换 $k$ 对边的边权，问交换完的图上从 $1$ 号点到 $n$ 号点的最短路是多少。

## 思路

我们先来考虑和本题的思路部分很像的这样一道题：

现在有一个序列 $a$，可以交换任意两个数字 $k$ 次，问操作完之后的序列的最大子段和。数据保证 $1 \le n \le 500$。

不难发现，当 $k$ 过大的时候，这个问题没有意义。但是当 $k$ 相对小的时候，我们就要思考做法了。

一种相对可行的解法是这样的，我们枚举最终最大子段和所在的区间左右端点，再去考虑往这个区间里面交换前 $k$ 大的数字。

当然要考虑前 $k$ 大的数字有一部分已经在这个区间里面了，所以细节处理会麻烦一点，但总之是 $O(n^3)$ 左右可以解决的问题，不过该时间复杂度下对应数据范围可能会超时，但这不是我们这篇题解的核心内容，所以暂时不提。

总结一下，我们用到的思路是**枚举终态**，也就是考虑最终的答案可能来自哪些部分，然后进一步操作。

再简单一点，就是找一些能概括所有状态的情况，然后依次枚举所有情况，找到在该种情况的最优解，最后得到最终的最优解。

那么放到这道题上，到底哪些状态是有限可以被枚举同时可以概括所有情况的呢？

一种可行的情况是这张图上前 $p$ 短的边是否在从 $1$ 到 $n$ 的路径上。 

这样枚举，可以概括所有的情况。

## 代码实现

第一步，我们要枚举 $p$，然后跑最短路。

但是我们已经知道了前 $p$ 短的路径了，有什么用呢？

我们可以用 dp 去获得“前 $p$ 短的路都在 $1$ 到 $n$ 的路径上时的最优解”。

怎么定义状态呢？我们设 $f_{i,j,t}$ 表示走过了 $j$ 条**原本就是**前 $p$ 短的边，并且使用了 $t$ 次魔法后，从 $1$ 走到 $i$ 的最小代价（不计算前 $p$ 短的边的长度）。

怎么转移呢？有以下两种情况。

当 $t+1\le k$ 时，可以尝试在 $x$ 到 $v$ 的路径上使用一次魔法，因为交换过来的边一定是前 $p$ 短的边的其中一根（否则答案一定不会更优），所以不记录答案，即更新 $f_{v,j,t+1}$ 的值为 $f_{x,j,t}$。

另外，当这条边是我们枚举的前 $p$ 条边中的其中一条时，因为是前 $p$ 短的边，所以不记录答案，我们可以更新 $f_{v,j+1,t}$ 的值为 $f_{x,j,t}$。

否则，这条边要计算到答案里，更新 $f_{v,j,t}$ 的值为 $f_{x,j,t} + w$。

最后，从 $1$ 到 $n$，走了 $j$ 条原本就是前 $p$ 小长度的边，用了 $k$ 次魔法的最小代价应该是 $f_{n,j,t} + sum_p$。其中 $sum_p$ 表示前 $p$ 小的边的长度和。

最后加上 $sum_p$ 的原因是在进行 dp 的过程中，不方便计算魔法交换过来的边的边权。

最后的答案就是所有 $j+t \le p$ 的 $f_{n,j,t}+sum_p$ 的最小值（因为超过范围的没有意义）。

## 代码展示

代码实现时注意一下边界处理，例如下面的 ```j+1<=m```。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
const int M = 155;
int n, m, k;

struct graph {
	int v, w, id;
};
vector<graph>e[N];

struct node {
	int x, j, k, dis;
	friend bool operator <(node a, node b) {
		return a.dis > b.dis;
	}
};

struct edge {
	int w, id;
} E[M];

bool cmp(edge a, edge b) {
	return a.w < b.w;
}
int mp[M], f[N][M][M], vis[N][M][M];

void dijkstra(int check) {
	memset(f, 0x3f, sizeof(f));
	memset(vis, 0, sizeof(vis));
	f[1][0][0] = 0;
	priority_queue<node>q;
	q.push({1, 0, 0, 0});
	while (!q.empty()) {
		node tmp = q.top();
		q.pop();
		int x = tmp.x;
		int j = tmp.j;
		int k_ = tmp.k;
		if (vis[x][j][k_])
			continue;
		vis[x][j][k_] = 1;
		for (int i = 0; i < e[x].size(); i++) {
			int v = e[x][i].v;
			int w = e[x][i].w;
			int id = e[x][i].id;
			if (k_ + 1 <= k && f[v][j][k_ + 1] > f[x][j][k_]) {
				f[v][j][k_ + 1] = f[x][j][k_];
				q.push({v, j, k_ + 1, f[v][j][k_ + 1]});
			}
			if (mp[id] <= check) {
				if (j + 1 <= m && f[v][j + 1][k_] > f[x][j][k_]) {
					f[v][j + 1][k_] = f[x][j][k_];
					q.push({v, j + 1, k_, f[v][j + 1][k_]});
				}
			} else {
				if (f[v][j][k_] > f[x][j][k_] + w) {
					f[v][j][k_] = f[x][j][k_] + w;
					q.push({v, j, k_, f[v][j][k_]});
				}
			}
		}
	}
}

int main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= m; i++) {
		int x, y, z;
		cin >> x >> y >> z;
		e[x].push_back({y, z, i});
		e[y].push_back({x, z, i});
		E[i] = {z, i};
	}
	sort(E + 1, E + 1 + m, cmp);
	for (int i = 1; i <= m; i++) {
		mp[E[i].id] = i;
	}
	int sum = 0;
	int ans = INT_MAX;
	for (int i = 0; i <= m; i++) {
		sum += E[i].w;
		dijkstra(i);
		for (int j = 0; j <= i; j++) {
			for (int K = 0; K <= k; K++) {
				if (j + K <= i) {
					ans = min(ans, f[n][j][K] + sum);
				} else
					break;
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：MafuyuQWQ (赞：6)

## 题意

> 给定一张有 $n$ 个点，$m$ 条边的图。可以任意交换途中两条边的权值不超过 $K$ 次，问最后 $1$ 到 $n$ 的最短路径长度。
>
> $1 \le n \le 50$，$1 \le m \le 150$，$1 \le K \le 20$

## Solution

这题是某次初赛模拟的时候放上来，似乎比较水，就写了一下。

不难想到一种贪心：直接将所有的最小边能换到路径上就换。

但是这样不一定是最优的，所以考虑枚举最后在路径上的边为所有边中前 $i$ 小的。

并且用 Dp 在 Dijkstra 的同时计算。

设 $f_{u, j, k}$ 表示从 $1$ 到 $u$ 的路径上有 $j$ 条为前 $i$ 小的边，且使用了 $k$ 次交换魔法的最短路径长度。

设当前点为 $u$，下一个节点为 $v$，则转移方程如下：

- 当 $k + 1 \le K$ 时，$f_{u, j, k}$ 可以更新 $f_{v, j, k + 1}$。
- 当遍历到的 $(u, v)$ 这条边属于前 $i$ 条边时，则将这条边边权设为 $0$，并且设 $j1 = j + 1$，否则为 $j$（因为前 $i$ 条边在最后统一计算前缀和）。此时当 $j1 \le m$ 时，则可以用 $f_{u, j, k} + w$ 更新 $f_{v, j1, k}$。

最后统计答案时，就枚举前 $i$ 条最小边和 $j, k$，再处理一个 $sum$ 表示前 $i$ 小的边权前缀和，然后在所有 $f_{n, j, k} + sum$ 中取最小值即可，但是要注意的是枚举条件 $j + k \le i$。

```cpp
// Asahina Mafuyu
#include <bits/stdc++.h>

using namespace std;

const int N = 55, M = 155, K = 25;

struct two_plus_four {
    int id, v, w;
};
struct three_plus_three {
    int u, j, k, f;
    bool operator<(const three_plus_three& W) const
    {
        return f > W.f;
    }
};

int n, m, k;
int w[M], id[M], mp[M];
int f[N][M][K];
bool st[N][M][K];
vector<two_plus_four> gph[N];

bool cmp(int a, int b)
{
    return w[a] < w[b];
}

void dijkstra(int limit)
{
    memset(f, 0x3f, sizeof f);
    memset(st, 0, sizeof st);
    priority_queue<three_plus_three> q;
    q.push({ 1, 0, 0, 0 });
    f[1][0][0] = 0;
    while (q.size()) {
        auto t = q.top();
        q.pop();
        int u = t.u, j = t.j, K = t.k;
        if (st[u][j][K])
            continue;
        st[u][j][K] = 1;

        for (auto x : gph[u]) {
            int v = x.v, w_ = x.w, id_ = x.id, j1 = j;
            if (K < k && f[v][j][K + 1] > f[u][j][K]) {
                f[v][j][K + 1] = f[u][j][K];
                q.push({ v, j, K + 1, f[v][j][K + 1] });
            }
            if (mp[id_] <= limit)
                j1++, w_ = 0;
            if (j1 <= m && f[v][j1][K] > f[u][j][K] + w_) {
                f[v][j1][K] = f[u][j][K] + w_;
                q.push({ v, j1, K, f[v][j1][K] });
            }
        }
    }
}

int main()
{
    cin >> n >> m >> k;
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        gph[a].push_back({ i, b, c }), gph[b].push_back({ i, a, c });
        id[i] = i, w[i] = c;
    }

    sort(id + 1, id + m + 1, cmp);
    sort(w + 1, w + m + 1);
    for (int i = 1; i <= m; i++)
        mp[id[i]] = i;
    int s = 0, res = 0x3f3f3f3f;
    for (int i = 0; i <= m; i++) {
        s += w[i];
        dijkstra(i);
        for (int j = 0; j <= i; j++)
            for (int K = 0; K <= k && j + K <= i; K++)
                res = min(res, f[n][j][K] + s);
    }

    cout << res << '\n';

    return 0;
}
```

---

## 作者：Gmt丶FFF (赞：5)

一道非常有意思的题，考验对最短路的理解。

可以看出，如果一条 $1$ 到 $n$ 的路径上路的数量 $\le m$，那么直接取最小的 $m$ 条边即可。

但是如果大于 $m$，那就不能这么简单的交换，因为路径上可能存在前 $m$ 小的边，这样我们没有必要花一个操作将这个边拿到我们路径上。

那么这种想法就是否完全没用了呢？并不是，实际上我们的最短路径中肯定会有前 $i$ 小的边，但是这个 $i$ 我们并不知道，所以枚举即可。

那么我们将前 $i$ 小的边强制塞入，所以就可以设 $f_{x,y,z}$ 为最短路跑到 $x$ 这个点，有 $y$ 条前 $i$ 小的边，使用了 $z$ 次魔法的最短路。

利用 dijstra 即可转移这个方程，在转移方程中，不记录前 $i$ 小的边的权值与使用魔法的边的权值，跑完最短路后强制塞入即可（即加上前 $i$ 小的边权和）。

注意在最后统计答案时，若 $y+z>i$，那么很明显不成立，不能计入答案。

跑 $m$ 次 dijstra 后取最小值即可。

时间复杂度：$O(n^2mk\times\log(nmk))$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int N=55;
const int M=155;
const int K=25;
int n,m,k,f[N][M][K],dis[M],vis[N][M][K],id[M],fid[M];
struct node2
{
	int name,to,data;
};
vector<node2>a[N];
int cmp(int x,int y)
{
	return dis[x]<dis[y];
}
struct node
{
	int x,y,z,data;
};
bool operator <(node x,node y)
{
	return x.data>y.data;
}
priority_queue<node>q;
void dijstra(int lim)
{
	memset(f,0x3f,sizeof(f));
	memset(vis,0,sizeof(vis));
	f[1][0][0]=0;
	q.push({1,0,0,0});
	while(!q.empty())
	{
		node t=q.top();
		q.pop();
		int x=t.x,y=t.y,z=t.z;
		if(vis[x][y][z])continue;
		vis[x][y][z]=1;
		int len=a[x].size();
		for(int i=0;i<len;i++)
		{
			if(z<k&&f[x][y][z]<f[a[x][i].to][y][z+1])
			{
				f[a[x][i].to][y][z+1]=f[x][y][z];
				q.push({a[x][i].to,y,z+1,f[a[x][i].to][y][z+1]});
			}
			int num=y,num2=a[x][i].data;
			if(fid[a[x][i].name]<=lim)num++,num2=0;
			if(num<=m&&f[x][y][z]+num2<f[a[x][i].to][num][z])
			{
				f[a[x][i].to][num][z]=f[x][y][z]+num2;
//				cout<<x<<" "<<a[x][i].to<<" "<<y<<" "<<z<<" "<<f[x][y][z]<<" "<<num2<<endl;
				q.push({a[x][i].to,num,z,f[a[x][i].to][num][z]});
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		a[x].push_back({i,y,z});
		a[y].push_back({i,x,z});
		dis[i]=z;
		id[i]=i;
	}
	sort(id+1,id+1+m,cmp);
	for(int i=1;i<=m;i++)fid[id[i]]=i;
//	for(int i=1;i<=m;i++)cout<<fid[i]<<" ";
	sort(dis+1,dis+1+m);
	int sum=0,ans=2e9;
	for(int i=0;i<=m;i++)
	{
		sum+=dis[i];
		dijstra(i);
		for(int j=0;j<=i;j++)for(int t=0;t<=k&&j+t<=i;t++)ans=min(ans,f[n][j][t]+sum);
	}
	printf("%d\n",ans);
	return 0;
}
/*
11 10 3
1 2 6
2 3 6
3 4 6
4 5 6
5 11 6
6 7 1
7 8 2
8 9 3
9 10 3
10 11 3
*/
```


---

## 作者：Erica_N_Contina (赞：4)

## 思路

就是给你一副无向图，你可以执行最多 $K$ 次以下操作：将任意两条边的长度交换。求从 $1$ 节点到 $N$ 节点的最短路径长度。

---

初看本题，我们毫无头绪。我们可以转移到最多不超过 $150$ 条边，可是我们可不能枚举替换那些边——想想 $C_{150}^{k},k\in[1,150]$ 吧，十分恐怖。

那么怎么办呢？我们把边都从小到大排序，我们想如果我们可以尽可能地从前往后选边那就好了。现在我们假定已经找到了最短路径 $L$（这里指的是 $L$ 在换边之后是最短路径，不代表它在原图中是最短的），那么我们肯定希望 $L$ 由最短的那些边组成。

我们可以画出下面的图，我们用斜杠表示边，从小到大排序后边如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ozx599yu.png)

假设我们很理想话，设 $L$ 的长度为 $4$，若所有边一开始都没有权值而是我们给它们赋的值，那么我们希望的选边应该是：

![](https://cdn.luogu.com.cn/upload/image_hosting/px3aedgu.png)

但是很显然有一些边本来就在路径 $L$ 上不需要更换，黄色的表示 $L$ 原来的边：
![](https://cdn.luogu.com.cn/upload/image_hosting/fdikyxs7.png)

那么最终我们的选边如下，绿色代表原本不在 $L$ 上，但是后来换到了 $L$ 上的边；灰色代表被替换的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/4cqgfrzr.png)

我们发现以上的所有讨论仅仅建立在我们知道那条 $L$ 一定是最后的答案的基础上的。可是现在我们并不知道，怎么办呢？我们看看上面的选边，很容易得出一个性质就是一定存在一个前缀里面只包含绿色和黄色斜杠。那么我们就会有一个分界点 $p$，意味着前 $p$ 条边我们一定会选择，若不在 $L$ 上，我们就强制替换。

---

是不是还没有思路？继续看：

确定了 $p$ 后，我们就知道那些边一定会选了。那么这些边的长度和是确定的，也就是说最终的路径长度还是由 $p$ 以后的边确定的。那么现在问题就好办了，我们在记录 dp 数组时不记录边在前 $p$ 条边中的边，只记录 $p$ 后面的。同时我们记录我们使用了几次魔法，还有一些其他信息我们后面再说。

现在问题转化为了你有 $K$ 次魔法（注意这里的 $K$ 不会受到 $p$ 的影响，因为我们可以不用 $K$ 次），每一次可以让一条边的边权变为 $0$，求最短路。

这好办啊，我们在跑 dijkstra 时同时 dp 即可。

---

dp 流程如下：定义 $f_{i,j,k}$ 表示当前从 $1$ 走到 $i$，使用了 $k$ 次魔法，但是路上本来就有 $j$ 条在前 $p$ 条边中的边的最小路径长度。

记录 $j$ 仅仅是为了帮助我们判断最后 dp 出来的情况是否合法。想一想，如果 $j+k>p$，那么这种情况不合法。因为 $k$ 代表我们用了 $p$ 中的 $k$ 条边（这些边必须是不在 $L$ 上的）来替换原来 $L$ 上的但是在 $p$ 后面的边。这就意味着前 $p$ 条边中必须要有 $k$ 条边不在 $L$ 上。如果 $j+k>p$，那么就意味着前 $p$ 条边中有超过 $p-k$ 条边在 $L$ 上，那么便无法留出 $k$ 条边不在 $L$ 上了。

https://www.luogu.com.cn/record/142597176


---

## 作者：x义x (赞：4)

不难发现我们很难决定一条边要不要换入/换出，也很难得知某条边是否已经被换入。于是我们直接枚举这个要不要换入的标准，具体来说是这样的：

对于一条路径，如果我们希望在它上面释放 $d$ 次魔法，那么一定是把该路径上最大的 $d$ 条边和不在该路径上的最小的 $d$ 条边交换。如果把所有边按权值从小到大排序，看起来大概会是这个样子：

$$\color{red}\text{〇}\color{blue}\text{〇〇}\color{red}\text{〇}\color{blue}\text{〇}\color{black}\text{〇〇}\color{red}\text{〇}\color{black}\text{〇}\color{lightgreen}\text{〇}\color{black}\text{〇}\color{lightgreen}\text{〇〇}$$

（其中红色代表在路径上而且没被施法，蓝色代表不在路径上但被换入，绿色代表在路径上但被换出）

有一个最长的前缀使得其中的所有边都是红色或蓝色。称它的长度为 $L$，这就是我们枚举的这个标准。所有蓝色都小于等于 $L$；所有绿色都大于 $L$。

``f[i][j][k]`` 表示从 $1$ 走到 $i$，路径上使用了 $j$ 条小于等于 $L$ 的边（换入不算），$k$ 次魔法，所有在路径上且大于 $L$ 且不换出的边的权值和的最小值。跑最短路来 DP。

跑 155 次 2e5 的最短路可能有点困难，所以如果前 $L$ 条边的长度和已经大于当前答案就可以退出了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxN=55,maxM=155,maxK=25;
int N,M,K;
int u[maxM],v[maxM],c[maxM],id[maxM];
bool cmp(int a,int b){
	return c[a]<c[b];
}

int lnk[maxN];
int pre[maxM<<1],tgt[maxM<<1],val[maxM<<1],cnt;
void add_E(int u,int v,int c){
	pre[++cnt]=lnk[u],tgt[cnt]=v,val[cnt]=c,lnk[u]=cnt;
}

int L;
struct node{
	int x,y,z,w;
	bool operator <(const node b)const{return w>b.w;}
};
priority_queue<node> Q;
int F[maxN][maxM][maxK];
void Push(node u){
	if(u.y>L||u.z>K) return;
	if(F[u.x][u.y][u.z]<=u.w) return;
	F[u.x][u.y][u.z]=u.w;
	Q.push(u);
}
int ans=0x3f3f3f3f,S;

int main(){
	scanf("%d%d%d",&N,&M,&K);
	for(int i=1;i<=M;i++) scanf("%d%d%d",&u[i],&v[i],&c[i]),id[i]=i;
	sort(id+1,id+M+1,cmp);
	for(int i=1;i<=M;i++) add_E(u[id[i]],v[id[i]],c[id[i]]),add_E(v[id[i]],u[id[i]],c[id[i]]);
	for(L=0;L<=M;L++){
		if(L) S+=c[id[L]];
//		if(S>=ans) break;
		memset(F,63,sizeof(F));
		Push((node){1,0,0,0});
		while(!Q.empty()){
			node u=Q.top();Q.pop();
			if(F[u.x][u.y][u.z]<u.w) continue;
			for(int e=lnk[u.x];e;e=pre[e]){
				if(((e+1)>>1)<=L) Push((node){tgt[e],u.y+1,u.z,u.w});
				else{
					Push((node){tgt[e],u.y,u.z,u.w+val[e]});
					Push((node){tgt[e],u.y,u.z+1,u.w});
				}
			}
		}
		for(int y=0;y<=L;y++)
		for(int z=0;z<=K&&y+z<=L;z++)
			ans=min(ans,F[N][y][z]+S);
	}
	printf("%d\n",ans);
}
```

---

## 作者：Iris_Aurora (赞：2)

### 题目大意

给定一张 $n$ 个点，$m$ 条边的带权无向图，

可以至多交换任意 $K$ 对边，问从 $1$ 到 $n$ 最短路的最短长度。

### 思路

首先我们将边从小到大排序。

可以发现换过来的边和原来没有被换掉的边一定会包含边排序之后的一个前缀，也就是包含前 $i$ 小的边 $(0\le i\le m)$。

因为如果你要交换 $t$ 条边到最短路径上，一定是选择换出在路径上的权值最大的 $t$ 条，换进不在路径上的权值最小的 $t$ 条，这 $t$ 条边就一定会和原来就在路径上的边组成前缀。

但我们不知道 $i$ 的值怎么办？

注意到 $m\le 150$，我们考虑枚举终态，即 $i$ 的值。

每次我们强制选前 $i$ 小的边，累加前 $i$ 小的边的和 $sum$，跑 dijkstra。

$f_{u,j,k}$ 表示从 $1$ 走到 $u$，走了 $j$ 条前 $i$ 小的边（原来的边），用了 $k$ 次魔法的最小代价。

因为我们强制选前 $i$ 小的边，所以在跑 dijkstra 的过程中不算前 $i$ 小内的边和魔法的代价，最后再统一累加。

最后答案是 $\max(f_{n,j,k}+sum)(j+k=i)(k\le K)$ 取最大值。

另：发现其他题解都是只要 $j+k\le i$ 就统计答案，但是 $j+k<i$ 的情况是没有意义的所以可以省去枚举 $k$ 的一重循环，只取等于的情况。

附上代码：


```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(int i=(a);i<=(b);i++)
#define FR(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
using namespace std;
const int MAXN = 50 + 5;
const int MAXM = 150 + 5;
const int MR = 20 + 5;
const int inf = 0x3f3f3f3f;
//f[u][j][k]表示1走到u,前缀选了j个,施展了k次魔法的最小代价 
struct edge{
	int u,v,w;
}e[MAXM];
struct Edge{
	int v,w,id;
};
int n,m,K;
int f[MAXN][MAXM][MR];
bool vis[MAXN][MAXM][MR];
vector<Edge>G[MAXN];
struct node{
	int u,j,k,val;
	bool operator<(const node &p) const{
		return val>p.val;
	}
};
priority_queue<node>q;
void dijkstra(int mx){
	memset(f,0x3f,sizeof(f));
	memset(vis,0,sizeof(vis));
	q.push({1,0,0,0});
	f[1][0][0]=0;
	while(!q.empty()){
		int u=q.top().u,j=q.top().j,k=q.top().k;
		q.pop();
		if(vis[u][j][k]) continue;
		vis[u][j][k]=1;
		for(auto i:G[u]){
			int v=i.v,w=i.w,id=i.id;
			if(id<=mx){
				if(j<mx&&f[v][j+1][k]>f[u][j][k]){
					f[v][j+1][k]=f[u][j][k];
					q.push({v,j+1,k,f[v][j+1][k]});
				}
			}
			else{
				if(f[v][j][k]>f[u][j][k]+w){
					f[v][j][k]=f[u][j][k]+w;
					q.push({v,j,k,f[v][j][k]});
				}
				if(k<K&&f[v][j][k+1]>f[u][j][k]){
					f[v][j][k+1]=f[u][j][k];
					q.push({v,j,k+1,f[v][j][k+1]});
				}
			}
		}
	}
	
}
bool cmp(edge p,edge q){
	return p.w<q.w;
}
int main(){
	scanf("%d%d%d",&n,&m,&K);
	FL(i,1,m) scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	sort(e+1,e+m+1,cmp);
	FL(i,1,m){
		G[e[i].u].push_back({e[i].v,e[i].w,i});
		G[e[i].v].push_back({e[i].u,e[i].w,i});
	}
	int now=0,ans=inf;
	FL(i,0,m){
		now+=e[i].w;
		dijkstra(i);
		FL(j,0,i)
			if(i-j<=K)
				ans=min(ans,now+f[n][j][i-j]);
	}
	printf("%d\n",ans);
	
}
```

---

## 作者：wangyibo201026 (赞：1)

## 题目大意

给定一张 $n$ 个点，$m$ 条边的带权无向图，要求在最初交换 $k$ 对边的权值，使得其最短路最短，让你求这个值。

$1 \le n \le 50, 1 \le m \le 150, 1 \le k \le 20$。

## 题目思路

首先拿到这道题我是没有思路的，但是 le0n 大佬讲完后再研究题解，突然发现又懂了。

首先确定一个事实：我们要将小的边放在目前的最短路上，这个贪心是显然的。

我们考虑将边按照边权排序，那么排完序后肯定每条边只有三个状态：

1. 没有产生任何交换。
2. 产生交换并且此时交换到了最短路上。
3. 产生交换并且此时交换到了非最短路上。

首先分析一下三种边的成因：

1. 没有任何原因。
2. 这条边边权较小。
3. 这条边边权较大。

然后我们再考虑一个事实，就是拍完序后，一些 $1$ 类边和所有 $2$ 类边一定构成一个前缀（因为贪心的想，肯定是要把尽量小的边换到最短路上），但是此时我们无法确定出这个前缀到底持续到哪里，所以这个东西就变成了一个 DP 状物。

考虑这个前缀既然无法确定，那么我们直接暴力枚举，然后此时可以在最短路上做 DP 了（因为前缀已经固定好了），我们设 $f_{i, j, k}$ 表示从 $1$ 到 $i$，枚举前缀中的 $1$ 类边选了 $j$ 个，枚举前缀中的 $2$ 类边选了 $k$ 个（施展了 $k$ 次魔法），此时这条路径上**除了枚举前缀**外其它边的代价（可能会不理解，如果两个东西的边集不包含怎么办？考虑最后只与 $n$ 有关，所以我们是硬控前 $i$ 个数的贡献，如果中间算重了就不计算，这样就可以达到目的），最后答案就是 $f_{n, j, k}$ 取个最小值再加上枚举前缀的边权和。

具体而言，转移细节可以看代码分析。

## 代码分析

首先拿出关键代码：

```cpp
void dijkstra ( int mx ) {
	memset ( f, 0x3f, sizeof ( f ) );
	memset ( vis, false, sizeof ( vis ) );
	q.push ( { 1, 0, 0, 0 } );
	f[1][0][0] = 0;
	while ( !q.empty () ) {
		Node2 x = q.top ();
		q.pop ();
		if ( vis[x.i][x.j][x.k] ) {
			continue;
		}
		vis[x.i][x.j][x.k] = true;
		for ( int j = head[x.i]; j; j = edges[j].next ) {
			if ( edges[j].id <= mx ) {
				if ( x.j + 1 <= mx && f[edges[j].to][x.j][x.k] > x.v ) {
					f[edges[j].to][x.j + 1][x.k] = x.v;
					q.push ( { edges[j].to, x.j + 1, x.k, x.v } );
				}
			}
			else {
				if ( f[edges[j].to][x.j][x.k] > x.v + edges[j].w ) {
					f[edges[j].to][x.j][x.k] = x.v + edges[j].w;
					q.push ( { edges[j].to, x.j, x.k, x.v + edges[j].w } );
				}
				if ( x.k + 1 <= K && f[edges[j].to][x.j][x.k + 1] > x.v ) {
					f[edges[j].to][x.j][x.k + 1] = x.v;
					q.push ( { edges[j].to, x.j, x.k + 1, x.v } );
				}
			}
		}
	}
}
```

其中 $mx$ 表示枚举前缀的边数，然后这里转移一句一句来分析。

首先看到：

```cpp
if ( edges[j].id <= mx ) {
	if ( x.j + 1 <= mx && f[edges[j].to][x.j][x.k] > x.v ) {
		f[edges[j].to][x.j + 1][x.k] = x.v;
		q.push ( { edges[j].to, x.j + 1, x.k, x.v } );
	}
}
```

这里的意思是说，如果最短路上的边在枚举前缀里，就什么也不用管，也不怕产生多余的贡献。

然后看到：

```cpp
else {
	if ( f[edges[j].to][x.j][x.k] > x.v + edges[j].w ) {
		f[edges[j].to][x.j][x.k] = x.v + edges[j].w;
		q.push ( { edges[j].to, x.j, x.k, x.v + edges[j].w } );
	}
	if ( x.k + 1 <= K && f[edges[j].to][x.j][x.k + 1] > x.v ) {
		f[edges[j].to][x.j][x.k + 1] = x.v;
		q.push ( { edges[j].to, x.j, x.k + 1, x.v } );
	}
}
```

这里有两种转移，分别表示的意思是：

1. 如果这条边并不出现在枚举前缀里，那么我们就算一下它的贡献（想当于是不在枚举前缀里的 $1$ 类边）。
2. 使用一次魔法，$j$ 并不增加，这个东西仔细想想就是把一个枚举前缀的边交换到这里来，本质上贡献在最开始是算过了的，所以不用算了。

## 代码实现

Code：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
#define fir first
#define sec second
#define mkp make_pair 
#define pb push_back
#define lep( i, l, r ) for ( int i = ( l ); i <= ( r ); ++ i )
#define rep( i, r, l ) for ( int i = ( r ); i >= ( l ); -- i )

typedef unsigned long long ull;
typedef long long ll;
typedef long double ld;
typedef pair < int, int > pii;

char _c; bool _f; template < class type > inline void read ( type &x ) {
	_f = 0, x = 0;
	while ( _c = getchar (), !isdigit ( _c ) ) if ( _c == '-' ) _f = 1;
	while ( isdigit ( _c ) ) x = x * 10 + _c - '0', _c = getchar (); if ( _f ) { x = -x; }
}

template < class type > inline void chkmin ( type &x, type y ) { x = ( x <= y ? x : y ); }
template < class type > inline void chkmax ( type &x, type y ) { x = ( x >= y ? x : y ); }

const int N = 55;
const int M = 155;
const int INF = 1 << 30;

int n, m, K, sum, ans = INF;
int f[N][M][25];
bool vis[N][M][25];

int head[N], tot;

struct Graph {
	int to, w, id, next;
} edges[M << 1];

void add ( int u, int v, int w, int id ) {
	tot ++;
	edges[tot].to = v;
	edges[tot].w = w;
	edges[tot].id = id;
	edges[tot].next = head[u];
	head[u] = tot;
}

struct Node {
	int u, v, w, id;
} a[N * N];

struct Node2 {
	int i, j, k, v;
	bool operator < ( const Node2 x ) const {
		return v > x.v;
	}
};

priority_queue < Node2 > q;

void dijkstra ( int mx ) {
	memset ( f, 0x3f, sizeof ( f ) );
	memset ( vis, false, sizeof ( vis ) );
	q.push ( { 1, 0, 0, 0 } );
	f[1][0][0] = 0;
	while ( !q.empty () ) {
		Node2 x = q.top ();
		q.pop ();
		if ( vis[x.i][x.j][x.k] ) {
			continue;
		}
		vis[x.i][x.j][x.k] = true;
		for ( int j = head[x.i]; j; j = edges[j].next ) {
			if ( edges[j].id <= mx ) {
				if ( x.j + 1 <= mx && f[edges[j].to][x.j][x.k] > x.v ) {
					f[edges[j].to][x.j + 1][x.k] = x.v;
					q.push ( { edges[j].to, x.j + 1, x.k, x.v } );
				}
			}
			else {
				if ( f[edges[j].to][x.j][x.k] > x.v + edges[j].w ) {
					f[edges[j].to][x.j][x.k] = x.v + edges[j].w;
					q.push ( { edges[j].to, x.j, x.k, x.v + edges[j].w } );
				}
				if ( x.k + 1 <= K && f[edges[j].to][x.j][x.k + 1] > x.v ) {
					f[edges[j].to][x.j][x.k + 1] = x.v;
					q.push ( { edges[j].to, x.j, x.k + 1, x.v } );
				}
			}
		}
	}
}

void Solve () {
	cin >> n >> m >> K;
	for ( int i = 1; i <= m; i ++ ) {
		cin >> a[i].u >> a[i].v >> a[i].w;
		a[i].id = i;
	}
	sort ( a + 1, a + 1 + m, [] ( Node x, Node y ) { return x.w < y.w; } );
	for ( int i = 1; i <= m; i ++ ) {
		add ( a[i].u, a[i].v, a[i].w, i ), add ( a[i].v, a[i].u, a[i].w, i );
	}
	for ( int i = 0; i <= m; i ++ ) {
		sum += a[i].w;
		dijkstra ( i );
		for ( int j = 0; j <= i; j ++ ) {
			for ( int k = 0; k <= K && j + k <= i; k ++ ) {
				ans = min ( ans, f[n][j][k] + sum );
			}
		}
	}
	cout << ans;
}

signed main () {
#ifdef judge
	freopen ( "Code.in", "r", stdin );
	freopen ( "Code.out", "w", stdout );
	freopen ( "Code.err", "w", stderr );
#endif
	Solve ();
	return 0;
}
```

---


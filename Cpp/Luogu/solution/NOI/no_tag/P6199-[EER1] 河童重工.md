# [EER1] 河童重工

## 题目背景

妖怪之山上生活着两种妖怪，鸦天狗和河童。从前，他们各有自己专属的交通线路，可以在妖怪之山的各个地点之间移动，但两套交通线路的维护成本实在是太高了！因此妖怪们现在想要把两套线路精简成一套。这个繁重的工程就被委托给河童重工了。

## 题目描述

妖怪之山上有 $n$ 个地点，鸦天狗和河童的两套交通线路都是分别由一些连接这些地点的无向道路组成的，每条道路有自己的长度，把这些道路看成有权边，那么他们的两套线路分别可以表示成两棵 $n$ 个节点的树 $T_1, T_2$（有 $n-1$ 条边的有边权无向连通图），河童重工现在要新建一些无向道路，新建一条无向道路 $(i,j)$ 的花费是 $dist_{T_1}(i,j)+dist_{T_2}(i,j)$（即 $T_1,T_2$ 上 $i$ 到 $j$ 的距离之和），河童重工要保证妖怪之山的任意两个节点都能只通过新修建的道路互相到达。但由于如果花费过多可能引起异变，所以他们希望这个工程的总花费最少。

荷取作为这个工程的总设计师，请你帮她算一算，修建新道路的总花费最少是多少？

## 说明/提示

对于 $100\%$ 的数据，满足 $2 \leq n \leq 10^5$。

本题共有 $5$ 个子任务，每个子任务的限制如下：

子任务 $1$（$15$ 分)：保证 $2 \leq n \leq 1000$。

子任务 $2$（$15$ 分)：保证 $T_1, T_2$ 分别是一条链。

子任务 $3$（$5$ 分)：保证 $T_1, T_2$ 除了边权完全相同（即如果将两棵树看成无边权树，那么它们是相同的）。

子任务 $4$（$5$ 分)：保证 $T_2$ 是一条链。

子任务 $5$（$60$ 分)：无特殊限制。

## 样例 #1

### 输入

```
5
1 2 1
1 3 1
2 4 1
2 5 1
2 3 1
2 4 1
3 5 1
3 1 1
```

### 输出

```
10
```

## 样例 #2

### 输入

```
4
1 2 1
1 3 1
1 4 1
1 2 1
2 3 1
3 4 1 
```

### 输出

```
8
```

# 题解

## 作者：梦梦子 (赞：17)

记$c(x,y)​$表示边权。

对$T_2$进行点分治

设$x,y$在当前点分树中到根的距离为$dep_x,dep_y$

那么我们可以认为$(x,y)$的边权为$dist_1(x,y)+dep_x+dep_y$

因为，若在当前点分树中，$lca(x,y)$等与点分树的重心，那么上式是成立的，否则$c(x,y)\leq dist_1(x,y)+dep_x+dep_y$

真实的$c(x,y)$会递归进下一个点分树被考虑到，我们可以认为这个式子依然成立，对答案不会有影响

那么我们希望在当前点分树的意义下删除一些一定不会对最终答案有贡献的$(x,y)$

考虑以下算法：

1.首先求出当前点分树中的点，在$T_1$当中的虚树。

2.对于所有当前点分树中的点$x$,建立新点$x'$,在虚树上加一条$(x,x')$边，边权为$dep_x$，我们称$mp[x']=x$,我们称所有这样的$x'$为源点

3.跑两遍树$dp$,对于虚树上每个点$y$，记录$pre[y]$表示离$y$最近的源点（如果有多个最近的随便记一个即可），$dist[y]$表示$pre[y]$与$y$的距离

4.枚举虚树中每一条边$(a,b)$，将$(mp[pre[a]],mp[pre[b]],dist[a]+dist[b]+l(a,b))$，$l$表示虚树上一条边的长度。这条边加入候选边集

所有点分树的所有候选边集大小总共$O(n\log n)$，对这些边进行$kruskal$算法，即可算出答案。

使用预处理$ST$表求$lca$可在$O(n\log n)$选出候选边集。

算法正确性证明请读者自行思考。

算法复杂度$O(n\log n+n\log n\log (n\log n))$

后面那第二个$\log$只是给$n\log n$条边排序的复杂度，众所周知$sort$排序是很快的，因此此算法可在一定意义上认为是$O(n\log n)$。$std$是基于这种做法，因此很多使用$boruvka$算法或其他做法的$O(n\log^2n)$可能会被卡常，实际上时限非常宽松。

按照此算法，$atcoder$上的那个子问题可做到$O(n)$

---

## 作者：command_block (赞：7)

子问题 : [AT3611 Tree MST](https://www.luogu.com.cn/blog/command-block/ds-ji-lu-at3611-tree-mst) ; 解法 : [题解 AT3611 【Tree MST】](https://www.luogu.com.cn/blog/command-block/solution-at3611)

**题意** : 给出两棵树$T_1,T_2$,点的标号对应,有边权。

按照如下的规则生成一个无向图 : $(u,v)$之间的边权为 $T_1.dis(u,v)+T_2.dis(u,v)$

求这张图的 `MST` 的边权和。$n\leq 10^5$,时限$\texttt{4s}$.

------------

首先抛出结论 : 对于(完全图)`MST`问题,我们可以先选定一个**边集**,做一次`MST`,只保留其中的边,最后对保留的边统一做`MST`,一定能得到最优解。

先对其中一棵树下手,考虑点分治。只考虑越过分治中心的路径对应的连边。

考虑`dfs`一下求出每个点的深度,则$(u,v)$之间连边的代价就是$dep[u]+dep[v]+T_2.dis(u,v)$

注意,当两个点在同一子树内时,这个式子并不正确,但是比直接连接的真实值更大,所以不影响答案。

现在我们就是要对这个东西求一个`MST`。可以考虑建立虚树然后就变成上面的 {子问题} 了。

虚树里面的辅助点不应该连边,可以把$dep$设置为`INF`便于判断。

子问题和虚树的复杂度均是$O(n\log n)$,本题的复杂度就是$O(n\log^2n)$

代码较长,这里给出一些实现上的技巧:

- 把虚树节点编号映射到$[1,m]$

- DP做子问题的时候封装结构体

- 把点分治的分治区域直接拷贝出来,避免多余的`dfs`

- 对于一个点的联通块,将其忽略(不知道会不会快)

- 封装成为难题,请善用宏

另外由于我的两空格无`Tab`缩进,这里可能显示地有点奇怪……

```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
#define MaxN 100500
using namespace std;
inline int read()
{
  int X=0;char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
vector<int> g[MaxN],l[MaxN];
inline void adl(int f,int t,int len){
  g[f].push_back(t);l[f].push_back(len);
  g[t].push_back(f);l[t].push_back(len);
}
int w[MaxN],c[MaxN];
#define Pr pair<int,int>
#define mp make_pair
#define fir first
#define sec second
struct Data
{
  Pr x,x2;int c;
  void chk(const Data &t){
    if (t.c==c){
      x=min(x,t.x);
      x2=min(x2,t.x2);
    }else {
      if (t.x<=x){
        x2=min(x,t.x2);
        c=t.c;x=t.x;
      }else x2=min(x2,t.x);
    }
  }
  Pr get(int tc){
    if (tc==c)return x2;
    return x;
  }
}ff[MaxN];
#define f ff
void dfs1(int u,int fa)
{
  f[u].x=mp(w[u],u);
  f[u].c=c[u];
  for (int i=0,v;i<g[u].size();i++)
    if ((v=g[u][i])!=fa){
   	  dfs1(v,u);
   	  f[v].x.fir+=l[u][i];
   	  f[v].x2.fir+=l[u][i];
   	  f[u].chk(f[v]);
   	  f[v].x.fir-=l[u][i];
      f[v].x2.fir-=l[u][i];
   	}
}
void dfs2(int u,int fa)
{
  for (int i=0,v;i<g[u].size();i++)
    if ((v=g[u][i])!=fa){
      f[u].x.fir+=l[u][i];
      f[u].x2.fir+=l[u][i];
      f[v].chk(f[u]);
      f[u].x.fir-=l[u][i];
      f[u].x2.fir-=l[u][i];
   	  dfs2(v,u);
    }
}
int findf(int u)
{return c[u]==u ? u : c[u]=findf(c[u]);}
bool merge(int x,int y)
{
  x=findf(x);y=findf(y);
  if (x==y)return 0;
  c[x]=y;return 1;
}
#define INF 1010000000
Pr p[MaxN];
int tc,tn,tl,t[MaxN];
struct Line
{int fr,to,len;}s[MaxN<<5];
void sub()
{
  int stl=tl;
  for (int i=1;i<=tn;i++)c[i]=i;
  while(tl-stl<tc-1){
    for (int i=1;i<=tn;i++){
      p[i].fir=f[i].x.fir=f[i].x2.fir=INF;
      f[i].x.sec=f[i].x2.sec=f[i].c=0;
    }dfs1(1,0);dfs2(1,0);
    for (int i=1;i<=tn;i++)
      if (w[i]<INF){
        Pr sav=f[i].get(c[i]);
        sav.fir+=w[i];
        p[c[i]]=min(p[c[i]],sav);
      }
    for (int i=1;i<=tn;i++)
      if (p[i].fir<INF&&merge(i,p[i].sec))
        s[++tl]=(Line){t[i],t[p[i].sec],p[i].fir};
    for (int i=1;i<=tn;i++)findf(i);
  }for (int i=1;i<=tn;i++)
    {g[i].clear();l[i].clear();}
}
#undef f
int in[MaxN],out[MaxN],dep[MaxN],f[17][MaxN],cd[MaxN];
int lca(int x,int y)
{
  if (dep[x]>dep[y])swap(x,y);
  int k=16;
  while(k--)
    while(dep[f[k][y]]>=dep[x])
      y=f[k][y];
  k=16;
  while(k--)
    while(f[k][x]!=f[k][y])
      {x=f[k][x];y=f[k][y];}
  return x==y ? x: f[0][x];
}
int tim;
void getf(int u,int fa)
{
  in[u]=++tim;
  f[0][u]=fa;
  dep[u]=dep[fa]+1;
  for (int i=0,v;i<g[u].size();i++)
    if ((v=g[u][i])!=fa){
      cd[v]=cd[u]+l[u][i];
      getf(v,u);
    }
  out[u]=tim;
}
int wd[MaxN],e[MaxN],ef,tp[MaxN],st[MaxN];
bool cmp(int A,int B){return in[A]<in[B];}
void calc()
{
  ef++;tc=tn;
  sort(t+1,t+tn+1,cmp);
  for (int i=1;i<=tn;i++)e[t[i]]=ef;
  int top=tn;
  for (int i=1,u;i<top;i++)
    if (e[u=lca(t[i],t[i+1])]<ef){
      e[t[++tn]=u]=ef;
      wd[u]=INF;
    }
  sort(t+1,t+tn+1,cmp);
  top=0;
  for (int i=1;i<=tn;i++)
    w[i]=wd[t[tp[t[i]]=i]];
  for (int i=1,u;i<=tn;i++){
    u=t[i];
    while(top>1&&out[u]>out[st[top]]){
      adl(tp[st[top-1]],tp[st[top]],cd[st[top]]-cd[st[top-1]]);
      top--;
    }st[++top]=u;
  }while(top>1){
    adl(tp[st[top-1]],tp[st[top]],cd[st[top]]-cd[st[top-1]]);
    top--;
  }sub();
}
vector<int> g2[MaxN],l2[MaxN];
#define g g2
#define l l2
int ms[MaxN],siz[MaxN];
bool vis[MaxN];
void pfs(int u,int fa)
{
  siz[t[++tn]=u]=1;ms[u]=0;
  for (int i=0,v;i<g[u].size();i++)
    if ((v=g[u][i])!=fa&&!vis[v]){
      pfs(v,u);
      siz[u]+=siz[v];
      ms[u]=max(ms[u],siz[v]);
    }
}
int getrt(int u)
{
  tn=0;pfs(u,0);
  int rt=0;
  for (int i=1;i<=tn;i++){
    ms[t[i]]=max(ms[t[i]],tn-siz[t[i]]);
    if (ms[t[i]]<ms[rt])rt=t[i];
  }return rt;
}
void dfs(int u,int fa)
{
  for (int i=0,v;i<g[u].size();i++)
    if ((v=g[u][i])!=fa&&!vis[v])
      {wd[v]=wd[u]+l[u][i];dfs(v,u);}
}
void solve(int u)
{
  if (siz[u]==1)return ;
  wd[u]=0;dfs(u,0);
  calc();vis[u]=1;
  for (int i=0,v;i<g[u].size();i++)
    if (!vis[v=g[u][i]])
   	  solve(getrt(v));
}
#undef g
#undef l
bool cmpL(const Line &A,const Line &B)
{return A.len<B.len;}
int n;
int main()
{
  n=read();
  for (int i=1,fr,to,len;i<n;i++){
    fr=read();to=read();len=read();
    adl(fr,to,len);
  }getf(1,0);
  for (int i=1;i<=n;i++)
    {g[i].clear();l[i].clear();}
  for (int j=1;j<16;j++)
    for (int i=1;i<=n;i++)
      f[j][i]=f[j-1][f[j-1][i]];
  for (int i=1,fr,to,len;i<n;i++){
    fr=read();to=read();len=read();
    g2[fr].push_back(to);l2[fr].push_back(len);
    g2[to].push_back(fr);l2[to].push_back(len);
  }ms[0]=n+1;solve(getrt(1));
  long long ans=0;
  for (int i=1;i<=n;i++)c[i]=i;
  sort(s+1,s+tl+1,cmpL);
  for (int i=1;i<=tl;i++)
    if (merge(s[i].fr,s[i].to))
      ans+=s[i].len;
  printf("%lld",ans);
}
```

此外,这题对每个点额外赋权也是可以做的。

---

## 作者：Itst (赞：7)

跟出题人交流了一下不太清楚为什么跑得非常慢，可能是有些东西写挂了，有空来 debug 一下卡卡常数。幸亏出题人开了 4s 要不然当场暴毙。

---

题目简述：给出一个 $n$ 个点的完全图和两棵树，图上 $(i,j)$ 边权等于 $dist_1(i,j) + dist_2(i,j)$，$dist_p(i,j)$ 表示第 $p$ 棵树上两点距离。你需要求出这个完全图的最小生成树边权和。

$n \leq 10^5$

---

sub-problem：[Here](https://www.luogu.com.cn/problem/AT3611)

使用 Boruvka 求最小生成树。在每一层中我们需要找到每一个已经形成的连通块与这个连通块外的某一个连通块中连接的边的最小权值，即对于每一个点计算与这个点不在同一个连通块内的所有点与它的边权最小值。

注意到与图上距离相关的是两棵树的距离，见到这种贡献与多棵树相关的问题 $99.9\%$ 要在一棵树上树分治。

对于第二棵树点分治，考虑经过分治重心的所有路径的贡献。注意到进行点分治后，在第二棵树上的一条穿过分治重心的路径可以转化为经过分治重心的两条路径，而这两条路径的长度只与路径端点是谁有关。

那么可以将一个在分治区域内的点 $i$ 的点权 $val_i$ 设做它到分治重心的距离，那么对于一条两个端点都在第二棵树当前分治区域的图上的边，它的长度就是 $val_i + val_j + dist_1(i,j)$。然后你就把题目转化为了上面给出的 sub-problem！

但还有一个事情：对于分治重心的同一个子树内的两个点，它们之间的边不应该被算入，但是在现在算入答案一定不如在某一次点分治的时候这两个点被分入不同的子树时产生的贡献优。所以把这样的边算入答案也是无妨的。

那么现在我们只需要快速地解决 sub-problem 就可以了。

对当前分治区域内的所有点在第二棵树上建立虚树，并在虚树上 DP，对于每个点 $x$ 求出 $dist_1(x,y)+val_y$ 的最小值以及与取到最小值的 $y$ 不在同一个连通块的所有点 $z$ 的 $dist_1(x,z) + val_z$ 的最小值。这个 DP 可以利用两次 dfs 解决：第一次 dfs 由儿子向父亲转移，第二次 dfs 由父亲向儿子转移。因为一条路径一定先向上走若干步再向下走若干步，所以这样贡献一定是正确的。

最后根据取到最小值的点是否和当前点在同一个连通块内，我们就可以得到当前每一个点在这一个分治区域内能够连出的最小权值的边的权值和其端点。

这样我们就可以得到答案了。复杂度 $O(n \log ^3 n)$（Boruvka + 点分治 + 每一次点分治需要建虚树，虚树里有排序和 LCA）。

值得注意的是判断在不在同一个连通块内需要使用并查集，但可以分析得到并查集产生的复杂度是 $O(n \log^2 n)$ 的。

这个复杂度并不优秀，会在 subtask4 上 TLE（非常魔幻的一件事是在 subtask4 上复杂度应该是 $O(n \log^2 n)$ 的因为点分治所经过的点数之和是线性的）。一个优化是：第二棵树的树形态永远不会变，所以点分治的过程和每一层的虚树总是一样的。我们在第一次建好之后把它存下来，之后直接拿过来用就行。复杂度降低为 $O(n \log^2 n)$，可以通过。

---

题外话：如果你在 Atcoder 上看我在 sub-problem 上的 AC 提交，你会发现写法并不是如上面所述的 Boruvka + 虚树 DP，而是点分治 + Kruskal。跟出题人进行交流过后感觉似乎利用这个做法进行拓展就可以得到出题人给出的标算了。

---

Code 长度较长，请谨慎食用。

```
#include<bits/stdc++.h>
using namespace std;

int read(){
	int a = 0; bool f = 0; char c = getchar(); while(!isdigit(c)){f = c == '-'; c = getchar();}
	while(isdigit(c)){a = a * 10 + c - 48; c = getchar();} return f ? -a : a;
}

const int _ = 1e5 + 7;
struct Edge{int end , upEd , w;}; int N , allmn[_] , id[_] , cnt , val[_];

namespace dsu{
	int fa[_]; int find(int x){return x > N ? 0 : fa[x] == x ? x : (fa[x] = find(fa[x]));}
}

namespace tree1{
	Edge Ed[_ << 1]; int head[_] , cntEd;
	void addEd(int a , int b , int c){Ed[++cntEd] = (Edge){b , head[a] , c}; head[a] = cntEd;}

	int dfn[_] , fa[_] , top[_] , sz[_] , son[_] , dep[_] , len[_];
	
	void dfs(int x , int p){
		sz[x] = 1; fa[x] = p; dep[x] = dep[p] + 1;
		for(int i = head[x] ; i ; i = Ed[i].upEd)
			if(Ed[i].end != p){
				len[Ed[i].end] = len[x] + Ed[i].w;
				dfs(Ed[i].end , x); sz[x] += sz[Ed[i].end];
				if(sz[Ed[i].end] > sz[son[x]]) son[x] = Ed[i].end;
			}
	}

	void dfs1(int x , int t){
		static int ts = 0; dfn[x] = ++ts; top[x] = t; if(!son[x]) return;
		dfs1(son[x] , t);
		for(int i = head[x] ; i ; i = Ed[i].upEd)
			if(Ed[i].end != fa[x] && Ed[i].end != son[x]) dfs1(Ed[i].end , Ed[i].end);
	}
	
	int LCA(int x , int y){
		while(top[x] != top[y]){if(dep[top[x]] < dep[top[y]]) swap(x , y); x = fa[top[x]];}
		return dep[x] < dep[y] ? x : y;
	}

	int dist(int x , int y){return len[x] + len[y] - 2 * len[LCA(x , y)];}
	
	vector < pair < int , int > > ch[_]; int mn[_][2][2];
	
	void merge(int p , int q , int w){
		static int tmp[2][2]; bool fl = dsu::find(mn[p][0][1]) == dsu::find(mn[q][0][1]);
		if(mn[p][0][0] < 0ll + mn[q][0][0] + w){
			tmp[0][0] = mn[p][0][0]; tmp[0][1] = mn[p][0][1];
			if(mn[p][1][0] < 0ll + mn[q][fl][0] + w){tmp[1][0] = mn[p][1][0]; tmp[1][1] = mn[p][1][1];}
			else{tmp[1][0] = mn[q][fl][0] + w; tmp[1][1] = mn[q][fl][1];}
		}
		else{
			tmp[0][0] = mn[q][0][0] + w; tmp[0][1] = mn[q][0][1];
			if(0ll + mn[q][1][0] + w < mn[p][fl][0]){tmp[1][0] = mn[q][1][0] + w; tmp[1][1] = mn[q][1][1];}
			else{tmp[1][0] = mn[p][fl][0]; tmp[1][1] = mn[p][fl][1];}
		}
		memcpy(mn[p] , tmp , sizeof(tmp));
	}

	bool in[_];
	void dp1(int x){for(auto t : ch[x]){dp1(t.first); merge(x , t.first , t.second);}}

	void dp2(int x){
		for(auto t : ch[x]){merge(t.first , x , t.second); dp2(t.first);}
		ch[x].clear(); bool fl = dsu::find(mn[x][0][1]) == dsu::find(x);
		if(in[x] && 0ll + mn[x][fl][0] + val[x] < allmn[x]){allmn[x] = mn[x][fl][0] + val[x]; id[x] = mn[x][fl][1];}
		memset(mn[x] , 0x7f , sizeof(mn[x])); in[x] = 0;
	}

	struct data{bool in; int id , fa;};
	vector < data > innode[_];
	
	void build(int id){
		if(innode[id].empty()) return;
		int rt = 0;
		for(auto t : innode[id]){
			if(!t.fa) rt = t.id; else ch[t.fa].push_back(make_pair(t.id , len[t.id] - len[t.fa]));
			if(in[t.id] = t.in){mn[t.id][0][0] = val[t.id]; mn[t.id][0][1] = t.id;}
		}
		dp1(rt); dp2(rt);
	}

	void build_save(vector < int > &node , int id){
		if(node.size() == 1) return;
		static int stk[_]; int top = 0;
		for(auto t : node){
			in[t] = 1;
			if(top){
				int p = LCA(stk[top] , t);
				while(dep[stk[top - 1]] >= dep[p]){innode[id].push_back((data){in[stk[top]] , stk[top] , stk[top - 1]}); --top;}
				if(stk[top] != p){innode[id].push_back((data){in[stk[top]] , stk[top] , p}); stk[top] = p;}
			}
			stk[++top] = t;
		}
		for(int i = 1 ; i < top ; ++i) innode[id].push_back((data){in[stk[i + 1]] , stk[i + 1] , stk[i]});
		innode[id].push_back((data){in[stk[1]] , stk[1] , 0});
		for(auto t : node) in[t] = 0;
	}
	
	void input(){
		for(int i = 1 ; i < N ; ++i){int x = read() , y = read() , z = read(); addEd(x , y , z); addEd(y , x , z);}
		dfs(1 , 0); dfs1(1 , 1); memset(mn , 0x7f , sizeof(mn));
	}
}

namespace tree2{
	Edge Ed[_ << 1]; int head[_] , cntEd;
	void addEd(int a , int b , int c){Ed[++cntEd] = (Edge){b , head[a] , c}; head[a] = cntEd;}
	int dfn[_] , fa[_] , top[_] , sz[_] , son[_] , dep[_] , len[_];
	
	void dfs(int x , int p){
		sz[x] = 1; fa[x] = p; dep[x] = dep[p] + 1;
		for(int i = head[x] ; i ; i = Ed[i].upEd)
			if(Ed[i].end != p){
				len[Ed[i].end] = len[x] + Ed[i].w;
				dfs(Ed[i].end , x); sz[x] += sz[Ed[i].end];
				if(sz[Ed[i].end] > sz[son[x]]) son[x] = Ed[i].end;
			}
	}
	
	void dfs1(int x , int t){
		static int ts = 0; dfn[x] = ++ts; top[x] = t; if(!son[x]) return;
		dfs1(son[x] , t);
		for(int i = head[x] ; i ; i = Ed[i].upEd)
			if(Ed[i].end != fa[x] && Ed[i].end != son[x]) dfs1(Ed[i].end , Ed[i].end);
	}

	int LCA(int x , int y){
		while(top[x] != top[y]){if(dep[top[x]] < dep[top[y]]) swap(x , y); x = fa[top[x]];}
		return dep[x] < dep[y] ? x : y;
	}

	int dist(int x , int y){return len[x] + len[y] - 2 * len[LCA(x , y)];}
	
	void input(){
		for(int i = 1 ; i < N ; ++i){int x = read() , y = read() , z = read(); addEd(x , y , z); addEd(y , x , z);}
		dfs(1 , 0); dfs1(1 , 1);
	}

	bool vis[_]; int nsz , msz , mid;

	void getsz(int x){
		vis[x] = 1; ++nsz;
		for(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]) getsz(Ed[i].end);
		vis[x] = 0;
	}

	int getrt(int x){
		vis[x] = 1; int mx = 0 , sz = 1;
		for(int i = head[x] ; i ; i = Ed[i].upEd)
			if(!vis[Ed[i].end]){int t = getrt(Ed[i].end); sz += t; mx = max(mx , t);}
		mx = max(mx , nsz - sz); if(msz > mx){msz = mx; mid = x;}
		vis[x] = 0; return sz;
	}

	void getnode(int x , int l , vector < pair < int , int > > &node){
		node.push_back(make_pair(x , l)); vis[x] = 1;
		for(int i = head[x] ; i ; i = Ed[i].upEd)
			if(!vis[Ed[i].end]) getnode(Ed[i].end , l + Ed[i].w , node);
		vis[x] = 0;
	}

	vector < pair < int , int > > node[_];
	void divide(int x){
		nsz = 0; msz = 1e9; getsz(x); getrt(x); x = mid;
		if(node[x].empty()){
			getnode(x , 0 , node[x]); vector < int > pid;
			for(auto t : node[x]) pid.push_back(t.first);
			sort(pid.begin() , pid.end() , [&](int p , int q){return tree1::dfn[p] < tree1::dfn[q];});
			tree1::build_save(pid , x);
		}
		for(auto t : node[x]) val[t.first] = t.second;
		tree1::build(x); vis[x] = 1;
		for(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]) divide(Ed[i].end);
	}
	
	void work(){
		for(int i = 1 ; i <= N ; ++i) dsu::fa[i] = i;
		long long sum = 0;
		while(cnt != N - 1){
			static int mnid[_];
			memset(vis , 0 , sizeof(vis)); memset(allmn , 0x7f , sizeof(allmn)); divide(1);
			for(int i = 1 ; i <= N ; ++i)
				if(!mnid[dsu::find(i)] || allmn[mnid[dsu::find(i)]] > allmn[i]) mnid[dsu::find(i)] = i;
			for(int i = 1 ; i <= N ; ++i)
				if(dsu::find(i) == i){
					int l = mnid[i] , r = id[mnid[i]]; mnid[i] = 0;
					if(dsu::find(r) != i){dsu::fa[i] = dsu::find(r); sum += tree1::dist(l , r) + dist(l , r); ++cnt;}
				}
		}
		cout << sum << endl;
	}
}

int main(){
	freopen("in","r",stdin);
	N = read(); tree1::input(); tree2::input(); tree2::work(); return 0;
}
```

---

## 作者：Kubic (赞：5)

比较经典的套路，写这篇题解来记录一下。

考虑 Boruvka 算法求最小生成树。

这个算法的好处是用 $O(\log n)$ 的代价将最小生成树问题转化为较为简单的数据结构问题。

对于这道题来说，转化后的问题是：每个点 $i$ 有一个颜色 $col_i$，要对于每一个点 $i$ 求出 $\min\limits_{col_i\neq col_j}dis_1(i,j)+dis_2(i,j)$。

考虑在 $T_1$ 上点分治，每次求出当前子树在 $T_2$ 上的虚树。点分治的好处是把 $dis_1(i,j)$ 拆成 $w_i+w_j$。于是直接在虚树上换根 dp 即可。dp 过程中需要记录最大值以及与最大值颜色不同的最大值。

需要注意的一个细节是：点分治过程中在重心的同一儿子的子树内的两个点实际上并不应该在当前过程中计算。

但可以发现由于边权都是正数，所以即便这两个点在当前过程中被计算到了也不会影响答案，这种方案一定不优。

这样直接计算一遍复杂度是 $O(n\log ^2n)$，瓶颈在建虚树。算上 Boruvka 就是 $O(n\log^3 n)$。但虚树的形态是固定的，我们只需要预处理出点分树上每个子树的虚树就可以做到 $O(n\log^2 n)$。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
#define pb push_back
#define ll long long
const int INF=1e9;
int n,m,dfsT,G,vs2[N],rt[N],st[N];ll ans;bool vs1[N];
int dfn1[N],dfn2[N],fa[N],dep[N],s[N],sz[N],hv[N],tp[N];
struct Edge
{
	int v,w;Edge(int _v=0,int _w=0) {v=_v;w=_w;}
	Edge operator + (int t) const {return Edge(v,w+t);}
	Edge operator - (int t) const {return Edge(v,w-t);}
}z[N],dp1[N],dp2[N],dp3[N],dp4[N];
vector<Edge> e1[N],e2[N];struct Node {int u,w;};
vector<Node> vc1[N];vector<int> vc2[N];
bool cmp(int x,int y)
{return (x>0?dfn1[x]:dfn2[-x])<(y>0?dfn1[y]:dfn2[-y]);}
int findRt(int u) {return u==rt[u]?u:rt[u]=findRt(rt[u]);}
void merge(int u,int v,int w)
{u=findRt(u);v=findRt(v);if(u!=v) rt[u]=v,ans+=w;}
void ins(Edge &z1,Edge &z2,Edge vl)
{
	if(vl.w<z1.w) {if(vl.v!=z1.v) z2=z1;z1=vl;}
	else if(vl.w<z2.w && vl.v!=z1.v) z2=vl;
}
void dfs1(int u,int f,int x,int s,bool fl)
{
	int mx=0;sz[u]=1;
	if(fl) vc1[G].pb((Node) {u,s}),vc2[G].pb(u),vs2[u]=G;
	for(auto i:e1[u]) if(i.v!=f && !vs1[i.v])
		dfs1(i.v,u,x,s+i.w,fl),sz[u]+=sz[i.v],mx=max(mx,sz[i.v]);
	mx=max(mx,x-sz[u]);if(!fl && mx<=x/2) G=u;
}
void dfs2(int u,int f)
{
	fa[u]=f;dfn1[u]=++dfsT;dep[u]=dep[f]+1;sz[u]=1;
	for(auto i:e2[u]) if(i.v!=f)
	{
		s[i.v]=s[u]+i.w;dfs2(i.v,u);sz[u]+=sz[i.v];
		if(sz[i.v]>sz[hv[u]]) hv[u]=i.v;
	}dfn2[u]=++dfsT;
}
void dfs3(int u,int f)
{
	tp[u]=f;if(hv[u]) dfs3(hv[u],f);
	for(auto i:e2[u]) if(i.v!=fa[u] && i.v!=hv[u]) dfs3(i.v,i.v);
}
int LCA(int u,int v)
{
	while(tp[u]!=tp[v])
	{if(dep[tp[u]]<dep[tp[v]]) swap(u,v);u=fa[tp[u]];}
	if(dep[u]<dep[v]) swap(u,v);return v;
}
void build(int u,int x)
{
	dfs1(u,0,x,0,0);u=G;dfs1(u,0,x,0,1);vs1[u]=1;
	sort(vc2[u].begin(),vc2[u].end(),cmp);
	for(int i=0;i<(int)vc2[u].size()-1;++i)
	{
		int t=LCA(vc2[u][i],vc2[u][i+1]);
		if(vs2[t]!=u) vs2[t]=u,vc2[u].pb(t);
	}
	for(int i=0;i<(int)vc2[u].size();++i)
	{if(vc2[u][i]<0) break;vc2[u].pb(-vc2[u][i]);}
	sort(vc2[u].begin(),vc2[u].end(),cmp);
	for(auto i:e1[u]) if(!vs1[i.v]) build(i.v,sz[i.v]);
}
void slv(int u)
{
	for(auto i:vc2[u]) if(i>0)
		dp1[i]=dp2[i]=dp3[i]=dp4[i]=Edge(0,INF);
	for(auto i:vc1[u]) dp1[i.u]=Edge(rt[i.u],i.w);
	for(auto i:vc2[u]) if(i>0) st[++st[0]]=i;else
	{
		int f=st[--st[0]],w=s[-i]-s[f];if(!f) continue;
		ins(dp1[f],dp2[f],dp1[-i]+w);ins(dp1[f],dp2[f],dp2[-i]+w);
	}
	for(auto i:vc2[u]) if(i>0)
	{
		int f=st[st[0]],w=s[i]-s[f];st[++st[0]]=i;
		dp3[i]=dp1[i];dp4[i]=dp2[i];if(!f) continue;
		ins(dp3[i],dp4[i],dp3[f]+w);ins(dp3[i],dp4[i],dp4[f]+w);
	}else --st[0];
	for(auto i:vc1[u])
	{
		int t1=rt[i.u];Edge t=t1==dp3[i.u].v?dp4[i.u]:dp3[i.u];
		t=t+i.w;if(t.w<z[t1].w) z[t1]=t;
	}
}
void Boruvka()
{
	for(int i=1;i<=n;++i) rt[i]=i;
	while(1)
	{
		bool fl=0;
		for(int i=1;i<=n;++i)
		{findRt(i);if(rt[i]!=rt[1]) fl=1;z[i]=Edge(0,INF);}
		if(!fl) break;for(int i=1;i<=n;++i) slv(i);
		for(int i=1;i<=n;++i) if(rt[i]==i) merge(i,z[i].v,z[i].w);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1,u,v,w;i<n;++i)
	{
		scanf("%d %d %d",&u,&v,&w);
		e1[u].pb(Edge(v,w));e1[v].pb(Edge(u,w));
	}
	for(int i=1,u,v,w;i<n;++i)
	{
		scanf("%d %d %d",&u,&v,&w);
		e2[u].pb(Edge(v,w));e2[v].pb(Edge(u,w));
	}dfs2(1,0);dfs3(1,1);build(1,n);Boruvka();
	printf("%lld\n",ans);return 0;
}
```

---

## 作者：zzxLLL (赞：4)


新做法，点分治套点分治。

---

给定两棵带权树 $T_1, T_2$，有一个完全图，$(u, v)$ 的边权为 $\operatorname{dist}_{T_1}(u, v) + \operatorname{dist}_{T_2}(u, v)$，求这个完全图的最小生成树。

一个结论是，将一张图的边划分成多个边集，每个边集做 MST，然后把 MST 并起来再做 MST，得到的就是原图的 MST。

树上问题考虑点分治。对于当前分治重心 $u$，求出其子树生成的完全图的最小生成树。

先建出其儿子的子树的最小生成树，因为是子问题所以分治解决即可。然后再考虑子树与子树之间的连边。根据上面结论这样做是正确的。

先考虑当 $T_1$ 上路径 $(i, j)$ 经过点 $u$ 时，从 $u$ 进行一遍 dfs 求出到子树每个点的距离 $D_{1, x}$，那么点对 $(i, j)$ 在完全图上的边权是 $D_{1, i} + D_{1, j} + \operatorname{dist}_{T_2}(i, j)$。

即使 $(i, j)$ 不经过点 $u$ 也没关系。强制它经过点 $u$，这样得出的值会被真实值大，最后不会选到，没有影响。

此时可以将 $D_{1, x}$ 看作 $T_2$ 上节点 $x$ 的点权 $val_x$，但是这个点权只对 $T_1$ 中 $u$ 的子树内的点有效。所以考虑将 $T_2$ 中建出 $T_1$ 的 $u$ 的子树内节点的虚树，然后在虚树上进行点分治。

设虚树上的点分中心为 $u'$，那么从 $u'$ 开始 dfs 求出其到子树每个点的距离 $D_{2, x}$。点对 $(i, j)$ 在完全图上的边权是 $(val_i + D_{2, i}) + (val_j + D_{2, j})$。显然只需要在 $u'$ 的子树里面选择 $val_x + D_{2, x}$ 的最小值，然后其他点都连边到 $x$ 即可。

实现上其实不需要真的连边。这些边都是完全图的最小生成树的候选的边，丢到一个边集里面，最后做一遍 Kruskal 即可。

分析时间复杂度，在 $T_1$ 上点分治 $\log n$ 层，每层 $n$ 个点。在虚树的点分治中，设虚树大小为 $S$，那么分治了 $\log S$ 层，每层贡献了 $S$ 条边，即虚树上分治一次贡献边数是 $S \log S$ 的。而在 $T_1$ 上每一层 $\sum S = n$ 所以每层是 $n \log n$ 的。在 $T_1$ 上分治 $\log n$ 层故总共有 $n \log^2 n$ 条边。最后的 Kruskal 要给这 $n \log^2 n$ 条边排序，复杂度是 $O(n \log^2 n \log (n \log^2 n))$ 的。~~复杂度瓶颈在排序~~。

想清楚的话代码还是比较好写的。毕竟没什么细节。

```cpp
#include <bits/stdc++.h>
const int M = 1e5 + 10;
const int inf = 1e9 + 7;

inline int read() {
	char ch = getchar();
	int x = 0;
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x;
}

int n, _lg2[M];

struct Edge {
	int u, v;
	long long w;
	inline bool operator<(const Edge &o)const {
		return w < o.w;
	}
};
std::vector<Edge>edges;

struct DSU {
	int fa[M];
	inline int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	inline void merge(int x, int y) {
		fa[find(x)] = find(y);
	}
	inline bool qry(int x, int y) {
		return find(x) == find(y);
	}
	DSU() {
		for (int i = 0; i < M; i++) fa[i] = i;
	}
} dsu;

namespace T2 {
	std::vector<std::pair<int, int> >g[M];
	std::vector<std::pair<int, int> >T[M];

	inline void Add(int u, int v, int w) {
		g[u].push_back({v, w});
		g[v].push_back({u, w});
	}

	int dfn[M], idx, Dist[M];
	struct ST {
		inline int Min(int A, int B) {
			return dfn[A] < dfn[B] ? A : B;
		}
		int st[20][M];
		inline void build() {
			for (int j = 1; (1 << j) <= n; j++)
				for (int i = 1; i + (1 << j) - 1 <= n; i++)
					st[j][i] = Min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
		}
		inline int LCA(int u, int v) {
			if (u == v) return u;
			if ((u = dfn[u]) > (v = dfn[v])) std::swap(u, v);
			int k = _lg2[v - u++];
			return Min(st[k][u], st[k][v - (1 << k) + 1]);
		}
		inline int dis(int u, int v) {
			return Dist[u] + Dist[v] - 2 * Dist[LCA(u, v)];
		}
	} lca;
	inline void dfs(int u, int fa) {
		lca.st[0][dfn[u] = ++idx] = fa;
		for (auto E : g[u])
			if (E.first != fa)
				Dist[E.first] = Dist[u] + E.second, dfs(E.first, u);
	}

	int val[M];

	std::vector<int>S0;
	inline void build_virtual_tree(std::vector<int>&S) {
		std::sort(S.begin(), S.end(), [](int A, int B) {
			return dfn[A] < dfn[B];
		});

		S0.clear(), S0.push_back(S.front());
		for (int i = 1; i < (int)S.size(); i++)
			S0.push_back(lca.LCA(S[i - 1], S[i])), S0.push_back(S[i]);

		std::sort(S0.begin(), S0.end(), [](int A, int B) {
			return dfn[A] < dfn[B];
		});
		S0.erase(std::unique(S0.begin(), S0.end()), S0.end());
		for (int u : S0) T[u].clear(), dsu.fa[u] = u;

		for (int i = 1; i < (int)S0.size(); i++) {
			int lc = lca.LCA(S0[i - 1], S0[i]);
			T[lc].push_back({S0[i], lca.dis(lc, S0[i])});
			T[S0[i]].push_back({lc, lca.dis(lc, S0[i])});
		}
	}

	bool vis[M], key[M];
	int siz[M], dis[M];
	int totsiz, minsiz, center;
	inline void getcenter(int u, int f) {
		siz[u] = 1;
		int tmp = 0;
		for (auto E : T[u]) {
			if (E.first == f || vis[E.first]) continue;
			getcenter(E.first, u), siz[u] += siz[E.first];
			tmp = std::max(tmp, siz[E.first]);
		}
		tmp = std::max(tmp, totsiz - siz[u]);
		if (tmp < minsiz) minsiz = tmp, center = u;
	}

	std::vector<int>pt;
	inline void getsize(int u, int f) {
		siz[u] = 1;
		for (auto E : T[u]) {
			if (vis[E.first] || E.first == f) continue;
			getsize(E.first, u), siz[u] += siz[E.first];
		}
	}
	inline void getdis(int u, int f) {
		if (key[u]) pt.push_back(u);
		for (auto E : T[u]) {
			if (E.first == f || vis[E.first]) continue;
			dis[E.first] = dis[u] + E.second, getdis(E.first, u);
		}
	}

	inline void zzxLLL(int u) {
		vis[u] = true, getsize(u, 0);
		for (auto E : T[u]) {
			if (vis[E.first]) continue;
			totsiz = siz[E.first], minsiz = inf;
			getcenter(E.first, u), zzxLLL(center);
		}

		pt.clear(), dis[u] = 0, getdis(u, 0);
		int cur = u;
		long long minn = val[u] + dis[u];
		for (int x : pt)
			if (dis[x] + val[x] < minn) minn = dis[x] + val[x], cur = x;
		for (int x : pt)
			if (x != cur)
				edges.push_back({x, cur, (long long)dis[x] + val[x] + minn});

		vis[u] = false;
	}

	inline void work(std::vector<int>&S) {
		build_virtual_tree(S);
		totsiz = S0.size(), minsiz = inf;
		getcenter(S0.front(), 0), zzxLLL(center);
	}
};

namespace T1 {
	std::vector<std::pair<int, int> >g[M];
	inline void Add(int u, int v, int w) {
		g[u].push_back({v, w});
		g[v].push_back({u, w});
	}

	bool vis[M];
	int siz[M], dis[M];
	int totsiz, minsiz, center;
	inline void getcenter(int u, int f) {
		siz[u] = 1;
		int tmp = 0;
		for (auto E : g[u]) {
			if (E.first == f || vis[E.first]) continue;
			getcenter(E.first, u), siz[u] += siz[E.first];
			tmp = std::max(tmp, siz[E.first]);
		}
		tmp = std::max(tmp, totsiz - siz[u]);
		if (tmp < minsiz) minsiz = tmp, center = u;
	}

	std::vector<int>pt;
	inline void getdis(int u, int f) {
		pt.push_back(u), siz[u] = 1;
		for (auto E : g[u]) {
			if (E.first == f || vis[E.first]) continue;
			dis[E.first] = dis[u] + E.second;
			getdis(E.first, u), siz[u] += siz[E.first];
		}
	}

	inline void Divide_Conquer(int u) {
		vis[u] = true, pt.clear();
		dis[u] = 0, getdis(u, 0);

		for (int x : pt) T2::val[x] = dis[x], T2::key[x] = true;
		T2::work(pt);
		for (int x : pt) T2::val[x] = inf, T2::key[x] = false;

		for (auto E : g[u]) {
			if (vis[E.first]) continue;
			totsiz = siz[E.first], minsiz = inf;
			getcenter(E.first, u), Divide_Conquer(center);
		}
	}
	inline void work() {
		totsiz = n, minsiz = inf;
		getcenter(1, 0), Divide_Conquer(center);
	}
};

int main() {
	_lg2[0] = -1;
	for (int i = 1; i < M; i++) _lg2[i] = _lg2[i >> 1] + 1;
	for (int i = 0; i < M; i++) T2::val[i] = inf;

	n = read();
	for (int i = 1, u, v, w; i < n; i++)
		u = read(), v = read(), w = read(), T1::Add(u, v, w);
	for (int i = 1, u, v, w; i < n; i++)
		u = read(), v = read(), w = read(), T2::Add(u, v, w);
	T2::dfs(1, 0), T2::lca.build();
	T1::work();

	long long ans = 0;
	std::sort(edges.begin(), edges.end());
	for (Edge E : edges)
		if (!dsu.qry(E.u, E.v)) ans += E.w, dsu.merge(E.u, E.v);
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：鲤鱼江 (赞：3)

SC 省集时 dx 提到的一个题，感觉比较经典。

首先发现 $dist_{T_1}(x,y)+dist_{T_2}(x,y)$ 牵扯到两棵树很不舒服，所以我们想要尽可能地去掉其中一棵树的影响，如果你做过暴力写挂或通道之类的题，肯定对这种东西不陌生。

考虑对 $T_1$ 点分治一下，记点 $x$ 离分治中心的距离为 $dis_x$ 那么两个点 $x,y$ 之间的权值应该为 $dis_x+dis_y+dist_{T_2}(x,y)$，因为是求最小生成树，所以 $x,y$ 在同一棵子树的时候不会影响最终答案。

如果你知道 AT_cf17_final_j，一定会对这种东西感到熟悉，我们令 $w_x=dis_x$，并在 $T_2$ 上建出虚树，那么问题被完美地转化到了 Tree MST 上了。

在这里，我们求出该分治中心对应的点集的最小生成树，并取出其所用到的边，那么把所有分治中心最后剩下的边拿出来再求一次最小生成树就做完了。

证明正确性是容易的，不难发现我们先拿出一个边集，对其求出最小生成树并把不在最小生成树上的边全部去掉肯定不会影响答案（如果不连通也不影响），那么我们点分治本质上是把所有跨越分治中心所产生的边做了最小生成树，这明显也是正确的。

所以我们如果能快速地解决 Tree MST 问题，则该问题也可以在优秀的时间复杂度内解决，当然因为建虚树所以不会低于 $O(n\log^ 2n)$。

Tree MST 的经典做法是点分治后 Kruskal 重构树，这样的话会导致保留了 $O(n\log n)$ 条边，放到此题要再呈一个 $O(\log n)$ 所以时间 $O(n\log^3 n)$，空间 $O(n\log^2 n)$，瓶颈在排序导致常数会比较小，所以应该能过，但是此题明显能够做到更优。

我们考虑 Boruvka 算法来解决 Tree MST，每次连边时用换根 DP，可以做到 $O(n\log n)$ 且最后保留的边数为 $O(n)$，故保留的总边数为 $O(n\log n)$，最后时间 $O(n\log^2 n)$ 空间 $O(n\log n)$。

有点细节，我写了两个树剖，一个点分治和一个换根，各种 dfs 差不多加起来有十个。

但是写起来真的很爽很爽。

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N=2e5+10;
struct Edge{
	int x,y,z;
	Edge(int x=0,int y=0,int z=0):x(x),y(y),z(z){;}
	bool operator <(const Edge t)const{return z<t.z;}
}b[N*20];
int C;
struct edge{
	int to,val;
	edge(int to=0,int val=0):
		to(to),val(val){;}
};
namespace MST{
	vector < edge > v[N];
	struct node{
		int c1,v1,c2,v2;
		node(){c1=c2=0;v1=v2=1e15;}
	}f[N],g[N];
	int d[N],tot,bel[N],val[N],fa[N],fr[N];
	inline void clear(){
		for(int x=1;x<=tot;++x){
			int i=d[x];d[x]=val[i]=bel[i]=fa[i]=fr[i]=0;
			f[i]=g[i]=node();v[i].clear();
		}
		tot=0;
	}
	inline void add(int x,int y,int z){v[x].emplace_back(y,z);v[y].emplace_back(x,z);}
	inline void Set(int x,int v){val[bel[d[++tot]=x]=x]=v;}
	int root(int x){return x==fa[x]?x:fa[x]=root(fa[x]);}
	node operator +(node x,node y){
		node z=node();if(x.v1>y.v1) swap(x,y);
		z.c1=x.c1;z.v1=x.v1;
		if(bel[z.c1]==bel[y.c1]){
			swap(y.v1,y.v2);
			swap(y.c1,y.c2);
		}
		z.v2=min(x.v2,y.v1);
		z.c2=(x.v2<y.v1)?x.c2:y.c1;	
		return z;
	}
	void dfs1(int x,int y){
		for(auto i:v[x]){
			if(i.to==y) continue;
			dfs1(i.to,x);node p=f[i.to];
			p.v1+=i.val;p.v2+=i.val;f[x]=p+f[x];
		}
		node z=node();z.c1=x;z.v1=val[x];f[x]=f[x]+z;
	}
	void dfs2(int x,int y){//换根
		for(auto i:v[x]){
			if(i.to==y) continue;
			node p=f[x];p.v1+=i.val;p.v2+=i.val;
			f[i.to]=f[i.to]+p;dfs2(i.to,x);
		}
	}
	inline void Boruvka(){
		int cnt=tot;
		while(cnt>1){
			for(int i=1;i<=tot;++i) f[d[i]]=g[d[i]]=node(),fa[d[i]]=bel[d[i]];
			dfs1(d[1],0);dfs2(d[1],0);
			for(int i=1;i<=tot;++i){
				int x=d[i];f[x].v1+=val[x];f[x].v2+=val[x];
				if(bel[f[x].c1]==bel[x]) f[x].v1=f[x].v2,f[x].c1=f[x].c2;
				g[bel[x]]=g[bel[x]]+f[x];node t=g[bel[x]];
				if(t.c1==f[x].c1&&t.v1==f[x].v1) fr[bel[x]]=x;
			}
			for(int i=1;i<=tot;++i){
				int x=d[i];if(root(g[bel[x]].c1)==root(x)) continue;
				fa[root(x)]=root(g[bel[x]].c1);
				b[++C]=Edge(fr[bel[x]],g[bel[x]].c1,g[bel[x]].v1);
			}
			cnt=0;
			for(int i=1;i<=tot;++i) cnt+=(bel[d[i]]=root(d[i]))==d[i];
		}
		clear();
	}
}

int dep[N],son[N],father[N],top[N],siz[N],sum[N];
vector < edge > v[N];vector < int > p;
void dfs1(int x,int y){
	dep[x]=dep[father[x]=y]+1;siz[x]=1;
	for(auto i:v[x]) if(i.to!=y){
		sum[i.to]=sum[x]+i.val;dfs1(i.to,x);siz[x]+=siz[i.to];
		(siz[son[x]]<siz[i.to])&&(son[x]=i.to);
	}
}
void dfs2(int x,int topf){
	top[x]=topf;if(son[x]) dfs2(son[x],topf);
	for(auto i:v[x]) if(!top[i.to]) dfs2(i.to,i.to);
}
inline int lca(int x,int y){
	while(top[x]!=top[y]) dep[top[x]]>dep[top[y]]?x=father[top[x]]:y=father[top[y]];
	return dep[x]<dep[y]?x:y;
}
inline int Dis(int x,int y){return sum[x]+sum[y]-(sum[lca(x,y)]<<1);}

namespace Tree2{
	vector < edge > v[N];
	int dep[N],son[N],father[N],id[N],idx,top[N],siz[N],sum[N];
	inline void add(int x,int y,int z){v[x].emplace_back(y,z);v[y].emplace_back(x,z);}
	void dfs1(int x,int y){
		dep[x]=dep[father[x]=y]+1;siz[x]=1;id[x]=++idx;
		for(auto i:v[x]) if(i.to!=y){
			sum[i.to]=sum[x]+i.val;dfs1(i.to,x);siz[x]+=siz[i.to];
			(siz[son[x]]<siz[i.to])&&(son[x]=i.to);
		}
	}
	void dfs2(int x,int topf){
		top[x]=topf;if(son[x]) dfs2(son[x],topf);
		for(auto i:v[x]) if(!top[i.to]) dfs2(i.to,i.to);
	}
	inline int LCA(int x,int y){
		while(top[x]!=top[y]) dep[top[x]]>dep[top[y]]?x=father[top[x]]:y=father[top[y]];
		return dep[x]<dep[y]?x:y;
	}
	inline void Build(vector < int > &p,int st){
		sort(p.begin(),p.end(),[](const int x,const int y){return id[x]<id[y];});
		int len=p.size();for(int i=1;i<len;++i) p.emplace_back(LCA(p[i],p[i-1]));
		sort(p.begin(),p.end(),[](const int x,const int y){return id[x]<id[y];});
		p.erase(unique(p.begin(),p.end()),p.end());len=p.size();
		for(int i=1;i<len;++i){int z=LCA(p[i],p[i-1]);MST::add(z,p[i],sum[p[i]]-sum[z]);}
		for(int x:p) MST::Set(x,Dis(st,x));
		MST::Boruvka();p.clear();
	}
	inline void init(){dfs1(1,0);dfs2(1,1);}
}

int n,fa[N],pos[N];

int root(int x){return x==fa[x]?x:fa[x]=root(fa[x]);}
inline void merge(int x,int y){fa[root(x)]=root(y);}
inline void add(int x,int y,int z){v[x].emplace_back(y,z);v[y].emplace_back(x,z);}

int flag[N],rt;
int GetSize(int x,int y){
	int tmp=1;for(auto i:v[x]) if(i.to!=y&&!flag[i.to]) tmp+=GetSize(i.to,x);
	return tmp;
}
void GetRoot(int x,int y,int sum){
	siz[x]=1;pos[x]=0; 
	for(auto i:v[x]){
		if(i.to==y||flag[i.to]) continue;
		GetRoot(i.to,x,sum);siz[x]+=siz[i.to];
		pos[x]=max(pos[x],siz[i.to]);
	}
	pos[x]=max(pos[x],sum-siz[x]);
	if(pos[x]<pos[rt]) rt=x;
}
void GetPoint(int x,int y,int d){
	p.emplace_back(x);
	for(auto i:v[x]) if(i.to!=y&&!flag[i.to]) GetPoint(i.to,x,d+i.val);
}
void Deal(int x){
	p.clear();GetPoint(x,0,0);
//	cout << x << ":\n";
//	for(auto i:p){cout << i << ' ' << dis[i] << "\n";}
	Tree2::Build(p,x);
}
void Solve(int x){
	pos[rt=0]=1e9;GetRoot(x,0,GetSize(x,0));
	Deal(rt);flag[rt]=1;
	for(auto i:v[rt]) if(!flag[i.to]) Solve(i.to);
}

inline int Kruskal(){
//	for(int i=1;i<=C;++i){
//		cout << b[i].x << ' ' << b[i].y << ' '<< b[i].z << "---------\n";
//	}
	sort(b+1,b+1+C);int ans=0;
	for(int i=1;i<=n;++i) fa[i]=i; 
	for(int i=1;i<=C;++i){ 
		int x=root(b[i].x),y=root(b[i].y);
//		cout<<" "<<b[i].x<<' '<<b[i].y<<' '<<b[i].z<<endl;
		if(x==y) continue;
		merge(x,y);ans+=b[i].z;
	}
	return ans;
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;for(int i=1,x,y,z;i<n;++i){cin>>x>>y>>z;add(x,y,z);}
	for(int i=1,x,y,z;i<n;++i){cin>>x>>y>>z;Tree2::add(x,y,z);}
	dfs1(1,0);dfs2(1,1);Tree2::init();Solve(1);cout<<Kruskal()<<'\n';return 0;
}
```

---

## 作者：hhhqx (赞：2)

**就让我站在巨人的肩膀上吧！**

[博客园](https://www.cnblogs.com/huangqixuan/p/18799468)

本文可能会有一些细节没讲到。

如果还有其他方法，欢迎在评论区补充。

---


## [luogu - P6199 [EER1] 河童重工](https://www.luogu.com.cn/problem/P6199)
> 给两棵树 $T1,T2$。$n$ 个节点的完全图，任意两点之间的边权为 $T1.dis(i,j) + T2.dis(i,j)$，求MST。

很显然这是 [[AT_cf17_final_j] Tree MST](https://www.luogu.com.cn/problem/AT_cf17_final_j) 的加强版。

### 法一
点分治套点分治。

直接得到可能用到的 $O(n \log^2 n)$ 条边（点分治，然后虚树，然后点分治），最后统一求一遍 MST。

复杂度 $O(n \log^2 n + n \log^2 n \log (n \log^2 n))$。

### 法二
点分治套 brovka。

直接得到可能用到的 $O(n \log n)$ 条边（点分治，然后虚树，然后 brovka），最后统一求一遍 MST。

复杂度 $O(n \log^2 n + n \log^2 n \ \alpha(n) + n \log n \log (n \log n))$

### 法二的进阶
对每个虚树都求 MST 还是太麻烦了，有没有更好的办法？有的兄弟，有的。（参考 https://www.luogu.com.cn/article/qu23uw2l ）

假设对 $T2$ 点分治，我们把两点距离算 $T2.dis(i,root) + T2.dis(j,root) + T1.dis(i,j)$，显然不影响最终答案。设 $w_i = T2.dis(i,root)$。设 $E$ 表示最终 MST 用到的边集。

对于一棵虚树，每个点 $i$，求 $w_j + T1.dis(i,j)$ 最小的 $j$，记作 $pre_i$，且记 $w_j + T1.dis(i,j)$ 为 $w'_i$（关于求 $j$，这是一个基础的 dijkstra 问题……堆初始 push 所有点即可）。

对于虚数上连接的两点 $u,v$，在 $E$ 中加入 $(pre_u,pre_v)$，边权为 $w'_u + w'_v + T1.dis(u,v)$。

对每个点 $u$，在 $E$ 中加入 $(u,pre_u)$，边权为 $w'_u + w_u$。

这样最后得到的是 $O(n \log n)$ 条边，统一求一遍 MST。

这为什么正确？证明：

- 考虑最后的答案，如果有一条边 $(x,y)$。一定存在一棵虚树，满足 $x$ 到 $y$ 路径上的 $pre$ 先全 $x$ 再全 $y$。
	- 因为如果其中存在一个 $z$，则 $(x,z)(z,y)$ 一定比 $(x,y)$ 更优。
	- 至于为什么先全 $x$ 再全 $y$，因为边权非负。
- 还发现，有可能全为 $x$ 或全为 $y$。（这句话是那篇题解里没有提到的，但是那篇题解还是可以通过的原因是他建了虚点）
- 那么我们这样加边，显然不会漏掉任何一条满足那个条件的边。

复杂度 $O(n \log^2 n + n \log^2 n + n \log n \log(n \log n))$。

### 法三
brovka 套点分治。（参考 https://www.luogu.com.cn/article/97gxfx4s ）

brovka 后，每一次，需要对每个 $i$ 求出 $T1.dis(i,j) + T2.dis(i,j)$ 最小且满足 $col_i \ne col_j$ 的 $j$。

假设对 $T1$ 用 brovka，每一层，对 $T1$ 点分治，求出当前子树在 $T2$ 中的虚树，树形 dp（额外记录次小值，满足最小值和次小值的 $col$ 不同）。

每一次的复杂度 $O(n \log^2 n \times 虚树的常数)$，再乘上 brokva 的 $\log n$ 直接爆炸。

可以把点分树和每一层的虚树建出来并保留，那么 brovka 的每一次，省去了建虚树的复杂度，那么 $O(n \log n)$。

最终复杂度 $O(n \log^2 n + n \log^2 n)$。
### Code
这里选择法二，个人感觉相比法三要好写一些，因为蒟蒻不太会存虚树，感觉存虚树有点麻烦……难评。

我写代码的时候出了几个问题：

- 我求虚树用的二次排序，相邻两点的 $lca$ 加入 `vector` 时点权为 $\inf$，这就导致有的点会有多钟值，这些值需要取最小值。
- 我需要比较两个 `pair<int, int>` 是否 `.first` 都相等，但是我直接判断两个 `pair<int, int>` 是否相等了（我在对 `vector` 去重时用到）。
- “还发现，有可能全为 $x$ 或全为 $y$” 这句话我当时没想到。

这题的样例还是太弱了，作为一个善良的人，赠送一组样例：

```
9
1 2 7
2 3 5
3 4 6
4 5 3
1 6 7
1 7 1
3 8 1
1 9 8
1 2 7
1 3 1
3 4 9
3 5 2
3 6 4
6 7 7
4 8 4
2 9 0

102
```

```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;
using PII = pair<int, int>;

const int MAXN = 1e5 + 3, MAXL = 18;

struct Edge{
  int u, v, w;
};

int n;

inline void Merge(vector<Edge> &x, vector<Edge> y){
  x.insert(x.end(), y.begin(), y.end());
}

namespace Tree1{
  int anc[MAXN][MAXL], dep[MAXN], ldep[MAXN], dfn[MAXN], depth = 0;
  vector<PII> EG[MAXN];
  void ADD(int U, int V, int W){
    EG[U].push_back({V, W}), EG[V].push_back({U, W});
  }
  void dfs(int x, int dad){
    anc[x][0] = dad, dfn[x] = ++depth;
    for(PII e : EG[x]){
      if(e.first == dad) continue;
      dep[e.first] = dep[x] + 1, ldep[e.first] = ldep[x] + e.second;
      dfs(e.first, x);
    }
  }
  void ply_m(){
    dep[1] = ldep[1] = 0, dfs(1, 0);
    for(int l = 1; l < MAXL; l++){
      for(int i = 1; i <= n; i++) anc[i][l] = anc[anc[i][l-1]][l-1];
    }
  }
  int LCA(int x, int y){
    if(dep[x] > dep[y]) swap(x, y);
    for(int k = dep[y] - dep[x], l = 0; l < MAXL; l++){
      if((k >> l) & 1) y = anc[y][l];
    }
    if(x == y) return x;
    for(int l = MAXL - 1; l >= 0; l--){
      if(anc[x][l] != anc[y][l]) x = anc[x][l], y = anc[y][l];
    }
    return anc[x][0];
  }
  
  int dp[MAXN], pre[MAXN];
  vector<PII> eg[MAXN];
  vector<Edge> Solve(vector<PII> S){
    vector<PII> vt;
    //cout << S.size() << " %%%%%%%%%%\n";
    //for(PII x : S) cout << x.first << " " << x.second << " $$$\n";
    sort(S.begin(), S.end(), [](PII x, PII y){ return dfn[x.first] < dfn[y.first]; });
    vt.push_back(S[0]);
    for(int i = 1; i < S.size(); i++){
      vt.push_back(S[i]), vt.push_back({LCA(S[i].first, S[i - 1].first), int(2e9)});
    }
    sort(vt.begin(), vt.end(), [](PII x, PII y){ return x.first == y.first ? x.second < y.second : dfn[x.first] < dfn[y.first]; });

    priority_queue<PII, vector<PII>, greater<PII>> pq;
    vector<PII> E, V;
    for(PII x : vt) eg[x.first].clear();
    pq.push({vt[0].second, vt[0].first}), dp[vt[0].first] = vt[0].second, pre[vt[0].first] = vt[0].first, V.push_back(vt[0]);
    for(int i = 1, la = vt[0].first; i < vt.size(); i++){
      if(vt[i].first != vt[i - 1].first){
        int x = vt[i].first, f = LCA(x, la);
        eg[f].push_back({x, ldep[x] - ldep[f]}), eg[x].push_back({f, ldep[x] - ldep[f]});
        pq.push({vt[i].second, x}), dp[x] = vt[i].second, pre[x] = x;
        E.push_back({x, f}), V.push_back(vt[i]);
        la = x;
      }
    }
    while(!pq.empty()){
      PII i = pq.top();
      pq.pop();
      swap(i.first, i.second);
      if(dp[i.first] < i.second) continue;
      for(PII e : eg[i.first]){
        int nx = e.first;
        LL nw = e.second + dp[i.first];
        if(dp[nx] > nw){
          dp[nx] = nw, pre[nx] = pre[i.first], pq.push({nw, nx});
        }
      }
    }
    vector<Edge> ret;
    for(PII e : E){
      //cout << e.first << " " << pre[e.first] << " " <<e.second << " " << pre[e.second ] << "\n";
      if(pre[e.first] != pre[e.second]){
        ret.push_back({pre[e.first], pre[e.second], dp[e.first] + dp[e.second] + abs(ldep[e.first] - ldep[e.second])});
      }
    }
    for(PII x : V){
      if(pre[x.first] != x.first && dp[x.first] < int(2e9) && x.second < int(2e9)){
        ret.push_back({pre[x.first], x.first, dp[x.first] + x.second});
      }
    }
    //cout << ret.size() << "\n";
    return ret;
  }
}

namespace Tree2{
  vector<Edge> ret;
  int vis[MAXN], Size, root, sz[MAXN], mx[MAXN];
  vector<PII> eg[MAXN];
  
  void ADD(int U, int V, int W){
    eg[U].push_back({V, W}), eg[V].push_back({U, W});
  }

  void Get_root(int x, int dad){
    sz[x] = 1, mx[x] = 0;
    for(PII e: eg[x]){ int nxt = e.first;
      if(vis[nxt] || nxt == dad) continue;
      Get_root(nxt, x), sz[x] += sz[nxt], mx[x] = max(mx[x], sz[nxt]);
    }
    mx[x] = max(mx[x], Size - sz[x]);
    if(root == 0 || mx[root] > mx[x]) root = x;
  }
  vector<PII> S;
  void dfs(int x, int dad, int ldep){
    S.push_back({x, ldep});
    for(PII e : eg[x]){ int nxt = e.first;
      if(vis[nxt] || nxt == dad) continue;
      dfs(nxt, x, ldep + e.second);
    }
  }
  void Solve(int x){
    vis[x] = 1; 
    S.clear(), dfs(x, 0, 0), Merge(ret, Tree1::Solve(S));
    for(PII e : eg[x]){ int nxt = e.first;
      if(vis[nxt]) continue;
      Size = sz[nxt], root = 0, Get_root(nxt, x), Solve(root);
    }
  }
}

int fa[MAXN];
int Getf(int x){ return fa[x] == x ? x : fa[x] = Getf(fa[x]); }

int main(){
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for(int i = 1, U, V, W; i < n; i++){
    cin >> U >> V >> W, Tree1::ADD(U, V, W);
  }
  for(int i = 1, U, V, W; i < n; i++){
    cin >> U >> V >> W, Tree2::ADD(U, V, W);
  }
  Tree1::ply_m();
  Tree2::Size = n, Tree2::root = 0, Tree2::Get_root(1, 0), Tree2::Solve(Tree2::root);
  vector<Edge> E = Tree2::ret;
  sort(E.begin(), E.end(), [](Edge i, Edge j){ return i.w < j.w; });
  for(int i = 1; i <= n; i++) fa[i] = i;
  LL ans = 0;
  for(Edge e : E){
    //cout << e.u << " " << e.v << " " << e.w << " ^\n";
    int fx = Getf(e.u), fy = Getf(e.v);
    if(fx != fy){
      fa[fx] = fy, ans += e.w;
    }
  }
  cout << ans;
  return 0;
}
/*
9
1 2 7
2 3 5
3 4 6
4 5 3
1 6 7
1 7 1
3 8 1
1 9 8
1 2 7
1 3 1
3 4 9
3 5 2
3 6 4
6 7 7
4 8 4
2 9 0

102

*/
```

---

## 作者：Luciylove (赞：1)

# Preface

P6199 [EER1] 河童重工

[Tree MST](https://www.luogu.com.cn/problem/AT_cf17_final_j) 的我不会 Boruvka，所以这个题我也不会 Boruvka ！

# Solution

因为是树上链上信息，所以需要先来一个静态链分治。

注意到这里并非单元的路径信息 dsu on tree 好像不太好做，所以我们用点分治。

考虑两颗树都没啥区别，所以我们先对 $T_1$ 点分治，然后可以把第一颗树上的距离给化为点权。然后就可以按照上面链接那个题的方法做了。

注意到 $T_1$ 点分中的树上邻域信息在 $T_2$ 中并不相邻了，所以需要使用虚树提出来这个邻域。

按照上面那个题的方法：

我们对虚树点分治，每次取出分治邻域信息中新的点权最小的点和所有点连边即可。

于是我们用点分套点分解决了找出所有优秀的边的问题。由于点分树大小是 $O(n \log n)$ 的，然后内层的点分每个点会带来 $O(\log n)$ 个数的点对，算上虚树复杂度，所以边数和时间复杂度都是 $O(n \log^2 n)$ 的。

最后我们需要对这 $O(n \log^2n)$ 条边排序，并做 kruskal，进行精细的实现后可以做到 $O(n \log^2 n + n \log^2 n\alpha(n))$。

笔者选择朴素的实现，还是在二分之一时限下毫无压力地通过了。


```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = l; i <= r; i ++)
#define per(i, r, l) for (int i = r; i >= l; i --)

using namespace std;

typedef long long ll;
const int _ = 1e5 + 5, inf = 0x3f3f3f3f;
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * f;
}

int n;
struct Info {
	int x, y, w;
	bool operator < (const Info &x) const {
		return w < x.w;
	}
} ;
vector <Info> Edges;

struct DSU {
	int fa[_];
	void init (int n) { rep(i, 1, n) fa[i] = i; }
	int find (int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
	void merge (int x, int y) { fa[find(x)] = find(y); }
} dsu;

namespace T2 {
	vector <pair<int, int> > e[_];
	vector <pair<int, int> > T[_];
	
	int dfc;
	int d[_], dfn[_], dep[_], pa[_][20];
	int val[_];
	
	void add (int x, int y, int w) {
		e[x].push_back({y, w}), e[y].push_back({x, w});
	}
	void addT (int x, int y, int w) {
 		T[x].push_back({y, w}), T[y].push_back({x, w});
	}
	
	void dfs1 (int x, int fa) {
		pa[x][0] = fa, dep[x] = dep[fa] + 1, dfn[x] = ++ dfc;
		rep(i, 1, 19)
			pa[x][i] = pa[pa[x][i - 1]][i - 1];		
		for (auto [y, w] : e[x]) {
			if (y == fa) continue ;
			d[y] = d[x] + w;
			dfs1(y, x);
		}
	}
	int LCA (int x, int y) {
		if (dep[x] < dep[y]) 
			swap(x, y);
		int d = dep[x] - dep[y];
		rep(i, 0, 19)
			if (d & (1 << i)) x = pa[x][i];
		if (x == y) return x;
		per(i, 19, 0)
			if (pa[x][i] != pa[y][i])
				x = pa[x][i], y = pa[y][i];
		return pa[x][0];
	}
	vector <int> V;

	void buildVT (vector <int> node) {
		V = node;
		sort(node.begin(), node.end(), [](int x, int y) { return dfn[x] < dfn[y]; });
		V.push_back(1);
	
		for (int i = 1; i < node.size(); i ++) 
			V.push_back(LCA(node[i], node[i - 1]));
		
		set <int> s(V.begin(), V.end());
		V.assign(s.begin(), s.end());
		sort(V.begin(), V.end(), [](int x, int y) { return dfn[x] < dfn[y]; } );
		
		for (int i = 1; i < V.size(); i ++) {
			int lc = LCA(V[i], V[i - 1]);
			if (lc)
				addT(lc, V[i], d[V[i]] - d[lc]);
		}
	}
	
	int sz[_], vis[_], dis[_];
	int all, root = 0, mx = inf;
	
	void rec (int x, int fa, bool flag) {
		all ++;
		for (auto [y, w] : T[x]) if (y ^ fa) rec(y, x, flag);
		if (flag) 
			vis[x] = 0, T[x].clear();
	}
	void findroot (int x, int fa) {
		sz[x] = 1;
		int mxs = 0;
		for (auto [y, w] : T[x]) {
			if (vis[y] || y == fa)
				continue ;
			findroot(y, x);
			sz[x] += sz[y], mxs = max(mxs, sz[y]);
		}
		mxs = max(all - sz[x], mxs);
		if (mx > mxs)
			mx = mxs, root = x; 
	}
	
	vector <int> Sub;
	void getdist (int x, int fa) {
		Sub.push_back(x);
		for (auto [y, w] : T[x]) {
			if (y == fa || vis[y]) 
				continue ;
			dis[y] = dis[x] + w;
			getdist(y, x);
			
		}
	}
	void proc (int x) {
		vis[x] = 1;
		Sub.clear();
		dis[x] = 0;
		getdist(x, 0);
		
		int p = 0, vl = inf;
		for (int y : Sub) 
			if (dis[y] + val[y] < vl)
				vl = dis[y] + val[y], p = y;
		
		for (int y : Sub) 
			if (y ^ p && val[y] != inf) Edges.push_back({p, y, vl + dis[y] + val[y]});
		for (auto [y, w] : T[x]) {
			if (vis[y]) continue ;
			all = sz[y], mx = inf;
			findroot(y, x);
			proc(root);
		}
	}
	void work (vector <int> node) {
		buildVT(node);
		rec(1, 0, 0), mx = inf, 
		findroot(1, 0),
		proc(root),
		rec(1, 0, 1), all = 0;
	}

}

namespace T1 {
	int all, root = 0, mx = inf;
	bool vis[_];
	int sz[_], dis[_];
	vector <pair<int, int> > e[_];
	vector <int> node;
	
	void add (int x, int y, int w) { e[x].push_back({y, w}), e[y].push_back({x, w}); }
	void findroot (int x, int fa) {
		int mxs = 0;
		sz[x] = 1;
		for (auto [y, w] : e[x]) {
			if (y == fa || vis[y])
				continue ;
			findroot(y, x);
			sz[x] += sz[y], mxs = max(mxs, sz[y]);
		}
		mxs = max(all - sz[x], mxs);
		if (mx > mxs)
			mx = mxs, root = x; 
	}
	void getdist (int x, int fa) {
		node.push_back(x);
		for (auto [y, w] : e[x]) {
			if (y == fa || vis[y])
				continue ;
			dis[y] = dis[x] + w;
			getdist(y, x);
		}
	}
	void proc (int x) {
		vis[x] = 1, node.clear();
		dis[x] = 0;
		getdist(x, 0);
		
		for (int y : node) T2::val[y] = dis[y];
		T2::work(node);
		for (int y : node) T2::val[y] = inf;
		for (auto [y, w] : e[x]) {
			if (vis[y]) continue ;
			all = sz[y], mx = inf;
			findroot(y, x);
			proc(root);
		}
	}
	void work () {
		all = n;
		findroot(1, 0);
		proc(root);
	}
}

int main () {
	// freopen(".in", "r", stdin);
	// freopen(".out", "w", stdout);
	
	n = read();
	rep(i, 1, n - 1) {
		int x = read(), y = read(), w = read();
		T1 :: add(x, y, w);
	}
	rep(i, 1, n - 1) {
		int x = read(), y = read(), w = read();
		T2 :: add(x, y, w);
	}
	T2 :: dfs1(1, 0);
	T1 :: work();
	dsu.init(n);
	ll ret = 0;
	sort(Edges.begin(), Edges.end());
	for (auto [x, y, w] : Edges) 
		if (dsu.find(x) != dsu.find(y))
			ret += w, dsu.merge(x, y);
	printf("%lld\n", ret);
	return 0;
}
```

---

## 作者：stoorz (赞：1)

先在 T1 中求出所有点到 $1$ 的距离 $\mathrm{dep1}_x$。用 ST 表预处理出 T1 的 LCA。

把 T2 点分治。求出每一个点到分治根的路径长度 $\mathrm{dep2}_x$。考虑经过当前根节点的路径。

把当前 T2 点分治到的子树的点在 T1 中建立虚树。然后对于 T2 点分治到的点 $x$，我们在虚树中给它拆出一个点 $x'$，从 $x'$ 向 $x$ 连一条长度为 $\mathrm{dep2}_x$ 的边。然后对于虚树上的一条边 $(x,y)$，连一条长度为 T1 中 $x,y$ 距离的边。事实上由于虚树中的相邻的点在 T1 中一定是祖孙关系，所以直接 $\mathrm{dep1}$ 减一下即可。

然后我们从所有拆出来的点 $x'$ 跑最短路，求出虚树上所有点到达最近的 $x'$ 的距离 $\mathrm{dis}$ 和最近的 $x'$ 的编号 $\mathrm{pre}$。接下来枚举虚树上的每一条边 $(x,y)$，向边集 $E$ 中扔一条连接 $\mathrm{pre}_x,\mathrm{pre}_y$，长度为 $\mathrm{dis_x}+\mathrm{dis_y}+d_{x,y}$，其中 $d_{x,y}$ 就是虚树中 $x,y$ 边的长度（也就是 T1 中 $x,y$ 的距离）。

显然我们扔进 $E$ 的边的长度一定不小于实际长度（也就是我们计算的两个点的距离不小于实际上它们在 T1 的距离加上 T2 的距离）。所以我们只需要证明所有最终在最小生成树上的边一定在 $E$ 中且长度一定等于实际长度即可。

考虑最终被连边的两个点 $x,y$，它们一定会同时在某一棵虚树中，且虚树上它们之间路径的 $\mathrm{pre}$ 一定是一段前缀为 $x$，另一段后缀为 $y$，否则假设其路径中有一个点的 $\mathrm{pre}$ 为点 $z$，显然最终的生成树中 $(x,y)$ 没有 $(x,z),(z,y)$ 优。

而且不难发现当分治到的根为 T2 中 $x$ 到 $y$ 的路径时，我们扔进 $E$ 的路径 $(x,y)$ 长度就是正确的。

由于一个大小为 $k$ 的点分树，我们扔进 $E$ 的边数是 $O(k)$ 的，所以最终 $E$ 中的边的数量就会是 $O(n\log n)$ 的，跑 Kruskal 即可。
时间复杂度 $O(n\log^2 n)$。

由于代码有一定长度，请到云剪切板查看：https://www.luogu.com.cn/paste/pawpljpq

---

## 作者：xuyiyang (赞：0)

### [P6199 [EER1] 河童重工](https://www.luogu.com.cn/problem/P6199)
完全的 dirty work。值得口胡，不值得写。$\\$
首先这题有个弱化版是 [Tree MST](https://www.luogu.com.cn/problem/AT_cf17_final_j)。这个是一棵树的情况。注意到对于若干个边集并为全集的子图，它们的 MST 再做一遍 MST 就是原树的 MST。所以对于树 $T$ 点分治，然后把距离拆开，就是一个简单的点权 MST，直接取最小点连菊花图即可。于是 $\mathcal O(n \log n)$ 可以解决一棵树的问题。$\\$
现在考虑原问题。首先在 $T_1$ 上做点分治，设重心为 $R$，那么 $\operatorname{dist}(T_1,i,j)$ 就简化掉了。所以现在只需对 $R$ 所在的点集做 MST。那么就用下 Tree MST 的做法在 $T_2$ 的虚树上套一层点分治就做完了。$\mathcal O(n \log ^ 2 n)$。

---

## 作者：lupengheyyds (赞：0)

先给出一个弱化版：**[Tree MST](https://www.luogu.com.cn/problem/AT_cf17_final_j "Tree MST")**

完全图 MST 问题，有两种做法。

**算法一**

考虑一个结论：

> 设边集 $E$ 的 MST 为 $T(E)$，有 $T(\bigcup\limits_iT(E_i))=T(\bigcup\limits_iE_i)$。

原问题不好直接处理是因为 $lca$ 不确定，于是考虑点分治。设中心为 $G$，考虑树上所有穿过 $G$ 的路径，对应在完全图的边集产生的边。他们两两的边权为 $a_x+dep_x+a_y+dep_y$，很明显只需要找到 $\min\{a_x+dep_x\}$，然后从 $x$ 向其他点连边，就可以找到 MST。这些边数之和为  $n\log n$，最后再求一次 kruskal 即可。即使在同一子树也无妨，因为贡献更劣，没有影响。复杂度 $T:\mathcal O(n\log^2n)M:\mathcal O(n\log n)$。

**算法二**

直接考虑 boruvka 算法。每轮更新对于每个点 $x$ 找到 $\min_{c_i\ne c_x}(a_i+d(i,x))$。使用换根 dp 可解决。颜色不同就求一个最大值和不同颜色的次大值。复杂度 $T:\mathcal O(n\log n)M:\mathcal O(n)$。

**[P6199 [EER1] 河童重工](https://www.luogu.com.cn/problem/P6199)**

> 这种多树问题直接把其他树点分治掉，最后剩下一棵树。

直接把其中一棵树点分治掉，在另一颗树上建虚树即可。上述两个算法都可用，但时间多一个 $\log$。

```cpp
#include<bits/stdc++.h>
#define io ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
#define int long long
#define loop(i,a,b) for(int i=a;i<=b;i++)
#define pool(i,a,b) for(int i=a;i>=b;i--)
#define mset(a,v) memset(a,v,sizeof a)
#define mcpy(a,b) memcpy(a,b,sizeof b)
#define umap unordered_map
#define pb push_back
#define pc(x) __builtin_popcountll(x)
#define fi first
#define se second
using namespace std;
typedef unsigned long long ull;
typedef pair<int,int> pa;
typedef vector<int> vi;
//#define DEBUG 
#ifndef DEBUG
#define cerr none
ofstream none("nul");
#endif
const int NN=1e5+5,INF=0x3f3f3f3f3f3f3f3f;
int n;
struct Edge{//存储最后Kruskal的边 
	int u,v,w;
	bool operator<(const Edge&b)const{
		return w<b.w;
	}
};
vector<Edge> edge;
struct Tree1{
	vector<pa> ed[NN];
	vi ved[NN];
	int c[NN],to[NN],eval[NN];
	bool key[NN];
	int b[NN],dip[NN],dfn[NN],top[NN],dep[NN],siz[NN],hvy[NN],fa[NN],num,from[NN];
	vi v;
	int Find(int x){
		if(x==c[x])return x;
		return c[x]=Find(c[x]);
	}
	struct DP{
		pa mn,mn2; 
		DP(pa _mn={INF,0},pa _mn2={INF,0}){
			mn=_mn,mn2=_mn2;
		}
		DP Add(int v){
			DP res=*this;
			res.mn.fi+=v,res.mn2.fi+=v;
			return res;
		}
	}f[NN],g[NN];
	DP Update(DP a,DP b){
		auto Upd=[&](pa&a,pa b){a=min(a,b);};
		DP res;
		if(a.mn.fi<b.mn.fi){
			res.mn=a.mn;
			if(Find(a.mn2.se)!=Find(res.mn.se))Upd(res.mn2,a.mn2);//不是同一个颜色，可以作为次大值 
			if(Find(b.mn.se)!=Find(res.mn.se))Upd(res.mn2,b.mn);
			if(Find(b.mn2.se)!=Find(res.mn.se))Upd(res.mn2,b.mn2);
		}else{
			res.mn=b.mn;
			if(Find(a.mn2.se)!=Find(res.mn.se))Upd(res.mn2,a.mn2);//不是同一个颜色，可以作为次大值 
			if(Find(a.mn.se)!=Find(res.mn.se))Upd(res.mn2,a.mn);
			if(Find(b.mn2.se)!=Find(res.mn.se))Upd(res.mn2,b.mn2);
		}
		return res;		
	}
	int LCA(int a,int b){
		while(top[a]!=top[b]){
			if(dep[top[a]]<dep[top[b]])swap(a,b);
			a=fa[top[a]];
		}
		return dep[a]<dep[b]?a:b;
	}
	int VirtualTree(vi v){//需要传参，因为会改 
		v.pb(1);//把1放进去 
		sort(v.begin(),v.end(),[&](int x,int y){return dfn[x]<dfn[y];});
		vi tmp=v;
		loop(i,0,(int)tmp.size()-2)v.pb(LCA(tmp[i],tmp[i+1]));
		sort(v.begin(),v.end(),[&](int x,int y){return dfn[x]<dfn[y];});
		v.erase(unique(v.begin(),v.end()),v.end());
		for(int o:v)ved[o].clear();
		loop(i,1,(int)v.size()-1)ved[LCA(v[i],v[i-1])].pb(v[i]);
		return 1; 
	}
	void Clear(){
		for(int o:v){
			f[o]=g[o]=DP();
		}
		return;
	}
	void DP_F(int x){//f:子树内
		f[x]=DP();
		if(key[x])f[x].mn={b[x],x};
		for(int y:ved[x]){
			DP_F(y);
			f[x]=Update(f[x],f[y].Add(dip[y]-dip[x]));
		}
		return; 
	}
	void DP_G(int x){//g:全局答案，因为先进来再出去不优，所以可以简单更新 
		for(int y:ved[x]){
			g[y]=Update(g[x].Add(dip[y]-dip[x]),f[y]);
			DP_G(y);
		}
		return;
	}
	void Calc(){
		auto Upd=[&](int o,pa p){eval[o]=p.fi,to[o]=p.se;};
		for(int o:v){
			from[o]=o;
			if(Find(g[o].mn.se)!=Find(o))Upd(o,g[o].mn);
			else				   Upd(o,g[o].mn2);
			eval[o]+=b[o];
		}
		return;
	} 
	void Deal(vector<pa> pack){
		v.clear();
		for(pa o:pack)v.pb(o.fi),b[o.fi]=o.se;//解包
		for(int o:v) key[o]=1;
		int root=VirtualTree(v);//给_v的节点建虚树,并存在ved中，返回根节点
		int cnt=0;
		for(int o:v)c[o]=o,cnt++;//用并查集维护颜色， 
		while(cnt>1){
			Clear();
			DP_F(root);
			g[root]=f[root],DP_G(root);
			Calc();//计算eval,to
			//处理完后一个点应当存储最短边的另外一个点，存在to[]中，其边权存储在 eval中 注意加了b[x] 
			for(int o:v){
				int tp=Find(o),tq=Find(to[o]);
				if(tp==tq)continue;
				if(eval[o]<eval[tp])eval[tp]=eval[o],to[tp]=to[o],from[tp]=from[o];
			}
			for(int o:v)if(Find(o)==o){
				edge.pb({from[o],to[o],eval[o]});
				c[o]=Find(to[o]);
			}
			cnt=0;
			for(int o:v)if(Find(o)==o)cnt++;
		}
		//清空key
		for(int o:v) key[o]=0;
		return;
	}
	void DFS(int x){//一开始需要先dfs一遍求出dfn与dip 
		dfn[x]=++num;
		siz[x]=1;
		for(pa eg:ed[x]){
			int y=eg.fi,val=eg.se;
			if(y==fa[x])continue;
			dip[y]=dip[x]+val;
			dep[y]=dep[x]+1;
			fa[y]=x;
			DFS(y);
			siz[x]+=siz[y];
			if(siz[y]>siz[hvy[x]])hvy[x]=y;
		}
		return;
	}
	void Trlk(int x,int topx){//树剖求LCA 
		top[x]=topx;
		if(!hvy[x])return;
		Trlk(hvy[x],topx);
		for(pa eg:ed[x]){
			int y=eg.fi;
			if(y==fa[x]||y==hvy[x])continue;
			Trlk(y,y);
		}
		return;
	}
}T1;
struct Tree2{
	vector<pa> ed[NN];
	int siz[NN],ans[NN],allsiz,MX,ctd;
	bool vst[NN];
	vi v;
	void DFS(int x,int fa){
		siz[x]=1;
		int mx=0;
		for(pa eg:ed[x]){
			int y=eg.first;
			if(vst[y]||y==fa)continue;
			DFS(y,x);
			siz[x]+=siz[y];
			mx=max(mx,siz[y]);
		}
		mx=max(mx,allsiz-siz[x]);
		if(mx<MX)ctd=x,MX=mx;
		return;
	}
	int CTD(int x){
		MX=INF,allsiz=siz[x],ctd=0,DFS(x,x);
		return ctd;
	}
	int b[NN],d[NN],cnt[NN];
	void DFS2(int x,int fa,int from,int dip){
		d[x]=from,b[x]=dip;
		v.pb(x);
		for(pa eg:ed[x]){
			int y=eg.fi,val=eg.se;
			if(y==fa||vst[y])continue;
			DFS2(y,x,from,dip+val);
		}
		return;
	}
	void CD(int x){
		vst[x]=1;
		v.clear();
		d[x]=x,b[x]=0;
		v.pb(x);
		for(pa eg:ed[x]){
			int y=eg.fi,val=eg.se;
			if(!vst[y])DFS2(y,x,y,val);
		}
		vector<pa> pack;
		for(int o:v)pack.pb({o,b[o]});//打包 
		T1.Deal(pack);//传了一个点集，一个点权 
		for(pa eg:ed[x]){
			int y=eg.first;
			if(vst[y])continue;
			CD(CTD(y));
		}
		return;
	}
	void Work(){//把第二棵树点分治了
		siz[1]=n;CD(CTD(1));
		return;
	}
}T2;
int fa[NN];
int Find(int x){
	if(x==fa[x])return x;
	return fa[x]=Find(fa[x]);
}
int ans=0;
void Kruskal(){
	sort(edge.begin(),edge.end());
	loop(i,1,n)fa[i]=i;
	for(Edge o:edge){
		int u=o.u,v=o.v,w=o.w;
		int tu=Find(u),tv=Find(v);
		if(tu==tv)continue;
		fa[tu]=tv;
		ans+=w;
	}
	return;
}
signed main(){
	io;cin>>n;
	loop(i,1,n-1){
		int u,v,w;cin>>u>>v>>w;
		T1.ed[u].pb({v,w});
		T1.ed[v].pb({u,w});
	}
	T1.DFS(1);T1.Trlk(1,1);
	loop(i,1,n-1){
		int u,v,w;cin>>u>>v>>w;
		T2.ed[u].pb({v,w});
		T2.ed[v].pb({u,w});
	}
	T2.Work();
	//得到了可能的边集，跑Kruskal即可 
	Kruskal(); 
	cout<<ans;
	return 0;
}
```

---

## 作者：BYR_KKK (赞：0)

完全图最小生成树，考虑 Boruvka。

先来考虑一个弱化弱化版，只有一棵树，边权为 $a_x+a_y+dis(x,y)$ 应该怎么做，每轮做树形 dp，维护子树内最大值和颜色不同的次大值，时间复杂度 $O(n\log n)$。

再来考虑一个弱化版，第二棵树是菊花应该怎么做，显然这个问题和上面那个等价，菊花图上任意两个点之间的距离就是两个点到根的距离之和，时间复杂度 $O(n\log n)$。

回到这个问题，我们想转化到弱化版的问题，即距离可以写成两个数的和的形式，不难想到点分治，对第二棵树点分治，这样每对点之间的距离就能写成 $a_x+a_y$ 的形式，然后做弱化弱化版的树形 dp 即可。注意此处的限制是要求两个点在之前的 Boruvka 中不在同一个连通块内，同时点分治不在不同一个子树中，看上去 dp 的时候要记的状态比较多，不过没有必要记是否在同一个子树中，这样显然不会最优。

这样的复杂度还是不对，我们每次点分治都要对第一棵树做 $O(n)$ 的树形 dp，很糟糕，点分治这一算法能优化复杂度的主要地方在于点的总数是 $O(n\log n)$ 的，启发我们建出虚树，然后在虚树上 dp。时间复杂度 $O(n\log^3 n)$，三个 $\log$ 分别来自 Boruvka、点分治、建虚树。

可以发现每轮 Boruvka 虚树形态是固定的，因此可以提前建好虚树，时间复杂度为 $O(n\log^2 n)$。

---

## 作者：takanashi_mifuru (赞：0)

愤怒！！！

完全图求其 MST 自然是使用 B 算法了，这样我们就只需要求出对于每个点来说距离他最近的与他不在同一个联通块内的点到他的距离。

我们在第一棵树上点分治再把控制的联通块丢进第二棵树内作虚树（因为对于同一个联通块其虚树是固定的所以可以预处理），虚树总大小是 $O(n\log n)$ 的，现在变成了每个点有一个权值 $val_i$（即为前面点分治的时候留下到分治中心的距离，如果他们的 lca 不是分治中心也没关系，因为这样求出来的值肯定不如他们用 lca 取出来的值），然后在树上求每个点到别的点的路径边权和与其权值之和最小值。

这个东西可以直接换根 dp 来求。

然后就做完了，时间复杂度 $O(n\log^2 n)$，真是太好写了。

时限其实是很足够的，但是 B 算法如果一个没写好（比如说为了卡常注释 `#define int long long` 导致最后爆 int ），就会死循环，调之前记得自己造几组判下死循环，别浪费一个上午卡常。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#define ll long long
#define rep(i, f, t) for (int i = (f), ed##i = (t); i <= ed##i; ++i)
#define re(i, t) rep (i, 1, t)
#define per(i, t, f) for (int i = (t), ed##i = (f); i >= ed##i; --i)
#define ste(i, f, t, s) for (int i = (f), ed##i = (t); i <= ed##i; i += s)
#define each(i, x) for (auto& i : (x))
#define nxt(i, f, g) for (int i = g.h[f]; i; i = g.e[i].n)
#define dbg(x) (cerr << "(dbg) " << #x " = " << (x) << '\n')
#define umod(x) ((x) >= mo && ((x) -= mo))
#define dmod(x) ((x) < 0 && ((x) += mo))
#define up(x, y) (((x) < (y)) && ((x) = (y)))
#define down(x, y) (((x) > (y)) && ((x) = (y)))
#define y1 y1__
namespace FastIO {
    const int SZ=(1<<23)+1;
    struct I {
        char ibuf[SZ],*iS,*iT,c;int f,_eof;FILE*fi;
        I(FILE*f):fi(f){}
        inline char Gc(){return iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,SZ,fi),(iS==iT?EOF:*iS++)):*iS++;}
        inline ll operator()(){ll x;operator()(x);return x;}
        inline I&operator()(char&x){x=Gc();return*this;}
        inline I&operator()(char*s){for(c=Gc();c<32||c>126||c==' ';)c=Gc();for(;c>31&&c<127&&c!=' '&&c!='\n'&&c!='\r';++s,c=Gc())*s=c;*s=0;return*this;}
        template<class T>inline I&operator()(T&x){_eof=0;for(f=1,c=Gc();(c<'0'||c>'9')&&!_eof;c=Gc()){if(c=='-')f=-1;_eof|=c==EOF;}for(x=0;c<='9'&&c>='0'&&!_eof;c=Gc())x=x*10+(c&15),_eof|=c==EOF;x*=f;return*this;}
        template<class T>I&operator()(T*x,const int&n,const int&st=1){rep(i,st,n){operator()(x[i]);}return*this;}
    } in(stdin);
    struct O {
        char obuf[SZ],*oS=obuf,*oT=oS+SZ-1,qu[55];int f,qr;FILE*fi;
        O(FILE*f):fi(f){}
        ~O(){Flush();}
        inline void Flush(){fwrite(obuf,1,oS-obuf,fi),oS=obuf;}
        inline O&operator()(char x){*oS++=x;if(oS==oT)Flush();return*this;}
        inline O&operator()(const char*s){int len=strlen(s);for(f=0;f<len;++f)operator()(s[f]);return*this;}
        template<class T>inline O&operator()(T x){if(!x)operator()('0');if(x<0)operator()('-'),x=-x;while(x)qu[++qr]=x%10+'0',x/=10;while(qr)operator()(qu[qr--]);return*this;}
        template<class T>O&operator()(T*x,const int&n,const char&ed=' ',const int&st=1){rep(i,st,n)operator()(x[i])(ed);return*this;}
    } out(stdout);
}
using FastIO::in;using FastIO::out;
#define int long long
using namespace std;
int n;
struct node{
    int v,w;
};
vector<node> G[100005],H[100005];
struct edge{
    int u,v,w;
};
int rnk[100005];
const int inf=1e16;
pair<int,int> Min[100005];//
pair<int,int> GMin[100005];//
vector<node> ljb[100005];
int val[100005];//
int col[100005];
struct dp{
    pair<int,int> Min,MMin;
    dp operator + (const dp &b)const{//要求最大和次大不能是同一个颜色块，在此基础上求其最大值，实际上就是前后缀向下换根
        dp tmp;
        tmp.Min=min(Min,b.Min);
        tmp.MMin=make_pair(inf,-1);
        if(tmp.Min.second!=Min.second)tmp.MMin=min(tmp.MMin,Min);
        if(tmp.Min.second!=MMin.second)tmp.MMin=min(tmp.MMin,MMin);
        if(tmp.Min.second!=b.Min.second)tmp.MMin=min(tmp.MMin,b.Min);
        if(tmp.Min.second!=b.MMin.second)tmp.MMin=min(tmp.MMin,b.MMin);
        return tmp;
    }
}f[100005];
int find(int x){return col[x]==x?x:col[x]=find(col[x]);}//
class VTree{
    public:
    vector<int> D;
    void getf(int cur,int fa){//
        f[cur]=dp{make_pair(inf,-1),make_pair(inf,-1)};
        for(int i=0;i<ljb[cur].size();i++){
            int v=ljb[cur][i].v;
            int w=ljb[cur][i].w;
            if(v==fa)continue;
            getf(v,cur);
            dp tmp=f[v];
            tmp.Min.first+=w;
            tmp.MMin.first+=w;
            dp fv=dp{make_pair(w+val[v],col[v]),make_pair(inf,-1)};
            f[cur]=f[cur]+tmp+fv;
        }
        return;
    }
    vector<dp> pre[100005];
    vector<dp> suf[100005];
    void getMin(int cur,int fa,dp need){
        pre[cur].resize(ljb[cur].size());
        suf[cur].resize(ljb[cur].size());
        for(int i=0;i<ljb[cur].size();i++){//
            int v=ljb[cur][i].v;
            int w=ljb[cur][i].w;
            pre[cur][i]=(dp{make_pair(inf,-1),make_pair(inf,-1)});
            suf[cur][i]=(dp{make_pair(inf,-1),make_pair(inf,-1)});
            if(v==fa)continue;
            dp tmp=f[v];
            tmp.Min.first+=w;
            tmp.MMin.first+=w;
            dp fv=dp{make_pair(w+val[v],col[v]),make_pair(inf,-1)};
            pre[cur][i]=tmp+fv;
            suf[cur][i]=tmp+fv;
        }
        for(int i=1;i<ljb[cur].size();i++){
            int v=ljb[cur][i].v;
            pre[cur][i]=pre[cur][i]+pre[cur][i-1];//
            if(v==fa)continue;
        }
        for(int i=ljb[cur].size()-2;i>=0;i--){
            int v=ljb[cur][i].v;
            suf[cur][i]=suf[cur][i]+suf[cur][i+1];
            if(v==fa)continue;
        }
        dp neta=need+pre[cur][pre[cur].size()-1];
        if(neta.Min.second!=col[cur]){
            Min[cur]=neta.Min;
        }
        else{
            Min[cur]=neta.MMin;
        }
        for(int i=0;i<ljb[cur].size();i++){
            int v=ljb[cur][i].v;
            int w=ljb[cur][i].w;
            if(v==fa)continue;
            dp tmp=need;
            if(i)tmp=tmp+pre[cur][i-1];
            if(i+1<ljb[cur].size())tmp=tmp+suf[cur][i+1];
            tmp.Min.first+=w;
            tmp.MMin.first+=w;
            dp fu=dp{make_pair(val[cur]+w,col[cur]),make_pair(inf,-1)};
            getMin(v,cur,tmp+fu);
        }
        return;
    }
    void solve(){
        bool flag=false;
        for(int i=0;i<D.size();i++){
            int now=D[i];
            col[now]=find(now);
            if(i&&(col[now]!=col[D[i-1]])){
                flag=true;
            }
        }
        if(!flag)return;
        getf(D[0],0);
        getMin(D[0],0,dp{make_pair(inf,-1),make_pair(inf,-1)});
        for(int i=0;i<D.size();i++){
            GMin[find(D[i])]=min(GMin[find(D[i])],make_pair(Min[D[i]].first+val[D[i]],Min[D[i]].second));
        }
        return;
    }
    void build(vector<int> &DD,vector<edge> &EE){
        D=DD;//
        for(int i=0;i<DD.size();i++)ljb[DD[i]].clear();
        for(int i=0;i<EE.size();i++){
            int u=EE[i].u;
            int v=EE[i].v;
            int w=EE[i].w;//
            ljb[u].push_back(node{v,w});
            ljb[v].push_back(node{u,w});
        }
        return;//
    }
}T;
int heavy[100005];
int siz[100005];
int top[100005];
int dfn[100005];
int dep[100005];
int father[100005];
int dis[100005];
int tot;
void getsiz(int cur,int fa){
    dep[cur]=dep[fa]+1;
    father[cur]=fa;
    siz[cur]=1,heavy[cur]=0;
    for(int i=0;i<G[cur].size();i++){
        int v=G[cur][i].v;
        int w=G[cur][i].w;
        if(v==fa)continue;
        dis[v]=dis[cur]+w;
        getsiz(v,cur);
        siz[cur]+=siz[v];
        if(siz[v]>siz[heavy[cur]]){
            heavy[cur]=v;
        }
    }
    return;
}
void getdfn(int cur,int fa){
    dfn[cur]=++tot;
    if(heavy[cur]){
        top[heavy[cur]]=top[cur];
        getdfn(heavy[cur],cur);
    }
    for(int i=0;i<G[cur].size();i++){
        int v=G[cur][i].v;
        if(v==fa)continue;
        if(v==heavy[cur])continue;
        top[v]=v;
        getdfn(v,cur);
    }
    return;
}
int getlca(int x,int y){
    while(top[x]^top[y]){//
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        x=father[top[x]];
    }
    return dep[x]<dep[y]?x:y;
}
bool cmp(int a,int b){
    return dfn[a]<dfn[b];
}
int tag[100005];
vector<int> V[100005];
vector<edge> E[100005];
void getvst(vector<int> &D,int neta){//把信息存在neta，虚树点的val拉满好了
    sort(D.begin(),D.end(),cmp);
    for(int i=0;i<D.size();i++)tag[D[i]]=neta;
    for(int i=1;i<D.size();i++){
        int now=D[i];
        int need=getlca(D[i],D[i-1]);
        if(tag[need]==neta)continue;
        D.push_back(need);
        tag[need]=neta;
    }
    sort(D.begin(),D.end(),cmp);
    for(int i=1;i<D.size();i++){
        int pre=D[i-1],nxt=D[i];//
        pre=getlca(pre,nxt);
        E[neta].push_back(edge{pre,nxt,dis[nxt]-dis[pre]});
    }
    return;//
}
int hsiz[100005],hheavy[100005];
bool vis[100005];
void getheavy(int cur,int fa){
    hsiz[cur]=1,hheavy[cur]=0;
    for(int i=0;i<H[cur].size();i++){
        int v=H[cur][i].v;
        if(v==fa)continue;
        if(vis[v])continue;
        getheavy(v,cur);
        hsiz[cur]+=hsiz[v];
        if(hsiz[v]>hsiz[hheavy[cur]])hheavy[cur]=v;//
    }
    return;
}
int getrt(int cur){
    int n=hsiz[cur];
    while(hsiz[hheavy[cur]]*2>=n)cur=hheavy[cur];
    return cur;
}
void getV(int cur,int fa,int neta){
    V[neta].push_back(cur);
    for(int i=0;i<H[cur].size();i++){
        int v=H[cur][i].v;
        int w=H[cur][i].w;
        if(v==fa)continue;
        if(vis[v])continue;
        getV(v,cur,neta);
    }
    return;
}
void calc(int cur){//把V塞进去，然后因为E不变，所以把E也塞进去，val就做到哪处理到哪吧。
    getV(cur,0,cur);
    getvst(V[cur],cur);
    return;
}
void build(int cur){
    vis[cur]=true;
    calc(cur);
    for(int i=0;i<H[cur].size();i++){
        int v=H[cur][i].v;
        if(vis[v])continue;
        getheavy(v,cur);
        build(getrt(v));
    }
    return;
}
void updval(int cur,int fa,int dis){
    val[cur]=dis;
    for(int i=0;i<H[cur].size();i++){
        int v=H[cur][i].v;
        int w=H[cur][i].w;
        if(v==fa||vis[v])continue;
        updval(v,cur,dis+w);
    }
    return;
}
void getval(int cur){
    for(int i=0;i<V[cur].size();i++){
        val[V[cur][i]]=1e9;
    }
    val[cur]=0;
    updval(cur,0,0);
    T.build(V[cur],E[cur]);
    // exit(0);
    T.solve();
    return;
}
void solve(int cur){
    vis[cur]=true;
    getval(cur);
    // exit(0);
    for(int i=0;i<H[cur].size();i++){
        int v=H[cur][i].v;
        if(vis[v])continue;
        getheavy(v,cur);
        solve(getrt(v));
    }
    return;
}
signed main(){
    // freopen("test.in","r",stdin);
    // freopen("ans.out","w",stdout);
    in(n);
    for(int i=1;i<n;i++){//G是内层树
        int u,v,w;
        in(u)(v)(w);
        H[u].push_back(node{v,w});
        H[v].push_back(node{u,w});
    }
    for(int i=1;i<n;i++){
        int u,v,w;
        in(u)(v)(w);
        G[u].push_back(node{v,w});
        G[v].push_back(node{u,w});
    }
    getsiz(1,0);
    top[1]=1;
    getdfn(1,0);
    getheavy(1,0);
    build(getrt(1));
    for(int i=1;i<=n;i++)col[i]=i;
    long long ans=0;
    int tot=0;
    while(true){
        for(int i=1;i<=n;i++)col[i]=find(i),vis[i]=false;
        bool tag=false;
        for(int i=2;i<=n;i++)tag|=(col[i]^col[i-1]);
        if(!tag)break;
        for(int i=1;i<=n;i++){
            Min[i]=make_pair(inf,-1);
            GMin[i]=make_pair(inf,-1);
        }
        getheavy(1,0);
        solve(getrt(1));
        for(int i=1;i<=n;i++){
            if(find(i)==i){
                if(GMin[i].second==-1)continue;
                if(find(GMin[i].second)==i)continue;
                col[i]=find(GMin[i].second);
                ans+=GMin[i].first;
            }
        }
    // return 0;
    }
    out(ans)('\n');
    return 0;
}
```

---


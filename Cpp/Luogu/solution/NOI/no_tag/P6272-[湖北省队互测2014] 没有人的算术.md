# [湖北省队互测2014] 没有人的算术

## 题目背景

题目来源：$2014$ 年湖北省队互测Week1

资源来源：[链接](https://tieba.baidu.com/p/3050650090?red_tag=3002680446)

## 题目描述

万物初始之前，宇宙是无边无际混沌的黑暗，只有上帝之灵穿行其间。

上帝对这无边的黑暗十分不满，就一挥手说:“要有光”，于是世间就有了光。从此，世间 就有了昼与夜的交替。这是上帝创世的第一天。

第二天，上帝仍不满意眼前空洞的景象，就一挥手说：“要有零”。于是世间出现了第一个数：$0$。

第三天，上帝对只有 $0$ 很不满意，就一挥手说：“要有非零数”。于是上帝开始创造新数，每个新数用一个已经创造出来的数的有序对表示，即：

$$
x = (x_L, x_R)
$$

于是世间出现了 $(0, 0), (0, (0, 0)), ((0, 0), 0), ((0, 0), (0, 0)), ...$。到了晚上，各种各样千奇百怪的数在大地上奔腾。
（注：上帝造的这个 “数” 与普通的自然数、有理数之类的不同，这种数是以如上所述的方式递归定义的，总是数对里面是数对，拆分到最后会得到不可再拆的 $0$）

第四天，上帝看到各个数不分彼此，就一挥手说：“要有区别”。于是为了区分每个数，上帝定义等于：

1.  $0 = 0$ 。

2.  对于任意 $x_L, x_R, y_L, y_R$，若 $x_L = y_L$ 且 $x_R = y_R$，则 $(x_L, x_R) = (y_L, y_R)$。

3.  对于任意 $x, y$，$x = y$ 当且仅当满足以上条件之一。反之记作 $x \not = y$。

第五天，上帝看到各个数乱成一团，就一挥手说：“要有序”。于是为了比较每个数，上帝定义小于：

1. 对于任意 $x$，若 $x\not = 0$，则 $0 < x$。
2. 对于任意 $x_L, x_R, y_L, y_R$，若 $x_L < y_L$，则 $(x_L, x_R) < (y_L, y_R)$ 。
3. 对于任意 $x_L, x_R, y_L, y_R$，若 $x_L = y_L$ 且 $x_R < y_R$，则 $(x_L, x_R) < (y_L, y_R)$。
4. 对于任意 $x, y$，$x < y$ 当且仅当满足以上条件之一。反之记作 $x\not < y$。

在此基础上定义小于等于：$x ≤ y \iff x < y$ 或 $x = y$ 。容易发现：

1. $x ≤ y, y ≤ x ⇒ x = y$ 。
2. $x ≤ y, y ≤ z ⇒ x ≤ z$ 。
3. $x ≤ y$ 或 $y ≤ x$ 。

进而定义：

1. $x > y \Longleftrightarrow  y < x$ 。
2. $x ≥ y \Longleftrightarrow   x\not < y$。

至此万物欣欣向荣，和睦一堂。

第六天，由于之前沉迷与算术而忘记去造核酸和蛋白质，所以上帝没办法造人。但是上帝不甘心，就一挥手说：“要有跳蚤”，于是用泥巴捏出了神奇生物跳蚤。

上帝用五天的时间造出天地万物，又在第六天造出了唯一的生命——跳蚤。上帝看到天地万物井然有序、生生不息，自己造的跳蚤正在开心地和数学玩耍，很高兴，便决定把第七天作为休息的日子。

跳蚤每天的生活很简单。一天开始时，他会取一个长度为 $n$ 的数组 $a[1,2,\cdots,n]$，初始时均为 $0$。

接着他会不断地做下列两件事之一：

1. 在头脑中产生三个正整数 $l, r, k$，然后把 $a[k]$ 重新赋值为 $(a[l], a[r])$ 。特别地，如果 $l = k$ 或 $r = k$ 也是合法的，这不会导致错误，因为跳蚤总是先默默算出 $(a[l], a[r])$ 再给 $a[k]$ 赋值。

    保证 $1 ≤ l, r, k ≤ n$。

2. 在头脑中产生两个正整数 $l, r$，然后计算 $a[l], a[l + 1], \cdots, a[r − 1], a[r]$ 中的最大值。

     保证 $1 ≤ l ≤ r ≤ n$。

跳蚤当然知道怎么做啦！但是他想考考你……

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/bj1dxhbv.png)

## 样例 #1

### 输入

```
5 10 
C 1 1 1 
C 2 1 2 
Q 1 2 
C 4 4 4 
C 5 5 5 
Q 4 5 
Q 3 3 
C 4 2 3 
C 4 4 4 
Q 3 4```

### 输出

```
2
4
3
3```

# 题解

## 作者：Marser (赞：9)

花姐姐当上志愿者的第二天，赶紧给她传的题写篇题解。  
### 题意
我们定义一个全序集，除 $0$ 以外，每个元素都可以被表示成一个数对 $(x,y)$，且 $x,y$ 均是全序集中的元素。  
我们定义比较运算，规定 $0$ 小于任何一个非 $0$ 数。对于两个数对，我们以 $x$ 为第一关键字，$y$ 为第二关键字进行比较。即，$(x_1,y_1) < (x_2,y_2)$ 当且仅当 $x_1 < x_2$ 或 $x_1 = x_2,y_1<y_2$。  
要求维护一个长为 $n$ 的数列 $\{a\}$，初始时所有元素均为 $0$。我们要支持两种操作：  
- 给定 $i,j,k$，将 $a_k$ 赋值为 $(a_i,a_j)$。
- 给定 $l,r$，求 $\min_{i=l}^r a_i$ 。  

### 题解
根据定义，这种东西可以递归地比较，但是这样复杂度爆炸了，不可接受。  
考虑改良比较方式。如果我们可以以较低的复杂度进行比较，用一棵区间线段树就能完成题目中单点修改、区间查询的操作了。因此，我们首先着眼于如何简化比较。

考虑给每个数对赋上一个满足原数的偏序关系的新权值，用这个权值代替数对进行比较。这样，两个数对的比较就被简化为至多 $4$ 个数的比较。  
这个方法看上去不错，但是不太好实现。我们考虑把所有数对插入一棵平衡树。显然，左子树中所有节点都小于根，右子树中所有节点都大于根。令一个节点的子树权值为 $[v_l,v_r]$，并给当前节点赋上 $\dfrac{v_l+v_r}2$ 的权值，再递归处理两个子树，分别赋上 $[v_l,\dfrac{v_l+v_r}2]$ 和 $[\dfrac{v_l+v_r}2,v_r]$ 的区间权值。容易知道这样赋值满足偏序关系。

问题来了，我们发现，如果平衡树的树高太大，即使使用实数，精度也无法保证。但是，如果要维护平衡的树结构，我们必须旋转。然而，我们无法在旋转的过程中有效地维护赋值结果。不能旋转又要保证高度，我们自然想到了替罪羊树。  
每次在拍扁重构的时候可以将整棵子树进行重新赋值，这样，复杂度就和普通平衡树没有差别了。  
将所得到的权值插入区间线段树，我们就完成了维护。
### 代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int MN=5e5+5;
const double alpha=0.75;
double a[MN];
struct data{
	int l,r;
	inline bool operator<(data x){
		return a[l]==a[x.l]?a[r]<a[x.r]:a[l]<a[x.l];
	}
	inline bool operator==(data x){
		return l==x.l&&r==x.r;
	}
	inline bool operator>(data x){
		return !((*this)<x)&&!((*this)==x);
	}
};
int n,m,root,pos[MN];
#define mid (l+r>>1)
namespace SGT{
	data val[MN];
	int tot,top,siz[MN],ls[MN],rs[MN];
	int len,arr[MN];
	void pia(int t){
		if(!t)return;pia(ls[t]);
		arr[++len]=t;pia(rs[t]);
	}
	void build(int& t,int l,int r,double L,double R){
		if(l>r)return (void)(t=0);
		reg double Mid=(L+R)/2;
		t=arr[mid];a[t]=Mid;
		build(ls[t],l,mid-1,L,Mid);
		build(rs[t],mid+1,r,Mid,R);
		siz[t]=siz[ls[t]]+siz[rs[t]]+1;
	}
	void rebuild(int& t,double L,double R){
		len=0;pia(t);build(t,1,len,L,R);
	}
	int insert(int& t,double L,double R,data v){
		double Mid=(L+R)/2;
		if(!t){
			t=++tot;siz[t]=1;val[t]=v;
			a[t]=Mid;return t;
		}
		if(v==val[t])return t;
		siz[t]++;reg int res=0;
		if(v<val[t])res=insert(ls[t],L,Mid,v);
		else res=insert(rs[t],Mid,R,v);
		if(max(siz[ls[t]],siz[rs[t]])<siz[t]*alpha){
			if(top){
				if(ls[t]==top)rebuild(ls[t],L,Mid);
				else rebuild(rs[t],Mid,R);top=0;
			}
		}
		else top=t;
		return res;
	}
}
namespace ST{
	#define ls (t<<1)
	#define rs (t<<1|1)
	int tr[MN];
	void update(int t,int l,int r,int pos){
		if(l==r)return (void)(tr[t]=l);
		if(pos<=mid)update(ls,l,mid,pos);
		else update(rs,mid+1,r,pos);
		if(a[::pos[tr[ls]]]>=a[::pos[tr[rs]]])tr[t]=tr[ls];
		else tr[t]=tr[rs];
	}
	int query(int t,int l,int r,int a,int b){
		if(a<=l&&r<=b)return tr[t];
		if(b<=mid)return query(ls,l,mid,a,b);
		if(a>mid)return query(rs,mid+1,r,a,b);
		reg int pl=query(ls,l,mid,a,mid),pr=query(rs,mid+1,r,mid+1,b);
		if(::a[pos[pl]]>=::a[pos[pr]])return pl;
		else return pr;
	}
	#undef ls
	#undef rs
}
int main(){
	scanf("%d%d",&n,&m);
	a[0]=-1;
	SGT::insert(root,0,1,(data){0,0});
	for(reg int i=1;i<=n;i++)pos[i]=1;
	for(reg int i=1;i<=n;i++)pos[i]=1;
	for(reg int i=1;i<=n;i++)ST::update(1,1,n,i);
	while(m--){
		static char ch[5];
		static int l,r,x;
		scanf("%s%d%d",ch,&l,&r);
		if(ch[0]=='C'){
			scanf("%d",&x);
			pos[x]=SGT::insert(root,0,1,(data){pos[l],pos[r]});
			if(SGT::top)SGT::rebuild(root,0,1),SGT::top=0;
			ST::update(1,1,n,x);
		}
		if(ch[0]=='Q')
			printf("%d\n",ST::query(1,1,n,l,r));
	}
	return 0;
}
```

---

## 作者：Swirl (赞：6)

理解了最高赞题解做法做出的这道黑题，特此留念。

---

> SGT（替罪羊树） + SGT（线段树）

首先，直接递归比较两个「数」是非常麻烦的，考虑用类似哈希的思想将每一个「数」对应成一个实数（不一定是整数），接下来的比较就变得简单了。

但是问题是该如何对每个「数」赋一个值呢？

我们先把所有的「数」放到一棵平衡树上。

对于以 $u$ 为根的子树，传入一个区间 $\left [ L, R \right ]$。

先将 $u$ 的权值赋为 $\frac{L + R}{2}$，接着分别往左右儿子递归传入 $\left [ L, \frac{L + R}{2} \right ]$、$\left [ \frac{L + R}{2}, R \right ]$（根节点的传参随便设置一个就行，代码中用的是 $\left [ 0, 1 \right ]$）。

可以证明此时的赋值一定满足平衡树的性质。

显然，这里的赋值不能用整数（因为精度太低），考虑用浮点数。

但是如果不用特殊的方法维护树高退化成一条链后浮点数的精度也不够。

如果用 Splay 等旋转类平衡树，就无法快速维护赋值的结果，其复杂度就会大大提升。

考虑用替罪羊树解决问题。

我们正好可以在重构的时候重新为整棵平衡树赋值，此时既保证了树高平衡又保证了复杂度平衡。

最后用线段树维护最大值编号即可。

---

**具体实现的注意事项或技巧**：

- 可以开一个 $pos$ 数组，用来存储数组 $a$ 中的下标对应到平衡树中的位置，在线段树中方便维护。
- 存储 $(a_l, a_r)$ 时可以分别记录 $a_l$ 和 $a_r$ 在平衡树里的位置（因为以前一定插入过），然后比较会更方便。
- $\alpha$ 不要写成 `int` 类型了……
- 建议不要用 `pair`，会莫名其妙 WA。
- 结点插进来就不要删了，因为后面的计算可能会用到。

---

```cpp
#include <bits/stdc++.h>
#define int long long
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

inline void cmax(int& x, int c) {
    x = max(x, c);
}
inline void cmin(int& x, int c) {
    x = min(x, c);
}

int _test_ = 1;
const int N = 5e5 + 5;
const double alpha = 0.75;
int n, m, rt, pos[N];
double V[N];  // 赋上的值

struct node {  // 存储 (L, R)
    int l, r;
    bool operator<(const node& x) const {
        return V[l] < V[x.l] ||
               (V[l] == V[x.l] && V[r] < V[x.r]);  // 比较规则题面
    }
    bool operator==(const node& x) const { return l == x.l && r == x.r; }
};

struct scape_goat {
    int tot, siz[N];      // 目前总结点数，子树大小
    node val[N];          // 值
    int son[N][2];        // 儿子
    void pushup(int u) {  // 上传
        siz[u] = siz[son[u][0]] + siz[son[u][1]] + 1;
    }
    int nwnode(node v) {  // 新建节点
        tot++;
        siz[tot] = 1;
        val[tot] = v;
        return tot;
    }
    bool ck_reb(int u) {  // 是否重构
        return alpha * siz[u] > (double)max(siz[son[u][0]], siz[son[u][1]]);
    }
    void re_dfs(vector<int>& p, int u) {  // 拍扁
        if (!u)
            return;
        re_dfs(p, son[u][0]);
        p.push_back(u);
        re_dfs(p, son[u][1]);
    }
    int re_bui(vector<int>& p, int l, int r, double L, double R) {  // 提起来
        if (l > r)
            return 0;
        int mid = (l + r) >> 1;
        double Mid = (L + R) / 2.0;
        V[p[mid]] = Mid;
        son[p[mid]][0] = re_bui(p, l, mid - 1, L, Mid);
        son[p[mid]][1] = re_bui(p, mid + 1, r, Mid, R);
        pushup(p[mid]);
        return p[mid];
    }
    void rebuild(int& u, double L, double R) {  // 重构函数
        vector<int> p;
        re_dfs(p, u);
        u = re_bui(p, 0, p.size() - 1, L, R);
    }
    int ins(int& u, node v, double L, double R) {  // 插入一个 v，取 [L, R] 赋值
        double Mid = (L + R) / 2.0;
        if (!u) {
            u = nwnode(v);
            V[u] = Mid;
            return u;
        }
        if (val[u] == v)
            return u;
        siz[u]++;
        int ret = (v < val[u]) ? ins(son[u][0], v, L, Mid)
                               : ins(son[u][1], v, Mid, R);
        if (!ck_reb(u))
            rebuild(u, L, R);
        return ret;
    }
} sgt;

struct segment_tree {
#define ls (id << 1)
#define rs (id << 1 | 1)
    int mx[N];  // 最大值下标
    void change(int id, int lft, int rht, int x) {
        if (lft == rht) {
            mx[id] = x;
            return;
        }
        int mid = (lft + rht) >> 1;
        if (x <= mid)
            change(ls, lft, mid, x);
        else
            change(rs, mid + 1, rht, x);
        mx[id] = (V[pos[mx[ls]]] >= V[pos[mx[rs]]]) ? mx[ls] : mx[rs];  // 上传
    }
    int query(int id, int lft, int rht, int l, int r) {
        if (l <= lft && rht <= r)
            return mx[id];
        int mid = (lft + rht) >> 1;
        if (r <= mid)
            return query(ls, lft, mid, l, r);
        if (l > mid)
            return query(rs, mid + 1, rht, l, r);
        int L = query(ls, lft, mid, l, mid);
        int R = query(rs, mid + 1, rht, mid + 1, r);
        return (V[pos[L]] >= V[pos[R]]) ? L : R;
    }
} seg;

void solve() {
    cin >> n >> m;
    sgt.ins(rt, node{0, 0}, 0.0, 1.0);  // 插入最原始的 0
    for (int i = 1; i <= n; i++)        // 赋初值
        pos[i] = 1;
    for (int i = 1; i <= n; i++)
        seg.change(1, 1, n, i);
    while (m--) {
        char c;
        int l, r;
        cin >> c >> l >> r;
        if (c == 'Q') {
            cout << seg.query(1, 1, n, l, r) << "\n";
        } else {
            int x;
            cin >> x;
            pos[x] = sgt.ins(rt, node{pos[l], pos[r]}, 0.0, 1.0);  // 插入
            seg.change(1, 1, n, x);
        }
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
```

---

## 作者：阿丑 (赞：5)

[传送门](https://www.luogu.com.cn/problem/P6272)

#### 前置知识：

平衡树（Treap/替罪羊树），~~应该没人会了平衡树不会线段树吧 qwq~~

#### 题意：

* 定义一种数：$0$ 是数，其他的数用 $(x_L, x_R)$ 表示，其中 $x_L,x_R$ 也是这种数。

* 定义等于：$0=0$；当 $x_L=y_L,x_R=y_R$ 时，认为 $(x_L, x_R)=(y_L, y_R)$。

* 定义小于：对于 $x \neq 0$，有 $0<x$；当 $x_L<y_L$ 时或 $x_L=y_L,x_R<y_R$ 时，认为 $(x_L, x_R)<(y_L, y_R)$。

* 现在有一个长度为 $n$，初始值均为 $0$ 的数列 $\{a_n\}$，处理 $m$ 次操作，每次操作分为两种：将 $(a_l, a_r)$ 赋值给 $a_k$；询问 $a_{l...r}$ 中最大数的编号，如果有相同的数，输出最小的编号。

* $n\le 10^5$，$m\le 5×10^5$。

~~好长的简述~~

#### 分析：

暴力想法是递归比较，但是每次更改操作可能使一个数中 $0$ 的数量增加至两倍，会 T。

注意到，每一次操作都最多只能增加一个数，所以最多只会出现约 $m$ 个不相同数；并且每次的新数都是由曾经出现过的数组成的，那么就可以通过曾经出现过的大小关系来进行新数与旧数的比较。

每两个数之间有一个大小关系，那难道我们要存储 $m^2$ 种关系？当然不用，注意到题目所提供的条件：

$$x\le y,y\le z \Rightarrow x\le z$$

（~~其实不需要题目提供~~），这意味着这种数与常规数的大小关系是类似的，因此我们可以给每个数赋上一个常规数的权值，通过比较常规数来比较这种数的关系。

如果能够方便地维护这样的权值，由于修改又是单点修改，故只需要开一棵线段树就可以处理区间最大值；因此先考虑如何维护权值。

当产生一个新数时，我们需要给其赋上一个新权值，而由于新数 $(a_l, a_r)$ 和旧数 $(x_L, x_R)$ 中的 $a_l,a_r,x_L,x_R$ 权值都已知，因此比较就可以 $O(1)$ 进行。假设这个权值序列有序，我们就可以 $O(\log n)$ 查找新数应该在哪个位置。

而维护一个序列，支持在序列中间插入元素，显然可以使用 set。

然而，如果不停地在两个数中间插入新数，就会这样：

![这里是一张图 qwq](https://z3.ax1x.com/2021/05/27/2i8MjI.png)

（这里的 al, ar 显然并不是 $a_k=(a_l, a_r)$ 的 $a_l,a_r$，而是某两个数的常规数权值）

当分割很多次后（~~尤其是五十万次~~），剩下的区间就会很小，导致精度不够的问题。

但是，我们由此联想到，这类似于一条无限下降的链：

![另一张图](https://z3.ax1x.com/2021/05/27/2i8vrt.png)

那么，我们可以通过“旋转”来降低链的高度，即提升了区间的大小；同时也保证相对大小关系不变，而我们维护的“权值”正好只考虑相对大小，十分合适。

![挺多余的图](https://z3.ax1x.com/2021/05/27/2iG4zj.png)


考虑实现。~~肯定不能用 set 了~~，可以手写平衡树，每个节点上不仅存放权值，还存放该节点权值的上下界（方便旋转），“旋转”就对应树的旋转。此时，旋转就不只是改变了节点的父亲儿子关系，也改变了节点的权值。

举个例子，假设上图中，节点 al 权值为 0，节点 ar 权值为 16，并且只考虑以 m1 为根的子树。那么旋转前：

|节点| m1 | m2 | m3 | m4 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|父亲| / | m1 | m2 | m3 |
|权值| 8 | 4 | 2 | 1 |
|上下界| (0, 16) | (0, 8) | (0, 4) | (0, 2) |


旋转后：

|节点| m1 | m2 | m3 | m4 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|父亲| m2 | / | m2 | m3 |
|权值| 12 | 8 | 4 | 2 |
|上下界| (8, 16) | (0, 16) | (0, 8) | (0, 4) |

虽然可以保证精度，但每次旋转都要更新子树所有节点的权值，若旋转次数多（如 Splay）就不能接受。考虑替罪羊树（无旋）或 Treap（期望旋转次数 $O(1)$）实现。

同时，为了方便比较，对于数 $x(x_L, x_R)$ 还应该存储 $x_L$ 和 $x_R$（~~虽然这个存在树外面也行~~）。

#### 思路：

1. Treap 维护每个数的权值，每次赋值操作对应着插入新数或者发现新数与某旧数相同。~~蒟蒻不会替罪羊~~

2. 使用线段树维护区间最值，每次赋值操作进行单点修改。（虽然整颗子树权值改变，但相对大小关系不变，故只需修改新数对应的位置。）

---

给出 Treap 部分的代码。

```cpp

double mn[mS], mx[mS];	//下界，上界 
double rk[mS];	//rk[p] 表示平衡树中节点 p 的权值，与 (mn[p]+mx[p])/2 相等 
int totn;
int son[mS][2], rd[mS], xl[mS], xr[mS];
//xl xr 即 (xL, xR)，就是这个数从哪里来 
namespace Treap {
#define lc son[p][0]
#define rc son[p][1]
	int rt;
	inline void build() {	//插入第一个节点，因为这个时候要赋值初始的上下界，所以单独写 
		rt=++totn, rd[rt]=rand(), xl[rt]=0, xr[rt]=0;	//这个数是 (0, 0) 
		mn[rt]=0, mx[rt]=inf, rk[rt]=(mn[rt]+mx[rt])/2;
	}
	inline void push_down(int p) {	//向下传递 mn 和 mx，同时用自己的上下界更新自己的权值。
		mn[lc]=mn[p], mx[lc]=mn[rc]=rk[p]=(mn[p]+mx[p])/2, mx[rc]=mx[p];
	}
	inline void update(int p) {	//更新整个子树内节点的权值 
		push_down(p);
		if(lc) update(lc); if(rc) update(rc);
	}
	inline void rotate(int &p, bool t) {
		int x=son[p][t^1];
		son[p][t^1]=son[x][t], son[x][t]=p;
		mn[x]=mn[p], mx[x]=mx[p], update(p=x);	//旋转时要把 p 的上下界赋给 x，再更新整个子树 
	}
	inline int insert(int &p, int f, int l, int r) {	//f 表示 father
		if(!p) {
			p=++totn, rd[p]=rand();
			xl[p]=l, xr[p]=r;
			push_down(f), rk[p]=(mn[p]+mx[p])/2;	//push_down f，用来得到 p 的上下界 
			return p;	//返回值是新数 (l, r) 的编号 
		}
		if(rk[l]==rk[xl[p]] && rk[r]==rk[xr[p]]) return p;
		bool t=!(rk[l]<rk[xl[p]]||rk[l]==rk[xl[p]]&&rk[r]<rk[xr[p]]);
		//括号内表示 (l, r) 比 p(xl, xr) 小，那 !(...) 就是 (l, r) 比 p 大
		//等等我为什么要这么写 
		int res=insert(son[p][t], p, l, r);
		if(rd[son[p][t]]<rd[p]) rotate(p, t^1);
		return res;
	}
#undef lc
#undef rc
}
```

---

## 作者：TLE_AK (赞：2)

#### 前言
这题真的是道紫吗……感觉像道黑（
### 题意
定义一个数为 $(x,y)$，初始时这个数为 $0$，之后可以用两个数来代替 $x,y$。

对于两个数 $(x1,y1)$ 与 $(x2,y2)$ 它们的关系如下：

1.如果 $ x1=x2 $ 并且 $ y1=y2 $，$ (x1,y1)=(x2,y2) $。
2.如果 $ x1 > x2 $ 或者 $ x1 = x2 $ 的同时 $ y1 >y2 $，则 $ (x1,y1)>(x2,y2) $。  
3.否则 $ (x1,y1)<(x2,y2) $。

现在维护一个这种数的数组 $A$，拥有两种操作：

- 给予 $l,r,k$ 使 $A_k = (A_l,A_r) $。
- 给予 $l,r$ 求 $A_{l...r}$ 的最小值。 
### 思路
首先，我们肯定不能使用暴力递归的方式来通过 $10^5$ 的数据。  
考虑使用一个实数来代替定义的数，使判断大小成为四个值的比较，可以用BST来维护每个值域区间 $(l,r)$，维护每个区间所代表的值 $(\frac{l+r}{2})$ 与对应的 $(x,y)$，这样就可转化为几个数了。  
（括号内的数表权值代表的定义数，边权是子树代表的区间）

![233](https://cdn.luogu.com.cn/upload/image_hosting/5srbsxyo.png)

但是由于那 $10^5$ 的数据,光用 BST 不仅精度会缺失，也会 TLE，所以我们需要使用平衡树来保证树高。这时候问题来了——怎么维护呢？

因为我们需要重构时准确维护子树内的结果，而需要旋转的平衡树很难做到这一点，所以选择替罪羊树。

替罪羊树重构时需要改变节点的权值（改变了 $(x,y)$ 对应的区间），同时也会出现 $16$ 不是 $16$ 之类的情况：例如上图权值 $24$ 的节点会变为 $16$，出现“我的父亲是我的情况”所以应该记录 $(x,y)$ 对应数的下标。

最后记录区间位置，用线段树维护即可。

### 代码
[code](https://www.luogu.com.cn/paste/8cy7he8l)




---

## 作者：Rainsleep (赞：2)

[cnblog](https://www.cnblogs.com/Rainsheep/p/18639975)

本文参考了 **湖北省队互测 Week1 解题报告**，在部分之处说明可能不如原题解，如有错误请指出。

洛谷上的题面缺失了特殊性质，不过原题的特殊性质还是比较具有启发性的，下面是原题面中的数据范围。

![](https://cdn.luogu.com.cn/upload/image_hosting/myoyhqna.png)

## 测试点 $1$

考察选手的读题能力。按照题目提供的比较方式暴力递归即可。

## 测试点 $2 \sim 3$

考虑特殊性质随机生成的实质。注意到如果我们一直操作 ``C 1 1 1`` 的话，比较树的大小是 $O(2^n)$ 的。但是在随机数据下，一个数字并不会被合并很多次，所以可以忽略比较的常数，直接用线段树维护序列，时间复杂度为 $O(m \log n)$。

## 测试点 $4 \sim 5$

注意到暴力维护的瓶颈实质上在于比较两个数的复杂度，例如在上个测试点中我们就是依赖 **随机数据下两个数的比较复杂度低** 来暴力解决的，那么如果规定了总共出现过的不同的数字不会超过 $1000$ 个，那么不妨采用记忆化的思想，设 $cmp_{i, j}$ 表示第 $i$ 个出现的数字和第 $j$ 个出现的数字比较的结果，暴力把这张 $V^2$ 的表打出来，就能把比较的复杂度降为 $O(1)$。

依然采用线段树实现，复杂度为 $O(V^2 + m\log n)$。

## 测试点 $6 \sim 7$

仔细想想上面的做法在某种程度上没什么必要，如果我们能从小到大直接维护出数字的相对顺序，也能直接比较两个数。
考虑用平衡树维护这个序列（大小关系的序列），一件很好的事情是，我们的两个关键字都是已经出现过的值，那么只要根据 $x_L, x_R$ 的排名就能在 $O(\log V)$ 的时间内比较一对数。

这样比较一次是 $O(\log V)$，那么插入一个数就是 $O(\log^2 V)$ 的（插入路径上的所有点都需要查排名）。查询也就变成 $O(\log n \log V)$ 的，那么复杂度为 $O(m(\log^2 V + \log n\log V))$。

## 测试点 $8 \sim 10$

上面所有的铺垫都在将答案指向一个地方——离散化。例如 $50$ 分时，我们的离散化工具是 $cmp_{i,j}$；在 $70$ 分时，我们的离散化工具是两个数的排名。

有没有什么能够 $O(1)$ 实现两个数比较的离散化方法呢？如果我们使用 **精度足够** 的实数，似乎也能实现这一想法！

于是我们直接考虑在 BST 上从根开始给每个节点赋值，例如从根开始是 $[0, V]$，然后分裂为 $[0, \dfrac{V}{2}),(\dfrac{V}{2}, V]$，以此类推。问题到这里还没结束，注意我们上文提到了如果想用实数进行比较，一定要保证 **精度**，于是我们想起平衡树来。

平衡树的树高是 $\log n$ 级别，那么最底层对精度的要求为 $2^{-\log n} = \dfrac{1}{n}$ ，而 $n$ 只有 $10^5$ 而已，所以精度是完全够用的。

但是，注意平衡树用于维护平衡的操作——旋转。麻烦的是，在进行一次旋转后，我们子树内所有点的值域都被完全打乱了，这个时候再插入数时每个点的值域就完全不一样了，所以考虑用结构稳定，依赖定期重构维护平衡结构的重量平衡树，这样我们可以在每次重构的过程中顺便计算每个点维护的值域。

大功告成，复杂度即为 $O(m(\log V + \log n))$。实现用了替罪羊树。

```cpp
// 如果命运对你缄默, 那就活给他看。
// #pragma GCC optimize(1)
// #pragma GCC optimize(2)
// #pragma GCC optimize(3)
// #pragma GCC optimize("Ofast", "inline", "-ffast-math")
// #pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include <bits/stdc++.h>
using namespace std;
typedef long long LL; 
// #define int LL
const int maxn = 600010;
int w[maxn], n, m;
namespace scapegt {
  int tot, rt;
  struct Node {
    int x, y;
    double v;
    int ls, rs;
    int c, sz;
  } t[maxn];
  const double ap = 0.9;
  inline void pu(int u) {
    t[u].sz = t[t[u].ls].sz + t[t[u].rs].sz + t[u].c;
  } 
  inline bool balance(int u) {
    double lw = t[u].sz * ap;
    return max(t[t[u].ls].sz, t[t[u].rs].sz) <= lw;
  }
  int acc = 0;
  int v[maxn];
  inline void dfs1(int u) {
    if(!u) return ;
    dfs1(t[u].ls);
    v[++ acc] = u;
    dfs1(t[u].rs);
  }
  inline int rebuild(int l, int r, double vl, double vr) {
    if(l > r) return 0; 
    int mid = l + r >> 1;
    double vmid = (vl + vr) / 2;
    int u = v[mid];
    t[u].v = vmid;
    t[u].ls = rebuild(l, mid - 1, vl, vmid);
    t[u].rs = rebuild(mid + 1, r, vmid, vr);
    pu(u);
    return u;
  }
  inline void dfs(int& u, double vl, double vr) {
    acc = 0;
    dfs1(u);
    u = rebuild(1, acc, vl, vr);
  }
  inline void insert(int& u, double vl, double vr, int l, int r, int k) {
    double mid = (vl + vr) / 2;
    if(!u) {
      u = ++ tot;
      t[u].x = w[l], t[u].y = w[r];
      t[u].v = mid;
      t[u].c = t[u].sz = 1;
      w[k] = u;
      return ;
    }
    if(t[t[u].x].v == t[w[l]].v && t[t[u].y].v == t[w[r]].v) {
      w[k] = u;
      t[u].c ++, pu(u);
      return ;
    }
    if(t[w[l]].v < t[t[u].x].v || (t[w[l]].v == t[t[u].x].v && t[w[r]].v < t[t[u].y].v)) insert(t[u].ls, vl, mid, l, r, k);
    else insert(t[u].rs, mid, vr, l, r, k);
    pu(u);
    if(!balance(u)) dfs(u, vl, vr);
  } 
  inline void print(int u) {
    if(!u) return ;
    print(t[u].ls);
    cout << fixed << setprecision(3) << u << ' ' << t[u].v << ' ' << t[u].x << ' ' << t[u].y << " " << '\n';    
    print(t[u].rs);
  }
}
namespace sgt {
  int mx[maxn];
  inline int cmx(int x, int y) {
    return scapegt :: t[w[x]].v >= scapegt :: t[w[y]].v ? x : y; 
  }
  inline void pu(int u) {
    mx[u] = cmx(mx[u << 1], mx[u << 1 | 1]);
  }
  inline void modf(int u, int l, int r, int p) {
    if(l == r) return ;
    int mid = l + r >> 1;
    if(p <= mid) modf(u << 1, l, mid, p);
    else modf(u << 1 | 1, mid + 1, r, p);
    pu(u);
  }
  inline int Q(int u, int l, int r, int ql, int qr) {
    if(ql <= l && r <= qr) return mx[u];
    int mid = l + r >> 1;
    if(qr <= mid) return Q(u << 1, l, mid, ql, qr);
    if(ql > mid) return Q(u << 1 | 1, mid + 1, r, ql, qr);
    return cmx(Q(u << 1, l, mid, ql, qr), Q(u << 1 | 1, mid + 1, r, ql, qr));
  }
  inline void build(int u, int l, int r) {
    mx[u] = l;
    if(l == r) return ;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
  }
}
signed main() {
  ios :: sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  char c[2];
  sgt :: build(1, 1, n);
  for(int i = 1; i <= m; ++ i) {
    int l, r, k;
    cin >> c >> l >> r;
    if(*c == 'C') {
      cin >> k;
      scapegt :: insert(scapegt :: rt, 1.0, 1e9, l, r, k);
      sgt :: modf(1, 1, n, k);
    } else {
      cout << sgt :: Q(1, 1, n, l, r) << '\n';
    }
  }
  return 0;
}
```
不知道为什么大家的 $\alpha$ 为什么取 $0.75$ 跑的都这么快，我只有取到 $0.9$ 的时候能跑的飞快（

---

## 作者：suxxsfe (赞：2)

在我的博客查看：https://www.cnblogs.com/suxxsfe/p/13392676.html  

https://darkbzoj.tk/problem/3600  
https://www.luogu.com.cn/problem/P6272  
替罪羊树+线段树  

题意：  
定义了新的一种数，递归的定义为：$(x,y)$ 或 $0$，其中 $x,y$ 也是这种数  
对于两个这种数大小的比较：若 $a<b$ 或 $a=b,c<d$，则 $(a,b)<(c,d)$；若 $a=b,c=d$ 则 $(a,b)=(c,d)$  

给定一个长度为 $n$ 的这种数的序列 $a$，初始全是 $0$，有 $m$ 个操作，分为两种：  

- `C l r k`：将 $a_k$ 赋值为 $(a_l,a_r)$  
- `Q l r`：查询 $a_l,\ldots a_r$ 中最小的数，如果存在多个同样小的数，将编号最小的视为最小。输出这个编号  

$n\le 10^5,m\le 5\cdot 10^5$  

---------------------  

如果我们能较快的比较两个数的大小，那直接一个线段树单点查询区间维护最大就完了  
但如果按照定义来比较，显然复杂度爆掉，那么下面考虑如何更快的比较  

可以把每一个题目里的数都用一个实数来表达  

首先要解决的是，如何确定这个实数的值。  
因为我们不知道后面插入的数有多少比他大，多少比他小，所以可以把它们放到一颗二叉树上，每个节点代表一个权值的区间 $(l,r)$，然后这个节点上的数对权值就是 $\dfrac{l+r}{2}$  
当插入一个数对时，如果这个数对比当前节点的数对小，就近左子树，权值区间 $(l,\frac{l+r}{2})$，反之进入右子树，权值区间 $(\frac{l+r}{2},r)$  
一直递归到节点为空，或当前节点存在且它代表的数对和插入的数对相等，就返回这个节点  

但这样，如果退化成一个链，那每次除以二，精度还是不够用  
而这里又涉及权值的区间的问题，不能用基于旋转或分裂合并的平衡树，所以应该用替罪羊树  
每次暴力重构的时候，重新为每个节点赋上权值的区间，还有代表这个节点数对的实数  

下面就是实现细节上的问题了  
至于如何在一个节点保存一个数对，我们在节点的结构体里存两个指针，由于一个数对实际上是由两个保存在其它节点的数对组成，所以这两个指针也就分别指向组成它的两个节点  
此外，还需要一个 `pos` 指针数组，$pos_i$ 指向 $a_i$ 所对应的数对在替罪羊树上的节点  
然后就可以借助这个数组在线段树上进行 pushup 了  

只于一开始所有数都为 $0$，就先往替罪羊树里插入一个那两个指针都是 null 的节点，也就是根，然后所有 $pos_i$ 一开始都指向根就行了  

屎山代码（写了好几个小时，而且是真的丑）：  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
#define N 500005
int n,m;
struct GOAT{
	#define alpha 0.7
	struct tr;
	struct data{
		tr *l,*r;
		inline int operator <(const data &x){
			return l->a==x.l->a?r->a<x.r->a:l->a<x.l->a;
		}
		inline int operator==(const data &x){
			return l->a==x.l->a&&r->a==x.r->a;
		}
	};
	struct tr{
		tr *ls,*rs;
		int size;
		data val;
		double a;
	}*root,*null,**badtag,dizhi[N],*nodes[N],*pos[N];
	double badtagL,badtagR;
	int tot,node;
	inline void init(){
		null=&dizhi[0];
		null->val=(data){0,0};
		null->size=0;
		root=null;
	}
	inline int isbad(tr *tree){
		return tree->ls->size>tree->size*alpha+5||tree->rs->size>tree->size*alpha+5;
	}
	void dfs(tr *tree){
		if(tree->ls!=null) dfs(tree->ls);
		nodes[++node]=tree;
		if(tree->rs!=null) dfs(tree->rs);
	}
	tr* build(int l,int r,double L,double R){
		if(l>r) return null;
		double MID=(L+R)/2;
		if(l==r){
			nodes[l]->ls=nodes[l]->rs=null;
			nodes[l]->size=1;
			nodes[l]->a=MID;
			return nodes[l];
		}
		int mid=(l+r)>>1;
		nodes[mid]->ls=build(l,mid-1,L,MID);nodes[mid]->rs=build(mid+1,r,MID,R);
		nodes[mid]->size=1+nodes[mid]->ls->size+nodes[mid]->rs->size;
		nodes[mid]->a=MID;
		return nodes[mid];
	}
	inline void rebuild(tr *&tree){
		node=0;dfs(tree);
		tree=build(1,node,badtagL,badtagR);
	}
	tr* insert(tr *&tree,double l,double r,data k){
		double mid=(l+r)/2;
		if(tree==null){
			tree=&dizhi[++tot];
			tree->ls=tree->rs=null;
			tree->val=k;
			tree->a=mid;
			tree->size=1;
			return tree;
		}
		if(k==tree->val) return tree;
		tree->size++;
		tr* ret;
		if(k<tree->val) ret=insert(tree->ls,l,mid,k);
		else ret=insert(tree->rs,mid,r,k);
		if(isbad(tree)) badtag=&tree,badtagL=l,badtagR=r;
		return ret;
	}
	inline tr* Insert(data k){
		badtag=NULL;
		tr *ret=insert(root,1,1e9,k);
		if(badtag) rebuild(*badtag);
		return ret;
	}
	#undef alpha
}B;
struct SEG{
	struct tr{
		tr *ls,*rs;
		int pos;
	}dizhi[N],*root=&dizhi[0];
	int tot;
	void build(tr *tree,int l,int r){
		if(l==r) return tree->pos=l,void();
		tree->ls=&dizhi[++tot];tree->rs=&dizhi[++tot];
		int mid=(l+r)>>1;
		build(tree->ls,l,mid);build(tree->rs,mid+1,r);
		tree->pos=l;
	}
	void change(tr *tree,int l,int r,int pos){
		if(l==r) return;
		int mid=(l+r)>>1;
		if(pos<=mid) change(tree->ls,l,mid,pos);
		else change(tree->rs,mid+1,r,pos);
		tree->pos=B.pos[tree->ls->pos]->a>=B.pos[tree->rs->pos]->a?tree->ls->pos:tree->rs->pos;
	}
	int get(tr *tree,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr) return tree->pos;
		int mid=(l+r)>>1;
		if(qr<=mid) return get(tree->ls,l,mid,ql,qr);
		if(ql>mid) return get(tree->rs,mid+1,r,ql,qr);
		int L=get(tree->ls,l,mid,ql,qr),R=get(tree->rs,mid+1,r,ql,qr);
		return B.pos[L]->a>=B.pos[R]->a?L:R;
	}
}A;
int main(){
	n=read();m=read();
	B.init();
	B.Insert((GOAT::data){B.null,B.null});
	A.build(A.root,1,n);
	for(reg int i=1;i<=n;i++) B.pos[i]=B.root;
	reg int l,r,k;char c;
	while(m--){
		c=getchar();
		while(c!='Q'&&c!='C') c=getchar();
		l=read();r=read();
		if(c=='C'){
			k=read();
			B.pos[k]=B.Insert((GOAT::data){B.pos[l],B.pos[r]});
			A.change(A.root,1,n,k);
		}
		else printf("%d\n",A.get(A.root,1,n,l,r));
	}
	return 0;
}
```

---


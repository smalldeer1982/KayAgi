# [QkOI#R1] Quark and Game

## 题目描述

给定 $n$ 个二元组 $(a_i,b_i)$，当 $b_i\le 0$ 时该二元组不再可以被操作。你可以执行两个操作：

1. 对于**所有**可以被操作的二元组，执行 $b_i\gets b_i-a_i$，即令 $b_i$ 的值减少 $a_i$，花费 $p$。

2. 对于**所有**可以被操作的二元组，执行 $\operatorname{Swap}(a_i,b_i)$，其中 $\operatorname{Swap}(x,y)$ 表示交换 $x,y$ 的值，花费 $q$。

现在，你要用最少的花费，使得所有二元组都不可以被操作.

## 说明/提示

### 样例解释

对于第一个样例，我们可以先后进行 $1$ 次操作 1，$1$ 次操作 2，$1$ 次操作 1，最小花费为 $9 + 5 + 9 = 23$。  
对于第二个样例，我们可以进行 $2$ 次操作 1，最小花费为 $500 \times 2 = 1000$。  
对于第三个样例，我们可以进行 $500$ 次操作 1，最小花费为 $1 \times 500 = 500$。

---

### 数据范围


**本题采用捆绑测试。**

- Subtask 1（10 pts）：$n\le 100$，$a_i,b_i\le 20$。
- Subtask 2（20 pts）：$n\le 1000$，$a_i,b_i\le 1000$。
- Subtask 3（17 pts）：$p=1$，$q=10^7$。
- Subtask 4（53 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le p,q\le 10^7$，$1\le a_i,b_i\le 10^5$。

## 样例 #1

### 输入

```
4 9 5
1 7
1 4
6 5
4 2```

### 输出

```
23```

## 样例 #2

### 输入

```
3 500 3
4 6
3 5
8 1```

### 输出

```
1000```

## 样例 #3

### 输入

```
2 1 1000
1 500
2 800```

### 输出

```
500```

# 题解

## 作者：qazswedx (赞：33)

首先，把这 $n$ 个二元组 $(a_i,b_i)$ 看成向量的形式，记 $\vec{v_i}=\begin{bmatrix}a_i\\b_i\end{bmatrix}$，默认向量的起点在原点。

可以发现，这两种操作对应了两个线性变换，把操作一和操作二对应的矩阵分别称作 $M_1,M_2$。那么题目就是要找到一个由矩阵 $M_1,M_2$ 构成的序列 $A_1,A_2,\cdots,A_k$，使得对于所有 $\vec{v_i}$，$A_kA_{k-1}\cdots A_1\vec{v_i}$ 的结果一定至少有一维非正。

在刚才转化后的题意中，似乎漏了一个只有当 $b_i>0$ 时才能继续操作的限制，但可以证明只要有一维非正，那么接下来的操作不会使 $a_i,b_i$ 重新同时变为正数。

接着，我们来考虑这个序列会漏掉哪些向量，也就是经过一系列变换后向量依旧在第一象限。比如空序列漏掉了第一象限的向量，只包含一个 $M_1$ 的序列漏掉了直线 $y=x$ 和 $x=0$ 右上方的向量。多举几个例子就可以发现漏掉的向量都在两条过原点的直线的右上方（不包括直线上），详细证明这个结论只需要考虑线性变换的性质。

然后，我们对这 $n$ 个向量按极角从小到大排序，那么如果要想让这 $n$ 个向量都不被漏掉，这两条直线就一定会在两个相邻向量之间。先特判一下两条直线在 $\vec{v_1}$ 下面或在 $\vec{v_n}$ 左面的情况（对应先进行一次操作二，再一直进行操作一或一直进行操作一）。我们发现这个问题现在只和这两个相邻的向量有关了。不妨设两条直线在 $\vec{v_1},\vec{v_2}$ 之间，下面分几种情况讨论：

1. 当 $\vec{v_1},\vec{v_2}$ 均在直线 $y=x$ 下面或直线上时，应当进行操作二（左乘 $M_2$），若进行操作一，那么 $\vec{v_1},\vec{v_2}$ 将同时变得不可操作，此时漏掉向量的区域就会在 $\vec{v_2}$ 上方。
2. 当 $\vec{v_1},\vec{v_2}$ 均不在直线 $y=x$ 下面或直线上时，应当进行操作一（左乘 $M_1$），若进行操作二，那就又回到了情况 1，但是情况 1 又只能再翻回来。
3. 当 $\vec{v_1},\vec{v_2}$ 中有恰好一个向量在 $y=x$ 直线下面或直线上时，只要进行操作一，那么就会使一个向量变得不可操作，所以我们要讨论一下操作一之前是否需要做一次操作二。假设不可操作的向量是 $\vec{v_1}$，我们做完操作一（这时使 $\vec{v_1}$ 不可操作）后再进行一次操作二，最后做若干次操作一使得 $\vec{v_2}$ 变得不可操作。注意这个时候我们让 $\vec{v_1}$ 不可操作后不能继续接着进行操作一，因为我们的目的是让漏掉向量的区域在这两个向量之间，所以我们必须先翻转，再进行操作一让 $\vec{v_2}$ 不可操作。这一步就是在原来的序列上左乘 $M_1^{t_1}M_2M_1$ 或者 $M_1^{t_2}M_2M_1M_2$，其中 $t_1,t_2$ 是这种情况下让 $\vec{v_2}$ 不可操作的进行操作 1 的最小次数。

我们对每对相邻向量都进行这些讨论，最后选取花费最少的方案即可，时间复杂度是 $O(n(a+b))$。现在的瓶颈在于情况 2 可能会重复很多遍，所以我们可以直接算出来需要进行多少次，然后一遍完成。因为操作 3 只会进行一次，操作 1 和操作 2 实际上就是辗转相除法，所以最后的时间复杂度是 $O(n\log\min(a,b))$。在实现时可以直接在原向量上修改，不需要使用矩阵，这里用矩阵说明只是为了便于理解。

代码如下：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
struct pt
{
	int a,b;
}c[100005];
int n;
ll ans,p,q;
bool cmp(const pt x,const pt y)
{
	return 1ll*x.a*y.b>1ll*y.a*x.b;  //使用叉积可以避免浮点运算 
}
int main()
{
	scanf("%d%lld%lld",&n,&p,&q);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&c[i].a,&c[i].b);
	sort(c+1,c+n+1,cmp);
	ans=min(1ll*(c[n].b+c[n].a-1)/c[n].a*p,1ll*(c[1].a+c[1].b-1)/c[1].b*p+q); //特判 
	for(int i=1;i<n;i++)
	{
		pt u=c[i],v=c[i+1];
		if(1ll*u.a*v.b==1ll*v.a*u.b) continue;
		ll nw=0;
		while(1)
		{
			if(u.a>=u.b&&v.a>=v.b)  //case 1 
			{
				swap(u.a,u.b),swap(v.a,v.b);
				nw+=q;
			}
			else if(u.a<u.b&&v.a<v.b)  //case 2 
			{
				int ct=min((u.b-1)/u.a,(v.b-1)/v.a);
				u.b-=ct*u.a,v.b-=ct*v.a;
				nw+=ct*p;
			}
			else  //case 3 
			{
				if(u.a>=u.b) swap(u,v);
				ll nw1=0,nw2=0;
				pt w=u;
				w.b-=w.a;
				nw1=q+p+1ll*(w.a+w.b-1)/w.b*p;  //case 3.1
				if(v.a>v.b)
				{
					w=v;
					swap(w.a,w.b);
					w.b-=w.a;
					nw2=p+q*2+1ll*(w.a+w.b-1)/w.b*p;  //case 3.2
					nw1=min(nw1,nw2);
				}
				nw+=nw1;
				break;
			}
		}
		ans=min(ans,nw);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：徐哲安 (赞：9)

观察操作的过程，发现每一次就是把平面砍了一半。

极角排序后，最后剩下的区间一定是在两个相邻点之间。接下来只需要考虑这两个点，称作 A 和 B（A 极角序更小）。

如果 A,B 都在平面的一侧，那么唯一决策就是不断砍平面，除法求出要砍几次。

否则就在 $x=y$ 直线的两侧。如果砍了一半，那么剩下一半的决策就是唯一的。

复杂度分析辗转相除一样，就是 $O(n \log V)$。

不是很懂为什么标算要 Tire 。。

```cpp
ll solve(int a,int b,int c,int d){
	ll ans=0;
	for(int t=0;b>0||c>0;){
		if(b<=0){
			ans+=(!t)*p+(c+d-1)/d*q;
			break;
		}
		if(c<=0){
			ans+=t*p+(b+a-1)/a*q;
			break;
		}
		if(b<a&&d<c){
			int k=min(a/b,c/d);
			ans+=(!t)*p+k*q;
			a-=k*b,c-=k*d,t=1;
			continue;
		}
		if(a<b&&c<d){
			int k=min(b/a,d/c);
			ans+=t*p+k*q;
			b-=k*a,d-=k*c,t=0;
			continue;
		}
		int C=c,D=d-c;
		ll CD=(D?p+p*t+q+(C+D-1)/D*q:inf);
		int A=a-b,B=b;
		ll AB=(A?p+p*(!t)+q+(B+A-1)/A*q:inf);
		ans+=min(AB,CD);
		break;
	}
	return ans;
}
```


---

## 作者：LCuter (赞：9)

## E - Quark and Game

##### $\text{Description}$

给定 $n$ 个二元组形如 $(a_i,b_i)$ ，你可以进行两个操作：

1. 对于所有 $b_i>0$ 的二元组，执行 $b_i\gets b_i-a_i$，花费 $p$。
2. 对于所有 $b_i>0$ 的二元组，执行 $\operatorname{Swap}(a_i,b_i)$，花费 $q$。

求一个花费最少的操作方法，使得所有二元组的 $b_i\le 0$。 

##### $\text{Solution}$

最优操作序列不会出现连续的交换操作。

最优操作序列一定是若干个不连续的交换操作将攻击操作划分，故我们将一个合法的操作序列写作若干个非负整数的序列，表示每次连续攻击操作包含的次数，特别地，若一开始就进行交换操作，则序列的第一位为 $0$。

通过辗转相除法得到的操作序列一定是在排除了连续交换操作的情况下**次数最多**的操作序列。

考虑将一个二元组 $(a,b)$ 写成序列，定义如下：

1. 当 $a=b$ 时，终止递归。
2. 否则，该二元组的序列是 $\lfloor\frac{b-1}{a}\rfloor$ 的末尾接上 $(b-a\lfloor\frac{b-1}{a}\rfloor,a)$ 的序列。

进一步地，我们得到 $n$ 个序列，将其建 Trie。

考虑如何枚举可能的最优序列。

我们发现可以通过枚举 Trie 上的节点 $pos$ ，它的含义是存在一个序列的 $[1,dep_{pos}]$ 与我们所枚举的操作序列的 $[1,dep_{pos}]$ 相等，且下一位不相等。体现在 Trie 上，就意味着我们走到了点 $pos$ 上。

考虑下一步要进行的攻击次数 $x$，为了保证不相等，所以 $x$ 不能与当前节点任意儿子相同。记 $max$ 表示当前节点所有儿子的权值最大值，则发现当 $x>max$ 时只需 $max+1$ 次就能解决所有还活着的。那 $x<max$ 时呢？我们发现此时对于权值小于 $x$ 的点（它是一个二元组的一个操作序列的某一个位置），它被攻击 $x$ 次后会死亡，其它活着的点，因为 $x$ 不和他们的权值相同，所以他们还剩两下才会被攻击死，故有 $a_i<b_i$，交换后只需一次攻击即可。那么令 $mex$ 是最小的**正整数**，且它不是任意一个儿子的权值，可以证明 $mex$ 是比其它 $x<max$ 的操作优的。

从而促使我们设计一个 Trie 上的 DP。初始时我们在树根，表示一个空的操作。每次我们有三种选择：

1. 攻击 $max+1$ 次
2. 攻击 $mex$ 次，交换，攻击 $1$ 次
3. 选择一个儿子，直接进入

这边要感性证明一个东西，我们选择一个儿子进入后，会让其它权值小于这个儿子的权值的儿子死亡，而权值大于这个儿子的儿子则会在交换后一遍攻击致死，从而我们只需关心这个儿子的子树。

显然这个做法的时间复杂度就是 Trie 的点数，但是这里由于字符集过大，我们可以用平衡树去维护儿子（当然也可以用 map，2s 时限就是给 map 开的）。考虑辗转相除得到的序列长度是 $O(\log \min(a,b))$ 的，故 Trie 上的点数至多为 $O(n \log \min (a,b))$，时间复杂度为 $O(n\log n\log\min(a,b))$。

---


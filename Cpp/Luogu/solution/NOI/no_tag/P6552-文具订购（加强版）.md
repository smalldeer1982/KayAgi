# 文具订购（加强版）

## 题目背景

感谢@肖然 的创意以及@Elegia @dengyaotriangle 对算法复杂度论证做出的贡献（我只是搬题的

## 题目描述

小明的班上共有 $n$ 元班费，同学们准备使用班费集体购买 $3$ 种物品：

1. 圆规，每个 $x$ 元。
2. 笔，每支 $y$ 元。
3. 笔记本，每本 $z$ 元。

小明负责订购文具，设圆规，笔，笔记本的订购数量分别为 $a,b,c$，他订购的原则依次如下：

1. $n$ 元钱必须正好用光，即 $ax+by+cz=n$。
2. 在满足以上条件情况下，成套的数量尽可能大，即 $a,b,c$ 中的最小值尽可能大。
3. 在满足以上条件情况下，物品的总数尽可能大，即 $a+b+c$ 尽可能大。

请你帮助小明求出满足条件的最优方案。数据保证 $x>y>z$。若有多组解，应输出 $(a, b, c)$ 字典序最小的答案。

## 说明/提示

对于全部的测试点，$1\leq T\leq 100$，$0\leq n\leq 10^9 $ ，$1\leq z<y<x\leq 10^9$

## 样例 #1

### 输入

```
3
33 7 4 3
81 39 37 7
227200291 189101 133029 52503```

### 输出

```
1 2 6
1 0 6
446 845 580```

# 题解

## 作者：Crabby_Maskiv (赞：9)

首先给出一个暴力的做法

枚举$\ a\ b\ c\ $中的最小值 $t$ ，设 $r=n-t(x+y+z)$，使用拓展欧几里得将 $r$ 表示成 $x,y$ 或 $y,z$ 或 $x,z$ 的线性组合，如果能够做到二者的系数非负，则表示找到了解。此时为了满足条件3，应该将较大的变量对应的系数最小化，然后拿来更新答案。

由于三组exgcd都可以拿到循环外面做，因此复杂度 $O(\frac{n}{x+y+z})$

我们再添加一个看起来是优化常数的东西：

从大到小枚举 $t$ ，显然在条件2的约束下，如果找到了解应该直接break。

然后再特判根本没有整数解的情况，根据贝祖定理，就是 $gcd(x,y,z)\nmid n$

你会发现，这份代码神奇地通过了本题。

为什么呢？为了证明复杂度，我们需要回想一下 P3951小凯的疑惑 的结论

### 对于两个互质的正整数 $a,b$ ，$ax+by\ (x,y\in N)$ 最大的不能表示的数是 $ab-a-b$

也就是说，假设三个数两两互质，对应到这道题上，当 $r\geq min(xy-x-y,yz-y-z,xz-x-z)$ 时一定能找到解

也就是说我们的复杂度变成了$O(\frac{min(n,xy,yz,xz)}{x+y+z})$

这有啥用呢？

当 $xy,yz,xz$ 中全都 $\geq n$ 时，一定有 $x+y+z\geq \sqrt{n}$，因此复杂度是 $O(\sqrt n)$

否则，不妨假设 $min(xy,yz,xz)$ $=xy$，$\frac{xy}{x+y+z}\leq \frac{xy}{x+y} \leq \frac{\sqrt{xy}}{2}$，复杂度还是 $O(\sqrt n)$

那么如果除去三个数两两互质的情况，如何证明复杂度？

我们需要对上面的结论做一个比较显然的变换

## 对于两个正整数 $a,b$ ，$ax+by\ (x,y\in N)$ 最大的不能表示的 $gcd(a,b)$ 的倍数是 $\frac{ab}{gcd(a,b)}-a-b$

我们发现，找到解所需的 $r$ 的上界量级并没有增加，只不过多了一个限制：$gcd(x,y)\mid r$（这里只考虑求 $x,y$ 的线性组合，其他的同理）

我们把$r=n-t(x+y+z)$带入一通分析，得到 $tz\equiv n\ \rm mod$ $gcd(x,y)$

这是个线性方程组，解完之后大概形如$t\equiv t_0\ \rm mod$ $\frac{gcd(x,y)}{gcd(x,y,z)}$

由于这个 $t$ 是我们枚举的，这说明了在 $r\geq \frac{xy}{gcd(x,y)}-x-y$ 之后我们至多再枚举 $\frac{gcd(x,y)}{gcd(x,y,z)}$ 次，这个数肯定 $\leq min(x,y)$，进而在 $xy\leq n$ 时在 $\sqrt{n}$ 以内。将其代入刚才的复杂度论证的第二种情况，得到复杂度还是$O(\sqrt n)$的。

特别注意，做法中特判无解正好对应了关于 $t$ 的线性方程无解的情况，这时循环次数就成了严格$\frac{n}{x+y+z}$次。不判是会超时的。

综上这题复杂度 $O(\sqrt{n})$


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=200005;
ll d;
pair<ll,ll> exgcd(ll a,ll b){
	if(!b){
		d=a;
		return {1,0};
	}
	pair<ll,ll> ret,ans=exgcd(b,a%b);
	ret.first=ans.second;
	ret.second=ans.first-(a/b)*ans.second;
	return ret;
}
ll ansa,ansb,ansc;
void upd(ll a,ll b,ll c){
	if(a+b+c>ansa+ansb+ansc){
		ansa=a;ansb=b;ansc=c;
	}
}
ll n,x,y,z;
pair<ll,ll> w1,w2,w3;
ll d1,d2,d3;
int main(){
	int i,j;
	int T;cin>>T;
	while(T--){
		cin>>n>>x>>y>>z;
		exgcd(x,y);exgcd(z,d);
		if(n%d){
			cout<<-1<<endl;
			continue;
		}
		ll t;ansa=ansb=ansc=0;
		w1=exgcd(x,y);d1=d;
		w2=exgcd(y,z);d2=d;
		w3=exgcd(x,z);d3=d;
		for(t=n/(x+y+z);t>=0;t--){
			ll r=n-t*(x+y+z);
			ll _x=w1.first,_y=w1.second;d=d1;
			if(r%d==0){
				_x*=(r/d);
				_x=(_x%(y/d)+(y/d))%(y/d);
				_y=(r-_x*x)/y;
				if(_y>=0) upd(t+_x,t+_y,t);
			}
			_x=w2.first;_y=w2.second;d=d2;
			if(r%d==0){
				_x*=(r/d);
				_x=(_x%(z/d)+(z/d))%(z/d);
				_y=(r-_x*y)/z;
				if(_y>=0) upd(t,t+_x,t+_y);
			}
			_x=w3.first;_y=w3.second;d=d3;
			if(r%d==0){
				_x*=(r/d);
				_x=(_x%(z/d)+(z/d))%(z/d);
				_y=(r-_x*x)/z;
				if(_y>=0) upd(t+_x,t,t+_y);
			}
			if(ansa*x+ansb*y+ansc*z==n){
				cout<<ansa<<" "<<ansb<<" "<<ansc<<endl;
				break;
			}
		}
		if(t<0)
			cout<<-1<<endl;
	}
	return 0;
}
```


upd：[这篇文章](https://www.luogu.com.cn/blog/dengyaotriangle/noi-online-1-ru-men-zu-wen-ju-ding-gou-ti-xie-wu-post)中介绍了一种基于类欧几里得的$O(log^2n)$的做法

---

## 作者：dengyaotriangle (赞：2)

本题的目标是求

$$ ax+by+cz=n $$

的一组 $x,y,z\in\mathbb{N}$ 的，满足 $\min\{x,y,z\}$ 最大的同时 $x+y+z$ 最大的解，保证 $a>b>c$

首先是第一个做法，从大到小枚举 $\min\{x,y,z\}=m$，令 $x'=x-m$，$y'=y-m$，$z'=z-m$，$n'=n-(a+b+c)m$，

那么 $x',y',z'$ 中肯定至少有一个为 $0$，此时只需要枚举为 $0$ 的那个（这里假设是 $c$），转化为求 $ax'+by'=n'$ 的 $x'+y'$ 最大的解，根据数学常识，我们显然要让系数大的那个尽量小，假设 $a>b$，我们要求 $x'\geq 0$ 的最小 $x'$ ，这显然来一发紧张刺激的exgcd就可以了。

如果无解，就继续枚举，有解，就输出。

但这么做我好像证明不出来什么好的复杂度，所以我们稍微优化一下

假设最优解中 $x'=0$ （其它的如法炮制取max），那么我们有 $by'+cz'=n'=n-(a+b+c)m$，根据裴蜀定理，$\{by'+cz'\mid y',z'\in\mathbb{Z}_+\}\subset \{k(b,c)\mid k\in \mathbb{Z}\}$，就是说如果 $by'+cz'=n'=n-(a+b+c)m$，那么一定存在 $ k\in \mathbb{Z}$ 使得 $k(b,c)=n-(a+b+c)m$。然后我们惊奇地发现，这样就可以 exgcd 解出所有可能合法的 $m$ 的通解（形如 $m=m_0+\lambda\dfrac{(b,c)}{(a,b,c)}$）的东西

然后我们发现，当 $m$ 符合上面的通解，且当 $n'>bc-b-c$ 时 一定有解，这是因为上面的 $m$ 通解保证了有整数解，而正整数解则是由小凯的疑惑的结论：当 $n'>bc-b-c$ 时一定可以找到。

所以我们发现，我们 $n'$ 只需要枚举到 $\min\{n,bc\}$，而一次枚举至少多 $a+b+c$，则一共枚举 $\dfrac{\min\{n,bc\}}{a+b+c}$ 次

注意不用每次都exgcd，exgcd的结果可以在外面预处理，所以可以少个log

我们称这样做是 $\mathcal{O}(\sqrt{n})$ 的

证明：

$n>bc$ 时，$\dfrac{\min\{n,bc\}}{a+b+c}=\dfrac{bc}{a+b+c}<\dfrac{bc}{b+c}\leq \dfrac{bc}{2\sqrt{bc}}=\dfrac12\sqrt{bc}<\dfrac12\sqrt{n}=\mathcal{O}(\sqrt{n})$

$n\leq bc$ 时，$\dfrac{\min\{n,bc\}}{a+b+c}=\dfrac{n}{a+b+c}<\dfrac{n}{b+c}\leq \dfrac{n}{2\sqrt{bc}}\leq \dfrac{n}{2\sqrt{n}}=\dfrac12\sqrt{n}=\mathcal{O}(\sqrt{n})$

那能不能做到更快呢！

首先我们弱化一下，看看怎么求它有没有解

如果我们会判断它是否有解，那么我们考虑判断是否可以有 $\min\{x,y,z\}=m\geq A$，这个显然你强制先拿 $A$ 个在判断是否有解即可，这个显然满足二分性，故就可以二分出最大的 $m$

求出了这个，那么令 $x'=x-m$，$y'=y-m$，$z'=z-m$，$n'=n-(a+b+c)m$（最大时）

接下来就和第一个做法那里所说的一样了

如上所述，如果我们会判定是否有解，那么我们可以较为轻松地得到答案。

那么如何判定呢？

首先假设 $(a,b,c)\mid n$ ，否则无解

其实就是推式子

我们先令一些东西，$u=(a,b),v=(u,c)$，以及 $p,q\in \mathbb{Z}$

首先exgcd出一组 $x_0,y_0$ 有 $ax_0+by_0=u$

那么方程 $ax+by=tu$ 的通解是

$x=tx_0+p\dfrac{b}u$，$y=ty_0-p\dfrac{a}u$

然后在exgcd出一组 $t_0,z_0$ 有 $ut+cz=v$

那么方程 $ut+cz=n$ 的通解是

$t=\dfrac{n}vt_0+q\dfrac{c}v$，$z=\dfrac{n}vz_0-q\dfrac{u}v$

那么开心地二式相加得 $ax+by+cz=n$ 的通解是

$$x=\left(\dfrac{n}vt_0+q\dfrac{c}v\right)x_0+p\dfrac{b}u$$
$$y=\left(\dfrac{n}vt_0+q\dfrac{c}v\right)y_0-p\dfrac{a}u$$
$$z=\dfrac{n}vz_0-q\dfrac{u}v$$

好，那么现在我们要求 $x,y,z\geq 0$

那简单，列方程即可

$$
\begin{cases}
nut_0x_0+cux_0q+bvp\geq 0 & \\& \\
nut_0y_0+cuy_0q-avp\geq 0 & \\& \\
nz_0-uq\geq 0 & \\

\end{cases}
$$

然后，你发现，如果以 $p,q$ 为坐标轴建立平面直角坐标系，你会惊奇地发现这其实就是围成了某种区域（当然有可能根本不存在）

然后任务就是寻找区域中有没有整点，因为 $p,q\in \mathbb{Z}$

我们把 $q$ 看成横坐标， $p$ 看成纵坐标

然后我们根据一些东西，发现第一个方程的区域那条线上边的所有，第二个方程是下边的所有，第三个是右面的所有（且平行与坐标轴）

然后，其实可以转化为数两个梯形中整点个数是不是一样的问题

然后你发现 梯形内整点个数 这个问题是一个类欧几里得算法的模板题

然后总复杂度 $\mathcal{O}(\log^2n)$

然后你写着写着代码就会发现不太行，因为这个东西它好像 $n=10^9$ 都需要高精度...反正我不想写

---

## 作者：farfarqwq (赞：1)

我们北大附中真是太有科研了！题目质量也很好呢！

调了好久终于通过看眼题解发现直接暴力就对了，于是一气之下给我校传统文化喂一坨不用证复杂度的数据点分治做法。

## Solution

考虑一种枚举 $\min(a,b,c)=r$ 的暴力，假设 $r=a$，变成 $y(b-r)+z(c-r)=n-r(x+y+z)$，$r=b/c$ 也差不多。

由于 $x>y>z$，exgcd 取 $b$ 的最小非负整数解能同时满足 $x+y+z$ 最大，更新答案即可。

这个玩意的复杂度是 $O(\frac n{x+y+z})$ 的，$x+y+z$ 特别大我们就直接暴力。现在我们考虑 $x+y+z$ 比较小的情况。

发现如果我们能知道 $r$ 到底是多少或者无解，我们就可以 $O(1)$ 求出答案（exgcd 一开始做三遍就行）。

考虑二分答案，使用同余最短路判断 $r$ 是否大于 $mid$。

同余最短路可以使用[转两圈算法](https://www.luogu.com.cn/problem/solution/P9140)变成 $O(z)$。而且只需要开始做一遍，后面只需要判断 $dis_{(n-mid(x+y+z)) \% z} \le n-mid(x+y+z)$ 就行。

阈值设成 $\sqrt n$ 就可以做到时间复杂度 $O(\sqrt n)$。

## Code

使用了特别蠢的枚举 $a$ 的暴力，建议不要学习。

```cpp
#include <bits/stdc++.h>
using namespace std;
using fastio::IN;
using fastio::OUT;
IN fin;
OUT fout;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
const int N = 40005, B = 4e4, mod = 1e9 + 7;
int exgcd(int a, int b, int &x, int &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
int rx, ry, rz;
int A, tp;
inline void upd(int b, int c) {
    int x, y, z;
    if (tp == 0)
        x = A, y = b, z = c;
    else if (tp == 1)
        x = b, y = A, z = c;
    else
        x = b, y = c, z = A;
    if (x < 0 || y < 0 || z < 0)
        return ;
    int mr = min({rx, ry, rz}), mx = min({x, y, z});
    if (mx > mr)
        rx = x, ry = y, rz = z;
    else if (mx == mr) {
        int sx = x + y + z, sr = rx + ry + rz;
        if (sx > sr || sx == sr && x < rx)
            rx = x, ry = y, rz = z;
    }
}
inline void chk(int y, int z, int n, int g, int bx, int by) {
    if (n % g)
        return;
    ll cc = n / g;
    int bs = z / g;
    int b = (bx * cc % bs + bs) % bs, c = (n - 1ll * b * y) / z;
    if (c < 0)
        return;
    ll k = 1ll * g * (c - b) / (y + z);
    upd(b + bs * k, c - (y / g) * k);
    ++k;
    upd(b + bs * k, c - (y / g) * k);
    k = (A > b ? (A - b - 1) / bs + 1 : 0);
    upd(b + bs * k, c - (y / g) * k);
}
ll dis[N];
void work() {
    int n, x, y, z;
    fin >> n >> x >> y >> z;
    rx = -1, ry = -1, rz = -1;
    if (x > B) {
        int bx, cx, g = exgcd(y, z, bx, cx);
        tp = 0;
        for (A = 0; n >= 0; n -= x, A++)
            chk(y, z, n, g, bx, cx);
    } else {
        memset(dis, 0x3f, sizeof(dis));
        dis[0] = 0;
        int a1, a2, b1, b2, c1, c2;
        int ga = exgcd(y, z, a1, a2), gb = exgcd(x, z, b1, b2), gc = exgcd(x, y, c1, c2);
        for (int s = 0; s < ga; s++)
            for (int c = 0, i = s; c < 2; i = (i + y) % z, c += (i == s))
                dis[(i + y) % z] = min(dis[(i + y) % z], dis[i] + y);
        for (int s = 0; s < gb; s++)
            for (int c = 0, i = s; c < 2; i = (i + x) % z, c += (i == s))
                dis[(i + x) % z] = min(dis[(i + x) % z], dis[i] + x);
        ll s = x + y + z;
        int l = 0, r = n / s;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (dis[(n - mid * s) % z] <= n - mid * s)
                l = mid + 1;
            else
                r = mid - 1;
        }
        A = r;
        tp = 0;
        chk(y, z, n - r * x, ga, a1, a2);
        tp = 1;
        chk(x, z, n - r * y, gb, b1, b2);
        tp = 2;
        chk(x, y, n - r * z, gc, c1, c2);
    }
    if (rx >= 0)
        fout << rx << ' ' << ry << ' ' << rz << '\n';
    else
        fout << "-1\n";
    // 记得清空！！！
}
int main() {
    int T;
    fin >> T;
    while (T--)
        work();
    return 0;
}
```

---


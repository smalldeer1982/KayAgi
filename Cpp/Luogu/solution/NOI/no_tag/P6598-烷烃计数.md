# 烷烃计数

## 题目描述

$n$ 个碳原子的烷烃共有多少种同分异构体（不考虑立体异构）？

提示：如果你不知道什么是烷烃，那么你可以认为这个问题等价于求 $n$ 个点的无标号无根树并满足每个点的度数 $\le 4$ 的树的个数。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l8x7ct53.png)

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^5$。

## 样例 #1

### 输入

```
5```

### 输出

```
3```

# 题解

## 作者：9AC8E2 (赞：16)

感觉这题比[烯烃计数](https://www.luogu.com.cn/problem/P6597)难一点啊

前置知识:[烷基计数](https://loj.ac/problem/6538)

## 烷烃计数

已知碳原子个数 $n$，求对应的烷烃有多少种同分异构体

不考虑空间异构

### 题解

就是 $n$ 个点的每个点的度数个数 $\leq 4$ 的无标号无根树计数

参考[博客](https://blog.csdn.net/qq_35950004/article/details/105228566)

无标号无根数还是很难做,考虑怎么做成除根节点外每个点的子节点个数 $\leq 3$,根节点的子节点个数 $\leq 4$ 的无标号有根树计数

>考虑对于一棵无根树,设枚举一个点为关键点,整棵树的点等价类数为 $p$ ,枚举一条边为关键边,整棵树的边等价类数为 $q$,设 $s=1$ 当且仅当有两个重心且两个重心等价,那么有 $p-q+s=1$

$s=0$ 时,考虑除重心外的每个点与其父亲边(以重心为根)的贡献.若两个点等价,那么这两个点的父亲边(以重心为根)也等价,所以除重心外的贡献为 $0$

对于重心,它不可能与其他任何一个点等价,所以贡献为 $1$

$s=1$ 时,因为两个重心等价,所以 $p-q=-1$

这样,对于每棵无标号无根树用 $p-q+s$ 统计答案即可做到不重不漏

对于 $\sum p,\sum q,\sum s$ 分别统计答案

#### $\sum p$

枚举无标号无根树并统计点等价类,将每个点作为根,就相当于求无标号有根树

即相当于除根节点外每个点的子节点个数 $\leq 3$,根节点的子节点个数 $\leq 4$ 的无标号有根树计数

除根外的节点的子节点个数 $\leq3$ ,即相当于前面做过的烷基计数

设烷基计数的 $OGF$ 为 $A(x)$

对根节点再做一遍 $Burnside$,设 $\sum p$ 的 $OGF$ 为 $P(x)$

一共有 $4!=24$ 种置换,分类讨论即可

$$p_{x+1}=\frac{\sum_{i_i+i_2+i_3+i_4=x}a_{i_1}a_{i_2}a_{i_3}a_{i_4}+6\sum_{2i_1+i_2+i_3=x}a_{i_1}a_{i_2}a_{i_3}+3\sum_{2i_1+2i_2=x}a_{i_1}a_{i_2}+8\sum_{3i_1+i_2=x}a_{i_1}a_{i_2}+6\sum_{4i_1=x}a_{i_1}}{24}$$

$$P(x)=x\frac{A^4(x)+6A(x^2)A^2(x)+3A(x^2)^2+8A(x^3)A(x)+6A(x^4)}{24}$$

#### $\sum q$

就是求两个无标号有根树的根连起来后的不同构方案数

设答案的 $OGF$ 为 $Q(x)$

$$Q(x)=\frac{(A(x)-1)^2+A(x^2)-1}{2}$$

$-1$ 是因为 $0$ 个点并不能被计入方案

#### $\sum s$

设答案的 $OGF$ 为 $S(x)$

$$S(x)=A(x^2)$$

那么答案就是 $P(x)-Q(x)+S(x)$

[代码](https://www.luogu.com.cn/paste/sp5ibubj)

---

## 作者：苹果蓝17 (赞：6)


[题目传送门](https://www.luogu.com.cn/problem/P6598)

[更好的阅读体验](https://www.cnblogs.com/Appleblue17/p/14440722.html)

[我的生成函数博客（含有此题，与本题解略有不同）](https://www.cnblogs.com/Appleblue17/p/14337965.html)

#### 题意简述

+ 求 $n$ 个碳原子对应的烷烃的同分异构体数量。
+ $n \leq 10^5$，答案对 $998244353$ 取模。
+ Tips：即求所有节点度数不超过 $4$ 的无标号无根树数量。

#### 题目分析

前置知识：[烷基计数](https://loj.ac/p/6538)。

设烷基计数的生成函数为 $F(x)$。

烷基计数是无标号有根树，需要去重。

还是用无标号无根树计数的处理方法：**钦定根为重心，减掉不合法的方案数**。

***

**总数**

总数并不是 $f_n$，因为根节点允许有四个儿子。

其实只要特别考虑根节点就可以了，设所有节点度数不超过 $4$ 的无标号无根树的生成函数为 $P(x)$。

跟烯烃计数一样，使用 `Burnside` 引理和 `Polya` 定理（括号里的数字代表每个循环的大小）：

+ $(1,1,1,1)$：$F^4(x)$，共有 $1$ 种。
+ $(1,1,2)$：$F^2(x)F(x^2)$，共有 $6$ 种。
+ $(1,3)$：$F(x)F(x^3)$，共有 $8$ 种。
+ $(2,2)$：$F^2(x^2)$，共有 $3$ 种。
+ $(4)$：$F(x^4)$，共有 $6$ 种。

$$P(x)=x\dfrac{F^4(x)+6F^2(x)F(x^2)+8F(x)F(x^3)+3F^2(x^2)+6F(x^4)}{24}$$

***

**去重**

接下来考虑去重，惊喜地发现：

+ 砍掉的那一棵子树的根节点的儿子个数一定不超过 $3$。
+ 剩下的子树的根节点（就是原树的根节点）的儿子个数也一定不超过 $3$（因为已经砍掉一棵了）。

然后直接拿 $F(x)$ 去重即可。

$$ans=p_n-\sum\limits_{k=\lfloor\frac{n}{2}\rfloor+1}^{n-1} f_kf_{n-k}-[2|n]C_{f_{\lfloor\frac{n}{2}\rfloor}}^2$$

时间复杂度 $O(nlogn)$。

***

#### 代码

很丑陋的代码……

```cpp
int main(){
	NTT::pre();
	cin>>n;
	solve();
	for(long long i=0;i<=n;i++) SS[i]=S2[i*2]=S22[i*2]=S3[i*3]=S4[i*4]=S[i];
	
	NTT::solve(SS,SS,S,n,n);
	NTT::solve(SS,SS,S,n,n);
	NTT::solve(SS,SS,S,n,n);
	
	NTT::solve(S2,S2,S,n,n);
	NTT::solve(S2,S2,S,n,n);
	
	NTT::solve(S22,S22,S22,n,n);
	
	NTT::solve(S3,S3,S,n,n);
	
	anss=(SS[n-1]+S2[n-1]*6%mod+S22[n-1]*3%mod+S3[n-1]*8%mod+S4[n-1]*6%mod)%mod*ksm(24,mod-2)%mod;
	for(long long i=n/2+1;i<n;i++) anss=(anss+mod-S[i]*S[n-i]%mod)%mod; 
	if(n%2==0) anss=(anss+mod-S[n/2]*(S[n/2]-1)/2%mod)%mod;
	cout<<anss;
}
```

[完整代码](https://www.luogu.com.cn/record/47006178)

---

## 作者：zhylj (赞：5)

怎么没有符号化方法的题解。

先考虑烷基计数。

记烷基构成的组合类为 $\mathcal B$，则有 $\mathcal B = \mathcal Z\times \mathsf {MSET}_{\le 3}(\mathcal B)$，此处 $\mathsf {MSET}$ 表示 Multiset 变换，表示取若干个 $\mathcal B$ 中元素构成可重集的方案，而 $\le 3$ 表示不能取超过 $3$ 个，即一个烷基相当于一个根加上不超过 $3$ 个烷基构成的可重集。

在无标号有根树计数中，我们是由如下式子得到无限制的 Multiset 变换的式子的（相当于多重背包）：
$$
\mathcal A =\mathsf {MSET}(\mathcal B)\implies A(z)=\prod_{\beta\in\mathcal B} \frac 1{1-z^{|\beta|}}=\prod_{j=1}^{\infty} \frac 1{(1-z^j)^{B_j}}
$$
而如何加上限制呢？一个方法是考虑二元生成函数 $A(z,u)$，其中 $u$ 的次数代表了使用了多少个 $\mathcal B$ 中的元素。
$$
\mathcal A =\mathsf {MSET}_{=k}(\mathcal B)\implies A(z)=[u^k]\prod_{\beta\in\mathcal B} \frac 1{1-uz^{|\beta|}}=[u^k]\prod_{j=1}^{\infty} \frac 1{(1-uz^j)^{B_j}}
$$
如何推导 $A(z,u)$ 使得我们的结果更好计算呢？我们可以对两侧同时取 $\ln$ 后再处理，即：
$$
\begin{aligned}
A(z,u) &= \exp\left(\sum_{j=1}^{\infty}\sum_{k=1}^{\infty}\frac{u^kz^{jk}B_j}{k}\right)\\
& = \exp \left(\sum_{k=1}^{\infty}\frac{u^kB(z^k)}{k}\right)
\end{aligned}
$$
对于取的个数有限的情况，对答案有贡献的项数也是有限的，我们可以直接展开进行计算，例如假如我们要求 $[u^2]A(z,u)$，则我们只需计算：
$$
[u^2]\exp\left(uB(z) + \frac 12u^2B(z^2)\right) = [u^2]\left(1 + \frac 1{1!}\left(uB(z)+\frac 12u^2B(z^2)\right) + \frac 1{2!}u^2B^2(z)\right)
$$
而烷基的式子即 $B(z)=z\operatorname{Exp}_{\le 3}( B(z))$，经过一些计算可以得到：
$$
\operatorname{Exp}_{\le 3}(B(z)) = 1 + B(z) + \frac{B(z^2)}2 + \frac {B^2(z)}2+\frac{B(z^3)}3+\frac {B(z)B(z^2)}2 + \frac {B^3(z)}6
$$
然后我们相当于要解方程：
$$
\frac {B(z)}z = 1 + B(z) + \frac{B(z^2)}2 + \frac {B^2(z)}2+\frac{B(z^3)}3+\frac {B(z)B(z^2)}2 + \frac {B^3(z)}6
$$
展开来比对系数就有：
$$
\begin{aligned}
b_{n+1} = & [n=0] + b_n + [2\mid n]\frac {b_{n/2}}{2} + [3\mid n]\frac{b_{n/3}}3 \\
& +\frac 12\sum_{i=0}^nb_ib_{n-i}+
\frac 12\sum_{i=0}^nb_ib_{(n-i)/2}[2\mid (n-i)]\\
& + \frac 16\sum_{i=0}^n\sum_{j=0}^{n-i} b_ib_jb_{n-i-j}
\end{aligned}
$$
再记一个 $f_n = \sum_{i=0}^nb_ib_{n-i}$，大概就是一个全在线卷积的形式，分治 NTT 就好了。

然后考虑烷烃怎么计数。先考虑“有根烷烃”，也就是 $\mathcal A_r = \mathcal Z\times \mathsf {MSET}_{\le 4}(\mathcal B)$，即 $A_r(z) = z\operatorname{Exp}_{\le 4}(B(z))$，然后还是有根到无根的容斥，消去根不是重心的答案，并对偶数再处理一下两棵子树被重复计算的情况就好了。

式子是类似的，这边就不再赘述了。



---

## 作者：joke3579 (赞：5)

本题解采用[符号化](https://www.cnblogs.com/joke3579/p/symbolic_method.html)的方式推导。

要解决这个问题，首先需要解决烷基计数。设 $\mathcal T$ 为烷基的组合类，我们能写出

$$\mathcal T = \mathcal Z \times \text{MSET}_3(\mathcal T) + \mathcal E$$

也就是

$$T(z) = z\left(\frac{T(z)^3}{6} + \frac{T(z)T(z^2)}{2} + \frac{T(z^3)}{3}\right) + 1$$

我们可以应用牛顿迭代来做这个。设

$$G(T(z)) = z\left(\frac{T(z)^3}{6} + \frac{T(z)T(z^2)}{2} + \frac{T(z^3)}{3}\right) - T(z) + 1 = 0$$

由于我们希望从 $z^n$ 的截取得到 $z^{2n}$ 的截取，现在已知了 $\forall k > 1, \ T(z^k)$，因此不妨将式子中的 $T(z^k)$ 视作常数，记为 $C_k$。记 $G$ 函数对应的自变量为 $x$，$z$ 为与 $x$ 无关的常数，可以写出

$$G(x) = z\left(\frac{x^3}{6} + \frac{C_2x}{2} + \frac{C_3}{3}\right) - x + 1$$

从而

$$G'(x) = z\left(\frac{x^2}{2} + \frac{C_2}{2}\right) - 1$$

记已经得到的截取为 $T^*(z)$，需要得到的截取为 $T(z)$，根据牛顿迭代可以得到

$$T(z) = T^*(z) - \frac{z\left(T^*(z)^3 + 3C_2T^*(z) + 2C_3\right) - 6T^*(z)  + 6}{z\left(3T^*(z)^2 + 3C_2\right) - 6}$$

直接作即可。总时间复杂度 $O(n\log n)$。

无标号无根树不是很好计数，考虑钦定一些东西的情况。  
我们设一棵无标号无根树在钦定一个点为根时被计数了 $p$ 次，钦定一条边为根时被计数了 $q$ 次，钦定计数重心时 $s = 1$ 当且仅当重心有两个，则 $p - q + s = 1$。  
证明其实不难。$s = 0$ 时钦定边其实等于钦定了一个端点，需要这些端点彼此不同。容易发现被计数了 $n - (n - 1) + 0 = 1$ 次。$s = 1$ 时更好说了，这重心肯定是一条边的两个端点，这俩端点彼此等价，因此被计数了 $(n - 1) - (n - 1) + 1 = 1$ 次。

假设烷基的组合类是 $\mathcal T$，上面钦定三种信息时对应的组合类是 $\mathcal {P, Q, S}$，则有

$$\mathcal P = \mathcal Z\times \text{MSET}_4(\mathcal T) \qquad \mathcal Q = (\mathcal T - \mathcal E)^2 / \textbf G \qquad \mathcal S = \text{AMP}_2(\mathcal T)$$

$\mathcal P$ 繁而不难，略去。$\mathcal S$ 是 Amplification 构造，翻译就是 $T(z^2)$，性质显然。

对于 $\mathcal Q$，我们需要考虑将两棵树用一条边 $-$ 拼合。我们设元素 $a\in \mathcal Q$ 可以被拆解为 $\{t, -, t'\}$，其中 $t, t' \in \mathcal T$，为 $a$ 的两棵子树；并记 $a = (t, t')$。则我们定义等价关系 $\textbf G$：

$$a_1\textbf G a_2 \iff (t_1 = t_2 \land t'_1 = t'_2) \ \lor \ (t_1 = t'_2  \land  t'_1 = t_2)$$ 

也就是子树相同但是顺序不同的树在同一等价类中。

然后考虑翻译成生成函数的形式。可以发现，对于两棵子树不同的元素，乘方时它被计数了两次，因此需要除以 $2$；而两棵子树相同的元素只被计数了一次，我们可以先加入这一部分元素，再整体除以 $2$。加入的内容可以被符号化地写作 $\text{AMP}_2(\mathcal T) - \mathcal E$：新组合类里没有空元素，需要减去。也就是

$$Q(z) = \frac{(T(z) - 1)^2 + T(z^2) - 1}{2}$$

最后 $\mathcal P - \mathcal Q +\mathcal S$ 就是答案的组合类。

```cpp
poly newton(int n) {
    poly F(1, 1), A, B;
    for (int k = 2; k < (n << 1); k <<= 1) {
        F.resize(k);
        A = F.shiftvar(2), B = F.shiftvar(3);
        F = F - (((F * F * F + 3 * A * F + 2 * B) >> 1) - 6 * F + 6) * (3 * (( F * F + A ) >> 1) - 6).inv().resize(k);
    } return F;
}

poly MSET(poly F, int cnt) {
	if (cnt == 1) return F;
	if (cnt == 2) return ginv(2) * ( (F * F).split(F.degree()) + F.shiftvar(2) );
	if (cnt == 3) {
		poly F2 = (F * F).split(F.degree()), FS2 = F.shiftvar(2);
		return ginv(6) * ( F2 * F ).split(F.degree()) + ginv(2) * (F * FS2).split(F.degree()) + ginv(3) * F.shiftvar(3);
	} 
	if (cnt == 4) {
		poly F2 = (F * F).split(F.degree()), FS2 = F.shiftvar(2);
		return ginv(24) * (F2 * F2).split(F.degree()) + ginv(4) * (F2 * FS2).split(F.degree()) + ginv(3) * (F * F.shiftvar(3)).split(F.degree()) + ginv(8) * (FS2 * FS2).split(F.degree()) + ginv(4) * F.shiftvar(4);
	}
}

signed main() {
    cin >> n;
	poly A = newton(n);
	poly F = (MSET(A, 4) >> 1) - ginv(2) * (((A - 1) * (A - 1)).split(n + 1) + A.shiftvar(2) - 1 ) + A.shiftvar(2);
	cout << F[n] << '\n';
} 
```

---

## 作者：Zi_Gao (赞：4)

## 0x00 有机物

这就是你洛谷，[烯烃计数](https://www.luogu.com.cn/article/ia9aanpk)这篇题解过了，烷烃计数这篇没过。

不会化学？没关系哦，我也不会。本人在化学月考和期中考试中分别获得了 37/100 和 61/100 的成绩。你只需要知道：

1. 键：链接两个原子的东西，对应 OI 中的边。XY 键就是连接 X 原子和 Y 原子的键，可以同时链几根键，变成 XY 双键、三键等。
2. 碳原子：必须要连 $4$ 根键，不能连自己但是两个碳原子可以连多根键。
3. 氢原子：只能连 $1$ 根键。
4. 烷烃：每个碳原子都连了 $4$ 根键，所有的碳碳都是单键。实际上有环的也叫烷烃，但是这次我们只考虑链状烷烃，形态是 OI 里面的一棵树，那么烷烃的通式为 $C_{n}H_{2n+2}$。
5. 烷基：去掉一个碳的一个氢原子，烷基的通式为 $C_{n}H_{2n+1}$。
6. 烯烃：有一个碳碳双键，这两个碳原子又分别链接了两个烷基。
7. 同分异构体：有相同分子式，但是结构不同的有机物，对应 OI 中的无标号树同构问题。

## 0x01 烷基计数

想一下去掉了一个氢原子的那个碳给我们带来了什么？答案是，把一个无根树变成一个有根树。我们把这个有机物从这个没连接的碳键拎起来，那么这个无根树就变成了每个非叶子点都链接了三个儿子。

设 $F(x)$ 是答案的生成函数，考虑每次把三个儿子填进去的方案数，要考虑是否同构所以用 Burnside 引理。枚举 $6$ 种置换：

1. $(1,2,3)$：三个置换环，三个都任意，答案 $xF^3(x)+1$。
2. $(1,3,2),(2,1,3),(3,2,1)$：有两个儿子相同，一个任意，答案 $3(xF(x^2)F(x)+1)$。
3. $(2,3,1),(3,1,2)$：三个都相同，答案 $2(xF(x^3)+1)$。

全部加起来取平均数：

$$
F(x)=\frac{x}{6}(F^3(x)+3F(x^2)F(x)+2F(x^3))+1
$$

使用牛顿迭代求解，首先令

$$
G(x,F(x))=F(x)-\frac{x}{6}(F^3(x)+3F(x^2)F(x)+2F(x^3))-1
$$

那么已知 $G(x,F(x))\equiv 0 \pmod{x^n}$，那么可知：

$$
F_1=F(x)-\frac{G(x,F(x))}{\frac{\partial G}{\partial F(x)}G(x,F(x))} \bmod{x^{2n}}
$$

注意这里的求导是形势求导，把 $F(x)$ 当做变量求导，$F^3(x),F(x^2),F(x^3)$ 都当做常量，整理一下：

$$
\begin{align}
F_1&=F(x)-\frac{F(x)-\frac{x}{6}(F^3(x)+3F(x^2)F(x)+2F(x^3))-1}{1-\frac{x}{6}(3F^2(x)+3F(x^2))}\\
&=\frac{F(x)-\frac{x}{6}(3F^3(x)+3F(x^2)F(x))-F(x)+\frac{x}{6}(F^3(x)+3F(x^2)F(x)+2F(x^3))+1}{1-\frac{x}{6}(3F^2(x)+3F(x^2))}\\
&=\frac{1-\frac{x}{3}(F^3(x)-F(x^3))}{1-\frac{x}{2}(F^2(x)+F(x^2))}
\end{align}
$$

倍增迭代即可得到烷基计数的生成函数，我们记为 $A(x)$。

## 0x02 烯烃计数

从碳碳双键的地方把这个有机物拎起来，那么这两个碳原子再链接两个烷基就行，先用 Burnside 引理对一个碳原子进行计数：

$$
F(x)=x\frac{A^2(x)+A(x^2)}{2}
$$

继续用 Burnside 引理对两个碳原子进行计数：

$$
G(x)=\frac{F^2(x)+F(x^2)}{2}
$$

得到答案。

## 0x03 烷烃基数

把重心钦定为根变成一个有根树。实际上这里已经可以通过容斥方法，暴力卷一个式子来做了，但是这样太不优雅了，而且不能求出烷烃计数的生成函数。

烷烃是无根树怎么办，考虑把未知化为已知，强制钦定某一个点为根，那么就只需要考虑树上点的等价类就行，而点等价类就是有根数的计数，然后发现重心这个点很特殊，分类讨论一下：

1. 只有一个重心：首先重心不与其他任何一个点等价，那么两个点等价意味着两个点的父亲边（以重心为根）等价，因为以这个点为根的有根树，到大小大于 $\frac{n}{2}$ 儿子的边是唯一的。设点等价类数量为 $p$，边等价类数量为 $q$，那么 $p-q=1$。
2. 有两个重心，两个重心不等价：同理可得 $p-q=1$。
3. 两个重心等价：$p-q=0$。

那么对于一棵树计算 $p,q,s$，当有两个重心，且两个重心等价时 $s=1$，否则 $s=0$，对于任意一棵树有 $p-q+s=1$ 恒等式。对三个部分分别生成函数 $P,Q,S$。

点等价就是根上加 $4$ 个烷基儿子，使用 Burnside 引理进行计数 $P(x)$：

$$
P(x)=x\frac{A^4(x)+6A(x^2)A^2(x)+3A(x^2)^2+8A(x^3)A(x)+6A(x^4)}{24}
$$

边等价就是两个烷基连起来，并且不能是单个氢原子，继续 Burnside：

$$
Q(x)=\frac{(A(x)-1)^2+A(x^2)-1}{2}
$$

然后是重心等价，就是相同的两个烷基连起来：

$$
S(x)=A(x^2)
$$

那么 $P-Q+S$ 就是烷烃计数的生成函数。

---

## 作者：warzone (赞：3)

前置芝士：[烷基计数](https://loj.ac/p/6538)

这题比 loj6512 要弱一些... 只要求一项。

默认以下的树均为无根树。

烷基的生成函数 $f(x)$ 已经求得了。

对于无根树的情况，考虑选定一个根，转化为有根树后容斥。

关于树的重心有以下性质：

- 一棵树的重心只有一个或两个。
- 若有两个重心，则它们必定相邻。
- 某个点为无根树的重心**当且仅当**其子树大小不超过 $\dfrac{n}{2}$。

因此，我们选定重心为根，可以很方便的容斥。

设 $g(x)=f(x)\bmod{x^{\lfloor\frac{n}{2}\rfloor}}$，通过 Burnside 引理很快可以得到以重心为根本质不同的方案数

$$p=[x^{n-1}]\dfrac{1}{24}(g^4(x)+6g(x^2)g^2(x)+3g^2(x^2)+8g(x^3)g(x)+6g(x^4))$$

然后我们去掉两个本质不同的重心的情况，即

$$[2|n]\dfrac{1}{2}(g_{\frac{n}{2}}^2-g_\frac{n}{2})$$

因此答案就是

$$p-[2|n]\dfrac{1}{2}(g_{\frac{n}{2}}^2-g_\frac{n}{2})$$

缺点是只能求一项... 不过应付这题足够了。

```cpp
#include<stdio.h>
#include<string.h>
typedef unsigned char byte;
typedef unsigned long long ull;
typedef long long ll;
typedef unsigned int word;
struct READ{
	char c;
	inline READ(){c=getchar();}
	template<typename type>
	inline READ& operator>>(register type& num){
		while('0'>c||c>'9') c=getchar();
		for(num=0;'0'<=c&&c<='9';c=getchar())
			num=num*10+(c-'0');
		return *this;
	}
}cin;
#define mx 18
#define mx_ 17
word root[1<<mx],inv[1<<mx],realid[1<<(mx+1)];
ull size;
const word mod=998244353;
constexpr ull pow(register ull a,register word b){
	register ull ans=1;
	for(;b;b>>=1){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
	}
	return ans;
}
const ull ni2=pow(2,mod-2),ni3=pow(3,mod-2);
#define loading() do{								\
	const ull num1=pow(3,(mod-1)>>mx);				\
	const ull num2=pow(num1,mod-2);					\
	register word head,i,floor;						\
	root[1<<mx_]=inv[1<<mx_]=1,realid[1]=0;			\
	for(floor=1,i=2;floor<=mx;++floor)				\
		for(;i^(1u<<(floor+1));++i)					\
			realid[i]=(i&1)<<(floor-1)|realid[i>>1];\
	for(i=(1<<mx_)+1;i<(1<<mx);++i){				\
		root[i]=num1*root[i-1]%mod;	\
		inv[i]=num2*inv[i-1]%mod;	\
	}												\
	for(i=(1<<mx_)-1;i;--i)							\
		root[i]=root[i<<1],inv[i]=inv[i<<1];		\
}while(0);
#define load()					\
	register ull num1,num2;		\
	register word head,i,floor;
#define nttfor(size)							\
	for(floor=1;floor<(size);floor<<=1)			\
		for(head=0;head<(size);head+=floor<<1)	\
			for(i=0;i<floor;++i)
//floor 变换区间大小
//head 变换区间头指针 
//i 变换位置 
#define ntt(num,root)(							\
	num1=num[head|i],num2=num[head|i|floor],	\
    num1+=(num2=num2*root[i|floor]%mod),        \
	num[head|i]=num1>=mod? num1-mod:num1,	    \
	num1-=num2,num1+=mod-num2,                  \
	num[head|i|floor]=num1>=mod? num1-mod:num1)
#define id(size,i) (realid[(i)|(size)])
#define modx(num,size) memset(num+(size),0,(size)<<2)
#define set0(num,size) memset(num,0,(size)<<2)
#define FOR(size) for(i=0;i<(size);i++)
#define newton(size)	\
	ull ni=ni2,size_=2;	\
	while(size_<<=1,ni=ni*ni2%mod,size_>>2<(size))
word in[1<<mx],eax[1<<mx],ebx[1<<mx],ecx[1<<mx],edx[1<<mx];
word eex[1<<mx];
inline void _1(word size){// 求逆元
	ebx[0]=pow(eax[0],mod-2);
    load()
	newton(size){
		FOR(size_>>1){
            head=id(size_,i);
			ecx[head]=eax[i]? mod-eax[i]:0;
			edx[head]=ebx[i];
            head=id(size_,i|(size_>>1));
            ecx[head]=edx[head]=0;
		}
		nttfor(size_) ntt(ecx,root),ntt(edx,root);
		FOR(size_) ebx[id(size_,i)]=(ull)(ecx[i])*edx[i]%mod;
		nttfor(size_) ntt(ebx,inv);
		modx(ebx,size_>>1);
		FOR(size_) ecx[id(size_,i)]=ni*ebx[i]%mod;
		ecx[0]=(ecx[0]+2)%mod;
		nttfor(size_) ntt(ecx,root);
		FOR(size_) ebx[id(size_,i)]=(ull)(ecx[i])*edx[i]%mod;
		nttfor(size_) ntt(ebx,inv);
		modx(ebx,size_>>1);
		FOR(size_>>1) ebx[i]=ni*ebx[i]%mod;
	}
}
inline void getans(word size){//牛顿迭代求烷基
	in[0]=1;
	load()
	newton(size){
		FOR(size_>>1){
			ecx[id(size_,i)]=in[i];
			ecx[id(size_,i|(size_>>1))]=0;
		}
		nttfor(size_) ntt(ecx,root);
		FOR(size_) eex[id(size_,i)]=1ull*ecx[i]*ecx[i]%mod;
		nttfor(size_) ntt(eex,inv);
		FOR(size_>>1){
			edx[id(size_,i)]=eex[i]=ni*eex[i]%mod;
			eax[i+1]=(ull)(mod-ni2)*(eex[i]+(i&1? 0:in[i>>1]))%mod;
			edx[id(size_,i|(size_>>1))]=0;
		}
		nttfor(size_) ntt(edx,root);
		FOR(size_) eex[id(size_,i)]=1ull*ecx[i]*edx[i]%mod;
		nttfor(size_) ntt(eex,inv);
		eax[0]=1,_1(size_>>1);
		FOR(size_>>1){
			ecx[id(size_,i)]=ebx[i];
			edx[id(size_,i+1)]=ni3*((i%3? 0:in[i/3])+mod-(ni*eex[i]%mod))%mod;
			head=id(size_,i|(size_>>1));
			ecx[head]=edx[head]=0;
		}
		edx[id(size_,size_>>1)]=0,edx[0]=1;
		nttfor(size_) ntt(ecx,root),ntt(edx,root);
		FOR(size_) in[id(size_,i)]=1ull*ecx[i]*edx[i]%mod;
		nttfor(size_) ntt(in,inv);
		modx(in,size_>>1);
		FOR(size_>>1) in[i]=ni*in[i]%mod;
	}
}
int main(){
	loading();
	word n,size=1;
	for(cin>>n;size<=n;size<<=1);
	getans(size>>1);
	for(register word i=(n>>1)+1;i<size;++i) in[i]=0;
	load()
	size<<=1;
	FOR(size){//(mod x^{4n})
		head=id(size,i);
		ecx[head]=in[i];//f(x)
		edx[head]=(i&1? 0:in[i>>1]);//f(x^2)
		eex[head]=(i%3? 0:in[i/3]);//f(x^3)
	}
	nttfor(size) ntt(ecx,root),ntt(edx,root),ntt(eex,root);
	FOR(size){
		num1=1ull*ecx[i]*ecx[i]%mod;
		eax[id(size,i)]=(
			(6ull*edx[i]+num1)%mod*num1%mod
			+(3ull*edx[i]*edx[i]%mod)
			+(8ull*eex[i]*ecx[i]%mod))%mod;
	}
	nttfor(size) ntt(eax,inv);
	const ull ni=pow(size,mod-2),ni24=pow(24,mod-2);

	FOR(size){
		eax[i]=ni24*(ni*eax[i]%mod+
		(6ull*(i&3? 0:in[i>>2])%mod))%mod;
	}
	ull ans=eax[n-1];
	if((n&1)==0){//容斥
		num1=1ull*in[n>>1]*in[n>>1]%mod;
		num2=(num1+mod-in[n>>1])*pow(2,mod-2)%mod;
		ans=(ans+mod-num2)%mod;
	}
	printf("%llu",ans);
	return 0;
}
```

---


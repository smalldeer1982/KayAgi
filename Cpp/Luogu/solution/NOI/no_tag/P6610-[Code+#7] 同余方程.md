# [Code+#7] 同余方程

## 题目描述

这就是一些朴素的二次同余方程:)

------------------

给出若干组正整数 $p$ 和 $x$，求方程 $a^2+b^2\equiv x {\pmod p}$ 关于 $a$ 和 $b$ **在模 $\boldsymbol p$ 意义下**解的组数，其中 $p$ 是奇数，且不包含平方因子。

## 说明/提示

### 样例解释

$9$ 组解分别为 $(a,b) = (0,0),(1,2),(1,3),(2,1),(2,4),(3,1),(3,4),(4,2),(4,3)$。

### 子任务

每个测试点的分值为 $5$ 分。

**对于所有数据**，$n\le 10^5$，$p\le10^7$，且 $2\nmid p$，$\forall$ 奇素数 $q\mid p，q^2\nmid p$，$0\le x\le p-1$。

| 测试点编号 | $n\le$ | $p\le$ | 附加性质     |
| :--------: | :----: | :----: | :------------: |
|    $1$     |  $5$   | $100$  | $p$ 为奇素数 |
|    $2$     |  $10$  | $10^3$ | $p$ 为奇素数 |
|    $3$     |  $10$  | $10^3$ |              |
|    $4$     |  $50$  | $10^4$ | $p$ 为奇素数 |
|    $5$     | $100$  | $10^4$ | $p$ 为奇素数 |
|    $6$     |  $50$  | $10^4$ |              |
|    $7$     | $100$  | $10^4$ |              |
|    $8$     | $100$  | $10^4$ |              |
|    $9$     | $10^3$ | $10^6$ | $p$ 为奇素数 |
|    $10$    | $10^3$ | $10^6$ |              |
|    $11$    | $10^3$ | $10^6$ |              |
|    $12$    | $10^5$ | $10^6$ | $p$ 为奇素数 |
|    $13$    | $10^5$ | $10^6$ |              |
|    $14$    | $10^5$ | $10^6$ |              |
|    $15$    | $10^5$ | $10^6$ |              |
|    $16$    | $10^5$ | $10^6$ |              |
|    $17$    | $10^5$ | $10^7$ |              |
|    $18$    | $10^5$ | $10^7$ |              |
|    $19$    | $10^5$ | $10^7$ |              |
|    $20$    | $10^5$ | $10^7$ |              |

## 样例 #1

### 输入

```
1
5 0```

### 输出

```
9```

# 题解

## 作者：Alex_Wei (赞：9)

> *II. [P6610 [Code+#7]同余方程](https://www.luogu.com.cn/problem/P6610)
>
> [基础数论学习笔记](https://www.cnblogs.com/alex-wei/p/Number_Theory.html) Part 7 例 2。

究极神仙题。

根据 $\mu(p) \neq 0$ 不难想到使用 CRT 将问题拆分为模奇质数。每个奇质数的解的个数的积即为所求，因为从每个奇质数的解中任选一个，根据中国剩余定理，所有奇质数对应的解组合起来唯一确定一个解。

拆成奇质数是为了使二次剩余相关定理适用。接下来 $p$ 均视为奇质数。

问题转化为求解 $x$ 能被拆分成多少组 $a, b$ 的和，使得 $a, b$ 均为二次剩余或 $0$。其中，每个二次剩余的贡献系数是 $2$（一个二次剩余可被表示两个数的平方），$0$ 的贡献是 $1$，每组 $(a, b)$ 的贡献即 $a$ 和 $b$ 分别的贡献系数之积。

我们需要一个数学公式而非判断式来描述答案，因为判断式是不可化简的。

二次剩余对应 $2$，$0$ 对应 $1$，二次非剩余对应 $0$，这使得我们想到勒让德符号：注意到 $\left(\dfrac a p\right) + 1$ 等价于使得 $x ^ 2 \equiv a \pmod p$ 的 $x$ 的个数，因此答案为
$$
\sum\limits_{a + b \equiv x} \left(\left(\dfrac a p\right) + 1\right)\left(\left(\dfrac b p\right) + 1\right)
$$

$p$ 以内的二次剩余和二次非剩余个数相等，故 $\sum\limits_{i = 0} ^ {p - 1} \left(\dfrac i p\right) = 0$。再根据 $b \equiv x - a$ 和勒让德符号的完全积性，上式简化为
$$
p + \sum\limits_{a = 0} ^ {p - 1} \left(\dfrac {ax - a ^ 2} p\right)
$$

接下来是一步巧妙转化。考虑到为 $ax - a ^ 2$ 除以 $a ^ 2$ 并不影响它的二次剩余性，因此答案即
$$
p + \sum\limits_{a = 1} ^ {p - 1}\left(\dfrac {\frac x a  - 1} p\right)
$$

显然，对于 $x \neq 0$ 且 $a \in [1, p - 1]$，$\dfrac x a$ 取遍 $[1, p - 1]$，即 $\dfrac x a - 1$ 取遍 $[0, p - 2]$。故当 $x \neq 0$ 时，答案又可写为
$$
p - \left(\dfrac {-1}{p}\right)
$$

根据欧拉判别准则公式 $\left(\dfrac a p\right) \equiv a ^ {\frac {p - 1} 2} \pmod p$ 上式即 $p - (-1) ^ {\frac {p - 1} 2}$。

对于 $x = 0$，答案 $p + \sum\limits_{a = 1} ^ {p - 1} \left(\dfrac {-1} p\right)$ 即 $p + (p - 1)(-1) ^ {\frac {p - 1} 2}$。

公式已经足够简洁，可以 $\mathcal{O}(1)$ 计算。时间复杂度 $\mathcal{O}(p + n\omega(p))$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e7 + 5;
int T, p, x, cnt, ans = 1, pr[N], mnpr[N];
bool vis[N];
int calc(int x, int p) {return !x ? p % 4 == 1 ? 2 * p - 1 : 1 : p - (p % 4 == 1 ? 1 : -1);}
int main() {
	for(int i = 2; i < N; i++) {
		if(!vis[i]) mnpr[i] = pr[++cnt] = i;
		for(int j = 1; j <= cnt && i * pr[j] < N; j++) {
			vis[i * pr[j]] = 1, mnpr[i * pr[j]] = pr[j];
			if(i % pr[j] == 0) break;
		}
	}
	cin >> T;
	while(T--) {
		cin >> p >> x, ans = 1;
		while(p != 1) ans *= calc(x % mnpr[p], mnpr[p]), p /= mnpr[p];
		cout << ans << "\n";
	}
	return 0;
}
```

---

## 作者：jiangby (赞：6)

先看题目要求$a^2+b^2\equiv x\  mod \ p$的解数,明显跟二次剩余有关,而二次剩余一般考虑的是奇素数,所以先考虑 $p$ 为奇素数的情况

当$x=0$时,要求的是$a^2\equiv -b^2$即$-b^2$在模$p$意义下时二次剩余,所以是$(-b^2)^{\frac{p-1}2}$不难发现当$ p\ \ mod\ \  4=1$ 时显然等于$1$,当$p\ \ mod \ \ 4=3$时显然为$-1$,
那么这一部分的答案就是 $2p$ 和 $0$ ,但其实有一点考虑错了,那就是$b=0$的情况,所以答案分别是$2p-1$和$0$

当$x!=0$时,考虑换元令$y=a^2,z=b^2$那么显然答案就是$\sum_{y+z \equiv x} (f(y)+1)(f(z)+1)$ ,其中$f(x)=x^{\frac{p-1}2}$
,
即当$x$为二次剩余时为$1$,否则为$-1$,特殊的当$x=0$时为 $0$ ,把原式展开可以得到

$$
\begin{aligned}
&\quad~ \sum f(y)f(z)+f(y)+f(z)+1 \\
&= \sum f(yz)+p\\
&= \sum f(y(x-y))+p \\
&=\sum f(\frac {x-y}y)+p\\
&=\sum f(\frac xy-1)+p
\end{aligned}
$$

这里用到了三个$f$ 的性质一个是$f(x)f(y)=f(xy)$ 第二个是$f(x)=f(\frac 1 x)$最后一个是$\sum f(x)=0$,第一二个显然,第三个是因为二次剩余只有 $\frac{p-1}2$个,不难发现$\frac xy-1$唯一取不到的值是$p-1$同样得到$p\ mod\ 4=1$和$p\ mod\ 4=3$,那么就解决了奇素数的情况

对于原题因为 $p$ 是若干奇素数的积,可以直接拆分成奇素数解决后乘起来,这可以用中国剩余定理证明


---

## 作者：JerryTcl (赞：5)

旧题解错误：[云剪贴板](https://www.luogu.com.cn/paste/ntk9eugj)

来整一个更注重于观察结构而不是计算的题解（

首先使用 CRT 将问题转化为模奇质数的结果相乘是显然的。

考虑对于 $a ^ 2 + b ^ 2$ 的经典转化：我们引入 $i ^ 2 = -1$，那么也即 $(a + bi)(a - bi) \equiv x \pmod p$。

根据一些代数知识，容易知道 $i \in \mathbb Z_p \iff \operatorname{ord}(i) \mid p - 1 \iff p = 4k + 1$，故以下分 $p = 4k + 1$ 与 $p = 4k + 3$ 讨论。

$p = 4k+1$ 时，令 $u = a+bi$，$v = a-bi$，则 $u, v$ 与 $a, b$ 一一对应，  
要求的即是 $uv \equiv x \pmod p$ 的解数。  
$x = 0$ 时有 $u = 0$ 或 $v = 0$，答案为 $2p-1$；  
$x \neq 0$ 时可以任意取 $u$ 后唯一确定 $v$，答案为 $p-1$。

$p=4k+3$ 时，$i \notin \mathbb Z_p$，故在 $\mathbb Z_p[i]$ 上考虑。  
我们定义范数 $N(z) = z\bar{z}$，则 $N(a+bi) = a^2+b^2$。  
容易验证 $N(zw) = N(z)N(w)$，我们要求的就是 $\mathbb Z_p[i]$ 中元素在范数映射下的原像大小。

$\mathbb Z_p[i]$ 作为 $p^2$ 个元素的有限域 $\mathbb F_{p^2}$，有原根存在定理，即其乘法群为循环群。  
设其一个原根为 $\gamma$，我们证明，$N(\gamma) = g$ 是 $\mathbb Z_p$ 的原根。

$\mathbb Z_p[i]$ 作为 $x^2+1$ 在 $\mathbb Z_p$ 上的分裂域，其 Galois 群为 $i \mapsto -i$。  
同时，$\mathbb Z_p[i]$ 存在域扩张 $\mathbb F_{p^2} / \mathbb F_p$，其 Galois 群为 Frobenius 自同构 $x \mapsto x^p$。  
对比可知 $(a+bi)^p = a-bi$，计算可以验证这个结果，故 $N(z) = z\bar{z} = z z^p = z^{p+1}$。  
故 $g = \gamma^{p+1}$。根据原根的定义，$1, \gamma^{p+1}, \gamma^{2(p+1)}, \cdots$ 互不相同，故 $g$ 是 $\mathbb Z_p$ 的原根。

然后就容易了，对于 $i=0\sim p^2-2$，有 $N(\gamma^i) = g^i$，  
故 $x=1 \sim p-1$ 各被取到 $(p^2-1)/(p-1) = p+1$ 次。  
剩下一个 $N(0) = 0$，即 $x=0$ 时的答案为 $1$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int Calc(int x, int p) { return p & 2 ? x ? p + 1 : 1 : x ? p - 1 : 2 * p - 1; }
void Solve() {
    int x, m, ans = 1; cin >> m >> x;
    for(int i = 2; i * i <= m; ++i)
        if(m % i == 0) ans *= Calc(x % i, i), m /= i;
    printf("%d\n", m == 1 ? ans : ans * Calc(x % m, m));
}
int main() {
    cin.tie(0)->sync_with_stdio(0);
    int T; cin >> T; while(T--) Solve();
}
```

---

## 作者：Purslane (赞：3)

# Solution

CMO 前差不多做了一道这样的题：

> 证明对于任何一个奇质数 $p$，在 $2$ 到 $p-1$ 范围内满足 $x$ 和 $x-1$ 的都是 $p$ 意义下的平方剩余的 $x$ 的个数是 $\dfrac{p-(\frac{-1}{p})}{4}-1$（那个框框表示勒让德符号）。

做法就是写成 $\sum_{i=1}^{p-2} \dfrac{[(\frac{i}{p})+1][(\frac{i+1}{p})+1]}{4}$，展开之后得到四项（我先把那个 $\dfrac{1}{4}$ 给删了，碍眼）：

- $\sum_{i=1}^{p-2} (\dfrac{i^2+i}{p})$。考虑提走 $(\dfrac{i^2}{p})$，这个东西肯定是 $1$，于是得到了 $\sum_{i=1}^{p-2} (\dfrac{1+\frac{1}{i}}{p})$。上面这些东西遍历了所有 $2$ 到 $p-1$ 之间的整数，合起来是 $-1$。当时有人说这是解析数论的结论，嘲讽。

- $\sum_{i=1}^{p-2} (\dfrac{i}{p}) + (\dfrac{i+1}{p})$。这个东西是 $-(\dfrac{1}{p})-(\dfrac{-1}{p})$。

- $\sum_{i=1}^{p-2} 1$。这个比较困难，没学过，经过暴力计算 + 暴力插值发现它是 $p-2$，有会的在评论区下面告诉我。

加在一起就是 $\dfrac{p-(\frac{-1}{p})}{4}-1$。

为什么想到构造这个东西呢？因为用来计算有关二次剩余解数的问题中，$x^2 \equiv c \pmod p$ 在模 $p$ 意义下有 $(\dfrac{c}{p})+1$ 个解。本质上就是求方程组 $\left\{ \begin{matrix}a^2 \equiv& x \pmod p \\ b^2 \equiv& x+1 \pmod p \end{matrix} \right.$ 的解数除以 $4$。

CMO 2023 好像没怎么考数论。今年注意了。

这道题一个套路。首先，考虑模数是奇质数怎么做。直接枚举两个加数，得到

$$
\begin{aligned}
&\sum_{a+b \equiv x \pmod p} ((\frac{a}{p})+1)((\frac{b}{p})+1)  \\
&= \sum_{a=0}^{p-1} (\frac{ax-a^2}{p})+(\frac{a}{p})+(\frac{p-a}{p})+1 \\
&= p+\sum_{a=1}^{p-1} (\frac{\frac{x}{a}-1}{p})
\end{aligned}
$$

考虑如果 $x=0$，这个和式得到了 $(p-1) (\dfrac{-1}{p})$。否则，$\dfrac{x}{a}$ 在模意义下应该遍历了所有非 $0$ 的数，那么 $\dfrac{x}{a}-1$ 就没访问到 $p-1$，这个和式为 $-(\dfrac{-1}{p})$。

注意到如果满足在模 $p$ 意义下解的个数为 $\alpha$（$p$ 为奇质数），模 $q$ 意义下解的个数为 $\beta$，在模 $pq$ 意义下解为 $\alpha \beta$（中国剩余定理直接合并）。

题目中保证了模数没有平方因子，就这么做即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e7+10;
int T,p,x,lst[MAXN],flg[MAXN];
void init(int mx) {
	vector<int> pr;
	ffor(i,2,mx) {
		if(!flg[i]) lst[i]=i,pr.push_back(i);
		for(auto v:pr) {
			if(i*v>mx) break;
			flg[i*v]=1,lst[i*v]=v;
			if(i%v==0) break;
		}
	}
	return ;
}
int solve(int p,int x) {
	int mul=1; if((p-1)/2%2) mul=-1;
	if(!(x%p)) return p+(p-1)*mul;
	return p-mul;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T; init(10000000);
	while(T--) {
		cin>>p>>x;
		ll ans=1;
		while(p!=1) ans*=solve(lst[p],x),p/=lst[p];
		cout<<ans<<'\n';
	}
	return 0;
}
```

真的是今天写的最后一篇题解了。

---

## 作者：LiuIR (赞：3)

### 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P6610)

给出若干组正整数 $p$ 和 $x$，求方程 $a^2+b^2\equiv x {\pmod p}$ 关于 $a$ 和 $b$ 在模 $p$ 意义下解的组数，其中 $p$ 是奇数，且不包含平方因子。

$n\le 10^5$，$p\le10^7$。

### 题目分析

#### 算法 1：暴力

直接枚举 $a$ 和 $b$ 得到结果。

时间复杂度 $O(np^2)$，可得 15 分。

#### 算法 2：利用二次剩余

因为这是一个二次同余方程，我们就可以用二次剩余来完成。

具体地说，我们可以建立一个 $quad$ 数组，用 $quad_i$ 表示平方模 $p$ 余 $i$ 的个数。

这时我们枚举只需一个 $i$，表示 $a^2\equiv i\pmod p$，则有 $b^2\equiv x-i\pmod p$，所以此时解的个数为 $quad_i\times quad_{x-i}$。

时间复杂度 $O(np)$，可得 40 分。

#### 算法 3：充分利用二次剩余

现在我们需要将 $p$ 为质数的情况完美地解决。

事实上如果对小质数尝试打表的话，会发现如下规律。

当 $p\bmod4=1,x=0$ 时，解的个数为 $2p-1$。

当 $p\bmod4=1,x\not=0$ 时，解的个数为 $p-1$。

当 $p\bmod4=3,x=0$ 时，解的个数为 $1$。

当 $p\bmod4=3,x\not=0$ 时，解的个数为 $p+1$。

上述结论也是可以严谨证明的，请感兴趣的同学尝试证一下。

于是在 $p$ 为质数的情况下，可以 $O(n)$ 完成，可得特殊情况的 30 分。

#### 算法 4：中国剩余定理+算法 3

我们在算法 3 中已经完美地解决了 $p$ 为质数的情况，我们现在将其拓宽捣任意的情况。

注意到题目中限制了 $p$ 中没有平方因子，所以对 $p$ 进行质因数分解可以得到 $p=\prod_{i=1}^kp_i$，其中 $p_i$ 均为奇质数。

我们设 $x\bmod p_i=x_i$，那么原本的方程化为了 $k$ 个同余方程 $a^2+b^2\equiv x_i\pmod p_i$。

由于 $p_i$ 互不相等，所以这 $k$ 个方程互相独立。而且有中国剩余定理可以证明，原方程的解与这个方程的解一一对应。

具体来说，如果 $(a,b)$ 为原方程的一组解，那么 $(a\bmod p_i,b\bmod p_i)$ 为地 $i$ 个方程的一组解。

反之，如果我们对第 $i$ 个方程找到了一组解 $(a_i,b_i)$，那么存在唯一的一对 $(a,b)$ 使得 $a\bmod p_i=a_i,b\bmod p_i=b_i$，它是方程的一组解。

由此，我们可以对每一个方程去求解的个数，最后将他们相乘，得到最后的答案。

时间复杂度主要受质因数分解限制，若直接枚举，时间复杂度为 $O(n\sqrt{p})$。

若先用欧拉筛筛出质数表，则可将时间复杂度优化为 $O(p+n\pi(\sqrt{p}))$。

### 代码

```c++
#include <cstdio>
#define int long long

int n, p, x, result[10];

void Break(int);

signed main()
{
	scanf("%lld", &n);
	while(n--)
	{
		int ans = 1;
		scanf("%lld%lld", &p, &x);
		Break(p);
		for (int i = 1; i <= result[0]; i++)//枚举每一个方程
		{
			int xx = x % result[i];
			if (result[i] % 4 == 1)
			{
				if (!xx)
					ans *= 2 * result[i] - 1;
				else
					ans *= result[i] - 1;
			}
			if (result[i] % 4 == 3)
			{
				if (!xx)
					ans *= 1;
				else
					ans *= result[i] + 1;
			}
		}
		printf("%lld\n", ans);
	}
	return 0;
}

void Break(int n)//质因数分解
{
	result[0] = 0;
	for (int i = 2; i * i <= n; i++)if (n % i == 0)
	{
		n /= i;
		result[++result[0]] = i;
	}
	if (n)
		result[++result[0]] = n;
}
```



---

## 作者：Vector_net (赞：2)

非常有意思的数论题呢！

### 题意：

求方程 $a^2+b^2 \equiv n \pmod{p}$ 关于 $a$ 和 $b$ 在模 $p$ 意义下解的组数，其中 $p$ 为奇数且不含平方因子。

### 解决：

注意到 $p$ 为奇数且不含平方因子，不难想到将 $p$ 质因数分解得到一些形如 ${p_i}$ 的两两互质的模数，此时对于每一组解的 $a$，$b$，我们可以使用 CRT 将她们合并为一个新解，显然这是一一映射，于是，我们只要求出在模奇质数意义下这个方程的解数，最后乘起来即可。

考虑如何求解这个子问题，现在模数是奇质数，所以二次剩余相关定理适用。

让我们引入 $Legendre$ 符号。定义如下：

$(\frac{a}{p}) = \begin{cases}
  0 & p \mid a\\
  1 & \exists x,x^2 \equiv a \pmod{p}\\
  -1 & otherwise
\end{cases}$

对原先的方程进行换元，令 $x\equiv a^2,y\equiv b^2$，则原方程的解数公式为：

$$\begin{aligned}
\sum_{x+y\equiv n}((\frac{x}{p})+1)((\frac{y}{p})+1)&=\sum_{x+y\equiv n}(\frac{x}{p})(\frac{y}{p})+(\frac{x}{p})+(\frac{y}{p})+1\\
&=p+\sum_{x=0}^{p-1}(\frac{nx-x^2}{p})
\end{aligned}
$$

思考一下为什么，由于模 $p$ 意义下二次剩余与非二次剩余数量相等，所以有 $\sum_{x=0}^{p-1}(\frac{x}{p})=0$，又因为 $x+y\equiv n$ 与 $(\frac{a}{p})(\frac{b}{p})=(\frac{ab}{p})$，因此可以得到这个式子。

接下来就是这个题最有意思的的部分了，~~当然也最难想到，~~我们发现 $xn-n^2$ 除以一个 $n^2$ 并不影响其二次剩余性，于是公式可以再次化简为：

$$
p+\sum_{x=1}^{p-1}(\frac{\frac{n}{x}-1}{p})
$$

当 $n \ne 0$ 时 $\frac{x}{n} \bmod p$ 恰好取遍 $[1,p-1]$ 的每一个数，于是可以得到一个更简洁的式子：

$$
p-(\frac{-1}{p})=p-(-1)^{\frac{p-1}{2}}
$$

这个式子已经可以 $O(1)$ 计算了。

而当 $n=0$ 时，代入上面的原始式子，得答案

$$
p+\sum_{a=1}^{p-1}(\frac{-1}{p})=p+(p-1)(-1)^{\frac{p-1}{2}}
$$

也可以 $O(1)$ 计算。

最后分解质因数考虑到 $p$ 不大，可以欧拉筛筛出每个数的最小质因子，最后一个个除，最终复杂度 $O(q\log n)$。

### 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e7+5,maxp=7e5+5;
int T,p,x,vis[maxn],prime[maxp],cnt;
inline int read(){
	int ret=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-f;c=getchar();}
	while(isdigit(c)){ret=ret*10+c-'0';c=getchar();}
	return ret*f;
}
inline void make_p(int n){
	vis[0]=vis[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i])prime[++cnt]=i,vis[i]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++){
			vis[i*prime[j]]=prime[j];
			if(i%prime[j]==0)break;
		}
	}
}
inline int power(int x){return x&1?-1:1;}
inline int calc(int p,int x){
    if(!x)return p+(p-1)*power(p-1>>1);
    else return p-power(p-1>>1);
}
signed main(){
	T=read();make_p(1e7);
    while(T--){
        p=read(),x=read();int ans=1;
        for(;p>1;p/=vis[p])ans*=calc(vis[p],x%vis[p]);
        printf("%lld\n",ans);
    }
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：2)

模拟赛的时候出过，结果今天又碰到了，才知道是原题。

#### 题目大意：

给定 $p,r$，求有多少个整数点 $(x,y)$ 满足 $x^2+y^2\equiv r \pmod p$，$x,y\in [0,p-1]$。数据保证 $p$ 为奇数且 $\mu(p)\neq 0$。

#### 题解：

由于 $\mu(p)\neq 0$ 且 $p$ 为奇数，显然 $p$ 可以表示成若干个互不相同的奇质数的乘积。由于题目数据有 $p$ 为质数的单独一档，这启示我们将不同的质数分开考虑。通过中国剩余定理，我们知道将问题拆解为奇质数，然后答案相乘即可。

我们可以发现在 $p$ 为质数时：

$x^2+y^2=r\bmod p$，先考虑 $r=0$ 的情况。

当 $x=0$ 时可以有 $y=0$。
当 $x=1\sim p-1$ 时，$y^2\equiv (-x^2)\bmod p$。这相当于询问 $-x^2$ 是否是模 $p$ 的二次剩余。根据欧拉判别法，$(-x^2)^{\frac{p-1}{2}}=(-1)^{\frac{p-1}{2}}\cdot x^{p-1}\bmod p$，再根据费马小定理可得 $x^{p-1}\equiv 1\bmod p$，因此原式等于 $(-1)^{\frac{p-1}{2}}\bmod p$。

- 当 $p=4k+1$ 时，$\dfrac{p-1}{2}=2k$ 为偶数，此时原式 $\equiv 1\bmod p$ 说明 $-x^2$ 是二次剩余，即 $x$ 对应唯一的 $y$。同理 $y$ 对应唯一的 $x$。又可以证明当 $x,y>0$ 时，$x\neq y$。故此时合法的方案数有 $1+2(p-1)=2p-1$ 种。
- 当 $p=4k+3$ 时，$\dfrac{p-1}{2}=2k+1$ 为奇数，此时原式 $\equiv -1$ 说明 $-x^2$ 不是二次剩余，即 $x>0$ 均无解，因此合法方案数只有 $1$ 种。

再考虑 $r\neq 0$ 的情况。

使用勒让德符号进行推导。勒让德符号 $\left(\dfrac a p\right)=a^{\frac{p-1}{2}}\bmod p$。其具有以下性质：

1. 完全积性：$\left(\dfrac a p\right)\left(\dfrac b p\right)=\left(\dfrac {ab} p\right)$；
2. $\displaystyle \sum_{i=0}^{p-1}\left(\dfrac i p\right)=0$。

然后我们就可以写出原题的式子：

$$
 \displaystyle \sum_{a+b\equiv r} (\left(\dfrac a p\right)+1)(\left(\dfrac b p\right)+1)$$

$$
= \sum_{a}(\left(\dfrac a p\right)+1)(\left(\dfrac {r-a} p\right)+1)
$$
$$
=\  p+\sum_{a=1}^{p-1} \left(\dfrac {ra-a^2} p\right)=\ p+\sum_{a=1}^{p-1} \left(\dfrac {\frac r a-1} p\right)
$$

由于 $p$ 为奇质数，必然存在逆元，可以证明 $ra^{-1}-1$ 取遍了 $[0,p-2]$ 中的所有数，因此运用性质 $2$，剩下来的就是
$$
p-\left(\dfrac{-1}{p}\right)=p-(-1)^{\frac{p-1}{2}}
$$
这就回到了上面的问题，当 $p=4k+1$ 时答案为 $p-1$，否则答案为 $p+1$。

当然打表也可以找到这一规律。

```cpp
int T, p, r, cnt;
int prime[maxn], tot;
bool vis[maxn];
inline void getPrime(int N) {
    vis[0] = vis[1] = 1;
    rep(i, 2, N) {
        if(!vis[i]) prime[++ tot] = i;
        for(int j = 1; j <= tot &&i * prime[j] <= N; ++ j) {
            vis[i * prime[j]] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}
inline ll calc(int p, int r) {
    r %= p;
    if(p % 4 == 1) {
        if(!r) return 2 * p - 1;
        else return p - 1;
    }
    else {
        if(!r) return 1;
        else return p + 1;
    }
}
int a[maxn], m[maxn], M[maxn];
inline void exgcd(int a, int b, ll &x, ll &y) {
    if(!b) {x = 1, y = 0; return;}
    exgcd(b, a % b, y, x); y -= (a / b) * x;
}
inline int inv(int a, int b) {
    ll x, y; exgcd(a, b, x, y);
    return (x % b + b) % b;
}
inline ll CRT() {
    ll now = 1, res = 0;
    rep(i, 1, cnt) now *= m[i];
    rep(i, 1, cnt) {
        M[i] = now / m[i];
        int M_inv = inv(M[i], m[i]);
        res += a[i] * 1ll * M_inv * M[i] ;
  //      printf("%d %d %d %d\n", a[i], now, M[i], M_inv);
    }
    return res;
}
inline void solve() {
    read(p); read(r);
    vector <int> d;
    for(int j = 1; j <= tot; ++ j) {
        int x = prime[j];
        if(x * x > p) break;
        if(p % x == 0) d.push_back(x), p /= x;
    }
    if(p > 1) d.push_back(p);
    ll ans = 1;
    cnt = 0;
    for(auto x : d) ans *= calc(x, r);//, writeln(x);
        //cnt ++, a[cnt] = calc(x, r), m[cnt] = x;// cout << a[cnt ]<< " " << m[cnt] << endl;
  //  ans = CRT();
    writeln(ans);
}
int main () {
//    freopen("circle.in", "r", stdin);

    getPrime(maxn - 5);
    read(T);
    while(T--) solve();

    return 0;
}
```

---

## 作者：chenxia25 (赞：2)

一道卓越得让我五体投地的好题/ww

---

首先拆 CRT 是显然的吧（）。将 $p$ 拆成若干个奇质数 $p_i$ 的乘积，设 $a^2+b^2\equiv x\pmod{p_i}$ 的解集 $X_i$（是个二元组集合哟），则从每个 $X_i$ 中选一组出来都能用 CRT 合并成一个模 $p$ 的解，所以答案就是 $\prod|X_i|$（不需要写 CRT 哟）。

下面考虑 $p$ 是奇质数怎么做。容易想到换元，令 $y=a^2,z=b^2$，设 $f(A)=[A\text{ 是模 }p\text{ 二次剩余哒！}]$，则答案就是 $4\sum\limits_{y\not\equiv 0,y\not\equiv x}f(y)f(x-y)$，再加上 $0$ 和 $x$ 的贡献。后者是 trivial 的，考虑前者怎么求。

由于枚举条件是 $y\not\equiv0,y\not\equiv x$，本能地分 $x$ 是否为 $0$ 讨论。如果等于那是比较简单的，设 $m=\dfrac{p-1}2$，任取原根 $g$，设 $y\equiv g^\alpha$，则显然 $-y\equiv -g^\alpha\equiv g^{m+\alpha}$。如果 $m$ 是偶数，那么 $f(y)=f(-y)$，于是 sum 枚举的有一半都是 $1$，算出来就是 $4\times\dfrac{p-1}2=2(p-1)$；$m$ 是奇数的话有 $f(y)=1-f(-y)$，这两者永远不可能同时为 $1$，那就寄了，算出来是 $0$。

$x\not\equiv0$ 乍一看感觉很离谱，觉得不可做，因为加法和二次剩余放一块就像世纪难题（雾水）。但注意到二次剩余判定方法，$f(A)=[A^{m}\equiv 1]$，这样 $f(A)=0$ 对应 $A^m\equiv-1$，$f(A)=1$ 对应 $A^m\equiv 1$，于是有 $f(A)=\dfrac{(A^m+1)\bmod p}2$！这样就把一个真值表达式变成了代数式！但一个问题是，要求的 $\sum$ 是在 $\Z$ 上的，而这样表示 $f(A)$ 是在 $\Z_p$ 上的，这就意味着如果按照这个表达式计算 $\sum$，只能得到模 $p$ 意义下的值。接下来是最神仙的地方：只需要知道模意义下的值，便可知道真实值，因为 $\sum f(y)f(x-y)\in[0,p-2]$！！！！

接下来就略显 trivial 了。忽略 $f(A)$ 的分母，最后乘个 $4$ 的逆元即可。显然
$$
\sum (y^m+1)((x-y)^m+1)=\sum(y^m(x-y)^m+y^m+(x-y)^m+1)
$$
第四项的和显然是 $p-2$。第二三项是对称的，分别能取遍 $[1,p)\backslash \{x\}$，而 $[1,p)$ 的 $m$ 次方一半是 $1$ 一半是 $-1$，总和就是 $0$，所以取 $-x^m$ 就行了。第一项的话，乘进去得到 $\!\left(xy-y^2\right)^m$，除以 $y^2$ 显然值不变，为 $\left(\dfrac xy-1\right)^m$。这就比较简单，$\dfrac xy$ 显然取遍 $[2,p)$，于是 $\dfrac xy-1$ 取遍 $[1,p-2]$。

```cpp
int solve(int p, int x) {
	if(x == 0) return (p - 1) % 4 == 0 ? 2 * p - 1 : 1;
	int m = p - 1 >> 1;
	int ans = p - 2;
	(ans += 2 * -qpow(x, m, p)) %= p;
	(ans += -qpow(p - 1, m, p)) %= p;
	ans = (ans + 10 * p) * inv(4, p) % p * 4;
	return ans + 4 * (qpow(x, m, p) == 1);
}

void mian() {
	int p = read(), x = read();
	int ans = 1;
	for(int i = 2; i * i <= p; ++i) if(p % i == 0) {
		ans *= solve(i, x % i);
		p /= i;
	} if(p > 1) ans *= solve(p, x % p);
	prt(ans), pc('\n');
}
```

---

## 作者：lightup37 (赞：2)

感谢数竞同学的做法

数竞同学真是太强了！

---

简述一下题意，给定 $p, x$，求满足同余方程 $a^2 + b^2 \equiv x \pmod p$ 的解的组数，其中 $\mu(p) = 0$ 且 $2\not | p$。

只需要考虑 $p$ 为奇质数时的情况，这是因为显然 $p = p_1p_2\cdots p_m$ 的答案就是分别考虑 $p_1, p_2, \cdots p_m$ 情况下答案的数量之积。

容易发现如下等式成立：$a^{p-1} \mod p = [a \not= 0]$，所以所求即 $p^2 - \sum\limits_{a, b\in [0, p-1]} ((a^2 + b^2 -x)^{p-1} \mod p )$. 不妨先考虑如何求 $(\sum\limits_{a, b\in [0, p-1]} (a^2 + b^2 -x)^{p-1}) \mod p$。以下讨论均建立在 $\mod p$ 基础下，有些步骤不再写出。

三项式定理展开一下：
$\begin{aligned}LHS &= \sum\limits_{a, b\in [0, p-1]} \sum\limits_{c+d\in [0, p-1]} \dbinom{p-1}{c,d,p-1-c-d}a^{2c} b^{2d} x^{p-1-c-d} \\ &= \sum\limits_{c+d\in[0, p-1]} x^{p-1-c-d} \dbinom{p-1}{c, d, p-1-c-d} ( \sum\limits_{a\in [0, p-1]} a^{2c} ) ( \sum\limits_{b\in [0, p-1]} b^{2d} )\end{aligned}$

考察式子 $\sum\limits_{a\in [0, p-1]} a^{2c}$, 不妨设 $p$ 的一个原根为 $g$，由 $a\in [0, p-1]$ 知 a 遍历 $0, g^0, g^1, g^2, ... g^{p-2}$，所以原式即 $\sum\limits_{t=0}^{p-2}  g^{2ct} = \frac{1-g^{2c(p-1)}}{1-g^{2c}}$，除非 $g^{2c} = 1$ 时原式等于 $p-1$，否则原式等于 0。而又 $c+d = p-1$，故只有 $c=d=\frac{p-1}{2}$ 时 $x^{p-1-c-d} \dbinom{p-1}{c, d, p-1-c-d} ( \sum\limits_{a\in [0, p-1]} a^{2c} ) ( \sum\limits_{b\in [0, p-1]} b^{2d} )$ 不为 0。


所以 $\begin{aligned}LHS &= \dbinom{p-1}{\frac{p-1}{2}}\end{aligned}$，又有：

$\begin{aligned}(\frac{p-1}{2}!) ^ 2 \mod p &= 1\times 2\times \cdots \frac{p-1}{2} \times (p-\frac{p+1}{2}) \times (p-\frac{p+3}{2})\times \cdots (p-(p-1))\\ &= (-1)^{\frac{p-1}{2}} (p-1)! = (-1)^\frac{p+1}{2}\end{aligned}$

所以 $\dbinom{p}{\frac{p-1}{2}} = (-1)^{\frac{p-1}{2}}$。

所以 $( p^2 - \sum\limits_{a, b\in [0, p-1]} (a^2 + b^2 -x)^{p-1} ) \mod p = -(-1)^\frac{p-1}{2}$。

接下来对 $x$ 进行一些讨论。若 $x$ 不等于 $0$，我断言答案组数为偶数且不大于 $2p$。可以分 $\frac{x}{2}$ 是否是二次剩余讨论证明，留给读者思考。所以若 $x\not= 0$ 则答案为 $p-(-1)^{\frac{p+1}{2}}$。若 $x = 0$，首先有解 $(a=0, b=0)$，且其它解均成对出现，故答案为奇数。所以当 $(-1)^{\frac{p-1}{2}} = 1$ 时答案为 1，否则答案为 $2p-1$。

---

## 作者：littlez_meow (赞：1)

代数推导保平安。

### 思路

首先将 $p$ 分解，得到一堆奇质数。根据 CRT，如果在每个数下的解的组数分别为 $t_1,t_2,\cdots$，则最后的答案为 $\prod\limits_i t_i$。

下面只讨论 $p$ 为奇质数的情况（事实上，$p=2$ 也可以用组合意义分讨出来）。出于自己的习惯，将题面中的 $x$ 记为 $r$。

写成式子，答案为：

$$\sum\limits_{a=0}^{p-1}\sum\limits_{b=0}^{p-1}[a^2+b^2\equiv r\pmod p]$$

考虑单位根反演，得到：

$$\sum\limits_{a=0}^{p-1}\sum\limits_{b=0}^{p-1}\dfrac 1 p\sum\limits_{i=0}^{p-1}(\omega_p^{a^2+b^2-r})^i$$

整理得：

$$\dfrac 1 p\sum\limits_{i=0}^{p-1}\omega_p^{-ri}\left(\sum\limits_{x=0}^{p-1}\omega_p^{x^2i}\right)^2$$


里面的式子比较碍事，考虑化简。枚举数变成枚举平方，一个数 $t=x^2$ 对应 $1+\left(\dfrac t p\right)$ 个 $x$，因此有：

$$\sum\limits_{x=0}^{p-1}\omega_p^{x^2i}=\sum\limits_{t=0}^{p-1}(1+\left(\dfrac t p\right))\omega_p^{ti}$$

带回原式得到答案为：

$$\dfrac 1 p\sum\limits_{i=0}^{p-1}\omega_p^{-ri}\left(\sum\limits_{t=0}^{p-1}(1+\left(\dfrac t p\right))\omega_p^{ti}\right)^2$$

拆开括号：

$$\dfrac 1 p\sum\limits_{i=0}^{p-1}\omega_p^{-ri}\left(\sum\limits_{t=0}^{p-1}(\omega_p^i)^t+\sum\limits_{t=0}^{p-1}\left(\dfrac t p\right)\omega_p^{ti}\right)^2$$

我们发现 $\sum\limits_{t=0}^{p-1}(\omega_p^i)^t$ 是单位根反演的形式，可以还原成 $p\times[p|i]$。这一项仅在 $i=0$ 时有值，把它单拎出来，得到上式等于：

$$\dfrac 1 p(p+\sum\limits_{t=0}^{p-1}\left(\dfrac t p\right))^2+\dfrac 1 p\sum\limits_{i=1}^{p-1}\omega_p^{-ri}\left(\sum\limits_{t=0}^{p-1}\left(\dfrac t p\right)\omega_p^{ti}\right)^2$$

再根据除了 $0$ 以外，$p$ 的二次剩余与二次非剩余均有 $\dfrac{p-1}2$ 个，得到 $\sum\limits_{t=0}^{p-1}\left(\dfrac t p\right)=0$，因此上式等于：

$$p+\dfrac 1 p\sum\limits_{i=1}^{p-1}\omega_p^{-ri}\left(\sum\limits_{t=0}^{p-1}\left(\dfrac t p\right)\omega_p^{ti}\right)^2$$

现在上式满足 $(p,i)=1$，因此 $\left(\dfrac i p\right)^2=1$ 且 $it$ 与 $t$ 共同遍历模 $p$ 完系。因此我们有：

$$\sum\limits_{t=0}^{p-1}\left(\dfrac t p\right)\omega_p^{ti}=\sum\limits_{t=0}^{p-1}\left(\dfrac t p\right)\left(\dfrac i p\right)^2\omega_p^{ti}=\left(\dfrac i p\right)\sum\limits_{t=0}^{p-1}\left(\dfrac{it}p\right)\omega_p^{it}=\left(\dfrac i p\right)\sum\limits_{t=0}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}$$

上面用到了勒让德符号的完全积性。带回原式得到答案为：

$$p+\dfrac 1 p\sum\limits_{i=1}^{p-1}\omega_p^{-ri}\left(\left(\dfrac i p\right)\sum\limits_{t=0}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}\right)^2$$

又有 $\left(\dfrac{i}p\right)^2=1$，得到：

$$p+\dfrac 1 p\left(\sum\limits_{i=1}^{p-1}\omega_p^{-ri}\right)\left(\sum\limits_{t=0}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}\right)^2$$

$r=0$ 是否成立会影响第一个括号的值。分两类。当 $r=0$ 时：

$$p+\dfrac{p-1}p\left(\sum\limits_{t=0}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}\right)^2$$

否则考虑给第一个括号补上 $i=0$，逆用单位根反演再展开，得到 $r\neq0$ 时的结果：

$$p-\dfrac 1 p\left(\sum\limits_{t=0}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}\right)^2$$

上面的式子均有共同的一项：$\sum\limits_{t=0}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}$。问题转化为求该式。

回到一开始的 $\sum\limits_{t=1}^{p-1}\omega_p^{t^2}$，其等于：

$$\sum\limits_{t=1}^{p-1}(1+\left(\dfrac{t}p\right))\omega_p^{t}$$

去括号：

$$\sum\limits_{t=1}^{p-1}\omega_p^{t}+\sum\limits_{t=1}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}$$

代入 $\sum\limits_{t=1}^{p-1}\omega_p^{t}=0$，第二个循环提前到从 $0$ 开始，得到：

$$\sum\limits_{t=0}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}$$

因此 $\sum\limits_{t=0}^{p-1}\left(\dfrac{t}p\right)\omega_p^{t}=\sum\limits_{t=1}^{p-1}\omega_p^{t^2}$。

等式右边被称为二次高斯和。根据二次互反律证明的相关知识，我们有：

$$\sum\limits_{t=1}^{p-1}\omega_p^{t^2}=\left\{\begin{matrix}
 \sqrt p & p\equiv 1\pmod 4\\
 i\sqrt p & p\equiv 3\pmod 4
\end{matrix}\right.$$

其中 $i$ 为虚数单位。读者自证不难，具体思路大概为因式分解其平方后确定正负号。

带回到原式得到答案 $A$。

当 $r=0$ 时，$A=\left\{\begin{matrix}
 2p-1 & p\equiv 1\pmod 4\\
 1 & p\equiv 3\pmod 4\end{matrix}\right.$。
 
当 $r\neq0$ 时，$A=\left\{\begin{matrix}
 p-1 & p\equiv 1\pmod 4\\
 p+1 & p\equiv 3\pmod 4\end{matrix}\right.$。

解决！

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i) 
#define ll long long
using namespace std;
int n,p,r;
int v[10000001];
vector<int>prime;
inline void euler(){
	F(i,2,10000000){
		if(!v[i]) v[i]=i,prime.push_back(i);
		for(int j:prime){
			ll t(1ll*i*j);
			if(t>=10000001) break;
			v[t]=j;
			if(v[i]==j) break;
		}
	}
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(euler();n;--n){
		cin>>p>>r;
		ll ans(1);
		while(p!=1){
			int t=v[p];
			p/=t;
			if(r%t==0) ans=ans*((t&3)==1?(t<<1)-1:1);
			else ans=ans*((t&3)==1?t-1:t+1);
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：PeppaPig_qwq (赞：0)

一道关于 Legendre 符号的推式子好题。
首先引入 Legendre 符号。定义 Legendre 符号 $\dbinom{a}{p} = \begin{cases} 0 & \gcd (a,p) \ne 1 \\ 1 & \gcd (a,p) = 1 \land ((\exists x \in \text Z) x^2 \equiv a \pmod p) \\ -1 & \textnormal {Otherwise} \end{cases}$。

说人话就是，对于 $a$，$p$ 不互质，$\dbinom{a}{p} = 0$。否则当 $a$ 是模 $p$ 的二次剩余时，$\dbinom{a}{p} = 1$，否则 $\dbinom{a}{p} = -1$。

Legendre 符号有很多性质。例如对于 $p \in \text P, \dbinom{a}{p} \equiv {a}^{\frac{(p - 1)}{2}} \pmod p$。晚点推式子的时候会用。

让我们先将题面用数学语言翻译一遍。给定 $p,x$，求 $\sum_{i=0}^{p-1} \sum_{j=0}^{p-1} [i^2 + j^2 \equiv x \pmod p]$。

注意到 $p$ 的每个质因子幂次都为 1，所以可以将 $p$ 分解质因数，然后再将每个质因数的答案乘起来，就是原本的答案。

先开始简化式子。尝试枚举 $i^2$ 而非 $i$。对于 $\dbinom{i}{p} = 1$ 的情况满足 $x^2 = i \pmod p$ 的解有两个。对于 $\dbinom{i}{p} = -1$ 的情况满足 $x^2 = i \pmod p$ 的解有零个。对于 $\dbinom{i}{p} = 0$ 的情况满足 $x^2 = i \pmod p$ 的解有一个。$\dbinom{i}{p} = 0$ 有一组解是因为此时 $i = 0$，只有 $0^2 \equiv 0 \pmod p$。总结一下，满足 $x^2 = i \pmod p$ 的解有 $\dbinom{i}{p} + 1$ 个。所以原式就等于 $\sum_{i=0}^{p-1} (\dbinom{i}{p} + 1)(\dbinom{x - i}{p} + 1)$。

现在，我们要用到 Legendre 符号的其中一个性质了。$\sum_{i=1}^{p-1} \dbinom{i}{p} = 0$。也就是 $1 \cdots p - 1$ 中有一半的数有二次剩余，另一半没有。分析一下原式，$\sum_{i=0}^{p-1} (\dbinom{i}{p} + 1)(\dbinom{x - i}{p} + 1) = \sum_{i=0}^{p-1} (\dbinom{i}{p}\dbinom{x - i}{p} + \dbinom{i}{p} + \dbinom{x - i}{p} + 1)$。

根据前面提到的性质，$\sum_{i=0}^{p-1} (\dbinom{i}{p} + \dbinom{x - i}{p} + 1) = p$。所以原式等于 $\sum_{i=0}^{p-1} \dbinom{i}{p}\dbinom{x - i}{p}$。

现在，开始用另一个性质。Lengendre 符号是完全积性的。也就是 $\dbinom{i}{p}\dbinom{j}{p} = \dbinom{ij}{p}$。证明显然。

所以将原式两边乘起来，得原式 $=\sum_{i=0}^{p-1} \dbinom{xi - i^2}{p}$。提出 $i^2$，则原式 $=\sum_{i=1}^{p-1} \dbinom{\frac{x}{i} - 1}{p}$。显然，$\frac{x}{i}$ 能取遍 $1 \cdots p - 1$，所以 $\frac{x}{i} - 1$ 能取遍 $0 \cdots p - 2$。所以原式 $=\sum_{i=1}^{p-1} \dbinom{\frac{x}{i} - 1}{p} = -\dbinom{-1}{p}$。

当然，对于 $x = 0$，原式为 $\dbinom{-1}{p} \times (p - 1)$。

总结：当 $x \ne 0$，答案为 $p - \dbinom{-1}{p}$。当 $x = 0$，答案为 $p + (p - 1) \times \dbinom{-1}{p}$。

最后的式子用 $\dbinom{a}{p} \equiv {a}^{\frac{(p - 1)}{2}} \pmod p$ 直接算即可。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

  

typedef long long ll;

  

const ll Pig = 1e7 + 10;

  

ll mn_pr[Pig];

vector<ll> pr;

bitset<Pig> p;

  

void sieve(ll n = Pig - 1) {

    for (ll i = 2; i < n; i++) {

        if (!p[i])

            pr.emplace_back(i), mn_pr[i] = i;

        for (ll j : pr) {

            if (i * j > n)

                break;

            p[i * j] = 1;

            mn_pr[i * j] = j;

            if (i % j == 0)

                break;

        }

    }

}

  

ll cal(ll x, ll p) {

    ll f = 1;

    if (!x)

        f = p - 1;

    f = f * (2 * ((((p - 1) / 2) & 1) ^ (!x)) - 1);

    return f + p;

}

  

int main() {

    ios::sync_with_stdio(0);

    cin.tie(0);

    //freopen("a.in", "r", stdin);

    sieve();

    ll t;

    cin >> t;

    for (; t; t--) {

        ll ans = 1, x, p;

        cin >> p >> x;

        while (p != 1)

            ans *= cal(x % mn_pr[p], mn_pr[p]), p /= mn_pr[p];

        cout << ans << "\n";

    }

}
```

---

## 作者：Corzica (赞：0)

因为保证没有数会拥有两个及以上我的等奇素数因子，所以可以拆开之后把答案用 CRT 合并，就是分开算答案后乘起来。

考虑如果是奇素数改怎么做，根据某些定理，一个数 $p$ 能成为 $m$ 的二次剩余当且仅当 $a^{\frac{m-1}{2}}\equiv 1 \pmod m$，否则 $a^{\frac{m-1}{2}}\equiv -1 \pmod m$。

稍稍打一下表就能发现，一个数如果是二次剩余，那么一定有且仅有两个数满足 $a^2 \equiv p \pmod m$。可以考虑平方差公式来证明。

所以，一个数对应的数字的数量就是 $p^{\frac{m-1}{2}}+1$，那么总的答案就是 $\sum_{p+q \equiv x} (p^{\frac{m-1}{2}}+1)(q^{\frac{m-1}{2}}+1)$。

对这个式子进行化简，得 $\sum_{p+q \equiv x}(pq)^{\frac{m-1}{2}}+(p^{\frac{m-1}{2}}+1)+(q^{\frac{m-1}{2}}+1)+1$，后面三项显然都可以总体计算，因为是二次剩余的数只有 $[1,p-1]$ 中的恰好一半，会恰好抵消完，所以第二三项的总和就是零，而最后一项的和是 $m$。

化为 $m+\sum_{p+q \equiv x}(pq)^{\frac{m-1}{2}}=m+\sum_{p=0}^{m-1}(p(x-p))^{\frac{m-1}{2}}$，因为**一个数在除去一个平方数之后并不影响其是否仍然为二次剩余**，化为 $m+\sum_{p=1}^{m-1}(\frac{x}{p}-1)^{\frac{m-1}{2}}$，因为 $\frac{x}{p}$ 取遍 $[1,m-1]$，所以 $\frac{x}{p}-1$ 取遍 $[0,m-2]$，而根据之前的结论 $[1,m-1]$ 这个的值为 $0$，所以这一部分的值就是 $m-(-1)^{\frac{m-1}{2}}$。

而当 $x=0$ 时，$\frac{x}{p}$ 不取遍 $[1,m-1]$，需要特殊处理。因为 $p^2+q^2 \equiv 0 \pmod m$，所以 $p^2 \equiv -q^2 \pmod m$，要求 $-q^2$ 是二次剩余。显然，$(q^2)^{\frac{m-1}{2}}=q^{m-1}=q^{\varphi(m)}\equiv 1\pmod m$，所以仅需要考虑 $\frac{m-1}{2}$ 的正负即可。这里要注意一下 $0$。

把上面的所有部分拼起来即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int prime[10000007], b[10000007], ccnt, t, n, m;
int ans = 1;
inline int sol(int p, int q) {
	if (!q) {
		if (p % 4 == 1) return 2 * p - 1;
		return 1;
	}
	return p - (p % 4 == 1 ? 1 : -1);
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	for (int i = 2; i <= 10000000; i++) {
		if (!b[i]) {
			b[i] = i;
			prime[++ccnt] = i;
		}
		for (int j = 1; j <= ccnt && i * prime[j] <= 10000000; j++) {
			b[i * prime[j]] = prime[j];
			if (!(i % prime[j])) break;
		}
	}
	cin >> t;
	while (t--) {
		cin >> n >> m;
		ans = 1;
		while (n != 1) {
			ans *= sol(b[n], m % b[n]);
			n /= b[n];
		}
		cout << ans << "\n";
	}

}
```

---

## 作者：hyman00 (赞：0)

# P6610 题解

[题面](https://www.luogu.com.cn/problem/P6610) 

首先，根据 $p$ 是奇数，且不包含平方因子，可以想到对 $p$ 中每一个质因数分别作为模数分别求一遍答案。

容易证明，最终的答案就是把它们全乘起来，可以使用 CRT 证明。

以下默认 $p$ 为素数

接着，不妨设 $f(a)=[\exists b,b^2\equiv a\pmod p]$，即 $a$ 是否是二次剩余。

考虑分讨 $x$ 是否为 $0$。

- $x=0$

那么所求即为：
$$
1+4\sum_{i=1}^{p-1}f(i)f(-i)
$$
如果 $f(-1)=0$ ，那么 $f(i),f(-i)$ 不可能同时是 $1$，则原式就等于 $1$。

否则，有 $f(i)=f(-i)$，原式等于 $2p-1$。

另外，根据某些结论可知，$f(-1)=0$ 等价于 $p\equiv3\pmod4$。

- $x\ne 0$

会稍微复杂一点。

也可以类似地列出式子：
$$
4f(x)+4\sum_{i\ne0,i\ne x}f(i)f(x-i)
$$
这个看上去不好求，但是根据欧拉判别准则公式，有 $f(a)$ 的一个表达式：
$$
f(a)=\frac{(a^{\frac{p-1}2}\mod p)+1}{2}
$$
发现原式右边的 $\sum$ 里的和不超过 $p-2$，可以在模 $p$ 意义下计算。

下面令 $q=\frac{p-1}2$，且放在模 $p$ 意义下计算
$$
\begin{aligned}
\sum_{i\ne0,i\ne x}f(i)f(x-i)&=\sum_{i\ne0,i\ne x}\frac{i^q+1}{2}\frac{(x-i)^q+1}{2}\\
&=\sum_{i\ne0,i\ne x}\frac14(i^q+1)((x-i)^q+1)\\
&=\frac14\sum_{i\ne0,i\ne x}i^q(x-i)^q+i^q+(x-i)^q+1
\end{aligned}
$$
对四项分别求和：
$$
\sum_{i\ne0,i\ne x}i^q(x-i)^q=\sum_{i\ne0,i\ne x}i^{2q}(\frac xi-1)^q=\sum_{i\ne0,i\ne x}(\frac xi-1)^q=-(-1)^q
$$

$$
\sum_{i\ne0,i\ne x}i^q+(x-i)^q=2\sum_{i\ne0,i\ne x}i^q=-2x^q
$$

$$
\sum_{i\ne0,i\ne x}1=p-2
$$

加起来就是
$$
-2-2x^q-(-1)^q
$$
这时，已经可以算出答案的真实值了

当然，也可以一直带入回去，发现答案模 $p$ 为 $(-1)^q$，可以猜出就是 $p+(-1)^q$ （逃

upd：这里答案是 $4$ 的倍数，结合答案的上下界也可以得到 $p+(-1)^q$ 的结果

代码是容易的：

```c++
int f(int p,int x){
	if(p%4==1&&x)re p-1;
	if(p%4==1)re p+p-1;
	if(x)re p+1;
	re 1;
}
void run(){
	int p,x;
	cin>>p>>x;
	int ans=1;
	for(int i=2;i*i<=p;i++)if(p%i==0){
		ans*=f(i,x%i);
		p/=i;
	}
	if(p>1)ans*=f(p,x%p);
	cout<<ans<<"\n";
}
```

借鉴了若干之前的题解



---

## 作者：Composite_Function (赞：0)

感觉难度极为虚高的题目。

阅读之前保证自己熟知勒让德符号、高斯判别法、等幂和相关内容。下面会直接考虑本质一点的。

---

拆开每个素因子单独考虑：

直接考虑 $x^2$ 和 $y^2$ 是什么。写成求和式就是：

$$\sum_{i=0}^{p-1}\left(\left(\frac{i}{p}\right)+1\right)\left(\left(\frac{x-i}{p}\right)+1\right)$$

套路地打开：

$$\sum_{i=0}^{p-1}\left(\left(\frac{i(x-i)}{p}\right)+\left(\frac{i}{p}\right)+\left(\frac{x-i}{p}\right)+1\right)$$

注意到中间两项轮换一圈直接就没了。只要求：

$$\sum_{i=0}^{p-1}\left(\frac{i(x-i)}{p}\right)+p$$

套路地，先考虑这个式子模 $p$ 的结果：

$$\sum_{i=0}^{p-1}\left(\frac{i(x-i)}{p}\right)\equiv\sum_{i=0}^{p-1}(i(x-i))^{\frac{p-1}{2}}\equiv\sum_{i=0}^{p-1}([z^{p-1}]((z(x-z))^{\frac{p-1}{2}}))(i)\equiv(-1)^{\frac{p+1}{2}}(\operatorname{mod}p)$$

对于 $x\not\equiv0(\operatorname{mod}p)$，有 $\left(\frac{i(x-i)}{p}\right)$ 在 $i\equiv0,x(\operatorname{mod}p)$ 时都是 $0$，进而：


$$-p+1<\sum_{i=0}^{p-1}\left(\frac{i(x-i)}{p}\right)<p-1$$

于是根据大小关系可知：

$$\sum_{i=1}^{p-1}\left(\frac{i(x-i)}{p}\right)=(-1)^{\frac{p+1}{2}}$$

对于 $x=0$，有：

$$\sum_{i=0}^{p-1}\left(\frac{i(x-i)}{p}\right)=\sum_{i=1}^{p-1}\left(\frac{-1}{p}\right)=(p-1)(-1)^{\frac{p-1}{2}}$$

那么就做完了。

---


# [Code+#7] 六元环

## 题目描述

qwqwq。

------------

给定序列 $a_0, a_1, \dots, a_n, a_{n+1}$；满足 $a_0 = a_{n+1} = +\infty$，$a_1, a_2, \dots, a_n$ 在输入中给出；

对 $1\le x\le n$，称 $\max_{0\le i<x, a_i\ge a_x} i$ 和 $x$ 是相邻的，且 $\min_{x< i\le n+1, a_i>a_x} i$ 和 $x$ 是**相邻**的；如果 $x$ 和 $y$ 相邻，则 $y$ 和 $x$ 也相邻；

如果 $0 \le b_1, b_2, b_3, b_4, b_5, b_6\le n+1$，且 $b_i$ 和 $b_{i+1}$ 相邻，$b_1$ 和 $b_6$ 相邻，$b_i$ 互不相同，则称集合 $\{b_1,b_2,b_3,b_4,b_5,b_6\}$ 是一个六元环（即判断两个六元环是否相同时，不考虑 $b_i$ 的顺序）。

共有 $m$ 次修改操作，每次修改操作给出 $x\ y$，将 $a_x$ 改为 $a_x + y$；每次修改后要求输出六元环的个数；

以上提到的所有数值为整数，且 $1\le n, m\le 5\times 10^5, 1\le x\le n,1\le a_i, y\le 10^9$。

## 说明/提示

| 子任务 | 分数 |              限制              |
| :----: | :--: | :----------------------------: |
|  $1$   | $10$ |      $\max (n,m)\le 100$       |
|  $2$   | $10$ |      $\max (n,m)\le 2000$      |
|  $3$   | $20$ |     $\max (n,m)\le 50000$      |
|  $4$   | $20$ | for each operation, $x\le 100$ |
|  $5$   | $20$ | for each operation, $y\le 10$  |
|  $6$   | $20$ |                                |

## 样例 #1

### 输入

```
6
1 2 5 4 3 6
4
1 8
3 6
5 10
2 7```

### 输出

```
3
0
1
1```

# 题解

## 作者：gxy001 (赞：9)

题意首先可以转化为求笛卡尔树上大小为 $4$ 的连通块个数（对应六元环的六个点为这四个点和最上面节点代表区间的右端点 $+1$，左端点 $-1$），但不能包含根节点（六元环不包含 $0$，$n+1$），用一个简单的 dp 求解就行了。

修改操作体现在笛卡尔树上其实就是上旋，容易发现，对于一条方向相同的链，一个点上旋到链顶只会产生 $O(1)$ 的父子关系改变，也只会产生 $O(1)$ 的 dp 数组的改变。

所以直接用 LCT 去维护就行了。

核心代码：

```cpp
inline void upd(int x,int val){
	int l=ch[x][0],r=ch[x][1];
	cut(x,l),cut(x,r);
	v[x]+=val;
	while(fa[x]&&cmp(x,fa[x])){
		splay(x);
		if(s[x][0]){
			int fat=findnxt(x),h=fa[x];
			cut(h,x);
			if(d[x])link(h,l),l=fat;
			else link(h,r),r=fat;
			if(fa[fat]){
				int g=fa[fat];
				cut(g,fat),link(g,x);
			}
		}else{
			int fat=fa[x];
			cut(fat,x);
			if(d[x])link(fat,l),l=fat;
			else link(fat,r),r=fat;
			if(fa[fat]){
				int g=fa[fat];
				cut(g,fat),link(g,x);
			}
		}
	}
	link(x,l),link(x,r);
	if(!fa[x]) rt=x;
}
```

---

## 作者：UNVRS (赞：5)

**upd 2023/5/31：**对本文所述结构有了更为本质的认识，故重构。

**upd 2023/6/1：**换上了新的代码，勘误。

> 本题解旨在提供一种维护二叉树旋转信息的非 LCT 做法。对于本人而言，做法来源是退役学长 yyt 的出题*莱斯特城*，祝其人生之路璀璨。

## 题意

给定序列 $a_0,a_1,\dots a_{n+1}$ 其中 $a_0=a_{n+1}=+\infty$。

定义图 $G$ 中结点 $i,j$ 满足 $i\ne 0 \lor j\ne n+1$ 间有**双向边**当且仅当 $a_i$ 是 $a_j$ 前第一个大于等于 $a_j$ 的数，或 $a_i$ 是 $a_j$ 后第一个大于 $a_j$ 的数。

每次修改将某个 $a_1\cdots a_n$ 中的某个数 $+x$，修改后询问 $G$ 中的六元环数量。

## 题意转化

首先，容易想到使用笛卡尔树维护序列 $a$，显然笛卡尔树上的边全部在 $G$ 中，然后存在额外连边，它们满足在笛卡尔树上是一个转折的关系（左儿子的右链连向自己，与右儿子的左链连向自己），容易发现 $G$ 为一个平面图。

对于六元环，其在 $G$ 上由四个三角形组成，通过对这四个三角形的联通情况进行分类讨论可以发现，一组联通的四个三角形与六元环间恰好存在对应关系。

我们用一个三角形在笛卡尔树中最深的结点表示这个三角形，即可将一组联通的四个三角形进一步转化为在笛卡尔树上的联通的四个点。

注意不存在边 $(0,n+1)$，需要将根节点删除。

如果不存在修改，该计数可以在每个点向下记录下一层结点数与下下层结点数解决，我们接下来考虑如何修改。

---

由于修改只会变大，且中序遍历不变，于是这可以描述为修改点在笛卡尔树上进行上旋。

现在有一个结点 $x$ 父亲为 $y$ 旋转到原先 $z$ 的位置， 满足过程中旋转方向不变，对于笛卡尔树上的边仅有 $x$，$x$ 的一个儿子、$y$、$z$ 与其的父亲它们的 $O(1)$ 的父子关系被改变，同样的贡献的改变量也是 $O(1)$ 的。

我们假设这之后 $x$ 的旋转方向改变，那么称 $y$ 是一个转折点。

对于转折点的数量，lxl 通过势能分析证明了其复杂度为 $O(n\log n)$，不过笔者并未看到具体的证明过程，加上太菜了以及不是本文重点 ~~故先咕这~~，不补了好像直接套 LCT 的分析就行，但是我不会分析 LCT 而且找不到资料。

## 数据结构

这显然是可以使用 LCT 维护的，但是毕竟本题的结构较为静态（中序遍历不变），考虑是否存在更为简单的方式。

现在考虑一个大根笛卡尔树，其结点上有权值，为了避免文字太多导致疲劳记为 $val$ 吧。

对于结点 $x$，不妨设是父亲的左儿子，那么它向上第一个转折点的父亲在它的左边，且一定是左边第一个 $val$ 大于它的 $val$ 的点，这中间的其他结点均为 $x$ 的后代。

对于旋转不到转折点的情况，由于旋转方向上那一条链所有大于 $x$ 的结点的 $val$ 按顺次为一个递减序列（因为它们按顺序是 $x$ 的祖先），而其他点的 $val$ 均小于其临近的两个链上的结点的 $val$。

这是什么？单调性，二分一下。不单调的都不是我们要找的，并且会被我们要找的给挡住，所以可以直接查找最终要旋转到的值。

所有的找某个结点的操作均可在数据结构上二分解决，由于本题没有其它操作了，使用线段树维护即可。

## 拓展

对于一般的二叉树，我们仍然可以使用该方法。

对于一棵二叉树，其满足是自己深度的中序遍历构建的笛卡尔树，对于连续的不变向旋转，可以等价于两个区间操作（以左旋为例）：

1. 从链顶的子树最左到这个点父亲的所有点深度加一。
2. 这个点的子树中不包括左子树的所有点的深度减去旋转次数。

实际上可以随便构造序列，只要满足笛卡尔树的性质即可，使用深度便于处理向上旋转某个特定次数的情况。

一般而言这类维护转折的题目不太可能出现区间修改一类的操作，所以区间加是不太可能跟什么别的标记冲突的。

## 后记

可以看到通过这种方式，我们将旋转操作的维护静态化了。虽然并不能够得到一个更加强大的做法，因为该做法仍然依赖于操作中信息的改变量是有限的这一事实，而对于树本身形态的维护是不能超过动态树的能力范畴的。

虽然只使用了线段树，但由于 LCT 本身结构的特点适于维护树链，相比之下这种做法细节相当多，并不容易调试。

~~速度由于线段树二分的递归结构在本题上没有太多优势~~，可以写 zkw 线段树，实际总用时跑到 LCT 的一半（于是完全看不懂洛谷怎么算的总用时了）。

---

本文撰文仓促，难免有错误，若发现请务必吊打笔者。

由于笔者没有进行进一步的研究，如果有其它有趣的想法欢迎讨论。

## CODE

~~就这道题的话，代码或许以后补一份~~

~~代码有啦。~~

换成 zkw 线段树了。

```c++
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
using ll=long long;
const int N=(1<<19)+10,FSIZE=1<<24;
int n,m,ans,rt,sl[N],sr[N],fa[N],down[N][2],now[N];
vector<int> s;
ll p[N];
struct ST{
    struct node{
        int pl;
        ll operator()()const{return(p[pl]);}
        node operator+(const node &b)const{return(p[pl]>b()?*this:b);}
    }a[N<<2];
    int len;
    void build(){
        len=(2<<__lg(n-1))-1;
        for(int i=1;i<=n;++i) a[i+len]={i};
        for(int p=len;--p;a[p]=a[p<<1]+a[p<<1|1]);
    }
    int pre(int x,ll y){
        for(x+=len;x>1;x>>=1)
            if(a[(x>>=__builtin_ctz(x))^1]()>=y) break;
        if(x<2) return(0);
        for(x^=1;x<=len;)
            if(a[x=x<<1|1]()<y) x^=1;
        return(x-len);
    }
    int nxt(int x,ll y){
        for(x+=len;x>1;x>>=1)
            if(a[(x>>=__builtin_ctz(~x))^1]()>y) break;
        if(x<2) return(0);
        for(x^=1;x<=len;)
            if(a[x<<=1]()<=y) x|=1;
        return(x-len);
    }
    void reset(int x){for(x+=len;x>>=1;a[x]=a[x<<1]+a[x<<1|1]);}
}t;
char BuF[FSIZE],*InF=BuF,WuF[FSIZE],*OnF=WuF,ST[10],*STC=ST;
template<typename T>void read(T &x){
    for(;*InF<33;++InF);
    for(x=0;32<*InF;x=x*10+(*InF++^48));
}
void write(int x){
    for(!x&&(*OnF++=48);x;x/=10) *++STC=x%10^48;
    for(;STC!=ST;*OnF++=*STC--);
    *OnF++='\n';
}
int calc(int x){
    if(!x) return(0);
    int *w=down[x],*ls=down[sl[x]],*rs=down[sr[x]],re=ls[1]+rs[1];
    w[1]=ls[0]+rs[0];
    if((w[0]=!!sl[x]+!!sr[x])>1) re+=w[1];
    return(now[x]=re+(ls[0]>1)+(rs[0]>1));
}
void bfs(){
    s={rt};
    for(int i=0;i<(int)s.size();++i){
        int x=s[i];
        fa[sl[x]]=fa[sr[x]]=x;
        if(sl[x]) s.push_back(sl[x]);
        if(sr[x]) s.push_back(sr[x]);
    }
    for(int i=s.size();i;--i) ans+=calc(s[i-1]);
}
#define zg(l,r){\
    fa[s##l[f]=s##r[x]]=f;\
    fa[fa[s##r[x]=y]=x]=fy;}
void change(int x,int y,bool is){
    int f=fa[x],fy=fa[y];
    if(is) zg(l,r)
    else zg(r,l)
    (sr[fy]==y?sr[fy]:sl[fy])=x;
    for(int i=f,p=4;i!=y&&i&&--p;i=fa[i]){
        ans-=now[i];
        ans+=calc(i);
    }
    ans-=now[y]+now[x];
    ans+=calc(y);ans+=calc(x);
    for(int i=fy,p=3;i&&--p;i=fa[i]){
        ans-=now[i];
        ans+=calc(i);
    }
}
void rotate(int x,ll &now,int add){
    for(;x!=rt;){
        int is=sl[fa[x]]==x,e=is?t.pre(x,now):t.nxt(x,now),s=e?is?sr[e]:sl[e]:rt;
        ll sp=p[s]+(s<x);
        if(sp<=now+add){
            change(x,s,is);
            add-=sp-now;
            now=sp;
            if(s==rt) rt=x;
        }else{
            int to=is?sl[t.nxt(x,now+add)]:sr[t.pre(x,now+add)];
            if(x!=to&&to) change(x,to,is);
            break;
        }
    }
    now+=add;
}
void buildC(){
    for(int i=1;i<=n;s.push_back(i++)){
        for(;s.size()&&p[i]>p[s.back()];s.pop_back()) sl[i]=s.back();
        if(s.size()) sr[s.back()]=i;
    }
    rt=s[0];
    for(int i=1;i<(int)s.size();++i) sr[s[i-1]]=s[i];
    bfs();
}
int main(){
    fread(BuF,1,FSIZE,stdin);
    read(n);
    for(int i=1;i<=n;++i) read(p[i]);
    buildC();
    t.build();
    read(m);
    for(int x,y;m--;){
        read(x);read(y);
        rotate(x,p[x],y);
        t.reset(x);
        write(ans-now[rt]);
    }
    fwrite(WuF,1,OnF-WuF,stdout);
    return(0);
}
```



---

## 作者：DaiRuiChen007 (赞：0)

# P6611 题解

**题目大意**

> 给定序列 $a_0\sim a_{n+1}$，其中 $a_0=a_{n+1}=+\infty$，对于所有 $x\in[1,n]$ 与 $\max\limits_{i\in[0,x),a_i\ge a_x}i$ 和 $\min\limits_{i\in(x,n+1],a_x<a_i} i$ 连双向边。
>
> $q$ 次修改使 $a_x\gets a_x+t$，每次求有多少个大小为 $6$ 的**点集**存在六元环。
>
> 数据范围：$n,q\le 5\times 10^5$。

**思路分析**

首先建大根笛卡尔树，注意到笛卡尔树上的每个大小为 $4$ 的连通块，加上联通块根节点的左右父亲必定构成一个六元环，且不存在其他可能构成方式。

因此答案等于笛卡尔树上大小为 $4$ 的连通块数量，但是不包含树根，因为 $0,n+1$ 之间不连边。

注意到每次 $a_x$ 变大相当于在笛卡尔树上不停上旋，暴力更新可以做到 $\mathcal O(nq)$。

但是复杂度过高，注意到 $a_x$ 要么向左上旋要么向右上旋，通过势能分析可以证明旋转方向改变次数总和为 $\mathcal O((n+q)\log n)$ 级别。

而注意到 $a_x$ 不停左旋到一个点上，树结构总的变化只有 $\mathcal O(1)$，更新的点数也只有 $\mathcal O(1)$。

问题变成如何快速求 $a_x$ 不断左旋会到哪里，先考虑这一段链的根在哪里，即求出 $a_x$ 左边 $\ge a_x$ 的第一个位置 $u$，$v=rs_u$ 就是这段链的根。

- 如果 $a_x\ge a_v$，那么直接旋转到根。
- 否则找到 $x$ 右边第一个 $>a_x$ 的位置 $w$，转到 $w$ 的左儿子即可。

右旋情况同理，为了减少常数，建议使用 zkw 线段树实现。

时间复杂度 $\mathcal O((n+q)\log^2n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=5e5+5;
int n,q,rt;
struct SegmentTree {
      const int N=1<<19;
      ll tr[1<<20];
      inline void add(int x,int v) {
            tr[x+=N]+=v;
            for(x>>=1;x;x>>=1) tr[x]=max(tr[x<<1],tr[x<<1|1]);
      }
      inline int lpos(int x,ll k) {
            for(x+=N+1;x>1;x>>=1) if((x&1)&&tr[x^1]>=k) break;
            if(x==1) return 0;
            for(x^=1;x<=N;) x=(tr[x<<1|1]>=k)?(x<<1|1):(x<<1);
            return x-N;
      }
      inline int rpos(int x,ll k) {
            for(x+=N-1;x>1;x>>=1) if((~x&1)&&tr[x^1]>=k) break;
            if(x==1) return n+1;
            for(x^=1;x<=N;) x=(tr[x<<1]>=k)?(x<<1):(x<<1|1);
            return x-N;
      }
}      TR;
ll a[MAXN],dp[MAXN][5],ans=0;
inline int cmp(int x,int y) { return x<y?a[x]<a[y]:a[x]<=a[y]; }
int ch[MAXN][2],fa[MAXN];
inline void upd(int u) {
      if(!u) return ;
      ans-=dp[u][4];
      bool ok=false;
      int ls=ch[u][0],rs=ch[u][1],cur;
      cur=dp[rs][1]+dp[ls][1];
      ok|=dp[u][2]!=cur,dp[u][2]=cur;
      cur=dp[rs][2]+dp[ls][1]*dp[rs][1]+dp[ls][2];
      ok|=dp[u][3]!=cur,dp[u][3]=cur;
      cur=dp[ls][3]+dp[ls][2]*dp[rs][1]+dp[ls][1]*dp[rs][2]+dp[rs][3];
      ok|=dp[u][4]!=cur,dp[u][4]=cur;
      ans+=dp[u][4];
      if(ok) upd(fa[u]);
}
int id[MAXN],stk[MAXN];
inline void init() {
      for(int i=1,tp=0;i<=n;++i) {
            bool add=false;
            while(tp&&cmp(stk[tp],i)) --tp,add=true;
            if(tp) ch[stk[tp]][1]=i;
            if(add) ch[i][0]=stk[tp+1];
            stk[++tp]=i;
      }
      iota(id+1,id+n+1,1),sort(id+1,id+n+1,cmp);
      rt=id[n],dp[0][0]=1;
      for(int i=1;i<=n;++i) {
            int u=id[i];
            fa[ch[u][0]]=fa[ch[u][1]]=id[i];
            dp[u][0]=dp[u][1]=1,upd(id[i]);
      }
}
inline void link(int f,int x,int c) { ch[f][c]=x,fa[x]=x?f:0; }
signed main() {
      scanf("%d",&n);
      for(int i=1;i<=n;++i) scanf("%lld",&a[i]),TR.add(i,a[i]);
      init(),scanf("%d",&q);
      for(int x,t;q--;) {
            scanf("%d%d",&x,&t),a[x]+=t;
            while(x!=rt) {
                  int f=fa[x];
                  if(cmp(x,f)) break;
                  if(x==ch[f][0]) {
                        int u=TR.lpos(f-1,a[f]),v=u?ch[u][1]:rt;
                        if(cmp(v,x)) {
                              link(f,ch[x][1],0);
                              link(x,v,1);
                              if(u) link(u,x,1);
                              else rt=x,fa[x]=0;
                        } else {
                              int w=TR.rpos(x+1,a[x]+1),y=ch[w][0];
                              link(f,ch[x][1],0);
                              link(x,y,1);
                              link(w,x,0);
                        }
                  } else {
                        int u=TR.rpos(f+1,a[f]+1),v=u<=n?ch[u][0]:rt;
                        if(cmp(v,x)) {
                              link(f,ch[x][0],1);
                              link(x,v,0);
                              if(u<=n) link(u,x,0);
                              else rt=x,fa[x]=0;
                        } else {
                              int w=TR.lpos(x-1,a[x]),y=ch[w][1];
                              link(f,ch[x][0],1);
                              link(x,y,0);
                              link(w,x,1);
                        }
                  }
                  upd(f),upd(x),upd(fa[x]);
            }
            TR.add(x,t);
            printf("%lld\n",ans-dp[rt][4]);
      }
      return 0;
}
```

---


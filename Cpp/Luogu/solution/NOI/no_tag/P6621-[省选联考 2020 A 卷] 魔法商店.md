# [省选联考 2020 A 卷] 魔法商店

## 题目背景

1s 512M

## 题目描述

笠笠和伦伦来到了一家魔法商店，这家商店内有 $n$ 件礼品，礼品从 $1 \sim n$ 编号，$i$ 号礼品的魅力值为 $c_i$，价格为 $v_i$。

两人希望购买一些礼品，但他们的要求比较奇怪：假设购买到的礼品集合为 $S=\{s_1,s_2,\dots,s_p\}(1\leq s_i\leq n)$，两人要求对于 $S$ 中任意的非空子集 $T=\{t_1,t_2,\dots,t_q\}$，它包含的所有礼品的魅力值异或和都不为零，即：$c_{t_1} \oplus c_{t_2} \oplus \cdots \oplus c_{t_q} \neq 0$。其中 $\oplus$ 是异或运算。在此基础上，两人还要求购买到的礼品数尽可能多。

例如：$c_1=1,c_2=2,c_3=5,c_4=6,c_5=7$。则 $S_1=\{2,3,5\}$ 不符合要求，因为 $c_2 \oplus c_3 \oplus c_5=0$。$S_2=\{1,2,3\}$ 与 $S_3=\{2,4,5\}$ 符合要求，其任意非空子集的异或和都不为零。$S_4=\{1,2\}$ 因为其包含的礼品数不是最多的。

满足两人要求的礼品集合可能很多，因此商店老板为两人挑选出了两个符合要求的礼品集合 $A$ 与 $B$（显然它们所含的礼品数相同），伦伦喜欢集合 $A$，但笠笠更喜欢集合 $B$。为了笠笠同意购买集合 $A$，伦伦决定使用魔法改变礼品价格。更具体地，伦伦能花费 $(x-v_i)^2$ 的魔力值，将 $i$ 号礼品的价格改为任意整数 $x$，每件礼品只能被改价一次。

伦伦希望改价后 $A$ 是所有符合要求的礼品集合之中价格总和最小的，且 $B$ 是所有符合要求的礼品集合之中价格总和最大的（一个礼品集合的价格总和为它包含的所有礼品的价格之和）。现在请你帮伦伦计算，他至少要花费多少魔力值才能完成他的目标。

## 说明/提示

#### 样例 1 解释

符合条件的礼品集合有：$\{1,2,3\},\{1,2,4\},\{1,2,5\},\{1,3,4\},\{1,3,5\},\{2,3,4\},\{2,4,5\},\{3,4,5\}$。

一个最优的改价方案为：$c_1=c_2=c_4=c_5=3$，$c_3=2$。

#### 样例 2

见附加文件中 `shop2.in` 与 `shop2.ans`。

#### 样例 3

见附加文件中 `shop3.in` 与 `shop3.ans`。

#### 数据范围

对于所有测试数据：$1\leq n\leq 1000$，$1\leq m\leq 64$，$1\leq c_i < 2^{64}$，$0\leq v_i\leq 10^6$。

每个测试点的具体限制见下表：

| 测试点编号 | $n \leq$ | $m \leq$ | 特殊限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1 \sim 3$ | $10$ | $4$ | $1 \leq v_i \leq 5$ |
| $4 \sim 6$ | $50$ | $2$ | $1 \leq v_i \leq 10$ |
| $7 \sim 10$ | $500$ | $30$ | $0 \leq v_i \leq 1$ |
| $11 \sim 12$ | $1000$ | $64$ | $A$ 与 $B$ 相同 |
| $13 \sim 20$ | $1000$ | $64$ | 无 |


## 样例 #1

### 输入

```
5 3
1 2 5 6 7
4 4 2 1 3
1 2 3
2 4 5```

### 输出

```
6```

# 题解

## 作者：灵梦 (赞：51)

参考 2018 年高睿泉的集训队论文《浅谈保序回归问题》。

## 保序回归问题

### 定义

保序回归问题是指，对于一个正整数 $p$，给定一个偏序关系（有向无环图），图中每个点 $i$ 有权值 $(w_i,y_i)$，你要给每个点赋上另一个权值 $f_i$，使得图中任意一条有向路径上的 $f_i$ 递增，并最小化回归代价:
$$
\sum_{i\in U} w_i|f_i-y_i|^p
$$
我们把上述问题称作 **$L_p$ 问题**。

举个简单的例子，[P4331](https://www.luogu.com.cn/problem/P4331) 这道题就可以转化为全序关系（链）上的 $L_1$ 问题，可以使用单调栈 + 堆来解决。但这种方法不能拓展到偏序关系上，所以这里不深入讨论。

### $L_p$ 均值与其性质

我们定义 $L_p$ 均值为使 $\sum\limits_{i\in U}w_i|k-y_i|^p$ 最小的 $k$，也就是所有 $f_i$ 相等时的最优取值。对目标式求导，解出其零点就是 $L_p$ 均值，这里给出 $L_1$ 均值为 $y_i$ 的带权中位数，$L_2$ 均值为 $y_i$ 的带权平均数 （$\left(\sum\limits_{i\in U}w_iy_i\right)\left/\left(\sum\limits_{i\in U}w_i\right)\right.$）。可以证明，当 $p>1$ 时，$L_p$ 均值是唯一的；且 $L_p$ 问题一定存在一组最优解，使得对于任意 $f_i$ 都可以找到某个点集，使它的 $L_p$ 均值等于 $f_i$。

### 整体二分 ###

应用整体二分的思想，可以得到一个求问题的近似解的算法。

我们在原问题的基础上加入一些限制。定义 $solve(U,l,r)$ 表示当前点集为 $U$，且 $f_i$ 的取值在区间 $[l,r]$ 内的 $L_p$ 问题。设 $mid=\lfloor(l+r)/2\rfloor$，如果我们能够知道 $U$ 的任意一组最优解中，有哪些点是 $\leq mid$ 的，就可以将当前问题划分成两个规模减半的子问题了。

尝试构造另一个问题。设开区间 $(a,b)$ 被 $[l,r]$ 包含，且 $U$ 的任意非空子集的 $L_p$ 均值都不在 $(a,b)$ 内。这个性质保证了对于任意的子问题，都存在一组最优解满足其所有元素均不在 $(a,b)$ 中。下面给出一个引理：

>  若 $solve(U,a,b)$ 的一组最优解为 $\tilde z$，且满足 $\tilde z_{i}\notin (a,b),\forall i\in U$。则存在 $solve(U,l,r)$ 的一组最优解 $z$，使得 $z_i\leq a$ 当且仅当 $\tilde z_i=a$。

证明：利用反证法。由于上面的性质，显然 $solve(U,a,b)$ 的解只有 $a$ 与 $b$ 两种取值。下面把 $\tilde z_i=a$ 的点称为 A 类点，$\tilde z_i=b$ 的点称为 B 类点，假设存在 B 类点 $i$ 满足 $z_i\leq a$。设点集 $U$ 的 $L_p$ 均值为 $k$，分两种情况讨论：

- 若 $k\geq b$，则可以发现对于一个 B 类点，它在区间 $(-\infty,k]$ 内的回归代价递减，而在区间 $[k,+\infty)$ 内的回归代价递增。设 $t$ 是满足 $z_i\leq a$ 的 B 类点中最大的 $z_i$，那么我们把所有 $z_i=t$ 的 B 类点移动到 $b$ 位置处，它们的回归代价变小，而所有点的相对大小关系不变。因此与 $z$ 是 $solve(U,l,r)$ 的一组最优解的假设矛盾。

- 若 $k\leq a$，则 $z_i\leq a$ 的 B 类点 $i$ 显然不会存在 A 类点 $j$ 满足 $z_i\leq z_j$ 这样的偏序关系。如果这样的 B 类点只有 $z_i=t$ 这一种取值，则其所有 $y_i\leq a$，所以将它们改为 A 类点回归代价会减小，且所有点的相对大小仍不发生改变。因此与 $\tilde z$ 是 $solve(U,a,b)$ 的一组最优解的假设矛盾。对于这些 B 类点的 $z_i$ 有多种取值的情况，则考虑设点集 $V=\{i\mid z_i<t,\tilde z_i=b\}$，其 $L_p$ 均值为 $k'$，如果 $k'\leq t$ 则可以将 $V$ 中 $z_i$ 最大的点调整为 A 类点得到 $solve(U,a,b)$ 的一组更优解；否则类似第一种情况，将 $V$ 中的一些 $z_i$ 调整到 $k'$ 处得到一组不劣于 $solve(U,l,r)$ 的答案，如果没有比原答案更优则显然 $V$ 中所有 $z_i$ 的取值相同，重复上述过程即可导出矛盾。

因为 $a<b$，所以如果 $U$ 中任意一点 $i$ 选择了 $b$，则其后继节点也都只能选 $b$。那么问题就转化为了一个最小权闭合子图问题，节点 $i$ 的权值为 $w_i[(b-y_i)^p-(a-y_i)^p]$。将权值取反可以转化为最大权闭合子图问题，这是一个经典的网络流模型，且可以根据残量网络构造方案。

回到原问题，考虑找到满足性质的区间 $(mid,mid+\epsilon)$，那么就可以由 $solve(U,mid,mid+\epsilon)$ 的最优解来确定 $U$ 中的哪些点在原问题的最优解中是 $\leq mid$ 的。但直接找到这样的区间比较麻烦，可能还需要跑浮点网络流，会遇到精度等一系列问题。

由于 $U$ 的任意非空子集的 $L_p$ 的并集是有限集，所以一定存在足够小的 $\epsilon$ 使得区间中没有这些元素。当 $\epsilon$ 无限趋近于 $0$ 时，节点 $i$ 的权值为 $w_i[(mid+\epsilon-y_i)^p-(mid-y_i)^p]$。把所有点的权值除以 $\epsilon$，最优方案不变，权值变为 $w_i(mid-y_i)^p$ 在 $mid$ 处的导数。当 $p=2$ 时，权值为 $2w_i(mid-y_i)$，于是问题得到了完美的解决。

## 本题题解 ##

题目中要求了大小关系的子集都是给定的 $n$ 个 01 向量的极大线性无关组。所以从某一组向量中拿走一个，线性空间维数会减一，也就能再加入一个向量。因此任意两组向量之间是可以由替换元素这个操作来互相转化的，并且替换的顺序没有限制。于是我们只需要从向量组 $A$ 的每个元素向能替换它的元素连边，向量组 $B$ 反之，即可构造出偏序关系。然后就可以跑 $L_2$ 问题了。

然后有个问题就是这题要求修改后的价格为整数，可以这样处理：当 $r-l=1$ 时，仍然是答案只有两种取值的情况，因此仍可以用转化成最小闭合子图问题，相应地每个点的权值设为选 $r$ 与选 $l$ 的代价差即可。

## 代码 ##

```cpp
#include <cstdio>
#include <queue>
using namespace std;
typedef unsigned long long ull;
const int MAXN=1005;
const int INF=1E9;
namespace MF
{
	struct Edge
	{
		int from, to, cap, flow;
		Edge(int u, int v, int c, int f):
			from(u), to(v), cap(c), flow(f) {}
	};
	int n, s, t, flow;
	vector<Edge> edges;
	vector<int> g[MAXN];
	int h[MAXN], cur[MAXN];
	void init(int v, int a, int b)
	{
		n=v, s=a, t=b, flow=0;
		edges.clear();
		for (int i=1; i<=n; i++) g[i].clear();
	}
	void addEdge(int from, int to, int cap)
	{
		edges.push_back(Edge(from, to, cap, 0));
		edges.push_back(Edge(to, from, 0, 0));
		g[from].push_back(edges.size()-2);
		g[to].push_back(edges.size()-1);
	}
	bool bfs()
	{
		queue<int> q;
		for (int i=1; i<=n; i++) cur[i]=h[i]=0;
		h[s]=1, q.push(s);
		while (!q.empty())
		{
			int u=q.front(); q.pop();
			for (int i=0; i<g[u].size(); i++)
			{
				Edge e=edges[g[u][i]];
				if (e.cap>e.flow&&!h[e.to])
					h[e.to]=h[u]+1, q.push(e.to);
			}
		}
		return h[t];
	}
	int dfs(int u, int f)
	{
		if (u==t) return f;
		for (int &i=cur[u]; i<g[u].size(); i++)
		{
			Edge &e=edges[g[u][i]];
			if (e.cap>e.flow&&h[e.to]==h[u]+1)
			{
				int d=dfs(e.to, min(f, e.cap-e.flow));
				if (d>0)
				{
					e.flow+=d;
					edges[g[u][i]^1].flow-=d;
					return d;
				}
			}
		}
		return 0;
	}
	void Dinic()
	{
		while (bfs())
			while (int f=dfs(s, INF)) flow+=f;
	}
}
namespace XB
{
	ull d[64];
	void clear()
	{
		for (int i=0; i<64; i++) d[i]=0;
	}
	int insert(ull x)
	{
		for (int i=63; i>=0; i--)
			if (x&1ll<<i)
				if (d[i]) x^=d[i];
				else return d[i]=x, i;
		return -1;
	}
}
ull c[MAXN];
int w[MAXN], a[66], b[66];
int p[MAXN], q[MAXN], t1[MAXN], t2[MAXN];
int f[MAXN];
vector<int> G[MAXN];
void solve(int l, int r, int L, int R)
{
	if (l>r) return;
	if (R-L==1)
	{
		MF::init(r-l+3, r-l+2, r-l+3);
		for (int i=l; i<=r; i++) q[p[i]]=i-l+1;
		for (int i=l; i<=r; i++)
		{
			int u=p[i], cost=2*(w[u]-L)-1;
			if (cost>0) MF::addEdge(MF::s, q[u], cost);
			else MF::addEdge(q[u], MF::t, -cost);
			for (int v: G[u]) if (q[v])
				MF::addEdge(q[u], q[v], INF);
		}
		for (int i=l; i<=r; i++) q[p[i]]=0;
		MF::Dinic();
		for (int i=l; i<=r; i++)
			if (!MF::h[i-l+1]) f[p[i]]=L;
			else f[p[i]]=R;
		return;
	}
	int mid=(L+R)/2;
	MF::init(r-l+3, r-l+2, r-l+3);
	for (int i=l; i<=r; i++) q[p[i]]=i-l+1;
	for (int i=l; i<=r; i++)
	{
		int u=p[i];
		if (mid<w[u]) MF::addEdge(MF::s, q[u], w[u]-mid);
		else MF::addEdge(q[u], MF::t, mid-w[u]);
		for (int v: G[u]) if (q[v])
			MF::addEdge(q[u], q[v], INF);
	}
	for (int i=l; i<=r; i++) q[p[i]]=0;
	MF::Dinic();
	int c1=0, c2=0;
	for (int i=l; i<=r; i++)
		if (!MF::h[i-l+1]) t1[++c1]=p[i];
		else t2[++c2]=p[i];
	for (int i=1; i<=c1; i++) p[l+i-1]=t1[i];
	for (int i=1; i<=c2; i++) p[l+c1+i-1]=t2[i];
	solve(l, l+c1-1, L, mid);
	solve(l+c1, r, mid, R);
}
int main()
{
//	freopen("shop.in", "r", stdin);
//	freopen("shop.out", "w", stdout);
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++) scanf("%llu", &c[i]);
	for (int i=1; i<=n; i++) scanf("%d", &w[i]);
	for (int i=1; i<=m; i++) scanf("%d", &a[i]);
	for (int i=1; i<=m; i++) scanf("%d", &b[i]);
	for (int i=1; i<=m; i++)
	{
		XB::clear();
		for (int j=1; j<=m; j++)
			if (j!=i) XB::insert(c[a[j]]);
		for (int j=1; j<=n; j++)
			if (j!=a[i])
			{
				int t=XB::insert(c[j]);
				if (~t) G[a[i]].push_back(j), XB::d[t]=0;
			}
	}
	for (int i=1; i<=m; i++)
	{
		XB::clear();
		for (int j=1; j<=m; j++)
			if (j!=i) XB::insert(c[b[j]]);
		for (int j=1; j<=n; j++)
			if (j!=b[i])
			{
				int t=XB::insert(c[j]);
				if (~t) G[j].push_back(b[i]), XB::d[t]=0;
			}
	}
	for (int i=1; i<=n; i++) p[i]=i;
	solve(1, n, 0, 1E6);
	ull ans=0;
	for (int i=1; i<=n; i++) ans+=1ll*(f[i]-w[i])*(f[i]-w[i]);
	printf("%llu\n", ans);
	return 0;
}
```

---

## 作者：xzggzh1 (赞：20)

这题后半部分可以直接套保守回归的板子，具体见 2018 年高睿泉的集训队论文《浅谈保序回归问题》 论文里讲的比我讲的好多了，本文将不在赘述保守回归算法的部分，重点讲一讲本题的剩余部分。

刚看到题解 ，又是 “拟阵” 啊，“极大线性无关组”这样令人劝退的名词，却没有一篇通俗朴素的题解，所以本蒟蒻就来讲一下我自己的理解，应该会比较好懂。

----

先考虑 $A$ ，$B$ 是同理的。注意到 $A$ 在题目中的描述是这样的：对于 $A$ 中任何子集，异或和都不是零，且 $A $ 是所有满足上述条件中最大的。

看一下 $A $ 的性质：对于 $i \not \in A $，$c_i$ 都可以表示为 $A$ 的子集 $Sub$ 的异或和（否则就可以加入 $A$ 那么原本的 $A$ 就不是最大的了）。换句话说，用 $A$ 中的子集的异或和可以表示出任何一个不在 $A$ 中的元素，并且这个子集是唯一的（如果不是唯一的，那么这两个子集的 并集减去交集 的异或和就是 $0$ 和题意不符）。

稍加思考发现我们无法完全枚举出所有符合题意的集合 $S$，所以我们考虑怎么对 $A$ 进行删减获得一个新的 $S$。 先考虑 $A$ 的一个子集 $Sub\subset A$ 若有 $\oplus_{j \in Sub} c_j=c_k$ 即 $Sub$ 的元素的异或和为 $c_k$  ，则 $k$ 可以替换任意一个 $c_j$ 。替换之后不会出现异或和为零的子集（因为本来没有异或和为零的子集，删减一个点不会出现异或和为零，之后加入 $c_k$ 若有异或和为零的子集，那么必然有 $\oplus_{j \in Sub'} c_j=c_k$ 即 $A $ 中含有一个新的不包括 $j$ 的子集异或和为 $c_k$ ，这样与上述结论相悖，所以原命题得证）。


那么 $A$ 是最小的花费的条件是 $v_k\ge \max_{i\in Sub}v_i$，表示 $k$ 的花费比 $Sub$ 中的任意一个花费都高，这个是必要条件，充分性的证明可以从替换的方面考虑（即不能用合法的替换把 $A$ 换成花费更小的，因为每次选 $A$ 外的元素换进 $A$ 中花费都是增加的）。由于性质可知，每一个 $k$ 都对应这这样一个 $S_k$ ，如何快速找到呢，这里可以用到线性基。


搞出 $A$ 的线性基 $d$ 和 $d_i$ 对应的 $q_i$ 表示 $\oplus_{j\in q_i}c_j=d_i$ 即 $d_i$ 是由哪些数异或出来的，那么对于每一个 $k$，都可以用线性基的基本操作来搞出对应的 $Sub_k$，然后把 $j \in Sub_k$ 与 $k$ 的大小关系当做有向边加入图中，对 $B$ 也如此操作就可以转换为：给一个无向图，每个点的权值都要比这个点能到达的点大，修改一个点的花费是 $(x-v_i)^2$ ($x$ 表示修改后，$v_i$ 表示修改前) ，问最少花费，这就成功变成一个 保守回归问题（见开头，这里不赘述）。



---

## 作者：AzusaCat (赞：12)

给定 $n$ 件物品，设第 $i$ 件物品的魅力值为 $c_i$，价格为 $v_i$。设所有魅力值构成的线性空间的基的大小为 $m$，给定两组基 $A,B$。你需要修改每件物品的价格（为非负整数），使得 $A$ 是所有基中价格和最小的，$B$ 是所有基中价格和最大的。对于第 $i$ 件物品，将其的价格修改为 $x_i$ 的代价为 $(x_i-v_i)^2$，最小化代价和。$n\leqslant 1000$，$m\leqslant 64$，$0\leqslant v_i\leqslant 10^6$。

根据简单线性代数内容，假设 $i$ 是某个 $A$ 外的元素，且 $c_i$ 恰好被 $A$ 中 $b_1,\dots,b_k$ 这些元素线性组合（异或）而成，则限制有 $x_i\geqslant x_{b_1},\dots,x_i\geqslant b_k$。对所有 $B$ 外的元素同理。不难发现满足所有这样的限制后一定合法，且限制构成了偏序关系，于是问题转化为 $L_2$ 保序回归问题。可以直接套用整体二分做法，每次二分分界点 $mid$ 后，取额外代价为 $mid$ 处的导数 $2(mid-v_i)$，转化为最小权闭合子图问题。但是由于本题要求 $x_i$ 都为非负整数，所以当可能的最优取值区间 $[l,r]$ 满足 $r=l+1$ 时，对于取 $mid+\epsilon$ 最优的部分在整数集上的最优解依旧可能是 $mid$，所以需要特判，把代价设为选择 $l$ 与 $r$ 的代价差，依旧是最小权闭合子图问题。

不难发现复杂度为 $O(\mathrm{maxflow}(n,nm)\log v)$，但是跑不满就是了。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef unsigned long long ll;
template<unsigned N,unsigned M> struct Maxflow
{
    int const inf=1e14;
    int maxflow,s,t,tot=1,target[M],pre[M],last[N],
    cap[M],deep[N],cur[N];
    queue<int>q;
    void add(int x,int y,int z)
    {
        target[++tot]=y;
        pre[tot]=last[x];
        last[x]=tot;
        cap[tot]=z;
        target[++tot]=x;
        pre[tot]=last[y];
        last[y]=tot;
        cap[tot]=0;
    }
    bool bfs()
    {
        for(int i=s;i<=t;i++)deep[i]=0,cur[i]=last[i];
        q.push(s);
        while(!q.empty())
        {
            int now=q.front();
            q.pop();
            for(int i=last[now];i;i=pre[i])
            {
                int tar=target[i];
                if(tar!=s&&cap[i]&&(!deep[tar]))
                    deep[tar]=deep[now]+1,q.push(tar);
            }
        }
        return deep[t];
    }
    int dfs(int x,int lim)
    {
        if((!lim)||x==t)return lim;
        int flow=0;
        for(int &i=cur[x];i;i=pre[i])
        {
            int tar=target[i];
            if(cap[i]&&deep[tar]==deep[x]+1)
            {
                int d=dfs(tar,min(lim,cap[i]));
                cap[i]-=d;
                cap[i^1]+=d;
                lim-=d;
                flow+=d;
                if(!lim)break;
            }
        }
        return flow;
    }
    void dinic(){while(bfs())maxflow+=dfs(s,inf);}
    void init(int n)
    {
        for(int i=0;i<n+5;i++)last[i]=0;
        tot=1;maxflow=0;
    }
};
struct BASE
{
    ll b[65],id[65];
    void insert(ll x,ll &y)
    {
        for(int i=63;i>=0;i--)
            if(x&(1ull<<i))
            {
                if(!b[i]){b[i]=x;id[i]=y;return;}
                x^=b[i],y^=id[i];
            }
    }
}B1,B2;
typedef vector<int> vec;
Maxflow<1005,1100005>g;
ll c[1005];
int n,m,a[65],b[65],delta[1005],w[1005],id[1005],res;
bool vis1[1005],vis2[1005],lk[1005][1005];
void solve(vec v,int l,int r)
{
    if(!v.size())return;
    if(r==l+1)
    {
        int cnt=0;
        g.init(v.size());
        g.t=v.size()+1;
        for(auto i:v)
        {
            id[i]=++cnt;
            delta[i]=(w[i]-r)*(w[i]-r)-(w[i]-l)*(w[i]-l);
            if(delta[i]<0)g.add(0,cnt,-delta[i]);
            else g.add(cnt,g.t,delta[i]);
        }
        for(auto i:v)
            for(auto j:v)
                if(lk[i][j])g.add(id[j],id[i],1e9);
        g.dinic();
        for(auto i:v)res+=g.deep[id[i]]?((w[i]-r)*(w[i]-r)):((w[i]-l)*(w[i]-l));
        return;
    }
    int mid=(l+r)>>1,cnt=0;
    g.init(v.size());
    g.t=v.size()+1;
    for(auto i:v)
    {
        id[i]=++cnt;
        delta[i]=2*(mid-w[i]);
        if(delta[i]<0)g.add(0,cnt,-delta[i]);
        else g.add(cnt,g.t,delta[i]);
    }
    for(auto i:v)
        for(auto j:v)
            if(lk[i][j])g.add(id[j],id[i],1e9);
    g.dinic();
    vec vl,vr;
    for(auto i:v)(g.deep[id[i]]?vr:vl).push_back(i);
    solve(vl,l,mid),solve(vr,mid,r);
}
signed main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)scanf("%llu",&c[i]);
    for(int i=1;i<=n;i++)scanf("%lld",&w[i]);
    ll tmp;
    for(int i=0;i<m;i++)scanf("%lld",&a[i]),vis1[a[i]]=1,B1.insert(c[a[i]],tmp=1ull<<i);
    for(int i=0;i<m;i++)scanf("%lld",&b[i]),vis2[b[i]]=1,B2.insert(c[b[i]],tmp=1ull<<i);
    for(int i=1;i<=n;i++)
        if(!vis1[i])
        {
            ll id=0;
            B1.insert(c[i],id);
            for(int j=0;j<m;j++)if(id&(1ull<<j))lk[i][a[j]]=1;//if i should be greater than a[j]
        }
    for(int i=1;i<=n;i++)
        if(!vis2[i])
        {
            ll id=0;
            B2.insert(c[i],id);
            for(int j=0;j<m;j++)if(id&(1ull<<j))lk[b[j]][i]=1;
        }
    vec v;
    for(int i=1;i<=n;i++)v.push_back(i);
    solve(v,0,1e6);
    cout<<res;
    return 0;
}
```

---

## 作者：EndSaH (赞：10)

[省选联考 A 卷题解集合](http://endsah.tk/blog/%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-A-%E5%8D%B7%E9%A2%98%E8%A7%A3/#more)

首先解决一下题目所给的关于线性基的问题。

在拟阵的理论中，有这样一个公理：

> 设 $A, B$ 是拟阵 $I$ 中的两个不相同的基，那么对于任意的 $x \in A - B$，存在 $y \in B - A$，使得 $A - {x} + {y}$ 是拟阵 $I$ 中的一个基。

感性理解的话相当于是，将 $A$ 这个基删掉一个 $x$ 之后，线性空间的维数会减去 $1$；$B$ 又是另一个极大线性无关子集，那么肯定能挑出来一个补进去，把 $A$ 的维数补回来。

所以，题目给的对 $A, B$ 集合的和是最小和最大值的限制就比较好解决了：

枚举 $x \in A$，看是否有元素 $y$ 能够加入 $A - {x}$ 这个线性无关集合内，如果能则从 $x$ 向 $y$ 连一条边，表示最后的 $v _x \le v _y$。$B$ 集合同理。

必要性是显然的；上面说的边只要有一个没连上，就会存在一个 $A - x + y$ 集合比 $A$ 更小。

充分性考虑利用上面那个公理，假设有一个与 $A$ 不同的基 $C$，那么将 $A - C$ 里面的元素应用公理一个个替换成 $C$ 中的元素，直到成为 $C$ 为止，可以发现一定满足小于等于的关系。

再考虑有了这些限制边后，怎么处理让 $(v _x - v' _x) ^2$ 最小的问题。（$v' _x$ 是原来的值）

这是个保序回归问题，考虑整体二分。一个点如果在当前情况中取 $mid$ 这个值最优，那么在最终答案，其应取 $mid$ 以下的值；否则会取 $mid + 1$ 以上的值（证明要看论文，但是感性理解起来挺对的……）

于是钦定所有点一开始为 $mid$，选择一个点相当于将其变为 $mid + 1$，那么小于等于的边就相当于选了这个点之后强制选择其相连的点；这是个经典的最小权闭合子图问题，网络流即可。

复杂度大概是 $O(n ^2 m \log V)$？不太会证明 $m$ 的上界，最粗略的估计是 $O(n B)$（$B$ 是指基的大小，这题里面是 $64$）。不过 Dinic 还是很难跑满 $O(n ^2 m)$ 的。

---

## 作者：Leasier (赞：3)

~~终于补完联合省选 2020 了（~~

------------

考虑用拟阵来描述一遍题意：

- $S$ 表示礼品集合，每种礼品的权值为其价格。
- $\mathcal{I}$ 表示所有不存在魅力值异或和为 $0$ 的 $S$ 的子集的集合。**特别地，$\emptyset \in \mathcal{I}$。**
- 有拟阵 $M = (S, \mathcal{I})$。
- 你可以将某个权值为 $v$ 的礼品的权值修改为 $v'$，代价为 $(v' - v)^2$，且一个礼品只能修改一次。
- 给定 $M$ 上的基 $A \neq B$，求最小代价，使得 $A$ 恒为 $M$ 的最小权独立集，$B$ 恒为 $M$ 的最大权独立集。

假定 $A$ 不是最小权独立集，我们尝试将 $A$ 外的一个元素 $(c', v')$ 加入 $A$。

由于 $A$ 是 $M$ 的一个基，加入一个新元素后必然成环，则我们需要舍去环上的一个元素。

若我们想要钦定进行一次这样的操作后 $A$ 的权值不变小，则对于每一个可以被舍弃的 $(c, v)$，新加入的 $(c', v')$ 必然满足 $v' \geq v$。

那如果进行多次这样替换元素的操作呢？注意到此时每一步都需要满足上述偏序关系，且用一个新元素去替换另一个新元素的操作可以被避免；由基交换定理可知：所有基都可以这样一步一步交换得到；则我们只需要考虑 $A$ 中原有元素的替换。

$B$ 同理，则我们相当于需要解决下面这个问题：

- 有长为 $n$ 的整数序列 $v'$。
- 给出若干限制 $v'_x \leq v'_y$。
- 求 $\displaystyle\min_{v'} \sum_{i = 1}^n (v'_i - v_i)^2$。

这显然是一个 $L_2$ 的保序回归问题，整体二分 + 最大权闭合子图即可。时间复杂度为 $O(nm \log w_1 + \operatorname{flow}(n, nm) \log \max(n, w_2))$，其中 $w_1$ 为值域 $2^{64}$，$w_2$ 为值域 $10^6$。

由于这里要求 $v'$ 为**整数序列**，我们不必二分到实数。

代码：
```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

typedef struct {
	ull a[67];
	
	inline void init(){
		for (register int i = 0; i <= 63; i++){
			a[i] = 0;
		}
	}
	
	inline void insert(ull x){
		for (register int i = 63; i >= 0; i--){
			if (x >> i & 1){
				if (a[i] == 0){
					a[i] = x;
					return;
				}
				x ^= a[i];
			}
		}
	}
	
	inline bool check(ull x){
		for (register int i = 63; i >= 0; i--){
			if (x >> i & 1){
				if (a[i] == 0) return true;
				x ^= a[i];
			}
		}
		return false;
	}
} LinearBasis;

typedef struct {
	int nxt;
	int end;
	int dis;
} Edge;

int cnt;
int v[1007], a[1007], b[1007], from[128007], to[128007], v_[1007], head[1007], dis_cnt[1007], dis[1007], cur_edge[1007];
ull c[1007];
bool mark[1007], vis[1007];
Edge edge[258007];
queue<int> q;
vector<int> vec;

inline void init1(int n){
	cnt = 1;
	for (register int i = 0; i <= n; i++){
		head[i] = dis_cnt[i] = 0;
		dis[i] = 0x7fffffff;
		vis[i] = false;
	}
}

inline void init2(int n){
	for (register int i = 0; i <= n; i++){
		cur_edge[i] = head[i];
	}
}

inline void add_edge(int start, int end, int dis){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
}

inline void bfs(int start){
	dis[start] = 0;
	q.push(start);
	while (!q.empty()){
		int cur = q.front(), dis_i = dis[cur] + 1;
		q.pop();
		dis_cnt[dis[cur]]++;
		for (register int i = head[cur]; i != 0; i = edge[i].nxt){
			int x = edge[i].end;
			if (dis[x] == 0x7fffffff){
				dis[x] = dis_i;
				q.push(x);
			}
		}
	}
}

int dfs1(int u, int flow, int start, int end, int n){
	if (u == end) return flow;
	int ans = 0;
	for (register int i = cur_edge[u]; i != 0; i = edge[i].nxt){
		cur_edge[u] = i;
		if (edge[i].dis != 0){
			int x = edge[i].end;
			if (dis[u] == dis[x] + 1){
				int t = dfs1(x, min(flow - ans, edge[i].dis), start, end, n);
				edge[i].dis -= t;
				edge[i ^ 1].dis += t;
				ans += t;
				if (ans == flow || dis[start] == n) return ans;
			}
		}
	}
	cur_edge[u] = head[u];
	if (--dis_cnt[dis[u]] == 0) dis[start] = n;
	dis_cnt[++dis[u]]++;
	return ans;
}

inline int isap(int start, int end, int n){
	int ans = 0;
	bfs(end);
	while (dis[start] < n) ans += dfs1(start, 0x7fffffff, start, end, n);
	return ans;
}

void dfs2(int u){
	vis[u] = true;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		if (edge[i].dis != 0){
			int x = edge[i].end;
			if (!vis[x]) dfs2(x);
		}
	}
}

void solve(int n, int cnt, int l, int r, vector<int> vec){
	if (vec.empty()) return;
	int size = vec.size();
	if (l == r){
		for (register int i = 0; i < size; i++){
			v_[vec[i]] = l;
		}
		return;
	}
	int end = n + 1, mid = (l + r) >> 1;
	vector<int> v1, v2;
	init1(end);
	for (register int i = 1; i <= n; i++){
		mark[i] = false;
	}
	for (register int i = 0; i < size; i++){
		int val = (mid - v[vec[i]]) * 2 + 1;
		mark[vec[i]] = true;
		if (val > 0){
			add_edge(0, vec[i], val);
			add_edge(vec[i], 0, 0);
		} else if (val < 0){
			add_edge(vec[i], end, -val);
			add_edge(end, vec[i], 0);
		}
	}
	for (register int i = 1; i <= cnt; i++){
		if (mark[from[i]] && mark[to[i]]){
			add_edge(to[i], from[i], 0x7fffffff);
			add_edge(from[i], to[i], 0);
		}
	}
	init2(end);
	isap(0, end, end + 1);
	dfs2(0);
	for (register int i = 0; i < size; i++){
		if (vis[vec[i]]){
			v1.push_back(vec[i]);
		} else {
			v2.push_back(vec[i]);
		}
	}
	solve(n, cnt, l, mid, v1);
	solve(n, cnt, mid + 1, r, v2);
}

inline ll sqr(int n){
	return (ll)n * n;
}

int main(){
	int n, m, cnt = 0;
	ll ans = 0;
	cin >> n >> m;
	for (register int i = 1; i <= n; i++){
		cin >> c[i];
	}
	for (register int i = 1; i <= n; i++){
		cin >> v[i];
	}
	for (register int i = 1; i <= m; i++){
		cin >> a[i];
	}
	for (register int i = 1; i <= m; i++){
		cin >> b[i];
	}
	for (register int i = 1; i <= m; i++){
		LinearBasis lb;
		lb.init();
		for (register int j = 1; j <= m; j++){
			if (j != i) lb.insert(c[a[j]]);
		}
		for (register int j = 1; j <= n; j++){
			if (lb.check(c[j])){
				cnt++;
				from[cnt] = a[i];
				to[cnt] = j;
			}
		}
	}
	for (register int i = 1; i <= m; i++){
		LinearBasis lb;
		lb.init();
		for (register int j = 1; j <= m; j++){
			if (j != i) lb.insert(c[b[j]]);
		}
		for (register int j = 1; j <= n; j++){
			if (lb.check(c[j])){
				cnt++;
				from[cnt] = j;
				to[cnt] = b[i];
			}
		}
	}
	for (register int i = 1; i <= n; i++){
		vec.push_back(i);
	}
	solve(n, cnt, 0, 1e6, vec);
	for (register int i = 1; i <= n; i++){
		ans += sqr(v_[i] - v[i]);
	}
	cout << ans;
	return 0;
}
```

---


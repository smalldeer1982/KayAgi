# [PA 2015 Final] Edycja

## 题目描述

给定两个长度为 $n$ 的等长的小写字母串 A 和 B，你可以做以下两种操作：
1. 把 A 中某个位置上的字符修改成另一个字符，用时 1 秒。比如：```ababc``` 变成 ```ababa```。
2. 把 A 中某种字符全部修改成另一个种字符，用时 $c$ 秒。比如：```ababc``` 变成 ```acacc```。

同一时间只能做一个操作，求把 A 变成 B 的最小总耗时。

## 说明/提示

#### 样例解释   
先把所有的 a 都修改成 b，然后再把第 4 个位置的 b 和第 5 个位置的 c 都修改为 a。

#### 数据范围
对于所有数据，满足 $1\le c\le n\le10^6$。

## 样例 #1

### 输入

```
5 2
aaabc
bbbaa```

### 输出

```
4```

# 题解

## 作者：Fan_sheng (赞：35)

省选两天已经考完了，出考场的时候整个人都是麻着的。这大概是我退役前最后一篇题解了，写一道有价值的黑题纪念一下吧。

性质一：**一定存在一种最优的操作顺序，使得所有二操作都在一操作之前**。

证明：假如先把 $a[i]$ 用一操作改成 $X$，再用二操作把所有 $X$ 改成 $Y$。显然等价于先用二操作把所有 $X$ 改成 $Y$，再把 $a[i]$ 用一操作改成 $Y$。

性质二：**同一个字母不可能进行多于一次的二操作**。

证明：假如已经对字母 $a$ 用了二操作，此时场上就没有 $a$ 了。如果再进行一次二操作 $a\rightarrow b$，必然先前存在 $c\rightarrow a$。不如直接 $c\rightarrow b$。

---

对每个字母建点。每个点对 $(u,v)$，$u$ 向 $v$ 连一条单向边。其中边权为：$s[i]=u\land t[i]\neq v$ 的位置数，如果 $u\neq v$，再加上 $c$。之后会讲这张图的含义。

原问题就可以转化：我们有 $n$ 颗棋子，第 $i$ 颗所在节点代表当前 $i$ 位置的字符，初始放在 $s[i]$ 上。如果进行 $u\rightarrow v$ 的二操作，相当于把 $u$ 上所有棋子移到 $v$ 上。然而这些移过来的棋子还需要通过一操作改成 $t[i]$，再加上二操作的代价，总代价就是 $u$ 到 $v$ 的边权。

![](https://cdn.luogu.com.cn/upload/image_hosting/nhy9q4b0.png)

如果感觉抽象的话可以看看图。比如说 $b$ 上面有两颗棋子（分别是 $2$ 号和 $4$ 号）。我们可以用二操作把 $b$ 变成 $a$，但是 $4$ 号的终态应该是 $b$，需要再用一次一操作修改，总代价就是 $b\rightarrow a$ 的边权 $1+c$。

根据性质二，我们要为每个点都确定一条唯一的出边，形成内向基环树森林，每颗棋子都要能通过这些边到达它的终点，同时总代价最小。考虑每个点都先贪心地选最小边权出边，看看会发生什么。

- 对于一棵树（根节点自环），按反拓扑序依次挪动棋子就好了，不会产生任何冲突。

![](https://cdn.luogu.com.cn/upload/image_hosting/2z6yxe9v.png)

- 对于一棵基环树（如上图），只借助基环树上的边是不行了。可以考虑先把 $a$ 上的棋子通过二操作挪到 $d$ 上，这样 $a$ 节点空出来，就不会冲突了。算出来代价和原来一样。

![](https://cdn.luogu.com.cn/upload/image_hosting/oiiiia8r.png)

- 对于一个大小 $>1$ 的环，由于不存在叶子节点，必须借助环外的一个点来“中转”才行。如果森林中存在大小 $>1$ 的树/基环树，可以先操作完那棵树/基环树，其叶子节点会空出来。比如这张图，你可以把 $g$ 上棋子都挪到 $d$ 上，再挪到 $f$ 上，就不会冲突了。**这样做的代价比原来增加了 $c$**。**如果图上不存在大小 $>1$ 的树/基环树，就不可能完成挪动，无解**。

---

由于每个环都会额外贡献 $c$，我们开始的贪心策略可能不是最优的，考虑修改某些点的出边。

性质三：**存在一种最优的修改策略，使得新图不会产生原图没有的环**。

证明：如果出现了新环，环上一定存在一个点的出边被修改过。如果把它改回去，不仅边权会变小，同时新环也会被破开，肯定更优。

所以做法就出来了：先预处理出原图中所有的环。设 $dp[i][S][0/1]$ 表示当前要为第 $i$ 个点选择出边，$S$ 集合中的环已被破开，是否有点的出边被修改过，最小代价。

转移直接枚举出边，如果策略与原来不一样，就可以破开自己所在的环与对方所在的环。根据性质三，我们不需要考虑这么做是否会产生新的环。**$0/1$ 那一维用于规避无解情况，那种情况下必须要修改策略才行**。我的代码里这样会好写一点，你也可以用其他方式特判；**还要注意，全是自环是一种可行的方案**。

最多有 $13$ 个大小 $>1$ 的环，时间复杂度 $\mathbb O(\Sigma^2 2^{\frac{\Sigma}{2}})$。

Code

```cpp
#include<bits/stdc++.h>
#define H(x) ((x)-'a'+1)
using namespace std;
typedef long long ll;
int n,c,w[27][27],nxt[27],cnt,b[27],in[27],spj=1,W[27][27];
char s[1000003],t[1000003];
ll dp[27][1<<13][2];
inline void ckmin(ll &a,ll b){a=(a<b?a:b);}
inline void toposort(){
	for(int i=1;i<=26;i++)in[nxt[i]]++;
	queue<int>q;
	for(int i=1;i<=26;i++)if(!in[i])q.emplace(i),spj=0;
	while(q.size()){
		int h=q.front();q.pop();
		if(!(--in[nxt[h]]))q.emplace(nxt[h]);
	}
	for(int i=1;i<=26;i++)if(in[i]&&nxt[i]!=i){
		++cnt;
		int now=i;
		while(in[now]){
			in[now]=0,b[now]=cnt;
			now=nxt[now];
		}
	}
	if(!cnt){
		ll ans=0;
		for(int i=1;i<=26;i++)ans+=w[i][nxt[i]];
		printf("%lld",ans),exit(0);
	}
}
inline void DP(){
	memset(dp,0x3f,sizeof(dp)),dp[0][0][0]=0;
	for(int i=1;i<=26;i++)
	for(int S=0;S<(1<<cnt);S++)
	for(int t=0;t<2;t++)
	for(int j=1;j<=26;j++){
		int T=S;
		if(b[i]&&nxt[i]!=j)T|=(1<<(b[i]-1));
		if(b[j]&&(nxt[i]!=j||b[i]!=b[j]))T|=(1<<(b[j]-1));
		ckmin(dp[i][T][t|(nxt[i]!=j)],dp[i-1][S][t]+w[i][j]);
	}
	ll ans=LLONG_MAX;
	for(int S=0;S<(1<<cnt);S++)
	for(int t=spj;t<2;t++)
	ckmin(ans,dp[26][S][t]+1ll*c*(cnt-__builtin_popcount(S)));
	printf("%lld",ans),exit(0);
}
int main(){
	scanf("%d%d%s%s",&n,&c,s+1,t+1);
	for(int i=1;i<=n;i++)W[H(s[i])][H(t[i])]++;
	for(int i=1;i<=26;i++){
		w[i][0]=0x3f3f3f3f;
		int tot=0;
		for(int j=1;j<=26;j++)tot+=W[i][j];
		for(int j=1;j<=26;j++){
			w[i][j]=tot-W[i][j];
			if(i!=j)w[i][j]+=c;
			if(w[i][j]<w[i][nxt[i]])nxt[i]=j;
		}
	}toposort(),DP();
}
```

**我果然还是想在洛谷留下一点我的足迹。谢谢你看到这里，你们还有无限的可能，祝前程似锦。**

欢迎找 bug，虽然我不太可能有精力修就是了……

---

## 作者：qiuzx (赞：2)

容易发现一定存在一种最优方案是先做操作 2 再做操作 1，原因是如果在某个位置做了操作 1，那么将这个操作放在最后直接变成目标字符一定不会更劣。这样我们只需要考虑操作 2，那么最后所有和目标字符不同的位置全部用一次操作 1 即可。对于操作 2 来说，所有初始一样的字符最终还是一样的，所以可以对每种字符 $c$ 记一个 $p_c$ 表示原来 $c$ 字符最终全部变成了 $p_c$。

先考虑确定了所有的 $p_c$ 之后怎么计算答案。首先最终需要做的操作 1 数量可以直接算出来。然后对于所有 $c\ne p_c$ 都至少需要一次替换操作，所以我们只需要最小化额外的替换操作数量。若从 $c$ 向 $p_c$ 连一条边，则构成一个内向基环树森林。对于一个基环树，若它的环是一个自环，那么这个自环不用进行任何操作，而其它字符的按照深度从小到大依次向父亲直接变换就是合法的，因此没有额外操作。

否则若这个环不是一个自环，那么看起来必须要借助其它点来把这个环上的字符循环移位一次，所以必须要一步额外的操作。然而事实上并非如此。如果这个环上挂了至少一个点，如下图，那么可以先按照红色箭头做一次操作（即把挂的点在环上的前一个点变成它），将环变成链，这样总步数没有增加，所以这种情况下不需要额外代价。

<img src="https://cdn.luogu.com.cn/upload/image_hosting/gbw6s4cb.png" style="zoom:33%;" />

不过如果这个环上没有挂任何一个点，而且不是自环，那么需要先用一步额外操作将环破开，所以这样的每个连通块都需要一步额外操作。特别地，如果所有连通块都是这种，那么是不合法的，因为第一步无法进行。

这样我们有一个暴力的状压 dp，即直接对这个基环树的形态进行 dp。具体地，可以预处理出 $v_{i,j}$ 表示 $p_i=j$ 时所有初始为 $i$ 的位置的代价，这部分包含最终需要的操作 1 数量（即 $s_x=i$ 但 $t_x\ne j$ 的 $x$ 数量），以及如果 $j\ne i$ 所需要的一步替换的代价 $c$。注意这里不包含只连成一个环的额外代价 $c$。然后直接对基环树状压 dp 分三种不同的基环树形态讨论即可，复杂度 $O(2^kk^2)$ 或 $O(3^k)$，其中 $k=|\Sigma|$。

如果需要优化这个做法，就不能直接考察基环树的形态。注意到如果没有额外代价，那么显然每个 $i$ 直接选择 $v_{i,j}$ 最小的 $j$ 即可，而额外代价产生的条件是连出一个不是自环的环，这样的环数量至多为 $\frac k2$，是很少的，所以考虑从这里入手解决问题。

具体来说，我们先按照 $v_{i,j}$ 贪心选最小的点连出一个基环树森林，然后考虑在上面调整来减小额外代价。我们称这种情况下产生额外代价的环为坏环，由于坏环至多 $\frac k2$ 个，所以可以记 $dp_{i,S}$ 表示考虑前 $i$ 个点，$S$ 集合中的坏环通过改变某些点的出边已经不存在的最小总代价（不含后面可能存在的额外代价）。这样转移是容易的，直接枚举 $i$ 的出边 $j$，考察是否会使得 $i$ 或 $j$ 所在的环不存在即可。计算答案也是容易的，枚举 $S$ 那么不在 $S$ 中的其它坏环依然存在，这些环就是带来额外贡献的环，可以直接算出代价。然而这样的问题在于我们可能会新连出坏的环，所以是不一定合法的。

但一个直觉是如果一开始我们按照最小的选没有选出某个坏环，那么之后调整的时候如果出现了坏环一定不会更优。这个想法是正确的。假设我们调整出了一个原来不存在的坏环，不妨设这个环为 $c_1,c_2,\cdots,c_k$，那么其中必然存在一个 $c_i$ 原来的出边不是 $c_{i+1}$，任取一个 $c_i$ 将其出边改为原来的出边即可将这个环拆成一个链挂在另一个连通块上。由于坏环的定义必须是环上不挂任何东西，所以这样不仅破坏了一个坏环，也不会产生新的坏环，而且原始代价更优，所以一定不会更劣。因此这个 dp 虽然可能会转移出坏环，但是这些环一定不优，因此不会对 dp 值和答案产生影响。

唯一的例外情况就是原来所有环都是坏的，这种情况应当是不合法的，但我们在 dp 里无法检测这一点。因此直接在 dp 里再记一维表示是否和原始连边方法完全相同。则如果原来不合法那么最后算答案时全部相同的 dp 值不应被计入答案。这样复杂度是 $O(n+2^{\frac k2}k^2)$，其中 $k=|\Sigma|=26$​。

```cpp
#include <bits/stdc++.h>
#define INF 1000000000
#define LINF 1000000000000000000
#define mod 1000000007
#define F first
#define S second
#define ll long long
#define N ((1<<13)+10)
#define M 30
using namespace std;
ll n,m,c,v[M][M],nxt[M],dp[M][N][2],deg[M],cnt=0,bel[M];
string a,b;
bool vis[M];
void prework()
{
	ll i,j;
	queue<ll> qu;
	for(i=0;i<m;i++)
	{
		if(deg[i]==0)
		{
			qu.push(i);
		}
	}
	while(!qu.empty())
	{
		ll x=qu.front();
		qu.pop();
		deg[nxt[x]]--;
		if(deg[nxt[x]]==0)
		{
			qu.push(nxt[x]);
		}
	}
	for(i=0;i<m;i++)
	{
		if(deg[i]==1&&(!vis[i])&&nxt[i]!=i)
		{
			for(j=i;!vis[j];j=nxt[j])
			{
				bel[j]=cnt;
				vis[j]=true;
			}
			cnt++;
		}
	}
	return;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	ll i,j,k;
	cin>>n>>c>>a>>b;
	for(i=0;i<n;i++)
	{
		v[a[i]-'a'][b[i]-'a']++;
	}
	m=26;
	for(i=0;i<m;i++)
	{
		ll sum=0;
		for(j=0;j<m;j++)
		{
			sum+=v[i][j];
		}
		nxt[i]=0;
		for(j=0;j<m;j++)
		{
			v[i][j]=sum-v[i][j];
			if(i!=j)
			{
				v[i][j]+=c;
			}
			if(v[i][j]<v[i][nxt[i]])
			{
				nxt[i]=j;
			}
		}
		deg[nxt[i]]++;
	}
	bool isok=false;
	for(i=0;i<m;i++)
	{
		if(deg[i]!=1||nxt[i]==i)
		{
			isok=true;
		}
	}
	memset(bel,-1,sizeof(bel));
	prework();
	memset(dp,63,sizeof(dp));
	dp[0][0][1]=0;
	for(i=0;i<m;i++)
	{
		for(j=0;j<(1<<cnt);j++)
		{
			for(k=0;k<m;k++)
			{
				ll nw=j|(bel[i]>=0&&nxt[i]!=k?1<<bel[i]:0);
				if(bel[k]>=0&&(nxt[i]!=k||bel[i]<0))
				{
					nw|=1<<bel[k];
				}
				dp[i+1][nw][nxt[i]==k]=min(dp[i+1][nw][nxt[i]==k],dp[i][j][1]+v[i][k]);
				dp[i+1][nw][0]=min(dp[i+1][nw][0],dp[i][j][0]+v[i][k]);
			}
		}
	}
	ll ans=LINF;
	for(i=0;i<(1<<cnt);i++)
	{
		ans=min(ans,dp[m][i][0]+c*(cnt-__builtin_popcount(i)));
		if(isok)
		{
			ans=min(ans,dp[m][i][1]+c*(cnt-__builtin_popcount(i)));
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

---


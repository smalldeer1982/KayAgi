# [NOI2020] 命运

## 题目描述

**提示**：我们在题目描述的最后一段提供了一份简要的、形式化描述的题面。

在遥远的未来，物理学家终于发现了时间和因果的自然规律。即使在一个人出生前，我们也可以通过理论分析知晓他或她人生的一些信息，换言之，物理学允许我们从一定程度上“预言”一个人的“命运”。

简单来说，一个人的命运是一棵由时间点构成的有根树 $T$：树的根结点代表着出生，而叶结点代表着死亡。每个非叶结点 $u$ 都有一个或多个孩子 $v_1, v_2,\dots , v_{c_u}$，表示这个人在 $u$ 所代表的时间点做出的 $c_u$ 个不同的选择可以导向的不同的可能性。形式化的，一个选择就是树上的一条边 $(u, v_i)$，其中 $u$ 是 $v_i$ 的父结点。

一个人的一生是从出生（即根结点）到死亡（即某一个叶子结点）的一条不经过重复结点的路径，这条路径上任何一个包含至少一条边的子路径都是这个人的一段**人生经历**，而他或她以所有可能的方式度过一生，从而拥有的所有人生经历，都被称为**潜在的人生经历**。换言之，所有潜在的人生经历就是所有 $u$ 到 $v$ 的路径，满足 $u, v \in T$，$u \neq v$，并且 $u$ 是 $v$ 的祖先。在数学上，这样一个潜在的人生经历被记作有序对 $(u, v)$，树 $T$ 所有潜在的人生经历的集合记作 $\mathcal P_T$。

物理理论不仅允许我们观测代表命运的树，还能让我们分析一些潜在的人生经历是否是“重要”的。一个人所作出的每一个选择——即树上的每一条边——都可能是**重要**或**不重要**的。一段潜在的人生经历被称为重要的，当且仅当其对应的路径上存在一条边是重要的。我们可以观测到一些潜在的人生经历是重要的：换言之，我们可以观测得到一个集合 $\mathcal Q \subseteq \mathcal P_T$，满足其中的所有潜在的人生经历 $(u, v) \in \mathcal Q$ 都是重要的。

树 $T$ 的形态早已被计算确定，集合 $\mathcal Q$ 也早已被观测得到，一个人命运的不确定性已经大大降低了。但不确定性仍然是巨大的——来计算一下吧，对于给定的树 $T$ 和集合 $\mathcal Q$，存在多少种不同的方案确定每条边是否是重要的，使之满足所观测到的 $\mathcal Q$ 所对应的限制：即对于任意 $(u, v) \in \mathcal Q$，都存在一条 $u$ 到 $v$ 路径上的边被确定为重要的。

**形式化的**：给定一棵树 $T = (V, E)$ 和点对集合 $\mathcal Q \subseteq V \times V$ ，满足对于所有 $(u, v) \in \mathcal Q$，都有 $u \neq v$，并且 $u$ 是 $v$ 在树 $T$ 上的祖先。其中 $V$ 和 $E$ 分别代表树 $T$ 的结点集和边集。求有多少个不同的函数 $f$ : $E \to \{0, 1\}$（将每条边 $e \in E$ 的 $f(e)$ 值置为 $0$ 或 $1$），满足对于任何 $(u, v) \in \mathcal Q$，都存在 $u$ 到 $v$ 路径上的一条边 $e$ 使得 $f(e) = 1$。由于答案可能非常大，你只需要输出结果对 $998,244,353$（一个素数）取模的结果。


## 说明/提示

#### 样例 1 解释

共有 $16$ 种方案，其中不满足题意的方案有以下 $6$ 种：

- $(1, 2),(2, 3),(3, 5)$ 确定为不重要，$(3, 4)$ 确定为重要：集合 $\mathcal Q$ 中没有限制被满足。
- $(1, 2),(2, 3),(3, 4),(3, 5)$ 确定为不重要：集合 $\mathcal Q$ 中没有限制被满足。
- $(1, 2),(2, 3)$ 确定为不重要，$(3, 4),(3, 5)$ 确定为重要：集合 $\mathcal Q$ 中 $(1, 3)$ 没被满足。
- $(1, 2),(2, 3),(3, 4)$ 确定为不重要，$(3, 5)$ 确定为重要：集合 $\mathcal Q$ 中 $(1, 3)$ 没被满足。
- $(2, 3),(3, 5)$ 确定为不重要，$(1, 2),(3, 4)$ 确定为重要：集合 $\mathcal Q$ 中 $(2, 5)$ 没被满足。
- $(2, 3),(3, 4),(3, 5)$ 确定为不重要，$(1, 2)$ 确定为重要：集合 $\mathcal Q$ 中 $(2, 5)$ 没被满足。
- 其他方案下，集合 $\mathcal Q$ 中的限制都被满足了。


#### 样例 3

见选手目录下的 destiny/destiny3.in 与 destiny/destiny3.ans。

#### 样例 4

见选手目录下的 destiny/destiny4.in 与 destiny/destiny4.ans。

| 测试点编号 |  $n$ |  $m$ |  $T$ 为完全二叉树 |
| :-: | :-:| :-: |:-:|
|  $1\sim 4$ |  $\le 10$ |  $\le 10$ | 否 |
|  $5$ |  $\le 500$ |  $\le 15$ | 否 |
|  $6$ |  $\le 10^4$ |  $\le 10$ | 否 | 
|  $7$ |  $\le 10^5$ |  $\le 16$ | 否 |
|  $8$ |  $\le 5\times 10^5$ |  $\le 16$ | 否 |
|  $9$ |  $\le 10^5$ |  $\le 22$ | 否 |
|  $10$ |  $\le 5\times 10^5$ |  $\le 22$ | 否 |
|  $11$ |  $\le 600$ |  $\le 600$ | 否 |
|  $12$ |  $\le 10^3$ |  $\le 10^3$ | 否 |
|  $13\sim 14$ |  $\le 2\times 10^3$ |  $\le 5\times 10^5$ | 否 |
|  $15\sim 16$ |  $\le 5\times 10^5$ |  $\le 2\times 10^3$ | 否 |
|  $17\sim 18$ |  $\le 10^5$ |  $\le 10^5$ | 是 |
|  $19$ |  $\le 5\times 10^4$ |  $\le 10^5$ | 否 |
|  $20$ |  $\le 8\times 10^4$ |  $\le 10^5$ | 否 |
|  $21\sim 22$ |  $\le 10^5$ |  $\le 5\times 10^5$ | 否 |
|  $23\sim 25$ |  $\le 5\times 10^5$ |  $\le 5\times 10^5$ | 否 |

---

### 测试点约束

**全部数据满足**：$n \leq 5 \times 10^5$，$m \leq 5 \times 10^5$。输入构成一棵树，并且对于 $1 \leq i \leq m$，$u_i$ 始终为 $v_i$ 的祖先结点。

**完全二叉树**：在本题中，每个非叶结点都有左右子结点，且所有叶子结点深度相同的树称为满二叉树；将满二叉树中的结点按照从上到下、从左向右的顺序编号，编号最小的若干个结点形成的树称为完全二叉树。


## 样例 #1

### 输入

```
5
1 2
2 3
3 4
3 5
2
1 3
2 5```

### 输出

```
10```

## 样例 #2

### 输入

```
15
2 1
3 1
4 3
5 2
6 3
7 6
8 4
9 5
10 7
11 5
12 10
13 3
14 9
15 8
6
3 12
5 11
2 5
3 13
8 15
1 13```

### 输出

```
960```

# 题解

## 作者：Karry5307 (赞：93)

### 题意

给定一棵 $n$ 个点的树和 $m$ 条限制，你可以给树上的每一条边赋一个 $0$ 或 $1$ 的权值。对于所有限制 $(u,v)$（保证 $v$ 为 $u$ 的祖先） 你需要保证 $u$ 到 $v$ 上至少有一条边的权值为 $1$，求赋值方案数。

$\texttt{Data Range:}1\leq n,m\leq 5\times 10^5$

### 题解

神仙题，但是大多数题解直接摆结论所以对于我这种还带有 whk 后遗症的菜鸡来说理解起来有点困难，所以写一篇自认为比较清晰的。

首先第一个问题是怎么 DP。

注意到有一个 key observation 是这样的：对于某一个节点 $u$，如果 $(u,v_1)$ 被满足且 $v_2$ 深度比 $v_1$ 小且也为 $u$ 的祖先，那么限制 $(u,v_2)$ 也能被满足。（其实就是因为 $u$ 到 $v_2$ 的路径包含了 $u$ 到 $v_1$ 的路径）用人话表述一遍的话，就是**对于下端点在 $u$ 的所有限制来说，上端点深的能满足的话那么上端点浅的一定也能满足**。

同时，对于 $u$ 来说，只需要考虑限制的一端在 $u$ 的子树内部的情况。（因为不在子树 $u$ 内部的限制与 $u$ 子树内边的赋值情况无关），再加上刚刚的 key observation 我们就得出了状态表示：**$f_{u,i}$ 表示以 $u$ 为根的子树内，下端点在子树内并且没有被满足的限制中上端点的最深深度为 $i$，对 $u$ 的子树内赋值的方案数**。（对于那些没有考虑的边，你可以认为权值默认为 $0$）其中，$f_{u,0}$ 表示所有限制都被满足的方案数，所以答案为 $f_{1,0}$。

考虑转移，如果将 $v$ 的子树往 $u$ 的子树合并，讨论一下 $(u,v)$ 这条边的权值，如果为 $1$ 那么下端点在 $v$ 子树内上端点在 $v$ 子树外的限制全部都会满足，第二维的 $i$ 必须全部由 $u$ 来贡献，为 $0$ 则意味着两边贡献出来的 $f$ 第二维最大值必须为 $i$，写成表达式就会有：

$$f_{u,i}\gets \sum\limits_{j=0}^{dep_u}f_{u,i}f_{v,j}+\sum\limits_{j=0}^{i}f_{u,i}f_{v,j}+\sum\limits_{j=0}^{i-1}f_{u,j}f_{v,i}$$

第一个和式表示 $(u,v)$ 权值为 $1$，后面两个表示权值为 $0$，第三个和式减去上界的原因是 $f_{u,i}f_{v,i}$ 已经算过。

这个时候设 $g_{u,i}$ 表示 $\sum\limits_{j=0}^{i}f_{u,i}$，则转移可以写成这样：

$$f_{u,i}\gets f_{u,i}(g_{v,dep_u}+g_{v,i})+g_{u,i-1}f_{v,i}$$

然后我们就有 $O(n^2)$ 的解法了，[见此处](https://loj.ac/s/1017206)，所以考虑优化。

这个时候考虑线段树合并。合并的过程中借用一点 cdq 分治的思路，也就是说先合并左子树顺便更新 $g$，然后再合并右子树。然后因为每次转移是形如一个乘某个值再加某个值的情况，所以需要写一个乘法标记，时间复杂度 $O(n\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=5e5+51,MOD=998244353;
ll n,m,u,v,totn;
ll depth[MAXN],ls[MAXN<<5],rs[MAXN<<5],sm[MAXN<<5],tag[MAXN<<5],rt[MAXN];
vector<ll>vg[MAXN],link[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline void update(ll node)
{
	sm[node]=(sm[ls[node]]+sm[rs[node]])%MOD;
}
inline void spread(ll node)
{
	if(tag[node]!=1)
	{
		sm[ls[node]]=(li)tag[node]*sm[ls[node]]%MOD;
		sm[rs[node]]=(li)tag[node]*sm[rs[node]]%MOD;
		tag[ls[node]]=(li)tag[node]*tag[ls[node]]%MOD;
		tag[rs[node]]=(li)tag[node]*tag[rs[node]]%MOD;
		tag[node]=1;
	}
}
inline void change(ll l,ll r,ll pos,ll val,ll &node)
{
	!node?tag[node=++totn]=1:1;
	if(l==r)
	{
		return (void)(tag[node]=1,sm[node]=val);
	}
	ll mid=(l+r)>>1;
	spread(node);
	pos<=mid?change(l,mid,pos,val,ls[node]):change(mid+1,r,pos,val,rs[node]);
	update(node);
}
inline ll query(ll l,ll r,ll ql,ll qr,ll node)
{
	if(ql<=l&&qr>=r)
	{
		return sm[node];
	}
	ll mid=(l+r)>>1,res=0;
	spread(node);
	res=(res+(ql<=mid?query(l,mid,ql,qr,ls[node]):0))%MOD;
	res=(res+(qr>mid?query(mid+1,r,ql,qr,rs[node]):0))%MOD;
	return res;
}
inline ll merge(ll x,ll y,ll l,ll r,ll &su,ll &sv)
{
	if(!x&&!y)
	{
		return 0;
	}
	if(!x)
	{
		sv=(sv+sm[y])%MOD,tag[y]=(li)tag[y]*su%MOD;
		return sm[y]=(li)sm[y]*su%MOD,y;
	}
	if(!y)
	{
		su=(su+sm[x])%MOD,tag[x]=(li)tag[x]*sv%MOD;
		return sm[x]=(li)sm[x]*sv%MOD,x;
	}
	if(l==r)
	{
		ll cu=sm[x],cv=sm[y];
		sv=(sv+cv)%MOD,sm[x]=((li)sm[x]*sv+(li)sm[y]*su)%MOD;
		return su=(su+cu)%MOD,x;
	}
	ll mid=(l+r)>>1;
	spread(x),spread(y);
	ls[x]=merge(ls[x],ls[y],l,mid,su,sv);
	rs[x]=merge(rs[x],rs[y],mid+1,r,su,sv);
	update(x);
	return x;
}
inline void dfs(ll node,ll fa)
{
	depth[node]=depth[fa]+1;
	ll mxd=0,su,sv;
	for(register int i:link[node])
	{
		mxd=max(mxd,depth[i]);
	}
	change(0,n,mxd,1,rt[node]);
	for(register int i:vg[node])
	{
		if(i!=fa)
		{
			dfs(i,node),su=0,sv=query(0,n,0,depth[node],rt[i]);
			rt[node]=merge(rt[node],rt[i],0,n,su,sv);
		}
	}
}
int main()
{
	n=read();
	for(register int i=0;i<n-1;i++)
	{
		u=read(),v=read(),vg[u].emplace_back(v),vg[v].emplace_back(u);
	}
	m=read();
	for(register int i=1;i<=m;i++)
	{
		u=read(),v=read(),link[v].push_back(u);
	}
	dfs(1,0),printf("%d\n",query(0,n,0,0,rt[1]));
}
```

---

## 作者：zyc2003 (赞：81)

这一切 , 都是 $\lfloor$ **命运** $\rceil$ 石之门的选择 !

(中二一下 , 咳咳咳

### 本文摘要

- 简要介绍了 $32pts$ (容斥) 的做法 , 详细介绍了 $64(72)pts$ (dp 方程的推导 , 深度的离散化 (虚树)) 和 $100pts$ (整体dp , 线段树合并) 的解法 . 
- 由于我看各路大佬题解的线段树合并看了老半天没看懂 , 所以这一篇的线段树合并会讲的比较详细 , 可能更加适合像我一样没那么熟练链线段树合并的同学 .  
- 同时 , 对于 dp 方程的推出有**自然的**想法 , 并非跳跃式的直接给出状态设计 . (不过对大佬来说确实一点都不跳跃 
- 希望大家看得愉快 .

### 题意简述

题目中已经给出了形式化的描述 , 这里不再复述 . 为了下文叙述方便 , 我们把将一条边赋值为 $1$ 说成是**染了色** , 把题目给出的带限制的链有时候简称为一个**限制** . 

### $32pts$ : 容斥大法好 ! 

看到题目后 , 我一开始心态是崩的 : 我怎么只有 $n\times 2^n$ 的枚举算法 ? 完了呀 ... 但是你冷静一下 , 前面 $40pts$ 的 $m$ 都很小 - 也就是给定的**树链** $(u,v)$ 很少 , 有什么用呢 ? 

题目要求的是 : 所有给定的树链 , 其链上**至少**有 $1$ 条边被染色的方案数 . 我对着它冥思苦想 ... 没什么思路 , 不妨取问题的**补集** , 也就是逆向思维 ? 可以等价于任意染色/不染色的方案数 $(2^{n-1})$ , 减去 : 至少存在一条给定树链 , 其链上**没有**边被染色的方案数 . 

到了这里 , 就可以使用我们的容斥大法 . 枚举所有 $m$ 的子集 $S$ , 求出这个子集中**所有被给定树链覆盖的边都不能染色**的染色方案数 , 再乘以容斥系数 $(-1)^{|S|}$ 即可 .  该算法正确是因为 , 当 $|S|=0$ 时 , 我们**加上了**任意染色的方案数 $2^{n-1}$ : 此时所有合法的和不合法的方案都在里面 ; 当 $|S|=1$ 时 , 我们**减去了** 第 $1$ 条链 , 第 $2$ 条链 , $\dots$ , 第 $m$ 条链上没有任何一条边被染色的方案数 ; 但是这些链是会相交的 , 我们多减去了一些东西 , 所以我们还需要加上第 $i$ 条链和第 $j$ 条链均没有任何一条边被染色的方案数 ... 归纳地证明了容斥的正确性 . 写成式子 , 就是 : 

$$\sum_{S\subset Q} (-1)^{|S|} 2^{n-1-|\cup_S|}$$

其中 $Q$ 是题目给定的树链的集合 , $|\cup_S|$ 表示 $S$ 集合内的树链求交之后 , 覆盖的边数 .

而我们发现 , 覆盖一条链的操作可以用树链剖分维护 , 所以总复杂度为 : $\mathcal O(m\times 2^m \log^2n)$ , 也可以优化到 $\mathcal O(2^m \log^2n)$ (不过没什么用 , 得分没有变化 ... 所以我 $40pts$ 的美梦破灭了

### $64pts$ : dp 大法好 !

实际上容斥的做法 , 对于参加 NOI 的选手可能是小菜一碟的 . 那么更进一步的做法呢 ? 求方案数嘛 , 怎么想都和 dp 脱不了关系 . 而树上 dp 的设计肯定和子树有关 , 不妨先设计一个最 naive 的方程 : 

$f_{x,0/1}$ 表示 , 所有树链限制 $(u,v)$ , 其两个端点都在 $x$ 子树内的限制都已经被满足 , 而 $v$ 在 $x$ 子树内 , $u$ 在 $x$ 子树外的限制**没有/有** $(0/1)$ 被全部满足 , 的方案数 . 这是我们最初的想法 .

但是这是不可转移的 , 因为我们把所有链的信息浓缩在 $0/1$ 中 , 以至于我们从子节点 $y$ 向父节点 $x$ 转移时 , 我们无法确定边 $(x,y)$ 染色/不染色会造成的影响 . 主要影响是 , 当某个限制 $(u,v)$ 满足 $u=x$ , 且 $v$ 在 $y$ 的子树内时 , 从 $y$ 向 $x$ 的转移就出了问题 : 你不懂何时需要覆盖 $(x,y)$ 何时不需要 , 因为你不懂 $(u,v)$ 这个限制是否已经在 $y$ 的子树内得到满足 !

那我们尝试维护这个信息如何 ? 但是注意到 , $y$ 转移到 $x$ , $x$ 又会转移到 $x$ 的父亲 ... 这可能要求我们维护一个和深度有关的信息 . 一端 $u$ 在 $x$ 的子树外 , 一端 $v$ 在 $x$ 的子树内 , 那么显然所有 $u$ 都是 $x$ 的祖先 ... 等等 , 所有 $u$ 都是 $x$ 的祖先 ? 在看看题目的要求 : 所有给定链上至少有 $1$ 条边被染色 . 那么这就意味着 , 我们考虑所有尚未被满足的 $(u,v)$ , 且 $u$ 在 $x$ 子树外 , $v$ 在 $x$ 子树内 , 那么能使得它们合法的染色只可能是将 $(u,x)$ 中的某条边染色 ; 而最终情况下 , 必须让所有限制都合法 , 所以我们必须所有给 $u$ 中最深的 $(u_{\max},x)$ 中的某条边染色 ; 染色了 , 所有限制一并满足 ; 如果不是给 $(u_{\max},x)$ 上的某条边染色 , 那么 $(u_{\max},v)$ 这个限制将永远得不到满足 . 这就是其他题解中所说的 key observation .

所以 , 我们的 dp 方程新鲜出炉 : 设 $f_{x,i}$ 表示 $x$ 为根的子树中 , 两端点都在 $x$ 子树内的限制已经被满足 , 而对于尚未被满足的 $(u,v)$ , 且 $u$ 在 $x$ 子树外 , $v$ 在 $x$ 子树内 , 最深的 $u$ 的深度为 $i$ .

现在来考虑转移 . 首先 , 如果对于一个 $v$ , 题目给出了多个限制 $(u_1,v),(u_2,v)\dots$ , 那么最深的那个 $u$ 是有用的 . 设 $anc_v=u$ (ancestor , 祖先) , 当 $anc_v=0$ 时 , 说明没有限制 , 或者也可以认为是设置了虚点 $0$ , 该限制为 $(0,v)$ .  那么 , 对于 $f_{x,i}$ , 我们有 $\mathrm{dep}_{anc_x} \leq i < \mathrm{dep}_x$ , 因为对于限制 $(anc_x,x)$ , 无论你怎么给 $x$ 子树内的边染色 , 都不可能满足 ; 而 $i$ 也不能取到 $\mathrm{dep}_x$ (显然) . 

好 . 接下来推导 $y\rightarrow x$ 的转移 . 当处理到子节点 $y$ 的时候 , $f_{x,i}$ 的值如何变化 : 

$1.$ 对 $(x,y)$ 染色

那么所有端点 $v$ 在 $y$ 内的限制全部得到满足 . 所以贡献为 

$$f_{x,i}\times \sum_{\mathrm{dep}_{anc_y} \leq j < \mathrm{dep}_y} f_{y,j}$$

噢 , 为了方便 , 不妨设 $g_{x,i}$ 为 $f_{x,i}$ 的前缀和 : $g_{x,i}=\sum_{j=0}^i f_{x,i}$ , 由于 $ < \mathrm{dep}_{anc_x}$ 的部分都为 $0$ , 所以这个定义是合法的 . 

所以贡献为 : 

$$f_{x,i}\times g_{y,\mathrm{dep_y}-1}$$

$2.$ 对 $(x,y)$ 不染色

那么 , 如果 $y$ 中最深的限制是 $\leq i$ 的 , 那么合并后的子树的最深的限制仍然是 $i$ . 所以 , 贡献为 :

$$f_{x,i}\times g_{y,i}$$

但如果是 $>i$ 的 , 那么最深的限制可以有更浅的限制转移而来 , 贡献为 : 

$$g_{x,i-1}\times f_{y,i}$$

整合起来就是 : 

$$f_{x,i}\leftarrow f_{x,i}\times g_{y,\mathrm{dep_y}-1}+f_{x,i}\times g_{y,i}+g_{x,i-1}\times f_{y,i},\mathrm{dep}_{anc_x} \leq i < \mathrm{dep}_x$$

这样就有了 $\mathcal O(n^2)$ 的做法 . 但是注意到 , 有用的点 , 也就是作为限制的点 $u$ 是 $\mathcal O(\min(n,m))$ 级别的 . 所以 , 第二维 : 深度是可以离散化的 . 离散化后的第二维是  $\mathcal O(\min(n,m))$ 级别的 , 所有时空复杂度均为 $\mathrm O(n\min(n,m))$ , 可以拿到 $64pts$ 的好成绩 . 我对于这部分分有实现 , 下面是离散化这部分的代码 : 

```cpp
int main() {
	n=read();
	for(int i=1,x,y;i<n;++i) 
		x=read(),y=read(),add(x,y),add(y,x);
	dfs(1,0);
	m=read();dep[0]=0;
	for(int i=1;i<=m;++i) {
		int u=read(),v=read();
		anc[v]=dep[u] > dep[anc[v]] ? u : anc[v];
	}
	for(int i=1;i<=n;++i)
		if(anc[i])	rk[++cnt]=dep[anc[i]];
	sort(rk+1,rk+1+cnt),cnt=unique(rk+1,rk+1+cnt)-rk-1;
	rk[++cnt]=n;
	for(int i=1;i<=n;++i)
		dep[i]=lower_bound(rk+1,rk+1+cnt,dep[i])-rk;
	treedp(1,0);
	Writes(f[1][0]);
	return 0;
}
```

Q : 那么 $f,g$ 数组怎么开 ?

A : 当然是用 vector 啦 !

Q : 你为什么不用虚树 ? 你这样写 , $15,16$ 两个点会爆空间啊 ! $nm=10^9$ ... 

A : 我忘记虚树了 ... 用虚树的话 , 时空复杂度变为 $\mathcal O(\min(n,m)^2)$ , 足以解决 $72pts$ 的问题 .

### $100pts$ : 整体 dp - 线段树合并 !

好吧 , 这部分我无法自然地想出 qaq ... 我们对式子进行一些变化 : 

$$f_{x,i}\leftarrow f_{x,i}\times (g_{y,\mathrm{dep_y}-1}+ g_{y,i})+f_{y,i}\times g_{x,i-1}$$

发现是对 $f_{x,i}$ 乘上某个数在加上 $f_{y,i}$ 乘上某个数 , 但是所谓的"这个数"是会变的啊 ?

不要紧 . 我们仍然考虑线段树合并 . 一开始 , 令 $f_{x,\mathrm{dep}_{anc_x}}=1$ . 维护两个全局值 $sum_x,sum_y$ , 来表示 $f_{x,i}/f_{y,i}$ 的前缀和 . 前缀和可以以**引用**的形式 (引用变量 , 或者设为全局变量也可以) , 在进入叶子结点或者 $x=0$ 或者 $y=0$ 时更新 . 而后在合并 $x$ 的子树和 $y$ 的子树时 : 我们发现难点在于当 $x=0$ 或者 $y=0$ 时 , 应该怎么维护下面的值呢 ? 

当我们进入 $x=0$ 或者 $y=0$ 的结点时 , 看到我们的式子 , 就会发现 : $x=0,y\neq 0$ 时 , 说明在该结点内 $sum_x$ 将不会变化 , 且所有 $f_{x,i}$ 没有值 , 那么相当于整个子树全部同乘以一个数 :  $g_{x,i-1}$ ; 而当 $x\neq 0,y=0$ 时 , 说明在该结点内 $sum_y$ 将不会变化 , 且所有 $f_{y,i}$ 没有值 , 那么相当于整个子树全部同乘以一个数 : $g_{y,\mathrm{dep_y}-1}+ g_{y,i}$ ; 而 $x\neq 0,y\neq 0$ 时 , 显然我们会继续往下合并 , 只需要 pushup 即可 . 

而后需要注意 , 对于 $f_{x,i}$ , 由于只有 $\mathrm{dep}_{anc_x} \leq i < \mathrm{dep}_x$ 会有值 , 所以处理完子树转移后 , 我们需要将 $[0,\mathrm{dep_{anc_x}})$ 和 $[\mathrm{dep}_x,n]$ 区间赋值为 $0$ . (覆盖总是没问题的 , 不覆盖可能会出锅)  

综上 , 我们维护区间和和乘法标记即可 (区间赋值为 $0$ 可以将乘法标记设为 $0$)

```cpp
#define Lx (T[x].l)
#define Rx (T[x].r)
#define Ly (T[y].l)
#define Ry (T[y].r)
#define mid ((l+r)>>1)
int newp() {++cnt,T[cnt].mul=1;return cnt;}
void pushup(int x) {T[x].v=qmod(T[Lx].v+T[Rx].v);}
void pushdown(int x) {
	if(T[x].mul == 1)	return ;
	T[Lx].mul=1ll*T[Lx].mul*T[x].mul%mod,T[Lx].v=1ll*T[Lx].v*T[x].mul%mod;
	T[Rx].mul=1ll*T[Rx].mul*T[x].mul%mod,T[Rx].v=1ll*T[Rx].v*T[x].mul%mod;
	T[x].mul=1;
}
void insert(int x,int l,int r,int p) {
	if(l == r)	{T[x].v=1;return ;}
	if(p <= mid)	Lx=newp(),insert(Lx,l,mid,p);
	else	Rx=newp(),insert(Rx,mid+1,r,p);
	pushup(x);
}
int merge(int x,int y,int l,int r,int &sumx,int &sumy) {
	if(!x and !y)	return 0;
	if(!x) {
		sumy=qmod(sumy+T[y].v);
		T[y].mul=1ll*T[y].mul*sumx%mod,T[y].v=1ll*T[y].v*sumx%mod;
		return y;
	}
	if(!y) {
		sumx=qmod(sumx+T[x].v);
		T[x].mul=1ll*T[x].mul*sumy%mod,T[x].v=1ll*T[x].v*sumy%mod;
		return x;
	}
	if(l == r) {
		sumx=qmod(sumx+T[x].v);
		T[x].v=qmod(1ll*T[x].v*sumy%mod+1ll*T[y].v*sumx%mod);
		sumy=qmod(sumy+T[y].v);
		return x;
	}
	pushdown(x),pushdown(y);
	Lx=merge(Lx,Ly,l,mid,sumx,sumy);
	Rx=merge(Rx,Ry,mid+1,r,sumx,sumy);
	pushup(x);
	return x;
}
void cover(int x,int l,int r,int ql,int qr) {
	if(!x)	return ;
	if(ql <= l and r <= qr) {T[x].mul=0,T[x].v=0;return ;}
	pushdown(x);
	if(ql <= mid)	cover(Lx,l,mid,ql,qr);
	if(qr > mid)	cover(Rx,mid+1,r,ql,qr);
	pushup(x);
}
int query(int x,int l,int r,int p) {
	if(!x) return 0;
	if(l == r)	return T[x].v;	
	pushdown(x);
	return p<=mid?query(Lx,l,mid,p):query(Rx,mid+1,r,p);
}

void treedp(int x,int fa) {
	root[x]=newp();
	insert(root[x],0,maxdep,dep[anc[x]]);
	for(int i=head[x];i;i=nxt[i]) {
		int y=ver[i];
		if(y == fa)	continue;
		treedp(y,x);
		int sumx=0,sumy=T[root[y]].v;//g_{y,dep_y-1}
		root[x]=merge(root[x],root[y],0,maxdep,sumx,sumy);
	}
	cover(root[x],0,maxdep,dep[x],maxdep);
    
}
```
我从开始看这道题 , 然后写部分分 , 写正解 , 写题解 ... 一共断断续续地经过了 $10+$ 天 , 完结撒花 !





---

## 作者：hs_black (赞：52)



## 解题思路

首先题目大意就是每个边可以是 0 或 1，有 m 个条件，要求树上的一条直上直下的链中至少有一个 1，求方案数。

考虑 dp，$dp[x][y]$ 表示 x 子树内的边状态已经确定，下端点在子树内且没有被满足的条件中，上端点最深的深度是 y，特殊地，如果子树内的条件都满足那么 y = 0。记录最深是因为深得满足浅的也就会跟着满足。

考虑如何转移，对于 x 的儿子点 y，有
$$
\large dp'[x][i] = \sum_{j=0}^{dep_x}  dp[x][i] \times dp[y][j]+ \sum_{j=0}^i dp[x][i] \times dp[y][j] \large + \sum_{j=0}^{i-1} dp[y][i] \times dp[x][j]
$$
简单来说就是看这条边是 1 还是 0，前缀和优化一下就有 64 pt，其中如果建出来虚树就能再拿 8 pt。

现在是正解时间，重新审查我们的 dp
$$
\large dp'[x][i] = dp[x][i] \times (sum[y][dep_x]+ sum[y][i]) + dp[y][i] \times sum[x][i-1]
$$
考虑线段树合并，$sum[y][dep_x]$ 可以先从线段树上查一下，剩下的都是和下标相关的，我们先合并左子树然后合并右子树，走右子树的时候就可以把左边的 sum 加上了，整体乘一个数可以打个标记即可，细节如下

```cpp
// s1 -> (sum[y][dep[x]]+sum[y][i]), s2 -> sum[x][i-1]
int merge(int x, int y, int l, int r, ll &s1, ll &s2) {
	if (!x && !y) return 0;
	if (!x || !y) {
		if (!x) {
			add(s1, sum(y));
			mul(y) = mul(y) * s2 % P;
			sum(y) = sum(y) * s2 % P;
			return y;
		}
		add(s2, sum(x));
		sum(x) = sum(x) * s1 % P, mul(x) = mul(x) * s1 % P;
		return x;
	}
	if (l == r) {
		ll tx = sum(x), ty = sum(y); add(s1, ty);
		sum(x) = (sum(x) * s1 + sum(y) * s2) % P;
		add(s2, tx); 
		return x;
	}
	spread(x), spread(y); //下放标记
	int mid = (l + r) >> 1;
	ls(x) = merge(ls(x), ls(y), l, mid, s1, s2); 
	rs(x) = merge(rs(x), rs(y), mid + 1, r, s1, s2);
	sum(x) = (sum(ls(x)) + sum(rs(x))) % P;
	return x;
}

```

参考代码

```cpp
/*
　　　　　／＞　 フ
　　　　　| 　_　 _|
　 　　　／`ミ _x 彡
　　 　 /　　　 　 |
　　　 /　  ヽ　　 ?
　／￣|　　 |　|　|
　| (￣ヽ＿_ヽ_)_)
　＼二つ
 */

#include <queue>
#include <vector>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define MP make_pair
#define ll long long
#define fi first
#define se second
using namespace std;

template <typename T>
void read(T &x) {
    x = 0; bool f = 0;
    char c = getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;
    for (;isdigit(c);c=getchar()) x=x*10+(c^48);
    if (f) x=-x;
}

template<typename F>
inline void write(F x, char ed = '\n') {
	static short st[30];short tp=0;
	if(x<0) putchar('-'),x=-x;
	do st[++tp]=x%10,x/=10; while(x);
	while(tp) putchar('0'|st[tp--]);
	putchar(ed);
}

template <typename T>
inline void Mx(T &x, T y) { x < y && (x = y); }

template <typename T>
inline void Mn(T &x, T y) { x > y && (x = y); }

const int P = 998244353;
const int N = 500050;
vector<int> v[N];
int h[N], ne[N<<1], to[N<<1], dep[N], tot, m, n;
inline void adde(int x, int y) {
	ne[++tot] = h[x], to[h[x] = tot] = y;
}

inline void add(ll &x, ll y) { x += y, (x >= P) && (x -= P); }

struct node {
	int ls, rs;
	ll sum, mul;
	#define mul(p) t[p].mul
	#define ls(p) t[p].ls
	#define rs(p) t[p].rs
	#define sum(p) t[p].sum
}t[N<<5];

void spread(int p) {
	if (ls(p)) {
		sum(ls(p)) = sum(ls(p)) * mul(p) % P;
		mul(ls(p)) = mul(ls(p)) * mul(p) % P;
	}
	if (rs(p)) {
		sum(rs(p)) = sum(rs(p)) * mul(p) % P;
		mul(rs(p)) = mul(rs(p)) * mul(p) % P;
	}
	mul(p) = 1;
}

ll query(int rt, int l, int r, int L) {
	if (!rt || r <= L) return sum(rt);
	int mid = (l + r) >> 1; ll sum = 0;
	spread(rt);
	if (mid < L) add(sum, query(rs(rt), mid + 1, r, L));
	add(sum, query(ls(rt), l, mid, L));
	return sum;
}

int cnt;
void change(int &p, int l, int r, int x) {
	p = ++cnt, sum(p) = mul(p) = 1;
	if (l == r) return;
	int mid = (l + r) >> 1;
	if (x <= mid) change(ls(p), l, mid, x);
	else change(rs(p), mid + 1, r, x);
}

int merge(int x, int y, int l, int r, ll &s1, ll &s2) {
	if (!x && !y) return 0;
	if (!x || !y) {
		if (!x) {
			add(s1, sum(y));
			mul(y) = mul(y) * s2 % P;
			sum(y) = sum(y) * s2 % P;
			return y;
		}
		add(s2, sum(x));
		sum(x) = sum(x) * s1 % P, mul(x) = mul(x) * s1 % P;
		return x;
	}
	if (l == r) {
		ll tx = sum(x), ty = sum(y); add(s1, ty);
		sum(x) = (sum(x) * s1 + sum(y) * s2) % P;
		add(s2, tx);
		return x;
	}
	spread(x), spread(y);
	int mid = (l + r) >> 1;
	ls(x) = merge(ls(x), ls(y), l, mid, s1, s2); 
	rs(x) = merge(rs(x), rs(y), mid + 1, r, s1, s2);
	sum(x) = (sum(ls(x)) + sum(rs(x))) % P;
	return x;
}

int T[N];
void dfs(int x, int fa) {
	dep[x] = dep[fa] + 1; int mx = 0;
	for (auto t: v[x]) Mx(mx, dep[t]);
	change(T[x], 0, n, mx);
	for (int i = h[x]; i; i = ne[i]) {
		int y = to[i]; if (y == fa) continue;
		dfs(y, x); 
		ll S = query(T[y], 0, n, dep[x]), SS = 0;
		T[x] = merge(T[x], T[y], 0, n, S, SS);
	}
}

int main() {
//	freopen ("destiny.in","r",stdin);
//	freopen ("destiny.out","w",stdout);
	read(n);
	for (int i = 1, x, y;i < n; i++) 
		read(x), read(y), adde(x, y), adde(y, x);
	read(m);
	for (int i = 1, x, y;i <= m; i++) 
		read(x), read(y), v[y].push_back(x);
	dfs(1, 0), write(query(T[1], 0, n, 0));
	return 0;
}
```



---

## 作者：duyi (赞：20)

# 题解 LOJ3340 「NOI2020」命运

[超超超超超超超超超爽的阅读体验 /惊讶](https://www.cnblogs.com/dysyn1314/p/13557336.html)

[题目链接](https://loj.ac/problem/3340)

> 博主有幸参加了NOI2020，考场上的经历和心得请见[这篇文章](https://www.cnblogs.com/dysyn1314/p/13525855.html)。这里就不唠叨了。

## 本题题解

为了方便表述，我们把边重要、不重要，称为：颜色为$1$、$0$。本题相当于要求对给边染色的方案计数。

前$40$分部分分，是对$m$个限制做容斥。也就是$2^m$枚举哪些路径强制设为$0$，不在这些路径上的边可以随意。问题转化为求路径并，可以用树链剖分或虚树维护。由于与正解做法关联不大，这里不细讲了。

---

正解的起点是一个DP。设$dp[u][i]$表示假设$u$的**子树外**边的颜色都已经确定，且$u$的“祖先边”（$u$到根路径上所有边）中，深度最大（离它最近）的颜色为$1$的边，深度为$i$，此时$u$的**子树内**所有边合法的染色方案数。

容易发现，一个子树内的染色方案数，只和这个子树“祖先边”中深度最大的颜色为$1$的边的深度有关，而这个东西我们已经写在了状态里（就是$i$）。因此这个状态非常合理。

更具体来讲，我们定义点的深度为它到根路径上的边数。边的深度为它连接的儿子节点的深度。因为根节点（深度为$0$）没有父亲边，所以不存在深度为$0$的边。不过我们可以假装有这样一条边，且这条边的颜色永远是$1$。则DP的答案就是$dp[1][0]$，其中$0$就是我们假想出来的这条边的深度。

至于$m$条限制，我们对每个点$u$，维护它“祖先边”中，离它最近的、颜色为$1$的边，深度至少是多少，记为$\text{lim}[u]$。初始时，$\text{lim}[u]=0$，也就是我们假想的那个颜色永远是$1$的边。每读入一条限制$(u,v)$，就令$\text{lim}[v]:=\max(\text{lim}[v],\text{dep}[u]+1)$。同时，每个节点的$\text{lim}$，还要对$\text{lim}[fa(u)]$取$\max$。

容易发现，对于$i\notin [\text{lim}[u],\text{dep}[u]]$，$dp[u][i]=0$。

对于其他的$i$，可以从儿子转移过来。不难写出：
$$
dp[u][i]=[\text{lim}[u]\leq i\leq \text{dep}[u]]\times \prod_{v\in \text{son}(u)}(dp[v][i]+dp[v][\text{dep}[v]])
$$
这样直接DP是$O(n^2)$的。

---

继续优化，对于每个点$u$，考虑把$dp[u]$的第二维搬到线段树上，然后做线段树合并。考虑在转移过程中，我们的线段树需要做哪些操作。

1. 假设线段树初值全部为$0$。那我们要先把$[\text{lim}[u],\text{dep}[u]]$这个区间赋值为$1$。
2. 我们要对所有$0\leq i<\text{dep}[u]$，令$dp[u][i]\texttt{+=}dp[u][\text{dep[u]}]$，这是为了从$u$向父亲转移时更方便（看一下转移式就知道了）。
3. 在第2条的基础上，转移时，我相当于要合并两棵线段树，并实现把所有对应位置相乘。

前两条操作，可以看成区间加。第3条操作又涉及乘法。所以我们的线段树，维护区间加法和乘法两个懒标记。

这里需要注意一下，下放标记的顺序。更新乘法标记时，把已有的加法标记也乘上这个数。更新加法标记时则不动乘法标记。下放标记（``push_down``）时，先下放乘法标记，再下放加法标记。这里面的原因并不复杂，可以自行思考一下。

同时我们还要支持单点查询。这个在访问到线段树叶子节点时，直接反回它的加法标记值即可。

这样合并$O(n)$次，做$O(n)$次修改，时间复杂度是$O(n\log n)$的。

参考代码（建议使用读入优化，详见本博客公告）：

```cpp
//problem:LOJ3340
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T>inline void ckmax(T& x,T y){x=(y>x?y:x);}
template<typename T>inline void ckmin(T& x,T y){x=(y<x?y:x);}

const int MAXN=5e5,MAXM=5e5;
const int MOD=998244353;
inline int mod1(int x){return x<MOD?x:x-MOD;}
inline int mod2(int x){return x<0?x+MOD:x;}
inline void add(int& x,int y){x=mod1(x+y);}
inline void sub(int& x,int y){x=mod2(x-y);}
inline int pow_mod(int x,int i){int y=1;while(i){if(i&1)y=(ll)y*x%MOD;x=(ll)x*x%MOD;i>>=1;}return y;}

int n,m;
vector<int>G[MAXN+5];
struct Request{
	// u是祖先,v是后代
	int u,v;
}q[MAXM+5];

int fa[MAXN+5],dep[MAXN+5];
int lim[MAXN+5];
void dfs_prep(int u){
	for(int i=0;i<SZ(G[u]);++i){
		int v=G[u][i];
		if(v==fa[u]) continue;
		fa[v]=u;
		dep[v]=dep[u]+1;
		dfs_prep(v);
	}
}

struct SegmentTree{
	int rt[MAXN+5];
	int cnt;
	vector<int>bin;
	int ls[MAXN*100+5],rs[MAXN*100+5];
	int tag_add[MAXN*100+5],tag_mul[MAXN*100+5];
	int new_node(int _mul=1,int _add=0){
		int x;
		if(SZ(bin)){
			x=bin.back();
			bin.pop_back();
		}
		else{
			x=++cnt;
		}
		ls[x]=rs[x]=0;
		tag_mul[x]=_mul;
		tag_add[x]=_add;
		return x;
	}
	void upd_mul(int x,int v){
		tag_mul[x]=(ll)tag_mul[x]*v%MOD;
		tag_add[x]=(ll)tag_add[x]*v%MOD;
	}
	void upd_add(int x,int v){
		add(tag_add[x],v);
	}
	void push_down(int x){
		if(tag_mul[x]!=1){
			if(!ls[x]) ls[x]=new_node();
			if(!rs[x]) rs[x]=new_node();
			upd_mul(ls[x],tag_mul[x]);
			upd_mul(rs[x],tag_mul[x]);
			tag_mul[x]=1;
		}
		if(tag_add[x]){
			if(!ls[x]) ls[x]=new_node();
			if(!rs[x]) rs[x]=new_node();
			upd_add(ls[x],tag_add[x]);
			upd_add(rs[x],tag_add[x]);
			tag_add[x]=0;
		}
	}
	void modify_add(int& x,int l,int r,int ql,int qr,int v){
		if(ql<=l && qr>=r){
			upd_add(x,v);
			return;
		}
		int mid=(l+r)>>1;
		push_down(x);
		if(ql<=mid)
			modify_add(ls[x],l,mid,ql,qr,v);
		if(qr>mid)
			modify_add(rs[x],mid+1,r,ql,qr,v);
	}
	int query(int x,int l,int r,int pos){
		if(l==r){
			return tag_add[x];
		}
		int mid=(l+r)>>1;
		push_down(x);
		if(pos<=mid)
			return query(ls[x],l,mid,pos);
		else
			return query(rs[x],mid+1,r,pos);
	}
	int merge(int x, int y){
		if (!ls[x] && !rs[x]) swap(x, y);
		if (!ls[y] && !rs[y]){
			upd_mul(x,tag_add[y]);
			return x;
		}
		push_down(x), push_down(y);
		ls[x] = merge(ls[x], ls[y]);
		rs[x] = merge(rs[x], rs[y]);
		return x;
	}
	SegmentTree(){}
}T;
/*
int dp[MAXN+5][MAXN+5];
void dfs_dp(int u){
	for(int j=lim[u];j<=dep[u];++j){
		dp[u][j]=1;
	}
	for(int i=0;i<SZ(G[u]);++i){
		int v=G[u][i];
		if(v==fa[u]) continue;
		dfs_dp(v);
		for(int j=lim[u];j<=dep[u];++j){
			dp[u][j]=(ll)dp[u][j]*(dp[v][j]+dp[v][dep[v]])%MOD;
		}
	}
}
*/
void dfs_dp(int u){
	lim[u]=max(lim[u],lim[fa[u]]);
	T.rt[u]=T.new_node(0,0);
	T.modify_add(T.rt[u],0,n-1,lim[u],dep[u],1);
	for(int i=0;i<SZ(G[u]);++i){
		int v=G[u][i];
		if(v==fa[u]) continue;
		dfs_dp(v);
		T.rt[u]=T.merge(T.rt[u],T.rt[v]);
	}
	if(u==1) return;
	int v=T.query(T.rt[u],0,n-1,dep[u]);
	T.modify_add(T.rt[u],0,n-1,0,dep[u]-1,v);
}
int main() {
//	freopen("destiny.in","r",stdin);
//	freopen("destiny.out","w",stdout);
	cin>>n;
	for(int i=1;i<n;++i){
		int u,v;
		cin>>u>>v;
		G[u].pb(v);
		G[v].pb(u);
	}
	dfs_prep(1);
	cin>>m;
	for(int i=1;i<=m;++i){
		cin>>q[i].u>>q[i].v;
		ckmax(lim[q[i].v],dep[q[i].u]+1);
	}
	dfs_dp(1);
	cout<<T.query(T.rt[1],0,n-1,0)<<endl;
	return 0;
}
```



---

## 作者：jiangby (赞：20)

首先看到题目，由至少一条边想到容斥，变为一条都没有，然后暴力枚举每个条件可以做到 $O(2^mm)$，但是 $m$ 很大无法通过，考虑把容斥放入 $DP$ 中进行计算。因为只关心最上面的，所以对于同一个点只用考虑最上面的限制，设 $Dp_{i,j}$ 为当前考虑了 $i$ 的子树，限制最上面的点深度为 $j$ ，因为选一个限制是有 $-1$ 的代价，所以一开始 $Dp_{i,Mx}=-1,Dp_{i,n}=1$，然后每次只需要枚举下限制即可，优化下可以做到 $O(n^2)$，当 $n$ 很大而   $m$ 比较小的时候用虚树可以 $O(m^2)$,而且因为至于深度有关同样可以通过完全二叉树的点，一共有 $72$ 分，而正解也比较简单了，只需要按照套路用线段树合并优化下这个 $DP$ 即可，这样复杂度为 $O(nlogn)$ 的可以通过   $100$ 的数据

代码仅供参考

```
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define db double
#define pint pair<int,int>
#define mk make_pair
#define pb push_back
#define eb emplace_back
#define ins insert
#define fi first
#define se second
#define Rep(x,y,z) for(int x=y;x<=z;x++)
#define Red(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
const int MAXN=5e5+5,Mod=998244353;
inline char gc(){return getchar();}
inline int read(){
	int x=0,p=1;char ch=gc();for(;ch<'0'||ch>'9';ch=gc())if(ch=='-')p=-1;
	for(;ch>='0'&&ch<='9';x=(x<<3)+(x<<1)+(ch^48),ch=gc());return x*p;
}
inline int Add(int x,int y){return x+y>=Mod?x+y-Mod:x+y;}
int n,m;vector<int>G[MAXN];
int Sum[MAXN*80],ls[MAXN*80],rs[MAXN*80],tag[MAXN*80],tot,rt[MAXN];
inline int newNode(){return ++tot,tag[tot]=1,tot;}
inline void pushr(int x,int v){if(x)tag[x]=1ll*tag[x]*v%Mod,Sum[x]=1ll*Sum[x]*v%Mod;}
inline void pushdown(int x){if(tag[x]!=1)pushr(ls[x],tag[x]),pushr(rs[x],tag[x]),tag[x]=1;}
inline void pushup(int x){Sum[x]=Add(Sum[ls[x]],Sum[rs[x]]);}
inline void Merge(int&x,int y,int Sum1,int Sum2,int l,int r){
	if(!x||!y){pushr(x,Sum2),pushr(y,Sum1),x+=y;return;}
	if(l==r){Sum[x]=(1ll*Sum[x]*Sum2+1ll*Sum[y]*Sum1+1ll*Sum[x]*Sum[y])%Mod;return;}pushdown(x),pushdown(y);int mid=l+r>>1;
	Merge(ls[x],ls[y],(Sum[rs[x]]+Sum1)%Mod,(Sum[rs[y]]+Sum2)%Mod,l,mid),Merge(rs[x],rs[y],Sum1,Sum2,mid+1,r),pushup(x);
}
inline void Mul(int x,int l,int r,int ql,int qr){
	if(!x)return;if(ql<=l&&r<=qr)return pushr(x,2);int mid=l+r>>1;pushdown(x);
	if(ql<=mid)Mul(ls[x],l,mid,ql,qr);if(qr>mid)Mul(rs[x],mid+1,r,ql,qr);pushup(x);
}
inline void Ins(int&x,int l,int r,int p,int v){
	if(!x)x=newNode();if(l==r){Sum[x]=v;return;}int mid=l+r>>1;pushdown(x);
	(p<=mid?Ins(ls[x],l,mid,p,v):Ins(rs[x],mid+1,r,p,v)),pushup(x);
}
int Mx[MAXN],d[MAXN],fa[MAXN],Rt;
void dfs(int x,int fa){d[x]=d[fa]+1;for(auto y:G[x])if(y!=fa)dfs(y,x);}
void dfs1(int x,int fa){
	if(Mx[x])Ins(rt[x],1,n,Mx[x],Mod-1);Ins(rt[x],1,n,n,1);
	for(auto y:G[x])if(y!=fa)dfs1(y,x),Merge(rt[x],rt[y],0,0,1,n);
	if(fa)Mul(rt[x],1,n,d[x],n);
}
inline void Solve(){
	n=read();
	Rep(i,1,n-1){int x=read(),y=read();G[x].pb(y),G[y].pb(x);}
	dfs(1,0);for(int m=read();m--;){int x=read(),y=read();Mx[y]=max(Mx[y],d[x]);}
	dfs1(1,0);cout<<Sum[rt[1]]<<'\n';
}
int main(){
//	freopen("destiny.in","r",stdin);
//	freopen("destiny.out","w",stdout);
	Solve();
	return 0;
}
```

---

## 作者：s_r_f (赞：11)

考虑$dp.$

记$dp_{x,i}$表示$x$子树内的所有边以及$x$到$x$的父亲的边的状态$($ 是否选取 $)$ 都决定好了$,$目前还没有被解决的限制的最大深度$\leq i$的方案数$.$

不难发现转移时相当于每个儿子的$dp$数组对位相乘$,$最后要求一个当前$dp$数组的和加到全局上$.$

可以用带$tag$的线段树合并维护$.$

我的考场代码写的是启发式合并$.$

启发式合并代码$:$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline int read(){
	static int x; static char c; x = 0,c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) x = x * 10 + c - '0',c = getchar();
	return x;
}
const int N = 500050,P = 998244353;
int To[N<<1],Ne[N<<1],He[N],_;
inline void adde(int x,int y){
	++_; To[_] = y,Ne[_] = He[x],He[x] = _;
	++_; To[_] = x,Ne[_] = He[y],He[y] = _;
}

int n,m,fa[N],dpt[N],lim[N];
inline void dfs(int x){
	dpt[x] = dpt[fa[x]] + 1;
	for (int y,p = He[x]; p ; p = Ne[p]) if ((y=To[p])^fa[x]) fa[y] = x,dfs(y);
}


const int V = N * 60;
inline void upd(int &x,int y){ x = (x+y>=P)?(x+y-P):(x+y); }
int lc[V],rc[V],val[V],mul[V],add[V],siz[V],cnto;
int stk[V],top;
inline int New(){
	static int o; if (top) o = stk[top],--top; else o = ++cnto;
	lc[o] = rc[o] = add[o] = siz[o] = val[o] = 0,mul[o] = 1;
	return o;
}
inline void DD(int x){ stk[++top] = x; }
inline void tmul(int o,int v){ if (o) mul[o] = (LL)mul[o] * v % P,add[o] = (LL)add[o] * v % P,val[o] = (LL)val[o] * v % P; }
inline void tadd(int o,int v){ if (o) upd(add[o],v),upd(val[o],v); }
inline void down(int o){
	if (mul[o] ^ 1) tmul(lc[o],mul[o]),tmul(rc[o],mul[o]),mul[o] = 1;
	if (add[o]) tadd(lc[o],add[o]),tadd(rc[o],add[o]),add[o] = 0;
}
inline void up(int o){ val[o] = val[rc[o] ? rc[o] : lc[o]],siz[o] = siz[lc[o]] + siz[rc[o]]; }
int pp,vv;
inline void Del(int &o,int l,int r){
	if (!o || r < pp) return; if (l >= pp){ DD(o),o = 0; return; }
	down(o); int mid = l+r>>1; Del(lc[o],l,mid); Del(rc[o],mid+1,r);
	up(o); if (siz[o] == 0) DD(o),o = 0;
}
inline void Ins(int &o,int l,int r){
	if (!o) o = New(); if (l == r){ siz[o] = 1,val[o] = vv; return; }
	down(o); int mid = l+r>>1; if (pp <= mid) Ins(lc[o],l,mid); else Ins(rc[o],mid+1,r); up(o);
}
int ll,rr;
inline void Mul(int o,int l,int r){
	if (!o) return; if (ll <= l && rr >= r){ tmul(o,vv); return; }
	down(o); int mid = l+r>>1; if (ll <= mid) Mul(lc[o],l,mid); if (rr > mid) Mul(rc[o],mid+1,r); up(o);
}
inline void Add(int o,int l,int r){
	if (!o) return; if (ll <= l && rr >= r){ tadd(o,vv); return; }
	down(o); int mid = l+r>>1; if (ll <= mid) Add(lc[o],l,mid); if (rr > mid) Add(rc[o],mid+1,r); up(o);
}

inline bool Is(int o,int l,int r){
	if (!o) return 0; if (l == r) return 1;
	down(o); int mid = l+r>>1; if (pp <= mid) return Is(lc[o],l,mid); return Is(rc[o],mid+1,r);
}
int qans,qi;
inline void Query(int o,int l,int r){
	if (!o || qi >= r || l >= pp) return; if (r < pp){ qi = r,qans = val[o]; return; }
	down(o); int mid = l+r>>1; Query(rc[o],mid+1,r); Query(lc[o],l,mid);
}
inline void radd(int rt,int l,int r,int v){ ll = l,rr = r,vv = v,Add(rt,0,n); }
inline void rmul(int rt,int l,int r,int v){ ll = l,rr = r,vv = v,Mul(rt,0,n); }
inline void rins(int &rt,int p,int v){ pp = p,vv = v,Ins(rt,0,n); }
inline void rdel(int &rt,int p){ pp = p,Del(rt,0,n); }
inline bool ris(int rt,int p){ pp = p; return Is(rt,0,n); } 

int ti[N],tv[N],cntt;
inline void Dfs(int o,int l,int r){
	if (!o) return; if (l == r){ ++cntt; ti[cntt] = l,tv[cntt] = val[o]; DD(o); return; }
	down(o); int mid = l+r>>1; Dfs(lc[o],l,mid); Dfs(rc[o],mid+1,r); DD(o);
}

int ans;
inline void Ask(int o,int l,int r){
	if (!o) return; if (l == r){ ans = val[o]; return; }
	down(o); int mid = l+r>>1; if (lc[o]) Ask(lc[o],l,mid); else Ask(rc[o],mid+1,r);
}

inline void Dfs2(int o,int l,int r){
	if (!o) return; if (l == r){ ++cntt; ti[cntt] = l,tv[cntt] = val[o]; return; }
	down(o); int mid = l+r>>1; Dfs2(lc[o],l,mid); Dfs2(rc[o],mid+1,r); 
}

inline int Merge(int rt1,int rt2){
	if (siz[rt1] < siz[rt2]) swap(rt1,rt2);
	cntt = 0,Dfs(rt2,0,n);
	ti[++cntt] = n+1;
	for (int i = cntt-1; i >= 1; --i){
		if (!ris(rt1,ti[i])){
			pp = ti[i],qi = -1,Query(rt1,0,n);
			rins(rt1,ti[i],qans);
		}
		rmul(rt1,ti[i],ti[i+1]-1,tv[i]);
	}
	return rt1;
}

int T[N];
inline void dp(int x){
	if (lim[x]) rins(T[x],0,0); rins(T[x],lim[x],1);
	for (int y,p = He[x]; p ; p = Ne[p]) if ((y=To[p])^fa[x]) dp(y),T[x] = Merge(T[x],T[y]);
	if (x == 1){ Ask(T[1],0,n); return; }
	radd(T[x],0,n,val[T[x]]);
	rdel(T[x],dpt[fa[x]]);
	//cerr << "print " << x <<'\n',Print(T[x]);
}

int main(){
//	freopen("destiny.in","r",stdin);
//	freopen("destiny.out","w",stdout);
	int i,x,y;
	n = read();
	for (i = 1; i < n; ++i) x = read(),y = read(),adde(x,y);
	dfs(1);
	for (i = 1; i <= n; ++i) lim[i] = 0;
	m = read();
	while (m--) x = read(),y = read(),lim[y] = max(lim[y],dpt[x]);
	dp(1);
	cout << ans << '\n';
}
```

---

## 作者：xgzc (赞：10)

[CF1327F AND Segments](https://www.luogu.com.cn/problem/CF1327F) + 整体 dp。

首先预处理 $\mathrm{pre}_i$ 表示向上最深的 $f(e) = 1$ 的边的深度最小值。

设 $f_{i, j}$ 表示当前在点 $i$，最深的 $f(e) = 1$ 的深度为 $j$ 的方案数。

枚举点 $i$ 和儿子之间的边是否设成 $1$，有：
$$
f_{i, j} = [\mathrm{pre}_i < j \leq \mathrm{dep}_i]\prod_{s \in \mathrm{son}(i)} (f_{s,j} + f_{s, \mathrm {dep}_s})
$$
其中 $f_{s, \mathrm{dep}_s}$ 表示将 $s$ 和它父亲的边设成 $1$ 的方案数。

考虑用线段树合并维护，那么只需要维护区间加，区间乘和区间赋值，维护一个标记 $(a, b)$ 使得 $f \stackrel{(a, b)}{\longrightarrow} af + b$。

手推一下标记如何合并即可。

代码见我的 [$\texttt{blog}$](https://www.cnblogs.com/cj-xxz/p/13534898.html)。

---

## 作者：p878567 (赞：9)

首先声明，本题解的 $O(n\log^2n)$ 的做法可以被攻击，$O(n\log n)$ 做法没有实现~~（如果打铁失败可能会考虑补一个实现）~~

由于我的水平比较菜，因此并没有当场指出这个算法。

当场提供的一个树形 DP，按照下面的理解表述如下：

记 $f(i,j)$ （其中 $j$ 是 $i$ 的祖先）表示考虑对 $i$ 子树内的边染色，并且仅考虑满足 $u$ 在 $j$ 子树内且 $v$ 在 $i$ 子树内且 $v\neq i$ 的路径 $(u,v)$ 的方案数，那么我们有
$$f(i,j)=\sum_u(f(u,u)+[v(u)\text{不存在或 }v(u)\text{ 是 }j\text{ 的严格祖先}]f(u,i))$$

其中求和是对满足 $u$ 是 $i$ 的子节点进行的，$v(u)$ 表示末端点为 $u$ 的路径中深度最大的初端点。

特别地，记 $f(u)=f(u,u)$，那么答案即为 $f(1)$。

考虑如何计算 $f(i)$，并假定我们已经计算出 $i$ 的子树内全部节点 $u$ 的 $f(u)$ 并能 $O(\log n)$ 查询 $f(u,j)$，其中 $j$ 是 $i$ 的对应儿子。

我们只需要加入以 $i$ 为初端点的路径，注意到加入一条路径最多只会改变一个转移方程，因此可以动态 DP，同时维护 $f(u,i)$。

暴力实现 $O(n\log n(\log n+\log p))$，由于出题人并没有卡树剖，因此可以通过全部测试点。

采用全局平衡二叉树并对链顶线性求逆元，可以做到 $O(n(\log n+\log p))$。

考场代码（树剖）：

~~由于取模问题，考场上仅获得 48 分，如果想参考下面的代码，建议先找出取模问题~~

```cpp
#include<bits/stdc++.h>
#define mod 998244353
using namespace std;
int power(int a, int n) {
	int ans = 1;
	while (n) {
		if (n & 1) ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		n >>= 1;
	}
	return ans;
}
int read() {
	char c=getchar();while(!isdigit(c)) c=getchar();
	int num=0;while(isdigit(c)) num=num*10+c-'0',c=getchar();
	return num;
}
int head[500001], ver[1000001], nxt[1000001], sz;
void addedge(int u, int v) {
	ver[++sz] = v, nxt[sz] = head[u], head[u] = sz;
	ver[++sz] = u, nxt[sz] = head[v], head[v] = sz;
}
int fa[500001], dep[500001], size[500001], son[500001];
void dfs1(int x) {
	size[x] = 1;
	for (int i = head[x]; i; i = nxt[i])
		if (fa[x] != ver[i]) {
			fa[ver[i]] = x;
			dep[ver[i]] = dep[x] + 1;
			dfs1(ver[i]);
			size[x] += size[ver[i]];
			if (size[ver[i]] > size[son[x]]) son[x] = ver[i];
		}
}
int id[500001], top[500001], bot[500001], now;
void dfs2(int x, int t) {
	top[x] = t, id[x] = ++now;
	if (son[x]) dfs2(son[x], t), bot[x] = bot[son[x]];
	else bot[x] = x;
	for (int i = head[x]; i; i = nxt[i])
		if (fa[x] != ver[i] && son[x] != ver[i])
			dfs2(ver[i], ver[i]);
}
struct linear {
	int k, b;
	operator int() {return k+b;}
}m0[2000001];
linear operator*(linear a, linear b) {
	linear ans;
	ans.k = 1ll*a.k*b.k%mod;
	ans.b = (1ll*a.b*b.k+b.b)%mod;
	return ans;
}
int f[500001], t[500001], f0[500001], v0[500001];
int tmp[500001], cnt[500001];
void init(int p, int l, int r) {
	m0[p].k = 1, m0[p].b = 0;
	if (l == r) return;
	int mid = (l + r) / 2;
	init(p * 2, l, mid), init(p * 2 + 1, mid + 1, r);
}
void upd(int p, int l, int r, int x, int x0) {
	if (l == r) {
		m0[p].k = v0[x0]*t[x], m0[p].b = 1ll*t[x]*f[x0]%mod;
		return;
	}
	int mid = (l + r) / 2;
	if (id[x] <= mid) upd(p * 2, l, mid, x, x0);
	else upd(p * 2 + 1, mid + 1, r, x, x0);
	m0[p] = m0[p*2+1] * m0[p*2];
}
linear query(int p, int l, int r, int l0, int r0) {
	if (l >= l0 && r <= r0) return m0[p];
	int mid = (l + r) / 2;
	linear ans;
	ans.k = 1, ans.b = 0;
	if (r0 > mid) ans = ans * query(p * 2 + 1, mid + 1, r, l0, r0);
	if (l0 <= mid) ans = ans * query(p * 2, l, mid, l0, r0);
	return ans;
} 
void modify(int u, int x, int n) {
	if (top[u] == top[x]) {
		upd(1, 1, n, fa[u], u);
		return;
	}
	if (top[u] == u) {
		if (f0[u] == 0) --cnt[fa[u]];
		else {
			int inv = power(f0[u], mod-2);
			tmp[fa[u]] = 1ll*tmp[fa[u]]*inv%mod;
		}
		f0[u] = f[u];
		if (f0[u] == 0) ++cnt[fa[u]];
		else tmp[fa[u]] = 1ll*tmp[fa[u]]*f0[u]%mod;
		t[fa[u]] = cnt[fa[u]]?0:tmp[fa[u]];
		u = fa[u], upd(1, 1, n, u, son[u]);
	}
	while (top[u] != top[x]) {
		int v = top[u];
		if (f0[v] == 0) --cnt[fa[v]];
		else {
			int inv = power(f0[v], mod-2);
			tmp[fa[v]] = 1ll*tmp[fa[v]]*inv%mod;
		}
		upd(1, 1, n, fa[u], u), f0[v] = (f[v]+v0[v]*query(1, 1, n, id[v], id[bot[u]]))%mod;
		if (f0[v] == 0) ++cnt[fa[v]];
		else tmp[fa[v]] = 1ll*tmp[fa[v]]*f0[v]%mod;
		t[fa[v]] = cnt[fa[v]]?0:tmp[fa[v]];
		u = fa[v], upd(1, 1, n, u, son[u]);
	}
}
vector<int> down[500001];
void dfs(int x, int n) {
	tmp[x] = t[x] = 1;
	for (int i = head[x]; i; i = nxt[i])
		if (fa[x] != ver[i]) dfs(ver[i], n);
	for (int i : down[x])
		if (v0[i]) {
			v0[i] = 0;
			modify(i, x, n);
		}
	f[x] = query(1, 1, n, id[x], id[bot[x]]);
	if (!fa[x]) return;
	if (top[x] == x) {
		if (f[x]) tmp[fa[x]] = 2ll*tmp[fa[x]]*f[x]%mod;
		else ++cnt[fa[x]];
		t[fa[x]] = cnt[fa[x]]?0:tmp[fa[x]];
		f0[x] = 2ll*f[x]%mod;
	}
	upd(1, 1, n, fa[x], son[fa[x]]);
}
int main() {
	freopen("destiny.in", "r", stdin);
	freopen("destiny.out", "w", stdout);
	int n = read();
	for (int i = 1; i < n; i++) {
		int x, y;
		x = read(), y = read();
		addedge(x, y);
	}
	dfs1(1), dfs2(1, 1), init(1, 1, n);
	for (int i = 1; i <= n; i++) v0[i] = 1;
	int m = read();
	for (int i = 1; i <= m; i++) {
		int u, v;
		u = read(), v = read();
		down[u].push_back(v);
	}
	dfs(1, n);
	cout << f[1] << endl;
}
```

---

## 作者：白羽0123 (赞：7)

本题存在一种思维难度与实现难度都远小于正解的做法，并且在测试数据中运行时间也比正解优秀（洛谷本题运行时间最短）。

但我并未算出足够优秀的时间复杂度，有可能是我的问题，也有可能是存在数据将此做法卡掉而测试数据中不存在。

具体做法如下：我们考虑朴素的 $dp$ , $f_{i,j}$ 表示 $i$ 子树中的边已填完，下端点在子树 $i$ 内且子树 $i$ 内填的边未满足的条件，上端点最深的深度是 $j$ 的情况数（同其他大多数题解的 $dp$ ）。

我们可以发现，在诸多状态中存在许多没有意义的状态（即 $f$ 值为 $0$ ），如果我们将有意义的状态储存下来进行 $dp$ ，就可以大幅节约时间和空间。

如果使用 $map$ 存状态而不使用前缀优化，实际得分 $88 pts$.如果使用 $map$ 存状态且使用前缀优化实际得分 $96 pts$. 

我们可以发现只有原来的 $f_{u,i}$ 有意义或 $f_{v,i}$ 有意义时 更新出来的 $f_{u,i}$ 才有意义，所以我们可以直接一个临时数组存 $dp$ 的结果，再通过原 $u$ 和 $v$ 的有意义集合推出新 $u$ 的有意义集合。

我推的一个粗略的严谨时间复杂度上界是 $O(min(m,dep) \times n)$ 的，但实际上应该更加优秀，至少在随机情况下十分优秀。  

```
#include<bits/stdc++.h>
#define nxt(x) bian[x].nxt
#define ed(x) bian[x].ed
using namespace std;
const int maxn=1e6+10,mod=998244353;
struct edge {
	int nxt,ed;
}bian[maxn];
int t[maxn],cnt=2;
int d[maxn];
int lim[maxn];
int g[maxn];
pair<int,int> wy[maxn];
int w=0;
vector <pair<int,int> > f[maxn];
int n,m;
int read() {
	int x=0;char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x;
}
void lj(int x,int y) {
	ed(cnt)=y;
	nxt(cnt)=t[x];
	t[x]=cnt++;
}
void initdfs(int fa,int u) {
	d[u]=d[fa]+1;
	for (int l=t[u];l;l=nxt(l)) {
		int v=ed(l);
		if (fa==v) continue;
		initdfs(u,v);
	}
}
void dfs(int fa,int u) {
	f[u].push_back(make_pair(lim[u],1));
	for (int l=t[u];l;l=nxt(l)) {
		int v=ed(l);
		if (fa==v) continue;
		dfs(u,v);
		int sum=0,sum2=0;
		for (int qv=0,qu=0;qv<f[v].size();qv++) {
			pair<int,int> pv=f[v][qv];
			if (pv.first==d[v]) continue;
			sum=(sum+pv.second)%mod;
			for (;qu<f[u].size()&&f[u][qu].first<=pv.first;qu++) {
				pair<int,int> pu=f[u][qu];
				if (pu.first==d[u]) continue;
				sum2=(sum2+pu.second)%mod;
			}
			if (sum2==0) continue;
			g[pv.first]=(g[pv.first]+1ll*sum2*pv.second%mod)%mod;
		}
		for (int qu=0,qv=0;qu<f[u].size();qu++) {
			pair<int,int> pu=f[u][qu];
			if (pu.first==d[u]) continue;
			for (;qv<f[v].size()&&f[v][qv].first<pu.first;qv++) {
				pair<int,int> pv=f[v][qv];
				if (pv.first==d[v]) continue;
				sum=(sum+pv.second)%mod;
			}
			g[pu.first]=(g[pu.first]+1ll*pu.second*sum%mod)%mod;
		}
		w=0;	
		int qv=0;
		for (int qu=0;qu<f[u].size();qu++) {
			pair<int,int> pu=f[u][qu];
			if (pu.first==d[u]) continue;
			for (;qv<f[v].size()&&f[v][qv].first<=pu.first;qv++) {
				pair<int,int> pv=f[v][qv];
				if (pv.first==d[v]) continue;
				if (g[pv.first]!=0){
					wy[++w]=make_pair(pv.first,g[pv.first]);
					g[pv.first]=0;
				}
			}
			if (g[pu.first]!=0){
				wy[++w]=make_pair(pu.first,g[pu.first]);
				g[pu.first]=0;
			}
		}
		for (;qv<f[v].size();qv++) {
			pair<int,int> pv=f[v][qv];
			if (pv.first==d[v]) continue;
			if (g[pv.first]!=0){
				wy[++w]=make_pair(pv.first,g[pv.first]);
				g[pv.first]=0;
			}
		}
		f[u].clear();
		for (int l=1;l<=w;l++) {
			f[u].push_back(wy[l]);
		}
	//	cout<<u<<" "<<f[u].size()<<endl;
		
	}
}

int main() {
//	freopen("destiny21.in","r",stdin);
//	freopen("destiny.out","w",stdout);
	n=read();
	for (int l=1;l<n;l++) {
		int u=read(),v=read();
		lj(u,v);
		lj(v,u);
	}
	initdfs(1,1);
	m=read();
	for (int l=1;l<=m;l++) {
		int u=read(),v=read();
		lim[v]=max(d[u],lim[v]);
	}
	dfs(1,1);
	cout<<f[1][0].second<<endl;
}
```

---

## 作者：Sol1 (赞：5)

神仙题。

看到题目第一眼：我会容斥！

可以直接得到 $O(2^mm\log^2n)$ 的做法并获得 $32$ 分。

~~我现场估计也就这点分了~~

结合虚树或子集卷积可以做到 $O(2^mm)$ 并获得 $40$ 分。

~~然后就不会了，只能 Orz dengyaotriangle 场切这题~~

然后其实是一个 key observation：对于两条路径，如果一条包含了另一条，那么只有被包含的那一条有用。

~~感觉是一句废话~~

这其实提示我们对于一个点，经过它且还没有被满足的限制，只需要满足终点深度最大的那个，剩下的就全部满足了。

于是就得到了 DP 状态：$f_{u,i}$ 表示 $u$ 点，终点深度最大的那个限制的终点的深度是 $i$ 对应的 $u$ 子树内的染色方案数。

在 $v\rightarrow u$ （其中 $u$ 是 $v$ 的父亲）转移的时候，就考虑这条边选还是不选：

1. 选，此时 $v$ 不管原来有啥限制都没了，于是得到转移：

$$f_{u,i}\leftarrow f_{u,i}\cdot\sum_{j=0}^{d_u}f_{v,j}$$

2. 不选，此时这个深度有可能是 $v$ 的限制也有可能是 $u$ 的限制，于是有转移：

$$f_{u,i}\leftarrow f_{u,i}\cdot\sum_{j=0}^if_{v,j}+f_{v,i}\cdot\sum_{j=0}^{i-1}f_{u,j}$$

（其中 $d_u$ 是 $u$ 的深度）

边界就是对于叶子节点，起点为它，终点深度最大的那个限制对应的终点的深度，对应的状态的方案数为 $1$。

答案就是 $f_{1,0}$。

（$0$ 代表所有限制都被满足）

得到一个 $O(n^2)$ 的做法。

可以优化到 $O(n\cdot\min\{m,\max d\})$，并获得 $64$ 分。

继续优化，叶子节点上只有 $1$ 个有效状态，故线段树合并，发现只需在合并过程中维护一个前缀和。

那么这题就做完了~

时空复杂度均为 $O(n\log n)$。

好像有些人会被卡常，其实只需要加减法的取模优化就可以直接跑进 1s。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <vector>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const int N = 500005, M = 500005;
const long long mod = 998244353;
struct Edge {
	int to, nxt;
	Edge() {
		nxt = -1;
	}
};
Edge e[N << 1];
int n, hd[N], pnt, dep[N], bnd[N], m;

inline long long Add(long long x, long long y) {return (x + y >= mod ? x + y - mod : x + y);}
inline long long Subt(long long x, long long y) {return (x < y ? x - y + mod : x - y);}

#define Sum(p) (p ? p->sum : 0)
struct Node {
	long long sum, mul;
	Node *l, *r;
	Node() {
		l = r = NULL;
		sum = 0;
		mul = 1;
	}
	inline void Update() {
		sum = Add(Sum(l), Sum(r));
	}
};
Node nd[40 * N];
int top;
struct Segtree {
	Node *_root[N];
	inline void Pushdown(Node *p) {
		if (p->mul == 1) return;
		if (p->l) {
			p->l->sum = p->l->sum * p->mul % mod;
			p->l->mul = p->l->mul * p->mul % mod;
		}
		if (p->r) {
			p->r->sum = p->r->sum * p->mul % mod;
			p->r->mul = p->r->mul * p->mul % mod;
		}
		p->mul = 1;
		return;
	}
	inline void Modify(Node *&p, int pl, int pr, int idx, int v) {
		if (!p) p = &nd[top++];
		if (pl == pr) {
			p->sum = v;
			return;
		}
		int mid = pl + pr >> 1;
		Pushdown(p);
		if (idx <= mid) Modify(p->l, pl, mid, idx, v);
		else Modify(p->r, mid + 1, pr, idx, v);
		p->Update();
	}
	inline long long Query(Node *p, int pl, int pr, int l, int r) {
		if (!p) return 0;
		if (pl == l && pr == r) return p->sum;
		Pushdown(p);
		int mid = pl + pr >> 1;
		if (mid >= r) return Query(p->l, pl, mid, l, r);
		else if (mid + 1 <= l) return Query(p->r, mid + 1, pr, l, r);
		else return Add(Query(p->l, pl, mid, l, mid), Query(p->r, mid + 1, pr, mid + 1, r));
	}
	inline Node* Merge(Node *p1, Node *p2, int pl, int pr, long long ps1, long long ps2, long long sum2) {
		if (!p1 && !p2) return NULL;
		if (!p1) {
			p2->mul = p2->mul * ps1 % mod;
			p2->sum = p2->sum * ps1 % mod;
			return p2;
		}
		if (!p2) {
			p1->mul = p1->mul * Add(ps2, sum2) % mod;
			p1->sum = p1->sum * Add(ps2, sum2) % mod;
			return p1;
		}
		if (pl == pr) {
			ps2 = Add(ps2, p2->sum);
			p1->sum = p1->sum * Add(ps2, sum2) % mod;
			p2->sum = p2->sum * ps1 % mod;
			p1->sum = Add(p1->sum, p2->sum);
			p1->mul = 1;
			return p1;
		}
		Pushdown(p1); Pushdown(p2);
		int mid = pl + pr >> 1;
		long long l1s = Sum(p1->l), l2s = Sum(p2->l);
		p1->l = Merge(p1->l, p2->l, pl, mid, ps1, ps2, sum2);
		p1->r = Merge(p1->r, p2->r, mid + 1, pr, Add(ps1, l1s), Add(ps2, l2s), sum2);
		p1->Update();
		return p1;
	}
};
Segtree sgt;

inline void AddEdge(int u, int v) {
	e[++pnt].to = v;
	e[pnt].nxt = hd[u];
	hd[u] = pnt;
}

inline void ReadTree() {
	n = qread();
	for (int i = 1;i < n;i++) {
		int u = qread(), v = qread();
		AddEdge(u, v);
		AddEdge(v, u);
	}
}

inline void Dfs1(int u, int fa) {
	for (int i = hd[u];~i;i = e[i].nxt) {
		if (e[i].to != fa) {
			dep[e[i].to] = dep[u] + 1;
			Dfs1(e[i].to, u);
		}
	}
}

inline void ReadQ() {
	m = qread();
	for (int i = 1;i <= m;i++) {
		int u = qread(), v = qread();
		if (dep[u] < dep[v]) swap(u, v);
		if (dep[bnd[u]] < dep[v]) bnd[u] = v;
	}
}

inline void Dfs2(int u, int fa) {
	sgt.Modify(sgt._root[u], 0, n, dep[bnd[u]], 1);
	for (int i = hd[u];~i;i = e[i].nxt) {
		if (e[i].to != fa) {
			Dfs2(e[i].to, u);
			sgt._root[u] = sgt.Merge(sgt._root[u], sgt._root[e[i].to], 0, n, 0, 0, sgt.Query(sgt._root[e[i].to], 0, n, 0, dep[u]));
		}
	}
}

int main() {
	memset(hd, -1, sizeof(hd));
	ReadTree();
	dep[1] = 1;
	Dfs1(1, -1);
	ReadQ();
	Dfs2(1, -1);
	printf("%lld", sgt.Query(sgt._root[1], 0, n, 0, 0));
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}

```

---

## 作者：Owen_codeisking (赞：4)

一年前写过一篇博客
[min-max 卷积](https://www.luogu.com.cn/blog/Owencodeisking/qian-tan-min-max-juan-ji)

考前看了看前年打的牛客第二场第二题，题意大概是给定一个环，每个位置的数 $\in[1,a_i]$，要求相邻位置不相等，问有多少种环满足条件。

看完想能不能把容斥+整体 dp 放到树里呢？好像 noi/noip 没考过，自己花了一个下午想了想，想不出什么好题，本想把牛客这题的树上版本放 noip 模拟赛 t3 的。

然后 noi 就出了/cy。看到这题甚是高兴，打了一个 $O(n^2)$ 验证了一下正确性就去 rush 正解了。

上面均是废话↑↑↑

-------------

看到存在两字，第一反应是容斥。

假定我们有指定了 $k$ 条路径没有 $1$，相当于这些边赋 $0$。其他是可以任意选的，设 $k$ 条路径径的并有 $l$ 条，它对答案的贡献为 $(-1)^k\times 2^{n-1-l}$。

继而我们发现这些路径有特点，$u$ 是 $v$ 的祖先。这样就可以 dp，$f_{i,j,k}$ 表示第 $i$ 个子树，$dep>j$ 的路径已被封锁，已选 $k$ 条路径的方案数，没有限制的话 $j=n+1$。再发现选多少条路径我们并不关心，我们只关心路径的奇偶性，可以把 $-1$ 乘到 dp 数组里面。这样我们的 dp 是两维的。

转移方程:

- 合并两个子树 $f'_{\min(i,j)}=\sum (f_i\times f_j)$

- 加入限制，设最大的限制深度为 $D$，没有就不执行 $f'_{1..D-1}=0,f'_D=-\sum f_{D+1..n+1},f_{D+1..n+1}$ 不变。

- 把任意选 $0/1$ 的方法乘进去，$f_{1..dep-1}$ 不变，$f_{dep..n+1}$ 每个都乘 $2$。

这样就可以拿到 $O(nm)$ 的分数（大概），不过会了 $64$ 应该就会 $100$ 了吧（雾

接下来就是对着这个 dp 优化。（建议可以去做做「PKUWC2018」Minimax）

第一条方程是 min 卷积，可以线段树合并，进入左子树的时候把右子树的答案加过来，维护乘法标记。

第二条方程需要支持区间清 $0$，区间求和。

第三条方程需要支持区间乘法。

这些都可以线段树，所以就可以在时间 $O(n\log n)$ 解决该问题。

还有，这个线段树合并是不用给空节点下传标记的，因为没有的位值在原 dp 数组是 $0$。

-------------

下面均是废话↓↓↓

可能是我的常数比较大，我刚开始直接暴力清零，本机 2.01s，后来加了一个最大的 $D$ 的剪枝，本机 1.78s，开个 O2 1.49s。幸好当时卡了卡常，最后好像评测最大一个点 1.81s。上次省选 d1t2 的教训铭记在心，所以，在赛场的时候如果实在卡不进时限的 1/2 也尽量卡一卡，说不定就少了一次申诉（雾

你问代码？放考场了，这辈子都不可能有的，还是等好心人发一发吧（雾

---

## 作者：AzusaCat (赞：3)

我们在一条链的底部加入这条链的限制。考虑 dp，设 $f(u,t)$ 为以 $u$ 为根的子树，目前尚未满足并且已经被加入的链中，最深的链顶的深度为 $t$ 的方案数。特殊的，当所有限制都被满足，方案数被记在 $f(u,0)$ 中。则答案为 $f(1,0)$。

那么我们考虑加入一个子树 $v$ 的答案，不难发现有转移
$$
\begin{aligned}
f'(u,t)&=\sum\limits_{\max(x,y)=t}f(u,x)f(v,y)+f(u,t)\sum\limits_{y\leqslant deep_u}f(v,y)\\
&=f(u,t)\left(\sum\limits_{y=0}^tf(v,y)+\sum\limits_{z=0}^{deep_u}f(v,z)\right)+f(v,t)\sum\limits_{x=0}^{t-1}f(u,x)\\
&=f(u,t)(s(v,t)+s(v,deep_u))+f(v,t)s(u,t-1)\\
\end{aligned}
$$
其中 $s$ 是前缀和。这个转移叫做 “max 卷积”，这个东西看上去难以维护，怎么优化我们一会再说。

合并完所有子树之后我们对每一个点需要增加以这个点为底的限制，设 $maxd_u$ 为以 $u$ 为起点的所有链中链顶最深的节点的深度，那么则
$$
f'(u,t)=
\begin{cases}
f(u,t)&t> maxd_u\\
\sum\limits_{x=0}^{maxd_u}f(u,x) &t=maxd_u\\
0 &t<maxd_u
\end{cases}
$$
接下来我们说怎么优化这个 dp。先做 max 卷积。max 卷积可以通过线段树合并来实现：具体地，我们合并的时候，维护两个标记 $s1,s2$ 分别表示 $s(v,l-1)+s(v,deep_u)$ 和 $s(u,l-1)$，那么当递归到叶子节点时，直接按照标记这个乘一下；当某一个区间只在一棵树中存在时，是一个区间乘的形式；剩下的情况先把左儿子的 $sum$ 加到标记上，递归右儿子，再用之前的标记递归左儿子，最后合并答案即可。

然后合并完所有的子树，加入新的限制时，相当于区间查询、区间修改和新增一个节点，都可以使用线段树维护。复杂度的话，由于每一个限制至多新增一个节点，所以一开始所有线段树的总结点数是 $O(n\log n)$ 的（这里认为 $n,m$ 同阶），然后合并时如果某一个节点在合并中的两棵树都存在，总结点数会 $-1$，而只在一棵树中存在的情况和都存在的情况次数是同阶的，所以总复杂度为 $O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int const p=998244353;
int mod(int x){return x>=p?x-p:x;}
int n,m,target[1000005],pre[1000005],last[500005],tot,deep[500005],maxd[500005],
ch[20000005][2],sum[20000005],mul[20000005],tag[20000005],cnt,root[500005];
void add(int x,int y)
{
    target[++tot]=y;
    pre[tot]=last[x];
    last[x]=tot;
}
void dfs(int x,int fa)
{
    deep[x]=deep[fa]+1;
    for(int i=last[x];i;i=pre[i])
    {
        int tar=target[i];
        if(tar==fa)continue;
        dfs(tar,x);
    }
}
void pushdown(int l,int r,int x)
{
    int mid=(l+r)>>1;
    if(tag[x]!=-1)
    {
        if(ch[x][0])sum[ch[x][0]]=1ll*(mid-l+1)*tag[x]%p,tag[ch[x][0]]=tag[x];
        if(ch[x][1])sum[ch[x][1]]=1ll*(r-mid)*tag[x]%p,tag[ch[x][1]]=tag[x];
        tag[x]=-1;
    }
    if(mul[x]!=1)
    {
        if(ch[x][0])sum[ch[x][0]]=1ll*sum[ch[x][0]]*mul[x]%p,mul[ch[x][0]]=1ll*mul[x]*mul[ch[x][0]]%p;
        if(ch[x][1])sum[ch[x][1]]=1ll*sum[ch[x][1]]*mul[x]%p,mul[ch[x][1]]=1ll*mul[x]*mul[ch[x][1]]%p;
        mul[x]=1;
    }
}
int query(int l,int r,int x,int a,int b)
{
    if(!x)return 0;
    pushdown(l,r,x);
    if(l>=a&&r<=b)return sum[x];
    int mid=(l+r)>>1,ans=0;
    if(a<=mid)ans=query(l,mid,ch[x][0],a,b);
    if(b>mid)ans=mod(ans+query(mid+1,r,ch[x][1],a,b));
    return ans;
}
int merge(int l,int r,int x,int y,int s1,int s2)
{
    if((!x)&&(!y))return 0;
    pushdown(l,r,x),pushdown(l,r,y);
    if((!x)||(!y))
    {
        if(!x)
        {
            sum[y]=1ll*sum[y]*s2%p;
            mul[y]=1ll*mul[y]*s2%p;
            return y;
        }
        sum[x]=1ll*sum[x]*s1%p;
        mul[x]=1ll*mul[x]*s1%p;
        return x;
    }
    if(l==r)
    {
        sum[x]=(1ll*sum[x]*(s1+sum[y])+1ll*sum[y]*s2)%p;
        return x;
    }
    int mid=(l+r)>>1;
    ch[x][1]=merge(mid+1,r,ch[x][1],ch[y][1],mod(s1+sum[ch[y][0]]),mod(s2+sum[ch[x][0]]));
    ch[x][0]=merge(l,mid,ch[x][0],ch[y][0],s1,s2);
    sum[x]=mod(sum[ch[x][0]]+sum[ch[x][1]]);
    return x;
}
void insert(int l,int r,int &x,int a,int b)
{
    if(!x)x=++cnt;
    pushdown(l,r,x);
    if(l==r){sum[x]=b;return;}
    int mid=(l+r)>>1;
    if(a<=mid)insert(l,mid,ch[x][0],a,b);
    else insert(mid+1,r,ch[x][1],a,b);
    sum[x]=mod(sum[ch[x][0]]+sum[ch[x][1]]);
}
void modify(int l,int r,int x,int a,int b,int c)
{
    if(a>b)return;
    if(!x)return;
    pushdown(l,r,x);
    if(l>=a&&r<=b){sum[x]=1ll*(r-l+1)*c%p;tag[x]=c;mul[x]=1;return;}
    int mid=(l+r)>>1;
    if(a<=mid)modify(l,mid,ch[x][0],a,b,c);
    if(b>mid)modify(mid+1,r,ch[x][1],a,b,c);
    sum[x]=mod(sum[ch[x][0]]+sum[ch[x][1]]);
}
void dfs2(int x,int fa)
{
    insert(0,n,root[x],0,1);
    for(int i=last[x];i;i=pre[i])
    {
        int tar=target[i];
        if(tar==fa)continue;
        dfs2(tar,x);
        root[x]=merge(0,n,root[x],root[tar],query(0,n,root[tar],0,deep[x]),0);
    }
    if(maxd[x])
    {
        insert(0,n,root[x],maxd[x],query(0,n,root[x],0,maxd[x]));
        modify(0,n,root[x],0,maxd[x]-1,0);
    }
}
int read()
{
    int x=0;
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=x*10+ch-48,ch=getchar();
    return x;
}
int main()
{
    memset(tag,0xff,sizeof(tag));
    int x,y;
    n=read();
    for(int i=1;i<n;i++)x=read(),y=read(),add(x,y),add(y,x);
    dfs(1,0);
    m=read();
    for(int i=1;i<=m;i++)
        x=read(),y=read(),maxd[y]=max(maxd[y],deep[x]);
    dfs2(1,0);
    printf("%d",query(0,n,root[1],0,0));
    return 0;
}
```


---

## 作者：crashed (赞：3)

&emsp;&emsp;**去往[原博客](https://www.cnblogs.com/crashed/p/13541305.html)食用更佳。**

# 题目

&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P6773)看题目。

# 分析

&emsp;&emsp;看到链的限制很奇葩， " 存在一个重要的选择 " ，于是就不难想到容斥。

&emsp;&emsp;首先定义 $(u_1,v_1)\cup (u_2,v_2)$ 表示求两条路径的边的并集。

&emsp;&emsp;显然容斥式子长这个样子：
$$
\sum_{S\subset Q} (-1)^{|S|}\times 2^{n-1-|\bigcup_{p\in S}p|}
$$


## 24 pts

&emsp;&emsp;考虑暴力选出容斥式子中的 $S$，然后用一番树上差分求出 $|\bigcup_{p\in S}p|$。

&emsp;&emsp;时间复杂度是 $O(2^mn)$。

## 32 pts

&emsp;&emsp;同样是暴力选出容斥式子中的 $S$，只不过我们这一次利用**虚树**动态维护 $|\bigcup_{p\in S} p|$。

&emsp;&emsp;简单讲一讲做法：将所有链底拿出来，按照 DFN 排序为 $a_1,a_2,...,a_p$，每次覆盖从 $a_i$ 到 $\operatorname{LCA}(a_i,a_{i-1})$ 和 该链链顶 中的较深的点 的那条链，做一下树上差分，最后回收标记。

&emsp;&emsp;现在的时间是 $O(2^mm\log_2n+n)$。    
    
&emsp;&emsp;另一个方法是，使用树链剖分维护链并，并且按照**格雷码**的方式来枚举集合。时间是 $O(2^m\log_2^2n)$ 。

## 40 pts

&emsp;&emsp;~~研究 ing。~~

## 64 pts

&emsp;&emsp;直接暴力枚举 $S$ 的方法已经行不通了，我们需要换种方法统计后面这一大堆。

&emsp;&emsp;不难想到要用树形 DP。这里的状态设计比较奇妙，可以先自己思考一会儿。

&emsp;&emsp;猜到了吗？最暴力的状态还是：

&emsp;&emsp;$f(u,S)$：以 $u$ 为根的子树内，选中了 $S$ 集合中的链的容斥方案。

&emsp;&emsp;~~然后你就用另一种方式获得暴力容斥的分数。~~

&emsp;&emsp;注意到我们选取 $S$ 集合，实际上是想要知道，从 $u$ 到祖先上，哪些边会被限制到。

&emsp;&emsp;但是有一点是：**如果有 $u$ 是 $v$ 的祖先，且 $u$ 的父边已经被限制，那么 $v$ 的父边一定被限制**。这就是

&emsp;&emsp;这意味着，我们只需要记录**最浅的**被限制的边的深度（一条边的深度是较浅的那个端点的深度），于是状态可以改为：

&emsp;&emsp;$f(u,d,k)$：只考虑以 $u$ 为根的子树内的边，且此时**被限制的边的最小深度**是 $d$ ，选择了 $k$ 条链的方案数。

&emsp;&emsp;~~想到一个老 trick~~，冷静分析一下，发现完全不需要记录 $k$，直接在转移的时候乘 $-1$ 就行了。于是状态就变成了两维。

&emsp;&emsp;（以下记 $dep_u$ 为 $u$ 的深度）

&emsp;&emsp;转移如下：

1. 尝试合并一棵子树 $v$。此时我们需要考虑 $(u,v)$ 是否被限制。记 $g$ 为合并了 $(u,v)$ 之后 $v$ 的贡献。
   $$
   g(d)=f(v,d)\times 2^{[d\ge dep_v]}
   $$
   然后合并到 $u$ 上来就有：
   $$
   f(u,d)=\sum_{\min\{i,j\}=d}f(u,i)\times g(j)
   $$
   这个看似卷积又不太像卷积的东西（$\min$ 卷积），我们待会儿再来谈怎么优化它。

2. 考虑加入一条链，链顶的深度为 $d$，于是有转移：
   $$
   f(u,i)=f(u,i)-\sum_{\min\{k,d\}=i} f(u,k)
   $$
   冷静分析一下之后发现：
   $$
   f(u,k)=\begin{cases}0&k<d\\-\sum_{i=d+1}^{n}f(u,i)&k=d\\f(u,k)&k>d\end{cases}
   $$

&emsp;&emsp;另外还有一个边界条件，就是最初的时候有 $f(u,n)=1$，因为压根儿没有限制。

&emsp;&emsp;于是你就可以拿到 $O(n^2)$ 的暴力 DP 分数。结合 40 pts 的~~某些做法~~就可以获得 64 pts 的高分。

## 100 pts

&emsp;&emsp;这里需要用到一个叫做 " 整体 DP " 的技巧。

&emsp;&emsp;~~说得这么玄乎，~~其实这就是**使用数据结构维护 DP 数组**，方便进行结构性操作和区间操作。

&emsp;&emsp;在这个问题中，由于转移过程中 DP 数组并不会变长或者变短，因此我们可以考虑使用线段树维护 DP 数组。

&emsp;&emsp;那么考虑不同的转移：

1. 合并子树。此时求 $g$ 就相当于直接做区间乘法。

   考虑之后合并到 $u$ 上来。我们首先记后缀和：
   $$
   \begin{aligned}su(d)&=\sum_{i=d}^nf(u,d)\\sg(d)&=\sum_{i=d}^ng(d)\end{aligned}
   $$
   那么转移就是：
   $$
   f(u,d)=f(u,d)\times sg(d+1)+g(d)\times su(d+1)+f(u,d)\times g(d)
   $$
   如果这是正常的对应项求积，我们就可以直接线段树合并，然后在叶节点乘起来。

   现在我们还是可以线段树合并，不过我们需要求出 $sg$ 和 $su$，并且在叶节点加上额外贡献。

   当然每次直接查询是不科学的，我们应该利用 **cdq 分治的技巧**。我们在线段树合并的时候，如果当前区间是 $[l,r]$，我们就需要维护 $su(r+1)$ 和 $sg(r+1)$。

   我们可以首先递归左子树，并且将右子树的 $su$ 和 $sg$ 贡献给左子树。之后再贡献给右子树。

   于是就可以在线段树合并的过程中处理掉这个 $\min$ 卷积。

2. 新增一条链，可以发现加入一条链做了三件事情：

   - 区间清空。
   - 区间求和。
   - 单点赋值。

   这三个东西都可以用线段树快速处理。第一个可以直接区间乘法。

   一点优化：如果当前点 $u$ 是多条链的链尾，我们可以只处理**链顶深度最大的那条链**。

   这是由于，如果有两条链，链顶深度分别为 $d$ 和 $d'$，且 $d'<d$，我们可以说明只有 $d$ 会影响结果。

   如果我们让 $d$ 在 $d'$ 之后加入 DP，那么 $d'$ 的影响就被清除了。

   否则就是 $d'$ 在 $d$ 之后加入 DP。首先对于 $i<d'$ 和 $i>d'$，$f(u,i)$ 不会受到影响。考虑 $f(u,d')$，简单算一下 $\sum_{k=d'+1}^nf(u,k)$ 可以发现它也是 0。所以 $d'$ 对答案仍然没有影响。 

&emsp;&emsp;于是这道题就做完了，时间是 $O(n\log_2n)$。实际上代码也不怎么难写，基本上都是常规的算法。

&emsp;&emsp;~~我不是指思维的常规。不过仔细想想这道题的思路和技巧也并不是特别难。~~

&emsp;&emsp;~~顺便，它有亿点点卡常。~~

# 代码

```cpp
#include <cstdio>

typedef long long LL;

const int mod = 998244353;

const int MAXN = 5e5 + 5, MAXM = 5e5 + 5, MAXLOG = 40;
const int MAXS = MAXN * MAXLOG;

inline void read( int &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

inline void write( int x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

inline int MAX( const int a, const int b )
{
	return a > b ? a : b;
}

struct edge
{
	int to, nxt;
}Graph[MAXN << 1];

int ttag[MAXS];
int su[MAXS], lch[MAXS], rch[MAXS]; 
int siz;

int head[MAXN], dep[MAXN], rt[MAXN], mx[MAXN];
int N, M, cnt;

inline int newNode() { int cur = ++ siz; ttag[cur] = 1; return cur; }
inline void upt( const int x ) { su[x] = ( su[lch[x]] + su[rch[x]] ) % mod; }
inline void sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }
inline int mul( LL x, const int v ) { x *= v; if( x >= mod ) x %= mod; return x; }
inline void add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }
inline void mult( int x, const int p ) { if( ! x ) return ; su[x] = mul( su[x], p ), ttag[x] = mul( ttag[x], p ); }
inline void normalize( const int x ) { if( ! x || ttag[x] == 1 ) return; mult( lch[x], ttag[x] ), mult( rch[x], ttag[x] ), ttag[x] = 1; }

inline void addEdge( const int from, const int to )
{
	Graph[++ cnt].to = to, Graph[cnt].nxt = head[from];
	head[from] = cnt;
}

void multiply( int &x, const int l, const int r, const int segL, const int segR, const int delt )
{
	if( ! x ) return ;
	if( segL <= l && r <= segR ) { mult( x, delt ); return ; }
	int mid = l + r >> 1; normalize( x );
	if( segL <= mid ) multiply( lch[x], l, mid, segL, segR, delt );
	if( mid < segR ) multiply( rch[x], mid + 1, r, segL, segR, delt );
	upt( x );
}

void setVal( int &x, const int l, const int r, const int p, const int v )
{
	x = x ? x : newNode();
	if( l == r ) { su[x] = v; return ; }
	int mid = l + r >> 1; normalize( x );
	if( p <= mid ) setVal( lch[x], l, mid, p, v );
	else setVal( rch[x], mid + 1, r, p, v );
	upt( x );
}

int query( const int x, const int l, const int r, const int segL, const int segR )
{
	if( ! x ) return 0;
	if( segL <= l && r <= segR ) return su[x];
	int mid = l + r >> 1, ret = 0; normalize( x );
	if( segL <= mid ) add( ret, query( lch[x], l, mid, segL, segR ) );
	if( mid < segR ) add( ret, query( rch[x], mid + 1, r, segL, segR ) );
	return ret;
}

int merg( const int x, const int y, const int l, const int r, const int sufX, const int sufY )
{
	if( ! x ) { mult( y, sufX ); return y; }
	if( ! y ) { mult( x, sufY ); return x; }
	if( l == r )
	{
		su[x] = ( ( LL ) mul( su[x], sufY ) + mul( su[y], sufX ) + mul( su[x], su[y] ) ) % mod;
		return x;
	}
	int mid = l + r >> 1; normalize( x ), normalize( y );
	lch[x] = merg( lch[x], lch[y], l, mid, ( sufX + su[rch[x]] ) % mod, ( sufY + su[rch[y]] ) % mod );
	rch[x] = merg( rch[x], rch[y], mid + 1, r, sufX, sufY );
	upt( x );
	return x;
}

void DFS( const int u, const int fa )
{
	dep[u] = dep[fa] + 1;
	setVal( rt[u], 1, N, N, 1 );
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa )
		{
			DFS( v, u );
			multiply( rt[v], 1, N, dep[v], N, 2 );
			rt[u] = merg( rt[u], rt[v], 1, N, 0, 0 );
		}
	if( mx[u] ) 
	{
		multiply( rt[u], 1, N, 1, mx[u], 0 );
		int tVal = query( rt[u], 1, N, mx[u] + 1, N );
		setVal( rt[u], 1, N, mx[u], mod - tVal );
	}
}

void init( const int u, const int fa )
{
	dep[u] = dep[fa] + 1;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa ) init( v, u );
}

int main()
{
	read( N ); for( int i = 1, a, b ; i < N ; i ++ ) read( a ), read( b ), addEdge( a, b ), addEdge( b, a );
	init( 1, 0 ), read( M ); for( int i = 1, fr, to ; i <= M ; i ++ ) read( fr ), read( to ), mx[to] = MAX( mx[to], dep[fr] );
	DFS( 1, 0 ); write( su[rt[1]] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：whiteqwq (赞：2)

[P6773 [NOI2020] 命运](https://www.luogu.com.cn/problem/P6773)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1787176)

## 题意

给定一个$n$个点的树，再给定一个路径集合$Q$满足路径端点存在祖先关系，定义一个关键边集合$F$是合法的当且进当路径集合$Q$中所有的路径都覆盖了至少一条关键边，求有多少个关键边集合$F$合法。（$1\leqslant n\leqslant 5\times 10^5$）

## 分析

NOI2020D1T2，线段树合并优化dp经典题。

设$up_x$表示$x$子树中的路径向上覆盖到最**浅**的深度（如果没有任何路径则$up_x=0$）。

这个“至少”容易让人联想到容斥，但纯容斥似乎无法推出多项式复杂度的做法，因此考虑dp。

考虑定义一个既包含当前节点也包含当前路径集合覆盖状态的的树形dp，那么设$f_{x,y}$表示$x$的子树中未覆盖关键边的路径覆盖到最**深**的深度为$y$的方案数量。

当$y$更新$x$时，我们可以写出状态转移方程（上面为选择$(x,y)$的情况，不难发现$y$为下端点的路径最深只能覆盖到$dep_x$；下面为不选择$(x,y)$，讨论这个最深是$x$贡献还是$y$贡献）：

$$f_{x,i}\leftarrow f_{x,i}\times\sum_{j=0}^{dep_x}f_{y,j}\\f_{x,i}\leftarrow f_{x,i}\times\sum_{j=0}^i f_{y,j}+f_{y,i}\times\sum_{j=0}^{i-1}f_{x,j}$$

很容易用前缀和优化来帮助转移，可以做到$O(n^2)$，甚至可以用虚树来做到$O(n\times \min\{m,\max\{dep_x\}\})$：

$$f_{x,i}\leftarrow f_{x,i}\times sumf_{y,dep_x}+f_{x,i}\times sumf_{y,i}+f_{y,i}\times sumf_{x,i-1}$$

看到这种前缀/后缀的转移方程，以及发现有很多状态是没有值的（叶子节点仅会有一个状态有值），那么我们可以想到线段树合并（类型相似的题：[P5298 [PKUWC2018]Minimax](https://www.luogu.com.cn/problem/P5298)）。

具体地，我们对于每个点开线段树维护dp状态，首先把$f_{x,up_x}$设为$1$，然后将$x$的所有儿子代表的线段树与$x$的线段树合并，合并的时候维护一下$x$的dp值前缀和与$y$的dp值前缀和就好了。

时间复杂度/空间复杂度：$O(n\log n)$（单点修改仅会有$O(n)$次）。

## 代码
```
#include<stdio.h>
#include<vector>
using namespace std;
const int maxn=500005,maxk=maxn*32,mod=998244353;
int n,m;
int up[maxn],dep[maxn];
int cnt;
int lc[maxk],rc[maxk],lazy[maxk],val[maxk],rt[maxn];
vector<int>g[maxn];
inline void pushup(int now){
	val[now]=(val[lc[now]]+val[rc[now]])%mod;
}
inline void getlazy(int now,int v){
	val[now]=1ll*val[now]*v%mod,lazy[now]=1ll*lazy[now]*v%mod;
}
inline void pushdown(int now){
	if(lazy[now]==1)
		return ;
	getlazy(lc[now],lazy[now]),getlazy(rc[now],lazy[now]);
	lazy[now]=1;
}
void update(int l,int r,int &now,int pos,int v){
	if(now==0)
		now=++cnt,lazy[now]=1;
	if(l==r){
		lazy[now]=1,val[now]=v;
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(now);
	if(pos<=mid)
		update(l,mid,lc[now],pos,v);
	else update(mid+1,r,rc[now],pos,v);
	pushup(now);
}
int query(int l,int r,int now,int L,int R){
	if(L<=l&&r<=R)
		return val[now];
	int mid=(l+r)>>1,res=0;
	pushdown(now);
	if(L<=mid)
		res=(res+query(l,mid,lc[now],L,R))%mod;
	if(mid<R)
		res=(res+query(mid+1,r,rc[now],L,R))%mod;
	return res;
}
int merge(int l,int r,int a,int b,int &tag1,int &tag2){
	if(a==0&&b==0)
		return 0;
	if(a==0){
		tag2=(tag2+val[b])%mod,getlazy(b,tag1);
		return b;
	}
	if(b==0){
		tag1=(tag1+val[a])%mod,getlazy(a,tag2);
		return a;
	}
	if(l==r){
		int rec1=val[a],rec2=val[b];
		tag2=(tag2+rec2)%mod;
		val[a]=(1ll*val[a]*tag2%mod+1ll*val[b]*tag1%mod)%mod;
		tag1=(tag1+rec1)%mod;
		return a;
	}
	int mid=(l+r)>>1;
	pushdown(a),pushdown(b);
	lc[a]=merge(l,mid,lc[a],lc[b],tag1,tag2);
	rc[a]=merge(mid+1,r,rc[a],rc[b],tag1,tag2);
	pushup(a);
	return a;
}
void dfs(int x,int last){
	dep[x]=dep[last]+1;
	for(int i=0;i<g[x].size();i++){
		int y=g[x][i];
		if(y==last)
			continue;
		dfs(y,x);
	}
}
void getans(int x,int last){
	update(0,n,rt[x],up[x],1);
	for(int i=0;i<g[x].size();i++){
		int y=g[x][i];
		if(y==last)
			continue;
		getans(y,x);
		int tag1=0,tag2=query(0,n,rt[y],0,dep[x]);
		rt[x]=merge(0,n,rt[x],rt[y],tag1,tag2);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		g[x].push_back(y),g[y].push_back(x);
	}
	dfs(1,0);
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		up[y]=max(up[y],dep[x]);
	}
	getans(1,0);
	printf("%d\n",query(0,n,rt[1],0,0));
	return 0;
}
```

---

## 作者：_quasar_ (赞：2)

[显然更好的阅读体验](https://www.cnblogs.com/losermoonlights/p/14021204.html)

考虑容斥，枚举哪些路径一定不合法即可：$\sum (-1)^{|S|}2^{(n-1)-val_S}$ 。其中 $val_S$ 指 $S$ 中的路径覆盖的边数条数。

因为所有的路径的两个端点满足祖先关系，考虑用 $dp$ 解决这个问题。

令 $dp_{u,i}$ 表示对于所有**起点在 $u$ 的子树中**的路径，选了一些，满足选出来的这些路径的**终点**的最小深度为 $i$ 时的**容斥系数**和。

这里考虑将 $\sum (-1)^{|S|}2^{(n-1)-val_S}$ 拆为 $2^{n-1}\sum (-1)^{|S|}\frac{1}{2^{val_S}}$ ，然后所谓的容斥系数指的 $(-1)^{|S|}\frac{1}{2^{val_S}}$ ，这样就可以很方便的合并了。

直接这样做时间复杂度 $O(n^2)$ ，可以拿到 $36\ pts$ 。

```cpp
void solve(int u,int fa) {
    if(~top[u]) pls(dp[u][top[u]],mod-inv[dep[u]-top[u]]);
    pls(dp[u][dep[u]],1);

    for(int v:son[u]) if(v!=fa) {
        solve(v,u);
        lep(i,1,dep[u]) lep(j,1,dep[v]) {
            int res=mul(dp[u][i],dp[v][j]);
            if(j<dep[v]) res=mul(res,fac[dep[u]-max(i,j)]);
            pls(tmp[min(i,j)],res);
        }
        lep(i,0,n) dp[u][i]=tmp[i],tmp[i]=0;
    }
}
```

答案显然就是 $dp_{1,1}$ 。

（注意到可能有很多条起点为 $u$ 的路径，但是只需要保留最下面的一条（即终点深度最神的），因为乘上容斥系数后上面的全部抵消了。

考虑优化。

考虑另外一种更加整洁的 $O(n^2)$ 做法，即转移的时候枚举目标位置，然后中间这个 `if(j<dep[v])` 太丑了，去掉后在最后单独处理 $dp_{u,dep_u}$ 即可。这个 `fac[dep[u]-max(i,j)]` 也可以拆开。

```cpp
void solve(int u,int fa) {
    if(~top[u]) pls(dp[u][top[u]],mod-inv[dep[u]-top[u]]);
    pls(dp[u][dep[u]],1);

    for(int v:son[u]) if(v!=fa) {
        solve(v,u);

        lep(i,1,dep[u]) {
            int res=mul(mul(dp[u][i],dp[v][i]),inv[i]);
            lep(j,i+1,dep[u]) pls(res,mul(mul(dp[u][j],dp[v][i]),inv[j]));
            lep(j,i+1,dep[v]) pls(res,mul(mul(dp[u][i],dp[v][j]),inv[j]));
            dp[u][i]=res;
        }
        lep(i,0,n) dp[u][i]=mul(fac[dep[u]],dp[u][i]);
    }
    if(u!=1) dp[u][dep[u]]=mul(dp[u][dep[u]],2);
}
```

接下来，不妨将 $dp_{u,i}$ 重定义为 $dp_{u,i}\cdot \frac{1}{2^i}$ 。那么转移的时候就可以去掉后面的 `inv[*]` 。

然后就可以发现，$i$ 这个位置，转移就是三种：$u,v$ 都取第 $i$ 位置，$u$ 取第 $i$ 位且 $v$ 取一个后缀和，$v$ 取第 $i$ 位且 $u$ 取一个后缀和。

PKUWC 2018 Minimax 启发了我们线段树合并也可以优化一类有关前缀/后缀和转移的 $dp$ 。不妨考虑用线段树合并来解决此题，然后就做完了。

合并过程可以见 `merge` 函数。

```cpp
const int N=5e5+5;
int n,m,inv[N],fac[N],dep[N],top[N];
std::vector <int> son[N];

inline void init() {
    fac[0]=inv[0]=1;
    int inv2=modpow(2,-1);
    lep(i,1,n) inv[i]=mul(inv[i-1],inv2),fac[i]=mul(fac[i-1],2);
}

// {{{ Segment_Tree

#define mid ((l+r)>>1)

const int M=2e7+5;
int cnt,rt[N],lc[M],rc[M],sum[M],tag[M];

inline void update(int x,int v) {sum[x]=mul(sum[x],v),tag[x]=mul(tag[x],v);}
inline void pushdown(int x) {if(tag[x]!=1) update(lc[x],tag[x]),update(rc[x],tag[x]),tag[x]=1;}

void modify(int &x,int l,int r,int pos,int val) {
    if(!x) x=++cnt,tag[x]=1; pls(sum[x],val);
    if(l==r) return void();
    pushdown(x);
    pos<=mid?modify(lc[x],l,mid,pos,val):modify(rc[x],mid+1,r,pos,val);
}
void _ex_modify(int &x,int l,int r,int pos) {
    if(!x) x=++cnt,tag[x]=1;
    if(l==r) return sum[x]=mul(sum[x],2),void();
    pushdown(x);
    pos<=mid?_ex_modify(lc[x],l,mid,pos):_ex_modify(rc[x],mid+1,r,pos);
    sum[x]=add(sum[lc[x]],sum[rc[x]]);
}
int query(int x,int l,int r,int pos) {
    if(l==r) return sum[x];
    pushdown(x);
    return (pos<=mid?query(lc[x],l,mid,pos):query(rc[x],mid+1,r,pos));
}

int merge(int x,int y,int l,int r,int s1,int s2) {
    if(!x||!y) {
        if(!x) return update(y,s1),y;
        if(!y) return update(x,s2),x;
    }

    if(l==r) {
        int now=add(add(mul(sum[x],s2),mul(sum[y],s1)),mul(sum[x],sum[y]));
        if(!x) x=y;
        return sum[x]=now,x;
    }
    pushdown(x),pushdown(y);
    lc[x]=merge(lc[x],lc[y],l,mid,add(s1,sum[rc[x]]),add(s2,sum[rc[y]]));
    rc[x]=merge(rc[x],rc[y],mid+1,r,s1,s2);
    sum[x]=add(sum[lc[x]],sum[rc[x]]);
    return x;
}

// }}

void dfs(int u,int fa) {
    dep[u]=dep[fa]+1;
    for(int v:son[u]) if(v!=fa) dfs(v,u);
}
void solve(int u,int fa) {
    if(~top[u]) modify(rt[u],1,n,top[u],mul(mod-inv[dep[u]-top[u]],inv[top[u]]));
    modify(rt[u],1,n,dep[u],inv[dep[u]]);

    for(int v:son[u]) if(v!=fa) {
        solve(v,u);
        rt[u]=merge(rt[u],rt[v],1,n,0,0);
        update(rt[u],fac[dep[u]]);
    }
    if(u!=1) _ex_modify(rt[u],1,n,dep[u]);
}

int u,v;
int main() {
    freopen("destiny.in","r",stdin);
    freopen("destiny.out","w",stdout);

    IN(n);
    lep(i,2,n) IN(u,v),son[u].pb(v),son[v].pb(u);
    dfs(1,0);

    IN(m);
    lep(i,1,n) top[i]=-1;
    lep(i,1,m) IN(u,v),chkmax(top[v],dep[u]);
    init(),solve(1,0);
    printf("%d\n",mul(fac[n],query(rt[1],1,n,1)));
    return 0;
}
```

---

## 作者：TEoS (赞：2)

本文同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/13823593.html)

------------
**题意分析**

给出 $m$ 条直链，要求每条链上至少选中一条边，求方案数。

**思路分析**

想到用 DP 求解，自下向上统计。可以发现，对于下端点相同的链，若上端点最深的链满足条件，则这些链都会满足条件。另外，若一些对于经过一个节点的链，若比这个节点更深的边全部不选，则可以等同于这些链的下端点相同。

因此，可以设 $f_{x,i}$ 表示经过 $x$ 的未满足条件的上端点的最大深度为 $i$ 时的方案数，若没有经过 $x$ 的链则为 $0$ 。题目所求即为所有条件都满足时的方案数，即 $f_{root,0}$ 。对于 $x$ 的子节点 $y$ ，若选中边 $(x,y)$ ，则经过所有经过 $y$ 的边都可以满足条件；若不选，则只有上端点深度 $\leq i$ 的链才可以满足条件。即：

$$f'_{x,i}=f_{x,i} *\sum_{j=0}^{d_x} f_{y,j}+\sum_{j=0}^i\sum_{k=0,max(j,k)=i}^i f_{x,j}*f_{y,k}$$

整理得：

$$f'_{x,i}=f_{x,i} *(\sum_{j=0}^{d_x} f_{y,j}+\sum_{j=0}^{i} f_{y,j})+f_{y,i}\sum_{j=0}^{i-1} f_{x,j}$$

发现这个式子显然可以用前缀和优化。想到用线段树合并来做，其中 $\sum_{j=0}^{d_x} f_{y,j}$ 对于同一个 $y$ 来说是定值，可以先查询；剩下的元素都可以在线段树合并的过程中计算。可以维护一个乘法标记，前缀和可以通过先走左子树再走右子树来计算。

```c++
#include<iostream>
#include<cstdio>
#include<vector>
#define ll long long
using namespace std;
const int N=5e5+100;
const ll P=998244353;
struct Seg
{
	int lson,rson;
	ll sum,mul;
	#define lson(i) t[i].lson
	#define rson(i) t[i].rson
	#define sum(i) t[i].sum
	#define mul(i) t[i].mul
}t[N<<5];
int n,m,tot,cnt;
int head[N],ver[2*N],Next[2*N];
int r[N],d[N];
vector<int> query[N];
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,Next[tot]=head[y],head[y]=tot;
}
void add_query(int x,int y)
{
	query[y].push_back(x);
}
void spread(int p)
{
	if(lson(p))
	{
		sum(lson(p))=sum(lson(p))*mul(p)%P;
		mul(lson(p))=mul(lson(p))*mul(p)%P;
	}
	if(rson(p))
	{
		sum(rson(p))=sum(rson(p))*mul(p)%P;
		mul(rson(p))=mul(rson(p))*mul(p)%P;
	}
	mul(p)=1;
}//下传标记
int change(int p,int l,int r,int k)
{
	if(!p)
		p=++cnt,sum(p)=mul(p)=1;//新建节点
	if(l==r)
		return p;
	spread(p);
	int mid=l+r>>1;
	if(k<=mid)
		lson(p)=change(lson(p),l,mid,k);
	else
		rson(p)=change(rson(p),mid+1,r,k);
	return p;
}//新树，类似单点修改
ll ask(int p,int l,int r,int k)
{
	if(!p)
		return 0;
	if(r<=k)
		return sum(p);
	spread(p);
	int mid=l+r>>1;
	ll now=0;
	now=(now+ask(lson(p),l,mid,k))%P;
	if(k>mid)
		now=(now+ask(rson(p),mid+1,r,k))%P;
	return now;
}//区间查询 [0,k]
int merge(int x,int y,int l,int r,ll &sumx,ll &sumy)
{
	if(!x && !y)
		return 0;
	if(!x)
	{
		sumy=(sumy+sum(y))%P;
		sum(y)=(sum(y)*sumx)%P;
		mul(y)=(mul(y)*sumx)%P;
		return y;
	}
	if(!y)
	{
		sumx=(sumx+sum(x))%P;
		sum(x)=(sum(x)*sumy)%P;
		mul(x)=(mul(x)*sumy)%P;
		return x;
	}
	if(l==r)
	{
		int nowx=sum(x);//sum(x) 的值会改变，先存储
		sumy=(sumy+sum(y))%P;
		sum(x)=(sum(x)*sumy+sum(y)*sumx)%P;
		sumx=(sumx+nowx)%P;//f[x][i]*f[y][i] 算过一遍就不重复计算
		return x;
	}
	spread(x),spread(y);
	int mid=l+r>>1;
	lson(x)=merge(lson(x),lson(y),l,mid,sumx,sumy);
	rson(x)=merge(rson(x),rson(y),mid+1,r,sumx,sumy);
	sum(x)=(sum(lson(x))+sum(rson(x)))%P;
	return x;
}
void solve(int x,int fa)
{
	d[x]=d[fa]+1;
	int maxd=0;
	for(int i=0;i<query[x].size();i++)
		maxd=max(maxd,d[query[x][i]]);//找到最大深度
	r[x]=change(r[x],0,n,maxd);//新节点
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(y==fa)
			continue;
		solve(y,x);
		ll nowy=ask(r[y],0,n,d[x]),nowx=0;//先查询定值
		r[x]=merge(r[x],r[y],0,n,nowx,nowy);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1,x,y;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	scanf("%d",&m);
	for(int i=1,x,y;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		add_query(x,y);
	}
	solve(1,0);
	printf("%lld",ask(r[1],0,n,0));
	return 0;
}
```



---

## 作者：x7103 (赞：1)

[不知道更好还是更差的阅读体验](https://www.cnblogs.com/VCLS01/p/14940664.html)

## 题目描述

给定一棵树 $T=(V,E)$ 和点对集合 $\mathcal Q$ ，满足对于所有 $(u,v)\in \mathcal Q$，都有 $u\neq v$，并且 $u$ 是 $v$ 在树 $T$ 上的祖先。

求有多少个不同的函数 $f:E\to\{0, 1\}$（将每条边 $e\in E$ 的 $f(e)$ 值置为 $0$ 或 $1$），满足对于任何 $(u,v)\in\mathcal Q$，都存在 $u$ 到 $v$ 路径上的一条边 $e$ 使得 $f(e)=1$。

结果对 $998244353$ 取模。

## Solution

考虑 $\texttt{DP}$。

设 $f_{u,d}$ 表示节点为 $u$，没满足限制的最大深度为 $d$ 的方案数。

转移枚举 $(u,v)\in E$，则

$$f_{u,d}=\sum_{i=0}^{dep_u}{f_{v,i}}f_{u,d}+\sum_{i=0}^{d}{f_{v,i}}f_{u,d}+\sum_{i=0}^{d-1}{f_{u,i}}f_{v,d}$$

设 $s_{u,d}=\sum_{i=0}^{d}f_{u,i}$，则

$$f_{u,d}=f_{u,d}(s_{v,dep_u}+s_{v,d})+f_{v,d}s_{u,d-1}$$

线段树合并优化即可。时间复杂度为 $O(n\log n)$。

## Code
```cpp
#include<cstdio>
#include<vector>
using namespace std;
const int maxn=1000010,MLY=998244353;
template<class T>inline T Max(const T &a,const T &b){return a>b?a:b;}
vector<int> mp[maxn];
struct SegmentTree{
	int l,r,lc,rc,sum,mul;
	SegmentTree(){mul=1;}
}tr[maxn*10];
int Fir[maxn],Nxt[maxn],Too[maxn],tot;
int cnt,dep[maxn],root[maxn],n,m;
inline void add(int a,int b){
	Too[++tot]=b;Nxt[tot]=Fir[a];Fir[a]=tot;
}
inline void pushmul(int u,int d){
	tr[u].sum=1ll*tr[u].sum*d%MLY;
	tr[u].mul=1ll*tr[u].mul*d%MLY;
}
inline void pushdown(int u){
	pushmul(tr[u].lc,tr[u].mul);pushmul(tr[u].rc,tr[u].mul);
	tr[u].mul=1;
}
inline void pushup(int u){
	tr[u].sum=(tr[tr[u].lc].sum+tr[tr[u].rc].sum)%MLY;
}
inline int modify(int u,int l,int r,int p){
	u=++cnt;tr[u].sum=1;
	if(l==r)return u;
	int mid=(l+r)>>1;
	if(p<=mid)tr[u].lc=modify(tr[u].lc,l,mid,p);
	else tr[u].rc=modify(tr[u].rc,mid+1,r,p);
	return u;
}
inline int query(int u,int l,int r,int ql,int qr){
	if(!u||ql<=l&&r<=qr)return tr[u].sum;
	int mid=(l+r)>>1,ans=0;
	pushdown(u);
	if(ql<=mid)ans=query(tr[u].lc,l,mid,ql,qr);
	if(mid<qr)ans=(ans+query(tr[u].rc,mid+1,r,ql,qr))%MLY;
	return ans;
}
inline int merge(int p,int q,int l,int r,int &s1,int &s2){
	if(!p&&!q)return 0;
	if(!p){
		s1=(s1+tr[q].sum)%MLY;
		pushmul(q,s2);
		return q;
	}
	if(!q){
		s2=(s2+tr[p].sum)%MLY;
		pushmul(p,s1);
		return p;
	}
	if(l==r){
		int tp=tr[p].sum,tq=tr[q].sum;
		s1=(s1+tq)%MLY;
		tr[p].sum=(1ll*tr[p].sum*s1+1ll*tr[q].sum*s2)%MLY;
		s2=(s2+tp)%MLY;
		return p;
	}
	pushdown(p);pushdown(q);
	int mid=(l+r)>>1;
	tr[p].lc=merge(tr[p].lc,tr[q].lc,l,mid,s1,s2);
	tr[p].rc=merge(tr[p].rc,tr[q].rc,mid+1,r,s1,s2);
	pushup(p);
	return p;
}
inline void dfs(int u,int f){
	dep[u]=dep[f]+1;
	int mxdep=0;
	for(auto t:mp[u])mxdep=Max(mxdep,dep[t]);
	root[u]=modify(root[u],0,n,mxdep);
	for(int i=Fir[u];i;i=Nxt[i]){
		int v=Too[i];
		if(v!=f){
			dfs(v,u);
			int s1=query(root[v],0,n,0,dep[u]),s2=0;
			root[u]=merge(root[u],root[v],0,n,s1,s2);
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;++i){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;++i){
		int u,v;
		scanf("%d%d",&u,&v);
		mp[v].push_back(u);
	}
	dfs(1,1);
	printf("%d",query(root[1],0,n,0,0));
	return 0;
}
```

---

## 作者：chenzida (赞：1)

第一次写带 `push_down` 的线段树合并，记录一下。

首先抽象一下题意：给定一棵树，树上每个边可以染黑或者不染，有 $q$ 条限制，每条形如 ：在 $u\rightarrow v$ 的路径上，有至少一条边被染黑，保证 $u$ 是 $v$ 的祖先，求染色的方案数。

我们首先可以推出一个 $36pts$ 的 $dp$：

我们用 $dp_{x,i}$ 表示只考虑以 $x$ 为根的子树，在 $1\rightarrow x$ 的路径中离 $x$ 最近的染黑的边的深度（边的深度定义为连接的两个点深度较深的点的深度）为 $i$ 时的方案数。

我们发现对于一个 $x$，如果 $i$ 过小就会不合法，我们用 $lim_x$ 表示对于 $x$ 来说，$i$ 有解时最小的 $i$ 是多少。由于我们发现当 $x,i$ 合法，那么 $x$ 直到 $i$ 链接的儿子点直接的所有边都没有被染黑，所以我们要保证这一段中没有完整的限制，那我们对于每条限制 $lim_v=dep_u+1$ 然后每次 $lim_v$ 都尝试被父亲更新即可。

然后我们考虑 $dp$ 的转移，这个非常简单，就是考虑每个儿子是取到 $i$ 还是直接取到 $dep_v$。不过注意，那个 $dp$ 的取值只能是 $[lim_x,dep_x]$ 之间的数。

时间复杂度 $n^2$，结合虚树可以拿到 $72pts$。

然后我们考虑优化，发现我们可以将 $i$ 那一维压到线段树上，然后就能合并了。

我们要支持区间 $+$，单点查询，线段树合并（乘法）。

这个直接套板子就好了。

不过要重点强调一件事

```cpp
void merge(int rt1,int rt2,int l,int r)
{
	if(l==r){update1(rt1,tr2[rt2]);return;}
	push_down(rt1);push_down(rt2);int mid=(l+r)>>1;
	if(ls[rt1]&&ls[rt2])merge(ls[rt1],ls[rt2],l,mid);
	if(rs[rt1]&&rs[rt2])merge(rs[rt1],rs[rt2],mid+1,r);
}
```

这样的话会直接 $RE 64pts$，沦为暴力分。

因为它 `push_down` 之后可以顺着你的合并一层层的 `push_down` 下去，引起合并的时候空间爆炸。

~~所以我就去看了看duyi大佬的题解，发现有一种非常优秀的写法~~

下面的代码摘自 @duyi 的题解

```cpp
int merge(int x, int y){
	if (!ls[x] && !rs[x]) swap(x, y);
	if (!ls[y] && !rs[y]){
		upd_mul(x,tag_add[y]);
		return x;
	}
	push_down(x), push_down(y);
	ls[x] = merge(ls[x], ls[y]);
	rs[x] = merge(rs[x], rs[y]);
	return x;
}
```
这样的话，我们就可以避免 `push_down`造成的空间爆炸了，因为这是本蒟蒻第一道带 `push_down` 的线段树合并，所以太菜了大佬们勿喷。

然后完整代码就不放了，毕竟借鉴了 duyi 大佬的博客

---

## 作者：HikariS (赞：1)

### 我竟然一直写了个假的线段树合并！
考场上连$O(n^2)$暴力都不会。。我是SB

感觉$O(2^m m\log n)$的暴力容斥的部分分就是用来迷惑人的。。

$dp_{u,j}$表示从$u$开始往上$j$条边全是$0$且第$j+1$条边为$1$的方案数。

（其实定义成到深度为$j$的边全是$0$更好，我不知道我为何要自找麻烦。。就按这个接着说吧）

每个点有一个$lim_u$表示$u$往上最多允许有几条连续的$0$边。每次新增条件的时候就更新一下它。
$$ dp_{u,j}=\left\{
\begin{aligned}
0 & & j > lim_u\\
\prod_{v \in son_u} (dp_{v,j+1}+dp_{v,0}) & & 0 \leq j \leq lim_u
\end{aligned}
\right.
$$
然后如果$O(n^2)$实现的比较好可以获得$72$分，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fp(i,l,r) for(register int (i)=(l);(i)<=(r);++(i))
#define fd(i,l,r) for(register int (i)=(l);(i)>=(r);--(i))
#define fe(i,u) for(register int (i)=front[(u)];(i);(i)=e[(i)].next)
#define mem(a) memset((a),0,sizeof (a))
#define O(x) cerr<<#x<<':'<<x<<endl
#define int long long
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)wr(x/10);
	putchar('0'+x%10);
}
const int MAXN=5e5+10,mod=998244353;
inline void tmod(int &x){x%=mod;}
struct tEdge{
	int v,next;
}e[MAXN<<1];
int front[MAXN],tcnt,dep[MAXN],n,m,lim[MAXN];
vector<int>dp[MAXN];
inline void adde(int u,int v){
	e[++tcnt]={v,front[u]};front[u]=tcnt;
}
void dfs1(int u,int f){
	dep[u]=dep[f]+1;lim[u]=dep[u]-1;
	fe(i,u){
		int v=e[i].v;if(v==f)continue;
		dfs1(v,u);
	}
}
void dfs(int u,int f){
	lim[u]=min(lim[u],lim[f]+1);dp[u].resize(lim[u]+1);fp(i,0,lim[u])dp[u][i]=1;
	fe(i,u){
		int v=e[i].v;if(v==f)continue;
		dfs(v,u);
		fd(j,lim[u],lim[v])tmod(dp[u][j]*=dp[v][0]);
		fd(j,min(lim[u],lim[v]-1),0)tmod(dp[u][j]*=dp[v][j+1]+dp[v][0]);
	}
}
main(){
	freopen("destiny.in","r",stdin);freopen("destiny.out","w",stdout);
	n=read();
	fp(i,1,n-1){
		int x=read(),y=read();adde(x,y);adde(y,x);
	}
	dfs1(1,0);m=read();
	fp(i,1,m){
		int x=read(),y=read();lim[y]=min(lim[y],dep[y]-dep[x]-1);
	}
	dfs(1,0);
	printf("%lld\n",dp[1][0]);
	return 0;
}
```
然后可以线段树合并来优化了，就是每个节点我们先区间赋值为$1$然后再与儿子节点线段树合并。

然后我写了一份$48$分的代码。。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fp(i,l,r) for(register int (i)=(l);(i)<=(r);++(i))
#define fd(i,l,r) for(register int (i)=(l);(i)>=(r);--(i))
#define fe(i,u) for(register int (i)=front[(u)];(i);(i)=e[(i)].next)
#define mem(a) memset((a),0,sizeof (a))
#define O(x) cerr<<#x<<':'<<x<<endl
#define int long long
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)wr(x/10);
	putchar('0'+x%10);
}
const int MAXN=5e5+10,mod=998244353;
inline void tmod(int &x){x%=mod;}
struct tEdge{
	int v,next;
}e[MAXN<<1];
int front[MAXN],tcnt,dep[MAXN],n,m,lim[MAXN],val[MAXN*80],nn,D;
signed ls[MAXN*80],rs[MAXN*80],cnt,rt[MAXN];
inline void adde(int u,int v){
	e[++tcnt]={v,front[u]};front[u]=tcnt;
}
void dfs1(int u,int f){
	lim[u]=dep[u];
	fe(i,u){
		int v=e[i].v;if(v==f)continue;
		dep[v]=dep[u]+1;dfs1(v,u);
	}
}
inline void pushdown(signed o){
	if(!val[o])return;
	if(!ls[o])ls[o]=++cnt;if(!rs[o])rs[o]=++cnt;
	val[ls[o]]+=val[o];val[rs[o]]+=val[o];val[o]=0;
}
void add(signed &o,int l,int r,int ql,int qr,int v){
	if(!o)o=++cnt;if(ql<=l&&qr>=r){tmod(val[o]+=v);return;}
	int mid=l+r>>1;pushdown(o);
	if(ql<=mid)add(ls[o],l,mid,ql,qr,v);
	if(qr>mid)add(rs[o],mid+1,r,ql,qr,v);
}
void merge(signed &o1,signed o2,int l,int r){
	if(!o1)return;if(!o2){o1=0;return;}
	if(l==r){tmod(val[o1]*=val[o2]);return;}
	int mid=l+r>>1;pushdown(o1);pushdown(o2);
	merge(ls[o1],ls[o2],l,mid);merge(rs[o1],rs[o2],mid+1,r);
}
int ask(signed o,int l,int r,int p){
	if(l==r)return val[o];
	int mid=l+r>>1;pushdown(o);
	if(p<=mid)return ask(ls[o],l,mid,p);
	else return ask(rs[o],mid+1,r,p);
}
void dfs(int u,int f){
	int d=n-dep[u],l=lim[u];
	add(rt[u],0,n,d,d+l,1);
	fe(i,u){
		int v=e[i].v;if(v==f)continue;
		dfs(v,u);add(rt[v],0,n,d,d+l,ask(rt[v],0,n,d-1));
		merge(rt[u],rt[v],0,n);
	}
}
main(){
	freopen("destiny.in","r",stdin);freopen("destiny.out","w",stdout);
	n=read();nn=n*2;
	fp(i,1,n-1){
		int x=read(),y=read();adde(x,y);adde(y,x);
	}
	dfs1(1,0);m=read();
	fp(i,1,m){
		int x=read(),y=read();lim[y]=min(lim[y],dep[y]-dep[x]-1);
	}
	dfs(1,0);
	printf("%lld\n",ask(rt[1],0,n,n));
	return 0;
}
```
这是因为我的merge函数会把我区间覆盖后得到的节点不断下放，时间复杂度退化为$O(n^2)$。。

正确写法应该是每次看它的左右儿子是否都为空，若如此则不再递归。当然这样的话我们还得让线段树同时支持区间加法和乘法。
满分代码如下（不过常数很大。。）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fp(i,l,r) for(register int (i)=(l);(i)<=(r);++(i))
#define fd(i,l,r) for(register int (i)=(l);(i)>=(r);--(i))
#define fe(i,u) for(register int (i)=front[(u)];(i);(i)=e[(i)].next)
#define mem(a) memset((a),0,sizeof (a))
#define O(x) cerr<<#x<<':'<<x<<endl
#define ll long long
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)wr(x/10);
	putchar('0'+x%10);
}
const int MAXN=5e5+10,mod=998244353;
inline void rmod(int &x){x+=x>>31&mod;}
struct tEdge{
	int v,next;
}e[MAXN<<1];
int front[MAXN],tcnt,dep[MAXN],n,m,lim[MAXN],val[MAXN*60],mul[MAXN*60];
int ls[MAXN*60],rs[MAXN*60],cnt,rt[MAXN];
inline void adde(int u,int v){
	e[++tcnt]={v,front[u]};front[u]=tcnt;
}
void dfs1(int u,int f){
	lim[u]=dep[u];
	fe(i,u){
		int v=e[i].v;if(v==f)continue;
		dep[v]=dep[u]+1;dfs1(v,u);
	}
}
inline void mmul(int o,ll v){mul[o]=mul[o]*v%mod;val[o]=val[o]*v%mod;}
inline void madd(int o,int v){rmod(val[o]+=v-mod);}
inline void pushdown(int o){
	if(mul[o]==1&&!val[o])return;
	if(!ls[o])ls[o]=++cnt,mul[cnt]=1;if(!rs[o])rs[o]=++cnt,mul[cnt]=1;
	if(mul[o]!=1)mmul(ls[o],mul[o]),mmul(rs[o],mul[o]),mul[o]=1;
	if(val[o])madd(ls[o],val[o]),madd(rs[o],val[o]),val[o]=0;
}
void add(int &o,int l,int r,int ql,int qr,int v){
	if(!o)o=++cnt,mul[cnt]=1;if(ql<=l&&qr>=r){madd(o,v);return;}
	int mid=l+r>>1;pushdown(o);
	if(ql<=mid)add(ls[o],l,mid,ql,qr,v);
	if(qr>mid)add(rs[o],mid+1,r,ql,qr,v);
}
void merge(int &o1,int o2){
	if(!ls[o1]&&!rs[o1])swap(o1,o2);
	if(!ls[o2]&&!rs[o2]){mmul(o1,val[o2]);return;}
	pushdown(o1);pushdown(o2);
	merge(ls[o1],ls[o2]);merge(rs[o1],rs[o2]);
}
int ask(int o,int l,int r,int p){
	if(l==r)return val[o];
	int mid=l+r>>1;pushdown(o);
	if(p<=mid)return ask(ls[o],l,mid,p);
	else return ask(rs[o],mid+1,r,p);
}
void dfs(int u,int f){
	int d=n-dep[u],l=lim[u];
	add(rt[u],0,n,d,d+l,1);
	fe(i,u){
		int v=e[i].v;if(v==f)continue;
		dfs(v,u);add(rt[v],0,n,d,d+l,ask(rt[v],0,n,d-1));
		merge(rt[u],rt[v]);
	}
}
main(){
	freopen("destiny.in","r",stdin);freopen("destiny.out","w",stdout);
	n=read();
	fp(i,1,n-1){
		int x=read(),y=read();adde(x,y);adde(y,x);
	}
	dfs1(1,0);m=read();
	fp(i,1,m){
		int x=read(),y=read();lim[y]=min(lim[y],dep[y]-dep[x]-1);
	}
	dfs(1,0);
	printf("%d\n",ask(rt[1],0,n,n));
	return 0;
}
```

---


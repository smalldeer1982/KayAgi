# [NOI2020] 制作菜品

## 题目描述

厨师准备给小朋友们制作 $m$ 道菜，每道菜均使用 $k$ 克原材料。为此，厨师购入了 $n$ 种原材料，原材料从 $1$ 到 $n$ 编号，第 $i$ 种原材料的质量为 $d_i$ 克。$n$ 种原材料的**质量之和恰好为 $m \times k$ 克**，其中 $d_i$ 与 $k$ 都是**正整数**。

制作菜品时，一种原材料可以被用于多道菜，但为了让菜品的味道更纯粹，厨师打算每道菜**至多使用 $2$ 种**原材料。现在请你判断是否存在一种满足要求的制作方案。更具体地，方案应满足下列要求：
- 共做出 $m$ 道菜。
- 每道菜至多使用 $2$ 种原材料。
- 每道菜恰好使用 $k$ 克原材料。
- 每道菜使用的每种原材料的质量都为正整数克。
- $n$ 种原材料都被恰好用完。

若存在满足要求的制作方案，你还应该给出一种具体的制作方案。

## 说明/提示

#### 样例 1 解释

对于第二组数据，一种满足要求的制作方案为：
- 使用 $80$ 克原材料 $1$ 与 $20$ 克原材料 $2$ 做第一道菜。
- 使用 $10$ 克原材料 $2$ 与 $90$ 克原材料 $3$ 做第二道菜。
- 使用 $100$ 克原材料 $4$ 做第三道菜。

#### 样例 2

见选手目录下的 dish/dish2.in 与 dish/dish2.ans。

#### 样例 3

见选手目录下的 dish/dish3.in 与 dish/dish3.ans。

---

### 测试点约束

对于所有测试点：
$1 \leq T \leq 10$，$1 \leq n \leq 500$，$n - 2 \leq m \leq 5000$，$m \geq 1$，$1 \leq k \leq 5000$，$\sum_{i=1}^{n}d_i = m \times k$。

每个测试点的具体限制见下表：

| 测试点编号 |  $n$ |  $m$ |  $k$ |
| :-: | :-: | :-: | :-: |
|  $1\sim 3$ |  $\le 4$ |  $\le 4$ |  $\le 50$ |
|  $4\sim 5$ |  $\le 10$ |  $\le 10$ |  $\le 5\times 10^3$ |
|  $6\sim 7$ |  $\le 500$ |  $=n-1$ |  $\le 5\times 10^3$ |
|  $8\sim 9$ |  $\le 500$ |  $n-1\le m\le 5\times 10^3$ |  $\le 5\times 10^3$ |
|  $10$ |  $\le 25$ |  $\le 5\times 10^3$ |  $\le 5\times 10^3$ |
|  $11\sim 12$ |  $\le 25$ |  $\le 5\times 10^3$ |  $\le 500$ |
|  $13\sim 14$ |  $\le 50$ |  $\le 5\times 10^3$ |  $\le 500$ |
|  $15\sim 17$ |  $\le 100$ |  $\le 5\times 10^3$ |  $\le 5\times 10^3$ |
|  $18\sim 20$ |  $\le 500$ | $\le 5\times 10^3$ |  $\le 5\times 10^3$ |

## 样例 #1

### 输入

```
4
1 1 10
10
4 3 100
80 30 90 100
5 3 1000
200 400 500 900 1000
6 4 100
25 30 50 80 95 120```

### 输出

```
1 10
1 80 2 20
2 10 3 90
4 100
-1
1 5 5 95
1 20 4 80
2 30 6 70
3 50 6 50```

# 题解

## 作者：周子衡 (赞：66)

> 这篇题解将给出详细的证明。如果我能拿到自己考场代码应该会贴（不过看起来希望渺茫）。

看到题目感觉无从下手。观察数据范围，发现一个奇怪的限制 $n-2\leq m$，而且还专门给出了 $m=n-1$ 和 $m\geq n-1$ 的部分分，我们不妨从此入手思考。

对于 $m=n-1$，枚举 $n=2,3$ 发现都一定有解。我们不妨尝试直接将 $n$ 向 $n-1$ 转化：不失一般性，令 $d_1\leq d_2\leq \cdots\leq d_n$。我们发现应该要尽量先用光少的那些材料，而且少的尽量要配大的。可以证明下面两条引理：

**引理一：**$d_1 < k$。

**证明：** 用反证法。假设 $d_1\geq k$，那么 $d_2,...,d_n\geq k$，则 $d_1+\cdots+d_n\geq nk>(n-1)k=d_1+\cdots+d_n$。显然矛盾，故命题得证。

**引理二：**$d_1+d_n\geq k$。

**证明：** 用反证法。假设 $d_1+d_n\leq k-1$，那么 $d_n\leq k-1-d_1$，则 $d_1+d_2+\cdots+d_n\leq d_1+(n-1)(k-1-d_1)=(n-1)k-(n-1)-(n-2)d_1 < (n-1)k$，矛盾，所以 $d_1+d_n\geq k$。

综合上面两条引理，我们可以一次把 $d_1$ 用光，同时用 $d_n$ 填补空缺，显然是可行的。这样就成功将 $n$ 的情况转化成了 $n-1$ 的情况。而 $n=2$ 时直接放一起即可。综上，我们成功对于 $m=n-1$ 的任意情况构造出了一组解。

直接模拟的时间复杂度为 $O(n^2)$；可以简单用数据结构优化到 $O(n\log n)$，虽然本题中没有必要。

-------------

对于 $m\geq n$ 的情况，考虑向 $m=n-1$ 转化。同上令 $d_1\leq \cdots\leq d_n$，显然可证

**引理三：** $d_n\geq k$。

**证明：** 如果 $d_n < k$，则 $d_1+d_2+\cdots d_n < nk\leq mk=d_1+d_2+\cdots d_n $。矛盾。

所以我们用 $d_n$ 单独做一道菜，就可以令 $m$ 减少 $1$。这样就转化为 $m=n-1$ 的情况了。时间复杂度 $O(mn)$ 或 $O(m\log n)$。

-------------

接下来是最后的部分：$m=n-2$。

先手推一下 $n$ 较小的情况，发现 $n=3$ 必定无解，$n=4$ 是有解当且仅当存在两个 $d$ 加起来等于 $k$。也就是说，我们似乎要将这个问题向 $m=n-1$ 转化；把 $n$ 个物品分为两个集合，如果两个集合都能找到 $m=n-1$ 的方法，那么加起来就有一个 $m=n-2$ 的方法了。也就是说

**引理四：** 问题有解当且仅当能找到一个集合 $U=\{1,...,n\}$ 的子集 $S$，使得：

- 记 $x=|S|$ 为 $S$ 的大小，则 $\sum_{i\in S}d_i=(x-1)k$。

**证明：**

- **充分性：** 显然对于集合 $S$ 和 $T=U-S$，都是一个满足 $m=n-1$ 的子问题，而我们已经证明过了 $m=n-1$ 必定有解，则对 $S,T$ 分别构造解即可。

- **必要性：** 考虑构造一张图 $G$，$G$ 中有 $1,...,n$ 这些节点，如果两种原料在一道菜里同时选用则连一条边。发觉 $G$ 中至多有 $n-2$ 条边，则 $G$ 一定不连通。设 $G$ 有一个连通块 $S$，则相当于 $S$ 必须满足 $m=n-1$ 的有解约束，即 $\sum_{i\in S}d_i=(x-1)k$。证毕。

总之，只要我们能找到一些物品的集合 $S$ 满足 $\sum d=(|S|-1)k$，就能构造出符合题意的解。如何求这个 $S$ 呢？显然考虑做背包 DP。而由于右边带了一个 $|S|$，我们再做一步转化，将 $|S|k$ 移到左边，即要求

$\sum (d-k)=-k$

这样就变成一道经典的 01 背包问题了。直接求解的时间复杂度为 $O(n\sum d_i)=O(n^2k)$，用 bitset 优化即可做到 $O(\dfrac{n^2k}{w})$。

其他想说的话：

- 这题确实是一道锻炼思维的题，据我个人观察，考场上坐我旁边的选手们人均思考了一小时以上。
- 我大致想出了正解的思路，但没有想出 bitset 优化，前边 $n\leq 4$ 的特判又挂了（哈哈哈哈哈），感觉 $100->85$ 没什么，$85->70$ 确实是自己的水平问题……
- 希望以后 NOI 能多出今年这样的思维好题吧。

---

## 作者：JohnVictor (赞：19)

场外选手口胡一波。

先证明，如果 $m \ge n-1$ 一定有解。

我们试图做一道菜，用完一种原材料，这样 $m \le n-1$ 的性质会一直被保留，直到最后 $n=2,m=1$。

分类讨论：

如果任何一种原材料剩余的克数都不小于 $k$，那么依次使用每一种原材料直到用光，此时每一道菜都至多使用了 $2$ 种原材料。

否则，一定存在一种原材料，它的克数不超过 $k$。

如果存在克数不小于 $k$ 的原材料 $A$ 和小于 $k$ 的原材料 $B$，那么用光 $B$，剩下的用 $A$ 去做一道菜；

否则，取出克数最大的两种原材料 $C,D$，用光 $C$，剩下的用 $D$ 做一道菜。由于 $m \ge n-1$ 不难证明 $C,D$ 的克数和不小于 $k$。

这样，我们就给出了 $m \le n-1$ 的构造。

我们再构造一张图：如果两种原材料共做一道菜那么就连边。不难证明任何一个连通块中 $m \ge n-1$，所以如果 $m=n-2$ 并且有解，那么至少两个连通块，也就是存在一个 $l \le m$ 使得存在 $l$ 中原材料它们的总重量恰好是 $(l-1)k$，这样用它们做 $l+1$ 道菜剩余的也这样即可。

这是一个很裸的 $01$ 背包问题，将每一个原材料的克数减去 $k$ 之后和为 $-k$ 即可。

此时直接使用 $bitset$ 记录前 $t$ 个数选或者不选能得到的和的所有值，就可以做到 $Tn^2k/w$ 的复杂度，其中 $w=64$。

当然还要输出方案，当输出方案的时候，只要先找到最小的有解的 $t$，然后现在如果在第 $p$ 位，还需要 $S$ 的重量时，看一下$p-1$ 个 $bitset$ 中 $m$ 那一位是否为 $1$，如果是那么第 $p$ 位就不取，否则就取，就可以得到一种方案。

~~什么？代码？上午我口胡的时候没有电脑，哪里来的代码？~~

---

## 作者：djwj223 (赞：12)

[P6775 [NOI2020] 制作菜品](https://www.luogu.com.cn/problem/P6775?contestId=70211)

用一种基于随机的做法过的，但是用起来很优秀。

想法就是从 $m$ 与 $n$ 的关系入手去分析。

$m$ 与 $n$ 差较大的可以乱搞几次变成  $m$ 与 $n$ 差较小的，这里比较显然。

我们考虑 $m=n-1$ 的情况。

想想能不能直接用最小的和最大的去解决当前所需用料。

首先得证明他够。

假设最小的值等于 $x$，所以剩余值为 $(n-1)\times k-x$，再用鸽巢原理算发现最大值不小于 $\frac{n-1}{n-1}\times (k-x)$，必然大于等于 $k-x$，所以两者之和大于等于 $k$。

这样是无法转到 $m=n-2$ 的。

想想怎么把 $m=n-2$ 转化为 $m=n-1$ 的子问题。

于是发现： $m_1+m_2=n_1+n_2-2\rightarrow m_1=n_1-1,m_2=n_2-1$。

不合法的情况就是分不出的情况。

我们设 $val_i$ 的值为 $|a_i-k|$，把所有点最后分成两个集合：$S_1,S_2$，我们手玩几组数据就会发现当 $\sum_{i=1}^{n}val_i[i\in S_1']=\sum_{i=1}^{n}val_i[i\in S_2']$ （前式），再把 $S_1'$ 中 $val<0$ 的与 $S_2'$ 中 $val<0$ 的交换以后得到 $S_1,S_2$ 时原式（后式）也成立。

而得到前一个式子中两边的集合需要随机化，只要来一个 $sum$，如果大于原来的一半就随机减一个数，小于原来的一半就随机加一个数，否则跳出循环表示找到了。

反正挺玄学的，我跑了 2e6 次是可以在本题上 AC 的。

但是我们还要证明为什么这两个式子互为充要条件，感性理解是显然的，这里再理性分析一下，也只指一下方向，$\LaTeX$ 写写太麻烦了见谅哦。

证明前式交换以后必然满足后式要求：拆掉绝对值，考虑每部分的正数和和负数和，最后解开来就是说左右两式一样，于是得证。

证明后式必然能从前式推来：倒着做一遍，差不多思路。

于是这道题就做完了。

---

## 作者：Nemlit (赞：11)

本篇题解可能和官方题解做法不太一样，做法可能存在问题，一个结论也不会证明

由于考场上没想到$m=n-2$的处理，加之是同步赛，所以就懒得写代码了

其余题解多是从$m=n-1$下手，但这里尝试从$m=n$入手

我们将$n$个食谱想象成$n$根高度为$d_i$的柱子，如果$m=n$，那么我们的目标是变成$n$根高度为$k$的柱子，并且最终每根柱子最多由两根原来的柱子拼成。

结论：如果当前有一根比$k$小的柱子，很多根比$k$大的柱子。假设分别设为$k-a$, $k+x_1, k+x_2, k+x_3……, k+x_n$，满足$a\le\sum x_i,a>max_{j=1}^n(\sum_{i\ne j}x_i)$，那么我们一定存在一种方案，让他们变成$n$根高度为$k$的柱子，和一根比$k$大的柱子

证明：我们可以将$k+x_1$中分出$a$的高度给$k-a$，这样$k-a$这跟柱子的高度就变成了$k$，而$k+x_1$的高度就变成了$k+x_1-a$，显然是比$k$小的。

不难发现这变成了一个新的子问题，我们可以类似递归地处理即可。

也就是说，我们任意找到一个小于$k$的数和一些大于$k$的数，我们可以将其合并。

由于满足$\sum d_i=m\times k$，所以除非全部变成$k$，每次我们一定可以找到一个小于$k$的数和一些大于$k$的数，不难看出一定有解。

那么如果$m>n$怎么做呢？这个很简单，直接再初始的时候补充一些高度为$0$的柱子即可。复杂度$O(M)$

现在问题来了，怎么做$m=n-1$和$m=n-2$呢？

先来看下$m=n-1$的情况。发现我们有一根柱子是需要把他拆开，填入其余柱子的。

如果我们忽略一根柱子，将其他的$m$根柱子跑$n=m$情况的做法，那么我们会剩下很多高度为$k$的柱子和一些高度小于$k$的柱子，并且每根小于$k$的柱子的组成一定是他本身，即别的柱子没有分给他高度。

考虑我们上述的实现过程，每一次操作都是将自己的部分高度给别的柱子，让别的柱子恰好为$k$。相对的，对于最后高度不为$k$的柱子，一定没有被别的柱子给自己高度。

所以我们只需要让任意$n-1$根柱子去跑$n=m$的部分。对于剩下的小于$k$的柱子直接用多出来的那根去填即可。不难发现仍然一定合法。复杂度$O(M)$

再来看$m=n-2$的情况。这时候就会多出两根柱子和一些小于$k$的数了，但由于每根小于$k$的柱子最多只能由两根多出来的柱子之一拼成，所以很有可能会存在不能分割的情况。

这个地方不太会处理，但根据正解来看，我们只需要把他拆分成两个$n=m-1$的集合即可。但是用这种方法笔者并不太会证明为什么不能分成两个集合就一定无解。

如果知道结论，问题就转化成了，怎么将这些数分成两个集合，使得他们的和为$(|S|-1)\times k$，这个问题只需要将每个数减去$k$，也就转化成选择一些数，使得和为$-k$。这就变成了$01$背包的经典题目，由于只需要知道是否可行，$bitset$优化即可

代码太丑了，三个部分拆开写的，所以看上去很长，在$loj$上过了：[Code](https://loj.ac/submission/913183)

---

## 作者：chrisgr_pretty_girl (赞：8)

## $m \ge n - 1$ 

 对于这种情况我们有一个显而易见的贪心，设数量最少的原料为第 $i$ 个，数量最多的原料为第 $j$ 个。如果 $d_i \ge k$ 我们直接将其做成一道菜，否则我们将 $d_i$ 全部用作一道菜，同时在这道菜中加入 $d_j$ 的一部分，使得其符合要求。

 首先先证明一下贪心的正确性，将 $ d $ 数组排序，假设不存在 $d_1 + d_n > k$。  
 即假设 $d_1 + d_n \le k$。  
 因为 $ d $ 为正整数，那么 $d_n < k$。  
 就有 $\sum\limits_{i = 2}^{n - 1} d_i < (n - 2) \cdot k$。  
 那么 $\sum\limits_{i = 1}^{n} d_i < (n - 1) \cdot k$。  
 因为 $\sum\limits_{i = 1}^{n} d_i = m \cdot k$ 与 $m \ge n - 1$。   
 所以 $\sum\limits_{i = 1}^{n} d_i \ge (n - 1) \cdot k$。  
 与先前算的结果矛盾，所以假设不成立，在 $m \ge n - 1$ 时一定存在 $d_1 + d_n > k$ 同时因为二者相加严格大于 $k$ 所以每次贪心后，两个原料一定还会剩下至少一部分，所以最劣情况也只会 $m - 1$ 同时 $n - 1$ 不会在贪心过程中出现 $m < n - 1$ 的情况。

## $m = n - 2$

 对于这种情况，我们容易发现如果还按贪心做法，最终可能会出现 $m = 1$ 同时 $n = 3$ 的情况，方案不合法，所以我们需要考虑将 $m = n - 2$ 的情况转化为 $m = n - 1$ 的情况。  
 注意到当 $m = n - 2$ 时，可以将 $m$ 和 $n$ 分解为 $m_1 = n_1 - 1$ 和 $m_2 = n_2 - 1$ 那么只要我们对 $d$ 进行可行性背包，看是否可以将 $d$ 分为上述的两部分，并使用 `bitset` 优化，就可以通过本题了。
 
 题解还没通过，口胡一个证明吧。  
 首先这个充分性肉眼可见，所以只需要证明必要性。  
 假设 $m = n - 2$ 分不出来两部分。  
 那么第一种情况 $m = n - 2$ 无法拆分，那么容易证明此时一定没有合法解（拆不出两部分说明，没有一道菜可以同时消耗掉两种原料，那么每次做菜只会使 $m - 1$ 同时 $n - 1$ 最后一定存在 $m = 1$ 同时 $n = 3$ 的情况）。   
 第二种情况，我们可以分出 $m_1 > n_1 - 1$ 和 $m_2 < n_2 - 1$ 两个部分，对于第一部分肯定有解，第二部分肉眼可见无法拆分为 $m_1' \ge n_1' - 1$ 与 $m_2' \ge n_2' - 1$ 两部分，所以必然存在不可分，或一部分 $m < n - 1$ 此时对于前者可以归类为第一种情况的证明，对于后者我们递归划分 $m < n - 1$ 的部分最后必然会出现不可分，或分出 $m = 1$ 同时 $n = 3$ 的情况，两种情况都不合法，所以第二种情况不合法（感觉没啥问题~~轻喷~~）。

题解还没过，来聊聊时间复杂度吧~~挤牙膏写法~~。  
首先，贪心就算写的再丑陋也不是时间复杂度的大头（我写的是 $ \mathcal{O}(n \log n) $）所以我们来分析一下背包的时间复杂度吧。很明显没有优化的时候，背包的时间复杂度是 $\mathcal{O}(n^2 \cdot k)$ 这个时间复杂度明显只能过前 17 个点，所以我们对其优化，之后时间复杂度为 $\mathcal{O}(\frac{ n^2 \cdot k}{w})$ 稳稳通过本题。
 
 小细节：背包时有可能溢出，所以需要多开一点，并且初始化的值应该在中间。

 ## CODE

 
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 505;
int n, m, k, d[N];
bool book[N];
bitset<5000004>bag[N], kk;
void dfs(int x, int y) {
    if(!y) return;
    else if(!bag[x + 1][2500000 + y]) book[x] = 1, dfs(x + 1, y - d[x]);
    else dfs(x + 1, y);
}
struct node{ int id, d; };
bool operator <(const node & x, const node & y) { 
    if(x.d ^ y.d) return x.d < y.d;
    else return x.id < y.id;
}
int main() {
    //freopen("dish2.in", "r", stdin);
    //freopen("1.out", "w", stdout);
    int t;
    scanf("%d", &t);
    while(t--) {
    	//cout << t << endl << endl;
        scanf("%d%d%d", &n, &m, &k);
        for(int i = n; i; --i) scanf("%d", d + i);
        if(m == n - 2) {
            if(m == 3) {
				puts("-1");
                continue;
            }
            memset(book, 0, sizeof(book));
            int dd[N];
            for(int i = n; i; --i) {
                dd[i] = d[i];
                d[i] = k - d[i];
            }
            bag[n + 1][2500000] = 1, kk = 0, kk[2500000 + k] = 1;
            //cout << kk << endl;
            for(int i = n ; i; --i) {
                bag[i] = bag[i + 1] | (d[i] >= 0 ? bag[i + 1] << d[i] : bag[i + 1] >> -d[i]);
                //if(t == 5) cout << i << "  " << bag[i][k] << endl;
            }
            if((bag[1] & kk) == 0) {
                puts("-1");
                continue;
            }
            dfs(1, k);
            multiset<node> lc1, lc2;
            for(int i = n; i; --i) {
                if(book[i]) lc1.insert({n - i + 1, dd[i]});
                else lc2.insert({n - i + 1, dd[i]});
            }
            while(!lc1.empty()) {
                auto a = lc1.begin();
                node aa = *a;
                lc1.erase(a);
                printf("%d %d", aa.id, aa.d);
                if(aa.d < k) {
                    auto b = --lc1.end();
                    node bb = *b;
                    lc1.erase(b);
                    int bbb = k - aa.d;
                    printf(" %d %d", bb.id, bbb);
                    bb.d -= bbb;
                    if(bb.d) lc1.insert(bb);
                }
                putchar('\n');
            } while(!lc2.empty()) {
                auto a = lc2.begin();
                node aa = *a;
                lc2.erase(a);
                printf("%d %d", aa.id, aa.d);
                if(aa.d < k) {
                    auto b = --lc2.end();
                    node bb = *b;
                    lc2.erase(b);
                    int bbb = k - aa.d;
                    printf(" %d %d", bb.id, bbb);
                    bb.d -= bbb;
                    if(bb.d) lc2.insert(bb);
                }
                putchar('\n');
            } 
        } else {
            multiset<node> st;
            for(int i = n; i; --i) st.insert({n - i + 1, d[i]});
            while(!st.empty()) {
                auto a = st.begin();
                node aa = *a;
                st.erase(a);
                if(aa.d >= k) {
                    printf("%d %d", aa.id, k);
                    if(aa.d ^ k) {
                        aa.d -= k;
                        st.insert(aa);
                    }
                } else {
                    auto b = --st.end();
                    node bb = *b;
                    st.erase(b);
                    int bbb = k - aa.d;
                    printf("%d %d %d %d", aa.id, aa.d, bb.id, bbb);
                    bb.d -= bbb;
                    if(bb.d) st.insert(bb);
                }
                putchar('\n');
            }
        }
    }
    return 0;
}
```

---

## 作者：dbxxx (赞：6)

[欢迎到我的博客查看本文，谢谢！](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p6775.html)

给定正整数 $n$，$m$，$k$。

有一个 $m$ 行 $k$ 列网格，每个网格可以被涂上 $n$ 种颜色之一，要求：

- 一行最多出现两种颜色。
- 第 $i$ 种颜色必须恰好被使用 $a_i$ 次。

$\{a_i\}$ 给定，保证 $\sum a_i = m \times k$。请构造涂色方案或判定不存在。

多测，最多 $10$ 组数据。$1 \le n \le 500$，$\boldsymbol{n - 2 \le m} \le 5000$，$m \ge 1$，$1 \le k \le 5000$。

## $\boldsymbol{m = n - 1}$

虽然这题是个黑题，但是我们仍然可以发现，$a$ 的顺序和答案完全无关。两种套路：

- 先对 $a$ 排序。
- 对 $a$ 建立权值数组，在权值数组上做。

这里一看就是第一种，那就先对 $a$ 排个序。

然后我们开始观察这个仅次于暴力的第一档部分分。

首先我们发现，如果没有每行颜色种类限制，只要按照 $a_i$ 随便涂就可以了。因为有了颜色种类限制，所以如果我们选择把某两个要求使用次数很少的颜色涂在同一行，使得这行没被涂完，就会导致不合法。

因此，对于要求使用次数最少的颜色，我们可以让它和次数最多的颜色一起涂，这样贪心还是比较优秀的。

简单观察不难发现（这里的 $a_1$ 和 $a_n$ 是按 $a$ 不降排序后意义上的）：

- $a_1 < k$。
    - 否则 $\sum a \ge nk > mk = \sum a$ 显然不成立。
- $a_1 + a_n \ge k$（$n \ge 2$ 时）。
    - 反证法。假设 $a_1 + a_n < k$，则 $a_n < k - a_1$，则 $\sum a_i < a_1 + (n - 1)(k - a_1) = (2 - n)a_1 + (n - 1)k \le (n- 1)k$，和 $\sum a = (n - 1)k$ 矛盾。

注意到上面两条的证明依赖于 $a_i \ge 0$，$a_i$ 可以为 $0$。

综上所述，我们可以在第一行直接涂上 $a_1$ 个颜色 $1$，以及 $k - a_1$ 个颜色 $n$。

这样以来，对于第 $2 \sim m$ 行的涂色，可以看做颜色种类数少了 $1$，涂色行数少了 $1$，同时仍然有 $\sum a_i = (n - 1)k$ 的一个子问题。这里，第一种颜色一定会被涂完，我们直接丢弃这种颜色；而第 $n$ 种颜色可能会被涂完，此时我们也不将第 $n$ 种颜色丢弃，而是看做 $a_n = 0$ 的一种颜色，这样也是合法的。于是问题成功归纳。

归纳的边界是 $n = 1$，$m = 0$，显然此时已经不需要涂色了，问题解决。

（此时剩下的那个颜色 $a_1$ 一定有 $a_1 = 0$。）

## $\boldsymbol{n - 1 \le m \le 5 \times 10^3}$

其实整道题不难发现，在 $a_i$ 不变的情况下，$m$ 越大（对应地 $k$ 越小）时，涂色越容易。所以这个问题应该是比上面那个问题弱的。

事实上确实如此，直接把颜色数补齐到 $m + 1$ 就行了。具体来说，就是新建 $m + 1 - n$ 个 $a_i = 0$ 的颜色即可。。

到这里已经解决 45 分了。

我们观察一下新建颜色的实质，其实就是让前 $m + 1 - n$ 次涂色都是将 $a$ 最大的那个颜色涂完一整行。根据新建颜色，并套用 $m = n - 1$ 的证明，可以得到在 $m > n - 1$ 时，$\max\{a_i\} \ge k$。当然，这个结论也可以很简单地通过 $m \ge n$ 时，$\sum a_i = mk \ge nk$ 所以最大值肯定不小于 $k$ 得到。

所以代码实现就不用新建颜色了，让头 $m + 1 - n$ 次颜色都让 $a$ 最大的颜色涂完一整行，转到 $m = n - 1$ 的情况即可。

## $\boldsymbol{m = n - 2}$

到这里没啥思路了，不妨考虑构造最常用的方法：建图。尤其是每行最多涂两个颜色的限制，启发我们对每行所涂的两种颜色连边。

那么题目变成：对 $n$ 个点连接 $m = n - 2$ 条边，并把点权按任意非负整数比例分配，贡献给它所连接的边的边权上，使得所有边边权恰好为 $k$。显然分配结束后所有点权应恰为 $0$。

这里一行颜色全为 $u$，可以看做这个颜色点和其它任何一个点 $v$ 连了一条边，并且 $v$ 没有给这条边分配权值，只有 $u$ 给这条边分配了恰好为 $k$ 的权值。

看起来无从下手，但是其实 $m \ge n - 1$ 的情况刚刚已经解决，保证给出一组方案了，只要把刚刚的思路放在图上即可，具体如下：

- 对于前 $m - n + 1$ 条边，我们连接点权最大的点 $u$ 和任意点 $v$，并将 $u$ 的点权分配 $k$ 的权值给这条边。（这里分配完权值后，$u$ 的点权也要动态地减去 $k$）。
- 对于后 $n - 1$ 条边，我们连接点权最大的点 $u$ 和点权最小的 **未标记点** $v$，然后：
    - 将 $u$ 的点权分配 $k - a_v$ 给这条边。
    - 将 $v$ 的点权 $a_v$ 全部分配给这条边，并 **标记** $v$。

这里一个点被标记，等价于之前对 $m \ge n - 1$ 方案的讨论中，一个颜色种类被丢掉。

那么对于 $m = n - 2$ 我们如何构造？观察到 $m = n - 2$ 时如果有解，任何一组解生成的图，一定不连通，即至少有 $2$ 个以上的连通块。下设全集 $U = \{1, 2, \ldots, n\}$，第 $i$ 个连通块点集为 $S_i$，$n_i = |S_i|$，并且这个连通块内部边数为 $m_i$。有以下发现：

- $\sum n_i = n$，$\sum m_i = m  = n - 2$。
- 根据连通块的连通性，$m_i \ge n_i - 1$。
- 第 $i$ 个连通块内部的点权明显要被这 $m_i$ 条边分配完（因为其它边不分配这些点权），所以 $\sum\limits_{u \in S_i}a_u =m_ik$。
- 至少存在两个 $i$ 满足 $m_i = n_i - 1$。
    - 否则，若最多存在一个 $i$ 满足 $m_i = n_i - 1$，会得到 $(\sum m_i) \ge  (\sum n_i) - 1$，也即 $m \ge n - 1$，矛盾。

因此，$m = n - 2$ 存在解的一个必要条件是：存在一个 $S \subseteq U$，使得 $\sum\limits_{u \in S}a_u = (|S| - 1)k$（也即对上面满足 $m_i = n_i - 1$ 的两个集合之一的描述）。

下面给出找到这样一个 $S$ 后的构造方案。

因为 $\sum\limits_{u \in S}a_u = (|S| - 1)k$，则考虑 $T = U \setminus S$，也有 $\sum\limits_{u \in T}a_u = (|T| - 1)k$。所以只需要分别对 $S$ 和 $T$ 分配 $|S| - 1$ 和 $|T| - 1$ 条边，分别构造。对 $S$ 构造 $|S| - 1$ 条边的方案是前面已经解决过的问题。

所以存在一个 $S \subseteq U$，使得 $\sum\limits_{u \in S}a_u = (|S| - 1)k$ 不仅是原问题有解的必要条件，也是充分的。接下来只需解决一个问题：如何快速找到这个 $S$。

这个问题很类似背包恰满问题，也就是在 $n$ 个有体积的物品中，找到 $|S|$ 个物品，恰满容量为 $(|S| - 1)k$ 的背包。

恰满的容量和物品选择的数量有关，不太好处理。可以对 $\sum\limits_{u \in S}a_u = (|S| - 1)k$ 处理成 $\sum\limits_{u \in S} a_u - k = -k$。

也就是 $n$ 个物品，第 $i$ 个物品体积为 $a_i - k$，求一个恰满体积 $-k$ 背包的容量组合。那就变成经典的容量恰满问题了。

根据 $0 \le \sum\limits_{u \subseteq S} a_u \le (n - 2) \times k$。这里 $S$ 代表 $U$ 的任意子集。可得：
$$
-nk \le -|S|k \le \sum\limits_{u \subseteq S} a_u - k \le (n - 2 - |S|)k \le (n - 2)k
$$
令 $f(i, j)$ 表示前 $i$ 个物品能否凑出体积 $j$，根据上面的式子，$j$ 的范围应为 $[-nk, (n - 2)k]$。

转移是 $f(i, j) = f(i - 1, j) \lor f(i - 1, j - v_i)$，其中 $v_i = a_i - k$。

可以考虑用 bitset 优化，设 $f(i)$ 为布尔型数组，第 $j$ 项为原先的 $f(i, j)$。在 bitset 上有：

`f[i] = f[i - 1] | (f[i - 1] << v[i])`。滚动一下得到 `f |= f << v[i]`。当然后面要输出方案所以别滚动了。

输出方案：设 $f(i, j) = \mathrm{true}$，检查 $f(i - 1, j)$ 和 $f(i - 1, j - v_i)$ 哪个是 $\mathrm{true}$ 即可（这两个肯定有一个是 $\mathrm{true}$），如果前者 $\mathrm{true}$ 就不取第 $i$ 个物品，转到 $f(i - 1, j)$；否则就取第 $i$ 个物品，转到 $f(i - 1, j - v_i)$。如果两个都是 $\mathrm{true}$ 说明无论取不取第 $i$ 个物品都行。从 $f(n, -k)$ 倒推做上面的操作即可。

背包复杂度是物品数量 $\times$ 物品子集和的值域大小 $\div$ bitset 优化的常数，即 $\Theta\left(\dfrac{nt}{w}\right) = \Theta\left(\dfrac{n^2k}{w}\right)$。这里 $t$ 表示 $a_i$ 任意子集的和的值域范围的长度，也即 $[-nk, (n - 2)k]$ 的长度，为 $\Theta(nk)$ 量级。

然后转化为 $m \ge n - 1$ 就是取 $m$ 次 $a$ 的最大最小值， 直接暴力，复杂度是 $\Theta(nm)$。

所以总复杂度 $\Theta\left(T\left(\dfrac{n^2k}{w} + nm\right)\right)$，算下来大概 $2 \times 10^8$，还可以。

```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2023-07-13 10:02:06 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2023-07-13 11:10:23
 */
#include <bits/stdc++.h>
inline int read() {
	int x = 0;
	bool f = true;
	char ch = getchar();
	for (; !isdigit(ch); ch = getchar())
		if (ch == '-')
			f = false;
	for (; isdigit(ch); ch = getchar())
		x = (x << 1) + (x << 3) + (ch ^ '0');
	return f ? x : (~(x - 1));
}

const int N = 505;
struct node {
	int val, id;
	bool operator < (node b) {
		if (val != b.val)
			return val < b.val;
		return id < b.id;
	}
};
int n, m, k;
std :: bitset <500 * 5000 * 2> f[N];

inline void easy(std :: vector <node> a) {
	int n = (int)a.size();
	for (int i = 1; i < n; ++i) {
		int x = std :: min_element(a.begin(), a.end()) - a.begin();
		int y = std :: max_element(a.begin(), a.end()) - a.begin();
		int p = a[x].val, q = k - p;
		if (p)
			printf("%d %d %d %d\n", a[x].id, p, a[y].id, q);
		else
			printf("%d %d\n", a[y].id, k);
		a[y].val -= q;
		std :: swap(a[x], a.back());
		a.pop_back();
	}
}

inline void solve() {
	n = read(); m = read(); k = read();
	std :: vector <node> a;
	for (int i = 1; i <= n; ++i)
		a.push_back({read(), i});
	if (m >= n - 1) {
		for (int i = 1; i <= m - n + 1; ++i) {
			int x = std :: max_element(a.begin(), a.end()) - a.begin();
			a[x].val -= k;
			printf("%d %d\n", a[x].id, k);
		}
		easy(a);
	} else {
		f[0].reset();
		f[0].set(n * k);
		for (int i = 1; i <= n; ++i) {
			int v = a[i - 1].val - k;
			if (v > 0)
				f[i] = (f[i - 1] | (f[i - 1] << v));
			else
				f[i] = (f[i - 1] | (f[i - 1] >> (-v)));
		}
		if (!f[n][-k + n * k])
			return void(puts("-1"));
		std :: vector <node> S, T;
		for (int i = n, j = -k + n * k; i; --i) {
			int v = a[i - 1].val - k;
			if (f[i - 1][j])
				T.push_back(a[i - 1]);
			else {
				S.push_back(a[i - 1]);
				j -= v;
			}
		}
		easy(S); easy(T);
	}
	return ;
}

int main() {
	int T = read();
	while (T--)
		solve();
	return 0;
}
```

如果您得这篇题解解决了您的疑惑，帮到了您，别忘了点个赞！

---

## 作者：lory1608 (赞：6)

### 前言

由于太菜，没进省队，这是我在同步赛赛场上写的最接近正解的一题。我写的是85分，loj测了也是 $85$ 分。

我认识的省队队员有许多人在这道题上翻了车，有一个本来（加上这一题）能进集训队的队员只拿了一个银牌，还是非常可惜的。

他们大部分都没有看到 $n − 2 \leq m \leq 5000$ 的限制，白白浪费时间推其他性质。确实，这个条件太隐蔽了，他在这里：

![](https://cdn.luogu.com.cn/upload/image_hosting/my5ml06m.png)

在中间，很多人都忽略了。

所以我希望大家在读题时都能**用笔在纸质版试卷上把重要的信息标出来，或者用电脑把那一块区域进行高亮**。不要失去了才追悔莫及。

### 解题思想与方法

其实这是一道贪心。

### 算法0

瞎搞，随机化贪心。

期望得分 ：$0-100$ 分。

我有一个认识的队员随机化贪心拿了 $70$ 分。

#### 算法1

对于前三个测试点，我们可以直接进行搜索，然后直接判断并输出方案即可。

期望得分：$15-25$ 分。

#### 算法2

对于测试点 $6-7$ ,我们一定可以构造出可行解。

**其实，我们可以看样例1和样例2来模拟，推性质。**

证明（数学归纳法）：

对于 $2$ 个元素他们的和为 $k$ 可以直接配对，是成立的。

假设有 $n$ 个元素和为 $(n-1)\times k$ 可以构造出可行解，那么对于 $n+1$ 个元素（其中每个元素都大于 $0$ ）和为 $n \times k$ 的情况。

首先我们可以取出最大的和最小的元素，显然最大值 $ + $ 最小值肯定大于 $k$ 。

我们可以反证法：

若最大值 $+$ 最小值小于等于 $k$ ,那么剩下的 $n-2$ 个数都小于 $k$ ,那么所有数的和一定小于 $(n-1)\times k$ ，与假设矛盾。

随后，我们只需要将最大值减去 （$k-$ 最小值），然后就变成 $n$ 个的情况了。

命题成立。

构造方法：每次取出最大值和最小值，将最大值 $-$ （ $k-$ 最小值）再然后就重复做下去。

显然我们可以用 $set$ 来维护这一过程。

这一段的复杂度是 $O(n\log n)$ 的。

期望得分: $10$ 分。

结合算法一后期望得分: $25-35$ 分。

### 算法3

对于 $n-1 \leq m \leq 5000$ 的测试点，我们可以用算法 $2$ 中的方法一样维护，但是有时候我们去出的最小值可能大于等于 $k$ ,此时我们只用让他自己做一道菜就行了。

复杂度 $O(n\log n)$

期望得分: $20$ 分。

结合算法一后期望得分: $35-45$ 分。

### 算法4

对于 $m=n-2$ 的点，我们可以想到将其拆成两部分大小分别为 $x$ 与 $y$ ，其中满足大小为 $x$ 的集合的权值和为 $(x-1)\times k$ ,大小为 $y$ 的集合的权值和为 $(y-1)\times k$ ,然后我们再用算法 $2$ 的方式构造即可，如果无法划分出来，答案就为 $-1$ 。

证明显然：如果我们无法拆成上述情况，则消到最后一定有三个元素之和为 $k$ 。

这就说明上述拆分是满足题意的**充分必要条件**。

然后我们可以用搜索去寻找是否有集合满足条件。

这一部分复杂度 $O(2^n)$ 。

期望得分: $60$ 分。

### 算法5

对于拆集合的过程我们可以进行dp，用 $f[i][j][t]$ 表示前 $i$ 个元素，选了 $j$ 个元素，权值和为 $t$ 是否可行。

那么我们就可以简单的转移 ，只用判断 $f[n][t][(t-1)\times k]$ 是否为 $1$ 即可。

最后倒着输出方案即可。

这一部分的复杂度为 $O(n^3k)$。

期望得分: $70$ 分。

### 算法6

对于算法 $5$，我们可以进行 $bitset$ 优化。

此时这一部分的复杂度为 $O(\dfrac{n^3k}{\omega})$ 。

期望得分: $85$ 分。

### 算法7

对于算法 $5$ ,我们只用知道 $j$ 与 $t$ 的相对大小关系就行了。

此时我们注意到满足条件的方案一定是有 $j\times k-t=k$ 即可。

那么，我们只需要将每个权值减去 $k$ ，然后 $0/1$ 背包 $dp$ ,就行了。

用 $dp[i][j]$ 表示前 $i$ 个元素权值和为 $j$ 是否可行。

最后我们只需要知道 $dp[i][-k]$ 是否可行即可。

然后再倒着输出方案即可。

此时这一部分的复杂度为 $O(n^2k)$ 。

期望得分: $85$ 分。

### 算法8

对于算法 $7$，我们可以进行 $bitset$ 优化。

此时这一部分的复杂度为 $O(\dfrac{n^2k}{\omega})$ 。

期望得分: $100$ 分。

### 我在考场上的做法

在考场上我是用的一种类似于 $Emily$ 家今天的饭一样的优化方法，写的 $O(n^2k)$ 的复杂度，很遗憾那种方法不能用 $bitset$ 优化。

### 正解代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<set>
#include<bitset>
#define iter multiset<node>::iterator 
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define REP(u) for(int i=p[u];i!=-1;i=e[i].nxt)
#define ll long long
using namespace std;
inline int getint()
{
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return (f==1)?x:-x;
}
const int maxn=505,maxk=5005;
int T,n,m,k;
int d[maxn];
namespace sol
{
	struct node
	{
		int id,val;
		node(int ii=0,int vv=0){id=ii,val=vv;}
		inline bool operator<(const node &b)const
		{
			if(val==b.val)return id<b.id;
			else return val<b.val;
		}
	};
	inline void solve(vector<pair<int,int> > &v)
	{
		multiset<node>s;
		s.clear();
		FOR(i,0,(int)(v.size())-1)s.insert(node(v[i].first,v[i].second));
		while(!s.empty())
		{
			iter hd=s.begin();
			int val=(*hd).val;
			int idx=(*hd).id;
			s.erase(hd);
			while(val>=k)printf("%d %d\n",idx,k),val-=k;
			if(s.empty())break;
			if(val!=0)
			{
				iter tl=s.end();
				--tl;
				int vall=(*tl).val;
				int idxx=(*tl).id;
				s.erase(tl);
				printf("%d %d %d %d\n",idx,val,idxx,k-val);
				vall-=k-val;
				if(vall!=0)s.insert(node(idxx,vall));
			}
		}
	}
}
namespace partition
{
	const int maxn=505;
	bitset<5000005>dp[maxn];
	bool vis[maxn];
	int temp[maxn],nowval=2500000;
	inline void init()
	{
		memset(dp,0,sizeof(dp));
		memset(vis,0,sizeof(vis));
		memset(temp,0,sizeof(temp));
	}
	inline void solve()
	{
		FOR(i,1,n)temp[i]=d[i]-k;
		dp[0][nowval]=1;
		FOR(i,1,n)
		{
			if(temp[i]>=0)
			{
				dp[i]|=dp[i-1]<<temp[i];
				dp[i]|=dp[i-1];
			}
			else
			{
				dp[i]|=dp[i-1];
				dp[i]|=dp[i-1]>>(-temp[i]);
			}
		}
		if(dp[n][nowval-k]==0)printf("-1\n");
		else
		{
			vector<pair<int,int> >v;
			v.clear();
			int pos=n,now=nowval-k;
			while(pos!=0)
			{
				if(dp[pos-1][now-temp[pos]])
				{
					v.push_back(pair<int,int>(pos,d[pos]));
					vis[pos]=1;
					now-=temp[pos];
				}
				pos--;
			}
			sol::solve(v);
			v.clear();
			FOR(i,1,n)if(!vis[i])v.push_back(pair<int,int>(i,d[i]));
			sol::solve(v);
		}
	}
}
int main()
{
	freopen("dish.in","r",stdin);
	freopen("dish.out","w",stdout);
	T=getint();
	while(T--)
	{
		n=getint(),m=getint(),k=getint();
		FOR(i,1,n)d[i]=getint();
		partition::init();
		if(m!=n-2)
		{
			vector<pair<int,int> >v;
			v.clear();
			FOR(i,1,n)v.push_back(pair<int,int>(i,d[i]));
			sol::solve(v);
		}
		else partition::solve();
	}
    return 0;
}

```



### 后记

希望这篇题解能使你有所收获。

---

## 作者：WeLikeStudying (赞：5)

- 当年，我利欲熏心，意图~~在完全不会随机化的情况下~~用随机化贪心水分，结果只水了 $15$ 分，[耻辱记录](https://www.luogu.com.cn/record/65074562)。
- 就当随机跳题了。

**[题意](https://www.luogu.com.cn/problem/P6775)**
- 有 $n$ 种质量之和为 $m\times k$ 的原材料，你需要构造 $m$ 道菜，使得每道菜使用最多两种原材料整数克，且使用恰好 $k$ 克原材料。
- $n\le 500,n-2\le m\le 5000,k\le 5000$。

**分析**
- 首先，作者不禁思考：$n-2$ 和 $m$ 有什么关系呢？为什么要加这个特殊限制？
- 你构造了一组 $m<n-2$ 的合法数据，因此坚定了你认为这是特殊性质的信念，但到底是什么呢？作者陷入了艰难的思考……
- 确实感觉 $m$ 越大，找到解越容易，结合样例 $n-1\le m$ 的数据根本没有无解判断来看，$n-1\le m$ 的情况难道可以直接构造？
- 我们先从 $m=n-1$ 开始，边界 $m=1,n=2$ 直接干，否则你尝试恰好取空一个数来满足要求。
- 那么这是否总能达成？根据咕咕原理，这里面最小的数不大于：$\lfloor mk/n\rfloor<k$，所以取空的任务总是能够完成。
- $m=n-2$ 的唯一问题在于：你似乎（其实不一定）可以把它变成更小的简单情况，但是最小的情况不一定有解。
- $m\ge n$ 的情况，根据鸽巢原理，总有一个大于等于 $k$ 的，找它就好了，我们可以得到 $20$ 分，[代码](https://www.luogu.com.cn/paste/zl69vh7f)。

**岔路口：乱搞**
- 作者突发奇想，想要根据这个启发式算法延续我的随机化贪心，结果就得到了 $100$ 分，过程非常地玄学，[参见记录](https://www.luogu.com.cn/record/77461145)，所以我认为真的对随机化贪心有研究的人是可以在赛是拿到满分的（最不济 $60$ 以上是没有问题的）。
- 个人给出我的思考过程：使用能够解决 $m\ge n-1$ 的算法，每次找数之前，都随机排列原序列，然后看看这样能不能找到，最高 $85$ 分；发现有一个部分复杂度卡满了，而主要部分卡不满，进行了概率性卡常，得到 $100$ 分，[代码](https://www.luogu.com.cn/paste/mudvxbru)。
- 完全没有正确性证明，或许存在特定的数据卡掉它。
- 结合比赛的赛制，我们可以把这个当成是一种启发式方法，它虽然不错，但是难以在比赛时拿到满分。

**正解**
- 所以这题正解是什么？我们要解决的唯一情况是 $m=n-2$，看这题的数据范围，我们猜测：可能是 $\text{DP}$？作者再次陷入了艰难的思考……
- 额，$n-1$ 让你想到了什么？一棵树！$n-2$ 说明如果有解，一定存在至少两个连通块，大小分别为 $x,n-x$ 然后可以它们分别放 $x-1,n-x-1$ 个菜，因为如果有一组不满足这个性质，就可以继续细分，直到恰好满足这一条件位置。
- 也就是说，需要需要找到一组大小为 $x$（$x>0$）的集合满足它的材料质量和恰好为 $(x-1)k$，直接跑背包复杂度是 $O(n^3k)$ 的，不太可过。
- 如果我们把每个材料的质量减去 $k$，那么满足要求的大小为 $x$ 的集合材料质量和就变成了 $-k$，好了，现在问题变成恒定值了，复杂度 $O(n^2k)$。
- 最后，这个形式显然可以 $\text{bitset}$ 优化一下，复杂度 $O(n^2k/w)$，可以通过此题，[代码](https://www.luogu.com.cn/paste/2i4csdfa)。

---

## 作者：TEoS (赞：4)

本文同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/13851698.html)

------------
**题意分析**

给出  $n$ 个数和 $m$ 个 $k$ ，可以某些 $k$ 拆两个正整数，使得拆后的数可以拼成给出的 $n$ 个数。

**思路分析**

~~上面的解释是因为这样写比较方便，实际上按照题意应该是用 $n$ 个数拆分拼成 $m$ 个 $k$ 。~~

观察数据范围，发现有 $m\geq n-2$ 的限制和 $m\geq n-1$  的部分分，考虑从这里切入分析。

先分析 $m\geq n-1$  的情况。令 $d_{min},d_{max}$ 分别表示最小的 $d$ 和最大的 $d$ 。

很容易想到一个贪心，若 $d_{min}<k$，用 $d_{max}$ 与其配对，让 $d_{max}$ 剩下的量尽量地大；否则就不断用 $d_{min}$ 单独做一道菜，直到它剩下的量小于 $k$ ，若还有剩余，再采用上一种策略。

如何证明这个贪心是正确的？

可以证明当 $m\geq n$ 时， $d_{max}\geq k$ ，即与 $d_{min}$ 配对后一定有剩余，因此此时每次只会仅让 $m$ 减 $1$ （ $d_{min}\geq k$ ）或 $n,m$ 各减 $1$ （ $d_{min}<k$ ）。

若 $m=n-1$ ，可能会出现 $d_{min}+d_{max}\leq k$ 的情况。可以证明此时 $d_{min}+d_{max}\geq 0$ ，因此只会出现 $d_{min}+d_{max}=k$ 的情况，这也说明了 $m=n-1$ 的情况下一定有解。这样就会有 $n$ 减 $2$ 而 $m$ 减 $1$ ，转化为 $m=n$ 。但是根据之前的分析，当 $m=n$ 时有 $d_{max}\geq k$ ，而之前的 $d_{max}< k$ 。因此这种情况当且仅当 $n=2$ 时会发生，即当前拼完之后就没有剩余的 $d$ 了，此时用剩下的两个 $d$ 拼成一个 $k$ 即可。另外，可以证明此时 $d_{min}<k$ ，即只会出现 $n,m$ 各减 $1$ 的情况。因此，只要出现 $m=n-1$  ，之后就会一直维持在这个情况，直至 $n=2$ 。

综上，根据这个贪心策略，可以使 $m\geq n-1$  所有情况不断向 $m=n-1$ 靠近，进入 $m=n-1$  情况后就会保持不变，直至 $n=2$ ，此时用剩下的两个 $d$ 拼成一个 $k$ 即可，一定有解。用 set 等数据结构优化，时间复杂度 $O(m\log n)$ 。~~其实暴力 $O(mn)$ 也可以过~~

题目中的 $\sum d_i =m*k$  是个很重要的性质，上面的“可以证明”都可以根据这个性质来证明。

接下来分析 $m=n-2$ 的情况。

可以想到把这种情况划分成两个独立的 $m=n-1$  的情况进行求解，此时两部分的 $d$ 是没有重合的。会不会有重合的情况呢？若存在这种情况，即从第二个 $k$ 开始，每次配对只能多用一个 $d$ ，最后只能用 $n-1$ 个 $d$ ，显然是不可能把 $d$ 全部用完的，因此不存在这种情况。

如何划分？

分析这个策略，发现实质是要找到一个集合 $S$ 使得 $\sum_{d_i\in S} d_i=(|S|-1)*k$ ， $|S|$ 表示集合 $S$ 的大小，即前面的 $n$ ，而不在这个集合内的元素就归到另一个集合。移项整理可以得到 $\sum_{d_i\in S} (d_i-k)=-k$ 。看到这个式子很容易想到 01 背包。用 bitset 优化，时间复杂度 $O(\frac{n^2k}{\omega})$ 。然后按照贪心策略分别求解，总的时间复杂度是 $O(\frac{n^2k}{\omega}+nlogn)$ 。注意，由于可能会出现负数，因此要将所有数处理为正数再进行 DP 。

综上，若 $m\geq n-1$ ，直接按照贪心策略进行求解；否则，用 01 背包将所有的 $d$ 划分成满足 $\sum_{d_i\in S} (d_i-k)=-k$ 的两个集合，再按照贪心策略分别求解，此时一定有解。若找不到满足条件的集合，则无解。

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
#include<set>
using namespace std;
const int N=600,M=2e6+5e5;
int T,n,m,k;
int d[N],v[N];
bool pd[N];
multiset<pair<int,int> > s;//维护 d_min 和 d_max
void solve()
{
	while(s.size())
	{
		multiset<pair<int,int> >::iterator it=s.begin();
		int minv=(*it).first,minb=(*it).second;
		s.erase(it);//取 d_min
		while(minv>=k)//不断用 d_min 单独构成一个 k
		{
			printf("%d %d\n",minb,k);
			minv-=k;
		}
		if(minv && s.size())//还没解完
		{
			it=s.end();it--;
			int maxv=(*it).first,maxb=(*it).second;
			s.erase(it);//取 d_max
			printf("%d %d %d %d\n",minb,minv,maxb,k-minv);
			maxv-=k-minv;//配对
			if(maxv)
				s.insert(make_pair(maxv,maxb));// d_max 还有剩余
		}
	}
}//贪心处理
void parti()
{
	memset(pd,0,sizeof(pd));
	bitset<2*M+1> f[N];
	memset(f,0,sizeof(f));
	for(int i=1;i<=n;i++)
		v[i]=d[i]-k;
	f[0].set(M);// 0  的位置初始化
	for(int i=1;i<=n;i++)
		if(v[i]>=0)
			f[i]|=f[i-1]<<v[i],f[i]|=f[i-1];
		else
			f[i]|=f[i-1]>>(-v[i]),f[i]|=f[i-1];//正负数分别处理，取或不取
	if(!f[n][M-k])//找不到满足条件的集合，无解
	{
		puts("-1");
		return ;
	}
	int now=M-k;
	s.clear();
	for(int i=n;i;i--)//倒着来，找到一个满足条件的集合
		if(f[i-1][now-v[i]])
		{
			s.insert(make_pair(d[i],i));
			pd[i]=1;now-=v[i];
		}
	solve();s.clear();
	for(int i=1;i<=n;i++)//找另一个集合
		if(!pd[i])
			s.insert(make_pair(d[i],i));
	solve();
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&n,&m,&k);
		for(int i=1;i<=n;i++)
			scanf("%d",&d[i]);
		if(m==n-2)
			parti();
		else
		{
			s.clear();
			for(int i=1;i<=n;i++)
				s.insert(make_pair(d[i],i));
			solve();
		}
	}
	return 0;
}
```



---

## 作者：duyi (赞：4)

# LOJ3342 「NOI2020」制作菜品


[超超超超超超超超超超级棒的阅读体验！！！](https://www.cnblogs.com/dysyn1314/p/13564122.html)

[题目链接](https://loj.ac/problem/3342)

> 博主有幸参加了NOI2020，考场上的经历和心得请见[这篇文章](https://www.cnblogs.com/dysyn1314/p/13525855.html)。这里就不唠叨了。

## 本题题解

本题的突破口在于$m$和$n$的关系。也就是数据范围表里这些奇怪的限制：$m=n-1$，$m\geq n-1$，$m\geq n-2$。我们一个一个来看。

### 走出第一步：$m=n-1$时

显然，$n$种原材料，除了在输出答案时，其他时候它们的原始顺序对我们解题没有任何影响。所以可以先将它们排序。现在假设$d_1\leq d_2\leq \dots \leq d_n$。

考虑一种贪心：先用**最大**的原材料和**最小**的原材料一起做成第一道菜。然后把它们剩余的部分，当做一种新的材料，插入回$d$序列中，转化为一个$m-1$道菜的子问题。

这种贪心在$m=n-1$时是正确的，而且一定有解。以下是证明：

**引理1.1**：$d_1<k$。

> **证明1.1**：
>
> 反证法，假设$d_1\geq k$，则$(\sum_{i=1}^{n}d_i)\geq d_1\times n\geq k\times n$。又因为$(\sum_{i=1}^{n}d_i)=m\times k$，所以$m\times k\geq n\times k$，$m\geq n$。与$m=n-1$矛盾。故可以证明：$d_1<k$。

**引理1.2**：$d_1+d_n\geq k$。

> **证明1.2**：
>
> 反正法，假设$d_1+d_n<k$，则$(\sum_{i=1}^{n}d_i)=(d_1+d_n)+(\sum_{i=2}^{n-1}d_i)<(n-1)\times k$。这与$(\sum_{i=1}^{n}d_i)=m\times k=(n-1)\times k$矛盾。故可以证明：$d_1+d_n\geq k$。

结合引理1.1和引理1.2，我们在贪心时，每次操作，一定会把最小的原材料和最大的原材料都用上，一定能用它们拼成一道菜，并且能把多余的$d_1+d_n-k$作为一种“新的”原材料放回序列中。那么，每次操作后，$n$和$m$各减小$1$，仍然满足$m=n-1$。我们如此归纳下去，直到$m=1,n=2$时，直接拼成一道菜即可。

注意，在证明时，我们认为可以允许存在一道菜$d_i=0$（否则，$n$每次就不一定减少$1$，而有可能减少$2$：也就是$d_1+d_n=k$的情况）。这样假设不会影响该做法的正确性，但在输出答案时要注意判断。

朴素地实现这一贪心，每次操作后将序列重新排序。时间复杂度$O(mn\log n)$。可以用$\texttt{std::set}$优化到$O(m\log n)$不过没有必要。

### 继续努力：$m\geq n$时

$m\geq n$时，考虑向$m=n-1$转化。

**引理2.1**：$d_n\geq k$。

> **证明2.1**：
>
> 反证法，假设$d_n<k$，则$(\sum_{i=1}^{n}d_i)<n\times k$。又因为$(\sum_{i=1}^{n}d_i)=m\times k$，所以$m\times k<n\times k$，$m<n$。与$m\geq n$矛盾。故可以证明：$d_n\geq k$。

于是我们每次使用$d_n$做一道菜，这样$m$会减少$1$，$n$不变。若干次后，一定能转化为$m=n-1$的情况。然后按上一段所述的方法贪心构造即可。

### 走向正解：$m=n-2$时

考虑把手上的原材料，分成两部分，分别满足$m=n-1$。具体来说，我们要证明：

**引理3.1**：$m=n-2$时，有解当且仅当，存在一个集合$S\subsetneq \{1,\dots ,n\}$，使得$(\sum_{i\in S}d_i)=(|S|-1)\times k$。

> **证明3.1**：
>
> **充分性**：可以对$S$和$T=\{1,\dots ,n\}\setminus S$这两个集合分别构造方案。根据定义，显然这两个集合都满足：“$m=n-1$”。所以一定是有解的。
>
> **必要性**：考虑建一张$n$个点的图。如果在最终方案下，第$i$种原材料和第$j$种原材料，曾经共同拼成过一道菜，则在点$i$和点$j$之间连一条边。因为总共只有$m$道菜，所以最多会连出$m=n-2$条边。因此这张图一定**不连通**。此时必然至少有一个连通块满足“$m=n-1$”（也就是至少有一个连通块是**树**。不可能每个连通块都有环，否则边数不够用了），它就是集合$S$。也就是说，有解时，必然存在一个这样的集合$S$。

如何划分出这样的集合$S$呢？$2^n$枚举肯定不行。考虑DP。

可以设计出这样一个朴素的状态：$dp[i][j][w]$，表示考虑了前$i$种原材料，选出了$j$种原材料，它们的质量之和为$w$，是否存在一种这样的方案。转移就考虑下一种原材料选或不选，分别转移到$dp[i+1][j+1][w+d_{i+1}]$和$dp[i+1][j][w]$。最终，如果存在一个$j$使得$dp[n][j][(j-1)\times k]=1$，则有解，我们顺着转移的过程，反推回去就能得到集合$S$。

时间复杂度$O(n^2\sum d_i)=O(n^3k)$。

继续优化，发现我们并不关心$j$是多少，只关心$j$和$w$的关系：也就是$w-j\times k=-k$。于是我们可以令每样物品的权值为$v_i=d_i-k$。设计一个新的状态：$dp[i][j]$，表示考虑了前$i$种物品，权值和为$j$，是否存在这样的方案。考虑下一种原材料选或不选，可以转移到$dp[i+1][j+v_{i+1}]$和$dp[i+1][j]$。最终只要看$dp[n][-k]$是否为$1$即可。另外，这种DP状态下，第二维可能是负数（最小为$-nk$）。所以在实现时，我们把数值统一加上$nk$即可。

在新的状态下，DP的状态数减小至$n\times(nk+mk+1)$个（第一维大小为$n$，第二维在$[-nk,mk]$）。转移是$O(1)$的。时间复杂度$O(n^2k)$，还是不足以通过全部数据。

因为DP数组里只存$01$两种值，所以考虑用$\texttt{bitset}$优化DP。具体来说，把DP的第二维，看做一个大小为$nk+mk+1$的$\texttt{bitset}$，则DP的转移就相当于将上一阶段的$\texttt{bitset}$，**或**上它**左移**$v_i$位。即：$dp[i]=dp[i-1]\operatorname{or}(dp[i-1]\ll v_i)$。特别地，如果$v_i$为负数，要写成右移$|v_i|$位。

时间复杂度$O(\frac{n^2k}{w})$，其中$w=64$。可以通过本题。

还有一个小问题。做完这个DP后，只是知道了是否有解。但我们还需要构造出$S$集合。不过这也不难，通过现有的DP数组就能构造出来。考虑定义一个$\texttt{getS(i,x)}$函数，用递归实现。保证传入的$i,x$满足$dp[i][x]=1$。显然，当$i>0$时，$dp[i-1][x]$和$dp[i-1][x-v_i]$必有至少一个为$1$。任选一个为$1$的递归下去即可。如果递归了$(i-1,x-v_i)$，相当于把原材料$i$加入集合$S$，否则相当于加入另一个集合。初始时，传入$i=n,x=-k$。递归的边界是$i=0$时直接返回。这样显然可以构造出满足我们要求的两个集合（分别满足$m=n-1$）。

总时间复杂度$O(\frac{n^2k}{w}+mn\log n)$。

参考代码：

```cpp
//problem:LOJ3342
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T>inline void ckmax(T& x,T y){x=(y>x?y:x);}
template<typename T>inline void ckmin(T& x,T y){x=(y<x?y:x);}

const int MAXN=500,MAXM=5000,MAXK=5000;
int n,m,K;
pii a[MAXN+5];
pair<pii,pii> ans[MAXM+5];
void work(pii a[],int n,int m,pair<pii,pii> ans[]){
	sort(a+1,a+n+1);
	for(int i=1;i<=m;++i){
		assert(n>0);
		int curm=m-i+1;
		if(n<=curm){
			assert(a[n].fi>=K);
			ans[i]=mk(mk(a[n].se,K),mk(0,0));
			a[n].fi-=K;
			sort(a+1,a+n+1);
		}
		else{
			assert(n==curm+1);
			assert(a[1].fi<K);
			assert(a[1].fi+a[n].fi>=K);
			ans[i]=mk(mk(a[1].se,a[1].fi),mk(a[n].se,K-a[1].fi));
			a[1].fi=a[1].fi+a[n].fi-K;
			a[1].se=a[n].se;
			--n;
			sort(a+1,a+n+1);
		}
	}
	for(int i=1;i<=m;++i){
		if(ans[i].se.se>ans[i].fi.se) swap(ans[i].fi,ans[i].se);
		if(ans[i].se.se)
			cout<<ans[i].fi.fi<<" "<<ans[i].fi.se<<" "<<ans[i].se.fi<<" "<<ans[i].se.se<<endl;
		else
			cout<<ans[i].fi.fi<<" "<<ans[i].fi.se<<endl;
	}
}
pii a1[MAXN+5],a2[MAXN+5];
pair<pii,pii> ans1[MAXN+5],ans2[MAXN+5];
bitset<MAXN*MAXK+(MAXN-2)*MAXK+5> dp[MAXN+5];
int bas,n1,n2;
void getset(int i,int x){
	if(i==0) return;
	if(dp[i-1][x+bas]){
		getset(i-1,x);
		a2[++n2]=a[i];
	}
	else{
		int v=a[i].fi-K;
		assert(dp[i-1][x-v+bas]==1);
		getset(i-1,x-v);
		a1[++n1]=a[i];
	}
}
void solve_case(){
	cin>>n>>m>>K;
	for(int i=1;i<=n;++i){
		cin>>a[i].fi;
		a[i].se=i;
	}
	if(n<=m+1){
		work(a,n,m,ans);
		return;
	}
	assert(n==m+2);
	bas=n*K;// DP数组为了保证下标不为负而产生的的偏移量
	//dp[-x] -> dp[-x+bas]
	dp[0].reset();
	dp[0][0+bas]=1;
	bool flag=0;
	for(int i=1;i<=n;++i){
		int v=a[i].fi-K;
		if(v>0)
			dp[i]=(dp[i-1]|(dp[i-1]<<v));
		else if(v<0)
			dp[i]=(dp[i-1]|(dp[i-1]>>(-v)));
		else
			dp[i].reset();
		if(dp[i][-K+bas]==1){
			n1=n2=0;
			getset(i,-K);
			for(int j=i+1;j<=n;++j){
				a2[++n2]=a[j];
			}
			flag=1;
			break;
		}
	}
	if(!flag){
		cout<<-1<<endl;
		return;
	}
//	for(int i=1;i<=n1;++i) cerr<<a1[i].fi<<" "; cerr<<endl;
//	for(int i=1;i<=n2;++i) cerr<<a2[i].fi<<" "; cerr<<endl;
	int sum1=0,sum2=0;
	for(int i=1;i<=n1;++i) sum1+=a1[i].fi; assert(sum1==(n1-1)*K);
	for(int i=1;i<=n2;++i) sum2+=a2[i].fi; assert(sum2==(n2-1)*K);
	assert(n1>=1);
	assert(n2>=1);
	work(a1,n1,n1-1,ans1);
	work(a2,n2,n2-1,ans2);
}
int main() {
//	freopen("dish.in","r",stdin);
//	freopen("dish.out","w",stdout);
	int T;cin>>T;while(T--){
		solve_case();
	}
	return 0;
}
```







---

## 作者：zhoukangyang (赞：4)

## 蒟蒻语
这题是真的不难, 蒟蒻同步赛上(反正是同步赛没关系)都想到背包了, 但是没看到 $m ≥ n - 2$...

## 蒟蒻解
首先考虑 $m ≥ n - 1$ 的情况。

先说蒟蒻的贪心策略吧 ：

每次取出最小的数, 如果他的值 $< k$, 再取出最小能和他加起来 $≥ k$ 的数。

正确性如何呢？分两种情况考虑 ： (以下 $n > 2$)

### 1. 没有比 $k$ 小的数了。
那么就相当于从小到大排序后每次取出第一个数减 $k$，如果目前的值 $x < k$, 那么让第二个数 $- (k - x)$, 由于第二个数 $≥ k$, 一定是可以减这么多的。所以一定可以取完。

### 2. 有比 $k$ 小的数。
取出数 $x$ , $x < k$。这时的最大数 $≥ \frac{mk - x}{n - 1} = k * \frac{m}{n - 1} - \frac{x}{n - 1} ≥ k - \frac{x}{n - 1}$, 

而 $k - \frac{x}{n - 1} + x = k + \frac{(n - 2)x}{n - 1}≥ k$, 因此一定可以找到一个数加上他大于等于 $k$。执行完该操作后 `n--, m--`, 所以仍然满足 $m ≥ n - 1$

边界情况 :

$n = 1$ : $m$ 次取完即可。

$n = 2$ : 若干次取完第一个数, 若无剩余则 $n = 1$, 若有余数则取完第一个数然后取第二个数的一部分, 然后就 $n = 1$ 了。

该部分代码 ：

```cpp
void work(int n, int m, int *d, int *tr) {
	while(cnt < m) {
        int minn = 0, mindy = 0;
        for(int i = 1; i <= n; i++) if((d[i] < d[minn] || !minn) && d[i]) minn = i;
        if(d[minn] >= k) {
            ++cnt;
            ans[cnt][1] = tr[minn], ans[cnt][2] = k, d[minn] -= k;
            continue;
        }
        for(int i = 1; i <= n; i++) if(i != minn && d[i] + d[minn] >= k && (d[i] < d[mindy] || !mindy)) mindy = i;
        ++cnt;
        ans[cnt][1] = tr[minn], ans[cnt][2] = d[minn];
		ans[cnt][3] = tr[mindy], ans[cnt][4] = k - d[minn];
        d[mindy] -= k - d[minn], d[minn] = 0;
    }
}
```

然后 $m = n - 2$ 怎么弄 /yiw

回想 $m = n - 1$ 的情况。这种情况是 $\sum\limits_{i=1}^{n} a_i = (n-1) * k$ 已经配好。这里是要求自己配出两个 $\sum\limits_{i=1}^{n} a_i = (n-1) * k$ 。否则无解(这就说明如果将他划分之后再做， 最大的那块还是 $m \le n - 2$, 这时就考虑边界情况, $n > 2$, $m  = 1$, 一定不行。再考虑因为不能划分了, 所以每一次取是取两个数, 而且取不完, 一直保持 $m \le n - 2$, 无解)。

那么怎么配呢 ? 

考虑先把每一个数 $-k$ , 就是要让几个数和为 $-k$。

那么这样时间复杂度是 $O(n^2m)$, $bitset$ 优化就是 $O(\frac{n^2m}{w})$ 了， 可以通过本题。

## 蒟蒻码
```cpp
#include<bits/stdc++.h>
#define N 5100
#define FN 501
#define G 2000000
using namespace std;
int T, ans[N][5], k, cnt;
void work(int n, int m, int *d, int *tr) {
	while(cnt < m) {
        int minn = 0, mindy = 0;
        for(int i = 1; i <= n; i++) if((d[i] < d[minn] || !minn) && d[i]) minn = i;
        if(d[minn] >= k) {
            ++cnt;
            ans[cnt][1] = tr[minn], ans[cnt][2] = k, d[minn] -= k;
            continue;
        }
        for(int i = 1; i <= n; i++) if(i != minn && d[i] + d[minn] >= k && (d[i] < d[mindy] || !mindy)) mindy = i;
        ++cnt;
        ans[cnt][1] = tr[minn], ans[cnt][2] = d[minn];
		ans[cnt][3] = tr[mindy], ans[cnt][4] = k - d[minn];
        d[mindy] -= k - d[minn], d[minn] = 0;
    }
}
int n, m, d[N], pcnt, flag[FN], tr[N];
bitset<4000000> f[FN];
void dfs(int x, int wz) {
	if(x == 0) return;
	if(f[x - 1][wz] == 1) dfs(x - 1, wz);
	else flag[x] = 1, dfs(x - 1, wz - d[x]);
}
int main() {
    scanf("%d", &T);
    while(T --> 0) {
		scanf("%d%d%d", &n, &m, &k), cnt = 0;
		for(int i = 1; i <= n; i++) scanf("%d", &d[i]), tr[i] = i;
		if(m == n - 2) {
			memset(f, 0, sizeof(f));
			for(int i = 1; i <= n; i++) d[i] -= k;
			f[0][G] = 1;
			for(int i = 1; i <= n; i++) {
				if(d[i] >= 0) f[i] = f[i - 1] | (f[i - 1] << d[i]);
				else f[i] = f[i - 1] | (f[i - 1] >> -d[i]);
			} 
			if(!f[n][G - k]) {
				puts("-1");
				continue;
			}
			else {
				for(int i = 1; i <= n; i++) flag[i] = 0;
				dfs(n, G - k), pcnt = 0;
				for(int i = 1; i <= n; i++) d[i] += k;
				for(int i = 1; i <= n; i++) if(flag[i] == 1) 
					++pcnt, swap(d[i], d[pcnt]), swap(tr[pcnt], tr[i]);
				work(pcnt, pcnt - 1, d, tr);
				work(n - pcnt, m, d + pcnt, tr + pcnt); 
			}
		} 
		else work(n, m, d, tr);	
		for(int i = 1; i <= m; i++) {
			printf("%d %d", ans[i][1], ans[i][2]);
			if(ans[i][2] != k) printf(" %d %d", ans[i][3], ans[i][4]);
			printf("\n");
		}
	}
    return 0;
}
```

希望大家有所收获！

---

## 作者：AzusaCat (赞：3)

通过观察样例和数据范围，我们可能有一个猜想：当 $m\geqslant n-1$ 时一定有解，这个结论我们可以通过归纳法证明：当 $n\leqslant 2$ 时显然成立，当 $n>2$ 时，我们取剩余质量最小的食材，如果质量 $\geqslant k$，那么一定有 $m\geqslant n$，那么我们把这道菜全部用这个食材做，那么 $m$ 减小 $1$，依旧满足 $m\geqslant n-1$；如果质量 $<k$，我们再取质量最大的菜，不难证明两种菜的质量加起来一定 $\geqslant k$，这样就相当于把第一种菜用掉，然后剩余要做的菜 $-1$，即 $m,n$ 均减小 $1$，依旧满足 $m\geqslant n-1$。

然后我们考虑 $m=n-2$ 的情况，也不难有猜想：只有能够划分为两个 $m=n-1$ 的集合的时候有解。充分性显然，考虑必要性：当 $m=1,n=3$ 时无解，如果不能划分为两个 $m=n-1$ 的集合，那么每做一盘菜质量减为 $0$ 的食材数量一定 $\leqslant1$（要不然我们就找到了一组划分），这样一直保持 $m\leqslant n-2$，所以一定无解。

那么对于 $m\geqslant n-1$ 的情况，我们随便写个模拟就好了，对于 $m=n-2$ 的情况，如果我们设每种食材的权值为 $d_i-k$，那么就相当于问有没有一个子集的权值和为 $-k$，这是一个可行性背包，可以使用 `bitset` 优化，复杂度为 $O(\frac{n^2k}{w})$，输出方案只需要找到的时候往前递归找就可以了。

代码（由于未知原因，这份代码在 windows 下似乎会 RE）：

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define mp make_pair
using namespace std;
typedef pair<int,int> pii;
struct dish
{
    int w,id;
}v[505];
bool cmp(dish x,dish y){return x.w<y.w;}
int n,m,k,d[505];
vector<pii>ans[5005];
namespace subtask1
{
    void main(int n,int m)
    {
        for(int i=1;i<=m;i++)
        {
            sort(v+1,v+n+1,cmp);
            ans[i].clear();
            if(v[1].w>=k)ans[i].pb(mp(v[1].id,k));
            else v[n].w-=k-v[1].w,ans[i].pb(mp(v[1].id,v[1].w)),ans[i].pb(mp(v[n].id,k-v[1].w));
            if(v[1].w<=k)swap(v[1],v[n]),n--;
            else v[1].w-=k;
        }
        for(int i=1;i<=m;i++)
        {
            for(int j=0;j<ans[i].size();j++)
                printf("%d %d ",ans[i][j].first,ans[i][j].second);
            puts("");
        }
    }
}
namespace subtask2
{
    bitset<5000005>f[505];
    int now;
    bool visited[505];
    void dfs(int x,int y)
    {
        if(!x)return;
        if(f[x-1][y])dfs(x-1,y);
        else visited[x]=1,v[++now].id=x,v[now].w=d[x],dfs(x-1,y-k+d[x]);
    }
    void main()
    {
        bool flag=0;
        now=0;
        f[0][2500001]=1;
        memset(visited,0,sizeof(visited));
        for(int i=1;i<=n;i++)
        {
            if(k-d[i]>=0)f[i]=((f[i-1])|(f[i-1]<<(k-d[i])));
            else f[i]=((f[i-1])|(f[i-1]>>(d[i]-k)));
            if(f[i][2500001+k])
            {
                dfs(i,2500001+k);
                flag=1;
                break;
            }
        }
        if(!flag){puts("-1");return;}
        subtask1::main(now,now-1);
        now=0;
        for(int i=1;i<=n;i++)
            if(!visited[i])v[++now].id=i,v[now].w=d[i];
        subtask1::main(now,now-1);
    }
}
int main()
{
    int _;
    scanf("%d",&_);
    while(_--)
    {
        scanf("%d%d%d",&n,&m,&k);
        for(int i=1;i<=n;i++)scanf("%d",&d[i]);
        if(m>=n-1)
        {
            for(int i=1;i<=n;i++)v[i].id=i,v[i].w=d[i];
            subtask1::main(n,m);
        }
        else subtask2::main();
    }
    return 0;
}
```


---

## 作者：St_john (赞：2)

# [ P6775 [NOI2020] 制作菜品 ](https://www.luogu.com.cn/problem/P6775)

分析一下，数据范围满足 $m\geqslant n-2$。  
部分分还给了 $m=n-1$。  
考虑从特殊情况入手。  
因为是拼情况，直接对 $d$ 升序排序即可。  

1. $m=n-1$。  
根据 $\sum_{i=1}^{n}d_i=m\times k$，我们可以选取最大的（$mxid$）和最小的（$mnid$）进行处理。  
因为 $d_1<k,d_1+d_n\geqslant k$，所以我们这么做就一定有解。  
具体证明：  
$d_1\geqslant k \Rightarrow \sum_{i=1}^{n}d_i \geqslant n\times k>m\times k$，所以 $d_1<k$。  
$d_1+d_n<k \Rightarrow \sum_{i=1}^{n} d_i <d_1+(n-1)\times (k-d_1)=(n-1)\times k-(n-2)\times d_1 \leqslant m\times k$，所以 $d_1+d_n \geqslant k$。  
**这里要卡一下 $mxid=mnid$ 的情况，对 $mx$ 用 $>$，对 $mn$ 用 $\leqslant$ 即可。**

1. $m\geqslant n$。  
考虑归纳到 $m=n-1$ 的子问题上。  
$d_n \geqslant k$，所以我们每次选最大的即可，最终一定会到 $m=n-1$ 的情况。  
证明：  
$d_n < k \Rightarrow \sum_{i=1}^n d_i<n\times k \leqslant m\times k$，所以 $d_n \geqslant k$。  

1. $m=n-2$。  
考虑能不能把 $m=n-2$ 分成 $m_1=n_1-1,m_2=n_2-1,m_1+m_2=m,n_1+n_2=n$ 的子问题呢？  
两边有解，合起来自然有解。  
即选出一个集合 $S$，满足 $\sum_{i\in S}d_i=(|S|-1)\times k$，进而得到 $\sum_{i\in S}(k-d_i)=k$。  
这样我们就可以直接 DP 了。  
具体来讲设 $f_{i,j}$ 表示前 $i$ 个数能否拼出 $j$，可以用状压二进制来表示 $j$。  
只要 $f_{i-1,j}=1$，那么 $f_{i,j+k-d_i}=1$。  
接下来就是找方案的问题了。  
分别构造即可。  

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<bitset>
using namespace std;
typedef long long ll;
#define  il inline
#define pc putchar
#define Re register int
#define _for(i,a,b) for(register int i=(a);i<=(b);++i)
#define __for(i,a,b) for(register int i=(a);i>=(b);--i)
il int re(){
    int x=0;
    char ch=getchar();
    bool f=0;
    while(ch<'0'||ch>'9')
        f|=(ch=='-'),ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return f?-x:x;
}
void pr(int x){
    if(x<0) x=-x,pc('-');
    if(x>9) pr(x/10);
    pc(x%10|48);
}
const int A=500+10,B=5e3+10,C=A*B;
int n,m,k;
struct node{
	int d,id;
}d[A],a1[A],a2[A];
bool cmp(const node &a,const node &b){
	return a.d<b.d;
}
bool used[A];

bitset<C> f[A];

signed main(){
	__for(_,re(),1){
		n=re(),m=re(),k=re();
		_for(i,1,n) d[i]={re(),i};
		sort(d+1,d+1+n,cmp);
		if(m>=n-1){
			while(m!=n-1){
				if(!n||!m) break;
				if(d[n].d>k){
					d[n].d-=k;
					--m;
					printf("%d %d\n",d[n].id,k);
				}
				else if(d[n].d==k){
					printf("%d %d\n",d[n].id,k);
					--n;
					--m;
				}
				else{
					d[n-1].d-=(k-d[n].d);
					printf("%d %d %d %d\n",d[n].id,d[n].d,d[n-1].id,k-d[n].d);
					--n,--m;
					if(!d[n].d) --n;
				}
			}
			memset(used,0,sizeof(bool)*(n+1));
			while(1){
				int mx=0,mn=1e9,mnid=0,mxid=0;
				_for(i,1,n)
					if(!used[i]){
						if(d[i].d>mx){
							mx=d[i].d;
							mxid=i;
						}
						if(d[i].d<=mn){
							mn=d[i].d;
							mnid=i;
						}
					}
				if(!mnid&&!mxid) break;
				used[mnid]=1;
				if(mn+mx==k){
					used[mxid]=1;
					printf("%d %d %d %d\n",d[mnid].id,mn,d[mxid].id,mx);
				}
				else{
					if(mn==k){
						printf("%d %d\n",d[mnid].id,mn);
					}
					else{
						d[mxid].d-=(k-mn);
						printf("%d %d %d %d\n",d[mnid].id,mn,d[mxid].id,k-mn);
					}
				}
			}
		}
		else{
			f[0][0]=1;
			_for(i,1,n)
				if(k>=d[i].d)
					f[i]=f[i-1]|(f[i-1]<<(k-d[i].d));
				else f[i]=f[i-1]|(f[i-1]>>(d[i].d-k));
			if(!f[n][k]){
				printf("-1\n");
			}
			else{
				int now=k;
				int n1=0,n2=0;
				__for(i,n,1){
					if(now>=(k-d[i].d)&&f[i-1][now-(k-d[i].d)]){
						a1[++n1]=d[i];
						now-=(k-d[i].d);
					}
					else a2[++n2]=d[i];
				}
				memset(used,0,sizeof(bool)*(n1+1));
				while(1){
					int mx=0,mn=1e9,mxid=0,mnid=0;
					_for(i,1,n1)
						if(!used[i]){
							if(mx<a1[i].d) mx=a1[i].d,mxid=i;
							if(mn>=a1[i].d) mn=a1[i].d,mnid=i;
						}
					if(!mnid&&!mxid) break;
					used[mnid]=1;
					if(mn+mx==k){
						used[mxid]=1;
						printf("%d %d %d %d\n",a1[mnid].id,mn,a1[mxid].id,mx);
					}
					else{
						if(mn==k){
							printf("%d %d\n",a1[mnid].id,mn);
						}
						else{
							a1[mxid].d-=(k-mn);
							printf("%d %d %d %d\n",a1[mnid].id,mn,a1[mxid].id,k-mn);
						}
					}
				}
				
				memset(used,0,sizeof(bool)*(n2+1));
				while(1){
					int mx=0,mn=1e9,mxid=0,mnid=0;
					_for(i,1,n2)
						if(!used[i]){
							if(mx<a2[i].d) mx=a2[i].d,mxid=i;
							if(mn>=a2[i].d) mn=a2[i].d,mnid=i;
						}
					if(!mnid&&!mxid) break;
					used[mnid]=1;
					if(mn+mx==k){
						used[mxid]=1;
						printf("%d %d %d %d\n",a2[mnid].id,mn,a2[mxid].id,mx);
					}
					else{
						if(mn==k){
							printf("%d %d\n",a2[mnid].id,mn);
						}
						else{
							a2[mxid].d-=(k-mn);
							printf("%d %d %d %d\n",a2[mnid].id,mn,a2[mxid].id,k-mn);
						}
					}
				}				
			}
		}
	}
    return 0;
}
```

---

## 作者：zhouhuanyi (赞：2)

链接：https://www.luogu.com.cn/problem/P6775

题目描述：有$m$道菜，和$n$种原材料，每个原材料有一个质量$d_{i}$,有$\sum_{i=1}^{n}{d_{i}}=m\times k$(m为正整数)，每次在$1-2$道菜中选一部分满足质量总和为$k$，求一组合法方案。

题解：考场上想了$3h$会了$70$,结果$m>n-1$判错$WA$成$55$。

假如我们已经选定好了一种方案$T$，那么我们可以考虑如何判定合法性，我们可以建出网络流模型，然后两边跑最大流，判是否满流。

但是我们会发现，若现在的判定方案为$T$,在跑网络流的时候，对于$d_{i}>=k$，我们可以将它流掉，那么它一定可以被单独做为$1$道菜流，所以我们可以将它流掉。

考虑流掉后$m$的范围，若$m>=n-1$，由于有$d_{i}<k$，那么$\sum_{i=1}^{n}d_{i}<=k\times n$,又有$\sum_{i=1}^{n}d_{i}=k\times m$，则$m<=n-1$，所以对于$m>=n-1$可以归纳为$m=n-1$。

那么考虑如何构造一组$m=n-1$的方案，可以如下构造方案：

先处理$n$个数，将最小的元素与最大的元素匹配从而消去最小的元素，这样就消去了一个数，然后对于剩下的数反复该过程。

考虑如何证明，令$d$从小到大排序后为$D$,则最小的数为$D_{1}$,最大的数为$D_{n}$,那么因$\sum_{i=1}^{n}D_{i}=(n-1)\times k$,则若$D_{1}+D_{n}<k$,那么有$\sum_{i=1}^{n}D_{i}<=D_{1}+(n-1)\times D_{n}<=(n-1)\times (D_{1}+D_{n})<(n-1)\times k$，则矛盾，即$D_{1}+D_{n}>=k$，可以构造出一组方案。

那么对于$m=n-2$的情况，我们发现无法归纳解决，那么仔细观察可以发现有解时$m=n-2$的解中一定会有两个不连通的$m=n-1$。

考虑如何证明。由于拆时将其拆为连通图，那么这些图都有$m>=n-1$,那么若对于一个点数为$N$，边数为$M$的连通图，若$M \times k=\sum_{i=1}^{n}d_{i}$，则即可归纳为$m>=n-1$的问题，一定存在解。反之，则会无法恰好选完，则无解。
即$M \times k=\sum_{i=1}^{N}d_{i}$为连通图有解的充要条件。

那么考虑我们$m=n-2$的解是若干个连通图，每个图需满足上述条件，在这些图会存在一些带环图与树，那么将带环图与树合并，合并出的新连通图仍满足这个条件，那么合并会更优，在合并完后会合并成两颗无法合并的树，所以有解时一定会有两个不连通的$m=n-1$。

那么我们可以构造一颗树，另外一颗树就满足条件，即需构造$(N-1) \times k=\sum_{i=1}^{N}d_{i}$，这个可化为$k=\sum_{i=1}^{N}(k-d_{i})$,将$k-d_{i}$看作元素可以背包，转移时可用$bitset$优化转移。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<bitset>
using namespace std;
int read()
{
  char c=0;
  int sum=0;
  while (c<'0'||c>'9')
    c=getchar();
  while ('0'<=c&&c<='9')
    sum=sum*10+c-'0',c=getchar();
  return sum;
}
struct node
{
  int num,d;
  bool operator < (const node &a)const
  {
    return d<a.d;
  }
};
node point[501],tong[501];
int T,n,m,k,cnt,length,maxer,maxn;
bool used[501];
bitset<4980001>dp[501];
int main()
{
  bool op;
  T=read();
  while (T--)
    {
      n=read(),m=read(),k=read();
      for (int i=1;i<=n;++i)
	point[i].num=i,point[i].d=read();
      if (m>=n-1)
	{
	  cnt=0;
	  for (int i=1;i<=n;++i)
	    while (point[i].d>=k&&cnt<m-n+1)
	      cnt++,point[i].d-=k,printf("%d %d\n",point[i].num,k);
	  for (int t=1;t<=n;++t)
	    {
	      sort(point+t,point+n+1);
	      if (point[t].d==0)
			continue;
		  if (point[t].d==k)
		  {
		  	printf("%d %d\n",point[t].num,k);
		    continue;
		  }
	      printf("%d %d %d %d\n",point[t].num,point[t].d,point[n].num,k-point[t].d);
	      point[n].d-=(k-point[t].d);
	    }
	}
      else
	{
	  for (int i=1;i<=n;++i)
	    used[i]=0;
	  for (int i=0;i<=n;++i)
	    dp[i].reset();
	  dp[0][(n-2)*k]=1;
	  int s,ps,tmp;
	  op=0;
	  for (int i=1;i<=n;++i)
	    {
	      if (k-point[i].d>=0)
		dp[i]=dp[i-1]|(dp[i-1]<<(k-point[i].d));
	      else
		dp[i]=dp[i-1]|(dp[i-1]>>(point[i].d-k));
	      if (dp[i][k+(n-2)*k])
		{
		  op=1;
		  used[i]=1,s=k+(n-2)*k-(k-point[i].d),ps=i;
		  while (ps!=0)
		    {
		      tmp=ps;
		      for (int j=0;j<=tmp-1;++j)
			if (dp[j][s])
			  {
			    ps=j;
			    break;
			  }
		      used[ps]=1;
		      s=s-(k-point[ps].d);
		    }
		  break;
		}
	    }
	  if (op)
	    {
	     length=0;
             for (int i=1;i<=n;++i)
               if (used[i])
                 tong[++length]=point[i];
             for (int t=1;t<=length;++t)
               {
                  sort(tong+t,tong+length+1);
                  if (tong[t].d==0)
                    continue;
                  printf("%d %d %d %d\n",tong[t].num,tong[t].d,tong[length].num,k-tong[t].d);
                  tong[length].d-=(k-tong[t].d);
               }
	      length=0;
	      for (int i=1;i<=n;++i)
	        if (!used[i])
	           tong[++length]=point[i];
              for (int t=1;t<=length;++t)
	        {
	           sort(tong+t,tong+length+1);
	           if (tong[t].d==0)
		      continue;
		   printf("%d %d %d %d\n",tong[t].num,tong[t].d,tong[length].num,k-tong[t].d);
		   tong[length].d-=(k-tong[t].d);
		}
	   }
	  else
	    puts("-1");
	  }
    }
  return 0;
}


---

## 作者：baka24 (赞：0)

这题一眼看上去就非常困难，让我们先想想特殊性质。

## $m=n-1$

在这种情况下，菜的数量恰好比原材料数量少一个。

考虑剩的最少的原材料应该怎么处理，设其为 $x$。

首先，由于 $\overline{d}=\frac{mk}{n}=\frac{n-1}{n}k$，所以 $x<k$。

从直觉上来说把它拆开分给两个其他材料不是很好做，考虑给它配上一个其他材料凑成一道菜，同时 $n,m$ 各减一，可以递归处理，感觉很好。

那如何挑选这个“其他材料”？

此时，对于“其他材料”的限制是这个材料的剩余量 $y$ 必须满足 $x+y\ge k$。

从贪心的角度想，我们选剩的最多的可以尽量使它们的和大于等于 $k$。

但是如何保证每次选最多的一定可以使 $x+y\ge k$？

因为 $d$ 的平均值为 $\frac{n-1}{n}k$，可以看出 $d_n$ （排序后的）大概率是大于 $k$ 的。

而当 $d_n=k-1$ 时，因为 $d_n$ 是最大值，所以有 $\forall i\in[2,n-1],d_i\le k-1$。
$$
d_1+\sum_{i=2}^n d_i\le d_1+(n-1)(k-1)
$$
$$
(n-1)k=mk\le d_1 +(n-1)k-(n-1)\\
n-1\le d_1
$$
可以得到
$$
d_1+d_n\ge n+k-2
$$

当 $n\ge2$ 时一定有 $d_1+d_n\ge k$。

当 $n=1$ 时有 $m=0$，此时不需要再组成菜品。

综上可以得到一个贪心：每次取剩余最小的原材料和剩余最多的原材料，组成一道菜之后菜数和原材料数都会减一，继续同样的处理即可。

那么这个特殊性质便被解决了，有没有希望推广一下这个特殊性质的解法呢？

## $m\le n$
此时我们的原材料种类更少。

因为题目的限制是在原材料种类上的，也就是说原材料越多，目标越难达成。

那么此时原材料很少，我们不妨奢侈一点，把一部分原材料直接作为一道菜，这样会使原材料的数量很快的减少。

而当原材料数量减少到 $m+1$ 时，就可以用上文已经得出的解法了。

现在我们已经可以解决 $m\le n-1$ 的问题了，观察题目数据范围，接下来只需要解决 $m=n-2$ 即可。

## $m=n-2$

根据 $m\le n$ 的思路，$m=n-2$ 的解法还是尽量往 $m=n-1$ 上靠。

如果我们可以找到一个拆分，使得 $n,m$ 分别被拆成 $n_1,n_2,m_1,m_2$，$d_i$ 被拆成两个集合 $S_1,S_2,|S_1|=n_1,|S_2|=n_2$。

它们满足 $m_1=n_1-1,m_2=n_2-1,\sum_{i\in S_1} d_i=m_1k,\sum_{i\in S_2}d_i=m_2k$，就可以将原问题拆成两个 $m=n-1$ 的子问题求解。

其中看起来最难满足的便是 $\sum_{i\in S_1} d_i=m_1k$（满足一个另一个一定也满足）。

化一下式子：
$$
\sum_{i\in S_1}d_i=m_1k\\
\sum_{i\in S_1}d_i=(n_1-1)k\\
\sum_{i\in S_1}d_i-k=-k\\
$$
看起来可以用背包判定。

注意到值域是 $\pm5000$，复杂度为 $O(n^2k)$，需要 `bitset` 优化。

记 $f_{i,j}$ 表示前 $i$ 个数是否可以总和为 $j$。

因为要输出方案，所以需要记选了哪些数，只需要看一下当前状态的两个前驱哪个为真，然后找过去即可。

至此，我们便解决了此题。从一个特殊性质开始，逐步推广，最终完成了对所有情况的讨论。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int> 
#define fr first
#define sc second 
#define mk make_pair
#define pb push_back
int read(){int x=0,f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}x=c-'0';c=getchar();while(c<='9'&&c>='0'){x*=10;x+=c-'0';c=getchar();}return x*f;}
const int MAXN=510,MAXM=5010,Mod=1000000007,inf=1000000000,B=150;
struct Edge{int v,nx;}edge[MAXN<<1];int h[MAXN],CNT;void add_side(int u,int v){edge[++CNT]={v,h[u]};h[u]=CNT;edge[++CNT]={u,h[v]};h[v]=CNT;}
int Pow(int x,int y){int rt=1;while(y){if(y&1)rt=rt*x%Mod;x=x*x%Mod,y>>=1;}return rt;}
int n,m,k,ans,fl[MAXN];
bitset<MAXN*MAXM*2>f[MAXN];
pii a[MAXN];
set<pii>st;
void sol(){
    while(m){
        pii x=*st.begin(),y=*st.rbegin();
        if(x==y||!x.fr)printf("%lld %lld\n",y.sc,k);
        else printf("%lld %lld %lld %lld\n",x.sc,x.fr,y.sc,k-x.fr);m--;
        st.erase(x),st.erase(y);
        if(x!=y)st.insert(mk(y.fr+x.fr-k,y.sc));
        else st.insert(mk(y.fr-k,y.sc));
    }
}
void slv0(){
    for(int i=1;i<=n;i++)st.insert(a[i]);
    sol();
}
void slv1(){
    for(int i=1;i<=n;i++)st.insert(a[i]);
    while(m&&m>=st.size()){
        pii x=*st.rbegin();st.erase(x);
        printf("%lld %lld\n",x.sc,k);m--;
        if(x.fr-k)st.insert(mk(x.fr-k,x.sc));
    }
    sol();
}
void slv2(){
    f[0].reset();
    f[0].set(n*k);
    for(int i=1;i<=n;i++){
        int v=a[i].fr-k;
        f[i]=f[i-1];
        if(v>=0){
            f[i]|=(f[i-1]<<v);
        }
        else{
            f[i]|=(f[i-1]>>(-v));
        }
    }
    if(!f[n][n*k-k]){
        printf("-1\n");
        return;
    }
    int now=n*k-k,n1=0,n2=0;
    for(int i=n;i>=1;i--){
        int v=a[i].fr-k;
        if(f[i-1][now-v])st.insert(a[i]),now-=v,n1++;
        else fl[i]=1,n2++;
    }
    n=n1,m=n1-1;
    sol();
    n=n1+n2;
    st.clear();
    for(int i=1;i<=n;i++)if(fl[i])st.insert(a[i]);
    n=n2,m=n2-1;
    sol();
}
void slv(){
    n=read(),m=read(),k=read();
    st.clear();
    for(int i=1;i<=n;i++)a[i].fr=read(),a[i].sc=i,fl[i]=0;
    if(m==n-1)slv0();
    else if(m>=n)slv1();
    else slv2();
}
signed main(){
 	freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    int _=read();while(_--)
    slv();
    return 0;
}
```

---

## 作者：_ANIG_ (赞：0)

[传送门](https://www.luogu.com.cn/problem/P6775)

看到部分分中有 $m=n-1$，考虑从这种情况开始考虑。

观察大样例，可以发现有很多道菜一次性用完了某种原材料。

于是可以猜测，每道菜一定至少用完一种原材料。

考虑模拟这个过程。

相当于进行 $m$ 次操作，每次取任意两个值 $i,j$，使得 $d_i\le k$ 且 $k-d_i\le d_j$。

不妨令 $d_i$ 为 $d$ 的最小值，$d_j$ 为 $d$ 的最大值。

则 $d_i\le k$ 和 $k-d_i\le d_j$ 都成立。

可以用 $set$ 维护 $d$，每次取最小和最大，然后用完最小的，再把剩余的插回去。

总复杂度 $O(n\log n)$。

现在考虑 $n-1\le m$。

由上文可得 $m=n-1$ 一定存在一种方案。

所以可以先把多余的菜做出来，每道菜只需要一种原材料。

最后考虑 $n-2=m$。

如果依然用上文的方法，就会最后剩 $3$ 种原材料制作一道菜，不合法。

所以需要在至少一道菜同时用完两种原材料。

也就是要求一个集合 $S$，使得存在 $i$，满足 $\sum\limits_{j\in S}k-d_j=d_i$。

可以用 bitset 维护，跑 01 背包。

总复杂度 $O(\frac{Tn^2k}{w})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=505,M=2.5e6+5;
struct node{
	int bh,sm;
	friend bool operator<(node a,node b){
		if(a.sm==b.sm)return a.bh<b.bh;
		return a.sm<b.sm;
	}
}d[N];
multiset<node>q;
bitset<M>f[N];
int t,n,m,k;
signed main(){
	cin>>t;
	while(t--){
		q.clear();
		cin>>n>>m>>k;
		for(int i=1;i<=n;i++){
			cin>>d[i].sm;
			d[i].bh=i;
			q.insert(d[i]);
		}
		while(m>n-1){
			cout<<(*(--q.end())).bh<<" "<<k<<"\n";
			auto x=*(--q.end());
			q.erase(--q.end());
			x.sm-=k;
			q.insert(x); 
			m--;
		}
		if(m==n-2){
			int oks=0;
			sort(d+1,d+n+1);
			for(int i=1;i<=n;i++)f[i].reset();
			f[0][0]=1;
			for(int i=1;i<=n;i++){
				if(f[i-1][d[i].sm]){
					oks=1;
					int nw=d[i].sm;
					q.erase(q.find(d[i]));
					for(int j=i-1;j>=1;j--){
						if(k-d[j].sm>=0&&nw>=k-d[j].sm&&f[j-1][nw-k+d[j].sm]){
							cout<<d[j].bh<<" "<<d[j].sm<<" "<<d[i].bh<<" "<<k-d[j].sm<<"\n";
							nw-=k-d[j].sm;
							q.erase(q.find(d[j]));
							m--;
						}
					}
					break;
				}
				if(d[i].sm>=0)f[i]=f[i-1]|f[i-1]<<k-d[i].sm;
				else f[i]=f[i-1];
			}
			if(!oks){
				cout<<"-1\n";
				continue;
			}
		}
		for(int i=1;i<=m;i++){
			if((*q.begin()).sm)cout<<(*q.begin()).bh<<" "<<(*q.begin()).sm<<" "<<(*(--q.end())).bh<<" "<<k-(*q.begin()).sm<<"\n";
			else cout<<(*(--q.end())).bh<<" "<<k-(*q.begin()).sm<<"\n";
			auto x=*(--q.end());
			x.sm-=k-(*q.begin()).sm;
			q.erase(q.begin());
			q.erase(--q.end());
			q.insert(x);
		}
	}
}
```

---

## 作者：Iam1789 (赞：0)

感觉是个牛逼思维好题，也可能是我太菜了。

首先考虑 $m=n-1$。~~通过观察大样例~~，猜测其一定有解。考虑如何证明。首先考虑 $n=2$，不难发现可以直接用完原材料。再考虑一般情况。由于 $m<n$，所以一定有 $\min a_i < k$。我们可以通过一次和其它食材的操作，将这个食材删掉，使目前的状态变为 $n=n-1,m=m-1$。递归下去，可以变为 $n=2$ 的状态。

接着考虑 $m>n-1$。由于 $n\geq m$，所以一定有 $\max a_i \geq k$。对这种食材进行一次仅使用该食材的操作，使状态变为 $n=n,m=m-1$ 或 $n=n-1,m=m-1$。递归下去，可以变为 $m=n-1$ 的状态或者将食材直接用完。

最后考虑 $m=n-2$。如果 $m=1$ 且 $n>2$，此时显然是无解的。由于一次操作最多只能用光两种食材，为了避免这种情况的发生，我们至少需要两次一下用光两种食材的操作。定义帮助达成这样操作的其它操作为前置操作，一个状态的最后一次操作为结束操作。不难发现，一下用光两种食材是 $m=n-1$ 状态的结束操作，每一个这样的操作可以与一个 $m=n-1$ 的子状态一一对应，而该操作与其前置操作是该子状态的解。所以**原状态能够被分成两个 $m=n-1$ 子状态**是有解的充要条件。

考虑怎么进行判定。设 $dp_{i,j,h}$ 表示是否存在有 $i$ 种食材，且食材质量之和为 $jk+h$ 的子状态，其中 $h<k$。容易转移。时间复杂度 $\Theta (Tn^2 mk)$。考虑优化。由于我们只关心 $i-j$ 用来判定，所以可以将 $i,j$ 压成一维。同时，我们还可以把 $h$ 一维扔进 `bitset` 中维护。这样时间复杂度就被优化到了 $\Theta(T\frac{nmk}{\omega})$。至于构造方案，我们用同样的方式反着 `dp` 一遍找出转移路径，再用 $m=n-1$ 的做法就可以了。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
	int s=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
		f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		s=s*10+c-'0';
		c=getchar();
	}
	return s*f;
}
int T;
int m,k;
struct Subtask1{
	set <pair<int,int> > s;
	inline void Solve(int n,int *a)
	{
	//	cout<<n<<endl;
	//	for(int i=1;i<=n;++i)
	//	printf("%d ",a[i]);
	//	cout<<endl;
		s.clear();
		for(int i=1;i<=n;++i)
			if(a[i])
				s.insert(make_pair(a[i],i));
		while(!s.empty())
		{
			int u=(*s.begin()).second;
			s.erase(make_pair(a[u],u));
			while(a[u]>=k)
			printf("%d %d\n",u,k),a[u]-=k;
			if(!a[u])
			continue;
			if(!s.empty())
			{
				int v=(*s.rbegin()).second;
				s.erase(make_pair(a[v],v));
				printf("%d %d %d %d\n",u,a[u],v,k-a[u]);
				a[v]-=(k-a[u]);
				if(a[v])
				s.insert(make_pair(a[v],v));
			}
		}
	}
}Sub1;
struct Subtask2{
	bitset <5007> b[507][1007],c,l;//m-n
	bool d[5007];
	int e[5007];
	inline void Solve(int n,int *a)
	{
		c&=0;
		for(int i=1;i<=n;++i)
		d[i]=0;
		for(int i=0;i<k;++i)
		c[i]=1;
		b[0][n][0]=1;
		for(int i=1;i<=n;++i)
		{
			for(int j=0;j<=2*n;++j)
			{
				b[i][j+a[i]/k-1]|=b[i-1][j+a[i]/k-1]|((b[i-1][j]<<(a[i]%k))&c);
				b[i][j+a[i]/k]|=b[i-1][j+a[i]/k]|((b[i-1][j]>>(k-a[i]%k))&c);
			}
		}
	/*	for(int i=0;i<=n;++i)
		{
			for(int j=0;j<=2*n;++j)
			{
				for(int h=0;h<k;++h)
				{
					if(b[i][j][h])
					cout<<i<<" "<<j<<" "<<h<<endl;
				}
			}
		}*/
					
		if(b[n][n-1][0]==1)
		{
			int x=n-1,y=0;
			for(int i=n;i>=1;--i)
			{
				for(int j=0;j<=2*n;++j)
				{
					if((j+a[i]/k-1)==x)
					{
						l=b[i-1][j]<<(a[i]%k);
						if(l[y])
						{
							x=j,y=y-(a[i]%k);
							d[i]=1;
							break;
						}
					}
					if((j+a[i]/k)==x)
					{
						l=b[i-1][j]>>(k-a[i]%k);
						if(l[y])
						{
							x=j,y=y+(k-a[i]%k);
							d[i]=1;
							break;
						}
					}
				}
			}
			for(int i=1;i<=n;++i)
			{
				if(d[i])
				e[i]=a[i];
				else
				e[i]=0;
			}
			Sub1.Solve(n,e);
			for(int i=1;i<=n;++i)
			{
				if(!d[i])
				e[i]=a[i];
				else
				e[i]=0;
			}
			Sub1.Solve(n,e);
		}
		else
		puts("-1");
		for(int i=1;i<=n;++i)
			for(int j=0;j<=2*n;++j)
				b[i][j]&=0;
		b[0][n][0]=0;
	}
}Sub2;
int n;
int a[507];
int main()
{
	T=read();
	while(T--)
	{
		n=read(),m=read(),k=read();
		for(int i=1;i<=n;++i)
		a[i]=read();
		if(m==n-2)
		Sub2.Solve(n,a);
		else
		Sub1.Solve(n,a);
	}
	return 0;
}
```


---

## 作者：chenxia25 (赞：0)

话说这题为啥是个黑题啊，感觉我能独立 AC 的题都不能算黑题（

然而在考场上还写挂了，有调味料选了 $0\mathrm g$，而输出格式规定$y>0$（悲）。这启示我们下次写 spj 题的时候，如果自己写 checker 判正确性，一定要把题面里所有的限制都判一下……

> ### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6775)

>题意见洛谷。

首先，显然有 $\sum d_i=mk$。以下设 $mn=\min\{d_i\},mx=\max\{d_i\}$，则 $mx\geq \dfrac mnk,mn\leq \dfrac mnk$。

注意到奇奇怪怪的数据范围，不妨先从 $m=n$ 入手。此时显然有 $mx\geq k,mn\leq k$。考虑配出一道菜，那么可以优先将 $mn$ 用掉，然后用 $mx$ 解决剩下的 $k-mn$，由于 $mn\geq1$，所以一定有 $mx>k-mn$，$mx$ 用不完。可以保证恰好用掉一个原料。此时 $n,m$ 都减一，转化为了一个规模小一级的 $m=n$ 问题。边界是 $n=m=0$。

然后考虑 $m>n$。显然有 $mx>k$。直接用 $mx$ 配出一个菜，还用不完，只有 $m$ 减一。就这样一直减减减，直到 $m=n$ 为止。

然后考虑 $m=n-1$。$m=1,n=2$ 时直接配就可以了（这是边界）。否则，考虑配出一道菜。那么能否配出一道菜呢？这就要满足 $mx+mx'\geq k$，其中 $mx'$ 表示第二大的原料。肉眼只能得到 $mx\geq \dfrac{n-1}nk$ 这样一个条件，仿佛不能保证一定能配出。但是经过不懈的尝试，还是证出来了一定能。

证明：反证法。假设不能，则 $mx+mx'<k$，即 $mx'<k-mx$。又 $\sum d_i\leq (n-1)mx'+mx=u$，显然当 $mx=\dfrac{n-1}nk$ 时，$u$ 的上限最松为 $u<(n-1)\left(k-\dfrac{n-1}nk\right)+\dfrac{n-1}nk=\dfrac{2n-2}nk$。所以 $\sum d_i<\dfrac{2n-2}nk$。又 $n>2$，所以 $\dfrac2n<1$，所以 $\dfrac{2n-2}nk<(n-1)k=\sum d_i$，矛盾。得证。

所以只需要优先用 $mx'$，再用 $mx$。但是就怕 $mx'>k$，用不完，那么用掉之后就 $m=n-2$ 了，哦吼，未知问题。那怎么办呢？注意到显然有 $mn<k$，先把 $mn$ 用掉即可。这样可能会转化到一个规模小一级的 $m=n-1$，也有可能 $m=n$（可能会 $mx+mx'=k$）。

至此，$m\geq n-1$ 就归纳做完了。$m=n-2$ 貌似没有啥思路？注意到可以将原料和菜分成两部分，使得每部分内部的原料和菜质量相等，并且 $m_1=n_1-1,m_2=n_2-1$，这样就可以做了。然后猜想，若不能分，则无解，并试图证明。然后就证出来了（我考场上没证，直接写的）。

证明：考虑证明逆否命题：若有解，则能分。考虑将每个菜看作节点，将每个原料也看作节点，若一个菜用了一个原料，则它们之间有边，构成一张二分图。显然，有 $n+m$ 个点，最多有 $2m$ 条边。要想图连通，必要条件是 $2m\geq n+m-1$，即 $m\geq n-1$。现在 $m=n-2$ 则图一定不连通。然后显然一定存在连通分量的 $m'=n'-1$，因为全是 $m'\geq n'$ 的话最终就 $m\geq n$ 了。所以这个连通分量以及它的补图是独立的，各自有解。得证。

接下来就是怎么分的事了。设分成两个集合 $S,T$，则对 $A=S$ 或 $A=T$ 都有 $\sum\limits_{i\in A}(d_i-k)=-k$。这是一个很简单的 01 背包，最终还原一下路径即可。定义域是 $\mathrm O(nk)$ 的，要更新 $n$ 遍，复杂度 $\mathrm O\!\left(n^2k\right)$，吃不消。注意到 DP 数组只记录能否凑出的布尔值，转移时 `bitset` 移位 + 按位或即可。

总时间复杂度 $\mathrm O\!\left(\dfrac{Tn^2k}w\right)$。

代码（好像要加个 O3，然后过不过还要看评测只因心情。不过 ccf 只因应该更快吧，当时我查分的时候发现全是 PE 没有 T 的）：
```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define X first
#define Y second
const int inf=0x3f3f3f3f;
const int N=500,K=5000;
int n,m,k;
int d[N+1];
vector<pair<pair<int,int>,pair<int,int> > > ans;
void use(int x,int y=0){
	m--;
	if(d[x]>=k){
		ans.pb(mp(mp(x,k),mp(0,0)));
		d[x]-=k;if(!d[x])n--;
	}
	else{
		int now=k;
		ans.pb(mp(mp(x,d[x]),mp(0,0)));
		now-=d[x],d[x]=0,n--;
		ans.back().Y=mp(y,now);
		d[y]-=now;if(!d[y])n--;
	}
}
void m_lss_n(){
	pair<int,int> mn(inf,inf),mx1(0,0),mx2(0,0);
	for(int i=1;i<=N;i++)if(d[i]){
		mn=min(mn,mp(d[i],i));
		if(mp(d[i],i)>mx1)mx2=mx1,mx1=mp(d[i],i);
		else if(mp(d[i],i)>mx2)mx2=mp(d[i],i);
	}
	if(mx2.X>k)use(mn.Y,mx2.Y);
	else use(mx2.Y,mx1.Y);
}
void m_eq_n(){
	pair<int,int> mn(inf,inf),mx(0,0);
	for(int i=1;i<=N;i++)if(d[i])mn=min(mn,mp(d[i],i)),mx=max(mx,mp(d[i],i));
	use(mn.Y,mx.Y);
}
void m_grt_n(){
	pair<int,int> mx(0,0);
	for(int i=1;i<=N;i++)if(d[i])mx=max(mx,mp(d[i],i));
	use(mx.Y);
}
void deal(){
	while(m){
		if(m<n)m_lss_n();
		else if(m==n)m_eq_n();
		else m_grt_n();
	}
}
bitset<2*N*K+1> dp[N+1];
void mian(){
	ans.clear();
	cin>>n>>m>>k;
	memset(d,0,sizeof(d));
	for(int i=1;i<=n;i++)cin>>d[i];
	if(m>=n-1)deal();
	else{
		for(int i=0;i<=n;i++)dp[i].reset();
		dp[0].set(n*k);
		for(int i=1;i<=n;i++){
			int x=d[i]-k;
			if(x<0)dp[i]=dp[i-1]|dp[i-1]>>-x;
			else dp[i]=dp[i-1]|dp[i-1]<<x;
		}
		vector<pair<int,int> > v1,v2;
		int now=n*k-k;
		if(!dp[n][now])return puts("-1"),void();
		for(int i=n;i;i--){
			if(dp[i-1][now])v1.pb(mp(i,d[i]));
			else now-=d[i]-k,v2.pb(mp(i,d[i]));
		}
		memset(d,0,sizeof(d));
		for(int i=0;i<v1.size();i++)d[v1[i].X]=v1[i].Y;
		n=v1.size(),m=n-1,deal();
		memset(d,0,sizeof(d));
		for(int i=0;i<v2.size();i++)d[v2[i].X]=v2[i].Y;
		n=v2.size(),m=n-1,deal();
	}
	for(int i=0;i<ans.size();i++)
		if(ans[i].Y.Y)printf("%d %d %d %d\n",ans[i].X.X,ans[i].X.Y,ans[i].Y.X,ans[i].Y.Y);
		else printf("%d %d\n",ans[i].X.X,ans[i].X.Y);
}
int main(){
	int testnum;
	cin>>testnum;
	while(testnum--)mian();
	return 0;
}
```

---

## 作者：Tyyyyyy (赞：0)

## P6775

### 题意简述
给定 $n,m,k$ 和序列 $d_1,\dots,d_n$，满足 $\sum d_i=m\times k$。用 $d$ 序列凑出 $m$ 个 $k$，要求同一个 $k$ 最多由两个 $d_i$ 构成。构造方案。

$1\leq n\leq 500,n-2\leq m\leq 5000,1\leq k\leq 5000$。

### 题目分析
发现部分分给了 $m=n-1$ 和 $m\geq n-1$，先讨论这两种情况。

#### $m=n-1$
此时必定存在一种方案的构造方式如下：不断选最小的作为新的一个 $k$ 的一部分，并用最大的补齐。考虑证明，因为 $\sum d_i=(n-1)k$，所以 $d_1<k$（这里假设 $d_1\leq d_2\leq \dots \leq d_n$，下文同)，补齐 $d_1$ 之后是一个新的子问题，归纳可证。

#### $m\geq n-1$
考虑将问题向 $m=n-1$ 转化。不难发现我们将 $d_i$ 排序后不断用最大的构成新的 $k$（不足用次大补齐），一定会使得 $m$ 减少得比 $n$ 快。这是因为当 $m\geq n$ 时，一定有 $d_n\geq k$，所以最大的 $d_i$ 不止对一个 $k$ 做出了贡献。重复此过程直到 $m=n-1$，套用 $m=n-1$ 的做法构造剩下的部分即可。

#### $m=n-2$
同样考虑将问题向 $m=n-1$ 转化。观察样例可以发现只要我们把所有的 $d_i$ 分为两个集合，使得每个集合中用 $n_0$ 个 $d_i$ 凑出了 $n_0-1$ 个 $k$，那么合起来就是一种合法的方案。又因为根据上文的讨论，$m=n-1$ 时必定有解，所以我们只要找到一个集合 $S$，满足 $\displaystyle\sum_{i\in S}d_i=(|S|-1)k$ 即可。这是一个经典问题，括号展开移项即可得到 $\sum k-d_i=k$，这样该问题就与 $|S|$ 无关，是一个简单的背包问题，可以用 bitset 优化。需要注意的是，这里 $k-d_i$ 的值域是 $[-(m-1)\times k,k-1]$，负数最小可达 $-2.5\times 10^7$，直接开是开不下的。为了严谨性应该分为正负分别做背包，这样只用开正数和的可能最大值 $2.5\times 10^6$，但是实际上直接开 $2.5\times 10^6$ 做背包就可以过了。

做完背包之后构造方案是平凡的。前两部分时间复杂度为 $O(n^2)$，最后一部分时间复杂度为 $O(\frac{n^2k}{w})$。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510,M=5010;
int T,n,m,k,n1,n2;
struct node
{
	int d,id;
	bool operator < (node b) const
	{
		return d<b.d;
	}
}a[N],a1[N],a2[N];
bitset<N*M>f[N];
bool vis[N];
int main()
{	
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&n,&m,&k);
		for(int i=1;i<=n;i++)scanf("%d",&a[i].d),a[i].id=i,vis[i]=0;
		sort(a+1,a+n+1);
		if(m>=n-1)
		{
			while(m!=n-1)
			{
				if(!m||!n)break;
				if(a[n].d>k)a[n].d-=k,printf("%d %d\n",a[n].id,k),m--;
				else if(a[n].d==k)printf("%d %d\n",a[n].id,k),n--,m--;
				else n--,a[n].d-=k-a[n+1].d,printf("%d %d %d %d\n",a[n+1].id,a[n+1].d,a[n].id,k-a[n+1].d),m--;
			}
			while(1)
			{
				int mn=1e9,mnid=0,mx=0,mxid=0;
				for(int i=1;i<=n;i++)
				{
					if(vis[i])continue;
					if(a[i].d<mn)mnid=i,mn=a[i].d;
					if(a[i].d>mx)mxid=i,mx=a[i].d;
				}
				if(!mnid&&!mxid)break;
				printf("%d %d %d %d\n",a[mnid].id,a[mnid].d,a[mxid].id,k-a[mnid].d);
				a[mxid].d-=k-a[mnid].d,a[mnid].d=k,vis[mnid]=1,vis[mxid]=(!a[mxid].d);
			}
			for(int i=1;i<=n;i++)if(!vis[i])printf("%d %d\n",a[i].id,k);
		}
		else
		{
			sort(a+1,a+n+1);
			f[0][0]=1;
			for(int i=1;i<=n;i++)
				if(k>=a[i].d)f[i]=f[i-1]|(f[i-1]<<(k-a[i].d));
				else f[i]=f[i-1]|(f[i-1]>>(a[i].d-k));
			if(!f[n][k])puts("-1");
			else
			{
				int now=k;
				for(int i=n;i;i--)
					if(now>=(k-a[i].d)&&f[i-1][now-(k-a[i].d)])vis[i]=1,now-=k-a[i].d;
				n1=n2=0; 
				for(int i=1;i<=n;i++)
					if(vis[i])a1[++n1]=a[i];
					else a2[++n2]=a[i];
				for(int i=1;i<=n1;i++)vis[i]=0;
				while(1)
				{
					int mn=1e9,mnid=0,mx=0,mxid=0;
					for(int i=1;i<=n1;i++)
					{
						if(vis[i])continue;
						if(a1[i].d<=mn)mnid=i,mn=a1[i].d;
						if(a1[i].d>mx)mxid=i,mx=a1[i].d;
					}
					if(!mnid&&!mxid)break;
					printf("%d %d %d %d\n",a1[mnid].id,a1[mnid].d,a1[mxid].id,k-a1[mnid].d);
					a1[mxid].d-=k-a1[mnid].d,a1[mnid].d=k,vis[mnid]=1,vis[mxid]=(!a1[mxid].d);
				}
				for(int i=1;i<=n1;i++)if(!vis[i])printf("%d %d\n",a1[i].id,k);
				for(int i=1;i<=n2;i++)vis[i]=0;
				while(1)
				{
					int mn=1e9,mnid=0,mx=0,mxid=0;
					for(int i=1;i<=n2;i++)
					{
						if(vis[i])continue;
						if(a2[i].d<mn)mnid=i,mn=a2[i].d;
						if(a2[i].d>mx)mxid=i,mx=a2[i].d;
					}
					if(!mnid&&!mxid)break;
					printf("%d %d %d %d\n",a2[mnid].id,a2[mnid].d,a2[mxid].id,k-a2[mnid].d);
					a2[mxid].d-=k-a2[mnid].d,a2[mnid].d=k,vis[mnid]=1,vis[mxid]=(!a2[mxid].d);
				}
				for(int i=1;i<=n2;i++)if(!vis[i])printf("%d %d\n",a2[i].id,k);
			}
		}
	}
	return 0;
}
```

---


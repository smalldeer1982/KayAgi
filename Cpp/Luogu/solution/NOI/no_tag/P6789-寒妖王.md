# 寒妖王

## 题目背景

寒冷的保加利亚小屋里，你发现了寒妖王给你提出的一个问题。

## 题目描述

给定一张 $n$ 个点 $m$ 条边的图，保证无重边与自环。第 $i$ 条边有权值 $w _i$。

定义一个边集是好的，当且仅当将这些边和与这些边相连的点取出来形成的图没有两个或以上处在同一个连通块的不同的环（两个环不同指的是构成环的边集不能完全相同）。同时定义一个边集的权值为边集中所有边的边权之和。

现在，每条边均有 $50\%$ 的概率消失。求在消失过程完成后，图中权值最大的好边集的权值的期望。

输出该期望值对一个大质数 $998244353$ 取模的结果。

可以知道这里的期望值是一个有理数。其对 $998244353$ 取模的结果相当于是将其写为最简分数形式 $\frac x y$（其中 $x$ 与 $y$ 互质）后 $x \times y ^{998244351}$ 对 $998244353$ 取模的结果。

## 说明/提示

**「数据范围与约定」**

- 对于前 $20\%$ 的数据，保证 $n \le 10$，$m \le 20$；
- 对于前 $40\%$ 的数据，保证 $n \le 10$，$m \le 30$；
- 对于另外 $30\%$ 的数据，保证所有边的权值均相等；
- 对于所有数据，保证 $1 \le n \le 15$，$1 \le m \le 60$，$1 \le u _i, v _i \le n$，$0 \le w _i < 998244353$。

## 样例 #1

### 输入

```
4 6
2 3 294405877
3 4 340909188
1 2 7718822
2 4 340754548
1 4 209906514
1 3 810986947
```

### 输出

```
121593921
```

# 题解

## 作者：Soulist (赞：14)

给定 $n$ 个点 $m$ 条边的图，第 $i$ 条边的权值为 $w_i$，每条边有 $\frac{1}{2}$ 的概率被保留，求最后这张图的最大基环树森林的边权和。

### Solution

$\mathcal O(2^m\cdot m\alpha(n))$ 是显然的。

类比一下 Kruskal 求 MST 就会做了。

考虑优化，我们不妨考虑判定一条边什么情况下**不会**被加入答案，等价于仅考虑边权大于他的边，有他连接的两个点：

1. 连通，且此时不为树。
2. 不连通，此时这两个点分别在一个基环树上。

第一类贡献很简单，我们统计仅保留这些边时点集 $S$ 的生成树的数量。这个可以枚举子集 $T\subseteq S$，然后计算一棵生成树，不难发现每棵生成树会被计算 $|S|-1$ 次，除掉即可。

统计 $T\to T\land S$ 中的边数通过 $cnt_S-cnt_T-cnt_{T\land S}$ 来计算，这样复杂度为 $\mathcal O(m\cdot 3^n)$，需要适当减枝，比如点集 $S$ 的边数小于 $|S|-1$ 时就直接 out

接下来考虑统计第二类贡献。

不难发现第二类贡献等价于点集 $A$ 和点集 $B$ 满足 $x\in A,y\in B$ 且 $A$ 是联通图不是生成树，$B$ 是联通图不是树。

枚举 $A,B$ 的总量是 $3^n$ 的，这样只需要预处理联通图计数，经典的容斥手段可以做到 $\mathcal O(3^n)$

最后，我们在 $\mathcal O(m3^n)$ 的复杂度解决了此问题。

- 预处理 $cnt$ 数组我是用高维前缀和算的。

ps : 看着不能过，但实际上有一些细节可以减一下枝，大概可以减少 $\frac{1}{3}\sim \frac{1}{9}$ 不等的常数，然后我 UB 了调了一晚上...

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int P = 998244353 ; 
const int N = (1 << 16) + 5 ; 
int n, m, limit, bit[N], ip[N], fac[70], iv[35], f[N], g[N], cnt[N], Ans ; 
struct E {
	int u, v, w ; 
} e[100] ;
bool cmp(E x, E y) { return x.w > y.w ; }
int fpow(int x, int k) {
	int ans = 1, base = x ;
	while(k) {
		if(k & 1) ans = 1ll * ans * base % P ;
		base = 1ll * base * base % P, k >>= 1 ;
	} return ans ;
}
void inc(int &x, int y) { ((x += y) >= P) && (x -= P) ; }
void solve(int x) {
	memset( cnt, 0, sizeof(cnt) ), memset( f, 0, sizeof(f) ), memset( g, 0, sizeof(g) ) ;
	rep( i, 1, x - 1 ) ++ cnt[(1 << e[i].u) | (1 << e[i].v)] ;
	for(re int k = 1; k <= limit; k <<= 1 )
	rep( i, 0, limit ) if(i & k) cnt[i] += cnt[i ^ k] ; 
	rep( S, 1, limit ) {
		if( bit[S] == 1 ) { f[S] = g[S] = 1 ; continue ; }
		if( cnt[S] < bit[S] - 1 ) { f[S] = 0 ; g[S] = 0 ; continue ; }
		int w = (1 << ip[S]), z = S ^ w ; f[S] = 0, g[S] = fac[cnt[S]] ; 
		for(re int i = z; i; i = (i - 1) & z) {
			int u = i ^ S, t = cnt[S] - cnt[i] - cnt[u] ; 
			f[S] = (f[S] + 1ll * f[i] * f[u] % P * t ) ;
			g[S] = (g[S] - g[u] * fac[cnt[i]] % P) ; 
		}
		f[S] %= P, g[S] = (g[S] % P + P) % P ; 
		f[S] = f[S] * iv[bit[S] - 1] % P ; 
	}
	int ans = 0, u = (1 << e[x].u), v = (1 << e[x].v) ;
	rep( S, 1, limit ) g[S] = (g[S] % P - f[S] % P + P) % P ; 
	rep( S, 1, limit ) {
		if( (!(S & u)) || (!(S & v)) ) continue ; 
		int d = g[S] ; d = d * fac[cnt[limit ^ S]] % P ;
		ans = (ans + d) % P ;
		//S 联通且不为树，枚举 S，外部任意 
	}
	rep( A, 1, limit ) {
		if( (!(A & u)) || (A & v) ) continue ; 
		int T = A ^ limit ; 
		for(re int B = T; B; B = (B - 1) & T) {
			if( !(B & v) ) continue ; 
			ans = (ans + 1ll * g[A] * g[B] % P * fac[cnt[limit ^ A ^ B]] % P) % P ; 
		}
	} 
	int ffv = (P + 1) / 2 ; 
	ans = ans * fpow( fac[x], P - 2 ) % P, ans = (ffv - ans + P) % P ; 
	Ans = (Ans + ans * e[x].w) % P ; 
}
signed main()
{
	n = gi(), m = gi() ; 
	rep( i, 1, m ) 
		e[i].u = gi() - 1, e[i].v = gi() - 1, e[i].w = gi() ; 
	sort(e + 1, e + m + 1, cmp), iv[0] = fac[0] = 1 ; 
	rep( i, 1, n ) iv[i] = fpow(i, P - 2) ; 
	rep( i, 1, m ) fac[i] = fac[i - 1] * 2 % P ;
	limit = (1 << n) - 1 ; 
	rep( i, 1, limit ) {
		bit[i] = __builtin_popcountll(i) ; 
		rep( j, 0, n - 1 ) if((1 << j) & i) { ip[i] = j ; break ; }
	}
	rep( i, 1, m ) solve(i) ; 
	cout << (long long)Ans << endl ; 
	return 0 ;
}
```



---

## 作者：Purslane (赞：4)

# Solution

我自己做的时候先设计了一个极为抽象的 DP，但是发现不同点集之间完全不独立，浪费了一晚上的时间呜呜。概率 DP 一定要考虑概率是否独立啊啊啊。

------

基环树这个东西具有拟阵的性质，所以可以贪心。

对于每条边，只保留**优先级比他高的边**，选出一个边集。对于每个边集，判断这条边能否加入，计算概率即可。

这条边能加入：

1. 两个端点在同一个连通块内，且这个连通块是一棵树。
2. 两个端点在不同的连通块内，且这两个连通块至少有一个是树。

现在你要算一个点集有多大概率是一个极大的连通块。这个东西用集合幂级数 ln + 子集卷积 + 矩阵树定理可以做到 $O(m \text{poly}(n) 2^n)$，但是我怀疑它跑不过 $O(m 3^n)$。

设 $cnt_S$ 为考虑 $S$ 的导出子图，有多少种方法使他成为一棵树。直接枚举一条边，将 $S$ 拆分为两个子集即可。

设 $Cnt_S$ 为考虑 $S$ 的导出子图，有多少种方法使他连通。用所有图（$2^e$）减去钦定了某一个包含 $\rm lowbit$ 的连通块即可。

不过这样会 T 飞起。你发现并不需要每次都跑一遍全局的树、图计数。新加入一条边 $(u,v)$，只去修改 $\{u,v\} \subseteq S$ 的 $S$ 即可，这样拥有更小的常数。

其实这两个过程都可以直接用子集卷积优化的，所以其实直接做就是 $O(m n^2 2^n)$ 的了？但是懒得写啊呜呜呜。

统计答案的时候再枚举一次子集。唉这个题看起来这么唐，怎么坠机了呢。 /ll

```cpp
#include<bits/stdc++.h>
#define ll long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXM=60+5,MAXS=(1<<15)+10,MOD=998244353,_2=(MOD+1)/2;
int n,m,ans,f[MAXS],g[MAXS],cnt[MAXS],pw[MAXM];
struct Edge {int u,v,w;}e[MAXM];
ll qpow(ll base,int p) {
	ll ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
void solve(int id) {
	int prob=0;
	int u=e[id].u,v=e[id].v;
	ffor(s,0,(1<<n)-1) if(s&(1<<u-1)) {
		int ot=(1<<n)-1-s;
		for(int S=ot;S;S=(S-1)&ot) if(S&(1<<v-1)) prob=(prob+(-1ll*f[s]*f[S]%MOD+1ll*f[s]*g[S]%MOD+1ll*g[s]*f[S]%MOD)%MOD*pw[cnt[(1<<n)-1-s-S]])%MOD;
	}
	ffor(s,0,(1<<n)-1) if((s&(1<<u-1))&&(s&(1<<v-1))) prob=(prob+1ll*f[s]*pw[cnt[(1<<n)-1-s]])%MOD;
	ans=(ans+1ll*prob*qpow(pw[id],MOD-2)%MOD*e[id].w)%MOD;
	ffor(i,0,(1<<n)-1) {
		if((i&(1<<u-1))&&(i&(1<<v-1))) {
			cnt[i]++,g[i]=2*g[i]%MOD;
			for(int s1=i;s1;s1=(s1-1)&i) {
				if(!(s1&(1<<u-1))) continue ;
				int s2=i-s1;
				if(!(s2&(1<<v-1))) continue ;
				g[i]=(g[i]+1ll*g[s1]*g[s2])%MOD;
				f[i]=(f[i]+1ll*f[s1]*f[s2])%MOD;
			}
		}
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) cin>>e[i].u>>e[i].v>>e[i].w;
	sort(e+1,e+m+1,[](Edge A,Edge B) {
		return A.w>B.w;	
	});
	pw[0]=1; ffor(i,1,m) pw[i]=pw[i-1]*2%MOD;
	ffor(i,1,n) f[1<<i-1]=g[1<<i-1]=1;
	ffor(i,1,m) solve(i);
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

人话题意：
给一个 $n$ 个点 $m$ 条边的简单无向图，边有边权。定义一个边集是好的，当且仅当将这些边和与这些边相连的点取出来形成的图没有两个或以上处在同一个连通块的不同的环。同时定义一个边集的权值为边集中所有边的边权之和。
每条边有 $50\%$ 的概率消失，问图中权值最大的好边集的权值的期望。

数据范围：
$ n \le 15,m\le 60 $

### Solution：

实际上就是问最大生成环套树森林的期望。考虑按边权从大到小加边，一条边有贡献，当且仅当其两个端点位于的连通块是一棵树，或位于不同的连通块，且至少有一个连通块无环。

令 $f_{i,V},g_{i,V}$ 表示考虑前 $i$ 条边中端点与 $V$ 交集非空的那些，满足 $V$ 是一个极大的连通图/树的方案。加入一条边进行转移时，枚举包含这条边两个端点的集合 $V$，再枚举两个端点分别位于的连通块 $S , T$ 那么会得到
$$f_{i,V} = 2f_{i-1,V}+ \sum _ {S\bigcap T = \emptyset,S\bigcup T = V} {f_{i-1,S} \times f_{i-1, T}}$$

以及
$$g_{i,V} = g_{i-1,V}+ \sum _ {S\bigcap T = \emptyset,S\bigcup T = V} {g_{i-1,S} \times g_{i-1, T}}$$

统计第 $i$ 条边的贡献时，考虑补记转化，求第 $i$ 条边不能做贡献的方案。也就是 $i$ 所在连通块存在环，或 $i$ 连接的两个连通块均存在环。注意到 $V$ 中存在环的方案等于 $f_{i-1,V}-g_{i-1,V}$，故答案等于
$$\sum _ {V} {(f_{i-1,V}-g_{i-1,V}+\sum _ {S\bigcap T = \emptyset,S\bigcup T = V} {(f_{i-1,S}-g_{i-1,S})\times(f_{i-1,T}-g_{i-1,S})})}$$

在算期望时，发现 $V$ 的方案数会少乘个 $2 ^ {s}$ ，其中 $s $ 表示前 $i$ 条边中，有多少条满足两个端点都不位于 $V$ 中。再维护一个 $S_{V}$ 表示有多少条边的两个端点均位于 $V$  中即可。

实现的时候 $f , g$ 可以滚动。时间复杂度为 $O(m3^{n})$，有 $\frac{1}{9}$ 的常数。

$code$：

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N = 20;
const int M = 65;
const int K = (1 << 15) + 5;
const int MOD = 998244353;

int n, m, bin[N], f[K], g[K], num[K], inv[M];
struct edge{int x, y, w;}e[M];

bool cmp(edge a, edge b)
{
	return a.w > b.w;
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) scanf("%d%d%d", &e[i].x, &e[i].y, &e[i].w), e[i].x--, e[i].y--;
	sort(e + 1, e + m + 1, cmp);
	bin[0] = inv[0] = 1;
	for (int i = 1; i <= n; i++) bin[i] = bin[i - 1] * 2;
	for (int i = 1; i <= m; i++) inv[i] = (LL)inv[i - 1] * ((MOD + 1) / 2) % MOD;
	for (int i = 0; i < n; i++) f[bin[i]] = g[bin[i]] = 1;
	int ans = 0;
	for (int i = 1; i <= m; i++)
	{
		int x = bin[e[i].x], y = bin[e[i].y], w = (MOD + 1) / 2;
		for (int j = 0; j < bin[n]; j++) if (!(j & x) && !(j & y))
		{
			int V = j | x | y, s = (f[V] - g[V]) % MOD;
			for (int k = j; k >= 0; k = !k ? k - 1 : (k - 1) & j)
			{
				int S = k | x, T = V ^ S;
				(s += (LL)(f[S] - g[S]) * (f[T] - g[T]) % MOD) %= MOD;
			}
			(w -= (LL)s * inv[i - num[(bin[n] - 1) ^ V]] % MOD) %= MOD;
		}
		(ans += (LL)w * e[i].w % MOD) %= MOD;
		for (int j = bin[n] - 1; j >= 0; j--) if (!(j & x) && !(j & y))
		{
			int V = j | x | y;
			(f[V] *= 2) %= MOD;
			num[V]++;
			for (int k = j; k >= 0; k = !k ? k - 1 : (k - 1) & j)
			{
				int S = k | x, T = V ^ S;
				(f[V] += (LL)f[S] * f[T] % MOD) %= MOD;
				(g[V] += (LL)g[S] * g[T] % MOD) %= MOD;
			}
		}
	}
	printf("%d\n", (ans + MOD) % MOD);
	return 0;
}

```

本蒟蒻第二篇题解，求过！

---

## 作者：Mirasycle (赞：2)

- 图联通计数：$f_s$ 为集合 $s$ 内联通的方案数，考虑使用容斥拿总的 $2^{e(s)}$ 减去不合法的图。不合法的只需要钦定一个包含 $\rm lowbit(s)$ 的联通集合，剩余的随便选就行了。可以预处理 $e(S)$，做到 $O(3^n)$。

* 树计数：设 $f_s$ 为集合 $s$ 为一颗树的方案数，直接通过一条边把 $S$ 分裂成两个集合 $s,t$，$f_S\gets f_s\times f_t$，可以发现 $S$ 一共被计算了 $\rm popcount(S)-1$ 次，除掉即可。

以上是本题的前置知识。

考虑按照 Kruskal 的过程来思考，我们应该从大到小加入边。显然影响某条边是否能产生贡献的因素就是比它大的边构成的图。

这条边能产生贡献有以下两种情况，

- 比它大的边构成的图中 $u$ 和 $v$ 在同一联通块，且这个联通块是一棵树。

- 比它大的边构成的图中 $u$ 和 $v$ 不在同一联通块，且这两个联通块至少有一个是一棵树。

设 $f_s$ 表示集合 $s$ 内的点构成一棵树的方案数，$g_s$ 表示集合 $s$ 内的点构成联通块的方案数，按照上文中的计算方式进行求解即可。

第一种贡献情况可以直接用 $f_s$ 解决。第二种情况的贡献就是 $f_sg_t+f_tg_s-f_sf_t$。

每次加入一条边统计过答案之后就做一次 $O(3^n)$ 的图联通计数，重新计算 $f_s$ 和 $g_s$。这里可以卡常就是我们只重新计算和 $u,v$ 有关的 $s$，其他的不会发生变化。

时间复杂度 $O(m3^n)$。

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=70;
const int maxm=(1<<16);
const int mod=998244353;
void add(int &x,int y){ x=x+y>=mod?x+y-mod:x+y; }
void sub(int &x,int y){ x=x<y?x-y+mod:x-y; }
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
int lowbit(int x){ return x&-x; }
struct edge{
	int u,v,w;
	bool operator < (const edge &rhs) const {
		return w>rhs.w;
	}
}e[maxn];
int id(int x){ return 1<<(x-1); }
int n,m,pw[maxn],inv[maxn],U;
int f[maxm],g[maxm],c[maxm],pc[maxm];
int qpow(int x,int k){
	int res=1;
	for(;k;k>>=1){
		if(k&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
	}
	return res;
}
int solve(int u,int v){
	ll res=0;
	for(int s=1;s<=U;s++)
		if((s&id(u))&&(s&id(v)))
			res=(res+1ll*f[s]*pw[c[U^s]])%mod;
	for(int s=1;s<=U;s++){
		if(!(s&id(u))||(s&id(v))) continue; int z=U^s; 
		for(int t=z;t;t=(t-1)&z){
			if(!(t&id(v))) continue;
			res=(res+(1ll*g[s]*f[t]+1ll*f[s]*g[t]-1ll*f[s]*f[t])%mod*pw[c[U^(s+t)]])%mod;
		}
		res=(res%mod+mod)%mod;
	}
	for(int s=1;s<=U;s++)
		if((s&id(u))&&(s&id(v))) c[s]++;
	for(int s=1;s<=U;s++){
		if(pc[s]==1){ f[s]=g[s]=1; continue; }
		if(pc[s]-1>c[s]){ f[s]=g[s]=0; continue; }
		if(!(s&id(u))||!(s&id(v))) continue;
		f[s]=0; g[s]=pw[c[s]];
		for(int t=(s-1)&s;t;t=(t-1)&s){
			int r=s^t,z=c[s]-c[t]-c[r];
			if(t<r) add(f[s],1ll*f[t]*f[r]%mod*z%mod);
			if(t&lowbit(s)) sub(g[s],1ll*g[t]*pw[c[r]]%mod);
		}
		f[s]=1ll*f[s]*inv[pc[s]-1]%mod;
	}
	return res;
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>m; pw[0]=inv[0]=1; U=(1<<n)-1; pc[0]=0;
	for(int s=1;s<(1<<n);s++) pc[s]=pc[s^lowbit(s)]+1;
	for(int i=1;i<=m;i++) pw[i]=2ll*pw[i-1]%mod,inv[i]=qpow(i,mod-2);
	for(int i=1;i<=m;i++) cin>>e[i].u>>e[i].v>>e[i].w;
	sort(e+1,e+1+m); int ans=0;
	for(int i=0;i<n;i++) f[(1<<i)]=g[(1<<i)]=1;
	for(int i=1;i<=m;i++) add(ans,1ll*solve(e[i].u,e[i].v)*e[i].w%mod*pw[m-i]%mod);
	cout<<1ll*ans*qpow(qpow(2,m),mod-2)%mod<<endl; 
	return 0;
}
```

---

## 作者：EuphoricStar (赞：2)

考虑给你一个图，怎么算权值最大的好边集的权值。

类似 Kruskal 的贪心，把所有边按照边权从大到小排序。如果选当前边不会使得新连通块有两个环就可以选。

发现题目算的是和，考虑拆贡献，算每条边贡献的次数。

还是把所有边按照边权从大到小排序，然后枚举每条边。考虑具体有哪些情况使得这条边被选。设这条边两端点为 $u, v$。发现：

- 要么 $u, v$ 之前已经在同一个连通块，且这个连通块是一棵树；
- 要么 $u, v$ 之前不在同一个连通块，且 $u, v$ 所在连通块不能都有环。

只考虑之前的边。可以容斥 $O(3^n)$ 算出 $f_S$ 表示点集 $S$ 构成一个连通块的方案数，矩阵树定理 $O(2^n n^3)$ 算出 $h_S$ 表示点集 $S$ 构成一棵树的方案数。那么点集 $S$ 构成一个连通块且连通块内有环的方案数为 $g_S = f_S - h_S$。

那么第一种情况可以直接计算，第二种情况枚举 $u, v$ 之前所在连通块点集 $S, T$（显然 $S \cap T = \varnothing$），也可以直接计算。

总时间复杂度 $O((3^n + 2^n n^3)m)$，轻微卡常后可以通过。

```cpp
// Problem: P6789 寒妖王
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6789
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef __int128 lll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int mod = 998244353;

inline int qpow(int b, int p) {
	int res = 1;
	while (p) {
		if (p & 1) {
			res = 1LL * res * b % mod;
		}
		b = 1LL * b * b % mod;
		p >>= 1;
	}
	return res;
}

inline void fix(int &x) {
	x += ((x >> 31) & mod);
}

const int maxn = (1 << 15) + 50;

int n, m;
struct edge {
	int u, v, d;
} a[99];

int e[maxn], f[maxn], g[maxn], h[maxn], pw[99], b[19][19], id[19];

inline int det(int n) {
	int ans = 1;
	for (int i = 0; i < n - 1; ++i) {
		for (int j = i; j < n - 1; ++j) {
			if (b[j][i]) {
				if (j != i) {
					swap(b[j], b[i]);
					fix(ans = -ans);
				}
				break;
			}
		}
		if (!b[i][i]) {
			return 0;
		}
		ans = 1LL * ans * b[i][i] % mod;
		int t = qpow(b[i][i], mod - 2);
		for (int j = i; j < n - 1; ++j) {
			b[i][j] = 1LL * b[i][j] * t % mod;
		}
		for (int j = 0; j < n - 1; ++j) {
			if (i == j) {
				continue;
			}
			for (int k = i + 1; k < n - 1; ++k) {
				fix(b[j][k] -= 1LL * b[j][i] * b[i][k] % mod);
			}
		}
	}
	return ans;
}

int fa[99];

int find(int x) {
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

inline void merge(int x, int y) {
	x = find(x);
	y = find(y);
	if (x != y) {
		fa[x] = y;
	}
}

void solve() {
	scanf("%d%d", &n, &m);
	pw[0] = 1;
	for (int i = 1; i < 99; ++i) {
		pw[i] = pw[i - 1] * 2 % mod;
	}
	for (int i = 0; i < n; ++i) {
		fa[i] = i;
		h[1 << i] = 1;
	}
	for (int i = 1; i <= m; ++i) {
		scanf("%d%d%d", &a[i].u, &a[i].v, &a[i].d);
		--a[i].u;
		--a[i].v;
	}
	sort(a + 1, a + m + 1, [&](const edge &a, const edge &b) {
		return a.d > b.d;
	});
	int ans = 0;
	for (int k = 1; k <= m; ++k) {
		for (int S = 1; S < (1 << n); ++S) {
			if (__builtin_popcount(S) == 1) {
				f[S] = 1;
				continue;
			}
			f[S] = pw[e[S]];
			int s = S ^ lowbit(S);
			lll x = 0;
			for (int t = (s - 1) & s;; t = (t - 1) & s) {
				int T = t | lowbit(S);
				x += 1LL * f[T] * pw[e[S ^ T]];
				if (!t) {
					break;
				}
			}
			fix(f[S] -= x % mod);
		}
		for (int S = 1; S < (1 << n); ++S) {
			if (k == 1 || !((S & (1 << a[k - 1].u)) && (S & (1 << a[k - 1].v)))) {
				continue;
			}
			int tot = 0, lst = -1;
			bool fl = 1;
			for (int i = 0; i < n && fl; ++i) {
				if (S & (1 << i)) {
					id[i] = tot++;
					if (lst != -1) {
						fl &= (find(lst) == find(i));
					}
					lst = i;
				}
			}
			if (!fl) {
				continue;
			}
			mems(b, 0);
			for (int i = 1; i < k; ++i) {
				if ((S & (1 << a[i].u)) && (S & (1 << a[i].v))) {
					int u = id[a[i].u], v = id[a[i].v];
					fix(--b[u][v]);
					fix(--b[v][u]);
					fix(b[u][u] += 1 - mod);
					fix(b[v][v] += 1 - mod);
				}
			}
			h[S] = det(tot);
		}
		int res = 0;
		for (int S = 1; S < (1 << n); ++S) {
			fix(g[S] = f[S] - h[S]);
			if ((S & (1 << a[k].u)) && (S & (1 << a[k].v))) {
				fix(res += 1LL * h[S] * pw[e[(1 << n) - 1 - S]] % mod - mod);
			}
		}
		int U = (1 << n) - 1 - (1 << a[k].u) - (1 << a[k].v);
		lll x = 0;
		for (int s = U;; s = (s - 1) & U) {
			int S = s | (1 << a[k].u);
			int P = (1 << n) - 1 - (1 << a[k].v) - S;
			for (int t = P;; t = (t - 1) & P) {
				int T = t | (1 << a[k].v);
				x += (1LL * f[S] * f[T] - 1LL * g[S] * g[T]) * pw[e[(1 << n) - 1 - S - T]];
				if (!t) {
					break;
				}
			}
			if (!s) {
				break;
			}
		}
		fix(res += x % mod - mod);
		fix(ans += 1LL * res * pw[m - k] % mod * a[k].d % mod - mod);
		merge(a[k].u, a[k].v);
		for (int S = 1; S < (1 << n); ++S) {
			e[S] += ((S & (1 << a[k].u)) && (S & (1 << a[k].v)));
		}
	}
	ans = 1LL * ans * qpow(pw[m], mod - 2) % mod;
	printf("%d\n", ans);
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
```

---

## 作者：dAniel_lele (赞：2)

首先，显然有个贪心，从大到小排序，能塞就塞。

考虑对于每条边，计算它被选中的概率。

对于每条边，有两种情况：

* 两端连通，且所在连通块是一棵树。

考虑 $dp_S$ 表示 $S$ 集合连成一棵树且为极大连通块的方案数。枚举 $T_1,T_2$ 使得 $T_1\cup T_2=\emptyset$，$T_1\cap T_2=S$，$dp_S\leftarrow dp_{T_1}\times dp_{T_2}$。注意到每棵树被算了 $\operatorname{popcount}(S)-1$ 次，故还要除以 $\operatorname{popcount}(S)-1$。

* 两端不连通，且两端不同时已经成为基环树。

考虑容斥，计算一个子集连通的概率。考虑 $f_S$ 表示 $S$ 集合为极大连通块的方案数。容易使用经典的子集容斥，钦定 $\operatorname{lowbit}(S)$ 所在集合 $T$，钦定 $T$ 为极大连通块，剩余集合任意。

总复杂度 $O(m3^n)$，轻微卡常。

```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(i) (i&(-i))
#define mid ((l+r)>>1)
using namespace std;
const int mod=998244353,lim=8000000000000000000;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
void add(int &x,int y){
	x+=y;
	if(x>=mod) x-=mod;
}
int cnt[32768],f0[32768],g0[32768],f[32768],g[32768],pw2[32768],iv2[32768],C[20][20],n,inv[20];
int cnted[14348907],tnval[32768];
int calc(int u,int v,int precnt,int lststa){
	for(int i=1;i<(1<<n);i++) if((i&lststa)==lststa) g0[i]=pw2[cnt[i]];
	for(int i=1;i<(1<<n);i++){
		if((i&lststa)!=lststa) continue;
		g[i]=g0[i];
		if(__builtin_popcount(i)==1) continue;
		int lb=lowbit(i),S=i^lb;
		int ttot=0;
		for(int j=(S-1)&S;;j=(j-1)&S){
			ttot+=g[j|lb]*g0[i^(j|lb)];
			if(ttot>lim) ttot%=mod;
			if(!j) break;
		}
		add(g[i],mod-ttot%mod);
	}
	for(int i=1;i<=n;i++) f[1<<(i-1)]=1;
	int nval=0;
	for(int i=1;i<(1<<n);i++){
		if((i&lststa)!=lststa){
			nval+=tnval[i];
			continue;
		}
		if(__builtin_popcount(i)==1) continue;
		f[i]=0;
		for(int j=i&(i-1);j;j=(j-1)&i){
			nval++;
			f[i]+=f[j]*f[i^j]%mod*cnted[nval];
		}
		f[i]=(f[i]%mod*inv[__builtin_popcount(i)-1])%mod;
	}
	int S=(((1<<n)-1)^(1<<(u-1))^(1<<(v-1))),ans=0;
	for(int i=S;;i=(i-1)&S){
		(ans+=f[i|(1<<(u-1))|(1<<(v-1))]*pw2[cnt[S^i]])%=mod;
		if(!i) break;
	}
	for(int T=S;;T=(T-1)&S){
		int tmp=0;
		for(int R=T;;R=(R-1)&T){
			int p=R|(1<<(u-1)),q=(T^R)|(1<<(v-1));
			int tmppp=g[p]*f[q]+g[q]*f[p]-f[q]*f[p];
			tmppp%=mod;
			if(tmppp<0) tmppp+=mod;
			add(tmp,tmppp);
			if(!R) break;
		}
		add(ans,tmp*pw2[cnt[S^T]]%mod);
		if(!T) break;
	}
	for(int i=S;;i=(i-1)&S){
		cnt[i|(1<<(u-1))|(1<<(v-1))]++;
		if(!i) break;
	}
	nval=0;
	for(int i=1;i<(1<<n);i++){
		if((i&((1<<(u-1))|(1<<(v-1))))!=((1<<(u-1))|(1<<(v-1)))){
			nval+=tnval[i];
			continue;
		}
		if(__builtin_popcount(i)==1) continue;
		for(int j=i&(i-1);j;j=(j-1)&i){
			nval++;
			if((j>>(u-1))&((i^j)>>(v-1))&1) cnted[nval]++;
		}
	}
	return ans*iv2[precnt]%mod;
}
signed main(){
	pw2[0]=1; for(int i=1;i<=10000;i++) pw2[i]=pw2[i-1]*2%mod;
	iv2[0]=1; for(int i=1;i<=10000;i++) iv2[i]=iv2[i-1]*((mod+1)/2)%mod;
	for(int i=0;i<=15;i++) inv[i]=qp(i,mod-2);
	for(int i=0;i<=15;i++) C[i][0]=1;
	for(int i=1;i<=15;i++) for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	int m; cin>>n>>m;
	for(int i=1;i<(1<<n);i++){
		for(int j=i&(i-1);j;j=(j-1)&i){
			tnval[i]++;
		}
	}
	int ans=0;
	vector<pair<int,pair<int,int>>> vc;
	for(int i=1;i<=m;i++){
		int u,v,w; cin>>u>>v>>w;
		vc.push_back(make_pair(w,make_pair(u,v)));
	}
	sort(vc.begin(),vc.end()); reverse(vc.begin(),vc.end());
	for(int i=0;i<m;i++){
		int u=vc[i].second.first,v=vc[i].second.second,w=vc[i].first;
		int tpp=calc(u,v,i+1,(i==0)?0:((1<<(vc[i-1].second.first-1))|(1<<(vc[i-1].second.second-1))));
		(ans+=tpp*w)%=mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：CatFromMars (赞：1)

首先我们考虑如何计算一张图的最大基环树森林。对于一个联通块，Kruskal 第一次出现在同一个集合的边也加进去。现在考虑优化。考虑一条边在多少个场合下会被加进来（当然可能并没有这么严苛）。首先边从大到小排序，对于边 $(u, v)$ 能被加进来的充要条件是

1. $u, v$ 在同一个联通块，但是这个联通块是树。
2. $u, v$ 不在同一个联通块。

令人愉快的事情在于我们并不在乎边权只在乎形态了。

对这两种情况分别计数。注意到这还是很难，因为你很难将联通块的划分放到状态里面去。考虑钦定一个联通块，别的边任选，然后利用容斥等手法去重。考虑钦定 $u$ 所在的联通块集合为 $S$。$f[i,S]$ 为前 $i$ 条边 $S$ 内的点集构成一个联通块树的方案数，$g[i, S]$ 为前 $i$ 条边 $S$ 内的点集任意的方案数，$h[i, S]$ 为 $S$ 内的点构成联通图方案数。现在计算贡献，钦定 $u\in S$。考虑构造好 $u$ 所在的联通块。

如果 $v\in S$，那么贡献就是 $f[S]\times g[i, U - S]$。很容易理解。如果 $v\not \in S$ 否则就是 $g[i, U - S - T](f[i, S]\times h[i, T] + f[i, T]\times h[i, S] - f[i, T]f[i, S])$。请注意我们这里面计数的重心在于 **$u$ 所在的联通块**。

现在我们考虑 $f, h, g$ 的转移。

$g$ 没必要考虑，$h$ 就是简单的图联通计数约等于 P100982。

对于 $f[i, S]$ 划分成两个不交子集，需要考虑最后一次连边。每个形态都会被最后一条边计算，所以会被计算 $(\operatorname{popcount(S)} - 1)$ 次，要除以掉它。

代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int Mod = 998244353;
const int M = 60, N = 15;
inline int lowbit(int x) {
	return x & (-x);
}
int qpow(int n, int m) {
	int res = 1;
	while(m) {
		if(m & 1) res = 1ll * res * 1ll * n % Mod;
		n = 1ll * n * 1ll * n % Mod;
		m >>= 1;
	}
	return res;
}

struct node {
	int x, y, val;
} Q[M + 10];
bool cmp(node &x, node &y) {
	return x.val > y.val;
}

inline void upd(int &x, int y) {
	x = ((x + y >= Mod) ? (x + y - Mod) : (x + y));
}
int n, m;
int sum = 0, U;
int invf[M + 10], fac[M + 10], inv[M + 10];

int popc[(1 << N) + 10], bas2[M + 10];
int f[(1 << N) + 10], g[(1 << N) + 10], h[(1 << N) + 10];
void prep() {
	fac[0] = 1, bas2[0] = 1;
	for(int i = 1; i <= M; i++) {
		fac[i] = 1ll * fac[i - 1] * 1ll * i % Mod;
		bas2[i] = 2ll * bas2[i - 1] % Mod;
	}
	invf[M] = qpow(fac[M], Mod - 2);
	inv[M] = 1ll * invf[M] * 1ll * fac[M - 1] % Mod;
	for(int i = M - 1; i >= 0; i--) {
		invf[i] = 1ll * invf[i + 1] * (i + 1) % Mod;
		if(i >= 1) inv[i] = 1ll * invf[i] * fac[i - 1] % Mod;
	}
}
int calc(int u, int v) {
	int rest = 0;
	for(int S = 0; S < (1 << n); S++) {
		if(!((S >> u) & 1)) continue;
		if((S >> v) & 1) upd(rest, 1ll * f[S] * bas2[g[U - S]] % Mod);
		else {
			int B = U - S;
			for(int T = B; T; T = (T - 1) & B) {
				if(!((T >> v) & 1)) continue; 
				int r = (1ll * f[S] * h[T] % Mod + 
					1ll * f[T] * h[S] % Mod  - 
					1ll * f[T] * f[S] % Mod + Mod) % Mod;
				upd(rest, 1ll * bas2[g[U - S - T]] * r % Mod);
			}
		}
	}

	for(int S = 0; S < (1 << n); S++)
		if(((S >> u) & 1) && ((S >> v) & 1))
			g[S]++;

	for(int S = 1; S < (1 << n); S++) {
		if(!((S >> u) & 1) || !((S >> v) & 1) || popc[S] == 1) continue;
		if(popc[S] > g[S] + 1) {
			f[S] = h[S] = 0;
			continue;
		}
		h[S] = bas2[g[S]], f[S] = 0;
		for(int T = S; T; T = (T - 1) & S) {
			if(T == S) continue;
			const int W = S - T;
			if(W < T) upd(f[S], 1ll * (1ll * f[W] * f[T] % Mod) * (g[S] - g[T] - g[W]) % Mod);
			if((T & lowbit(S))) upd(h[S], 1ll * (Mod - 1ll * h[T] * bas2[g[W]] % Mod) % Mod);
		}
		f[S] = 1ll * f[S] * inv[popc[S] - 1] % Mod;
	}
	return rest;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	prep();
	cin >> n >> m;
	U = (1 << n) - 1;
	for(int S = 0; S < (1 << n); S++) {
		popc[S] = __builtin_popcount(S);
		g[S] = 0;
	}
	for(int i = 0; i < n; i++)
		f[(1 << i)] = h[(1 << i)] = 1;
	for(int i = 1; i <= m; i++)
		cin >> Q[i].x >> Q[i].y >> Q[i].val,
		Q[i].x--, Q[i].y--;
	sort(Q + 1, Q + m + 1, cmp);

	int ans = 0;
	for(int i = 1; i <= m; i++)
		upd(ans, (ll)(1ll * calc(Q[i].x, Q[i].y) * Q[i].val % Mod) * bas2[m - i] % Mod);
	cout << (1ll * ans * qpow(qpow(2, m), Mod - 2) % Mod) << endl;
}
```

---

## 作者：喵仔牛奶 (赞：1)

# Solution

定义 $U=\{1,2,3,\cdots,n\}$。

首先如果边确定的话有一个贪心：每次取出最大的边，可以加入就加入。

考虑不能加入边的情况：
- 在同一个连通块内，且连通块内已有环。
- 不同一个连通块内，且两个连通块内均已有环。

从大到小枚举边，求出 $(x,y)$ 不能加入的方案数。下文的图都指已经加入的边构成的图。

处理出 $g_S$ 表示 $S$ 连通导出子图个数，$h_S$ 表示 $S$ 生成树个数，$c_S$ 表示两段都在 $S$ 内的边数。前两者使用集合幂级数 exp 和 ln 即可求出。

考虑第一种情况，枚举所在的连通块 $S$，例题图有环相当于不是树，故方案为 $(g_S-h_S)\cdot2^{c_{U\backslash S}}$。

考虑第二种情况，这种情况对每个连通块都有一下限制：
- 不能同时包含 $x,y$。
- 如果包含了 $x$ 或 $y$，不能是树。

因此求出 $f_S$ 表示 $S$ 满足条件的连通导出子图数，exp 回去即可。

这样就求出不能加入的方案数，加入的概率乘边权求和即为答案。复杂度 $\mathcal O(mn^22^n)$。

应该有点卡常（虽然我的板子有点快，没卡常就过了）。

# Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
#define ppc(x) __builtin_popcount(x)
using namespace std;
namespace math { ... }
namespace Milkcat {
	using namespace math;
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 15, M = 1 << N, mod = 998244353;
	typedef mint<mod> MI;
	namespace SET {
		void exp(MI* f, MI* g, int n) { ... } // g=exp(f)
		void ln(MI* f, MI* g, int n) { ... } // g=ln(f)
	} // SPS
	int n, m, x, y, z, e[N], ct[M]; MI rs, pw[M], f[M], g[M], h[M];
	vector<tuple<int, int, int>> E;
	int main() {
		cin >> n >> m, pw[0] = 1;
		REP(i, 1, m) {
			cin >> x >> y >> z, E.pb(z, x - 1, y - 1);
			pw[i] = pw[i - 1] * 2;
		}
		fill_n(f, 1 << n, 1), m = (1 << n) - 1;
		sort(ALL(E), greater<>());
		for (auto [z, x, y] : E) {
			SET::ln(f, g, n), h[0] = 1;
			REP(i, 0, n - 1) {
				REP(S, 0, (1 << i) - 1)
					h[S | 1 << i] = h[S] * ppc(e[i] & S);  
				SET::exp(h + (1 << i), h + (1 << i), i);
			}
			MI sm = 0;
			REP(S, 0, m) {
				if (!(S >> x & 1) || !(S >> y & 1)) continue;
				sm += (g[S] - h[S]) * pw[ct[S ^ m]], ct[S] ++, f[S] *= 2; 
			}
			REP(S, 0, m) {
				int p = (S >> x & 1), q = (S >> y & 1);
				if (p && q) { g[S] = 0; continue; }
				if (p || q) g[S] -= h[S];
			}
			SET::exp(g, g, n);
			rs += (pw[ct[m] - 1] - sm - g[m]) * z / pw[ct[m]];
			e[x] |= 1 << y, e[y] |= 1 << x;
		}
		cout << rs << '\n';
		return 0;
	}
}
int main() {
	cin.tie(0)->sync_with_stdio(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

---


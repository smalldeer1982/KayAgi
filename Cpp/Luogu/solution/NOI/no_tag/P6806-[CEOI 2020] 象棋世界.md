# [CEOI 2020] 象棋世界

## 题目背景

1.3s，64MB

## 题目描述

象棋世界是一个 $R$ 行 $C$ 列的棋盘，其中 $R \geq C$。所有的行依此编号为 $1$ 到 $R$，所有的列依此编号为 $1$ 到 $C$。

在象棋世界里，共有五种棋子：兵，车，象，后，王。与现实世界不同的是，骑士精神在象棋世界中已经死亡，因此象棋世界里找不到马。

象棋世界里，每种棋子可以按如下规则进行一步移动：

- 兵只能向行号增大的方向走一步（从第 $r$ 行到第 $r+1$ 行），且其所处的列不变。
- 车只能沿水平方向或竖直方向移动。
- 象只能沿对角线方向移动。
- 后可以沿水平方向，竖直方向，或对角线方向移动。
- 王可以向与之相邻的八个格子移动。

为了方便你理解，我们在下图给出了每种棋子的合法移动范围。其中 X 代表该棋子能移动到的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/wgweh8tf.png)

最近一段时间，象棋世界发生了不少诡异的事情：某些棋子可能会被不明来源的力量所劫持，随后从象棋世界中消失。在这种情况下，所有棋子都希望能尽快前往他们想要到达的目的地，他们还想知道，在走的步数最少的前提下，到达目的地的方案数有多少。两种方案是不同的，当且仅当这两种方案中有一步经过的格子不同。

在本题中，你需要解决下面这个问题：某个棋子将从第 $1$ 行的第 $c_1$ 列出发，到达第 $R$ 行的第 $c_R$ 列。现在给出这个棋子的类型，以及 $c_1,c_R$ 的值，你需要求出，这个棋子最少需要走多少步，以及在步数最少的前提下，行走方案有多少种。

## 说明/提示

所有测试点均满足：$1 \leq Q \leq 1000$，$2 \leq C \leq 1000$，$C \leq R \leq 10^9$，$T \in \{\texttt{P},\texttt{R},\texttt{Q},\texttt{B},\texttt{K}\}$，$1 \leq c_1,c_R \leq C$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                         |
| ---------- | ---- | -------------------------------------------- |
| $1$        | $0$  | 样例                                         |
| $2$        | $8$  | $T \in \{\texttt{P},\texttt{R},\texttt{Q}\}$ |
| $3$        | $15$ | $T=\texttt{B}$，$C,R \leq 100$               |
| $4$        | $22$ | $T=\texttt{B}$                               |
| $5$        | $5$  | $T=\texttt{K}$，$C,R \leq 100$，$Q \leq 50$  |
| $6$        | $8$  | $T=\texttt{K}$，$C,R \leq 100$               |
| $7$        | $15$ | $T=\texttt{K}$，$C \leq 100$                 |
| $8$        | $20$ | $T=\texttt{K}$                               |
| $9$        | $7$  | 无特殊约束                                   |

## 样例 #1

### 输入

```
8 8 5
P 1 2
R 4 8
Q 2 3
B 3 6
K 5 5```

### 输出

```
0 0
2 2
2 5
2 2
7 393```

# 题解

## 作者：yyyyxh (赞：10)

大家 K 的 Case 其实有点推麻烦了，其实最难的是 B？

+ P：判一下是不是 $c_1=c_r$ 就行了。否则无解。

+ R：同上。否则需要走两步，有两种走法。

+ Q：注意到答案不超过 2 所以只有一些分讨，但比想象的情况多，比如你需要考虑 $n=m$ 的时候，Q 可以先走到某一个角落然后斜着一步走到。一种比较好的方法是直接做 $O(1)$ 条一次函数暴力分讨交点。

然后对于 B 来说，为了保证你的跳跃次数尽可能少，你每一次一定跳得尽量极端，除非你下一步可以直达终点。

所以先模拟求出最短路径形态：我们枚举第一次跳跃的方向，然后不断跳极端，找到在你这条路径上第一个 $x\geq n,y=c_R$ 的位置作为暂定终点。

然后考虑再在上面调整，每一次可以让一个拐角少走一步，终点向下平移两步。那么这就是一个插板的组合数。

对于 K 来说，由于 $R\geq C$，然后你每次最多往上一行，所以你一定恰好走 $R-1$ 步。

于是你需要计算一个“两条线问题”：从 $(1,c_1)$ 游走到 $(R,c_R)$，不能触碰 $x=0$ 和 $x=C+1$ 两条线的方案数。

这是[这道题](https://www.luogu.com.cn/problem/P9366)的一维情况。这很经典，你施加反射容斥，然后你只需要考虑计算到达横坐标 $\equiv \pm c_R \pmod {2C+2}$ 的点的方案数。

这相当于计算 $(x+\frac{1}{x}+1)^{R-1}$ 在 $\bmod (x^{2C+2}-1)$ 循环卷积意义下的结果。这道题没有 NTT 模数所以你不得不暴力卷积得到 $O(n^2 \log n)$ 的复杂度。~~才不写 MTT 呢。~~

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
using namespace std;
int read(){
	char c=getchar();int x=0;
	while(!isdigit(c)) c=getchar();
	do x=(x<<1)+(x<<3)+(c^48),c=getchar();
	while(isdigit(c));
	return x;
}
const int N=1003,P=1000000007;
int n,m,q,lim;
typedef long long ll;
int qp(int a,int b=P-2){
	int res=1;
	while(b){
		if(b&1) res=(ll)res*a%P;
		a=(ll)a*a%P;b>>=1;
	}
	return res;
}
struct Poly{
	int f[N<<1];
	friend Poly operator*(const Poly x,const Poly y){
		Poly z;
		for(int i=0;i<lim;++i) z.f[i]=0;
		for(int i=0;i<lim;++i)
			for(int j=0;j<lim;++j){
				int t=i+j;
				if(t>=lim) t-=lim;
				z.f[t]=(z.f[t]+(ll)x.f[i]*y.f[j])%P;
			}
		return z;
	}
}F,G;
int fac[N],fiv[N];
int C(int a,int b){
	int res=fiv[b];
	for(int i=0;i<b;++i) res=(ll)res*(a-i)%P;
	return res;
}
void solve(){
	char c=getchar();
	while(!isupper(c)) c=getchar();
	int x=read(),y=read();
	if(c=='P'){
		if(x!=y) puts("0 0");
		else printf("%d 1\n",n-1);
		return;
	}
	if(c=='R'){
		if(x==y) puts("1 1");
		else puts("2 2");
		return;
	}
	if(c=='Q'){
		if(n==m&&((x==1&&y==m)||(x==m&&y==1))) puts("1 1");
		else if(x==y) puts("1 1");
		else{
			int res=4;
			if((x^y^n)&1){
				if(x+y+n-1<=m+m) ++res;
				if(x+y-n+1>=2) ++res;
			}
			if(n==m){
				if(x==1||x==m) ++res;
				if(y==1||y==m) ++res;
			}
			printf("2 %d\n",res);
		}
		return;
	}
	if(c=='K'){
		int a=(y-x+lim)%lim;
		int b=(-x-y+lim)%lim;
		int res=F.f[a]-F.f[b];
		if(res<0) res+=P;
		printf("%d %d\n",n-1,res);
		return;
	}
	if(c=='B'){
		if((x^y^n)&1){
			int p,ps,gap=2*(m-1);
			int tt,res=0x3f3f3f3f,cnt=0;
			for(int op=0;op<2;++op){
				if(op){ps=1;p=x;}
				else{ps=m;p=m-x+1;}
				int tmp=(n-p)/gap;
				tt=tmp*2;p+=gap*tmp;
				while(p<n||ps!=y){
					++tt;
					if(ps==1){
						if(p+y-1>=n){p+=y-1;break;}
						p+=m-1;ps=m;
						continue;
					}
					if(ps==m){
						if(p+m-y>=n){p+=m-y;break;}
						p+=m-1;ps=1;
						continue;
					}
				}
				if(res>tt) res=tt,cnt=0;
				if(res==tt){
					int d=(p-n)>>1;
					cnt+=C(d+tt-1,d);
					if(cnt>=P) cnt-=P;
				}
			}
			printf("%d %d\n",res+1,cnt);
		}
		else puts("0 0");
		return;
	}
}
int main(){
	n=read();m=read();q=read();lim=(m+1)<<1;
	for(int i=0;i<lim;++i) F.f[i]=G.f[i]=0;
	F.f[0]=G.f[0]=G.f[1]=G.f[lim-1]=1;
	fac[0]=1;
	for(int i=1;i<=m;++i) fac[i]=(ll)fac[i-1]*i%P;
	fiv[m]=qp(fac[m]);
	for(int i=m;i;--i) fiv[i-1]=(ll)fiv[i]*i%P;
	int ex=n-1;
	while(ex){
		if(ex&1) F=F*G;
		G=G*G;ex>>=1;
	}
	while(q--) solve();
	return 0;
}
```

---

## 作者：feecle6418 (赞：9)

我不会做题，我只是英文题解的翻译工

------

以下认为 $n=R,m=C$。

我们只解决 K 的情况，因为其他题解已经把另外几个说得很详细了。

首先，因为 $n\ge m$，第一问答案一定是 $n-1$。

既然第一问答案一定是 $n-1$，那每一步一定要么向右，要么向右上，要么向右下。可以写出朴素 dp，设 $f_{i,S,j}$ 为 $(1,S)$ 走到 $(i,j)$ 的方案数：

$$
f_{i,S,j}=\left\{
\begin{aligned}
f_{i-1,S,j-1}+f_{i-1,S,j}+f_{i-1,S,j+1}\ (1<j<m)
\\
f_{i-1,S,j}+f_{i-1,S,j+1}\ (j=1)
\\
f_{i-1,S,j}+f_{i-1,S,j-1}\ (j=m)
\end{aligned}
\right.
$$

矩阵快速幂优化 dp 即可通过 $m\le 100$ 的测试点。

注意到瓶颈在于矩阵乘法，考虑优化矩阵乘法。

又注意到矩阵快速幂时本质上只用到了以下两种乘法：

$$A^n\to A^{n+1},A^n\to A^{2n}$$

只需分别优化。第一种显然可以 $O(m^2)$ 搞定，因为 $A$ 中有值的只有 $O(m)$ 项。问题在于第二种。

观察发现以下几个结论：

1. 任意 $n$，$A^n_{i,j}=A^n_{j,i}$（显然）
2. 任意 $n$，$A^n_{i,j}=A^n_{m-j+1,m-i+1}$（显然）
3. 任意 $n$，若 $i+j-1\le m$，则 $A^n_{i,j}=A^n_{i-1,j-1}+A^n_{1,i+j-1}$

假如结论都成立，那我们只用求出 $A^{2n}$ 的第一行、第一列，就可以直接递推出整个矩阵了。这样，$A^n\to A^{2n}$ 的变换可以 $O(m^2)$ 完成，整个题也就可以 $O(m^2\log n+q)$ 解决了。怎么证明第三条结论呢？

考虑归纳法，先证明 $i=2$ 成立：

因为 $A^{n+1}_{1,i}=A^{n+1}_{i,1}$，所以 $A^n_{1,i-1}+A^n_{1,i}+A^n_{1,i+1}=A^n_{i,1}+A^n_{i,2}$。

又因为 $A^n_{1,i}=A^n_{i,1}$，所以 $A^n_{i,2}=A^n_{1,i-1}+A^n_{1,i+1}=A^n_{i-1,1}+A^n_{1,i+1}$。

然后证明 $i$ 成立推出 $i+1$ 成立，过程和上面类似，对 $A^{n+1}_{i,j}$ 算两次即可，留作习题。

---

## 作者：s_r_f (赞：8)

[我的CEOI作战记录&题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ceoi2020-zuo-zhan-ji-lu-ti-xie-shi-gong-zhong-post)

[我的CEOI作战记录&题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13581895.html)

---

这道题分为三个不同的子任务.

### subtask1 : $T = 'P'/'R'/'Q'$

这个部分直接暴力即可,注意 $T = 'Q'$ 的部分有一点细节.

---

### subtask2 : $T = 'B'$

首先先判掉 $1+R+c1+cr$ 是奇数的情况 . 这样的情况必然无解 .

枚举第一步是往左走然后往右走,然后贪心的往下跳,每一步都撞到边界,直到当前坐标 $(x,y)$ 满足 $x\geq R,y=cr$ 

那么我们就求出了最优的步数。

方案数实际上就是考虑，记 $d=\frac{x-R}{2}$ , $t$ 为转弯的次数,即步数 $-1.$

然后相当于在每个转弯的地方我可以缩进去一些距离 ，这些距离的和为 d ，那么这就是一个经典组合问题 , 答案为 $\binom{t+d-1}{d}$.

因为 d 是多出来的距离 , 不会超过 $O(C)$ 级别 , 但是 t 是 $O(\frac{R}{C})$ 的 , 可能很大 , 所以我们使用 $O(C)$ 的方法求组合数 .

那么就能做到每组询问 $O(C)$ 查询了 .

---

### subtask3 : $T = 'K'$

**一个 $O((C+Q)C^2 + Q \times C \log C \log R)$ 做法**

 $O(C^3)$ 暴力dp,然后使用 $O(Q)$ 次BM算法求出递推式,总复杂度 $O((C+Q)C^2)$ ，每次查询使用[【模板】常系数齐次线性递推](https://www.luogu.com.cn/problem/P4723)的科技来查询答案.

**优化1:减少跑BM的次数**

因为特征多项式 $F$ 只有一个,并且只要求 $x^R$ 对 $F$ 取模的结果,并且 $R$ 是一个定值,所以可以先 $O(C^2\log R)$ 或 $O(C^2+C \log C \log R)$ 的复杂度求出取模之后的多项式,查询的时候直接 $O(C)$ 就可以了.

复杂度上线性递推部分少了一个 $O(C)$ $,$不过还是需要 $O(C^3)$ 的暴力DP,所以复杂度实际上并没有变优.

**优化2:优化掉暴力DP的 $O(C^3)$**

因为前 $C$ 步**不可能上下同时越界**$,$所以就分别容斥掉越上界/下界的情况就可以了.需要 $O(C^2)$ DP一下容斥的结果,然后就可以支持 $O(1)$ 查询暴力 DP 的结果了.

那么查询还是 $O(C)$ ,不过预处理的复杂度从 $O(C^3)$ 降到了 $O(C^2)$ 

**优化3:优化求特征多项式的复杂度**

特征多项式 $F_C=(λ-1)F_{C-1}-F_{C-2},$ 所以可以 $O(C^2)$ 直接计算,不需要使用BM了.

并且可以发现,把 $n$ 个单位根的点值带进去,然后IDFT,就可以直接获得所求多项式的系数,复杂度 $O(C\log C).$ 

如果使用线性递推的科技,可以获得 $O(C^2 + C \log C \log R)-O(C)$ 的复杂度.

**优化4:进一步优化暴力DP解的计算/预处理**

EI 对暴力 DP的解解出了一个封闭形式.

理论上可以优化到$O(C \log C\log R)-O(C)$ [大家快来膜EI](https://codeforces.com/blog/entry/82022#comment-687991)

---

我写的是不用NTT的做法,是 $O(C^2 \log R)-O(C)$ 的.


代码 : [见云剪贴板](https://www.luogu.com.cn/paste/ikx79npi)

---

## 作者：zzw4257 (赞：4)

写个详细的流程

![img](https://cdn.luogu.com.cn/upload/image_hosting/wgweh8tf.png)

### $\mathrm{P,R,Q}$

- $P$

  那么$ans1$为$\begin{cases}R-1&c_1=c_R\\0&c_1\neq c_R\end{cases}$

  $ans2$为$0~\text{or}~1$

- $R$

  那么分

  1. $c_1=c_R$,$ans1=1,ans2=1$
  2. $c1\neq c_R$,$ans1=2,ans2=2$

- $Q$

  1. $c_1=c_R~\text{or}~ \Delta x=\Delta y$,$ans1=1,ans2=1$

  2. $\text{otherwise}$,$ans1=2$

     $ans2$分为$3$类

     首先前提$\Delta x\geqslant C-1\geqslant \Delta y$

     (我认为列是水平的...)

     - 永远可以走两边对角线卡在水平方向界线上，横竖也可以分开走,$4$个

     - 交点看可不可以走$2$个

     - 最后看可不可以卡在竖直方向界线上只可能有一边,具体的检查$n=m$与一个点在角上

### $B$

首先贪心策略很好想出

我们先定开头方向一直触线到直到$Y_0=c_R,X_0\geqslant R$的位置

~~这个位置算起来很烦~~

设$d=X_0-R$,则我们会把一些角陷下去共$\frac{d}{2}$,隔板一下，具体的是盒子不同且可空

>关于*陷下去*，插播一下，因为$\frac{d}{2}\leqslant m-1$所以在中间陷下去不会有问题，开头可能会陷下去但这样另一个方向一定不会陷下去故再比$ans1$的时候这边不会被选中

所以$\displaystyle ans2= \binom{t+\frac{d}{2}-1}{\frac{d}{2}}$

### $K$

#### 法一

~~等会儿~~来复习一下线性代数中的零化多项式相关

首先给出结论

>假设我们得出了$\mathbf A$矩阵的特征多项式$f_A(\lambda)$(下面的函数定义域包含矩阵)
>
>其中$f_\mathbf A(\lambda)=\det \lambda \mathbf I-\mathbf A$
>
>令$g=\mathbf \lambda^k \mod f_A$
>
>则有$\mathbf A^k=\displaystyle g(\mathbf A)=\sum_{i=0}^{|A|}g_iA^i$

这个表述可能有点糟...

把$\lambda I-\mathbf A$列出来
$$
\begin{bmatrix}
\lambda-1&-1&0&0&\cdots&0\\
-1&\lambda-1&-1&0&\cdots& 0\\
0&-1&\lambda-1&-1&\cdots& 0\\
&&\cdots\\
0&\cdots&-1&\lambda-1&-1& 0\\
0&\cdots&0&-1&\lambda-1&-1\\
0&\cdots&0&0&-1&\lambda-1
\end{bmatrix}
$$
利用行列式展开的原理$\det \mathbf M=\sum\limits_{j=1}^{|\mathbf M|}(-1)^{i+j}\det \mathbf M_{i,j}$

就是任选一行求带权的代数余子式之和

对本题，矩阵的$m$阶主子式是有相似结构的

设$f_m(\lambda)$表示$m$阶转移矩阵的特征多项式
$$
f_m(\lambda)=(\lambda-1)f_{m-1}(\lambda)-f_{m-2}(\lambda)
$$
关于$f_{m-2}$其实是拆了两层，最后一层剩一个右下角直接搞掉

所以我们可以$\mathcal O(m^2)$求$f_m$

加上结论所以我们只需要求$A^{0\to m}$的对位和然后直接就可以算$A^{n-1}$了

这个算法就是转为实际意义，变为可以向右/右上/右下走**不经过**上下$0/m+1$边界从$(1,X)$到$(n,Y)$的方案数

我们考虑$\mathcal O(3m^2)dp$出$w'_{x,y}$意义类似表示$(1,x)\to (n,y)$但可以过边界的走法，于是我们要求的$w_{x,y}$就用最简单的折线法，建立终点内外的双射做一层容斥即可,原因是不可能跨两边

但这样为了求出每个$A^i_{x,y}$依然是$\mathcal O(m^3)~\text{or}~\mathcal O(qm)$的(其实够了...)，但我们只用求每个$x,y$的每个次幂的按位和，又注意到$f_{x,y}$只跟$|y-x|$有关，所以每个位置只被一种长度贡献，因此对每个长度$x-y$处理$w$头上带的系数贡献(注意并不是只把$x,y\to x+y$,容斥的两个也要),就可以$\mathcal O(m^2)$预处理，$\mathcal O(1)$询问了

---

## 作者：Kevin090228 (赞：2)

## P6806 [CEOI2020] 象棋世界 / ABC309Ex Simple Path Counting Problem

#### 碎碎念

AtCoder 最近好喜欢出加强版毒瘤多项式题。吐了。

虽然说象棋世界这个题不止 King 这一种情况，但是其他情况比较朴素，其他博客里也提到了，就二合一直接写了。并且算法五似乎在其他博客里面并没有提到？

P6806 的 $r,c$ 对应了 ABC309Ex 的 $n,m$，这里统一使用 $n,m$ 表示。

#### 算法一

使用 $O(m^3)$ 的时间暴力做一个 DP。

转移矩阵的特征矩阵形式如下：
$$
\left[\begin{matrix}\lambda-1 & -1 & 0 & \cdots & 0\\ -1 & \lambda-1 & -1 & \cdots & 0\\ 0 & -1 &\lambda -1 & \cdots & 0\\ \vdots &\vdots &\vdots &\ddots & \vdots\\0 & \cdots & -1 & \lambda -1 & -1\\ 0 & \cdots & 0 & -1 & \lambda-1\end{matrix}\right]
$$
直接考察行列式定义就能发现，这个东西的特征多项式 $F_n$ 满足 $F_n=(\lambda-1)F_{n-1}-F_{n-2}$。

这样我们可以 $O(m^2)$ 的时间求出特征多项式，结合暴力 DP 的表做线性递推，就能得到一个询问的值了。

时间复杂度 $O(m^3)-O(m\log m\log n)$。

#### 算法二

注意到可以先提前多项式取模好，最后查询的时候只用处理一个点乘即可。

时间复杂度 $O(m^3+m\log m\log n)-O(m)$。

#### 算法三

注意到在前 $m$ 行你没有办法既超出上边界又超出下边界，所以就可以对 DP 进行一手容斥。

时间复杂度 $O(m^2+m\log m\log n)-O(m)$。

#### 算法四

[EI 的 Comment](https://codeforces.com/blog/entry/82022#comment-687991)。

这个做法很复杂啊！

#### 算法五

和前三个算法不太相关。

不能直接每次乘 $(x^{-1}+1+x)$ 的原因，是你会把 $(*,0)$ 和 $(*,m+1)$ 的 DP 值也考虑进来，这是不合法的。所以我们期望使 $(*,0)$ 和 $(*,m+1)$ 的 DP 值始终为 $0$。

考虑将 DP 表格看成一个圆柱，将原来的 DP 表格贴在圆柱一半侧面上，另一半侧面对称的贴一个相同的 DP 表，只不过这里所有的 DP 值是原表格中对应位取相反数。这时，$(*,0)$ 和 $(*,m+1)$ 对应的地方，也就是两半 DP 表的交点，一定是对称的两个互为相反数的数相加，互相抵消，就一定为 $0$ 了。

这样只要写一个多项式快速幂，每次乘法之后对 $x^{2m+2}-1$ 取模即可。

时间复杂度 $O(m\log m\log n)-O(1)$。

算法五也可以非常好的修改到 ABC 那个题上面。时间复杂度 $O(m\log m\log n)$。

---

## 作者：UKE_Automation (赞：1)

### P6806/CF1403C [CEOI2020] 象棋世界/Chess Rush

[$\text{Luogu\ Link}$](https://www.luogu.com.cn/problem/P6806)

[$\text{CF\ Link}$](https://codeforces.com/problemset/problem/1403/C)

拼好题，把 $5$ 个部分都做一遍就行。

- 兵 $\text P$：

  如果 $c_1=c_R$ 则可以走到，步数 $n-1$，方案只有一种；否则无解。

- 车 $\text R$：

  如果 $c_1=c_R$ 则一步走到，否则两步走到。方案只有一种。

- 后 $\text{Q}$：

  如果在同一条斜线上则一步走到，方案为 $1$；否则，有以下四种走法：斜-纵、横-斜、斜-斜、横-纵，步数均为两步，按照棋盘范围判断能不能这样走即可。注意每种走法实际有两种顺序，所以最后要乘 $2$。

前面三种情况都是 trivial 的，后面两个比较难一点。

- 象 $\text B$：

  先判断一下是否有解，看 $n-c_R+c_1$ 奇偶性即可。

  首先象的最优策略就是不断撞墙然后反弹出去，直到最后一步可以直接走到就停止，于是步数我们可以直接求出。接下来要进行计数，直接算比较困难，考虑先弱化条件，我们不考虑最后一步可以直接走到，就一直按照撞墙反弹的路线走，然后记第一次走到终点正上方的某个格子为 $(x,y)$。

  如此我们需要将终点向下挪动 $y-n$ 格，考虑怎样才能挪动终点，实际上就是我们每个拐点可以不撞墙，而是选择向内缩，每有一个拐点向内缩一格终点就会下降两格。所以令 $d=\tfrac{y-n}{2}$，$t$ 为拐点个数，根据经典插板法结论，这个的方案数就是：
  $$
  \binom{t+d-1}{t-1}
  $$
  但是 $t-1$ 的大小是 $O(n)$ 级的，复杂度无法接受。显然我们可以把 $t-1$ 换成 $d$，这样暴力求解组合数的复杂度就是 $O(m)$ 的了。

- 王 $\text K$：

  这一部分是最难的部分。首先发现王走的步数一定是 $n-1$，这就告诉我们王的决策只有上、左上、右上三种。于是设 $dp(i,j)$ 表示王走到 $(i,j)$ 的方案数，就有一个简单的 dp 方程：
  $$
  dp(i,j)=
  \begin{cases}
  dp(i-1,j-1)+dp(i-1,j)+dp(i-1,j+1)&1<j<m\\
  dp(i-1,j-1)+dp(i-1,j)&j=m\\
  dp(i-1,j)+dp(i-1,j+1)&j=1
  \end{cases}
  $$
  直接矩阵快速幂就可以做到 $O(m^3\log n)$ 预处理转移矩阵，然后每次询问就是 $O(1)$ 的。不过这个复杂度还是太高，观察到瓶颈在于矩阵乘法，所以考虑对其进行优化。

  令单次转移矩阵为 $A$，则矩阵快速幂的操作可以看作只有 $\times A$ 和求二次方。前者容易优化，因为 $A$ 有值的位置只有 $O(m)$ 个，只考虑它们即可，复杂度可以做到 $O(m^2)$。然后是后面一部分，这里需要我们观察出 $A$ 矩阵的一些性质：

  - $A_{i,j}^n =A_{j,i}^n$，$A_{i,j}^n=A_{m-j+1,m-i+1}^n$。这告诉我们 $A^n$ 永远是关于两条对角线对称的，证明显然，因为 $A$ 本身就满足这个性质。

  - $A_{i,j}^n=A_{i-1,j-1}^n+A_{1,i+j-1}^n(i+j-1\le m)$。

    这个性质比较难看出，可以认为它建立了一个矩阵元素间的递推关系。

    考虑证明，采用归纳法，首先 $j=1$ 显然成立，考虑从 $j\to j+1$ 的过程。首先根据性质 $1$ 可知 $A_{i,j}^n=A_{j,i}^n$。所以有：
    $$
    A_{i,j}^{n+1}=A_{j,i}^{n+1}\Rightarrow A_{i,j-1}^n+A_{i,j}^n+A_{i,j+1}^n=A_{j,i-1}^n+A_{j,i}^n+A_{j,i+1}^n
    $$
    消掉 $A_{i,j}^n$ 与 $A_{j,i}^n$ 并移项可得 $A_{i,j+1}^n=A_{j,i-1}^n+A_{j,i+1}^n-A_{i,j-1}^n=A_{i-1,j}^n+A_{i+1,j}^n-A_{i,j-1}^n$。由于对于 $j$ 来说 $A_{i,j}^n=A_{i-1,j-1}^n+A_{1,i+j-1}^n$ 成立，所以将 $A_{i+1,j}^n$ 换掉可得：
    $$
    A_{i,j+1}^n=A_{i-1,j}^n+A_{i+1,j}^n-A_{i,j-1}^n=A_{i-1,j}^n+A_{i,j-1}^n+A_{1,i+j}^n-A_{i,j-1}^n=A_{i-1,j}^n+A_{1,i+j}^n
    $$
    于是我们就证明了这个结论。

  根据这些性质我们发现，只要知道了这个矩阵的第一行就能递推求出下面的元素，所以第二部分的复杂度也可以优化到 $O(m^2)$。所以预处理转移矩阵的复杂度就是 $O(m^2\log n)$ 的了。

综上，我们就可以在 $O(m^2\log n +qm)$ 的复杂度内解决这个问题。

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int Maxn = 2e5 + 5;
const int Inf = 2e9;
const int Mod = 1e9 + 7;

int add(int x, int y) {return x + y >= Mod ? x + y - Mod : x + y;}
int del(int x, int y) {return x - y < 0 ? x - y + Mod : x - y;}

int n, m, T;
int inv[Maxn];

struct Mat {
	int a[1005][1005];
	Mat() {for(int i = 1; i <= m; i++) for(int j = 1; j <= m; j++) a[i][j] = 0;}
	int* operator [] (int x) {return a[x];}
}M;

Mat add(Mat a) {
	Mat res;
	for(int i = 1; i <= m; i++) {
		for(int j = 1; j <= m; j++) {
			res[i][j] = add(a[i][j], add(a[i][j - 1], a[i][j + 1]));
		}
	}
	return res;
}

Mat mul(Mat a) {
	Mat res;
	for(int i = 1; i <= m; i++) {
		for(int j = 1; j <= m; j++) {
			res[1][i] = add(res[1][i], 1ll * a[1][j] * a[j][i] % Mod);
		}
		res[i][1] = res[1][i];
	}
	for(int i = 2; i <= m; i++) {
		for(int j = 2; j <= m; j++) {
			if(i + j - 1 <= m) res[i][j] = add(res[i - 1][j - 1], res[1][i + j - 1]);
			else res[i][j] = res[m - j + 1][m - i + 1];
		}
	}
	return res;
}

void init() {
	inv[1] = 1;
	for(int i = 2; i <= 10000; i++) {
		inv[i] = Mod - 1ll * inv[Mod % i] * (Mod / i) % Mod;
	}
	for(int i = 1; i <= m; i++) M[i][i] = 1;
	for(int i = 31; i >= 0; i--) {
		M = mul(M);
		if(((n - 1) >> i) & 1) M = add(M);
	}
}

void workP(int c1, int c2) {
	if(c1 == c2) cout << n - 1 << " " << 1 << '\n';
	else cout << "0 0\n";
}

void workR(int c1, int c2) {
	if(c1 == c2) cout << "1 1\n";
	else cout << "2 2\n";
}

#define pii pair<int, int>
#define mk make_pair

int C(int n, int m) {
	if(n < m || n < 0 || m < 0) return 1;
	int mul = 1;
	for(int i = 1; i <= m; i++) {
		mul = 1ll * mul * (n - i + 1) % Mod * inv[m - i + 1] % Mod;
	}
	return mul;
}

pii solve(int c1, int c2, int opt, int pos) {
	int num = (n - pos) / (m - 1);
	int fin = opt ^ (num & 1), h = pos + num * (m - 1);
	int dx = abs(c2 - (1 + fin * (m - 1))), dy = n - h, d = 0;
	if(dy <= dx) {
		num++; d = dx - dy;
		if(dx == dy && dx == 0) num--;
	}
	else {
		num += 2; d = 2 * m - dx - dy - 2;
	}
	d >>= 1; 
	return mk(num + 1, C(d + num - 1, d));
}

void workB(int c1, int c2) {
	if(((n - c2 + c1) & 1) == 0) {
		cout << "0 0\n"; return ;
	}
	int posr = m - c1 + 1, posl = c1;
	pii res1 = solve(c1, c2, 1, posr), res2 = solve(c1, c2, 0, posl);
	if(res1.first < res2.first) cout << res1.first << " " << res1.second << '\n';
	else if(res1.first > res2.first) cout << res2.first << " " << res2.second << '\n';
	else cout << res1.first << " " << add(res1.second, res2.second) << '\n';
}

void workQ(int c1, int c2) {
	if(c2 - c1 == n - 1 || c1 == c2) cout << "1 1\n";
	else {
		int res = 4;
		if(c2 - n + 1 > 0) res++;
		if(c1 + n - 1 <= m) res++;
		if((n - c2 + c1) & 1) {
			int num = (n - c2 + c1) / 2;
			if(c1 - num > 0) res++;
			if(c2 + num <= m) res++;		
		}
		cout << "2 " << res << '\n'; 
	}
}

void workK(int c1, int c2) {
	cout << n - 1 << " " << M[c2][c1] << '\n';
}

void solve() {
	char opt; int c1, c2;
	cin >> opt >> c1 >> c2;
	if(c1 > c2) swap(c1, c2);
	switch(opt) {
		case 'P': {workP(c1, c2); break;}
		case 'R': {workR(c1, c2); break;}
		case 'B': {workB(c1, c2); break;}
		case 'Q': {workQ(c1, c2); break;}
		case 'K': {workK(c1, c2); break;}
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m >> T;
	init();
	while(T--) solve();
	return 0;
}
```

---


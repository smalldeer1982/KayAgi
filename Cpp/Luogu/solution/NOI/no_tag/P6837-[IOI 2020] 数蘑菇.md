# [IOI 2020] 数蘑菇

## 题目描述

研究蘑菇的专家安德鲁在研究新加坡的本地蘑菇。

作为研究的一部分，安德鲁采集了 $n$ 个蘑菇，编号为 $0$ 到 $n-1$。每个蘑菇均为两种蘑菇种类之⼀，称为 $A$ 或 $B$。

安德鲁知道 **蘑菇 $0$ 属于种类 $A$**, 但是由于这两种蘑菇看起来很相似，他不知道蘑菇 $1$ 到 $n-1$ 属于哪一种。

幸运的是，安德鲁的实验室里有一台机器可以帮助他。在使用这台机器时，需要将两个或者多个蘑菇放到机器里，并摆成一排（以任意顺序），然后打开机器。接下来，这台机器会计算所有不属于同一种类的 **相邻** 蘑菇对的个数。例如，如果你把种类为 $[A,B,B,A]$ 的蘑菇（按照这个顺序）放到机器中，结果应该是 $2$。

但是，因为机器操作非常昂贵，机器只能使用有限的次数。此外，在机器的所有使用中，放置到机器中的蘑菇总数不能超过 $10^5$。请使用这台机器帮助安德鲁来数一数他采集了多少个种类为 $A$ 的蘑菇。

#### 实现细节

你需要实现以下函数：

```cpp
int count_mushrooms(int n)
```

- $n$: 安德鲁采集到的蘑菇数量。
- 该函数应该被调用恰好一次，而且要返回种类为 $A$ 的蘑菇的个数。

以上函数可以调用以下函数：

```cpp
int use_machine(int[] x)
```

- $x$: 一个长度介于 $2$ 和 $n$ 的数组（包括 $2$ 和 $n$)，按顺序给出放在机器中的蘑菇的编号。
- $x$ 的元素必须是在 $0$ 到 $n-1$ 之间（包括 $0$ 和 $n-1$) **互不相同** 的整数。
- 假设数组 $x$ 的长度为 $d$。那么，此函数返回不同的下标 $j$ 的个数，满足 $0 \le j \le d-2$ 并且 $x[j]$ 和 $x[j+1]$ 属于不同种类。
- 该函数最多可以被调用 $2 \times 10^4$ 次。
- 在对函数 `use_machine` 的所有调用中，所有被传到该函数 `use_machine` 的 $x$ 的总长度不能超过 $10^5$。

## 说明/提示

#### 样例说明

#### 例 1

考虑以下场景：有 $3$ 个蘑菇，种类依次为 $[A,B,B]$。函数 `count_mushrooms` 用以下方式调用

```cpp
count_mushrooms(3)
```

该函数可以调用 `use_machine([0, 1, 2])`，在该场景下调用返回 $1$。 函数接着调用 `use_machine([2, 1])`，该调用返回 $0$。

此时，已经有足够的信息来推出只有 $1$ 个 $A$ 类蘑菇。所以，函数 `count_mushrooms` 应该返回 $1$。

#### 例 2

考虑一个例子：有 $4$ 个蘑菇，种类依次为 $[A,B,A,A]$。函数 `count_mushrooms` 被调用如下：
```cpp
count_mushrooms(4)
```

该函数可以调用 `use_machine([0, 2, 1, 3])`，该调用返回 $2$。接着调用 `use_machine([1,2])`，该调用返回 $1$。

此时，已有足够的信息推出：有 $3$ 个 $A$ 类蘑菇。因此，函数 `count_mushrooms` 应该返回 $3$。

#### 约束条件

- $2 \le n \le 2 \times 10^4$

#### 计分

在所有测试用例中，如果对函数 `use_machine` 的调用不符合上面所述的要求，或者 `count_mushrooms` 的返回值不正确，你的解答得分将为 $0$。否则，令 $Q$ 为所有测试样例中对函数 `use_machine` 的最大调用次数。那么，得分将按照以下表格进行计算：

|条件|得分|
|:-:|:-:|
|$2 \times 10^4 \le Q$|$0$|
|$10010 < Q \le 2 \times 10^4$|$10$|
|$904 < Q \le 10010$|$25$|
|$226 < Q \le 904$|$\frac{226}{Q} \cdot 100$|
|$Q \le 226$|$100$|

在有些测试用例上，评测程序的行为是自适应的。也就是说，在这些测试用例中，评测程序并没有一个固定的蘑菇种类序列。相反，评测程序中所给出的回答可能依赖于此前对 `use_machine` 的调用。

但是可以保证，评测程序中所给出的回答满足：在每次交互之后，至少存在一个蘑菇种类序列，它能够与当前所给出过的所有回答都相符。

#### 评测程序示例

评测程序示例读入一个整数数组 $s$，该数组给出了蘑菇的种类。对于所有 $0 \le i \le n-1$，$s[i]=0$ 表示蘑菇 $i$ 的种类是 $A$，$s[i]=1$ 表示蘑菇 $i$ 的种类是 $B$。评测程序示例读取如下格式的输入数据：

第 $1$ 行: $n$       
第 $2$ 行: $s[0]\ s[1]\ \ldots\ s[n-1]$

评测程序示例的输出为如下格式：

第 $1$ 行: `count_mushrooms` 的返回值。     
第 $2$ 行: 调用 `use_machine` 的次数。

注意评测程序示例不是自适应的。

# 题解

## 作者：lightup37 (赞：11)

# IOI2020 mushrooms 题解

## 题意

**交互题**. 给定 $n$, 有一个长度为 $n$ 的 01 序列 $a_0, a_1, \cdots a_{n-1}$, 你不知道 $a_1, a_2, \cdots a_{n-1}$ 的值, 但你知道 $a_0 = 0$.

我们定义一次操作为给定 $k(2\leq k\leq n)$ 和一个长度为 $k$ 的, 不含重复值的序列 $b_0, b_1, \cdots b_{k-1}$, 然后交互库返回 $\sum\limits_{i=0}^{k-2} [b_i \not= b_{i+1}]$.

你需要通过若干次操作, 求出 $\sum\limits_{i=0}^{n-1} (1-b_{i})$.

具体细节参见[题面](https://loj.ac/p/3368).

**Note:** 你需要 ``#include "mushrooms.h"``.

## 解法

为了方便, 以下我们将不加申明的将 $ret$ 用作上一次 $\texttt{query}$ 操作的返回值, 读者可以根据上下文知道这个 $ret$ 的值.

### Method 1

我们考虑朴素暴力: 对所有 $i\in [1, n-1]$ 执行操作 $\texttt{query}(\{0, i\})$, 这是一个时间复杂度 $O(n)$ 的算法, 可以获得 ... 10 分.

### Method 2

我们发现: 如果已知有 $k$ 个 0, 分别是 $a_{f_1}, a_{f_2}, \cdots a_{f_k}$, 那么可以执行这样的一次操作来求出长度为 $k$ 的序列 $g_1, g_2, \cdots g_k$ 中 0 的个数: $\texttt{query}(\{g_1, f_1, g_2, f_2, \cdots g_k, f_k\})$. 容易知道 $\sum\limits_{i=1}^k g_i = \lceil\frac{ret}{2}\rceil$. 有 $k$ 个 1 的情况下同理.

而如何求出 $f_1, f_2, \cdots f_k$ 呢? 显然直接套用 Method 1 即可. 我们使用类似根号分治的思想可以做到 $O(\sqrt n)$ 的复杂度(实际上后续都是常数优化, 并没有超越这个复杂度.)

### Optimize 1

我们考察这种操作: $\texttt{query}(\{g_1, f_1, g_2, f_2, \cdots g_k, f_k\})$. 那么可以根据 $ret$ 的奇偶性判断 $g_1$ 的值, 具体来说, 由于 $g_2, g_3, \cdots g_{k}$ 左右均为相同的值, 故不管这些数如何取值, 均不会影响 $ret$ 的奇偶性, 所以 $ret$ 的奇偶性只由 $a_{g_1}, a_{f_1}$ 决定, 也即可以得出 $a_{g_1}$ 的具体值. 于是我们可以动态的维护当前 0/1 的个数和这些 0/1 的位置然后每次启发式的用 0/1 去询问.

[以上优化的代码](https://loj.ac/s/1368535)

### Optimize 2

这同时也可以对 Method 1 的过程做出优化: 在有两个相同值的数 $a_x, a_y$ 时, 每次可以通过 $\texttt{query\{p, x, q, y\}}$ 确定 $a_p$, $a_q$ 的具体值.

### Optimize 3

Method 2 的过程已经难以优化, 接下来我们来优化 Method 1 的过程.

不妨考虑我们有充分多的 0 和充分多的 1, 接下来我们考虑如何更优的询问, 具体来说, 我们将用 2 询问次得到 5 个数的具体值.

我们设 $p_i$ 为所有 0 的位置序列, $q_i$ 为所有 1 的位置序列. 即 必有 $a_{p_i}=0, a_{q_i}=1$.

我们先进行询问 $\texttt{query}(\{x, p_1, y, p_2, z, p_3\})$. 根据返回值讨论: 首先可以发现根据 $ret$ 的奇偶性确定 $a_x$, 然后我们令 $ret\leftarrow \lfloor\frac{ret}{2}\rfloor$, 这样就有 $a_{y}+a_{z} = ret$. 显然只需要考虑 $ret = 1$ 的情况.

如果 $ret = 1$, 我们接下来进行询问 $\texttt{query}(\{q_1, y, q_2, p_1, z, p_2, u, p_3, v\})$, 然后令 $ret\leftarrow ret-1$(这是因为有相邻的 $q_2, p_1$).

首先考察 $ret$ 的奇偶性以确定 $v$, 然后令 $ret\leftarrow \lfloor \frac{ret}{2}\rfloor$, 这样就有 $1-a_y+a_z+a_u = ret$, 也即 $2a_z+a_u = ret$, 这样又可以根据 $ret$ 的奇偶性来确定 $a_u$, 从而确定 $a_z$ 和 $a_y$.

[以上优化的代码](https://loj.ac/s/1368651)

### Optimize 4

调整你的参数.

[AC 代码](https://loj.ac/s/1368663)

---

## 作者：Otomachi_Una_ (赞：3)

首先观察一下 $226$ 这个东西大概就是 $O(\log^2 n)$ 或者 $O(\sqrt n)$ 的东西。

我显然没见过 $O(\log^2 n)$ 次交互的题目。考虑根号。

考虑如果我们确定了 $i_1,i_2,\dots,i_k$ 都是 A 类蘑菇，那么通过询问 $[i_1,x_1,i_2,x_2,\dots,x_{k-1},i_k]$ 就能知道 $(x_i)$ 中 A 类蘑菇的数量。

也就是，我们只要得到 $O(\sqrt n)$ 个蘑菇就能通过 $O(\sqrt n)$ 次查询知道有多少个 A 类蘑菇。

然后算一下好像 $2\sqrt n$ 比 $226$ 大了不少。卡卡常。

后面感觉优化不了了，但是前面感觉可以优化。

两个两个问，得到的答案永远是 0/1，信息熵太小了。考虑问多一点，但是问多了我们就不知道有啥用了。

考虑我们计算 $k$（$k$ 是小整数）个蘑菇，并且维护他们的 $O(2^k)$ 种的所有可能情况。

每次询问前随机 $1000$ 个可能的询问，并且将最劣情况下排除情况最多的询问作为当前最优询问。

询问完之后，再往后补充还未询问的蘑菇，直到可能情况又达到 $O(2^k)$ 量级为止。

这样子询问只要 $200$ 次左右就过了。可能爆标了？

---

## 作者：zyh_helen (赞：1)

做了很久很久（10h+）的一道题，真的很好玩。

---
---

我们设 $t$ 为每次询问的交互库给出的回答。

---

#### 策略 1

考虑询问次数为 $n-1$ 的做法，我们直接对于每一个蘑菇和第 0 个蘑菇比较一下是否相同。

期望得分：10。

---

#### 策略 2
下一档分是询问次数 $\frac{n}{2}$ 左右，考虑如果我们已知两个蘑菇是同一种（不妨设为 A），则可以询问一个 $[A,X,A,Y]$，根据 $t\bmod 2$ 判断 $Y$ 的种类，根据 $\left\lfloor\frac{t}{2}\right\rfloor$ 的结果判断 $X$ 的种类。

考虑如何使满足获得两个同种蘑菇，先使用策略 1，易证最多 3 次即可得到两个同种蘑菇。

期望得分：25

---

我们考虑我们的策略的问题，那就是题目仅仅要求我们求出 $A$ 种类的个数，我们却把所有 $A$ 的位置精确问出来了。

---

#### 策略3

假设我们有了足够多的 $A$ 或 $B$（这里假设是 $A$，$B$ 同理）我们考虑问出一个形如 $[A,X_1,A,X_2,A,X_3,\dots,A,X_k,A]$ 这样的，然后每一个 $X_i$ 种类为 $B$ 都会给出 2 的贡献，那么 $k-\left\lfloor\frac{t}{2}\right\rfloor$ 即为 $X_1,X_2,X_3,\dots,X_k$ 中 $A$ 的个数。

考虑我们需要 $k+1$ 个 $A$（或 $B$），我们先使用策略 1 $2k+2$ 次一定就能得到 $k+1$ 个同种蘑菇，然后再操作即可。

次数 $2\times k+\frac{n}{k}$ 左右，易证取得最优时次数为 $2\times\sqrt{2\times n}$ 左右。

期望得分：56

---

这时候我们发现我们的策略大概分为前期（获取足够多的同种蘑菇）和后期（利用同种蘑菇确定剩余蘑菇中 $A$ 种类的个数）。

---

#### 策略 4

优化前期。

我们考虑获取 $k+1$ 个同种蘑菇时采用策略 2。

前期的询问效率从 1 优化到 2，次数变为 $\frac{2\times k}{2}+\frac{n}{k}$，易证取得最优时次数为 $2\times \sqrt{n}$ 左右。

期望得分：62

---

#### 策略 5

优化后期。

我们考虑询问时在最后加上一个未知蘑菇，可以通过 $t\bmod 2$ 直接得到该蘑菇的种类，并且不会影响其余蘑菇中 $A$ 种类个数的判断。

这样在后期每次询问都能再得到一个确定的蘑菇种类，$k$ 也可以随着后期询问的进行而增大（显然最劣后期每问两次都能使 $k$ 增大 1）。

次数的式子比较长，用程序算一下大概最优时次数是 245 左右。

期望得分：92

---

#### 策略 6

优化前期。

这个策略实际是我脑抽了忘了交互库自适应。

考虑交互库不自适应的情况。

假设已经有 3 个同种类的蘑菇，我们考虑问 $[A,X,A,Y,A,Z]$。

显然可以通过 $t\mod2$ 直接得到 $Z$ 的种类。

- 如果 $\left\lfloor\frac{t}{2}\right\rfloor=0$，则 $X,Y$ 都是 $A$ 种类；
- 如果 $\left\lfloor\frac{t}{2}\right\rfloor=1$，则说明 $X,Y$ 种类不同；
  
  - 我们询问一个 $[A,X,A,W]$，类似策略 2，我们得到了 $X,W$ 的种类，又因为 $X$ 与 $Y$ 种类不同，也能得到 $Y$ 的种类。
- 如果 $\left\lfloor\frac{t}{2}\right\rfloor=2$，则 $X,Y$ 都是 $B$ 种类。

那么 
- $X,Y$ 相同概率为 $\frac{1}{2}$，1 个询问确定 3 个蘑菇，询问效率 3。
- $X,Y$ 不同概率为 $\frac{1}{2}$，2 个询问确定 4 个蘑菇，询问效率 2。

交互库不自适应情况下询问效率从 2 优化到 2.5，用程序算一下最优时期望次数 225 左右，虽然不一定能过但很优秀。

很可惜，交互库自适应。

期望得分：92

---
#### 策略 7

优化前期。

这个真的想了很久，以至于以为不可做了。

考虑我们之前疏漏了什么，就是每次询问都只考虑利用相同蘑菇来问。

此时我们假设已经有了 4 个 $A$ 和 2 个 $B$。

考虑先问 $[A,X_1,A,X_2,A,X_3,A,X_4]$。

同理，根据 $t\bmod2$ 确定 X_4。

接着令 $o=\left\lfloor\frac{t}{2}\right\rfloor$，我们分类讨论。

- $o=0$，$X_1,X_2,X_3$ 都是种类 $A$；
- $o=1$，$X_1,X_2,X_3$ 中有一个是种类 $B$，那么我们再问 $[A,X_1,A,B,X_2,B,X_4]$（这个回答的值记为 $t^\prime$），同理还是先确定 $X_4$ 的种类

   - $\left\lfloor\frac{t^\prime-1}{2}\right\rfloor=0$，$X_1$ 为 $A$，$X_2$ 为 $B$，也可以确定 $X_3$ 为 $A$；
   -  $\left\lfloor\frac{t^\prime-1}{2}\right\rfloor=1$，$X_1$ 和 $X_2$ 相同，所以 $X_1$ 和 $X_2$ 都是 $A$，$X_3$ 是 $B$；
   -  $\left\lfloor\frac{t^\prime-1}{2}\right\rfloor=2$，$X_1$ 为 $B$，$X_2$ 为 $A$，也可以确定 $X_3$ 为 $A$；
- $o=2$，$X_1,X_2,X_3$ 中有一个是种类 $A$，那么我们也是再问 $[A,X_1,A,B,X_2,B,X_4]$（这个回答的值记为 $t^\prime$），同理还是先确定 $X_4$ 的种类

   - $\left\lfloor\frac{t^\prime-1}{2}\right\rfloor=0$，$X_1$ 为 $A$，$X_2$ 为 $B$，也可以确定 $X_3$ 为 $B$；
   -  $\left\lfloor\frac{t^\prime-1}{2}\right\rfloor=1$，$X_1$ 和 $X_2$ 相同，所以 $X_1$ 和 $X_2$ 都是 $B$，$X_3$ 是 $A$；
   -  $\left\lfloor\frac{t^\prime-1}{2}\right\rfloor=2$，$X_1$ 为 $B$，$X_2$ 为 $A$，也可以确定 $X_3$ 为 $B$；
- $o=3$，$X_1,X_2,X_3$ 都是种类 $B$。

考虑怎么得到 4 个 $A$ 和 2 个 $B$，这时候策略 6 就发挥作用了，当我们仅有一种蘑菇满足条件时使用策略 6，要么得到不同的蘑菇，要么以 3 的效率确定，不会被卡掉。

至此我们发现，最劣情况下我们 2 次询问都能确定 5 个蘑菇，效率 2.5，次数 225 左右。

经过一些调参和乱搞（比如所有询问开始前先把所有蘑菇问一遍）即可通过。

期望得分：100

---
---
贴上来的是 loj 的 ac 代码

```cpp
#include<bits/stdc++.h>
//#include<Windows.h>
//#define int long long
//#define ll long long
//#define double long double
#define fi first
#define se second
//#define ls t[p].l
//#define rs t[p].r
#define y1 yyyyyyyyyyyyyyyy1
#include "mushrooms.h"
using namespace std;
const int N = 1e6 + 10, inf = 1e9, M = 10000;
const double eps = 1e-12, pi = 3.14;
const int mod = 1e9 + 7;
//const int AQX = 9;
//mt19937 rnd(time(0) ^ clock());
//int random(int l, int r){
//	return rnd() % (r - l + 1) + l;
//}
/*
		    	           _      _        _          
			       ____  _| |_   | |_  ___| |___ _ _  
			      |_ / || | ' \  | ' \/ -_) / -_) ' \ 
			      /__|\_, |_||_|_|_||_\___|_\___|_||_|
			          |__/    |___|                              
				       
*/
//struct Graph{
//	int head[N], tot = 1;
//	struct edge{
//		int t;
//		int d, fa, f;
//		int next;
//	}e[N << 1];
//	void edge_add(int u, int v, int w = 0){
//		e[++tot].next = head[u];
//		e[tot].t = v;
//		e[tot].d = w;
//		e[tot].f = u;
//		head[u] = tot;
//	}
//	void clear(int n){
//		for(int i = 1;i <= tot;i++)e[i].t = e[i].f = e[i].d = e[i].next = 0;
//		for(int i = 1;i <= n;i++)head[i] = 0;
//		tot = 0;
//	}
//}g;
//int qmr(int x, int a){
//	int ret = 1, p = x % mod;
//	if(a < 0)return 0;
//	while(a){
//		if(a & 1)ret = ret * p % mod;
//		p = p * p % mod;
//		a >>= 1;
//	}
//	return ret;
//}
//int in(){
//	int ret = 0, w = 1;
//	char t = getchar();
//	while((t < '0' || t > '9') && t != '-')t = getchar();
//	if(t == '-')w = -1, t = getchar();
//	while(t >= '0'&& t <= '9')ret = ((ret << 3) + (ret << 1) + t - '0'), t = getchar();
//	return ret * w;
//}
//void out(int x){
//	if(x < 0)putchar('-'), x = -x;
//	if(x >= 10)out(x / 10);
//	putchar(x % 10 + '0');
//}


const int B = 184;
//int use_machine(vector<int> x){
//	for(int i : x)cout << i + 1 << ' ';
//	cout << endl;
//	int o;
//	cin >> o;
//	return o;
//}
int X = 1;
vector<int>a, b;
int nn;
vector<int>p, pp, cp, ap, bp;
void work1(){
	p[1] = X;
	if(use_machine(p))b.push_back(X);
	else a.push_back(X);
	X++;
}
void work2(){
	pp[1] = X;
	pp[3] = X + 1;
	if(a.size() > 1){
		pp[0] = a[0];
		pp[2] = a[1];
		int t = use_machine(pp);
		if(t & 2)b.push_back(X);
		else a.push_back(X);
		if(t & 1)b.push_back(X + 1);
		else a.push_back(X + 1);
	}
	else {
		pp[0] = b[0];
		pp[2] = b[1];
		int t = use_machine(pp);
		if(t & 2)a.push_back(X);
		else b.push_back(X);
		if(t & 1)a.push_back(X + 1);
		else b.push_back(X + 1);
	}
	X += 2;
}
void work3(){
	cp[1] = X;
	cp[3] = X + 1;
	cp[5] = X + 2;
	if(a.size() > 2){
		cp[0] = a[0];
		cp[2] = a[1];
		cp[4] = a[2];
		int t = use_machine(cp);
		if(t & 1)b.push_back(X + 2);
		else a.push_back(X + 2);
		if(t <= 1){
			a.push_back(X), a.push_back(X + 1);
			X += 3;
			return;
		}
		if(t >= 4){
			b.push_back(X), b.push_back(X + 1);
			X += 3;
			return;
		}
	}
	else {
		cp[0] = b[0];
		cp[2] = b[1];
		cp[4] = b[2];
		int t = use_machine(cp);
		if(t & 1)a.push_back(X + 2);
		else b.push_back(X + 2);
		if(t <= 1){
			b.push_back(X), b.push_back(X + 1);
			X += 3;
			return;
		}
		if(t >= 4){
			a.push_back(X), a.push_back(X + 1);
			X += 3;
			return;
		}
	}
	pp[1] = X + 3;
	pp[3] = X;
	if(a.size() > 1){
		pp[0] = a[0];
		pp[2] = a[1];
		int t = use_machine(pp);
		if(t & 2)b.push_back(X + 3);
		else a.push_back(X + 3);
		if(t & 1)b.push_back(X), a.push_back(X + 1);
		else a.push_back(X), b.push_back(X + 1);
	}
	else {
		pp[0] = b[0];
		pp[2] = b[1];
		int t = use_machine(pp);
		if(t & 2)a.push_back(X + 3);
		else b.push_back(X + 3);
		if(t & 1)a.push_back(X), b.push_back(X + 1);
		else b.push_back(X), a.push_back(X + 1);
	}
	X += 4;
}
void work4(){
	ap[0] = a[0];
	ap[2] = a[1];
	ap[4] = a[2];
	ap[6] = a[3];
	ap[1] = X;
	ap[3] = X + 1;
	ap[5] = X + 2;
	ap[7] = X + 3;
	int t = use_machine(ap);
	if(t & 1)b.push_back(X + 3);
	else a.push_back(X + 3);
	if(t <= 1){
		a.push_back(X);
		a.push_back(X + 1);
		a.push_back(X + 2);
		X += 4;
		return;
	}
	if(t >= 6){
		b.push_back(X);
		b.push_back(X + 1);
		b.push_back(X + 2);
		X += 4;
		return;
	}
	bp[0] = a[0];
	bp[2] = a[1];
	bp[3] = b[0];
	bp[5] = b[1];
	bp[1] = X;
	bp[4] = X + 1;
	bp[6] = X + 4;
	int tt = use_machine(bp);
	if(tt & 1)b.push_back(X + 4);
	else a.push_back(X + 4);
	tt--;
	if(tt / 2 == 0){
		a.push_back(X), b.push_back(X + 1);
		if(t / 2 == 1)a.push_back(X + 2);
		else b.push_back(X + 2);
	}
	else if(tt / 2 == 1){
		if(t / 2 == 1)a.push_back(X), a.push_back(X + 1), b.push_back(X + 2);
		else b.push_back(X), b.push_back(X + 1), a.push_back(X + 2);
	}
	else {
		b.push_back(X), a.push_back(X + 1);
		if(t / 2 == 1)a.push_back(X + 2);
		else b.push_back(X + 2);
	}
	X += 5;
}
void workL(){
	while(a.size() < 2 && b.size() < 2)work1();
	while(a.size() < 3 && b.size() < 3)work2();
	while((b.size() < 2 || a.size() < 4) && X <= B)work3();
	while(X <= B)work4();
}
int cal(){
	if(a.size() < b.size()){
		int s = min((int)b.size(), nn - X + 1);
		vector<int>nt;
		for(int i = 0;i < s;i++){
			nt.push_back(b[i]);
			nt.push_back(i + X);
		}
		int t = use_machine(nt);
		X += s;
		if(X <= nn){
			if(t & 1)a.push_back(X - 1);
			else b.push_back(X - 1);
		}
		return (t + 1) / 2;
	}
	else {
		int s = min((int)a.size(), nn - X + 1);
		vector<int>nt;
		for(int i = 0;i < s;i++){
			nt.push_back(a[i]);
			nt.push_back(i + X);
		}
		int t = use_machine(nt);
		X += s;
		if(X <= nn){
			if(t & 1)b.push_back(X - 1);
			else a.push_back(X - 1);
		}
		return s - (t + 1) / 2;
	}
}
void init(){
	p.push_back(0);p.push_back(0);
	pp.push_back(0);pp.push_back(0);pp.push_back(0);pp.push_back(0);
	cp.push_back(0);cp.push_back(0);cp.push_back(0);cp.push_back(0);cp.push_back(0);cp.push_back(0);
	ap.push_back(0);ap.push_back(0);ap.push_back(0);ap.push_back(0);ap.push_back(0);ap.push_back(0);ap.push_back(0);ap.push_back(0);
	bp.push_back(0);bp.push_back(0);bp.push_back(0);bp.push_back(0);bp.push_back(0);bp.push_back(0);bp.push_back(0);
}
//signed main(){
//	int op;
//	cin >> op;
int count_mushrooms(int op){
	vector<int>ooo;
	for(int i = 0;i < op;i++)ooo.push_back(i);
	int qmrakioi = use_machine(ooo);
	a.push_back(0);
	init();
	nn = op - 1;
	if(nn <= 200){
		while(X <= nn)work1();
//		cout << a.size();
		return (int)a.size();
	}
	workL();
	int cc = a.size();
	while(X <= nn)cc += cal();
	return cc;
}

---


# [BJOI2016] 打字机

## 题目描述

小 J 在搬家的过程中发现了一台古老的打字机。 好奇的小 J 决定研究如何使用它。首先，需要将一条长度为 $m$ 
的纸带放入打字机。打字机上共有 26 个按键，分别是小写字母 `a` 到 `z` 。每当你按下一个按键时，打字机
就会立即在纸带上打印出那个字符，并将纸带平移一个单位距离。聪明的小 J 很快就掌握了这款打字机的使用技巧，并想尝试新的挑战。

他拿出了一本字典，挑选了 $n$ 个单词，并给每个单词设定了分数。纸带中每出现一次指定的单词，就会得到对应的分数。例如， 单词 `eye` 的分数为 $2$， `year` 的分数为 $3$，那么纸带 `eyeyeyear` 的分数为 $9$ 分。小 J 希望挑战自己，打出分数最高的纸带。

特别地，小 J 偶尔会手抖，按到自己不想输入的字符。由于这台古老的打字机没有退格（删除）功能，所以小 J 只能接受按错这个事实，重新规划在按错的情况下如何得最高分。倘若小 J 有可能在任意位置按错按键，并保证整个过程中按错的次数不超过 $k$ 次，那么请你算出他在最坏情况下的最高得分是多少。

## 说明/提示

【样例解释】

以下是一种错误思路：

"共 $4$ 种情况，即第 $1$ 位按错、第 $2$ 位按错、第 $3$ 位按错和第 $4$ 位按错。
1. 第 $1$ 位按错（不妨假设按成 `x`，下同），最高得分为 `xwha`，得分为 $10$。
2. 第 $2$ 位按错，最高得分为 `wxha`，同样为 $10$ 分。
3. 第 $3$ 位按错，最高得分为 `haxw`，同样为 $10$ 分。
4. 第 $4$ 位按错，最高得分为 `hawx`，同样为 $10$ 分。

综上，最坏情况下最高得分为 $10$ 分。"

这种思路的错误之处在于，你不能根据哪一位按错决定你第一位按哪个键。 换种说法，你在哪一位按错，是在按下那个按键之后才能知道的事情。 正确的思路如下：

1. 第 $1$ 位先按 `h`，倘若按对， 跳至 2，倘若按错， 跳至 4；
2. 第 $2$ 位按 `a`，倘若按对， 跳至 3，倘若按错， 跳至 5；
3. 第 $3$ 位和第 $4$ 位都按 `w`， 结束。 至多错 1 次，最终纸带为 `hawx` 或 `haxw`，得分为 $10$ 分。
4. 后面三位依次按 `haw`， 结束。 因为不会再错， 最终纸带为 `xhaw`，得分为 $10$ 分。
5. 后面两位依次按 `ha`， 结束。因为不会再错， 最终纸带为 `hxha`，得分为 $9$ 分。

综上，最坏情况下，最高得分为 $9$ 分。

【数据范围】

测试点 $1,2$ 满足，$n = 1$ 或 $k = 0$；

测试点 $1\sim 6$ 满足，$n ≤ 100$，$m ≤ 500$，$∑|S| ≤ 500$，$a_i ≤1000$；

测试点 $7,8$ 满足，$k = 0$，$∑|S| ≤ 200$；

测试点 $9,10$ 满足，$∑|S| ≤ 50$，$a_i ≤1$。

对于 $100\%$ 的数据，$n ≤ 100$，$m ≤ 10^9$ ，$∑|S| ≤ 500$，$a_i ≤1000$，$k ≤ 5$。**请注意，每一个测试点都有相应特殊性质。**

## 样例 #1

### 输入

```
2 4 1
w 1
ha 9```

### 输出

```
9```

# 题解

## 作者：smarthehe (赞：12)

这是一道三合一的题目，我们将数据点 1~6，7~8，9~10 分别处理。

### 数据点 1~6

一个经典的 AC 自动机上 dp。~~（BJOI 传统艺能）~~

考虑到打错字符这一扰动的特殊性我们并不能直接正向做决策，但是可以倒序决策，这样就能把扰动的“最坏”与正常决策的“最好”一起转移。

先将串建成 AC 自动机，然后对于每个串在结束节点添加价值，最后每个节点的价值 $val$ 定义为其在 fail 树上到根的价值和。

令 $dp_{i,j,k}$ 表示在填后 $i$ 个字符，起始在自动机上的节点 $j$，在之前已经打错了 $k$ 次时，能够在后面获得的最大价值。

转移的时候，分类讨论是否打错，如果打错则取最坏情况，否则取最好情况，在此基础上再选择最坏情况。因此有转移：

$$
dp_{i,j,k} = \min \{ \max_{x \in to_j} \{dp_{i-1,x,k}\}, \min_{x \in  to_j}\{ dp_{i-1,x,k+1}\}\}+val_j
$$

直接做，复杂度为 $O(mk|\Sigma|\sum|S|)$。

### 数据点 7~8

没有扰动了，因此可以简化成一个更简单的 dp。

先同样建出自动机，并得出节点的价值。

令 $dp_{i,j}$ 为填了 $i$ 个字符，当前在自动机上的节点 $j$ 时已经获得的最大价值。有转移：

$$
dp_{i,j} = \max_{j \in to_x} \{ dp_{i-1,x}\}+val_j
$$

注意到这个转移式子是简洁的 $(max,+)$ 递推，可以使用类似 [【NOI2020】美食家](https://www.luogu.com.cn/problem/P6772) 的方法，用倍增或者矩阵的形式加速 dp。

### 数据点 9~10

略显玄学的部分。

观察到扰动最多 $5$ 次，$\sum|S|$ 只有 $50$，而 $m$ 高达 $10^9$。这说明在两次扰动之间会隔有很长的一段。对于这一段，其决策不受扰动影响。

如果这一段的长度是数倍于自动机节点个数的，则可以预见到，最优的决策一定会经过一个环，在环上不断地走，获得环上的价值。

在一次扰动之后，可能会有多种情况，比如走上另一个环，或者走一条路径等，但实际上也都是一个类似之前决策的过程。

如果走上的路径长度是自动机节点个数的数倍，那必然不如走一个环有意义。所以走路径只会是最后几步的决策。

而对于不停走一个环的情况，在开始循环后在第几次循环扰动都是等价的。

因此可以声明：存在一种符合题意的最优情况，使得所有扰动都集中在末尾，且末尾这段的长度是 $O(k\sum|S|)$ 级别。

那么对于前面的部分视作没有扰动，按数据点 7~8 的方法处理，最后选择一个末尾长度（理论上需要是 $k\sum|S|$ 的数倍以上，我选择了 $2000$）按数据点 1~6 的方法处理，然后拼起来计算答案。

另外据说官方题解是利用 $a_i=1$ 性质的一个所谓“最小比率环”的做法，但是作者实在找不到相关资源，只能不了了之了。

### 代码

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=505,N2=205;
char s[N][N];
int val[N],son[N][26],fail[N],ndc=1;
int n,m,k,que[N],h,t;
inline void ins_AC(int id,int v)
{
	int i,len=strlen(s[id]+1),now=1;
	for(i=1;i<=len;i++)
	{
		int c=s[id][i]-'a';
		if(!son[now][c]) son[now][c]=++ndc;
		now=son[now][c];
	}
	val[now]+=v;
}
void build_AC()
{
	for(int i=0;i<26;i++)
	{
		if(son[1][i]) fail[son[1][i]]=1,que[t++]=son[1][i];
		else son[1][i]=1;
	}
	while(h<t)
	{
		int now=que[h++];
		for(int i=0;i<26;i++)
		{
			if(son[now][i]) fail[son[now][i]]=son[fail[now]][i],que[t++]=son[now][i];
			else son[now][i]=son[fail[now]][i];
		}
	}
	for(int i=0;i<t;i++)
	{
		int now=que[i];
		val[now]+=val[fail[now]];
	}
}
int dp[N*5][N][6];
void solve1()
{
	int i,j,tk,x;
	for(i=1;i<=ndc;i++)
		for(j=0;j<=k;j++)
			dp[0][i][j]=val[i];
	for(i=1;i<=m;i++)
	{
		for(j=1;j<=ndc;j++)
		{
			for(tk=0;tk<=k;tk++)
			{
				int mx=0,mn=1e9;
				for(x=0;x<26;x++) mx=max(mx,dp[i-1][son[j][x]][tk]);
				if(tk<k) {for(x=0;x<26;x++) mn=min(mn,dp[i-1][son[j][x]][tk+1]);}
				dp[i][j][tk]=min(mx,mn)+val[j];
			}
		}
	}
}
long long dp2[35][N2][N2],tdp[N2],tdp2[N2];
void solve2()
{
	int i,j,tk,x;
	for(i=1;i<=ndc;i++) 
	{
		for(j=1;j<=ndc;j++) dp2[0][i][j]=-1;
		for(j=0;j<26;j++) dp2[0][i][son[i][j]]=val[i]+val[son[i][j]];
	}
	for(i=1;(1<<i)<=m;i++)
	{
		for(j=1;j<=ndc;j++)
		{
			for(tk=1;tk<=ndc;tk++)
			{
				long long mx=-1;
				for(x=1;x<=ndc;x++) if(dp2[i-1][j][x]!=-1&&dp2[i-1][x][tk]!=-1) mx=max(mx,dp2[i-1][j][x]+dp2[i-1][x][tk]-val[x]);
				dp2[i][j][tk]=mx;
			}
		}
	}
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
    {
    	int v;
    	scanf("%s%d",s[i]+1,&v);
    	ins_AC(i,v);
    }
    build_AC();
    if(m<=500)
    {
    	solve1();
    	printf("%d",dp[m][1][0]);
    }
    else if(k==0)
    {
    	solve2();
    	int i,j,tk;
    	for(i=1;i<=ndc;i++) tdp[i]=tdp2[i]=-1;
    	tdp[1]=0;
    	for(i=0;(1<<i)<=m;i++)
    	{
    		if(!((1<<i)&m)) continue;
    		for(j=1;j<=ndc;j++)
    		{
    			if(tdp[j]==-1) continue;
    			for(tk=1;tk<=ndc;tk++)
    			{
    				if(dp2[i][j][tk]==-1) continue;
    				tdp2[tk]=max(tdp2[tk],tdp[j]+dp2[i][j][tk]-val[j]);
    			}
    		}
    		for(j=1;j<=ndc;j++) tdp[j]=tdp2[j],tdp2[j]=-1;
    	}
    	long long ans=0;
    	for(i=1;i<=ndc;i++) ans=max(ans,tdp[i]);
    	printf("%lld",ans);
    }
    else
    {
    	if(m<=2500)
    	{
    		solve1();
    		printf("%d",dp[m][1][0]);
    		return 0;
    	}
    	solve2();
    	int i,j,tk;
    	for(i=1;i<=ndc;i++) tdp[i]=tdp2[i]=-1;
    	tdp[1]=0;
    	for(i=0;(1<<i)<=m-2000;i++)
    	{
    		if(!((1<<i)&(m-2000))) continue;
    		for(j=1;j<=ndc;j++)
    		{
    			if(tdp[j]==-1) continue;
    			for(tk=1;tk<=ndc;tk++)
    			{
    				if(dp2[i][j][tk]==-1) continue;
    				tdp2[tk]=max(tdp2[tk],tdp[j]+dp2[i][j][tk]-val[j]);
    			}
    		}
    		for(j=1;j<=ndc;j++) tdp[j]=tdp2[j],tdp2[j]=-1;
    	}
    	m=2000;
    	solve1();
    	long long ans=0;
    	for(i=1;i<=ndc;i++) if(tdp[i]!=-1&&dp[m][i][0]!=-1) ans=max(ans,tdp[i]+dp[m][i][0]-val[i]);
    	printf("%lld",ans);
    }
    return 0;
}
```

---

## 作者：HECZ (赞：5)

首先我们捋一下题意：

最坏情况下，那一定是恰好发生 $k$ 次打错字符的事情，而对于每个时刻的 $26$ 种方案中，一定有一个最优情况，这个情况就是这个时刻想打出的字符，也就是说对于任何时刻，下一步的最优字符一定是已经确定的。

所以我们可以先建立AC自动机，每个单词的终止节点拥有一个分数，然后考虑在上面做一些事情。

对于 $\text{Subtask }1\sim 6$ 我们可以 DP，设 $F[i][j][k]$ 表示当前在 $i$ 号节点，文章长度剩余 $j$，最多还能犯 $k$ 次错误的最大得分。

那么怎么递推呢？假设他这次没犯错误，那么一定会选 $26$ 种情况里获利最大的那个 $F[p][j-1][k]$。（注：$p$ 是最优情况）

但是他还有可能犯错，所以要和另外 $25$ 种情况取个 $\min F[p][j-1][k-1]$。（注： $p$ 不是最优情况）

这样我们可以得到 $60$ 分，可见再难的题目只需要认真推导。

对于 $\text{Subtask }7\sim 8$，特殊点在于 $k=0$，这样的话就不会有犯错的情况出现了想打什么就打什么，这样我们就可以用类似矩阵乘法快速幂的东西快速求解。

对于 $\text{Subtask }9\sim 10$，有很多种做法，官方给的是利用 $a_i \leq 1$ 这点来找出最优比例环，然后一直在环上走这样的。

代码：

```cpp
#include<iostream> 
#include<cstdio> 
#include<cstring> 
#define N 510 
using namespace std; 
char s[N]; 
int a[110]; 
int ch[N][27],nxt[N],la[N],w[N],cnt; 
void addnew(int v) 
{ 
    int now=0; 
    int n=strlen(s),i,j,x; 
    for(i=0;i<n;i++) 
    { 
        x=s[i]-96; 
        if(!ch[now][x]) 
        { 
            cnt++; 
            ch[now][x]=cnt; 
        } 
        now=ch[now][x]; 
    } 
    w[now]+=v; 
} 
int q[N],h,t; 
void getnxt() 
{ 
    h=1;t=0; 
    int i,j,x,y; 
    for(i=1;i<=26;i++) 
    if(ch[0][i]) t++,q[t]=ch[0][i]; 
    while(h<=t) 
    { 
        x=q[h];h++; 
        for(i=1;i<=26;i++) 
        { 
            j=ch[x][i]; 
            if(!j) {ch[x][i]=ch[nxt[x]][i];continue;} 
            y=nxt[x]; 
            while(y&&!ch[y][i]) y=nxt[y]; 
            nxt[j]=ch[y][i]; 
            w[j]+=w[nxt[j]]; 
            if(w[nxt[j]]) la[j]=nxt[j]; 
            else la[j]=la[nxt[j]]; 
            t++;q[t]=j; 
        } 
    } 
} 
int f[N][N][6]; 
bool used[N][N][6]; 
int K,m; 
void dp(int n,int x,int k) 
{ 
    if(k>K||used[n][x][k]) return; 
    used[n][x][k]=true; 
    f[n][x][k]=w[x]; 
    if(n==m) return; 
    int maxn=-707185547707185547LL,maxb=0; 
    int i,j; 
    for(i=1;i<=26;i++) 
    { 
        dp(n+1,ch[x][i],k); 
        if(k<K) 
        dp(n+1,ch[x][i],k+1); 
        if(f[n+1][ch[x][i]][k]>maxn) 
        { 
            maxn=f[n+1][ch[x][i]][k]; 
            maxb=i; 
        } 
    } 
    maxn=707185547707185547LL; 
    for(i=1;i<=26;i++) 
    { 
        if(i==maxb) maxn=min(maxn,f[n+1][ch[x][i]][k]); 
        else if(k<K) maxn=min(maxn,f[n+1][ch[x][i]][k+1]); 
    } 
    f[n][x][k]+=maxn; 
} 
long long di[210][210],ret[210][210],tmp[210][210]; 
long long ans; 
void do1(int M,bool chu) 
{ 
    ans=0; 
    int i,j,k; 
    if(chu) 
    { 
        memset(di,0xef,sizeof(di)); 
        for(i=0;i<=cnt;i++) 
        for(j=1;j<=26;j++) 
        di[i][ch[i][j]]=w[ch[i][j]]; 
        for(i=0;i<=cnt;i++) 
        for(j=0;j<=cnt;j++) 
        ret[i][j]=di[i][j]; 
        M--;     
        while(M) 
        { 
            for(i=0;i<=cnt;i++) 
            for(j=0;j<=cnt;j++) 
            tmp[i][j]=-707185547707185547LL; 
            if(M&1) 
            { 
                for(i=0;i<=cnt;i++) 
                for(k=0;k<=cnt;k++) 
                for(j=0;j<=cnt;j++) 
                tmp[i][j]=max(ret[i][k]+di[k][j],tmp[i][j]); 
                for(i=0;i<=cnt;i++) 
                for(j=0;j<=cnt;j++) 
                ret[i][j]=tmp[i][j]; 
            } 
            for(i=0;i<=cnt;i++) 
            for(j=0;j<=cnt;j++) 
            tmp[i][j]=-707185547707185547LL; 
            for(i=0;i<=cnt;i++) 
            for(k=0;k<=cnt;k++) 
            for(j=0;j<=cnt;j++) 
            tmp[i][j]=max(tmp[i][j],di[i][k]+di[k][j]); 
            for(i=0;i<=cnt;i++) 
            for(j=0;j<=cnt;j++) 
            di[i][j]=tmp[i][j]; 
            M/=2; 
        } 
        memset(di,0xef,sizeof(di)); 
        for(i=0;i<=cnt;i++) 
        for(j=1;j<=26;j++) 
        di[i][ch[i][j]]=w[ch[i][j]]; 
    } 
    else
    { 
        for(i=0;i<=cnt;i++) 
        for(j=0;j<=cnt;j++) 
        { 
            tmp[i][j]=-707185547707185547LL; 
            for(k=0;k<=cnt;k++) 
            tmp[i][j]=max(ret[i][k]+di[k][j],tmp[i][j]); 
        } 
        for(i=0;i<=cnt;i++) 
        for(j=0;j<=cnt;j++) 
        ret[i][j]=tmp[i][j]; 
    } 
    for(i=0;i<=cnt;i++) 
    ans=max(ans,ret[0][i]); 
} 
void do2() 
{ 
    int M=m; 
    int P=M-300,i,j,k; 
    long long ret=0; 
    int st; 
    for(;P<=M-250;P++) 
    { 
        for(i=0;i<=300;i++) 
        for(j=0;j<=cnt;j++) 
        for(k=0;k<=K;k++) 
        used[i][j][k]=false; 
        m=M-P; 
        dp(0,0,0); 
        do1(P,(P==M-300)); 
        ret=max(ret,f[0][0][0]+ans); 
    } 
    printf("%lld",ret+1); 
} 
int main() 
{  
    int n; 
    scanf("%d%d%d",&n,&m,&K); 
    int i,j; 
    for(i=1;i<=n;i++) 
    { 
        scanf("%s%d",s,&a[i]); 
        addnew(a[i]); 
    } 
    getnxt(); 
    if(m>500&&K==0&&cnt<=200) {do1(m,true);printf("%lld",ans);return 0;} 
    if(m>500&&K!=0&&cnt<=51) {do2();return 0;} 
    dp(0,0,0); 
    printf("%d",f[0][0][0]);
}
```

---


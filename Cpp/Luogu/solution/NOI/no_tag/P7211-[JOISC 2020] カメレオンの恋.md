# [JOISC 2020] カメレオンの恋

## 题目背景

您可以在如下的代码模板中编写程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
extern "C" int Query(const std::vector<int> &p);
extern "C" void Answer(int a, int b);
extern "C" void Solve(int N) {
	
}
```

## 题目描述

在 JOI 动物园中，有 $2\times N$ 只变色龙，有 $N$ 只的性别为 $\rm X$，另外 $N$ 只的性别为 $\rm Y$。

每一只变色龙均有其原始颜色，其约束如下：
- $\rm X$ 性别的变色龙颜色两两不同。
- 对于每一只 $\rm X$ 性别的变色龙，都有一只 $\rm Y$ 性别的变色龙颜色与之相同。

现在每一只变色龙都爱另一只变色龙了，具体规则如下：
- 每一只变色龙只爱异性变色龙。
- 每只变色龙与其喜欢的变色龙有不同的初始颜色。
- 不会存在两只变色龙爱一只变色龙。

现在您可以组织一些变色龙开会，对于每一只在会议中的变色龙 $s$，设 $s$ 爱的变色龙为 $t$。

- 若 $t$ 参加会议，则 $s$ 的皮肤颜色为 $t$ 的原始颜色。
- 否则，$s$ 的皮肤颜色为 $s$ 的原始颜色。

对于您组织的每次会议，您可以统计不同的肤色数量。

通过召开不超过 $2\times 10^4$ 次会议，您要确定初始颜色相同的每一对变色龙。

#### 交互细节
您需要在程序前声明两个函数：
- `int Query(const std::vector<int> &p)`。
- `void Answer(int a, int b)`。

您需要实现一个函数：`void Solve(int N)`。
- 每个测试样例仅调用一次。
- $N$ 的意义如题。

你的程序可以调用如下函数：
- `int Query(const std::vector<int> &p)`
   - 您可以调用此函数来组织变色龙会议。
       - $p$ 是参加会议的变色龙名单。
       - 这会返回参加会议的变色龙颜色的种数。
       - 所有 $p$ 内的数必须在 $1$ 到 $2\times N$ 之间，不然会返回 `Wrong Answer [1]`。
       - 所有 $p$ 内的数必须是两两不同的，不然会返回 `Wrong Answer [2]`。
       - 您只能调用此函数 $2\times 10^4$ 次，若超过，会返回 `Wrong Answer [3]`。
     
- `void Answer(int a, int b)`
   - 调用这个函数来提交一对原始颜色相同的变色龙。
       - 参数 $a$ 和 $b$ 表示变色龙 $a$ 和 $b$ 具有相同的初始颜色。
       - 您需要保证 $1\le a,b\le 2\times N$，否则会返回 `Wrong Answer [4]`。
       - 您需要保证每一次提交的变色龙不同，否则会返回 `Wrong Answer [5]`。
       - 如果您提交的 $a$ 和 $b$ 的初始颜色不同，会返回 `Wrong Answer [6]`。
       - 您需要调用 $N$ 次该函数，否则会返回 `Wrong Answer [7]`。
       
如果您在交互过程中均未违反限制，恭喜您 AC 了。

## 说明/提示

#### 样例解释
样例调用如下：
| 交互库调用 | 你的调用 | 返回值 |
| :-: | :-: | :-:|
| `Solve(4)` |  |  |
|  | `Query([])` | $0$ |
|  | `Query([6, 2])` | $2$ |
|  | `Query([8, 1, 6])` | $2$ |
|  | `Query([7, 1, 3, 5, 6, 8])` | $4$  |
|  | `Query([8, 6, 4, 1, 5])` | $3$ | 
|  | `Answer(6, 4)` |  |
|  | `Answer(7, 8)` |  |
|  | `Answer(2, 1)` |  |
|  | `Answer(3, 5)` |  |

`sample-02.txt` 符合 Subtask 1 的限制，`sample-03.txt` 符合 Subtask 4 的限制。
#### 子任务
对于 $100\%$ 的数据，保证 $2\le N\le 500$，$0\le Y_i\le 1$，$1\le C_i\le N$，$1\le L_i\le 2\times N$，$Y_i\not=Y_{L_i}$，$C_i\not=C_{L_i}$，$L$ 两两不同。

| 子任务 | 特殊性质 | 分数 |
| :-: | :-: | :-: |
| $1$ | $L_{L_i}=i (1\le i\le 2\times N)$ | $4$ |
| $2$ | $N\le 7$ | $20$ |
| $3$ | $N\le 50$ | $20$ |
| $4$ | $Y_i=0 (1\le i\le N)$ | $20$ |
| $5$ | 无 | $36$ |
#### 说明
本题译自 [第 19 回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) Day 2 [T1 カメレオンの恋](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day2/chameleon-en.pdf)。

## 样例 #1

### 输入

```
4
1 0 1 0 0 1 1 0
4 4 1 2 1 2 3 3
4 3 8 7 6 5 2 1```

### 输出

```
```

# 题解

## 作者：xht (赞：4)

对于两个点 $x,y$，如果我们按照如下方式建图：

- 若 $x,y$ 颜色相同，则 $x,y$ 之间连一条无向边，记为 $x \leftrightarrow y$。
- 若 $x$ 喜欢 $y$，则连一条 $x \to y$ 的有向边。

先不考虑询问的限制次数。

如果我们询问所有的点对 $(x,y)$，返回的结果要么为 $1$，要么为 $2$。

如果为 $1$，则只有以下三种情况：

1. $x,y$ 颜色相同。
2. $x$ 喜欢 $y$，但 $y$ 不喜欢 $x$。
3. $y$ 喜欢 $x$，但 $x$ 不喜欢 $y$。

容易发现，当答案为 $1$ 时，$x,y$ 之间一定有边；答案为 $2$ 时，$x,y$ 之间一定无边，除了 $x \to y$ 且 $y \to x$ 的情况。

进一步可以发现，每个点的度数都是 $3$，但是询问出来的度数可能为 $1$。

若询问出来 $x$ 的度数为 $1$，则说明存在一个度数同样为 $1$ 的点 $y$，符合 $x \to y$ 且 $y \to x$ 的情况，而询问出来的那条边，则是一条无向边 $x \leftrightarrow z$，这意味着 $x,z$ 的颜色相同。

若询问出来 $x$ 的度数为 $3$，设这 $3$ 个点为 $y,z,w$。考虑到如果我们询问 $(x,y,z),(x,y,w),(x,z,w)$，其中有且仅有一组的答案为 $1$，其它两组的答案都为 $2$。

不妨设为 $1$ 的询问为 $(x,y,z)$，则只可能是 $x \leftrightarrow y$ 且 $z \to x$，或者 $x \leftrightarrow z$ 且 $y \to x$。

尽管我们无法得知是哪种，但是我们可以以此确定 $x \to w$ 这条边。

通过这种方法，我们可以确定所有的有向边，那么剩下的边就是无向边，即颜色相同的点。

这个做法的询问次数为 $\mathcal O(n^2)$ 的，瓶颈在询问两两点对上。

考虑优化这个过程。

我们可以通过 $\mathcal O(n)$ 次询问求出一个极大独立集。

方法为，从 $1 \sim 2n$ 依次尝试加入当前的极大独立集 $S$，如果询问 $(S,x)$ 的答案为 $|S| + 1$，则说明可以加入，否则说明有边。

找到极大独立集之后，对于独立集之外的点，在独立集中二分找到所有边。

此时还剩下独立集之外的点中的边没有找到，那么重复上述过程，直到所有剩下的点都是一个独立集。

由于每个点的度数最多为 $3$，因此每次独立集的大小 $\ge$ 总点数的 $\frac 14$。这意味着每次我们可以将点的规模缩小到原来的 $\frac 34$，那么一共只需要最多重复 $\mathcal O(\log n)$ 次就能找到所有边，因此求最大独立集部分的询问次数为 $\mathcal O(n \log n)$。

又由于每找到一条边需要一次二分，而边数是 $\mathcal O(n)$ 的，所以二分部分也只有 $\mathcal O(n \log n)$ 次询问。

这样我们就可以用 $\mathcal O(n \log n)$ 次询问找到所有边，为了减小常数防止被卡，可以先对点进行 `random_shuffle`。

```cpp
inline int get(int x, vi p) {
	int l = 0, r = p.size() - 1;
	while (l < r) {
		int mid = (l + r) >> 1;
		vi q(1, x);
		for (int i = l; i <= mid; i++) q.pb(p[i]);
		if (Query(q) != (int)q.size()) r = mid;
		else l = mid + 1;
	}
	return p[l];
}

inline int ask(int x, int y, int z) {
	vi p(3);
	p[0] = x, p[1] = y, p[2] = z;
	return Query(p);
}

void Solve(int n) {
	srand(time(0));
	vi A, B;
	for (int i = 1; i <= (n << 1); i++) B.pb(i);
	random_shuffle(B.begin(), B.end());
	vector<vi> e(n << 1 | 1);
	while (B.size()) {
		vi S = B, v(n << 1 | 1);
		A.clear(), B.clear();
		for (int x : S) {
			A.pb(x);
			if (Query(A) != (int)A.size()) A.pop_back(), B.pb(x);
			else v[x] = 1;
		}
		for (int i : B) {
			vi p = A;
			p.pb(i);
			do {
				p.pop_back();
				int k = get(i, p);
				e[k].pb(i), e[i].pb(k);
				for (int &x : p)
					if (x == k) swap(x, p.back());
				p.pop_back();
				p.pb(i);
			} while (Query(p) != (int)p.size());
		}
	}
	vi v(n << 1 | 1);
	vector<map<int, bool>> f(n << 1 | 1);
	for (int x = 1; x <= (n << 1); x++)
		if (e[x].size() == 3u) {
			int y = e[x][0], z = e[x][1], w = e[x][2];
			if (ask(x, y, w) == 1) swap(z, w);
			else if (ask(x, z, w) == 1) swap(y, w);
			f[x][w] = f[w][x] = 1;
		}
	for (int x = 1; x <= (n << 1); x++)
		if (!v[x])
			for (int y : e[x])
				if (!f[x][y]) v[x] = v[y] = 1, Answer(x, y);
}
```

---

## 作者：xiezheyuan (赞：2)

[也许有更好的阅读体验](https://www.xiezheyuan.xyz/oifc/pro/20250622.html#joisc-2020-d-%E3%82%AB%E3%83%A1%E3%83%AC%E3%82%AA%E3%83%B3%E3%81%AE%E6%81%8B-chameleon-s-love)。

## 简要题意

> 这是一道**交互题**。
>
> 有 $2n$ 只变色龙，其中 $n$ 只是雄性，$n$ 只是雌性。具体地，若 $Y_i=0$ 表示变色龙 $i$ 是雌性，否则是雄性。
>
> 第 $i$ 只变色龙的原本颜色是 $C_i$，且喜欢变色龙 $L_i$，$C_i,L_i$ 满足：
> - $Y_i\neq Y_{L_i}, C_i\neq C_{L_i}$，即变色龙只会喜欢和自己颜色不同的异性。
> - $\forall i\neq j, L_i\neq L_j$，即不存在两只变色龙喜欢同一只变色龙。
> - $\forall (i\neq j, Y_i=Y_j), C_i\neq C_j$，即同性变色龙颜色互异。
> - $\forall i, \exists Y_i\neq Y_j, C_i=C_j$，即对于每一只变色龙，都存在一只与其颜色相同的异性变色龙。
>
> 你只知道 $n$ 和关于 $L,C,Y$ 的这些限制。但你不知道 $L,C,Y$ 的具体值。所幸你可以进行最多 $2\times 10^4$ 次询问 `int Query(const vector<int>& p)`，表示组织向量 $p$ 中的所有变色龙开会。若变色龙 $i$ 参加会议，且 $L_i$ 也参加会议，变色龙 $i$ 就会将自己的颜色变成 $C_{L_i}$（不会修改 $L_i$），该函数会返回与会的所有变色龙的颜色数量。
>
> 你需要实现函数 `void Solve(int n)`，通过若干次询问求出每一对同色的异性变色龙，调用 $n$ 次 `void Answer(int a, int b)` 来报告你求出的答案。
>
> 对于 $40\%$ 的测试点，$n\leq 50$。对于 $100\%$ 的测试点，$1\leq n\leq 500$。

## 思路

非常神奇的交互题，使我大脑旋转。

先来考虑 $40$ 分应该怎么做，为了获取尽可能多的有用信息，不妨获取所有 `Query({i, j})` 的答案，记作 $Q(i,j)$。那么容易发现 $Q(i,j)\in \{1, 2\}$。

若 $Q(i,j)=1$，可以发现 $i,j$ 只能是如下关系之一：

- $C_i=C_j$，即 $i,j$ 是同色的异性变色龙。
- $L_i=j,L_j\neq i$，即变色龙 $i$ 喜欢变色龙 $j$，但 $j$ 不喜欢 $i$。
- $L_j=i,L_i\neq j$，即变色龙 $j$ 喜欢变色龙 $i$，但 $i$ 不喜欢 $j$。

我们发现变色龙之间的“同色”是一种双向关系，但是“喜欢”是一种单向关系。无论如何它们都是二元关系，因此可以考虑建图。对于 $C_i=C_j$，我们连一条黑色无向边 $(i,j)$，对于 $L_i=j$，我们连一条绿色有向边 $(i,j)$。那么我们就得到了一张混合图，例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/imxm52qs.png)

如果将每条边都视为无向边，那么我们得到的其实是一张二分图（因为同色的两个变色龙是异性，变色龙也只会喜欢异性变色龙，所以性别就可以看成一组染色）。不妨将两条绿色的蓝边去除，这样子我们就得到了一张简单图，这样的好处是 $Q(i,j)=1$ 表明存在边 $(i,j)$：

![](https://cdn.luogu.com.cn/upload/image_hosting/l6st15jz.png)

对于 $40$ 分的数据，我们可以 $O(n^2)$ 暴力询问出所有 $Q(i,j)$，然后建出这张图，现在只需要关注如何通过这张图来求得答案。

考察每个点的度数，在原图上，每个点的度数应该都是 $3$，但是在新图上则出现了度数为 $1$ 的点，它是双向喜欢关系引起的，我们暂时忽略这些点。对于一个度数为 $3$ 的点 $i$，我们可以找出它的邻域 $\{x,y,z\}$，那么 $x,y,z$ 中一定有一只变色龙与 $i$ 同色，其余的是与 $i$ 间有喜欢 / 被喜欢关系的变色龙。

考虑如何找到那只与 $i$ 同色的变色龙，我们可以尝试挑出两只变色龙 $x,y$ 与 $i$ 一起组织会议，那么实际上有三种情况：

- $C_x=C_i,L_y=i$，即 $x$ 与 $i$ 同色，$y$ 喜欢 $i$。此时组织会议 $y$ 的颜色会变成 $C_i$，$x,i$ 不变，因此询问结果为 $1$。
- $C_x=C_i,L_i=y$，即 $x$ 与 $i$ 同色，$i$ 喜欢 $y$。此时组织会议 $i$ 的颜色会变成 $C_y$，$y,i$ 不变，因此询问结果为 $2$。
- $L_x=i,y=L_i$，即 $x$ 喜欢 $i$，$i$ 喜欢 $y$。此时组织会议 $x$ 的颜色会变成 $C_i$，$i$ 的颜色会变成 $C_y$，$y$ 不变。因此询问结果为 $2$。

那么我们可以通过两次询问中找到一组询问结果为 $1$ 的 $x,y$，此时我们至少可以确定 $L_i=z$，即在原图 / 新图中存在边 $(i,z)$，并且可以发现所有绿色边都可以通过这种方法找到，那么剩下的边自然也就是黑色边了。这一部分只需要 $\sim 2n$ 次询问。

我们发现要想拿到 $100$ 分，关键在于优化建图的过程（因为通过图来求答案不是瓶颈）。

这里就比较需要人类智慧了，我们考察新图的一个独立集，比如 $\{1,3,6,7\}$，那么如果让这些变色龙一起开会，答案肯定就是独立集的大小，但是这个条件并不充要（比如这些可怜的变色龙构成了三角恋或者四角恋之类的）。不过如果采用增量法，这就是显然成立的：

> 引理：对于新图的一个独立集 $I$，对于 $u\not\in I$，$I\cup \{u\}$ 也是独立集当且仅当 $I\cup\{u\}$ 这些变色龙组织会议时，答案恰好为 $|I|+1$。

那么可以通过 $n$ 次询问找出新图的一个独立集：增量法维护当前独立集 $I$，对于尝试加入的点 $u$，若 $I\cup\{u\}$ 的答案是 $|I|+1$，就将 $u$ 加入到 $I$ 中。

由于每个点的度数最多为 $3$，因此加入一个点最多排除之后的三个点，因此这个独立集的大小至少为 $\frac{n}{4}$。

独立集中肯定是没有边的，因此我们实际上给规模乘上了 $\frac{3}{4}$，不过还需要处理一下其他点连向独立集的边。

考虑枚举 $\overline{I}$ 中的每个点 $u$，考察 $u,I$ 之间有哪些边。注意到判定独立集 $I$ 的非空子集一定也是独立集，且判断独立集 $I'$ 与 $u$ 间有没有边，等价于判断 $I'\cup \{u\}$ 是否是独立集，因此可以进行若干次二分来找到所有与 $u$ 相连的独立集上的点，因此也就确定了这些边。

于是我们成功将规模为 $n$ 的问题，以 $O(n\log n)$ 的询问次数，$O(n^2\log n)$ 的时间复杂度归约到了一个规模为 $\frac{3}{4}n$ 的问题。因此我们可以删去独立集，重复上述操作直至点集为空。这样就询问出了新图的所有边。

分析一下总询问次数和时间复杂度。对于总询问次数，有 $T(n)=T(\frac{3}{4}n)+O(n\log n)=O(n\log n)$，对于时间复杂度有 $T(n)=T(\frac{3}{4} n)+O(n^2\log n)=O(n^2\log n)$，这大致是可以接受的（我的实现中，实测最大询问次数为 $18866$ 刚好可以通过）。

## 代码

```cpp
#include <bits/stdc++.h>
#define impl extern "C"
using namespace std;

const int N = 1005;
int g[N][N];

vector<int> join(vector<int> a, int b){ return a.push_back(b), a; }

impl int Query(const vector<int> &p);
impl void Answer(int a, int b);

int find(const vector<int>& p, int x){
    int l = 0, r = p.size() - 1;
    assert(p.size());
    while(l < r){
        int mid = (l + r) >> 1;
        vector<int> vct(p.begin(), p.begin() + mid + 1);
        if(Query(join(vct, x)) == (int)vct.size() + 1) l = mid + 1;
        else r = mid;
    }
    return p[l];
}

impl void Solve(int n){
    vector<int> proc(n << 1);
    iota(proc.begin(), proc.end(), 1);
    while(!proc.empty()){
        vector<int> ind, nind;
        for(int i : proc) (Query(join(ind, i)) == (int)ind.size() + 1 ? ind : nind).push_back(i);
        for(int u : nind){
            vector<int> S = ind;
            while(Query(join(S, u)) != (int)S.size() + 1){
                int v = find(S, u); g[u][v] = g[v][u] = 1;
                S.erase(find(S.begin(), S.end(), v));
            }
        }
        proc = nind;
    }
    for(int i=1;i<=(n<<1);i++){
        int ngb[3], t = 0;
        for(int j=1;j<=(n<<1);j++) if(g[i][j]) ngb[t++] = j;
        if(t == 1) continue;
        auto query = [&](int x, int y, int z){
            if(Query({i, x, y}) == 1) return g[i][z] = g[z][i] = 2, 0;
            return 1;
        };
        auto [x, y, z] = ngb;
        if(query(x, y, z)) if(query(x, z, y)) g[i][x] = g[x][i] = 2;
    }
    for(int i=1;i<=(n<<1);i++){
        for(int j=1;j<i;j++) if(g[i][j] == 1) Answer(i, j);
    }
}

// Written by xiezheyuan
```

---

## 作者：flyfreemrn (赞：1)

## [[JOISC 2020] カメレオンの恋](https://www.luogu.com.cn/problem/P7211)

逆天交互题。

### 考虑构造答案

先考虑不关心交互次数的暴力写法，我们可以用 $n^2$ 次查询找到和一个点 **相关** 的所有点，这里相关的定义是 $Query(x, y) = 1$ 即 $x,y$ 在同一场两人会议里时颜色相同。我们把这些相关点之间连边。

可以考虑什么时候两个点是相关的：
1. $x,y$ 颜色相同，此时在 $x,y$ 之间连双向边。
2. $x$ 喜欢 $y$，此时 $x \rightarrow y$ 连单向边。
3. $y$ 喜欢 $x$，此时 $y \rightarrow x$ 连单向边。

我们就知道了和一个点有连边的所有点，问题转化为找所有边中的双向边。

观察图的形态，每个点的度数 **要么为 1 要么为 3**。当一个人 $x$ 喜欢 $y$ 且 $y$ 喜欢 $x$ 时，查询 $x,y$ 时的结果一定是不相关，所以 $x,y$ 各少了两条边，因此对于度数为 1 的情况我们可以直接找到双向边。

当度数等于 3 时，我们把三个点取出来，根据上面的讨论记为 $x,y,z$，如果我们两两一组和 $i$ 一起查询，就会发现只有查询 $\{i, x, z\}$ 时答案是 2，虽然我们没法确定哪个点是 $x$ 或 $z$，但我们知道剩下那个点一定是 $y$，也就是知道了 $i$ 喜欢的人。

这样我们对 $n$ 个点都查询一遍，就能知道所有的有向边，那么剩下的边就是无向边，这个过程是 $O(n)$ 的，找边是 $O(n^2)$ 的，可以拿到 40pts。

### 找边

上面的过程中复杂度的瓶颈在于找边的过程。

交互题中，一个经典的优化方案就是把找信息的过程变成二分，我们需要构造一个序列使得我们可以让每一个点在上面二分找边。

这个序列怎么构造呢？首先要能够判断区间是否有点和 $x$ 连边，根据操作的性质可知独立集构成的序列是满足这个条件的，我们可以每次找出一个极大点独立集，然后用剩下的点找和点独立集中连的边，之后删除独立集继续找。

一个点最多有三条连边，所以剩下的点极大独立集大小至少是点集的 $\frac{1}{4}$，每次找独立集都能把点集压缩到原来的 $\frac{3}{4}$，这样我们就用 $n\log n$ 的查询找出了所有的独立集。而二分找边的过程，每条边需要 $\log n$ 次查询，而一共有 $O(n)$ 级别的边，所以二分过程的查询次数为 $n\log n$。

综上，总复杂度为 $O(n\log n)$ 可以解决这道题。

~~~
#include<bits/stdc++.h>
using namespace std;
#define LOCAL
#define ll long long
#define pir pair <ll,ll>
#define fs first
#define sc second
inline ll read(){
    ll f = 1, num = 0;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c=='-') f = -1;c = getchar();
    }
    while(c>='0'&&c<='9') num = num * 10 + c - '0', c = getchar();
    return num * f;
}
extern "C" int Query(const std::vector<int> &p);
extern "C" void Answer(int a, int b);
ll mp[1010][1010];

// 二分找到独立集 ids 中和 u 有连边的第一个点
ll finde(ll u, vector <int> ids){
    ll l = 0,r = ids.size() - 1;
    while(r > l){
        ll mid = (l + r) >> 1;
        vector <int> qs;
        for(int j = l;j <= mid; ++j)qs.push_back(ids[j]);
        qs.push_back(u);
        if(Query(qs) != qs.size())r = mid;
        else l = mid + 1;
    }
    return ids[l];
}

extern "C" void Solve(int N) {
    // 这里偷个懒，直接用 set 存点。
    set <int> st;
    for(int i = 1;i <= N * 2; ++i){
        st.insert(i);
    }

    while(!st.empty()){
        // 找剩下的点中的极大独立集
        vector <int> ids;
        for(auto y : st){
            int stp = ids.size();
            ids.push_back(y);
            if(Query(ids) < ids.size())ids.pop_back();
        }

        // 删掉极大独立集
        for(auto y : ids){
            st.erase(y);
        }

        for(auto y : st){
            ll nw = y;
            vector <int> qs = ids;
            qs.push_back(nw);
            while(Query(qs) != qs.size()){// 发现还有连边
                qs.pop_back();
                // 找到连边的点 s
                ll s = finde(nw, qs);
                mp[s][nw] = mp[nw][s] = 1;
                // 删掉 s
                for(int i = 0;i < qs.size(); ++i){
                    if(qs[i] == s){
                        swap(qs[i], qs.back());
                        break;
                    }
                }
                qs.pop_back();
                qs.push_back(nw);
            }
        }
    }

    for(int i = 1;i <= N * 2; ++i){
        vector <int> vec;
        for(int j = 1;j <= N * 2; ++j){
            if(i == j)continue;
            if(mp[i][j])vec.push_back(j);
        }

        if(vec.size() == 1)continue;//直接找到双向边
        if(vec.size() != 3){
            cout << "-1\n";
            return;
        }
        int x = vec[0],y = vec[1],z = vec[2];

        bool res = false;
        if(!res){// xy
            vector <int> qs(3);qs = {i, x, y};
            if(Query(qs) == 1)mp[i][z] = mp[z][i] = 2,res = true;
        }

        if(!res){// yz
            vector <int> qs(3);qs = {i, y, z};
            if(Query(qs) == 1)mp[i][x] = mp[x][i] = 2;
        }

        if(!res){// xz
            vector <int> qs(3);qs = {i, x, z};
            if(Query(qs) == 1)mp[i][y] = mp[y][i] = 2;
        }
    }

    for(int i = 1;i <= N * 2; ++i){
        for(int j = i + 1;j <= N * 2; ++j){
            if(mp[i][j] == 1)Answer(i, j);
        }
    }

}
~~~

---

## 作者：TTpandaS (赞：1)

考虑每只变色龙 $x$ 与满足与 $x$ 参加一个会议，总颜色数只会有一种的变色龙 $y$ 连边。所以每只变色龙只可能与三只变色龙连边。

如果与三只连边，说明跟与 $x$ 同色的变色龙，喜欢 $x$ 的变色龙还有 $x$ 喜欢的变色龙连了边。令与 $x$ 同色的变色龙为 $w$， 喜欢 $x$ 的变色龙为 $y$，$x$ 喜欢的变色龙为 $z$，那么如果 $x,y,w$ 参加同一场会议，一定只会有一种颜色，此时就可以分辨出另一只为 $x$ 喜欢的变色龙 $z$，那么将 $x$ 与 $z$ 的连边删去即可。

考虑如何减少连边时查询的次数。考虑如果 $x$ 与一个内部无连边集合 $S$ 连边，那么可以直接分治，每次判断集合的一部分加上 $x$ 后是否产生连边，来找到与 $x$ 连边的点有哪些。

一个内部无连边集合 $S$ 即二分图中的 X 部和 Y 部，那么动态维护一下依次加点之后的 X 部和 Y 部，然后可以在 $n \log n$ 次左右查询找到每条连边。

---

## 作者：7KByte (赞：1)

奇奇怪怪的交互题。

有 $2N$ 只变色龙，每条变色龙有一个性别，一个颜色，和一个喜欢的颜色不同的异性。其中恰好 $N$ 男 $N$ 女，$N$ 种颜色每种颜色恰好两条变色龙。

每次可以选一些变色龙出来，如果第 $i$ 条龙和它喜欢的龙同时被选了，那么它就变成喜欢龙的颜色，否则不变，返回变色后的颜色数。

$N\le 500$ ，需要在 $20000$ 次询问内求出颜色相同的每一对龙。

对于子任务 $1$ ，所有变色龙都是双向喜欢。那么查询所有二元组 $(i,j)$ ，如果返回 $1$ 则 $i,j$ 颜色相同，否则颜色不同。因为如果互相或互相不喜欢，颜色总数都不变。

对于子任务 $2,3$ ，延续子任务 $1$ 的思路，查询所有二元组，如果返回 $1$ ，手玩一下发现有三种情况。第一种是两者颜色相同，第二种是 $i$ 单向喜欢 $j$ ，或者是 $j$ 单向喜欢 $i$ 。我们在 $i,j$ 之间连边，一个点的入度为 $1$ 或 $3$ 。

入度为 $1$ ，则与之连边的点和它颜色相同。

入度为 $3$，我们找到与之相连的三个点中的两个点，查询当前点和这两个点的集合，如果返回 $1$ ，则当前点一定单向喜欢第三个点。

这样我们可以在 $\mathcal{O}(N^2)$ 次询问内找出答案。

对于子任务 $4$ ，我们发现瓶颈在于连边的过程，而这个子任务中已知性别。

显然连边后的图一定是二分图，因为无论是喜欢关系还是相等关系都是异性之间。

那么对于 $X$ 中的点，可以快速在 $Y$ 中二分出连边的三个点，同理对于 $Y$ 中的点，可以快速在 $X$ 中二分出连边的三个点。这样询问次数是 $\mathcal{O}(N\log N)$。

对于子任务 $4$，依次考虑每个点 $i$ 。首先我们建出前 $i-1$ 个点的图，这一定是二分图，那么第 $i$ 个点在二分图的 $X$ 部和 $Y$ 部通过二分快速连边。

随着点的加入二分图的 $X$ 部和 $Y$ 部会变化，所以每次都要重新 DFS 染色。时间复杂度 $\mathcal{O}(N^2\log N)$ ，询问次数 $\mathcal{O}(N\log N)$ 。

```cpp
#include<bits/stdc++.h>
#include "chameleon.h"
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 1005
using namespace std;
int v[N],ot[N],in[N];vector<int>c[2],a[N];
int ask(vector<int>p,int w,int l,int r){
	vector<int>cur;cur.push_back(w);
	rep(i,l,r)cur.push_back(p[i-1]);
	return Query(cur);
}
void dfs(int x,int op){
	v[x]=1;c[op].push_back(x);
	for(int i=0;i<(int)a[x].size();i++)
		if(!v[a[x][i]])dfs(a[x][i],1-op);
}
void calc(vector<int>u,int x){
	if(!u.size())return;
	int st=1,sz=u.size();
	rep(op,0,2){
		if(st>sz||ask(u,x,st,sz)==sz-st+2)return;
		int l=st,r=sz,ed=0;
		while(l<=r){
			int mid=(l+r)>>1;
			if(ask(u,x,st,mid)<=mid-st+1)ed=mid,r=mid-1;
			else l=mid+1;
		}
		a[x].push_back(u[ed-1]);a[u[ed-1]].push_back(x);st=ed+1;
	}
}
int qry(int x,int y,int z){
	vector<int>u;
	u.push_back(x);u.push_back(y);u.push_back(z);
	return Query(u);
}
void solve(int x){
	if(a[x].size()>2){
		int i=a[x][0],j=a[x][1],k=a[x][2];
		if(qry(x,i,j)==1)ot[x]=k,in[k]=x;
		else if(qry(x,j,k)==1)ot[x]=i,in[i]=x;
		else ot[x]=j,in[j]=x;
	}
}
void Solve(int n){
	rep(i,2,n*2){
		memset(v,0,sizeof(v));
		c[0].clear();c[1].clear();
		rep(j,1,i-1)if(!v[j])dfs(j,0);
		calc(c[0],i);calc(c[1],i);
	}
	memset(v,0,sizeof(v));
	rep(i,1,n*2)solve(i);
	rep(i,1,n*2)if(!v[i]){
		if(in[i]){
			int cur=0;
			for(int j=0;j<=2;j++)if(a[i][j]!=in[i]&&a[i][j]!=ot[i])cur=a[i][j];
			Answer(i,cur);v[i]=v[cur]=1;
		}
		else Answer(i,a[i][0]),v[i]=v[a[i][0]]=1;
	}
}
```

---

## 作者：Sol1 (赞：0)

考虑建一个无向图，$u,v$ 之间有边当且仅当询问 $\{u,v\}$ 的结果为 $1$。那么对于一对双向奔赴的关系，则两侧的点的度数均为 $1$；其他点的度数均为 $3$。

由于自己和自己喜欢的一定不同色，所以对于 1 度点，直接找唯一的相邻的边就是答案。对于一个 3 度点，经过枚举可以发现如果从这个大小为 4 的邻域中询问 3 个点，那么当且仅当询问到「自己、喜欢自己的、和自己同色的」时答案为 1，于是可以找到自己喜欢的。

所以在得到图之后，可以使用至多 $3000$ 次操作找出所有的喜欢关系，于是可以得到答案。问题变为使用至多 $17000$ 次操作建出该无向图。

考虑一个暴力：维护一个点集 $S$，初始为空。依次考虑点 $u$，如果询问 $S\cup\{u\}$ 的结果是 $|S|+1$，说明 $u$ 到 $S$ 中没有边，将 $u$ 加入 $S$。遍历所有点后，对于所有不在 $S$ 中的点（设这些点构成点集 $T$），可以在 $S$ 内部二分找到其所有连向 $S$ 内部的边。最后，我们确定 $S$ 内部没有边，并找到了所有 $S,T$ 之间的边，然后直接对 $T$ 递归做。

下面我们证明这个暴力足以通过这道题。

首先每一个点的度数最多是 3，于是有 $3|S|\geq |T|$，变形得 $|T|\leq \dfrac{3}{4}(|S|+|T|)$，于是每次递归问题规模至少缩小到原来的 $\dfrac{3}{4}$。因此对大小为 $n$ 的集合，递归过程消耗的查询次数满足 $T(n)=n+T\left(\dfrac{3}{4}n\right)$，可以解得 $T(n)=4n$，于是这部分消耗 $T(2n)=8n$ 的代价。

同时每条边只贡献一次二分的代价，于是消耗 $1500\log n$。

这样算出来需要 $19000$ 次，仍然过大。但是我们不难观察到这个 $8n$ 和 $1500\log n$ 之间存在相互制约关系。具体来说，让边数代价最大的情况显然是第一层递归直接找到所有边。设第一层找到的独立集为 $S$，那么代价是 $1500\log |S|+1000+4(1000-|S|)$（log 不需要上取整是因为每个点度数为 3 保证二分的终点分布足够均匀），解出最大值是 $16500$ 左右，于是总交互次数就被控制到了 $19500$ 以下，于是就可以通过。

时间复杂度 $O(n^2\log n)$，交互次数 $O(n\log n)$。实际最大点交互次数不到 $19000$。

```cpp
namespace So1stice {
	const int MXN = 1005;
	int n;
	bool suki[MXN][MXN], vis[MXN];
	vector <int> g[MXN];

	inline int findEdge(const vector <int> &t, int bl, int s) {
		vector <int> tmp;
		for (int i = bl;i < t.size();i++) tmp.push_back(t[i]);
		tmp.push_back(s);
		if (Query(tmp) == tmp.size()) return -1;
		int l = bl, r = t.size() - 1;
		while (l < r) {
			int mid = l + r >> 1;
			vector <int> tmp;
			for (int i = l;i <= mid;i++) tmp.push_back(t[i]);
			tmp.push_back(s);
			if (Query(tmp) != tmp.size()) r = mid;
			else l = mid + 1;
		}
		return l;
	}

	inline void buildGraph(const vector <int> &v) {
		if (v.size() <= 1) return;
		vector <int> iso, nxt;
		for (int x : v) {
			iso.push_back(x);
			if (Query(iso) < iso.size()) {
				iso.pop_back();
				nxt.push_back(x);
			}
		}
		for (int x : nxt) {
			int p = 0, l;
			while ((l = findEdge(iso, p, x)) != -1) {
				g[x].push_back(iso[l]);
				g[iso[l]].push_back(x);
				p = l + 1;
			}
		}
		buildGraph(nxt);
	}

	inline void Work() {
		vector <int> bg;
		for (int i = 1;i <= 2 * n;i++) bg.push_back(i);
		buildGraph(bg);
		for (int i = 1;i <= 2 * n;i++) {
			if (g[i].size() == 3) {
				for (int a = 0;a < g[i].size();a++) {
					for (int b = a + 1;b < g[i].size();b++) {
						vector <int> tmp;
						tmp.push_back(g[i][a]); tmp.push_back(i); tmp.push_back(g[i][b]);
						if (Query(tmp) == 1) {
							suki[g[i][0] + g[i][1] + g[i][2] - g[i][a] - g[i][b]][i] = 1;
							suki[i][g[i][0] + g[i][1] + g[i][2] - g[i][a] - g[i][b]] = 1;
							goto done;
						}
					}
				}
			}
			done:;
		}
		for (int i = 1;i <= 2 * n;i++) {
			if (!vis[i]) {
				for (int v : g[i]) {
					if (!suki[i][v] && !suki[v][i]) {
						Answer(v, i);
						vis[i] = vis[v] = 1;
						break;
					}
				}
			}
		}
	}
}

void Solve(int N) {
	So1stice::n = N;
	So1stice::Work();
}
```

---


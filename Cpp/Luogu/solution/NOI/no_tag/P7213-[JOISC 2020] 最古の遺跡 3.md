# [JOISC 2020] 最古の遺跡 3

## 题目背景

JOI 教授是一名研究 IOI 王国的历史学家。

## 题目描述

他发现了一行古代石柱的废墟及一份古代文献。

古代文献上的记载如下：
- 刚建造完成的时候，有 $2\times N$ 个石柱，对于 $1\le k\le N$ 均有两个石柱高度为 $k$，同时记第 $i$ 个石柱的高度为 $h_i$。
- 会发生 $N$ 次地震，每次地震会使一些石柱的高度 $-1$，其他石柱高度不变。
- 石柱 $i$ 地震时高度不变，当且仅当 $h_i\ge 1$ 并且对于 $j>i$ 都要有 $h_i\not=h_j$
- $N$ 次地震后，恰好只剩下了 $N$ 个石柱。

现在 JOI 教授找出了仅存的 $N$ 个石柱的位置 $A_1,A_2,\ldots,A_N$，他想让你求出，最初 $2\times N$ 个石柱高度的修建方案数 $\bmod~10^9+7$ 的值。

## 说明/提示

#### 样例解释
#### 样例 1 解释
一种可行的解为 $(2,2,3,3,1,1)$。
- 第一次地震后，变为 $(1,2,2,3,0,1)$。
- 第二次地震后，变为 $(0,1,2,3,0,1)$。
- 第三次地震后，变为 $(0,0,2,3,0,1)$。

另外四种解如下：
- $(2,3,2,3,1,1)$。
- $(2,3,3,2,1,1)$。
- $(3,2,2,3,1,1)$.
- $(3,2,3,2,1,1)$。
#### 样例 2 解释
对于 $N=1$ 的情况，显然只有 $(1,1)$ 一种修建方案，在一次地震后，会变为 $(0,1)$，$1$ 号位置不可能有石柱。
#### 样例 3 解释
共有 $111147004440$ 种可能的修建方案，$111147004440 \bmod 10^9+7=147003663$。
#### 子任务
对于 $100\%$ 的数据，保证 $1\le N\le 600$，$1\le A_i\le 2\times N$，$A_i< A_{i+1}$。
| Subtask 编号 | $N\le$ | 分数 |
| :-: |:-: | :-: |
| $1$ | $13$ | $6$
| $2$| $60$ | $52$
| $3$ | 无 | $42$
#### 说明
本题译自 [第 19 回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) Day 2 [T3 最古の遺跡 3](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day2/ruins3-en.pdf)。

## 样例 #1

### 输入

```
3
3 4 6```

### 输出

```
5```

## 样例 #2

### 输入

```
1
1```

### 输出

```
0```

## 样例 #3

### 输入

```
10
5 8 9 13 15 16 17 18 19 20```

### 输出

```
147003663```

# 题解

## 作者：crashed (赞：27)

# 题目

[点这里](https://loj.ac/p/3276)看题目。

# 分析

~~懂了懂了，数数题都是毒瘤。~~

考虑我们可以怎么去震柱子。显然我们可以从高往低去震，~~但是这样分析无法导出一个解法~~。

另一个方式就是从后往前去震；这样我们可以导出一个结论：

> 如果当前柱子之后有高度为 $1\sim h$ 的柱子各一根，那么当前柱子及之前的柱子，如果高度 $\le h$，都会被直接震没。

因此我们可以将最大的 $h$ 看作 " 高度阈值 " ，把那 $1\sim h$ 的 $h$ 个柱子称为 " 标准柱 " 。

---

考虑一个 DP ：

 $f_{i,j}$ 表示后 $i$ 个柱子，此时高度阈值为 $j$ 时的方案数。

为了便于转移，设两个参数 $c_0$ 为后 $i-1$ 个柱子中钦定消失的数量，$c_1$ 为钦定存在的数量。

此外，我们需要区分一下同样高度的两个柱子（比如染色）以便转移，最终答案就需要除掉 $2^n$。

分类讨论一下转移：

- 如果 $i$ 钦定消失，那么阈值不变，从 $f_{i-1,j}$ 转移。

  此时有 $2j$ 个可用高度，其中有 $j$ 个分配给了标准柱，还有 $c_0$ 个已经分配，所以系数为 $j-c_0$。

- 如果 $i$ 钦定保留，我们同样考虑它的高度：

  - 如果 $i$ 的高度 $> j+1$，我们就稍后考虑它的真实高度，此时从 $f_{i-1,j}$ 转移，系数为 1。

  - 如果 $i$ 的高度为 $j+1$，由于有些标准柱的高度还未确定，所以我们需要考虑接起来之后的高度阈值。

    枚举一个新阈值 $k$，此时是从 $f_{i-1,j}$ 转移到 $f_{i,k}$。

    计算系数，有如下几个部分：

    - 选定标准柱的位置 $\binom{c_1-j}{k-j-1}$。
    - 确定当前柱子的长度 $k-j+1$，分析方式同第一种转移。
    - 考虑未确定的 $k-j-1$ 的形成过程，这里我们用 $g_{k-j-1}$ 表示。

    因此系数为 $\binom{c_1-j}{k-j-1}\times g_{k-j-1}\times (k-j+1)$。

现在我们考虑 $g$ 的转移，明确 $g$ 的含义为 " 将 $n$ 个石柱震为高度连续的（初始）状态数 " 。

其实这个过程很类似于 $f$ 的第二种转移。我们只需要枚举一下编号最小的柱子的高度：
$$
g_n=\sum_{i=1}^{n}\binom{n-1}{i-1}\times (i+1)\times g_{i-1}\times g_{n-i}
$$
这样做的时间复杂度即 $O(n^3)$。


# 代码

```cpp
#include <cstdio>

#define rep( i, a, b ) for( int i = (a) ; i <= (b) ; i ++ )
#define per( i, a, b ) for( int i = (a) ; i >= (b) ; i -- )

typedef long long LL;

const int mod = 1e9 + 7, inv2 = ( mod + 1 ) >> 1;
const int MAXN = 2e3 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

int f[MAXN][MAXN];
int g[MAXN];

int C[MAXN][MAXN];
int N, M;
bool save[MAXN];

inline int Mul( LL x, int v ) { return x * v % mod; }
inline int Sub( int x, int v ) { return ( x -= v ) < 0 ? x + mod : x; }
inline int Add( int x, int v ) { return ( x += v ) >= mod ? x - mod : x; }

void Init()
{
	rep( i, 0, M )
	{
		C[i][0] = C[i][i] = 1;
		rep( j, 1, i - 1 )
			C[i][j] = Add( C[i - 1][j], C[i - 1][j - 1] );
	}
}

int main()
{
	read( N );
	rep( i, 1, N ) { int a;
		read( a ), save[a] = true;
	}
	M = N << 1, Init();
	
	g[0] = 1;
	rep( i, 1, M ) rep( j, 1, M )
		g[i] = Add( g[i], Mul( C[i - 1][j - 1], Mul( j + 1, Mul( g[j - 1], g[i - j] ) ) ) );
	f[M + 1][0] = 1; int c0 = 0, c1 = 0;
	per( i, M, 1 ) 
		if( save[i] )
		{
			c1 ++;
			rep( j, c0, c1 - 1 )
			{
				f[i][j] = Add( f[i][j], f[i + 1][j] );
				rep( k, 1, c1 - j )
					f[i][j + k] = Add( f[i][j + k], Mul( f[i + 1][j], Mul( C[c1 - j - 1][k - 1], Mul( g[k - 1], k + 1 ) ) ) );
			}
		}
		else
		{
			c0 ++;
			rep( j, c0, c1 )
				f[i][j] = Add( f[i][j], Mul( f[i + 1][j], j - c0 + 1 ) );
		}
	rep( i, 1, N ) f[1][N] = Mul( f[1][N], inv2 );
	write( f[1][N] ), putchar( '\n' );
	return 0;
}
```


---

## 作者：_sys (赞：9)

我们考虑一个位置能够被留住的条件。可知其只与这个位置后面的数有关。如果当前位置为 $x$，而后面会有 $x \sim x - k$，则 $x$ 会下降到 $x - k - 1$。

那么我们可以得到一个算法，给定 $h$，得到 $A$：初始时令一个序列 $B$ 全为 $0$。$i$ 从 $2N$ 到 $1$ 降序枚举，考虑将 $h_i$ 加入序列 $B$，从 $h_i$ 到 $1$ 枚举 $j$，若 $B_j$ 为 $0$，则在这里填入 $i$。如果没有这样的位置，则其不在 $A$ 中。最后便是 $A_{B_i} = i$。

所以每个位置是否存活取决于 $\textrm{mex}\ B$ 与 $h_i$ 的大小关系。我们可以由此得到一个递推做法。

设 $f_{i, j}$ 表示 $2N$ 到 $i$，$\textrm{mex}=j+1$ 的方案数。则答案为 $f_{1, N}$。

* 若 $i$ 没有在 $A$ 中出现过，则 $j\geq h_i$，$\textrm{mex}$ 不会改变。有

$$f_{i, j}\leftarrow cf_{i+1, j}$$

其中 $c$ 为 $[1, j]$ 中可以放的数字个数，等于 $j - (2N-i - s)$，$s$ 为 $[i + 1, 2N]$ 中存活的位置的个数。为了能够这样统计，我们需要将 $h$ 相同的两个元素当作**有标号的**，最后将答案除以 $2^n$。否则会需要更多的信息才能算出这里的 $c$。

* 若 $i$ 出现过，且没有改变 $\textrm{mex}$，我们将它的贡献**后延**，直到 $\textrm{mex}$ 改变时统计。

  $$f_{i, j} \leftarrow f_{i+1, j}$$

* 若 $\textrm{mex}$ 改变了，考虑新的 $\textrm{mex}=j+k$，则现在需要在那些**后延了贡献**的位置中选出 $k-1$ 个。这些位置需要满足
  * $\leq j+s$ 的数不得超过 $s$ 个。否则就会有人走到 $0$。
  * 每个数都不超过 $j+k$。

发现这个过程其实和 $j$ 无关。设辅助数组 $g_k$ 表示 $1, 1, 2, 2, \ldots, k, k$ 这些数选出 $k$ 个，满足 $\leq s$ 的数不得超过 $s$ 个的方案数。$g$ 该怎么求呢？其实和 $f$ 的想法是类似的。只不过现在没有第一种（不在 $A$ 中出现）的情况了。考虑最后一个插入的数显然不会后延，假设其最终到了 $x + 1$，那么它最初有可能是 $[x + 1, k]$，$x + 1$ 还剩两个可选，$[x + 2, k]$ 还剩一个，所以共有 $k-x+1$ 种可能。并且此时前 $x$ 个和后 $k - x - 1$ 个是独立的。我们由此可以得到递推式

$$g_k = \sum_{x=0}^{k-1} \binom{k-1}x g_x g_{k - x - 1}(k - x + 1)$$

$$f_{i, j+k}\leftarrow \sum_{k=j+1}^s \binom {s-j-1}{k-j-1}f_{i+1, j}g_{k-j-1}(k-j+1)$$

时间复杂度 $O(N^3)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int Maxn = 1205, p = 1e9 + 7;
int n, sum, a[Maxn], C[Maxn][Maxn];
long long g[Maxn], fac[Maxn], finv[Maxn], f[Maxn][Maxn];
bool vis[Maxn];
long long get_inv(int x)
{
	return x <= 1 ? 1 : (p - p / x) * get_inv(p % x) % p;
}
int main()
{
	scanf("%d", &n);
	C[0][0] = 1;
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]), vis[a[i]] = true;
	fac[0] = finv[0] = 1;
	for (int i = 1; i <= 2 * n; i++)
	{
		fac[i] = fac[i - 1] * i % p;
		finv[i] = get_inv(fac[i]);
		C[i][0] = 1;
		for (int j = 1; j <= i; j++)
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % p;
	}
	f[2 * n + 1][0] = 1;
	g[0] = 1;
	for (int i = 1; i <= n; i++)
		for (int j = 0; j < i; j++)
			(g[i] += g[j] * g[i - j - 1] % p * C[i - 1][j] % p * (i - j + 1)) %= p;
	for (int i = 2 * n; i >= 1; i--)
	{
		if (vis[i])
		{
			sum++;
			for (int j = 0; j <= n; j++)
			{
				(f[i][j] += f[i + 1][j]) %= p;
				for (int k = j + 1; k <= sum; k++)
					(f[i][k] += f[i + 1][j] * C[sum - j - 1][k - j - 1] % p * g[k - j - 1] % p * (k - j + 1)) %= p;
			}
		}
		else
			for (int j = n; j - (2 * n - i - sum) > 0; j--)
				(f[i][j] += f[i + 1][j] * (j - (2 * n - i - sum))) %= p;
	}
	for (int i = 1; i <= n; i++)
		(f[1][n] *= (p + 1) / 2) %= p;
	printf("%lld", f[1][n]);
	return 0;
}
```

---

## 作者：璀璨星空1 (赞：8)

|  $\blacksquare$  |     $\blacksquare$     | $\blacksquare$  |  $\blacksquare$  |       $\blacksquare$        |    $\blacksquare$    | $\square$ | $\square$ | $\blacksquare$  | $\blacksquare$  | $\square$ | $\square$ |  $\blacksquare$  |  $\blacksquare$  |     $\blacksquare$      | $\square$ | $\square$ | $\square$ |      $\blacksquare$       | $\square$ | $\square$ | $\square$ | $\square$ | $\square$ |
| :--------------: | :--------------------: | :-------------: | :--------------: | :-------------------------: | :------------------: | :-------: | :-------: | :-------------: | :-------------: | :-------: | :-------: | :--------------: | :--------------: | :---------------------: | :-------: | :-------: | :-------: | :-----------------------: | :-------: | :-------: | :-------: | :-------: | :-------: |
|       $8$        |          $2$           |       $6$       |       $10$       |             $2$             |         $6$          |    $1$    |    $1$    |       $4$       |       $5$       |    $5$    |    $3$    |       $10$       |       $11$       |          $11$           |    $9$    |    $7$    |    $4$    |           $12$            |    $8$    |   $12$    |    $9$    |    $7$    |    $3$    |
| $\color{blue}11$ | $\color{yellowgreen}2$ | $\color{teal}6$ | $\color{blue}11$ | $\color{yellowgreen}\bold2$ | $\color{teal}\bold6$ |    $2$    |    $2$    | $\color{teal}6$ | $\color{teal}6$ |    $6$    |    $6$    | $\color{blue}11$ | $\color{blue}11$ | $\color{blue}\bold{11}$ |   $11$    |   $11$    |   $11$    | $\color{purple}\bold{12}$ |   $12$    |   $12$    |   $12$    |   $12$    |   $12$    |

------------

首先翻转下标，地震时石柱高度不变当且仅当，其**前缀**中没有与该石柱高度一样的.

由于 $n$ 次地震分别震掉了高度为 $n,n-1,n-2,\cdots,1$ 的石柱，因此在第 $n+1$ 次以后再进行地震也毫无影响，我们可以直接视作地震 $+\infty$ 次，考虑**从前往后确定**石柱高度的变化.

对于第 $i$ 个石柱而言，设 $a_i$ 表示其原来的高度、$a'_i$ 表示其最终的高度，那么我们得到一个结论：$a'_i$ 应该等于 $\leq a_i$ 的**最大**的在 $\{a'_1,a'_2,\cdots,a'_{i-1}\}$ 中**未出现过**的正整数(如果 $\leq a_i$ 中的正整数都出现过则 $a'_i=0$).

考虑 $a_i$，若 $a'_p=a_i$，那么总有一个时刻第 $p$ 个石柱被震到 $a_i$，此刻如果第 $i$ 个石柱还没有被震，那么第 $p$ 个石柱会**被保护**而第 $i$ 个石柱不会，因此 $a_i$ 会被震到 $a_i-1$；再沿用上述结论依次类推，即可得证.

------------

上述表格中的第一行描述对应石柱有无被**钦定**留下(简称黑色/白色)，第二行描述对应石柱的**初始**高度.

定义集合 $S$ 的**覆盖值**表示最大的 $x$，使得 $\leq x$ 的正整数都在 $S$ 中出现过，那么 $a_i$ 是黑色等价于 $a_i$ 大于 $\{a'_1,a'_2,\cdots,a'_{i-1}\}$ 的覆盖值，反之是白色，等价于 $a_i$ **小于等于** $\{a'_1,a'_2,\cdots,a'_{i-1}\}$ 的覆盖值.

设 $\tau_i$ 表示 $\{a'_1,a'_2,\cdots,a'_{i}\}$ 的覆盖值，对于黑色位置 $i$，如果 $\tau_i\neq\tau_{i-1}$，我们就在表格中的第三行用一种**加粗的**新的颜色标注出 $\tau_i$，并且将所有对 $\tau_i$ **产生了贡献**的黑色位置 $j$ 也都用该种颜色标注出 $\tau_i$.

所谓产生了贡献，说的就是 $a'_j\in(\tau_{i-1},\tau_i]$，例如上述例子中的黑色位置 $3,6,9,10$、其 $a'_j$ 分别是 $6,5,4,3$、均 $\in[3,6]$、并且覆盖了 $[3,6]$ 这整个区间，又例如黑色位置 $1,4,13,14,15$ 的 $8,10,9,11,7$ 也是一样的；显然由于 $\tau_i\neq\tau_{i-1}$，必有 $a'_i=\tau_i$，否则 $\tau_{i-1}$ 肯定**早就**已经被升上去了.

------------

基于覆盖值，我们可以设计**动态规划**：令 $F_{i,x}$ 表示**填完**了前 $i$ 个位置，使得 $\{a'_1,a'_2,\cdots,a'_i\}$ 的覆盖值**恰好等于** $x$ 的方案数；为了方便转移，我们设高度相同的两个石柱是**有区别的**，最后答案就要**除以** $2^n$.

考虑第 $i$ 个石柱应该填什么，从 $F_{i-1}$ **正向转移**到 $F_i$.

- 若第 $i$ 个石柱被钦定保留：

  - 若 $\tau_i\neq\tau_{i-1}$、即**产生了**加粗的新的颜色：

    设 $\tau_{i-1}=x$、$\tau_i=y$，则首先需要在之前的黑色位置中**选取**一个**包括** $i$ 的、大小为 $y-x$ 的**子集**，满足该子集内的黑色位置都还没有被之前的颜色**占用**过，设 $[1,i]$ 中的黑色位置的总数为 $c_i$，那么选取该子集的方案数恰为 $\dbinom{c_i-x-1}{y-x-1}$.

    之后要在该子集之内**填具体数**，使得 $a'_i=y$、其 $a'_j$ 均 $\in(x,y]$ 并且刚好覆盖 $(x,y]$ 这整个区间，那么显然填数的方案**只与** $y-x$ **有关**，我们直接设其为 $\mu_{y-x}$.

    这刻画了 $F_{i,y}\leftarrow F_{i,y}+\dbinom{c_i-x-1}{y-x-1}\mu_{y-x}F_{i-1,x}$ 的一个转移.

  - 若 $\tau_i=\tau_{i-1}$，即与**后续**某个加粗的新的颜色是**同一**颜色：

    此时 $a_i$ 具体填什么会在那个后续的加粗颜色处被刻画**计算**，故而此时可以暂时**忽略掉** $a_i$.

    这刻画了 $F_{i,x}\leftarrow F_{i-1,x}$ 的一个转移.

- 若第 $i$ 个石柱被钦定消失：

  需要填入 $a_i$ 使得 $a'_i=0$、即 $a_i\leq x$，由于 $\leq x$ 的值**一共**有 $2x$ 个，其中为了产生 $x$ 的覆盖值已经在黑色位置处**消耗**掉了 $x$ 个、之前的白色位置处已经填了 $(i-c_i)-1$ 个，故填 $a_i$ 的方案数恰为 $x-(i-c_i)+1$ 种.

  这刻画了 $F_{i,x}\leftarrow(x-(i-c_i)+1)F_{i-1,x}$ 的一个转移. 

------------

现在考虑 $\mu_n$ 怎么计算，**明确** $\mu_n$ 的意思是，在 $1$ 到 $n$ **各两个**(有区别)的多重集合中选出 $n$ 个**排成**一个数列 $a$，再令 $a'_i$ 为 $\leq a_i$ 的最大的在 $\{a'_1,a'_2,\cdots,a'_{i-1}\}$ 中未出现过的正整数，则 $a'_i$ 刚好构成一个 $[1,n]$ 的**排列**、并且满足 $a'_n=1$ 的方案数.

首先**忽略**掉 $a'_n=1$ 的限制，我们把该多重集合排成一排：$n^+,n^-,(n-1)^+,(n-1)^-,(n-2)^+,(n-2)^-,\cdots,2^+,2^-,1^+,1^-$；那么相当于是说我们要在其中选取 $n$ 个数，使得在每个**偶数**前缀处都**至少**选取了**一半**的数，考虑一个长度为 $2n+2$ 的**括号序列**，其中第 $1$ 个位置是 $\texttt{(}$ 而第 $2n+2$ 个位置是 $\texttt{)}$，中间 $2n$ 个位置**根据**对应的数，选对应 $\texttt{(}$ 而不选对应 $\texttt{)}$，那么显然合法的选数方案和长度为 $2n+2$ 的合法括号序列**一一对应**，故而选数的方案数为 $H_{n+1}$，其中 $H$ 为**卡塔兰**数；再乘以**任意**排成一排的方案数 $n!$，故忽略限制时填数的方案数 $=n!H_{n+1}$.

考虑该限制，用总数减去**不合法**的得到合法的，对于一个不合法的填数方案，设 $\tau_{n-1}=i$，则我们先选取 $n-i$ 个包括 $n$ 的位置作为最后一个**子集**的元素，在这个子集**内部**填数的方案数为 $\mu_{n-i}$，在这个子集**外部**填数的方案数为 $i!H_{i+1}$，故而有 $\mu_n=n!H_{n+1}-\sum\limits_{i=1}^{n-1}\dfrac{(n-1)!}{((n-1)-i)!}H_{i+1}\mu_{n-i}$.

------------

最后，观察到我们的转移**形如** $F'_i=F_i+\sum\limits_{j=0}^{i-1}\dbinom{c_u-j-1}{i-j-1}\mu_{i-j}F_j$，后面那部分为 $\sum\limits_{j=0}^{i-1}\dbinom{c_u-j-1}{i-j-1}\mu_{i-j}F_j=\sum\limits_{j=0}^{i-1}\dfrac{(c_u-j-1)!}{(c_u-i)!(i-j-1)!}\mu_{i-j}F_j=\dfrac1{(c_u-i)!}\sum\limits_{j=0}^{i-1}((c_u-j-1)!F_j)(\dfrac{\mu_{i-j}}{(i-j-1)!})$，可以看作是 $(c_u-i-1)!F_i$ 和 $\dfrac{\mu_{i}}{(i-1)!}$ 的**卷积**，使用 $\text{NTT}$ 对该卷积进行优化即可.

由于模数为 $10^9+7$ 需要使用**中国剩余定理**合并**三次** $\text{NTT}$ 的结果，故而实际**表现**不如**直接**转移.

该算法的时间复杂度为 $\mathcal{O}(n^2\log n)$，空间复杂度为 $\mathcal{O}(n)$.

```
#include <bits/stdc++.h>
#define rep(a,b,c) for(register int a=(b);a<=(c);++a)
#define dow(a,b,c) for(register int a=(b);a>=(c);--a)
using namespace std;
constexpr int MaxN = 600 + 5, MaxLimit = ((1 << 12) | 5), Mod = 1000000007;
inline void SimpleMod(int &wei, const int Mod) {
    (wei >= Mod) &&(wei -= Mod);
}
inline int QuickPow(const int wei, const int lvl, const int Mod) {
    if (!lvl)
        return 1;

    if (lvl & 1)
        return ((long long)QuickPow(wei, lvl ^ 1, Mod) * wei) % Mod;

    const int Half = QuickPow(wei, lvl >> 1, Mod);
    return ((long long)Half * Half) % Mod;
}
int Rev[MaxLimit], cumWei[MaxLimit];
inline void Number_Theory_Transform(const int Log_Limit, int arr[], const bool Flag, const int Mod) {
    const int Limit = (1 << Log_Limit);
    
	rep(i, 1, Limit - 1)
    	if (i < (Rev[i] = ((Rev[i >> 1] | ((i & 1) << Log_Limit)) >> 1)))
     	   swap(arr[i], arr[Rev[i]]);

    for (int Lvl = 1; Lvl != Limit; Lvl <<= 1) {
        const int wei = QuickPow(3, (Flag ? ((Mod - 1) - ((Mod - 1) / (Lvl << 1))) : ((Mod - 1) / (Lvl << 1))), Mod);
        cumWei[0] = 1;
        rep(i, 1, Lvl - 1)
        	cumWei[i] = ((long long)cumWei[i - 1] * wei) % Mod;

        for (int i = 0; i != Limit; i += (Lvl << 1))
            rep(j, i, i | (Lvl - 1)) {
            	const int arrThe = ((long long)arr[j | Lvl] * cumWei[j & (Lvl - 1)]) % Mod;
            	SimpleMod(arr[j | Lvl] = (arr[j] + (Mod - arrThe)), Mod), SimpleMod(arr[j] += arrThe, Mod);
        	}
    }

    if (!Flag)
        return;

    const int Adjust = QuickPow(Limit, Mod - 2, Mod);
    rep(i, 0, Limit - 1)
    	arr[i] = ((long long)arr[i] * Adjust) % Mod;
}
int T_00[MaxLimit], T_01[MaxLimit];
inline void Partial_Multiply(const int Len, const int F[], const int G[], int H[], const int Mod) {
    const int Log_Limit = ((31 ^ __builtin_clz(Len)) + 2), Limit = (1 << Log_Limit);
    memset(T_00, 0, sizeof(int) << Log_Limit);
    memcpy(T_00, F, sizeof(int) * (Len + 1));
    Number_Theory_Transform(Log_Limit, T_00, false, Mod);
    memset(T_01, 0, sizeof(int) << Log_Limit);
    memcpy(T_01, G, sizeof(int) * (Len + 1));
    Number_Theory_Transform(Log_Limit, T_01, false, Mod);
    rep(i, 0, Limit - 1)
    	T_00[i] = ((long long)T_00[i] * T_01[i]) % Mod;
    Number_Theory_Transform(Log_Limit, T_00, true, Mod);
    memcpy(H, T_00, sizeof(int) * (Len + 1));
}
constexpr int Mod_0 = 469762049, Mod_1 = 998244353, Mod_2 = 1004535809;
constexpr int Phi_1 = 554580198, Phi_2 = 395249030;
int T_10[MaxLimit], T_11[MaxLimit], T_12[MaxLimit];
inline void Polynomial_Multiply(const int Len, const int F[], const int G[], int H[]) {
    Partial_Multiply(Len, F, G, T_10, Mod_0);
    Partial_Multiply(Len, F, G, T_11, Mod_1);
    Partial_Multiply(Len, F, G, T_12, Mod_2);
    rep(i, 0, Len) {
        const long long Alpha = ((((long long)(T_11[i] + (Mod_1 - T_10[i])) * Phi_1) % Mod_1 * Mod_0) + T_10[i]);
        H[i] = (((((long long)(T_12[i] + (Mod_2 - (Alpha % Mod_2))) * Phi_2) % Mod_2 * Mod_0) % Mod * Mod_1) + Alpha)
               % Mod;
    }
}
int arr[MaxN], cnt[MaxN << 1], Coe[MaxN << 1], CoeInv[MaxN << 1];
int A[MaxN], B[MaxN], F[MaxN], G[MaxN], X[MaxN], Y[MaxN];
bitset < MaxN << 1 > Bitset;
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    int n;
    cin >> n;
    rep(i, 1, n)
    	cin >> arr[i], Bitset[(n << 1) - arr[i] + 1] = true;
    rep(i, 1, n << 1)
		if (((cnt[i] = (cnt[i - 1] + Bitset[i])) << 1) < i) {
	        cout << "0\n";
	        return 0;
	    }

    Coe[0] = 1;
    rep(i, 1, (n + 1) << 1)
    	Coe[i] = ((long long)Coe[i - 1] * i) % Mod;
    CoeInv[(n + 1) << 1] = QuickPow(Coe[(n + 1) << 1], Mod - 2, Mod);
    dow(i, (n + 1) << 1, 1)
    	CoeInv[i - 1] = ((long long)CoeInv[i] * i) % Mod;
    rep(i, 0, n + 1)
    	A[i] = (((long long)Coe[i << 1] * CoeInv[i]) % Mod * CoeInv[i + 1]) % Mod;
    rep(i, 1, n) {
        int Sum = 0;
        rep(j, 1, i - 1)
        	Sum = (Sum + (((long long)CoeInv[(i - 1) - j] * A[j + 1]) % Mod * B[i - j])) % Mod;
        B[i] = (((long long)A[i + 1] * Coe[i]) + ((long long)(Mod - Sum) * Coe[i - 1])) % Mod;
    }
    F[0] = 1;
    rep(u, 1, n << 1) {
        if (!Bitset[u]) {
            rep(i, 0, cnt[u])
            	F[i] = ((long long)F[i] * max(i - (u - cnt[u]) + 1, 0)) % Mod;
            continue;
        }

        rep(i, 0, cnt[u] - 1)
        	X[i] = ((long long)F[i] * Coe[cnt[u] - i - 1]) % Mod;
        rep(i, 1, cnt[u])
        	Y[i] = ((long long)B[i] * CoeInv[i - 1]) % Mod;
        Polynomial_Multiply(cnt[u], X, Y, X);
        rep(i, 0, cnt[u])
        	F[i] = (F[i] + ((long long)X[i] * CoeInv[cnt[u] - i])) % Mod;
    }
    const int Answer = ((long long)F[n] * QuickPow(2, (Mod - 1) - n, Mod)) % Mod;
    cout << Answer << '\n';
    return 0;
}
```

---

## 作者：Nangu (赞：5)

## 题解
考虑如何快速求出一个序列中最终不为零的坐标。

从后往前考虑，若 $h_i$ 后面有 $\le h_i$ 的全部正整数，那显然 $i$ 这根柱子就没了。否则，$h_i$ 会变成后面 $h$ 数组中没有出现且小于等于 $h_i$ 的最大整数，~~然后去祸害下一根石柱。~~

既然如此，我们考虑动态规划，设 $f_{i,j}$ 表示后面的 $i$ 根石柱，$\le j$ 的正整数高度全部都出现过的状态数。同时，设前 $i-1$ 个石柱中，$c_0$ 个石柱消失了，$c_1$ 个石柱还没有消失。

考虑转移。

- $i$ 消失了，显然 $h_i\le j$。前 $j$ 个高度中，共有 $2j$ 个可用高度，$j$ 个被没有消失的石柱用掉了，还要减去 $c_0$ 个消失的石柱，因此总共有 $j-c_0$ 个高度可以使用。故转移方程为：$f_{i+1,j}\times (j-c_0)\to f_{i,j}$。
- $i$ 没有消失。
> - $h_i>j+1$。此时的 $j$ 不会发生变化，因此状态不好表示，我们把它放到后面再去考虑。
> - $h_i=j+1$。此时 $j$ 会增加。若在 $i$ 之前，$[j+2, k]$ 之间的高度都已经出现过，那么 $\le k$ 的高度全都出现过，$f_{i+1,j}$ 就将转移到 $f_{i, k}$ 上。 考虑如何计算系数。
>>- $j+2$ 到 $k$ 共有 $k-j-1$ 个数，这些数可在 $c_1-j$ 个位子里随便选。总方案数为 ${c_1-j}\choose{k-j-1}$。
>>- 此时的高度 $h_i$ 可以在 $j+1$ 到 $k$ 之间随便挑。总共有 $2k-2j$ 个数，其中有 $k-j-1$ 个数已经被用掉，因此 $k-j+1$ 个数可选。
>>- $k-j-1$ 个数中，也像 $h_i$ 一样，其中许多高度是被它们前面的数震小后才形成的。不好求，考虑现设一个 $g_i$，表示 $i$ 个高度连续柱子的形成总方案数。
>- 由此可得，$f_{i,k}=f_{i+1, k}+\sum f_{i+1, j} \times {{c_1-j}\choose{k-j-1}} \times  (k-j+1) \times g_k-j-1$。

至于 $g_i$，我们枚举最后产生的高度 $j$，所产生方案的系数有：
- 高度 $j-1$ 及以下的，以及 $j+1$ 以上的，显然不会互相产生影响。这部分的系数为 $g_{j-1}\times g_{i-j}$。
- 高度 $j-1$ 及以下，高度 $j+1$ 及以上的排列组合的总方案数为 ${i-1}\choose{j-1}$。
- 考虑 $j$ 的产生总方案数。共有 $2(i-j+1)$ 个高度可选择，有 $i-j$ 已经被选，因此还剩 $i-j+2$ 种方案。
综上， $g_i=\sum g_{j-1}\times g_{i-j}\times (i-j+2) \times {{i-1}\choose{j-1}}$。

这样子，这道题就做完啦。

## 代码
```cpp
#include<bits/stdc++.h>
#define F(i, j, k) for(int i=(j); i<=(k); ++i)
#define R(i, j, k) for(int i=(j); i>=(k); --i)
#define int long long
using namespace std;
const int N=1207, mod=998244353;
int n, fac[N], ifac[N], f[N][N], g[N];
bool vis[N];

int power(int k, int e){
	int res=1;
	for(; e; e>>=1, k=k*k%mod) if(e&1) res=res*k%mod;
	return res;
}

void init(int x){
	fac[0]=1;
	F(i, 1, x) fac[i]=fac[i-1]*i%mod;
	ifac[x]=power(fac[x], mod-2);
	R(i, x-1, 0) ifac[i]=ifac[i+1]*(i+1)%mod; 
}

int C(int n, int m){
	return fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}

main(){
	cin>>n;
	init(n);
	F(i, 1, n){
		int x; cin>>x;
		vis[x]=1;
	}
	g[0]=1;
	F(i, 1, n) F(j, 1, i) g[i]=(g[i]+g[j-1]*g[i-j]%mod*C(i-1, j-1)%mod*(i-j+2))%mod;
	int c0=0, c1=0;
	f[n*2+1][0]=1;
	R(i, n<<1, 1)
		if(!vis[i]){
			F(j, c0, n) f[i][j]=f[i+1][j]*(j-c0)%mod;
			++c0;
		} else{
			F(j, 0, c1+1){
				f[i][j]=f[i+1][j];
				F(k, 0, j-1) f[i][j]=(f[i][j]+f[i+1][k]*(j-k+1)%mod*C(c1-k, j-k-1)%mod*g[j-k-1])%mod;
			}
			++c1;
		}
	cout<<f[1][n]*power(power(2, mod-2), n)%mod<<'\n';
}

```

---

## 作者：james1BadCreeper (赞：4)

旋风牛马大数数。

考虑从后往前扫，然后假定 $1\sim h$ 的石柱各出现了一根，那么接下来出现的 $\le h$ 的柱子，都会直接震没。那些没有被震死的柱子称为“标准柱”。

继续观察性质。如果当前位置为 $x$，后面存在 $x\sim x-k$，那么 $x$ 会下降到 $x-k-1$。

设 $f_{i,j}$ 代表后 $i$ 个柱子，此时 $h=j$ 的方案数。

我们先假定两根高度相同的柱子实际上是不同的，那么最终答案除以 $2^n$ 即可。

倒着 DP，设此时有 $c_0$ 个钦定消失，$c_1$ 个钦定存在。

1. $i$ 钦定消失，此时 $j$ 不变，有 $j$ 个可用高度，那么不算当前这个没消失的，这里可以填写 $j-(c_0-1)$ 个有效的。
2. $i$ 钦定保留，令 $h_i$ 代表 $i$ 最后的高度，分讨：
    - 如果 $h_i>j+1$，那么从 $f_{i+1,j}$ 转移，这里的贡献留给以后再计算。
    - 否则此时 $h_i=j+1$，那么此时枚举一个新增的大小 $k$，转移到 $f_{i,j+k}$，系数是：
        - 选择哪些位置的值被记入了当前 $j$。钦定除了当前位置的那 $k-1$ 个位置的方案数 $\dbinom{c_1-1-j}{k-1}$；
        - $j+2\sim j+k$ 的高度之前均有出现过一次，这里还可以选择各一次，然后还可以选择两个 $j+1$ 的高度，方案数是 $k+1$；
        - 固定那 $k-1$ 个位置上的数的排列，那些数都没有被震没。因此就是要求一个 $g_n$ 代表有 $2n$ 个数进行选择，然后震成值域连续段的初始方案数。

设 $g_{i,j}$ 代表用 $1\sim i$ 的数填 $j$ 个位置，放进去的最大数不影响原来能震成的值域连续段，那么能震成值域连续段的必要条件是 $i\ge j$，然后发现其实怎么填都无所谓了。枚举第 $i$ 个数填了 $0/1/2$ 的转移方式：

$$
g_{i,j}=g_{i-1,j}+2j\times g_{i-1,j-1}+j(j-1) g_{i-1,j-2}
$$

```cpp
#include <bits/stdc++.h>
using namespace std; 
const int N = 2e3 + 5; 
const int P = 1e9 + 7, I = P + 1 >> 1; 

int n, C[N][N]; 
int f[N][N], g[N][N], is[N];  

int main(void) {
    ios::sync_with_stdio(0); 
    for (int i = 0; i < N; ++i)
        for (int j = C[i][0] = 1; j <= i; ++j)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P; 
    
    cin >> n; 
    for (int i = 1, x; i <= n; ++i) cin >> x, is[x] = 1; 

    for (int i = 0; i <= n; ++i)
        for (int j = g[i][0] = 1; j <= i; ++j) {
            g[i][j] = (g[i - 1][j] + 2ll * j * g[i - 1][j - 1]) % P; 
            if (j > 1) g[i][j] = (g[i][j] + 1ll * j * (j - 1) * g[i - 1][j - 2]) % P; 
        }

    int c0 = 0, c1 = 0; 
    f[n * 2 + 1][0] = 1; 
    for (int i = n * 2; i >= 1; --i)
        if (is[i]) {
            ++c1; 
            for (int j = 0; j <= c1; ++j) {
                f[i][j] = (f[i][j] + f[i + 1][j]) % P; 
                for (int k = 1; k + j <= c1; ++k)
                    f[i][j + k] = (f[i][j + k] + 1ll * f[i + 1][j] * C[c1 - j - 1][k - 1] % P * (k + 1) % P * g[k - 1][k - 1]) % P; 
            }
        } else {
            ++c0; 
            for (int j = 0; j <= c1; ++j)
                f[i][j] = (f[i][j] + 1ll * f[i + 1][j] * (j - c0 + 1)) % P; 
        }

    int ans = f[1][n]; 
    for (int i = 1; i <= n; ++i) ans = 1ll * ans * I % P; 
    cout << ans << '\n'; 
    return 0; 
}
```

---

## 作者：Otomachi_Una_ (赞：4)

## 题目简述

> - 一个长度为 $2n$ 的序列 $a$，满足 $1,2,\dots,n$ 每个数恰好出现 $2$ 次。现在进行 $n$ 次如下操作：
> - - 同时对于所有 $i(a_i>0)$ 满足 $∃ i<j,a_j=a_i$ 的 $a_i$ 减一。
> - 最后恰得到 $n$ 个非零位，记为 $a$ 的「支撑集」。给定 $a$ 的支撑集，求原来 $a$ 的可能数量。答案对 $10^9+7$ 取模。
> - $n\leq 600$。

## 解题思路

刚拿道题没有思路，我们尝试猜测一些结论。

> 猜测 $1$：对任意满足 $1,2,\dots,n$ 每个数恰好出现 $2$ 次的数列 $a$，经过 $n$ 次操作后必然只剩下 $n$ 个非零位。

下面我们尝试去证明「猜测 $1$」（对证明没有兴趣的同学可以跳到猜测 $2$）：

我们尝试去观察一个例子：$a=[2,3,5,5,4,2,3,4,1,1]$，变换如下：

- 第 $1$ 次操作，$a=[1,2,4,5,3,2,3,4,0,1]$；
- 第 $2$ 次操作，$a=[0,1,3,5,2,2,3,4,0,1]$；
- 第 $3$ 次操作，$a=[0,0,2,5,1,2,3,4,0,1]$；
- 第 $4$ 次操作，$a=[0,0,1,5,0,2,3,4,0,1]$；
- 第 $5$ 次操作，$a=[0,0,0,5,0,2,3,4,0,1]$。

注意观察上面的操作，不难发现：**每个非负整数至多出现 $\bm 2$ 次**。这个使用归纳证明是显然的，更进一步，不难发现在第 $i$ 次操作后 $1\sim n-i$ 每个数出现两次，$n-i+1\sim n$ 每个数出现一次。这用归纳法也是显然的。

也就是每次的两个 $1$ 总有一个会变成 $0$，证毕。

下面考虑每个合法序列的「支撑集」，通过上面的引理，不难发现每次两个数比较都是小的减一，也就是如果把数值看做成等级，那么下标大的人会把下标小的人打下去。这不难让我们猜测到「支撑集」的计算方法：

> 猜测 $2$（支撑集的计算方法）：遍历 $i$ 从 $n$ 到 $1$，把所有数值 $\geq i$ 且没有标记的数中下标最大者标记，最后所有标记的点记为原序列的「支撑集」。

证明是显然的。但是这显然不利于我们去计数。我们需要考虑另一种的表示方法。

> 猜测 $3$（支撑集的另一种表示方法）：考虑 $i$ 从 $2n$ 遍历到 $1$，维护集合 $S$。如果 $S$ 中包含 $1,2,\dots,a_i$ 那么 $i$ 不能加入支撑集，否则加入小于等于 $a_i$ 当中最大不在 $S$ 当中的数，此时 $i$ 在支撑集。

考虑证明，我们还是引用上面打擂台的表示方法。考虑 $i$ 如果在支撑集，也就是 $i$ 占领了一个等级，那么 $i$ 必然是不断往比自己等级小的地方走，直到没有人的等级就当上了这个等级的爷爷，如果等级归 $0$ 了还没当上爷爷那么它就再见了。

说了那么多实际上还是只能暴力枚举，甚至 $1$ 分都拿不到，但是我们已经可以考虑 dp 的做法了。

下面假设序列当中相同的数硬性规定不同。最终答案除以 $2^n$。假设位置 $i$（不包括）之前已经有 $c_0$ 个不在支撑集，$c_1$ 个在支撑集。

考虑 $f_{i,j}$ 表示后 $i$ 个数，等级 $1\sim j$ 已经被占领且 $j+1$ 未被占领的方案数，考虑转移 $f_{i,j}$：

- 如果规定位置 $i$ 不是支撑集，那么他可以在 $1\sim j$ 当中任意一个选取，由于支撑集用了 $j$ 个，不在支撑集用了 $c_0$ 个，所以还有 $j-c_0$ 的选择。也就是：

- $$
  f_{i,j}=(j-c_0)f_{i-1,j}
  $$

- 如果规定位置 $i$ 是支配集，那么它选择必然 $\geq j$，考虑 $f_{i-1,j'}$ 的贡献。

- - 如果 $j'=j$，那么贡献未来再计算，也就是 $f_{i,j}\leftarrow f_{i-1,j}$。
  - 如果 $j'< j$，那么我们考虑我要在前面 $c_1-j'$ 个未被选择的数当中选择 $j-j'-1$ 个，这有 $\dbinom{c_1-j'}{j-j'-1}$ 种方案，考虑第 $i$ 个数的数值有 $j-j'+1$ 种方案，最后考虑未确定的 $j-j'-1$ 个元素当中选取的方案，感觉这个不好直接计算，我们先假设他为 $g_{j-j'-1}$ 后面再搞搞。

接下来考虑 $g$ 的计算，本质上是在 $1,1,2,2,3,3,\dots,n,n$ 当中选 $n$ 个通过上面变换变成连续的方案数。同样的枚举第一个点值最终等级，假设为 $x$，那么他有 $n-x$ 种方案。在 $n-1$ 个选 $x-1$ 个一边等级 $>x$，一边 $<x$ 有 $\dbinom{x-1}{n-1}$ 种方案，然后两边独立又有 $g_{x-1}\times g_{n-x}$ 种方案。那么得到转移式子：
$$
g_n=\sum_{i=1}^n (n-x+2)\times \dbinom{x-1}{n-1}\times g_{x-1}\times g_{n-x}
$$
然后就做完了。

## 实现细节

很好写，没细节。照着上面的式子搬下来就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
const int MAXN=605;
const int MOD=1e9+7;
int n;
ll f[2*MAXN][MAXN],g[MAXN];
ll fac[MAXN],inf[MAXN];
bool mark[MAXN*2];
ll inv(ll a,int b=MOD-2){ll res=1;while(b){if(b&1)res=res*a%MOD;a=a*a%MOD,b>>=1;}return res;} 
void init(){
	fac[0]=inf[0]=1;
	for(int i=1;i<MAXN;i++)
		fac[i]=fac[i-1]*i%MOD,
		inf[i]=inv(fac[i]);
	return;
}
ll C(int x,int y){if(x>y)return 0;return fac[y]*inf[x]%MOD*inf[y-x]%MOD;} 
int main(){
	ios::sync_with_stdio(false);
	init();
	cin>>n;
	for(int i=1;i<=n;i++){
		int a;cin>>a;mark[2*n+1-a]=1;
	}
	g[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			g[i]+=C(j-1,i-1)*(j+1)%MOD*g[j-1]%MOD*g[i-j]%MOD,
			g[i]%=MOD;
	f[0][0]=1;
	int c0=0,c1=0;
	for(int i=1;i<=2*n;i++){
		if(mark[i]){
			for(int j=0;j<=n;j++){
				f[i][j]=f[i-1][j];
				for(int k=0;k<j;k++)
					f[i][j]+=f[i-1][k]*C(j-k-1,c1-k)%MOD*(j-k+1)%MOD*g[j-k-1]%MOD,
					f[i][j]%=MOD;
			} 
			c1++;
		}else{
			for(int j=c0;j<=n;j++)
				f[i][j]=f[i-1][j]*(j-c0)%MOD;
			c0++;
		}
	}
	ll x=inv(inv(2,n));
	cout<<f[2*n][n]*x%MOD;
	return 0;
}
```



---

## 作者：_Cheems (赞：3)

厉害数数题，使我螺旋升天。然后是小蒟蒻看完题解后的感想，不得不说第一眼看是真的一头雾水。

先考虑给定初始高度如何求最终高度。题目说每次地震会使得相同高度的两个柱子（显然至多两个）中靠前的那个高度减一，不可能模拟整个过程，所以需要观察一些性质：

记一段后缀的高度集合为 $A$，那么经过若干轮地震后高度集合 $B$ 必然满足 $A\in B$，即地震后高度集合元素不减。这不难归纳证明。

这启示我们从后往前逐个确定最终高度，已确定 $[i+1,2n]$，现考虑 $i$。由性质知只需关注 $[i+1,2n]$ 中柱子的最终高度。具体而言，记 $h_i$ 为当前柱子的初始高度，$H$ 为 $[i+1,2n]$ 中柱子的高度集合，那么若 $H$ 中存在极大连续段 $[k,h_i]$ 则当前柱子高度最终变成 $k-1$。

考虑 dp，记 $f_{i,j}$ 为后 $i$ 个柱子高度集合中存在极大连续段 $[1,j]$ 的方案数。为了方便计数，认为同一高度的柱子不一样（两种颜色），最终除 $2^n$ 即可。

考虑转移，记 $c_0,c_1$ 为此前消失、保留的柱子数量：
* 当前柱子应消失：对 $j$ 无影响，只需考虑当前柱子的起始高度。由结论可知添加柱子的过程中连续段一定扩大，所以此前消失的柱子高度必然 $\le j$。那么有 $2j-j-c_0=j-c_0$ 种选择。即 $f_{i-1,j}\times (j-c_0)\to f_{i,j}$。

* 当前柱子应保留：需要根据对连续段 $[1,j]$ 的影响分类：

  1. 最终高度 $>j+1$：无影响，但是可能影响其它连续段，怎么办？可以暂时存着，记为“待定柱”，等到连续段合并时再考虑其取值。即 $f_{i-1,j}\to f_{i,j}$。
 
  2. 最终高度 $=j+1$：会合并连续段，枚举 $[1,j]$ 通过 $j+1$ 与 $[j+1,k]$ 合并。共有 $c_1-j$ 个待定柱，抽出一些构成连续段 $[j+1,k]$，不妨记 $g_k$ 为 $k$ 个柱子最终构成大小为 $k$ 的连续段的方案数。转移：$f_{i-1,j}\times {{c_1-j}\choose {k-j-1}}\times g_{k-j-1}\times (k-j+1)\to f_{i,k}$。
 
最后考虑 $g_k$ 怎么求，不妨设构成的连续段为 $[1,k]$。同 $f$ 的转移，枚举最后添加的柱子高度 $i$，那么此前连续段 $[1,i-1]$ 和 $[i+1,k]$ 的形成完全独立，这不难理解。

于是有转移：$g_k=\sum\limits_{i=1}^k {{k-1}\choose {i-1}}\times g_{i-1}\times g_{k-i}\times (k-i+2)$。

复杂度 $O(n^3)$，跑的挺快。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define ADD(a, b) a = (a + b) % mod
const int N = 1.2e3 + 5, mod = 1e9 + 7, inv2 = 5e8 + 4;
int n, a, g[N], f[N][N], jc[N], jcinv[N];
bool vis[N];

inline int qstp(int a, int k) {int res = 1; for(; k; a = a * a % mod, k >>= 1) if(k & 1) res = res * a % mod; return res;}
inline int C(int n, int m){
	if(n < 0 || m < 0 || n < m) return 0;
	return jc[n] * jcinv[m] % mod * jcinv[n - m] % mod;
}
signed main(){
	jc[0] = jcinv[0] = 1;
	for(int i = 1; i < N; ++i) jcinv[i] = qstp(jc[i] = jc[i - 1] * i % mod, mod - 2);
	
	cin >> n;
	for(int i = 1; i <= n; ++i) scanf("%lld", &a), vis[a] = true;
	
	g[0] = f[0][0] = 1;
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= i; ++j)
			ADD(g[i], g[j - 1] * g[i - j] % mod * (i - j + 2) % mod * C(i - 1, j - 1) % mod);
			
	int c0, c1 = 0;
	for(int i = 1; i <= 2 * n; ++i){
		c0 = i - 1 - c1;
		if(!vis[2 * n - i + 1]){
			for(int j = 0; j <= n; ++j) 
				if(j > c0) ADD(f[i][j], f[i - 1][j] * (j - c0) % mod);
		}
		else{
			for(int j = 0; j <= n; ++j){
				if(n > j + 1) ADD(f[i][j], f[i - 1][j]); 
				for(int k = j + 1; k <= n; ++k)
					ADD(f[i][k], f[i - 1][j] * g[k - j - 1] % mod * C(c1 - j, k - j - 1) % mod * (k - j + 1) % mod);
			}
		}
		c1 += vis[2 * n - i + 1];
	}
	
	cout << f[2 * n][n] * qstp(inv2, n) % mod;
	return 0;
}
```

---

## 作者：7KByte (赞：3)

做过最神的数数题之一。

先考虑如果给定 $h$ ，如何求出 $A$ 。

首先最后一个数一定会留下，倒数第二个数如果和最后一个数相等，则减一，否则一直保留下去。

所以模拟一下我们发现，从后向前扫一遍，如果后面没有出现 $h_i$ ，则 $h_i$ 就是当前位置的最终值，否则 $h_i$ 一直减一直到后面没有出现 $h_i$ ，减到 $0$ 为止。

可以设计状态 $f[i][S]$ 表示后 $i$ 个数，出现过的数的集合是 $S$ 的方案数，时间复杂度 $\mathcal{O}(n^2 2^n)$ ，可以通过第一个子任务。

考虑优化，我们优化状态 $f[i][j]$ 表示后 $i$ 个数，出现过的数的集合是 $1\sim j$ 的方案数，然后每次在 $j$ 后面接上连续的一段转移转移到 $f[i'][j+k]$ 。

接下来是愉快的分类讨论环节。

如果当前位置没有留下来，那么当前位置可选的数是 $1\sim j$ ，因为选 $>j$ 的数一定会使当前数留下来。我们记当前位置后面没有留下来的位置有 $res$ 个，当前可以填的数有 $2j$ 个，已经填了 $j+res$ 个数，所以还剩 $j-res$ 个数可以选择，$f[i][j]=(j-res)\times f[i-1][j]$ 。

如果当前数留了下来。那么考虑是否在 $j$ 后面接上连续的一段 $k$ 。

如果不接上，那么就将当前位置留到后面计算，即贡献未来计算，$f[i][j]=f[i-1][j]$ 。

否则我们枚举 $k$ ，从 $f[i-1][j-k]$ 转移到 $f[i][j]$ 。

首先当前位置一定是的最终值 $j-k+1$ ，因为如果 $j-k+1$ 出现在其他位置，则贡献不在这里计算。

其中 $j-k+2\sim j$ 这 $k-1$ 个数已经出现过，所以当前位置可填的数有这 $k-1$ 个数，还有等于 $j-k+1$ 的两个数，一共 $k+1$ 个数。

然后钦定这 $k-1$ 个数的位置，我们令后面留下的位置有 $sum$ 个，固定前面的 $j-k$ 个数用了 $j-k$ 个位置，剩下 $sum-j+k$ 个位置，方案数为 $\dbinom{sum-j+k}{k-1}$。

最后固定这 $k-1$ 个位置上的数的排列，我们记作 $g_{k-1}$ 。即用 $1\sim n$ 这 $2n$ 个数构成一个长度为 $n$ 的序列使得最终序列为一个 $1\sim n$ 的排列。

首先必要条件是：对于任意的 $i\in [1,n]$ ，使用的 $\le i$ 的数 $\le i$ 。显然，如果 $>i$ ，则至少存在一个数被减到 $0$ 。

观察一下发现这同时是充分条件，因为这个序列一定优于一个长度为 $n$ 的排列，而排列一定合法。

所以我们呢记录 $g[i][j]$ 表示用 $1\sim i$ 个数，填了 $j$ 个位置，然后枚举第 $i$ 个数填了 $0/1/2$ 个数转移即可。

$$g[i][j]=g[i-1][j]+2j\times g[i-1][j-1]+j(j-1)\times g[i-1][j-2]$$

预处理组合数，时间复杂度 $\mathcal{O}(N^3)$ 。

```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 605
#define P 1000000007
using namespace std;
int f[N << 1][N], g[N][N], n, u[N << 1], c[N][N];
int main() {
    scanf("%d", &n);
    rep(i, 1, n) {
        int x;
        scanf("%d", &x);
        u[x] = 1;
    }
    rep(i, 0, n) {
        c[i][0] = g[i][0] = 1;
        rep(j, 1, i)c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;
        rep(j, 1, i) {
            g[i][j] = (g[i - 1][j] + 2LL * j * g[i - 1][j - 1]) % P;

            if (j > 1)
                g[i][j] = (g[i][j] + 1LL * g[i - 1][j - 2] * j * (j - 1)) % P;
        }
    }
    f[n * 2 + 1][0] = 1;
    int sum = 0;
    pre(i, n * 2, 1) {
        if (u[i]) {
            rep(j, 0, sum + 1) {
                f[i][j] = f[i + 1][j];
                rep(k, 1, j)
                f[i][j] = (f[i][j] + 1LL * f[i + 1][j - k] * c[sum - (j - k)][k - 1] % P * g[k - 1][k - 1] % P * (k + 1)) % P;
            }
            sum++;
        } else {
            int res = n * 2 - i - sum;
            rep(j, 0, sum)f[i][j] = 1LL * f[i + 1][j] * (j - res) % P;
        }
    }
    rep(i, 1, n)f[1][n] = 500000004LL * f[1][n] % P;
    printf("%d\n", f[1][n]);
    return 0;
}
```



---

## 作者：流水行船CCD (赞：2)

两种思考方式：

- 值域维度：从原始高度大往小插入柱子，不确定右边是否有最终高度等于它的柱子，并不好记录状态。

- 下标维度：从后往前扫描，注意到前面的对后面的后效性很小，此时不难设出一个基础的状压 DP 方程。

为了避免记录后方柱子初始高度出现情况（相同初始高度有且仅有 $2$ 种），将相同的初始高度拆成两个，颜色不同，强制定序，最后消序（除以 $2^n$）即可。

## Part 1 状压 DP

不妨设 $f_{i, S}$ 表示后 $i$ 个柱子，**最终高度**出现集合为 $S$ 的方案数。其中，最终高度 $i$ 出现，那么 $S_i = 0$，否则 $S_i = 1$，初始时 $S$ 为全 $1$ 串。

此时若 $i$ 的最终高度 $a_i$ 为 $0$，这就意味着在 $i$ 左边从 $1$ 到 $i$ 的初始高度都已经出现过（一段前缀零），设 $S$ 的前缀 $0$ 长度为 $Pre_0(S)$，那么考虑 $i$ **初始高度**的取值有多少种可能：首先 $i$ 的初始高度必须位于 $S$ 的前缀 $0$ 中，所以共有 $2Pre_0(S)$ 种选择（每种高度 $2$ 个）；然后每一个在前缀 $0$ 中的柱子又会占用掉一个高度（最终高度在前缀 $0$ 的柱子初始高度一定在前缀 $0$ 中，虽然他们有可能是被震下来的，但仍占用了 $1$ 种高度）；最后在 $i+1$ 以后的，被震成 $0$ 的柱子，初始高度仍然均在 $[1,Pre_0(S)]$ 之间，减去。最后剩下的就是给 $i$ 的了，有方程：

$$f_{i,S} = f_{i+1,S} \times (2Pre_0(S) -Pre_0(S)-\sum_{j=i+1}^{2n}[a_j=0])$$

若 $i$ 的最终高度 $a_i$ 不为 $0$，枚举 $i$ 的最终高度 $j$，设 $j$ 之后连续一段 $0$ 的长度为 $len_j(S)$（$S_j=1$），因为如果 $i$ 的初始高度在 $j$ 后面一段 $0$ 中，最后一定会被震成 $j$，那么有转移方程：

$$f_{i,S'} = f_{i+1,S} \times (2len_j(S) - len_j(S) + 2)$$

解释：如果当前点初始高度在后面 $len_j(S)$ 个已被占用高度当中，共有 $2len_j(S)$ 种选择，已经被占了 $len_j(S)$ 种高度；如果当前柱子初始高度直接就是最终高度，有 $2$ 种选择（一个高度两种）。

给张图方便理解。

![pic1](https://cdn.luogu.com.cn/upload/image_hosting/spjphdi5.png)

## Part2 优化

考虑第一种转移，仅仅与前缀 $0$ 长度有关，考虑只记录前缀 $0$ 长度，设 $f_{i,j}$ 表示后 $i$ 个柱子，**最终高度**出现集合前缀 $0$ 长度为 $j$ 的方案数（事实上，这里所谓的前缀 $0$ 就是其他题解所说的支撑柱，标准柱），第一种（最终高度 $a_i=0$）状转方程直接照搬。

$$f_{i,j} = f_{i+1,j} \times (2j - j -\sum_{k=i+1}^{2n}[a_k=0])$$

但是发现第二种情况（最终高度 $a_i > 0$）不太好办了，当一个柱子最终高度在 $j+1$ 往上的时候，无法处理出 $0$ 联通块大小。计数题分步计算不了，先合并捆绑，后定序处理。分类讨论两种情况。

- $a_i > j + 1$，此时无法处理，不用考虑，直接合并。

$$f_{i,j} = f_{i+1,j}$$

- $a_i = j + 1$，枚举将 $j+1$ 纳入最终高度出现集合中后，新的前缀 $0$ 长度为 $k$，又令 $val = \sum_{j=i+1}^n[a_j=0]$，令 $g_i$ 表示将 $i$ 个初始高度在 $[1,i]$ 中柱子最终可以被震成连续一段的方案数，那么有转移方程：

$$f_{i,k} = f{i+1,j} \times \binom{val - j}{k - j - 1} \times (2(k-j-1)-(k-j-1)+2) \times g_{k-j-1}$$

解释：

- $\binom{val - j}{k - j - 1}$：共有 $val$ 个数可以成为 $0$（支撑柱），其中有 $j$ 个已经确定了，在之前被选入前缀 $0$ 中，剩下 $val - j$ 个未确定最终高度和初始高度的柱子要被放入 $k - j - 1$ 这新的一段前缀 $0$ 中。

- $2(k-j-1)-(k-j-1)+2$：确定当前 $i$ 号柱子的初始高度，正如在状压 DP 那里讲的，共有 $2(k-j-1)$ 种高度，被后面的连续 $0$ 占用了 $(k-j-1)$ 种，剩下 $2(k-j-1)-(k-j-1)$ 种，除此之外初始高度直接是 $k$ 有 $2$ 种可能。

- $g_{k-j-1}$ 确定这 $k - j - 1$ 个新柱子的初始高度和最终高度，由于这些柱子高度变化与外界无关，平移后可以转化为子问题。

同样给一张图：
![](https://cdn.luogu.com.cn/upload/image_hosting/3s949d31.png)

接下来只用考虑 $g$ 的转移了，类似于第二种情况。

$$g_i = \sum_{j=1}^{i}g_{i-j}\times g_{j - 1}\times(2(i-j)-(i-j)+2)\times \binom{i - 1}{j - 1}$$

组合意义和上面基本一样，给张图就理解了：

![](https://cdn.luogu.com.cn/upload/image_hosting/kyv1tafc.png)

$O(n^2+n^3)$

# Code

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;
namespace fast_IO{
    #define IOSIZE (1<<20)
    char ibuf[IOSIZE],obuf[IOSIZE];char*p1=ibuf,*p2=ibuf,*p3=obuf;
    #ifdef ONLINE_JUDGE
    #define putchar(x)((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
    #endif
    #define isdigit(ch)(ch>47&&ch<58)
    #define isspace(ch)(ch<33)
    template    <typename T>inline T    read(){T s=0;int w=1;char ch;while(ch=getchar(),!isdigit(ch)and(ch!=EOF))if(ch=='-')w=-1;if(ch==EOF)return false;while(isdigit(ch))s=s*1+ch-48,ch=getchar();return s*w;}template<typename T>inline bool read(T&s){s=0;int w=1;char ch;while(ch=getchar(),!isdigit(ch)and(ch!=EOF))if(ch=='-')w=-1;if(ch==EOF)return false;while(isdigit(ch))s=s*10+ch-48,ch=getchar();return s*=w,true;}template<typename T>inline void print(T x){if(x<0)putchar('-'),x=-x;if(x>9)print(x/10);putchar(x%10+48);}inline bool read(char&s){while(s=getchar(),isspace(s));return true;}inline bool read(char*s){char ch;while(ch=getchar(),isspace(ch));if(ch==EOF)return false;while(!isspace(ch))*s++=ch,ch=getchar();*s='\000';return true;}inline void print(char x){putchar(x);}inline void print(char*x){while(*x)putchar(*x++);}inline void print(const char*x){for(int i=0;x[i];i++)putchar(x[i]);}inline bool read(std::string&s){s="";char ch;while(ch=getchar(),isspace(ch));if(ch==EOF)return false;while(!isspace(ch))s+=ch,ch=getchar();return true;}inline void print(std::string x){for(int i=0,n=x.size();i<n;i++)putchar(x[i]);}inline bool read(bool&b){char ch;while(ch=getchar(),isspace(ch));b=ch^48;return true;}inline void print(bool b){putchar(b+48);}template<typename T,typename...T1>inline int read(T&a,T1&...other){return read(a)+read(other...);}template<typename T,typename...T1>inline void print(T a,T1...other){print(a),print(other...);}struct Fast_IO{~Fast_IO(){fwrite(obuf,p3-obuf,1,stdout);}}jyt;template<typename T>Fast_IO&operator>>(Fast_IO&jyt,T&b){return read(b),jyt;}template<typename T>Fast_IO&operator<<(Fast_IO&jyt,T b){return print(b),jyt;}
    struct IO{static const int S=1<<21;char buf[S],*p1,*p2;int st[105],Top;~IO(){clear();}inline void clear(){fwrite(buf,1,Top,stdout);Top=0;}inline void pc(const char c){Top==S&&(clear(),0);buf[Top++]=c;}inline char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}IO&operator>>(char&x){while(x=gc(),x==' '||x=='\n');return*this;}template<typename T>IO&operator>>(T&x){x=0;bool f=0;char ch=gc();while(ch<'0'||ch>'9'){if(ch=='-')f^=1;ch=gc();}while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc();f?x=-x:0;return*this;}IO&operator<<(const char c){pc(c);return*this;}template<typename T>IO&operator<<(T x){if(x<0)pc('-'),x=-x;do{st[++st[0]]=x%10,x/=10;}while(x);while(st[0]){pc('0'+st[st[0]--]);}return*this;}}ld;
} using namespace fast_IO;
#define ll long long
#define ull unsigned long long
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
#define rep(i, l, r) for (int i = l; i < r ; ++i)
#define per(i, l, r) for (int i = l; i > r ; --i)
namespace RPD {
    #define pf(x) ((x) * (x))
    #define ppf(x) ((x) * (x) * (x))
    #define modf(x, mod) (((x) % mod + mod) % mod)
    #define min3(x, y, z) (min(x, min(y, z)))
    #define min4(x, y, z, w) (min(min(x, y), min(z, w)))
    #define max3(x, y, z) (max(x, max(y, z)))
    #define max4(x, y, z, w) (max(max(x, y), max(z, w)))
    #define gmin(x, y) (x = min(x, y))
    #define gmax(x, y) (x = max(x, y))
    #define lowbit(x) (x & -x) 
    #define bitcount(x) __builtin_popcount(x)
    #define albit(x) ((1 << (x)) - 1)
    #define mkbit(x) (1 << (x))
    #define gtbit(x, id) (((x) >> (id)) & 1)
}
// #define ld cin
// #define jyt cout
//#define int long long
const int N = 1200 + 7;
const int inf = 1e9 + 7;
const ll linf = 1e18 + 7;
const int P = 1e9 + 7;
namespace MG42 {
    int n, A[N];
    inline ll qpow(ll x, ll y) {
        ll Res = 1; 
        while (y) {
            if (y & 1) (Res *= x) %= P;
            y >>= 1, (x *= x) %= P;
        } return Res;
    }
    ll f[N][N], g[N], fac[N], inv[N];
    inline ll C(ll x, ll y) {
        if (x < y || x < 0 || y < 0) return 0;
        return fac[x] * inv[y] % P * inv[x - y] % P;
    }
    signed main() { fac[0] = inv[0] = 1;
        ld >> n; int x = 0, Cnt0 = 0, Cnt1 = 0;
        REP(i, 1, n) ld >> x, A[x] = true;
        REP(i, 1, 2 * n) fac[i] = fac[i - 1] * i % P, inv[i] = qpow(fac[i], P - 2); 
        g[0] = 1;
        REP(i, 1, 2 * n) 
            REP(j, 1, i) 
                (g[i] += g[i - j] * g[j - 1] % P * ((i - j + 1) + 1) % P * C(i - 1, j - 1) % P) %= P;
        // cerr << g[3] << '\n';
        f[2 * n + 1][0] = 1;
        PER(i, 2 * n, 1) {
            if (!A[i]) {
                REP(j, Cnt0 + 1, Cnt1) f[i][j] = f[i + 1][j] * (2 * j - j - Cnt0) % P;
            } else {
                REP(j, Cnt0, Cnt1) f[i][j] = f[i + 1][j];
                REP(j, Cnt0, Cnt1) 
                    REP(k, j + 1, Cnt1 + 1) 
                        (f[i][k] += f[i + 1][j] * C(Cnt1 - j, k - j - 1) % P * g[k - j - 1] % P * (k - j + 1) % P) %= P;
            } Cnt0 += (A[i] == 0), Cnt1 += (A[i] == 1);
        }
        // cerr << f[6][1] << '\n';
        ll Ans = f[1][n] * qpow(qpow(2, n), P - 2) % P;
        jyt << Ans << '\n';
        return 0; 
    }
}
signed main() {
    // freopen("copy.in", "r", stdin);
    // freopen("copy.out", "w", stdout);
//  ios::sync_with_stdio(false);
//  cin.tie(0), cout.tie(0);
    MG42::main();
    return 0;
}
```

---

## 作者：pref_ctrl27 (赞：2)

### [JOISC2020] 最古の遺跡 3

[题目](https://www.luogu.com.cn/problem/P7213)

可以发现，第 $i$ 根柱子最后的位置在所有曾经为 $i$ 的位置中最大的。记 $T_i$ 表示最终保留高度 $i$ 的柱子编号。
考虑按照值域从大到小扫描，维护一个集合 $S$ 表示尚未留下的位置集合，每次执行：

+ $S\gets S\cup \{X_i, Y_i\}$
+ $T_i\gets \max S$
+ $S\gets S\setminus \{T_i\}$

但不太好转移。考虑从位置的角度刻画问题。
从后往前依次确定每一位的权值。可以发现，$i$ 的最终权值为最大的 $v$ 满足 $v\leq a_i$ 且 $\forall j>i, a'_j\not=v$。

考虑设 $f_{i,j}$ 表示后 $i$ 个位置，$1\sim j$ 都被占用而且 $j+1$ 未被占用的方案数。
为方便转移，将相同的数看成不同的，最后答案乘以 $\dfrac{1}{2^n}$。
同时为了满足无后效性，我们不去关注初始权值 $>j+1$ 的位置的具体取值造成的区别，也不关注由于两个 $>j+1$ 位置之间造成的不合法性。

形式化地，我们用 $f_{i,j}$ 对 $a_{i\sim 2n}$ 计数，其满足：

+ $a$ 由 $1\sim 2j$ 以及 $*$ 构成，且 $1\sim 2j$ 最多出现一次。
+ 将所有非 $*$ 位置提取出来组成序列 $a'$ 并让所有 $a'_x\gets \lceil\frac{a'_x}{2}\rceil$ 后，该序列进行题目中描述的操作后得到的最终序列中 $1\sim j$ 都各有一个，且是否为 $0$ 与题目中给定的限制相同。
+ 所有 $*$ 所在的位置都必须是最终不为 $0$ 的位置。

注意到 $\dfrac{f_{1,n}}{2^n}$ 就是最终的答案，因为此时计数的 $a$ 序列中不可能有 $*$。

记 $i+1\sim 2n$ 中有 $c_1$ 个被钦定，$c_0$ 个被舍弃。

考虑转移。
如果 $a_i$ 最终为 $0$，则 $a_i$ 只能为数字，它只能从 $f_{i+1,j}$ 转移过来，此时 $a_i$ 取值范围为 $[1,2j]$，但其中恰好有 $j+c_0$ 个已选，所以系数为 $(2j-j-c_0)=j-c_0$。

如果 $a_i$ 最终不为 $0$，则分类讨论：

+ $a_i$ 为 $*$，此时 $f_{i,j}\gets f_{i+1, j}$。
+ $a_i$ 为数字。
    考虑枚举 $a_i$ 最终权值是多少，记为 $k$。不难意识到 $a_{i+1\sim 2n}$ 得到最终序列值域为 $[1,k)\cup(k,j]$。问题变为先让 $a_{i+1\sim 2n}$ 的值域变为 $[1,k)\cup (k,j]$，然后再让 $a_i$ 变为 $k$，此时 $a_i$ 有 $j-k+2$ 种取值。
注意到 $k$ 作为分界点将问题分为两个部分，使得初始值和最终值不会跨过该点。因此考虑分开计算两个部分的贡献，发现 $(k, j]$ 对于 $[1,k)$ 的部分不会产生贡献，可以将其视为 $*$，所以 $[1,k)$ 部分的答案为 $f_{i+1,k-1}$，对于 $(k,j]$ 的答案可以看成先区分出数字和 $*$，然后再使得恰好为 $(k,j]$。区分的贡献为 $\binom{c_1-(k-1)}{j-k}$，而使用 $(k,j]$ 中的数字使得最终恰好构成 $(k,j]$ 可以被平移到 $[1,j-k]$ 上。设其为 $g(j-k)$。
则贡献为 
$\displaystyle f_{i,j}\gets \sum_k f_{i+1, k-1}\times \binom{c_1-k+1}{j-k}\times (j-k+2)\times g(j-k)$

关键在于计算 $g(i)$，其表示用 $1,1,2,2,3,3\cdots i,i$ 组成序列能够使得最终值域为 $[1,i]$ 的方案数。不难发现和 $f$ 是很像的。
同样考虑枚举 $a_i$，有 $\displaystyle g(i)=\sum_j \binom{i-1}{j-1} g(j-1)\times g(i-j)\times (i-j+2)$

复杂度 $\mathcal O(n^3)$。

---

## 作者：PosVII (赞：1)

## 前言

提醒：这个做法需要二维分治 FFT。

被迫的 $O(n^2 \log^2 n + n^3)$ 做法，因为方法不一样所以不能 $n^3$ 做。

场上想出来的方法，思路可能比较诡异。

答辩出题人模数开 $10^9+7$，弘文了。

## 题解

考虑如果将石柱的位置与最终高度一一对应，其实每个高度代表的位置就是在全过程中经过这个高度的最大位置。

那么先考虑枚举石柱的位置与最终高度相对应的排列，答案会是什么。

设 $p_i$ 为最终高度为 $i$ 的石柱的位置。

我们发现一个满足条件方案的充要条件：

1. $p_i$ 初始的高度可以为 $\{j | \forall^{k \leq j}_{k=i} p_{k} \ge p_i\}$。
1. 初始高度为 $i$ 且最终高度为 $0$ 的石柱编号 $j$ 需要满足 $\forall_{k=1}^{k \leq i} j \leq p_k$。
1. 初始高度为 $i$ 的柱子恰好有两个。

那么我们就可以根据以上的结论写一个小常数 $O(n^4)$ dp，可以通过 $n \leq 60$ 的部分。

首先，设 $f_{i,j}$ 表示目前已经处理到 $p_i=j$，且此时 $p_i$ 为最小值的方案数，设 $b_i$ 为编号 $\leq a_i$ 的非 $a$ 数组石柱数量。

然后考虑枚举 $f_{k,t}$ 并向 $f_{i,j}$ 转移：

从 $p_k$ 到 $p_i$ 总共有 $b_t - b_j$ 个非最终存在的石柱，因为条件 $2$ 所以它们的初始高度一定 $\leq i$，所以这部分方案是 $C_{i+b_t-n-1}^{b_t - b_j} \times (b_t-b_j)!$。

从 $k$ 到 $i$ 之间满足 $\forall_{l=k+1}^{l < i} p_{l} > p_{k}$，这部分是 $C_{n-t-k+1}^{i-k-1}$。

然后这 $p_{k+1} - p_{i-1}$ 内部的方案需要预处理，可以用数组 $g_{i,j}$ 表示长度为 $i$ 的方案，左边有 $j$ 个初始高度可以为这 $i$ 个高度中的任意一个的方案数。然后就可以 $O(n^4)$ 预处理了。

这样的转移是 $O(n^4)$ 的，然后你发现会算重，因为会出现某个初始高度有两个空位，但是考虑转换思路，把初始高度的两个位置当成两个不同的位置，最后再除去 $2^n$ 就行了。

这样你就可以拿到 $60$ 分了。

然后你考虑到 $g$ 的转移是一个非常经典的二维分治 FFT，是 $O(n^2 \log^2 n)$ 的，而 $f$ 的转移可以拆成分别不需要 $j$ 和分别不需要 $k$ 的两份，可以分步转移，是 $O(n^3)$ 的。

给个 $O(n^4)$ 的代码吧。

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long LL;

const int MAXN=600+5,p=1e9+7;

int qpow(int x,int y) {

	int res=1;

	while(y) {

		if(y&1) res=1ll*res*x%p;

		x=1ll*x*x%p,y>>=1;

	}return res;

}

int fac[MAXN],inv[MAXN];

int C(int x,int y) {if(x<y||y<0) return 0;return 1ll*fac[x]*inv[x-y]%p*inv[y]%p;}

int n,a[MAXN],b[MAXN],f[MAXN][MAXN],F[MAXN][MAXN],g[MAXN][MAXN];

signed main() {

	#ifndef ONLINE_JUDGE

	freopen(".in","r",stdin);

	freopen(".out","w",stdout);

	#endif

	ios::sync_with_stdio(0),cin.tie(0);

	cin>>n;fac[0]=1;

	for(int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%p;

	inv[n]=qpow(fac[n],p-2);

	for(int i=n-1;i>=0;--i) inv[i]=1ll*inv[i+1]*(i+1)%p;

	for(int i=1;i<=n;++i) cin>>a[i],b[i]=a[i]-i;

	g[0][0]=1;

	for(int i=1;i<=n;++i) {

		for(int j=1;j<=i;++j) {

			for(int k=0;k<=j-1;++k) {

				for(int t=0;t<=i-j;++t) {

					g[i][k+t+1]=(g[i][k+t+1]+2ll*g[j-1][k]*g[i-j][t]%p*C(k+t+1,k)%p*C(t+2,2)%p*C(i-1,j-1))%p;

					g[i][k+t]=(g[i][k+t]+2ll*g[j-1][k]*g[i-j][t]%p*C(k+t,k)%p*C(t+1,1)%p*C(i-1,j-1))%p;

					if(k+t) g[i][k+t-1]=(g[i][k+t-1]+1ll*g[j-1][k]*g[i-j][t]%p*C(k+t-1,k)%p*C(i-1,j-1))%p;

				}

			}

		}

	}

	b[n+1]=n,f[0][n+1]=1; 

	for(int i=1;i<=n+1;++i) {

		for(int k=0;k<i;++k) {

			for(int t=1;t<=n+1;++t) {

				F[i][t]=(F[i][t]+1ll*f[k][t]*(2ll*g[i-k-1][0]+g[i-k-1][1])%p*C(n-t-k+1,i-k-1))%p;

			}

		}

		for(int j=0;j<=n;++j) {

			for(int t=j+1;t<=n+1;++t) {

				f[i][j]=(f[i][j]+1ll*F[i][t]*C(i-(n-b[t])-1,b[t]-b[j])%p*fac[b[t]-b[j]])%p;

			}

		}

	}

	printf("%lld",1ll*f[n+1][0]*qpow(qpow(2,n+1),p-2)%p); 

	return 0;

} 
```

---

## 作者：EXODUS (赞：1)

# Part 1：前言

感觉不难啊/yiw

# Part 2：正文

先假定同一高度的柱子有区分，最后再除以 $2^n$。从后往前考虑每个石柱 $x$，每次找 $\leq x$ 还未标记的值 $v$，那么 $x$ 最后会被震成 $v$，如果找不到说明 $x$ 湮灭了。那么 dp 记录最大的 $h$ 满足 $1\sim h$ 都被标记了，如果来了一个湮灭石柱，它有 $(h-c)$ 种可能，这里 $c$ 是已经出现了几个湮灭石柱。

否则这个石柱要标记某个值，如果 $h$ 未更新则将其值的确定延后到后方处理，否则考虑 $h$ 增加了 $k$，那么相当于在之前还没有确定值的石柱中再选出 $k-1$ 个，对于这 $k$ 个石柱相当于《将 $1\sim k$ 全部标记并且最后一个标记的是 $1$》方案数。

令 $G_i$ 为《$k$ 个石柱将 $1\sim k$ 全部标记并且最后一个标记的是 $1$》的答案，$F_i$ 为《$k$ 个石柱将 $1\sim k$ 全部标记》的答案，$F,G$ 就可以递推出来了。

这样总的 dp 复杂度就是 $\mathcal{O}(n^3)$。

# Part 3：代码

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;

#define rep(i,l,r) for(int i(l);i<=(r);++i)
#define per(i,r,l) for(int i(r);i>=(l);--i)
#define eb emplace_back
#define File(filename) freopen(filename ".in","r",stdin),freopen(filename ".out","w",stdout)
#define Exit(p) fprintf(stderr,"[exit]: at breakpoint %d\n",p),exit(0);

#ifdef EXODUS
	#define Debug(...) fprintf(stderr,__VA_ARGS__)
#else
	#define Debug(...) 0
#endif

//=========================================================================================================
// Something about IO

template<typename T>
void read(T &x){
	x=0;T flg=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flg=-1;ch=getchar();}
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	x*=flg;
}
template<typename T>
void seq_read(T bg,T ed){for(auto i=bg;i!=ed;++i)read(*i);}
template<typename T,typename... Args>
void read(T &x,Args &...args){read(x),read(args...);}

//=========================================================================================================
//Some useful function

template<typename T>
void cmax(T& x,T y){x=max(x,y);}
template<typename T,typename... Args>
void cmax(T& x,T y,Args ...args){cmax(x,y);cmax(x,args...);}
template<typename T>
void cmin(T& x,T y){x=min(x,y);}
template<typename T,typename... Args>
void cmin(T& x,T y,Args ...args){cmin(x,y);cmin(x,args...);}
template<typename T,typename U>
void seq_assign(T bg,T ed,U val){for(auto i=bg;i!=ed;++i)(*i)=val;}
template<typename T,class F,class=enable_if_t<is_invocable_v<F>>>
void seq_assign(T bg,T ed,F func){for(auto i=bg;i!=ed;++i)(*i)=func(i);}
template<typename T>
void seq_copy(T dstbg,T dsted,T srcbg,T srced){for(auto i=dstbg,j=srcbg;i!=dsted&&j!=srced;++i,++j)(*i)=(*j);}

//=========================================================================================================
// Define the global variables here.

bool membg=0;

const int mod=1000000007;
inline void cadd(int &x,int y){x=(x+y>=mod)?(x+y-mod):(x+y);}
inline int add(int x,int y){return (x+y>=mod)?(x+y-mod):(x+y);}
int qpow(int x,int y){
	int s=1;
	while(y){
		if(y&1)s=1ll*s*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return s;
}
const int N=610;
int n;
int ok[N<<1];
int f[N],g[N],F[N],G[N],C[N][N];

bool memed=0;

//=========================================================================================================
// Code here.

void solve(){
	read(n);
	for(int i=1;i<=n;i++){int x;read(x);ok[x]=1;}
	for(int i=0;i<=n;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++)C[i][j]=add(C[i-1][j],C[i-1][j-1]);
	}
	F[0]=G[0]=1;
	F[1]=G[1]=2;
	for(int i=2;i<=n;i++){
		for(int j=2;j<=i;j++){
			cadd(G[i],1ll*G[i-j+1]*F[j-2]%mod*C[i-2][j-2]%mod);
		}
		G[i]=1ll*G[i]*(i+1)%mod;
		for(int j=1;j<=i;j++)
			cadd(F[i],1ll*G[i-j+1]*F[j-1]%mod*C[i-1][j-1]%mod);
	}
	f[0]=1;
	for(int o=2*n,c0=0,c1=0;o>=1;o--){
		if(!ok[o]){
			for(int i=0;i<=n;i++)if(f[i])f[i]=1ll*f[i]*(i-c0)%mod;
			++c0;
		}
		else{
			for(int i=0;i<=n;i++){
				cadd(g[i],f[i]);
				for(int j=i+1;j<=n;j++)
					if(c1-i>=j-i-1)
						cadd(g[j],1ll*f[i]*C[c1-i][j-i-1]%mod*G[j-i]%mod);
					else break;
			}
			for(int i=0;i<=n;i++)f[i]=g[i],g[i]=0;
			++c1;
		}
	}
	int ans=1ll*f[n]*qpow((mod+1)/2,n)%mod;
	cout<<ans<<'\n';
}


//=========================================================================================================

int main(){
	Debug("%.3lfMB\n",fabs(&memed-&membg)/1024.0/1024.0);
	int timbg=clock();
	int T=1;//read(T);
	while(T--)solve();
	int timed=clock();
	Debug("%.3lfs\n",1.0*(timed-timbg)/CLOCKS_PER_SEC);
	fflush(stdout);
	return 0;
}
```

---

## 作者：UKE_Automation (赞：0)

### P7213 [JOISC 2020] 最古の遺跡 3

[$\text{Link}$](https://www.luogu.com.cn/problem/P7213)

拿到题目没有什么可以下手的地方，如果我们按照值域 dp，把值从大往小填肯定是没有前途的；所以我们要在下标上发现一些性质。对于位置 $i$，我们令 $i$ 地震结束后高度为 $b_i$，手玩一下会发现，如果 $i$ 后面的 $b_i$ 中有 $1\sim a_i$ 的所有整数，那么 $b_i$ 就等于 $0$；否则的话，它应该是 $\le a_i$ 的所有 $b_i$ 中没有出现过的最大整数。

我们考虑利用这个性质进行 dp，设 $f(i,j)$ 表示当前枚举到第 $i$ 位，$i$ 后面的 $b_i$ 已经填满了 $1\sim j$，但是还没有填上 $j+1$ 的方案数。同时为了计数方便，我们强制规定每一种数中的两个数是本质不同的，答案最后就需要除以 $2^n$。设 $c_0$ 表示此时 $i$ 后面钦定消失的柱子个数，$c_1$ 为钦定不消失的柱子个数，分类讨论一下转移：

- 如果当前位置钦定消失：

  显然此时 $j$ 不会变，那么 $1\sim j$ 总共有 $2j$ 个可用的高度，前面填 $1\sim j$ 这些柱子用了 $j$ 个，同时填 $c_0$ 还要用 $c_0$ 个，所以转移为：
  $$
  f(i,j)\leftarrow f(i+1,j)\times (j-c_0)
  $$
  注意这里转移讨论系数的方法比较重要，下文还会运用。

- 如果当前位置钦定不消失，那么还要分 $j$ 是否改变讨论：

  - 当 $b_i > j+1$ 时：

    显然此时 $j$ 不会改变，至于当前的 $a_i$ 取多少我们先不关心，把他的贡献延后计算，转移为：
    $$
    f(i,j)\leftarrow f(i+1,j)
    $$

  - 当 $b_i=j+1$ 时：

    此时我们就需要把之前没有考虑到的 $a_i$ 考虑一下了。枚举一下改变后的值 $k$，先从后面的没有消失且没有填 $1\sim j$ 的柱子中选出 $b_i$ 为 $j+2\sim k$ 的 $k-j-1$ 个柱子，方案为 $\binom{c_1-j}{k-j-1}$。

    然后再确定 $a_i$ 的值，由于 $b_i=j+1$，说明 $a_i$ 只能在 $[j+1,k]$ 中取，套用第一类转移的套路，此时有 $2(k-j)$ 个可用高度，已经用了 $k-j-1$ 个，则剩下的有 $k-j+1$ 种高度。

    最后我们还需要知道后面的 $k-j-1$ 个柱子填数的合法方案数，这个暂时还不知道，我们先记它为 $g_{k-j-1}$。那么转移方程就是：
    $$
    f(i,k)\leftarrow f(i+1,j)\times \binom{c_1-j}{k-j-1}\times (k-j+1)\times g_{k-j-1}
    $$

现在考虑 $g_n$ 怎么求，实际上 $g_n$ 表示的就是 $n$ 个柱子地震后恰好震成 $1\sim n$ 的方案数，那么这个的转移和 $f$ 的第二类转移实际上是比较类似的，我们枚举第一个柱子的最终高度为 $x$，那么后面就应该分成两部分，一部分震成 $1\sim x-1$，另一部分震成 $x+1\sim n$。先选出哪些柱子要震成 $1\sim x-1$，方案数是 $\binom{n-1}{x-1}$ 的，而这两部分选数的方案数则是 $g_{x-1}g_{n-x}$。

现在剩下的就是第一个珠子的初始高度的方案数，继续套用第一类转移的套路，当前初始值只能选 $[x,n]$，总共 $2(n-x+1)$ 个可行高度，而后面占用了 $n-x$ 个，所以方案数是 $n-x+2$ 种。于是转移为：
$$
g_n =\sum _{x=1}^n\binom{n-1}{x-1}\times (n-x+2)\times g_{x-1}\times g_{n-x}
$$
那么我们就可以在 $O(n^3)$ 的时间复杂度内完成这个 dp 了，可以通过。

```cpp
#include <bits/stdc++.h>
#define il inline

using namespace std;

const int Maxn = 1.2e3 + 5;
const int Inf = 2e9;
const int Mod = 1e9 + 7;
il int Add(int x, int y) {return x + y >= Mod ? x + y - Mod: x + y;} il void pls(int &x, int y) {x = Add(x, y);}
il int Del(int x, int y) {return x - y < 0 ? x - y + Mod : x - y;} il void sub(int &x, int y) {x = Del(x, y);}
il int max(int x, int y) {return x >= y ? x : y;} il void chkmax(int &x, int y) {x = (x >= y ? x : y);}
il int min(int x, int y) {return x <= y ? x : y;} il void chkmin(int &x, int y) {x = (x <= y ? x : y);}
il int qpow(int a, int b) {int res = 1; for(; b; a = 1ll * a * a % Mod, b >>= 1) if(b & 1) res = 1ll * res * a % Mod; return res;}
il int Inv(int a) {return qpow(a, Mod - 2);}
template <typename T>
il void read(T &x) {
	x = 0; char ch = getchar(); bool flg = 0;
	for(; ch < '0' || ch > '9'; ch = getchar()) flg = (ch == '-');
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	flg ? x = -x : 0;
}
template <typename T>
il void write(T x, bool typ = 1) {
	static short Stk[50], Top = 0;
	x < 0 ? putchar('-'), x = -x : 0;
	do Stk[++Top] = x % 10, x /= 10; while(x);
	while(Top) putchar(Stk[Top--] | 48);
	typ ? putchar('\n') : putchar(' ');
}
il void IOS() {ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);}
il void File() {freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);}
bool Beg;

int n, m, a[Maxn], vis[Maxn], s[Maxn];
int C[Maxn][Maxn], g[Maxn], f[Maxn][Maxn];

bool End; 
il void Usd() {cerr << (&Beg - &End) / 1024.0 / 1024.0 << "MB " << (double)clock() * 1000.0 / CLOCKS_PER_SEC << "ms\n"; }
int main() {
	read(n);
	for(int i = 1; i <= n; i++) read(a[i]), vis[a[i]] = s[a[i]] = 1;
	m = n << 1;
	for(int i = m; i >= 1; i--) s[i] += s[i + 1];
	C[0][0] = 1;
	for(int i = 1; i <= m; i++) {
		C[i][0] = 1;
		for(int j = 1; j <= i; j++) C[i][j] = Add(C[i - 1][j], C[i - 1][j - 1]);
	}
	g[0] = 1;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			pls(g[i], 1ll * (i - j + 2) * C[i - 1][j - 1] % Mod * g[j - 1] % Mod * g[i - j] % Mod);
		}
	}
	f[m + 1][0] = 1;
	for(int i = m; i >= 1; i--) {
		int c1 = s[i + 1], c0 = m - i - c1;
		if(!vis[i]) {
			for(int j = c0; j <= n; j++) pls(f[i][j], 1ll * f[i + 1][j] * (j - c0) % Mod);
		}
		else {
			for(int j = 0; j <= n; j++) {
				pls(f[i][j], f[i + 1][j]);
				for(int k = j + 1; k <= n; k++) {
					if(c1 >= j) pls(f[i][k], 1ll * f[i + 1][j] * C[c1 - j][k - j - 1] % Mod * g[k - j - 1] % Mod * (k - j + 1) % Mod);
				}
			}
		}
	}
	int ans = 1ll * f[1][n] * Inv(qpow(2, n)) % Mod;
	write(ans);
	Usd();
	return 0;
}

```

---

## 作者：居然有个高手 (赞：0)

观察原序列与最终保留序列的关系：首先原序列中 $h_i = n$ 的两个位置中靠后的位置一定会保留下来。原因是它后面的位置再出现一个 $n$。此刻靠前的位置变为 $n-1$。

然后再加入原序列中 $h_i = n-1$ 的两个位置，现在这三个位置中最靠后的也会被保留下来，原因相同。再往后加入 $h_i \in [1,n-2]$ 之后的结论是类似的。

这告诉我们，最终保留下来的序列可以由以下操作得到：按值域从大往小，每次填进新的两个位置后，选择最大的位置保留下来并删除。

下文中称出现在 $a_i$ 中的位置为应保留下来的位置，并记 $p_i$ 为 $>a_i$ 的不应保留下来的位置的个数，$q_i$ 为 $<a_i$ 的不应保留下来的位置的个数（即 $a_i -i$）。

容易发现，若目前最小的未保留下的应保留下来的位置为 $a_i$，那么我们就不能选取 $>a_i$ 的不应保留下来的位置，否则一定会错误保留一个位置。同时，$<a_i$ 的不应保留下来的位置可以任取，其不会影响后面的保留情况。

这启发我们记录状态 $f_{i,j,k,0/1}$ 表示目前填入了 $2i$ 个数，其中最小的未保留下来的应保留下来的位置为题面中的 $a_j$，$<a_j$ 的不应保留下来的位置还有 $k$ 个未被填入，且 $a_j$ 的填入情况为 $0/1$ 时的方案数。

那么，我们可以算出 $\ge a_j$ 且还未被填入的 $a_x$ 有 $c=2(n-i)-p_j-k$ 个。$\ge a_j$且已被填入且已被保留的 $a_y$ 有 $o=i-j+1$ 个。原因是 $>a_j$ 的不应保留的位置全部未被填入，且 $<a_j$ 的应保留位置已全部填入并保留。

考虑每次填入两个值，我们可以填入 $\ge a_j$ 的应保留值或 $<a_j$ 的不应保留值。容易发现，当 $a_j$ 未填入时，其变为被保留当且仅当填入 $a_j$ 与一个 $<a_j$ 的不应保留值；$a_j$ 已填入时，其变为被保留当且仅当填入两个 $<a_j$ 的不应保留值。

当最小的不应保留值变化时，我们还需要枚举其变化量 $l$，此时应从拿出若干个上文提到的 $a_y$ 填在 $[j+1,l]$。但我们发现 $a_y$ 出现重复情况时其并非简单的 $n$ 选 $m$ 排列，但也无法暴力记录；不过 $a_y$ 最多只会出现两个重复值，因此我们视为填入的 $h_i$ 是 $[1,2n]$ 的排列，最后再将答案除以 $2^n$ 可得到原答案。

现在可以开始转移了！对于 $f_{i,j,k,0}$，我们有以下转移：

$f_{i,j,k,0} \to f_{i+1,j,k,0}$，即填入两个 $>a_j$ 的应保留值，要求 $c\ge 3$。

$f_{i,j,k,0} \times 2 \to f_{i+1,j,k,1}$，即填入 $a_j$ 与一个 $>a_j$ 的应保留值。要求 $c\ge 2$。

$f_{i,j,k,0}\times k\times 2 \to f_{i+1,j,k-1,0}$，即填入一个 $>a_j$ 的应保留值与一个 $<a_j$ 的不应保留值，要求 $c\ge 2,k\ge 1$。

$f_{i,j,k,0}\times k\times 2\to f_{i+1,j,k-1,1}$，即填入 $a_j$ 与一个 $<a_j$ 的不应保留值，要求 $k\ge 1$，并且还有一个 $>a_j$ 的已填入值还未被保留，即 $n-j+1-c > o$。

$f_{i,j,k,0}\times k\times(k-1)\to f_{i+1,j,k-2,0}$，即填入两个 $<a_j$ 的不应保留值，要求 $k\ge 2$，同样要求 $n-j+1-c > o$。

$f_{i,j,k,0}\times k\times 2\times A_{l-j-1}^o \to f_{i+1,l,p,0}$，其中 $p = k-1 + q_l - q_j$，即填入 $a_j$ 与一个 $<a_j$ 的不应保留值，并且此时 $a_j$ 被保留。枚举下一个未被填入的值 $l$，则带的权值为从 $o$ 中选 $l-j-1$ 个填给 $[j+1,l-1]$。要求 $k\ge 1,n-j+1-c=o$。

对于 $f_{i,j,k,1}$，有如下转移：

$f_{i,j,k,1}\to f_{i+1,j,k,1}$，即填入两个 $>a_j$ 的应保留值，要求 $c\ge 2$。

$f_{i,j,k,1} \times k\times 2 \to f_{i+1,j,k-1,1}$，即填入一个 $>a_j$ 的应保留值与一个 $<a_j$ 的不应保留值，要求 $c\ge 1,k\ge 1$。

$f_{i,j,k,1}\times k\times (k-1)\to f_{i+1,j,k-2,1}$，即填入两个 $<a_j$ 的不应保留值。要求 $k\ge 2$，且有一个 $>a_j$ 的应保留值已被填入且未被保留，即 $n-j+1-c>o+1$。

$f_{i,j,k,1}\times k\times (k-1)\times A_{l-j-1}^o\to f_{i+1,l,p,0}$，其中 $p=k-2+q_l-q_j$，即填入两个 $<a_j$ 的不应保留值。且 $a_j$ 恰好在本回合被保留，同样枚举下一个未被填入的应保留值 $l$，从 $o$ 中选 $l-j-1$ 个填给 $[j+1,l-1]$。要求 $k\ge 2$ 且 $n-j+1-c=o+1$。

容易发现两种需要枚举 $l$ 的转移要求会导致在 $i,j$ 固定时 $k$ 也固定，因此产生的转移量仅为 $O(n^3)$ 级别。

上述转移需要滚动数组进行空间复杂度的优化。本题得到解决。

时间复杂度：$O(n^3)$，空间复杂度：$O(n^2)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=605,mod=1e9+7,inv2=(mod+1)/2;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
int n,a[N],jie[N<<1],inv[N<<1],f[2][N][N][2],p[N];
inline int A(int n,int m){
	return jie[n]*1ll*inv[n-m]%mod;
}
int main(){
	n=read();
	for(int i = 1;i<=n;i++)a[i]=read(),p[i]=(2*n-a[i])-(n-i);
	jie[0]=jie[1]=inv[0]=inv[1]=1;
	for(int i = 2;i<=n*2;i++)jie[i]=jie[i-1]*1ll*i%mod,inv[i]=inv[mod%i]*1ll*(mod-mod/i)%mod;
	for(int i = 2;i<=n*2;i++)inv[i]=inv[i-1]*1ll*inv[i]%mod;
	f[0][1][a[1]-1][0]=1;
	a[n+1]=2*n+1;
	for(int i = 0,now=0,nxt=1;i<n;i++,now^=1,nxt^=1){
		memset(f[nxt],0,sizeof f[nxt]);
		for(int j = 1;j<=n;++j){
			for(int k = 0;k<=a[j]-j;k++){
					int c = 2*n-2*i-p[j]-k,o = i - (j-1);
					if(f[now][j][k][0]){
						if(c>=3)f[nxt][j][k][0]=(f[nxt][j][k][0]+f[now][j][k][0])%mod;
						if(c>=2){
							f[nxt][j][k][1]=(f[nxt][j][k][1]+1ll*f[now][j][k][0]*2)%mod;
							if(k)f[nxt][j][k-1][0]=(f[nxt][j][k-1][0]+1ll*f[now][j][k][0]*k*2)%mod;
						}
						if(n-j+1-c != o){
							if(k)f[nxt][j][k-1][1]=(f[nxt][j][k-1][1] + 1ll*f[now][j][k][0]*k*2)%mod;	
							if(k>=2)f[nxt][j][k-2][0]=(f[nxt][j][k-2][0] + 1ll*f[now][j][k][0]*k*(k-1))%mod;
						}
						else if(k){
							for(int l = j+1;l-j-1<=o;l++)f[nxt][l][k-1+(a[l]-l)-(a[j]-j)][0]=(f[nxt][l][k-1+(a[l]-l)-(a[j]-j)][0] + 1ll*f[now][j][k][0]*k*2%mod*A(o,l-j-1))%mod;
						}
					}
					if(f[now][j][k][1]){
						if(c>=2)f[nxt][j][k][1]=(f[nxt][j][k][1]+1ll*f[now][j][k][1])%mod;
						if(c&&k)f[nxt][j][k-1][1]=(f[nxt][j][k-1][1]+1ll*f[now][j][k][1]*k*2)%mod;
						if(k>=2){
							if(n-j+1-c!=o+1)f[nxt][j][k-2][1]=(f[nxt][j][k-2][1]+1ll*f[now][j][k][1]*k*(k-1))%mod;
							else{
								for(int l = j+1;l-j-1<=o;l++)f[nxt][l][k-2+(a[l]-l)-(a[j]-j)][0]=(f[nxt][l][k-2+(a[l]-l)-(a[j]-j)][0] + 1ll*f[now][j][k][1]*k*(k-1)%mod*A(o,l-j-1))%mod;
							}
						}
					}
			}
		}
	}
	for(int i = 1;i<=n;i++)f[n&1][n+1][0][0]=1ll*f[n&1][n+1][0][0]*inv2%mod;
	cout<<(f[n&1][n+1][0][0]+mod)%mod;
	return 0;
}
```

---

## 作者：Komomo (赞：0)

> 感觉不是很难。。但是卡在中间了

首先容易发现题目这个操作可以延迟的，也就是其实按照值域操作也是可以的。如 $[1,2,1,2,3,3]$，先对 $3$ 操作 $[1,2,1,2,2,3]$，再对 $2$ 操作 $[1,1,1,1,2,3]$，最后得到了 $[0,0,0,1,2,3]$。

于是我们就可以再转化一下，最终序列一定是这样得到的：目前有空集 $S$，对于 $i=2n\cdots 1$，如果目前 $\text{mex}(S)\le a_i$（以下 $\text{mex}$ 从 $1$ 开始定义），那么 $i$ 最终值为 $\text{mex}$ 并将其加入 $S$，否则 $i$ 没值。

很熟悉的想到了 CF1608F，我们能不能加入只和目前最大的 $t$ 使得所有 $1\sim t\in S$ 的 $t$ 有关，剩下的延续钦定就好了。令 $f_{i,j}$ 表示考虑了 $i\sim 2n$ 的元素，目前最大的值域连续段是 $1\sim j$，我就卡在这里了，觉得非常不好转移啊！但是写写发现就明朗了，令 $c_0$ 表示 $i+1\sim 2n$ 最终没数的位置数，$c_1$ 反之。

- 当前位置最终没数了
  - 这里有一个结论：如果存在 $S$ 中存在连续段 $1\sim t$，那么这些对应的原始数取值范围一定也是 $[1,t]$，否则如果有更大的 $t$ 也会更大。这里为了好转移，同个数区分开来，最后除掉 $2^n$ 就好了，于是转移为 $f_{i-1,j}\cdot (2j-c_0)\rightarrow f_{i,j}$。
- 当前位置最终有数
  - 第一种填法就是不会改变连续段大小，那么延续钦定就不用管系数了，$f_{i-1,j}\rightarrow f_{i,j}$。
  - 第二种填法改变了连续段大小，假如说原来连续段为 $1\sim j$，新的连续段为 $1\sim k$，首先目前总共能填的有 $2k$ 个数，需要钦定 $k-j-1$ 个数，而且不能填值域 $\le j$ 的数，所以 $i$ 能选的个数为 $2k-k+j+1-2j=k-j+1$。剩下的我们先从 $c_0-j$ 个没钦定的里面选 $k-j-1$，然后希望他们最终能变成一个长度为 $k-j-1$ 的连续段，现在没法快速计算，设这个系数为 $g_{k-j-1}$，那么有转移 $f_{i-1,j}\cdot \dbinom{c_0-j}{k-j-1}\cdot(k-j+1)\cdot g_{k-j-1}\rightarrow f_{i,k}$。

现在转化求 $g_i$，表示值域在 $[1,i]$ 的 $i$ 个数经过地震之后每个位置都不为 $0$ 的方案数，这个是同理的，有转移式 $g_n=\sum\limits_{i=0}^{n-1}(n-i+1)\dbinom{n-1}{i}g_ig_{n-i-1}$，前面系数是第一个数的填法，第二个组合数是把 $g_i$ 插到 $g_{n-i-1}$ 的方案数，时间复杂度 $\mathcal O(n^3)$。

---

## 作者：intel_core (赞：0)

原来上原神文化课才是原神题的打开方式。

首先考虑题目中“最后只会剩下 $n$ 根石柱”这一句话的含义。注意到对于 $[1,n]$ 内的每一个高度 $h$，当前都一定存在至少一根高度为 $h$ 的石柱，因此剩下的石柱的高度是 $n$ 的排列。

记原高度序列为 $h_{1,2,\cdots,2n}$，变换后的高度序列为 $l_{1,2,\cdots,2n}$，$s_i$ 表示 $l_j=i$ 的 $j$ 的数量。

先考虑通过 $h$ 直接计算 $l$。考虑一次地震对 $s$ 数组产生的影响，很明显新的 $s'$ 可以直接通过 $s$ 得到：$s_n=1$，$s'_i=s_{i+1}(i<n)$。

注意到初始时 $s_i=2$，所以在进行 $T$ 次地震后的 $s$ 显然为 $n-T$ 个 $2$ 和 $T$ 个 $1$ 依次拼接得到，即 $s_i=1+[i\le n-T]$。也就是说，在第 $T$ 次地震之后我们就可以知道 $b_p=n-T+1$ 的 $p$ 是多少，也就是最终状态下剩下的石柱中高度为 $n-T+1$ 的那个。

> 结论：我们可以通过以下方式求得正确的 $l_{1,2,\cdots,2n}$：倒序枚举 $i$，令 $k=h_i$，若不存在 $j>i$ 使得 $l_j=k$，则令 $l_i=k$，否则将 $k$ 减一，并重复前述过程直到 $k\le 0$ 为止。

证明：设 $p_{1,2,n\cdots,n}$ 满足 $l_{p_i}=i$，考虑归纳证明上述过程所得 $p_i$ 的正确性。

* 当 $i=n$ 时显然。

* 若 $i> k$ 时结论都成立，来证 $i=k$ 时的情况：

	考虑 $n-k$ 次地震后的 $l$，对于所有 $h_j\ge k$ 且没有确定最终高度的 $j$ 此时一定都有 $l_j\le k$。
    
   在上述 $j$ 当中我们找到最大的 $j_{max}$，显然 $l_{j_{max}}$ 在此时一定是 $k$，所以我们可以得到 $p_k=j_{max}$。
    
   显然，依此得到的 $p_k$ 和前述方法所求是一致的。于是我们验证了 $p_k$ 的正确性。
   
现在再来考虑 $l_i=0$ 的 $i$ 带来限制。比如说我们令 $l_x=0$，那我们可以得到对于任意的 $k\le h_x$，都存在 $j>x$ 使得 $l_j=k$，即 $1,2,\cdots,h_x$ 这些数的最终状态里的位置在枚举到 $x$ 时已经被确定了。

相当于在 DP 的时候我们只用考虑当前已经确定的 $l$ 的 MEX 即可。很自然地，DP 状态可以设计为 $f_{i,j}$ 表示从后往前考虑到 $i$，已经确定的 $l$ 的 MEX 为 $j+1$ 的情况总数。

但是这样设计的状态在 $i$ 不在 $A$ 中时无法转移，所以考虑在 $j'\to j$ 的转移时将 $[j'+1,j]$ 中的所有数都考虑进转移系数里。对应的，状态更改为从后往前考虑到 $i$，已经确定的 $l$ 的 MEX 为 $j+1$，并且钦定 $1,2\cdots,j$ 中的数的相对顺序后的情况总数。

考虑转移。对于不在 $A$ 中的 $i$ 转移显然为 $f_{i,j}=f_{i+1,j}$。

对于在 $A$ 中出现的 $i$，考虑转移点 $f_{i+1,k}$：

* 若 $j=k$，那么 $f_{i,j}=f_{i+1,k}$。

* 若 $j>k$，可以得到 $l_i=k+1$，我们还需要选出 $j-k-1$ 个数并钦定它们的 $l$，这一步有 $\tbinom{c_i-k-1}{j-k-1}$ 种选法，其中 $c_i$ 表示 $\ge i$ 且在 $A$ 中出现的 $j$ 的数量。

	再考虑如何计算相对顺序带来的贡献。注意到对于我们已经钦定了 $l_x$ 的 $x$，一定都有 $h_x\le k$。否则若存在 $y$ 使得 $l_y\le k$ 且 $h_y > k$，那么 $p_{k+1}$ 一定不小于 $y$，这与当前钦定的 $l_i=k+1$ 矛盾。
    
   此时我们要处理的问题相当于就是一个规模为 $j-k$ 的子问题。令 $g_i$ 表示规模为 $i$ 的子问题的答案，那么这部分的转移系数就是 $g_{j-k}$。
   
   最后一部分转移系数来自将 $[k+1,j]$ 和 $[1,j]$ 中还没选完的数钦定一个相对顺序。不难发现这就是一个简单的组合数 $\tbinom{j-d_i}{j-k}$，其中 $d_i$ 表示 $\ge i$ 且不在 $A$ 中出现的 $j$ 的数量。
   
由上，$g_x$ 表示将 $1,2,\cdots,x$ 各两个排列成 $u_{1,2,\cdots,2x}$，且模拟地震后的序列 $v_{1,2,\cdots,2n}$ 满足 $v_{1,2,\cdots,x}$ 为 $0$，$v_{x+1,x+2,\cdots,2x}$ 是一个 $x$ 的排列且 $v_{x+1}=1$ 的情况总数。现在考虑如何计算 $g_x$ 的值。

先考虑 $\{u_i\}$ 合法的等价条件：

> 结论：令 $w_i$ 为 $u_j\le i$ 且 $j\ge x+1$ 的 $j$ 的个数，则 $\{u_i \}$ 合法等价于对于任意的 $i\le x$ 都有 $w_i\le i$，即 $u_{x+1,\cdots,2x}$ 中不超过 $i$ 的数至多 $i$ 个。

证明：必要性显然，下面来证充分性。

注意到根据 $u$ 求 $v$ 的过程相当于二分图匹配：把 $v_{x+1,x+2,\cdots,2x}$ 和 $1,2,\cdots,x$ 一一配对，现在要证的是按照前述的方法算出的 $v$ 相当于是完美匹配。

由于前述条件相当于 Hall 定理的判句，所以一定存在一组完美匹配，而我们贪心求 $v_i$ 的过程显然是不劣的，因此求出的 $v_i$ 一定对应着一组完美匹配。

我们先枚举一个 $x$，考虑 DP 计算 $g_x$ 的值，令 $dp_{i,j,k}$ 表示钦定完 $u_{x+1,x+2,\cdots,2x}$ 中 $\le i$ 的数，一共钦定了 $j$ 个，有 $k$ 个数被钦定了两次的情况总数。

考虑转移：枚举 $i,j,k$ 后考虑当前选几个即可，系数即为 $\tbinom{x-j-t}{t}$，注意 $i=1$ 时的特殊情况。

接着考虑 $u_{1,2,\cdots,x}$ 的方案总数：对于 $dp_{x,x,k}$，贡献系数就是 $\frac{x!}{2^k}$，因为在排列中有一个数重复出现就 $\div 2$。

这样求 $g$ 是 $O(n^4)$ 的，考虑优化：

注意到上面贡献系数和 $k$ 的关系是好求的，因此我们在每次 $k$ 变大时就给 DP 值 $\div 2$，就去掉了 $k$ 这一维，对应的，要把 $u_{x+1}$ 有没有被钦定单独加一维。

这样整体复杂度变为 $O(n^3)$，可以通过。

终于写完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=1210;
#define int long long
int n,fac[NR],ifac[NR],flag[NR],s1[NR],s2[NR],f[NR][NR],g[NR][2],dp[NR][NR][2];
const int MOD=1e9+7;
const int Inv2=5e8+4;
void add(int &x,int y){(x+=y)%=MOD;}

int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=res*x%MOD;
		x=x*x%MOD;y>>=1;
	}
	return res;
}
int Inv(int x){return qpow(x,MOD-2);}
int C(int x,int y){return fac[x]*ifac[x-y]%MOD*ifac[y]%MOD;}

signed main(){
	cin>>n;
	for(int i=1,x;i<=n;i++)
		cin>>x,flag[x]=1;
	fac[0]=ifac[0]=1;
	for(int i=1;i<=n;i++)
		fac[i]=fac[i-1]*i%MOD,ifac[i]=ifac[i-1]*Inv(i)%MOD;
	for(int i=2*n;i>=1;i--){
		s1[i]=s1[i+1];s2[i]=s2[i+1];
		if(flag[i])s1[i]++;
		else s2[i]++;
	}
	for(int len=0;len<n;len++){
		memset(dp,0,sizeof(dp));
		dp[0][0][0]=1;
		for(int i=0;i<len;i++)
			for(int j=0;j<=i;j++){
				add(dp[i+1][j][0],dp[i][j][0]);
				add(dp[i+1][j+1][0],dp[i][j][0]*(len-j));
				add(dp[i+1][j][1],dp[i][j][0]);
				if(j<i)add(dp[i+1][j+2][0],dp[i][j][0]*Inv2%MOD*C(len-j,2));
				add(dp[i+1][j+1][1],dp[i][j][0]*Inv2%MOD*(len-j));
				add(dp[i+1][j][1],dp[i][j][1]);
				add(dp[i+1][j+1][1],dp[i][j][1]*(len-j));
				if(j<i)add(dp[i+1][j+2][1],dp[i][j][1]*Inv2%MOD*C(len-j,2));
			}
		g[len][0]=dp[len][len][0];g[len][1]=dp[len][len][1];
	}
	f[n*2+1][0]=1;
	for(int i=2*n;i>=1;i--){
		if(flag[i]){
			for(int j=s2[i];j<=s1[i];j++){
				add(f[i][j],f[i+1][j]);
				for(int k=s2[i];k<j;k++)add(f[i][j],f[i+1][k]*C(s1[i]-k-1,j-k-1)%MOD*
					((g[j-k-1][0]+g[j-k-1][1])*fac[j-k]%MOD)%MOD*C(k-s2[i]+(j-k),j-k));
			}
		}
		else{
			for(int j=s2[i];j<=s1[i];j++)f[i][j]=f[i+1][j];
		}
	}
	cout<<f[1][n]<<endl;
	return 0;
}
```

---

## 作者：takanashi_mifuru (赞：0)

考虑一个石柱是往后寻找有没有能抗他的，如果能就把他往下压，容易发现，一个柱子被往下压不会导致这个石柱序列有任何的数本来能够往下压现在不能往下压。

也就是操作不会使得高度集合变小，这个性质非常优秀。

考虑假设现在有一个操作后的高度集合，我要加入一个柱子，那怎么判定他最后会不会留下来？

假设他的高度为 $h$，则如果区间 $[1,h]$ 的石柱都有了，他就会直接掉到 $0$，原因显然，否则的话他就掉不到。

根据这个东西状压，居然可以通过 6 分，有点厉害。

根据上面这个形式我们容易发现，在判定高度是否合法这件事上，我只关心他最小的没有被使用的高度是谁，所以我们考虑只记录这个东西进入状态。

具体来讲，设 $dp_{i,j}$ 表示对于前 $i$ 个点，区间 $[1,j]$ 都有石柱但 $j+1$ 没有的方案数。

考虑对这个东西转移，但是很失败，因为我根本不知道有多少种互不相同的颜色可以选择，具体来说，前面选择了一些要被拿下的点，有可能会把一个颜色占满，也有可能一个颜色剩两个空位，这样的话具体情况变得难以计算。

所以我们考虑**给颜色打标签**，因为虽然我不知道互不相同的颜色有多少种，但是我知道总共剩下多少个空位，所以我们选择先暂时给颜色打标签，转移完再撕掉。

那么这样的话这一部分式子就变得非常方便推。

然后考虑如果我要拓新段怎么办，将其分为两个部分。

1. 取到 $j+1$ 以上。

显然他的取值没办法影响状态，考虑延后钦定。

2. 取到 $j+1$。

这样的话就能拓出新段来，假设我们想要拓到 $k$，那么就考虑首先我必须取到 $j+1$，不然的话就会和后面已经取到过 $j+1$，可能转移到一个 $l$，再从 $l$ 转移到 $k$ 的状态算重，就很不好。

于是考虑区间 $[j+1,k]$ 有多少个能选的，考虑我们给颜色打了标签，而区间 $[j+2,k]$ 在后面有 $k-j-1$ 个**带标签的高度**被别人选走了，而 $j+1$ 因为保证了后面没人选过我是第一个达成的，所以有两个**带标签的高度**可以选择，我能选的就是 $2(k-j-1)-(k-j-1)+2=k-j+1$ 个**带标签的高度**。

然后考虑对于后面的，我可以用组合数选出我前面准备延后钦定的点拿过来，然后因为我钦定这些点在地震的最后会变成区间 $[j+2,k]$，但是初始状态我不晓得，容易发现这个东西显然只跟长度有关，所以我设 $g_i$ 表示长度为 $i$ 的序列有多少个在地震的最后把下标集合取到 $[1,i]$。

然后这个转移是容易的，考虑枚举第一个在最后会变成什么，假设变成了 $j$，那么在后面首先要在 $i-1$ 中选出 $j-1$ 个数组成 $[1,j-1]$，再用剩下的数组成 $[j+1,i]$，然后对于当前点，考虑区间 $[j+1,i]$ 用了 $i-(j+1)+1=i-j$ 个带标签的高度，再加上他自己还有两个带标签的高度，那么剩下 $2(i-(j+1)+1)-(i-(j+1)+1)+2=i-j+2$ 个带标签的高度可以使用。

那么我们就转移完了，最后不要忘记撕掉标签，也就是除以 $2^n$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int P=1e9+7;
int n;
int p[1205];
int dp[1205][1205];
int g[1205];
bool vis[1205];
int pre[1205];
int power(int x,int y=P-2){
   if(y==0)return 1;
   int tmp=power(x,y>>1);
   if(y&1)return tmp*tmp%P*x%P;
   return tmp*tmp%P;
}
int fac[1205];
int invfac[1205];
int C(int n,int m){
   return fac[n]*invfac[m]%P*invfac[n-m]%P;
}
signed main(){
   fac[0]=1;
   for(int i=1;i<=1200;i++)fac[i]=fac[i-1]*i%P;
   invfac[1200]=power(fac[1200]);
   for(int i=1200;i>=1;i--)invfac[i-1]=invfac[i]*i%P;
   scanf("%lld",&n);
   //
   g[0]=1;
   // g[1]=1;
   for(int i=1;i<=2*n;i++){
      for(int j=1;j<=i;j++){
         g[i]+=C(i-1,j-1)*(i-j+2)%P*g[j-1]%P*g[i-j]%P;
         if(g[i]>=P)g[i]-=P;
      }
   }
   for(int i=1;i<=n;i++)scanf("%lld",&p[i]);
   int st=1,ed=n;
   while(st<ed)swap(p[st++],p[ed--]);
   for(int i=1;i<=n;i++)p[i]=2*n-p[i]+1;
   for(int i=1;i<=n;i++)vis[p[i]]=true;
   for(int i=1;i<=2*n;i++)pre[i]=pre[i-1]+vis[i];
   dp[0][0]=1;
   for(int i=1;i<=2*n;i++){
      if(!vis[i]){
         for(int j=0;j<=pre[i-1];j++){
            int num=j-(i-1-(pre[i-1]));
            if(num<=0)continue;
            dp[i][j]+=dp[i-1][j]*num;
            dp[i][j]%=P;
         }
         continue;
      }
      for(int j=0;j<=pre[i-1];j++){
         dp[i][j]=dp[i-1][j];
      }
      for(int j=0;j<=pre[i-1];j++){
         for(int k=j+1;k<=pre[i];k++){
            int num=pre[i-1]-j;
            int need=k-j-1;
            if(need>num)continue;
            dp[i][k]+=dp[i-1][j]*C(num,need)%P*g[need]%P*(k-j+1)%P;//
            if(dp[i][k]>=P)dp[i][k]-=P;
         }
      }
   }
   printf("%lld\n",dp[2*n][n]*power(power(2),n)%P);
   return 0;
}
/*

*/
```

---


# [JOISC 2020] 美味しい美味しいハンバーグ

## 题目背景

JOISC2020 Day 1 T2

由于数据点较多，本题只评测其中的部分数据。

下面的题意是简要题意。

## 题目描述

有一个 $10^9\times 10^9$ 的金属网格，其中 $(x,y)$ 表示从左往右第 $x$ 列，从上往下第 $y$ 行的格子。（$1\leq x,y\leq 10^9$）。在这些网格上放了 $N$ 块汉堡肉，依次编号为 $1,\cdots,N$，其中第 $i$ 块汉堡肉放在以 $(L_i,D_i)$ 为左下角，$(R_i,U_i)$ 为右上角的矩形区域内，并且汉堡肉可以重叠。

你需要检查所有的汉堡肉是否煮熟。你可以选择金属网上的 $K$ 个格子，并且垂直地在这个格子中间插一根竹签。对于每一块汉堡肉来说，你可以通过在它所处的格子中插一根竹签来确认这块汉堡肉是否煮熟。当然，你也可以在一个格子里面插多根竹签或者是在没有汉堡肉的格子插竹签，尽管这很不必要。

形式上说，你需要找到 $K$ 组 $(x_1,y_1),\cdots,(x_k,y_k)$，满足以下条件：

- 对于所有 $i$，存在一个 $j$ 满足 $L_i\leq x_j\leq R_i,D_i\leq y_j\leq U_i$。

- 对于所有 $j$，$1\leq x_j,y_j\leq 10^9$。

你需要写一个程序来找出这 $K$ 组 $(x_j,y_j)$，数据保证有解。

## 说明/提示

#### 样例 1 解释

在 $(2,2)$ 处插一根竹签，可以确定前两块汉堡肉是否煮熟，在 $(7,4)$ 处插一根竹签，可以确定后两块汉堡肉是否煮熟。

另一种可行方案是，在 $(3,3)$ 和 $(6,4)$ 处分别插一根竹签。

#### 子任务

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $N\leq 2000,K=1$ | $1$ |
| $2$ | $N\leq 2000,K=2$ | $1$ |
| $3$ | $N\leq 2000,K=3$ | $3$ |
| $4$ | $N\leq 2000,K=4$ | $6$ |
| $5$ | $K=1$ | $1$ |
| $6$ | $K=2$ | $3$ |
| $7$ | $K=3$ | $6$ |
| $8$ | $K=4$ | $79$ |

对于 $100\%$ 的数据，$1\leq n\leq 2\times 10^5,1\leq k\leq 4,1\leq L_i\leq R_i\leq 10^9,1\leq D_i\leq U_i\leq 10^9$，数据保证有解。



## 样例 #1

### 输入

```
4 2
2 1 3 3 
1 2 4 3 
6 1 7 4
5 3 7 5```

### 输出

```
2 2
7 4```

## 样例 #2

### 输入

```
3 3
1 1 1 1
1 2 1 2
1 3 1 3```

### 输出

```
1 1
1 2
1 3```

# 题解

## 作者：syf2008 (赞：14)

**本解法非正解，但是能过所有数据（包括 loj 加强版），欢迎 hack**

## 题意

平面上给定 $n$ 个矩形，选择 $k$ 个点，使得每个矩形内部都至少被选择一个点。

$n\le 2 \times 10^5$，$k\le 4$，保证数据有解。

## Solution


发现这个 $k$ 特别小，可以考虑随机。


我们可以先钦定 $k$ 个矩形为特殊矩形（在每个矩形上都要至少选一个点），然后其它矩形与特殊矩形做矩形交，让这些矩形和任意与它有交的特殊矩形交集为合并的结果。

具体的，可以考虑每次随机序列，这样虽然能过原题数据，但是在 loj 的加强版会寄，即使你加入去重，去掉所有重复的矩形，通过了 loj 的 hack，其实还是错的。

## mkdata:

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int n=2e5,k=2;
	cout<<n<<' '<<k<<'\n';
	for(int i=1;i<=99999;i++)
	cout<<i<<" 1 500000000 1000000000\n";
	for(int i=100000;i<=199999;i++)
	cout<<"500000000 "<<i-99999<<" 1000000000 999999999\n";
	cout<<"1000000000 1000000000 1000000000 1000000000\n";
}
```

所以，我们考虑更加优秀的随机。

我们发现，如果重构整个序列，其实是不优的，所以我们可以把第一个无法与特殊矩形相交的矩形向前随机交换，这样就可以通过加强版数据了。

## code:
```cpp
#include<bits/stdc++.h>
const int N=2e5+5;
using namespace std;
struct meat{int x,y,xx,yy;}a[N],b[10];
meat jiao(meat a,meat b)//求矩形交
{return (meat){max(a.x,b.x),max(a.y,b.y),min(a.xx,b.xx),min(a.yy,b.yy)};}
mt19937 rnd(time(0));
int n,k,tmp;
double S(meat a){return 1.0*(a.yy-a.y+1)*(a.xx-a.x+1);}
double calc(meat a,meat b)
{   
    meat temp=jiao(a,b);
    if(temp.x>temp.xx||temp.y>temp.yy)return -1;
    return S(temp)/S(a);
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    cin>>a[i].x>>a[i].y>>a[i].xx>>a[i].yy;
    while(1)
    {
        for(int i=1;i<=k;i++)b[i]=a[i];
        for(int i=k+1,id;i<=n;i++)
        {
            id=0;
            for(int j=1;j<=k;j++)
            {
                double now=calc(b[j],a[i]);
                if(now>0)id=j;
            }
            if(!id){swap(a[i],a[rnd()%(i-1)+1]);goto ff;}//无法与特殊矩形相交，向前随机交换
            b[id]=jiao(b[id],a[i]);//用交集替换
        }
        for(int i=1;i<=k;i++)
		if(!b[i].x)cout<<1<<' '<<1<<'\n';//如果 n<k 那么就会有点空出来，直接随便放在任意位置即可 
	else cout<<b[i].x<<' '<<b[i].y<<'\n';//输出合法解
        return 0;
        ff:;
    }
}
```

---

## 作者：18Michael (赞：11)

## 题意

有 $N(\le2\times10^5)$ 个矩形，要选出 $K(\le4)$ 个点使得每个矩形内都有至少一个点。保证有解。

## 题解

神仙题，值得一想，~~不值得一写~~。

从简单情况开始考虑。

$K=1$，直接求矩形交。

$K=2$，还是先直接求矩形交，若加入矩形 $A$ 前交集不为空但加入 $A$ 后交集为空，则存在已加入的矩形与 $A$ 交为空。

这是为什么呢？考虑反证。注意到若三个矩形 $A,B,C$ 满足 $A\cap B\ne\varnothing$，$A\cap C\ne\varnothing$，$A\cap(B\cap C)=\varnothing$，则 $B\cap C=\varnothing$。

那么，若 $A\cap B\ne\varnothing$，$A\cap C\ne\varnothing$，$B\cap C\ne\varnothing$，则 $A\cap(B\cap C)\ne\varnothing$。

因此，假设已加入的矩形都与 $A$ 有交，又由于已加入的矩形两两间有交，故任意两个已加入的矩形的交与 $A$ 有交，进而推出任意个已加入的矩形的交与 $A$ 有交，矛盾！故存在已加入的矩形与 $A$ 交为空。

故我们可以在 $O(n)$ 的时间内找出一个与 $A$ 无交的矩形 $B$，之后再从头加矩形。我们把只与 $A$ 或 $B$ 有交的矩形加入 $A$ 或 $B$，并将 $A$ 或 $B$ 与新加入的矩形取交集。由于保证有解，因此不存在与 $A,B$ 无交的矩形，最后只剩一些与 $A,B$ 都有交的矩形。此时只需任取一个矩形加入 $A,B$ 中任意一个，再不断重复上述过程就可以了，证明还是考虑用上述结论反证，但较为繁琐，故略去不写。

但是该做法由于过度依赖分类讨论，因此很难扩展到 $K=3,4$，为了解决 $K=3,4$ 的情况，需要注意到题目中的一个性质。

考虑最左的右边界，如果我们选的最左边的点在该右边界的左边，则将其横坐标调整到该右边界上来依然满足题意；如果我们选的最左边的点在该右边界的右边，则该右边界对应的矩形中不存在点，不符合题意。因此，存在一种合法方案使得最左边的右边界上一定有点。

同理，最右边的左边界、最上边的下边界、最下边的上边界上也都一定有点，由于 $K=3$ 而我们要覆盖四个边界，由抽屉原理知四个边界的四个交点中至少有一个交点是要被选入答案的。

因此，枚举选哪个交点，之后就转成了 $K=2$ 的问题。

对于 $K=4$，我们先运行一次上述做法，但是还有一种情况，四个边界上各有一个点且都不在角上。此时，若一个矩形与至少三条边界相交，则该矩形一定包含至少一条完整的边界，内部一定有点，可以不用考虑。若只与一条边界相交，则更新这条边界上可取点的范围。否则，与恰好两条边界相交，且在这两条边界上的交集中至少要有一条上有点。

考虑 2-SAT 建图，每个矩形建 $4$ 个点 $x,x',y,y'$ 分别表示选交的第一条边界，不选交的第一条边界，选交的第二条边界，不选交的第二条边界，首先连边 $x'\to y,y'\to x$ 表示两条边界至少要选一条与矩形有交。接着，若两个矩形 $A,B$ 满足 $A$ 的上边界比 $B$ 的下边界还靠下，则连边 $x_B\to x_A'$，$x_A\to x_B'$ 表示 $A,B$ 不可能选在同一条边界上（因为一条边界上只有一个点，而 $A,B$ 与这条边界的交的交为空）。

对于第二类边，上下左右同理都要做一遍，连边需要按对应坐标排序后双指针来前后缀优化建图，这样子总点数和总边数便都缩小到了 $O(n)$ 级别。

总时间复杂度为 $O\left(n(B+\log n)\right)$，其中 $B=4$。由于我比较菜~~懒~~，因此我写了 $O\left(n(4^K+\log n)\right)$ 的做法。

## Code

```cpp
#include<bits/stdc++.h>
#define inf 1000000000
using namespace std;
int n,n2,k,tot,edge_t=0,L,D,R,U,las,t,dfn_t=0,rt_t=0,st_t=0,L1,D1,R1,U1;
int u[200002],one[16],la[2400002],id[200002],id2[200002],dfn[2400002],low[2400002],rt[2400002],st[2400002],to[200002],to1[200002];
typedef pair<int,int> P;
vector<P> vec;
struct aaa
{
	int l,d,r,u;
}p[200002];
struct bbb
{
	int to,nx;
}edge[5400002];
inline bool cmpl(int x,int y)
{
	return p[x].l<p[y].l;
}
inline bool cmpd(int x,int y)
{
	return p[x].d<p[y].d;
}
inline bool cmpr(int x,int y)
{
	return p[x].r<p[y].r;
}
inline bool cmpu(int x,int y)
{
	return p[x].u<p[y].u;
}
inline void add_edge(int x,int y)
{
	edge[++edge_t]=(bbb){y,la[x]},la[x]=edge_t;
}
inline void ins(int x,int y,int z)
{
	vec.push_back(P(x,y));
	for(int i=1;i<=n;++i)if(!u[i] && p[i].l<=x && p[i].d<=y && x<=p[i].r && y<=p[i].u)u[i]=z,--tot;
}
inline void clear(int x)
{
	vec.pop_back();
	for(int i=1;i<=n;++i)if(u[i]==x)u[i]=0,++tot;
}
inline bool dfs(int x)
{
	if(!tot)return 1;
	if(x>k)return 0;
	int L=1,D=1,R=inf,U=inf;
	for(int i=1;i<=n;++i)if(!u[i])L=max(L,p[i].l),D=max(D,p[i].d),R=min(R,p[i].r),U=min(U,p[i].u);
	if(x+1==k)
	{
		ins(L,D,x),ins(R,U,x+1);
		if(!tot)return 1;
		clear(x),clear(x+1);
		ins(R,D,x),ins(L,U,x+1);
		if(!tot)return 1;
		clear(x),clear(x+1);
		return 0;
	}
	ins(L,D,x);
	if(dfs(x+1))return 1;
	clear(x),ins(L,U,x);
	if(dfs(x+1))return 1;
	clear(x),ins(R,D,x);
	if(dfs(x+1))return 1;
	clear(x),ins(R,U,x);
	if(dfs(x+1))return 1;
	clear(x);
	return 0;
}
inline bool get(int x,int y)
{
	return u[x]&((1<<y)-1);
}
inline void Tarjan(int x)
{
	dfn[x]=low[x]=(++dfn_t),st[++st_t]=x;
	for(int i=la[x],v;i;i=edge[i].nx)
	{
		v=edge[i].to;
		if(!dfn[v])Tarjan(v),low[x]=min(low[x],low[v]);
		else if(!rt[v])low[x]=min(low[x],dfn[v]);
	}
	if(dfn[x]==low[x])
	{
		++rt_t;
		do rt[st[st_t]]=rt_t,--st_t;while(st[st_t+1]!=x);
	}
}
int main()
{
	scanf("%d%d",&n,&k),n2=(n<<1),tot=n;
	for(int i=1;i<=n;++i)scanf("%d%d%d%d",&p[i].l,&p[i].d,&p[i].r,&p[i].u);
	if(dfs(1))
	{
		for(int i=0;i<vec.size();++i)printf("%d %d\n",vec[i].first,vec[i].second);
		for(int i=vec.size();i<k;++i)puts("1 1");
		return 0;
	}
	L=1,D=1,R=inf,U=inf,tot=(n<<2);
	for(int i=1;i<16;++i)one[i]=one[i>>1]+(i&1);
	for(int i=1;i<=n;++i)L=max(L,p[i].l),D=max(D,p[i].d),R=min(R,p[i].r),U=min(U,p[i].u),id[i]=id2[i]=i;
	L1=R,D1=U,R1=L,U1=D;
	for(int i=1;i<=n;++i)
	{
		u[i]=0;
		if(p[i].l<=R && R<=p[i].r)u[i]|=1;
		if(p[i].l<=L && L<=p[i].r)u[i]|=2;
		if(p[i].d<=U && U<=p[i].u)u[i]|=4;
		if(p[i].d<=D && D<=p[i].u)u[i]|=8;
		if(one[u[i]]>2)continue;
		add_edge(i+n,i+n2),add_edge(i+n2+n,i);
		if(one[u[i]]==1)
		{
			add_edge(i+n2,i);
			if(u[i]==1)U1=min(U1,p[i].u);
			else if(u[i]==2)D1=max(D1,p[i].d);
			else if(u[i]==4)R1=min(R1,p[i].r);
			else L1=max(L1,p[i].l);
		}
	}
	sort(id+1,id+n+1,cmpu),sort(id2+1,id2+n+1,cmpd),las=0,t=1;
	for(int i=1;i<=n;++i)
	{
		to[id[i]]=id[i]+n2*get(id[i],0),to1[id[i]]=0;
		if(one[u[id[i]]]>2 || !(u[id[i]]&1))continue;
		add_edge(to1[id[i]]=(++tot),to[id[i]]+n);
		if(las)add_edge(tot,las);
		las=tot;
	}
	las=0;
	for(int i=1;i<=n;++i)
	{
		if(one[u[id2[i]]]>2 || !(u[id2[i]]&1))continue;
		while(t<=n && p[id[t]].u<p[id2[i]].d)
		{
			if(to1[id[t]])las=id[t];
			++t;
		}
		if(las)add_edge(to[id2[i]],to1[las]);
	}
	las=0,t=1;
	for(int i=1;i<=n;++i)
	{
		to[id[i]]=id[i]+n2*get(id[i],1),to1[id[i]]=0;
		if(one[u[id[i]]]>2 || !(u[id[i]]&2))continue;
		add_edge(to1[id[i]]=(++tot),to[id[i]]+n);
		if(las)add_edge(tot,las);
		las=tot;
	}
	las=0;
	for(int i=1;i<=n;++i)
	{
		if(one[u[id2[i]]]>2 || !(u[id2[i]]&2))continue;
		while(t<=n && p[id[t]].u<p[id2[i]].d)
		{
			if(to1[id[t]])las=id[t];
			++t;
		}
		if(las)add_edge(to[id2[i]],to1[las]);
	}
	for(int i=1;i<=n;++i)swap(id[i],id2[i]);
	las=0,t=n;
	for(int i=n;i;--i)
	{
		to[id[i]]=id[i]+n2*get(id[i],0),to1[id[i]]=0;
		if(one[u[id[i]]]>2 || !(u[id[i]]&1))continue;
		add_edge(to1[id[i]]=(++tot),to[id[i]]+n);
		if(las)add_edge(tot,las);
		las=tot;
	}
	las=0;
	for(int i=n;i;--i)
	{
		if(one[u[id2[i]]]>2 || !(u[id2[i]]&1))continue;
		while(t && p[id[t]].d>p[id2[i]].u)
		{
			if(to1[id[t]])las=id[t];
			--t;
		}
		if(las)add_edge(to[id2[i]],to1[las]);
	}
	las=0,t=n;
	for(int i=n;i;--i)
	{
		to[id[i]]=id[i]+n2*get(id[i],1),to1[id[i]]=0;
		if(one[u[id[i]]]>2 || !(u[id[i]]&2))continue;
		add_edge(to1[id[i]]=(++tot),to[id[i]]+n);
		if(las)add_edge(tot,las);
		las=tot;
	}
	las=0;
	for(int i=n;i;--i)
	{
		if(one[u[id2[i]]]>2 || !(u[id2[i]]&2))continue;
		while(t && p[id[t]].d>p[id2[i]].u)
		{
			if(to1[id[t]])las=id[t];
			--t;
		}
		if(las)add_edge(to[id2[i]],to1[las]);
	}
	sort(id+1,id+n+1,cmpr),sort(id2+1,id2+n+1,cmpl),las=0,t=1;
	for(int i=1;i<=n;++i)
	{
		to[id[i]]=id[i]+n2*get(id[i],2),to1[id[i]]=0;
		if(one[u[id[i]]]>2 || !(u[id[i]]&4))continue;
		add_edge(to1[id[i]]=(++tot),to[id[i]]+n);
		if(las)add_edge(tot,las);
		las=tot;
	}
	las=0;
	for(int i=1;i<=n;++i)
	{
		if(one[u[id2[i]]]>2 || !(u[id2[i]]&4))continue;
		while(t<=n && p[id[t]].r<p[id2[i]].l)
		{
			if(to1[id[t]])las=id[t];
			++t;
		}
		if(las)add_edge(to[id2[i]],to1[las]);
	}
	las=0,t=1;
	for(int i=1;i<=n;++i)
	{
		to[id[i]]=id[i]+n2*get(id[i],3),to1[id[i]]=0;
		if(one[u[id[i]]]>2 || !(u[id[i]]&8))continue;
		add_edge(to1[id[i]]=(++tot),to[id[i]]+n);
		if(las)add_edge(tot,las);
		las=tot;
	}
	las=0;
	for(int i=1;i<=n;++i)
	{
		if(one[u[id2[i]]]>2 || !(u[id2[i]]&8))continue;
		while(t<=n && p[id[t]].r<p[id2[i]].l)
		{
			if(to1[id[t]])las=id[t];
			++t;
		}
		if(las)add_edge(to[id2[i]],to1[las]);
	}
	for(int i=1;i<=n;++i)swap(id[i],id2[i]);
	las=0,t=n;
	for(int i=n;i;--i)
	{
		to[id[i]]=id[i]+n2*get(id[i],2),to1[id[i]]=0;
		if(one[u[id[i]]]>2 || !(u[id[i]]&4))continue;
		add_edge(to1[id[i]]=(++tot),to[id[i]]+n);
		if(las)add_edge(tot,las);
		las=tot;
	}
	las=0;
	for(int i=n;i;--i)
	{
		if(one[u[id2[i]]]>2 || !(u[id2[i]]&4))continue;
		while(t && p[id[t]].l>p[id2[i]].r)
		{
			if(to1[id[t]])las=id[t];
			--t;
		}
		if(las)add_edge(to[id2[i]],to1[las]);
	}
	las=0,t=n;
	for(int i=n;i;--i)
	{
		to[id[i]]=id[i]+n2*get(id[i],3),to1[id[i]]=0;
		if(one[u[id[i]]]>2 || !(u[id[i]]&8))continue;
		add_edge(to1[id[i]]=(++tot),to[id[i]]+n);
		if(las)add_edge(tot,las);
		las=tot;
	}
	las=0;
	for(int i=n;i;--i)
	{
		if(one[u[id2[i]]]>2 || !(u[id2[i]]&8))continue;
		while(t && p[id[t]].l>p[id2[i]].r)
		{
			if(to1[id[t]])las=id[t];
			--t;
		}
		if(las)add_edge(to[id2[i]],to1[las]);
	}
	for(int i=1;i<=(n2<<1);++i)if(!dfn[i])Tarjan(i);
	for(int i=1;i<=n;++i)
	{
		if(one[u[i]]!=2)continue;
		if(rt[i]<rt[i+n])
		{
			if(u[i]&1)U1=min(U1,p[i].u);
			else if(u[i]&2)D1=max(D1,p[i].d);
			else R1=min(R1,p[i].r);
		}
		else if(rt[i+n2]<rt[i+n2+n])
		{
			if(u[i]&8)L1=max(L1,p[i].l);
			else if(u[i]&4)R1=min(R1,p[i].r);
			else D1=max(D1,p[i].d);
		}
		else return 0&puts("Error");
	}
	return 0&printf("%d %d\n%d %d\n%d %d\n%d %d",R,U1,L,D1,R1,U,L1,D);
}
```


---

## 作者：xzzduang (赞：10)

[传送门](https://loj.ac/p/3272)

## 大意

在二维平面上选择 $K(K\le 4)$ 个点，使得每个给定的矩形内部都至少有一个点。

## 题解

不妨从简单的一维情况开始考虑。

一个显然的贪心策略是每次选最小的右端点，因为如果最左边的点小于最小右端点，把它移到最小右端点肯定不劣。并且我们把策略换成每次选最大左端点也是对的。

拓展的二维的情况，上面的思考启发我们找出所有矩形的最小右边界，最大左边界，最小上边界和最大下边界。首先如果最小右边界大于等于最大左边界，那么肯定存在一条竖线穿过所有矩形，这就退化成了一维的情况，上下边界同理。

所以我们可以只考虑最小右边界小于最大左边界，最小上边界小于最大下边界的情况。以最小右边界为例，发现我们选的最左边的点一定在最小右边界上，其他三个边界同理。所以每个边界上至少有一个点。

这样我们就可以处理 $K\le 3$ 的情况了，因为我们只有不超过 $3$ 个点，却要覆盖四条边界，所以至少有一个交点要选，直接爆搜即可，时间 $\mathcal{O}(4^Kn)$。

对于 $K=4$ 的情况，我们先跑一边上面的爆搜，跑出解就结束了。否则肯定是四条边界上个有一个点，且都不是交点，这也告诉我们不存在一个不与任何一个边界相交的矩形。

于是我们对矩形与交的边界的数量分类讨论：

- 如果与大于等于 $3$ 条边界有交，说明至少完整包含了一条边界，而每条边界上恰好有一个点，所以相当于没有限制。
- 如果与 $1$ 条边界有交，其实就是限制了这条边界上的点要在一个区间内。
- 如果与两个边界有交，我们可以使用 2-sat，对于这个矩形建立两个状态分别表示这个矩形依靠哪个边界上的点消掉。注意到一堆区间交非空当且仅当这些区间两两交非空。所以限制就是对于两个矩形，它们如果它们在一个边界上的区间不相交，那么就不能同时选这个边界。前缀和优化建图即可。

总的时间 $\mathcal{O}(4^Kn+n\log n)$。

```cpp
#include<iostream>
#include<stdio.h>
#include<ctype.h>
#include<vector>
#include<algorithm>
#define ll long long
#define ld long double
#define fi first
#define se second
#define pii pair<int,int>
#define lowbit(x) ((x)&-(x))
#define popcount(x) __builtin_popcount(x)
#define inf 0x3f3f3f3f
#define infll 0x3f3f3f3f3f3f3f3f
#define umap unordered_map
#define all(x) x.begin(),x.end()
#define mk make_pair
#define pb push_back
#define ckmax(x,y) x=max(x,y)
#define ckmin(x,y) x=min(x,y)
#define rep(i,l,r) for(int i=l;i<=r;++i)
#define per(i,r,l) for(int i=r;i>=l;--i)
#define N 200005
using namespace std;
inline int read(){
	int x=0,f=0; char ch=getchar();
	while(!isdigit(ch)) f|=(ch==45),ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f?-x:x;
}
int n,K,L[N],R[N],D[N],U[N],id[5][N];
pii ans[5];
void solve(int p,int sze){
	int a[2]={(int)1e9,0},b[2]={(int)1e9,0};
	for(int i=1;i<=sze;++i){
		int x=id[p][i];
		ckmin(a[0],R[x]),ckmax(a[1],L[x]);
		ckmin(b[0],U[x]),ckmax(b[1],D[x]);
	}
	if(a[0]>=a[1] && b[0]>=b[1]){
		for(int i=1;i<=p;++i) ans[i]={a[1],b[1]};
		for(int i=1;i<=K;++i) printf("%d %d\n",ans[i].fi,ans[i].se);
		exit(0);
	}
	if(p==1) return;
	for(int i=0;i<2;++i){
		for(int j=0;j<2;++j){
			int fick=0;
			for(int t=1;t<=sze;++t){
				int x=id[p][t];
				if(L[x]<=a[i]&&a[i]<=R[x]&&D[x]<=b[j]&&b[j]<=U[x]);
				else id[p-1][++fick]=x;
			}
			ans[p]={a[i],b[j]};
			solve(p-1,fick);
		}
	}
}
int msk[N],rev[2*N];
pii re[4];
struct node{
	int l,r,id;
	bool operator < (const node &A)const{
		if(l==A.l) return r<A.r;
		return l<A.l;
	}
};
vector<node> seg[4];
struct edge{
	int b,n;
}e[20*N];
int h[6*N],tot,pin[N],pout[N],pool,u2[N];
inline void charu(int a,int b){
	e[++tot].b=b,e[tot].n=h[a],h[a]=tot;
}
int dfn[6*N],low[6*N],c[6*N],col,vis[6*N],st[6*N],top;
void tarjan(int u){
	dfn[u]=low[u]=++dfn[0],st[++top]=u;
	for(int i=h[u];i;i=e[i].n){
		int v=e[i].b;
		if(!dfn[v]) tarjan(v),ckmin(low[u],low[v]);
		else if(vis[v]) ckmin(low[u],low[v]);
	}
	if(dfn[u]==low[u]){
		int v;++col;
		do{
			v=st[top--];
			c[v]=col,vis[v]=0;
		}while(u!=v);
	}
}
signed main(){
	n=read(),K=read();
	for(int i=1;i<=n;++i){
		L[i]=read(),D[i]=read(),R[i]=read(),U[i]=read();
		id[K][i]=i;
	}
	solve(K,n);
	int a[2]={(int)1e9,0},b[2]={(int)1e9,0};
	for(int x=1;x<=n;++x){
		ckmin(a[0],R[x]),ckmax(a[1],L[x]);
		ckmin(b[0],U[x]),ckmax(b[1],D[x]);
	}
	re[0]=re[1]={b[0],b[1]};
	re[2]=re[3]={a[0],a[1]};
	for(int i=1;i<=n;++i){
		int cnt=0,s=0;
		if(L[i]<=a[0] && a[0]<=R[i]) cnt++,s|=1;
		if(L[i]<=a[1] && a[1]<=R[i]) cnt++,s|=2;
		if(D[i]<=b[0] && b[0]<=U[i]) cnt++,s|=4;
		if(D[i]<=b[1] && b[1]<=U[i]) cnt++,s|=8;
		if(cnt==1){
			if(L[i]<=a[0] && a[0]<=R[i]){
				ckmax(re[0].fi,D[i]);
				ckmin(re[0].se,U[i]);
			}
			if(L[i]<=a[1] && a[1]<=R[i]){
				ckmax(re[1].fi,D[i]);
				ckmin(re[1].se,U[i]);
			}
			if(D[i]<=b[0] && b[0]<=U[i]){
				ckmax(re[2].fi,L[i]);
				ckmin(re[2].se,R[i]);
			}
			if(D[i]<=b[1] && b[1]<=U[i]){
				ckmax(re[3].fi,L[i]);
				ckmin(re[3].se,R[i]);
			}
		}
	}
	for(int i=1;i<=n;++i){
		int cnt=0,s=0;
		if(L[i]<=a[0] && a[0]<=R[i]) cnt++,s|=1;
		if(L[i]<=a[1] && a[1]<=R[i]) cnt++,s|=2;
		if(D[i]<=b[0] && b[0]<=U[i]) cnt++,s|=4;
		if(D[i]<=b[1] && b[1]<=U[i]) cnt++,s|=8;
		msk[i]=s;
		if(cnt==2){
			u2[i]=1;
			rev[i]=i+n;
			rev[i+n]=i;
			ckmax(L[i],a[0]);
			ckmin(R[i],a[1]);
			ckmax(D[i],b[0]);
			ckmin(U[i],b[1]);
			int I;
			if(L[i]<=a[0] && a[0]<=R[i]){
				I=i;
				if(U[i]<re[0].fi || re[0].se<D[i]) charu(I,rev[I]);
				seg[0].pb({D[i],U[i],I});
			}
			if(L[i]<=a[1] && a[1]<=R[i]){
				if(2<s-2) I=i;
				else I=i+n;
				if(U[i]<re[1].fi || re[1].se<D[i]) charu(I,rev[I]);
				seg[1].pb({D[i],U[i],I});
			}
			if(D[i]<=b[0] && b[0]<=U[i]){
				if(4<s-4) I=i;
				else I=i+n;
				if(R[i]<re[2].fi || re[2].se<L[i]) charu(I,rev[I]);
				seg[2].pb({L[i],R[i],I});
			}
			if(D[i]<=b[1] && b[1]<=U[i]){
				I=i+n;
				if(R[i]<re[3].fi || re[3].se<L[i]) charu(I,rev[I]);
				seg[3].pb({L[i],R[i],I});
			}
		}
	}
	pool=2*n;
	for(int o=0;o<4;++o){
		sort(all(seg[o]));
		int sze=seg[o].size();
		for(int i=0;i<sze;++i) pin[i]=++pool;
		for(int i=0;i<sze;++i) pout[i]=++pool;
		for(int i=0;i+1<sze;++i){
			charu(pin[i],pin[i+1]);
			charu(pin[i],rev[seg[o][i].id]);
		}
		for(int i=0;i+1<sze;++i){
			charu(pout[i+1],pout[i]);
			charu(seg[o][i].id,pout[i]);
		}
		for(node v:seg[o]){
			int pos=upper_bound(all(seg[o]),(node){v.r,(int)1e9,0})-seg[o].begin();
			if(pos>=sze) continue;
			charu(v.id,pin[pos]);
			charu(pout[pos],rev[v.id]);
		}
	}
	for(int i=1;i<=n;++i){
		if(!u2[i]) continue;
		if(!dfn[i]) tarjan(i);
		if(!dfn[i+n]) tarjan(i+n);
	}
	for(int i=2*n+1;i<=pool;++i){
		if(!dfn[i]) tarjan(i);
	}
	for(int i=1;i<=n;++i){
		if(!u2[i]) continue;
		int t=0;
		if(c[i]<c[i+n]) t=__lg(lowbit(msk[i]));
		else t=__lg(msk[i]^lowbit(msk[i]));
		if(t<2) ckmax(re[t].fi,D[i]),ckmin(re[t].se,U[i]);
		if(t>1) ckmax(re[t].fi,L[i]),ckmin(re[t].se,R[i]);
	}
	printf("%d %d\n",a[0],re[0].fi);
	printf("%d %d\n",a[1],re[1].fi);
	printf("%d %d\n",re[2].fi,b[0]);
	printf("%d %d\n",re[3].fi,b[1]);
	return 0;
}
```





---

## 作者：phigy (赞：7)

**注意：此非正解做法，虽然能 AC，但还是推荐使用正解做法。**

---

考虑如何随机化。

如果是直接在 $10^9\times 10^9$ 选取 $K$ 个位置验证，实在是太慢了。

不如反向考虑 $n$ 个汉堡肉每个里都要有个竹签。

一个竹签戳到那些汉堡肉并集一定包含竹签位置。

那么我们就是需要将汉堡肉分成 $K$ 组使得每组并集不空。

此时如果随意分组那还是很慢。

为了让并集尽可能不空，我们可以让每个汉堡肉选取与其并集最大的组加入。

具体的，我们每次先将汉堡肉顺序打乱，将前四个分成四组。

然后对于后面的汉堡肉，让每个汉堡肉选取与其并集最大的组加入。

最后检查每个组并集是否均非空。

于是这样就可以跑过原题数据了。

但是 $\sf loj$ 添加了 $\texttt{hack}$ 数据。 

```cpp
#include <ctime>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>

using namespace std;

int n,k;

struct node
{
	long long x1,y1,x2,y2;
	node operator*(node a)
	{
		node pig;
		pig.x1=max(x1,a.x1);
		pig.y1=max(y1,a.y1);
		pig.x2=min(x2,a.x2);
		pig.y2=min(y2,a.y2);
		return pig;
	}

}a[200005],b[200005];

double S(node a)
{
    if(a.x1>a.x2||a.y1>a.y2)
    {
        return 0;
    }
    return 1.0*(a.y2-a.y1+1)*(a.x2-a.x1+1);
}

double calc(node a,node b)
{
	node pig=a*b;
	return (S(a)-S(pig))/S(a);
}

int main()
{
    int i,j;
	srand(time(NULL));
	cin>>n>>k;
	for(i=1;i<=n;i++)
    {
        cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2;
    }
	while(1)
    {
		int f=1;
		random_shuffle(a+1,a+n+1);
        for(i=1;i<=k;i++)
        {
            b[i]=a[i];
        }
        for(i=k+1;i<=n;i++)
        {
            int id=1;
            double minn=1e9;
            for(j=1;j<=k;j++)
            {
                double now=calc(b[j],a[i]);
                if(now<minn)
                {
                    minn=now;
                    id=j;
                }
            }
            b[id]=b[id]*a[i];
            if(S(b[id])==0)
            {
                f=0;
                break;
            }
        }
		if(f==1)
        {
			for(i=1;i<=k;i++)
            {
                cout<<b[i].x1<<' '<<b[i].y1<<endl;
			}
			return 0;
		}
	}
}

```


---

## 作者：MhxMa (赞：3)

### 题意

给 $n$ 个矩形，在平面上选定 $k$ 个点使每个矩形内至少有一个被选定的点。

### 分析
考虑随机化。随机选择点，检查是否满足条件。枚举每两个矩阵，计算两个矩形的交集，随机选择 $k$ 个矩形作为初始点集。

随机出来的结果可能并没有选到所有的矩阵中，则使用循环来不断尝试不同的点集，直到找到一个满足条件的点集。详细解释见代码中注释。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;

int n, k;

struct node {
	int x1, y1, x2, y2;
} a[N];

node ans[6];

node js(node a, node b) { // 计算交集
	if (max(a.x1, b.x1) > min(a.x2, b.x2) || max(a.y1, b.y1) > min(a.y2, b.y2)) {
		return (node) {
			0, 0, 0, 0 // 两个矩形不相交
		};
	} else {
		return (node) {
			max(a.x1, b.x1), max(a.y1, b.y1), min(a.x2, b.x2), min(a.y2, b.y2)
		};
	}
}

int main() {
	srand(time(NULL));

	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; ++i) {
		scanf("%d%d%d%d", &a[i].x1, &a[i].y1, &a[i].x2, &a[i].y2);
	}

	bool fl = 0; // 本轮计算是否符合题意
	while (1) {
		fl = 0;
		for (int i = 1; i <= k; ++i) {
			ans[i] = a[i];
		}

		for (int i = 1; i <= n; ++i) {
			int tp = 0; // 当前会选择第 tp 个点
			for (int j = 1; j <= k; ++j) { // 选择每两个矩阵，检查是否每个矩形都至少包含一个选定的点。
				if (!(max(a[i].x1, ans[j].x1) > min(a[i].x2, ans[j].x2) || max(a[i].y1, ans[j].y1) > min(a[i].y2, ans[j].y2))) { // 判断矩形 a[i] 是否包含点 ans[j]
					tp = j;
				}
			}
			if (!tp) { // 当前矩形不包含任何选定的点
				swap(a[i], a[rand() % (i - 1) + 1]);
				fl = 1;
				break;
			}
			ans[tp] = js(a[i], ans[tp]);
		}
		
		if (!fl) {
			for (int i = 1; i <= k; ++i) {
				printf("%d %d\n", ans[i].x1, ans[i].y1);
			}
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：7KByte (赞：3)

$K$ 非常小，先找特殊性质。

首先 $K=1$ 的时候直接求交集即可。

对于 $K=2$ ，先考虑固定第一个点。我们令左的右边界为 $x$ ，那么第一个点的横坐标为 $x$ 一定最优。因为如果横坐标 $>x$ ，一定会漏掉某个矩形，如果 $<x$ ，而不存在右端点 $<x$ 的，所以选则 $x$ 一定最优。

同理我们找到最右的左边界，最上的下边界和最下的上边界。那么一定选择这些边界上的点最优。

对于 $K\le 3$ 的情况，我们只有三个点却要覆盖四个边界，那么只能选择边界的交点。而交点只有 $4$ 个，所以我们直接暴搜即可。时间复杂度 $\mathcal{O}(4^KN)$ 。

对于 $K=4$ 还有一种情况是四个边界每个边界上恰好一个点。

那么对于每个矩形。一定与某些边界有交集，且不可能与四个同时

如果至少与四个边界中的三个有交集，那么一定包含一条边界，这类矩形可以忽略。

如果与四个边界中的一个有交集，那么这个边界上的点一定在交集内。

否则会与四个边界中的两个有交集，我们令两个交集为 $[l_1,r_1]$ 和 $[l_2,r_2]$ ，那么两个中至少选择一个，经典 2-SAT 问题，直接建图跑即可。

时间复杂度 $\mathcal{ O}(4^KN+N\log N)$ 。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 200005
#define M 2000005
using namespace std;
const int inf = 0x7fffffff;
int n,k,v[N],idx;
struct node{int l,r,u,d;}a[N];
struct pt{
	int x,y;
	pt(int X=0,int Y=0){x=X,y=Y;}
}sta[5],lim[4];
bool ck(node x,pt y){return x.l<=y.x&&y.x<=x.r&&x.d<=y.y&&y.y<=x.u;}
pt ad(pt x,pt y){return pt(max(x.x,y.x),min(x.y,y.y));}
struct seg{
	int l,r,op;
	seg(int L=0,int R=0,int O=0){l=L,r=R,op=O;}
};
vector<seg>c[4];
int h[M],tot,f[N];
struct edge{int to,nxt;}e[M<<1];
void add(int x,int y){e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;}
int rev(int x){if(x>n*2)return x-n*2;return x+n*2;}
void calc(int l,int r,int d,int u,node x){
	int sum=0;pt p,q;int opx=~0,opy=~0;
	if(x.l<=l&&l<=x.r)q=pt(x.d,x.u),opy=0,swap(p,q),swap(opx,opy),sum++;
	if(x.l<=r&&r<=x.r)q=pt(x.d,x.u),opy=1,swap(p,q),swap(opx,opy),sum++;
	if(x.d<=d&&d<=x.u)q=pt(x.l,x.r),opy=2,swap(p,q),swap(opx,opy),sum++;
	if(x.d<=u&&u<=x.u)q=pt(x.l,x.r),opy=3,swap(p,q),swap(opx,opy),sum++;
	if(sum>=3)return;
	if(sum==1)lim[opx]=ad(lim[opx],p);
	if(sum==2){
		c[opx].push_back(seg(p.x,p.y,++idx));
		c[opy].push_back(seg(q.x,q.y,++idx));
		add(rev(idx-1),idx);add(rev(idx),idx-1);
	}
}
bool cmp1(seg x,seg y){return x.r<y.r;}
bool cmp2(seg x,seg y){return x.l<y.l;}
int dfn[M],st[M],top,cnt,cc,low[M],mat[M],vis[M];
void tar(int x){
	dfn[x]=low[x]=++cc;vis[st[++top]=x]=1;
	for(int i=h[x];i;i=e[i].nxt){
		if(!dfn[e[i].to])tar(e[i].to),low[x]=min(low[x],low[e[i].to]);
		else if(vis[e[i].to])low[x]=min(low[x],dfn[e[i].to]);
	}
	if(dfn[x]==low[x]){
		++cnt;
		while(true){
			int y=st[top--];
			vis[y]=0;mat[y]=cnt;
			if(x==y)return;
		}
	}
}
void solve(){
	int l=~0,r=inf,u=inf,d=~0;
	rep(i,1,n)l=max(l,a[i].l),r=min(r,a[i].r),u=min(u,a[i].u),d=max(d,a[i].d);
	rep(i,0,3)lim[i]=pt(0,inf);rep(i,1,n)calc(r,l,u,d,a[i]);
	idx+=2*n;
	rep(op,0,3){
		sort(c[op].begin(),c[op].end(),cmp1);
		int sz=c[op].size();
		for(int i=0;i<sz;i++){
			if(c[op][i].r<lim[op].x||c[op][i].l>lim[op].y)
				add(c[op][i].op,rev(c[op][i].op));
			f[i]=++idx;add(f[i],rev(c[op][i].op));
			if(i>0)add(f[i],f[i-1]);
			int l=0,r=i-1,ed=~0;
			while(l<=r){
				int mid=(l+r)>>1;
				if(c[op][mid].r<c[op][i].l)ed=mid,l=mid+1;
				else r=mid-1;
			}
			if(~ed)add(c[op][i].op,f[ed]);
		}
		sort(c[op].begin(),c[op].end(),cmp2);
		for(int i=sz-1;i>=0;i--){
			f[i]=++idx;add(f[i],rev(c[op][i].op));
			if(i<sz-1)add(f[i],f[i+1]);
			int l=i+1,r=sz-1,ed=~0;
			while(l<=r){
				int mid=(l+r)>>1;
				if(c[op][mid].l>c[op][i].r)ed=mid,r=mid-1;
				else l=mid+1;
			}
			if(~ed)add(c[op][i].op,f[ed]);
		}
	}
	memset(v,0,sizeof(v));
	rep(i,1,idx)if(!dfn[i])tar(i);
	rep(op,0,3){
		for(int i=0;i<(int)c[op].size();i++){
			int x=c[op][i].op,y=rev(x);
			if(mat[x]<mat[y])lim[op]=ad(lim[op],pt(c[op][i].l,c[op][i].r));
		}
	}
	printf("%d %d\n",r,lim[0].x);
	printf("%d %d\n",l,lim[1].x);
	printf("%d %d\n",lim[2].x,u);
	printf("%d %d\n",lim[3].x,d);
}
bool dfs(int x){
	vector<int>is;
	int l=~0,r=inf,u=inf,d=~0;
	rep(i,1,n)if(!v[i])
		l=max(l,a[i].l),r=min(r,a[i].r),u=min(u,a[i].u),d=max(d,a[i].d);
	if(-1==l){
		if(x==k+1){
			rep(i,1,k)printf("%d %d\n",sta[i].x,sta[i].y);
			return true;
		}
		sta[x]=pt(0,0);
	}
	if(x>k)return false;
	// type = 1  (l,u)
	pt cur=pt(l,u);sta[x]=cur;
	rep(i,1,n)if(!v[i]&&ck(a[i],cur))is.push_back(i),v[i]=1;
	if(dfs(x+1))return true;
	for(int i=0;i<(int)is.size();i++)v[is[i]]=0;is.clear();
	// type = 2  (l,d)
	cur=pt(l,d);sta[x]=cur;
	rep(i,1,n)if(!v[i]&&ck(a[i],cur))is.push_back(i),v[i]=1;
	if(dfs(x+1))return true;
	for(int i=0;i<(int)is.size();i++)v[is[i]]=0;is.clear();
	// type = 3  (r,u)
	cur=pt(r,u);sta[x]=cur;
	rep(i,1,n)if(!v[i]&&ck(a[i],cur))is.push_back(i),v[i]=1;
	if(dfs(x+1))return true;
	for(int i=0;i<(int)is.size();i++)v[is[i]]=0;is.clear();
	// type = 4  (r,d)
	cur=pt(r,d);sta[x]=cur;
	rep(i,1,n)if(!v[i]&&ck(a[i],cur))is.push_back(i),v[i]=1;
	if(dfs(x+1))return true;
	for(int i=0;i<(int)is.size();i++)v[is[i]]=0;is.clear();
	return false;
}
int main(){
	//freopen("08-14.in","r",stdin);
	freopen("INPUT","r",stdin);
	scanf("%d%d",&n,&k);
	rep(i,1,n)scanf("%d%d%d%d",&a[i].l,&a[i].d,&a[i].r,&a[i].u);
	if(!dfs(1))solve();
	return 0;
}
```

---

## 作者：Acoipp (赞：3)

一道很不错的思维题和大模拟。

我们首先分类讨论一下 $K$ 的取值：

## $K=1$

如果 $K=1$，代表只能选一个格子，很显然的取所有矩形的交集就可以了。

判断交集可以按 $x,y$ 轴分开判断，这样会比较方便。

## $K=2$

$K=2$ 的时候需要我们发现一些性质，如果设 $l$ 表示所有矩形下边界（$L_i$）的最小值，那么一定有一个选择的点的坐标在 $l$ 这条直线上。

证明很简单：如果在 $l$ 下方，那么就无法覆盖下边界为 $l$ 的矩形；如果在 $l$ 上方，移动到 $l$ 这条直线也不会影响答案。

然后对于下边界的最小值、上边界的最大值、左边界最靠右的值和右边界最靠左的值都可以这样子计算。

而且这四个边界有 $4$ 个交点（有些交点会重合，但是没关系），我们必须选择两个满足四条边界上都至少有一个点，故搜索即可。

搜索的步骤：

> 当前四个交点里选择一个，删除包含这个交点的矩形。  

> 剩下的矩形中继续 $O(n)$ 找到这四个交点，递归 $K$ 层即可。

时间复杂度为 $O(4^KN)$。

## $K=3$

一样的处理方式，因为四条边选 $3$ 个点覆盖，至少选一个交点，故枚举一个之后，变为四条边选 $2$ 个点覆盖，然后按照上面的过程 DFS 实现即可，时间复杂度同上。

## $K=4$

首先还是可以搜索找到答案，但是我们发现这种情况可能会出现四条边边上选点的情况（一个交点都不选）。

这种的话我们需要对每个矩形分开考虑：

（以下的“边”均为四个交点围成的矩形的边，不是之前描述的“直线”）

> 如果某个矩形包含了其中的某一条边，那么事实上这个矩形可以不用考虑，因为边上至少有一点。

> 如果某个矩形不包含其中任意一条边，那么它一定与 $1 \sim 2$ 条边有交，而且不会与任何一条边都没有交点（题目保证有解）。

> 如果某个矩形只与 $1$ 条边有交，那么这条边上的点只能选交叉的那部分。

> 如果某个矩形与 $2$ 条边有交，那么把这个矩形存下来跑 2-SAT 即可。

这里说一下跑 2-SAT 的过程：

（以下所说矩形均为与 $2$ 条边有交的矩形）

> 对于每条边来说，如果某个矩形与这条边的交集和这条边必选的线段的交集为空，则不能选这条边。

> 否则如果存在另外一个矩形与这条边的交集和这个矩形与这条边的交集的交集为空，则这两个矩形不能同时选这条边。

最后把矩形与这条边的交拿出来，视作在线段上做 2-SAT 即可，可以用前后缀建图优化。

## 代码

想好之后就是一道大模拟了，特别锻炼码力（当然用随机化水过去的就算了），是一道不错的思维+实现的好题！

有点长，但是大部分都是复制粘贴，算下来手写的应该有 $4 \sim 5$ 个 kb。

```cpp\
#include<bits/stdc++.h>
#define ll int
#define N 5000005
using namespace std;
struct node{ll x,y;}p[N];
struct wolve{ll l,r,id,idd;}downw[N],upw[N],lefw[N],rihw[N];
bool cmp(wolve a,wolve b){return a.r<b.r;}
ll n,k,i,l[N],d[N],r[N],u[N],q1[N],q2[N],p1,p2,up,down,lef,rih,vis[N],la[N],ne[N],to[N],et;
ll px[N],py[N];
ll dfn[N],top,sta[N],scc,col[N],low[N],ini[N],tot,w1,w2,w3,w4,id_tot,f1[N],f2[N],qzh[N],id_qzh[N],id_qzh2[N];
ll down_cz[N],up_cz[N],lef_cz[N],rih_cz[N];
inline void merge(ll x,ll y){
	et++;
	ne[et] = la[x],la[x] = et,to[et] = y;
}
void tarjan(ll x){
	dfn[x] = low[x] = ++tot;
	ini[x] = 1;
	sta[++top] = x;
	for(ll i=la[x];i;i=ne[i]){
		if(!dfn[to[i]]){
			tarjan(to[i]);
			low[x] = min(low[x],low[to[i]]);
		}
		else if(ini[to[i]]) low[x] = min(low[x],dfn[to[i]]);
	}
	if(dfn[x]==low[x]){
		scc++;
		while(sta[top+1]!=x){
			col[sta[top]] = scc;
			ini[sta[top]] = 0;
			top--;
		}
	}
}
void dfs(ll x,ll down,ll up,ll lef,ll rih){
	if(x>k){
		for(ll i=1;i<=n;i++) if(!vis[i]) return ;
		for(ll i=1;i<=k;i++) cout<<q1[px[i]]<<" "<<q2[py[i]]<<endl;
		exit(0);
	}
	ll down1,up1,lef1,rih1;
	stack<ll> op;
	while(op.size()) op.pop();
	down1 = INT_MIN,up1 = INT_MAX,lef1 = INT_MIN,rih1 = INT_MAX;
	//---
	down1 = INT_MIN,up1 = INT_MAX,lef1 = INT_MIN,rih1 = INT_MAX;
	px[x] = lef,py[x] = down;
	for(ll i=1;i<=n;i++) if(!vis[i]&&l[i]<=lef&&lef<=r[i]&&d[i]<=down&&down<=u[i]) vis[i]=1,op.push(i);
	for(ll i=1;i<=n;i++) if(!vis[i]) down1 = max(down1,d[i]),up1 = min(up1,u[i]),lef1 = max(lef1,l[i]),rih1 = min(rih1,r[i]);
	dfs(x+1,down1,up1,lef1,rih1);
	while(op.size()) vis[op.top()]=0,op.pop();
	//---
	down1 = INT_MIN,up1 = INT_MAX,lef1 = INT_MIN,rih1 = INT_MAX;
	px[x] = rih,py[x] = down;
	for(ll i=1;i<=n;i++) if(!vis[i]&&l[i]<=rih&&rih<=r[i]&&d[i]<=down&&down<=u[i]) vis[i]=1,op.push(i);
	for(ll i=1;i<=n;i++) if(!vis[i]) down1 = max(down1,d[i]),up1 = min(up1,u[i]),lef1 = max(lef1,l[i]),rih1 = min(rih1,r[i]);
	dfs(x+1,down1,up1,lef1,rih1);
	while(op.size()) vis[op.top()]=0,op.pop();
	//---
	down1 = INT_MIN,up1 = INT_MAX,lef1 = INT_MIN,rih1 = INT_MAX;
	px[x] = lef,py[x] = up;
	for(ll i=1;i<=n;i++) if(!vis[i]&&l[i]<=lef&&lef<=r[i]&&d[i]<=up&&up<=u[i]) vis[i]=1,op.push(i);
	for(ll i=1;i<=n;i++) if(!vis[i]) down1 = max(down1,d[i]),up1 = min(up1,u[i]),lef1 = max(lef1,l[i]),rih1 = min(rih1,r[i]);
	dfs(x+1,down1,up1,lef1,rih1);
	while(op.size()) vis[op.top()]=0,op.pop();
	//---
	down1 = INT_MIN,up1 = INT_MAX,lef1 = INT_MIN,rih1 = INT_MAX;
	px[x] = rih,py[x] = up;
	for(ll i=1;i<=n;i++) if(!vis[i]&&l[i]<=rih&&rih<=r[i]&&d[i]<=up&&up<=u[i]) vis[i]=1,op.push(i);
	for(ll i=1;i<=n;i++) if(!vis[i]) down1 = max(down1,d[i]),up1 = min(up1,u[i]),lef1 = max(lef1,l[i]),rih1 = min(rih1,r[i]);
	dfs(x+1,down1,up1,lef1,rih1);
	while(op.size()) vis[op.top()]=0,op.pop();
}
int main(){
	ios::sync_with_stdio(false);
	down = INT_MIN,up = INT_MAX,lef = INT_MIN,rih = INT_MAX;
	cin>>n>>k;
	for(i=1;i<=n;i++){
		cin>>l[i]>>d[i]>>r[i]>>u[i];
		q1[++p1] = l[i],q1[++p1] = r[i],q2[++p2] = d[i],q2[++p2] = u[i];
	}
	sort(q1+1,q1+p1+1),p1=unique(q1+1,q1+p1+1)-q1-1,sort(q2+1,q2+p2+1),p2=unique(q2+1,q2+p2+1)-q2-1;
	for(i=1;i<=n;i++){
		l[i] = lower_bound(q1+1,q1+p1+1,l[i])-q1;
		r[i] = lower_bound(q1+1,q1+p1+1,r[i])-q1;
		d[i] = lower_bound(q2+1,q2+p2+1,d[i])-q2;
		u[i] = lower_bound(q2+1,q2+p2+1,u[i])-q2;
		down = max(down,d[i]),up = min(up,u[i]),lef = max(lef,l[i]),rih = min(rih,r[i]);
		//1601 1440 3025 2756
	}
	if(down>up) swap(down,up);
	if(lef>rih) swap(lef,rih);
	//1403 2862 1534 2818
	dfs(1,down,up,lef,rih);
	//--------------------------------------------
	upw[0].l = lef,upw[0].r = rih,downw[0].l = lef,downw[0].r = rih,lefw[0].l = down,lefw[0].r = up,rihw[0].l = down,rihw[0].r = up;
	for(i=1;i<=n;i++){
		ll cnt = 0;
		if(l[i]<=lef&&lef<=r[i]) cnt++;
		if(l[i]<=rih&&rih<=r[i]) cnt++;
		if(d[i]<=down&&down<=u[i]) cnt++;
		if(d[i]<=up&&up<=u[i]) cnt++;
		if(cnt==1){
			if(l[i]<=lef&&lef<=r[i]){
				lefw[0].l = max(lefw[0].l,d[i]);
				lefw[0].r = min(lefw[0].r,u[i]);
			}
			if(l[i]<=rih&&rih<=r[i]){
				rihw[0].l = max(rihw[0].l,d[i]);
				rihw[0].r = min(rihw[0].r,u[i]);
			}
			if(d[i]<=down&&down<=u[i]){
				downw[0].l = max(downw[0].l,l[i]);
				downw[0].r = min(downw[0].r,r[i]);
			}
			if(d[i]<=up&&up<=u[i]){
				upw[0].l = max(upw[0].l,l[i]);
				upw[0].r = min(upw[0].r,r[i]);
			}
		}
		if(cnt==2){
			id_tot++,f1[i] = id_tot,id_tot++,f2[i] = id_tot;
			if(lef<l[i]&&r[i]<rih){
				downw[++w1] = (wolve){l[i],r[i],f1[i],f2[i]};
				upw[++w2] = (wolve){l[i],r[i],f2[i],f1[i]};
			}
			else if(down<d[i]&&u[i]<up){
				lefw[++w3] = (wolve){d[i],u[i],f1[i],f2[i]};
				rihw[++w4] = (wolve){d[i],u[i],f2[i],f1[i]};
			}
			else{
				if(l[i]<=lef&&lef<=r[i]){
					if(d[i]<=down&&down<=u[i]){
						downw[++w1] = (wolve){lef,r[i],f1[i],f2[i]};
						lefw[++w3] = (wolve){down,u[i],f2[i],f1[i]};
					}
					else{
						upw[++w2] = (wolve){lef,r[i],f1[i],f2[i]};
						lefw[++w3] = (wolve){d[i],up,f2[i],f1[i]};
					}
				}
				else{
					if(d[i]<=down&&down<=u[i]){
						downw[++w1] = (wolve){l[i],rih,f1[i],f2[i]};
						rihw[++w4] = (wolve){down,u[i],f2[i],f1[i]};
					}
					else{
						upw[++w2] = (wolve){l[i],rih,f1[i],f2[i]};
						rihw[++w4] = (wolve){d[i],up,f2[i],f1[i]};
					}
				}
			}
		}
	}
	sort(downw+1,downw+w1+1,cmp);
	sort(upw+1,upw+w2+1,cmp);
	sort(lefw+1,lefw+w3+1,cmp);
	sort(rihw+1,rihw+w4+1,cmp);
	for(i=1;i<=w1;i++) qzh[i] = downw[i].r,id_qzh[i] = ++id_tot,id_qzh2[i] = ++id_tot,merge(id_qzh[i],downw[i].idd),merge(downw[i].id,id_qzh2[i]);
	for(i=2;i<=w1;i++) merge(id_qzh[i],id_qzh[i-1]),merge(id_qzh2[i-1],id_qzh2[i]);
	for(i=1;i<=w1;i++){
		if(downw[i].l>downw[0].r||downw[i].r<downw[0].l) merge(downw[i].id,downw[i].idd);
		else{
			ll temp = lower_bound(qzh+1,qzh+w1+1,downw[i].l)-qzh-1;
			if(temp!=0) merge(downw[i].id,id_qzh[temp]),merge(id_qzh2[temp],downw[i].idd);
		}
	}
	for(i=1;i<=w2;i++) qzh[i] = upw[i].r,id_qzh[i] = ++id_tot,id_qzh2[i] = ++id_tot,merge(id_qzh[i],upw[i].idd),merge(upw[i].id,id_qzh2[i]);
	for(i=2;i<=w2;i++) merge(id_qzh[i],id_qzh[i-1]),merge(id_qzh2[i-1],id_qzh2[i]);
	for(i=1;i<=w2;i++){
		if(upw[i].l>upw[0].r||upw[i].r<upw[0].l) merge(upw[i].id,upw[i].idd);
		else{
			ll temp = lower_bound(qzh+1,qzh+w2+1,upw[i].l)-qzh-1;
			if(temp!=0) merge(upw[i].id,id_qzh[temp]),merge(id_qzh2[temp],upw[i].idd);
		}
	}
	for(i=1;i<=w3;i++) qzh[i] = lefw[i].r,id_qzh[i] = ++id_tot,id_qzh2[i] = ++id_tot,merge(id_qzh[i],lefw[i].idd),merge(lefw[i].id,id_qzh2[i]);
	for(i=2;i<=w3;i++) merge(id_qzh[i],id_qzh[i-1]),merge(id_qzh2[i-1],id_qzh2[i]);
	for(i=1;i<=w3;i++){
		if(lefw[i].l>lefw[0].r||lefw[i].r<lefw[0].l) merge(lefw[i].id,lefw[i].idd);
		else{
			ll temp = lower_bound(qzh+1,qzh+w3+1,lefw[i].l)-qzh-1;
			if(temp!=0) merge(lefw[i].id,id_qzh[temp]),merge(id_qzh2[temp],lefw[i].idd);
		}
	}
	for(i=1;i<=w4;i++) qzh[i] = rihw[i].r,id_qzh[i] = ++id_tot,id_qzh2[i] = ++id_tot,merge(id_qzh[i],rihw[i].idd),merge(rihw[i].id,id_qzh2[i]);
	for(i=2;i<=w4;i++) merge(id_qzh[i],id_qzh[i-1]),merge(id_qzh2[i-1],id_qzh2[i]);
	for(i=1;i<=w4;i++){
		if(rihw[i].l>rihw[0].r||rihw[i].r<rihw[0].l) merge(rihw[i].id,rihw[i].idd);
		else{
			ll temp = lower_bound(qzh+1,qzh+w4+1,rihw[i].l)-qzh-1;
			if(temp!=0) merge(rihw[i].id,id_qzh[temp]),merge(id_qzh2[temp],rihw[i].idd);
		}
	}
	for(i=1;i<=id_tot;i++) if(!dfn[i]) tarjan(i);
	for(i=1;i<=n;i++){
		ll cnt = 0;
		if(l[i]<=lef&&lef<=r[i]) cnt++;
		if(l[i]<=rih&&rih<=r[i]) cnt++;
		if(d[i]<=down&&down<=u[i]) cnt++;
		if(d[i]<=up&&up<=u[i]) cnt++;
		if(cnt==1){
			if(l[i]<=lef&&lef<=r[i]) lef_cz[d[i]]++,lef_cz[u[i]+1]--;
			if(l[i]<=rih&&rih<=r[i]) rih_cz[d[i]]++,rih_cz[u[i]+1]--;
			if(d[i]<=down&&down<=u[i]) down_cz[l[i]]++,down_cz[r[i]+1]--; 
			if(d[i]<=up&&up<=u[i]) up_cz[l[i]]++,up_cz[r[i]+1]--; 
		}
		if(f1[i]){
			if(col[f1[i]]<col[f2[i]]){
				if(lef<l[i]&&r[i]<rih) down_cz[l[i]]++,down_cz[r[i]+1]--;
				else if(down<d[i]&&u[i]<up) lef_cz[d[i]]++,lef_cz[u[i]+1]--;
				else{
					if(l[i]<=lef&&lef<=r[i]){
						if(d[i]<=down&&down<=u[i]) down_cz[lef]++,down_cz[r[i]+1]--;
						else up_cz[lef]++,up_cz[r[i]+1]--;
					}
					else{
						if(d[i]<=down&&down<=u[i]) down_cz[l[i]]++,down_cz[rih+1]--;
						else up_cz[l[i]]++,up_cz[rih+1]--;
					}
				}
			}
			else{
				if(lef<l[i]&&r[i]<rih) up_cz[l[i]]++,up_cz[r[i]+1]--;
				else if(down<d[i]&&u[i]<up) rih_cz[d[i]]++,rih_cz[u[i]+1]--;
				else{
					if(l[i]<=lef&&lef<=r[i]){
						if(d[i]<=down&&down<=u[i]) lef_cz[down]++,lef_cz[u[i]+1]--;
						else lef_cz[d[i]]++,lef_cz[up+1]--;
					}
					else{
						if(d[i]<=down&&down<=u[i]) rih_cz[down]++,rih_cz[u[i]+1]--;
						else rih_cz[d[i]]++,rih_cz[up+1]--;
					}
				}
			}
		}
	}
	ll ans1,ans2;
	ans1 = 1,ans2 = -1;
	for(ll i=1;i<=p2;i++){
		lef_cz[i]+=lef_cz[i-1];
		if(lef_cz[i]>ans2) ans2=lef_cz[i],ans1=i;
	}
	cout<<q1[lef]<<" "<<q2[ans1]<<endl;
	ans1 = 1,ans2 = -1;
	for(ll i=1;i<=p2;i++){
		rih_cz[i]+=rih_cz[i-1];
		if(rih_cz[i]>ans2) ans2=rih_cz[i],ans1=i;
	}
	cout<<q1[rih]<<" "<<q2[ans1]<<endl;
	ans1 = 1,ans2 = -1;
	for(ll i=1;i<=p1;i++){
		down_cz[i]+=down_cz[i-1];
		if(down_cz[i]>ans2) ans2=down_cz[i],ans1=i;
	}
	cout<<q1[ans1]<<" "<<q2[down]<<endl;
	ans1 = 1,ans2 = -1;
	for(ll i=1;i<=p1;i++){
		up_cz[i]+=up_cz[i-1];
		if(up_cz[i]>ans2) ans2=up_cz[i],ans1=i;
	}
	cout<<q1[ans1]<<" "<<q2[up]<<endl;
	return 0;
}
/*
360403472 500715003
729084344 710133109
387411075 387296311
457131722 710133109
*/
```

---

## 作者：DaiRuiChen007 (赞：2)

# P7216 题解

[Problem Link](https://www.luogu.com.cn/problem/P7216)

**题目大意**

> 给 $n$ 个矩形，在平面上选定 $k$ 个点使每个矩形内至少有一个被选定的点。
>
> 数据范围：$n\le 5\times 10^5$，$k\le 4$，保证有解。

**思路分析**

先考虑 $k\le3$ 的情况。

先求出所有矩形的交，如果非空，那么任取一个都可以。

如果一边非空（最大左端点 $\le$ 最小右端点），可以根据调整法证明点一定放在中间，因此可以降成一维的情况，那么一维的情况直接贪心按右端点放就行。

如果两边都为空（最大左端点 $>$ 最小右端点，最大上端点 $>$ 最小下端点），显然每个边界上至少要有一个点，但又由于 $k\le 3$，那么至少要有一个交点上有点，枚举选了哪个端点然后递归处理即可。

$k=4$ 的时候，若依然有点是交点，则也进行刚才同样的爆搜处理。

接下来我们只要处理四个边界上分别恰有一个点的情况，能够证明四个点一定在四条边界构成的矩形上。

对坐标离散化，然后建立 2-SAT 模型，如 $L_i$ 表示左边界上 $i$ 是不是被选的点。

考虑分类讨论每个矩形和几条边界有交：

- 若有 $3$ 或 $4$ 条边界有交，显然至少有一条边界被完全包含，则这个矩形一定满足。
- 若和 $1$ 条边界有交，显然直接更新对应的可能被选区间。
- 若不和区间有交，至少要一个点放在边界矩形内部，那么这种情况一定在刚刚选拐点的过程中处理过。
- 若和 $2$ 条边界有交，那么限制形如 $X_{l_1,r_1}\lor Y_{l_2,r_2}=1$，其中 $X,Y$ 是边界，$[l_1,r_1],[l_2,r_2]$ 表示对应边界上的一个子区间，但限制关系，考虑前缀和优化，注意到 $X_{l,r}=(X_{1,r}\land\lnot X_{1,l-1})$，因此原限制条件可以拆成 $\mathcal O(1)$ 组前缀变量上的限制关系，这样限制关系数就可以接受。

时间复杂度：$\mathcal O(4^kn+n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5,inf=1e9;
struct Rect { int lox,hix,loy,hiy; };
inline Rect merge(Rect a,Rect b) {
	return {max(a.lox,b.lox),min(a.hix,b.hix),max(a.loy,b.loy),min(a.hiy,b.hiy)};
}
typedef array<int,2> Pair;
inline vector<Pair> dfs(const vector<Rect> &now,int k) {
	if(!k) return vector<Pair>(0);
	Rect inter{1,inf,1,inf};
	for(auto re:now) inter=merge(inter,re);
	int L=inter.lox,R=inter.hix,D=inter.loy,U=inter.hiy;
	if(L<=R&&D<=U) return vector<Pair>(k,{L,D});
	if(L<=R) {
		vector <Pair> sec,ans;
		for(auto re:now) sec.push_back({re.loy,re.hiy});
		sort(sec.begin(),sec.end(),[&](auto I,auto J){ return I[1]<J[1]; });
		int lst=0;
		for(auto s:sec) if(lst<s[0]) ans.push_back({L,lst=s[1]});
		if((int)ans.size()>k) ans.clear();
		else while((int)ans.size()<k) ans.push_back({inf,inf});
		return ans;
	}
	if(D<=U) {
		vector <Pair> sec,ans;
		for(auto re:now) sec.push_back({re.lox,re.hix});
		sort(sec.begin(),sec.end(),[&](auto I,auto J){ return I[1]<J[1]; });
		int lst=0;
		for(auto s:sec) if(lst<s[0]) ans.push_back({lst=s[1],U});
		if((int)ans.size()>k) ans.clear();
		else while((int)ans.size()<k) ans.push_back({inf,inf});
		return ans;
	}
	for(int o:{0,1,2,3}) {
		int x=(o&1)?L:R,y=(o&2)?U:D;
		vector <Rect> nxt;
		for(auto Re:now) if(x<Re.lox||x>Re.hix||y<Re.loy||y>Re.hiy) nxt.push_back(Re);
		vector <Pair> ans=dfs(nxt,k-1);
		if(ans.empty()) continue;
		ans.push_back({x,y});
		return ans;
	}
	return vector<Pair>(0);
}
int U[MAXN*2][2],D[MAXN*2][2],L[MAXN*2][2],R[MAXN*2][2];
int vx[MAXN*2],vy[MAXN*2];
vector <int> G[MAXN*16];
inline void link(int u,int v) { G[u].push_back(v); }
int dfn[MAXN*16],low[MAXN*16],dcnt;
int stk[MAXN*16],tp;
bool ins[MAXN*16];
int bel[MAXN*16],scnt;
inline void tarjan(int u) {
	dfn[u]=low[u]=++dcnt;
	ins[stk[++tp]=u]=true;
	for(int v:G[u]) {
		if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);
		else if(ins[v]) low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]) {
		int k; ++scnt;
		do {
			ins[k=stk[tp--]]=false;
			bel[k]=scnt;
		} while(k^u);
	}
}
signed main() {
	int n,k;
	scanf("%d%d",&n,&k);
	vector <Rect> a(n);
	for(int i=0;i<n;++i) scanf("%d%d%d%d",&a[i].lox,&a[i].loy,&a[i].hix,&a[i].hiy);
	auto ans=dfs(a,k);
	if(!ans.empty()) {
		for(auto I:ans) printf("%d %d\n",I[0],I[1]);
		return 0;
	}
	for(auto re:a) {
		vx[++vx[0]]=re.lox,vx[++vx[0]]=re.hix;
		vy[++vy[0]]=re.loy,vy[++vy[0]]=re.hiy;
	}
	sort(vx+1,vx+vx[0]+1),vx[0]=unique(vx+1,vx+vx[0]+1)-vx-1;
	sort(vy+1,vy+vy[0]+1),vy[0]=unique(vy+1,vy+vy[0]+1)-vy-1;
	for(auto &re:a) {
		re.lox=lower_bound(vx+1,vx+vx[0]+1,re.lox)-vx;
		re.hix=lower_bound(vx+1,vx+vx[0]+1,re.hix)-vx;
		re.loy=lower_bound(vy+1,vy+vy[0]+1,re.loy)-vy;
		re.hiy=lower_bound(vy+1,vy+vy[0]+1,re.hiy)-vy;
	}
	Rect inter{1,inf,1,inf};
	for(auto re:a) inter=merge(inter,re);
	int l=inter.hix,r=inter.lox,d=inter.hiy,u=inter.loy;
	int vcnt=0;
	for(int i=l;i<=r;++i) U[i][0]=++vcnt,D[i][0]=++vcnt;
	for(int i=d;i<=u;++i) L[i][0]=++vcnt,R[i][0]=++vcnt;
	for(int i=l;i<=r;++i) U[i][1]=++vcnt,D[i][1]=++vcnt;
	for(int i=d;i<=u;++i) L[i][1]=++vcnt,R[i][1]=++vcnt;
	for(int i=l;i<r;++i) {
		link(U[i][1],U[i+1][1]);
		link(U[i+1][0],U[i][0]);
		link(D[i][1],D[i+1][1]);
		link(D[i+1][0],D[i][0]);
	}
	link(D[r][0],D[r][1]);
	link(U[r][0],U[r][1]);
	for(int i=d;i<u;++i) {
		link(L[i][1],L[i+1][1]);
		link(L[i+1][0],L[i][0]);
		link(R[i][1],R[i+1][1]);
		link(R[i+1][0],R[i][0]);
	}
	link(L[u][0],L[u][1]);
	link(R[u][0],R[u][1]);
	for(auto re:a) {
		int tl,tr,tu,td;
		bool il=(tl=re.lox)<=l,ir=(tr=re.hix)>=r;
		bool id=(td=re.loy)<=d,iu=(tu=re.hiy)>=u;
		int sum=il+ir+id+iu;
		if(sum>=3) continue;
		if(sum==1) {
			if(il) {
				link(L[td-1][1],L[td-1][0]);
				link(L[tu][0],L[tu][1]);
			}
			if(ir) {
				link(R[td-1][1],R[td-1][0]);
				link(R[tu][0],R[tu][1]);
			}
			if(id) {
				link(D[tl-1][1],D[tl-1][0]);
				link(D[tr][0],D[tr][1]);
			}
			if(iu) {
				link(U[tl-1][1],U[tl-1][0]);
				link(U[tr][0],U[tr][1]);
			}
		}
		if(sum==2) {
			if(il&&iu) {
				link(U[tr][0],L[td-1][0]);
				link(L[td-1][1],U[tr][1]);
			}
			if(il&&id) {
				link(L[tu][0],D[tr][1]);
				link(D[tr][0],L[tu][1]);
			}
			if(ir&&iu) {
				link(U[tl-1][1],R[td-1][0]);
				link(R[td-1][1],U[tl-1][0]);
			}
			if(ir&&id) {
				link(R[tu][0],D[tl-1][0]);
				link(D[tl-1][1],R[tu][1]);
			}
			if(il&&ir) {
				link(L[td-1][1],R[td-1][0]);
				link(L[td-1][1],R[tu][1]);
				link(L[tu][0],R[td-1][0]);
				link(L[tu][0],R[tu][1]);
				link(R[td-1][1],L[td-1][0]);
				link(R[td-1][1],L[tu][1]);
				link(R[tu][0],L[td-1][0]);
				link(R[tu][0],L[tu][1]);
			}
			if(id&&iu) {
				link(D[tl-1][1],U[tl-1][0]);
				link(D[tl-1][1],U[tr][1]);
				link(D[tr][0],U[tl-1][0]);
				link(D[tr][0],U[tr][1]);
				link(U[tl-1][1],D[tl-1][0]);
				link(U[tl-1][1],D[tr][1]);
				link(U[tr][0],D[tl-1][0]);
				link(U[tr][0],D[tr][1]);
			}
		}
	}
	for(int i=1;i<=vcnt;++i) if(!dfn[i]) tarjan(i);
	for(int i=d;i<=u;++i) {
		bool lst0=(i==d||bel[L[i-1][0]]<bel[L[i-1][1]]);
		bool now1=bel[L[i][0]]>bel[L[i][1]];
		if(lst0&&now1) printf("%d %d\n",vx[l],vy[i]);
	}
	for(int i=d;i<=u;++i) {
		bool lst0=(i==d||bel[R[i-1][0]]<bel[R[i-1][1]]);
		bool now1=bel[R[i][0]]>bel[R[i][1]];
		if(lst0&&now1) printf("%d %d\n",vx[r],vy[i]);
	}
	for(int i=l;i<=r;++i) {
		bool lst0=(i==l||bel[D[i-1][0]]<bel[D[i-1][1]]);
		bool now1=bel[D[i][0]]>bel[D[i][1]];
		if(lst0&&now1) printf("%d %d\n",vx[i],vy[d]);
	}
	for(int i=l;i<=r;++i) {
		bool lst0=(i==l||bel[U[i-1][0]]<bel[U[i-1][1]]);
		bool now1=bel[U[i][0]]>bel[U[i][1]];
		if(lst0&&now1) printf("%d %d\n",vx[i],vy[u]);
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

### 题解
本题实际上就是将 $n$ 个矩形分出不大于 $k$ 组，使得每一组的矩形两两有交。

首先，有一个显而易见的**错误的**贪心策略：\
维护每一组矩阵的交集。对于第 $i$ 个矩阵（此时前 $i-1$ 个已分组），枚举 $k$ 组，若第 $j$ 组矩阵的交集与第 $i$ 个矩阵有交集，则将第 $i$ 个矩阵加入到第 $j$ 组。

容易发现，矩阵的加入顺序对答案有影响，而我们又不可能枚举全排列。

就能想到随机化。

令 $order_i$ 表示第 $i$ 个进行分组的矩阵。

那么每次循环，都要重新排列 $order$。\
但随机排列一次是 $\mathcal{O}(n\log n)$，显然会 TLE。

因此，考虑用 `swap` 代替 `random_shuffle`。

若第 $i$ 个进行分组的矩阵无法进行合法分组，则让该矩阵优先分组。\
即随机交换 $order_i,order_j,j<i$。

---

## 作者：Unnamed114514 (赞：0)

[镜像题解](https://www.luogu.com.cn/article/9piiqy9x)

给一个构造类随机化的通用流程：

- 判断当前状态在某种策略下是否存在方案。

- 如果存在，直接输出方案；如果不存在，对状态进行微扰再回到第一步。

微扰可以考虑 `random_shuffle`，但是在一般情况下，为了优化掉这个 $O(n)$，我们可以考虑 `swap`。

接下来考虑第一步，因为同一个情况下也可能有多种策略，我们可以考虑通过类似于贪心的思路来 $O(n)$ 判断是否存在方案，而不是暴力搜索。

最初考虑的是从 $1$ 到 $n$ 遍历，如果能放到当前组就放，否则就新建一个组。

但是这样是过不了的，因为每次放的组都是连续的区间，单次微扰并不能改变大致的分组。

此时，我们应该考虑随机分组。

注意到分成 $k$ 组一定不劣，因为如果不分成 $k$ 组把一组拆开显然不会让有解变成无解。

所以我们可以先把 $[1,k]$ 放到这 $k$ 组里面，对于每个 $i\in [k+1,n]$，考虑找到哪些组是可以放的，随机放到一个组里面即可；如果没有，报告无解。

这样做仍然过不了。

发现直接交换之后对无解的位置的微扰还是不够，仍然有可能出现在同样的位置，同样的矩形无解的情况。

考虑把这个位置变成有解，最简单的一种思路就是放到初始的矩阵里面，这样一定能让它自己变得可行。

上述过程都是在扩大单次微扰的效率和影响。

事实证明，上述做法可过。

---

## 作者：Wilderness_ (赞：0)

### 思路
$k$ 的范围不大，先考虑枚举，发现 $n$ 范围较大，不能通过此题。

考虑在此基础上贪心，先选定 $k$ 个矩形，然后对其余矩形和枚举选定的矩形，若与其有相交部分则取相交所得的矩形。然而对于每个剩余矩形，有相交的矩形可能不止一个，而交的顺序不同可能导致最后答案也会不同，所以这个贪心是错误的。对此，所以我们考虑在此基础上进行随机化。

然而，若我们每次都打乱整个序列，仍会出现超时情况。因此我们每找出一个无法与前面所选矩形相交的矩形，就将其同前面的矩形随机交换。至此，便可以通过此题。

### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch))
	{
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(isdigit(ch))
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
inline void write(int x)
{
    if(x<0)
	{
        putchar('-');
        write(-x);
        return;
    }
    if(x>9)write(x/10);
    putchar(x%10+48);
    return;
}
struct zf
{
	int x1,y1,x2,y2;
	friend bool operator!(zf b){return (!b.x1)&&(!b.y1)&&(!b.x2)&&(!b.y2);}
}p[500010],ans[5];
mt19937 dg(time(NULL));
int main()
{
	int n=read(),k=read();
	for(int i=1;i<=n;++i)p[i].x1=read(),p[i].y1=read(),p[i].x2=read(),p[i].y2=read();
	while(true)
	{
		auto U=[](zf a,zf b)
		{
			int lx=max(a.x1,b.x1),rx=min(a.x2,b.x2),dy=max(a.y1,b.y1),uy=min(a.y2,b.y2);
			if(lx>rx||dy>uy)return (zf){0,0,0,0};
			else return (zf){lx,dy,rx,uy};
		};
		bool fg=1;
		for(int i=1;i<=k;++i)ans[i]=p[i];
		for(int i=1;i<=n;++i)
		{
			int tp=0;
			for(int j=1;j<=k;++j)if(!(!U(p[i],ans[j])))tp=j;
			if(!tp)
			{
				fg=0;
				swap(p[i],p[dg()%(i-1)+1]);
				break;
			}
			ans[tp]=U(p[i],ans[tp]);
		}
		if(fg)
		{
			for(int i=1;i<=k;++i)write(ans[i].x1),putchar(' '),write(ans[i].y2),puts("");
			return 0;
		}
	}
    return 0;
}
```

---


# 计树

## 题目描述

求有多少不同的包含 $n$ 个点的有标号无根树，满足：对于任何一个点 $x$，都存在点 $y$ 使得 $x$ 和 $y$ 之间有一条边且 $|x - y| = 1$。答案对 $998244353$ 取模。

## 说明/提示

**【样例解释 #1】**

![无标题.png](https://i.loli.net/2020/12/28/1Cp3jLXaiOWmuPA.png)

样例 #1 中符合题意的 $4$ 种树如上图所示。

----

**【数据范围】**

本题包含 $20$ 个测试点，每个测试点 $5$ 分。

| 测试点编号 | $n$ 的范围  |
| :--------: | :---------: |
|  $1 \sim 2$  |  $\leq 7$   |
|  $3 \sim 4$  |  $\leq 14$  |
|  $5 \sim 8$  |  $\leq 30$  |
|  $9 \sim 12$ | $\leq 10^3$ |
| $13 \sim 20$ | $\leq 10^5$ |

对于所有测试点满足 $n$ 为正整数且 $2 \leq n \leq {10}^5$。

## 样例 #1

### 输入

```
4```

### 输出

```
4```

## 样例 #2

### 输入

```
209```

### 输出

```
21754876```

## 样例 #3

### 输入

```
5```

### 输出

```
11```

## 样例 #4

### 输入

```
6```

### 输出

```
56```

# 题解

## 作者：do_while_true (赞：24)

快进完生成函数，现在我们知道如果令一个长度为 $i$ 的连续段权值为 $in[z^i]\frac{z^2}{1-z+z^2}$，一个连续段权值的 ogf 是 $F$，那么答案的 ogf 就是 $\frac{1}{1-F}$．

先看看 $\frac{z^2}{1-z+z^2}$ 展开，发现形式很好看，就是 $\{0,0,1,1,0,-1,-1,0,1,1,0,-1,-1,\cdots\}$，后面就是 $\{0,1,1,0,-1,-1\}$ 的循环了。也就是只有 $len\bmod 3=0,2$ 的连续段有权值，并且按照 $\lfloor\frac{len}{3}\rfloor$ 的奇偶性分类。这样我们就能通过记录模 $3$ 为 $0,1,2$ 处的位置的一个前缀和状物（每长度为 $3$ 分组，按照奇偶决定对前缀和贡献为正还是负）就能 $\mathcal{O}(n)$ 递推出来了。

这玩意能矩阵快速幂，但是信息数还是太多了，大概还需要一组一组转移。其实递推 $f_i$ 可以直接考虑 $i$ 所在连续段长度，$\leq 6$ 的直接转，$>6$ 的让它从 $(i-6)$ 那个位置续上。由于权值中需要乘个 $len$，所以续上的时候要多记一个 $g$ 表示只有最后一段没有乘 $len$ 的答案是多少。现在就只需要记 $[i-6,i-1]$ 的所有 $f,g$，信息数是 $12$，先把前 $6$ 个位置递推出来，再矩阵快速幂就 $\mathcal{O}(\log n)$ 复杂度了。

实际上递推式还能更短，跑 BM 对着系数找规律应该能找出来，但我懒了（其实就是不会 BM）。

$\mathcal{O}(n)$：

```cpp
const int N=100010;
int n;
int f[N];
int s[3],t[3];
signed main(){
	read(n);
	s[0]=f[0]=1;
	for(int i=1;i<=n;i++){
		int o=i%3;
		for(int j=2;j<=3;j++){
			int p=o-j<0?o-j+3:o-j;
			if(((i/3)&1) ^ (o-j<0)){
				cdel(f[i],1ll*n*del(1ll*s[p]*i%mod,t[p])%mod);
			}
			else{
				cadd(f[i],1ll*n*del(1ll*s[p]*i%mod,t[p])%mod);
			}
		}
		if((i/3)&1){
			cdel(s[i%3],f[i]);
			cdel(t[i%3],1ll*f[i]*i%mod);
		}
		else{
			cadd(s[i%3],f[i]);
			cadd(t[i%3],1ll*f[i]*i%mod);
		}
	}
	cout << 1ll*f[n]*qpow(1ll*n*n%mod,mod-2)%mod << '\n';
	return 0;
}
```

```cpp
const int N=100020;
int n;
int buff[N],bufg[N];
int *f=buff+10,*g=bufg+10;
signed main(){
	read(n);
	f[0]=g[0]=1;
	for(int i=2;i<=n;i++){
		cadd(f[i],f[i-2]*2ll%mod*n%mod);
		cadd(g[i],1ll*f[i-2]*n%mod);
		cadd(f[i],f[i-3]*3ll%mod*n%mod);
		cadd(g[i],1ll*f[i-3]*n%mod);
		cdel(f[i],f[i-5]*5ll%mod*n%mod);
		cdel(g[i],1ll*f[i-5]*n%mod);
		cdel(f[i],f[i-6]*6ll%mod*n%mod);
		cdel(g[i],1ll*f[i-6]*n%mod);
		if(i!=6){
			cadd(f[i],f[i-6]);
			cadd(f[i],g[i-6]*6ll%mod);
			cadd(g[i],g[i-6]);
		}
	}
	cout << 1ll*f[n]*qpow(1ll*n*n%mod,mod-2)%mod << '\n';
	return 0;
}
```

$\mathcal{O}(\log n)$：

```cpp
const int N=100020;
ll n;
int buff[20],bufg[20];
int *f=buff+10,*g=bufg+10;
int a[13][13],b[13][13],c[13][13],ans[13][13];
void mul(int z[13][13],int x[13][13],int y[13][13]){
	memset(c,0,sizeof(c));
	for(int k=1;k<=12;k++)
		for(int j=1;j<=12;j++)
			if(y[k][j]){
				for(int i=1;i<=12;i++)
					if(x[i][k]){
						cadd(c[i][j],1ll*x[i][k]*y[k][j]%mod);
					}
			}
	memcpy(z,c,sizeof(c));
}
signed main(){
	int m=read(n);
	f[0]=g[0]=1;
	for(int i=2;i<=6;i++){
		cadd(f[i],f[i-2]*2ll%mod*n%mod);
		cadd(g[i],1ll*f[i-2]*n%mod);
		cadd(f[i],f[i-3]*3ll%mod*n%mod);
		cadd(g[i],1ll*f[i-3]*n%mod);
		cdel(f[i],f[i-5]*5ll%mod*n%mod);
		cdel(g[i],1ll*f[i-5]*n%mod);
		cdel(f[i],f[i-6]*6ll%mod*n%mod);
		cdel(g[i],1ll*f[i-6]*n%mod);
	}
	if(n<=6){
		cout << 1ll*f[n]*qpow(1ll*n*n%mod,mod-2)%mod << '\n';
		return 0;
	}
	a[2][1]=2ll*n%mod;
	a[2][7]=n%mod;
	a[3][1]=3ll*n%mod;
	a[3][7]=n%mod;
	a[5][1]=del(0,5ll*n%mod);
	a[5][7]=del(0,n%mod);
	a[6][1]=del(1,6ll*n%mod);
	a[6][7]=del(0,n%mod);
	a[12][1]=6;
	a[12][7]=1;
	a[1][2]=1;
	a[2][3]=1;
	a[3][4]=1;
	a[4][5]=1;
	a[5][6]=1;
	a[7][8]=1;
	a[8][9]=1;
	a[9][10]=1;
	a[10][11]=1;
	a[11][12]=1;
	for(int i=1;i<=12;i++)ans[i][i]=1;
	n-=6;
	while(n){
		if(n&1){
			mul(ans,ans,a);
		}
		mul(a,a,a);
		n>>=1;
	}
	int s=0;
	for(int i=1;i<=6;i++)
		cadd(s,1ll*f[7-i]*ans[i][1]%mod);
	for(int i=1;i<=6;i++)
		cadd(s,1ll*g[7-i]*ans[i+6][1]%mod);
	cout << 1ll*s*qpow(1ll*m*m%mod,mod-2)%mod << '\n';
	return 0;
}

```

---

## 作者：qwaszx (赞：11)

最终的树一定是若干条形如 $l,l+1,\cdots,r$ 的极长链拼起来得到的，考虑容斥，一个基本单位是 $\sum_{i\geq 2}x^i=\frac{x^2}{1-x}$，我们容斥掉几个拼起来的情况，也就是

$$
1-\frac{1}{1+\frac{x^2}{1-x}}=\frac{x^2}{1-x+x^2}
$$

现在我们可以忽略极长这个限制，在乘上对应的容斥系数的情况下直接拼接. 根据 prufer 序列的经典结论，一个划分的拼接方案数是

$$
n^{m-2}\prod_{i=1}^mlen_i
$$

给出一个简单的证明: 我们把一个已经连好的连通块看成一个点，然后枚举其在树中的度数，每个度数有 $len_i$ 种连法，那么根据 prufer 编码就有

$$
\begin{aligned}
&\sum_{\sum (deg_i-1)=m-2}\frac{(m-2)!}{\prod(deg_i-1)!}\prod len_i^{deg_i}\\
=&\left(\prod len_i\right)\left((m-2)![x^{m-2}]\prod e^{len_ix}\right)\\
=&n^{m-2}\prod_{i=1}^mlen_i
\end{aligned}
$$

我们把 $n^{-2}$ 提到外面来，那么现在长为 $len$ 的一段的贡献系数就是 $f_{len}=\left([x^{len}]\frac{x^2}{1-x+x^2}\right)len\cdot n$

最终的答案就是

$$
[x^n]\frac{1}{1-\sum_{i\geq 2}f_ix^i}
$$

可以多项式求逆做到 $n\log n$，不过事实上这是一个线性递推，证明如下:

考察 $\frac{x^2}{1-x+x^2}$，提出一个 $x$ 之后它是线性递推的，而我们恰好不需要前两项系数. 于是我们知道 $[x^n]\frac{x^2}{1-x+x^2}$ 在 $n\geq 2$ 的时候具有 $\alpha r_1^n+\beta r_2^n$ 的形式.

再考虑点乘上 $i\cdot n$ 之后的结果，那就是

$$
n\sum_{i\geq 2}i(\alpha r_1^i+\beta r_2^i)x^i
$$

这必然可以被写成 $\frac{P(x)}{Q(x)}$ 的形式，$\frac{1}{1-F}$ 亦然. 将分子对分母取模就得到一个线性递推加常多项式的形式（不过在这题里最终分子次数是小于分母的）. 我们用次数高于常多项式次数的部分做线性递推即可. 使用 BM 算法求出递推式，最终复杂度 $\Theta(\log n)$

延伸阅读（雾）：https://blog.csdn.net/ei_captain/article/details/104288107


---

## 作者：An_Account (赞：9)

对于一条边，如果它连接的两个端点的编号之差的绝对值不超过$1$，我们称这两个端点“连通”。

通过观察不难发现，最终我们得到的每个连通块都是一条长度不小于$2$的链，并且这条链上的点的编号是连续的一段区间。

接下来我们将构建整棵树看作一个这样的过程：

1. 将$1\sim n$分为$k$个区间，每段区间的长度不小于$2$。
2. 每段区间内部只有一种连边的方法，接着我们用$k-1$条边将这$k$个连通块连接起来。注意不能再有类似$(i,i+1)$这样的连边，我们称包含这种连边的情况为不合法情况。

比如当$n=4,k=2$时，有如下几种情况：

![image.png](https://i.loli.net/2021/01/16/pcOqX8nSDmdZNyL.png)![image.png](https://i.loli.net/2021/01/16/Jz2wmR1h4jGAryx.png)![image.png](https://i.loli.net/2021/01/16/ryzlRQ2UtWSmBOa.png)![image.png](https://i.loli.net/2021/01/16/gyUFstbJpd9Kiqo.png)

此时我们认为$\{1,2\}$是一个连通块，$\{3,4\}$是一个连通块，根据上面的定义，上面的四种情况中，前三种情况都是合法的，而最后一种情况不合法。

在计数的时候直接去除不合法的状态较为困难，因此可以考虑容斥。

记$f(i)$表示将$1\sim n$分为$i$个连通块（也就是区间），再连接$i-1$条边，可能出现不合法情况的方案数。

考虑如何计算$f$，假设我们已经将这$i$个区间分好了，第$i$个区间的大小为$a_i$。显然我们有$\sum a_i=n$，对于新加入的每条边来说，如果它的两个端点分别落在第$u$个区间以及第$v$个区间中，那么$u$这个端点有$a_u$种选法，$v$这个端点有$a_v$种选法。换言之，最终如果第$i$个连通块的度数为$j$，那么答案就要乘上$a_i^j$。

考虑对这棵树的`prufer`序计数。在`prufer`序中，一个点出现的次数为度数$-1$，而我们想要的贡献是$\prod a_i^j$。

因此我们可以将一个确定的$a_i$序列的贡献看作`prufer`序中所有出现$a_i$的乘积，再乘上每个连通块的度数的乘积。对于一个$a_i$来说，它在`prufer`序中出现了$j-1$次，再加上最后整体乘的一次，贡献恰好为$a_i^j$

由于`prufer`序的长度为$i-2$，因此实际上这个$a_i$序列的贡献为

$$
\begin{aligned}
\prod_{j=1}^ia_j\times (\sum_{k=1}^ia_k)^{i-2}=\prod a_i\times n^{i-2}
\end{aligned}
$$

我们可以根据这个式子设计一个朴素的$dp$，将$n^{i-2}$拆为$n^i\times n^{-2}$。注意到$n^{-2}$与$a_i$是没有关系的，因此我们在$dp$的过程中可以只考虑$\prod a_i\times n^i$。

记$dp[i][j]$表示将$1\sim i$分为$j$段区间，一组分法的贡献为$\prod a_i\times n^i$时所有方案的和，它可以通过简单的转移求得。

接下来我们需要计算出每个区间的容斥系数，根据广义容斥原理，一组$a_i$的容斥系数为每个$a_i$的容斥系数的乘积。此时每种$a_i$序列的贡献乘上自己的容斥系数再求和就是答案。

我们希望在最终的方案中，长度小于$2$的区间对答案的贡献次数都为$0$，长度大于等于$2$的区间对答案的贡献次数都为$1$。

不妨设$A(x)$是容斥系数的生成函数，$x^i$项的系数就代表长度为$i$的区间对应的容斥系数。对于在最终的一段长度为$i$的区间来说，在我们计算$f$的过程中它有可能被分为若干段小区间，然后在这些小区间之间连上了若干条不合法的边。每种这样的划分都会导致$i$被统计了一次，因此此时每种区间在答案中的统计次数的生成函数为

$$
A(x)+A(x)^2+A(x)^3+\cdots=\frac{1}{1-A(x)}-1
$$

我们希望长度小于$2$的区间被统计的次数都为$0$，因此

$$
\begin{aligned}
\frac{1}{1-A(x)}-1&=x^2+x^3+x^4+\cdots\\
&=\frac{1}{1-x}-1-x
\end{aligned}
$$

解得

$$
A(x)=\frac{x^2}{x^2-x+1}
$$

将$A(x)$展开，它的系数非常优美，为$\{0,1,1,0,-1,-1,0,1,1,0,-1,-1,\cdots\}$。

将$dp$写成生成函数的形式，由于$dp$的本质是将$n$划分为$i$段区间，我们有

$$
\begin{aligned}
B(x)&=\sum_{j\geq 2}nx^jA_j\\
dp[n][i]&=B(x)^i[x^n]\\
ans&=\sum_i \frac{dp[n][i]}{n^2}\\
&=\sum_i\frac{B(x)^i[x^n]}{n^2}\\
&=\frac{\frac{1}{1-B(x)}[x^n]}{n^2}
\end{aligned}
$$

调用一次多项式求逆即可。

[代码](https://paste.ubuntu.com/p/F62K6g4bQG/)


---

## 作者：Graphcity (赞：4)

首先将整棵树划分为若干值域连续的段，题目要求每一段长度至少为 2。这些连续段之间需要相互连边形成一棵树。根据 Prufer 定理，$k$ 个大小分别为 $w_{1\cdots k}$ 的连通块形成树的方案数为：
$$
n^{k-2}\prod_{i=1}^kw_i
$$
这相当于每个连通块给到了 $nw_i$ 的贡献，最后再乘一个 $n^{-2}$。现在出现了一个新的问题：那就是连续段相互连边的过程中，可能会出现更长的连续段。我们需要利用容斥去重。考虑给每一种长度的段分配一个容斥系数 $F_i$。设容斥系数的生成函数为 $F(x)$。要求一个极长连续段的所有划分方式容斥系数之和等于 $\sum_{i\ge 2}x^i$。也就是说：
$$
\begin{aligned}
\sum_{i\ge 1}F(x)^i &=\sum_{i\ge 2}x^i=\frac{x^2}{1-x}\\
\frac{1}{1-F(x)}-1&=\frac{x^2}{1-x}\\
1-F(x)&=\frac{-x+1}{x^2-x+1}\\
F(x)&=\frac{x^2}{x^2-x+1}
\end{aligned}
$$
接下来再写出每一个连续段对应的生成函数 $G(x)$：
$$
\begin{aligned}
G(x)&=\sum_{i}niF_ix^i\\
ans&=[x^n]\sum_{k\ge 1}G(x)^k=[x^n]\frac{1}{1-G(x)}-1
\end{aligned}
$$
因为 $n\ge 1$，答案其实就是这个多项式的第 $n$ 项。时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=1e6,Mod=998244353;

inline int Pow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1) res=1ll*res*x%Mod;
        x=1ll*x*x%Mod,y>>=1;
    }
    return res;
}

struct Poly
{
    const int g=3;
    int lim=1,len,rev[Maxn+5];
    inline void GetLim(int n)
    {
        lim=1,len=0;
        while(lim<=n*2) lim<<=1,len++;
        For(i,0,lim-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<len-1);
    }
    inline void NTT(int *A,int opt)
    {
        int ninv=Pow(lim,Mod-2);
        For(i,0,lim-1) if(i<rev[i]) swap(A[i],A[rev[i]]);
        for(int l=2,mid=1;l<=lim;l<<=1,mid<<=1)
        {
            int wi=Pow(g,(Mod-1)/l);
            if(opt==-1) wi=Pow(wi,Mod-2);
            for(int j=0;j<lim;j+=l)
                for(int k=0,w=1;k<mid;++k,w=1ll*w*wi%Mod)
                {
                    int f=A[j+k],t=1ll*A[j+k+mid]*w%Mod;
                    A[j+k]=(f+t)%Mod,A[j+k+mid]=(f-t+Mod)%Mod;
                }
        }
        if(opt==-1) For(i,0,lim-1) A[i]=1ll*A[i]*ninv%Mod;
    }
    int F1[Maxn+5],G1[Maxn+5];
    inline void GetMul(int *F,int *G,int *H)
    {
        For(i,0,lim-1) F1[i]=F[i],G1[i]=G[i];
        NTT(F1,1),NTT(G1,1);
        For(i,0,lim-1) F1[i]=1ll*F1[i]*G1[i]%Mod;
        NTT(F1,-1);
        For(i,0,lim-1) H[i]=F1[i];
    }
    int A[Maxn+5],B[Maxn+5],C[Maxn+5],P[Maxn+5];
    int Q[Maxn+5],R[Maxn+5],S[Maxn+5],T[Maxn+5];
    inline void GetInv(int *F,int *G,int n)
    {
        if(n==1) {G[0]=Pow(F[0],Mod-2); return;}
        GetInv(F,G,(n+1)/2),GetLim(n);
        For(i,0,lim-1) A[i]=(i<n?F[i]:0),B[i]=(i<n?G[i]:0);
        NTT(A,1),NTT(B,1);
        For(i,0,lim-1) G[i]=1ll*B[i]*(2-1ll*B[i]*A[i]%Mod+Mod)%Mod;
        NTT(G,-1);
        For(i,n,lim-1) G[i]=0;
    }
} P;

int main()
{
    static int n,F[Maxn+5],G[Maxn+5];
    ios::sync_with_stdio(false);
    cin>>n;
    For(i,0,n) F[0]=1,F[1]=Mod-1,F[2]=1;
    P.GetInv(F,G,n+1),memset(F,0,sizeof(F));
    For(i,2,n) F[i]=G[i-2];
    For(i,0,n) F[i]=1ll*F[i]*i%Mod*n%Mod;
    For(i,0,n) F[i]=(Mod-F[i])%Mod; F[0]++;
    memset(G,0,sizeof(G)),P.GetInv(F,G,n+1);
    int ans=1ll*G[n]*Pow(1ll*n*n%Mod,Mod-2)%Mod;
    cout<<ans<<endl;
    return 0;
}
```



---

## 作者：251Sec (赞：2)

通过找规律，发现 $f(n)$ 满足如下关系式：

$$
f(1)=0
$$

$$
f(2)=\frac{2}{n}
$$

$$
f(3)=\frac{3}{n}
$$

$$
f(4)=4
$$

$$
f(i)=2f(i-1)+(2n-3)f(i-2)+(2-n)f(i-3)-f(i-4)
$$

据此计算即可，复杂度 $O(n)$，可以优化到 $O(\log n)$。

核心代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 998244353;
int n;
ll f[100005];
ll QPow(ll a, ll b) {
	ll res = 1;
	for (; b; b >>= 1, a = a * a % P) if (b & 1) res = res * a % P;
	return res;
}
int main() {
	scanf("%d", &n);
	f[1] = 0, f[2] = QPow(n, P - 2) * 2 % P, f[3] = QPow(n, P - 2) * 3 % P, f[4] = 4;
	for (int i = 5; i <= n; i++) f[i] = (f[i - 1] * 2 + f[i - 2] * (2 * n - 3) + f[i - 3] * (2 - n) - f[i - 4]) % P;
	printf("%lld\n", (f[n] + P) % P);
	return 0;
}
```

---

首先有一个基本的想法：钦定若干连续段，然后把它们拼成一棵树。显然这会算重，于是给每个连续段赋一个容斥系数，这可以暴力推出来，至此我们得到 $O(n^2)$ 的 DP。

我们猜测：在 $n$ 固定时，DP 数组有较短的递推式，且递推式的每一项系数是关于 $n$ 较简单的式子，使用 BM 打表即可。

---

## 作者：analysis (赞：2)

独立完成，一遍就过了是我没想到的。

---

看题，显然要先容斥一下。

直接对点进行容斥显然是很费脑子的，大概就是对边进行容斥。

于是注意到题目的条件就是选出的点在序列上相邻的边要构成点覆盖。

在只考虑相邻的边的情况下，序列被划分为若干条链，不能出现单点。

考虑极长链很麻烦，于是目标就很明确了：我们实际上应该对链长进行容斥。

赋予钦定的长为 $n$ 的链 $p_i$ 的容斥系数，若其对应的 OGF 为 $P$，应有 $\operatorname{SEQ}(P)=\frac{1}{1-x}-x=\frac{1-x+x^2}{1-x} \Rightarrow P=\frac{x^2}{1-x+x^2}$。

再考虑若干链组成树，根据经典结论可以知道方案数为 $n^{k-2}(\prod a_i)=n^{-2}(\prod na_i)$，于是挂到 GF 上就有 $F=n\sum_{i \geq 0}p_iix^i=nxP'$，答案即为 $n^{-2}[x^n]\operatorname{SEQ}(F)$。

考虑到：
$$
F=nxP'=-\frac{nx^2(x-2)}{(1-x+x^2)^2}\\
\operatorname{SEQ}(F)=\frac{x^4-2x^3+3x^2-2x+1}{x^4+(n-2)x^3+(3-2n)x^2-2x+1}
$$

直接做 bostan-mori 就可以 $O(k^2\log{n})$ 或 $O(k\log{k}\log{n})$，$k=5$。

```cpp
#include<bits/stdc++.h>
#define poly vector<int>
const int mod=998244353;
int fpow(int a,int b=mod-2){
    int r=1;
    while(b){
        if(b&1)r=1ll*r*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return r;
}
using namespace std;
poly mul(poly a,poly b){
    poly r;r.clear();r.resize((int)a.size()+(int)b.size()-1);
    for(int i=0;i<(int)a.size();i++){
        for(int j=0;j<(int)b.size();j++){
            r[i+j]=(r[i+j]+1ll*a[i]*b[j]%mod)%mod;
        }
    }
    return r;
}
int mori(poly f,poly g,int n){
    for(;n;n>>=1){
        poly gf=g;
        for(int i=1;i<(int)gf.size();i+=2)gf[i]=(mod-gf[i])%mod;
        f=mul(f,gf);g=mul(g,gf);
        int i;
        for(i=(n&1);i<(int)f.size();i+=2)f[i>>1]=f[i];
        f.resize(i>>1);
        for(i=0;i<(int)g.size();i+=2)g[i>>1]=g[i];
        g.resize(i>>1);
    }
    if(f.empty())return 0;
    return 1ll*f[0]*fpow(g[0])%mod;
}
int n;
poly f,g;
signed main(){
    cin>>n;f.resize(5);g.resize(5);
    f[0]=1,f[1]=mod-2,f[2]=3,f[3]=mod-2,f[4]=1;
    g[0]=1,g[1]=mod-2,g[2]=(3-2*n+mod)%mod,g[3]=n-2,g[4]=1;
    int ans=1ll*fpow(1ll*n*n%mod)*mori(f,g,n)%mod;
    cout<<ans;
    return 0;
}
```

---

## 作者：chroneZ (赞：2)

我们称好边为满足边的端点满足 $|u - v| = 1$ 的边。容易发现，一棵树合法当且仅当保留所有的好边后，每个连通块大小均大于等于 $2$。更进一步地，每个连通块显然是一个值域连续段，并且只能连成一条链的形态。因此，我们可以将一棵树按照好边划分为若干条极长的链。

一个初步的想法是，直接钦定链的划分方式，在此基础上对树进行计数。根据 Prufer 定理，对于 $n$ 个点，若我们划分为了 $m$ 个长为 $L_{1 \dots m}$ 的链，则在此基础上连边形成树的数量为

$$
n ^ {m - 2} \prod_{i = 1} ^ m L_i
$$

但是钦定链的划分方式会导致一个问题，最终我们加边得到的树的链划分可能与钦定的有所不同，原因在于加入的边也有可能是好边，从而合并了两极长链。

考虑容斥原理，问题在于容斥系数应该怎么调配。如果你学过集合划分容斥，这里的处理思路就是十分类似的：一棵树会在其正确划分的所有子划分处都被统计一次，我们需要保证这些局面下的容斥系数之和等于 $1$。容易发现这等价于，每个长为 $m(m \geq 2)$ 的链都需满足其所有划分对应的容斥系数之和为 $1$。由上，我们记 $\delta(x)$ 为容斥系数的 OGF，可以得到

$$
\sum_{i \geq 1} \delta^i(x) = \sum_{i \geq 2} x^i
$$

容易解出 $\delta(x) = \dfrac{x^2}{1 - x + x^2}$。

那么我们记 $F(x) = \sum \limits_{i \geq 2} ix^i[x^i]\delta(x)$，可以得到答案为

$$
\sum_{i} n^{i - 2} [x^n]F^i(x) 
$$

转写为 $n^{-2} [x^n] \dfrac{1}{1 - n F(x)}$，直接计算即可。时间复杂度为 $\Theta(n \log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

constexpr int mod = 998244353, N = 1 << 21, invg = (mod + 1) / 3;
namespace basic {
  inline int add(int x, int y) {return (x + y >= mod ? x + y - mod : x + y);}
  inline int dec(int x, int y) {return (x - y < 0 ? x - y + mod : x - y);}
  inline void ad(int &x, int y) {x = add(x, y);}
  inline void de(int &x, int y) {x = dec(x, y);}

  inline int qpow(int a, int b) {
    int r = 1;
    while(b) {
      if(b & 1) r = 1ll * r * a % mod;
      a = 1ll * a * a % mod; b >>= 1;
    }
    return r;
  }
  inline int inv(int x) {return qpow(x, mod - 2);}

  int fac[N], ifac[N];
  inline void fac_init(int n = N - 1) {
    fac[0] = 1;
    for(int i = 1; i <= n; i++)
      fac[i] = 1ll * fac[i - 1] * i % mod;
    ifac[n] = inv(fac[n]);
    for(int i = n - 1; i >= 0; i--)
      ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
  }
  int invx[N];
  inline void inv_init(int n = N - 1) {
    invx[1] = 1;
    for(int i = 2; i <= n; i++)
      invx[i] = 1ll * (mod - mod / i) * invx[mod % i] % mod;
  }
  inline int binom(int n, int m) {
    if(n < m || m < 0) return 0;
    return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;
  }

  int rev[N];
  inline void rev_init(int n) {
    for(int i = 1; i < n; i++) {
      rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? n >> 1 : 0);
    }
  }
}
using namespace basic;

struct Poly {
  vector<int> a;
  inline int & operator [] (int x) {return a[x];}
  Poly() {}
  inline int size() {return a.size();}
  inline void resize(int n) {a.resize(n, 0);}
  explicit Poly(int n) {resize(n);}
  Poly(vector<int> b) {a = b;}
  inline void clear() {a.clear();}

  inline friend Poly operator + (Poly x, Poly y) {
    Poly ret(max(x.size(), y.size()));
    for(int i = 0; i < ret.size(); i++) {
      if(i < x.size()) {ad(ret[i], x[i]);}
      if(i < y.size()) {ad(ret[i], y[i]);}
    }
    return ret;
  }
  inline friend Poly operator - (Poly x, Poly y) {
    Poly ret(max(x.size(), y.size()));
    for(int i = 0; i < ret.size(); i++) {
      if(i < x.size()) {ad(ret[i], x[i]);}
      if(i < y.size()) {de(ret[i], y[i]);}
    }
    return ret;
  }

  inline void NTT(int type) {
    int n = size();
    rev_init(n);
    for(int i = 1; i < n; i++) {
      if(i < rev[i]) {
        swap(a[i], a[rev[i]]);
      }
    }
    static int gr[N]; gr[0] = 1;
    for(int d = 1; d < n; d <<= 1) {
      int gw = qpow(type == 1 ? 3 : invg, (mod - 1) / (d << 1));
      for(int i = 1; i < d; i++) {
        gr[i] = 1ll * gr[i - 1] * gw % mod;
      }
      for(int i = 0; i < n; i += d << 1) {
        for(int j = 0; j < d; j++) {
          int x = a[i + j], y = 1ll * gr[j] * a[i + j + d] % mod;
          a[i + j] = add(x, y);
          a[i + j + d] = dec(x, y);
        }
      }
    }
    if(type == -1) {
      for(int i = 0, invn = inv(n); i < n; i++) {
        a[i] = 1ll * a[i] * invn % mod;
      }
    }
  }
  inline friend Poly operator * (Poly x, Poly y) {
    int m = x.size() + y.size() - 1;
    int n = 1;
    while(n < m) {
      n <<= 1;
    }
    x.resize(n), y.resize(n);
    x.NTT(1), y.NTT(1);
    for(int i = 0; i < n; i++) {
      x[i] = 1ll * x[i] * y[i] % mod;
    }
    x.NTT(-1);
    x.resize(m);
    return x;
  }

  inline Poly operator += (Poly x) {
    return (*this) = (*this) + x;
  }
  inline Poly operator -= (Poly x) {
    return (*this) = (*this) - x;
  }
  inline Poly operator *= (Poly x) {
    return (*this) = (*this) * x;
  }

  inline Poly operator * (int x) {
    Poly ret(size());
    for(int i = 0; i < size(); i++) {
      ret[i] = 1ll * a[i] * x % mod;
    }
    return ret;
  }

  inline Poly Deriv() {
    Poly ret(size() - 1);
    for(int i = 1; i < size(); i++) {
      ret[i - 1] = 1ll * a[i] * i % mod;
    }
    return ret;
  }
  inline Poly Integ() {
    Poly ret(size() + 1); 
    for(int i = 0; i < size(); i++) {
      ret[i + 1] = 1ll * a[i] * inv(i + 1) % mod;
    }
    return ret;
  }

  // Implement followings by Newton's Method.
  // f(x) = f0(x) - g(f0(x)) / g'(f0(x))
  inline Poly Inv() {
    assert(a[0] != 0);
    Poly f0 = vector<int>{inv(a[0])};
    while(f0.size() < size()) {
      int n = f0.size() << 1;
      Poly h = (*this); h.resize(n), h.resize(n << 1); h.NTT(1);
      f0.resize(n << 1); f0.NTT(1);
      for(int i = 0; i < (n << 1); i++) {
        f0[i] = 1ll * f0[i] * dec(2, 1ll * f0[i] * h[i] % mod) % mod;
      }
      f0.NTT(-1), f0.resize(n);
    }
    f0.resize(size());
    return f0;
  }
  
  inline Poly Ln() {
    assert(a[0] == 1);
    Poly ret = ((*this).Deriv() * (*this).Inv()).Integ();
    ret.resize(size());
    return ret;
  }

  inline Poly Exp() {
    assert(a[0] == 0);
    Poly f0 = vector<int>{1};
    while(f0.size() < size()) {
      int n = f0.size() << 1; f0.resize(n);
      Poly t = f0.Ln();
      Poly h = (*this); h.resize(n);
      for(int i = 0; i < n; i++) {
        t[i] = dec(h[i], t[i]);
      }
      ad(t[0], 1);
      f0 = f0 * t; f0.resize(n);
    }
    f0.resize(size());
    return f0;
  }

  inline Poly Sqrt() {
    Poly f0 = vector<int>{1};
    while(f0.size() < size()) {
      int n = f0.size() << 1; f0.resize(n);
      Poly h = (*this); h.resize(n);
      f0 = f0 + h * f0.Inv(); f0.resize(n);
      int inv2 = inv(2);
      for(int i = 0; i < n; i++) {
        f0[i] = 1ll * f0[i] * inv2 % mod;
      }
    }
    return f0;
  }
};

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr), cout.tie(nullptr);
  
  int n; cin >> n;
  Poly D(n + 1);
  D[0] = D[2] = 1, D[1] = mod - 1;
  D = D.Inv() * vector<int>{0, 0, 1}; D.resize(n + 1);
  Poly F(n + 1);
  for(int i = 2; i <= n; i++) {
    F[i] = 1ll * D[i] * i % mod;
  }
  int ans = ((vector<int>{1} - F * n).Inv())[n];
  cout << 1ll * ans * inv(1ll * n * n % mod) % mod << "\n";
}
```

---

## 作者：tzc_wk (赞：1)

最终方案肯定是将 $[1,n]$ 划分为若干个长度 $\ge 2$ 的区间 $[l_i,r_i]$ 满足 $l_i\sim r_i$ 按照 $l_i\to l_i+1\to l_i+2\to\cdots\to r_i$ 的方案连成一条链，剩余点之间连边满足不存在其他边两端点差为 $1$。

考虑对后面那个限制进行容斥，即将 $[1,n]$ 划分为一些长度 $\ge 2$ 的连续段并钦定它们必须连成一条链。然后乘以适当的容斥系数并求和。先考虑钦定一些连续段怎么算方案数，这是[经典问题](https://www.cnblogs.com/tzcwk/p/codeforces-917D.html)。答案是 $n^{k-2}·\prod(r_i-l_i+1)$，其中 $k$ 是你划分出的连续段个数。接下来考虑怎么钦定容斥系数 $A(x)$。因为对于一组方案，如果其中有一个长度为 $len$ 的连续段，那么所有对其有贡献的拆分 $b_i$ 均满足 $\sum b_i=len$，它们的容斥系数之和为 $\sum\limits_{\sum b_i=len}\prod[x^{b_i}]A(x)$，我们希望 $\sum\limits_{\sum b_i=len}\prod[x^{b_i}]A(x)=[len\ge 2]$，而根据生成函数的知识，前者等于 $[x^{len}](A(x)+A^2(x)+A^3(x)+\cdots)=[x^{len}]\dfrac{1}{1-A(x)}-1$，因此 $\dfrac{1}{1-A(x)}-1=\dfrac{1}{1-x}-1-x$，解得 $A(x)=\dfrac{x^2}{x^2-x+1}$，手玩可知系数为 $\{0,0,1,1,0,-1,-1,0,1,1,0,-1,-1\}$（0-indexed）。

这样，考虑 $B(x)=\sum\limits_{t}tnA_tx^t$，答案就是 $n^{-2}[x^n]\sum\limits_{i}B^i(x)=n^{-2}[x^n]\dfrac{1}{1-B(x)}$，多项式求逆搞定。

```cpp
const int MAXN=1e5;
const int MAXP=1<<18;
const int pr=3;
const int ipr=332748118;
const int MOD=998244353;
int calc(int x){
	x%=6;
	if(x==2||x==3)return 1;
	if(x==5||x==0)return MOD-1;
	return 0;
}
int qpow(int x,int e){int ret=1;for(;e;e>>=1,x=1ll*x*x%MOD)if(e&1)ret=1ll*ret*x%MOD;return ret;}
int n,rev[MAXP+5];
void NTT(vector<int> &a,int len,int type){
	int lg=31-__builtin_clz(len);
	for(int i=0;i<len;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<lg-1);
	for(int i=0;i<len;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int i=2;i<=len;i<<=1){
		int W=qpow((type<0)?ipr:pr,(MOD-1)/i);
		for(int j=0;j<len;j+=i){
			for(int k=0,w=1;k<(i>>1);k++,w=1ll*w*W%MOD){
				int X=a[j+k],Y=1ll*a[(i>>1)+j+k]*w%MOD;
				a[j+k]=(X+Y)%MOD;a[(i>>1)+j+k]=(X-Y+MOD)%MOD;
			}
		}
	}
	if(!~type){
		int iv=qpow(len,MOD-2);
		for(int i=0;i<len;i++)a[i]=1ll*a[i]*iv%MOD;
	}
}
vector<int>conv(vector<int>a,vector<int>b){
	int LEN=1;while(LEN<a.size()+b.size())LEN<<=1;
	a.resize(LEN,0);b.resize(LEN,0);NTT(a,LEN,1);NTT(b,LEN,1);
	for(int i=0;i<LEN;i++)a[i]=1ll*a[i]*b[i]%MOD;
	NTT(a,LEN,-1);return a;
}
vector<int>getinv(vector<int>a,int len){
	vector<int>b(len,0);b[0]=qpow(a[0],MOD-2);
	for(int i=2;i<=len;i<<=1){
		vector<int>c(b.begin(),b.begin()+(i>>1));
		vector<int>d(a.begin(),a.begin()+i);
		c=conv(c,c);d=conv(c,d);
		for(int j=0;j<i;j++)b[j]=(2*b[j]%MOD-d[j]+MOD)%MOD;
	}return b;
}
int main(){
	scanf("%d",&n);int LEN=1;while(LEN<=n)LEN<<=1;
	vector<int>a(LEN),b;
	for(int i=0;i<LEN;i++){
		if(!i)a[i]=1;
		else a[i]=(-1ll*calc(i)*i%MOD*n%MOD+MOD)%MOD;
	}b=getinv(a,LEN);
	printf("%d\n",1ll*b[n]*qpow(n,MOD-3)%MOD);
	return 0;
}
```


---


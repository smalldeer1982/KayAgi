# 平凡点滴

## 题目背景

少年看见他的桌上有一本书。  
翻开着其中一页。  
上面只有一道题。

## 题目描述

他写下一个函数 $f(n)$。  
它是这么定义的：  
记 $n$ 的质因子分解式中每个质因子的最大次数为 $g(n)$，例如 $g(2)=1,g(12)=2$。  
**注意**：本题中假设 $g(1)=1$。样例及数据已修正。  
则 $f(n) = \max(m-g(n)+1,0) n^k$。  
其中 $m,k$ 都是他将给定你的参数。

他希望你求出
$$
\sum\limits_{i=1}^n \sum\limits_{j=1}^n f(\gcd(i,j))
$$

并对 $998244353$ 取模。

## 说明/提示

对于 $70\%$ 的数据，$n \le 10^7$；  
对于 $50\%$ 的数据，$m \le 33$；  
对于 $100\%$ 的数据，$1 \le n \le 10^{10}$, $1 \le m < 998244353$, $1 \le k \le 100$。

除此之外，添加一组来自 @[cqbzljsqwq](/user/154560) 的 Hack 数据。

## 样例 #1

### 输入

```
4 4 4```

### 输出

```
1328```

## 样例 #2

### 输入

```
6 6 6```

### 输出

```
410114```

## 样例 #3

### 输入

```
10000000000 114514 100```

### 输出

```
603074925```

# 题解

## 作者：ForgotMe (赞：5)

写个比较好懂的题解，看官方题解理解了半天。。。。

先写一下怎么推的柿子。（不想看的可以跳过）

$$
\sum_{i=1}^n\sum_{j=1}^nf(\gcd(i,j))
$$

$$
\sum_{d=1}^nf(d)\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=d]
$$

$$
\sum_{d=1}^nf(d)\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{n}{d}}[\gcd(i,j)=1]
$$

$$
\sum_{d=1}^nf(d)\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{n}{d}}[\gcd(i,j)=1]
$$

$$
\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{n}{d}}[\gcd(i,j)=1]
$$
这一坨指数很经典，就是仪仗队。

所以答案为
$$
\sum_{d=1}^nf(d)(2\sum_{i=1}^{\frac{n}{d}}\varphi(i)-1)
$$

右边这一坨直接整除分块套杜教筛即可，考虑怎么处理 $f$ 函数的前缀和。

这里讲两个思路。

### Way-1

$f(n) = \max(m-g(n)+1,0) n^k$ 中这坨 $\max(m-g(n)+1,0)$ 指数很恶心，让人无从下手，但发现 $g(n)$ 的最大值最多只为 $\log_2(n)$，于是考虑枚举 $g(n)$ 的值 $u$。

问题传化为怎么快速求

$$
\sum_{i=1}^n[g(i)=u]i^k
$$

这东西不好求，考虑转化。

$$
\sum_{i=1}^n[g(i)=u]i^k=\sum_{i=1}^n[g(i)\le u]i^k-\sum_{i=1}^n[g(i)\lt u]i^k
$$

这东西考虑用 min_25 直接求，简直就是 min_25 板子题，直接改一改 S 求和函数里的限制条件就行，然后差分直接乘上系数答案就出来了，**理论时间复杂度** $\mathcal{O}(\sqrt{n}+kn+n^{\frac{3}{4}}+n^{\frac{2}{3}})$。

但是，这个东西我写了一下，跑 $2\times 10^9$ 本地都要跑 15S 左右，$10^{10}$ 直接 T 爆，反正我的代码是过不了的 ~~（可能是我写的太丑了）~~，~~有兴趣的同学可以去写一写，要是过了 @ 我一下~~。

不过这玩意不知道能不能用新版的 min_25 筛去搞，要是能行的话应该能过，反正我没试过，理论复杂度应该会变为 $\mathcal{O(n^{\frac{2}{3}}}\log n)$。

### Way-2

~~还是不要搞着这些歪门邪道，要想正解，这题怎么可能这么简单。~~

同样的跟上面的思路一样，枚举 $g(n)$ 的值 $u$。

将 $f(n)$ 的系数搞一下事情，$f(n)$ 变为 $\max((m+1)-g(n),0)n^k$。

这启发我们可以转化问题，先算出所有的贡献，在减去不应该有的贡献。

形象化的表达即
$$
\sum_{i=1}^n f(i)=(m+1)\sum_{i=1}^ni^k-\sum_{u=1}^{\min(m+1,\log_2(n))}\sum_{i=1}^n[u\le g(i)]i^k
$$
前面的柿子就是自然数幂和，伯努利数，第二类斯特林数直接搞，推一推后面的柿子。
$$
\sum_{u=1}^{\min(m+1,\log_2(n))}\sum_{i=1}^n[u\le g(i)]i^k
$$

任意一个正整数的 $g(i)$ 都是大于等于 $1$（题目中特殊规定了 $g(1)=1$），所以可以拆一下柿子。

$$
\sum_{u=2}^{\min(m+1,\log_2(n))}\sum_{i=1}^n[u\le g(i)]i^k+\sum_{i=1}^ni^k
$$

然后来看前面这一坨柿子。

$$
\sum_{u=2}^{\min(m+1,\log_2(n))}\sum_{i=1}^n[u\le g(i)]i^k
$$

考虑做容斥，枚举一些质因子强制大于等于 $u$。

$$
\sum_{u=2}^{\min(m+1,\log_2(n))}\sum_{i=1}^n[u\le g(i)]i^k=-\sum_{u=2}^{\min(m+1,\log_2(n))}\sum_{p=2}^{\sqrt[u]{n}}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{p^u}\rfloor}(ip^u)^k
$$

然后移项。
$$
\sum_{u=2}^{\min(m+1,\log_2(n))}\sum_{p=2}^{\sqrt[u]{n}}\mu(p)p^u\sum_{i=1}^{\lfloor\frac{n}{p^u}\rfloor}i^k
$$

发现这东西可以直接算，后面那一坨就是自然数幂和，我们可以通过对 $n$ 整除分块得到对于任意一个 $i$，$\lfloor\dfrac{n}{i}\rfloor$ 的值，然后套上求自然数幂和的板子直接预处理出来，然后每次 $\mathcal{O(1)}$ 用就行了。

至于每次求前缀和的时间复杂度大约在 $\mathcal{O(\sqrt{n})}$，~~至于证明我不会，我可是个时间复杂度的白痴。~~

#### 关于为啥这个式子是正确的。

$$
\sum_{i=1}^n[u\le g(i)]i^k=-\sum_{p=2}^{\sqrt[u]{n}}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{p^u}\rfloor}(ip^u)^k
$$

我来解释一下，因为莫比乌斯函数就相当于是个容斥，当 $p$ 有多个重复的质因子是值为 $0$，于是相当于枚举的不同质因子的乘积。

举个通俗易懂的栗子来说明一下这个式子，$\mu(2)=-1$，$\mu(3)=-1$，$\mu(6)=1$，当 $p=2$ 时，我减去了有质因子 $2$ 的次数大于等于 $u$ 的数的贡献，当 $p=3$ 时，我减去了有质因子 $3$ 的次数大于等于 $u$ 的数的贡献，但是你会发现我减多了，对于形如 $i6^u$ 的数我们会减去两次，于是需要加回来。

如果还不懂的话可以去搜一搜莫比乌斯函数与容斥，~~包看包懂~~。

代码
```cpp
#include <cstdio>
#include <map>
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>
#include <cmath>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define LL long long
#define int long long
const int mod = 998244353;
const int inv2 = 499122177;
int dec(int x, int y) { return x >= y ? x - y : x + mod - y; }
int mul(int x, int y) { return 1ll * x * y % mod; }
int add(int x, int y) {
    if (x + y >= mod)
        return x + y - mod;
    return x + y;
}
int qkpow(LL a, int b) {
    int res = 1;
    for (; b; b >>= 1, a = mul(a, a))
        if (b & 1)
            res = mul(res, a);
    return res;
}
int sq, size, cnt;
int m, k, prime[10000005], id1[1000005], id2[1000005], Str[105][105], fk[10000005];
int h[1000005], hprime[2000005], phi[10000005], mn[10000005], mx[10000005], pw[10000005], f[10000005],
    inv[205];
int mu[200005], fs[200005];
LL n, num[1000005];
bool vis[10000005];

gp_hash_table<LL, int> Phi;

int Id(LL x) {
    if (x == 0)
        return 0;
    return (x <= sq ? id1[x] : id2[n / x]);
}

int S(LL n) {
    if (n == 1)
        return m;
    if (n <= 10000000)
        return f[n];
    if (fs[Id(n)])
        return fs[Id(n)];
    int maxg = log2(n) + 1;
    int tot = mul(m, h[Id(n)]);
    for (int p = 2; 1ll * p * p <= n; p++) {
        if (mu[p]) {
            int pkx = mul(pw[p], pw[p]);
            LL anopkx = 1ll * p * p;
            for (int u = 2; anopkx <= n && u <= min(m + 1, maxg);
                 u++, pkx = mul(pkx, pw[p]), anopkx = 1ll * anopkx * p) {
                int now = mul(mu[p], pkx);
                tot = add(tot, mul(now, h[Id(n / anopkx)]));
            }
        }
    }
    return fs[Id(n)] = tot;
}

int calcphi(LL n) {
    if (n <= 10000000)
        return phi[n];
    if (Phi[n])
        return Phi[n];
    int res = mul(n % mod, add(n, 1) % mod);
    res = mul(res, inv2);
    for (LL i = 2, j; i <= n; i = j + 1) {
        j = n / (n / i);
        res = dec(res, mul(dec(add(j % mod, 1) % mod, i % mod), calcphi(n / i)));
    }
    return Phi[n] = res;
}

signed main() {
    scanf("%lld %lld %lld", &n, &m, &k);
    for (int i = 1; i <= k + 2; i++) inv[i] = qkpow(i, mod - 2);
    Str[0][0] = 1;
    for (int i = 1; i <= k; i++)
        for (int j = 1; j <= k; j++) Str[i][j] = add(Str[i - 1][j - 1], mul(j, Str[i - 1][j]));
    sq = sqrt(n * 1.0);
    phi[1] = 1, f[1] = m, pw[1] = 1;
    for (int i = 2; i <= 10000000; i++) {
        if (!vis[i])
            prime[++cnt] = i, phi[i] = i - 1, pw[i] = qkpow(i, k), mn[i] = mx[i] = 1;
        for (int j = 1; j <= cnt && prime[j] * i <= 10000000; j++) {
            vis[i * prime[j]] = 1;
            pw[i * prime[j]] = mul(pw[i], pw[prime[j]]);
            if (i % prime[j] == 0) {
                mn[i * prime[j]] = mn[i] + 1, mx[i * prime[j]] = max(mx[i], mn[i] + 1);
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            mn[i * prime[j]] = 1, mx[i * prime[j]] = mx[i];
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
        f[i] = add(f[i - 1], mul(pw[i], max(m - mx[i] + 1, 0ll))) % mod;
        phi[i] = add(phi[i], phi[i - 1]);
    }
    for (int i = 1; i <= sq; i++) vis[i] = 0;
    cnt = 0;
    mu[1] = 1;
    for (int i = 2; i <= sq; i++) {
        if (!vis[i])
            mu[i] = -1, prime[++cnt] = i, fk[cnt] = pw[i], hprime[cnt] = add(hprime[cnt - 1], fk[cnt]);
        for (int j = 1; j <= cnt && prime[j] * i <= sq; j++) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
    for (int i = 1; i <= sq; i++) mu[i] = (mu[i] == -1 ? mod - 1 : mu[i]);
    for (LL l = 1, r; l <= n; l = r + 1) {
        r = n / (n / l);
        num[++size] = n / r;
        LL Num = n / r % mod;
        int prod = 1;
        for (int i = 0; i <= k; ++i)
            prod = mul((Num + 1 - i) % mod, prod),
            h[size] = add(h[size], mul(mul(Str[k][i], prod), inv[i + 1]));
        if (n / r <= sq)
            id1[n / r] = size;
        else
            id2[r] = size;
    }
    int tot = 0, lstans = 0;
    for (LL l = 1, r; l <= n; l = r + 1) {
        r = n / (n / l);
        int phisum = dec(mul(2, calcphi(n / r)), 1), ano, fsum = S(r);
        ano = fsum;
        fsum = dec(fsum, lstans);
        lstans = ano;
        tot = add(tot, mul(fsum, phisum));
    }
    printf("%lld\n", tot);
    return 0;
}
```

---

## 作者：Aleph1022 (赞：5)

本文同步发表于我的博客：<https://www.alpha1022.me/articles/lg-7277.htm>。

首先显然地，有答案为
$$
\sum\limits_{d=1}^n f(d) \left(2\sum\limits_{i=1}^{\left\lfloor\frac nd\right\rfloor} \varphi(i) - 1\right)
$$

杜教筛 / Min_25 筛一下，那么问题变为求 $f(i)$ 的前缀和。  
设 $s(n) = \sum\limits_{i=1}^n f(i)$。

观察到 $f(n)$ 实际上并不好处理，考虑把那个 $\max(m-g(n)+1,0)$ 的系数处理一下：
$$
f(n) = \sum\limits_{u=1}^m [g(n) \le u] n^k
$$

但是 $m$ 可能很大。  
然而注意到 $g(n) \le \log_2 n$，所以可以把 $m$ 降到 $O(\log n)$ 级别，超出部分直接算一下自然数幂和即可。

则
$$
\begin{aligned}
s(n)
&= \sum\limits_{i=1}^n f(i) \\
&= \sum\limits_{i=1}^n \sum\limits_{u=1}^m [g(i) \le u] i^k \\
&= \sum\limits_{u=1}^m \sum\limits_{i=1}^n [g(i) \le u] i^k
\end{aligned}
$$

考虑求 $\sum\limits_{i=1}^n [g(i) \le u]i^k$。  
这可以考虑容斥，即枚举某些质因子，使它们的指数强制超过 $u$。  
则
$$
\begin{aligned}
\sum\limits_{i=1}^n [g(i) \le u]i^k
&= \sum\limits_{p=1}^{\lfloor n^{1/(u+1)}\rfloor} \mu(p) \sum\limits_{i=1}^{\left\lfloor\frac n{p^{u+1}}\right\rfloor} (ip^{u+1})^k \\
&= \sum\limits_{p=1}^{\lfloor n^{1/(u+1)}\rfloor} \mu(p) p^{(u+1)k} \sum\limits_{i=1}^{\left\lfloor\frac n{p^{u+1}}\right\rfloor} i^k
\end{aligned}
$$

然后注意到 $\sum\limits_{u=1}^m O(n^{1/(u+1)}) = O(\sqrt n)$，所以对于 $u=1,\dots, m$ 如此计算一次的复杂度是 $O(\sqrt n)$ 的。  
另外可以通过线筛 $g(n)$ 预处理出一定范围内的 $s(n)$。  
于是根据杜教筛的思想，平衡至 $O(n^{2/3})$ 即可。

不过还有一个问题，那就是计算自然数 $k$ 次幂和。  
这是一个经典问题，容易发现需要计算的位置只有 $O(\sqrt n)$ 种，有很多方法可以做到 $O(k^2)$ 预处理后 $O(k\sqrt n)$ 解决。  
标程使用的是第二类斯特林数。

总复杂度 $O(k^2 + k\sqrt n + n^{2/3})$。  
可能略微卡常。

代码：
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const long long N = 1e10;
const int MX = 5e6;
const int LIM = 1e5;
const int M = 33;
const int K = 100;
const int mod = 998244353;
inline int fpow(int a,int b)
{
    int ret = 1;
    for(;b;b >>= 1)
        (b & 1) && (ret = (long long)ret * a % mod),a = (long long)a * a % mod;
    return ret;
}
long long n;
int lim,m,k;
int inv[K + 5],S[K + 5][K + 5];
int vis[MX + 5],cnt,prime[MX + 5];
int mn[MX + 5],mx[MX + 5],f[MX + 5],phi[MX + 5],mu[MX + 5],pw[MX + 5];
int le[LIM + 5],ge[LIM + 5],tot;
int sk[2 * LIM + 5];
inline int &id(long long x)
{
    return x <= lim ? le[x] : ge[n / x];
}
int w[2][MX + 5];
inline int &mem_sphi(long long x)
{
    return w[0][n / x];
}
inline int &mem_sf(long long x)
{
    return w[1][n / x];
}
int sphi(long long n)
{
    if(n <= MX)
        return phi[n];
    if(~mem_sphi(n))
        return mem_sphi(n);
    int ret = n & 1 ? ((n + 1 >> 1) % mod) * (n % mod) % mod : ((n >> 1) % mod) * ((n + 1) % mod) % mod;
    for(register long long l = 2,r;l <= n;l = r + 1)
    {
        r = n / (n / l);
        ret = (ret - (r - l + 1) % mod * sphi(n / l) % mod + mod) % mod;
    }
    return mem_sphi(n) = ret;
}
int sf(long long n)
{
    if(n <= MX)
        return f[n];
    if(~mem_sf(n))
        return mem_sf(n);
    int ret = m > M ? (long long)(m - M) * sk[id(n)] % mod : 0;
    for(register int i = 1;(long long)i * i <= n;++i)
        if(mu[i])
        {
            long long j = n / i / i;
            int s = (long long)pw[i] * pw[i] % mod;
            for(register int u = 1;u <= min(m,M) && j;++u,j /= i,s = (long long)s * pw[i] % mod)
                ret = (ret + (long long)s * mu[i] % mod * sk[id(j)]) % mod;
        }
    return mem_sf(n) = ret;
}
int ans;
int main()
{
    memset(w,-1,sizeof w);
    scanf("%lld%d%d",&n,&m,&k),lim = sqrt(n);
    inv[1] = 1;
    for(register int i = 2;i <= k + 1;++i)
        inv[i] = (long long)(mod - mod / i) * inv[mod % i] % mod;
    S[0][0] = 1;
    for(register int i = 1;i <= k;++i)
        for(register int j = 1;j <= k;++j)
            S[i][j] = (S[i - 1][j - 1] + (long long)j * S[i - 1][j]) % mod;
    phi[1] = mu[1] = pw[1] = 1,f[1] = m;
    for(register int i = 2;i <= MX;++i)
    {
        if(!vis[i])
            mn[prime[++cnt] = i] = mx[i] = 1,phi[i] = i - 1,mu[i] = mod - 1,pw[i] = fpow(i,k);
        for(register int j = 1;j <= cnt && i * prime[j] <= MX;++j)
        {
            vis[i * prime[j]] = 1,pw[i * prime[j]] = (long long)pw[i] * pw[prime[j]] % mod;
            if(!(i % prime[j]))
            {
                mn[i * prime[j]] = mn[i] + 1,mx[i * prime[j]] = max(mx[i],mn[i] + 1),phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            mn[i * prime[j]] = 1,mx[i * prime[j]] = mx[i],phi[i * prime[j]] = phi[i] * (prime[j] - 1),mu[i * prime[j]] = (mod - mu[i]) % mod;
        }
        f[i] = (f[i - 1] + (long long)pw[i] * max(m - mx[i] + 1,0)) % mod,
        phi[i] = (phi[i] + phi[i - 1]) % mod;
    }
    for(register long long l = 1,r;l <= n;l = r + 1)
    {
        r = n / (n / l);
        id(n / l) = ++tot;
        int prod = 1;
        for(register int i = 0;i <= k;++i)
            prod = (n / l + 1 - i) % mod * prod % mod,
            sk[tot] = (sk[tot] + (long long)S[k][i] * prod % mod * inv[i + 1]) % mod;
    }
    for(register long long l = 1,r;l <= n;l = r + 1)
    {
        r = n / (n / l);
        ans = (ans + (2LL * sphi(n / l) - 1 + mod) * (sf(r) - sf(l - 1) + mod)) % mod;
    }
    printf("%d\n",ans);
}
```

---


# Dream and the Multiverse REMATCH

## 题目描述

Dream 将时空的结构抽象为一个有 $N$ 个节点（编号为 $1$ 到 $N$）的有向根树（树形结构）。节点 $1$ 是根节点，对于每个 $i$（$1 \le i \le N-1$），节点 $i+1$ 的父节点是 $f_i$。这棵树的所有边都是从根节点指向外部的。

然后，Dream 使用一种神奇的超能力，向这棵树中添加了 $M$ 条有向边，使得结果图仍然是无环的（有向无环图，DAG）。

我们称这个 DAG 的一个节点为一个*事件*，并进一步称这个 DAG 上的一条简单路径为一个*时代*。Dream 认为一对事件 $(i,j)$ 是*可能的*，如果存在一个时代，其第一个事件是 $i$，最后一个事件是 $j$。注意，对于一个可能的对，$i < j$ 并不一定成立。

Dream 现在希望你回答 $Q$ 个查询。在每个查询中，他给你两个正整数 $l$ 和 $r$，其中 $l \leq r$，他希望知道有多少对可能的事件 $(i,j)$ 满足 $l \leq i < j \leq r$。

## 说明/提示

- $2 \leq N \leq 7 \cdot 10^5$
- $1 \leq Q \leq 7 \cdot 10^5$
- $0 \leq M \leq 20$
- 对于每个有效的 $i$，$1 \le f_i \le N$
- $1 \le u, v \le N$
- 输入描述的图是无环的
- $1 \le l \le r \le N$

### 子任务

**子任务 #1 (17 分):** $N,Q \le 3 \cdot 10^5$

**子任务 #2 (83 分):** 原始约束条件。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
8 2
1 2 5 1 4 3 3
2 4
4 7
3
4 6
5 7
1 8```

### 输出

```
2
2
18```

# 题解

## 作者：ppip (赞：2)

**不要写，跑不过莫队二次离线。**

假设 $n,q$ 同阶。

首先这个东西偏序逆序对，而逆序对归约矩乘，所以没有 polylog 做法。

首先我们注意到每个点能到达的点集能被拆成最多 $m+1$ 个子树，且这些子树都是某条额外边的出点或者自己。所以我们预处理一下每个点指向的点集即可。这部分可以做到 $O(nm)$。

反图上的到达点集同理，可以被拆成最多 $m+1$ 条不交路径。

接下来序列分块就是套路了，直接参考[这个题](https://www.luogu.com.cn/problem/P5046)的做法即可。

有很多拆贡献的方法，随便讲一种。

预处理：

- 两两块之间的答案；
- 前 $i$ 个块内的点在正反图上分别到达点 $j$ 的次数；
- 每个块内前后缀和的答案。

查询的时候：

- 如果 $l,r$ 同块则可以拆成两个块内前缀相减，以及两个散块的之间的贡献；
- 如果不同块则拆成中间整块的答案，两个散块内部的答案，中间整块到两边散块的贡献，两边散块之间的贡献。

预处理各种平衡一下，使用差分能轻松做到 $O(nm+n\sqrt{n})$。发现我们只有两个散块之间的贡献没有做。

这个不能直接归并，因为左侧散点的到达点集是 DFS 序上 $m$ 个区间，归并复杂度 $O(m\sqrt{n})$。

但是注意到大多数区间都是指定的 $m$ 条额外边的出点的子树，所以可以预处理右侧散块里每个指定的子树里有多少点，以及左侧有多少点包含指定子树，乘起来即可。剩下每个点到达的点集就是它的子树本身，直接归并扫一遍即可。

注意到以上做法居然需要 $O(n\sqrt{n})$ 的空间，太不牛了，但是每次询问只需要调用 $O(1)$ 个值所以离线逐块处理一下即可 $O(nm)$ 空间。

总复杂度 $O(nm+n\sqrt{n})$。

---

## 作者：zesqwq (赞：2)

[AC record](https://www.luogu.com.cn/record/113898915)

# 题解成分

- 官方题解中的 'Node-to-Prefix' 的另一种清真做法；
- 如何卡常。

## 官方题解中的 'Node-to-Prefix' 的另一种清真做法

官方题解中给出了一种所谓的“暴力”做法，然而也有另一种做法。

我们令额外加入的 $m$ 条边 $(u, v)$ 中的 $u$ 为关键点，那么每个点可以用一个 `unsigned` 来存储是否能到达每一个关键点。

现在就变为了有一个 $\le m + 1$ 个点的点集，考虑按照 $\text{dfn}$ 排序，然后其路径并实际上就是每个点到根节点的路径减去相邻两点的 $\text{LCA}$ 到根节点的路径。

## 如何卡常

如何去除 $\text{MLE}$：

1. 手写内存池代替 vector；
2. 无用数组及时释放。

如何去除 $\text{TLE}$：

1. 在莫队处理 $\forall i \in [1, x - 1]$ 能到达到 $x$ 的数量和对端点进行扫描线的部分可以合并。
2. 注意减少莫队常数，比如左右端点直接跳的时候可以用前缀和将这部分的根号去掉。
3. 实在不行自己试试吧 >_<。

---

## 作者：w33z8kqrqk8zzzx33 (赞：2)

[English editorial](https://discuss.codechef.com/t/dre3hgf-editorial/84967)

# C2：【Dream and the Multiverse REMATCH】

~~C2 是原版本的题，然后铃给出了一个对 n=1e5 的更优秀做法，所以题给裂了。~~

首先考虑莫队二次离线，需要快速维护 $[1,i]$ 有多少节点可以到达 $x$ 和 $x$ 可以到达 $[1,i]$ 里多少节点。我们分开处理，第一部分叫 Prefix-to-Node，第二部分叫 Node-to-Prefix。

## Prefix-to-Node

考虑树的 dfs 序。在一个树上一个节点所能到达的节点可以被恰好一个 dfs 序的值域区间表示。推广到 DAG 上，用底层树的 dfs 序。这样，某个节点所能到达的节点由 $O(m)$ 个 dfs 序的值域区间表示。证明很简单：每一条额外边仅会最多多贡献一个区间对一个节点。有很多方法来高效对所有节点计算这些 $O(m)$ 个区间是什么。可以模仿树的 dfs 序区间，直接合并一个节点相邻的节点的所有区间并且用扫描线简化。

这些区间实际上应该看做子树，但是为了常数略微小一点看做区间也没问题。

## Node-to-Prefix

现在一个节点在 DAG 上的祖先仍然可以用 $O(m)$ 个区间表示，但是这些区间就不是 dfs 序上的区间，而是树上的一个路径。这个路径有特点：一个端点是另一个端点的祖先。对于一棵树这个路径就是当前点到根的路径。和 Prefix-to-Node 同样的扩展到 DAG 上，可以得到一个节点的祖先对应 $O(m)$ 个这样的路径的并，其中一个路径是这个节点到根的路径。从一个父亲到孩子节点只会增加对应进入孩子节点的额外边。于是孩子的集合可以先复制父亲的集合，然后再暴力添加进入这个节点的额外边的贡献。这里“暴力”指的从额外边的开头一直往上爬，一直爬到进入了一个被原来的路径已经包含的节点。这样复杂度为什么对？一个节点对复杂度产生的贡献就是它被暴力爬过几次，也就最多是从它开始能到达几个额外边。这最多是 $O(m)$，于是总共初始化复杂度是 $O(nm)$。

---

好了这个部分搞完了。于是我们现在需要快速实现：

1. 将某个节点染色。
2. 访问某个节点能到达多少被染色的节点，**或者** 访问多少被染色的节点能到达某个节点。

其中我们以上已经引入了将某个节点染色等价于对 $O(m)$ 个子树里的所有节点权值加 1 和对 $O(m)$ 条特殊路径里的所有节点权值加 1。（这两种权值独立。）

由于莫队二次离线的自然性质，第一个操作需要进行 $O(n)$ 次，第二操作要进行 $O(n\sqrt n)$ 次，其中这里默认 $q=O(n)$。我们以上已经定了子树加等价于对 dfs 序区间加。对一条从深往浅链的权值全加 1 可以看做链头加 -1，链尾加 1，单点询问变成子树询问。对链的部分再次转换一下，发现等价于对【链头的 dfs 序编号+1，链尾的 dfs 序编号】全部加 1，单点询问可以从对应子树 dfs 序区间搞出来答案。

问题将转换成做 $O(nm)$ 次区间加，做 $O(n\sqrt n)$ 次单点询问。直接分块是 $O(nm\sqrt n)$；直接线段树是 $O(n(m+\sqrt n)\log n)$。能做更好么？考虑更佳平衡 $O(nm)$ 和 $O(n\sqrt n)$。我们开 $B$ 层分块；这样修改的时间复杂度为 $O(Bn^{1/B})$，询问的复杂度为 $O(B)$。仔细分析最佳 $B$ 得到最终复杂度：

$$O(\frac{n\log n\sqrt n}{W(\sqrt n/m)})$$

实际上取 $B=3$ 挺优秀。

---


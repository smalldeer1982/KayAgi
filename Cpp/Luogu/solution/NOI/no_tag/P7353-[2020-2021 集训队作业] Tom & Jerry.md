# [2020-2021 集训队作业] Tom & Jerry

## 题目背景

自选题 by ix35

## 题目描述

给定一张包含 $n$ 个顶点和 $m$ 条边的 **无向连通图**，Tom 和 Jerry 在图上进行了 $q$ 次追逐游戏。

在第 $i$ 次游戏中，Tom 一开始位于顶点 $a_i$，而 Jerry 一开始位于顶点 $b_i$（双方任何时候都知道自己和对方的位置），追逐规则如下：

- Jerry 和 Tom 交替行动，Jerry 先行动。

- Jerry 每次行动可以通过无向图中的 **任意多条边**（可以选择不移动），但是在移动过程中不能经过 Tom 当前所在的结点，否则就会被抓住。

- Tom 每次行动只能通过无向图中的 **至多一条边**（可以选择不移动）。

- 如果 Tom 在一次行动后到达了 Jerry 的位置，那么 Tom 胜利。

Tom 尽量想要胜利，而 Jerry 会尽量阻止 Tom 胜利。

现在你需要对于每一局游戏，求出 Tom 是否一定能在有限次行动内获胜。

## 说明/提示

【样例解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/gg8gk6fw.png)

第一组询问中，$a_1=6,\ b_1=4$，则 Jerry 先走到 $2$ 处，此后每一回合，若 Tom 行动完后与 Jerry 相邻，Jerry 只需要移动到环 $[1,2,3,4]$ 中与 Tom 不相邻的那个点，可保证 Tom 不胜。

第二组询问中，$a_2=4,\ b_2=5$，无论 Jerry 如何行动，Tom 只需走到 $6$ 处，此后 Jerry 可能在 $\{5,7,8\}$，无论如何 Tom 都可以一步追到。

第三组询问中，$a_3=5,\ b_3=7$，则 Jerry 按照第一组询问中的策略即可使得 Tom 无法获胜。

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\leq n,m,q\leq 10^5$，$1\leq x,y,a,b\leq n$，$a_i\ne b_i$。

保证给出的无向图连通，且不含重边和自环。

$\text{Subtask 1}\ (10\%)$： $n,m,q\leq 10$。

$\text{Subtask 2}\ (16\%)$： $n,m,q\leq 100$。

$\text{Subtask 3}\ (24\%)$： $n,m,q\leq 1000$。

$\text{Subtask 4}\ (16\%)$： $m=n$。

$\text{Subtask 5}\ (34\%)$： 无特殊限制。

## 样例 #1

### 输入

```
8 10 3
1 2
2 3
3 4
4 1
6 4
5 6
6 7
8 7
8 5
8 6
6 4
4 5
5 7
```

### 输出

```
No
Yes
No
```

# 题解

## 作者：Leasier (赞：10)

看到“不能经过 Tom 所在的点”，不难想到割点。

对于 Tom 而言，首先可以注意到一种简单的策略：

- 逼着 Jerry 往某个子连通块里走。

现在来具体地描述这个“逼”的过程。

我们发现在这种策略下，当 Tom 获胜时，Tom 初始一定处于一个割点，每一步都会走进一个让 Jerry 活动范围更小的割点，从而 Jerry 被迫在一个更小的子连通块内走，最终被抓到。

考虑建出原图的圆方树，现在把 $a$ 提起来当圆方树的根，设 $b$ 在换根后的树上位于 $a$ 的 $b'$ 子树，则 $b$ 一开始只能在 $b'$ 子树内的圆点内活动。

现在 Tom 想要把当前位置 $p$ 移到一个 $q$，满足：

- $q$ 为割点或可以在 $q$ 抓到 Jerry。
- 圆方树上 $q$ 在 $p$ 子树中。
- 原图上 $p, q$ 有边。

这个几个条件同时也告诉我们 $q$ 一定是 $p$ **所在的某个点双的除 $p$ 以外的点**（称此为条件 $P$），这样才可能满足距离为 $1$。

注意到 Jerry 在第一次操作时可以在任何一个符合条件的点，所以 $\forall u \in subtree_{b'}$，都需要满足在按照上面的方式操作后，存在一种方案使得 Tom 最终 $p = u$。

也就是说，$\forall p \in subtree_{b'}$ 且 $q$ 满足条件 $P$，$p, q$ 在原图上有边。

我们肯定不可能把每个 $a$ 拿出来当根讨论，于是考虑换根 dp，预处理 $f_u, g_u$ 表示以 $1$ 为根时内 / 外子树是否满足上述条件，回答询问时讨论一下 $b$ 是否在 $a$ 的子树中即可。

但因为 $a$ 一开始可能不是割点，一开始 Jerry 可以处在一个任意点。

注意到此时 Tom 并非必败，因为此时 Tom 还有另一种策略：

- 走到一个点 $r$，满足以 $r$ 为根，无论 Jerry 位于哪个非 $r$ 点，都可以按照上述方式被抓到。

在换根 dp 结束后看一下有没有点 $u$ 满足 $f_u = g_u = \operatorname{true}$，如果有则答案为全 `Yes`，否则该策略一定不可行。

综上，时间复杂度为 $O(m + (n + q) \log n)$。

代码：
```cpp
#include <iostream>
#include <set>
#include <stack>
#include <cmath>

using namespace std;

typedef struct {
	int nxt;
	int end;
} Edge;

int cnt1 = 0, cnt2 = 0;
int head1[100007], dfn[100007], low[100007], head2[200007], depth[200007], in[200007], fa[200007][27], out[200007];
bool vis[100007], dp1[200007], dp2[200007];
Edge edge1[200007], edge2[400007];
set<int> se1;
stack<int> stk;
set<int> se2[100007];

inline void add_edge1(int start, int end){
	cnt1++;
	edge1[cnt1].nxt = head1[start];
	head1[start] = cnt1;
	edge1[cnt1].end = end;
}

inline void add_edge2(int start, int end){
	cnt2++;
	edge2[cnt2].nxt = head2[start];
	head2[start] = cnt2;
	edge2[cnt2].end = end;
}

void tarjan(int u, int father, int n, int &id, int &bcc_cnt){
	int son_cnt = 0;
	dfn[u] = low[u] = ++id;
	vis[u] = true;
	stk.push(u);
	for (register int i = head1[u]; i != 0; i = edge1[i].nxt){
		int x = edge1[i].end;
		if (!vis[x]){
			son_cnt++;
			tarjan(x, u, n, id, bcc_cnt);
			low[u] = min(low[u], low[x]);
			if (low[x] >= dfn[u]){
				int pos = ++bcc_cnt + n, cur;
				add_edge2(pos, u);
				add_edge2(u, pos);
				do {
					cur = stk.top();
					stk.pop();
					add_edge2(pos, cur);
					add_edge2(cur, pos);
				} while (cur != x);
			}
		} else {
			low[u] = min(low[u], dfn[x]);
		}
	}
	if (father == 0 && son_cnt == 0){
		int pos = ++bcc_cnt + n;
		add_edge2(pos, u);
		add_edge2(u, pos);
	}
}

void dfs1(int u, int father, int n, int &id){
	int t;
	depth[u] = depth[father] + 1;
	t = log2(depth[u]);
	in[u] = ++id;
	fa[u][0] = father;
	for (register int i = 1; i <= t; i++){
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	dp1[u] = true;
	for (register int i = head2[u]; i != 0; i = edge2[i].nxt){
		int x = edge2[i].end;
		if (x != father){
			dfs1(x, u, n, id);
			dp1[u] &= dp1[x];
			if (u > n) dp1[u] &= se2[father].count(x);
		}
	}
	out[u] = id;
}

void dfs2(int u, int n){
	int cnt1 = 0, size;
	se1.clear();
	if (fa[u][0] != 0) se1.insert(fa[u][0]);
	for (register int i = head2[u]; i != 0; i = edge2[i].nxt){
		int x = edge2[i].end;
		if (x != fa[u][0]){
			se1.insert(x);
			if (!dp1[x]) cnt1++;
		}
	}
	size = se1.size();
	for (register int i = head2[u]; i != 0; i = edge2[i].nxt){
		int x = edge2[i].end;
		if (x != fa[u][0]){
			dp2[x] = dp2[u] && (cnt1 == 0 || (cnt1 == 1 && !dp1[x]));
			if (u > n){
				int cnt2 = 0;
				for (register int j = head1[x]; j != 0; j = edge1[j].nxt){
					if (se1.count(edge1[j].end)) cnt2++;
				}
				dp2[x] &= cnt2 + 1 == size;
			}
		}
	}
	for (register int i = head2[u]; i != 0; i = edge2[i].nxt){
		int x = edge2[i].end;
		if (x != fa[u][0]) dfs2(x, n);
	}
}

inline bool check(int u, int v){
	return in[u] <= in[v] && in[v] <= out[u];
}

inline int jump(int u, int k){
	for (register int i = 0; (1 << i) <= k; i++){
		if (k >> i & 1) u = fa[u][i];
	}
	return u;
}

int main(){
	int n, m, q, dfn_id1 = 0, bcc_cnt = 0, dfn_id2 = 0;
	cin >> n >> m >> q;
	for (register int i = 1; i <= m; i++){
		int x, y;
		cin >> x >> y;
		se2[x].insert(y);
		se2[y].insert(x);
		add_edge1(x, y);
		add_edge1(y, x);
	}
	tarjan(1, 0, n, dfn_id1, bcc_cnt);
	dfs1(1, 0, n, dfn_id2);
	dp2[1] = true;
	dfs2(1, n);
	for (register int i = 1; i <= n; i++){
		if (dp1[i] && dp2[i]){
			for (register int j = 1; j <= q; j++){
				cout << "Yes" << endl;
			}
			return 0;
		}
	}
	for (register int i = 1; i <= q; i++){
		int a, b;
		cin >> a >> b;
		if (!check(a, b)){
			if (dp2[a]){
				cout << "Yes" << endl;
			} else {
				cout << "No" << endl;
			}
		} else if (dp1[jump(b, depth[b] - depth[a] - 1)]){
			cout << "Yes" << endl;
		} else {
			cout << "No" << endl;
		}
	}
	return 0;
}
```

---

## 作者：Hoks (赞：6)

## 前言

折磨题目，这个正确性是太难搞了，$1000$ 个人写 dp 有 $1000$ 种写法，再加上数据难造，根本没法判断正确性。

神仙模拟赛 T4，场上想了 $2h$ 结果漏了一种最难判的情况（虽说幽默数据好像不判那个情况原本也能过）。

花了大概 $2$ 天写完的题解，希望能更简明点。

## 思路分析

考虑何时 Tom 会输。

首先有最显然的一个想法：

> 只要 Jerry 跑进了一个非 $3$ 元环里，那 Tom 就输了。
>
> 因为 $3$ 元环中的点都只需要 $1$ 步就可以互相到达。
>
> 而对于 $4$ 元及以上的环：$\forall x,\exist dis(x,y)\ge2$。

但其实这个显然是错的，观察样例便可以得到。

样例图片中，即使 Jerry 在 $5,6,7,8$ 这四个点组成的环里，仍然会被抓住。

再仔细观察，我们会发现看似 $5\rightarrow6\rightarrow7\rightarrow8$ 是一个 $4$ 元环，应该对任意一个点 $x$ 都存在点 $y$ 需要 $x$ 走两步到 $y$。

但其实这个 $4$ 元环是由好几个 $3$ 元环拼凑而成的，所以并不满足上面的那个性质。

我们考虑何时一个环是可以完全拆分为 $3$ 元环的。

类似于小学中学的把一个 $n$ 边形划分为 $n-2$ 个三角形，只需要满足**存在**一个点 $x$ 满足他向这个环的其他所有点连边即可。

我们定义不可被拆分的环叫做**最小环**，那么就可以得到一个 Tom 无法获胜的情况：

> Jerry 可以跑进一个非 $3$ 元环的最小环里，那 Tom 就输了。

于是模拟赛场中的我就以为已经充要了，直接对这个条件进行维护。

我们考虑对于一组询问 $x,y$，先断开 $x$ 这个点，那么 $y$ 就在一个连通块里。

显然的是，如果 $y$ 的这个连通块里有**非 $3$ 元环的最小环**，Tom 就输了，否则 Tom 就赢了。

实现而言，我们考虑先对原图建出**圆方树**，那么断开 $x$ 这个点后，$y$ 就有两种可能性：

1. 在 $x$ 的子树里。
2. 不在 $x$ 的子树里。

做两次换根 dp，定义 $f_i$ 表示 $i$ 的子树里存在非 $3$ 元环的最小环，$g_i$ 表示**非** $i$ 的子树里存在非 $3$ 元环的最小环。

对于 $1$ 情况，直接找到 $x\rightarrow y$ 路径上的第一个点 $z$，查询 $f_z$ 的值即可。

对于 $2$ 情况，直接查询 $g_x$ 即可，而这里的 $f,g$ 转移也较为简单，就不再赘述，有兴趣的读者可以尝试想想。

**但是**这显然是错误的，因为数据难造的原因，可以获得 $100$ 分的好成绩。

~~不过有的人把点双写成了缩点，就难以评价了。~~

这样的 Jerry 还是太傻了，其实他还有两种获胜方式。

在我们刚刚的定义中，**非最小环**的环一定不行，但真的是这样的吗。

考虑下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/s5ovm1pg.png)

在这图中，按我们的判断，Tom 应该是必胜的，因为不存在**非 $3$ 元环的最小环**。

设 Tom 最开始在点 $4$，而 jerry 在点 $5$。

那么我们的 Jerry 可以先跑到 $7$ 号点，等 Tom 过来。

当 Tom 走到点 $5$ 或 $6$ 时，Jerry 就可以绕过 Tom 跑到点 $1$。

因为这张图是上下对称的，所以这个过程是可以无限循环的。

此时我们会发现，显然是 Tom 输了，但是我们并不能判出来。

考虑下这种特殊的点双应该怎么判断。

下面我们称这种点双为**特殊点双**：即代表上面那种情况。

归纳一下这种情况的特点，我们就发现是否为**特殊点双**还与 $x$ 的位置有关。

最后总结出来的特点即为如下几点：

> 不是最小环，能被划分为若干三元环。
>
> Tom 走到这个点双的第一个点 $x$ 不能与其他点都有连边。

重点关注的是第二行话，这句话就意味着，当 Tom 第一次达到这个点双的时候，Jerry 还可以在这个点双里等 Tom 再走一步。

那么只要 Tom 走了一步，根据点双的性质，Jerry 就可以走到 $x$ 这个点，接着就可以跑出去逃出 Tom 的封锁。

只要在初始连通块（即为 Jerry 最初所在的连通块）外面，还能找到一个这样的**特殊点双**或是第一种情况中的点双，Tom 就又输了。

真的是这样的吗？

上文中我们也发现了**特殊点双**的判定和 Tom 的位置有关，那有没有可能 Tom 存在一个 bug 点使得此时不存在**特殊点双**。

答案是有可能的，有兴趣的读者可以尝试手动构造一下构造出这种情况。

所以综上我们可以得到，Tom 输的情况是：

> Jerry 可以跑进一个非 $3$ 元环的最小环里。
>
> Jerry 可以跑进一个**特殊点双**且在初始连通块外面，还能找到一个**特殊点双**或是非 $3$ 元环的最小环。
>
> 不存在非 $3$ 元环的最小环的情况下，Tom 不存在一个 bug 点使得不存在**特殊点双**。

那么 Tom 赢的情况就是恰好相反。

此时我们来尝试证明，这些情况对于胜负的判断，是不是充要的。

必要性，也就是这些情况下 Tom 必输，比较显然，便不再给出证明。

考虑证明充分性，即 Tom 输的情况肯定是这些情况。

考虑反证法，假设 Tom 在不是这些情况的情况下还输了。

那么首先 Jerry 所在连通块里不存在非 $3$ 元环的最小环。

接下来有三种情况：

1. 不存在非 $3$ 元环的最小环，且 Tom 存在一个 bug 点。
2. 存在非 $3$ 元环的最小环，但 Jerry 所在连通块中不存在**特殊点双**。
3. Jerry 所在连通块中存在**特殊点双**，但连通块外找不到一个**特殊点双**或是非 $3$ 元环的最小环。

对于情况 $1$，Tom 只要走到 bug 点后就变成了情况 $2$。

对于情况 $2$，我们只需要考虑 Jerry 能不能跑出初始连通块。

因为 Jerry 找不到**特殊点双**，所以当 Tom 走到 Jerry 所在点双时，Jerry 必须逃到**另一个点双**里去。

因为是逃到了**另一个点双**里，所以当 Tom 走到 Jerry 这个点双时，不存在一条路径使得 Jerry 可以绕过 Tom 跑到 Tom 来时的那个点双里。

具体的，也就是当 Tom 从 $x\rightarrow y$ 时，$y$ 和 Jerry 所在点 $z$ 在同一点双，而 $x,y$ 不在同一点双。

因为 $x,y$ 不在同一点双，所以 $x\rightarrow y$ 是连通这两个点双的唯一路径。

$z$ 可以通过多种路径绕到 $y$，但是无法不路过 $y$ 到 $x$。

若 $z$ 可以做到 $z\rightarrow y'\rightarrow x$，其中 $y',z$ 在同一个点双里，则 $x$ 所在点双和 $z$ 所在点双有两条边：$y'\rightarrow x$ 和 $y\rightarrow x$。

也就说明 $x,y,y',z$ 都在同一个点双，这与 $x,y$ 不在同一个点双的题设矛盾了，所以 Jerry 是跑不出初始连通块的，也就是必死。

对于情况 $3$，就算 Jerry 能绕到初始连通块外面，仍然无法找到一个位置再跑出来/和 Tom 绕圈，终究会被抓住。  

所以我们证明了充分性，结合上面显然的必要性，这些情况用来判定胜负是充要的。

接着就是考虑怎么用代码实现这些判断了。

因为 Tom 输肉眼可见的难判断，所以我们考虑如何判断 Tom 胜。

其实就是把上面的情况反一反。

但这样还是太冗长了，我们考虑定义 $p(x,y)$ 表示如果 Tom 在点 $x$，Jerry 在点 $y$，$p(x,y)=1$ 则表示 Tom 可以抓住 Jerry，否则就是不行。

类似于上面错误做法中的延续，我们考虑处理出子树中和非子树中两种情况。

首先建出**圆方树**，接着考虑定义 $f_i$ 表示如果 Tom 在点 $i$，$f_i=1$ 即表示 Tom 能抓住子树中的 Jerry，形式化的写就是：

$\forall j\in son_i,p(i,j)=1$，这里的 $son_i$ 表示 $i$ 的子树点集。

但是 Tom 只能在圆点上移动，显然不能走到我们建出来的方点上。

所以对于方点 $i$，定义 $f_i=f_{fa_i}$，其中 $fa_i$ 表示点 $i$ 的父亲。

这点比较好理解，因为方点表示的是一个点双，而除了父亲圆点外其他点双里的点都是方点的圆儿子，也就意味着，方点的父亲圆点的子树，就包含了整个点双的圆点，直接取这个值即可。

转移也比较简单，我们还是对圆方点进行讨论（$son_u$ 表示 $u$ 的儿子点集）：

1. 圆点，只要他的所有儿子的子树都可行即可，也就是 $\forall v\in son_u,f_v=1$。
2. 方点，此时还要满足他的父亲圆点到点双里的任意一个点也可以抓住，也就是 $\forall v\in son_u,f_v=1\&p(fa_u,v)=1$。

那这个时候我们就可以处理掉 $y$ 在 $x$ 的子树里的情况了，直接把 $x\rightarrow y$ 的第一个点 $z$ 拿出来查询下 $f_z=1$ 则说明 Tom 赢了，否则就是输了。

接着来考虑剩下的一种情况，也是叉掉了一众题解的情况。

当 $y$ 不在 $x$ 子树里时，我们考虑定义 $g_i=1$ 表示 Tom 在点 $i$ 可以抓住在非 $i$ 子树里的 Jerry，形式化的写就是：

$\forall j\notin son_i,p(i,j)=1$，这里的 $son_i$ 表示 $i$ 的子树点集。

这个转移比起 $f_i$ 就比较烦了，还是把圆点和方点分开考虑：

1. 圆点，此时要满足 $g_{fa_i}=1$，而且兄弟子树的 $f_i=1$ 且在这个父亲方点的点双里，这个点要和其他所有点相邻。
2. 方点，此时要满足所有方点兄弟的 $f_i=1$，初始值为 $g_i=1$，用于给圆点转移。

这里解释下什么是 $2$ 中的用于给圆点转移，因为对于一个圆点 $i$，$fa_{fa_i}$ 的这个圆点也和 $i$ 实在同一个点双里的。

但我们不能直接判断 $g_{fa_{fa_i}}=1$，因为这个点还有其他的方儿子，而其他方儿子的圆儿子也和这个点是在同一个点双里，所以我们要在方点处也转移一次判掉其他兄弟点双。

这样的话正确性就应该保证了，复杂度也是保证的，因为每个点只会遍历常数次边集。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10,M=128,INF=0x3f3f3f3f3f3f3f3f,mod=998244353;
int n,m,q,in[N],f[N],g[N];vector<int>e[N],eg[N];map<int,int>mp[N];vector<pair<int,int>>d[N];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
inline void add(int u,int v,vector<int>e[]){e[u].emplace_back(v),e[v].emplace_back(u);}
namespace Tarjan
{
    int tot,cnt,dt,dfn[N],low[N],sd[N],bl[N];
    inline void tarjan(int u)
    {
        dfn[u]=low[u]=++tot;sd[++dt]=u;
        for(auto v:eg[u])
            if(!dfn[v])
            {
                tarjan(v),low[u]=min(low[u],low[v]);
                if(low[v]==dfn[u])
                {
                    add(++cnt,u,e);
                    while(1)
                    {
                        int x=sd[dt--];add(cnt,x,e);
                        if(x==v) break;
                    }
                }
            }
            else low[u]=min(low[u],dfn[v]);

    }
}
using namespace Tarjan;
namespace tree_decomposition
{
    int fa[N],son[N],si[N],dep[N],top[N];
    inline void dfs1(int u,int ff)
    {
        fa[u]=ff,si[u]=1,dep[u]=dep[ff]+1;f[u]=1;
        for(auto v:e[u]) if(v!=ff)
        {
            dfs1(v,u);si[u]+=si[v];f[u]&=f[v];
            if(u>n&&mp[ff].find(v)==mp[ff].end()) f[u]=0;
            if(si[son[u]]<si[v]) son[u]=v;
        }
    }
    inline void dfs2(int u,int topf)
    {
        int s=0,sf=0;if(!g[u]){for(auto v:e[u]) if(v!=fa[u]) g[v]=0;goto play;}
        if(u<=n)
        {
            s=0;for(auto v:e[u]) if(v!=fa[u]) sf+=f[v],s++;
            for(auto v:e[u]) if(v!=fa[u]&&sf-f[v]!=s-1) g[v]=0;goto play;
        }for(auto v:e[u]) if(v!=fa[u]) s++,sf+=f[v],in[v]=0;
        for(auto i:d[u]) in[i.first]++,in[i.second]++;
        for(auto y:e[u]) if(in[y]==s&&sf-f[y]==s-1) g[y]=1;play:;
        top[u]=topf;if(son[u]) dfs2(son[u],topf);
        for(auto v:e[u])
        {
            if(v==fa[u]||v==son[u]) continue;
            dfs2(v,v);
        }
    }
    inline int LCA(int x,int y)
    {
        while(top[x]!=top[y])
        {
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            x=fa[top[x]];
        }
        return dep[x]<dep[y]?x:y;
    }
}
using namespace tree_decomposition;
signed main()
{
    cnt=n=read();m=read(),q=read();for(int i=1,u,v;i<=m;i++) u=read(),v=read(),mp[u][v]=mp[v][u]=1,add(u,v,eg);
    tarjan(1);for(int i=n+1;i<=cnt;i++) g[i]=1;dfs1(1,0);
    for(int u=1;u<=n;u++) for(auto v:eg[u]) if(v>u) d[dep[u]>dep[v]?fa[u]:fa[v]].emplace_back(u,v);
    g[1]=1,dfs2(1,1);for(int i=1;i<=n;i++) if(f[i]&g[i]){while(q--) put("Yes\n");goto genshin;}
    for(int i=1,x,y,lca;i<=q;i++)
    {
        x=read(),y=read(),lca=LCA(x,y);
        if(lca!=x) put(g[x]?"Yes\n":"No\n");
        else
        {
            int xx=LCA(son[x],y);
            if(xx!=son[x]){xx=y;while(fa[top[xx]]!=x) xx=fa[top[xx]];xx=top[xx];}
            put(f[xx]?"Yes\n":"No\n");
        }
    }
    genshin:;flush();return 0;
}
```

---

## 作者：_ANIG_ (赞：4)

[传送门](https://www.luogu.com.cn/problem/P7353)

首先考虑两人的策略是什么。

Jerry 的行动较为复杂，不好考虑策略。

Tom 行动比较简单，不妨从 Tom 的策略入手。

整体感受一下，Tom 为了抓住 Jerry，所以会朝着 Jerry 的方向一直走。

建出圆方树，在树上考虑。

若 Tom 当前能走到一个距离 Jerry 更近的点，则一定往这个方向走，否则，Tom 在不会远离 Jerry 的前提下走向度数最大的点，这是为了处理 Jerry 始终与 Tom 距离为 $1$ 的情况。

所以可以让 Tom 使用如下策略：若可以接近 Jerry，则往 Jerry 的方向走。否则走向不会远离 Jerry 的度数最大的点。

考虑图论建模，用点 $(a,b)$ 表示 Tom 在 $a$，Jerry 在 $b$，轮到 Jerry 这个状态。

$x$ 到 $y$ 有边表示状态为 $x$ 时，Jerry 存在一种方案，使得 Tom 按照上述策略走一步后状态为 $y$。

在新图上跑 SCC，则 Tom 能赢的充要条件为当前状态无法到达一个大小大于 $1$ 的 SCC。

可以发现，很多状态是可以合并的。

由于 Jerry 可以走任意步，所以不妨设 $(x,y)$ 表示 Tom 在 $x$，Jerry 可以到达以 $x$ 为根时 $y$ 的子树内的任意点。

此时总点数为 $O(n)$，边数 $O(n^2)$，但很难卡满。

瓶颈在于给一个点除掉一个儿子后的其他儿子连边。

可以使用经典技巧，新建虚点表示给前后缀连边，这样边数 $O(n)$，总复杂度 $O((n+q)\log n)$。

使用哈希表和长剖求 k 级祖先等精细实现可能可以做到 $O(n+q)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,m,qs,dfn[N],dd[N],rd[N],f[N],siz[N],bh[N],sms,cnt,low[N],eds[N],idx,tot,fa[N][20],mk[N],dep[N];
vector<int>e[N],st,p[N],g[N],b[N],to[N];
unordered_map<int,int>dy[N],wz[N],dds[N];
vector<int>qz[N],hz[N];
deque<int>q;
void tarjan(int x){
    st.push_back(x);
	dfn[x]=low[x]=++idx;
	for(auto c:e[x]){
		if(!dfn[c]){
			tarjan(c);
			low[x]=min(low[x],low[c]);
			if(dfn[x]<=low[c]){
				int y;cnt++;
				do{
					y=st.back();
					st.pop_back();
					p[cnt].push_back(y);
					p[y].push_back(cnt);
				}while(y!=c);
				p[cnt].push_back(x);
				p[x].push_back(cnt);
			}
		}else low[x]=min(low[x],dfn[c]);
	}
}
void dfs1(int x){
	mk[x]=1;dfn[x]=++idx;
	for(int i=1;i<=19;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(auto c:p[x]){
		if(mk[c])continue;
		fa[c][0]=x;
		dep[c]=dep[x]+1;
		dfs1(c);
	}
	eds[x]=idx;
	mk[x]=0;
}
void dfs2(int x){
	dd[x]=low[x]=++idx;
	st.push_back(x);
	mk[x]=1;
	for(auto c:b[x]){
		if(!dd[c]){
			dfs2(c);
			low[x]=min(low[x],low[c]);
		}else if(mk[c])low[x]=min(low[x],dd[c]);
	}
	if(dd[x]==low[x]){
		int y;sms++;
		do{
			y=st.back();
			st.pop_back();
			bh[y]=sms;mk[y]=0;
			siz[sms]++;
		}while(y!=x);
	}
}
int gm(int a,int b){
	if(fa[a][0]==fa[b][0])return fa[a][0];
	if(fa[a][1]==b)return fa[a][0];
	return fa[b][0];
}
int up(int x,int k){
	while(k){
		x=fa[x][__lg(k&-k)];
		k^=k&-k;
	}
	return x;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>qs;
	cnt=n;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	tarjan(1);
	for(int i=1;i<=n;i++){
		for(auto c:p[i])dy[i][c]=++tot;
		qz[i].resize(p[i].size());
		hz[i].resize(p[i].size());
		for(int j=0;j<p[i].size();j++){
			int c=p[i][j];
			wz[i][c]=j;
			qz[i][j]=++tot;
			hz[i][j]=++tot;
			if(j)b[qz[i][j]].push_back(qz[i][j-1]);
			b[qz[i][j]].push_back(dy[i][c]);
			b[hz[i][j]].push_back(dy[i][c]);
		}
		for(int j=0;j+1<p[i].size();j++)b[hz[i][j]].push_back(hz[i][j+1]);
	}
	idx=0;
	dfs1(1);
	for(int i=1;i<=n;i++){
		for(auto c:e[i]){
			int tmp=gm(i,c);
			dds[i][tmp]++;
		}
	}
	for(int i=1;i<=n;i++){
		for(auto c:e[i]){
			int tmp=gm(i,c);
			g[tmp].push_back(c);
		}
		for(auto c:p[i]){
			sort(g[c].begin(),g[c].end(),[&](int a,int b){
				return dds[a][c]>dds[b][c];
			});
			int tmp=dy[i][c];
			for(auto d:g[c]){
				int k=wz[d][c];
				if(k)b[tmp].push_back(qz[d][k-1]);
				if(k+1<p[d].size())b[tmp].push_back(hz[d][k+1]);
			}
			if(g[c].size()<p[c].size()-1){
				b[tmp].push_back(dy[g[c][0]][c]);
			}
			g[c].clear();
		}
	}
	idx=0;
	for(int i=1;i<=tot;i++)if(!dd[i])dfs2(i);
	for(int i=1;i<=tot;i++){
		for(auto c:b[i]){
			if(bh[i]==bh[c])continue;
			to[bh[c]].push_back(bh[i]);
			rd[bh[i]]++;
		} 
		if(siz[i]>1)f[i]=1;
	}
	for(int i=1;i<=tot;i++)if(!rd[i])q.push_back(i);
	while(q.size()){
		int x=q.front();
		q.pop_front();
		for(auto c:to[x]){
			rd[c]--;
			f[c]|=f[x];
			if(!rd[c])q.push_back(c);
		}
	}
	while(qs--){
		int a,b;
		cin>>a>>b;
		if(dfn[b]>=dfn[a]&&dfn[b]<=eds[a]){
			b=up(b,dep[b]-dep[a]-1);
		}else{
			b=fa[a][0];
		}
		if(f[bh[dy[a][b]]])cout<<"No\n";
		else cout<<"Yes\n";
	}
} 
```

---

## 作者：yukimianyan (赞：3)

由于要求 Jerry 的路径不能与 Tom 的位置重叠，这里就蕴含了一种割点的想法，考虑建圆方树。

首先可以发现，如果一个圆点能一步到达它相邻某个方点的点双中所有点，Tom 一旦站上去这个点，如果 Jerry 逃不出这个点双，Jerry 就会被吃；**如果没有这样的点，Jerry 一直待在这个点双里，Jerry 就赢了**。可以发现这种点异常的关键，不如先取个名字，叫作一步杀点。

假如说 Jerry 待在一个点双里面，Tom 来的方向**到达这个点双的第一个点无法一步杀**，Jerry 要躲在 Tom 到的第一个点一步到不了的点。当 Tom 进入这个点双的时候，Jerry 就可以开始考虑他应该逃向何处。可以发现 **Jerry 实际上整张图都可以去**，分两种情况，如果要经过 Tom 所在的点，那么让 Tom 先走一步，然后 Jerry 逃走；如果不经过 Tom 所在点，Jerry 直接跑就可以了。

但是一直跑下去也不是一个办法，我们需要找一种稳定的策略。可以发现核心就在于 Tom 来的方向**到达这个点双的第一个点无法一步杀**，假如我们找到两个点双，假如它们对应的方点 $x, y$ 之间的路径 $x- u- \cdots- v- y$ 上，$u$ 无法一步杀 $x$，$v$ 无法一步杀 $y$，那么 Jerry 在这两个点双之间来回奔跑就行了。**只要一开始 Jerry 到达这对点双的一端，Jerry 就赢了。**

---

总结：如果一个圆点不能一步到达它相邻某个方点的点双中所有点，那么将这条边定向为圆点到方点。我们仔细分讨一下，就会发现：

1. 如果有两个方点 $x, y$，它们之间的路径形如 $x- u- \cdots- v- y$，如果发现 $u\to x$ 和 $v\to y$ 这两条边被定向了，那么标记 $(x, y)$ 为好的点对。询问 $a, b$ 时，删去 $a$，若有一个好的点对的其中一端在 $b$ 所在连通块中，那么 Jerry 就获胜了（Jerry 可以在这两个方点中来回横跳）。
2. 还有一种情况，如果一个方点上没有点定向到它，而同时 Jerry 一开始可以到达这个方点，那么 Jerry 也获胜了。

可以证明这个和 ix35 的结论是等价的，过程就不写了。至此可以平方完成，然后就用其它技术例如树上倍增之类的优化一下就可以了，后面的部分一点都不难，就不写了。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
#ifdef LOCAL
#define debug(...) fprintf(stderr, ##__VA_ARGS__)
#else
#define endl "\n"
#define debug(...) void(0)
#endif
using LL = long long;
constexpr int N = 1e5 + 10;
int n, m, q, siz[N << 1];
bool upw[N << 1];
basic_string<int> g[N], tr[N << 1];
vector<pair<int, int>> E[N << 1];
int dfn[N << 1], tot, cnt;
void tarjan(int u) {/*{{{*/
  static int low[N], stk[N], top;
  static vector<pair<int, int>> Estk;
  low[u] = dfn[u] = ++cnt, stk[++top] = u;
  for (int v : g[u]) {
    auto e = make_pair(u, v);
    if (dfn[v]) {
      low[u] = min(low[u], dfn[v]);
      if (dfn[v] < dfn[u]) Estk.push_back(e);
    } else {
      Estk.push_back(e);
      tarjan(v), low[u] = min(low[u], low[v]);
      if (low[v] >= dfn[u]) {
        int p = ++tot;
        tr[p] += u, tr[u] += p;
        do tr[p] += stk[top], tr[stk[top]] += p; while (stk[top--] != v);
        auto lst = e;
        do E[p].push_back(lst = Estk.back()), Estk.pop_back(); while (lst != e);
      }
    }
  }
}/*}}}*/
auto getw(int u, int v) { return dfn[u] < dfn[v] ? upw[v] : upw[u]; }
int anc[18][N << 1], dep[N << 1];
void dfs1(int u, int fa) {
  anc[0][u] = fa;
  dfn[u] = ++cnt, siz[u] = 1, dep[u] = dep[fa] + 1;
  if (u > n) {
    auto bg = E[u].begin(), ed = E[u].end();
    for (auto& [x, y] : E[u]) if (x > y) swap(x, y);
    sort(bg, ed), E[u].erase(unique(bg, ed), ed);
    static int deg[N << 1];
    for (int v : tr[u]) deg[v] = 0;
    for (auto [x, y] : E[u]) deg[x] += 1, deg[y] += 1;
    for (int v : tr[u]) if (deg[v] != (int)tr[u].size() - 1) upw[v == fa ? u : v] = true;
  }
  for (int v : tr[u]) if (v != fa) dfs1(v, u), siz[u] += siz[v];
}
bool ok[N << 1];
pair<bool, vector<int>> dfs2(int u, int fa) {
  int cnt = 0;
  vector<vector<int>> vecs;
  for (int v : tr[u]) if (v != fa) {
    auto&& res = dfs2(v, u);
    if (v > n && getw(u, v)) res.second.push_back(v);
    cnt += (bool)(res.first || !res.second.empty());
    if (u > n && getw(u, v) && res.first) {
      ok[u] = true;
      for (int x : res.second) ok[x] = true;
      res.second.clear();
    }
    if (!res.second.empty()) vecs.push_back(res.second);
  }
  if (!cnt) return {false, {}};
  for (auto vc : vecs) for (int x : vc) ok[x] = true;
  return {true, {}};
}
int jump(int u, int k) {
  for (int j = 17; j >= 0; j--) if (k >> j & 1) u = anc[j][u];
  return u;
}
vector<int> vec;
bool cok(int l, int r) {
  auto it = lower_bound(vec.begin(), vec.end(), l);
  return it != vec.end() && *it <= r;
}
bool check(int x, int y) {
  if (dfn[x] <= dfn[y] && dfn[y] < dfn[x] + siz[x]) {
    y = jump(y, dep[y] - dep[x] - 1);
    return cok(dfn[y], dfn[y] + siz[y] - 1);
  } else {
    return cok(1, dfn[x] - 1) || cok(dfn[x] + siz[x], tot);
  }
}
int main() {
#ifndef LOCAL
  cin.tie(nullptr)->sync_with_stdio(false);
#endif
  cin >> n >> m >> q, tot = n;
  for (int i = 1, u, v; i <= m; i++) cin >> u >> v, g[u] += v, g[v] += u;
  for (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);
  cnt = 0, dfs1(1, 0);
  for (int i = n + 1; i <= tot; i++) {
    int cc = 0;
    for (int v : tr[i]) if (getw(i, v)) ++cc;
    if (cc == (int)tr[i].size()) ok[i] = true;
  }
  dfs2(1, 0);
  for (int i = 1; i <= tot; i++) if (ok[i]) vec.push_back(dfn[i]);
  sort(vec.begin(), vec.end());
  for (int j = 1; j <= 17; j++) {
    for (int i = 1; i <= tot; i++) anc[j][i] = anc[j - 1][anc[j - 1][i]];
  }
  while (q--) {
    int x, y;
    cin >> x >> y;
    cout << (!check(x, y) ? "Yes" : "No") << endl;
  }
  return 0;
}
```

---

## 作者：louisliang (赞：3)

[Problem Link](https://www.luogu.com.cn/problem/P7353)

思考 Tom 怎么获胜，有以下两种情况：

1. Tom 不断限制 Jerry 的活动范围，直到困死。
2. ~Tom 瞎走都可以赢~，有一个点能让 Tom 必胜。

对于（1），显然 Tom 需要不断走割点，由此想到圆方树。

![这里有个圆方树](https://cdn.luogu.com.cn/upload/image_hosting/zl9wapcp.png)

假设 Tom 在 $a$，Jerry 在 $d$，Jerry 能在 $a$ 的子树里任意走，所以 Tom 需要让 $a$ 能直接到达 $b$ 和 $c$，否则就输了。由此看出每当 Tom 在 $x$，Jerry 在 $x$ 的子树 $y$ 内时，$x$ 必须直接到达 $y$ 代表的点双连通分量中的任意点。此时 Tom 必胜。

对于（2），考虑能让 Tom 必胜的那个点 $x$，此时 Jerry 可以在任何地方（否则（1）就讨论过了）。Tom 必胜条件就是对于 $x$ 的任何子树，（1）的条件都成立。

若（1）（2）都不成立，Tom 必败。

接下来实现挺复杂的，我看其他 dalao 题解是没怎么看懂（我太蒻了），这里介绍一下我的写法。

![](https://cdn.luogu.com.cn/upload/image_hosting/hyr8tssr.png)

考虑如何表示 $x$ 能直接到达其点双连通分量的任意点。可以将这个状态放到 $x$ 到对应方点的边上。

枚举原图上的边，如 $(a,b)$，则在圆方树上让 $w(a,A)$ 和 $w(b,A)$ 各加一，这很好实现。$a$ 能直接到 $A$ 中任意点的充要条件是 $w(a,A) = sz_A-1$（$sz_A$ 是 $A$ 代表的点双连通分量的大小）。

必胜条件可以转化为：对于一个根为 $x$ 的子树中，所有 $u$ 是圆点，$v$ 是方点，$dep_u<dep_v$ 的边 $(u,v)$ （如下图红边）均合法。记不合法的边的**数量**为 $f_x$，满足条件且不合法的的边称为不合法边。

![](https://cdn.luogu.com.cn/upload/image_hosting/d0yxh8r6.png)

容易得到转移：$f_{y \in son_x} \rightarrow f_x$。对于不合法边 $(u,v)$，为代码更好写，让 $f_v \leftarrow f_v+1$。

考虑换根 dp，记 $g_x$ 为删去 $x$ 的子树（除了 $x$）剩下的子树中不合法边的**数量**。

转移为：$g_y=g_x+f_x-f_y+\Delta$。

$\Delta$ 的取值有：

- $(x,y)$ 有原来是不合法边，$\Delta=-1$。
- $(x,y)$ 现在是不合法边，$\Delta=1$。
- $(x,y)$ 啥都不是，$\Delta=0$。

最后用 lca 求出需要满足的子树 $x$，注意特判情况（2）。

默认 $n,m,q$ 同级，时间复杂度为 $O(n\log n)$。

update on 2024.10.3 修改代码中的部分错误

Code:

```cpp
#include<iostream>
#include<cstdlib>
#include<ctime>
#include<cassert>
#include<vector>
#include<cmath>
#include<cstring>
#include<set>
#include<queue>
#include<algorithm>
using namespace std;
const int N = 2e5 + 10, M = 2 * N;
int dfn[N], low[N], st[N], sz[N], f[N], g[N], tot;
int fa[N][21], dep[N], n, m, q, ifa[N];
vector <int> e[N];
int head[N], vi[M], ne[M], wi[M], htot;
vector < pair <int, int> > vt;
void addedge(int u, int v){
	ne[++htot] = head[u], vi[htot] = v, head[u] = htot;
}
void add(int u, int v){
	addedge(u, v);
	addedge(v, u);
}
void tarjin(int x){
	dfn[x] = low[x] = ++dfn[0], st[++st[0]] = x;
	for(int y : e[x]){
		if(!dfn[y]){
			tarjin(y);
			low[x] = min(low[x], low[y]);
			if(low[y] == dfn[x]){
				add(x, ++tot);
				sz[tot] = 2;
				while(st[st[0]] != y){
					sz[tot]++;
					add(st[st[0]--], tot);
				}
				add(st[st[0]--], tot);
			}
		}
		else
			low[x] = min(low[x], dfn[y]);
	}
}
void ad(int u, int v){
	while(u != v){
		if(dep[u] < dep[v])
			swap(u, v);
		wi[ifa[u]]++, u = fa[u][0];
	}
}
void dfs1(int x, int pfa){
	dep[x] = dep[pfa] + 1, fa[x][0] = pfa;
	for(int i = 1; i <= 20; i++)
		fa[x][i] = fa[fa[x][i - 1]][i - 1];
	for(int i = head[x]; i; i = ne[i]){
		int y = vi[i];
		if(y == pfa)
			continue;
		ifa[y] = i;
		dfs1(y, x);
	}
}
void dfs2(int x, int pfa, int op){
	f[x] = op;
	for(int i = head[x]; i; i = ne[i]){
		int y = vi[i];
		if(y == pfa)
			continue;
		dfs2(y, x, (x <= n && wi[i] != sz[y] - 1));
		f[x] += f[y];
	}
}
void dfs3(int x, int pfa){
	for(int i = head[x]; i; i = ne[i]){
		int y = vi[i];
		if(y == pfa)
			continue;
		int t = g[x] + f[x] - f[y];
		if(y <= n && wi[i] != sz[x] - 1)
			t++;
		if(x <= n && wi[i] != sz[y] - 1)
			t--;
		g[y] = t;
		dfs3(y, x);
	}
}
int lca(int x, int y){
	if(dep[x] < dep[y])
		swap(x, y);
	for(int i = 20; ~i; i--)
		if(dep[fa[x][i]] >= dep[y])
			x = fa[x][i];
	if(x == y)
		return x;
	for(int i = 20; ~i; i--)
		if(fa[x][i] != fa[y][i])
			x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}
bool check(int x, int y){
	if(lca(x, y) == x){
		int z = y;
		for(int i = 20; ~i; i--)
			if(dep[fa[z][i]] > dep[x])
				z = fa[z][i];
		return f[z] == 0;
	}
	return g[x] == 0;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m >> q;
	for(int i = 1, u, v; i <= m; i++){
		cin >> u >> v;
		vt.push_back(make_pair(u, v));
		e[u].push_back(v);
		e[v].push_back(u);
	}
	tot = n;
	tarjin(1);
	dfs1(1, 0);
	for(auto i : vt)
		ad(i.first, i.second);
	dfs2(1, 0, 0);
	dfs3(1, 0);
	bool flag = 0;
	for(int i = 1; i <= n; i++)
		flag |= (f[i] + g[i] == 0);
	while(q--){
		int a, b;
		cin >> a >> b;
		if(flag){
			cout << "Yes\n";
			continue;
		}
		cout << (check(a, b)? "Yes\n" : "No\n");
	}
}
```

---

## 作者：Larryyu (赞：3)

## _Description_

给定一张包含 $n$ 个顶点和 $m$ 条边的无向连通图，Tom 和 Jerry 在图上进行了 $q$ 次追逐游戏。
    
在第 $i$ 次游戏中，Tom 一开始位于顶点 $a_i$，而 Jerry 一开始位于顶点 $b_i$（双方任何时候都知道自己和对方的位置），追逐规则如下：

- Jerry 和 Tom 交替行动，Jerry 先行动。
- Jerry 每次行动可以通过无向图中的 \textbf{任意多条边}（可以选择不移动），但是在移动过程中不能经过 Tom 当前所在的结点，否则就会被抓住。
- Tom 每次行动只能通过无向图中的 \textbf{至多一条边}（可以选择不移动）。
- 如果 Tom 在一次行动后到达了 Jerry 的位置，那么 Tom 胜利

Tom 尽量想要胜利，而 Jerry 会尽量阻止 Tom 胜利。

现在你需要对于每一局游戏，求出 Tom 是否一定能在有限次行动内获胜。

$n,m,q\le10^5$。

## _Solution_

看到 Jerry 不能走 Tom 所在的节点，不难想到割点与圆方树，Tom 想要抓到 Jerry 一定是把不断限制 Jerry 的移动范围直到把他逼到一个叶子上。下文的『一步到达』指在原图上可以只通过一条边到达。

假设 Tom 此时在一个圆点 $x$ 上，Jerry 在 $s$ 这个方点的子树内，考虑如何使 Jerry 在他移动后无法走到这棵子树外。

如果 $x$ 无法一步到达所有与 $s$ 相连的圆点内，那么 Jerry 就可以先待在一个 $x$ 无法一步到达的点使得在 Tom 移动一步后可以立马跑到 $s$ 的子树外。这样 Tom 是无法缩小 Jerry 的移动范围。

如果 $x$ 可以一步到达，那么 Jerry 肯定不会走到与 $s$ 相连的圆点，于是 Tom 可以走到与 $s$ 相连的圆点 $y$，而此时 Jerry 在 $y$ 的子树中。这样 Tom 成功缩小了 Jerry 的移动范围。

因为我们要知道 $x$ 能否到 $s$ 点双的所有点，于是我们设 $cov_i$ 来判定：

- 当 $i$ 是圆点时，表示 $i$ 能到多少个点双 $fa_i$ 内的点。
- 当 $i$ 是方点时，表示 $fa_i$ 能到多少个点双 $i$ 内的点。

$cov_i$ 是好算的，对于原图中的一条边 $(u,v)$，$u$ 和 $v$ 一定会在一个点双内，所以会对 $cov$ 产生贡献。设 $dev_i$ 表示 $i$ 在圆方树的深度，$u$ 和 $v$ 有两种情况：

- $dep_u=dep_v$，那么 $cov_u$ 和 $cov_v$ 都加 1。
- $dep_u\ne dep_v$，设 $dep_u<dep_v$，那么 $cov_v$ 和 $cov_{fa_v}$ 都加 1。

于是设 $f_x$，当 $f_x=0$ 时，表示可以从 $x$ 开始一步步将在其子树**内**的 Jerry 移动范围不断缩小直至抓住，否则不能。转移和绝大多数圆方树 dp 一样：

- $x$ 是圆点时，$f_x=\sum\limits_{y\in son_x}{f_y}+[cov_y\neq siz_y]$，其中 $siz_y$ 表示点双 $y$ 的大小。
- $x$ 是方点时，$f_x=\sum\limits_{y\in son_x}{f_y}$。

再设 $g_x$ 表示能否缩子树**外**的 Jerry 移动范围，转移与 $f_x$ 类似。

所以对于一次询问 $a,b$，如果 $b$ 在 $a$ 子树外，那么判定 $g_a$ 是否等于 0，如果 $b$ 在 $a$ 的儿子 $c$ 的子树内，判断 $f_c$ 是否等于 0 以及 $a$ 能否到点双 $c$ 的所有点。

当然以上判断前提条件是 $a$ 是一个割点，如果 $a$ 不是割点那么只有 $a$ 先移动到一个割点在能开始缩小 Jerry 的移动范围。如果图上有 $f_x=g_x=0$ 的点，那么 $a$ 走到 $x$ 再开始抓，否则没有这种点的话，Jerry 只要待在 $f_x$ 或 $g_x$  不等于 0 的那一边就不会被抓。

总复杂度 $O(n+q\log n)$，瓶颈在于找 $b$ 在 $a$ 的哪一儿子的子树内。

## _Code_

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,q,cnt,tot;
int f[2*N],g[2*N],fa[2*N][20];
int low[N],dfn[N],dep[2*N],cov[2*N];
bool vis[N];
stack<int> s;
vector<int> e[2*N],v[N];
vector<pair<int,int> > sav;
void tarjan(int x,int fax){
	dfn[x]=low[x]=++cnt;
	s.push(x);
	for(int y:e[x]){
		if(y==fax) continue;
		if(!dfn[y]){
			tarjan(y,x);
			low[x]=min(low[x],low[y]);
			if(low[y]>=dfn[x]){
				tot++;
				while(s.top()!=y){
					v[tot].push_back(s.top());
					s.pop();
				}
				v[tot].push_back(y);
				v[tot].push_back(x);
				vis[x]=1;
				s.pop();
			}
		}else low[x]=min(low[x],dfn[y]);
	}
}
void dfs1(int x,int fax){
	dep[x]=dep[fax]+1;
	fa[x][0]=fax;
	for(int i=1;i<=17;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int y:e[x]){
		if(y==fax) continue;
		dfs1(y,x);
	}
}
void dfs2(int x){
	for(int y:e[x]){
		if(y==fa[x][0]) continue;
		dfs2(y);
		f[x]+=f[y];
		if(x<=n) f[x]+=(cov[y]!=v[y-n].size());
	}
}
void dfs3(int x){
	if(x<=n&&x^1)
		g[x]=g[fa[x][0]]+f[fa[x][0]]-f[x]+(cov[x]!=v[fa[x][0]-n].size());
	if(x>n)
		g[x]=g[fa[x][0]]+f[fa[x][0]]-f[x];
	for(int y:e[x]){
		if(y==fa[x][0]) continue;
		dfs3(y);
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]!=dep[y]){
		x=fa[x][(int)log2(dep[x]-dep[y])];
	}
	if(x==y) return x;
	for(int i=17;~i;i--){
		if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	}
	return fa[x][0];
}
bool sol(int x,int y){
	if(!vis[x]) return 0;
	if(x==y) return 1;
	if(lca(x,y)==x){
		for(int i=17;~i;i--){
			if(dep[fa[y][i]]>dep[x]) y=fa[y][i];
		}
		return f[y]+(cov[y]!=v[y-n].size())==0;
	}
	return g[x]==0;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n>>m>>q;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
		sav.push_back({x,y});
	}
	tarjan(1,0);
	for(int i=1;i<=n;i++) e[i].clear();
	for(int i=1;i<=tot;i++){
		for(int j:v[i]){
			e[n+i].push_back(j);
			e[j].push_back(n+i);
		}
	}
	dfs1(1,0);
	for(int i=1;i<=n+tot;i++) cov[i]=1;
	for(auto [x,y]:sav){
		if(dep[x]>dep[y]) swap(x,y);
		if(dep[x]==dep[y]) cov[x]++,cov[y]++;
		else cov[y]++,cov[fa[y][0]]++;
	}
	dfs2(1);
	dfs3(1);
	bool ff=0;
	for(int i=1;i<=n;i++) ff|=(f[i]==0)&(g[i]==0);
	while(q--){
		int x,y;
		cin>>x>>y;
		if(ff) cout<<"Yes\n";
		else cout<<(sol(x,y)?"Yes":"No")<<'\n';
	}
	return 0;
}
```

---

## 作者：Iniaugoty (赞：2)

除去分讨和代码比较史以外是一个好题。

前置知识：对点双连通分量、圆方树的性质有一定了解，并且会写基础的换根 DP。

先进行一些平凡的观察。

- **「观察 $1$」**：从 J 的角度，发现她可以直接到达的点其实是，把 T 删掉以后与其连通的任意点。而“删点后连通”这个东西显然与点双连通性有关。进一步地发现 J 的初始位置 $b$ 其实是假的，相当于你几乎可以选择任意点开始游戏，然后等着 T 来抓你，$a, b$ 只是限制一个第一步的范围。不难发现初始位置肯定会**选择最好的一个**，以至于接下来一段时间内都没有必要动。

- **「观察 $2$」**：从 T 的角度，想要在有限时间内获胜，反过来 J 就会尽量拖延时间。所以 T 可以不移动其实也是假的，她会**始终尝试移动**，不会停在一个点上尝试堵住 J，否则 J 也选择不动僵持下来，T 就赢不了了。

考虑 J 活下来的策略只有以下三种：

1. 在一个点双连通分量中转圈圈。

2. 在两个分量（**不一定相邻**）间反复横跳。

3. 在若干个分量间反复移动。

同时，由 **「观察 $1$」**，只需要考虑 T 与 J 在同一个连通分量的情况。

不难发现如果能达成 Case 3 也一定可以达成 Case 2，Case 3 是不优的。

考虑 Case 1。只需考虑 T 移动后与 J 直接相连时 J 的策略。

- 如果存在一个点和 T 没有直接相连，J 会走过去。

- 否则，J 会被一步杀。

那 T 肯定会尽量走到“与分量中任何点都直接相连的点”，这样 J 无论如何都会寄。若不存在这样的点，我们称这是一个「极好的」分量。

考虑 Case 2，考虑 J 如何能从一个点双连通分量 $A$ 移动到分量 $B$。设 $A$ 中朝着 $B$ 方向的割点为 $u$。

- 若 T 不在 $u$ 上，J 直接就过去了。

- 若 T 在 $u$ 上，J 需要先到一个与 $u$ 不相连的点上。

  - 若存在，J 会先过来，根据 **「观察 $2$」**，T 会移动一下，而且没法杀掉 J，然后 J 就过去了。
 
  - 否则 J 无论如何都会被一步杀掉。

所以 J 能从 $A$ 走到 $B$ 的充要条件是，$A$ 中至少存在一个点与 $u$ 不直接相连。反之，我们称 $u$「锁定」了 $A$。

从而，当 $A, B$ 都没有被中间的割点「锁定」，J 可以在其中反复横跳，就输不了了。

该想的几乎完了，讨论 $a$ 是否是割点。

先将原图进行点双缩点，得到一个圆方树。

- T 不在割点上，则 J 的初始位置可以任选。

  - 若**整棵树上**存在一个 Case 1 中「极好的」方点，则 J 走到其中可以存活。
  
  - 若**整棵树上**存在一对方点 $A, B$，满足：在 $A$ 到 $B$ 的路径上，设与 $A$ 相邻的圆点是 $u$，与 $B$ 相邻的圆点是 $v$，$u$ 没有「锁住」$A$ 且 $v$ 没有「锁住」$B$。同样走到 $A$ 或 $B$ 中即可存活。

  - 否则 J 必死。

- T 在割点上。将原图缩点成圆方树，则 T 对应了某个圆点。则 J 的第一步只能选择 $a$ 在 $b$ 方向的子树中。

  - 若**子树中**存在一个 Case 1 中「极好的」分量，则 J 走到其中即可存活。

  - 若**子树中**存在一个方点 $A$，使得**整棵树上**存在一个方点 $B$，满足：在 $A$ 到 $B$ 的路径上，设与 $A$ 相邻的圆点是 $u$，与 $B$ 相邻的圆点是 $v$，$u$ 没有「锁住」$A$ 且 $v$ 没有「锁住」$B$。同样走到 $A$ 中即可存活。

  - 否则就寄了。
 
需要注意的是条件几乎都是一样的，区别只在于范围。

考虑如何维护。先缩点。能处理出：每个方点是否是「极好的」；每个圆点能「锁定」哪些方点。

Case 1 考虑设 $s_u$ 表示 $u$ 的子树内「极好的」方点数量即可。

Case 2 稍稍复杂。若圆点 $u$ 没有「锁定」方点 $v$，我们将 $(u, v)$ 的边定向为 $v \to u$。那么要找的其实就是一对相向的边。设 $f_u$ 表示 $u$ 子树内向着 $u$ 的边的数量。由于需要支持换根，设 $g_u$ 表示 $u$ 子树外向着 $u$ 的边的数量。但这不足以应付询问。因此再设 $val_u = 1/0$ 表示是否存在一对跨过 $u$ 的满足条件方点，设 $dp_u$ 表示子树 $val$ 值之和。

全部信息都可以通过换根 DP 求出。

很多地方需要支持差分所以大多数维护的都是数量而非存在性。

复杂度是在 $\mathcal O(n)$ 或是在其基础上带一个 $\log n$ 或者 $\log^2 n$，看实现。

~~其实只要思路清晰是很好写的。~~

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for (int i = (a); i <= (b); ++i)
#define dF(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
typedef long long LL;
typedef unsigned long long ull;
typedef pair<int, int> pii;
const int N = 2e5 + 5;

int n, m, q, tot;
vector<int> e[N], t[N];

// 缩点，建圆方树
int deg[N], vis[N]; set<int> st[N]; map<int, int> buc[N];
namespace Tarjan {
  int cnt, dfn[N], low[N], st[N], tp;
  void Addedge(int u, int v)
    { t[u].push_back(v), t[v].push_back(u), ++deg[u], ++deg[v]; }
  void Dfs(int u) {
    dfn[u] = low[u] = ++cnt, st[++tp] = u;
    for (int v : e[u])
      if (!dfn[v]) {
        Dfs(v), low[u] = min(low[u], low[v]);
        if (low[v] >= dfn[u]) {
          Addedge(++tot, u);
          do Addedge(tot, st[tp]); while (v != st[tp--]);
        }
      }
      else low[u] = min(low[u], dfn[v]);
  }
}

int fa[N][20], dep[N];
void Dfs(int u, int ff) {
  fa[u][0] = ff, dep[u] = dep[ff] + 1;
  F(i, 1, 19) fa[u][i] = fa[fa[u][i - 1]][i - 1];
  for (int v : t[u]) if (v != ff) Dfs(v, u);
}
int Getfa(int u, int k) {
  dF(i, 19, 0) if (k >> i & 1) u = fa[u][i];
  return u;
}
bool chk(int u, int v) {
  if (dep[u] > dep[v]) return 0;
  return Getfa(v, dep[v] - dep[u]) == u;
}

// 换根 DP 出要找的东西
int s[N], f[N], g[N], up[N], dn[N], val[N], dp[N];
void Dfs1(int u, int ff) {
  for (int v : t[u]) if (v != ff) {
    Dfs1(v, u), s[u] += s[v];
    if (v > n && st[u].find(v) == st[u].end()) up[v] = 1;
    f[u] += f[v] + up[v];
  }
}
void Dfs2(int u, int ff) {
  for (int v : t[u]) if (v != ff) {
    if (u > n && st[v].find(u) == st[v].end()) dn[v] = 1;
    g[v] = g[u] + f[u] - f[v] - up[v] + dn[v];
    Dfs2(v, u);
  }
}
void Dfs3(int u, int ff) {
  for (int v : t[u]) if (v != ff) {
    if (up[v] && g[u] + f[u] - f[v] - up[v]) val[v] = 1;
    if (dn[v] && f[v]) val[u] = 1;
  }
  dp[u] = val[u];
  for (int v : t[u]) if (v != ff)
    Dfs3(v, u), dp[u] += dp[v];
}

void mian() {
  int a, b, c; cin >> a >> b;
  if (deg[a] == 1)
    if (s[tot] || dp[tot]) return cout << "No\n", void();
    else return cout << "Yes\n", void();
  bool res1 = 0, res2 = 0;
  if (chk(a, b))
    c = Getfa(b, dep[b] - dep[a] - 1),
    res1 = s[c], res2 = dp[c];
  else c = fa[a][0],
    res1 = s[tot] - s[a], res2 = dp[tot] - dp[a];
  cout << (res1 || res2 ? "No\n" : "Yes\n");
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> m >> q;
  F(i, 1, m) {
    int u, v; cin >> u >> v;
    e[u].push_back(v), e[v].push_back(u);
  }
  tot = n; Tarjan::Dfs(1), Dfs(tot, 0);
  F(u, 1, n) for (int v : e[u]) if (u < v) {
    int w = 0;
    if (deg[u] > 1 && deg[v] > 1)
      w = (dep[u] < dep[v] ? fa[v][0] : fa[u][0]);
    else w = (deg[u] > 1 ? t[v][0] : t[u][0]);
    ++buc[w][u], ++buc[w][v];
  }
  F(u, n + 1, tot)
    for (auto [x, y] : buc[u])
      if (y == deg[u] - 1)
        ++vis[u], st[x].insert(u);
  F(u, n + 1, tot) if (!vis[u]) s[u] = 1;
  Dfs1(tot, 0), Dfs2(tot, 0), Dfs3(tot, 0);
  while (q--) mian();
  return 0;
}
```

---

## 作者：flyingfrog (赞：2)

## 前言
模拟赛挂分挂完，直接来补 T4，花半天一路学了点双、圆方树（菜还有理了），但是 [@Hoks](https://www.luogu.com.cn/user/551100) 的思路对我来说不太直接，所以决定自己重新写一篇。

## 思路
赛时看到，最先想到割点，打算写个显然假的做法：Tom 在割点就是 Yes，否则就是 No。

~~但是割点挂了。~~ 正解的确与割点有关。

### 初始在割点：
一种显然的策略：

1. Tom 初始在割点。
2. Tom 每一步走到另一个能使 Jerry 能活动的点双变少的割点。
3. Tom 最后一步抓住 Jerry。

一些深入思考：

1. 每个割点连接多个不同点双，策略的可行性取决于 Jerry 所在联通块能不能被 Tom 缩小。
2. Tom 如果不能每一步都到达一个割点，Jerry 就可以逃跑，这个策略就会寄。

总结关键词：割点，到达，位置——**圆方树**。

一直到这一步应该都是好理解的。那么在原图上建出圆方树。以 Tom 的位置为树根，向 Jerry 所在子树越过方点移动。每次到达的圆点和上一个圆点必须有边连接，不然 Jerry 就会逃跑。

钦定点 $1$ 作为树根，$f_u$，$g_u$ 分别表示点 $u$ 内外子树的可行行，考虑 dp：

#### 内子树 $f$（第一遍 dfs）
对于每个圆点 $u$ 之于其子树的可行性 $f_{u}$ 如果为 $1$，那么它的儿子方点的儿子圆点（以下称为孙子圆点 $sv$）对于 $u$ 必须都在原图上可达即 $p(u, sv) = 1$（不然 Jerry 跑到这个子树就寄），而且必须有 $f_{sv} = 1$ 。就是说：

$$\forall sv, f_{sv} \land p(u, sv), f_u = 1$$

然而这样 dp 是存在缺陷的。考虑下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1aqt6cnj.png)

建出圆方树：

![](https://cdn.luogu.com.cn/upload/image_hosting/lm9jsx1j.png)

简单模拟一下可以得到 $f=\{0, 1, 1, 1, 1\}$。然而对于询问 $1, 2$，$2$ 在 $1$ 的子树中，如果直接从 $f_1$ 就会得到答案为 No，不符合实际。究其原因在于 Jerry 只能在编号 $7$ 的点双里移动而到不了 $6$ 去，但 $f_1$ 却是包括了 $7$ 和 $6$ 的答案。

解决方法也很简单，把 $f$ 记录的对象从圆点扩大到方点。

对于每个方点 $u$ 之于其子树的可行性 $f_{u}$ 如果为 $1$，那么它的儿子圆点 $v$ 对于父亲圆点 $fa_u$ 必须都在原图上可达即 $p(fa_u, v) = 1$，而且必须有 $f_{v} = 1$ 。就是说：

$$\forall v, f_{v} \land p(fa_u, v), f_u = 1$$

用这种 dp 得到的 $f=\{0, 1, 1, 1, 1, 0, 1\}$，对于询问 $1, 2$，查询 $2$ 所在 $1$ 的子树的根（一定是 $1$ 的一个儿子方点）也就是 $7$，得到 Yes，符合实际。

不过为了下面对 $g$ 的递推方便一些，在这里修改一下 $f$ 的定义：$f_u$ 表示 $u$ 的儿子或孙子圆点符合条件的数量，同时定义辅助数组 $son$ 记录圆点的孙子数和方点的儿子数，dp：

$$f_u = \sum_{v \in sons_u}[p(u, v) \land(f_v = son_v)]$$

判断改成 $f_u = son_u$ 即可。

#### 外子树 $g$（第二遍 dfs）
$g_u$ 表示圆点 $u$ 的外子树是否可行，递推时需要考虑它的兄弟圆点，父亲方点的兄弟方点，和祖父圆点的外子树。具体地说：

1. 祖父圆点 $ga$ 的外子树。要求 $ga$ 能到达 $u$ 且 $g_{ga} = 1$。
2. $u$ 的兄弟圆点 $br$。要求 $br$ 能到达 $u$ 且 $f_{br} = son_{br}$。
3. 父亲方点的兄弟方点 $uc$。这些方点不与 $u$ 直接连接，所以不用判断是否能到达。要求 $f_{uc} = son_{uc}$。

第一点，直接设定 $g_u$ 的初值为 $g_{ga} \land p(ga, u)$。

第二点，遍历并判断。

对于第三点中的 $uc$，不用遍历，因为 $\sum f_{uc}=f_{ga}-f_{fa}$，$\sum son_{uc}=son_{ga}-son_{fa}$，所以直接判断 $f_{ga} - f_{fa} = son_{ga} - son_{fa}$ 就行。

不用记录方点，因为外子树只有一个。

### 初始不在割点
到目前为止都是对初始在割点情况的说明。而对与 Tom 初始不在割点的情况，可以遍历一遍所有圆点看是否有点 $u$ 满足 $f_u = son_u$ 且 $g_u = 1$。

如果有，那不管在不在割点，所有询问都输出 Yes 就可以。因为只要 Tom 到这个点，不管 Jerry 在内子树还是外子树，都可以采用上面的策略。

而如果没有，不管 Tom 移动到哪个点，Jerry 只要移动到 Tom 抓不到的部分去就可以赢得比赛，所以初始不在割点就是 No。

不用特意判断是否在割点。不是割点的点 $f$ 和 $g$ 一定不满足条件。

## 代码实现
处理询问时会遇到一个问题，就是如何判断 $y$ 是否在 $x$ 的子树内。可以利用树剖的思想，一个子树内的 $dfn$ 一定是连续的，所以在 dfs 处理 $f$，$g$ 的时候顺手处理出 $in$ 和 $out$ 数组，$in$ 数组记录遍历到该点时的 $tim$，$out$ 数组记录离开该点时的 $tim$，那么只要满足 $in_x \le in_y \le out_x$ 就可以判定 $y$ 在 $x$ 的子树内。

而当 $b$ 在 $a$ 子树内时也可以利用这一点，遍历 $a$ 的所有儿子方点 $v$，若 $in_v \le in_b \le out_v$，那么 $v$ 就是可以得出答案的方点。

```cpp
#include <bits/stdc++.h>
using namespace std;

const string name = "P7353";
const int N = 2e5 + 2;

int n, m, q, tim, top, cnt;
int dfn[N], low[N], stk[N], fa[N], son[N], in[N], out[N];
int dp[N][2];
set <int> g[N];
vector <int> tr[N];

void tarjan(int u, int fa){
	dfn[u] = low[u] = ++ tim;
	stk[++ top] = u;
	for(int v : g[u]){
		if(!dfn[v]){
			tarjan(v, u);
			low[u] = min(low[v], low[u]);
			if(low[v] >= dfn[u]){
				int r = ++ cnt;
				tr[r].push_back(u);
				tr[u].push_back(r);
				while(stk[top + 1] != v){
					int t = stk[top];
					tr[r].push_back(t);
					tr[t].push_back(r);
					top --;
				}
			}
		}else if(v != fa)
			low[u] = min(dfn[v], low[u]);
	}
}

void dfs1(int u, int f){
	in[u] = ++ tim;
	for(int v : tr[u]){
		if(v == f)  continue;
		fa[v] = u;
		in[v] = ++ tim;
		for(int vv : tr[v]){
			if(vv == u)  continue;
			fa[vv] = v, son[u] ++, son[v] ++;
			dfs1(vv, v);
			if(g[u].count(vv) && dp[vv][0] == son[vv])
				dp[u][0] ++, dp[v][0] ++;
		}
		out[v] = tim;
	}
	out[u] = tim;
}

void dfs2(int u, int f){
	if(!f)  dp[u][1] = 1;
	else  dp[u][1] = (g[u].count(f) & dp[f][1] & (dp[f][0] - dp[fa[u]][0] == son[f] - son[fa[u]]));

	for(int v : tr[fa[u]]){
		if(v == u || v == f)  continue;
		dp[u][1] &= (g[u].count(v) & (dp[v][0] == son[v]));
	}
	for(int v : tr[u]){
		if(v == fa[u])  continue;
		for(int vv : tr[v]){
			if(vv == fa[v])  continue;
			dfs2(vv, u);
		}
	}
}

bool check(int u, int v){
	for(int t : tr[u]){
		if(t == fa[u])  continue;
		if(in[t] <= in[v] && in[v] <= out[t]){
			return dp[t][0] == son[t];
		}
	}
}

int main(){
	ios_base::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);

	cin >> n >> m >> q;  cnt = n;
	for(int i = 1; i <= m; i ++){
		int u, v;  cin >> u >> v;
		g[u].insert(v);
		g[v].insert(u);
	}
	tarjan(1, 0);  tim = 0;
	dfs1(1, 0);
	dfs2(1, 0);
	for(int i = 1; i <= n; i ++){
		if(dp[i][0] == son[i] && dp[i][1]){
			while(q --)  cout << "Yes\n";
			return 0;
		}
	}
	while(q --){
		int u, v;  cin >> u >> v;
		if(in[u] <= in[v] && in[v] <= out[u]){
			if(check(u, v))  cout << "Yes\n";
			else  cout << "No\n";
		}else{
			if(dp[u][1])  cout << "Yes\n";
			else  cout << "No\n";
		}
	}
	
	return 0;
}
```

---


# Virtual Self

## 题目背景

![Virtual Self](https://cdn.luogu.com.cn/upload/image_hosting/16xzq9r9.png)

> Lately, I've been hearing the cries of the angels when I close my eyes
>
> Remember?

## 题目描述

Technic_Angel 想用粒子来制作一支美丽的水晶。Pathselector 告诉她，一支水晶由 $m$ 簇粒子合成，其中每一簇粒子都有美丽度（一个小于 $2^w$ 的非负整数，其中 $w$ 为给定正整数），而一支水晶的美丽度就是合成它的所有粒子的美丽度的异或和。

Technic_Angel 有许多粒子：对于每一个 $i\in[0,2^w)\cap\Z$，她都有恰好 $v_i$ 簇美丽度为 $i$ 的粒子。现在 Technic_Angel 想要知道，有多少种方案能够合成一支美丽度为 $k$ 的水晶呢？（两种方案不同，当且仅当有一簇粒子在一种方案中被使用而在另一种方案中没有；所有粒子都互不相同）可惜她并不会这个问题，于是她找到了擅长 OI 的你。

在你花 $0.01\mu s$ 切掉这道题后，异常惊喜的 Technic_Angel 想要让你对所有 $k\in[0,2^w)\cap\Z$ 都解决上面的问题。但由于答案过于巨大，她只要求你告诉她对于所有的 $i$，$((i+1)f(i))\bmod998244353$ 的异或和，其中 $f(i)$ 代表合成一支美丽度为 $i$ 的水晶的方案数。即
$$
(f(0)\bmod P)\otimes(2f(1)\bmod P)\otimes\cdots\otimes(2^wf(2^w-1)\bmod P)
$$
其中 $P=998244353$，$\otimes$ 代表异或。注意是取模后的异或和而非异或后再取模。

## 说明/提示

### 样例解释

样例一：Technic_Angel 共有三簇粒子，美丽度分别为 $1,2,3$。用序列表示选出的粒子的美丽度的话，没有合成美丽度为 $0$ 的水晶的方案，而为 $1$、为 $2$ 和为 $3$ 的方案各有一种（分别是 $[2,3]$、$[1,3]$ 和 $[1,2]$），于是答案为 $0\otimes2\otimes3\otimes4=5$。

### 数据范围

令 $n=\sum v_i$。对于全部数据，有 $0\le n,v_i<998244353$，$1\le m\le\min\{n,10^6\}$，$1\le w\le 20$。

| 子任务 |       $n,m,w$       | 特殊性质 | 分值 |
| :----: | :-----------------: | :------: | :--: |
|   1    |        $m=1$        |   $A$    |  5   |
|   2    |   $n\le200,w\le8$   |   $A$    |  10  |
|   3    |        $m=2$        |   $A$    |  20  |
|   4    |         无          |  $A,B$   |  25  |
|   5    |         无          |   $A$    |  38  |
|   6    | $m\le 60000,w\le16$ |    无    |  2   |

特殊性质 $A$：$n\le10^6$。

特殊性质 $B$：$2^w\cdot m\le 6\cdot 10^7$。

## 样例 #1

### 输入

```
2 2
0 1 1 1```

### 输出

```
5```

## 样例 #2

### 输入

```
3 3
2 0 1 7 1 2 0 1```

### 输出

```
320```

## 样例 #3

### 输入

```
5 3
2 0 2 1 0 4 2 3```

### 输出

```
1482```

# 题解

## 作者：Mivik (赞：10)


### Subtask 1

一共只有 $n$ 种选择方案，直接统计并输出即可。

### Subtask 2

记 $f_{i,j,k}$ 为考虑了前 $i$ 个数，用到了 $j$ 个，异或值为 $k$ 的方案数。直接 $O(2^wn^2)$ 暴力转移即可。

### Subtask 3

先不考虑不能选同一个数的条件，那么令 $c_i$ 为 $i$ 在给定的数中的出现次数，答案就是 $c*c$（$*$ 是异或卷积）。用 $\mathrm{FWT}$ 算出这个后我们再减去选到同一个数的情况就好了。

### Subtask 4

下文我们令 $L=2^w$。定义一个序列的权值向量为一个长度为 $L$ 的向量，其中序列的第 $i$ 位为 $i$ 在原序列中出现的次数；并额外定义一个数 $c$ 的权值向量就是 $[c]$ 的权值向量。那么 $k$ 个数的异或就是它们的权值向量 $\mathrm{FWT}$ 后逐位相乘再 $\mathrm{FWT}$ 回去。然后我们对这个向量逐位考虑。根据 $\mathrm{FWT}$ 的定义我们知道
$$
\mathrm{FWT}(v)_i=\sum_{j=0}^{L-1}(-1)^{\mathrm{pop}(i\&j)}v_j
$$
其中 $\mathrm{pop}(v)$ 是 $v$ 二进制下 $1$ 的个数，$i\&j$ 是位与（Bit-And）运算。其次我们知道 $\mathrm{FWT}$ 是一个线性变换，也就是说 $\mathrm{FWT}(a)+\mathrm{FWT}(b)=\mathrm{FWT}(a+b)$，我们要算答案可以把所有情况的 $\mathrm{FWT}$ 加起来得到答案的 $\mathrm{FWT}$。

不难发现一个正整数的权值向量 $\mathrm{FWT}$ 后每一项只能是 $\pm1$。对于答案 $\mathrm{FWT}$ 中的每一个位置，我们相当于是要从一些 $1$ 和 $-1$ 中选出 $m$ 个，然后算乘积，并对所有方案求和。假设我们知道这一个位置上有 $a$ 个 $-1$，$(n-a)$ 个 $1$，于是答案的 $\mathrm{FWT}$ 上这一位的值就是
$$
\begin{aligned}
&[x^m](1-x)^a(1+x)^{n-a}\\
=&\sum_{i=0}^m(-1)^i\binom ai\binom{n-a}{m-i}
\end{aligned}
$$
这个可以 $O(m)$ 计算。现在问题是我们怎么对每一个位置都算出 $a$。不难发现每一个位置上面数的和是
$$
s_i=\sum_{j=1}^n(-1)^{\mathrm{pop}(i\&v_j)}
$$
这个是可以一遍 $\mathrm{FWT}$ 算出来的，然后解一下方程就可以知道 $a$ 了。于是我们就可以 $O(Lm)$ 得到答案的 $\mathrm{FWT}$，然后 $O(Lw)$ 得到答案。总时间复杂度 $O(Lm)$。

### Subtask 5

不难发现我们可以对每一个可能的 $a$（即 $[0,n]$ 间任意整数）用 $\mathrm{FFT}$ 预处理出上面那个式子的值，于是我们就在 $O(n\log n+Lw)$ 的时间复杂度内通过了这一 Subtask。

### Subtask 6

~~好耶，是防 AK~~

不难发现上面那个式子是关于 $a$ 的一个 $m$ 次多项式，我们可以预先对 $a\in[0,m]$ 求出点值然后插值得到多项式，最后我们再多点求值求至多 $L$ 个点值即可。

不过我们注意到由于 $n$ 是 $10^9$ 级别，我们没法以朴素形式为基础直接卷积得到点值，于是我们对原式变形：
$$
\begin{aligned}
&\sum_{i=0}^m(-1)^i\binom ai\binom{n-a}{m-i}\\
=&\sum_{i=0}^m(-1)^i\frac{a!(n-a)!}{i!(a-i)!(m-i)!(n-a-m+i)!}\\
=&a!\sum_{i=0}^m\frac{(-1)^i}{i!(m-i)!}\frac{(n-a)^{\underline{m-i}}}{(a-i)!}\\
=&\frac{a!}{n^{\underline a}}\sum_{i=0}^m\frac{(-1)^i}{i!(m-i)!}\frac{n^{\underline{m+(a-i)}}}{(a-i)!}
\end{aligned}
$$
于是就可以正常卷积了。时间复杂度 $O(m\log^2m+Lw)$。

[mivik.h](https://mivik.gitee.io/mivik.h) / [98 分代码](https://paste.ubuntu.com/p/yCgCjzVYPg/) / [满分代码](https://paste.ubuntu.com/p/GQsymJvTzw/)


---

## 作者：Petit_Souris (赞：3)

~~这是一篇推歌博文，希望大家立刻去听 Particle Arts。~~

首先考虑抽象成集合幂级数。相当于现在有 $n$ 个集合幂级数 $F_{i}(x)=x^{a_i}$，我们需要从中选出 $m$ 个，求他们的异或卷积的和。

那么第一步容易想到做 FWT，我们要求从 $n$ 个 FWT 后的结果中选出 $m$ 个，他们的乘积的 IFWT 的结果的和。

FWT 和 IFWT 是具有线性性的，也就是说：$\operatorname{FWT}(a)+\operatorname{FWT}(b)=\operatorname{FWT}(a+b)$，也就是说我们只要求出所有 FWT 后的集合幂级数中选出 $m$ 个的乘积之和，最后整体做一遍 IFWT 即可。

考虑一下对单项式做异或 FWT 的结果：$x^{a_i}$ 在 FWT 后每位都是 $1$ 或 $-1$。那么这时候一个经典的 trick 就是你考虑求出每一位的 FWT 结果之和，就能解一个方程得到每一位上有多少 $-1$ 和 $1$。因此你考虑把所有 $x^{a_i}$ 求和，做一遍 FWT，这样你就能求出每位的 $-1$ 和 $1$ 的数量。

接下来考虑每位选出 $m$ 个数的乘积之和。假设这位有 $c$ 个 $-1$，那么这位的结果为：

$$\sum\limits_{i=0}^{c}(-1)^{i}\binom{c}{i}\binom{n-c}{m-i}$$

展开后容易发现是一个卷积的形式，可以用 NTT 做到 $\mathcal O(n\log n+2^ww)$，获得尊贵的 98 分！

最后 2 分比较生气！发现上面这个东西是关于 $c$ 的至多 $m+1$ 次多项式，因此我们可以用 98 分的做法求出 $[0,m]$ 的点值，进行一次快速插值求得这个多项式，最后再用一次多点求值求出 $2^w$ 个要用的点值。时间复杂度 $\mathcal O(m\log^2 m+2^ww^2)$，实现的比较好就可以获得 100 分！（上面的卷积需要改一下，因为我们不好算 $(n-c)!$，可以转成下降幂处理。）

我的代码只有 10KB，可以说是相当得好写了！

[code](https://www.luogu.com.cn/paste/2xathhy4)

---

## 作者：云浅知处 (赞：2)

感觉这题肯定能评黑啊！

考虑写出 $\sum v_i$ 个多项式，其中 $x^i$ 有 $v_i$ 个，那么答案相当于从这 $\sum v_i$ 个多项式里面选 $m$ 个，求出乘积（其中 $x^a\times x^b=x^{a \text{ xor }b}$），再全部求和。

考虑 FWT，相当于选 $m$ 个多项式，把它们 FWT 后乘起来，再对所有这种的 FWT 之和求和，再 IFWT 回去。

发现每个序列 FWT 后会有若干位 $1$ 和若干位 $-1$，考虑先算出来所有序列的 FWT 之和。那么通过这一位上的值就能解出这一位上 $-1$ 的个数，假设有 $a$ 个，则答案的 FWT 在这一位上（乘法情形时）的值就是
$$
\sum_{i=0}^a(-1)^i\binom{a}{i}\binom{n-a}{m-i}=a!(n-a)!\sum_{i=0}^a\dfrac{(-1)^i}{i!(m-i)!}\times \dfrac{1}{(a-i)!(n-m-(a-i))!}
$$
发现是个卷积，可以用 NTT $O(n\log n)$ 预处理。时间复杂度是 $O(n\log n+w2^w)$。

但是这样只有 $98$ 分，考虑 $n\le 10^9$ 怎么做。

其实说起来也没什么！注意到这个组合数求和是关于 $a$ 的不超过 $m+1$ 次多项式！因此你可以先 NTT 算出前 $O(m)$ 项！然后快速插值得到多项式！最后多点求值要算的那 $2^w$ 项就可以了！！复杂度是 $O(m\log ^2m+w2^w)$！！！

---

## 作者：Social_Zhao (赞：1)

~~今天~~ 昨天学了多点求值相关内容啊，虽然这样说但下午主要还是去研究 Virtual Self 的新做法去了。

之前一直觉得这东西很离谱，今天静下心来思考学习了以后发现并没有想象中的那么困难。虽然对其运用还不是很熟练但这肯定也需要更多的练习。不过我现在功利心很重阿！估计也不会更深地研究这个技巧了。大概会套用一下方法就可以了。感觉有很多题目很值得花时间来研究，收获真的很大。闲话就说这么多吧。

---

下面讲一个第二问（没有 A 性质）的另解，虽然没有官方正解优秀，但是比较好想。下面记给出序列对应的集合幂级数为 $A(x)$。

首先我们将这 $m$ 个数有序化，最后除以 $m!$。设 $F_i(x)=\sum_Sa_Sx^S$ 表示长度为 $i$，内部元素两两不同，异或和为 $S$ 的序列个数。考虑在长度为 $i-1$ 的序列后面添加一个新数来递推到长度 $i$ 的序列，也就是 $F_{i-1}(x)\times A(x)$。这样得到的序列有两种情况：

1. 新数和前面任意一个数不同。这个的方案为 $F_i(x)$
2. 新数和前面某个数相同，这时候这两个相同数抵消，异或和不变，序列长度减二。此时方案数为 $F_{i-2}(x)\times(n-(i-2))\times(i-1)$。这里乘的系数的意思是选择一个和 $i-2$ 个数不同的新数，然后选择上一次出现时的位置。

综合起来我们得到了这个递推式：

$$
F_i(x)=F_{i-1}(x)\times A(x)+F_{i-2}(x)\times(n-(i-2))\times(i-1)
$$

这是一个关于集合幂级数的递推，我们首先对它做 FWT，然后对于每一项分别递推。也就是：

$$
FWT(F_i(x))_S=FWT(F_{i-1}(x))_SFWT(A)_S+(n-(i-2))(i-1)FWT(F_{i-2}(x))
$$

将这个递推写成矩阵的形式，就是：

$$
\prod_{i=1}^m \begin{bmatrix}
0  &  (n-(i-2))(i-1) \\
1 & FWT(A)_S
\end{bmatrix}
$$

将 $FWT(A)_S$ 看成变量 $x$，然后用分治 NTT 求出上面的多项式，然后多点求值即可得到答案的 FWT。

常数非常大，还是需要拼上暴力才能拿到满分。

代码非常长，需要可以私信领取。

---


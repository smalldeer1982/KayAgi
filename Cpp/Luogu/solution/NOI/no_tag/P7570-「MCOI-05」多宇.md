# 「MCOI-05」多宇

## 题目描述

Dream 将时空抽象为一颗 $n$ 节点有向有根树，其中树根为节点 $1$ 并且所有边的方向都为浅往深。  
Dream 用他的超能力在这颗树上额外添加 $m$ 条有向边，但最终的图仍然是无环图。  
Dream 进而将一个事件抽象为图上的一个节点，将一个时代抽象为图上的一个简单路径。  
Dream 认为一对事件 $(i,j)$ **可行** 当且仅当存在一个时代，使得时代的首事件是 $i$，末事件是 $j$。  
Dream 不满足于统计普通可行对。他认为超能力添加的额外边十分重要。  
Dream 认为一对事件 $(i,j)$ **条件可行** 当且仅当 $(i,j)$ 可行并且所有额外边去掉之后 $(i,j)$ 非可行。  
Dream 现在有 $q$ 组询问。第 $i$ 组询问用两个正整数 $l_i$ 与 $r_i$ 表示，其中 $l_i\le r_i$。  
Dream 想知道，对每一组询问，有多少对 **条件可行** 事件 $(i,j)$，使得 $l\le i<j\le r$。

## 说明/提示


 - Subtask 1（3 pts）：$n,q\le 1000$，3s；
 - Subtask 2（29 pts）：$n,q\le2\times10^5$，$m\le50$，3s；
 - Subtask 3（31 pts）：$m\le 50$，5s；
 - Subtask 4（37 pts）：无额外限制，5s。

对于 $100\%$ 的数据，$2\le n\le7\times10^5$，$1\le q\le3\times10^5$，$0\le m\le100$。

## 样例 #1

### 输入

```
2 2
1
1 2
1 2
1
1 2```

### 输出

```
0```

## 样例 #2

### 输入

```
8 2
1 2 5 1 4 3 3
2 4
4 7
3
4 6
5 7
1 8```

### 输出

```
0
1
4```

# 题解

## 作者：w33z8kqrqk8zzzx33 (赞：5)


观察到，一个节点可以到达的节点为若干子树并。特殊的是，**对于所有条件可行对，如果固定首事件，则末事件形成若干额外边末事件的子树之和（强于之并）**。可以通过对深度大往小归纳证明。

对每一个节点通过 bitset 处理出来这些子树是什么，时间复杂度 $\mathcal O(nm)$，空间复杂度 $\mathcal O(nm/w)$。考虑任意一个额外边计算它的贡献，也就是对每一个询问它在多少条件可行对里为最后经过的额外边。

考虑离线并扫描线：对询问按照左端点排序，从大到小扫描左端点。考虑 $L+1$ 往 $L$ 移动的时候，需要加 $L$ 对这个子树（额外边末事件）的贡献。我们先处理出来这个子树的所有节点，**对这些节点和仅对这些节点建立线段树/树状数组。** 这里“仅”的意思是离散化并不考虑任何子树外的节点。

我们仅需要在 $L$ 可以达到额外边**首**事件时候进行对线段树/树状数组的修改，这个可以直接查询 bitset。还需要注意不要将子树重复统计，这个可以通过按照 dfs 序处理末事件，判断一个节点到达的上一个末事件是否覆盖这个，如果覆盖则跳过。

如果最终发现不跳过，就对子树的线段树/树状数组所有**标号**大于 $L$ 的元素加1。对于所有 $L$ 等于当前 $L$ 的询问就加上贡献，直接在线段树/树状数组上计算 $[L,R]$ 之和即可。

时间复杂度 $\mathcal O((n+q)m\log n)$，空间复杂度 $\mathcal O(nm/w+q)$。

**赛后更新**：存在优于 $\mathcal O((n+q)m\log n)$ 的 $\mathcal O((n+q)m)$ 做法。我们不需要扫描线解决统计可达顺序对。本质是想解决快速统计

$$\sum_{l\le i<j\le r}[i\Rightarrow E][E\Rightarrow j]$$

可以通过前缀和计算。

---

## 作者：command_block (赞：3)

**题意** ： 给出一棵 $n$ 个点的外向树 $T$，以及 $m$ 条额外的边，满足加入这些边之后图 $G$ 是 DAG。

对于点对 $u,v$ ，若在 $T$ 中 $u$ 不能到达 $v$ ，但是在 $G$ 中 $u$ 可以到达 $v$ ，则称点对 $(u,v)$ 是好的。

每次询问给出 $l,r$ ，求有多少对好的 $(u,v)$ 满足 $l\leq u<v\leq r$ 。

$n\leq 7\times 10^5,q\leq 3\times 10^5,m\leq 100$ ，时限$\texttt{5s}$。

------------

> @newbiewzs 题解的详细版。

对于额外边 $u\rightarrow v$ ，将 $v$ 标记为“**关键点**”。记关键点集合为 $E$ 。

观察好对子 $(a,b)$ 的分布。

在固定 $a$ 时，若 $(a,b)$ 是好的，且 $T:b\leadsto c$ ，则 $(a,c)$ 是好的。

这说明 $b$ 的分布必然是若干不交的 $T$ 的子树（称作**好子树**）。不难进一步发现，这些子树的根都是关键点。

------------

对于每个好的对子 $(a,b)$ ，在所有可能的路径 $G:a\leadsto b$ 中，都必然有至少一个关键点。取某个关键点作为“统计点”，这样我们才能对贡献转置。

根据如上观察，我们取 $b$ 所在“好子树”的根作为**统计点** $v$ ，这样是唯一的。

考虑如何判定 $(a,b)$ 是否满足“是好的，且统计点为 $v$”。

首先有必要条件 $T:a\not\leadsto b$ ，否则 $(a,b)$ 不是好的。

然后，为了保证统计点，一个显然的必要条件是，$G:a\leadsto v$ 且 $T:v\leadsto b$ 。但这不充分，我们称满足该条件的 $v$ 为 $(a,b)$ 的**中转点**。

不难发现，中转点都是 $T$ 中 $b$ 的祖先，那么深度最小（是其他中转点的祖先）的中转点就是统计点了。

对关键点 $v$ ，记 $S_v=\{u\ \big|\ T:v\leadsto u\}$ ， $T_v=\{u\ \big|\ G:u\leadsto v,\text{不存在}v'\text{使得}G:u\leadsto v',T:v'\leadsto v\}$ 。

那么 $a\in T_v,b\in S_v$ 就是“统计点为 $v$”的充要条件。

再将 $T:a\not\leadsto b$ 纳入考虑，注意到 $T:v\leadsto b,G:v\not\leadsto a$ ，前者可以等价为 $T:a\not\leadsto v$ 。

于是改记 $T_v=\{u\ \big|\ G:u\leadsto v,T:u\not\leadsto v,\text{不存在}v'\text{使得}G:u\leadsto v',T:v'\leadsto v\}$ 。

------------

考虑如何求 $S,T$ ，使用转置。

记 $S'_u=\{v\in E\ \big|\ T:v\rightarrow u\}$ ， $T'_u=\{v\in E\ \big|\ G:u\leadsto v,T:u\not\leadsto v,\text{不存在}v'\text{使得}G:u\leadsto v',T:v'\leadsto v\}$ 。

显然，$S',T'$ 与 $S,T$ 互为转置。

$S'$ 是简单的传递闭包。

对于 $T'$ ，先用传递闭包处理 “$u\leadsto v$” ，然后用 dfs 序和树形 DP 处理 “$T:u\not\leadsto v$” 和 “$\text{不存在}v'\text{使得}G:u\leadsto v',T:v'\leadsto v$”。

使用 `bitset` ，时间 $O(nm)$ ，空间 $O(nm/w)$ 。

- 卡常技巧

  - 不要用 `[]` 操作 `bitset` ，而要使用 `set,reset,test` 等函数，常数小很多。
  
  - 树形 DP 可以转为 dfs 序上的问题。

------------

接下来考虑如何回答询问。

为了方便处理，将条件 $[l\leq a<b\leq r]$ 拆成 $[l\leq b\leq r][a<b]-[l\leq b\leq r][a<l]$ 。

$$
\begin{aligned}
{\rm Ans_1}&=\sum\limits_{v\text{是关键点}}\sum\limits_{(a,b)}[l\leq b\leq r][a<b][(a,b)\text{是好的,统计点是}v]\\
&=\sum\limits_{v\text{是关键点}}\sum\limits_{(a,b)}[l\leq b\leq r][a<b][a\in T_v][b\in S_v]\\
&=\sum\limits_{v\text{是关键点}}\sum\limits_{l\leq b\leq r}[b\in S_v]\sum\limits_{a<b}[a\in T_v]\\
\end{aligned}
$$

$$
\begin{aligned}
{\rm Ans_2}&=\sum\limits_{v\text{是关键点}}\sum\limits_{(a,b)}[l\leq b\leq r][a<l][(a,b)\text{是好的,统计点是}v]\\
&=\sum\limits_{v\text{是关键点}}\sum\limits_{(a,b)}[l\leq b\leq r][a<l][a\in T_v][b\in S_v]\\
&=\sum\limits_{v\text{是关键点}}\Bigg(\sum\limits_{l\leq b\leq r}[b\in S_v]\Bigg)\Bigg(\sum\limits_{a<l}[a\in T_v]\Bigg)\\
\end{aligned}
$$

对于每个 $v$ ，上述式子都容易用前缀和搞定。

总时间复杂度 $O((n+q)m)$ ，空间复杂度（若离线） $O(nm/\omega+q)$。

```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
#include<bitset>
#define ll long long
#define pb push_back
#define MaxN 700500
#define MaxQ 300500
#define MaxM 105
using namespace std;
struct Line{int t,nxt;}g[MaxN];
int fir[MaxN],tl;
void adl(int u,int v)
{g[++tl]=(Line){v,fir[u]};fir[u]=tl;}
int dfn[MaxN],out[MaxN],tp[MaxN],tim;
void dfsT(int u)
{
  tp[dfn[u]=++tim]=u;
  for (int i=fir[u];i;i=g[i].nxt)
    dfsT(g[i].t);
  out[u]=tim;
}
bitset<MaxM> T0[MaxN];
int id[MaxN],st[MaxM],tn;
bool vis[MaxN];
void dfsG(int u)
{
  if (id[u])T0[u][id[u]]=1;
  vis[u]=1;
  for (int i=fir[u];i;i=g[i].nxt){
    if (!vis[g[i].t])dfsG(g[i].t);
    T0[u]|=T0[g[i].t];
  }
}
int n,m,q,S[MaxN],T[MaxN],r[MaxM];
ll O[MaxN],ans[MaxQ];
int ql[MaxQ],qr[MaxQ];
int main()
{
  scanf("%d%d",&n,&m);
  for (int i=2,fa;i<=n;i++)
    {scanf("%d",&fa);adl(fa,i);}
  dfsT(1);
  for (int i=1,u,v;i<=m;i++){
    scanf("%d%d",&u,&v);
    adl(u,v);id[v]=1;
  }
  for (int i=1;i<=n;i++)if (id[tp[i]])
    {st[++tn]=tp[i];id[tp[i]]=tn;}
  for (int i=1;i<=tn;i++){
    r[i]=i;
    while(r[i]<tn&&dfn[st[r[i]+1]]<=out[st[i]])r[i]++;
  }
  dfsG(1);
  for (int u=1;u<=n;u++)
    for (int k=1;k<=tn;k++)
      if (T0[u].test(k)){
        int lim=r[k];
        while(k+1<=lim)T0[u].reset(++k);
      }
  scanf("%d",&q);
  for (int i=1;i<=q;i++)
    scanf("%d%d",&ql[i],&qr[i]);
  for (int k=1;k<=tn;k++){
    int v=st[k];
    for (int u=1;u<=n;u++){
      S[u]=(dfn[v]<=dfn[u]&&dfn[u]<=out[v]);
      T[u]=T0[u].test(k)&&!(dfn[u]<=dfn[v]&&dfn[v]<=out[u]);
      O[u]=O[u-1]+S[u]*T[u-1];
      T[u]+=T[u-1];S[u]+=S[u-1];
    }
    for (int i=1;i<=q;i++){
      int l=ql[i],r=qr[i];
      ans[i]+=O[r]-O[l-1]-1ll*(S[r]-S[l-1])*T[l-1];
    }
  }
  for (int i=1;i<=q;i++)
    printf("%lld\n",ans[i]);
  return 0;
}
```

---

## 作者：newbiewzs (赞：1)

定义每条新加的边 $(u,v)$ 的 $v$ 为关键点，发现最后每个满足条件的点对 $(x,y)$ 路径上都至少有一个关键点，且存在至少一个关键点为 $y$ 在原树上的祖先且能被 $x$ 到达。

考虑给每个点对一个统计点，不妨对于每个点对 $(x,y)$ 都在 $y$ 的祖先，能被 $x$ 到达且深度最浅的关键点处统计，则可以保证每个点对都只会被统计一次。

现在考虑求出每个点 $x$ 能到达的关键点集合，这个可以用 $bitset$ 在 $O(\frac{nm}{w}) $ 时间完成，发现如果 $x$ 能到达的两个关键点 $u,v$，满足 $u$ 是 $v$ 在原树上的祖先，则 $v$ 一定没用，因为 $u$ 能够统计所有 $v$ 能统计的信息，所以将 $v$ 在 $x$ 能到达的集合中删去，以免算重。

现在考虑枚举每个关键点 $z$ ， 再在上面枚举每个询问 $[L,R]$，发现我们现在其实在询问能到达 $z$ 的所有点 $x$ 与 $z$ 子树内的所有点 $y$，且满足 $x<y \ \ \&\&\ \ [x,y]\subseteq[L,R]$ ，将询问拆成 $\sum_{L<=x<=R\ ,\ x<y} - \sum_{L<=x<=R \ ,\ y>R}$，容易发现这些我们都可以在每个关键点 $O(n)$ 的预处理出前缀和然后扫一遍询问 $O(1)$ 的计算，所以最后复杂度为 $O(\frac{nm}{w}+nm)$

$Code:$

```cpp
const int N=7e5+55;
const int M=105;
struct Query{
	int l,r;
}q[N];
int n,m,s,st[N],top,dfn[N],ed[N],tot,pos[N],f[N],x[M],y[M],tmp[N],ans[N],s1[N],s2[N],s3[N],s4[N],ls[N],head1,rs[N],head2;
bitset<M>b[N];
bool vis[N],ban[N];
vi v[N],g[N],h[M];
int cmp(int x,int y){
	return dfn[x]<dfn[y];
}
void dfs(int u){
	vis[u]=1;	
	if(pos[u])b[u][pos[u]]=1;
	for(unsigned int i=0;i<v[u].size();i++){
		if(!vis[v[u][i]]){
			dfs(v[u][i]);
		}
		b[u]|=b[v[u][i]];
	}
	for(unsigned int i=0;i<g[u].size();i++){
		if(!vis[g[u][i]]){
			dfs(g[u][i]);
		}
		b[u]|=b[g[u][i]];
	}
}
void dfs1(int u){
	dfn[u]=++tot;
	for(unsigned int i=0;i<v[u].size();i++){
		dfs1(v[u][i]);
	}
	ed[u]=++tot;
}
signed main(){
	n=read();m=read();
	for(int i=2;i<=n;i++)f[i]=read(),v[f[i]].pb(i);
	dfs1(1);
	for(int i=1;i<=m;i++)x[i]=read(),y[i]=read(),st[++top]=y[i],g[x[i]].pb(y[i]);
	sort(st+1,st+top+1,cmp);
	for(int i=1;i<=top;i++)pos[st[i]]=i
	dfs(1);
	for(int i=1;i<=top;i++){
		for(int k=1;k<=top;k++){			
			if(dfn[st[i]]<dfn[st[k]] and ed[st[i]]>ed[st[k]])h[i].pb(k);
		}
	}
	for(int i=1;i<=n;i++){
		for(int k=1;k<=top;k++){
			if(b[i][k]){
				for(unsigned int j=0;j<h[k].size();j++)b[i][h[k][j]]=0;
			}
		}
	}
	s=read();
	for(int i=1;i<=s;i++){
		q[i].l=read();q[i].r=read();
	}
	for(int i=1;i<=top;i++){
		int u=st[i];
		int v=f[u];
		head1=head2=0;
		while(v){
			ban[v]=1;
			v=f[v];
		}
		for(int k=1;k<=n;k++){
			s2[k]=s2[k-1];
			if(ban[k])continue;
			if(k!=u and b[k][i])s1[k]++;
			if(dfn[k]>=dfn[u] and ed[k]<=ed[u])s2[k]++;
		}
		for(int k=1;k<=n;k++)s4[k]=s4[k-1]+s1[k]*(s2[n]-s2[k]);
		for(int k=1;k<=n;k++)s1[k]+=s1[k-1];
		for(int k=1;k<=s;k++){
			ans[k]+=(s4[q[k].r]-s4[q[k].l-1]);
			ans[k]-=(s1[q[k].r]-s1[q[k].l-1])*(s2[n]-s2[q[k].r]);
		}
		memset(s1,0,sizeof(s1));
		memset(s2,0,sizeof(s2));
		memset(s4,0,sizeof(s4));
		v=u;
		while(v){
			ban[v]=0;
			v=f[v];
		}
	}
	for(int i=1;i<=s;i++){
		printf("%lld\n",ans[i]);
	}
    return 0;
}


```

---


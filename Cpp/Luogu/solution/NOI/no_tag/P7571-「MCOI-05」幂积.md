# 「MCOI-05」幂积

## 题目背景

书虫有 $10^{10}$ 块金牌！

书虫正在整理他的 $n$ 块金牌。他的金牌分四类，依次为：NOI 金牌，IOI 金牌，IMO 金牌，ICPC WF 金牌。他在第 $1$ 到第 $n$ 天中各 AK 了一场比赛，得到以上类金牌之一。对于给定参数 $k$，第 $i$ 天得到的金牌的价值为 $1$ 如果 $k=0$，为 $i$ 如果 $k=1$。

书虫每天会通过奇妙手段选择他当天应该 AK 什么比赛。对于第 $i$ 天，令 $i=p_1\times p_2\times\dots p_k$，其中 $p_1,p_2,\dots,p_k$ 均为质数。书虫会计算 $x$，其中 $x$ 是 $p_1+p_2+\dots+p_k$ 对 $4$ 取模的余数，并且 AK 第 $x+1$ 类比赛，得到一个第 $x+1$ 类比赛的金牌。

书虫的金牌实在太多了，于是他邀请您帮他计算，他这 $n$ 个金牌里，每一类中的**价值**之和。但是书虫不满足于这个，于是他给您 $m$ 和 $k$，请您对每一个 $1\le i\le\lfloor\sqrt m\rfloor$ 计算当 $n=\lfloor\frac mi\rfloor$ 时候的答案。

## 题目描述

定义函数 $f(\prod p_i^{a_i})=\sum a_ip_i$，其中 $p_i$ 为质数。特别，$f(1)=0$。

对于 $k\in\{0,1\}$，定义函数 $g$ 为：

$$g(n,k,r)=\sum_{i=1}^ni^k[f(i)\equiv r\pmod 4]$$

给定 $m$ 和 $k$，请对所有 $1\le i\le\lfloor\sqrt m\rfloor$，计算所有 $0\le r<4$ 的 $g(\lfloor\frac mi\rfloor,k,r)$ 值。

## 说明/提示

#### 样例 1 解释

$f=[0,2,3,0,1,1,3,2,2,3,\dots]$

#### 数据规模与约定

**本题采用捆绑测试**。

| Subtask | 分数 | $m$ | $k$ |
| - | - | - | - |
| 1 | 5 pts | $\le 10^7$ | 无 |
| 2 | 15 pts | $\le10^9$ | $=0$ |
| 3 | 25 pts | 无 | $=0$ |
| 4 | 25 pts | $\le10^9$ | 无 |
| 5 | 30 pts | 无 | 无 |

对于 $100\%$ 的数据，$1\le m\le10^{10}$，$0\le k\le1$。

## 样例 #1

### 输入

```
10 0```

### 输出

```
2 2 3 3
2 1 1 1
1 0 1 1```

# 题解

## 作者：w33z8kqrqk8zzzx33 (赞：6)



这里给出一个 $\mathcal O(\frac{n^{3/4}}{\log n})$ 解法。

由整除分块结论，对正整数 $n$，有 $|\{\lfloor\frac ni\rfloor:i\in\mathbb Z^+\}|\in O(\sqrt n)$。定义函数 $r:\mathbb Z^+\rightarrow\text{\#}$ 关于 $n$ 的 **块筛** 为 $r$ 在 $\{\lfloor\frac ni\rfloor:i\in\mathbb Z^+\}$ 处的值。

定义一个函数 $r(n)$ 的前缀和函数为 $r^S(n)$，其中

$$r^S(n)=\sum_{i=1}^nr(i)$$

#### 函数建立

建立函数 $g:\mathbb Z^+\rightarrow\mathbb Z/p\mathbb Z[x]$，定义 $g(n)=n^kx^{f(n)\bmod4}$。我们本质想求 $g$ 关于 $n$ 的块筛。由于 $f(n)$ 为加性函数，$n^k$ 为完全积性函数，$n^kx^{f(n)}$ 为积性函数。于是，在 $\mathbb Z/p\mathbb Z[x]/(x^4-1)$ 环下，$g(n)$ 为积性函数；这里乘法为长度为 $4$ 循环卷积，等价于模 $x^4-1$ 的多项式乘法。

由一些理论，得到 $g(n)\mathbb P(n)$ 的块筛即可 $O(\frac{n^{3/4}}{\log n})$ 得到 $g(n)$ 块筛，其中 $\mathbb P(n)$ 为质数指示函数。注意我们在这里\textbf{无法直接筛}（指 min25 筛）因为不存在完全积性函数可以贯穿 $g(n)$ 在质数处；$n^kx^n$ 和 $n^kx^{n\bmod 4}$ 均不为完全积性函数。

#### 求 $g(n)\mathbb P(n)$ 块筛

定 $g_{\mathbb P}(n)=g(n)\mathbb P(n)$，则如果我们展开 $[x^m]g_{\mathbb P}^S(n)$，其中 $0\le m<4$，发现等价于：

$$\sum_{i=1}^ni^k\mathbb P(i)[i\equiv m\pmod 4]$$

这和 min25 step1 所求的东西基本一致，只多了 $[i\equiv m\pmod 4]$。对 $m=0$，上述值为 $0$；对 $m=2$，上述值为 $[2\le n]2^k$。所以实际有 $[x^1]g_{\mathbb P}^S(n)$ 和 $[x^3]g_{\mathbb P}^S(n)$ 的块筛就可以恢复 $g_\mathbb P(n)$ 的块筛。

考虑广义一下 min25 step1 过程。仍然逐个质数筛。定一个递增变量 $p$，$\mathsf{lpf}(i)$ 为 $i$ 的最小质因子；维护：

$$[x^{m|m\in\{1,3\}}]h_p^S(n)=\sum_{i=1}^ni^k[\mathbb P(i)\lor\mathsf{lpf}(i)>p][i\equiv m\pmod 4]$$

初始，$p=0$，需要初始化这东西：

$$\sum_{i=2}^ni^k[i\equiv m\pmod 4]$$

的块筛，这个可以通过等差数列求和公式找到。我们先看上一个质数 $p'$ 怎么更新到下一个质数 $p$，也就是怎么筛走最小质因子等于 $p$ 的合数。注意当 $p>\sqrt n$ 已经筛走所有合数：最小未筛走合数为 $p^2$，可以停止了。

筛走的合数可以表示为 $px$，其中 $\mathsf{lpf}(x)\ge p\iff\mathsf{lpf}(x)>p'$。$x$ 可以为合数，也可以为大于 $p'$ 的质数。以下开始大力分类讨论。$p$，$px$，与 $x$ 均在模 $4$ 意义表示。

1. 若 $p\equiv 1$，$px\equiv 1$，则 $x\equiv 1$。从 $[x^1]h_p^S(n)$ 筛走 $p^k([x^1]h_{p'}^S(\lfloor\frac np\rfloor)-[x^1]h_{p'}^S(p'))$。
2. 若 $p\equiv 1$，$px\equiv 3$，则 $x\equiv 3$。从 $[x^3]h_p^S(n)$ 筛走 $p^k([x^3]h_{p'}^S(\lfloor\frac np\rfloor)-[x^3]h_{p'}^S(p'))$。
3. 若 $p\equiv 3$，$px\equiv 1$，则 $x\equiv 3$。从 $[x^1]h_p^S(n)$ 筛走 $p^k([x^3]h_{p'}^S(\lfloor\frac np\rfloor)-[x^3]h_{p'}^S(p'))$。
4. 若 $p\equiv 3$，$px\equiv 3$，则 $x\equiv 1$。从 $[x^3]h_p^S(n)$ 筛走 $p^k([x^1]h_{p'}^S(\lfloor\frac np\rfloor)-[x^1]h_{p'}^S(p'))$。

其中所有后者为不该筛走的小于等于 $p'$ 质数，可以预处理。

#### 从 $g(n)\mathbb P(n)$ 块筛得 $g(n)$ 块筛

通常 min25 问题只需要我们对积性函数前缀和单点求值，这时候可以用一个更简洁的 $\mathcal O(n^{1-\varepsilon})$ 递归做法。这里先介绍如何将 min25 step2 扩展到计算前缀和函数块筛。感谢 @GuidingStar 提供这一部分详细讲解。

考虑将合数逐个筛回答案，仍然枚举合数最小质因子 $p=p_m$。先丢走 $g(n)$ 为多项式这性质，定义函数

$$F_m(n)=\sum_{i=2}^ng(n)[\textsf{lpf}(i)\ge p_m\lor i\in\mathbb P]$$

则有边界条件

$$F_{\pi(\sqrt n)+1}(n)=g_{\mathbb P}^S(n)$$

考虑如何筛进最小质因子为 $p_m$ 的合数 $C$。有两个情况：第一 $C$ 包含不为 $C$ 的质因子，也就是 $C=p_m^xC'$ 其中 $\textsf{lpf}(C')>p_m$；或者 $C$ 为 $p_m$ 的幂，也就是 $C=p_m^x$ 其中 $x>1$（注意 $x=1$ 情况已经在质数里包含了！）

枚举 $x$；与上一部分类似推到，第一情况的 $C'$ 从 $1\le x\le\frac{n}{p_m^x}$ 的 $\textsf{lpf}(C')>p_m$ 选，第二情况直接算。由 $g(n)$ 的积性性，第一情况可以直接乘 $g(p_m^x)$ 计算贡献。形式化：

$$F_m(n)=F_{m+1}(n)+\sum_{x=1,p_m^x\le n}g(p_m^x)\max(0,F_{m+1}(\lfloor\frac n{p_m^x}\rfloor)-g_{\mathbb P}^S(p_m))+\sum_{x=2,p_m^x\le n}g(p_m^x)$$

整理一下第一部分发现如果有 $\frac{n}{p_m^x}\ge p_m$，等价于 $p_m^{x+1}\le n$，于是直接枚举 $x+1$ 也没事。

$$F_m(n)=F_{m+1}(n)+\sum_{x=1,p_m^{x+1}\le n}g_m(p_m^x)(F_{m+1}(\lfloor\frac n{p_m^x}\rfloor)-g_{\mathbb P}^S(p_m))+g(p_m^{x+1})$$

逐 $m$ 地推，从 $\pi(\sqrt n)+1$ 往 $1$，即可。

这里 $F_m(n)$ 值均在环 $\mathbb Z/p\mathbb Z[x]/(x^4-1)$ 操作，乘法为循环卷积。总共时间复杂度 $\mathcal O(\frac{n^{3/4}}{\log n})$。

---

## 作者：Leasier (赞：4)

前置芝士：[Min_25 筛](https://oi-wiki.org/math/number-theory/min-25/)

~~本来准备把它扔到互测赛 T3 的位置，但因为教练认为难度过大（？？？）没过审。~~

不管是数据范围还是所求的点值均为数论分块处的点值都可以提醒我们可以考虑 Min_25 筛。但所求为一个和性函数，不方便直接操作。

不管怎么样，我们可以先像 Min_25 筛 Part 1 一样退而求其次：先对于 $0 \leq r \leq 3$ 求出 $n$ 以内 $\bmod 4 = r$ 的数的 $k$ 次方和。

当 $r = 0$，答案为 $0$；当 $r = 2$，答案为 $[n \geq 2] 2^k$。

接下来考虑 $r = 1, 3$ 的情况。

这部分不妨沿用 Min_25 筛的递推，但因为我们要对 $r = 1, 3$ 分别求值，考虑将 Min_25 筛的递推改为三维：$g_{i, j, x}$ 表示 $j$ 以内 $\operatorname{lpf} > i$ 且 $\bmod 4 = x$ 的数的 $k$ 次方和，此处 $x = 1, 3$。

考虑即将筛掉的某个质数 $p$。

1. $p \equiv 1 \pmod 4$

此时我们从 $x = 1$ 筛走 $x = 1$，从 $x = 3$ 筛走 $x = 3$。

2. $p \equiv 3 \pmod 4$

此时我们从 $x = 1$ 筛走 $x = 3$，从 $x = 3$ 筛走 $x = 1$。

用 $> 2$ 的所有质数筛掉后特判 $2$ 的贡献即可。

接下来考虑怎样把质数处的答案还原到整体。由于我们所求不是单点，不方便采用常见的 $O(n^{1 - \epsilon})$ 的 dfs 写法。

不妨用类似上述递推的方法将质数处的值还原到整体。

设 $h_{i, j, x}$ 表示 $j$ 以内 $\operatorname{lpf} \geq i$ 且 $\bmod 4 = x$ 的数的 $k$ 次方和。

初值：$h_{\pi(\lfloor \sqrt{n} \rfloor) + 1, i, j} = g_{\pi(\lfloor \sqrt{n} \rfloor), i, j}$。

转移：$h_{i, j, x} = h_{i + 1, j, x} + \displaystyle\sum_{y = 1}^{\lfloor \log_{p_i} j \rfloor - 1} (h_{i + 1, \lfloor \frac{j}{p_i^y} \rfloor, x - yp_i} - \sum_{z = 1}^i [p_z \equiv x \pmod 4] + [p_i^{y + 1} \equiv x \pmod 4])$。

答案：$h_{1, i, j} + [j = 0]$。

实现时开一个结构体做 $\bmod x^4 - 1$ 的循环卷积即可。时间复杂度为 $O(\frac{n^{\frac{3}{4}}}{\ln n})$。

注意需要开 __int128。

代码：
```cpp
#include <stdio.h>
#include <string.h>
#include <math.h>

typedef long long ll;
typedef __int128 lll;

typedef struct Polynomial_tag {
	lll a[7];
	Polynomial_tag(){
		memset(a, 0, sizeof(a));
	}
} Polynomial;

const int N = 1e5 + 7, M = 2e5 + 7;
ll sqrt_n;
int id1[N], id2[N];
ll prime[N], number[M];
bool p[N];
Polynomial g[M], prime_cnt[N], h[M], prime_sum[N];

Polynomial operator -(Polynomial &a, Polynomial &b){
	Polynomial ans;
	for (register int i = 0; i <= 3; i++){
		ans.a[i] = a.a[i] - b.a[i];
	}
	return ans;
}

Polynomial operator -=(Polynomial &a, Polynomial b){
	return a = a - b;
}

Polynomial operator *(Polynomial &a, Polynomial b){
	Polynomial ans;
	for (register int i = 0; i <= 3; i++){
		for (register int j = 0; j <= 3; j++){
			ans.a[(i + j) % 4] += a.a[i] * b.a[j];
		}
	}
	return ans;
}

Polynomial operator +(Polynomial &a, Polynomial &b){
	Polynomial ans;
	for (register int i = 0; i <= 3; i++){
		ans.a[i] = a.a[i] + b.a[i];
	}
	return ans;
}

Polynomial operator +=(Polynomial &a, Polynomial b){
	return a = a + b;
}

inline ll sqrt(ll n){
	ll ans = sqrt((double)n);
	while (ans * ans <= n) ans++;
	return ans - 1;
}

inline lll sum1(ll n){
	return (lll)n * (n + 1) / 2;
}

inline int get_id(ll n, ll m){
	return n <= sqrt_n ? id1[n] : id2[m / n];
}

inline int init(ll n, int m){
	int cnt = 0, id = 0;
	sqrt_n = sqrt(n);
	p[0] = p[1] = true;
	for (register ll i = 2; i <= sqrt_n; i++){
		if (!p[i]) prime[++cnt] = i;
		for (register int j = 1; j <= cnt && i * prime[j] <= sqrt_n; j++){
			p[i * prime[j]] = true;
			if (i % prime[j] == 0) break;
		}
	}
	for (register ll i = 1, j; i <= n; i = j + 1){
		ll tn = n / i;
		j = n / tn;
		id++;
		number[id] = tn;
		if (m == 0){
			for (register int k = 1; k <= 3; k += 2){
				g[id].a[k] = tn >= k ? (tn - k) / 4 + (k == 1 ? 0 : 1) : 0;
			}
		} else {
			for (register int k = 1; k <= 3; k += 2){
				if (tn < k){
					g[id].a[k] = 0;
				} else {
					ll t = (tn - k) / 4;
					g[id].a[k] = sum1(t) * 4 + k * (t + (k == 1 ? 0 : 1));
				}
			}
		}
		if (tn <= sqrt_n){
			id1[tn] = id;
		} else {
			id2[j] = id;
		}
	}
	if (m == 0){
		for (register int i = 1; i <= cnt; i++){
			prime_cnt[i] = prime_cnt[i - 1];
			prime_cnt[i].a[prime[i] % 4]++;
		}
		for (register int i = 2; i <= cnt; i++){
			ll r = prime[i] % 4, t = prime[i] * prime[i];
			for (register int j = 1; j <= id && number[j] >= t; j++){
				int cur_id = get_id(number[j] / prime[i], n);
				if (r == 1){
					g[j].a[1] -= g[cur_id].a[1] - prime_cnt[i - 1].a[1];
					g[j].a[3] -= g[cur_id].a[3] - prime_cnt[i - 1].a[3];
				} else {
					g[j].a[1] -= g[cur_id].a[3] - prime_cnt[i - 1].a[3];
					g[j].a[3] -= g[cur_id].a[1] - prime_cnt[i - 1].a[1];
				}
			}
		}
		for (register int i = 1; i <= id; i++){
			if (i < id) g[i].a[2]++;
			h[i] = g[i];
		}
		for (register int i = cnt; i >= 1; i--){
			ll t = prime[i] * prime[i];
			for (register int j = 1; j <= id && number[j] >= t; j++){
				int x = 1;
				for (register ll y = prime[i]; y * prime[i] <= number[j]; x++, y *= prime[i]){
					Polynomial poly;
					poly.a[x * prime[i] % 4] = 1;
					h[j] += poly * (h[get_id(number[j] / y, n)] - prime_cnt[i]);
					h[j].a[prime[i] * (x + 1) % 4]++;
				}
			}
		}
	} else {
		for (register int i = 1; i <= cnt; i++){
			prime_sum[i] = prime_sum[i - 1];
			prime_sum[i].a[prime[i] % 4] += prime[i];
		}
		for (register int i = 2; i <= cnt; i++){
			ll r = prime[i] % 4, t = prime[i] * prime[i];
			for (register int j = 1; j <= id && number[j] >= t; j++){
				int cur_id = get_id(number[j] / prime[i], n);
				if (r == 1){
					g[j].a[1] -= prime[i] * (g[cur_id].a[1] - prime_sum[i - 1].a[1]);
					g[j].a[3] -= prime[i] * (g[cur_id].a[3] - prime_sum[i - 1].a[3]);
				} else {
					g[j].a[1] -= prime[i] * (g[cur_id].a[3] - prime_sum[i - 1].a[3]);
					g[j].a[3] -= prime[i] * (g[cur_id].a[1] - prime_sum[i - 1].a[1]);
				}
			}
		}
		for (register int i = 1; i <= id; i++){
			if (i < id) g[i].a[2] += 2;
			h[i] = g[i];
		}
		for (register int i = cnt; i >= 1; i--){
			ll t = prime[i] * prime[i];
			for (register int j = 1; j <= id && number[j] >= t; j++){
				int x = 1;
				for (register ll y = prime[i]; y * prime[i] <= number[j]; x++, y *= prime[i]){
					Polynomial poly;
					poly.a[x * prime[i] % 4] = y;
					h[j] += poly * (h[get_id(number[j] / y, n)] - prime_sum[i]);
					h[j].a[prime[i] * (x + 1) % 4] += y * prime[i];
				}
			}
		}
	}
	return cnt;
}

void write(lll n){
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
}

int main(){
	int k;
	ll m;
	scanf("%lld %d", &m, &k);
	init(m, k);
	for (register ll i = 1; i <= sqrt_n; i++){
		for (register int j = 0; j <= 3; j++){
			write(h[i].a[j] + (j == 0 ? 1 : 0));
			putchar(' ');
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：JohnVictor (赞：3)

口胡一波。

从自由度的角度我们考虑 DFT，也就是只用算出所有的 $g(n,k,0)+wg(n,k,1)+w^2g(n,k,2)+w^3g(n,k,3)$，其中 $w$ 取遍四次单位根 $1,i,-1,-i$。

此时我们就可以把这些 $g$ 的和拆成一个了，拆出来的结果是

$\sum_{t=1}^n w^{f(t)}t^k$，因为 $w^{f(t)} $ 和 $t^k$ 都是积性的，所以问题变成一个积性函数前缀和，而这个积性函数和 $1$ 的狄利克雷卷积容易计算（仍然是积性的，线性筛预处理出小的，大的用 pollard 分解之后直接用积性进行计算），杜教筛出即可，正好把要求的都求了出来。

实现的时候直接维护复数类即可。

~~退役人没有代码。~~

---


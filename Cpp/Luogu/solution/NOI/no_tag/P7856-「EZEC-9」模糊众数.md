# 「EZEC-9」模糊众数

## 题目描述

给你一个长为 $n$ 的序列 $a$。

你可以将序列中的某个数增加 $1$，称为一次操作。

你需要处理 $q$ 次询问。

对于每次询问，求出 $a$ 在至少多少次操作后，可以形成一个序列 $a'$，使得 $x$ 为 $a'$ 的众数。

**注意：一个序列可能有多个众数。**

## 说明/提示

**【样例 1 解释】**

- $x=2$ 时，一种可行的方案为 $a'=[1,2,2,3,3,4]$。
- $x=10$ 时，一种可行的方案为 $a'=[1,2,3,4,5,10]$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$n=3$。
-  Subtask 2（5 points）：所有 $a_i$ 均相等，**时间限制为 2000 ms**。
-  Subtask 3（5 points）：$n\le 10$，$q\le 10^3$。
-  Subtask 4（15 points）：$n\le 100$，$q\le 10^4$。
-  Subtask 5（15 points）：$n\le 10^3$。
-  Subtask 6（15 points）：$q\le 10^3$。
-  Subtask 7（40 points）：**时间限制为 2000 ms**。

对于 $100\%$ 的数据，$1\le n,q\le 10^5$，$1\le a_i,x\le 10^9$。

## 样例 #1

### 输入

```
6 2
1 1 1 3 3 3
2
10
```

### 输出

```
3
13
```

# 题解

## 作者：whiteqwq (赞：5)

[P7856 「EZEC-9」模糊众数](https://www.luogu.com.cn/problem/P7856) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/16708563.html)

## 题意

给定一个长度为 $n$ 的序列，一次操作可以将某个数字加一，多次询问一个数 $x$，求使得 $x$ 称为序列众数至少要多少次操作。

$1\leqslant n,q\leqslant 10^5$。

## 分析

由于没有代码，如果假掉希望有老哥提醒一下我（

使 $x$ 变成众数很难考虑，不妨假定得到了众数的出现次数 $k$，此时我们只需保证所有数出现次数不超过 $k$ 以及 $x$ 出现次数达到 $k$ 即可。

按照数字大小从大到小枚举每个数，若一个数出现次数超过了 $k$ 就将其多余的部分放到后面，询问一个位置只需线段树二分出其前 $k$ 个数字，可以在 $O(n\log n)$ 内解决。

若每组询问的 $k$ 不相同呢？枚举 $k$ 的取值，找到原序列中出现次数超过 $k$ 的所有数，将其多余部分丢到后面去。直接实现这一过程会退化到 $O(n\log^2 n)$（枚举总量为 $O(n\ln n)$），但我们可以精细处理此过程。

从大到小枚举 $k$ 的取值，将多余部分丢到后面时，只需判断是否会新增位置放置多余的数（新增次数大于一也没关系，一个数向后新增位置次数总和等于这个数初始出现次数），这样就做到了 $O(n\log n)$。

事实上，对于每个 $x$，这个 $k$ 都是可三分的，于是可以对所有询问整体三分并每次调用上面的算法。（我们不能分治地实现这一过程，而是需要逐层处理）

三分性也很好证明，只需说明在 $k\leftarrow k-1$ 的过程中，保证所有数出现次数不超过 $k$ 的新增代价与让 $x$ 出现次数达到 $k$ 的新增代价均不降。

可以发现一个数若对 $k$ 的第一部分产生了贡献，其必然对 $k-1$ 的第一部分也产生贡献，于是第一部分不降，第二部分由贪心性显然。

时间复杂度 $O((n+q)\log^2 n)$。

## 代码

有点难写，先咕着。

---

## 作者：LZDQ (赞：5)

对于一组询问，我们记 $v$ 为询问希望得到的众数，$x$ 为最后众数出现的次数。这个问题可以用费用流来描述，对坐标离散化并预留足够的溢出位置后，相邻两个点连一条边，$v$ 这个位置向汇点连一条带上下界的边，其他地方连一条带上界的边。于是我们可以得到一个结论，令 $f(x)=y$ 表示答案，则 $f$ 是一个下凸函数。当然不用费用流也可以得到类似的结论。

现在解决给定 $v,x$ 求答案。根据费用流的建模，要让 $x$ 个数变成 $v$，一定可以看作是把最近的 $x$ 个数变成 $v$。所以我们只需要解决对于序列的每个前缀和后缀，需要多少次操作才能使得众数的出现次数不超过 $x$。

考虑根号分治。令块长为 $B$，对于 $x\le B$ 的部分，每个 $x$ 用 $O(n)$ 预处理。对于 $x>B$ 的部分，显然不合法的位置至多有 $\frac nB$ 个，总变化量是 $O(\frac nB)$ 级别的。

我们枚举每个 $x\le B$ 并更新答案。剩下的部分使用二分，二分到最后一个斜率为负的位置，就是最小值。总复杂度 $O(Bn+\frac nB\log n)$，取 $B=\sqrt {n\log n}$ 即可做到 $O(n\sqrt{n\log n})$。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
typedef long long ll;
const int MAXN=1e5+5;
int n,q,a[MAXN],B,op[MAXN][2];
int all[MAXN],cnt[MAXN],_cnt[MAXN];
ll sum[MAXN];
ll f1[MAXN],g1[MAXN],f2[MAXN],g2[MAXN];
void Solve(int x,ll *f,ll *g){
	int l=0,c=0;
	ll res=0;
	for(int i=1; i<=n; i++){
		while(l<a[i]){
			if(c<=x){
				c=0;
				break;
			}
			c-=x;
			res+=c;
			l++;
		}
		l=a[i];
		c++;
		ll k=c/x;
		f[i]=res+c*k-x*k*(k+1)/2;
	}
	static int sx[MAXN],sy[MAXN],top;
	top=0;
	res=0;
	for(int i=n,j=n+1; i; i--){
		while(j>n||all[j]!=a[i]){
			j--;
			top++;
			sx[top]=all[j];
			sy[top]=0;
		}
		res+=sx[top]-a[i];
		if(++sy[top]==x) top--;
		g[i]=res;
	}
	return ;
}
vector<int> vec;
int chg[MAXN];
ll Calc1(int w,int x){
	if(!w) return 0;
	int _w=lower_bound(a+1,a+n+1,a[w])-a;
	_w=w-_w+1;
	w=lower_bound(all+1,all+n+1,a[w])-all;
	chg[*chg=1]=w;
	cnt[w]=_w;
	ll res=0;
	for(int i=0; i<vec.size(); i++){
		int k=vec[i];
		if(k>=w) break;
		if(cnt[k]>x) chg[++*chg]=k;
		while(k<w&&cnt[k]>x){
			chg[++*chg]=k+1;
			cnt[k+1]+=cnt[k]-x;
			res+=cnt[k]-x;
			cnt[k]=x;
			k++;
		}
	}
	while(cnt[w]>x){
		res+=cnt[w]-x;
		cnt[w]-=x;
	}
	for(int i=1; i<=*chg; i++)
		cnt[chg[i]]=_cnt[chg[i]];
	return res;
}
ll Calc2(int w,int x){
	if(w>n) return 0;
	int _w=upper_bound(a+1,a+n+1,a[w])-a-1;
	_w=_w-w+1;
	w=lower_bound(all+1,all+n+1,a[w])-all;
	chg[*chg=1]=w;
	cnt[w]=_w;
	ll res=0;
	for(int i=lower_bound(vec.begin(),vec.end(),w)-vec.begin(); i<vec.size(); i++){
		int k=vec[i];
		if(cnt[k]>x) chg[++*chg]=k;
		while(cnt[k]>x){
			chg[++*chg]=k+1;
			cnt[k+1]+=cnt[k]-x;
			res+=cnt[k]-x;
			cnt[k]=x;
			k++;
		}
	}
	for(int i=1; i<=*chg; i++)
		cnt[chg[i]]=_cnt[chg[i]];
	return res;
}
bool vis[MAXN];
ll ans[MAXN];
int main(){
	scanf("%d%d",&n,&q);
	B=min(800,n);
	for(int i=1; i<=n; i++)
		scanf("%d",a+i);
	if(n==1){
		while(q--){
			int x;
			scanf("%d",&x);
			if(x>=a[1]) printf("%d\n",x-a[1]);
			else puts("-1");
		}
		return 0;
	}
	sort(a+1,a+n+1);
	for(int i=1; i<=n; i++)
		all[i]=max(all[i-1]+1,a[i]),sum[i]=sum[i-1]+a[i];
	for(int i=1,j=1; i<=n; i++){
		while(all[j]!=a[i]) j++;
		cnt[j]++;
	}
	for(int i=1; i<=n; i++)
		if(cnt[i]>B) vec.push_back(i);
	memcpy(_cnt,cnt,sizeof(cnt));
	Solve(B,f1,g1);
	Solve(B-1,f2,g2);
	for(int i=1; i<=q; i++){
		scanf("%d",op[i]);
		int v=op[i][0];
		int w=upper_bound(a+1,a+n+1,v)-a-1,x;
		op[i][1]=w;
		if(w>=B){
			x=B;
			ll y1=f1[w-x]+g1[w+1]+(1ll*v*x-(sum[w]-sum[w-x]));
			x--;
			ll y2=f2[w-x]+g2[w+1]+(1ll*v*x-(sum[w]-sum[w-x]));
			if(y1>=y2) vis[i]=1,ans[i]=-1;
			else{
				int l=B,r=w;
				while(l<r){
					int mid=l+r>>1;
					x=mid;
					y1=Calc1(w-x,x)+Calc2(w+1,x)+(1ll*v*x-(sum[w]-sum[w-x]));
					x++;
					y2=Calc1(w-x,x)+Calc2(w+1,x)+(1ll*v*x-(sum[w]-sum[w-x]));
					if(y1<y2) r=mid;
					else l=mid+1;
				}
				x=l;
				ans[i]=Calc1(w-x,x)+Calc2(w+1,x)+(1ll*v*x-(sum[w]-sum[w-x]));
			}
		}else vis[i]=1,ans[i]=-1;
	}
	for(int x=1; x<=B; x++){
		Solve(x,f1,g1);
		bool ok=0;
		for(int i=1; i<=q; i++)
			if(vis[i]){
				int v=op[i][0],w=op[i][1];
				if(x>w){
					vis[i]=0;
					continue;
				}
				ll y=f1[w-x]+g1[w+1]+(1ll*v*x-(sum[w]-sum[w-x]));
				if(x>1&&y>=ans[i]){
					vis[i]=0;
					continue;
				}
				ans[i]=y;
				ok=1;
			}
		if(!ok) break;
	}
	for(int i=1; i<=q; i++)
		printf("%lld\n",ans[i]);
	return 0;
}
```

之前写挂的原因：复制了一行代码忘改一点东西，两个函数对着写，结果第二个函数写反了。改进行修改的没修改。q 写成 n。总结：千万不要复制代码，总是忘改东西，也不要对着之前的代码写。


---

## 作者：_lbw_ (赞：2)

首先我们可以考虑先枚举众数的出现次数 $c$，至于怎么优化后面再说。

我们可以考虑一个贪心，先将初始状态每个数的出现次数为数组 $a$。

然后从小到大扫 $a$，如果当前位置值 $a_i$ 大于 $c$ 则把 $a_{i}-c$ 个 $i$ 往后移一格。

而我们还要满足 $a_x=c$，于是在做完上述过程后选取  $\leq x$ 的最大的 $c$ 个数移动到 $c$ 即可。（这里可以在做完前面的操作后再选取的原因是我们不会在前面不够 $c$ 的情况下往后移动）。

我们观察到：$\forall c$，终止状态和初始状态不一样的位置个数是 $\mathcal{O}(\dfrac nc)$ 的。

Prove：考虑变化的位置满足要么这个位置 $a_i$ 是 $c$ 要么前面一个位置是 $c$，故 $c$ 的权值最多只能贡献两个答案。

但如果直接初始先枚举一遍 $c$，我们发现无法方便的描述贡献。

我们进行大胆的猜测：答案关于 $c$ 是凸的！打表可以验证。

于是我们可以三分，这个时候再套个主席树，我们发现空间是 $n\ln n\log V$ 的，出题人不知道为什么空间开的是 128M，根本过不去。

但我们还可以整体二分斜率，同时观测到线段树只有 $\mathcal{O}(n)$ 个叶子是有用的，离散化之，空间 $\mathcal{O}(n)$，时间 $\mathcal{O}(n\log^2 n)$。

注意这题比较卡常，不离散化很难过去。

怒斥 whiteqwq 不给代码的行为！！！！！因此代码如下：

```cpp
#define ll long long
#define I ll
#define her1 20081214
#define IV void
#define cht 998244353
#define ull unsigned long long
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define E(i,now)for(register int i=first[now];i;i=e[i].nxt)
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define DL(i,j,n)for(register i64 i=j;i>=n;i--)
#define EL(i,now)for(register i64 i=first[now];i;i=e[i].nxt)
#define FL(i,j,n)for(register i64 i=j;i<=n;i++)
#undef ll
#include "assert.h"
mt19937_64 rnd(her1);
#include "functional"
using i64 = long long;
#define My_assert(expr,tips) ((expr)?(void(0)):(puts(tips),exit(0)))
const i64 MAX = 2e9;
const int maxn = 1e5+5;
const int maxm = 32*maxn+5;
map<i64,i64>mp;vector<i64>V[maxn];
i64 n,q,a[maxn],b[maxn],tot,Ans[maxn];
IV cmin(i64&x,i64 val){x>val?x=val,0:0;}
int Ls[maxm],Rs[maxm],rt,Tc,cnt[maxm];i64 val[maxm];
IV M(int&o,i64 l,i64 r,i64 p,i64 v){
	if(!o)o=++Tc;cnt[o]+=v;val[o]+=v*b[p];if(l==r)return;
	i64 mid=l+r>>1;p<=mid?M(Ls[o],l,mid,p,v):M(Rs[o],mid+1,r,p,v);
}
i64 Qp(i64 x){
	return upper_bound(b+1,b+1+tot,x)-b-1;
}
i64 s2=0;
i64 Qc(int o,int l,int r,int x,int y){
	if(r<x||l>y||!o)return 0;if(x<=l&&r<=y)return s2+=val[o],cnt[o];
	i64 mid=l+r>>1;return Qc(Ls[o],l,mid,x,y)+Qc(Rs[o],mid+1,r,x,y);
}
i64 Q(i64 o,i64 l,i64 r,i64 R){
	if(l==r)return b[l]*R;i64 mid=l+r>>1,tmp=cnt[Ls[o]];
	if(R<=tmp)return Q(Ls[o],l,mid,R);return val[Ls[o]]+Q(Rs[o],mid+1,r,R-tmp);
}
i64 Sum=0,sv,K;
vector<pair<int,int> >vi;
IV calc(i64 i){
	Sum=0;K=i;
	F(j,0,(i64)V[i].size()-1){
		i64 x=V[i][j];
		while((j+1==V[i].size()||x<V[i][j+1])&&mp[x]>=i){
			if(mp[x]>i){
				i64 px=Qp(x),px1=px+1;
				vi.push_back({px,i-mp[x]});vi.push_back({px1,mp[x]-i});
				Sum+=mp[x]-i,M(rt,1,n,px,i-mp[x]),M(rt,1,n,px1,mp[x]-i);
			}
			mp[x+1]+=mp[x]-i,mp[x]=i;x++;
		}
	}
}
IV clr(){
	for(auto[x,v]:vi)mp[b[x]]-=v,M(rt,1,n,x,-v);
	vector<pair<int,int> >nw;nw.swap(vi);
}
i64 Getans(i64 v){
	i64 nv=Qp(v);
	s2=0;i64 Ra=Qc(rt,1,n,1,nv);if(Ra<K)return 1e18;
	return v*K-(s2-Q(rt,1,n,Ra-K))+Sum;
}
i64 vA[maxn],vB[maxn];
IV cdq(i64 l,i64 r,vector<pair<int,int> >V){
	if(V.empty())return;
	if(r-l+1<=3){
		i64 L=l,R=r;
		if(L!=1)L++;if(R!=n)R--;
		F(i,L,R){
			calc(i);
			for(auto[val,id]:V)
				cmin(Ans[id],Getans(val));
			clr();
		}
		return;
	}
	i64 mid=l+r>>1;
	vector<pair<int,int> >ql,qr;
	calc(mid);for(auto[val,id]:V)vA[id]=Getans(val);clr();
	calc(mid+1);for(auto[val,id]:V)vB[id]=Getans(val);clr();
	for(auto[val,id]:V){
		cmin(Ans[id],vA[id]);cmin(Ans[id],vB[id]);
		if(vB[id]==1e18)ql.push_back({val,id});
		else if(vA[id]<vB[id])ql.push_back({val,id});
		else qr.push_back({val,id});
	}
	cdq(l,mid,ql);cdq(mid+1,r,qr);
}
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();q=read();
	F(i,1,n)mp[a[i]=read()]++;sort(a+1,a+1+n);i64 now=0;
	F(i,1,n)if(now>=a[i])b[++tot]=++now;else b[++tot]=now=a[i];
	for(auto[x,c]:mp){
		F(i,1,c)V[i].push_back(x);
		M(rt,1,n,Qp(x),c);
	}
	F(i,1,q)Ans[i]=1e18;
	sv=tot;vector<pair<int,int> >V;F(i,1,q)V.push_back({read(),i});
	cdq(1,n,V);F(i,1,q)printf("%lld\n",Ans[i]==1e18?-1:Ans[i]);
	return 0;
}
```

---


# 『JROI-4』少女幻葬

## 题目背景

[该题原题目背景](https://www.luogu.com.cn/paste/imhwx32x)

[少女幻葬](https://thwiki.cc/%E5%B0%91%E5%A5%B3%E5%B9%BB%E8%91%AC_%EF%BD%9E_Necro-Fantasy)是八云蓝的主题曲，同样也是东方妖妖梦 extra stage 的 boss 战音乐。

是使用 ZUN 号的音乐中最为经典的一首之一。钢琴声仿佛在描绘一个强大而又美丽的妖兽的形象，而嘹亮的 ZUN 号配合蓝华丽的弹幕将死亡的主题表现到了极致。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，并给出序列第 $i$ 个数 $a_i$ 的取值范围 $[l_i,r_i]$。现在蓝想知道有多少个序列 $a$ 满足对于给定的常数 $k$，有：

- 任意相邻两数的最大公因数都不为 $k$； 

- 任意相邻三数的最大公因数都恰好为 $k$。

 由于答案可能很大，请输出其 $\bmod \space998244353$ 的值。

## 说明/提示

【样例解释】

对于样例 $1$，可行的序列有：$[2,6,3],[3,6,4],[4,6,3]$。

【数据范围及约定】

- Subtask1（7pts）$3 \leq n \leq 5$，$1 \leq m \leq 10$。
- Subtask2（23pts）$3 \leq n \leq 100$，$1 \leq m \leq 100$。
- Subtask3（25pts）$3 \leq n \leq 1000$，$1 \leq m \leq 1000$。
- Subtask4（45pts）无特殊限制。

对于 $100\%$ 的数据，满足 $3 \leq n \leq 2000$，$1 \leq l_i \leq r_i \leq 5000$，$1 \leq k \leq 5000$。

其中 $m=\max_{i=1}^{n}r_i$。

## 样例 #1

### 输入

```
3 1
1 6
2 6
3 6```

### 输出

```
3```

## 样例 #2

### 输入

```
4 1
11 45
19 81
31 53
7 28```

### 输出

```
6295```

# 题解

## 作者：Sol1 (赞：8)

蓝可爱 /qq

似乎是一个复杂度略微更低的做法。

设 $f_{i,j,k}$ 表示固定前 $i$ 个数，$a_i=k$，同时 $\gcd(a_i,a_{i-1})=j$ 的方案数；$g_{i,j,k}$ 表示固定前 $i$ 个数，$a_i=k$，并且固定 $\gcd(a_i,a_{i+1})=j$ 的方案数。

首先考虑 $f$ 到 $g$ 的转移：

$$g_{i,j,k}=\sum_{v|j} f_{i-1,j,v}[\gcd(v,k)=j]$$

考虑枚举 $j$ 然后把 $j$ 整体除掉，然后就变成了如下形式：

$$g_{k}=\sum_{v}f_v[v\perp k]$$

直接莫反：

$$g_k=\sum_{v}f_v\sum_{t|v,t|k}\mu(t)=\sum_{t|k}\mu(t)\sum_{t|v}f_v$$

所以 $f$ 到 $g$ 的转移就是枚举 $f$ 的前两维，对第三维迪利克雷后缀和，逐点乘 $\mu$，再迪利克雷前缀和即可，处理上下界只需要把超出限制的状态值改为 $0$。这部分复杂度 $O(nm\log m\log\log m)$。



再考虑 $g$ 到 $f$ 的转移：

$$f_{i,j,k}=\sum_{p|k}g_{i,p,k}[p\perp j]$$

枚举 $k$，考虑 $j$ 的质因子集合 $S_1$ 和 $p$ 的质因子集合 $S_2$ 需要满足 $S_1\cap S_2=\varnothing$，那么可以对所有 $p|k$，将 $p$ 对应的质因子集合 $S_1$ 的 $h_{S_1}$ 加上 $g_{i,p,k}$；对 $h$ 高维前缀和之后，设 $j$ 对应质因子集合 $S_2$，$f_{i,j,k}$ 的值就是 $h_{\overline{S_2}}$。

这部分复杂度 $O(nm\log m+n\sum_{i=1}^m\omega(i)2^{\omega(i)})$。考虑到 $\max\limits_{i\leq n}\omega(i)=O\left(\dfrac{\log n}{\log\log n}\right)$，同时 $2^{\omega(i)}\leq d(i)$，可以得到一个粗略的复杂度上界 $O\left(\dfrac{nm\log^2m}{\log\log m}\right)$。（实际上 $\sum_{i=1}^m\omega(i)2^{\omega(i)}$ 在 $m=5000$ 的时候只有 $9\times 10^4$ 左右，所以可能实际复杂度接近 $O(nm\log m\log\log m)$。）

```cpp
inline void Solve() {
	for (int i = 2;i <= v;i++) {
		for (int j = i;j <= v;j += i) {
			if (j >= l[1] && j <= r[1]) g[mp[i][j]] = 1;
		}
	}
	for (int i = 1;i < n;i++) {
		// g->f
		for (int j = 2;j <= v;j++) {
			for (int k = j;k <= v;k += j) tmp[k / j] = g[mp[j][k]];
			int mx = v / j;
			for (int k = 1;k <= pcnt;k++) {
				if (pri[k] > mx) break;
				for (int x = mx / pri[k] * pri[k];x >= pri[k];x -= pri[k]) tmp[x / pri[k]] = Add(tmp[x / pri[k]], tmp[x]);
			}
			for (int k = 1;k <= mx;k++) tmp[k] = (tmp[k] * mu[k] % mod + mod) % mod;
			for (int k = 1;k <= pcnt;k++) {
				if (pri[k] > mx) break;
				for (int x = pri[k];x <= mx;x += pri[k]) tmp[x] = Add(tmp[x], tmp[x / pri[k]]);
			}
			for (int k = j;k <= v;k += j) f[mp[j][k]] = tmp[k / j];
		}
        for (int j = 2;j <= v;j++) {
            for (int k = j;k <= v;k += j) {
                if (k < l[i + 1] || k > r[i + 1]) f[mp[j][k]] = 0;
            }
        }
		// f->g
		for (int j = 2;j <= v;j++) {
            for (int k = 0;k < (1 << tpw[j]);k++) sdp[k] = 0;
            for (int k = 1;k <= tpd[j];k++) {
                if (d[j][k] == 1) continue;
                sdp[subs[mp[d[j][k]][j]]] = Add(sdp[subs[mp[d[j][k]][j]]], f[mp[d[j][k]][j]]);
            }
            for (int k = 0;k < tpw[j];k++) {
                for (int s = 0;s < (1 << tpw[j]);s++) {
                    if (s & (1 << k)) sdp[s] = Add(sdp[s], sdp[s ^ (1 << k)]);
                }
            }
            for (int k = 1;k <= tpd[j];k++) {
                if (d[j][k] == 1) continue;
                g[mp[d[j][k]][j]] = sdp[((1 << tpw[j]) - 1) ^ subs[mp[d[j][k]][j]]];
            }
		}
	}
    long long ans = 0;
    for (int i = 1;i <= c;i++) ans = Add(ans, f[i]);
    cout << ans << endl;
}
```











---

## 作者：Prean (赞：5)

## Subtask1
使用搜索，可以获得比上一题还高的 $7$ 分！
## Subtask2
设 $dp[n][m][k]$ 表示当前计算到序列的第 $n$ 个位置，$\gcd(a[n],a[n-1])=m,a[n]=mk$ 的序列的数量。

直接根据条件暴力枚举就好了，复杂度 $O(nm^2\log m)$。
## Subtask3
开始推式子。

转移方程的形式为 $dp[n][x][A]=\sum[\gcd(x,y)=1][\gcd(A\times x,B\times y)=x]dp[n-1][y][B]$。

接下来为了方便，设 $f=dp[n],g=dp[n-1]$：
$$f[x][A]=\sum[\gcd(x,y)=1][\gcd(A \times x,B \times y)=x]g[y][B]$$
$$f[x][A]=\sum[\gcd(x,y)=1]\sum_{d \mid A,d \mid By/x}\mu(d)g[y][B]$$
枚举 $(y,B)$，然后存下因子和与自己互质的数后暴力转移即可。复杂度大概是 $O(nm^{\frac{5}{3}})$ 或 $O(nm^2)$ 的，但是因为跑不满能够通过。
## Subtask4
考虑对上述算法进行优化。

直接精细实现即可。开一个数组 $F$ 用来存 $g$ 那一堆东西的狄利克雷后缀和，然后再做一个狄利克雷后缀和给转移到 $f$ 上。

枚举前面狄利克雷后缀和的数组中，枚举的总复杂度是 $O(\sum_{i=1}^{n}\sum_{j=1}^{n}\lfloor\frac{n}{ij}\rfloor[\gcd(i,j)=1])=O(\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor2^{\Omega(i)})$。

算一下可以知道上面那玩意儿在 $m=5000$ 的时候只有 $159390$，而且常数巨小，可以直接莽。

上述部分的具体的复杂度可以见[这里](https://www.luogu.com.cn/paste/h3lkw29y)，复杂度为 $O(m\log^2m)$。

狄利克雷卷积部分的复杂度是 $O(\sum_{i=1}^{m}\lfloor\frac{m}{i}\rfloor\log\lfloor\frac{m}{i}\rfloor)=O(m\log^2m)$，常数也非常小。

标算只跑了 1.6s，复杂度 $O(nm\log^2m)$。
```cpp
inline void init(){
	ui i,j,x,*now;mu[1]=1;
	for(i=1;i<=n;++i)if(r[i]>m)m=r[i];
	for(now=buf1,i=1;i<=m;++i)f[i]=now,now+=m/i+1;f[m+1]=now;
	for(now=buf2,i=1;i<=m;++i)g[i]=now,now+=m/i+1;g[m+1]=now;
	for(now=buf,i=1;i<=m;++i)for(C[i]=now,j=1;i*j<=m;++j)if(gcd(i,j)==1)*now++=j;C[m+1]=now;
	for(i=2;i<=m;++i){
		if(!pos[i])pri[pos[i]=++top]=i,mu[i]=mod-1;
		for(j=1;j<=pos[i]&&(x=i*pri[j])<=m;++j)if((pos[x]=j)!=pos[i])mu[x]=mod-mu[i];
	}
}
inline void trans(){
	ui x,y,i,j;
	for(x=1;x<=m;++x){
		const ui&n=m/x;
		for(i=0;i<=n;++i)g[x][i]=F[i]=0;
		for(ui*it=C[x];it!=C[x+1];++it){
			for(y=*it,i=1;i*y<=n;++i)Mod(F[i*y]+=f[y][i*x]);
		}
		for(i=1;i<=n;++i)for(j=2;i*j<=n;++j)Mod(F[i]+=F[i*j]);
		for(i=n;i>=1;--i)if(y=1ull*mu[i]*F[i]%mod)for(j=1;i*j<=n;++j)Mod(g[x][i*j]+=y);
	}
}
```

---

## 作者：Purslane (赞：3)

# Solution

大家好啊，我是安徽队长 Reunite。今天我发明了快速 $\gcd$ 变换，大家快来学习！！！

-------

Reunite 说这是联考的某道题的弱化版（其实一模一样）。他在打模拟赛的时候想到了一个快速 $\gcd$ 变换，我按照他的思路实现了出来。

首先，不妨设 $k=1$。转化为——任意相邻两个数不互质，任意相邻三个数互质。

设 $dp_{i,j,k}$ 表示，只考虑前 $i$ 个数，有多少种数列满足 $a_i = j$ 且 $\gcd(a_i,a_{i-1}) = k$。显然这样的 $(j,k)$ 只有 $O(V \ln V)$ 对。

考虑转移。枚举 $a_{i+1}$ 的取值 $a$，则有：

$$
dp_{i+1,a,\gcd(a,j)} \leftarrow dp_{i+1,a,\gcd(a,j)} + [\gcd(a,k) = 1] dp_{i,j,k}
$$

显然要考虑莫比乌斯反演，枚举 $d \mid \gcd(a,k)$ 有：

$$
dp_{i+1,a_0d,\gcd(a_0d,j)} \leftarrow dp_{i+1,a_0d,\gcd(a_0d,j)} + \mu(d) dp_{i,j,k_0d}
$$

枚举 $d$ 的时候，发现第三维已经不重要，所以记录 $f_j = \mu(d) \sum_{k_0} dp_{i,j,k_0d}$。显然 $d \mid j$。

我们枚举 $a_0d = a$，相当于做了这样一个事情：

$$
dp_{i+1,a,\gcd(a,j)} \leftarrow dp_{i+1,a,\gcd(a,j)} + f_j
$$

注意到 $a$ 和 $j$ 一定都是 $d$ 的倍数，所以我们可以现将他们除以 $d$，做这个运算再乘回去。

考虑一个叫做 $\gcd$ 卷积的东西。给定数组 $u_i$ 和 $v_i$，我们需要求出 $w_k = \sum_{\gcd(i,j) = k} u_iv_j$。发现这个东西和 $\rm FMT$ 没啥本质区别，只需要先求狄利克雷后缀和，乘起来再差分即可。

将该操作看为 $f_j$ 和 $g_j=[j=a]$ 的 $\rm gcd$ 卷积。

如果直接做，比暴力还劣。但是考虑 $g_j$ 求狄利克雷后缀和之后只有 $O(d(j))$ 个非 $0$ 位置，我们只需要处理这些非 $0$ 位置即可。

时间复杂度大概是 $O(n V \log^2 V)$，卡常能过。

卡常小技巧：避免 `vector` 循环，**避免数组嵌套**。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2000+5,MAXM=5000+5,MAXK=43376+5,MOD=998244353;
int n,k,s[MAXM],l[MAXN],r[MAXN],mu[MAXM],flg[MAXM],id[MAXM*MAXM];
ll dp[2][MAXM*MAXM],f[MAXM],tmp[MAXM];
vector<int> pr;
int zzz[MAXM],frac[MAXK],St[MAXM],Lst[MAXM],len[MAXM],pfr[MAXM*20],pc[MAXM];
void init(int mx) {
	mu[1]=1;
	ffor(j,1,mx) for(int i=j;i<=mx;i+=j) zzz[i]++;
	ffor(i,1,mx) St[i]=Lst[i-1]+1,Lst[i]=St[i]+zzz[i]-1;
	ffor(j,1,mx) for(int i=j;i<=mx;i+=j) frac[St[i]+(++len[i])-1]=j;
	ffor(i,2,mx) {
		if(!flg[i]) pr.push_back(i),mu[i]=-1;
		for(auto v:pr) {
			if(i*v>mx) break ;
			flg[i*v]=1;
			if(i%v==0) break ;
			mu[i*v]-=mu[i];
		}
	}
	ffor(i,1,mx) for(auto p:pr) if(i%p==0) pfr[i*11+(++pc[i])]=p;
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
 	cin>>n>>k;
 	ffor(i,1,n) cin>>l[i]>>r[i],r[i]=r[i]/k,l[i]=(l[i]+k-1)/k;
//	n=2000,k=1;
//	ffor(i,1,n) l[i]=1,r[i]=5000;
	ffor(i,1,n) if(l[i]>r[i]) return cout<<0,0;
	int tot=0;
	ffor(i,1,5000) s[i]=s[i-1]+5000/i;
	ffor(i,l[1],r[1]) dp[1][i]++;
	init(5000);
	ffor(i,2,n) {
		int st=(i&1),lst=st^1;
		ffor(d,1,5000) if(mu[d]) {
			int m=5000/d;
			ffor(j,1,m) f[j]=0;
			ffor(k,1,m) {int o=k*d;for(int j=k,jj=s[o-1]+1;j<=m;j+=k,jj++) f[j]+=dp[lst][jj];}
			if(mu[d]<0) ffor(j,1,m) f[j]=-f[j];
			for(auto p:pr) {
				if(p>m) break ;
				int ov=m/p*p;
				roff(j,m/p,1) f[j]+=f[ov],ov-=p;	
			}
			ffor(a,1,m) {
				for(int j=St[a],id=frac[j];j<=Lst[a];j++,id=frac[j]) tmp[id]=f[id];
				int k=a*11;
				for(int j=1,p=pfr[k+1];j<=pc[a];j++,p=pfr[k+j]) {int v=a/p;for(int j=St[v],id=frac[j];j<=Lst[v];j++,id=frac[j]) tmp[id]-=tmp[id*p];}
				for(int j=St[a],jj=Lst[a],idx=frac[j];j<=Lst[a];j++,idx=frac[j],jj--) dp[st][s[idx*d-1]+frac[jj]]+=tmp[idx];
			}
		}
		ffor(k,1,5000) for(int j=k,jj=s[k-1]+1;j<=5000;j+=k,jj++) {
			if(k==1||j<l[i]||j>r[i]) dp[st][jj]=0;
			else dp[st][jj]%=MOD;
			dp[lst][jj]=0;
		}
	}
	int ans=0;
	ffor(k,1,43376) ans=(ans+dp[n&1][k])%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

对了，卡常也是 Reunite 教我的。

---

## 作者：littlez_meow (赞：2)

感觉前两篇题解的式子太意识流了。

记值域为 $m$。

由于 $\gcd(a_i,a_{i+1},a_{i+2})=k$，所以有 $k|a_i$。不妨令 $a_i\leftarrow\dfrac{a_i}{k},l_i\leftarrow\lceil\dfrac{l_i}{k}\rceil,r_i\leftarrow\lfloor\dfrac{r_i}{k}\rfloor$。则原限制转化为 $l_i\le a_i\le r_i,\gcd(a_i,a_{i+1})\neq 1,\gcd(a_i,a_{i+1},a_{i+2})=1$。接下来的 $k$ 和题目里的没有关系。

设一个状态转移会比较抽象。设 $f(i,j,k)$ 表示考虑到第 $i$ 个数，$a_i=k$，$\gcd(a_i,a_{i-1})=j$ 的方案数；设 $g(i,j,k)$ 表示考虑到第 $i$ 个数，$a_i=k$，$\gcd(a_i,a_{i+1})=j$ 的方案数。

首先是 $g$ 到 $f$ 的转移为 $f(i,j,k)=\sum\limits_{v=l_{i-1}}^{r_{i-1}}g(i-1,j,v)[\gcd(v,k)=j]$。

除掉 $j$ 后反演得到 $f(i,j,k)=\sum\limits_{v=\lceil\frac{l_{i-1}}{j}\rceil}^{\lfloor\frac{r_{i-1}}{j}\rfloor}g(i-1,j,vj)\sum\limits_{d|v,d|\frac{k}{j}}\mu(d)$。

即：

$$f(i,j,k)=\sum\limits_{d|\frac{k}{j}}\mu(d)\sum\limits_{v=\lceil\frac{l_{i-1}}{dj}\rceil}^{\lfloor\frac{r_{i-1}}{dj}\rfloor}g(i-1,j,vdj)$$

不妨 $k\leftarrow \dfrac k j$，对第三维做狄利克雷后缀和，对位乘 $\mu$ 后再做狄利克雷前缀和即可转移，时间复杂度 $O(nm\log m\log\log m)$，前一个 $\log m$ 是枚举因数的调和级数，后一个 $\log\log m$ 是狄利克雷前后缀和。

然后再是 $f$ 到 $g$ 的转移为：

$$g(i,j,k)=\sum\limits_{x|k}f(i,x,k)[\gcd(x,j)=1]$$

枚举 $k$，把 $f(i,x,k)$ 贡献到 $x$ 的质因数集合的位置然后求高维后缀和，那么 $g(i,j,k)$ 就是 $j$ 的质因数集合的补集的位置。这一部分复杂度是 $\sum\limits_{k\le m}d(k)\omega(k)=\sum\limits_{k\le m}\omega(k)\sum\limits_{i|k}1=\sum\limits_{ik\le m}\omega(ik)\le\sum\limits_{ik\le m}(\omega(i)+\omega(k))=2\sum\limits_{i\le m}\sum\limits_{k\le\frac m i}\omega(i)=2\sum\limits_{i\le m}O(\dfrac m i\log\log\dfrac v i)=O(m\log m\log\log m)$。加上枚举第一维，总的复杂度是 $O(nm\log m\log\log m)$。

然后就做完了，时间复杂度 $O(nm\log m\log\log m)$。

---

## 作者：UKE_Automation (赞：0)

### P8322『JROI-4』少女幻葬

[$\text{Link}$](https://www.luogu.com.cn/problem/P8322)

首先我们发现所有数都是 $k$ 的倍数，那么直接把 $k$ 除掉。此时限制变为 $\gcd(a_i,a_{i+1})>1$ 且 $\gcd(a_{i-1},a_i,a_{i+1})=1$。考虑 dp，令 $f_{i,j,k}$ 表示 $a_i=j$ 且 $\gcd(a_{i-1},a_i)=k$ 的方案数，那么有转移方程：
$$
f_{i,a,\gcd(a,j)}=\sum f_{i-1,j,k}\times [\gcd(a,k)=1]
$$
注意这里我们先不管 $\gcd(a,j)=1$，在最后清空即可。然后我们直接莫比乌斯反演可得：
$$
\begin{aligned}
&f_{i,a,\gcd(a,j)}=\sum f_{i-1,j,k}\sum _{p\mid \gcd(a,k)}\mu(p)\\
\Rightarrow &f_{i,ap,\gcd(ap,j)}=\sum _{p}\mu(p)\sum_{p\mid k} f_{i-1,j,k}\\
\end{aligned}
$$
发现此时 $a,j$ 一定都是 $p$ 的倍数，所以左边我们可以同时除掉 $p$，最后乘回去即可。

在枚举完 $p$ 之后，我们令 $F_j=\mu(p) \sum\limits_{p\mid k} f_{i-1,jp,k}$。接下来枚举 $a$，那么实际上，如果我们再令 $G_k=[k=a]$，那么上面的式子就是对 $F,G$ 做 $\gcd$ 卷积然后存到 $f_{i,a,*}$ 中。直接暴力做复杂度承受不了，不过我们发现对于 $G$ 进行一次变换之后，只有 $d(a)$ 个位置上有值，那么我们只考虑这几个位置上的值即可。

最后复杂度是 $O(nm\log^2 m)$，略微卡常即可通过。

```cpp
#include <bits/stdc++.h>
#define il inline

using namespace std;

typedef long long ll;
const int Maxn = 5e3 + 5;
const int Inf = 2e9;
const int Mod = 998244353;
il int Add(int x, int y) {return x + y >= Mod ? x + y - Mod: x + y;} il void pls(int &x, int y) {x = Add(x, y);}
il int Del(int x, int y) {return x - y < 0 ? x - y + Mod : x - y;} il void sub(int &x, int y) {x = Del(x, y);}
il int qpow(int a, int b, int P = Mod) {int res = 1; for(; b; a = 1ll * a * a % P, b >>= 1) if(b & 1) res = 1ll * res * a % P; return res;}
il int Inv(int a) {return qpow(a, Mod - 2);}
template <typename T> il void chkmax(T &x, T y) {x = (x >= y ? x : y);}
template <typename T> il void chkmin(T &x, T y) {x = (x <= y ? x : y);}
template <typename T>
il void read(T &x) {
	x = 0; char ch = getchar(); bool flg = 0;
	for(; ch < '0' || ch > '9'; ch = getchar()) flg = (ch == '-');
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	flg ? x = -x : 0;
}
template <typename T>
il void write(T x, bool typ = 1) {
	static short Stk[50], Top = 0;
	x < 0 ? putchar('-'), x = -x : 0;
	do Stk[++Top] = x % 10, x /= 10; while(x);
	while(Top) putchar(Stk[Top--] | 48);
	typ ? putchar('\n') : putchar(' ');
}
il void IOS() {ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);}
il void File() {freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);}
bool Beg;

int n, m, k;
int l[Maxn], r[Maxn];
ll dp[2][Maxn * 18];
int prim[Maxn], tot, vis[Maxn], mu[Maxn];
int P[Maxn * 18], st[Maxn], ed[Maxn], len[Maxn], ps[Maxn];
int Pr[Maxn * 12], ln[Maxn];
int pos[Maxn];
void init(int N) {
	mu[1] = 1;
	for(int i = 2; i <= N; i++) {
		if(!vis[i]) prim[++tot] = i, mu[i] = -1;
		for(int j = 1, x; (x = prim[j] * i) <= N; j++) {
			vis[x] = 1;
			if(i % prim[j] == 0) {
				mu[x] = 0; break;
			}
			mu[x] = -mu[i];
		}
	}
	pos[1] = 1;
	for(int i = 1; i <= N; i++) {
		pos[i + 1] = pos[i];
		for(int j = i; j <= N; j += i) len[j]++, pos[i + 1]++;
	}
	for(int i = 1; i <= N; i++) ps[i] = st[i] = ed[i - 1] + 1, ed[i] = st[i] + len[i] - 1;
	for(int i = 1; i <= N; i++) for(int j = i; j <= N; j += i) P[ps[j]++] = i;
	for(int i = 1; i <= tot; i++) for(int j = prim[i]; j <= N; j += prim[i]) ln[j]++, Pr[j * 11 + ln[j]] = prim[i];
}
ll G[Maxn], F[Maxn];

bool End;
il void Usd() {cerr << (&Beg - &End) / 1024.0 / 1024.0 << "MB " << (double)clock() * 1000.0 / CLOCKS_PER_SEC << "ms\n"; }
int main() {
//	File();
	read(n), read(k);
	for(int i = 1; i <= n; i++) {
		read(l[i]), read(r[i]);
		l[i] = (l[i] - 1) / k + 1, r[i] /= k;
		chkmax(m, r[i]);
	}
	init(m);
	for(int i = l[1]; i <= r[1]; i++) dp[0][i] = 1;
	int now = 0, nxt = 1;
	for(int i = 1; i < n; i++) {
		for(int p = 1; p <= m; p++) {
			if(!mu[p]) continue;
			for(int _p = p; _p <= m; _p += p) 
				for(int j = _p, c = pos[_p]; j <= m; j += _p, c++) 
					F[j] += dp[now][c];
			if(mu[p] < 0) for(int j = p; j <= m; j += p) F[j] = -F[j];
			for(int j = p; j <= m; j += p) for(int c = j + j; c <= m; c += j) F[j] += F[c];
			int L = (l[i + 1] - 1) / p + 1, R = r[i + 1] / p;
			for(int a = L; a <= R; a++) {
				for(int t = st[a], d = P[t]; t <= ed[a]; t++, d = P[t]) G[d] += F[d * p];
				for(int c = a * 11 + 1, _d = Pr[c]; c <= a * 11 + ln[a]; c++, _d = Pr[c]) {
					for(int t = st[a], d = P[t]; t <= ed[a]; t++, d = P[t]) {
						if(d * _d > a) break; 
						G[d] -= G[d * _d];
					}
				} 
				for(int t = st[a], d = P[t], r = ed[a]; t <= ed[a]; t++, d = P[t], r--) 
					dp[nxt][pos[d * p] + P[r] - 1] += G[d], G[d] = 0;
			}
			for(int j = p; j <= m; j += p) F[j] = 0;
		}
		for(int d = 1; d <= m; d++) {
			for(int a = d, c = pos[d]; a <= m; a += d, c++) {
				dp[now][c] = 0;
				if(d == 1) dp[nxt][c] = 0;
				else (dp[nxt][c] += Mod) %= Mod;
			}
		}
		now ^= 1, nxt ^= 1;
	}
	int ans = 0;
	for(int i = 1; i <= m; i++) {
		for(int j = i, p = pos[i]; j <= m; j += i, p++) {
			pls(ans, dp[now][p]);
		}
	}
	write(ans);
    Usd();
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

首先不妨 $k=1$。

假设 $f_{i,j,k}$ 表示 $a_i=j,\gcd(a_i,a_{i-1})=k$ 的方案数。由于只关心 $\gcd$ 和 $1$ 的关系，我们可以可以钦定 $k,j$ 是 sqrt-free 的。由于 $k|j$ 所以状态数数量是 $O(nV\log V)$ 的。

考虑转移。枚举 $a_{i+1}=x$，我们找到所有满足 $\gcd(j,x)\neq 1$ 且 $\gcd(k,x)=1$ 的 $(j,k)$ 对转移即可。

考虑先不管 $\gcd(j,x)\neq 1$ 这个条件。我们算出 $f_{i+1,j,k}$ 之后把 $k=1$ 的全部清零即可。

考虑如何作这个变化。首先我们钦定 $t|\gcd(j,x)$，我们首先计算 $f'_{i+1,j,k}=\sum_{j|j'}f_{i+1,j',k}$，我们可以通过 $f'$ 算出 $f$。

莫反 $s|\gcd(k,x)$。然后相当于我们枚举 $t,s$，然后钦定 $t|j,s|k,\operatorname{lcm}(s,t)|x$。注意到 $x\leq V$，所以 $\operatorname{lcm}(s,t)\leq V$。这样的 $s,t$ 对大约是 $10^5$ 的。

我们可以通过类似高位前缀和的技巧，先计算 $g_{s,t}=\mu(t)(\dfrac{r_i}{\operatorname{lcm}(s,t)}-\dfrac{l_i-1}{\operatorname{lcm}(s,t)})\sum_{s|x,t|y}f_{i,x,y}$，然后就有 $f'_{i+1,j,k}=\sum_{y|k}g_{j,y}$。这里预处理存下所有转移即可。转移数量大约是 $2\times 10^5$ 的。

---


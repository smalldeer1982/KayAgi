# [AHOI2022] 山河重整

## 题目描述

生活在 $998244353$ 号小宇宙的艾和兰收到了归零者的讯息，决定响应回归运动。他们需要把大部分的物质归还给大宇宙，只留下极少的物质用于在新宇宙重建自己的文明。

艾和兰的文明总共有 $n$ 个关键信息，编号为 $1, 2, \ldots, n$。他们需要保留的信息是这些关键信息的一个子集 $S$。对于一个编号为 $x$ 的信息，只要 $S$ 中一个子集的编号和等于 $x$，那么他们设计的漂流瓶就可以在新宇宙将 $x$ 还原出来。

艾和兰不禁想要思考，他们有多少种选择子集 $S$ 的方案，使得关键信息 $1, 2, \ldots, n$ 均能被还原？艾和兰自然是只用 $1$ 微秒就算出了方案数的精确数值，现在他们想让你帮忙验算。由于方案数可能很大，你只需要输出方案数对 $M$ 取模的结果。

## 说明/提示

**【样例解释 \#1】**

总共有以下 $3$ 个集合满足条件：

- $\{ 1, 2, 3 \}$
- $\{ 1, 2, 4 \}$
- $\{ 1, 2, 3, 4 \}$

**【数据范围】**

对于 $100 \%$ 的数据，保证 $1 \le N \le 5 \times {10}^5$，$2 \le M \le 1.01 \times {10}^9$。

| 测试点编号 | $N \le$ | $M \le$ |
|:-:|:-:|:-:|
| $1 \sim 2$ | $20$ | $1.01 \times {10}^9$ |
| $3 \sim 4$ | $100$ | $1.01 \times {10}^9$ |
| $5 \sim 6$ | $5000$ | $1.01 \times {10}^9$ |
| $7$ | $3 \times {10}^5$ | $127$ |
| $8$ | $5 \times {10}^5$ | $127$ |
| $9$ | $3 \times {10}^5$ | $1.01 \times {10}^9$ |
| $10$ | $5 \times {10}^5$ | $1.01 \times {10}^9$ |

## 样例 #1

### 输入

```
4 1000000007
```

### 输出

```
3
```

## 样例 #2

### 输入

```
10 1000000007
```

### 输出

```
180
```

## 样例 #3

### 输入

```
1000 65472
```

### 输出

```
2136
```

## 样例 #4

### 输入

```
100000 100
```

### 输出

```
96
```

# 题解

## 作者：luogubot (赞：33)

首先知道 $S=\{x_1,x_2,\cdots x_k\}(x_i\leq x_{i+1})$ 能凑出的上界是 $\sum x_i$，然后断言能达到上界当且仅当「$\forall k\in[1,\sum x_i]$，$S$ 中 $\leq k$ 的数之和 $\ge k$」，证明略。令 $f_i$ 是若干个 $[1,i]$ 中的数之和是 $i$ 且满足上述条件的方案数，答案就是 $2^n-\sum f_i\times 2^{n-i-1}$，即在非法方案中钦定 $i+1$ 不选，剩余的任意选择，每个方案都能在第一次非法的时候被减掉。

考虑通过容斥求出 $f$，即设 $g_i$ 是若干个 $[1,i]$ 中的数之和是 $i$ 但不限制满足上述条件的方案数，它的求法将在之后讨论，然后 $f_i=g_i-\sum f_j\times val(j,i)$，其中 $val(j,i)$ 表示转移的系数。从 $j$ 转移到 $i$ 意味着从 $j+1$ 开始就不合法了，于是 $j+1$ 这个数是不能选的，只能选 $[j+2,i]$ 中的若干个数使其和为 $j-i$，$val(j,i)$ 就是这样的方案数。

我们暂时搁置 $f$ 的转移，来看 $g$ 的 $O(n\sqrt n)$ 经典 dp。$g_n$ 是若干不同正整数和为 $n$ 的方案数，因为 $\sum_{i=1}^n i=O(n^2)$，于是凑出 $n$ 的正整数只有 $O(\sqrt n)$ 个，我们把选择的数看作格子画出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/qjhrci3g.png)

一列的格子数对应一个选择的数组，比如这就对应选择了数字 $\{8,7,6,4,3,1\}$。这样的好处是列数，即行的长度只有 $O(\sqrt n)$，每一行的长度单调不增且与上一行的差值不超过 1，如果超过 1 就出现了两个相同的数了；一行长度为 $i$ 的格子表示给最大的 $i$ 个数加一。

问题就转化为可以在行上做完全背包了，从 $O(\sqrt n)$ 到 1 枚举行的长度，并强制这个长度至少有一行，然后做完全背包就可以对应拆分的方案数了，复杂度 $O(n\sqrt n)$。代码长这样（`Rof` 是倒序循环）：

```cpp
Rof(i,n,1)if(1ll*i*(i+1)/2<=n){
    Rof(j,n,i)g[j]=g[j-i];
    add(g[i],1);For(j,i,n)add(g[j],g[j-i]);
}
```

其中 `add(g[i],1)` 表示加入一种第一行长度是 $i$，即只选 $i$ 个数的方案。

然后再考虑 $f$ 的转移，$f_i=g_i-\sum f_j\times val(j,i)=g_i-h_i$。我们不会求出每个 $val(j,i)$ 精确的值，但我们知道 $val(j,i)$ 等于在 $[j+2,i]$ 中选若干个和为 $j-i$ 的方案数，那么 $h$ 转移和 $g$ 唯一的不同就在于加入一种第一行有 $i$ 个格子（选了 $i$ 个数）的方案时，首先有一个 $f_j$ 作为被加入的方案数替代原本的 1，然后需要选 $i$ 个 $\ge j+2$ 的数，和就变为了 $j+(j+2)i$，也就是 $f_j\to h_{j+(j+2)i}$，$j$ 在内层枚举。

注意到在转移 $h$ 前必须把转移过来的 $f$ 的 dp 值提前计算完成，可以每次先求出前一半的 dp 值，再转移给后一半，即由于 $j+(j+2)i\ge 2j$，可以倍增完成转移。

复杂度 $n\sqrt n+\frac{n\sqrt n}2+\frac{n\sqrt n}4+\cdots=O(n\sqrt n)$，阅读[完整代码](https://www.luogu.com.cn/paste/p4lz7ci9)可能更有助于理解，注意代码中的变量意义和题解描述不完全相同。



---

## 作者：CXY07 (赞：30)

> 题目链接：[[AHOI2022] 山河重整](https://www.luogu.com.cn/problem/P8340)

> **本题解同步发布于 [My Blog](https://www.cxy07.blog/index.php/archives/551/)**

题意：

> 计数有多少个元素在 $[1,n]$ 的集合，其 $01$ 背包能表示 $[1,n]$ 中的所有数。

> $1\le n\le 5\times 10^5$，时间限制 $\text{3s}$。

首先考虑从小到大加入数字，那么加入数字中途的每一个时刻，所能表示的都应是值域的一个前缀（因为加的数字越来越大）。

若目前能组合出 $[1,p]$，加入的新数是 $x$，那么能表示出的集合就变成了 $[1,p]\cup[x,p+x]$。若 $p+1<x$，由于加入的数字越来越大，所以以后再也组合不出 $p+1$ 了。因此，$x$ 需满足 $x\le p+1$，能拼出的新集合变成了 $[1,p+x]$。

于是容易得到一个 $\mathcal{O}(n^2)$ 的算法：设 $\text{dp}(i,p)$ 表示考虑前 $i$ 个数，已经能拼出 $[1,p]$ 的方案数。每次只需要决策是否将 $i$ 加入集合，将 $\text{dp}(i-1,p)$ 转移到 $\text{dp}(i,p+i)$ 即可。

我们需要一个更好的方式来描述上述过程。

直接计数所有满足条件的序列看起来不那么容易，尝试钦定不满足条件的位置，然后进行容斥。确切来说，即找到一组不合法方案的，最小的 $i$，满足 $[1,i]$ 均可拼出但 $i+1$ 无法拼出，对这样的位置进行容斥。

若值域 $[1,i]$ 中每个数均可拼出，且值域在 $[1,i]$ 中所有元素的和 $> i$，那么 $i+1$ 一定可以拼出。又需要能拼出 $i$，所以可知：若 $i$ 是这样一个位置，那么值域在 $[1,i]$ 中的所有元素的和**恰好**为 $i$。

我们设 $f_i$ 表示，只考虑值域在 $[1,i]$ 中的元素，能拼出 $[1,i]$ 中每个数字，且总和恰好为 $i$ 的方案数。其计算可以通过 “所有方案” 减去 “$[1,i]$ 中存在元素无法拼出的方案”。前者是 $i$ 的**互异拆分数**，而后者可以通过之前的 $f$ 求得。

更具体些，枚举第一个无法拼出的数字，在计算 $f_i$ 的时候，一个可以贡献的 $f_j$ 大概形如：$[1,j]$ 均可拼出，跳过 $j+1$（无法拼出），$[j+2,i]$ 中的元素加上 $[1,j]$ 中的元素总和恰好为 $i$（由 $f_j$ 定义可知，$[1,j]$ 中的元素之和恰好为 $j$，因此 $[j+2,i]$ 中的元素和应恰好为 $i-j$）。

考虑求解互异拆分数的具体做法。拆分出的数字个数是 $\mathcal{O}(\sqrt{n})$ 级别，于是我们将 “计数 $\mathcal{O}(\sqrt{n})$ 个不同数字和为 $n$ 的方案数” 转变为 “对 $i\in[1,\sqrt{n}]$，考虑有多少个数 $\ge i$”。

![](https://cdn.luogu.com.cn/upload/image_hosting/og3ax8u7.png)

例如，上图可以看作 $12$ 的一组互异拆分 $\{1,2,4,5\}$（每行看作一个数字），也可以看作 $\ge 1$ 的有 $4$ 个，$\ge 2$ 的有 $3$ 个，$\ge 4$ 的有 $2$，$\ge 5$ 的有 $1$ 个（考虑每列）。

由于 $\ge i+1$ 的数字个数一定不多于 $\ge i$ 的数字个数，所以可以从 $\sqrt{n}$ 到 $1$ 倒序枚举 $i$，类似完全背包加入一个体积为 $i$ 的元素（表示有 $i$ 个元素 $\ge$ 某一个值）。

而 $f_j$ 向 $f_i$ 的贡献中，也存在 $[j+2,i]$ 中数字的背包状物。暴力做法可以从 $i$ 倒序枚举，在背包中逐步加入元素，在适当的时刻加入 $f_j$ 对 $f_i$ 的贡献。

考虑用上述方法类似地优化。$f_j$ 贡献的时候，其他所有元素应 $\ge j+2$。所以，我们可以在确定 $[j+2,i]$ 的集合中有多少个数的时候（设其为 $c$，即上图第一列有多少点），将 $f_j$ 贡献到背包的 $j+(j+2)\times c$ 处作为初值（可以结合代码理解）。

最后只剩下一个问题。在计算 $f_i$ 的时候，需要 $f_j$ 已经计算好了。但是上述做法中，我们需要先做一次完整的背包，才可以得到 $f_i$ 的系数。

注意到，若 $f_j$ 能贡献到 $f_i$，则 $i\ge j+(j+2)$（$i$ 要在 $j$ 的两倍以上）。因此，只需要先计算 $\dfrac{n}{2}$ 以下部分的 $f_i$，便可以得到所有 $f_i$ 的答案（类似一个倍增的过程）。

其复杂度为 $T(n)=\mathcal{O}(n\sqrt{n})+T\Big(\dfrac{n}{2}\Big)=\mathcal{O}(n\sqrt{n})$。

```cpp
//Code By CXY07 - It's My Fiesta.
#include<bits/stdc++.h>
using namespace std;

//#define FILE
//#define int long long
#define randint(l, r) (rand() % ((r) - (l) + 1) + (l))
#define abs(x) ((x) < 0 ? (-(x)) : (x))
#define popc(x) __builtin_popcount(x)
#define inv(x) qpow((x), mod - 2)
#define lowbit(x) ((x) & (-(x)))
#define ull unsigned long long
#define pii pair<int, int>
#define LL long long
#define mp make_pair
#define pb push_back
#define scd second
#define vec vector
#define fst first
#define endl '\n'
#define y1 _y1

const int MAXN = 5e5 + 10;
const int INF = 2e9;
const double eps = 1e-6;
const double PI = acos(-1);
//const int mod = 1e9 + 7;
//const int mod = 998244353;
//const int G = 3;
//const int base = 131;

int n, mod, lim, Ans;
int dp[MAXN], t[MAXN], p2[MAXN];

template<typename T> inline bool read(T &a) {
	a = 0; char c = getchar(); int f = 1;
	while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { a = a * 10 + (c ^ 48); c = getchar(); }
	return a *= f, true;
}

template<typename A, typename ...B>
inline bool read(A &x, B &...y) { return read(x) && read(y...); }

void modadd(int &x, int y) { x += y; if(x >= mod) x -= mod; }

void run(int n) {
	if(n <= 1) return;
	run(n >> 1);
	for(int i = 0; i <= n; ++i) t[i] = 0;
	lim = sqrt(2 * n);
	for(int i = lim; i >= 1; --i) {
		for(int j = n; j >= i; --j) t[j] = t[j - i];
		for(int j = i - 1; j >= 0; --j) t[j] = 0;
		for(int j = 0; j + (j + 2) * i <= n; ++j)
			modadd(t[j + (j + 2) * i], dp[j]);
		for(int j = i; j <= n; ++j) modadd(t[j], t[j - i]);
	}
	for(int i = (n >> 1) + 1; i <= n; ++i)
		modadd(dp[i], mod - t[i]);
}

signed main () {
#ifdef FILE
	freopen("P8340.in", "r", stdin);
	freopen("P8340.out", "w", stdout);
#endif
	read(n), read(mod); p2[0] = 1;
	for(int i = 1; i < MAXN; ++i)
		p2[i] = (p2[i - 1] + p2[i - 1]) % mod;
	lim = sqrt(2 * n); dp[0] = 1;
	for(int i = lim; i >= 1; --i) {
		for(int j = n; j > i; --j) dp[j] = dp[j - i];
		for(int j = i; j >= 1; --j) dp[j] = 0;
		for(int j = i; j <= n; ++j) modadd(dp[j], dp[j - i]);
	}
	run(n);
	for(int i = 0; i < n; ++i)
		Ans = (Ans + 1ll * dp[i] * p2[n - i - 1]) % mod;
	Ans = (p2[n] - Ans + mod) % mod;
	printf("%d\n", Ans);
	return 0;
}
```

---

## 作者：FjswYuzu (赞：23)

updated on 2022/6/6: 改了一些下标细节，加了点基于 Ferrers 图像对式子的解释。

今年的独立命题除了福建都很一可赛艇啊！

首先有个经典结论是，如果选出的子集 $S$ 合法，那么 $\forall i, \sum_{j \in S,j \leq i} j \geq i$。

那么可以得到一个 $O(n^2)$ 的 DP。定义 $dp_{i,j}$ 为在前 $i$ 个数中，可以构出 $[1,j]$ 内的所有数（第二维与 $n$ 取最小值），直接转移即可。

陷入困境。一方面这个 DP 的形式不好优化，另一方面容易发现这个 DP 的劣势在于第二维进行了压缩，我们无法得知准确的信息。

那么考虑算不合法的方案数。我们在每一个方案中第一个无法被表示的位置 $i+1$ 计数。容易发现此时小于等于 $i$ 的数的和就是 $i$。

那么定义 $f_i$ 为集合 $\{1,2,\cdots,i\}$ 有多少子集使得和为 $i$，且可以表示 $[1,i]$ 内的所有数。遗憾的是在这里我们陷入困境，一方面是直接朴素 DP 和上面的形式毛区别也没有，另一方面可以表示 $[1,i]$ 内的所有数这个限制非常的离谱。

但是，注意到和为 $i$ 这个限制，并且选出的数都不相同，容易发现我们选出来的数是 $O(\sqrt n)$ 级别的，并且避免了信息的压缩。那我们转换计数视角，下面给出一个实例：

![](https://cdn.luogu.com.cn/upload/image_hosting/24sn2ogd.png)

容易发现我们选择了 $S=\{1,2,4,5\}$，和为 $12$。其中大小不同的行数量级别为 $O(\sqrt{12})$。（也可以按整数拆分选择的不同数个数这个角度来考虑。）

那么考虑我们之前 DP 的实质，我们是每次加入一列。那么这里我们按行来考虑。发现这个图有如下特点：

- 行的最大值是 $O(\sqrt n)$ 的，已经强调了很多次了；   
- 上面的行大小都不小于下面的行；   
- 如果大小为 $i$ 的行出现了，那么大小在 $[1,i-1]$ 内的行都出现了。

根据实际意义容易发现到上面的结论。

注意到我们直接计算 $f_i$ 仍然困难，因为可以表示 $[1,i]$ 内的所有数这个限制确实比较难处理。我们考虑容斥，先算出一个不考虑这个限制的 $f_i$。

如何算这个不带限制的 $f_i$ 呢？容易发现每个大小的行可以出现任意次，类似于完全背包，区别在于带了类似「如果要选 $i$，必须先选 $[1,i-1]$ 内的每个数至少一次」的限制。那么我们考虑从大的数选起，每次枚举到 $i$ 的时候为了保证更上面的方案是合法的，我们先选择一个 $i$，然后再更新。

```cpp
	// 此时 f[0] 不等于 1
	for(int i=n;i;--i)
	{
		if(LL(i)*(i+1)/2>n)	continue;
		// 从大的开始选，要保证 i 一定要被选到。从小的开始选的话可能会缺。考虑实际意义，因为 1~p 都要被选到才合法。
		for(int j=n;j>=i;--j)	f[j]=f[j-i];
		// 我先单选个 i，保证之前选择的方案合法
		++f[i];
		for(int j=i;j<=n;++j)	add(f[j],f[j-i]);
		// 做完全背包。
	}
	f[0]=1;
```

那么对每个 $i$ 考虑容斥掉不合法的方案数，得到正确的 $f_i$。

先考虑对 $i$ 有贡献的 $j$。首先为了方便计数，并且为了满足定义，显然我们后来选的最小的数为 $j+2$（因为我们要满足选之后，$j+1$ 是最小的不能被构出的数，并且和为 $i$）。那么不难发现对 $i$ 有贡献的 $j$，满足 $2j+2 \leq i$。

注意到这个点，我们在处理 $f_{1 \sim n}$ 的时候，可以先处理 $f_{1 \sim \frac{n}{2}}$，然后继续处理后面的东西。

那么我们已经知道了前面一半的 $f$，要求后面一半。

这个时候继续考虑加入每一行之类的想法就非常的没有前途（主要是我没找到）。注意到我们现在要的是，通过选择 $[j+2,i]$ 里面的数，使得和为 $i-j$。我们考虑划分数相关的想法。

假设没有选择的数限制（但是还是有选择的数不能重复的限制），不妨写作生成函数的形式：

$$
F(x) = \prod_{i=1}^{∞} (1+x^i)
$$

再来考虑这个东西的意义……我们按上面的方格图的形式把它排好，然后第 $i$ 列从下往上删去 $i$ 个方格（可以发现不可能出现没东西删的情况，因为第 $i$ 列的格子数显然不小于 $i$），容易发现上面的行仍然大于等于下面的行，当然这没有什么用。同时有些列消失了，若之前有 $p$ 列，现在就是不大于 $p$ 列。现在减去这个之后形式变成了类似于整数拆分的形式，并且有限制选择的最大的数。

那么，枚举选择的集合的大小：

$$
F(x) = \sum_{i=1}^∞ x^{\frac{i(i+1)}{2}} \prod_{j=1}^{i} \dfrac{1}{1-x^j}
$$

先解释一下后面这个东西。可能有人会问后面这个东西并没有限制选择了至多 $i$ 个数，但是根据 Ferrers 图像的相关推论，整数 $n$ 拆分成最多不超过 $i$ 个数的和的方案数等于 $n$ 拆分成最大不超过 $i$ 的方案数。因此后面那个东西是对的。

不难发现 $[x^{i-j}]F(x)$ 就是没有限制的情况下我们要的结果。

但是现在带大小限制。首先上界我们不用管，可以考虑对 $x^n$ 之类的东西取模；主要的是下界 $j+2$，在我们上面设计的模型下相当于每一列多了 $j+1$ 个格子，只跟 $j+1$ 有关系。

记 $F_p(x)$ 为下界为 $p+1$ 时的生成函数，那么有：

$$
\begin{aligned}
F_p(x)
&= \prod_{i=p+1}^∞ (1+x^i) \\
&= \sum_{i=1}^∞ x^{\frac{i(i+1)}{2}} x^{ip} \prod_{j=1}^i \dfrac{1}{1-x^j}
\end{aligned}
$$

再记生成函数 $G(x)$ 表示一下需要减去的贡献：

$$
G(x) = \sum_{j=0}^{n} f_j x^j F_{j+1}(x)
$$

把 $G$ 求出来，更新 $f$ 的后一半即可。记不带限制的 $f$ 为 $g$，具体求法写出式子就好理解了：

$$
f_i = g_i - [x^i] \sum_{k=0}^i f_k \sum_{i=1}^{∞} x^{\frac{i(i+1)}{2}} x^{(k+1)i} x^k \prod_{j=1}^i \dfrac{1}{1-x^j}
$$

从大到小枚举 $i$，然后枚举外层的 $k$，最后再乘上 $\dfrac{1}{1-x^j}$。先从大到小枚举 $i$ 的原因就是后面的那个 $\prod$ 处理起来不方便，在这样处理之后就真的是单纯的完全背包了。

注意到计算 $F_p(x)$ 的过程中，$i$ 的上界为 $O(\sqrt n)$，后面 $\prod$ 内的内容是完全背包（感觉可以和一开始的做法产生有机联系，可惜我没有发现），可以做到 $O(n \sqrt n)$。每次递归 $n$ 减半，复杂度分析后得到总时间复杂度 $O(n \sqrt n)$。

可以采用其他的手段得到更优的做法。

Motivation: 正难则反，视角转换，生成函数。

```cpp
int f[500005],g[500005];
void Solve(int n)
{
	if(n<=1)	return ;
	Solve(n>>1);
	for(int i=1;i<=n;++i)	g[i]=0;
	for(int i=n;i;--i)
	{
		if(LL(i)*(i+1)/2>n)	continue;
		for(int j=0,t=i+i*(i+1)/2;t<=n;++j,t+=i+1)	add(g[t],f[j]);
		for(int j=i;j<=n;++j)	add(g[j],g[j-i]);
	}
	for(int i=n/2+1;i<=n;++i)	sub(f[i],g[i]);
}
int n;
int main(){
	n=read(),MOD=read();
	for(int i=n;i;--i)
	{
		if(LL(i)*(i+1)/2>n)	continue;
		for(int j=n;j>=i;--j)	f[j]=f[j-i];
		f[i]=1;
		for(int j=i;j<=n;++j)	add(f[j],f[j-i]);
	}
	f[0]=1;
	Solve(n);
	int ans=1;
	for(int i=0;i<n;++i)	add(ans,ans),sub(ans,f[i]);
	write(ans);
	return 0;
}
```

---

## 作者：JoshAlMan (赞：19)

首先这个问题肯定需要转化找到一个更好的充要条件。

* 对于任意 $i$，满足 $S$ 中 $\le i$ 的和要 $\ge i$

>  证明：这个肯定的必要的，考虑充分怎么证。1, 2 肯定是必需在里面，刚好满足这个条件的，考虑归纳 $i \ge 3$，假设前 $i - 1$ 个和都能用 $\le x$ 表达出来，考虑找到一个最小的 $x$ 使得 $\le x$ 的数加起来 $\ge i$ ，设这个和是 $t$，那么必然有 $i \le t < 2i$，那么 $t - i < i$ 也能被表示了，用总的减去 $t - i$ 就得到 $i$ 了。

那么就有一个 $O(n^2)$ 的 dp，就按 $1$ 到 $n$ 顺序加入，记一下当前和（可以对 $n$ 取 min），任意时刻都得满足限制。

考虑优化这个事情，其实是困难的。（后续全部拟合 ei，呜呜，我好菜。

合法的抽象特征似乎有点难提取，考虑不合法有一个共同的特征，考虑最小的 $x$，使得 $\le x$ 的和 $< x$，那么 $\le x - 1$ 的和必然是 $x - 1$！

那么我们可以从新的视角设计状态是 $f_i$ 表示 $\le i$ 的一个子集的和恰好是 $i$，并且任意 $x \le i$ 都合法（小于等于的和大于自己）。

$f$ 的计算可以先通过计算 $f$ 的整数拆分，减去不合法情况。不合法情况是什么呢，其实就是刚才提到全局不合法的一个局部，即这个拆分存在一个 $x$ 使得 $\le x$ 的和是 $x$ 并且之前都合法，那么就是 $f_x$，然后没有 $x+1$，加上 $x + 2 \sim i$ 部分的一个和恰好是 $i$ 。

考虑整数拆分的计算，比如现在计算 $n$ 的分拆，一个发现就是这个集合个数是根号量级的（（（咋这么喜欢考这个，那么计数是可以转化角度，一个好的理解是考虑这种矩形图（类似 Ferrers 或者杨表

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h238bhqamtj20po0zawf4.jpg)

每列代表一个数，竖着长度代表数值。上图是一个 $6+5+3+1 = 15$ 的例子。

那么这个矩阵有着最多根号量级的列。之前自然的 dp 都是一列一列加，不妨考虑一行一行加。

假设有 $p$ 个数，那么一个方案可以表示成 $n = \sum v_p \times p$ 的形式，期中 $v_p \ge 1$，而 $p$ 是根号量级。（这是一个经典映射？

所以可以看成有根号个数的完全背包之类的形式，完成 $O(n \sqrt {n})$ 分拆的计算。

考虑前面的 $f$ 对后面 $f$ 的那个贡献，假设 $j$ 对 $i$ 的贡献，那么肯定有 $j + j + 2 \le i$，其实可以类似的做，我们可以从大到小枚举 $p$，那么这 $p$ 个数都有 $\ge j + 2$，每次先叠行，然后加入 $f_j$ 后面放 $p$ 个这样的贡献，这样就是 $O(n \sqrt{n})$ 。但这要求是前面的 $f$ 都算好了。

考虑到 $j \le \frac{i}{2}$，那么我们可以考虑递归的形式，先算好 $n / 2$ 之前的部分，然后花费 $O(n \sqrt {n})$ 的代价算之后的部分，这个复杂度仍然是不超过 $O(n \sqrt {n})$（类似于倍增 FFT 的过程。

```cpp
// Skyqwq
#include <bits/stdc++.h>

#define pb push_back
#define fi first
#define se second
#define mp make_pair

using namespace std;

typedef pair<int, int> PII;
typedef long long LL;

template <typename T> bool chkMax(T &x, T y) { return (y > x) ? x = y, 1 : 0; }
template <typename T> bool chkMin(T &x, T y) { return (y < x) ? x = y, 1 : 0; }

template <typename T> void inline read(T &x) {
    int f = 1; x = 0; char s = getchar();
    while (s < '0' || s > '9') { if (s == '-') f = -1; s = getchar(); }
    while (s <= '9' && s >= '0') x = x * 10 + (s ^ 48), s = getchar();
    x *= f;
}

const int N = 5e5 + 5;

int n, P, f[N], g[N], pw[N];

void inline add(int &x, int y) {
	x += y;
	if (x >= P) x -= P;
}

void inline del(int &x, int y) {
	x -= y;
	if (x < 0) x += P;
}

void inline work(int m) {
	if (m <= 1) return;
	work(m / 2);
	for (int i = 0; i <= m; i++) g[i] = 0;

	for (int i = m; i; i--) {
		if (i * (i + 1ll) / 2 > m) continue;
		for (int j = m; j >= i; j--) g[j] = g[j - i];

		for (int j = 0; j + (j + 2) * i <= m; j++)
			add(g[j + (j + 2) * i], f[j]);
		for (int j = i; j <= m; j ++) add(g[j], g[j - i]);
	}
	for (int i = m / 2 + 1; i <= m; i++) del(f[i], g[i]);
}

int main() {
    read(n), read(P);
    for (int i = n; i; i--) {
    	if (i * (i + 1ll) / 2 > n) continue;
    	for (int j = n; j >= i; j--)
    		f[j] = f[j - i];
    	add(f[i], 1);
    	for (int j = i; j <= n; j ++) add(f[j], f[j - i]);
    }	
	f[0] = 1;
	work(n);
	pw[0] = 1;
	for (int i = 1; i <= n; i++) pw[i] = pw[i - 1] * 2 % P;
	int ans = pw[n];
	for (int i = 0; i < n; i++) {
		del(ans, 1ll * f[i] * pw[n - i - 1] % P);
	}
	printf("%d\n", ans);
    return 0;
}
```


---

## 作者：xtx1092515503 (赞：15)

我们首先找一个必要条件吧。

然后发现，对于每个 $i$，**全体不大于其的元素之和不小于其** 是必要条件。

这个条件是充分的吗？

~~盲猜是的~~

考虑归纳。对于选出的集合大小和表示界同时归纳，每次尝试把界增加一，然后删去最大数，到达一个大小更小、界更小的态，即可归纳。

有了这个性质，我们就可以简单设计一个 $n^2$ 的 DP。但是这个 DP 并不能简单扩展至正解。

考虑容斥，用合法态数减去不合法态数。

考虑不合法态的特征：存在 $i$ 满足 $1\sim i$ 中所有数之和等于 $i$，且 $i+1$ 未被选中。

考虑令 $f_i$ 为 $1\sim i$ 中所有数之和等于 $i$ 的方案，然后容斥找到这是首个不合法的位置的方案数，即可避免重复计算。

暴力 DP 仍然是平方的。但是注意到这玩意长得很像 **整数拆分**，并且这题的整数拆分还有特殊性质，也即 **选择的数中不存在相同元素**。这就直接推出 **至多选取根号个数**。

整数拆分的一种优化至平方的经典套路是考虑令 $f_{i,j}$ 表示 $j$ 个数组合成 $i$ 的方案数，然后每次执行操作全体加一或者插入一个 $1$。

我们发现将这种东西直接写成 DP，在本题的性质下，状态数就是线性根号级别的，只需特别保证一下两两不同的性质即可。

```
1*
3***
4****
7*******
8********
```

关于上图，常规 DP 是从上往下的；上述优化是从左往右的。为了保证特殊性质，假如最终共选择了 $i$ 个数，满足特殊性质就等价于 $1\sim i$ 都被计入了至少一次。我们可以从左往右 DP，每次插入一个最终选择 $i$ 个数的状态即可。

则我们现在已经会了一个线性根号的 DP，现在就要考虑如何容斥了。

考虑一个暴力的容斥，即 $f_j\to f_i$，其中 $f_j$ 前要带一个系数。

什么系数呢？是区间 $[j+2,i]$ 中选取若干个数和为 $i-j$ 的方案数。

这玩意跟我们上面的 DP 是长得没啥区别的，只需确定最终选择了 $i$ 个数，然后把所有数减去 $j+2$、总和减去 $(j+2)i$ 即可。

然后紧接着我们发现，这个系数在 $j\geq\dfrac i2$ 时为零，因为备选的每个数都大于 $i-j$，因而不可能合法。

这引出一个很好的想法： 考虑 CDQ 分治。这牵涉到左区间内部贡献、左区间对右区间的贡献、右区间内部贡献。

然后我们惊讶地发现，依据上述观察，右区间内部 **没有贡献**。这意味着我们分治 **不需要进入右区间**，则每层分治长度都是折半的。假如反过来想，这就是个类倍增的流程。

现在我们考虑计算左区间对右区间的贡献。可以用一个辅助 DP $g$ 来表示：枚举左区间中每个 $f_j$ 在 $[j+2,i]$ 中选择了多少个数，为 $g$ 初始化；然后 $g$ 转移是简单的。

也可以参照代码（有注释）。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int BBB=1000;
int mod,f[500100],g[500100],res,bin[500100];
void ADD(int&x,int y){if((x+=y)>=mod)x-=mod;}
void solve(int n){
	if(n==1)return;
	solve(n>>1);
	for(int j=0;j<=n;j++)g[j]=0;
	for(int i=BBB;i;i--){
		for(int j=n;j>=i;j--)g[j]=g[j-i];//g[i] is the value that f[i] must substract in order to be correct.
		for(int j=0;j+(j+2)*i<=n;j++)ADD(g[j+(j+2)*i],f[j]);
		//take the transferrings where after state f[j] there are exact i numbers chosen(each of them is no less than j+2,and i(j+2) is pre-calculated) into consideration
		for(int j=i;j<=n;j++)ADD(g[j],g[j-i]);
	}
	for(int j=(n>>1)+1;j<=n;j++)ADD(f[j],mod-g[j]);
}
int n;
int main(){
	scanf("%d%d",&n,&mod);
	for(int i=BBB;i;i--){//a state that we have i chosen numbers in parallel
		for(int j=n;j>=i;j--)f[j]=f[j-i];f[i]=1;//force there to be at least one i exist.
		for(int j=i;j<=n;j++)ADD(f[j],f[j-i]);//do complete knapsack.
	}
	f[0]=1;//set f[0]=1 in order to do exclusion&inclusion.
	solve(n);
	bin[0]=1;for(int i=1;i<=n;i++)bin[i]=(bin[i-1]<<1)%mod;
	for(int i=0;i<n;i++)res=(1ll*f[i]*bin[n-i-1]+res)%mod;
	printf("%d\n",(bin[n]+mod-res)%mod);
	return 0;
}
```





---

## 作者：whiteqwq (赞：14)

[P8340 [AHOI2022] 山河重整](https://www.luogu.com.cn/problem/P8340) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/16254899.html)

## 题意

求有多少个值域 $[1,n]$ 的集合，做 01 背包后可以凑出 $[1,n]$ 内所有数。

$1\leqslant n\leqslant 5\times 10^5$。

## 分析

首先有一个很显然的 $O(n^2)$ dp：

令 $f_{i,j}$ 为使用了前 $i$ 个数字，目前最多可以凑出前缀 $[1,j]$ 的方案数，转移只需要新加入的区间拼的上就好了。

实际上，转移时的限制可以写作“集合中 $\leqslant k$ 的数之和要 $\geqslant k$”。于是我们考虑容斥，我们找到第一个不满足的位置 $p$ 进行转移，并乘上 $-1$ 的系数。

此时有一个很好的性质，由于 $p$ 之前的位置都满足性质，所以小于等于 $p-1$ 的数之和一定是 $p-1$。

那么就可以把 dp 变成一维的，令 $f_i$ 为 $[1,i]$ 内的数，和恰好为 $i$ 的方案的容斥系数之和。它的计算可以用正常的整数拆分减去 $f$ 带来的容斥转移。

这一类型的 dp 有一个很经典的优化到背包的方法，我们可以类似 [P6189 [NOI Online #1 入门组] 跑步](https://www.luogu.com.cn/problem/P6189)，一次要么加入一个钦定不满足的数字，要么给全局加若干次一，可以发现只会加入至多根号个数字，所以做这个 dp 的复杂度是 $O(n\sqrt n)$ 的。

但是我们在转移前必须把转移过来的 dp 值提前计算完成，可以使用类似半在线卷积，每次先求出前一半的 dp 值，再转移给后一半。

复杂度是 $n\sqrt n+\frac{n\sqrt n}{2}+\frac{n\sqrt n}{4}+\cdots=O(n\sqrt n)$ 的。

## 代码
```
#include<stdio.h>
#include<math.h>
const int maxn=500005;
int n,mod,ans,s;
int f[maxn],mul[maxn],g[maxn];
inline int inc(int x){
	return x>=mod? x-mod:x;
}
void solve(int n){
	if(n<=1)
		return ;
	solve(n/2);
	int s=sqrt(2*n);
	for(int i=s;i>=1;i--){
		for(int j=n;j>=i;j--)
			g[j]=g[j-i];
		for(int j=0,k=2*i;k<=n;j++,k+=i+1)
			g[k]=inc(g[k]+f[j]);
		for(int j=i;j<=n;j++)
			g[j]=inc(g[j]+g[j-i]);
	}
	for(int i=n/2+1;i<=n;i++)
		f[i]=inc(f[i]-g[i]+mod);
	for(int i=0;i<=n;i++)
		g[i]=0;
}
int main(){
	scanf("%d%d",&n,&mod),s=sqrt(2*n);
	mul[0]=1; 
	for(int i=1;i<=n;i++)
		mul[i]=(mul[i-1]+mul[i-1])%mod;
	for(int i=s;i>=1;i--){
		for(int j=n;j>=i;j--)
			f[j]=f[j-i];
		f[i]=inc(f[i]+1);
		for(int j=i;j<=n;j++)
			f[j]=inc(f[j]+f[j-i]);
	}
	f[0]=1;
	solve(n);
	for(int i=0;i<n;i++)
		ans=(ans+1ll*f[i]*mul[n-i-1])%mod;
	printf("%d\n",(mul[n]-ans+mod)%mod);
	return 0;
}
```

---

## 作者：一叶知秋。 (赞：10)

最后还是来发题解了。。。

有个比较显然的转化，合法的条件可以看作 $\forall i \in [1,n] \cap \mathrm N,\sum\limits_{j \in S,j \le i} j \ge i$

正难则反，考虑拿总方案减去不合法的，为了防止算重，我们可以计算 $f_i$ 为最小的 $i$ 使得条件不成立，不是很直观？有一个明显的性质，那就是 $i-1$ 一定是满足条件的，那么我们可以更改定义改为 $f_i$ 是 $\forall j \in [1,i] \cap \mathrm N$ 都满足条件的方案数，那么答案就是 $\sum\limits_{i=0}^{n-1}f_i 2^{n-i-1}$

如果没有条件，那么方案数就是每个数只能选至多一个的分划数，生成函数是

$$G(x)=\prod_{i=1}^{\infty}(1+x^i)=\sum_{i=1}^{\infty} g_i x^i$$

容斥一下，相当于是减掉 $i$ 之前有不合法的情况，如果是 $j+1$ 第一个不合法，要减去的数就是 $f_j$ 乘上从 $[j+2,i]$ 中选数加起来为 $i-j$ 的方案数，所以有递推式

$$f_i=g_i-[x^i]\sum_{j=0}^{i-1} f_j x^j\prod_{k=j+2}^{\infty}(1+x^k)$$

我们来试试推一推形如 $G(x)$ 这样的生成函数

这个也可以从类 $\text{Ferrers}$ 图像考虑

![](https://cdn.luogu.com.cn/upload/image_hosting/t3n1kx0v.png)

我们找到最大的斜三角，设其长度为 $h$ （其实容易发现 $h$ 就是这张图的宽度）

![](https://cdn.luogu.com.cn/upload/image_hosting/iob890n8.png)

我们把其删掉然后上端对齐，容易发现那么剩下的就变成了 $n-\frac{h(h+1)}{2}$ 的 $\text{Ferrers}$ 图像，但宽度不能超过 $h$ ，所以就有式子

$$\prod_{i=1}^{\infty}(1+x^i)=\sum_{h=1}^{\infty}x^{\frac{h(h+1)}{2}}\prod_{i=1}^h\frac{1}{1-x^i}$$

可以用类似的推导推出

$$\prod_{i=k+1}^{\infty}(1+x^i)=\sum_{h=1}x^{kh} \cdot x^{\frac{h(h+1)}{2}}\prod_{i=1}^h\frac{1}{1-x^i}$$

于是前面的递推式就可以写成

$$f_i=g_i-[x^i]\sum_{j=0}^i f_j x^j\sum_{h=1}^{\infty}x^{(j+1)h} \cdot x^{\frac{h(h+1)}{2}}\prod_{k=1}^h\frac{1}{1-x^k}$$

发现有贡献的 $j$ 必定小于 $\frac{i}{2}$ ，所以像先递归解决小于等于 $\frac{n}{2}$ 的，然后倒着枚举 $h$ ，一个一个加入然后每次多乘个 $\frac{1}{1-x^h}$ 就行了

[评测链接](https://loj.ac/s/1461242)

UPD. 更优的复杂度：（sto EI orz）

![](https://cdn.luogu.com.cn/upload/image_hosting/ng9r67gu.png)

---

## 作者：FifthAxiom (赞：5)

本篇与其说是题解，不如说是 EI 的 [[AHOI2022\] 山河重整 解析](https://www.cnblogs.com/Elegia/p/16339433.html) 的解析，~~因为原文实在太难懂了~~ 。

感谢 rqy 与 EI 对本人思路的指导！

## 题解分析

首先考虑将互异拆分数 $p_{n-1}$ 的生成函数拆成如下形式：
$$
\sum_k a_k x^k(1+x^{k+1})(1+x^{k+2})\cdots = x\cdot (1 + x)(1+x^2)\cdots
$$
对于右边显然就是上述生成函数。对于左边，考虑一个和为 $n-1$ 的集合 $S$ ，我们将其元素从小到大排序，其前缀集合为 $T$ 。令 $k$ 为最大的 $k$ 使得 $T$ 元素之和为  $k-1$ ，且能表示  $1,2,\cdots,k-1$ 。（此时 $T$ 就满足原文中关于 $a_k$ 的限制）这个时候由于已经知道 $k$ 是 $S$ 中最小的不可表示之数，只要再用  $k+1,k+2,\cdots$ 再凑出原来的 $S$ 即可。 由于任一选定的 $S$ 必然存在最小的不可表示之数，因此可以构造出所有的 $S$ 。于是上式成立。

类似于上述过程，我们也可以导出答案与 $a_k$ 的关系。考虑任一无法表示 $1,\cdots,n$ 中所有数的集合，找到其最小不可表示之数，则易知答案为 $\displaystyle 2^n - \sum_k a_k 2^{n-k}$ 。

在知晓一组 $a_k$ 的情况下，答案显然可以使用如下倍增算法计算：

```cpp
int res = 1;
    for (int i = 0; i < n; i++)
        add(res, res), sub(res, a[i]);
```



接下来就是如何求出 $a_k$ 。

设 $\displaystyle \sum_k a_k x^k=A(x),\quad (1+x^{k})(1+x^{k+1})\cdots=P(x^k)$。最关键的一步就是将 $P(x^k)$ 拆成如下形式：
$$
(1+x^k)(1+x^{k+1})\cdots = \sum_{j\ge 0}\frac{x^{j(j-1)/2+jk}}{(1-x)\cdots(1-x^j)}
$$
给出两种方法理解此式：

1.（偏组合，来自 rqy） 

左边为用  $k,k+1,\cdots$ 作互异拆分的方案数。也就是选出 $k\le k_1<k_2<\cdots<k_j$ 再统计 $\displaystyle x^{\sum k_i}$ 。考虑排除互异的限制，发现令  $t_i=k_i-k-i+1$ ，则有 $0\le t_1\le t_2\le\cdots\le t_j$ ，恰好为不超过 $j$ 部分的拆分数。减去的总次数就是 $j(j-1)/2+jk$ 。

2.（偏代数，来自 EI）

设 $q=x^k$ ，则有 $P(q)=(1+q)P(qx)$ 。
$$
\begin{aligned}
[q^n]P(q)&=[q^n]P(qx)+[q^{n-1}]P(qx)\\
		 &=x^n[q^n]P(q)+x^{n-1}[q^{n-1}]P(q)\\
		 &=\dfrac{x^{n-1}}{1-x^n}[q^{n-1}]P(q)
\end{aligned}
$$
当 $n=0$ 时显然有 $[q^0]P(q)=1$ 。

故
$$
\begin{aligned}
[q^n]P(q)&=\prod_{i=1}^n\frac{x^{i-1}}{1-x^i}=\frac{x^{n(n-1)/2}}{(1-x)\cdots(1-x^n)}\\
P(q)&=\sum_{n\ge 0}\frac{x^{n(n-1)/2}q^n}{(1-x)\cdots(1-x^n)}
\end{aligned}
$$


代入 $q=x^k$ 即证。

将 $P(x^k)$ 拆掉后，原恒等式的 LHS 可以展开成
$$
\begin{aligned}
\sum_{k} x^ka_k\sum_{j\ge 0}\frac{x^{j(j-1)/2+j(k+1)}}{(1-x)\cdots(1-x^j)}
&= \sum_{j\ge 0} \frac{x^{j(j+1)/2}}{(1-x)\cdots (1-x^j)} \sum_k a_k x^{(j+1)k}\\
& = \sum_{j\ge 0} \frac{x^{j(j+1)/2}}{(1-x)\cdots (1-x^j)} A(x^{j+1}),
\end{aligned}
$$


因此我们有 
$$
A(x) = x(1+x)(1+x^2)\cdots - \sum_{j\ge 1} \frac{x^{j(j+1)/2}}{(1-x)\cdots (1-x^j)} A(x^{j+1}).
$$
对于上式，可知对 $[x^n]A(x)$ 有贡献的项次数不超过 $\dfrac{n}{2}$ 。我们先递归处理前  $\dfrac{n}{2}$ 项，再对 $j$ 从大到小合并，从而求出整段的 $a_k$ 。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

const int N = 5e5 + 5;

int n, p;
int a[N], tmp[N];

inline void add(int &x, int y) { x += y; (x >= p) ? x -= p : x; }
inline void sub(int &x, int y) { x -= y; (x < 0) ? x += p : x; }

void calc(int n) {
    if (n < 2) return;
    calc(n >> 1);
    for (int i = 0; i <= n; i++) tmp[i] = 0;

    for (int j = sqrt(n << 1), sj = j * (j + 1) >> 1; j; sj -= j, j--) {
        for (int i = 0, pos = sj + j; pos <= n; i++, pos += j + 1) add(tmp[pos], a[i]);
        for (int i = 2 * j + sj; i <= n; i++) add(tmp[i], tmp[i - j]);
    }

    for (int i = n / 2 + 1; i <= n; i++)
        sub(a[i], tmp[i]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> p;
    tmp[0] = a[0] = 1;
    for (int j = 1, sj = 1; sj <= n; j++, sj += j) {
        for (int i = j; i <= n - sj; i++) add(tmp[i], tmp[i - j]);
        for (int i = sj; i <= n; i++) add(a[i], tmp[i - sj]);
    }

    calc(n - 1);
    int res = 1;
    for (int i = 0; i < n; i++)
        add(res, res), sub(res, a[i]);
    
    cout << res;
    return 0;
}
```





---

## 作者：WrongAnswer_90 (赞：0)

# [My Blogs](https://wronganswer90.github.io/2025/06/14/P8340-[AHOI2022]-山河重整)

### [P8340 [AHOI2022] 山河重整](https://www.luogu.com.cn/problem/P8340)

题目限制是，对于一种选法 $a$，要求 $\forall x,\sum_{a_i\leq x}a_i\geq x$。所以有暴力 DP $f_{i,j}$ 表示考虑了 $\leq i$ 的所有数，和是 $j$。复杂度 $\mathcal O(n^2)$。

考虑优化，首先两维的状态就爆了。进行容斥，$f_i$ 表示 $\sum_{a_j\leq i}a_j=i$，并且 $\leq i$ 的数全部合法的方案数，答案就是 $2^n-\sum_i f_i2^{n-i-1}$，表示钦定 $i+1$ 不合法，对第一次不合法的位置进行容斥。

考虑如何求 $f$，先设 $g_i$ 表示 $i$ 的互异分拆数。考虑把分拆数化成柱形图，一组拆分数 $\sum b_i=n$ 表示为横坐标为 $i$ 的格子上有一个高度为 $b_i$ 的主子。因为是互异的，所以数字个数是 $\mathcal O(\sqrt n)$ 的，也就是柱状图的宽度是 $\mathcal O(\sqrt n)$ 的。枚举最大宽度，因为要求互异，所以比他小的每一种宽度都需要至少有一行，所以从大到小枚举宽度转移 $g$ 就行了。

再考虑 $f$ 的转移：$f_i=g_i-\sum_{j<i}f_jval(j,i-j)$，$val(j,v)$ 表示用 $\geq j+2$ 的数凑出来 $v$ 的方案数。

这个不太好算，我们把所有的 $j$ 放到一起算。这个转移显然有 $i\geq 2j$，所以进行一个牛顿迭代（？）。假设已经知道了 $f_{\leq n}$，考虑如何推出 $f_{\leq 2n}$。

注意到上面的转移天然可以对最小值进行限制。仍然是从大到小枚举宽度，假设枚举到宽度为 $t$ 的，可以选择在 $h$ 中加入一个 $-f_j$ 的贡献：贡献到 $j+(j+2)t$ 的位置上，表示最小值需要大于等于 $j+2$，其余 $h$ 的转移和 $g$ 相同，最后 $f_i=g_i-h_i$ 即可。复杂度 $T(n)=T(n/2)+\mathcal O(n\sqrt n)=\mathcal O(n\sqrt n)$。

```cpp
    int n,MOD;
	int g[500010],f[500010],h[500010];
	const int B=999;
	inline void solve(int n)
	{
		for(int i=0;i<=n;++i)h[i]=0;
		for(int i=B;i>=1;--i)
		{
			for(int j=0;j+i*(j+1)<=n;++j)
			Madd(h[j+i*(j+1)],f[j]);
			for(int j=n;j>=i;--j)h[j]=h[j-i];
			for(int j=0;j<i;++j)h[j]=0;
			for(int j=i;j<=n;++j)Madd(h[j],h[j-i]);
		}
		for(int i=n/2+1;i<=n;++i)f[i]=Cdel(g[i],h[i]);
	}
	inline void mian()
	{
		read(n,MOD);
		g[0]=1;
		for(int i=B;i>=1;--i)
		{
			for(int j=n;j>=i;--j)g[j]=g[j-i];
			for(int j=0;j<i;++j)g[j]=0;
			Madd(g[i],1);
			for(int j=i;j<=n;++j)Madd(g[j],g[j-i]);
		}
		int m=2;
		f[0]=f[1]=1;
		while(m<n)solve(m),m<<=1;
		solve(n);
		int ans=power(2,n);
		for(int i=0;i<n;++i)Mdel(ans,Cmul(f[i],power(2,n-i-1)));
		write(ans,'\n');
	}
```

---


# [AHOI2022] 回忆

## 题目背景

生活在题面里的他们，是一群怪异的少年。

对城市中修建道路需满足的基本物理限制熟视无睹，沉迷于十万个城市、百万条道路上的各种结构。

明明知道真正需要的数字庞大到无法计算，却偏要关心它模一个奇怪素数之后得到的结果。

如此智力超群的他们，却总是在自己提出的诡异的问题下败下阵来，把它们一股脑地丢给你们来做。

如今，他们长大了。他们学习到更普适的理论，习惯了更抽象的符号，不必再思考如此古怪的问题。但他们不曾料到，你们却以这些 “无用” 的问题为驱动，于计算机学科体系的一隅，开垦出了一片独属于 OI 的新天地。

有一天，他们各自回忆起了少年时期提出的问题。

## 题目描述

少年时，他们提出了 $n$ 个问题，从 $1$ 到 $n$ 编号。一个问题总由一个更基础的问题衍生而来，因此问题之间构成了一个树形的结构：$1$ 号问题是最基本的问题，也就是树的根节点，而其他问题都由其父亲节点对应的问题衍生而来。如果两个问题在树上相邻，则称这两个问题**彼此相关**。

少年时期的他们一共做了 $m$ 次研究，第 $i$ 次的研究从提出较为基本的问题 $s_i$ 开始，将它不断地修改、推广，最终提出问题 $t_i$。这些研究满足 $s_i \ne t_i$ 且 **$\bm{s_i}$ 必定是 $\bm{t_i}$ 的祖先**。即使研究的问题完全相同，从不同的角度研究会有不同的结果，因此**可能存在 $\bm{i \ne j, (s_i, t_i) = (s_j, t_j)}$ 的情形**。

现在，他们正一轮轮地回忆着少年时提出的问题。在他们每一轮对问题的回忆中，他们首先回忆到 $n$ 个问题中的任意一个。接下来，如果存在与当前回忆到的问题**彼此相关且在这轮回忆中没有被回忆到**的问题，那么他们可以将思绪从当前问题上切换到这些问题中的**任意一个**，并回忆到这个新的问题。他们可以不断地切换思绪，也可以在回忆到任何一个问题之后结束回忆。**每一轮回忆是独立的，也就是说一个问题可以被多轮回忆回忆起。**

如果在某一轮回忆中，他们**同时**回忆到了问题 $s_i$ 和问题 $t_i$，则称第 $i$ 次研究**被想起**。

为了更好地理解上述概念，考察以下例子：$n = 5$，问题 $1$ 与问题 $2, 3$ 相关，问题 $3$ 与问题 $4, 5$ 相关。一轮可能的回忆是：从问题 $2$ 开始回忆，切换思绪到问题 $1$，再切换到问题 $3$，最终切换到问题 $5$ 并结束回忆。如果 $m = 4$，$(s_1, t_1) = (1, 2), (s_2, t_2) = (1, 4), (s_3, t_3) = (s_4, t_4) = (3, 5)$，那么这轮回忆会让第 $1$ 次、第 $3$ 次和第 $4$ 次研究被想起，而第 $2$ 次研究不会被想起。

他们问你们的最后一个问题是：**如果每轮回忆的起点以及思绪的切换可以任意选择，最少需要多少轮回忆才能使所有的研究都被想起。**

## 说明/提示

**【样例解释 \#1】**

样例中的第一组数据与题目描述所给的例子相同。一种可能的回忆方案为：

- 第一轮回忆中，从问题 $2$ 开始，依次切换思绪到问题 $1, 3, 5$。此时第 $1, 3, 4$ 次研究被想起，但第 $2, 5$ 次没有。
- 第二轮回忆中，从问题 $4$ 开始，依次切换思绪到问题 $3, 1$。此时第 $2, 5$ 次研究被想起。

第二组数据符合特性 A 的要求。一种可能的回忆方案为：第一次回忆依次回忆到 $2, 1, 3, 5, 6$，第二次回忆依次回忆到 $8, 7, 9, 10$。

**【样例 \#2】**

见附件中的 `memory/memory2.in` 与 `memory/memory2.ans`。

这组数据满足了测试点 $1 \sim 4$ 的条件。

**【样例 \#3】**

见附件中的 `memory/memory3.in` 与 `memory/memory3.ans`。

这组样例满足了特性 A 的条件。且除了后 $3$ 组数据外，其余样例均满足 $n, m \le 1000$。除了后 $30$ 组数据外，其余样例均满足 $n, m \le 30$。你也可以用这组样例完成对较小规模数据的测试。

**【样例 \#4】**

见附件中的 `memory/memory4.in` 与 `memory/memory4.ans`。

这组样例满足了测试点 $24 \sim 25$ 的条件。同样例 \#3，本样例满足：除了后 $3$ 组数据外，其余样例均满足 $n, m \le 1000$。除了后 $30$ 组数据外，其余样例均满足 $n, m \le 30$。你也可以用这组样例完成对较小规模数据的测试。

**【样例 \#5】**

见附件中的 `memory/memory5.in` 与 `memory/memory5.ans`。

这组样例满足了特性 B 的条件。

**【样例 \#6】**

见附件中的 `memory/memory6.in` 与 `memory/memory6.ans`。

这组样例满足了特性 C 的条件。

**【评分方式】**

对于每一组测试点，如果你的输出格式正确，且每一组数据输出的答案正确，那么你会获得 $4$ 分。

否则，如果你的输出格式正确，且对于每一组数据，你输出的答案**与正确答案相等或者比正确答案大 $\bm{1}$**，那么你将在此测试点上获得 $3$ 分。

**【数据范围】**

本题共 $25$ 个测试点。对于所有的测试点，$1 \le n, m \le 2 \times {10}^5$，$1 \le \sum n, \sum m \le
5 \times {10}^5$，$1 \le u_i, v_i, s_i, t_i \le n$，$s_i \ne t_i$。保证输入的 $(u_i, v_i)$ 构成一棵树，$s_i$ 在以 $1$ 为根的树上是 $t_i$ 的祖先。

| 测试点 | 规模限制 | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $T \le 3000$，$n \le 50$，$m \le 15$ 且最多有 $5$ 组数据满足 $m \ge 10$ | 无 |
| $5 \sim 6$ | $n, m \le 100$，$\sum n^3, \sum m^3 \le 3 \times {10}^7$ | A |
| $7$ | $n, m \le 100$，$\sum n^3, \sum m^3 \le 3 \times {10}^7$ | B |
| $8$ | $n, m \le 100$，$\sum n^3, \sum m^3 \le 3 \times {10}^7$ | C |
| $9$ | $n, m \le 100$，$\sum n^3, \sum m^3 \le 3 \times {10}^7$ | 无 |
| $10 \sim 11$ | $n, m \le 1000$，$\sum n^2, \sum m^2 \le 3 \times {10}^7$ | A |
| $12$ | $n, m \le 1000$，$\sum n^2, \sum m^2 \le 3 \times {10}^7$ | B |
| $13$ | $n, m \le 1000$，$\sum n^2, \sum m^2 \le 3 \times {10}^7$ | C |
| $14 \sim 16$ | $n, m \le 1000$，$\sum n^2, \sum m^2 \le 3 \times {10}^7$ | 无 |
| $17 \sim 18$ | $n, m \le 2 \times {10}^5$，$\sum n, \sum m \le 5 \times {10}^5$ | B |
| $19 \sim 20$ | $n, m \le 2 \times {10}^5$，$\sum n, \sum m \le 5 \times {10}^5$ | C |
| $21 \sim 23$ | $n, m \le 2 \times {10}^5$，$\sum n, \sum m \le 5 \times {10}^5$ | A |
| $24 \sim 25$ | $n, m \le 2 \times {10}^5$，$\sum n, \sum m \le 5 \times {10}^5$ | 无 |

特殊性质 A：保证 $n$ 为偶数，且树的结构为：对于任意正整数 $1 \le i \le \lfloor \frac{n}{2} \rfloor$，$2 i$ 的父亲为 $2 i - 1$；若 $i \ge 2$，则 $2 i - 1$ 的父亲为 $2 i - 3$。  
特殊性质 B：保证对于所有的正整数 $1 \le i \le m$，$s_i$ 为 $t_i$ 的父亲。  
特殊性质 C：保证对于所有的正整数 $1 \le i \le m$，$s_i = 1$。

请注意，**测试点的难度与编号并没有直接关系**。

**【提示】**

请注意，为了取得部分分，你必须保证输出格式正确，即：输出恰好有 $m$ 行，且每行是一个正整数。

此外，如果某组测试数据中你输出的结果比答案小 $1$ 而不是大 $1$，那么你**不能**在该测试点获得 $3$ 分。

本题部分测试点读入量较大。为了优化程序的总运行时间，我们建议你采用较为快速的读入方式。

## 样例 #1

### 输入

```
2
5 5
1 2
3 1
3 4
5 3
1 2
1 4
3 5
3 5
3 4
10 5
1 2
3 1
3 4
5 3
6 5
7 8
5 7
7 9
9 10
1 2
3 5
5 6
7 8
9 10
```

### 输出

```
2
2
```

# 题解

## 作者：TheLostWeak (赞：26)

一个 $O(n+m)$ 的解法？

称一条路径的 **目标深度** 为要满足分配给它的点对的限制至少需要达到的深度。

对于已经完成目标的路径，将直的路径（即一个端点是另一个端点的祖先的路径）称作 **尚未匹配的路径**，两条拼接在一起的直的路径称作 **完成匹配的路径对**。

考虑一个点子树内的信息，可以表示成若干个完成匹配的路径对、若干条尚未匹配的路径、若干条尚未完成目标的路径。

其中，对于尚未匹配的路径，我们能匹配就先匹配掉，因为已经完成的匹配之后可以拆，而现在没有匹配以后就不知道能不能匹配了。

如果有多条尚未完成目标的路径，我们只需保留一条路径继续做匹配，剩余的路径完成当前的任务就可以收工了。而保留的那条路径一定是 **目标深度最小** 的路径，所以对于其余尚未完成目标的路径可以直接在对应深度打标记表示到了那时会多出一条完成任务的 **尚未匹配的路径**。

先是对于边界情况，注意到几个结论：

- 对所有存在限制 $(x,y)$ 且子树内没有其他限制的点 $y$，肯定存在一种最优方案，使得所有 $y$ 都是某条路径的端点。（比较显然）
- 如果存在限制 $(x,y)$，且点 $y$ 子树内有其他限制，那么从子树内引一条路径上来一定不劣：
  - 如果子树内存在没有匹配的路径，显然引上来一定不劣。
  - 否则，新建路径只能得到一条向上的路径，**拆散一对匹配并引一条路径上来** 除了这条向上的路径外还能产生一条尚未匹配的路径。两者所需路径数相同，而后者显然更优一些。

然后再去考虑两个子树 $X,Y$ 信息的贪心合并：

- 如果都有尚未完成目标的路径，只要按照前面提到的方式保留一条即可。
- 假设 $Y$ 尚未匹配的路径较多，如果 $X$ 总路径数大于等于 $Y$ 的尚未匹配路径数，则除了路径总数为奇数时会多出一条路径之外，其余路径都能完成匹配；否则，就用 $X$ 所有路径去与 $Y$ 尚未匹配的路径匹配。

于是就做完了？时间复杂度 $O(n+m)$，代码也很好写。

不知道上面的过程会不会有什么问题，万一把我叉掉了通知我一下......

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Rg register
#define RI Rg int
#define Cn const
#define CI Cn int&
#define I inline
#define W while
#define N 200000
#define add(x,y) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y)
using namespace std;
namespace FastIO
{
	#define FS 100000
	#define tc() (FA==FB&&(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)
	#define pc(c) (FC==FE&&(clear(),0),*FC++=c)
	int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;
	I void clear() {fwrite(FO,1,FC-FO,stdout),FC=FO;}
	Tp I void read(Ty& x) {x=0;W(!isdigit(oc=tc()));W(x=(x<<3)+(x<<1)+(oc&15),isdigit(oc=tc()));}
	Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
	Tp I void writeln(Ty x) {W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc('\n');}
}using namespace FastIO;
int n,m,ee,lnk[N+5];struct edge {int to,nxt;}e[N<<1];
int D[N+5];void dfs(CI x,CI lst=0)//预处理深度
{
	for(RI i=lnk[x];i;i=e[i].nxt) e[i].to^lst&&(D[e[i].to]=D[x]+1,dfs(e[i].to,x),0);
}
int a[N+5],b[N+5],mn[N+5],g[N+5],h[N+5];void Solve(CI x,CI lst=0)
{
	for(RI i=lnk[x],y;i;i=e[i].nxt) if((y=e[i].to)^lst)
	{
		if(Solve(y,x),b[y]+=h[D[x]],h[D[x]]=0,!a[y]&&!b[y]&&!mn[y]) continue;//子树为空，无需合并
		mn[y]==D[x]&&(++b[y],mn[y]=0);//完成了目标
		if(mn[x]&&mn[y]) mn[x]<mn[y]?++h[mn[y]]:(++h[mn[x]],mn[x]=mn[y]);else mn[x]|=mn[y];//合并尚未完成目标的路径
		if(b[x]>b[y]) swap(a[x],a[y]),swap(b[x],b[y]);//让y尚未匹配的路径数较大
		if(2*a[x]+b[x]>=b[y]) a[x]=a[x]+a[y]+(b[x]+b[y]>>1),b[x]=(b[x]+b[y])&1;//能匹配完
		else b[y]-=2*a[x]+b[x],a[x]=2*a[x]+b[x]+a[y],b[x]=b[y];//匹配不完
	}
	if(g[x]) mn[x]?mn[x]=min(mn[x],g[x]):(mn[x]=g[x],b[x]?--b[x]:a[x]&&(--a[x],++b[x]));//处理当前点上的要求
}
int main()
{
	RI Tt,i,x,y;read(Tt);W(Tt--)
	{
		for(read(n,m),ee=0,i=1;i<=n;++i) lnk[i]=a[i]=b[i]=g[i]=mn[i]=0;
		for(i=1;i^n;++i) read(x,y),add(x,y),add(y,x);D[1]=1,dfs(1);
		for(i=1;i<=m;++i) read(x,y),g[y]=g[y]?min(g[y],D[x]):D[x];//在y处记录要求
		Solve(1),writeln(a[1]+b[1]);
	}return clear(),0;
}
```



---

## 作者：ix35 (赞：17)

看上去比 std 做法快很多而且好写很多？

首先，我们做一些准备工作，如果研究 $(s_i,t_i)$ 覆盖了研究 $(s_j,t_j)$，那么我们就删掉 $(s_j,t_j)$，这可以排序后用一个 DFS 序上的树状数组做到 $O(n\log n)$。于是，现在认为研究之间两两没有包含关系。

接下来我们考虑所有满足以下条件的 $(s_i,t_i)$：不存在某个 $t_j$ 是其后代。这样的 $t_i$ 实际上就是一组极大的两两没有祖先关系的 $t_i$。我们称这些研究 $(s_i,t_i)$ 是**关键的**。

对于根结点 $1$ 的每个儿子 $x_1,\ldots,x_k$，考虑其中关键研究的个数，不妨设为 $z_1\leq \ldots\leq z_k$，那么我们首先给出一个答案的下界，那就是 $\lceil(\sum z_i)/2\rceil$，因为任意三个关键研究不可能被一条路径覆盖（容易证明），所以一条路径至多只能满足两个研究。

当 $z_1+\ldots+z_{k-1}\ge z_k$ 时，这个下界是可以取到的，因为我们只需将关键研究两两配对，使得同一对中的关键研究属于 $1$ 的不同子树，然后用一条 LCA 为 $1$ 的路径将它们覆盖。

而当 $z_1+\ldots+z_{k-1}<z_k$ 时就不一定可行了，因为这时没有上述配对方案。但我们知道此时 $y_1,\ldots,y_{k-1}$ 子树中的关键研究是不会出现配对的（总是可以调整成与 $y_k$ 子树中的关键研究配对），所以我们可以递归儿子 $y_k$，将答案加上 $z_1+\ldots+z_{k-1}$，之后我们就有了 $z_1+\ldots+z_{k-1}$ 条“闲置路径”，可以免费覆盖任意一个关键研究。

事实上，上面的过程类似于在寻找所有关键研究中的 $t_i$ 的重心。

上面的算法有一些需要修补的地方，从 $1$ 递归到 $y_k$ 时我们可能漏掉了一些 $s_i=1$ 的**非关键**研究，之后可能会覆盖不到，下面来解决这个问题。

我们发现，从 $1$ 递归到 $y_k$ 时我们加的限制其实是：添加了一些“免费”的路径，其中一部分是可以连向 $y_k$ 的任意后代的，另一部分则只能连向特定的某个结点的任意后代。

于是，我们引入一个对结点的标记，一个结点上有标记就表示：存在一条免费的路径可以连到这个结点的任意后代。

每一轮递归流程如下：

- 首先计算 $z_1,\ldots,z_k$，如果 $z_1+\ldots+z_{k-1}<z_k$，那么先令 免费路径数 增加 $z_1+\ldots+z_{k-1}$，同时答案也增加 $z_1+\ldots+z_{k-1}$；
- 接下来考虑所有 $s_i=1$ 的研究 $(s_i,t_i)$：

  1. 如果存在 $t_i$ 的一个比当前点更深的祖先拥有标记，则找到其中最深的标记，将其移动到 $t_i$ 上；
  2. 如果不存在上述拥有标记的祖先，则 如果当前免费路径数不为 $0$，则令免费路径数 -1，同时在 $t_i$ 上打标记；
  3. 如果不存在上述拥有标记的祖先，而且免费路径数为 $0$，则答案 +1，同时在 $t_i$ 上打标记。

标记以及 $z_i$ 的求解都可以用树状数组实现，复杂度为 $O((n+m)\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=200010;
struct P {int a,b;} p[MAXN];
int t,n,m,x,y,tot,ans,bt[MAXN],tb[MAXN],sy[MAXN],f[MAXN];
int dfn[MAXN],ed[MAXN],vis[MAXN],dep[MAXN];
vector <int> v[MAXN],w[MAXN];
void modify1 (int x,int v) {
	for (int i=x;i<=n;i+=(i&(-i))) {bt[i]+=v;}
}
int query1 (int x) {
	int res=0;
	for (int i=x;i;i-=(i&(-i))) {res+=bt[i];}
	return res;
}
void modify2 (int x,int v) {
	for (int i=x;i<=n;i+=(i&(-i))) {tb[i]+=v;}
}
int query2 (int x) {
	int res=0;
	for (int i=x;i;i-=(i&(-i))) {res+=tb[i];}
	return res;
}
bool cmp (P a,P b) {return dep[a.a]==dep[b.a]?dep[a.b]>dep[b.b]:dep[a.a]<dep[b.a];}
void dfs (int x,int fa) {
	dfn[x]=ed[x]=++tot,dep[x]=dep[fa]+1,f[x]=fa;
	int len=v[x].size();
	for (int i=0;i<len;i++) {
		if (v[x][i]==fa) {continue;}
		dfs(v[x][i],x);
		ed[x]=ed[v[x][i]];
	}
	return;
}
void dfs2 (int x,int fa) {
	int len=v[x].size(),flg=(vis[x]==1);
	for (int i=0;i<len;i++) {
		if (v[x][i]==fa) {continue;}
		dfs2(v[x][i],x);
		vis[x]+=vis[v[x][i]];
	}
	if (vis[x]==1&&flg) {modify1(dfn[x],1);}
	return;
}
int main () {
	scanf("%d",&t);
	for (int ii=1;ii<=t;ii++) {
		scanf("%d%d",&n,&m);
		tot=ans=0;
		for (int i=1;i<=n;i++) {v[i].clear(),w[i].clear(),bt[i]=tb[i]=sy[i]=vis[i]=0;}
		for (int i=1;i<=n-1;i++) {
			scanf("%d%d",&x,&y);
			v[x].push_back(y),v[y].push_back(x);
		}
		dfs(1,0);
		for (int i=1;i<=m;i++) {
			scanf("%d%d",&x,&y);
			p[i].a=x,p[i].b=y;
		}
		sort(p+1,p+m+1,cmp);
		for (int i=1;i<=m;i++) {
			int sum=query2(ed[p[i].b])-query2(dfn[p[i].b]-1);
			if (sum==0) {w[p[i].a].push_back(p[i].b),vis[p[i].b]=1;}
			modify2(dfn[p[i].b],1);
		}
		for (int i=1;i<=n;i++) {tb[i]=0;}
		dfs2(1,0);
		int cur=1;
		while (cur) {
			int len=v[cur].size(),sum=0,mx=0,alp=0;
			for (int i=0;i<len;i++) {
				if (v[cur][i]==f[cur]) {continue;}
				int tmp=query1(ed[v[cur][i]])-query1(dfn[v[cur][i]]-1);
				if (tmp>mx) {mx=tmp,alp=v[cur][i];}
				sum+=tmp;
			}
			//cout << "    " << cur << "  " << sum << "  " << mx << "  " << sy[cur] << endl;
			if (mx<=sum-mx+sy[cur]) {
				ans+=(sum-sy[cur]+1)/2;
				break;
			}
			sy[cur]+=sum-mx,ans+=sum-mx;
			//cout << cur << "  " << alp << "  " << sy[cur] << "  " << ans << endl;
			int len2=w[cur].size();
			for (int i=0;i<len2;i++) {
				if (dfn[w[cur][i]]<dfn[alp]||ed[alp]<ed[w[cur][i]]) {continue;}
				int val=query2(dfn[w[cur][i]]);
				if (val) {
					modify2(dfn[val],-val),modify2(ed[val]+1,val);
					modify1(dfn[val],1),sy[val]--;
				} else if (sy[cur]) {
					sy[cur]--;
				} else {
					ans++;
				}
				modify2(dfn[w[cur][i]],w[cur][i]),modify2(ed[w[cur][i]]+1,-w[cur][i]);
				modify1(dfn[w[cur][i]],-1),sy[w[cur][i]]++;
			}
			if (sy[alp]) {
				modify2(dfn[alp],-alp),modify2(ed[alp]+1,alp);
			}
			//cout << cur << "  " << alp << "  " << sy[cur] << "  " << ans << endl;
			sy[alp]+=sy[cur];
			cur=alp;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：feecle6418 (赞：17)

credit https://www.cnblogs.com/chenxiaoran666/p/Luogu8341.html

因为树上贪心一定要从下往上，考虑从下往上贪心。每个点只保留深度最浅的以其为下端点的限制。

称 路径 为直上直下的路径；称两条路径 匹配 为它们能连接起来成为一条路径。

首先，找出所有子树内没有限制下端点，自身又是限制下端点的点，容易证明：一定存在一种最优方案，所有路径的端点都属于这些点。

我们的目标是尽量少开始路径，尽量多匹配路径。

考虑在 $x$ 子树内有哪些路径：

1. 尚未达到自己目标深度的路径。
2. 已经达到目标深度，可以匹配的路径。
3. 已经与匹配的有上有下的路径。

1 类路径只需要特殊处理目标深度最小的这一条，这一条可以用来满足 $x$ 到 1 这条链上其它的限制；其它 1 类路径在达到目标深度后会自动变成 2 类路径，可以在深度上打标记实现。

2,3 类路径可以互相转化（可以把 3 拆成两个 2）。合并两个子树 $p,q$ 时，贪心匹配它们内部的路径。假设 $p,q$ 分别 2 类路径数为 $x,y$，3 类路径数为 $a,b$。

发现肯定是用 $x,y$ 小的那一边去匹配大的那一边（因为把内部 3 类路径拆开拿来匹配并不会增加答案）。不妨假设 $x<y$。

- $x+2a\ge y$：此时可以完全配对，根据奇偶性至多留下一条路径。
- $x+2a<y$：会剩下 $y-(x+2a)$ 条路径。

合并完子树后，处理 $x$ 自己开始的贡献。

如果 $x$ 子树内还有 1 类路径没有完结，根据上面的说法，它就是拿来处理这里新加这条这样的路径的。故直接把这条路径拉长。

否则，我们不得不新开一条路径来满足 $x$ 本身的要求。我们可以直接拿出一条 2 类路径，或拆掉一条 3 类路径。如果 2,3 类路径都没有就不得不新开一条路径。（注意！“新开路径”并没有显示在算法中体现，因为我们是在它完成自己任务之后才把它作为可以匹配的路径加进来的，这也是贪心算法的前提。所以，现在这里新开路径不需要做其它操作；反而是拉长一条原本有的路径需要把当前贡献减一。）

整个做法时间复杂度 $O(n+m)$。

以下瞎扯一下正确性。这个算法自己有一些非常让人信服的点。

1. 注意到每个限制我们尽量在深的地方拿出来配，越深配在之后能做的事情越多。
2. 算法的部分内部都显然正确。
3. 整个过程完全从下往上，符合“树上一定要从下往上而非从上往下”的教训（应该叫 经验）。

```cpp
int n,m,a[200005],b[200005],d[200005],mn[200005],tag[200005],to[200005];
//a:已经匹配 b:尚未匹配 
vector<int> g[200005];
void dfs1(int x,int fa){
	d[x]=d[fa]+1;
	for(int y:g[x]){
		if(y==fa)continue;
		dfs1(y,x);
	}
}
void dfs2(int x,int fa){
	for(int y:g[x]){
		if(y==fa)continue;
		dfs2(y,x),b[y]+=tag[d[x]],tag[d[x]]=0;
		//y子树内延伸上来的，打在y上
		if(mn[y]==d[x])b[y]++,mn[y]=0;
		if(mn[x]&&mn[y]){
			if(mn[x]<mn[y])tag[mn[y]]++;
			else tag[mn[x]]++,mn[x]=mn[y];
		}
		else mn[x]|=mn[y];
		if(b[x]<b[y])swap(b[x],b[y]),swap(a[x],a[y]);
		if(b[y]+2*a[y]>=b[x]){
			int w=b[x]+b[y]+2*a[y];
			a[x]+=(w>>1),b[x]=(w&1);
		}
		else b[x]-=b[y]+2*a[y],a[x]+=b[y]+2*a[y];
	}
	if(to[x]){
		if(!mn[x]){
			mn[x]=to[x];
			if(b[x])b[x]--;
			else if(a[x])a[x]--,b[x]++;
		}
		else mn[x]=min(mn[x],to[x]);
	}
}
void Solve(){
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<n;i++)scanf("%d%d",&x,&y),g[x].push_back(y),g[y].push_back(x);
	dfs1(1,0);
	for(int i=1,x,y;i<=m;i++){
		scanf("%d%d",&x,&y);
		if(!to[y]||to[y]>d[x])to[y]=d[x];
	}
	dfs2(1,0);
	cout<<a[1]+b[1]<<'\n';
	for(int i=1;i<=n;i++)mn[i]=tag[i]=to[i]=a[i]=b[i]=0,g[i].clear();
}
```



---

## 作者：Suiseiseki (赞：7)

事先声明，该做法没有经过严格的证明，我也不清楚它到底对不对，但是它可以通过省选原题的所有数据，欢迎提供证明或者提供 Hack。

首先，显然对于每一个点 $u$ 只有一条 $(s_i,t_i)$ 使得 $t_i=u$，若真的有多个，取 $s_i$ 最浅的。

我们考虑贪心，在以 $u$ 为根的子树中，存在若干条已经完成的路径和若干条向上的路径等待匹配，等待匹配的路径分为 $s_i$ 在 $u$ 之上（即目前还不能匹配），和 $s_i$ 是 $u$ 或者在 $u$ 之下（即目前已经可以匹配），我们使用数据结构维护目前还不能匹配的深度的可重集合，显然，我们希望找到一种方式使得它目前可以匹配的路径数量既可能多，且对于不能匹配的路径 $s_i$ 的深度都尽可能深。

接下来我们考虑合并自己的孩子集合并将其匹配。

如果当前孩子可以进行匹配的向上路径恰好能够完全匹配（或者只剩一条），那么我们直接进行匹配即可。

否则定然有一个子树的未匹配路径数比其它子树加起来都多，那么我们考虑拆掉其它子树内部已经匹配的路径，再进行匹配。

最后我们要加入一条 $t_i=u$ 的路径，如果我们目前还不可以匹配的路径集合不为空，那么将它和集合中最浅的合并（根据不能匹配的路径 $s_i$ 的深度都尽可能深的原则），否则，如果当前子树内存在目前可以匹配但未匹配的路径，将当前点的路径与其匹配，若以上两种情况都不满足，再判断子树内是否有已经匹配的路径，将其拆开，其中一条与当前路径匹配，另一条作为目前可以匹配但未匹配的路径。

由于我们的数据结构需要支持查询最小值，查询最大值，删除最小值，删除最大值，以及合并，我在考场上偷懒写了 set + 启发式合并，得到了 $O(n\log^2 n)$ 的时间复杂度，然而如果用四个可并堆模拟或者用线段树合并就可以做到 $O(n\log n)$ 的时间复杂度。

时间复杂度：$O(n\log^2 n)$ 或 $O(n\log n)$。

代码可以去我的博客查看：[AHOI2022 回忆 题解](https://www.cnblogs.com/withhope/p/16251769.html)

---

## 作者：Kubic (赞：6)

好像是左爷出的题，先膜为敬 Orz

用人话翻译一下题意就是：给定树上若干条祖先后代链，要求另外选出最少的链（不要求是祖先后代链）覆盖给定的祖先后代链。

我们先去除一些无用点。具体来说，对于一个点 $u$，如果不存在任何一个 $t_i$ 在它的子树中，我们就可以把它直接删掉。显然这样做不影响答案。

我们可以先列出一些比较显然的结论：

- 存在一种最优方案，满足任何一条选出的链两个端点一定是叶子。

- 存在一种最优方案，满足任何一个叶子不会称为两条选出的链的端点。

令 $leaf_u$ 表示 $u$ 的子树中的叶子个数，$mx=\max\limits_{v\in son(root)} leaf_v,sum=\sum\limits_{v\in son(root)} leaf_v$，$pos$ 为满足 $v\in son(root),leaf_v=mx$ 的所有 $v$ 中的任意一个。

容易发现：

- 如果 $sum\ge 2mx$，那么可以在根节点处组成 $\left\lfloor\dfrac{sum}{2}\right\rfloor$ 对匹配。

- 如果 $sum<2mx$，那么可以在根节点处组成 $sum-mx$ 对匹配。

如果是第一种情况，那么已经达到了答案的下界，直接返回即可。

如果是第二种情况，此时对于所有满足 $v\in son(root),v\neq pos$ 的 $v$ 都不需要额外考虑，因为这些 $v$ 的子树中的叶子节点所产生的链一定都要连到根节点进行匹配。

由于 $pos$ 下面连上来的链太多了，我们希望它们在 $pos$ 的子树内部尽量消耗。也就是说，我们要求出 $pos$ 的子树内部最多能产生多少组匹配。这实际上与原问题等价，可以递归处理。

但这里还没有考虑给定的限制。

此时我们需要钦定一些链，强制将它们连上来，它们不能在 $pos$ 的子树中被匹配。显然我们不希望被强制连上来的太多。

对于当前的 $root$，拿出所有 $s_i=root$ 的限制。

如果两个限制的 $t_i$ 为祖先后代关系，那么可以把 $t_i$ 为祖先的那个限制去掉，因为它严格弱于另一个限制。这个我们可以暴力跳父亲维护，均摊 $O(n)$。

此时递归到的子问题中每个子树的权重变为了 $leaf_v-cnt_v$，其中 $cnt_v$ 表示它内部被强制连上去的链的条数，可以在维护上面的部分的基础上加一个树状数组来维护子树和来求出 $cnt_v$。

此时需要注意到一个细节：可能存在一个限制强制当前 $root$ 的子树中连上去一条链这种情况。显然从 $pos$ 的子树中连这一条链是最优的，这样可以尽量减少 $mx$ 的值。如果依然要递归到 $pos$，那么就把这个限制也传到 $pos$ 即可。

总结一下，我们的整个过程如下：

- 求出当前的 $root$ 的每一个儿子的子树的权重。

- 求出 $mx,sum,pos$。

- 如果存在一个限制强制从 $root$ 的子树中练上去一条链，那么执行 $mx\leftarrow mx-1,sum\leftarrow sum-1$，同时增加一个对 $pos$ 的子树的限制。

- 如果 $sum\ge 2mx$，返回 $\left\lfloor\dfrac{sum}{2}\right\rfloor$。

- 如果 $sum<2mx$，加入所有 $s_i=root$ 的限制，递归到 $pos$ 的子树中处理。令 $t$ 为 $pos$ 的子树中产生的匹配数量。执行 $mx\leftarrow mx-2t,sum\leftarrow sum-2t$。此时：

  - 如果 $sum\ge 2mx$，返回 $\left\lfloor\dfrac{sum}{2}\right\rfloor$。
  - 如果 $sum<2mx$，返回 $sum-mx$。

至此，我们就在 $O(n\log n)$ 的时间复杂度内解决了这个问题。数据结构上只需要用到一个树状数组，常数很小。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 200005
#define LIM 1000005
#define mid ((l+r)/2)
#define pb push_back
#define gc() (P1==P2 && (P2=(P1=buf)+fread(buf,1,LIM,stdin),P1==P2)?EOF:*P1++)
char *P1,*P2,buf[LIM];
int T,n,m,fa[N],lf[N],L[N],R[N],vl[N];
bool vs[N],tg[N];vector<int> e[N],e1[N],vc[N];
int rd()
{
	int res=0;char c=0;while(!isdigit(c)) c=gc();
	while(isdigit(c)) res=res*10+(c-48),c=gc();return res;
}
void clear() {for(int i=1;i<=n;++i) vl[i]=0;}
void upd(int x,int w) {for(;x<=n;x+=x&-x) vl[x]+=w;}
int qSm(int x) {int res=0;for(;x;x-=x&-x) res+=vl[x];return res;}
void ins(int u)
{
	if(vs[u]) return;if(!tg[u]) tg[u]=1,upd(L[u],1);
	for(int i=fa[u];!vs[i];i=fa[i]) {vs[i]=1;if(tg[i]) tg[i]=0,upd(L[i],-1);}
}
void dfs1(int u,int f) {for(auto v:e1[u]) if(v!=f) dfs1(v,u),vs[u]|=vs[v];}
void dfs2(int u,int f)
{
	fa[u]=f;lf[u]=f && e[u].size()<2;L[u]=++L[0];
	for(auto v:e[u]) if(v!=f) dfs2(v,u),lf[u]+=lf[v];R[u]=L[0];
}
int slv1(int u)
{
	int t,s=0,mx=-1,ps=0;
	for(auto v:e[u]) if(v!=fa[u])
	{t=lf[v]-qSm(R[v])+qSm(L[v]-1);s+=t;if(t>mx) mx=t,ps=v;}
	s-=mx;if(tg[u]) --mx;mx=max(mx,0);if(mx<=s) return (s+mx)/2;
	if(tg[u]) ins(ps);for(auto v:vc[u]) if(L[v]>=L[ps] && R[v]<=R[ps]) ins(v);
	t=slv1(ps);mx-=t*2;if(mx<=s) return (s+mx)/2+t;return s+t;
}
void slv()
{
	n=rd();m=rd();L[0]=0;clear();
	for(int i=1;i<=n;++i)
		vs[i]=tg[i]=0,e[i].clear(),e1[i].clear(),vc[i].clear();
	for(int i=1,u,v;i<n;++i) u=rd(),v=rd(),e1[u].pb(v),e1[v].pb(u);
	for(int i=1,u,v;i<=m;++i) u=rd(),v=rd(),vc[u].pb(v),vs[v]=1;dfs1(1,0);
	for(int i=1;i<=n;++i) if(vs[i]) for(auto j:e1[i])
		if(vs[j]) e[i].pb(j);dfs2(1,0);
	for(int i=1;i<=n;++i) vs[i]=0;printf("%d\n",lf[1]-slv1(1));
}
int main() {T=rd();while(T--) slv();return 0;}
```

---

## 作者：FjswYuzu (赞：5)

看了这个题不如看下[这个题](https://www.luogu.com.cn/problem/P7246)？

题意比较清楚，就不讲了。

首先有个简单结论是，如果有多组 $(s_i,t)$ 的关系，我们只需要保留 $s_i$ 深度最小的关系 $(s_i,t)$ 即可。

然后是因为所有的 $(s_i,t_i)$ 都是祖孙关系，因此如果我们选择了一条路径使得它的端点在一个点的两个子树内，可以拆成两条路径且仍然保证合法。

记两个端点是祖孙关系的路径为一类路径，在一个点的两个不同子树内的路径为二类路径。借用上面那个题的思路，我们维护子树内的二类路径个数，并记下当前可以往上延申的一类路径个数（可能会有已经伸上去的，我们在那里打标记就好），然后记录当前一类路径伸到的最浅的深度。

本来根据 Intro 题目的结论可以知道向上的一类路径是越多越好的，但是因为在这里二类路径可以随时转成一类路径并且次数也比较小，那这里变成了子树内的二类路径越多越好。

继续沿用上面那个题的做法，从下往上考虑。先考虑一个结点合并两个子树。先处理掉一类路径往上到的最浅深度，然后记 $p$ 子树 $u$ 内一类路径有 $u_1$ 条，子树 $v$ 内一类路径有 $v_1$ 条，$u_2,v_2,p_1,p_2$ 同理。那么合并到当前点 $p$，按下面的流程处理：

- 先匹配两个子树内的一类路径，记 $c=\min(u_1,v_1)$，则 $p_2 \gets^+ c, u_1 \gets^- c,v_1 \gets^- c$（容易发现此时每匹配一个答案就小 $1$）；    
- 现在 $u_1,v_1$ 中一定有一个是 $0$，假设 $v_1$ 为 $0$，则考虑拆开 $v_2$ 中的路径与 $u_1$ 的两条匹配，匹配越多越好（每拆开一对并完全匹配答案小 $1$）；    
- 然后整不了花活，往上传。

接下来，如果当前一类路径延申不到 $p$ 结点需要的最浅深度 $d_p$，我们需要拉长路径或者拆开路径。采用这样的策略：

- 如果子树内最浅的一类路径比当前结点浅：直接把这条路径拉长到 $d_p$；   
- 否则，我们需要用之前的路径：
  - 如果有一类路径：拉长到 $d_p$；   
  - 如果没有一类路径，有二类路径：拆开，选择一条拉长到 $d_p$；     
  - 都没有：直接造一条拉到 $d_p$ 的路径。

局部正确性显然啊。

然后考虑拉到 $d$ 的路径怎么实现，在这个子树内留下一个标记数组表示有一条上端点在深度 $d$ 的个数就好，处理的时候只需要在满足 $d_p = d$ 的 $p$ 合并子树的时候加到 $p$ 上面。

接下来是直觉与丢失的证明，直觉有了就好了，基本是经验之谈。

剩下的事情就是模拟了。

```cpp
int f[200005],g[200005];
int spr[200005];
/*
 * f[u]: 向上（子树内）
 * g[u]: 横叉（子树内） // 这里口胡了，但是意思大概都懂啊。
 * spare[u]: 有一些必须被引到 up，这时候直到 up 才可以使用。 // 即标记数组
 */
void merge(int u,int v)
{
	f[v]+=spr[dep[u]],spr[dep[u]]=0;
	/*
	 * 挂到 dep[u] 的直向上的路径。
	 * 这么写的原因也比较清楚，这里要强调只在一个子树内。
	 */
	if(f[u]<f[v])	swap(f[u],f[v]),swap(g[u],g[v]);
	g[u]+=f[v],f[u]-=f[v];
	// 先把两个直向上的合起来吧。
	int c=min(f[u]>>1,g[v])<<1;
	f[u]-=c,g[u]+=g[v]+(c>>1);
	/*
	 * 然后要处理子树内的横叉。这个有点 hard 啊！
	 * 我可以把横叉拆成俩，然后往上传和向上的合并起来。
	 * 因为路径不会横叉所以可以拆 =.=。
	 */
	fup[u]=min(fup[u],fup[v]);
	// 最后记录向上到哪里。
}
void dfs2(int u,int p)
{
	for(auto v:G[u])
	{
		if(v==p)	continue;
		dfs2(v,u);
		merge(u,v);
	}
	if(fup[u]>up[u])
	{
		if(fup[u]>=dep[u])
		{
			if(f[u])	--f[u]; // 拉长一条向上的路径。
			else if(g[u])	++f[u],--g[u]; // 拆掉一条横叉。
			// 否则的话我们直接打个标记就好了，上面那些东西只是暂时离开，它们要到更浅的地方去。
		}
		else	--spr[fup[u]]; // 把之前打在 fup 的标记去掉，也就是把当前的深度 fup 拉到 up。
		fup[u]=up[u],++spr[up[u]];
	}
}
```

~~这个题是不是比雨兔的题简单多了~~，反正我这么觉得。[完整代码](https://www.luogu.com.cn/paste/lqalg9jx)。

---

## 作者：Felix72 (赞：1)

初看是数据结构，思考良久没有思路，看完题解醍醐灌顶，这么神奇的贪心我必须写个题解。

首先不难发现，对于一个固定的 $p$ 和所有路径 $x \to p$，保留深度最小的 $x$ 即可；再发现，我们只在必须加新路径的时候加新路径，不然就用原有的路径是看起来很优秀的；再接着我们发现，能把两条从上到下的路径合并成一条路径就要赶快合并（因为后面还能拆开，而如果不合并可能导致最终路径条数变多）。

有了这三个基本思想，这题就能做了。但是具体的贪心策略仍然不清楚。我们来结合实现方法具体分析：

考虑节点 $p$，因为子树往上的路径有可能顺便满足从 $p$ 往上的节点，因此先把子树的信息合并了。

假设一个点内有 $f_i$ 条已经匹配的路径，$g_i$ 条由下往上且已经确定一定存在的路径。先把当前深度的标记 $tag_{dep_p}$ 结算一下（这个标记是什么下文会说）。如果子树内往上的路径要求到 $p$ 就结束了，那么 $g_{son}$ 会做相应的增加。否则看这个最小深度 $minn_{p}, minn_{son}$ 哪个小，用哪个小的作为新的 $minn_p$，而大的位置由于来自不同的子树，不可能被另一条路径顺便覆盖，我们需要在对应深度打上标记表示到了那里会有额外的 $g$ 产生（这标记就是上文说的标记）。然后就能合并 $f, g$ 数组了。分两种情况讨论（方便讨论，设 $g_{son} < g_p$）：

- 把 $f_{son}$ 全部拆成两个 $g$，再算上 $g_{son}$ 仍然没有 $g_{p}$ 多，此时尽力匹配，匹配不完的就剩下；
- 可以完全匹配，根据奇偶性可能剩下一条路径。

考虑完所有儿子，再考虑自己。如果自己有向上的路径，那么先看看能不能用儿子往上的路径顺便满足了。如果有 $g_p$ 自然最好，此时这条路径已经定下（暂时的）终点了，不参与接下来的合并，因此把 $g_p$ 减一；没有也没关系，可以把一个 $f_p$ 拆了。如果都没有，则无法做任何优化。

答案是 $f_1 + g_1$。

```cpp
/* Good Game, Well Play. */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 200010;
int T, n, m; vector < int > tr[N];

int dep[N];
inline void init(int now, int prt)
{
	dep[now] = dep[prt] + 1;
	for(int to : tr[now])
	{
		if(to == prt) continue;
		init(to, now);
	}
}

int f[N], g[N], minn[N], tag[N], p[N];
inline void treedp(int now, int prt)
{
	for(int to : tr[now])
	{
		if(to == prt) continue;
		treedp(to, now);
		g[to] += tag[dep[now]]; tag[dep[now]] = 0;
		
		if(minn[to] == dep[now]) ++g[to];
		else
		{
			if(minn[to] && minn[now])
			{
				++tag[max(minn[to], minn[now])];
				minn[now] = min(minn[now], minn[to]);
			}
			else minn[now] += minn[to];
		}
		
//		cerr << now << " -> " << to << " " << f[now] << " " << g[now] << " " << f[to] << " " << g[to] << '\n';
		
		if(g[to] > g[now]) swap(g[now], g[to]), swap(f[now], f[to]);
		if(g[to] + f[to] * 2 >= g[now])
		{
			f[now] += (g[to] + f[to] * 2 + g[now]) / 2;
			g[now] = (g[to] + f[to] * 2 + g[now]) % 2;
		}
		else
		{
			f[now] += g[to] + f[to] * 2;
			g[now] -= g[to] + f[to] * 2;
		}
	}
	if(p[now])
	{
		if(!minn[now])
		{
			minn[now] = p[now];
			if(g[now]) --g[now];
			else if(f[now]) ++g[now], --f[now];
		}
		else minn[now] = min(minn[now], p[now]);
	}
//	cerr << "result " << now << " : " << minn[now] << " " << f[now] << " " << g[now] << '\n';
}

inline void reset()
{
	for(int i = 1; i <= n; ++i)
	{
		f[i] = g[i] = minn[i] = tag[i] = p[i] = 0;
		tr[i].clear();
	}
}
inline void sol()
{
	reset(); cin >> n >> m;
	for(int i = 1, x, y; i < n; ++i)
	{
		cin >> x >> y;
		tr[x].push_back(y);
		tr[y].push_back(x);
	}
	init(1, 0);
	for(int i = 1, x, y; i <= m; ++i)
	{
		cin >> x >> y;
		if(!p[y] || p[y] > dep[x]) p[y] = dep[x];
	}
//	for(int i = 1; i <= n; ++i) cerr << p[i] << " "; cerr << '\n';
	treedp(1, 0);
	cout << f[1] + g[1] << '\n';
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> T;
	while(T--) sol();
	return 0;
}
/*
1
5 5
1 2
3 1
3 4
5 3
1 2
1 4
3 5
3 5
3 4
*/
```

---

## 作者：baka24 (赞：0)

感觉大部分人都是从下往上贪的，其实可以从上往下贪。

直接在所有 $(s_i,t_i)$ 形成的虚树上考虑，此时每个叶子都必须被包含进一条链中。

那么可以得到一个答案的上限，即叶子数量。

接下来考虑如何减少答案，发现可以每次拼起来两个叶子，作为一条链消掉。

从根开始，考虑把子树中的叶子匹配起来，容易发现只有当叶子最多儿子叶子个数超过一半时无法达到下界。

定义当前点为 $u$，叶子最多的儿子为重儿子，其他儿子为轻儿子。那么一个初步的想法是，此时记录一下轻儿子总共有多少个儿子，将问题递归到重儿子上处理。

但这样会有一个问题，对于 $s_i=u$ 的限制，无法在重儿子中考虑它们的匹配。

那考虑解决这个问题。

首先，对于所有 $t_i$ 不在重儿子里的限制，没有必要考虑。因为一定有一种匹配方式使得轻儿子中的叶子匹配后全部经过 $u$。

此时对于 $u$ 这个点，差不多是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/j6vgdfyi.png)

具体来说，有一些只有一半的路径指向 $u$，可能来自它的轻儿子，也可能来自它的父亲，但总之 $u$ 需要把它们传递下去（红箭头）。

对于 $s_i=u$ 的 $t_i$，必须有一个经过 $u$ 的一半路径到达 $t_i$（比较长的蓝箭头），考虑这个条件如何满足。

![](https://cdn.luogu.com.cn/upload/image_hosting/l0pi2ace.png)

如图，此时对于一个 $t_i$，如果 $u$ 的祖先已经向 $t_i$ 的祖先添加过一条路径了，那便可以延长这条路径至 $t_i$。

如果没有，那可以从 $u$ 里选一个轻儿子提供的路径。

另外，如果 $u$ 的轻儿子提供不出路径，那 $t_i$ 只能从 $u$ 上抠出一条全新的路径。

直接按照这个决策顺序贪心地为 $t_i$ 选匹配即可，因为 $u$ 一定是 $t_i$ 的祖先，而抠出全新路径会使答案加一，所以靠前的决策不劣于靠后的决策。

可以发现通过这种方式添加的路径，对于一个点最多有一条，所以可以视为打了一个 tag，用树状数组维护 tag 可以实现 $O(n\log n)$ 找到有 tag 的祖先。

另外的，如果已经有路径覆盖了 $t_i$，说明 $(s_i,t_i)$ 这对限制被某对限制完全包含了（因为已经添加的路径肯定是 $s_i$ 的祖先添加的），所以在最开始去掉所有被包含的路径即可。

去掉被包含的路径可以维护每个 $t_i=u$ 最浅的 $s_i$，按照深度从深到浅扫一遍来确定 $u$ 上的限制是否被包含。

之后，对于有些落到轻子树里的，祖先添加的路径，它们可以帮助减少一个轻儿子的叶子。所以在统计每个子树内部叶子数量时需要减掉子树内部 tag 的数量。这部分也可以用树状数组维护。

那此时这个题就做完了，稍微总结一下。先把所有被包含的路径去掉，之后从根节点开始向下递归处理。对于每个点 $u$，如果它重儿子的权值小于轻儿子权值和加通向 $u$ 的一半路径，就可以直接计算剩余答案（将其两两匹配），否则对于所有 $s_i=u$ 考虑如何打 tag，然后递归到 $u$ 的重儿子处理。用树状数组维护权值和 tag，总复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
#define fr first
#define sc second
#define mk make_pair
#define pb push_back
#define inx(u) int I=h[(u)],v=edge[I].v;I;I=edge[I].nx,v=edge[I].v
#define lb(x) (x&(-x))
int read(){int x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();return x*f;}
const int MAXN=500010;
struct Edge{int v,nx;}edge[MAXN<<1];int h[MAXN],CNT;void add_side(int u,int v){edge[++CNT]={v,h[u]};h[u]=CNT;edge[++CNT]={u,h[v]};h[v]=CNT;}
int n,m,ans;
int a[MAXN],dep[MAXN],dfn[MAXN],ed[MAXN],cnt,id[MAXN];
vector<int>G[MAXN];
void init(int u,int lst){dfn[u]=++cnt;for(inx(u))if(v!=lst)dep[v]=dep[u]+1,init(v,u);ed[u]=cnt;}
bool cmp(int x,int y){return dep[x]>dep[y];}
struct treearray{
    int C[MAXN];
    void upd(int x,int y){for(int i=x;i<=n;i+=lb(i))C[i]+=y;}
    int qry(int x){int rt=0;for(int i=x;i>=1;i-=lb(i))rt+=C[i];return rt;}
    void upd(int l,int r,int x){upd(l,x),upd(r+1,-x);}
    int qry(int l,int r){return qry(r)-qry(l-1);}
}T,A;
bool f[MAXN];
void init(){
    init(1,1);
    for(int i=1;i<=n;i++)id[i]=i,a[i]=i;
    sort(id+1,id+n+1,cmp);
    for(int i=1;i<=m;i++){
        int s=read(),t=read();
        if(dep[s]<dep[a[t]])a[t]=s;
    }
    for(int I=1;I<=n;I++){int u=id[I];
        int tmp=u;
        for(inx(u))if(dep[v]>dep[u]&&dep[a[v]]<=dep[tmp])tmp=a[v];
        if(dep[tmp]>dep[a[u]]){
            G[a[u]].pb(u);
            if(!T.qry(dfn[u],ed[u]))T.upd(dfn[u],1);
        }
        else a[u]=tmp;
    }
}
void sol(int u,int k){
    if(f[u])k++,A.upd(dfn[u],ed[u],-u);
    vector<pii>P;
    int sum=0;
    for(inx(u))if(dep[v]>dep[u])P.pb(mk(T.qry(dfn[v],ed[v]),v)),sum+=P.back().fr;
    if(P.empty())return;
    sort(P.begin(),P.end());
    int v=P.back().sc;
    sum-=P.back().fr;
    if(P.back().fr-k<=sum)ans+=(P.back().fr+sum-k+1)/2;
    else{
        k+=sum,ans+=sum;
        for(auto o:G[u])if(dfn[o]>=dfn[v]&&dfn[o]<=ed[v]){
            int tmp=A.qry(dfn[o]);
            if(tmp)A.upd(dfn[tmp],ed[tmp],-tmp),f[tmp]=0,T.upd(dfn[tmp],1),A.upd(dfn[o],ed[o],o),f[o]=1,T.upd(dfn[o],-1);
            else if(k)A.upd(dfn[o],ed[o],o),f[o]=1,T.upd(dfn[o],-1),k--;
            else A.upd(dfn[o],ed[o],o),f[o]=1,T.upd(dfn[o],-1),ans++;
        }
        sol(v,k);
    }
}
void slv(){
    for(int i=1;i<=n;i++)h[i]=dfn[i]=ed[i]=dep[i]=a[i]=f[i]=A.C[i]=T.C[i]=id[i]=0,G[i].clear();cnt=ans=0,CNT=1;
    n=read(),m=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        add_side(u,v);
    }
    init(),sol(1,0);
    printf("%d\n",ans);
}
signed main(){
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    int _=read();while(_--)
    slv();
    cerr<<(clock()*1.0)/CLOCKS_PER_SEC<<"s"<<endl;
    return 0;
}
```

---

## 作者：SegTree (赞：0)

比较有趣的贪心题，写篇题解记录一下。

我们将路径分成三类：

+ 直上直下的路径，且未达到目标深度。
+ 直上直下的路径，且已达到目标深度。
+ 两条直上直下的路径，已经匹配。

我们记 $cnt_i$ 为：目标深度为 $i$ 的路径条数。$f_u,g_u$ 分别表示未成对和成对的路径条数。$aim_u$ 表示 $u$ 向上的直上路径的最高目标深度。

我们将说明如何维护信息的合并：

+ 记录新增的已达目标路径条数。（一类变二类）
+ 不妨令 $f_x\le f_u$，则可以把三类路径拆掉使得来自 $x$ 子树共有 $f_x+2g_x$ 条二类路径，如果这个个数 $\ge f_u$ 那么我们可以将它们贪心的全部匹配成三类路径（不过可能会因为奇偶性导致多一条二类路径）。如果 $<f_u$，那么贪心的将这些二类、三类路径全部匹配掉来自 $u$ 的二类路径来达成三类路径，而剩余的路径的会达成二类路径。

最后我们考虑新增的祖先-后代链对答案的影响：

+ 如果有向上的路径，则维护 $aim$ 的变化。
+ 否则，新开一条路径。优先使用二类路径，如果没有就拆掉三类路径。

时间复杂度 $O(n+m)$。

---

## 作者：LiuIR (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8341)

妙妙贪心题，写篇题解记录一下。

一句话题意：一棵 $n$ 个点的有根树，给定 $m$ 对关键点对，要选择一些路径满足每对关键点对都被至少一条路径同时覆盖，求最少的路径条数。

记 路径 为直上直下的路径（即某个端点是另一个端点的祖先），两条路径 匹配 为将其组合成一条弯曲的路径。同时记 目标深度 为某条路径要覆盖分配给它的关键点对至少要到达的深度。

那目标即为尽可能匹配路径，并尽可能少新建路径。

考虑 $u$ 的子树内会有哪种路径：

1. 尚未达到目标深度的路径。

2. 已达到目标深度，但尚未与其他路径匹配的路径。

3. 已达到目标深度，且已经匹配的路径。

下文中用 $f_u$ 表示 $u$ 子树内 3 类路径的条数（为方便计算答案，这实际上是路径数除以 $2$ 后的结果），$g_u$ 表示 $u$ 子树内 2 类路径的条数。

容易得到，1 类路径只用保存一条，因为这样就可以满足 $u$ 到根上其他的限制。而这一条肯定是目标深度最小的那条，并记这条路径的目标深度为 $mn_u$。

而其他的 1 类路径在到达目标深度后会直接变成 2 类路径，这可以在树上打标记实现。

1 类路径的合并是平凡的，直接打标记即可。

再考虑 2,3 类路径。按照合并子树的过程，假设现在要合并 $p$ 和 $q$ 的子树。不妨设 $g_p<g_q$，然后进行分类讨论：

+ 若 $g_p+2f_p\ge g_q$，此时可以将这共计 $g_p+g_q+2f_p$ 条路径直接匹配。若总数为奇数就还会剩下一条路径。

+ 否则说明 $g_q$ 无法被匹配完，此时会产生 $g_p+2f_p$ 组匹配。

合并完子树后再考虑点 $u$ 带来的影响，即以点 $u$ 为深度较大点的关键点对。

记这些点对中深度较小点的最小深度为 $to_u$，那么需要一条延伸到 $to_u$ 的路径。再次分类讨论：

+ 若存在 1 类路径，直接让其的目标深度与 $to_u$ 取 $\min$ 即可。

+ 否则就需要拿出一个 2 类路径或拆开一个 3 类路径，并将其作为 1 类路径。如果都没有，就只能新开一条路径。

  因为要尽可能匹配路径，所以拿出 2 类路径一定优于拆开 3 类路径。

  有一点需要注意的是：此时得到一个 1 类路径并不能直接将其计入答案，因为我们的贪心是在路径结束时才会计入答案。具体可以详见代码。

主要代码如下：

``` c++
//cnt1[i] 表示上文中的 f[i]，cnt2[i] 表示上文中的 g[i]
signed main()
{
    SetIO();
    cin >> T;
    while(T--)
    {
        cin >> n >> m;
        fill(to, to + n + 1, 0);
        fill(mn, mn + n + 1, 0);
        fill(tag, tag + n + 1, 0);
        fill(cnt1, cnt1 + n + 1, 0);
        fill(cnt2, cnt2 + n + 1, 0);
        for (int i = 1; i <= n; i++)
            edge[i].clear();
        for (int i = 1, u, v; i < n; i++)
        {
            cin >> u >> v;
            edge[u].eb(v), edge[v].eb(u);
        }
        deep[1] = 1;
        Init(1, 0);
        for (int i = 1, x, y; i <= m; i++)
        {
            cin >> x >> y;
            if (deep[x] > deep[y])
                swap(x, y);
            if (!to[y] || to[y] > deep[x])
                to[y] = deep[x];
        }
        Dfs(1, 0);
        cout << cnt1[1] + cnt2[1] << '\n';
    }
    return 0;
}

void Dfs(int u, int fa)
{
    for (int v : edge[u])if (v ^ fa)
    {
        Dfs(v, u);
        cnt2[v] += tag[deep[u]];
        tag[deep[u]] = 0;//注意清除旧的标记
        if (mn[v] == deep[u])
            cnt2[v]++, mn[v] = 0;
        if (!mn[u] || !mn[v])//更新 1 类路径
            mn[u] |= mn[v];
        else
        {
            if (mn[u] < mn[v])
                tag[mn[v]]++;
            else
                tag[mn[u]]++, mn[u] = mn[v];
        }
        if (cnt2[v] > cnt2[u])
            swap(cnt1[u], cnt1[v]), swap(cnt2[u], cnt2[v]);
        if (cnt2[v] + 2 * cnt1[v] >= cnt2[u])//更新 2,3 类路径
        {
            int val = cnt2[u] + cnt2[v] + 2 * cnt1[v];
            cnt1[u] += val >> 1;
            cnt2[u] = val & 1;
        }
        else
        {
            cnt1[u] += cnt2[v] + 2 * cnt1[v];
            cnt2[u] -= cnt2[v] + 2 * cnt1[v];
        }
    }
    if (to[u])//处理点 u 的影响
    {
        if (mn[u])
            mn[u] = min(mn[u], to[u]);
        else
        {
            mn[u] = to[u];
            if (cnt2[u])
                cnt2[u]--;
            else if (cnt1[u])
                cnt2[u]++, cnt1[u]--;
        }
    }
}
```

---


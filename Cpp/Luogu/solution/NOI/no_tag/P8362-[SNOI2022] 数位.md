# [SNOI2022] 数位

## 题目描述

小 S 是一个喜欢数数的女孩子。

有一天，她在睡前躺在床上数数，当她数到 $977431$ 的时候，她终于困了，并且决定睡觉。但此时她突然发现这个数字的各位数码是单调不增的！她觉得这相当有趣，于是她又睡不着了。

她想知道有多少个数在 $L, R$ 之间，并且它的各位数码是单调不增的。但这个问题太无聊了。

她又想知道有多少数对 $(a, b)$ 在 $L, R$ 之间，并且 $(a + b)$ 的各位数码是单调不增的。但这个问题也太无聊了。

终于，她想到了一个有趣一些的问题：

给定整数 $L, R, k$，求有多少个 $k$ 维向量 $(a_1, a_2, ..., a_k)$ 满足 $(a_1 + a_2 + ... + a_k)$ 的数码是单调不增的，并且 $\forall i \in [1, k],  L \leq a_i \leq R$。

由于答案可能很大，请你输出它对 $998244353$ 取模的结果。

## 说明/提示

**【数据规模与约定】**

对于全部数据，$1 \leq L \leq R < 10^{1000}$，$1 \leq k \leq 50$。

具体的数据规模与约定见下表。

| 测试点编号 |    $R<$     | $k$  |
| :--------: | :---------: | :--: |
|    $1$     |   $10^6$    | $1$  |
|    $2$     |   $10^6$    | $10$ |
|    $3$     |   $10^6$    | $20$ |
|    $4$     |   $10^6$    | $30$ |
|    $5$     |   $10^6$    | $50$ |
|    $6$     |  $10^{17}$  | $10$ |
|    $7$     |  $10^{17}$  | $10$ |
|    $8$     |  $10^{17}$  | $20$ |
|    $9$     |  $10^{17}$  | $30$ |
|    $10$    |  $10^{17}$  | $50$ |
|    $11$    |  $10^{50}$  | $2$  |
|    $12$    |  $10^{50}$  | $10$ |
|    $13$    | $10^{100}$  | $2$  |
|    $14$    | $10^{100}$  | $3$  |
|    $15$    | $10^{100}$  | $10$ |
|    $16$    | $10^{200}$  | $3$  |
|    $17$    | $10^{200}$  | $10$ |
|    $18$    | $10^{300}$  | $10$ |
|    $19$    | $10^{300}$  | $10$ |
|    $20$    | $10^{300}$  | $20$ |
|    $21$    | $10^{500}$  | $10$ |
|    $22$    | $10^{500}$  | $20$ |
|    $23$    | $10^{1000}$ | $30$ |
|    $24$    | $10^{1000}$  | $50$ |
|    $25$    | $10^{1000}$  | $50$ |

## 样例 #1

### 输入

```
1
100
2```

### 输出

```
3728```

## 样例 #2

### 输入

```
19260817
1000000000
3```

### 输出

```
28745082```

## 样例 #3

### 输入

```
114514233
1919810233
10```

### 输出

```
135934411```

## 样例 #4

### 输入

```
样例 4 见附件 digit4.in```

### 输出

```
样例 4 见附件 digit4.ans```

## 样例 #5

### 输入

```
样例 5 见附件 digit5.in```

### 输出

```
样例 5 见附件 digit5.ans```

# 题解

## 作者：Renshey (赞：6)

#### 题解

考虑如何统计答案，从 $a_1 \sim a_k$ 出发显然是难以同时处理的，因此只能从 $S=\sum_{i=1}^k$ 开始处理。在 $S$ 确定后，方案数不难通过容斥 + 隔板法求出，即为 $\sum_{i=0}^k (-1)^i \binom{k}{i}\binom{S-k(L-1)-i(R-L+1)-1}{k-1}$。

考虑如何计算组合数，不难发现组合数是关于 $S$ 的 $k-1$ 次多项式，因此可以直接用数位 dp 计算 $S$ 的若干次方和：设 $f_{i,j,0/1,r}$ 表示前 $i$ 位，最后一位为 $j$，$S$ 是否达到上界的 $S^r$ 之和，转移不难用二项式定理推出。统计答案可以用斯特林数计算出下降幂的展开系数。

时间复杂度 $O(k^3B^2 \log_B R)$，空间复杂度 $O(kB\log_B R)$，其中 $B=10$。

如果采用前缀和优化或改为记录 $S$ 的下降幂之和可以做的更优。

#### 代码

```cpp
#include <bits/stdc++.h>
const int mod = 998244353;
struct Int
{
	int a[1010];
	inline int & operator [] (int x) {return a[x];}
	inline bool friend operator < (Int a, Int b) {for (int i = 1002; ~i; i--) if (a[i] != b[i]) return a[i] < b[i]; return false;}
	inline Int friend operator + (Int a, int b) {a[0] += b; for (int i = 0; i <= 1002; i++) a[i + 1] += a[i] > 9, a[i] -= 10 * (a[i] > 9); return a;}
	inline Int friend operator + (Int a, Int b) {for (int i = 0; i <= 1002; i++) a[i] += b[i], a[i + 1] += a[i] > 9, a[i] -= 10 * (a[i] > 9); return a;}
	inline Int friend operator - (Int a, Int b) {for (int i = 0; i <= 1002; i++) a[i] -= b[i], a[i + 1] -= a[i] < 0, a[i] += 10 * (a[i] < 0); return a;}
	inline Int friend operator * (Int a, int b) {a[0] *= b; for (int i = 1; i <= 1002; i++) a[i] = a[i] * b + a[i - 1] / 10, a[i - 1] %= 10; return a;}
	inline int friend operator % (Int a, int p) {int res = 0; for (int i = 1002; ~i; i--) res = (10LL * res + a[i]) % p; return res;}
	inline void read (void) {std::string s; std::cin >> s; for (int i = 0; i < (int)s.length(); i++) a[s.length() - i - 1] = s[i] ^ 48;}
} L, R, Q[2];
int k, wl, wr, sgn[2], inv[60], P[12][60], C[60][60], S[60][60], tr[60][60][10], Pow[60], f[1010][10][2][60], g[60], h[60], ans;
inline void dp (int *g, Int Q)
{
	for (int j = 1002, p = 1; j >= 1; j--) f[j][9][p &= (Q[j] == 0)][0] = 1;
	for (int j = 1001; j >= 0; j--) for (int x = 0; x <= 9; x++)
		for (int p = 0; p < 2; p++) for (int t = 0; t < k; t++) if (f[j + 1][x][p][t])
			for (int y = 0; y <= x and y <= (p ? Q[j] : 9); y++)
				for (int r = t, q = p & (y == Q[j]); r < k; r++) f[j][y][q][r] = (f[j][y][q][r] + 1LL * tr[r][t][y] * f[j + 1][x][p][t]) % mod;
	for (int x = 0; x <= 9; x++) for (int p = 0; p < 2; p++) for (int r = 0; r < k; r++) g[r] = (g[r] + f[0][x][p][r]) % mod;
	for (int j = 1002; ~j; j--) for (int x = 0; x <= 9; x++) for (int p = 0; p < 2; p++) for (int r = 0; r < k; r++) f[j][x][p][r] = 0;
}
signed main ()
{
	L.read(); R.read(); std::cin >> k; wl = L % mod; wr = R % mod;
	inv[0] = inv[1] = sgn[0] = 1; sgn[1] = mod - 1;
	for (int i = 2; i <= k; i++) inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;
	for (int i = 3; i <= k; i++) inv[i] = 1LL * inv[i - 1] * inv[i] % mod;
	for (int i = 0; i <= 10; i++) for (int j = P[i][0] = 1; j <= k; j++) P[i][j] = 1LL * P[i][j - 1] * i % mod;
	for (int i = 0; i <= k; i++) for (int j = C[i][0] = 1; j <= i; j++) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
	for (int i = S[0][0] = 1; i <= k; i++) for (int j = 1; j <= i; j++) S[i][j] = (S[i - 1][j - 1] + 1LL * (i - 1) * S[i - 1][j]) % mod;
	for (int i = 0; i < k; i++) for (int j = 0; j <= i; j++) for (int k = 0; k <= 9; k++) tr[i][j][k] = 1LL * C[i][j] * P[10][j] % mod * P[k][i - j] % mod;
	Q[0] = L * k + (-1); Q[1] = R * k; R = R - L + 1; dp(h, Q[1]);
	for (int i = 0; i <= k and Q[0] < Q[1]; i++, Q[0] = Q[0] + R)
	{
		dp(g, Q[0]); for (int j = 0; j < k; j++) g[j] = (h[j] - g[j] + mod) % mod;
		int w = 1LL * sgn[i & 1] * C[k][i] % mod * inv[k - 1] % mod;
		Pow[0] = 1; Pow[1] = (mod - (1LL * k * (wl - 1) + 1LL * i * (wr - wl + 1) + 1) % mod) % mod;
		for (int j = 2; j < k; j++) Pow[j] = 1LL * Pow[j - 1] * Pow[1] % mod;
		for (int j = k - 1; j >= 0; j--) for (int r = 0; r < j; r++) g[j] = (g[j] + 1LL * C[j][r] * g[r] % mod * Pow[j - r]) % mod;
		for (int j = 0; j < k; j++) ans = (ans + 1LL * w * sgn[(k - 1 - j) & 1] % mod * S[k - 1][j] % mod * g[j]) % mod, g[j] = 0;
	}
	return !printf("%d\n", ans);
}
```

---

## 作者：Cherished (赞：3)

看到还没有题解，赶紧偷跑一篇。

yysy，看到出题人在知乎吐槽考场上没有什么人尝试这道题，就来看了一眼。但是我做完之后，也确实感觉，如果我在考场上也不会去尝试写这道题，因为真的太难写了!!!!!!

但是总体来说作为一道省选的压轴题，代码难一点也无可厚非。

思路上来说，感觉没人特别难想的地方，作为省队水平选手大概 $10$ 到 $20$ 分钟应该就能想到大致思路。

### 解题思路

首先我们先看看如果确定了 $\sum{a_i}=S$ 是什么，怎么计算答案。

众所周知，如果把限制改成 $a_i \in [L,+\infty)$ 的做法是直接使用隔板法，答案为 ${S-k(L-1)-1}\choose{k-1}$。

但是现在限制是 $a_i \in [L,R]$，直接做显然是不好做的。那我们考虑容斥。枚举有多少 $a_i$ 突破了 $R$ 的限制，此时答案为：

$$
\sum_{i=0}^{k}{(-1)^i{{k}\choose{i}}{{S-k(l-1)-i(R-L+1)-1}\choose{k-1}}}
$$

既然有了这种做法，我们的思路就可以转变为枚举 $i$，用数位 `dp` 计算 ${{S-k(l-1)-i(R-L+1)-1}\choose{k-1}}$ 的和。

这个东西显然也是不好算的，但是如果我们将 $S-k(l-1)-i(R-L+1)-1$ 设为 $x$。我们知道的是 $x \choose k-1$ 可以写成 $\sum_{i=0}^{k-1}{a_ix^i}$ 的形式，那么我们只需要计算出所有 $x$ 的所有 $k$ 次幂和即可求得答案。考虑到 $k$ 次幂和之间的递推可以直接使用二项式定理，所以我们的数位 `dp` 可以直接记录，考虑到第几位，是否需要借位，上一个填的数是什么，当前维护的是几次幂和。这样的时间复杂度大概是 $O(10k^3|R|)$，感觉很卡，但是实测是可过的。（其实是我本地没跑过感觉非常慌，但是交上去就过了）

下面是代码。QwQ

```cpp
#include <stdio.h>
#include <bits/stdc++.h>

using namespace std;

const int N = 1110, M = 1010;
const int P = 998244353;
char s[N];

inline int add(int x, int y) {return x + y >= P ? x + y - P : x + y;}
inline int sub(int x, int y) {return x < y ? x - y + P : x - y;}
inline int mul(int x, int y) {return 1ll * x * y % P;}
inline void upd(int &x, int y) {x = add(x, y);}
inline int Pow(int x, int y) {int r = 1; for (; y; y >>= 1, x = mul(x, x)) if (y & 1) r = mul(r, x); return r;}

struct BigInt {
	int a[N], len;
	BigInt() {
		len = 0;
		memset(a, 0, sizeof a);
	}
	void input() {
		scanf("%s", &s);
		len = strlen(s);
		for (int i = 0; i < len; i++)
			a[i] = s[len - i - 1] - '0';
	}
};

BigInt operator + (BigInt x, BigInt y) {
	BigInt ret; ret.len = max(x.len, y.len);
	for (int i = 0; i < ret.len; i++)
		ret.a[i] = x.a[i] + y.a[i];
	for (int i = 0; i < ret.len; i++)
		if (ret.a[i] > 9) ret.a[i] -= 10, ret.a[i + 1]++;
	while (ret.a[ret.len]) ret.len++;
	return ret;
}

BigInt operator - (BigInt x, BigInt y) {
	BigInt ret; ret.len = x.len;
	for (int i = 0; i < ret.len; i++)
		ret.a[i] = x.a[i] - y.a[i];
	for (int i = 0; i < ret.len; i++)
		if (ret.a[i] < 0) ret.a[i] += 10, ret.a[i + 1]--;
	while (ret.len && !ret.a[ret.len - 1]) ret.len--;
	return ret;
}

BigInt L, R, AL;
int K, C[52][52], ans, dp[N][10][2][52], sdp[N][10][2][52], pw[10][52], pw10[N * 52], coe[52];

int main() {
	L.input(), R.input(), scanf("%d", &K);
	L.a[0]--;
	for (int i = 0; ; i++) {
		if (L.a[i] < 0) L.a[i] += 10, L.a[i + 1]--;
		else break;
	}
	while (L.len && !L.a[L.len - 1]) L.len--;
	R = R - L; AL.len = 1, AL.a[0] = 1;
	for (int i = 1; i <= K; i++) AL = AL + L;
	for (int i = 0; i <= K; i++) {
		C[i][0] = C[i][i] = 1;
		for (int j = 1; j < i; j++)
			C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);
	}
	for (int i = 0; i < 10; i++) {
		pw[i][0] = 1;
		for (int j = 1; j <= K; j++)
			pw[i][j] = mul(pw[i][j - 1], i);
	}
	pw10[0] = 1;
	for (int i = 1; i < N * 52; i++)
		pw10[i] = mul(pw10[i - 1], 10);
	coe[1] = 1;
	for (int i = 1; i < K - 1; i++) {
		for (int j = K; j > 0; j--)
			coe[j] = coe[j - 1];
		coe[0] = 0;
		for (int j = 0; j < K; j++)
			coe[j] = sub(coe[j], mul(i, coe[j + 1]));
	}
	if (K == 1) coe[1] = 0, coe[0] = 1;
	for (int T = 0; T <= K; T++) {
		for (int i = 0; i < K; i++)
			for (int j = 0; j < 10; j++)
				for (int o = 0; o < 2; o++)
					dp[0][j][o][i] = 0;
		for (int i = 0; i < K; i++)
			for (int j = 0; j < 10; j++) {
				if (AL.a[0] > j) dp[0][j][1][i] = pw[j - AL.a[0] + 10][i];
				else dp[0][j][0][i] = pw[j - AL.a[0]][i];
			}
		int temp = 0;
		for (int i = 0; i < M; i++) {
			if (i + 1 >= AL.len)
				for (int k = 1; k < 10; k++)
					for (int o = 0; o < K; o++)
						upd(temp, mul(coe[o], dp[i][k][0][o]));
			for (int j = 0; j < 2; j++)
				for (int k = 0; k < 10; k++)
					for (int o = 0; o < K; o++) {
						sdp[i][k][j][o] = dp[i][k][j][o];
						if (k > 0) sdp[i][k][j][o] = add(sdp[i][k][j][o], sdp[i][k - 1][j][o]);
					}
			for (int j = 0; j < 2; j++)
				for (int k = 0; k < 10; k++)
					for (int o = 0; o < K; o++)
						dp[i + 1][k][j][o] = 0;
			int num = AL.a[i + 1];
			for (int j = 0; j < 2; j++)
				for (int o = 0; o < K; o++)
					for (int p = 0; p < 10; p++) {
						if (!sdp[i][p][j][o]) continue;
						int tr = sdp[i][p][j][o];
						for (int m = o; m < K; m++) {
							if (p - j < num) {
								int tmp = p - j - num + 10;
								upd(dp[i + 1][p][1][m], mul(tr, mul(C[m][o], mul(pw[tmp][m - o], pw10[(i + 1) * (m - o)]))));
							}
							else {
								int tmp = p - j - num;
								upd(dp[i + 1][p][0][m], mul(tr, mul(C[m][o], mul(pw[tmp][m - o], pw10[(i + 1) * (m - o)]))));
							}
						}
				}
		}
		for (int k = 1; k < 10; k++)
			for (int o = 0; o < K; o++)
				upd(temp, mul(coe[o], dp[M][k][0][o]));
		for (int i = 2; i < K; i++)
			temp = mul(temp, Pow(i, P - 2));
		temp = mul(temp, C[K][T]);
		if (T & 1) ans = sub(ans, temp);
		else ans = add(ans, temp);
		AL = AL + R;
	}
	printf("%d\n", ans);
	return 0;
}

```

---

## 作者：feecle6418 (赞：2)

设 $m=10$ 是进制数（字符集大小）。

首先，$x\in [L,R]$ 的限制可以直接去掉下界：先算出 $kL$ 的值，然后认为 $x\in [0,R-L]$。在之后的数位 dp 过程中，dp 到第 $i$ 位时加上 $kL$ 的第 $i$ 位的贡献即可。

事实上，上界 $R-L$ 的限制也能如法炮制：容斥，钦定 $i$ 个超过上界，用类似的方法减去 $i(R-L+1)$ 即可。现在我们需要对于每个 $i$，都算出钦定完成后，既无上界也无下界的方案数。

不难设计出 dp：$f(x,val,digit)$ 表示已经完成 $[0,x)$ 位，$x-1$ 位向 $x$ 位进位 $val$，$x-1$ 位是 $digit$ 的方案数。$x\in [0,n]$，$val\in [0,k]$，$digit\in [0,9]$。转移时枚举第 $x$ 位的数的总和 $s$，用之前预处理的值可以直接得到方案数 $g(s)$，则这一位的新值是 $val+s+bound_x$（$bound$ 是由之前的下界带来的额外贡献）。直接 dp 复杂度是 $O(k\times nkm\times km)=O(nk^3m^2)$ 的（三部分分别是 dp 次数，状态数，转移复杂度）。看上去很大，但常数很小，可以得到 92 分。[提交记录](https://loj.ac/s/1473729)

考虑优化上面的算法。不难发现 $f(\dots,val)\times g(s)\to f'(\dots,val+s)$ 的过程是卷积，使用 NTT 即可做到 $O(nk^2m^2(\log k+\log m))$，但仍然只有 92 分。

注：如果您理解下面的优化有困难，可以对照 LOJ 上用户 2222 的提交来理解是如何优化的：我把优化的中间过程写成代码都交了一遍。

注意到每轮转移我们要做 $m$ 次 $n\times (nm)$ 的卷积，每次卷上的长为 $nm$ 的序列 $b$ 都是一样的。但这些卷积的结果保留与否，只与 $a_{t,i}b_j\to c_{i+j}$ 时 $(i+j)\bmod m$ 与 $t$ 的大小关系有关。

考虑按照 $i,j$ 模 $m$ 的余数分类，对于每一类 $j\bmod m$ 先用 $O(m^2n)$ 的时间枚举所有 $(t,i)$ 预处理出与这一类 $j$ 做卷积的结果会被保留的 $a_{t,i}$，再用 $O((mn/m)\times n)$ 的时间一次卷积完。这样均摊下来相当于只做了一次卷积。

复杂度优化至 $O(nk^3m+nk^2m^2)$，常数仍然很小，已经可以通过。在卷积处使用 unsigned long long 避免多次取模，可以在 1s 以内出解。[提交记录](https://loj.ac/s/1473883)

代码不超过 2kb。

---

## 作者：Petit_Souris (赞：1)

感觉主要难度在于 implementation 和卡常。作为一个合格的省队选手，你应当在 15min 内想出做法。

考虑对于每个 $S$ 计算拆分成 $a_1,a_2,\dots,a_k$ 的方案数，显然可以全部减掉 $L$，再容斥枚举 $>R-L$ 的数量，得到方案数 $\sum\limits_{i=0}^{k}\binom{k}{i}(-1)^{i}\binom{S-kL-i(R-L+1)+k-1}{k-1}$。下面枚举 $i$，对每个 $i$ 计算合法的 $S$ 的 $\binom{S-kL-i(R-L+1)+k-1}{k-1}$ 之和。

当 $S-kL-i(R-L+1)\ge 0$，这个组合数是关于 $S$ 的 $k-1$ 次多项式。设其为 $F(x)=f_0+f_1x+f_2x^2+\dots +f^{k-1}x^{k-1}$，容易 $\mathcal O(k^2)$ 求得系数。那么我们实际上只需要对于每个 $p$，求所有 $S^p$ 之和。

这样就可以数位 dp 了：记 $dp_{i,j,p}$ 表示前 $i$ 位，目前限制填入的数必须 $\le j$，$S^p$ 之和。注意这里还限制了 $S$ 的上下界，所以还要再记两维表示是否顶到上 / 下界。转移的时候会从一个 $p$ 转移到一个 $q(q\ge p)$，并在 $S$ 末尾加入一位数 $c$，也即 $S^p\to (10S+c)^q$，用二项式定理拆开容易计算。

复杂度 $\mathcal O(nk^3B^2)$，其中 $B=10$，看似无法通过，实际上减少一些取模后可以轻松在 4s 内通过。

```cpp
#include<bits/stdc++.h>
typedef unsigned long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const int N=1e3+20,D=59,Mod=998244353;
int K,len1,len2,cur;
ll dp[2][11][2][2][D];
int f[D],tmp[D],fac[D],ifac[D],C[D][D];
char sL[N],sR[N];
int L[N],R[N],lim[N],lim2[N],lim3[N];
int pre[11][D],res[D],pwt[D],coef1[10][D][D];
int pw(int x,int p){
    int res=1;
    while(p){
        if(p&1)res=1ll*res*x%Mod;
        x=1ll*x*x%Mod,p>>=1;
    }
    return res;
}
void Upd(int&x,int y){
    ((x+=y)>=Mod)?(x-=Mod):0;
}
bool Med;
int main(){
    // freopen("digit.in","r",stdin);
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    scanf("%s%s",sL,sR),len1=strlen(sL),len2=strlen(sR),K=read();
    fac[0]=1;
    rep(i,1,K)fac[i]=1ll*fac[i-1]*i%Mod;
    ifac[K]=pw(fac[K],Mod-2);
    per(i,K-1,0)ifac[i]=1ll*ifac[i+1]*(i+1)%Mod;
    rep(i,0,10){
        pre[i][0]=1;
        rep(j,1,K)pre[i][j]=1ll*pre[i][j-1]*i%Mod;
    }
    rep(i,0,K){
        C[i][0]=1;
        rep(j,1,i)C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mod;
    }
    rep(i,0,len1-1)L[i]=sL[i]-'0';
    rep(i,0,len2-1)R[i]=sR[i]-'0';
    reverse(L,L+len1),reverse(R,R+len2);
    f[0]=1;
    rep(i,0,K-2){
        memset(tmp,0,sizeof(tmp));
        rep(j,0,i){
            tmp[j+1]=(tmp[j+1]+f[j])%Mod;
            tmp[j]=(tmp[j]+1ll*f[j]*(K-i-1)%Mod+Mod)%Mod;
        }
        memcpy(f,tmp,sizeof(f));
    }
    rep(i,0,K-1)f[i]=1ll*f[i]*ifac[K-1]%Mod;
    rep(c,0,9){
        rep(p,0,K-1){
            rep(q,p,K-1)coef1[c][p][q]=1ll*pre[10][p]*pre[c][q-p]%Mod*C[q][p]%Mod;
        }
    }
    ll ans=0;
    rep(i,0,K){
        int coef=1ll*C[K][i]*((i&1)?Mod-1:1)%Mod;
        memset(dp,0,sizeof(dp));
        memcpy(lim,L,sizeof(lim));
        memcpy(lim2,R,sizeof(lim2));
        memcpy(lim3,R,sizeof(lim3));
        lim2[0]++;
        cur=0;
        int mxlen=0;
        rep(j,0,len2-1)lim[j]*=(K-i),lim2[j]*=i,lim3[j]*=K;
        int t=0;
        rep(j,0,1010){
            lim[j]+=lim2[j];
            if(lim[j]>=10)lim[j+1]+=lim[j]/10,lim[j]%=10;
            if(lim3[j]>=10)lim3[j+1]+=lim3[j]/10,lim3[j]%=10;
            if(lim[j]||lim3[j])mxlen=j+1;
        }
        per(j,mxlen-1,0)t=(t*10ll+lim[j])%Mod;
        pwt[0]=1;
        rep(j,1,K)pwt[j]=1ll*pwt[j-1]*(Mod-t)%Mod;
        dp[cur][10][0][0][0]=1;
        per(j,mxlen-1,0){
            memset(dp[cur^1],0,sizeof(dp[cur^1]));
            rep(d,0,10){
                rep(fre1,0,1){
                    rep(fre2,0,1){
                        rep(p,0,K-1){
                            int val=dp[cur][d][fre1][fre2][p]%Mod;
                            if(!val)continue;
                            rep(c,0,min(9,d)){
                                if(!fre1&&c<lim[j])continue;
                                if(!fre2&&c>lim3[j])continue;
                                int nd=c;
                                if(d==10&&c==0)nd=10;
                                int nfre1=fre1||(c>lim[j]);
                                int nfre2=fre2||(c<lim3[j]);
                                rep(q,p,K-1){
                                    dp[cur^1][nd][nfre1][nfre2][q]+=1ll*val*coef1[c][p][q];
                                    if(!(p&15))dp[cur^1][nd][nfre1][nfre2][q]%=Mod;
                                }
                            }
                        }
                    }
                }
            }
            cur^=1;
        }
        memset(res,0,sizeof(res));
        rep(d,0,10){
            rep(fre1,0,1){
                rep(fre2,0,1){
                    rep(p,0,K-1){
                        rep(q,p,K-1)Upd(res[q],1ll*dp[cur][d][fre1][fre2][p]%Mod*pwt[q-p]%Mod*C[q][p]%Mod);
                    }
                }
            }
        }
        rep(q,0,K-1)ans=(ans+1ll*coef*res[q]%Mod*f[q])%Mod;
    }
    write(ans),putchar('\n');
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：1)

## 数位

枚举 $S=a_1+a_2+\dots+a_k$。通过容斥发现合法方案数应当是：
$$
\sum_{i=0}^k (-1)^i\cdot\dbinom ki\cdot \dbinom{S-k(L-1)-i(R-L+1)-1}{k-1}
$$
需要注意的是最后一个组合数可能上面小于下面导致这玩意是 $0$，也就是这玩意不完全是关于 $S$ 的 $k$ 次多项式。

我们可以通过枚举 $k$，钦定 $S\in[i(R+1)+(k-i)L,kR]$。这样子这个组合数显然的关于 $S$ 的 $k-1$ 次多项式。解决这个问题是容易的。

具体的，假设 $n=\lg kR$，通过差分我们只需要计算一边。定义 $f_{i,j,o,k}$ 表示当前只考虑 $S[i,n]$ 且 $S_i=j$，$S[i,n]$ 是否等于 $kR[i,n]$，满足这样条件 $S[i,n]$ 的 $k$ 次方和。

转移可以通过二项式定理拆开。具体的转移见代码。

算一下复杂度，假设 $B=10$，复杂度是 $\mathcal O(nk^3B^2)$。剪一下枝，写完发现有 $92$ 分的样子。

考虑怎么过掉最后两个点，你发现 $o=1$ 有用情况很少，不用管。只需要 $o=0$ 之间的贡献即可。

不难发现 $o=0$ 收到上一层 $o=0$ 的是贡献是一个 $j$ 的后缀，通过后缀和可以丢掉一个 $B$。

时间复杂度是 $\mathcal O(nk^3B)$。

为了卡常需要把主要 dp 数组全部换成 `int` 以加快速度，在计数题效果很明显。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int MAXN=1005;
const int MR=55;
const int MOD=998244353;
ll pw[11][MAXN*MR],fac[MR],inf[MR],c[MR][MR];
struct Big_Int{
int a[MAXN+5];
int& operator [](int x){return a[x];}
Big_Int(int x=0){
	memset(a,0,sizeof(a));
	for(int i=0;i<=10;i++) a[i]=x%10,x/=10;
}
}L,R;int k;
Big_Int read(){
	Big_Int re;int n=0;char ch=getchar();
	while(ch>'9'||ch<'0') ch=getchar();
	while(ch>='0'&&ch<='9') re[n++]=ch-'0',ch=getchar();
	reverse(re.a,re.a+n);
	return re;
}
Big_Int operator +(Big_Int x,Big_Int y){
	for(int i=0;i<MAXN;i++){
		x[i]+=y[i];
		if(x[i]>=10) x[i]-=10,x[i+1]++;
	}
	return x;
}
Big_Int operator -(Big_Int x,Big_Int y){
	for(int i=0;i<MAXN;i++){
		x[i]-=y[i];
		if(x[i]<0) x[i]+=10,x[i+1]--;
	}
	return x;
}
bool operator >=(Big_Int x,Big_Int y){
	for(int i=MAXN;i>=0;i--) if(x[i]!=y[i]) return x[i]>y[i];
	return true;
}
Big_Int operator *(Big_Int x,int y){
	for(int i=0;i<MAXN;i++) x[i]*=y;
	for(int i=0;i<MAXN;i++) x[i+1]+=x[i]/10,x[i]%=10;
	return x;
}
int operator %(Big_Int x,int y){
	int ans=0;
	for(int i=MAXN-1;i>=0;i--) ans=(10ll*ans+x[i])%y;
	return ans;
}
ll ksm(ll a,int b){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}
void add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}
int f[MR],g[MR];// all possible S, calculate the sum of S^k
ll C(int x,int y){return fac[y]*inf[x]%MOD*inf[y-x]%MOD;}
void solve(Big_Int R,int *ans){
	static int f[MAXN][10][MR][2],g[MAXN][10][MR];
	ans[0]=1;
	memset(f,0,sizeof(f));memset(g,0,sizeof(g));
	int n=MAXN;
	while(n&&!R[n]) n--;
	for(int i=n+1;i>=0;i--){
		f[i][9][0][i==n+1]++;ans[0]--;
		for(int j=0;j<=9;j++) for(int t=0;t<k;t++) if(i&&f[i][j][t][1]){
			int lim=min(j,R[i-1]);
			for(int c=0;c<=lim;c++) for(int p=0;p+t<k;p++)
				add(f[i-1][c][p+t][c==R[i-1]],
				f[i][j][t][1]*pw[10][(i-1)*p]%MOD*pw[c][p]%MOD*C(p,p+t)%MOD);
		}
		for(int c=0;c<=9;c++) for(int t=0;t<k;t++){
			for(int p=0;p<=t;p++) add(f[i][c][t][0],
				C(p,t)*g[i+1][c][t-p]%MOD*pw[10][i*p]%MOD*pw[c][p]%MOD);
		}
		for(int t=0;t<k;t++){
			g[i][9][t]=f[i][9][t][0];
			for(int c=8;c>=0;c--) g[i][c][t]=(g[i][c+1][t]+f[i][c][t][0])%MOD;
		}
	}
	for(int i=0;i<=9;i++) for(int o:{0,1}) for(int t=0;t<k;t++)
		add(ans[t],f[0][i][t][o]);
}
int main(){
	// freopen("digit.in","r",stdin);
	// freopen("digit.out","w",stdout);
	L=read();R=read();k=read()%MOD;
	for(int i=0;i<=10;i++){
		pw[i][0]=1;
		for(int j=1;j<MAXN*MR;j++) pw[i][j]=pw[i][j-1]*i%MOD;
	}
	fac[0]=inf[0]=1;
	for(int i=1;i<MR;i++) inf[i]=ksm(fac[i]=fac[i-1]*i%MOD,MOD-2);
	int ans=0;
	solve(R*k,f);
	for(int i=0;i<=k;i++)if(R*k>=(R+1)*i+L*(k-i)){
		memset(g,0,sizeof(g));
		solve(L*(k-i)+(R+Big_Int(1))*i-Big_Int(1),g);
		ll x=((L-Big_Int(1))*k+(R-L+Big_Int(1))*i+Big_Int(1))%MOD;
		c[0][0]=1;
		for(int i=1;i<=k-1;i++){
			for(int j=0;j<=i;j++) c[i][j]=((j?c[i-1][j-1]:0)+(MOD-x-(i-1))*c[i-1][j])%MOD;
		}
		int sum=0;
		for(int i=0;i<=k-1;i++) add(sum,inf[k-1]*c[k-1][i]%MOD*(f[i]-g[i]+MOD)%MOD);
		add(ans,fac[k]*inf[i]%MOD*inf[k-i]%MOD*(i&1?MOD-1:1)%MOD*sum%MOD);	
	}
	cout<<ans<<'\n';
	return 0;
}
```

---


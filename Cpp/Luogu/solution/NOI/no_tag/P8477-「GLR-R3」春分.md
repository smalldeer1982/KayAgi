# 「GLR-R3」春分

## 题目背景

&emsp;&emsp;「解冻群芳盛，馀寒百卉稀」

---

&emsp;&emsp;吉他　贝斯　键盘　架子鼓

&emsp;&emsp;她们的声嗓　七八点的太阳光

&emsp;&emsp;炖作一隅　所谓青春的模样

&emsp;&emsp;可惜他们　还得把那胜负扛在

&emsp;&emsp;佯作成熟的肩上

---

&emsp;&emsp;**春分**&emsp;「你我间有无形磁场　追赶着终有天碰撞　迸发火光吧」


## 题目描述

休息室外的走廊上有一块电视屏幕，除了高考倒计时外，还偶尔整些无聊的活。练习的间隙，枕在某位阿绫腿上的天依竖起耳朵听着，但闻——

今有一外国小哥，整了个笨重、花哨、无用的原电池装置，天依的脑补图如下：

![figure1.png](https://cdn.luogu.com.cn/upload/image_hosting/ibdp8eyw.png)

我们只关心中间的红色部分，它们是若干分隔板，用于分隔左右两侧的溶液。这些分隔板**可拆下，可任意顺序同时组装入任意块，可翻转左右方向**。

现在小哥有两组溶液，第一组为 $X=\{x_1,x_2,\cdots,x_n\}$，第二组为 $Y=\{y_1,y_2,\cdots,y_n\}$，这 $2n$ 种溶液**两两不同**。小哥想将每种 $X$ 组内溶液置于容器左侧，每种 $Y$ 组内溶液置于容器右侧，一共进行 $n^2$ 次原电池实验。每次实验结束后，严谨的小哥会清洗装置，但是他不想清洗分隔板。

实验过程中，若分隔板的某侧**直接接触**了实验溶液，则此种溶液会沾在分隔板对应侧。为了防止溶液的污染，任意分隔板沾上任何一种溶液的**一侧**都不能和**非同种**的实验用溶液接触。例如下图（红色竖线表示分隔板，蓝色标号表示两侧已沾上的溶液，黑色标号表示实验中的溶液，下同）：

![explanation1.png](https://cdn.luogu.com.cn/upload/image_hosting/ezwggdwh.png)

此外，若一次使用了多个分隔板，由于分隔板贴合紧密，所以若某块分隔板的一侧与另一分隔板沾有某种溶液的一侧相接触，这种溶液就会残留在两块分隔板各自的接触侧。例如下图（绿色标号表示本次实验后两块分隔板**新**沾上的溶液）：

![explanation2.png](https://cdn.luogu.com.cn/upload/image_hosting/gjbad0ox.png)

小哥称他希望用较少（**不必最少**）数量的分隔板完成所有实验，并邀请观众给出使用分隔板的数量 $m$ 和此时**依次进行**的 $n^2$ 次实验中，所用的左右两侧溶液种类以及使用分隔板的方案。

天依预料到评论区的答案一定质量堪忧，所以邀请你来构造一个优秀的方案。


## 说明/提示

#### 样例 #1 解释

![figure2.png](https://cdn.luogu.com.cn/upload/image_hosting/je86hjkk.png)

可以证明，这是 $n=2$ 时 $m$ 最小的一种方案。

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

对于 $100\%$ 的数据，$1\le n\le609$。

对于不同的子任务，作如下约定：

| 子任务编号 |   $n$    | 子任务分值 |
| :--------: | :------: | :--------: |
|    $1$     | $\le26$  |    $10$    |
|    $2$     | $\le356$ |    $10$    |
|    $3$     | $\le475$ |    $20$    |
|    $4$     | $\le534$ |    $20$    |
|    $5$     | $\le567$ |    $20$    |
|    $6$     | $\le592$ |    $10$    |
|    $7$     | $\le609$ |    $10$    |

- **提示 1**：再次强调，你构造的方案**应当保证 $1\le m\le712$**。

- **提示 2**：对于任意子任务，保证**针对该子任务的标算**的输出量不超过 $5\times10^6$ 个整数。


## 样例 #1

### 输入

```
2```

### 输出

```
2
2 1 1 2 1
1 1 1 2
1 2 2 1
2 2 2 1 2```

# 题解

## 作者：Reanap (赞：10)

~~同班化竞生 7min 切掉了，所以应该很简单。~~

一些吐槽：

~~为什么不用两个容器，为什么分隔板贴这么紧~~。

- **Subtask 1**

大户人家做法，每对溶液组配一个专用的！需要 $n^2$ 个， $26 \times 26 = 676 < 712$，可以通过。

- **Subtask 2**

第一个做法完全没有运用题目条件，即既没有拼板，也没有翻版，很不优。

现在我们节俭一点，每个溶液配一个板，一对溶液实验时两个板拼起来用。

要使用 $2 \times n$ 个板，可以通过 子任务 2。

- **Subtask 3**

第二个做法有明显缺陷，就是实验结束后，每个板都有一面是没有接触过溶液的，还是很浪费。

发现一个板如果只脏了一面，还可以换一面给其它溶液配上。

于是把 $X$ 溶液平均分为两组，我们只给第一组配一个专属板，$Y$ 仍然每个配一个专属板，然后把第一组的溶液拿去和 $Y$ 中的所有做实验，中间隔两块板。

然后把第一组的板翻个面作为第二组的专属板，然后去和 $Y$ 中做实验。

需要 $\lceil \frac{n}{2} \rceil + n$ 个板。

对于子任务3 发现多了一个板。

考虑再节约一点。当 $n$ 为奇数的时候，不对 $x_n$ 进行分组，重复上面步骤，但在第二组实验前，把 $x_n$ 和 $Y$ 中每一个实验了。

需要 $\lfloor \frac{n}{2} \rfloor + n$ 个板，恰能通过。

免责声明： 数据点是 Rainybunny 安排的，如果有同学对这组子任务卡了向上向下取整的行为心怀不满，可以和她深入交流一下，与我无关。

- **Subtask 4** 

分析一下做法 3 的劣势。最劣的地方是，我们用板的脏面去触碰了板的干净面，这种行为我们认为是极其不优秀的，我们带着这种想法去构造更优方案。

我们把 $X$ 均分为 3 组，但同时，我们也把 $Y$ 均分为 3 组，$Y$ 每个配一个板，$X$ 第一组每个配一个板。

把 $X$ 的第一组先与 $Y$ 反应。如图：（竖线表示一组板，波浪线表示该组板的该面是有溶液的）

![](https://cdn.luogu.com.cn/upload/image_hosting/v9x1okah.png)

然后把 $Y$ 的第三组拿给 $X$ 的第二组，然后进行如下的实验：

![](https://cdn.luogu.com.cn/upload/image_hosting/js66nz8c.png)

注意到现在 $Y$ 配的板的左面依然干净，把 $Y$ 第二组的板给 $X$ 的第三组，然后进行类似上面的实验：

![](https://cdn.luogu.com.cn/upload/image_hosting/95lvfvt5.png)

最后，把 $X$ 第一组给 $Y$ 第二组，$Y$ 第一组翻面给 $Y$ 的第三组，然后剩下随便配就是了。

![](https://cdn.luogu.com.cn/upload/image_hosting/yasxh4yg.png)

说完了。要用 $\frac{n}{3} + n$ 个板。

这个子任务没有卡边界情况啥的。

- **Subtask 5**

发现上个做法有一个很糟心的点，就是我们在进行三层板操作时，我们用了一大片右面干净板来保证 $Y$ 的板的左面是干净的，但简单思考，发现我们只需要额外申请一个板就可做成这件事，而不用保证那么多的板右面随时干净。

因此继续，我们把 $X$ 分为四组，第一组配板， $Y$ 分为四组，每个配板。

先把 $X$ 第一组与 $Y$ 每一个实验一次，然后把 $X$ 第一组反过来给第二组，然后申请一个额外板，隔三层板把第二组板与 $Y$ 中溶液做实验。

得到如下局面($Y$ 板左面依然干净)：

![](https://cdn.luogu.com.cn/upload/image_hosting/g0wtobhx.png)

把 $Y$ 第三组第四组的给 $X$ 第三组第四组的，然后继续用额外板隔三层板做实验：

![](https://cdn.luogu.com.cn/upload/image_hosting/0jbe5t8n.png)

然后把 $Y$ 第一二组的反过来给三四组，随便实验一下就结束了：

![](https://cdn.luogu.com.cn/upload/image_hosting/y297hv6r.png)

使用了 $\frac{n}{4} + n$ 块板。

- **Subtask 7**

我们在上面全部的做法中，我们全部给 $Y$ 做了满配，只给了一部分 $X$ 分了板子。

考虑这样一种构造，我们把 $X$ 平均分为两组，$Y$ 平均分为三组。$X$ 中一组配板，$Y$ 中两组配板 , 然后先进行一部分实验。

![](https://cdn.luogu.com.cn/upload/image_hosting/3pribkko.png)

然后添加一个神奇的板，把 $Y$ 中第一组的板翻面放到第三组，然后隔着神奇的板再进行实验。

![](https://cdn.luogu.com.cn/upload/image_hosting/hzia3nyp.png)

之后把 $X$ 中第一组的板翻面给第二组，通过翻面的神奇的板再实验一轮。

![](https://cdn.luogu.com.cn/upload/image_hosting/lauux20a.png)

最后把 $Y$ 中第二组的翻面给第一组做一轮实验就好了。

![](https://cdn.luogu.com.cn/upload/image_hosting/rhlb1zca.png)

于是，我们使用了 $\frac{n}{2}+\frac{2n}{3} = \frac{7n}{6}$ 块板，可以通过本题。

```cpp
/*+Rainybunny+*/

#include <bits/stdc++.h>

#define rep(i, l, r) for (int i = l, rep##i = r; i <= rep##i; ++i)
#define per(i, r, l) for (int i = r, per##i = l; i >= per##i; --i)

int main() {
    int n; scanf("%d", &n);
    int s0 = n + 1 >> 1, t0 = (n + 2) / 3, t1 = (n - t0 + 1) >> 1;
    int p = s0 + t0 + t1 + 1;

    printf("%d\n", p);
    rep (i, 1, s0) { // S0->T0, S0->T1.
        rep (j, 1, t0 + t1) {
            printf("2 %d %d %d %d\n", i, i, j + s0, j);
        }
    }
    rep (i, 1, s0) { // S0->T2.
        rep (j, t0 + t1 + 1, n) {
            printf("3 %d %d %d %d %d\n", i, i, p, -(j - t1 + s0), j);
        }
    }
    rep (i, s0 + 1, n) { // S1->T0.
        rep (j, 1, t0) {
            printf("3 %d %d %d %d %d\n", i, -(i - s0), -p, j + s0, j);
        }
    }
    rep (i, s0 + 1, n) { // S1->T1.
        rep (j, t0 + 1, t0 + t1) {
            printf("2 %d %d %d %d\n", i, -(i - s0), -(j - t0 + s0), j);
        }
    }
    rep (i, s0 + 1, n) { // S1->T2.
        rep (j, t0 + t1 + 1, n) {
            printf("2 %d %d %d %d\n", i, -(i - s0), -(j - t1 + s0), j);
        }
    }
    return 0;
}
```

---

## 作者：Alex_Wei (赞：3)

> D. [P8477 「GLR-R3」春分](https://www.luogu.com.cn/problem/P8477)

看完题解被震撼到了。

做法 1：从 $\dfrac {3n} 2$ 入手，将 $Y$ 分成 $Y_1, Y_2$ 两半，为 $X$ 每种溶液配一块板，$Y_1$ 的每种溶液配一块板。$X - Y_1$ 实验后将 $Y_1$ 另一面配上 $Y_2$ 进行 $X - Y_2$ 实验，做到 $n + \left\lceil\dfrac n 2 \right \rceil$。将某个 $y_i$ 在 $Y_1, Y_2$ 实验中间和 $X$ 实验（直接涂到每个 $X$ 的背面）即可做到 $n + \left\lfloor \dfrac n 2 \right\rfloor$。

优化 1：$Y_2$ 和 $X$ 实验时因为 $Y_2$ 背面有 $Y_1$，所以会污染 $X$ 的每个背面，但只需用额外一块分隔板即可使得 $X$ 的所有背面不被污染。这样，在实验结束后 $X$ 的背面仍是干净的，从这点出发可以做到更优。

优化 2：考虑 $X$ 干净的背面的用处：将 $X$ 分成两半 $X_1, X_2$，$X_1$ 的背面给 $Y$ 还没有实验的溶液 $Y'$，$X_2$ 保留。用额外一块分隔板即可进行 $X_2 - Y'$ 实验，并使得 $X_2$ 的背面仍干净。然后将 $X_2$ 的背面给 $X_1$ 进行 $X_1 - Y'$ 实验即可。

做法 2：结合优化 1 和优化 2，可得如下做法：优化 2 要求 $Y' \leq \dfrac 1 2 n$，因此 $Y_1 \geq \dfrac {Y - Y'}{2} = \dfrac n 4$。将 $X$ 分成两半，$Y$ 分成三组 $Y_1, Y_2, Y_3$，其中 $Y_1, Y_2$ 占四分之一，$Y_3$ 占一半。用优化 1 进行 $X - Y_1$ 和 $X - Y_2$，使得所有 $X$ 背面仍然干净。用优化 2 进行 $X - Y_3$ 即可做到 $n + 2 + \left\lceil\dfrac n 4\right\rceil$。进一步地，将优化 1 和优化 2 的分隔板重复利用即可做到 $n + 1 + \left\lceil\dfrac n 4 \right\rceil$。

做法 3：沿用做法 2 的思路，结合数据范围，我们猜测需要做到 $\left\lceil\dfrac {2n} 3\right\rceil + \left\lceil\dfrac n 2 \right\rceil + 1$。因此，将 $X$ 分成两半 $X_1, X_2$，$Y$ 分成三半 $Y_1, Y_2, Y_3$，给 $X_1$ 和 $Y_1, Y_2$ 配分割板。首先进行 $X_1 - Y_1$ 和 $X_1 - Y_2$。为了丢掉 $X_1$，接下来肯定做 $X_1 - Y_3$，因此将 $Y_1$ 背面给 $Y_3$，进行 $X_1 - Y_3$，需要用一块分隔板保证 $X_1$ 背面不被污染。然后将 $X_1$ 背面给 $X_2$ 进行 $X_2 - Y_2$ 和 $X_2 - Y_3$，注意 $X_2 - Y_2$ 需要重复利用刚才的分隔板保证 $Y_2$ 背面不被污染。接下来将 $Y_2$ 背面给 $Y_1$，进行最后的 $X_2 - Y_1$ 即可。

分隔板使用数量为 $\left\lceil\dfrac {2n} 3\right\rceil + \left\lceil\dfrac n 2 \right\rceil + 1$，每次实验分隔板使用数量为 $\mathcal{O}(1)$，可以接受。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
bool Mbe;
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  int n, m = 712;
  cin >> n;
  int x1 = ceil(n / 2.0), x2 = n - x1;
  int y1 = ceil(n / 3.0), y2 = y1, y3 = n - y1 - y2;
  puts("712");
  if(n == 1) printf("1 1 1 1\n"), exit(0);
  for(int i = 1; i <= x1; i++)
    for(int j = 1; j <= y1; j++)
      printf("2 %d %d %d %d\n", i, i, -(x1 + j), j);
  for(int i = 1; i <= x1; i++)
    for(int j = 1; j <= y2; j++)
      printf("2 %d %d %d %d\n", i, i, -(x1 + y1 + j), y1 + j);
  for(int i = 1; i <= x1; i++)
    for(int j = 1; j <= y3; j++)
      printf("3 %d %d %d %d %d\n", i, i, m, x1 + j, y1 + y2 + j);
  for(int i = 1; i <= x2; i++)
    for(int j = 1; j <= y2; j++)
      printf("3 %d %d %d %d %d\n", x1 + i, -i, -m, -(x1 + y1 + j), y1 + j);
  for(int i = 1; i <= x2; i++)
    for(int j = 1; j <= y3; j++)
      printf("2 %d %d %d %d\n", x1 + i, -i, x1 + j, y1 + y2 + j);
  for(int i = 1; i <= x2; i++)
    for(int j = 1; j <= y1; j++)
      printf("2 %d %d %d %d\n", x1 + i, -i, x1 + y1 + j, j);
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/8/19
author: Alex_Wei
start coding at
finish debugging at
*/
```

---

## 作者：Vsinger_洛天依 (赞：2)

题目看起来比较魔怔，考虑怎么搞一下。

首先，一个最简单的想法，每对溶液组都配一个板子，可以用 $n^2$ 个板子解决，看得出来很不优啊，但是可以得到 Sub1 的分数。

节俭一点，我们如果把每个板子都拿出来一面用来对应一种溶液，此时就可以拼起来，只需要 $2n$ 个板子解决，可以获得 Sub1,Sub2 的分数。

我们发现，上面的做法有一个很严重的缺陷：每个板子都有一面是没有接触过溶液的，我们考虑对这里进行优化。

考虑 $X$ 没有接触过溶液的背面有什么用，我们把 $X$ 平均分成两组，一组是 $X_1 = \{x_1,x_2,\cdots,x_{\lfloor \frac{n}{2}\rfloor}\}$，一组是 $X_2=\{x_{\lfloor \frac{n}{2}\rfloor+1},x_{\lfloor \frac{n}{2}\rfloor+2},\cdots,x_n\}$。

我们现在为每个 $X_1$ 的板子都和 $Y$ 的分割板子去做实验，此时需要共 $n+\lceil\frac{n}{2}\rceil$ 个

我们发现此时对于剩下的那一部分我们可以通过对板子进行组合来实现全部覆盖，那么总共需要的就是 $\lceil\frac{n}{2}\rceil+ n$，通过计算我们可以发现正好多 $1$，不能通过 Sub3。

因此我们需要对这个算法进行优化，发现其实我们对于奇数的情况完全不需要单独的一个板子，我们在完成翻转后的实验前，可以先让 $x_n$ 和 $Y$ 组实验，这样在最后可以减少一块额外的分隔板，因此可以优化到 $\lfloor \frac{n}{2} \rfloor+n$，完全可以通过 Sub3。

考虑如何通过 Sub4，我们发现 Sub3 里用干净的板子去接触了不干净的板子导致干净的板子被污染了，如果能利用干净的板子就可以更优一点。

如果我们先把 $X$ 和 $Y$ 都平均分成三部分，然后先用 $X_1$ 和 $Y_{1\sim 3}$ 全部贴一次，此时我们会得到 $\frac{n}{3} + n$ 个板子。

![](https://cdn.luogu.com.cn/upload/image_hosting/6ax3ws4c.png)

那么就会形成一个这样的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/ut1f6skw.png)

我们此时拿出 $Y_3$ 翻转用没有染上的那面去染上灰色（灰色那里没有板子），此时我们在 $Y_3$ 这里直接把 $X_1$ 被污染的一面的和 $Y_3$ 被污染的一面拼起来，此时就剩下没有被污染的两面，直接进行 $X_2$ 与 $Y$ 的配置即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/32ezgfgr.png)

在染上之后我们的 $X_1$ 两面都被污染了，但是容易发现 $Y_1$ 和 $Y_2$ 依然没有被污染。

我们直接把 $Y_2$ 翻面给 $X_3$，这样我们就能得到一个左侧 $X_3$ 右侧 $Y_2$ 的板子。

我们把原本有一面没被污染的 $Y_1$ 和 $Y_3$ 拼过来就行，需要 $\frac{4n}{3}$ 个板子，能过 Sub4。

看一下 Sub5，我们发现 Sub4 有一些非常不优的地方导致了还可以进一步优化，可以发现在 Sub4 中我们的思路是保证那么一大片全都是空白的才能拼。

但是我们发现事实上我们只需要一个空白板即可。

我们对左边分成 $4$ 份，对右边分成 $4$ 份，此时只对于左边的 $X_1$ 配板，对于右边全部配板。

然后把 $X_1$ 与 $Y_{\{1\sim 4\}}$ 全部反应一次，我们把 $X_1$ 反过来放 $X_2$，中间隔一个空白板，直接和 $Y_{\{i\sim 4\}}$ 全部反应一次。

然后用类似上一步的方法进行反应即可，需要 $\frac{n}{4}+n+1$ 块，可以通过 Sub5。

此时我们发现一件事，诶我们这里 $X$ 和 $Y$ 分的总量都是相同的，我们对于左侧分成两部分 $X_1,X_2$，对于右侧分为三个部分 $Y_1,Y_2,Y_3$，其中对于 $X_1$ 配板，同时 $Y_1,Y_2$ 配板。

我们先对于 $X_1$ 和 $Y_1,Y_2$ 进行实验，在试验后我们加入一个空白隔板，让 $Y_1$ 翻面，此时隔着空白隔板进行 $Y_3$ 的实验，空白隔板的一面会和 $Y_1$ 接触导致污染。

此时我们翻转 $X_1$ 进行 $X_2$ 的实验，把空白隔板被污染的一面给到 $X_1$ 被翻转的一面，然后进行实验 $X_2$ 与 $Y$ 的实验，由于 $Y_2$ 还有一面没有被污染，所以刚好能行。

可通过 Sub7。

---

## 作者：Sktic (赞：2)

[P8477 「GLR-R3」春分](https://www.luogu.com.cn/problem/P8477)



看到题目感觉十分神奇，~~但是我班为什么没有这样的化竞生啊（雾）~~。



我们可以从最朴素的做法想起，对于 $X,Y$ 两组溶液，考虑给 $X$ 组每个溶液配一面板， $Y$ 组中前一半的溶液配板。



那我们就可以先将 $X_{1,2,3,\cdots,n}$ 与 $Y_{1,2,3,\cdots,\lceil\frac{n}{2}\rceil}$ 先做完实验，此时因为 $Y_{1,2,3,\cdots,\lceil\frac{n}{2}\rceil}$  的配板的左面全部干净，我们就可以将其翻面，用干净的左面对上 $Y_{\lceil\frac{n}{2}\rceil+1,\cdots,n}$ 的溶液与 $X$ 做剩余的实验，共需要 $n+\lceil\frac{n}{2}\rceil$ 块板。可以借助图片理解具体实现：

![](https://cdn.luogu.com.cn/upload/image_hosting/mx10qk5c.png)

我们很容易可以发现这个方案一个明显的缺陷： 为了让 $Y$ 节省半组板，$X$ 溶液配的板的右面全部干净，而在后一组时 $X$ 的右面全部被 $Y$ 的板所弄脏。为了不让 $X$ 的板弄脏，让节省下来的半面继续配溶液，由此可以想出一种优化，我们新采用一块板来当作中转器，当有一面脏的板要反转进行新的实验时，我们用这块一面干净的板代替 $X$ 来维持 $X$ 右面的干净，于是也可以将 $X$ 的板两面充分利用。我们考虑将 $X,Y$ 各分为 $4$ 组， $X$ 组全部配板，$Y$ 组只给第一组配板。于是我们可以先将 $X$ 与 $Y$ 的第一组全部实验，再将第一组 $Y$ 的板反转，采用一个新的小板对 $Y$ 的脏面进行隔离以保证 $X$ 右面的干净，再做完 $X$ 与 $Y$ 的第二组的全部实验。此时将 $X$ 的第三、四组板给 $Y$ 的第三、四组，再次使用隔离板保持 $X$ 的一、二组板右面保持干净，做完 $X$ 一、二组与 $Y$ 三、四组的实验。最后再把 $X$ 右面干净的一、二组板反面给 $X$ 的三、四组，与 $Y$ 的三、四组实验即可，共需要 $\lceil\frac{5n}{4}\rceil+1$ 块板。具体见图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mdct9aq3.png)

但是这样只能获得 $80$ 分，我们需要考虑更优秀的做法。由$\frac{712-1}{609}\approx\frac{7}{6}$ 可以猜出本题要对 $X$ 分三组，配两组板， $Y$ 组配一半的板，将 $X$ 的第一、二组与 $Y$ 的第一组进行实验。然后将 $X$ 的第一组反转给 $X$ 的第三组，借助中转板保证 $Y$ 的第一组板左面干净，将 $X$ 的第三组与 $Y$ 的第一组全部实验。此时 $Y$ 的第一组已经与 $X$ 全部实验，将 $Y$ 的第一组反转给 $Y$ 的第二组，同时将中转板反转，借助中转板保持 $X$ 第二组板右面的干净，将 $X$ 的第二组与 $Y$ 的第二组全部实验。最后将 $X$ 的第二组板反转给 $X$ 的第一组，实验剩余的所有部分即可。一共使用 $\lceil\frac{7n}{6}\rceil+1$ 块板，最终过程如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/fl7rurb3.png)

AC Code：

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
typedef long long ll;
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	cout<<ceil(n/2.0)+ceil(n/3.0)+ceil((n-ceil(n/3.0))/2.0)+1<<endl;
	for(int i=1;i<=ceil(n/2.0);i++)
	{
		for(int j=1;j<=ceil(n/3.0)+ceil((n-ceil(n/3.0))/2.0);j++)
		{
			cout<<"2 "<<j<<" "<<j+ceil(n/2.0)<<" "<<i<<" "<<i<<endl;
		}
	}
	for(int i=1;i<=ceil(n/2.0);i++)
	{
		for(int j=ceil((n-ceil(n/3.0))/2.0)+ceil(n/3.0)+1;j<=n;j++)
		{
			cout<<"3 "<<j<<" "<<-(j-ceil((n-ceil(n/3.0))/2.0)+ceil(n/2.0))<<" "<<ceil(n/2.0)+ceil(n/3.0)+ceil((n-ceil(n/3.0))/2.0)+1<<" "<<i<<" "<<i<<endl;
		}
	}
	for(int i=ceil(n/2.0)+1;i<=n;i++)
	{
		for(int j=1;j<=ceil(n/3.0);j++)
		{
			cout<<"3 "<<j<<" "<<j+ceil(n/2.0)<<" "<<-(ceil(n/2.0)+ceil(n/3.0)+ceil((n-ceil(n/3.0))/2.0)+1)<<" "<<-(i-ceil(n/2.0))<<" "<<i<<endl;
		}
	}
	for(int i=ceil(n/2.0)+1;i<=n;i++)
	{
		for(int j=ceil(n/3.0)+1;j<=ceil(n/3.0)+ceil((n-ceil(n/3.0))/2.0);j++)
		{
			cout<<"2 "<<j<<" "<<-(j+ceil(n/2.0)-ceil(n/3.0))<<" "<<-(i-ceil(n/2.0))<<" "<<i<<endl;
		}
		for(int j=ceil(n/3.0)+ceil((n-ceil(n/3.0))/2.0)+1;j<=n;j++)
		{
			cout<<"2 "<<j<<" "<<-(j+ceil(n/2.0)-ceil((n-ceil(n/3.0))/2.0))<<" "<<-(i-ceil(n/2.0))<<" "<<i<<endl;
		}
	}
	return 0;
}
```

~~因为代码修改了 1919810 次所以还是很丑，结合图理解就好了~~

---

## 作者：Phartial (赞：1)

牛逼逼题。

## Subtask 1

直接暴力，每个实验配一块板。

需要 $n^2$ 块板。

```cpp
cout << n * n << '\n';
for (int i = 1; i <= n; ++i) {
  for (int j = 1; j <= n; ++j) {
    cout << "1 " << i << ' ' << ++c << ' ' << j << '\n';
  }
}
```

## Subtask 2

注意到我们可以给每一种溶液配一块专属板，实验时挑出两种溶液配的板拼在一起即可。

需要 $2n$ 块板。

```cpp
cout << 2 * n << '\n';
for (int i = 1; i <= n; ++i) {
  for (int j = 1; j <= n; ++j) {
    cout << "2 " << i << ' ' << i << ' ' << n + j << ' ' << j << '\n';
  }
}
```

## Subtask 3

考虑分组，我们把右边的溶液平均分为两组，记作 $R_0$ 和 $R_1$，左边的溶液记作 $L$

那么我们考虑给 $L$ 中每组溶液配一块专属板，这里需要 $n$ 块板，然后给 $R_0$ 中每组溶液配一块板，完成 $L\times R_0$ 中的实验。

这时情况是这样的：

![sub3-1](https://cdn.luogu.com.cn/upload/image_hosting/6lvp0scr.png)

我们考虑复用 $R_0$ 中的板，翻转后给 $R_1$ 完成 $L\times R_1$ 中的实验即可。

这时需要用 $\lceil\frac{n}{2}\rceil+n$ 块板，会被卡。

发现 $R_0$ 中多出来的那块板其实根本不需要，因为污染的地方只是内侧。而在处理 $L\times R_1$ 里的实验时我们不需要内侧。

于是就只要 $\lfloor\frac{n}{2}\rfloor+n$ 块板了。

$\lceil\frac{n}{2}\rceil+n$：

```cpp
cout << (n + 1) / 2 + n << '\n';
for (int i = 1; i <= n; ++i) {
  for (int j = 1; j <= (n + 1) / 2; ++j) {
    cout << "2 " << i << ' ' << i << ' ' << n + j << ' ' << j << '\n';
  }
}
for (int i = 1; i <= n; ++i) {
  for (int j = (n + 1) / 2 + 1; j <= n; ++j) {
    cout << "2 " << i << ' ' << i << ' ' << -(n / 2 + j) << ' ' << j << '\n';
  }
}
```

$\lfloor\frac{n}{2}\rfloor+n$：

```cpp
cout << n / 2 + n << '\n';
for (int i = 1; i <= n; ++i) {
  for (int j = 1; j <= n / 2; ++j) {
    cout << "2 " << i << ' ' << i << ' ' << n + j << ' ' << j << '\n';
  }
}
if (n & 1) {
  for (int i = 1; i <= n; ++i) {
    cout << "1 " << i << ' ' << i << ' ' << n / 2 + 1 << '\n';
  }
}
for (int i = 1; i <= n; ++i) {
  for (int j = (n + 1) / 2 + 1; j <= n; ++j) {
    cout << "2 " << i << ' ' << i << ' ' << -(n / 2 + j) << ' ' << j << '\n';
  }
}
```

## Subtask 4

Subtask 3 最劣的地方在于 $L$ 配板的右边本来都是干净的，结果被 $R_0$ 配板污染了，这显然不是我们的意图。

考虑把 $L,R$ 两边都均分成 $3$ 组。给 $L_0,L_1,L_2,R_0$ 各分配一块板。

那么第一步显然是把 $L\times R_0$ 弄完。

![sub4-1](https://cdn.luogu.com.cn/upload/image_hosting/bojnis0z.png)

然后我们考虑将 $L_2$ 的板拿给 $R_1$ 用，然后将 $(L_0+L_1)\times R_1$ 弄完。

但这样会导致 $L_0+L_1$ 的配板被污染了，很劣。

考虑 $R_0$ 的配板，我们让它充当中间人，将干净的一面对着 $L_0+L_1$，脏的一面对着 $R_1$，于是 $L_0+L_1$ 依然是干净的。

![sub4-2](https://cdn.luogu.com.cn/upload/image_hosting/qhz23mhe.png)

同样的，我们再把 $L_1$ 的板给 $R_2$ 用，然后用同样的方式处理 $L_0\times R_2$

![sub4-3](https://cdn.luogu.com.cn/upload/image_hosting/7mx1oep3.png)

我们还剩下 $L_2\times R_1+(L_1+L_2)\times R_2$ 没做，随便排列组合一下就行：

![sub4-4](https://cdn.luogu.com.cn/upload/image_hosting/79malt1g.png)

需要满足 $s_{L_2}\ge s_{R_1},s_{L_1}\ge s_{R_2},s_{R_0}\ge s_{L_2},s_{L_0}\ge s_{L_1}$，取：

$$
s_{L_1}=s_{R_2}=\lfloor\frac{n}{3}\rfloor\\[5px]
s_{L_2}=s_{R_1}=\lfloor\frac{n+1}{3}\rfloor\\[5px]
s_{L_0}=s_{R_0}=\lceil\frac{n}{3}\rceil
$$

即可。

```cpp
sl1 = sr2 = n / 3;
sl2 = sr1 = (n + 1) / 3;
sl0 = sr0 = (n + 2) / 3;
for (int i = 1; i <= sl0; ++i) {
  l0[i] = ++c;
}
for (int i = 1; i <= sl1; ++i) {
  l1[i] = ++c;
}
for (int i = 1; i <= sl2; ++i) {
  l2[i] = ++c;
}
for (int i = 1; i <= sr0; ++i) {
  r0[i] = ++c;
}
cout << c << '\n';
for (int j = 1; j <= sr0; ++j) {
  for (int i = 1; i <= sl0; ++i) {
    cout << "2 " << i << ' ' << l0[i] << ' ' << r0[j] << ' ' << j << '\n';
  }
  for (int i = 1; i <= sl1; ++i) {
    cout << "2 " << sl0 + i << ' ' << l1[i] << ' ' << r0[j] << ' ' << j << '\n';
  }
  for (int i = 1; i <= sl2; ++i) {
    cout << "2 " << sl0 + sl1 + i << ' ' << l2[i] << ' ' << r0[j] << ' ' << j << '\n';
  }
}
for (int j = 1; j <= sr1; ++j) {
  for (int i = 1; i <= sl0; ++i) {
    cout << "3 " << i << ' ' << l0[i] << ' ' << r0[1] << ' ' << l2[j] << ' ' << sr0 + j << '\n';
  }
  for (int i = 1; i <= sl1; ++i) {
    cout << "3 " << sl0 + i << ' ' << l1[i] << ' ' << r0[1] << ' ' << l2[j] << ' ' << sr0 + j << '\n';
  }
}
for (int j = 1; j <= sr2; ++j) {
  for (int i = 1; i <= sl0; ++i) {
    cout << "3 " << i << ' ' << l0[i] << ' ' << r0[1] << ' ' << l1[j] << ' ' << sr0 + sr1 + j << '\n';
  }
}
for (int i = 1; i <= sl1; ++i) {
  for (int j = 1; j <= sr2; ++j) {
    cout << "2 " << sl0 + i << ' ' << -l0[i] << ' ' << l1[j] << ' ' << sr0 + sr1 + j << '\n';
  }
}
for (int i = 1; i <= sl2; ++i) {
  for (int j = 1; j <= sr1; ++j) {
    cout << "2 " << sl0 + sl1 + i << ' ' << r0[i] << ' ' << l2[j] << ' ' << sr0 + j << '\n';
  }
  for (int j = 1; j <= sr2; ++j) {
    cout << "2 " << sl0 + sl1 + i << ' ' << r0[i] << ' ' << l1[j] << ' ' << sr0 + sr1 + j << '\n';
  }
}
```

## Subtask 5~7

观察 sub 4，我们发现其实只需要额外拿一块中间板就可以保持左右两边板的状态，于是我们可以空出来一个 $R_0$ 来干一些奇奇怪怪的事情。

考虑将 $L$ 分为 $2$ 组，$R$ 分为 $3$ 组。给 $L_0,R_0,R_1$ 各分配一块板。

首先第一步显然还是将 $L_0\times(R_0+R_1)$ 的实验做了：

![sub7-1](https://cdn.luogu.com.cn/upload/image_hosting/scbjrn9j.png)

然后我们将 $R_0$ 翻转后给 $R_2$ 用，额外用一块中间板来隔绝 $L_0$ 和 $R_2$，处理 $L_0\times R_2$：

![sub7-2](https://cdn.luogu.com.cn/upload/image_hosting/moarob5w.png)

翻转 $L_0$ 给 $L_1$ 用，处理 $L_1\times R_1$：

![sub7-3](https://cdn.luogu.com.cn/upload/image_hosting/96srvqsj.png)

最后把 $R_1$ 的板翻转后给 $R_0$，处理 $L_1\times(R_0+R_2)$ 即可：

![sub7-4](https://cdn.luogu.com.cn/upload/image_hosting/k1h8y3gm.png)

需要 $s_{R_1}\ge s_{R_0}\ge s_{R_2},s_{L_0}\ge s_{L_1}$，取

$$
s_{L_0}=\lceil\frac{n}{2}\rceil,s_{L_1}=\lfloor\frac{n}{2}\rfloor\\[5px]
s_{R_0}=\lfloor\frac{n+1}{3}\rfloor,s_{R_1}=\lceil\frac{n}{3}\rceil,s_{R_2}=\lfloor\frac{n}{3}\rfloor
$$

即可。

代码实际上比 sub 4 还要好写一点。

```cpp
for (int i = 1; i <= (sl = (n + 1) / 2); ++i) {
  l[i] = ++c;
}
for (int i = 1; i <= (sr0 = (n + 1) / 3); ++i) {
  r0[i] = ++c;
}
for (int i = 1; i <= (sr1 = (n + 2) / 3); ++i) {
  r1[i] = ++c;
}
sr2 = n / 3;
x = ++c;
cout << c << '\n';
for (int i = 1; i <= sl; ++i) {
  for (int j = 1; j <= sr0; ++j) {
    cout << "2 " << i << ' ' << l[i] << ' ' << r0[j] << ' ' << j << '\n';
  }
  for (int j = 1; j <= sr1; ++j) {
    cout << "2 " << i << ' ' << l[i] << ' ' << r1[j] << ' ' << sr0 + j << '\n';
  }
}
for (int i = 1; i <= sl; ++i) {
  for (int j = 1; j <= sr2; ++j) {
    cout << "3 " << i << ' ' << l[i] << ' ' << x << ' ' << -r0[j] << ' ' << sr0 + sr1 + j << '\n';
  }
}
for (int i = 1; i <= n / 2; ++i) {
  for (int j = 1; j <= sr1; ++j) {
    cout << "3 " << sl + i << ' ' << -l[i] << ' ' << -x << ' ' << r1[j] << ' ' << sr0 + j << '\n';
  }
}
for (int i = 1; i <= n / 2; ++i) {
  int d = sl + i;
  for (int j = 1; j <= sr0; ++j) {
    cout << "2 " << d << ' ' << -l[i] << ' ' << -r1[j] << ' ' << j << '\n';
  }
  for (int j = 1; j <= sr2; ++j) {
    cout << "2 " << d << ' ' << -l[i] << ' ' << -r0[j] << ' ' << sr0 + sr1 + j << '\n';
  }
}
```

[record](https://www.luogu.com.cn/record/113201016)

[code](https://www.luogu.com.cn/paste/e2qy45fy)


---


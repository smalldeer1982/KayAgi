# 「GLR-R3」谷雨

## 题目背景

&emsp;&emsp;「几枝新叶萧萧竹，数笔横皴淡淡山」

---

&emsp;&emsp;十几天前的那条路，还好，两个人一起。

&emsp;&emsp;“很幸运呢”，阿绫悄悄嘬一口才破涕为笑的天依，“上天保佑我们要在一……”

&emsp;&emsp;鼓着腮掐着软软的腰，天依却又不觉流露笑意，是很幸运呢，刚好入围……

&emsp;&emsp;鳞次栉比的尽头，天空似云下起伏的山，皴擦着淡青墨样的欣喜。

&emsp;&emsp;她们的故事还在继续，正如谷物正当在今日生长。

---

&emsp;&emsp;**谷雨**&emsp;「我翻过一座高山　前方依然　山路漫漫」

## 题目描述

老 V 为发挥不错的大家办了场小 party，为了活跃气氛，同时贯彻安全环保的理念，~~（主要还是因为编不出来了，）~~ 老 V 带来了一个高大上的“电子烟花”，美其名曰，火**树**银花。

物如其名，这是一棵含有 $n$ 个结点的树，结点 $u$ 上有点权 $l_u$，表示该结点上所设烟花样式的**绚丽度**。好奇的大家一共对它进行了 $q$ 次操作，不妨记树上从 $u$ 到 $v$ 的路径上的结点（含 $u,v$）构成集合 $P(u,v)$，则每次操作形如：

0. 给定结点编号 $u,v$ 和新的绚丽度 $k$，意为将所有 $\in P(u,v)$，**或者**存在一个邻接点 $\in P(u,v)$ 的结点 $w$ 的绚丽度 $l_w$ **赋值**为 $k$。

1. 给定 $u,v$，点燃这一串烟花最“耀眼”的子段。具体地，维护一个**序列** $S$，从 $u$ 出发沿着树边走向 $v$，当走到结点 $w$（$w$ 可能为 $u$ 或 $v$） 时：

    - 将 $l_w$ 加入序列 $S$ 的末尾；
    - **按标号从小到大**枚举 $w$ 的邻接点 $x$，若 $x\notin P(u,v)$，将 $l_x$ 加入 $S$ 的末尾；
    - 最后，走向下一个结点。

得到最终的 $S$ 后，系统将自动点燃 $S$ 中绚丽度之和最大的子段，子段可能为空。而你需要求出这一和的最大值，即对于每次 1. 操作，求出 $S$ 的**最大可空子段和**。

## 说明/提示

#### 样例 #1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/2szx2kdy.png)

本组样例不属于测试数据，故第一行 $T$ 以 $0$ 代替。

第 $1$ 次操作为询问，依次遍历到的结点为 $\lang 1,5,2,3,4\rang$，对应权值队列 $S=\lang 1,5,2,3,4\rang$，最大子段和为 $15$。

第 $2$ 次操作为修改，将结点 $2,1,4,3$ 的点权修改为 $-2$。

第 $3$ 次操作为询问，依次遍历到的结点为 $\lang 3,2,1,4\rang$，对应权值队列 $S=\lang -2,-2,-2,-2\rang$，注意子段可以为空，所以最大子段和为 $0$。

第 $4$ 次操作为修改，将结点 $4,2$ 的点权修改为 $1$。

第 $5$ 次操作为询问，依次遍历到的结点为 $\lang 3,2,1,4\rang$，对应权值队列 $S=\lang -2,1,-2,1\rang$，最大子段和为 $1$。

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

设 $V$ 为初始点权以及修改操作中点权的值域。

对于 $100\%$ 的数据，$1\le n,q\le10^5$，$1\le p_i\le i$，$V\subseteq[-10^9,10^9]$，操作参数 $1\le u,v\le n$。

对于不同的子任务，作如下约定：

| 子任务编号 |   $n,q$   |       $V$       | 特殊性质 | 子任务分值 |
| :--------: | :-------: | :-------------: | :------: | :--------: |
|    $1$     | $\le10^3$ | $\subseteq[-10^9,10^9]$ |    无    |    $10$    |
|    $2$     | $\le10^5$ | $\subseteq[-10^9,10^9]$ |  **A**   |    $10$    |
|    $3$     | $\le10^5$ | $\subseteq[-10^9,10^9]$ |  **B**   |    $10$    |
|    $4$     | $\le10^5$ | $\subseteq[-10^9,10^9]$ |  **C**   |    $15$    |
|    $5$     | $\le10^5$ | $\subseteq[-10^9,10^9]$ |  **D**   |    $15$    |
|    $6$     | $\le10^5$ |   $\subseteq[0,10^9]$   |    无    |    $10$    |
|    $7$     | $\le10^5$ | $\subseteq[-10^9,10^9]$ |  **E**   |    $20$    |
|    $8$     | $\le10^5$ | $\subseteq[-10^9,10^9]$ |    无    |    $10$    |

- **特殊性质 A**：对于所有 $i\in[1,n)$，满足 $p_i=i$。
- **特殊性质 B**：对于所有操作中的参数 $u,v$，满足 $u=v$。
- **特殊性质 C**：不存在修改操作。
- **特殊性质 D**：有且仅有第 $q$ 次操作是询问操作。
- **特殊性质 E**：对于所有**询问操作**中的参数 $u,v$，满足当结点 $1$ 为树根时，$u=v$ 或 $u$ 是 $v$ 的祖先。
- **注意**：输入数据中的 $T$ 仅指该数据点所属子任务编号，该数据点可能满足其他子任务的约束条件。

## 样例 #1

### 输入

```
0
5
1 2 3 4 5
1 2 2 1
5
1 1 2
0 2 3 -2
1 3 4
0 4 4 1
1 3 4
```

### 输出

```
15
0
1```

# 题解

## 作者：Rainybunny (赞：23)

# $\mathscr{Description}$

&emsp;&emsp;[Link](). (It's empty temporarily.)

&emsp;&emsp;给定一棵含有 $n$ 个结点的树，点有点权。现进行 $q$ 次操作，每次操作形如：

0. **修改操作**&emsp;给定 $u,v,k$，对于所有在路径 $(u,v)$ 上，或者存在一个邻接点在路径 $(u,v)$ 上的结点 $w$，将其点权**变为** $k$。
1. **询问操作**&emsp;给定 $u,v$，从 $u$ 出发沿树边走向 $v$，走到结点 $w$ 时：$a)$ 将 $w$ 的点权加入队列 $S$；$b)$ 按标号从小到大枚举 $w$ 的邻接点 $x$，若 $x$ **不在路径上**，将 $x$ 的点权加入队列 $S$；$c)$ 最后，走向路径上的下一个点。求出 $S$ 的最大**可空**子段和。

&emsp;&emsp;$n,q\le10^5$。

# $\mathscr{Solution}$

## $\mathscr{Subtasks}$

&emsp;&emsp;**Subtask 1**&emsp;按题意模拟，注意开 `long long`，大家应该都有这档√

&emsp;&emsp;**Subtask 2**&emsp;线段树板题。反正正解也要打线段树，所以这是非常划算的部分分，应该也不难拿叭。

&emsp;&emsp;**Subtask 3**&emsp;在每个结点处拿一些东西（例如线段树）维护儿子，应该对正解有些许启发；当然，也能直接离线处理。

&emsp;&emsp;**Subtask 4 & Subtask 5**&emsp;献给差不多想到解法但觉得修改 / 询问操作特别毒瘤的选手，当然如果确实有特殊解法也是好事 awa。由于这两档已经向正解靠拢了，所以分值给高一些 w。

&emsp;&emsp;**Subtask 6**&emsp;相当于赋值与求和。献给大概会维护但是不会处理结点顺序~~或者懒得写分讨~~的选手，有特殊解法……也是好事。（

&emsp;&emsp;**Subtask 7**&emsp;献给高高兴兴写完发现事情并不简单（？）的选手（比如我），从某种意义上也算正解卡常的保底档。拿到这档几乎就会正解啦。

&emsp;&emsp;**Subtask 8**&emsp;献给正解。恭喜拿到这档的选手！因为自己的代码很冗长，也想学习一下各位的实现呢 www。

## $\mathscr{Intro}$

&emsp;&emsp;本题 idea 极其昂贵，它出自 [「NOI 2021」轻重边](https://www.luogu.com.cn/problem/P7735)。当然这道题的诞生意味这我在 NOI 2021 成为了尸体。（

&emsp;&emsp;先从[「NOI 2021」轻重边](https://www.luogu.com.cn/problem/P7735) 这道题入手讨论。我们可以把题目抽象为，给定一棵树，支持两种操作：

1. <u>毛毛虫</u>赋值；
2. 路径和查询。

其中<u>毛毛虫</u>正如本题修改和查询中涉及的树结构。这里给出形式化定义：

&emsp;&emsp;<u>毛毛虫</u>是一个树上点集，由一条树上路径 $P$ 描述。毛毛虫 $C$ 表示路径 $P$ 中的以及与 $P$ 邻接的所有结点构成的点集。此时，称 $P$ 为 $C$ 的<u>虫身</u>，$C\setminus P$ 为 $C$ 的<u>虫足</u>。

&emsp;&emsp;自然地，毛毛虫和路径有诸多相似之处，那么可以想到用树上路径维护的一贯做法——树链剖分维护毛毛虫。可惜，直接树剖全然无从下手。所以，有一个蠢货（特指我）在赛场上磨蹭半天 DIY 出了一个“毛毛虫剖分”。对于想要进行毛毛虫维护的树，毛毛虫剖分用如下方式对其重标号：

- 首先重链剖分，求出重链相关信息。

- 从树根开始递归标号。若现在递归到 $u$：
    - 若 $u$ 未被标号，则按顺序为其标号；
    - 若 $u$ 是重链头，遍历这条重链，按顺序为**不在重链上但邻接这条重链**的结点标号；
    - 若 $u$ 有重儿子，先递归重儿子；最后递归 $u$ 的其他儿子。

&emsp;&emsp;考察这个妙妙标号方法的性质：

1. 对于重链，**除链头外**，结点标号连续。

2. 对于任意结点，它的轻儿子标号连续。

3. 对于重链，不在这条重链但与其邻接的结点标号连续。

&emsp;&emsp;可见，利用这三个性质，毛毛虫剖分能够**同时**支持：

- 树上路径修改 / 查询；
- 树上毛毛虫修改 / 查询；
- 子树修改 / 查询。

&emsp;&emsp;时间复杂度基于标号后选用的数据维护方法，总的来说，**该方法不弱于传统的重链剖分**。当然，标号复杂的代价是常数因子，不过这种算法确实是能够通过 NOI 那题的。

## $\mathscr{Body}$

&emsp;&emsp;~~什么鬼标题啊这是，不能用分割线吗。~~

&emsp;&emsp;用上文的毛毛虫剖分，我们似乎能够轻松解决这道题啦？

&emsp;&emsp;可惜，这种剖分方法将毛毛虫的结构**乱序化**，我们就算可以分别得到虫身和虫足的**点集**，却无法用同样优秀的时间去维护或修改顺序访问毛毛虫得到的**序列**。

&emsp;&emsp;受上文“毛毛虫剖分 1.0”的启发，我们立马弄一个“毛毛虫剖分 2.0”的重标号方法：

- 首先重链剖分，求出重链相关信息。
- **先为树根标号**，然后从树根开始递归标号。若现在递归到结点 $u$：
    - 若 $u$ 是重链头，从 $u$ 出发遍历这条重链，若现在走到结点 $v$：
        - 若 $v$ 不是重链头，为它标号；
        - **顺序遍历** $v$ 的**轻儿子**，为它们标号；
        - 若 $v$ 还有重儿子，则继续向重儿子遍历。
    - 忽略这条重链，直接以任意顺序递归所有邻接于重链的结点。

&emsp;&emsp;可见，毛毛虫剖分 2.0 **无法支持**路径修改 / 访问，但却支持**顺序修改 / 访问**毛毛虫。我们可以用线段树维护重标号后序列的最大子段和，然后爬重链进行修改和询问。

---

&emsp;&emsp;想一想对于一条垂直的链（端点存在祖先-后代关系）在这种标号方法下得到的序列信息是：**从上到下**遍历链，**先加入**链上结点，然后**顺序加入**链外儿子。这对应了 **subtask 7** 的 $20$ 分。

&emsp;&emsp;但是！事情确实并不简单，正常情况下，我们做树剖询问需要两个路径端点各自爬到 LCA，然后**将其中一个结点爬到的答案反序**，最后将两个答案拼在一起。而这种编号方法反序的结果是：**从下到上**遍历链，**先逆序加入**链外儿子，**后加入**链上结点，这不符合题目要求的顺序！

&emsp;&emsp;因此，我们还需要设计一个与“毛毛虫剖分 2.0”对应的“毛毛虫剖分 2.1”：

- 首先重链剖分，求出重链相关信息。
- **先为树根标号**，然后从树根开始递归标号。若现在递归到结点 $u$：
    - 若 $u$ 是重链头，从 $u$ 出发遍历这条重链，若现在走到结点 $v$：
        - **逆序遍历** $v$ 的**轻儿子**，为它们标号；
        - 若 $v$ 不是重链头，为它标号；
        - 若 $v$ 还有重儿子，则继续向重儿子遍历。
    - 忽略这条重链，直接以任意顺序递归所有邻接于重链的结点。

&emsp;&emsp;在“毛毛虫剖分 2.1”下，询问垂直树链得到的序列信息是：**从上到下**遍历链，**先逆序加入**链外儿子，**后加入**链上结点。反序得到：**从下到上**遍历链，**先加入**链上结点，**后顺序加入**链外儿子。这样，我们才能用这一信息与另一条链合并。

&emsp;&emsp;概括地讲，标算为：用两种标号方法对树重标号，用线段树分别维护序列最大子段和。复杂度为 $\mathcal O(q\log^2 n)$。还有一大难点是细节，例如重链头与重链头的儿子们的先后顺序；LCA 处删去两个轻儿子贡献，加入 LCA 祖先和 LCA 重儿子贡献的顺序……难以一一罗列，具体可见代码中的处理方法。

---

&emsp;&emsp;本来想加上但是害怕被群殴，所以写在题解里的 hard version：追加两种操作：

0. **修改操作**&emsp;……
1. **询问操作**&emsp;……

2. **链询问操作**&emsp;给定 $u,v$，询问路径 $(u,v)$ 上点权序列的最大子段和。（需额外维护“毛毛虫剖分 1.0”。）
3. **优先级修改操作**&emsp;每个点 $u$ 初始有优先级 $r_u=u$，询问操作中遍历儿子时，以优先级升序遍历。给定 $u,v$，交换 $r_u,r_v$。（平衡树维护序列，区间位移，究极分讨。）

&emsp;&emsp;还是 $\mathcal O(q\log^2 n)$，反正我不想写 qwq。

## $\mathscr{Code}$

```cpp
/*+Rainybunny+*/

#include <bits/stdc++.h>

#define rep(i, l, r) for (int i = l, rep##i = r; i <= rep##i; ++i)
#define per(i, r, l) for (int i = r, per##i = l; i >= per##i; --i)

typedef long long LL;
#define fi first
#define se second

inline char fgc() {
    static char buf[1 << 17], *p = buf, *q = buf;
    return p == q && (q = buf + fread(p = buf, 1, 1 << 17, stdin), p == q) ?
      EOF : *p++;
}

template <typename Tp = int>
inline Tp rint() {
    Tp x = 0, s = fgc(), f = 1;
    for (; s < '0' || '9' < s; s = fgc()) f = s == '-' ? -f : f;
    for (; '0' <= s && s <= '9'; s = fgc()) x = x * 10 + (s ^ '0');
    return x * f;
}

template <typename Tp>
inline void wint(Tp x) {
    if (x < 0) putchar('-'), x = -x;
    if (9 < x) wint(x / 10);
    putchar(x % 10 ^ '0');
}

template <typename Tp>
inline Tp imin(const Tp& u, const Tp& v) { return u < v ? u : v; }
template <typename Tp>
inline Tp imax(const Tp& u, const Tp& v) { return u < v ? v : u; }

const int MAXN = 1e5, IINF = 0x3f3f3f3f;
int n, ecnt, fa[MAXN + 5], val[MAXN + 5], head[MAXN + 5];
int dep[MAXN + 5], siz[MAXN + 5], son[MAXN + 5];
std::vector<int> adj[MAXN + 5];

int dfc[2], dfn[MAXN + 5][2], top[MAXN + 5], ref[MAXN + 5][2];
int clef[MAXN + 5][2], crig[MAXN + 5][2];
int spos[MAXN + 5][2];

struct Atom {
    LL sum, lmx, rmx, amx;
    inline Atom rev() const { return { sum, rmx, lmx, amx }; }
    inline Atom operator + (const Atom& t) const {
        return { sum + t.sum, imax(lmx, sum + t.lmx),
          imax(rmx + t.sum, t.rmx), imax(imax(amx, t.amx), rmx + t.lmx) };
    }
    inline Atom& operator *= (const Atom& t) { return *this = *this + t; }
    inline Atom& operator += (const Atom& t) { return *this = t + *this; }
};

struct SegmentTree {
    Atom uni[MAXN << 2];
    int len[MAXN << 2], tag[MAXN << 2];

    inline void pushup(const int u) {
        uni[u] = uni[u << 1] + uni[u << 1 | 1];
    }

    inline void build(const int u, const int l, const int r, const int id) {
        len[u] = r - l + 1, tag[u] = IINF;
        if (l == r) {
            uni[u].sum = val[ref[l][id]];
            uni[u].lmx = uni[u].rmx = uni[u].amx = imax(0, val[ref[l][id]]);
            return ;
        }
        int mid = l + r >> 1;
        build(u << 1, l, mid, id), build(u << 1 | 1, mid + 1, r, id);
        pushup(u);
    }

    inline void pushas(const int u, const int v) {
        tag[u] = v, uni[u].sum = 1ll * len[u] * v;
        uni[u].lmx = uni[u].rmx = uni[u].amx = imax(0ll, uni[u].sum);
    }

    inline void pushdn(const int u) {
        if (tag[u] != IINF) {
            pushas(u << 1, tag[u]), pushas(u << 1 | 1, tag[u]);
            tag[u] = IINF;
        }
    }

    inline void assign(const int u, const int l, const int r,
      const int al, const int ar, const int k) {
        if (al > ar) return ;
        if (al <= l && r <= ar) return pushas(u, k);
        int mid = l + r >> 1; pushdn(u);
        if (al <= mid) assign(u << 1, l, mid, al, ar, k);
        if (mid < ar) assign(u << 1 | 1, mid + 1, r, al, ar, k);
        pushup(u);
    }

    inline Atom query(const int u, const int l, const int r,
      const int ql, const int qr) {
        if (ql > qr) return { 0, 0, 0, 0 };
        if (ql <= l && r <= qr) return uni[u];
        int mid = l + r >> 1; pushdn(u);
        if (qr <= mid) return query(u << 1, l, mid, ql, qr);
        if (mid < ql) return query(u << 1 | 1, mid + 1, r, ql, qr);
        return query(u << 1, l, mid, ql, qr)
          + query(u << 1 | 1, mid + 1, r, ql, qr);
    }
} sgt[2];

inline void init(const int u) {
    siz[u] = 1, dep[u] = dep[fa[u]] + 1;
    for (int v: adj[u]) {
        init(v), siz[u] += siz[v];
        if (siz[v] > siz[son[u]]) son[u] = v;
    }
}

inline void retopF(const int u) {
    clef[u][0] = dfc[0] + 1;
    if (!top[u]) dfn[u][0] = ++dfc[0];
    for (int v: adj[u]) {
        if (v == son[u]) spos[u][0] = dfc[0];
        else dfn[v][0] = ++dfc[0];
    }
    crig[u][0] = dfc[0];
    if (son[u]) retopF(son[u]);
}

inline void retopR(const int u) {
    clef[u][1] = dfc[1] + 1;
    for (int i = int(adj[u].size()) - 1, v; ~i; --i) {
        if ((v = adj[u][i]) == son[u]) spos[u][1] = dfc[1];
        else dfn[v][1] = ++dfc[1];
    }
    if (!top[u]) dfn[u][1] = ++dfc[1];
    crig[u][1] = dfc[1];
    if (son[u]) retopR(son[u]);
}

inline void renum(const int u, const int tp) {
    top[u] = tp;
    if (u == tp) retopF(u), retopR(u);
    if (son[u]) renum(son[u], tp);
    for (int v: adj[u]) if (v != son[u]) renum(v, v);
}

inline int lca(int u, int v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) v = fa[top[v]];
        else u = fa[top[u]];
    }
    return dep[u] < dep[v] ? u : v;
}

inline void assign(int u, int v, const int k, const int id) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;
        sgt[id].assign(1, 1, n, clef[top[u]][id], crig[u][id], k);
        if (son[u]) {
            sgt[id].assign(1, 1, n, dfn[son[u]][id], dfn[son[u]][id], k);
        }
        u = top[u];
        sgt[id].assign(1, 1, n, dfn[u][id], dfn[u][id], k);
        u = fa[u];
    }
    if (dep[u] < dep[v]) u ^= v ^= u ^= v;
    sgt[id].assign(1, 1, n, clef[v][id], crig[u][id], k);
    if (son[u]) sgt[id].assign(1, 1, n, dfn[son[u]][id], dfn[son[u]][id], k);
    if (v == top[v]) sgt[id].assign(1, 1, n, dfn[v][id], dfn[v][id], k);
    if (fa[v]) sgt[id].assign(1, 1, n, dfn[fa[v]][id], dfn[fa[v]][id], k);
}

inline void append(Atom& res, const int u, const int p, const int id) {
    int l = clef[u][id];
    if (dfn[p][id] < spos[u][id]) {
        res += sgt[id].query(1, 1, n, spos[u][id] + 1, crig[u][id]);
        res += sgt[id].query(1, 1, n, dfn[son[u]][id], dfn[son[u]][id]);
        res += sgt[id].query(1, 1, n, imax(dfn[p][id] + 1, l), spos[u][id]);
        res += sgt[id].query(1, 1, n, l, dfn[p][id] - 1);
    } else {
        res += sgt[id].query(1, 1, n, imax(dfn[p][id] + 1, l), crig[u][id]);
        res += sgt[id].query(1, 1, n, imax(spos[u][id] + 1, l), dfn[p][id] -1);
        if (son[u])
            res += sgt[id].query(1, 1, n, dfn[son[u]][id], dfn[son[u]][id]);
        res += sgt[id].query(1, 1, n, l, imin(spos[u][id], dfn[p][id] - 1));
    }
}

inline std::pair<Atom, int> climb(int u, const int tar, const int id) {
    Atom ret = { 0, 0, 0, 0 }; int p = 0;
    while (top[u] != top[tar]) {
        if (u != top[u]) {
            append(ret, u, p, id);
            ret += sgt[id].query(1, 1, n,
              crig[top[u]][id] + 1, clef[u][id] - 1);
            u = top[u];
            if (!id) {
                ret += sgt[0].query(1, 1, n, clef[u][0], crig[u][0]);
                ret += sgt[0].query(1, 1, n, dfn[u][0], dfn[u][0]);
            } else {
                ret += sgt[1].query(1, 1, n, dfn[u][1], dfn[u][1]);
                ret += sgt[1].query(1, 1, n, clef[u][1], crig[u][1]);
            }
        } else if (!id) {
            append(ret, u, p, 0);
            ret += sgt[0].query(1, 1, n, dfn[u][0], dfn[u][0]);
        } else {
            ret += sgt[1].query(1, 1, n, dfn[u][1], dfn[u][1]);
            append(ret, u, p, 1);
        }
        u = fa[p = u];
    }
    if (u != tar) {
        append(ret, u, p, id);
        ret += sgt[id].query(1, 1, n, clef[p = son[tar]][id], clef[u][id] - 1);
    }
    return { ret, p };
}

inline LL query(const int u, const int v) {
    int w = lca(u, v);
    auto su(climb(u, w, 1)), sv(climb(v, w, 0));
    auto ret(su.fi.rev());
    ret *= sgt[0].query(1, 1, n, dfn[w][0], dfn[w][0]);
    if (fa[w]) ret *= sgt[0].query(1, 1, n, dfn[fa[w]][0], dfn[fa[w]][0]);

    std::vector<std::pair<int, int> > tmp;
    if (su.se && su.se != son[w]) tmp.push_back({ dfn[su.se][0], 0 });
    if (sv.se && sv.se != son[w]) tmp.push_back({ dfn[sv.se][0], 0 });
    if (su.se != son[w] && sv.se != son[w]) tmp.push_back({ spos[w][0], 2 });
    tmp.push_back({ crig[w][0], 1 });
    std::sort(tmp.begin(), tmp.end());
    
    int las = clef[w][0] + (w != top[w]);
    for (auto& p: tmp) {
        ret *= sgt[0].query(1, 1, n, las, p.fi - !p.se);
        if (p.fi == spos[w][0] && p.se == 2) {
            ret = ret + sgt[0].query(1, 1, n, dfn[son[w]][0], dfn[son[w]][0]);
        }
        las = p.fi + 1;
    }
    ret *= sv.fi;
    return ret.amx;
}

int main() {
    rint(), n = rint();
    rep (i, 1, n) val[i] = rint();
    rep (i, 2, n) adj[fa[i] = rint()].push_back(i);

    init(1);
    dfn[1][0] = dfc[0] = dfn[1][1] = dfc[1] = 1;
    renum(1, 1);
    rep (i, 1, n) ref[dfn[i][0]][0] = ref[dfn[i][1]][1] = i;

    sgt[0].build(1, 1, n, 0), sgt[1].build(1, 1, n, 1);
    for (int q = rint(), op, u, v, k; q--;) {
        op = rint(), u = rint(), v = rint();
        if (!op) k = rint(), assign(u, v, k, 0), assign(u, v, k, 1);
        else wint(query(u, v)), putchar('\n');
    }
    return 0;
}

```

## $\mathscr{Details}$

&emsp;&emsp;附上数据生成细则：

```plain
1. O(n^2) brute-force | 10pts
    1.1. 10/10/10 (n=10/q=10/V=[-10,10])
    1.2. 1000/999/100   | op=1
    1.3. 999/1000/100   | only op[q]=1
    1.4. 1000/999/1000  | u=v.
    1.5. 1000/1000/1e9
2. chain | 10pts
    2.1. 1000/1000/1e9
    2.2. 1e5/(1e5-1)/1e9    | when op=0, |u-v|<10
    2.3. (1e5-1)/1e5/10     | when op=0, |u-v|<100
    2.4. 1e5/1e5/1000
    2.5. 1e5/1e5/1e9
3. in all operations, u=v holds | 10pts
    3.1. 1000/1000/1e9
    3.2. 1e5/(1e5-1)/10     | fa<=10, u,v are generated in [1,10] with pr=0.5
    3.3. (1e5-1)/1e5/100    | fa<=100, u,v are generated in [1,100] with pr=0.5
    3.4. 1e5/1e5/1000       | fa=712, u,v=712 with pr=0.412
    3.5. 1e5/1e5/1e9        | fa<=1e4
4. no modification | 15pts
    4.1. 1000/1000/1e9
    4.2. 1e5/(1e5-1)/100    | fa<=1e4
    4.3. (1e5-1)/1e5/1000   | fa<=1e4
    4.4. 1e5/1e5/1e9        | fa[u] is in [u-9,u)
    4.5. 1e5/1e5/100        | `fa[u] = u - 1 - (u & 1)`
5. only one query operation | 15pts
    5.1. 1000/1000/1e9
    5.2. 1e5/(1e5-1)/10
    5.3. (1e5-1)/1e5/100
    5.4. 1e5/1e5/1000       | `fa[u] = u - 1 - (u & 1)`, |u-v|<100
    5.5. 1e5/1e5/1e9
6. v>=0 | 10pts
    6.1. 1000/1000/1e9
    6.2. 1e5/(1e5-1)/1e9
    6.3. (1e5-1)/1e5/1e9
    6.4. 1e5/1e5/1e9        | fa<=10
    6.5. 1e5/1e5/1e9        | `fa[u] = u - 1 - (u & 1)`
7. when op=1, node 1 considered as root, u is v's ancestor | 20pts
    7.1. 1000/1000/1e9
    7.2. 1e5/(1e5-1)/10     | fa=712, v=712 with pr=0.412
    7.3. (1e5-1)/1e5/100    | `fa[u] = u - 1 - (u & 1)`, |u-v|<10 for op=0.
    7.4. 1e5/1e5/1000       | fa<=100
    7.5. 1e5/1e5/1e9        | fa[u] is in [u-127,u)
8. completed solution | 10pts
    8.1. 1000/1000/1e9
    8.2. 1e5/(1e5-1)/10     | fa=712, u,v=712 with pr=0.412
    8.3. (1e5-1)/1e5/100    | `fa[u] = u - 1 - (u & 1)`, |u-v|<10
    8.4. 1e5/1e5/1000       | fa<=100
    8.5. 1e5/1e5/1e9        | fa[u] is in [u-127,u)

```

&emsp;&emsp;若无特殊说明，树形的生成方式为每个点随机选父亲。可以对着看一看自己为什么得分 / 挂分。（

---

## 作者：jerry3128 (赞：8)

标程用高超的 DFS 技巧像我们展示了重排信息存储方式从而达到简化维护信息的过程。而我们考虑继续沿用树剖的方式维护信息。

考虑一次毛毛虫所覆盖的信息为：
1. 一条链上本身的信息。
1. 链上所有点不再链上的轻儿子。
1. 一些不再链上的重儿子。
1. 链端点的 LCA 的父亲。

其中 $3$ 不超过 $\log$ 个，总体而言，$1$、$3$、$4$ 是比较好维护的。那么重点就来到了如何维护 $2$ 上。

我们考虑从动态 DP 的角度维护这个东西，即对于每条重链分治，而非对于整棵树的 DFS 序或者子树分治。

考虑 $2$ 所具有的重要特殊性质：一定是一条重链的链顶。那么我们可以将这个修改标记先打到其父亲上。即对于所有轻儿子的标记。

考虑到标记是覆盖，我们想办法将标记下放。用二叉树的结构将所有轻儿子维护，将标记下放，那么每次链查询先由上至下将所有链上轻儿子的标记下放，那么此时就可以维护出一个节点及其轻儿子构成的答案。

考虑查询的构成部分：一些重链的节点及其轻儿子信息的区间答案，这个可以用线段树进行维护，注意对于一条重链的链顶和当前查询的轻边转移特判。

那么此时我们已经能够在 $\mathcal O(n\log^{2} n)$ 的时间复杂度对本题进行维护，对每一条重链开数据结构维护区间答案，查询跳的时候特判链顶即可和链尾。

考虑一些更好的优化，其实上面那个算法有很多不好看的地方。

我们考虑将轻重链剖改成虚实链剖。那么这下的毛毛虫信息就比较好看了：
1. 一条链本身。
2. 这条链的所有虚儿子的链顶。

所以我们考虑将标记对应集合的信息分离。本题链修会调用换根。所以考虑将一条实链的信息分为：
1. 链顶及链顶的虚儿子
2. 链尾及链尾的虚儿子
3. 中间部分

那么对于一次修改就可以操作为：对于一条链直接打覆盖标记，其中覆盖标记往下传时对每个轻儿子的传一个链顶修改标记。同时维护链及其轻儿子最大子段和信息及取 reverse 信息。

如此优化，实现复杂度达到 $\mathcal O(n\log n)$。

对于给出的 hard version 也可以维护：

3. 多维护一个链信息。
4. 在 rake tree 上搞一下就行了。

---

## 作者：GYHL (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P8479)

那个大佬可以告诉我这个题是那个比赛的？

## 前言

偷偷的说（别被他本人发现了）：今年是老师[Rainybunny](https://www.luogu.com.cn/user/123807)出这道题的第 $3$ 年，当他给我讲树链剖分的时，语言略带神秘，但不禁露出些许自豪的说，这道题是他出的。

但，即使是他出的，我也要吐槽一下：这什么屎山代码？

有大佬用虚实链剖分切了，鄙人不才，所以写一个大家都可以理解的题解供大家参考。

## 题目大意

给定 $n$ 个结点的树，有 $q$ 次操作，如下：

- 修改：对于在路径 $(u,v)$ 上的节点或在路径上的邻接点 $x$，将 $x$ 的点权变为 $k$。
- 查询：对于在路径 $(u,v)$ 上的节点 $x$：
  1.将 $x$ 的点权加入 $S$；
  2.按标号升序枚举 $x$ 的**不在路径上**的邻接点 $y$，将 $y$ 的点权加入 $S$。求 $S$ 的最大可空子段和。

~~看似很简单。~~

## 引入

大家都知道[「NOI 2021」轻重边](https://www.luogu.com.cn/problem/P7735)这道题吧，这道题是这样的：

每条边一开始都是轻边。
有两种操作：
- 修改：将 $(u,v)$ 路径上的点的邻接点变成轻边，再将 $(u,v)$ 路径上的边变成重边。
- 查询：(u,v) 上一共有多少条重边。

我们发现了一个没有什么用的性质：每次修改的部分很像一条毛毛虫。

显然，我们要将边变成点，用**一个点表示一条边**，可以说这样做是很疯狂的，非常恐怖。

不妨换一个思路，一条边是重边，当且仅当：它被次修改的路径包含，并且在此次修改后, 它的两个端点都没有被其他修改路径包含。

换句话说：最后一次涉及这条边的两个端点的修改是同一个修改。

如此，我们便解决了这道题，但是，对毛毛虫的修改和对路径查询，真的不能做吗？

答案是：**能！**

## 思路

回忆树链剖分的基本逻辑：将**需要维护的信息**（树上路径）通过**重编号**（dfn）实现到区间上。现在，我们更关心所谓的毛毛虫的信息，那么就需要设计一种将毛毛虫通过重编号转化到区间的算法。

我们先定义一下毛毛虫的结构：对于数 $Tree=(V,E)$ 和树上一条路径的点集 $P$，定义毛毛虫为：
$$C=P\cup\underset{x\in P}{\bigcup}\{y\mid(x,y)\in E\}$$
同时，我们亲切的称 $P$ 为 $C$ 的毛毛虫虫身，$C\setminus P$ 为 $C$ 的虫足。

这样，原题的两种操作可以用一下三种操作组合而成：

1. 虫足点权赋值（为 $0$，除了 $LCA$ 的父亲）；
2. 虫身赋值（为 $1$，除了 $LCA$）；
3. 虫身点权和查询（减去 $LCA$ 贡献）。

**重点：解决了定义，但如何剖分？**

~~汪老师在课堂上说这个是毛毛虫剖分。~~

首先，为什么我们要用重链？因为我们跳整个链，从 $S_u\gets2S_u$，我们只有用重链剖分才能保证我的时间复杂度。

但是，我们要再重链剖分的基础上改进一下，在其原有的性质的基础上增加必要的性质。

对于本题来说，重编号方法不难构造。先为树根编号，接着从树根所在的重链出发，依次进行：

1. 为除重链头 $top$ 以外的重链结点依次编号；
2. 依次枚举重链结点，为它们的轻儿子依次编号（这些儿子是其他重链的 $top$）；
3. 任意顺序递归 $2.$ 中的轻儿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/3eo08v4o.png)
在这幅图中，黄色箭头表示将要递归的子树；橙色边是重边；蓝色的框是重儿子；绿色框是重链两边的轻儿子。

可以看出，毛毛虫剖分的重编号的性质：

 - 对于重链，除 $top$ 外的结点编号连续；
 - 对于任意结点，其轻儿子编号连续；
 - 对于重链毛毛虫，除 $top$ 的父亲外所有虫足编号连续。

所以，毛毛虫剖分可以很方便的维护毛毛虫信息。并且，他能顺便维护重链剖分的所有信息，还能维护子树的所有信息（子树最多剖分为三部分：重链区间、邻接轻点区间、邻接轻子树区间）。

时间复杂度为：$O(q\log^2n)$，与重链剖分完全一样。

## ~~屎山~~代码

注意：第 $4$ 行的 `define` 要注意将 $a$ 和 $b$ 用括号包住，不然会出以外（例如 `max(x+1,y-1`) 会被展开为 `x+1<y-1?y-1:x+1`）。

```cpp
#include <bits/stdc++.h>
#define For(i, l, r) for (int i = l;i <= r; i++)
#define min(a,b) (a)<(b)?(a):(b)
#define max(a,b) (a)<(b)?(b):(a)
#define LL long long
#define fi first
#define se second

using namespace std;

inline int read() {
	int x;
	cin >> x;
	return x;
}

const int N = 1e5 + 10, IINF = 0x3f3f3f3f;
int n, ecnt, fa[N], val[N], head[N];
int dep[N], siz[N], son[N];
vector<int> g[N];

int dfc[2], dfn[N][2], top[N], rnk[N][2];
int clef[N][2], crig[N][2];
int spos[N][2];

struct Atom {
	LL sum, lmx, rmx, amx;
	inline Atom rev() const {
		return { sum, rmx, lmx, amx };
	}
	inline Atom operator + (const Atom& t) const {
		return {sum + t.sum, max(lmx, sum + t.lmx), max(rmx + t.sum, t.rmx), max(max(amx, t.amx), rmx + t.lmx)};
	}
	inline Atom& operator *= (const Atom& t) {
		return *this = *this + t;
	}
	inline Atom& operator += (const Atom& t) {
		return *this = t + *this;
	}
};

struct SegmentTree {
	Atom uni[N << 2];
	int len[N << 2], tag[N << 2];
	inline void pushup(const int u) {
		uni[u] = uni[u << 1] + uni[u << 1 | 1];
	}
	inline void build(int u, int l, int r, int id) {
		len[u] = r - l + 1, tag[u] = IINF;
		if (l == r) {
			uni[u].sum = val[rnk[l][id]];
			uni[u].lmx = uni[u].rmx = uni[u].amx = max(0, val[rnk[l][id]]);
			return ;
		}
		int mid = (l + r) >> 1;
		build(u << 1, l, mid, id), build(u << 1 | 1, mid + 1, r, id);
		pushup(u);
	}
	inline void change(int u, int v) {
		tag[u] = v, uni[u].sum = 1ll * len[u] * v;
		uni[u].lmx = uni[u].rmx = uni[u].amx = max(0ll, uni[u].sum);
	}
	inline void pushdown(int u) {
		if (tag[u] != IINF) {
			change(u << 1, tag[u]), change(u << 1 | 1, tag[u]);
			tag[u] = IINF;
		}
	}
	inline void mulity(int u, int l, int r,int al, int ar, int k) {
		if (al > ar) return ;
		if (al <= l && r <= ar) return change(u, k);
		int mid = (l + r) >> 1;
		pushdown(u);
		if (al <= mid) mulity(u << 1, l, mid, al, ar, k);
		if (mid < ar) mulity(u << 1 | 1, mid + 1, r, al, ar, k);
		pushup(u);
	}
	inline Atom query(int u, int l, int r,int ql, int qr) {
		if (ql > qr) return { 0, 0, 0, 0 };
		if (ql <= l && r <= qr) return uni[u];
		int mid = (l + r) >> 1;
		pushdown(u);
		if (qr <= mid) return query(u << 1, l, mid, ql, qr);
		if (mid < ql) return query(u << 1 | 1, mid + 1, r, ql, qr);
		return query(u << 1, l, mid, ql, qr)
		       + query(u << 1 | 1, mid + 1, r, ql, qr);
	}
} T[2];

inline void dfs1(int u) {
	siz[u] = 1, dep[u] = dep[fa[u]] + 1;
	for (int v : g[u]) {
		dfs1(v), siz[u] += siz[v];
		if (siz[v] > siz[son[u]]) son[u] = v;
	}
}

inline void retopF(int u) {
	clef[u][0] = dfc[0] + 1;
	if (!top[u]) dfn[u][0] = ++dfc[0];
	for (int v : g[u]) {
		if (v == son[u]) spos[u][0] = dfc[0];
		else dfn[v][0] = ++dfc[0];
	}
	crig[u][0] = dfc[0];
	if (son[u]) retopF(son[u]);
}

inline void retopR(int u) {
	clef[u][1] = dfc[1] + 1;
	for (int i = int(g[u].size()) - 1, v; ~i; --i) {
		if ((v = g[u][i]) == son[u]) spos[u][1] = dfc[1];
		else dfn[v][1] = ++dfc[1];
	}
	if (!top[u]) dfn[u][1] = ++dfc[1];
	crig[u][1] = dfc[1];
	if (son[u]) retopR(son[u]);
}

inline void dfs2(int u, int tp) {
	top[u] = tp;
	if (u == tp) retopF(u), retopR(u);
	if (son[u]) dfs2(son[u], tp);
	for (int v : g[u]) if (v != son[u]) dfs2(v, v);
}

inline int lca(int u, int v) {
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) v = fa[top[v]];
		else u = fa[top[u]];
	}
	return dep[u] < dep[v] ? u : v;
}

inline void mulity(int u, int v, int k, int id) {
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;
		T[id].mulity(1, 1, n, clef[top[u]][id], crig[u][id], k);
		if (son[u]) {
			T[id].mulity(1, 1, n, dfn[son[u]][id], dfn[son[u]][id], k);
		}
		u = top[u];
		T[id].mulity(1, 1, n, dfn[u][id], dfn[u][id], k);
		u = fa[u];
	}
	if (dep[u] < dep[v]) u ^= v ^= u ^= v;
	T[id].mulity(1, 1, n, clef[v][id], crig[u][id], k);
	if (son[u]) T[id].mulity(1, 1, n, dfn[son[u]][id], dfn[son[u]][id], k);
	if (v == top[v]) T[id].mulity(1, 1, n, dfn[v][id], dfn[v][id], k);
	if (fa[v]) T[id].mulity(1, 1, n, dfn[fa[v]][id], dfn[fa[v]][id], k);
}

inline void append(Atom& res, int u, int p,int id) {
	int l = clef[u][id];
	if (dfn[p][id] < spos[u][id]) {
		res += T[id].query(1, 1, n, spos[u][id] + 1, crig[u][id]);
		res += T[id].query(1, 1, n, dfn[son[u]][id], dfn[son[u]][id]);
		res += T[id].query(1, 1, n, max(dfn[p][id] + 1, l), spos[u][id]);
		res += T[id].query(1, 1, n, l, dfn[p][id] - 1);
	} else {
		res += T[id].query(1, 1, n, max(dfn[p][id] + 1, l), crig[u][id]);
		res += T[id].query(1, 1, n, max(spos[u][id] + 1, l), dfn[p][id] - 1);
		if (son[u])
			res += T[id].query(1, 1, n, dfn[son[u]][id], dfn[son[u]][id]);
		res += T[id].query(1, 1, n, l, min(spos[u][id], dfn[p][id] - 1));
	}
}

inline pair<Atom, int> climb(int u, int tar, int id) {
	Atom ret = { 0, 0, 0, 0 };
	int p = 0;
	while (top[u] != top[tar]) {
		if (u != top[u]) {
			append(ret, u, p, id);
			ret += T[id].query(1, 1, n,
			                   crig[top[u]][id] + 1, clef[u][id] - 1);
			u = top[u];
			if (!id) {
				ret += T[0].query(1, 1, n, clef[u][0], crig[u][0]);
				ret += T[0].query(1, 1, n, dfn[u][0], dfn[u][0]);
			} else {
				ret += T[1].query(1, 1, n, dfn[u][1], dfn[u][1]);
				ret += T[1].query(1, 1, n, clef[u][1], crig[u][1]);
			}
		} else if (!id) {
			append(ret, u, p, 0);
			ret += T[0].query(1, 1, n, dfn[u][0], dfn[u][0]);
		} else {
			ret += T[1].query(1, 1, n, dfn[u][1], dfn[u][1]);
			append(ret, u, p, 1);
		}
		u = fa[p = u];
	}
	if (u != tar) {
		append(ret, u, p, id);
		ret += T[id].query(1, 1, n, clef[p = son[tar]][id], clef[u][id] - 1);
	}
	return { ret, p };
}

inline LL query(int u, int v) {
	int w = lca(u, v);
	auto su(climb(u, w, 1)), sv(climb(v, w, 0));
	auto ret(su.fi.rev());
	ret *= T[0].query(1, 1, n, dfn[w][0], dfn[w][0]);
	if (fa[w]) ret *= T[0].query(1, 1, n, dfn[fa[w]][0], dfn[fa[w]][0]);
	vector<pair<int, int> > tmp;
	if (su.se && su.se != son[w]) tmp.push_back({ dfn[su.se][0], 0 });
	if (sv.se && sv.se != son[w]) tmp.push_back({ dfn[sv.se][0], 0 });
	if (su.se != son[w] && sv.se != son[w]) tmp.push_back({ spos[w][0], 2 });
	tmp.push_back({ crig[w][0], 1 });
	sort(tmp.begin(), tmp.end());
	int las = clef[w][0] + (w != top[w]);
	for (auto& p : tmp) {
		ret *= T[0].query(1, 1, n, las, p.fi - !p.se);
		if (p.fi == spos[w][0] && p.se == 2) {
			ret = ret + T[0].query(1, 1, n, dfn[son[w]][0], dfn[son[w]][0]);
		}
		las = p.fi + 1;
	}
	ret *= sv.fi;
	return ret.amx;
}

signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	read(), n = read();
	For (i, 1, n) val[i] = read();
	For (i, 2, n) g[fa[i] = read()].push_back(i);
	dfs1(1);
	dfn[1][0] = dfc[0] = dfn[1][1] = dfc[1] = 1;
	dfs2(1, 1);
	For (i, 1, n) rnk[dfn[i][0]][0] = rnk[dfn[i][1]][1] = i;
	T[0].build(1, 1, n, 0), T[1].build(1, 1, n, 1);
	for (int q = read(), op, u, v, k; q--;) {
		op = read(), u = read(), v = read();
		if (!op) k = read(), mulity(u, v, k, 0), mulity(u, v, k, 1);
		else cout << query(u, v) << endl;
	}
	return 0;
}
```

---

## 作者：Rainbow_qwq (赞：6)

考虑虚实链剖分，在 LCT 上 $\text{split}$ 出 $u,v$ 这条路径，那 $u,v$ 毛毛虫的结构就由以下组成：

1. 实链的点
2. 实链上每个虚儿子的链顶，按照编号顺序

这是一个适应题目信息的结构，可以维护。

我们想要设计一个结构，使得 pushup/pushtag 的时候能用到 每个虚儿子的链顶 的信息（设计和虚儿子的链顶的父子关系），并且虚儿子的链顶还要有序。

于是对每个点开一个平衡树放所有虚儿子的链顶（按照编号顺序的平衡树），一个点的点权就是自己的信息加上它平衡树根的信息。一条链的权值就是从上到下依次合并每个点的点权。

在一条实链上维护出从上到下和从下到上的最大子段和信息（因为 LCT 有 reverse 一条链操作），如下：

```cpp
void up(int x){
	s[x]=s[ls(x)]+v[x]+T::s[T::rt[x]]+s[rs(x)];
	s1[x]=s1[rs(x)]+v[x]+T::s[T::rt[x]]+s1[ls(x)];
	sz[x]=sz[ls(x)]+1+T::sz[T::rt[x]]+sz[rs(x)];
}
```

这样就能支持询问了。考虑修改：

我们维护一个 tag，表示这条实链以及实链上每个虚儿子的链顶被修改成 $x$。push tag 的时候，对于这个点的平衡树也进行 push tag，就支持了修改。

从平衡树中删一个点的时候，注意要把 LCT 上的点权更新成平衡树上的点权。插入一个点就是平衡树上的点权更新成 LCT 上的点权。

平衡树的复杂度无法均摊，所以是 $O((n+q)\log^2 n)$。

[代码，坑点写注释里了](https://www.luogu.com.cn/paste/vv4webyc)

---

## 作者：Mobius127 (赞：4)

[题传](https://www.luogu.com.cn/problem/P8479)

**upd on 2023.10.03** 补充了代码以及一些实现细节。

自己写的关于这类剖分方法的 [$blog$](https://www.cnblogs.com/sizeof127/p/16693494.html)

### 题意简述

称一条链和与其有连边的点 构成的点集 为 “毛毛虫”，链上的点为 “毛点”，某个 “毛点” $x$ 的脚（与之右边但非链点）的点集为 $T_x$。

操作：给出一条 “毛毛虫” 的两端 $u, v$，将该“毛毛虫”内的点的点权改为 $k$；

询问：开始有个空序列 $q$，给出一条 “毛毛虫” 的**头、尾** $u, v$，从头到尾按链上的顺序遍历 “毛点”，每走到一个 “毛点” $x$，现将 $x$ 的点权加入 $q$，然后将 $T_x$ 内的点的点权按点编号从小到大顺序放入 $q$。操作完后，询问 $q$ 的最大子段和（可以为 0）；

### 主要思路

考虑根据重链构造满足题目修改要求的 dfs 序，然后直接线段树维护。

设 $S_{Z}$ 为将重链 $Z$ 作为 “毛毛虫” 时的 $q$，特别的，此时 $q$ 不包含 $Z$ 链顶的父亲。

我们构造的 dfs 序满足：

>每条重链 $Z$ 的 $S_{Z}$ 的编号连续；

因为跳重链时会出现半条链的情况，所以需要额外满足：

>对于每条重链上的点 $x$，$x$ 与 $x$ 所有在 $S_{Z}$ 中的拓展点（即 $T_x$）编号连续；

注意到题目中询问分向上走和向下走两种，因此还有一个限制：

>重链点的编号的偏序关系和重链点的深度偏序关系全部相同或相反（分别对应向下和向下的情况）。

对于第三个限制，由于不能同时正序和倒序，所以构造两个不同的 dfn 序分别满足相同和相反，分开两棵线段树进行维护。

考虑构造，由于我们树剖时都是向上跳，因此我们对于某条重链，自底向上遍历每个点 $x$，对于向上跳的 dfs 序，先给 $x$ 编号后再给 $T_{x}$ 编号；对于向下跳的 dfs 序，先给 $T_{x}$ 编号再给 $x$ 编号。这样子，对于我们询问中向下跳的部分，只要整体翻转就可以得到正序遍历之后的信息。

```cpp
void cover(int x){
	if(son[x]) cover(son[x]);
	dfT[x][0]=dfn[0]+1, nfT[x][0]=nfd[0]+1;if(!dfn[x]) dfn[x]=++dfn[0];
	for(auto v:G[x]) if(son[x]^v) dfn[v]=++dfn[0];reverse(G[x].begin(), G[x].end());
	for(auto v:G[x]) if(son[x]^v) nfd[v]=++nfd[0];reverse(G[x].begin(), G[x].end());
	if(!nfd[x]) nfd[x]=++nfd[0];dfT[x][1]=dfn[0], nfT[x][1]=nfd[0];
}
void dfs(int x, int rt){
	top[x]=rt;if(x==rt) cover(x);if(son[x]) dfs(son[x], rt);
	int c=0;for(auto v:G[x]) if(son[x]^v) dfs(v, v), ++c;else pos[x]=c;
}
```

其中 $dfn_{x}, nfd_{x}$ 分别为 $x$ 上跳/下跳的 dfs 序。$dfT_{x, 0, 1}, nfT_{x, 0/1}$ 则维护了 $T_{x}$ 的 dfs 序区间。

注意到这样的构造有点不完美：一条重链 $Z$ 的链顶的 dfs 序与 $Z$ 可能是分离的。但这只需要 $O(1)$ 的分讨量，因此是利大于弊的。~~然而代码细节变得巨多~~。



### 代码细节

十分建议先写性质 D，因为询问边界很多需要特殊处理，而修改是覆盖，边界问题基本不用考虑。

对于修改：直接模拟树剖 LCA，注意跳重链时，重链顶部单独拿出来修改，当前所在的半条重链底部的重儿子也要考虑。最后注意 LCA 的父亲也要修改。

对于询问：仍是模拟 LCA，链底/顶单独拿出来，跳完一条重链的时候，可以先将重链顶部的值变为 0，这样就不需要再在上面考虑排除掉这些多余的信息。最后再修改回来即可。

更多的细节可以看代码注释。

### Code

[博客园](https://www.cnblogs.com/sizeof127/p/16698002.html)

---

## 作者：Others (赞：1)

逆天代码。

如果不考虑代码 ex 的话，本题也许可以作为另一道毛毛虫剖分板题（？）

## 题意简述

毛毛虫覆盖，毛毛虫按一定顺序遍历求最大子段和。

## 前置知识

毛毛虫剖分，一类通过舍弃一点常数来改造 $dfn$ 序进而维护树上 $1$ 邻域信息的技巧。

具体来讲，我们原来的 $dfn$ 序为每条重链从上到下的顺序凑起来的，而维护 $1$ 邻域信息要求我们把每个点轻儿子的信息放在一块，而发现每个轻儿子都是一条重链链顶，这对查询的影响是 $O(\log n)$ 的（因为正常一次查询需要访问 $O(\log n)$ 条重链），所以可以把轻儿子在 $dfn$ 数组中的位置放在一个连续段上，查询 $1$ 邻域信息则将其和父亲、重儿子信息合并即可。

**例题：** [[NOI2021] 轻重边](https://www.luogu.com.cn/problem/P7735)

对于此题，当然有更好的做法，这里可以作为毛毛虫剖分板子练手。在此题中，轻儿子的连续段是被甩在重链 $dfn$ 序的后面的，所以可以区分对轻儿子和重链的不同修改。

注意到我们要求轻儿子处于连续段而没要求轻儿子连续段与父亲的 $dfn$ 的联系，所以于本题（谷雨）中连续段便被放在的与父亲 $dfn$ 相邻的位置（按照题目给的遍历顺序划分）。

## Solution

我们按照题目遍历顺序进行毛毛虫剖分，维护最大子段和。然后正常两端往上爬，合并贡献即可。

2 个细节：一、注意到 $u→lca$ 的遍历顺序与我们构造的 $dfn$ 序有些不符，其中每段 [ 重儿子 $+$ 轻儿子从小到大连续段 ] 都要各自反向，这个显然是不太好维护的，所以考虑建立另一颗形如 [ 轻儿子从大到小连续段 $+$ 重儿子 ] 的 $dfn$ 序，然后用两颗线段树分别维护向上爬的贡献； 二、在链尾和 $lca$ 处需要考虑重儿子与父亲插在连续段哪里以及去掉爬上来时经过的重链顶，这个函数建议想好了再写。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int long long
#define lb(i) ((i)&(-(i)))
#define wr(x,ch) write(x),putchar(ch)
using namespace std;
char ibuf[(1<<20)+1],*iS,*iT;
#if ONLINE_JUDGE
#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
#else
#define gh() getchar()
#endif
inline long long read(){
	char ch=gh();
	long long x=0;
	char t=0;
	while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
	while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
	return t?-x:x;
}
void write(ll x) {
    if(x<0) putchar('-'),x=-x;
    if(x>=10) write(x/10);
    putchar(x%10^48);
    return ;
}
const int N=100005,inf=0x3f3f3f3f;
int a[N],dep[N],fa[N],siz[N],son[N],top[N],sl1[N],sr1[N],pos1[N],ord1[N],nord1;
int sr2[N],sl2[N],pos2[N],ord2[N],nord2,n,q;
vector<int> G[N];
struct node {
	int ls,rs,ss,s;
	node operator+(const node &p) const {return (node){max(ls,s+p.ls),max(p.rs,p.s+rs),max(max(ss,p.ss),rs+p.ls),s+p.s};}
	node rev() {return (node){rs,ls,ss,s};}
};
struct Others {
	node tr[N<<2];int len[N<<2],tag[N<<2];
	void pushup(int p) {tr[p]=tr[p<<1]+tr[p<<1|1];return ;}
	void update(int p,int t) {
		if(t>=0) tr[p]=(node){len[p]*t,len[p]*t,len[p]*t,len[p]*t};
		else tr[p]=(node){0,0,0,len[p]*t};
		tag[p]=t;
		return ;
	}
	void pushdown(int p) {
		if(tag[p]!=inf) update(p<<1,tag[p]),update(p<<1|1,tag[p]),tag[p]=inf;
		return ;
	}
	void build(int l,int r,int p,int *ord) {
		tag[p]=inf,len[p]=r-l+1;
		if(l==r) {
			if(a[ord[l]]>=0) tr[p]=(node){a[ord[l]],a[ord[l]],a[ord[l]],a[ord[l]]};
			else tr[p]=(node){0,0,0,a[ord[l]]};
			return ;
		}
		int mid=l+r>>1;
		build(l,mid,p<<1,ord),build(mid+1,r,p<<1|1,ord);
		pushup(p);
		return ;
	}
	void modify(int s,int t,int l,int r,int p,int d) {
		if(s>t) return ;
		if(s<=l&&r<=t) return update(p,d);
		pushdown(p);int mid=l+r>>1;
		if(s<=mid) modify(s,t,l,mid,p<<1,d);
		if(t>mid) modify(s,t,mid+1,r,p<<1|1,d);
		pushup(p);
		return ;
	}
	node ask(int s,int t,int l,int r,int p) {
		if(s*t==0) return (node){0,0,0,0};
		if(s>t) return (node){0ll,0ll,0ll,0ll};
		if(s<=l&&r<=t) return tr[p];
		pushdown(p);
		int mid=l+r>>1;node ans=(node){0ll,0ll,0ll,0ll};
		if(s<=mid) ans=ans+ask(s,t,l,mid,p<<1);
		if(t>mid) ans=ans+ask(s,t,mid+1,r,p<<1|1);
		return ans;
	}
}T1,T2;
void dfs1(int p) {
	dep[p]=dep[fa[p]]+1,siz[p]=1;
	for(const auto &lxl:G[p]) 
		fa[lxl]=p,dfs1(lxl),siz[p]+=siz[lxl],(siz[lxl]>siz[son[p]])&&(son[p]=lxl);
	return ;
}
void dfs2(int p,int Top) {
	top[p]=Top;
	if(son[p]) dfs2(son[p],Top);
	for(const auto &lxl:G[p]) 
		if(lxl!=son[p]) 
			dfs2(lxl,lxl);
	return ;
}
node deal2(int p,int son) {
	return T2.ask(sl2[p],pos2[son]-1,1,n,1)+T2.ask(pos2[son]+1,sr2[p],1,n,1)+T2.ask(pos2[p],pos2[p],1,n,1);
}
node deal1(int p,int son) {
	return T1.ask(pos1[p],pos1[p],1,n,1)+T1.ask(sl1[p],pos1[son]-1,1,n,1)+T1.ask(pos1[son]+1,sr1[p],1,n,1);
}
double fabs1(double x) {
	return x<0?-x:x;
}
node chk(int id,int P3,int P4,int p3,int p4,double *ap) {
	node ans=(node){0,0,0,0};
	if(fabs1(ap[id]-(P3-0.5))<=1e-9) ans=ans+T1.ask(pos1[p3],pos1[p3],1,n,1);
	if(fabs1(ap[id]-(P4-0.5))<=1e-9) ans=ans+T1.ask(pos1[p4],pos1[p4],1,n,1);
	return ans;
}
int ceil1(double x) {
	return (int)(x+0.5);
}
int floor1(double x) {
	return (int)x;
}
node func(int p,int p1,int p2,int p3,int p4) {
	if(p3>p4) swap(p3,p4);
	node ans=T1.ask(pos1[p],pos1[p],1,n,1);
	int P3=lower_bound(ord1+sl1[p],ord1+sr1[p]+1,p3)-ord1;
	int P4=lower_bound(ord1+sl1[p],ord1+sr1[p]+1,p4)-ord1;
	if(!p3) P3=0;if(!p4) P4=0;
	double ap[4]={pos1[p1]*1.0,pos1[p2]*1.0,P3-0.5,P4-0.5};
	sort(ap,ap+4);
	int top=-1;
	for(int i=0;i<4;i++) 
		if(ap[i]>1e-9&&(top==-1||fabs1(ap[top]-ap[i])>1e-9)) 
			ap[++top]=ap[i];
	if(top==3) {
		sort(ap,ap+4);
		ans=ans+T1.ask(sl1[p],ceil1(ap[0]-1),1,n,1);
		ans=ans+chk(0,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[0]+1),ceil1(ap[1]-1),1,n,1);
		ans=ans+chk(1,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[1]+1),ceil1(ap[2]-1),1,n,1);
		ans=ans+chk(2,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[2]+1),ceil1(ap[3]-1),1,n,1);
		ans=ans+chk(3,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[3]+1),sr1[p],1,n,1);
	}else if(top==2) {
		sort(ap,ap+3);
		ans=ans+T1.ask(sl1[p],ceil1(ap[0]-1),1,n,1);
		ans=ans+chk(0,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[0]+1),ceil1(ap[1]-1),1,n,1);
		ans=ans+chk(1,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[1]+1),ceil1(ap[2]-1),1,n,1);
		ans=ans+chk(2,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[2]+1),sr1[p],1,n,1);
	}else if(top==1) {
		sort(ap,ap+2);
		ans=ans+T1.ask(sl1[p],ceil1(ap[0]-1),1,n,1);
		ans=ans+chk(0,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[0]+1),ceil1(ap[1]-1),1,n,1);
		ans=ans+chk(1,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[1]+1),sr1[p],1,n,1);
	}else if(top==0) {
		ans=ans+T1.ask(sl1[p],ceil1(ap[0]-1),1,n,1);
		ans=ans+chk(0,P3,P4,p3,p4,ap);
		ans=ans+T1.ask(floor1(ap[0]+1),sr1[p],1,n,1);
	}else {
		ans=ans+T1.ask(sl1[p],sr1[p],1,n,1);
	}
	return ans;
}
node query(int u,int v) {
	node ansu=func(u,0,0,son[u],0).rev();
	node ansv=func(v,0,0,son[v],0);
	node lstansu=(node){0,0,0,0},lstansv=(node){0,0,0,0};
	int lstu=0,lstv=0;
	while(top[u]^top[v]) {
		if(dep[top[u]]>dep[top[v]]) {
			if(top[u]^u) ansu=T2.ask(sl2[top[u]],sr2[top[u]],1,n,1)+T2.ask(pos2[top[u]],pos2[top[u]],1,n,1)+T2.ask(sl2[son[top[u]]],pos2[fa[u]],1,n,1)+ansu;
			lstansu=ansu,ansu=func(fa[top[u]],top[u],0,son[fa[top[u]]],0).rev()+ansu;
			lstu=top[u],u=fa[top[u]];
		}else {
			if(top[v]^v) ansv=T1.ask(pos1[top[v]],pos1[top[v]],1,n,1)+T1.ask(sl1[top[v]],sr1[top[v]],1,n,1)+T1.ask(pos1[son[top[v]]],sr1[fa[v]],1,n,1)+ansv;
			lstansv=ansv,ansv=func(fa[top[v]],top[v],0,son[fa[top[v]]],0)+ansv;
			lstv=top[v],v=fa[top[v]];
		}
	}
	if(u^v) {
		if(dep[u]>dep[v]) {
			ansv=lstansv;
			if(fa[u]^v) ansu=T2.ask(sl2[son[v]],pos2[fa[u]],1,n,1)+ansu;
			return ansu.rev()+func(v,son[v],lstv,fa[v],0)+ansv;
		}else {
			ansu=lstansu;
			if(fa[v]^u) ansv=T1.ask(pos1[son[u]],sr1[fa[v]],1,n,1)+ansv;
			return ansu.rev()+func(u,son[u],lstu,fa[u],0)+ansv;
		}
	}else {
		ansv=lstansv,ansu=lstansu;
		return ansu.rev()+func(u,lstu,lstv,fa[u],son[u])+ansv;
	}
}
void modify(int x,int y,int k) {
	while(top[x]^top[y]) {
		if(dep[top[x]]>dep[top[y]]) swap(x,y);
		T1.modify(sl1[top[y]],sr1[y],1,n,1,k);
		T1.modify(pos1[top[y]],pos1[top[y]],1,n,1,k);
		if(son[y]) T1.modify(pos1[son[y]],pos1[son[y]],1,n,1,k);
		T2.modify(sl2[top[y]],y==top[y]?sr2[y]:pos2[y],1,n,1,k);
		T2.modify(pos2[top[y]],pos2[top[y]],1,n,1,k);
		if(son[y]) T2.modify(pos2[son[y]],pos2[son[y]],1,n,1,k);
		y=fa[top[y]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	if(son[y]) T1.modify(pos1[son[y]],pos1[son[y]],1,n,1,k),T2.modify(pos2[son[y]],pos2[son[y]],1,n,1,k);
	T1.modify(sl1[x],sr1[y],1,n,1,k);
	T1.modify(pos1[x],pos1[x],1,n,1,k);
	if(fa[x]) T1.modify(pos1[fa[x]],pos1[fa[x]],1,n,1,k);
	T2.modify(sl2[x],x==y?sr2[y]:pos2[y],1,n,1,k);
	T2.modify(pos2[x],pos2[x],1,n,1,k);
	if(fa[x]) T2.modify(pos2[fa[x]],pos2[fa[x]],1,n,1,k);
	return ;
}
signed main() {
// 	freopen("data.in","r",stdin);
// 	freopen("data.out","w",stdout);
	int sbtl=read();
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=2;i<=n;i++) {
		int tfa=read();
		G[tfa].push_back(i);
	}
	for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());
	dfs1(1),dfs2(1,1);
	ord1[pos1[1]=++nord1]=1;
	for(int i=1;i<=n;i++) 
		if(i==top[i]) {
			int p=i;
			while(p) {
				if(p!=top[p]) ord1[pos1[p]=++nord1]=p;
				sl1[p]=nord1+1;
				for(const auto &lxl:G[p]) 
					if(lxl!=son[p]) 
						ord1[pos1[lxl]=++nord1]=lxl;
				sr1[p]=nord1;
				p=son[p];
			}
		}
	T1.build(1,n,1,ord1);
	ord2[pos2[1]=++nord2]=1;
	for(int i=1;i<=n;i++) 
		if(i==top[i]) {
			int p=i;
			while(p) {
				sl2[p]=nord2+1;
				for(int j=(int)G[p].size()-1;j>=0;j--) 
					if(G[p][j]!=son[p]) 
						ord2[pos2[G[p][j]]=++nord2]=G[p][j];
				sr2[p]=nord2;
				if(p!=top[p]) ord2[pos2[p]=++nord2]=p;
				p=son[p];
			}
		}
	T2.build(1,n,1,ord2);
	q=read();
	for(int i=1;i<=q;i++) {
		int op=read();
//		for(int i=1;i<=n;i++) printf("%d ",T2.ask(pos2[i],pos2[i],1,n,1).s);puts("");
		if(op==0) {
			int x=read(),y=read(),k=read();
			modify(x,y,k);
		}else {
			int x=read(),y=read();
			wr(query(x,y).ss,'\n');
		}
	}
    return 0;
}

```

---

## 作者：zyn_ (赞：0)

## $0$

题目大意：给你一棵树，对长成以下形状的树的子图做两种操作：

1. 赋值；
2. 求最大子段和，其中节点的遍历顺序如下：

```cpp
int arr[N],cnt;
void dfs(int p){
    arr[++cnt]=p;
    sort(neighbour of p, less<int>());
    for(int i: neighbour of p)
        if(i!=pre[p] && i!=nxt[p])
            arr[++cnt]=i;
    if(nxt[p]) dfs(nxt[p]);
}
```

![centipede](https://cdn.luogu.com.cn/upload/image_hosting/o0zwzdpx.png)

为什么大家都把这种子图叫毛毛虫呀，我感觉它更像一只蜈蚣。

## $1$

前置知识 $1$：线段树维护区间赋值，区间最大子段和。即性质 A。

区间赋值时容易打标记，只需考虑如何合并区间。两个区间合并时，最大子段和若更新，则一定是被跨过边界的区间更新。因此需要维护最大子段和、前缀最大值、后缀最大值。发现还要维护区间和。以下直接给出代码：

```cpp
struct info{ll lm,rm,m,s;};
info merge(const info&a,const info&b){
	info c;
	c.lm=max(a.lm,a.s+b.lm);
	c.rm=max(b.rm,b.s+a.rm);
	c.m=max(max(a.m,b.m),a.rm+b.lm);
	c.s=a.s+b.s;
	return c;
}
```

前置知识 $2$：重链剖分。这是[模板题](https://www.luogu.com.cn/problem/P3384)链接。

## $2$

类树上链修改链求和问题，考虑对树做重链剖分。简单地优先遍历重儿子并标 DFS 序是行不通的，此时一只蜈蚣中所有节点的 DFS 序十分混乱，不能维护。

考虑设计一种标号方案，使得任何一只蜈蚣都可以被表示成 $O(\log n)$ 个区间的并。

为了回答询问，我们要仔细地、**不重不漏地**刻画一只蜈蚣所对应的**序列**（注意只刻画点集是不够的）。记节点 $k$ 有 $w_k$ 个儿子为 $s_{k,1},s_{k,2},\dots,s_{k,w_k}$，重儿子为 $t_k=s_{k,z_k}$。节点 $k$ 的父亲为 $p_k$。

首先假设 $v$ 是 $u$ 的祖先，考虑 $u\to v$ 路径形成的蜈蚣。根据遍历规则，对应的序列应为

$$
u,s_{u,1},s_{u,2},\dots,s_{u,w_u}
$$

$$
p_u,s_{p_u,1},\dots,s_{p_u,m_{p_u}-1},s_{p_u,m_{p_u}+1},\dots,s_{p_u,w_{p_u}}
$$

其中 $s_{p_u,m_{p_u}}=u$。记 $p_u=y$。

$$
p_y,s_{p_y,1},\dots,s_{p_y,m_{p_y}-1},s_{p_y,m_{p_y}+1},\dots,s_{p_y,w_{p_y}}
$$

其中 $s_{p_y,m_{p_y}}=y$。

$$
p_{p_y},s_{p_{p_y},1},\dots
$$

直到……节点 $v$。

发现 $v$ 的邻点除了 $w_v-1$ 个儿子还有 $p_v$。$p_v$ 应该什么时候遍历呢？

我们注意到 $p_i<i$，因此 $p_v$ 一定是 $v$ 的邻点中编号最小的点！注意这个性质会减少分类讨论的量，等会儿写代码时可要好好感谢出题人。

$$
v,p_v,s_{v,1},s_{v,2},\dots,s_{v,m_v-1},s_{v,m_v+1},\dots,s_{v,w_v}
$$

序列至此，终了。

观察到同一个节点的儿子连续出现，结合重链剖分，有以下给点标号的做法：

根节点在初始就标号。其它节点 $x$ 在遍历到 $p_x$ 的链头时标号。

具体地，遍历一个链头时，**自下往上**遍历重链中的节点 $y$，遍历 $y$ 的轻儿子，连续标号，如下：

```cpp
int hson[N],chain[N],len,id[N],cnt;
void mark(){
    for(int i=len,x;i>=1;--i){
        x=chain[i];
        if(!id[x])id[x]=++cnt;
        for(int j: son of x)if(j != hson[x])
            id[j]=++cnt;
    }
}
```

结合重链剖分的性质，可以发现，现在 $u\to v$ 的蜈蚣可以拆成与重链个数同量级，即 $O(\log n)$ 个区间了。对于每个重链对应的蜈蚣，链中间的点标号全连续，链两端也只有 $O(1)$ 个点增减。

有了拆分成区间的方法，就可以用线段树维护了。

做完了？

## $3$

> 首先假设 $u$ 是 $v$ 的祖先……

现在考虑任意 $u,v$，检查蜈蚣的形态吧。

设 $c=\operatorname{LCA}(u,v)$。$u\to c$ 前面已经讨论过了，看看 $c\to v$，就会发现这时蜈蚣对应的点序列的标号，又不连续了。

> **自下往上**遍历重链中的节点 $y$……

是这里的问题。事实上，$c\to v$ 这一段，只需在标号时**自上往下**遍历重链的节点，就可以拆成 $O(\log  n)$ 个区间的维护。

因此，可以同时用线段树维护两种标号方式下的区间最大子段和。注意不同线段树维护的信息之间也是可以合并的。另外可能需要维护区间翻转后的信息，这只需交换前后缀最大值即可。

真的做完了。

说的简单，代码真的难写，需要大量分讨。

[submission](https://www.luogu.com.cn/record/218776166)

还是给个代码吧，省略了不重要的与重复的部分。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100009
#define F 182376
#define ll long long
int n,q,f[N],g[N],op,a,b,c;
struct info{ll lm,rm,m,s;};info e={0,0,0,0};
info merge(const info&a,const info&b){}
inline info rev(const info&x){return {x.rm,x.lm,x.m,x.s};}
struct seg{
	info t[N<<2];bool f[N<<2];int a[N<<2];
	void bd(...){} void tg(...){} void pd(...){}
	void ass(...){} void upd(int l,int r,ll d){}
	info sum(...){} info qr(int l,int r){}
}sg1,sg2;
vector<int> v[N];
int fa[N],pos[N],dep[N],siz[N],son[N],top[N];
int dfn1[N],dfn2[N],cnt1,cnt2,l1[N],r1[N],l2[N],r2[N];
void dfs1(int p){} void dfs2(int p,int t){}
int lst[N],len;
void dfs3(int p){
	if(p==top[p]){
		lst[len=1]=p;while(son[lst[len]])lst[len+1]=son[lst[len]],++len;
		for(int i=1,k;i<=len;++i){
			k=lst[i];if(!dfn1[k])dfn1[k]=++cnt1;
			l1[k]=cnt1+1;for(int j:v[k])if(j!=son[k])dfn1[j]=++cnt1;r1[k]=cnt1;
		}for(int i=len,k;i>=1;--i){}
	}for(int i:v[p])dfs3(i);
}
int main(){
	scanf("%*d%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&f[i]);
	for(int i=2;i<=n;++i)scanf("%d",&fa[i]),v[fa[i]].push_back(i);
	for(int i=1;i<=n;++i){
		sort(v[i].begin(),v[i].end());
		for(int j=0;j<v[i].size();++j)pos[v[i][j]]=j;
	}
	dfs1(1);dfs2(1,1);dfs3(1);
	for(int i=1;i<=n;++i)g[dfn1[i]]=f[i]; sg1.bd(1,n,1,g);
	for(int i=1;i<=n;++i)g[dfn2[i]]=f[i]; sg2.bd(1,n,1,g);
	scanf("%d",&q);
	while(q--){
		scanf("%d%d%d",&op,&a,&b);
		if(op){
			info l=e,r=e;int ls=0,rs=0;
			while(top[a]!=top[b]){
				if(dep[top[a]]>dep[top[b]]){
					l=merge(l,sg2.qr(dfn2[a],dfn2[a]));
					if(ls){
						if(ls<son[a]){
							if(pos[ls]>0)l=merge(l,sg2.qr(l2[a],dfn2[v[a][pos[ls]-1]]));
							if(pos[ls]+1<pos[son[a]])l=merge(l,sg2.qr(dfn2[v[a][pos[ls]+1]],dfn2[v[a][pos[son[a]]-1]]));
							if(son[a])l=merge(l,sg2.qr(dfn2[son[a]],dfn2[son[a]]));
							if(pos[son[a]]+1<v[a].size())l=merge(l,sg2.qr(dfn2[v[a][pos[son[a]]+1]],r2[a]));
						} else{}
					}
					else{
						if(pos[son[a]]>0)l=merge(l,sg2.qr(l2[a],dfn2[v[a][pos[son[a]]-1]]));
						if(son[a])l=merge(l,sg2.qr(dfn2[son[a]],dfn2[son[a]]));
						if(pos[son[a]]+1<v[a].size())l=merge(l,sg2.qr(dfn2[v[a][pos[son[a]]+1]],r2[a]));
					}
					if(a!=top[a]){
						if(fa[a]!=top[a])l=merge(l,sg2.qr(dfn2[fa[a]],r2[son[top[a]]]));
						l=merge(l,sg2.qr(dfn2[top[a]],dfn2[top[a]]));
						l=merge(l,sg2.qr(l2[top[a]],r2[top[a]]));
					}ls=top[a];a=fa[top[a]];
				}
				else{
					if(rs){ if(rs<son[b]){} else{} } else{}
					r=merge(sg1.qr(dfn1[b],dfn1[b]),r);
					if(b!=top[b]){} rs=top[b];b=fa[top[b]];	
				}
			}
			if(dep[a]<dep[b]){
				if(rs){
					if(rs<son[b]){
						if(pos[son[b]]+1<v[b].size())r=merge(sg1.qr(dfn1[v[b][pos[son[b]]+1]],r1[b]),r);
						if(son[b])r=merge(sg1.qr(dfn1[son[b]],dfn1[son[b]]),r);
						if(pos[rs]+1<pos[son[b]])r=merge(sg1.qr(dfn1[v[b][pos[rs]+1]],dfn1[v[b][pos[son[b]]-1]]),r);
						if(pos[rs]>0)r=merge(sg1.qr(l1[b],dfn1[v[b][pos[rs]-1]]),r);
					} else{}
				} else{}
				r=merge(sg1.qr(dfn1[b],dfn1[b]),r);
				if(fa[b]!=a)r=merge(sg1.qr(dfn1[son[a]],r1[fa[b]]),r);
				if(ls){
					if(dfn1[ls]<r1[a])r=merge(sg1.qr(dfn1[ls]+1,r1[a]),r);
					if(dfn1[ls]>l1[a])r=merge(sg1.qr(l1[a],dfn1[ls]-1),r);
				}else r=merge(sg1.qr(l1[a],r1[a]),r);
				if(fa[a])r=merge(sg1.qr(dfn1[fa[a]],dfn1[fa[a]]),r);
				r=merge(sg1.qr(dfn1[a],dfn1[a]),r);
			} else if(dep[a]>dep[b]){}
			else{
				l=merge(l,sg2.qr(dfn2[b],dfn2[b]));
				if(fa[b])l=merge(l,sg2.qr(dfn2[fa[b]],dfn2[fa[b]]));
				int p[3]={ls?pos[ls]:F,rs?pos[rs]:F,son[b]?pos[son[b]]:F};
				if(p[0]>p[1])swap(p[0],p[1]);
				if(p[1]>p[2])swap(p[1],p[2]);
				if(p[0]>p[1])swap(p[0],p[1]);
				if(p[0]<F){
					if(p[0]>0)l=merge(l,sg2.qr(l2[b],dfn2[v[b][p[0]-1]]));
					if(v[b][p[0]]==son[b])l=merge(l,sg2.qr(dfn2[son[b]],dfn2[son[b]]));
					if(p[1]<F){
						if(p[0]+1<p[1])l=merge(l,sg2.qr(dfn2[v[b][p[0]+1]],dfn2[v[b][p[1]-1]]));
						if(v[b][p[1]]==son[b])l=merge(l,sg2.qr(dfn2[son[b]],dfn2[son[b]]));
						if(p[2]<F){ }
						else if(p[1]+1<v[b].size())l=merge(l,sg2.qr(dfn2[v[b][p[1]+1]],r2[b]));
					}else if(p[0]+1<v[b].size())l=merge(l,sg2.qr(dfn2[v[b][p[0]+1]],r2[b]));
				}
			}
			printf("%lld\n",merge(l,r).m);
		}
		else{
			scanf("%d",&c);
			while(top[a]!=top[b]){
				if(dep[top[a]]<dep[top[b]])swap(a,b);
				if(son[a])sg1.upd(dfn1[son[a]],dfn1[son[a]],c);
				sg1.upd(l1[top[a]],r1[a],c);sg1.upd(dfn1[top[a]],dfn1[top[a]],c);
				if(son[a])sg2.upd(dfn2[son[a]],dfn2[son[a]],c);
				if(a!=top[a])sg2.upd(dfn2[a],r2[top[a]],c);else sg2.upd(l2[top[a]],r2[top[a]],c);
				sg2.upd(dfn2[top[a]],dfn2[top[a]],c);a=fa[top[a]];
			}
			if(dep[a]>dep[b])swap(a,b);
			sg1.upd(l1[a],r1[b],c);if(son[b])sg1.upd(dfn1[son[b]],dfn1[son[b]],c);
			sg1.upd(dfn1[a],dfn1[a],c);if(fa[a])sg1.upd(dfn1[fa[a]],dfn1[fa[a]],c);
			if(son[b])sg2.upd(dfn2[son[b]],dfn2[son[b]],c);
			if(b!=a)sg2.upd(dfn2[b],r2[a],c);else sg2.upd(l2[a],r2[a],c);
			sg2.upd(dfn2[a],dfn2[a],c);if(fa[a])sg2.upd(dfn2[fa[a]],dfn2[fa[a]],c);
		}
	}
	return 0;
}
```

---


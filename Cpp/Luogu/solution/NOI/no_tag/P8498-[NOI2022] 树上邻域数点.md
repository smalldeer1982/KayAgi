# [NOI2022] 树上邻域数点

## 题目背景

**这是一道交互题。**

**在提交本题前请务必仔细阅读以下内容。**

本题只支持 C++ 语言提交（建议使用 C++14，请不要使用 C++14 (GCC9)）。

由于洛谷特殊的交互机制，在提交本题时，请去掉代码中的 ```#include "count.h"``` 语句，并将下发文件 **`count_.h`** （注意并不是 `count.zip` 里的 `count.h`）中的内容粘贴到代码最开头，然后提交。

如果您无法打开 `count_.h`，那么可以复制下面的内容。

```cpp
#ifndef CIRCLE_H
#define CIRCLE_H
#include<vector>
struct info{
  unsigned val;
  unsigned poi[2];
};
const info emptyinfo=info{0,(unsigned)-1,(unsigned)-1};
info MR(info a,info b);
info MC(info a,info b);
void init(int T,int n,int q,std::vector<int>dad,std::vector<info>ve,int M);
bool isempty(info a);
info ask(int x,int d);

#endif
```

如果您在提交本题时出现了任何意外的情况，请咨询管理员。

## 题目描述

给出五元组 $(T, I, S_V, S_E, \iota)$，其中：

- $T$ 是一棵 $n$ 个点的有根树 $T = (V, E)$，其中 $V$ 为 $T$ 的点集，$E$ 为 $T$ 的边集。树的节点被编号为 $1, 2, \ldots, n$，其中根节点编号为 $1$。
- $I$ 是一个集合，集合中的元素称作**信息**。其中有两个不同的特殊元素：单位元 $\epsilon$ 和不合法信息 $\bot$。

对于一般的信息，其都具有**点集合**和**边集合**两个属性。特别的，对于单位元，其只有边集合的属性，而对于不合法信息，其没有以上两种属性。

- 对于信息 $o \in I \setminus \{ \epsilon, \bot \}$，$o$ 的**点集合**是 $V$ 的一个二元子集，记作 $S_V(o)$，满足 $S_V(o) \subseteq V$ 且 $\lvert S_V(o) \rvert = 2$。其中，两个集合 $A, B$ 的差 $A \setminus B$ 被定义为 $A \setminus B = \{ x \in A \hspace{3mu}\vert\hspace{3mu} x \notin B \}$。
- 对于信息 $o \in I \setminus \{ \bot \}$，$o$ 的**边集合**是 $E$ 的一个子集，记作 $S_E(o)$，满足 $S_E(o) \subseteq E$。规定单位元的边集合为空，也即 $S_E(\epsilon) = \varnothing$。
- 对于树上的任何一条边 $e \in E$，记 $e = (u, v)$，存在一个关于 $e$ 的信息 $\iota(e) \in I$，它以其端点为点集合、自身为边集合，即 $S_V(\iota(e)) = \{ u, v \}$、$S_E(\iota(e)) = \{ e \}$。

信息有两种合并的方式，分别记作 $R$ 和 $C$。对于 $\forall a, b \in I$，记 $r = R(a, b), c = C(a, b)$，满足 $r, c \in I$，则：

- 单位元和任何信息合并都得到对方。也即，如果 $a = \epsilon$，那么 $r = c = b$；如果 $b = \epsilon$，那么 $r = c = a$。
- 不合法信息和任何信息合并都得到不合法信息。也即，如果 $a = \bot$ 或者 $b = \bot$，那么 $r = c = \bot$。
- 对于剩下的情况，如果两个信息的**边集合**的交集非空，或者**点集合**的交集的大小不为 $1$，则合并得到不合法信息。也即，如果 $S_E(a) \cap S_E(b) \ne \varnothing$ 或 $\lvert S_V(a) \cap S_V(b) \rvert \ne 1$，则 $r = c = \bot$。
- 否则，有
  $$ S_E(r) = S_E(c) = S_E(a) \cup S_E(b) \text{,} $$
  $$ S_V(r) = S_V(a) \text{,} $$
  $$ S_V(c) = S_V(a) \oplus S_V(b) \text{,} $$
  其中 $\oplus$ 表示集合的对称差运算，也即 $A \oplus B = (A \cup B) \setminus (A \cap B)$。

定义 $T$ 中两个点的树上距离为树上以两个点为端点的唯一简单路径经过的边数。

给出评分参数 $M$ 和 $q$ 次询问，每次询问给出树上的一个点 $u$ 和一个非负整数 $d$。记点集 $X$ 为 $T$ 中所有与 $u$ 的树上距离不超过 $d$ 的点构成的集合，又记边集 $Y = \{ (a, b) \in E \hspace{3mu}\vert\hspace{3mu} a, b \in X \}$ 为 $X$ 内部的边集。可以证明，从 $\epsilon$ 和所有 $\iota(e)$（$e \in E$）出发，总是能通过有限次 $R, C$ 的调用得到信息 $o \ne \bot$ 满足 $S_E(o) = Y$。

每组询问中，你需要在 $R$ 和 $C$ 的调用次数总和不超过 $M$ 的限制下构造出一个满足这样的要求的信息 $o$。特别地，如果 $d = 0$，则直接返回单位元 $\epsilon$ 即可。

----

**【实现细节】**

请确保你的程序开头有 `#include "count.h"`。

头文件 `count.h` 中实现了如下内容：

1. 定义了信息对应的数据类型 `info`；
2. 定义了 $\epsilon$ 所对应的 `info` 类型常量 `emptyinfo`，你可以在程序中直接使用。
3. 定义并实现了以下两个信息合并函数，你可以在程序中直接调用：
   
   ```cpp
   info MR(info a,info b);
   info MC(info a,info b);
   ```
   
   - 两个函数分别返回 $R(a, b)$ 与 $C(a, b)$ 对应的信息。
   
   **你需要保证调用 $\boldsymbol{R(a, b)}$ 与 $\boldsymbol{C(a, b)}$ 时结果不为 $\boldsymbol{\bot}$，否则程序可能会出现异常行为。**
4. 定义并实现了判定一个信息是否为单位元的函数，你可以在程序中直接调用：
   ```cpp
   bool isempty(info a);
   ```
   - 这个函数返回真当且仅当 $a$ 为单位元。

可以查看参考交互库了解更多实现细节。

**你不需要，也不应该实现主函数。** 你需要实现如下几个函数：

```cpp
void init(int T, int n, int q, vector<int> fa, vector<info> e, int M);
```

- `T` 表示测试点编号，`n` 表示树的点数，`q` 表示询问数，`M` 表示该测试点的评分参数。
- `fa` 和 `e` 的长度均为 $n - 1$。对于 $0 \le i < n - 1$，$fa[i]$ 和 $i + 2$ 为第 $i$ 条边 $e_i$ 的两个端点，$e[i]$ 为题目描述中提到的 $\iota(e_i)$ 所对应的 `info` 类型元素。数据保证 $fa[i]$ 小于 $i + 2$。

```cpp
info ask(int u, int d);
```

给出一个询问，参数的意义见题目描述。你需要在函数结束时返回一个满足题设条件的信息。

最终测试时，在每个测试点，交互库会**恰好**调用一次 `init` 函数，随后调用 $q$ 次 `ask`函数。交互库会使用特殊的实现方式，单个 `info` 类型的变量会恒定消耗 $12$ 字节内存，**这与下发的参考交互库不同**。为保证程序运行时内存使用在题目限制内，你需要保证运行过程中没有过多的 `info` 类型变量同时存在。

保证在满足调用次数限制且不进行 `isempty` 函数调用的情况下，最终测试的交互库运行所需的时间不超过 0.6 秒，交互库本身所消耗的内存不超过 16 MiB。保证在只执行 ${10}^8$ 次 `isempty` 函数调用的情况下，最终测试的交互库运行的时间不超过 0.25 秒。

在下发文件中包含一个名为 `count.cpp` 的文件，作为示例程序，选手可以在此基础上继续实现本题。在下发文件中还额外包含一个名为 `count_backup.h` 的备份文件，我们保证其与 `count.h` 文件完全相同。

----

**【测试程序方式】**

本题目录下提供了两个交互库的参考实现 `grader.o`、`checker.o`，其为两个不同的交互库编译产生的可链接文件。最终测试时所用的交互库实现与该实现有不同，因此选手的解法**不应依赖交互库的具体实现**，同时也不应该依赖 `count.h` 中 `info` 类型的具体实现。

你需要修改下发的 `count.h` 来帮助进行链接。具体的，在将源代码 `count.cpp` 和程序 `grader.o` 进行链接的时候，你需要注释掉 `count.h` 代码的第 5 行，并保留第 4 行的代码。链接 `checker.o` 方法类似，需要注释掉 `count.h` 代码的第 4 行，并保留第 5 行的代码。选手可以对 `count.h` 的实现自行修改来实现不同程序的编译。

修改后，选手可以在本题目录下使用如下命令编译得到可执行程序：

```bash
g++ count.cpp -c -O2 -std=c++14 -lm && g++ count.o grader.o -o count
g++ count.cpp -c -O2 -std=c++14 -lm && g++ count.o checker.o -o count
```

其中第一行命令会编译当前 `count.cpp` 后与 `grader.o` 链接起来，生成可执行文件 `count`，第二行命令则会编译当前 `count.cpp` 后与 `checker.o` 链接起来，生成可执行文件 `count`。

按上述方法编译得到的可执行文件 `count`，其运行方式如下：

- 可执行文件将从标准输入读入以下格式的数据：
  - 第一行四个整数 $id, n, q, M$，分别表示测试点编号、树的点数、询问数和评分参数；
  - 第二行 $n - 1$ 个整数 $p_2, p_3, \ldots, p_n$，分别表示 $2$ 至 $n$ 的父亲节点编号，在本地调试时你需要保证 $\forall i \in [2, n]$，$p_i < i$；
  - 接下来 $q$ 行每行两个整数 $u, d$，描述一次询问。
- 读入之后，交互库会进行测试。如果你的程序不满足交互库限制，其会在输出中返回对应的错误信息。否则，对于链接的可执行文件，其输出如下：
  - 总共一行三个整数 $C_1, C_2, C_3$，其中：
    - $C_1$ 表示程序在 `init` 函数中调用交互库函数的总次数；
    - $C_2$ 表示程序在运行过程中调用交互库函数的总次数；
    - $C_3$ 表示程序在 $q$ 次 `ask` 函数中调用交互库函数的次数的最大值。
    - 对于上述三个统计量，我们只会计入 `MR`、`MC` 函数的调用次数，而不会计入 `isempty` 函数的调用次数。
- 在链接不同文件的时候，其能够进行的检查也不同，具体地：
  - `grader.o`：其在运行时不会检查 `ask` 函数返回的信息是否正确，但可以帮助选手判断交互操作是否符合要求。这份程序运行时间最接近评测时的交互库，因此选手可以利用该程序测试运行速度，但不保证程序正确性。
  - `checker.o`：其在运行时会检查 `ask` 函数返回的信息是否正确，也可以帮助选手判断交互操作是否符合要求。同时其会检查 `ask` 函数返回的信息是否正确。这份程序可以进行答案正确性的检查。

选手在调试时需要保证输入可执行文件 `count` 的数据满足上述输入格式，否则不保证输出结果正确。


## 说明/提示

**【评分方式】**

最终评测**只会**收取 `count.cpp`，修改选手目录下其他文件不会对评测结果产生影响。**注意：**

- **未初始化的 `info` 类型的变量不保证是 `emptyinfo`。**
- **请不要尝试访问或修改 `info` 类型的成员变量，否则将被视为攻击交互库。**
- **请不要在 `init` 函数调用之前调用 `MR` 和 `MC` 函数，否则可能会发生未定义行为。**
- **你只能访问自己定义的变量和交互库返回的 `info` 类型变量，尝试访问其他空间将可能导致编译错误或运行时错误。**

**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 0 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 0 分等。

在上述条件以外，在一个测试点中，若程序执行了非法的函数调用或询问操作中给出了错误回答，该测试点将会获得 0 分。否则，记 $C_1, C_3$ 分别表示你的程序在 `init` 函数中调用交互库函数的次数，和你的程序在所有 $q$ 次 `ask` 函数中调用交互库函数的次数的最大值。如果 $C_1 \le 3 \cdot {10}^7$ 且 $C_3$ 不超过该测试点的评分参数 $M$，你将获得该测试点的分数，否则你无法获得该测试点的分数。注意：计算 $C_1, C_3$ 时只会计入 `MR`、`MC` 函数的调用次数，而不会计入 `isempty` 函数的调用次数。

----

**【样例 \#1】**

见附件中的 `count/count1.in` 与 `count/count1.ans`。

----

**【样例 \#2】**

见附件中的 `count/count2.in` 与 `count/count2.ans`。

该组样例满足数据范围中的特殊性质 A。

----

**【样例 \#3】**

见附件中的 `count/count3.in` 与 `count/count3.ans`。

该组样例满足数据范围中的特殊性质 B。

----

**【样例 \#4】**

见附件中的 `count/count4.in` 与 `count/count4.ans`。

----

**【数据范围】**

对于所有测试点，$1 \le n \le 2 \times {10}^5$，$1 \le q \le {10}^6$；每组询问中，有 $1 \le u \le n$，$1 \le d \le n - 1$。

| 测试点   | $n=$              | $q=$            | 特殊性质 | $M=$  |
|:-----:|:-----------------:|:---------------:|:----:|:-----:|
| $1$   | $1000$            | $10^4$          |      | $500$ |
| $2$   | $2000$            | $10^4$          |      | $500$ |
| $3,4$ | $10^5$            | $10^6$          | A    | $5$   |
| $5,6$ | $6 \times 10^4$   | $6\times 10^4$  | B    | $50$  |
| $7$   | $6 \times 10^4$   | $6 \times 10^4$ | B    | $5$   |
| $8$   | $10^5$            | $10^5$          | B    | $5$   |
| $9$   | $7500$            | $5 \times 10^4$ | C    | $500$ |
| $10$  | $10^4$            | $5 \times 10^4$ |      | $500$ |
| $11$  | $1.5 \times 10^4$ | $5 \times 10^4$ |      | $500$ |
| $12$  | $2 \times 10^4$   | $5 \times 10^4$ |      | $50$  |
| $13$  | $2.5 \times 10^4$ | $5 \times 10^4$ |      | $5$   |
| $14$  | $3 \times 10^4$   | $10^5$          |      | $5$   |
| $15$  | $6 \times 10^4$   | $10^6$          | D    | $5$   |
| $16$  | $6 \times 10^4$   | $10^6$          |      | $5$   |
| $17$  | $8 \times 10^4$   | $10^6$          |      | $5$   |
| $18$  | $10^5$            | $10^6$          |      | $5$   |
| $19$  | $1.5 \times 10^5$ | $10^6$          |      | $5$   |
| $20$  | $2 \times 10^5$   | $10^6$          |      | $1$   |


特殊性质 A：保证 $\forall i \in [1, n - 1]$，编号为 $i + 1$ 的点的父节点为 $i$。  
特殊性质 B：保证所有询问均满足 $u = 1$。  
特殊性质 C：保证所有询问均满足 $d \le 100$。  
特殊性质 D：保证所有询问均满足 $d \ge 1000$。

# 题解

## 作者：Elegia (赞：53)

好像有人想要一份更详细一点的题解, 我这里帮出题 ~~青蛙~~ 人写一下吧. 主要叙述通向正解的一些关键点, 所以内容会比本来讲题的课件里少一点.

## 理解题目

首先要说明的是注意到题意中两个操作的自然性, 所谓的 R 和 C 实际上就是 rake 和 compress 的缩写. 为什么说这两个操作是自然的呢? 因为它几乎就是所谓的 "动态 DP" 支持维护的信息合并的最一般形式了. 按照比较广为人知的方式解释就是, compress 无非是维护链上信息的合并, rake 是将子树信息附着在父亲链上. 此外值得一提的是, 再加上 "twist" 操作则是我们在广义串并联图上能实现的 DP 的信息合并. 在这里附上一张陈年老图:

![img](https://img.uoj.ac/user/negiizhao/basic.png)

但也要注意到为了让题目的定义不变得长, 实际上对于信息合并的细节稍微牺牲了一点直观, 也就是一般来说应该是要允许只有一个端点的信息的. 在我们 rake 一个 $\epsilon$ 和一个信息的时候, 按照我们常见的理解应该是返回一个端点的信息, 但在这里不是. 对此可能某些实现时候在这里需要更加精细地处理, 比如用一个结构体把题目给的信息套起来.

## 树上 DP

我们需要支持有一些序列 $a$, 支持:

- 给出一个信息 $x$, 将所有信息 $a_i$ 变成 $C(x, a_i)$, 然后把 $x$ 放在序列的开头.

- 将两个序列 $a, b$ 合并, 其中先把较短的那个序列用它的最后一个元素补齐, 然后合并成 $R(a_i, b_i)$.

我们直接按照定义对上面的东西暴力 $O(n)$ 做, 就可以求出 $u=1$ 的答案.

自顶向下的时候处理一下前缀和后缀, 就可以 $C_1=O(n^2)$, $C_3=0$ 的情况下求出所有答案了. 此外少加修改, 我们如果只将序列长度保留到 $d$, 就可以完成子任务 C, 因为此时有 $C_1 = O(nd)$.

## 长链剖分

特殊性质 B 的解法和正解之一有较大的关系. 其实这部分实际上也比较熟知了, 这里仅复述大致思路.

简单来说, 对于前面的树形 DP 问题, 注意到只在所有操作的最后询问. 如果我们总是能 $O(1)$ 支持第一个操作, 并 $O(\min(|a|, |b|))$ 完成第二个操作, 根据简单的贡献分析, 总共的复杂度就是 $O(n)$ 的.

具体的实现是将一个序列实际开成两个数组 $p, q$, 其中一个可以看做某种惰性标记, 实际的 $a_i = q_1 C q_2 C \cdots C q_i C p_i$. 经过较为精细的实现, 就可以完成满足上述复杂度的维护了.

这样我们可以在 $C_1 = O(n), C_3 = 0$ 的情况下通过子任务 B 了.

## 树的簇 (cluster) 分解

或者说是最为标准的树分块方法. 我们实际上划分的不是树的点集而是边集. 我们称一个连通边集且仅有不超过 $2$ 个界点时是簇 (cluster). 这里界点就是和其他边有交的点. 把边集划分成若干个不交簇的并称为簇分解.

$2$ 个界点的限制, 实际上就是为了让簇分解看成是将树 "收缩" 成了一颗更小的树. 我们总可以将 $1$ 个界点的簇随便补一个界点, 然后将每个簇看做是两个界点间的一条"边".

我们这里还要用到簇的一个性质, 就是可以我们总可以将一颗树划分成 $O(n/d)$ 个大小不超过 $d$ 的簇. 对于这道题来说可能更弱一些, 我们只需要将树划分成 $O(n/d)$ 个**直径**不超过 $d$ 的簇. 对着这个事实来编一个构造划分的算法其实并不难, 基本上就是一个贪心, 细节在这里略去.

我们考虑固定 $d$ 的时候如何处理所有 $u$ 的询问. 首先将树划分成 $O(n/d)$ 个直径不超过 $d$ 的簇, 当我们询问一个点 $u$ 的时候, $u$ 必然在某个簇的点集内, 由于这个簇的直径不超过 $d$, 所以 $d$-邻域必然完全覆盖这个簇里的所有边!
如果我们已经处理了簇的信息为 $x$, 我们还对于每个簇的界点, 预处理出了两个界点外部子树的信息 $p, q$, 就可以通过计算出 $u$ 到两个界点的距离, 然后将询问的答案表为一个 $p_i C x C q_j$ 了!

我们可以先将每个簇处理出和深度有关的 "大信息", 这是可以通过前述的长链剖分做到 $O(d)$ 的. 然后, 界点外部的信息就可以通过在外面对 "大信息" 做 $O(n/d)$ 个界点构成的边上的树形 DP 来进行维护了. 这样的总复杂度是 $O(n/d)\cdot O(d) = O(n)$.

## 正解 1 -- 簇内与簇间 DP

我们发现, 前面的处理方法实际上略加修改就可以回答不止一个 $d$. 对于所有 $d\in [L, R]$ 的询问, 我们可以将树分成 $O(n/L)$ 个簇, 然后树形 DP 时候的信息量保留到 $O(R)$, 就是 $O(nR/L)$ 的复杂度进行预处理.

也就是说对每个 $k$, 我们可以 $O(n)$ 预处理 $d\in [2^k, 2^{k+1})$ 的询问. 那么我们就有 $C_1 = O(n\log n), C_3 \leq 1$ 了.

本人实现的就是这种做法, 不过似乎由于某些常数原因, 我需要开成 $4$ 为底数才能获得 $100$ 分.

## 正解 2 -- top cluster 分解

我们考虑将一颗树每次将两条边进行 rake/compress 让树越来越小的过程, 这个过程整个可以表示成一颗树的结构, 以及所谓的 "top tree". 对于 top tree, 我们可以通过很自然的方式截取出一个簇分解: 拿出 top tree 中大小不超过 $d$ 的所有极大子树.

但是这样的簇的数量能有保证吗? 显然对于随便建的 top tree 是没有的, 但可以证明, 按照全局平衡二叉树的方式构建的 top tree, 能够保证它给出的大小不超过 $d$ 的簇分解有 $O(n/d)$ 个簇.

这样一来, 我们可以直接在这个 top tree 上先自底向上维护出每个簇的簇内信息, 再自顶向下对每个 $d=2^k$ 维护出簇外信息.

这样也足够通过本题, 并且避免了长链剖分的细致讨论.

## 正解 3 -- 一个更精简的做法

我们忘掉 $[2^k, 2^{k+1})$ 的划分方式, 转而考虑一颗 top tree 本身天然给出的划分.

处理一个询问 $(u, d)$ 的时候, 我们可以先定位到这个点所在的大小不超过 $d$ 的最大子树, 此时 $(u,d)$ 邻域必然是覆盖住这个整个子树所代表的簇的, 而且此时 $d$ 一定小于这个子树的父亲子树的簇的大小.

我们将上一个解法中的自顶向下部分改成: 每个子树维护的簇外信息截取到其父亲的大小, 这样一来, 预处理的信息量实际上就是 $O\left(\sum_{u \in \mathrm{Toptree}} \mathrm{Sub}(u)\right)$, 换句话说, 就是这棵树的 "分治复杂度".

至此我们又丢掉了一个需要的性质, 现在的结论就是: 只要有一个分治复杂度为 $O(n\log n)$ 的, 且分治时只有 $\leq 2$ 个界点的结构, 就给出一个 $C_1 = O(n\log n)$, $C_3\leq 1$ 的处理方法.

当然全局平衡二叉树依然是满足这个条件的, 遗憾的是普及度最高的点分治并不适合处理这个问题, 因为它的分治过程有 $O(\log n)$ 个界点, 这是不构成 top tree 的结构的.

## 复杂度的最优性

我们最后证明一下在询问只允许 $1$ 次信息合并的时候, 预处理必须有 $\Omega(n\log n)$ 的合并次数, 事实上我们可以证明一条链的情况就已经有此下界.

为了叙述方便, 我们在链上直接说查询 $[l, r]$, 显然这和原问题是相差常数倍等价的. 我们记 $S_{[d/2, d]}$ 为所有点 $x$ 满足预处理的时候得到过一个以 $x$ 为一个端点, 且区间长度在 $[d/2, d]$ 的信息的 $x$. 

考虑我们询问所有 $r-l=d$ 的区间, 如果只能进行一次合并, 那么一定是对于某个 $m$ 合并 $[l, m]$ 和 $[m, r]$. 此时必然有 $m-l$ 和 $r-m$ 的一者不小于 $d/2$. 因此, $l,r$ 必有一者在 $S_{[d/2, d]}$ 中. 进一步, 我们可以得到 $S_{[d/2, d]}$ 中必须有 $\Omega(n)$ 个点, 那么长度在 $[d/2, d]$ 中的信息也必须有 $\Omega(n)$ 个被预处理了.

取一系列不交的 $[d/2, d]$, 我们可以取 $\Omega(\log n)$ 个, 这说明了被预处理的信息有 $\Omega(n\log n)$ 个.


---

## 作者：EnofTaiPeople (赞：12)

### Part1 前言
题意需要我们维护一棵静态树，$\text{rake}$ 和 $\text{compress}$ 都需要通过调用函数实现，查询到节点 $x$ 距离不超过 $d$ 的边集信息，且每次查询只能进行一次信息合并，$n\le2\times10^5,q\le10^6$。

这道题太神了，以致于在 [NOI2022](/problem/P8498) 出现后被加入 [Ynoi2003](/problem/P8532)，这里感谢 zx2003，让我发现之前学的[点权和 $\text{Top Tree}$](/blog/502410/sone1-imaglct-satt-develop-p5649) 真的只是简单应用。

---
### Part2 $\text{Top Tree}$ 维护边集的静态构建
这道题的本质是 $\text{Top Tree}$ 上换根 dp，为了方便转移和查询，我们需要将 $\text{Top Tree}$ $\text{leafy}$ 化，使得每一条边所对应节点都是叶子，然后参照全局平衡二叉树的建立方式，注意节点 $1$ 没有父边，所以要忽略掉。

![](https://cdn.luogu.com.cn/upload/image_hosting/lucqyjh7.png)

上图是一棵树，加粗的点表示重儿子，它所对应的 $\text{leafy-top-tree}$ 如下图：![](https://cdn.luogu.com.cn/upload/image_hosting/xkgbvgtw.png)

其中 $r1\sim r4$ 表示 $\text{rake-node}$，$c1\sim c3$ 表示 $\text{compress-node}$，容易发现，它是一棵二叉树，有 $2n-3$ 个节点。

---
### Part3 对簇内信息的记录

簇其实就是连通的边集，并且有两个端点，上图的 $\text{Top Tree}$ 中，每一个节点都表示了一个簇。

如何维护簇内信息？

记 $g(x,0/1,k)$ 表示到左右端点距离为 $k$ 以内的边集信息。

对于一个 $\text{rake-node}$，左端点的信息就是两颗子树对应距离 $\text{rake}$ 得到的结果，由于**建树时默认重儿子在左子树**，所以右端点会继承左子树的右端点，自然也会继承左子树的右端点邻域信息。

对于每一个节点，维护一个 $len$，表示簇的左右端点距离，这样继承之后会将右儿子的 $k-len$ 邻域信息并进来：
```cpp
ln[x]=ln[ls],U[x]=U[ls],V[x]=V[ls];
for(i=0;i<=rz[x];++i){
	g[x][0][i]=R(G(ls,0,i),G(rs,0,i));
	g[x][1][i]=R(G(ls,1,i),G(rs,0,i-ln[x]));
}
```

对于一个 $\text{compress-node}$，左端点是左儿子的左端点，右端点是右儿子的右端点，合并时 $len$ 会相加，同样在处理左/右端点信息时取的是右/左儿子的 $k-len$ 邻域信息：

```cpp
ln[x]=ln[ls]+ln[rs],U[x]=U[ls],V[x]=V[rs];
for(i=0;i<=rz[x];++i){
	g[x][0][i]=C(G(ls,0,i),G(rs,0,i-ln[ls]));
	g[x][1][i]=C(G(ls,1,i-ln[rs]),G(rs,1,i));
}
```
由于每一个节点只会保留边数的信息，而此树具有全局平衡的性质，所以时空复杂度 $O(n\log_2n)$，这样就可以通过 $u=1$ 和 $n\le2000$ 的测试点了，具体地，可以对于每一个需要的根节点建一棵树，由于根节点必定是根簇的左端点，所以可以直接查询簇内信息，可以得到 $30pts$，时空复杂度 $O(rn\log_2n)$，$r$ 表示查询的不同节点个数。

---
### Part4 对簇外信息的记录
发现对于一个节点，如果不是根簇端点，可能会很尴尬：从叶子往上跳，跳多了得到的信息就超了，跳少了信息又不完全，我们无法做到让查询的信息总在一个簇内与簇的某一端点完全相邻，于是需要记录簇外的信息。

记 $h(x,0/1,k)$ 表示 $x$ 的簇外到左/右节点距离为 $k$ 以内的邻域信息。

无论是哪一个节点，它的簇外信息都有两部分组成：父亲的簇外信息和兄弟的簇内信息，这方面不难推导，依旧只需要对于两种类型的节点分类讨论就可以了：
```cpp
if(tp[x]){
	h[ls][0].resize(rz[x]+1);
	h[ls][1]=h[rs][0]=h[ls][0];
	h[rs][1]={emptyinfo};
	for(i=0;i<=rz[x];++i)
		h[ls][1][i]=H(x,1,i);
	for(i=0;i<=rz[x];++i){
		h[ls][0][i]=R(G(rs,0,i),H(x,0,i));
		h[rs][0][i]=R(C(G(ls,0,i),H(ls,1,i-ln[ls])),H(x,0,i));
	}
}else{
	h[ls][0].resize(rz[x]+1);
	h[rs][0]=h[ls][1]=h[rs][1]=h[ls][0];
	for(i=0;i<=rz[x];++i){
		h[ls][0][i]=H(x,0,i);
		h[rs][1][i]=H(x,1,i);
		h[ls][1][i]=C(H(x,1,i-ln[rs]),G(rs,0,i));
		h[rs][0][i]=C(H(x,0,i-ln[ls]),G(ls,1,i));
	}
}
```
大家可能发现了，对于每一个节点的簇外信息，我们都将其保留到了父亲的大小，这样可以方便查询。

具体地，从查询节点开始跳，直到父亲的簇大小超过 $d$ 为止，这样当前的簇内信息必定被完全包含，簇外信息也必定经过了预处理，可以通过两次 $\text{compress}$ 得到答案。

容易发现，这一部分必定会完全包含簇内信息，所以在预处理时将 $h(x,0,k)$ 与 $g(x,0,sz_x)$ 合并，就能保证查询时只需要一次 $\text{compress}$ 了，符合题意要求，时空复杂度 $O(n\log_2n)$。

---
### Part5 代码效率说明

首先，这是我的第一次[提交记录](https://uoj.ac/submission/591293)，也推荐大家参考，因为没有删注释，但是只有 $97$ 分，因为交完之后，我发现在本地纯随机造树就卡成了 `too many MR,MC operations in init()`，然后就莫名其妙地 Hack 成功了，后来发现这是被卡常了，微调了一下建树过程，就通过了，或许是出题人并不想卡人？反正目前是最优最短解，指不定哪一天就被人挤下去了。

然而，这样的做法又被我自己 [Hack 掉了](https://uoj.ac/hack/12775)，原因是，当数据为一棵完全二叉树时，高度会达到 $60$，或许在时间上没有问题，但函数调用次数会大大增加，超过了 $3\times10^7$，所以需要进一步卡常，具体地，在 dp 时不需要处理到边集大小，只需要处理到直径就可以了。

---
### Part6 后记
不知道自己想干什么，学一道题目花了一个星期，或许这是我联赛之前的最后一次任性吧。但这道题真的十分有教育意义，将树上问题在链和子树的基础上，又向全新的“邻域”问题发展，也让我了解到了 $\text{Top Tree}$ 的更多功能。

---

## 作者：水军带你飞 (赞：9)

[推销一波博客](https://www.cnblogs.com/aaaaawa/p/NOI2022D1T3.html)

有趣的题，口胡起来很快乐，但码量不小外加不能操作 grader 导致调试很困难，写+调花了五个小时。样例好像也很水，对着数据调才过。。。

特殊性质 $\text{A}$ 是一条链，这可以直接猫树分治做到 $O(n \log n)$ 预处理，$1$ 次操作查询。

特殊性质 $\text{B}$ 是每次询问的点都是 $1$。跟深度有关，可以考虑长链剖分。把轻子树暴力归并到重子树之后，重子树超出轻子树的部分可以直接打一个懒标记，就可以做到 $O(n)$ 预处理，$0$ 次操作查询。

~~知道复杂度~~认真思考之后尝试用类似树链剖分的东西乱搞出一个做法。首先还是自然想到分子树外的点和子树内的点。但是一般这种树链剖分对于一个点，问题的规模是不能超过子树大小级别的，否则复杂度很可能会炸。但是询问的 $d$ 可能会超过 $suze_u$，而对于不同的 $d$，$u$ 的答案也不相同，所以几乎不能对 $u$ 维护很大的 $d$ 的答案。

但是可以发现如果 $d$ 大于 $size_u$，那么可以发现这个 $d$ 很浪费：$u$ 子树内的点距离远远小于 $d$。所以尝试将询问做一些修改：如果 $d$ 较大，那么可以将 $u$ 换成 $fa_u$，并且将 $d$ 减 $1$，这样 $u$ 子树外覆盖到的点不变，而子树内的点仍然被完全覆盖。

不断这样操作，不可行时说明向上一步会导致 $u$ 子树内的点覆盖不完全。记 $h_u$ 表示 $u$ 子树内的点到 $u$ 的最大距离，那么就有 $d \le h_u + 1 \le size_u$，这样之后就能将 $d$ 控制在 $size_u$ 之内了。

然后考虑在每一条重链上进行链分治。分治的时候记录分治区间和区间内最左边、最右边的点连向区间外面的点中每个深度的答案。分治的时候直接把左半区间和最左边连出去的每个深度的答案跑一遍上面的长链剖分贡献到右半区间，右半区间同理贡献到左半区间。由于已经将询问的 $d$ 控制在 $size_u$ 以内，所以只要保留区间内轻子树 $size$ 和的长度就行。用全局平衡二叉树的结构即可 $O(n \log n)$ 得到每个**重链链顶**所需要的值。

然后计算答案还需要算子树内的答案。刚刚的全局平衡二叉树只能保留轻子树的 $size$ 和，也就是说如果要直接记录每个点所在重链中自身下方的点对询问的贡献，那么复杂度仍然爆炸。仍然尝试把这一部分的复杂度均摊到轻子树上面：可以找到从这个点向下的第一个点，使得这个点的轻子树没有被这次询问完全覆盖。这由于上面将 $d$ 在 $h_u + 1$ 之内，是几乎可以做到的。唯一不行的就是 $d = h_u$ 或 $d = h_u + 1$，而这时 $d$ 之超出了 $1$，所以可以在分治过程中给每个分治节点加上 $1$。

找到了这个点之后想让复杂度均摊到这个点的轻子树上面。于是可以模仿特殊性质 $\text{A}$ 的做法：设找到的第一个轻子树不被完全覆盖的点 $v$，再找到 $u, v$ 被分治开的区间 $[l, mid, r]$，尝试在这个区间解决询问。

$v$ 轻子树没有被完全覆盖，所以可以直接把刚刚的分治过程搬过来，只不过深度还要求完全覆盖右边的轻子树，这样复杂度仍然正确，并且解决了右半区间的问题。又可以发现 $u$ 到 $v$ 之前的轻子树被完全包含，所以对于左半区间以 $u$ 为根的答案，可以直接改成以 $mid$ 为根，$d$ 加上 $mid - u$ 的答案。这样 $u$ 左边被覆盖的点集相同，而 $[u, mid]$ 中轻子树仍然被完全包含。于是左半边也是直接将上面的分治过程搬过来，稍微算一下跑那个长剖的深度至少要是多少即可。询问直接将左右两边拼起来。

我的代码为了方便，没有用全局平衡二叉树，而是用了长链剖分下对每条链进行分治，分治过程直接取终点即可。由于是深度相关，每条长链只会作为轻子树在上面那条长链的分治过程中算 $O(\log n)$ 次，所以总复杂度仍然是 $O(n \log n)$。


```cpp
#include "count.h"
#include <vector>
#include <algorithm>

using namespace std;

const int N = 200005;
vector<int> to[N];
int h[N], lh[N], son[N];
int fa[N][18], top[N], mp[N], tot;
info e[N];
vector<info> dp[N], lson[N];

info mr(info x, info y) {
	if (isempty(x))
		return y;
	if (isempty(y))
		return x;
	return MR(x, y);
}
info mc(info x, info y) {
	if (isempty(x))
		return y;
	if (isempty(y))
		return x;
	return MC(x, y);
}

info getv(vector<info> &a, int p) { return a.empty() ? emptyinfo : a[min((int)a.size() - 1, p)]; }

vector<info> merge(vector<int> a, vector<vector<info>> b, int m = -1) {
	static info v[N];
	static int l[N], r[N];
	int n = a.size();
	if (m == -1)
		m = 1 << 30;

	if (n == 1 && b[0].size() <= 1)
		return {emptyinfo};

	vector<info> f{emptyinfo};
	v[0] = emptyinfo;
	for (int i = 1; i != n; i++)
		l[i] = i - 1, r[i] = i + 1, v[i] = e[max(a[i - 1], a[i])];
	r[0] = 1, l[0] = n;
	r[n] = 0, l[n] = n - 1;

	for (int i = 0; i != n; i++)
		if (b[i].empty())
			b[i].push_back(emptyinfo);

	int bg = 0;
	auto del = [&](int x) {
		l[r[x]] = l[x], r[l[x]] = r[x];
		if (x == bg)
			bg = r[x];
		v[x] = mr(v[x], b[x].back());
		if (x)
			v[r[x]] = mc(v[x], v[r[x]]);
		else
			v[r[x]] = mr(v[r[x]], v[x]);
	};

	if(b[0].size() <= 1)
		del(0);

	for (int len = 1; len <= m; len++) {
		info x = emptyinfo;
		for (int i = bg; i <= len && i < n; i = r[i]) {
			if (len - i == (int)b[i].size() - 1 && r[i] <= len && i != n - 1) {
				del(i);
				continue;
			}
			if (l[i])
				x = mc(x, v[i]);
			else
				x = mr(v[i], x);
			x = mr(x, getv(b[i], len - i));
			if (len - i == (int)b[i].size() - 1 && i != n - 1)
				del(i);
		}

		f.push_back(x);

		if (bg == n - 1 && len - (n - 1) >= (int)b[n - 1].size() - 1)
			return f;
	}
	return f;
}

vector<info> merge(vector<info> a, vector<info> b, bool op) {
	if (a.size() > b.size())
		swap(a, b);
	if (op) {
		for (int i = 0; i != (int)b.size(); i++)
			b[i] = mr(b[i], getv(a, i));
		return b;
	}
	for (int i = 0; i != (int)a.size(); i++)
		a[i] = mr(a[i], getv(b, i));
	return a;
}

void dfs1(int i) {
	for (int j : to[i])
		dfs1(j);
	sort(to[i].begin(), to[i].end(), [&](int i, int j){ return h[i] < h[j]; });
	if (!to[i].empty()) {
		son[i] = to[i].back();
		h[i] = h[son[i]] + 1;
		to[i].pop_back();
	}
	for (int j : to[i])
		lh[i] = max(lh[i], h[j]);
}

void dfs2(int i) {
	for (int x = i; x; x = son[x])
		for (int y : to[x]) {
			dfs2(y);
			vector<info> a = dp[y];
			for (info &x : a)
				x = mr(e[y], x);
			a.insert(a.begin(), emptyinfo);
			lson[x] = merge(lson[x], a, 1);
		}

	vector<int> a;
	vector<vector<info>> b;
	for (int x = i; x; x = son[x])
		a.push_back(x), b.push_back(lson[x]), top[x] = i;
	dp[i] = merge(a, b);
}

void dfs3(int i, vector<info> v);

vector<info> tmp[N];

struct sgt{
	vector<int> rh, a;
	vector<vector<info>> vl, vr;

	void init(int n) { vl.resize(n * 4), vr.resize(n * 4), rh.resize(n * 4), a.resize(n); }

	void build(int i, int l, int r, vector<info> fl, vector<info> fr) {
		static vector<info> val[N];
		if (l == r) {
			int x = a[l], len = lh[x] + 3;
			if (len < (int)fl.size())
				fl.resize(len);
			if (len < (int)fr.size())
				fr.resize(len);
			vector<info> f = merge(fl, fr, 1);
			vl[i] = f;
			if ((int)f.size() < len) {
				if (f.empty())
					f.resize(len, emptyinfo);
				else
					f.resize(len, f.back());
			}
			for (int j = 0; j != (int)to[x].size(); j++) {
				int y = to[x][j];
				tmp[y] = dp[y];
				for (info &z : tmp[y])
					z = mr(e[y], z);
				tmp[y].insert(tmp[y].begin(), emptyinfo);
				val[j + 1] = merge(val[j], tmp[y], 1);
			}
			for (int j = to[x].size() - 1; j != -1; j--) {
				int y = to[x][j];
				vector<info> g = merge(f, val[j], 1), tp = tmp[y];
				for (info &z : g)
					z = mr(e[y], z);
				g.insert(g.begin(), emptyinfo);
				tmp[y] = g, f = merge(f, tp, 0);
			}
			return;
		}

		int mid = (l + r) >> 1;
		for (int j = mid + 1; j <= r; j++)
			rh[i] = max(rh[i], j + lh[a[j]]);
		rh[i] += 1;
		int ll = rh[i] - l + mid - l;
		int rl = rh[i] - mid;
		for (int j = l; j <= mid; j++)
			rl = max(rl, lh[a[j]] - (mid - j) + 1);
		int tp = ll - (mid - l);
		vector<info> ttl = fl, ttr = fr;
		if (tp < (int)fl.size())
			fl.resize(tp + 1);
		tp = max(0, rl - (r - mid) + 1);
		if (tp < (int)fr.size())
			fr.resize(tp + 1);

		vector<int> al(mid - l + 1), ar(r - mid);
		vector<vector<info>> bl(mid - l + 1), br(r - mid);
		for (int j = mid; j >= l; j--) {
			al[mid - j] = a[j];
			bl[mid - j] = lson[a[j]];
		}
		bl[mid - l] = merge(bl[mid - l], fl, 1);

		for (int j = mid + 1; j <= r; j++) {
			ar[j - mid - 1] = a[j];
			br[j - mid - 1] = lson[a[j]];
		}
		br[r - mid - 1] = merge(br[r - mid - 1], fr, 1);

		vl[i] = merge(al, bl, ll), vr[i] = merge(ar, br, rl);
		for (info &x : vl[i])
			x = mr(e[a[mid + 1]], x);
		vl[i].insert(vl[i].begin(), emptyinfo);

		vector<info> tr = vr[i];
		for (info &x : tr)
			x = mr(e[a[mid + 1]], x);
		tr.insert(tr.begin(), emptyinfo);
		build(i << 1, l, mid, ttl, tr);
		build(i << 1 | 1, mid + 1, r, vl[i], ttr);
	}

	pair<info, bool> query(int i, int l, int r, int x, int d) {
		if (l == r) {
			if (d <= lh[a[x]] + 1)
				return {mr(getv(vl[i], d), getv(lson[a[x]], d)), 1};
			return {emptyinfo, 0};
		}

		int mid = (l + r) >> 1;
		if (x > mid)
			return query(i << 1 | 1, mid + 1, r, x, d);
		pair<info, bool> tp = query(i << 1, l, mid, x, d);
		if (tp.second)
			return tp;
		if (x + d > rh[i])
			return {emptyinfo, 0};
		return {mr(getv(vl[i], d + mid - x + 1), getv(vr[i], x + d - mid - 1)), 1};
	}

	info query(int x, int d) { return query(1, 0, a.size() - 1, x, d).first; }
}seg[N];

void dfs3(int i, vector<info> v) {
	int l = h[i] + 1;
	mp[i] = ++tot;
	seg[tot].init(l);
	for (int x = i; x; x = son[x])
		seg[tot].a[h[i] - h[x]] = x;
	seg[tot].build(1, 0, h[i], v, vector<info>{emptyinfo});
	for (int x = i; x; x = son[x])
		for (int y : to[x])
			dfs3(y, tmp[y]);
}

void init(int t, int n, int q, vector<int> ff, vector<info> ee, int limit) {
	for (int i = 2; i <= n; i++) {
		fa[i][0] = ff[i - 2], e[i] = ee[i - 2];
		to[ff[i - 2]].push_back(i);
		for (int j = 1; fa[fa[i][j - 1]][j - 1]; j++)
			fa[i][j] = fa[fa[i][j - 1]][j - 1];
	}

	dfs1(1), dfs2(1);
	dfs3(1, vector<info>{emptyinfo});
}

info ask(int u, int d) {
	for (int i = 17; i != -1; i--) {
		int j = fa[u][i];
		if (!j)
			continue;
		if (h[j] + 1 < d - (1 << i)) {
			u = fa[u][i];
			d -= 1 << i;
		}
	}
	if (fa[u][0] && h[u] + 1 < d)
		d--, u = fa[u][0];
	if (u == 1)
		return getv(dp[1], d);

	return seg[mp[top[u]]].query(h[top[u]] - h[u], d);
}
```

---

## 作者：_Ch1F4N_ (赞：4)

感谢这道题，让我对静态 Top tree 的理解又上一层楼。

首先我们建立出静态 Top tree。

# 如何建立

首先按全局平衡二叉树的方法对原树划分，然后轻儿子先把所有簇收缩后 rake 到虚父亲上，对于一条轻儿子全部 rake 完成的重链再用全局平衡二叉树对重链的划分方式把重链上所有边 compress 成一条然后向上递归。

不过对于有多个轻儿子的点显然是有问题的。所以对于多个轻儿子在按照重量选取带权中点，每次按照中点分治，两个分治区间内的轻儿子 rake 成一条，最后再和重儿子 rake 到一起，还是重量平衡的，所以树高 $O(\log n)$。

# 如何维护信息

找到最大的被给定邻域覆盖的簇，它的自己被完全覆盖，提示我们可以处理出每个邻域的信息，而由于它的父亲没有被完全覆盖，所以 $d < sz_{fa}$，并且在这个簇外的邻域形如以界点为根的子树中深度不超过 $d - dis_{u,v}$ 的所有点的深度信息，而这个深度显然小于 $sz_{fa}$，并且对于一个父亲簇需要处理的界点只有 $4$ 个，而 Top tree 的树高为 $\log n$ 代表其子树大小和为 $O(n \log n)$ 级别。总之，如果我们有办法求出这 $O(n \log n)$ 个信息，就有可能做到快速合并。

由于状态总量很少，考虑 dp。

我们定义 $dp_{u,0/1,i}$ 表示簇 $u$ 的上界点与下界点在其簇内的 $i$ 邻域信息，显然有 $i \leq sz_u$，所以在构建 Top tree 时可以在 rake 与 compress 时暴力合并，总合并量级还是 $O(n \log n)$ 的。同时在这个过程中顺便维护出每个簇所有边集与以其两个界点为点集的信息，

然后考虑换根 dp。

定义 $g_{u,0/1,i}$ 表示簇 $u$ 的上界点与下界点在簇外的 $i$ 邻域信息，我们在知道 $g_{u,0/1,i}$ 与 $f_{ls_{u},0/1.i}$ 后可以 $O(sz_{u})$ 地求出 $g_{u,0/1,i}$ 这个状态数位 $O(sz_u)$ 个的 dp 数组。那么便从上到下的 dp 求解出所有 $g_{u,0/1,i}$。

# 一些细节

1. 对于 $f_{u,0/1,i}$ 而言若这个邻域包含另一个界点那么代表信息的点集即为两个界点，否则只包含以其为邻域中心的那个界点，对于 $g_{u,0/1,i}$ 而言所有的状态代表的信息的点集都只包含以其为邻域中心的那个界点。

2. 不难发现按照上面的做法一个询问实际上要合并两次，但是我们发现 $g_{u,1,i}$ 总是会与簇 $u$ 内所有边集代表的信息合并，所以可以在预处理时提前合并。

3. 实际上两个 dp 数组都没有必要维护到子树大小，维护到直径即可，但是可能会出现一个邻域覆盖整棵树的情况，所以根簇的直径设置为 $n$ 即可。

# 代码与转移方程

转移方程通过 compress 与 rake 的过程推导出，具体可见代码。

```cpp
#ifndef CIRCLE_H
#define CIRCLE_H
#include<vector>
struct info{
  unsigned val;
  unsigned poi[2];
};
const info emptyinfo=info{0,(unsigned)-1,(unsigned)-1};
info MR(info a,info b);
info MC(info a,info b);
void init(int T,int n,int q,std::vector<int>dad,std::vector<info>ve,int M);
bool isempty(info a);
info ask(int x,int d);
#endif
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5+114;
vector<int> E[maxn];
info edge[maxn];//点 i 到其父亲的信息
struct node{
	int u,v,id,dis;//包括界点
	int len,maxu,maxv;//维护直径
	vector<info> fu,fv,gu,gv;//子树内距离两个界点 k 邻域信息/子树外距离两个界点 k 邻域信息 第一个处理到自己簇大小 第二个处理到父亲簇大小
	info all;//整个簇的信息
 	char type;
	//u 在上面 v 在下面
}cluster[maxn];
int pos[maxn],fa[maxn],ls[maxn],rs[maxn];//pos 表示每个点所在的最小簇
char type[maxn];//P 是边点 C 是 compress 点 R 是 rake 点
int root=1;//根簇
info R(info a,info b){
    if(isempty(a)==true) return b;
    if(isempty(b)==true) return a;
    return MR(a,b);
}
info C(info a,info b){
    if(isempty(a)==true) return b;
    if(isempty(b)==true) return a;
    return MC(a,b);
}
info queryf(node &u,int p,char type){
    if(p>=(int)u.fu.size()) p=(int)u.fu.size()-1;
    if(p<0) return emptyinfo;
    else return (type=='u'?u.fu[p]:u.fv[p]);
}
info queryg(node &u,int p,char type){
    if(p>=(int)u.gu.size()) p=(int)u.gu.size()-1;
    if(p<0) return emptyinfo;
    else return (type=='u'?u.gu[p]:u.gv[p]);
}
void compress(node &x,node &y,node &w){
	//x 在上面 y 在下面
	w.u=x.u,w.v=y.v;
    w.len=max(max(x.len,y.len),x.maxv+y.maxu);
    w.maxu=max(x.maxu,x.dis+y.maxu);
    w.maxv=max(y.maxv,y.dis+x.maxv);
    w.dis=x.dis+y.dis;
    w.all=C(x.all,y.all);
    w.fu.push_back(emptyinfo);
    w.fv.push_back(emptyinfo);
    for(int i=1;i<=w.len;i++){
        w.fu.push_back(C(queryf(x,i,'u'),queryf(y,i-x.dis,'u')));
        w.fv.push_back(C(queryf(x,i-y.dis,'v'),queryf(y,i,'v')));
    }
	fa[x.id]=fa[y.id]=w.id;
	ls[w.id]=x.id;
	rs[w.id]=y.id;
	w.type='C';
	root=w.id;
}
void rake(node &x,node &y,node &w){
	//把 x rake 到 y 上
	w.u=y.u,w.v=y.v;
	w.len=max(max(x.len,y.len),y.maxu+x.maxu);
    w.maxu=max(x.maxu,y.maxu);
    w.maxv=max(y.maxv,x.maxu+y.dis);
	w.dis=y.dis;
	w.all=R(y.all,x.all);
	w.fu.push_back(emptyinfo);
	w.fv.push_back(emptyinfo);
	for(int i=1;i<=w.len;i++){
        w.fu.push_back(R(queryf(y,i,'u'),queryf(x,i,'u')));
        w.fv.push_back(R(queryf(y,i,'v'),queryf(x,i-y.dis,'u')));
    }
	fa[x.id]=fa[y.id]=w.id;
	ls[w.id]=x.id;
	rs[w.id]=y.id;
	w.type='R';
	root=w.id;
}
int father_pos[maxn];//一个点到其父亲的边的簇编号
int father[maxn];
int son[maxn],sz[maxn],tot,dep[maxn];
int top[maxn];
vector<int> st[maxn];//重链上的点存到链顶
void dfs1(int u){
	sz[u]=1;
	for(int v:E[u]){
        dep[v]=dep[u]+1;
        father[v]=u;
		father_pos[v]=++tot;
		pos[u]=pos[v]=tot;
		cluster[tot].u=u,cluster[tot].v=v,cluster[tot].id=tot,cluster[tot].dis=1,cluster[tot].len=1,cluster[tot].maxu=1,cluster[tot].maxv=1,cluster[tot].all=edge[v],cluster[tot].fu.push_back(emptyinfo),cluster[tot].fu.push_back(edge[v]),cluster[tot].fv.push_back(emptyinfo),cluster[tot].fv.push_back(edge[v]);
		dfs1(v);
		if(sz[v]>sz[son[u]]) son[u]=v;
		sz[u]+=sz[v];
	}
}
void dfs2(int u,int tp){
    top[u]=tp;
	st[tp].push_back(u);
	if(son[u]!=0) dfs2(son[u],tp);
	for(int v:E[u]){
		if(v==son[u]) continue;
		dfs2(v,v);
	}
}
int LCA(int u,int v){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        u=father[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    return v;
}
int dis(int u,int v){
    return dep[u]+dep[v]-2*dep[LCA(u,v)];
}
vector<int> vec[maxn];
vector<int> pre[maxn];
int solve(int l,int r,int u){
	if(l==r) return father_pos[vec[u][l]];
	int L=l,R=r;
	while(L+1<R){
		int mid=(L+R)>>1;
		if((pre[u][mid]-pre[u][l-1])*2<=(pre[u][r]-pre[u][l-1])) L=mid;
		else R=mid;
	}
	int mid=L;
	int lson=solve(l,mid,u);
	int rson=solve(mid+1,r,u);
	int res=++tot;
	cluster[tot].id=tot;
	rake(cluster[lson],cluster[rson],cluster[res]);
	return res;
}
int calc(int l,int r,int u){
    if(l==r) return father_pos[vec[u][l]];
	int L=l,R=r;
	while(L+1<R){
		int mid=(L+R)>>1;
		if((pre[u][mid]-pre[u][l-1])*2<=(pre[u][r]-pre[u][l-1])) L=mid;
		else R=mid;
	}
	int mid=L;
	int lson=calc(l,mid,u);
	int rson=calc(mid+1,r,u);
	int res=++tot;
    cluster[tot].id=tot;
	compress(cluster[lson],cluster[rson],cluster[res]);
	return res;
}
void dfs3(int u){
	for(int x:st[u]){
        if(son[x]==0) continue;
		pre[x].push_back(0);
		vec[x].push_back(0);
		for(int v:E[x]){
			if(v!=son[x]){
				dfs3(v);
				//收缩 (x,v) 一个簇
				vec[x].push_back(v);
			}
		}
		//在对这些轻儿子簇按中点分治的方法合并起来
		for(int i=1;i<=(int)vec[x].size()-1;i++){
			pre[x].push_back(pre[x][i-1]+sz[vec[x][i]]);
		}
		if(vec[x].size()>=2){
            int rt=solve(1,(int)vec[x].size()-1,x);
            if(rt!=0){
                tot++;
                cluster[tot].id=tot;
                rake(cluster[rt],cluster[father_pos[son[x]]],cluster[tot]);
                father_pos[son[x]]=tot;//rake 到重链上
            }
		}
	}
	vec[u].clear();
	pre[u].clear();
	pre[u].push_back(0);
	vec[u].push_back(0);
	for(int x:st[u]){
		vec[u].push_back(x);
	}
	for(int i=1;i<=(int)vec[u].size()-1;i++){
		pre[u].push_back(pre[u][i-1]+sz[father[vec[u][i]]]-sz[vec[u][i]]);
	}
	if(u!=1) father_pos[u]=calc(1,(int)vec[u].size()-1,u);//把重链上的边 compress 成一条
	else father_pos[u]=calc(2,(int)vec[u].size()-1,u);
	E[u].clear();
	E[u].push_back(father[u]);
	return ;
}
void DP(int u){
    if(ls[u]==0) return ;
    if(cluster[u].type=='C'){
        cluster[ls[u]].gu.push_back(emptyinfo);
        cluster[ls[u]].gv.push_back(emptyinfo);
        for(int i=1;i<=cluster[u].len;i++) cluster[ls[u]].gu.push_back(queryg(cluster[u],i,'u')),cluster[ls[u]].gv.push_back(C(queryf(cluster[rs[u]],i,'u'),queryg(cluster[u],i-cluster[rs[u]].dis,'v')));
        cluster[rs[u]].gu.push_back(emptyinfo);
        cluster[rs[u]].gv.push_back(emptyinfo);
        for(int i=1;i<=cluster[u].len;i++) cluster[rs[u]].gu.push_back(C(queryf(cluster[ls[u]],i,'v'),queryg(cluster[u],i-cluster[ls[u]].dis,'u'))),cluster[rs[u]].gv.push_back(queryg(cluster[u],i,'v'));
    }else{
        cluster[ls[u]].gu.push_back(emptyinfo);
        cluster[ls[u]].gv.push_back(emptyinfo);
        for(int i=1;i<=cluster[u].len;i++) cluster[ls[u]].gu.push_back(R(queryg(cluster[u],i,'u'),C(queryf(cluster[rs[u]],i,'u'),queryg(cluster[u],i-cluster[rs[u]].dis,'v')))),cluster[ls[u]].gv.push_back(emptyinfo);
        cluster[rs[u]].gu.push_back(emptyinfo);
        cluster[rs[u]].gv.push_back(emptyinfo);
        for(int i=1;i<=cluster[u].len;i++) cluster[rs[u]].gu.push_back(R(queryg(cluster[u],i,'u'),queryf(cluster[ls[u]],i,'u'))),cluster[rs[u]].gv.push_back(queryg(cluster[u],i,'v'));
    }
    DP(ls[u]);
    DP(rs[u]);
    //默认将界点 u 的簇外信息合并上自己簇的信息
    for(int i=0;i<=cluster[u].len;i++){
        cluster[ls[u]].gu[i]=C(cluster[ls[u]].gu[i],cluster[ls[u]].all);
        cluster[rs[u]].gu[i]=C(cluster[rs[u]].gu[i],cluster[rs[u]].all);
    }
}//Top tree 上换根 dp
char check(node &u,int p){
    if(p==u.u) return 'u';
    else return 'v';
}
info ask(int u, int d){
    if(d==0) return emptyinfo;
    int now=pos[u];
    while(cluster[fa[now]].len<d) now=fa[now];
    return C(queryg(cluster[now],d-dis(cluster[now].u,u),'u'),queryg(cluster[now],d-dis(cluster[now].v,u),'v'));
}
void init(int T, int n, int q, vector<int> FA, vector<info> e, int M){
    for(int i=1;i<n;i++){
        E[FA[i-1]].push_back(i+1);
        edge[i+1]=e[i-1];
    }
    dfs1(1);
    dfs2(1,1);
    dfs3(1);
    DP(root);
    cluster[root].len=n;
    return ;
}
```

---

## 作者：AtomAlpaca (赞：3)

## 题意

给你一棵树，边上有信息，提供两种合并方式（其实就是 Top Tree 那套理论里的 compress 和 rake）。

![](https://img.uoj.ac/user/negiizhao/basic.png)

合并两个信息需要通过调用交互库来实现。你可以用不超过 $3\times 10^7$ 次操作进行预处理，每次不超过 $1$ 次操作回答节点 $u$ 的 $d$-邻域信息并。

[详情请咨询](https://www.luogu.com.cn/problem/P8498)

## 题解

考虑建一棵静态 Top Tree 出来。

一个建法是对原树进行树剖，然后考虑每一条重链，对于这条重链上的每一个点，递归处理所有轻儿子把它们的子树缩成一个簇，然后对这些轻儿子簇和这一个节点和它重儿子连成的边形成的那一个簇进行合并。

大概过程就是类似全局平衡二叉树，对于这一排簇，每次以簇的大小为权值找到带权中点，然后把两边分别递归处理，然后再用 $\operatorname {rake}$ 合并起来。

这样我们就把一个点所有轻儿子的簇 $\operatorname {rake}$ 到了重儿子那个簇上。然后我们每条重链就只剩下一条链了，这时我们再重复上述步骤把它分治地 $\operatorname {compress}$ 成一个簇即可。

然后对于三个簇 $a, b, c$，如果 $a$ 是 $b, c\operatorname {rake}$ 或者 $\operatorname {compress}$ 来的，那么我们就把 $a$ 和 $b, c$ 连边，这样形成的就是一棵 Top Tree，并且我们能保证这棵树的树高是 $O(\log n)$ 的。

我们令 $ln_x$ 为一个簇的两个端点的距离，$len_x$ 是簇的直径。然后规定每个簇两个顶点有“上下”之分，两个簇能 $\operatorname {rake}$ 当且仅当它们的上界点相同，能 $\operatorname {compress}$ 当且仅当一个簇的下界点和另一个的上界点相同。可以结合上面的图和题面理解这个约定。

然后我们考虑维护 $f_{x, 0/1, d}$ 是树簇 $x$ 的上/下界点在该树簇内的 $d$-邻域的信息，$g_{x, 0/1, d}$ 是树簇 $x$ 的上/下界点在该树簇外的 $d$-邻域的信息。维护的时候我们对这个簇是 $\operatorname {rake}$ 还是 $\operatorname {compress}$ 得到的进行讨论。当这个点是 $\operatorname {rake}$ 得到的时，有：

$$
\begin{aligned}
f_{u, 0, i} &= \operatorname{rake}(f_{ls_u, 0, i}, f_{rs_u, 0, i}) \\
f_{u, 1, i} &= \operatorname{rake}(f_{ls_u, 1, i}, f_{rs_u, 0, i - ln_u}) \\
g_{ls_u, 0, i} &= \operatorname{rake} (f_{rs_u, 0, i}, g_{u, 0, i})\\
g_{ls_u, 1, i} &= g_{u, 1, i}\\
g_{rs_u, 0, i} &= \operatorname{rake}(\operatorname{compress}(f_{ls_u, 0, i}, g_{ls_u, 1, i - ln_{ls_u}}), g_{u, 0, i})\\
g_{rs_u, 1, i} &= \epsilon
\end{aligned}
$$

否则
$$
\begin{aligned}
f_{u, 0, i} &= \operatorname{compress}(f_{ls_u, 0, i}, f_{rs_u, 0, i - ln_{ls_u}})\\
f_{u, 1, i} &= \operatorname{compress}(f_{ls_u, 1, i - ln_{rs_u}}, f_{rs_u, 1, i})\\
g_{ls_u, 0, i} &= g_{u, 0, i} \\
g_{ls_u, 1, i} &= \operatorname{compress}(g_{u, 1, i - ln_{rs_u}}), f_{rs_u, 0, i})\\
g_{rs_u, 0, i} &= \operatorname{compress}(g_{u, 0, i - ln_{ls_u}}, f_{ls_u, 1, i})\\
g_{rs_u, 1, i} &= g_{u, 1, i}\\
\end{aligned}
$$

具体式子怎么推出来的，其实在上面的图上把式子代表的范围圈出来就能感性地看出来要合并哪些信息了。举个例子：
![](https://cdn.luogu.com.cn/upload/image_hosting/3kt4lv23.png)

比如芝士 $f_{x, 0, d}$，不难发现就是 $f_{ls_x, 0, d}$ 和 $f_{rs_x, 0, d}$ 并起来。

然后 $f$ 是依赖儿子的，而 $g$ 是依赖父亲和 $f$ 的，所有需要分两次求。

考虑我们怎么进行查询。首先我们找到包含这个点的一个最小簇，然后不断往上跳直到最后一个的直径小于 $d$ 的簇。由于树高是 $O(\log n)$ 的所以复杂度是有保证的。

这时我们的答案分为了簇内的所有信息，和两个簇端点外面一段距离的信息的并。形式化地说是 $\operatorname{compress}(\operatorname{compress}(g_{x, 0, d - dis(u_x, u)}, f_{x, 0, len_x}), g_{x, 1, d - dis(v_x, u)})$ 这样。

但是这样每次查询我们都需要进行两次合并，这是过不了最后一个测试点的。然后我们发现查询答案的时候 $g_{x, 0, d - dis(u_x, u)}, f_{x, 0, len_x}$ 这两个信息一定会被合并，所有我们可以提前把所有的后者和合并到前者上，从而将合并次数减少到一次。

然后为了减少操作次数，如果合并的信息两者中有 $\epsilon$ 就直接返回另一个元素；对于每个簇的信息我们第三维只维护到簇的直径。

## 代码

```c++
#include <bits/stdc++.h>
#include "count.h"

typedef info I;

const int MAX = 5e5 + 5;
const int RAKE = 1;

int n, cnt, top, rt, tot;
int h[MAX], st[MAX], dep[MAX], fa[MAX], _fa[MAX], siz[MAX], sz[MAX], son[MAX], U[MAX], V[MAX], ls[MAX], rs[MAX], ln[MAX], typ[MAX], lm[MAX], rm[MAX], mx[MAX];
int fth[MAX][25];
std::vector <I> f[MAX][2], g[MAX][2];

struct E { int v, x; } e[MAX << 2];
void add(int u, int v) { e[++tot] = {v, h[u]}; h[u] = tot; }

inline I R(I a, I b)
{
	if (isempty(a)) { return b; }
	if (isempty(b)) { return a; }
	return MR(a, b);
}

inline I C(I a, I b)
{
	if (isempty(a)) { return b; }
	if (isempty(b)) { return a; }
	return MC(a, b);
}

inline int lca(int u, int v)
{
	if (dep[u] < dep[v]) { std::swap(u, v); }
	for (int i = 20; i >= 0; --i) { if (dep[fth[u][i]] >= dep[v]) { u = fth[u][i]; } }
	if (u == v) { return u; }
	for (int i = 20; i >= 0; --i) { if (fth[u][i] != fth[v][i]) { u = fth[u][i]; v = fth[v][i]; } }
	return fth[u][0];
}

inline int dis(int u, int v) { return dep[u] + dep[v] - 2 * dep[lca(u, v)]; }

inline I F(int u, int t, int k)
{
	if (k < 0) { return emptyinfo; }
	if (k >= f[u][t].size()) { return f[u][t].back(); }
	return f[u][t][k];
}

inline I G(int u, int t, int k)
{
	if (k < 0) { return emptyinfo; }
	if (k >= g[u][t].size()) { return g[u][t].back(); }
	return g[u][t][k];
}

void dfs0(int u)
{
	siz[u] = 1; dep[u] = dep[fa[u]] + 1; fth[u][0] = fa[u];
	for (int i = 1; i <= 20; ++i) { fth[u][i] = fth[fth[u][i - 1]][i - 1]; }
	for (int i = h[u]; i; i = e[i].x)
	{
		int v = e[i].v; dfs0(v);
		if (siz[v] > siz[son[u]]) { son[u] = v; } siz[u] += siz[v];
	}
}

void initf(int u)
{
	_fa[ls[u]] = _fa[rs[u]] = u; sz[u] = sz[ls[u]] + sz[rs[u]];
	if (typ[u] == RAKE)
	{
		mx[u] = std::max(lm[ls[u]] + lm[rs[u]], std::max(mx[ls[u]], mx[rs[u]]));
		lm[u] = std::max(lm[ls[u]], lm[rs[u]]);
		rm[u] = std::max(rm[ls[u]], ln[ls[u]] + lm[rs[u]]);
		ln[u] = ln[ls[u]]; U[u] = U[ls[u]]; V[u] = V[ls[u]];
		f[u][0].resize(mx[u] + 1); f[u][1].resize(mx[u] + 1);
		for (int i = 0; i <= mx[u]; ++i)
		{
			f[u][0][i] = R(F(ls[u], 0, i), F(rs[u], 0, i));
			f[u][1][i] = R(F(ls[u], 1, i), F(rs[u], 0, i - ln[u]));
		}
	}
	else
	{
		mx[u] = std::max(rm[ls[u]] + lm[rs[u]], std::max(mx[ls[u]], mx[rs[u]]));
		lm[u] = std::max(lm[ls[u]], ln[ls[u]] + lm[rs[u]]);
		rm[u] = std::max(rm[rs[u]], ln[rs[u]] + rm[ls[u]]);
		ln[u] = ln[ls[u]] + ln[rs[u]]; U[u] = U[ls[u]]; V[u] = V[rs[u]];
		f[u][0].resize(mx[u] + 1); f[u][1].resize(mx[u] + 1);
		for (int i = 0; i <= mx[u]; ++i)
		{
			f[u][0][i] = C(F(ls[u], 0, i), F(rs[u], 0, i - ln[ls[u]]));
			f[u][1][i] = C(F(ls[u], 1, i - ln[rs[u]]), F(rs[u], 1, i));
		}
	}
}

int build(int l, int r, int k)
{
	if (l == r) { return st[l]; }
	int sm = 0, p = l, u = ++cnt, now = 0; typ[u] = k;
	for (int i = l; i <= r; ++i) { sm += sz[st[i]]; }
	while (p < r - 1 and (now + sz[st[p]]) * 2 <= sm) { now += sz[st[p++]]; }
	ls[u] = build(l, p, k); rs[u] = build(p + 1, r, k);
	initf(u); return u;
}

void dfs1(int u)
{
	int tp = top + 1, v = u, rt; if (u != 1) { st[++top] = u; }
	for (; son[v]; v = son[v])
	{
		st[rt = ++top] = son[v];
		for (int i = h[v]; i; i = e[i].x)
		{
			int k = e[i].v;
			if (k != son[v]) { dfs1(k); }
		}
		int tmp = build(rt, top, RAKE);
		st[top = rt] = tmp;
	}
	int tmp = build(tp, top, 0); st[top = tp] = tmp;
}

void initg(int u)
{
	if (typ[u] == RAKE)
	{
		g[ls[u]][0].resize(mx[u] + 1); g[ls[u]][1].resize(mx[u] + 1);
		g[rs[u]][0].resize(mx[u] + 1); g[rs[u]][1] = {emptyinfo};
		for (int i = 0; i <= mx[u]; ++i)
		{
			g[ls[u]][0][i] = R(F(rs[u], 0, i), G(u, 0, i));
			g[ls[u]][1][i] = G(u, 1, i);
			g[rs[u]][0][i] = R(C(F(ls[u], 0, i), G(ls[u], 1, i - ln[ls[u]])), G(u, 0, i));
		}
	}
	else
	{
		g[ls[u]][0].resize(mx[u] + 1); g[ls[u]][1].resize(mx[u] + 1);
		g[rs[u]][0].resize(mx[u] + 1); g[rs[u]][1].resize(mx[u] + 1);
		for (int i = 0; i <= mx[u]; ++i)
		{
			g[ls[u]][0][i] = G(u, 0, i);
			g[ls[u]][1][i] = C(G(u, 1, i - ln[rs[u]]), F(rs[u], 0, i));
			g[rs[u]][0][i] = C(G(u, 0, i - ln[ls[u]]), F(ls[u], 1, i));
			g[rs[u]][1][i] = G(u, 1, i);
		}
	}
}

void dfs2(int u) { if (u <= n) { return ; } initg(u); dfs2(ls[u]); dfs2(rs[u]); }

void init(int _T, int _n, int _q, std::vector<int> _fa, std::vector<info> _e, int _M)
{
	cnt = n = _n;
	for (int i = 0; i < n - 1; ++i)
	{
		fa[i + 2] = _fa[i]; add(_fa[i], i + 2);
		U[i + 2] = fa[i + 2]; V[i + 2] = i + 2;
		lm[i + 2] = rm[i + 2] = mx[i + 2] = ln[i + 2] = sz[i + 2] = 1;
		f[i + 2][0] = f[i + 2][1] = {emptyinfo, _e[i]};
	}
	dfs0(1); dfs1(1);
	rt = st[1]; g[rt][0] = g[rt][1] = {emptyinfo};
	dfs2(rt);
	for (int i = 2; i <= cnt; ++i)
	{
		for (I & j : g[i][0]) { j = C(j, f[i][0].back()); }
	}
}

I ask(int u, int d)
{
	int p = u; if (p == 1) { p = 2; }
	while (mx[_fa[p]] <= d and _fa[p]) { p = _fa[p]; }
	return C(G(p, 0, d - dis(u, U[p])), G(p, 1, d - dis(u, V[p])));
}

```

---

## 作者：feecle6418 (赞：1)

考虑建 toptree。建法和全局平衡二叉树一样，就是轻儿子 rake 二叉树，重链 compress 二叉树。注意两棵二叉树都要重量平衡。

然后，设 $f(i,0/1,d)$ 表示 $i$ 的子簇，到左边 / 右边的界点，$d$-邻域的信息，$g(...)$ 表示 $i$ 的子簇外，到左边 / 右边的界点，$d$-邻域的信息，在 toptree 上做换根 dp 即可。注意设计一下转移顺序，使得 $f,g$ 的值的界点恰好包含了子簇的某个界点。最终回答询问 $(x,d)$，就倍增找到 $x$ 最浅的祖先使得簇大小 $\le d$，只要换根 dp 的第三维维护到 $fa_i$ 的簇大小，就可以每次询问两次合并解决问题，预处理其中一次即可一次合并。

其实没有任何细节，但是写起来就很难受。

说句闲话，这题好 educational 阿。说不定之后会成为 toptree 入门经典题？

参考实现：https://uoj.ac/submission/582922

---


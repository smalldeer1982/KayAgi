# [NOI2022] 二次整数规划问题

## 题目描述

本题中，你需要解决一个著名的 NP 问题——二次整数规划问题。

二次整数规划问题要有变量：你需要给出一个长度为 $n$ 的**整数**序列 $(x_1, x_2, \ldots, x_n)$，满足下文中的所有条件。

二次整数规划问题要有约束：你给出的整数序列需要满足以下两类约束：

1. 一类约束是单个变量取值的约束：给出正整数 $k$（$3 \leq k \leq 5$）和 $n$ 个区间 $[l_i, r_i]$（$1 \leq i \leq n$），其中 $1 \leq l_i \leq r_i \leq k$，你给出的序列需要满足 $\forall 1 \leq i \leq n$，$l_i \leq x_i \leq r_i$；
2. 另一类约束是变量之间取值的约束：给出 $m$ 个三元组 $(p_i, q_i, b_i)$，你给出的序列需要满足 $\forall 1 \leq j \leq m$，$\lvert x_{p_j} - x_{q_j} \rvert \leq b_j$。

二次整数规划问题要有目标函数：在给出 $k-2$ 个目标参数 $v_2,v_3,\dots,v_{k-1}$（**注意下标范围为 $\boldsymbol{2}$ 至 $\boldsymbol{k-1}$**）的前提下，对于一个值域为 $[1,k]$ 的整数数列 $\{p_1,p_2,\dots,p_n\}$，设 $c_i$ 为该序列中取值为 $i$ 的元素个数，$G$ 为满足 $1 \leq i,j \leq n$ 且 $|p_i-p_j|\leq 1$ 的整数二元组 $(i, j)$ 个数，**注意当 $\boldsymbol{i \neq j}$ 时，$\boldsymbol{(i, j)}$ 与 $\boldsymbol{(j, i)}$ 是不同的二元组**。定义该序列的**权值**为

$$ W(p_1, p_2, \ldots, p_n) = 10^6 G+\sum_{i=2}^{k-1} c_i v_i \text{。} $$

你的序列需要在满足以上两类约束的情况下，最大化其权值。在给出的约束下，保证存在满足约束的序列。

二次整数规划问题不一定要有多组询问，但是我们会给出 $q$ 次询问，每次询问给出不同的权值参数 $v_2, v_3, \ldots, v_{k-1}$，对于每组询问你需要找到满足约束的最大化权值的序列。为了减少输出量，你只需要输出这个序列的权值。

## 说明/提示

**【样例 \#1】**

见附件中的 `qip/qip1.in` 与 `qip/qip1.ans`。

该样例满足数据范围中测试点 $1$ 的性质。

----

**【样例解释 \#1】**

第一个测试数据中两组询问对应的最优序列均为 $(1, 2, 2, 1, 3)$，有 $c_2 = 2, G = 21$。

----

**【样例 \#2】**

见附件中的 `qip/qip2.in` 与 `qip/qip2.ans`。

该样例满足数据范围中测试点 $3$ 的性质。

----

**【样例解释 \#2】**

第一个测试数据中两组询问对应的最优序列分别为 $(4,4,3,3)$ 和 $(4,3,2,2)$。

----

**【样例 \#3】**

见附件中的 `qip/qip3.in` 与 `qip/qip3.ans`。

该样例满足数据范围中测试点 $5$ 的性质。

----

**【样例解释 \#3】**

第一个测试数据中三组询问对应的一个最优序列分别为 $(3, 3, 3, 3, 3)$、$(2, 2, 3, 3, 2)$ 和 $(3, 2, 4, 4, 2)$。

----

**【样例 \#4】**

见附件中的 `qip/qip4.in` 与 `qip/qip4.ans`。

该样例满足数据范围中测试点 $2$ 的性质。

----

**【样例 \#5】**

见附件中的 `qip/qip5.in` 与 `qip/qip5.ans`。

该样例满足数据范围中测试点 $4$ 的性质。

----

**【样例 \#6】**

见附件中的 `qip/qip6.in` 与 `qip/qip6.ans`。

该样例满足数据范围中测试点 $8$ 的性质。

----

**【样例 \#7】**

见附件中的 `qip/qip7.in` 与 `qip/qip7.ans`。

该样例满足数据范围中测试点 $14$ 的性质。

----

**【样例 \#8】**

见附件中的 `qip/qip8.in` 与 `qip/qip8.ans`。

该样例满足数据范围中测试点 $17$ 的性质。

----

**【数据范围】**

设 $\sum q$ 为单个测试点中所有测试数据的 $q$ 的和。对于所有测试点，

- $1 \leq T \leq 600$，
- 第 $i$（$1 \le i \le T$）个测试数据中，$1 \leq n \leq \max(\frac{T}{i},2 \log_2 T)$，
- $3 \leq k \leq 5$，$0 \leq m \leq 3n$，$1 \leq q,\sum q \leq 3 \times 10^5$，
- $1 \leq l_i \leq r_i \leq k$，
- $1 \leq p_j,q_j \leq n$，$0 \leq b_j<k$，
- $0 \leq v_2,\dots,v_{k-1} \leq 10^{12}$。

| 测试点编号 | $T \leq$ | $k=$ | $\sum q \leq$   | 特殊性质         | 测试点分数 |
|:-----:|:--------:|:----:|:---------------:|:------------:|:-----:|
| $1$   | $10$     | $3$  | $200$           | 无            | $4$   |
| $2$   | $600$    | $3$  | $3 \times 10^5$ | 无            | $6$   |
| $3$   | $10$     | $4$  | $200$           | 无            | $4$   |
| $4$   | $600$    | $4$  | $3 \times 10^5$ | 无            | $6$   |
| $5$   | $10$     | $5$  | $300$           | 无            | $5$   |
| $6$   | $15$     | $5$  | $500$           | 无            | $4$   |
| $7$   | $25$     | $5$  | $750$           | 无            | $4$   |
| $8$   | $50$     | $5$  | $1000$          | 无            | $6$   |
| $9$   | $80$     | $5$  | $1500$          | 无            | $6$   |
| $10$  | $120$    | $5$  | $2000$          | 无            | $5$   |
| $11$  | $200$    | $5$  | $8000$          | A | $3$   |
| $12$  | $400$    | $5$  | $3 \times 10^4$ | A | $4$   |
| $13$  | $600$    | $5$  | $2 \times 10^5$ | A | $5$   |
| $14$  | $200$    | $5$  | $8000$          | B | $3$   |
| $15$  | $400$    | $5$  | $3 \times 10^4$ | B | $4$   |
| $16$  | $600$    | $5$  | $2 \times 10^5$ | B | $4$   |
| $17$  | $120$    | $5$  | $10^5$          | C | $4$   |
| $18$  | $150$    | $5$  | $2 \times 10^5$ | C | $5$   |
| $19$  | $180$    | $5$  | $3 \times 10^5$ | C | $5$   |
| $20$  | $300$    | $5$  | $5 \times 10^4$ | 无            | $5$   |
| $21$  | $450$    | $5$  | $10^5$          | 无            | $4$   |
| $22$  | $600$    | $5$  | $3 \times 10^5$ | 无            | $4$   |

特殊性质 A：$m=0$。

特殊性质 B：$m \leq 10$，单个测试点中所有测试数据的 $m$ 的和不超过 $200$。

特殊性质 C：数据随机生成。具体地，生成测试点中每组测试数据时，给出参数 $k,n,m,q$ 以及 $k$ 个非负常数 $p_0,p_1,p_2,\dots,p_{k-1}$，保证 $p_{k-1} \neq 0$，则按照如下规则生成该组数据：

- 对于 $1 \leq i \leq n$，独立均匀生成 $x,y \in [1,k]$，则 $l_i=\min(x,y),r_i=\max(x,y)$；
- 不断按照如下方式生成三元组直至有 $m$ 个三元组：
  1. 独立均匀随机生成 $u,v \in [1,n]$；
  2. 以 $p$ 为权值随机生成 $w$（对于 $0 \leq i \leq k-1$，$w=i$ 的概率为 $\frac{p_i}{p_0+p_1+\dots+p_{k-1}}$）；
  3. 若在原有三元组集合中加入 $(u,v,w)$ 后不存在序列 $(x_1,x_2,\dots,x_n)$ 满足所有限制，则舍弃当前三元组，否则加入当前三元组。
- 每组询问的 $v_2, \ldots, v_{k-1}$ 在 $[0,10^{12}]$ 内独立均匀随机生成。

# 题解

## 作者：Itst (赞：35)

# 解法一

对于每组询问枚举每个 $x_{i}$ 的可能取值并计算答案，复杂度
$O\left( qk^{n} \right)$。该暴力算法有很多优化空间：可以提前将所有搜索结果预处理；在搜索过程中可以进行可行性剪枝；可以将一个序列压缩成一个
$(k - 2)$ 元组 $\left( c_{2},c_{3},\cdots,c_{k - 2} \right)$，这是由于最大化的函数的特殊性，该元组相同的所有序列中只有一个序列可能取到最优解。

# 解法二（k=3）

由于 $v_{2}$ 非负，在不影响其他元素的前提下，将序列中某个元素设为 $2$
总是更优的，因为这样其在目标函数的线性项和二次项上都能获得更大的值。

故考虑处理出必须选择 $1$ 和必须选择 $3$ 的元素集合。此处以必须选择 $1$
的元素为例，3 是类似的。只有以下两种情况之一会让元素 $x_{i}$ 必须取 $1$：

- $r_{i} = 1$；

- 与另一个只能选 $1$ 的元素 $x_{j}$ 有 $\left| x_{i} - x_{j} \right| \leq 0$ 的限制。

按照两个规则搜索或并查集求出只能选 $1$ 的元素。

接下来将说明，对于非必须选择 $1$ 或必须选择 $3$
的元素集合，它们可以同时取到 $2$。考察这样的序列中的所有限制：

对于值域限制而言，由于必须选择 $1$ 和必须选择 $3$
的元素都被排除掉了，剩下的每个元素都必然可以取到 $2$；

对于元素间的限制而言，取 $2$ 的元素两两之间限制总能得到满足；这些元素与必须取
$1$ 或必须取 $3$ 的元素的取值差绝对值为 $1$。唯一不合法的情况是一个取 $2$
的元素和必须取 $1$ 或必须取 $3$ 的元素之间有一个取值小于等于 $0$
的限制，但在这种情况下这个取值为 $2$ 的元素必然分到必须选择 $1$ 或必须选择
$3$ 的元素集合内，产生矛盾。于是所有限制必然都得到满足。

这样就得到了无论 $v_{2}$
取值如何都固定的最优方案，根据这个方案计算每组询问对应的结果即可。复杂度
$O(n + m + q)$。

# 解法三（k=4）

考虑拓展 $k = 3$ 的做法。

**定理 1：对于任意 $k$ 和任意非负的
$\left(k - 2\right)$ 元组
$v_2,\cdots,v_{k-1}$，存在一个最优序列，非必须取
$1$ 或必须取 $k$ 的元素取到 $[2,k-1]$。**

**证明：** 倘若最优方案不满足该性质，考虑将所有非必须取 $1$ 但取到 $1$
的元素改为 $2$，非必须取 $k$ 但取到 $k$ 的元素改为 $k - 1$。与解法二中的证明类似可以证明所有限制都必然得到满足，同时目标函数取值不会变小。

应用*定理 1* 之后，扔掉必须取 $2$ 或必须取 $3$
的元素，只需要对每个变量进行取 $2$ 还是取 $3$ 的抉择。

此时决策区间长度为 $2$，需要决策的元素两两间取值绝对值一定不超过
$1$，因此它们对 $G$
的贡献固定了。不考虑这部分贡献后，待决策的元素产生的贡献是线性的，即对于任意一个元素来说，选
$2$ 对目标函数的影响一致，选 $3$
对目标函数的影响一致。所以只有两种方案：全选择 $2$ 或者全选择 $3$。

对于每组询问在这两种方案里取最大值即可。复杂度
$O(n + m + q)$。

实现中需要注意的是，必须选 $1$ 和必须选 $k$
的元素可能通过变量间限制对其他元素的可取值域区间产生影响，例如必须取 $1$
的元素与一个取值为 $[2,4]$ 的元素之间有一个差的绝对值不超过 $2$
的限制，那么 $4$ 就不能取到。

这种取值端点的变化本质上是一个差分约束问题，可以通过最短路松弛的方式预处理：对于一个限制
$\left| x_{i} - x_{j} \right| \leq b$，将 $x_{j}$ 的取值区间更新为
$\left\lbrack l_{j},r_{j} \right\rbrack \cap \left\lbrack l_{i} - b,r_{i} + b \right\rbrack$，对
$x_{i}$
类似。进行若干次直到任意一个限制不会改变值域区间后，就将元素之间限制产生的值域区间影响都考虑进去了。

在以下算法中我们认为输入数据后均运行了一次该算法。

# 解法三（特殊性质A）

特殊性质 A 满足没有元素之间的限制。运用*定理 1*之后，元素只有三种可能，可选范围分别为
$[2,3]$，$[3,4]$ 和
$[2,4]$。

给出**命题：对于可选范围相同的元素，存在一个最优方案它们选择同一个数。**

**证明：** 若存在某个可选范围，其元素选择了两种不同的值，假设分别为 $a$
和 $b$。设 $\text{va}l_{a,b}$ 表示将一个取值为 $a$ 的元素变为 $b$
之后目标函数的改变量，则通过简单的计算可以得知
$\text{va}l_{a,b} + val_{b,a} \geq 0$。若两者不都为 0，则必然有一个大于
0，故将其中某个取值的一个元素改变为另一个取值更优；若两者都为
0，设定第二关键字为
$\max(a,b)$，则也存在一个改变的方法让第二关键字更优。这样不断进行调整，最终总能调整到
$\min(a,b) = 0$ 的状态。

因此只有 $2\  \times 2\  \times 3 = 12$ 种情况，每次询问计算即可，复杂度
$O(n + m + q)$。实际上情况数还可以继续优化，最少仅有5种。

# 解法四（特殊性质B）

特殊性质 B 中变量之间的限制个数不超过
10。考虑暴力枚举被任何一个变量之间的限制约束的变量的取值，这样有
$3^{2m}$
种可能。但是注意到若将变量之间的限制视作边，则每个连通块之间是独立的，而且在运用*定理 1* 的基础上，可以将每个连通块的方案压缩成二元组
$\left( c_{2},c_{4} \right)$，这是因为 $c_{2} + c_{3} + c_{4}$
是一个固定的取值。这样在 $O\left( 3^{m}m \right)$
的复杂度下可以处理出被限制约束的所有元素取值构成的合法二元组。对于没有限制约束的元素，由特殊性质
A 的分析总共只有 12 种情况。故可以处理出 $O\left( m^{2} \right)$
个二元组，每次询问计算所有二元组中的最优解即可。复杂度
$O\left( n + 3^{m}m + qm^{2} \right)$。

# 解法五（询问次数较少）

运用*定理 1*之后，可以将 $G$ 的贡献视为"每一对二元组之间一个选 $2$
另一个选 $4$，则付出 $10^{6}$
的代价"。将变量之间的限制看作变量之间不满足该性质付出 $+ \infty$
的代价，则它们均可以视作"对应二元组之间其中一个选择小于等于 $v$
的值、另一个选择大于等于 $v + \Delta$
的值后产生一定代价"，其中$\Delta$对于每个限制为常数。这可以使用最小割建模，建模方法可参考
HNOI2013
切糕。对于每一组询问均运行一次最大流即可。

# 解法六（特殊性质 C）

在数据随机时，有用的限制数较少，故猜想可以取到最优解的二元组
$\left( c_{2},c_{4} \right)$
的个数也较少。解法五中，运行一次最小割并计算其割集，可以得到一个可以取到最优解的
$\left( c_{2},c_{4} \right)$。故可以考虑在所有询问之前运行若干次最小割，每次随机选取
$v_{2},v_{3},v_{4}$ 的取值，得到若干 $\left( c_{2},c_{4} \right)$
后去重并以这些二元组作为答案的可行范围。当运行次数在 500
左右时可以在时间限制内以很高概率得到正确结果。

# 解法七

上述部分分做法中不断体现一个思想：与其说我们关注序列每个元素的取值，不如说我们只关心
$\left( c_{2},c_{4} \right)$
这个二元组能取到哪些值，而其中哪些二元组能取到某个询问的最优解。

为考察哪些二元组可以取到某个询问的最优解，对目标函数进行简单的化简。为避免在式子中出现
$n$，考察 $\left( c_{2},c_{4} \right)$ 对应的目标函数取值减去 $(0,0)$
对应的目标函数取值（不管 $(0,0)$ 是否对应一个合法方案）。相比
$(0,0)$，调整 $c_{2}$ 个元素变为 $2$、$c_{4}$ 个元素变为 $4$
产生的目标函数的增量为

$$c_{2}\left( v_{2} - v_{3} + 2 \times 10^{6}c_{1} \right) + c_{4}\left( v_{4} - v_{3} + 2 \times 10^{6}c_{5} \right) - 2 \times 10^{6}c_{2}c_{4}.$$

注意到这里面有 $c_{2}c_{4},c_{2},c_{4}$ 项，故整理为

$$- 2 \times 10^{6}\left( c_{2} - C_{1} \right)\left( c_{4} - C_{2} \right) + C_{3},$$

其中 $C_{1},C_{2},C_{3}$ 为常数。因此最小化
$\left( c_{2} - C_{1} \right)\left( c_{4} - C_{2} \right)$ 的
$\left( c_{2},c_{4} \right)$ 对应了最优解。

然后将二元组 $\left( c_{2},c_{4} \right)$
嵌入到二维平面上，并考察其分布。

设 $\text{min}c_{2}$ 为所有方案中 $c_{2}$ 的最小值（必须选 $2$
的元素数），$\text{max}c_{2}$ 为 $c_{2}$ 的最大值，$c_{4}$
类似，那么有三个点
$\left( \text{min}c_{2},\text{min}c_{4} \right),\left( \text{max}c_{2},\text{min}c_{4} \right),\left( \text{min}c_{2},\text{max}c_{4} \right)$，同时所有点一定在
$\left\lbrack \text{min}c_{2},\text{max}c_{2} \right\rbrack \times \left\lbrack \text{min}c_{4},\text{max}c_{4} \right\rbrack$
内。

求 $\text{max}c_{2}$ 是简单的：将 $\left| x_{i} - x_{j} \right| = 0$
的限制对应的位置都缩在一起，每个缩在一起的部分可以选 $2$ 就选 $2$ 否则选
$3$，这样就找到了 $\left( \text{max}c_{2},\text{min}c_{4} \right)$
对应的方案。

而求 $\left( c_{2} - C_{1} \right)\left( c_{4} - C_{2} \right)$
的最小值则相当于将所有点集进行平移之后求横纵坐标乘积的最小值。

分类讨论平移之后
$\left\lbrack \text{min}c_{2},\text{max}c_{2} \right\rbrack \times \left\lbrack \text{min}c_{4},\text{max}c_{4} \right\rbrack$
的位置：

-   若 $\left( \text{min}c_{2},\text{min}c_{4} \right)$
    对应的点仍然在第一象限上（整个矩形都落在第一象限），那么
    $\left( \text{min}c_{2},\text{min}c_{4} \right)$
    对应的方案就取到最小值；

-   若整个矩形不完全落在第三象限，那么第二象限的部分
    $\left( \text{min}c_{2},\text{max}c_{4} \right)$
    取到最小值，第四象限的部分
    $\left( \text{max}c_{2},\text{min}c_{4} \right)$
    取到最小值，最小值在这两者里取到；

-   若整个矩形都落在第三象限，由于右上方的形态是未知的所以不能下结论。

因此剩下的部分就是：找到右上方的若干个可能取到横纵坐标乘积最小值的点。

***定理 2*：给定第三象限上一点集，可以取到横纵坐标乘积最小值的点一定在这个点集的右上凸包上。**

**证明：** 不妨假设点集中还有两个点
$( - \infty, - \epsilon)( - \epsilon, - \infty)$，其中 $\epsilon$
为足够小的常数，这两个点不影响答案。考察非右上凸包上一点
$(x,y)$，其与原点的连线必然穿过凸包上某两个相邻的点
$\left( x_{1},y_{1} \right)\left( x_{2},y_{2} \right)$ 的连线，$(x,y)$
一定不比这个交点优。再考虑
$\left( x_{1},y_{1} \right)\left( x_{2},y_{2} \right)$
确定的线段上每个点的横纵坐标乘积，这个函数关于横坐标是一个二次项系数为负的二次函数，所以一定在两端点取到最小值，所以
$\left( x_{1},y_{1} \right)$ 或者 $\left( x_{2},y_{2} \right)$
一定比交点优，也就比 $(x,y)$ 优。 

因此需要找到凸包上所有的点。考虑分治：右上凸包的边界点
$\left( \text{max}c_{2},\text{min}c_{4} \right)$ 和
$\left( \text{max}c_{4},\text{min}c_{2} \right)$
是已知的，而对于凸包上的两个点
$\left( x_{1},y_{1} \right),\left( x_{2},y_{2} \right)$，其中
$x_{1} < x_{2}$，在全体点集中找到一个点 $(x',y')$，使得
$\left( x_{1} - x_{2},y_{1} - y_{2} \right)$ 与 $(x',y')$
的叉积最大，若其不在 $\left( x_{1},y_{1} \right)$ 与
$\left( x_{2},y_{2} \right)$
的连线上，则其是凸包上一个新的点，将这个点分出的凸包的两段作为两个部分分治下去。

每一次分治过程中我们需要解决这样的问题：每个元素选 $2$ 有
$y_{1} - y_{2}$ 的收益，选 $4$ 有 $x_{2} - x_{1}$
的收益，要求找到一个满足所有限制的方案使得收益最大。

更换一下描述，先把 $y_{1} - y_{2} + x_{2} - x_{1}$ 的收益加上，那么选
$2$ 有 $x_{2} - x_{1}$ 的代价，选 $3$ 有 $y_{1} - y_{2} + x_{2} - x_{1}$
的代价，选 $4$ 有 $y_{1} - y_{2}$ 的代价，要求代价和最小。

把必须相等的元素缩在一起，代价乘以缩起来的元素包含的元素个数，那么有用的限制只有
$\left| x_{i} - x_{j} \right| \leq 1$，意味着 $x_{i}$ 选 $2$ 时 $x_{j}$
不能选 $4$，$x_{i}$ 选 $4$ 时 $x_{j}$ 不能选 $2$。

以上问题也是HNOI2013切糕对应的最小割模型可以解决的问题，使用 Dinic
算法得到最小割及其割集，也就得到了在叉积意义下最优的
$\left( c_{2},c_{4} \right)$。

得到凸包上所有点之后每次询问暴力查询凸包上所有点中的最优解。复杂度看似为
$n\left( n^{2}m + q \right)$，但可以分析$\lbrack 0,n\rbrack^{2}$上整点凸包点数上界为
$O\left( n^{\frac{2}{3}} \right)$（证明细节可参考杨景钦 2017 年集训队论文），网络流图也具有良好的性质，可以分析出
$O\left( n^{2}\log n + nm \right)$ 的复杂度（证明可参考Fernández-Baca,
D., & Martel, C. U. (1989). On the efficiency of maximum-flow algorithms
on networks with small integer capacities. Algorithmica, 4(1-4),
173--189），故总复杂度为$O\left( n^{\frac{2}{3}}\left( n^{2}\text{log}n + nm + q \right) \right)$，结合解法一、二可以通过本题。

---

## 作者：JohnVictor (赞：16)

$k<5$ 的情况可以通过之后的分析得出答案，这里省略。

首先我们注意到如果一个数不被强制为 $1,5$，我们肯定不希望它们是 $1,5$，这里被强制为是钦定了是 $1,5$ 或者钦定和某个已经是 $1,5$ 的相同。证明很简单，改成 $2,4$ 就行。注意到 $1,5$ 对于答案的贡献可以改成改变询问里面的 $v_i$，我们认为没有 $1,5$。

现在我们考虑一个只有 $2,3,4$ 的版本，有一些数可以直接确定下来，它们的贡献对于询问的贡献仍然可以认为是改变 $v_i$，我们也认为没有这种数。现在问题变成了这样的形式：

有 $n$ 个数，$m$ 个限制，限制形如 $x_i,x_j$ 不能是一个 $2$ 一个 $4$，或者 $x_i$ 不能是 $2$，或者不能是 $4$。还有一些点被钦定是相等的。然后要将这些数标上 $2,3,4$ 之一，设 $2,3,4$ 标了 $x+y+z=n$ 个，那么总贡献容易算得为

$$M(n^2-2xz)+Ax+Bz+C$$

其中 $M=10^6$，$A,B,C$ 是根据询问而定的常数。

现在我们只用预处理出每一个 $x$ 对应的 $z$ 的最值是怎么样的就行，就可以 $O(nq)$ 处理所有的询问（枚举 $x$）。

考虑经典的网络流模型，左边为可以是 $2$ 的点，右边为可以是 $4$ 的点。把每一组钦定相等的点缩成一个，源点向左边连 $\text{size}$ 的边，右边向汇点连 $l\times \text{size}$ 的边，$\text{size}$ 表示点的大小，$l$ 是一个待定常数。对于不能一个是 $2$ 一个是 $4$ 的限制我们在中间连上 $inf$ 的边，此时考虑这个图的最小割一定能表示为 $x+lz$ 的形式，也就是一个 $l$ 可以让我们在所有可能的 $(x,z)$ 的凸包上二分一次，代价为网络流的复杂度 $O(\text{Dinic}())$。由于值域为 $O(n)$，凸包上至多 $O(n^{\frac{2}{3}})$ 个点，我们就能在 $O(n^{\frac{2}{3}}  \log n\text{Dinic}())$ 的复杂度内完成需要的预处理。

---

## 作者：Rainbow_qwq (赞：10)


考虑 $k=5$ 的情况，首先除了限制为 $1,5$ 的其他一定取 $2,3,4$ 更优。把一定确定的数字都当作常数，确定是相等的数字用并查集合并，剩下的数限制是 $\{2,3\},\{3,4\},\{2,3,4\}$ 中的一种，以及有一些限制：某两个数不能取一个 $2$ 一个 $4$。

设选 2 的数个数为 $x$，选 4 的个数为 $y$。

推一下会发现对于一个询问，要最大化 $Ax+By-Vxy$，$A,B$ 为每个询问不同的变量，$V=2\times 10^6$ 为定值。

把式子化成：最大化 $-V(x-C_1)(y-C_2)+C_3$，也就是最小化 $(x-C_1)(y-C_2)$.

把可行的 $(x,y)$ 画在平面上，位置一定都在 $([\min x,\max x],[\min y,\max y])$ 的矩形内，并且能取到 $(\min x,\min y),(\min x,\max y),(\max x,\min y)$ 三个点。

现在问题是平移这个矩形后求 $\min x\times y$。如果平移后的点在一二四象限那么上面 3 个特殊点可以解决，其他点不会更优。

如果点全部都在第三象限，答案的形式和最小乘积生成树一样。于是结论与做法也一样，可能是答案的点是 $(x,y)$ 的右上凸包的点，做法就是分治出整个凸包，可以直接看[最小乘积生成树](https://www.luogu.com.cn/problem/P5540)的做法。

与最小乘积生成树不同的是，现在要求的问题是：选一个 2 的收益为 $dy$，选一个 4 的收益为 $dx$，以及有一些某两个数不能取一个 $2$ 一个 $4$ 的限制，求收益最大的方案。这个可以用经典的最小割模型解决：看作选 2,3,4 的代价为 $\infty-dy,\infty,\infty-dx$，然后使用[切糕](https://www.luogu.com.cn/problem/P3227)的模型。

复杂度为凸包上点数乘网络流。


---

## 作者：璀璨星空1 (赞：9)

定义问题的「标准形式」如下：有 $n'$ 个结点，要给他们染蓝白橙三种颜色之一。有些结点不能染蓝色，有些结点不能染橙色，另外的结点则都可以染。另有 $m'$ 条边，每条边连接着两个结点 $u,v$，要求是 $u$ 和 $v$ 不能一个染蓝一个染橙。

每个结点有一个 $\text{siz}(u)$。令 $c_蓝$ 表示蓝结点的 $\text{siz}$ 之和，$c_橙$ 表示橙结点的 $\text{siz}$ 之和。对于常数 $w=10^6$ 以及给定的参数 $w_蓝,w_橙$，需要求出所有合法染色方案 $w_蓝c_蓝+w_橙c_橙-2wc_蓝c_橙$ 的最大值。

------

## 一、将原问题转化到「标准形式」

首先将一定相等的连通块缩成一个点，其取值区间是构成结点取值区间的交。这时，有些连通块的取值已经被确定下来。受 $k=3,4$ 情况时的启发，不难想到：如果一个缩点的取值此时未被确定为 $1,5$，则我们一定不会往里面填 $1,5$。这是因为 $1$ 可以调整成 $2$，而 $5$ 可以调整成 $4$。以 $1$ 调整成 $2$ 为例，其所带来的收益一定更好，而且调整完之后一定仍是合法方案。

考虑用已经确定取值的缩点的连边来更新其他缩点的取值区间。进行完这一步之后，可以将这些确定的缩点都给删去。删去后可以将 $1,5$ 从剩下缩点的取值区间中去除掉。在去除掉之后，又会有一些缩点的取值被确定下来。重复上面的步骤，将这些确定的缩点都给删去。由于剩下的取值范围只有 $2,3,4$，因此所有要求差值 $\leq2$ 的连边都没有用了。

最后将一个缩点看成一个结点，$2,3,4$ 分别看成蓝白橙，保留要求差值 $\leq1$ 的所有连边，即可转化到问题的「标准形式」。$w_蓝,w_橙$ 的计算是容易的：首先注意到除了 $-2wc_蓝c_橙$ 一项以外，其余项的贡献可以表达为 $c_蓝,c_白,c_橙$ 的线性组合（再加常数）。然后根据 $c_蓝+c_白+c_橙$ 是常数的事实将 $c_白$ 的贡献摊到 $c_蓝$ 和 $c_橙$ 头上即可。具体计算细节这里不列出。

## 二、分析「标准形式」目标函数的性质

注意到 $w_蓝c_蓝+w_橙c_橙-2wc_蓝c_橙=常数-2w\big(c_蓝-\dfrac{w_橙}{2w})(c_橙-\dfrac{w_蓝}{2w})$。设 $S$ 为所有可以被取到的 $(c_蓝,c_橙)$ 的集合，我们将 $(c_蓝,c_橙)$ 看作是平面上的一个点，那么问题实际上就是：将 $S$ 中的所有点向左平移 $\dfrac{w_橙}{2w}$ 个单位，再向下平移 $\dfrac{w_蓝}{2w}$ 个单位之后，求横纵坐标乘积的最小值。

又注意到全染白，能染蓝的全染蓝其余全染白，能染橙的全染橙其余全染白是三种特殊的合法染色方案。设 $S$ 中 $c_蓝,c_橙$ 的最大值分别为 $\max c_蓝,\max c_橙$，这意味着 $(0,0)$、$(\max c_蓝,0)$、$(0,\max c_橙)$ 这三个点肯定均在 $S$ 中。这样一来，我们就对 $S$ 的形状有了一定的了解。我们考虑对三个点变换后的位置分类讨论：

- 若 $(\max c_蓝,0)$ 在第二象限或 $(0,\max c_橙)$ 在第四象限：此时 $S$ 包含第二或第四象限中的部分。此时选第二或第四象限（而不是第一或第三象限）中的点一定更优。在第二象限中，$(\max c_蓝,0)$ 既最靠左又最靠上，因此肯定选他/她最优。在第四象限中同理，肯定选 $(0,\max c_橙)$ 最优。

- 否则的话，$(0,0)$ 要么在第一象限要么在第三象限，且整个 $S$ 也都在这个象限。若 $(0,0)$ 在第一象限，则肯定选他/她最优。

- 唯一不平凡的情况在于整个 $S$ 都在第三象限。由于 $S$ 右上方的形状未知，我们无法直接下结论。然而此时我们有结论：取到横纵坐标乘积最小值的点一定在 $S$ 的右上凸包上。

  从左到右考虑三个点 $(x_0,y_0),(x_1,y_1),(x_2,y_2)$，其中 $(x_1,y_1)$ 在 $(x_0,y_0)$ 和 $(x_2,y_2)$ 的连线上。那么 $(x_i,y_i)$ 均满足 $y=kx+b$（其中 $k<0$），也就是说 $x_iy_i=x_i(kx_i+b)$ 是关于 $x_i$ 开口向下的二次函数。若其顶点位于 $(x_1,y_1)$ 左侧，则 $x_2y_2<x_1y_1$；若其顶点位于 $(x_1,y_1)$ 右侧，则 $x_0y_0<x_1y_1$。无论如何 $x_1y_1$ 都不可能是最小的那个。而原本的 $(x_1,y_1)$ 位于 $(x_0,y_0)$ 和 $(x_2,y_2)$ 的连线下方，$x_1y_1$ 比连线上的 $x_1y_1$ 更大，更加不可能是最小的那个。

这样一来，我们只需要求出 $S$ 的右上凸包即可，并不需要把 $S$ 中的所有点都求出来。

## 三、构建网络流模型求出 $S$ 的右上凸包

考虑经典的网络流模型。将每个结点 $u$ 拆成两个结点 $A_u,B_u$：其中源点 $S$ 连向 $A_u$，表示 $u$ 染蓝；而 $B_u$ 连向汇点 $T$，表示 $u$ 染橙。边权均为 $\text{siz}(u)$。对于每个限制 $(u,v)$，从 $A_u$ 往 $B_v$ 和从 $A_v$ 往 $B_u$ 各连边权为 $+\infty$ 的边，表示 $u$ 和 $v$ 不能一个染蓝一个染橙；同理还要从 $A_u$ 往 $B_u$ 连边权为 $+\infty$ 的边。

现在我们对该模型作一些改动。我们将 $S$ 到 $A_u$ 的边权都乘上 $\lambda_A$，将 $B_u$ 到 $T$ 的边权都乘上 $\lambda_B$。在网络流模型中，我们知道最小割等于最大流。考虑网络的最小割。割掉 $S$ 到 $A_u$ 就是在说 $u$ 不染蓝色，割掉 $B_u$ 到 $T$ 就是在说 $u$ 不染橙色。那么不染蓝色就需要放弃 $\lambda_A\text{siz}(u)$ 的收益，不染橙色就需要放弃 $\lambda_B\text{siz}(u)$ 的收益。那么考虑剩下来能获得的收益。求出了最小割，就相当于求出了 $\lambda_Ac_蓝+\lambda_Bc_橙$ 的最大值。也就是说，我们可以选定 $\lambda_A$ 和 $\lambda_B$ 的值，并通过一次网络流得到 $S$ 中 $\lambda_Ac_蓝+\lambda_Bc_橙$ 取最大值的 $(c_蓝,c_橙)$ 是什么。利用类似于 $\text{wqs}$ 二分的思想，我们可以还原 $S$ 的右上凸包。

具体的还原方法是分治。设 $(c_蓝,c_橙)$ 和 $(c'_蓝,c'_橙)$ 是已知在凸包上的两个点（其中 $c_蓝<c'_蓝$，$c_橙>c'_橙$）。若在其连线的上方还存在一个点 $(c''_蓝,c''_橙)$，那么取 $\lambda_A=c_橙-c'_橙$ 和 $\lambda_B=c'_蓝-c_蓝$，一定能将 $(c''_蓝,c''_橙)$ 找出来（至少找出其中的一个）。这是因为 $\dfrac{c_橙-c''_橙}{c''_蓝-c_蓝}<\dfrac{c_橙-c'_橙}{c'_蓝-c_蓝}<\dfrac{c''_橙-c'_橙}{c'_蓝-c''_蓝}$ 的缘故（也可以用切线来解释）。那么我们直接分治，初始时我们知道 $(\max c_蓝,0)$ 和 $(0,\max c_橙)$ 这两个点一定在凸包上，每次取 $\lambda_A=c_橙-c'_橙$ 和 $\lambda_B=c'_蓝-c_蓝$ 找 $(c''_蓝,c''_橙)$，如果其在 $(c_蓝,c_橙)$ 和 $(c'_蓝,c'_橙)$ 的连线上那么就说明 $(c_蓝,c_橙)$ 和 $(c'_蓝,c'_橙)$ 之间没有其他的点了，否则就确定 $(c''_蓝,c''_橙)$ 在凸包上，然后继续往两边递归即可。

由于 $(c_蓝,c_橙)$ 都是 $n\times n$ 网格内的整点，通过对本质不同斜率个数的简单分析可得凸包的点数是 $\mathcal{O}(n^{2/3})$ 级别的。因此只需要跑 $\mathcal{O}(n^{2/3})$ 次最小割即可。回答询问可以直接在求出的凸包上二分，答案一定是先增后减的单峰函数，且峰值至多只会在连续的 $2$ 个点处取到，可以直接以相邻两个点处答案的增减关系作为二分的依据。

假定 $m=\Omega(n)$，该算法的时间复杂度是 $\mathcal{O}\big(n^{2/3}\text{Dinic}()+q\log n\big)$，空间复杂度是 $\mathcal{O}(m)$。

---

## 作者：Mirasycle (赞：3)

首先，约束条件可能和固有上下界产生冲突，导致区间内有些数不可能被取到，我们直接类似于 SPFA 跑 $n$ 轮松弛一下这些约束就行了，这样子每个数在取值区间内的数都可能被取到。然后固定一些 $l_i=r_i$ 的数，还有一些数 $l_i\neq r_i$，但是 $1\in [l_i,r_i]，5\in [l_i,r_i]$，这个时候就把 $1,5$ 从值域中踢出去，原因会在下一段提及。

最大化的式子中可以发现，首先 $v_1$ 和 $v_k$ 无贡献，其次取 $1,k$ 的时候对于 $G$ 的贡献没有那么优。所以通过调整法，我们可以发现选 $1$ 或选 $k$ 不如选 $[2,k-1]$。除了那些必须选 $1$ 和 $k$ 的位置外，值域可以缩小到 $[2,k-1]$。

对于部分分，$k=3,4$ 都可以运用基础调整法迅速得到最优解的形式。对于 $k=3$ 的时候，能选 $2$ 就选 $2$。对于 $k=4$ 的时候，贡献函数关于未知数为线性形式，所以那些未确定数要么全选 $2$，要么全选 $3$。

对于 $k=5$ 的时候。建议再读一遍第一段的第一步变量取值处理，然后再看这段文字。未确定数的取值有 $\{2,3,4\}$。首先思考约束关系，那些必定取某个值也就是 $l_i=r_i$ 的位置如果对于未确定数产生约束的时候肯定在松弛的时候已经产生过了。比较难限制的是动区间的约束，比如两个取值为 $[2,4]$ 和 $[2,4]$ 的变量，要求距离 $\le 1$，也就是不能一个 $2$，另一个 $4$，在松弛那一步约束不到这里。可以发现在 $\{2,3,4\}$ 集合内，约束为 $1$ 的条件传递两次没有意义，因为传递两次之后就变成了距离约束为 $2$，而集合内部的最大距离也就是 $2$，所以没有用了。但是距离为 $0$ 的约束传递多次还是紧的，可以用并查集处理。

于是，总结一下变量取值范围的约束大部分在松弛那一步已经处理完了，还有两个需要处理，一个是两个变量要求距离 $\le 1$（这个两个变量只可能是 $m$ 条约束中的某个），还有一个是一些变量要求相等 （不一定为 $m$ 条约束之一，可能是通过并查集传递的）。

处理完变量取值范围之后，我们回到最优化问题上来。可以发现贡献函数形式必定如下所示，其中 $V_i=v_i+?$，这个 $?$ 代表一些距离大于 $1$ 的变量贡献需要扣掉，反正是关于未知数是一个线性关系。

$$W=10^6(n^2-2c_2c_4)+\sum\limits_{i=2}^4c_iV_i+\lambda$$

化简式子，就是就是形如 $-M(c_2-A_1)(c_4-A_2)+A_3$。

令 $(c_2,c_4)\to (x,y)$，我们需要最小化 $(x-A_1)(y-A_4)$。

其中可以发现目前已知三个点肯定能取到，分别是 $(x_{\min},y_{\min})$，$(x_{\min},y_{\max})$ 和 $(x_{\max},y_{\min})$。$x_{\min}$ 就是只有那些松弛过后 $l_i=r_i$ 的点产生贡献，$x_{\max}$ 则是把所有 $2\in[l_i,r_i]$ 的点都压到了 $2$，保证能取到是因为这些动区间点聚集在一起之后距离肯定为 $0$ 也就肯定满足约束，而剩下点还是那一句话定点对于动区间点的约束已经在松弛一步约束过了，所以这三个点肯定能取到。

我们现在需要处理出一个可能取到最优答案的点集，遇到哪个询问，就直接对于点集内所有点代入算一遍看看哪个最优就行了。你直接把所有可能的合法点放入这个点集，显然复杂度是要爆的。因此我们需要挑出一些有用的点放入，一些 $100\%$ 不可能产生贡献的点就不放进去了。 

题目要处理的就是平移之后的 $x'y'$ 乘积最小值。可以发现如果平移之后，还存在点处于 $1,2,4$ 象限，那么肯定包含上面三个定点之一，选择它们是最好的（这个可以自己画画图就能看出来）。因此先把这三个点纳入点集。

问题是如果所有点都被移动到了第三象限怎么办？乘法之后负负得正，我们可以作出判断，只有上凸壳上面的点是有效的（注意如果是 $x,y>0$ 那么是下凸壳，但是这里 $x,y<0$，所以是上凸壳）。

根据引理，


> 在一个 $V\times V$ 的矩形上，凸包点的个数是 $O(V^{\frac{2}{3}})$ 的。

于是我们就把有用点点集大小缩小到了凸包大小量级，也就是 $O(V^{\frac{2}{3}})$。

可惜我们无法直接显式建立这个凸包。不过根据 [P5540](https://www.luogu.com.cn/problem/P5540) 的 trick，我们可以解决这个凸包问题。我们知道凸包上的两点 $P(x_{\min},y_{\max})$ 和 $Q(x_{\max},y_{\min})$。我们可以通过已有的两点去构建这个凸包，直接寻找所有点还是不容易，考虑哪个点是一定在凸包上的，那么就是一个点 $R$ 满足在直线 $PQ$ 上方且离 $PQ$ 距离最大。找到 $R$ 点之后更新答案，并且分治为 $(P,R)$ 和 $(R,Q)$ 去解决问题，这样子我们每次找到一个肯定在凸包上的点，总的寻找复杂度也就是凸包上点的个数乘以单次寻找时间复杂度。

现在考虑如何找到 $R$ 点，上述条件等价于三角形 $PQR$ 的面积最大，也就是 $\vec{RP}\times \vec{RQ}$ 最大。代入坐标，利用叉乘公式计算之后可以得到，希望最大化 $(X_Q-X_P)y_R+(Y_P-Y_Q)x_R$，也就是最小化 $(X_P-X_Q)y_R+(Y_Q-Y_P)x_R$。

也就是说每个数如果选 $2$ 就会有 $Y_Q-Y_P$ 的代价，如果选 $4$ 就会有 $X_P-X_Q$ 的贡献，选 $3$ 没有贡献，同时一些数之间会有在上文中的两个约束。这显然是一个[切糕模型](https://www.luogu.com.cn/problem/P3227)的形式。每次利用切糕模型建图，代价可能是负的，平移 $n$ 即可。跑最小割即可。利用最小割的流量信息求出一组方案，然后找到凸壳上的点，继续分治就行了。注意找到点之后要验证其是否在凸包上，以防复杂度退化。

时间复杂度 $O(n^{\frac{2}{3}}(q+\rm Dinic()))$。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef pair<int,int> pii; 
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
const int maxn=610;
const int maxm=1e6+10;
const ll Vg=1e6;
const ll inf=1e13;
int L[maxn],R[maxn],n,K,m,q; ll val[maxn];
int cnt[6],U[maxm],V[maxm],W[maxm];
vector<pii> vec; int id[maxn][2],c=0;
struct DSU{
	int fa[maxn],sz[maxn];
	void init(){ for(int i=1;i<=n;i++) fa[i]=i,sz[i]=1; }
	int find(int u){ return fa[u]==u?u:fa[u]=find(fa[u]); }
	bool merge(int u,int v){
		u=find(u); v=find(v);
		if(u==v) return 0;
		if(sz[u]<sz[v]) swap(u,v);
		fa[v]=u; sz[u]+=sz[v]; return 1;
	}
}dsu;
struct Dinic{
	struct edge{
		int to,Next; ll f;
	}edges[maxm]; queue<int> q;
	int head[maxm],now[maxm],d[maxm],tot;
	void init(){ tot=1;	for(int i=1;i<=c+2;i++) head[i]=0; }//别忘记调用了 
	void add(int u,int v,ll f){
		edges[++tot]=(edge){v,head[u],f}; head[u]=tot;
		edges[++tot]=(edge){u,head[v],0}; head[v]=tot;
	}
	bool bfs(int s,int t){
		while(q.size()) q.pop(); for(int i=1;i<=c+2;i++) d[i]=0; 
		d[s]=1; q.push(s); now[s]=head[s];//清空 now(s) 
		while(!q.empty()){
			int u=q.front(); q.pop();
			for(int i=head[u];i;i=edges[i].Next){
				int v=edges[i].to; if(d[v]||!edges[i].f) continue;//注意两个条件 
				now[v]=head[v]; d[v]=d[u]+1; q.push(v);//清空 now(v) 
				if(v==t) return 1; 
			}
		}
		return 0;
	}
	ll dinic(int s,int t,ll flow){
		if(s==t) return flow;
		ll rest=flow,k;
		for(int i=now[s];i&&rest;i=edges[i].Next){//判断 rest 是否有剩余 
			now[s]=i; int v=edges[i].to;//动态更新 now 
			if(!edges[i].f||d[v]!=d[s]+1) continue;// 注意 d 的条件 
			k=dinic(v,t,min(rest,edges[i].f));
			if(!k) d[v]=0; //注意 
			rest-=k; edges[i].f-=k; edges[i^1].f+=k;
		}
		return flow-rest;
	}
	pii solve(int s,int t){
		ll maxflow=0,flow;
		while(bfs(s,t))
			while(flow=dinic(s,t,inf)) maxflow+=flow;
		int c2=0,c4=0; bfs(s,t);
		for(int i=1;i<=n;i++){
			if(dsu.find(i)!=i||L[i]==1||R[i]==5) continue;
			if(!d[id[i][0]]) c2+=dsu.sz[i];
			else if(d[id[i][1]]) c4+=dsu.sz[i];
		}
		return mp(c2,c4);
	}
}DC;
void init(){
	dsu.init(); vec.clear(); c=0;
	for(int i=1;i<=5;i++) cnt[i]=0;
}
namespace K3{
	void solve(){
		ll ans; 
		while(q--){
			cin>>val[2];
			int c2=n-cnt[1]-cnt[3];
			ans=Vg*(1ll*n*n-2ll*cnt[1]*cnt[3])+c2*val[2];
			cout<<ans<<"\n";
		}
	}
}
namespace K4{
	void solve(){
		ll ans; 
		while(q--){
			cin>>val[2]>>val[3];
			int r=n-cnt[1]-cnt[2]-cnt[3]-cnt[4];
			int c2=cnt[2]+r;
			ans=Vg*(1ll*n*n-2ll*cnt[1]*(cnt[3]+cnt[4])-2ll*c2*cnt[4])+c2*val[2]+cnt[3]*val[3];
			int c3=cnt[3]+r;
			ans=max(ans,Vg*(1ll*n*n-2ll*cnt[1]*(c3+cnt[4])-2ll*cnt[2]*cnt[4])+cnt[2]*val[2]+c3*val[3]);
			cout<<ans<<"\n";
		}
	}
}
bool chk(pii A,pii B,pii C){
	pii D=mp(B.fi-A.fi,B.se-A.se);
	pii E=mp(C.fi-A.fi,C.se-A.se);
	if(1ll*D.fi*E.se-1ll*D.se*E.fi>0) return 1;
	else return 0;
}
void solve(pii P,pii Q){
	DC.init(); int S=c+1,T=c+2;
	int X=Q.se-P.se+n,Y=P.fi-Q.fi+n;
	for(int i=1;i<=n;i++){
		if(dsu.find(i)!=i||R[i]==1||L[i]==5) continue;
		int sz=dsu.sz[i];
		DC.add(S,id[i][0],(L[i]==2?sz*X:inf));
		DC.add(id[i][0],id[i][1],(L[i]<=3&&R[i]>=3)?sz*n:inf);
		DC.add(id[i][1],T,(R[i]==4?sz*Y:inf));
	}
	for(int i=1;i<=m;i++){
		int u=dsu.find(U[i]),v=dsu.find(V[i]);
		if(W[i]!=1||u==v) continue;
		DC.add(id[u][1],id[v][0],inf); 
		DC.add(id[v][1],id[u][0],inf);
	}
	pii R=DC.solve(S,T);
	if(!chk(P,Q,R)) return ;
	vec.pb(R); solve(P,R); solve(R,Q); 
}
ll calc(){
	ll res=0;
	for(int i=2;i<=K-1;i++) res+=cnt[i]*val[i];
	for(int i=1;i<=K;i++){
		res+=Vg*cnt[i]*cnt[i];
		if(i+1<=K) res+=Vg*cnt[i]*cnt[i+1];
		if(i) res+=Vg*cnt[i-1]*cnt[i];
	}
	return res;
}
void solve(){
	cin>>K>>n>>m>>q; init();
	for(int i=1;i<=n;i++)
		for(auto j:{0,1})
			id[i][j]=++c;
	for(int i=1;i<=n;i++) cin>>L[i]>>R[i];
	for(int i=1;i<=m;i++) cin>>U[i]>>V[i]>>W[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int x=U[j],y=V[j],w=W[j];
			cmax(L[x],L[y]-w); cmin(R[x],R[y]+w);
			cmax(L[y],L[x]-w); cmin(R[y],R[x]+w);
		}
	}
	int mx2=0,mx4=0;
	for(int i=1;i<=n;i++){
		if(L[i]<K&&R[i]>1) cmax(L[i],2),cmin(R[i],K-1);
		if(L[i]==R[i]) cnt[L[i]]++;
		mx2+=(L[i]==2); mx4+=(R[i]==4);
	}
	if(K==3){ K3::solve(); return ; } 
	if(K==4){ K4::solve(); return ; }
	for(int i=1;i<=m;i++)
		if(!W[i]) dsu.merge(U[i],V[i]); 
	vec.pb(mp(cnt[2],cnt[4])); vec.pb(mp(mx2,cnt[4])); vec.pb(mp(cnt[2],mx4));
	solve(vec[2],vec[1]);
	while(q--){
		for(auto i:{2,3,4}) cin>>val[i];
		ll ans=0;
		for(auto z:vec){
			cnt[2]=z.fi,cnt[4]=z.se;
			cnt[3]=n-cnt[1]-cnt[2]-cnt[4]-cnt[5];
			ans=max(ans,calc());
		}
		cout<<ans<<"\n";
	}
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	int c,T; cin>>c>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：complexor (赞：2)

很妙的题。
## $K=3$
首先有一些变量会被限制为 $x_i\in[1,1]$ 或者 $x_i\in[3,3]$，那么它们的值已经确定。同时如果有 $|x_i-x_j|\leq0$ 且 $x_i$ 确定，那么 $x_j$ 也确定。这样我们就得到了一些变量必须为 $1$ 或 $3$，那么可以猜想除了这些变量剩下的都取 $2$。

可以发现这样确实是对的。因为我们已经处理了 $|x_i-x_j|\leq0$ 的限制，所以剩下的全取 $2$ 是合法的。同时全取 $2$ 不会使 $G$ 减小（因为 $|2-1|=|3-2|=1$），而且会使 $c_2$ 增大，故答案更优。

所以 $x_i$ 的取值与 $v_2$ 无关，时间复杂度 $O(n+m+q)$。
## $K=4$
$K=3$ 时，我们只考虑了 $|x_i-x_j|\leq0$ 的约束，这是因为 $|2-1|=|3-2|=1$。现在 $K=4$，需要考虑更一般化的情况。可以发现，第二类约束对第一类约束的影响是，如果 $x_i\in[l_i,r_i]$ 且 $|x_i-x_j|\leq b$，那么有 $x_j\in [l_i-b,r_i+b]$，可以看作是将 $[l_j,r_j]$ 限制得更紧。事实上，将左右端点分开看这就是差分约束，可以 $O(n+m)$（将 $K$ 看作常数）地解决。

进行完上面的过程后，也会得到一些必须为 $1$ 或 $4$ 的变量。那么和 $K=3$ 类似，剩下的变量必然取 $2,3$ 之一，证明也是将所有 $1$ 改成 $2$，$4$ 改成 $3$ 不劣。

观察到序列的权值和顺序没有关系，只取决于每种数的出现次数。剩下这些变量无论取 $2$ 还是取 $3$，这些变量之间的贡献不变，而 $x_i=2$ 对其他已经确定的变量的贡献和 $x_j=2$ 是一样的，所以这些未确定的变量要么同时取 $2$ 要么同时取 $3$。

时间复杂度也是 $O(n+m+q)$。
## $K=5$
首先还是通过差分约束处理限制，那么仍然有结论：除了必须取 $1$ 或 $5$ 的变量，其他变量只会取 $2,3,4$。那么事实上，剩下的变量中，再除去必须取 $2,3,4$ 中特定某个的，取值范围只有三种可能 $\{2,3\},\{3,4\},\{2,3,4\}$，称这些变量为“自由变量”。而二元约束则等价于对于某些 $i,j$，有 $\{x_i,x_j\}\neq\{2,4\}$，或者 $x_i=x_j$。其中，第二种约束比较好处理，因为这意味着此时 $x_i,x_j$ 的取值范围也相同，可以直接当作一个等价类处理。

对于 $Q$ 较小的情况，我们先将必须相等的变量看作一个等价类，然后先算上所有的 $v_2+v_3+v_4$ 和 $G$， 问题就变成了每个等价类可以选 $2,3,4$，分别有 $C_i(v_3+v_4),C_i(v_2+v_4),C_i(v_2+v_3)$ 的代价，而且某两个等价类如果一个选 $2$ 一个选 $4$ 有 $C_iC_j\times10^6$（$G$ 减小）或者 $+\infin$（两个等价类之间存在二元约束）的代价，然后问题转化成 [[HNOI2013] 切糕](https://www.luogu.com.cn/problem/P3227)，可以用网络流解决。可以证明在本题中网络流的复杂度是 $O(n^2\log{n}+nm)$ 的。

回顾 $K=3,4$ 的分析，$K=3$ 时对于任意的 $v_2$，$\{x_i\}$ 的取值相同，$K=4$ 时也只存在两种可能取值，而且本题的询问数 $Q$ 相对于 $n$ 较大，这启发我们预处理出所有可能的序列 $\{x_i\}$，然后每次询问取枚举每种可能计算答案。

对于没有二元约束的情况（特殊性质 $A$），$x$ 的可能性依旧很少。可以证明，对于取值范围一样的自由变量，它们一定会取到同样的值，也就是至多有 $2\times2\times3=12$ 种可能的序列。

可惜的是二元限制的存在使得可能的序列不再是 $O(1)$ 种。求出所有序列是不太可能也没必要的，因为我们实际上只关心 $c_1,c_2,c_3,c_4,c_5$。根据我们的分析，$c_1,c_5$ 已经是定值，且 $c_1+c_2+c_3+c_4+c_5=n$ 也是定值，所以我们需要的信息可以表示为 $(c_2,c_4)$，记此时的权值为 $W(c_2,c_4)$，那么可以得到：
$$
W(c_2,c_4)=W(0,0)+c_2(v_2-v_3+2Vc_1)+c_4(v_4-v_3+2Vc_5)-2Vc_2c_4\\
V=10^6
$$
需要注意的是可能并不存在 $x$ 的取值使得 $(0,0)$，这里的 $W(0,0)$ 只是令 $c_2=c_4=0$ 计算出来的权值以方便化简，不一定存在实际意义。

上式中的变量只有 $c_2,c_4,c_2c_4$，所以我们可以计算出常数 $C_1,C_2,C_3$，使得 $W(c_2,c_4)-W(0,0)=-2V(c_2-C_1)(c_4-C_2)+C_3$，所以只需要最小化 $(c_2-C_1)(c_4-C_2)$。

将 $(c_2,c_4)$ 放到二维平面上，那么每次询问就是将这个点集向左平移 $C_1$，向下平移 $C_2$ 后，求横纵坐标乘积最小的点。

接下来考察哪些 $(c_2,c_4)$（平移之前）可以取到。

先分别考虑两维，$c_2$ 最小值 $L_x$ 就是所有被固定为 $2$ 的变量数量，最大值 $R_x$ 是所有取值范围含 $2$ 的变量数量，包括固定为 $2$ 的变量和取值范围为 $\{2,3\},\{2,3,4\}$ 的自由变量。$L_y,R_y$ 同理。

所以所有能取到的点一定在 $([L_x,R_x],[L_y,R_y])$ 这个矩形中。并且由于所有自由变量都可以取到 $3$，所以这个矩形的三个顶点 $(L_x,L_y),(L_x,R_y),(R_x,L_y)$ 一定是可以取到的。

对于平移后 $(c_2-C_1,c_4-C_2)$ 构成的矩形，有几种情况：

- 矩形全部在第一象限，则此时一定是左下角最优。
- 矩形和二、四象限有交，那么此时一定是左上角或右下角最优。
- 矩形全部在第三象限，此时如果右上角是可以取到的，当然是右上角最好，但是事实上 $(R_x,R_y)$ 不一定能取到。

对于第三种情况，一个自然的想法是所有合法的点构成一个四分之一凸壳。证明考虑不在凸壳上的点，它和原点的线段会与凸壳相交，这个交点更优。而这个交点在一条凸壳的边上，又可以通过二次函数证明调整到边的两个端点之一会更优。

平移后的凸壳也是原来的凸壳平移而来，所以现在只需要求出可能取到的点集的右上四分之一凸壳即可。

一个可能的想法是枚举或二分求出每个 $c_2$ 对应的最大 $c_4$，但没有简单有效检验方法。还是考虑前面的网络流，那么就需要解决两个问题：1.如何给变量赋权建图。2.跑 $O(n)$ 次网络流的复杂度也无法接受，必须要缩减次数。考虑到网络流次数不太可能少于凸包点数，我们希望凸包的点数不能太多。这里有一个经典结论：所有横纵坐标都是 $[0,n]$ 内整数的点集 $1/4$ 凸包大小上界是 $O(n^{\frac{2}{3}})$。

那么现在的问题只剩下如何求出一个未知点集的凸包，我们希望求解方式是以某种顺序找出凸包上的每个点，最好能一次网络流就能找出凸包上的一个新点。

考虑分治法。已经知道凸壳的最左点 $A(x_0=L_x,y_0=R_y))$ 和最右点 $B(x_1=R_x,y_1=L_y))$，那么我们找出点集内的点 $P(c_2,c_4)$ 满足 $|\overrightarrow{AB}\times\overrightarrow{AP}|$ 最大，也就是找到 $AB$ 最远且在 $AB$ 外侧的点，那么 $P$ 一定在凸包上，再分治 $(A,P)$ 和 $(P,B)$ 即可。
$$
\begin{equation}
\begin{aligned}

|\overrightarrow{AB}\times\overrightarrow{AP}|&=(x_1-x_0)(c_4-y_0)-(y_1-y_0)(c_2-x_0)\\
&=(x_1-x_0)c_4+(y_0-y_1)c_2-y_0(x_1-x_0)+x_0(y_1-y_0)\\
&=(c_2+c_3+c_4)(x_1-x_0+y_0-y_1)-y_0(x_1-x_0)+x_0(y_1-y_0)-((x_1-x_0)c_2+(x_1-x_0+y_0-y_1)c_3+(y_0-y_1)c_4)

\end{aligned}
\end{equation}
$$
注意到 $c_2+c_3+c_4=0,x_1-x_0\geq0,y_0-y_1\geq0$，所以这也是[[HNOI2013] 切糕](https://www.luogu.com.cn/problem/P3227)的形式，只要将等价类合并再加上二元约束（代价为 $+\infin$）即可转化为最小割，然后构造出一组最小割方案即可求出对应的 $c_2,c_4$。

预处理复杂度 $O(n^{\frac{2}{3}}(n^2\log{n}+nm))$，询问复杂度 $O(qn^{\frac{2}{3}})$。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P8501)

**题目大意**

> 构造 $x_1\sim x_n$，满足 $x_i\in [l_i,r_i]\subseteq[1,k]$ 以及 $m$ 条限制形如 $|x_u-x_v|\le w$。
>
> $q$ 次询问给定 $v_1\sim v_k$，其中 $v_1=v_k=0$，最大化 $10^6\sum_{i,j}[|x_i-x_j|\le 1]+\sum v_i\sum_j [x_j=i]$。
>
> 数据范围：$n\le 600,m\le 3n,q\le 3\times 10^5,k\le 5$。

**思路分析**

只分析 $k=5$ 的情况。

首先显然填 $1,5$ 的元素越少越好，可以预处理出这样的元素。

剩余的元素在 $2,3,4$ 中选择，则答案为 $\sum v_ic_i+10^6(n^2-2(c_2c_4-c_1c_4-c_2c_5-c_1c_5-c_3c_1-c_3c_5))$。

那么答案可以看成一个有关 $x=c_2,y=c_4$ 的函数 $f(x,y)=axy+bx+cy+d$，其中 $a=-2\times 10^6$。

转写成求 $\max a(x-x_0)(y-y_0)$，即最小化 $(x-x_0)(y-y_0)$。

把所有的 $(x,y)$ 画在平面上，设他们占据的范围为 $[x_L,x_R]\times [y_L,y_R]$，由于这些限制可以把一些填 $2,4$ 的点直接调成 $3$，因此一定能取到 $(x_L,y_L),(x_R,y_L)(x_L,y_R)$。

如果这个矩形平移 $(-x_0,-y_0)$ 后经过二四象限，则答案一定在 $(x_L,y_R)$ 或 $(x_R,y_L)$ 上取到。

否则要么全在第一象限要么全在第三象限，第一种情况答案在 $(x_L,y_L)$ 上取到。

否则相当于求 $(x,y)$ 的上凸壳，类似 [最小乘积生成树](https://www.luogu.com.cn/problem/P5540)，分治构造凸包，每次求出距离当前区间左右端点最远的点，这个点一定在凸包上。

而这个问题相当于求一组解最大化 $z_2c_2+z_4c_4$，先转成最小化 $z_4c_2+(z_2+z_4)c_3+z_2c_4$。

然后把 $w=0$ 的限制对应连通块缩起来，限制是有些点不能一个填 $2$ 一个填 $4$，这是经典的切糕模型，网络流解决。

可以证明凸壳上点数不会超过 $\mathcal O(n^{2/3})$ 级别。

时间复杂度 $\mathcal O(n^{2/3}(q+\mathrm{Flow}(n,m)))$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=605,Z=1e6,inf=1e9;
int k,n,m,q,L[MAXN],R[MAXN],c[6];
int dsu[MAXN],bl[MAXN],id[MAXN],sz[MAXN],tot;
int find(int x) { return dsu[x]^x?dsu[x]=find(dsu[x]):x; }
vector <array<int,2>> vc,lim;
struct Flow {
static const int MAXV=1205,MAXE=2e5+5;
struct Edge {
	int v,f,lst;
}	G[MAXE];
int S,T,ec=1,vc,hd[MAXV],cur[MAXV],dep[MAXV];
void init() { ec=1,memset(hd,0,(vc+1)<<2); }
void adde(int u,int v,int w) { G[++ec]={v,w,hd[u]},hd[u]=ec; }
void link(int u,int v,int w) { adde(u,v,w),adde(v,u,0); }
bool BFS() {
	memcpy(cur,hd,(vc+1)<<2),memset(dep,-1,(vc+1)<<2);
	queue <int> Q;
	Q.push(S),dep[S]=0;
	while(!Q.empty()) {
		int u=Q.front(); Q.pop();
		for(int i=hd[u];i;i=G[i].lst) if(G[i].f&&dep[G[i].v]==-1) {
			dep[G[i].v]=dep[u]+1,Q.push(G[i].v);
		}
	}
	return ~dep[T];
}
int dfs(int u,int f) {
	if(u==T) return f;
	int r=f;
	for(int i=cur[u];i;i=G[i].lst) {
		int v=G[cur[u]=i].v;
		if(G[i].f&&dep[v]==dep[u]+1) {
			int g=dfs(v,min(r,G[i].f));
			if(!g) dep[v]=-1;
			G[i].f-=g,G[i^1].f+=g,r-=g;
		}
		if(!r) return f;
	}
	return f-r;
}
int Dinic() {
	int f=0;
	while(BFS()) f+=dfs(S,inf);
	return f;
}
}	F;
void build(array<int,2>a,array<int,2>b) {
	int wx=a[1]-b[1],wy=b[0]-a[0];
	int s=F.S=2*tot+1,t=F.T=F.vc=2*tot+2;
	F.init();
	for(int i=1;i<=tot;++i) {
		F.link(s,i,L[id[i]]==2?sz[i]*wy:inf);
		F.link(i,i+tot,sz[i]*(wy+wx));
		F.link(i+tot,t,R[id[i]]==4?sz[i]*wx:inf);
	}
	for(auto e:lim) F.link(e[0]+tot,e[1],inf),F.link(e[1]+tot,e[0],inf);
	F.Dinic();
	array<int,2>o{c[2],c[4]};
	for(int i=1;i<=tot;++i) {
		if(F.dep[i]==-1) o[0]+=sz[i];
		if(~F.dep[i+tot]) o[1]+=sz[i];
	}
	if(o[0]*wx+o[1]*wy>a[0]*wx+a[1]*wy) vc.push_back(o),build(a,o),build(o,b);
}
void solve() {
	cin>>k>>n>>m>>q;
	for(int i=1;i<=n;++i) cin>>L[i]>>R[i];
	vector <array<int,3>> edg;
	for(int i=1,u,v,w;i<=m;++i) {
		cin>>u>>v>>w,edg.push_back({u,v,w});
	}
	for(int t=1;t<=n;++t) for(auto e:edg) {
		int u=e[0],v=e[1],w=e[2];
		L[v]=max(L[v],L[u]-w),R[v]=min(R[v],R[u]+w);
		L[u]=max(L[u],L[v]-w),R[u]=min(R[u],R[v]+w);
	}
	for(int i=1;i<=n;++i) {
		if(R[i]>1&&L[i]<k) L[i]=max(L[i],2),R[i]=min(R[i],k-1);
		if(L[i]==R[i]) ++c[L[i]];
	}
	if(k==3) vc={{n-c[1]-c[3],n-c[1]-c[3]}};
	else if(k==4) vc={{c[2],n-c[1]-c[2]-c[4]},{n-c[1]-c[3]-c[4],c[3]}};
	else {
		int m2=0,m4=0;
		for(int i=1;i<=n;++i) m2+=L[i]==2,m4+=R[i]==4;
		vc={{c[2],c[4]},{c[2],m4},{m2,c[4]}};
		tot=0,lim.clear(),iota(dsu+1,dsu+n+1,1);
		for(auto e:edg) if(!e[2]) dsu[find(e[0])]=find(e[1]);
		for(int i=1;i<=n;++i) if(L[i]!=R[i]&&dsu[i]==i) id[++tot]=i,bl[i]=tot;
		for(int i=1;i<=n;++i) if(L[i]!=R[i]) ++sz[bl[find(i)]];
		for(auto e:edg) if(e[2]==1) {
			int x=bl[find(e[0])],y=bl[find(e[1])];
			if(x&&y) lim.push_back({x,y});
		}
		build(vc[1],vc[2]);
	}
	while(q--) {
		array <ll,6> vt={0,0,0,0,0,0};
		for(int i=2;i<k;++i) cin>>vt[i];
		ll ans=0;
		for(auto o:vc) {
			auto e=c;
			e[2]=o[0],e[k-1]=o[1];
			if(k==5) e[3]=n-e[1]-e[2]-e[4]-e[5];
			ll s=0;
			for(int i=1;i<=k;++i) s+=vt[i]*e[i]+1ll*(e[i]+2*e[i-1])*e[i]*Z;
			ans=max(ans,s);
		}
		cout<<ans<<"\n";
	}
	memset(sz,0,sizeof(sz)),memset(c,0,sizeof(c)),memset(bl,0,sizeof(bl)),tot=0;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int ty,_; cin>>ty>>_;
	while(_--) solve();
	return 0;
}
```

---


# [IOI 2021] 分糖果

## 题目背景

# 滥用本题评测将被封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

## 题目描述

Khong 阿姨正在给附近一所学校的学生准备 $n$ 盒糖果。盒子的编号分别为 $0$ 到 $n - 1$，开始时盒子都为空。第 $i$ 个盒子 $(0 \leq i \leq n - 1)$ 至多可以容纳 $c[i]$ 块糖果（容量为 $c[i]$）。

Khong 阿姨花了 $q$ 天时间准备糖果盒。在第 $j$ 天 $(0 \leq j \leq q - 1)$，她根据三个整数 $l[j]$、 $r[j]$ 和 $v[j]$ 执行操作，其中 $0 \leq l[j] \leq r[j] \leq n - 1$ 且 $v[j] \neq 0$。对于每个编号满足 $l[j] \leq k \leq r[j]$ 的盒子 $k$：

- 如果 $v[j] > 0$，Khong 阿姨将糖果一块接一块地放入第 $k$ 个盒子，直到她正好放了 $v[j]$ 块糖果或者该盒子已满。也就是说，如果该盒子在这次操作之前已有 $p$ 块糖果，那么在这次操作之后盒子将有 $\min(c[k], p + v[j])$ 块糖果。

- 如果 $v[j] < 0$，Khong 阿姨将糖果一块接一块地从第 $k$ 个盒子取出，直到她正好从盒子中取出 $-v[j]$ 块糖果或者该盒子已空。也就是说，如果该盒子在这次操作之前已有 $p$ 块糖果，那么在这次操作之后盒子将有 $\max(0, p + v[j])$ 块糖果。

你的任务是求出 $q$ 天之后每个盒子中糖果的数量。

## 说明/提示

**例 1**

考虑如下调⽤：
`distribute_candies([10, 15, 13], [0, 0], [2, 1], [20, -11])`

这表示盒子 $0$ 的容量为 $10$ 块糖果，盒子 $1$ 的容量为 $15$ 块糖果，盒子 $2$ 的容量为 $13$ 块糖果。

在第 $0$ 天结束时，盒子 $0$ 有 $\min(c[0], 0 + v[0]) = 10$ 块糖果，盒子 $1$ 有 $\min(c[1], 0 + v[0]) = 15$ 块糖果，盒子 2 有 $\min(c[2], 0 + v[0]) = 13$ 块糖果。

在第 $1$ 天结束时，盒子 $0$ 有 $\max(0, 10 + v[1]) = 0$ 块糖果，盒子 $1$ 有 $\max(0, 15 + v[1]) = 4$ 块糖果。因为 $2 > r[1]$，盒子 $2$ 中的糖果数量没有变化。每一天结束时糖果的数量总结如下：

| 天 | 盒子 $0$ | 盒子 $1$ | 盒子 $2$ |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $10$ | $15$ | $13$ |
| $1$ | $0$ | $4$ | $13$ |

就此情况，函数应该返回 $[0, 4, 13]$。

**约束条件**

- $1 \le n \le 200 000$

- $1 \le q \le 200 000$
- $1 \le c[i] \le 10 ^ 9$ （对所有 $0 \le i \le n - 1$）
- $0 \le l[j] \le r[j] \le n - 1$（对所有 $0 \le j \le q - 1$）

- $−10 ^ 9 \le v[j] \le 10 ^ 9$ , $v[j] ≠ 0$（对所有 $0 \le j \le q - 1$）

**子任务**

1. （$3$ 分） $n, q \leq 2000$
2. （$8$ 分） $v[j] > 0$（对所有 $0 \le j \le q - 1$）
3. （$27$ 分） $c[0] = c[1] = \cdots = c[n - 1]$
4. （$29$ 分） $l[j] = 0$ 和 $r[j] = n - 1$（对所有 $0 \leq j \leq q - 1$）
5. （$33$ 分） 没有额外的约束条件。

**评测程序示例**

评测程序示例读入如下格式的输入：

- 第 $1$ 行: $n$
- 第 $2$ 行: $c[0] ~ c[1] ~ \cdots ~ c[n - 1]$
- 第 $3$ 行: $q$
- 第 $4 + j$ 行 ( $0 \leq j \leq q - 1$): $l[j] ~ r[j] ~ v[j]$

评测程序示例按照以下格式打印你的答案：

第 $1$ 行: $s[0] ~ s[1] ~ \cdots ~ s[n - 1]$

## 样例 #1

### 输入

```
3
10 15 13
2
0 2 20
0 1 -11
```

### 输出

```
0 4 13
```

# 题解

## 作者：Undead2008 (赞：36)

[题目](https://www.luogu.com.cn/problem/P8518)

### 题目描述
> Khong 阿姨花了 $q$ 天时间准备糖果盒。在第 $j$ 天，对于每个编号满⾜ $l[j] \leq k \leq r[j]$ 的盒⼦ $k$：
>
> - 如果 $v[j] > 0$，如果该盒⼦ $k$ 之前已有 $p$ 块糖果，那么在这次操作之后盒⼦将有 $\min(c[k], p + v[j])$ 块糖果。
>
> - 如果 $v[j] < 0$，如果该盒⼦之前已有 $p$ 块糖果，那么在这次操作之后盒⼦将有 $\max(0, p + v[j])$ 块糖果。
>
> 你的任务是求出 $q$ 天之后每个盒⼦中糖果的数量。
> 
> $1\le n,q\le 2\times 10^5$

### 题目分析
以下均用 $a$ 代指原序列。

如果不考虑上下界的话，就是一个朴素的线段树问题。

棘手的是每一个位置都有独特的上界，没办法直接维护。

如果位置 $j$ 在某一时刻的值 $a_j=0$，就说它碰了下壁；如果位置 $j$ 在某一时刻的值 $a_j=c_j$，就说它碰了上壁。在最后一次碰壁后，上下界就没有作用了。因此，我们只需要知道最后一次碰壁的时间，就可以很方便地维护答案。

维护“时间”可以离线询问，将每一个操作的贡献打到时间轴上。将不考虑上下界后得到的时间轴记作 $b$。对于每一个位置 $j$，如果第 $i$ 个操作将 $b_j$ 加上了 $\Delta$，就相当于将 $b_j$ 在时刻 $i$ 到时刻 $q$ 内的每一个时刻的值都加上了 $\Delta$。

建立 $n$ 棵线段树维护每一个位置的时间轴 $b$ 是不现实的。可以使用类似差分的做法，将一个区间操作拆成两个对后缀的操作，即将 $(l,r,\Delta)$ 拆成 $(l,n,\Delta)$ 和 $(r+1,n,-\Delta)$，考虑扫描线思想，用一棵维护时间轴的线段树从左到右扫，到每个位置时都进行该位置上的操作（即到 $j$ 时进行所有 $(j,n,\Delta)$ 操作），这样执行完位置 $j$ 的所有操作后，线段树维护的就是位置 $j$ 的时间轴 $b_j$。

注意到如果一段时间内 $b_j$ 的极差（最大值减去最小值）大于等于 $c_j$，则 $j$ 至少碰壁一次。如果在这段时间内的时刻 $u$ 时 $b_j$ 取最大值，时刻 $v$ 时 $b_j$ 取最小值，则在时刻 $\max(u,v)$ 时 $j$ 一定碰壁 $^\dag$。不管 $\min(u,v)$ 是否碰壁，$\max(u,v)$ 往上走和往下走都会碰壁。

$^\dag$：这和大多数题解“时刻 $u$ 和时刻 $v$ 都会碰壁”的结论不同。后者在下图图 $4$ 中的两种情况中是明显错误的。

（蓝线代表考虑上下界后 $b_j$ 的值，红线代表不考虑上下界时 $b_j$ 的值）

![](https://cdn.luogu.com.cn/upload/image_hosting/3mir0pip.png)

我们要找 $j$ 的最后一次碰壁，也就是要找时间轴上极差 $\ge c_j$ 的最短后缀。线段树的每个节点维护区间最大值，最小值时，这可以在线段树上二分实现。

记时刻 $q$ 时 $b_j$ 的值为 $f$，有三种情况：

- 找不到满足要求的后缀（对应上图 $1$），则答案等于 $f$ 减去整个时间轴每个时刻中 $b_j$ 的最小值。

否则，记 $U$ 和 $V$ 为满足要求的后缀中的最大值和最小值。

- $U$ 比 $V$ 先出现（对应上图 $2$）则答案等于 $f-V$；
- $V$ 比 $U$ 先出现（对应上图 $3$）则答案等于 $c_j-(U-f)$。

注意到前 $3$ 张图上的 $x$ 总等于 $y$，可以根据这个性质推出答案。

这道题就做完了。

### 代码实现

我写了一个带区间操作的线段树，代码或许会长出去好多。

线段树的每个节点维护区间最大值、最小值、懒标记和（叶子结点的）值即可。

[代码](https://www.luogu.com.cn/paste/acdtrv90)

---

## 作者：WeLikeStudying (赞：29)

- 以下是[第二个版本的博客](https://www.luogu.com.cn/paste/9ywvtwup)，现在是第三个版本。
- 感谢[0htoAi](https://www.luogu.com.cn/user/335366)，[gzw2005](https://www.luogu.com.cn/user/53118)和[Pozhu](https://www.luogu.com.cn/user/581564)，祝愿其信息学之路光明璀璨。
- 感谢 UOJ 的高人，他们的实现简洁而精妙，让我学到了很多，如果我有机会，一定要感谢他们。
- 如果我有机会，一定要写篇题解讲代老师的分块做法。
- 作者已经退役，因为[这件事](https://www.luogu.com.cn/discuss/475189)挨批，然后又得重写一遍博客，心情还是有点难受的。
- 不过，心中真正有光明的人，即使仰望茫茫宇宙，意识到自己生活的一切痕迹都将被抹去，不解自己为何被离弃，也会安然坦然地走下去。
- 我极喜欢张晓风的那句“我在”：
```
	《旧约·创世纪》里，堕落后的亚当在凉风乍至的伊甸园把自己藏匿起来。上帝说：“亚当，你在哪里？”
	他噤而不答。
	如果是我，我会走出，说：“上帝，我在，我在这里，请你看着我，我在这里。不比一个凡人好，也不比一个凡人坏，我有我的逊顺祥和，也有我的叛逆凶戾，我在我无限的求真求美的梦里，也在我脆弱不堪一击的人性里。上帝啊，俯察我，我在这里。”
```
- 同样，尽管退役，我依然在这里。


**题意**
- [题目链接](https://uoj.ac/problem/660)。
- 长为 $n$ 的数列 $a_i$，与一个恒定的数列 $c_i$，支持区间加操作，但是每次操作之后，所有 $a_i$ 与 $0$ 取较大值，与 $c_i$ 取较小值，要求在所有操作之后输出 $a_i$。

**分析**
- “在所有操作之后输出结果”是经典的离线问题，有这句话几乎意味着在线不可做，与这个类似的还有[rprmq](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-kai-bai-ji-hua-1-ren-pin-ran-mei-qu)，[这篇例题 3](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-ji-chu-you-hua-fen-kuai)等一系列神秘题目。
- 把时间维度与数列下标维度交换（如果您不了解这个技巧，可以参照上面的第二道例题）（具体而言：我们打算对于每个元素 $a_i$，用数据结构维护对应的操作序列，那么只需要 $O(q)$ 次增加或删除“修改操作”的操作），我们得到了一个问题：给定（对于一个单独元素的）操作序列，求最后的结果。
- 由于原来的问题不太好思考，可以尝试去掉上界思考：
![](https://cdn.luogu.com.cn/upload/image_hosting/e2jrxe41.png)
- 因此，如果去掉上界，我们只需要在线段树上二分找到最小的前缀和，如果大于等于零，对 $0$ 取 $\max$ 没有发生，否则操作序列的后缀和就是答案。
- 接下来，考虑上界 $c_i$：
![](https://cdn.luogu.com.cn/upload/image_hosting/31swz6ci.png)
- 如果找到左端点最右的一段区间满足这个条件，那么它一定是成功对 $0$ 取 $\max$ 和对 $c_i$ 取 $\min$ 两者交替（或者在它的后面一段），而在这之后的的区间只会出现其中一种情况，这种情况只需要再次取操作序列的极值即可。

**代码实现**
- 利用区间前缀最大值，前缀最小值和区间和这三个变量可以表示一切（注意两者相减就是绝对值最大子段和）。
- 我们需要找到最右的，绝对值大于 $c$ 的区间的左端点，在线段树上，二分的同时维护后缀信息，容易在 $O(\log q)$ 的时间内查询得到结果。
- 找到最右的左端点之后，可以利用该点的正负说明这个操作是上面四种情况的哪一种（触底后碰顶，碰顶后触底，触底后半段，碰顶后半段），然后找到极值点，再判断要不要清 $0$，最终的代码是简短的，[代码](https://www.luogu.com.cn/paste/njzmvld2)。

---

## 作者：Mine_King (赞：8)

[在我的博客获得更好的阅读体验](https://www.cnblogs.com/mk-oi/p/P8518.html)

## Problem

[题目编号，P8518 [IOI2021] 分糖果](https://www.luogu.com.cn/problem/P8518)

**题目大意：**

给你一个长度为 $n$ 的序列 $c$，你有一个序列 $a$，初始时 $a$ 的每个值都为 $0$。有 $q$ 次操作，每次操作将一个区间加上一个数。每次操作后若 $a_i<0$ 则 $a_i \gets 0$。若 $a_i>c_i$ 则 $a_i \gets c_i$。问 $q$ 次操作后序列 $a$ 的值。

## Solution

我们定义 $a_i \gets 0$ 为“碰下壁”，$a_i \gets c_i$ 为“碰上壁”。

容易发现，对于每个 $a_i$，最后一次碰壁前的操作是无用的。于是我们考虑对于每个点求出最后一次碰壁的时间。

假设正在考虑第 $i$ 个点。

假设没有推平操作，那么这个数的变化情况应该是这样一条曲线：

![QQ截图20220907094243.png](https://s2.loli.net/2022/09/07/GVhNrHDJtFyRknl.png)

观察发现，对于相邻的一次碰上壁和一次碰下壁：

![QQ截图20220907094515.png](https://s2.loli.net/2022/09/07/HGuctaf9WM3EDOo.png)

他们的差一定 $>c_i$。

于是考虑使用这个性质来找到最后一次碰上壁和最后一次碰下壁。

具体怎么实现呢？  
我们在时间（即每次操作）上建一棵线段树，在线段树的每个节点记录这个区间的和，前缀最大最小值。则我们查询只要找最后一次碰上壁和最后一次碰下壁中靠前的那个的位置，另一个则为从这个位置开始一直道最后的另一个极值。  
因为我们需要查询的是一段后缀，所以若当前在区间 $[l,r]$，则同时还要记录 $[r+1,q]$ 这个区间的区间和，前缀最大最小值。  
对于当前区间，若右半部分（$[mid+1,q]$）的极差 $>c_i$，则答案在右儿子，否则在左儿子。

找到正确的位置后，考虑维护答案，可以把碰壁操作看成整体位移。以碰上壁为例，则相当于将整个曲线向下移动一段距离，也就是整体减去一个值，如图所示：

![QQ截图20220907095733.png](https://s2.loli.net/2022/09/07/OPBxJm9oTlXSsgL.png)

所以最终答案为整个后缀的和减去最后一次碰壁的前缀和再加上位移量。

但是上面的只是单独一个点的做法。那有 $n$ 个点的情况呢？

可以进行差分，也就是对于一个影响范围为 $[l,r]$ 的操作，在点 $l$ 时将其插入线段树，在点 $r+1$ 时将其从线段树中删除即可。

## Code

```cpp
//Think twice,code once.
#include<vector>
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,q;
vector<int>c,lt,rt,vv,ans;
vector<pair<int,int> >v[200005];
struct Segment_Tree
{
	long long sum[800005],mx[800005],mn[800005];//sum，mx，mn 分别为区间和，最大最小值。
	int l[800005],r[800005];
	void build(int ll,int rr,int k)
	{
		l[k]=ll;r[k]=rr;
		if(ll==rr) return ;
		int mid=(l[k]+r[k])/2;
		build(ll,mid,k*2);
		build(mid+1,rr,k*2+1);
		return ;
	}
	void update(int p,int val,int k)
	{
		if(l[k]==r[k])
		{
			sum[k]+=val;
			mx[k]=max(0ll,sum[k]);
			mn[k]=min(0ll,sum[k]);
			return ;
		}
		int mid=(l[k]+r[k])/2;
		if(p<=mid) update(p,val,k*2);
		else update(p,val,k*2+1);
		sum[k]=sum[k*2]+sum[k*2+1];
		mx[k]=max(mx[k*2],sum[k*2]+mx[k*2+1]);
		mn[k]=min(mn[k*2],sum[k*2]+mn[k*2+1]);
		return ;
	}
	long long query(int cc,long long rsum,long long rmx,long long rmn,int k)//这里 rsum,rmx,rmn 分别代表当前区间 [l,r] 的后缀 [r+1,q] 的和，最大最小值。
	{
		if(l[k]==r[k])
		{//二分得到的位置一定是最后一次碰上壁和最后一次碰下壁中的某一个，所以可以根据 sum 的值来判断他是碰上壁还是碰下壁，进而判断最后一次碰壁时碰上壁还是碰下壁
			if(sum[k]<=0)
			{
				if(rmx>cc) return cc+rsum-rmx;
				else return rsum-rmn;
			}
			else
			{
				if(rmn<-cc) return rsum-rmn;
				else return cc+rsum-rmx;
			}
		}
		long long nsum=rsum+sum[k*2+1];
		long long nmx=max(mx[k*2+1],sum[k*2+1]+rmx);
		long long nmn=min(mn[k*2+1],sum[k*2+1]+rmn);
        //将 [mid+1,r] 与后缀合并。
		if(nmx-nmn<=cc) return query(cc,nsum,nmx,nmn,k*2);
		else return query(cc,rsum,rmx,rmn,k*2+1);
	}
}tr;
vector<int>distribute_candies(vector<int>c,vector<int>lt,vector<int>rt,vector<int>vv)
{
	n=c.size();
	q=vv.size();
	tr.build(0,q,1);
	c.push_back(0);
	lt.push_back(0);
	rt.push_back(0);
	vv.push_back(0);
	for(int i=n-1;i>=0;i--) swap(c[i],c[i+1]);
	for(int i=q-1;i>=0;i--) swap(lt[i],lt[i+1]);
	for(int i=q-1;i>=0;i--) swap(rt[i],rt[i+1]);
	for(int i=q-1;i>=0;i--) swap(vv[i],vv[i+1]);
	for(int i=1;i<=q;i++)
	{
		lt[i]++,rt[i]++;
		v[lt[i]].emplace_back(i,vv[i]);
		v[rt[i]+1].emplace_back(i,-vv[i]);
	}//差分
	for(int i=1;i<=n;i++)
	{
		for(auto j:v[i])
			tr.update(j.first,j.second,1);
		ans.push_back(tr.query(c[i],0,0,0,1));
	}
	return ans;
}
```


---

## 作者：Larry76 (赞：5)

建系，横轴为序列维，纵轴为时间维，套用 P7560 的套路，只要我们找到了最后一次触碰上界或者下界的时刻 $t$，在 $t$ 时刻之后的部分就变成了一个简单的求和。

那么目前亟待解决的问题就是如何描述「最后一次触碰上 / 下界」这一个东西。

设当前正在被操作的原序列 $A$ 位置为 $j$，时间序列为 $time$，定义「制裁」为「当前操作结束后触碰到上 / 下界时，对$a_j$ 取 $\min$ 或 $\max$ 」的行为，定义「触碰」为「当前操作结束后，位置 $a_j \gt c_j$ 或 $a_j \lt 0$」。

先忽略上界，考虑什么时候会碰到下界，不难发现在时间序列的最小前缀和 $[1,x]$ 中的 $x$ 上，证明如下：

> 假设 $h$ 时刻被制裁，那么如果 $t$ 时刻还想被制裁，则必须要保证时间序列上 $t$ 位置上的数 $<$ $-\max(0, \sum_{i=h+1}^{t-1} time_i)$，否则一定不会被制裁。
>
> 这就意味着如果你选上了一段和为非负数的区间，那么必然要选其后面的那一个被制裁的地方，此时才能保证当前前缀和更小，否则一定不会选那一段区间。

现在考虑加上上界，不难发现下面这个性质：

- 若 $i$ 时刻触碰上界，$j$ 时刻触碰下界，则时间序列上 $[i,j]$ 区间的和一定 $\lt -c$。
- 若 $i$ 时刻触碰下界，$j$ 时刻触碰上界，则时间序列上 $[i,j]$ 区间的和一定 $\gt c$。

综上，得「相邻的上下界触碰事件」之间区间的和的绝对值一定 $\gt c$。

现在我们的「最后一次触碰上 / 下界」一定在最靠右满足这一条件的区间的左端点或者右端点，然而左端点只会有一种情况（就是有可能在触碰下界后一段或触碰上界后一段的区间和的绝对值 $\gt c$），对于这种情况取一下当前序列的前缀最大/小值就好了。

最后就剩怎么找我们所需要的那个区间，简单的，考虑线段树维护「前缀最小和、前缀最大和、区间和」，然后绝对值最大子段和就是「前缀最大和 $-$ 前缀最小和」，修改时单点修改，查询时在线段树上二分即可。

PS：找到位置 $t$ 然后再做求和查询时没有必要的，可以直接在查询的时候返回「$t$ 时刻之后的部分」的答案。

时间复杂度 $O((n+q)\log q)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using veci = vector<int>;
#define fore(name, start, end) for(int name = start; name <= end; ++ name)
#define stlfore(name, stlname) for(auto name : stlname)
#define stlsiz(x) ((int)(x).size())
#define lson(x) ((x)<<1)
#define rson(x) ((x)<<1|1)
using i64 = long long;
using i128 = __int128_t;
const int MAX_SIZE = 2e5 + 100;
int n, m;
struct Info{
	i64 premax, premin;
	i64 sum;
	Info(i64 _premax, i64 _premin, i64 _sum) : 
		premax(_premax), premin(_premin), sum(_sum) {}
	Info() = default;
	Info(i64 x) : 
		premax(max(0ll, x)), premin(min(0ll, x)), sum(x) {}
	inline Info operator + (const Info &oth) const {
		return Info(max(premax, sum + oth.premax), min(premin, sum + oth.premin), sum + oth.sum);
	}
};
Info seg[MAX_SIZE<<2];
void modify(int p, int tl, int tr, int pos, i64 val) {
	if(tl == tr) {
		seg[p] = Info(seg[p].sum + val);
		return ;
	}
	int mid = (tl + tr) >> 1;
	if(pos <= mid)
		modify(lson(p), tl, mid, pos, val);
	else 
		modify(rson(p), mid + 1, tr, pos, val);
	seg[p] = seg[lson(p)] + seg[rson(p)];
}
i64 query(int p, int tl, int tr, i64 c, Info nowInfo) {
	if(tl == tr) {
		if(seg[p].sum <= 0) {
			if(nowInfo.premax > c) {
				return c + nowInfo.sum - nowInfo.premax;
			} else {
				return nowInfo.sum - nowInfo.premin;
			}
		} else {
			if(nowInfo.premin < -c) {
				return nowInfo.sum - nowInfo.premin;
			} else {
				return c + nowInfo.sum - nowInfo.premax;
			}
		}
	}
	int mid = (tl + tr) >> 1;
	Info nextInfo = seg[rson(p)] + nowInfo;
	if(nextInfo.premax - nextInfo.premin <= c) {
		return query(lson(p), tl, mid, c, nextInfo);
	} else {
		return query(rson(p), mid + 1, tr, c, nowInfo);
	}
}
struct Line{
	i64 pos;
	i64 val;
};
vector<Line> event[MAX_SIZE];
veci distribute_candies(veci c, veci l, veci r, veci v) {
	n = stlsiz(c);
	m = stlsiz(l);
	fore(i, 0, m - 1) {
		event[l[i]].push_back({i + 1, v[i]});
		event[r[i] + 1].push_back({i + 1, -v[i]});
	}
	veci ans(n, 0);
	fore(i, 0, n - 1) {
		stlfore(e, event[i])
			modify(1, 0, m, e.pos, e.val);
		ans[i] = query(1, 0, m, c[i], Info(0));
	}
	return ans;
}
```

---

## 作者：Genius_Star (赞：3)

### 思路：

先忽略其余 $n-1$ 个盒子，即只有第 $h$ 个盒子的情况下如何快速求出这个盒子的答案。

先给一些定义：

- 碰壁：若当前值加上这次操作的值 $\le 0$ 或者 $\ge c_h$（“碰下壁”为前者，“碰上壁”为后者）。

容易发现，只要找到最后一次“碰壁”的时刻，就可以轻松的求出答案了。

定义 $s_i$ 表示当前盒子在第 $i$ 个时刻总共增加的糖果数量。

注意到一个性质，若有一段区间，其极差（最大值减去最小值）是大于等于 $c_h$ 的，那么区间内是肯定有一次“碰壁”
。

如图（红色是上界，蓝色是 $s$ 的变化），分为以下三种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ijd09ppp.png)

其中第一种和第二张情况肯定满足，第三种情况极差可能 $\le c_h$。

将极值点提取出来，记做 $X,Y$，由上图可知 $\max(X,Y)$ 是肯定“碰壁”的。

我们需要找到最后一次“碰壁”的位置，即要找到一个尽量靠后的 $j$，使得 $[j,q]$ 的极差 $\ge c_i$；发现可以在线段树上二分可得。

此时又会分为几种情况（图中蓝色是取了上下界的情况，粉色是是不取上下界的情况）：
#### 第一种：

没有找到 $j$，即没有碰过一次壁。

- 该情况如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/m22h98ok.png)

- 此时蓝线与粉线完全重复，即 $ans=y$。

#### 第二种：

也没有找到 $j$，是之前的图 $3$ 那种情况；即全局只出现了一次“碰壁”，且是“碰下壁”；且 $y$ 点在 $x$ 轴上方。

- 该情况如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/186jkigw.png)

- 相当于我们已知 $y$ 和 $t$，要求 $ans$。

- 因为在蓝线“不碰壁”的时候，都是同增同减，即此时蓝线和粉线是平行的（即偏移了一段距离）。

- 偏移的距离就是粉线多减或者多加的距离，即 $t$ 垂直于 $x$ 轴的距离为 $|t|$，那么 $ans=y+|t|=y-t$。

#### 第三种：

也没有找到 $j$，是之前的图 $3$ 那种情况；即全局只出现了一次“碰壁”，且是“碰下壁”；且 $y$ 点在 $x$ 轴下方。

- 该情况如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/estado8k.png)

- 与第二种几乎一致，可得 $ans=y-t$。
#### 第四种：

最后一次“碰壁”是“碰下壁”；且 $y$ 点在 $x$ 轴上方。

- 该情况如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/du3ah5jj.png)

- 发现后面的模型和前面几种是一样的，即 $t$ 到交点的长度与 $y$ 到 $ans$ 的长度是相等的；则 $ans=y+|t|=y-t$。

#### 第五种：

最后一次“碰壁”是“碰下壁”；且 $y$ 点在 $x$ 轴下方。

- 该情况如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6gxquiuo.png)

- 已知 $t,y$，求 $ans$。

- 与第四种几乎是一样的，则 $ans=y-t$。

#### 第六种：

最后一次“碰壁”是“碰上壁”，且顶点 $t$ 在上界外。

- 该情况如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3rdlzqop.png)

- 此时 $y$ 与 $ans$ 的距离等于 $t$ 与上界 $c_h$ 的距离，可得 $ans=y-(t-c_h)=y-t+c_h$。

#### 第七种：

最后一次“碰壁”是“碰上壁”，且顶点 $t$ 在上界内。

- 该情况如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qy844jit.png)

- 因为当蓝线不“碰壁”时，两线是同增同减的，那么 $ans$ 到上界的距离就等于 $t$ 到 $y$ 与上界平行的直线上；那么 $ans=c_h - (t-y) = c_h -t + y$。

#### 总结：

那么答案可以分为四种情况：图 $1$，图 $2,3$，图 $4,5$，图 $6,7$。

分类讨论以下就可以得出答案。

------------

这样如果只询问一个点，且我们知道当前这个点每个时间点上增加的值，就可以 $\log n$ 的时间求出答案。

那么我们考虑将原题转化为单点询问，即使用扫描线算法；扫描线扫序列，线段树维护时间轴。

对于一次区间 $[l,r]$ 加 $v$ 操作，可以影响 $[i,q]$ 的时间段；因为要扫描线，考虑拆成在 $l$ 处将 $[i,q]$ 增加 $v$，在 $r+1$ 处将 $[i,q]$ 增加 $-v$。

那么将每一个点的操作处理完之后，此时线段树维护的该点的时间轴；然后在线段树上二分，找到最后一个“碰壁”的位置，分类讨论一下即可求出答案。

时间复杂度为 $O((N+Q) \log Q)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=200200,INF=1e18;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll l,r;
	ll Max,Min;
	ll tag;
}X[N<<2];
ll n,q,x,y,t,lim;
ll a[N];
vector<pair<ll,ll>> E[N];
vector<int> ans;
pair<ll,ll> h;
pair<ll,ll> merge(const pair<ll,ll> &a,const pair<ll,ll> &b){
	return {max(a.first,b.first),min(a.second,b.second)};
}
void pushup(ll k){
	X[k].Max=max(X[k<<1].Max,X[k<<1|1].Max);
	X[k].Min=min(X[k<<1].Min,X[k<<1|1].Min);
}
void add(ll k,ll v){
	X[k].tag+=v;
	X[k].Max+=v;
	X[k].Min+=v;
}
void push_down(ll k){
	if(X[k].tag){
		add(k<<1,X[k].tag);
		add(k<<1|1,X[k].tag);
		X[k].tag=0;
	}
}
void build(ll k,ll l,ll r){
	X[k].l=l,X[k].r=r;
	if(l==r)
	  return ;
	ll mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
}
void updata(ll k,ll l,ll r,ll v){
	if(X[k].l==l&&r==X[k].r){
		add(k,v);
		return ;
	}
	push_down(k);
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  updata(k<<1,l,r,v);
	else if(l>mid)
	  updata(k<<1|1,l,r,v);
	else{
		updata(k<<1,l,mid,v);
		updata(k<<1|1,mid+1,r,v);
	}
	pushup(k);
}
ll qurey(ll k,ll i){
	if(X[k].l==i&&i==X[k].r)
	  return X[k].Max;
	push_down(k);
	ll mid=(X[k].l+X[k].r)>>1;
	if(i<=mid)
	  return qurey(k<<1,i);
	else
	  return qurey(k<<1|1,i);
}
ll qurey(ll k){
	if(X[k].l==X[k].r){
		h=merge({X[k].Max,X[k].Min},h);
		return X[k].l;
	}
	push_down(k);
	auto t=merge(h,{X[k<<1|1].Max,X[k<<1|1].Min});
	if(t.first-t.second>=lim)
	  return qurey(k<<1|1);
	else{
		h=t;
		return qurey(k<<1);
	}
}
vector<int> distribute_candies(vector<int> c,vector<int> l,vector<int> r,vector<int> v){
	n=c.size(),q=l.size();
	for(int i=0;i<n;i++)
	  a[i+1]=c[i];
	for(int i=1;i<=q;i++){
		x=l[i-1]+1,y=r[i-1]+1,t=v[i-1];
		E[x].push_back({i,t});
		E[y+1].push_back({i,-t});
	}
	build(1,0,q);
	for(int i=1;i<=n;i++){
		for(auto t:E[i]){
			ll l=t.first,r=q,v=t.second;
			updata(1,l,r,v);
		}
		h={-INF,INF},lim=a[i];
		x=qurey(1),y=qurey(1,q);
		t=qurey(1,x);
//		cerr<<h.first<<' '<<h.second<<'\n';
		if(h.first-h.second<lim){
			if(h.second>=0)
			  ans.push_back(y);
			else
			  ans.push_back(y-h.second);
		}
		else if(t==h.first)
		  ans.push_back(y-h.second);
		else if(t==h.second)
		  ans.push_back(a[i]-(h.first-y));
	}
//	for(auto v:ans){
//		write(v);
//		putchar(' ');
//	}
	return ans;
}
```

---

## 作者：ljw0102 (赞：2)

## 题目大意：

给定一个长为 $n$ 的数组 $c$，维护一个长为 $n$ 的数组 $a$，起初全为 $0$。有 $q$ 次区间加操作，若操作后 $a_i<0$ 则 $a_i \gets 0 $，若操作后 $a_i>c_i$ 则 $a_i \gets c_i$。求所有操作后 $a$ 数组的值。

## 思路：

使用**换维扫描线**的技巧，对序列扫描线，维护操作序列。则题目转化为：单点修改，查询在给定的 $c$ 下从初值为 $0$ 开始经过所有操作后的数值。

我们可以用线段树维护操作序列，使用**函数化**的思想，定义 $f(p,c,s)$ 表示经过线段树上节点 $p$ 代表的区间中的操作，初值为 $s$，上限为 $c$ 的结果。

直接维护二维信息肯定不可行，那怎么办？

我们先把二维平面建出来，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jyxifnva.png)

左边的坐标轴就是下限 $0$，黑色的斜线就是上限 $c$，红色是当前值域。

操作的本质就是把红色区域整体左移或整体右移，撞到墙就不动。

可以发现红色区域一定形如一条线 $+$ 一个斜着的三角形，其中最重要的点就是图中的紫色点（以下称为**关键点**）。线段树只需维护关键点即可。

关键点可以表示为一个三元组 $(c,x,k)$，有如下含义：

在上限 $C< c$ 时，**结果唯一，和初始值无关**；

在上限 $C\ge c$ 时：

$$f(p,C,s)= \begin{cases} k & s<x \\ k+s-x & x \le s \le x+C-c \\ k+C-c & s>x+C-c \end{cases}$$

接下来只需要解决两个问题，就能切掉这道 IOI 题：

### 1. 合并状态

容易发现状态可以等效于连续进行 $-x,+c,+k-c$ 三个操作。

直接对左儿子的状态连续进行右儿子的三个操作即可。具体见代码。

### 2. 查询答案

如果查询的 $C>c$，可以 $O(1)$ 计算。

如果是叶子节点，也能直接计算答案。

剩下可以都先计算左儿子再计算右儿子，但复杂度无法保证。

保证复杂度的关键是：**如果 $C<c_{rs}$，那么只需递归右儿子**。因为此时右儿子的结果唯一，和初始值无关。这样每次至多只有一边会递归下去，复杂度 $O(\log q)$。

总复杂度 $O((n+q)\log q)$。

## 代码：

细节比较少，注意开 long long。


```cpp
#include<iostream>
#include<vector>
#include<cmath>
#define N 200005
#define ll long long
using namespace std;
int n,q;
vector<int> pos[N],val[N];
struct SegmentTree{
	int l,r;
	ll c,x,k;
}t[N*4];
void build(int p,int l,int r){
	t[p].l=l;t[p].r=r;
	if(l==r) return;
	int mid=(l+r)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
void add(ll &c,ll &x,ll &k,ll v){
	if(v<0){
		c+=max(-v-k,0ll);
		x+=max(-v-k,0ll);
		k=max(k+v,0ll);
	}
	if(v>0){
		c=max(k+v,c);
		k+=v;
	}
}
void update(int p){
	ll c=t[p*2].c,x=t[p*2].x,k=t[p*2].k;
	add(c,x,k,-t[p*2+1].x);
	add(c,x,k,t[p*2+1].c);
	add(c,x,k,t[p*2+1].x-t[p*2+1].c);
	add(c,x,k,t[p*2+1].k-t[p*2+1].x);
	t[p].c=c,t[p].x=x,t[p].k=k;
}
void change(int p,int x,int k){
	if(t[p].l==t[p].r){
		t[p].c=abs(k);
		if(k==0) t[p].x=t[p].k=0;
		if(k<0) t[p].x=abs(k),t[p].k=0;
		if(k>0) t[p].x=0,t[p].k=k;
		return;
	}
	int mid=(t[p].l+t[p].r)/2;
	if(x<=mid) change(p*2,x,k);
	else change(p*2+1,x,k);
	update(p);
}
int ask(int p,int c,int s){
	if(c>=t[p].c){
		if(s<=t[p].x) return t[p].k;
		return t[p].k+min(s-t[p].x,c-t[p].c);
	}
	if(t[p].l==t[p].r){
		if(t[p].k==0) return s;
		if(t[p].k<0) return 0;
		return c;
	}
	if(c<t[p*2+1].c) return ask(p*2+1,c,s);
	return ask(p*2+1,c,ask(p*2,c,s));
}
std::vector<int> distribute_candies(
  	std::vector<int> c, std::vector<int> l,
  	std::vector<int> r, std::vector<int> v)
  	n=c.size(),q=l.size();
	for(int i=0;i<q;i++){
		pos[l[i]].push_back(i+1);
		val[l[i]].push_back(v[i]);
		pos[r[i]+1].push_back(i+1);
		val[r[i]+1].push_back(0);
	}
	build(1,1,q);
	vector<int> ans;
	for(int i=0;i<n;i++){
		for(int j=0;j<pos[i].size();j++){
			int x=pos[i][j],k=val[i][j];
			change(1,x,k);
		}
		ans.push_back(ask(1,c[i],0));
	}
	return ans;
}

```

---

## 作者：Leasier (赞：2)

Update on 2022.9.17：感谢 [Stinger](https://www.luogu.com.cn/user/361308)。

Update on 2022.9.18：感谢审核员 [_RSY_](https://www.luogu.com.cn/user/46197) 提出的建议。

前置芝士：[线段树](https://oi-wiki.org/ds/seg/)

对于每个元素 $i$，我们可以用类似下图的图形表示其变化：

![](https://cdn.luogu.com.cn/upload/image_hosting/gw7dv5oy.png)

这样的图形直接处理是很麻烦的，因为你不方便处理上下边界。

假如没有上下边界，我们可以如何对每个 $i$ 得到上述图形？

考虑以操作编号 $0 \sim q$ 为下标建线段树，从小到大处理每个 $i$。

在每个位置 $i$，我们需要对于所有 $l_j = i$，将下标 $j \sim q$ 加上 $v_j$，还要对于所有 $r_j + 1 = i$，将下标 $j \sim q$ 减去 $v_j$。这可以通过对修改差分来解决。

假如没有上界，我们可以如何算答案？

此时我们会注意到一个性质：**在已知上述图形的情况下，答案只与是否碰到过下边界以及最后一次碰到下边界的时间有关**。

1. 没有碰到下界

设**假装看不到下界的情况下**图形上下标 $i$ 对应的元素为 $s_i$，则答案为 $s_q$。

2. 最后一次碰到下界的时间为 $t$

答案为 $s_q - s_t$。

没有碰到下界的情况容易处理，但我们如何求出这个时间 $t$ 呢？

注意到 $s_t$ 为**假装看不到下界、$s_t < 0$ 且 $s_t$ 最小的情况下** $t$ 的最大值，于是可以线段树上二分求出。

现在我们加上上界。相比于只有下界的情况，有什么变化呢？

基于上面的经验，我们只需要关注最后**至多**两次碰到下界和上界即可。

若最后一次碰到了下界，此时 $\displaystyle\max_{j = 0}^t s_j - s_t> c_i$。最后一次碰到上界的情况类似。

这启发我们在线段树上二分找出一个尽量靠右的位置 $t'$，使 $[t', q]$ 的**绝对值最大子段和** $> c_i$，此时我们的 $t', t$ 分别为碰到下界和上界（有可能反过来）。

下文设 $maxs_i$ 表示 $\displaystyle\max_{j = i}^q (s_q - s_{j - 1})$，$mins_i$ 表示 $\displaystyle\min_{j = i}^q (s_q - s_{j - 1})$。

1. 当 $a_{t'} = s_{t'} - s_{t' - 1} < 0$

- $maxs_{t' + 1} > c_i$

在 $t'$ 时刻一定碰到了上边界，在 $t$ 时刻一定碰到了下界，则答案为 $c_i + (s_q - s_{t'}) - maxs_{t' + 1}$。

- $maxs_{t' + 1} \leq c_i$

在 $t'$ 时刻一定碰到了下边界，在 $t$ 时刻一定碰到了上界，则答案为 $(s_q - s_{t'}) - mins_{t' + 1}$。

2. 当 $a_{t'} = 0$

此时 $t' = 0$，即没有碰到过任何边界。

3. 当 $a_{t'} > 0$

类似于 $a_{t'} < 0$ 的情况。

- $mins_{t' + 1} < -c_i$

答案为 $(s_q - s_{t'}) - mins_{t' + 1}$。

- $mins_{t' + 1} \geq -c_i$

答案为 $c_i + (s_q - s_{t'}) - maxs_{t' + 1}$。

时间复杂度为 $O((n + q) \log q)$。

代码：
```cpp
#include <algorithm>
#include <vector>

using namespace std;

typedef long long ll;

typedef struct {
	int l;
	int r;
	ll sum;
	ll min_sum;
	ll max_sum;
} Node;

typedef struct {
	int id;
	int pos;
	int val;
} Query;

Node tree[800007];
Query query[400007];

bool operator <(const Query a, const Query b){
	return a.pos < b.pos;
}

void build(int x, int l, int r){
	tree[x].l = l;
	tree[x].r = r;
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(x * 2, l, mid);
	build(x * 2 + 1, mid + 1, r);
}

inline void update(int x){
	int ls = x * 2, rs = x * 2 + 1;
	tree[x].sum = tree[ls].sum + tree[rs].sum;
	tree[x].min_sum = min(tree[ls].min_sum, tree[rs].min_sum + tree[ls].sum);
	tree[x].max_sum = max(tree[ls].max_sum, tree[rs].max_sum + tree[ls].sum);
}

void add(int x, int pos, int val){
	if (tree[x].l == tree[x].r){
		tree[x].sum += val;
		tree[x].min_sum = min(tree[x].sum, 0ll);
		tree[x].max_sum = max(tree[x].sum, 0ll);
		return;
	}
	if (pos <= ((tree[x].l + tree[x].r) >> 1)){
		add(x * 2, pos, val);
	} else {
		add(x * 2 + 1, pos, val);
	}
	update(x);
}

ll do_query(int x, int k, ll cur_sum, ll cur_min_sum, ll cur_max_sum){
	if (tree[x].l == tree[x].r) return (tree[x].sum <= 0 && cur_max_sum > k) || (tree[x].sum > 0 && cur_min_sum >= -k) ? k + cur_sum - cur_max_sum : cur_sum - cur_min_sum;
	int rs = x * 2 + 1;
	ll y = min(tree[rs].min_sum, cur_min_sum + tree[rs].sum), z = max(tree[rs].max_sum, cur_max_sum + tree[rs].sum);
	if (z - y > k) return do_query(rs, k, cur_sum, cur_min_sum, cur_max_sum);
	return do_query(x * 2, k, cur_sum + tree[rs].sum, y, z);
}

vector<int> distribute_candies(vector<int> c, vector<int> l, vector<int> r, vector<int> v){
	int n = c.size(), q = l.size(), m = 0;
	vector<int> ans;
	c.insert(c.begin(), 0);
	l.insert(l.begin(), 0);
	r.insert(r.begin(), 0);
	v.insert(v.begin(), 0);
	build(1, 0, q);
	for (register int i = 1; i <= q; i++){
		m++;
		query[m].id = i;
		query[m].pos = ++l[i];
		query[m].val = v[i];
		if (++r[i] < n){
			m++;
			query[m].id = i;
			query[m].pos = r[i] + 1;
			query[m].val = -v[i];
		}
	}
	sort(query + 1, query + m + 1);
	for (register int i = 1, j = 1; i <= n; i++){
		while (j <= m && query[j].pos == i){
			add(1, query[j].id, query[j].val);
			j++;
		}
		ans.push_back(do_query(1, c[i], 0, 0, 0));
	}
	return ans;
}
```

---

## 作者：Mirasycle (赞：1)

对于单个盒子算出其不记 chkmin 和 chkmax 影响的前缀和序列 $s_i$。特判掉整个过程不触碰上界和下界的情况。

如果抛弃上界，只考虑下界可以发现对于 $i$ 如果能触及底部，需要满足 $s_i<\min\limits_{j<i} s_j$，本质是下界在 $\{s_i\}$ 值域上的不断下移（每次下降到 $0$ 之后都让其上升到 $0$，那么相对来说也等价于 $0$ 这个界向下平移）。所以只考虑一个下界的时候，答案就是 $s_q-\min s_i$。

对于只有上界的情况，同理答案是 $C-(\max s_i-s_q)=C+s_q-\max s_i$。

现在需要加入一个上界的限制，也就是说我们需要找到最后一次碰到上界的时间，后面就是只有下界了，或者找到最后一次碰到下界这样子后面只需要考虑上界。而且有一个好处就是，某次碰到上界之后，我们不需要考虑之前下界的影响，某次碰到下界之前，我们不需要考虑之前上界的影响。

找到最后出现的某个界这个问题不好直接做，有一个巧妙的解决方法是找到最靠后的一段后缀，使得其极差 $> C$，由于极差已经大于双界距离了，所以这个位置肯定是在两个不同界之间的，由于是最靠后的位置，所以这两个不同界中前面那个界必定是最后出现的上界/下界。

这个最短后缀可以二分出来，假设后缀为 $[x,n]$。上面说过了，某次触碰到一种界之后，另外一种界在此之前的影响都可以不计了。所以我们只需要在 $[x,n]$ 中执行第一段的算法即可。

如果 $x$ 是后缀最大值，那么最后一个上界已经出现过了，我们只需要找到后缀最小值 $\rm {mn}$ 就行了，然后根据第一段的算法答案就是 $s_q-\rm mn$。

如果 $x$ 是后缀最小值，那么最后一个下界已经出现过了，我们只需要找到后缀最大值 $\rm mx$ 即可。同理，答案就是 $C-\rm {mx}+s_q$。

建立下标为 $[1,q]$ 的线段树，对于盒子编号进行扫描线，动态维护每个盒子每时刻的 $s_i$。

时间复杂度 $O(n\log n)$。


```cpp
#include<bits/stdc++.h>
//#include "candies.h"
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int maxn=2e5+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
struct OP{
	int l,r,v;
}op[maxn];
int n,m,c[maxn]; vi ans;
vector<pair<int,int> > vec[maxn];
struct SegmentTree{
	#define ls (p<<1)
	#define rs (p<<1|1)
	#define mid (l+r>>1)
	ll mx[maxn<<2],mn[maxn<<2],tag[maxn<<2];
	void init(){ for(int i=1;i<=4*n;i++) mx[i]=mn[i]=tag[i]=0; }
	void upd(int p,ll v){ mx[p]+=v; mn[p]+=v; tag[p]+=v; }
	void pushdown(int p){
		if(!tag[p]) return ;
		upd(ls,tag[p]); upd(rs,tag[p]); tag[p]=0;
	}
	void pushup(int p){ mx[p]=max(mx[ls],mx[rs]); mn[p]=min(mn[ls],mn[rs]); }
	void modify(int p,int l,int r,int ql,int qr,int v){
		if(ql<=l&&r<=qr){ upd(p,v); return ; }
		pushdown(p);
		if(ql<=mid) modify(ls,l,mid,ql,qr,v);
		if(qr>mid) modify(rs,mid+1,r,ql,qr,v);
		pushup(p);
	}
	ll getmn(int p,int l,int r,int x){
		if(x<=l) return mn[p]; pushdown(p);
		if(x<=mid) return min(getmn(ls,l,mid,x),getmn(rs,mid+1,r,x));
		else return getmn(rs,mid+1,r,x);
	}
	ll getmx(int p,int l,int r,int x){
		if(x<=l) return mx[p]; pushdown(p);
		if(x<=mid) return max(getmx(ls,l,mid,x),getmx(rs,mid+1,r,x));
		else return getmx(rs,mid+1,r,x);
	}
	ll get(int p,int l,int r,int x){
		if(l==r) return mn[p]; pushdown(p);
		if(x<=mid) return get(ls,l,mid,x);
		else return get(rs,mid+1,r,x);
	}
}seg;
int find(int C){
	int l=0,r=m;
	while(l<r){
		int M=(l+r+1)>>1;
		if(seg.getmx(1,0,m,M)-seg.getmn(1,0,m,M)>C) l=M;
		else r=M-1;
	}
	return l;
}
vi distribute_candies(vi C,vi L,vi R,vi V){
	n=C.size(); m=L.size();
	for(int i=1;i<=n;i++) c[i]=C[i-1];
	for(int i=1;i<=m;i++){
		vec[L[i-1]+1].pb(V[i-1],i);
		vec[R[i-1]+2].pb(-V[i-1],i);
	}
	seg.init();
	for(int i=1;i<=n;i++){
		for(auto z:vec[i]) seg.modify(1,0,m,z.se,m,z.fi);
		ll val=seg.getmn(1,0,m,m);
		if(seg.mx[1]-seg.mn[1]<=c[i]){ ans.pb(val-min(seg.mn[1],0ll)); continue; }
		int x=find(c[i]);
		ll mn=seg.getmn(1,0,m,x),mx=seg.getmx(1,0,m,x);
		if(seg.get(1,0,m,x)==mx) ans.pb(val-mn);
		else ans.pb(c[i]-mx+val);
	}
	return ans;
}
```

---

## 作者：Purslane (赞：1)

# Solution

这是咋评上黑的。

首先，考虑如果 $C_i = +\infty$，怎么做。

从左到右扫描每个位置 $p$。如果第 $i$ 个修改和 $p$ 位置有关，那么记 $\Delta_i = V_i$，否则 $\Delta_i = 0$。

显然可以将 $\rm checkmax$ 操作拆开。答案显然是：

$$
\max_{0 \le i \le q} \sum_{j \ge i} \Delta_j
$$

记 $pre_i = \sum_{j \le i} \Delta_j$，显然就是 $pre_q - \min_{0 \le i \le q} pre_i$。

回到本题。

记 $pre$ 数组的极差为 $\Delta$。如果 $\Delta \le C_p$，我们证明：上界是没用的。因为只考虑 $\rm checkmax$ 操作，时刻 $i$ 拥有的糖果就是 $pre_i - \min_{j \le i} pre_j$ 个。显然这个数一直 $\le C_p$，所以用不上上界。

否则，考虑找到 $pre$ 最短的后缀，使得其极差 $> C_p$。不妨设这个位置为 $j$。

分为两种情况：

1. $pre_j$ 是 $pre$ 的后缀最小值，设 $pre_t$ 是 $\ge j$ 的位置中 $pre$ 最大值。则无论经过前 $j$ 个操作拥有多少个糖果，时刻 $t$ 一定拥有 $C_i$ 个糖果（由于你保证了这个后缀是“第一个”，所以 $j+1$ 位置之后不会出现极差 $>C$ 的情况。因此第一次碰到上界之后，下界就没用了，可以不考虑。）而 $pre_t$ 是后缀最大值，因此之后上界也没用了，所以直接将 $C_p - pre_t+pre_q$ 作为答案；
2. $pre_j$ 是 $pre$ 的后缀最大值。那么设 $pre_t$ 是后面位置中的最小值，则 $t$ 时刻一定拥有 $0$ 颗糖果，将 $pre_q - pre_t$ 作为答案。

当 $p \leftarrow p+1$ 的时候，我们对 $pre$ 进行后缀加减、维护区间最值。使用线段树容易维护。找第一个后缀可以使用线段树上二分，但是我偷懒写了二分+线段树，复杂度 $O(n \log^2 n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10;
int n,q;
ll mn[MAXN<<2],mx[MAXN<<2],tag[MAXN<<2];
vector<int> upd[MAXN];
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void assign(int k,int l,int r,ll v) {return mn[k]+=v,mx[k]+=v,tag[k]+=v,void();}
void push_down(int k,int l,int r) {return assign(lson,l,mid,tag[k]),assign(rson,mid+1,r,tag[k]),tag[k]=0,void();}
void update(int k,int l,int r,int x,int y,int v) {
	if(x<=l&&r<=y) return assign(k,l,r,v),void();
	push_down(k,l,r);
	if(x<=mid) update(lson,l,mid,x,y,v);
	if(y>mid) update(rson,mid+1,r,x,y,v);
	return mn[k]=min(mn[lson],mn[rson]),mx[k]=max(mx[lson],mx[rson]),void();
}
pair<ll,ll> query(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) return {mn[k],mx[k]};
	push_down(k,l,r);
	if(y<=mid) return query(lson,l,mid,x,y);
	if(x>mid) return query(rson,mid+1,r,x,y);
	auto p1=query(lson,l,mid,x,y),p2=query(rson,mid+1,r,x,y);
	return {min(p1.first,p2.first),max(p1.second,p2.second)};	
}
vector<int> distribute_candies(vector<int> C,vector<int> L,vector<int> R,vector<int> V) {
	vector<int> aans;
	n=C.size(),q=L.size();
	ffor(i,0,q-1) upd[L[i]].push_back(i+1),upd[R[i]+1].push_back(-i-1);
	ll tot=0;
	ffor(i,0,n-1) {
		for(auto id:upd[i]) {
			if(id>0) update(1,0,q,id,q,V[id-1]),tot+=V[id-1];
			else update(1,0,q,-id,q,-V[-id-1]),tot-=V[-id-1];	
		}
		if(mx[1]-mn[1]<=C[i]) aans.push_back(tot-mn[1]);
		else {
			int ans=0,l=1,r=q;
			while(l<=r) {
				auto pr=query(1,0,q,mid,q);
				if(pr.second-pr.first>=C[i]) ans=mid,l=mid+1;
				else r=mid-1;	
			}
			auto pr=query(1,0,q,ans,q),Pr=query(1,0,q,ans,ans);
			if(Pr.first==pr.first) aans.push_back(C[i]-pr.second+tot);
			else aans.push_back(tot-pr.first);
		}
	}
	return aans;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P8518)

**题目大意**

> 序列 $a_1\sim a_n$，初始全为零，进行 $q$ 次区间加，每次操作后 $a_i\gets \max(0,\min(a_i,c_i))$，求最终的 $a$。
>
> 数据范围：$n\le 2\times 10^5$。

**思路分析**

首先可以想到对 $i$ 扫描线，对时间轴建立线段树。

那我们就要找到最后一个 $a_i<0$ 或 $a_i>c$ 的时刻。

如果 $c_i=\infty$，则最后一个时刻一定是最小前缀和的位置。

否则如果碰到先后过上界和下界，找到最小的后缀 $[p,q]$ 使得这个范围内的最大子段和 $>c$ 或最小子段和 $<-c$。

那么操作 $p$ 之后，$[p+1,q]$ 的部分只会碰到上界或下界中的一个，用上面的方法维护总和以及最大最小前缀和即可。

线段树上二分维护该过程。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "candies.h"
#define ll long long
using namespace std;
const int MAXN=2e5+5;
int n,q;
struct info {
    ll mn,mx,su;
    inline friend info operator +(const info &u,const info &v) {
        return {min(u.mn,u.su+v.mn),max(u.mx,u.su+v.mx),u.su+v.su};
    }
};
struct SegmentTree {
    info tr[1<<19];
    void psu(int p) { tr[p]=tr[p<<1]+tr[p<<1|1]; }
    void set(int u,int x,int l=0,int r=q,int p=1) {
        if(l==r) return tr[p]=info{min(0,x),max(0,x),x},void();
        int mid=(l+r)>>1;
        u<=mid?set(u,x,l,mid,p<<1):set(u,x,mid+1,r,p<<1|1);
        psu(p);
    }
    int qry(int c,info o,int l=0,int r=q,int p=1) {
        if(l==r) {
            if(tr[p].su<=0) return o.mx>c?c+o.su-o.mx:o.su-o.mn;
            else return o.mn<-c?o.su-o.mn:c+o.su-o.mx;
        }
        int mid=(l+r)>>1; info t=tr[p<<1|1]+o;
        if(t.mx-t.mn>c) return qry(c,o,mid+1,r,p<<1|1);
        else return qry(c,t,l,mid,p<<1);
    }
}   T;
vector <array<int,2>> op[MAXN];
vector<int> distribute_candies(vector<int>c,vector<int>l,vector<int>r,vector<int>v) {
    n=c.size(),q=l.size();
    for(int i=0;i<q;++i) op[l[i]].push_back({i+1,v[i]}),op[r[i]+1].push_back({i+1,0});
    vector <int> ans(n);
    for(int i=0;i<n;++i) {
        for(auto o:op[i]) T.set(o[0],o[1]);
        ans[i]=T.qry(c[i],{0,0,0});
    }
    return ans;
}
```

---


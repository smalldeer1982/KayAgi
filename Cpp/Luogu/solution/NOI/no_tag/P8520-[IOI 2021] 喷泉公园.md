# [IOI 2021] 喷泉公园

## 题目背景

# 滥用本题评测将被封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。但是你的代码需要声明 `void build(std::vector<int> u, std::vector<int> v, std::vector<int> a, std::vector<int> b)` 函数。

具体的，以下是一种模板：
```cpp
#include <vector>

void build(std::vector<int> u, std::vector<int> v, std::vector<int> a, std::vector<int> b);

int construct_roads(std::vector<int> x, std::vector<int> y) {
    // Code here...
}
```

由于洛谷技术限制，本题仅包含 IOI 官方数据的部分测试点。

## 题目描述

在附近的一个公园里，有 $n$ 座**喷泉**，编号为从 $0$ 到 $n - 1$。我们把喷泉看成是二维平面上的点。也就是说，喷泉 $i ~ (0 \leq i \leq n - 1)$ 是一个点 $(x _ i, y _ i)$，这里 $x _ i$ 和 $y _ i$ 是**偶数**。喷泉的位置各不相同。

建筑师 Timothy 受雇来规划一些**道路**的建设，以及每条道路对应的长椅的摆放。每条道路都是一个长度为 $2$ 的**横向**或**纵向**的线段，其端点是两座不同的喷泉。游客应该能够沿着它们即可在任意两座喷泉之间互相抵达。在最开始时，公园里没有任何道路。

对于每条道路，都要在公园里摆放恰好一个长椅，并将其**分配给**（也就是面朝）这条道路。每个长椅必须摆放在某个点 $(a, ~ b)$ 上，这里 $a$ 和 $b$ 都是**奇数**。所有长椅的位置必须都是**不同的**。在 $(a, ~ b)$ 处的长椅，只能分配给两个断电均为 $(a - 1, ~ b - 1), (a - 1, ~ b + 1), (a + 1, ~ b - 1)$ 和 $(a + 1, ~ b + 1)$ 其中之一的道路。举例来说，在 $(3, ~ 3)$ 处的长椅只能分配给下面四条线段所表示的道路之一：$(2, ~ 2), - (2, ~ 4), ~ (2 , ~ 4) - (4, ~ 4), ~ (4, ~ 4) - (4, ~ 2), ~ (4, ~ 2) - (2, ~ 2)$。

请帮助 Timothy 判断一下，能否在满足上述所有要求的前提下，造出所有道路，并摆放和分配长椅。如果这能做到，请给他一个可行的解决方案。如果有多个满足所有要求的方案，你可以报告其中的任意方案。

## 说明/提示

**例 1**

考虑如下调用：
```cpp
construct_roads([4, 4, 6, 4, 2], [4, 6, 4, 2, 4])
```

这意味着总共有 $5$ 座喷泉：

- 喷泉 $0$ 坐落在 $(4, 4)$ 处。
- 喷泉 $1$ 坐落在 $(4, 6)$ 处。
- 喷泉 $2$ 坐落在 $(6, 4)$ 处。
- 喷泉 $3$ 坐落在 $(4, 2)$ 处。
- 喷泉 $4$ 坐落在 $(2, 4)$ 处。

可以建造下面这样 $4$ 条道路，其中每条道路连接两座喷泉，并且摆放着对应的长椅。

| 道路编号 | 道路所连接的喷泉编号 | 所分配的长椅的位置 |
| :----------: | :----------: | :----------: |
| $0$ | $0, 2$ | $(5, 5)$ |
| $1$ | $0, 1$ | $(3, 5)$ |
| $2$ | $3, 0$ | $(5, 3)$ |
| $3$ | $4, 0$ | $(3, 3)$ |

该方案对应下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/s7vv14bj.png)

为报告此方案，`construct_roads` 应做如下调用：

```cpp
build([0, 0, 3, 4], [2, 1, 0, 0], [5, 3, 5, 3], [5, 5, 3, 3])
```

随后它应当返回 $1$，

注意，在这个例子中，有多个满足要求的方案，它们都被视为正确。

**例 2**

考虑如下调用：

```cpp
construct_roads([2, 4], [2, 6])
```

喷泉 $0$ 坐落在 $(2, 2)$ 处，而喷泉 $1$ 坐落在 $(4, 6)$ 处。由于不可能建造出满⾜要求的道路，
`construct_roads` 应当返回 $0$，并且不做 `build` 的任何调⽤。

**约束条件**

- $1 \leq n \leq 2 \times 10 ^ 5$
- $2 \leq x[i], y[i] \leq 2 \times 10 ^ 5$
- $x[i], y[i]$ 都是偶数。
- 任意两座喷泉的位置都不相同。

**子任务**

1. （$5$ 分）$x[i] = 2$
2. （$10$ 分）$2 \leq x[i] \leq 4$
3. （$15$ 分）$2 \leq x[i] \leq 6$
4. （$20$ 分）至多只有一种道路建设方案，能够让游客在任意两座喷泉之间沿着这些道路即可抵达。
5. （$20$ 分）任意四座喷泉都不会构成某一个 $2 \times 2$ 正方形的四个顶点。
6. （$30$ 分）没有额外的约束条件。

## 样例 #1

### 输入

```
5
4 4
4 6
6 4
4 2
2 4
```

### 输出

```
1
4
0 2 5 5
0 1 3 5
3 0 5 3
4 0 3 3
```

## 样例 #2

### 输入

```
2
2 2
4 6
```

### 输出

```
0
```

# 题解

## 作者：swiftc (赞：3)

考虑将所有放长椅的地方黑白染色，黑色的只连横着的边，白色的只连竖着的边，考虑从上到下，从左到右加入所有边，并尽量保证我们当前的图与所有边都加入的图连通性相同，黑色块上面的边和白色块左面的边一定能加入，只需要考虑两种情况：

- 黑色块下面的边

![](https://cdn.luogu.com.cn/upload/image_hosting/8fzpc7kh.png)

此时三条绿色的边一定已经（可能以等价形式）加入，这条边一定不用加入。

- 白色块右面的边

![](https://cdn.luogu.com.cn/upload/image_hosting/2kp1r9fm.png)

此时两条绿色的边已经加入，而蓝色的边因为在黑色块上面而一定能加入，于是这条边也不用加入。

所以从实现上来说只需要依次检验所有边是否能加入即可。

```cpp
// #include "parks.h"
#include <algorithm>
#include <functional>
#include <iostream>
#include <map>
#include <vector>
using namespace std;
void build(vector<int> u, vector<int> v, vector<int> a, vector<int> b);
int construct_roads(vector<int> x, vector<int> y) {
  int n = x.size();
  vector<int> f(n, 0);
  for (int i = 0; i < n; i++)
    f[i] = i;
  function<int(int)> gf = [&](int x) {
    return f[x] == x ? x : f[x] = gf(f[x]);
  };
  vector<pair<int, int>> v;
  map<pair<int, int>, int> mp, used;
  for (int i = 0; i < n; i++)
    mp[{x[i], y[i]}] = i, v.push_back({x[i], y[i]});
  sort(v.begin(), v.end(), [&](auto a, auto b) {
    if (a.second != b.second)
      return a.second > b.second;
    return a.first < b.first;
  });
  vector<int> vu, vv, va, vb;
  for (auto [x, y] : v) {
    if (mp.count({x + 2, y})) {
      int u = mp[{x, y}], v = mp[{x + 2, y}];
      if (gf(u) != gf(v)) {
        int cx = x + 1, cy = y + 1;
        if (((cx / 2) + (cy / 2)) & 1)
          cy -= 2;
        if (used.count({cx, cy}))
          continue;
        used[{cx, cy}] = 1;
        vu.push_back(u), vv.push_back(v), va.push_back(cx), vb.push_back(cy);
        f[gf(u)] = gf(v);
      }
    }
    if (mp.count({x, y - 2})) {
      int u = mp[{x, y}], v = mp[{x, y - 2}];
      if (gf(u) != gf(v)) {
        int cx = x + 1, cy = y - 1;
        if (!(((cx / 2) + (cy / 2)) & 1))
          cx -= 2;
        if (used.count({cx, cy}))
          continue;
        used[{cx, cy}] = 1;
        vu.push_back(u), vv.push_back(v), va.push_back(cx), vb.push_back(cy);
        f[gf(u)] = gf(v);
      }
    }
  }
  bool flag = 1;
  for (int i = 1; i < n; i++)
    flag &= (gf(i) == gf(0));
  if (!flag)
    return 0;
  build(vu, vv, va, vb);
  return 1;
}

```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P8520)

**题目大意**

> 给定网格上的 $n$ 个格点，求这些点的一棵生成树，并给每条边匹配一个相邻的方格，要求每个方格至多匹配一条边，构造方案。
>
> 数据范围：$n\le 2\times 10^5$。

**思路分析**

考虑没有方格的四个顶点都在点集内的的情况，则生成树唯一。

一个想法是把方格黑白染色，黑格子只匹配竖边，白格子只匹配横边，此时每条边恰有唯一可能的格子。

由于每个方格周围四个顶点不全被选，因此直接匹配不会冲突。

对于一般的情况，如果一个黑格子左右都有竖边，那么把一条竖边换成一条原先没有的横边即可。

为了让加入的横边不继续导出矛盾，我们从下到上从左到右考虑每条边，始终保证尽量连通。

如果 $(x-2,y-2),(x-2,y)$ 以及 $(x,y-2),(x,y)$ 同时存在，那么删掉 $(x,y-2),(x,y)$ 加入 $(x-2,y),(x,y)$。

如果 $(x-2,y),(x,y)$ 以及 $(x-2,y-2),(x,y-2)$ 同时存在，说明此前 $(x-2,y),(x,y)$ 不连通，但这两条竖边刚刚一定被加入了，因此矛盾。

因此从下到上构造，贪心加入每条边一定合法。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "parks.h"
using namespace std;
const int MAXN=2e5+5;
vector <array<int,2>> p[MAXN];
unordered_map <int,int> id[MAXN],vis[MAXN];
int dsu[MAXN];
int find(int x) { return dsu[x]^x?dsu[x]=find(dsu[x]):x; }
int construct_roads(vector<int>X,vector<int>Y) {
    int n=X.size(); iota(dsu,dsu+n,0);
    for(int i=0;i<n;++i) p[Y[i]].push_back({X[i],i}),id[X[i]][Y[i]]=i;
    vector <int> wu,wv,wa,wb;
    auto link=[&](int u,int v,int x,int y) {
        wu.push_back(u),wv.push_back(v),wa.push_back(x),wb.push_back(y);
        dsu[find(u)]=find(v),vis[x][y]=1;
    };
    for(int y=0;y<MAXN;y+=2) {
        sort(p[y].begin(),p[y].end());
        for(auto o:p[y]) {
            int x=o[0],u=o[1];
            if(!id[x].count(y-2)) continue;
            int v=id[x][y-2];
            if(find(u)==find(v)) continue;
            if((x/2+(y-2)/2)&1) link(u,v,x+1,y-1);
            else if(!vis[x-1].count(y-1)) link(u,v,x-1,y-1);
            else link(u,id[x-2][y],x-1,y+1);
        }
        for(auto o:p[y]) {
            int x=o[0],u=o[1];
            if(!id[x-2].count(y)) continue;
            int v=id[x-2][y];
            if(find(u)==find(v)) continue;
            if(~((x-2)/2+y/2)&1) link(u,v,x-1,y+1);
            else if(!vis[x-1].count(y-1)) link(u,v,x-1,y-1);
            else assert(0);
        }
    }
    for(int i=1;i<n;++i) if(find(i)!=find(0)) return 0;
    build(wu,wv,wa,wb);
    return 1;
}
```

---


# [JRKSJ R7] 五彩斑斓的曙光

## 题目背景

题目名称由 fjy666 提供，背景 TBD.

## 题目描述

给您一个长度为 $n$ 的序列 $a$，请您支持 $m$ 次操作：

1. 将 $[l,r]$ 区间中 $> x$ 的数减去 $x$。
2. 求 $[l,r]$ 区间中 $\le x$ 的数的个数。

## 说明/提示

Idea：Ntokisq&nzhtl1477，Solution：Ntokisq，Code：Ntokisq，Data：Ntokisq

### 样例解释

样例 $1$ 未加密前：

```cpp
10 10
20 10 20 14 4 15 11 20 2 13
2 5 9 1
1 7 8 2
1 2 3 8
1 4 6 12
2 1 7 9
2 2 7 17
2 3 9 2
2 8 9 5
1 3 10 1
2 8 9 6
```
样例 $2$ 未加密前：

```cpp
5 5
6 10 3 4 7
1 1 3 3
1 3 4 3
2 3 5 3
1 1 3 9
2 2 3 7
```



### 数据规模

本题采用捆绑测试。
| $\text{Subtask}$ | $n\le$ | $m\le$ | $\text{Score}$ | 时间限制 |
| :----------: | :----------: | :----------: | :----------: |  :----------: | 
| $1$ | $10^4$ | $10^4$ | $10$ | $\text{1s}$ |
| $2$ | $3\times 10^5$ | $3\times 10^5$ | $30$ | $\text{5s}$ |
| $3$ | $7\times 10^5$ | $5\times 10^5$ | $60$ | $\text{20s}$ |

对于 $100\%$ 的数据，$1\le n \le 7\times 10^5$，$1\le m\le  5\times 10^5$，$1\le a_i,x\le 10^9$，$1\le l\le r\le n$。

### 提示

如果您认为您的算法时间复杂度正确但常数过大，您可以使用同样思路但时间复杂度略高、常数小的算法。

## 样例 #1

### 输入

```
10 10
20 10 20 14 4 15 11 20 2 13 
2 5 9 1
1 7 8 2
1 2 3 8
1 4 6 12
2 1 7 9
2 2 7 20
2 3 9 4
2 8 9 7
1 3 10 0
2 8 9 7```

### 输出

```
0
5
6
2
1
1```

## 样例 #2

### 输入

```
5 5
6 10 3 4 7 
1 1 3 3
1 3 4 3
2 3 5 3
1 1 3 11
2 2 3 5```

### 输出

```
2
2```

# 题解

## 作者：critnos (赞：17)

$w=\Theta(\log n)$，$O(n\sqrt n)$。

显然该问题不弱于区间加区间 rank，考虑 $O(n\sqrt n)$ 做法。

对值域 $b$ 为底数分块，即块为 $[b^0,b^1),[b^1,b^2)\dots$，每块维护值域在该块内的数，共有 $\log_b v=\dfrac w {\log b}$ 块。

取常数 $k>0$，令 $b=n^k$，则共有 $\dfrac w {\log b}=\dfrac w {k\log n}=O(\dfrac 1 k)$ 块。 即 $O(1)$ 块。

容易发现，每次存在三种情形：

1. 不变
2. 被减去 $x$，但所属块不变
3. 被减去 $x$，所属块变

显然，对于 $x$ 所属的块会发生三种情形。该块内的数显然经过 $O(b)$ 次情形 $2$ 后就会发生情形 $3$。对于每个数会发生 $O(1)$ 次情形 $3$，那么会发生 $O(b)$ 次情形 $2$。

对小于 $x$ 的块只会发生情形 $1$，忽略。对大于 $x$ 的块会发生情形 $2,3$。

对块维护线段树，可以识别三种情形的发生。

那么问题其实是：

1. $O(nb)$ 次单点修改（情形 $2$）
2. $O(n)$ 次区间 rank（查询）
3. $O(n)$ 次区间减（情形 $3$）

我们希望做到 $O(n\sqrt n)$，那么操作 $1$ 需要 $o(\sqrt n)$。

对序列分块，块长为 $\Theta(\sqrt n)$。每次单点修改累计在一个块内，用另一个数据结构用同样的分块结构进行维护，直到该块内有 $b$ 次单点修改就对原块进行重构。

用线段树上分散层叠维护，这是 well-known 的。单点修改用另一个数据结构维护时需要抵消原数贡献。另一个数据结构中每块有 $O(b)$ 个数，每 $\Theta(b)$ 次修改重构该块，同样用线段树上分散层叠维护，修改时间复杂度 $O(b)$，查询时间复杂度 $O(\sqrt n)$，重构单块次数为 $O(n)$，所以重构时间复杂度为 $O(n\sqrt n)$。这里大小为 $O(b)$ 的分块起到了缓存的作用。

时间复杂度 $O(n\sqrt n+nb^2)$，取 $k\in(0,0.25]$ 即可 $O(n\sqrt n)$。
 
于是我们解决了问题，甚至在线线性空间。

实际实现使用的是平凡的二分做法，时间复杂度 $O(n\sqrt{n\log n})$，因为分散层叠的常数会和 $4\log_n w$ 相乘，大概不能要了，二分反而能微调块长。

---

## 作者：zesqwq (赞：6)

upd: 之前提交记录里的代码好像有 $>$ 写了个 $\ge$ 但是通过题目了，现在链接里的代码应该是正确的。

是一道不错的套路题，下文中为了方便书写认为 $nq$ 同阶，该做法与官方题解不太相同。

对于操作 $1$，我们发现如下性质：

1. 对于 $[1,x]\cup(2x,\inf]$ 中的数，他们的相对顺序不变；
2. 对于 $(x,2x]$ 中的数，他们经过这次操作后它们至少减半，也就是说该类型的操作不会超过 $O(n \log V)$ 次。

---

一个粗糙的做法：

考虑每 $B$ 个数分一块，每个块中用平衡树维护，每次修改对于第二部分的数直接暴力取出重新插入回平衡树，复杂度 $O(n\log V\log n)$；对于第一部分的数因为相对顺序不变，所以不会改变平衡树形态，可以直接打区间减标记，对于小块则直接将平衡树转化为排序后的序列，然后归并排序，然后再建树，复杂度 $O(B+\dfrac  n B \log n)$。

取 $B = \sqrt{n \log n}$ 即可取到最优复杂度 $O(n\sqrt{n\log n} + n \log V \log n)$。

但是因为平衡树常数太大，即使是在 $20\text s$ 的时限下也不足通过。

---

一个精细的做法：

考虑尝试使用树状数组代替平衡树，首先你要会树状树组的线性建立和转化为前缀和数组的形式的方法，然后我们可以使用树状数组维护每一块排序后的差分，那么查询可以和修改的第一部分可以对于整块树状树组上二分，对于小块把树状树组拍回排序后的数组解决问题的。

考虑如何处理修改的第二部分，树状树组不支持删除，所以对每一块我们再开一个大小为 $s$ 缓存，每次删除数的时候，就先找到对应要删除的区间 $(x,2x]$，然后把该值域中的数先取出至缓存中，然后都变为 $x$，并且打上代表已经消失了的标记。

对于缓存中的数，因为其总量不会超过 $O(\dfrac{ns}B)$ 个，所以可以暴力做修改与查询，当缓存中的数超过 $s$ 时，则将缓存与块重构。

现在分析时间复杂度，重构可以用树状树组的线性建立，而重构次数是 $O(n+\dfrac{n\log V}s)$ 其中 $O(n)$ 来源于散块修改，重构复杂度是 $O(B)$ 的；查询复杂度是 $O(\dfrac n B \log n + \dfrac n Bs)$ 的；修改复杂度是类型一 $O(\dfrac n B s + \dfrac n B \log n)$，类型  $2$ 每个数不会超过 $O(n \log V)$ 次，每次至多会推平额外 $O(s)$ 个数，单点复杂度树状树组是 $O(\log n)$ 的，因此复杂度是 $O(ns \log V \log n)$ 的（当然也可以做到 $O(n\log V\log n)$，但由于实际测试中要多一些判断导致其甚至跑不过该复杂度，因此在下文提及），取 $s = O(\log n), B = O(\sqrt{n\log n})$。

时间复杂度 $O(n \sqrt {n \log n} + n \log^2n \log V)$，但是由于最后的三个 $\log$ 常数都非常非常小，因此可以通过。


由于时间比较紧，所以如果被卡常了加一些剪枝即可通过。

[code](https://www.luogu.com.cn/paste/o49d3vw5)

接下来写一下如何把 $O(n \log^2 n \log V)$ 做法变为 $O(n \log n \log V)$，你发现额外的缓存中的 $s$ 个数实际上只有相邻前后不再缓存里才有意义，于是你修改操作 $2$ 的时候，在树状树组上可以跳过那些前后都在缓存里的更新的差分（因为本质上没更新），这样复杂度就做到了 $O(n \log n\log V + n \sqrt{n \log n})$。

---


# [北大集训 2021] 魔塔 OL

## 题目背景

CTT2021 D1T2

## 题目描述

比特游戏公司最近发布了一款新游戏《魔塔 Online》，玩家可以操控勇士在游戏世界中与怪物进行搏斗。在游戏发布之初，魔塔里没有任何怪物，接下来将依次发生 $q$ 个事件，每个事件是以下三种之一：

* `+ x y z a b`：表示游戏发布了新版本，在游戏中新增了一只怪物。如果这是第一只新增的怪物，那么它的编号为 $1$；否则它的编号为最后一只新增的怪物的编号 $+1$。这只怪物位于魔塔的第 $x$ 层，它的等级为 $y$ 级，它的难度为 $z$。如果玩家选择击杀这只怪物，那么需要消耗 $a$ 点血量，在击杀成功后，玩家将得到一支可以恢复 $b$ 点血量的药剂并立即使用。
* `- k`：表示游戏发布了新版本，编号为 $k$ 的怪物由于平衡性问题下架，它将不会出现在魔塔中。请注意：下架的怪物**仍然保留它们的编号**，未来新增的怪物**不会复用**被下架怪物的编号。
* `? g l d`：表示一个询问。某玩家希望击杀魔塔前 $g$ 层中**所有**等级**不超过** $l$ 且难度**不超过** $d$ 的怪物。玩家可以按照**任意顺序**去击杀这些怪物，登上新的一层**不需要杀光**当前层的所有怪物，且作战过程中不会受到别的怪物的干扰。你的任务是帮助该玩家计算出征前勇士的血量**最少**是多少。如果某个时刻勇士的血量是**负数**，那么游戏结束，你一定要防止这种情况的发生。

请写一个程序，依次回答每个询问。注意：每个询问只是玩家的一个思考，**不会真正击杀**任何一只怪物。

## 说明/提示

1. （3 分）怪物总数不超过 $8$，询问数量不超过 $8$。
2. （7 分）怪物总数不超过 $5\,000$，询问数量不超过 $5\,000$。
3. （10 分）药剂不会回血，且所有怪物的难度都是 $1$。即 $b=0$，且 $z=d=1$。
4. （17 分）$1\leq x,y,z,g,l,d\leq 5$。
5. （30 分）所有怪物的等级和难度都是 $1$。即 $y=z=l=d=1$。
6. （33 分）无其他限制。


## 样例 #1

### 输入

```
10
+ 2 1 1 3 4
+ 1 2 2 2 5
? 2 2 2
+ 1 1 1 8 2
? 2 2 1
? 1 2 2
- 1
? 2 2 2
- 3
? 1 2 2
```

### 输出

```
2
7
5
5
2
```

# 题解

## 作者：Alex_Wei (赞：5)

#### D1T2. [P8985 [北大集训 2021] 魔塔 OL](https://www.luogu.com.cn/problem/P8985)

问题的一个子问题是经典的贪心：Monster Hunter，以下记作 MH。它的解法是：对于 $a_i\leq b_i$，我们放到前半部分，并按 $a_i$ 从小到大排序；对于 $a_i > b_i$，我们放到后半部分，并按 $b_i$ 从大到小排序。算法正确性可通过邻项交换（Exchange Arguments）证明，相当于比较 $\max(a_1, a_1 - b_1 + a_2)$ 和 $\max(a_2, a_2 - b_2 + a_1)$，较小的排在前面。

回到原问题。容易看出这是对四维偏序内的所有点求 MH，看起来非常阴间。一般的数据结构肯定寄了，时间复杂度太高，我们只能考虑一些奇技淫巧。

对于高维偏序，有个神奇的做法，就是对每一维的所有值域前缀，用 bitset 处理出落在这个前缀内的所有点的标号，那么一次查询相当于将每个维度对应的 bitset 求交，时空复杂度均为 $\mathcal{O}(\frac{n ^ 2k} w)$。

对于按顺序处理的信息，我们真的只能一个个处理吗？答案是否定的。有个神奇的做法：按 $B = \log_2 n$ 分块，预处理块内所有 $2 ^ B$ 个集合的信息。对于每个询问，只要能快速求出落在该块内的所有点的集合，就可以给总复杂度除掉一个 $\log_2 n$。

结合上述两个技巧，我们得到如下做法：每次处理 $B = \log_2 n$ 个元素。DP 求出 $2 ^ B$ 个集合的信息。然后对于每一维限制，预处理值域的每个前缀的点的集合，用 $B$ 位二进制数描述。最后依次处理所有询问即可。时间复杂度是 $\mathcal{O}(\frac {(n + q + V) n}{\log n})$，其中 $V$ 是值域。

常数优化：注意编号维度大小很大。我们考虑扫描线，先对加入或删除块内每个点的事件按编号排序，然后按编号顺序处理询问，并用指针维护该维度的限制即可。[代码](https://uoj.ac/submission/605418)。

---

## 作者：tribool4_in (赞：0)

以下描述中设怪物总数为 $n$，询问数为 $q$。

首先询问的问题是经典贪心，其策略为对于 $a,b$ 大小关系分类讨论，对于 $a<b$ 的按照 $a$ 升序排序，$a>b$ 的按照 $b$ 降序排序。然后容易发现比较条件为 $\max(a_1,a_1-b_1+a_2)<\max(a_2,a_2-b_2+a_1)$，也就是两种先后顺序的最大扣血量。可以发现这个等价于前面的条件。于是首先离线下来，把怪物序列排序，**此时打怪的顺序就一定是单调的了**。

题意形如询问带时间轴的三维（或者算是四维）偏序下的贪心子问题答案。高维偏序类问题一种经典做法是考虑 bitset 维护，$b_{k,x}$ 表示第 $k$ 维 $\le x$ 的点的下标构成的 bitset（前缀和一下即可求出），询问时求个交集即可。

子问题似乎很具有顺序性。于是极为巧妙地考虑对于怪物序列（已经排好序了），按照 $B=\log n$ 分块。对于每个块内，首先可以状压 dp 预处理出所有 $2^B$ 种子集的打怪情况（需要维护“当前血量”与“历史最大扣血量”），然后将块内所有怪存入 bitset。对于每组询问，就可以用刚刚的方法求出满足偏序关系的怪物集合，在 dp 数组上查询即可得到块内的怪对于这组询问的影响（每组询问同理维护一下“当前血量”与“历史最大扣血量”）。

怪物还有增减的情况。容易得出每个怪物贡献到的询问区间。对于每个块内处理询问时，将怪物的贡献区间排序然后扫描线，维护一下能贡献到当前询问的怪物集合，跟 bitset 求出的集合求个交即可。时间复杂度 $O\left(\dfrac{n}{\log n}(n+V+q)\right)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1.5e5 + 10, V = 1e4 + 10, B = 13;
int q, n, m;
struct mst {
    int x, y, z, a, b, l, r;
} s[N];
bool operator<(const mst &u, const mst &v) { return max(u.a, u.a + v.a - u.b) < max(v.a, v.a + u.a - v.b); }
struct qry {
    int x, y, z, p;
    int f, g;
} qr[N];
int f[1 << B], g[1 << B];
int bx[V], by[V], bz[V];
vector<pair<int, int>> op;
void work(int L, int R) {
    int len = R - L + 1;
    f[0] = g[0] = 0;
    for (unsigned k = 1; k < (1 << len); k++) {
        int b = 31 - __builtin_clz(k), k0 = k ^ (1 << b);
        f[k] = f[k0] - s[L + b].a + s[L + b].b;
        g[k] = min(g[k0], f[k0] - s[L + b].a);
    }
    memset(bx, 0, sizeof(bx)), memset(by, 0, sizeof(by)), memset(bz, 0, sizeof(bz));
    for (int i = L; i <= R; i++) bx[s[i].x] |= (1 << i - L), by[s[i].y] |= (1 << i - L), bz[s[i].z] |= (1 << i - L);
    for (int i = 1; i < V; i++) bx[i] |= bx[i - 1], by[i] |= by[i - 1], bz[i] |= bz[i - 1];
    op.clear();
    for (int i = L; i <= R; i++) op.emplace_back(s[i].l, i - L), op.emplace_back(s[i].r, i - L);
    sort(op.begin(), op.end());
    for (int i = 1, j = 0, bq = 0; i <= m; i++) {
        while (j < op.size() && op[j].first < qr[i].p) bq ^= (1 << op[j].second), ++j;
        int b = bq & bx[qr[i].x] & by[qr[i].y] & bz[qr[i].z];
        qr[i].g = min(qr[i].g, qr[i].f + g[b]);
        qr[i].f = qr[i].f + f[b];
    }
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> q;
    for (int i = 1, k; i <= q; i++) {
        char ch;
        cin >> ch;
        if (ch == '+') {
            s[++n].l = i;
            cin >> s[n].x >> s[n].y >> s[n].z >> s[n].a >> s[n].b;
        } else if (ch == '-') {
            cin >> k;
            s[k].r = i;
        } else if (ch == '?') {
            qr[++m].p = i;
            cin >> qr[m].x >> qr[m].y >> qr[m].z;
        }
    }
    sort(s + 1, s + n + 1);
    for (int i = 1; i <= n; i++)
        if (!s[i].r) s[i].r = q + 1;
    for (int i = 1, j; i <= n; i = j + 1) {
        j = min(i + B - 1, n);
        work(i, j);
    }
    for (int i = 1; i <= m; i++) cout << -qr[i].g << '\n';
    return 0;
}
```

---


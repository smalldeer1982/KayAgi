# [北大集训 2021] 简单数据结构

## 题目背景

CTT2021 D2T1

## 题目描述

小 D 是一位数据结构大师，他特别喜欢研究形式简单的数据结构，今天他想到了这样一道题目：

你有一个长度为 $n$ 的序列 $a$，下面你要进行 $q$ 次修改或询问。

1. 给定 $v$，将所有 $a_i$ 变为 $\min(a_i, v)$。
2. 将所有 $a_i$ 变为 $a_i + i$。
3. 给定 $l, r$，询问 $\sum_{i=l}^r a_i$。

顶级数据结构大师小 D 轻松的解决了这个问题，现在他打算来考考即将参加 IOI2022 的你，相信你也可以轻松解决这个问题。

## 说明/提示

| 子任务编号 | 子任务分值 |  $n,q$   |   特殊性质   |
| :--------: | :--------: | :------: | :----------: |
|    $1$     |    $10$    |  $5000$  |              |
|    $2$     |    $20$    | $200000$ |      A       |
|    $3$     |    $15$    | $200000$ | $op_i\neq 2$ |
|    $4$     |    $55$    | $200000$ |              |




$1 \leq n, q \leq 2 \times 10^5$，$0 \leq a_i, v_i \leq 10^{12}$。

性质 A 为：$a_i, v_i$ 在 $[0, 10^{12}]$ 随机生成，$op_i$ 在 $[1, 3]$ 随机生成，$[l_i, r_i]$ 在所有可行区间随机生成。


## 样例 #1

### 输入

```
15 15
6 14 14 6 3 6 4 13 10 3 12 5 11 9 6
1 9
1 2
2
2
2
1 11
3 4 6
2
1 6
2
1 9
1 11
1 11
3 4 4
3 2 13```

### 输出

```
33
9
107
```

# 题解

## 作者：EuphoricStar (赞：21)

考虑若原来的序列是不降的，那么进行 $1$ 操作或 $2$ 操作序列仍然不降。那么 $1$ 操作直接线段树上二分然后打覆盖标记，$2$ 操作直接打标记即可。

考虑一般情况，发现某个时刻所有被 $1$ 操作影响过的 $i$（存在一次 $1$ 操作使得 $a_i \ge v$）组成的集合 $S$，$S$ 内部的序列是单调的。

于是整个序列被分成了两部分：$S$ 和 $[1, n] \setminus S$。对于 $S$，$1$ 操作直接线段树上二分然后打标记。$2$ 操作就分别对两个部分打个标记即可。

线段树一个结点需要维护：$S$ 部分的最大值及其最大下标（为了 $2$ 操作后计算新的最大值），两部分分别的和及其下标的和，$S$ 部分的元素个数和这个区间在 $S$ 部分的最大下标（打覆盖标记时需要将最大值的最大下标重置为这个值）。

剩下最后一个问题：如何计算一个元素何时加入 $S$。考虑二分 $mid$，相当于查询是否 $\exists j \in [1, mid], b_j \times i + a_i \ge v_j$（其中 $b_i$ 为第 $i$ 次 $1$ 操作前面的 $2$ 操作次数）。变形得 $\min\limits_{j = 1}^{mid} \{ -b_j \times i + v_j \} \le a_i$。考虑整体二分，维护一个 $(b_j, v_j)$ 的下凸包，check 就维护一个凸包上的指针即可。因为 $b_j$ 单调，所以不用排序。注意可能存在若干个 $b_j$ 相等，这种取它们 $v_j$ 的最小值即可。

总时间复杂度 $O(n \log n)$。

[code](https://loj.ac/s/2025858)

---

## 作者：H_W_Y (赞：14)

介绍一种没用整体二分和李超线段树的神秘单 log 做法，拿到了目前最优解（~~加了个快读~~ [Link](https://www.luogu.com.cn/record/188123672)）。



首先，假设当前的时刻为 $i$，设前面操作 $2$ 的次数是 $tg_i$。

然后对于每一次询问，我们让 $ans = tg_i \times (l+(l+1)+\cdots + r) + S(l,r)$，那么这里 $S(l,r)$ 相当于在 $[l,r]$ 区间内的 **初值** 之和。

于是对于 $i$ 时刻的操作 $1$，我们的操作其实是对于每个 $j$，让 $a_j = \min (a_j,v-tg_i \times  j)$。

现在考虑如何维护 $a$。



分成两种情况：

1. $i$ 位置的初值为初始的 $a_i$。
2. $i$ 位置的初值为某一次修改的 $-tg_j \times i +v_j$。

注意到第一种情况一定是一个时间的前缀，所以我们先不考虑这种情况。

那么对于第二种情况，在每一个时刻，相当于让每个值与 **一条直线** 取 $\min$，并且这个直线的 **斜率递减，且 $\le 0$**。

发现这个东西是一个凸包！也就是每次只会更新一段后缀！

![](https://cdn.luogu.com.cn/upload/image_hosting/wr4knk42.png)

图中 $1,2,3$ 是插入顺序也是线段的编号，红色部分是第2/3条线段插入时更新的一段后缀。

这个东西是容易用单调栈维护的，每次暴力弹栈即可。可以做到 $\mathcal O(n)$，但是代码中是 $\mathcal O(n \log n)$（二分交点）。



进而，如果一个 $i$ 的答案取决于某一条线段的 $-kx+b$，我们可以直接用线段树维护区间和。

但是注意到 $i$ 的初值还有可能取为 $a_i$，所以我们考虑去 **二分** 出 $a_i$ 作为初值贡献的一个前缀。

这里我们称一条线对于点 $i$ 是有用的当且仅当这条线加入时，会更新到 $i$ 位置的初值。

举个例子，

![](https://cdn.luogu.com.cn/upload/image_hosting/rd3fest6.png)

图中在 $x_2$ 位置，有用的线是 $1,2,3$；而到了 $x_1$ 这个位置，有用的线就只有 $1,3$ 了，因为 $2$ 加入时不会影响到 $x_1$ 位置的值。

所以我们考虑 **从后往前扫 $i$**，每次在对于当前 $i$ 有用的线上面去 **二分** 第一个 $-k_{j}i+v_{j} \lt a_i$ 的位置，不妨设这个 $j$ 为 $t_i$。

那么在 $[1 ,t_i)$ 时刻 $i$ 位置的初值都是 $a_i$，$[t_i,m]$ 时刻的 $i$ 位置的初值就取决于上面这个凸包上面的值了。

于是我们只需要在 $t_i$ 时刻在凸包上面点亮这个点就可以了。



而现在问题就在于怎么找到这些有用的线。

根据最开始我们在讲凸包时的发现，每次一条线只会更新一段后缀，而对于在这段后缀中点的 $x$，这条线是有用的。

那么我们在 **从后往前** 扫的过程中，线只减不增，也就是会不断删除一些线。

于是容易维护这些有用的线的集合，代码中用并查集维护 $i$ 时刻之前最后一个有用的线的位置。



这样就做完了，整体来说分了四个部分：

1. 找到每一条线贡献到的一段后缀。
2. 从后往前扫每一个序列上的位置 $i$，二分出 $a_i$ 贡献的一个前缀 $[1,t_i)$。
3. 用树状数组维护初值为 $a_i$ 的贡献，随着时间的推移，每次删除一些点。
4. 用线段树维护初值为某个 $-kx+b$ 的贡献，随着时间的推移，每次加入一些点。

其实后两部分也可以合并。



时间复杂度 $\mathcal O(n \log n)$，认为 $n,m$ 同阶。[代码](https://www.luogu.com.cn/record/188123761)。

~~以下代码是联考场上代码，实现并不精细。~~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back

const int N=2e5+5;
int n,m,cnt=0,st[N],tp=0,id[N],to[N],gx[N],fa[N];
ll a[N],tg[N],ans[N];
struct Nod{
  int op,l,r;
  ll v;
}q[N];
struct Line{
  ll k,b;
  ll val(int x){return 1ll*x*k+b;}
}L[N];
vector<int> G[N],P[N];

int find(int x,int pre){
  if(!pre) return 1;
  int l=1,r=n,res=n+1;
  while(l<=r){
    int mid=((l+r)>>1);
    if(L[x].val(mid)<L[pre].val(mid)) res=mid,r=mid-1;
    else l=mid+1;
  }
  return res;
}

int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}

bool chk(int pos,int x){
  x=find(x);
  if(!x) return false;
  return L[to[x]].val(pos)<a[pos];
}

ll S(int l,int r){return 1ll*(l+r)*(r-l+1)/2ll;}

namespace BIT{
  ll tr[N];
  int lowbit(int i){return i&(-i);}
  void upd(int x,ll v){for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=v;}
  ll qry(int x){
    ll res=0;
    for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
    return res;
  }
  ll qry(int l,int r){return qry(r)-qry(l-1);}
}

void init(){
  cin>>n>>m;
  for(int i=1;i<=n;i++) cin>>a[i];
  for(int i=1;i<=m;i++){
    cin>>q[i].op;tg[i]=tg[i-1];
    if(q[i].op==1) cin>>q[i].v;
    else if(q[i].op==2) tg[i]++;
    else cin>>q[i].l>>q[i].r;
    
    if(q[i].op==1){
      L[++cnt]={-tg[i],q[i].v},to[i]=cnt;
      while(tp&&L[id[tp]].val(st[tp])>L[cnt].val(st[tp])) --tp;
      id[++tp]=cnt,gx[i]=st[tp]=find(id[tp],id[tp-1]);
      if(st[tp]==n+1) --tp;
      G[gx[i]-1].pb(i);
    }
  }
  
  iota(fa+1,fa+m+1,1);
  for(int i=1;i<=m;i++) if(q[i].op!=1) fa[i]=i-1;
  
  for(int i=n;i>=1;i--){
    for(auto j:G[i]) fa[j]=j-1;
    int l=1,r=m,res=m+1;
    while(l<=r){
      int mid=((l+r)>>1);
      if(chk(i,mid)) res=mid,r=mid-1;
      else l=mid+1;
    }
    P[res].pb(i);
  }
  
  for(int i=1;i<=n;i++) BIT::upd(i,a[i]);
  for(int i=1;i<=m;i++){
    for(auto j:P[i]) BIT::upd(j,-a[j]);
    if(q[i].op==3) ans[i]=BIT::qry(q[i].l,q[i].r);
  }
}

namespace SGT{
  #define mid ((l+r)>>1)
  #define lc p<<1
  #define rc p<<1|1
  #define lson l,mid,lc
  #define rson mid+1,r,rc
  
  struct sgt{
    int tg,v,len;
    ll sx,sum;
  }tr[N<<2];
  
  void pu(int p){
    tr[p].sx=tr[lc].sx+tr[rc].sx;
    tr[p].sum=tr[lc].sum+tr[rc].sum;
    tr[p].len=tr[lc].len+tr[rc].len;
  }
  
  void pt(int p,int v){
    tr[p].tg=tr[p].v=v;
    tr[p].sum=tr[p].sx*L[v].k+1ll*tr[p].len*L[v].b;
  }
  
  void pd(int p){
    if(tr[p].tg!=-1) pt(lc,tr[p].tg),pt(rc,tr[p].tg),tr[p].tg=-1;
  }
  
  void build(int l,int r,int p){
    tr[p].tg=-1;
    if(l==r) return ;
    build(lson),build(rson);
  }
  
  void ins(int l,int r,int p,int x){
    if(l==r){
      tr[p].sx=l;
      tr[p].sum=L[tr[p].v].val(x);
      tr[p].len=1;
      return;
    }
    pd(p);
    x<=mid?ins(lson,x):ins(rson,x);
    pu(p);
  }
  
  void upd(int l,int r,int p,int x,int y,int v){
    if(x>y||x>r||y<l) return;
    if(x<=l&&y>=r) return pt(p,v);
    pd(p);
    if(x<=mid) upd(lson,x,y,v);
    if(y>mid) upd(rson,x,y,v);
    pu(p);
  }
  
  ll qry(int l,int r,int p,int x,int y){
    if(x<=l&&y>=r) return tr[p].sum;
    pd(p);
    if(y<=mid) return qry(lson,x,y);
    if(x>mid) return qry(rson,x,y);
    return qry(lson,x,y)+qry(rson,x,y);
  }
  
  #undef mid
}

void solve(){
  SGT::build(1,n,1);
  for(int i=1;i<=m;i++){
    for(auto j:P[i]) SGT::ins(1,n,1,j);
    if(q[i].op==1) SGT::upd(1,n,1,gx[i],n,to[i]);
    else if(q[i].op==3){
      int l=q[i].l,r=q[i].r;
      ans[i]+=SGT::qry(1,n,1,l,r)+1ll*tg[i]*S(l,r);
      cout<<ans[i]<<'\n';
    }
  }
}

int main(){
  ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
  init(),solve();
  return 0;
}
```

---

## 作者：Alex_Wei (赞：14)

#### *D2T1. [P8987 [北大集训 2021] 简单数据结构](https://www.luogu.com.cn/problem/P8987)

没看到 $a_i$ 有初值，这不是简单题吗？$a$ 一直具有单调不降的性质，因此操作 1 转化为线段树二分 + 区间覆盖，操作 2 直接打 tag。

$a_i$ 有初值怎么办呢？肯定也得想办法往上述做法靠拢，其本质是 **容易维护单调不降的序列**。

我们观察一下两个操作，发现如果一个元素没有被操作 1 影响，那么它的值仅和初始值和操作 2 执行的次数有关。这就启发我们将元素分成两类：没有被操作 1 影响的 $S$，和被操作 1 影响的 $T$，分别维护。

考虑一个元素 $a_p$ 被操作 1 影响，将其加入 $T$ 时，$T$ 仍然保持单调性：在该元素之后的所有元素 $a_q$（$p < q$）也一定被操作 1 影响，否则当前 $a_q < v \leq a_p$。又因为 $a_p$ 是第一次被影响，所以 $a_q$ 恒小于 $a_p$，在当前操作之前同样没有被影响，这与 $a_q\in T$ 矛盾。

因此，只需求出每个元素加入 $T$ 的时间，就可以用两棵线段树分别维护 $S$ 和 $T$ 计算答案（$S$ 也可以用树状数组维护）。

考虑 $a_i$ 的当前值为 $a_i + c\times i$，其中 $c$ 表示操作 2 次数。对于每次操作 1，我们需要找到所有使得 $a_i +c\times i \geq v$ 的 $a_i$ 并删除，相当于找到斜率为 $-c$ 的直线在所有点 $(i, a_i)$ 形成的凸包上的切点。删点，求切点，斜率递增，强制在线，分块凸包 + 双指针维护。

视 $n, q$ 同级，总时间复杂度 $\mathcal{O}(n\sqrt n)$。[代码](https://uoj.ac/submission/605739)。

能不能 polylog 呢？可以！$a_i + c_j\times i\geq v_j$ 写成 $a_i\geq v_j - c_j\times i$，我们可以快速判断 $a_i$ 是否被一些操作 1 影响，李超线段树套整体二分即可。时间复杂度 $\mathcal{O}(n\log ^ 2n)$。[代码](https://uoj.ac/submission/605753)。

---

## 作者：Purslane (赞：10)

感觉这题还是比较套路的，放在当今 CNOI 大家肯定都能切穿了吧。

先考虑这样一个问题：如果 $a$ 的初始值满足 $a_1=a_2=\cdots = a_n = A$ 怎么办？

考虑将 $\min$ 拆开（这种套路在**涉及很多取 $\min$ 的数据结构题中比较常见**，举个例子就是 $\min(a,\min(b,c)+d) = \min(a,b+d,c+d)$，只有最外层一个 $\min$ 方便使用数据结构维护）。

令 $t$ 为**当前操作 $2$ 执行的次数**，并且维护辅助数组 $b$。当执行了 $1$ 操作（最开始我们可以认为 $a_i = +\infty$，并且执行了 $v=A$ 的 $1$），对于所有的 $b$ 执行 $b_i \leftarrow \min\{b_i,v-it\}$。

那么查询的时候 $a_i=b_i+it$，所以只需要维护 $b$ 的区间和。

显然 $b_i$ 是若干条 $y=v-tx$ 的线构成的凸包。平衡树动态维护凸包肯定是可以的，但是发现斜率是递减的，所以维护一个栈就行。

所以为什么没有这个的部分分？？很奇怪啊。

回到原题，如果初始的时候假设 $a_i=+\infty$ 那么上面的操作肯定还是对的，但是会算大了，因为每个 $i$ 在最开始会有 $b_i \leftarrow a_i$。那咋办？

显然这个初始的 $a_i$ 在某个时刻之后就没用了，可以直接套用上面那个做法。找到这个时刻 $lim_i$，在 $lim_i$ 之前我们不需要考虑 $1$ 操作，只是简单的区间加；在 $lim_i$ 之后我们不用考虑初始值，可以用简单的区间赋值线段树维护。

那么，怎么找到这个 $lim$？

思路 1：我们对于每次操作 $1$，没有把原有的 $a$ 覆盖掉需要初始的 $a_i \le v- it$。前 $tmp$ 时刻都没更新，等价于这些限制都成立，所以我们要对于一大堆 $(v,t)$ 求 $v-it$ 的最小值。显然可以整体二分，这样是 $O(n \log^2 n)$ 的。

思路 2：考虑直接上 KTT。容易势能分析得到复杂度为 $O(n \log^2 n)$。感觉不太好写，常数可能还不小。这样还不用离线，不好评价。

思路 3：在思路 1 中，为什么要用李超树呢？因为斜率是递减的，所以我们可以把凸包建出来，而建立凸包的过程只用到了栈，所以这一部分是 $O(n \log n)$；查询的时候也不用在凸包上二分，因为我们可以通过手段使得查询的横坐标是递增的，那么就可以使用双指针来做到线性。因此我们的整体二分在 $O(n \log n)$ 完成。

---

## 作者：qijianci (赞：7)

联考场上因为并查集合并写挂了没调出来。

赛后看题解区似乎没有和我一样的做法？来水一发

#### 不需要维护凸包也不用整体二分也不用李超线段树的题解。

题意很简单，需要维护全局加 id 、全局取 $\min$ 和区间查询。

做过线段树3的朋友们应该都对全局取 $\min$ 的操作是很熟悉了，记一个最大值和次大值就能轻松做到单 $\log$ ，但是这个题显然不能那样做，全局加 id 的操作会破坏它的复杂度，我们考虑别的做法。

#### 首先我们注意到一点，若序列的初值都一样，那全局加 id 、全局取 $\min$ 的操作是不会影响相邻两个数的偏序关系的，所以全局加 id 可以直接打懒标记，全局取 $\min$ 就成了后缀覆盖，可以轻松维护。

那若是初值不一样呢？显然是没法直接维护的，我们想想能不能转化到初值一样的情况上去。

场上很快发现一个事情，对于一次全局取 $\min$ 的操作，那些被有效操作了的点就相当于初值一样了。

由此我们先大胆猜一个结论：

#### 对于被取过 $\min$ 的点，它们在之后一定满足单调不降的性质。

其实也很好证明。若一个点 $i$ 在某一时刻在对与 $x$ 取 $\min$ 的操作中被有效操作了，那么对于标号在它之前的已被操作过点 $a$ 来说，由于对 $x$ 取 $\min$ ，此时的值一定是也是小于等于 $x$ 的，也就是小于等于点 $i$ 的；对于标号在它之后的已被操作过的点 $b$ 来说，由于 $b$ 在之前被操作过了，说明在那个时刻，$b$ 的值是大于 $i$ 的值的，而加 id 的操作又是不会改变他们的偏序关系的，因此在对 $x$ 取 $\min$ 前，$b$ 的值大于 $i$，那么 $i$ 对 $x$ 取 $\min$ ，$b$ 也会对 $x$ 取 $\min$ ，因此依然单调不降。

那现在我们只需要维护两个线段树，一个线段树维护未被操作过的点，另一个维护被操作过的点，全局加 id 两个线段树都打懒标记就行了，取 $\min$ 对于未被操作过的点就不用管了，对于被操作过的点做后缀覆盖就行了。

那么我们现在只需要知道一个点在什么时候被取 $\min$ ，然后就把它从一个线段树上转移到另一个线段树上就行了。

那这个怎么做呢？一个朴素的想法是维护未被选过的最大值，然后每次取 $\min$ 的时候判一下是否大于 $x$。但我想了很久都没有发现能怎么维护，全局加 id 的操作和这个应该是不兼容的。考虑换一种方式。 

假设我们先单独考虑对一个点 $x$ 求出答案。那么我们可以统计出一个 $sum$ 数组表示到第 $i$ 个询问的时候前面进行了多少次全局加 id 的操作，那么现在对于第 $i$ 个询问的值就会变为  $g(i)=y-sum_i\times x$ ，此时我们只需要找出第一个小于 $a_x$ 的值就行了，但这样单次的复杂度无法接受。

我们发现若从大到小枚举点 $x$ ，$g(i)$ 会慢慢由 $y-sum_i\times x$ 变为 $y-sum_i\times (x-1)$ ，这样 $g(i)$ 的值一定是单调增加的，并且由于 $sum_i$ 也是随 $i$ 单调增加的，

#### 因此可能成为答案的 $g(i)$ 一定是 $g(i)$ 序列上从后往前的单调递增的单调栈上的点。 

证明也很简单。考虑若存在两个点 $a<b$ 并且 $g(a)<g(b)$，由于 $sum_i$ 单调增加，所以 $g(a)$ 的增长速度一定小于 $g(b)$，讲人话就是 $g(a)$ 会一直小于 $g(b)$，因此  $b$ 永远不会成为答案。

若我们能够动态维护这个单调栈，那算答案时就只用在这个单调栈上二分即可。

我们继续考虑如何动态维护这个单调栈。首先我们可以对于 $x=n$ 时求出这个单调栈，那到 $x=n-1$ 时单调栈会有什么变化呢？考虑单调栈上一个相邻点对 $i$ $j$，若 $x=n-1$ 时 $g(i)<g(j)$，那么由前面的结论我们知道后面 $g(i)$ 会一直小于 $g(j)$，因此 $j$ 不会再成为答案了，会从单调栈上删除。容易发现  $g(i)<g(j)$ 的时间是确定的，设当前点与点 $n$ 之差为 $x$，那当 $x>=(g(j)-g(i))/(sum_j-sum_i)$ 时，将点 $j$ 与点 $i$ 的并查集合并就行了。我们可以将相邻两个点合并的时间先求出来，等枚举到那个点时合并就行了，注意动态加入后要考虑新的相邻的点。

精细实现可以做到单 $\log$。

#### end.

代码挺好写的，没什么细节。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int,int>
#define fi first
#define se second
#define ls p<<1
#define rs p<<1|1
const int N=2e5+5;
int n,q,a[N],c[N],sk[N],tp;
int fa[N],sum[N],R[N];
int dad(int x){return fa[x]^x?fa[x]=dad(fa[x]):x;}
struct Node{
    int o,v,l,r;
}Q[N];
priority_queue<PII>q1;
vector<int>t[N];
int T1[N<<2],s1[N<<2],lz1[N<<2];
int T2[N<<2],s2[N<<2],mn[N<<2],tg[N<<2],lz2[N<<2],vl[N<<2],len[N<<2];
void pup1(int p){T1[p]=T1[ls]+T1[rs],s1[p]=s1[ls]+s1[rs];}
void pup2(int p){
    T2[p]=T2[ls]+T2[rs],s2[p]=s2[ls]+s2[rs];
    if(s2[ls])mn[p]=mn[ls],vl[p]=vl[ls];
    else mn[p]=mn[rs],vl[p]=vl[rs];
    len[p]=len[ls]+len[rs];
}
void pud1(int p){
    if(!lz1[p])return;
    int x=lz1[p];lz1[p]=0;
    lz1[ls]+=x,lz1[rs]+=x;
    T1[ls]+=s1[ls]*x,T1[rs]+=s1[rs]*x;
}
void pud2(int p){
    if(tg[p]){
        int x=tg[p];tg[p]=0;
        mn[ls]=mn[rs]=x,tg[ls]=tg[rs]=x;
        lz2[ls]=lz2[rs]=0;
        T2[ls]=x*len[ls],T2[rs]=x*len[rs];
    } 
    if(lz2[p]){
        int x=lz2[p];lz2[p]=0;
        lz2[ls]+=x,lz2[rs]+=x;
        T2[ls]+=s2[ls]*x,T2[rs]+=s2[rs]*x;
        mn[ls]+=x*vl[ls],mn[rs]+=x*vl[rs];
    }
}
void build(int l,int r,int p){
    int mid=l+r>>1;
    if(l==r){s1[p]=l,T1[p]=a[l];return;}
    build(l,mid,ls),build(mid+1,r,rs),pup1(p);
}
void ins(int l,int r,int p,int x,int v){
    if(l==r){T2[p]=mn[p]=v,vl[p]=s2[p]=l,len[p]=1,T1[p]=s1[p]=0;return;}
    int mid=l+r>>1; pud1(p),pud2(p);
    x<=mid?ins(l,mid,ls,x,v):ins(mid+1,r,rs,x,v);
    pup1(p),pup2(p);
}
void upt(int l,int r,int p,int v){
    if(mn[p]>=v){
        if(!s2[p])return;
        T2[p]=len[p]*v,mn[p]=tg[p]=v,lz2[p]=0;
        return;
    } if(l==r)return; int mid=l+r>>1; pud2(p);
    if(mn[rs]>=v||!s2[rs])upt(l,mid,ls,v);
    upt(mid+1,r,rs,v),pup2(p);
}
int que(int l,int r,int p,int lx,int rx){
    if(rx<l||r<lx)return 0;
    if(lx<=l&&r<=rx)return T1[p]+T2[p];
    int mid=l+r>>1; pud1(p),pud2(p);
    return que(l,mid,ls,lx,rx)+que(mid+1,r,rs,lx,rx);
}
signed main(){
    ios::sync_with_stdio(false);
    // freopen("ds.in","r",stdin);
    // freopen("ds.out","w",stdout);
    int i,j,k,l,r,x,y,z;
    cin>>n>>q;
    for(i=1;i<=n;++i)cin>>a[i];
    for(i=1,y=0;i<=q;++i){
        cin>>k,Q[i].o=k,c[i]=2e18;
        if(k==1)cin>>x,c[i]=Q[i].v=x;
        if(k==2)y+=n,sum[i]++;
        if(k==3)cin>>Q[i].l>>Q[i].r;
        c[i]-=y,sum[i]+=sum[i-1];
    }
    for(i=q;i;--i){
        while(tp&&c[sk[tp]]>=c[i])tp--;
        sk[++tp]=i; 
        // if(tp>1&&sum[sk[tp-1]]-sum[i]==0)tp--;
    } iota(fa+1,fa+1+tp,1),iota(R+1,R+1+tp,1);
    reverse(sk+1,sk+1+tp);
    for(i=1;i<tp;++i){
        l=sk[i],r=sk[i+1];
        if(sum[r]-sum[l]==0)continue;
        x=(c[l]-c[r]-1)/(sum[r]-sum[l])+1;
        q1.push({-x,i});
    }
    for(i=n,sk[0]=q+1;i;--i){
        while(q1.size()&&-q1.top().fi<=n-i){
            x=q1.top().se,q1.pop(),y=R[x]+1;
            if(dad(x)!=x||dad(y)!=y)continue;
            fa[y]=x,R[x]=R[y],l=sk[x],r=sk[R[x]+1];
            if(R[x]<tp&&sum[r]-sum[l]){
                k=(c[l]-c[r]-1)/(sum[r]-sum[l])+1;
                // assert(sum[r]>sum[l]);
                // if(sum[r]<sum[l])printf("%d %d\n",x,y);
                q1.push({-k,x});
            }
        } l=1,r=tp,x=0;
        while(l<=r){
            y=l+r>>1,k=sk[dad(y)];
            if(c[k]+(n-i)*sum[k]>a[i])l=y+1;
            else r=y-1,x=y;
        } t[sk[x]].push_back(i);
        // if(i==1)printf("%lld:::\n",dad(2));
    } build(1,n,1);
    for(i=1;i<=q;++i){
        for(auto u:t[i])ins(1,n,1,u,Q[i].v);
        // if(i==3){for(auto u:t[i])printf("%d ",u);puts("");}
        k=Q[i].o;
        if(k==1){
            if(!s2[1])continue;
            upt(1,n,1,Q[i].v);
        } else if(k==2)lz1[1]++,lz2[1]++,T1[1]+=s1[1],T2[1]+=s2[1];
        else printf("%lld\n",que(1,n,1,Q[i].l,Q[i].r));
    }
    return 0;
}
```

---

## 作者：Mobius127 (赞：7)

[题传](https://www.luogu.com.cn/problem/P8987)

前排膜拜 [cp152](https://www.luogu.com.cn/user/171544)。

没有 1 操作怎么办？线段树直接打 tag！

没有 2 操作怎么办？我会吉老师线段树！

现在将两种做法合并起来。

注意到吉老师线段树在 2 操作的影响下势能分析会假掉，因此需要考虑另一些奇怪的做法。

将操作 1 抽象成把很多个不同的颜色归到同一个颜色中。而操作 2 是我们将不降序列转化为单增序列的一种方法，进而推出操作 2 对于一个有序的序列，其并不会影响内部有序性。

发现两种操作都是全局的，那么颜色段数量只会不断减少，这启发我们去暴力维护这些段，操作 1 总是将**所有**大的合并到小的，反过来说，我们将一个后缀若干个不降段合并到了一起，并且这些段以后不会再分裂开（因为 2 操作不会对一个），或者是把后面一整个不降的段的末尾“削平”。

对于 1 操作，我们珂以只维护其对最大的那个集合 $M$ 的影响，因为其单调不降，所以直接在线段树上二分然后区间推平即可。

对于 2 操作，对于在 $M$ 内和不在 $M$ 内的都正常打 tag 就行（注意两个的要分开，因为 $M$ 内还有个推平标记）。

接下来考虑 $a_i$ 加入 $M$ 的时间，考虑二分，记 $b_i$ 为第 $i$ 次 1 操作前 2 操作的数量，则二分条件为 $\exists j\in [1, mid], b_j \times i +a_i \ge v_j$，改一下变为 $\min_{j \in[1, mid]}\{-b_j \times i+v_j\} \le a_i$，可持久化李超线段树或者整体二分套李超线段树即可做到 $O(\log^2 n)$。

然而真的要这么麻烦吗？

注意到斜率 $-b_j$ 单调不增，整体二分的时候直接单调栈做凸包就好。

复杂度 $O(n \log n)$，跑得飞快。~~虽然 2log 跑得也挺快的~~

### Code:

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cctype>
#include <vector>
#include <queue>
#include <bitset>
#define vi vector<int>
#define pb push_back
#define mp make_pair
#define st first
#define nd second
using namespace std;
typedef long long ll;
typedef pair <int, int> Pii;
const int cp=998244353;
inline int mod(int x){if(x>=cp) x-=cp;if(x<0) x+=cp;return x;}
inline void plust(int &x, int y){x=mod(x+y);return ;}
inline void minut(int &x, int y){x=mod(x-y);return ;}
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline ll readll(){
	char ch=getchar();ll x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=x*10ll+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline int ksm(int a, int b=cp-2){
	int ret=1;
	for(; b; b>>=1, a=1ll*a*a%cp)
		if(b&1) ret=1ll*ret*a%cp;
	return ret;
}
const int N=2e5+5;
const ll INF=1e18;
int n, Q, cnt, trn[N], id[N];
int lp[N], rp[N];
ll a[N], b[N], v[N];
struct oper{int tp, x, y;}op[N];
vi G[N];
struct seg{ll k, b, lf;ll func(int x){return 1ll*k*x+b;}}sta[N];
ll operator * (seg A, seg B){
	//kix+bi=kjx+bj x=(bj-bi)/(ki-kj)
	return (A.b-B.b)/(B.k-A.k);
}
namespace SMT{
	#define ls k<<1
	#define rs k<<1|1
	#define mid (l+r>>1)
	struct node{ll sum[2], cnt[2], num, mx, mxid, mn, mnid, adt[2], cov;}tr[N<<2];
	node operator + (node a, node b){
		node c;c.adt[0]=c.adt[1]=0, c.cov=-1;
		c.sum[0]=a.sum[0]+b.sum[0];
		c.sum[1]=a.sum[1]+b.sum[1];
		c.cnt[0]=a.cnt[0]+b.cnt[0];
		c.cnt[1]=a.cnt[1]+b.cnt[1];
		c.num=a.num+b.num, c.mx=max(a.mx, b.mx), c.mn=min(a.mn, b.mn);
		if(a.mx==c.mx) c.mxid=a.mxid;
		if(b.mx==c.mx) c.mxid=b.mxid;
		if(b.mn==c.mn) c.mnid=b.mnid;
		if(a.mn==c.mn) c.mnid=a.mnid;
		return c;
	}
	void pushup(int k){tr[k]=tr[ls]+tr[rs];return ;}
	void build(int k, int l, int r){
		tr[k].cov=-1, tr[k].mx=-INF, tr[k].mn=INF;
		if(l==r){tr[k].sum[0]=a[mid], tr[k].cnt[0]=mid;return ;}
		build(ls, l, mid), build(rs, mid+1, r);pushup(k);
	}
	void cover(int k, ll v, int lid, int rid){
		if(tr[k].num) 
			tr[k].sum[1]=v*tr[k].num, tr[k].mx=tr[k].mn=v, 
			tr[k].mxid=rid, tr[k].mnid=lid, tr[k].adt[1]=0, tr[k].cov=v;
	}
	void upd(int k, ll v1, ll v2){
		tr[k].sum[0]+=v1*tr[k].cnt[0];
		tr[k].sum[1]+=v2*tr[k].cnt[1];
		if(tr[k].cnt[0]) tr[k].adt[0]+=v1;
		if(tr[k].cnt[1]) tr[k].mx+=v2*tr[k].mxid, tr[k].mn+=v2*tr[k].mnid, tr[k].adt[1]+=v2;
	}
	void pushdown(int k, int l, int r){
		if(~tr[k].cov) cover(ls, tr[k].cov, l, mid), cover(rs, tr[k].cov, mid+1, r), tr[k].cov=-1;
		if(tr[k].adt[0]||tr[k].adt[1]) 
			upd(ls, tr[k].adt[0], tr[k].adt[1]), upd(rs, tr[k].adt[0], tr[k].adt[1]), 
			tr[k].adt[0]=tr[k].adt[1]=0;
	}
	void bulldoze(int k, int l, int r, ll v){
		if(tr[k].mx<=v||!tr[k].cnt[1]) return ;
		if(tr[k].mn>=v) return cover(k, v, l, r);
		pushdown(k, l, r);bulldoze(ls, l, mid, v), bulldoze(rs, mid+1, r, v);
		pushup(k);
	}
	void colchange(int k, int l, int r, int x, ll v){
		if(l==r){
			tr[k].sum[0]=tr[k].cnt[0]=0, tr[k].num=1, tr[k].cnt[1]=tr[k].mxid=tr[k].mnid=mid;
			// printf("change %d to %lld\n", mid, v);
			tr[k].sum[1]=tr[k].mx=tr[k].mn=v;return ;
		}
		pushdown(k, l, r);
		if(x<=mid) colchange(ls, l, mid, x, v);
		else colchange(rs, mid+1, r, x, v);
		pushup(k);
	}
	ll query(int k, int l, int r, int x, int y){
		if(x>r||y<l) return 0;
		if(x<=l&&r<=y) return tr[k].sum[0]+tr[k].sum[1];pushdown(k, l, r);
		return query(ls, l, mid, x, y)+query(rs, mid+1, r, x, y);
	}
	#undef ls
	#undef rs
	#undef mid
}
void solve(int l, int r, int ql, int qr){
	if(ql>qr) return ;int mid=l+r>>1;
	if(l==r){for(int i=ql; i<=qr; ++i) trn[id[i]]=mid;return ;}
	int top=0;
	for(int i=l, j; i<=mid; i=j+1){
		seg t=(seg){-b[i], v[i], 1};j=i;
		while(j<mid&&b[j]==b[j+1]) ++j, t.b=min(t.b, v[j]);
		while(top&&sta[top].func(sta[top].lf)>=t.func(sta[top].lf)) --top;
		if(top) t.lf=max(1ll, sta[top]*t+1);
		if(!top||(top&&t.lf<n)) sta[++top]=t;
	}
	int lt=0, rt=0;sta[top+1].lf=n+1;//printf("for [%d %d] :\n", l, r);
	// for(int i=1; i<=top; ++i) 
		// printf("y=%lldx+%lld in [%d, %d)\n", sta[i].k, sta[i].b, sta[i].lf, sta[i+1].lf);
	for(int i=ql, j=1; i<=qr; ++i){
		while(id[i]>=sta[j+1].lf) ++j;
		if(sta[j].func(id[i])<=a[id[i]]) lp[++lt]=id[i];// printf("%d go left\n", id[i]);
		else rp[++rt]=id[i];// printf("%d go right\n", id[i]);
	}
	for(int i=ql, j=0, k=0; i<=qr; ++i)
		if(j<lt) id[i]=lp[++j];else id[i]=rp[++k];
	solve(l, mid, ql, ql+lt-1);
	solve(mid+1, r, ql+lt, qr);
}
signed main(){
	n=read(), Q=read();
	for(int i=1; i<=n; ++i) a[i]=readll(), id[i]=i;
	for(int i=1, toc=0; i<=Q; ++i){
		int tp=read();
		if(tp==1) v[++cnt]=readll(), op[i]=(oper){1, cnt, 0}, b[cnt]=toc;
		if(tp==2) op[i]=(oper){2, 0, 0}, ++toc;
		if(tp==3) op[i].tp=3, op[i].x=read(), op[i].y=read();
	}
	++cnt, b[cnt]=-1, v[cnt]=-INF;
	solve(1, cnt, 1, n);
	for(int i=1; i<=n; ++i) G[trn[i]].pb(i);//printf("%d ", trn[i]);puts("");
	SMT :: build(1, 1, n);
	for(int i=1; i<=Q; ++i){
		if(op[i].tp==1){
			int idx=op[i].x;
			SMT :: bulldoze(1, 1, n, v[idx]);
			for(auto pos:G[idx]) SMT :: colchange(1, 1, n, pos, v[idx]);
		}
		if(op[i].tp==2) SMT :: upd(1, 1, 1);
		if(op[i].tp==3) printf("%lld\n", SMT :: query(1, 1, n, op[i].x, op[i].y));
	}
	return 0;
}
// ai+bj*i>=vj
// min(-bj*x+vj)<=ax
```




---

## 作者：JWRuixi (赞：6)

## P8987 [北大集训 2021] 简单数据结构

### 题意

给定长度为 $n$ 的序列 $a$ 和 $q$ 次操作：

- 令所有 $a_i \gets \min(a_i, v)$；
- 令所有 $a_i \gets a_i + i$；
- 查询 $\sum\limits_{i = L}^R a_i$。

$n, q \le 2 \times 10^5$。

### 分析

很难不发现，如果 $a$ 单调增的话，修改不改变单调性。操作一相当于后缀覆盖，操作二是打标记。直接线段树维护。

感性上修改操作都是让序列往单调的方向发展的。那么可以看成是，序列最开始时不是单调的，但是随着操作的进行，序列的一些部分逐渐变的单调了。

于是一个直接的思路就是，记 $A$ 为原序列，我们将 $A$ 分为两部分 $B$、$A \setminus B$，分别维护，满足 $B$ 是单调的。$B$ 初始时为空，在操作进行的过程中，会有一些 $A \setminus B$ 的部分加入到 $B$ 中，所以每个点什么时候加入 $B$ 是我们所关心的。

一个观察是：一操作实质上是后缀推平，也就是说，它会影响 $B$ 的一个后缀，并且将它们推平到 $v$。那么如果某个 $x \in A \setminus B$ 也受到了这个一操作的影响，那么意味着结束时它的值也会变成 $v$，那么它也就能自然的融入 $B$ 收影响的后缀了。

也就是说，我们关注的时间戳实际上就是每个点第一次受一操作影响的时间戳，记 $t_i$ 为 $i$ 的时间戳。而另外一个观察是：若 $p < q$ 且 $t_p > t_q$，那么从 $t_q$ 这个节点开始，$a_p$ 恒 $\le a_q$。这个就是由于在 $t_q$ 这个时刻，我们能确定 $a_p < a_q$，而修改不改变单调性，所以这个性质会一直保持下去。

那么这会不会存在问题呢？考虑如果 $p \in A \setminus B, q \in B, p < q$，且 $p$ 受到影响但 $q$ 不受影响，也就是说 $a_p > v \ge a_p$，这与观察二矛盾，所以这种冲突是不存在的。

那么我实际上只要求出 $t_{1, \dots, n}$ 就完事了！

记 $b_i$ 表示：第 $i$ 个一操作之前，又多少个二操作。那么 $t_i$ 相当于是最小的 $p$ 满足 $t_i + i \times b_p > v_p$，略微移项就变成了：$t_i > v_p - i \times b_p$。考虑二分，用持久化李超线段树维护最小值，复杂度 $\mathcal O(n \log^2 n)$，可以通过。

考虑更近一步，我们发现 $b_p$ 具有单调性，这启发我们维护 $(b_p, v_p)$ 组成的凸包查询最小值。顺序扫 $i$，那么切点显然可以用指针移动维护，复杂度 $\mathcal O(n \log n)$。用整体二分不难将空间做到线性。

### Code

提交记录：<https://loj.ac/s/2182394>。

---

## 作者：Sio_ (赞：4)

将序列中的点分为两个部分，被 $\text{checkmin}$ 过的和没有 $\text{checkmin}$ 过的。     
容易发现被 $\text{checkmin}$ 过的点具有明显的单调性，即 $\forall i<j,a_i<a_j$，于是一操作可以转化为后缀覆盖，这一部分可以直接分块。    
对于没有被 $\text{checkmin}$ 过的点，我们可以维护最大值，如果在一次 $\text{checkmin}$ 中，这些点的最大值大于 $v$，就可以扔进另一个部分。    
维护最大值的方式很经典，相信大部分人都见过，类似[CF573E Bear and Bowling](https://www.luogu.com.cn/problem/CF573E)，容易发现点值的式子类似斜率优化，分块维护凸壳即可，单点删除直接暴力重构。    
时间复杂度 $O(n\sqrt n)$，我的代码跑的有点慢。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e5+5,inf=1e18;
int n,q,a[maxn],l[maxn],r[maxn],c[maxn],tot,len,vis[maxn];
struct B1
{
    int l,r,k,sum,ksum;
    deque<int> dq;
    int g(int x){return a[x]+k*x;}
    double slope(int x,int y){return 1.0*(a[x]-a[y])/(x-y);}
    void remake()
    {
        dq.clear(),sum=0,ksum=0;
        for(int i=l;i<=r;i++)
        {
            if(vis[i]==1) continue;
            a[i]=g(i),sum+=a[i],ksum+=i;
        }k=0;
        for(int i=l;i<=r;i++)
        {
            if(vis[i]==1) continue;
            while(dq.size()>=2&&slope(dq[dq.size()-2],dq[dq.size()-1])<slope(dq[dq.size()-1],i)) dq.pop_back();
            dq.push_back(i);
        }
    }
    pair<int,int> query()
    {
        if(dq.size()==0) return {-inf,0}; 
        while(dq.size()>=2&&slope(dq[0],dq[1])>=-1.0*k) dq.pop_front();
        return {g(dq[0]),dq[0]};
    }
    int getsum(){return sum+k*ksum;}
}b1[maxn];
struct B2
{
    int l,r,k,sum,ksum,tag,cnt;
    vector<int> v;
    int g(int cur)
    {
        if(tag!=inf) return tag+k*cur;
        else return a[cur]+k*cur;
    }
    void pushdown(int cur){a[cur]=g(cur);}
    void insert(int x)
    {
        for(int i=0;i<v.size();i++) pushdown(v[i]);tag=inf,k=0;
        cnt++;
        v.insert(lower_bound(v.begin(),v.end(),x),x);
        sum=0,ksum=0;
        for(int i=0;i<v.size();i++) sum+=a[v[i]],ksum+=v[i];
    }
    int getsum(){return sum+ksum*k;}
    int maxi(){return g(v.back());}
    int mini(){return g(v.front());}
    void checkmin(int x)
    {
        for(int i=0;i<v.size();i++) pushdown(v[i]),a[v[i]]=min(a[v[i]],x);tag=inf,k=0;
        sum=0,ksum=0;
        for(int i=0;i<v.size();i++) sum+=a[v[i]],ksum+=v[i];
    }
}b2[maxn];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>q,len=max((int)sqrt(n/1.8),1ll);
    for(int i=1;i<=n;i++) cin>>a[i];
    while(r[tot]!=n) tot++,l[tot]=r[tot-1]+1,r[tot]=min(l[tot]+len-1,n);
    for(int i=1;i<=tot;i++)
    {
        b2[i].l=b1[i].l=l[i],b2[i].r=b1[i].r=r[i],b1[i].remake();
        b2[i].tag=inf;
        for(int k=l[i];k<=r[i];k++) c[k]=i;
    }
    int cnt=0;
    while(q--)
    {
        int opt,v,lt,rt;
        cin>>opt;
        if(opt==3)
        {
            cin>>lt>>rt;
            int LT=c[lt],RT=c[rt],ans=0;
            if(LT==RT)
            {
                for(int i=lt;i<=rt;i++)
                {
                    ans+=(vis[i]==0)?b1[LT].g(i):b2[LT].g(i);
                    // cout<<b1[LT].k<<" "<<((vis[i]==0)?b1[LT].g(i):b2[LT].g(i))<<"\n";
                }
                cout<<ans<<"\n";
                // exit(0);
                continue;
            }
            for(int i=lt;i<=r[LT];i++) ans+=(vis[i]==0)?b1[LT].g(i):b2[LT].g(i);
            for(int i=l[RT];i<=rt;i++) ans+=(vis[i]==0)?b1[RT].g(i):b2[RT].g(i);
            for(int i=LT+1;i<=RT-1;i++) ans+=(b1[i].getsum()+b2[i].getsum());
            cout<<ans<<'\n';
            continue;
        }
        if(opt==2){for(int i=1;i<=tot;i++) b1[i].k++,b2[i].k++;continue;}
        cin>>v;
        for(int i=tot;i>=1;i--)
        {
            if(b2[i].v.size()==0) continue;
            if(b2[i].maxi()<=v) continue;
            if(b2[i].mini()>=v){b2[i].k=0,b2[i].tag=v,b2[i].sum=b2[i].cnt*v;continue;}
            b2[i].checkmin(v);
        }
        while(1)
        {
            pair<int,int> ans;
            ans.first=-inf,ans.second=0;
            for(int i=1;i<=tot;i++) ans=max(ans,b1[i].query());
            if(ans.second==0||ans.first<v) break;
            a[ans.second]=v;
            vis[ans.second]=1,b1[c[ans.second]].remake();
            b2[c[ans.second]].insert(ans.second);
        }
    }
}
```

---

## 作者：Luciylove (赞：4)

# Preface

本题解完成于 2024/9/9 系速浪的女帝 Sora Ginko 生日，望周知。

本题解给出了一个 $O(n \log^2 n)$ 的**在线**做法。

# Solution

不妨视这些东西为一堆一次函数。

注意到题目要求全局取 $\min$，全局竖线平移。

直接做显然是很难设计 SegBeats 半群的，我们需要观察 $a_i$ 被取 $\min$ 后有什么性质。

我们称这个集合为 $T$。

可以观察出 $T$ 在任意时刻都单调：

- 加入这个集合的时候，集合中小于他的数全部都 $\leq x$
- 这个时刻还没有加入这个集合的斜率小于他的数的值 $\leq v$，所以满足截距小于等于他，所以未来的值只会比他大。

这样优秀的性质令人心安，因为单调，可以使用线段树直接二分、推平一段区间，而因为对应的斜率也是单调的，所以 $a_i \to a_i + i$ 这样的竖线平移是不会破坏单调性质的。

然后我们怎么维护不在 $T$ 集合中的数呢？

维护区间和只需要使用全局加、区间和的任意黑盒即可，问题是怎么在每次取 $\min$ 后求出哪些点在 $T$ 里面，我们需要撤销这些点。

问题等价于求全局一次函数最高点，注意到竖线平移量均为正数，大炮打蚊子地使用 [KTT](https://www.luogu.com.cn/article/rx16evsy) 即可。

我们稍微不严谨地分析一下，与分块凸包类似地，斜率更大的直线会越换越上去，所以势能 $\phi(n) = O(n\log n)$，再算上 $O(\log n)$ 次递归至少减少 $O(1)$ 的是能，所以复杂度是 $O(n \log^2 n)$，而其他黑盒则是简单的线性对数，所以复杂度是 $O(n\log^2n)$。

代码并不难以实现，甚至战斗爽！

# Code


```cpp
/*
Pro : Easy Ds
Index : Uoj #712
Coder : Custlo0793 
Time : 2024/9/9

Happy Birthday For Sora Ginko <3 
best radix asteris for you！
*/
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = l; i <= r; i ++)
#define per(i, r, l) for (int i = r; i >= l; i --)
#define lc x << 1
#define rc x << 1 | 1

using namespace std;

using ll = long long;
const int _ = 2e5 + 5;
const ll inf = 4e18;

ll read() {
	ll x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * f;
}

int n, q;
ll a[_];
namespace sora {
	ll sum[_ << 2], c[_ << 2], ad[_ << 2];
	void apply (int x, ll k) { sum[x] += c[x] * k, ad[x] += k; }
	void pushdown (int x) {
		if (ad[x])
			apply(lc, ad[x]), apply(rc, ad[x]), ad[x] = 0;
	}
	void build (int x, int l, int r) {
		if (l == r) return c[x] = l, sum[x] = a[l], void();
		int mid = (l + r) >> 1;
		build(lc, l, mid), build(rc, mid + 1, r);
		c[x] = c[lc] + c[rc], sum[x] = sum[lc] + sum[rc];
	}
	void insec (int x, int l, int r, ll v) {
		if (l == r) return sum[x] = c[x] = 0, void();
		int mid = (l + r) >> 1; pushdown(x);
		v <= mid ? insec(lc, l, mid, v) : insec(rc, mid + 1, r, v);
		sum[x] = sum[lc] + sum[rc], c[x] = c[lc] + c[rc];
	}
	ll query (int x, int l, int r, int ql, int qr) {
		if (ql <= l && r <= qr) return sum[x];
		int mid = (l + r) >> 1; ll ret = 0; pushdown(x);
		if (ql <= mid) ret += query(lc, l, mid, ql, qr);
		if (qr > mid) ret += query(rc, mid + 1, r, ql, qr);
		return ret;
	} 
} // T1
namespace ginko {
	struct lazy {
		ll ass, ad;
		lazy operator + (const lazy &x) const {
			if (~x.ass) return x;
			return {ass, ad + x.ad};
		}
	} Tag[_ << 2];
	struct Info {
		ll v, rv, c, ci, sum;
		Info operator + (const Info &x) const {
			if (!x.v) return *this;
			return {x.v, x.rv, c + x.c, ci + x.ci, sum + x.sum};
		}	
		Info operator + (const lazy &x) const {
			Info ret = *this;
			if (~x.ass)
				ret.rv = x.ass, ret.sum = x.ass * c;
			ret.rv += v * x.ad, ret.sum += ci * x.ad;
			return ret;
		}
	} info[_ << 2];
	void apply (int x, lazy v) {
		info[x] = info[x] + v, Tag[x] = Tag[x] + v;
	}
	void pushdown (int x) {
		if (~Tag[x].ass || Tag[x].ad)
			apply(lc, Tag[x]), apply(rc, Tag[x]);
		Tag[x] = {-1, 0};
	}
 	void insert (int x, int l, int r, int p, ll v) {
 		if (l == r) return info[x] = {l, v, 1, l, v}, void();
 		int mid = (l + r) >> 1; pushdown(x);
 		p <= mid ? insert(lc, l, mid, p, v) : insert(rc, mid + 1, r, p, v);
 		info[x] = info[lc] + info[rc];
 	}
 	void modify (int x, int l, int r, int ql, int qr, lazy v) {
 		if (ql <= l && r <= qr) return apply(x, v);
 		int mid = (l + r) >> 1; pushdown(x);
 		if (ql <= mid) modify(lc, l, mid, ql, qr, v);
 		if (qr > mid) modify(rc, mid + 1, r, ql, qr, v);
 		return info[x] = info[lc] + info[rc], void();
 	}
 	ll query (int x, int l, int r, int ql, int qr) {
 		if (ql <= l && r <= qr) return info[x].sum;
 		int mid = (l + r) >> 1; ll ret = 0; pushdown(x);
 		if (ql <= mid) ret = query(lc, l, mid, ql, qr);
 		if (qr > mid) ret += query(rc, mid + 1, r, ql, qr);
 		return ret;
 	}
 	int findpos (int x, int l, int r, ll v) {
 		if (info[x].rv < v) return -1;
 		if (l == r) return l;
 		int mid = (l + r) >> 1; pushdown(x);
 		int ret = findpos(lc, l, mid, v);
 		if (~ret) return ret;
 		return findpos(rc, mid + 1, r, v);
 	}
 	void chkmin (ll v) {
 		int p = findpos(1, 1, n, v);
 		if (~p) modify(1, 1, n, p, n, {v, 0});
 	}
} // T2

namespace ktt {	
	ll ad[_ << 2], thr[_ << 2];
	struct line {
		ll k, b, id;
	} t[_ << 2];
	pair<line, ll> calc (line x, line y) {
		if (x.b < y.b) swap(x, y);
		return {x, (x.k < y.k) ? (x.b - y.b) / (y.k - x.k) : inf};
	}
	void apply (int x, ll v) {
		ad[x] += v, t[x].b += v * t[x].k, thr[x] -= v;
	}
	void pushdown (int x) {
		if (ad[x])
			apply(lc, ad[x]), apply(rc, ad[x]), ad[x] = 0;
	}
	void pushup (int x) {
		pair<line, ll> v = calc(t[lc], t[rc]);
		t[x] = v.first;
		thr[x] = min({v.second, thr[lc], thr[rc]});
	}
	void build (int x, int l, int r) {
		if (l == r) return t[x] = {l, a[l], l}, thr[x] = inf, void();
		int mid = (l + r) >> 1;
		build(lc, l, mid), build(rc, mid + 1, r);
		pushup(x);
	}
	void insec (int x, int l, int r, int v) {
		if (l == r) return t[x] = {0, -inf, l}, void();
		int mid = (l + r) >> 1; pushdown(x);
		v <= mid ? insec(lc, l, mid, v) : insec(rc, mid + 1, r, v);
		pushup(x);
	}
	void modify (int x, int l, int r, int ql, int qr, ll v) {
		if (ql <= l && r <= qr && thr[x] >= v) return apply(x, v);
		int mid = (l + r) >> 1; pushdown(x);
		if (ql <= mid) modify(lc, l, mid, ql, qr, v);
		if (qr > mid) modify(rc, mid + 1, r, ql, qr, v);
		return pushup(x);
	}
} // find s2 node

int main () {
	// freopen("2.in", "r", stdin);
	// freopen("2.out", "w", stdout);
	n = read(), q = read();
	rep(i, 1, n) a[i] = read();
	sora :: build(1, 1, n), ktt :: build(1, 1, n);
	rep(i, 1, q) {
		int op, l, r; ll v;
		op = read();
		if (op == 1) {
			v = read();
			while (ktt :: t[1].b >= v) {
				int id = ktt :: t[1].id;
				ktt :: insec(1, 1, n, id);
				sora :: insec(1, 1, n, id);
				ginko :: insert(1, 1, n, id, v);
			}
			ginko :: chkmin(v);
		} 
		if (op == 2) {
			ktt :: modify(1, 1, n, 1, n, 1);
			sora :: apply(1, 1), ginko :: apply(1, {-1, 1});
		} 
		if (op == 3) {
			l = read(), r = read();
			printf("%lld\n", sora :: query(1, 1, n, l, r) + ginko :: query(1, 1, n, l, r));
		}
	}
	return 0;
}
```

---

## 作者：lalaouye (赞：4)

简单数据结构，但本蒟蒻觉得并不简单呐！

容易发现这题的几个好用的性质：

1. 只要被第一个操作影响的都能够保持单调，容易一起维护。

2. 操作都是全局的！

3. 没被操作一影响的都可以表示为 $ki+a_i$ 的形式。

利用这些性质，我们考虑把没被操作一影响的项放在 $S$ 集合，被操作一影响的项放在 $T$ 集合。现在我们考虑动态维护这两个东西，事实上我们可以先知道每一项是在什么时候从 $S$ 进入 $T$ 的（显然初始每一项都在 $S$）。

每次我们进行操作一时，都会把所有满足 $a_i\ge v-ki$ 的所有项并入 $T$，这种一次函数的形式启发我们维护一个凸包，上面每个点为 $(i,a_i)$，然后维护一个上凸包，但是凸包太大了，不好修改，怎么办？我们发现删点与重构凸包复杂度非常不均，~~所以考虑分块~~，我们这样每次删掉一个点，再 $\mathcal{O}(\sqrt n)$ 重构即可。因为只会删掉 $n$ 个点，所以复杂度是对的，但是这里有个小问题，就是我们单次操作找每个块内凸包的点有可能退化到 $\mathcal{O}(n)$，没关系，我们的 $k$ 是单调的，每个块内维护个双指针即可。

对答案的贡献用树状数组可以简单维护。

然后考虑维护 $T$，首先对于 $1$ 操作相当于是一段后缀推平，线段树上二分随便做。对于操作二的贡献在线段树上维护增加次数 $delta$，并且维护可提供贡献的点 $sum$，因为线段树上可以产生贡献的点并不连续。对于最大值的维护也是简单的，知道区间中最右边的在 $T$ 中的点就知道最大值了。

时间复杂度 $\mathcal{O}(n\sqrt n)$，这里 $n,q$ 同级。

代码：

````
#include <bits/stdc++.h>
#define int long long
#define rep(i, l, r) for (int i = l; i <= r; ++ i)
#define rrp(i, l, r) for (int i = r; i >= l; -- i)
#define pii pair <int, int>
#define eb emplace_back
#define inf 1000000000
#define id(x, y) n * (x - 1) + y
#define ls p << 1
#define rs ls | 1
using namespace std;
constexpr int N = 2e5 + 5, M = (1ll << 31) - 1, P = 998244353;
constexpr double PI = acos (-1.0);
inline int rd () {
  int x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch)) {
    if (ch == '-') f = -1;
    ch = getchar ();
  }
  while (isdigit (ch)) {
    x = (x << 1) + (x << 3) + ch - 48;
    ch = getchar ();
  }
  return x * f;
}
int qpow (int x, int y) {
  int ret = 1;
  for (; y; y >>= 1, x = x * x % P) if (y & 1) ret = ret * x % P;
  return ret;
}

namespace seg {
  class node {
    public:
      int sum, val, mx, R, cnt, tag1, tag2;
  } t[N << 2];
  void clear () {
    rep (i, 1, N * 4 - 1) {
      t[i].sum = t[i].val = 0;
      t[i].mx = t[i].R = t[i].cnt = 0;
      t[i].tag1 = - 1; t[i].tag2 = 0;
    }
  }
  void merge (node &ret, node x, node y) {
    ret.sum = x.sum + y.sum;
    ret.val = x.val + y.val;
    ret.mx = max (x.mx, y.mx);
    ret.R = max (x.R, y.R);
    ret.cnt = x.cnt + y.cnt;
  }
  void cov (int p, int val) {
    t[p].val = t[p].cnt * val;
    t[p].mx = val;
    t[p].tag1 = val;
    t[p].tag2 = 0;
  }
  void add (int p, int x) {
    t[p].val += t[p].sum * x;
    t[p].mx += t[p].R * x; 
    t[p].tag2 += x;
  }
  void psd (int p) {
    if (t[p].tag1 > -1) {
      cov (ls, t[p].tag1);
      cov (rs, t[p].tag1);
      t[p].tag1 = -1;
    }
    if (t[p].tag2) {
      add (ls, t[p].tag2);
      add (rs, t[p].tag2);
      t[p].tag2 = 0;
    }
  }
  int find (int p, int l, int r, int x) {
    if (l == r) {
      if (t[p].val >= x) return l; else return 0;
    }
    int mid = l + r >> 1;
    psd (p);
    
    if (t[ls].mx >= x) return find (ls, l, mid, x);
    else return find (rs, mid + 1, r, x);
  }
  void modify (int p, int l, int r, int L, int R, int v) {
    if (L <= l && r <= R) return cov (p, v), void ();
    int mid = l + r >> 1; psd (p);
    if (L <= mid) modify (ls, l, mid, L, R, v);
    if (R > mid) modify (rs, mid + 1, r, L, R, v);
    merge (t[p], t[ls], t[rs]);
  }
  void upd (int p, int l, int r, int x, int k) {
    if (l == r) {
      t[p].sum = x, t[p].cnt = 1;
      t[p].R = x, t[p].val = t[p].mx = k;
      return ;
    } psd (p); int mid = l + r >> 1;
    if (x <= mid) upd (ls, l, mid, x, k);
    else upd (rs, mid + 1, r, x, k);
    merge (t[p], t[ls], t[rs]);
  }
  int qry (int p, int l, int r, int L, int R) {
    if (L <= l && r <= R) return t[p].val;
    int mid = l + r >> 1, ret = 0; psd (p);
    if (L <= mid) ret += qry (ls, l, mid, L, R);
    if (R > mid) ret += qry (rs, mid + 1, r, L, R);
    return ret;
  }
}

int n, m, q;
int a[N];
struct FWT {
  int c[N];
  int lb (int x) { return x & -x; }
  void upd (int x, int y) {
    for (; x <= n; c[x] += y, x += lb (x)) ;
  }
  int qry (int x) {
    int ret = 0;
    for (; x; ret += c[x], x -= lb (x)) ;
    return ret;
  }
} s, t;
class node {
  public:
    int opt;
    int l, r;
} g[N];

class Dot {
  public:
    int x, y;
  friend Dot operator + (const Dot &a, const Dot &b) {
    return (Dot) {a.x + b.x, a.y + b.y};
  }
  friend Dot operator - (const Dot &a, const Dot &b) {
    return (Dot) {a.x - b.x, a.y - b.y};
  }
  friend int operator * (const Dot &a, const Dot &b) {
    return a.x * b.y - a.y * b.x;
  }
} d[N];
vector <int> vec[N];
class block {
  public:
  int l, r, ld, rd;
  int stk[505];
  void build () {
    l = 1, r = 0;
    rep (i, ld, rd) {
      if (d[i].y < 0) continue;
      while (l < r && (d[stk[r]] - d[stk[r - 1]]) * (d[i] - d[stk[r]]) >= 0) -- r;
      stk[++ r] = i;
    }
  }
  void del (int k, int id, int x) {
    while (l <= r) {
      while (l < r && d[stk[l]].x * k + d[stk[l]].y <= d[stk[l + 1]].x * k + d[stk[l + 1]].y) ++ l;
      if (d[stk[l]].x * k + d[stk[l]].y >= x) vec[id].eb (d[stk[l]].x), d[stk[l]].y = -1; else return ;
      build ();
    }
  }
} bl[505];
void init () {
  int B = sqrt (n);
  m = n / B + (bool) (n % B);
  rep (i, 1, m) {
    bl[i].ld = bl[i - 1].rd + 1;
    bl[i].rd = min (bl[i - 1].rd + B, n);
    bl[i].build ();
  }
}
signed main () {
  // freopen ("1.in", "r", stdin);
  // freopen ("1.out", "w", stdout);
  n = rd (), q = rd ();
  rep (i, 1, n) a[i] = rd (), d[i] = (Dot) {i, a[i]};
  init ();
  int now = 0;
  rep (i, 1, q) {
    g[i].opt = rd ();
    if (g[i].opt == 1) {
      g[i].l = rd ();
      rep (j, 1, m) bl[j].del (now, i, g[i].l);
    } else if (g[i].opt == 2) {
      ++ now;
    } else g[i].l = rd (), g[i].r = rd ();
  }
  rep (i, 1, n) {
    s.upd (i, i), t.upd (i, a[i]);
  }
  seg::clear ();
  now = 0;
  rep (i, 1, q) {
    if (g[i].opt == 1) {
      int pos = seg::find (1, 1, n, g[i].l);
      if (pos) seg::modify (1, 1, n, pos, n, g[i].l);
      for (auto p : vec[i]) {
        s.upd (p, - p), t.upd (p, - a[p]);
        seg::upd (1, 1, n, p, g[i].l);
      }
    } else {
      if (g[i].opt == 2) {
        ++ now; seg::add (1, 1);
      } else {
        int l = g[i].l, r = g[i].r;
        printf ("%lld\n", now * (s.qry (r) - s.qry (l - 1)) + t.qry (r) - t.qry (l - 1) + seg::qry (1, 1, n, l, r));
      }
    }
  }
}
````

---

## 作者：FstAutoMaton (赞：3)

## [[北大集训 2021] 简单数据结构](https://www.luogu.com.cn/problem/P8987)

大大大大大ds。

首先考虑考虑最开始所有的 $a_i$ 都为 $0$ 时怎么做。

那么此时 $a$ 是单调不降的，用线段树维护区间和区间最大值并支持对 $a_i$ 加上 $i$，每次 $\text{checkmin}$ 就是把一段后缀赋值成某一个数，至于后缀位置就是从后往前最后一个大于操作给出的 $x$ 的位置，在线段树上二分即可。

接着考虑如果 $a_i$ 最开始不等于 $0$ 怎么办。

不难发现，那些受到操作 $1$ 影响的数一定是递增的，而没有受到操作 $1$ 影响的数可以被表示成 $a_i+k\times i$（其中 $k$ 是操作 $2$ 的次数），所以考虑把这 $n$ 个数分成受到操作 $1$ 影响和没有受到操作 $1$ 影响两个部分，设没有被影响的集合为 $S$，被影响的集合为 $T$，用线段树维护即可。

那么现在的问题是如何在 $\text{checkmin}$ 的时候把 $S$ 中的一些元素快速的丢到 $T$ 里去。

考虑哪些要从集合 $S$ 丢到 $T$ 中的数满足什么性质。令当前操作 $2$ 此时为 $k$，不难发现这些数要满足 $a_i+k\times i\geq c$，移项可以得到 $a_i\geq c-k\times i$。这相当于要将一个半平面内的数从 $S$ 丢到 $T$，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/8a9r48w3.png)

这些红色的点就是需要移除的。

考虑分块凸包。把每个数看作一个点 $\left(i,a_i\right)$，然后分成 $\sqrt{n}$ 个块。每个块内建立一个下凸壳，每次暴力在凸壳上找到一个点使得 $y\geq k\times x+b$（$k$ 在本题中是当前操作 $2$ 的个数的相反数，$b$ 是 $\text{checkmin}$ 时题目给出的 $x$），然后把这个点删掉。删掉后可以直接暴力重构凸壳。这样子每次删掉一个点复杂度是 $\operatorname{O}(\sqrt{n})$ 的（因为已经满足 $x$ 递增了，不需要排序），一个点只会被删 $1$ 次，所以这部分的时间复杂度是 $\operatorname{O}(n\sqrt{n})$ 的。删除的时候可以双指针做（每次删点不要重新从凸壳的第一个点开始遍历，直接从被删除的点的前一个开始），但其实直接从头遍历好像复杂度也是对的（？

由于 $T$ 中不一定包含所有数，所以线段树要记录每个位置上的数有没有加入 $T$，记录的信息只记录已经加入了 $T$ 的那些数。集合 $S$ 可以用树状数组维护，因为只要维护第 $i$ 个位置是否存在 $S$ 中，然后每次找到在分块凸包中被删除的数单点修改。

总时间复杂度 $\operatorname{O}(n\sqrt n)$

代码比较复杂，细节比较多，要稍微注意一下线段树下传 `tag` 时加法和赋值的顺序以及对区间最大值和区间和的影响。

[code](https://www.luogu.com.cn/paste/2rdlpzfj)

---

## 作者：WrongAnswer_90 (赞：2)

[P8987 [北大集训 2021] 简单数据结构](https://www.luogu.com.cn/problem/P8987)

[更好的阅读体验](https://www.cnblogs.com/WrongAnswer90-home/p/18027877)

挺有意思的题。

初步的想法是如果 $i<j\wedge a_i\leq a_j$ 则在之后的操作中 $a_i$ 一定仍然不大于 $a_j$。

接下来是一个很妙的转化：把每个数看成坐标系中 $i,a_i$ 的点。正常的取 $\min$ 操作是对于一条直线 $y=k$ 取 $\min$，但是经过了几次 $2$ 操作后变成了对于一条斜率为“负操作二次数”的直线，纵轴截距为 $k$ 的直线取 $\min$，处理到 $2$ 操作暂时先不管它，少加的部分之后处理。

因为直线斜率单调不增，考虑操作一定是对这个凸包上的一段后缀的**真实值**做区间推平的操作，这个相对容易处理。

发现一个点如果在凸包上则以后一定还在凸包上，考虑如何计算出每个点变成凸包边界上的点的时间，可以使用整体二分，转为查询当前 $y-ix$ 的最小值，类似斜率优化，维护 $(x,y)$ 的下凸壳，因为原用来取 $\min$ 的直线斜率（即当前的 $x$）和查询的 $i$（即当前直线的斜率）都单增，先把全部点都插进去然后指针扫描一下即可。

找出每个点第一次击破时间后问题就很简单了。线段树维护，如果当前操作后某个点从不是凸包上变成了凸包边界，则激活该点，显然全局取 $\min$ 对于未激活点是无效的，而激活点是单增的，可以线段树上二分然后区间推平。

需要三个标记，推平的值，未激活点操作 $2$ 次数和激活点操作 $2$ 次数，信息需要维护激活点下标和，激活点权值和，区间最右侧激活点的下标和权值（线段树上二分要用），区间和，还是有一些细节的。

总复杂度 $\mathcal O((n +q)\log n)$。

```cpp
	int n,m,top,len,st[200010],a[200010],ans[200010],pre[200010],Id[200010],id[200010],id1[200010],id2[200010];
	tup b[200010];
	vector<int> ve[200010];
	namespace Segment
	{
		#define ls(p) (t[p].l+t[p].r)
		#define rs(p) ((t[p].l+t[p].r)^1)
		struct{int l,r,si,sv,sx,ri,rv,s,tg1,tg2,tg3;}t[400010];
		inline void down1(int p,int x)
		{
			if(!t[p].ri)return;
			t[p].tg3=0,t[p].rv=t[p].tg1=x,t[p].s-=t[p].sv;
			t[p].sv=t[p].si*x,t[p].s+=t[p].sv;
		}
		inline void down2(int p,int x)
		{
			t[p].s+=x*((t[p].l+t[p].r)*(t[p].r-t[p].l+1)/2-t[p].sx);
			t[p].tg2+=x;
		}
		inline void down3(int p,int x)
		{
			if(!t[p].ri)return;
			t[p].s+=t[p].sx*x,t[p].sv+=t[p].sx*x;
			t[p].rv+=t[p].ri*x,t[p].tg3+=x;
		}
		inline void spread(int p)
		{
			if(~t[p].tg1)down1(ls(p),t[p].tg1),down1(rs(p),t[p].tg1),t[p].tg1=-1;
			if(t[p].tg2)down2(ls(p),t[p].tg2),down2(rs(p),t[p].tg2),t[p].tg2=0;
			if(t[p].tg3)down3(ls(p),t[p].tg3),down3(rs(p),t[p].tg3),t[p].tg3=0;
		}
		inline void update(int p)
		{
			assert(t[p].tg1==-1),assert(!t[p].tg2),assert(!t[p].tg3);
			t[p].ri=t[ls(p)].ri,t[p].rv=t[ls(p)].rv;
			if(t[rs(p)].ri)t[p].ri=t[rs(p)].ri,t[p].rv=t[rs(p)].rv;
			t[p].s=t[ls(p)].s+t[rs(p)].s,t[p].sv=t[ls(p)].sv+t[rs(p)].sv;
			t[p].si=t[ls(p)].si+t[rs(p)].si,t[p].sx=t[ls(p)].sx+t[rs(p)].sx;;
		}
		void build(int p,int l,int r)
		{
			t[p].l=l,t[p].r=r,t[p].tg1=-1;
			if(l==r)return t[p].s=a[l],void();
			int mid=l+((r-l)>>1);
			build(ls(p),l,mid),build(rs(p),mid+1,r),update(p);
		}
		void change(int p,int l,int x)
		{
			if(l<=t[p].l)return down1(p,x);
			spread(p),change(rs(p),l,x);
			if(l<=t[ls(p)].r)change(ls(p),l,x);
			update(p);
		}
		void active(int p,int x,int y)
		{
			if(t[p].l==t[p].r)
			{
				t[p].sv=t[p].s=y,t[p].si=1;
				t[p].sx=t[p].ri=t[p].l,t[p].rv=y;
				return;
			}
			spread(p);
			if(x<=t[ls(p)].r)active(ls(p),x,y);
			else active(rs(p),x,y);
			update(p);
		}
		int find(int p,int v)
		{
			if(!t[p].ri)return inf;
			if(t[p].l==t[p].r)return t[p].rv>=v?t[p].l:inf;
			spread(p);
			if(t[ls(p)].rv<=v)return find(rs(p),v);
			return find(ls(p),v);
		}
		int ask(int p,int l,int r)
		{
			if(l<=t[p].l&&r>=t[p].r)return t[p].s;
			spread(p);
			if(r<=t[ls(p)].r)return ask(ls(p),l,r);
			if(l>t[ls(p)].r)return ask(rs(p),l,r);
			return ask(ls(p),l,r)+ask(rs(p),l,r);
		}
		void print(int x)
		{
			if(t[x].l==t[x].r)return write(t[x].s);
			spread(x);
			print(ls(x)),print(rs(x));
		}
	}
	using namespace Segment;
	#define dy(i,j) (b[j].y-b[i].y)
	#define dx(i,j) (pre[j]-pre[i]+eps)
	inline void ins(int x)
	{
		while(top>1&&(db)(dy(st[top],x)*dx(st[top-1],st[top]))<=(db)(dy(st[top-1],st[top])*dx(st[top],x)))--top;
		st[++top]=x;
	}
	void solve(int L,int R,int l,int r)
	{
		if(l>r)return;
		if(L==R){for(int i=l;i<=r;++i)ans[Id[i]]=L;return;}
		int mid=L+((R-L)>>1),len1=0,len2=0;top=0;
		for(int i=L;i<=mid;++i)ins(id[i]);
		for(int i=l,j=1;i<=r;++i)
		{
			while(j<top&&(db)(dy(st[j],st[j+1]))<=(db)(Id[i]*dx(st[j],st[j+1])))++j;
			int v=b[st[j]].y-pre[st[j]]*Id[i];
			if(v<=a[Id[i]])id1[++len1]=Id[i];
			else id2[++len2]=Id[i];
		}
		for(int i=1;i<=len1;++i)Id[i+l-1]=id1[i];
		for(int i=1;i<=len2;++i)Id[i+l+len1-1]=id2[i];
		solve(L,mid,l,l+len1-1),solve(mid+1,R,l+len1,r);
	}
	inline void mian()
	{
		read(n,m);int opt,x;
		for(int i=1;i<=n;++i)read(a[i]),Id[i]=i;
		for(int i=1,minn=INF;i<=m;++i)
		{
			read(opt),pre[i]=pre[i-1]+(opt==2);
			if(opt==1)
			{
				read(x),b[i]=tup(opt,x,0);
				if(x>=minn){--m,--i;continue;}
				minn=x,id[++len]=i;
			}
			else if(opt==3)read(b[i].y,b[i].z),b[i].x=3;
			else minn=INF,b[i]=tup(opt,0,0);
		}
		solve(1,len+1,1,n),build(1,1,n);
		for(int i=1;i<=n;++i)if(ans[i]<=len)ve[id[ans[i]]].eb(i);
		for(int i=1;i<=m;++i)
		{
			if(b[i].x==1)
			{
				x=find(1,b[i].y);
				x<inf?change(1,x,b[i].y),0:0;
			}
			else if(b[i].x==2)down2(1,1),down3(1,1);
			else write(ask(1,b[i].y,b[i].z),'\n');
			for(auto j:ve[i])active(1,j,b[i].y);
		}
	}
```

---

## 作者：SegTree (赞：1)

考虑如果 $a$ 没有初值（全为 $0$）怎么做。维护每个位置的值 $ki+b$，每次 chkmin 的是一段后缀，打个区间赋值标记，计算区间和是简单的。

考虑如果没有 chkmin 操作，那么问题也是简单的。

注意到被 chkmin 过的位置对应的值具有单调性，于是动态维护被 chkmin 过的位置，对他们执行一开始的算法，剩下的单算，问题转化为求出每个数被 chkmin 的最小时间。

写出限制，$a_i+ic_j\ge v_j$，求满足条件的最小 $j$。整体二分，求出 $(c_j,v_j)$ 的下凸包即可，由于单调性可以做到线性判定，因此时间复杂度 $O(n\log n)$。

[submission](https://uoj.ac/submission/783106)。

---

## 作者：xzCyanBrad (赞：1)

为啥要凸包，我推不动（（（

注意到当 $a$ 数列非严格单增时，不管咋操作 $a$ 还是会非严格单增。

下面称一操作为 checkmin。

注意到成功进行过 checkmin 的点，把他们抽出来后他们的 $a$ 是单增的。

这启发我们分成两部分考虑，checkmin 前的和后的。考虑每个点只会被 checkmin 一次就会从一变成二，所以你可在每个 checkmin 的时候暴力弹出第一部分最大值尝试 checkmin，如果成功丢到第二个部分。

第一个部分需要支持：区间加等差数列，单点修改，区间 max，区间和。不难发现一个 KTT 和一个线段树就行了。

第二个部分因为 $a$ 值单增，直接暴力在线段树上二分要修改的区间，然后区间推平。所以需要支持 区间加等差数列，单点修改，区间和，区间推平。这只用一个线段树就行了。

有点细节。支持在线，复杂度三只老哥，但是 ktt 完全无法卡满所以比较轻松地过了。

::::info[代码]
  
```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for (int i = (a), i##ABRACADABRA = (b); i <= i##ABRACADABRA; i++)
#define drep(i, a, b) for (int i = (a), i##ABRACADABRA = (b); i >= i##ABRACADABRA; i--)
using namespace std;
using ll = long long;
constexpr ll inf=1e18,piv=1e13;

int n,q;
ll a[200010];
namespace KTT{
  int L[800010],R[800010];
  ll tag[800010];
  struct line{
    ll k,b;
    friend line operator+(line p,line q){return {p.k+q.k,p.b+q.b};}
  };
  inline pair<line,ll>gmx(line x,line y){
    if (x.k<y.k||(x.k==y.k&&x.b<y.b))swap(x,y);
    if (x.b>=y.b)return {x,inf};
    else return {y,(y.b-x.b)/(x.k-y.k)};
  }
  struct node{
    line l;
    ll x;
    friend node operator+(node p,node q){
      node t;
      t.x=min(p.x,q.x);
      auto [nl,nx]=gmx(p.l,q.l);
      t.x=min(t.x,nx);
      t.l=nl;
      return t;
    }
  }t[800010],base={{-inf,-inf},inf};
  void bld(int p,int l,int r){
    L[p]=l,R[p]=r,tag[p]=0;
    if (l==r){
      line z={l,a[l]};
      t[p]={z,inf};
      return ;
    }
    int mid=(l+r)>>1;
    bld(p<<1,l,mid);
    bld(p<<1|1,mid+1,r);
    t[p]=t[p<<1]+t[p<<1|1];
    // cout<<l<<' '<<r<<' '<<t[p].x<<'\n';
  }
  void get(int p,ll w){
    tag[p]+=w,t[p].x-=w;
    t[p].l.b+=t[p].l.k*w;
  }
  void chg(int p,ll w){
    // cout<<p<<' '<<L[p]<<' '<<R[p]<<' '<<t[p].x<<'\n';
    if (w<=t[p].x){
      get(p,w);
      return ;
    }
    ll ww=tag[p]+w;
    tag[p]=0;
    chg(p<<1,ww);
    chg(p<<1|1,ww);
    t[p]=t[p<<1]+t[p<<1|1];
  }
  void down(int p){
    if (tag[p]){
      get(p<<1,tag[p]);
      get(p<<1|1,tag[p]);
      tag[p]=0;
    }
  }
  void upd(int p,int ql,int qr,ll w){
    if (L[p]>qr||R[p]<ql||ql>qr)return ;
    if (ql<=L[p]&&R[p]<=qr)return chg(p,w);
    down(p);
    upd(p<<1,ql,qr,w);
    upd(p<<1|1,ql,qr,w);
    t[p]=t[p<<1]+t[p<<1|1];
  }
  void mdf(int p,int o,line w){
    if (L[p]==R[p]){
      t[p].l=w;
      return ;
    }
    down(p);
    int mid=(L[p]+R[p])>>1;
    if (o<=mid)mdf(p<<1,o,w);
    else mdf(p<<1|1,o,w);
    t[p]=t[p<<1]+t[p<<1|1];
  }
  node ask(int p,int ql,int qr){
    if (L[p]>qr||R[p]<ql||ql>qr)return base;
    if (ql<=L[p]&&R[p]<=qr)return t[p];
    down(p);
    return ask(p<<1,ql,qr)+ask(p<<1|1,ql,qr);
  }
}

namespace sgt{
  struct line{
    ll k,b;
    friend line operator+(line p,line q){return {p.k+q.k,p.b+q.b};}
  }t[800010];
  int L[800010],R[800010];
  ll tag[800010];
  void bld(int p,int l,int r){
    L[p]=l,R[p]=r,tag[p]=0;
    if (l==r){
      t[p]={l,a[l]};
      return ;
    }
    int mid=(l+r)>>1;
    bld(p<<1,l,mid);
    bld(p<<1|1,mid+1,r);
    t[p]=t[p<<1]+t[p<<1|1];
  }
  void get(int p,ll x){
    t[p].b+=t[p].k*x;
    tag[p]+=x;
  }
  void down(int p){
    get(p<<1,tag[p]);
    get(p<<1|1,tag[p]);
    tag[p]=0;
  }
  void upd(int p,int ql,int qr,ll x){
    if (ql>R[p]||qr<L[p]||ql>qr)return ;
    if (ql<=L[p]&&R[p]<=qr)return get(p,x);
    down(p);
    upd(p<<1,ql,qr,x);
    upd(p<<1|1,ql,qr,x);
    t[p]=t[p<<1]+t[p<<1|1];
  }
  void mdf(int p,int o,line x){
    if (L[p]==R[p]){
      t[p]=x;
      return ;
    }
    down(p);
    int mid=(L[p]+R[p])>>1;
    if (o<=mid)mdf(p<<1,o,x);
    else mdf(p<<1|1,o,x);
    t[p]=t[p<<1]+t[p<<1|1];
  }
  line ask(int p,int ql,int qr){
    if (ql>R[p]||qr<L[p]||ql>qr)return {0,0};
    if (ql<=L[p]&&R[p]<=qr)return t[p];
    down(p);
    return ask(p<<1,ql,qr)+ask(p<<1|1,ql,qr);
  }
}

namespace sgt2{
  struct line{
    ll k,b;
    friend line operator+(line p,line q){return {p.k+q.k,p.b+q.b};}
  }t[800010];
  int L[800010],R[800010],cnt[800010];
  ll tag[800010],tag2[800010];
  void bld(int p,int l,int r){
    L[p]=l,R[p]=r,tag[p]=0,tag2[p]=-1,cnt[p]=0;
    if (l==r){
      t[p]={0,0};
      return ;
    }
    int mid=(l+r)>>1;
    bld(p<<1,l,mid);
    bld(p<<1|1,mid+1,r);
    t[p]=t[p<<1]+t[p<<1|1];
  }
  void get(int p,ll x){
    t[p].b+=t[p].k*x;
    tag[p]+=x;
  }
  void get2(int p,ll x){
    t[p].b=cnt[p]*x;
    tag[p]=0;
    tag2[p]=x;
  }
  void down(int p){
    if (~tag2[p]){
      get2(p<<1,tag2[p]);
      get2(p<<1|1,tag2[p]);
      tag2[p]=-1;
    }
    get(p<<1,tag[p]);
    get(p<<1|1,tag[p]);
    tag[p]=0;
  }
  void upd(int p,int ql,int qr,ll x){
    if (ql>R[p]||qr<L[p]||ql>qr)return ;
    if (ql<=L[p]&&R[p]<=qr)return get(p,x);
    down(p);
    upd(p<<1,ql,qr,x);
    upd(p<<1|1,ql,qr,x);
    t[p]=t[p<<1]+t[p<<1|1];
    cnt[p]=cnt[p<<1]+cnt[p<<1|1];
  }
  void spec(int p,int ql,int qr,ll x){
    if (ql>R[p]||qr<L[p]||ql>qr)return ;
    if (ql<=L[p]&&R[p]<=qr)return get2(p,x);
    down(p);
    spec(p<<1,ql,qr,x);
    spec(p<<1|1,ql,qr,x);
    t[p]=t[p<<1]+t[p<<1|1];
    cnt[p]=cnt[p<<1]+cnt[p<<1|1];
  }
  void mdf(int p,int o,line x){
    if (L[p]==R[p]){
      t[p]=x;
      cnt[p]=t[p].k!=0;
      return ;
    }
    down(p);
    int mid=(L[p]+R[p])>>1;
    if (o<=mid)mdf(p<<1,o,x);
    else mdf(p<<1|1,o,x);
    t[p]=t[p<<1]+t[p<<1|1];
    cnt[p]=cnt[p<<1]+cnt[p<<1|1];
  }
  line ask(int p,int ql,int qr){
    if (ql>R[p]||qr<L[p]||ql>qr)return {0,0};
    if (ql<=L[p]&&R[p]<=qr)return t[p];
    down(p);
    return ask(p<<1,ql,qr)+ask(p<<1|1,ql,qr);
  }
  line ask_to(int p,int o){
    // cout<<"??? "<<p<<' '<<o<<' '<<t[p].k<<'\n';
    if (!t[p].k||o<L[p])return {0,0};
    if (L[p]==R[p])return t[p];
    down(p);
    line now=ask_to(p<<1|1,o);
    if (!now.k)return ask_to(p<<1,o);
    return now;
  }
  void op1(ll v){
    // cout<<"Checkmin "<<v<<'\n';
    // rep(i,1,n)cout<<ask(1,i,i).b<<" \n"[i==n];
    int lo=1,hi=n,mi,res=0;
    while (lo<=hi){
      mi=(lo+hi)>>1;
      // cout<<mi<<' '<<ask_to(1,mi).b<<'\n';
      if (ask_to(1,mi).b<v){
        res=mi;
        lo=mi+1;
      }else
        hi=mi-1;
    }
    // cout<<"GOT "<<res<<'\n';
    spec(1,res+1,n,v);
    // rep(i,1,n)cout<<ask(1,i,i).b<<" \n"[i==n];
  }
  void op2(){
    // cout<<"Range +i\n";
    upd(1,1,n,1);
    // rep(i,1,n)cout<<ask(1,i,i).b<<" \n"[i==n];
  }
  ll op3(int l,int r){
    return ask(1,l,r).b;
  }
  void ins(int i,ll x){
    mdf(1,i,{i,x});
  }
}

int main() {
#ifdef LOCAL
  freopen("datastruct.in","r",stdin);
  freopen("datastruct.out","w",stdout);
#endif
  scanf("%d%d",&n,&q);
  rep(i,1,n)scanf("%lld",&a[i]);
  KTT::bld(1,1,n);
  sgt::bld(1,1,n);
  sgt2::bld(1,1,n);
  while (q--){
    int o;
    scanf("%d",&o);
    if (o==1){
      ll v;
      scanf("%lld",&v);
      sgt2::op1(v);
      while (1){
        auto [id,z]=KTT::ask(1,1,n).l;
        if (z>=v){
          // cout<<"$ "<<id<<'\n';
          sgt2::ins(id,v);
          KTT::mdf(1,id,{0,-piv});
          sgt::mdf(1,id,{0,0});
        }else
          break;
      }
    }else if (o==2){
      KTT::upd(1,1,n,1);
      sgt2::op2();
      sgt::upd(1,1,n,1);
    }else{
      int l,r;
      scanf("%d%d",&l,&r);
      printf("%lld\n",sgt2::op3(l,r)+sgt::ask(1,l,r).b);
    }
    // rep(i,1,n)cout<<sgt2::ask(1,i,i).k<<" \n"[i==n];
  }
  return 0;
}
```
::::

---

## 作者：封禁用户 (赞：1)

#### 前言：

这里给出一篇在速度上遥遥领先的单 log 做法，轻松拿下最优解，并领先次优解超过 100ms。

#### 思路：

发现两个操作都比较复杂，考虑能否转为一个简单，一个很复杂的形式。

转换一下模型：

- 令 $ans_{l, r} = \sum_{i=l}^r a_i + cnt\sum_{i=l}^r i $。

  - 其中 $cnt $ 表示此时前面的 2 操作数量。
 
- 而 1 操作改为，对 $a_i = \min(a_i, v-cnt\cdot i) $。

所以现在关键在于动态维护 a：

- 容易发现，这个 1 操作的形式相当于在每一个时刻，让 $a_i$ 与【一条直线】取 min，并且这个直线【斜率递减】，且 $ \le0$。

- 这个东西是一个凸包，所以按照时间插入，每条直线会去 chkmin 一段 a 的后缀。

  - 理论上每条直线都应该去更新整个 $a$，但是在和之前的直线相交后就没有作用了。
 
  - 所以这里的 chkmin 实际上仅是【当前直线】与【$a_i$ 初值】chkmin。

- 这段后缀可以通过单调栈维护：

  - 具体的，单调栈存凸包上每一段，从栈顶开始，依次判断是当前直线与之的交点是否在栈顶的线段上。
 
  - 然后弹栈即可。
 
所以现在的问题是什么时刻，$a_i$ 的值就是初值：

- 显然这是一段前缀区间。

- 由于我们求出了每条直线所真正影响的后缀。

- 所以对于每一个 $i$，我们可以求出只有一些直线可能影响到它：

  - 这些直线分别影响 $i$ 的一个连续时间段，后面的会覆盖前面的权值。
 
- 于是我们考虑二分出时间轴上哪个时刻开始 $a_i$ 不再是 $a_i$ 的初值，而是由直线提供的。
 
  - 相当于找到最小的 $j$（相当于时间最靠前的），满足 $-cnt_j\cdot i+v_j<a_i $。
 
  - 而 $[1, j) $ 的时间中，就是初值；剩下的就是凸包上的值了。
 
现在问题转化为对于每个 $i$ 求出这些直线：

- 每条线段有一个权值 $pos_j $ 表示直线 j 只会影响到 $[pos_j, n] $ 的 a。

-  对于 $i$ 有用的直线只有 $pos_j\le i $ 的直线。

-  所以这个排个序，搞个双指针很容易求出。

-  容易发现，由于只统计对 $i$ 有用的直线，所以它们之间相对顺序不变，写个平衡树上二分即可。

所以我们现在对于每个 $i$，搞清楚了它在什么时间段用初值，什么时候用凸包上的值，考虑求解答案：

- 整体以时间扫描线。

- 至于 $a_i$ 为初值的情况，

  - 随着时间的推移，每次删掉一些点。
 
  - 剩下的点可以用树状数组单独维护。
 
- 随着时间的推移，会不断的加入一些直线和一些点，会对一个后缀区间 cover 一个一次函数。

  - 注意有些点还未加入，则这个点的贡献应该是 0。
 
#### Code：

代码比较长，主要是写了个替罪羊树，用 treap 之类的实现的话会短很多。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
using namespace std;

const int Maxn = 2e5+5;
int NOW;

class Line {
public:
	ll k, b; int time;
	// static int x;
	inline bool operator < (const Line &b) const {
		return this->k*NOW + this->b < b.k*NOW + b.b;
		// return this->k*x + this->b < b.k*x + b.b;
	}
	inline ll val(ll pos) { return k*pos+b; }
} line[Maxn];

template <typename Value> class ScapegoatTree {
private:
	const double alpha = 0.8;
	int limit, rt, num, tot_val, trash[Maxn], top; Value tmp_val[Maxn];
	struct SGT {
		int son[2], fa, size, sdel, tim, mn; Value val;
		#define lson(t)	tree[t].son[0]
		#define rson(t)	tree[t].son[1]
		#define fa(t)	tree[t].fa
		#define son(t, chk)	tree[t].son[chk]
	} tree[Maxn];
	inline int new_node(Value val, int fa) {
//		int t = ++num;
		int t = (top ?trash[top--] :++num);
		tree[t].val = val, tree[t].size = 1, tree[t].mn = tree[t].tim = val.time;
		lson(t) = rson(t) = 0, fa(t) = fa;
		return t;
	}
	inline void pushup(int t) {
		tree[t].size = tree[lson(t)].size + tree[rson(t)].size + 1;
		tree[t].mn = min(tree[t].tim, min(tree[lson(t)].mn, tree[rson(t)].mn));
	}
	inline bool isbad(int t) {
		if(max(tree[lson(t)].size, tree[rson(t)].size) > alpha*tree[t].size)	return 1;
		else	return 0;
	}
	inline void dfs(int t) {
		if(!t)	return ;
		dfs(lson(t));
		tmp_val[++tot_val] = tree[t].val;
		dfs(rson(t));
		trash[++top] = t;
	}
	inline void Build(int &t, int l, int r, int fa) {
		if(l > r)	return t = 0, void();
		int mid = (l+r)>>1;
		// while(mid<r && tmp_val[mid].k==tmp_val[mid+1] )	mid++;
		t = new_node(tmp_val[mid], fa);
		Build(lson(t), l, mid-1, t);
		Build(rson(t), mid+1, r, t);
		pushup(t);
	}
 	inline void rebuild(int fa, int &t) {
		tot_val = 0, dfs(t);
		bool chk = tree[fa].val<tree[t].val;
		Build(t, 1, tot_val, fa);
		son(fa, chk) = t;
	}
public:
	inline void init(int n) {
		limit = n;
	}
	inline void insert(Value k) {
		if(!rt)	return rt = new_node(k, 0), void();
		int t = rt;
		while(son(t, tree[t].val<k))	tree[t].size++, tree[t].mn = min(tree[t].mn, k.time), t = son(t, tree[t].val<k);	// maxx(lson(t)) <= tree[t].val < minn(rson(t))
		tree[t].size++, tree[t].mn = min(tree[t].mn, k.time), son(t, tree[t].val<k) = new_node(k, t);
		t = rt;
		while(!isbad(t) && t)	t = son(t, tree[t].val<k);
		if(t)	rebuild(fa(t), t);
		if(!fa(t) && t)	rt = t;
		tree[0].size = lson(0) = rson(0) = fa(0) = 0, tree[0].val = {0, 0, 0}, tree[0].mn = tree[0].tim = limit+1;
	}
	inline int Query(int a) {
		if(!rt)	return limit+1;
		tree[0].mn = tree[0].tim = limit+1;
		// printf("Query(%lld)\n", a);
		Line k = {0, a, 0}; int t = rt, tim = limit+1;
		while(t) {
			// printf("t:%lld, tim:%lld, res:%lld, val:{%lld, %lld, %lld} = %lld, ls:%lld, rs:%lld\n", t, tree[t].tim, tim, tree[t].val.k, tree[t].val.b, tree[t].val.time, tree[t].val.val(NOW), lson(t), rson(t));
			if(k < tree[t].val)	t = tree[t].son[0];
			else {
				// printf("tim = min(%lld, tree[%lld]:%lld, %lld)\n", tim, tree[t].son[0], tree[tree[t].son[0]].tim, tree[t].tim);
				tim = min(tim, min(tree[tree[t].son[0]].mn, tree[t].tim));
				t = tree[t].son[1];
			}
		}
		return tim;
	}
	#undef lson
	#undef rson
	#undef fa
	#undef son
}; 

class BinaryIndexedTree {
private:
	int limit; ll tree[Maxn];
	inline int lowbit(int &t) { return t&(-t); }
public:
	inline void init(int n, ll *a) {
		limit = n;
		for(int i=1; i<=limit; i++) {
			tree[i] += a[i];
			if(i+lowbit(i) <= limit)	tree[i+lowbit(i)] += tree[i];
		}
	}
	inline void Add(int t, ll k) {
		for(; t<=limit; t+=lowbit(t))	tree[t] += k;
	}
	inline ll Ask(int l, int r) {
		ll res = 0; l--;
		for(; r; r-=lowbit(r))	res += tree[r];
		for(; l; l-=lowbit(l))	res -= tree[l];
		return res;
	}
} bit;

class SegmentTree {
private:
	int limit;
	struct Segment { int tag, lid, sz; ll sumx, res; } seg[Maxn<<2];
	inline void cover(int t, int lid) {
		seg[t].tag = seg[t].lid = lid;
		seg[t].res = seg[t].sumx*line[lid].k + seg[t].sz*line[lid].b;
	}
	inline void pushdown(int t) {
		if(seg[t].tag != -1) {
			cover(t<<1, seg[t].tag), cover(t<<1|1, seg[t].tag);
			seg[t].tag = -1;
		}
	}
	inline void pushup(int t) {
		seg[t].sumx = seg[t<<1].sumx + seg[t<<1|1].sumx;
		seg[t].sz = seg[t<<1].sz + seg[t<<1|1].sz;
		seg[t].res = seg[t<<1].res + seg[t<<1|1].res;
	}
	inline void Build(int t, int l, int r) {
		seg[t].tag = -1;
		if(l == r)	return ;
		int mid = (l+r)>>1;
		Build(t<<1, l, mid), Build(t<<1|1, mid+1, r);
	}
	inline void insert(int t, int l, int r, int pos) {
		if(l == r) {
			seg[t].sumx = l, seg[t].sz = 1;
			return seg[t].res = line[seg[t].lid].val(pos), void();
		}
		int mid = (l+r)>>1; pushdown(t);
		if(pos <= mid)	insert(t<<1, l, mid, pos);
		else	insert(t<<1|1, mid+1, r, pos);
		pushup(t);
	}
	inline void Cover(int t, int l, int r, int L, int R, int lid) {
		if(L<=l and r<=R)	return cover(t, lid);
		int mid = (l+r)>>1; pushdown(t);
		if(L <= mid)	Cover(t<<1, l, mid, L, R, lid);
		if(R > mid)	Cover(t<<1|1, mid+1, r, L, R, lid);
		pushup(t);	
	}
	inline ll Query(int t, int l, int r, int L, int R) {
		if(r<L || R<l)	return 0;
		if(L<=l and r<=R)	return seg[t].res;
		int mid = (l+r)>>1; pushdown(t);
		return Query(t<<1, l, mid, L, R) + Query(t<<1|1, mid+1, r, L, R);
	}
public:
	inline void init(int n) {
		limit = n, Build(1, 1, limit);
	}
	inline void insert(int pos) {
		insert(1, 1, limit, pos);
	}
	inline void Cover(int l, int r, int lid) {
		if(l <= r)	Cover(1, 1, limit, l, r, lid);
	} 
	inline ll Query(int l, int r) {
		return Query(1, 1, limit, l, r);
	}
} seg;

namespace Josh_zmf {
	
	int N, Q, tot, top, stk[Maxn], cnt[Maxn], pos[Maxn]; ll a[Maxn];
	struct Que { int opt, l, r, lid; ll v; } que[Maxn];
	std::vector<int> influence[Maxn], have[Maxn];
	ScapegoatTree <Line> s;

	inline int cross(int l1, int l2) { // 找到 l1, l2 的交点
		if(line[l1].k == line[l2].k)	return (line[l2].b>line[l1].b ?N+1 :1);
		ll x = ceil((1.*line[l2].b-line[l1].b)/(line[l1].k-line[l2].k));
		return max(min((int)x, N+1), 1ll);
	}

	inline int main() {
		cin>> N>> Q;
		for(int i=1; i<=N; i++)	cin>> a[i];
		for(int i=1; i<=Q; i++) {
			cin>> que[i].opt, cnt[i] = cnt[i-1];
			if(que[i].opt == 1) {
				cin>> que[i].v;
				line[++tot] = {-cnt[i], que[i].v, i}, que[i].lid = tot;
				for(; top and cross(stk[top], tot)<=pos[stk[top]]; top--);
				pos[tot] = (top ?cross(stk[top], tot) :1), stk[++top] = tot;
				influence[pos[tot]].push_back(tot);
				// printf("tot:%lld, stk[top:%lld]:%lld, line:{%lld, %lld, time:%lld}, pos:%lld\n", tot, top, stk[top], line[tot].k, line[tot].b, line[tot].time, pos[tot]);
			} else if(que[i].opt == 2) {
				cnt[i]++;
			} else {
				cin>> que[i].l>> que[i].r;
			}
		}
		s.init(Q);
		for(int i=1; i<=N; i++) {
			NOW = i; 
			for(int j: influence[i])	s.insert(line[j]);//, printf("s.insert(line[%lld])\n", j);
			int t = s.Query(a[i]);
			// printf("t[%lld]:%lld\n", i, t);
			have[t].push_back(i); // 从 t 开始，a_i 不用初值
		}
		seg.init(N), bit.init(N, a);
		for(int i=1; i<=Q; i++) {
			for(int j: have[i])	bit.Add(j, -a[j]), seg.insert(j);
			if(que[i].opt == 1)	seg.Cover(pos[que[i].lid], N, que[i].lid);
			else if(que[i].opt == 3) {
				int l = que[i].l, r = que[i].r;
				ll ans = 1ll*cnt[i]*(l+r)*(r-l+1)/2;
				ans += bit.Ask(l, r) + seg.Query(l, r);
				cout<< ans<< '\n';
			}
		}
		return 0;
	}

}

signed main() {
	// freopen("ezds.in", "r", stdin);
	// freopen("ezds.out", "w", stdout);
	Josh_zmf::main();
	return 0;
}
/*
7 5
6 6 5 10 10 6 1
1 10
2
1 3
2
3 4 6

*/
```

#### 结语：

都看到这里了，点个赞再走吧！

---

## 作者：Mirasycle (赞：1)

两种思考方式，第一种是 xtq 上课的时候提出。

如果询问是在最后的话，可以考虑把所有 $\min$ 操作移到最后。

考虑先 $\min v$ 再 $+i$，调换一下顺序就是先 $+i$，再取 $\min (v+i)$，最后就是若干个 $\min (v+k\times i)$。最终 $a_i=\min(a_i+k\times i,\min\limits_j v_j+t_j\times i)$。其中 $t_j$ 表示 $j$ 操作之后到末尾还有几次全局 $+i$ 的操作。

考虑处理第二个 $\min$，这是 $a_i$ 的理论上界。这是一个在 $t_j-v_j$ 的坐标系中的一个下凸壳用斜率为 $-i$ 的直线来截取，可以发现随着 $i$ 增大，$\min v_j+t_j\times i$ 也是增大的，所以对于 $i$ 更大的数的上界也是更大的，因此对于 $a_i+k\times i$ 能达到上界的位置中数值是随着 $i$ 单调递增的。可以发现这个结论对于任意时刻都满足。

于是考虑分成能某个时刻某个数否达到上界来考虑，对于当前时刻无法达到上界的位置直接线段树维护，对于当前时刻已经达到上界的数满足单调递增很容易，故可以用线段树二分完成 chkmin。于是对于每个数找到第一次达到界的 $j$，此后这些数一直满足单调递增。因为一直符合性质，所以可以持续维护。

如何找到每个数第一次达到界的时刻呢，这个时刻是满足 $a_i+k\times i\ge v_j$ 的，注意这里的 $t_j=0$，因为我们以该时刻为截止时刻来考虑。移项之后就是 $a_i\ge v_j-k\times i$，可以用整体二分配合李超线段树解决。时间复杂度 $O(n\log^2 n)$。

但我更倾向于题解区结合我个人想法的第二种思考方式，这个 chkmin 和 $+i$ 都启发我们维护一个单调不降的序列。如果有这么一个序列经过 $+i$ 之后还是单调的，chkmin 就是线段树二分之后直接打标记即可。

可以发现每次被 chkmin 影响的点此后都是单调递增的，因为这次 chkmin 抹平了他们之间的差距。此后 $+i$ 后可以维持单调关系。

更进一步观察就是一些点如果先后被 chkmin，他们仍然保持单调关系。也就是说凡是被 chkmin 影响了至少一次的点都具有单调关系。考虑第一次被 chkmin 影响的点 $i,k$ 和第二次被 chkmin 的点 $j$，满足 $i<j<k$。第一次被 chkmin 之后肯定是 $a_i=a_k>a_j$，如果最后一个不等号反向那么 $a_j$ 也会被这次操作影响，矛盾，故式子成立。经历若干次 $+i$ 操作之后是 $a_i~?~a_j< a_k$，假设此时 $j$ 也被 chkmin 影响了，那么首先 $a_j=a_k$。当 $?$ 是 $>$ 的时候，$a_i=a_j=a_k$，当 $?$ 是小于的时候 $a_i\le a_j\le a_k$。因此上述结论成立。

所以还是转化为求出每个点第一次被 chkmin 影响，同第一种方法解决即可。

---

## 作者：鲤鱼江 (赞：0)

其实有比较简单的强制在线做法。

先考虑如果 $a_i$ 递增怎么做。

发现题目一下子变得很萌，因为序列始终单调递增，每次操作 $1$ 相当于后缀覆盖，使用线段树上二分可以做到 $O(n\log n)$。

发现这个方法很有启发性，考虑拓展一下，尽量向这里靠。

发现序列经历若干次操作后会慢慢变得单调起来（这好像是特殊性质 A 的一个做法）。

综上两个想法，我们考虑再维护两个序列。

第一个序列是不单调的序列，对于这个序列，只要有数被操作 $1$ 推平，就加入第二个序列。

我们容易证明第二个序列是始终单调的。

然后对于第二个序列使用数列单调的做法。

问题来到了如何知道每个点什么时候被加入第二个序列。

不难发现每个数最多加入一次，所以我们可以求出最大值的位置，然后暴力修改和加入，此时问题相当于快速求最大值，离线做法有整体二分等，当然也可以采用分块维护凸壳。

具体来讲，我们把每个数当作一条直线，第 $i$ 个数为 $i\times cnt +a_i$，其中 $cnt$ 是二操作的次数。

有一个很友好的性质是 $i$，也就是斜率，是天生单调递增的，这让我们的分块可以省去排序之类的操作。

维护凸壳是容易的，使用栈来模拟。若栈的大小不足 $2$，就直接加入该线段，否则弹出栈顶不合法的元素，弹到合法为止。

判断是否合法可以用使用求交点来实现，可能会好写一些。一共重构 $O(n)$ 次，每次重构大小为 $O(\sqrt n)$ 的块，总时间 $O(n\sqrt n)$，接下来对着代码解析。

本题还是比较好写，只是要维护的东西不少，有些唬人罢了。

```cpp
#include<bits/stdc++.h>
#define mid ((l+r)>>1)
#define int long long
#define rs now<<1|1
#define ls now<<1
#define endl '\n'

using namespace std;

const int N=2e5+10;
int n,a[N],cnt,q;

namespace Fread {
	const int SIZE=1<<21;char buf[SIZE],*S,*T;
	inline char getchar() {if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return '\n';}return *S++;}
}
namespace Fwrite {
	const int SIZE=1<<21;
	char buf[SIZE],*S=buf,*T=buf+SIZE;
	inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}
	inline void putchar(char c){*S++=c;if(S==T)flush();}
	struct POPOSSIBLE{~POPOSSIBLE(){flush();}}ztr;
}
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio{
	struct Reader{
	    template<typename T>
    	Reader& operator >> (T& x) {
        	char c=getchar();T f=1;
        	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}x=0;
        	while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}x*=f;
	        return *this;
    	}
	    Reader(){}
	}cin;
	struct Writer{
	    template<typename T>
	    Writer& operator << (T x) {
	        if(x==0){putchar('0');return *this;}
	        if(x<0){putchar('-');x=-x;}
	        static int sta[45];int top=0;
	        while(x){sta[++top]=x%10;x/=10;}
	        while(top){putchar(sta[top]+'0');--top;}
	        return *this;
    	}
    	Writer& operator << (char c) {putchar(c);return *this;}
    	Writer(){}
	}cout;
}
#define cin Fastio :: cin
#define cout Fastio :: cout

struct TreeArray{
	int tr[N];
	inline int lowbit(const int &x){return x&(-x);}
	inline void add(int i,int x){for(;i<=n;i+=lowbit(i)) tr[i]+=x;}
	inline int ask(int pos){int res=0;for(;pos;pos-=lowbit(pos)) res+=tr[pos];return res;}
	inline int ask(int l,int r){return ask(r)-ask(l-1);}
}s1,s2;

struct Segment{
	int maxx[N<<2],w[N<<2],sum[N<<2],cov[N<<2],tag[N<<2],len[N<<2],rpos[N<<2];
	inline void pushup(int now){sum[now]=sum[ls]+sum[rs];maxx[now]=max(maxx[ls],maxx[rs]);}
	inline void cover(int now,int v){sum[now]=len[now]*v;cov[now]=maxx[now]=v;tag[now]=0;}
	inline void add(int now,int v){sum[now]+=w[now]*v;tag[now]+=v;maxx[now]+=rpos[now]*v;}
	inline void pushdown(int now){
		if(~cov[now]){cover(ls,cov[now]);cover(rs,cov[now]);cov[now]=-1;}
		if(tag[now]){add(ls,tag[now]);add(rs,tag[now]);tag[now]=0;}
	}
	void build(int now,int l,int r){
		cov[now]=-1;if(l==r) return ;
		build(ls,l,mid);build(rs,mid+1,r);
	}
	void Search(int now,int l,int r,int v){
		if(maxx[now]<v) return ;
		if(l==r) return cover(now,v);
		pushdown(now);
		if(maxx[ls]>v){cover(rs,v);Search(ls,l,mid,v);}
		else Search(rs,mid+1,r,v);
		pushup(now);
	}
	void upd(int now,int l,int r,int to,int v){
		w[now]+=to;++len[now];rpos[now]=max(rpos[now],to);if(l==r){maxx[now]=sum[now]=v;return ;}
		pushdown(now);(mid>=to)?upd(ls,l,mid,to,v):upd(rs,mid+1,r,to,v);pushup(now);
	}
	int ask(int now,int l,int r,int x,int y){
		if(x>y||x>r||y<l) return 0;
		if(x<=l&&r<=y) return sum[now];
		pushdown(now);return ask(ls,l,mid,x,y)+ask(rs,mid+1,r,x,y);
	}
}t;

struct blocks{
	struct block{
		int l,r,top,ptr;
		int val[510];
		#define lpos(k) blk[k].l
		#define rpos(k) blk[k].r
		#define top(k) blk[k].top
		#define ptr(k) blk[k].ptr
		#define val(k,i) blk[k].val[i]
	}blk[500];
	int pos[N],lenth,tot,flag[N];
	inline int Point(int x,int y){return (a[x]==a[y])?0:(a[x]-a[y]-1)/(y-x)+1;}//求交点 
	inline void pushup(int id){//弹栈 
		top(id)=0;int tmp=0;
		for(int i=lpos(id);i<=rpos(id);++i){
			if(flag[i]) continue;
			while(tmp>1&&(Point(val(id,tmp),i)<Point(val(id,tmp-1),i))) --tmp;//重构 
			val(id,++tmp)=i;
		}
		top(id)=tmp;ptr(id)=1;
	}
	inline void init(){
		lenth=sqrt(n)*0.9;
		for(int i=1;i<=n;++i){
			pos[i]=(i-1)/lenth+1;
			if(!lpos(pos[i])){
				lpos(pos[i])=i;
				rpos(pos[i]-1)=i-1;
			}
		}
		rpos(tot=(n-1)/lenth+1)=n;
		for(int i=1;i<=tot;++i) pushup(i);
	}
	inline int Ask(int x){
		if(!top(x)) return 0;
		int p=ptr(x);while(p<top(x)&&Point(val(x,p),val(x,p+1))<=cnt) ++p;
		ptr(x)=p;return val(x,p);//求出在哪一条直线取到最值。 
	}
	inline int p(int x){return x*cnt+a[x];}
	inline void upd(int v){
		for(int i=1;i<=tot;++i){
			int pos=Ask(i);
			while(p(pos)>v){
				flag[pos]=1;pushup(i);
				s1.add(pos,-pos);t.upd(1,1,n,pos,v);
				s2.add(pos,-a[pos]);pos=Ask(i);//判断 
			}
		}
	}
}b;

bool ed;
signed main(){
	cin>>n>>q;
	for(int i=1;i<=n;++i) cin>>a[i];
	b.init();t.build(1,1,n);
	for(int i=1;i<=n;++i){s1.add(i,i);s2.add(i,a[i]);}
	for(int i=1,op,l,r,v;i<=q;++i){
		cin>>op;
		if(op==1){cin>>v;b.upd(v);t.Search(1,1,n,v);}
		else if(op==2){++cnt;t.add(1,1);}
		else {cin>>l>>r;cout<<s2.ask(l,r)+s1.ask(l,r)*cnt+t.ask(1,1,n,l,r)<<endl;}
	}
	return 0;
} 
```

---


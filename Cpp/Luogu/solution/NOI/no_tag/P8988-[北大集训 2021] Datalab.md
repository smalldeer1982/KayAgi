# [北大集训 2021] Datalab

## 题目背景

CTT2021 D2T2

**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `datalab.h`，而需要把 `datalab.h` 中的内容加入文件的开头。即，在程序中 `solve` 函数的前面加入以下几行语句：**

```cpp
#include<bitset>
#include<vector>
typedef std::bitset<8192> Bitset;
Bitset Add(Bitset A,Bitset B);
std::vector<int> solve(int k,int LIMIT);
```

## 题目描述

**这是一道交互题。**

在 AutoLab 平台上有一台奇怪的 $k$ 位计算机，其中 $k$ 是一个固定的常数 $8192 = 2^{13}$。这台计算机的字长恰好为 $\frac{k}{8} = 1024 = 2^{10}$，且其存储整数的方式如下：

每个整数会存储在连续的 $k$ 个 bit 中。假设将这 $k$ 个连续 bit 的值按照下标从小到大顺次排列后得到的长度为 $k$ 的 01 字符串为 $S$。假设 $S$ 的下标从 $0$ 开始，则这个字符串 $S$ 对应的整数值为 $f(S) = \sum \limits_{i=0}^{k-1} [S_i=1] sgn_i 2^i$，其中 $sgn$ 是一个小 W 预先定义的长度为 $k$ 的数组，其下标从 $0$ 开始且 $\forall 0 \le i < k,sgn_i \in \{-1,1\}$。出于某些特殊的原因，这台计算机上保证了 $sgn_{k-1} = 1$，$sgn_{k-2} = -1$。而你不知道 $sgn_0,sgn_1,\cdots,sgn_{k-3}$ 的值。

假设 $L = \sum \limits_{i=0}^{k-1} \min\{0,sgn_i\} 2^i$，$R = \sum \limits_{i=0}^{k-1} \max\{0,sgn_i\} 2^i$，则发现 $\forall L \le x \le R$，恰好有一个长度为 $k$ 的 01 字符串 $f(T)$，使得 $f(T) = x$（证明略去）。不妨设所有 $[L,R]$ 内的整数构成的集合为 $S$，则 $f$ 是一个从 $\{0,1\}^n$ 到 $S$ 的双射。据此我们可以设 $f(x)$ 的反函数 $g(x)$ 存在，且其满足 $\forall x \in S,f(g(x)) = x$。

假设存在 $x,y \in S$ ，则在该计算机上两个整数之间的加法 $\oplus$ 被定义为 $x \oplus y \overset{def}{=} (x + y - L + 2^k) \bmod 2^k + L$。不难发现 $\forall x,y \in S,x \oplus y \in S$。因而在这台计算机上加法满足封闭性。同时按照如上规则定义的加法也满足交换律，结合律等性质。这些性质的证明也同样略去。

学生可以通过有限次的询问获得和 $sgn_i$ 相关的信息。每次询问你可以给计算机两个长度为 $k$ 的仅包含 $0,1$ 的字符串 $x,y$，而计算机会返回 $g(f(x) \oplus f(y))$ 的值。本次的作业要求是在不超过 $m$ 次的询问中求出 $sgn_0,sgn_1,\cdots,sgn_{k-3}$ 的准确值。

小 Z 是一名聪明绝顶的学生，因而他尝试使用他的 $10^3 \mathrm{Hz}$ 的超强大脑来手算出每次交互的值。但是他发现给他的处理速度还是跟不上庞大的数据规模。因而它请你帮忙写一个程序，帮助他更快速的完成本次的作业。

---

### 任务

你不需要，也不应该实现主函数，你只需要实现如下一个函数：

1. `std::vector<int> solve(int k,int m)`：

	- 传入数字的是计算机的字长 $k$ 和询问次数限制 $\mathrm{m}$。
	- 你需要返回一个大小为 $k$ 的 `vector`，其第 $i$ 个元素代表你确定的 $sgn_i$ 的值。

你可以通过如下函数调用 Autolab 上的加法操作。

1. `std::bitset<8192> Add(std::bitset<8192> x,std::bitset<8192> y)`：
	- 给定两个大小为 $k$ 的 bitset, 每个 bitset 自低位向高位阅读的结果代表了一个长度为 $k$ 的仅包含 01 的字符串。
	- 返回一个大小为 $k$ 的 bitset, 表示 $g(f(x) \oplus f(y))$ 的值。返回的格式和输入的格式相同。

根据题目要求，你至多只能询问 $\mathrm{m}$ 次两个整数在这台计算机上的加法结果。也就是说你至多只能调用 $\mathrm{m}$ 次 `Add` 函数。

评测时，交互库会**恰好**调用 `solve` 一次。

**本题保证所使用的数组 `sgn` 在开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。**

**数据保证在调用次数限制下，交互库运行所需的时间不超过 1s；交互库使用的内存大小固定，且不超过 128MB。**

---

### 如何测试你的程序

**试题目录下的 `grader.cpp` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。**

1. 你需要在本题目录下使用如下命令编译得到可执行程序：
   - `g++ grader.cpp sample.cpp -o sample -O2 -lm`

2. 对于编译得到的可执行程序：
   - 可执行文件将从**标准输入**读入以下格式的数据：
     - 第一行包含两个整数 $k,\mathrm{m}$。
     - 接下来一行 $k$ 个整数，第 $i$ 个数字表示 $sgn_i$。
   - 读入完成之后，交互库将调用恰好一次函数 $\texttt{solve}$ 你的函数正确返回后，交互库会判断你的计算是否正确，若正确则会输出 `Correct` 和交互函数调用次数相关信息，否则会输出相应的错误信息。

试题目录下有出题人提供的一份参考代码 `sample.cpp`，注意这份代码 **不保证可以通过所有的测试用例**。

---

### 样例一、二

见附件下载。

这两个样例满足可执行程序的输入格式，因而可以直接输入到可执行程序中。

## 说明/提示

### 评分方式

| subtask | $k$ | $m$ |
| :----------: | :----------: | :----------: |
| 1 | $=8192=2^{13}$ | $=8200$ |
| 2 | $=8192=2^{13}$ | $=5550$ |
| 3 | $=8192=2^{13}$ | $=4096=2^{12}$ |

对于任意一个子任务中的数据，如果在某一个数据上选手返回了错误的答案，或者是超出了询问次数限制，得分为 $0$。

否则假设在子任务内所有测试点中，询问次数的最大值为 $a$，则对于每个子任务，选手得分为：

- Subtask $1$: $10$
- Subtask $2$: $15$
- Subtask $3$: $\min \{75,\lfloor \frac{13800}{\max\{a,1\}} \rfloor \}$

换而言之，当且仅当 $a \le 184$ 的时候，Subtask $3$ 可以获得满分。

选手在本题为本题三个子任务的得分之和。

# 题解

## 作者：vzcx_host (赞：6)

在本题解中，约定 $k=2^{13}=8192$，所有数组下标均从 $0$ 开始编号。

## 题意简述与分析
现有一个长度为 $k$ 的数组 $sgn$，满足 $sgn_i\in\{1,-1\}$，且已知 $sgn_{k-1}=1,sgn_{k-2}=-1$。

对于一个长度为 $k$ 的 01 串 $S$，定义 $f(S)=\sum_{0\le i<k}[S_i=1]sgn_i 2^i$，$g(x)$ 为 $f(x)$ 的反函数。

二进制加法的法则是“逢 $2$ 进 $1$”，由定义可知，对于任意两个长度为 $k$ 的 01 串 $S,T$，$g(f(S)+f(T))$ 的值就是对 $S$ 和 $T$ 做“逢 $2$ 进 $1$ 或 $-1$”的“二进制加法”后得出的结果，也可以发现，题目中的加法运算与这里的加法完全一致。（讲的不够清楚，但这一段非常重要）

同样，由于加法运算的存在，证明了 $f(x)$ 存在反函数 $g(x)$。

现每次询问要求给出两个长度为 $k$ 的 01 串 $S,T$，交互库会返回 $g(f(S)+f(T))$，用尽量少的询问套出 $sgn$ 数组。

题目补充：三个 Subtask 的 $LIMIT$ 分别为 $8200,5550,4096$。

## Solution
定义 $R=g(f(S)+f(T))$。

若 $f(S)+f(T)$ 的第 $i$ 位发生进位，且之后的所有位均为 $0$，则 $R$ 的第 $i$ 位后会出现一段连续的 $1$，其中最高位的 $1$ 所在位与第 $i$ 位同号，中间的 $1$ 所在位与第 $i$ 位异号。

对每一位分开询问即可，最大询问次数为 $8190$，可得 $10$ 分。

---

在上一个做法中，我们让每次询问恰好发生一次进位，这样会大幅度浪费询问次数，考虑多进程询问。

考虑分块，一次进位要么只会影响该位所在的块内的部分，要么会发生“跨块”。如果某一个块发生“跨块”，那么这个块内的所有位会被全部做完，所以“跨块”最多会发生 $\sqrt{k}$ 次，当跨块发生时停止处理后面的块即可。

询问上限 $2\sqrt{k}\le 182$，可以通过本题。

~~以上为标算的做法，接下来，我们要开启快乐的踩标之旅！~~

---

反过来考虑，如果我们令 $S=11111111\dots 1111,T=00000000\dots 0001$，得到的 $R$ 必然为一段 $1$ 后跟一段 $0$，其中最高位的 $0$ 与最低位异号，其余的 $0$ 与最低位同号。我们还可以发现，更高位的 $1$ 还可以供我们多线程询问。

因此，对于当前要解决的区间 $(l\sim r,d)$，其中 $r+1\sim d-1$ 与 $r$ 同号，$d$ 与 $r$ 异号，我们可以对 $mid$ 做一次单点询问，对得到的最高位的 $0$ 所在位 $p$ 再做一次单点询问，设第二次询问得到的最高位的 $0$ 在第 $q$ 位，我们可以确定 $mid\sim p-1$ 与 $mid$ 同号，$p\sim q-1$ 与 $mid$ 异号，$q$ 与 $mid$ 同号。同时，原区间被分为了两个区间 $(l\sim mid,p)$ 和 $(q\sim r,d)$，子区间依然满足原区间的性质，由于中间的异号位充足，两个子区间不会对对方产生影响，多个不交的区间同时进行即可。

询问上限 $2\log_2 k = 26$，完成一般踩标。

---

我们想想当询问利用率达到极限会发生什么。

令 $S=T=11111111\dots 1111$，对于 $R$ 某一位，若该位与下一位同号，则下一位会进 $1$，下一位会正常进位；若该位与下一位异号，则下一位会退 $1$，下一位不会进位，带来的影响就是再下一位必定为 $0$。

因此，若 $R$ 的第 $i$ 位为 $0$，则它的上一位和上上位异号，它和上一位的关系不知道，对不知道的关系做一次统一询问即可。由于两个询问位之间必定有一组异号关系，按最原始的方法询问不会出现互相影响的问题。

询问上限 $2\times 1 = 2$，完成爆踩标算。

---


# [北大集训 2021] 小明的树

## 题目背景

CTT2021 D3T1

## 题目描述

小明有一棵以 $1$ 为根的 $n$ 个节点的树，树上每一个非根节点上有一盏灯，他有一个 $2 \thicksim n$ 的排列 $a_1,a_2,\dots,a_{n-1}$。他还有一个计数器，初始为 $0$。

他会按照排列依次点亮这 $n-1$ 盏灯，每进行一次点灯操作后，他会检查整个树是否是美丽的，如果是美丽的，计数器会加上此时点灯的节点形成的连通块的个数。

$n-1$ 次点灯后计数器的值，记为这棵树的答案。
				

一个树是美丽的当前仅当对于每一个被点亮的节点，这个节点子树内的节点都是点亮的。

小明认为这个问题太简单了，他觉得应该让树动起来。

在初始查询后，他会删掉树中一条边并加上一条边，保证修改后还是一棵树，他想知道每一次修改后将计数器清零后重新点灯并计数，这棵树的答案是多少。

## 说明/提示

- 子任务 $1$（$10$ 分）：保证满足 $2 \leq n \leq 500000$，$m = 0$。

- 子任务 $2$（$20$ 分）：保证满足 $2 \leq n \leq 8000$，$0 \leq m \leq 8000$。

- 子任务 $3$（$70$ 分）：保证满足 $2 \leq n \leq 500000$，$0\leq m \leq 500000$。



## 样例 #1

### 输入

```
10 10
2 1
3 1
4 2
5 1
6 4
7 6
8 5
9 4
10 1
6 4 2 7 8 9 10 3 5
6 7 10 7
1 5 8 9
1 2 10 8
10 8 7 6
2 4 2 9
8 9 1 5
5 8 8 2
2 9 10 8
10 7 4 10
10 8 8 9
```

### 输出

```
13
15
4
6
2
2
10
7
8
8
7
```

## 样例 #2

### 输入

```
10 10
2 1
3 2
4 3
5 4
6 2
7 5
8 7
9 1
10 8
6 8 3 9 2 5 7 10 4 
1 9 3 9
4 5 2 7
2 7 6 7
8 10 10 1
6 7 8 1
3 9 9 8
1 2 7 3
2 3 2 9
8 1 1 7
2 9 2 8
```

### 输出

```
3
2
2
1
2
4
4
3
3
3
3
```

# 题解

## 作者：Alex_Wei (赞：19)

#### D3T1. [P8990 [北大集训 2021] 小明的树](https://www.luogu.com.cn/problem/P8990)

从白点限制入手不好描述一棵树是否美丽，因为白点的限制是子树限制，而操作使得子树关系难以维护。为此，我们希望从边的角度描述限制，且每条边的贡献独立，这样，支持题述操作就容易了。

换种角度，考虑黑点限制，发现一棵树是美丽的，当且仅当每个黑点没有白点祖先，进一步转化就是 **黑点连通**。

设 $c_i$ 表示时刻 $i$ 黑点连通块的数量。连通块数为 $|V| - |E|$，所以 $c_i$ 等于时刻 $i$ 的黑点数量 $n - i$，减去两端都是黑点的边数，初始为 $n - 1$。因此，初始化所有 $c_i$ 为 $1 - i$。对于每条边，设它第一次某端被点亮的时刻为 $t$，则 $c_t\sim c_{n - 1}$ 加 $1$。很显然，$t = \min(b_u, b_v)$，其中 $b_i$ 表示 $i$ 被点亮的时刻（$b_1 = n$）。

同样的，为方便统计答案，考虑从边的角度入手。想到这一点后，我们很容易发现一棵美丽的树的权值就是两端颜色不同的边的数量，设为 $v_i$，而一条边两端颜色不同的时刻就是 $\min(b_u, b_v)\sim \max(b_u, b_v) - 1$。

因此，答案相当于所有 $c_i = 1$ 的 $v_i$ 之和。操作产生的影响为 $\mathcal{O}(1)$ 次区间 $c, v$ 修改，又因为 $c_i\geq 1$，所以线段树维护区间最小值，最小值数量以及对应权值之和即可。

时间复杂度 $\mathcal{O}((n + q)\log n)$。[代码](https://uoj.ac/submission/605417)。

---

## 作者：Cocoly1990 (赞：8)

考虑对边分类，记两个端点都未点亮的边为黑边，一个端点点亮一个端点为点亮的边为黑白边，两个端点都点亮的边为白边。

然后，美丽的定义等价于所有的黑边构成连通块。

考察一个经典结论：连通块个数等于点数减边数。

记当前操作次数为 $i$，黑边个数为 $p$，则树合法当且仅当 $n-i-p=1$。

这时候对计数器的贡献是黑白边的个数。

然后，考虑线段树维护这个东西，对时间轴建立线段树。

考察一条边 $(x,y)$，记 $t_x,t_y$ 分别表示 $x,y$ 被点亮的时间，不妨有 $t_x<t_y$。

- 一开始，对黑边贡献为 $1$。

- 然后，遇到 $t_x$ 时，黑边减一，黑白边加一。
- 遇到 $t_y$ 时，黑白边减一，白边加一。

然后，把黑白边的个数看作权值，把 $n-i-p$ 看作属性，维护最小属性的值，个数和对应的权值和即可。

修改操作的话，沿用上面的思路，对贡献操作就好了。相当于一个区间加的操作。

```c++
#include<bits/stdc++.h>
#define Maxn 500007
using namespace std;
int n, q, p[Maxn], a[Maxn], U[Maxn], V[Maxn];
struct Seg{
	int ls(int x) {return x << 1;} int rs(int x) {return x << 1 | 1;}
	int cnt[Maxn << 2], mn[Maxn << 2], tag[Maxn << 2][2]; long long sum[Maxn << 2]; //0 min 1 bw
	void pushup(int p){
		mn[p] = min(mn[ls(p)], mn[rs(p)]); cnt[p] = sum[p] = 0;
		if(mn[p] == mn[ls(p)]) cnt[p] += cnt[ls(p)], sum[p] += sum[ls(p)];
		if(mn[p] == mn[rs(p)]) cnt[p] += cnt[rs(p)], sum[p] += sum[rs(p)];
	}
	void pushdown(int p){
		if(tag[p][0]) {tag[ls(p)][0] += tag[p][0]; tag[rs(p)][0] += tag[p][0]; mn[ls(p)] += tag[p][0]; mn[rs(p)] += tag[p][0]; tag[p][0] = 0;}
		if(tag[p][1]) {tag[ls(p)][1] += tag[p][1]; tag[rs(p)][1] += tag[p][1]; sum[ls(p)] += 1ll * tag[p][1] * cnt[ls(p)]; sum[rs(p)] += 1ll * tag[p][1] * cnt[rs(p)]; tag[p][1] = 0;}				
	}
	void build(int p, int l, int r){
		cnt[p] = mn[p] = sum[p] = tag[p][0] = tag[p][1] = 0;
		if(l == r) {cnt[p] = 1; mn[p] = n - l + (n == l); return;}
		int mid = (l + r) >> 1; build(ls(p), l, mid); build(rs(p), mid + 1, r); pushup(p); 
	}
	void motify(int p, int l, int r, int ql, int qr, int x, int y){
		if(ql <= l and r <= qr) {tag[p][0] += x; tag[p][1] += y; mn[p] += x; sum[p] += 1ll * cnt[p] * y; return;}
		pushdown(p); int mid = (l + r) >> 1;
		if(ql <= mid) motify(ls(p), l, mid, ql, qr, x, y); 
		if(qr > mid) motify(rs(p), mid + 1, r, ql, qr, x, y); pushup(p);
	}
	void add(int x, int y, int k){
		x = p[x], y = p[y]; if(x > y) swap(x, y);
		if(x >= 2) motify(1, 1, n, 1, x - 1, - k, 0);
		if(y > x) motify(1, 1, n, x, y - 1, 0, k);
	}
}t;
int main(){
	ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n >> q;
	for(int i = 1; i < n; i ++) cin >> U[i] >> V[i];
	for(int i = 1; i < n; i ++) cin >> a[i], p[a[i]] = i; p[a[n] = 1] = n; 
	t.build(1, 1, n); 
	for(int i = 1; i < n; i ++) t.add(U[i], V[i], 1); cout << t.sum[1] << "\n";
	for(int u, v, l, w; q; q --){
		cin >> u >> v >> l >> w;
		t.add(u, v, -1); t.add(l, w, 1);
		cout << t.sum[1] << "\n";
	}
}
```


---
后记：很厉害的题，当年模拟赛出了这题，全网没有题解，我们一车人对着墨染空的做题记录看了 114514 年。


---

## 作者：ducati (赞：5)

## Description

[传送门](https://www.luogu.com.cn/problem/P8990)

## Solution

令 $a_n = 1$，容易发现：

**Observation 1**：点亮 $a_1,a_2,\cdots,a_r$ 后树是美丽的，当且仅当 $a_{r+1},a_{r+2},\cdots,a_n$ 连通。

**Observation 2**：$S$ 的连通块数为 $|S|$ 减去两端均在 $S$ 中的边数 $e(S)$。

令 $f_i = i - e(\{a_1,a_2,\cdots,a_i\})$，$g_i = (n-i) - e(\{a_{i+1},a_{i+2},\cdots,a_n\})$，则答案为 $\sum_{i=1}^{n-1} [g_i = 1]f_i$。

由于 $g$ 的下界是 $1$，问题转化为：动态对 $f,g$ 作区间加减，维护所有 $g_i$ 取到最小值的 $f_i$ 总和。

使用线段树维护即可，时间复杂度 $O(n \log n)$，本题被轻松解决。

## Code

```cpp
#include <bits/stdc++.h>
#define LS (rt<<1)
#define RS (rt<<1|1)
#define ll long long
using namespace std;
const int N=5e5+5,Z=N*4;

namespace IO{
	inline char nc(){
		static char buf[500001],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,500000,stdin),p1==p2)?EOF:*p1++;
	}
	char out[500001],*pout=out,*eout=out+500000;
	template<typename T> inline T read(){
		char ch=nc(); T sum=0; bool f=false;
		for(;ch<'0'||ch>'9';ch=nc()) if(ch=='-') f=1;
		while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();
		return f?-sum:sum;
	}
}
#define read IO::read<int>

int n,m,bel[N],tagf[Z],tagg[Z]; ll sumf[Z];
struct edge{int u,v;}edg[N];
struct info{
	int ming,cnt; ll sum;
	info operator + (const info &A) const{return info{ming,cnt+A.cnt,sum+A.sum};}
}tr[Z];
inline void Apply_f(int rt,int k){tagf[rt]+=k,tr[rt].sum+=(ll)k*tr[rt].cnt;}
inline void Apply_g(int rt,int k){tagg[rt]+=k,tr[rt].ming+=k;}
inline void pushup(int rt){
	if (tr[LS].ming<tr[RS].ming)  tr[rt]=tr[LS];
	else if (tr[RS].ming<tr[LS].ming)  tr[rt]=tr[RS];
	else tr[rt]=tr[LS]+tr[RS];
}
inline void pushdown(int rt){
	if (tagf[rt])  Apply_f(LS,tagf[rt]),Apply_f(RS,tagf[rt]),tagf[rt]=0;
	if (tagg[rt])  Apply_g(LS,tagg[rt]),Apply_g(RS,tagg[rt]),tagg[rt]=0;
}
void build_tree(int l,int r,int rt){
	if (l==r){
		if (l^n)  tr[rt]=info{n-l,1,l};
		else tr[rt].ming=1e9;
		return;
	}
	int mid=(l+r)>>1;
	build_tree(l,mid,LS);
	build_tree(mid+1,r,RS);
	pushup(rt);
}
void addf(int nl,int nr,int l,int r,int rt,int k){
	if (nl<=l&&r<=nr) {Apply_f(rt,k);return;}
	pushdown(rt);

	int mid=(l+r)>>1;
	if (nl<=mid)  addf(nl,nr,l,mid,LS,k);
	if (nr>mid)  addf(nl,nr,mid+1,r,RS,k);
	pushup(rt);
}
void addg(int nl,int nr,int l,int r,int rt,int k){
	if (nl<=l&&r<=nr) {Apply_g(rt,k);return;}
	pushdown(rt);

	int mid=(l+r)>>1;
	if (nl<=mid)  addg(nl,nr,l,mid,LS,k);
	if (nr>mid)  addg(nl,nr,mid+1,r,RS,k);
	pushup(rt);
}
inline void Ins(int u,int v,int op){
	u=bel[u],v=bel[v],addf(max(u,v),n,1,n,1,-op);
	if (min(u,v)^1)  addg(1,min(u,v)-1,1,n,1,-op);
}
int main(){
	n=read(),m=read(),bel[1]=n,build_tree(1,n,1);
	for (int i=1;i<n;i++)  edg[i].u=read(),edg[i].v=read();
	for (int i=1;i<n;i++)  bel[read()]=i;
	for (int i=1;i<n;i++)  Ins(edg[i].u,edg[i].v,1);

	printf("%lld\n",tr[1].sum);
	for (int x,y,t=1;t<=m;t++){
		x=read(),y=read(),Ins(x,y,-1);
		x=read(),y=read(),Ins(x,y,1);
		printf("%lld\n",tr[1].sum);
	}
	return 0;
}
```



---

## 作者：bmatrix (赞：4)

[题面](https://www.luogu.com.cn/problem/P8990)

注意到直接根据题目的条件判断树是否美丽并不容易。考虑未被点亮的点，可以发现一棵树是美丽的当且仅当**未被点亮的点形成一个连通块**。

有一个结论是，对于一个森林，点数减边数等于连通块的个数。$(*)$

因此树是美丽的当且仅当 “未被点亮的节点的个数”减去“两端都未被点亮的边的个数” $=1$。令 $P$ 表示这个值，当且仅当 $P=1$ 时树是美丽的。

同时根据 $*$ 结论，树上被点亮的连通块的个数就是 “被点亮的节点的个数”减去“两端都被点亮的边的个数”。设这个值为 $Q$。

如果我们按顺序执行点亮操作，那么每个时刻的 $P$ 和 $Q$ 会分别形成一个序列。更准确地说，令 $p_i$ 表示点亮完第 $a_i$ 个点后的 $P$ 值，$q_i$ 表示点亮完第 $a_i$ 个点后的 $Q$ 值，我们就得到了 $p$ 和 $q$ 两个序列，答案即为 $\sum\limits_{i=1}^{n-1}q_i\times[p_i=1]$。（$[X]$ 当 $X$ 为真时 $=1$，否则 $=0$）

接下来考虑 link-cut 操作，先考虑断掉一条边 $(u,v)$ 时对 $p$ 和 $q$ 的影响：由于一个节点是否点亮只决定于 $i$，所以边的情况不会影响点的情况。记 $t_i$ 表示点 $i$ 被点亮的时刻，则 $(u,v)$ 脱离“两端都未被点亮”状态的时刻就是 $\min(t_u, t_v)$，在这之前它都对 $p$ 有贡献，因此删去它后会使 $p$ 的 $[1, \min(t_u, t_v) - 1]$ 区间每个数 $+1$。它变成“两端都被点亮”的状态的时刻是 $\max(t_u, t_v)$，在这之后它都对 $q$ 有贡献，因此删去它后会使 $q$ 的 $[\max(t_u, t_v),n-1]$ 区间每个数 $+1$。

同理，如果连上一条边 $(x,y)$，则它会使 $p$ 的 $[1,\min(t_x,t_y)-1]$ 区间 $-1$，$q$ 的 $[\max(t_x,t_y),n-1]$ 区间 $-1$。

于是转化成了一个线段树问题。具体地，对于线段树每个节点 $[l, r]$，维护 $mn=\min\limits_{i=l}^rp_i$，$cnt = \sum\limits_{i=l}^r[p_i=mn]$ 和 $sum = \sum\limits_{i=l}^rq_i\times[p_i=mn]$ 以及加法标记即可。

时间复杂度 $O((n+m)\log n)$。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define rep(i, s, e) for(int i = s, i##E = e; i <= i##E; ++i)
#define per(i, s, e) for(int i = s, i##E = e; i >= i##E; --i)
#define F first
#define S second
#define int ll
#define gmin(x, y) (x = min(x, y))
#define gmax(x, y) (x = max(x, y))
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double f128;
typedef pair<int, int> pii;
constexpr int N = 5e5 + 5;
int n, m, a[N], t[N];
struct edge {
    int u, v;
} e[N];
struct node {
    int mn, sum, cnt, t1, t2;
} nd[N * 4];
#define ls (p << 1)
#define rs (p << 1 | 1)
void upd(int p, int v, int w) {
    nd[p].mn += v;
    nd[p].t1 += v;
    nd[p].sum += nd[p].cnt * w;
    nd[p].t2 += w;
}
void pushdown(int p) {
    if(nd[p].t1 || nd[p].t2) {
        upd(ls, nd[p].t1, nd[p].t2);
        upd(rs, nd[p].t1, nd[p].t2);
        nd[p].t1 = nd[p].t2 = 0;
    }
}
void pushup(int p) {
    if(nd[ls].mn < nd[rs].mn) nd[p].mn = nd[ls].mn, nd[p].sum = nd[ls].sum, nd[p].cnt = nd[ls].cnt;
    else if(nd[ls].mn > nd[rs].mn) nd[p].mn = nd[rs].mn, nd[p].sum = nd[rs].sum, nd[p].cnt = nd[rs].cnt;
    else nd[p].mn = nd[ls].mn, nd[p].sum = nd[ls].sum + nd[rs].sum, nd[p].cnt = nd[ls].cnt + nd[rs].cnt;
}
void build(int p, int l, int r) {
    if(l == r) {
        nd[p].mn = n - l;
        nd[p].sum = l;
        nd[p].cnt = 1;
        return;
    }
    int mid = (l + r) / 2;
    build(ls, l, mid), build(rs, mid + 1, r);
    pushup(p);
}
void add(int p, int l, int r, int ql, int qr, int v, int w) {
    if(l > qr || r < ql) return;
    if(ql <= l && qr >= r) return upd(p, v, w);
    pushdown(p);
    int mid = (l + r) / 2;
    add(ls, l, mid, ql, qr, v, w);
    add(rs, mid + 1, r, ql, qr, v, w);
    pushup(p);
}
signed main() {
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
#endif
    cin >> n >> m;
    build(1, 1, n - 1);
    rep(i, 1, n - 1) cin >> e[i].u >> e[i].v;
    rep(i, 1, n - 1) cin >> a[i], t[a[i]] = i;
    t[1] = n;
    rep(i, 1, n - 1) {
        int u = e[i].u, v = e[i].v;
        add(1, 1, n - 1, 1, min(t[u], t[v]) - 1, -1, 0);
        add(1, 1, n - 1, max(t[u], t[v]), n - 1, 0, -1);
    }
    cout << (nd[1].mn == 1 ? nd[1].sum : 0) << endl;
    while(m--) {
        int u, v, x, y;
        cin >> u >> v >> x >> y;
        add(1, 1, n - 1, 1, min(t[u], t[v]) - 1, 1, 0);
        add(1, 1, n - 1, max(t[u], t[v]), n - 1, 0, 1);
        add(1, 1, n - 1, 1, min(t[x], t[y]) - 1, -1, 0);
        add(1, 1, n - 1, max(t[x], t[y]), n - 1, 0, -1);
        cout << (nd[1].mn == 1 ? nd[1].sum : 0) << endl;
    }
    return 0;
}
```

---

## 作者：lzqy_ (赞：3)

停课时候的遗留题目，回归 whk 后并没有独立做出来。

首先肯定要用另一种方法来刻画一棵树的权值。由于点亮的点是子树限制，且放到时间轴上还是区间操作，难以进行断边的操作，也不好表示每个时刻的权值。

正难则反，考虑未点亮的点，以下称之为黑点。

观察到一号节点不会变为白色，因此白点构成子树的限制就等价于黑点构成连通块，而一个合法时刻的权值就是黑白边（边上两点一黑一白）的数量。

操作和权值的表达都是边，考虑将合法的判断也改成边。注意到每个连通块 $S$ 的边数一定是 $|S|-1$，因此连通块个数就是**点数减边数**。所以，设黑点个数为 $x$，黑边（边上两点都为黑）个数为 $y$，有 $x-y\ge 1$，当 $(x-y)_{\min}=1$ 时恰有一个连通块。

至此，题目的所有信息只和边的种类、点的颜色相关，用线段树维护即可。

时间复杂度 $O(n\log n)$。

有些卡常，寻找边的编号写了哈希。

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define ll long long
#define il inline
using namespace std;
const int p=1e7+7;
const int maxn=500010;
il int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
map<pair<int,int>,int>id;
int n,m,b[maxn];
struct info{
	int u,v;
	info(int _x=0,int _y=0){u=_x,v=_y;}
	bool operator ==(info x)const{return min(u,v)==min(x.u,x.v)&&max(u,v)==max(x.u,x.v);}
}a[maxn<<1];
struct Hash{
	info v;
	int id,to;
}e[maxn<<1];
int head[p],ecnt;
void Insert(info x,int id){
	int val=1ll*x.u*x.v%p;
	for(int i=head[val];i;i=e[i].to)
		if(e[i].v==x) return e[i].id=id,void();
	e[++ecnt].v=x,e[ecnt].id=id;
	e[ecnt].to=head[val],head[val]=ecnt;
}
int Find(info x){
	int val=1ll*x.u*x.v%p;
	for(int i=head[val];i;i=e[i].to)
		if(e[i].v==x) return e[i].id;
	return -1;
}
namespace Seg{
	#define MAXN maxn*4
	int dm[MAXN],dmc[MAXN];
	int lz1[MAXN],lz2[MAXN];
	ll ds[MAXN],dms[MAXN];
	void pushup(int i){
		dm[i]=min(dm[i<<1],dm[i<<1|1]);
		if(dm[i<<1]==dm[i<<1|1]){
			dmc[i]=dmc[i<<1]+dmc[i<<1|1];
			dms[i]=dms[i<<1]+dms[i<<1|1];
		}
		if(dm[i<<1]<dm[i<<1|1]){
			dmc[i]=dmc[i<<1];
			dms[i]=dms[i<<1];
		}
		if(dm[i<<1]>dm[i<<1|1]){
			dmc[i]=dmc[i<<1|1];
			dms[i]=dms[i<<1|1];
		}
		ds[i]=ds[i<<1]+ds[i<<1|1];
	}
	void pushdown(int i,int l,int r){
		int mid=l+r>>1;
		if(lz1[i]){
			ds[i<<1]+=(mid-l+1)*lz1[i];
			dms[i<<1]+=dmc[i<<1]*lz1[i];
			lz1[i<<1]+=lz1[i];
			ds[i<<1|1]+=(r-mid)*lz1[i];
			dms[i<<1|1]+=dmc[i<<1|1]*lz1[i];
			lz1[i<<1|1]+=lz1[i];
		}lz1[i]=0;
		if(lz2[i]){
			dm[i<<1]+=lz2[i],lz2[i<<1]+=lz2[i];
			dm[i<<1|1]+=lz2[i],lz2[i<<1|1]+=lz2[i];
		}lz2[i]=0;
	}
	void build(int i,int l,int r){
		if(l==r){
			dm[i]=n-l,dmc[i]=1;
			return ;
		}int mid=l+r>>1;
		build(i<<1,l,mid),build(i<<1|1,mid+1,r);
		pushup(i);
	}
	void A1(int i,int l,int r,int L,int R,int k){
//		if(i==1) printf("A1 : [%d,%d]->%d\n",L,R,k);
		if(l>R||r<L) return ;
		if(l>=L&&r<=R){
			ds[i]+=(r-l+1)*k;
			dms[i]+=dmc[i]*k;
			return lz1[i]+=k,void();
		}int mid=l+r>>1;
		pushdown(i,l,r);
		if(mid>=L) A1(i<<1,l,mid,L,R,k);
		if(mid<R) A1(i<<1|1,mid+1,r,L,R,k);
		pushup(i);
	}
	void A2(int i,int l,int r,int L,int R,int k){
//		if(i==1) printf("A2 :%d,%d[%d]\n",L,R,k);
		if(l>R||r<L) return ;
		if(l>=L&&r<=R){
			dm[i]-=k,lz2[i]-=k;
			return ;
		}int mid=l+r>>1;
		pushdown(i,l,r);
		if(mid>=L) A2(i<<1,l,mid,L,R,k);
		if(mid<R) A2(i<<1|1,mid+1,r,L,R,k);
		pushup(i);
	}
	#undef MAXN
}
void upd(info x,int k){
//	printf("upd :(%d,%d)\n",x.u,x.v);
	int l=min(b[x.u],b[x.v]);
	int r=max(b[x.u],b[x.v]);
	Seg::A1(1,1,n-1,l,r-1,k);
	Seg::A2(1,1,n-1,1,l-1,k);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<n;i++){
		a[i].u=read(),a[i].v=read();
		Insert(a[i],i); 
	}
	b[1]=n;
	for(int i=2;i<=n;i++) b[read()]=i-1;
	Seg::build(1,1,n-1);
	for(int i=1;i<n;i++) upd(a[i],1);
//	printf("Min : %d\n",Seg::dm[1]);
	printf("%lld\n",Seg::dm[1]==1?Seg::dms[1]:0);
	for(int test=1;test<=m;test++){
		int x=read(),y=read();
		int u=read(),v=read();
		int id1=Find(info(x,y)),id2=n+test-1;
		Insert(info(u,v),id2);
		a[id2].u=u,a[id2].v=v;
		upd(a[id1],-1),upd(a[id2],1);
//		printf("Minc : %d\n",Seg::dmc[1]); 
		printf("%lld\n",Seg::dm[1]==1?Seg::dms[1]:0);
	}
	return 0;
}
```

---

## 作者：zifanwang (赞：2)

[传送门](https://www.luogu.com.cn/problem/P8990)

妙妙题。

如果一个点被点亮了，那么就称这个点为白点，否则为黑点。

由题意可得点 $1$ 任意时刻都是黑点，于是“一个树是美丽的当前仅当对于每一个被点亮的节点，这个节点子树内的节点都是点亮的。”便可以转化为：

- 一个树是美丽的当前仅当任意时刻黑点形成一个连通块。

显然有：

- 黑点连通块个数 $=$ 黑点个数 $-$ 连接两个黑点的边的个数。

- 白点连通块个数 $=$ 连接一个黑点和一个白点的边的个数。

对时间线建立线段树维护即可。线段树上每个节点记录节点区间内**黑点连通块个数**的最小值和对应时刻的**白点连通块个数**的和。

参考代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 500003
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
using namespace std;
struct node{
	int x,y;
}d[mxn];
int n,m,a[mxn],p[mxn],f[mxn<<2],c[mxn<<2],ad[mxn<<2];
ll t[mxn<<2],d1[mxn<<2];
void push_up(int p){
	f[p]=min(f[p<<1],f[p<<1|1]);
	t[p]=0,c[p]=0;
	if(f[p<<1]==f[p])t[p]+=t[p<<1],c[p]+=c[p<<1];
	if(f[p<<1|1]==f[p])t[p]+=t[p<<1|1],c[p]+=c[p<<1|1];
}
void build(int p,int l,int r){
	if(l==r){
		f[p]=n-l,t[p]=0,c[p]=1;
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void push_down(int p){
	if(ad[p]){
		f[p<<1]+=ad[p],ad[p<<1]+=ad[p];
		f[p<<1|1]+=ad[p],ad[p<<1|1]+=ad[p];
		ad[p]=0;
	}
	if(d1[p]){
		t[p<<1]+=d1[p]*c[p<<1],d1[p<<1]+=d1[p];
		t[p<<1|1]+=d1[p]*c[p<<1|1],d1[p<<1|1]+=d1[p];
		d1[p]=0;
	}
}
void upd(int p,int l,int r,int x,int L,int R){
	if(l<=L&&R<=r){
		f[p]+=x,ad[p]+=x;
		return;
	}
	push_down(p);
	int mid=(L+R)>>1;
	if(l<=mid)upd(p<<1,l,r,x,L,mid);
	if(r>mid)upd(p<<1|1,l,r,x,mid+1,R);
	push_up(p);
}
void add(int p,int l,int r,int x,int L,int R){
	if(l<=L&&R<=r){
		t[p]+=x*c[p],d1[p]+=x;
		return;
	}
	push_down(p);
	int mid=(L+R)>>1;
	if(l<=mid)add(p<<1,l,r,x,L,mid);
	if(r>mid)add(p<<1|1,l,r,x,mid+1,R);
	push_up(p);
}
void add(int a,int b){
	int x=min(p[a],p[b]),y=max(p[a],p[b]);
	if(x>1)upd(1,1,x-1,-1,1,n-1);
	if(x<y)add(1,x,y-1,1,1,n-1);
}
void del(int a,int b){
	int x=min(p[a],p[b]),y=max(p[a],p[b]);
	if(x>1)upd(1,1,x-1,1,1,n-1);
	if(x<y)add(1,x,y-1,-1,1,n-1);
}
signed main(){
	scanf("%d%d",&n,&m);
	rept(i,1,n)scanf("%d%d",&d[i].x,&d[i].y);
	rept(i,1,n)scanf("%d",&a[i]),p[a[i]]=i;
	p[1]=n;
	build(1,1,n-1);
	rept(i,1,n){
		int x=min(p[d[i].x],p[d[i].y]),y=max(p[d[i].x],p[d[i].y]);
		if(x>1)upd(1,1,x-1,-1,1,n-1);
		if(x<y)add(1,x,y-1,1,1,n-1);
	}
	printf("%lld\n",t[1]);
	int x1,y1,x2,y2;
	while(m--){
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		del(x1,y1);
		add(x2,y2);
		printf("%lld\n",t[1]);
	}
	return 0;
}
```

---

## 作者：Jryno1 (赞：2)

## 简要题面

给定大小为 $n$ 有根树（根为 $1$）和一个不包括根的操作序列，每次按照操作序列染色。当一个时刻所有被染色的点的子树中所有点也被染色了，将答案**加上**此时所有被染色的点的形成连通块数量。输出操作结束之后的答案。

还会有 $m$ 删边和加边的操作。每次删除后再次询问答案。

$n,m\le 10^5$。

## Sol

先考虑转化“所有被染色的点的子树都被染色”这个条件，因为每次单独考虑一个节点的子树是不好处理的（尤其是在修改的时候父子关系可能改变的情况下）。会发现这个条件等价于所有没有被染色的点会恰好处于一个连通块中，且连通块的根节点为 $1$。原图是一棵树，因此连通块也应该为树，即应该满足 $N=M+1$ 的条件。其中 $N$ 为节点数，$M$ 为边数。

此时我们有了能够比较快速判断一个状态是否会给答案有贡献的方法，更具体的，假如到了第 $i$ 次操作之后，我们只需要考虑此时是否满足 $N-i=P+1$ 的条件。其中 $P$ 为没有被染色点之间边的数量。

对于 $P$ 进行维护，会发现一条边 $(u,v)$ 连接的两个节点在其中一个点被选择之前对 $P$ 的贡献始终为 $1$ 之后一直是 $0$，即是一个区间贡献的形式。这样转化的好处有二，其一，我们不需要在意 $(u,v)$ 的具体的祖先关系，这样在后面更改操作能够容易维护；其二，这样的形式可以通过对于每个时间点建立线段树后 $O(\log n)$ 维护。 

此时我们成功一半了，但是还需要考虑如何计算答案。在一个符合条件的情况下，我们按照同样的套路观察边的情况。不难发现此时被染色点形成连通块的数量应该为：所有一边的点被染色另一边的点不被染色边的数量，设其为 $Q$。

再次观察 $(u,v)$，在其中一个点被染色之后，且另一个点没有被染色的时候对于 $Q$ 的贡献为 $1$。其他的时候一直为 $0$。这和 $P$ 的更改情况几乎一样，我们同样可以在线段树上维护。这样同样可以在 $\log n$ 的时间内维护，至此整道题的思路梳理完。

具体实现上，在线段树上维护两个个参数，分别表示 $N-i-P$，$Q$。其中 $N-i-P$ 为区间每个点 $N-i-P$ 的最大值，询问的时候如果 $N-i-P=1$ 则贡献为 $Q$。

但是直接这样暴力判断在查询的时候会导致往下推的次数太多，因此可以再记录一个参数，表示区间 $N-i-P$ 的最小值，如果最小值 $> 1$，则在查询的时候可以直接跳过。

每次加入一条边（以下假设 $u$ 在序列中出现的时间早于 $v$)，将 $[1,t_u)$ 的 $N-i-P$ 减 $1$，将 $[t_u,t_v)$ 的 $Q$ 加一。删除同理。

复杂度 $O(m\log n)$。

[ 代码实现 ](https://www.luogu.com.cn/record/116167116)

[ LOJ 记录 ](https://loj.ac/s/1832094)

---

## 作者：WrongAnswer_90 (赞：0)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90-home/p/18134386)

[P8990 [北大集训 2021] 小明的树](https://www.luogu.com.cn/problem/P8990)

首先连通块个数可以用经典的点边转化，用点的个数减去边的条数。

观察之后可以发现定合法的充要条件是黑色的点构成一个连通块，同样使用点边转化。

现在可以看成有两个序列（时间轴），$V$ 和 $S$，操作是区间 $v$ 的修改，区间 $s$ 的修改，和查询全局 $v=1$ 的 $s$ 的和。

对于一个点，设 $p_i$ 为其出现时间，则其在 $[1,p_i-1]$ 上对 $v$ 有 $1$ 的贡献，在 $[p_i,n]$ 上对 $s$ 有 $1$ 的贡献。

对于一条边，设 $p_1$ 为两端点出现较早的时间，$p_2$ 为较晚点的出现时间，则其在 $[1,p_1-1]$ 上对 $v$ 有 $-1$ 的贡献，在 $[p_2,n]$ 上对 $s$ 有 $-1$ 的贡献。

容易发现操作一定保证 $v\geq 1$，所以线段树维护区间 $v$ 是最小值的 $s$ 的和，修改就直接把原来边的贡献删掉，再加入新的边。经典答案和树形态无关，复杂度是 $\mathcal O((n+q)\log n)$。

```cpp
	int n,m,a[500010];
	vector<pii> ve;
	namespace Segment
	{
		#define ls(x) (t[x].l+t[x].r)
		#define rs(x) (ls(x)^1)
		struct{int l,r,v,s,sz,tg1,tg2;}t[1000010];
		inline void update(int x)
		{
			t[x].v=min(t[ls(x)].v,t[rs(x)].v),t[x].s=t[x].sz=0;
			if(t[x].v==t[ls(x)].v)t[x].s+=t[ls(x)].s,t[x].sz+=t[ls(x)].sz;
			if(t[x].v==t[rs(x)].v)t[x].s+=t[rs(x)].s,t[x].sz+=t[rs(x)].sz;
		}
		inline void down1(int p,int x){t[p].tg1+=x,t[p].v+=x;}
		inline void down2(int p,int x){t[p].tg2+=x,t[p].s+=t[p].sz*x;}
		inline void spread(int p)
		{
			down1(ls(p),t[p].tg1),down1(rs(p),t[p].tg1);
			down2(ls(p),t[p].tg2),down2(rs(p),t[p].tg2);
			t[p].tg1=t[p].tg2=0;
		}
		void build(int p,int l,int r)
		{
			t[p].l=l,t[p].r=r;
			if(l==r)return t[p].sz=1,t[p].v=l==n,void();
			int mid=l+((r-l)>>1);
			build(ls(p),l,mid),build(rs(p),mid+1,r),update(p);
		}
		void modify1(int p,int l,int r,int x)
		{
			if(l<=t[p].l&&r>=t[p].r)return down1(p,x);
			spread(p);
			if(l<=t[ls(p)].r)modify1(ls(p),l,r,x);
			if(r>t[ls(p)].r)modify1(rs(p),l,r,x);
			update(p);
		}
		void modify2(int p,int l,int r,int x)
		{
			if(l<=t[p].l&&r>=t[p].r)return down2(p,x);
			spread(p);
			if(l<=t[ls(p)].r)modify2(ls(p),l,r,x);
			if(r>t[ls(p)].r)modify2(rs(p),l,r,x);
			update(p);
		}
		void print(int p)
		{
			write(t[p].l,' ',t[p].r,' ',t[p].v,' ',t[p].s,'\n');
			if(t[p].l==t[p].r)return;
			spread(p),print(ls(p)),print(rs(p));
		}
	}
	using namespace Segment;
	inline void add(pii p,int v)
	{
		if(a[p.fi]>a[p.se])swap(p.fi,p.se);
		if(a[p.fi]>1)modify1(1,1,a[p.fi]-1,-v);
		modify2(1,a[p.se],n,-v);
	}
	inline void add(int p,int v)
	{
		if(a[p]>1)modify1(1,1,a[p]-1,v);
		modify2(1,a[p],n,v);
	}
	inline void mian()
	{
		read(n,m),a[1]=n,build(1,1,n);int x,y;
		for(int i=1;i<n;++i)read(x,y),ve.eb(mp(x,y));
		for(int i=1;i<n;++i)read(x),a[x]=i;
		for(int i=1;i<=n;++i)add(i,1);
		for(auto p:ve)add(p,1);
		if(t[1].v==1)write(t[1].s-1,'\n');
		else puts("0");
		while(m--)
		{
			read(x,y),add(mp(x,y),-1),read(x,y),add(mp(x,y),1);
			if(t[1].v==1)write(t[1].s-1,'\n');
			else puts("0");
		}
	}
```

---

## 作者：wYYSZLwSSY (赞：0)

好像不是很难，虽然见过这两个 trick 但是真没想到，还是不熟练啊。

## 题解
不卖关子。

**Trick1**：发现“点亮节点子树内的节点都是点亮的”这个东西不好维护，转换成其它节点形成联通快。

这并不总是成立，当根节点可以被点亮时就不成立，但这个题并不。

考虑证明。其实这个结论和割点一些性质有点像（根节点特殊），所以从割点角度入手。一棵树（不考虑根节点）除了叶子结点外一定都是割点，那么选中就意味着树被分割，除非把它的子树也选上或者选上除了它子树以外的所有节点。所以上面结论充要性显然。

**Trick2**：（点边容斥）森林联通块数=点数-边数。

很显然，所以略去证明。

因此，设 $i$ 步之后点亮的点的“导出森林”有 $f_i$ 个联通块，未点亮的点有 $g_i$ 个联通快，那么结果就是：
$$\sum^{n-1}_{i=1}{[g_i=1] \cdot f_i}$$

而 $f_i=i-e(\cup^i_1 a_i)$，$g_i=(n-i)-e(\cup^n_{i+1} a_i)$。加减边实际上是区间加减，维护答案即维护 $g$ 最小时 $f$ 的和。

一个块中 $f$ 和 $g$ 的 $tag$ 相对独立，可以使用线段树。

时间复杂度：$O((n+m)\log n)$。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,u,v,x,y,ia[500005],a[500005];
int num,hd[500005];
bitset<500005>b;
int f[500005],g[500005];
struct P{int nxt,to;}line[1000006];
void add(int x,int y){
	++num;
	line[num]={hd[x],y};
	hd[x]=num;
	return ;
}
struct Q{int l,r,sum,minn,num,tagf,tagg;}tree[2000006];
Q operator + (Q x,Q y){
	Q z={x.l,y.r,0,min(x.minn,y.minn)};
	if(x.minn==y.minn)z.sum=x.sum+y.sum,z.num=x.num+y.num;
	else if(x.minn<y.minn)z.sum=x.sum,z.num=x.num;
	else z.sum=y.sum,z.num=y.num;
	return z;
}
void build(int t,int l,int r){
	tree[t].l=l,tree[t].r=r;
	if(l==r)return tree[t]={l,r,f[l],g[l],1},void();
	int mid=l+r>>1;
	build(2*t,l,mid),build(2*t+1,mid+1,r);
	tree[t]=tree[2*t]+tree[2*t+1];
	return ;	
}
void pd(int t){
	auto&x=tree[t/2],&y=tree[t];
	y.tagf+=x.tagf;
	y.tagg+=x.tagg;
	y.sum+=x.tagf*y.num;
	y.minn+=x.tagg;
	return ;
}
void pushdown(int t){
	pd(2*t),pd(2*t+1);
	tree[t].tagf=tree[t].tagg=0;
	return;
}
void changef(int t,int ll,int rr,int c){
	if(ll>rr)return ;
	int l=tree[t].l,r=tree[t].r;
	if(ll<=l and r<=rr){
		tree[t].sum+=tree[t].num*c;
		tree[t].tagf+=c;
		return ;
	}
	pushdown(t);
	int mid=l+r>>1;
	if(ll<=mid)changef(2*t,ll,rr,c);
	if(rr>mid)changef(2*t+1,ll,rr,c);
	tree[t]=tree[2*t]+tree[2*t+1];
	return;
}
void changeg(int t,int ll,int rr,int c){
	if(ll>rr)return ;
	int l=tree[t].l,r=tree[t].r;
	if(ll<=l and r<=rr){
		tree[t].minn+=c;
		tree[t].tagg+=c;
		return ;
	}
	pushdown(t);
	int mid=l+r>>1;
	if(ll<=mid)changeg(2*t,ll,rr,c);
	if(rr>mid)changeg(2*t+1,ll,rr,c);
	tree[t]=tree[2*t]+tree[2*t+1];
	return;
}
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	//freopen("1.in","r",stdin);
	cin>>n>>m;
	for(int i=1;i<n;++i){
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<n;++i)cin>>a[i],ia[a[i]]=i;
	ia[1]=n;//
	b[1]=1;
	g[n-1]=1;
	int num=1;
	for(int i=n-1;i;--i){
		++num;
		b[a[i]]=1;
		for(int j=hd[a[i]];j;j=line[j].nxt){
			int to=line[j].to;
			if(b[to])--num;
		}
		g[i-1]=num;//注意这里不是 i
	}
	b=0;num=0;
	for(int i=1;i<n;++i){
		++num;b[a[i]]=1;
		for(int j=hd[a[i]];j;j=line[j].nxt){
			int to=line[j].to;
			if(b[to])--num;
		}
		f[i]=num;
	}
	--n;//操作只有 n-1
	build(1,1,n);
	cout<<tree[1].sum<<'\n';
	while(m--){
		cin>>u>>v>>x>>y;
		if(ia[u]>ia[v])swap(u,v);
		if(ia[x]>ia[y])swap(x,y);
		changef(1,ia[v],n,+1);
		changeg(1,1,ia[u]-1,+1);//-1 不要忘了
		changef(1,ia[y],n,-1);
		changeg(1,1,ia[x]-1,-1);//同上
		cout<<tree[1].sum<<'\n';
	}
	return 0;
}
```

---

## 作者：苏联小渣 (赞：0)

很厉害的转化，转化完之后就差不多做完了。

考虑对于一棵树是“美丽的”找到一个更好的充要条件：假如被点亮的连通块是一些子树，那么没被点亮的连通块一定是一个包含根的连通块。也就是说，假如我们把没被点亮的点看成黑点，被点亮的点看成白点，那么充要条件就是**所有黑点组成的连通块只有一个。**

考虑黑色连通块个数如何更好的描述，可以用 $B=|V|-|E|$ 也即**点数减边数**来描述，这样每一次修改产生的贡献都是可以直接计算的。记录一个点 $x$ 被点亮的时间为 $t_x$，考虑对于一次修改，即点亮一个点 $x$，它对黑色连通块个数 $B$ 的影响：

- 点：黑点个数少一，即 $|V'| \gets |V|-1$。

- 边：在黑点连通块里面的边需要满足两端都是黑点，也就是说，$|E'| \gets |E|-c$，其中 $c$ 表示点亮 $x$ 后黑点连通块少的边数，换句话说，即 $(x,y)$ 的数量满足 $x,y$ 有边且 $t_y>t_x$。

再考虑点亮一个点 $x$ 对白点连通块个数 $W$，也就是答案的影响：考虑可以从连通块顶端计数，答案就是**两端不同色的边的数量**，那么点亮 $x$ 后，对于 $(x,y)$ 满足 $x,y$ 有边且 $t_y>t_x$，会给 $[t_x,t_y-1]$ 这个区间的答案加一，因为在 $t_y$ 时刻两个点又同色了。

那么不带修改的话，点和边的增量以及答案贡献都是可以很快求出的，对于单次模拟可以做到 $O(n)$。

考虑带修，即断掉一条边 $(x,y)$ 的影响（加上一条边本质相同，所以只讨论删除）。容易想到一个大致的思路，就是我们要维护每一时刻的信息，包括黑连通块数量和白连通块数量。然后统计满足 $B=1$ 时的 $W$ 之和。不妨假定 $t_x<t_y$。对于上述三个相关量分别考虑：

- 点：容易发现每一时刻点数不变。

- 边：对于 $[t_x,n-1]$ 时刻，其边数减一。

- $W$：对于 $[t_x,t_y-1]$ 时刻，连通块数量减一。

所以 $B$ 和 $W$ 的变化都是区间修改，最后查询满足 $B=1$ 时的 $W$ 之和。容易发现 $B \ge 1$，所以我们只需要维护**最小值、最小值个数和最小值的 $W$ 之和**，用线段树容易维护，时间复杂度 $O(n \log n)$。

### Code:

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int n, m, x, y, xx, yy, rev[500010];
struct node{
	int x, y;
}a[500010];
struct segment{
	#define lc(x) x<<1
	#define rc(x) x<<1|1
	int d[2000010], tag[2000010], tag2[2000010], cnt[2000010];
	ll tot[2000010];
	void pushup(int k){
		d[k] = min(d[lc(k)], d[rc(k)]);
		cnt[k] = tot[k] = 0;
		if (d[k] == d[lc(k)]) cnt[k] += cnt[lc(k)], tot[k] += tot[lc(k)];
		if (d[k] == d[rc(k)]) cnt[k] += cnt[rc(k)], tot[k] += tot[rc(k)];
	}
	void pushdown(int k){
		if (tag[k]){
			tag[lc(k)] += tag[k], tag[rc(k)] += tag[k];
			d[lc(k)] += tag[k], d[rc(k)] += tag[k];
			tag[k] = 0; 
		}
		if (tag2[k]){
			tag2[lc(k)] += tag2[k], tag2[rc(k)] += tag2[k];
			tot[lc(k)] += 1LL * tag2[k] * cnt[lc(k)], tot[rc(k)] += 1LL * tag2[k] * cnt[rc(k)];
			tag2[k] = 0;
		}
	}
	void build(int k, int l, int r){
		if (l == r){
			cnt[k] = 1, d[k] = 1 - l;
			return ;
		}
		int mid = l + r >> 1;
		build(lc(k), l, mid);
		build(rc(k), mid+1, r);
		pushup(k);
	}
	void modify1(int k, int l, int r, int x, int y, int val){
		if (x > y) return ;
		if (x <= l && r <= y){
			d[k] += val, tag[k] += val;
			return ;
		}
		int mid = l + r >> 1;
		pushdown(k);
		if (x <= mid) modify1(lc(k), l, mid, x, y, val);
		if (y > mid) modify1(rc(k), mid+1, r, x, y, val);
		pushup(k);
	}
	void modify2(int k, int l, int r, int x, int y, int val){
		if (x > y) return ;
		if (x <= l && r <= y){
			tot[k] += 1LL * val * cnt[k], tag2[k] += val;
			return ;
		}
		int mid = l + r >> 1;
		pushdown(k);
		if (x <= mid) modify2(lc(k), l, mid, x, y, val);
		if (y > mid) modify2(rc(k), mid+1, r, x, y, val);
		pushup(k); 
	}
}S;
int main(){
	scanf ("%d%d", &n, &m);
	for (int i=1; i<n; i++){
		scanf ("%d%d", &a[i].x, &a[i].y);
	}
	S.build(1, 1, n-1);
	for (int i=1; i<n; i++){
		scanf ("%d", &x);
		rev[x] = i;
	}
	rev[1] = n;
	for (int i=1; i<n; i++){
		x = a[i].x, y = a[i].y;
		if (rev[x] > rev[y]) swap(x, y);
		S.modify1(1, 1, n-1, rev[x], n-1, 1);
		S.modify2(1, 1, n-1, rev[x], rev[y]-1, 1);
	}
	printf ("%lld\n", S.tot[1]);
	for (int i=1; i<=m; i++){
		scanf ("%d%d%d%d", &x, &y, &xx, &yy);
		if (rev[x] > rev[y]) swap(x, y);
		if (rev[xx] > rev[yy]) swap(xx, yy);
		S.modify1(1, 1, n-1, rev[x], n-1, -1);
		S.modify2(1, 1, n-1, rev[x], rev[y]-1, -1);
		S.modify1(1, 1, n-1, rev[xx], n-1, 1);
		S.modify2(1, 1, n-1, rev[xx], rev[yy]-1, 1);
		printf ("%lld\n", S.tot[1]);
	} 
	return 0;
}
```

---

## 作者：Luciylove (赞：0)

考虑转化这个合法的情形：

点灯了的点形成若干完整的子树，相当于所有没有点灯的点在树中形成连通块，然后贡献是这两种点相连的边的个数。

做到这里就可以开始做了。然后我们用经典技巧把数黑点的树转化为点减边，考虑两端变亮的时间 $t_x < t_y$。然后时刻 $i$ 有 $n - i$ 个没变亮的点，一条没有被点过的边存在的时刻是 $[1,t_x)$。

不难使用线段树维护，最后根据经典结论可以做到反射到最小值的权值和。

一条边异色的时间是 $[t_x, t_y)$ 我们把他挂在线段树上加 1 就好了。

相当于区间加，区间最小值权值加。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = l; i <= r; i ++)
#define per(i, r, l) for (int i = r; i >= l; i --)
#define lc x << 1
#define rc x << 1 | 1
#define ll long long
using namespace std;

const int _ = 5e5 + 5, mod = 998244353;

int read () {
    int ans = 0; char c = getchar(), last = ' ';
    while(c < '0' || c > '9') last = c,c = getchar();
    while(c >= '0' && c <= '9') ans = (ans << 1) + (ans << 3) + c - '0',c = getchar();
    return last == '-' ? - ans : ans;
}
struct Tag { 
	int v, d; 
	Tag operator + (const Tag &x) const { return {v + x.v, d + x.d}; }
} ;
struct Info { 
	int mn, cnt; ll sum; 
	Info operator + (const Info &x) const {
		if (mn < x.mn) return *this;
		else if (mn > x.mn) return x;
		return {mn, cnt + x.cnt, sum + x.sum};
	}
	Info operator + (const Tag &x) const { return {mn + x.v, cnt, sum + 1ll * cnt * x.d}; }
};

Tag tag[_ << 2];
Info info[_ << 2];

int n, q, t[_];
pair <int, int> e[_];

void apply (int x, Tag k) { info[x] = info[x] + k, tag[x] = tag[x] + k; }
void pushdown (int x) {
	if (tag[x].v || tag[x].d) {
		apply(lc, tag[x]), apply(rc, tag[x]);
		tag[x] = {0, 0};
	}
}
void build (int x, int l, int r) {
	if (l == r) return info[x] = {n - l, 1, 0}, void();
	int mid = (l + r) >> 1; 
	build(lc, l, mid), build(rc, mid + 1, r);
	info[x] = info[lc] + info[rc];
}
void modify (int x, int l, int r, int ql, int qr, Tag k) {
	if (ql > qr) return ; 
	if (ql <= l && r <= qr) return apply(x, k);
	int mid = (l + r) >> 1; pushdown(x);
	if (ql <= mid) modify(lc, l, mid, ql, qr, k);
	if (qr > mid) modify(rc, mid + 1, r, ql, qr, k);
	info[x] = info[lc] + info[rc];
}

void link (int x, int y, int v) {
	int st = min(t[x], t[y]), ed = max(t[x], t[y]);
	modify(1, 1, n - 1, 1, st - 1, {-v, 0}), 
	modify(1, 1, n - 1, st, ed - 1, {0, v});
}
int main () {
	n = read(), q = read();
	rep(i, 1, n - 1) {
		int x = read(), y = read();
		e[i] = {x, y};
	}
	build(1, 1, n - 1);
	rep(i, 1, n - 1) t[read()] = i; t[1] = n;
	rep(i, 1, n - 1) link(e[i].first, e[i].second, 1);
	cout << info[1].sum << endl;
	rep(i, 1, q) {
		int x = read(), y = read(), a = read(), b = read();
		link(x, y, -1), link(a, b, 1);
		printf("%lld\n", info[1].sum);
	}
	return 0;
}

```


---

## 作者：CarroT1212 (赞：0)

+ 关键词：线段树。

黑不至于吧。

尝试对点进行维护，然后发现我们做不到。每次嫁接子树的操作会直接把祖先关系全部打乱，所以只能对边下手。

令点亮的点叫白点，没点亮的叫黑点，连接两个白点的边叫白边，两个黑点的叫黑边，一个黑点一个白点的叫黑白边。第 $i$ 个点变成白点的时间为 $d_i$。

白点这个子树限制有点抽象，一个更广为人知的说法是黑点连通。所以首先我们要将这个条件方便地表示出来。

发现在这棵树上，黑点形成的连通块数就等于黑点个数减去黑边条数。设目前是第 $i$ 次操作，黑边有 $h$ 条。黑点个数为 $n-i$，而黑边条数就是在这 $i$ 次操作之后满足 $d_u>i$ 且 $d_v>i$ 的边 $(u,v)$ 数量。不考虑修改的话可以差分处理出来。

而某一时刻对答案的贡献首先要满足上面的 $n-i-h=1$，然后白点连通块数就是此时的黑白边数量，也就是满足 $d_u\le i$ 且 $d_v>i$ 的边 $(u,v)$ 数量。同样可以差分。这样我们就 $O(n)$ 地基于边求出了第一个答案。

然而还有修改，于是我们需要一个在线的东西来搞。

线段树即可，维护区间 $n-i-h$ 的最小值，取到最小值的 $n-i-h$ 个数以及这些 $n-i-h$ 对应的黑白边条数之和。保持线段树里的 $n-i$ 不变，那么 $h$ 和黑白边个数都是可以 $O(\log)$ 撤销和添加的，解决了。

最后发现我写得好丑啊，封装了但是没有完全封装是这样的。

```cpp
int n,m,a[N],b[N],c[N],d[N];
struct sgt {
	ll m[N<<2],c[N<<2],w[N<<2],tg1[N<<2],tg2[N<<2];
	void pdn(int p,int l,int r,int mid) {
		if (tg1[p]) {
			m[p<<1]+=tg1[p],tg1[p<<1]+=tg1[p];
			m[p<<1|1]+=tg1[p],tg1[p<<1|1]+=tg1[p];
			tg1[p]=0;
		}
		if (tg2[p]) {
			w[p<<1]+=c[p<<1]*tg2[p],tg2[p<<1]+=tg2[p];
			w[p<<1|1]+=c[p<<1|1]*tg2[p],tg2[p<<1|1]+=tg2[p];
			tg2[p]=0;
		}
	}
	void pup(int p) {
		m[p]=min(m[p<<1],m[p<<1|1]);
		c[p]=c[p<<1]*(m[p]==m[p<<1])+c[p<<1|1]*(m[p]==m[p<<1|1]);
		w[p]=w[p<<1]*(m[p]==m[p<<1])+w[p<<1|1]*(m[p]==m[p<<1|1]);
	}
	void bui(int p,int l,int r) {
		if (l==r) return m[p]=n-l,c[p]=1,vo;
		int mid=l+r>>1;
		bui(p<<1,l,mid),bui(p<<1|1,mid+1,r);
		pup(p);
	}
	void add1(int p,int l,int r,int x,int y,int z) {
		if (x<=l&&r<=y) return m[p]+=z,tg1[p]+=z,vo;
		int mid=l+r>>1;
		pdn(p,l,r,mid);
		if (x<=mid) add1(p<<1,l,mid,x,y,z);
		if (y>mid) add1(p<<1|1,mid+1,r,x,y,z);
		pup(p);
	}
	void add2(int p,int l,int r,int x,int y,int z) {
		if (x<=l&&r<=y) return w[p]+=c[p]*z,tg2[p]+=z,vo;
		int mid=l+r>>1;
		pdn(p,l,r,mid);
		if (x<=mid) add2(p<<1,l,mid,x,y,z);
		if (y>mid) add2(p<<1|1,mid+1,r,x,y,z);
		pup(p);
	}
} tr;
void mian() {
	scanf("%d%d",&n,&m);
	for (int i=1;i<n;i++) scanf("%d%d",&a[i],&b[i]);
	for (int i=1;i<n;i++) scanf("%d",&c[i]),d[c[i]]=i;
	d[1]=n;
	tr.bui(1,1,n-1);
	for (int i=1;i<n;i++) {
		if (d[a[i]]>d[b[i]]) swap(a[i],b[i]);
		if (d[a[i]]>1) tr.add1(1,1,n-1,1,d[a[i]]-1,-1);
		if (d[a[i]]<d[b[i]]) tr.add2(1,1,n-1,d[a[i]],d[b[i]]-1,1);
	}
	cout<<tr.w[1]<<"\n";
	for (int i=1,xa,ya,xb,yb;i<=m;i++) {
		scanf("%d%d%d%d",&xa,&ya,&xb,&yb);
		if (d[xa]>d[ya]) swap(xa,ya);
		if (d[xb]>d[yb]) swap(xb,yb);
		if (d[xa]>1) tr.add1(1,1,n-1,1,d[xa]-1,1);
		if (d[xa]<d[ya]) tr.add2(1,1,n-1,d[xa],d[ya]-1,-1);
		if (d[xb]>1) tr.add1(1,1,n-1,1,d[xb]-1,-1);
		if (d[xb]<d[yb]) tr.add2(1,1,n-1,d[xb],d[yb]-1,1);
		cout<<tr.w[1]<<"\n";
	}
}
```

---


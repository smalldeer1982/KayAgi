# [PA 2021] Desant 2

## 题目描述

Byteotia 准备再次袭击 Bitotia！在敌人的领土上登陆是一个真正硬汉的任务，因此，Byteotia 最好的特种部队的士兵——Byteburg——将参与其中。

Bytchak 将军让 $n$ 名士兵集合。他们立即排成一排，并从左到右依次用 $1$ 到 $n$ 的整数编号。将军希望选择一定数量的部队重新部署到 Bitotia 境内。作为一个熟练的战略家，他知道他的部下排队顺序不是随意的，而是与他们之间的友好关系有关，所以他选择的每支部队必须恰好由 $k$ 个连续的士兵组成。通过这种方式，他可以确保组成小队的士兵能够很好地合作。当然，每个士兵最多属于一个小队，将军对小队的数量没有偏好——特别是，他可以不选择任何小队而放弃对 Bitotia 的攻击（至少暂时如此）。

Bytchak 将军知道每一个士兵的技能——他可以用一个整数 $a_i$ 来描述他们每个人。技能值越高，这个士兵在战斗中的效率就越高。这个值也可以是负数，意味着这个士兵可能只会阻碍行动。

将军希望将所有将被派去登陆的士兵的 $a_i$ 值之和最大化。然而，有一个问题。可能他要派一定数量的排头兵去与 Intotia 作战的前线，而派一定数量的排尾兵在 Longlongotia 进行情报行动。那么他将不得不只从位置号在 $[l_i, r_i]$ 范围内的士兵中选择部队。

请你帮助将军考虑不同的情况，并为每一种情况计算派去登陆的士兵的最大可能的 $a_i$ 值之和。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n, q \leq 3 \times 10^5$，$1 \leq k \leq n$，$-10^9 \leq a_i \leq 10^9$，$1 \leq l_i \leq r_i \leq n$。

## 样例 #1

### 输入

```
8 3 7
3 -1 10 0 10 -1 1 -1
1 8
3 5
6 8
1 2
1 7
2 8
1 6```

### 输出

```
22
20
0
0
22
20
21```

# 题解

## 作者：Infter (赞：4)

[LibreOJ-3614](https://loj.ac/p/3614) [Luogu-P9040](https://www.luogu.com.cn/problem/P9040)

很好的题。

---

先不考虑区间，先想 $l=1,r=n$ 的情况。

考虑 dp，$f_i$ 表示考虑 $[l,r]$ 的答案。

则容易得到：
$$
f_i=\max\left\{f_{i-1}, f_{i-k}+s_i-s_{i-k}\right\},f_0=0
$$
其中 $s$ 为 $a$ 的前缀和。

这个转移本身是 $\Theta(n)$ 的。

遇见这种区间查询 DP 的通常都是动态 DP，但是由于下标跨了 $k$，矩阵的大小为 $\Theta(k)$，所以进行如此操作的时间复杂度为 $\Theta(k^3\log n)$，表现很差。

本题难点在此。

我们看到这个 DP 式子非常工整，灵光一现，唉我给她塞图上。

我们从 $u$ 向 $v$ 连长度为 $w$ 的边表示 $f_v$ 的转移方程式里有一项为 $f_u + w$。

突破口出现了！

原题所求的 $[l,r]$ 的答案就是 $l-1$ 到 $r$ 的最长路！（注意此处由于 $l$ 也要参与运算，所以起点为 $l-1$）

---

但是新的问题到来了，怎么给这样一个图求两点最短路呢？

显然不能 Johnson，这样比暴力还慢。

显然是要利用这个图的结构。

我们经过一顿梳理发现她长这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/rhge7hre.png)

规规整整的跟个矩形一样。

知道网格求最短路的同学瞬间就懂了。

---

接下来是个很经典的 trick。

对于一类网格图，我们若要求若干点对间的最短或长路则采用以下算法：

我们考虑把询问离线下来分治。

每次分治面向原网格中的一个子网格。

为了方便我们设她是 $r\times c$ 的。

$1^\circ$ 若 $r>c$，我们按照中间行把她切成两半，对于中间行上每个点 $p$ 算出其对子矩阵里所有点的最短或长路。（若是 DAG 则可直接 DP），然后枚举所有被这个中间行分开的点对 $u,v$，将 $u$ 到 $v$ 的最短或长路经过 $p$ 松弛。（因为 $u$ 到 $v$ 的最短或长路一定经过 $p$）

$2^\circ$ 不然则按照中间列切，同样枚举中间列上的点来计算。

每次把切完的两个小网格分治下去，要把两端点都在。

每次分治 $O(n\sqrt n)$。
$$
T(n)=O(n\sqrt n) + 2T(\cfrac{n}{2})
$$
由主定理，总复杂度 $O(n\sqrt n)$。

---

回到这道题。

我们发现还有一些从最顶上指到底下的边，他们可以通过这条边而不需通过中间行。

对于这种情况我们可以额外枚举第一行的每个点，因为经过斜边一定要经过第一行的点。

但是有可能在同一侧的节点的最长路穿下去再慢慢爬上来的情况。

这种情况我们也要给在同一侧的点对统计答案，但是由于只有一次不影响复杂度。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define endl '\n'
#define debug(x) cerr << #x << " = " << x << endl
#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define per(i, a, b) for (int i = (a); i >= (b); i--)
#define gn(u, v) for (int v : G.G[u])
#define pb emplace_back
#define mp make_pair
#define fi first
#define se second
#define sz(x) (int)(x).size()
#define pii pair<int, int>
#define vi vector<int>
#define vpii vector<pii>
#define vvi vector<vi>
#define no cout << "NO" << endl
#define yes cout << "YES" << endl
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define tomin(x, y) ((x) = min((x), (y)))
#define tomax(x, y) ((x) = max((x), (y)))
#define ck(mask, i) (((mask) >> (i)) & 1)
#define pq priority_queue
#define FLG (cerr << "Alive!" << endl);

constexpr int MAXN = 6e5 + 5;
constexpr int INF = 0x3f3f3f3f3f3f3f3f;
int n, k, q;
int a[MAXN];
vector<vpii> G;
vector<vpii> H;

struct Query {
    int u, v, ans;
};
vector<Query> query;

vi num[MAXN];
int x[MAXN], y[MAXN];
int dis[2][MAXN];

void get(int start, const vector<vpii>& G, const vector<vpii>& H, int lx, int rx, int ly, int ry, bool typ) {
    queue<int> q;
    q.push(start);
    dis[typ][start] = -1;
    vi vis;
    vis.pb(start);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (auto [v, w] : G[u]) {
            // cerr << "!" << v << endl;
            if (x[v] < lx || x[v] > rx || y[v] < ly || y[v] > ry)
                continue;
            if (dis[typ][v] != -1) {
                dis[typ][v] = -1;
                q.push(v);
                vis.pb(v);
            }
        }
    }

    rep (i, lx, rx) {
        rep (j, ly, ry) {
            dis[typ][num[i][j]] = -INF;
        }
    }

    if (typ)
        sort(all(vis), greater<>());
    else
        sort(all(vis));
    dis[typ][start] = 0;
    for (int u : vis) {
        if (u == start)
            continue;
        dis[typ][u] = -INF;
        for (auto [v, w] : H[u]) {
            if (x[v] < lx || x[v] > rx || y[v] < ly || y[v] > ry)
                continue;
            // cerr << v << " " << w << endl;
            tomax(dis[typ][u], dis[typ][v] + w);
        }
        // cerr << "dis from " << start << " to " << u << " with type " << typ << " is " << dis[typ][u] << endl;
    }
}

void solve(int lx, int rx, int ly, int ry, vector<Query>& q) {
    if (lx > rx || ly > ry || q.empty())
        return;
    rep (i, lx, rx) {
        rep (j, ly, ry) {
            dis[false][num[i][j]] = dis[true][num[i][j]] = 0;
        }
    }
    if (rx - lx <= ry - ly) {
        int mid = ly + ry >> 1;

        vector<Query> l, r, now;
        for (auto [u, v, ans] : q) {
            if (y[u] < mid && y[v] < mid) {
                l.pb(Query{u, v, ans});
            } else if (y[u] > mid && y[v] > mid) {
                r.pb(Query{u, v, ans});
            } else {
                now.pb(Query{u, v, ans});
            }
        }

        rep (tmp, lx, rx) {
            int cur = num[tmp][mid];
            get(cur, G, H, lx, rx, ly, ry, false);
            get(cur, H, G, lx, rx, ly, ry, true);
            for (auto& [u, v, ans] : now) {
                // if (u == 170 && v == 200) {
                //     cerr << lx << " " << rx << " " << ly << " " << ry << endl;
                //     cerr << dis[0][u] + dis[1][v] << " " << dis[1][u] + dis[0][v] << endl;
                // }
                tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
                // cerr << dis[0][u] << " " << dis[1][u] << " " << dis[0][v] << " " << dis[1][v] << endl;
            }
            for (auto& [u, v, ans] : l) {
                // if (u == 170 && v == 200) {
                //     cerr << lx << " " << rx << " " << ly << " " << ry << endl;
                //     cerr << dis[0][u] + dis[1][v] << " " << dis[1][u] + dis[0][v] << endl;
                // }
                tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
                // cerr << dis[0][u] << " " << dis[1][u] << " " << dis[0][v] << " " << dis[1][v] << endl;
            }
            for (auto& [u, v, ans] : r) {
                // if (u == 170 && v == 200) {
                //     cerr << lx << " " << rx << " " << ly << " " << ry << endl;
                //     cerr << dis[0][u] + dis[1][v] << " " << dis[1][u] + dis[0][v] << endl;
                // }
                tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
                // cerr << dis[0][u] << " " << dis[1][u] << " " << dis[0][v] << " " << dis[1][v] << endl;
            }
        }

        solve(lx, rx, ly, mid - 1, l);
        solve(lx, rx, mid + 1, ry, r);

        int i = 0, j = 0, cnt = 0;
        for (auto& [u, v, ans] : q) {
            if (y[u] < mid && y[v] < mid) {
                ans = l[i++].ans;
            } else if (y[u] > mid && y[v] > mid) {
                ans = r[j++].ans;
            } else {
                ans = now[cnt++].ans;
            }
        }
    } else {
        int mid = lx + rx >> 1;

        vector<Query> l, r, now;
        for (auto [u, v, ans] : q) {
            if (x[u] < mid && x[v] < mid) {
                l.pb(Query{u, v, ans});
            } else if (x[u] > mid && x[v] > mid) {
                r.pb(Query{u, v, ans});
            } else {
                now.pb(Query{u, v, ans});
            }
        }

        rep (tmp, ly, ry) {
            int cur = num[mid][tmp];
            get(cur, G, H, lx, rx, ly, ry, false);
            get(cur, H, G, lx, rx, ly, ry, true);
            for (auto& [u, v, ans] : now) {
                tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
            }
            for (auto& [u, v, ans] : l) {
                tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
            }
            for (auto& [u, v, ans] : r) {
                tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
            }
        }

        // if (lx == 1 && rx == k) {
            rep (tmp, ly, ry) {
                int cur = num[lx][tmp];
                get(cur, G, H, lx, rx, ly, ry, false);
                get(cur, H, G, lx, rx, ly, ry, true);
                for (auto& [u, v, ans] : now) {
                    tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
                }
                for (auto& [u, v, ans] : l) {
                    tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
                }
                for (auto& [u, v, ans] : r) {
                    tomax(ans, max(dis[0][u] + dis[1][v], dis[1][u] + dis[0][v]));
                }
            }
        // }

        solve(lx, mid - 1, ly, ry, l);
        solve(mid + 1, rx, ly, ry, r);

        int i = 0, j = 0, cnt = 0;
        for (auto& [u, v, ans] : q) {
            if (x[u] < mid && x[v] < mid) {
                ans = l[i++].ans;
            } else if (x[u] > mid && x[v] > mid) {
                ans = r[j++].ans;
            } else {
                ans = now[cnt++].ans;
            }
        }
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> k >> q;
    int tmp = (n / k + 1) * k - 1;
    rep (i, 1, n)
        cin >> a[i];
    rep (i, 1, tmp)
        a[i] += a[i - 1];
    
    G.resize(tmp + 1);
    H.resize(tmp + 1);
    rep (i, 1, tmp) {
        G[i - 1].pb(mp(i, 0));
        H[i].pb(mp(i - 1, 0));
        if (i >= k)
            G[i - k].pb(mp(i, a[i] - a[i - k])),
            H[i].pb(mp(i - k, a[i] - a[i - k]));
    }
    query.resize(q);
    rep (i, 0, q - 1) {
        cin >> query[i].u >> query[i].v;
        query[i].u--;
        query[i].ans = 0;
    }

    rep (i, 1, k) {
        num[i].resize(n / k + 2);
    }
    rep (i, 0, (n / k + 1) * k - 1) {
        num[i % k + 1][i / k + 1] = i;
        x[i] = i % k + 1;
        y[i] = i / k + 1;
    }
    // rep (i, 0, n) {
    //     for (auto [v, w] : G[i]) {
    //         cerr << i << " " << v << " " << w << endl;
    //     }
    // }

    solve(1, k, 1, n / k + 1, query);
    // cerr << x[170] << " " << y[170] << " " << x[200] << " " << y[200] << endl;

    rep (i, 0, q - 1)
        cout << query[i].ans << endl;

    return 0;
}
```

---

## 作者：紊莫 (赞：4)

洛谷最优解过不了模拟赛的数据.jpg

---

首先考虑暴力的 DP，$f_i$ 表示前 $i$ 个位置的最大答案，$f_i = \max(f_{i-1}, f_{i-k} + s_i - s_{i-k})$，其中 $s_i$ 表示的是 $a_i$ 的前缀和数组。

这样的话可以暴力做到 $O(nq)$。

对于 $k$ 比较小的情况，我们发现这个转移可以写成矩阵的形式，那么可以简单做到 $O(qk^3\log n )$，虽然没啥用。

此外，我们还有一个 $O(k(n\log n + q))$ 的分治做法：

我们对原序列分治一下，``solve(l, r)`` 表示当前正在处理原序列中 $[l, r]$ 的区间，我们要回答的是左端点在 $[l, mid]$ 和右端点在 $[mid + 1, r]$ 的询问。

首先，因为 $k$ 很小，比如 $k \le 30$，那么一定存在一个事情，就是会有两段的分界点在 $mid$ 附近，或者说是会有一个数字没选，那么我们可以枚举这个分界点，然后对左右分别按照上面的暴力做法 DP，统计答案即可。

然后来到正解：

我们把状态和转移看作是一个 DAG，画出这个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/cq1m3qm3.png)

对于横向边 $(u, u + k)$，边权为 $s_{u + k} - s_u$，对于其他边，权值为 $0$。

那么我们要求的就是网格图上 $l \rightarrow r$ 的最长路，这个问题我们仍然使用分治解决。

比如我们对于图中的一列分治，此时我们可以处理的询问就是左端点在 $mid$ 列左侧，右端点在 $mid$ 右侧的询问，因为其合法路径必然经过 $mid$ 列中的某个点。

我们可以枚举其经过的是哪个点，对于这个点 $i$，我们计算左边的点到 $i$ 的最长路和 $i$ 到右边的点的最长路，这个可以直接 DP 或拓扑排序计算。

然后像整体二分一样的划分询问，向下递归。

然后是对于一行的划分，显然我们也可以和上文一样的去做，但是会出现一个问题，因为存在上图中的斜边，所以可能有一种情况使得最长路不经过中间的任何一个点。

所幸的是这样的情况只会在第一次对行分治的时候才会出现，那么我们也可以暴力计算。

然后我们要做的是每次对矩形中较长的一边去分治，枚举的就是较短的边，这个不会超过 $O(\sqrt{S})$，$S$ 就是当前矩形的面积。

那么我们的复杂度是这样的 $T(n) = O(n \sqrt{n}) + 2T(\frac{n}{2})$ 可得 $T(n) = O(n \sqrt{n})$。

代码实现可以参考其他题解。

---

## 作者：COsm0s (赞：2)

妙妙题。

对于暴力，我们很轻松可以推出一个 $\Theta(nq)$ 的 dp。

对于每个询问区间 $[l,r]$，设 $f_i$ 为区间内前 $i$ 个数的答案。

则有 $f_i=\max(f_{i-1},f_{i-k}+\sum\limits^{i}_{j=i-k+1}a_j)$。

显然 $\sum a_j$ 可以前缀和。

我们考虑对于这个 dp 优化。

将 dp 的过程看成在一张图上遍历，那么将 $i$ 和转移的两部分 $i-1$ 和 $i-k$ 分别连边，边权为 $0$ 和 $\sum\limits^{i}_{j=i-k+1}a_j$。这样，一个区间 $[l,r]$ 的答案即为 $l,r$ 之间的**最长路**。

![](https://cdn.luogu.com.cn/upload/image_hosting/wu9l82rw.png)

如上图，我们把图建成一个近似矩形的形状，两边长为 $k,\lceil \frac{n}{k} \rceil$。

接着考虑分治。

+ 如果行数大于列数，考虑跨越中间列的询问一定经过中间列的点，对每个中间列的点求一遍所有点到其和其到所有点的最长路，即可处理这些询问，然后分治下去。

+ 反之，就对于中间行处理最长路即可。

	但是，这里有个特殊情况。如上图，我们在处理整个矩形时，中间行是 $1,4,7$。但是对于 $2,3$ 两个点，它们可以不用过中间行，这是因为在其之间有一条**跨越矩形的特殊边**。
    
  所以对于每条特殊边，我们需要让它做刚才的“中间行”的角色，即需要令此边两边的点走最长路时必须走过此边。
  
对于处理最长路，并不需要普通处理最长路的算法。由于处理最长路的过程本质上是 dp，我们只需要用暴力 dp 的方法求出最长路即可。

关于复杂度：分治的复杂度显然为 $\Theta(\log n)$，而对于枚举中间行或中间列，由于是选择行列中较小的一个枚举，所以相当于是 $\Theta(\sqrt {sum})$ 级别的，$sum$ 即为当前处理的矩形大小。

即 $T(n)=2T(\frac{n}{2})+O(n\sqrt{n})$。

根据主定理，总复杂度为 $\Theta(n\sqrt n)$。实际实现可以稳定在单测试点 $120$ ms。

luogu 数据过水了，建议在 LOJ 交题。

```cpp
void solve(int hl, int hr, int tl, int tr, vector<tuple<int, int, int> > qp) {
	if(hl > hr || tl > tr) return ;
	if(hr - hl <= tr - tl) {
		int mid = tl + tr >> 1;
		vector<tuple<int, int, int> > ql, qr, qq;
		for(auto opt : qp) {
			int l = get<0> (opt), r = get<1> (opt), id = get<2> (opt);
			if(pos[l].second < mid && pos[r].second < mid) ql.pb(l, r, id);
			else if(pos[l].second > mid && pos[r].second > mid) qr.pb(l, r, id);
			else qq.pb(l, r, id);
		}
		for(int now = hl; now <= hr; now ++) {
			int m = k * mid + now;
			for(int j = mid - 1; j >= tl; j --) {
				for(int i = hr; i >= hl; i --) {
					int u = i + j * k;
					f[u] = f[u + 1];
					if(u + k <= m) f[u] = max(f[u], f[u + k] + b[u]);
				}
			}
			for(int j = mid + 1; j <= tr; j ++) {
				for(int i = hl; i <= hr; i ++) {
					int u = i + j * k;
					f[u] = f[u - 1];
					if(u - k >= m) f[u] = max(f[u], f[u - k] + b[u - k]);
				}
			}
			for(auto opt : qq) {
				int l = get<0> (opt), r = get<1> (opt), id = get<2> (opt);
				if(l <= m && m <= r)
					ans[id] = max(ans[id], f[l] + f[r]);
			}
			for(int i = hl; i <= hr; i ++) {
				for(int j = tl; j <= tr; j ++) {
					f[i + j * k] = 0;
				}
			}
		}
		if(!ql.empty() && tl < mid) solve(hl, hr, tl, mid - 1, ql);
		if(!qr.empty() && tr > mid) solve(hl, hr, mid + 1, tr, qr);
	} else {
		if(hl == 0 && hr == k - 1) {
			for(int now = tl; now <= tr; now ++) {
				int m = now * k;
				for(int j = now - 1; j >= tl; j --) {
					for(int i = hr; i >= hl; i --) {
						int u = i + j * k;
						f[u] = f[u + 1];
						if(u + k <= m) f[u] = max(f[u], f[u + k] + b[u]);
					}
				}
				for(int j = now + 1; j <= tr; j ++) {
					for(int i = hl; i <= hr; i ++) {
						int u = i + j * k;
						f[u] = f[u - 1];
						if(u - k >= m) f[u] = max(f[u], f[u - k] + b[u - k]);
					}
				}
				for(auto opt : qp) {
					int l = get<0> (opt), r = get<1> (opt), id = get<2> (opt);
					if(l <= m && m <= r)
						ans[id] = max(ans[id], f[l] + f[r]);
				}
				for(int i = hl; i <= hr; i ++) {
					for(int j = tl; j <= tr; j ++) {
						f[i + j * k] = 0;
					}
				}
			}
		}
		int mid = hl + hr >> 1;
//		solve(hl, hr, tl, tmid - 1), solve(hl, hr, tmid + 1, tr);
		vector<tuple<int, int, int> > ql, qr, qq;
		for(auto opt : qp) {
			int l = get<0> (opt), r = get<1> (opt), id = get<2> (opt);
			if(pos[l].first < mid && pos[r].first < mid) ql.pb(l, r, id);
			else if(pos[l].first > mid && pos[r].first > mid) qr.pb(l, r, id);
			else qq.pb(l, r, id);
		}
		for(int now = tl; now <= tr; now ++) {
			int m = mid + k * now;
			for(int j = now - 1; j >= tl; j --) {
				for(int i = hr; i >= hl; i --) {
					int u = i + j * k;
					f[u] = f[u + 1];
					if(u + k <= m) f[u] = max(f[u], f[u + k] + b[u]);
				}
			}
			for(int j = now + 1; j <= tr; j ++) {
				for(int i = hl; i <= hr; i ++) {
					int u = i + j * k;
					f[u] = max(f[u], f[u - 1]);
					if(u - k >= m) f[u] = max(f[u], f[u - k] + b[u - k]);
				}
			}
			for(auto opt : qq) {
				int l = get<0> (opt), r = get<1> (opt), id = get<2> (opt);
				if(l <= m && m <= r)
					ans[id] = max(ans[id], f[l] + f[r]);
			}
			for(int i = hl; i <= hr; i ++) {
				for(int j = tl; j <= tr; j ++) {
					f[i + j * k] = 0;
				}
			}
		}
		if(!ql.empty() && hl < mid) solve(hl, mid - 1, tl, tr, ql);
		if(!qr.empty() && hr > mid) solve(mid + 1, hr, tl, tr, qr);
	}
}
void Solve() {
	cin >> n >> k >> q;
	for(int i = 0; i < n; i ++)
		cin >> a[i];
	for(int i = n - 1; i >= 0; i --) {
		tt[i] = tt[i + 1] + a[i];
	}
	for(int i = 0; i <= n; i ++) {
		if(i + k <= n)
			b[i] = tt[i] - tt[i + k];
		else
			b[i] = -inf;
	}
	for(int i = 0; i <= n; i ++) {
		pos[i] = make_pair(i % k, i / k);
	}
	for(int i = 0; i < q; i ++) {
		int l, r;
		cin >> l >> r;
		Q.pb(l - 1, r, i);
	}
	solve(0, k - 1, 0, n / k, Q);
	for(int i = 0; i < q; i ++) {
		cout << ans[i] << '\n';
	}
}
```

---

## 作者：Usada_Pekora (赞：2)

题意：给定一个序列，每次可以选择连续 $k$ 个数，价值是他们的和，多次询问在区间 $[l,r]$ 这样选数的最大价值（可以有数不选）。

首先考虑只有一个询问怎么做，这是普及题，令 $f_{i}$ 表示前 $i$ 个的最大答案，那么 $f_{i}=\max\{f_{i-1},f_{i-k}+\operatorname{value}(i-k+1,i)\}$，那我们可以每次把区间里的数拿出来 dp，这样做是 $O(qn)$ 的。

然后原题是有 subtask 给 $k\leq 20$ 的，可以维护矩阵或者类似的东西跑过去，这个很简单不展开讲了。

稍微转化一下，发现我们是在图上跑最长路（不过要建一个虚拟源点 $0$ 开始跑，因为 $l$ 可以不选），连 $(x,x+1)$ 权值为 $0$，连 $(x,x+k)$ 权值为 $\operatorname{value}(x+1,x+k)$。

其实还是没有变简单，不过有一个巧妙的转化：考虑把这个东西变成网格图，$x$ 的位置是 $(\lfloor\dfrac{x}{k}\rfloor,x\bmod k)$，就得到一个大小 $\lceil\dfrac{n}{k}\rceil\times k$ 的网格图，网格图最长路可以像 ZJOI2016 旅行者一样去做，这里稍微提一下。

就是考虑分治，`solve(lx, rx, ly, ry, l, r)` 表示处理左上角 $(lx,ly)$，右下角 $(rx,ry)$ 的矩形时回答 $[l,r]$ 这些询问，我们考虑每次取矩形较长的一条边，然后取它的中线，以中线上每个点为起点跑一次最长路，容易发现如果询问的两个点分别位于中线两边，我们的答案一定是对的，因为必定过中线；如果在同一侧，有可能是错的，因为要先走到中线上某个点，再折到终点，那么我们对在中线同一侧的询问再次分治就好了。

设矩形大小是 $n$，那么复杂度 $T(n)=2T(\dfrac{n}{2})+pn$，其中 $p$ 是中线长度，也就是矩形的短边长度，不超过 $\sqrt n$，那这样复杂度就是 $O(n\sqrt n)$ 了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double lf;
template<typename T> inline bool chkmax(T &x, const T &y) {
	return (x < y) && (x = y, true);
}
template<typename T> inline bool chkmin(T &x, const T &y) {
	return (x > y) && (x = y, true);
}
template<typename F> inline bool equa(const F &x, const F &y) {
	return abs(x - y) < 1e-6;
}
const int N = 6e5 + 5;
const ll inf = -1e18;
int n, k, Q;
ll a[N], ans[N], dis[N], val[N], sum[N];
struct node {
	int x1, y1, x2, y2, id;
} q[N], _[N];
inline int id(int x, int y) {
	return x * k + y;
}
inline bool in_range(int x, int y, int lx, int rx, int ly, int ry) {
	return lx <= x && x <= rx && ly <= y && y <= ry;
}
inline void calc(int x, int y, int lx, int rx, int ly, int ry) {
	for (int i = lx; i <= rx; i++)
		for (int j = ly; j <= ry; j++)
			dis[id(i, j)] = inf;
	int s;
	dis[s = id(x, y)] = 0;
	for (int i = x; i >= lx; i--)
		for (int j = ry; j >= ly; j--) {
			int x = id(i, j);
			if (x > s)
				continue;
			if (in_range((x + 1) / k, (x + 1) % k, lx, rx, ly, ry))
				chkmax(dis[x], dis[x + 1]);
			if (in_range(i + 1, j, lx, rx, ly, ry))
				chkmax(dis[x], dis[x + k] + val[x + k]);
		}
	for (int i = x; i <= rx; i++)
		for (int j = ly; j <= ry; j++) {
			int x = id(i, j);
			if (x < s)
				continue;
			if (in_range((x + 1) / k, (x + 1) % k, lx, rx, ly, ry))
				chkmax(dis[x + 1], dis[x]);
			if (in_range(i + 1, j, lx, rx, ly, ry))
				chkmax(dis[x + k], dis[x] + val[x + k]);
		}
}
inline void solve(int l, int r, int lx, int rx, int ly, int ry) {
	if (l > r || lx > rx || ly > ry)
		return;
	if (rx - lx > ry - ly) {
		int mid = (lx + rx) >> 1;
		for (int i = ly; i <= ry; i++) {
			calc(mid, i, lx, rx, ly, ry);
			for (int j = l; j <= r; j++)
				if (id(q[j].x1, q[j].y1) <= id(mid, i) && id(q[j].x2, q[j].y2) >= id(mid, i))
					chkmax(ans[q[j].id], dis[id(q[j].x1, q[j].y1)] + dis[id(q[j].x2, q[j].y2)]);
		}
		for (int i = l; i <= r; i++)
			_[i] = q[i];
		int lp = l, rp = r;
		for (int i = l; i <= r; i++) {
			if (_[i].x1 < mid && _[i].x2 < mid)
				q[lp++] = _[i];
			if (_[i].x1 > mid && _[i].x2 > mid)
				q[rp--] = _[i];
		}
		solve(l, lp - 1, lx, mid - 1, ly, ry), solve(rp + 1, r, mid + 1, rx, ly, ry);
	} else {
		if (ly == 0 && ry == k - 1) {
			int mid = 0;
			for (int i = lx; i <= rx; i++) {
				calc(i, mid, lx, rx, ly, ry);
				for (int j = l; j <= r; j++)
					if (id(q[j].x1, q[j].y1) <= id(i, mid) && id(q[j].x2, q[j].y2) >= id(i, mid))
						chkmax(ans[q[j].id], dis[id(q[j].x1, q[j].y1)] + dis[id(q[j].x2, q[j].y2)]);
			}
		}
		int mid = (ly + ry) >> 1;
		for (int i = lx; i <= rx; i++) {
			calc(i, mid, lx, rx, ly, ry);
			for (int j = l; j <= r; j++)
				if (id(q[j].x1, q[j].y1) <= id(i, mid) && id(q[j].x2, q[j].y2) >= id(i, mid))
					chkmax(ans[q[j].id], dis[id(q[j].x1, q[j].y1)] + dis[id(q[j].x2, q[j].y2)]);
		}
		for (int i = l; i <= r; i++)
			_[i] = q[i];
		int lp = l, rp = r;
		for (int i = l; i <= r; i++) {
			if (_[i].y1 < mid && _[i].y2 < mid)
				q[lp++] = _[i];
			if (_[i].y1 > mid && _[i].y2 > mid)
				q[rp--] = _[i];
		}
		solve(l, lp - 1, lx, rx, ly, mid - 1), solve(rp + 1, r, lx, rx, mid + 1, ry);
	}
}
inline void slv() {
	cin >> n >> k >> Q;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++)
		sum[i] = sum[i - 1] + a[i];
	for (int i = k; i <= n; i++)
		val[i] = sum[i] - sum[i - k];
	for (int i = 1, l, r; i <= Q; i++) {
		cin >> l >> r, l--;
		q[i].x1 = l / k, q[i].y1 = l % k, q[i].x2 = r / k, q[i].y2 = r % k, q[i].id = i;
	}
	for (int i = 1; i <= Q; i++)
		ans[i] = 0;
	solve(1, Q, 0, n / k, 0, k - 1);
	for (int i = 1; i <= Q; i++) {
		cout << ans[i] << '\n';
	}
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	int T = 1;
	while (T--)
		slv();
	return 0;
}
```

---

## 作者：Nygglatho (赞：1)

7.11 的模拟赛，7.31 写挂，8.19 想到 hack，8.20 才 ac/fad

---

一个很 naive 的想法就是 dp。

设 $f_i$ 表示 $l\sim i$ 的最大值，则 $f_i=\max(f_{i-1},f_{i-k}+\sum\limits_{j=i-k+1}^ia_j)$。使用前缀和可以做到 $O(nq)$。

考虑优化。我们把它看成一张图，则对于每一个点 $i$，都可以向 $i+1$ 连一条边权为 $0$ 的边，代表不选择 $i+1$，向 $i+k$ 连接一条边权为 $\sum\limits_{j=i+1}^{i+k}a_j$，代表选择 $i+1\sim i+k$ 这 $k$ 个点。对于区间 $[l_i,r_i]$，答案即为从 $l_i\mathbf{-1}$ 到 $r_i$ 的最长路。**注意是 $l_i-1$，因为如果从第 $l_i$ 个点为起点，按这样建图是不会选择 $l_i$ 的。**

将询问离线下来，然后考虑如果 $l_i,r_i$ 如果一个在某一列左边一个在右边，则必定要经过这一列，行同理。

![](https://s21.ax1x.com/2024/08/20/pAPxGb6.png)

如图，对于样例，我们可以构造出这样一张图，考虑枚举在中间的列上的点，dp **强制经过这个点的最长路**，则我们可以将所有满足 $l_i\le 3$ 且 $r_i\ge 5$ 的询问一次性更新。

同理，也可以枚举在中间行的点，将一些询问一次性更新。需要注意的是，在枚举中间行的时候，会有一些特殊边，例如这里的 $(2,3)$ 和 $(5,6)$。特判即可。

由于既可以枚举行也可以枚举列，对于列，需要枚举点的数目为 $k$，对于行，则为 $\left\lceil\dfrac{n}{k}\right\rceil$，则一次时间复杂度为 $O(n\cdot\max(k,\left\lceil\dfrac{n}{k}\right\rceil))$。当 $k$ 取 $\sqrt n$ 时最劣，复杂度为 $O(n\sqrt n)$。

对于不经过中间行或者中间列的点，可以采用分治。每一次分治，需要考虑的点数减少一半，复杂度为 $T(n)=2T(\dfrac{n}{2})+O(n\sqrt n)$，根据 [主定理](https://oi-wiki.org/basic/complexity/#%E4%B8%BB%E5%AE%9A%E7%90%86-master-theorem) 可得总复杂度为 $O(n\sqrt n)$。

---

## 作者：qiuzx (赞：0)

记 $f_i$ 表示最后一个选择的区间的右端点在 $i$ 及之前的最大答案，则转移为 $f_i=\max(f_{i-1},f_{i-k}+s_i)$，其中 $s_i$ 为 $[i-k+1,i]$ 这个区间中所有数的和。这个转移看起来不是很好优化，但我们注意到这个转移有一个很好的形式，就是与一个 $i$ 有关的前驱位置是很少的，并且随着 $i$ 的变化它们的变化也是有规律的。对于这样的问题，不妨将 dp 转移画成一个 DAG 然后考察这个 DAG 具有怎样的性质。

将图画出来之后可以发现，如果将每 $k$ 个点排列成一列，那么转移就是一个网格图，除了有一些边连接前一列最下面的点和后一列最上面的点，那么我们需要计算的就是一个类似于网格图上的最长路问题。如果就是网格图，那么可以想到一个分治的做法，每次选择中间行或中间列，则任意两个跨越了这一行或列的点之间的路径必须经过上面的至少一个点。所以对上面的每个点求出到所有点的最短路，然后更新答案。最后对于没有跨越这一行或列的点对，递归下去将图分成两半分别解决。每次选择行与列中较大的一维进行切割，则复杂度为 $T(n)=2T(n/2)+O(n\sqrt n)$，即 $O(n\sqrt n)$。

现在还需要考虑到那些连接相邻两列的边。显然每一对点都可能被这样的边用来更新，但我们不能每次分治下去求最短路的时候都加上这些边，因为这些边有可能不在我们分治的范围内，导致出现一些没有被定义的路径。所以我们的选择是在第一次切割行的时候，将这些边也纳入考察的范围，即求出这些端点到所有点的最短路并用来更新答案。这样在接下来递归的时候由于已经考察过这些边了，所以之后不用再关心它们，就当成普通的网格图做即可。由于在切割列的时候不管是否使用这些边都一定会经过中间的那一列，所以列仍然是正常的。这样复杂度没有变化，因为这样的边的数目和列的数量是同阶的，所以在切割行的时候与本来就需要求的最短路复杂度是同阶的，仍然是 $O(n\sqrt n)$。

[代码](https://loj.ac/s/2171682)

---


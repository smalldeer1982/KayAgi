# [PA 2021] Areny

## 题目描述

给定一张有向图，每个点至少有一条出边，每个点只可能被染成黑色或白色。

你需要对于所有 $1 \leq k \leq n$ 求出以下问题的答案：

- 初始状态下所有点均为白色。
- 每一次操作，Alice 先选择一个黑点 $1 \leq u \leq k$，Bob 必须从 $u$ 出边指向的点中选择一个将其染黑。
- Alice 和 Bob 在这张图上玩游戏，定义一个有序二元组 $(A, B)$ 是好的，如果 $A \neq B$ 且 Alice 从只有 $A$ 点为黑色的状态开始，无论 Bob 如何操作，$B$ 点均可以变成黑色。
- 求好的有序二元组的个数。

## 说明/提示

对于 $100\%$ 的数据，$2 \leq n \leq 2 \times 10^5$，$1 \leq l \leq 5 \times 10^5$，$n \leq \sum l \leq 5 \times 10^5$，**不保证无重边，但保证无自环**。

## 样例 #1

### 输入

```
9
2 2 3
1 1
1 2
1 5
3 5 8 9
1 5
2 6 4
2 5 9
3 5 8 5```

### 输出

```
0 1 4 4 5 6 7 7 7```

# 题解

## 作者：lcjqwq (赞：5)

我们考虑如何处理一对询问 $(A,B)$。我们把过程看作是先把 $B$ 点删掉，如果一个点此时没有出度，那我们就继续把这个点也给删掉。一直这样进行下去。如果最后 $A$ 被删掉了，那么 $(A,B)$ 就能成为答案。

对于当前选择的根，如果删掉点 $u$ 后会导致 $v$ 点也被删除，我们称其为 $u$ 支配点 $v$。我们可以构建出支配树：考虑一个点的所有出度，他们在支配树上的 LCA 就是它的父亲。

需要注意的是，根可能支配自己。根的所有出度如果都会被自己删掉那么他们在支配树上的 LCA 就会支配根。所以实际上，我们最后得到的关系是一个支配基环树。对于环上的每个点，我们如果删掉他就会让这个基环树被删掉；对于不在环上的点，删掉它会使得子树里的点被删掉。

可以发现，我们可以把一个图变成基环树森林再统计答案。考虑按 $k$ 从 $1$ 枚举到 $n$ 动态的维护基环树森林的形态。最开始的图是 $n$ 个自环，每次我们枚举到点 $u$ 我们就把这个自环去掉，他的出边都加到图中。

可以发现 $u$ 之前一定是某颗树的根。

- 如果当前这个点 $u$ 的出度都在自己这颗树里，把他们的 LCA 往 $u$ 连一条边就好了。
- 如果所有出度都在另一颗树中，同样求出 LCA，我们现在就是是把 $u$ 的子树接到 LCA 下面。
- 如果出度分散在不同的联通块，此时 $u$ 并不任何点支配。但是随着合并的进行，可能在某一刻，$u$ 的出边全都在某一个联通块里了。所以我们在加入 $u$ 的时候往每个联通块里扔一个标记，每次合并两个联通块的时候把两个联通块都有的标记的计数器减一，减到 $0$ 就需要把 $u$ 重新拿出来，把出度的 LCA 和它连边。我们可以考虑用线段树合并维护这个过程就可以做到单 log。每次在 merge 两个叶子的时候处理一下计数器。开一个队列记录当前需要考虑的 $u$，每次拿队首出来做。计数器变成 $0$ 就 push 进去。

考虑怎么算答案，即对于每个时刻的支配森林求出有多少个点对 $(u,v)$ 满足 $u$ 能到达 $v$。

答案就是每个点的 siz 和也就是 dep 和，我们要维护的操作是把一个树根接到某个点的儿子处。考虑在 LCT 上维护 Link，求某个点的 dep，求 LCA，求联通块 siz 的操作就可以做了。

如果过程中出现了一个新的基环树，需要特殊处理一下。由于每个联通块只会变成一次基环树，我们可以直接暴力的通过某些手段 $O(siz)$ 的处理这颗基环树的答案。

但是要注意的是，一颗基环树虽然不会再往外连出出度，但是里面的点之后有可能作为其他的点的出度。为了方便后续的答案计算，需要把基环树上的环点的 dep 人为的修改一下。具体的，把根的 dep 改为环长，其他环点的 dep 改成 $0$ 就好啦。

以及，每颗树的树根有可能编号大于当前枚举的 $k$。可以最开始每个点的 dep 设成 $0$，加入这个点的时候加上对答案的贡献，再把 dep 改成 $1$，这样算出来的 dep 才是对的。

总体的时间复杂度为 $O(m \log n)$。可以发现这颗 LCT 由于 Link 操作都是把一个树根接到另一个儿子上所以只需要 access 而不需要维护懒标记进行 makeroot，常数是很美丽的。

---

另一个做法，我们可以先直接求出 $k=n$ 时的基环森林。再考虑在最后的状态上统计答案。

首先应该怎么求出 $k=n$ 时的状态呢？如果我们现在有一个根，我们可以直接在图上模拟一遍求 LCA 加边的过程，用倍增维护就好。但是我们不能暴力的枚举一个根然后做一遍这样的事情。因为一个点为根的支配树可能是另一个点为根的支配树的子树。所以问题就变为了找到那些最厉害的根。

我们考虑不断的缩图。考虑一个点 $u$，如果他只有一条出边连向 $v$，那么我们就可以把 $u$ 扔了，因为 $v$ 的支配树一定包含他的支配树。此时我们把 $u,v$ 缩成一个点，并且把之前连向 $u$ 的边全部接到 $v$ 上。重复这个过程，直到图中每个点的出度都 $\ge 2$。此时图中的每个点都可以成为一个根/一个基环树环里的某个点。

维护缩图的过程可以使用线段树合并，可以发现和第一个做法中维护的信息大同小异，每个联通块的根处维护有那些点连向他，每次合并的时候相当于把两者都有的点的出度减一，每次找到出度变为 $1$ 的那些点执行合并操作即可。

之后我们考虑怎么求出每个 $k$ 的答案。首先可以发现每个时刻的图都是最后的图的子图，并且每条边都是在 $k$ 逐渐增大到某个值的时候出现。这个值可以在求出基环树的过程中维护出来。具体来说，考虑构建基环树的过程中考虑到了当前点 $u$ 以及他的出度的 LCA，$u$ 连向 LCA 的这条边就是 $u$ 到 LCA 上的每一条链上的所有边的权值的 max。于是我们在倍增的时候多维护一个链上权值的 max 即可。

之后考虑统计答案。我们拎一个环上的点当根搞一颗外向树。这个图会存在至多一条返祖边。我们把答案分为直上直下和必须经过返祖边的两部分进行统计。

- 对于直上直下的部分，可以并查集维护 siz 和最浅的那个点，很好做。
- 对于经过返祖边的部分，我们可以巧妙地把最开始钦定的根设置成使得那个返祖边是环上边权最大的边的那个点。这样我们就能保证在加入返祖边的时候，整个环就完整的形成了。
  + 加入返祖边之前只有直上直下的贡献。
  + 加入返祖边时，由于只会加入一次，我们可以暴力的 DFS 一遍算贡献。
  + 加入返祖边后，可以发现如果一对 $(u,v)$ 满足从 $u$ 走到 $v$ 必然要经过返祖边那么一定是形如 $u$ 处于 $v$ 在环上的投影以下一直到返祖边端点的那一条链上。于是也可以很方便通过并查集的 siz 信息计算贡献。

最后整体的时间复杂度依然是 $O(m \log n)$，来源于线段树合并以及倍增求基环树。

代码(LCT做法)：https://www.luogu.com.cn/paste/21uo8ogi

---

## 作者：Rainbow_qwq (赞：2)

问题可以转化为：

> 有一个棋子在点 A，每次如果棋子在 $\ge k$ 的位置则游戏停止，否则 Bob 会选择一个出边走出去。问从 A 开始，有多少个点 B 使得无论 Bob 如何操作，都有一个中间状态达到 B。

称从 A 开始怎么操作都能到达 B 为 $a\leadsto b$.

做一些观察：

- 如果 $u$ 的所有出边 $v$ 都有 $v\leadsto w$，那么 $u\leadsto w$.
- 如果 $u\leadsto v,v\leadsto w$，那么 $u\leadsto w$.
- 如果 $u\leadsto v_1,u\leadsto v_2$，那么 $v_1\leadsto v_2$ 与 $v_2\leadsto v_1$ 中至少满足一个。

对于 $k=n$ 的情况，可以设计如下算法：

发现题目要求一个类似支配树的东西，考虑建若干棵树，使得每个点的父亲是他所有出边的 LCA。进一步考虑这个做法：

把所有点分成若干个连通块，初始有 $n$ 个连通块。

下面的算法会说明，每个连通块是一个内向树或基环内向树，并且若 $v$ 为 $u$ 的祖先或 $v$ 在 $u$ 连通块的环内，则 $u\leadsto v$。

每次找到一个出边全在同一个连通块内（并且没执行过“连边”操作）的点，执行“连边”操作：

如果出边指向与 $u$ 不同的连通块，那就连边、合并连通块。$u$ 的所有出边一定在同一个连通块，求出他们在内向树/基环内向树上的 $\text{LCA}$（显然 $\text{LCA}$ 的可达点就是 $u$ 的可达点），将 $u$ 向 $\text{LCA}$ 连边。连完后仍为内向树/基环内向树。

如果出边指向同一个连通块，说明内向树变成了基环内向树，进行缩环。

最后统计每个点能到达的点个数。

代码实现的话，把每个连通块染一个颜色，对每个点存储一个连出去的颜色集合，若颜色集合大小为 $1$ 则可以对这个点进行“连边”操作。加边时启发式合并两个连通块的集合，并修改颜色集合。

----

对于 $k<n$ 的情况，还要加上的限制就是编号 $>k$ 的点禁止进行“连边”操作。

那么可以 $k$ 从小到大处理。每次 check 一下 $k$ 这个点能否进行连边操作，能连就操作下去。

由于要动态维护连边，可以用 LCT 维护。

对于缩环操作，可以发现缩的是到根的一条链，可以链上根节点的权值赋值为 $len$，下面的每个点权值赋值为 $0$。

答案就是每个点到根节点的路径的点权和。加边时可以快速维护答案，缩环时可以对每个点重新计算。

[代码实现](https://loj.ac/s/1812277)

---

## 作者：Hasinon (赞：2)

首先题意可以转化为从 $A$ 点开始的任意一条路径都经过 $B$。

必要性：如果有一条路径不经过 $B$，那么 Bob 就沿着这条路径选就是了。

充分性：从 $A$ 点开始，Bob 选择任意一个出边指向的点 $x$，根据定义有 $x$ 点开始的任意一条路径都经过 $B$。显然 Bob 在走到 $B$ 点前没法选择之前走过的点，不然成环且这个环内不包括 $B$，不符合定义，那么最后一定能走到 $B$。

上面这条性质多少沾点支配树了（感觉是只会支配树），但是支配树是求 $A$ 点到 $C$ 点的任意一条路径都经过 $B$ 这样子。需要进一步观察性质。

如果 $(u,v)$ 和 $(u,v')$ 都合法，显然 $(v,v')$ 和 $(v',v)$ 至少一个合法，且关系具有传递性。所以我们可以拉出几个极大子图 $G$，满足子图内存在 $root$，使得 $\forall i \in G$ 有 $(i,root)$ 合法。于是若 $(x,y)$ 的两点不在同一子图，就不可能合法，问题独立开来了，而且满足 $\forall i \in G$，任意一条路径都经过 $root$，我们把 $root$ 的出边删掉之后就是一个 DAG，可以建支配树维护了。

关于拉极大子图，可以枚举每个点当 $root$，反向拓补出 $S$ 满足 $x\in S$，$(x,root)$ 合法。显然 $S_x,S_y$ 要不不交要不包含，对于已经被扔进 $S$ 的点不去拓补，保证总拓补时间复杂度是线性的。但是如果一个已经被扔进 $S_x$ 的点在 $root=y$ 的时候应该被拓补，那么最后把 $S_x$ 和 $S_y$ 合并，显然可能对于一个 $y$ 可能有多次合并，所以要启发式合并的。

先考虑 $k=n$ 的情况，考虑定 $x$ 计算有多少个 $y$ 满足 $(x,y)$ 合法，首先是 $x$ 在支配树上的祖先，以及 $root$ 的出边连向的所有点的 lca 的祖先（包括 lca）。

扩展到 $k \in [1,n]$ 上，就是预处理每个 $x$ 到自己的最近支配点 $y$ 可能经过的点的编号最大值 $w$。对 $k$ 从大到小做扫描线，如果 $w_{x}>k$ 就把边断掉。关于维护的话就是拉 dfn 线段树维护 $f(x)$ 表示 $x$ 在支配树上的祖先（如果 $(x,y)$ 之间有断边就不管）。单点查全局查区间减即可。

需要注意若 $x$ 与 $root$ 仍然相连，那么 $x$ 的贡献还需要加上“$root$ 的出边连向的所有点的 lca 的祖先”（当然也考虑断边）。特判一下就好了。

---

## 作者：nullqtr_pwp (赞：0)

枚举 $B$ 随便记录一下路径最值有一个 $\mathcal O(n^2)$ 的做法。大概就是，拓扑排序，每次从 $B$ 开始不断删除无出度的节点。转化一下，保留图上所有标号 $\leq k$ 的点，题意可以变为 $A$ 开始的任意一条路径均经过 $B$。那么这基本就是一个支配树的题。考虑先做 $k=n$。观察一下合法的关系 $(A,B)$ 所具有的性质。传递性是显然的，即 $(A,B),(B,C)\Rightarrow (A,C)$，但还有一个重要性质是，我们仿照支配树的性质 $2$ 可以设计出：若 $A\Rightarrow B,A\Rightarrow C$ 则有 $B\Rightarrow C$ 或者 $C\Rightarrow B$ 成立。那么我们可以构建支配树状物，对于 $u$ 选取最近的支配点来建树。注意这棵树事实上是一个基环树。

先考虑求 $k=n$ 的答案。考虑支配树的根 $root$，也就是说考虑最开始删掉点 $root$。我们令 $S_{root}$ 为 $root$ 删除掉的点集，我们希望刻画 $S_*$ 之间的关系。模仿 P8276 的套路，对于一种朴素情况，$u$ 的出边有且仅有 $v$，那么考虑直接删掉 $v$ 会导致 $u$ 被删除，$u$ 就是没有用的，那么令 $u$ 的所有入边改接到 $v$ 并叠合重边，注意自环需要保留。那么重复这个过程直到最终任意点出度 $\ge 2$，此时删除任意一个点都不会导致进一步的删除。此时图中的每个点都可以成为一个根或一个支配基环树环里的某个点。那么一个点代表的 $S$ 一定是极大的，且两两不交，是全集的一种划分。那么这些点相当于支配树的根的点集。

观察一下支配树是什么，考虑找出 $u$ 的支配点，一个点 $u$ 的支配点就是所有出度在支配树上当前的 $\text{lca}$ 为 $dom(u)$。那么就将 $u$ 挂在 $dom(u)$ 之下。注意根可能支配自己，也有可能是一个形成环。此时对应的是，删除掉自己之后不断删，把环删干净了，最终把整个支配树都删了。对于一个不在环上的，只能删除其子树。也就是说一个点的支配点被删之后由其定义他自身就会被删除。用上文操作把 $k=n$ 的基环森林给求出来，统计一下信息就可以做 $k=n$。形式化地说，求出基环森林上可达点对 $(x,y)$ 的数量，即为 $k=n$ 的答案。维护缩图的过程可以使用线段树合并，用队列维护删掉的点。

由部分分提示，先建立 $k=n$ 的基环森林，一条边出现后就不会消失，在建树过程维护一下出现时刻。那么考虑刻画为基环树的 $\text{dfs}$ 生成树加上有且仅有的一条返祖边。此时我们可以不妨设根是返祖边的端点，而返祖边可以设置为出现时刻最大的点。对于当前已经加入的点和边，并查集维护大小和最浅的点可以支持计算不经过返祖边的答案。时间复杂度 $\mathcal O((n+m)\log n)$。

[提交记录](https://loj.ac/s/2229277)

---

## 作者：strapplE (赞：0)

我靠，遇到了 CTSC+ 恶心题。必须写篇题解留个念 + 警示后人了。本篇题解为 [这位大佬](https://www.luogu.com.cn/article/hzw00633) 做法中的算法二的补充（用自己的话重新阐述了一遍），且给出了一种可能的理解方式。

首先有一个暴力，就是枚举一个点 $B$，做拓扑排序（也就是一直删没出度的点和它的入边），不过只删 $\leq k$ 的点，判 $A$ 是否被删除。这样的复杂度是 $O(n^2)$。

然后观察一下这个删点的过程，你会发现如下两个结论：

- 如果 $u$ 能删 $v$，$v$ 能删 $w$，则 $u$ 能删 $w$。（显然）

- 如果 $u$ 能删 $w$，$v$ 能删 $w$，则要么 $u$ 能删 $v$，要么 $v$ 能删 $u$。（考虑逆推，一定存在一个时刻有个点逆推不了了，那就是说明 $u$ 和 $v$ 有一个先结束了）

其实有了这两条性质就可以得到一个结论：可以把原图缩成一个基环外向树，使得 $(u,v)$ 合法当且仅当 $u$ 可以通过其中一些有向边达到 $v$。

注意到环点是可以到达这个连通块内的任何一个点，也就是说它是最大的，删掉它后，任何一个点都可以被激活。只需要求出这种点，就可以复原了（具体做法后边说）。

于是我们想出了本题的第一步：

维护一个小根堆，表示出度可能是 $1$ 的点。每次找到堆顶 $u$，通过并查集找到它唯一连向的点 $v$。因为删掉 $v$ 后 $u$ 也会被删掉，因此 $v$ 比 $u$ 优，就可以把 $u$ 合并到 $v$ 上。具体地，$u$ 的所有入点的这条出边改接到 $v$ 上。遇到重边就删，但不能删自环。合并方式可以用线段树合并或者启发式合并都行，不过前者空间一定要开够，最好像我一样，开 $2\times 10^7$。

缩完以后，就剩下了一些没有出度的点和一些出度 $\geq 2$ 的点（其实每个点代表一个点集）。注意到此时，删任何点都不会导致其它点被删，所以就独立开来了。下面我们只取 consider 其中一个点，或者说，它所代表的点集。

考虑一个由 $u$ 统治的点集，那么删掉 $u$ 及其相连的边后，图剩余的部分一定不含环（否则 $u$ 就无法统治它了），也就是说，这剩下了一个 DAG。那么我们就可以仿照[支配树](http://oi-wiki.com/graph/dominator-tree/#%E8%BD%AC%E5%8C%96%E4%B8%BA-dag)，建立一棵树，拓扑排序的顺序加点，其加到其的出度的所有点在树上的 LCA 的儿子中。这样得到了一棵树，然后把 $u$ 也以此法连一条返祖边加进来，就得到了本题的基环外向树森林。这样，就有了一个 $O(n\log n)$ 解决 $k=n$ 时答案的做法。

再考虑 $k$ 为其它数时。不知道为啥，可以发现，此时它的缩图是 $k=n$ 时的缩图的子图，区别只是有些边消失了。$k$ 从小往大扫，这提示我们去求每条边的出现时刻。

有一个神奇的事情：

把 $u$ 设为环上的最大点。以 $u$ 为根构建这棵树（不考虑返祖边），则 $x$ 与它父亲 $y$ 这条边的出现时刻 $time_{(x,y)}$ 为：

$$\max(x,y,\max_{v\in out_x}\max_{e\in path(u,y)}time_{e})$$

看起来很显然，就是一个提前要求，但是实际上你发现把 $u$ 设为环上其它点，它是错的！！！

反例：

![](https://cdn.luogu.com.cn/upload/image_hosting/jrkvxfkt.png)

如果我们选择了 $2$ 号点作为根，它对应的基环树是：

![](https://cdn.luogu.com.cn/upload/image_hosting/mk7jrn6v.png)

则 $2\rightarrow 3$ 那条边的出现时间是 $8$。这样 $7\rightarrow 3$ 的可通过时间一定也是 $8$，就错了。因为只要 $k=7$，$7$ 就能到达 $3$ 了。所以根节点我们一定要选择 $8$（别问为啥，问就是卡了好久，血泪教训！）。大概证明看官方题解吧。这部分可以直接采用倍增求出。

接下来，问题就完全转化成了下面这个：

有一个基环树，每条边在一个时刻出现。对每个时刻，求可达点对个数。

第一点：如果基环树改成树的话，那么每次加边直接用一个带权并查集维护深度和子树大小，加上对应的乘积即可。

第二点：换成环。首先，找到环上出现时间最大（当然如果有多个，我们要钦定顺序）的边连的和（后面那个）点，将其设为根。那么，这条返祖边加上的时候，其它环边都已经加上了。

第三点：那么我们只需一次暴力重构就解决了这次操作。后面的其它加操作，把对应在环上的投影位置下面的点的个数加进来就好了。

这部分都可以用并查集 + dfs 实现。

因此总复杂度是 $O(n\log n)$，瓶颈在最开始的缩点部分！！！具体证明好难，咕了。[大哭]

代码可以在[这里](https://qoj.ac/submission/650345)参考，虽然比他们 LCT 慢的多得多。[流泪]

---


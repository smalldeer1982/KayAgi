# [PA 2018] Ryki

## 题目描述

**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Ryki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/ryk/)**

Berlandia 是一个由方格组成的无限大棋盘。行从下到上用递增的整数编号，列从左到右用递增的整数编号。令 $(r,c)$ 表示第 $r$ 行第 $c$ 列的方格。如果两个不同方格至少有一个角接触，我们就称这两个格子相邻。这意味着格子是八连通的。

两个格子 $(R_A,C_A)$ 与 $(R_B,C_B)$ 之间的距离是欧几里得距离，也就是：
$$
\sqrt{(R_A-R_B)^2+(C_A-C_B)^2}
$$
Berlandia 地区居住着 $n$ 只熊。第 $i$ 只熊居住在方格 $(r_i,c_i)$ 处。同一方格中可以居住多只熊。

熊可以单独生活，但是有时也会相互靠近。当一只熊吼叫时，其他方格中所有的熊会立即移动到相邻的方格中离吼叫的熊最近的方格。可以证明有且仅有一个这样的方格（不会出现并列情况）。与吼叫的熊在同一方格的熊不会移动位置。

例如，考虑一对熊，一只在方格 $(2,1)$，另一只在方格 $(4,8)$。方格 $(2,1)$ 中的熊吼叫会让另一只熊移向方格 $(3,7)$ ，这两只熊最后相距 $\sqrt{(3-2)^2+(7-1)^2}=\sqrt{37}$。

这些熊会按第一只，第二只，……，最后一只的顺序依次吼叫。除了一只叫 Limak 的熊，他太冷了以至于吼不出来，并且他也不能离开他所在的方格，可怜的 Limak。

但你不知道 Limak 是哪只熊，对于 $1$ 到 $n$ 的每一个 $k$，如果第 $k$ 只熊是 Limak，请找出所有熊的最终位置。对于每种可能，输出所有熊的横纵坐标乘积之和就可以了。也就是说，假设在 $n-1$ 次吼叫后，第 $i$ 只熊在 $(r_i',c_i')$，则输出：
$$
\sum_{i=1}^n r_i'c_i'
$$


## 说明/提示

#### 样例 1 解释

下图展示了 $k=2$ 的情况，即熊的吼叫顺序为 $1,3,4$。红色圆圈表示吼叫的熊。最后乘积的和为 $2 \cdot 4 + 2 \cdot 1 + 2 \cdot 4 + 2 \cdot 3 = 24$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ri72cgjf.png)

------------

#### 数据范围

**本题采用捆绑测试**

保证每组子任务中下述三种情况至少出现一种：

- $n\le 10^5$
- 对于所有 $i$ 都有 $c_i=1$
- 时间限制为 $8$ 秒

注：由于未公布每个测试点的详细时间限制，因此本题所有测试点的时间限制均为 $4$ 秒。

## 样例 #1

### 输入

```
4
3 5
2 1
1 4
2 1```

### 输出

```
27
24
25
35```

# 题解

## 作者：lalaouye (赞：4)

下文称每个吼不出来的熊叫特殊熊。

首先独立变成两个一维问题，然后放在数轴上做，自然地，我们会考虑这个过程的性质，不难观察到以下几点：

1. 相对位置不变。
2. 只有合并在一起的点才不会对对方产生影响，否则必定会产生相对位置带来的影响。
3. 叫一次对于两侧点之间的距离不会改变，除了自己与两侧点和两侧点之间。
4. 合并的点在原顺序上对应着一个区间。

这些都是必须意识到且注意到的性质，但是单次维护这个东西总是要 $\mathcal{O}(n\log n)$ 的，然而每次只删掉一个点，我们不妨考虑其与原本每只熊都叫一次的答案关系。从感觉上变化是不大的。首先考虑到少叫一次相当于有些点少移动了一格子，但是有可能就是因为少叫了一次导致一只熊可以被另一侧多拉 $1$ 到 $2$ 次，总之每只熊顶多只会产生 $1$ 的距离变化量。

有经验的你不难猜到，变化量为 $-1,0,1$ 的熊在相对位置上构成了三个区间，这是不难证明的，感受一下发现越靠中间越可能受到阻挡，越靠左或越靠右的就越能因为多叫这一次而移动，那么我们只需要对于每只熊处理出属于它的 $[l_i,r_i]$，表示这个区间内的熊的位置不变，于是我们就能二维数点了。

然后我们又能发现一个比较显然的结论，一只熊因为特殊熊多吼一次而受到额外阻挡时，必然已经跟特殊的那只熊合并了。

下面我们考虑对于每只熊处理出它的 $[l_i,r_i]$，注意了，以下讨论的情况都是钦定第 $i$ 只熊吼了，在它吼的情况找出 $[l_i,r_i]$。

这个东西很抽象，必须要从过程去找到它，因为它跟过程是紧密相关的。那么我们考虑当第 $i$ 只熊开始吼的时候，吼了跟没吼都一样的那些熊显然是之前已经跟 $i$ 合并在一起的熊。而对于之后的一只熊 $j$，如果它在吼之前不与 $i$ 合并在一起，显然是不会影响 $[l_i,r_i]$ 的，根据之前的结论可以发现，他们不论怎样都会一起移动一格。也不会有新增加的，因为新增加的显然得与 $i$ 合并在一起，而当前 $j$ 都没跟 $i$ 合并在一起，又怎么去影响别人呢？

下文称第 $i$ 只熊为相对位置意义下的第 $i$ 只，至于说原顺序的我们称其为编号第 $i$ 只熊。

如果 $j$ 跟 $i$ 合并在了一起就需要好好考虑了，设当前 $[L,R]$ 里的熊合并在了一起，满足 $i,j\in[L,R]$，那么首先显然 $[l_i,r_i]\subseteq[L,R]$，我们考虑 $[l_i,r_i]$ 的意义，对于第 $r_i+1$ 这只熊，$i$ 操作了的情况下他们合并在了一起，而若没操作则意味着 $r_i$ 并没有与 $r_i+1$ 合并在了一起！此时的 $r_i+1$ 在没吼的情况下的坐标是要加一的，于是当 $j>r_i$ 时，$[l_i,r_i]$ 都将移动，而 $[L,l_i-1]$ 这些熊回到了原位。若 $j<l_i$ 同理，而若 $j\in[l_i,r_i]$ 时，当前 $[L,R]$ 的熊都将回到原位。

于是我们可以 $\mathcal{O}(n^2)$ 完成这道题了。考虑这个东西是能一起做的，这也是我们优化它的方向。我们维护合并到了一起的区间，称他们为 A 区间，但是除了公用 A 区间以外看起来各个 $[l_i,r_i]$ 之间没有什么关系，貌似没办法一起做。

但是我们注意到一次操作后，被改变的所有 $[l_i,r_i]$ 区间都满足要么 $l_i=L$，要么 $r_i=R$，不难证明任意时刻我们都可以用若干个极长不交的区间表示出这些区间，里面嵌套了一些要么 $l_i=L$ 要么 $r_i=R$ 的区间，我们记所有这样的区间为 B 区间，我们需要记录三个集合信息 $S_L,S_R,id$，分别表示左端点在 $L$ 的区间集合，右端点在 $R$ 的区间集合，注意到我们可以将相同区间放到一个并查集中，集合中的元素是个二元组，分别表示它的另一个端点和它的编号，因为它代表的是一个等价类，然而对于刚好是该区间的集合我们会额外分到 $id$，$id$ 也只用放这些区间等价类并查集中的根。

然后我们每次操作会找到 $[L,R]$ 中所有 B 区间，并把他们放到自己新建的 B 区间中。我们还是得讨论位置，当前 B 区间为 $[L',R']$，那么若 $R'<j$ 的话，直接将 $(L'-1,id')$ 丢进 $S_L$，然后将 $S_{L'}$ 也丢尽 $S_L$，对于 $S_{R'}$ 我们需要将每个二元组的第一个元减一再丢进去，对于 $j<L'$ 类似的讨论，而对于 $j\in[L',R']$ 的情况，首先将 $id'$ 进入新的 $id$，然后对于 $S_{L'}$ 中的信息如果包含了 $j$ 也会并入 $id$，否则我们会把他们搞在 $[L,L'-1]$ 中，$S_{R'}$ 类似，注意到直接暴力枚举复杂度均摊是对的，因为我们顶多会新增 $3$ 个本质不同的信息，所以均摊下来对完了。

特别的我们发现有一种操作需要给每个信息的第一个元减一，但是我们可以利用一个小 trick，把区间变为左闭右开区间，这样我们便无需额外减一了！因为注意到我们涉及到整体左端点右端点互换都只有一个规则，直接变成左闭右开即可。

利用启发式合并可以做到 $\mathcal{O}(n\log n)$，但是实际上可以更优秀，我们注意到对集合的操作相当于把它分到两个集合中并删除，或者整体合并，这个东西可以链表直接做，于是可以线性完成这个过程。

考虑算出答案，由于答案式子是个没什么道理的乘积式，不妨直接写出答案式子：

$$\sum_j (x_j-[xrk_j<lx_i]+[xrk_j>rx_i])(y_j-[yrk_j<ly_i]+[yrk_j>ry_i])$$

$rk$ 代表每只熊在数轴上的相对位置排名。这个拆开就是二维数点了。时间复杂度 $\mathcal{O}(n\log n)$，考验了选手处理复杂信息的能力，以及一些整体考虑，并查集和均摊的思想，还有感受结论的能力，~~还有把区间变成左闭右开区间的奇技淫巧~~，总之是个难题！

代码：


```cpp
#include <bits/stdc++.h>
#define int long long
#define rep(i, l, r) for (int i (l); i <= r; ++ i)
#define rrp(i, l, r) for (int i (r); i >= l; -- i)
#define eb emplace_back
using namespace std;
#define pii pair <int, int>
#define inf 1000000000
#define ls (p << 1)
#define rs (ls | 1)
constexpr int N = 5e5 + 5, M = 1e5, P = 1e9 + 7;
typedef long long ll;
typedef unsigned long long ull;
inline int rd () {
  int x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch)) {
    if (ch == '-') f = -1;
    ch = getchar ();
  }
  while (isdigit (ch)) {
    x = (x << 1) + (x << 3) + (ch ^ 48);
    ch = getchar ();
  }
  return x * f;
}
int qpow (int x, int y, int p = P) {
  int ret (1);
  for (; y; y >>= 1, x = x * x % p) if (y & 1) ret = ret * x % p;
  return ret;
}
int X[N], Y[N], n;
int xpos[N], ypos[N], xrk[N], yrk[N], lx[N], ly[N], rx[N], ry[N];
int px[N], py[N];
int dis[N];
int pre[N], nxt[N], id[N];
class DSU {
  public:
  int fa[N];
  void init () {
    rep (i, 1, n) fa[i] = i;
  }
  int find (int x) {
    return x == fa[x] ? x : fa[x] = find (fa[x]);
  }
  int merge (int x, int y) {
    if (! x || ! y) return x | y;
    x = find (x), y = find (y);
    if (x ^ y) {
      fa[x] = y; return y;
    }
    return x;
  }
} dsu, seq;
int net[N << 2], tot;
pii Mes[N << 2];
class Link {
  public: 
  int hd, tl;
  void merge (Link x) {
    if (! hd) {
      hd = x.hd, tl = x.tl;
      return ;
    }
    if (! x.hd) return ;
    net[tl] = x.hd;
    tl = x.tl;
  }
  void lnk (pii pa) {
    int x = ++ tot;
    Mes[x] = pa;
    if (! tl) {
      hd = tl = x;
      return ;
    }
    net[tl] = x;
    tl = x;
  }
} L[N], R[N];
int unite (Link x, int u) {
  for (int i (x.hd); i; i = net[i]) {
    u = dsu.merge (Mes[i].second, u);
  } return u;
}
void solve (int * x, int * p, int * rk, int * pos, int * l, int * r) {
  rep (i, 1, tot) net[i] = 0;
  dsu.init (), seq.init ();
  tot = 0;
  rep (i, 1, n) p[i] = i, l[i] = r[i] = -1;
  sort (p + 1, p + n + 1, [&] (int i, int j) { return x[i] < x[j]; });
  rep (i, 2, n) dis[i] = x[p[i]] - x[p[i - 1]]; dis[1] += n, dis[n + 1] = n + 1;
  rep (i, 1, n) rk[p[i]] = i, pre[i] = i - 1, nxt[i] = i + 1, id[i] = 0, L[i].hd = L[i].tl = 0, R[i].hd = R[i].tl = 0; nxt[0] = 1, pre[n + 1] = n;
  rep (i, 1, n) if (! dis[i]) seq.merge (i, i - 1);
  rep (T, 1, n) {
    int p = rk[T], s = seq.find (p), i; id[0] = p;
    for (i = s; i == s || ! dis[i]; i = nxt[i]) {
      nxt[s] = nxt[i], pre[nxt[i]] = s;
      if (! id[i]) continue;
      if (p >= nxt[i]) {
        L[0].merge (R[i]);
        L[0].lnk (pii (i, unite (L[i], id[i])));
      } else if (p < i) {
        R[0].merge (L[i]);
        R[0].lnk (pii (nxt[i], unite (R[i], id[i])));
      } else {
        dsu.merge (id[i], id[0]);
        int u (0);
        for (int j (L[i].hd); j; j = net[j]) {
          if (p >= Mes[j].first) u = dsu.merge (Mes[j].second, u);
          else id[0] = dsu.merge (Mes[j].second, id[0]);
        }
        L[0].lnk (pii (i, u));
        u = 0;
        for (int j (R[i].hd); j; j = net[j]) {
          if (p < Mes[j].first) u = dsu.merge (Mes[j].second, u);
          else id[0] = dsu.merge (Mes[j].second, id[0]);
        }
        R[0].lnk (pii (nxt[i], u));
      }
    }
    L[s] = L[0], R[s] = R[0], id[s] = id[0];
    L[0].hd = L[0].tl = R[0].hd = R[0].tl = id[0] = 0;
    if (! -- dis[s]) seq.merge (s, pre[s]);
    if (! -- dis[nxt[s]]) seq.merge (nxt[s], s);
    if (s)
    ++ pos[1],
    -- pos[s];
    -- pos[nxt[s]];
  }
  rep (i, 1, n) pos[i] += pos[i - 1];
  rep (i, 1, n) pos[i] += x[p[i]];
  for (int i (1); i <= n; i = nxt[i]) {
    l[id[i]] = i, r[id[i]] = nxt[i];
    for (int j (L[i].hd); j; j = net[j]) {
      l[Mes[j].second] = i, r[Mes[j].second] = Mes[j].first;
    }
    for (int j (R[i].hd); j; j = net[j]) {
      l[Mes[j].second] = Mes[j].first, r[Mes[j].second] = nxt[i];
    }
  }
  rep (i, 1, n) l[i] = l[dsu.find (i)], r[i] = r[dsu.find (i)];
}
int ans[N];
vector <pii> vec[N], vc[N];
int c[N];
int lb (int x) {
  return x & -x;
}
void upd (int x) {
  for (; x; x -= lb (x)) ++ c[x];
}
int qry (int x) {
  int ret (0);
  for (; x <= n + 1; x += lb (x)) {
    ret += c[x];
  }
  return ret;
}
int sum[N];
int32_t main () {
  // freopen ("1.in", "r", stdin);
  // freopen ("1.out", "w", stdout);
  n = rd ();
  rep (i, 1, n) X[i] = rd (), Y[i] = rd ();
  solve (X, px, xrk, xpos, lx, rx);
  solve (Y, py, yrk, ypos, ly, ry);
  int s (0);
  rep (i, 1, n) (s += 1ll * (xpos[xrk[i]] - 1) * (ypos[yrk[i]] - 1));
  rep (i, 1, n)
    vec[lx[xrk[i]]].eb (pii (ly[yrk[i]], i)),
    vec[lx[xrk[i]]].eb (pii (ry[yrk[i]], i)),
    vec[rx[xrk[i]]].eb (pii (ly[yrk[i]], i)),
    vec[rx[xrk[i]]].eb (pii (ry[yrk[i]], i));
  rrp (i, 1, n) {
    sum[i] = sum[i + 1] + xpos[xrk[py[i]]] - 1;
  }
  rep (i, 1, n) {
    ans[i] = (sum[ly[yrk[i]]] + sum[ry[yrk[i]]]);
  }
  rrp (i, 1, n) {
    sum[i] = sum[i + 1] + ypos[yrk[px[i]]] - 1;
  }
  rep (i, 1, n) {
    ans[i] = ans[i] + (sum[lx[xrk[i]]] + sum[rx[xrk[i]]]);
  }
  rrp (i, 1, n) {
    upd (yrk[px[i]]);
    for (auto p : vec[i]) {
      ans[p.second] += qry (p.first);
    }
  }
  rep (i, 1, n) {
    (ans[i] -= 1ll * (xpos[xrk[i]] - (xrk[i] < lx[xrk[i]]) + (xrk[i] >= rx[xrk[i]])) * (ypos[yrk[i]] - (yrk[i] < ly[yrk[i]]) + (yrk[i] >= ry[yrk[i]])));
    (ans[i] += 1ll * X[i] * Y[i]);
    ans[i] += s;
    printf ("%lld\n", ans[i]);
  }
}
```

---

## 作者：山田リョウ (赞：3)

不难发现计算答案前均可以正交分解后对每一维做，因为对于每一维来看都相当于是只要不重叠就向吼叫的熊方向移动一格。

而且每一维上熊的位置不会交叉，所以可以先按照初始坐标排序。

再简单感受下（从后面的观察中会体现出这个的正确性）删除一个熊只会导致一个前缀的熊最终坐标减去 $1$ 和一个后缀的熊最终坐标加上 $1$。

显然计算答案不会弱于对每一维计算这个前后缀的位置，而且知道这些前后缀的位置后可以直接拆成二维数点计算出最终答案，所以我们的目标就是对于每一维找到这个前后缀位置。

不妨记 $[l_i,r_i)\quad(1\leq l_i\leq r_i\leq n+1)$ 表示删除第 $i$ 个熊后 $[1,l_i)$ 的熊坐标减去 $1$ 且 $[r_i,n]$ 的熊坐标加上 $1$，这样开闭的优势后文会看到。一个简单的观察（后文也能归纳得到这个的正确性）是 $[l_i,r_i)$ 一定被最终与 $i$ 重叠的区间包含。

我们考虑增量维护这些，按时间顺序依次加入熊 $i$。

首先 $[l_i,r_i)$ 是加入 $i$ 前和 $i$ 已经重叠在一起那个区间。

再考虑一个在 $i$ 之前被加入且在 $i$ 加入前和 $i$ 仍未重叠的 $j$，那显然 $[l_j,r_j)$ 不会因为 $i$ 的加入改变（因为无论是否加入 $j$ 都不影响这次操作的位置）。

然后就到了这个问题的核心，如果一个在 $i$ 之前就被加入的 $j$ 在 $i$ 加入之前已经与 $i$ 重叠了，$[l_j,r_j)$ 会是什么样呢？我们分两种情况分讨（不妨设在 $i$ 加入前已经与 $i$ 重叠的区间为 $[L,R)$）：
+ $i\in[l_j,r_j)$：那么这一次操作就已经起到了此前 $j$ 那次合并的效果了，于是我们仍缺一次 $i$ 的操作，于是 $[l_j,r_j)=[L,R)$。
+ $i\notin[l_j,r_j)$：不失一般性地假设 $i<l_j$，另一边情况同理。$[r_j,R)$ 多减了 $1$ 所以它们坐标又不需要调了，而 $[l_j,r_j)$ 多减了 $1$ 使得它们又欠一个加 $1$ 了，因此 $[l_j,r_j)$ 变为 $[r'_j,R)$。

这样可以发现每个时刻你可以将每个重叠的区间划分为小区间使得每个 $[l_i,r_i)$ 至少有一个端点在小区间上，增量加入时只需要先把 $i$ 所在的大区间内小区间合并起来用链表维护修改，再合并大区间即可，合并区间用并查集维护就好了！

最后时间复杂度为 $O(n\log n)$，瓶颈在于初始的排序以及最后的二维数点。

[submission.](https://qoj.ac/submission/1078459)

---

## 作者：Bronya18C (赞：2)

我们先来考虑如何计算出不删任何点时最后的坐标。

一个点在吼叫完的贡献是左边连续一段总体加 $1$，右边一段总体减 $1$，如果我们维护坐标的差分数组 $d_i=a_i-a_{i-1}$，最后 $i$ 的贡献相当于找到两边第一个非 $0$ 的 $d_i$ 减 $1$，然后让 $d_0$ 加 $1$，最后跑一遍前缀和就是最后的位置，可以用并查集维护连续段，复杂度 $O(n)$。

再考虑 $c_i=1$ 时怎么做，即如何快速计算出删去一个点后坐标的偏移量。

一个点对答案的贡献是差分数组的两个位置减 $1$，但是我们发现由于后面的点也会吼叫，所以我们并不能直接减去这部分的贡献。容易发现，撤销最后一个点的贡献是容易的，而且原问题等价于将某个点的吼叫放到最后并撤销的答案，设它们此时贡献到的 $l_i,r_i$ 两个位置的差分数组。

同时，每个点的吼叫对那些和它吼叫前不在同一个位置的点的吼叫不会产生影响。具体地，设当前考虑到的点为 $i$，分析它对当前和 $i$ 已经在同一个位置且已经吼叫过的点 $j$ 的影响，设 $i$ 影响到的是 $l_i,r_i$，$j$ 放到最后一个位置影响到的是 $l_j,r_j$，如果 $j$ 不吼叫而 $i$ 吼叫，那么会在这四个位置找 $i$ 两边最近的位置减 $1$，而剩下的两个位置可以看作 $j$ 最后会贡献到的位置。

这样维护最坏复杂度是 $O(n^2)$ 的，用数据结构可以做到 $O(n \text{ polylog n})$。

再仔细分析可以发现 $l_i\le l_j,r_j\le r_i$，则 $j$ 的两个贡献到的点一定包含 $l_i,r_i$ 其中的一个，但是我们想更好地确定具体是哪个。

考虑用并查集维护连续段的时候，如果两个段 $[l,m),[m,r)$ 被合并了，则 $\forall i\in[l,m),j\in [m,r),l\le l_i\le r_i\le m \le l_j \le r_j \le r$。即它们贡献的点都在各自对应的区间里面，且互不干扰，我们可以对其懒惰合并，直到后面有新的点对这个连续段产生影响的时候再进行分析。

新加入点 $x$ 时，设 $x$ 所在连续段由 $[L_1,R_1],[L_2,R_2],\cdots,[L_m,R_m]$ 这几个懒惰合并的连续段组成，设 $x$ 所在连续段为 $[L_i,R_i]$。

对于 $\forall j\lt i,y\in [L_j,R_j]$，有 $[l_y,r_y]\in[L_j,R_j]$，而 $l_x=L_1,r_x=R_m$，所以此时保留的是 $l_x$ 和 $l_y$，注意到此时一定保留了 $l_x$；对于 $j > i$ 也类似，保留的是 $r_x$ 和 $r_y$，此时一定保留 $r_x$。

对于 $y\in[L_i,R_i]$，由于 $y$ 一定至少有一个贡献点在 $L_i$ 和 $R_i$ 的位置上，如果有一个贡献点在 $L_i$ 上，那 $y$ 一定会保留 $l_x$，否则一定会保留 $r_x$。  

为了方便维护，我们对于每个连续段 $[L,R]$，记录在内部最后一个吼叫的点 $x$ 上，在此我们维护三个部分 $A_x,B_x,C_x$，$A_x$ 内部储存的是贡献到 $L$ 的部分（注意到 $L$ 一定是作为较小的那个贡献点），$B_x$ 储存的是贡献到 $R$ 的部分（注意到 $R$ 一定是作为较大的那个贡献点），$C_x$ 储存的是两个都能贡献到的部分。$A_x$ 和 $B_x$ 可以只记录除了已知的贡献点之外的另一个点，$C_x$ 内部的点之后贡献到的点一定都是一样的，所以可以用并查集缩成一个点。

考虑上面的维护过程，对于 $\forall j < i$，$y$ 是 $[L_j,R_j]$ 的最后一个吼叫的点，$A_y$ 和 $C_y$ 内的点最后贡献到的都是 $L_1$ 和 $L_j$，可以合并成同一个点放入 $A_x$，而 $B_y$ 内的点最后贡献到的是 $L_1$ 和其内部记录的另一个点，所以可以整体放入 $A_x$（注意此时记录的点由二者较小的变为二者较大的）。（$j > i$ 同理）对于 $[L_i,R_i]$，设 $y$ 是 $[L_i,R_i]$ 上一个吼叫的点。其中 $C_y$ 里的点最后贡献到的是 $L_1$ 和 $R_m$，可以和 $C_x$ 合并成同一个点。$A_y$ 中的点 $z$，如果 $z$ 记录的另一个贡献点大于 $x$，则它最后贡献到的是 $L_1$ 和 $R_m$，否则贡献到的是 $L_1$ 和 $L_i$，所以可以将 $A_y$ 中的点合并成两个点，一个和 $C_x$ 合并，一个放到 $A_x$ 里面。$B_y$ 中的点同理。

考虑分析复杂度，扫一遍连续段的复杂度是均摊 $O(n)$ 的，对于维护 $A_x,B_x,C_x$ 我们需要实现遍历和合并，由于不需要随机访问，可以使用链表，合并是 $O(1)$ 的，由于每次遍历完都会将遍历的元素合并，所以均摊是 $O(n)$ 的。

这部分总复杂度 $O(n)$，可以求出每个点最后贡献到的差分数组的位置和如果不考虑删除的话每个点最后的位置，加上排序复杂度 $O(n\log n)$。

对于 $c_i\neq 1$ 的情况，只需分别求出来两维的答案，然后它们对乘积和的贡献是一个二维数点的形式，可以用树状数组维护，总复杂度 $O(n\log n)$。


```cpp
#include<bits/stdc++.h>

using namespace std;
int read(){
    int x = 0, t = 1;
    char ch=getchar(); 
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            t=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);  
        ch=getchar();
    }
    return x*t;
}
void write(__int128 x)
{
    if(x<0){
    	putchar('-');
		x=-x;
	}
    if(x>9) 
		write(x/10);
    putchar(x%10+'0');
}
int n;
const int N=2000005;
int *A;
bool cmp(int a,int b){
    return A[a]<A[b];
}
struct DSU{
    int fa[N];
    void Init(){
        for(int i=1;i<=n;i++)fa[i]=i;
    }
    int Find(int u){
        return (u!=fa[u]?(fa[u]=Find(fa[u])):u);
    }
    int merge(int x,int y){
        x=Find(x);y=Find(y);
        if(!x||!y)return x^y;
        fa[y]=x;
        return x;
    }
}F1,F2;
int d[N];
int nxet[N<<2],s[N<<2],t[N];
int cnt=0;
struct LList{
    int head,tail;
    void Init(){
        head=tail=0;
    }
    void link(int x){
        s[++cnt]=x;nxet[cnt]=0;
        if(!head)head=tail=cnt;
        else nxet[tail]=cnt,tail=cnt;
    }
}L[N],R[N];
void merge(LList &x,LList y){
    if(!y.head)return;
    if(!x.head)x=y;
    nxet[x.tail]=y.head;x.tail=y.tail;
}
int nxt[N],id[N];
void update(int u,LList v){
    for(int i=v.head;i;i=nxet[i])F2.merge(u,s[i]);
}
void Solve(int *a,int *p,int *rk,int *l,int *r,int *pos){
    for(int i=1;i<=n;i++)p[i]=i;A=a;
    sort(p+1,p+1+n,cmp);
    for(int i=1;i<=n;i++)id[i]=0,rk[p[i]]=i,d[i]=a[p[i]]-a[p[i-1]],nxt[i]=i+1,L[i].Init(),R[i].Init();
    F1.Init();F2.Init();
    for(int i=1;i<=n;i++)
        if(d[i]==0)F1.merge(i-1,i);
    d[1]+=n;d[n+1]+=1e9;cnt=0;nxt[0]=1;
    for(int i=1;i<=n;i++){
        int u=rk[i],j=F1.Find(u);
        for(int k=j;(k==j)||d[k]==0;k=nxt[k]){
            nxt[j]=nxt[k];
            if(!id[k])continue;
            int q=id[k];
            if(nxt[k]<=u)update(q,L[q]),t[q]=k,L[i].link(q),merge(L[i],R[q]);
            else if(k>u)merge(R[i],L[q]),update(q,R[q]),t[q]=nxt[k],R[i].link(q);
            else {
                F2.merge(i,q);int l1=0,r1=0;
                for(int v=L[q].head;v;v=nxet[v]){
                    int r=s[v];
                    if(t[r]<=u)l1=F2.merge(l1,r);
                    else F2.merge(i,r);
                }
                for(int v=R[q].head;v;v=nxet[v]){
                    int r=s[v];
                    if(t[r]>u)r1=F2.merge(r1,r);
                    else F2.merge(i,r);
                }
                t[l1]=k;t[r1]=nxt[k];
                if(l1)L[i].link(l1);
                if(r1)R[i].link(r1);
            }
        }
        id[j]=i;
        if(!(--d[j]))F1.merge(j-1,j);
        if(!(--d[nxt[j]]))F1.merge(j,nxt[j]);
    }
    cerr<< cnt<<endl;
    for(int i=1;i<=n;i=nxt[i]){
        int x=id[i];
        l[x]=i;r[x]=nxt[i];
        for(int u=L[x].head;u;u=nxet[u]){
            int v=s[u];
            l[v]=i,r[v]=t[v];
        }
        for(int u=R[x].head;u;u=nxet[u]){
            int v=s[u];
            r[v]=nxt[i],l[v]=t[v];
        }
    }
    for(int i=1;i<=n;i++)l[i]=l[F2.Find(i)],r[i]=r[F2.Find(i)];
    for(int i=1;i<=n;i++)pos[i]=pos[i-1]+d[i];
}

int x[N],y[N];
int px[N],py[N],rkx[N],rky[N];
int lx[N],rx[N],ly[N],ry[N],posx[N],posy[N];
long long sumx[N],sumy[N],ans[N];
struct BIT{
    int t[N];
    int lowbit(int x){
        return x&(-x);
    }
    void add(int x,int val){
        while(x<=n){
            t[x]+=val;
            x+=lowbit(x);
        }
    }
    int Find(int x){
        int sum=0;
        while(x){
            sum+=t[x];
            x-=lowbit(x);
        }
        return sum;
    }
}T;
vector<int>vt[N];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)x[i]=read(),y[i]=read();
    Solve(x,px,rkx,lx,rx,posx);
    Solve(y,py,rky,ly,ry,posy);
    __int128 sum=0;
    for(int i=1;i<=n;i++)sum+=1ll*posx[rkx[i]]*posy[rky[i]];
    for(int i=1;i<=n;i++)sumx[i]=posx[rkx[py[i]]]+sumx[i-1],sumy[i]=posy[rky[px[i]]]+sumy[i-1];
    for(int i=1;i<=n;i++){
        ans[i]+=sumx[n]-sumx[ry[i]-1]-sumx[ly[i]-1]+sumy[n]-sumy[rx[i]-1]-sumy[lx[i]-1];
        if(lx[i]!=1)vt[lx[i]-1].push_back(i);
        if(rx[i]!=n+1){
            vt[rx[i]-1].push_back(i);
            ans[i]+=-ly[i]+1+n-ry[i]+1;
        }
    }
    for(int i=1;i<=n;i++){
        T.add(rky[px[i]],1);
        for(auto u:vt[i])ans[u]+=T.Find(ly[u]-1)-i+T.Find(ry[u]-1);
    }
    for(int i=1;i<=n;i++)
        write(sum-1ll*(posx[rkx[i]]-(rkx[i]<lx[i])+(rkx[i]>=rx[i]))*(posy[rky[i]]-(rky[i]<ly[i])+(rky[i]>=ry[i]))+ans[i]+1ll*x[i]*y[i]),putchar('\n');
    return 0;
}
```

---


# 「GLR-R4」小暑

## 题目背景

&emsp;&emsp;「长养薰风拂晓吹，浅开荷芰落蔷薇」

---

&emsp;&emsp;在校内的最后一次试演出！

&emsp;&emsp;从[第一次登台](https://www.luogu.com.cn/problem/P7245)至今，从以往约定的放学后空无一人的操场到如今日夜挥汗的训练室，他们与彼此的约定是否改变呢？

&emsp;&emsp;“肩上的吉他和小小梦想，要为它们长出坚强的翅膀！”

---

&emsp;&emsp;**小暑**&emsp;「Can you hear me now?　我会从此成为你的骄傲　现在就要出发　一切刚刚好」

## 题目描述

&emsp;&emsp;[还记得吗？](https://www.luogu.com.cn/problem/P8476)你可是天依他们的专业分析师。除了演出者的表现，观众们的情感波动也是重要的分析对象。经过不懈努力，你提出了以下这些指标（出题人已经被你消灭啦，但还是请你耐心读题）：

&emsp;&emsp;「情绪」&emsp;我们用强烈度 $v\in\mathbb N^\star$ 来表达一个情绪。

&emsp;&emsp;「心境」&emsp;一系列情绪共同组成一个心境，我们将心境描述为一个二元组 $M=(s,f)$，其中 $s,f\in\mathbb N^\star$，其中 $s$ 为所含情绪的强烈度之和，$f$ 为某个特征情绪的强烈度。

&emsp;&emsp;「共鸣」&emsp;两个心境可以通过共鸣而融合得到新的心境。我们将 $M_2=(s_2,f_2)$ 融合向 $M_1=(s_1,f_1)$ 的共鸣记作 $M_1+M_2$，共鸣的结果是一个新的心境 $M=M_1+M_2=(s_1+s_2,f_1)$。注意此时**不一定满足** $M_1+M_2=M_2+M_1$。

&emsp;&emsp;「心路」&emsp;在一棵有根树上，沿**树形关系**共鸣心境的过程称为心路。对于以 $r$ 为根的子树，其心路历程可以描述如下：

1.  初始时，$A_r\gets M_r$，其中 $A_x$ 表示以 $x$ 为根的子树心路完成后的最终心境，$M_x$ 为 $x$ 结点上的初始心境。

2.  **按编号升序地**枚举 $r$ 的孩子结点 $x$：

    -   递归完成 $x$ 子树的心路，得到 $A_x$。此时，设 $A_r=(s_r,f_r)$，$A_x=(s_x,f_x)$。

    -   若 $s_r\ge s_x$，则令 $A_r\gets A_r+A_x$，否则令 $A_r\gets A_x+A_r$。

&emsp;&emsp;最终的 $A_r$ 即为以 $r$ 为根的子树心路完成后的最终心境。

---

&emsp;&emsp;为研究特定观众的心理变化情况，你需要时刻监控其上述指标。现给定一棵含有 $n$ 个结点，以 $1$ 为根结点的有根树，结点 $x$ 上初始有心境 $M_x=(a_x,a_x)$。此后进行 $q$ 次操作，每次操作有以下两类：

1.  给出结点 $x$，询问 $A_x=(s_x,f_x)$ 中 $f_x$ 的值，其中 $A_x$ 应当在每次询问时，依据当前的信息重新计算。

2.  给出结点 $x$ 和变化量 $d$，令 $a_x\gets a_x+d$，并修改对应的 $M_x$。注意 $d$ **可能为负数**，但保证操作前后都有 $a_x>0$。

&emsp;&emsp;请你对于每个询问操作，计算出相应的答案。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，$1\le n,q\le2\times10^5$，$1\le p_i<i$；操作给出的 $x\in[1,n]$，$d\in[-10^{18},10^{18}]$；在任意时刻 $a_x\ge 1$ 且 $\sum_{x=1}^na_x\le10^{18}$。

对于不同的子任务，作如下约定：

|   子任务编号    |   $n$    |  $q$  | 特殊性质 | 子任务分值 |
| :---------: | :--------: | :----:  | :----: | :-: |
|  $1$  |  $\leq 10 ^ 3$  | $\leq 10 ^ 3$  | 无 | $10$|
|  $2$  | $\leq 2 \times 10 ^ 5$ | $\leq 2 \times 10 ^ 5$ | $\textbf A$| $20$|
|  $3$  | $\le 2 \times 10 ^ 5$ | $\le 2 \times 10 ^ 5$| $\textbf B$ | $20$|
|  $4$  | $\le 2 \times 10 ^ 5$ | $\leq 2 \times 10 ^ 5$ | 无 | $50$|

- 特殊性质 $\textbf A$：对于 $i\in[2,n]$，$p_i=i-1$。

- 特殊性质 $\textbf B$：保证当 $1$ 为根时，原树是一棵二叉树。且对于 $i\in[2,n]$，存在一条从 $1$ 到 $i$，经过边数不超过 $20$ 的树上路径。

## 样例 #1

### 输入

```
5 10
2 10 1 10 3
1 2 3 2
2 1 3
1 3
1 5
2 3 5
2 3 2
1 5
2 5 6
1 3
2 5 -1
2 3 0```

### 输出

```
10
3
3
10```

# 题解

## 作者：EnofTaiPeople (赞：10)

### Part1 前言
省选前一直想改这道题，一直不敢，结果现在国赛模拟搬原题强制落实，被我两个小时场切了。

启示：数据结构题还是场切更有意思。

最近的国赛模拟频繁地出现 LCT 或 Top Tree（无一例外都场切了），可能会直接导致我重新开始研究 Top Tree，毕竟我又没有 D/E 类名额。

### Part2 问题转化

发现将一个节点与其儿子依次合并不好做，将这棵树重构。

每次将 $A_x$ 与 $A_y$ 合并时，新建一个节点，左儿子为 $x$，右儿子为 $y$。

注意这时 $x$ 会变成新建的节点，同时记录每一个节点子树最后的合并结果为 $mst_x$，查询时就是从 $mst_x$ 开始往下跳关于 $a_x$ 的带权重链。

### Part3 两个操作

[WBTT](https://zx2003.blog.uoj.ac/blog/7884) 这篇文章讲得很清楚，反正我都是学 zx2003 的。

这篇文章里讲了两个操作，`access` 和 `drop`，我们每次更改节点 $x$ 的权值时，先对 $x$ `access`，即强制将其到根路径上的边变为重边。

然后进行 `drop`，即将不合法的重边变为轻边，具体地，记录 $lt_x$ 表示节点 $x$ 的重儿子带权 $size$ 减去轻儿子带权 $size$，若 $lt_x\le 0$，则**可能**需要抖落，这样的边最多有 $O(\log V)$ 条。

至于如何动态维护 $lt_x$，只要在 `access` 之后链加就行了。

### Part4 一些细节

求答案时需要向下跳重链，起初我想用倍增维护（参考 CSP-S 2019 树的重心），但这样是错误的，我白白浪费了好多时间。

事实上，这里需要记录 $cl_x$ 表示 $x$ 往下跳到底的答案，在带权轻重边切换时，假设是 $x$ 的重儿子变为 $y$，我们先求出 $cl_y$，再从 $x$ 往上（二分）跳重链，将这段重链节点的 $cl$ 赋值为 $cl_y$。

因为每次切换 $O(\log n)$，每次最多 $O(\log V)$ 次切换，所以总时间复杂度 $O(n+q\log n\log V)$，空间 $O(n)$。

### Part5 后记

希望我可以从本题衍生出 WBTT 的考场可写作实现方式。

希望 Top Tree 文化能够一直传递下去。

才 2023 年，有的是希望。

Upd：本题并不能衍生出 WBTT 的实现方式，因为那比这个要复杂许多，但我已经学会了复杂度严格、支持 Link-Cut 的 WBTT，却依旧无法做到 考场可写作。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5;
using ll=long long;
ll a[N],sm[N];
int n,q,rt,cnt,L[N],R[N],fa[N];
int mst[N],d[N];
vector<int>lk[N];
ll lt[N],mn[N],tg[N];
int cl[N],ctg[N];
int lc[N],sl[N];//lc[x]=1->x is'nt wtson
int t[N][2],f[N];
#define ls t[x][0]
#define rs t[x][1]
#define tp(x) (t[f[x]][1]==x)
#define in(x) (t[f[x]][0]==x||tp(x))
void pp(int x){
    sl[x]=sl[ls]|sl[rs]|lc[x];
    mn[x]=min({mn[ls],mn[rs],lt[x]});
}
void add(int x,ll d){
    tg[x]+=d,mn[x]+=d,lt[x]+=d;
}
void adc(int x,int c){
    cl[x]=ctg[x]=c;
}
void pd(int x){
    if(tg[x]){
        if(ls)add(ls,tg[x]);
        if(rs)add(rs,tg[x]);
        tg[x]=0;
    }if(ctg[x]){
        adc(ls,ctg[x]),adc(rs,ctg[x]);
        ctg[x]=0;
    }
}
void ppd(int x){
    if(in(x))ppd(f[x]);pd(x);
}
void rot(int x){
    int y=f[x],k=tp(x),w=t[x][!k];
    t[f[w]=t[x][!k]=y][k]=w;
    if(in(y))t[f[y]][tp(y)]=x;
    f[x]=f[y],f[y]=x,pp(y);
}
void splay(int x){ppd(x);
    for(int y=f[x];in(x);rot(x),y=f[x])
        if(in(y))rot(tp(x)^tp(y)?x:y);pp(x);
}
void acs(int x){
    for(int y=0;x;x=f[y=x])
        splay(x),rs=y,pp(x);
}
int dfs(int x){
    sort(lk[x].begin(),lk[x].end());
    int nw=x,p;sm[x]=a[x],cl[x]=x;
    for(int y:lk[x]){
        p=++cnt;
        fa[L[p]=nw]=p;
        fa[R[p]=dfs(y)]=p;
        f[L[p]]=f[R[p]]=p;
        if(sm[L[p]]>=sm[R[p]]){
            d[p]=L[p];
            lc[R[p]]=1,cl[p]=cl[L[p]];
            lt[p]=sm[L[p]]-sm[R[p]];
        }else{
            d[p]=R[p];
            lc[L[p]]=1,cl[p]=cl[R[p]];
            lt[p]=sm[R[p]]-sm[L[p]];
        }
        sm[nw=p]=sm[L[p]]+sm[R[p]];
    }return mst[x]=nw;
}
vector<int>nd;
void rep(int x,int y){
    // cerr<<"rep:"<<x<<" "<<y<<endl;
    if(y!=d[x]){
        splay(d[x]),lc[d[x]]=1,pp(d[x]);
        splay(y),d[x]=y;
        int p=cl[y];
        splay(x),rs=0;
        lt[x]=-lt[x],pp(x);
        if(!lc[x])
            if(sl[ls]){
                for(x=ls;;){
                    pd(x);
                    if(sl[rs])x=rs;
                    else if(lc[x])break;
                    else x=ls;
                }
            }else{
                while(ls)pd(x),x=ls;
            }
        // cerr<<x<<" "<<p<<endl;
        splay(x),cl[x]=p,adc(rs,p);
        // cerr<<cl[x]<<endl;
        splay(y),lc[y]=0,pp(y);
    }
}
void access(int x){
    acs(x),splay(x);
    // cerr<<x<<" "<<sl[x]<<" "<<lc[x]<<endl;
    while(x&&sl[x]){
        while(1){
            pd(x);
            if(sl[rs])x=rs;
            else if(lc[x])break;
            else x=ls;
        }splay(x);
        nd.push_back(x);
        x=ls;
    }
    for(int p:nd)
        if(p!=rt)rep(fa[p],p);
    nd.clear();
}
void drop(int x){
    int mast=x;
    acs(x),splay(x),x=ls,splay(x);
    while(x&&mn[x]<=0){
        while(1){
            // cout<<"tg:"<<tg[x]<<endl;
            // cout<<"*"<<x<<" "<<ls<<" "<<rs<<" "<<mn[rs]<<" "<<mn[ls]<<" "<<lt[x]<<" "<<mn[x]<<endl;
            pd(x);
            // cout<<x<<" "<<ls<<" "<<rs<<" "<<mn[rs]<<" "<<mn[ls]<<" "<<lt[x]<<" "<<mn[x]<<endl;
            if(mn[rs]<=0)x=rs;
            else if(lt[x]<=0)break;
            else x=ls;
        }
        // cerr<<x<<endl;
        splay(x);
        // cerr<<x<<endl;
        nd.push_back(x);
        x=ls;
    }
    for(int p:nd)
        if(p!=mast){
            // cerr<<p<<" "<<d[p]<<" "<<lt[p]<<endl;
            if(d[p]==L[p]){
                // cerr<<p<<" "<<lt[p]<<endl;
                if(lt[p]<0)rep(p,R[p]);
            }else rep(p,L[p]);
        }
    nd.clear();
}
int main(){
    // freopen("copy.in","r",stdin);
    // freopen("copy.out","w",stdout);
    ios::sync_with_stdio(false);
    int i,j,k,l,r,x,y;
    cin>>n>>q,cnt=n;ll d;
    mn[0]=1e18;
    for(x=1;x<=n;++x)cin>>a[x];
    for(x=2;x<=n;++x){
        cin>>y;
        lk[y].push_back(x);
    }rt=dfs(1);
    for(x=1;x<=cnt;++x)pp(x);
    // for(x=n+1;x<=cnt;++x)
    //     splay(x),printf("x:%d d:%d L:%d R:%d lt:%lld\n",x,::d[x],L[x],R[x],lt[x]);
    // for(x=1;x<=cnt;++x)
    //     printf("x:%d lc:%d\n",x,lc[x]);
    while(q--){
        cin>>k>>x;
        if(k==1){
            splay(mst[x]);
            // cerr<<cl[mst[x]]<<endl;
            printf("%lld\n",a[cl[mst[x]]]);
            // if(x==3){
            //     splay(8),printf("%lld\n",lt[8]);
            // }
        }else{
            cin>>d,access(x),a[x]+=d;
            acs(x),splay(x);
            // for(int x=1;x<=cnt;++x)
            //     printf("x:%d ls:%d rs:%d f:%d\n",x,ls,rs,f[x]);
            // printf("x:%d mn:%lld\n",x,mn[x]);
            // printf("ls:%d mn:%lld\n",ls,mn[ls]);
            add(ls,d),pp(x);
            // if(!q)exit(0);
            // printf("x:%d mn:%lld\n",x,mn[x]);
            // cout<<"drop:"<<endl;
            drop(x);
            // cout<<"end:"<<endl;
        }
        // for(x=n+1;x<=cnt;++x)
        //     splay(x),printf("x:%d d:%d L:%d R:%d lt:%lld\n",x,::d[x],L[x],R[x],lt[x]);
        // fflush(stdout);
    }return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：9)

官方题解。

个人认为是一道比较简单的题目。

比较考察选手对于常见套路的结合能力。

希望大家不要做前面的题做自闭了于是来缓和一下难度。

~~小彩蛋，这道题正解其实是 zky 一年前提供的。~~

**Sub 1**

暴力。

**sub 2**

链问题。

维护一个点的权值本身是否大于后缀和，称这样的点为特殊点。

我们发现这样的点至多出现 $O(\log V)$ 个，那么每次修改后暴力重构这些特殊点，具体来说我们令每个点的权值为 $a_{x} - \sum_{i = x + 1} ^ {n} a_{i}$。每次修改在线段树上就是区间加单点修改，然后线段树维护区间最小值就可以递归找到这些节点。

这样原序列的答案被分成了 $O(\log V)$ 段，直接查询即可。

时间复杂度 $O((n+q) \log V)$。

**sub 3**

线段树问题。

发现影响的只会有祖先的答案，区别于朴素的重构暴力，直接暴力爬重新模拟后合并就行了。

时间复杂度 $O((n + q) \log^2 n)$。

**sub 4**

继续套路。

凭感觉，启发式合并的过程很类似树剖，合并的过程让你想起点/边分治上的三度化思想，直接组合一下两个套路。

如果您不会树链剖分，网上有很多资料。

此题的三度化指的是，每次合并子树时视为一个序列，将子树根放在序列第一个元素，然后将剩余点按照编号从小到大排列，每次合并的时候新建一个节点代表两个合并的集合后新产生的集合。

举个例子：

![](https://tuchuangs.com/imgs/2023/03/14/d7b29fde29153f8a.png)

如图，$4$ 表示父亲，对该子树进行三度化后的形态。重构树的点数显然也是 $O(n)$ 级别的。

这个结构的优势是，它将合并过程的结构显性表达了。所以我们直接维护一下每个节点的重儿子（即权值和为键值的重儿子）。

再结合第二档部分分，发现一次修改至多会有 $O(\log V)$ 个节点的轻重关系被改变，使用数据结构维护即可。

毛估估时间复杂度 $O((n + q) \log ^ 2 V)$，不清楚有没有更精确的时间复杂度分析，反正我也不知道我造的极限数据能不能卡满两只 $\log$，至少跑出来是比较卡满的样子。

标程采用的是 LCT 维护，传统树剖也可在同时间复杂度内维护，只是不方便书写。

```cpp
/*+Rainybunny+*/

#include <bits/stdc++.h>
#define int long long
#define rep(i, l, r) for (int i = l, rep##i = r; i <= rep##i; ++i)
#define per(i, r, l) for (int i = r, per##i = l; i >= per##i; --i)
#ifndef RYBY
#   undef assert
#   define assert(expr) void() /* do nothing */
#endif

typedef long long LL;

inline char fgc() {
    static char buf[1 << 17], *p = buf, *q = buf;
    return p == q && (q = buf + fread(p = buf, 1, 1 << 17, stdin), p == q) ?
      EOF : *p++;
}

template <typename Tp = int>
inline Tp rint() {
    Tp x = 0, s = fgc(), f = 1;
    for (; s < '0' || '9' < s; s = fgc()) f = s == '-' ? -f : f;
    for (; '0' <= s && s <= '9'; s = fgc()) x = x * 10 + (s ^ '0');
    return x * f;
}

template <typename Tp>
inline void wint(Tp x) {
    if (x < 0) putchar('-'), x = -x;
    if (9 < x) wint(x / 10);
    putchar(x % 10 ^ '0');
}

const int MAXN = 2e5, MAXND = MAXN << 1;
const LL LINF = 1ll << 60;
int n, q, node, ref[MAXN + 5], adj[MAXND + 5][2];
LL a[MAXN + 5];
std::vector<int> son[MAXN + 5];

namespace LCT {

int ch[MAXND + 5][2], fa[MAXND + 5], win[MAXND + 5];
LL gap[MAXND + 5], mng[MAXND + 5], tag[MAXND + 5];

inline bool nroot(const int u) {
    return ch[fa[u]][0] == u || ch[fa[u]][1] == u;
}

inline void pushad(const int u, const LL k) {
    mng[u] += k, gap[u] += k, tag[u] += k;
}

inline void pushdn(const int u) {
    if (tag[u]) {
        if (ch[u][0]) pushad(ch[u][0], tag[u]);
        if (ch[u][1]) pushad(ch[u][1], tag[u]);
        tag[u] = 0;
    }
}

inline void pushup(const int u) {
    mng[u] = gap[u];
    if (ch[u][0]) mng[u] = std::min(mng[u], mng[ch[u][0]]);
    if (ch[u][1]) mng[u] = std::min(mng[u], mng[ch[u][1]]);
}

inline LL build(const int u) {
    if (u <= n) return gap[u] = LINF, pushup(u), a[u];
    LL s0 = build(adj[u][0]), s1 = build(adj[u][1]);
    fa[adj[u][0]] = fa[adj[u][1]] = u;
    if (s0 >= s1) win[u] = ch[u][1] = adj[u][0], gap[u] = s0 - s1;
    else win[u] = ch[u][1] = adj[u][1], gap[u] = s1 - s0 - 1;
    return pushup(u), s0 + s1;
}

inline void rotate(const int u) {
    int v = fa[u], w = fa[v], k = ch[v][1] == u;
    fa[u] = w; if (nroot(v)) ch[w][ch[w][1] == v] = u;
    ch[v][k] = ch[u][!k]; if (ch[u][!k]) fa[ch[u][!k]] = v;
    pushup(ch[fa[v] = u][!k] = v), pushup(u);
}

inline void splay(const int u) {
    static int v, w, stk[MAXND + 5];
    for (stk[w = 1] = v = u; nroot(v); stk[++w] = v = fa[v]);
    while (w) pushdn(stk[w--]);
    for (; nroot(u); rotate(u)) {
        if (nroot(v = fa[u])) {
            rotate((ch[v][0] == u) == (ch[fa[v]][0] == v) ? v : u);
        }
    }
}

inline int findCut(int u) {
    if (!u || mng[u] >= 0) return 0;
    while (true) {
        pushdn(u);
        if (ch[u][1] && mng[ch[u][1]] < 0) u = ch[u][1];
        else if (gap[u] < 0) return u;
        else u = ch[u][0];
    }
}

inline void swapWin(const int u) {
    assert(u > n), assert(!nroot(u));
    gap[u] = -gap[u] - 1, pushup(u);
    assert(gap[u] >= 0);
    win[u] = adj[u][0] ^ adj[u][1] ^ win[u];
}

inline void modify(int u, const int k) {
    for (int v = u; v; v = fa[v]) {
        splay(v), gap[v] -= k;
        if (ch[v][0]) pushad(ch[v][0], k);
        pushup(v);
    }

    for (int v; u; u = v) {
        if ((v = findCut(u))) {
            splay(v), swapWin(v);
            splay(win[v]), ch[v][1] = win[v], pushup(v);
        } else v = fa[u];
    }
}

inline int answer(int u) {
    splay(u);
    while (ch[u][1]) u = ch[u][1];
    splay(u);
    return u;
}

} // namespace LCT

signed main() {
    //freopen("data36.in","r",stdin);
    //freopen("data36.out","w",stdout);
    n = node = rint(), q = rint();
    rep (i, 1, n) a[i] = rint<LL>();
    rep (i, 2, n) son[rint()].push_back(i);

    per (u, n, 1) {
        ref[u] = u, std::sort(son[u].begin(), son[u].end());
        for (int v: son[u]) {
            ++node, adj[node][0] = ref[u], adj[node][1] = ref[v];
            // printf("%d %d\n%d %d\n", node, ref[u], node, ref[v]);
            ref[u] = node;
        }
    }
    LCT::build(node);

    for (int op, x, y; q--;) {
        op = rint(), x = rint();
        if (op == 1) wint(a[LCT::answer(ref[x])]), putchar('\n');
        else LCT::modify(x, y = rint<LL>()), a[x] += y;
    }
    return 0;
}
```

upd 2023/3/19 被指出代码时间复杂度有问题，已更正，感谢杰老师。

---

## 作者：Pekemetier (赞：5)

$2\log$ 树剖做法，常数巨大。

每次修改一个节点，$f$ 会变化的点只能是它的祖先，因此考虑动态维护 $f$。

注意到向上枚举祖先的过程中，如果 $size_i>\frac12size_{fa}$，那么 $f_{fa}$ 一定等于 $f_i$。因此我们可以找出所有的 $fa$ 满足 $size_{fa}\geq2size_i$，这些点显然只有不超过 $\log V$ 个，对每个点计算答案，然后对于这些 $fa$ 之间的点，利用树剖区间赋值。

如何找到这些 $fa$ 呢，根据一些显然的套路，我们可以先得到当前节点的 $size_x$，然后向上找到第一个 $size_{fa}\geq2size_x$，接着验证 $size_{fa}$ 是否为儿子大小的两倍。最多找 $\log V+\log n$ 次，每次寻找可以直接用线段树完成。

然后考虑对这 $\log V$ 个 $fa$ 计算答案。我们需要维护的是每个儿子的 $size_i-size_{pre}$，这可以用[上一场](https://www.luogu.com.cn/contest/78024)[另一道题](https://www.luogu.com.cn/problem/P8479)的方法维护。具体地，对于每一条重链，从上向下（反向也可以）依次将编号大于重儿子的轻儿子按编号加入 dfn 序。每次修改时，会把一条重链上每个点编号比它大的兄弟修改，这在 dfn 序上恰好是一段连续区间。之后只要处理轻儿子的边界情况，这部分较好维护。

---

## 作者：jerry3128 (赞：3)

关于我因为退役准备把以前出好的题整理到一起准备大学恰米，结果被好朋友想到了相同 idea 捷足先登痛失良机，然后高考模拟错过比赛，Top Tree 又被卡常，不能复制粘贴，于是重构代码再来写这道题这件事。

于是我们将题意转化为求二叉树上带点权修改的重链剖分。

Q：我们应当以何种思想和方法来维护重链剖分。

- 因为是二叉树，对于一个节点，其节点的度数最大是 $3$，只可能指向两个儿子中的一个，那么我们考虑使用动态链剖也就是 LCT 的方式对原有树剖结构进行维护，并在 LCT 上对每个节点加一个外向边记录虚儿子。
- 考虑一次单点修改的影响：
  - 如果改大，单点到根的整条链上，所有指向外的实边有可能指向当前链。
  - 如果改小，单点到根的整条链上，所有指向当前链的实边有可能指向外。
- 那么我们需要的就是一个阈值判定，判定其是否会有边的切换。这个阈值应该都能够想到就是 $dlt=sz_{son}-sz_{other}+pri_{son}$，即实儿子大小减去虚儿子大小再加上实儿子是不是右边的儿子（是一个 bool 变量），因为第二关键字是顺序大到小。
- 这个东西很好维护，甚至不需要懒标记，每次维护当前子结构最小的 $dlt$，上传的时候把实链右侧对左侧的影响加上去即可。
- 每次单点修改就真的是单点修改，把修改点 $splay$，然后一遍做 $search$ 切换边，一边将新信息上传到根。因为信息只跟子结构有关系，所以不需要懒标记。

Q：这个东西复杂度如何。

A：可以容易的得出上界 $\mathcal O(n\log^2 n)$（怀疑是 $\mathcal O(n\log n)$，已退役过一年再填坑）

Q：怎么做这样的题。

- 前置科技点：[[ZJOI2018]历史](https://www.luogu.com.cn/problem/P4338)
- 后置科技点：[[Ynoi Easy Round 2020] TEST_63](https://www.luogu.com.cn/problem/P8265)（带 link、cut 动态链剖），蜀道难（换根 DDP）

```
void push_up(int rt){
	v[rt].pre=v[rt].ch[0]?v[v[rt].ch[0]].pre:rt;
	v[rt].suf=v[rt].ch[1]?v[v[rt].ch[1]].suf:rt;
	v[rt].sum=v[v[rt].ch[0]].sum+v[v[rt].ch[1]].sum+v[v[rt].ch[2]].sum+v[rt].val;
	v[rt].dlt=v[rt].ch[2]?v[v[rt].ch[1]].sum-v[v[rt].ch[2]].sum+(pri[v[v[rt].ch[1]].pre]):0x3f3f3f3f3f3f3f3fll;
	v[rt].midlt=min(v[v[rt].ch[1]].midlt,v[rt].dlt,v[v[rt].ch[0]].midlt+(v[rt].sum-v[v[rt].ch[0]].sum));
}
int searchsuf(int x,long long sufval){
	if(v[v[x].ch[1]].midlt+sufval<=0)return searchsuf(v[x].ch[1],sufval);
	if(v[x].dlt+sufval<=0)return x;
	return searchsuf(v[x].ch[0],sufval+(v[x].sum-v[v[x].ch[0]].sum));
}
void redirection(int x){splay(x),swap(v[x].ch[1],v[x].ch[2]),push_up(x);}
void modify(int x,long long val){
	splay(x);long long pre=v[x].val;
	v[x].val+=val,push_up(x);
	while(x){
		splay(x);
		if(v[x].dlt<=0)redirection(x);
		if(v[x].ch[0]&&v[v[x].ch[0]].midlt+(v[x].sum-v[v[x].ch[0]].sum)<=0)x=searchsuf(v[x].ch[0],v[x].sum-v[v[x].ch[0]].sum);
		else x=v[x].fa;
	}
}
```

---


# 「GLR-R4」大暑

## 题目背景

&emsp;&emsp;「时见疏星落画檐，几点流萤小」

---

&emsp;&emsp;全国音乐祭，在天依一行人抵达之时，芙城早已翻涌这狂欢的气氛，汇聚于此的某些紧张青年人们倒显得有些格格不入。

&emsp;&emsp;“总之，这里一定是终点站吧。”

&emsp;&emsp;排练又一次随着弦音结束。又开始，结束。

&emsp;&emsp;“阿绫，我们出去走走吧。”

---

&emsp;&emsp;**大暑**&emsp;「为所有视线涂抹上　一片蔚蓝的颜色　融化了苦涩」

## 题目描述

&emsp;&emsp;“阿绫，你看这宣传册上这幅画，好奇怪呀。”

&emsp;&emsp;在宣传册中“融艺术与科技为一体”的巨幅画作的制作过程如下：

&emsp;&emsp;首先，工作人员画出 $n!$ 个 $n\times2$ 的点阵图，任意两个点阵图间互相远离，在后续的制作过程中**互相独立**。对于第 $i$ 个点阵图，令其左下角坐标为 $(0,0)$，该点阵的点集为 $X_i\cup Y_i$，其中 $X_i=\{(0,y)\mid y\in[0,n)\cap\mathbb N\}$，$Y_i=\{(1,y)\mid y\in[0,n)\cap\mathbb N\}$。

&emsp;&emsp;接着，设集合 $\Sigma=\{\sigma_i\}_{i=1}^{n!}$ 包含 $\{0,1,\dots,n-1\}$ 的所有 $n$ 阶排列，对于第 $i$ 个点阵图，工作人员将用字典序第 $i$ 小的排列 $\sigma_i$ 为 $X_i,Y_i$ 连线配对：对于点 $P(0,y)\in X_i$，作一条线段将其与点 $Q(1,\sigma_{i,y})\in Y_i$ 相连。

&emsp;&emsp;最后，是激动人心的上色步骤。对于第 $i$ 个点阵图中的每个 $P(0,y)\in X_i$，从 $P$ 出发，沿着上一步骤中作出的线段，走**任意线段或折线**，到达 $Y_i$ 中的任意一点，并为这条线段或折线染上第 $y$ 种颜色。此外，为了避免不同颜色混在一起，需要保证，在所有 $n!$ 个点阵图中，被多余一种颜色染过的线段长度之和为 $0$。

&emsp;&emsp;呈现在天依一行人眼前的这幅画的上色明显很敷衍，所以天依想知道到底有多少种可供选择的上色方案。定义两种上色方案不同，当且仅当存在编号 $i\in[1,n!]$ 和任意一点 $P$，使得两个上色方案各自完成后，第 $i$ 个点阵图中染过点 $P$ 的颜色集合不同。

&emsp;&emsp;你只需要告诉天依答案对 $p=335~544~323$ 取模后的结果。*天依可是为了简化你的计算，精挑细选了一个有趣的模数呢。*

&emsp;&emsp;（请参考样例 #1 解释确认题意。）

## 说明/提示

#### 样例 #1 解释

在完成前两步后，画作的全貌如下。$(A,B,C,D,E,F)$ 构成一组 $n\times2$ 的点阵图，不同点阵图的相对位置并不重要。

![](https://cdn.luogu.com.cn/upload/image_hosting/6xaw4brz.png)

以下是一种可供选择的染色方案。红、黄、蓝依次对应第 $0,1,2$ 种颜色。

![](https://cdn.luogu.com.cn/upload/image_hosting/ma3r8yit.png)

#### 样例 #2 解释

答案的真实值为 $996~124~179~980~315~787~264$。

### 数据规模与约定

对于 $100\%$ 的数据，$n\le10^6$。

对于不同的子任务，作如下约定：

| 子任务编号 |       $n$        | 子任务分值 |
| :--------: | :--------------: | :--------: |
|    $1$     |      $\le9$      |    $10$    |
|    $2$     |     $\le100$     |    $10$    |
|    $3$     |     $\le500$     |    $15$    |
|    $4$     | $\le5\times10^3$ |    $20$    |
|    $5$     |    $\le10^5$     |    $20$    |
|    $6$     |    $\le10^6$     |    $25$    |


## 样例 #1

### 输入

```
3```

### 输出

```
384```

## 样例 #2

### 输入

```
4```

### 输出

```
40344945```

# 题解

## 作者：Rainybunny (赞：12)

# $\mathscr{Description}$

&emsp;&emsp;[Link]().

&emsp;&emsp;这里有兔以前写的另一个题意，大家可以参考着看看。

&emsp;&emsp;你有两个坐标集合 $X,Y$，$X=\{(0,y)\mid y\in[0,n)\cap\mathbb N\}$，$Y=\{(1,y)\mid y\in[0,n)\cap\mathbb N\}$。

&emsp;&emsp;现在你需要将 $X$ 中每个点与 $Y$ 中每个点配对构成双射，将它们连接。配对完成后，你需要从 $X$ 的每个点 $(0,k)$ 出发，**沿着配对**的线，走一条**线段或折线**到达 $Y$ 中一点，并为走过的线涂上第 $k$ 种颜色。你需要保证走动过程的任意时刻，$x$ 轴方向的速度 $v_x$ 为正。

&emsp;&emsp;染色完成后，你需要保证任意线段上的任意一个不与其他线段相交的点都**恰好**被染上一种颜色。

&emsp;&emsp;对于一种配对方案，令其权值为染色方案数。求所有配对方案的权值之积，模 $335544323$。

&emsp;&emsp;$m\le10^6$。

# $\mathscr{Solution}$

&emsp;&emsp;**Subtask 1** $(n\le9)$&emsp;不妨称第 $i$ 个点阵图内部的染色方案数为排列 $\sigma_i$ 的权值，记为 $v(\sigma_i)$。我们自然是要求所有排列权值之积。

&emsp;&emsp;如果不会算 $v(\sigma_i)$ 那确实只能过 $n\le4$ 了（因为 $n=4$ 是样例）。仔细一想，其实 $v(\sigma_i)$ 很容易求出——对于点阵图中一个被 $k$ 条线段通过的点 $P$，有 $k$ 种颜色可以在这个点上任意交换，贡献因子为 $k!$。所以 $v(\sigma_i)$ 就是所有这样的 $k!$ 的乘积。

&emsp;&emsp;知道这一点，直接 `std::next_permutation`，$\mathcal O(n!\operatorname{poly}(n))$ 就能拿到这档分。

&nbsp;

&emsp;&emsp;**Subtask 2** $(n\le100)$&emsp;注意 $v(\sigma_i)$ 是若干阶乘的乘积，而答案又是所有 $v(\sigma_i)$ 的乘积，所以可以独立地计算每个 $k!$ 对答案的贡献。

&emsp;&emsp;通过枚举两条线段交点，获得一个至少被两条线段经过的点 $P$，再枚举得到可能经过 $P$ 的线段总数 $l$，精细实现可以在 $\mathcal O(n^4\operatorname{polylog}(n))$ 的时间内完成这一步。

&emsp;&emsp;此后，我们预处理 $w(l)$ 表示最多可能 $l$ 条线段经过的点对答案的总贡献。枚举实际经过该点的线段数量，容斥求出这一情况下排列的数量，可以得到

$$
w(l)=\prod_{i=2}^li!^{\binom{l}{i}\sum_{j=0}^{l-i}(-1)^j\binom{l-i}{j}(n-i-j)!}.
$$

&emsp;&emsp;暴力计算即可。注意指数应该对 $\varphi(p)=p-1$ 取模。

&nbsp;

&emsp;&emsp;**Subtask 3/4** $(n\le500~/~n\le5\times10^3)$&emsp;求 $w(l)$ 并不是瓶颈，来看看如何加速 $P$ 的枚举。令 $c(l)$ 表示得到线段总数为 $l$ 的 $P$ 的数量。那么答案可以表示为：

$$
\textit{ans}=\prod_{l=2}^nw(l)^{c(l)}.
$$

&emsp;&emsp;注意到，若已知两直线 $l_1,l_2$ 过 $x=0$ 和 $x=1$ 中间的任意一点 $P$，则 $l_1,l_2,l:x=0$ 围成的三角形 $\triangle_1$ 与 $l_1,l_2,l:x=1$ 围成的三角形 $\triangle_2$ 的相似比是一定的。换言之，若在 $x=0$ 上取 $y$ 升序排列的点 $A_{0..k}$，在 $x=1$ 上取 $y$ 降序排列的点 $B_{0..k}$，且所有直线 $A_iB_i$ 交于一点时，必然存在唯一常数 $k$，使得 $\forall i\neq j,~|A_iA_j|:|B_iB_j|=k$。

&emsp;&emsp;利用这一结论，我们来进一步刻画一个交点 $P$ 被理论最多的交线经过的情况。通过直观感受不难注意到，若存在某个 $i$，使得 $y_{A_{i+1}}-y_{A_i}\neq y_{A_i}-y_{A_{i-1}}$，不妨设 $y_{A_{i+1}}-y_{A_i}>y_{A_{i}}-y_{A_{i-1}}$，那么我们再取一个 $A(0,y_{A_i}+(y_{A_i}-y_{A_{i-1}}))$，对应地有 $B(1,y_{B_i}-(y_{B_{i+1}}-y_{B_i}))$，可以验证 $AB$ 过 $P$，这与 $|\{A_k\}|,|\{B_k\}|$ 的最大性矛盾。因此，$\{A_k\},\{B_k\}$ 中的点的纵坐标应当分别为等差数列。

&emsp;&emsp;再进一步，设 $\{A_k\}$ 中纵坐标的公差为 $d_1~(d_1>0)$，$\{B_k\}$ 中纵坐标的公差为 $d_2~(d_2>0)$。显然，$|\{A_k\}|,|\{B_k\}|$ 的最大性还需要满足：

1. $d_1\perp d_2$。否则还能在中间插入更多整点。

2. 在保证 $y\in[1,n]$ 的情况下，$y_{A_{0..k}}$ 与 $y_{B_{k..0}}$ 无法同时依各自公差向后延伸。否则可以延伸出更多整点。

&emsp;&emsp;第 $2$ 个要求听上去比较麻烦，先不管它。令 $t(l)$ 表示交线数量为 $l$，忽略要求 $2$ 时最大集合对 $(\{A\},\{B\})$ 的数量。那么

$$
t(l)=\sum_{d_1\perp d_2,\\d_1,d_2\le n/(l-1)}(n-d_1(l-1))(n-d_2(l-1)).
$$

&emsp;&emsp;进行一个小巧的容斥。对于任意一个可能不合法的 $(\{A_{k+1}\},\{B_{k+1}\})$，其必然对应两个一定不的合法 $(\{A_k\},\{B_k\})$；对于一个不合法的 $(\{A_k\},\{B_k\})$，若等差数列可以向两种方向一起延伸，则其对应一个可能不合法 $(\{A_{k+1}\},\{B_{k+1}\})$，否则对应两个可能不合法的 $(\{A_{k+1}\},\{B_{k+1}\})$。因而

$$
c(l)=t(l)-2t(l+1)+t(l+2).
$$

&emsp;&emsp;随便乱算一下可以 $\mathcal O(n^2)$ 过掉子任务 3,4，但如果带 $\log$ 被卡常或者写得实在太丑就只有子任务 3 啦。

&nbsp;

&emsp;&emsp;**Subtask 5** $(n\le10^5)$&emsp;一步步来优化。对于 $c(l)$，也即 $t(l)$，利用众所周知的结论

$$
\sum_{i\le n}[i\perp n]i=\frac{1}{2}(\operatorname{id}\cdot\varphi+\epsilon)(n),
$$

可以化出 $\mathcal O(n)$ 的式子。不过这不是瓶颈，所以也大可以 $\mathcal O(n\log n)$ 莫反算。即

$$
t(l)=\sum_{d=1}^{n/(l-1)}\mu(d)\sum_{d_1=1}^{n/(l-1)/d}\sum_{d_2=1}^{n/(l-1)/d}(n-dd_1(l-1))(n-dd_2(l-1)).
$$

&emsp;&emsp;从最终答案入手。最终答案为

$$
\begin{aligned}
    \textit{ans} &= \prod_{l\ge2}w(l)^{c(l)}\\
    &= \prod_{l\ge2}\prod_{i\le l}i!^{c(l)\binom{l}{i}\sum_{j=0}^{l-i}(-1)^j\binom{l-i}{j}(n-i-j)!}\\
    &= \prod_{i=2}^ni!^{\sum_{l\ge i}c(l)\binom{l}{i}\sum_{j=0}^{l-i}(-1)^j\binom{l-i}{j}(n-i-j)!}.
\end{aligned}
$$

&emsp;&emsp;记 $f(i)$ 为 $i!$ 的那一大坨指标，那么

$$
\begin{aligned}
    f(i) &= \sum_{l\ge i}c(l)\binom{l}{i}\sum_{j=0}^{l-i}(-1)^j\binom{l-i}{j}(n-i-j)!\\
    &= \sum_{l\ge i}c(l)\sum_{j=0}^{l-i}(-1)^j(n-i-j)!{\color{red}{\binom{l}{i}\binom{l-i}{j}}}\\
    &= \sum_{l\ge i}c(l)\sum_{j=0}^{l-i}(-1)^j(n-i-j)!{\color{red}{\binom{l}{i+j}\binom{i+j}{i}}}\\
    &= \sum_{j=0}^n(-1)^j(n-i-j)!\binom{i+j}{i}{\color{blue}{\sum_{l\ge i+j}c(l)\binom{l}{i+j}}}~~~~(*)\\
    &= \sum_{j=0}^n(-1)^j(n-i-j)!\binom{i+j}{i}{\color{blue}{g(i+j)}}\\
    &= \frac{1}{i!}\sum_{j=0}^n\frac{(-1)^j}{j!}\cdot(n-i-j)!(i+j)!g(i+j).
    \end{aligned}
$$

&emsp;&emsp;其中 $(*)$ 的最后一个和式是关于 $l$ 与 $l-(i+j)$ 的差卷积，$\mathcal O(n\log n)$ 卷出来得到 $g(i+j)$。最后 $f$ 的形式又是关于 $i+j$ 和 $j$ 的差卷积，因而可以 $\mathcal O(n\log n)$ 求解。

&emsp;&emsp;还没完，$p=335544323$，$p-1$ 显然不可能是素数，而且还有超小因子 $2$，式子里又有 $\frac{1}{i!}$ 这种东西。这怎么卷？放弃了放弃了，随便整点多项式玄学凑合一下。希望能过这档。

&nbsp;

&emsp;&emsp;**Subtask 6** $(n\le10^6)$&emsp;这怎么卷？——天依可是精心挑选了一个有趣的模数！

&emsp;&emsp;注意到 $p-1=2\times 167772161$，因子很少，尝试 CRT 合并出 $f$ 模 $p-1$ 的结果。对于后者，$167772161=5\times2^{25}+1$ 是个 NTT 模数，可以直接算；对于前者，观察最初的式子：

$$
f(i) = \sum_{l\ge i}c(l)\binom{l}{i}\sum_{j=0}^{l-i}(-1)^j\binom{l-i}{j}(n-i-j)!.
$$

&emsp;&emsp;不去动组合数，整个式子没有除法。因而当 $n-i-j>1$ 时 $2\mid (n-i-j)!$，对答案没有影响。所以 $j$ 只可能取 $n-i$ 和 $n-i-1$。相应地，$l\ge i+j$ 也少得可怜，所以可以 $\mathcal O(1)$ 算出 $f(i)\bmod 2$。本题就 $\mathcal O(n\log n)$ 完成啦。

## $\mathscr{Code}$

```cpp
/*+Rainybunny+*/

#include <bits/stdc++.h>

#define rep(i, l, r) for (int i = l, rep##i = r; i <= rep##i; ++i)
#define per(i, r, l) for (int i = r, per##i = l; i >= per##i; --i)

const int MAXN = 1e6, MR = 335544323, MP = 167772161, MC = MR - 1;
int n, c[MAXN + 5], g[MAXN + 5], f[MAXN + 5];
int h[MAXN + 5]; // a temp poly.
int fac[MAXN + 5], ifac[MAXN + 5], pn, pr[MAXN + 5], mu[MAXN + 5];
bool npr[MAXN + 5];

namespace Basic {

} using namespace Basic;

namespace Poly {

} // namespace Poly.

inline void sieve() {

}

inline void init() {

}

int main() {
    scanf("%d", &n);
    Poly::init(), sieve(), init();

    rep (l, 2, n) {
        rep (d, 1, n / (l - 1)) if (mu[d]) { // can be O(n).
            int a = repd / d;
            int s = (((n - d * (l - 1ll))
              + (n - a * d * (l - 1))) * a >> 1) % MC;
            addeqC(c[l], mulC(mu[d], mulC(s, s)));
        }
    }
    rep (l, 2, n) c[l] = subC(addC(c[l], c[l + 2]), mul(2, c[l + 1]));

    rep (i, 0, n) h[i] = ifac[i];
    rep (i, 0, n) g[i] = mul(fac[i], c[i] % MP);
    Poly::polyMulT(n + 1, g, h, g);
    rep (i, 0, n) g[i] = mul(g[i], ifac[i]);

    rep (i, 0, n) h[i] = i & 1 ? sub(0, ifac[i]) : ifac[i];
    rep (i, 0, n) g[i] = mul(mul(fac[n - i], fac[i]), g[i]);
    Poly::polyMulT(n + 1, g, h, f);
    rep (i, 0, n) f[i] = mul(f[i], ifac[i]);
    
    rep (i, 2, n) {
        int s = 0;
        rep (j, n - i - (i < n), n - i) {
            rep (l, i + j, n) {
                s += c[l] & 1 && (l | i) == l && ((l - i) | j) == l - i;
            }
        }
        if ((s & 1) != (f[i] & 1)) f[i] += MP; // mod MC.
    }

    fac[0] = 1;
    rep (i, 1, n) fac[i] = mulR(i, fac[i - 1]); // mod MP initially.
    int ans = 1;
    rep (i, 2, n) ans = mulR(ans, mpowR(fac[i], f[i]));
    printf("%d\n", ans);
    return 0;
}

```



---

## 作者：YeahPotato (赞：6)

&emsp;&emsp;同学打月赛后告诉我有道很离谱的题，遂做，确实挺离谱的，这里讲一下自己做的思路。

## 题意

* 给定 $n$，平面直角坐标系上有点 $(0,0)\sim(0,n-1),(1,0)\sim(1,n-1)$。对于一个 $n$ 排列 $p$，对每个 $i$ 连线段 $(0,i)-(1,p_i)$。
* 考虑从每个横坐标为 $0$ 的点出发，依附于这些线段各走一条折线（或线段）到达一个横坐标为 $1$ 的点，这些折线（或线段）仅能在原先 $n$ 条线段的交点上重合。
* 求所有 $p$ 的方案数之**积**${}\bmod 335~544~323$。
* $n\le 10^6$。

## Step 1

&emsp;&emsp;**方便起见称原题中完美匹配（简称匹配）的连线为 “线段”，染色的折线（或线段）为 “路径”。**

&emsp;&emsp;模拟一些例子，发现三点：

* 路径不会 “往回折” 且线段没有任何部分不被经过。
* 选择一条路径在（最后）一个交点的走向，剩余的东西并没有本质不同，感性地说像是有一个乘法原理。
* 三线段交于同一点和三线段交于三个点的方案数是不同的，也就是说这个几何背景是有用的。

&emsp;&emsp;可以证明第一点：考虑任一横坐标 $x_0$ 满足原先 $n$ 条线段的交点均不在 $x=x_0$ 上，这时原图有 $n$ 个点在 $x=x_0$ 上，而每一条路径至少穿过一次 $x=x_0$。如果有一条路径往回折，那就穿过某个 $x=x_0$ 大于一次，这就不可能存在 $n$ 条两两交长度 $=0$ 的路径了。

&emsp;&emsp;进一步分析，发现一个 “$k$ 线共点” 的情况会对答案贡献 $k!$。因为这个局部相当于一个 $k$ 阶匹配以决定每条路径的走向，且每种方案显然都是合法的。因此最有可能的思路大概就是对于每个可能的交点，求出每种匹配情况下有几条线段经过它，然后阶乘乘起来贡献给答案。当然不能像这样直接算。

&emsp;&emsp;**显然贡献值只取决于该交点最多被几条线段经过**（显然这些线段的端点均不同，所以相当于是一个选择问题），故可以求出 **$w_k$ 表示将所有可能的 $n^2$ 条线段画出后 $k$ 线共点的情况数，$p_k$ 表示一个至多作为 $k$ 条线段交点的点在所有匹配情况下对答案的总贡献**。就有：

$$ans=\prod_{k=2}^n p_k^{w_k}$$

## Step 2

&emsp;&emsp;求 $w_k$。考虑刻画线段交于一点的情况。

![例](https://cdn.luogu.com.cn/upload/image_hosting/xd7iksq2.png)

&emsp;&emsp;（为了美观横过来了）由图中相似关系可见，两边选的相邻点距离要对应成比例。

&emsp;&emsp;第一反应是直接硬着对**极大共点选择（一些线段交于同一点，且不能再多选一条经过该交点的线段**。显然这些线段的端点均不同）计数，官方解法有更方便的容斥做法，这里就算给一个备选方案了。极大共点选择的条件为：

* 两边选的点纵坐标分别成等差数列；
* 不能再往左右扩展；
* 公差互质。

&emsp;&emsp;首先发现互质条件无法直接处理，因此莫反，枚举公差的公因数 $g$，贡献乘 $\mu(g)$ 即可。如果考虑左右部分别长为 $x$ 和 $y$ 的极长等差数列，那么画图可得它们能构成的极大共点选择包括：$2$ 个 $2$ 线共点，$2$ 个 $3$ 线共点，……，$2$ 个 $\min(x,y)-1$ 线共点，$\lvert x-y\rvert+1$ 个 $\min(x,y)$ 线共点。

&emsp;&emsp;那么只需对于每个 $g$，把每种为 $g$ 倍数的公差所能形成的极长等差数列长度及其数量求出来，统计并扫描处理即可。由于一个公差 $d$ 至多只能产生 $\lfloor (n-1)/d\rfloor+1$ 与 $\lfloor (n-1)/d\rfloor$ 两种长度，而扫描可以优化到线性（枚举长较小者，部分细节略去），故这部分可以做到 $\mathrm{O}(n\log n)$。

## Step 3

&emsp;&emsp;直接求 $p_k$ 的思路为：对于每个 $i=1,\cdots,k$，求出**有多少种匹配恰好出现 $i$ 条线段经过该点，记为 $f_i$**，则：

$$p_k=\prod_{i=1}^k (i!)^{f_i}$$

&emsp;&emsp;$f_i$ 无法直接计算，记 **$g_i$ 表示钦定 $i$ 条线段经过该点，其他随便匹配的方案数**（可能会算重）。则：

$$\binom ki(n-i)!=g_i=\sum_{j=i}^k\binom jif_i$$

&emsp;&emsp;二项式反演得：

$$f_i=\sum_{j=i}^k(-1)^{j-i}\binom ji\binom kj(n-j)!$$

&emsp;&emsp;然后就会发现没法快速求出 $p_i$~~（如果有大佬会的能教一下吗/kel~~

## Step 4

&emsp;&emsp;既然没法快速求 $p_i$，那么考虑利用最终只需求一个积这个性质，把所有 $k$ 放在一起求。记：

$$c_i=\sum_{k=i}^nw_k\sum_{j=i}^k(-1)^{j-i}\binom ji\binom kj(n-j)!$$

&emsp;&emsp;则：

$$ans=\prod_{i=2}^n(i!)^{c_i}$$

&emsp;&emsp;而 $c_i$ 是可以快速求的：

$$c_i=\sum_{j=i}^n(-1)^{j-i}\binom ji(n-j)!\left(\sum_{k=j}^n w_k\binom kj\right)$$

&emsp;&emsp;两次差卷积即可。细节略去。

## Step 5

&emsp;&emsp;最后一个问题是 $c_i$ 是在指数上的。注意到原模数为质数 $335~544~323=2^{26}\times 5+3$，因此如果能求出 $c_i$ 模 NTT 质数 $2^{25}\times 5+1$ 与 $c_i$ 的奇偶性即可用 CRT 的思路还原 $c_i\bmod (2^{26}\times 5+2)$。

&emsp;&emsp;一个性质是 $w_i\equiv[i=n]\pmod 2$（显然 $w_n=1$）。这是因为除了两部公差均为 $1$ 的情况，其余所有极大共点选择可以对应其两部交换后的另一个极大共点选择。那么：

$$\begin{aligned}c_i&\equiv\sum_{j=i}^n\binom ji\binom nj(n-j)!\\&\equiv n\binom{n-1}i+\binom ni\\&\equiv(n-i+1)[i\subseteq n]\pmod 2\end{aligned}$$

&emsp;&emsp;最终时间复杂度为 $\mathrm{O}(n\log n)$。

## 代码

&emsp;&emsp;一个优化：两次卷积分别要求类似于 $\text{DFT}(\mathrm{e}^x)$ 以及 $\text{DFT}(\mathrm{e}^{-x})$ 形式的东西，可以省掉一次。共 $5$ 次 DFT。

```cpp
void NTT(int n, int *a, int o) {
	for (int i=0; i<n; i++)
		if (i < f[i]) swap(a[i], a[f[i]]);
	for (int i=1, _; i<n; i<<=1)
		for (int j=0; j<n; j+=i<<1)
			for (int k=j; k<j+i; k++)
				_ = 1ll * g[i][k-j] * a[k+i] % P, a[k+i] = R(a[k], P - _), a[k] = R(a[k], _);
	if (o) {
		reverse (a+1, a+n);
		for (int i=0; i<n; i++)
			a[i] = 1ll * a[i] * I % P;
	}
}
int main() {
	cin >> n;
	for (int i=mu[1]=1; i<=n; i++) if (mu[i])
		for (int j=i<<1; j<=n; j+=i)
			mu[j] -= mu[i];
	for (int i=1; i<n; i++)
		L[i] = (n - 1) / i + 1, C[i] = (n - 1) % i + 1;
	for (int g=1; g<n; g++) {
		if (! mu[g]) continue;
		int m = 0, sl = 0, sc = 0;
		for (int i=g; i<n; i+=g) {
			if (m && l[m-1] == L[i]) c[m-1] = R(c[m-1], C[i]);
			else if (l[m] == L[i]) c[m] = R(c[m], C[i]);
			else l[++m] = L[i], c[m] = C[i];
			if (C[i] < i && L[i] > 2)
				if (l[m] == L[i] - 1) c[m] = R(c[m], i - C[i]);
				else l[++m] = L[i] - 1, c[m] = i - C[i];
		}
		for (int i=1; i<=m; i++) {
			w[l[i]] = (w[l[i]] + ((sl + 1ll * (P - l[i] + 1) * sc << 1) + c[i]) % P * (~ mu[g] ? c[i] : P - c[i])) % P;
			d[l[i]-1] = (d[l[i]-1] + (2ll * sc + c[i]) * (~ mu[g] ? c[i] : P - c[i])) % P;
			sl = (sl + 1ll * l[i] * c[i]) % P, sc = R(sc, c[i]);
		}
	}
	for (int i=n; i>1; i--)
		d[i] = R(d[i], d[i+1]), w[i] = R(w[i], R(d[i], d[i]));
	for (int i=F[0]=1; i<=n; i++)
		F[i] = 1ll * F[i-1] * i % P;
	IF[n] = qpow(F[n], P - 2);
	for (int i=n-1; ~i; i--)
		IF[i] = 1ll * IF[i+1] * (i+1) % P;
	while (m < (n << 1) - 3) m <<= 1;
	I = qpow(m, P - 2);
	for (int i=0; i<m; i++)
		f[i] = f[i>>1] >> 1 | (i & 1 ? m >> 1 : 0);
	for (int i=1; i<m; i<<=1) {
		g[i] = new int [i] {1};
		if (i > 1) {
			g[i][1] = qpow(3, (P - 1) / (i << 1));
			for (int j=2; j<i; j++) g[i][j] = 1ll * g[i][j-1] * g[i][1] % P;
		}
	}
	for (int i=0; i<n-1; i++)
		a[i] = 1ll * F[n-i] * w[n-i] % P, b[i] = IF[i];
	NTT(m, a, 0), NTT(m, b, 0);
	for (int i=0; i<m; i++)
		a[i] = 1ll * a[i] * b[i] % P;
	NTT(m, a, 1);
	for (int i=0; i<m; i++)
		a[i] = i < n - 1 ? 1ll * F[i] * a[i] % P : 0;
	for (int i=0; i<m>>1; i++)
		swap(b[i], b[i|m>>1]);
	NTT(m, a, 0);
	for (int i=0; i<m; i++)
		a[i] = 1ll * a[i] * b[i] % P;
	NTT(m, a, 1);
	for (int i=0; i<n-1; i++)
		c[n-i] = 1ll * IF[n-i] * a[i] % P;
	for (int i=2; i<=n; i++)
		if ((i & n) == i & n - i - 1 & 1 ^ c[i] & 1)
			c[i] += P;
	for (int i=n; i>1; i--) {
		if ((c[i] += c[i+1]) >= P2 - 1) c[i] -= P2 - 1;
		ans = 1ll * ans * qpow_(i, c[i]) % P2;
	} cout << ans;
}
```

---


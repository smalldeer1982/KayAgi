# [省选联考 2023] 填数游戏

## 题目描述

众所周知，Alice 和 Bob 是一对好朋友。今天，他们约好一起玩游戏。

一开始，他们各自有一张空白的纸条。接下来，他们会在纸条上依次写 $n$ 个 $[1,m]$ 范围内的正整数。等 Alice 写完，Bob **在看到 Alice 写的纸条之后开始写他的纸条**。

Alice 需要保证她写下的第 $i$ 个数在集合 $S_{i}$ 中，Bob 需要保证他写下的第 $i$ 个数在集合 $T_{i}$ 中。**题目保证** $1 \leq\left|S_{i}\right|,\left|T_{i}\right| \leq 2$ 。

Alice 喜欢相同，因此，她希望她写下的数与 Bob 写下的数对应位置相同的个数尽量多。Bob 喜欢不同，因此，他希望他写下的 $n$ 个数 $b_{1}, \ldots, b_{n}$ 互不相同。在此基础上，Bob 希望他写下的数与 Alice 写下的数对应位置相同的个数尽量少。

即设 Alice 写下的数为 $a_{1}, \ldots, a_{n}$，Bob 写下的数为 $b_{1}, \ldots, b_{n}$，记 $X$ 为满足 $1 \leq i \leq n, a_{i}=b_{i}$ 的下标 $i$ 的个数，则

- Alice 希望最大化 $X,$
- Bob 在**保证 $b_{1}, \ldots, b_{n}$ 互不相同的前提下**希望最小化 $X$。

你首先想知道 Bob 能否保证他写下的 $n$ 个数互不相同。如果 Bob 能够做到，你想知道**在双方均采取最优策略的前提下** $X$ 的值会是多少。

## 说明/提示

**【样例 1 解释】**

在这组样例中，$S_{1}=\{3\}, S_{2}=T_{1}=\{1,2\}, S_{3}=T_{3}=\{3,4\}, T_{2}=\{2,3\}$。Alice 的填法有 $4$ 种，列举如下：

第一种：$a_{1}=3,a_{2}=1,a_{3}=3$。

第二种：$a_{1}=3,a_{2}=1,a_{3}=4$。

第三种：$a_{1}=3,a_{2}=2,a_{3}=3$。

第四种：$a_{1}=3,a_{2}=2,a_{3}=4$。

由于 Bob 必须保证他所填的数互不相同，所以他有以下填法:

第一种：$b_{1}=1,b_{2}=2,b_{3}=3$。

第二种：$b_{1}=2,b_{3}=3,b_{3}=4$。

第三种：$b_{1}=1,b_{2}=2,b_{3}=4$。

第四种：$b_{1}=1,b_{2}=3,b_{3}=4$。

若 Alice 选择第一种填法，则 Bob 为最小化 $X$，选择第二种填法，得到 $X=0$。

若 Alice 选择第二种填法，则 Bob 为最小化 $X$，选择第一种填法，得到 $X=0$。

若 Alice 选择第三种填法，则 Bob 为最小化 $X$，选择第一种填法，得到 $X=0$。

若 Alice 选择第四种填法，则 Bob 无论选择哪种填法，$X$ 均不小于 $1$。

因此，Alice 为最大化 $X$ 的值，她会选择第四种填法。

**【子任务】**

表格中 $\sum n,\sum m$ 分别表示同个测试点内所有测试数据的 $n$ 总和和 $m$ 总和。 $\sum n^{2}, \sum m^{2}, \sum n^{3}, \sum m^{3}$ 的含义类似。

![](https://cdn.luogu.com.cn/upload/image_hosting/nbt12df0.png)

特殊性质 A：对于任何 $1 \leq i \leq n,S_i$ 和 $T_i$ 互不相交，即 $S_i \cap T_i=\emptyset$。

特殊性质 B：$n \geq 3$，且对于任何 $1 \leq i<n, T_{1} =\{i,i+1\}$，且 $T_{n}=\{n,1\}$。

特殊性质 C：对于任何 $1 \leq i \leq n,|S_i|=1$。

特殊性质 D：对于任何 $1 \leq i \leq n,S_{i}=T_{i}$。

**【提示】**

本题部分测试点读入规模较大，我们建议你采取效率较高的读入方式。

## 样例 #1

### 输入

```
1
3 4
1 3
2 1 2
2 3 4
2 1 2
2 2 3
2 3 4
```

### 输出

```
1
```

## 样例 #2

### 输入

```
见附件中的 game/game2.in```

### 输出

```
见附件中的 game/game2.ans```

## 样例 #3

### 输入

```
见附件中的 game/game3.in```

### 输出

```
见附件中的 game/game3.ans```

## 样例 #4

### 输入

```
见附件中的 game/game4.in```

### 输出

```
见附件中的 game/game4.ans```

## 样例 #5

### 输入

```
见附件中的 game/game5.in```

### 输出

```
见附件中的 game/game5.ans```

## 样例 #6

### 输入

```
见附件中的 game/game6.in```

### 输出

```
见附件中的 game/game6.ans```

## 样例 #7

### 输入

```
见附件中的 game/game7.in```

### 输出

```
见附件中的 game/game7.ans```

## 样例 #8

### 输入

```
见附件中的 game/game8.in```

### 输出

```
见附件中的 game/game8.ans```

## 样例 #9

### 输入

```
见附件中的 game/game9.in```

### 输出

```
见附件中的 game/game9.ans```

# 题解

## 作者：Alex_Wei (赞：32)

#### [P9170 [省选联考 2023] 填数游戏](https://www.luogu.com.cn/problem/P9170)

在 $T_{i, 1}$ 和 $T_{i, 2}$ 之间连边，选择每条边的一端使得选择的点互不相同，则任意连通块满足 $|V| \geq |E|$，否则无解。

每条边 $(u, v)$ 根据 $S_i$ 有四种状态：什么都不选，只选 $u$，只选 $v$，两个都可以选。若 $|S_i\cap T_i| = 0$，则这条边一定不会产生贡献。若 $|S_i\cap T_i| = 1$，则 Alice 一定选择交集里的元素。若 $|S_i\cap T_i| = 2$，则 Alice 可以选择任何一个元素。

**对于 $\boldsymbol{|V| = |E|}$，连通块的形态是基环树**。

对于不在环上的边，Bob 只能选叶向端，因此如果一条边的状态是只选叶向端或两个都可以选，则 Alice 一定会让这条边产生贡献。

对于环上的边：

- 环大小为 $1$，则只要 Alice 可以选就一定产生贡献。
- 环大小大于 $1$，则有两种定向方案。Bob 一定选代价较小的那个，Alice 的目标是让代价较小的方案的代价最大化。设 $c_u, c_v, c$ 分别表示只能选 $u$，只能选 $v$，两个都可以选的边数，相当于求 $\max_{i = 0} ^ c \min(c_u + i, c_v + c - i)$。不妨设 $c_u < c_v$，则当 $c_u + c < c_v$ 时，贡献为 $c_u + c$，否则贡献为 $\lfloor\frac {c_u + c_v + c} 2\rfloor$。

**对于 $\boldsymbol{|V| = |E| + 1}$，连通块的形态是树**。

Bob 有 $|V|$ 种策略：不选连通块中的某个点。设 $f_i$ 表示不选 $i$ 的代价，则 Alice 给一条边定向的影响形如给一侧子树的 $f$ 加 $1$，求 $\min f$ 的最大值。

现在我们只关心未定向的边该如何定向。考虑任意两条未定向的边，设它们分别给 $V_1, V_2$ 的 $f$ 加 $1$。若 $V_1$ 和 $V_2$ 无交，我们可以把这两条边都反向，将 $V_i$ 变成 $V\backslash V_i$。这样至少给每个 $f$ 加了 $1$，一定不劣。

因此，任意两条未定向的边的 $V_i$ 有交，则所有 $V_i$ 的交非空。枚举交集中的某个点 $x$，则所有未定向的边的方案是确定的：以 $x$ 为根的叶向。这样，对应的 $f_i$ 等于 $f_x + mn_{x, i}$，其中 $mn_{x, i}$ 表示 $x$ 到 $i$ 的根向边的数量，减去 $x$ 到 $i$ 的叶向边的数量。

直接枚举 $x$ 并计算 $f_i$，时间复杂度 $\mathcal{O}(n ^ 2)$。

换根时维护以 $x$ 为根的 $f_x$，以及 $x$ 子树内所有 $i$ 的 $mn_{x, i}$ 的最小值。需要预处理以初始 $x$ 为根，每个结点 $i$ 子树内所有 $u$ 的 $mn_{i, u}$ 的最小值和次小值。具体细节根据父亲走向子节点时 $f$ 和 $mn$ 的变化讨论一下即可。

时间复杂度 $\mathcal{O}(n + m)$。


```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

bool Mbe;
constexpr int N = 1e6 + 5;

int n, m, s1[N], s2[N];
struct edge {
  int to, w, id;
  // w = -1: useless
  // w = 0: choose this
  // w = 1: choose to
  // w = 2: any
};
vector<edge> e[N];

int V, E, vv[N], ve[N], deg[N];
vector<int> c;
void dfs(int id) {
  V++, vv[id] = 1, c.push_back(id);
  for(auto _ : e[id]) {
    int it = _.to;
    if(!ve[_.id]) E++, ve[_.id] = 1;
    if(!vv[it]) dfs(it);
  }
}

namespace Cyc { // ez
  int solve() {
    int ans = 0, on = -1;
    queue<int> q;
    for(int id : c) {
      deg[id] = e[id].size();
      if(deg[id] == 1) q.push(id);
      else on = id;
    }
    while(!q.empty()) { // let's toposort!
      int t = q.front();
      q.pop(), V--;
      for(auto _ : e[t]) {
        int it = _.to;
        if(deg[it] > 1) {
          ans += _.w == 0 || _.w == 2;
          if(--deg[it] == 1) q.push(it);
          else on = it;
        }
      }
    }
    if(V == 1) {
      for(auto _ : e[on]) {
        int it = _.to;
        if(on == it) {
          ans += _.w >= 0;
          break;
        }
      }
    }
    else {
      int c0 = 0, c1 = 0, c2 = 0;
      int cur = on, lst = 0;
      while(V--) {
        for(auto _ : e[cur]) {
          int it = _.to;
          if(deg[it] == 1) continue;
          if(_.id == lst) continue;
          if(_.w == 0) c0++;
          if(_.w == 1) c1++;
          if(_.w == 2) c2++;
          cur = it, lst = _.id;
          break;
        }
      }
      if(c0 > c1) swap(c0, c1);
      if(c0 + c2 <= c1) ans += c0 + c2;
      else ans += (c0 + c1 + c2) / 2;
    }
    return ans;
  }
}

namespace Tree { // 2 hard 4 me
  int f[N], g[N], mn[N], smn[N], gmn[N];
  void dfs1(int id, int ff) {
    f[id] = g[id] = mn[id] = smn[id] = gmn[id] = 0;
    for(auto _ : e[id]) {
      int it = _.to;
      if(it == ff) continue;
      dfs1(it, id);
      f[id] += f[it];
      if(_.w > 0) f[id]++;
      int v = mn[it];
      if(_.w == 0) v++;
      if(_.w > 0) v--;
      if(v < mn[id]) smn[id] = mn[id], mn[id] = v;
      else if(v < smn[id]) smn[id] = v;
    }
  }
  void dfs2(int id, int ff) {
    gmn[id] = min(gmn[id], 0);
    for(auto _ : e[id]) {
      int it = _.to;
      if(it == ff) continue;
      g[it] = g[id] + f[id] - f[it] - (_.w > 0);
      if(_.w == 0 || _.w == 2) g[it]++;
      int v = mn[it];
      if(_.w == 0) v++;
      if(_.w > 0) v--;
      gmn[it] = min(gmn[id], v == mn[id] ? smn[id] : mn[id]);
      if(_.w == 0 || _.w == 2) gmn[it]--;
      if(_.w == 1) gmn[it]++;
      dfs2(it, id);
    }
  }
  int solve() {
    dfs1(c[0], 0), dfs2(c[0], 0);
    int ans = 0;
    for(int id : c) ans = max(ans, f[id] + g[id] + min(mn[id], gmn[id]));
    return ans;
  }
}

void solve() {
  cin >> n >> m;
  for(int i = 1; i <= m; i++) e[i].clear(), vv[i] = 0;
  for(int i = 1; i <= n; i++) {
    ve[i] = 0;
    int sz;
    cin >> sz >> s1[i];
    if(sz == 1) s2[i] = -1;
    else cin >> s2[i];
  }
  for(int i = 1; i <= n; i++) {
    int sz, x, y = -1;
    cin >> sz >> x;
    auto add = [&](int u, int v, int w) {
      e[u].push_back({v, w, i});
    };
    if(sz == 1) {
      if(s1[i] == x || s2[i] == x) add(x, x, 0), add(x, x, 0);
      else add(x, x, -1), add(x, x, -1);
    }
    else {
      cin >> y;
      if(s2[i] == -1) {
        if(s1[i] == x) add(x, y, 0), add(y, x, 1);
        else if(s1[i] == y) add(x, y, 1), add(y, x, 0);
        else add(x, y, -1), add(y, x, -1);
      }
      else {
        if(s1[i] > s2[i]) swap(s1[i], s2[i]);
        if(x > y) swap(x, y);
        if(s1[i] == x && s2[i] == y) add(x, y, 2), add(y, x, 2);
        else if(s1[i] == x || s2[i] == x) add(x, y, 0), add(y, x, 1);
        else if(s1[i] == y || s2[i] == y) add(x, y, 1), add(y, x, 0);
        else add(x, y, -1), add(y, x, -1);
      }
    }
  }

  int ans = 0;
  for(int i = 1; i <= m; i++) {
    if(e[i].empty() || vv[i]) continue;
    V = E = 0, c.clear(), dfs(i);
    if(V < E) return cout << "-1\n", void();
    if(V == E) ans += Cyc::solve();
    else ans += Tree::solve();
  }
  cout << ans << "\n";
}

bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("game.in", "r", stdin);
    FILE* OUT = freopen("game.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin >> T;
  while(T--) solve();
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
/*
g++ game.cpp -o game -std=c++14 -O2 -DALEX_WEI
*/
```

---

## 作者：luogubot (赞：18)

Alice 和 Bob 玩游戏，初始各自有一张空白的纸条。接下来，他们会在纸条上依次写 $n$ 个 $[1,m]$ 范围内的正整数。等 Alice 写完，Bob **在看到 Alice 写的纸条之后开始写他的纸条**。

Alice 需要保证她写下的第 $i$ 个数在集合 $S_{i}$ 中，Bob 需要保证他写下的第 $i$ 个数在集合 $T_{i}$ 中。**题目保证** $1 \leq\left|S_{i}\right|,\left|T_{i}\right| \leq 2$ 。

设 Alice 写下的数为 $a_{1}, \cdots, a_{n}$，Bob 写下的数为 $b_{1}, \cdots, b_{n}$，记 $X$ 为满足 $1 \leq i \leq n, a_{i}=b_{i}$ 的下标 $i$ 的个数，则

- Alice 希望最大化 $X,$
- Bob 在**保证 $b_{1}, \cdots, b_{n}$ 互不相同的前提下**希望最小化 $X$。

你首先想知道 Bob 能否保证他写下的 $n$ 个数互不相同。如果 Bob 能够做到，你想知道**在双方均采取最优策略的前提下** $X$ 的值会是多少。

$\sum n,\sum m\leq 1.5\times 10^6$。

部分分：$O(n^2)$，A：$S_i\cap T_i=\varnothing$，B：$T_i=\{i,(i\bmod n)+1\}$，C：$|S_i|=1$，D：$S_i=T_i$。

首先判断无解。即每个位置二选一/固定，问是否能互不相同，固定可以看作两个相同的数二选一，于是在每个位置的两种取值之间连边，表示一条边必须独占某一个端点，那么只要每个连通块的点数 $\leq$ 边数，即形成树结构或基环树结构就有解，可以用并查集解决这部分，解决特殊性质 A。

有了连边变为基环树或树结构之后，特殊性质 B 保证了连出来的是一个大环，那么 $\{b\}$ 显然只有两种，所以 Alice 在每一位的决策分为 没有贡献、给 $A$ 加一、给 $B$ 加一、给 $A$ 或 $B$ 加一，目标是最大化 $\min(A,B)$，枚举最后一类操作的分配可以解决。

有了特殊性质 B，我们就可以快速解决所有基环树了，因为后手只有两种决策，且基环树的非环部分的值是固定的，那么后续只需要考虑树的贡献。

对于树，Bob 的决策有 $n$ 种，即给这棵无根树定根变为内向树，每条边对应选的点就是它的起始点。类似地，我们也刻画 Alice 的决策为给所有 $|S_i\cap T_i|=2$ 的边定向，且 $|S_i\cap T_i|=1$ 的边就是已经定向完成的。Alice 首先完成定向过程，然后 Bob 在 $n$ 个根中取最优的，这样我们就把原问题完全转为了**树上问题**。考虑特殊性质 C 的 $|S_i|=1$，它保证了所有边如果可能有贡献，那么 Alice 的定向已经完成，只需要对每个点计算以其为根会有多少边的方向重合，发现一条定向好的边 $u\to v$ 会对树上以 $u$ 为根 $v$ 的子树的贡献全部加一，最终求所有点的最小值作为 Bob 的决策。容易用 dfn 序上差分解决 C 性质。

接下来需要考察 Alice 的策略，否则就只有指数级枚举其策略了。常见方向是通过一些分析**丢掉一定更劣的策略以缩小决策范围**。考虑 Alice 主动定向的两条边如果出现了“背向而行”的情况，即 $v_1,v_2\notin \operatorname{Path}(u_1,u_2)$，此时同时调转这两条边的方向，则 $\operatorname{Path}(u_1,u_2)$ 中的点贡献全部加二，一定更优。那么 Alice 的决策中一定不会有这样的情况，那么其结构一定是指定一个根，所有边都指向根的方向；假设实际最优决策在指定的某个根的情况下存在一条不指向根的边，那么把当前的根向对应方向移动（一定唯一，否则存在上述情况）直到不存在就能满足上述要求。换言之，这样的 $n$ 个决策中一定包含最优决策，最优决策也一定能找到这样的根通过上述方式生成。

至此我们至少得到了 $O(n^2)$ 的做法，即枚举根，套用性质 C 的差分，并且对于性质 D，Alice 决定根之后，Bob 选择的最小值一定为 $n$ 减去最大子树的 size，可以 $O(1)$ 计算，那么已经可以拿到 80 分了。 接下来的优化也很轻松，即在树上 dfs 枚举根，经过一条 Alice 可以定向的边的时候将其反向并结算贡献，可以用线段树区间加、查全局最小值做到 $O(n\log n)$，可以通过本题。


---

## 作者：ducati (赞：7)

## Description

[传送门](https://www.luogu.com.cn/problem/P9170)

## Solution

先转化为图论模型。$\forall i \in [1,n]$，若 $|T_i|=1$，设 $T_i=\{x\}$，则连一条 $x \to x$ 的自环；否则（$|T_i|=2$），设 $T_i=\{u,v\}$，则将 $u,v$ 用双向边连接，得到一张 $m$ 个点的无向图。根据鸽巢原理，若存在连通块的边数 $>$ 点数，则一定无解。否则，图由若干独立的**树**和**基环树**构成。

先处理基环树。此时，Bob 需要将各边定向，使各点度数 $\le 1$。将环上的点依次取出，不妨设为 $p_1,p_2,\cdots,p_k$。那么，环内有两种定向方案，环外各边只能由距环较近的点连向较远的点。设两种方案对应的 $X$ 分别为 $A,B$，有时 Alice 只能将 $A$ 加 $1$，有时只能将 $B$ 加 $1$，有时必须将 $A,B$ 均加一，有时可将 $A$ **或** $B$ 加 $1$，目标是最大化 $\min(A,B)$。先处理前三种情况，再贪心地处理第四种，每次将 $A,B$ 中的较小者加一即可。特别的，若环长 $=1$（即为自环），那么只有一种定向方法，直接计算即可。

再处理树。此时，Bob 需要选一个点 $rt$，定向成一棵以 $rt$ 为根的**外向树**，不妨设其对应的 $X$ 为 $w_{rt}$。有时 Alice 只能将 $u$ 子树内的 $w$ 加 $1$（其中 $u$ 是任意树上的点），有时只能将 $u$ 子树外的 $w$ 加 $1$，有时可将 $u$ 子树内**或**子树外的所有 $w$ 加 $1$，目标即最大化 $\min \{w\}$。先处理前两种情况，计算出当前的 $w$，关键在于第三种情况。

为方便叙述，我们称对 $u$ 进行了 $\lceil$ 一类决策 $\rfloor$，当且仅当将 $u$ 子树内的 $w$ 加了 $1$；$\lceil$ 二类决策 $\rfloor$，即将 $u$ 子树外的 $w$ 加了 $1$。不难发现以下性质：

- 若 $x$ 是 $y$ 的祖先，对 $x$ 进行了二类决策且对 $y$ 进行了一类决策，则一定不优，可以转而对 $x$ 进行一类决策，对 $y$ 进行二类决策。
- 若 $x$，$y$ 无祖先后代关系，对 $x,y$ 均进行了一类决策，则一定不优，可以转而对 $x,y$ 均进行二类决策。

根据以上的分析，不难发现：一定存在一条从树根出发的链，使得其中每个点都进行了一类决策。

在树上进行 dfs，动态维护所有点的 $w$，支持子树加减，查询整体最值。将树拍平后用线段树维护即可，时间复杂度 $O(n \log n)$。

考场想法，但来不及实现，码力太菜了。

## Code

```cpp
#include <bits/stdc++.h>
#define eb emplace_back
using namespace std;
const int N=1e6+5;

namespace IO{
	inline char nc(){
		static char buf[500001],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,500000,stdin),p1==p2)?EOF:*p1++;
	}
	char out[500001],*pout=out,*eout=out+500000;
	template<typename T> inline T read(){
		char ch=nc(); T sum=0; bool f=false;
		for(;ch<'0'||ch>'9';ch=nc()) if(ch=='-') f=1;
		while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();
		return f ? -sum : sum;
	}
}
#define read IO::read<int>

int m,n,ce,ti,Fail,P,Q,ans,Free,tag_sum,du[N],dv[N],st[N],ed[N],cid[N];
int head[N],anc[N],w[N],spc[N],in_tag[N],out_tag[N]; vector<int> A[N],B[N];
struct edge{int nxt,to,id;}e[N<<1];
struct DS{
	#define L (rt<<1)
	#define R (rt<<1|1)
	int tr[N<<2],tag[N<<2],tw[N];
	void F(int rt,int k){tr[rt]+=k,tag[rt]+=k;}
	void pushup(int rt){tr[rt]=min(tr[L],tr[R]);}
	void pushdown(int rt){if(tag[rt])F(L,tag[rt]),F(R,tag[rt]),tag[rt]=0;}
	void build_tree(int l,int r,int rt){
		tag[rt]=0;
		if (l==r)  tr[rt]=tw[l];
		else{
			int mid=(l+r)>>1;
			build_tree(l,mid,L);
			build_tree(mid+1,r,R);
			pushup(rt);
		}
	}
	void change(int nl,int nr,int l,int r,int rt,int k){
		if (nl<=l&&r<=nr) {F(rt,k);return;}
		pushdown(rt);

		int mid=(l+r)>>1;
		if (nl<=mid)  change(nl,nr,l,mid,L,k);
		if (nr>mid)  change(nl,nr,mid+1,r,R,k);
		pushup(rt);
	}
}SGT;
int Count(int id,int v){
	for (int x:A[id]){
		if (x==v)  return 1;
	}
	return 0;
}
int Find(int x){return(anc[x]==x)?x:(anc[x]=Find(anc[x]));}
void add_edge(int u,int v,int w){e[++ce]=edge{head[u],v,w},head[u]=ce;}
void Add(int x,int y,int id){
	int fx=Find(x),fy=Find(y);
	if (fx^fy){
		anc[fx]=fy;
		if (du[fx]&&du[fy])  Fail=1;
		else{
			add_edge(x,y,id),add_edge(y,x,id);
			if (!du[fy])  du[fy]=du[fx],dv[fy]=dv[fx],cid[fy]=cid[fx];
		}
	}
	else{
		if (du[fx])  Fail=1;
		else du[fx]=x,dv[fx]=y,cid[fx]=id;
	}
}
void Read(vector<int> &v){
	int sz=read(); v.resize(sz);
	for (int i=0;i<sz;i++)  v[i]=read();
}
void upd_PQ(int u,int v,int id){
	auto Deal=[&](int x){
		if (x==v)  P++;
		else if (x==u)  Q++;
	};
	if (A[id].size()==1u)  Deal(A[id][0]);
	else{
		int x=A[id][0],y=A[id][1];
		if ((x==u&&y==v)||(x==v&&y==u))  Free++;
		else Deal(x),Deal(y);
	}
}
bool dfs_cir(int u,int F,int tmn){
	bool flg=(u==tmn);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v==F)  continue;
		if (dfs_cir(v,u,tmn))  upd_PQ(u,v,e[i].id),flg=1;
		else if (Count(e[i].id,v))  P++,Q++;
	}
	return flg;
}
void dfs_init(int u,int F){
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v==F)  continue;
		auto Deal=[&](int x){
			if (x==v)  out_tag[v]++,tag_sum++;
			else if (x==u)  in_tag[v]++;
		};
		int id=e[i].id;
		if (A[id].size()==1u)  Deal(A[id][0]);
		else{
			int x=A[id][0],y=A[id][1];
			if ((x==u&&y==v)||(x==v&&y==u))  spc[v]=1,out_tag[v]++,tag_sum++;
			else Deal(A[id][0]),Deal(A[id][1]);
		}
		dfs_init(v,u);
	}
}
void calc_out(int u,int F,int sum){
	sum+=out_tag[u],w[u]=tag_sum-sum;
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v^F)  calc_out(v,u,sum);
	}
}
void calc_in(int u,int F,int sum){
	w[u]+=(sum+=in_tag[u]);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v^F)  calc_in(v,u,sum);
	}
}
void calc_w(int u,int F){
	SGT.tw[st[u]=(++ti)]=w[u];
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v^F)  calc_w(v,u);
	}
	ed[u]=ti;
}
void dfs_solve(int u,int F){
	if (spc[u])  SGT.F(1,-1),SGT.change(st[u],ed[u],1,ti,1,2),P=max(P,SGT.tr[1]);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v^F)  dfs_solve(v,u);
	}
	if (spc[u])  SGT.F(1,1),SGT.change(st[u],ed[u],1,ti,1,-2);
}
int solve(){
	m=read(),n=read(),Fail=ans=ce=0;
	for (int i=1;i<=n;i++)  anc[i]=i,du[i]=head[i]=w[i]=spc[i]=in_tag[i]=out_tag[i]=0;
	for (int i=1;i<=m;i++)  Read(A[i]);
	for (int i=1;i<=m;i++)  Read(B[i]),Add(B[i][0],B[i].back(),i);
	if (Fail)  return -1;
	for (int rt=1;rt<=n;rt++)if(Find(rt)==rt){
		if (du[rt]){
			int x=du[rt],y=dv[rt]; P=Q=Free=0,dfs_cir(x,0,y);
			if (x^y)  upd_PQ(y,x,cid[rt]);
			else ans+=Count(cid[rt],x);
			while (Free--){
				if (P<Q)  P++;
				else Q++;
			}
			ans+=min(P,Q);
		}
		else{
			tag_sum=0,dfs_init(rt,0),calc_out(rt,0,0),calc_in(rt,0,0);
			ti=0,calc_w(rt,0),SGT.build_tree(1,ti,1);
			P=SGT.tr[1],dfs_solve(rt,0),ans+=P;
		}
	}
	return ans;
}
int main(){
	freopen("game.in","r",stdin);
	freopen("game.out","w",stdout);
	int T=read();
	while (T--)  printf("%d\n",solve());
	return 0;
}
```

---

## 作者：隔壁泞2的如心 (赞：4)

以下是考场思路。

首先，这是一道图论题。把 $T$ 集合抽象成边，大小为 $1$ 的集合就是自环。然后要是有个连通块边比点多那肯定就完蛋了。

然后每个连通块要么是树要么是基环树，基环树应该简单所以先想树。再来看 $S$ 集合，我们只考虑 $S_i$ 和 $T_i$ 的交集，稍微转化一下可以将题意转化为：

> 有一个树，有的边上有方向规定，B 要给每条边定向使其成为一棵内向树使得违反的规则尽可能少，在这之前 A 可以决定部分边上的规定使得 B 违反尽可能多的规则。

先随便抽出一个点为根，那么 B 要是选择其他根，实质上就是反转了这两个点之间的链。那我们就可以 dp A 的选择了，设 $dp_{i,j,k}$ 表示确定了以 $i$ 为根的子树、B 选择把根放到这棵子树里最多可能少违反 $j$ 个规则、你摆放的外向边数数量为 $k$ 的状态是否存在。最终的答案就是所有存在的 $dp_{1,j,k}$ 中 $j-k$ 的最大值。实现的时候可以只记录 $i,j$ 相同的状态里 $k$ 最大的，这是一个 $O(n^2)$ 的 dp。

这个 dp 据说形态良好，可以维护凸包直接得出答案，不过这有些复杂，我们还可以进一步发掘性质。考虑这个 dp 所有状态的三种转移：

合并两个子树：$dp_{i_1,j_1,k_1},dp_{i_2,j_2,k_2} \to dp_{i,\max(j1,j2),k1+k2}$

接上一个内向边：$dp_{s,j,k}\to dp_{i,\max(j-1,0),k}$

接上一个外向边：$dp_{s,j,k}\to dp_{i,j+1,k+1}$

我们发现，假如说我们同时选择在两个不同的子树里接上内向边，那么由于 $j$ 的合并是 $\max$ ，还是只会省下一份 $j$ （令 $j$ 比原先减少了 $2$），但是 $k$ 也确确实实减少了 $2$，那么 $k-j$ 就不变了，这样也就得不偿失，所以我们可以猜测最后每个节点都只会有一个子树里面有特意安放的内向边。

这样的话，特意安放的内向边只会在一个从根开始的链上，我们接着感性分析，猜测这样的边会尽可能靠近根，以防好不容易减下来的 $j$ 被 $\max$ 掉。

此时我们就有一个很强的结论了：A 的决策一定是选择一个点，然后以这个点为根为根将所有可以调的边全部设定成外向的！那这个点是什么呢？不重要。我们可以通过换根的方式统计出所有点的答案，然后取最优即可。

那这个题就做完了……吗？？还有基环树呢。

这也能难倒人吗？B 在基环树里只有环上有选择，要么顺时针要么逆时针直接看哪个违反的规则少就行，那 A 就让两种情况尽可能平均，你找到环不就做完了？

然后我确实在考场上没能写出来找环。这个玩意实在是太难写了，参见讨论区（

就这样，我遗憾离场了。

这道题其实不算很难，推法也有很多种。如果我能写完它，进队也就稳了，可惜没有如果。我写过的比这题还长的代码不超过 $10$ 个，没法指望啊……

最后这个题的输出没有出锅，我还是拿到了 A 性质的分数。这是我学 OI 以来的线下考试里第一个得了分的 T2，纪念一下吧（

---

## 作者：why_cb (赞：3)

~~这道题让我意识到了我码力有多么的差。~~

我们先看特殊性质 A，发现是判断有无合法情况。

我们可以把每次 Bob 的选择看成一条无向边，所连接的两个点就是 Bob 可以选的点，如果只有一个就连自环。

这样我们成功的转化成了一个图论问题：**即每条边选择一个点，每个点只属于一条边。**

**当且仅当这张图是一个树和基环树的森林时有合法情况。**

用并查集维护即可。

接下来我们加入 Alice 的决策，我们可以把一条无向边拆成两条带权有向边，选一个点代表选它的出边，如果在 Alice 的对应集合中，边权为 1，否则边权为 0。如果两个点都可以选，那么 Alice 仅能选择一个点。

问题又被转化成：**对于上述 Alice 的所有选择方案，Bob 所有合法选择方案中最大值最小（博弈的性质）的方案。**

对于一棵树，必定且仅有有一个点不选；

对于一个基环树，所有的点都被选。

然后我们开始统计答案。

- **基环树**

可以发现对于挂在环上的树，所有的边都选下面的点，对于集合相等的边 Alice 肯定都选下面的点。

对于环上有且仅有顺时针和逆时针两种方案，先不管集合相等的边，统计两个的答案，在分配集合相等的边，是两种情况最小值最大，那么最小值就是答案。

~~没怎么写过图论，比较史山。~~


```cpp
	int dfs1(int u,int from)//找环，注意传入边而不是 fa
    {
        if(in[u])
        {
            int t=top;
            while(top&&st[top]!=u) r[st[top]]=true,top--;
            r[u]=true;
            return u;
        }
        in[u]=true;
        st[++top]=u;
        for(int i=head[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if((i^1)==from) continue;
            int t=dfs1(v,i);
            if(t) return t;
        }
        in[u]=false;
        top--;
        return 0;
    }
    void dfs2(int u,int from)//统计两种情况以及环上集合相等的边的数量
    {
        bool f=false;
        if(u==rt&&from) return;
        for(int i=head[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if((f&&r[v])||(i^1)==from) continue;
            if(r[v])
            {
                f=true;
                if(e[i].w&&e[i^1].w&&v!=u) both++;
                else rans1+=e[i].w,rans2+=e[i^1].w;
            }
            else ans+=e[i^1].w;
            dfs2(v,i);
        }
    }
	void solve1()
    {
       top=0;
       rt=dfs1(rt,0);
       dfs2(rt,0);
       if(rans1<rans2) swap(rans1,rans2);
       if(rans2+both<=rans1) ans+=rans2+both;//最小值最大
       else ans+=(rans1+rans2+both)/2;
    }
```

- **树**

同样可以发现：**在树上，对于不选的那个点，它往上到根的边都选上面的点，其它边都选下面一个点。**

所以，如果不选的点确定，那么对于 Alice 的一种选点情况可以确定答案，而 Alice 要选择一种合法选点情况，使得 Bob 的所有合法情况中最小值最大。

那么对于集合相等的边，Alice 到底选上面的点还是下面的点才能使最小值最大呢？

我们可以使用**贪心调整来确定最终答案**。

我们先假设对于集合相等的边，Alice 全选下面的点，然后 dfs 统计出每个点不选的答案计为这个点的权值 $val$，然后在通过将选下面的点的一些边，改成选上面的点来调整点的 $val$（称作一次“翻转”）,使最后最小的 $val$ 最大。

我们可以发现：一次翻转操作，**可以使这条边下面所有的点的 $val+1$，其它点的 $val-1$。**

于是问题转化成了：**给定一棵有根树，每个点上有一个权值，在一些点上有一个操作必须执行，对于每个操作要么将子树内点的权值加一，要么将子树外点的权值加一，使操作后的最小值最大。**

我们让所有操作一开始均为后者，然后我们就开始贪心。

因为最小值最大，所以一开始的最小值一定要被调整，否则答案就是一开始的最小值。
我们找到一开始的最小值的点 $u$,然后我们发现，如果有不止一个最小值，**那么只能翻转它们公共 LCA 到根上的操作**，否则翻转后最小值会变小，而且我们还可以发现，在这些合法操作中，先操作深度小的必定不劣。

于是就有以下思路：对于第一遍 dfs 在求每个点初始权值时同时求最小的那个点以及每个点除了最小点的那棵子树其它子树与本身的最小值，以及通往那个最小点的子树和可以操作的边（即集合相等的边）。然后在做第二遍 dfs，从根到最小点集合相等的边依次进行翻转，将当前最小点所在子树外的最小值减一，最小值所在的子树加一，直到最小值加一大于子树外的最小值减一，当前的最小值即为答案。

```cpp
 	pii dfs3(int u,int fa,int val)//第一遍 dfs
    {
        pii res={val,u};
        for(int i=head[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if(v==fa) continue;
            b[v]=(e[i].w==1&&e[i^1].w==1);
            ans+=(e[i^1].w==1);
            pii t=dfs3(v,u,val+e[i].w-e[i^1].w-b[v]);
            if(t.first<res.first) to[u]=v,Min2[u]=res.first,res=t;
            else if(t.first<Min2[u]) Min2[u]=t.first;
        }
        if(u==rt) Min=res;
        return res;
    }
    int dfs4(int u,int val,int up)//第二遍 dfs
    {
        if(u==Min.second) return Min.first;
        val=min(val,Min2[u]+up);
        if(b[to[u]])
        {
            if(val-1<Min.first+1) return Min.first;
            Min.first++;
            val--;
            return dfs4(to[u],val,up+1);
        }
        else return dfs4(to[u],val,up);
    }
    void solve0()
    {
        dfs3(rt,0,0);
        ans+=dfs4(rt,INF,0);
    }
```

合起来就是最终答案，时间复杂度 $O(n+m)$。

---

## 作者：hxhhxh (赞：3)

## 题意

Alice 和 Bob 各有 $n$ 个集合，值域 $m$，两人各从每个集合里选一个数组成两个长为 $n$ 的序列 $a_{1\dots n}$，$b_{1\dots n}$。

Alice 先选，Bob**看到 Alice 选的数**后再选。记 $X=\sum[a_i=b_i]$，Alice 希望最大化 $X$，Bob 希望在保证 $b$ 中元素**互不相同**的前提下最小化 $X$，两人都聪明绝顶，求最终的 $X$。

**集合大小不超过** $2$，多测，$\sum n,\sum m\leq 1.5\times 10^6$。Bob 无法保证 $b$ 互不相同时输出`-1`。

## 思路

几乎是考场想法。

由于集合大小不超过 $2$，所以可以转化为从两个数中选一个。在第 $i$ 个位置上，设 Alice 能选的两个数分别为 $s_{i,0/1}$，Bob 能选的两个数分别为 $t_{i,0/1}$。

首先手玩一下，发现 Bob 的选数方案一般远小于 Alice 的，~~并且 Bob 的主观能动性大一些~~，所以从 Bob 的选数方案入手。

由于第 $i$ 个数要选 $t_{i,0}$ 或 $t_{i,1}$ 中的一个，我们可以把 $t_{i,0}$，$t_{i,1}$ 之间连一条边（不忽略自环），然后 Bob 要做的就是将每条边定向，使得每个点入度最多为 $1$； Alice 的决策相当于在每一条边上写 $s_{i,0/1}$；如果一条边指向的数和边上面的数相等，那么对 $X$ 有 $1$ 的贡献。

如果一个连通块内的边数大于点数，那么 Bob 无论如何都无法满足要求，输出`-1`，否则这个连通块要么是颗树，要么是个基环树。容易发现每个连通块独立，所以我们把每个连通块分开考虑。

在分类讨论之前，先考虑一下 Alice 的决策。如果 Bob 定向后一条边指向的点等于 Alice 在上面写的数，那么对 $X$ 有 $1$ 的贡献。显然，Alice 只想写 $t_{i,0/1}$，不然不可能有用。那么，边可以分为三类：$t_{i,0/1}$ Alice 都可以选（称为 1 类边）；$t_{i,0/1}$ 中 Alice 只能选一个（称为 2 类边）；都不能选（称为 3 类边）。

### 基环树

这种情况相对容易，因为定向后环部分一定是个有向环，剩下的部分是外向树。外向树的部分 Bob 的决策唯一，可以提前贪心处理。

现在只剩环上的点了。Bob 有两种方式来将环定向，对应两种决策。Alice 的目标是最大化两种选法中的 $X$ 最小值。

随便将某个方向定为正向，那么 2 类边会对正向或逆向中的一个方向造成贡献。为了用 1 类边最大化最小值，Alice 应该让两个方向的贡献尽可能平均。这个可以简单计算。

### 树

这种情况中 Bob 不再只有很少种决策。Bob 可以选择一个点，并以它为根，将边定向为外向树。记 Bob 选 $i$ 为根时 $X=c_i$，则 Alice 可以改变 $c$，目标是最大化 $\min c_i$ 。

先随便定一个根，并在边端点中深度较深的点处计算贡献，钦定 $dep_{t_{i,0}}<dep_{t_{i,1}}$，考虑 Alice 的决策对 $c$ 的影响：

- 3 类边是废物；
- 2 类边对子树内（$s_{i,0/1}=t_{i,0}$）或外（$s_{i,0/1}=t_{i,1}$）的点有 $1$ 的贡献；
- 1 类边可以自由选择对子树内还是子树外产生 $1$ 的贡献。

提前把 2 类边对树上每个点对 $c$ 的贡献算出来，先预设所有的 1 类边都选择对子树外贡献。称 $\;$ _把 1 类边从选择贡献子树外变为选择贡献子树内_ $\;$ 为在儿子处的操作。重复以下过程：

- 找到最小值的位置，设之为 $x$（线段树）；
- 用 $c_x$ 更新答案；
- 找到 $x$ 的祖先（包括 $x$）中可操作的中深度最浅的点并操作（下面说）。
- 如果 $x$ 祖先（包括 $x$）中没有可以操作的，结束。

倒数第二步可以重复以下操作：

- 向上找到最浅的没有试图操作过的点（倍增）；
- 如果 $x$ 及 $x$ 上面没有未被操作的点，结束；
- 试图操作它；
- 如果它成功被操作，结束。

这样贪心为什么是对的呢？首先，Bob 会选贡献最小的点，所以用最小值更新答案是对的~~（废话）~~；然后，要让答案可能增加，必须让 $c_x$ 变大，必须选择一个 $x$ 的祖先来操作；同时，被尝试操作的点的所有祖先都一定被尝试操作过，所以倍增是对的；最后，操作深度较浅的点比操作深度较深的点更优。

每个点最多被尝试操作一次，每次尝试都要一次线段树查询，若干次线段树修改（可能要），一次倍增，所以复杂度也是对的。

### 总结

将基环树和树的答案都分别算出来后，就可以把它们的答案简单地加起来得到答案。

时间复杂度：$\mathrm O(\sum n\log n)$（默认 $n,m$ 同阶）。

### 注意事项

都是[我错过的](https://www.luogu.com.cn/paste/r3xrxb0t)。

- 由于要拆开计算，编号可能会很乱（树上要拍成dfn序，基环树上要找环）；
- 小心自环和二元环；
- 小心一个点的树；
- 各种各样的初始化，注意 $T\leq 1.5\times 10^6$（各种各样）；
- 倍增不要只跳 $18$ 步；
- 点数最多是 $\min(2n,m)$ 的；

## 代码

有点长，放在[这里](https://www.luogu.com.cn/paste/e3fobh85)了。

---

## 作者：Petit_Souris (赞：2)

超级无敌炫酷原神大王，后面忘了。

最近突然觉得在 NOI 之前把之前的历史遗留天坑都给填了比较好，结果这题一填就是一整天，简直是生气了。现在这份代码还在被卡常憋屈致死，真是没救了。

所以这题为啥只有紫，我觉得无论是思考过程还是代码难度都很难啊 /ll。

你可以通过各式各样的暴力搜索获得 $20$ 分。

首先初步进行一些分析：对于先手 Alice，如果 $|S_i\cap T_i|=0$，那么 Alice 无论选什么都不对答案造成贡献；如果 $|S_i\cap T_i|=1$，那么 Alice 一定要选交集的那个元素才有可能产生贡献；如果 $|S_i\cap T_i|=2$，那么 Alice 两个都有可能选，还不确定。

这样看来从 Alice 入手并不是很好的选择。我们考虑一下 Bob 的策略。由于 Bob 有选出的数互不相同这一限制，就产生了无解的情况。我们先从性质 A 开始思考，即判断是否有解。

首先，对于 $|T_i|=1$ 的部分，$b_i$ 只能取 $T_{i}$ 中唯一的元素。填完 $|T_i|=1$ 的部分之后，会有一部分的 $|T_i|=2$ 的其中一个元素废掉，进而推出这个集合的 $b_i$ 的取值（也可能推出无解）。这部分可以用一个 bfs 实现。现在假设剩下来的都是 $|T_i|=2$ 的集合。

只有两个元素的限制，这启发我们建图，给两个点之间连一条边。现在问题变为给每条边选一个端点，使所有边选择的点互不相同。

这个问题对于每个连通块是独立的。设目前考虑的连通块点数为 $V$，边数为 $E$。当 $E>V$ 时无解；当 $E=V$ 时连通块是一棵基环树，我们可以给每条非环边选择离环较远的那个点，给每条环边依次选上一端的点，显然是有解的；当 $E=V-1$ 时，我们任意定一个根，将树定向成一棵外向树，每条边选择指向的点即可，也是有解的。

这样我们就会判断无解了，获得了额外的 $8$ 分。

我们分析一下 Bob 的填数方法多样程度。发现对于一棵基环树，Bob 只有两种填法：正着转一圈环，反着转一圈环；而对于一棵树，每个点为根的填法都是不同的。显然基环树的问题看起来容易得多，那么我们先考虑基环树的问题，即性质 B。

既然只有两种填法，我们就把两种方法的答案都计算出来，设为 $X,Y$。考虑 Alice 的每次决策可以给答案带来怎么样的变化。一次操作可能：

- 不对答案造成任何贡献；

- 给 $X$ 加上 $1$；

- 给 $Y$ 加上 $1$；

- 选择 $X,Y$ 中的一个，给其加上 $1$。

现在需要最大化 $\min(X,Y)$，那么显然可以直接贪心，在做完固定的操作之后，每次选较少的操作。这样就解决了性质 B，获得了额外的 $12$ 分。

我们发现树的主要问题是 Alice 的决策比较复杂，我们先把他放到一边，考虑固定了 Alice 的决策如何找到最优的 Bob 的决策，即性质 C。

你完全可以 $\mathcal O(n^2)$ 枚举根后计算，但是这样只能多拿到尊贵的 $4$ 分，我们不希望止步于此。设连通块大小为 $k$，以每个点为根的答案为 $r_{1},r_{2},\dots r_{k}$。考虑一个 $a_i$ 对 $r$ 序列产生的贡献。

依次考虑每条边，他产生贡献的情况：

- 不产生贡献；

- 定向成父亲 $\to $ 儿子的时候产生贡献；

- 定向成儿子 $\to $ 父亲的时候产生贡献；

发现第二种情况就是对子树外的 $r$ 加 $1$，第三种情况就是对子树内的 $r$ 加 $1$。那么直接做一遍 dfs 序上的差分就知道每个 $r$ 的值了，其中的最小值即为答案。这样又获得了 $12$ 分。

想到这里，正解离我们其实已经很近了。我们剩下的最后的问题就是 Alice 在 $|S_i\cap T_i|=2$ 时的策略，究竟应该使上述哪一种定向方式产生贡献。梳理一下 Alice 的策略：

> 每个点有四种状态：无法产生贡献、给子树内的 $r$ 加上 $1$、给子树外的 $r$ 加上 $1$、选择子树内 / 子树外，并给对应点的 $r$ 加上 $1$。给每个需要选择的点选择子树内 / 子树外，要求最大化 $\min \{r_i\}$。

分析一下，发现很多情况是不优的：设两条边操作到的点集为 $V_1,V_2$，设全集为 $U$，若 $V_1\cap V_2=\empty$，那么 不如两者都取反，即选择 $U\backslash V_1$ 和 $U\backslash V_2$。

具体而言：

- 如果对于 $x,y$，其中 $x$ 为 $y$ 的祖先，$x$ 选择了子树外，而 $y$ 选择了子树内，不如替换成 $x$ 选择子树内，$y$ 选择子树外；

- 如果对于 $x,y$，其中 $x,y$ 没有祖先后代关系，$x,y$ 均选择了子树内，不如都替换成子树外。

这样分析下来，发现 Alice 会选择操作子树内的点一定形成一条从根出发的链！这样我们只需要 dfs 式地枚举这条链，每次做一次操作，回溯时同时回退操作即可。现在问题转化为区间加，查询全局最大值，用线段树维护即可。至此，我们终于解决了这个问题！时间复杂度 $\mathcal O(n\log n)$。

思路还是很递进的，一路顺着想就有很大可能得出正解，但是考场上绝对来不及写！

代码也就 8KB，欢迎大家都来补这个题！

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=1e6+9;
ll n,m,a[N],b[N],ans,vis[N],global_res,len,vd[N];
ll ec[N],vc[N],ve[N],fa[N],cupsz[N];
ll stk[N],top,cir[N],in[N],sta[N];
ll dfn[N],tim,sz[N];
vector<ll>S[N],T[N],vec[N],vedg[N],circ,cid,cup[N];
vector<pii>to[N];
vector<ll> Cup(vector<ll>S,vector<ll>T){
    vector<ll>cup;
    for(ll x:S){
        for(ll y:T){
            if(x==y)cup.push_back(x);
        }
    }
    return cup;
}
ll find(ll x){
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
void merge(ll x,ll y){
    x=find(x),y=find(y);
    if(x^y)fa[x]=y;
}
void dfs(ll x,ll f){
    stk[++top]=x;
    in[x]=1;
    vd[x]=1;
    for(pii es:to[x]){
        ll y=es.first,id=es.second;
        if(id==f)continue;
        if(in[y]){
            ll z=0;
            do{
                z=stk[top],top--;
                in[z]=0,cir[z]=1;
                circ.push_back(z);
            }while(z!=y);
        }
        else if(!vd[y]){
            dfs(y,id);
        }
    }
    if(stk[top]==x)top--,in[x]=0;
}
void dfs2(ll x,ll f){
    for(pii es:to[x]){
        ll y=es.first,id=es.second;
        if(cir[y]||y==f)continue;
        b[id]=y,dfs2(y,x);
    }
}
ll tr[N<<2],tag[N<<2];
void Build(ll x,ll l,ll r){
    tr[x]=tag[x]=0;
    if(l==r)return ;
    ll mid=(l+r)>>1;
    Build(x<<1,l,mid);
    Build(x<<1|1,mid+1,r);
}
void Pushup(ll x){
    tr[x]=min(tr[x<<1],tr[x<<1|1]);
}
void Pushtag(ll x,ll k){
    tag[x]+=k,tr[x]+=k;
}
void Pushdown(ll x){
    if(!tag[x])return ;
    Pushtag(x<<1,tag[x]);
    Pushtag(x<<1|1,tag[x]);
    tag[x]=0;
}
void Upd(ll x,ll l,ll r,ll ql,ll qr,ll k){
    if(l>qr||r<ql||ql>qr)return ;
    if(ql<=l&&r<=qr){
        Pushtag(x,k);
        return ;
    }
    ll mid=(l+r)>>1;
    Pushdown(x);
    Upd(x<<1,l,mid,ql,qr,k);
    Upd(x<<1|1,mid+1,r,ql,qr,k);
    Pushup(x);
}
void AddSub(ll x,ll k){
    Upd(1,1,len,dfn[x],dfn[x]+sz[x]-1,k);
}
void AddOutSub(ll x,ll k){
    Upd(1,1,len,1,dfn[x]-1,k);
    Upd(1,1,len,dfn[x]+sz[x],len,k);
}
void dfs1(ll x,ll f){
    dfn[x]=++tim,sz[x]=1;
    for(pii es:to[x]){
        ll y=es.first,id=es.second;
        if(y==f)continue;
        dfs1(y,x);
        if(!cupsz[id]);
        else if(cupsz[id]==1){
            if(cup[id][0]==x){
                sta[id]=1;
                AddSub(y,1);
            }
            else {
                sta[id]=2;
                AddOutSub(y,1);
            }
        }
        else {
            sta[id]=3;
            AddOutSub(y,1);
        }
        sz[x]+=sz[y];
    }
}
void dfs3(ll x,ll f,ll up){
    if(up&&sta[up]==3){
        AddOutSub(x,-1);
        AddSub(x,1);
    }
    global_res=max(global_res,tr[1]);
    for(pii es:to[x]){
        ll y=es.first;
        if(y==f)continue;
        dfs3(y,x,es.second);
    }
    if(up&&sta[up]==3){
        AddOutSub(x,1);
        AddSub(x,-1);
    }
}
void solve(){
    n=read(),m=read();
    rep(i,0,n+1)S[i].clear(),T[i].clear(),a[i]=b[i]=0;
    rep(i,0,m+1)to[i].clear(),vis[i]=0,vd[i]=0,in[i]=0,cir[i]=0;
    rep(i,1,n){
        ll k=read();
        while(k--){
            ll x=read();
            S[i].push_back(x);
        }
    }
    rep(i,1,n){
        ll k=read();
        while(k--){
            ll x=read();
            T[i].push_back(x);
        }
    }
    ans=0;
    rep(i,1,n){
        cup[i]=Cup(S[i],T[i]);
        cupsz[i]=cup[i].size();
        if(cupsz[i]==1)a[i]=cup[i][0];
    }
    queue<pii>q;
    rep(i,1,n){
        if((ll)T[i].size()==2){
            to[T[i][0]].push_back({T[i][1],i});
            to[T[i][1]].push_back({T[i][0],i});
        }
        else q.push({i,T[i][0]});
    }
    while(!q.empty()){
        pii now=q.front();q.pop();
        ll u=now.first,v=now.second;
        if(vis[v])return puts("-1"),void();
        b[u]=v,vis[v]=1;
        for(pii es:to[v]){
            ll w=es.first,id=es.second;
            if(b[id])continue;
            q.push({id,w});
        }
    }
    rep(i,0,m+1)to[i].clear();
    top=0;
    iota(fa+1,fa+m+1,1);
    rep(i,1,n){
        if((ll)T[i].size()==2&&!b[i]){
            to[T[i][0]].push_back({T[i][1],i});
            to[T[i][1]].push_back({T[i][0],i});
            merge(T[i][0],T[i][1]);
        }
        else if(b[i]){
            for(ll x:S[i]){
                if(x==b[i])ans++;
            }
        }
    }
    rep(i,0,m+1)ec[i]=vc[i]=0,vec[i].clear(),vedg[i].clear();
    rep(i,0,n+1)ve[i]=0;
    rep(i,1,n){
        if((ll)T[i].size()==2&&!b[i])ec[find(T[i][0])]++,vedg[find(T[i][0])].push_back(i);
    }
    rep(i,1,m)vc[find(i)]++,vec[find(i)].push_back(i);
    rep(i,0,m+1)sta[i]=0;
    rep(i,1,m){
        if(find(i)==i){
            if(ec[i]>vc[i])return puts("-1"),void();
            if(ec[i]==vc[i]){
                top=0,circ.clear();
                dfs(i,0);
                cid.clear();
                rep(j,0,(ll)circ.size()-1){
                    ll u=circ[j],v=circ[(j+1)%(ll)circ.size()];
                    for(pii es:to[u]){
                        ll v1=es.first,id=es.second;
                        if(v1==v&&!ve[id]){
                            cid.push_back(id);
                            ve[id]=1;
                            break;
                        }
                    }
                }
                for(ll rt:circ)dfs2(rt,0);
                ll res=0,sum1=0,sum2=0;
                for(ll id:vedg[i]){
                    if(!ve[id]){
                        if(cupsz[id]==0)continue;
                        else if(cupsz[id]==1)res+=(a[id]==b[id]);
                        else res+=(S[id][0]==b[id]||S[id][1]==b[id]);
                    }
                }
                rep(j,0,(ll)circ.size()-1){
                    ll id=cid[j],w=circ[j];
                    if(cupsz[id]==0)continue;
                    else if(cupsz[id]==1){
                        if(w==a[id])sta[id]|=1;
                    }
                    else {
                        if(S[id][0]==w||S[id][1]==w)sta[id]|=1;
                    }
                }
                rep(j,0,(ll)circ.size()-1){
                    ll id=cid[j],w=circ[(j+1)%(ll)circ.size()];
                    if(cupsz[id]==0)continue;
                    else if(cupsz[id]==1){
                        if(w==a[id])sta[id]|=2;
                    }
                    else {
                        if(S[id][0]==w||S[id][1]==w)sta[id]|=2;
                    }
                }
                for(ll id:cid){
                    if(!sta[id])continue;
                    if(sta[id]==1)sum1++;
                    else if(sta[id]==2)sum2++;
                }
                for(ll id:cid){
                    if(sta[id]==3){
                        if(sum1<sum2)sum1++;
                        else sum2++;
                    }
                }
                ans+=res+min(sum1,sum2);
            }
            else {
                tim=0;
                len=vc[i];
                Build(1,1,len);
                global_res=tr[1];
                dfs1(i,0);
                dfs3(i,0,0);
                ans+=global_res;
            }
        }
    }
    write(ans),putchar('\n');
}
bool Med;
int main(){
    // freopen("game.in","r",stdin);
    // freopen("game.out","w",stdout);
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    ll T=read();
    rep(tid,1,T){
        solve();
    }
    return 0;
}
```

---

## 作者：Leasier (赞：1)

~~想起来爽，写起来*。~~

------------

### 性质 A：只需要判有无解
回忆一下 [CF875F Royal Questions](https://codeforces.com/problemset/problem/875/F)，对于这种“二选一”的模型，有如下建图方式：

- 当 $|T_i| = 2$，我们取 $x, y \in T_i, x \neq y$，连边 $(x, y)$
- 当 $|T_i| = 1$，我们取 $x \in T_i$，连边 $(x, x)$。
- 对于每条边，选择一个端点，使得所选点两两不同。

不难发现对于一个连通块 $(V, E)$ 而言，有解当且仅当 $|V| \geq |E|$。

dfs 出每个连通块判断即可。时间复杂度为 $O(\sum n)$。
### 性质 B：图连成一个环
考虑给每条边赋权，我们用 $u \to v$ 表示选 $v$ 而不选 $u$，边权为 $[v \in S_x]$。

Alice 的任务是给边定向，使得 Bob 的两种选法（正反）所得边权和的最小值最大。

设在环上顺时针走边权为 $1$、反之边权为 $0$ 的边有 $x$ 条，顺时针走边权为 $0$、反之边权为 $1$ 的边有 $y$ 条，无论怎么走边权都为 $1$ 的边有 $z$ 条，则我们需要确定一个 $t \in [0, z]$，使得 $\min(x + t, y + (z - t))$ 最大。

随便讨论一下即可，记得特判大小 $\leq 2$ 的环。时间复杂度为 $O(\sum n)$。
### 无特殊限制
考虑把连通块分为基环树和树处理。

对于基环树，环上的部分可以把性质 B 搬过来，树上的部分完全固定。

对于树，考虑 Alice 会怎么做：

- 对于 $(0, 0)$ 边，怎么搞都一样。
- 对于 $(0, 1) / (1, 0)$ 边，Alice 一定会使其指向 $1$。
- 对于 $(1, 1)$ 边，有待斟酌（

再考虑 Bob 会怎么做：

- 选定一个根搜出一棵外向树，每条边 $u \to v$ 获得 $[v \in S_x]$ 的贡献。
- 这个根满足边的贡献和最小。

接下来考虑 Alice 会怎样决定 $(1, 1)$ 边的方向。

- **考虑两条边的相对关系：正 / 背对优不优？**

考虑两条边 $(p, q), (r, s)$，使得 $p \to q \to r \to s$ 是一条链。则可以发现**正对优于背对**，即选择 $p \to q, s \to r$ 优于 $q \to p, r \to s$。

进一步地，我们可以发现：Alice 所选的 $(1, 1)$ 边也一定可以构成一棵外向树（如果可以调整其他类型的边的话）。

线段树维护 Alice 换根时 Bob 选取每个根的答案最小值即可。时间复杂度为 $O(\sum n \log n)$。

代码：
```cpp
#include <stdio.h>

typedef struct {
	int nxt;
	int end;
	int dis;
} Edge;

typedef struct {
	int l;
	int r;
	int add;
	int min;
} Node;

int top1, top2, len, cnt;
int root[1000007], head[1000007], sizes[1000007], s[1000007][7], sizet[1000007], t[1000007][7], val[1000007], stk1[1000007], stk2[1000007], loop[1000007], in[1000007], fa[1000007], out[1000007];
bool mark[1000007], vis[1000007], have[1000007][7];
Edge edge[2000007];
Node tree[4000007];

inline void init(int n){
	cnt = 1;
	for (register int i = 1; i <= n; i++){
		root[i] = i;
		mark[i] = false;
		head[i] = 0;
		vis[i] = false;
	}
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

int get_root(int x){
	if (root[x] == x) return x;
	return root[x] = get_root(root[x]);
}

inline bool merge(int x, int y){
	int root_x = get_root(x), root_y = get_root(y);
	if (root_x == root_y){
		if (mark[root_x]) return false;
		mark[root_x] = true;
	} else {
		if (mark[root_x] && mark[root_y]) return false;
		root[root_x] = root_y;
		mark[root_y] |= mark[root_x];
	}
	return true;
}

inline void add_edge(int start, int end, int dis){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
}

bool dfs1(int u, int pre){
	vis[u] = true;
	stk1[++top1] = u;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (i != pre){
			if (!vis[x]){
				if (dfs1(x, i ^ 1)) return true;
			} else {
				len = 0;
				do {
					loop[++len] = stk1[top1--];
				} while (loop[len] != x);
				return true;
			}
		}
	}
	stk2[++top2] = stk1[top1--];
	return false;
}

int dfs2(int u, int father){
	int ans = 0;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (!vis[x] && x != father) ans += dfs2(x, u) + edge[i].dis;
	}
	return ans;
}

void dfs3(int u, int father, int begin, int &x, int &y, int &z){
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int w = edge[i].end;
		if (w != father && vis[w]){
			int p = edge[i].dis, q = edge[i ^ 1].dis;
			if (p == 1 && q == 0){
				x++;
			} else if (p == 0 && q == 1){
				y++;
			} else if (p == 1 && q == 1){
				z++;
			}
			if (w != begin) dfs3(w, u, begin, x, y, z);
		}
	}
}

inline int min(int a, int b){
	return a < b ? a : b;
}

void dfs4(int u, int father, int &id){
	in[u] = ++id;
	fa[u] = father;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father) dfs4(x, u, id);
	}
	out[u] = id;
}

void build(int x, int l, int r){
	tree[x].l = l;
	tree[x].r = r;
	tree[x].add = tree[x].min = 0;
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(x * 2, l, mid);
	build(x * 2 + 1, mid + 1, r);
}

inline void push_add(int x, int k){
	tree[x].add += k;
	tree[x].min += k;
}

inline void pushdown(int x){
	if (tree[x].add != 0){
		push_add(x * 2, tree[x].add);
		push_add(x * 2 + 1, tree[x].add);
		tree[x].add = 0;
	}
}

inline void update(int x){
	tree[x].min = min(tree[x * 2].min, tree[x * 2 + 1].min);
}

void add(int x, int l, int r, int k){
	if (l <= tree[x].l && tree[x].r <= r){
		push_add(x, k);
		return;
	}
	int mid = (tree[x].l + tree[x].r) >> 1;
	pushdown(x);
	if (l <= mid) add(x * 2, l, r, k);
	if (r > mid) add(x * 2 + 1, l, r, k);
	update(x);
}

void dfs5(int u, int id){
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != fa[u]){
			if (edge[i].dis == 1){
				push_add(1, 1);
				add(1, in[x], out[x], -1);
			} else if (edge[i ^ 1].dis == 1){
				add(1, in[x], out[x], 1);
			}
			dfs5(x, id);
		}
	}
}

inline int max(int a, int b){
	return a > b ? a : b;
}

int dfs6(int u, int id){
	int ans = tree[1].min;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != fa[u]){
			bool flag = edge[i].dis == 1 && edge[i ^ 1].dis == 1;
			if (flag){
				push_add(1, -1);
				add(1, in[x], out[x], 2);
			}
			ans = max(ans, dfs6(x, id));
			if (flag){
				add(1, in[x], out[x], -2);
				push_add(1, 1);
			}
		}
	}
	return ans;
}

void write(int n){
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
}

int main(){
	int T = read();
	for (register int i = 1; i <= T; i++){
		int n = read(), m = read();
		bool flag = true;
		init(m);
		for (register int j = 1; j <= n; j++){
			sizes[j] = read();
			for (register int k = 1; k <= sizes[j]; k++){
				s[j][k] = read();
			}
		}
		for (register int j = 1; j <= n; j++){
			sizet[j] = read();
			for (register int k = 1; k <= sizet[j]; k++){
				t[j][k] = read();
			}
		}
		for (register int j = 1; j <= n; j++){
			if (sizet[j] == 1){
				flag &= merge(t[j][1], t[j][1]);
			} else {
				flag &= merge(t[j][1], t[j][2]);
			}
		}
		if (!flag){
			putchar('-');
			putchar('1');
			putchar('\n');
			continue;
		}
		int ans = 0;
		for (register int j = 1; j <= n; j++){
			for (register int k = 1; k <= sizet[j]; k++){
				have[j][k] = false;
				for (register int l = 1; l <= sizes[j]; l++){
					if (t[j][k] == s[j][l]){
						have[j][k] = true;
						break;
					}
				}
			}
		}
		for (register int j = 1; j <= n; j++){
			if (sizet[j] == 1){
				val[t[j][1]] = have[j][1] ? 1 : 0;
				add_edge(t[j][1], t[j][1], val[t[j][1]]);
				add_edge(t[j][1], t[j][1], val[t[j][1]]);
			} else {
				add_edge(t[j][1], t[j][2], have[j][2] ? 1 : 0);
				add_edge(t[j][2], t[j][1], have[j][1] ? 1 : 0);
			}
		}
		for (register int j = 1; j <= m; j++){
			if (get_root(j) == j){
				if (mark[j]){
					top1 = top2 = 0;
					dfs1(j, 0);
					while (top1 > 0){
						vis[stk1[top1--]] = false;
					}
					while (top2 > 0){
						vis[stk2[top2--]] = false;
					}
					for (register int k = 1; k <= len; k++){
						ans += dfs2(loop[k], 0);
					}
					if (len == 1){
						ans += val[loop[1]];
					} else {
						int x = 0, y = 0, z = 0;
						if (len == 2){
							int pre;
							for (register int k = head[loop[1]]; k != 0; k = edge[k].nxt){
								if (edge[k].end == loop[2]){
									int p = edge[k].dis, q;
									pre = k ^ 1;
									q = edge[pre].dis;
									if (p == 1 && q == 0){
										x++;
									} else if (p == 0 && q == 1){
										y++;
									} else if (p == 1 && q == 1){
										z++;
									}
									break;
								}
							}
							for (register int k = head[loop[2]]; k != 0; k = edge[k].nxt){
								if (k != pre && edge[k].end == loop[1]){
									int p = edge[k].dis, q = edge[k ^ 1].dis;
									if (p == 1 && q == 0){
										x++;
									} else if (p == 0 && q == 1){
										y++;
									} else if (p == 1 && q == 1){
										z++;
									}
									break;
								}
							}
						} else {
							dfs3(loop[1], loop[len], loop[1], x, y, z);
						}
						if (x <= y - z){
							ans += x + z;
						} else if (y <= x - z){
							ans += y + z;
						} else {
							ans += (x + y + z) / 2;
						}
					}
				} else {
					int id = 0;
					dfs4(j, 0, id);
					build(1, 1, id);
					dfs5(j, id);
					ans += dfs6(j, id);
				}
			}
		}
		write(ans);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：happybob (赞：1)

先考虑怎么判断 $-1$。

对于 $|T_i|=2$，我们考虑连无向边 $T_{i,1} \leftrightarrow T_{i,2}$。对于 $|T_i|=1$，连自环 $T_{i,1} \leftrightarrow T_{i,1}$。

考虑每天边 Bob 会怎样？显然是选择其中一个端点，或者可以说，对无向边定向，从没选的指向选了的。

对于每个连通块，如果存在边数大于点数，那么无论怎么选都有重复，即为 $-1$。

这样我们已经判断了是否可以凑出每个都不同。那么接着就已经离正解不远了。

注意到当边数大于点数，输出 $-1$。于是只需要考虑边数 $\leq$ 点数。然而这是连通块，所以要么是树，要么是基环树。

我们现在将 $S_i$ 纳入进来。显然 Alice 最优策略下一定会选 $S_i \cap T_i$ 的一些点，如果两个集合没有交集，那么无论怎么选都没有贡献。交集为 $1$ 时 Alice 选的确定，现在只需要考虑交集等于 $2$，即 $S_i = T_i$ 的选法。

先考虑基环树。比较显然我们的边定向方案是一棵外向基环树，不在环上的边只能往外定向，这些贡献可以直接处理。环上只有两种，都选左端点或者右端点。环上的边的 $S_i =T_i$ 可以容易处理，假设全都选左边，只计算 $S_i \neq T_i$ 的贡献是 $c_1$，全都选右边，只计算 $S_i \neq T_i$ 的贡献是 $c_2$。$S_i = T_i$ 的环上边数量为 $d$。则贡献为 $\max \limits_{i=0}^d \min\{c_1+i,c_2+d-i\}$，计算并累加贡献即可。

考虑另一部分，即树。对于 Bob 来说，选法有树的点数种，每种都是确定一个根，然后连。直接做是 $O(n^2)$ 的，不妨从 Alice 的角度考虑。考虑对于 $S_i = T_i$ 的边，Alice 可以选择一个方向，使得定向如果定成这个方向就有代价。随便找个根 DFS，对于 $S_i = T_i$ 的一条边 $(u,v)$，不妨设 $u$ 为 $v$ 的父亲。如果选的代价是 $u \rightarrow v$ 的，那么以 $v$ 子树外所有点为根时，Bob 都需要花贡献。反之，$v \rightarrow u$，则是以 $v$ 为根的子树有贡献。

我们称 $u \rightarrow v$ 的边为后向边，$v \rightarrow u$ 的边为前向边。感性理解可以发现，前向边一定同时在一条链上且一定是连续的。可以通过反证法。读者自证不难。于是我们可以 DFS 的时候线段树维护之。复杂度 $O(n \log n)$。

总体复杂度线性对数，$2$ 秒可以接受。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
using namespace std;

constexpr int N = 2e6 + 5;
int T, n, m;

int e[N * 2], h[N * 2], ne[N * 2], gg[N * 2], idx;
int s[N], ss[N][3], t[N], tt[N][3];
void add(int u, int v, int id)
{
	e[idx] = v, gg[idx] = id, ne[idx] = h[u], h[u] = idx++;
}
int cicp;

bool vis[N];
int cv, ce;
int fa[N];
bool cir;
bool both[N];
int dep[N];
vector<int> vv;

void dfs(int u, int from)
{
	vv.emplace_back(u);
	vis[u] = 1;
	cv++;
	int gg = 0;
	for (int i = h[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (i == (from ^ 1)) continue;
		if (!vis[j] || dep[j] <= dep[u]) ce++;
		if (j == u)
		{
			gg++;
		}
		if (vis[j])
		{
			cicp = j;
		}
		if (!vis[j])
		{
			dep[j] = dep[u] + 1;
			fa[j] = u;
			dfs(j, i);
		}
	}
	if (gg) ce -= gg / 2;
}

class SegmentTree
{
public:
	struct Node
	{
		int l, r, minn, tag;
	}tr[N << 2];
	void pushup(int u)
	{
		tr[u].minn = min(tr[u << 1].minn, tr[u << 1 | 1].minn);
	}
	void build(int u, int l, int r)
	{
		tr[u] = { l, r, 0, 0 };
		if (l == r) return;
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
	}
	void pushdown(int u)
	{
		if (tr[u].tag)
		{
			tr[u << 1].minn += tr[u].tag;
			tr[u << 1].tag += tr[u].tag;
			tr[u << 1 | 1].minn += tr[u].tag;
			tr[u << 1 | 1].tag += tr[u].tag;
			tr[u].tag = 0;
		}
	}
	void update(int u, int l, int r, int v)
	{
		//if (l > m) exit(-1);
		if (tr[u].l >= l and tr[u].r <= r)
		{
			tr[u].tag += v;
			tr[u].minn += v;
			return;
		}
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid) update(u << 1, l, r, v);
		if (r > mid) update(u << 1 | 1, l, r, v);
		pushup(u);
	}
	int query(int u, int l, int r)
	{
		if (tr[u].l >= l and tr[u].r <= r) return tr[u].minn;
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1, res = (int)1e9;
		if (l <= mid) res = query(u << 1, l, r);
		if (r > mid) res = min(res, query(u << 1 | 1, l, r));
		return res;
	}
}sgt;

bool cmp(int x)
{
	return (ss[x][1] == tt[x][1] && ss[x][2] == tt[x][2]) || (ss[x][1] == tt[x][2] && ss[x][2] == tt[x][1]);
}
int tr_idx[N], tridx, trsz[N];
int res = 0, ans;
bool inc[N];
bool flag[N];

void pre_dfs(int u, int fa)
{
	tr_idx[u] = ++tridx;
	trsz[u] = 1;
	for (int i = h[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (j == fa) continue;
		pre_dfs(j, u);
		trsz[u] += trsz[j];
		int id = gg[i];
		if (s[id] == 2 && t[id] == 2 && cmp(id))
		{
			both[i] = 1;
			sgt.update(1, 1, m, 1);
			sgt.update(1, tr_idx[j], tr_idx[j] + trsz[j] - 1, -1);
		}
		else if (s[id] == 2)
		{
			if (ss[id][1] == j || ss[id][2] == j)
			{
				sgt.update(1, 1, m, 1);
				sgt.update(1, tr_idx[j], tr_idx[j] + trsz[j] - 1, -1);
			}
			else if (ss[id][1] == u || ss[id][2] == u)
			{
				sgt.update(1, tr_idx[j], tr_idx[j] + trsz[j] - 1, 1);
			}
		}
		else
		{
			if (ss[id][1] == j)
			{
				sgt.update(1, 1, m, 1);
				sgt.update(1, tr_idx[j], tr_idx[j] + trsz[j] - 1, -1);
			}
			else if (ss[id][1] == u)
			{
				sgt.update(1, tr_idx[j], tr_idx[j] + trsz[j] - 1, 1);
			}
		}
	}
}

int nowl, nowr;

void dfs2(int u, int fa)
{
	res = max(res, sgt.query(1, nowl, nowr));
	for (int i = h[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (j == fa) continue;
		if (both[i])
		{
			//cout << "!!!: " << u << " " << j << "\n";
			sgt.update(1, 1, m, -1);
			sgt.update(1, tr_idx[j], tr_idx[j] + trsz[j] - 1, 2);
		}
		dfs2(j, u);
		if (both[i])
		{
			sgt.update(1, 1, m, 1);
			sgt.update(1, tr_idx[j], tr_idx[j] + trsz[j] - 1, -2);
		}
	}
}

void solve_tree(int u)
{
	nowl = tridx + 1;
	nowr = tridx + cv;
	for (int i = nowl; i <= nowr; i++) sgt.update(1, i, i, -sgt.query(1, i, i));
	pre_dfs(u, -1);
	res = sgt.query(1, nowl, nowr);
	//cout << "!!!: " << nowl << " " << nowr << " " << res << "\n";
	//if (u == 2) cout << "yoxi: " << res << " " << nowl << " " << nowr << "\n";
	dfs2(u, -1);
	ans += res;
}

int tc;
int ccnt, c1, c2;

int get_res(int id)
{
	if (ss[id][1] == tt[id][1]) return tt[id][1];
	else if (t[id] >= 2 && ss[id][1] == tt[id][2]) return tt[id][2];
	if (s[id] == 1) return -1;
	else
	{
		if (ss[id][2] == tt[id][1]) return tt[id][1];
		else if (t[id] >= 2 && ss[id][2] == tt[id][2]) return tt[id][2];
		return -1;
	}
}

namespace looped_base_tree
{
	void dfs(int u, int f, int from)
	{
		vis[u] = 1;
		fa[u] = f;
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			if (i == (from ^ 1)) continue;
			if (vis[j])
			{
				if (dep[u] < dep[j]) continue;
				int now = u;
				if (u == j)
				{
					inc[u] = 1;
					continue;
				}
				do
				{
					inc[now] = 1;
					now = fa[now];
				} while (now != j);
				inc[j] = 1;
			}
			else
			{
				dep[j] = dep[u] + 1;
				dfs(j, u, i);
			}
		}
	}
	void dfs2(int u)
	{
		vis[u] = 1;
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			int id = gg[i];
			if (!flag[i] && !flag[i ^ 1])
			{
				flag[i] = flag[i ^ 1] = 1;
				if (inc[u] && inc[j])
				{
					if (s[id] == 2 && t[id] == 2 && cmp(id))
					{
						ccnt++;
					}
					else
					{
						int g = get_res(id);
						if (~g)
						{
							if (g == u) c1++;
							if (g == j) c2++;
						}
					}
				}
				else
				{
					bool fg = 0;
					for (int k = 1; k <= s[id]; k++)
					{
						if (ss[id][k] == j)
						{
							fg = 1;
							break;
						}
					}
					if (fg) tc++;
				}
			}
			if (!vis[j]) dfs2(j);
		}
	}
}

void solve_looped_base_tree(int u)
{
	tc = c1 = c2 = ccnt = 0;
	for (auto& i : vv) vis[i] = dep[i] = 0;
	looped_base_tree::dfs(cicp, 0, -1);
	for (auto& i : vv) vis[i] = 0;
	looped_base_tree::dfs2(cicp);
	int res = 0;
	for (int i = 0; i <= ccnt; i++) res = max(res, min(c1 + i, c2 + ccnt - i));
	ans += res + tc;
}

int main()
{
	//freopen("C:\\Users\\60215\\Downloads\\Compressed\\game\\game\\game9.in", "r", stdin);
	//freopen("C:\\Users\\60215\\Downloads\\Compressed\\game\\game\\game9.out", "w", stdout);\
	memset(h, -1, sizeof h);
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> T;
	while (T--)
	{
		ans = 0;
		cin >> n >> m;
		sgt.build(1, 1, m);
		for (int i = 1; i <= m; i++) trsz[i] = dep[i] = inc[i] = 0, h[i] = -1, vis[i] = fa[i] = 0;
		for (int i = 0; i <= idx; i++) both[i] = flag[i] = 0;
		idx = tridx = 0;
		res = 0;
		for (int i = 1; i <= n; i++)
		{
			cin >> s[i];
			for (int j = 1; j <= s[i]; j++) cin >> ss[i][j];
		}
		for (int i = 1; i <= n; i++)
		{
			cin >> t[i];
			for (int j = 1; j <= t[i]; j++) cin >> tt[i][j];
			if (t[i] == 1) add(tt[i][1], tt[i][1], i), add(tt[i][1], tt[i][1], i);
			else add(tt[i][1], tt[i][2], i), add(tt[i][2], tt[i][1], i);
		}
		for (int i = 1; i <= m; i++)
		{
			if (vis[i]) continue;
			cv = ce = cir = 0;
			vv.clear(), vv.shrink_to_fit();
			dep[i] = 0;
			cicp = -1;
			dfs(i, -1);
			if (ce > cv)
			{
				cout << "-1\n";
				goto E;
			}
			if (ce == cv - 1)
			{
				solve_tree(i);
			}
			else
			{
				solve_looped_base_tree(i);
			}
		}
		cout << ans << "\n";
	E:;
	}
	return 0;
}
```


---

## 作者：云浅知处 (赞：1)

首先进行一些显然的转化：

- 当 $S_i\cap T_i=\varnothing$ 时，这个 $S_i$ 没用，可以忽略；
- 当 $|S_i\cap T_i|=1$ 时，这个 $S_i$ 一定是选 $S_i\cap T_i$ 更优，转化为 $|S_i|=1$ 的情形。
- $|S_i\cap T_i|=2$，这意味着 $S_i=T_i$。

对每个 $T_{i,0},T_{i,1}$ 连边（这里我们认为 $|T_i|=1$ 时令 $T_{i,1}=T_{i,0}$）得到一张 $n$ 点 $n$ 边的无向图。现在相当于把每条边定向，使得每个点的入度不超过 $1$；$S_i$ 则表示某条边如果定成某个方向会有若干的代价，$|S_i|=2$ 的则代表 Alice 可以自由选择代价的方向。

考虑每个连通块，如果边数小于点数则无解，否则一定是树或者基环树；对于基环树，环上点有两种定向方案，环外点必然是形成基环外向树，已经唯一确定。对于环内点，若 Alice 可以自由选择 $C$ 次，目前全部指左和指右已有的代价分别为 $A,B$，那么 Alice 就是要把 $C$ 分配给 $A,B$，让 $\min(A,B)$ 最大。简单分讨一下即可；对于环外点，由于每个点的 Bob 的方案唯一，Alice 很容易做出选择。

对于树，Bob 有 $n$ 种选择方案（让某个点为根得到一棵外向树）。考虑设 $w_i$ 表示点 $i$ 为根的答案，那么对于 Alice 的每条可以自由选择的边 $(u,v)$，不妨设 $u=fa_v$，那么 Alice 可以选择在 $v$ 子树内 $w_i$ 全都 $+1$（即定向为 $v\to u$），或者是 $v$ 子树外的 $w_i$ 全都 $+1$（即定向为 $u\to v$），要求最大化 $w$ 的最小值。

~~然后我场上写到这里就不会了orz~~

考虑 Alice 的两条边 $(a,b),(c,d)$，不妨设 $a=fa_b,c=fa_d$，若 $b,d$ 不互为祖孙关系则不可能两条边分别定向为 $b\to a,d\to c$（否则定向为 $a\to b,c\to d$ 一定更优）；若 $b$ 是 $d$ 的祖先则不可能两条边分别定向为 $a\to b,d\to c$（否则反过来更优）。总之，我们发现一定不可能有两条边是“互相面对面”的。

这也就是说，所有由儿子指向父亲即对子树内贡献的边一定都存在于根到某个点的路径上，并且一定是根到这个点路径上的所有可选边。称这个点为**关键点**。套路地先做 DFS 求出 DFS 序转为区间加全局 min，先令每条可选边均指向儿子，再做一遍 DFS，每次经过一条可选边 $u\to v$ 的时候就把 $(u,v)$ 的方向反向，回来的时候再反向回去，就能处理出以每个点为关键点时的线段树形态。时间复杂度 $O(n\log n)$。

[AC Code](https://www.luogu.com.cn/paste/15nu8x6q)

---

## 作者：baka24 (赞：0)

将选一个点视为选两个一样的点，在这之上考虑。

先考虑 Bob 所拿到的东西如何转化，将 $n$ 个限制所代表的二元组两两连边，对于每条边分配一个点，要求一个点只能用一次。则每个连通块只能是树或者基环树（因为要求边数不能大于点数）。

分别考虑基环树和树。

#### 基环树
因为每个边都要被分配一个点，所以在基环树时没有点被浪费。

那么可以发现一共只有两种情况。

对于树上部分，每个点只能分配给自己的父边。对于环的部分，每个边有两种选择（都选 $u$ 和都选 $v$）。

那么 Alice 需要找一共填法使得这两种情况的最小值最大。

只考虑环上的点，设有 $c_0$ 个点只能选 $u$ 个点，$c_1$ 个点只能选 $v$ 个点，$c$ 个点 $u,v$ 都能选。

那么考虑有 $i$ 个自由点选了 $u$，则对于环上的答案为 $\max _{i=0}^c \min(c_0+i,c_1+c-i)$。

那么在这里答案就是 $\min (c_0+c,c_1+c,\lfloor\frac{c_0+c_1+c}{2}\rfloor)$。

对于树部分直接统计有多少条边可以选儿子即可。

#### 树
对于树，每个连通块有一个点可以不被分配，那考虑以这个点作为根时，所有点就被分配到它的父边。

考虑这样转化：Alice 可以先指定所有边的方向，权值就是 Bob 把树改成一颗外向树所需要更改的边的数量。

考虑设 $p_i$ 为 $i$ 为根时该方案的权值，则 Alice 需要最大化 $\min p_i$。

那对于一条边，它的两种方向分别对应贡献到 $i$ 子树内和 $i$ 子树外。

有一个 $O(n\log n)$ 的贪心：在 dfn 序上考虑，初始让所有点贡献到子树外。每次把权值最小的点拿出来，把它的祖先中最靠上能够修改贡献的点的贡献改成子树内。

因为最靠上的点在 dfn 序上的区间更大，造成的劣影响更少。

用并查集维护哪些点贡献改过了，每次倍增找最靠上的祖先即可。

用线段树维护权值，复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lson (pos<<1)
#define rson (pos<<1|1)
#define pii pair<int,int>
#define fr first
#define sc second
#define mk make_pair
#define inx(u) int I=h[(u)],v=edge[I].v,w=edge[I].w;I;I=edge[I].nx,v=edge[I].v,w=edge[I].w
#define lb(x) (x&(-x))
int read(){int x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();return x*f;}
const int MAXN=2000010,N=22;
struct Edge{int v,nx,w;}edge[MAXN<<1];int h[MAXN],CNT=1;void add_side(int u,int v,int w){edge[++CNT]={v,h[u],w};h[u]=CNT;edge[++CNT]={u,h[v],w};h[v]=CNT;}
int n,m,ans,fa[MAXN],siz[MAXN];
int fid(int x){return fa[x]==x?x:fa[x]=fid(fa[x]);}
void mrge(int x,int y){x=fid(x),y=fid(y);if(x!=y)fa[x]=y,siz[y]+=siz[x]+1;else siz[x]++;}
int vis[MAXN],lp[MAXN];
pii a[MAXN],b[MAXN];
int c,c1,c0;
int dfs1(int u,int lst){
    if(vis[u])return u;
    vis[u]=lp[u]=1;
    for(inx(u))if(I!=lst){
        int tmp=dfs1(v,I^1);
        if(tmp){
            if(mk(u,v)==a[w]||mk(v,u)==a[w])c++;
            else if(u==a[w].fr||u==a[w].sc)c0++;
            else if(v==a[w].fr||v==a[w].sc)c1++;
            return tmp==u?0:tmp;
        }
    }
    lp[u]=0;
    return 0;
}
void col(int u){vis[u]=3;for(inx(u))if(vis[v]!=3)col(v);}
void dfs2(int u){
    vis[u]=2;
    for(inx(u))if(!lp[v]&&vis[v]!=2){
        if(a[w].fr==v||a[w].sc==v)ans++;
        dfs2(v);
    }
}
int dfn[MAXN],ed[MAXN],dy[MAXN],cnt,f[MAXN][N+2];
struct segtree{
    pii t[MAXN<<2];
    int lz[MAXN<<2];
    void upd(int pos,int x){t[pos].fr+=x,lz[pos]+=x;}
    void pushdown(int pos){upd(lson,lz[pos]),upd(rson,lz[pos]),lz[pos]=0;}
    void pushup(int pos){t[pos]=min(t[lson],t[rson]);}
    void build(int pos,int l,int r){
        lz[pos]=0;
        if(l==r){
            t[pos]={0,l};
            return;
        }
        int mid=(l+r)>>1;
        build(lson,l,mid),build(rson,mid+1,r);
        pushup(pos);
    }
    void update(int pos,int l,int r,int ql,int qr,int x){
        if(ql>qr)return;
        if(ql<=l&&qr>=r){
            upd(pos,x);
            return;
        }
        int mid=(l+r)>>1;pushdown(pos);
        if(ql<=mid)update(lson,l,mid,ql,qr,x);
        if(qr>mid)update(rson,mid+1,r,ql,qr,x);
        pushup(pos);
    }
    pii query(int pos,int l,int r,int ql,int qr){
        if(ql<=l&&qr>=r)return t[pos];
        int mid=(l+r)>>1;pushdown(pos);
        if(qr<=mid)return query(lson,l,mid,ql,qr);
        if(ql>mid)return query(rson,mid+1,r,ql,qr);
        return min(query(lson,l,mid,ql,qr),query(rson,mid+1,r,ql,qr));
    }
}T;
struct DSU{
    int fa[MAXN];
    void init(){for(int i=1;i<=m;i++)fa[i]=i;}
    int fid(int x){return x==fa[x]?x:fa[x]=fid(fa[x]);}
    void mrge(int u,int v){
        u=fid(u),v=fid(v);fa[u]=v;}
}D;
void dfs(int u,int lst){
    dfn[u]=++cnt,f[u][0]=lst,dy[cnt]=u;
    for(inx(u))if(v!=lst)dfs(v,u);
    ed[u]=cnt;
}
void dfs(int u){
    vis[u]=2;
    for(inx(u))if(vis[v]!=2){
        if(a[w]==mk(u,v)||a[w]==mk(v,u))T.update(1,1,cnt,1,dfn[v]-1,1),T.update(1,1,cnt,ed[v]+1,cnt,1);
        else if(a[w].fr==u||a[w].sc==u)T.update(1,1,cnt,dfn[v],ed[v],1),D.mrge(v,u);
        else if(a[w].fr==v||a[w].sc==v)T.update(1,1,cnt,1,dfn[v]-1,1),T.update(1,1,cnt,ed[v]+1,cnt,1),D.mrge(v,u);
        else D.mrge(v,u);
        dfs(v);
    }
}
int get(int x){
    for(int i=N;~i;i--)if(D.fid(f[x][i])!=D.fid(f[x][N]))x=f[x][i];
    return D.fid(x);
}
void slv(){
    n=read(),m=read();
    for(int i=1;i<=m;i++)fa[i]=i,siz[i]=-1,h[i]=vis[i]=lp[i]=0;ans=cnt=0,CNT=1;
    for(int i=1;i<=n;i++){
        int k=read();
        if(k==2)a[i].fr=read(),a[i].sc=read();
        else a[i].fr=a[i].sc=read();
    }
    for(int i=1;i<=n;i++){
        int k=read();
        if(k==2)b[i].fr=read(),b[i].sc=read();
        else b[i].fr=b[i].sc=read();
    }
    for(int i=1;i<=n;i++)mrge(b[i].fr,b[i].sc),add_side(b[i].fr,b[i].sc,i);
    for(int i=1;i<=m;i++)if(siz[fid(i)]>0){puts("-1");return;}
    for(int i=1;i<=m;i++)if(!vis[i]){
        c0=c1=c=0;
        dfs1(i,0),col(i);
        if(c1+c0+c==1)ans++;
        else if(c0+c<c1||c1+c<c0)ans+=min(c1+c,c0+c);
        else ans+=(c1+c0+c)/2;
    }
    for(int i=1;i<=m;i++)if(lp[i])dfs2(i);
    D.init();
    for(int i=1;i<=m;i++)if(vis[i]!=2){
        cnt=0;
        dfs(i,i);
        if(cnt==1)continue;
        T.build(1,1,cnt);
        dfs(i);
        for(int i=1;i<=N;i++)for(int j=1;j<=cnt;j++)f[dy[j]][i]=f[f[dy[j]][i-1]][i-1];
        int res=0;
        pii tmp=T.query(1,1,cnt,1,cnt);
        while(tmp.fr>=res){
            res=tmp.fr;
            int x=get(dy[tmp.sc]);
            if(x==i)break;
            D.mrge(x,f[x][0]);
            T.update(1,1,cnt,1,cnt,-1);
            T.update(1,1,cnt,dfn[x],ed[x],2);
            tmp=T.query(1,1,cnt,1,cnt);
        }
        ans+=res;
    }
    printf("%lld\n",ans);
}
signed main(){
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    int _=read();while(_--)
    slv();
    cerr<<(clock()*1.0)/CLOCKS_PER_SEC<<"s"<<endl;
    return 0;
}
```

---

## 作者：loip (赞：0)

~~码力场~~

首先考虑如何判断 Bob 无解的情况，先将其转化为图论模型：将值域 $[1,m]$ 中每个整数看作一个点，当 $\left|T_{i}\right| = 1$ 时，将一条单向边指向 $T_{i}$ 中的这个数；当 $\left|T_{i}\right| = 2$ 时，将一条双向边连接 $T_{i}$ 中的两个数。之后我们尝试给每条双向边确定一个方向（相当于选择填入哪个数），最后使每个点的入度都不大于一。这样做相当于每个数都被填入的次数不大于一，就等价于 Bob 填数的一种合法方案。

例如当 $n=5,m=5$ 时，有 $T_{1}=\{1,2\},T_{2}=\{1,3\},T_{3}=\{2,3\},T_{4}=\{2\},T_{5}=\{5\}$ 。则转化为下图形式：

![](https://cdn.luogu.com.cn/upload/image_hosting/bwzu4acd.png)

此时发现无论如何给双向边定向最后总会有一个点的入度大于一，即 Bob 填数无解。

判无解的方式和 [Bovine Alliance G](https://www.luogu.com.cn/problem/P3043) 这道题相似，但多了初始时有单项边的情况。

考虑每个由双向边构成的连通块，显而易见的是如果一个连通块中的 $\left|V\right| < \left|E\right|$ 就一定无解（因为每条单项或双向边最后都至少指向一个点）。

然后现在每个连通块要么 $\left|V\right| = \left|E\right|$ 要么 $\left|V\right| = \left|E\right| + 1$（如果 $\left|V\right| > \left|E\right| + 1$ 就不是连通块了）。对每个连通块容易构造至少一种方式定向使其满足要求。

 $\left|V\right| = \left|E\right|$ 时连通块为一颗基环树或者是一颗树加一条有向边的形式，而 $\left|V\right| = \left|E\right| + 1$ 时为一颗树的形式。

![](https://cdn.luogu.com.cn/upload/image_hosting/fri7zsat.png)

（如上图依次为基环树，一颗树加一条有向边，一颗树，单独一个点和单独一个点被有向边指向的形式）

同样的，考虑将 Alice 的决策转化为在图论上的问题，与 $T_i$ 连边的方式类似，对于 Alice 的若干集合 $S_i$ ，若 $\left|T_i \cap S_i\right| = 0$ 则忽略，若 $\left|T_i \cap S_i\right| = 1$ 则将一条单向边指向交集中的这个数；若 $\left|T_i \cap S_i\right| = 2$ 则将一条双向边连接交集中的两个数。 Alice  也要将每条双向边定向（相当于选择填入哪个数）。最终对于每一个 $i$ ，发现只有当 $S_i$ 对应在图上的边与 $T_i$ 对应在图上的边指向同一个点，即相当于在 $i$ 处两人填入的数相同时，才会对 $X$ 产生 $1$ 的贡献。

接下来在 Bob 的未定向时的图上进行 Alice 的决策，发现每个联通块相互独立，分别考虑。

#### 1.对于一棵树加一条有向边形式的联通块

假设这一条有向边指向的点为树根，那么与根相连的所有双向边都只能指向儿子节点（否则根入度大于二），对于子树同理。故在该种连通块中 Bob 最终对每条边的定向方向唯一，都从父节点指向子节点。Bob 总共只有 $1$ 种定向方式。

然后考虑 Alice 如何依据该联通块做决策，显然 $S_i$ 应尽量与 $T_i$ 的边方向应尽量相同，并统计对 $X$ 的贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/20fbuw47.png)

（黑边为 Bob 定向的边，红边为 Alice 定向的边，蓝圈连接的两条边表示一组 $i$ 相同的 $T_{i}$ 和 $S_i$）

#### 2.对于基环树形式的联通块

对于环上的边显然 Bob 一共有两种定向方式：逆时针或顺时针。而对于连在环上的树，类似于上一种树加有向边的形式， Bob 给每条边的定向方向唯一，都从父节点指向子节点。最后 Bob 总共有 $2$ 种定向方式。

考虑 Alice 如何做决策，对于连在环上的树则与采用第一种处理方式。关键是对于环， Alice 希望顺时针和逆时针贡献的最小值最大，尽量平均，那么记 $x_1$ 表示 Bob 将整个环顺时针定向时 Alice 在环上的单向边的贡献，$x_2$ 则表示 Bob 将整个环逆时针定向时 Alice 在环上的单向边的贡献，$x_3$ 表示 Alice 在环上的双向边的条数。

![](https://cdn.luogu.com.cn/upload/image_hosting/kdc04gug.png)

最后若 $x_3 <\left|x_1 - x_2\right|$ 则贡献为 $\min \left \{x_1,x_2 \right \}  + x_3$，否则为 $\left \lfloor  \frac{x_1 + x_2 + x_3}{2}  \right \rfloor $。

#### 3.对于一颗树形式的联通块

这是最复杂的部分，可以用线段树等数据结构做到 $\Theta (n \log n)$ 的复杂度，也可以用这里的树形dp和换根做到 $\Theta (n)$ 的复杂度。

 Bob 定向后总会有一个点入度为 $0$ ，记该点为树根，则剩下的部分类似于第一种的形式，每条边的定向方向唯一，都从父节点指向子节点。因为 Bob 可以任选一个点为根，所以最后 Bob 共有 $\left|V\right|$ 种定向方式。

由于是 Alice 先做出决策，那么记 $w_x$ 为：Bob 以 $x$ 点为根时 Alice 的决策对 $X$ 的贡献。Alice 做出决策后 Bob 一定会选最小的 $w_x$ ，故 Alice 的决策要使最小的 $w_x$ 最大。

可以先把 Alice 的单向边贡献用差分直接计入 $w_x$ 。

 Alice 给一条双向边定向后，相当于把子树的一侧的 $w_x$ 全部加上 $1$ 。接着由人类智慧的贪心，我们发现一定存在一组最优解满足任意两条定向后的双向边方向不会 “相对”，因为此时将这两条双向边方向都翻转一定不会更劣，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/82cf1mx7.png)

由于双向边方向不会“相对”，那么 Alice 给所有双向边定向后总是能找到至少一个类似“根”的点，使得所有定向后的边都背对这个“根”（可用归纳法证明），那么确定了这个根也就确定了 Alice 的定向方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ipgithf.png)

（红边为 Alice 的定向方案，其中 2，5，6 节点都可以被称作该种定向方案的“根”）

对于一个“根”对应的定向方案，我们可以用树形dp求出最小的 $w_x$ 。具体来说，首先对于 $u$ 节点其 $w_u$ 的值为 Alice 可操作的总双向边条数减去从“根”到 $u$ 所经过的 Alice 的双向边条数（结合上图理解）再加上可能的 Alice 的单向边贡献，递归时维护即可。记 $dp_u$ 为以 $u$ 为根的子树中最小的 $w_x$ 值，$dp_u$ 初始值为 $w_u$ ，显然 $dp_u = \min_{v \in son[u]} dp_v$。

然后考虑换根，发现每个节点 $u$ 还要多维护一个次小值，每次换根时判断使用最小值还是次小值。注意换根可能会使 Alice 某条已定向的双向边反转，注意及时 $+1$ 或 $-1$。

最后时间复杂度 $\Theta (n + m)$。

本题思路递进但最后一步难度较大，如果没有想到人类智慧的贪心就还是只能指数级枚举，且细节较多。~~我狂写dfs6然后调试的神志不清。~~

本人的代码十分史山，但跑的还挺快？？ [AC link](https://www.luogu.com.cn/record/180989539)

史山代码：[codee](https://www.luogu.com.cn/paste/yjme6pgh)

有问题欢迎指出

---

## 作者：Corzica (赞：0)

对于我这种蒟蒻来说，想做一道题，肯定先关注部分分啦。

第一个 sub 是直接枚举后检查，可能带点卡常和剪枝。

特性 A 意味着我们只需要检查 Bob 能否选出不重的一个集合即可。我们把在一个集合内的点连边，只有一个数的集合连自环。我们会做的操作就是一直去找一个带有自环或者度数为 $1$ 的点，然后让这个点选出来。同时删掉这个点。如果一个点带有多个自环，或是最终化成的图边数大于点数，那么就寄了。否则输出 $0$。

特性 B 告诉我们，Bob 能够组成的序列只有两种。一是 $a_i=i$，二是 $a_i=i+1$。那么对每一个位置的 $S$ 集合进行检查。维护三个变量 $p,q,w$，分别代表 Bob 选第 1、2 种情况时的答案和最后未确定变量的个数。如果这个集合恰好包含 $i$ 与 $i+1$，那么 $w+1$，否则按是否包含 $i,i+1$ 来改变 $p,q$ 变量的值。最后把 $w$ 加到 $p,q$ 变量内，使得两变量尽可能接近即可。

这两个特性给了我们一些启示。我们分析第一个特性，发现连成图之后，每一个联通块都要满足 $\text{点数} \ge \text{边数}$，而本身联通块就有 $\text{点数}\leq\text{边数}+1$，所以点数要么与边数相等，要么比边数小 $1$。也就是子图要么为树，要么为基环树。

分别考虑这两种情况下子图的解。

先来考虑树的，如果带有特性 C 的话，那么不难设计出 $f_{i,j}$ 代表 $i$ 子树内所有边全部处理完且 $i$ 这个点选择情况为 $j$ 下的最小值。转移可以枚举子树状态，因为至多只有一个子树的 $j$ 为 $1$，枚举这个点到了哪一个子树即可。那么每一个点的答案都是确定的。这个东西可以换根做出来。

如果带性质 D 的话，我们说树的答案就是 $\text{边数}-1$，我们可以先后考虑它的上下限。发现两边都一定有办法使得答案一定大于等于和小于等于 $\text{边数}-1$，所以答案就是它。

因此，我们注意到可以把选 $n-1$ 个点转化为不选 $1$ 个点。那么一次相当于在一个子树内加一或者是子树外的所有点加一。又注意到每两个 Alice 做的点集一定有交，说明存在一个点是所有点集的交。就可以在树上 dfs，那么线段树维护这个东西，查询全局最小值即可。


再考虑基环树的情况，因为点和边是刚好够分配的，手玩一下发现只有两种情况（即所谓的额外边往哪里伸），这个时候再使用我们的特性 B 中的做法，就可以解决啦。

时间复杂度应该是 $n\log n$。不用写就知道常数会比较大，因为我真没写。

---

## 作者：CarroT1212 (赞：0)

首先你需要知道怎么使 $b_i$ 互不相同。扔到图上，每对 $b_i$ 之间连一条边。那么有解仅当每个连通块都是基环树或者树，否则不可能每个点都不冲突。

那么根据题意，问题可以转化为：Bob 需要将每条边 $(u,v)$ 定向为 $u\to v$ 或 $v\to u$（即对于这个边对应的集合选择 $v$ 或 $u$，集合大小为 $1$ 就是 $u,v$ 相等）。而同时对于每条边，Alice 也可以进行定向，Alice 在每条边的定向情况会因为 $S,T$ 的重合情况分为 $4$ 种：定不了，只能定 $u\to v$，只能定 $v\to u$，两边都可能定。那么 Alice 的任务是通过恰当地定向使得 Bob 在某些边上无论如何都会定得跟 Alice 一个方向。

然后可以大力对每个连通块分讨了。称上面 $4$ 种边中的 $2,3$ 种为单向边，第 $4$ 种为双向边。

+ 是基环树。

你发现其实 Bob 这时只有两种定法，也就是取决于那个环的两种定向。显然非环边只能定向朝叶子的一端。看起来这很好解决。

对于非环边，Alice 肯定会尽量往叶子定向。

对于环边，鉴于 Bob 会选择两种定向方式中重合最少的那种，我们需要让两种定向方式的答案的较小值尽量大，也就是尽量平衡两个方向的边的数量。求出环上两种单向边和双向边的数量，那么问题在于双向边如何分配给两个方向，这是好算的。

注意处理重边自环。

+ 是树。

这时有一个点 Bob 可以不选，那么 Bob 每条边选哪个点取决于这个不被选的点是哪个，那么每条边就只能往外侧定向，相当于是 Bob 以它为根定了一棵外向树。

Alice 的定法要求 Bob 所有定法的最小值最大。考虑怎么搞。

设 $f_i$ 为在目前 Alice 的定向状态下 Bob 以 $i$ 为根的结果。发现对于 Alice 定向的一条 $u\to v$，相当于给 $u$ 那一侧的所有 $f_i$ 都加了 $1$。

现在问题同样在于双向边。找点性质。你发现如果要使 $f_i$ 增加使得最小值更大，对于双向边，如果有两条双向边被定向使得它们朝向的那一端靠得更近（即设有 $x\to y$ 和 $u\to v$ 两条边，连接 $x,u$ 的路径会经过 $y,v$），这时两条边中间的部分的 $f_i$ 没有任何变化，其它部分加 $1$。但是如果将它们同时反过来变成 $y\to x$ 和 $v\to u$，就能使整棵树的 $f_i$ 都至少加 $1$，中间部分加 $2$。所以这种面对面的情况一定不优。

那什么时候能让这种不优定向方式尽量不出现呢？就是 Alice 的定向也是一棵外向树的时候。换句话说，Alice 会钦定一个根，并且她会尽量把所有边往外侧定向，就能尽量让定向不存在面对面的情况。

那我们枚举这个根是哪个就好了。把树拍到 dfn 上之后可以用线段树区间加维护在目前的根时所有的 $f_i$ 的值，此时的答案是 $\min f_i$。dfs 换根求出每一个根的 $\min f_i$ 中的最大值即可。

总复杂度 $O(n\log n)$。需要一定卡常。

------------

不难想象省选现场写这题的人是什么心理状态。

```cpp
struct edg { int fi,se,w; };
int n,m,ans;
int s[N][3],t[N][3],sta[N];
vector<edg> e[N];
namespace pseu {
	edg cyc[N]; int cntc,vic[N],isc[N];
	int cycle(int p,int f) {
		if (vic[p]) return p;
		vic[p]=1;
		for (edg i:e[p]) if (i.se!=f) {
			int ret=cycle(i.fi,i.se);
			if (ret) {
				if (ret==-1) return -1;
				else {
					cyc[++cntc]=i,isc[i.fi]=1;
					return ret==p?-1:ret;
				}
			}
		}
		return 0;
	}
	void ddir(int p,int f) {
		for (edg i:e[p]) if (i.fi!=f&&!isc[i.fi]) {
			ans+=i.w>>1&1;
			ddir(i.fi,p);
		}
	}
	void mian(int rt,int sz) {
		cntc=0;
		cycle(rt,0);
		reverse(cyc+1,cyc+cntc+1);
		for (int i=1;i<=cntc;i++) ddir(cyc[i].fi,0);
		if (cntc==1) ans+=!!cyc[1].w;
		else {
			int cnt[4]={0,0,0,0};
			for (int i=1;i<=cntc;i++) cnt[cyc[i].w]++;
			if (cnt[1]>cnt[2]) swap(cnt[1],cnt[2]);
			ans+=min((cnt[1]+cnt[2]+cnt[3])/2,min(cnt[1],cnt[2])+cnt[3]);
		}
	}
	void clr() { for (int i=1;i<=m;i++) vic[i]=isc[i]=0; }
}
namespace tree {
	int sgtn=1;
	struct sgt {
		int t[N<<2],tg[N<<2];
		void ini(int _n) { sgtn=_n; for (int i=1;i<=sgtn<<2;i++) t[i]=0,tg[i]=0; }
		void all(int x) { t[1]+=x,tg[1]+=x; }
		void add(int x,int y,int z,int p=1,int l=1,int r=sgtn) {
			if (x<=l&&r<=y) return t[p]+=z,tg[p]+=z,void();
			int mid=l+r>>1;
			if (tg[p]) t[p<<1]+=tg[p],t[p<<1|1]+=tg[p],tg[p<<1]+=tg[p],tg[p<<1|1]+=tg[p],tg[p]=0;
			if (x<=mid) add(x,y,z,p<<1,l,mid);
			if (y>mid) add(x,y,z,p<<1|1,mid+1,r);
			t[p]=min(t[p<<1],t[p<<1|1]);
		}
		int que() { return t[1]; }
	} tr;
	int res;
	int dfn[N],cnn,dfm[N];
	void initr(int p,int f) {
		dfn[p]=++cnn;
		for (edg i:e[p]) if (i.fi!=f) {
			initr(i.fi,p);
			if (i.w>>1&1) tr.all(1),tr.add(dfn[i.fi],dfm[i.fi],-1);
			else if (i.w) tr.add(dfn[i.fi],dfm[i.fi],1);
		}
		dfm[p]=cnn;
	}
	void chgrt(int p,int f) {
		res=max(res,tr.que());
		for (edg i:e[p]) if (i.fi!=f) {
			if (i.w==3) tr.all(-1),tr.add(dfn[i.fi],dfm[i.fi],2);
			chgrt(i.fi,p);
			if (i.w==3) tr.add(dfn[i.fi],dfm[i.fi],-2),tr.all(1);
		}
	}
	void mian(int rt,int sz) {
		cnn=res=0;
		tr.ini(sz);
		initr(rt,0);
		chgrt(rt,0);
		ans+=res;
	}
	void clr() {}
}
int vis[N],cntn,cntm;
void judge(int p,int f,int pos) {
	vis[p]=pos,cntn++;
	for (edg i:e[p]) {
		cntm++;
		if (!vis[i.fi]) judge(i.fi,p,pos);
	}
}
void getscc() {
	for (int i=1;i<=m;i++) if (!vis[i]) {
		cntn=0,cntm=0,judge(i,0,i),cntm/=2;
		if (cntn<cntm) return cout<<"-1\n",void();
		else if (cntn==cntm) pseu::mian(i,cntn);
		else if (cntn-1==cntm) tree::mian(i,cntn);
	}
	cout<<ans<<"\n";
}
void clear() {
	for (int i=1;i<=m;i++) vector<edg>().swap(e[i]),vis[i]=0;
	pseu::clr();
	tree::clr();
	ans=0;
}
void input() {
	scanf("%d%d",&n,&m);
	clear();
	for (int i=1;i<=n;i++) {
		scanf("%d",&s[i][0]);
		for (int j=1;j<=s[i][0];j++) scanf("%d",&s[i][j]);
		if (s[i][0]==1) s[i][2]=s[i][1];
		if (s[i][1]>s[i][2]) swap(s[i][1],s[i][2]);
	}
	for (int i=1;i<=n;i++) {
		scanf("%d",&t[i][0]);
		for (int j=1;j<=t[i][0];j++) scanf("%d",&t[i][j]);
		if (t[i][0]==1) t[i][2]=t[i][1];
		if (t[i][1]>t[i][2]) swap(t[i][1],t[i][2]);
		sta[i]=(t[i][1]==s[i][1]||t[i][1]==s[i][2])|(t[i][2]==s[i][1]||t[i][2]==s[i][2])<<1;
		e[t[i][1]].pb({t[i][2],i,sta[i]}),e[t[i][2]].pb({t[i][1],i,(sta[i]>>1)&1|(sta[i]&1)<<1});
	}
}
void mian() {
	input();
	getscc();
}
```

---

## 作者：Fzrcy (赞：0)

首先判断 Bob 是否能够保证 $b_{1}, \ldots, b_{n}$ 互不相同：将 $T_{i,1}$ 和 $T_{i,2}$ 之间连边，则 $b_{1}, \ldots, b_{n}$ 互不相同当且仅当可以给每条边定向，使得每个点的入度小于等于 $1$，其充要条件为对于每个连通块 $(V,E)$ 均满足 $|V|\ge |E|$。

对于边 $(T_{i,1},T_{i,2})$，若 $|T_i\cap S_i|=0$ 则该边一定不会对答案产生影响，若 $|T_i\cap S_i|=1$ 则 Alice 一定会选择交集中唯一的元素，若 $|T_i\cap S_i|=2$ 则 Alice 可以选择任意一个元素，若 Alice 选择 $T_{i,1}$，则称 Alice 将边 $i$ 的方向定为 $T_{i,2}\to T_{i,1}$，选择 $T_{i,2}$ 同理，若无法对边 $i$ 定向，则默认其为无向边，和任意一条有向边的方向均相同。

则题意转化为 Alice 和 Bob 分别对边定向（Alice 先定向），设 $X$ 表示满足 Alice 和 Bob 对边 $i$ 定的方向相同的 $i$ 的个数。Alice 希望 $X$ 尽量大，Bob 希望 $X$ 尽量小。

在 Alice 的方案中先对所有的 $|T_i\cap S_i|=1$ 的边定向为朝向选择的数 $x$（$x\in T_i\cap S_i$）的方向。

显然每个连通块之间互不影响，我们对每个连通块分别计算答案，最后相加即可。

先考虑 $|V|=|E|$ 的基环树： 

- 对于非环边，在 Bob 的方案中其方向唯一，直接计算其贡献即可。
- 当环的大小为一时，若 Alice 可以选则它一定会产生贡献。
- 当环的大小大于一时，Bob 只有两种方案，若 Alice 的定向方案确定，则 Bob 一定选择最优的那个。设顺时针的边数为 $c1$、逆时针的边数为 $c2$、未确定方向的边数为 $c3$，则其贡献为 $\max_{i=1}^{c3}\min(c1+i,c2+c3-i)$，显然 $c1+i$ 和 $c2+c3-i$ 最接近时最优。假设 $c1<c2$，若 $c1+c3\le c2$ 则贡献为 $c1+c3$，否则为 $\lfloor\frac{c1+c2+c3}{2}\rfloor$。

然后是 $|V|=|E|+1$ 的树：

显然 Bob 有 $|V|$ 种方案，任意一种方案可以表示为选择一个点 $rt$，并以它为根，所有边的方向为朝向叶子端的方向，设其贡献为 $f_{rt}$（在已知 Alice 的定向方案的情况下）。

设 $D_i$ 表示点集 $\{rt\}$ ，满足边 $i$ 定的方向会对 $f_{rt}$ 产生贡献。

若对未确定方向的边 $i,j$ 定向后 $D_i\cap D_j=\empty$，则我们可以对两条边的方向都取反，使得 $D_i\cup D_j=V$、$D_i\cap D_j\ne\empty$，显然答案不会变劣。因此 Alice 的方案中任意一对未确定方向的边 $i,j$ 均满足 $D_i\cap D_j\ne\empty$，即 Alice 的方案可以表示为以某一个点 $u$ 为根，将未定向的边定向为朝向叶子端的方向，于是答案为 $\max_{u\in V}\min_{rt\in V}f_{rt}$，我们对 $u$ 进行换根，并对 $f_{rt}$ 用线段树动态维护，时间复杂度为 $O(n\log n)$。

总时间复杂度为 $O(\sum n\log n)$。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
#define gc getchar()
constexpr int N=1.1e6+9;

inline int in(){
    char c;int x=0,bo=0;
    while(!isdigit(c=gc))if(c=='-')bo=1;
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=gc;
    return bo?-x:x;
}

int h[N<<1],nt[N<<1],to[N<<1],cnt,lid[N<<1];
void lnkcls(int siz){
    for(int i=1;i<=siz;i++)h[i]=0;
    cnt=1;
}
void Add(int u,int v,int w){
    // printf("(%d,%d,%d)\n",u,v,w);
    nt[++cnt]=h[u],h[u]=cnt,to[cnt]=v,lid[cnt]=w;
    nt[++cnt]=h[v],h[v]=cnt,to[cnt]=u,lid[cnt]=w;
}

int As[N][2],Bs[N][2];
namespace CTree{
    vector<int>nd,nl;
    bool ban[N],flag;
    int stk[N],top,stkl[N];
    int vis[N],dft;
    void cls(int siz){
        for(int i=1;i<=siz;i++)
            ban[i]=0,stk[i]=stkl[i]=vis[i]=0;
        top=dft=0,flag=0,nd.clear(),nl.clear();
    }
    void Fc(int x,int fai){
        vis[x]=++dft,stk[++top]=x,stkl[top]=lid[fai];
        for(int i=h[x],v;i;i=nt[i])
        if(i!=fai&&(i^1)!=fai){
            if(vis[v=to[i]]){
                if(vis[v]>vis[x])continue;
                while(stk[top]!=v){
                    nd.push_back(stk[top]);
                    nl.push_back(stkl[top]);
                    top--;
                }
                nd.push_back(v);
                nl.push_back(lid[i]);
                for(auto node:nd)
                    ban[node]=1;
                flag=1;
            }
            else Fc(v,i);
            if(flag)break;
        }
        if(flag)return;
        --top;
    }
    int cst(int u,int fa){
        int res=0;
        for(int i=h[u],v;i;i=nt[i])if((v=to[i])!=fa&&!ban[v])
            res+=cst(v,u)+(As[lid[i]][0]==v||As[lid[i]][1]==v);
        return res;
    }
    int sol(int pos){
        flag=0,nd.clear(),nl.clear(),Fc(pos,0);
        // for(auto i:nd)cout<<i<<' ';puts("");
        int ans=0;
        for(int i:nd)ans+=cst(i,0);
        // puts("ok");
        int siz=nd.size(),L=0,R=0,s=0;
        if(siz==1){
            int lnk=nl[0],x=nd[0];
            return ans+(As[lnk][0]==x||As[lnk][1]==x);
        }
        for(int i=0;i<siz;i++){
            int x=nd[i],y=nd[(i+1)%siz],lnk=nl[i];
            bool fl=(As[lnk][0]==x||As[lnk][1]==x);
            bool fr=(As[lnk][0]==y||As[lnk][1]==y);
            if(!fl&&!fr)continue;
            if(fl&&fr){++s;continue;}
            if(fl)++L;
            if(fr)++R;
        }
        if(L>R)swap(L,R);
        int t=min(s,(R-L));
        s-=t,L+=t;
        return L+(s/2)+ans;
    }
}
namespace Tree{
    struct SegTree{
        int s[N<<2],g[N<<2];
        void up(int x){s[x]=min(s[x<<1],s[x<<1|1]);}
        void TG(int x,int v){s[x]+=v,g[x]+=v;}
        void dw(int x){if(g[x])TG(x<<1,g[x]),TG(x<<1|1,g[x]),g[x]=0;}
        void Add(int k,int l,int r,int x,int y,int v){
            if(l>=x&&r<=y)return TG(k,v);
            int mid=(l+r)>>1;dw(k);
            if(x<=mid)Add(k<<1,l,mid,x,y,v);
            if(y>mid) Add(k<<1|1,mid+1,r,x,y,v);
            up(k);
        }
        void build(int k,int l,int r){
            s[k]=g[k]=0;if(l==r)return;int mid=(l+r)>>1;
            build(k<<1,l,mid); build(k<<1|1,mid+1,r);
        }
    }SMT;
    int dfn[N],sz[N],dft;
    int ans;
    void cls(int siz){
        for(int i=1;i<=siz;i++)
            dfn[i]=sz[i]=0;
        ans=dft=0;
    }
    void dfs(int u,int fa){
        dfn[u]=++dft,sz[u]=1;
        for(int i=h[u],v;i;i=nt[i])if((v=to[i])!=fa){
            dfs(v,u),sz[u]+=sz[v];
        }
    }
    void op1(int x,int v){
        int l=dfn[x],r=dfn[x]+sz[x]-1;
        SMT.Add(1,1,dft,l,r,v);
    }
    void op2(int x,int v){
        int l=dfn[x],r=dfn[x]+sz[x]-1;
        if(l>1)  SMT.Add(1,1,dft,1,l-1,v);
        if(r<dft)SMT.Add(1,1,dft,r+1,dft,v);
    }
    void dp1(int u,int fa){
        for(int i=h[u],v;i;i=nt[i])if((v=to[i])!=fa){
            dp1(v,u);
            int l=lid[i];
            bool fl=(As[l][0]==u||As[l][1]==u);
            bool fr=(As[l][0]==v||As[l][1]==v);
            if(fr)op2(v,1);
            if(!fr&&fl)op1(v,1);
        }
    }
    void dp2(int u,int fa){
        ans=max(ans,SMT.s[1]);
        for(int i=h[u],v;i;i=nt[i])if((v=to[i])!=fa){
            int l=lid[i];
            bool fl=(As[l][0]==u||As[l][1]==u);
            bool fr=(As[l][0]==v||As[l][1]==v);
            if(fl&&fr)op2(v,-1),op1(v,1);
            dp2(v,u);
            if(fl&&fr)op2(v,1),op1(v,-1);
        }
    }
    int sol(int pos,int siz){
        dft=0,ans=0;SMT.build(1,1,siz);
        dfs(pos,0);dp1(pos,0),dp2(pos,0);
        return ans;
    }
}
namespace Work{
    int fa[N],Siz[N],n,m,Sz[N];
    int gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);}
    void mer(int x,int y){
        if((x=gf(x))!=(y=gf(y)))
            fa[x]=y,Siz[y]+=Siz[x],Sz[y]+=Sz[x];
    }
    bool check(){
        lnkcls(m);
        for(int i=1;i<=m;i++)fa[i]=i,Siz[i]=0,Sz[i]=1;
        for(int i=1;i<=n;i++){
            int x=Bs[i][0],y=Bs[i][1];
            mer(x,y),++Siz[gf(x)];
        }
        for(int i=1;i<=m;i++)
            if(Siz[i]>Sz[i])
                return 0;
        for(int i=1;i<=n;i++)
            Add(Bs[i][0],Bs[i][1],i);
        return 1;
    }
    int Main(){
        n=in(),m=in();
        CTree::cls(m);
        Tree::cls(m);
        lnkcls(m);
        for(int i=1,s;i<=n;i++){
            s=in();
            if(s==1)As[i][0]=in(),As[i][1]=As[i][0];
            else As[i][0]=in(),As[i][1]=in();
        }
        for(int i=1,s;i<=n;i++){
            s=in();
            if(s==1)Bs[i][0]=in(),Bs[i][1]=Bs[i][0];
            else Bs[i][0]=in(),Bs[i][1]=in();
        }
        if(!check()){
            puts("-1");
            return 0;
        }
        int ans=0;
        for(int i=1;i<=m;i++)
            if(fa[i]==i){
                if(Siz[i]==Sz[i])
                    ans+=CTree::sol(i);
                else ans+=Tree::sol(i,Sz[i]);
            }
        cout<<ans<<'\n';
        return 0;
    }
}
int main(){
    int T=in();
    while(T--)
        Work::Main();
    return 0;
}
```



---

## 作者：blackname (赞：0)

超级无敌炫酷原神大王题目。

首先先通过搜索把 $|T_i|=1$ 的情况都解决掉，接下来只考虑 $|T_i|=2$ 的情况。

将每个 $T_i$ 中的两个元素连边，形成一张无自环的无向图，Bob 要干的事即给每一条边定向，使得每个点的入度不超过 $1$。

发现如果某个连通块满足 $|V|<|E|$ 就是显然无解了，接下来分 $|V|=|E|,|V|=|E|+1$ 的两种情况讨论。

- $|V|=|E|$

连通块是一棵基环树，定向方式只有两种，直接枚举这两种方式，看每条边上 Alice 能否造成 $1$ 的贡献。

设 $c_1,c_2$ 分别为 Alice 只能对第一种/第二种定向方式产生贡献的边数，再设 $c_3$ 为 Alice 可以选择对两种方式的其中一种产生贡献的边数，简单分类可知该连通块答案即为 $\min(c_1+c_3,c_2+c_3,\left\lfloor\dfrac{c_1+c_2+c_3}{2}\right\rfloor)$。

- $|V|=|E|+1$

连通块形成树，本题的核心，这里提供一个 $O(n\log n)$ 的做法。

考虑如果强制不选择树内一点，那么其它边的定向方向都确定了，下面称强制不选择 $i$ 点的定向方案为 $i$ 的定向方向。

观察可知，对于一条边 $(u,fa_u)$，如果 Alice 选择了 $u$，那么他会对 $u$ 子树内所有点的定向方案产生 $1$ 的贡献，如果他选择了 $fa_u$，会对子树外点的定向方案产生 $1$ 的贡献。

那么可以来看 Alice 的策略，对于每条边，如果他只能对一种定向方式产生贡献或者不能产生贡献，那么他的选择是显然的，一次差分可以处理出这部分贡献，每个点的定向方案的当前权值记为 $s_i$。

对于剩下的边，Alice 需要选择让子树外或者子树内的 $s_i$ 加一，使得最终得到的 $s_i$ 最小值最大。

为了方便叙述，这里把该问题转化为每次先全局加一，然后选择子树外或者子树内减一，使得减一次数最大的最小，并且每个点有初始减的次数 $s_i$。（两个 $s_i$ 意义相近，但是值不相同，下文中子树内/外加一均指子树内/外被减次数加一）

这种最大值最小化问题通常考虑二分，先二分一个 $mid$ 作为全局被减次数最大值的上界。

观察到一个重要的性质：不会存在两个子树不交的边，它们同时选择了子树外加一，原因是可以调整为同时选择子树内加一，必然不劣。

那么可以直接考虑从叶子开始贪心，具体策略为，统计 $u$ 的每个儿子子树内当前被减次数最大值（带上 $u$ 子树内选择子树外加一的贡献），如果 $(u,fa_u)$ 需要决策，分类讨论：如果 $u$ 子树内没有被减次数达到 $mid$ 的点，直接选择子树内加一；反之，只能选择子树外加一。

策略的证明：如果策略有问题，只能出现在有一个点子树内并没有卡到上界，但是却选择了子树外加一，那么这个点选择子树外加一一定是为了某个点的决策做准备，这种情况又有两种可能：

- $u$ 选择子树外加一是为了某个祖先 $anc$ 选择子树内加一做准备。

这种情况，将 $u,anc$ 决策互换，必然不劣。

- $u$ 选择子树外加一是为了某个 $v$ 选择子树外加一做准备，其中 $u$ 子树与 $v$ 子树不交。

这种情况，由上文的性质可知不够优。

综上完成了贪心策略的证明，也就解决了树的问题。

对于原问题，只需要对于每个连通块所得的答案相加，便可得到最终的答案。

时间复杂度 $O(n\log n)$，常数不像我场上写的那坨东西那么大就可通过。

---


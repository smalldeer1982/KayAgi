# [省选联考 2023] 染色数组

## 题目描述

给定一个长度为 $n$ 的正整数数组 $A$，其中每个数都在 $1$ 到 $m$ 之间，从左到右排成一排。现在要将每个数字染成红色或者绿色，我们定义一个染色方案为优秀的染色方案，当且仅当它满足：

1. 每个数 $A_{i}$ 要么被染成红色，要么被染成绿色。
2. 红色的数从左到右依次严格递增，绿色的数从左到右依次严格递减。

例如：$1\;9\;3\;4\;7\;6$ 中，将 $1\;3\;4\;7$ 染成红色，$9\;6$ 染成绿色是优秀的染色方案（$\color{red}1\color{green}9\color{red}347\color{green}6$）；$1\;3\;4\;6$ 染成红色，$9\;7$ 染成绿色也是优秀的染色方案（$\color{red}1\color{green}9\color{red}34\color{green}7\color{red}6$）。但是将 $1\;4\;7\;6$ 染成红色，$9\;3$ 染成绿色则**不是**优秀的染色方案，因为 $1\;4\;7\;6$ 不是递增的。$1\;9\;5\;5$ 中，将 $1$ 和任意一个 $5$ 染色红色，$9$ 和另一个 $5$ 染成绿色，也是优秀的染色方案（其中一种是 $\color{red}1\color{green}95\color{red}5$）。

如果一个数组**至少存在两个不同的**优秀的染色方案，那么称这个数组是**完美**的。（两个染色方案不同当且仅当至少存在一个位置上的数字被染成不同的颜色）。

例如，$1\;9\;3\;4\;7\;6$ 和 $1\;9\;5\;5$ 都是完美的，因为上面已经分别给出了 $2$ 种优秀的染色方案。而 $2\;3\;3\;3$ 则不是完美的，因为找不到任何一种优秀的染色方案。同时 $1\;5\;3\;6\;4$ 也不是完美的，因为仅存在一种优秀的染色方案（$\color{red}1\color{green}5\color{red}36\color{green}4$）。

补充说明：如果红色的数只有 $0$ 个或者 $1$ 个，我们也认为它严格递增；同理如果绿色的数只有 $0$ 个或者 $1$ 个，我们也认为它严格递减。例如 $\color{red}123$，$\color{red}1\color{green}2\color{red}3$ 都是优秀的的染色方案，因此 $1\;2\;3$ 是完美的数组。

我们定义一种给染色方案打分的方式。

对于每个的有序元素对 $A_{i}, A_{j}(i<j)$ :

1. 如果 $A_{j}$ 染成红色，且 $A_{j}<A_{i}$，则该元素对得 $m-A_{j}+1$ 分;
2. 如果 $A_{j}$ 染成绿色，且 $A_{j}>A_{i}$，则该元素对得 $A_{j}$ 分;
3. 不满足 1 或 2 ，则该元素对得 $0$ 分。

则一个染色方案的得分为所有有序元素对的得分和。

一个完美的数组的得分为它所有优秀的染色方案的得分的最大值。

现在确定数组 $A$ 的前 $t$ 个数 $A_{1}, A_{2}, \ldots, A_{t}$, 你需要回答以下两个问题:

- 第一问：有多少种确定 $A$ 中后 $n-t$ 个数的方案使得 $A$ 是一个完美数组？
- 第二问：所有可能的完美数组的得分和是多少？

由于答案太大，你只需要输出答案在模 $998244353$ 下的结果即可。

## 说明/提示

**【评分方式】**

每个测试点 $5$ 分。

每一行应按顺序输出两问的答案，不符合输出格式的输出得 $0$ 分。

程序仅回答对第一问得 $1$ 分，仅回答对第二问得 $4$ 分，两问都答对得 $5$ 分。

如果你不回答第一问或第二问，也需要在对应位置上输出任意一个整数以满足输出格式。

**【子任务】**

对于所有的数据，保证： $1 \leq C \leq 5$；$2 \leq n \leq 50$；$1 \leq t \leq n$；$1 \leq m \leq 200$；$1 \leq A_{i} \leq m$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/swc3o5bm.png)

## 样例 #1

### 输入

```
5
6 10 6
1 9 3 4 7 6
5 8 4
1 7 2 6
9 10 2
3 6
6 11 6
1 7 5 8 3 9
9 10 5
5 10 6 4 7
```

### 输出

```
1 63
8 245
29378 1267731
1 17
78 1820
```

## 样例 #2

### 输入

```
见附件中的 color/color2.in```

### 输出

```
见附件中的 color/color2.ans```

# 题解

## 作者：Alex_Wei (赞：48)

#### [P9171 [省选联考 2023] 染色数组](https://www.luogu.com.cn/problem/P9171)

很明显，要想会做第二问，首先得会做第一问。要想会做第一问，首先得找到方便统计答案的方式刻画完美数组。

##### 刻画完美数组

从定义入手，完美数组是具有至少两种染色方案的数组，显然存在一个元素在两种方案中分别被染上了红色和绿色。这启发我们考虑一个元素可以被染成红色和绿色的充要条件。

- 元素 $a_i$ 被染成红色，那么
  - $[1, i)$ 中 $\ge a_i$ 的元素，和 $(i, n]$ 中 $\le a_i$ 的元素形成递减序列。
  - $[1, i)$ 中 $< a_i$ 的元素，和 $(i, n]$ 中 $> a_i$ 的元素形成递增序列。
- 元素 $a_i$ 被染成绿色，那么
  - $[1, i)$ 中 $\le a_i$ 的元素，和 $(i, n]$ 中 $\ge a_i$ 的元素形成递增序列。
  - $[1, i)$ 中 $> a_i$ 的元素，和 $(i, n]$ 中 $< a_i$ 的元素形成递减序列。

将四个条件拼起来（其中两个条件分别弱于另外两个条件），得

> **结论 1**：元素 $a_i$ 可以被染成红色和绿色，当且仅当其满足以下所有条件：
>
> - $[1, i)$ 中 $\ge a_i$ 的元素，和 $(i, n]$ 中 $\le a_i$ 的元素形成递减序列。
> - $[1, i)$ 中 $\le a_i$ 的元素，和 $(i, n]$ 中 $\ge a_i$ 的元素形成递增序列。

这两个条件看起来非常棒，满足条件的元素性质一定很好。称这些元素为 **关键元素**，对应下标集合 $S$。

接下来探究关键元素的性质。

考虑两个关键元素 $a_l, a_r$（$l < r$）：

- 如果 $a_l = a_r$，那么它们只能相邻，即 $l + 1 = r$，否则易证不合法。
- 如果 $a_l > a_r$，那么根据 $a_l$ 和 $a_r$ 是关键元素，可知 $a_{l + 1\sim r - 1}$ 只能落在 $[a_r + 1, a_l - 1]$，则 $a_l > a_{l + 1} > \cdots > a_r$。进一步推出 $\forall i\in [l, r], i\in S$。
- 如果 $a_l < a_r$，同理有 $a_l < a_{l + 1} < \cdots < a_r$，且 $\forall i\in [l, r], i\in S$。

> **结论 2**：完美数组的 $S$ 为一段 **非空** 区间 $[l, r]$，且满足下列条件之一：
>
> - $a_l = a_r$ 且 $l + 1 = r$。
> - $a_l < a_{l + 1} < \cdots < a_r$。
> - $a_l > a_{l + 1} > \cdots > a_r$。

关键元素的形态刻画完了，再考虑非关键元素的形态，易知

> **结论 3**：设 $L = \min(a_l, a_r)$，$R = \max(a_l, a_r)$，则
>
> - $[1, l)$ 中 $> R$ 的元素递减，$< L$ 的元素递增，不存在值落在 $[L, R]$ 的元素。
> - $(r, n]$ 中 $> R$ 的元素递增，$< L$ 的元素递减，不存在值落在 $[L, R]$ 的元素。

设 $Q(r, x, y)$ 表示条件：$[1, r)$ 中小于 $x$ 的数递增，大于 $y$ 的数递减，且不存在值落在 $[x, y]$ 的元素。

##### 第一问

我们已经得到充分的性质解决第一问。考虑在 $a_r$ 处统计答案。

- 对于结论 2 的情况 1，枚举 $r$ 和 $a_r$，根据结论 3 求出安排对应前缀 $[1, r - 1)$ 和后缀 $(r, n]$ 的方案数。

- 对于结论 2 的情况 2 和 3，枚举 $r$ 和 $a_r$，则为了让 $r + 1\notin S$：

  - 若 $a_r < a_{r + 1}$，则要求 $[1, r)$ 中 $> a_r$ 的最小值不大于 $a_{r + 1}$，否则无论是情况 2 还是情况 3，根据 $a_r$ 是关键元素均可推出 $a_{r + 1}$ 是关键元素，反之一定有 $r + 1\notin S$。

    直接算不好算，容斥一下就是用 $Q(r, a_r, a_r)$ 的方案数减去 $Q(r, a_r, a_{r + 1})$ 的方案数。这里及下文的方案数，均指不考虑 $a_{r + 2\sim n}$，只考虑 $a_{1\sim r - 1}$ 的方案数。

  - $a_r = a_{r + 1}$ 不合法，因为 $r$ 和 $r + 1$ 要么同属于 $S$，要么同不属于 $S$。

  - 若 $a_r > a_{r + 1}$，类似地，要求 $[1, r)$ 中 $< a_r$ 的最大值不小于 $a_{r + 1}$，反之一定有 $r + 1\notin S$。

  这说明我们还要枚举 $a_{r + 1}$。

综合上述讨论，发现要求满足 $Q(r, x, y)$ 的方案数。对于后缀，限制是类似的。

- 设 $f_{i, x, y}$ 表示 $[1, i]$ 中满足 $Q(i, x + 1, y - 1)$ 且存在 $x$ 和 $y$ 的方案数。初始递增序列开头为 $0$，递减序列开头为 $m + 1$，即初始化 $f_{0, 0, m + 1} = 1$。枚举 $a_{i + 1}$ 转移结合前 / 后缀和优化做到 $\mathcal{O}(nm ^ 2)$ 计算 $f$，对每个 $f_i$ 做二维前缀和。
- 也可以用组合方法计算 $f$，接下来会讲，且非常重要。这样复杂度是 $\mathcal{O}(n ^ 2 m ^ 2)$。

##### 第二问

接下来考虑第二问。

计数题里面套了个 $\max$，怎么看都觉得阴间。

在考虑每个元素产生的贡献时，其前面的元素的颜色是不重要的。因此，考虑一个完美数组，计算其得分时，只有关键元素的颜色会对 $\max$ 产生影响。

- 对于情况 1，两个关键元素一红一绿，因值相等故两种染色方案得分相等。

- 对于情况 2，只有至多一个关键元素被染成绿色。考虑被染成绿色的关键元素，若其不为 $a_r$，则将其染成红色，下一个元素染成绿色，染色方案的得分不降。

  因此，$a_l\sim a_{r - 1}$ 被染成红色，只有 $a_r$ 的颜色对 $\max$ 产生影响。而 $a_r$ 是要枚举的，所以它的贡献可在枚举时一并刻画，这看起来很棒。

- 对于情况 3，同理。

> **结论 4**：完美数组的得分为：
>
> - 对于情况 1，任意一种染色方案的得分。
> - 对于情况 2 和 3，将 $[1, r)$ 中 $< a_r$ 的元素和 $(r, n]$ 中 $> a_r$ 的元素染成红色，$[1, r)$ 中 $> a_r$ 的元素和 $(r, n]$ 中 $< a_r$ 的元素染成绿色，$a_r$ 染成贡献较大的颜色的染色方案的得分。
>
> 这两种情况可以统一起来，但计算时仍需分类讨论。原因是情况 1 和情况 2，3 本质不同。

**以下讨论情况 2 和 3**。

$[1, r)$ 和 $(r, n]$ 在贡献计算方式上本质相同，于是统一考虑。

枚举 $r$，$a_r$ 和 $a_{r + 1}$。**不妨设 $\boldsymbol {a_r < a_{r + 1}}$，反之同理**。

- 对于 $[1, r)$：类似第一问 DP。维护所有完美数组的当前得分之和，红色元素数量之和，绿色元素数量之和，以及方案数。时间复杂度 $\mathcal{O}(nm ^ 2)$。

- 对于 $r$：若从 DP 入手，则需再记录一维表示红色元素的数量，有点麻烦。

  考虑组合方法。注意首先检查 $[1, r)$ 已经确定的部分是否符合要求。

  设 $[1, r)$ 已经确定的部分 $< a_r$ 的元素数量为 $c_d$，最大值为 $v_d$，$> a_r$ 的元素数量为 $c_u$，最小值为 $v_u$。设还有 $k$ 个位置没有确定。枚举未确定部分 $< a_r$ 的元素数量 $i$，则贡献为
  $$
  \sum_{i = 0} ^ k \binom {k} {i} \binom {a_r - v_d - 1} {i} \binom {v_u - a_r - 1} {k - i} \max((m - a_r + 1) (c_u + k - i), a_r (c_d + i))
  $$
  再减去不合法（使得 $a_{r + 1}\in S$）的贡献，对应第一问的容斥。
  $$
  \sum_{i = 0} ^ k \binom k i \binom {a_r - v_d - 1} {i} \binom {v_u - a_{r + 1} - 1} {k - i} \max((m - a_r + 1) (c_u + k - i), a_r(c_d + i))
  $$
  不要忘记乘以对应方案数。时间复杂度 $\mathcal{O}(n ^ 2m ^ 2)$。

- 对于 $(r, n]$：根据点对贡献的定义，位置在 $r$ 之后的元素只会和位置在 $r$ 之前的元素产生贡献。这两部分相对独立。

  计算每个数在 $[1, r)$ 中出现的方案数（只安排 $a_{1\sim r - 1}$，注意 $a_r$ 和 $a_{r + 1}$ 已确定）$c_i$。枚举产生贡献的数 $a_j$（只关心数值，不关心位置），根据 $a_j$ 和 $a_r$ 的相对大小关系可知其颜色。不妨设 $a_j$ 被染成绿色（$a_r > a_j$），则 $a_j$ 产生的贡献为：$a_j$ 在 $(r, n]$ 中出现的方案数（只安排 $a_{r + 1\sim n}$）$d_{a_j}$，乘以 $a_j$，再乘以 $\sum_{i = 1} ^ {a_j - 1} c_i$。

  计算 $c_i$：

  - 若 $i$ 在 $[1, r)$ 已经确定确定的部分出现，则 $c_i$ 等于安排 $a_{1\sim r - 1}$ 的方案数。

  - 否则，对于 $i < a_r$，要求 $v_d < i < a_r$，可以认为 $i$ 在所有方案中是均匀的（感性理解），即所有 $v_d < i < a_r$ 的 $c_i$ 相等。算出 $\sum c_i$ 即
    $$
    \sum_{i = 0} ^ k i\binom k i \binom {a_r - v_d - 1} {i} \left(\binom {v_u - a_{r} - 1} {k - i} - \binom {v_u - a_{r + 1} - 1} {k - i} \right)
    $$
    对于 $i > a_r$，分别对容斥的两部分算出平均值再相减，而不是先相减再取平均。

  计算 $d_{a_j}$：

  - 类似地，若 $a_j$ 在 $(r, n]$ 已经确定的部分出现或等于枚举的 $a_{r + 1}$，则 $d_{a_j}$ 等于安排 $a_{r + 2\sim n}$ 的方案数。

  - 否则直接对 $< x$ 和 $> y$ 的两部分分别算总数取平均（后缀不需要容斥）。用组合数算总数。

    注意这里不是 $< a_r$ 和 $> a_{r + 1}$，因为当 $r < t$ 时，已经确定的数对未确定的数有更紧的界。

  直接做的复杂度是 $\mathcal{O}(nm ^ 3)$，因为枚举了 $a_j$。考虑优化复杂度。

##### 优化复杂度

当 $r < t$ 时，$a_r$ 和 $a_{r + 1}$ 均不需要枚举。当 $r\geq t$ 时，$[1, a_r)$，$a_{r + 1}$ 和 $(a_{r + 1}, n]$ 的 $d$ 值分别相同，枚举太浪费时间。

- 当 $r < t$ 时，可直接暴力计算。

- 当 $r\geq t$ 时，转换视角，考虑 $c_i$ 和所有 $d_j$ 之间的贡献，后者形如 $j$ 属于某个区间范围内的 $\sum d_j j$ 或 $\sum d_j (m - j + 1)$。因 $d$ 值为三个连续段，可以 $\mathcal{O}(1)$ 计算。

  在 $a_{1\sim t}$ 中出现过的 $i$（共 $t$ 个）的 $c_i$ 的贡献分别 $\mathcal{O}(1)$ 计算，而没出现过的 $c_i$ 依然为取值相同的三段区间，$\mathcal{O}(1)$ 计算一段 $c$ 值相同的区间和一段 $d$ 值相同的区间之间的贡献。

总时间复杂度 $\mathcal{O}(n ^ 2 m ^ 2)$。

一些细节：

- 在使用组合方法计算前缀或后缀方案数时，先判断已经确定的数是否合法。
- 特判 $r = n$。
- 情况 1 的第二问和情况 2，3 的第二问略有不同，可类似推导，细节处理一定要仔细，不能想当然。
- 可以对 $i < t$ 预处理 $r = i$ 时后缀是否合法及对应方案数，方便处理。
- 题解的大部分地方都只讨论了一种情况，因为另一种情况是对称的。繁琐的分类讨论导致代码量和细节很多，想清楚再开始写。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

bool Mbe;
constexpr int N = 50 + 5, M = 200 + 5, mod = 998244353;
void cmin(int &x, int y) {x = x < y ? x : y;}
void cmax(int &x, int y) {x = x > y ? x : y;}
void addt(int &x, int y) {x += y, x >= mod && (x -= mod);}
void subf(int &x, int y) {x -= y, x < 0 && (x += mod);}
int add(int x, int y) {return x += y, x >= mod && (x -= mod), x;}
int sub(int x, int y) {return x -= y, x < 0 && (x += mod), x;}
int S(int l, int r) {return (l + r) * (r - l + 1) / 2;}
int S2(int x) {return x * (x + 1) * (x + x + 1) / 6;}
int S2(int l, int r) {return S2(r) - S2(l - 1);}

int n, m, t, ans1, ans2, a[N], b[N], d[M], up[N], dn[N], inv[M], val1[N], val2[N], C[M][M], g[N][M][M], gi[N][M][M];
bool chk(int i, int v) {return !a[i] || a[i] == v;}
int getg(int k, int x, int y) {return x < 0 || y < 0 ? 0 : x < y ? g[k][x][y] : g[k][y][x];}
int getgi(int k, int x, int y) {return x < 0 || y < 0 ? 0 : 1ll * (x < y ? gi[k][x][y] : sub(1ll * g[k][y][x] * k % mod, gi[k][y][x])) * inv[x] % mod;} // 想一想 x > y 时为什么要将 i 变成 k - i.
int csuf(int p, int x, int y) {return p - 2 < t ? max(0, b[p - 2]) : getg(n - (p - 1), x - 1, m - y);}
struct dat {
  int f, su, lo, hi;
  dat operator + (const dat &z) const {return {add(f, z.f), add(su, z.su), add(lo, z.lo), add(hi, z.hi)};}
  dat operator - (const dat &z) const {return {sub(f, z.f), sub(su, z.su), sub(lo, z.lo), sub(hi, z.hi)};}
  dat addlo(int z) {return {f, add(su, 1ll * (m - z + 1) * hi % mod), add(lo, f), hi};}
  dat addhi(int z) {return {f, add(su, 1ll * z * lo % mod), lo, add(hi, f)};}
} f[N][M][M], E;
struct itv {int l, r, val;};

void solve() {
  cin >> n >> m >> t, ans1 = ans2 = 0;
  memset(a, 0, sizeof(a)); for(int i = 1; i <= t; i++) cin >> a[i];
  for(int i = 1; i < t; i++) {
    dn[i] = min(a[i], a[i + 1]), up[i] = max(a[i], a[i + 1]);
    for(int j = i + 2; j <= t; j++) a[j] > up[i] ? up[i] = a[j] : dn[i] = (a[j] < dn[i] ? a[j] : -1);
    b[i] = dn[i] != -1 ? getg(n - t, dn[i] - 1, m - up[i]) : -1; // -1 表示 r 不合法.
  }
  memset(f, 0, sizeof(f));
  for(int x = 0; x <= m; x++) for(int y = m + 1; y; y--) f[0][x][y] = {1, 0, 0, 0};
  for(int i = 1; i < n; i++) { // DP 部分.
    for(int v = 1; v <= m; v++) if(chk(i, v)) {
      for(int y = m + 1; y > v; y--) f[i][v][y] = (f[i - 1][v - 1][y] - f[i - 1][v - 1][y + 1]).addlo(v);
      for(int x = 0; x <= m; x++) f[i][x][v] = f[i][x][v] + (f[i - 1][x][v + 1] - (x ? f[i - 1][x - 1][v + 1] : E)).addhi(v);
    }
    for(int x = 0; x <= m; x++) for(int y = m + 1; y > x; y--) // 二维前缀和.
      f[i][x][y] = f[i][x][y] + f[i][x][y + 1] + (x ? f[i][x - 1][y] - f[i][x - 1][y + 1] : E);
  }
  for(int r = 1; r <= n; r++) for(int v = 1; v <= m; v++) if(chk(r, v)) {
    int k = max(0, r - 1 - t), cd = 0, vd = 0, cu = 0, vu = m + 1, equal = 0;
    int pre = 0, suf = 0, tot = 0, sufok = r >= t || r < t && b[r] != -1;
    for(int i = 1; i < r && i <= t && vd != -1 && vu != -1; i++) {
      if(a[i] < v) cd++, a[i] > vd ? vd = a[i] : vd = -1;
      if(a[i] == v) equal++;
      if(a[i] > v) cu++, a[i] < vu ? vu = a[i] : vu = -1;
    }
    if(vu == -1 || vd == -1 || equal > 1 || equal == 1 && a[r - 1] != v) continue; // 前缀不合法, 注意情况 1 的 equal 可以等于 1.
    auto calc = [&](int v2) { // (r, n], 被调用 O(nm ^ 2) 次.
      if(r == 1 || r == n) return; // r = 1 或 r = n 一定不产生贡献.
      if(r < t) { // 总共调用 O(n) 次, 随便暴力.
        memset(d, 0, sizeof(d));
        if(v < v2 && vu > v2 || v > v2 && vd < v2) return; // 判 r + 1 \in S 不合法.
        int hi = getgi(n - t, m - up[r], dn[r] - 1), lo = getgi(n - t, dn[r] - 1, m - up[r]);
        for(int i = up[r] + 1; i <= m; i++) d[i] = 1ll * hi * (m - i + 1) % mod;
        for(int i = dn[r] - 1; i >= 1; i--) d[i] = 1ll * lo * i % mod;
        for(int i = r + 1; i <= t; i++) addt(d[a[i]], 1ll * suf * (a[i] < v ? a[i] : m - a[i] + 1) % mod);
        for(int i = max(v, v2) + 1; i <= m; i++) addt(d[i], d[i - 1]);
        for(int i = min(v, v2) - 1; i; i--) addt(d[i], d[i + 1]);
        for(int i = 1; i < r - (v == v2); i++) addt(ans2, a[i] < v ? d[a[i] + 1] : d[a[i] - 1]); // 已经确定的数的 c = 1.
      }
      else {
        static itv c[3], d[3]; int C = 0, D = 0;
        if(v != v2) {
          d[D++] = {1, min(v, v2) - 1, getgi(n - (r + 1), min(v, v2) - 1, m - max(v, v2))};
          d[D++] = {max(v, v2) + 1, m, getgi(n - (r + 1), m - max(v, v2), min(v, v2) - 1)};
          d[D++] = {v2, v2, suf};
          if(v < v2) {
            if(vd + 1 < v) c[C++] = {vd + 1, v - 1, sub(getgi(k, v - vd - 1, vu - v - 1), getgi(k, v - vd - 1, vu - v2 - 1))};
            if(v2 + 1 < vu) c[C++] = {v2 + 1, vu - 1, sub(getgi(k, vu - v - 1, v - vd - 1), getgi(k, vu - v2 - 1, v - vd - 1))};
          }
          else {
            if(v + 1 < vu) c[C++] = {v + 1, vu - 1, sub(getgi(k, vu - v - 1, v - vd - 1), getgi(k, vu - v - 1, v2 - vd - 1))};
            if(vd + 1 < v2) c[C++] = {vd + 1, v2 - 1, sub(getgi(k, v - vd - 1, vu - v - 1), getgi(k, v2 - vd - 1, vu - v - 1))};
          }
        }
        else {
          d[D++] = {1, v - 1, getgi(n - r, v - 1, m - v)};
          d[D++] = {v + 1, m, getgi(n - r, m - v, v - 1)};
          if(vd + 1 < v && k) c[C++] = {vd + 1, v - 1, getgi(k - 1, v - vd - 1, vu - v - 1)}; // 这里是 k - 1!
          if(v + 1 < vu && k) c[C++] = {v + 1, vu - 1, getgi(k - 1, vu - v - 1, v - vd - 1)};
        }
        int tot = 0;
        for(int i = 1; i < r - (v == v2) && i <= t; i++) for(int j = 0; j < D; j++) { // 计算已经确定的 c_i 的贡献.
          const itv &I = d[j];
          if(a[i] < v && I.l < v && I.r > a[i]) addt(tot, 1ll * S(max(I.l, a[i] + 1), I.r) * I.val % mod);
          if(a[i] > v && I.l > v && I.l < a[i]) addt(tot, 1ll * S(m - min(I.r, a[i] - 1) + 1, m - I.l + 1) * I.val % mod);
        }
        addt(ans2, 1ll * tot * pre % mod);
        for(int i = 0; i < C; i++) for(int j = 0; j < D; j++) {
          const itv &I = c[i], &J = d[j]; int coef = 0;
          if(I.l < v && J.l < v) { // c 和 d 的区间, 要么后者包含前者, 要么后者为 [v2, v2]
            if(J.l <= I.l && I.r <= J.r) coef += (I.r - I.l + 1) * J.r * (J.r + 1) - S2(I.l, I.r) - S(I.l, I.r) >> 1;
            else if(I.r < J.l) coef += (I.r - I.l + 1) * J.l; // J.l = J.r = v2
          }
          if(I.l > v && J.l > v) {
            if(J.l <= I.l && I.r <= J.r) coef += S(I.l - J.l, I.r - J.l) * (m + 1) - (S2(I.l, I.r) - S(I.l, I.r) - (I.r - I.l + 1) * (J.l - 1) * J.l >> 1);
            else if(J.r < I.l) coef += (I.r - I.l + 1) * (m - J.l + 1);
          }
          addt(ans2, 1ll * coef * I.val % mod * J.val % mod);
        }
      }
    };
    if(r > 1 && chk(r - 1, v) && sufok) {
      suf = csuf(r + 1, v, v);
      addt(ans1, 1ll * (pre = f[r - 2][v - 1][v + 1].f) * suf % mod);
      addt(ans2, 1ll * f[r - 2][v - 1][v + 1].addlo(v).su * suf % mod); // [1, r)
      addt(ans2, 1ll * f[r - 2][v - 1][v + 1].lo * v % mod * suf % mod); // r
      calc(v);
    }
    if(equal) continue; // 情况 2 和 3 要求前缀没有等于 a[r] 的元素.
    for(int i = 0, val; i <= k; i++) { // 预处理经常要用的式子, 减小常数.
      val = 1ll * C[k][i] * max((m - v + 1) * (cu + k - i), v * (cd + i)) % mod;
      val1[i] = 1ll * val * C[v - vd - 1][i] % mod, val2[i] = 1ll * val * C[vu - v - 1][k - i] % mod;
    }
    if(r == n) {
      addt(ans1, f[r - 1][v - 1][v + 1].f);
      addt(ans2, f[r - 1][v - 1][v + 1].su); // [1, r)
      for(int i = 0; i <= k; i++) if(i < v - vd && k - i < vu - v) // r
        addt(ans2, 1ll * val1[i] * C[vu - v - 1][k - i] % mod);
    }
    else if(sufok) {
      for(int v2 = v + 1; v2 <= m; v2++) if(chk(r + 1, v2)) {
        suf = csuf(r + 2, v, v2), tot = 0;
        addt(ans1, 1ll * (pre = (f[r - 1][v - 1][v + 1] - f[r - 1][v - 1][v2 + 1]).f) * suf % mod);
        addt(tot, (f[r - 1][v - 1][v + 1] - f[r - 1][v - 1][v2 + 1]).su); // [1, r)
        for(int i = 0; i <= k; i++) if(i < v - vd && k - i < vu - v) // r
          addt(tot, 1ll * val1[i] * sub(C[vu - v - 1][k - i], k - i < vu - v2 ? C[vu - v2 - 1][k - i] : 0) % mod);
        calc(v2), addt(ans2, 1ll * tot * suf % mod);
      }
      for(int v2 = 1; v2 < v; v2++) if(chk(r + 1, v2)) {
        suf = csuf(r + 2, v2, v), tot = 0;
        addt(ans1, 1ll * (pre = (f[r - 1][v - 1][v + 1] - f[r - 1][v2 - 1][v + 1]).f) * suf % mod);
        addt(tot, (f[r - 1][v - 1][v + 1] - f[r - 1][v2 - 1][v + 1]).su); // [1, r)
        for(int i = 0; i <= k; i++) if(i < v - vd && k - i < vu - v) // r
          addt(tot, 1ll * val2[i] * sub(C[v - vd - 1][i], i < v2 - vd ? C[v2 - vd - 1][i] : 0) % mod);
        calc(v2), addt(ans2, 1ll * tot * suf % mod);
      }
    }
  }
  cout << ans1 << " " << ans2 << "\n";
}

bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("color.in", "r", stdin);
    FILE* OUT = freopen("color.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  inv[1] = 1; for(int i = 2; i < M; i++) inv[i] = mod - 1ll * mod / i * inv[mod % i] % mod;
  for(int i = 0; i < M; i++) for(int j = 0; j <= i; j++) C[i][j] = j ? add(C[i - 1][j - 1], C[i - 1][j]) : 1;
  for(int k = 0; k < N; k++) for(int x = 0; x < M; x++)
    for(int y = x; y + x < M; y++) for(int i = max(0, k - y), val; i <= min(x, k); i++)
      addt(g[k][x][y], val = 1ll * C[k][i] * C[x][i] % mod * C[y][k - i] % mod), addt(gi[k][x][y], 1ll * i * val % mod);
  int T; cin >> T; while(T--) solve();
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
/*
g++ color.cpp -o color -std=c++14 -O2 -DALEX_WEI
v = v2 的 k -> k - 1.
加入判断 equal = 1 && a[r - 1] != v.
将 S(I.l - J.l, I.r - J.l) * m 改成 S(I.l - J.l, I.r - J.l) * (m + 1).
*/
```

---

## 作者：YeahPotato (赞：16)

&emsp;&emsp;提供一个 $\mathrm{O}(Tn^3m)$ 的做法，目前在各 oj 上是 rank 1，运行时间为第二名的 $\frac{1}{6}$ 以内。

&emsp;&emsp;类似于本题解的方法不建议在考试中使用，非常耗时间。~~并且公式很丑。~~

**&emsp;&emsp;坐稳了！！**

## Step 1

&emsp;&emsp;@Alex_Wei 已经把严谨的结构刻画讲清楚了，这里再写一下自己的理解（本质上是等价的），看起来不大优美，但比较直观。

&emsp;&emsp;对于一个完整的序列 $a_{1\cdots n}$，找出其最长的前缀 $a_{1\cdots r}$，满足：前缀中 $\le a_r$ 的数严格递增，$\ge a_r$ 的数严格递减，类似于形成一个尖角。接下来暂时默认 $r<n$。

&emsp;&emsp;如果 $a_{r+1}=a_r$，那么要求 $a_{r+1\cdots n}$ 中，$\le a_r$ 的数严格递减，$\ge a_r$ 的数严格递增。这种情况恰好有 $2$ 种染色方案且得分相同。

&emsp;&emsp;否则，记 $a_{1\cdots r}$ 中最大的 $<a_r$ 的数为 $D$（不存在则为 $0$），最小的 $>a_r$ 的数为 $U$（不存在则为 $m+1$），**不妨设** $a_{r+1}\le D$（与之对称的一种情况是 $\ge U$）。现在找到以 $a_{r+1}$ 开头的最长严格递减**子段**，如果子段末尾还有下一项，则记为 $a_s$，否则肯定是完美的。

&emsp;&emsp;**结论**：此时完美数组的充要条件是，在 $a_{r+1\cdots n}$ 中，$\le a_{r+1}$ 的数严格递减，不存在 $(a_{r+1},a_r]$ 以内的数，且 $\ge a_s$ 的数严格递增。

&emsp;&emsp;如图，这是一个完美数组的例子（横坐标为下标，纵坐标为值）：

![](https://cdn.luogu.com.cn/upload/image_hosting/kn1ls8is.png)

&emsp;&emsp;它共有 $4$ 种染色方案，分别对应着下图中全不选/选一个黄色点染成绿色，其他黄色点染成红色：

![](https://cdn.luogu.com.cn/upload/image_hosting/whyomgtn.png)

&emsp;&emsp;如果 $a_s\in (D,a_r]$，那么只有 $1$ 种染色方案，以下是一例；如果 $a_s\in (a_{r+1},D]$ 则无染色方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/uww5i8ud.png)

&emsp;&emsp;同时，通过观察例子，可以发现多种染色方案一定是形如：一段前后缀颜色固定，中间剩下的区间，它有一个染色方案是全染红/绿，其余方案仅通过选其中某一个反转颜色得到。若 $a_{r+1}\le D$，则允许变颜色的点是以 $(a_U^{-1},U)$ 为左上角，$(r+1, a_{r+1})$ 为右下角的矩形**以内**的点。这部分实际上是递增的，且相对值域是连续的。$a_{r+1}\ge U$ 类似。

&emsp;&emsp;以上的证明都是容易的，需要一些分类讨论。

&emsp;&emsp;考虑哪种染色方案得分最大，容易发现最后一个可以变的点变色一定比其他点变色更优。因此最优染色一定是：$a_{1\cdots r-1}$ 中 $<a_r$ 的和 $a_{r+1\cdots n}$ 中 $>a_r$ 的染红色，$a_{1\cdots r-1}$ 中 $>a_r$ 的和 $a_{r+1\cdots n}$ 中 $<a_r$ 的染绿色，$a_r$ 两种均有可能。

## Step 2

&emsp;&emsp;**下文中 $r,U,D$ 的含义不变。称出现了满足 $a_{r+1}=a_r$ 或 $\le D$ 或 $\ge U$ 的情况为“交叉”，$a_r$ 为“交叉点”。称 $a_{1\cdots t}$ 为“前面”，$a_{t+1\cdots n}$ 为“后面”。组合数里只要有负数结果就是 $0$，除了 $\binom{-1}{-1}=1$。**

&emsp;&emsp;回到原问题。先来道开胃菜：前面已经交叉了。这时可以由 $a_{1\cdots t}$ 确定后面染绿部分必须要小于某个值 $L$，染红部分必须要大于某个值 $R$。

&emsp;&emsp;枚举后面有 $i$ 个染绿的。方案数为：
$$
\binom{L-1}{i}\binom{m-R}{n-t-i}\binom{n-t}{i}
$$
&emsp;&emsp;得分贡献为：
$$
\begin{aligned}&\left[\sum_{j<L}\sum_{k\le t}[a_k<j]j\right]\binom{L-2}{i-1}\binom{m-R}{n-t-i}\binom{n-t}{i}\\+&\left[\sum_{j>R}\sum_{k\le t}[a_k>j](m-j+1)\right]\binom{L-1}{i}\binom{m-R-1}{n-t-i-1}\binom{n-t}{i}\end{aligned}
$$
&emsp;&emsp;可以共 $\mathrm{O}(n+m)$ 计算。另外需要求前面的贡献，可以用树状数组。

## Step 3

&emsp;&emsp;前面尚未交叉时，为了简化起见，分 $a_r\;\fbox{</=/>}\;a_t$ 讨论。$a_r=a_t$ 也就是 $r=t$，这时暴力枚举 $a_{r+1}$ 后套用 Step 2 方法，时复只有两次方。

&emsp;&emsp;$a_r>a_t$ 与 $a_r<a_t$ 的算法完全相同。下记 $L$ 为前面最大的 $<a_t$ 的数（不存在则为 $0$），$R=a_r$，$X$ 为前面 $\le L$ 的数的个数，$Y=t-X$。

&emsp;&emsp;求方案数可以用 dp。交叉之前，想象“识别尖角”的过程，每次新加入的 $a$ 允许处于两个区间中：

![](https://cdn.luogu.com.cn/upload/image_hosting/yjke872q.png)

&emsp;&emsp;实际计数时，只需要钦定一个区间就行了，一般不会计重。于是 $f_{i,j,k}$ 表示，交叉之前，$a_i=j$，区间另一个端点为 $k$ 的方案数。一种转移是枚举 $a_{i+1}$，然后转移到 $f_{i,a,j/k}$。

&emsp;&emsp;$g_{i,j,k}$ 表示交叉之后，上一个染绿的为 $j$ ，上一个染红的为 $k$ 的方案数，转移略。$f$ 在 $i$ 作为 $r$ 时要转移给 $g$，为了避免信息不够无法转移以及计重的情况，$j>k$ 的 $f_{i,j,k}$ 只枚举 $a_{i+1}\le k$ 以及 $a_{i+1}=a_i$ 的情况进行贡献，$j<k$ 的只枚举 $a_{i+1}\ge k$ 的情况进行贡献。

&emsp;&emsp;以上 dp 均可以用前缀和优化做到 $\mathrm{O}(nm^2)$，但是这个 dp 无法类推求出得分和，我们放弃 dp，尝试直接推式子。**同样地，还是只考虑 $a_{r+1}\le D$、 $a_{r+1}=a_r$ 以及 $r=n$ 的情况**，$a_{r+1}\ge U$ 情况可以将 $a_i\mapsto m-a_i+1$ 后套用 $a_{r+1}\le D$ 的算法。

&emsp;&emsp;首先，后面的结构大致包含这些要素：交叉前 $<a_r$ 的数个数、交叉前 $>a_r$ 的数个数、$r$、$a_r$、$a_{r+1}$、交叉后 $<a_r$ 的数个数、交叉后 $>a_r$ 的数个数。考虑枚举其中一些。

&emsp;&emsp;对于 $a_{r+1}\le D$，枚举交叉前 $<a_r$ 的数个数 $i$，交叉前 $>a_r$ 的数个数 $j$，交叉后 $<a_r$ 的数个数 $k$，方案数为：
$$
\begin{aligned}
&\sum_{a_r}\sum_{D<a_r}\textcolor{red}{\binom{D-L-1}{i-1}\binom{m-a_r}{n-t-i-j-k-1}}\textcolor{green}{\binom{D}{k}\binom{R-a_r-1}{j}}\textcolor{blue}{\binom{i+j}{i}\binom{n-t-i-j-2}{k-1}}\\
=&\binom{i+j}{i}\binom{n-t-i-j-2}{k-1}\sum_{a_r}\left[\sum_{D<a_r}\binom{D-L-1}{i-1}\binom{D}{k}\right]\binom{R-a_r-1}{j}\binom{m-a_r}{n-t-i-j-k-1}\\
=&\binom{i+j}{i}\binom{n-t-i-j-2}{k-1}\sum_{a_r}C_D(i,k,a_r)\cdot C_U(j,n-t-i-j-k-1,a_r)
\end{aligned}
$$
&emsp;&emsp;红色表示染红部分的方案数，绿色表示染绿部分的方案数，蓝色表示“交织”的方案数。枚举 $D$ 会比枚举 $a_{r+1}$ 稍微方便一点。**$C_D$ 和 $C_U$ 主要是为了突出有关变量仅有三个（预处理即可）。**

&emsp;&emsp;对于 $a_{r+1}=a_r$，枚举 $l=r-t-1$ 以及 $a_r$，方案数为：
$$
\begin{aligned}
&\sum_i\sum_k\textcolor{red}{\binom{a_r-L-1}{i}\binom{m-a_r}{n-t-l-k-2}}\textcolor{green}{\binom{R-a_r-1}{l-i}\binom{a_r-1}{k}}\textcolor{blue}{\binom{l}{i}\binom{n-t-l-2}{k}}\\
=&\left[\sum_i\binom{a_r-L-1}{i}\binom{R-a_r-1}{l-i}\binom{l}{i}\right]\left[\sum_k\binom{a_r-1}{k}\binom{m-a_r}{n-t-l-k-2}\binom{n-t-l-2}{k}\right]\\
=&\,C_L(l,a_r)\cdot C_R(n-t-l-2,a_r)
\end{aligned}
$$
&emsp;&emsp;这里明确一下组合意义：

* $C_D(i,j,a)$ 表示 $a_r=a$，要安排 $<a_r$ 的数，交叉前个数为 $i$，交叉后个数为 $j$ 的方案数。
* $C_U(i,j,a)$ 表示 $a_r=a$，要安排 $>a_r$ 的数，交叉前个数为 $i$，交叉后个数为 $j$ 的方案数。
* $C_L(i,a)$ 表示 $a_r=a$，要安排 $r$ 之前的数共 $i$ 个的方案数（不考虑交叉条件）。
* $C_R(i,a)$ 表示 $a_r=a$，要安排 $r$ 之后的数共 $i$ 个的方案数（不考虑交叉条件）。

&emsp;&emsp;$r=n$ 的情况可以顺便计入。总体来说，计算方案数为 $\mathrm{O}(n^3m)$，实际表现比 dp 还快。下面是计算得分和，思路与求方案数类似。

## Step 4

&emsp;&emsp;以下 $a_r=a_{r+1}$ 情况部分时间复杂度都是 $\mathrm{O}(n^2m)$，一般情况部分则是 $\mathrm{O}(n^3m)$。代码中的顺序和分析的顺序是一样的。

### 交叉前下部

&emsp;&emsp;首先，不考虑交叉后部分与交叉前上部数值的安排，它们充其量就是外面乘一个系数。枚举交叉前 $<a_r$ 的数个数 $i$，交叉前 $>a_r$ 的数个数 $j$，以及 $D$，该部分得分为：
$$
\begin{aligned}
&\sum_{p=1}^i\left[\sum_{q=0}^j\binom{p-1+q}{p-1}\binom{i-p+j-q}{i-p}(q+Y)\right]\left[\sum_{a=L+1}^D\binom{a-L-1}{p-1}\binom{D-a-1}{i-p-1}(m-a+1)\right]\\
=&\sum_{p=1}^i\left[\binom{i+j}{i+1}p+\binom{i+j}{i}Y\right]\left[\binom{D-L-1}{i-1}(m-L+1)-\binom{D-L}{i}p\right]\\
=&\binom{i+j}{i}\binom{D-L-1}{i-1}\left[\frac{ij(m-L+1)}{2}-\frac{(2i+1)j(D-L)}{6}+iY(m-L+1)-\frac{(i+1)Y(D-L)}{2}\right]
\end{aligned}
$$
&emsp;&emsp;其中 $p$ 枚举交叉前下部的第几个数（称为“它”），$q$ 枚举有交叉前上部有几个数在它前面，$a$ 枚举它的值。第一个等号是利用 Vandermonde 恒等式，第二个等号就是正整数次方求和。记该式为 $(*)$。

&emsp;&emsp;接下来再把剩余未确定的部分确定，枚举交叉后 $<a_r$ 的数个数 $k$，最终得分为：
$$
\begin{aligned}
&\sum_{a_r>D}(*)\binom{R-a_r-1}{j}\binom{D}{k}\binom{m-a_r}{n-t-i-j-k-1}\binom{n-t-i-j-2}{k-1}\\
=&(*)\binom{D}{k}\binom{n-t-i-j-2}{k-1}\sum_{a_r>D}C_U(j,n-t-i-j-k-1,a_r)\\
=&(*)\binom{D}{k}\binom{n-t-i-j-2}{k-1}C'_U(j,n-t-i-j-k-1,D)
\end{aligned}
$$
&emsp;&emsp;预处理 $C_U(i,j,*)$ 的后缀和就不用枚举 $a_r$ 了。

### 交叉前上部

&emsp;&emsp;思路是差不多的。先枚举交叉前 $<a_r$ 的数个数 $i$，交叉前 $>a_r$ 的数个数 $j$，以及 $a_r$，该部分得分为：
$$
\begin{aligned}
&\sum_{p=1}^j\left[\sum_{q=0}^i\binom{p-1+q}{p-1}\binom{j-p+i-q}{j-p}(q+X)\right]\left[\sum_{a=a_r+1}^{R-1}\binom{R-a-1}{p-1}\binom{a-a_r-1}{j-p}a\right]\\
=&\sum_{p=1}^j\left[\binom{i+j}{j+1}p+\binom{i+j}{j}X\right]\left[\binom{R-a_r-1}{j}R-\binom{R-a_r}{j+1}p\right]\\
=&\binom{i+j}{j}j\left[\binom{R-a_r-1}{j}\left(\frac{i}{2}+X\right)R-\binom{R-a}{j+1}\left(\frac{i(2j+1)}{6}+\frac{(j+1)X}{2}\right)\right]
\end{aligned}
$$
&emsp;&emsp;抱歉让强迫症难受了，没法化得对称，否则分母上就会有未知数，得乘逆元了 /lb。

&emsp;&emsp;剩余未确定的部分的方案数同理，枚举一下 $k$，就不写了，要乘 $C_D$ 等。

&emsp;&emsp;另外 $a_{r+1}=a_r$ 和 $r=n$ 的情况的交叉前也可以方便地在这里算掉（反正都枚举 $a_r$ 了）。交叉前下部里就不用算了，会在 $a_i\mapsto m-a_i+1$ 时当成上部算掉。

&emsp;&emsp;另一种思路是不推上部，直接推 $a_{r+1}>a_r$ 情况的下部，我没试过，应该也是可以的。

### 交叉点

&emsp;&emsp;枚举交叉前 $<a_r$ 的数个数 $i$，交叉前 $>a_r$ 的数个数 $j$，交叉后 $<a_r$ 的数个数 $k$，最终得分为：
$$
\sum_{a_r}C_D(i,k,a_r)\cdot C_U(j,n-t-i-j-k-1,a_r)\cdot\max((Y+j)(m-a_r+1),(X+i)a_r)
$$
&emsp;&emsp;$a_{r+1}=a_r$ 的部分可能要特殊考虑一下，代码里处理的思路是和交叉前放在一起算，直接乘 $C_R$，就不用枚举 $k$ 了。

### 交叉后下部

&emsp;&emsp;交叉后就无需考虑 $r=n$ 了。先不考虑上部与“交织”的安排。枚举交叉前 $<a_r$ 的数个数 $i$，交叉后 $<a_r$ 的数个数 $k$，以及 $D$，该部分得分为：
$$
\begin{aligned}
&\sum_{i\le t,a_i\le L}\sum_{p=a_i+1}^D\binom{D-L-1}{i-1}\binom{D-1}{k-1}p+\sum_{a=L+1}^D\sum_{p=a+1}^D\binom{D-L-2}{i-2}\binom{D-1}{k-1}p\\
=&\binom{D-1}{k-1}\left[\binom{D-L-1}{i-1}\underline{\sum_{i\le t,a_i\le L}\frac{(a_i+1+D)(D-a_i)}{2}}_{f_0(D)}+\binom{D-L-2}{i-2}\underline{\sum_{a=L+1}^D\frac{(a+1+D)(D-a)}{2}}_{f(D)}\right]
\end{aligned}
$$
&emsp;&emsp;其中 $p$ 枚举的是交叉后下部的某个数值。记该式为 $(*)$。划线部分可以预处理。

&emsp;&emsp;考虑剩余部分，枚举交叉前 $>a_r$ 的数个数 $j$，最终得分为：
$$
(*)\binom{i+j}{i}\binom{n-t-i-j-2}{k-1}C'_U(j,n-t-i-j-k-1,D)
$$

### 交叉后上部

&emsp;&emsp;先枚举交叉前 $>a_r$ 的数个数 $j$，交叉后 $>a_r$ 的数个数 $k$，以及 $a_r$，该部分得分为：
$$
\binom{m-a_r-1}{k-1}\underline{\left[\binom{R-a_r-1}{j}\sum_{i\le t,a_i\ge R}\frac{(2m-a_i-a_r+2)(a_i-a_r-1)}{2}+\binom{R-a_r-2}{j-1}\sum_{a=a_r+1}^{R-1}\frac{(2m-a-a_r+2)(a-a_r-1)}{2}\right]}_{F(j,a_r)}
$$
&emsp;&emsp;最终得分同理也是要乘 $C_D$ 等，略。

&emsp;&emsp;同样要处理一下 $a_{r+1}=a_r$，要做到三次方还得分离一下变量：
$$
\begin{aligned}
&\sum_{i,j,k,a_r}\binom{a_r-L-1}{i}\binom{m-a_r-1}{k-1}F(j,a_r)\binom{a_r-1}{n-t-i-j-k-2}\binom{i+j}{j}\binom{n-t-i-j-2}{k}\\
=&\sum_{a_r}\sum_l\left[\sum_i\binom{a_r-L-1}{i}F(l-i,a_r)\binom{l}{i}\right]\left[\sum_k\binom{a_r-1}{n-t-l-k-2}\binom{m-a_r-1}{k-1}\binom{n-t-l-2}{k}\right]
\end{aligned}
$$
&emsp;&emsp;$l$ 就是 $i+j$ 换元，跟 Step 3 里的 $l$ 是一样的。注意第二个中括号里的不是 $C_R$。

## Step 5

&emsp;&emsp;说一下优化：我们希望瓶颈部分（四次方的最内层循环）运算次数尽量少，所以可以把只涉及到一部分变量的乘法先预处理掉，把能用分配律的乘法提到外层。

&emsp;&emsp;然后就是 $18$ 次一取模优化。

## Code

```cpp
#define ansc ans. first
#define anss ans. second
int calcP() {
	int res = 0; CL (tree);
	for (int i=1; i<=t; i++)
		update(A[i]), res += c[i] ? getsum(A[i] - 1) * A[i] : (i - getsum(A[i])) * (m - A[i] + 1);
	return res;
}
pii calcX(int L, int R) {
	pii ans (0, 0); CL (cnt);
	int pre = calcP(), sumd = 0, sumu = 0;
	if (t == n) return {1, pre};
	for (int i=1; i<=t; i++) cnt[A[i]] ++;
	for (int i=1; i<L; i++) sumd += cnt[i-1] * i, cnt[i] += cnt[i-1];
	for (int i=m; i>R; i--) sumu += cnt[i+1] * (m - i + 1), cnt[i] += cnt[i+1];
	for (int i=max(0,n-t-m+R); i<=min(L-1,n-t); i++) {
		ansc = (ansc + 1ll * C[L-1][i] * C[m-R][n-t-i] % MOD * C[n-t][i]) % MOD;
		if (i) anss = (anss + 1ll * C[L-2][i-1] * C[m-R][n-t-i] % MOD * C[n-t][i] % MOD * sumd) % MOD;
		if (n - t - i) anss = (anss + 1ll * C[L-1][i] * C[m-R-1][n-t-i-1] % MOD * C[n-t][i] % MOD * sumu) % MOD;
	} anss = (anss + 1ll * ansc * pre) % MOD;
	return ans;
}
pii calcI(int L, int R, bool flag) {
	pii ans (0, 0); CL (CD), CL (CU), CL (CUS), CL (CR);
	for (int k=0; k<n-t; k++)
		for (int a=L+1; a<=m; a++)
			CD[0][k][a] = C[L][k];
	for (int i=1; i<n-t; i++)
		for (int k=0; k<n-t-i; k++)
			for (int a=L+i+1; a<=m; a++)
				CD[i][k][a] = (CD[i][k][a-1] + 1ll * C[a-L-2][i-1] * C[a-1][k]) % MOD;
	for (int j=0; j<n-t; j++)
		for (int k=0; k<n-t-j; k++)
			for (int a=R-j-1; a>0; a--)
				CU[j][k][a] = 1ll * C[R-a-1][j] * C[m-a][k] % MOD, 
				CUS[j][k][a] = P(CUS[j][k][a+1], CU[j][k][a+1]);
	for (int l=0; l<n-t; l++)
		for (int a=1; a<=m; a++)
			for (int k=0; k<=l; k++)
				CR[l][a] = (CR[l][a] + 1ll * C[a-1][k] * C[m-a][l-k] % MOD * C[l][k]) % MOD;
	for (int i=0; i<n-t-1; i++)
		for (int j=0; j<n-t-i-1; j++)
			for (int k=1; k<n-t-i-j; k++) {
				ull res = 0;
				for (int a=L+i+1, _=0; a<=R-j-1; a++) {
					ADD(1ll * CD[i][k][a] * CU[j][n-t-i-j-k-1][a]);
				} res %= MOD;
				ansc = (ansc + 1ll * C[i+j][i] * C[n-t-i-j-2][k-1] % MOD * res) % MOD;
			}
	if (flag) for (int l=0; l<n-t; l++)
		for (int a=L+1; a<=R-1; a++) {
			int CL = 0;
			for (int i=0; i<=l; i++)
				CL = (CL + 1ll * C[a-L-1][i] * C[R-a-1][l-i] % MOD * C[l][i]) % MOD;
			ansc = (ansc + 1ll * CL * (l < n - t - 1 ? CR[n-t-l-2][a] : 1)) % MOD;
		}
	for (int i=1; i<n-t-1; i++)
		for (int j=0; j<n-t-i-1; j++) {
			for (int a=L+i; a<=R-j-2; a++)
				F[a] = (i3 * j * (3 * i * (m - L + 1) - (2 * i + 1) * (a - L)) + Y * (2 * i * (m - L + 1) - (i + 1) * (a - L))) % MOD * i2 % MOD * C[i+j][i] % MOD * C[a-L-1][i-1] % MOD;
			for (int k=1; k<n-t-i-j; k++) {
				ull res = 0;
				for (int a=L+i, _=0; a<=R-j-2; a++) {
					ADD(1ll * C[a][k] * CUS[j][n-t-i-j-k-1][a] % MOD * F[a]);
				} res %= MOD;
				anss = (anss + 1ll * C[n-t-i-j-2][k-1] * res) % MOD;
			}
		}
	for (int i=0; i<n-t; i++)
		for (int j=0; j<n-t-i; j++) {
			for (int a=L+i+1; a<=R-j-1; a++)
				F[a] = (1ll * C[R-a-1][j] * R * (i + 2 * X) + i3 * (MOD - C[R-a][j+1]) % MOD * (i * (2 * j + 1) + 3 * (j + 1) * X)) * j % MOD * i2 % MOD * C[i+j][j] % MOD;
			if (j)
				if (i + j < n - t - 1) for (int k=0; k<n-t-i-j-1; k++) {
					ull res = 0;
					for (int a=L+i+1, _=0; a<=R-j-1; a++) {
						ADD(1ll * C[m-a][k] * CD[i][n-t-i-j-k-1][a] % MOD * F[a]);
					} res %= MOD;
					anss = (anss + 1ll * C[n-t-i-j-2][k] * res) % MOD;
				} else for (int a=L+i+1; a<=R-j-1; a++)
					anss = (anss + 1ll * CD[i][0][a] * F[a]) % MOD;
			if (i + j < n - t - 1) for (int a=L+i+1; a<=R-j-1; a++)
				anss = (anss + 1ll * (F[a] + 1ll * (X + i) * a * C[R-a-1][j] % MOD * C[i+j][i]) % MOD * C[a-L-1][i] % MOD * CR[n-t-i-j-2][a]) % MOD;
		}
	for (int i=0; i<n-t; i++)
		for (int j=0; j<n-t-i; j++)
			for (int k=0; k<n-t-i-j; k++) {
				ull res = 0;
				for (int a=L+i+1, wr=(Y+j)*(m-a+1), wg=(X+i)*a; a<=R-j-1; a++, wr-=Y+j, wg+=X+i) {
					res += 1ll * CD[i][k][a] * CU[j][n-t-i-j-k-1][a] % MOD * max(wr, wg);
				} res %= MOD;
				if (i + j == n - t - 1 && flag) anss = (anss + 1ll * C[i+j][i] * res) % MOD;
				else if (k) anss = (anss + 1ll * C[i+j][i] * C[n-t-i-j-2][k-1]  % MOD * res) % MOD;
			}
	CL (f0), CL (f);
	for (int a=L; a<=R-2; a++) {
		for (int i=1; i<=t; i++) if (A[i] <= L)
			f0[a] += (A[i] + 1 + a) * (a - A[i]) >> 1;
		for (int i=L+1; i<=a; i++)
			f[a] += (i + 1 + a) * (a - i) >> 1;
	}
	for (int i=0; i<n-t-1; i++)
		for (int k=1; k<n-t-i; k++) {
			if (! i) {
				F[L] = L ? 1ll * C[L-1][k-1] * f0[L] % MOD : 0;
				for (int a=L+1; a<=R-2; a++) F[a] = 0;
			} else for (int a=L+i; a<=R-2; a++)
				F[a] = (1ll * C[a-L-1][i-1] * f0[a] + (i > 1 ? 1ll * C[a-L-2][i-2] * f[a] : 0)) % MOD * C[a-1][k-1] % MOD;
			for (int j=0; j<n-t-i-k; j++) {
				ull res = 0;
				for (int a=L+i, _=0; a<=R-j-2; a++) {
					ADD(1ll * CUS[j][n-t-i-j-k-1][a] * F[a]);
				} res %= MOD;
				anss = (anss + 1ll * C[i+j][i] * C[n-t-i-j-2][k-1] % MOD * res) % MOD;
			}
		}
	CL (f0), CL (f), CL (_F);
	for (int a=L+1; a<=R-1; a++) {
		for (int i=1; i<=t; i++) if (A[i] >= R)
			f0[a] += (2 * (m + 1) - A[i] - a) * (A[i] - a - 1) >> 1;
		for (int i=a+1; i<=R-1; i++)
			f[a] += (2 * (m + 1) - i - a) * (i - a - 1) >> 1;
	}
	for (int j=0; j<n-t-1; j++) {
		for (int a=L+1; a<=R-j-1; a++)
			_F[a][j] = (1ll * C[R-a-1][j] * f0[a] + (j ? 1ll * C[R-a-2][j-1] * f[a] : 0)) % MOD;
		for (int k=1; k<n-t-j-1; k++) {
			for (int a=L+1; a<=R-j-1; a++)
				F[a] = a < m ? 1ll * C[m-a-1][k-1] * _F[a][j] % MOD : 0;
			for (int i=0; i<n-t-j-k-1; i++) {
				ull res = 0;
				for (int a=L+i+1, _=0; a<=R-j-1; a++) {
					ADD(1ll * CD[i][n-t-i-j-k-1][a] * F[a]);
				} res %= MOD;
				anss = (anss + 1ll * C[i+j][j] * C[n-t-i-j-2][k] % MOD * res) % MOD;
			}
		}
	}
	for (int l=0; l<n-t-1; l++)
		for (int a=L+1; a<=min(R-1,m-1); a++) {
			int res1 = 0, res2 = 0;
			for (int i=max(0,a-R+l+1); i<=min(l,a-L-1); i++)
				res1 = (res1 + 1ll * C[a-L-1][i] * C[l][i] % MOD * _F[a][l-i]) % MOD;
			for (int k=1; k<n-t-l-1; k++)
				res2 = (res2 + 1ll * C[n-t-l-2][k] * C[a-1][n-t-l-k-2] % MOD * C[m-a-1][k-1]) % MOD;
			anss = (anss + 1ll * res1 * res2) % MOD;
		}
	return ans;
}
pii calcF(int L, int R) {
	pii ans (0, 0);
	ans += calcI(L, R, 1);
	for (int i=1; i<=t; i++) A[i] = m - A[i] + 1; swap(X, Y);
	ans += calcI(m - R + 1, m - L + 1, 0);
	for (int i=1; i<=t; i++) A[i] = m - A[i] + 1; swap(X, Y);
	anss = (anss + 1ll * ansc * calcP()) % MOD;
	return ans;
}
pii calcN() {
	pii ans (0, 0);
	c[t] = 1, Y ++, ans += calcF(L, A[t]), Y --;
	c[t] = A[t] * X > (m - A[t] + 1) * Y, t ++;
	for (int i=1; i<=L; i++)
		A[t] = i, c[t] = 1, ans += calcX(i, A[t-1]);
	c[t] = c[t-1] ^ 1, ans += calcX(A[t-1], A[t] = A[t-1]);
	for (int i=R; i<=m; i++)
		A[t] = i, c[t] = 0, ans += calcX(A[t-1], i);
	t --;
	c[t] = 0, X ++, ans += calcF(A[t], R), X --;
	return ans;
}
int main() {
	for (int i=0; i<=200; i++) {
		C[i][0] = 1;
		for (int j=1; j<=min(i,50); j++)
			C[i][j] = P(C[i-1][j-1], C[i-1][j]);
	}
	cin >> T;
	while (T --) {
		cin >> n >> m >> t, L = X = Y = 0, R = m + 1;
		for (int i=1; i<=t; i++) scanf ("%d", &A[i]);
		for (int i=2; i<=t; i++)
			if (L < R)
				if (L < A[i] && A[i] < A[i-1])
					R = A[i-1], c[i-1] = 1, Y ++;
				else if (A[i-1] < A[i] && A[i] < R)
					L = A[i-1], c[i-1] = 0, X ++;
				else if (A[i] == A[i-1])
					L = R = A[i], c[i-1] = 0, c[i] = 1;
				else {
					c[i-1] = A[i-1] * X > (m - A[i-1] + 1) * Y;
					if (A[i] < A[i-1]) L = A[i-1], R = A[i], c[i] = 1;
					else L = A[i], R = A[i-1], c[i] = 0;
				}
			else if (A[i] > L) L = A[i], c[i] = 0;
			else if (A[i] < R) R = A[i], c[i] = 1;
			else { ans = {0, 0}; goto O; }
		if (L < R && t == n) c[n] = A[n] * X > (m - A[n] + 1) * Y, L = R = 0;
		ans = L >= R ? calcX(R, L) : calcN();
		O : printf ("%d %d\n", ansc, anss);
	}
}
```



---

## 作者：Larunatrecy (赞：5)

开始做一些没有意义的事情。

性质一：

> 存在优秀染色的数组中每种 $A_i$ 最多出现两次 

证明：如果出现三次及以上，必定不可能划分到两个单调序列里



对于一个完美数组，因为其有至少两种不同染色方案，所以必定存在至少一个位置既可染成绿色也可染成红色。

> 性质二：
>
>  $A_i$ 既可以被染成红色又可以被染成绿色当且仅当满足如下条件
>
> - $[1,i)$ 中 $\leq A_i$ 的数（记为 $Lred_i$）和 $(i,n]$ 中 $\geq A_i$ 的数（记为 $Rred_i$）构成递增子序列
> - $[1,i)$ 中 $\geq A_i$ 的数（记为 $Lgreen_i$）和 $(i,n]$ 中 $\leq A_i$ 的数（记为 $Rgreen_i$ ）构成递减子序列

证明：

- 充分性：我们可以简单构造出 $A_i$ 是绿色和红色的两种方案。
  - 把 $[1,i)$ 中 $<A_i$ 的数、$A_i$、$(i,n]$ 中 $>A_i$ 的数染成红色，剩下的数染成绿色。
  - 把 $[1,i)$ 中 $>A_i$ 的数、$A_i$、$(i,n]$ 中 $<A_i$ 的数染成绿色，剩下的数染成红色。
- 必要性：考虑反证法，因为都是对称的，我们不妨只考虑第一条的前半种即 $Lred_i$ 中存在相邻的非递增数对 $(A_x,A_y)$。此时若 $A_i$ 要染成绿色，则 $A_x,A_y$ 都只能染成红色（否则绿色不递减)，但此时红色也不递增，所以矛盾，不成立。



称满足上述条件的位置为关键位置，关键位置构成的集合为 $S$。

> 性质三：
>
> 对于完美数组，其 $S$ 构成一段序列上的区间。

证明：

- $|S|=1$ 时成立
- 若 $|S|>1$，任取 $x,y\in S(x<y)$ 
  - $A_x=A_y$，此时对于 $i\in(x,y)$，发现不论 $A_i$ 取值如何，$x,y$ 不可能同时是关键位置，故 $i$ 不存在，即 $y=x+1$。
  - $A_x<A_y$ ，此时对于 $i\in (x,y)$，必有 $A_i\in (A_x,A_y)$ 且 $A_i$ 递增，否则也很容易导出矛盾。我们看看还有什么性质。
    - 随着 $i$ 的增加，$Lgreen_i$ 不断倒着删元素，$Rred_i$ 不断正着删元素。
    - 因为 $Lred_x$ 递增，$Lred_y$ 递增，且 $A_i$ 递增，所以容易得出 $Lred_i$ 递增，同理 $Rgreen_i$ 递减。
    - 综上，对于任意的 $i\in (x,y)$，$i$ 都是关键位置。
  - $A_x>A_y$，同上可证 $[x,y]$ 内的位置都是关键位置。

故 $S$ 一定构成一段区间。



> 性质四：
>
> 记某完美数组的关键区间是 $[l,r]$ ，$L=\min (A_l,A_r)，R=\max(A_l,A_r)$，那么：
>
> 对于 $i\in [1,l)$ ， $A_i<L$ 的 $A_i$ 递增，$A_i>R$ 的 $A_i$ 递减，且不存在 $[L,R]$ 之间的数。
>
> 对于 $i\in (r,n]$，$A_i<L$ 的 $A_i$ 递减，$A_i>R$ 的 $A_i$ 递增，且不存在 $[L,R]$ 之间的数。

不难由关键区间的定义得出。



那么我们就可以来解决第一问了。

#### 第一问

我们考虑在 $r$ 处计算答案。

注意到我们只需要保证 $r$ 是关键位置，且 $r+1$ 不是关键位置即可，不需要知道 $l$ 以及 $A_l$ 是啥。

记 $f_{i,x,y}$ 表示前 $i$ 个位置填数，其中 $\leq x$ 的递增，$\geq y$ 的递减的方案数，$g_{i,x,y}$ 表示相应的后缀方案数。

我们枚举 $A_r=x$，然后分类一下：

- $A_{r-1}=A_r$，因为此时 $r+1$ 一定不是关键位置，那么方案数就是 $f_{r-2,x-1,x+1}g_{r+1,x-1,x+1}$
- 否则 $r+1$ 可能是关键位置，我们需要容斥掉，枚举 $A_{r+1}=y$
  - $x<y$，方案数 $(f_{r-1,x-1,x+1}-f_{r-1,x-1,y+1})g_{r+2,x-1,y+1}$
  - $x=y$，此时 $r+1$ 一定是关键位置，不合法。
  - $x>y$，方案数 $(f_{r-1,x-1,x+1}-f_{r-1,y-1,x+1})g_{r+2,y-1,x+1}$

复杂度 $O(nm^2)$ ，可以获得 $20pts$ 高分。

[20pts代码](https://uoj.ac/submission/673221)



#### 第二问

首先我们要搞清楚得分最大的染色方式是啥。



> 性质五
>
> 对于产生贡献的点对 $(i,j)$ ，若 $j$ 不是关键位置，则 $i$ 也不是关键位置

可以由贡献方式和性质四推出来。



性质五告诉我们，因为非关键位置的染色情况是固定的，所以我们需要考虑关键位置的贡献情况即可。

> 性质六
>
> 贡献最大的方案只需要考虑 $r$ 处的染色情况

证明：

还是分三类看一看：

-  $A_l=A_r$，此时 $A_l,A_r$ 一定异色，一共两种染色且贡献是一模一样的。

- $A_l<A_r$，此时 $[l,r]$ 中最多只有一个绿色，并且我们可以发现这些位置染成红色产生的贡献是一样的，因此考虑位置 $p$ 是绿色，它的贡献为：

  $$(\sum\limits_{i<l}[A_i<A_p]+(p-l))A_p$$

  随着 $p$ 的增大，$A_p$ 增大，贡献一定是增大，故 $p$ 一定是在 $r$ 处最优。当然，要把 $r$ 染成绿色和红色的两种贡献取个最大值才行。

- $A_l>A_r$ 与上一种类似，可以得出也是在 $r$ 处最优。



性质六看起来很舒服，因为我们正好也是枚举 $r$ 计算答案的。

贡献相对比较独立，我们拆成几部分：

-  $j\in [1,r)$ ，我们只需要在 $dp$ 计算 $f$ 的时候，而外记录当前权值和，绿色个数和，红色个数和即可，都是很容易维护的。

- $j=r$，我们当然可以用 $dp$ 计算贡献，但是为了后续处理我们还有一种更简单的方法，还是枚举 $A_r=x,A_{r+1}=y$：

  记 $[1,r]$ 中已经确定的部分中 $<x$ 的个数为 $Lc$，其中最大的是 $Lv$，相应的 $>x$ 的有 $Rc,Rv$ ，没有确定的位置个数为 $k$ ，那么填数的贡献就是就是：

  $$\sum\limits_{i=0}^k\binom{k}{i}\binom{x-1-Lv}{i}\binom{Rv-1-x}{k-i}\max((Rc+k-i)(m-x+1),(Lc+i)x)$$

  当然同样需要容斥掉 $r+1$ 是关键位置的情况，与之前类似就不多赘述了。

  需要注意一点是，这种方法需要保证已经确定部分是合法的才行。

- $j\in(r,n]$，此时对应的 $i\in [1,r)$。

  考虑求出 $p_i$ 表示 $[1,r)$ 内 $i$ 这个数的出现次数和，$q_j$ 表示 $(r,n]$ 内 $j$ 这个数的出现次数和。

  对于已经出现过的数字，其 $p$ 和 $q$ 加一即可，而对于没有出现过的数字，以 $p_i$ 为例 $(Lv<i<x)$ ，考虑相当于在 $(Lv,x)$ 的值域区间内选择一个有大小限制的子集，问包含 $i$ 的方案数。显然这个问题对于所有 $i$ 都等价，我们求出总方案数（也就是上面那个式子），然后求平均即可。$q_j$ 是同理的，只不过我们依然需要把 $p_i$ 减掉一部分来容斥。

  求出来之后，$O(m)$ 地枚举 $i$ ，另一边的 $j$ 是一个前缀和的事，总复杂度 $O(nm^3)$。
  
  考虑一下怎么优化。

  - 当 $r<t$ 时，使用上述做法，复杂度 $O(nm)$。
  - 当 $r\geq t$ 时，注意到因为 $p_i,q_j$ 对于 $i,j$ 等价，所以它们都可以表示成一段段值相同的区间，更具体的，$p_i$ 可以表示成 $(Lv,\min(x,y))$ 和 $(\max(x,y),Rv)$ 两个区间，$q_j$ 可以表示成 $[1,\min(x,y)),(y,y),(\max(x,y),m]$ 三个区间，而两个区间之间的贡献我们是可以 $O(1)$ 计算的，不过需要注意的是，$\leq t$ 的部分与 $q$ 之间的贡献我们还要花上 $O(n)$ 复杂度，所以总复杂度 $O(n^2m^2)$ 。

[100pts代码](https://uoj.ac/submission/673220)

---


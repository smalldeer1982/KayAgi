# [PA 2022] Mędrcy

## 题目描述

### 警告：滥用本题卡评测者将被封号。

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Mędrcy](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/med/)**

几个世纪以来，神奇的 Bitoland 一直是 $n$ 个贤者和 $m$ 条咒语的家园。根据古老的魔法法则，每条咒语恰好被 $n-2$ 个贤者知道。所有的贤者都知道每条咒语都被他们中的一些确定的人所知，但他们不知道到底有多少条咒语存在。每个贤者，对于他所知道的每一条咒语，都清楚地知道其他哪些贤者知道它。然而，贤者不知道存在多少他不知道的咒语。特别的，一个贤者可能不知道任何咒语——在这种情况下，他不知道是否存在咒语（但他仍然知道，如果存在咒语，则正好有 $n-2$ 个贤者会知道它们）。

贤者每天中午都会在 Stumegabyte 森林里聚会，但他们在那里不会互相交流，他们只是各自问候对方并进行冥想，晚上他们都回到自己的小屋。贤者除了在见面时看到对方之外，并没有其他任何方式的交流。他们这样做是因为他们害怕约束他们的古老传统，其中规定，如果一个贤者发现有他不知道的咒语，他必须在当天午夜神不知鬼不觉地离开这里，并且永远不能回到 Bitoland。

有一天，一个流浪者来到了 Bitoland。在观察了几天这些贤者之后，他决定去见他们，在那里他不明智地对所有贤者宣布：「我已经注意到，你们中至少有一个贤者知道至少一条咒语！」

流浪者将在 Bitoland 再停留 $k$ 天（最多一个月），每天观察聚会情况，但不会再多说什么。在这段时间里，会不会有一天，一些贤者不会在聚会上出现？

我们假设贤者的推断是完美的，也就是说，如果他们中的任何一个人能够从流浪者宣布的内容和他们所掌握的关于咒语的信息中推断出什么，那么现实情况一定是这样的，并且他们会这么做。

## 说明/提示

对于 $100\%$ 的数据，满足：

$3\le n,1\le m,1\le k\le 30, 1\le a_i<b_i\le n$,

一组数据中所有测试点的 $n$ 之和不超过 $10 ^ 3$，所有 $m$ 之和不超过 $3 \times 10 ^ 3$。

## 样例 #1

### 输入

```
4
3 2 7
1 2
2 3
3 3 7
1 2
2 3
1 3
5 3 1
1 5
2 4
1 5
5 2 2
2 4
1 5
```

### 输出

```
1 1
2
2 3
1 2 3
-1
2 4
1 2 4 5
```

# 题解

## 作者：rizynvu (赞：8)

[我的博客](https://www.cnblogs.com/rizynvu/p/18278784)。

2024.07.02：修改了 $T(k)$ 部分的错误。

考虑找一下走掉的条件:  
1. 若 $x$ 第 $1$ 天走掉，那么就说明 $x$ 没有知道任何咒语。  
2. 若 $x$ 第 $2$ 天走掉，那么就说明应该存在一个 $y$，按照 $x$ 已知的信息，$y$ 应该没有掌握咒语，但是 $y$ 第一天没走。  
3. 若 $x$ 第 $3$ 天走掉，那么就说明应该存在一个 $(y, z)$，按照 $x$ 已知的信息应当不存在。
4. 依次类推，若 $x$ 第 $c$ 天走掉，则说明存在 $(a_1, a_2,\cdots, a_{c - 1})$，按照 $x$ 已知的信息应当不存在这种共同存在的情况。

转化一下，用 $S_x$ 表示 $x$ 会的咒语的集合。  
1. 若第 $1$ 天走掉，那么说明 $S_x = \varnothing$。
2. 若第 $2$ 天走掉，那么说明存在 $y$ 使得 $S_x\cap S_y = \varnothing$，即不存在 $x, y$ 共存的咒语，$x$ 就认为 $y$，$x$ 就认为 $y$ 没有掌握咒语。
3. 若第 $c$ 天走掉，那么说明存在 $(a_1, a_2, \cdots, a_{c - 1})$，$S_x\cap S_{a_1}\cap S_{a_2}\cap \cdots \cap S_{a_{c - 1}} = \varnothing$。

进一步的，考虑转化为补集的形式，令 $T_x$ 表示 $x$ 不会的咒语的集合。  
那么第 $c$ 天就走掉，那么说明存在 $(a_1, a_2, \cdots, a_{c - 1})$，$T_x\cup T_{a_1}\cup T_{a_2}\cup \cdots \cap T_{a_{c - 1}} = \text{U}$（$\text{U}$ 指全集）。

然后因为又有每个咒语只有 $2$ 个贤者没有掌握，考虑把咒语当作边，贤者当作点。  
然后能发现要求的即是最小点覆盖和对应的方案。

这是经典 *NPC* 问题，但是能发现这里给了个特殊的 $k\le 30$。  
这启发去试着弄一些优一点的东西。

考虑朴素的求解，即是遍历到一个点，并去抉择是否将其加入点集，然后递归下去，分为两种：  
1. 在点集里。
2. 不在点集里，那么与其有连边的点都需要选。

考虑每次选剩余度数最大的点 $u$。  
- 若最大度数 $\le 2$，那么只有环和链，可以直接处理。  
  对于环，最小覆盖即为 $\lceil\frac{len}{2}\rceil$，每个点都有可能被选入。  
  对于链，分讨一下长度 $len$ 的奇偶：  
  1. 为偶，则最小覆盖为 $\frac{len}{2}$，每个点都有可能。
  2. 为奇，则最小覆盖为 $\lfloor\frac{len}{2}\rfloor$，只有选择按顺序的第 $2, 4, \cdots$ 的点是最优的。
- 若最大度数 $> 3$，那么就用上文提到的朴素递归。

考虑复杂度，令 $T(k)$ 为还能选 $k$ 个点的复杂度。  
其中第二种情况一种会选上 $1$ 个点，一种会选上 $\ge 3$ 个点（相邻的），所以有 $T(k) = T(k - 1) + T(k - 3)$，能得到 $T(30) = 58425$。

时间复杂度 $\mathcal{O}(T(k)(n + m))$。

注意判断重边，重边会使得度数实际上是假的。

```cpp
#include<bits/stdc++.h>
const int maxn = 1e3 + 10;
int n, ed;
std::vector<int> to[maxn], P[maxn];
int deg[maxn];
int vis[maxn], ch[maxn], ans[maxn], ud[maxn], mn, now;
void dfsl(int u, int fa, int id) {
   if (ud[u]++) return ;
   P[id].push_back(u);
   for (int v : to[u])
      if (! vis[v] && v != fa)
         dfsl(v, u, id);
}
inline void del(int u, int val) {
   for (int v : to[u])
      deg[v] -= val;
}
void dfs() {
   if (now > mn) return ;
   int u = 0;
   for (int i = 1; i <= n; i++)
      if (! vis[i] && deg[i] > deg[u])
         u = i;
   if (! u) {
      if (now < mn)
         mn = now, memset(ans, 0, sizeof(int) * (n + 1));
      for (int i = 1; i <= n; i++)
         ans[i] |= ch[i];
   } else if (deg[u] > 2) {
      vis[u] = 1, del(u, 1);
      ch[u] = 1, now++;
      dfs();
      ch[u] = 0, now--;
      std::vector<int> V;
      for (int v : to[u]) 
         ! vis[v] && (V.push_back(v), del(v, 1), vis[v] = ch[v] = 1, now++);
      dfs();
      for (int v : V)
         vis[v] = ch[v] = 0, del(v, -1), now--;
      vis[u] = 0, del(u, -1);
   } else {
      memset(ud, 0, sizeof(int) * (n + 1));
      std::vector<std::pair<int, int> > tp;
      for (int i = 1; i <= n; i++)
         if (! vis[i] && ! ud[i] && deg[i] <= 1)
            P[i].clear(), dfsl(i, 0, i), tp.emplace_back(P[i].size() & 1, i);
      for (int i = 1; i <= n ;i++)
         if (! vis[i] && ! ud[i])
            P[i].clear(), dfsl(i, 0, i), tp.emplace_back(2, i);
      for (auto [op, p] : tp)
         now += P[p].size() + (op == 2) >> 1;
      if (now < mn)
         mn = now, memset(ans, 0, sizeof(int) * (n + 1));
      if (now == mn) {
         for (int i = 1; i <= n; i++)
            ans[i] |= ch[i];
         for (auto [op, p] : tp)
            if (op == 0 || op == 2) {
               for (int v : P[p])
                  ans[v] = 1;
            } else {
               for (int i = 1; i < P[p].size(); i += 2)
                  ans[P[p][i]] = 1;
            }
      }
      for (auto [op, p] : tp)
         now -= P[p].size() + (op == 2) >> 1;
   }
}
inline void Main() {
   int m;
   scanf("%d%d%d", &n, &m, &ed);
   for (int i = 1; i <= n; i++) to[i].clear();
   std::unordered_map<int, int> s;
   for (int x, y; m--; ) {
      scanf("%d%d", &x, &y);
      if (x > y) std::swap(x, y);
      if (s[x * n + y]++) continue;
      to[x].push_back(y), to[y].push_back(x);
   }
   for (int i = 1; i <= n; i++) deg[i] = to[i].size();
   mn = ed + 1, dfs();
   if (mn > ed) return puts("-1"), void();
   std::vector<int> U;
   for (int i = 1; i <= n; i++)
      if (ans[i]) U.push_back(i);
   printf("%d %zu\n", mn, U.size());
   for (int x : U) printf("%d ", x);
   puts("");
}
int main() {
   int T;
   scanf("%d", &T);
   while (T--) Main();
   return 0;
}
```

---

## 作者：qiuzx (赞：7)

## 题意

有 $n$ 个人 $m$ 条咒语，每条咒语都有恰好两个人不知道。某一天一个人告诉他们至少存在一条咒语。此后每一天，若某个人能推断出有他不知道的咒语，那么他就会离开。求前 $k$ 天中第一次有人离开是哪一天，以及离开的人是谁。$n\le1000,m\le3000,k\le30$。

## 思路

先从简单情形入手，考虑什么情况下第一天会有人离开。显然，当一个人不知道任何一条咒语时，他必然在第一天离开，而这显然是一个充要条件。下面考虑第二天的情形。此时一个人的思考过程应当是：如果我知道所有的咒语，那么会不会有一个人在第一天离开？如果他发现会，但事实上没有人离开，那么他就会在第二天离开。注意由于我们只关心第一次有人离开的时刻，所以我们考虑每一天的时候都假定前面没有任何人离开。

这个思考的过程是很关键的， 因为在每一天所有人都会重复一遍这个思考过程。而他们在脑中解决的这个问题，其实就是原问题的一个子问题。如果我们将不知道每条咒语的两个人 $x,y$ 连一条无向边，那么一个人在解决的问题其实就是删去了这个人以及他所有出边后剩余图的问题。从而我们可以用形式化的语言描述这个问题。记 $G$ 为一张无向图，$f(G)$ 为 $G$ 对应的原问题的答案。那么对于一个点 $x$ 而言，若前 $f(G-\{x\})$ 天都没有人离开，那么在第 $f(G-\{x\})+1$ 天他会离开，且这是 $x$ 唯一可能离开的方式。那么 $\displaystyle f(G)=\min_x f(G-\{x\})+1$。

直接做复杂度是 $O(2^n)$，难以接受。而这个问题本质上是一个一般图最小点覆盖的问题，这是一个经典的 NPC 问题，但 $n,m$ 又很大，说明一定还有我们没有注意到的条件。此时可以发现 $k$ 很小，这启发我们进行一个类似搜索的过程，如果过程中搜出了 $>k$ 的答案，那么直接返回即可。一个朴素的搜索过程是随便拉一个点，枚举是否选择它，但这样最坏复杂度为 $O(2^kn)$，仍然无法通过。但注意到如果不选择一个点，那么就一定要选择它的所有邻居。所以我们优先选择度数最大的点，即可以大大降低复杂度。不过这样还是会被一个环或一条链卡成斐波那契数的复杂度，所以还需要进一步优化。如果最大度数为 $1$，那么一定是若干条不相连的边，直接计数即可。如果最大度数为 $2$，那么一定是若干个环/链，对每个连通块也是可以直接算出答案。所以我们只有在最大度数至少为 $3$ 的时候才会进入两个分支，因此这样做的复杂度 $T(k)=T(k-1)+T(k-3)+O(n)$，约为 $10^5n$，可以通过。

[代码](https://www.luogu.com.cn/paste/6ndyllsi)

---

## 作者：Silent_thinker (赞：7)

我的博客：https://www.cnblogs.com/flower-dream/p/17793941.html

题面：[[PA 2022] Mędrcy](https://www.luogu.com.cn/problem/P9257)
看到这道题没有题解， 所以过来水了一篇。

从题目上来看，这是一道经典的智力游戏问题，这类问题的核心其实就一点，为什么他会得到自己想要的信息。本题中想要知道的信息是是否存在自己不知道的咒语。假设有一个人小 A 知道所有的咒语，那么因为所有人都绝顶聪明，小 A 会知道每个人会在什么时候走掉。那反过来，如果小 A 发现了与自己所知道的信息不符的情况（本来不应该走掉的走掉了，本来该走掉的没走掉），那他就知道肯定有自己不知道的咒语，也就会在这一天的晚上走掉。

跟据刚才的分析，我们现在只需要知道什么情况下会产生冲突即可。如果一个人没有加入任何群，那么他会在第一天之前就走掉。如果两个人加入的群没有交集，那么他们会认为对方在第一天之前就该走掉，所以如果第二天见面了，他们会在当晚走掉。如果三个人，两两之间存在一个群，但没有一个同时包含三人的群，那么他们会认为剩下两个人应该是上一种情况，所以三人在第二天还能互相见到时，就会在当天晚上走掉。

以此类推，我们可以发现，如果存在 $a$ 个人，每 $a - 1$ 个人知道一个咒语，且不存在 $a$ 个人同时知道的咒语，那么我们的答案将小于等于 $a$，更确切地说，答案是所有满足条件的 $a$ 中最小的。由于上面的推理证明了此结论的必要性（如果存在这样的 $a$ 个人那么依照上面的方式逐层分析，可以得到这 $a$ 个人必定同时在第 $a$ 天的前一个晚上走掉），所以我们需要证明本结论的充分性，即没有比这样的 $a$ 更小的数成为答案。

证明：假设 $b$ 为答案，那么就有 $b$ 时间会产生第一个离开，所以 $b$ 时刻的离开是因为对于某个在 $b$ 天前一晚走的人来说在 $b - 1$ 天出现了本来该在前一天晚上走却留了下来的人。那么我们可以递归出一个子问题，即去除 $x$ 和所有不含 $x$ 的咒语之后，应该得到一个答案为 $b - 1$ 的问题。这样逐层递归（也可能不经过任何递归），必定会有一个时刻问题的答案为 $1$，此时有存在一个人没加入任何咒语，即答案满足上面给出的结论中的答案 $a$。我们考虑归纳，如果 $b - 1$ 层满足上面的结论，那么在 $b$ 层，我们需要加入一个不含 $x$ 的咒语使得答案为 $b$。如果这个咒语不包含所有 $b - 1$ 层判断应该走掉的点，那么根据上面答案的必要性（多余的咒语并不影响 $b - 1$ 答案的必要性，只会影响答案的充分性，因为我少考虑咒语一定只会使答案变大），$b$ 层的答案必定小于等于 $b - 1$，这与条件答案为 $b$ 不相符。故我们得到了像上面所说的情况，并且证明了情况的充分性。

那么，我们的问题就转化成了求最小的合法情况，但这明显是不好求的，我们需要再次转化。我们尝试减少限制，不要求每 $a - 1$ 个人知道一个咒语，因为这看上去并不是必须的，事实证明，去掉此限制后的最优解依然是答案。我们尝试对此进行证明：如果我们以新条件去获取答案， 设此时选出来的人员集合为 $S$，若本集合在原条件下不合法，则必定存在一个人 $x$，不存在不包含它而包含其它 $S$ 中的人的咒语，此时去掉 $x$ 符合新条件且是一个更优解。

当然经过优化后的算法还是太劣了，且没有用到每个咒语包含 $n - 2$ 人的限制，所以考虑将选中问题转化成不被选中问题。我们记 $C_i$ 为不包含第 $i$ 个人的魔咒集合，那么如果某个人员集合 $S$ 合法，当且仅当 $\cup_{i}C_i$ 为所有魔咒组成的集合，否则，不在集合里的魔咒会包含 $S$ 中的所有人，是 $S$ 集合不合法。

再次转化后，我们的问题变得看上去更加好求，但依旧没有用到 $n - 2$ 的人数限制。对于这种一个点对应两个量的问题，我们可以想到连接这两个量，建出图来。思考一下我们的转化，点表示人，边表示魔咒，再思考我们的需求，人数最小，魔咒全选，那么可以轻松地将问题转化成最小点覆盖问题。

转化成最小点覆盖问题以后，我们发现貌似进入了一个死胡同。因为最小点覆盖问题是一个经典的 NPC 问题，这使得问题看上去不太可做。由于原问题和最小点覆盖问题的转化完全等价，所以我们完全不能寻求转化上的突破，只能转而向另一个方向上寻求帮助，也就是答案的大小。很显然，这道题的作者也解决不了这一 NP 问题，所以他用了一个非常巧妙的办法，在答案上动手脚。注意到答案如果大于 $k$ 就直接输出 `-1` 即可，这就给了我们对于暴力算法剪枝的可能。

考虑我们要求出最小点覆盖和其所有方案的一个算法：寻找一个度数大于 $2$ 或者为 $0$ 的点，如果是度数为 $0$ 的点，直接删除再递归下去，否则，递归两种情况，选择自己和选择所有相邻点。我们对两种情况分别递归，选择自己就把自己和相邻点边删除，选择相邻点就把自己和相邻点以及这些点的相邻边删除。最后我们会省下一些环和链（注意，没有树和基环树），直接判断即可。这里有一个需要注意的点，就是我们并不会寻找到一个度数为 $1$ 的点后贪心地去选择它的临点，因为这样答案大小是对的，但方案却不对。

最后， 我们在答案天数走掉的人就是所有最小覆盖的方案数选择的点的并。

code:
https://www.luogu.com.cn/paste/wa5mgy7c

---

## 作者：Nygglatho (赞：6)

令 $S_i$ 表示 $i$ 知道咒语的集合。

考虑一个人 A 什么时候会离开。

- 如果 A 第一天离开了，说明 A 不知道任何咒语，可以推断出 $S_A=\varnothing$。
- 如果 A 第二天离开，说明 A 认为有一个人 B 不知道任何咒语（$S_A\cap S_B=\varnothing$），但是 B 第一天没有离开，那么 A 会推测出 B 有 A 不知道的咒语而离开。
- 如果 A 第三天离开，说明 A 认为有两个人 B 和 C 按照上述规则，第二天就应该离开（B 与 C 会的咒语的并集 A 根据自己信息推断为空，即 $S_A\cap S_B\cap S_C=\varnothing$）但是 B 和 C 第二天没有离开，那么 A 会推测出来 B 与 C 会的咒语的并集是自己不知道的而离开。

以此类推，一个人 A 第 $x$ 天离开的条件是存在 $x-1$ 个人 $B_i$，$\bigcap\limits_{i=1}^{x-1}S_{B_i}\cap S_A=\varnothing$。由于题目中需要找到第一次有人离开的时间，那么就是找到离开时间最短的人。

这似乎不是很好做，注意到「每条咒语恰好被 $n−2$ 个贤者知道」，那么考虑转化为补集的形式，令 $T_i$ 表示 $i$ 不知道咒语的集合，则 A 第 $x$ 天离开条件变为 $\bigcup\limits_{i=1}^{x-1}T_{B_i}\cup T_A$ 为全集。

现在由于每一条咒语恰好被 $2$ 个贤者**不知道**，考虑转化为图论问题。具体地，将贤者看作点，咒语看作边，这条边连接两个**不知道**的贤者，并建图。

注意到对于一个点 $u$，以其为端点的边都是其不知道的咒语，那么根据前面交集为全集的条件，原问题变为一个[最小点覆盖](https://oi-wiki.org/graph/concept/#%E7%82%B9%E8%A6%86%E7%9B%96)问题，需要求出最优解和所有最优方案的并集。

这是 NPC 问题，但是给出了一个 $k\le30$ 的信息。

考虑 dfs 时选择还未选择的点中度数最多的点，有两种方案：

- 选这个点。
- 不选这个点，那么由于需要覆盖以这个点为端点的边，这个点相邻的所有点都需要被覆盖。

选择之后相当于删去了这个点和以这个点为端点的边，并进行下一层 dfs。

那么这样子的最坏情况是 $1\leftrightarrow2\quad3\leftrightarrow4\cdots$，此时复杂度是 $O(2^k(n+m))$ 的，较难接受，考虑优化。

注意到如果取剩下的图是一条链或者环，那么可以直接计算。

- 如果是一条链，例如 $a_1\leftrightarrow a_2\leftrightarrow a_3\leftrightarrow a_4\cdots$，且链的长度 $len$ 为奇数，那么可以选择 $a_2,a_4,\cdots$ 以覆盖这一条链，需要的点数为 $\left\lfloor\dfrac{len}{2}\right\rfloor$ ，而选择的方案则为 $a_2,a_4,\cdots$。
- 如果是一条链，且链的长度 $len$ 为偶数，那么由于选择 $a_1,a_3,\cdots$ 和 $a_2,a_4,\cdots$ 需要点数量都是 $\dfrac{len}{2}$，因此方案取两者并集，即会选择这条链上所有点。
- 如果是环，同理需要点的数量为 $\left\lceil\dfrac{len}{2}\right\rceil$，方案为这个环上所有点。

注意到可能取完之后是不连通的多条链或者环，需要分别计算贡献。

否则和前面一样 dfs，这样每次度数最多的点度数 $\ge 3$，那么可以得出最坏情况 $T(k)=T(k-1)+T(k-3)$，分别是选这个点和选择相邻的所有点，现在复杂度大概是 $O(1.46^k(n+m))$，可以接受。

[LOJ Submission](https://loj.ac/s/2214582)

---

## 作者：orange_new (赞：4)

节选自：[图论做题记录（二）（2025.4.2）](https://www.luogu.com.cn/article/3i34hyad)

[安利一下我的博客](https://www.cnblogs.com/JPGOJCZX/p/18808197)

一道非常有意思的逻辑 + 图论题，~~写了我一天才写出来。~~

其实这道题目应该是《迷人的逻辑题》中“花心丈夫”这道题目的加强版，如果做了原题可能会好想一点。

我们先考虑一个贤者在什么情况下会离开。那一定是目前的情况无法用这个贤者已知的信息推出，那么一定是有这个贤者不知道的咒语，于是该贤者就会离开。

现在我们从小数据开始推：

- 第一天，什么咒语都不知道的贤者知道了居然有人知道咒语，自己真是太菜了，于是就退了。那么第一天的退出规则就是掌握的咒语为空集的人退出。

- 第二天，由于每个贤者都知道掌握了自己知道的咒语的其他贤者是谁，那么就会判断其他每个贤者是否会退出。当一个贤者 $a$ 掌握的咒语的其它掌握者都不包括贤者 $b$，那么 $a$ 就会认为 $b$ 会退出，如果 $b$ 没有退出，那么 $a$ 就知道 $b$ 还掌握了他不知道的咒语，于是 $a$ 就会退出。对于 $b$ 也是一样的，于是 $a$ 和 $b$ 都会退出。那么第二天的退出规则就是两个掌握咒语的交集为空的贤者会退出。

- 第三天，对于一个贤者 $a$，如果它掌握的咒语的其它掌握者中存在贤者 $b$ 和贤者 $c$ 掌握的咒语的交集为空，那么 $a$ 就会认为 $b$ 和 $c$ 会退出。如果 $b$ 和 $c$ 没有退出，那么 $a$ 就知道 $b$ 和 $c$ 还共同掌握了他不知道的咒语，于是 $a$ 就会退出。对于 $b$ 和 $c$ 也是一样，于是 $a, b, c$ 都会退出。那么第三天的退出规则就是三个掌握咒语的交集为空的贤者会退出。

- 推广到第 $n$ 天，对于一个贤者 $a$，如果它掌握的咒语的其它掌握者中存在贤者 $b_1, b_2, \dots, b_{n - 1}$ 掌握的咒语的交集为空，那么 $a$ 就会认为$b_1, b_2, \dots, b_{n - 1}$ 会退出。如果 $b_1, b_2, \dots, b_{n - 1}$ 没有退出，那么 $a$ 就知道 $b_1, b_2, \dots, b_{n - 1}$ 还共同掌握了他不知道的咒语，于是 $a$ 就会退出。对于 $b_1, b_2, \dots, b_{n - 1}$ 也是一样，于是 $a, b_1, b_2, \dots, b_{n - 1}$ 都会退出。那么第 $n$ 天的退出规则就是 $n$ 个掌握咒语的交集为空的贤者会退出。

由于题目要找到第一次有贤者退出的日期，那么我们就需要找到最小的 $n$ 使得存在 $n$ 个贤者，它们掌握的咒语的交集为空集。由于可能会存在**多组**这样的 $n$ 个贤者，我们需要求出它们的**并集**。

转化成数学语言，就是找到一组 $b_1, b_2, \dots, b_n$，$b_1 \cap b_2 \cap \dots \cap b_n = \emptyset$，对两边取反，根据德-摩根定律，可以得到 $c_1 \cup c_2 \cup \dots \cup c_n = U$（$c_i$ 为 $b_i$ 的补集），于是我们要找到 $n$ 个贤者，他们不知道的咒语的并集为全集。如果把贤者看成点，不掌握的咒语看成边，那么这道题就变成了一般图最小点覆盖，也就是图中每一条边，都**至少**有一个端点被选中。

这是一个典型的 NPC 问题，暴力的时间复杂度是 $O(n2^n)$ 但是我们依然可以降低复杂度。

首先，流浪者观察 $k$ 天就走了，于是大于 $k$ 的点覆盖都不行，于是复杂度先降低成 $O(n2^k)$。

考虑一个显然的贪心，如果一个点 $u$ 不选，那么与 $u$ 相连的所有边的另一个端点必须选，那么选 $u$ 一定不劣，于是我们按照度数从大到小选点，选了的点就删掉（不是真删，把 $u$ 连接了的点的度数减 $1$ 即可）。

但是这个做法会被一条链或一个环将常数卡成斐波那契数的复杂度，这是因为删了一个点后，总边数要么减少 $1$，要么减少 $2$，于是这种情况直接特判：

- 如果找到了一个长度为 $len$ 的环，那么就需要选中 $\left\lceil \displaystyle\frac{len}{2}\right\rceil$ 个点才能点覆盖。因为要取并集，因此每个点都可能被选；

- 如果找到了长度为 $len$ 的链，需要分以下情况讨论：

  - 长度为偶数，此时选链上从左往右第 $2, 4, \dots, \displaystyle\frac{len}{2}$ 的点即可覆盖整条链；
 
  - 长度为奇数，那么就需要选中 $\left\lfloor \displaystyle\frac{len}{2}\right\rfloor$ 个点才能点覆盖。因为要取并集，因此每个点都可能被选；
 
其他情况直接贪心做起，此时选一个点至少减少了 $3$ 条边，不选这个点减少了一个点，由于 $n$ 和 $m$ 是同阶的，于是常数就降低成了 $T(n) = T(n - 1) + T(n - 3), T(1) = 1$，此时 $T(30)$ 只有 $50000$ 多，足以通过此题。

完整代码：

```cpp
#include <bits/stdc++.h>
#define pii pair <int, int>
#define mk make_pair
using namespace std;
const int N = 1e3 + 9, M = 3e3 + 9, INF = 1e9 + 7;
struct Edge{
	int v, nex;
} e[M << 1];
int head[N], ecnt;
void addEdge(int u, int v){
	e[++ecnt] = Edge{v, head[u]};
	head[u] = ecnt;
}
int deg[N], T, n, m, k, ans;
bool vis[N], flag[N], flg[N], b[N], now[N];
map <pii, bool> mp;
void init(){
	memset(head, 0, sizeof(head));
	memset(deg, 0, sizeof(deg));
	memset(vis, 0, sizeof(vis));
	memset(flag, 0, sizeof(flag));
	memset(flg, 0, sizeof(flg));
	mp.clear();
	ecnt = 0;
	ans = 1e9 + 7;
}
vector <int> vec;
void dfs2(int u, int pre){
	b[u] = true;
	vec.push_back(u);
	for(int i = head[u]; i; i = e[i].nex){
		int v = e[i].v;
		if(vis[v] || v == pre)
			continue;
		if(!b[v])
			dfs2(v, u);
	}	
}
void del(int u, int x){
	for(int i = head[u]; i; i = e[i].nex){
		int v = e[i].v;
		deg[v] -= x;
	}	
}
void dfs(int cnt){
	if(cnt > ans || cnt > k)
		return;
	int maxn = 0;
	for(int i = 1; i <= n; i++)
		if(!vis[i] && deg[i] > deg[maxn])
			maxn = i;
	if(!maxn){
		if(cnt < ans){
			ans = cnt;
			memset(flg, 0, sizeof(flg));
		}
		for(int i = 1; i <= n; i++)
			flg[i] |= flag[i];
	} else if(deg[maxn] <= 2){
		memset(b, 0, sizeof(b));
		int tmp = 0;
		for(int i = 1; i <= n; i++)
			now[i] = flag[i];
		for(int i = 1; i <= n; i++){
			if(!vis[i] && !b[i] && deg[i] == 1){
				vec.clear();
				dfs2(i, 0);
				if(vec.size() % 2 == 1)
					for(int j = 1; j < (int)vec.size(); j += 2)
						flag[vec[j]] = 1;	
				else
					for(auto j : vec)
						flag[j] = 1;
				tmp += floor(1.0 * vec.size() / 2);	
			}
		}
		for(int i = 1; i <= n; i++)
			if(!vis[i] && !b[i] && deg[i] == 2){
				vec.clear();
				dfs2(i, 0);
				for(auto j : vec)
					flag[j] = 1;
				tmp += ceil(1.0 * vec.size() / 2);
			}
		if(cnt + tmp < ans){
			ans = cnt + tmp;
			memset(flg, 0, sizeof(flg));
		}
		if(cnt + tmp <= ans)
			for(int i = 1; i <= n; i++)
				flg[i] |= flag[i];
		for(int i = 1; i <= n; i++)
			flag[i] = now[i];
	} else {
		vis[maxn] = 1;
		del(maxn, 1);
		flag[maxn] = 1;
		dfs(cnt + 1);
		flag[maxn] = 0;
		vector <int> st;
		for(int i = head[maxn]; i; i = e[i].nex){
			int v = e[i].v;
			if(!vis[v]){
				st.push_back(v); 
				del(v, 1);
				flag[v] = 1;
				vis[v] = 1;
			}
		}
		dfs(cnt + st.size());
		for(auto v : st){
			vis[v] = 0;
			flag[v] = 0;
			del(v, -1);
		}
		del(maxn, -1);
		vis[maxn] = 0;
	}
}
int main(){
//	freopen("med1a.in", "r", stdin);
//	freopen("med1a.out", "w", stdout);
	scanf("%d", &T);
	while(T--){
		init();
		scanf("%d%d%d", &n, &m, &k);
		for(int i = 1; i <= m; i++){
			int u, v;
			scanf("%d%d", &u, &v);
			if(u > v)
				swap(u, v);
			if(mp[mk(u, v)])
				continue;
			mp[mk(u, v)] = true;
			addEdge(u, v);
			addEdge(v, u);
			deg[u]++;
			deg[v]++;
		}
		dfs(0);
		if(ans > k)
			printf("-1\n");
		else {
			int cnt = 0;
			printf("%d ", ans);
			for(int i = 1; i <= n; i++)
				if(flg[i])
					cnt++;
			printf("%d\n", cnt);
			bool space = false;
			for(int i = 1; i <= n; i++)
				if(flg[i] && space)
					printf(" %d", i);
				else if(flg[i]){
					printf("%d", i);
					space = true;
				}
			printf("\n");
		}	
	}
	return 0;
}
```

---

## 作者：_Cheems (赞：2)

对于此类“智力游戏”问题，一种思路是每个人先根据已知条件推理，假如事实结果与推理相矛盾，则条件不成立。此题正是如此，每个贤者假设自己会所有咒语并加以推理，看看是否会矛盾。

记 $S_i$ 为 $i$ 会的咒语集合，考虑一个人 $x$ 在第 $t$ 天离开的条件：

1. $t=1$：$S_x=\varnothing$。因为流浪者说至少有一条咒语，所以显然 $x$ 会推出矛盾。
2. $t>1$：每个人可以转换立场，站在别人的角度推理第 $t-1$ 天，但是 $x$ 会认为 $S_y=S_x\cap S_y$，因为他只能得知谁和他同时会一个咒语。所以条件就是存在一个 $y$，满足带入对于 $x$ 而言的 $S$ 并按照第 $t-1$ 天的条件判断，$y$ 应该离开，但他却没有离开，那么 $x$ 就会在第 $t$ 天离开。

发现不好刻画 $y$ 没有离开这一条件，但是本题只需求出第一次有人离开的时刻即可，所以不妨设第 $t$ 天前没有任何人离开，不影响正确性。那么归纳得第 $t$ 天有人离开的条件是：存在互不相同的 $a_1\dots a_t$，满足 $S_{a_1}\cap S_{a_2}\dots \cap S_{a_t}=\varnothing$。

又因为每条咒语恰有 $2$ 人不会，所以转化为补集 $T$ 的条件：$T_{a_1}\cup T_{a_2}\dots \cup T_{a_t}=A$。$A$ 为全集。

咒语为边、人为点，那么就是求最小点覆盖，离开者集合即为最小点覆盖的并。一般图上这是 NPC 问题，但是注意到 $k$ 很小，所以大力搜索即可。

需要剪枝：先考虑度数最大的点，若其度 $>2$ 暴力递归。否则所有点度数 $\le 2$ 则为若干链和环，可以直接处理。那么最坏情况下度数为 $3$，复杂度 $T_k=T_{k-1}+T_{k-3}+O(n)$，经计算可以通过。
#### 代码
比较恶心，但完全不卡常，平均 4ms 过。假如你遇到了 TLE 或 MLE，务必检查是否陷入死循环。
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 3e3 + 5;
int T, n, m, k, mi, u[N], v[N], q[N], qn, q2[N], qn2, du[N], col[N], e[N][N], stk[N];
bool vis[N], ans[N], vis2[N];
vector<int> to[N], buc;

inline void debug(){
	for(int i = 1; i <= n; ++i) cout << vis[i] << ' ';
	cout << endl;
	for(int i = 1; i <= n; ++i) cout << du[i] << ' ';
	cout << endl;
	cout << endl;
}
inline void init(){	
	scanf("%d%d%d", &n, &m, &k);
	for(int i = 1; i <= n; ++i){
		to[i].clear(), ans[i] = du[i] = 0; 
		for(int j = 1; j <= n; ++j) e[i][j] = false;
	}
	for(int i = 1; i <= m; ++i){
		scanf("%d%d", &u[i], &v[i]);
		if(!e[u[i]][v[i]]){
			to[u[i]].push_back(v[i]), to[v[i]].push_back(u[i]);
			++du[u[i]], ++du[v[i]];
			e[u[i]][v[i]] = e[v[i]][u[i]] = true;
		}
	}
}
inline void dfs2(int u, int from, bool &iscir){
	buc.push_back(u);
	for(auto v : to[u]){
		if(v == from || !du[v] || vis[v]) continue;
		if(!col[v]) col[v] = 3 - col[u], dfs2(v, u, iscir);		
		else iscir = true;
	}
}
inline void dfs(int cnt){
	if(cnt > mi) return ;
	
	int now = 0; 
	for(int i = 1; i <= n; ++i)	if(!vis[i]) now = (du[i] > du[now] ? i : now);
	
	if(!now){
		if(cnt < mi){
			for(int i = 1; i <= n; ++i) ans[i] = 0;
			mi = cnt;  
		}
		for(int i = 1; i <= n; ++i) ans[i] |= vis[i];
		return ;
	}	
	if(du[now] > 2){
		vis[now] = true;
		for(auto i : to[now]) if(!vis[i]) --du[i], --du[now]; 
		dfs(cnt + 1);
		vis[now] = false;
		for(auto i : to[now]) if(!vis[i]) ++du[i], ++du[now];
	
		vector<int> oth; 
		for(auto i : to[now]) 
			if(!vis[i]){
				oth.push_back(i), vis[i] = true;
				for(auto j : to[i]) if(!vis[j]) --du[i], --du[j];
			}
		dfs(cnt + oth.size());
		while(!oth.empty()){
			int u = oth.back(); oth.pop_back();
			vis[u] = false; 
			for(auto v : to[u]) if(!vis[v]) ++du[u], ++du[v];  
		}
	}
	else{
		for(int i = 1; i <= n; ++i) col[i] = 0, vis2[i] = vis[i];
		for(int i = 1; i <= n; ++i)
			if(!vis[i] && du[i] && !col[i]){
				bool iscir = false;
				col[i] = 1, dfs2(i, 0, iscir);
				
				if(iscir){
					cnt += (buc.size() + 1) / 2;
					while(!buc.empty())	vis[buc.back()] = true, buc.pop_back();
				}
				else{
					int c1 = 0, c2 = 0, pp;
					for(auto i : buc) c1 += col[i] == 1, c2 += col[i] == 2;
					cnt += min(c1, c2);
					while(!buc.empty()){
						pp = buc.back();
						if(c1 == c2) vis[pp] = true;
						if(c1 < c2 && col[pp] == 1) vis[pp] = true;
						if(c1 > c2 && col[pp] == 2) vis[pp] = true; 
						buc.pop_back();
					}
				}
			}
		 
		if(cnt < mi){
			for(int i = 1; i <= n; ++i) ans[i] = false;
			mi = cnt;
		}
		if(cnt == mi) for(int i = 1; i <= n; ++i) ans[i] |= vis[i];
		for(int i = 1; i <= n; ++i) vis[i] = vis2[i];

		return ;
	}

}
inline void solve(){
	mi = k + 1;
	dfs(0);
	if(mi > k) puts("-1");
	else{
		vector<int> Ans; 
		for(int i = 1; i <= n; ++i) if(ans[i]) Ans.push_back(i);
		printf("%d %d\n", mi, Ans.size());
		for(auto i : Ans) printf("%d ", i);
		putchar('\n');
	}
}
signed main(){
	cin >> T;
	while(T--) init(), solve();
	return 0;
}
```

---


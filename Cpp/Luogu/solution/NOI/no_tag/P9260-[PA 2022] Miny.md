# [PA 2022] Miny

## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Miny](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/min/)**

给定一棵树（无向无环图），树上每条边有一个确定的长度。每个点上都有一颗地雷，每个地雷有一个确定的爆炸半径。如果一个地雷爆炸了，所有距离这颗地雷不超过其爆炸半径的地雷都会爆炸。我们定义两个点之间的距离是这两个点之间简单路径上边的长度和。对于每颗地雷，如果手动引爆它，确定有多少地雷会爆炸。注意对于每颗地雷，我们认为手动引爆它与手动引爆其他地雷互相独立。

## 说明/提示

$1\le n\le 10 ^ 5, 0\le r_i\le 10^{18}, 1\le a_i,b_i\le n,1\le c_i\le 10^{12}$

## 样例 #1

### 输入

```
5
8 1 0 4 6
2 4 2
3 1 9
2 5 5
2 1 2
```

### 输出

```
4 1 1 4 2
```

# 题解

## 作者：ZhongYuLin (赞：4)

~~为什么可持久化线段树合并能过啊。~~

树上邻域问题，考虑点分治。建出点分树，然后对于每个点提出子树内的所有点，前缀优化建边后双指针扫一轮（笔者的代码使用了暴力跳父亲加二分），可以 $O(n\log n)$ 建出转移图，然后做图上可达点统计即可，位运算优化转移可以做到 $O(\dfrac{n^2\log n}{w})$，其中 $w=64$。也就是每次取出 $64$ 个点进行状压，再拓扑排序。

听起来很简单？那你的代码能通过官方的完整数据吗？虽然纸面运算次数只有 $3\times10^9$，但是前缀优化建边自带 $2$ 倍常数，这就导致某个地方稍微常数大一点就过不了。包括但不限于：

1. 点分治写挂了，变成了大常数 $\log n$。

2. 内存访问不连续，这在暴力题中是致命的。

3. 前缀优化建图时建出了所有的虚点，而不是只建出需要的点。这会导致缩点后形成的分量过多，约为 $2$ 倍。

4. 图上转移时没有应用分量标号是逆拓扑序的性质，每次重新进行拓扑排序。

看起来只有内存访问不连续不好解决，因为其余的问题都指出了解决办法。经典的办法是进行边基排，优化十分显著。但此时笔者的代码最慢点要 $10$ 秒，仍然无法通过。问题出在哪里呢？

我们为什么只取 $64$ 个点啊，我缺这点空间？我取 $1024$ 个点状压，于是访问就比较连续了。

参考实现（并没有因为卡常而面目全非）：


```cpp
#include<bits/stdc++.h>
#define se second
#define fi first
using namespace std;
using ll=long long;
using ull=unsigned long long;
using pli=pair<ll,int>;
using pii=pair<int,int>;
const int INF=0x3f3f3f3f;
const int N=1e5+3;
void ckmn(int &x,int y){if(y<x)x=y;}
struct Edge{int nxt,to;ll w;}e[N*100];
int head[N*35],dfn[N*35],dep[N],f[20][N],fa[N],sz[N],mx[N];
ll dis[N],R[N];
bitset<N*35>vis;
int tot,n,cnt,rt,sum;
void add(int u,int v,ll w=0){
	e[++tot]={head[u],v,w};
	head[u]=tot;
}
void dfs1(int x,int fa){
	f[0][++cnt]=fa;dep[x]=dep[fa]+1;
	dfn[x]=cnt;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(y==fa)continue;
		dis[y]=dis[x]+e[i].w;
		dfs1(y,x);
	}
}
int ckmx(int x,int y){return dep[x]<dep[y]?x:y;}
int lca(int x,int y){
	if(x==y)return x;
	if((x=dfn[x])>(y=dfn[y]))swap(x,y);
	int k=__lg(y-x);
	return ckmx(f[k][x+1],f[k][y-(1<<k)+1]);
}
ll calc(int x,int y){return dis[x]+dis[y]-2*dis[lca(x,y)];}
void getSz(int x,int f){
	sz[x]=1;mx[x]=0;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(y==f||vis[y])continue;
		mx[x]=max(sz[y],mx[x]);
		getSz(y,x);sz[x]+=sz[y];
	}
}
void getRt(int x,int f){
	mx[x]=max(mx[x],sum-sz[x]);
	if(mx[x]<mx[rt])rt=x;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(y==f||vis[y])continue;
		getRt(y,x);
	}
}
void solve(int x){
	vis[x]=1;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(vis[y])continue;
		getSz(y,x);rt=0;sum=sz[y];
		getRt(y,x);fa[rt]=x;
		solve(rt);
	}
}
vector<pli>tmp[N];
vector<int>id[N];
void build(int x,int s){
	tmp[s].push_back({calc(x,s),x});
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		build(y,s);
	}
}
int st[N*35],bl[N*35],low[N*35];
int top,scc;
void tarjan(int x){
	st[++top]=x;vis[x]=1;
	dfn[x]=low[x]=++cnt;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(!dfn[y])tarjan(y),ckmn(low[x],low[y]);
		else if(vis[y])ckmn(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]&&++scc)
		while(1){
			int y=st[top--];
			bl[y]=scc;vis[y]=0;
			if(x==y)break;
		}
}
const int B=1<<10;
int ans[N],MX[N],LD[N*35],RD[N*35],to[N*100],bk[N*100];
vector<int>E[N*35];
bitset<B>g[N*35];
int main(){
	int u,v,x,y,z;ll w;
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)cin>>R[i];
	for(int i=1;i<n;++i)cin>>u>>v>>w,add(u,v,w),add(v,u,w);
	dfs1(1,0);
	for(int j=1;1<<j<=n;++j)
		for(int i=1;i+(1<<j)-1<=n;++i)
			f[j][i]=ckmx(f[j-1][i],f[j-1][i+(1<<j-1)]);
	mx[0]=INF;getSz(1,0);sum=sz[1];getRt(1,0);solve(rt);
	fill_n(head+1,n,0);tot=0;
	int p=0;
	for(int i=1;i<=n;++i)
		if(fa[i])add(fa[i],i);
		else p=i;
	for(int i=1;i<=n;++i)build(i,i),sort(tmp[i].begin(),tmp[i].end());
	fill_n(head+1,n,0);tot=0;
	int now=n;fill_n(MX+1,n,-1);
	for(int i=1;i<=n;++i)
		for(int x=i;x;x=fa[x]){
			ll k=R[i]-calc(i,x);
			if(k<0)continue;
			int y=upper_bound(tmp[x].begin(),tmp[x].end(),make_pair(k,INF))-tmp[x].begin()-1;
			MX[x]=max(MX[x],y);
		}
	for(int x=1;x<=n;++x){
		if(tmp[x].empty()||MX[x]==-1)continue;
		int len=tmp[x].size();
		id[x].resize(MX[x]+1);
		add(id[x][0]=++now,x);
		for(int i=1;i<=MX[x];++i){
			add(id[x][i]=now+1,now);
			add(id[x][i]=++now,tmp[x][i].se);
		}
	}
	for(int i=1;i<=n;++i)
		for(int x=i;x;x=fa[x]){
			ll k=R[i]-calc(i,x);
			if(k<0)continue;
			int y=upper_bound(tmp[x].begin(),tmp[x].end(),make_pair(k,INF))-tmp[x].begin()-1;
			add(i,id[x][y]);
		}
	vis.reset();cnt=0;fill_n(dfn+1,n,0);
	for(int i=1;i<=now;++i)if(!dfn[i])tarjan(i);
	for(int x=1;x<=now;++x)
		for(int i=head[x];i;i=e[i].nxt)
			if((u=bl[x])!=(v=bl[e[i].to]))
				E[v].push_back(u);
	tot=0;
	for(int x=1;x<=scc;++x){
		sort(E[x].begin(),E[x].end());
		for(auto y:E[x])to[++tot]=y,bk[tot]=x;
	}
	for(int l=1,r;l<=n;l=r+1){
		r=min(l+B-1,n);memset(&g[1],0,128*scc);
		for(int i=l;i<=r;++i)g[bl[i]][i-l]=1;
		for(int i=1;i<=tot;++i)g[to[i]]|=g[bk[i]];
		for(int i=1;i<=n;++i)ans[i]+=g[bl[i]].count();
	}
	for(int i=1;i<=n;++i)printf("%d ",ans[i]);puts("");
	return 0;
}
```

---

## 作者：XZhuRen (赞：4)

奶题。

树上 [炸弹](https://www.luogu.com.cn/problem/P5025)，但是这题严格难于炸弹，炸弹的优美性质在这题全没了，所以不考虑炸弹的线性做法。

依然套路地考虑建图，一开始想的是树剖套线段树优化建图，但是略微观察就能发现影响范围并非为一条链，一个菊花图立刻升天。

考虑什么算法能快速计算树上两两距离，基本就是淀粉质（点分治）了。

所以对整颗树跑点分治。

在每一层我们就可以知道一个点相对于点分范围内节点跨过根的准确距离。

![2025-01-19 19-36-49屏幕截图.png](https://s2.loli.net/2025/01/19/jZVUAxPKimnE9rd.png)

转换为小学数学题就是 $dis(u,Root)+dis(v,Root)\le R_{u} \to dis(v,Root) \le R_{u}-dis(u,Root)$ 其中 $u,v$ 不在同一子树中，$Root$ 为分治重心，$dis(x,y)$ 为 树上 $x,y$ 两点间距离，$R$ 为爆炸半径。

由于不在同一子树的限制较弱可以忽略，直接对淀粉树每层的所有节点（包括根）拉出来排序然后对于每个点二分前缀和优化建图就行。

如果你没有做过前缀和优化建图：[例题](https://www.luogu.com.cn/problem/AT_abc232_g)。

然后就建好图了，跑 Tarjan 缩成 DAG。

为什么说炸弹的优美性质在本题上消失了呢？

因为本题会出现这种情况：

![2025-01-19 19-56-57.png](https://s2.loli.net/2025/01/19/sKV3AZoMU8zwRip.png)

而且树上可达区域编号不连续，不可以表示为区间求和。

所以并不能像炸弹那样求出每个点可达的左右端点后统计。

这个统计就是统计 DAG 上可达点数目的，所于要求使用 `bitset` 等求并集。

这里虽然可以 `bitset`，但使用可持久化线段树合并也可以，同时维护哈希减枝（实测双哈希或单哈希都能过），若合并的两点包括其子树完全相同则跳过。

跑得不算慢。

---

## 作者：Luciylove (赞：0)

# Preface

代码参考可以去 LOJ 上面找。

# Solution

考虑点分治优化建图，对于 $r_i - dis_i$ 和 $dis_i$ 排序，然后向所有的 $dis_j \leq r_i - dis_i$ ，可以使用双指针+前缀和优化建图解决。

求出强连通分量，注意到问题等价于可达性统计，然后就有很多乱搞做法了，本文作者建议使用线段树合并。

考虑对于每个强连通分量的标号进行异或哈希，然后直接在合并的时候判断是否一样进行剪枝。

注意线段树合并需要可持久化。

---

## 作者：xxxxxzy (赞：0)

来个首发题解。

这是一篇非正解题解。

题目大意：[P5025 [SNOI2017] 炸弹](https://www.luogu.com.cn/problem/P5025) 的树上版本。

之前在学校的 OJ 做到了一个题，跟这个差不多，但是求最少引爆几个地雷才能全部引爆。

先考虑暴力建图，两个点 $(u,v)$ 如果 $dis_{u,v} \le r_u$ 就把 $u$ 往 $v$ 连边。

用点分治优化建图，从当前的根 $x$ 出发，到本次分治内所有点的距离设为 $dis_y$。

那么，连边的条件就是 $dis_u+dis_v \le r_u$。

移项，得 $dis_v \le r_u-dis_u$。

那么，假设将 $i$ 按 $dis_i,r_i-dis_i$ 分别排序从小到大得到序列 $a,b$。

则如果 $a_x \le b_y$ 则从 $x$ 往 $y$ 连边。

发现如果 $(x,y)$ 成立，那么 $(i,y)_{1 \le i \le x}$ 一定成立。

所以直接前缀优化建图。

考虑建一排虚点，然后双指针连边就可以了，从当前 $x$ 连向最大满足的 $y$。

时间复杂度 $O(n \log^2 n)$。

建完图跑缩点建反边，然后得到一张 DAG。

题目即为在 DAG 上计算每个点可以到达点的权值之和。

法一：

这显然不好做，但是考虑跑不满，然后上了个线段树合并试试。

然后就过了。。。。。。

时间最大点 1.7s，空间最大点 570MB。

没有卡常，线段树合并没有建虚树压缩。

法二：

我们记包含 $1-n$ 的点的强连通分量为实点，否则为虚点。

那么我们把实点以及实点能到达的点都拿出来重新组成一张图。

然后在这个新图上，用 bitset 跑一遍。

空间显然会炸。

所以对于 $1-n$，每 $64$ 个数分开处理。

这样空间就是 $O(n \log n)$ 的。

这样就得到了一个时间 $O(n \log^2 n+\dfrac{n^2 \log n}{w})$，空间 $O(n \log n)$ 的做法。

可能我写太丑了吧，跑的还没第一种快。

对了，可以把 $1-n$ 中的最大拓扑序作为枚举上界，不然会 TLE。

严重怀疑是 $O(\dfrac{n^2 \log n}{w})$ 次 vecotr 的调用太慢了。

最大点 4.3s，最大空间 283MB。

![](https://cdn.luogu.com.cn/upload/image_hosting/21leo1u3.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/gcnbvx5z.png)

代码就不放了。

---


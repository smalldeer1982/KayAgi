# [JOIST 2023] JOI 国的节日 2 / Festivals in JOI Kingdom 2

## 题目描述

在 JOI 王国，每年都会举行一次全国性的节日。在节日期间，总共有 $N$ 个活动。每个活动的时间表已经固定。$N$ 个活动的时间表由长度为 $N$ 的序列 $a, b$ 描述，满足以下条件：

- 从 $1$ 到 $2N$ 之间的每个整数都出现在 $a$ 或 $b$ 中。
- $a_i < b_i \ (1 \le i \le N)$。
- $a_i < a_{i + 1} \ (1 \le i \le N - 1)$。

第 $i$ 个活动将在节日开始后的 $a_i$ 分钟开始，并在节日开始后的 $b_i$ 分钟结束。

节日的参与者可以选择参加任意活动。然而，不允许参加时间表重叠的两个活动。（注意，活动的开始时间和结束时间彼此不同。）

JOI-kun 想参加尽可能多的活动。直到去年，他通过计算机使用以下程序选择参加的活动：

> 对于 $i = 1, 2, \dots, N$，按以下顺序进行。
> > 如果第 $i$ 个活动的时间表与他已经选择参加的其他活动的时间表不重叠，他将参加第 $i$ 个活动。否则，他将不参加第 $i$ 个活动。

然而，在学习了计算机科学之后，JOI-kun 注意到上述算法并不一定能最大化他参加的活动数量。从今年开始，JOI-kun 将使用改进的算法。使用改进的算法，JOI-kun 将能够最大化他参加的活动数量。

JOI-kun 想知道使用改进算法时，产生更多活动数量的情况数。

编写一个程序，给定整数 $N$ 和一个大质数 $P$，计算出描述 $N$ 个活动时间表的序列 $a, b$ 的对数，其中改进的算法产生更多的活动数量。由于答案可能非常大，程序应输出答案除以 $P$ 的余数。

## 说明/提示

**【样例解释 #1】**

例如，考虑 $a = (1, 2, 4)$ 和 $b = (6, 3, 5)$ 的情况。如果 JOI-kun 使用去年使用的算法，他将只参加第一个活动。另一方面，如果他使用正确的算法来最大化活动数量，他将参加第二个和第三个活动。因此，他将参加两个活动。在这种情况下，改进的算法产生了更多的活动数量。

以下是改进的算法产生更多活动数量的序列对 $a, b$：

- $a = (1, 2, 4), b = (6, 3, 5)$
- $a = (1, 2, 4), b = (5, 3, 6)$

因此，输出 $2$，这是 $2$ 除以 $100000007$ 的余数。

该样例满足所有子任务的限制。

**【样例解释 #2】**

有 $28$ 对序列 $a, b$ 满足条件。因此，输出 $28$，这是 $28$ 除以 $100000007$ 的余数。

该样例满足所有子任务的限制。

**【样例解释 #3】**

有 $5295044602247148$ 对序列 $a, b$ 满足条件。因此，输出 $935834920$，这是 $5295044602247148$ 除以 $999999937$ 的余数。

该样例满足子任务 $3 \sim 6$ 的限制。

**【数据范围】**

对于所有测试数据，满足 $1 \le N \le 2 \times 10 ^ 4$，$10 ^ 8 < P < 10 ^ 9$，保证 $P$ 是质数，保证所有输入均为整数。

|子任务编号|分值|$N \le$|
|:-:|:-:|:-:|
|$1$|$5$|$5$|
|$2$|$5$|$8$|
|$3$|$27$|$30$|
|$4$|$14$|$300$|
|$5$|$36$|$3000$|
|$6$|$13$|$2 \times 10 ^ 4$|

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3 100000007
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 100000007
```

### 输出

```
28
```

## 样例 #3

### 输入

```
15 999999937
```

### 输出

```
935834920
```

# 题解

## 作者：Un1quAIoid (赞：7)

**传送门：** [P9330](https://www.luogu.com.cn/problem/P9330)

---------------------------

牛逼 dp。

**step1 $(n \le 8)$：**

首先真贪心是把区间按照右端点排序，然后从前到后能选就选。

我们考虑求答案的补，即计算假贪心能够求出正确答案的方案数，总方案数为 $1-2n$ 中所有奇数之积，所以当 $n \le 8$ 时直接 dfs 即可。

总方案数的证明考虑 $i$ 从 $1$ 至 $n$ 安排 $a_i,b_i$:

- 当安排 $a_i$ 时方案数为 $1$，只能安排最小的未被选过的数。
- 当安排 $b_i$ 时方案数为 $2n-2i+1$，可以安排任意一个未被选过的数。

**step2 $(n \le 300)$：**

将真贪心选中的区间称为**红**区间，假贪心选中的区间称为**蓝**区间，注意两种贪心可能选中同一个区间，不妨将这种区间称为**紫**区间，其它区间则为**黑**区间。

那么一组红区间应当满足的性质为：

- 相邻两个红区间无交。
- 两个相邻红区间的右端点之间不存在**其它完整区间**，特别的，第一个红区间的右端点之前不存在**其它完整区间**。

同时也容易证明当一组区间满足上述条件时，这组区间也一定是真贪心选出来的红区间。

同样可以得出蓝区间的性质：

- 相邻两个蓝区间无交。
- 前一个蓝区间的右端点和后一个蓝区间的左端点之间不存在**其它区间的左端点**，特别的，第一个蓝区间的左端点之前不存在**其他区间的左端点**。

和红区间一样，满足上述性质的一组区间也一定是假贪心选出的蓝区间。

我们再将红蓝区间放到一起观察，由于要求红蓝区间个数相等，所以我们**将第 $i$ 个红区间与第 $i$ 个蓝区间配对**，可以发现第 $i$ 个红区间的右端点一定大于第 $i-1$ 个蓝区间的右端点，小于等于第 $i$ 个蓝区间的右端点。

配合下图理解（截自[日文题解](https://qoj.ac/download.php?type=solution&id=6333)）：

![](https://pic.imgdb.cn/item/64a18b841ddac507cc6fa3fa.png)

dp 的最重要一步来了：考虑按顺序**每次插入一对红蓝区间**。

具体来说，在 dp 状态中记录当前已经插入的区间个数 $i$，转移就考虑每次插入“**一对新的红蓝区间**以及所有**右端点在当前最后一个红区间右端点和新插入的红区间右端点之间的黑区间**”，所以我们需要枚举新插入的黑区间个数 $j$；同时我们还需要为这些新插入的黑区间右端点分配左端点，而左端点还有关于蓝区间的限制（见上文），所以还需要在状态中记录之前能插入一个左端点的位置数 $k$；同时还要添一维 $0/1$ 表示当前这对红蓝区间是不是紫区间。

转移细节就不展开写了，不是重点。

于是我们就得到了状态 $O(n^2)$，转移 $O(n)$ 的 $O(n^3)$ dp。

**step3 $(n \le 3000)$：**

按照插入区间的思路，转移感觉上就是不可避免地需要枚举插入的黑区间个数，所以我们考虑优化状态数。

观察上述的 $O(n^2)$ 状态的 dp，注意到需要多出来一维 $k$ 是因为**左端点有较强的限制**，但是右端点的限制较弱，于是我们就可以考虑去**转换左右端点**。

具体来说，我们考虑**倒着插入**每一对红蓝区间，枚举新插入的黑区间数量 $j$，同时为新插入的黑区间左端点分配右端点，这时就会发现右端点是**可以插入到之前任意两个端点之间的**！

于是我们可以设计 dp：$f_{i,0/1}$ 表示当前已经插入了 $i$ 个区间，当前这对红蓝区间是(1)否(0)是紫区间，根据 $0/1$ 不同一共有 $4$ 种转移式，这里具体展开一下 $0 \rightarrow 0$ 的转移式：

$$
f_{i+j+2,0} \leftarrow f_{i+j+2,0} + f_{i,0} \cdot (j+2)(j+1) \cdot (2i-2+(j-1))^{\underline{j}}
$$

其中 $(2i-2+(j-1))^{\underline{j}}$ 为插入 $j$ 个黑区间右端点的方案数，$(j+2)(j+1)$ 为将共计 $j+3$ 个端点划分为 $3$ 段的方案数，配合下两图理解：

![](https://pic.imgdb.cn/item/64a194d31ddac507cc7fc49b.png)

![](https://pic.imgdb.cn/item/64a1950f1ddac507cc802274.png)

其它 $3$ 种转移大同小异，请自行画图理解。

于是我们得到了状态 $O(n)$，转移 $O(n)$ 的 $O(n^2)$ dp，同时也存在其它 $O(n^2)$ dp 方法，但大多由于为状态 $O(n^2)$，转移 $O(1)$ 而无法进一步优化。

$O(n^2)$ 核心代码：
```cpp
f[1][0] = f[2][1] = 1;
	for (int i = 1; i < n; i++)
		for (int p = 0; p < 2; p++) if (f[i][p])
			for (int j = 0; i + j + 1 <= n; j++)
				for (int q = 0; i + j + 1 + q <= n && q < 2; q++) {
					ll t = f[i][p];
					if (q) t = t * (j + 1 + p) % Mod;
					if (p) t = t * (j + 1) % Mod;
					Add(f[i + j + 1 + q][q], t * fac[2 * i - 3 + !p + j] % Mod * ifac[2 * i - 3 + !p] % Mod);
				}
```

**step4 $(n \le 20000)$：**

~~其实 n 方卡卡常就能草过去。~~

依然以 $0 \rightarrow 0$ 的转移为例（其它大同小异），令 $j \leftarrow i+j+2$，重新化简一下转移式：

$$
\begin{aligned}
f_{j,0} \leftarrow f_{j,0} &+f_{i,0} \cdot (j-i)(j-i-1) \cdot \dfrac{(j+i-5)!}{(2i-3)!}\\
f_{j,0} \leftarrow f_{j,0} &+ \dfrac{f_{i,0}(i^2+i)}{(2i-3)!} \cdot (j+i-5)!\\
&+ (j^2-j)\dfrac{f_{i,0}}{(2i-3)!}(j+i-5)!\\
&- 2j\dfrac{f_{i,0}i}{(2i-3)!}(j+i-5)!
\end{aligned}
$$

式子中只有和 $i,j,i+j$ 有关的项，所以这实际上就是半在线减法卷积，使用分治法解决即可。

注意到是任意模数，写 NTT 巨烦，可以考虑用 Karatsuba 乘法代替。

使用 NTT 或 Karatsuba 乘法即可得到 $O(n \log^2 n)$ 或 $O(n^{1.59})$ 的复杂度。

细节较多，注意代码实现。

代码（使用 Karatsuba 乘法）：
```cpp
#include <bits/stdc++.h>
#define lowbit(x) (x & -x)
#define eb emplace_back
#define pb push_back
#define mp make_pair
using namespace std;

typedef long long ll;
typedef vector<int> poly;
const int N = 4e4+5;

struct FastMod {
    ll p, m;
    FastMod(ll pp): p(pp), m((1ll << 62) / pp) { }
    ll operator ()(ll x) {
        ll r = x - p * ((__int128) x * m >> 62);
        return r >= p ? r - p : r;
    }
} F(2);

int n, Mod, ans = 1;
int f[N][2];
ll Bfac[N], Bifac[N], *fac = Bfac + 2, *ifac = Bifac + 2;

inline ll qpow(int a, int b) {
	ll base = a, ans = 1;
	while (b) {
		if (b & 1) ans = ans * base % Mod;
		base = base * base % Mod;
		b >>= 1;
	}
	return ans;
}

inline void Add(int &a, int b) { a += b; if (a >= Mod) a -= Mod; }
inline void Add(ll &a, int b) { a += b; if (a >= Mod) a -= Mod; }

ll A[N], B[N], C[N], r0[15][N], r1[15][N], r2[15][N], x[15][N], y[15][N];

inline int mul(int d, ll *a, ll *b, int n, ll *g) {
    if (!n) return 0;
    for (int i = 0; i < 2 * n - 1; i++) g[i] = 0;
    // if (1) {
    if (n <= 16) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                g[i + j] = F(g[i + j] + a[i] * b[j]);
        return 2 * n - 1;
    }
    int mid = (n + 1) / 2;
    int l0 = mul(d + 1, a, b, mid, r0[d]);
    int l1 = mul(d + 1, a + mid, b + mid, n - mid, r1[d]);
    for (int i = 0; i < l0; i++) Add(g[i + mid], Mod - r0[d][i]), Add(g[i], r0[d][i]);
    for (int i = 0; i < l1; i++) Add(g[i + mid], Mod - r1[d][i]), Add(g[i + 2 * mid], r1[d][i]);

    for (int i = 0; i < mid; i++) {
        x[d][i] = a[i], y[d][i] = b[i];
        if (mid + i < n) Add(x[d][i], a[mid + i]), Add(y[d][i], b[mid + i]);
    }
    int l2 = mul(d + 1, x[d], y[d], mid, r2[d]);

    for (int i = 0; i < l2; i++) Add(g[i + mid], r2[d][i]);

    return 2 * n - 1;
}

inline ll c0(int p, int q, ll j) { return F(p * q * j * j + (p + q - p * q) * j); }
inline ll c1(int p, int q, ll i) { return F(p * q * i * i + (p * q - p - q) * i + (1 - p) * (1 - q) + Mod); }

void solve(int l, int r) {
	if (l == r) return;
	int mid = (l + r) >> 1;
	solve(l, mid);
	for (int p = 0; p < 2; p++)
		for (int q = 0; q < 2; q++) {
			for (int i = 0; i < r - l; i++) B[i] = fac[mid - 2 + l - q + i - p], A[i] = 0;
			if (p * q || (p + q - p * q)) {
				for (int i = l; i <= mid; i++) A[mid - i] = F(f[i][p] * ifac[2 * i - 2 - p]);
				mul(0, A, B, r - l, C);
				for (int i = mid - l; i <= r - l - 1; i++) {
					int j = i + 1 + l - q;
                    f[j + q][q] = F(f[j + q][q] + c0(p, q, j) * C[i]);
				}
			}

			if (p * q || (p * q - p - q) || (1 - p) * (1 - q)) {
				for (int i = l; i <= mid; i++) A[mid - i] = F(F(f[i][p] * ifac[2 * i - 2 - p]) * c1(p, q, i));
				mul(0, A, B, r - l, C);
				for (int i = mid - l; i <= r - l - 1; i++) Add(f[i + 1 + l][q], C[i]);
			}

			if (p * q) {
				for (int i = l; i <= mid; i++) A[mid - i] = F(F(f[i][p] * ifac[2 * i - 2 - p]) * i);
				mul(0, A, B, r - l, C);
				for (int i = mid - l; i <= r - l - 1; i++) {
					int j = i + 1 + l - q;
					Add(f[j + q][q], Mod - F(C[i] * 2 * j));
				}
			}
		}
	solve(mid + 1, r);
}

int main() {
	scanf("%d%d", &n, &Mod); F = FastMod(Mod);

	fac[0] = 1;
	for (int i = 1; i <= 2 * n; i++) fac[i] = fac[i - 1] * i % Mod;
	ifac[2 * n] = qpow(fac[2 * n], Mod - 2);
	for (int i = 2 * n; i; i--) ifac[i - 1] = ifac[i] * i % Mod;

	f[1][0] = f[2][1] = 1;
	solve(1, n);

	for (int i = 3; i <= 2 * n; i += 2) ans = (ll) ans * i % Mod;
	for (int i = 1; i <= n; i++)
		for (int p = 0; p < 2; p++) {
			ll t = f[i][p];
			if (p) t = t * (n - i + 1) % Mod;
			Add(ans, Mod - t * fac[n + i - 3 + !p] % Mod * ifac[2 * i - 3 + !p] % Mod);
		}

	printf("%d", ans);
	return 0;
}
```

---

## 作者：Purslane (赞：1)

# Solution

还是昨天讲的题，感觉讲的有点抽象，稍微整理一下。

-------

计算所有符合条件的 $(a,b)$ 总数。

依次确定 $a_1$，$b_1$，$a_2$，$b_2$，$\dots$，$a_n$，$b_n$。其中 $a_i$ 只有 $1$ 种可能，而 $b_i$ 有 $2n-2i+1$ 种可能。因此总数为 $(2n-1)!!$。我们可以用它减去能求出正确解的 $(a,b)$ 的个数。

--------

显然正确的贪心是将区间按 $b$ 排序。把 $a$ 和 $b$ 放到数轴上考虑。

正确的贪心满足：对于所有大小为 $|S|=s$ 的不相交线段组，我们求出的那一组 $\max_{u \in S} b_u$ 最小。

考察正确算法求出的 $S$ 的每条线段，假设第 $k$ 条右端点为 $b_k$，若想让两个算法求出来的东西一样，应该有：假算法求出来的 $T$ 种 $a_t \le b_k$ 的 $t$ 的数量 $\ge k$。（如果 $<k$，随便调整一下显然不优）。更加细致的，应该是这样的结构：

![](https://s21.ax1x.com/2024/06/06/pkYhYi8.md.png)

---------

下文的基本思路：对于每个点，可以选择是左端点还是右端点。左端点加入“未匹配”行列，右端点和一个未匹配的左端点匹配。并且及时判断新加的线段是否会出现在两种算法中。（错误算法在左端点处判断，正确算法在右端点处判断）

这样可以 $\rm DP$ 了。设 $dp_{i,j,k,op}$ 表示考虑了数轴上 $1$ 到 $i$ 的点，在**最后一个确认的、作为正确算法某条线段右端点**的点，左边有 $j$ 个未匹配左端点，右边有 $k$ 个未匹配左端点。

$op$ 表示扫描到 $i$ 的状态：

- $op=0$ 表示两种算法都选取了相同数量的完整的合法线段；
- $op=1$ 表示错误算法选了一个左端点，不过还没有配上合适的右端点，两种算法已经选了相同数量的合法线段；
- $op=2$ 表示错误算法选了一个左端点，不过还没有配上合适的右端点，但是正确算法目前比错误算法少选了一条线段。（如果你认为这种情况不会出现，考虑 $\{(1,3),(2,5),(4,7),(6,8)\}$）

前两种的转移比较容易，分别考虑下一步是加一个左端点，还是加一个右端点且和哪种左端点匹配。

但是这样复杂度为 $O(n^3)$。

主要优化点在于，$j$ 这一维根本不会改变两种算法选取线段的条数，我们可以在它产生的时候，强制在后面未确定的 $t$ 个数中选取若干个作为他们匹配的右端点（也就是转移到 $i+j$ 去，乘上一个排列数。）

注意，未匹配左端点是否为“错误算法中正在处理的线段的左端点”是有区别的，要分开考虑。

这样可以 $O(n^2)$ 大力冲过去。

一个可能的优化技巧：如果一个量要进行多次加法操作，那么可以用 `__int128` 存，不急着取模，用的时候取一次即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e4+10;
int n,MOD,ans=1,dp[2][3][MAXN],frac[MAXN<<1],inv[MAXN<<1];
__int128 ad[MAXN<<1],Ad[MAXN<<1];
inline void add(int &a,const int b) {a+=b;if(a>=MOD) a-=MOD;return ;}
int qpow(ll base,ll p) {
	ll ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;	
	}
	return ans;
}
inline ll A(const int u,const int d) {return 1ll*frac[d]*inv[d-u]%MOD;}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>MOD;
	frac[0]=1; ffor(i,1,n+n) frac[i]=1ll*frac[i-1]*i%MOD;
	ffor(i,1,n+n) if(i&1) ans=1ll*ans*i%MOD;
	inv[n+n]=qpow(frac[n+n],MOD-2); roff(i,n+n-1,0) inv[i]=1ll*inv[i+1]*(i+1)%MOD;
	dp[0][0][0]=1;
	double DEL=0;
	ffor(i,0,n+n-1) {
		int lst=i&1,st=lst^1;
		add(dp[lst][0][0],ad[i]%MOD);
		add(dp[lst][1][0],Ad[i]%MOD);
		memset(dp[st],0,sizeof(dp[st]));
		ffor(j,0,min(i,n+n-i)) {
			if(dp[lst][0][j]) dp[st][2][j+1]=dp[lst][0][j];
			if(dp[lst][1][j]) dp[st][0][j]=dp[lst][1][j],dp[st][1][j+1]=dp[lst][1][j];
			if(dp[lst][2][j]) {
				ad[i+j]=(ad[i+j]+A(j-1,n+n-i-1)*dp[lst][2][j]);
				if(j!=1) Ad[i+j-1]=(Ad[i+j-1]+dp[lst][2][j]*A(j-2,n+n-i-1)%MOD*(j-1));
				add(dp[st][2][j+1],dp[lst][2][j]);
			}
		}
	}
	cout<<((ans-(dp[0][0][0]+(int)(ad[n+n]%MOD))%MOD)%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：lyreqwq (赞：0)

真贪心显然是按右端点排序。

考虑容斥，统计真贪心和假贪心答案相同的方案数，再用总方案数 $(2n - 1)!!$ 减掉相同的即为答案。

我们设真贪心选择的区间为红区间，假贪心选择的区间为蓝区间，真假贪心同时选择的区间为紫区间，同时不选择的区间为黑区间。

观察合法方案的形态，可以发现：

- 把所有区间按右端点排序后，红蓝区间交替出现。
- 相邻的两个红区间，它们的右端点之间不存在完整区间；第一个红区间的右端点之前不存在完整区间。
- 相邻的两个蓝区间，前者的右端点与后者的左端点之间不存在某个区间的左端点；第一个蓝区间的左端点之前不存在某个区间的左端点。

![](https://pic.imgdb.cn/item/64a18b841ddac507cc6fa3fa.png)

容易想到线头 dp，设 $f_{i, j, p, q}$ 表示考虑 $[1\dots i]$，剩下 $j$ 个左端点未匹配，红蓝区间右端点分别为 $p, q$ 的方案数。这个转移是简单的。

红蓝区间是交替出现的，所以可以转成插入 dp。设 $f_{i, j, 0/1}$ 表示已有 $i$ 个完整区间，剩下 $j$ 个左端点未匹配的方案数。另外还要记一维 $0/1$ 表示最后一组区间是不是紫区间。

每次转移需要枚举有多少黑区间的右端点在上个红区间右端点与当前红区间右端点之间。然后统计给这些黑区间分配左端点的贡献。另外，一个位置是合法的左端点当且仅当它被某个蓝区间包含。可以做到 $O(n^3)$。还需要压缩状态数。

发现这里 dp 状态需要记两维的原因是，蓝区间对左端点的限制很强，而对右端点的限制很弱。一个巧妙的做法是，从右往左 dp，每次插入左端点在相邻两个红区间右端点之间的黑区间。这样就把左端点的限制放到了枚举里而不是状态里。而右端点可以在后面的任意两个位置之间插入，不需要往状态里加更多信息。

具体地，设 $f_{i, 0/1}$ 表示从右到左考虑，已有 $i$ 个完整区间，（从右到左）最后一组区间是否是紫区间的方案数。

但是这样还不够，我们还要额外记录最后一组红蓝区间左端点的信息，因为这部分信息会影响分配黑区间的方案数。

不妨延后分配最后一组红蓝区间的左端点，而红区间右端点一定在蓝区间右端点左侧，无需记录。然后原 dp 状态就可以转移了。

以 $0\to 0$ 的转移为例。首先我们要分配 $j$ 个黑区间的左端点，上一组红蓝区间的左端点，以及当前这一组蓝区间的右端点。相邻蓝区间的右端点和左端点之间不能有其它左端点，于是可以把它俩缩起来当一个点处理，方案数是 $(j + 2)(j + 1)$。后面有 $(2i - 2)$ 个间隔可以插入右端点，方案数是 $(2i - 2)^{\overline{j}}$。

剩下三种状态同理。写一下转移方程：
$$
\begin{aligned}
  f_{i + j + 2, 0} &\gets f_{i, 0} (j + 2)(j + 1) (2i - 2)^{\overline{j}} \\
  f_{i + j + 2, 0} &\gets f_{i, 1} (j + 1) (2i - 1)^{\overline{j}} \\
  f_{i + j + 1, 1} &\gets f_{i, 0} (j + 1) (2i - 2)^{\overline{j}} \\
  f_{i + j + 1, 1} &\gets f_{0, 1} (2i - 1)^{\overline{j}}
\end{aligned}
$$
![](https://pic.imgdb.cn/item/64a194d31ddac507cc7fc49b.png)

![](https://pic.imgdb.cn/item/64a1950f1ddac507cc802274.png)

统计答案的时候还要考虑在最后一组红蓝区间前面的黑区间的贡献。

现在是 $O(n^2)$。进一步优化需要半在线差卷积，分治 MTT。但是不如卡常直接能过。可能需要 Barrett Reduction。

---


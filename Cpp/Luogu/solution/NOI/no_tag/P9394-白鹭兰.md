# 白鹭兰

## 题目描述

有很多有关火星人的传说，比如他们的 DNA 非常复杂，他们有成千上万根手指等等，但这些都没有得到证实。同样没有得到证实的一个传说是火星人很会做 OI 题。

为了验证最后这个传说，地球人们给来自火星的外星旅人出了一道 OI 题：

> 给定一张 $n$ 个点 $m$ 条边的无向连通图 $G=(V,E)$，请找出最小的 $k$ 使得存在一个对点集的划分 $V_1,\ldots,V_t$ 使得：
>
> - $\forall 1\leq x\leq t$，$\bigcup_{i=1}^x V_i$ 的导出子图连通；
>
> - $\forall 1\leq x\leq t$，$\bigcup_{i=x}^t V_i$ 的导出子图连通；
>
> - $\forall 1\leq x\leq t$，$|V_x|\leq k$。
>
> 注意，作为划分，还需要满足 $\bigcup_{i=1}^t V_i=V$，$ V_i\cap V_j=\varnothing\ (\forall i\neq j)$，且所有 $V_i$ 非空。
>
> 请给出最小的 $k$ 以及对应的划分。

再见，You're 火星人。现在你需要完成这道题，证明火星人的智慧。

## 说明/提示

**【样例解释】**

如下图，$V_1,\ldots,V_5$ 分别是红色/橙色/绿色/蓝色/紫色点集，可以验证这满足题目条件。

![](https://cdn.luogu.com.cn/upload/image_hosting/omc7gvxe.png)

--- 

**【评分方式】**

如果你的输出格式错误，将有可能不得分，也可能导致不可预知的错误。

如果你的输出格式正确，若你的 $k_{min}$ 正确，你将获得测试点 $50\%$ 的分数，若在此基础上你的构造方案正确，你将获得测试点 $100\%$ 的分数。

---

**【数据范围】**

对于全部数据：$2\leq n\leq 2\times 10^5$，$1\leq m\leq 2.3\times 10^5$，$1\leq x,y\leq n$，保证给出的 $m$ 条边中没有重边和自环，保证给出的图连通。

|     子任务编号     | $m\leq$ |        特殊限制        | 分值 |
| :----------------: | :-------------: | :--------------------: | :--: |
| $\text{Subtask 1}$ |     $2\times 10^5$     | $G$ 是链 | $10$ |
| $\text{Subtask 2}$ |      $10$       |         无          | $10$ |
| $\text{Subtask 3}$ |     $2000$      |         $G$ 是树          | $15$ |
| $\text{Subtask 4}$ |     $2000$      |         无          | $20$ |
| $\text{Subtask 5}$ |      $10^5$      |           $G$ 是树           | $15$ |
| $\text{Subtask 6}$ |     $2.3\times 10^5$     |           无           | $30$ |


---

![](https://cdn.luogu.com.cn/upload/image_hosting/41etnpdx.png)

## 样例 #1

### 输入

```
7 7
1 2
1 3
1 5
1 6
4 5
5 6
6 7
```

### 输出

```
2 5
1 2
2 1 3
2 5 4
1 6
1 7
```

# 题解

## 作者：ix35 (赞：30)

## 白鹭兰

我们首先考虑，如何判断是否有 $k=1$，即是否存在一个点的排列，使得所有前缀和后缀的导出子图连通。将这个过程看成每次染黑一个点，时刻保证当前黑点和白点的导出子图都是连通的。

考虑图的圆方树，如果所有点双连通分量没有构成一条链，就说明存在一个割点 $x$ 使得删去它后图分成至少三个连通块，设其中三个连通块为 $C_1,C_2,C_3$，由于加入 $x$ 前黑白点导出子图都是连通的，所以 $C_1,C_2,C_3$ 至少有两个是纯白的（因为 $x$ 是白的），加入 $x$ 后这两个纯白的部分就一定不连通了，这说明一定不存在一个可行的方案。

后面我们会构造证明，只要点双连通分量排成一条链，就一定有 $k=1$ 的解。

下面考虑如何求最小的 $k$，使得存在一种方案每次染黑至多 $k$ 个点，任何时刻黑白点导出子图都连通。我们设第一个被染黑的点（第一批 $V_1$ 里任选一个）和最后一个（最后一批里任选一个）被染黑的点分别是 $x,y$，不妨设它们都是圆方树的叶子（否则可以调整），考虑路径 $x\to y$。

对于 $x\to y$ 上的某个圆点 $z$，事实上根据前面的讨论，$z$ 连同其不在 $x\to y$ 路径上的所有子树内的点都必须在同一次操作中被染黑，否则可以由和上面一样的方法导出矛盾。

同理，对于 $x\to y$ 上的某个方点 $u$，对于其每一个不在 $x\to y$ 路径上的儿子（圆点）$v$，$v$ 在 $x\to y$ 路径外侧的子树中的所有点必须在同一次操作中被染黑。

这样我们得到了若干个必须同时被染黑的集合，称为关键集合，它们的大小的最大值就是这一组 $(x,y)$ 对应的 $k$ 的最小值。下图展示了一个例子，每个红框中的部分是每个关键集合：

![](https://cdn.luogu.com.cn/upload/image_hosting/0aoyodgo.png)

但是暴力枚举 $x,y$ 的复杂度太高，尝试分析一些性质。

设 $x,y$ 的 LCA 是 $z$，且分别属于 $z$ 的儿子 $x_0,y_0$ 的子树，$x_0$ 到 $x$ 的路径为 $x_0\to x_1\to \ldots\to x_s=x$，那么我们证明：存在一种最优的 $x$，使得这个路径上任意两个相邻点都满足 $x_{i+1}$ 是 $x_i$ 的最大子树（$i\ge 1$）。

这是因为，设 $x_i$ 的最大子树是 $x'$，其大小为 $S$，如果 $x_{i+1}\ne x'$，则在 $x_i$ 处计算的贡献（$x_i$ 所在的关键集合大小）至少为 $S$，然而如果将 $x_{i+1}$ 调整为 $x'$，则在 $x_i$ 处计算的贡献一定会变小，而 $x_{i+1}$ 子树内算的贡献一定不会超过 $S$（因为整个子树大小只有 $S$)，因此一定不会更劣。

于是我们可以用树形 DP 来计算答案。设 $sn(x)$ 表示 $x$ 的最大子树，记 $f(x)$ 表示 $x\to sn(x)\to sn^2(x)\to \ldots$ 这条路径上的贡献。对于某个点 $z$，设其大小最大和次大的子树分别是儿子 $x,y$ 的子树，那么用 $\max(f(x),f(y),g(z,x,y))$ 更新答案即可，其中 $g(z,x,y)$ 表示 $z$ 这里的贡献（同上不难证明选择最大和次大的子树 $x,y$ 是最优的）。

上面我们已经解决了本题的第一部分，即圆方树上的部分，下一部分是构造答案，即一个点双连通分量内部怎么构造一种固定第一个染黑的点为 $x$，最后一个染黑的点为 $y$ 的每次染黑一个点的方案。

以 $x$ 为根，考虑 Tarjan 算法，对于每个点 $u$ 求出 DFS 树子树内通过返祖边可到达的最浅祖先 $low(u)$。考虑剥叶子，对于一个叶子 $u$，它有两个邻居 $f(u),low(u)$，我们可以在这两个点中的任意一个被染黑后立刻染黑 $u$，染黑 $u$ 与否并不会对剩余部分的连通性产生影响，所以这一定是合法的。

于是我们就从下往上考虑，对于每个点 $x$ 用 `vector` 维护一个后继列表 $L_x$，每次删一个叶子 $u$，就在 $L_{f(u)}$ 和 $L_{low(u)}$ 中在末尾插入 $u$。然后，我们染黑根结点 $x$。每当染黑一个点 $u$ 时，就从前到后依次递归染黑 $L_u$ 中的所有元素，这个过程中每个结点被染黑的顺序就是我们要求的答案。

但是上面我们没有考虑到 $y$ 要最后一个染黑，为此我们对算法稍加修改：剥叶子剥到 $y$ 的时候就不剥了，这样 $x\to y$ 路径上的点都会被保留，然后我们按照 $x\to y$ 的顺序依次染黑这些点。我们断言染黑 $y$ 时 $L_y$ 中的点已经全是黑的了，从而 $y$ 就是最后一个被染黑的：这是因为如果染黑 $y$ 时 $L_y$ 中还有没被染黑的点，就说明有一个点的所有（$y$ 以下的）祖先和后代都没有连到 $y$ 的祖先的返祖边，这说明 $y$ 是一个割点。

时间复杂度为 $O(m)$。

---

## 作者：Union_of_Britain (赞：5)

## 耳分解

设无向图 $G'(V',E')\subset G(V,E)$，简单路径或简单环 $P:x_1\to \dots \to x_k$ 被称为 $G$ 关于 $G'$ 的耳，当且仅当其满足 $x_1,x_k\in V',x_2,x_3\dots x_{k-1}\not\in V'$。如果 $P$ 是简单路径，那么 $P$ 称为开耳。

下面记树上 $x,y$ 之间的路径为 $P(x,y)$。



一个无向连通图的一个连通子图序列 $(G_0,G_1,\dots G_k),G_i(V_i,E_i)$ 满足：

- $G_0$ 是简单环。
- $G_{i-1}\subset G_i$。
- $E_i-E_{i-1}$ 是 $G_{i-1}$ 关于 $G_i$ 的一个耳（开耳）。

 那么称 $(G_0,G_1,\dots G_k)$ 是一个 $G$ 的耳分解（开耳分解）。



无向连通图 $G$ 存在耳分解当且仅当其边双连通，$G$ 存在开耳分解当且仅当其点双连通。

证明：

只证明前一个。开耳分解类似。

耳分解 $\Rightarrow$ 边双连通。显然，增加一个耳不会改变边双连通性。

边双连通 $\Rightarrow $ 耳分解。这就是耳分解的构造算法。

- 先求出 $1$ 为根的 dfs 树（不存在横叉边！！）。找到一个非树边 $1\to x$。初始 $G_0$ 设为 $1\to x$ 和 $P(1,x)$ 构成的简单环。
- 设已经构造了 $G_i$，找到一个点 $x $ 的父亲 $y$ 在 $G_i$ 中，自己不在。找到他子树的返祖边 $v\to u$，那么当前的耳就是 $P(y,v)\cup (v\to u)$。
- 重复上述过程直到点集为 $V$，剩下的一个边就是一个耳。

## 双极定向

对于无向图 $G(V,E)$ 和 $s,t\in V,s\neq t$。以下四个命题等价：

- 添加 $s\to t$ 后 $G$ 点双连通。
- 圆方树上的所有方点成链。并且 $P(s,t)$ 是圆方树的直径。
- 存在 DAG $G'$ 以 $G$ 为基图，且 $s$ 是唯一入度为 $0$ 的点，$t$ 是唯一出度为 $0$ 的点。
- 存在 $p\in S_n$，$p_1=s,p_n=t$，任意前缀后缀的导出子图连通。

$1,2$ 显然等价。

$3\Rightarrow 4$：取定向后的拓扑排序即可。

$4\Rightarrow 3$：当作拓扑排序定向即可。

$1\Rightarrow 3$：在加开耳的过程中搞一下即可。

$4\Rightarrow 1$：设存在（加边后）割点 $u$，此时 $s,t$ 在同一连通块。设另一任意连通块为 $S$。设 $S\cup \{u\}$ 在 $p$ 上最早晚的分别是 $x,y$，则 $x,y$ 至少有一个不是 $u$。此时根据 $4$，$S$ 应该和 $s,t$ 连通块连通，矛盾。



如何构造 $p$（这样也构造了双极定向）？跑出 dfs 树（这些过程中不考虑加的 $s\to t$ 边），记录每个点的 low。把每个点 $u$ 按照先 dfs 儿子再操作自己的顺序，如果 $u\not\in P(s,t)$，把 $low_u$ 和 $fa_u$ 结点的队列添加进 $u$。

接下来按顺序遍历 $P(s,t)$，遍历到一个点就把他加进 $p$，然后递归遍历其队列元素（如果没有被遍历过）。具体可以参见代码。这样做的正确性是不难发现的。

## Solution

题意：可以把若干个点缩成一个点（不限次数），使得上述条件 $4$ 被满足。最小化缩之后的点包含原来的点的个数的最大值。输出方案。

依靠前面的结论，就是希望圆方树的方点是链。这样不妨先考虑知道 $s,t$ 怎么做。在这样的链上，圆点必须被缩成一个点，方点连接到的（不在链上的）圆点必须被缩成一个点。对这些取 $\max$ 就是要求的答案。

有结论：固定一个点 $u$，另一个点 $v$ 在其子树内选取的话，最优的 $v$ 是不断走向**任意**重儿子得到的结果（笔者写代码的时候没有注意到任意）。这个结论正确，因为不走向重儿子，在 $u$ 上的影响都已经大于任何儿子内部的所有贡献了。

这个结论主要说明了：我们可以进行类似于贪心的过程，不会发生走向轻儿子（非当前最优）会导致总结果更优的情况。

那么可以在树上进行 dp。先求出每个点一直向重儿子走的贡献 $f$，枚举选取的 $s,t$ 的 LCA，取其重儿子和次重（非严格）儿子更新答案即可。

求出 $s,t$ 之后，按上面的构造方法来即可。

下面的代码是可以被精简的。

```cpp
// Problem: P9394 白鹭兰
// Platform: Luogu
// URL: https://www.luogu.com.cn/problem/P9394
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// Author:British Union
// Long live UOB and koala
//
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=5e5+5,INF=1e9;
int dfn[maxn],st[maxn],tp=0,T=0,cnt=0,low[maxn],n,m;
vector<int> e[maxn],e2[maxn];
void tarjan(int u){
	dfn[u]=low[u]=++T;
	st[++tp]=u;
	for(auto v:e[u]){
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(dfn[u]==low[v]){
				++cnt;
				for(int x=0;x!=v;--tp){
					x=st[tp];
					e2[x].push_back(cnt);
					e2[cnt].push_back(x);
				}
				e2[u].push_back(cnt);
				e2[cnt].push_back(u);
			}
		}else low[u]=min(low[u],dfn[v]);
	}
}
int sze[maxn],f[maxn],g[maxn],msze[maxn],msze2[maxn],d[maxn];
void dfs1(int u,int fa){
	sze[u]=(u<=n);
	for(auto v:e2[u])if(v!=fa)dfs1(v,u),sze[u]+=sze[v];
	for(auto v:e2[u]){
		if(v==fa)continue;
		if(sze[v]>msze[u])msze2[u]=msze[u],msze[u]=sze[v];
		else if(sze[v]>msze2[u])msze2[u]=sze[v];
	}
}
struct qsy{
	int a,b,c;
};
bool operator <(qsy x,qsy y){
	return make_pair(x.a,-x.b)<make_pair(y.a,-y.b);
}
void calcf(int u,int fa){
	bool cld=0;
	qsy ans={0,INF,-1};
	for(auto v:e2[u]){
		if(v==fa)continue;
		calcf(v,u);
		cld=1;
		if(u<=n)ans=max(ans,(qsy){sze[v],max(f[v],sze[u]-sze[v]),d[v]});
		else ans=max(ans,(qsy){sze[v],max(f[v],sze[v]==msze[u]?msze2[u]:msze[u]),d[v]});
	}
	if(cld==0)f[u]=sze[u],d[u]=u;
	else f[u]=ans.b,d[u]=ans.c;
}
int mn=INF,minx,miny;
void upd(int ans,int x,int y){
	if(x>n||y>n)return ;
	if(ans<mn)mn=ans,minx=x,miny=y;
}
int bcnt[maxn];
void dp(int u,int fa){
	qsy m1={0,INF,-1},m2={0,INF,-1};
	for(auto v:e2[u]){
		if(v==fa)continue;
		dp(v,u);
		qsy cur={sze[v],f[v],d[v]};
		if(m1<cur)m2=m1,m1=cur;
		else if(m2<cur)m2=cur;
	}
	int ans=0;
	if(m2.b==INF){
		if(m1.b==INF){return ;}
		else ans=m1.b;
	}else ans=max(m1.b,m2.b);
	bcnt[m1.a]++,bcnt[m2.a]++;
	int res=0;
	for(auto v:e2[u]){
		if(v==fa)continue;
		if(bcnt[sze[v]]>0)bcnt[sze[v]]--;
		else{
			if(u<=n)res+=sze[v];
			else res=max(res,sze[v]);
		}
	}
	if(u<=n)res+=n-sze[u]+1;
	else res=max(res,n-sze[u]);
	ans=max(ans,res);
	g[u]=ans;int X=m1.c,Y=m2.c;
	if(Y==-1)Y=u;
	upd(g[u],X,Y);
}
int ban1,ban2,c[maxn],K,C;
void dfs2(int u,int fa){
	st[++tp]=u;
	if(u==miny){
		K=tp;
		for(int i=1;i<=K;i++)c[i]=st[i];
		return ;
	}
	for(auto v:e2[u]){
		if(v==fa)continue;
		dfs2(v,u);
	}
	--tp;
}
vector<int> pt[maxn];
int bel[maxn];
void dfs3(int u,int fa){
	if(u==ban1||u==ban2)return ;
	if(u<=n)pt[cnt].push_back(u);
	bel[u]=cnt;
	for(auto v:e2[u]){
		if(v==fa)continue;
		dfs3(v,u);
	}
}
vector<int> e3[maxn],L[maxn],e4[maxn];
bool vis[maxn],vis2[maxn];
int Ans[maxn],len=0,hzc[maxn],mk=0,Fa[maxn],rev[maxn];
void tarjan2(int u){
	dfn[u]=low[u]=++T;
	rev[dfn[u]]=u;
	st[++tp]=u;
	if(u==miny)for(int i=1;i<=tp;i++)vis2[st[i]]=1,hzc[++mk]=st[i];
	for(auto v:e3[u]){
		if(!dfn[v]){
			e4[u].push_back(v);
			e4[v].push_back(u);
			Fa[v]=u;
			tarjan2(v);
			low[u]=min(low[u],low[v]);
		}else low[u]=min(low[u],dfn[v]);
	}
	--tp;
}
void dfs4(int u){
	if(vis[u])return ;
	Ans[++len]=u;
	vis[u]=1;
	for(auto v:L[u])dfs4(v);
}
namespace checker{
	vector<int> cur;
	bool vis[maxn],vis2[maxn];
	void dfs(int u){
		if(vis[u])return;
		vis[u]=1;
		for(auto v:e[u]){
			if(!vis2[v])continue;
			dfs(v);
		}
	}
	bool check(){
		for(int i=1;i<=n;i++)vis[i]=vis2[i]=0;
		for(auto u:cur)vis2[u]=1;
		dfs(cur[0]);
		for(auto u:cur)if(!vis[u])return 0;
		return 1;
	}
	void checkans(){
		for(int i=1;i<=cnt;i++){
			for(auto u:pt[Ans[i]])cur.push_back(u);
			if(!check())exit(1);
		}
		cur.clear();
		for(int i=cnt;i>=1;i--){
			for(auto u:pt[Ans[i]])cur.push_back(u);
			if(!check())exit(1);
		}
	}
}
void dfs5(int u,int fa){
	for(auto v:e4[u]){
		if(v==fa)continue;
		dfs5(v,u);
	}
	if(!vis2[u])L[Fa[u]].push_back(u),L[rev[low[u]]].push_back(u);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	cnt=n;
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
	dfs1(1,0);calcf(1,0);dp(1,0);
	tp=0;dfs2(minx,0);cnt=0;
	for(int i=1;i<=K;i++){
		ban1=c[i-1],ban2=c[i+1];
		if(c[i]<=n){
			C=++cnt;
			dfs3(c[i],0);
		}else{
			for(auto v:e2[c[i]]){
				if(v==ban1||v==ban2)continue;
				C=++cnt;
				dfs3(v,c[i]);
			}
		}
	}
	cout<<mn<<" "<<cnt<<endl;
	for(int i=1;i<=n;i++)for(auto j:e[i])if(bel[i]!=bel[j])e3[bel[i]].push_back(bel[j]);
	minx=bel[minx],miny=bel[miny],T=0;tp=0;
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	tarjan2(minx);
	dfs5(minx,0);
	for(int i=1;i<=mk;i++)dfs4(hzc[i]);
	for(int i=1;i<=cnt;i++){
		cout<<pt[Ans[i]].size()<<" ";
		for(auto u:pt[Ans[i]])cout<<u<<" ";
		cout<<endl;
	}
	// checker::checkans();
	return 0;
}
```

---

## 作者：251Sec (赞：4)

考虑 $k=1$ 的情况，相当于求是否有一个序列使得它的每个前缀和每个后缀都是连通的，这是经典的双极定向问题，在此不多赘述做法，但是我们有结论：存在方案当且仅当图的圆方树是一条链。

回到原问题，相当于把整个图划分成若干个连通块，每个连通块缩成一个点，使得圆方树是一条链。这事实上等价于选取圆方树上的一条链，删去所有上面的方点，然后把剩下的每个连通块里的圆点缩到一起。我们希望这些剩下的连通块里包含圆点最多的连通块包含的圆点尽量少。

考虑用树上 DP 处理这个问题，枚举 LCA，发现一定会选择向它圆点最多和次多的子树里伸出这条链，并且从这两个子树往下延伸的时候也会选择圆点最多的子树，这一点的正确性还挺显然的。那么直接设 $f(u)$ 代表从 $u$ 往 $u$ 的子树里延伸一条链，这个子树的最小答案。容易转移。

求出 DP 的答案后，直接用双极定向的方法构造方案即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m;
struct Edge {
	int to, next;
} e[500005];
int head[200005], len = 1;
void Insert(int u, int v) {
	e[++len] = { v, head[u] };
	head[u] = len;
}
int p[400005];
namespace Bipolar {
	Edge e[800005];
	int head[400005], len;
	void Insert(int u, int v) {
		e[++len] = { v, head[u] };
		head[u] = len;
	}
	void InsertD(int u, int v) { Insert(u, v), Insert(v, u); }
	int n, s, t, dfn[400005], low[400005], cti, deg[400005], chn[400005], cCnt, prt[400005], pCnt;
	bool DFS(int u) {
		dfn[u] = low[u] = ++cti;
		bool f = (u == t);
		for (int i = head[u]; i; i = e[i].next) {
			int v = e[i].to;
			if (!dfn[v]) {
				f |= DFS(v);
				deg[u]++, prt[v] = u;
				low[u] = min(low[u], low[v]);
			}
			else low[u] = min(low[u], dfn[v]);
		}
		if (f) chn[++cCnt] = u;
		return f;
	}
	queue<int> q;
	vector<int> ve[400005];
	bool vis[400005];
	void Proc(int u) {
		if (vis[u]) return;
		vis[u] = true, p[++pCnt] = u;
		for (int v : ve[dfn[u]]) Proc(v);
	}
	void Solve() {
		DFS(s);
		for (int i = 1; i <= n; i++) if (!deg[i]) q.push(i);
		while (!q.empty()) {
			int u = q.front(); q.pop();
			if (u == t) continue;
			ve[low[u]].push_back(u);
			ve[dfn[prt[u]]].push_back(u);
			if (!--deg[prt[u]]) q.push(prt[u]);
		}
		while (cCnt) Proc(chn[cCnt--]);
	}
}
int dfn[200005], low[200005], cti, st[500005], top, bel[500005], cnt;
namespace RST {
	int ans, pos;
	Edge e[800005];
	int head[400005], len;
	int fi[400005], se[400005], siz[400005];
	void Insert(int u, int v) {
		e[++len] = { v, head[u] };
		head[u] = len;
	}
	void InsertD(int u, int v) { Insert(u, v), Insert(v, u); }
	int f[400005];
	void DFS(int u, int fa) {
		siz[u] = (u <= n);
		for (int i = head[u]; i; i = e[i].next) {
			int v = e[i].to;
			if (v == fa) continue;
			DFS(v, u);
			siz[u] += siz[v];
			if (siz[v] > siz[fi[u]]) se[u] = fi[u], fi[u] = v;
			else if (siz[v] > siz[se[u]]) se[u] = v;
		}
		int d1 = (u <= n), d2 = (u <= n);
		for (int i = head[u]; i; i = e[i].next) {
			int v = e[i].to;
			if (v == fa || v == fi[u]) continue;
			if (u <= n) d1 += siz[v];
			else d1 = max(d1, siz[v]);
			if (v == se[u]) continue;
			if (u <= n) d2 += siz[v];
			else d2 = max(d2, siz[v]);
		}
		if (u <= n) d2 += n - siz[u];
		else d2 = max(d2, n - siz[u]);
		d1 = max(d1, f[fi[u]]);
		d2 = max({ d2, f[fi[u]], f[se[u]] });
		f[u] = d1;
		if (d2 <= ans) ans = d2, pos = u;
	}
	bool del[400005];
	int col[400005], cCnt;
	vector<int> pt[400005];
	void ColDFS(int u) {
		if (col[u] || del[u]) return;
		col[u] = cCnt;
		if (u <= n) pt[cCnt].push_back(u);
		for (int i = head[u]; i; i = e[i].next) ColDFS(e[i].to);
	}
	void Solve() {
		ans = 1e9;
		DFS(1, 0);
		if (pos > n) del[pos] = true;
		int pa = pos, pb = pos;
		for (int x = fi[pos]; x; x = fi[x]) {
			if (x > n) del[x] = true;
			else pa = x;
		}
		for (int x = se[pos]; x; x = fi[x]) {
			if (x > n) del[x] = true;
			else pb = x;
		}
		for (int i = 1; i <= cnt; i++) if (!col[i] && !del[i]) cCnt++, ColDFS(i);
		Bipolar::n = cCnt, Bipolar::s = col[pa], Bipolar::t = col[pb];
		for (int u = 1; u <= n; u++) {
			for (int i = ::head[u]; i; i = ::e[i].next) {
				int v = ::e[i].to;
				if (col[u] != col[v] && u < v) Bipolar::InsertD(col[u], col[v]);
			}
		}
		Bipolar::Solve();
		printf("%d %d\n", ans, cCnt);
		for (int i = 1; i <= cCnt; i++) {
			printf("%d ", (int)pt[p[i]].size());
			for (int u : pt[p[i]]) printf("%d ", u);
			putchar('\n');
		}
	}
}
bool vis[200005];
set<pair<int, int>> ed;
void Tarjan(int u) {
	dfn[u] = low[u] = ++cti;
	for (int i = head[u]; i; i = e[i].next) {
		int v = e[i].to;
		if (!bel[i >> 1] && !vis[i >> 1]) {
			st[++top] = i;
			vis[i >> 1] = true;
		}
		if (!dfn[v]) {
			Tarjan(v);
			low[u] = min(low[u], low[v]);
			if (low[v] == dfn[u]) {
				cnt++;
				ed.emplace(u, cnt);
				while (vis[i >> 1]) {
					int x = st[top--];
					vis[x >> 1] = false, bel[x >> 1] = cnt;
					ed.emplace(e[x].to, cnt);
				}
			}
		}
		else low[u] = min(low[u], dfn[v]);
	}
}
int main() {
	scanf("%d%d", &n, &m);
	cnt = n;
	for (int i = 1, u, v; i <= m; i++) {
		scanf("%d%d", &u, &v);
		Insert(u, v), Insert(v, u);
	}
	Tarjan(1);
	for (auto [u, v] : ed) RST::InsertD(u, v);
	RST::Solve();
	return 0;
}
```

---

## 作者：Federico2903 (赞：3)

## 题目大意

给定一张 $n$ 个点 $m$ 条边的无向连通图 $G=(V,E)$，请找出最小的 $k$ 使得存在一个对点集的划分 $V_1,\ldots,V_t$ 使得：

- $\forall 1\leq x\leq t$，$\bigcup_{i=1}^x V_i$ 的导出子图连通；
- $\forall 1\leq x\leq t$，$\bigcup_{i=x}^t V_i$ 的导出子图连通；
- $\forall 1\leq x\leq t$，$|V_x|\leq k$。

注意，作为划分，还需要满足 $\bigcup_{i=1}^t V_i=V$，$ V_i\cap V_j=\varnothing\ (\forall i\neq j)$，且所有 $V_i$ 非空。

请给出最小的 $k$ 以及对应的划分。

## 耳分解

我们约定 $u \leadsto v$ 表示 $u$ 到 $v$ 的一条路径，$u \to v$ 表示 $u$ 和 $v$ 间的一条边。

在无向图 $G(V,E)$ 中，存在一个子图 $G'(V',E')$，若简单路径或简单环 $P$：$x_1 \to x_2 \to x_3 \to \cdots \to x_{n - 1} \to x_n$ 且 $x_1, x_n \in V', x_2,\dots,x_{n - 1} \notin V'$，我们称 $P$ 为 $G$ 关于 $G'$ 的耳。

若 $P$ 是简单路径，则称 $P$ 是 $G$ 关于 $G'$ 的开耳。

对于无向连通图 $G$，若连通图序列 $(G_0, G_1, G_2, \cdots, G_k)$ 满足：

1. $G_0$ 是一个简单环（可以只有一个点），$G_k = G$。
2. $G_{i - 1}$ 是 $G_i$ 的子图。
3. 设 $G_i = (V_i, E_i)$，则 $E_i \backslash E_i - 1$ 构成 $G_{i - 1}$ 的一个耳（开耳）。

则称 $(G_0, G_1, G_2, \cdots, G_k)$ 是 $G$ 的一个耳分解（开耳分解）。

我们有定理：至少含有三个点的无自环无向连通图 $G$ 存在开耳分解当且仅当 $G$ 点双连通。

证明：

若 $G$ 有开耳分解 $(G_0,\cdots,G_k)$，则因为 $G_0$ 是简单环，所以 $G_0$ 点双连通。则在 $G_i$ 的基础上加一条路径构成的 $G_{i + 1}$ 也是点双连通的。

归纳可得 $G_k$ 是点双连通的。

若 $G$ 点双连通，我们求出一棵以 $1$ 为根节点的 DFS 树，可以使用如下方法构造出一组开耳分解：

1. 找到一条以 $1$ 为端点的非树边 $1 \to x$，令 $G_0$ 为 $1 \leadsto x$ 和这条非树边构成的简单环。
2. 如果 $G_i$ 的点集不为 $V$，找到一个 $x \notin G_i$ 且 $fa(x) \in G_i$，根据点双连通性，此时一定存在一条返祖边 $u \to v$ 覆盖了 $fa(x) \to x$ 且 $u$ 为 $fa(x)$ 的祖先，$v$ 为 $x$ 的后代，则 $fa(x) \leadsto v$ 并上 $u \to v$ 是 $G_i$ 的一个开耳，令 $G_{i + 1}$ 为 $G_i$ 加上该开耳。
3. 如果 $G_i$ 的点集为 $V$，则剩余的边都作为一个开耳依次加入。

由于第二步中 $G_i$ 一定是一个包含 $1$ 的树上连通块，所以这样的 $x$ 一定能找到。

## 双极定向

考虑如下命题：给定一张无向连通图 $G$，将其定向为 DAG，要求 $S$ 是唯一一个入度为 $0$ 的点，$T$ 是唯一一个出度为 $0$ 的点，$S \neq T$。

则其与下列命题等价：

1. 在添加一条无向边 $S \to T$ 后，$G$ 点双连通。
2. $G$ 的圆方树中的方点构成一条链，$S \leadsto T$ 是圆方树的一条直径。
3. 存在一个所有点的排列 $p_1,p_2,\cdots,p_n$ 且 $p_1 = S, p_n = T$，该排列任意前后缀的导出子图连通。

证明较长不再赘述。可以去看原[论文](https://github.com/enkerewpo/OI-Public-Library/blob/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2023%E8%AE%BA%E6%96%87%E9%9B%86.pdf)。

## 思路

回到原题，考虑 $k = 1$ 的特殊情况。此时原图的圆方树一定形成一条链。否则一定存在一个点，删去它后原图分成至少 $3$ 个连通块。

那么当 $k = 1$ 时，我们可以使用双极定向完成。

我们找出圆方树的直径，令其端点分别为 $S, T$。那么我们构造一组 $S$ 到 $T$ 的双极定向即可满足要求。

我们可以在连接 $S \to T$ 后对原图构造开耳分解 $(G_0, G_1, \cdots, G_k)$。注意到 $G_0$ 可以构造出一组包含 $S \to T$ 的环。那么除去这条边使得 $S$ 可达 $T$ 是简单的。

令 $P_i = G_i \backslash G_{i -1}$。设 $P_i$ 起始点为 $u_i$，终止点 $v_i$。若在 $G_{i - 1}$ 中 $u_i$ 可达 $v_i$，那么 可将 $P_i$ 定向为从 $u_i$ 到 $v_i$，反之。显然这不会破坏 DAG 的性质。也不会出现新的零度点，暴力进行的复杂度为 $O(n^2)$。 

但我们可以使用更简单的方法。我们以 $S$ 为根求出其 DFS 树和子树内最浅的返祖边。对于一个点 $u$，我们可以在 $low(u)$ 或 $fa(u)$ 被遍历时立即遍历该节点。

对于所有点都记录一个后继列表 $nxt$，表示遍历该点后下一步去哪些点。

在拓扑排序时保留 $S \leadsto T$ 的一条链，由于我们图上并没有真正连接 $S \to T$，所以我们手动钦定一下 $S \leadsto T$ 的染黑顺序。

对于其他的点，我们在剥叶子的时候将自己 `push_back` 进 $low(u)$ 和 $fa(u)$ 的 $nxt$ 即可。

因为在这种情况下我们删去该点不会影响连通性。假如删去该点影响连通性，则说明其子树内没有一个点能够跳到该点往上，则说明该点是割点。由于 $S \leadsto T$ 包含了所有割点，所以与我们的假设矛盾。

按照上述顺序遍历的点就是答案。

考虑 $k > 1$ 的情况。我们应该如何求出 $k_{\min}$？

此时原问题被化为了删去一条路径上的所有方点，剩余的连通块缩为一个点，使得新图的圆方树是一条链，并且圆点最多的连通块的圆点数量最少。

考虑枚举路径的 LCA，设其为 $x$，此时我们有结论：路径的两端会向 $x$ 圆点数量最大和次大的子树中延伸。

不难使用调整法证明：设 $x$ 最大的子树圆点数量为 $s$，若链的一端没有选择其最大的子树，则答案至少为 $s$，若把一端调整为其最大子树，其子树内最大的贡献也仅为 $s$，所以答案一定不会更劣。

所以可以简单树形 DP 取得答案。

设 $x$ 为其圆点数量最多的子树，$siz_y$ 为节点 $y$ 子树中圆点数量，节点编号 $\le n$ 的是圆点，我们有转移：
$$
f_u = \max(f_{x}, g(u))\\
g(u) =
\begin{cases}
\sum_{v \notin \{x, fa\}} siz_v & u \le n\\
\max_{v \notin \{x, fa\}} siz_v & u > n
\end{cases}
$$
缩连通块后用上述方法构造即可。

代码写的很长。[Here](https://www.luogu.com.cn/paste/oewu5t7u)。

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P9394)

**题目大意**

> 把 $n$ 个点 $m$ 条边的图 $G$ 分成若干个个集合 $V_1\sim V_k$，使得任意 $V_1\cup\dots\cup V_i$ 连通，任意 $V_{i+1}\cup\cdots\cup V_k$ 连通。
>
> 最小化 $\max |V_i|$。
>
> 数据范围：$n\le 2\times 10^5,m\le 2.3\times 10^5$。

**思路分析**

如果 $|V_i|=1$，那么这就是双极定向，$G$ 点双连通时必然有解。

如果 $G$ 不点双连通，那么建立圆方树：

- 如果圆方树是链，那么对每个点双联通分量双极定向，终点设为和下一个点双联通分量的割点即可。
- 否则我们考虑 $V_1\to V_k$ 的路径，找到一个不在路径上的方点，这个点内部包含的圆点一定至少在一侧不合法。

因此能够构造当且仅当 $G$ 是点双联通分量。

不难证明 $V_i$ 内部连通，否则可以分裂成若干个连通块更优。

那么我们枚举 $V_1,V_k$，最优解就是把路径上的方点删除，然后每个圆点对应一个连通块，这个连通块就是一个 $V_i$。

枚举 $\mathrm{LCA}(V_1,V_k)$，最优路径一定每次走 $\mathrm{siz}$ 最大的子树，那么简单树形 dp 就能求出方案，然后每个点双连通分量跑一边双极定向即可。

时间复杂度 $\mathcal O(n+m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e5+5;
vector <int> G[MAXN],E[MAXN];
int n,m,tot;
int dfn[MAXN],low[MAXN],dcnt,stk[MAXN],tp;
bool ins[MAXN];
void link(int x,int y) { E[x].push_back(y),E[y].push_back(x); }
void tarjan(int u) {
	dfn[u]=low[u]=++dcnt,stk[++tp]=u,ins[u]=true;
	for(int v:G[u]) {
		if(!dfn[v]) {
			tarjan(v),low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]) {
				link(u,++tot);
				for(;ins[v];ins[stk[tp--]]=false) link(tot,stk[tp]);
			}
		} else low[u]=min(low[u],dfn[v]);
	}
}
int siz[MAXN],f[MAXN],ans,rt=0,to[MAXN][2];
void dfs1(int u,int fz) {
	siz[u]=(u<=n);
	vector <int> sn;
	for(int v:E[u]) if(v^fz) dfs1(v,u),siz[u]+=siz[v],sn.push_back(v);
	sort(sn.begin(),sn.end(),[&](int x,int y){ return siz[x]>siz[y]; });
	if(sn.empty()) return f[u]=1,void();
	int h=to[u][0]=sn[0],se=to[u][1]=(sn.size()>1?sn[1]:0),vl;
	if(u<=n) {
		f[u]=max(f[h],siz[u]-siz[h]);
		vl=max({f[h],f[se],n-siz[h]-siz[se]});
	} else {
		f[u]=max(f[h],siz[se]);
		vl=max({f[h],f[se],sn.size()>2?siz[sn[2]]:0,n-siz[u]});
	}
	if(ans>=vl) rt=u,ans=vl;
}
int st[MAXN],q;
bool vis[MAXN];
vector <int> grp[MAXN];
void dfs2(int u,int bl) {
	vis[u]=true;
	if(u<=n) grp[bl].push_back(u);
	for(int v:E[u]) if(!vis[v]) dfs2(v,bl);
}
int fa[MAXN],rk[MAXN];
bool inq[MAXN],del[MAXN];
vector <int> ord,pat,Q[MAXN];
void dfs3(int u) {
	low[u]=dfn[u]=++dcnt,rk[dcnt]=u;
	for(int v:G[u]) if(inq[v]) {
		if(!dfn[v]) fa[v]=u,dfs3(v),low[u]=min(low[u],low[v]);
		else low[u]=min(low[u],dfn[v]);
	}
	Q[fa[u]].push_back(u),Q[rk[low[u]]].push_back(u);
}
void dfs4(int u) {
	ord.push_back(u),vis[u]=true;
	for(int v:Q[u]) if(!vis[v]&&!del[v]) dfs4(v);
}
vector<int> solve(vector<int>&V,int S,int T) {
	dcnt=0,ord.clear(),pat.clear();
	for(int u:V) fa[u]=dfn[u]=low[u]=vis[u]=0,inq[u]=1,Q[u].clear();
	dfs3(S);
	for(int u=T;u;u=fa[u]) pat.push_back(u),del[u]=1;
	reverse(pat.begin(),pat.end());
	for(int u:pat) dfs4(u);
	for(int u:V) inq[u]=del[u]=0;
	return ord;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m,tot=n;
	for(int i=1,u,v;i<=m;++i) cin>>u>>v,G[u].push_back(v),G[v].push_back(u);
	tarjan(1),ans=n+1,dfs1(1,0);
	for(int x=rt;x;x=to[x][0]) st[++q]=x;
	reverse(st+1,st+q+1);
	if(to[rt][1]) for(int x=to[rt][1];x;x=to[x][0]) st[++q]=x;
	for(int i=2;i<q;i+=2) vis[st[i]]=true;
	for(int i=2;i<q;i+=2) for(int u:E[st[i]]) if(!vis[u]) dfs2(u,u);
	vector <int> wys;
	for(int i=2;i<q;i+=2) {
		auto o=solve(E[st[i]],st[i-1],st[i+1]);
		if(wys.size()) wys.pop_back();
		for(int u:o) wys.push_back(u);
	}
	cout<<ans<<" "<<wys.size()<<"\n";
	for(int i:wys) {
		cout<<grp[i].size()<<" ";
		for(int x:grp[i]) cout<<x<<" "; cout<<"\n";
	}
	return 0;
}
```

---


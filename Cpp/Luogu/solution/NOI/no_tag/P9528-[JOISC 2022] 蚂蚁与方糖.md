# [JOISC 2022] 蚂蚁与方糖

## 题目背景

JOISC2022 D3T3

## 题目描述

JOI 君是一个生物学家。他准备对蚂蚁和方糖做一些实验。

JOI 君的实验在一个长度为 $10^9$ 的木条上进行。这根木条被从左往右放置。木条上距离左端点 $x$ 的点被称作坐标为 $x$ 的点。

现在，木条上什么都没有。JOI 君将会进行 $Q$ 次操作。第 $i$ 个操作 $(1 \le i \le Q)$ 由三个整数 $T_i,X_i,A_i$ 描述，表示：

- 若 $T_i=1$，JOI 君在坐标为 $X_i$ 的点处放了 $A_i$ 个蚂蚁。
- 若 $T_i=2$，JOI 君在坐标为 $X_i$ 的点处放了 $A_i$ 块方糖。

由于蚂蚁和方糖都很小，所以可能会有一些蚂蚁和方糖放在同一个点上。JOI 君也可能在同一个点执行多次操作。

这次实验中使用的蚂蚁具有「好奇心强」的萌点。具体地，当 JOI 君拍手时，每个蚂蚁会执行以下操作：

- 如果存在一块方糖与该蚂蚁距离不超过 $L$，它会选择任意一块并吃掉。

可能存在多个蚂蚁同时吃掉一块方糖的情况。

对于每个 $k$ $(1\le k \le Q)$，JOI 君想要知道以下问题的答案。

- 假设 JOI 君在第 $k$ 次操作后拍了一次手，最多有多少块方糖被至少一个蚂蚁吃掉了？

请写一个程序，对于给定的 JOI 君执行的操作和 $L$ 的值，对于所有 $k$ 回答 JOI 君的每个问题。

注意 JOI 君并不会真的拍手。因此蚂蚁的位置不会改变，方糖也不会被吃掉。

## 说明/提示

**【样例解释 #1】**

在这组样例中，所有操作和每个 $k$ 的答案如下：

 1. JOI 君在坐标为 $1$ 的点放了一个蚂蚁。  
    由于没有方糖，对应的答案为 $0$。
 2. JOI 君在坐标为 $2$ 的点放了一块方糖。  
    假设 JOI 君此时拍手，则坐标为 $1$ 的蚂蚁会吃掉坐标为 $2$ 的方糖，所以对应的答案为 $1$。
 3. JOI 君在坐标为 $3$ 的点放了一个蚂蚁。  
    假设 JOI 君此时拍手，则坐标为 $1,3$ 的蚂蚁会同时吃掉坐标为 $2$ 的方糖，所以对应的答案为 $1$。
 4. JOI 君在坐标为 $0$ 的点放了一块方糖。  
    假设 JOI 君此时拍手，则坐标为 $1,3$ 的蚂蚁可以分别吃掉坐标为 $0,2$ 的方糖，所以对应的答案为 $2$。

这组样例满足子任务 $1,2,4$ 的限制。

**【样例解释 #2】**

这组样例满足子任务 $1,2,4$ 的限制。

**【样例解释 #3】**

这组样例满足子任务 $1,4$ 的限制。

**【样例解释 #4】**

这组样例满足子任务 $1,3,4$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $1 \le Q \le 500\,000$。
- $1 \le L \le 10^9$。
- $T_i \in \{1,2\}$。
- $0 \le X_i \le 10^9$ $(1 \le i \le Q)$。
- $1 \le A_i \le 10^9$ $(1 \le i \le Q)$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$Q \le 3\,000$|$6$|
|$2$|$L=1$，$X_i \le Q-1$，$X_i+T_i$ 是偶数 $(1\le i\le Q)$|$16$|
|$3$|$Q$ 是偶数，$T_i = 1$ $(1 \le i \le Q/2)$，$T_i = 2$ $(Q/2+1 \le i \le Q)$|$26$|
|$4$|无附加限制|$52$|

## 样例 #1

### 输入

```
4 1
1 1 1
2 2 1
1 3 1
2 0 1```

### 输出

```
0
1
1
2```

## 样例 #2

### 输入

```
20 1
2 16 778913911
1 7 558407445
1 1 589762439
1 17 74646747
1 1 149104909
1 15 956697952
2 6 389372991
2 4 867453845
1 15 157353445
1 9 846177695
1 7 747107163
2 10 525670462
2 16 478912944
2 6 301733761
2 12 132966485
1 1 748012313
2 10 830922632
1 19 969484637
1 13 370330582
1 1 464798040```

### 输出

```
0
0
0
74646747
74646747
778913911
1168286902
1168286902
1168286902
1168286902
1168286902
1693957364
2103741597
2405475358
2405475358
2405475358
2725982591
2725982591
2858949076
2858949076```

## 样例 #3

### 输入

```
20 6
2 27 12
2 9 11
1 36 10
2 39 4
2 14 9
2 33 7
2 38 20
2 0 20
2 25 16
1 14 3
1 13 19
2 6 4
2 15 6
2 33 4
1 12 11
1 44 1
2 17 14
2 12 19
1 48 18
2 30 16```

### 输出

```
0
0
0
4
4
10
10
10
10
13
30
30
32
32
40
41
44
44
44
44```

## 样例 #4

### 输入

```
20 268886972
1 984472666 733463744
1 478477245 94817772
1 242536956 330762563
1 65794782 319137646
1 320548477 937296140
1 815011370 938193848
1 565184190 917533785
1 245417414 534089975
1 529908772 977043962
1 603891865 700935654
2 167042244 479827216
2 173921297 798343455
2 916159596 810126726
2 999299355 465535307
2 965968070 501768990
2 936073643 174976034
2 832859952 778072072
2 955489596 704853861
2 246733786 382428992
2 227669861 390905006```

### 输出

```
0
0
0
0
0
0
0
0
0
0
479827216
1278170671
2088297397
2553832704
2949828263
2949828263
3727900335
3727900335
4110329327
4501234333```

# 题解

## 作者：tzc_wk (赞：18)

首先显然可以 $n^2\log n$ 地贪心。但是没法优化。

注意到这个模型等价于二分图最大匹配，考虑特殊二分图模型的重要工具：霍尔定理，具体来说一张二分图假设左部点集合为 $A$，右部点集合为 $B$，那么最大匹配就是 $|A|-\max\limits_{S\subseteq A}\{|S|-|\text{Nb}(S)|\}$。应用到此题上就是红点个数 $-\max\limits_{\{[l_i,r_i]\}\text{两两不相交}}\sum\limits_{i=1}^k\text{sumred}(l_i,r_i)-\text{sumblue}(l_i-L,r_i+L)$。其中要求相邻区间间隔 $>2L$，否则把间隔 $\le 2L$ 的并起来肯定是更优的。

考虑如何求这个东西，记 $R_i$ 和 $B_i$ 为红点个数的前缀和，然后记 $p_i=-R_{i-1}+B_{l_i-L-1},q_i=R_i-B_{i+L}$，那么这个问题等价于间隔选 $p,q,p,q$ 的最大权值和，线段树维护一下，记 $f_{i,0/1,0/1}$ 表示线段树 $i$ 节点，以 $p/q$ 开始，以 $p/q$ 结束的最大权值和，合并可以 $O(1)$。

考虑修改的贡献：

- 加入红点等价于 $[x+1,\infty)$ 的 $p$ 减去 $v$，$[x,\infty)$ 的 $p$ 加上 $v$，注意到区间加好像有点难维护，但是对于一个区间的 $p$ 加 $v$，$q$ 减 $v$，对于固定的 $x,i,j$，$f_{x,i,j}$ 的最优策略是不变的，因为它会加多少个 $p$ 已经在 $i,j$ 中有所体现。因此可以直接打 tag，这样加入红点的贡献等价于区间加 + 单点修改。
- 加入蓝点等价于 $[x+L+1,\infty)$ 的 $p$ 加上 $v$，$[x-L,\infty)$ 的 $p$ 减去 $v$，还是将修改拆成一段 $p$ 加 $q$ 减，不过这次剩的是区间加。发现一个性质是这个区间长度 $\le 2L$，根据间隔 $>2L$ 的性质可以对每一类 $f_{i,0/1,0/1}$ 算出它里面究竟有多少个 $q$，这样标记就是可加的了。

时间复杂度 $n\log n$。

---

## 作者：happybob (赞：8)

题意：

有一个左右侧各 $10^9$ 个点的二分图，左侧每个点 $i$ 向右侧 $[i-L,i+L]$ 范围连边。$q$ 次操作，每次将左侧或右侧某个点的权值加上非负数 $x$，然后询问这张图的最大匹配。允许离线。

$1 \leq q \leq 5 \times 10^5$，$4$ 秒，$1$ GB。

解法：

首先我们可以每次询问从前往后遍历左侧点权非 $0$ 的点并贪心匹配 $[i-L,i+L]$ 中所有点，这样总复杂度 $O(q^2 \log q)$，优化前景不是很好。

考虑二分图最大匹配的另一个方向，霍尔定理。霍尔定理推论告诉我们，设左侧和右侧点集为 $A,B$，其点权分别为 $a_i,b_i$。最大匹配等于 $(\sum \limits_{i\in A} a_i) - (\max \limits_{S \subseteq A} \sum \limits_{i \in S} a_i - \sum \limits_{j \in N(S)} b_j)$，$N(S)$ 表示 $S$ 的邻域。

左侧点权值和是容易维护的，我们只需要维护后面的式子即可。我们将 $S$ 写为若干左端点排序后的不交区间形式，即 $[l_1,r_1]\cup[l_2,r_2]\cup\cdots\cup[l_k,r_k]$。首先可以发现存在最优解使得对于任意 $1 \leq i < k$，都有 $l_{i+1} - r_i > 2L$，否则我们可以合并 $[l_i,r_i]$ 与 $[l_{i+1},r_{i+1}]$ 变为 $[l_i,r_{i+1}]$，显然邻域大小不增加，所以不劣。

接着可以写出区间对应的贡献形式，记 $SA_i$ 表示左侧 $[1,i]$ 点权和，$SB_i$ 同理。则区间对应贡献为 $\sum \limits_{i=1}^k SA_{r_i}-SA_{l_i-1} - SB_{r_i+L} + SB_{l_i-L-1}$。

对于每个点 $i$，其作为左端点贡献为 $p_i=SB_{i-L-1}-SA_{i-1}$，作为右端点贡献为 $q_i=SA_{i}-SB_{i+L}$。问题变为交替选左端点与右端点最大化贡献和。这个信息是可以合并的，线段树上维护 $f_{0/1,0/1}$ 表示最靠左与最靠右选的被选点是作为 $p$ 或 $q$ 时的答案。

考虑修改，第一部分是，左侧点 $a$ 点权加 $x$ 对应的是 $p$ 的 $(a,n]$ 减 $x$ 与 $q$ 的 $[a,n]$ 加 $x$。也就是 $(a,n]$ 中 $p$ 减 $x$，$q$ 加 $x$，$a$ 处 $q$ 加 $x$。单点加是容易的，区间 $p$ 减 $x$，$q$ 加 $x$，对于那些选的左右端点数相同的不会产生贡献，即 $f_{0,1}$ 与 $f_{1,0}$，而 $f_{0,0}$ 与 $f_{1,1}$ 的最优解不会改变，只是将答案加上某个数。所以实际上这部分只需要维护 $f_{*,*}$ 的区间加。

另一方面，右侧点 $a$ 点权加 $x$，可以发现有一段后缀仍然是 $p$ 加 $x$，$q$ 减 $x$ 的形式，容易维护。中间有一段区间是整体 $q$ 加 $x$。但可以发现区间长度不超过 $2L$，所以 $f_{1,0}$ 是不需要考虑的，而 $f_{0,0},f_{0,1},f_{1,1}$ 对应选了几个 $q$ 是容易求出的。我们仍然只需要维护区间加。

综上，维护区间 $f_{*,*}$ 加可以支持所有操作，复杂度 $O(q \log q)$，注意先离线离散化一下。

代码：


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <tuple>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <array>
using namespace std;

using ll = long long;

constexpr int N = 3e6 + 5;

int q, L;

array<int, N> t, x, a;
vector<int> pos;
ll suma = 0;

class SegmentTree
{
public:
	struct Node
	{
		int l, r;
		ll LL, LR, RL, RR;
		ll tag1, tag2, tag3; // LL,RR,LR
		friend Node operator+(const Node a, const Node b)
		{
			if (a.l == -1) return b;
			if (b.l == -1) return a;
			Node c;
			c.l = a.l, c.r = b.r;
			c.tag1 = c.tag2 = c.tag3 = 0ll;
			c.LL = max({ a.LL, b.LL, a.LL + b.RL, a.LR + b.LL });
			c.LR = max({ a.LR, b.LR, a.LL + b.RR, a.LR + b.LR } );
			c.RL = max({ a.RL, b.RL, a.RL + b.RL, a.RR + b.LL } );
			c.RR = max({ a.RR, b.RR, a.RL + b.RR, a.RR + b.LR } );
			return c;
		}
	};
	array<Node, N << 2> tr;
	inline void pushtag1(int u, ll x)
	{
		tr[u].tag1 += x, tr[u].LL += x;
	}
	inline void pushtag2(int u, ll x)
	{
		tr[u].tag2 += x, tr[u].RR += x;
	}
	inline void pushtag3(int u, ll x)
	{
		tr[u].tag3 += x, tr[u].LR += x;
	}
	inline void pushdown(int u)
	{
		if (tr[u].tag1)
		{
			pushtag1(u << 1, tr[u].tag1);
			pushtag1(u << 1 | 1, tr[u].tag1);
			tr[u].tag1 = 0ll;
		}
		if (tr[u].tag2)
		{
			pushtag2(u << 1, tr[u].tag2);
			pushtag2(u << 1 | 1, tr[u].tag2);
			tr[u].tag2 = 0ll;
		}
		if (tr[u].tag3)
		{
			pushtag3(u << 1, tr[u].tag3);
			pushtag3(u << 1 | 1, tr[u].tag3);
			tr[u].tag3 = 0ll;
		}
	}
	void build(int u, int l, int r)
	{
		tr[u] = { l, r, 0ll, 0ll, (ll)-4e18, 0ll, 0ll, 0ll, 0ll};
		if (l == r) return;
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
	}
	inline void update(int u, int l, int r, tuple<ll, ll, ll> t)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			pushtag1(u, get<0>(t));
			pushtag2(u, get<1>(t));
			pushtag3(u, get<2>(t));
			return;
		}
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid) update(u << 1, l, r, t);
		if (r > mid) update(u << 1 | 1, l, r, t);
		tr[u] = tr[u << 1] + tr[u << 1 | 1];
	}
}sgt;

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> q >> L;
	for (int i = 1; i <= q; i++)
	{
		cin >> t[i] >> x[i] >> a[i];
		pos.emplace_back(x[i]);
		pos.emplace_back(x[i] + 1);
		pos.emplace_back(x[i] + L + 1);
		pos.emplace_back(x[i] - L);
		pos.emplace_back(x[i] + L);
	}
	sort(pos.begin(), pos.end());
	pos.erase(unique(pos.begin(), pos.end()), pos.end());
	auto get = [&](int x)
		{
			return lower_bound(pos.begin(), pos.end(), x) - pos.begin() + 1;
		};
	sgt.build(1, 1, pos.size());
	int lim = pos.size();
	for (int i = 1; i <= q; i++)
	{
		if (t[i] == 1)
		{
			int pos = get(x[i]), pos2 = get(x[i] + 1);
			sgt.update(1, pos, pos, make_tuple(0, a[i], a[i]));
			sgt.update(1, pos2, lim, make_tuple(-a[i], a[i], 0));
			suma += a[i];
		}
		else
		{
			int pos = get(x[i] + L + 1), pos2 = get(x[i] - L), pos3 = get(x[i] + L);
			sgt.update(1, pos, lim, make_tuple(a[i], -a[i], 0));
			sgt.update(1, pos2, pos3, make_tuple(0, -a[i], -a[i]));
		}
		cout << suma - max(0ll, sgt.tr[1].LR) << "\n";
	}
	return 0;
}
```

---

## 作者：littlez_meow (赞：8)

[题目指路](https://www.luogu.com.cn/problem/P9528)。

### 思路

对每一只蚂蚁和每一块建点，一只蚂蚁跟能吃到的方糖连边，我们得到了一张二分图。多只蚂蚁吃一块方糖显然不优，也就是说，原问题可以转化成：在二分图中选尽可能多的边（吃与被吃的关系），满足任意两边没有公共顶点（一只蚂蚁只能吃一块方糖，一块方糖被一只蚂蚁吃最优）。即二分图最大匹配。

对于二分图匹配问题，我们有如下定理：

**【霍尔定理】** 对于一个二分图，记左部点为 $A$，则该二分图最大匹配等于 $|A|-\max\limits_{S\subseteq A}\{|S|-|\operatorname{Nb}(S)|\}$，其中 $\operatorname{Nb}(S)$ 为与 $S$ 有边相连的点集，即 $|S|$ 的邻域。

（好吧，上式其实是霍尔定理的推论。霍尔定理本身是描述是否存在最大匹配的不等式。但这个推论显然更有用，且也可导出本身。在此姑且就叫它霍尔定理。）

首先是一个很显然的性质：对于坐标相同的蚂蚁，要么全在 $S$ 中，要么全不在。因为如果不全在，相比于全在，$|\operatorname{Nb}(S)|$ 是相同的，但 $|S|$ 更小，显然取不到最大值。

现在离线一下，离散化所有蚂蚁出现的位置，记一共有 $n$ 个，从小到大坐标为 $x_1\sim x_n$，第 $i$ 个位置的蚂蚁个数为 $a_i$（区分输入的 $A_i$）。

暂时考虑没有修改的情况。

现在，上述 $S$ 肯定为 $\{1,2,\cdots,n\}$ 的一个子集。依次代回原式，左部点个数为 $\sum\limits_{i=1}^n a_i$，枚举 $S$，设第 $i$ 个坐标的邻域为 $\operatorname{Nb}(i)$，有答案为：

$$\sum\limits_{i=1}^n a_i-\max\limits_{S\subseteq\{1,\cdots,n\}}\{\sum\limits_{i\in S} a_i-|\bigcup\limits_{i\in S}\operatorname{Nb}(i)|\}$$

问题转化为求并集大小。容易想到用总大小减相交多算的大小。

设 $i\in S$，$f(i)$ 为 $S$ 中大于 $i$ 的最小数，不存在则 $\operatorname{Nb}(f(i))=\varnothing$。那么，多算的大小为 $\sum\limits_{i\in S}|\operatorname{Nb}(i)\cap\operatorname{Nb}(f(i))|$。这是因为邻域在数轴上对应的区间是单调右移的，去掉相邻两个的交集可以保证每个点都在右端点最靠右的邻域区间中计算。

答案可写作：

$$\sum\limits_{i=1}^n a_i-\max\limits_{S\subseteq\{1,\cdots,n\}}\{\sum\limits_{i\in S} a_i-\sum\limits_{i\in S}|\operatorname{Nb}(i)|+\sum\limits_{i\in S}|\operatorname{Nb}(i)\cap\operatorname{Nb}(f(i))|\}$$

好像还是没有任何计算的方法，似乎只能进一步研究 $S$ 的性质了。

打表发现最优的 $S$ 似乎都是一段一段的区间？让我们尝试严谨化结论：若 $i,j\in S,x_j-x_i\le 2L$，则 $\forall i\le k\le j,k\in S$。既然 $i,j$ 距离不超过 $2L$，$\operatorname{Nb}(i)\cup\operatorname{Nb}(j)$ 在数轴上对应的区间肯定覆盖了整个 $[x_i-L,x_j+L]$。不选 $[i,j]$ 中的点相比于选，$|\operatorname{Nb}(S)|$ 不变，$|S|$ 更小，不是最大值。由此立即得到，$S$ 是由若干不交的区间间隔大于 $2L$ 的区间构成的。这是因为间隔若小于等于 $2L$，根据上面的论证，这两个区间可以合成一个大区间。

这还可以说明，若 $f(i)\neq i+1$，则 $\operatorname{Nb}(i)\cap\operatorname{Nb}(f(i))=\varnothing$，因为二者距离大于 $2L$，而 $\operatorname{Nb}(i)$ 最多扩展 $L$，两边加起来是 $2L$，始终连不到一起。

把 $S$ 从数的集合改成区间的集合。答案可以进一步写成：

$$\sum\limits_{i=1}^m a_i-\max\limits_{S}\{\sum\limits_{[l,r]\in S}\sum\limits_{i\in[l,r]}(a_i-\operatorname{Nb}(i))+\sum\limits_{[l,r]\in S}\sum\limits_{i\in[l,r-1]}|\operatorname{Nb}(i)\cap\operatorname{Nb}(i+1)|\}$$

不能再化简了。研究如何计算答案并应用修改。

修改的话线段树肯定没跑了。想想应该维护什么。首先，根据之前单点修最大子段和的经验，对于线段树上一个点，设该区间中点为 $m$，我们肯定要维护左/右端点是/否在 $S$ 中的 $\max\limits_S$ 那个式子的值。答案是 $a_i$ 之和减根节点四个值里最大的。为了合并左右儿子，我们还要维护 $|\operatorname{Nb}(m)\cap\operatorname{Nb}(m+1)|$。计算就搞定了。

然后是修改。分开研究，先研究加蚂蚁。这是简单的，单点加就行。

然后是加方糖。对位置 $X$ 加 $A$ 块方糖，影响到的邻域是 $[X-L,X+L]$ 中的点。只要这个区间包含了 $S$ 中区间，它就会把答案区间加 $A$。以及，$|\operatorname{Nb}(m)\cap\operatorname{Nb}(m+1)|$ 也要加 $A$。

注意到包含区间个数要么是 $0$，要么是 $1$，因此区间不可能加多个 $A$。

时间复杂度 $O(Q\log Q)$，注意修改的正负号。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
using namespace std;
const int MAXQ=5e5+1;
namespace Segt{
	#define mid ((l+r)>>1)
	#define L (now<<1)
	#define R (now<<1|1)
	#define lc L,l,mid
	#define rc R,mid+1,r
	ll cap[MAXQ<<2],tag[MAXQ<<2],ans[MAXQ<<2][2][2];
	inline void upd(int now){
		ans[now][0][0]=max({ans[L][0][0]+ans[R][0][0],ans[L][0][0]+ans[R][1][0],ans[L][0][1]+ans[R][0][0],ans[L][0][1]+ans[R][1][0]+cap[now]});
		ans[now][0][1]=max({ans[L][0][0]+ans[R][0][1],ans[L][0][1]+ans[R][0][1],ans[L][0][0]+ans[R][1][1],ans[L][0][1]+ans[R][1][1]+cap[now]});
		ans[now][1][0]=max({ans[L][1][0]+ans[R][0][0],ans[L][1][0]+ans[R][1][0],ans[L][1][1]+ans[R][0][0],ans[L][1][1]+ans[R][1][0]+cap[now]});
		ans[now][1][1]=max({ans[L][1][0]+ans[R][0][1],ans[L][1][0]+ans[R][1][1],ans[L][1][1]+ans[R][0][1],ans[L][1][1]+ans[R][1][1]+cap[now]});
		return;
	}
	inline void add(int now,ll x){
		cap[now]+=x;
		tag[now]+=x;
		F(i,0,1) F(j,0,1) ans[now][i][j]-=x;
		ans[now][0][0]=max(ans[now][0][0],0ll);
		return;
	} 
	inline void psd(int now){
		if(!tag[now]) return;
		add(L,tag[now]);
		add(R,tag[now]);
		tag[now]=0;
		return;
	}
	void modiant(int now,int l,int r,int pos,ll v){
		if(l==r){
			ans[now][1][1]+=v;
			return;
		}
		psd(now);
		if(pos<=mid) modiant(lc,pos,v);
		else modiant(rc,pos,v);
		upd(now);
		return;
	}
	void modisugar(int now,int l,int r,int ql,int qr,ll v){
		if(ql>r||qr<l) return;
		if(ql<=l&&r<=qr){
			add(now,v);
			return;
		}
		psd(now);
		if(ql<=mid) modisugar(lc,ql,qr,v);
		if(qr>mid) modisugar(rc,ql,qr,v);
		(ql<=mid&&mid<qr)&&(cap[now]+=v);
		upd(now);
		return;
	}
	inline ll res(){
		return max({ans[1][0][0],ans[1][0][1],ans[1][1][0],ans[1][1][1]});
	}
}
int q,l;
struct Oper{
	int t,x,a;
}op[MAXQ];
int ant[MAXQ],m;
ll sum;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>q>>l;
	F(i,1,q){
		Oper&qwq(op[i]);
		cin>>qwq.t>>qwq.x>>qwq.a;
		qwq.t==1&&(ant[++m]=qwq.x);
	}
	sort(ant+1,ant+m+1);
	m=unique(ant+1,ant+m+1)-ant-1;
	F(i,1,q){
		Oper&qwq(op[i]);
		if(qwq.t==1){
			sum+=qwq.a;
			int t=lower_bound(ant+1,ant+m+1,qwq.x)-ant;
			Segt::modiant(1,1,m,t,qwq.a);
		}else{
			int ql=lower_bound(ant+1,ant+m+1,qwq.x-l)-ant,qr=upper_bound(ant+1,ant+m+1,qwq.x+l)-ant-1;
			Segt::modisugar(1,1,m,ql,qr,qwq.a);
		}
		cout<<sum-Segt::res()<<"\n";
	}
	return 0;
}
```

---

## 作者：TTpandaS (赞：7)

方糖并不想被吃掉，所以（迟到地）给大家送来方糖社的新春祝福：

![](https://cdn.luogu.com.cn/upload/image_hosting/rohin3r0.png)

求最大匹配，利用扩展霍尔定理：一个任意二分图 $(V1,V2,E)$，最大匹配为 $|V1|-\max_{S \in V1}(|S|-|N(S)|)$。$|V1|$ 即为 $\sum [T_i=1]A_i$，$S$ 即为一些区间的蚂蚁的并，设为 $\cup [l_i,r_i]$，那么 $N(S)$ 即为这些区间向两边扩展 $L$ 的区间的并，设为 $\cup [l_i-L,r_i+L]$。两个相邻区间间隔大于 $2L$，否则将两个区间合并为一个区间更优。

$|S|$ 和 $|N(S)|$ 对应蚂蚁和方糖的数量，设 $a_i$ 表示位置 $i$ 的蚂蚁数量，$s_i$ 为位置 $i$ 的方糖数量，答案即为 

$$\sum \sum_{j=l_i}^{r_i}a_j-\sum_{j=l_i-L}^{r_i+L}s_j=\sum \sum_{j=l_i}^{r_i}(a_j-\sum_{k=j-L}^{j+L}s_k)+\sum_{j=l_i}^{r_i-1}\sum_{k=j-L+1}^{j+L}s_k$$

令 $j \in [l_i,r_i]$ 表示 $j$ 被选择，设 $dp_{l,r,0/1,0/1}$ 表示区间 $[l,r]$ 左端点和右端点是否被选择时的最大值。可以用线段树进行维护，同时为了合并左右儿子，对于每个区间 $(l,r,mid)$ 还需要维护  

$$\sum_{k=mid-L+1}^{mid+L}s_k $$

的值。修改时注意 $dp_{l,r,0,0} \geq 0$。

加入蚂蚁时，对 $X_i$ 位置单点加即可。

加入方糖时，会影响 $[X_i-L,X_i+L]$ 这个区间的 dp 值。具体地，如果区间 $(l,r,mid) \subseteq [X_i-L,X_i+L]$，那么 dp 值均会减少，而 

$$\sum_{k=mid-L+1}^{mid+L}s_k $$

的值会增加。此外，如果 $X_i-L\leq mid < X_i+L$，那么该区间的

$$\sum_{k=mid-L+1}^{mid+L}s_k $$

值也会增加。

实现需要离散化。


```cpp
#include<bits/stdc++.h>
#define int long long
#define lc p<<1
#define rc p<<1|1
using namespace std;
const int N=5e5+5,inf=0x0d0007210d000721;
struct tree{
	int l,r,val,tag;
	int dp[2][2];
}t[N*4];
void pushup(int p){
	for(int x=0;x<=1;x++){
		for(int y=0;y<=1;y++){
			t[p].dp[x][y]=-inf;
		}
	}
	for(int x1=0;x1<=1;x1++){
		for(int y1=0;y1<=1;y1++){
			for(int x2=0;x2<=1;x2++){
				for(int y2=0;y2<=1;y2++){
					t[p].dp[x1][y2]=max(t[p].dp[x1][y2],t[lc].dp[x1][y1]+t[rc].dp[x2][y2]+(y1&x2)*t[p].val);
				}
			}
		}
	}
}
void add(int p,int val){
	t[p].val+=val;
	t[p].tag+=val;
	for(int x=0;x<=1;x++){
		for(int y=0;y<=1;y++){
			t[p].dp[x][y]-=val;
		}
	}
	t[p].dp[0][0]=max(t[p].dp[0][0],0ll);
}
void pushdown(int p){
	if(t[p].tag){
		add(lc,t[p].tag);
		add(rc,t[p].tag);
		t[p].tag=0;
	}
}
void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l==r){
		return;
	}
	int mid=(t[p].l+t[p].r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
}
void addg(int p,int x,int y){
	if(t[p].l==t[p].r){
		t[p].dp[1][1]+=y;
		return;
	}
	pushdown(p);
	int mid=(t[p].l+t[p].r)>>1;
	if(x<=mid){
		addg(lc,x,y);
	}
	else{
		addg(rc,x,y);
	}
	pushup(p);
}
void addf(int p,int l,int r,int x){
	if(l>r){
		return;
	}
	if(l<=t[p].l&&t[p].r<=r){
		add(p,x);
		return;
	}
	pushdown(p);
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid){
		addf(lc,l,r,x);
	}
	if(mid+1<=r){
		addf(rc,l,r,x);
	}
	if(l<=mid&&mid+1<=r){
		t[p].val+=x;
	}
	pushup(p);
}
int Q,L;
int lsh[N],lshcnt;
struct opt{
	int t,x,a;
}o[N];
int ans;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>Q>>L;
	lshcnt=1;
	for(int i=1;i<=Q;i++){
		cin>>o[i].t>>o[i].x>>o[i].a;
		if(o[i].t==1){
			lsh[++lshcnt]=o[i].x;
		}
	}
	sort(lsh+1,lsh+lshcnt+1);
	lshcnt=unique(lsh+1,lsh+lshcnt+1)-lsh-1;
	build(1,1,lshcnt);
	for(int i=1;i<=Q;i++){
		if(o[i].t==1){
			ans+=o[i].a;
			int pos=lower_bound(lsh+1,lsh+lshcnt+1,o[i].x)-lsh;
			addg(1,pos,o[i].a);
		}
		else{
			int posl=lower_bound(lsh+1,lsh+lshcnt+1,o[i].x-L)-lsh,posr=upper_bound(lsh+1,lsh+lshcnt+1,o[i].x+L)-lsh-1;
			addf(1,posl,posr,o[i].a);
		}
		cout<<ans-max(max(t[1].dp[0][0],t[1].dp[0][1]),max(t[1].dp[1][0],t[1].dp[1][1]))<<'\n';
	}
	return 0;
}
```

---

## 作者：Raisetsu41 (赞：6)

考虑将这个问题转化一下，变成最大独立集问题，意味着选择的相邻的红、蓝点之间的距离应该大于 $L$，于是先选出所有红点，然后排除不能选的蓝点，剩下的是独立集。于是有两个重要的**观察**。  

- 每个位置上的点要么都选，要么都不选，因为选了全部一定比只选部分更优，所以只用对位置考虑。  

- 选择的相邻的两个红点之间的距离应该大于 $2L$，如果小于等于了 $2L$，那么可以将中间所有的红点都选上，因为不可选的蓝点的集合没变，而能选的红点变多了，所以这样更优秀。

于是这个问题被划分成了很多个独立的段，每个段以红点开头，以红点结尾，记为 $[l, r]$，计算这一段的贡献，记每个位置上红/蓝点个数为 $R_i, B_i$。  
先选出所有红点，为

$$
\begin{aligned}
  \sum_{i = l}^{r} R_i
\end{aligned}
$$

去掉 $R_i$ 邻域上的蓝点，为

$$
\begin{aligned}
  \sum_{i = l - L}^{r + L} B_i
\end{aligned}
$$

这个是以区间和的形式出现的，所以拆一下前缀，并整理得到

$$
\begin{aligned}
  &\left( \sum_{i = 0}^{r} R_i - \sum_{i = 0}^{l - 1} R_i \right) - 
  \left( \sum_{i = 0}^{r + L} B_i - \sum_{i = 0}^{l - L - 1} B_i \right) \\
  =& \left( \sum_{i = 0}^{r} R_i -  \sum_{i = 0}^{r + L} B_i\right) + 
  \left(\sum_{i = 0}^{l - L - 1} B_i - \sum_{i = 0}^{l - 1} R_i\right)
\end{aligned}
$$

这个形式很优美，因为只用左右端点的信息就可以刻画整个贡献，分别可以记为 $f_r, g_l$。  
问题就变成了交替选择 $f_r, g_l$ 使得总和最大，这个是个经典问题，可以 `ddp` 解决，记录每个区间开头与结尾的类型就行。  
于是来解决带修改的版本。  

- 加入 $R_i$
  - 对于 $j \ge i, f_j := f_j + x$
  - 对于 $j \ge i + 1, g_i := g_i + x$

- 加入 $B_i$
  - 对于 $j \ge i + L, f_j := f_j - x$
  - 对于 $j \ge i - L - 1, g_j := g_j - x$

发现形式不太好，拆一下操作

- 加入 $R_i$
  - 对于 $j \ge i + 1, f_j := f_j + x, g_j := g_j + x$
  - 对于 $j \in [i, i + 1), f_j := f_j + x$
  
- 加入 $B_i$
  - 对于 $j \ge i + L, f_j := f_j - x, g_j := g_j - x$
  - 对于 $j \in [i - L - 1, i + L), g_j := g_j - x$

第一个操作变得非常好做，第二个操作有个区间修改，但是注意到一件事 $j \in [i - L - 1, i + L)$，这个区间长度小于等于 $2L$，说明了这个区间里面只有一个 $g_j$，于是也就是一个单点修改。  

然后怎么区间修改呢？如果当前区间选择的 $R$ 和 $B$ 的数目相同，那么整个区间的答案是不变的，并且注意到 $R$，$B$ 在交替出现，所以这两者的个数差在 $[0, 1]$ 中，如何判断呢，其实之前 `ddp` 里面记录的 $0/1$ 状态已经指明了个数差。  

更具体地给出状态表示 $(l, r)$ 二元组表示当前的状态以 $l \in [0, 1]$ 开头，$r \in [0, 1]$ 结尾。而对于上面讨论的是否存在一个选中的点位于修改的 $[i - L - 1, i + L)$ 中，可以对所有的长度小于等于 $2L$ 的区间记录其中存在的 $g_l$ 的个数。  

其实麻烦了，有没有种可能呢，就是说拆开维护的常数其实不大，并且非常好写，写法是用第二种情况去包含第一种情况。

这题给份代码是很有必要的。[submission](https://loj.ac/s/1894489)

---

## 作者：zac2010 (赞：5)

## Part1：转化

* 转化为单蚂蚁和单方糖的二分图最大匹配

* 考虑霍尔定理经典推论，$|V1|-\max_{S\in V1}(|S|-|N(S)|)$，其中 $N(S)$ 表示与 $S$ 节点有边的点集。

* 位置 $x$ 的蚂蚁能匹配的方糖区间为 $[x-L,x+L]$

* 一个直接的思路是 $|N(S)|=\sum_{x\in S}|N(x)|$，但是 $N(x)$ 之间可能有交，导致会算重。

* 为了去除重复贡献点，我们要把有交的区间并到一起，假设将每堆并到一起的蚂蚁记为 $[l_i,r_i]$。根据定义，显然排序后有 $l_{i+1}-r_{i}>2L$

* 记 $i$ 位置的蚂蚁、方糖数分别为 $a_i,b_i$，则贡献式为：
  $$
  \sum_{i}(\sum_{j\in[l_i,r_i]}a_j-\sum_{j\in[l_i-L,r_i+L]}b_i)
  $$

## Part2：如何维护

>  **带修**且与**若干区间贡献和**相关的东西，可以考虑用线段树来维护

* 我们将对每个线段树上的区间维护，$f_{0/1,0/1}$，表示左端点不选/选，右端点不选/选。

* 对蚂蚁的修改是简单的，对应的是线段树上的单点修。

* 对方糖的修改，注意到只会对一些区间产生 $A$ 的贡献，所以直接做就行了。

  具体的，我们按照上述贡献式，把所有和 $[X-L,X+L]$ 有交的线段树区间的 $\text{DP}$ 值都减去 $A$。但是这样在 Pushup 上来的时候会重复减，所以要在重复统计的位置加上 $A$。

特别的，我们并不需要在线段树中确保 $[l_i,r_i]$ 两两之间距离 $>2L$，因为这样必定是不优的。

## Part3：代码

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for (int i = (a); i <= (b); ++i)
#define FR(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
typedef long long ll;
const int N = 5e5 + 10;
const ll INFLL = 1e18;
int Q, L, len, x[N];
array<int, 3> qry[N];
template<typename T>
void ChkMax(T &x, T y) {
	if (y > x) x = y; 
}
struct SGT {
	struct Node {
		ll w, lazy, f[2][2];
		void tag(ll v) {
			w += v, lazy += v;
			FL(i, 0, 1) FL(j, 0, 1) {
				f[i][j] -= v;
			}
			ChkMax(f[0][0], 0ll);
		}
	} t[N << 2];
	void PushUp(int p) {
		const Node &a = t[p << 1];
		const Node &b = t[p << 1 | 1];
		FL(i, 0, 1) FL(j, 0, 1) {
			t[p].f[i][j] = -INFLL;
		}
		FL(l1, 0, 1) FL(r1, 0, 1) {
			FL(l2, 0, 1) FL(r2, 0, 1) {
				ChkMax(t[p].f[l1][r2], a.f[l1][r1] + b.f[l2][r2] + (l2 & r1) * t[p].w);
			}
		}
	}
	void PushDown(int p) {
		t[p << 1].tag(t[p].lazy);
		t[p << 1 | 1].tag(t[p].lazy);
		t[p].lazy = 0;
	}
	void UpdAnt(int p, int l, int r, int x, int v) {
		if (l == r) {
			t[p].f[1][1] += v;
			return;
		}
		PushDown(p);
		int mid = (l + r) >> 1;
		if (x <= mid) {
			UpdAnt(p << 1, l, mid, x, v);
		} else {
			UpdAnt(p << 1 | 1, mid + 1, r, x, v); 
		}
		PushUp(p);
	} 
	void UpdSug(int p, int l, int r, int L, int R, int v) {
		if (L > R) return;
		if (L <= l && r <= R) {
			return t[p].tag(v);
		}
		PushDown(p);
		int mid = (l + r) >> 1;
		if (R <= mid) {
			UpdSug(p << 1, l, mid, L, R, v);
		} else if (mid < L) {
			UpdSug(p << 1 | 1, mid + 1, r, L, R, v);
		} else {
			UpdSug(p << 1, l, mid, L, R, v);
			UpdSug(p << 1 | 1, mid + 1, r, L, R, v);
			t[p].w += v;
		}
		PushUp(p);
	}
	ll Query() {
		ll ans = 0;
		FL(i, 0, 1) FL(j, 0, 1) {
			ans = max(ans, t[1].f[i][j]);
		}
		return ans;
	}
} sgt;
int main() {
	scanf("%d %d", &Q, &L);
	FL(i, 1, Q) {
		auto &[typ, X, A] = qry[i];
		scanf("%d %d %d", &typ, &X, &A);
		if (typ == 1) {
			x[++len] = X;
		}
	}
	sort(x + 1, x + len + 1);
	len = unique(x + 1, x + len + 1) - x - 1;

	ll S = 0;
	FL(i, 1, Q) {
		auto &[typ, X, A] = qry[i];
		if (typ == 1) {
			X = lower_bound(x + 1, x + len + 1, X) - x;
			sgt.UpdAnt(1, 1, len, X, A);
			S += A;
		} else {
			int l = lower_bound(x + 1, x + len + 1, X - L) - x;
			int r = upper_bound(x + 1, x + len + 1, X + L) - x - 1;
			sgt.UpdSug(1, 1, len, l, r, A);
		}
		printf("%lld\n", S - sgt.Query());
	}
	return 0;
}
```

---

## 作者：UKE_Automation (赞：4)

### P9528 [JOISC 2022] 蚂蚁与方糖

[$\text{Link }$](https://www.luogu.com.cn/problem/P9528)

首先这道题就是让蚂蚁去找方糖，求最大匹配数。不难想到建立一个二分图最大匹配模型，左边是蚂蚁，右边是方糖。然后想到有关二分图匹配的 Hall 定理：对于二分图 $(A,B,E)$，其最大匹配数是 $|A|-\max\limits_{S \subseteq A}(|S|-|N(S)|)$。$|A|$ 是好求的，就是所有蚂蚁的 $A_i$ 之和。现在难点在于求后面这个式子。

首先，同一位置上的蚂蚁肯定尽可能全选，因为这样做邻域 $N(S)$ 不会改变而 $|S|$ 会增大。然后进一步发现，让后面的式子取到最大值的 $S$ 是一段段区间，每两段区间的间隔至少是 $2L$。这个原因也比较显然，如果两个区间间隔 $<2L$，那么把中间的蚂蚁全部加上不会改变邻域大小，而 $S$ 的大小会增大。

所以我们可以形式化的写出后面式子的值，假设第 $i$ 个区间包含第 $[l_i,r_i]$ 个蚂蚁，那么后面式子的值就是：
$$
\sum_{i} \sum_{j=l_i}^{r_i} A_j-\sum_{j=X_{l_i}-L}^{X_{r_i}+L} B_j
$$
这个式子不好直接求最大值，我们希望把它拆成只和 $[l_i,r_i]$ 中每一项单独相关，这样的话用一些数据结构维护一下最大子段和就行了。考虑到后面的求和实际上就是所有蚂蚁的区间 $[X_i-L,X_i+L]$ 的并，而根据容斥原理，两个区间的并是两个区间的和减去两个区间的交，而交也是好求的，所以上式可以改写为：
$$
\begin{aligned}
\sum_i \sum_{j=l_i}^{r_i} A_j-(\sum_{j=l_i}^{r_i}\sum _{k=X_j-L}^{X_j+L} B_k - \sum_{j=l_i}^{r_i-1}\sum _{k=X_{j+1}-L}^{X_{j}+L} B_k)

\end{aligned}
$$
此时对于每个蚂蚁出现的位置，我们只需要维护出该位置上有多少蚂蚁、这个位置对应的区间内有多少方糖，以及这个位置和下一个位置交的地方有多少方糖即可。现在考虑怎样维护最大的区间和，这个显然可以上线段树，在每一个节点设 $f(i,0/1,0/1)$ 表示当前节点区间左 / 右端点钦定选 / 不选的方案数。转移的时候枚举 $l,mid,mid+1,r$ 处是否钦定选然后合并即可；当 $mid,mid+1$ 处都钦定选的时候要加上区间交的方糖个数，在每个线段树节点上再维护一下 $mid,mid+1$ 的区间交的方糖个数即可。

然后考虑如何修改，蚂蚁的修改是简单的，直接找到对应位置单点加即可。方糖的修改比较麻烦，考虑一块方糖会影响 $[X_i-L,X_i+L]$ 区间内的所有蚂蚁，那么在线段树上找到对应区间之后，只要这个区间内选了蚂蚁，邻域就会加上这些方糖的大小，也就是 dp 值要对应减去（注意此时 $dp(i,0,0)$ 不一定选了蚂蚁，所以需要和 $0$ 取 $\max$）。然后还需要同时维护区间中点处区间交的方糖个数，这个比较简单，判断一下中点和 $[X_i-L,X_i+L]$ 的位置关系然后直接修改即可。

最后式子的最大值就是线段树根节点处所有 dp 值的最大值，然后用 $\sum A_i$ 一减就是最终答案。复杂度是 $O(Q\log Q)$ 的，不过合并的时候会带一个 $16$ 的常数。

```cpp
#include <bits/stdc++.h>
#define il inline
#define int long long

using namespace std;

const int Maxn = 5e5 + 5;
const int Inf = 1e18;
template <typename T> il void chkmax(T &x, T y) {x = (x >= y ? x : y);}
template <typename T> il void chkmin(T &x, T y) {x = (x <= y ? x : y);}
template <typename T>
il void read(T &x) {
	x = 0; char ch = getchar(); bool flg = 0;
	for(; ch < '0' || ch > '9'; ch = getchar()) flg = (ch == '-');
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	flg ? x = -x : 0;
}
template <typename T>
il void write(T x, bool typ = 1) {
	static short Stk[50], Top = 0;
	x < 0 ? putchar('-'), x = -x : 0;
	do Stk[++Top] = x % 10, x /= 10; while(x);
	while(Top) putchar(Stk[Top--] | 48);
	typ ? putchar('\n') : putchar(' ');
}
il void IOS() {ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);}
il void File() {freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);}
bool Beg;

int n, lim;
struct node {
	int typ, x, a;
}p[Maxn];
int t[Maxn], tot;
namespace SMT {
	struct node {
		int f[2][2], val, tag;
	}t[Maxn << 2];
	#define ls(p) (p << 1)
	#define rs(p) (p << 1 | 1)
	void pushup(int p) {
		t[p].f[0][0] = t[p].f[0][1] = t[p].f[1][0] = t[p].f[1][1] = -Inf;
		for(int l1 = 0; l1 < 2; l1++)
			for(int r1 = 0; r1 < 2; r1++)
				for(int l2 = 0; l2 < 2; l2++)
					for(int r2 = 0; r2 < 2; r2++)
						chkmax(t[p].f[l1][r2], t[ls(p)].f[l1][r1] + t[rs(p)].f[l2][r2] + (r1 && l2) * t[p].val);
	}
	void pushtag(int p, int v) {
		t[p].tag += v;
		t[p].val += v;
		t[p].f[0][0] -= v, t[p].f[0][1] -= v, t[p].f[1][0] -= v, t[p].f[1][1] -= v;
		chkmax(t[p].f[0][0], 0ll);
	}
	void pushdown(int p) {
		if(t[p].tag) {
			pushtag(ls(p), t[p].tag); pushtag(rs(p), t[p].tag);
			t[p].tag = 0;
		}
	}
	void mdfa(int p, int l, int r, int x, int v) {
		if(l == r) {
			t[p].f[1][1] += v; return ;
		}
		pushdown(p);
		int mid = (l + r) >> 1;
		if(x <= mid) mdfa(ls(p), l, mid, x, v);
		else mdfa(rs(p), mid + 1, r, x, v);
		pushup(p);
	}
	void mdfs(int p, int l, int r, int pl, int pr, int v) {
		if(pl > pr) return ;
		if(pl <= l && r <= pr) {
			pushtag(p, v); return ;
		}
		pushdown(p);
		int mid = (l + r) >> 1;
		if(pl <= mid) mdfs(ls(p), l, mid, pl, pr, v);
		if(pr > mid) mdfs(rs(p), mid + 1, r, pl, pr, v);
		if(pl <= mid && pr > mid) t[p].val += v;
		pushup(p);
	} 
	int query() {
		return max({t[1].f[0][0], t[1].f[0][1], t[1].f[1][0], t[1].f[1][1]}); 
	}
}

bool End;
il void Usd() {cerr << (&Beg - &End) / 1024.0 / 1024.0 << "MB " << (double)clock() * 1000.0 / CLOCKS_PER_SEC << "ms\n"; }
signed main() {
	read(n), read(lim);
	for(int i = 1; i <= n; i++) {
		read(p[i].typ), read(p[i].x), read(p[i].a);
		if(p[i].typ == 1) t[++tot] = p[i].x;
	}
	sort(t + 1, t + tot + 1);
	tot = unique(t + 1, t + tot + 1) - t - 1;
	int sum = 0;
	for(int i = 1; i <= n; i++) {
		if(p[i].typ == 1) {
			int pos = lower_bound(t + 1, t + tot + 1, p[i].x) - t;
			SMT::mdfa(1, 1, tot, pos, p[i].a);
			sum += p[i].a;
		}
		else {
			int l = lower_bound(t + 1, t + tot + 1, p[i].x - lim) - t, r = upper_bound(t + 1, t + tot + 1, p[i].x + lim) - t - 1;
			SMT::mdfs(1, 1, tot, l, r, p[i].a);
		}
		int ans = sum - SMT::query();
		write(ans);
	}
	Usd();
	return 0;
}
```

---

## 作者：Fesdrer (赞：4)

容易将该问题转化为二分图，将蚂蚁和其能吃到的方糖连边后，就转化成求二分图的最大匹配。众所周知，二分图最大匹配等于总点数减去最大独立集，因此问题转化为了动态维护当前二分图的最大独立集。

容易贪心的发现，每选择的两个蚂蚁之间如果没有被选择的方糖，则其之间的所有蚂蚁都可以被选择，方糖同理。由此我们可以把最大独立集看作由从左到右的若干个不交的区间组成，每个区间选择其中所有的蚂蚁或方糖来作为最大独立集，且相邻的区间不能同时选择蚂蚁或方糖。再贪心的发现，如果我们确定了两个相邻的蚂蚁区间 $[l_1,r_1],[l_2,r_2]$，则它们中间的方糖区间应该贪心的选择成 $[r_1+L+1,l_2-L-1]$，这样才能尽可能最多的选择方糖。而为了更加方便维护答案，我们容斥地考虑扣掉每个蚂蚁区间确定后不应被选择地方糖数量，最后再加上方糖总数即可。由此，我们考虑维护蚂蚁区间。

再进一步的，我们定量的考虑这一问题。我们首先将问题离线，并将其中放置蚂蚁和方糖的位置离散化。假设离散化成了 $n$ 个位置，每个位置的原位置为 $x_i$，记 $up(i)$ 表示最小的 $j$ 使得 $x_j>x_i+L$（没有则为 $n+1$），记 $down(i)$ 表示最大的 $j$ 使得 $x_j<x_i-L$。再记 $S_i$ 蚂蚁数量的前缀和，$T_i$ 为方糖数量的前缀和，注意这里的 $i$ 是离散化后的 $i$。则每个蚂蚁区间 $[l,r]$（注意这里的 $l,r$ 已经是离散化后的 $l,r$ 了）的贡献为 $S_r-S_{l-1}-T_{up(r)-1}+T_{down(l)}$。进一步的拆开贡献，设 $l_i=-S_{i-1}+T_{down(i)}$，设 $r_i=S_r-T_{up(r)-1}$。由此，问题转化为了从左到右依次选择 $l,r,l,r,\cdots$ 来使总和最大。同时，最终选择的相邻的 $r$ 和 $l$ 其间隔应当大于 $2L$，否则将其连接肯定更优。

到这一步，容易发现 $l_i,r_i$ 很好用线段树维护，而依次选择 $l,r$ 可以用 DP 维护，于是有同学就立刻想到用矩阵乘法来进行 DDP，最后因为不会区间加、区间求积而苦思冥想（比如我），而最大的问题就是：无法在区间修改打标记的时候及时维护区间答案。事实上，我们不妨抛弃矩阵，不单独维护 $l,r$ 的值，而是在线段树上直接维护依次选择 $l,r$ 的最大值。具体的，线段树的每个节点上都要存储 $4$ 个变量 $ll,lr,rl,rr$，表示在节点表示的区间里从 $l$ 或 $r$ 开始依次选择到 $l$ 或 $r$ 的最大值。接下来一次考虑如何进行修改操作。

当在 $x$ 位置（已离散化）放置 $b$ 个蚂蚁时，记 $a=-b$，则需要将 $[x+1,n]$ 的 $l_i$ 加上 $a$，还要将 $[x,n]$ 的 $r_i$ 减去 $a$。这一操作等价于将 $[x+1,n]$ 的 $l_i$ 加 $a$、$r_i$ 减 $a$，再将 $r_x$ 减去 $a$。后一个操作就是一个单点修改很好求，具体分析前一个操作。当一个区间里的所有 $l$ 都加 $a$、$r$ 都减 $a$ 时，所有的从 $l$ 开始依次选择到 $r$ 的选择方式其贡献都不会改变（因为加 $a$ 减 $a$ 被抵消了），因此这一区间的 $lr$ 不变。同理 $rl$ 不变。而所有从 $l$ 开始依次选择到 $l$ 的选择方式其贡献都加 $a$，相对大小不变，因此 $ll$ 加 $a$，同理 $rr$ 减 $a$。这样就实现了打标记的时候能够及时维护答案。

当在 $x$ 位置（已离散化）放置 $a$ 个方糖时，通过类似的转换可以等价于：将 $[up(x),n]$ 的 $l_i$ 加 $a$、$r_i$ 减 $a$，再将 $[down(x)+1,up(x)-1]$ 的 $r_i$ 减去 $a$。前一个操作用上面的方法即可解决，后面的操作怎么办呢？容易发现这一区间的真实长度是小于等于 $2L$ 的（不懂的回去看 $up(x)$ 和 $down(x)$ 的定义），而每个区间上的 $ll,lr,rl,rr$，其选择的相邻的 $r$ 和 $l$ 其间隔都应当大于 $2L$，这就意味着这一区间上的 $rl$ 变量无意义。对这一区间 $rl$，我们可以在一开始就预处理一下，将区间长度小于等于 $2L$ 的所有节点的 $rl$ 设为 $-\infty$，所以这里就不用操作了。对于 $lr$，肯定只选择了一个 $l$ 和一个 $r$，因此只需要将 $lr$ 减 $a$，对于 $rl,ll$ 同理。至此实现了打标记的时候能够及时维护答案。

```c++
#include<bits/stdc++.h>
using namespace std;
using i64=long long;
const int N=5e5+5;
int Q,n;
i64 cnt1,ls[N],L;
struct Query{int op,x,num;}query[N];
void init(){
	for(int i=1;i<=Q;i++)	ls[i]=query[i].x;
	sort(ls+1,ls+Q+1),n=unique(ls+1,ls+Q+1)-ls-1;
}
struct Node{i64 lazy,lazyr,sum[2][2];}tr[N<<2];//lazy, l+r-; lazyr, r+
void doinit(int p,int l,int r){
	if(ls[r]-ls[l]<=2*L)	tr[p].sum[1][0]=-4000000000000000000;
	if(l==r)	return;
	int mid=(l+r)/2;
	doinit(p*2,l,mid),doinit(p*2+1,mid+1,r);
}
void pushup(int p){
	for(int i=0;i<=1;i++)	for(int j=0;j<=1;j++){
		tr[p].sum[i][j]=max(tr[p*2].sum[i][j],tr[p*2+1].sum[i][j]);
		for(int k=0;k<=1;k++)
			tr[p].sum[i][j]=max(tr[p].sum[i][j],tr[p*2].sum[i][k]+tr[p*2+1].sum[1-k][j]);
	}
}
void tag(int p,i64 lazy,i64 lazyr){
	tr[p].lazy+=lazy,tr[p].lazyr+=lazyr;
	tr[p].sum[0][0]+=lazy,tr[p].sum[1][1]-=lazy;
	tr[p].sum[0][1]+=lazyr,tr[p].sum[1][0]+=lazyr,tr[p].sum[1][1]+=lazyr;
}
void pushdown(int p){
	tag(p*2,tr[p].lazy,tr[p].lazyr),tag(p*2+1,tr[p].lazy,tr[p].lazyr);
	tr[p].lazy=tr[p].lazyr=0;
}
void change(int p,int l,int r,int L,int R,i64 lazy,i64 lazyr){
	if(L>r)	return;
	if(L<=l&&r<=R){
		tag(p,lazy,lazyr);
		return;
	}
	int mid=(l+r)/2;
	pushdown(p);
	if(L<=mid)	change(p*2,l,mid,L,R,lazy,lazyr);
	if(R>mid)	change(p*2+1,mid+1,r,L,R,lazy,lazyr);
	pushup(p);
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>Q>>L;
	for(int i=1;i<=Q;i++)	cin>>query[i].op>>query[i].x>>query[i].num;
	init(),doinit(1,1,n);
	for(int i=1;i<=Q;i++){
		Query que=query[i];
		if(que.op==1){
			int pal=lower_bound(ls+1,ls+n+1,que.x)-ls;
			change(1,1,n,pal+1,n,-que.num,0);
			change(1,1,n,pal,pal,0,que.num);
			cnt1+=que.num;
		}
		else{
			int palr=upper_bound(ls+1,ls+n+1,que.x+L)-ls;
			int pall=lower_bound(ls+1,ls+n+1,que.x-L)-ls;
			change(1,1,n,palr,n,que.num,0);
			change(1,1,n,pall,palr-1,0,-que.num);
		}
		cout<<(cnt1-max(0ll,tr[1].sum[0][1]))<<endl;
	}
	return 0;
}
```

---

## 作者：Cindy_Li (赞：1)

### 题意

数轴上有蚂蚁和方糖，蚂蚁找距离不超过 $L$ 的方糖，每次在位置 $x$ 放 $a$ 只蚂蚁或 $b$ 个方糖，询问最多有多少方糖能被匹配上。$q\le 5\times 10^5,x,a,b,L\le 10^9$。

### 题解

显然的二分图匹配问题，考虑 Hall 定理推论：
- 二分图最大匹配 $=|S|-\max\limits_{T\subseteq S} (|T|-N(T))$，其中 $N(T)$ 表示 $T$ 的邻域。

问题转化为选一个 $T$，最大化 $\max\limits_{T\subseteq S} (|T|-N(T))$。注意到选的蚂蚁一定是若干间隔 $>2L$ 的连续段，否则把两段中间的蚂蚁选上邻域不变集合大小增加。

形式化的写出这个式子，注意到邻域相当于若干 $[x_i-L,x_i+L]$ 的并，而并集等于总和减去相邻两个的交，交集是容易求的。

于是线段树维护 $f(0/1,0/1)$ 表示钦定左右端点选不选的最大值，pushup 时对 $mid,mid+1$ 都选的要减去交集，所以还需要维护 $mid,mid+1$ 的邻域交，修改是容易的。

---

## 作者：YYYmoon (赞：1)

这篇可以配合其他题解食用，算是一个补充说明。许多 dalao 对线段树具体实现的部分写的非常简略，我看了很久才终于搞明白了……

**Hall 定理**：对于一个两部分分别为 $V_L$,$V_R$ 的二分图，且 $|V_L|\leq |V_R|$。它存在一个大小为 $|V_L|$ 的匹配（即左侧点完全被匹配，或称之为“完美匹配”），当且仅当 $\forall S \subseteq V_L$，都有 $|S| \leq |\cup_{x\in S} N(x)|$（其中 $N(x)$ 表示点 $x$ 的邻居集）。

它有一个**推论**：若只有一个 $|S| > |\cup_{x\in S} N(x)|$，那么我们直接匹配最多可能匹配的，匹配不上的删掉。然后变就成了 **Hall 定理**的形式。

这个结论在连边的范围是一段区间时非常好用，可以作为一些贪心策略的依据。

对于本题，直接转化为实际意义，最大匹配就是“用总蚂蚁数-最大的（选择的蚂蚁数-对应方糖数）”。

$\max$ 内的东西可以用线段树维护（别问怎么看出来的，可能就是区间修改+多次询问……

考虑一种经典 **trick**，对每个区间维护当前左/右端点选/不选蚂蚁时的最大的(选择的蚂蚁数-对应方糖数)的值。（准确来说只有钦定不选是必不选，钦定选择还包含这个地方暂时没有蚂蚁的情况）

每次修改时，加入蚂蚁就单点改；加入方糖，我们修改它能影响的区间 $[x-L,x+L]$（即，在区间内选择蚂蚁时会计入这堆方糖的贡献）。

但注意到我们在线段树上合并两个区间时，这两个蚂蚁区间对应的方糖可能会有交集。

考虑如何维护这个东西。首先我们明确，如果两个蚂蚁的距离在 $2L$ 以内，我们一定会选择这两个蚂蚁之间的所有蚂蚁。因为可选择的方糖数不变，而蚂蚁增多了。

那么 ```pushup``` 时如果在两侧区间各取一个已选择的蚂蚁，且这两个蚂蚁的最近距离在 $2L$ 以内，合并两个区间的最大值，一定是钦定选择左区间的右端点和右区间的左端点；与此同时，这也就是会多算方糖的情况，我们只需要在此时把左右区间选择方糖的交集搞掉就行了。

那么我们线段树就只需要维护一个 ```t[x].f[0/1][0/1]``` 表示在这个区间内左右端点蚂蚁是否钦定选择的最大值，```t[x].val``` 表示在合并这个区间的左右儿子时会多算的方糖的贡献，最后我们还需要一个懒标记就行了。（注意懒标记打上的区间 ```t[x].f[0/1][0/1],t[x].val``` 都要更新。

如需代码，可参考 UKE_Automation 大佬的题解。

---

## 作者：喵仔牛奶 (赞：0)

## Solution

根据 Hall 定理的一些转化，需要解决的问题是选择若干区间 $[l_i,r_i]$，最大化区间内蚂蚁的个数之和，减去所有被 $[l_i-L,r_i+L]$ 包含的方糖个数之和。

将蚂蚁的位置离散化。这个被 $[l_i-L,r_i+L]$ 包含非常不好，对于方糖求出 $[x-L,x+L]$ 在蚂蚁位置中的区间，计入贡献的条件变为选择的区间与方糖区间有交。

方糖区间具有性质：不存在两个方糖区间 $[l,r],[x,y]$ 使得 $l<x\le y<r$。

很多题解没有讲到，有交则计入贡献的本质解决方法是**点减边容斥**。也就是相邻两个点之间连边，然后选了这两个点会有额外代价。

设两个信息 $(w,f)$，对于区间 $[l,r]$，$w$ 表示 $(l-1,l)$ 这条边的代价，$f_{0/1,0/1}$ 表示 $l$ 选/不选，$r$ 选/不选的最大权值。

设两个标记 $(x,y)$，对于区间 $[l,r]$，所有 $[l,r]$ 内部的点和边的权值要加上 $y$，$(l-1,l)$ 权值要加上 $x$。

对于信息的合并：直接枚举 $f_{a,b},f_{c,d}$ 合成为 $f_{a,d}$，如果 $b=c=1$ 还要再加上右边的 $w$。

对于标记的复合：直接加起来就好了。

对于标记作用在信息上：首先将 $w$ 加上 $x$。根据方糖的性质，此时的区间 $[l,r]$ 内部的最优解一定是一个区间，因此直接把 $f_{x,y}$ 全部减去 $y$，然后 $f_{0,0}$ 对 $0$ 取 $\max$。

需要注意的是标记的下传比较特殊，左儿子要复合 $(x,y)$，右儿子要复合 $(y,y)$，拆分区间时也同理。具体可以见代码。

复杂度 $\mathcal O(q\log q)$。

:::info[代码]
[记录](https://www.luogu.com.cn/record/230628789)。
```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
#define ppc(x) __builtin_popcount(x)
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 5e5 + 5;
	namespace SGT {
		struct info {
			LL w, f[4];
			void set(LL x) { w = 0, f[0] = 0, f[3] = x, f[1] = f[2] = -1e18; }
		} s[N * 4];
		struct tag {
			LL x, y;
			void rst() { x = y = 0; }
		} tg[N * 4];
		info mrg(const info& x, const info& y) { 
			info z; z.set(-1e18), z.w = x.w;
			REP(i, 0, 3) REP(j, 0, 3) {
				int k = (i & 2) | (j & 1);
				z.f[k] = max(z.f[k], x.f[i] + y.f[j] + ((i & 1) && (j & 2) ? y.w : 0));
			}
			return z;
		}
		tag cps(const tag& x, const tag& y) {
			return {x.x + y.x, x.y + y.y};
		}
		info apl(info x, const tag& y) {
			x.w += y.x;
			REP(i, 0, 3) x.f[i] -= y.y;
			x.f[0] = max(x.f[0], 0LL);
			return x;
		}
		void pushup(int p) { s[p] = mrg(s[p * 2], s[p * 2 + 1]); }
		void mktg(int p, const tag& k) { s[p] = apl(s[p], k), tg[p] = cps(tg[p], k); }
		void pushdw(int p) {
			if (!tg[p].x && !tg[p].y) return;
			mktg(p * 2, tg[p]), mktg(p * 2 + 1, {tg[p].y, tg[p].y}), tg[p].rst();
		}
		void mdf(int p, int l, int r, int t, LL w) {
			if (l == r) { s[p].f[3] += w; return; }
			int m = (l + r) >> 1; pushdw(p);
			if (t <= m) mdf(p * 2, l, m, t, w);
			else mdf(p * 2 + 1, m + 1, r, t, w);
			pushup(p);
		}
		void upd(int p, int l, int r, int nl, int nr, const tag& k) {
			if (nl <= l && r <= nr) { mktg(p, k); return; }
			int m = (l + r) >> 1; pushdw(p);
			if (nl <= m) upd(p * 2, l, m, nl, nr, k);
			if (nr > m) upd(p * 2 + 1, m + 1, r, nl, nr, (nl <= m ? (tag){k.y, k.y} : k));
			pushup(p);
		}
		info ask(int p, int l, int r, int nl, int nr) {
			if (nl <= l && r <= nr) return s[p];
			int m = (l + r) >> 1; pushdw(p);
			if (nr <= m) return ask(p * 2, l, m, nl, nr);
			if (nl > m) return ask(p * 2 + 1, m + 1, r, nl, nr);
			return mrg(ask(p * 2, l, m, nl, nr), ask(p * 2 + 1, m + 1, r, nl, nr));
		}
		void bld(int p, int l, int r) {
			tg[p].rst();
			if (l == r) return s[p].set(0);
			int m = (l + r) >> 1;
			bld(p * 2, l, m), bld(p * 2 + 1, m + 1, r), pushup(p);
		}
	}
	LL q, n, k, sm;
	vector<int> t; tuple<int, int, int> qr[N]; 
	int main() {
		cin >> q >> k, t.pb(0);
		REP(i, 1, q) {
			auto &[o, x, y] = qr[i];
			cin >> o >> x >> y;
			if (o == 1) t.pb(x);
		}
		sort(ALL(t)), t.erase(unique(ALL(t)), t.end()), n = SZ(t);
		SGT::bld(1, 1, n);
		REP(i, 1, q) {
			auto [o, x, y] = qr[i];
			if (o == 1) {
				x = lower_bound(ALL(t), x) - t.begin() + 1;
				SGT::mdf(1, 1, n, x, y), sm += y;
			}
			if (o == 2) {
				int l = lower_bound(ALL(t), x - k) - t.begin() + 1;
				int r = upper_bound(ALL(t), x + k) - t.begin();
				if (l <= r) SGT::upd(1, 1, n, l, r, {0, y});
			}
			auto t = SGT::s[1];
			cout << sm - max({t.f[0], t.f[1], t.f[2], t.f[3]}) << '\n';
		}
		return 0;
	}
}
int main() {
	cin.tie(0)->sync_with_stdio(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```
:::

---


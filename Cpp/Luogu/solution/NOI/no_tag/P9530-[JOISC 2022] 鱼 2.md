# [JOISC 2022] 鱼 2

## 题目背景

JOISC2022 D4T2

## 题目描述

JOI 君有 $N$ 条鱼，编号为 $1,2,\dots,N$。第 $i$ $(1 \le i \le N)$ 条鱼的大小为 $A_i$。

当我们养鱼的时候，需要注意如下的一个事实：如果有两条鱼离得很近，那么随着时间的流逝，可能会有其中一条吃掉另一条。其中，两条鱼离得很近，当且仅当它们中间没有鱼。  
更具体地，如果鱼 $x$ 的大小不小于鱼 $y$ 的大小，且鱼 $x,y$ 离得很近，那么 $x$ 可以吃掉 $y$，且 $x$ 的大小变为原来 $x,y$ 的大小之和。如果 $x,y$ 一样大，那么 $x$ 吃掉 $y$ 或 $y$ 吃掉 $x$ 都可能发生。

JOI 君会养 $Q$ 天鱼。为了消磨时光，他会进行如下的思想实验。在第 $j$ 天 $(1 \le j \le Q)$，JOI 君会进行如下行动中的一个：

- 第一类：JOI 君给鱼 $X_j$ 吃了某些秘制的食物。这会将鱼 $X_j$ 的大小变为 $Y_j$。

- 第二类：JOI 君将编号在区间 $[L_j,R_j]$ 内的鱼单独拿出来，并进行以下实验：  
  JOI 君将鱼 $L_j,L_j+1,\dots,R_j$ 从左到右依次放在一个鱼缸中。由于鱼们具有如上所述的特点，最后只有一条鱼会存活。存活的这条鱼的编号取决于在哪些时刻哪些鱼吃掉了哪些鱼。JOI 君想知道可能成为最后存活者的鱼的条数。在实验中，鱼的编号不会改变，也不能有两条鱼同时吃掉同一条鱼。

请写一个程序，对于给定的 JOI 君的鱼和实验的信息，计算每个第二类行动的答案来让 JOI 君能够证明或证伪自己的观点。注意这只是思想实验，并没有任何鱼真的被吃掉。

## 说明/提示

**【样例解释 #1】**

在 $6$ 天中，JOI 君进行了以下行动：

- 第一天，他对鱼 $1,2,3,4,5$ 进行了一次实验。
- 第二天，他对鱼 $1,2,3$ 进行了一次实验。
- 第三天，他给鱼 $3$ 吃了秘制食物，使其大小变为 $1$。
- 第四天，他对鱼 $2,3,4,5$ 进行了一次实验。
- 第五天，他对鱼 $1,2,3,4,5$ 进行了一次实验。
- 第六天，他对鱼 $2,3,4$ 进行了一次实验。

第一天的实验的结果如下：

- 鱼缸中的鱼的大小依次为 $[6,4,2,2,6]$。
- 例如，经过如下过程，鱼 $2$ 会成为最后存活者。（其中粗体为鱼 $2$ 的大小。）  
  $[6,\textbf 4,2,2,6]$（初始状态）$\longrightarrow$ $[6,\textbf 4,4,6]$（鱼 $4$ 吃掉鱼 $3$）$\longrightarrow$ $[6,\textbf 8,6]$（鱼 $2$ 吃掉鱼 $4$）$\longrightarrow$ $[\textbf{14},6]$（鱼 $2$ 吃掉鱼 $1$）$\longrightarrow$ $[\textbf{20}]$（鱼 $2$ 吃掉鱼 $5$）。
- 类似地，鱼 $1,2,3,4,5$ 都可能成为最后存活者。因此答案为 $5$。

该样例满足子任务 $1,3,6$ 的限制。

**【样例解释 #2】**

该样例满足所有子任务的限制。

**【样例解释 #3】**

该样例满足子任务 $1,3,4,6$ 的限制。

**【样例解释 #4】**

该样例满足子任务 $1,3,5,6$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $1 \le N,Q \le 100\,000$。
- $1 \le A_i \le 10^9$ $(1\le i\le N)$。
- $T_j \in \{1,2\}$。
- $1 \le X_j \le N$ $(1\le j\le Q)$。
- $1 \le Y_j \le 10^9$。
- $1 \le L_j \le R_j \le N$ $(1 \le j \le Q)$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$N \le 500$，$Q \le 500$|$5$|
|$2$|$Q=1$，$T_j=2$，$L_j=1$，$R_j=N$ $(1 \le j \le Q)$|$8$|
|$3$|$Q\le 1\,000$|$12$|
|$4$|$T_j=2$ $(1 \le j\le Q)$|$23$|
|$5$|对于每个满足 $T_j=2$ 的 $j$ $(1\le j\le Q)$，满足 $L_j=1$，$R_j=N$|$35$|
|$6$|无附加限制|$17$|

## 样例 #1

### 输入

```
5
6 4 2 2 6
6
2 1 5
2 1 3
1 3 1
2 2 5
2 1 5
2 2 4```

### 输出

```
5
2
2
3
1```

## 样例 #2

### 输入

```
13
10 4 2 5 20 5 4 8 20 10 3 3 7
1
2 1 13```

### 输出

```
7```

## 样例 #3

### 输入

```
12
32 32 4 1 1 1 1 4 4 16 32 128
7
2 1 12
2 2 6
2 8 10
2 1 9
2 3 8
2 5 9
2 2 12```

### 输出

```
12
1
1
2
6
2
1```

## 样例 #4

### 输入

```
10
2 3 5 10 1 3 4 9 5 2
8
2 1 10
1 10 5
2 1 10
1 4 1000000000
2 1 10
1 8 20
1 4 8
2 1 10```

### 输出

```
4
6
1
6```

# 题解

## 作者：Alex_Wei (赞：24)

### *[P9530 [JOISC2022] 鱼 2](https://www.luogu.com.cn/problem/P9530)

考虑如何判定一条鱼能够活到最后。从它的位置开始，向左向右找到第一条大于它当前重量的鱼。将这两条鱼之间的所有鱼吃掉，不断重复该过程直到它两侧的鱼的重量都大于它。寻找前驱和后继的过程可以通过线段树上二分维护，而每次寻找大于当前重量的鱼的前驱后继时，由于最终一定会吃掉一个前驱或后继（否则无法继续扩展），于是鱼的重量翻倍。因此整个过程的复杂度是 $\mathcal{O}(\log n \log A)$。

容易想到用下标区间 $[l, r]$ 记录一条鱼，表示它能吃掉下标区间内的所有鱼，并且被 $l - 1$ 和 $r + 1$ 挡住了。那么，根据上述分析，对于序列的每个位置 $i$，包含 $i$ 的本质不同的区间数量只有 $\mathcal{O}(\log A)$ 次：较大区间的重量一定大于较小区间重量的两倍。

考虑对一段区间求出区间内每条鱼在当前区间范围内的下标区间 $[L, R]$，如果某条鱼的下标区间无法到达区间 $[l, r]$ 的左端点和右端点（$l < L \leq R < r$），那么它无论如何也无法吃掉更大的区间：影响它扩张的前驱 $L - 1$ 和后继 $R + 1$ 在该区间内已经出现了，于是在更大的区间也会影响它扩张。

结合 “包含某点的不同区间数量很少” 以及 “只有包含左端点或右端点的区间有用”，可知只需用 $\mathcal{O}(\log A)$ 个区间 $[L, R]$（还需维护有多少个下标 $C$ 可以恰好扩张到该区间）就可以描述一段区间的信息。结合带修的要求，用线段树维护。于是只需考虑两个相邻结点 $[l, M]$ 和 $[M + 1, r]$ 的信息的合并。

将区间根据是否可达左右端点分为三类（两者都不可达的区间无用）。左侧可达左端点但不可达右端点的区间依然可达左端点且不可达右端点，右侧同理。

考虑左侧可达右端点 $M$（不用不可达左端点 $l$）的区间 $[L_i, M]$ 的贡献，将它们按照包含关系从小到大排序。

- 对可达整体右端点 $r$ 的贡献：求出最小的可扩张为整体右端点 $r$ 的区间 $[L_i, M]$，然后不断向左扩展。过程中可能会出现无法扩展的情况，那么上一次无法扩展（$[L_i, M]$）到这一次无法扩展（$[L_j, M], i < j$）之间，所有 $[L_k, M], i < k\leq j$ 对应的所有下标都恰好扩张为 $[L_j, r]$。
- 对可达整体左端点 $l$ 但不可达右端点 $r$ 的贡献：求出 $[l, M]$（也是最大的 $[L_c, M]$）可达的右边界 $r'$，如果右边界不是右端点（$r' < r$），那么求出最小的左侧可达 $r'$ 的区间 $[L_i, M]$，所有 $[L_k, M], i \leq k\leq c$ 的对应下标都恰好扩张为 $[l, r']$。

为了避免 ”求出最小的满足 …… 的区间“ 的二分，可以用双指针 $pl, pr$ 维护，表示从左侧对应区间 $[L_{pl}, M]$ 开始，可以将右边界扩展到右侧对应区间 $R_{pr}$，同时记录有多少个下标可以扩张到当前区间。从左侧最小的区间开始：

- 如果能向右边扩张就向右边扩张，$pr$ 加 $1$；
- 否则如果左边到头了（$pl = c$）就退出；
- 否则如果左边不能扩张，则说明两边都不能扩张，下标数清零。然后 $pl$ 加 $1$（无论左边是否能够扩张），并加入 $[L_{pl}, M]$ 的对应下标数。

可以在双指针的过程中求出可达整体右端点 $r$ 的贡献，在双指针结束后求出对可达整体左端点 $l$ 但不可达右端点 $r$ 的贡献。

对右侧可达左端点 $M + 1$（不用不可达右端点 $r$）的区间的贡献，同理。

每个 $[L, R]$ 需要维护区间和，对应下标数，以及两侧限制它扩张的鱼的重量（实际上只要一侧：可达左端点的维护右侧；可达右端点的维护左侧；可达左右端点的不用维护，只需在结点处额外维护左右端点的重量）。

时间复杂度 $\mathcal{O}((n + q\log n)\log A)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int N = 1e5 + 5;
constexpr int inf = 1e9 + 7;

int n, q, a[N];
struct info {int sum, cnt, out;};
struct dat {
  int l, r, sum, cnt;
  vector<info> L, R;
  dat operator + (const dat &z) const {
    dat x = {l, z.r, min(inf, sum + z.sum), 0, L, z.R};

    vector<info> fl = R, fr = z.L;
    fl.push_back({sum, cnt, 0});
    fr.push_back({z.sum, z.cnt, 0});

    vector<info> apl, apr;
    int sum, bound;

    // left
    int pl = 0, pr = -1, tot = fl[0].cnt;
    while(1) {
      sum = min(inf, fl[pl].sum + (pr == -1 ? 0 : fr[pr].sum));
      bound = (pr == -1 ? z.l : fr[pr].out);
      if(sum >= bound && pr + 1 < fr.size()) pr++;
      else if(pl == fl.size() - 1) break;
      else {
        if(sum < fl[pl].out) {
          if(pr == fr.size() - 1) apr.push_back({sum, tot, fl[pl].out});
          tot = 0;
        }
        tot += fl[++pl].cnt;
      }
    }
    if(pr == fr.size() - 1) x.cnt += tot;
    else x.L.push_back({sum, tot, bound});

    swap(fl, fr);

    // right
    pl = 0, pr = -1, tot = fl[0].cnt;
    while(1) {
      sum = min(inf, fl[pl].sum + (pr == -1 ? 0 : fr[pr].sum));
      bound = (pr == -1 ? r : fr[pr].out);
      if(sum >= bound && pr + 1 < fr.size()) pr++;
      else if(pl == fl.size() - 1) break;
      else {
        if(sum < fl[pl].out) {
          if(pr == fr.size() - 1) apl.push_back({sum, tot, fl[pl].out});
          tot = 0;
        }
        tot += fl[++pl].cnt;
      }
    }
    if(pr == fr.size() - 1) x.cnt += tot;
    else x.R.push_back({sum, tot, bound});

    for(info it : apl) x.L.push_back(it);
    for(info it : apr) x.R.push_back(it);

    return x;
  }
} val[N << 2];
void build(int l, int r, int x) {
  if(l == r) return val[x] = {a[l], a[l], a[l], 1}, void();
  int m = l + r >> 1;
  build(l, m, x << 1), build(m + 1, r, x << 1 | 1);
  val[x] = val[x << 1] + val[x << 1 | 1];
}
void modify(int l, int r, int x, int p) {
  if(l == r) return val[x] = {a[l], a[l], a[l], 1}, void();
  int m = l + r >> 1;
  if(p <= m) modify(l, m, x << 1, p);
  else modify(m + 1, r, x << 1 | 1, p);
  val[x] = val[x << 1] + val[x << 1 | 1];
}
dat query(int l, int r, int ql, int qr, int x) {
  if(ql <= l && r <= qr) return val[x];
  int m = l + r >> 1;
  if(qr <= m) return query(l, m, ql, qr, x << 1);
  if(m < ql) return query(m + 1, r, ql, qr, x << 1 | 1); 
  return query(l, m, ql, qr, x << 1) + query(m + 1, r, ql, qr, x << 1 | 1);
}
int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  for(int i = 1; i <= n; i++) cin >> a[i];
  build(1, n, 1);
  cin >> q;
  for(int i = 1; i <= q; i++) {
    int op;
    cin >> op;
    if(op == 1) {
      int x, y;
      cin >> x >> y, a[x] = y;
      modify(1, n, 1, x);
    }
    else {
      int l, r;
      cin >> l >> r;
      dat res = query(1, n, l, r, 1);
      cout << res.cnt << "\n";
    }
  }
  return 0;
}
```

---

## 作者：Hoks (赞：7)

## 前言
好题，真的好题。

摘自 [杂题选做](https://www.luogu.com.cn/training/597433)。
## 思路分析
首先推荐先去看下[弱化版](https://www.luogu.com.cn/problem/CF1990F)。

想下在这个弱化版里我们最重要的关键是什么。

是不是最开始的一个单点的暴力，通过这个推广到线段树上。

这题也是这样，我们先考虑下对于一个区间 $[l,r]$ 中的一个位置 $x$ 找到他能扩展的最大区间 $[L,R]$ 怎么做。

我们可以想到一个很暴力的思路，先向右一路扩展到不能扩展，然后再向左扩展到不能扩展。

实际上，我们发现扩展到不能扩展非常困难，因为扩展后鱼的重量也会变，会影响扩展的边界。

但是这不重要，我们直接找到**当前肯定能吃掉**的最长扩展就行了。

看上去很暴力，但实际上这个是对的。

我们用线段树维护查询从位置 $l$ 开始第一个大于 $x$ 的数的位置，这个是可以简单 $O(\log(n))$ 完成的。

接着因为除了第一次扩展外，每次扩展都是把之前的一个**断点**吃掉。

而**断点**之所以是断点，就是因为第一次到这个点的时候值小于这个点。

所以在吃掉**断点**之后扩展鱼的质量至少会翻倍，也就是我们最多只会**扩展** $\log V$ 次。

这样的话单点查询的复杂度就是 $O(\log n\log V)$，显然的是对每个点暴力做还是很不现实的。

我们考虑把这东西扔到线段树上去尝试 pushup。

问题就变成了怎么合并两个区间的答案。

我们考虑对于两个区间假设其分别为 $[l,mid],[mid+1,r]$，那么类似于弱化版，我们要考虑的答案还是在于跨过 $mid$ 点产生的新影响。

考虑下什么样的点才能产生贡献。

我们考虑，对于 $[l,mid]$ 这个区间中的点，如果他原本的扩展无法到 $mid$ 这个点，那么肯定不能越过 $mid$ 到更右边的位置，所以可以直接扔掉。

因为右边的位置和左边的位置是对称的，所以我们只考虑左边的问题。

考虑对于许多个点 $x,y,z,\dots$，假设他们扩展出来的最大区间都是 $[L,R]$，那么他们本质上是等价的，因为最后这段区间都变成了一个固定的和。

所以这启发我们把**能到达左/右端点**的**不同的最大扩展区间**存下来。

那么对于这样的每一个**最大扩展区间**，我们使用刚刚的朴素方法去扩展这个区间，那么每个拓展都需要 $O(\log n\log V)$。

接着考虑最多会有多少个不同的**最大扩展区间**。

考虑类似于弱化版中的证明，要产生一个不同的，就要用一个极大值卡主左/右端点，也就是构造一个这样的数列：
$$1,2,4,8,\dots,2^k$$
显然的值域限制下，这个最多只会有 $\log V$ 个。

这样我们就得到了一个较劣的做法，复杂度 $O(q\log^2 V\log^2 n)$，卡满就是全修改不查询的情况。

但是实际上我们有优化空间，考虑下我们的处理的那些区间其实都是包含关系。

准确而言，我们的区间应该都是长成这样的：
$$[l_1,mid],[l_2,mid],\dots,[l_k,mid]$$

这点比较显然，因为我们的右端点必须要达到区间的右端点嘛。

那既然有包含这么特殊的条件，我们考虑下能不能不要在每个区间做的时候都暴力的算一遍，而是略带启发性的转移。

考虑包含意味着什么？

对于两个区间 $[x,mid]$ 和 $[y,mid]$，假设 $x<y$，那么设后面那个区间可以扩展到 $[L,R]$，则 $[x,mid]$ 这个区间至少能扩展到 $[L,R]$。

这样我们就保证了扩展的单调性，结合最多只会扩展 $\log V$ 次的性质，对 $\log V$ 个区间扩展，总扩展次数总和只能卡到 $\log V$，所以这里就成功消掉了一个 $\log V$。

就可以把复杂度压到 $O(q\log V\log^2 n)$，最劣情况和上面那个其实是相同的。

我们考虑能不能进一步的优化这个东西。

这下的优化我们必须在线段树上动手脚了。

因为我们的 pushup 肯定会有一个 $\log$ 挂在上面的，我们还无法避免不遍历每个区间来转移，所以这里的 $\log n\log V$ 是定死了的，必须要想办法砍掉线段树二分。

这个时候就开始找性质了。

其实我们会发现，全程的问题中，很多点都是无关紧要的，**因为他根本没法卡住让一个区间没法扩展**。

那么对于能卡住区间扩展的点不妨称之为**断点**，因为我们用到的只有**能到达左右端点的区间**，所以我们只需要考虑这些区间的**断点**就行了。

也就是只有我们存下来的那 $\log V$ 个不同区间的左右端点才是线段树二分可能出来的结果。

这点比较显然，给张图应该就懂了。

我们考虑反证法，假设一个点 $x$ 不是**断点**但被二分出来了。

那么我们肯定可以找到线段树之前的一个区间包含这个点 $x$，这个区间用黑色表示，而当前被卡住的区间用红色表示，就得到了这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/axfoixat.png)

因为他不是**断点**，所以 $[mid,x)$ 这一段的区间都不能被卡住，也就是 $[mid,x)$ 的和大于 $x$ 才能扩展出去。

显然的是当前区间 $[l,x),l\le mid$ 是包含区间 $[mid,x)$ 的，必不可能被卡住，所以矛盾。

所以这个性质就成立了。

再结合我们的区间扩展也是**单调的**，所以我们可以直接用双指针一路移的方法来替代线段树上二分。

具体的，对于 $[l,mid]$ 的区间，我们按照区间被下一个包含的顺序遍历，那么这个右端点的扩展就是单调的。

双指针往右扩展时同时记录下就行了。

为了避免查询和而多出 $\log n$，我们对于每个区间都记录下和 $s$，向右从区间 $x$ 走到区间 $y$ 时就减去 $x$ 的和加上 $y$ 的和。

向左移的同时，因为这些区间的答案也会跟着当前区间一样变大，所以把这些区间的方案数也加上一起跑。

此时我们来分析复杂度，就会发现这个移动最多只有 $\log V$ 次，因为断点数是 $\log V$ 的，那这样我们就成功的又剥掉一个 $\log$。

总的复杂度来到 $O(q\log V\log n)$。

实现可能有点困难。

~~我的写法好像和现在看到的所有双指针写法的都不太一样（），但个人认为更好理解了。~~

具体实现而言，因为我们要保证左右两端点的 `vector` 中位置的单调性，所以不能直接把左边得到的结果压进最后的 `vector` 中，而是要先存起来。

右边的也是同理，把左右两边都处理完后，再合并这 $4$ 个 `vector`。

双指针移动时考虑比较朴素的直接把区间两端点指针的 $L,R$ 实时维护，这样写起来清楚也不容易错一点。

以及 `vector` 使用记得实时判空，不然会疯狂 UB。
## 代码

```cpp
#include<bits/stdc++.h>
#define ls (p<<1)
#define rs (ls|1)
#define mid ((l+r)>>1)
#define int long long
using namespace std;
constexpr int N=2e5+10,INF=0x3f3f3f3f3f3f3f3f;
struct info{int x,w,s;};
struct node{int l,r;vector<info>ll,rr;}t[N<<2];
int n,m,a[N];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
inline node merge(node x,node y)
{
    if(x.l==-1) return y;if(y.l==-1) return x;node res;
    res.l=x.l;res.r=y.r;res.ll=x.ll;res.rr=y.rr;vector<info> lll,llr,rrl,rrr;
    int l=0,r=-1,s=x.rr[0].s,w=x.rr[0].w,ll=a[x.l-1],rr=a[y.r+1];a[x.l-1]=a[y.r+1]=INF;
    while(!res.ll.empty()&&res.ll.back().x==x.r) res.ll.pop_back();
    while(!res.rr.empty()&&res.rr.back().x==y.l) res.rr.pop_back();
    lll.clear();llr.clear();rrl.clear();rrr.clear();
    while(1)
    {
        int L=x.rr[l].x,R=(r==-1?x.r:y.ll[r].x);
        while(l+1<x.rr.size()&&s>=a[L-1])
        {
            s-=x.rr[l++].s;s+=x.rr[l].s;
            w+=x.rr[l].w;L=x.rr[l].x;
        }
        while(r+1<y.ll.size()&&s>=a[R+1])
        {
            if(r!=-1) s-=y.ll[r].s;r++;
            s+=y.ll[r].s;R=y.ll[r].x;
        }
        if(s<a[L-1]&&s<a[R+1])
        {
            if(L==x.l&&w!=0) lll.push_back({R,w,s});
            if(R==y.r&&w!=0) llr.push_back({L,w,s});
            l++;if(l>=x.rr.size()) break;
            w=x.rr[l].w;s=x.rr[l].s;
            if(r!=-1) s+=y.ll[r].s;
        }
    }
    l=-1,r=0,s=y.ll[0].s,w=y.ll[0].w;
    while(1)
    {
        int L=(l==-1?y.l:x.rr[l].x),R=y.ll[r].x;
        while(l+1<x.rr.size()&&s>=a[L-1])
        {
            if(l!=-1) s-=x.rr[l].s;l++;
            s+=x.rr[l].s;L=x.rr[l].x;
        }
        while(r+1<y.ll.size()&&s>=a[R+1])
        {
            s-=y.ll[r++].s;s+=y.ll[r].s;
            w+=y.ll[r].w;R=y.ll[r].x;
        }
        if(s<a[L-1]&&s<a[R+1])
        {
            if(L==x.l&&w!=0) rrl.push_back({R,w,s});
            if(R==y.r&&w!=0) rrr.push_back({L,w,s});
            r++;if(r>=y.ll.size()) break;
            w=y.ll[r].w;s=y.ll[r].s;
            if(l!=-1) s+=x.rr[l].s;
        }
    }int i=0,j=0;
    while(i<lll.size()||j<rrl.size())
    {
        if(i==lll.size()){res.ll.emplace_back(rrl[j++]);continue;}
        if(j==rrl.size()){res.ll.emplace_back(lll[i++]);continue;}
        if(lll[i].x<rrl[j].x){res.ll.emplace_back(lll[i++]);continue;}
        if(lll[i].x>rrl[j].x){res.ll.emplace_back(rrl[j++]);continue;}
        res.ll.push_back({lll[i].x,lll[i].w+rrl[j].w,lll[i].s});i++;j++;
    }i=0;j=0;
    while(i<llr.size()||j<rrr.size())
    {
        if(i==llr.size()){res.rr.emplace_back(rrr[j++]);continue;}
        if(j==rrr.size()){res.rr.emplace_back(llr[i++]);continue;}
        if(llr[i].x>rrr[j].x){res.rr.emplace_back(llr[i++]);continue;}
        if(llr[i].x<rrr[j].x){res.rr.emplace_back(rrr[j++]);continue;}
        res.rr.push_back({llr[i].x,llr[i].w+rrr[j].w,llr[i].s});i++;j++;
    }a[x.l-1]=ll;a[y.r+1]=rr;return res;
}
inline void build(int l,node&x){x.l=x.r=l,x.ll.clear();x.ll.push_back({l,1,a[l]});x.rr=x.ll;}
inline void build(int p,int l,int r)
{
    if(l==r) return build(l,t[p]);
    build(ls,l,mid);build(rs,mid+1,r),t[p]=merge(t[ls],t[rs]);
}
inline void modify(int p,int l,int r,int x,int w)
{
    if(l==r) return a[l]=w,build(l,t[p]);
    mid>=x?modify(ls,l,mid,x,w):modify(rs,mid+1,r,x,w);t[p]=merge(t[ls],t[rs]);
}
inline node query(int p,int l,int r,int s,int e)
{
    if(l>=s&&r<=e) return t[p];node res;res.l=-1;
    if(mid>=s) res=query(ls,l,mid,s,e);
    if(mid<e) res=merge(res,query(rs,mid+1,r,s,e));
    return res;
}
inline int query(int l,int r)
{
    auto ans=query(1,1,n,l,r).ll;int res=0;
    for(auto [x,w,s]:ans) res+=(x==r)*w;
    return res;
}
inline void solve()
{
    n=read();for(int i=1;i<=n;i++) a[i]=read();build(1,1,n);m=read();
    for(int i=1,op,x,y;i<=m;i++)
    {
        op=read(),x=read(),y=read();
        op==1?modify(1,1,n,x,y):(print(query(x,y)),put('\n'));
    }
}
signed main()
{
    int T=1;while(T--) solve();
    genshin:;flush();return 0;
}
```

---

## 作者：Raisetsu41 (赞：7)

首先观察一下不能继续吃的条件是啥，对于 $[l, r]$ 一个小区间，里面的鱼互相吃完之后不能再移动当且仅当 $a[l \dots r] < \min\{ a_{l - 1}, a_{r + 1} \}$。  
记一条鱼 $i$ 能够吃掉的极大区间为 $[l_i, r_i]$，发现在询问区间 $[L, R]$ 固定的时候，不同的 $[l_i, r_i]$ 的个数是 $\log V$ 级别的，因为当 $i$ 的扩展被挡住时，一定会出现一条和 $i$ 目前体积相当或更大的鱼，鱼的体积每次都在翻倍。  
于是把生成了相同 $[l, r]$ 的鱼看作一个等价类。  
先考虑全局问题，答案就是等价类 $[1, n]$ 的大小。对于局部询问，这个等价类的信息如何合并呢？  
考虑合并两个相邻的区间 $[l, mid]$ 和 $[mid + 1, r]$，能成为 $[l, r]$ 这个区间答案的等价类一定满足其中一个端点落在了 $mid$ 或者 $mid + 1$ 上。很显然，如果一个等价类连两个子区间都无法跨过，那肯定吃不完整个大的区间，而有端点落在了 $mid, mid + 1$ 的等价类有可能跨过所在的子区间，然后吃了相邻区间后折回来吃之前剩下的，于是对于一个子区间只需要保留为其前、后缀的等价类的信息即可。  
更具体地合并方式，枚举左边的后缀，暴力右左横跳，能往右走就往右走，不能往右走了就折回头往左走，走到走不动位为止，如果生成的新的等价类有一端在合并过后的左、右端点上，则把它扔进合并后区间的前后缀集合里面，顺便维护等价类大小即可，整个过程可以双指针维护。  

---

## 作者：_Ch1F4N_ (赞：5)

好题。

我们一点点来分析。

首先怎么做 $O(n^2 \times q)$ 暴力？

考虑判定一条鱼是否可能成为活到最后的鱼：先不断往左吃，吃不动就不断往右吃，在吃完整个区间前假若两边都吃不动就完蛋了。

现在要快速计算一个区间的答案，还需要支持修改，注意到我们并没有比较好的简化答案计算过程的办法，于是考虑去合并两个区间的答案，假若可以快速合并，就可以利用线段树解决问题。

考虑对于一个区间而言，什么是重要的，无疑是能活到最后的鱼，并且你发现，活到最后的鱼其实是本质相同的，因为吃完这个区间后大小都已经变成了区间内所有鱼大小和，考虑在合并两个区间的时候判断什么样的鱼有可能会成为活到最后的鱼。

注意到，合并区间后活到最后的鱼在原区间中至少要吃完一个前缀或者一个后缀的鱼，不然这条鱼无法离开原区间在合并后的区间中必然也没法在受到影响成为能吃完一整个区间的鱼，并且与前文提到的能吃完一个区间的鱼是本质相同的一点相仿，对于一个相同的前缀或者后缀而言，能吃完并且仅仅能吃完这个前缀或者后缀的鱼也是本质相同的，因为吃完后大小变为了前缀或者是后缀中鱼的大小和。

考虑刻画一下这样的前缀后缀，注意，我们只需要刻画存在鱼能吃完并且仅仅只能吃完，不能再继续吃下去的前后缀，我们以前缀为例子。

我们声称，这样的前缀 $[1,i]$ 一定都满足 $a_i > \sum_{j=1}^{i-1} a_j$，这是显然的，不然你吃完这个前缀肯定可以再吃下去，实际上，这样的 $i$ 至多只有 $\log V$ 个，因为从前往后扫，每扫到一个符合条件的 $i$，前缀和必定翻倍，而至多翻倍 $\log V$ 次。

至此我们可以直到要维护什么信息了，对于一个区间维护两个下标集合 $pre_1,pre_2,\dots,pre_k$ 与 $suf_1,suf_2,\dots,suf_l$ 分别表示满足自身大小大于其前缀大小和或者后缀大小和的所有下标，同时对于每个 $[pre_i,pre_{i+1}),(suf_{i+1},suf_{i+1}]$ 维护这个区间内所有鱼大小和与有多少条鱼可以吃掉 $pre_i$ 或者 $suf_i$ 代表的鱼（$pre_{k+1},suf_{l+1}$ 在区间外面，代表的鱼大小为正无穷），注意，由于定义可得，区间内的鱼一定无法吃掉 $pre_{i+1},suf_{i+1}$ 代表的鱼，并且吃掉 $pre_i,suf_i$ 代表的鱼后一定可以进一步吃掉前缀 $[1,pre_{i+1})$ 或者后缀 $(suf_{i+1},len]$。

合并区间时貌似不好考虑一类信息对另一类的贡献关系，所以考虑原来的信息合并后变成了什么，于是我们考虑先把 $pre_i,suf_i$ 以及段内和简单处理出来，求每个段内能吃完一个前缀或后缀的鱼数量则对于每个 $[pre_i,pre_{i+1}),(suf_{i+1},suf_i]$ 内能吃完一个前缀或者后缀的鱼处理其在合并后能吃完的鱼的形态，具体而言，处理与暴力类似，但是注意到我们只需要管合并前的区间中所有 $pre_i,suf_i$，因为根据上面我们知道只要能吃完端点就一定能吃完一段，因此对于所有端点考虑即可，不过这样处理一段就是 $O(\log V)$ 处理 $O(\log V)$ 段就爆炸了，但是你考虑这里具有一个单调性：鱼在合并后的区间吃之前假若在原区间中吃了越多的鱼，在合并后也会吃越多的鱼，也就是可以直接在段 $[pre_i,pre_{i+1}),(suf_{i+1},suf_i]$ 的基础上去处理段 $[pre_{i+1},pre_{i+2}),(suf_{i+2},suf_{i+1}]$，具体可以用一个双指针状物简单实现，如此便做到了 $O(n \log V + q \log n \log V)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 1e5+114;
int a[maxn];
int n,q;
struct Node{
    int pos,sum,cnt;
    Node(int p=0,int s=0,int c=0){
        pos=p;
        sum=s;
        cnt=c;
    }
};
struct node{
    vector<Node> pre,suf;
    node(){
        pre.clear(),suf.clear();
        return ;
    }
    node operator+(const node &x)const{
        node res=node();
        res.pre=pre;
        int sum=0,lst=0;
        for(Node now:res.pre) sum+=now.sum;
        for(Node now:x.pre){
            if(a[now.pos]>sum) res.pre.back().sum+=lst,lst=0,res.pre.push_back(now);
            else lst+=now.sum;
        }
        res.pre.back().sum+=lst;
        sum=lst=0;
        res.suf=x.suf;
        for(Node now:res.suf) sum+=now.sum;
        for(Node now:suf){
            if(a[now.pos]>sum) res.suf.back().sum+=lst,lst=0,res.suf.push_back(now);
            else lst+=now.sum;
        }
        res.suf.back().sum+=lst;
        for(int i=0;i<(int)res.pre.size();i++) res.pre[i].cnt=0;
        for(int i=0;i<(int)res.suf.size();i++) res.suf[i].cnt=0; 
        sum=lst=0;
        int l=-1,r=-1;//expand
        int lt=-1,rt=-1;//pos
        sum=0;
        for(int i=0;i<(int)pre.size();i++){
            while(l<i){
                l++;
                sum+=pre[l].sum;
            }
            while(l+1<pre.size()&&sum>=a[pre[l+1].pos]){
                l++;
                sum+=pre[l].sum;
            }
            if(l==(int)pre.size()-1){
                while(r+1<x.pre.size()&&sum>=a[x.pre[r+1].pos]){
                    r++;
                    sum+=x.pre[r].sum;
                }
            }
            while(l>-1&&rt+1<res.pre.size()&&res.pre[rt+1].pos<=pre[l].pos) rt++;
            while(r>-1&&rt+1<res.pre.size()&&res.pre[rt+1].pos<=x.pre[r].pos) rt++;
            res.pre[rt].cnt+=pre[i].cnt;
            if(rt==(int)res.pre.size()-1) res.suf.back().cnt+=pre[i].cnt;
        }
        l=r=-1;
        lt=rt=-1;
        sum=0;
        for(int i=0;i<(int)suf.size()-1;i++){
            while(l<i){
                l++;
                sum+=suf[l].sum;
            }
            while((l+1<suf.size()&&sum>=a[suf[l+1].pos])||(r+1<x.pre.size()&&sum>=a[x.pre[r+1].pos])){
                while(l+1<suf.size()&&sum>=a[suf[l+1].pos]){
                    l++;
                    sum+=suf[l].sum;
                }
                while(r+1<x.pre.size()&&sum>=a[x.pre[r+1].pos]){
                    r++;
                    sum+=x.pre[r].sum;
                }                
            }
            if(l==(int)suf.size()-1){
                while(rt+1<(int)res.pre.size()&&res.pre[rt+1].pos<=pre.back().pos) rt++;
                while(r>-1&&rt+1<(int)res.pre.size()&&res.pre[rt+1].pos<=x.pre[r].pos) rt++;
                res.pre[rt].cnt+=suf[i].cnt;
            }
            if(r==(int)x.pre.size()-1){
                while(lt+1<(int)res.suf.size()&&res.suf[lt+1].pos>=x.suf.back().pos) lt++;
                while(l>-1&&lt+1<(int)res.suf.size()&&res.suf[lt+1].pos>=suf[l].pos) lt++;
                res.suf[lt].cnt+=suf[i].cnt;
            }
        }
        l=r=-1;
        lt=rt=-1;
        sum=0;
        for(int i=0;i<(int)x.pre.size();i++){
            while(r<i){
                r++;
                sum+=x.pre[r].sum;
            }
            while((l+1<suf.size()&&sum>=a[suf[l+1].pos])||(r+1<x.pre.size()&&sum>=a[x.pre[r+1].pos])){
                while(l+1<suf.size()&&sum>=a[suf[l+1].pos]){
                    l++;
                    sum+=suf[l].sum;
                }
                while(r+1<x.pre.size()&&sum>=a[x.pre[r+1].pos]){
                    r++;
                    sum+=x.pre[r].sum;
                }                
            }
            if(l==(int)suf.size()-1){
                while(rt+1<(int)res.pre.size()&&res.pre[rt+1].pos<=pre.back().pos) rt++;
                while(r>-1&&rt+1<(int)res.pre.size()&&res.pre[rt+1].pos<=x.pre[r].pos) rt++;
                res.pre[rt].cnt+=x.pre[i].cnt;
            }
            if(r==(int)x.pre.size()-1){
                while(lt+1<(int)res.suf.size()&&res.suf[lt+1].pos>=x.suf.back().pos) lt++;
                while(l>-1&&lt+1<(int)res.suf.size()&&res.suf[lt+1].pos>=suf[l].pos) lt++;
                res.suf[lt].cnt+=x.pre[i].cnt;
            }
        }
        l=r=-1;
        lt=rt=-1;
        sum=0;
        for(int i=0;i<(int)x.suf.size()-1;i++){
            while(r<i){
                r++;
                sum+=x.suf[r].sum;
            }
            while(r+1<x.suf.size()&&sum>=a[x.suf[r+1].pos]){
                r++;
                sum+=x.suf[r].sum;
            }
            if(r==(int)x.suf.size()-1){
                while(l+1<suf.size()&&sum>=a[suf[l+1].pos]){
                    l++;
                    sum+=suf[l].sum;
                }
            }
            while(r>-1&&lt+1<(int)res.suf.size()&&res.suf[lt+1].pos>=x.suf[r].pos) lt++;
            while(l>-1&&lt+1<(int)res.suf.size()&&res.suf[lt+1].pos>=suf[l].pos) lt++;
            res.suf[lt].cnt+=x.suf[i].cnt;
            if(lt==(int)res.suf.size()-1) res.pre.back().cnt+=x.suf[i].cnt;
        }
        return res;
    }
}tr[maxn<<2];
void build(int cur,int lt,int rt){
    if(lt==rt){
        tr[cur]=node();
        tr[cur].pre.push_back(Node(lt,a[lt],1));
        tr[cur].suf.push_back(Node(rt,a[rt],1));
        return ;
    }
    int mid=(lt+rt)>>1;
    build(cur<<1,lt,mid);
    build(cur<<1|1,mid+1,rt);
    tr[cur]=tr[cur<<1]+tr[cur<<1|1];
    /*
    cout<<lt<<' '<<rt<<'\n';
    cout<<"Pre:";
    for(Node now:tr[cur].pre) cout<<now.pos<<' '<<now.sum<<' '<<now.cnt<<'|';
    cout<<'\n';
    cout<<"Suf:";
    for(Node now:tr[cur].suf) cout<<now.pos<<' '<<now.sum<<' '<<now.cnt<<'|';
    cout<<'\n';*/
}
void change(int cur,int lt,int rt,int pos,int v){
    if(lt==rt){
        a[lt]=v;
        tr[cur]=node();
        tr[cur].pre.push_back(Node(lt,a[lt],1));
        tr[cur].suf.push_back(Node(rt,a[rt],1));
        return ;
    }
    int mid=(lt+rt)>>1;
    if(pos<=mid) change(cur<<1,lt,mid,pos,v);
    else change(cur<<1|1,mid+1,rt,pos,v);
    tr[cur]=tr[cur<<1]+tr[cur<<1|1];
}
node ask(int cur,int lt,int rt,int l,int r){
    if(l<=lt&&rt<=r) return tr[cur];
    int mid=(lt+rt)>>1;
    if(l<=mid&&r>mid) return ask(cur<<1,lt,mid,l,r)+ask(cur<<1|1,mid+1,rt,l,r);
    else if(l<=mid) return ask(cur<<1,lt,mid,l,r);
    else return ask(cur<<1|1,mid+1,rt,l,r);
}
signed main(){
    //freopen("1.in","r",stdin);
    //freopen("1.ans","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    build(1,1,n);
    cin>>q;
    while(q--){
        int ty,x,y;
        cin>>ty>>x>>y;
        if(ty==1) change(1,1,n,x,y);
        else cout<<ask(1,1,n,x,y).pre.back().cnt<<'\n';
    }
    return 0;
}
/*
5
17 2 8 3 13
1
2 1 5
*/
/*
3
17 2 8
0
*/
```

---

## 作者：云浅知处 (赞：5)

对于一个区间 $[l,r]$，如果 $\sum_{i=l}^ra_i<\min(a_{l-1},a_{r+1})$，称这样的区间 $[l,r]$ 为阻塞区间。

这里认为 $a_0=a_{n+1}=\infty$。

首先有一些显然的性质：阻塞区间的个数不超过 $2n$，且两个阻塞区间要么包含，要么不交。考虑一次询问 $[L,R]$，发现如果 $i$ 不合法了，意味着有一个阻塞区间 $i\in[l,r]\subseteq [L,R]$ 使得它不合法了。同理也可以发现，如果不存在包含 $i$ 的阻塞区间，那么 $i$ 一定合法。

考虑直接用线段树维护当前节点 $[L,R]$ 内还有多少个点没有被阻塞区间覆盖。合并的时候，有可能左边的一段后缀和右边的一段前缀本来都是阻塞区间，但它们合并起来之后就合法了。注意到这些区间的个数不超过 $O(\log V)$，而且这些区间之间都是互相相交的，我们只需要找到最大的一个阻塞区间。双指针即可。

综上，时间复杂度 $O(N\log V+Q\log N\log V)$，其中 $V=10^9$ 为值域。

我比较懒，所以代码写的多了一个 $\log V$，看上去跑的也非常快啊，最慢的点才 0.8s 左右。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int N=1e5+5;
int a[N],n,q;

struct Info{
	int p;ll s;int c;
	Info(int P=0,ll S=0,int C=0):p(P),s(S),c(C){}
};
struct Node{
	int l,r,cnt;ll sum;
	vector<Info>pl,pr;
};
Node d[N<<2];

Node op(Node lc,Node rc){
	Node res;
	res.l=lc.l,res.r=rc.r,res.sum=lc.sum+rc.sum;
	res.pl=lc.pl,res.pr=rc.pr;
	
	res.cnt=lc.cnt+rc.cnt;
	
	if(!lc.pr.empty())res.cnt+=lc.pr.back().c;
	if(!rc.pl.empty())res.cnt+=rc.pl.back().c;
	
	vector<pair<int,Info> >L,R;
	L.emplace_back(mk(-1,Info(rc.l,0,0)));
	for(auto [j,s,c]:lc.pr)L.emplace_back(mk(-1,Info(j,s,c)));
	R.emplace_back(mk(-1,Info(lc.r,0,0)));
	for(auto [j,s,c]:rc.pl)R.emplace_back(mk(-1,Info(j,s,c)));
	
	for(int i=0;i<L.size();i++){
		for(int j=0;j<R.size();j++){
			int l=L[i].se.p,r=R[j].se.p;
			ll sum=L[i].se.s+R[j].se.s;
			if(sum<min(a[l-1],a[r+1]))cmax(L[i].fi,j),cmax(R[j].fi,i);
		}
	}
	
	for(int i=L.size()-1;i>=0;i--){
		if(L[i].fi==-1)continue;
		int j=L[i].fi;
		res.cnt-=L[i].se.c+R[j].se.c;
		break;
	}
	
	int nl=lc.cnt,nr=rc.cnt;
	if(!lc.pl.empty())nl+=lc.pl.back().c;
	if(!lc.pr.empty())nl+=lc.pr.back().c;
	if(!rc.pl.empty())nr+=rc.pl.back().c;
	if(!rc.pr.empty())nr+=rc.pr.back().c;

	bool cl=0,cr=0;int nw=0;
	
	res.pl=lc.pl;
	int cur=0;
	for(auto [j,A]:R){
		auto [p,s,c]=A;
		if(j!=-1)cmax(cur,L[j].se.c+c);
		if(s+lc.sum>=a[p+1])continue;
		int cc=c+nl-cur;
		res.pl.emplace_back(Info(p,s+lc.sum,cc)),cl=true,nw=c;
	}
	cur=0;
	for(auto [j,A]:L){
		auto [p,s,c]=A;
		if(j!=-1)cmax(cur,R[j].se.c+c);
		if(s+rc.sum>=a[p-1])continue;
		int cc=c+nr-cur;
		res.pr.emplace_back(Info(p,s+rc.sum,cc)),cr=true,nw=c;
	}
	
	if(cl){
		res.cnt=rc.cnt;
		if(!rc.pl.empty())res.cnt+=rc.pl.back().c;
		res.cnt-=nw;		
	}
	if(cr){
		res.cnt=lc.cnt;
		if(!lc.pr.empty())res.cnt+=lc.pr.back().c;
		res.cnt-=nw;
	}
	
	return res;
}

struct sgt{
	Node d[N<<2];
	#define ls(p) (p<<1)
	#define rs(p) (p<<1|1)
	void pushup(int p){d[p]=op(d[ls(p)],d[rs(p)]);}
	void build(int l,int r,int p){
		if(l==r)return d[p].l=d[p].r=l,d[p].cnt=1,d[p].sum=a[l],void();
		int mid=(l+r)>>1;build(l,mid,ls(p)),build(mid+1,r,rs(p)),pushup(p);
	}
	void modify(int x,int v,int ql,int qr,int p){
		if(ql==qr)return d[p].sum=v,void();
		int mid=(ql+qr)>>1;
		if(x<=mid)modify(x,v,ql,mid,ls(p));
		else modify(x,v,mid+1,qr,rs(p));
		pushup(p);
	}
	Node qry(int l,int r,int ql,int qr,int p){
		if(l<=ql&&qr<=r)return d[p];
		int mid=(ql+qr)>>1;
		if(l>mid)return qry(l,r,mid+1,qr,rs(p));
		else if(r<=mid)return qry(l,r,ql,mid,ls(p));
		return op(qry(l,r,ql,mid,ls(p)),qry(l,r,mid+1,qr,rs(p)));
	}
}T;

signed main(void){

	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	T.build(1,n,1);
	
	q=read();
	for(int i=1;i<=q;i++){
		int op=read();
		if(op==1){
			int x=read(),y=read();
			a[x]=y,T.modify(x,y,1,n,1);
		}
		else{
			int l=read(),r=read();
			auto res=T.qry(l,r,1,n,1);
			cout<<res.cnt<<'\n';
		}
	}

	return 0;
}
```

---

## 作者：EuphoricStar (赞：4)

为了方便，设 $a_0 = a_{n + 1} = \infty$。

考虑拎出来所有区间 $[l, r]$ 使得 $\sum\limits_{i = l}^r a_i < \min(a_{l - 1}, a_{r + 1})$。那么 $[l, r]$ 中的所有鱼都不能吃到 $[l, r]$ 外面的鱼。那么 $[1, n]$ 中能吃掉所有鱼的鱼，一定不被除了 $[1, n]$ 之外的区间包含。

考虑从 $[i, i]$ 开始，通过线段树上二分得到包含它的最小的区间 $[l, r]$ 使得 $\sum\limits_{i = l}^r a_i < \min(a_{l - 1}, a_{r + 1})$。每次跳出去区间和至少加倍，所以至多跳 $\log V$ 次。所以这样的区间有 $O(n \log V)$ 种。加上线段树上二分的 $\log n$，找出所有这样的区间的复杂度为 $O(n \log n \log V)$。

先考虑没有修改：因为不能往 $[l, r]$ 外面吃了，所以可能会导致 $[l, r]$ 的一个前缀和后缀不能吃完 $[l, r]$ 了。我们用上面的方法可以找到这样的前缀和后缀。我们把不能往外面吃的鱼的区间拎出来，给它们区间加 $1$，查询即查询 $[l, r]$ 最小值个数（因为还有一些大区间 $L \le l \le r \le R$ 完全包含 $[l, r]$）。

有修改的话，我们找出所有包含 $x - 1, x, x + 1$ 的区间（要 $\pm 1$ 是因为修改 $x$ 可能会影响所有 $r = x - 1$ 或者 $l = x + 1$ 的区间），把它们删除，修改后重新加入即可。

所以总复杂度就是 $O((n + q) \log n \log V)$。

[code](https://loj.ac/s/1883935)，写起来有点臭。

---

## 作者：ZnPdCo (赞：3)

### 怎么写暴力？

我们可以有一个暴力方法，就是从当前鱼所在的位置 $[x,x]$ 开始，向左线段树上二分找到第一个大于当前区间和的数，然后把这个点以后的吃掉；紧接着向右线段树上二分，找到第一个大于当前区间和的数，把这个点以前的吃掉。

为什么是对的呢？感性一点，每次吃掉一个原本吃不掉的数说明区间和会翻倍，所以最多重复上述过程 $O(\log A)$ 次，每次线段树上二分是 $O(\log n)$ 的。

时间复杂度 $O(nq\log n\log A)$。

### 怎么优化？

如果我们考虑预处理一个点的答案，是不行的，因为答案会随查询区间的变化而变化。

所以我们不妨换个视角，用线段树来维护这些信息。

维护什么呢？我们可以维护每个区间内的要维护的点，然后每次合并都重新计算两个子区间内的点对于这个区间的答案。

什么点不用维护了呢，对于那种到达不了区间左端点和右端点的点，我们可以不用维护她们了，因为阻挡她们的点已经在区间内出现了，不会变得更优。

欸，感觉好像更劣了说。

### 一些点是等价的？

我们考虑将一个点 $x$ 表示为一个区间 $[l,r]$，这个表示的意思是这个点当前最左可以到达 $l$，最右可以到达 $r$。

对于两个点，如果她们能够表示为同一个区间，这两个点不是等价的吗？

那么如果我们朴素的去想，不记录一个点，而是记录一个区间，对于重复的区间我们就打个标记，会不会更优呢？

我们有一个结论，假如把所有点都表示为一个区间，那么包含点 $p$ 的区间只有 $O(\log A)$ 个！

具体地，我们用线段树维护所有能够到达左端点而到达不了右端点的区间，能够到达右端点而到达不了左端点的区间，以及能够到达左端点和右端点的区间。这里对于重复的区间我们打个标记表示出现了多少次。

那么，这些包含了左端点 $l$ 和右端点 $r$ 的区间，只有 $O(\log A)$ 个。

那么，一个节点的信息，竟然只有 $O(\log A)$ 个！

现在我们终于有一些像样一点的复杂度的做法了。我们合并的时候直接枚举所有区间，然后去做最暴力的那个做法就可以了。

时间复杂度 $O((n+q\log n)\log n\log^2 A)$。

嗯，只有 25 pts。

### 哪些点可以成为区间端点？

我们有一个结论，能够成为 $[l,r]$ 这个线段树区间的答案（就是上面能够到达左端点而到达不了右端点的区间，能够到达右端点而到达不了左端点的区间，以及能够到达左端点和右端点的区间）的区间端点，一定在 $[l,m]$ 和 $[m+1,r]$ 中的答案的区间端点中出现过。

现在我们似乎可以砍掉线段树二分？每次我们直接不用二分，直接跳到上一个可能的端点判一下是否合法就可以了。

时间复杂度 $O(n+q\log n)\log^2 A)$。

### 答案区间不断增大？

首先，能够到达左端点而到达不了右端点的区间，一定是呈包含关系的（废话，左端点固定，所以肯定呈包含关系），我们从最小的区间向大区间开始做，区间和是不断增加的，那么能够到达的区间是不断增大的。

所以，我们可以直接用一个指针记录当前到哪了，然后每一次直接和当前计算的区间做一个判断，如果计算的区间比上一个区间小，我们直接把她变成上一个区间的答案，然后继续做就好了，否则就用上面的做法。

那么每一个点均摊只会访问 $O(1)$ 次，所以时间复杂度为 $O((n+q\log n)\log A)$。

我的做法似乎在洛谷上有点卡常（需要多交几发卡），但是 AT 上跑得非常快。

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
#define N 100010
using namespace std;
// 略去IO
struct info {
    // 左端点，右端点，可以到达这种状态的位置数
    int l, r, cnt, val;
    info(int l = 0, int r = 0, int cnt = 0, int val = 0) : l(l), r(r), cnt(cnt), val(val) {}
};
int n, q, p[N], op, x, y;
bool flag;  // 表示是否是第一个，如果不是双指针不重置
info solve(int l, int r, info x, vector<pair<int, int>> &e) {
    static vector<pair<int, int>>::iterator L, R;
    if(flag) L = lower_bound(e.begin(), e.end(), make_pair(x.l, 0ll)), R = lower_bound(e.begin(), e.end(), make_pair(x.r, 0ll));
    else {
        if(L->first > x.l) while(L->first > x.l) L--;
        else {
            x.val += lower_bound(e.begin(), e.end(), make_pair(x.l, 0ll))->second - p[x.l];
            x.l = L->first, x.val += p[x.l] - L->second;
        }
        if(R->first < x.r) while(R->first < x.r) R++;
        else {
            x.val -= lower_bound(e.begin(), e.end(), make_pair(x.r, 0ll))->second;
            x.r = R->first, x.val += R->second;
        }
    }
    while(1) {
        if(l < x.l && p[x.l - 1] <= x.val) {
            assert(L != e.begin());
            x.val += L->second - p[x.l];
            L--;
            x.l = L->first, x.val += p[x.l] - L->second;
        } else if(x.r < r && p[x.r + 1] <= x.val) {
            x.val -= R->second;
            R++;
            x.r = R->first, x.val += R->second;
        } else break;
    }
    return flag = 0, x;
}
struct node {
    int sum, mx, l, r;
    // L, R 表示前驱、后缀的区间，full表示整个区间
    vector<info> L, R;
    vector<pair<int, int>> e;
    info full;
    node(int x = 0, int y = 0, bool flag = 0) : sum(y), mx(y), l(x), r(x), full(x, x, flag, y) {
        if(flag) e.emplace_back(x, y);
    }
    friend node operator+(const node& a, const node& b) {
        node c;
        c.l = a.l, c.r = b.r;
        c.sum = a.sum + b.sum, c.mx = max(a.mx, b.mx);
        vector<pair<int, int>> e;
        for(auto i : a.e) e.emplace_back(i.first, i.second);
        for(auto i : b.e) e.emplace_back(i.first, a.sum + i.second);

        vector<info> seq, seq1;
        for(auto i : a.L) seq.push_back(i);
        for(auto i : b.R) seq.push_back(i);
        flag = 1; for(auto i : a.R) seq.push_back(solve(c.l, c.r, i, e));
        seq.push_back(solve(c.l, c.r, a.full, e));
        flag = 1; for(auto i : b.L) seq.push_back(solve(c.l, c.r, i, e));
        seq.push_back(solve(c.l, c.r, b.full, e));
        sort(seq.begin(), seq.end(), [](info a, info b) {
            if(a.l != b.l) return a.l < b.l;
            return a.r < b.r;
        });
        for(int i = 0; i < seq.size(); i++) {
            if(i == 0 || seq[i].l != seq[i - 1].l || seq[i].r != seq[i - 1].r) {
                seq1.push_back(seq[i]);
            } else {
                int tmp = seq1.back().cnt + seq[i].cnt;
                seq1.pop_back();
                seq1.push_back(info(seq[i].l, seq[i].r, tmp, seq[i].val));
            }
        }
        for(auto i : seq1) {
            if(i.l == c.l && i.r == c.r) {
                c.full = i;
            } else if(i.l == c.l) {
                c.L.push_back(i);
                c.e.emplace_back(i.r, i.val);
            } else if(i.r == c.r) {
                c.R.push_back(i);
                c.e.emplace_back(i.l, c.sum - i.val + p[i.l]);
            }
        }
        reverse(c.R.begin(), c.R.end());
        c.e.emplace_back(c.l, p[c.l]);
        c.e.emplace_back(c.r, c.sum);
        sort(c.e.begin(), c.e.end());
        c.e.erase(unique(c.e.begin(), c.e.end()), c.e.end());
        return c;
    }
} t[N * 4];
void build(int l, int r, int pos) {
    if(l == r) return (void)(t[pos] = node(l, p[l], 1));
    int mid = (l + r) >> 1;
    build(l, mid, ls(pos)), build(mid + 1, r, rs(pos));
    t[pos].l = t[ls(pos)].l, t[pos].r = t[rs(pos)].r;
    t[pos] = t[ls(pos)] + t[rs(pos)];
}
void update(int x, int l, int r, int pos, int val) {
    if(l == r) return (void)(t[pos] = node(l, val, 1));
    int mid = (l + r) >> 1;
    if(x <= mid) update(x, l, mid, ls(pos), val);
    if(mid < x) update(x, mid + 1, r, rs(pos), val);
    t[pos] = t[ls(pos)] + t[rs(pos)];
}
node query(int nl, int nr, int l, int r, int pos) {
    if(nl <= l && r <= nr) return t[pos];
    int mid = (l + r) >> 1;
    if(nl <= mid && mid < nr) return query(nl, nr, l, mid, ls(pos)) + query(nl, nr, mid + 1, r, rs(pos));
    if(nl <= mid) return query(nl, nr, l, mid, ls(pos));
    return query(nl, nr, mid + 1, r, rs(pos));
}
signed main() {
    // freopen("06-01.in", "r", stdin);
    read(n);
    for(int i = 1; i <= n; i++) read(p[i]);
    read(q);
    build(1, n, 1);
    while(q--) {
        read(op, x, y);
        if(op == 1) {
            p[x] = y;
            update(x, 1, n, 1, y);
        } else if(op == 2) {
            write(query(x, y, 1, n, 1).full.cnt, "\n");
        }
        // if(q % 10000 == 0) cerr << q << endl;
    }
}
```

---

## 作者：SnowTrace (赞：3)

设原重量序列为 $a$。

先考虑如何处理一组询问。

枚举起点，我们可以线段树二分出当前左边第一个比现在的鱼重量大的位置和右边第一个比现在的鱼重量大的位置，然后迭代下去。

因为每次线段树二分后，重量大小至少翻倍，所以时间复杂度是 $O(nq\log V \log n)$ 的。

--------------------------

然后不会做了。

尝试去思考一些性质。

我们希望通过预处理来降低时间复杂度，但是在这里预处理的信息不一定有用，因为你有可能被询问的端点挡住导致走不出去。

我们希望使用线段树来维护这个结构。

我们称从 $i$ 出发能扩展到的极大区间 $[l_i,r_i]$ 为 $i$ 的极大区间。

首先如果在一个询问 $[l,r]$ 的子区间内 $[l',r'] $ 中，对于一个起始位置 $i$，如果它左端点走不到 $l'$ 并且右端点走不到 $r'$，就一定不可能走到 $[l,r]$。

所以我们只关心一个区间内，能走到区间左端点的所有起点和能走到区间右端点的所有起点。（这里我们只考虑区间内部的数，不允许走出去）

注意到一个性质是，包含位置 $p$ 的极大区间只有 $O(\log V)$ 个。

我们根据一开始的暴力算法，从 $p$ 向外线段树二分拓展，只有拓展到的区间才有可能是一个极大区间，否则考虑其左右端点必有一个比当前的和小，也就是说还能再走一步，必然不是一个极大区间。

从而我们可以知道只考虑区间 $[l,r]$ 时，包含 $l,r$ 的极大区间都只有 $O(\log V)$ 个，从而可以直接通过记录位置的方式进行维护。

然后考虑怎么合并。

我们考虑把 $[l,r]$ 从 $[l,m],[m+1,r]$ 合并过来。

此时有一个性质是 $[l,r]$ 中包含 $l$ 或 $r$ 的极长区间的端点一定是一个在 $[l,m],[m+1,r]$ 区间内的被记录的极长区间端点。换句话说，现在只有被记录在线段树里面的位置才是有用的，其他的位置都不可能成为极长区间的一个端点。 

设 $[p,m]$ 是 $[l,m]$ 中一个极长区间，如果其往右拓展时停在一个未被记录的点 $q$ 上，则此时有 $\sum_{p}^{q-1}a_i<a_{q}$，从而也可以知道 $\sum_{m+1}^{q-1}a_i<a_{q}$，从而 $q$ 一定是某个极长区间的端点，矛盾。

然后我们维护只需要考虑双指针，实现起来比较麻烦。

---

## 作者：Leasier (赞：3)

虽然我赛后意识到有一个 $O(qn)$ 的高妙暴力，但这不影响我赛时第一反应的暴力是 $O(qn \log n \log w)$ 的，其中 $w$ 为值域 $10^9$。下面我来描述一下这个暴力：

- 显然每条鱼吃鱼的过程都可以被描述为先往左边尽量吃，吃不动了再往右边尽量吃，如此反复，直到吃完或发现吃不完。
- 具体实现时，用线段树维护 $a_i$，每次向两边二分求出最大吃到的位置即可。
- 注意到每当我们遇到一条一开始吃不掉的鱼但在 $O(1)$ 次上述操作后把它吃了，则当前鱼的大小至少倍增，于是左右二分次数均为 $O(\log w)$。
- 由于线段树上二分的时间复杂度为 $O(\log n)$，总时间复杂度为 $O(qn \log n \log w)$。

这个时间复杂度显然不能接受。但注意到上面二分次数 $O(\log w)$ 的结论，我们是否可以从这个角度思考来搞事情呢？

~~然后模拟赛时想了 30min 却没有大的进展……~~

------------

不妨从另一个角度思考：猜想这道题需要用线段树维护区间信息，现在我们只需要合并两个区间的信息——尽管具体信息内容未知。

那我们需要维护什么呢？

- 区间左右端点。
- 区间和。
- 该区间的答案。
- 然后呢……？

不妨从目的——该区间的答案——出发，思考我们需要知道什么信息。

- 需要两个子树的答案，因为它们可能继续扩展作为该区间的答案。
- **不**需要扩展后的区间均不为这两个子树区间前后缀的答案，因为它们连这个子树都出不了。
- 需要扩展后的区间为左子树后缀或右子树前缀的答案，因为它们有希望作为该区间的答案。

考虑之前那个暴力的结论：从一个左端点或右端点出发，被卡住的位置只有 $O(\log w)$ 个，于是我们可以在线段树的区间上存下前后缀被卡住的位置及其个数。

合并时直接暴力模拟上面的过程即可做到 $O((n + q \log n) \log^2 w)$。

但事实上注意到最后一种情况的在另一棵子树上扩展后的左右被卡住端点是有单调性的，于是我们不需要每次重新开始扫，于是时间复杂度降为 $O((n + q \log n) \log w)$。

代码：
```cpp
#include <iostream>
#include <vector>

using namespace std;

typedef long long ll;

typedef struct Info_tag {
	ll cur;
	ll goal;
	Info_tag(ll cur_, ll goal_){
		cur = cur_;
		goal = goal_;
	}
} Info;

typedef struct {
	int l;
	int r;
	int cnt;
	ll sum;
	vector<int> v1;
	vector<int> v2;
	vector<Info> v3;
	vector<Info> v4;
} Node;

int a[100007], refa[37], refb[37];
Node tree[400007];

Node operator +(const Node a, const Node b){
	int sizea2 = a.v2.size(), sizeb1 = b.v1.size(), posa = 0, posb = 0;
	ll sum = 0;
	bool flag = false;
	Node ans;
	ans.l = a.l;
	ans.r = b.r;
	ans.cnt = 0;
	ans.sum = a.sum + b.sum;
	ans.v1 = a.v1;
	ans.v2 = b.v2;
	ans.v3 = a.v3;
	ans.v4 = b.v4;
	for (register int i = 0; i < sizea2; i++){
		Info info = a.v4[i];
		info.cur += b.sum;
		if (info.cur < info.goal){
			ans.v4.push_back(info);
			if (!flag){
				flag = true;
				ans.v2.push_back(b.cnt);
			} else {
				ans.v2.push_back(0);
			}
		}
		refa[i] = ans.v4.size() - 1;
	}
	if (flag){
		flag = false;
	} else {
		ans.cnt = b.cnt;
	}
	for (register int i = 0; i < sizeb1; i++){
		Info info = b.v3[i];
		info.cur += a.sum;
		if (info.cur < info.goal){
			ans.v3.push_back(info);
			if (!flag){
				flag = true;
				ans.v1.push_back(a.cnt);
			} else {
				ans.v1.push_back(0);
			}
		}
		refb[i] = ans.v3.size() - 1;
	}
	if (!flag) ans.cnt += a.cnt;
	for (register int i = 0; i < sizea2; i++){
		if (posa < i){
			posa = i;
			sum += a.v4[posa].cur - (posa > 0 ? a.v4[posa - 1].cur : 0);
		}
		while (true){
			flag = false;
			while (posb < sizeb1 && sum >= b.v3[posb].goal){
				sum += (posb + 1 == sizeb1 ? b.sum : b.v3[posb + 1].cur) - b.v3[posb].cur;
				posb++;
				flag = true;
			}
			while (posa < sizea2 && sum >= a.v4[posa].goal){
				sum += (posa + 1 == sizea2 ? a.sum : a.v4[posa + 1].cur) - a.v4[posa].cur;
				posa++;
				flag = true;
			}
			if (posa == sizea2 && posb == sizeb1){
				ans.cnt += a.v2[i];
				break;
			}
			if (!flag){
				if (posa == sizea2){
					ans.v1[refb[posb]] += a.v2[i];
				} else if (posb == sizeb1){
					ans.v2[refa[posa]] += a.v2[i];
				}
				break;
			}
		}
	}
	posa = posb = sum = 0;
	for (register int i = 0; i < sizeb1; i++){
		if (posb < i){
			posb = i;
			sum += b.v3[posb].cur - (posb > 0 ? b.v3[posb - 1].cur : 0);
		}
		while (true){
			flag = false;
			while (posa < sizea2 && sum >= a.v4[posa].goal){
				sum += (posa + 1 == sizea2 ? a.sum : a.v4[posa + 1].cur) - a.v4[posa].cur;
				posa++;
				flag = true;
			}
			while (posb < sizeb1 && sum >= b.v3[posb].goal){
				sum += (posb + 1 == sizeb1 ? b.sum : b.v3[posb + 1].cur) - b.v3[posb].cur;
				posb++;
				flag = true;
			}
			if (posa == sizea2 && posb == sizeb1){
				ans.cnt += b.v1[i];
				break;
			}
			if (!flag){
				if (posa == sizea2){
					ans.v1[refb[posb]] += b.v1[i];
				} else if (posb == sizeb1){
					ans.v2[refa[posa]] += b.v1[i];
				}
				break;
			}
		}
	}
	return ans;
}

inline Node generate(int pos, int val){
	Node ans;
	ans.l = ans.r = pos;
	ans.cnt = 1;
	ans.sum = val;
	ans.v1 = ans.v2 = vector<int>{0};
	ans.v3 = ans.v4 = vector<Info>{Info(0, val)};
	return ans;
}

inline void update(int x){
	tree[x] = tree[x * 2] + tree[x * 2 + 1];
}

void build(int x, int l, int r){
	if (l == r){
		tree[x] = generate(l, a[l]);
		return;
	}
	int mid = (l + r) >> 1;
	build(x * 2, l, mid);
	build(x * 2 + 1, mid + 1, r);
	update(x);
}

void modify(int x, int pos, int val){
	if (tree[x].l == tree[x].r){
		tree[x] = generate(pos, val);
		return;
	}
	if (pos <= ((tree[x].l + tree[x].r) >> 1)){
		modify(x * 2, pos, val);
	} else {
		modify(x * 2 + 1, pos, val);
	}
	update(x);
}

Node query(int x, int l, int r){
	if (l <= tree[x].l && tree[x].r <= r) return tree[x];
	int mid = (tree[x].l + tree[x].r) >> 1;
	if (r <= mid) return query(x * 2, l, r);
	if (l > mid) return query(x * 2 + 1, l, r);
	return query(x * 2, l, r) + query(x * 2 + 1, l, r);
}

int main(){
	int n, q;
	cin >> n;
	for (register int i = 1; i <= n; i++){
		cin >> a[i];
	}
	build(1, 1, n);
	cin >> q;
	for (register int i = 1; i <= q; i++){
		int t;
		cin >> t;
		if (t == 1){
			int x, y;
			cin >> x >> y;
			modify(1, x, y);
		} else {
			int l, r;
			cin >> l >> r;
			cout << query(1, l, r).cnt << endl;
		}
	}
	return 0;
}
```

---

## 作者：YYYmoon (赞：2)

题意相当于维护某条鱼开始的一段区间和，这段（极大的）区间和小于左边和右边的鱼的大小，且扩展的过程中不能出现某段区间和小于左边和右边鱼的情况。

发现还是很繁琐，但发现可能有一群鱼，它们能扩展出来的这个“极大的区间”是相等的，那么不妨把它们作为一个等价类去看。

这时候我们先考虑如何去维护，多次区间查询一定是用线段树的。

又发现，我们在每个线段树节点的区间，都只关心“极大区间”能通向左端点或右端点的鱼。（因为我们想要的是能吃掉整个查询区间的鱼，如果连小区间的左或右端点都达不到，后面跟其他区间合并时也不可能吃掉整个区间）

假设包含左端点，那么这个“极大区间”的区间和每多扩展一次，至少翻倍。（因为上一次扩展是被右边某个大于整个区间和的鱼拦住了，那么下一次扩展从这条鱼开始，一定能扩展至左端点，那么极大区间和翻倍）那么这样，每个节点至多只用维护 $\log V$ 个极大区间了。

给一个图方便理解，横线是极大区间，斜线是能扩展到当前极大区间的鱼。

![](https://cdn.luogu.com.cn/upload/image_hosting/xsdk7k2t.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

线段树每次 ```pushup``` 时只需要用双指针维护。（实现细节看代码吧，有非常详尽的注释）（第一次写的时候也非常懵，参考了别人的写法）


```cpp
#include<bits/stdc++.h>
#define int long long//陋习
#define lid (id<<1)
#define rid (id<<1|1)
using namespace std;
const int maxn=1e5+5;
int n,q,a[maxn];
struct nod{
	int s,c,lim;//划分若干个区间，其中前/后缀和（跟在L/R内有关）为s，能吃掉这个区间的鱼有c条，被lim拦住了 
};
struct node{
	int l,r,sum,cnt;//整个区间的左右端点上的权值是l/r，这里是方便处理过不去区间的情况；sum表示全区间和；cnt表示能吃掉全区间的鱼的个数 
	vector<nod>L,R;//以L为例，表示划分的区间左端点和线段树上区间左端点重合的区间们。由(1)(2)(3)三部分贡献组成 
	 
	node operator +(const node z) const{
		node x={l,z.r,sum+z.sum,0,L,z.R};//(1)这里是从左区间出发，左边顶头，右边仍在左区间内 
		vector<nod>fl=R,fr=z.L,al,ar;
		fl.push_back({sum,cnt,0});//整个区间的要分别加入 
		fr.push_back({z.sum,z.cnt,0});
		
		int now,tmp,pl=0,pr=-1,tot=fl[0].c;//pr表示是被某个lim拦住的 
		while(1){
			now=fl[pl].s+(pr==-1?0:fr[pr].s);//特判-1：处理根本过不去的情况 
			tmp=(pr==-1)?z.l:fr[pr].lim;//事实上只要能过z.l，那么下一个被拦截的点一定是在我们分出来区间的lim里面了，不会产生新的区间 
			if(now>=tmp&&pr+1<fr.size()) pr++;
			else if(pl==fl.size()-1) break;
			else{
				if(now<fl[pl].lim){
					if(pr==fr.size()-1) ar.push_back({now,tot,fl[pl].lim});
					tot=0;
				}
				pl++,tot+=fl[pl].c;//既然这里的元素都大于整个区间和了，那肯定能走完区间 
			}
		}
		if(pr==fr.size()-1) x.cnt+=tot;
		else x.L.push_back({now,tot,tmp});//(2)这里是从左区间，不仅走满左区间了，还跨越到右区间的贡献 
		swap(fl,fr);
		
		pl=0,pr=-1,tot=fl[0].c;
		while(1){
			now=fl[pl].s+(pr==-1?0:fr[pr].s);
			tmp=(pr==-1)?r:fr[pr].lim;
			if(now>=tmp&&pr+1<fr.size()) pr++;
			else if(pl==fl.size()-1) break;
			else{
				if(now<fl[pl].lim){
					if(pr==fr.size()-1) al.push_back({now,tot,fl[pl].lim});//(3)这里是从右区间出发，且走满左区间了 
					tot=0;
				}
				pl++,tot+=fl[pl].c;
			}
		}
		if(pr==fr.size()-1) x.cnt+=tot;
		else x.R.push_back({now,tot,tmp});
		
		for(nod it:al) x.L.push_back(it);
		for(nod it:ar) x.R.push_back(it);
		return x;	
	} 
}t[maxn<<2];
void build(int id,int l,int r){
	if(l==r) return t[id]={a[l],a[l],a[l],1},void();
	int mid=(l+r)>>1;
	build(lid,l,mid),build(rid,mid+1,r);
	t[id]=t[lid]+t[rid];
}
void change(int id,int l,int r,int p,int v){
	if(l==r) return t[id]={v,v,v,1},void();
	int mid=(l+r)>>1;
	if(p<=mid) change(lid,l,mid,p,v);
	else change(rid,mid+1,r,p,v);
	t[id]=t[lid]+t[rid];
}
node query(int id,int l,int r,int vl,int vr){
	if(vl<=l&&r<=vr) return t[id];
	int mid=(l+r)>>1;
	if(vr<=mid) return query(lid,l,mid,vl,vr);
	else if(vl>mid) return query(rid,mid+1,r,vl,vr);
	else return query(lid,l,mid,vl,vr)+query(rid,mid+1,r,vl,vr);
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	build(1,1,n);
	scanf("%lld",&q);
	while(q--){
		int opt,x,y;
		scanf("%lld%lld%lld",&opt,&x,&y);
		if(opt==1) change(1,1,n,x,y);
		else{
			node res=query(1,1,n,x,y);
			printf("%lld\n",res.cnt);
		}
	}
	return 0;
}
```

---

## 作者：EXODUS (赞：2)

# Part 1：前言

多 log 还难写的 /tuu 做法

# Part 2：正文

考虑如何校验一个鱼是否**不能**活到最后，那么充要条件就是存在一个包含它的区间 $[l,r]$ 满足区间和 $s<a_{l-1},a_{r+1}$（称为被 ban 区间）。

不能直接数点的问题在于询问的两侧，由于单独提出 $[L,R]$ 之后相当于将 $a_{L-1},a_{R+1}$ 视为 $+\infty$，所以可能出现以 $L-1$ 作为 $l-1$ 的极长被 ban 区间 $[l,r]$，可能出现以 $R+1$ 作为 $r+1$ 的极长被 ban 区间 $[l,r]$，可以直接二分出这两个端点，对于再往中间的部分就不会被 $+\infty$ 影响，那么就是完全被包含在 $[L,R]$ 内部的被 ban 区间会 ban 点，没被 ban 的点才会被贡献进答案中。

现在考虑单点修改 $a_p$ 会对哪些被 ban 区间产生影响。

仅考察 $a_{l-1}<a_{r+1}$ 的被 ban 区间，若 $r$ 相同，那么不同的 $l$ 从右往左一定满足 $a_{l-1}$ 递增，并且每次权值至少 $\times 2$，所以固定其中一端点时被 ban 区间只有 $\mathcal{O}(\log A)$ 个，那么单点修改 $a_p$ 的时候直接将 $r=p-1$ 和 $l=p+1$ 的被 ban 区间全都暴力重找一遍即可。

再考虑包含 $p$ 的被 ban 区间，由于被 ban 区间不会相交，所以它们一定是包含关系，同理包含关系的区间每扩张一次（还是两次）权值至少 $\times 2$，那么包含 $p$ 的被 ban 区间也至多有 $\mathcal{O}(\log A)$ 个。也将这些端点拉出来重新再找一遍即可。还要情况是将它改小可能会增加包含它的区间，直接 $\mathcal{O}(\log A)$ 轮左右二分找就行。

每次要对 $\mathcal{O}(\log A)$ 个端点重新找被 ban 区间，假如是对左端点找右端点，那么需要 $a_i-pre_{i-1}>-pre_{l-1}$，线段树上直接嗯递归把这 $\mathcal{O}(\log A)$ 个可能的 $i$ 找出来就行。找到被 ban 区间，为了询问还要将这些被 ban 区间进行一个区间 +1，支持区间查询 0 的个数，在询问的时候临时删掉包含询问左右端点的区间。于是现在复杂度是 $\mathcal{O}((n+q)\log^2A\log n)$。

# Part 3：代码

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef pair<int,int>pii;
typedef vector<int>vi;
typedef vector<pair<int,int>>vpii;

#define rep(i,l,r) for(int i(l);i<=(r);++i)
#define per(i,r,l) for(int i(r);i>=(l);--i)
#define mp make_pair
#define pb emplace_back
#define File(filename) freopen(filename ".in","r",stdin),freopen(filename ".out","w",stdout)
#define Exit(p) fprintf(stderr,"[exit]: at breakpoint %d\n",p),exit(0);

#ifdef EXODUS
	#define Debug(...) fprintf(stderr,__VA_ARGS__)
#else
	#define Debug(...) 0
#endif

//=========================================================================================================
// Something about IO

template<typename T>
void read(T &x){
	x=0;T flg=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flg=-1;ch=getchar();}
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	x*=flg;
}
template<typename T>
void seq_read(T bg,T ed){for(auto i=bg;i!=ed;++i)read(*i);}
template<typename T,typename... Args>
void read(T &x,Args &...args){read(x),read(args...);}

//=========================================================================================================
//Some useful function

template<typename T>
void cmax(T& x,T y){x=max(x,y);}
template<typename T,typename... Args>
void cmax(T& x,T y,Args ...args){cmax(x,y);cmax(x,args...);}
template<typename T>
void cmin(T& x,T y){x=min(x,y);}
template<typename T,typename... Args>
void cmin(T& x,T y,Args ...args){cmin(x,y);cmin(x,args...);}
template<typename T,typename U>
void seq_assign(T bg,T ed,U val){for(auto i=bg;i!=ed;++i)(*i)=val;}
template<typename T,class F,class=enable_if_t<is_invocable_v<F>>>
void seq_assign(T bg,T ed,F func){for(auto i=bg;i!=ed;++i)(*i)=func(i);}
template<typename T>
void seq_copy(T dstbg,T dsted,T srcbg,T srced){for(auto i=dstbg,j=srcbg;i!=dsted&&j!=srced;++i,++j)(*i)=(*j);}

//=========================================================================================================
// Define the global variables here.

bool membg=0;

constexpr int N=1e5+10;

int n;
ll a[N];
ll pre[N],suf[N],w[N];

inline int lowbit(int x){return x&(-x);}
#define ls (x<<1)
#define rs ((x<<1)|1)
struct SGT{//区间 +-1，查询区间 0 的个数
	int mn[N<<2],ct[N<<2],tag[N<<2];
	void upd(int x,int v){tag[x]+=v;mn[x]+=v;}
	void pushup(int x){
		mn[x]=min(mn[ls],mn[rs]);ct[x]=0;
		if(mn[x]==mn[ls])ct[x]+=ct[ls];
		if(mn[x]==mn[rs])ct[x]+=ct[rs];
	}
	void pushdown(int x){
		if(tag[x]){
			upd(ls,tag[x]);upd(rs,tag[x]);
			tag[x]=0;
		}
	}
	void build(int x,int l,int r){
		mn[x]=0;ct[x]=r-l+1;
		if(l==r)return ;
		int mid=(l+r)>>1;
		build(ls,l,mid);build(rs,mid+1,r);
	}
	void modify(int x,int tl,int tr,int l,int r,int v){
		if(tl>=l&&tr<=r)return upd(x,v);
		int mid=(tl+tr)>>1;pushdown(x);
		if(mid>=l)modify(ls,tl,mid,l,r,v);
		if(mid<r)modify(rs,mid+1,tr,l,r,v);
		pushup(x);
	}
	int query(int x,int tl,int tr,int l,int r){
		if(tl>=l&&tr<=r)return mn[x]==0?ct[x]:0;
		int mid=(tl+tr)>>1,s=0;pushdown(x);
		if(mid>=l)s+=query(ls,tl,mid,l,r);
		if(mid<r)s+=query(rs,mid+1,tr,l,r);
		pushup(x);
		return s;
	}
	void modify(int l,int r,int v){modify(1,1,n,l,r,v);}
	int query(int l,int r){return query(1,1,n,l,r);}
}T;
struct SGTw{
	ll mx[N<<2],tag[N<<2];
	void upd(int x,ll v){mx[x]+=v;tag[x]+=v;}
	void pushup(int x){mx[x]=max(mx[ls],mx[rs]);}
	void pushdown(int x){
		if(tag[x]){
			upd(ls,tag[x]);
			upd(rs,tag[x]);
			tag[x]=0;
		}
	}
	void build(int x,int l,int r,ll *w){
		if(l==r){mx[x]=w[l];return ;}
		int mid=(l+r)>>1;
		build(ls,l,mid,w);build(rs,mid+1,r,w);
		pushup(x);
	}
	void modify(int x,int tl,int tr,int l,int r,ll v){
		if(tl>=l&&tr<=r)return upd(x,v);
		int mid=(tl+tr)>>1;pushdown(x);
		if(mid>=l)modify(ls,tl,mid,l,r,v);
		if(mid<r)modify(rs,mid+1,tr,l,r,v);
		pushup(x);
	}
	void modify(int l,int r,ll v){modify(1,1,n,l,r,v);}
	void query(int x,int tl,int tr,int l,int r,ll v,vi &vec){
		if(mx[x]<=v)return ;
		if(tl==tr){
			vec.pb(tl);return ;
		}
		int mid=(tl+tr)>>1;pushdown(x);
		if(mid>=l)query(ls,tl,mid,l,r,v,vec);
		if(mid<r)query(rs,mid+1,tr,l,r,v,vec);
		pushup(x);
	}
	void query(int l,int r,ll v,vi &vec){if(l>r)return ;query(1,1,n,l,r,v,vec);}
	int getl(int x,int tl,int tr,int l,int r,ll v){
		if(mx[x]<=v)return n+1;
		if(tl==tr)return tl;
		int mid=(tl+tr)>>1;pushdown(x);
		if(mid>=l&&mid<r){
			int p=getl(ls,tl,mid,l,r,v);
			if(p==n+1)p=getl(rs,mid+1,tr,l,r,v);
			pushup(x);
			return p;
		}
		int p;
		if(mid>=l)p=getl(ls,tl,mid,l,r,v);
		else p=getl(rs,mid+1,tr,l,r,v);
		pushup(x);
		return p;
	}
	int getr(int x,int tl,int tr,int l,int r,ll v){
		if(mx[x]<=v)return 0;
		if(tl==tr)return tl;
		int mid=(tl+tr)>>1;pushdown(x);
		if(mid>=l&&mid<r){
			int p=getr(rs,mid+1,tr,l,r,v);
			if(!p)p=getr(ls,tl,mid,l,r,v);
			pushup(x);
			return p;
		}
		int p;
		if(mid>=l)p=getr(ls,tl,mid,l,r,v);
		else p=getr(rs,mid+1,tr,l,r,v);
		pushup(x);
		return p;
	}
}sgt1,sgt2;
struct SGTk{
	vpii vec[N<<2];
	void ins(int x,int tl,int tr,int l,int r,pii v){
		if(tl>=l&&tr<=r){vec[x].pb(v);return ;}
		int mid=(tl+tr)>>1;
		if(mid>=l)ins(ls,tl,mid,l,r,v);
		if(mid<r)ins(rs,mid+1,tr,l,r,v);
		return ;
	}
	void era(int x,int tl,int tr,int l,int r,pii v){
		if(tl>=l&&tr<=r){vec[x].erase(find(vec[x].begin(),vec[x].end(),v));return ;}
		int mid=(tl+tr)>>1;
		if(mid>=l)era(ls,tl,mid,l,r,v);
		if(mid<r)era(rs,mid+1,tr,l,r,v);
		return ;
	}
	void query(int x,int tl,int tr,int p,vpii &Vec){
		for(auto i:vec[x])Vec.pb(i);
		if(tl==tr)return ;
		int mid=(tl+tr)>>1;
		if(p<=mid)query(ls,tl,mid,p,Vec);
		else query(rs,mid+1,tr,p,Vec);
	}
}sgtk;
struct BIT{
	ll tree[N];
	void modify(int x,int v){for(;x<=n;x+=lowbit(x))tree[x]+=v;}
	ll query(int x){ll s=0;for(;x;x-=lowbit(x))s+=tree[x];return s;}
	ll query(int l,int r){
		r=min(r,n);
		if(l>r)return 0;
		return query(r)-query(l-1);
	}
}bit;
vi vl[N],vr[N];

bool memed=0;

//=========================================================================================================
// Code here.

void ins(int l,int r){
	// fprintf(stderr,"ins(%d, %d)\n",l,r);
	T.modify(l,r,1);
	sgtk.ins(1,1,n,l,r,mp(l,r));
}
void era(int l,int r){
	// fprintf(stderr,"era(%d, %d)\n",l,r);
	T.modify(l,r,-1);
	sgtk.era(1,1,n,l,r,mp(l,r));
}
void remakel(int p){
	if(p==n)return ;
	ll prel=bit.query(1,p-1);
	vi vec;
	sgt1.query(p+1,n,-prel,vec);
	if(bit.query(p+1,n)<a[p])vec.pb(n+1);
	for(auto &i:vec)--i;
	vi tmp=vec;vi().swap(vec);
	for(auto i:tmp){
		if(a[p-1]>bit.query(p,i))
			vec.pb(i);
	}
	vpii rr,rw;
	for(auto i:vl[p]){
		int fl=0;
		for(auto j:vec)if(i==j)fl=1;
		if(!fl){
			era(p,i);
			rr.pb(p,i);
		}
	}
	for(auto i:vec){
		int fl=0;
		for(auto j:vl[p])if(i==j)fl=1;
		if(!fl){
			ins(p,i);
			rw.pb(p,i);
		}
	}
	vl[p]=vec;
	for(auto [l,r]:rr){
		auto it=find(vr[r].begin(),vr[r].end(),l);
		if(it!=vr[r].end()){
			vr[r].erase(it);
			era(l,r);
		}
	}
	for(auto [l,r]:rw){
		auto it=find(vr[r].begin(),vr[r].end(),l);
		if(it==vr[r].end()){
			vr[r].pb(l);
			ins(l,r);
		}
	}
}
void remaker(int p){
	if(p==1)return ;
	ll sufr=bit.query(p+1,n);
	vi vec;
	sgt2.query(1,p-1,-sufr,vec);
	if(bit.query(1,p-1)<a[p])vec.pb(0);
	for(auto &i:vec)++i;
	vi tmp=vec;vi().swap(vec);
	for(auto i:tmp){
		if(a[p+1]>bit.query(i,p))
			vec.pb(i);
	}
	vpii rr,rw;
	for(auto i:vr[p]){
		int fl=0;
		for(auto j:vec)if(i==j)fl=1;
		if(!fl){
			rr.pb(i,p);
			era(i,p);
		}
	}
	for(auto i:vec){
		int fl=0;
		for(auto j:vr[p])if(i==j)fl=1;
		if(!fl){
			rw.pb(i,p);
			ins(i,p);
		}
	}
	vr[p]=vec;
	for(auto [l,r]:rr){
		auto it=find(vl[l].begin(),vl[l].end(),r);
		if(it!=vl[l].end()){
			vl[l].erase(it);
			era(l,r);
		}
	}
	for(auto [l,r]:rw){
		auto it=find(vl[l].begin(),vl[l].end(),r);
		if(it==vl[l].end()){
			vl[l].pb(r);
			ins(l,r);
		}
	}
}
void chkins(int l,int r){
	if(find(vl[l].begin(),vl[l].end(),r)==vl[l].end()){
		vl[l].pb(r);
		ins(l,r);
	}
	if(find(vr[r].begin(),vr[r].end(),l)==vr[r].end()){
		vr[r].pb(l);
		ins(l,r);
	}
}
void remakep(int p){
	int l=p,r=p;
	while(!(l==1&&r==n)){
		if(r<n){
			int o=sgt1.getl(1,1,n,r+1,n,-bit.query(1,l-1));
			r=o-1;
		}
		if(l>1){
			int o=sgt2.getr(1,1,n,1,l-1,-bit.query(r+1,n));
			l=o+1;
		}
		ll s=bit.query(l,r);
		if(a[l-1]>s && a[r+1]>s){
			chkins(l,r);
			if(l==1&&r==n)break;
			if(a[l-1]<a[r+1])--l;
			else ++r;
		}
	}
}
void solve(){
	read(n);
	for(int i=1;i<=n;i++)read(a[i]),bit.modify(i,a[i]);
	if(n==1){
		int q;read(q);
		while(q--){
			int o,l,r;read(o,l,r);
			if(o==2)cout<<1<<'\n';
		}
		return ;
	}
	if(n==2){
		int q;read(q);
		while(q--){
			int o,l,r;read(o,l,r);
			if(o==1)a[l]=r;
			else{
				if(l==r){
					cout<<1<<'\n';
					continue;
				}
				int s=0;
				for(int i=l;i<=r;i++)
					if(i==1)s+=a[1]>=a[2];
					else s+=a[2]>=a[1];
				cout<<s<<'\n';
			}
		}
		return ;
	}
	a[0]=a[n+1]=0x7fffffffffffffff;
	for(int i=1;i<=n;i++)pre[i]=pre[i-1]+a[i];
	for(int i=n;i>=1;i--)suf[i]=suf[i+1]+a[i];
	T.build(1,1,n);
	for(int i=1;i<=n;i++)w[i]=a[i]-pre[i-1];
	sgt1.build(1,1,n,w);
	for(int i=1;i<=n;i++)w[i]=a[i]-suf[i+1];
	sgt2.build(1,1,n,w);
	for(int i=1;i<=n;i++)remakel(i);
	for(int i=1;i<=n;i++)remaker(i);
	// cerr<<"------query------\n";
	int q;read(q);
	for(int o=1;o<=q;o++){
		// cerr<<"opration "<<o<<"\n";
		int op;read(op);
		if(op==1){
			int p,v;read(p,v);
			if(v==a[p])continue;
			int dt=v-a[p];
			bit.modify(p,dt);
			if(p<n)sgt1.modify(p+1,n,-dt);
			sgt1.modify(p,p,dt);
			if(p>1)sgt2.modify(1,p-1,-dt);
			sgt2.modify(p,p,dt);
			a[p]=v;
			vi vecl,vecr;
			if(p<n)vecl.pb(p+1);
			if(p>1)vecr.pb(p-1);
			if(dt>0){
				vpii vec;
				sgtk.query(1,1,n,p,vec);
				for(auto [l,r]:vec)vecl.pb(l),vecr.pb(r);
			}
			sort(vecl.begin(),vecl.end());
			vecl.erase(unique(vecl.begin(),vecl.end()),vecl.end());
			for(auto l:vecl)remakel(l);
			//
			sort(vecr.begin(),vecr.end());
			vecr.erase(unique(vecr.begin(),vecr.end()),vecr.end());
			for(auto r:vecr)remaker(r);
			//
			if(dt<0){
				remakep(p);
			}
		}
		else{
			int L,R;read(L,R);
			int l=sgt1.getr(1,1,n,L,R,-bit.query(1,L-1));
			if(l==0)l=L;
			int r=sgt2.getl(1,1,n,L,R,-bit.query(R+1,n));
			if(r==n+1)r=R;
			int ans=0;
			if(l>r)ans=0;
			else{
				vpii vec1;
				sgtk.query(1,1,n,l,vec1);
				for(auto [l,r]:vec1)era(l,r);
				vpii vec2;
				sgtk.query(1,1,n,r,vec2);
				for(auto [l,r]:vec2)era(l,r);
				ans+=T.query(l,r);
				for(auto [l,r]:vec1)ins(l,r);
				for(auto [l,r]:vec2)ins(l,r);
			}
			cout<<ans<<'\n';
		}
	}
	return ;
}

//=========================================================================================================

int main(){
	// Debug("%.3lfMB\n",fabs(&memed-&membg)/1024.0/1024.0);
	// int timbg=clock();
	int T=1;
	while(T--)solve();
	// int timed=clock();
	// Debug("%.3lfs\n",1.0*(timed-timbg)/CLOCKS_PER_SEC);
	// fflush(stdout);
	return 0;
}
```

---

## 作者：Purslane (赞：1)

# Solution

模拟赛放了这道题，我斩获 $13$ 分。

首先获得一个暴力模拟的方法：考虑一条鱼在 $i$。每个时刻他会尝试吃掉左边或者右边的鱼，所以实际上是一个包含 $i$ 的区间 $[L,R]$。这样在 $O(n)$ 复杂度内可以确定一条鱼是否合法。

注意到如果当前鱼是 $[L,R]$，记 $s = \sum_{i=L}^R a_i$，则如果 $a_{R+1} \le s$ 可以直接移动。也就是说，我们找到 $>R$ 的第一个位置 $R'$ 使得 $a_{R'}>s$，$<L$ 的第一个位置 $L'$ 使得 $a_{L'} > s$，则 $[L,R]$ 一定能扩展到 $(L',R')$。如果能继续扩展一次，则区间和一定会扩大 $2$ 倍。所以这样迭代的次数肯定控制在 $\log$ 量级内。使用线段树二分就可以做到 $\log^2$ 判定。

这样能过整整 $13$ 分，真是太牛了。

正解感觉也非常简单，但是需要一个非常暴力的手段：直接上线段树。

原因是，考虑一个区间 $[L_1,R_1]$，里面的鱼吃啊吃最后都会最后停留在一个区间 $[l,r]$ 中。如果 $L_1 < l < r < R_1$，那么对于任何的 $L_2 \le L_1 \le R_1 \le R_2$，这条鱼在 $[L_2,R_2]$ 中也不可能成为最终的胜利者。所以一定有 $l=L_1$ 且 $r=R_1$。

而 $l=L_1$ 的时候，符合条件的 $r$ 的数量显然也是 $O(\log)$ 的，这足以让我们在线段树上保存他们。我们将所有鱼按照其最终停留的区间划分等价类，保留一个等价类里面有多少条鱼。

等价类差不多是这三种：分别卡到端点；左边卡到了端点右边没卡到；右边卡到了端点左边没卡到。

考虑合并。左边那个区间没卡到右端点的鱼显然不会改变，右边区间没卡到左端点的鱼同理。我们只需要处理左区间卡到右端点的鱼，和右区间卡到左端点的鱼。~~说得跟绕口令一样。~~

合并是这样的：

![](https://s21.ax1x.com/2025/06/22/pVZawZR.png)

显然你只需要求出这个黄色的区间的位置。

红色区间越长，这个黄色区间的两端也越长，所以你用指针维护两个端点就行。

单次合并信息复杂度为 $O(\log V)$，所以总复杂度为 $O((n+q) \log^2 V)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,q,a[MAXN],x[MAXN],y[MAXN];
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1) 
struct INFO {
	int c,sum,lp,rp;
	vector<pair<int,int>> fL,fR;
	vector<pair<int,int>> pL,pR;
}t[MAXN<<2];
int c1[MAXN],c2[MAXN],Pre[MAXN],Nxt[MAXN],AdPre[MAXN],AdNxt[MAXN];
inline INFO operator +(INFO A,INFO B) {
	INFO C;
	C.c=0,C.sum=A.sum+B.sum;
	C.pL=A.pL,C.pR=B.pR,C.lp=A.lp,C.rp=B.rp;
	B.pL.insert(B.pL.begin(),make_pair(B.lp,0ll));
	A.pR.insert(A.pR.begin(),make_pair(A.rp,0ll));
	for(auto pr:B.pL) if(a[pr.first]>A.sum+pr.second) C.pL.push_back({pr.first,A.sum+pr.second});
	for(auto pr:A.pR) if(a[pr.first]>B.sum+pr.second) C.pR.push_back({pr.first,B.sum+pr.second});
	
	for(auto pr:C.pL) c1[pr.first]=0; for(auto pr:C.pR) c2[pr.first]=0;
	for(auto pr:A.fL) c1[pr.first]+=pr.second; for(auto pr:B.fR) c2[pr.first]+=pr.second;
	
	int lstpos=B.lp,lsum=0;
	for(auto pr:A.pR) {
		Pre[lstpos]=pr.first,AdPre[lstpos]=pr.second-lsum;
		lstpos=pr.first,lsum=pr.second;
	}
	Pre[lstpos]=A.lp-1,AdPre[lstpos]=A.sum-lsum;
	lstpos=A.rp,lsum=0;
	for(auto pr:B.pL) {
		Nxt[lstpos]=pr.first,AdNxt[lstpos]=pr.second-lsum;
		lstpos=pr.first,lsum=pr.second;
	}
	Nxt[lstpos]=B.rp+1,AdNxt[lstpos]=B.sum-lsum;
	
	int tl=A.rp+1,tr=A.rp,sum=0,xl=A.lp,xr=B.rp;
	if(A.c) A.fR.push_back({A.lp-1,A.c});
	if(B.c) B.fL.push_back({B.rp+1,B.c});
	for(auto pr:A.fR) {
		while(tl>pr.first) sum+=AdPre[tl],tl=Pre[tl];
		while(1) {
			int flg=0;
			if(tl!=xl-1&&a[tl]<=sum) flg=1,sum+=AdPre[tl],tl=Pre[tl];
			if(tr!=xr+1&&a[tr]<=sum) flg=1,sum+=AdNxt[tr],tr=Nxt[tr];
			if(!flg) break ;
		}
		if(tl==xl-1&&tr==xr+1) C.c+=pr.second;
		else if(tl==xl-1) c1[tr]+=pr.second;
		else if(tr==xr+1) c2[tl]+=pr.second;
	}
	tl=A.rp+1,tr=A.rp,sum=0,xl=A.lp,xr=B.rp;
	for(auto pr:B.fL) {
		while(tr<pr.first) sum+=AdNxt[tr],tr=Nxt[tr];
		while(1) {
			int flg=0;
			if(tl!=xl-1&&a[tl]<=sum) flg=1,sum+=AdPre[tl],tl=Pre[tl];
			if(tr!=xr+1&&a[tr]<=sum) flg=1,sum+=AdNxt[tr],tr=Nxt[tr];
			if(!flg) break ;
		}
		if(tl==xl-1&&tr==xr+1) C.c+=pr.second;
		else if(tl==xl-1) c1[tr]+=pr.second;
		else if(tr==xr+1) c2[tl]+=pr.second;
	}
	
	for(auto pr:C.pL) C.fL.push_back({pr.first,c1[pr.first]});
	for(auto pr:C.pR) C.fR.push_back({pr.first,c2[pr.first]});
	return C;
}
void build(int k,int l,int r) {
	t[k].lp=l,t[k].rp=r;
	if(l==r) return t[k].c=1,t[k].sum=a[l],t[k].fL=t[k].fR={},void();
	build(lson,l,mid),build(rson,mid+1,r);
	return t[k]=t[lson]+t[rson],void();
}
void update(int k,int l,int r,int pos) {
	if(l==r) return t[k].sum=a[l],void();
	if(pos<=mid) update(lson,l,mid,pos);
	else update(rson,mid+1,r,pos);
	return t[k]=t[lson]+t[rson],void();
}
INFO query(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) return t[k];
	if(y<=mid) return query(lson,l,mid,x,y);
	if(x>mid) return query(rson,mid+1,r,x,y);
	return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y);
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,1,n) cin>>a[i];
	build(1,1,n);
	cin>>q;
	ffor(i,1,q) {
		int op,x,y;
		cin>>op>>x>>y;
		if(op==1) a[x]=y,update(1,1,n,x);
		else cout<<query(1,1,n,x,y).c<<'\n';
	}
	return 0;
}
```

---

## 作者：happybob (赞：1)

题意：

给定一个长度为 $n$ 的正整数序列。考虑一个序列中某一个位置的数，我们称其为好的当且仅当其通过以下操作能将序列中除了这个点的位置删空，操作是：

1. 若其左侧相邻有数且小于等于当前的数，可以将左侧相邻的数加到这个数上并删去左侧的数。
2. 若其右侧相邻有数且小于等于当前的数，可以将右侧相邻的数加到这个数上并删去右侧的数。

现在有 $q$ 次操作，每次是单点修改或询问序列保留一个区间后有多少个位置是好的。

$1 \leq n, q \leq 10^5$，$1 \leq a_i \leq 10^9$，$4$ 秒，$1$ GB。

解法：

考虑暴力怎么做，首先有 $O(n^3)$ 做法，其次考虑到这是一个经典的问题，枚举起点后做 $O(\log V)$ 次线段树二分即可做到 $O(n^2 \log V \log n)$。

上述做法不容易优化，原因是由于保留的区间不同，我们无法对于每个起点很好地维护信息。

我们更优美地刻画一个点是好的条件。称一个区间 $[l,r]$ 是坏的当且仅当 $\sum \limits_{i=l}^r a_i < \min(a_{l-1},a_{r+1})$，即这个区间中的起点会在这个区间被阻塞而无法向外扩展。

对于询问区间 $[L,R]$，假设 $a_{L-1}=a_{R+1}=+\infty$，则一个点 $i$ 是好的当且仅当不存在坏区间 $i \in [l,r] \subsetneqq [L,R]$。

题目性质刻画得差不多了，考虑用线段树维护。如果我们能快速合并相邻区间那问题就得以解决了，因为单点修改肯定是容易的。考虑合并相邻区间 $[l,m]$ 和 $[m+1,r]$，首先我们需要思考维护什么信息能在刻画答案的前提下容易进行合并。注意到如果一个区间内的点连区间端点都走不到，则无论如何与相邻区间合并，这个点都无法走出去。并且答案是能走完整个区间的点，显然是可以走到左右端点的。所以我们只需要维护那些能到左端点或右端点的那些点集即可。

但是这样的点数量还是太多，我们以维护前缀为例，后缀同理。可以发现如果两个点扩展完后得到的前缀相同，则这两个点没有区别。假设目前区间为 $[l,r]$，我们只需要维护若干 $(l,x,c,s)$ 表示一段前缀为 $[l,x]$，有 $c$ 个起点最终会扩展成这个前缀，这个前缀的和为 $s$。注意到一个这样的四元组有意义当且仅当 $\sum \limits_{i=l}^x a_i < a_{x+1}$，否则这个区间不可能是一个终止区间。显然这样的四元组只有 $O(\log V)$ 个，所以我们在每个点只需要维护 $O(\log V)$ 个信息。

考虑合并。直接按照题意模拟合并即可做到 $O(n \log n \log^2 V)$，常数比较小或许可以通过，不过显然的优化是在合并区间的过程中，扩展到的区间有单调性，双指针维护即可做到 $O(n \log n \log V)$，跑得飞快。

代码：


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <array>
#include <set>
#include <map>
#include <string>
#include <vector>
#include <queue>
using namespace std;

using ll = long long;

constexpr int N = 1e5 + 5;

int n, q;
array<int, N> v;
array<int, N> pos1, pos2;

class SegmentTree
{
public:
	struct Segs
	{
		int l, r, cnt;
		ll sum;
		Segs() = default;
		Segs(int l, int r, int cnt, ll sum) : l(l), r(r), cnt(cnt), sum(sum) {}
	};
	struct Node
	{
		int l, r;
		vector<Segs> pre, suf;
		int lf, rt;
		friend Node operator+(Node a, Node b)
		{
			if (a.l == -1) return b;
			if (b.l == -1) return a;
			Node c;
			c.l = a.l, c.r = b.r;
			c.lf = a.lf, c.rt = b.rt;
			c.pre = a.pre;
			ll suma = a.pre.back().sum, sumb = b.pre.back().sum;
			// solve c.pre
			if (c.pre.back().sum >= v[c.pre.back().r + 1]) c.pre.pop_back();
			for (auto& [l, r, cnt, sum] : b.pre)
			{
				if (suma + sum < v[r + 1] || r == b.pre.back().r)
				{
					c.pre.emplace_back(a.l, r, 0, suma + sum);
				}
			}
			for (int i = 0; i < c.pre.size(); i++)
			{
				pos1[c.pre[i].r] = i;
			}
			// solve c.suf
			c.suf = b.suf;
			if (c.suf.back().sum >= v[c.suf.back().l - 1]) c.suf.pop_back();
			for (auto& [l, r, cnt, sum] : a.suf)
			{
				if (sumb + sum < v[l - 1] || l == a.suf.back().l)
				{
					c.suf.emplace_back(l, b.r, 0, sumb + sum);
				}
			}
			for (int i = 0; i < c.suf.size(); i++)
			{
				pos2[c.suf[i].l] = i;
			}
			// things in b.pre
			int nowl = -1, nowr = 0;
			ll nows = b.pre.front().sum;
			for (int i = 0; i < b.pre.size(); i++)
			{
				if (nowr < i)
				{
					nows -= b.pre[nowr].sum;
					nowr = i;
					nows += b.pre[nowr].sum;
				}
				while (true)
				{
					bool tag = 0;
					if (nowr + 1 < b.pre.size() && nows >= v[b.pre[nowr].r + 1])
					{
						tag = 1;
						nows -= b.pre[nowr].sum;
						nowr++;
						nows += b.pre[nowr].sum;
					}
					if (nowl + 1 < a.suf.size() && nows >= (nowl == -1 ? a.rt : v[a.suf[nowl].l - 1]))
					{
						tag = 1;
						if (nowl != -1)
						{
							nows -= a.suf[nowl].sum;
						}
						nowl++;
						nows += a.suf[nowl].sum;
					}
					if (!tag) break;
				}
				int cnt = b.pre[i].cnt;
				if (nowl == a.suf.size() - 1)
				{
					c.pre[pos1[b.pre[nowr].r]].cnt += cnt;
				}
				if (nowr == b.pre.size() - 1 && nowl != -1)
				{
					c.suf[pos2[(nowl == -1 ? a.r + 1 : a.suf[nowl].l)]].cnt += cnt;
				}
			}
			// things in a.suf
			nowl = 0, nowr = -1;
			nows = a.suf.front().sum;
			for (int i = 0; i < a.suf.size(); i++)
			{
				if (nowl < i)
				{
					nows -= a.suf[nowl].sum;
					nowl = i;
					nows += a.suf[nowl].sum;
				}
				while (true)
				{
					bool tag = 0;
					if (nowl + 1 < a.suf.size() && nows >= v[a.suf[nowl].l - 1])
					{
						tag = 1;
						if (nowl != -1)
						{
							nows -= a.suf[nowl].sum;
						}
						nowl++;
						nows += a.suf[nowl].sum;
					}
					if (nowr + 1 < b.pre.size() && nows >= (nowr == -1 ? b.lf : v[b.pre[nowr].r + 1]))
					{
						tag = 1;
						if (~nowr) nows -= b.pre[nowr].sum;
						nowr++;
						nows += b.pre[nowr].sum;
					}
					if (!tag) break;
				}
				int cnt = a.suf[i].cnt;
				if (nowl == a.suf.size() - 1 && nowr != -1)
				{
					c.pre[pos1[(nowr == -1 ? a.r : b.pre[nowr].r)]].cnt += cnt;
				}
				if (nowr == b.pre.size() - 1)
				{
					c.suf[pos2[a.suf[nowl].l]].cnt += cnt;
				}
			}
			return c;
		}
	};
	array<Node, N << 2> tr;
	void build(int u, int l, int r)
	{
		tr[u].l = l, tr[u].r = r;
		if (l == r)
		{
			tr[u].lf = tr[u].rt = v[l];
			tr[u].pre.emplace_back(l, l, 1, v[l]);
			tr[u].suf.emplace_back(l, l, 1, v[l]);
			//cout << "ok: " << l << " " << r << "\n";
			return;
		}
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		//cout << "doing: " << l << " " << r << "\n";
		tr[u] = tr[u << 1] + tr[u << 1 | 1];
		//cout << "ok: " << l << " " << r << "\n";
	}
	void update(int u, int x, int y)
	{
		if (tr[u].l == tr[u].r)
		{
			tr[u].pre[0].sum = y;
			tr[u].suf[0].sum = y;
			tr[u].lf = tr[u].rt = y;
			return;
		}
		int mid = tr[u].l + tr[u].r >> 1;
		if (x <= mid) update(u << 1, x, y);
		else update(u << 1 | 1, x, y);
		tr[u] = tr[u << 1] + tr[u << 1 | 1];
	}
	Node query(int u, int l, int r)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			return tr[u];
		}
		Node res;
		res.l = -1;
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid) res = query(u << 1, l, r);
		if (r > mid) res = res + query(u << 1 | 1, l, r);
		return res;
	}
}sgt;

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> v[i];
	sgt.build(1, 1, n);
	cin >> q;
	while (q--)
	{
		int op, x, y;
		cin >> op >> x >> y;
		if (op == 1)
		{
			v[x] = y;
			sgt.update(1, x, y);
		}
		else
		{
			cout << sgt.query(1, x, y).pre.back().cnt << "\n";
		}
	}
	return 0;
}
```

---

## 作者：blackname (赞：1)

对于每条鱼 $i$，处理出向右的最短区间 $[i+1,r_i]$ 使得区间和 $\ge a_i$，如果 $[i+1,r_i]$ 中有比 $a_i$ 大的数，设为 $a_j$，则将 $r_i\coloneqq j-1$ 后将 $[i+1,r_i]$ 标记为死区间，否则标记为活区间。向左同理。

observation：对于任意 $i$，包含 $i$ 的死区间/活区间数量为 $O(\log V)$。

不妨只考虑向右的区间。一个区间 $[j+1,r_j]$ 包含 $i$，说明延伸到 $i$ 的区间和仍不超过 $a_j$，则从 $[j+1,i-1]$ 到 $[j,i-1]$，区间和至少翻倍，因此有此结论。

对于单次询问 $[l,r]$，所有初始点（即 $i$）在 $[l,r]$ 内的死区间与 $[l,r]$ 的交均不可能成为答案，而有贡献的活区间为初始点在 $[l,r]$ 内，$r_i$ 或 $l_i$ 在 $[l,r]$ 外的。对于死区间，只需要预处理时对其做区间覆盖，在询问时暴力撤销一部分覆盖即可。对于活区间，只需在询问时暴力处理包含 $l$ 或 $r$ 的所有区间即可。

对于修改，影响到的区间数量即为包含其的活区间和死区间数量，只需全部重新处理即可，可以通过在线段树上二分完成。

总复杂度 $O((n+q)\log n\log V)$。

---


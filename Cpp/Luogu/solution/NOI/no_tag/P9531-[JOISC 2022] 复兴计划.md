# [JOISC 2022] 复兴计划

## 题目背景

JOISC2022 D4T3

## 题目描述

JOI 镇是一个曾经辉煌的工业区。为了运输产品，其中建起了许多铁轨与火车站。尽管 JOI 镇已经衰落，那里仍有许多不再被使用的铁轨与火车站。

JOI 镇中有 $N$ 个火车站，编号为 $1,2,\dots,N$。其中还剩下 $M$ 条铁轨。第 $i$ 条铁轨 $(1\le i \le M)$ 双向连接火车站 $A_i$ 和 $B_i$，且其宽度为 $W_i$。保证能够从任意火车站经过若干条铁轨到达任意其他火车站。

你是 JOI 镇的镇长。你计划吸引铁路公司来使用 JOI 镇中留下的铁轨与火车站，使得 JOI 镇复苏成为「铁路之镇」。 
 
于是，共有 $Q$ 个铁路公司申请参与这个复兴计划。然而，不同公司的火车所需的铁轨宽度也有所不同。这意味着你需要重建这些铁轨，使得它们都匹配对应公司的火车。 

第 $j$ $(1\le j\le Q)$ 家铁路公司的火车所需的铁轨宽度为 $X_j$。为了迎合公司 $j$，要求满足以下条件：
- **条件**：保证能够从任意火车站只经过宽度为 $X_j$ 的铁轨到达任意其他火车站。

为了满足上述条件，你可以按如下方式重建铁轨任意次：
- **重建**：选择一条铁轨，你可以重建其使得其宽度增加或减少 $1$ 并花费 $1$。然而，若其宽度为 $1$，则不能再减少其宽度。

为了确定你能满足哪些公司，你需要求出迎合公司 $j$ 所需要的最小花费。

请写一个程序，对于给定的火车站、铁轨与铁路公司的信息，计算迎合公司 $j$ 所需要的最小花费。

## 说明/提示

**【样例解释 #1】**

例如，为了迎合公司 $1$，若你按如下方式重建铁轨，将会花费 $8$。

1. 将铁轨 $6$ 的宽度减少 $4$。
2. 将铁轨 $9$ 的宽度减少 $3$。
3. 将铁轨 $10$ 的宽度增加 $1$。

可以证明不可能用少于 $8$ 的花费迎合公司 $1$。因此，在第一行输出 $8$。

该样例满足子任务 $1,2,4,5,6$ 的限制。

**【样例解释 #2】**

该样例满足所有子任务的限制。

**【样例解释 #3】**

该样例满足子任务 $2,4,5,6$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $2 \le N \le 500$。
- $N-1 \le M \le 100\,000$。
- $1 \le Q \le 1\,000\,000$。
- $1 \le A_i < B_i \le N$ $(1\le i\le M)$。
- $1 \le W_i \le 10^9$ $(1\le i\le M)$。
- $(A_i,B_i,W_i)\ne(A_j,B_j,W_j)$ $(1\le i<j\le M)$。
- 保证能够从任意火车站经过若干条铁轨到达任意其他火车站。
- $1 \le X_j \le 10^9$ $(1\le j\le Q)$。
- $X_j < X_{j+1}$ $(1\le j<Q)$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$M \le 16$，$Q \le 10$|$3$|
|$2$|$Q\le 10$|$4$|
|$3$|$B_i = A_i+1$ $(1\le i\le M)$|$7$|
|$4$|$M\le 1\,000$|$28$|
|$5$|$Q\le 20\,000$|$35$|
|$6$|无附加限制|$23$|

## 样例 #1

### 输入

```
5 10
1 2 8
1 3 13
1 4 5
1 5 11
1 5 3
2 3 7
2 4 15
3 4 6
3 5 6
4 5 2
6
3
6
8
10
13
17```

### 输出

```
8
2
5
10
9
21```

## 样例 #2

### 输入

```
3 4
1 2 1
1 2 4
2 3 2
2 3 4
4
1
2
3
4```

### 输出

```
1
1
2
0```

## 样例 #3

### 输入

```
10 20
6 7 914727791
1 8 771674531
3 5 632918108
5 9 329296846
1 7 237501112
4 9 303328173
2 6 216298255
2 10 504024991
3 8 158236886
1 10 10176179
8 9 918271145
3 6 217165898
3 6 624543444
4 9 70147274
8 9 976983490
6 9 210108505
2 9 972711062
1 10 564567289
3 7 411395464
4 7 952470985
10
115721165
198969744
356664401
429802521
513343279
610443927
741016686
786597783
898772266
903568946```

### 输出

```
1121073688
761832468
1026806785
1316097872
1321500065
1445238392
1637513141
1621778548
1733953031
1738749711```

# 题解

## 作者：liangbowen (赞：10)

[blog](https://www.cnblogs.com/liangbowen/p/18312848)。提供一份代码短的题解。

---

一个暴力做法：维护 $w_i<w_{now}$ 与 $w_i\ge w_{now}$ 的前后缀 MST，查 $X_i$ 时将前后缀 MST 合并，直接求得答案。

考虑一棵 $(u_{now},v_{now},W)$ 的前缀 MST。因为 $w_i<W$ 时 $w_i$ 越大 $|W-w_i|$ 越小，所以枚举所有 $w_i<W$，按边权从大到小加边：

+ 先忽略掉 $(u_{now},v_{now})$ 的边。
+ 对于其他 $w_i<W$，尝试加入。如果成功加入并且构成了包含 $(u_{now},v_{now})$ 的环，显然需要删除最大边，加入最小边。显然**最大边就是** $w_i$**，最小边就是** $w_{now}$，删掉 $i$ 并加入 $now$。

找到这个 $i$。那么 $w_{now}$ 对答案有贡献，当且仅当询问的 $X$ 有 $X-w_i> w_{now}-X$，即 $X>\dfrac{w_i+w_{now}}2$。

同理，$w_i$ 在 $X>\dfrac{w_i+w_{now}}2$ 时会结束贡献。那么**每条边都会有一个贡献区间**，可以加入 MST **当且仅当在贡献区间内**。

---

用并查集模拟上述算法，找出贡献区间 $[l_i,r_i]$，那么对于不同的 $X$，边 $i$ 的贡献为：

+ $X<l_i$，没有贡献。
+ $l_i\le X<w_i$，贡献为 $|X-w_i|=w_i-X$。
+ $w_i\le X<r_i$，贡献为 $|X-w_i|=X-w_i$。
+ $X\ge r_i$，没有贡献。

写个指针状物，因为询问的 $X_i$ 有序，顺着扫一遍即可。可以看代码理解。

---

[code](https://loj.ac/s/2108239)，时间复杂度 $O(nm+q\log m)$。

写了 1.5k，其实应该可以写进 1k 的（

---

## 作者：Arghariza (赞：6)

不难发现题目要求对于每次询问，第 $i$ 条边边权为 $|w_i-x|$，求出最小生成树。

这个绝对值性质多多，比如呈现斜率为 $1$ 的 V 字形。

这说明对于两条边 $i,j$ 图像，必然至多只有一个交点。所以对于每条边 $i$，其有影响 $x$ 是一段区间 $[l_i,r_i]$，$i$ 被算进询问为 $x$ 的生成树中，当且仅当 $x\in [l_i,r_i]$。

同时不难发现 $l_i,r_i\in \{w_i|1\le i\le n\}$。于是可以将边权从小到大排序，维护出一段后缀边集的最小生成树。具体地，考虑如何由 $i\ge l+1$ 的 $i$ 组成的最小生成树 $T_{l+1}$ 推出 $i\ge l$ 的 $i$ 组成的最小生成树 $T_l$：

- 设权值第 $i$ 小的边连接 $u,v$。
- 由于 $n\le 500$，可以 $O(n)$ 找出 $T_{l+1}$ 中 $u\to v$ 的路径 $P$，或者 $u,v$ 不连通。
- 若 $u,v$ 不联通，直接加入 $i$ 边，即 $T_l\gets T_{l+1}\cup i$。
- 若 $u,v$ 联通，由于 $i$ 边权的最小性，删去 $P$ 中权值最大的边 $j$，然后加入 $i$，即 $T_l\gets (T_{l+1}\setminus j)\cup i$。同时发现 $x< \frac{w_i+w_j}{2}$ 时必定取 $i$ 更优，$x>\frac{w_i+w_j}{2}$ 时必定取 $j$ 更优。所以更新 $l_j=r_i=\frac{w_i+w_j}{2}$。

上述求出 $l_i,r_i$ 的过程可以做到 $O(nm)/O(nm\log n)$。

于是对于询问 $x$：

$$\text{ans}=\sum\limits_{l_i\le x\le r_i}|x-w_i|$$

这东西随便用个数据结构差分维护一下就行了。复杂度 $O(nm\log n+m\log w)$。

标记永久化可以大大降低代码常数。

```cpp
// Problem: P9531 [JOISC 2022 Day4] 复兴计划
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P9531
// Memory Limit: 1 MB
// Time Limit: 5000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define int long long
using namespace std;

namespace vbzIO {
    char ibuf[(1 << 20) + 1], *iS, *iT;
    #if ONLINE_JUDGE
    #define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
    #else
    #define gh() getchar()
    #endif
    #define mt make_tuple
    #define mp make_pair
    #define fi first
    #define se second
    #define pc putchar
    #define pb emplace_back
    #define ins insert
    #define era erase
    typedef tuple<int, int, int> tu3;
    typedef pair<int, int> pi;
    inline int rd() {
        char ch = gh();
        int x = 0;
        bool t = 0;
        while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
        while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
        return t ? ~(x - 1) : x;
    }
    inline void wr(int x) {
        if (x < 0) x = ~(x - 1), putchar('-');
        if (x > 9) wr(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace vbzIO;

const int N = 550;
const int W = 1e9;
const int M = 1e5 + 100;

tu3 e[M];
int n, m, sum, fl, tp, rt, tar, tot;
int st[N], lp[M], rp[M];
set<pi> t[N];

#define gt(x, y) get<y>(x)

void dfs(int u, int fa) {
	if (u == tar) return fl = 1, void();
	for (pi p : t[u]) {
		int v, w; tie(v, w) = p;
		if (v == fa) continue;
		st[++tp] = w, dfs(v, u);
		if (fl) return;
		tp--;
	}
}

struct seg { int lc, rc, s, t; } tr[M * 60];

#define ls tr[x].lc
#define rs tr[x].rc
#define mid ((l + r) >> 1)

void upd(int l, int r, int s, int t, int c, int &x) {
	if (!x) x = ++tot;
	tr[x].s += (min(r, t) - max(l, s) + 1) * c;
	if (s <= l && r <= t) return tr[x].t += c, void();
	if (s <= mid) upd(l, mid, s, t, c, ls);
	if (t > mid) upd(mid + 1, r, s, t, c, rs);
}

int qry(int l, int r, int s, int t, int lz, int x) {
	if (!x) return (min(r, t) - max(l, s) + 1) * lz;
	if (s <= l && r <= t) return tr[x].s + (r - l + 1) * lz;
	lz += tr[x].t;
	int res = 0;
	if (s <= mid) res += qry(l, mid, s, t, lz, ls);
	if (t > mid) res += qry(mid + 1, r, s, t, lz, rs);
	return res;
}

signed main() {
	n = rd(), m = rd();
    for (int i = 1, u, v, w; i <= m; i++) 
    	u = rd(), v = rd(), w = rd(), e[i] = mt(w, u, v);
    sort(e + 1, e + m + 1);
    for (int i = m; i; i--) {
    	int u, v, w; tie(w, u, v) = e[i];
    	tar = v, fl = tp = 0, dfs(u, 0);
    	if (fl) {
    		pi res = mp(0, 0);
    		for (int j = 1; j <= tp; j++) 
    			res = max(res, mp(gt(e[st[j]], 0), st[j]));
    		t[gt(e[res.se], 1)].era(mp(gt(e[res.se], 2), res.se));
    		t[gt(e[res.se], 2)].era(mp(gt(e[res.se], 1), res.se));
    		sum -= res.fi;
    		rp[i] = (w + res.fi) >> 1;
    		if ((w + res.fi) & 1) lp[res.se] = rp[i] + 1;
    		else lp[res.se] = rp[i];
    	}
    	sum += w;
    	t[u].ins(mp(v, i)), t[v].ins(mp(u, i));
    }
    for (int i = 1; i <= m; i++)
    	if (!rp[i]) rp[i] = W;
    upd(0, W, 0, 0, sum, rt);
    for (int i = 1; i <= m; i++)
    	upd(0, W, lp[i] + 1, min(gt(e[i], 0), rp[i]), -1, rt),
    	upd(0, W, max(gt(e[i], 0), lp[i]) + 1, rp[i], 1, rt);
    int q = rd();
    while (q--) {
    	int w = rd();
    	wr(qry(0, W, 0, w, 0, rt)), pc('\n');
    }
	return 0;
}
```

---

## 作者：Richard_Whr (赞：5)

同时看多篇题解才看懂，自己来写一篇，希望能帮到一些人。

首先抽象题目可以发现，就是要求给定 $x$ 后，求一颗最小生成树，其中每条边的边权值为 $|x-w|$

首先考虑暴力的算法，我们每次直接对边重定权排序后跑 $\texttt{kruskal}$。

但是这样的复杂度是爆炸的。

我们考虑这个排序对于不同的 $x$ 有什么特点

对于函数 $y=|x-a|$，是一个开口向上的 $V$ 字形，我们将令 $a=w_i$，将所有函数画在一个平面直角坐标系内。

那么对于给定的一个 $x_0$，就是直线 $x=x_0$ 与所有函数的交点，从下到上即使排序后的顺序。

我们发现当 $x$ 缓缓从左向右（或从右向左）横移的时候，当且仅当穿过某条线段的焦点处的时候，会有一条线段反超之前的线段。

在这之前，前一条线段更优，在这之后，后一条线段更优。

但是并不是说在这之后，后一条线段一定有用，为什么呢。

原因就在于，他所连接的两个端点，有可能已经被更优的联通了。

但是，这并不妨碍我们得出结论：**一条线对生成树有贡献的时刻是连续的一段 $x$**，只是可能会将这个区间缩短。

对于每条边 $i$，记录对于他来说一段有用的区间为 $L[i],R[i]$

这就告诉我们，不仅需要知道哪个线段更优，还要时时维护出在  $x=x_0$ 的时候，当前的最有生成树。

我们考虑将所有边权从大到小排序，依次尝试加入最小生成树当中，此时的 $x$ 缓缓左移。

考虑加入的时候有什么情况：

- 连接的两个端点不联通，很显然，直接加入。

- 连接的两个端点联通，考虑他和原来的路径构成了一个环，那么当 $x$ 变化的时候，必然有人遭到淘汰。
	
  重新看回绝对值函数，两个函数 $y=|x-a|$ 和 $y=|x-b|,(a<b)$，两个点的分界处位于 $(a+b)/2$
  
  因此，当 $x$ 移动的时候，最先碰到某两个函数的那个界限中，在 $x$ 左移后更靠上的，将会被淘汰。容易发现是 $(a+b)/2$ 中最大的点是最先碰到的界限，所以应该是环上最大边权的边将被淘汰。
  
  设要被淘汰的边为 $j$，当前边为 $i$，可以发现，在 $>x$ 的时候， $j$ 更好，在 $<x$ 的时候 $i$，更好。
  
  因此有 $L[j]=(a+b)/2+1,R[i]=(a+b)/2$
  
这个过程可以用 $\texttt{LCT}$ 维护，但由于点数很少因此直接暴力也是可以的。

特别的，对于在过程中没有赋值的 $L[i]$，说明他从一开始就要加入，对于没有赋值的 $R[i]$，说明他最后没有被剔除。

最后有了每条边的 $L[i],R[i]$，如何维护我们的答案呢？

形式化的：

$$ans=\sum_{L[i]\le x\le R[i]}|x-w[i]|$$

考虑直接拆掉这个绝对值，并对每个 $i$，维护他对 $x$ 的贡献。

最终的答案一定是 $k_x\times x+b_x$，因为绝对值拆掉后会有一些 $x$ 抵消，因此同时维护好 $k_x$ 和 $b_x$ 即可。

对于那些 $w[i] < x < R[i]$ 的 $x$，$b$ 将加上 $-w[i]$，而 $k$ 会 $+1$

反之对于 $L[i] < x < w[i]$ 也是一样的。

考虑到我们的询问是离线的，我们只需要做一下差分即可。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
const int N=5e2+10,M=1e6+10,inf=1e15;
vector<PII> e[N];
struct Edge
{
	int u,v,w;
	bool operator<(const Edge &t)const
	{
		return w>t.w;
	}
}edge[M];
int n,m,q;
int Link[N],tot;
int L[M],R[M];
PIII seq[M];

void add(int u,int v,int w)
{
	e[u].push_back({v,w});
	e[v].push_back({u,w});
}

void del(int u,int v,int w)
{
	e[u].erase(find(e[u].begin(),e[u].end(),(PII){v,w}));
	e[v].erase(find(e[v].begin(),e[v].end(),(PII){u,w}));
}

bool dfs(int u,int fa,int x)
{
	if(u==x) return true;
	for(auto t:e[u])
	{
		int v=t.first,wid=t.second;
		if(v==fa) continue;
		Link[++tot]=wid;
		if(dfs(v,u,x)) return true;
		tot--;
	}
	return false;
}

signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	
	cin>>n>>m;
	for(int i=1,u,v,w;i<=m;i++) cin>>u>>v>>w,edge[i]={u,v,w};
	sort(edge+1,edge+1+m);
	
	memset(L,-0x3f,sizeof L),memset(R,0x3f,sizeof R);
	for(int i=1;i<=m;i++)
	{
		int u=edge[i].u,v=edge[i].v,w=edge[i].w;
		tot=0;
		if(dfs(u,-1,v))
		{
			int id,maxv=-inf;
			for(int i=1;i<=tot;i++) 
			{
				int x=Link[i];
				if(edge[x].w>maxv) maxv=edge[x].w,id=x;
			}
			int mid=w+maxv>>1;
			R[i]=mid,L[id]=mid+1;
			int x=edge[id].u,y=edge[id].v;
			del(x,y,id);
		}
		add(u,v,i);
	}
	
	tot=0;
	for(int i=1;i<=m;i++) 
	{
		int w=edge[i].w;
		seq[++tot]={L[i],{w,-1}};
		seq[++tot]={edge[i].w,{-w*2,2}};
		seq[++tot]={R[i]+1,{w,-1}};
	}
	
	sort(seq+1,seq+1+tot);
	
	cin>>q;
	int i=0,cnt=0,sum=0;
	while(q--)
	{
		int x;
		cin>>x;
		while(i<=tot&&seq[i].first<=x) 
		{
			sum+=seq[i].second.first,cnt+=seq[i].second.second,i++;
		}
		cout<<(cnt*x+sum)<<"\n";
	}
	
	return 0;
}
```


---

## 作者：thomaswmy (赞：4)

为啥大家写的全是 LCT 啊/yiw

orz 4182_543_731

首先注意到对于一条边，在 $x\leq w_i$ 时，$x$ 越大越优，$x\geq w_i$ 同理。所以他关于时间在最小生成树内一定是一段包含 $w_i$ 区间（可能不是一颗树，但是总权值和是对的）。

那么我们考虑分治，把时刻 $mid$ 的最小生成树扒出来，不在生成树中的边只对一侧有贡献；在生成树上的边出现的区间如果包含了一侧就可以把两个点缩起来考虑。运用类似线段树的分析可以得知这部分复杂度 $O(m\log v)$。

细节方面你可以直接用可撤销并查集。但是注意到分治下去后在并查集上只有 $O(\texttt{边数})$ 个点的父亲改动了，所以直接存下来复杂度是对的。最终复杂度大概是 $O(m\alpha(n)\log v)$。

[code](https://www.luogu.com.cn/paste/gi0qyqry)

---

## 作者：To_our_starry_sea (赞：2)

### Soulution

简要题意：已知 $n$ 个点，$m$ 条权值为 $w_i$ 的边。共有 $q$ 次询问，每次给出常数 $x$，而每条边的边长变为 $|w_i - x|$，求最小生成树大小。

首先，如果我们每次都跑 kruskal 的话时间复杂度是 $O(qm \log m)$ 的，显然无法通过。注意到 $n$ 很小，因此我们尝试将利用这一性质。从 $|w_i - x|$ 入手，可以发现其一定是一个 V 形结构，且斜率的绝对值都为 $1$，从而对于任意两条边，其关于 $x$ 的权值函数至多只有一个交点，即每条边对应着唯一一个对答案有贡献的区间 $[l_i, r_i]$，接下来我们尝试求解这一区间。

我们将所有边按照 $w_i$ 从小到大排序，对于第 $i$ 条边，我们直接从 $i - 1$ 到 $1$ 枚举边并用并查集维护连通性。当加入第 $j$ 条边之后，$u_i$ 与 $v_i$ 在一个联通快内时停止。容易发现如果此时将第 $i$ 条边换成第 $j$ 条更优，则 $x - w_i > w_j - x$，即 $x > \frac{w_i + w_j}{2}$。则 $l_i \gets \lfloor \frac{w_i + w_j}{2} \rfloor + 1$，$r_j \gets \lfloor \frac{w_i + w_j}{2} \rfloor + 1$，边界条件二者取等皆可。

这么做似乎是 $O(m ^ 2)$ 的，然而事实上并非如此。下面我们考虑如何证明。

设 $g(i)$ 从 $(u_1, v_1)$ 到 $(u_i, v_i)$ 的边构成的集合的后缀最小生成树（森林）的大小，$f(i)$ 表示上述维护过程中加入后缀最小生成树（森林）的边的最小编号。注意到 $i - f(i) + 1 = g(i) - g(i - 1) + O(1)$，因为由归纳可知，每一次 $f(i)$ 向右的移动量不大于（或近似于） $g(i) - g(i - 1)$，而初始时的 $f(i) = 1$。同时 $\sum\limits_{i = 1}^{m} (i - f(i) + 1) = g(m)$，而 $g(m)$ 显然是不大于 $O(nm)$ 的。故时间复杂度上界为 $O(nm)$。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int MAXN = 1000005;
const int MAXM = 1000005;
const int MAXQ = 1000005;
const int INF = 1e9 + 5;
int n, m, q, cnt = 0, fa[MAXN], L[MAXN], R[MAXN], b[MAXN];
//ll sum[MAXN], S[MAXN];
map<int, ll> sum, S;
struct edge {
	int u, v;
	ll w;
	inline bool operator < (const edge &b) {
		if (w != b.w) return w < b.w;
		else if (u != b.u) return u < b.u;
		else return v < b.v;
	}
} e[MAXN];
inline int find(int k) {
	if (fa[k] == k) return k;
	else return fa[k] = find(fa[k]);
}
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-')
		   f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x * f;
}
int main() {
	n = read(), m = read();
	for (int i = 1; i <= m; i++) e[i].u = read(), e[i].v = read(), e[i].w = read(), L[i] = -INF, R[i] = INF;
	sort(e + 1, e + m + 1);
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) fa[j] = j;
		for (int j = i - 1; j >= 1; j--) {
			int fx = find(e[j].u), fy = find(e[j].v);
			if (fx == fy) continue;
			fa[fy] = fx;
			int fu = find(e[i].u), fv = find(e[i].v);
			if (fu == fv) {
				L[i] = R[j] = (e[i].w + e[j].w + 1) >> 1;
				break;
			}
		}
	}
	for (int i = 1; i <= m; i++) b[++cnt] = L[i], b[++cnt] = R[i], b[++cnt] = e[i].w;
	sort(b + 1, b + cnt + 1);
	cnt = unique(b + 1, b + cnt + 1) - b - 1;
	for (int i = 1; i <= m; i++) {
		int l = lower_bound(b + 1, b + cnt + 1, L[i]) - b, r = lower_bound(b + 1, b + cnt + 1, R[i]) - b;
		int w = lower_bound(b + 1, b + cnt + 1, e[i].w) - b;
		sum[l]--, sum[w] += 2, sum[r]--;
		S[l] += 1ll * e[i].w, S[w] -= 2ll * e[i].w, S[r] += 1ll * e[i].w;
	}
	q = read();
	int it = 1;
	ll ans1 = 0, ans2 = 0;
	while (q--) {
		ll x = read();
		while (it <= cnt && b[it] <= x) ans1 += sum[it], ans2 += S[it], it++;
		//cout << ans1 << " " << ans2 << endl;
		printf("%lld\n", x * ans1 + ans2); 
	}
	return 0;
}
```

---

## 作者：Maverik (赞：2)


有每次都重新跑最小生成树的暴力，复杂度 $O(Qm\log m)$。

随着 $X$ 增大，边的边权先斜率为 $-1$ 到达 $x$ 轴，再以 $1$ 的斜率增加。

在上述过程，分别以边权、编号作为第一、二关键字生成的最小生成树中。


容易证明：每条边只会在 $X$ 的一段区间内出现，设第 $i$ 条边出现对应区间为 $[l_i,r_i]$，考虑如何求 $l_i$，另一侧的 $r_i$ 是对称的。

感受这个过程，在 $X$ 增大的过程中，一条边会 直接 或者 替换别的边 加入到最小生成树 (森林) 中。

仅考虑后者，每条边作为对象去考虑，设 $i$ 替换 $j$，有：

- $w_j<w_i$，且 $w_j$ 是环上 $w$ 最小的边。

- 替换时 $x=\frac{w_i+w_j}{2}$，在 $w_i,w_j$ 之间。

- 替换时，所有 $w_k>w_i$ 的边 $k$，都不如 $w_i$ 更优，不会对此次替换产生影响。

由此可以按照上述方式对边排序，从小到大加边，添加到了 $i$：

- 如果边两边未联通，直接连接，$l_i=0$。

- 否则，找到 $(x_i,y_i)$ 最小的边 $j$ 并删除，连上 $(x_i,y_i)$，$r_j=l_i=\frac{w_i+w_j}{2}$。

最后统计答案即可。

过程可以用 LCT 维护做到 $O(m(\log n+\log m)+Q)$，当然也可以暴力维护做到 $O(nm\log n)$。


https://loj.ac/s/2008338



---

## 作者：zesqwq (赞：1)

简要题意：

给定 $m$ 个三元组 $(u_i,v_i,w_i)$，每次询问给出一个 $x$，保证询问的 $x$ 单调递增，查询对于所有 $1 \le i \le m$ 在树上连边 $(u_i, v_i, |w_i - x|)$，求 $\text{MST}$ 边权和。

---

结论：一个边在 $\text{MST}$ 中存在时的 $x$ 是一段连续区间。

做法：从大到小枚举边，维护动态树。加入一条边 $(u, v, w)$ 时，如果动态树上两点不联通，则直接加入，找到链上权值最大的边 $(u', v', w')$，那么当前这条边存在有条件 $x \le \dfrac {w + w'} 2$，另一条边存在有条件 $x > \dfrac {w + w'} 2$，然后删去那条边，加入该边即可，该部分可以用 LCT 维护。

这样就可以求出每条边存在时的 $x$ 区间。

最后询问直接双指针就行了，时间复杂度 $O(m (\log n + \log m) + q)$。

$\text{code}$：（不包含快读）完整答辩代码可以私信。

```cpp
const int N = 2e5 + 10;
int v[N], ch[N][2], fa[N], sum[N];
bool lzy[N];
#define lc(x) ch[x][0]
#define rc(x) ch[x][1]
inline bool isroot(int u) { return ch[fa[u]][0] != u && ch[fa[u]][1] != u; }
inline void connect(int u, int v, bool k) { ch[u][k] = v, fa[v] = u; }
inline bool get(int u) { return rc(fa[u]) == u; }
inline void pushup(int u) {
    if (u) {
        sum[u] = u;
        if (lc(u) && v[sum[lc(u)]] > v[sum[u]]) sum[u] = sum[lc(u)];
        if (rc(u) && v[sum[rc(u)]] > v[sum[u]]) sum[u] = sum[rc(u)];
    }
}
inline void maketag(int u) { lzy[u] ^= 1, swap(lc(u), rc(u)); }
inline void pushdown(int u) {
    if (lzy[u]) {
        if (lc(u)) maketag(lc(u));
        if (rc(u)) maketag(rc(u));
        lzy[u] = 0;
    }
}
inline void update(int u) {
    if (!isroot(u)) update(fa[u]);
    pushdown(u);
}
inline void rotate(int u) {
    bool k = get(u), kf = get(fa[u]);
    int f = fa[u];
    if (isroot(f))
        fa[u] = fa[f];
    else
        connect(fa[f], u, kf);
    connect(f, ch[u][k ^ 1], k), connect(u, f, k ^ 1);
    pushup(f), pushup(u);
}
inline void splay(int u) {
    update(u);
    for (int f = fa[u]; f = fa[u], !isroot(u); rotate(u))
        if (!isroot(f)) rotate(get(u) == get(f) ? f : u);
}
inline void access(int u) {
    for (int f = 0; u; u = fa[f = u]) splay(u), rc(u) = f, pushup(u);
}
inline void makeroot(int u) { access(u), splay(u), maketag(u); }
inline void split(int u, int v) { makeroot(u), access(v), splay(v); }
inline int find(int u) {
    access(u), splay(u), pushdown(u);
    while (lc(u)) pushdown(u = lc(u));
    return splay(u), u;
}
inline void link(int u, int v) {
    makeroot(u), fa[u] = v;
}
inline void cut(int u, int v) {
    split(u, v);
    if (lc(v) == u && !rc(u)) lc(v) = fa[u] = 0, pushup(v);
}
int n, m;
struct Edge {
    int u, v, w;
    inline bool operator<(Edge b) const { return w > b.w; }
} e[N];
pair<ll, pair<ll, int> > vec[N * 3];
int L[N], R[N],top;
int main() {
    read(n, m);
    memset(L, -0x3f, sizeof(L)), memset(R, 0x3f, sizeof(R));
    for (int i = 1; i <= m; i++) read(e[i].u, e[i].v, e[i].w);
    sort(e + 1, e + m + 1);
    for (int i = 1; i <= m; i++) v[i + n] = e[i].w;
    for (int i = 1; i <= n + m; i++) pushup(i);
    for (int i = 1; i <= m; i++) {
        if (find(e[i].u) == find(e[i].v)) {
            split(e[i].u, e[i].v);
            int c = sum[e[i].v] - n;
            cut(e[c].u, c + n);
            int M = e[c].w + e[i].w >> 1;
            R[i] = M, L[c] = M + 1;
        }
        link(e[i].u, i + n), link(i + n, e[i].v);
    }
    for (int i = 1; i <= m; i++) {
        vec[++top] = {L[i], {e[i].w, -1}};
        vec[++top] = {e[i].w, {-e[i].w * 2, 2}};
        vec[++top] = {R[i] + 1, {e[i].w, -1}};
    }
    sort(vec + 1, vec + top + 1);
    ll ans = 0;
    int q, x, r = 0;
    read(q);
    ll sum = 0, tot = 0;
    while (q--) {
        read(x);
        while (r <= top && vec[r].first <= x)
            sum += vec[r].second.first, tot += vec[r].second.second, ++r; 
        println(sum + tot * x);
    }
    return 0;
}
```

---

## 作者：Felix72 (赞：0)

受 kruskal 的贪心做法启发，我们想到了一个简单贪心：把当前询问的值当作一个中线，左右两边各维护一个指针贪心加边。但这样复杂度难以优化，预处理每种中线左右两边可能会选的边后也只能达到 $O(NM + QNα(N))$。

考虑这个询问值递增，其实就是引导我们离线（或者在线扫描），可以试着维护中线移动时边的变化情况。假如中线从左向右移动，一条边会在某个时刻被加入生成树，另一个时刻被权值更小的边替换，即每条边的贡献时间段是一个区间。

思考有什么办法能算出边之间的替换情况。首先假设中线为 $-\infin$，求出此时最小生成树的边，若这里面编号最大（已按照权值排序）的边编号是 $id$，则从 $id + 1$ 开始，考虑这条边会替换哪条边。略加思考后会发现，替换的是在生成树对应路径上且编号最小的边。因此维护生成树和替换方式，最后用指针扫描一遍就好了。

```cpp
/*Good Game, Well Play.*/
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 510, M = 100010, Q = 1000010;
typedef pair < int, int > PII;
int n, m, k; bool is[M]; vector < PII > edge[N];
struct node {int x, y, val;} s[M];
inline bool cmp(node u, node v) {return u.val < v.val;}

struct DSU
{
	int prt[N], siz[N];
	inline void init() {for(int i = 1; i <= n; ++i) prt[i] = i, siz[i] = 1;}
	inline int find(int x)
	{
		if(prt[x] == x) return x;
		prt[x] = find(prt[x]);
		return prt[x];
	}
	inline void merge(int x, int y)
	{
		int u = find(x), v = find(y);
		if(u != v)
		{
			if(siz[u] > siz[v]) swap(u, v);
			prt[u] = v, siz[v] += siz[u], siz[u] = 0;
		}
	}
}; DSU dsu;

int p1, p2, comp;
inline bool search(int now, int prt, int goal)
{
	if(now == goal) return true;
	for(PII li : edge[now])
	{
		if(li.first == prt) continue;
		if(search(li.first, now, goal))
		{
			if(li.second < comp)
			{
				comp = li.second;
				p1 = now, p2 = li.first;
			}
			return true;
		}
	}
	return false;
}
struct Change
{
	int x, y, lim;
	bool operator < (const Change &w) const {return lim < w.lim;}
	bool operator > (const Change &w) const {return lim > w.lim;}
} c[M]; int cn;

struct BIT
{
	long long c[M];
	inline void add(int pos, long long num)
	{for(int i = pos; i <= m; i += lowbit(i)) c[i] += num;}
	inline long long ask(int pos)
	{
		long long ans = 0;
		for(int i = pos; i; i -= lowbit(i)) ans += c[i];
		return ans;
	}
	inline long long query(int l, int r)
	{if(l > r) return 0; else return ask(r) - ask(l - 1);}
}; BIT T[2];

int q[Q]; long long ans[Q];

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= m; ++i)
		cin >> s[i].x >> s[i].y >> s[i].val;
	sort(s + 1, s + m + 1, cmp);
	int p = 0; dsu.init();
	for(int p = 1, cnt = 0; p <= m; ++p)
	{
		if(dsu.find(s[p].x) != dsu.find(s[p].y))
		{
			dsu.merge(s[p].x, s[p].y), ++cnt;
			is[p] = true;
			edge[s[p].x].push_back({s[p].y, p});
			edge[s[p].y].push_back({s[p].x, p});
		}
		if(cnt == n - 1) break;
	}
	for(int i = p + 1; i <= m; ++i)
	{
		comp = 1e9; search(s[i].x, 0, s[i].y);
//		cerr << "! " << s[i].x << " " << s[i].y << " " << comp << " " << p1 << " " << p2 << '\n';
		c[++cn].x = comp, c[cn].y = i;
		c[cn].lim = ((s[comp].val + s[i].val + 1) / 2);
		vector < PII > tmp;
		for(PII li : edge[p1])
			if(li.first != p2)
				tmp.push_back(li);
		edge[p1] = tmp; tmp.clear();
		for(PII li : edge[p2])
			if(li.first != p1)
				tmp.push_back(li);
		edge[p2] = tmp; tmp.clear();
		edge[s[i].x].push_back({s[i].y, i});
		edge[s[i].y].push_back({s[i].x, i});
	}
	for(int i = 1; i <= m; ++i)
	{
		if(!is[i]) continue;
		T[0].add(i, 1);
		T[1].add(i, s[i].val);
	}
	cin >> k;
	for(int i = 1; i <= k; ++i) cin >> q[i];
	sort(c + 1, c + cn + 1);
//	for(int i = 1; i <= cn; ++i) cerr << c[i].x << " " << c[i].y << " " << c[i].lim << '\n';
	for(int i = 1, p = 1; i <= k; ++i)
	{
		while(p <= cn && c[p].lim <= q[i])
		{
			T[0].add(c[p].x, -1); T[1].add(c[p].x, -s[c[p].x].val);
			T[0].add(c[p].y, 1); T[1].add(c[p].y, s[c[p].y].val);
			++p;
		}
		int l = 1, r = m, dv = 0;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(s[mid].val <= q[i]) dv = mid, l = mid + 1;
			else r = mid - 1;
		}
		ans[i] += (T[0].query(1, dv) * q[i] - T[1].query(1, dv));
		ans[i] += (T[1].query(dv + 1, m) - T[0].query(dv + 1, m) * q[i]);
	}
	for(int i = 1; i <= k; ++i) cout << ans[i] << '\n';
	return 0;
}
/*

*/
```

---


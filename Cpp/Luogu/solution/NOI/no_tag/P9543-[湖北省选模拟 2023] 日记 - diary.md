# [湖北省选模拟 2023] 日记 / diary

## 题目描述

小 M 决定开始写日记，但她不愿意花费太多时间构思日记的内容。为此，她找来了一个长度为 $n$ 的字符串 $S$，决定任取 $S$ 的一个前缀 $P$，再任取 $S$ 的一个后缀 $Q$，将 $P$ 和 $Q$ 顺次连接起来得到的字符串 $P+Q$ 作为日记的内容。这里，空串也认为是 $S$ 的前缀和后缀，因此 $P$ 和 $Q$ 各有 $n+1$ 种取法。

当然了，这样形成的很多字符串是无意义的。具体而言，小 M 认为一个已知的长度为 $m$ 的字符串 $T$ 为重要信息，所有包含该重要信息作为子串的字符串都是有意义的，反之则是无意义的。

请你求出，小 M 一共能写出多少种本质不同的有意义的字符串。本质不同就是说，对于某个有意义的字符串 $A$ ，即使它可以被若干种取前缀和后缀的方式得到，也只应被计入一次。

## 说明/提示

### 样例 1 解释

对于第一组样例，所有能够形成的有意义字符串分别为  `ab`，`aab`，`aaab`，`aaaab`，`aabaab`，`aabab`，`aabb`，一共 $7$ 种。

### 子任务

对于所有测试数据，保证 $1 \leq |S| \leq 5 \times 10^6$，$1 \leq |T| \leq 2|S|$，输入的字符串 $S$ 和 $T$ 仅包含小写英文字母。其中 $|S|,|T|$ 分别表示串 $S$ 和 $T$ 的长度。

![](https://cdn.luogu.com.cn/upload/image_hosting/j2ymssdo.png)

- 2023.8.21 添加一组 hack 数据。

## 样例 #1

### 输入

```
aab
ab```

### 输出

```
7```

## 样例 #2

### 输入

```
mikageandspica
spica```

### 输出

```
140```

## 样例 #3

### 输入

```
见选手目录下的 diary/diary3.in 与 diary/diary3.ans。```

### 输出

```
见选手目录下的 diary/diary3.in 与 diary/diary3.ans。```

## 样例 #4

### 输入

```
见选手目录下的 diary/diary4.in 与 diary/diary4.ans。```

### 输出

```
见选手目录下的 diary/diary4.in 与 diary/diary4.ans。```

## 样例 #5

### 输入

```
见选手目录下的 diary/diary5.in 与 diary/diary5.ans。```

### 输出

```
见选手目录下的 diary/diary5.in 与 diary/diary5.ans。```

# 题解

## 作者：Alex_Wei (赞：8)

### *[P9543 [湖北省选模拟 2023] 日记 / diary](https://www.luogu.com.cn/problem/P9543)

相当酷的一道题目。

设 $n = |S|$，$m = |T|$。

$10 ^ 7$ 的数据范围告诉我们题目的时间复杂度只能是线性或常数极小的单 $\log$。

首先让我们思考线性时间能求出哪些信息。KMP，扩展 KMP，Manacher，Lyndon 分解，最小表示法等字符串算法都是可以接受的，不过至于 SA，SAM 这样的后缀数据结构就别想了。因为本题和回文与字典序没有太大关系，而和 “一个字符串在另一个字符串中出现” 密切相关，所以我们猜测本题的主要算法是 KMP 和扩展 KMP。

不妨将限制放宽一些。如果不要求得到的字符串包含 $T$ 作为子串，能做吗？**必须能**。构造 $|T| = 1$ 且 $S_1 = S_n = T_1$，可知原问题不弱于：任选 $S$ 的可空前缀 $P$ 与可空后缀 $Q$，求本质不同的 $P + Q$ 的数量。

该问题容易在线性时间内解决：对于每个本质不同的 $R = P + Q$，只在最后一个分割点处统计它，即枚举 $R$ 与 $S$ 的最长公共前缀长度 $L$，并认为 $P = S_{1\sim L}$。因此，对于每个 $P$，所有合法的 $Q$ 形如：若 $P = S$，则 $Q$ 为任意后缀；若 $P\neq S$ 即 $L < n$，则 $|Q| = 0$ 或 $Q_1 \neq S_{L + 1}$，否则 $S$ 与 $R$ 的最长公共前缀还可以更长，即 $L$ 可以更大。用总数 $(n + 1) ^ 2$ 减去对每个 $0 \leq L < N$，第一个字符等于 $S_{L + 1}$ 的非空后缀数量，即字符 $S_{L + 1}$ 在 $S$ 中出现的次数。

尝试加入 $T$ 在 $R$ 中出现的限制，有三种情况：$T$ 在 $P$ 中出现；$T$ 在 $Q$ 中出现；$T$ 等于 $P$ 的非空后缀加上 $Q$ 的非空前缀。但这三种情况可能同时发生，再加上本质不同的要求，根本无从下手。但很显然，$T$ 在 $P$ 或 $Q$ 中出现的情况更容易考虑一些，因为它只与 $P$ 或 $Q$ 相关，而不同时与 $P, Q$ 相关。我们希望尽可能排除这两种情况，简化问题。

先看看用上面的算法能推出哪些东西吧：设 $f(i, j)$ 表示不要求 $T$ 在 $R$ 中出现过，$|P| \leq i$ 且 $|Q|\leq n - i + 1$ 的本质不同的 $R$ 的数量，可以线性计算。容斥是必要的。首先用 $f(n, 1)$ 估计答案，但是多算了不包含 $T$ 的 $R$。只要 $P$ 或 $Q$ 包含 $T$，那么 $R$ 一定包含 $T$。故考虑设 $T$ 在 $S$ 中第一次出现的 **结束位置** 为 $c$，最后一次出现的 **开始位置** 为 $d$，若 $P$ 的结束位置在 $c$ 及其右侧，或 $Q$ 的开始位置在 $d$ 及其左侧，那么 $R$ 一定包含 $T$。特别地，若 $T$ 没有在 $S$ 中出现，可认为 $c = n + 1$，$d = 0$。

在容斥减去不包含 $T$ 的 $R$ 的数量时，可以限制 $|P| < c$ 且 $|Q| < n - d + 1$。用 $f(c - 1, d + 1)$ 估计这个值，将导致答案少算了 **存在** 分割方式使得 $|P| < c$ 且 $|Q| < n - d + 1$ 的包含 $T$ 的 $R$ 的数量。

将 $c$ 减去 $1$，$d$ 加上 $1$，我们将问题转化为了：计算 $P$ 的结束位置在 $c$ 及其左侧，$Q$ 的结束位置在 $d$ 及其右侧，且 $T$ 在 $R$ 中出现过的本质不同的 $R$ 的数量。根据 $c$ 和 $d$ 的定义，可知 $P$ 和 $Q$ 不可能单独包含 $T$。因此，$T$ 必然等于 $P$ 的某个 **非空** 后缀加上 $Q$ 的某个 **非空** 前缀。在这个前提下，关于 “$T$ 在 $R$ 中出现” 的限制，有两种思路：

**思路一**：枚举 $|P|$，那么合法的 $Q$ 满足：存在 $L$ 使得 $P$ 的长度为 $L$ 的后缀等于 $T$ 的长度为 $L$ 的前缀，且 $Q$ 的长度为 $n - L$ 的前缀等于 $T$ 的长度为 $n - L$ 的后缀。

- 刻画 $L$ 的形态：建出 $T$ 的失配树，设 $P$ 与 $T$ 的最长公共后缀前缀为 $len$（KMP 求出），那么 $L$ 是失配树上 $len$ 的祖先。
- 刻画 $Q$ 的形态：建出 $T$ 的反串的失配树，设 $Q$ 与 $T$ 的最长公共前缀后缀为 $len$，那么 $n - L$ 是失配树上 $len$ 的祖先。固定 $L$，合法的 $Q$ 是 $T$ 的反串的失配树的某棵子树。因此合法的 $Q$ 是该失配树的若干子树的并，这很难处理，更何况还有本质不同的限制。这种思路并不可行。

**思路二**：从 $R$ 中删去 $T$，设 $P$ 和 $Q$ 变成了 $P'$（$P'$ 是 $P$ 的前缀，且 $P' \neq P$）和 $Q'$（$Q'$ 是 $Q$ 的后缀，且 $Q'\neq Q$），枚举 $L = |P'|$，设 $S_{L + 1\sim c}$ 与 $T$ 的最长公共前缀为 $x$，那么要求 $S_{d\sim n - |Q'|}$ 与 $T$ 的最长公共后缀 $y\geq m - x$。

先不管本质不同，合法的 $(P', Q')$ 二元组数量是可以计算的：对每个 $1\leq i\leq c$，使用扩展 KMP 求出 $S_{i\sim c}$ 与 $T$ 的最长公共前缀 $zs_i$；对每个 $d\leq j\leq n$，使用扩展 KMP 求出 $S_{d\sim j}$ 与 $T$ 的最长公共后缀 $zs'_j$。注意到 $zs$ 和 $zs'$ 均小于 $m$，所以 $P'$ 不会以位置 $c$ 结尾（否则要求 $Q$ 完全包含 $T$），同理 $Q'$ 不会以位置 $d$ 开头。因此，合法的 $(P', Q')$ 二元组数量就等于 $\sum_{i = 1} ^ c\sum_{j = d} ^ n [zs_i + zs'_j \geq m]$。这是一维偏序，复杂度线性。

加入本质不同的限制，我们希望在最小的 $|P'|$ 的位置统计 $R$。不能存在 **合法** 的 $(P'', Q'')$ 使得 $P'' + T + Q'' = P' + T + Q'$ 且 $|P''| < |P'|$，为此，尝试探究什么样的 **合法** 二元组需 $(P', Q')$ 要舍去。

考虑两个 **合法** 二元组 $(P_1', Q_1')$ 和 $(P_2', Q_2')$ 满足 $R = P_1' + T + Q_1' = P_2' + T + Q_2'$。不妨设 $|P_1'| < |P_2'|$，则 $(P_2', Q_2')$ 需要被舍去。设 $per = |P_2'| - |P_1'|$，则 $per < m$（否则 $T$ 在 $P_2'$ 中出现）。

- 根据 $P_1' + T + Q_1' = P_2' + T + Q_2'$，可知 $P_2'$ 与 $T$ 有长度为 $per$ 的公共后缀前缀，且 $Q_1'$ 与 $T$ 有长度为 $per$ 的公共前缀后缀。又因为 $Q_1'$ 的起始位置在 $d$ 及其右侧，所以后者等价于 $S_{d\sim n - |Q_2'|}$ 与 $T$ 有长度为 $per$ 的公共后缀，即 $zs'_{n - |Q_2'|} \geq per$。
- 设 $R = P_1' + T' + Q_2'$，那么 $|T'| = m + per$ 且 $T$ 为 $T'$ 的 border。这说明 $T'$ 有长度为 $per$ 的 period，继而推出 $T$ 有长度为 $per$ 的 period。

综上，得 $(P_2', Q_2')$ 需要被舍去的必要条件：存在 $per$ 同时满足

- $per$ 是 $T$ 的 period。
- $P_2'$ 与 $T$ 有长度为 $per$ 的公共后缀前缀。
- $zs'_{n - |Q_2'|} \geq per$。

充分吗？充分性是容易证明的。

枚举 $|P_2'|$。显然我们只关心最小的 $per$ 使得 $per$ 是 $T$ 的 period 且 $P_2'$ 与 $T$ 有长度为 $per$ 的公共后缀前缀，因为对于所有这样的 $per$，如果 $zs'_{n - |Q_2'|}$ 小于最小的 $per$，那么更大的  $per$ 也不会让它被舍去。

综上，枚举 $0\leq i = |P'| < c$，求出对应的最小的 $per$（标记所有 period，然后在失配树上 DP），合法的 $Q'$ 的起始位置 $d < j \leq n + 1$ 满足：

- $zs_{i + 1} + zs'_{j - 1} \geq m$。
- $zs'_{j - 1} < per$。

看上去是二维偏序，但这就是 $m - zs_{i + 1} \leq zs'_{j - 1} < per$，还是一维偏序，前缀和即可。

时间复杂度 $\mathcal{O}(n + m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

bool Mbe;
constexpr int N = 1e7 + 5;

ll ans;
int n, m, f[N], fst = -1, lst = -1;
int zs[N], _zs[N], zt[N];
int ns[N], nt[N], buc[N];
char s[N], t[N];

void calcnxt(int *nt, int *ns) {
  for(int i = 2; i <= m; i++) {
    int j = nt[i - 1];
    while(j && t[j + 1] != t[i]) j = nt[j];
    nt[i] = j + (t[j + 1] == t[i]);
  }
  for(int i = 1; i <= n; i++) {
    int j = ns[i - 1];
    while(j && t[j + 1] != s[i]) j = nt[j];
    ns[i] = j + (t[j + 1] == s[i]);
  }
}

void calcz(int *zt, int *zs) {
  int l = 1, r = 0;
  for(int i = 2; i <= m; i++) {
    int j = i > r ? 0 : min(zt[i - l + 1], r - i + 1);
    while(t[j + 1] == t[i + j]) j++;
    if(i + j > r) l = i, r = i + j - 1;
    zt[i] = j;
  }
  l = 1, r = 0;
  for(int i = 1; i <= n; i++) {
    int j = i > r ? 0 : min(zt[i - l + 1], r - i + 1);
    while(i + j <= n && t[j + 1] == s[i + j]) j++;
    if(i + j > r) l = i, r = i + j - 1;
    zs[i] = j;
  }
}

ll calc(int l, int r) {
  ll res = 1ll * (l + 1) * (n - r + 2);
  vector<int> cnt(26);
  for(int i = r; i <= n; i++) cnt[s[i] - 'a']++;
  for(int i = 1; i <= l; i++) res -= cnt[s[i] - 'a'];
  return res;
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE *IN = freopen("diary.in", "r", stdin);
    FILE *OUT = freopen("diary.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

  cin >> s + 1 >> t + 1;
  n = strlen(s + 1), m = strlen(t + 1);

  calcz(zt, _zs);
  reverse(s + 1, s + n + 1);
  reverse(_zs + 1, _zs + n + 1);
  reverse(t + 1, t + m + 1);
  calcz(zt, zs), calcnxt(nt, ns);

  for(int i = 0; i <= m; i++) f[i] = m;
  for(int i = nt[m]; i; i = nt[i]) f[m - i] = m - i;
  for(int i = 1; i <= m; i++) f[i] = min(f[i], f[nt[i]]);

  for(int i = m; i <= n; i++) if(ns[i] == m) fst == -1 && (fst = i - 1), lst = i - m + 2;
  if(fst != -1) ans = calc(n, 1) - calc(fst, lst);
  else fst = n, lst = 1;

  for(int i = 1; i <= fst; i++) zs[i] = min(zs[i], fst - i + 1);
  for(int i = lst; i <= n; i++) buc[_zs[i] = min(_zs[i], i - lst + 1)]++;
  for(int i = 1; i <= n; i++) buc[i] += buc[i - 1];
  for(int i = 1; i <= fst; i++) {
    int l = m - zs[i], r = min(n, f[ns[i - 1]] - 1);
    if(l <= r) ans += buc[r] - buc[l - 1];
  }
  cout << ans << "\n";

  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}

/*
g++ diary.cpp -o diary -O2 -std=c++14 -DALEX_WEI
*/
```

---

## 作者：EternalAlexander (赞：7)

为了保证 $P+Q$ 互不相同，将答案计算在尽可能长的后缀上。也就是说，使 $Q$ 的长度最大。
	
对于 $T$ 在 $P$ 或者 $Q$ 中出现过的情况，答案是比较容易统计的。我们面对的主要矛盾是， $T$ 只在跨过 $P$ 和 $Q$ 的分界线的位置出现过的情况。
	
我们考虑 $T$ 在 $P+Q$ 中某一次出现的位置。考虑 $T$ 在 $Q$ 中的部分 $T_Q$，它一定是 $S$ 的某个前缀与 $T$ 的 LCS （否则不满足之前对后缀尽可能长的限制）。同时，这样的 $Q$ 就是这个 LCS 加上这个前缀的结尾到串的结尾的那一部分字符串。
	
如果我们枚举了这个前缀，就可以求得 $T_Q$。接下来只需要找出来有多少个前缀 $P$ 可以包含 $T$ 中剩下的部分。也就是说，有多少个后缀和 $T$ 的 LCP 至少是 $|T| - |T_Q|$。
	
这样计算可以保证考虑的 $P+Q$ 是互不相同的，但是在同一种 $P+Q$ 中，如果 $T$ 出现了多次，也会被统计多次。为了解决这个问题，我们尝试能不能只统计 $T$ 在每一种 $P+Q$ 的方案中的最后一次出现的位置。
	
我们考虑，对于前缀 $i$，如果有前缀 $j$，使得 $j<i$，而且 $i$ 和 $j$ 相差 $T$ 的某个周期，而且 $i$ 和 $j$ 两个位置对应的 $Q$ 是一样的，并且我们在 $i$ 处统计过了答案，那我们就标记 $j$，表示不再在 $j$ 处统计答案。
	
首先这样自然是不重的。然后，假如某个 $P+Q$ 中 $T$ 的结尾出现在 $j$ 处，可以推出 $T$ 同样也在 $i$ 处出现过。因此也是不漏的。

![](https://cdn.luogu.com.cn/upload/image_hosting/brhr9ibk.png)

	
具体实现时暴力即可，标记时按顺序枚举 $T$ 的周期，遇到被标记过的就停止。可以说明每个位置至多被标记一次。求每个前缀/后缀和 $T$ 的 LCP/LCS 可以用 Z 算法，总复杂度 $O(n + m)$。

```cpp
#include <bits/stdc++.h>

const int maxn = 1e7 + 222;
using ll = long long;

char s[maxn],t[maxn];
int n,m,Z[maxn],a[maxn],b[maxn],cnt[55],cnt1[55],sum[maxn],ban[maxn],flag,lim,lim1,tot;
ll ans = 0;
std::vector<int>peri;

void work(char *s,int m,char *t,int n,int *P) {
	for (int i = 0; i <= std::max(n,m) + 1; ++ i) Z[i] = 0;
	for (int i = 0; i <= std::max(n,m)  + 1; ++ i) P[i] = 0;
	int p = 0, r = 0;
	Z[1] = n;
	for (int i = 2; i <= n; ++ i) {
		if (i <= r) Z[i] = std::min(r - i + 1,Z[1 + i - p]);
		while (i + Z[i] <= n && t[i + Z[i]] == t[1 + Z[i]])
			Z[i] ++;
		if (i + Z[i] - 1 > r) {
			r = i + Z[i] - 1;
			p = i;
		}
	} p = 0, r = 0; 
	for (int i = 1; i <= m; ++ i) {
		if (i <= r) P[i] = std::min(r - i + 1,Z[1 + i - p]);
		while (i + P[i] <= m && 1 + P[i] <= n && s[i + P[i]] == t[1 + P[i]])
			P[i] ++;
		if (i + P[i] - 1 > r) {
			r = i + P[i] - 1;
			p = i;
		}
	} 
}

int main() {
	scanf("%s%s",s + 1,t + 1);
	n = strlen(s + 1);
	m = strlen(t + 1);
	s[0] = s[n + 1] = 26 + 'a'; 
	std::reverse(s + 1,s + n + 1);
	std::reverse(t + 1,t + m + 1);
	work(s,n,t,m,b);
	std::reverse(b + 1,b + n + 1);
	std::reverse(s + 1,s + n + 1);
	std::reverse(t + 1,t + m + 1);
	work(s,n,t,m,a);
	for (int i = 2; i <= m; ++ i) 
		if (Z[i] == m - i + 1) peri.push_back(i - 1);
	// in prefix
	for (int i = 0; i <= n; ++ i) cnt[s[i] - 'a'] ++;
	for (int i = 0; i <= n; ++ i) {
		if (i >= m && a[i - m + 1] == m) { flag = 1; if (!lim) lim = i; }
		if (flag) {  ans += (n + 1 - cnt[s[i + 1] - 'a']); }
		else { cnt1[s[i + 1] - 'a'] ++ ; tot ++; }
	}
	if (!lim) lim = n + 1;
	// in suffix
	flag = 0;
	for (int i = n; i >= 1; i --) {
		if (i + m - 1 <= n && b[i + m - 1] == m) { flag = 1; if (!lim1) lim1 = i; }
		if (flag) ans += (tot - cnt1[s[i] - 'a']);
	}
	for (int i = n; i >= 1; i --) {
		int w = std::min(b[i],i - lim1);
		if (w >= 0) sum[w] ++;
	}
	for (int i = m; i >= 1; i --) sum[i] += sum[i + 1];
	ans += flag;
	// otherwise
	for (int i = 1; i <= n; ++ i) {
		if (i + a[i] - 1 >= lim) continue;
		if (!a[i]) continue;
		if (ban[i]) continue;
		ans += sum[m - a[i]];
		for (int t:peri) {
			if (t >= a[i]) break;
			ban[i + t] = 1;
			
		}
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：yyyyxh (赞：2)

一个更直接的想法。

首先考虑如何去重，这里的手法基本上都一样：钦定前缀是极长的，那么设你拿长度为 $i$ 的前缀和长度为 $j$ 的后缀去拼成一个串 $P=S_{[1,i]}+S_{[n-j+1,n]}$，我们只需要统计 $S_{i+1}\neq S_{n-j+1}$ 的 $P$ 就好了。

接下来考虑包含 $T$ 的条件，最简单的情况是长度为 $i$ 的前缀或长度为 $j$ 的后缀已经包含了 $T$。找到 $T$ 在 $S$ 中的第一次出现和最后一次出现，我们容易计算出这一部分对答案的贡献，注意这里需要开个桶处理一下 $S_{i+1}\neq S_{n-j+1}$ 的限制。

接下来考虑 $T$ 不在前缀后缀中出现但在 $P$ 中出现了的情况。先考虑怎么得到一个 $O(n^2)$ 的做法：我们对于每一个前缀，求出最长的 $T$ 的前缀满足其是该前缀的后缀，即 KMP 算法中维护的最大匹配长度。设其为 $x$，则我们知道跟这个前缀的某个后缀匹配的所有的 $T$ 的前缀是 $\{x,nxt_x,nxt_{nxt_x}\dots\}$，即 $x$ 在 $T$ 串 $nxt$ 树上到根的链。同理用 $T$ 的反串的 $nxt$ 树可以刻画出与每个后缀的匹配关系。那么问前缀后缀拼起来包不包括 $T$ 相当于是在问这两颗树上的到根的链中是否存在一对点满足它们的长度之和为 $|T|$。直接预处理复杂度就是 $O(n^2)$ 了。

接下来依然先枚举前缀，然后考虑所有与这个前缀的后缀匹配的 $T$ 的前缀 $x$，你发现，由于此时 $T_{x+1}$ 需要与你选出的后缀的第一个字符匹配，为了满足 $S_{i+1}\neq S_{n-j+1}$，就有 $T_{x+1}\neq S_{i+1}$。这令我们回想起了[用 KMP 偏序 Z 函数](https://www.cnblogs.com/yyyyxh/p/KMP-Z.html)中的处理方式。你可以看作用 $T$ 去跟 $S$ 的每一个前缀求 LCP，也就是说，对于所有前缀 $i$，其可能满足 $T_{x+1}\neq S_{i+1}$ 且 $T_{[1,x]}=S_{[i-x+1,i]}$ 的 $x$ 的总个数是 $O(n)$ 的！

我们可以直接跑 Z 函数，或者用 KMP 求 Z 的方法优化暴力跳，都可以得到每个前缀 $i$ 对应的所有 $x$，然后你需要在 $T$ 反串 $nxt$ 树中找到 $|T|-x$ 对应的子树，接下来你需要求出这些子树并中的权值之和，权值定义为每个节点匹配上的后缀的个数。

求子树并权值和看起来甩不掉 $\log$ 因子？我们可以离线！直接开个桶，然后计算每一个权值被多少个子树并算过贡献即可。时间复杂度 $O(n)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=5000003,M=10000003;
char s[N],t[M];
int n,m;
int nxt[N],sz[N];
int nx[N],jump[N];
int sum,w[26];
ll res;
int hd[N],ver[M],tran[M],tot;
void add(int u,int v){tran[++tot]=hd[u];hd[u]=tot;ver[tot]=v;}
int cnt[N],num;
void dfs(int u){
	res+=num*sz[u];
	for(int i=hd[u];i;i=tran[i]){
		int v=ver[i];
		if(v<0){if(!cnt[-v]++) ++num,res+=sz[u];}
		else dfs(v);
	}
	for(int i=hd[u];i;i=tran[i]){
		int v=ver[i];
		if(v<0){if(!--cnt[-v]) --num;}
		else break;
	}
}
int main(){
	scanf("%s%s",s+1,t+1);
	n=strlen(s+1);m=strlen(t+1);
	reverse(s+1,s+n+1);reverse(t+1,t+m+1);
	int tt=min(m-1,n);
	for(int i=2,j=0;i<=tt;++i){
		while(j&&t[j+1]!=t[i]) j=nxt[j];
		if(t[j+1]==t[i]) ++j;
		nxt[i]=j;
	}
	int pos=n+1;
	for(int i=1,j=0;i<=n;++i){
		while(j&&t[j+1]!=s[i]) j=nxt[j];
		if(t[j+1]==s[i]) ++j;
		if(j==m){pos=i;break;}
		if(j) ++sz[j];
	}
	for(int i=2;i<=tt;++i) if(nxt[i]) add(nxt[i],i);
	reverse(s+1,s+n+1);reverse(t+1,t+m+1);
	for(int i=2,j=0;i<=tt;++i){
		while(j&&t[j+1]!=t[i]) j=nx[j];
		if(t[j+1]==t[i]) ++j;
		nx[i]=j;
		if(t[i+1]==t[j+1]) jump[i]=jump[j];
		else jump[i]=j;
	}
	int lim=n+1;
	s[n+1]='#';
	for(int i=1,j=0;i<=n;++i){
		while(j&&t[j+1]!=s[i]) j=nx[j];
		if(t[j+1]==s[i]) ++j;
		if(j==m){lim=i;break;}
		for(int x=j;x;)
			if(t[x+1]!=s[i+1]){
				if(m-x<=tt) add(m-x,-i);
				x=nx[x];
			}
			else x=jump[x];
	}
	for(int i=1;i<=tt;++i) if(!nxt[i]) dfs(i);
	sum=pos;
	for(int i=1;i<pos;++i) ++w[s[n-i+1]-97];
	for(int i=lim;i<=n;++i){res+=sum;if(i<n) res-=w[s[i+1]-97];}
	memset(w,0,104);
	sum=n-pos+1;
	for(int i=pos;i<=n;++i) ++w[s[n-i+1]-97];
	for(int i=0;i<=n;++i){res+=sum;if(i<n) res-=w[s[i+1]-97];}
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：Schi2oid (赞：2)

非常具有启发性的字符串趣题。

下文中的 $n,m$ 表示 $|S|,|T|$，$i,j$ 表示 $P,Q$ 分别选择了 $s[1\dots i]$ 和 $s[j\dots n]$。

先去除掉包含 $T$ 的条件，来研究本质不同的限制，考虑将一个串切割为一个原串前缀和一个原串后缀的方式。考虑代表元设置为 $|P|$ 最大，形式化来说，计数前缀 $s[1\dots i]$ 和后缀 $s[j\dots n]$ 满足 $s[i+1]\not=s[j]$ 的 $(i,j)$ 对数，那么可以直接枚举 $i$，其对应 $j$ 数量就是 $n-cnt$，其中 $cnt$ 表示 $s$ 中 $s[i+1]$ 的出现次数。

上述做法得到了一个保证 $P+Q$ 不重的判据：$s[i+1]\not=s[j]$。

现在考虑包含 $T$ 的条件，可以通过简单容斥去除掉 $P$ 或 $Q$ 中包含 $T$ 的情况，也就是只需要求 $P$、$Q$ 中没有 $T$ 而拼起来后有 $T$ 的情况。相当于 $i$ 只能选一个前缀，$j$ 只能选一个后缀。

继续考虑前缀和后缀本身是不够明智的，因为我们无法得知一个前缀应该匹配到 $T$ 的哪个位置。现在，枚举一个位置 $p$，考察 $p$ 作为匹配 $T$ 的起始点时，其能向后匹配多长，即 $s[p\dots n]$ 和 $T$ 的 LCP，记为 $r_p$。根据上述判据，假设 $i<p+r_p-1$，那么 $s[1\dots i]+s[j\dots n]=s[1\dots i+1]+s[j+1\dots n]$，即 $s[i+1]=s[j]$，一定属于算重的情况，所以可以直接排除掉，这意味着对于每个 $p$，只有 $p+r_p-1$ 是合法的 $i$ 的取值。而关于 $j$，要求 $s[j\dots n]$ 拥有 $T[r_p+1\dots m]$ 的前缀，那么一个后缀所能匹配的 $r_p$ 是有限的，考虑将 $rev(T)$ 和 $rev(S)$ 用特殊符号连接后求出 next 数组，那么后缀 $j$ 能匹配的长度就是其对应位置不断跳 next 中遍历到的每一个长度。那么我们将贡献记在最长的 Border 上，即 $next_{m+1+j}$，最后倒序遍历将每个位置的值加到其 next 指向位置上即可。

到这里，我们保证了 $P+Q$ 不重，但是现在的问题是我们可能对同一组 $P,Q$ 计算多次，因为 $P+Q$ 中可能多次出现 $T$，而每一次出现都会有一次枚举 $p$ 时将其计算一次贡献。

考虑能否只计算 $T$ 第一次出现产生的贡献。尝试分析什么时候对于一组 $i,j$，从 $p_0$ 开始可以进行一次 $T$ 的匹配，并且存在一个 $p_0-x$ 且 $T$ 在 $p=p_0-x$ 时已经出现过，容易发现这等价于 $x$ 是 $T$ 的一个周期并且 $s[p_0-x,p_0-1]=T[1,x]$。必要性显然，关于充分性，条件保证前缀可以延长，而后缀缩短一定更有可能合法，所以每一个 $p_0$ 处的出现一定都对应一个 $p$ 处的出现。

因此，我们求出 $T$ 和 $S$ 用特殊符号连接后的 next 数组，显式地建出它的 next 树，将所有周期结点及其子树内结点打上标记，这可以通过一遍 dfs 处理。根据上一段得到的判据，如果 $m+1+p$ 结点被标记，说明存在一个 $x$，即这个 $p$ 是会算重的，直接跳过即可。

时间复杂度 $O(n+m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[10000005],t[10000005];
char st[20000005];
char rev_st[20000005];
int z[20000005],rev_z[20000005];
int nxt[20000005],ans[20000005];
vector<int>edge[20000005];
void Z(char *s,int *z,int n){
	int l=0,r=0;
	z[0]=0;
	for(int i=1;i<n;i++){
		if(z[i-l]<r-i+1) z[i]=z[i-l];
		else{
			z[i]=max(r-i+1,0);
			while(i+z[i]<n&&s[z[i]]==s[i+z[i]]) z[i]++;
			l=i,r=i+z[i]-1;
		}
	}
}
void KMP(char *s,char *t,int *nxt,int *ans,int n,int m){
	for(int i=2;i<=m;i++){
		int p=nxt[i-1];
		while(p&&t[p+1]!=t[i]) p=nxt[p];
		if(t[p+1]==t[i]) p++;
		nxt[i]=p;
	}
	for(int i=1;i<=n;i++){
		int p=ans[i-1];
		while(p&&t[p+1]!=s[i]) p=nxt[p];
		if(t[p+1]==s[i]) p++;
		ans[i]=p;
	}
}
void KMP1(char *s,int *nxt,int n){
	nxt[0]=-1;
	for(int i=1;i<n;i++){
		int p=nxt[i-1];
		while(p!=-1&&s[p+1]!=s[i]) p=nxt[p];
		if(s[p+1]==s[i]) p++;
		nxt[i]=p;
	}
}
int r[20000005];
bool vis[20000005];
long long c[20000005];
int cnt[2][30];
vector<int>peri;
void dfs(int x){
	for(int i=0;i<edge[x].size();i++){
		int v=edge[x][i];
		vis[v]|=vis[x];
		dfs(v);
	}
}
int main(){
	scanf("%s",s+1);
	scanf("%s",t+1);
	int n=strlen(s+1),m=strlen(t+1);
	for(int i=0;i<m;i++) st[i]=t[i+1];
	st[m]='$';
	for(int i=0;i<n;i++) st[m+1+i]=s[i+1];
	memcpy(rev_st,st,sizeof st);
	reverse(rev_st,rev_st+m);
	reverse(rev_st+m+1,rev_st+n+m+1);
	Z(st,z,n+m+1);
	Z(rev_st,rev_z,n+m+1);
	KMP(s,t,nxt,ans,n,m);
	int limi=n+1,limj=0;
	for(int i=1;i<=n;i++){
		if(ans[i]==m){
			limi=min(limi,i-1);
			limj=max(limj,i-m+2);
		}
	}
	for(int i=1;i<=n;i++){
		if(i<limj) cnt[0][s[i]-'a']++,cnt[1][s[i]-'a']++;
		else cnt[0][s[i]-'a']++;
	}
	long long ans=0;
	s[n+1]='z'+1;
	for(int i=0;i<=n;i++){
		if(i<=limi) ans+=max(limj-1-cnt[1][s[i+1]-'a'],0);
		else ans+=max(n+1-cnt[0][s[i+1]-'a'],0);
	}
	int len=nxt[m];
	while(len){
		vis[m-len]=1;
		len=nxt[len];
	}
	for(int i=1;i<=n;i++) r[i]=z[i+m];
	KMP1(rev_st,nxt,n+m+1);
	nxt[m+n+1]=-1;
	for(int i=limj;i<=n+1;i++) if(nxt[m+n-i+1]!=-1) c[nxt[m+n-i+1]]++;
	for(int i=m;i>=0;i--) if(nxt[i]!=-1) c[nxt[i]]+=c[i];
	for(int i=m;i>=1;i--) c[i]=c[i-1];
	KMP1(st,nxt,n+m+1);
	for(int i=0;i<n+m+1;i++) edge[nxt[i]+1].push_back(i+1);
	dfs(0);
	for(int p=1;p<=n;p++){
		int i=p+r[p]-1;
		if(vis[m+p]||i>limi||r[p]==0) continue;
		ans+=c[m-r[p]];
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：MEKHANE (赞：1)

厉害，这种题只有一点一点做才舒服。

首先考虑求出本质不同的选取前缀 $+$ 后缀的方案数，貌似可以拼起来上 SAM？但是考虑到数据范围 $|S| \le 5 \times 10^6$ 实在太困难。貌似没什么想法了。考虑到前缀和后缀可能重叠，也许这题前后缀的联系并不大。

考虑到本质不同的串一般有两种求法，一种是去重，一种是将贡献位置放在特定的地方（极小/极大），然后考虑限制其增量。考虑这题是否能用比较罕见的后者做。考虑枚举前缀长度 $l$，考虑它作为最长前缀的前提条件是什么。发现我们仅需考虑后一个位置是否能拓展，即后缀的首字母 $\neq S_{l+1}$，那么减一下就做完了。

然后我们考虑怎么放严限制，先考虑 $T$ 在 $S$ 中的位置，不难发现这已经对前缀的长度和后缀的长度进行了限制。继续放严，考虑在去除 $T$ 仅在拼接后的前缀和后缀中出现而不在前缀和后缀中出现的字符串。

考虑本质不同很难被 KMP 处理，那么我们考虑另辟蹊径。考虑在拼出的不合法字符串中**删去** $T$（可能会有多种，但是剩下的串拼起来依旧本质不同），那么考虑枚举分裂出的前缀和后缀长度，合法性判断就变成了后缀和 $T$ 的最长公共前缀和前缀与 $T$ 的最长公共后缀的问题（**可增量，好处理**）。

再度弱化：去掉本质不同怎么做。可以扩展 KMP 求原串和反串与 $T$ 的最长公共后缀，变为一维偏序。加入本质不同的限制后，我们同样的考虑极值算贡献，考虑去掉非最小位置的贡献。考虑前缀的长度差为 $pr$ ( $pr<m$ 否则会不合法)。同时我们发现，错位一致可得出周期的结论，与前缀后缀结合可得出约束（要求 $pr$ 尽量小）。

那么我们枚举分裂前缀长度，寻找最小的 $pr$ 使得合法，然后后缀的选择位置是一个区间，可以线性。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+5;
int n,m,zl=-1,zr=-1,cnt1[26],cnt[N],f[N],zs[N],zs1[N],zt[N],ns[N],nt[N],ans;
char s[N],t[N];
void js(int *z,int *z1){
    int l=1,r=0;
    for(int i=2;i<=m;i++){
        int dq=(i>r?0:min(z[i-l+1],r-i+1));
        while(t[1+dq]==t[i+dq]) dq++;
        if(i+dq>r) l=i,r=i+dq-1; z[i]=dq;
    }l=1,r=0;
    for(int i=1;i<=n;i++){
        int dq=(i>r?0:min(z[i-l+1],r-i+1));
        while(i+dq<=n&&t[1+dq]==s[i+dq]) dq++;
        if(i+dq>r) l=i,r=i+dq-1; z1[i]=dq;
    }
}
void js1(int *nxt,int *nxt1){
    for(int i=2;i<=m;i++){
        int dq=nxt[i-1];
        while(dq&&t[dq+1]!=t[i]) dq=nxt[dq];
        nxt[i]=dq+(t[dq+1]==t[i]);
    }
    for(int i=1;i<=n;i++){
        int dq=nxt1[i-1];
        while(dq&&t[dq+1]!=s[i]) dq=nxt[dq];
        nxt1[i]=dq+(t[dq+1]==s[i]);
    }
}
int tj(int l,int r){
    int res=(l+1)*(n-r+2);
    for(int i=0;i<26;i++) cnt1[i]=0;
    for(int i=r;i<=n;i++) cnt1[s[i]-'a']++;
    for(int i=1;i<=l;i++) res-=cnt1[s[i]-'a'];
    return res;
}
signed main(){
    ios::sync_with_stdio(false);
    cin>>(s+1)>>(t+1),n=strlen(s+1),m=strlen(t+1);
    js(zt,zs1),reverse(s+1,s+n+1),reverse(t+1,t+m+1);
    reverse(zs1+1,zs1+n+1),js(zt,zs),js1(nt,ns);
    for(int i=0;i<=m;i++) f[i]=m;
    for(int i=nt[m];i;i=nt[i]) f[m-i]=m-i;
    for(int i=1;i<=m;i++) f[i]=min(f[i],f[nt[i]]);
    for(int i=m;i<=n;i++) if(ns[i]==m){if(zl==-1) zl=i-1; zr=i-m+2;}
    if(zl!=-1) ans=tj(n,1)-tj(zl,zr);
    else zl=n,zr=1;
    for(int i=1;i<=zl;i++) zs[i]=min(zs[i],zl-i+1);
    for(int i=zr;i<=n;i++) zs1[i]=min(zs1[i],i-zr+1),cnt[zs1[i]]++;
    for(int i=1;i<=n;i++) cnt[i]+=cnt[i-1];
    for(int i=1;i<=zl;i++){
        int le=m-zs[i],ri=min(n,f[ns[i-1]]-1);
        if(le<=ri) ans+=cnt[ri]-cnt[le-1];
    }cout<<ans;
    return 0;
}
```



---


# [湖北省选模拟 2023] 调和 / concoct

## 题目描述

小 C 是一名药师，为了制作出某种药剂，她需要在 S 大陆上寻找一些药材。

S 大陆可以抽象为一棵 $n$ 个顶点的无根树，每个顶点上都有一种药材。每种药材的属性可以描述为一个三元组 $(x,y,z)$，其中 $x$，$y$，$z$ 均为正整数。

如果小 C 获得了 $n$ 种属性分别为 $(x_1,y_1,z_1), (x_2,y_2,z_2)  \ldots  (x_n,y_n,z_n)$ 的 $n$ 种药材，她可以任取 $n$ 个不全为 $0$ 的非负实数 $a_1,a_2 \ldots a_n$，将这些药材调和为一种属性为 $(\sum a_i x_i,\sum a_i y_i,\sum a_i z_i)$ 的药剂。

现在小 C 需要在 S 大陆上收集药材。具体而言，她需要选定树上的一个连通块，并获得连通块中所有顶点上的药材。现给定小 C 想制作的药剂的属性 $(a,b,c)$，请你求出，如果小 C 需要使用所获得的药材调和出属性为 $(a,b,c)$ 的药剂，她选定的连通块的大小至少是多少。

## 说明/提示

### 样例 1 解释

对于第一组样例，可以选择包含顶点 $1$，$2$ 和 $3$ 的连通块，取 $a_1,a_2,a_3$ 分别为 $\dfrac{1}{2},0,\dfrac{1}{2}$，即可得到属性为 $(\dfrac{1}{2} + \dfrac{3}{2},\dfrac{1}{2} + \dfrac{3}{2},\dfrac{5}{2} + \dfrac{1}{2}) = (2,2,3)$ 的药材。

### 子任务

对于所有测试数据，保证 $1 \leq n \leq 5 \times 10^4$，$1 \leq a,b,c,x_i,y_i,z_i \leq 2 \times 10^9$。

![](https://cdn.luogu.com.cn/upload/image_hosting/qh0c3wfw.png)

- 2023.8.25 添加一组 hack 数据。

## 样例 #1

### 输入

```
4 2 2 3
1 1 5
3 2 2
3 3 1
2 4 1
1 2
2 3
2 4
```

### 输出

```
3```

## 样例 #2

### 输入

```
8 3 269 1729
607 777 617
549 717 735
341 672 988
5 601 1395
846 263 892
796 954 251
243 144 1614
978 430 593
2 1
3 2
4 1
5 4
6 2
7 1
8 5
```

### 输出

```
-1```

# 题解

## 作者：AFewSuns (赞：7)

### 题目大意

有一棵 $n$ 个点的树，每个节点上有一种药材，可用三元组 $(x_i,y_i,z_i)$ 表示。

若你获得了 $m$ 种属性分别为 $(x_1,y_1,z_1),\cdots,(x_m,y_m,z_m)$ 的药材，你可以任取 $m$ 个**非负实数** $a_1,\cdots,a_m$，配置出 $(\sum{a_ix_i},\sum{a_iy_i},\sum{a_iz_i})$ 的药剂。

你要选取树上的一个连通块，用连通块上的药材配置出 $(a,b,c)$ 的药剂，求可以配置出此药剂的连通块大小的最小值，或判断无解。

保证所有 $x_i+y_i+z_i=a+b+c,n \leq 5\times 10^4$。

### 题目分析

首先注意到所有的 $x_i+y_i+z_i=a+b+c$，那么相当于 $\sum{a_i}=1$，只需要使得前两个元素相等即可。

只保留每个点的 $(x_i,y_i)$，将其视作平面上的点。当有两个点时，它们能配出线段上的任意点；当有三个点时，它们能配出三角形中的任意点；以此类推，$m$ 个点就能配出它们凸包中的任意点，而判断是否可行就相当于判断 $(a,b)$ 这个点在不在凸包内部。

为了方便，先将 $(a,b)$ 平移至原点，再将其他点缩放到单位圆上，容易证明这并不影响原点在凸包内的判断。接下来证明几个简单的性质：

**1. 凸包包含原点 $\Longleftrightarrow$ 存在三个点的三角形包含原点**

充分性显而易见，只需证明必要性。

选取圆上夹角最大的两个点 $X,Y$，分别过原点作直线交圆的另一端于 $X',Y'$，如果不存在三角形包含原点，那么就不能有点在 $X'Y'$ 圆弧内，同时因为 $X,Y$ 夹角最大，所以不能有点在 $XY',YX'$ 圆弧内，于是所有点都在 $XY$ 圆弧内，凸包不包含原点。

**2. 凸包包含原点 $\Longleftrightarrow$ 每个点都能找到另外两个点构成的三角形包含原点**

首先由上面可得一定存在某个三角形包含原点，不妨设这个三角形为 $XYZ$。

![图挂了快告诉我](https://cdn.luogu.com.cn/upload/image_hosting/et1ie505.png)

对于任意一点 $A$，由于三角形 $XAY$ 和 $YAZ$ 的并完全包含三角形 $XYZ$，所以三角形 $XAY$ 和 $YAZ$ 之间必有一个包含原点。

**3.可能成为答案的连通块一定是一条链**

如果连通块不是一条链，由于存在三个点包含原点，那么一定形如以下结构：

![图挂了快告诉我](https://cdn.luogu.com.cn/upload/image_hosting/tdygfo4n.png)

其中包含原点的三角形 $XYZ$ 限制了连通块大小，$A$ 为它们的交点。那么仿照上面的证明，$XAY,YAZ,ZAX$ 三个三角形之间必有一个包含原点，无论哪一个都比之前的连通块优，并且都是链。

**注：上面的证明均不考虑一个点、两个点的情况。**

---

接下来考虑点分治，设当前分治重心为 $x$，那么只需要计算链跨过 $x$ 的情况。分两种情况讨论：

**1. 链的两端在不同子树内**

设链的两端为 $y,z$，$x,y,z$ 对应的点分别为 $X,Y,Z$，那么如下图：

![图挂了快告诉我](https://cdn.luogu.com.cn/upload/image_hosting/at4frjio.png)

不妨设 $Y$ 在左边，$Z$ 在右边，那么三角形 $XYZ$ 包含原点等价于 $\mathop{XY}\limits^{\frown} \geq \mathop{X'Z}\limits^{\frown}$。将每个点按照左右两边分类，按弧长排序后双指针即可做到 $\mathcal O(n\log^2 n)$。

由于连通块大小等于 $dep_y+dep_z+1$，只与深度有关，所以可以对每个深度维护左边部分最大值和右边部分最小值，做一遍前缀最大值/最小值后双指针，时间复杂度 $\mathcal O(n\log n)$。

**2. 链的一端为 $x$**

直接在 dfs 的过程中维护 $x$ 到当前点的路径上，左边部分最大值和右边部分最小值，根据当前点在哪边来判断是否可行。

总时间复杂度 $\mathcal O(n\log n)$。

### 代码

随便写的，[目前最优解](https://www.luogu.com.cn/record/123756213) 269ms。

弧长的比较可以转化为角度，用点积比较。

```cpp
#include<bits/stdc++.h>
using namespace std;
using namespace my_std;
#define eps 1e-12
ll n,head[50050],cnt=0,ans=inf;
ll rt,minn=inf,rsiz,siz[50050],maxdep;
db L[50050],R[50050];
bl ck[50050];
struct edge{
	ll nxt,to;
}e[100010];
struct point{
	db x,y;
}a[50050],X,XX;
il void add(ll u,ll v){
	e[++cnt].nxt=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
il db cross(point x,point y){
	return x.x*y.y-x.y*y.x;
}
void getroot(ll fa,ll u){
	siz[u]=1;
	ll maxx=0;
	go(u){
		ll v=e[i].to;
		if(v==fa||ck[v]) continue;
		getroot(u,v);
		siz[u]+=siz[v];
		maxx=max(maxx,siz[v]);
	}
	maxx=max(maxx,rsiz-siz[u]);
	if(minn>maxx){
		minn=maxx;
		rt=u;
	}
}
void dfs(ll fa,ll u,ll dep,db lft,db rgt){
	siz[u]=1;
	maxdep=max(maxdep,dep);
	if(fabs(XX.x-a[u].x)<eps&&fabs(XX.y-a[u].y)<eps) ans=min(ans,dep+1);
	else if(cross(X,a[u])>eps){
		db tmp=-(X.x*a[u].x+X.y*a[u].y);
		if(rgt<=tmp) ans=min(ans,dep+1);
		lft=max(lft,tmp);
		L[dep]=max(L[dep],tmp);
	}
	else if(cross(X,a[u])<-eps){
		db tmp=-(XX.x*a[u].x+XX.y*a[u].y);
		if(lft>=tmp) ans=min(ans,dep+1);
		rgt=min(rgt,tmp);
		R[dep]=min(R[dep],tmp);
	}
	go(u){
		ll v=e[i].to;
		if(v==fa||ck[v]) continue;
		dfs(u,v,dep+1,lft,rgt);
		siz[u]+=siz[v];
	}
}
void solve(ll u){
	ck[u]=1;
	X=a[u];
	XX=(point){-a[u].x,-a[u].y};
	maxdep=0;
	dfs(0,u,0,-inf,inf);
	L[0]=-inf;
	R[0]=inf;
	fr(i,1,maxdep) L[i]=max(L[i],L[i-1]);
	fr(i,1,maxdep) R[i]=min(R[i],R[i-1]);
	ll now=maxdep+1;
	fr(i,1,maxdep){
		while(R[now-1]<=L[i]) now--;
		if(now<=maxdep) ans=min(ans,i+now+1);
	}
	fr(i,1,maxdep) L[i]=-inf;
	fr(i,1,maxdep) R[i]=inf;
	go(u){
		ll v=e[i].to;
		if(ck[v]) continue;
		rsiz=siz[v];
		minn=inf;
		getroot(u,v);
		solve(rt);
	}
}
int main(){
	n=read();
	fr(i,0,n){
		a[i].x=read();
		a[i].y=read();
		ll tmp=read();
	}
	fr(i,1,n){
		a[i].x-=a[0].x;
		a[i].y-=a[0].y;
	}
	fr(i,2,n){
		ll u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	fr(i,1,n){
		db len=sqrt(a[i].x*a[i].x+a[i].y*a[i].y);
		if(fabs(len)<eps){
			write(1);
			return 0;
		}
		a[i].x/=len;
		a[i].y/=len;
	}
	rsiz=n;
	minn=inf;
	getroot(0,1);
	fr(i,1,n) L[i]=-inf;
	fr(i,1,n) R[i]=inf;
	solve(rt);
	if(ans==inf) write(-1);
	else write(ans);
}
```

---

## 作者：EternalAlexander (赞：6)

对于所有药材的 $(x,y,z)$，将点 $(x,y)$ 标在二维平面上。假如有两个药材，可以发现它们能够调和得到的药剂对应的点可以是它们的连线上的任意一点。如果有三个，那么则是它们围成的三角形中的任意一点。如果有更多，依此类推，是它们围成的凸包中的任意一点。
	
因此，合法的充要条件是，点 $(a,b)$ 在所有药材对应的点形成的凸包内部。
	
不妨设 $(a,b)$ 是原点，并且假设其它的点都在单位圆上。可以验证这样不影响答案。
	

可以证明答案一定是某条边的两个端点+另一个点。例如，选出三个点 $(u,v,t)$，考虑 $u-v$ 这条链，一定有一条边跨过了图示两条直线中的某一条，把这条边的两个端点选出来，加上 $t$ 或 $v$ 中某一点，答案一定不劣。
	
![](https://cdn.luogu.com.cn/upload/image_hosting/gx7b8cib.png)
	
那么可以点分治，枚举那一条边，另一个点需要在某个扇形区域内，数据结构维护即可。
	
两种做法复杂度均为 $O(n\log^2n)$。

---

## 作者：良心WA题人 (赞：5)

## 思路

首先，因为 $x_i+y_i+z_i=x+y+z$，所以 $\sum a_i\times x_i+\sum a_i\times y_i=x+y$ 时，$\sum a_i\times z_i=z$。

于是原问题变成了二维的问题。

一个经典结论是将这些二维的东西看成点，则位于选出来的点的凸包内所有浓度均可以取到（中学数学知识）。

那么原问题就是在图上选择一些点使得原点被包含在内。先考虑一个点，就是相同。两个点就是判点在线段上，则一定是这两个点之间的路径，是一条链，可以点分治。

对于大于等于三个点的，因为凸多边形可以三角剖分，所以只需要找到一个三角形包含原点即可，其他的点本质上没有意义。但是原题要求是连通块，所以可能需要一些厄余的点。

于是我们需要完成的是找一个连通块，使得其中存在三个点围成三角形能够包含原点。可是这个仍然不能算。我们考虑在一个包含原点的三角形中加入第四个点，可以发现这第四个点一定存在原三角形的某条边，使得组成的新三角形包含原点。

具体的，该四点的四边形显然包含原三角形，对该四边形以过新点的对角线剖分，两个三角形一定存在一个三角形包含原点。

那么，任意三个不在同一条链上的点，可以将一个向另外两个点的路径不断变化，最终成为一条链。于是，又变成了链上的问题，也可以点分治了！

为了方便处理，我们将答案挪到原点，并将所有点放到单位圆上。

现在考虑点分治。首先链分为三种情况：
1. 完全在一个子树内：此时递归处理
2. 包含当前的根并延申至一个子树：此时需要找到过根表示点的直径左侧和右侧的两个点（令该点为 $X$，直径与圆另一交点为 $X'$，以 $X'X$ 为坐标轴，正半轴所选点为 $A$，负半轴所选点为 $B$），使得 $\angle AOX>\angle BOX'$。
3. 包含当前的根并延申至两个子树：存下所有点按 2 的条件双指针做即可。

时间复杂度 $O(n\log^2 n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=5e4+4;
struct point
{
    double x,y;
    point()
    {
    	x=y=0;
	}
    point(double _x,double _y)
    {
    	x=_x,y=_y;
	}
    point operator-(const point&it)const
    {
        return {x-it.x,y-it.y};
    }
    double operator*(const point&it)const
    {
        return x*it.y-it.x*y;
    }
}a[NN];
int siz[NN],maxx[NN],d[NN],ans=1e9;
bool vis[NN];
vector<pair<double,int> >t1,t2;
vector<int>g[NN];
int sign(double x)
{
	if(abs(x)<=1e-6)
		return 0;
	if(x<0)
		return -1;
	return 1;
}
double get_dist(point a,point b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
void get(int u,int fa,int root,double maxx,double minn)
{
	if(sign(a[u]*a[root])<0)
	{
		t1.push_back({get_dist({-a[u].x,-a[u].y},a[root]),d[u]});
		minn=min(minn,get_dist({-a[u].x,-a[u].y},a[root]));
	}
	else if(sign(a[u]*a[root])>0)
	{
		t2.push_back({get_dist(a[u],a[root]),d[u]});
		maxx=max(maxx,get_dist(a[u],a[root]));
	}
	else if(sign(a[u].x*a[root].x)<=0&&sign(a[u].y*a[root].y)<=0)
		ans=min(ans,d[u]+1);
	if(minn<=maxx)
		ans=min(ans,d[u]+1);
	siz[u]=1;
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i];
		if(vis[v]||v==fa)
			continue;
		d[v]=d[u]+1;
		get(v,u,root,maxx,minn);
		siz[u]+=siz[v];
	}
}
int find_root(int u,int fa,int n)
{
	maxx[u]=n-siz[u];
	int k=0;
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i];
		if(v==fa||vis[v])
			continue;
		int t=find_root(v,u,n);
		maxx[u]=max(maxx[u],siz[v]);
		if(maxx[t]<maxx[k])
			k=t;
	}
	if(maxx[u]<maxx[k])
		k=u;
	return k;
}
void solve(int u)
{
	vis[u]=true;
	t1.clear(),t2.clear();
	d[u]=0;
	get(u,0,u,0,1e18);
	sort(t1.begin(),t1.end());
	sort(t2.begin(),t2.end());
	for(int i=max(-1,(int)t2.size()-2);~i;i--)
		t2[i].second=min(t2[i+1].second,t2[i].second);
	for(int i=0,j=0;i<t1.size();i++)
	{
		while(j<t2.size()&&t2[j].first<t1[i].first)
			j++;
		if(j==t2.size())
			break;
		ans=min(ans,t1[i].second+t2[j].second+1);
	}
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i];
		if(vis[v])
			continue;
		solve(find_root(v,0,siz[v]));
	}
}
int main()
{
	int n;
	point o;
	scanf("%d%lf%lf%*lf",&n,&o.x,&o.y);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf%*lf",&a[i].x,&a[i].y);
		double t=get_dist(a[i],o);
		if(!sign(t))
		{
			printf("1");
			return 0;
		}
		a[i]=a[i]-o;
		a[i].x/=t,a[i].y/=t;
	}
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	maxx[0]=1e9;
	get(1,0,1,0,1e18);
	solve(find_root(1,0,n));
	if(ans==1e9)
		ans=-1;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Little09 (赞：2)

首先注意到由于三维的和是相等的，因此有 $\sum a=1$，所以我们其实只需要关注前两维就行。把每个物品表示在二维平面上，那么注意到两个物品可以配成的就是它们连线形成的线段，三个物品是形成的三角形，多个物品就是凸包，于是我们会判定一个集合能否配成 $(A,B,C)$ 了。但其实对于一个凸包而言，其中只有最多三个点是有效的。

先平移一下把 $(A,B)$ 放到原点。接下来我们其实只关注每个点和原点连线与 X 轴的夹角，也就是 $\text{tan}$ 值。因此我们不妨在单位圆上考虑。

考虑直接点分治，假设当前分治重心为 $x$，我们需要计算出包含 $x$ 的符合题意的连通块。假设 $x$ 在圆上对应 $X$ 点如下图，令 $X'$ 是 $X$ 关于圆心的对称点，那我们需要找到两个点 $Y$、$Z$ 满足它们分居 $XX'$ 的两侧，且需要满足弧 $XY$ 的长度大于等于弧 $ZX'$ 的长度。

![](https://cdn.luogu.com.cn/upload/image_hosting/0zjbcg87.png)

对于一个不合法的连通块一定找不到这样的 $Y$、$Z$，而找到这样 $Y$、$Z$ 的一定合法，所以这样找是充要的。因此在 $x$ 分治子树内的点都可以被划分都 $XX'$ 的左右部分中的一个去，然后我们可以计算出弧 $XY$ 或弧 $X'Z$。最后把这些点放在一起跑一个排序双指针就是 $O(n\log ^2n)$ 的。

但是可以注意到对于两个在 $XX'$ 左侧的点 $A$、$B$，如果满足弧 $AX$ 小于弧 $BX$，且 $A$ 的深度大于 $B$ 的深度，那么 $A$ 其实没用。所以我们对每个深度只要存一个最优值，并且最后删掉无用的深度，这样就做到了排序。实际上本质是把对角度的排序转化到对深度的排序上，而对深度排序是可以用桶存的。于是这样复杂度为 $O(n\log n)$。

注意还需要判一下有没有点正好是 $X'$，这样两个点就合法。

使用 double 计算角度可以通过，但理论上可以被卡精度。使用向量叉积代替 double 即可。

---

## 作者：sidekick257 (赞：1)

### update on 2023.1.14 修改了一处笔误。

因为 $x_i+y_i+z_i=a+b+c$，所以 $\sum a_i=1$。

然后如果 $\sum a_ix_i+a_iy_i=a+b$，那么 $\sum a_iz_i=c$。

所以只用保留两维。

然后可以把 $(x_i,y_i)$ 视为向量，我们都知道 $a\overrightarrow{AB}+b\overrightarrow{AC}$ 在 $a+b=1$ 时可以取到 $BC$ 上的所有点。

然后不断加点进来，发现可以取到凸包内的所有点。

于是问题转化为求最小连通块使得这些点的凸包包含给定点。

我们又知道，对于任意一个点 $A$，都存在一个以 $A$ 为顶点的三角形包含给定点。

经过观察可以发现，如果三个点 $A,B,C$ 在树上不是一条链，设他们中间的点为 $D$，则 $ABD,ACD,BCD$ 中一定存在一个三角形包含给定点，故如果存在三个点满足条件，一定可以找到在一条链上的三个点满足条件。

于是考虑点分治，把一条边为分治中心到给定点的角度全存下来按照角度排序即可做到 $O(n\log^2 n)$。

细节较多，注意特判以下情况：

1. 存在点等于给定点。
2. 存在点与分治中心关于给定点对称。
3. 分治中心是链的端点。

---


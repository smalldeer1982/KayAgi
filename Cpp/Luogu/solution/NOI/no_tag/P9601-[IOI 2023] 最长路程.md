# [IOI 2023] 最长路程

## 题目背景

IOI2023 D1T2

**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引入头文件，而需要把头文件的内容加入文件的开头。即，在程序开头加入以下几行语句：**

```
#include <vector>

std::vector<int> longest_trip(int N, int D);

bool are_connected(std::vector<int> A, std::vector<int> B);
```

## 题目描述

IOI 2023 组委会有大麻烦了！他们忘记计划即将到来的 Ópusztaszer 之旅了。然而，或许一切尚未为晚 ......

在 Ópusztaszer 有 $N$ 个地标，编号为从 $0$ 到 $N-1$。某些地标之间连有**双向**的**道路**。任意一对地标之间至多连有一条道路。组委会**不知道**哪些地标之间有道路相连。

如果对于每三个不同的地标，它们之间都至少连有 $\delta$ 条道路，我们就称 Ópusztaszer 的路网**密度**是**至少**为 $\delta$ 的。换言之，对所有满足 $0 \le u \lt v \lt w \lt N$ 的地标三元组 $(u, v, w)$，配对 $(u,v)$，$(v,w)$ 和 $(u,w)$ 中至少有 $\delta$ 个配对中的地标有道路相连。

组委会**已知**有某个正整数 $D$，满足路网密度至少为 $D$。注意， $D$ 的值不会大于 $3$。

组委会可以**询问** Ópusztaszer 的电话接线员，以获取关于某些地标之间的道路连接信息。在每次询问时，必须给出两个非空的地标数组 $[A[0], \ldots, A[P-1]]$ 和 $[B[0], \ldots, B[R-1]]$。地标之间必须是两两不同的，即，

* 对于满足 $0 \le i \lt j \lt P$ 的所有 $i$ 和 $j$，有 $A[i] \neq A[j]$；
* 对于满足 $0 \le i \lt j \lt R$ 的所有 $i$ 和 $j$，有 $B[i] \neq B[j]$；
* 对于满足 $0 \le i \lt P$ 且 $0\le j \lt R$ 的所有 $i$ 和 $j$，有 $A[i] \neq B[j]$。

对每次询问，接线员都会报告是否存在 $A$ 中的某个地标和 $B$ 中的某个地标有道路相连。更准确地说，接线员会对满足 $0 \le i \lt P$ 和 $0\le j \lt R$ 的所有配对 $i$ 和 $j$ 进行尝试。如果其中某对地标 $A[i]$ 与 $B[j]$ 之间连有道路，接线员将报告 `true`。否则，接线员将报告 `false`。

一条长度为 $l$ 的**路程**，被定义为由**不同**地标 $t[0], t[1], \ldots, t[l-1]$ 构成的序列，其中对从 $0$ 到 $l-2$（包括 $0$ 和 $l-2$）的所有 $i$，地标 $t[i]$ 和 $t[i+1]$ 之间都有道路相连。如果不存在长度至少为 $l+1$ 的路程，则长度为 $l$ 的某条路程被称为是**最长路程**。

你的任务是通过询问接线员，帮助组委会在 Ópusztaszer 找一条最长路程。

---

**【实现细节】**

你需要实现如下函数：

```
int[] longest_trip(int N, int D)
```

* $N$：Ópusztaszer 的地标数量。
* $D$：可以保证的路网密度最小值。
* 该函数需要返回一个表示某条最长路程的数组 $t = [t[0], t[1], \ldots, t[l-1]]$。
* 对于每个测试用例，该函数都可能会被调用 **多次**。

上述函数可以调用如下函数：

```
bool are_connected(int[] A, int[] B)
```

* $A$：一个非空、且元素两两不同的地标数组。
* $B$：一个非空、且元素两两不同的地标数组。
* $A$ 和 $B$ 之间应无交集。
* 如果存在连接 $A$ 中某个地标以及 $B$ 中某个地标的道路，该函数返回 `true`。否则该函数返回 `false`。
* 在每次 `longest_trip` 调用中，该函数可以被至多调用 $32\,640$ 次。该函数的累计调用总数至多为 $150\,000$ 次。
* 对历次调用该函数时传递的数组 $A$ 和 $B$ 长度进行累计，两个数组累计长度加起来不能超过 $1\,500\,000$。

评测程序是**非适应性的**。每次提交都将在同一组测试用例上进行评测。换言之，在每个测试用例中，$N$ 和 $D$ 的值，以及道路所连接的地标配对，对于每次 `longest_trip` 调用都保持不变。

## 说明/提示

**【例子】**

**样例一**

考虑某个 $N = 5$, $D = 1$ 的场景，其中道路连接情形如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/h4q6u936.png)

函数 `longest_trip` 被调用如下：

```
longest_trip(5, 1)
```

该函数可以调用 `are_connected` 如下。

|                调用                |  有道路连接的配对  | 返回值  |
| :--------------------------------: | :----------------: | :-----: |
| `are_connected([0], [1, 2, 4, 3])` | $(0,1)$ 和 $(0,2)$ | `true`  |
|     `are_connected([2], [0])`      |      $(2,0)$       | `true`  |
|     `are_connected([2], [3])`      |      $(2,3)$       | `true`  |
|  `are_connected([1, 0], [4, 3])`   |         无         | `false` |

在第四次调用后，可知 $(1,4)$，$(0,4)$，$(1,3)$ 和 $(0,3)$ 中**没有**哪个配对中的地标之间连有道路。由于路网的密度至少是 $D = 1$，我们由三元组 $(0, 3, 4)$ 可知，配对 $(3,4)$ 的地标之间必须连有道路。与此相似，地标 $0$ 和 $1$ 之间必须是相连的。

至此，可以总结出 $t = [1, 0, 2, 3, 4]$ 是一条长度为 $5$ 的路程，而且不存在长度超过 $5$ 的路程。因此，函数 `longest_trip` 可以返回 $[1, 0, 2, 3, 4]$。

考虑另一个场景， 其中 $N = 4$, $D = 1$，且地标之间的道路如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/6kk0r3y9.png)

函数 `longest_trip` 被调用如下：

```
longest_trip(4, 1)
```

在这个场景中，最长路程的长度为 $2$。因此，在对函数 `are_connected` 进行少量调用后，函数 `longest_trip` 可以返回 $[0, 1]$, $[1, 0]$, $[2, 3]$ 和 $[3, 2]$ 中的任意一个.

**样例 2**

子任务 0 包含另一个测试用例用作示例，其中有 $N=256$ 个地标。

**【数据范围】**

* $3 \le N \le 256$
* 对于每个测试用例，函数 `longest_trip` 的所有调用中 $N$ 的累计总和不超过 $1\,024$。
* $1 \le D \le 3$

**【子任务】**

1. （5 分）$D = 3$
1. （10 分）$D = 2$
1. （25 分）$D = 1$。令 $l^\star$ 表示最长路程的长度。函数 `longest_trip` 不必返回长度为 $l^\star$ 的某条路程，而应返回长度至少为 $\left\lceil \frac{l^\star}{2} \right\rceil$ 的某条路程。
1. （60 分）$D = 1$

在子任务 4 中，你的得分将根据 `longest_trip` 的单次调用中对函数 `are_connected` 的调用数量而定。对该子任务的所有测试用例调用 `longest_trip`，令 $q$ 为各次调用产生的函数 `are_connected` 调用次数的最大值。
你在该子任务上的得分将按照下表进行计算：

|            条件            | 得分 |
| :------------------------: | :--: |
| $2\,750 \lt q \le 32\,640$ | $20$ |
|   $550 \lt q \le 2\,750$   | $30$ |
|    $400 \lt q \le 550$     | $45$ |
|        $q \le 400$         | $60$ |

如果在某个测试用例上，对函数 `are_connected` 的调用没有遵守实现细节部分给出的限制条件，或者 `longest_trip` 返回的数组是错误的，你的解答在该子任务上的得分将为 $0$。

**【评测程序示例】**

令 $C$ 为场景数量，即调用 `longest_trip` 的次数。
评测程序示例读取如下格式的输入数据：

* 第 $1$ 行：$C$

接下来是这 $C$ 个场景的描述数据。

评测程序示例读取每个场景如下格式的描述数据：

* 第 $1$ 行：$N \; D$
* 第 $1 + i$ 行（$1 \le i \lt N$）：$U_i[0] \; U_i[1] \; \ldots \; U_i[i-1]$

这里每个 $U_i$（$1 \le i \lt N$）均为长度为 $i$ 的数组，以给出那些有道路相连的地标配对。对于满足 $1 \le i \lt N$ 且 $0 \le j \lt i$ 的所有 $i$ 和 $j$：

* 如果地标 $j$ 和 $i$ 之间有道路相连，则 $U_i[j]$ 的值应为 $1$；
* 如果地标 $j$ 和 $i$ 之间没有道路相连，则 $U_i[j]$ 的值应为 $0$。

在每个场景中，在调用 `longest_trip` 之前，评测程序示例检查路网的密度是否至少为 $D$。如果不满足该条件，评测程序示例将输出信息 `Insufficient Density` 并中止。

如果检查出违反规则的行为，评测程序示例的输出为 `Protocol Violation: <MSG>`，这里 `<MSG>` 为如下错误信息之一：

* `invalid array`：在 `are_connected` 的某次调用中，数组 $A$ 和 $B$ 中至少其一
  - 为空，或
  - 有元素不是 $0$ 到 $N-1$ 之间（包含 $0$ 和 $N-1$）的整数，或
  - 有重复元素。
* `non-disjoint arrays`：在 `are_connected` 的某次调用中，数组 $A$ 和 $B$ 的交集不空。
* `too many calls`：函数 `are_connected` 在 `longest trip` 的当前调用中的被调用次数超过了 $32\,640$，或者其累计调用次数超过了 $150\,000$。
* `too many elements`：在 `are_connected` 的全部调用中，所传递的地标的累计数量超过了 $1\,500\,000$。

否则，令 `longest_trip` 函数在某个场景中的返回数组为 $t[0], t[1], \ldots, t[l - 1]$，这里 $l$ 为某个非负整数。评测程序示例将对该场景按照如下格式输出三行：

* 第 $1$ 行：$l$
* 第 $2$ 行：$t[0] \; t[1] \; \ldots \; t[l-1]$
* 第 $3$ 行：在该场景中调用 `are_connected` 的次数

最后，评测程序示例输出：

* 第 $1 + 3 \cdot C$ 行：在 `longest_trip` 的所有调用中，函数 `are_connected` 被调用的最多次数

# 题解

## 作者：Leasier (赞：5)

注意到使用 $C_n^2$ 次操作问出图的形态就可以在 Subtask 4 中获得 $20$ 分的好成绩了，考虑已知图的形态后如何计算最长简单路径。

直接当成一般图来做是 NPC 问题，考虑利用题目给出的性质，可以发现：

- 这张图至多存在两个连通块。

证明：如果存在三个连通块，分别抓出三个点 $u, v, w$，则 $u, v, w$ 之间两两无边，与题给条件矛盾。

- 如果存在两个连通块，则两个连通块均为团。

证明：如果某个连通块中存在两个无边的 $u, v$，任取另一个连通块中的点 $w$，则 $u, v, w$ 之间两两无边，与题给条件矛盾。

因此，若存在两个连通块，则我们以任意形式遍历其中较大者的所有点即可。

否则，考虑利用形如“若 $u, v$ 与 $u, w$ 之间均不存在边，则 $u, w$ 之间必然存在边”的关系找最长简单路径。

考虑依次加入每个点。注意到无论何时原图都满足其至多存在两个连通块，考虑维护两条路径 $P, Q$，初始分别加入 $0, 1$ 两个点。

接下来考虑加入点 $i$：

- 若 $P$ 的末端与 $i$ 间有边，则将 $i$ 加入 $P$ 的末尾。
- 若 $Q$ 的末端与 $i$ 间有边，则将 $i$ 加入 $Q$ 的末尾。
- 否则，注意到此时 $P, Q$ 的末端直接一定有边，则将 $P, Q$ 串起来作为新 $P$，将 $i$ 单独作为新 $Q$ 即可。

若 $P, Q$ 首端、末端或首尾之间有边，我们不难直接构造出一条长为 $n$ 的路径。

否则，$P, Q$ 各自的首尾之间有边，且由于 $P, Q$ 中点两两连通，考虑抓出一条边 $(u, v)$，其中 $u \in P, v \in Q$，于是也不难构造出一条长为 $n$ 的路径。

现在考虑减少询问次数。

注意到上面构造 $P, Q$ 的过程只需要 $\leq 2n - 4$ 次询问，判断 $P, Q$ 是否连通只需要 $1$ 次询问，判断 $P, Q$ 首端、末端或首尾之间是否有边只需要 $4$ 次询问，抓出 $u, v$ 的过程可以通过两次二分做到 $\leq 2 \lceil \log_2 n \rceil$ 次询问，则总询问次数 $\leq 2n + 2 \lceil \log_2 n \rceil + 1 \leq 545$，于是我们可以在 Subtask 4 中获得 $45$ 分的好成绩了。

注意到最终限制 $400$ 为 $\max(1.5n + 2 \lceil \log_2 n \rceil)$，考虑只用三次询问往 $P, Q$ 中加入两个点。具体的操作可以类似地讨论，此处略去。需要注意的是 $n$ 为奇数时我们需要单独加入最后一项。

最终我们发现按照之前的询问方式可能会恰好多出一次询问。注意到当 $P, Q$ 首端、末端和其中一对首尾之间均无边，$P, Q$ 各自的首尾之间一定有边，于是我们可以减少恰好一次操作。

最终，$n$ 为偶数时的询问次数 $\leq 1.5n + 2 \lceil \log_2 n \rceil$、$n$ 为奇数时的询问次数 $\leq 1.5(n - 1) + 2 \lceil \log_2 n \rceil + 2$，于是最大总询问次数为 $400$ 次，可以通过。

代码：
```cpp
#include <iostream>
#include <vector>
#include "longesttrip.h"

using namespace std;

pair<int, int> find1(int u, vector<int> v1){
	if (v1.size() == 1) return make_pair(u, v1[0]);
	int mid = v1.size() / 2;
	vector<int> v2;
	for (int i = 1; i <= mid; i++){
		v2.push_back(v1.back());
		v1.pop_back();
	}
	if (are_connected(vector<int>{u}, v1)) return find1(u, v1);
	return find1(u, v2);
}

pair<int, int> find2(vector<int> v1, vector<int> v2){
	if (v1.size() == 1) return find1(v1[0], v2);
	int mid = v1.size() / 2;
	vector<int> v3;
	for (int i = 1; i <= mid; i++){
		v3.push_back(v1.back());
		v1.pop_back();
	}
	if (are_connected(v1, v2)) return find2(v1, v2);
	return find2(v3, v2);
}

vector<int> longest_trip(int N, int D){
	vector<int> v1, v2;
	v1.push_back(0);
	v2.push_back(1);
	for (int i = 2; i + 1 < N; i += 2){
		if (are_connected(vector<int>{v1.back()}, vector<int>{i})){
			v1.push_back(i);
			if (are_connected(vector<int>{i}, vector<int>{i + 1})){
				v1.push_back(i + 1);
			} else if (are_connected(vector<int>{v2.back()}, vector<int>{i + 1})){
				v2.push_back(i + 1);
			} else {
				while (!v2.empty()){
					v1.push_back(v2.back());
					v2.pop_back();
				}
				v2.push_back(i + 1);
			}
		} else if (are_connected(vector<int>{v2.back()}, vector<int>{i})){
			v2.push_back(i);
			if (are_connected(vector<int>{i}, vector<int>{i + 1})){
				v2.push_back(i + 1);
			} else {
				v1.push_back(i + 1);
			}
		} else {
			if (are_connected(vector<int>{i}, vector<int>{i + 1})){
				while (!v2.empty()){
					v1.push_back(v2.back());
					v2.pop_back();
				}
				v2.push_back(i);
				v2.push_back(i + 1);
			} else {
				v1.push_back(i + 1);
				while (!v2.empty()){
					v1.push_back(v2.back());
					v2.pop_back();
				}
				v2.push_back(i);
			}
		}
	}
	if (N % 2 == 1){
		if (are_connected(vector<int>{v1.back()}, vector<int>{N - 1})){
			v1.push_back(N - 1);
		} else if (are_connected(vector<int>{v2.back()}, vector<int>{N - 1})){
			v2.push_back(N - 1);
		} else {
			while (!v2.empty()){
				v1.push_back(v2.back());
				v2.pop_back();
			}
			v2.push_back(N - 1);
		}
	}
	if (!are_connected(v1, v2)){
		if (v1.size() > v2.size()) return v1;
		return v2;
	}
	int p = v1[0], q = v2[0], size1 = v1.size(), size2 = v2.size();
	vector<int> ans;
	if (are_connected(vector<int>{p}, vector<int>{q})){
		for (register int i = size1 - 1; i >= 0; i--){
			ans.push_back(v1[i]);
		}
		for (register int i = 0; i < size2; i++){
			ans.push_back(v2[i]);
		}
	} else {
		int r = v1[size1 - 1], s = v2[size2 - 1];
		if (are_connected(vector<int>{r}, vector<int>{s})){
			for (register int i = 0; i < size1; i++){
				ans.push_back(v1[i]);
			}
			for (register int i = size2 - 1; i >= 0; i--){
				ans.push_back(v2[i]);
			}
		} else if (are_connected(vector<int>{p}, vector<int>{s})){
			for (register int i = size1 - 1; i >= 0; i--){
				ans.push_back(v1[i]);
			}
			for (register int i = size2 - 1; i >= 0; i--){
				ans.push_back(v2[i]);
			}
		} else {
			int posu, posv;
			pair<int, int> pr = find2(v1, v2);
			for (register int i = 0; i < size1; i++){
				if (v1[i] == pr.first){
					posu = i;
					break;
				}
			}
			for (register int i = 0; i < size2; i++){
				if (v2[i] == pr.second){
					posv = i;
					break;
				}
			}
			for (register int i = posu - 1; i >= 0; i--){
				ans.push_back(v1[i]);
			}
			for (register int i = size1 - 1; i >= posu; i--){
				ans.push_back(v1[i]);
			}
			for (register int i = posv; i < size2; i++){
				ans.push_back(v2[i]);
			}
			for (register int i = 0; i < posv; i++){
				ans.push_back(v2[i]);
			}
		}
	}
	return ans;
}
```

---

## 作者：yzy1 (赞：3)

为表述方便，题解中将点的编号定义为 $1$ 至 $n$，而非原题中的 $0$ 至 $n-1$．

## 算法 1

注意到题目中存在一个「任意三点之间至少有一条连边」的性质．根据此性质，可以推导出图中最多存在两个连通块．证明可以考虑以下的过程：

考虑维护两条链 $L_1$ 和 $L_2$，初始为空．设两条链的末结点编号为 $v_1$ 和 $v_2$．从 $1$ 至 $n$ 枚举点 $u$，根据题目性质，以下三者中必然存在一者为真：

- $v_1$ 为空或 $u$ 与 $v_1$ 之间有一条边．
- $v_2$ 为空或 $u$ 与 $v_2$ 之间有一条边．
- $v_1$ 与 $v_2$ 之间有一条边．

对于前两种情况，我们直接将 $u$ 拼接到链末尾即可．对于第三种情况，我们发现此时两条链可以拼接．考虑将 $L_2$ 拼到 $L_1$ 上，然后 $u$ 放进将空出来的 $L_2$ 里．

根据这个过程，我们可以使用 $2 n + O(1)$ 次操作将整个图划分为两个链．

链的性质还不是很好，我们考虑将链变成环．根据性质，以下三者中必然存在一者为真：

- $L_1$ 末结点和 $L_2$ 始结点之间有一条边．
- $L_1$ 末结点和 $L_2$ 末结点之间有一条边．
- $L_2$ 始末结点之间有一条边．

对于前两种情况，可以直接将两个链拼接得到一条哈密顿路作为最终答案．否则，可以证明 $L_2$ 是一个环．将 $L_1$ 与 $L_2$ 交换，再次进行此过程，即可确定两个链均为环．

对于两个环的情况，下一步就是看是否存在一条边可以连接两个环了．如果存在则可以直接得到一条哈密顿路，否则答案就为比较大的那个环．找连接两环的边的过程可以通过两次二分来实现：首先二分出 $p_1$ 满足 $L_1[1 \dots p_1]$ 与 $L_2$ 之间有边且 $L_1[1 \dots p_1-1]$ 与 $L_2$ 之间无边，此时必然存在一条 $L_1[p_1]$ 到 $L_2$ 的边．再用一次二分得到边的另一个端点即可．

该做法操作次数为 $2 n + O(\log n)$，可以得到除最后一个 subtask 的最后一档评分参数的得分外的其他得分，共 $85$ 分．

## 算法 2

算法 1 的瓶颈在于前面的 $2 n$ 次操作将图划分为两个链．事实上，存在一种方式可以在至多 $3$ 次询问内在将两个点加入链：

- 若 $i, i+1$ 有边：
  - 若 $v_1, i$ 有边：$L_1 \to i \to i+1$．
  - 否则，若 $v_2, i$ 有边：$L_2 \to i \to i+1$．
  - 否则，若 $v_1, v_2$ 有边：$L_1 \to L_2$，$L_2 = i \to i+1$．
- 否则，若 $v_1,i$ 有边：
  - 若 $v_2,i$ 有边：$L_1 \to i \to L_2$，$L_2 = i+1$．
  - 若 $v_2, i+1$ 有边：$L_1 \to i$，$L_2 \to i+1$．
- 否则，若 $v_2,i$ 有边：$L_1 \to i+1$，$L_2 \to i$．
- 否则，$L_1 \to L_2 \to i+1$，$L_2 = i$．


注意特判最后只剩下一个点时使用做法 1 中的处理方式．

该做法操作次数为 $\frac 3 2 n + O(\log n)$，可以得到 $100$ 分．

## 代码参考

见 [原始 OJ 提交](https://loj.ac/s/1880894)．


---

## 作者：OrangeEye (赞：2)

由于密度至少为 $1$，显而易见地最多只会有两个连通块。

我们声称最长路径长度为所有连通块中最大的连通块大小，并给出如下构造方案：

- 依次加入每个点，在所有时刻维护两条路径 $s_1,s_2$ 并使其不重复地覆盖当前所有点。
- 加入一个点时，如果其和当前两条路径中某条路径的某条路径末尾有连边，那么直接加入这条路径末尾。
- 否则，由于密度至少为 $1$，这两条路径末尾有连边。我们将**这两条路径的并**和**新加入的这个单独的点**分别作为新的两条路径。
- 最终可以得到两条路径。如果这两条路径不连通，那么输出较长的路径即可。
- 否则如果这两条路径可以合并，那么直接合并即可（这样得出的路径覆盖了图中的所有点）。
- 否则，由于密度至少为 $1$，这两条链首尾必须相连，形成两个环。由于图的连通性，并且这两条路径覆盖了整张图，一定可以找到 $u\in s_1,v\in s_2$ 使得存在一条边 $(u,v)$。容易从 $u$ 相邻的点开始构造哈密顿路径。

这个方法使用了 $2(n-2)+1+3+2\log_2n$ 次询问，无法通过。

我们考虑优化加入点的过程。在某个点 $i$ 加入 $s_1$ 失败后（如果成功那么 $i$ 就只花费了 $1$ 次询问），我们把下一个点 $j$ 一起纳入考虑。
- 如果 $i$ 加入 $s_2$ 成功，此时由于 $i$ （亦即此时 $s_2$ 的末尾）和 $s_1$ 末尾无连边，并且密度至少为 $1$，所以 $j$ 至少和这两个点中的其中一个有连边，我们只需要在 $j$ 上花费一次询问。
- 如果 $i$ 加入 $s_2$ 失败，那么此时 $s_1,s_2$ 末尾之间有连边，不过先别急着合并它们。我们此时询问 $(\{i\},\{j\})$。如果 $i,j$ 之间有连边，那么我们合并 $s_1,s_2$ 和 $i,j$ 分别作为新的两条路径。否则，此时 **$j$ 和 $s_1,s_2$ 末尾均有连边**。我们依次合并 $s_1,j,s_2$，并和单独的 $i$ 作为新的两条路径。
- 无论哪种情况，操作这两个点都只花了我们 $3$ 次询问。
- 如果最后剩一个点单独考虑即可。

至此，询问数被优化为 $\dfrac{3}{2}(n-2)+1+3+2\log_2n$，可以通过。

```cpp
#include"longesttrip.h"
#include<bits/stdc++.h>
using namespace std;
int n,u,v,x,y;
vector<int> s1,s2,ans;
bool qry(int u,int v){
	vector<int> P={u},Q={v};return are_connected(P,Q);
}
bool qry(int l1,int r1,int l2,int r2){
	vector<int> P={},Q={};
	for(int i=l1;i<=r1;i++)P.push_back(s1[i]);
	for(int i=l2;i<=r2;i++)Q.push_back(s2[i]);
	return are_connected(P,Q);
}
void getcon(){
	int l=0,r=x-1;
	while(r>l){
		int mid=l+r>>1;
		if(qry(l,mid,0,y-1))r=mid;
		else l=mid+1;
	}u=l;l=0,r=y-1;
	while(r>l){
		int mid=l+r>>1;
		if(qry(u,u,l,mid))r=mid;
		else l=mid+1;
	}v=l;
}
void merge(){
	while(!s2.empty())s1.push_back(s2.back()),s2.pop_back();
}
vector<int> longest_trip(int _n,int ph){
	s1.clear();s2.clear();ans.clear();n=_n;
	s1.push_back(0);s2.push_back(1);
	for(int i=2;i<n;i++)
		if(qry(s1.back(),i))s1.push_back(i);
		else if(i==n-1){
			if(qry(s2.back(),i))s2.push_back(i);
			else merge(),s2.push_back(i);
		}else{
			int j=i+1;
			if(qry(s2.back(),i)){
				s2.push_back(i);
				if(qry(i,j))s2.push_back(j);
				else s1.push_back(j);
			}else if(qry(i,j))merge(),s2.push_back(i),s2.push_back(j);
			else s1.push_back(j),merge(),s2.push_back(i);
			i=j;
		}
	if(qry(s1.back(),s2.back()))return merge(),s1;
	if(qry(s1[0],s2.back()))return reverse(s1.begin(),s1.end()),merge(),s1;
	if(qry(s1.back(),s2[0]))return reverse(s2.begin(),s2.end()),merge(),s1;
	x=(int)s1.size(),y=(int)s2.size();
	if(!qry(0,x-1,0,y-1))return (x>y?s1:s2);
	getcon();
	for(int i=u+1;i<x;i++)ans.push_back(s1[i]);
	for(int i=0;i<=u;i++)ans.push_back(s1[i]);
	for(int i=v;i<y;i++)ans.push_back(s2[i]);
	for(int i=0;i<v;i++)ans.push_back(s2[i]);
	return ans;
}
```

---

## 作者：Acoipp (赞：2)

## 题意

有一幅图，我们事先不知道，但是给定了图的点数 $n$ 和一个参数 $d$，对于任意互不相同的 $i,j,k(0 \le i,j,k < n)$，若设 $a_{i,j}=1$ 则 $i,j$ 之间有边，那么 $a_{i,j}+a_{j,k}+a_{i,k} \ge d$。

你每次可以询问两组点 $p,q$，交互库会返回这两组点里面有没有一个点属于 $p$，一个点属于 $q$ 且这两个点之间有边。

你需要通过若干次询问找到这幅图上的一条最长路径。（不经过重复点和边）

其中：$3 \le n \le 256$，$1 \le d \le 3$ 并且限制询问次数 $\le 400$。

## 分析

$d$ 等于 $2$ 或者 $3$ 的时候都是送分题，这里不过多赘述。

这里只讨论 $d=1$ 的情况。

我们可以关注整张图的形态，我们从这张图中随便选择一个子图出来都满足题目中的 $a_{i,j}+a_{j,k}+a_{i,k} \ge d$ 限制，于是我们按照 $0 \sim n-1$ 的顺序依次讨论。

首先这幅图的连通块个数一定小于 $3$，如果大于，我们从 $3$ 个连通块分别选择一个点出来，那么 $a_{i,j}+a_{j,k}+a_{i,k}=0$ 就不满足题目限制了。

如果这幅图的连通块个数等于 $2$，那么这两个连通块是完全图，如果不是，我们从一个连通块中选择没边的两个点，另一个连通块选一个点，这三个点互相没边，不满足题目要求。

那么任意一个导出子图的形态就只有下面两种：

- 一个连通块。
- 两个连通块，每个连通块都是完全图。

有一个很好的思路，就是维护两条链，每次加入两个点，如果最后剩下来一个点，暴力加即可。

这里讲一下做法，最开始第一条链只有一个数 $0$，第二条链只有一个数 $1$，设第一条链最后一个数为 $p$，第二条链最后一个数为 $q$，当前要加入 $i,i+1$ 两个点：

- 一次询问判断 $i$ 和 $p$ 是否有边相连，若有：

	- $i$ 加入第一条链末尾，询问 $i$ 和 $i+1$ 是否有边相连，若有：
    	- $i+1$ 加入第一条链末尾。
	- 否则询问 $i+1$ 是否和 $q$ 有边相连，若有：
    	- $i+1$ 加入第二条链末尾。
	- 否则 $i$ 和 $q$ 一定有边相连，合并第一条链和第二条链，然后第二条链赋为 $i+1$ 一个点。
- 否则询问 $i$ 和 $q$ 是否有边相连，若有：
	- $i$ 加入第二条链末尾，询问 $i$ 和 $i+1$ 是否有边相连，若有：
		- $i+1$ 加入第二条链末尾。
	- 否则 $i+1$ 一定与 $p$ 相连，$i+1$ 加入第一条链末尾。
- 否则 $p$ 和 $q$ 一定有边相连，询问 $i$ 和 $i+1$ 是否有边相连，若有：
	- 合并第一条链和第二条链，第二条链变成 $i$ 和 $i+1$ 这两个点的链。
- 否则 $i+1$ 和 $p,q$ 一定有边相连，$i+1$ 加入第一条链末尾，合并第一条链和第二条链，$i$ 单独成为一个链。

发现上述所有情况都最多花了 $3$ 个询问，那么最后如果剩下来一个点暴力询问 $2$ 次即可。

我们便得到了两条链，并且这两条链包括了 $0 \sim n-1$ 的所有节点。

再花一次询问这两条链中间是否有点有边，如果没有，输出这两条链长度较大者即可，这里花费 $1$ 次询问。

考虑合并两条链，如果两条链链头有边或者两条链链尾有边，都可以合并，这里花费 $2$ 次询问。

如果第一条链的链头与第二条链的链尾有边，可以合并，这里花费 $1$ 次询问。

那么剩下的情况怎么处理呢，我们设第一条链链头与链尾为 $p,p'$，第二条链链头与链尾为 $q,q'$，根据上面的询问得到：

$$
a_{p,q}=a_{p',q'}=a_{p,q'}=0
$$

那么我们发现因为 $a_{p',q'}+a_{p,q'}+a_{p,p'} \ge 1$，所以 $a_{p,p'}=1$。

又因为 $a_{p,q}+a_{q,q'}+a_{p,q'} \ge 1$，所以 $a_{q,q'}=1$。

那么这两条链就是一个环了，那么我们通过两次二分找到这两条链中的边 $u \to v$，就可以通过环的性质构造出一条长度为 $n$ 的路径，大概如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/evykhxcn.png)

红色线条是构造的路径，断开的部分代表不相连，即起点在 $u$ 后面的第一个元素，终点在 $v$ 前面的第一个元素。

那么这道题就做完了。

处理到这里，花费的询问数量 $cos$ 如下：

$$
cos = \begin{cases} 1.5 (n-2)+1+2+1+2 \lceil \log_2 n \rceil  & n \bmod 2 = 0 \\ 1.5(n-3)+2+1+2+1+2 \lceil \log_2 n \rceil & n \bmod 2 = 1\end{cases}
$$

算出来最大的值是 $401$，是怎么回事呢？

原因在于我们二分的时候一次用的是第一条链的长度，一次用的是第二条链的长度，而第一条链的长度加上第二条链的长度为 $n$ 并且它们都大于等于 $1$，那么这两条链长度的 $\log_2$（取上整）之和最大为 $2 \lceil \log_2 n \rceil-1$，于是最大询问次数就变成了 $400$，不多不少。

而总的询问点数显然不会超过 $1.5 \times 10^6$，因为 $256 \times 400$ 小于这个数。

## 代码

此代码仅限在洛谷提交 AC。

```cpp
#include<bits/stdc++.h> 
#define vec vector<int>
using namespace std;
std::vec longest_trip(int N, int D);
bool are_connected(std::vec A, std::vec B);
vec p,q,ans,qq;
int n,d,i,l,r,mid,temp,pos1,pos2;
std::vec longest_trip(int N, int D){
	n=N,d=D,ans.clear(),p.clear(),q.clear();
	p.push_back(0),q.push_back(1);
	for(i=2;i+1<n;i+=2){
		if(are_connected(vec{p.back()},vec{i})){
			p.push_back(i);
			if(are_connected(vec{i},vec{i+1})) p.push_back(i+1);
			else if(are_connected(vec{q.back()},vec{i+1})) q.push_back(i+1);
			else{
				while(q.size()) p.push_back(q.back()),q.pop_back();
				q.push_back(i+1);
			}
		}
		else if(are_connected(vec{q.back()},vec{i})){
			q.push_back(i);
			if(are_connected(vec{i},vec{i+1})) q.push_back(i+1);
			else p.push_back(i+1);
		}
		else{
			if(are_connected(vec{i},vec{i+1})){
				while(q.size()) p.push_back(q.back()),q.pop_back();
				q.push_back(i),q.push_back(i+1);
			}
			else{
				p.push_back(i+1);
				while(q.size()) p.push_back(q.back()),q.pop_back();
				q.push_back(i);
			}
		}
	}
	if(n%2==1){
		int id = n-1;
		if(are_connected(vec{p.back()},vec{id})) p.push_back(id);
		else if(are_connected(vec{q.back()},vec{id})) q.push_back(id);
		else{
			while(q.size()) p.push_back(q.back()),q.pop_back();
			q.push_back(id);
		}
	}
	if(!are_connected(p,q)){
		if(p.size()>q.size()) return p;
		else return q;
	}
	if(are_connected(vec{p[0]},vec{q[0]})){
		for(i=q.size()-1;i>=0;i--) ans.push_back(q[i]);
		for(i=0;i<p.size();i++) ans.push_back(p[i]);
		return ans;
	}
	if(are_connected(vec{p.back()},vec{q.back()})){
		for(i=0;i<p.size();i++) ans.push_back(p[i]);
		for(i=q.size()-1;i>=0;i--) ans.push_back(q[i]);
		return ans;
	}
	if(are_connected(vec{p.back()},vec{q[0]})){
		for(i=0;i<p.size();i++) ans.push_back(p[i]);
		for(i=0;i<q.size();i++) ans.push_back(q[i]);
		return ans;
	}
	l=0,r=q.size()-1;
	while(l<r){
		mid=(l+r)/2;
		qq.clear();
		for(i=0;i<=mid;i++) qq.push_back(q[i]);
		if(are_connected(p,qq)) r=mid;
		else l=mid+1;
	}
	pos2=l;
	l=0,r=p.size()-1;
	while(l<r){
		mid=(l+r)/2;
		qq.clear();
		for(i=0;i<=mid;i++) qq.push_back(p[i]);
		if(are_connected(qq,vec{q[pos2]})) r=mid;
		else l=mid+1;
	}
	pos1=l;
	for(i=pos1+1;i<p.size();i++) ans.push_back(p[i]);
	for(i=0;i<=pos1;i++) ans.push_back(p[i]);
	for(i=pos2;i<q.size();i++) ans.push_back(q[i]);
	for(i=0;i<pos2;i++) ans.push_back(q[i]);
    return ans;
}
```

---

## 作者：Purslane (赞：2)

# Solution

思路来自于 He_Ren 在冬令营讲的课。

直接考虑 $D=1$。很明显，这张图的边数至少为 $\dfrac{n(n-1)}{2} - \lfloor \dfrac{n^2}{4} \rfloor$（补图不存在三角形，使用托兰定理），那么可以看出这张图的边“比较稠密”。

容易猜测，最长路径是一条哈密顿路径。但是不一定如此，因为整张图**不一定联通**。但是容易发现，整张图最多由两个连通块构成（否则容易找到两两未连边的三角形），而且这两个连通块必定是完全图，显然完全图存在哈密顿路，我们取较长的一条即可。

考虑维护一条链，然后动态加点。不妨设目前链首为 $s$，链尾为 $t$，新加的点为 $u$。

如果 $u$ 与 $s$ 或者 $t$ 有边，直接连上去。否则，说明 $s$ 和 $t$ 有边，我们之前维护的链形成了一个环。所以只需要 $u$ 和环上任意某个点存在边，就可以相连。

这样看起来是好的，只有一个问题：如果 $u$ 与整个环上所有的点都没有边该如何应对。

这时候我们就可以尝试同时维护两条链。每次加入一个点的时候，先询问它能否直接合并到两条链的某一条的末尾。如果都不能合并，说明两条链自身是可以合并的（末端本身就有连边），新加的一个点可以当做新的链。由于复杂度较小，可以直接暴力使用 vector 存储两条链的信息。

但是这样新加一个点需要两次合并操作，明显无法在 $400$ 次以内完成任务。考虑 $1.5n$ 略小于限制，所以尝试用 $3$ 次合并操作加入两个点。这是简单的。考虑我们要加入 $u$ 和 $v$ 两个节点，两个链尾分别是 $t_1$ 和 $t_2$。直接给出策略：

在 $u$ 和 $v$ 之间询问。并且按照他们是否存在边分成两部分：
- 如果 $u$ 和 $v$ 之间有连边。
    - 查询 $u$ 和 $t_1$ 以及 $u$ 与 $t_2$ 之间是否有连边。
        - 只要有一个有连边，就可以合并成新的链。
        - 如果都没有连边，则 $t_1$ 与 $t_2$ 必定有边，直接合并。
    
- 如果 $u$ 和 $v$ 之间没有连边。
    - 查询 $u$ 与 $t_1$ 之间有没有连边。
    	- 如果没有连边，则 $v$ 与 $t_1$ 必定有连边，合并。
      - 如果有连边，直接让 $u$ 与 $t_1$ 合并。
    - 这样必定 $u$ 和 $v$ 有一个与第一条条链合并。
    - 查询另外一个点（$u$ 和 $v$ 中没有已经合并到链上的）与 $t_2$ 是否有连边。
    	- 如果有连边，直接与第二条链合并。
      - 如果没有连边，第一条链和第二条链的链尾可以直接合并，这个点单独当成一条新的链。
      
可见，最多 $3$ 次操作可以合并两个节点。所以你需要 $254 \times \dfrac{3}{2} = 381$ 次操作，还剩下 $19$ 次操作。

剩下要考虑能否将两条链合并。设四个端点分别是 $s_1$、$t_1$ 与 $s_2$、$t_2$。先用一次询问得到 $\{s_1,t_1\}$ 和 $\{s_2,t_2\}$ 有没有连边。

- 如果有连边，直接暴力枚举四种情况，至少有一种能直接合并两条链。

- 否则，这两条链必定是两个环。我们可以使用 $\log_2 s_1 + 1$ 次操作确定第一个环里面哪个点和第二个环有边。再用 $\log_2 s_2$ 次操作确定第二个环里面哪个点和第一个环中确定的这个点右边（上面所有东西都要上取整）。打表发现，最多要 $16$ 次二分来实现。

综上所述，我们最多使用 $398$ 次询问，在要求之内。更一般的，你可以通过随机加点的顺序，随机询问顺序来让这个次数卡不满。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=256+10;
bool are_connected(vector<int> A,vector<int> B);
vector<int> longest_trip(int N,int D);
#define con are_connected
vector<int> c1,c2;
int tl(vector<int> vc) {return vc[vc.size()-1];}
int icon(int u,int v) {vector<int> A,B; A.push_back(u),B.push_back(v);return con(A,B);}
vector<int> merge(vector<int> vc1,vector<int> vc2) {
	roff(i,vc2.size()-1,0) vc1.push_back(vc2[i]);	
	return vc1;
}
mt19937 myrand(time(NULL));
void add_node(int u,int v) {
	if(myrand()&1) swap(c1,c2);
	if(v==-1) {
		if(icon(u,tl(c1))) c1.push_back(u);
		else if(icon(u,tl(c2))) c2.push_back(u); 
		else c1=merge(c1,c2),c2.clear(),c2.push_back(u);
		return ;
	}
	if(icon(u,v)) {
		if(icon(u,tl(c1))) c1.push_back(u),c1.push_back(v);
		else if(icon(u,tl(c2))) c2.push_back(u),c2.push_back(v);
		else c1=merge(c1,c2),c2.clear(),c2.push_back(u),c2.push_back(v);
	}
	else {
		if(icon(u,tl(c1))) c1.push_back(u);
		else c1.push_back(v),swap(u,v);
		if(icon(v,tl(c2))) c2.push_back(v);
		else c1=merge(c1,c2),c2.clear(),c2.push_back(v);
	}
	return ;
}
int id[MAXN];
vector<int> gen(vector<int> ori,int l,int r) {
	vector<int> ans;
	ffor(i,l,r) ans.push_back(ori[i-1]);
	return ans;	
}
vector<int> longest_trip(int n,int d) {
	c1.clear(),c2.clear();	
	ffor(i,1,n+1) id[i]=-1;
	ffor(i,1,n) id[i]=i-1;
	shuffle(id+1,id+n+1,myrand);
	c1.push_back(id[1]),c2.push_back(id[2]);
	ffor(i,2,n/2+n%2) add_node(id[2*i-1],id[2*i]);
	vector<int> v1,v2; 
	v1.push_back(c1[0]),v2.push_back(c2[0]);
	if(c1.size()-1) v1.push_back(tl(c1));
	if(c2.size()-1) v2.push_back(tl(c2));
	if(con(v1,v2)) {
		if(icon(c1[0],c2[0])) return reverse(c1.begin(),c1.end()),reverse(c2.begin(),c2.end()),merge(c1,c2);
		if(icon(c1[0],tl(c2))) return reverse(c1.begin(),c1.end()),merge(c1,c2);
		if(icon(tl(c1),c2[0])) return reverse(c2.begin(),c2.end()),merge(c1,c2);
		return merge(c1,c2);
	}
	else {
		int ans=-1,l=1,r=c1.size();
		while(l<=r) {
			int mid=l+r>>1;
			if(con(gen(c1,mid,c1.size()),c2)) ans=mid,l=mid+1;
			else r=mid-1;	
		}
		if(ans==-1) {
			if(c1.size()>c2.size()) return c1;
			return c2;	
		}
		vector<int> C1; int mzx=ans-1;
		C1.push_back(c1[mzx]);
		ans=-1,l=1,r=c2.size();
		while(l<=r) {
			int mid=l+r>>1;
			if(con(C1,gen(c2,mid,c2.size()))) ans=mid,l=mid+1;
			else r=mid-1;	
		}
		ans--;
		vector<int> res;
		int popu=(mzx+1)%c1.size();
		while(popu!=mzx) res.push_back(c1[popu]),popu=(popu+1)%c1.size();
		res.push_back(c1[mzx]),res.push_back(c2[ans]);
		popu=(ans+1)%c2.size();
		while(popu!=ans) res.push_back(c2[popu]),popu=(popu+1)%c2.size();
		return res;
	}
}
```

简单补充一下如何自测：把下发文件里面的 `longesttrip.h` 替换成你写的程序，然后运行 `grader.cpp`（这里面可能有一些奇怪的 static，我都给删掉了），按照题目的要求进行输入。

---

## 作者：cryozwq (赞：1)


$D=3$ 十分困难。

$D=2$ 我们考虑答案一定是 $n$，然后提出一个构造性做法证明，这里先不写了，因为是 $D=1$ 做法的子集。

$D=1$ 答案是不是还一定是 $n$ 呢？显然不是，考虑一张四个点，两条边的图就能 Hack 掉，但是稍加冷静思考，答案一定还是很好算的~~不然spj怎么写~~，事实上，除非原图是两个不联通的团，答案还是 $n$，至于怎么证明，还是一个构造性做法。

这个做法的核心想法是，维护原图两条路径 $P_1$，$P_2$ 满足每个点都在其中一条路径上，这样一来如果原图答案不是 $n$，那么答案就是 $\max(P_1,P_2)$，如果是 $n$，设两条路径首尾分别是 $s_1,t_1,s_2,t_2$，只要 $(s_1,s_2),(s_1,t_2),(t_1,s_2),(t_1,t_2)$ 中有一条边存在，那很容易走出长度为 $n$ 的路径，如果都不存在那么 $(s_1,t_1),(s_2,t_2)$ 一定都存在，由原图联通那 $P_1$ 中的某个点一定能走到 $P_2$ 某个点，那直接以 $P_1$ 那个点为起点绕一圈走到 $P_2$ 再绕一圈走完 $P_2$ 即可。

所以问题变为如何维护 $P_1$,$P_2$，考虑一个点一个点加进去，设当前两条路径最前面是 $t_1,t_2$，当前点如果和 $t_1,t_2$ 中某个点连接那么加在后面即可，如果都不，$(t_1,t_2)$ 一定存在，那么 $P_1$ 和 $P_2$ 可以合并为一条路径，当前点成为一条新的路径即可。这样做的话需要的询问次数上限是 $2n$，无法通过。

考虑优化，核心思想就是每次多加几个点一起问，具体过程的话不嫌字丑可以看[我写的草稿](https://www.luogu.com.cn/paste/o72bylxk)，这样一来询问次数上限是 $\frac{3}{2}n$，加上找 $P_1$,$P_2$ 之间一条边需要类似二进制分组一样找的 $2\log n$，加起来居然正好是 $400$ 次！，可惜询问原图是否联通和那四条边是否存在还需要几次询问，所以理论上来说会被卡，但事实上，如果对点 random_shuffle 一下，出现“四次询问三个点”的次数还是会比较多的，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
std::vector<int> longest_trip(int N, int D);

bool are_connected(std::vector<int> A, std::vector<int> B);
bool query(std::vector<int> A, std::vector<int> B){
	if(!A.size()||!B.size())return 0;
	return are_connected(A,B);
}
inline bool ask(int u,int v){
	vector<int>v1,v2;
	v1.resize(1);v2.resize(1);
	v1[0]=u;v2[0]=v;
	return query(v1,v2);
} 
std::vector<int> longest_trip(int n, int d){
	vector<int>ans;ans.clear();	
	if(d==3){
		for(int i=0;i<n;i++)ans.push_back(i);
		return ans;
	}	
	vector<int>tmp,t1,t2,l1,l2;
	tmp.resize(n);
	l1.clear();l2.clear();
	for(int i=0;i<n;i++)tmp[i]=i;
	random_shuffle(tmp.begin(),tmp.end());
	l1.push_back(tmp[0]);
	int st1=tmp[0],ed1=tmp[0],st2=-1,ed2=-1;
//	cout<<"?-é?1"<<endl; 
	for(int i=1;i<tmp.size();i++){
		int v=tmp[i];
		t1.resize(1);t2.resize(1);
		t1[0]=v;t2[0]=ed1;
		bool f1=query(t1,t2);
		if(f1){ed1=v;l1.push_back(v);continue;}
		if(ed2==-1){st2=ed2=v;l2.push_back(v);continue;}
		t2[0]=ed2;
		bool f2=query(t1,t2);
		if(f2){	
			if(i==tmp.size()-1)ed2=v,l2.push_back(v);
			else{
				l2.push_back(v);
				ed2=v;
				t1[0]=tmp[i+1],t2[0]=ed1;
				bool f3=query(t1,t2);
				if(f3)ed1=tmp[i+1],l1.push_back(tmp[i+1]);
				else ed2=tmp[i+1],l2.push_back(tmp[i+1]);
				i++;
			}
		}
		else{  
			if(i+2>=tmp.size()){
				ed1=st2;
				reverse(l2.begin(),l2.end());
				for(auto vv:l2)l1.push_back(vv);
				l2.clear(); 
				st2=ed2=v;
				l2.push_back(v);
				continue;
			}
			int v1=tmp[i+1],v2=tmp[i+2];
			t1[0]=v;t2[0]=v1;
			bool c1=query(t1,t2);
			t1[0]=v;t2[0]=v2;
			bool c2=query(t1,t2);
			if(c1&&c2){ 
				ed1=st2;
				reverse(l2.begin(),l2.end());
				for(auto vv:l2)l1.push_back(vv);
				l2.clear();
				l2.push_back(v1);
				l2.push_back(v);
				l2.push_back(v2);
				st2=v1;ed2=v2;
			}
			if(!c1&&!c2){
				l1.push_back(v1);
				l1.push_back(v2);
				reverse(l2.begin(),l2.end());
				for(auto vv:l2)l1.push_back(vv);
				ed1=st2;
				st2=ed2=-1;
				l2.clear();
				st2=ed2=v;
				l2.push_back(v);
			}
			if(c1&&!c2){
				l1.push_back(v2);
				reverse(l2.begin(),l2.end());
				for(auto vv:l2)l1.push_back(vv);
				l2.clear();
				ed1=st2;
				st2=v1;ed2=v;
				l2.push_back(v1);l2.push_back(v);
			}
			if(!c1&&c2){
				l1.push_back(v1);
				reverse(l2.begin(),l2.end());
				for(auto vv:l2)l1.push_back(vv);
				l2.clear();
				ed1=st2;
				st2=v2;ed2=v;
				l2.push_back(v2);l2.push_back(v);
			}
			i+=2;
		} 
	}
//	int lt=-1;
//	for(auto v:l1){
//		if(lt!=-1){
//			if(!ask(lt,v))assert(0);
//		}
//		lt=v;
//	}
//	cout<<"?-é?2"<<st1<<" "<<ed1<<" "<<st2<<" "<<ed2<<" "<<l1[0]<<" "<<l1[l1.size()-1]<<" "<<l2[0]<<" "<<l2[l2.size()-1]<<endl;
//	st1=l1[0];
//	st2=l2[9];
//	ed1=l1[l1.size()-1];
//	ed2=l2[l2.size()-1];
	if(ed2==-1)return l1;
	bool fl=0;
	if(ask(st1,st2)){
		fl=1;
		reverse(l1.begin(),l1.end());
	}
	else if(ask(st1,ed2)){
		fl=1;
		reverse(l1.begin(),l1.end());
		reverse(l2.begin(),l2.end());
	}
	else if(ask(ed1,st2)){
		fl=1;
	}
	else if(ask(ed1,ed2)){
		fl=1;
		reverse(l2.begin(),l2.end());
	}
	if(!query(l1,l2)){
//		cout<<l2.size()<<" "<<l1.size()<<endl;
		if(l1.size()<l2.size())return l2;
		else return l1;
	}
	if(fl){
		for(auto v:l1)ans.push_back(v);
		for(auto v:l2)ans.push_back(v);
		return ans;
	}
//	cout<<"???ˉ"<<endl; 
	vector<int>lst,n1,n0,lst2;
	lst=l1;
//	cout<<"yuanshen"<<endl;
	for(int i=1;;i<<=1){
		if(lst.size()==1)break;
//		cout<<lst.size()<<endl;
		n1.clear();n0.clear();
		for(auto v:lst){
			if((v&i))n1.push_back(v);
			else n0.push_back(v);
		}
		if(query(n0,l2))lst=n0;
		else lst=n1;
	}
//	cout<<"shiyuanshenhuilewo\n";
	lst2=l2;
	assert(query(lst2,lst));
	for(int i=1;;i<<=1){
		if(lst2.size()==1)break;
		n1.clear();n0.clear();
		for(auto v:lst2){
			if((v&i))n1.push_back(v);
			else n0.push_back(v);
		}
		if(query(n0,lst))lst2=n0;
		else lst2=n1;
	}
	int tu=lst[0],tv=lst2[0];
	int p1=0,p2=0;
	for(int i=0;i<l1.size();i++)if(l1[i]==tu)p1=i;
	for(int i=0;i<l2.size();i++)if(l2[i]==tv)p2=i;
	int now=(p1+1);
//	cout<<l1.size()<<" "<<l2.size()<<endl;
	while(1){
		now%=l1.size();
		ans.push_back(l1[now]);
		if(now==p1)break;
		now++;
	}
	now=p2;
	while(1){
		ans.push_back(l2[now]);	
		now++;
		now%=l2.size();
		if(now==p2)break;
	}
	return ans;
}

```

---

## 作者：wyp20130701_AC (赞：1)

首先，连通块数量一定不超过 $3$，如果连通块数量为 $2$，那么两个连通块一定都是完全图。答案就是两个图中较大的那一个。不然的话，现在要求一个连通图的最长路。  
下面证明这个连通图一定存在哈密顿通路（不懂哈密顿通路的在[这里](https://blog.csdn.net/zhouzi2018/article/details/81278942)学）。
## 证明
考虑现在对前 $i$ 个数维护了一条哈密顿通路 $u_1 \rightarrow u_2 \ldots u_k$，现在加入 $i + 1$： 
- 如果 $i + 1$ 与 $u$ 有连边，连接 $i + 1$ 和 $u$。
- 如果 $i + 1$ 与 $v$ 有连边，连接 $i + 1$ 和 $v$。
- 否则，$u$ 和 $v$ 有连边，原图是一个环。在当中二分出一个点 $k$ 与 $i + 1$ 有连边，并把环断出来形成一条新的链。

同时我们得到了一个询问次数为 $O(n\log n)$的做法。  
一个神奇的优化：维护两条链，设两条链链头分别为 $x$ 和 $y$。链底分别为 $p$ 和 $q$。  
考虑增加点 $i$，有如下几种情况：
- 如果 $i$ 与 $x$ 或 $y$ 有连边，把 $i$ 加入那条链。
- 否则 $x,y$ 有连边，把两条链合并成一条，$i$ 独自一条链。

最后把两条链合并起来。
- 如果 $\{x,p\}$ 和 $\{y,p\}$ 之间有连边，直接接起来。
- 否则两条链都是环，在两条链中分别二分出两个点，满足他们之间有边，并断环合并。

得到了一个 $$2n + 2\log n$$ 次询问的做法。  
## 进一步优化
考虑优化，$400$ 大概是 $$1.5n + 2\log n$$，所以考虑用三次询问增加两个点。假设两个链链头分别为 $x,y$，先增加 $a,b$。
- 如果 $a,b$ 之间有边。
     - 如果 $x,y$ 之间有边，就把 $x,y$ 连接，另一条链设为 $a,b$。
     - 否则，$a$ 和 $x,y$ 之间至少一个有边。用一次操作判断和哪个连接。
- 否则如果 $x$ 和 $a$ 有边，把 $a$ 放在 $x$ 后面。
     - 如果 $a$ 和 $y$ 有边，合并两条链，把 $b$ 设为一条链。
     - 否则 $b$ 和 $y$ 一定有边。
- 否则 $x$ 和 $b$ 一定有边，$y$ 的讨论如上。
```cpp
//#include "longesttrip.h"
#include<bits/stdc++.h>
using namespace std;
vector<int>longest_trip(int N,int D);
bool are_connected(vector<int>A,vector<int>B);
vector<int>mk(vector<int>g)
{
	if(g.front()==g.back())
		return {g.front()};
	return {g.front(),g.back()};
}
std::vector<int> longest_trip(int N, int D)
{
	--N;
	if(!N)
		return {0};
	vector<int>g,h;
	g.push_back(1),h.push_back(0);
	for(int i=2;i<N;i+=2)
	{
		if(are_connected({i},{i+1}))
		{
			if(are_connected({g.back()},{h.back()}))
			{
				while(!h.empty())
					g.push_back(h.back()),h.pop_back();
				h.push_back(i),h.push_back(i+1);
			}
			else
			{
				if(are_connected({g.back()},{i}))
					g.push_back(i),g.push_back(i+1);
				else
					h.push_back(i),h.push_back(i+1);
			}
		}
		else
		{
			if(are_connected({g.back()},{i}))
			{
				g.push_back(i);
				if(are_connected({h.back()},{i}))
				{
					while(!h.empty())
						g.push_back(h.back()),h.pop_back();
					h.push_back(i+1);
				}
				else
					h.push_back(i+1);
			}
			else
			{
				g.push_back(i+1);
				if(are_connected({h.back()},{i+1}))
				{
					while(!h.empty())
						g.push_back(h.back()),h.pop_back();
					h.push_back(i);
				}
				else
					h.push_back(i);
			}
		}
	}
	if(N&1^1)
	{
		if(are_connected({g.back()},{h.back()}))
		{
			while(!h.empty())
				g.push_back(h.back()),h.pop_back();
			h.push_back(N);	
		}
		else
		{
			if(are_connected({g.back()},{N}))
				g.push_back(N);
			else
				h.push_back(N);
		}
	}
	if(are_connected(g,h))
	{
		if(are_connected(mk(g),mk(h)))
		{
			vector<int>p;
			if(are_connected({g.front()},{h.front()}))
			{
				p=g;
				reverse(p.begin(),p.end());
				for(int j:h)
					p.push_back(j);
			}
			else if(are_connected({g.front()},{h.back()}))
			{
				p=h;
				for(int j:g)
					p.push_back(j);
			}
			else if(are_connected({g.back()},{h.back()}))
			{
				p=g;
				for(int i=h.size()-1;~i;--i)
					p.push_back(h[i]);
			}
			else
			{
				p=g;
				for(int j:h)
					p.push_back(j);
			}
			return p;
		}
		int l=0,r=g.size()-1;
		while(l<r)
		{
			int md=l+r>>1;
			vector<int>p;
			for(int i=0;i<=md;i++)
				p.push_back(g[i]);
			if(are_connected(p,h))
				r=md;
			else
				l=md+1;
		}
		int k=l;
		l=0,r=h.size()-1;
		while(l<r)
		{
			int md=l+r>>1;
			vector<int>p;
			for(int i=0;i<=md;i++)
				p.push_back(h[i]);
			if(are_connected({g[k]},{p}))
				r=md;
			else
				l=md+1;
		}
		if(h.front()^h.back())
			assert(are_connected({h[l]},{g[k]}));	
		vector<int>p;
		for(int i=l-1;~i;--i)
			p.push_back(h[i]);
		for(int i=h.size()-1;i>=l;i--)
			p.push_back(h[i]);
		for(int i=k;~i;--i)
			p.push_back(g[i]);
		for(int i=g.size()-1;i>k;i--)
			p.push_back(g[i]);
		return p;
	}
	else
		return g.size()>h.size()? g:h;
}
```
**提示：编辑器语言得是C++20，要不然会编辑错误。**

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P9601)

**题目大意**

> 交互器有一张 $n$ 个点的无向图，保证任意三个点之间至少有一条边。
>
> 你每次可以询问两个不交点集之间是否有边，$400$ 次询问内构造出最长路。
>
> 数据范围：$n\le 256$。

**思路分析**

如果整张图不连通，那么这个图一定是两个完全图，答案就是这两个连通块的较大值。

如果整张图联通，我们不妨猜测整张图有哈密顿路。

我们考虑逐步在图中加点，保证图始终联通，并且在这个过程中动态维护哈密顿路。

考虑新加入点 $u$ 和链的头尾 $s,t$ 的关系，如果 $u\to s,u\to t$ 存在任意一条即可，否则 $s\to t$ 存在，那么哈密顿路实际上是一个环。

由于 $u$ 与原图联通，我们找到 $u$ 在环上的邻域 $v$，连接 $u\to v$ 然后切掉 $v$ 的入边即可。

但这样构造过程需要太多次询问，考虑优化：

我们可以同时维护两条路径，每次加点 $u$ 时取出两条路径的各一个端点 $x,y$，如果 $u\to x,u\to y$ 存在其一就可以直接加入，否则把 $x,y$ 连接然后把 $u$ 独立加入。

最后合并的时候看第一条路径的两个端点 $a,b$ 和第二条路径的一个端点 $c$，如果 $a\to c,b\to c$ 存在其一直接合并，否则第一条路径是一个环，二分出 $c$ 在其中的一个邻居即可。

这样的询问次数是 $2n+\log n$ 的，需要进一步优化。

考虑 $3$ 次操作加入两个点 $u,v$，设两条路径各一个端点 $x,y$，先询问 $u\to v$ 是否存在：

- 如果 $u\to v$ 不存在，那么询问 $u\to x,u\to y$ 是否存在：
  
  - 如果两条边都存在那么就把两条链用 $u$ 连起来，$v$ 单独成链。
  - 如果恰存在一条边，那么另一个端点一定和 $v$ 联通，分别加入一条链即可。
  - 如果两条边都不存在，那么原来的两条链用 $v$ 连起来，$u$ 单独成链。
- 如果 $u\to v$ 存在，那么询问 $u\to x,u\to y$ 是否存在：
  
  - 如果存在至少一条，那么把 $u,v$ 都加入该链末尾。
  - 否则说明 $x\to y$ 存在，把原来的两条链连成一条，$u\to v$ 成为新的一条链。

操作次数大约为 $1.5n+2\log n$，可以计算得到最大次数恰好为 $400$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "longesttrip.h"
using namespace std;
bool qry(int x,int y) { return are_connected({x},{y}); }
vector<int>longest_trip(int n,int d) {
	vector <int> a{0},b{1};
	for(int i=2;i+1<n;i+=2) {
		int x=a.back(),y=b.back();
		if(qry(i,i+1)) {
			if(qry(i,x)) a.push_back(i),a.push_back(i+1);
			else if(qry(i,y)) b.push_back(i),b.push_back(i+1);
			else {
				for(int j=b.size()-1;~j;--j) a.push_back(b[j]);
				b={i,i+1};
			}
		} else {
			bool cx=qry(i,x),cy=qry(i,y);
			if(cx&&cy) {
				a.push_back(i);
				for(int j=b.size()-1;~j;--j) a.push_back(b[j]);
				b={i+1};
			} else if(cx||cy) {
				a.push_back(i+cy),b.push_back(i+cx);
			} else {
				b.push_back(i+1);
				for(int j=a.size()-1;~j;--j) b.push_back(a[j]);
				a={i};
			}
		}
	}
	if(n&1) {
		int x=a.back(),y=b.back();
		if(qry(n-1,x)) a.push_back(n-1);
		else if(qry(n-1,y)) b.push_back(n-1);
		else {
			for(int i=b.size()-1;~i;--i) a.push_back(b[i]);
			b={n-1};
		}
	}
	if(a.size()>b.size()) swap(a,b);
	if(!are_connected(a,b)) return b;
	int x=a.back();
	if(qry(x,b.front())) {
		for(int i:b) a.push_back(i);
		return a;
	}
	if(qry(x,b.back())) {
		for(int i=b.size()-1;~i;--i) a.push_back(b[i]);
		return a;
	}
	if(qry(a[0],b.back())) {
		for(int i:a) b.push_back(i);
		return b;
	}
	int l=0,r=(int)a.size()-1;
	while(l<r) {
		int mid=(l+r)>>1;
		if(are_connected(vector<int>(a.begin()+l,a.begin()+mid+1),b)) r=mid;
		else l=mid+1;
	}
	if(l!=(int)a.size()-1) rotate(a.begin(),a.begin()+l+1,a.end());
	x=a.back(),l=0,r=(int)b.size()-1;
	while(l<r) {
		int mid=(l+r)>>1;
		if(are_connected(vector<int>(b.begin()+l,b.begin()+mid+1),{x})) r=mid;
		else l=mid+1;
	}
	rotate(b.begin(),b.begin()+l,b.end());
	for(int i:b) a.push_back(i);
	return a;
}
```

---

## 作者：lalaouye (赞：0)

解法非常优雅的题，不愧是 IOI 题！

首先这题第一眼是非常怪且不可做的。因为他的三元组限制和询问形式都非常的奇怪。不妨看一下部分分，$D=3$ 显然是完全图，随便输出就行了。$D=2$ 我们发现我们可以考虑往路径中依次加点，不难发现每次都是能加进去的，因为有三元组的限制。

那正解会不会也是沿着这个思路往下走呢？我们考虑依次加点，发现有可能有点是加不进去的，这种情况下路径的 $s,t$ 之间必然有边。接下来想到的一些奇奇怪怪的做法都是很劣的，复杂度不对而且正确性还有问题，我们需要多分析一些性质。

首先如果图不连通，那么显然这些连通子图都得是完全图。愚蠢的我没有却没有发现**最多只有两个连通块**。这些都是显然好证的性质，那么我们可以考虑维护出两条路径，考虑当前要加入点 $u$，两条路径当前走到了 $t_1,t_2$，那么如果只 $u$ 与 $t_1$ 连边就接到第一条路径，只与 $t_2$ 连边就接到第二条路径，若都有连边则可以合并两条路径。不难发现不存在都不连接的情况，若都不连接那么 $t_1,t_2$ 之间必须有边，那么可以把他们合并变成一条路径，$u$ 单独另开一条路径。

但是我们发现首先这样就是 $2n$ 级别的。然而处理完两条路径后，并不意味着这两条路径就不连通，也就是说我们还要处理这两条路径之间的边对答案的影响。发现直接分析非常困难，但是我们发现若在同一路径中的一对点对之间没有直接连边，那么对于另外一条路径上的任意一点，点对中至少存在一个点与其连通。

而如果同一路径中有点对同时无法到达另外一条路径中的一个点则点对间必然有连边。

同时我们发现，两条路径如果 $s,t$ 之间都有连边，即能构成环，则只要存在连边都可以构造出路径长度为 $n$ 的解。

所以我们先 check 两条路径首尾是否有边相连，若有则可以直接构造出长度为 $n$ 的解。否则不难发现我们可以进行两次二分找到其中一条边。

那么我们现在只需要花 $2n+2\log n$ 次就能完成最长路径构造，现在考虑优化前半部分。

考虑限制与 $n$ 的关系，发现前面花 $\frac 3 2 n$ 次刚好能够通过。乱搞有点困难，我们每插入一个点稳定需要 $2$ 次查询。不妨考虑让两个点一起加然后花三次查询。怎么加其实是不难手玩出来的。我是按照加入两点 $u,v$ 是否连通进行讨论的。

然后就做完了。代码如下：


```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i (l); i <= (r); ++ i)
#define rrp(i, l, r) for (int i (r); i >= (l); -- i)
#define eb emplace_back
using namespace std;
#define pii pair <int, int>
#define inf 1000000000
#define ls (p << 1)
#define rs (ls | 1)
constexpr int N = 2000 + 5, M = 5e5, P = 353442899, B = 400;
typedef long long ll;
typedef unsigned long long ull;
std::vector<int> longest_trip (int N, int D);

bool are_connected (std::vector <int> A, std::vector <int> B);
vector <int> v0, v1;
bool ask (int u, int v) { assert (u != v); return are_connected ({u}, {v}); }
mt19937 rnd (20090421);
vector <int> longest_trip (int N, int D) {
  v0.clear (), v1.clear ();
  int st (1);
  if (~ N & 1) {
    st = 2;
    v0.eb (0), v1.eb (1);
  } else v0.eb (0);
  for (int i (st); i < N; i += 2) {
    if (v0.empty ()) swap (v0, v1);
    int u (i), v (i + 1);
    int c0, c1, c2 (ask (u, v));
    if (v1.empty ()) {
      if (c2) v1.eb (u), v1.eb (v);
      else if (ask (v0.back (), u)) {
        v0.eb (u); v1.eb (v);
      } else v0.eb (v), v1.eb (u);
    } else {
      if (c2) {
        c0 = ask (v0.back (), u);
        if (c0) {
          v0.eb (u), v0.eb (v); continue;
        }
        c1 = ask (v0.back (), v1.back ());
        if (! c1) {
          v1.eb (u), v1.eb (v); continue;
        }
        rrp (i, 0, v1.size () - 1) v0.eb (v1[i]); v1.clear ();
        v1.eb (u), v1.eb (v);
      } else {
        c0 = ask (v0.back (), u);
        c1 = ask (v1.back (), v);
        if (! c0 && ! c1) c0 = c1 = 1, swap (u, v);
        if (c0 && c1) {
          v0.eb (u), v1.eb (v);
        } else {
          if (! c0) swap (c0, c1), swap (u, v);
          v0.eb (u);
          rrp (i, 0, v1.size () - 1) v0.eb (v1[i]);
          v1.clear (); v1.eb (v);
        }
      }
    }
  }
  if (v0.size () == N) return v0;
  if (! are_connected (v0, v1)) {
    if (v0.size () < v1.size ()) swap (v0, v1);
    return v0;
  }
  if (ask (v0.front (), v1.front ())) {
    vector <int> ans;
    int sz = v0.size ();
    rrp (i, 0, sz - 1) ans.eb (v0[i]);
    for (auto u : v1) ans.eb (u);
    return ans;
  }
  if (ask (v0.front (), v1.back ())) {
    for (auto v : v0) v1.eb (v); return v1;
  }
  if (ask (v0.back (), v1.front ())) {
    for (auto v : v1) v0.eb (v); return v0;
  }
  if (ask (v0.back (), v1.back ())) {
    rrp (i, 0, v1.size () - 1) v0.eb (v1[i]);
    return v0;
  }
  int l (0), r (v0.size () - 1);
  int pos;
  while (l <= r) {
    int mid (l + r >> 1);
    vector <int> vec;
    rep (i, 0, mid) vec.eb (v0[i]);
    if (are_connected (vec, v1)) {
      pos = mid; r = mid - 1;
    } else l = mid + 1;
  }
  l = 0, r = v1.size () - 1;
  int Pos;
  while (l <= r) {
    int mid (l + r >> 1);
    vector <int> vec;
    rep (i, 0, mid) vec.eb (v1[i]);
    if (are_connected ({v0[pos]}, vec)) {
      Pos = mid; r = mid - 1;
    } else l = mid + 1;
  }
  vector <int> ans;
  rep (i, pos + 1, v0.size () - 1) ans.eb (v0[i]);
  rep (i, 0, pos) ans.eb (v0[i]);
  rep (i, Pos, v1.size () - 1) ans.eb (v1[i]);
  rep (i, 0, Pos - 1) ans.eb (v1[i]);
  return ans;
}
```

---


# [IOI 2023] 山毛榉树

## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

本题仅支持 C++ 语言提交。

## 题目描述

Vétyem Woods 是一片著名的缤纷多彩的森林。其中最老最高的一棵山毛榉树叫 Ős Vezér。

树 Ős Vezér 可以被建模成 $N$ 个**结点**和 $N-1$ 条**边**的集合。结点的编号为从 $0$ 到 $N-1$，边的编号为从 $1$ 到 $N-1$。每条边均连接树上两个不同的结点。具体地说，边 $i$（$1 \le i \lt N$）从结点 $i$ 连接到结点 $P[i]$，这里 $0 \le P[i] \lt i$。结点 $P[i]$ 被称为是结点 $i$ 的**父结点**，而结点 $i$ 被称为是结点 $P[i]$ 的一个**子结点**。

每条边都有某种颜色。一共有 $M$ 种可能的颜色，编号为从 $1$ 到 $M$。边 $i$ 的颜色为 $C[i]$。不同的边可能有相同的颜色。

注意，在上面的定义中，$i = 0$ 的情形并不对应树上的边。方便起见，我们令 $P[0] = -1$ 和 $C[0] = 0$。

例如，假定 Ős Vezér 有 $N = 18$ 个结点和 $M = 3$ 种可能的颜色，以及 $17$ 条边。边的描述为 $P = [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11]$，边的颜色为 $C = [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3]$。这棵树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/xnxdhpz1.png)

Árpád 是一位才华横溢的护林人，他喜欢研究树上被称为**子树**的部分。
对所有满足 $0 \le r \lt N$ 的  $r$，结点 $r$ 的子树是一个满足以下性质的结点集合 $T(r)$：

* 结点 $r$ 属于 $T(r)$。
* 如果某个结点 $x$ 属于 $T(r)$，则 $x$ 的所有子结点都属于$T(r)$。
* 除了上述情况以外，其他结点都不属于 $T(r)$。

集合 $T(r)$ 的大小记作 $|T(r)|$。

Árpád 最近发现了一个复杂但有趣的子树性质。Árpád 的发现需要用到大量的纸和笔做演算，他认为你需要做同样的事情才能完成理解。他还会给你几个例子，让你能够对它们做详细的分析。

假设我们有某个给定的 $r$，以及子树 $T(r)$ 中结点的某个置换 $v_0, v_1, \ldots, v_{|T(r)|-1}$。

对于所有满足 $1 \le i \lt |T(r)|$ 的 $i$，令 $f(i)$ 为颜色 $C[v_i]$ 在长为 $i-1$ 的颜色序列 $C[v_1], C[v_2], \ldots, C[v_{i-1}]$ 中的出现次数。

（注意，$f(1)$ 必定为 $0$，原因是其定义中要考察的颜色序列是空的。）

置换 $v_0, v_1, \ldots, v_{|T(r)|-1}$ 被称为是一个**绝妙置换**，当且仅当以下性质成立：

* $v_0 = r$。
* 对于所有满足 $1 \le i \lt |T(r)|$ 的 $i$，结点 $v_i$ 的父结点是 $v_{f(i)}$。

对于所有满足 $0 \le r \lt N$ 的 $r$，子树 $T(r)$ 是一棵**绝妙子树**，当且仅当 $T(r)$ 中结点存在某个绝妙置换。注意，根据定义，仅包含单独一个结点的子树都是绝妙的。

考虑上面给出的树的例子。可以看到，子树 $T(0)$ 和 $T(3)$ 不是绝妙的。子树 $T(14)$ 是绝妙的，因为它仅包含一个结点。接下来，我们将要说明子树 $T(1)$ 也是绝妙的。

考虑一个由不同整数构成的序列 $[v_0, v_1, v_2, v_3, v_4, v_5, v_6] = [1, 4, 5, 12, 13, 6, 14]$。这个序列是 $T(1)$ 中结点的一个置换。下图给出了这个置换。序列中每个结点旁边的数字，是该结点在置换中的索引。

![](https://cdn.luogu.com.cn/upload/image_hosting/ziecuezc.png)

我们将要验证，这是一个**绝妙置换**。

* $v_0 = 1$。
* $f(1) = 0$，原因是 $C[v_1] = C[4] = 1$ 在序列 $[\,]$ 中出现了 $0$ 次。
 * 相应地，$v_1$ 的父结点是 $v_0$。也就是说，$4$ 的父结点是 $1$。（形式化地，$P[4] = 1$。）
* $f(2) = 0$，原因是 $C[v_2] = C[5] = 2$ 在序列 $[1]$ 中出现了 $0$ 次。
 * 相应地，$v_2$ 的父结点是 $v_0$。也就是说，$5$ 的父结点是 $1$。
* $f(3) = 1$，原因是 $C[v_3] = C[12] = 1$ 在序列 $[1, 2]$ 中出现了 $1$ 次。
 * 相应地，$v_3$ 的父结点是 $v_1$。也就是说，$12$ 的父结点是 $4$。
* $f(4) = 1$，原因是 $C[v_4] = C[13] = 2$ 在序列 $[1, 2, 1]$ 中出现了 $1$ 次。
 * 相应地，$v_4$ 的父结点是 $v_1$。也就是说，$13$ 的父结点是 4。
* $f(5) = 0$，原因是 $C[v_5] = C[6] = 3$ 在序列 $[1, 2, 1, 2]$ 中出现了 $0$ 次。
 * 相应地，$v_5$ 的父结点是 $v_0$。也就是说，$6$ 的父结点是 $1$。
* $f(6) = 2$，原因是 $C[v_6] = C[14] = 2$ 在序列 $[1, 2, 1, 2, 3]$ 中出现了  $2$ 次。
 * 相应地，$v_6$ 的父结点是 $v_2$。也就是说，$14$ 的父结点是 $5$。

由于我们能为 $T(1)$ 中的结点找到一个**绝妙置换**，子树 $T(1)$ 因此是一棵**绝妙子树**。

你的任务是，帮助 Árpád 确定 Ős Vezér 的每棵子树是否是绝妙的。

## 说明/提示



### 样例

#### 样例 1

考虑如下调用：

```
beechtree(4, 2, [-1, 0, 0, 0], [0, 1, 1, 2])
```

这棵树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/bcv1naft.png)

$T(1)$，$T(2)$ 和 $T(3)$ 均各自包含单独一个结点，因此都是绝妙的。
$T(0)$ 不是绝妙的。
因此，函数应当返回 $[0, 1, 1, 1]$。

#### 样例 2

考虑如下调用：

```
beechtree(18, 3, 
          [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11],
          [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3])
```

这个例子在题面中已经给出。

函数应当返回 $[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]$。

#### 样例 3

考虑如下调用：

```
beechtree(7, 2, [-1, 0, 1, 1, 0, 4, 5], [0, 1, 1, 2, 2, 1, 1])
```

该例子如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/cv6ljl13.png)

$T(0)$ 是唯一不是绝妙的子树。函数应当返回 $[0, 1, 1, 1, 1, 1, 1]$。

### 约束条件

* $3 \le N \le 200\,000$
* $2 \le M \le 200\,000$
* $0 \le P[i] \lt i$（对于所有满足 $1 \le i \lt N$ 的 $i$）
* $1 \le C[i] \le M$（对于所有满足 $1 \le i \lt N$ 的 $i$）
* $P[0] = -1$ 且 $C[0] = 0$

### 子任务

1. （9 分）$N \le 8$ 且 $M \le 500$
1. （5 分）边 $i$ 从结点 $i$ 连接到结点 $i-1$。也就是说，对所有满足 $1 \le i \lt N$ 的 $i$，都有 $P[i] = i-1$。
1. （9 分）除了结点 $0$ 以外，其他结点要么连接到结点 $0$，要么连接到某个连接到结点 $0$ 的结点。
    也就是说，对于所有满足 $1 \le i \lt N$ 的 $i$，要么有 $P[i]=0$，要么有 $P[P[i]]=0$。
1. （8 分）对于所有满足 $1 \le c \le M$ 的 $c$，至多有两条边的颜色为 $c$。
1. （14 分） $N \le 200$ 且 $M \le 500$
1. （14 分） $N \le 2\,000$ 且 $M = 2$
1. （12 分） $N \le 2\,000$
1. （17 分） $M = 2$
1. （12 分） 没有额外的约束条件。

### 评测程序示例

评测程序示例按以下格式读取输入：

* 第 $1$ 行：$N \; M$
* 第 $2$ 行：$P[0] \; P[1] \; \ldots \; P[N-1]$
* 第 $3$ 行：$C[0] \; C[1] \; \ldots \; C[N-1]$

令 $b[0], \; b[1], \; \ldots$ 表示 `beechtree` 所返回的数组中的元素。评测程序示例以如下格式，在单行中输出你的答案：
* 第 $1$ 行：$b[0] \; b[1] \; \ldots$

# 题解

## 作者：zac2010 (赞：6)

题目的“绝妙置换”定义较为复杂，我们无法直接进行转化。考虑列举出一些必要条件，从中寻找思路：

* 对于树上的一条边 $(x,y)$，其中 $x$ 为 $y$ 的父节点。那么 $x$ 在绝妙置换中的位置必定小于 $y$ 的位置。

* 对于同个颜色节点的父亲集合，在绝妙置换中必定构成了一段前缀。

  由此可以推出：$\forall v_i,v_j\in v(i<j)$，$\{c_{son_{v_i}}\}\subseteq\{c_{son_{v_j}}\}$。

  通俗的讲，就是绝妙置换中位于前面的点相对于位于后面的点，必定满足它连向儿子的边的颜色集合完全包含了后面点的颜色集合。

如果仅仅只是这样，那么你将只能拿到少量的分数，因为这根本就组不成充分条件。考虑对第二个必要条件进行一些调整——我们新引入一个概念：子树完全包含。我们称子树 $u$ 完全包含子树 $v$ 当且仅当子树 $v$ 能重叠在子树 $u$ 上。换句话说，就是在子树 $v$ 上添加一些点和边，使得子树 $v$ 能变成子树 $u$。

所以我们现在将第二个必要条件由出边颜色集合转化为了子树完全包含，不妨重写一遍：$\forall v_i,v_j\in v(i<j)$，$v_i$ 的子树完全包含 $v_j$ 的子树。必要性的证明和修改前条件二的推导过程类似。两个条件的充分性通过归纳证明不难得到。

第一个条件可以直接用一个哈希表判断；第二个条件的判断，考虑用一个 `set` 记录子树中的顺序（优先级：第一关键字为出边颜色数，第二关键字为子树大小，第三关键字为树上节点的编号大小），启发式合并时判断一下即可。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 2e5 + 10;
typedef vector<int> vc;
unordered_map<int, int> mp[N];
set<array<int, 3> > s[N]; vc ans, c, sz, e[N];
bool check(int x, int y){
    for(auto u: mp[y])
        if(!mp[x].count(u.first) || sz[mp[x][u.first]] < sz[u.second])
            return 0;
    return 1;
}
bool merge(int x, int y){
    if(s[x].size() < s[y].size()) s[x].swap(s[y]);
    for(auto u: s[y]){
        auto it = (s[x].insert(u)).first, it2 = it;
        if(it != s[x].begin())
            if(!check(get<2>(u), get<2>(*--it2))) return 0;
        if(++it != s[x].end())
            if(!check(get<2>(*it), get<2>(u))) return 0;
    }
    return 1;
}
void dfs(int u){
    s[u].insert({(int)e[u].size(), sz[u], u});
    for(const int &v: e[u]){
        if(mp[u].count(c[v])) ans[u] = 0;
        mp[u][c[v]] = v;
    }
    for(const int &v: e[u]){
        dfs(v); if(!ans[v] || !merge(u, v)) ans[u] = 0;
    }
}
vc beechtree(int n, int m, vc p, vc co){
    ans.resize(n, 1), sz.resize(n, 1), c.swap(co);
    FR(i, n - 1, 1) e[p[i]].emplace_back(i), sz[p[i]] += sz[i];
    dfs(0); return ans;
}
```


---

## 作者：yllcm (赞：5)

建议配合[官方讲题视频](https://www.youtube.com/watch?v=CqnCzSArftg)食用。

这是一道推结论题，我们尝试先寻找一些合法子树的性质，即**必要条件**，然后逐步加强限制，使得条件充分。

对于每种颜色 $c$ 单独考虑，可以发现：

* 存在子结点使得子结点到父亲的边的颜色为 $c$ 的结点为序列 $\{v_i\}$ 的一个前缀。
* 不存在一个结点，使得同时存在两个子结点，它们到父亲的边都为 $c$。

上述结论由定义立得。

第二个条件是容易判断的，下面我们默认其被满足。对第一个条件做一个转述：考虑 $\text{col}_u$ 表示 $u$ 的儿子的颜色构成的集合，那么对于任意两个节点 $u,v$，那么满足 $\text{col}_u\subseteq \text{col}_v$，要么满足 $\text{col}_v\subseteq \text{col}_u$。

那么这个条件是否充分呢？实际上，枚举可以得到满足这个条件却不合法的反例：

![](https://cdn.luogu.com.cn/upload/image_hosting/43uyzmdq.png)

可以发现，$2$ 号结点为 $\{v_i\}$ 中首个出现的颜色为 $\texttt{b}$ 的结点，其在 $\{v_i \}$ 中的编号比 $5$ 号结点小，而 $2$ 号结点没有颜色为 $\texttt{a}$ 的儿子，所以 $9$ 号结点应该接在 $2$ 号结点而非 $5$ 号结点。

所以需要加强限制。我们引入概念“子树包含”：称以 $u$ 为根的子树 $T_u$ 包含以 $v$ 为根的子树 $T_v$（$T_v\subseteq T_u$），当且仅当可以通过在 $T_v$ 上不断添加叶子使得其与 $T_u$ 同构。我们断言，子树合法当且仅当对于任意两个节点 $u,v$，要么满足 $T_u\subseteq T_v$，要么满足 $T_v\subseteq T_u$。

这样似乎非常自然：因为添加节点 $u$ 时，我们会优先将其添加到序列 $\{v_i\}$ 中编号小的结点的下面，而这恰好是子树较大的结点。下面我们分别证明其必要性和充分性：

* 必要性：假设条件不成立，我们通过模拟添加的过程证明它一定不合法。如果存在 $u,v$，使得 $T_u,T_v$ 交叉而无包含关系，不妨设 $u$ 是在 $\{v_i\}$ 中更加靠前的结点，那么在正常的加入顺序中，$u$ 的颜色 $c$ 对应的出边的终点一定比 $v$ 的颜色 $c$ 对应的出边的终点更加靠前，这是因为对于相同的颜色 $c$，我们总是选择位置最靠前的结点连接。由于 $T_v\nsubseteq T_v$，我们找到多出来的节点 $v'$，那么 $v'$ 显然应该接在 $u$ 子树中对应位置上，因为编号更小。
  * 结合上面的例子理解，$T_1$ 中多出的 $9$ 号结点，应该接在 $T_0$ 的对应位置 $2$ 上。
* 充分性：我们说明满足条件的子树一定存在对应的排列。构造排列是简单的，我们只需要根据包含关系一一加入即可。关键在于，我们需要证明不存在调整的方法使得当前加入的结点 $u$ 能接到编号更小的结点上。假设 $u$ 上的边的颜色为 $c$，等价于说明任意位置比 $\text{fa}_u$ 靠前的结点都存在颜色为 $c$ 的出边。而根据之前的分析，比 $\text{fa}_u$ 靠前的结点的 $c$ 的出边对应的子树一定完全包含 $u$ 的子树，其出现位置一定比 $u$ 靠前，所以在 $u$ 加入之前，所有的结点都被占用，所以 $u$ 只能接到 $\text{fa}_u$ 上。

综上我们证明了结论，下面是如何实现。关键在于判断子树之间的包含关系，实际上，依据 $sz_u$ 排序已经可以得到最终的序列，我们只需要判断排序后相邻的两个节点是否互相包含，而判断是否包含只需要判断 $\text{col}_u,\text{col}_v$ 的包含关系和子树大小即可，因为若子树大小关系正确，在之后的比较中我们会比较两棵子节点对应的子树是否同构，归纳可以发现其与原条件等价。

套用 set 启发式合并，复杂度为 $\mathcal{O}(n\log^2 n)$。

[code](https://loj.ac/s/1902208)

---

## 作者：ducati (赞：4)

## Description

[传送门](https://www.luogu.com.cn/problem/P9603)

## Solution

考虑绝妙子树有何性质。为方便叙述，令点 $x$ 的颜色为 $x$ 父边的颜色。

首先，对于所有点 $u$，$u$ 儿子的颜色两两不同。但这并不充分。不妨手玩一下。任取 $u = z_i, \ v = z_j (i<j)$，若 $v_0$ 是 $v$ 的儿子颜色为 $c$，则 $u$ 也有颜色为 $c$ 的儿子 $u_0$，且在 $z$ 中 $u_0$ 先于 $v_0$ 出现，可进一步考虑 $u_0, v_0$ 的关系。通过数学归纳，可得到核心结论：$S_v \subseteq S_u$。其中，$S_u, S_v$ 分别表示 $u,v$ 的子树；$S_v \subseteq S_u$ 表示，$S_u$ 存在子图 $S'_u \cong S_v$ （即 $S'_u$ 与 $S_v$ **同构**），其中 $S'_u$ 是含 $u$ 的连通块。

此时的条件是否充分呢？考虑任意一棵满足前述要求的树，可按如下方式构造 $z$：若 $S_u \subset S_v$，或 $S_u \cong S_v$ 且 $fa_u$ 在 $fa_v$ 前出现，则 $u$ 在 $v$ 前出现。按此顺序依次加入每个点，对于 $x = z_i$，令 $u = fa_x$ 且 $x$ 的颜色为 $c$，由于 $u$ 的颜色为 $c$ 的儿子刚被加入，根据偏序关系可以得到，所有在 $z$ 中先于 $u$ 的节点的颜色为 $c$ 的儿子已被加入，而后于 $u$ 的节点的颜色为 $c$ 的儿子尚未被加入，因此该构造符合绝妙子树的要求，充分性得证。

为判断所有子树是否为绝妙子树，使用 set 维护每个子树内各节点按子树大小排序的结果，合并时判断是否满足 $S_x \subseteq S_y$ 即可。更近一步的，我们可以只判断 $x$ 的儿子颜色集合 $T_x$ 是否是 $y$ 的儿子颜色集合 $T_y$ 的子集，毕竟 $x, y$ 的儿子也在对应的 set 中，而 $\subseteq$ 本质是递归定义的，因此相当于判断了 $S_x \subseteq S_y$。至于如何判断 $T_x \subseteq T_y$，暴力枚举 $x$ 的每个儿子，找到 $y$ 的同色儿子并比较，使用 map 维护即可。由于 set 的大小与子树大小同级，可以直接启发式合并，每次选取 size 较小的 set 合并到较大的 set，时间复杂度 $O(n \log^2 n)$。

## Summary
- 本题的第一个部分，在于找出充要条件，这也是最大难点，需要较强的观察和分析能力，考察先出现的节点与后出现节点的子树关系，要从子树间的同构、包含入手，难以想到。
- 本题的第二个部分在于求解答案。其中一个关键点在于，我们并不需要直接判断 $S_x \subseteq S_y$，只需判断 $T_x \subseteq T_y$ 即可。
- 本题的代码难度较低，但思维难度极高。因此 IOI 现场只有 CHN-1, CHN-2 通过。
- ~~不过，如果你有信仰，可以瞎猜几个奇怪的必要条件，虽然无法组成充分条件，但难以卡掉，本人通过这种方式获得了 $71$ 分，[提交记录](https://loj.ac/s/2000020)。~~

## Code

```cpp
#include "beechtree.h"
#include "bits/stdc++.h"
#define eb emplace_back
#define MYSET set<int, cmp>
using namespace std;
const int N = 2e5 + 5;

int n, m, fa[N], sz[N], ans[N], col[N];
struct cmp {
	bool operator() (const int x, const int y) const {
		return (sz[x] ^ sz[y]) ? (sz[x] < sz[y]) : (x < y);
	}
};MYSET nds[N];

vector<int> ansvec, Tr[N]; map<int, int> cols[N];
vector<int> beechtree(int _n, int _m, vector<int> _fa, vector<int> _col) {
	n = _n, m = _m;
	for (int i = 2; i <= n; i++) {
		fa[i] = _fa[i - 1] + 1;
		col[i] = _col[i - 1];
	}
	for (int u = 2; u <= n; u++)  Tr[fa[u]].eb(u);
	for (int u = n; u; u--) {
		sz[u] = ans[u] = 1;
		for (int v : Tr[u]) {
			cols[u][col[v]] = v;
			ans[u] &= ans[v];
			sz[u] += sz[v];
		}
		ans[u] &= (cols[u].size() == Tr[u].size());
	}
	auto Subset = [&](int x, int y) {
		if (Tr[x].size() > Tr[y].size())  return false;
		for (auto &[c, son] : cols[x]) {
			auto it = cols[y].find(c);
			if (it == cols[y].end() || sz[son] > sz[it->second])  return false;
		}
		return true;
	};
	function<bool(MYSET&, MYSET&)> Merge = [&](MYSET& a, MYSET& b) {
		if (a.size() < b.size()) {
			bool smg = Merge(b, a);
			return swap(a, b), smg;
		}
		else {
			for (int x : b) {
				auto it = a.lower_bound(x);
				if (it != a.end() && !Subset(x, *it))  return false;
				if (it != a.begin() && !Subset(*(--it), x))  return false;
			}
			for (int x : b)  a.emplace(x);
		}
		return true;
	};
	function<void(int)> dfs = [&](int u) {
		nds[u].emplace(u);
		for (int v : Tr[u]) {
			dfs(v);
			ans[u] &= ans[v];
			ans[u] &= Merge(nds[u], nds[v]);
			nds[v].clear();
		}
	};
	dfs(1);
	for (int u = 1; u <= n; u++)  ansvec.eb(ans[u]);
	return ansvec;
}
```

---

## 作者：YeahPotato (赞：3)

提供一个自己做的思路。用到的性质比其他正解弱，但更容易想。

考虑单棵树的判定。初步读题后会得到两个性质：

1. 一个点的儿子边权不能重复。
2. 设所有权为 $i$ 的边的较浅端点形成集合 $S_i$，则所有 $S_i$ 形成一个“连续包含链”的结构。或者也可以从一个点的所有儿子边权角度等价描述。

这些性质都是 beautiful subtree 的必要条件，并且对于想象力不够丰富的选手来说，难以加强至充要条件。既然必要角度不行，那考虑充分角度——同样是一个很常见的套路，我们希望找到一种排列的构造，使得对于 beautiful subtree，构造出来的排列必定是 beautiful permutation；如果不是 beautiful subtree，那就不用考虑了。于是剩余要做的就是验证一遍题意中的条件即可。

归纳易证排列中越靠前的点子树 size 越大，因此先按 size 排序；如果两棵子树 size 相同，那么也归纳易证它们同构，因此它们的相对顺序只取决于它们各自父亲的相对顺序。因此可以在按 size 排序后再扫一遍，size 相同的按父亲在序列中的位置排序。这样可以做到 $\mathrm{O}(n\log n)$ 单次判定。这些归纳易证的部分也都很直觉的。

对于原问题，一个有意思的猜想是，一棵 beautiful subtree 的子树也都是 beautiful 的。考试中当然可以直接 assert 然后交上去看看，不过这也是好证的。考虑 $T(u)$ 对应的某个 beautiful permutation $p$。对于 $v\in T(u)$，将 $p$ 中 ${}\in T(v)$ 的点对应的子序列 $p'$ 取出来，可以证明这就符合条件。因为对于某种权值的边，除去它的较深端点为 $v$ 的情况以外（$v$ 本身在 $p'$ 中不贡献给计数器，故也不用考虑），其余该权值的边的两端点要么同时在 $p'$ 中，要么同时不在 $p'$ 中。因此扔掉 $p'$ 以外的部分后，剩余的连边情况是保持不变的。

剩下的就是思想类似 [[WC2018] 即时战略](https://www.luogu.com.cn/problem/P6541) 的二分了。取出重链，在上面二分，然后往轻儿子递归。硬二分是 $\mathrm{O}(n\log^3n)$ 的（[代码](https://qoj.ac/submission/312048)），如果按全局平衡二叉树的方式带权二分，则是 $\mathrm{O}(n\log^2 n)$ 的。这是因为考虑大小为 $n$ 的树的第一轮二分，假设得到的根最浅 beautiful subtree 大小为 $s$，那么分 $\ge 2s$ 和 $<2s$ 的子树判定讨论，这轮二分的复杂度为 $\mathrm{O}(n\log n+s\log^2 n)$。接下来，剩余若干大小 $\le n/2$，和为 $n-s$ 的子问题，这样分析下来就是 $\log^2$ 的。

---

## 作者：Petit_Souris (赞：2)

神题！

显然第一步是暴力判断一棵树是否合法。但是观察到写出多项式做法就能得到很多分了，说明相当有难度。

我们发现一个最显然的条件：对于每个节点 $u$，$u$ 的儿子边颜色必须两两不同，因为连到的父亲节点是按顺序递增的，不能相同。

我们还可以发现一个强一点的性质：对于节点 $u, v$，设儿子的颜色集合为 $C_u, C_v$，那么一定有 $C_u\subseteq C_v$ 或 $C_v \subseteq C_u$。

证明也不难。实际上我们是在对于每种颜色 $c$，考虑颜色为 $c$ 的边的父亲点集，组成了序列的一个前缀。这相当于不能两个点分别有自己独有的颜色。

但是这个条件并不是充分的！这里借鉴 yllcm 的题解中的一个反例：

![](https://cdn.luogu.com.cn/upload/image_hosting/43uyzmdq.png)

这里的节点 $9$ 如果接在这里，会发生的问题就是 $b$ 对应的 $2$ 比 $5$ 早，但是 $2$ 还没有挂上 $a$ 的儿子。

这是极其具有启发性的！我们发现一个更早出现的节点，需要把对应颜色的儿子都挂上才合法，当然子树也要继续递归下去。

据此我们可以加强一下条件：对于任意两个节点 $u,v$，必须满足子树 $u$ 可变换成子树 $v$，或子树 $v$ 可变换成子树 $u$。

- 这里变换定义为，在一棵树的基础上加一个叶子节点，边的颜色任意。

证明一下条件的必要性：反证。找两个不符合条件的节点 $u,v$，$u$ 在 $v$ 前面。那么对于两个点都有的颜色 $c$，$u$ 跳一条颜色为 $c$ 的边到达的节点一定比 $v$ 对应跳到的节点靠前。找出 $v$ 多出来的节点，那么肯定得接到 $u$ 子树的对应位置上才是合法的，矛盾。

限制已经很强了。大胆猜测是充分的！看起来确实是很能构造的，只需要说明一个点接上的点不会更前就行了。如果接到了点 $x$，那么 $x$ 前面的点都已经有对应颜色的出边了，这些子树一定完全包含 $x$，那么所有可用的节点一定都被占用了。

结论推完了！我们获得了一个多项式复杂度的做法，拼上特殊性质可以拿到很多分，应该薄纱了正式赛场上的绝大多数人。

最后一步并不困难。我们发现判定的时候，只需要判断按照子树 size 从大到小的排列是否合法。这样其实就只需要看相邻的子树是否可以转换了，以及颜色集合是否正确。

显然可以 set 维护 size 的有序序列，启发式合并即可。复杂度 $\mathcal O(n\log ^2 n)$。

代码超短，神题。

```cpp
#include "beechtree.h"
#include <bits/stdc++.h>
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define pii pair<int, int>
#define rep(i, a, b) for(int i = (a); i <= (b); ++i)
#define per(i, a, b) for(int i = (a); i >= (b); --i)
#define pb push_back
const int maxN = 2e5 + 9;
Ve<pii> to[maxN];
map<int, int> mp[maxN];
multiset<pii> S[maxN];
int sz[maxN];
Ve<int> ans;
bool check(int u, int v) {
    for(auto [c, w] : mp[u]) {
        if(!mp[v].count(c)) return 0;
        if(sz[w] > sz[mp[v][c]]) return 0;
    }
    return 1;
}
bool merge(int u, int v) {
    if(S[u].size() < S[v].size()) swap(S[u], S[v]);
    for(auto [siz, w] : S[v]) {
        auto it = S[u].insert({siz, w});
        if(it != S[u].begin()) {
            if(!check((*prev(it)).second, w)) return 0;
        }
        if(next(it) != S[u].end()) {
            if(!check(w, (*next(it)).second)) return 0;
        }
    }
    multiset<pii> ().swap(S[v]);
    return 1;
}
void dfs(int u) {
    sz[u] = 1;
    for(auto [v, c] : to[u]) {
        dfs(v);
        if(!ans[v] || mp[u].count(c)) ans[u] = 0;
        mp[u][c] = v, sz[u] += sz[v];
    }
    S[u].insert({sz[u], u});
    for(auto [v, c] : to[u]) {
        if(!merge(u, v)) ans[u] = 0;
    }
}
Ve<int> beechtree(int N, int M, Ve<int> P, Ve <int> C) {
    rep(i, 1, N - 1) to[P[i]].pb({i, C[i]});
    ans = Ve<int>(N, 1);
    dfs(0);
    return ans;
}
```

---

## 作者：Leasier (赞：1)

好妙啊！！！

------------

通过样例可以发现一些比较显然的性质：

- 若 $u$ 存在一个儿子无解，则 $u$ 也无解。

因为有解时一定存在 $u$ 的绝妙置换的子序列，使得其为 $v$ 的绝妙置换。

- 若 $u$ 存在两条颜色相同的出边，则 $u$ 无解。

因为每条颜色相同的边的上端点在绝妙置换中所处位置单调递增。

------------

下面设 $S(u)$ 表示 $u$ 的出边颜色集合，$to_{u, col}$ 表示 $u$ 的颜色为 $col$ 的出边终点，若不存在则为 $-1$。

接下来是一些不那么显然的性质：

- 若有解且在一组绝妙置换中 $x$ 在 $y$ 前，则 $S(y) \subseteq S(x)$。

考虑反证法：对于一组 $x = v_i, y = v_{i + 1}$，若 $S(y)$ 中存在一种在 $x$ 的出边中未出现的颜色，则加入其终点时的 $f$ 值 $< i$，矛盾。

- 若有解且在一组绝妙置换中 $x$ 在 $y$ 前，则 $\forall z \in S(y)$，在该绝妙置换中 $to_{x, z}$ 在 $to_{y, z}$ 前。

因为加入 $to_{x, z}$ 时的 $f$ 值应当小于加入 $to_{y, z}$ 时的 $f$ 值。

------------

考虑如何来判断一棵子树十分存在绝妙置换。我们递归定义**偏相似**（下面 $x, y \neq -1$）：

- $\operatorname{similar}(-1, -1 / x) = \operatorname{true}$。
- $\operatorname{similar}(x, -1) = \operatorname{false}$。
- $\operatorname{similar}(x, y) = \operatorname{and}_{col} \operatorname{similar}(to_{x, col}, to_{y, col})$。

然后可以得到下面的性质：

- 若有解且 $size_x \leq size_y$，则 $x$ 与 $y$ 偏相似。

凭借前面的两个性质即可归纳。

注意到相似是具有传递性的，于是我们有了一个 $O(n^2 \log n)$ 算法：

- 首先判掉本文开头的两种情况。
- 对于 $u$ 子树，取出其中所有点按子树大小排序。
- 检查排序后相邻子树是否相似，若都相似则存在绝妙置换，反之不存在。

将排序那一步换成 set 启发式合并，合并时取出当前插入项的前驱后继检查即可。

时间复杂度为 $O(n \log^2 n)$。

代码：
```cpp
#include <set>
#include <map>
#include <vector>

using namespace std;

typedef struct {
	int nxt;
	int end;
	int dis;
} Edge;

int cnt = 0;
int head[200007], sz[200007], ans[200007];
Edge edge[200007];
set<pair<int, int> > s[200007];
map<int, int> mp[200007];

inline void add_edge(int start, int end, int dis){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
}

inline bool check(int u, int v){
	for (pair<int, int> i : mp[u]){
		if (!mp[v].count(i.first) || sz[i.second] > sz[mp[v][i.first]]) return false;
	}
	return true;
}

bool merge(int u, int v){
	if (s[u].size() < s[v].size()) swap(s[u], s[v]);
	for (pair<int, int> i : s[v]){
		set<pair<int, int> >::iterator it = s[u].lower_bound(i);
		if ((it != s[u].end() && !check(i.second, it->second)) || (it != s[u].begin() && !check((--it)->second, i.second))) return false;
		s[u].insert(i);
	}
	s[v].clear();
	return true;
}

void dfs(int u){
	sz[u] = 1;
	ans[u] = 1;
	for (int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		dfs(x);
		if (ans[u] == 1){
			sz[u] += sz[x];
			if (ans[x] == 0 || mp[u].count(edge[i].dis)) ans[u] = 0;
			mp[u][edge[i].dis] = x;
		}
	}
	if (ans[u] > 0){
		s[u].insert(make_pair(sz[u], u));
		for (int i = head[u]; i != 0; i = edge[i].nxt){
			if (!merge(u, edge[i].end)){
				ans[u] = 0;
				break;
			}
		}
	}
}

vector<int> beechtree(int n, int m, vector<int> p, vector<int> c){
	for (int i = 2; i <= n; i++){
		add_edge(p[i - 1] + 1, i, c[i - 1]);
	}
	dfs(1);
	return vector<int>(ans + 1, ans + n + 1);
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P9603)

**题目大意**

> 给定一棵 $n$ 个点的树，每个点有颜色。
>
> 定义一个子树是好的，当且仅当存在一个节点的排列 $p$，使得：
>
> - $p_0$ 为根
> - $p_i$ 的父亲为 $p_c$，其中 $c$ 是 $p[1,i)$ 中颜色和 $p_i$ 相同的节点个数。
>
> 求哪些子树是好的。
>
> 数据范围：$n\le 2\times 10^5$。

**思路分析**

手玩一下构造过程，首先 $p_0$ 的儿子一定是同色点中的首个出现，$p_1$ 的儿子一定是同色点中的第二个出现。

那么 $p_1$ 的儿子颜色集合一定是 $p_0$ 儿子颜色集合的子集，以此类推。

因此一棵树是好的必要条件是任意两个点儿子颜色集合有包含关系

但这个条件并不充分，因为对于 $p_0,p_1$ 的两个同色儿子 $u,v$，$u$ 在排列中必须在 $v$ 前面，从而 $u$ 儿子颜色集合必须包含 $v$ 儿子颜色集合。

那么不断递归，我们得到 $p_i$ 的子树一定包含 $p_{i+1}$ 子树，即存在一个子图等于 $p_{i+1}$ 子树。

那么我们把所有点的子树按 $\mathrm{siz}$ 排序，判断相邻两个点是否有包含关系，启发式合并维护。

注意到每次判断不需要比较子树，只要比较根的每种颜色的儿子的 $\mathrm{siz}$，因为对应子树之间的包含关系已经检验过了。

时间复杂度 $\mathcal O(n\log^2n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "beechtree.h"
#define fi first
#define se second
using namespace std;
const int MAXN=2e5+5;
int siz[MAXN];
map <int,int> G[MAXN];
set <pair<int,int>> f[MAXN];
bool ans[MAXN];
bool chk(int x,int y) {
	for(auto e:G[x]) if(!G[y].count(e.fi)||siz[e.se]>siz[G[y][e.fi]]) return false;
	return true;
}
bool merge(set<pair<int,int>>&g,set<pair<int,int>>&h) {
	if(g.size()<h.size()) g.swap(h);
	for(auto o:h) {
		auto it=g.insert(o).fi;
		if(it!=g.begin()&&!chk(prev(it)->se,o.se)) return false;
		if(next(it)!=g.end()&&!chk(o.se,next(it)->se)) return false;
	}
	return true;
}
void dfs(int u) {
	siz[u]=1;
	for(auto e:G[u]) dfs(e.se),ans[u]&=ans[e.se],siz[u]+=siz[e.se];
	if(!ans[u]) return ;
	f[u].insert({siz[u],u});
	for(auto e:G[u]) {
		if(!merge(f[u],f[e.se])) return ans[u]=false,void();
	}
}
vector<int> beechtree(int n,int m,vector<int>P,vector<int>c) {
	for(int i=0;i<n;++i) ans[i]=true;
	for(int i=1;i<n;++i) {
		if(G[P[i]].count(c[i])) ans[P[i]]=false;
		G[P[i]][c[i]]=i;
	}
	for(int i=0;i<n;++i) if(!siz[i]) dfs(i);
	return vector<int>(ans,ans+n);
}
```

---


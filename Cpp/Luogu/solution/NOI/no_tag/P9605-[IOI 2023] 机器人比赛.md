# [IOI 2023] 机器人比赛

## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。

---

由于某些技术原因，你可能需要在源代码的开头加入以下内容：

```cpp
#include <vector>

void program_pulibot();
void set_instruction(std::vector<int> S, int Z, char A);
```

## 题目描述

塞格德大学的人工智能研究人员正在举办一场机器人编程竞赛。
你的朋友 Hanga 决定参加比赛。由于著名的匈牙利牧羊犬品种 Puli 非常聪明，所以该比赛的目标定为编程实现顶级的 Pulibot。

Pulibot 将在由 $(H+2) \times (W+2)$ 网格组成的迷宫中进行测试。
网格的行从北到南编号为 $-1$ 到 $H$，网格的列从西到东编号为 $-1$ 到 $W$。
我们将位于网格的第 $r$ 行和第 $c$ 列的单元格（$-1 \le r \le H$, $-1 \le c \le W$）称为单元格 $(r,c)$。

考虑一个单元格 $(r,c)$ （$0 \le r \lt H$，$0 \le c \lt W$），和它**相邻**的有 $4$ 个单元格。

* 单元格 $(r,c-1)$ 被称为单元格 $(r,c)$ 的**西邻**；
* 单元格 $(r+1,c)$ 被称为单元格 $(r,c)$ 的**南邻**；
* 单元格 $(r,c+1)$ 被称为单元格 $(r,c)$ 的**东邻**；
* 单元格 $(r-1,c)$ 被称为单元格 $(r,c)$ 的**北邻**。

如果 $r=-1$ 或 $r=H$ 或 $c=-1$ 或 $c=W$ 成立，则单元格 $(r,c)$ 称为迷宫的**边界**。每个不是迷宫边界的单元格要么是**障碍**，要么是**空的**。
此外，每个空单元格都有一个**颜色**，由 $0$ 和 $Z_{\text{MAX}}$ 之间的非负整数表示，包括 $0$ 和 $Z_{\text{MAX}}$。最初，每个空单元格的颜色为 $0$。

例如，考虑一个迷宫，$H=4$， $W=5$， 包含一个障碍单元格 $(1,3)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/h649yqfv.png)

唯一的障碍单元格用 $\times$ 表示。迷宫的边界单元格被阴影覆盖。
每个空单元格中的数字表示它的颜色。

从单元格 $(r_0, c_0)$ 到单元格 $(r_\ell, c_\ell)$ 的长度为 $\ell$（$\ell\gt 0$）的**路径**
是一个**空**单元格序列 $(r_0,c_0), (r_1, c_1), \ldots, (r_\ell, c_\ell)$，序列中的空单元格两两不同。其中对于每个 $i$（$0\le i\lt\ell$），单元格 $(r_i, c_i)$ 和 $(r_{i+1}, c_{i+1})$ 是相邻的。

注意长度为 $\ell$ 的路径正好包含 $\ell+1$ 个单元格。

在比赛中，研究人员设置了一个迷宫，其中至少有一条从单元格 $(0,0)$ 到单元格 $(H-1, W-1)$ 的路径。注意，这意味着单元格 $(0, 0)$ 和 $(H-1, W-1)$ 保证为空。

Hanga 不知道迷宫中哪些单元格是空的，哪些单元格是障碍。

你的任务是帮助 Hanga 对 Pulibot 进行编程，使其能够在研究人员设置的未知迷宫中找到从单元格 $(0,0)$ 到单元格 $(H-1, W-1)$ 的**最短路径**（即长度最小的路径）。
Pulibot 的说明和比赛规则如下所述。 

注意，在题面的最后一部分描述了一个显示工具，该工具可以用于可视化 Pulibot。

### Pulibot 说明

对每个单元格 $(r,c)$（$-1 \le r \le H$ ，$-1 \le c \le W$），其**状态**定义为一个整数，具体如下：
* 如果单元格 $(r,c)$ 是边界，则其状态为 $-2$；
* 如果单元格 $(r,c)$ 是障碍，则其状态为 $-1$；
* 如果单元格 $(r,c)$ 是空的，那么它的状态就是单元格的颜色。

Pulibot 的程序是按一系列步骤执行的。在每一步中，Pulibot 都会识别附近单元格的状态，然后执行一条指令。它执行的指令由识别的状态决定。以下是更准确的描述。

假设在当前步骤开始时，Pulibot位于单元格 $(r,c)$，这是一个空单元格。该步骤执行如下：

1. 首先，Pulibot 识别当前**状态数组**，即数组 $S = [S[0], S[1], S[2], S[3], S[4]]$， 它包含单元格 $(r,c)$ 及其所有相邻单元格的状态：
    * $S[0]$ 表示单元格 $(r,c)$ 的状态。
    * $S[1]$ 表示西邻的状态。
    * $S[2]$ 表示南邻的状态。
    * $S[3]$ 表示东邻的状态。
    * $S[4]$ 表示北邻的状态。
1. 然后，Pulibot 确定与所识别的状态数组相对应的**指令** $(Z, A)$。
1. 最后，Pulibot 执行这条指令：它将单元格 $(r,c)$ 的颜色设置为 $Z$，然后它执行动作 $A$, $A$ 是以下动作之一：
    * **停留** 在单元格 $(r,c)$；
    * **移动** 到 $4$ 个邻居之一；
    * **终止程序**。

例如，考虑下图左侧显示的场景。Pulibot 当前位于单元格$(0,0)$，颜色为$0$。
Pulibot 识别出状态数组 $S=[0, -2, 2, 2, -2]$。Pulibot 可能有一个程序，该程序根据所识别的数组，将当前单元格的颜色设置为 $Z=1$，然后向东移动，如图的中间和右侧所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/pg2mek5q.png)

### 机器人比赛规则

* 在开始时，Pulibot 被放置在单元格 $(0,0)$ 并开始执行其程序。
* 不允许 Pulibot 移动到非空单元格。
* Pulibot 的程序必须在最多 $500\,000$ 步后终止。
* 在 Pulibot 的程序终止后，迷宫中的空单元格的着色满足以下要求：
  - 存在从 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径，路径中包括的每个单元格的颜色为 $1$。
  - 所有其他空单元格的颜色为 $0$。
* Pulibot 可以在任何空单元格终止其程序。 
  

例如，下图显示了一个可能的迷宫，其中$H=W=6$。左侧显示了初始配置，右侧显示了程序终止后空单元格的一种可以接受的着色：

![](https://cdn.luogu.com.cn/upload/image_hosting/ry81lf6s.png)

## 说明/提示

## 约束条件

$Z_{\text{MAX}} = 19$。因此，Pulibot 可以使用 0 到 19 的颜色，包含 0 和 19。

对于每个用来测试Pulibot的迷宫：
* $2 \le H, W \le 15$
* 至少有一条从单元格 $(0,0)$ 到 $(H-1, W-1)$ 的路径。

## 子任务

1. （6 分）迷宫中没有障碍单元格。
1. （10 分）$H = 2$
1. （18 分）任意两个空单元格之间恰好有一条路径。
1. （20 分）从单元格 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径的长度为 $H + W - 2$。
1. （46 分）无额外约束条件。

如果在任何测试用例中，对函数 `set_instruction` 的调用或 Pulibot 程序的执行不符合“实现细节”中所描述的限制条件，则该子任务的解决方案得分将为 $0$。

在每个子任务中，你可以通过生成几乎正确的着色来获得部分分数。

形式化地说：

* 如果空单元格的最终颜色满足机器人竞赛规则，则测试用例的解决方案是**完整**的。
* 如果最终着色如下所示，则测试用例的解决方案是**部分**的：
   - 存在一条从 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径，路径中包含的每个单元格的颜色为 $1$。
   - 网格中没有其他颜色为 $1$ 的空单元格。
   - 网格中的某些空单元格的颜色既不是 $0$ 也不是 $1$。
   

如果你对某个测试用例的解决方案既不完整也不部分，则该测试用例的得分将为 $0$。

在子任务 1-4 中，对每个测试用例来说，完整解决方案的计分为该子任务分数的 100%，部分解决方案的计分为该子任务分数的 50%。

在子任务 5 中，你的分数取决于 Pulibot 程序中所使用颜色的数量。
更准确地说，用 $Z^\star$ 表示对 `set_instruction` 进行的所有调用中 $Z$ 的最大值。
测试用例上的得分按下表计算：

| 条件            | 分数 (完整)      | 分数 (部分)       |
|:-----------------------:|:---------------------:|:---------------------:|
| $11 \le Z^\star \le 19$ | $20 + (19 - Z^\star)$ | $12 + (19 - Z^\star)$ |
| $Z^\star = 10$          | $31$                  | $23$                  |
| $Z^\star = 9$           | $34$                  | $26$                  |
| $Z^\star = 8$           | $38$                  | $29$                  |
| $Z^\star = 7$           | $42$                  | $32$                  |
| $Z^\star \le 6$         | $46$                  | $36$                  |


每个子任务的得分是该子任务中所有测试用例上计分的最小值。

## 评测程序示例

评测程序示例按照以下格式读取输入：
* 第 $1$ 行: $H \; W$
* 第 $2 + r$ 行 ($0 \le r \lt H$): $m[r][0] \; m[r][1] \; \ldots \; m[r][W-1]$

其中，$m$ 是一个 $H$ 行 $W$ 列的二维整数数组，描述迷宫中非边界单元格。
如果单元格 $(r, c)$ 是空的，$m[r][c] = 0$；如果单元格 $(r, c)$ 是障碍， $m[r][c] = 1$。



评测程序示例首先调用 `program_pulibot()`。如果评测程序示例检测到违反规则的行为，则会打印 `Protocol Violation: <MSG>` 并终止，其中 `<MSG>` 是以下错误消息之一：

* `Invalid array`：$-2 \le S[i] \le Z_{\text{MAX}}$ 对某些 $i$ 不成立或者 $S$ 的长度不是 $5$。
* `Invalid color`：$0 \le Z \le Z_{\text{MAX}}$ 不成立。
* `Invalid action`：字符 $A$ 不是 `H`, `W`, `S`, `E`, `N` 或 `T`。
* `Same state array`：用相同的 $S$ 调用 `set_instruction` 两次或以上。

否则，当 `program_pulibot` 完成时，评测程序示例将在输入所描述的迷宫中执行 Pulibot 的程序。

评测程序示例产生两个输出。首先，评测程序示例将 Pulibot 动作记录写入工作目录中的文件 `robot.bin` 。
该文件用作下一节中描述的可视化工具的输入。

其次，如果 Pulibot 的程序未成功终止，评测程序示例将打印以下错误消息之一：

* `Unexpected state`：Pulibot 识别出一个无法调用“set_instruction”的状态数组。
* `Invalid move`：执行一个动作，导致 Pulibot 移动到一个非空单元格。
* `Too many steps`：Pulibot 执行了 $500\,000$ 步没有终止程序。

否则，令 $e[r][c]$ 为 Pulibot 程序终止后单元格 $(r, c)$ 的状态。
评测程序示例按以下格式打印 $H$ 行：
* 第 $1 + r$ 行 ($0 \le r \lt H$)：$e[r][0] \; e[r][1] \; \ldots \; e[r][W-1]$

## 显示工具

此任务的附件包含有一个名为 `display.py` 的文件。
调用时，此 Python 脚本会显示 Pulibot 在由评测程序示例的输入所描述的迷宫中的操作。
为此，工作目录中要有二进制文件 `robot.bin`。

要调用该脚本，请执行以下命令。

```
python3 display.py
```

一个简单的图形界面将会出现，主要特性如下：

* 你可以观察整个迷宫的状态。 Pulibot 的当前位置以矩形突出显示。
* 你可以通过单击箭头按钮或按热键来浏览 Pulibot 的步骤。 你还可以跳转到特定步骤。
* Pulibot 程序中即将进行的步骤显示在底部。
它显示当前状态数组及将要执行的指令。
在最后一步之后，它或者会显示评测程序的错误消息之一，或者在程序成功终止时显示 `Terminated`。
* 对于代表颜色的每个数字，你可以指定视觉背景颜色以及显示的文本。 显示的文本是一个短字符串，应出现在每个具有那个颜色的单元格。你可以通过以下任一方式指定背景颜色和显示的文本：
   - 单击 `Colors` 按钮后在对话框窗口中设置它们。
   - 编辑 `colors.txt` 文件的内容。
* 要重新加载 `robot.bin`，请使用 `Reload` 按钮。 这可以用来处理 `robot.bin` 的内容发生更改的情况。

# 题解

## 作者：璀璨星空1 (赞：14)

> 如溪水潺潺淌过古街　带走了如梦般的时节  
> 小桥上人潮络绎不绝　牵引我思绪层出不迭

我们的程序将分两个阶段进行。在第一阶段中，我们从 $(0,0)$ 出发走到 $(n-1,m-1)$，找到并标明一条从 $(0,0)$ 到 $(n-1,m-1)$ 的最短路；在第二阶段中，我们从 $(n-1,m-1)$ 出发走回 $(0,0)$，在回溯的过程中将所有不在最短路上的格子的标记清零。

## 第一阶段：标明一条从 $(0,0)$ 到 $(n-1,m-1)$ 的最短路。

我们先思考 $\text{subtask 3}$，即一棵树的情形。我们从 $(0,0)$ 开始 DFS。设当前 DFS 到 $(x,y)$，我们需要枚举 $4$ 个方向，并依次扩展那些 $=0$ 并且不同于来时的路的方向。我们有两种选择：

- 用一个 $(x,y)$ 的颜色 $c(x,y)$ 记录当前扩展到了哪个方向，每次访问到 $(x,y)$ 就将 $c(x,y)$ 增加 $1$；
- 每当 DFS 完一个 $(x,y)$ 没找到通向 $(n-1,m-1)$ 的路，就将 $c(x,y)$ 改成 $2$，表示将 $(x,y)$ 这个格子堵住。

可以看出，采用第一种选择将大大增加所用的颜色个数。所以我们倾向于采用第二种选择。在 $\text{subtask }4,5$ 中我们继续沿用第二种选择：当 DFS 完 $(x,y)$ 的某个儿子 $(x',y')$ 时，就将 $c(x',y')$ 改成某种特殊的标记，表示以 $(x',y')$ 为根的 DFS 已经结束。

再思考 $\text{subtask 4}$。$\text{subtask 4}$ 保证了最短路 $=n+m-2$，也就是说我们只会向右走或向下走。相比于 $\text{subtask 5}$，$\text{subtask }3,4$ 的简单之处在于我们只需要找到某一条从 $(0,0)$ 到 $(n-1,m-1)$ 的路径，这条路径便自然是最短路。

如果采用第二种选择的话，我们沿用 $\text{subtask 3}$ 的 DFS 就可以直接解决 $\text{subtask 4}$。可以获得 $35$ 分。

------

有了 $\text{subtask }3,4$ 的提示，我们再来思考 $\text{subtask 5}$。要求从 $(0,0)$ 到 $(n-1,m-1)$ 的路径最短，我们非常希望 BFS 而不是 DFS。但是由于 Pulibot 的视角是局部的，它天然更适合 DFS 而不是 BFS。

所以我们采用类似迭代加深的办法。我们一轮一轮扩展，在第 $i$ 轮标记所有 $\text{dis}(x,y)=i$ 的 $(x,y)$。我们会遇到一个重要的问题：

- 在第 $i$ 轮开始的时候，与 $=0$ 的 $(x',y')$ 接触的 $(x,y)$ 一定是 $\text{dis}=i-1$ 的。但是给 $(x',y')$ 做了标记以后，$(x',y')$ 这个格子就与外界接触了。怎么防止 $\text{dis}=i$ 的 $(x',y')$ 继续扩展下去，导致 $\text{dis}\geq i+1$ 的格子在第 $i$ 轮就被标记呢？

考虑 BFS 树。我们每次扩展一层叶子。我们用 $4$ 个方向 $\leftarrow,\downarrow,\rightarrow,\uparrow$ 记录一个 $(x,y)$ 在 BFS 树上的父亲，在遍历 BFS 树的时候，我们只能沿着父亲到儿子的方向走。这样我们便不可能沿不同的路径多次访问到同一个 $(x,y)$。再加上 $0,1,2$ 这 $3$ 种颜色，总共是 $7$ 种标记：

![](https://cdn.luogu.com.cn/upload/image_hosting/jmqwdc2g.png)

------

> 若不识梁祝变成蝴蝶　驾紫烟穿过天上宫阙  
> 绝不知人间多愁离别　吹落叶散作秋风清切

现在我们设计 DFS 的具体流程。在第 $i$ 轮，我们沿着 BFS 树的第 $0$ 到 $i-1$ 层进行 DFS，扩展出它的第 $i$ 层。设当前 DFS 到了 $(x,y)$，那么从 $(0,0)$ 到 $(x,y)$ 路径上的所有格子都 $=2$。$(x,y)$ 的 $4$ 个邻居中一定有一个 $=2$，那是 $(x,y)$ 的父亲 $\text{Fa}(x,y)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/hrnqxzfg.png)

如果 $(x,y)$ 的其他 $3$ 个邻居中有指向 $(x,y)$ 的箭头，则说明 $(x,y)$ 不是叶子。我们按西、南、东、北的顺序找到第一个指向 $(x,y)$ 的 $(x',y')$，走到 $(x',y')$，然后将 $c(x',y')$ 改成 $2$，从 $(x',y')$ 出发继续 DFS。

如果 $(x,y)$ 的其他 $3$ 个邻居中没有指向 $(x,y)$ 的箭头，则说明 $(x,y)$ 是叶子。我们需要将 $(x,y)$ 所有 $=0$ 的邻居 $(x',y')$ 指向 $(x,y)$，然后立刻回溯。我们先将 $c(x,y)$ 改成 $1$。当 Pulibot 站在一个 $1$ 上时，它会按西、南、东、北的顺序找到第一个 $=0$ 的 $(x',y')$，走到 $(x',y')$，然后将 $(x',y')$ 指向 $(x,y)$ 并走回 $(x,y)$；如果 $4$ 个邻居中已经没有 $0$ 了，说明 $(x,y)$ 的子树已经扩展完了，我们将 $c(x,y)$ 改成 $0$，并返回 $\text{Fa}(x,y)$，标示从 $\text{Fa}(x,y)$ 到 $(x,y)$ 这条路已经扩展完了。

当 $(x,y)$ 的子树扩展完了的时候，我们选择将 $c(x,y)$ 改成 $0$ 作为特殊的标记。这样做是很方便的：当 $\text{Fa}(x,y)$ 的儿子都扩展完了之后，$\text{Fa}(x,y)$ 的周围一圈都是 $0$，然后 $\text{Fa}(x,y)$ 就会变成 $1$ 并且将周围的 $0$ 都重新指回 $\text{Fa}(x,y)$，最后 $c\big(\text{Fa}(x,y)\big)$ 再从 $1$ 变成 $0$。

最后当 $c(0,0)=1$ 并且 $(0,0)$ 的 $4$ 个邻居都 $\neq0$ 的时候，就意味着第 $i$ 轮已经结束了。我们将 $c(0,0)$ 改成 $2$，从此开启第 $i+1$ 轮。

------

整理前述的所有东西，我们得到了一个初步的做法：

- 如果 $c(x,y)=0$：
  - 如果 $(x,y)=(0,0)$，则将 $c(x,y)$ 改成 $1$ 并停在原地；
  - 否则检查 $(x,y)$ 的 $4$ 个邻居。若邻居中有 $1$，则按西、南、东、北的顺序找到第一个 $1$，将 $(x,y)$ 指向那个 $1$ 并走过去。
- 如果 $c(x,y)=1$：
  - 检查 $(x,y)$ 的 $4$ 个邻居。若邻居中有 $0$，则按西、南、东、北的顺序找到第一个 $0$，直接走过去；
  - 否则如果 $(x,y)=(0,0)$，则将 $c(x,y)$ 改成 $2$ 并停在原地；
  - 否则检查 $(x,y)$ 的 $4$ 个邻居。若邻居中有 $2$，则按西、南、东、北的顺序找到第一个 $2$，将 $c(x,y)$ 改成 $0$ 并走过去。
- 如果 $c(x,y)=2$：
  - 检查 $(x,y)$ 的 $4$ 个邻居。若邻居中有指向 $(x,y)$ 的 $(x',y')$，则按西、南、东、北的顺序找到第一个 $(x',y')$，直接走过去；
  - 否则将 $c(x,y)$ 改成 $1$ 并停在原地。
- 如果 $c(x,y)\in[3,6]$，则将 $c(x,y)$ 改成 $2$ 并停在原地。

最后，我们将会到达下图所示的局面。直接沿着标明的最短路返回并将路径上的 $2$ 都改成 $1$，可以获得 $71$ 分。

![](https://cdn.luogu.com.cn/upload/image_hosting/kwnh1d81.png)

## 第二阶段：回溯清理所有不在最短路上的格子的标记。

最后我们再考虑回溯清理的问题。当 Pulibot 走到了 $(n-1,m-1)$ 并且 $c(n-1,m-1)\in[3,6]$ 时，意味着已经找到并标明了一条从 $(0,0)$ 到 $(n-1,m-1)$ 的最短路，应该开始回溯清理了。我们的目标是到达下图所示的局面：

![](https://cdn.luogu.com.cn/upload/image_hosting/dts77iuv.png)

我们要干的事是将一棵树删空。当我们访问到一个结点 $u$ 的时候，我们先依次访问 $u$ 的所有儿子 $v_i$ 并将 $v_i$ 的子树删空，然后再删掉 $u$ 并回到 $\text{Fa}(u)$，继续删除 $\text{Fa}(u)$ 其他儿子的子树。用 $\text{2D grid}$ 的语言，我们从 $(n-1,m-1)$ 倒着走回 $(0,0)$，将一路上所有的 $2$ 改成 $1$。当一个 $(x,y)$ 被从 $2$ 改成 $1$ 时，我们开始清理 $(x,y)$ 的子树。当 Pulibot 站在一个 $1$ 或者一个箭头上时，如果 $(x,y)$ 的儿子已经都变成了 $0$，那么就将 $(x,y)$ 也改成 $0$ 并走回 $\text{Fa}(x,y)$；如果 $(x,y)$ 的儿子中还有指向 $(x,y)$ 的箭头 $(x',y')$，那么直接走到 $(x',y')$。

有一个细节问题在于如果最短路上的一个 $2$ 有一些儿子已经变成了 $0$，那么需要重新把这些 $0$ 指向这个 $2$ 才能继续进行下去。好在之前的所有讨论中都不会出现 Pulibot 站在一个 $0$ 上而 $4$ 个邻居中有 $2$ 的情况，所以直接让 Pulibot 走到这个 $0$ 并将这个 $0$ 指向那个 $2$ 即可。

代码实现：[https://loj.ac/s/1880747](https://loj.ac/s/1880747)。可以获得 $100$ 分。

---

## 作者：tribool4_in (赞：3)

很人类智慧的一道题！

[IOI 2023 Robot Contest in Z* = 5 - Codeforces ](https://codeforces.com/blog/entry/120252) 给出了一种 $Z^\star=5$ 的构造。其中除了 $0$ 表示的空白以及 $1$ 表示的路径以外，$2-5$ 分别表示四个方向的箭头。

考虑分为两个阶段，第一个阶段通过 bfs 来找到最短路径；第二个阶段顺着搜索树回溯并将最短路径染色，其余清除。

## 一

由于机器人只能得知周围情况，只能进行 dfs，于是考虑迭代加深搜索，每次通过 dfs 扩展一层直到找到终点。

判断是否在左上角或右下角是容易的，只需看对应位置是否为边界且自己是否为空白即可。首先在左上角随意染上一个右或下的箭头并走过去。然后分情况判断：

- 当前位置为空白：此时扩展到了新的一层的一个节点，在四周找到指向它的位置（即父亲），**指向父亲**并走过去（回溯）；
- 当前位置有箭头：容易发现此时当前位置指向的位置上的箭头一定指向自己（这是区分一、二阶段的条件）。此时需要换一个子树继续递归，于是逆时针（或顺时针）旋转直到找到一个位置为空白或指向自己，然后指向它并走过去。

当回到左上角并且指向初始方向时即完成了一轮，扩展了一层。此时还会继续递归下去。

观察这个过程，发现当到达一个新的有染色节点时，该节点的箭头初始指向父亲，逆时针旋转过程中则会依次指向各个子树递归，递归结束重新指向并走向父亲则相当于回溯。这个过程每一轮显然只会经过每个子树一次，因此完美的进行了扩展。

### 二

当机器人走到右下角时，首先随便指向右或下防止判断错误。此时箭头形成了一个以右下角为根的树，左上角到右下角的链即为最短路径。

在第二阶段中，不应改变箭头的方向，此时任何一个位置指向的位置上的箭头**一定不指向自己**（因为这是一棵树）。

考虑通过 dfs 遍历整棵树并将错误的叶子消去。对于当前位置，如果周围存在一个位置指向它（即其子树），则直接走过去，否则进行一次判断将其标为 $0$ 还是 $1$。发现如果当前位置不是左上角并且周围没有染成 $1$ 的，则其一定为 $0$，否则标为 $1$。然后走向当前位置染色前指向的方向。

发现这个过程会先消去一些子树并回到左上角，然后会从根开始沿着正确路径染色。如果还有没清除的子树，在这个过程中会被清除。且由于父亲已经染成 $1$ 了，不会回到父亲。

----

文字描述可能比较抽象，可以把代码复制到本地跑一跑模拟观察一下喵。

放两张 Codeforces 上的图，分别是第一阶段和第二阶段（多截了一点）：

![](https://codeforces.com/predownloaded/2e/31/2e31053b817cc7254c9c2e02000080c0103add44.webp)

![](https://codeforces.com/predownloaded/41/b6/41b64db2d9f9ed9a2935448229df4de66dd24d26.webp)

代码：

```cpp
// #include "robot.h"

#include <bits/stdc++.h>

void program_pulibot();
void set_instruction(vector<int> S, int Z, char A);

using namespace std;
enum Stat {
    Border = -2,
    Block,
    Empty,
    Path,
    West,
    South,
    East,
    North,
    Failed
};
char dirch[6] = {'H', '?', 'W', 'S', 'E', 'N'};
#define isdir(sta) (2 <= (sta) && (sta) <= 5)
#define oppo(sta) ((sta) % 4 + 2)
pair<int, char> calc(vector<int> S) {
    int h = S[Empty], w = S[West - 1], s = S[South - 1], e = S[East - 1], n = S[North - 1];
    if (h == Empty) {
        if (w == Border && n == Border) {  // 左上角初始染色
            if (s == Block) return {East, dirch[East]};
            else return {South, dirch[South]};
        } else if (e == Border && s == Border) {  // 到达右下角，第一阶段结束
            return {East, 'H'};
        }
        for (int i = 2; i <= 5; i++)  // 找到父亲并回溯
            if (S[i - 1] == oppo(i)) return {i, dirch[i]};
        return {Failed, 'H'};
    } else if (isdir(h)) {
        if (S[h - 1] == oppo(h)) {
            int p = (h - 1) % 4 + 2;
            while (p != h) {  // 找寻子树 / 回溯父亲
                if (S[p - 1] == Empty || S[p - 1] == oppo(p)) return {p, dirch[p]};
                p = (p - 1) % 4 + 2;
            }
            return {h, dirch[h]};
        } else {  // Stage 2
            int p = 2;
            bool ispath = (w == Border && n == Border);
            do {
                if (S[p - 1] == oppo(p)) return {h, dirch[p]};
                ispath |= (S[p - 1] == Path);
                p = (p - 1) % 4 + 2;
            } while (p != 2);
            if (e == Border && s == Border) return {Path, 'T'};
            else if (isdir(h)) return {ispath ? Path : Empty, dirch[h]};
            else return {Failed, 'H'};
        }
    } else {
        return {Failed, 'H'};
    }
}
void dfs(vector<int> S) {
    if (S.size() == 5) {
        auto [Z, A] = calc(S);
        if (string("HWSENT").find_first_of(A) == string::npos) {
            for (auto v : S) cerr << v << ' ';
            cerr << A << '\n';
        }
        set_instruction(S, Z, A);
        return;
    }
    for (int i = Border; i < Failed; i++) {
        S.push_back(i);
        dfs(S);
        S.pop_back();
    }
}
void program_pulibot() {
    dfs({});
}
```

---

## 作者：liuzhenhao09 (赞：2)

本文主要是对[这篇题解](https://www.luogu.com.cn/article/sel2w1d6)的补充说明，也包含了自己的理解。

## 大体思路

WC 讲的题，感觉是很有启发性的题。

下文叙述的是 $Z^\star = 5$ 的做法。

染色方法为除了 $0,1$ 以外，$2,3,4,5$ 分别表示上下左右。

首先我们大概发现我们的探索是分为两部分。

首先是我们要探索出一条从左上到右下的路径，其次我们要删去无关点并染色路径。

我们考虑搞出一个连接左上和右下的有向树，根节点是右下角，结点颜色是每个点往右下角扩展的时候走的方向，这就是第一部分。这部分可以类比迭代加深 DFS。

而第二部分则是通过跳父亲节点实现的。具体而言，我们会观察这个点是否还有子树可以走，有则递归，没有则判断目前点颜色。这部分可以类比普通 DFS。

## 具体实现

### 第一部分

目标：走到右下角。

判断目标是简单的，直接通过判墙体即可。

我们的染色方法是**以目前节点为根画出目前已经扩展的点的树，每个点指向自己的父亲**。特别地，目前节点指向上一轮它往哪里走了。

接下来考虑如何通过四周信息判断要去哪里。

如果目前的点为空点，那么我们需要扩展当前点并且回溯到它来时的路。根据染色方法的定义，它一定会从唯一一个指向它的点走来，我们走回去就行了。

如果目前的点有颜色，则说明这条路已经走过了，我们转向。这里逆时针顺时针无所谓。转向直到转到一个空点或是指向我们的点。即表示我们要去探索那里或者那里是我来时的路。此时走过去即可。

注意，如果转到的点指向的不是你，则代表这个点可能是从旁边绕弯才绕到那里的，我们不能向那里走。

每个点的选择就只有上下左右了，走一圈一定会回溯回来，每轮扩展至少多扩展一个点，不会陷入死循环的问题。

最后直到走到右下角结束即可，右下角随便往右或往下指。由于我们每轮扩展的点到左上角距离一样（即迭代加深），所以可以保证第一次走到右下角一定是最短路。

插个图。

![](https://codeforces.com/predownloaded/2e/31/2e31053b817cc7254c9c2e02000080c0103add44.webp)

### 第二部分

**第二部分我们不改变箭头方向，即不改变树的结构，只进行染色，一旦染色之后这个点就再也不会被访问了。**

每个点判断被染色的前提是，这个点的所有子树都被判断完了，此时这个点若不是起点的话，则它必然会有一个儿子的颜色被标为了 $1$。否则这个节点就不能被染色。

这就好比在一棵树上 DFS。给定起始节点，让你遍历整棵树并将起始节点到根节点的点染黑，其余点染白。这部分是简单的。

最后一个问题，我们如何判断目前是第一还是第二阶段。容易发现在第二阶段中，由于箭头方向不变，目前的位置指向的点一定不会指向自己，这就是判断的依据。

插个图。

![](https://codeforces.com/predownloaded/41/b6/41b64db2d9f9ed9a2935448229df4de66dd24d26.webp)

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
void program_pulibot();
void set_instruction(vector<int> S, int Z, char A);
vector<int>S;
#define LL 2
#define DD 3
#define RR 4
#define UU 5
char mp[6] = {'H','*','W','S','E','N'};
pair<int,char> calc(vector<int>S){
	int tmp = S[0],L = S[1],D = S[2],R = S[3],U = S[4];
	int col;
	char dir;
	//枚举状态 
	if(!tmp){ //第一阶段，目前节点为空 
		if(L == -2 && U == -2){ //左上角 
			if(R != -1) return {RR,'E'};
			else return {DD,'S'};
		}
		else if(R == -2 && D == -2) return {RR,'H'}; //右下角，随便选一个方向，然后到第二阶段 
		for(int i = 2; i <= 5; i++) if(S[i - 1] == i % 4 + 2) return {i,mp[i]}; //第一阶段，往回走 
		return {0,'T'};
	}
	else if(tmp >= 2 && tmp <= 5){
		if(S[tmp - 1] == tmp % 4 + 2){ //第一阶段 
			int p = (tmp - 1) % 4 + 2; //旋转 
			while(p != tmp){
				if(!S[p - 1] || S[p - 1] == p % 4 + 2) return {p,mp[p]};
				p = (p - 1) % 4 + 2; 
			} 
			return {tmp,mp[tmp]}; //回溯 
		}
		else{
			int p = 2;
			bool col = 0;
			if(L == -2 && U == -2) col = 1;
			do{ //旋转 + 判断这个点是不是答案路径上的点 
				if(S[p - 1] == p % 4 + 2) return {tmp,mp[p]};
				col |= (S[p - 1] == 1);
				p = (p - 1) % 4 + 2;
			}
			while(p != 2);
			if(R == -2 && D == -2) return {1,'T'};
			else if(tmp >= 2 && tmp <= 5) return {col,mp[tmp]};
			else return {0,'T'};
		}
	}
	else return {0,'T'};
}
void program_pulibot(){
	for(int a = -2; a <= 5; a++){
	for(int b = -2; b <= 5; b++){
	for(int c = -2; c <= 5; c++){
	for(int d = -2; d <= 5; d++){
	for(int e = -2; e <= 5; e++){
		vector<int>S;
		S.push_back(a),S.push_back(b),S.push_back(c),S.push_back(d),S.push_back(e);
		pair<int,char>res = calc(S);
		set_instruction(S,res.first,res.second);
	}	
	}	
	}	
	}
	}
}
```

---

## 作者：denominator (赞：1)

**upd**：因为眼瞎，逆时针写成了顺时针，已改。

> [原题](https://www.luogu.com.cn/problem/P9605)
>
> - **本题下标从 0 开始**。
> - 构造一个在 $n\times m$ 的矩阵上运行的机器，接受：
> 	- 当前位置与四周位置上的数（初始为 $0$，障碍为 $-1$，越界为 $-2$），
> - 返回：
> 	- 把当前位置上的数改成的值；
> 	- 下一步的操作，包括：
> 		- 向上 / 下 / 左 / 右走；
> 		- 停止程序；
> 		- 站着不动，
> - 使得它可以用 $1$ 标记处从 $(0,0)$ 到 $(n-1,m-1)$ 的任意一条最短路，不经过障碍，其余位置均为 $0$。

---

一道有趣题，自 IOI 2023 Day 2 开始时，我就对这题有了兴致，但做起来就不那么有趣了。

讲个笑话，我做这题用了虚拟机 NOI Linux 2.0，因为上面装了 Python 可以打开 `display.py`，但编译需要 `PySide6`，结果安装时显示空间爆了。下个 Python 安装包又死慢的，最后索性不用了。

下面进入正题。

CF 上的一篇 [博客](https://codeforces.com/blog/entry/120252) 上介绍了这题 $Z^\star=5$ 的方法，吊打了标算。~~别问我是怎么知道的，问就是 WC 上讲的~~。我用了两天时间完成这道题，成功成为洛谷上本题第 20 个 AC 者（其实 LOJ 上也是）。

这种方法也和 [另一种题解](https://www.luogu.com.cn/blog/stella-noi/P9605) 方法一样，分为两个阶段。

1. 找到一条从 $(0,0)$ 到 $(n-1,m-1)$ 的最短路；
2. 将这条最短路标为 $1$，并重置不在最短路上的标记。

省下的这一种颜色主要位于阶段 1。看看它怎么省下的吧！

## Part \#1 找到最短路

同样是使用迭代加深的方法，我们如何省下这一种颜色呢？

事实上，上面题解的做法将搜索过的路径用 $2$ 来表示，当前搜索的结点用 $1$ 表示，而 $0$ 则清除了当前搜索的状态。我们可以换一种思路，用箭头表示行进方向，同时我们不用 $0$ 来清除状态，而是始终把它指向 BFS 树上的父亲。如图。

（都说了没有 `display.py` 了，所以只能搞成这样了。如果有时间搞成图）

```plain
 2  2  2 (2) <  <
 0  < -1 -1  ^  <
 ^ -1  >  >  ^  <
 ^ -1  ^  ^ -1 -1
 ^  < -1  ^  <  0
 ^  < -1  ^  0  0

 >  >  > (<) <  <
 ^  < -1 -1  ^  <
 ^ -1  >  >  ^  <
 ^ -1  ^  ^ -1 -1
 ^  < -1  ^  <  0
 ^  < -1  ^  0  0
```

（括号指当前所在的位置）

对于一个位置，逆时针旋转，直到第一个它能走的位置。以上的示例不太好，我们换为下面（第二行第二列指针方向不一样，是因为搜索顺序）：

```plain
 >  >  >  >  v  <
 ^  ^ -1 -1  v  <
 ^ -1  > (>) <  <
 ^ -1  ^  ^ -1 -1
 ^  < -1  ^  0  0
 ^  < -1  0  0  0
```

逆时针旋转一次后，指向了障碍，走不了了，就再转一步：

```plain
 >  >  >  >  v  <
 ^  ^ -1 -1  v  <
 ^ -1 (>) <  <  <
 ^ -1  ^  ^ -1 -1
 ^  < -1  ^  0  0
 ^  < -1  0  0  0
```

现在括号所在结点指向原来结点，这说明这是原结点的子结点，因此我们指向它（表示这是现在所行进的路线）。

接下来我们再模拟一步。

```plain
 >  >  >  >  v  <
 ^  ^ -1 -1  v  <
 ^ -1  v  <  <  <
 ^ -1 (^) ^ -1 -1
 ^  < -1  ^  0  0
 ^  < -1  0  0  0
```

注意这个结点！它转两次均遇到了 `-1`，再次旋转得到的是向上的箭头，并不是指向它的，所以我们不能走。

最后它转回了原样，有个指针指向它。其实我们并不需要知道这个指针是子结点还是父结点，**在往下走的时候，括号上方的结点已经把自己（临时地）当成了下一个结点的子结点**。这是这种做法中最精巧的部分。它虽然看似走向了子结点，实际上就是回溯。

如果遇到未开辟的结点呢？我们快进。

```plain
 >  >  >  >  v  <
 ^  ^ -1 -1  v  <
 ^ -1  >  v  <  <
 ^ -1  ^  v -1 -1
 ^  < -1 (^) 0  0
 ^  < -1  0  0  0
```

这时指向它并往下走一步，把 `0` 开辟，指针指向父亲（唯一一个指向它的指针）。

```plain
 >  >  >  >  v  <
 ^  ^ -1 -1  v  <
 ^ -1  >  v  <  <
 ^ -1  ^  v -1 -1
 ^  < -1  v  0  0
 ^  < -1 (0) 0  0
 
 >  >  >  >  v  <
 ^  ^ -1 -1  v  <
 ^ -1  >  v  <  <
 ^ -1  ^  v -1 -1
 ^  < -1 (v) 0  0
 ^  < -1  ^  0  0
```

注意对于起点（左、上均为边界），进行特判：指针初始指向右边并向右走（如果右边有障碍就往下走）。

注意对于终点（右、下均为边界），进行特判：指针初始指向右边（之后会解释为什么），回退，进入阶段 2。

## Part \#2 标记最短路

```plain
 >  >  >  >  v  <
 ^  ^ -1 -1  v  <
 ^ -1  >  v  <  <
 ^ -1  ^  v -1 -1
 ^  < -1  v  <  <
 ^  < -1  > (>) >
```

以上是我的程序搜到最短路时的局面。

以前我们都以起点为根，现在我们以终点为根。

将每个点与其指针指向的位置连边，显然它是一棵树，且所有指针都指向终点方向。

> **证明**：先证树。使用结论：一张有 $n$ 个结点 $n-1$ 条边的连通图是树。
> - 有 $n-1$ 条边。
> 	
> 	每个结点都有指向的位置，但显然这个位置不是 $0$，因为不会有一个点是空白点的子结点——这个空白点并没搜到。但是，我们钦定终点指向外面，所以终点没有一条对应的边。
> 	
> 	因此，设有 $n$ 个结点，则有 $n-1$ 条边。
> - 连通。
> 	
> 	若不连通，设有两个连通块，其中一个是起点，则无法从起点到达连通块内的点。
> 	
> 再证所有结点指向终点方向。
>
> 最短路上的点显然指向终点方向，而其余结点表示自己是其指向结点的子结点，最终指向最短路上一个点的方向。
> 
> 也即，对于不在最短路上的结点 $u$，在定向后，存在最短路上的结点 $v$，使得存在路径（设 $t$ 是终点）：
>
> $$u\leadsto v\leadsto t$$
>
> $u$ 就指向 $t$ 的方向。$\square$
>
> 如果以上证明有误，或有更简单的方法，请在评论区告诉我。

如果以 $t$ 为根，问题就变得简单了。我们要求把一棵树上路径 $s\leadsto t$ 经过的点标记，而取消其他点的标记。如果你用编程语言做这道题，你会怎么写？以下是伪代码：

```plain
function DFS (u)
    if u = s then
        b[u] ← true
    end if
    for v ∈ Sons[u] do  ▹ Sons[v] 是 v 的子结点组成的集合
        DFS (v)
        if b[v] then
            b[v] ← true
        end if
    end for
    b[v] ← false
end function

function Main (s, t)
    DFS (t)
    return b
end function
```

（第一次写伪代码，不知道是不是这么写的 qwq）

我们采用同样的方法：

- 若有指向当前结点的指针，说明它还有子结点没有 DFS 完，因此我们先不对指针方向进行修改，直接走向这个子结点；
- 否则，DFS 已经完成。
	- 若此结点为起点，设为 $1$；
    - 否则：
    	- 若周围有 $1$，则一个孩子有 $1$，仿照上面的伪代码，将它设为 $1$；
        - 否则，仿照伪代码，设为 $0$。
        
这个方法已经足够我们完成任务了！

```plain
 1  1  1  1  1  0
 0  0 -1 -1  1  0
 0 -1  0  1  1  0
 0 -1  0  1 -1 -1
 0  0 -1  1  0  0
 0  0 -1  1  1 (1)
```

## Part \#3 实现细节

如何判断我们在进行阶段 1 还是阶段 2？

站在 Pulibot 的角度，假如有以下两个阶段：

```plain
   v          v
> (>) <    > (>) >
   ^          ^
Stage 1    Stage 2
```

可以看到，左图中指针指向的结点是指向自己的，这说明图还没有成为树，因此是阶段 1 的；右图中指针指向的结点没有指向自己，这说明它不是由阶段 1 回溯后回到的原来结点，这个指针也不能向右移动（由 Part \#1 处的分析），所以在阶段 1 中是不会出现的。因此，此图位于阶段 2。

由此我们需要注意，在实现阶段 1 和阶段 2 的使用，应当严加注意是否有相同状态执行不同操作的情况。

比起原做法，我认为这种做法更好想一些（？），但是状态重的情况和状态的判断比原做法更烦，且部分的解法与完全的解法等难。（原做法把 $2$ 改成 $1$ 就能得到部分的分数）。

# Part \#4 代码

两个阶段不是同一天写的，码风不太一样。

写了一些没用的特判，所以比较长，不要被吓到了。

```cpp
/* colors.txt:
#ffffff 0
#005ca5 1
#005500 <
#005500 v
#005500 >
#005500 ^
*/
// W S E N
// 2 3 4 5
//   N
// W   E
//   S
#include <bits/stdc++.h>
using namespace std;
void set_instruction (vector <int>, int, char); // 在洛谷上提交时
// #include "robot.h"                              不在洛谷上提交时
char op[6] = " WSEN";
void program_pulibot () {
	// Stage 1

	// 对起点的特判
	set_instruction ({0, -2, -1, 0, -2}, 4, 'E');
	set_instruction ({0, -2, 0, -1, -2}, 3, 'S');
	set_instruction ({0, -2, 0, 0, -2}, 4, 'E');
	set_instruction ({4, -2, -1, 2, -2}, 4, 'E');
	set_instruction ({3, -2, 5, -1, -2}, 3, 'S');
	set_instruction ({4, -2, 0, 2, -2}, 3, 'S');
	set_instruction ({3, -2, 5, 2, -2}, 4, 'E');
	set_instruction ({4, -2, 5, 2, -2}, 3, 'S');
	for (int p1 = -2; p1 <= 5; p1++) {
		for (int p2 = -2; p2 <= 5; p2++) {
			for (int p3 = -2; p3 <= 5; p3++) {
				for (int p4 = -2; p4 <= 5; p4++) {
					if (p1 == -2 && p3 == -2 || p2 == -2 && p4 == -2) { // 不可能的位置
						continue;
					}
					if (p1 == -2 && p4 == -2 || p2 == -2 && p3 == -2) { // 起点或终点
						continue;
					}
					if ((p1 == -2 || p1 == -1) && (p2 == -2 || p2 == -1) && (p3 == -2 || p3 == -1)
					    && (p4 == -2 || p4 == -1)) {                    // 被围起来了
						continue;
					}
					if (p1 != 4 && p2 != 5 && p3 != 2 && p4 != 3) {     // 没有一个相邻的位置指针指向自己
						continue;
					}
					for (int i = 0; i <= 5; i++) {
						if (i == 1) {
							continue;
						}
						if (i != 0 && (i == 2 && p1 != 4 || i == 3 && p2 != 5 || i == 4
						    && p3 != 2 || i == 5 && p4 != 3)) {         // 指向的位置指针不指向自己
							continue;
						}
						int p = (i - 1) % 4 + 2;
						if (i == 0) {                                   // 对空位的特判
							if (p1 == 4) {
								p = 2;
							} else if (p2 == 5) {
								p = 3;
							} else if (p3 == 2) {
								p = 4;
							} else {
								p = 5;
							}
						}
						while (p == 2 && p1 != 0 && p1 != 4 || p == 3 && p2 != 0 && p2 != 5 ||
						       p == 4 && p3 != 0 && p3 != 2 || p == 5 && p4 != 0 && p4 != 3) {
								                                        // 顺时针转动指针直到指到空地或指向自己的位置
							p = (p - 1) % 4 + 2;
						}
						set_instruction ({i, p1, p2, p3, p4}, p, op[p - 1]);
					}
				}
			}
		}
	}
	// 对终点的特判
	for (int i = -1; i <= 5; i++) {
		if (i == 1 || i == 3) {
			continue;
		}
		set_instruction ({0, 4, -2, -2, i}, 4, 'W');
	}
	for (int i = -1; i <= 5; i++) {
		if (i == 1 || i == 4) {
			continue;
		}
		set_instruction ({0, i, -2, -2, 3}, 4, 'N');
	}

	// Stage 2

	// 对起点的特判
	for (int i = 2; i <= 4; i++) {
		set_instruction ({3, -2, i, -1, -2}, 1, 'S');
		set_instruction ({3, -2, i, 0, -2}, 1, 'S');
		set_instruction ({4, -2, 4, i, -2}, 1, 'E');
	}
	for (int i = 3; i <= 5; i++) {
		set_instruction ({4, -2, -1, i, -2}, 1, 'E');
		set_instruction ({4, -2, 0, i, -2}, 1, 'E');
		set_instruction ({3, -2, i, 3, -2}, 1, 'S');
	}
	for (int i = 2; i <= 5; i++) {
		vector <int> ans;
		ans.resize (5);
		ans[0] = i;
		for (int p1 = -2; p1 <= 5; p1++) {
			for (int p2 = -2; p2 <= 5; p2++) {
				for (int p3 = -2; p3 <= 5; p3++) {
					for (int p4 = -2; p4 <= 5; p4++) {
						ans[1] = p1, ans[2] = p2, ans[3] = p3, ans[4] = p4;
						if (ans[i - 1] == i % 4 + 2) {                  // 指向的位置指针指向自己
							continue;
						}
						if (p1 == -2 && p3 == -2 || p2 == -2 &&
						    p4 == -2) {                                 // 不可能的位置
							continue;
						}
						if (p2 == -2 && p3 == -2) {                     // 终点
							continue;
						}
						if ((p1 == -2 || p1 == -1) && (p2 == -2 || p2 == -1) && (p3 == -2 || p3 == -1) &&
						    (p4 == -2 || p4 == -1)) {                   // 被围起来了
							continue;
						}
						if (p1 == 4 || p2 == 5 || p3 == 2 || p4 == 3) { // 有子结点
							if (p1 == 4) {
								set_instruction (ans, i, 'W');
							} else if (p2 == 5) {
								set_instruction (ans, i, 'S');
							} else if (p3 == 2) {
								set_instruction (ans, i, 'E');
							} else {
								set_instruction (ans, i, 'N');
							}
						} else {
							if (p1 == -2 && p4 == -2) {
								continue;
							}
							set_instruction (ans, p1 == 1 || p2 == 1 || p3 == 1 || p4 == 1, op[i - 1]);
						}
					}
				}
			}
		}
	}
	// 对终点的特判
	set_instruction ({4, 1, -2, -2, -1}, 1, 'T');
	set_instruction ({4, 1, -2, -2, 0}, 1, 'T');
	set_instruction ({4, -1, -2, -2, 1}, 1, 'T');
	set_instruction ({4, 0, -2, -2, 1}, 1, 'T');
}
```

**【后记】**

在做完这道题的第二天，我重装了系统……

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P9605)

**题目大意**

> 你需要设计一个机器人，使得其能在一个 $n\times m$ 迷宫中找到左上到右下最短路。
>
> 你的机器人可以在每个位置上留下 $[0,6]$ 之间的标记，并且收集当前位置以及四联通位置的标记，然后留在原地或者向四个方向之一移动一步。
>
> 构造一个策略，使得机器人在 $5\times 10^5$，可以把最短路上的点标 $0$，其他标 $1$。
>
> 数据范围：$n,m\le 15$。

**思路分析**

实际上可以做到 $Z\in\{0,1,2,3,4,5\}$。

我们把 $2,3,4,5$ 分别用来表示上下左右的方向。

第一部分，先通过 bfs 求出一条最短路。

我们只能用类似 dfs 的过程维护 bfs，即每次 dfs 拓展一轮叶子。

首先我们要判断当前是否是起点，当且仅当 U，L 方向是边界且当前是 $0$，那么就把这个格子指向 D（如果是墙就指向 R）并移动。

当我们到达一个新格子（标号为 $0$）时，我们将指针指向其上一步走到的格子并返回（找唯一一个指向自己的格子）。

如果该格子已经访问，就将其指向的方向逆时针旋转，如果如果有未访问的点指向其并走过去，如果没有那么就会转回父亲，指向父亲并返回即可。

容易发现每次重新走到根，都会让每个点的指针从父亲逆时针旋转一周再回到父亲，那么每个点就会在 bfs 的过程中推进一轮。

如果我们走到了右下角，那么就进入了第二部分。

我们需要将 bfs 树上路径的的点标 $1$ 并把其他点标 $0$。

那么此时所有指针形成了一棵以右下角为根的内向树。

在这一阶段下我们不改变指针的结构，直接把每个点标成 $0/1$。

进行 dfs，每当我们到达一个节点时，如果有指向其的邻居，那么先走过去（任选一个）。

如果该节点的邻居都已解决，那么我们进行判断：如果该节点在最短路径上，当且仅当其为左上角或者在树上有标为 $1$ 的邻居，然后把这个点标为 $0/1$。

那么此时的 dfs 树按后序遍历确定了若干点，且已确定的点标号为 $0/1$，这是容易判断的。

那么可以在 $\mathcal O(n^2m^2)$ 的步数内完成整个过程。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "robot.h"
using namespace std;
const char op[]="  WSEN";
int a[6];
void sol() {
	auto ans=[&](int z,char c) { set_instruction({a[1],a[2],a[3],a[4],a[5]},z,c); };
	int o=a[1];
	if(!o) {
		if(a[2]==-2&&a[5]==-2) return ~a[3]?ans(3,'S'):ans(4,'E');
		if(a[3]==-2&&a[4]==-2) return ans(4,'H');
		for(int i:{2,3,4,5}) if(a[i]==i%4+2) return ans(i,op[i]);
		return ;
	}
	if(o>5||o<2) return ;
	if(a[o]==o%4+2) {
		for(int c:{1,2,3}) {
			int i=(o-2+c)%4+2;
			if(!a[i]||a[i]==i%4+2) return ans(i,op[i]);
		}
		return ans(o,op[o]);
	}
	bool ok=0;
	if(a[2]==-2&&a[5]==-2) ok=1;
	for(int i:{2,3,4,5}) if(a[i]==i%4+2) return ans(o,op[i]);
	for(int i:{2,3,4,5}) ok|=a[i]==1;
	if(a[3]==-2&&a[4]==-2) return ans(1,'T');
	return ans(ok,op[o]);
}
void program_pulibot() {
	for(a[1]=-2;a[1]<=5;++a[1]) for(a[2]=-2;a[2]<=5;++a[2]) for(a[3]=-2;a[3]<=5;++a[3]) for(a[4]=-2;a[4]<=5;++a[4]) for(a[5]=-2;a[5]<=5;++a[5]) sol();
}
```

---


# [POI 2021/2022 R2] kon

## 题目背景

翻译自 [POI2021~2022R2 Day2T2](https://szkopul.edu.pl/problemset/problem/TEuljz3gsotYQRUKdlEZZr1G/statement/)。


## 题目描述

有一个舞会，一开始角色只有 $1$、$2$，他们两个都愿意和彼此跳舞。

然后存在 $q$ 个事件，分别对应下方的操作：

- `W x`：表示新加入一个人，他和编号 $x$ 的人愿意互相和对方跳舞。
- `Z x`：表示新加入一个人，初始时他和编号为 $x$ 的人愿意跳舞的对象都互相同意跳舞。
- `? x`：表示查询愿意与 $x$ 跳舞的有几个人。

新加入的人的编号是当前人数加一。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/qvrwztvc.png)

子任务分配：

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $q \leq 5000$ | $20$ |
| $2$ | 仅包含操作 `Z` 和 `?` | $10$ |
| $3$ | `?` 总是在 $q$ 次操作的末尾部分出现 | $35$ |
| $4$ | 无附加限制 | $35$ |


## 样例 #1

### 输入

```
7
? 1
Z 2
? 1
Z 1
W 2
? 2
? 3```

### 输出

```
1
2
3
2```

# 题解

## 作者：_•́へ•́╬_ (赞：4)

## 思路

先把操作树建出来。树上有 W 边和 Z 边。

一个有意思的地方是，如果查询不占时间，那么操作的时间和点的编号相等。我们以这个东西作为下标用树状树组维护一个点的边的情况，查询的时候对着查询的时刻前缀和就行。

考虑两个点如何才能有边相连。要么通过 W 边直接相连，要么在一条 W 边的基础上通过一车 Z 边间接地相连。注意这一车 Z 边的时间都要比 W 边晚才行。i.e. 两点在树上的路径里只有一条 W 边且这条 W 边在 $\text{LCA}$ 处，且这条 W 边的时间比其他 Z 边都早。

考虑从中心的 W 边入手。W 边连接了两个极大 Z 连通块。记 W 边连接的父亲是 $u$，儿子是 $v$。

$u$ 还有若干个 Z 儿子。根据上面的注意，所有比 $v$ 晚的 Z 儿子子树都与 $v$ 之间相互有贡献。

两个方向的贡献分开。用双指针去掉这个时间的限制。随便处理一下贡献即可。

有一部分使用了天天爱跑步 trick。算法有点抽象，不好叙述清楚。

## code

```cpp
#include<stdio.h>
#include<vector>
#define N 1000009
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
inline void pc(char x)
{
	static char buf[99999],*r=buf;
	(!x||(*r++=x,r==buf+99999))&&(fwrite(buf,1,r-buf,stdout),r=buf);
}
inline void pr(int x){if(x>9)pr(x/10);pc(x%10+'0');}
int n,m=2,q,ans[N],szsz[N];vector<int>w[N],z[N],qid[N],qt[N];
inline void upd(int i,int x){for(;i<=m;szsz[i]+=x,i+=i&-i);}
inline int qry(int i){int ans=0;for(;i;ans+=szsz[i],i&=i-1);return ans;}
inline void add(int i,int x)
{
	upd(i,x);
	for(int j=0;j<z[i].size();++j)add(z[i][j],x);
}
inline void con(int i,int x)
{
	for(int j=0;j<qid[i].size();++j)ans[qid[i][j]]+=x*qry(qt[i][j]);
	for(int j=0;j<z[i].size();++j)con(z[i][j],x);
}
inline void dfs1(int i)//处理w儿子的z连通块对当前z连通块的贡献
{
	for(int j=0,k=0;j<w[i].size()||k<z[i].size();)
		if(j<w[i].size()&&(k==z[i].size()||w[i][j]<z[i][k]))
			add(w[i][j++],1);
		else dfs1(z[i][k++]);
	for(int j=0;j<qid[i].size();++j)ans[qid[i][j]]+=qry(qt[i][j]);
	for(int j=0;j<w[i].size();++j)add(w[i][j],-1);
}
inline void dfs2(int i)//处理当前z连通块对w儿子的z连通块的贡献
{
	for(int j=0;j<w[i].size();++j)con(w[i][j],-1);
	upd(i,1);
	for(int j=(int)(w[i].size())-1,k=(int)(z[i].size())-1;j>=0||k>=0;)
		if(~j&&(k>>31||w[i][j]>z[i][k]))con(w[i][j--],1);
		else dfs2(z[i][k--]);
}
inline void dfs(int i,bool o)
{
	if(o)dfs1(i),dfs2(i),add(i,-1);
	for(int j=0;j<z[i].size();++j)dfs(z[i][j],0);
	for(int j=0;j<w[i].size();++j)dfs(w[i][j],1);
}
main()
{
	read(n);w[1].emplace_back(2);
	for(int o,x;n--;)
	{
		for(;o=nc(),(o^'?')&&(o^'W')&&(o^'Z'););read(x);
		if(o=='?')qid[x].emplace_back(q++),qt[x].emplace_back(m);
		else if(o=='W')w[x].emplace_back(++m);
		else z[x].emplace_back(++m);
	}
	dfs(1,1);
	for(int i=0;i<q;pr(ans[i++]),pc('\n'));pc(0);
}
```

---

## 作者：Starrykiller (赞：2)

参考官方题解。

定义**邻域**：点 $u$ 的邻域 $N(u)=\{v: (u,v)\in E\}$，即 $u$ 出边连向点的集合。

### Subtask 1

$\mathcal{O}(q^2)$ 暴力。期望得分 $20$。

### Subtask 2

> **Lemma.**
>
> 如果只有 $\texttt{Z}$ 操作，在任意时刻，图的形态都是完全二分图。
>
> **Proof.** 初始时显然，归纳即可证明。$\square$

直接维护二分图两部的点数，以及每个点属于哪一部即可。时间复杂度 $\Theta(q)$。结合 Subtask 1 期望得分 $30$。

### Subtask 3

> **Lemma.**
>
> 在任意时刻，图的形态都是二分图。
>
> **Proof.** 初始时显然，归纳即可证明。$\square$

Subtask 1 的解法实在是太不牛了，究其原因是我们没有挖掘题目的性质，每次暴力地复制。

感性理解一下，发现有很多点的邻域都有公共的元素。考虑优化这个过程。

设二分图左部点集为 $L$，右部点集为 $R$。

不失一般性地假设我们在维护 $L$ 的邻域。考虑一棵树，我们用一条边代表一个右部点，一条路径 $\operatorname{path}(i)=(\operatorname{st}(i),\operatorname{ed}(i))$ 代表左部点 $i$ 的邻域。

依次考虑四种操作：

- $\texttt{W}$ $l$（$l\in L$）。
  - 设 $l$ 的链底为 $\operatorname{ed}(l)$，新加的右部点为 $r$。加一条代表右部点的边 $(\operatorname{ed}(l),r)$，更新链底 $\operatorname{ed}(l)\gets r$。
- $\texttt{W}$ $r$（$r\in R$）。
  - 设新加的左部点为 $l$。找到 $r$ 对应的连边，更新 $\operatorname{path}(i)$ 即可。
- $\texttt{Z}$ $l$（$l\in L$）。
  - 设新加的左部点为 $l'$，直接令 $\operatorname{path}(l')\gets \operatorname{path}(l)$（复制）即可。
- $\texttt{Z}$ $r$（$r\in R$）。
  - 设新加的右部点为 $r'$。我们要对任意包含 $r$ 这条边的路径，都加入一条代表 $r'$ 的边。
  - 考虑将 $r$ 对应的边拆成两条，一条对应 $r$ 一条对应 $r'$ 即可。

不难注意到，每个 $\operatorname{path}$ 都是某个点向上跳若干步得到的一条链。

使用树上差分，我们就直接做到了 $\Theta(q)$（对于拆边操作，可以使用懒标记维护）。结合 Subtask 1&2 期望得分 $65$。

### Subtask 4

经典套路：离线操作，获得最终树的形态。给每条边权赋 $0/1$，表示当前时刻这条边是否存在。

这是一个经典问题（根链加/单点查），使用 DFS 序+树状数组可以简单地 $\Theta(q\log q)$。期望得分 $100$。

---

## 作者：XuYueming (赞：1)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P9867)。

[庚昊的体验](https://www.cnblogs.com/XuYueming/p/18937211)。

## 题意简述

维护一张无向图图，初始两个点，通过一条边相连。$q$ 次操作：

- `W x`：新建点，和 $x$ 连边。
- `Z x`：新建点，和 $x$ 所有直接相连的点连边。
- `? x`：查询有几个点和 $x$ 相连。

## 题目分析

妙妙题。

发现 Z 操作很像把 $x$ 复制一遍，相当于一个新的版本。提示我们对操作建树，$u$ 继承了 $\operatorname{fa}(u)$ 所有对应的连边状态。

那么 W 操作就是先把 $x$ 复制一遍，在新版 $x$ 上与新建点「连边」（这里连边是原图上相连的意思，并非树边，称之为「W 边」），这样不会让之前的点错误继承这次操作。

原图上，两个点 $u,v$ 相连，当且仅当操作树上 $u$ 的某一个祖先 $u'$ 和 $v$ 的某一个祖先 $v'$，通过 W 边相连。

那么问题变为了求 $x$ 的每一个祖先，所有连出 W 边指向的点，在操作树上的子树中有几个点，这里需要对点做区分，不能算上 W 操作复制的版本。

稍微分类讨论一下。对于树根，相当于单点加子树和；对于非树根，修改的时候将树根 W 边父亲单点修改，链查询。

均可以树状数组做到 $\mathcal{O}(n\log n)$。

可以 LCT 做到在线，相信大家都会。

## 代码

离线树状数组、在线 LCT 的代码，见我[博客](https://www.cnblogs.com/XuYueming/p/18937211)。

---

## 作者：_lmh_ (赞：1)

把整张图存下来显然是不现实的。但是我们发现，复制一个节点的过程类似 `trie` 树上的分支，所以可以存储操作树。

一种思路是在操作 `c x (c='W' or c='Z')` 时将 $x$ 结点连上一个新的儿子，这条边类型为 $c$。但是这样我们发现一个问题：如果 $x$ 在 $t_1$ 时刻拉出来一个 `Z` 边连向儿子 $y$，在 $t_2(t_1<t_2)$ 时刻拉出来一个 `W` 边连向儿子 $z$，那么 $y,z$ 不相邻，但是 $y$ 和之前所有 `W` 边另一端的节点相邻。

这样我们有一个更好的思路：在 `W` 操作时依然是挂出来一个节点，而在 `Z` 操作时分裂出来两个儿子，两个节点各选一个走过去。

维护 `Z` 边构成的有根树森林，而将 `W` 边视作虚边，它两端的节点一定有至少一个是其所在树的根。这样两个节点 $x,y$ 相邻，当且仅当它们不在同一棵树内而且存在 $x,y$ 的祖先 $p_x^{(s)},p_y^{(t)}$ 通过 `W` 边相连。

查询时，将 $x$ 到所在树的根这条链提取出来，对上面每一个点求出其通过 `W` 边相连的儿子所在树的叶子个数之和；而对于根节点通过 `W` 边相连的父节点，子树内所有的叶子节点也可以对答案产生贡献。

把操作离线下来。答案的两部分一个是单点修改，链查询，一个是单点修改子树查询，都可以用树状数组维护。注意空间常数，一个节点的 `Z` 儿子不超过两个，`vector` 容易被卡。时间复杂度 $O(n\log n)$。

代码写了一个无意义的树剖。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
#define lson (u<<1)
#define rson (u<<1|1)
const ll N=2000007;
struct FenwickTree{
	int cnt[N];
	void modify(int x,int v){
		while(x<N){
			cnt[x]+=v;x+=x&-x; 
		}
	}
	int query(int x){
		int sum=0;
		while(x){
			sum+=cnt[x];x&=x-1;
		}
		return sum;
	}
}val,cnt;
ll n=2,m,k=2,nV=2,p[N],op[N],qry[N],pos[N],root[N],top[N],sz[N],tI[N],timer;
vector<ll> split[N],roots;
//+1: original; +2: new
char c;
void dfs1(int u){
	sz[u]=1;
	for (auto v:split[u]){
		root[v]=root[u];
		dfs1(v);
		sz[u]+=sz[v];
		if (sz[v]>sz[top[u]]) top[u]=v;
	}
}
void dfs2(int u,int t){
	tI[u]=++timer;
	if (top[u]){
		dfs2(top[u],t);
		for (auto v:split[u]) if (v!=top[u]) dfs2(v,v);
	}
	top[u]=t;
}
ll query(int u){
	if (!u) return 0;
	ll sum=0;
	if (root[u]!=1){
		int o=p[root[u]];
		sum=cnt.query(tI[o]+sz[o]-1)-cnt.query(tI[o]-1);
	}
//	cout<<u<<' '<<sum<<endl;
	while(1){
		int w=top[u];
		sum+=val.query(tI[u])-val.query(tI[w]-1);
		if (w==root[u]) return sum;
		u=p[w];
	}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	p[2]=1;roots.emplace_back(1);roots.emplace_back(2);
	pos[1]=1;pos[2]=2;
	cin>>m;
	for (int x,i=1;i<=m;++i){
		cin>>c>>x;qry[i]=x;
		if (c=='W'){
			op[i]=1;
			p[pos[++k]=++n]=pos[x];
			roots.emplace_back(n);
		}
		else if (c=='Z'){
			op[i]=2;
			split[pos[x]].emplace_back(++n);p[n]=pos[x];
			split[pos[x]].emplace_back(++n);p[n]=pos[x];
			split[pos[x]].shrink_to_fit();
			pos[x]=n-1;pos[++k]=n;
		}
		else op[i]=3;
	}
//	for (int i=1;i<=n;++i) cout<<p[i]<<' ';cout<<endl;
	for (auto x:roots){
		root[x]=x;dfs1(x);dfs2(x,x);
	}
//	memset(sz,0,sizeof(sz));
	memset(pos,0,sizeof(pos));
	pos[1]=1;pos[2]=2;k=2;
	val.modify(tI[1],1);
	cnt.modify(tI[1],1);
	cnt.modify(tI[2],1);
	for (int i=1;i<=m;++i){
		int u=qry[i];
		if (op[i]==1){
			pos[++k]=++nV;
//			sz[nV]=1;
			cnt.modify(tI[nV],1);
			val.modify(tI[pos[u]],1);
		}
		else if (op[i]==2){
//			++sz[root[pos[u]]];
			if (root[pos[u]]!=1) val.modify(tI[p[root[pos[u]]]],1);
			cnt.modify(tI[pos[u]],-1);
			cnt.modify(tI[pos[u]=++nV],1);
			cnt.modify(tI[pos[++k]=++nV],1);
		}
		else cout<<query(pos[u])<<'\n';
	}
	return 0;
}
```

---

## 作者：Reunite (赞：1)

折磨了很久的题，一直没怎么听懂 wt 讲的，我来补充一下吧。


---
## 一
---

首先建出操作树，边有 $W/Z$ 两种。

- **引理1：** $u,v$ 两点有边，则操作树上 $u \rightarrow v$ 的路径上有且仅有一条 $W$ 边。

证明：考虑归纳，设路径上任一个 $W$ 边为 $(x,y)$，结合特殊性质可以发现，如果没有其他 $W$ 边，则每一次操作后，图都是完全二分图。因为新增的点由 $Z$ 边产生，其连满了另一部的所有点。如果仍有 $W$ 边，若与初始的 $W$ 边 $(x,y)$ 共顶点，则可以直连，不满足有多于一条 $W$ 边，否则一定会导致与初始的 $x,y$ 不直连，也即破坏了完全二分图性质，显然无法实现 $u,v$ 有边。

- **引理2：** $u\rightarrow v$ 路径上唯一的一条 $W$ 边一定与 $lca_{u,v}$ 共顶点，且编号为路径上最小的两个。

证明：因为连边是有时间的，显然子节点时间大于父节点，因此必须有上述性质，才能保证 $W$ 这条边的直连性通过一系列 $Z$ 边复制到 $(u,v)$ 使其有边。

接下来我们利用这两个性质解决这道题。

考虑不那么朴素的实现，钦定一条 $W$ 边，向左右两边的连通块内得到一些信息，再根据询问查询，但这个是无法用数据结构优化的，因为对于每个 $W$ 边遍历两边的极大 $Z$ 连通块复杂度是假的，可考虑一个很大的 $Z$ 连通块外面挂了很多个 $W$ 边的情况。

但是操作树是有根的，我们可以换一种精妙~~玄学~~的方法。

我们只对 $W$ 的边进行操作，每次我们开始 $solve$，都会进入一个父亲边是 $W$ 的点 $u$，我们考虑这个点，以及所有儿子的极大 $Z$ 连通块的贡献与询问。

对询问的贡献有两部分，一个是 $u$ 的 $W$ 儿子子树内 $Z$ 连通块对 $u$ 的 $Z$ 儿子子树内 $Z$ 连通块的贡献，另一个则是反过来的。

引理二的限制可以由双指针解决，剩下的就交给递归好了。虽然我比较笨，没办法彻底弄清 wt 的递归，但感性理解是非常对的。

---
## 二
---

思考一下复杂度，我们先去掉 BIT 的一个 $\log$，程序进入了每一个父边为 $W$ 的点，并以此扩展出一个极大 $Z$ 连通块，然后我们在这个连通块的基础上，又扩展出了一圈 $W$ 边，再把这些新加的点扩展一个 $Z$ 连通块。注意这里并没有迭代。

父边为 $W$ 的点，显然只被访问了两次：一次是父亲，一次是祖先上最靠近 $u$ 的父边为 $W$ 的点。

父边为 $Z$ 的点，显然也只被访问了两次：为祖先上最靠近 $u$ 的两个父边为 $W$ 的点。

因此每个点只被访问了 $O(1)$ 次，加入删除 BIT $O(1)$ 次，总时间复杂度正确，为 $O(n\log_2n)$。

代码借鉴了 wt 的。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define N 1000005
using namespace std;

int n,m=2,qq;
int ans[N];
vector <int> w[N];
vector <int> z[N];
vector <pair <int,int>> q[N];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

int t[N];
inline void add(int x,int k){while(x<=m) t[x]+=k,x+=x&-x;return ;}
inline int ask(int x){int s=0;while(x) s+=t[x],x^=x&-x;return s;}

inline void updata(int u,int x){add(u,x);for(int v:z[u]) updata(v,x);}
inline void con(int u,int x){for(auto v:q[u]) ans[v.second]+=x*ask(v.first);for(int v:z[u]) con(v,x);}

inline void work1(int u){
	int s1=w[u].size(),s2=z[u].size(),pos=0;
	for(int i=0;i<s2;i++){
		while(pos<s1&&w[u][pos]<z[u][i]) updata(w[u][pos++],1);
		work1(z[u][i]);
	}
	for(int i=pos;i<s1;i++) updata(w[u][i],1);
	for(auto v:q[u]) ans[v.second]+=ask(v.first);
	for(int i=0;i<s1;i++) updata(w[u][i],-1);
	return ;
}

inline void work2(int u){
	for(int v:w[u]) con(v,-1);
	add(u,1);
	int s1=w[u].size(),s2=z[u].size(),pos=s1-1;
	for(int i=s2-1;i>=0;i--){
		while(pos>=0&&w[u][pos]>z[u][i]) con(w[u][pos--],1);
		work2(z[u][i]);
	}
	for(int i=pos;i>=0;i--) con(w[u][i],1);
	return ;
}

inline void solve(int u,bool op){
	if(op) work1(u),work2(u),updata(u,-1);
	for(int v:z[u]) solve(v,0);
	for(int v:w[u]) solve(v,1);
	return ;
}

int main(){
	in(n);
	w[1].emplace_back(2);
	for(int i=1;i<=n;i++){
		char c[4];
		int x;
		scanf("%s%d",c+1,&x);
		if(x>m) return 1;
		if(c[1]=='?') q[x].push_back({m,++qq});
		if(c[1]=='W') w[x].emplace_back(++m);
		if(c[1]=='Z') z[x].emplace_back(++m);
	}
	solve(1,1);
	for(int i=1;i<=qq;i++) printf("%d\n",ans[i]);

	return 0;
}
```

---

## 作者：dream10 (赞：0)

## Hint

考虑操作树。

## Solution

### Step 1

我们建立操作树，新加点就作为儿子加入，记录边是 $W$ 还是 $Z$。

### Step 2

原图两个点 $x,y$ 在图上联通，在树上的充要条件是什么？肯定有一条初始的 $(u,v)$ 边，然后不断对 $u,v$ 进行 $Z$ 操作，在树上就是一条路径，中间是 $W$，两边是 $Z$，而且 $Z$ 的时间比 $W$ 晚。

### Step 3

如果不调整模型，那么时间的限制就需要再加数据结构。所以考虑再次调整模型，使得充要条件更为简单。

将 $u$ 点按照 $W$ 边加入的时间进行拆点，拆成 $u_1,u_2,\cdots,u_k$，构成祖先后代关系，然后挂 $Z$ 边就在一个地方插入，使得它的祖先下方的 $W$ 边都是原来的问题能复制的 $W$ 边。也就是代码里的

```
G[pos[x]].emplace_back(++tot);
G[pos[x]].emplace_back(++tot);
pos[++n]=tot-1,pos[x]=tot;
```

此时只有叶子是真实的。

### Step 4

计算答案，就是一段 $Z$ 向上走，然后经过 $W$ 边，然后向下走，走到一个叶子（代表原图中的点），如果已经加入了就统计答案。

维护 $Z$ 联通块，其他视为虚边。

发现有一部分是到根链，然后向下走一段 $W$。
另外一部分是跳到根，然后跳虚边，再向下。

两部分分开统计，使用数据结构维护。

### Analysis

复杂度 $O(q \log q)$。

```
#include<bits/stdc++.h>
using namespace std;
template<typename T>
void read(T &a){
    #define gc getchar()
    char c;a=0;int f=1;
    while(!isdigit(c=gc))if(c=='-')f=-1;
    do a=a*10+c-'0';
    while(isdigit(c=gc));
    a*=f;
}
template<typename T>
void write(T a){
    if(a<0)putchar('-'),a=-a;
    if(a>=10)write(a/10);
    putchar('0'+a%10);
}
char GC(){
    char c=getchar();
    while(c<=32)c=getchar();
    return c;
}
template<typename T>
void chmin(T &x,T y){if(x>y)x=y;}
template<typename T>
void chmax(T &x,T y){if(x<y)x=y;}
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef pair<int,int> PII;
typedef pair<ll,int> PLI;
typedef __int128 lll;
mt19937 rng(chrono::system_clock::now().time_since_epoch().count());
namespace GENSOKYO{
int Q;
const int MAXN=2000010;
struct QRY{
    char ch;int x;
}a[MAXN];
vector<int> rts;
int n,tot;
int vfa[MAXN];//virtual father 在新图下标
int pos[MAXN];//原图下标到新图下标
int dfn[MAXN],dfc,siz[MAXN];
int bel[MAXN];
vector<int> G[MAXN];
void dfs(int x,int RT){
    bel[x]=RT;dfn[x]=++dfc;
    siz[x]=1;
    for(int y:G[x]){
        dfs(y,RT);
        siz[x]+=siz[y];
    }
}
struct FWK{
int a[MAXN];
int lowbit(int x){return x&-x;}
void upd(int x,int v){
    for(;x<=tot;x+=lowbit(x))
        a[x]+=v;
}
int qry(int x){
    int res=0;
    for(;x;x-=lowbit(x))
        res+=a[x];
    return res;
}
}t1,t2;
//t1记录子树贡献，t2记录链上连出去的贡献
void activate(int x){
    t1.upd(dfn[pos[x]],1);
    int rt=bel[pos[x]];
    if(vfa[rt]!=0){
        int y=vfa[rt];
        t2.upd(dfn[y],1);
        t2.upd(dfn[y]+siz[y],-1);
    }
}
void main(){
    cin>>Q;
    rts.emplace_back(1);
    rts.emplace_back(2);
    vfa[1]=0;vfa[2]=1;
    pos[1]=1,pos[2]=2;
    tot=n=2;
    for(int iq=1;iq<=Q;++iq){
        cin>>a[iq].ch>>a[iq].x;
        char op=a[iq].ch;int x=a[iq].x;
        if(op=='W'){
            pos[++n]=++tot;
            rts.emplace_back(tot);
            vfa[tot]=pos[x];
        }else if(op=='Z'){
            G[pos[x]].emplace_back(++tot);
            G[pos[x]].emplace_back(++tot);
            pos[++n]=tot-1,pos[x]=tot;
        }
    }
    dfc=0;
    for(auto rt:rts)
        dfs(rt,rt);
    activate(1);
    activate(2);
    int it=2;
    for(int iq=1;iq<=Q;++iq){
        char op=a[iq].ch;int x=a[iq].x;
        if(op=='W'||op=='Z'){
            activate(++it);
        }else{
            int ans=0;
            ans+=t2.qry(dfn[pos[x]]);
            if(vfa[bel[pos[x]]]!=0){
                int y=vfa[bel[pos[x]]];
                ans+=t1.qry(dfn[y]+siz[y]-1)-t1.qry(dfn[y]-1);
            }
            printf("%d\n",ans);
        }
    }
}
}
signed main(){
    int T=1;//cin>>T;
    while(T--)GENSOKYO::main();
    return 0;
}
```


借鉴 _lmh_ 的思路，代码。

---


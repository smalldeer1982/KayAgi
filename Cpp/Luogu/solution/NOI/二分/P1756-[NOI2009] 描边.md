# [NOI2009] 描边

## 题目描述

小 Z 是一位杰出的数学家。聪明的他特别喜欢研究一些数学小问题。

有一天，他在一张纸上选择了 $n$ 个点，并用铅笔将它们两两连接起来，构成 $\dfrac{n(n-1)}{2}$ 条线段。由于铅笔很细，可以认为这些线段的宽度为 $0$。

望着这些线段，小 Z 陷入了冥想中。他认为这些线段中的一部分比较重要，需要进行强调。因此小 Z 拿出了毛笔，将它们重新进行了描边。毛笔画在纸上，会形成一个半径为 $r$ 的圆。在对一条线段进行描边时，毛笔的中心（即圆心）将从线段的一个端点开始，沿着该线段描向另一个端点。下图即为在一张 $4$ 个点的图中，对其中一条线段进行描边强调后的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/h92i5d69.png)

现在，小 Z 非常想知道在描边之后纸面上共有多大面积的区域被强调，你能帮助他解答这个问题么？

## 说明/提示

每个测试点单独评分。

本题设有 $4$ 个评分参数 $p_1,p_2,p_3,p_4$（$p_1 \lt p_2 \lt p_3 \lt p_4$），已在输入文件中给出。

你的得分将按照如下规则给出：

- 若你的答案与标准答案相差不超过 $p_1$，则该测试点你将得到满分；
- 否则，若你的答案与标准答案相差不超过 $p_2$，则你将得到该测试点 $70\%$ 的分数；
- 否则，若你的答案与标准答案相差不超过 $p_3$，则你将得到该测试点 $40\%$ 的分数；
- 否则，若你的答案与标准答案相差不超过 $p_4$，则你将得到该测试点 $10\%$ 的分数；
- 否则，该测试点你的得分为 $0$。

## 样例 #1

### 输入

```
2
1 1
1 2
1
1 2
1
0.00001 0.001 0.1 1
```

### 输出

```
5.1415927```

# 题解

## 作者：Yukikaze_ (赞：38)

发现这道 noi 的题竟然没有题解，所以来写一下我的暴力思路。

首先，因为这道题的值域很小，而且精度只要求精确到 $10^{-4}$，所以可以利用经典的蒙特卡罗法来求面积。设取的随机点数为 $k$，复杂度为 $O(mk)$ ，实测按照 $k$ 的不同大小，可以取得 $60-85$ 分。

蒙特卡罗算法是没有办法优化的，因此考虑另一种算法：把平面划分成若干个小方格，对于每个小方格，只根据它的中心点是否被覆盖来判断这个方格是否被覆盖。

这个算法相对于蒙特卡罗来说精度提升了一些，但并没有什么用，还是只能取得 $80$ 分。

考虑把平面按照横坐标划分成若干长条，对于每个长条取中心线，按照中心线的被覆盖情况来判断整个长条的被覆盖情况，这种算法效率更高是因为一条“描边”最多只和一条直线相交于连续的一段，而且可以用较低的时间复杂度求出交点。

我的程序中采用了二分来求交点，所以效率比较低，要跑 $1h40min$ 才能跑出第 $10$ 个点，采用高效的写法应该可以在几分钟之内出结果。

程序如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
const int N=2505;
const ld eps=1e-9;
int n,m,u[N],v[N],cnt;
ld r,mxx=-1e9,mix=1e9,mxy=-1e9,miy=1e9;
ld ans;
struct aa
{
	ld x,y;
	aa operator +(const aa &b)const{return aa{x+b.x,y+b.y};}
	aa operator -(const aa &b)const{return aa{x-b.x,y-b.y};}
	aa operator *(const ld &b)const{return aa{x*b,y*b};}
	ld operator ^(const aa &b)const{return x*b.y-y*b.x;}
	ld operator *(const aa &b)const{return x*b.x+y*b.y;}
	ld dis() {return sqrt(x*x+y*y);}
}dt[N];
int sgn(ld x) {return (x>eps)-(x<-eps);}
struct bb
{
	ld ps;
	int fl;
	bool operator <(const bb &b)const{return sgn(ps-b.ps)? ps<b.ps:fl>b.fl;}
}Ln[N+N];
bool in(aa s,aa t,aa x)
{
	ld lp=((x-s)^(t-s));
	if(sgn(lp)>0) swap(s,t);
	else lp=-lp;
	aa la=t-s,lb=la;
	swap(lb.x,lb.y),lb.x=-lb.x;
	if(sgn((x-s)^lb)>=0&&sgn((x-t)^lb)<=0) return lp/la.dis()<=r;
	return min((x-s).dis(),(x-t).dis())<=r;
}
int main()
{
	freopen("path10.in","r",stdin);
	freopen("path10.out","w",stdout); 
	int i,j;
	for(cin>>n,i=1;i<=n;i++)
		cin>>dt[i].x>>dt[i].y,mxx=max(mxx,dt[i].x),mix=min(mix,dt[i].x),
		mxy=max(mxy,dt[i].y),miy=min(miy,dt[i].y);
	for(cin>>m,i=1;i<=m;i++) cin>>u[i]>>v[i];
	cin>>r,mix-=r,mxx+=r,miy-=r,mxy+=r;
	ld px=(mxx-mix)/10000000.0;
	int Cl=0;
	for(ld X1=mix+px/2,X;X1<mxx;X1+=px)
	{
		cnt=0,X=X1;
		for(i=1;i<=m;i++)
			if(max(dt[u[i]].x,dt[v[i]].x)+r>X&&min(dt[u[i]].x,dt[v[i]].x)-r<X)
			{
				if(fabs(dt[u[i]].x-X)>fabs(dt[v[i]].x-X)) swap(u[i],v[i]);
				if(fabs(dt[u[i]].x-X)<r)
				{
					ld st=dt[u[i]].y,pl=0,pr=mxy-st,mid;
					while(pr-pl>eps)
					{
						mid=(pl+pr)/2;
						if(in(dt[u[i]],dt[v[i]],aa{X,st+mid})) pl=mid;
						else pr=mid;
					}
					Ln[++cnt]=bb{st+(pl+pr)/2,-1},pl=0,pr=st-miy;
					while(pr-pl>eps)
					{
						mid=(pl+pr)/2;
						if(in(dt[u[i]],dt[v[i]],aa{X,st-mid})) pl=mid;
						else pr=mid;
					}
					Ln[++cnt]=bb{st-(pl+pr)/2,1};
				}
				else
				{
					if(dt[u[i]].x>dt[v[i]].x) swap(u[i],v[i]);
					aa lp=dt[v[i]]-dt[u[i]];
					ld la=dt[u[i]].y+lp.y*(X-dt[u[i]].x)/(dt[v[i]].x-dt[u[i]].x),lb=r*lp.dis()/(dt[v[i]].x-dt[u[i]].x);
					Ln[++cnt]=bb{la-lb,1},Ln[++cnt]=bb{la+lb,-1};
				}
			}
		sort(Ln+1,Ln+cnt+1);
		for(i=1,j=0;i<=cnt;i++)
			ans+=(!!j)*(Ln[i].ps-Ln[i-1].ps)*px,j+=Ln[i].fl;
	}
	printf("%.9Lf",ans);
	return 0;
}
```


---

## 作者：一只小兔子 (赞：16)

~~502 Bad Gateway~~

让我们直奔主题吧。

记 $f(c)$ 为任一图形面积与 $x=c$ 相交的所有线段长度总和。那么，此图形面积可以表示为：

$$\int^B_Af(x)dx$$

其中， $A=\inf(x)$ 和 $B=\sup(x)$ 分别是 $x$ 的上下界，即图形左右边界。

为了求这个积分，我们把这个区间分成 $N$ 等份，先近似求每一个小区间的积分，再求和。

## 函数值

$f(x)$ 怎么求？

对于某个值 $c$ ，考虑记录 $x=c$ 与每一个笔画的交线段，最后排序合并并求和，复杂度 $O(n\log n)$ 。（共 $n$ 笔画）

## 一阶近似（梯形法则）

考虑某一小段区间 $[a,b]$ ，区间长为 $h$ 。

我们可以选择矩形近似（左端点，右端点和中点都可以）：

$$\int^b_af(x)\approx hf(a)$$

或者梯形近似：

$$\int^b_af(x)\approx \frac{h}{2}(f(a)+f(b))$$

最后线性求和，这就是扫描线。

复杂度： $O(Nn\log n)$

（ $N$ 越大，结果越精确，程序耗时越长。误差与 $f(x)$ 二阶导成正比）

参考题解：神仙的11天4小时[扫描线](https://byvoid.com/zhs/blog/noi-2009-path/)（满分）

## 二阶近似（辛普森法则）

考虑某一小段区间 $[a,b]$ ，区间长为 $h$ 。

$$\int^b_af(x)\approx \frac{h}{6}(f(a)+f(b)+4f(\frac{a+b}{2}))$$

最后线性求和，这就是朴素辛普森。

复杂度： $O(Nn\log n)$

（ $N$ 越大，结果越精确，程序耗时越长。误差与 $f(x)$ **四**阶导成正比）

## 优化（自适应辛普森法）

考虑某一段区间 $[a,b]$ ，区间长为 $h$ 。如果我们可以及时知道所求估值的误差是否在允许范围内，我们就可以更快的决定合适的区间长度，甚至自己调控区间长度。

二分此区间。如果左右区间估值和与本区间估值的差在允许范围内，则认为本区间估值的误差在允许范围内。

理论复杂度： $O(n\log n\log N)$

参考题解：神仙的[辛普森公式](https://luoguliziheng.gitee.io/solution-p1756.html)[代码](https://www.cnblogs.com/datam-cy/archive/2012/05/22/2512770.html)（97分）

## 误差

自适应辛普森虽然快，但是其精度实际上是基于 $f(x)$ **四**阶导的。对于区间 $[a,b]$ ，其误差项是

$$-\frac{(b-a)^5}{2880}f^{(4)}(\xi)$$

（ $f(x)$ 有四阶导吗？）

注意到，我们假设 $f(x)$ 是光滑的，即可无限次求导，但是真正的 $f(x)$ 只能保证连续性，它的图像有很多V型拐点，导致辛普森法估算结偏小。（自证不难，感性理解）

这导致了第10个点的误差超过了 $10^{-4}$ ，只能得到7分。

~~但是网上有人用了辛普森/纯计算/高精度实数依次做了比对，最后认为是最后一个点的数据错了，实际怎样不得而知。~~

## 代码

（15s跑过第10点，还是97分）

**本题只能提交答案，10个点的输入数据都只有最后4个精度值，无法用代码判断数据点**

```
#include<cstdio>//P1756
#include<cmath>
#include<algorithm>
#define sqr(x) ((x)*(x))
typedef long double ldb;
const ldb eps=1e-6;
const int N=2442;
template<class T>T lmin(T a,T b){return a<b?a:b;}
template<class T>T lmax(T a,T b){return a<b?b:a;}
template<class T>void swp(T &a,T &b){T f=a;a=b;b=f;}
ldb QWERTY[4],rad;
int n,m,dv,dx[N],dy[N],cr[N],totr;
struct P{
	ldb x,y;
	P(ldb a=0,ldb b=0):x(a),y(b){}
	void scan(){scanf("%Lf%Lf",&x,&y);}
	void print(){printf("(%.15Lf,%.15Lf)",x,y);}
	void rot90(){ldb p=y;y=x;x=-p;}
	ldb operator ~ (){return sqrt(x*x+y*y);}
	ldb slope(){return x==0.0?1e99:y/x;}
	friend P operator + (P a,P b){return (P){a.x+b.x,a.y+b.y};}
	friend P operator - (P a,P b){return (P){a.x-b.x,a.y-b.y};}
	P operator * (ldb k){x*=k,y*=k;return *this;}
	P operator / (ldb k){x/=k,y/=k;return *this;}
	friend bool operator < (P a,P b){return a.x<b.x;}
	friend bool operator > (P a,P b){return a.y>b.y;}
}pt[N];
struct R{
	P pa,pb,pc,pd;
	R(P da=P(),P db=P(),P dc=P(),P dd=P()):pa(da),pb(db),pc(dc),pd(dd){}
	ldb minx(){return lmin(lmin(pa,pb),lmin(pc,pd)).x;}
	ldb maxx(){return lmax(lmax(pa,pb),lmax(pc,pd)).x;}
}bk[N];
struct range{
	ldb led,red;
	range(ldb la=0,ldb ra=0):led(la),red(ra){}
	range(R blk){led=blk.minx();red=blk.maxx();}
	void print(){printf("[%.15Lf,%.15Lf]",led,red);}
	friend bool operator < (range a,range b){
		return a.led==b.led?a.red<b.red:a.led<b.led;}
}rt[N+N],ry[N+N];
ldb intersect(ldb x,P a,P b){
	ldb slp=(b-a).slope(),het;het=a.y-a.x*slp;return slp*x+het;
}
ldb F(ldb x){
	int c=0;ldb tmp=0.0,lf[4];
	for(int i=1;i<=n;++i)if(fabs(pt[i].x-x)<rad){
		tmp=sqr(rad)-sqr(pt[i].x-x);tmp=sqrt(fabs(tmp));
		ry[++c]=range(pt[i].y-tmp,pt[i].y+tmp);
	}
	for(int i=1;i<=m;++i)if(bk[i].minx()<x&&x<bk[i].maxx()){
		lf[0]=intersect(x,bk[i].pa,bk[i].pb);lf[1]=intersect(x,bk[i].pb,bk[i].pc);
		lf[2]=intersect(x,bk[i].pc,bk[i].pd);lf[3]=intersect(x,bk[i].pd,bk[i].pa);
		for(int f=0;f<4;++f)for(int g=f+1;g<4;++g)if(lf[f]>lf[g])swp(lf[f],lf[g]);
		ry[++c]=range(lf[1],lf[2]);//printf("%.15Lf,%.15Lf\n",lf[1],lf[2]);
	}
	if(c==0)return 0.0;std::sort(ry+1,ry+c+1);ldb l=ry[1].led,r=ry[1].red,s=0.0;
	for(int i=2;i<=c;++i)if(ry[i].led<=r+eps)r=lmax(ry[i].red,r);
	else s+=r-l,l=ry[i].led,r=ry[i].red;
//	;printf("F(%.15Lf)=%.15Lf\n",x,s+r-l);
	return s+r-l;
}
ldb simpson_approx(ldb l,ldb r,ldb fl,ldb fm,ldb fr){
	return (r-l)*(fl+fr+4*fm)/6.0;}
ldb get_area(ldb l,ldb fl,ldb m,ldb fm,ldb r,ldb fr,ldb pe){
//	;printf("Calculating range:[%.15Lf,%.15Lf]:",l,r);
//	;printf("\tApproximation:%.15Lf\n",pe);
	ldb lm=(l+m)/2,rm=(r+m)/2,flm,frm;flm=F(lm);frm=F(rm);
	ldb ls=simpson_approx(l,m,fl,flm,fm),rs=simpson_approx(m,r,fm,frm,fr);
//	;printf("\tLeft approx:%.15Lf;Right approx:%.15Lf\n",ls,rs);
	return fabs(ls+rs-pe)<eps?(ls+rs):
	get_area(l,fl,lm,flm,m,fm,ls)+get_area(m,fm,rm,frm,r,fr,rs);
}
ldb calc(ldb l,ldb r){
	ldb fl=F(l),fr=F(r),fm,m=(l+r)/2.0;fm=F(m);
	ldb pe=simpson_approx(l,r,fl,fm,fr);return get_area(l,fl,m,fm,r,fr,pe);
}
void solve(){
	scanf("%d",&n);for(int i=1;i<=n;++i)pt[i].scan();int ccn=0,ex,ey;
//	;for(int i=1;i<=n;++i)printf("Point #%d:(%.15Lf,%.15Lf)\n",i,pt[i].x,pt[i].y);
	scanf("%d",&m);for(int i=1;i<=m;++i)scanf("%d%d",dx+i,dy+i),cr[dx[i]]=cr[dy[i]]=1;
//	;printf("P:");for(int i=1;i<=n;++i)if(cr[i])printf(" #%d",i);printf(" Involved\n");
	float ppp;scanf("%f",&ppp);rad=ppp;
//	scanf("%Lf",&rad);for(int i=0;i<4;++i)scanf("%Lf",QWERTY+i);
//	;printf("Radius input:%.15Lf\nFour useless precision decision",rad);
//	;for(int i=0;i<4;++i)printf(" %.15Lf",QWERTY[i]);printf("\nModified list:\n");
	for(int i=1;i<=n;++i)if(cr[i])pt[++ccn]=pt[i];n=ccn;ccn=0;
//	;for(int i=1;i<=n;++i)printf("Point #%d:(%.15Lf,%.15Lf)\n",i,pt[i].x,pt[i].y);
	for(int i=1;i<=m;++i){ex=dx[i],ey=dy[i];P tmp=pt[ex]-pt[ey];
		ldb ds=~tmp;tmp=tmp/ds*rad;tmp.rot90();
		bk[i]=R(pt[ex]-tmp,pt[ex]+tmp,pt[ey]+tmp,pt[ey]-tmp);
	}
//	;for(int i=1;i<=m;++i){printf("Rectangle $%d:\n",i);bk[i].pa.print();
//	;bk[i].pb.print();bk[i].pc.print();bk[i].pd.print();putchar('\n');}
	for(int i=1;i<=n;++i)rt[++ccn]=range(pt[i].x-rad,pt[i].x+rad);
	for(int i=1;i<=m;++i)rt[++ccn]=range(bk[i]);std::sort(rt+1,rt+ccn+1);
//	;for(int i=1;i<=ccn;++i)printf("#%d range:",i),rt[i].print(),putchar('\n');
	ldb ans=0,le=rt[1].led,re=rt[1].red;
	for(int i=2;i<=ccn;++i)if(rt[i].led<=re+eps)re=lmax(re,rt[i].red);
	else ans+=calc(le,re),le=rt[i].led,re=rt[i].red;ans+=calc(le,re);
	printf("%.15Lf",ans);
}
ldb answer[11]={5.141592653589793};//;)
int main(){solve();}
```

---

## 作者：Foxtr0t (赞：15)

### 传送门

[P1756 \[NOI2009\] 描边](https://www.luogu.com.cn/problem/P1756)

### 题意简述

给定一堆线段 $l_i$ 和一个半径 $r$.

有图形（未必连通）$S$ 使得任意一点 $P$ 到任意 **线段** $l_i$ 距离 $d < r$，$P$ 在 $S$ 上.

求 $S$ 的面积.

翻译成数学符号就是:

$\forall{P(x_1,y_1)}\exists{i}\exists{M(x_2,y_2)}\in{l_i},{(x_1-x_2)^2+(y_1-y_2)^2<r^2}\Rightarrow{{P}\in{S}}$

### 题目分析

读取输入数据:

数组 $vertexes$, $segments$ 分别存储顶点信息和线段信息;

双精度浮点数 $r$, $p$ 分别存储半径和最高精度（AC 想必也不需要低精度）.

~~然后建一个画布，大小为顶点的最值加减半径，CPU绘图，都画完统计面积~~

~~能得 4 分~~

设函数 $h(x)$ 为扫描线有效长度.

显然 $S=\int{h(x)\cdot{dx}}$

于是设一个合适的 $dx$ 值，用扫描线水平扫描，得出函数 $h(x)$ 的值表

显然 ${S}\approx\sum_{i}{h(x_0+i\cdot{dx})}\cdot{dx}$

实现没问题大概能得 $97$ 分……

接下来无论我如何提高精度，永远都比标准答案小 $n*10^{-4}$

### 那为什么是 $97$ 呢

**以下分析仅供参考，因为我不知道标准答案是怎么得出的！**

对不同扫描方向进行分析:

水平扫描加法进行了 $880601$ 次;

竖直扫描加法进行了 $1001013$ 次;

显然不是截断的问题，不然水平扫描才是最优解！

对与 $x, y$ 轴平行的线段长度进行统计:

$\Large\{^{x_a\approx{535.203695}}_{y_a\approx{654.000000}}$

加上我的实现导致与扫描线 **平行** 的线段日常 **误差大**……

于是用竖直方向扫描的方法再试了一次，这次 AC 了.

至于是不是这个原理，这个 hack 样本太大了 debug 太痛苦，我无法证明.

就只能交给你们啦.

### 代码实现（部分）

C++ 我喜欢封装成类，这里提供我写的类供你们参考：

虽然洛谷的规则已经强调了抄袭的危害，但我得说：

直接抄这个肯定跑不动，连 ```main()``` 都没有……

这个提交文件的题，我不可能发 AC 代码，不然真的是罪人了.

#### 线段的类 Class

```cpp
std::vector<std::pair<double, double>> vertexes;
double left = 1.79769e+308, right = -left, top = left, bottom = -left, r, p1, p2, p3, p4, dx, S = 0.0;
struct Line 
{
	int a, b;
	bool rh;
	double dx, _dx, _dy, k, c1; // 乱七八糟的优化变量，数学相关，有一些研究价值
	Line(int a_, int b_)  // 参数为从 0 开始的 vertexes 索引，顺序无所谓
	{
		bool rev = vertexes[a_].first > vertexes[b_].first || (vertexes[a_].first == vertexes[b_].first && vertexes[a_].second > vertexes[b_].second);
		a = rev ? b_ : a_, b = rev ? a_ : b_;
		auto& _a = vertexes[this->a], & _b = vertexes[this->b];
		rh = _a.second > _b.second;
		_dx = _b.first - _a.first, _dy = _b.second - _a.second, k = _dy / _dx, dx = !_dy ? 0 : abs(_dy) / sqrt(_dx * _dx + _dy * _dy);
		c1 = sqrt(_dx * _dx + _dy * _dy) / _dx;
	}
	bool height(double x, double& h0, double& h1) // 如果和扫描线相交返回 true，同时 h0, h1 分别为最值
	{
		bool res = true;
		if (x + r <= vertexes[a].first || x >= vertexes[b].first + r) res = false;
		if (res)
		{
			auto& a = vertexes[this->a], & b = vertexes[this->b];
			if (x + dx * r < a.first)
			{
				double _cos = a.first - x;
				double _sin = sqrt(r * r - _cos * _cos);
				h0 = a.second - _sin, h1 = a.second + _sin;
			}
			else if (x > b.first + dx * r)
			{
				double _cos = x - b.first;
				double _sin = sqrt(r * r - _cos * _cos);
				h0 = b.second - _sin, h1 = b.second + _sin;
			}
			else if (x < a.first + dx * r && x + dx * r > b.first)
			{
				double _cosa = a.first - x, _cosb = x - b.first;
				double _sina = sqrt(r * r - _cosa * _cosa), _sinb = sqrt(r * r - _cosb * _cosb);
				if (rh) h0 = b.second - _sinb, h1 = a.second + _sina;
				else h0 = a.second - _sina, h1 = b.second + _sinb;
			}
			else if (x < a.first + dx * r)
			{
				double _cos = a.first - x;
				double _sin = sqrt(r * r - _cos * _cos);
				if (rh) h0 = a.second + (x - a.first) * k - c1 * r, h1 = a.second + _sin;
				else h0 = a.second - _sin, h1 = a.second + (x - a.first) * k + c1 * r;
			}
			else if (x + dx * r > b.first)
			{
				double _cos = x - b.first;
				double _sin = sqrt(r * r - _cos * _cos);
				if (rh) h0 = b.second - _sin, h1 = a.second + (x - a.first) * k + c1 * r;
				else h0 = a.second + (x - a.first) * k - c1 * r, h1 = b.second + _sin;
			}
			else
			{
				h0 = a.second + (x - a.first) * k - c1 * r, h1 = a.second + (x - a.first) * k + c1 * r;
			}
		}
		return res;
	}
	bool operator<(const Line& e) // 排序用，勿动
	{
		auto& a = vertexes[this->a], & b = vertexes[this->b];
		auto& c = vertexes[e.a], & d = vertexes[e.b];
		return (a.first < c.first) || ((a.first == c.first) && (a.second < c.second));
	}
};
std::vector<Line> segments;
```

#### 积分过程 Procedure

```cpp
std::sort(segments.begin(), segments.end());
std::cin >> r >> p1 >> p2 >> p3 >> p4;
//p1 *= 0.1; // 没啥用，因为已经很精确了
dx = p1 * 0.00001, left -= r; // 初始化
std::vector<Line*> ctx; // 上下文数组
std::vector<std::pair<double, double>> hs; // h, dx
for (i = 0; i < segments.size(); i++)
{
	ctx.emplace_back(&segments[i]);
	while (ctx.size())
	{
		if (i + 1 < segments.size() && left + r >= vertexes[ctx.end()[-1]->a].first) break; // 防止丢元素，确保所有线段的起点都大于 left + r
		if (left + r < vertexes[ctx[0]->a].first) left = vertexes[ctx[0]->a].first - r; // 跳过空白
		std::vector<Interval> intervals; // 区间数组
		for (j = 0; j < ctx.size(); j++) // TODO(i = 11, ctx.size() = 1?)
		{
			auto& e = ctx[j];
			double h0, h1;
			if ((j < ctx.size() && (!e->height(left, h0, h1) || (intervals.emplace_back(h0, h1), false))) && vertexes[ctx[j]->b].first + r < left) ctx.erase(ctx.begin() + j--);
		}
		std::sort(intervals.begin(), intervals.end());
		for (j = 0; j + 1 < intervals.size(); j++)
		{
			bool loop = true;
			while (loop) // 区间合并
			{
				loop = false;
				while (j + 1 < intervals.size() && intervals[j].a == intervals[j + 1].a) intervals.erase(intervals.begin() + j + 1), loop = true;
				while (j + 1 < intervals.size() && intervals[j].b > intervals[j + 1].a) intervals[j].b = std::max(intervals[j].b, intervals[j + 1].b), intervals.erase(intervals.begin() + j + 1), loop = true;
			}
		}
		double h = 0.0;
		for (const auto& e : intervals) h += e; // 区间有个 double operator(), 自动转成 b - a 即区间的大小
		left += dx;
		if (hs.size() > 2)
		{
			// 解二次多项式函数的参数 A * x^2 + B * x + C = h
			auto Q = Quadratic(hs[(k + 0) % 3].second, hs[(k + 0) % 3].second + hs[(k + 1) % 3].second, hs[(k + 0) % 3].first, hs[(k + 1) % 3].first, hs[(k + 2) % 3].first);
			// 二次函数积分，这里就不贴代码了，过于简单了
			S += Q.S();
			// 这个位置没用了，用新数据替换掉
			hs[(k + 0) % 3].first = h, hs[(k + 0) % 3].second = dx;
			// 更新 dx, A 绝对值越大 dx 就得越小，具体原理一时半会讲不明白，可以评论问; 1000 可以微调，不小于 100 应该都没大问题
			dx = p1 / (1.0 + abs(Q.A * dx) * 1000);
			// 那个新数据存到哪里了？
			k = (k + 1) % 3;
		}
		else
		{
			hs.emplace_back(h, dx); // 数据不够，先攒着
		}
		if (!k) printf("%.16lf/%.16lf\r", left, right); // 输出进度，看着舒服
	}
}
if (hs.size() > 1) S += (hs[(k + 0) % 3].first + hs[(k + 1) % 3].first) * (hs[(k + 0) % 3].second + hs[(k + 1) % 3].second) * 0.5; // 别漏掉最后一个小区间
printf("\n%.16lf", S);
```

#### 写在最后

我封装的那个 ```Line``` 类一开始就不是为了让人看懂的，所以如果实在看不懂可以提 issue, 我也许会补充一下，你们也可以自己推导计算的方法，就不用看我的垃圾代码了【捂脸】


---


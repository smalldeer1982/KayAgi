# [CTSC2008] 祭祀

## 题目描述

在遥远的东方，有一个神秘的民族，自称 Y 族。他们世代居住在水面上，奉龙王为神。每逢重大庆典，Y 族都会在水面上举办盛大的祭祀活动。我们可以把 Y 族居住地水系看成一个由岔口和河道组成的网络。每条河道连接着两个岔口，并且水在河道内按照一个固定的方向流动。显然，水系中不会有环流（下图描述一个环流的例子）。

 ![](https://cdn.luogu.com.cn/upload/pic/15479.png)

由于人数众多的原因，Y 族的祭祀活动会在多个岔口上同时举行。出于对龙王的尊重，这些祭祀地点的选择必须非常慎重。准确地说，Y 族人认为，如果水流可以从一个祭祀点流到另外一个祭祀点，那么祭祀就会失去它神圣的意义。族长希望在保持祭祀神圣性的基础上，选择尽可能多的祭祀的地点。

## 说明/提示

$N \le 100, M \le 1000$

在样例给出的水系中，不存在一种方法能够选择三个或者三个以上的祭祀点。包含两个祭祀点的测试点的方案有两种：

选择岔口 $1$ 与岔口 $3$（如样例输出第二行），选择岔口 $1$ 与岔口 $4$。

水流可以从任意岔口流至岔口 $2$。如果在岔口 $2$ 建立祭祀点，那么任意其他岔口都不能建立祭祀点但是在最优的一种祭祀点的选取方案中我们可以建立两个祭祀点，所以岔口 $2$ 不能建立祭祀点。对于其他岔口至少存在一个最优方案选择该岔口为祭祀点，所以输出为 `1011`。

感谢@ACdreamer 提供SPJ

## 样例 #1

### 输入

```
4 4
1 2
3 4
3 2
4 2```

### 输出

```
2
1010
1011```

# 题解

## 作者：小粉兔 (赞：74)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/12238880.html](https://www.cnblogs.com/PinkRabbit/p/12238880.html)。

### 题意简述：

给定一个 $n$ 个点，$m$ 条边的简单有向无环图（DAG），求出它的最长反链，并构造方案。

最长反链：一张有向无环图的最长反链为一个集合 $S \subseteq V$，满足对于 $S$ 中的任意两个不同的点 $u, v \in S$（$u \ne v$），$u$ 不能到达 $v$，$v$ 也不能到达 $u$，且 $S$ 的大小尽量大。

### 题解：

根据 Dilworth 定理，一个 DAG 中最长反链的大小，等于其最小链划分的大小。

最小链划分：在 DAG 中选出若干条链，每个点恰好属于其中一条链，且链数尽量少。  
（这里的“链”可能与传统理解不同，请看下面的注释。）

> 需要注意的是，这里对“链”的定义，**不需要**是 DAG 中连续的一条链，只需要前一个点能通过路径到达后一个点即可。你也可以理解为：一条连续的链，**挖掉**中间的一些点，形成的点集也算作“链”。
>
> 另一个理解方式是：这里的“链划分”要求每个点**不重不漏**地属于一条链；但也可以理解为，链一定要是连续的，并且允许多条链重复经过同一个点，只需要保证每个点都被经过即可。（以这种角度去理解，可以称之为**最小“可重链覆盖”**。）
>
> 这两种理解方式（即 (1) **最小链划分** 和 (2) **最小可重链覆盖**）是等价的，只不过前者的链可以跳过中间的点。

在后文中，给出一种使用二分图匹配求 DAG 中的**最小不可重链覆盖**的方法。为了别求错，我们需要先对 DAG 求一次传递闭包，把 $u$ 能间接到达 $v$ 的点对之间的边 $u \to v$ 建出来，这样就把“可重链覆盖”转化为“不可重链覆盖”了。

> 注释：Dilworth 定理原本的描述是对于偏序集来说的。你可以将偏序集理解为“求过传递闭包的 DAG”，于是“可重”或“不可重”就无所谓了。

在这里大费周章地解释，就是为了提醒各位，求最长反链的时候，不要忘记对 DAG 求传递闭包。

---

这里给出使用二分图匹配求最小不可重链覆盖的方法。

考虑从每个点自成一条链的形态出发，此时恰好有 $n$ 条链。  
可以发现最终答案一定是合并（首尾相接）若干条链形成的。考虑重新描述这个过程：  
对于一个点，它在最终的链上，一定只有最多一个前驱，和最多一个后继。  
我们考虑把每个点拆成入点和出点，那么入点和出点应该只能匹配上最多一个点（表示前驱或者后继）。

这似乎是二分图匹配的形式，具体地，我们考虑：  
把一个点 $x$ 拆成两个点：$x_{out}$ 和 $x_{in}$，表示出点和入点。  
对于一条边 $x \to y$，连接 $x_{out}$ 与 $y_{in}$，表示原图中 $x$ 的出边指向 $y$（这条边是 $y$ 的入边）。  
那么最终形成了一个二分图，左侧是所有 $x_{out}$，右侧是所有 $x_{in}$。而且所有边都是连接左侧的点和右侧的点的。

在这个二分图 $G = \langle \langle V_{out}, V_{in} \rangle , E' \rangle$ 上做二分图最大匹配：  
每一个匹配边 $x_{out} \leftrightarrow y_{in}$ 都可以还原原图中链的一条边 $x \to y$。  
每匹配 $1$ 条边，链的个数就减少 $1$，则有最小链覆盖的大小等于 $n$ 减去最大匹配的大小。

继续考虑如何从二分图最大匹配中，构造出最长反链。以下部分参考了 [r_64 的题解](http://r-64.blog.uoj.ac/blog/623)。

我们首先需要构造二分图最大独立集，这部分参考了[「图的最大匹配算法」](https://www.cnblogs.com/jianglangcaijin/p/6035945.html)这篇博客：

考虑下图，可以求出它的其中一种最大匹配为 $\{ \langle 2, D \rangle, \langle 3, E \rangle, \langle 4, A \rangle, \langle 5, C \rangle \}$，设最大匹配大小为 $m$，这里 $m = 4$：

![](https://cdn.luogu.com.cn/upload/image_hosting/e63s88i4.png)

从右侧的非匹配点（这里为 $B$，可能有多个）开始 DFS，右侧的点只能走**非匹配边**向左访问，左侧的点只能走**匹配边**向右访问：

![](https://cdn.luogu.com.cn/upload/image_hosting/izomyfkm.png)

可以发现 DFS 到了 $3, 5, B, C, E$ 这些点。

我们取左侧被 DFS 到的点，以及右侧没被 DFS 到的点，也就是 $3, 5, A, D$ 这些点，记做集合 $S$，可以证明 $S$ 是一个最小点覆盖。  
**最小点覆盖**：选取最少的点，覆盖每条边，也就是说每条边的两个端点至少有一个被选中了。

**证明：**

1. 首先有：最小点覆盖等于最大匹配。我们可以证明 $|S| = m$。  
这是因为：右侧的非匹配点一定都被 DFS 到了，所以在右侧选取的必然是匹配点。如果一个右侧的匹配点没被选取，即它被 DFS 到了，而这只有可能是因为它在左侧匹配到的点被 DFS 到了，那么左侧匹配到的点就会被选上。即是：**每条匹配边的两端点恰好会被选一个**。而左侧的非匹配点一定不会被 DFS 到，这是因为如果被 DFS 到了，必然会形成一条**交错路**（匈牙利算法中的），不满足最大匹配的条件。所以有且仅有匹配边的端点会被选上，而且每条匹配边的两端点恰好被选一个，所以 $\boldsymbol{|S| = m}$。

2. $S$ 可以覆盖所有的边。  
我们把边按照左右端点是否被 DFS 到，分成 $2 \times 2 = 4$ 类。那么如果出现了左端点没被 DFS 到，但是右端点被 DFS 到了的边，它才不会被覆盖。然而这是不可能的，这是因为对于一个右侧被 DFS 到的点，与它相连的左侧的点一定都被 DFS 到了。

然后有最大独立集等于最小点覆盖的补集。也就是只要选出左侧没被 DFS 到的点和右侧被 DFS 到的点就行了。  
在上图中就是 $1, 2, 4, B, C, E$ 这 $6$ 个点。

---

回到 DAG 的情况（注意到我们举的例子并不是 DAG 导出的二分图，所以这个例子不能用来解释最长反链）：

令最大独立集为 $I$，考虑选出所有 $x_{out}$ 和 $x_{in}$ 都属于 $I$ 的点，记做集合 $A$，它们构成一个最长反链。

**证明：**  
先证 $A$ 的确是一个反链：这是容易的，因为任取 $x \in A$，$x_{in}$ 就一定是被 DFS 到的点，而 $x_{out}$ 一定是没被 DFS 到的点，任何两个 $x, y \in A$ 之间若是有连边就和 DFS 的过程冲突了。  
首先有 $|I| = 2n - |S| = 2n - m$，而 $|I| - |A|$ 可以看作是满足「$x_{out}$ 或 $x_{in}$ 属于 $I$」的 $x$ 的个数，显然这样的 $x$ 不会超过 $n$ 个，所以 $|I| - |A| \le n$，所以 $|A| \ge |I| - n = n - m$。  
但是 $A$ 再大，也不能大过 $n - m$，所以 $|A| = n - m$，也就是一个最长反链。

**总结**——只要选出 $x_{out}$ 没被 DFS 到，且 $x_{in}$ 被 DFS 到了的点，这些点就组成一个最长反链。

---

然后是第三问，这只要默认该点被选中，也就是删除这个点和与其有偏序关系的所有点后，再求一次最长反链，如果最长反链的大小只减小了 $1$，那么这个点就能在最长反链中，否则不能。

下面是代码，复杂度为 $\mathcal O (n^{3.5})$：

```cpp
#include <cstdio>
#include <algorithm>
#include <bitset>

namespace Dinic {
	const int Inf = 0x3f3f3f3f;
	const int MN = 205, MM = 5155;
	
	int N, S, T;
	int h[MN], iter[MN], nxt[MM * 2], to[MM * 2], w[MM * 2], tot;
	
	inline void Init(int _N) {
		N = _N, tot = 1;
		for (int i = 1; i <= N; ++i) h[i] = 0;
	}
	inline void SetST(int _S, int _T) { S = _S, T = _T; }
	
	inline void ins(int u, int v, int x) { nxt[++tot] = h[u], to[tot] = v, w[tot] = x, h[u] = tot; }
	inline void insw(int u, int v, int w1 = Inf, int w2 = 0) {
		if (!u) u = S; if (!v) v = T;
		ins(u, v, w1), ins(v, u, w2);
	}
	
	int lv[MN], que[MN], l, r;
	
	inline bool Lvl() {
		for (int i = 1; i <= N; ++i) lv[i] = 0;
		lv[S] = 1;
		que[l = r = 1] = S;
		while (l <= r) {
			int u = que[l++];
			for (int i = h[u]; i; i = nxt[i])
				if (w[i] && !lv[to[i]]) {
					lv[to[i]] = lv[u] + 1;
					que[++r] = to[i];
				}
		}
		return lv[T] != 0;
	}
	
	int Flow(int u, int f) {
		if (u == T) return f;
		int d = 0, s = 0;
		for (int &i = iter[u]; i; i = nxt[i])
			if (w[i] && lv[to[i]] == lv[u] + 1) {
				d = Flow(to[i], std::min(f, w[i]));
				f -= d, s += d;
				w[i] -= d, w[i ^ 1] += d;
				if (!f) break;
			}
		return s;
	}
	
	inline int DoDinic() {
		int Ans = 0;
		while (Lvl()) {
			for (int i = 1; i <= N; ++i) iter[i] = h[i];
			Ans += Flow(S, Inf);
		}
		return Ans;
	}
}
using Dinic::Init;
using Dinic::SetST;
using Dinic::insw;
using Dinic::DoDinic;
using Dinic::h;
using Dinic::nxt;
using Dinic::to;
using Dinic::w;

const int MN = 105;

int N, M, Ans;
std::bitset<101> g[MN];

int match[MN], tagl[MN], tagr[MN];
void DFS(int u) {
	tagr[u] = 1;
	for (int i = 1; i <= N; ++i)
		if (g[i][u] && !tagl[i])
			tagl[i] = 1, DFS(match[i]);
}

int main() {
	scanf("%d%d", &N, &M);
	for (int i = 1; i <= M; ++i) {
		int x, y;
		scanf("%d%d", &x, &y);
		g[x][y] = 1;
	}
	for (int k = 1; k <= N; ++k)
		for (int i = 1; i <= N; ++i)
			if (g[i][k]) g[i] |= g[k];
	Init(N + N + 2), SetST(N + N + 1, N + N + 2);
	for (int i = 1; i <= N; ++i)
		insw(0, i, 1), insw(N + i, 0, 1);
	for (int i = 1; i <= N; ++i)
		for (int j = 1; j <= N; ++j)
			if (g[i][j]) insw(i, N + j, 1);
	Ans = N - DoDinic();
	printf("%d\n", Ans);
	for (int i = 1; i <= N; ++i) if (!w[4 * i - 2]) {
		for (int j = h[i]; j; j = nxt[j])
			if (!w[j]) { match[i] = to[j] - N; break; }
	}
	for (int i = 1; i <= N; ++i) if (w[4 * i]) DFS(i);
	for (int i = 1; i <= N; ++i) printf("%d", !tagl[i] && tagr[i]);
	puts("");
	for (int u = 1; u <= N; ++u) {
		static int del[MN]; int cnt = 0;
		for (int i = 1; i <= N; ++i) del[i] = i == u || g[i][u] || g[u][i];
		Init(N + N + 2), SetST(N + N + 1, N + N + 2);
		for (int i = 1; i <= N; ++i) if (!del[i])
			insw(0, i, 1), insw(N + i, 0, 1), ++cnt;
		for (int i = 1; i <= N; ++i) if (!del[i])
			for (int j = 1; j <= N; ++j) if (!del[j])
				if (g[i][j]) insw(i, N + j, 1);
		printf("%d", cnt - DoDinic() == Ans - 1);
	} puts("");
	return 0;
}
```

---

## 作者：Piwry (赞：63)

话说第二问还有另外一种求法...比起我当前看到的这些题解的方法都要更好描述和证明，并且简单改改就能算出方案数...具体可以看下面。

其他两问的方法已经被讲过很多次了...那我对于这部分就只尝试给出一个逻辑较为清晰的回答（尽我所能的规范化构造问题...），希望能理理读者的思路QWQ

~~（我的题解肯定是没人点赞的所以看到这的肯定是翻到最底端的（暴论）~~

~~（怎么最近老是喜欢打省略号...）~~

## Question 1.

题目要求我们求一个 $\text{DAG}$ 的最大独立点集。如果我们把 $a$ 能够到达 $b$ 抽象成一个偏序关系的话，就可以把要求转化为求偏序集的最大反链。根据 $\text{Dilworth}$ 定理，这实际上就是要求我们求最少链划分，而这对应到 $\text{DAG}$ 上就是求最少**可重**链覆盖。

但一般来说直接求可重链覆盖是不那么好求的...（~~其实这是一个根据 "结果" 得出的结论QAQ~~）先考虑怎么把问题转化为不可重链覆盖。

发现当我们将问题抽象到偏序集时，对于该偏序集的关系全集 $R$ 实际上无法和 $\text{DAG}$ 的边集 $E$ **一一对应**。（例如有 $E=\{(a, b), (b, c)\}$，我们就可以有 $R=\{(a, b), (b, c), (a, c)\}$）

于是我们就要已知 $E$ 而求出 $R$（或者说 "补全" $E$），这也可以叫做**求传递闭包**。具体操作可以发现全集 $R$ 对于 $\text{DAG}$ 的意义就是所有可以单向到达的点对，这可以用 $\text{Floyd}$ 算法 $O(n^3)$ 地求出它：

```cpp
/*map 储存初始图信息（是否有边）*/
for(int k =1; k <= n; ++k)
	for(int i =1; i <= n; ++i)
		for(int j =1; j <= n; ++j)
			if(map[i][k] && map[k][j]) map[i][j] =1;
```

接下来只需求出 $\text{DAG}$ 的最小不可重链覆盖数就可以了。

我们根据（求闭包后的）原图构造一个二分图：将每个点 "分裂" 成两个点 $x, x'$，若有一条边 $(x, y)$，我们将它重连接为 $(x, y')$：

（命名有点不一样...）

![1](https://cdn.luogu.com.cn/upload/image_hosting/ifpg4b1o.png)

而不可重链覆盖实际上就是把原图划分为一条条**链（图意义下）**，可以想象为：一个 $n$ 个点的 $\text{DAG}$ 一开始有 $n$ 条链（一个点为一条）；我们一条条，并尽可能多地选边使剩下的链数目尽量少，同时要求一个点**最多有一条出边一条入边**（满足链要求）。这实际上就和求转化的二分图的最大匹配的意义一致：对应原图同一编号的点最多被匹配两次，并尽可能多地选边。

每匹配一条边，就相当在原图取一条边，就能使链数目减少一；于是答案（最小不可重链覆盖数）就等于 $\text{原图点数目} - \text{最大匹配数}$。

## Question 3.
######  _由于问题二需要问题三的答案，就先讲问题三了。_ 

我们考虑原图（已求闭包）中一个点对于独立集划分的状态。有两种情况：

1. 这个点和所有和这个点有关系的点组成的点集是原图的一条链（**偏序集意义下**）。
2. 这个点和所有和这个点有关系的点组成的点集既不是原图的一条链，也不是原图的一条反链。

（为了看着清楚，下图**没有把闭包的** "边" 加上去）

![2](https://cdn.luogu.com.cn/upload/image_hosting/uls4aqz1.png)

对于 `情况1`，无论如何我们只能在这条链中选一个点，因此这个点是可选的（**最优**），且删去该点集显然会使答案减少一；对于 `情况2`，我们是有可能将这个点集划分为多条链（"多个" `情况1`），因此选这个点**不是最优**的，且删去个点集使答案的减量显然大于一。

那么我们就可以枚举删去点集，重新求答案，并比较新答案与原始答案的差值来确定某个点是否可选。

## Question 2.

回想一下我们在 $\text{Question 3}$ 提到的情况一：

>对于 `情况1`，无论如何我们只能在这条链中选一个点。

因此我们可以将一个可选点的所有和它有关系的**可选点**染色，这些同一颜色的可选点我们至多只能选一个。对于每种颜色，我们只要随便选一个点（比如第一个找到的）就可以组成一种可行的方案了。同时由于这种做法求出了每个可选点之间的关系，我们还可以求出**所有可行的最大独立集方案数目**。

## CODE

```cpp
#include <cstdio>
#include <cstring>

const int MAXN =110, MAXM =1010;

/*------------------------------Map------------------------------*/

int n, m;
bool map[MAXN][MAXN];
bool vis[MAXN], isdel[MAXN];
int lk[MAXN];

bool match(int x){/*我比较菜 QAQ，用的是匈牙利求法*/
	if(x == 0) return 1;
	for(int y =1; y <= n; ++y) if(map[x][y] && !vis[y]){
		if(isdel[y]) continue;
		vis[y] =1;
		if(!lk[y] || match(lk[y])){
			lk[y] =x;
			return 1;
		}
	}
	return 0;
}

int col[MAXN];
bool able[MAXN], chose[MAXN];

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	n =read(), m =read();
	for(int i =1; i <= m; ++i){
		int x =read(), y =read();
		map[x][y] =1;
	}
	/*Floyd*/
	for(int k =1; k <= n; ++k) for(int i =1; i <= n; ++i) for(int j =1; j <= n; ++j)
		if(map[i][k] && map[k][j]) map[i][j] =1;
	int cntm =0;
	for(int i =1; i <= n; ++i){
		memset(vis, 0, sizeof(vis));
		if(match(i)) ++cntm;
	}
	printf("%d\n", n-cntm);/*原图点数目 - 最大匹配数*/
	for(int rt =1; rt <= n; ++rt){
		memset(isdel, 0, sizeof(isdel)), memset(lk, 0, sizeof(lk));
		int cntm2 =0, nn =n;
		for(int i =1; i <= n; ++i) if(map[i][rt] || map[rt][i] || i == rt) isdel[i] =1, --nn;
		for(int i =1; i <= n; ++i){
			if(isdel[i]) continue;
			memset(vis, 0, sizeof(vis));
			if(match(i)) ++cntm2;
		}
		able[rt] =(nn-cntm2 == (n-cntm)-1);/*是情况一*/
	}
	int COL =0;
	for(int i =1; i <= n; ++i) if(able[i] && !col[i]){
		++COL;
		chose[i] =1;/*选第一个碰到的*/
		/*这里染色比较随意...反正染了不可选点也没影响*/
		for(int j =1; j <= n; ++j) if(map[j][i] || map[i][j] || j == i) col[j] =COL;
	}
	for(int i =1; i <= n; ++i) if(chose[i]) putchar('1'); else putchar('0');
	putchar('\n');
	for(int i =1; i <= n; ++i) if(able[i]) putchar('1'); else putchar('0');
}
```


## Question 2*.

这里再讲下其他题解里的做法。

先求出（转化后的）二分图的任意一组最大匹配。我们 $\text{dfs}$ 左边所有未匹配的点，每次 $\text{dfs}$ 从左往右只走未匹配边，从右往左则只走匹配边（注意最后的搜索树可能不止是一条链，也可能**是一棵树**。也就是说要 $\text{dfs}$ 当前可找到的**所有**未匹配边）。

二分图的一种最小点覆盖就是**左侧的未访问点加上右侧的已访问点**；二分图的一种最大独立集就是这些点的补集（对于二分图所有点全集）；而原图的一种最大独立集就是由所有其编号对应的二分图**左侧点和右侧点都在二分图最大独立集中**的点组成（或者说由所有其编号对应的二分图**左侧点已访问且右侧点未访问**的点组成）。

（上面的话都有点绕...建议多读几次）

现在先来证明**为什么这种划分是二分图的一种最小点覆盖**。

首先显然最小点覆盖数加最大独立集数 **或** 二分图的最大匹配数加最小链划分数（想想 $\text{Question 1}$）等于点数，而根据 $\text{Dilworth}$ 定理有最大独立集数等于最小链划分数，因此二分图的最大匹配数等于最小点覆盖数。

而且我们有：

1. 该划分在数值上等于最大匹配。因为所有匹配边的端点要么同时被访问过，要么都没被访问过（对于左边的未匹配点，我们的方法**保证被访问过**，它们**不会被计入答案**）。

2. 该划分可以覆盖所有的边。**如果**这是一条匹配边，由于匹配边的两端被访问的状态是**一样的**，因此这条边保证被覆盖；**如果**这是一条未匹配边，**若**其左端点未被匹配，那么它右端点一定会被访问；**若**其右端点未被匹配，那么**对于**其左端点（已和其他右端点匹配）未被访问（此时右端点也不会被访问），这条边会被左端点覆盖；**对于**其左端点被访问，右端点也一定被访问，这条边会被右端点覆盖。

因此可以说这种划分就是二分图的一种最小点覆盖。

（此段证明参考了 [zsy](https://www.cnblogs.com/zhoushuyu) 的 [证明](https://cdn.luogu.com.cn/upload/image_hosting/0ivksiuh.png)，感谢）

接着我们再考虑**为什么其编号对应的左侧点和右侧点都在二分图最大独立集中的点集就是原图的一种最大独立集划分**。~~（好长...）~~

（符号 $|.|$ 表示一个集合的元素数）

设二分图最小点覆盖 $S$，最大独立集 $I$，再设 $A$ 由所有编号对应的二分图左右点都在 $I$ 中的原图点（或二分图点，这里不太严谨~~感性~~理解下...）组成（我们要证它是原图的一种最大独立集划分 ~）。最后设原图点数 $n$。

首先有 $|I|=2n-|S|$，这很显然。

而$|I|-|A|$ 可以看做是满足「编号对应的二分图左端点**或**右端点**之一** $\in I$」的点数目，显然这样的点最多不会超过 $n$ 个，所以有 $|I|-|A|\leqslant n$，即 $|A|\geqslant n-|S|$。

显然原图的独立集最大也就是 $n-|S|$。同时由于 $A$ 是二分图最大独立集的子集，也可以知道 $A$ 不论在二分图**还是原图**都是一个独立集。所以 $A$ 就是原图的一种最大独立集划分。

（此段证明参考了 [小粉兔](https://www.luogu.com.cn/user/10703) 的 [证明](https://www.luogu.com.cn/blog/PinkRabbit/solution-p4298)后段，感谢）

---
#### 另：

关于这种~~极其麻烦~~的构造方式，最初的来源应该是由 Dénes Kőnig 证明的 [$\text{Kőnig}$ 定理](https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory))（或[百度百科](https://baike.baidu.com/item/%E6%9F%AF%E5%B0%BC%E5%B8%8C%E5%AE%9A%E7%90%86/19584092#viewPageContent)，但说实话没维基准确）的[证明方式](https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)#Proof)。

首先，这个定理表明了 **二分图的最大匹配数等于其最小点覆盖数** ；然后，其证明方式**实际上就是**我们程序实现的求二分图最小点覆盖方案的方法。

（至于他怎么想到的我也不知道...~~%%%~~ 但这里得说明下 $\text{Dilworth}$ 定理是在这个证明**后**约 $\text{20}$ 年才被证出来的）

（查证路线：[小粉兔题解](https://www.luogu.com.cn/blog/PinkRabbit/solution-p4298) -> [r_64题解](http://r-64.blog.uoj.ac/blog/623) -> [stackoverflow](https://stackoverflow.com/questions/23858530/how-can-i-get-the-antichain-elements-in-spoj-divrel) -> [维基](https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory))）

## CODE*

```cpp
#include <cstdio>
#include <cstring>

const int MAXN =110, MAXM =1010;

/*------------------------------Map------------------------------*/

int n, m;
bool map[MAXN][MAXN];
bool vis[MAXN], isdel[MAXN];
int lk[MAXN];

bool match(int x){/*还是匈牙利 QWQ*/
	if(x == 0) return 1;
	for(int y =1; y <= n; ++y) if(map[x][y] && !vis[y]){
		if(isdel[y]) continue;
		vis[y] =1;
		if(!lk[y] || match(lk[y])){
			lk[y] =x;
			return 1;
		}
	}
	return 0;
}

bool flg[2][MAXN]/*1是 x（左），0是 y；表示是否访问*/, xused[MAXN]/*左端点是否匹配*/;

void dfs(int u){
	flg[1][u] =1;
	for(int y =1; y <= n; ++y) if(map[u][y] && lk[y] != u && !flg[0][y]/*搜过的再搜也没意义...其实这个条件随便啦*/){
		flg[0][y] =1;
		if(lk[y] != 0) dfs(lk[y]);
	}
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	n =read(), m =read();
	for(int i =1; i <= m; ++i){
		int x =read(), y =read();
		map[x][y] =1;
	}
	for(int k =1; k <= n; ++k) for(int i =1; i <= n; ++i) for(int j =1; j <= n; ++j)
		if(map[i][k] && map[k][j]) map[i][j] =1;
	int cntm =0;
	for(int i =1; i <= n; ++i){
		memset(vis, 0, sizeof(vis));
		if(match(i)) ++cntm;
	}
	printf("%d\n", n-cntm);
	
	/*这里开始处理第二问*/
	for(int i =1; i <= n; ++i) xused[lk[i]] =1;
	for(int i =1; i <= n; ++i) if(!xused[i]) dfs(i);
	/*下面判断按题解中的定义*/
	for(int i =1; i <= n; ++i) if(!flg[1][i] || flg[0][i]) putchar('0'); else putchar('1');
	/*又可以写作：if(!(flg[1][i] && !flg[0][i])) putchar('1'); else putchar('0');*/
	
	putchar('\n');
	for(int rt =1; rt <= n; ++rt){
		memset(isdel, 0, sizeof(isdel)), memset(lk, 0, sizeof(lk));
		int cntm2 =0, nn =n;
		for(int i =1; i <= n; ++i) if(map[i][rt] || map[rt][i] || i == rt) isdel[i] =1, --nn;
		for(int i =1; i <= n; ++i){
			if(isdel[i]) continue;
			memset(vis, 0, sizeof(vis));
			if(match(i)) ++cntm2;
		}
		printf("%d", (nn-cntm2 == (n-cntm)-1));
	}
}
```

话说 $\text{Question 2}$ 两种方法的复杂度**都可以是** $O(n+m)$ （$m$ 基于**求传递闭包后**的关系数）的QWQ

---

能看到后面这一小段字的肯定是（~~大概？~~）认真看完全篇了QWQ。虽然在开头说了要尽量 "规范化构造问题"，但由于解析太长导致我写着写着就不设符号全文字了QAQ（于是就能看到一些极长的命题...），~~现在写完看篇幅太大就懒得改了（bushi~~。不过我还是尽量让文字表达的意思**准确**没有异议了，如果哪段看不懂多读几次一定能理解www（我可是把自己思考时遇到的坑点都事无巨**细**地写进去惹）。

~~（虽然代码挺好写，但这题的思路可真是毒瘤...（~~

---

## 作者：_鱼非仙_ (赞：27)

前置知识: 称有向图 $G = (V, E)$ 的子图 $H \subset G$ 是**闭合子图**, 如果 $\forall (u, v) \in E, (u \in H \Rightarrow v \in H)$. 现每一点 $u$ 有一整数点权 $w_u$, 且子图的权值为子图中所有点权之和, 求该无环图的**最大权闭合子图**, 可以用网络流解决. 

第一问可以转化为最大权闭合子图问题. 在新图中将点 $u$ 拆为 $u_1, u_2$, **点权**分别为 $-1$ 和 $1$, 同时连边 $(u_1, u_2)$. 对原图中的一条有向边 $(u, v)$, 在新图中连边 $(u_2, v_1)$. 对新图求最大权闭合子图, 即为第一问的答案.

设新图是 $G$, $H \subset G$ 是 $G$ 的一个最大权闭合子图. 那么这张图对应的方案中, 点 $u$ 可以作为祭祀点当且仅当 $u_1 \notin H \land u_2 \in H$.

对第二问, 相当于构造出一个最大权闭合子图. 在最大权闭合子图问题中, 一个最大权闭合子图 $H \subset G$ 可以唯一对应所构图的一个最小割 $(S, T)$,  其中 $u \in H \Leftrightarrow u \in T \land (\forall (v, u) \in E, v \in S)$. 据此可以先构造出最小割, 再构造方案.

第三问相当于对每个 $u$, 判断是否存在最小割 $(S, T)$, 使得 $u_1 \in S \land u_2 \in T$. 注意到割 $(S, T)$ 是最小割当且仅当在残量网络中, $S$ 是闭合子图, 即 $\forall (u, v) \in \text{残量网络}, (u \in S \Rightarrow v \in S)$. 令 $f(u, v)$ 表示残量网络中是否存在 $u$ 到 $v$ 的路径. 那么存在最小割 $(S, T)$, 使得 $u_1 \in S \land u_2 \in T$ 的等价条件是 $\lnot f(s, u_2) \land \lnot f(u_1, u_2) \land \lnot f(u_1, t)$, 其中 $s$ 和 $t$ 是网络中的源汇点.

本做法只需跑一遍网络流, 由于边权均为 $1$ 或 $+\infty$, 复杂度为 $\mathcal O(m \sqrt n + n \times (n+m)) = \mathcal O(nm)$.

下面是使用了 [AtCoder Library](https://github.com/atcoder/ac-library) 的参考代码.

```cpp
#include <cstdio>
#include <vector>
#include <atcoder/maxflow>
const int INF = 0x3F3F3F3F;

signed main() {
	int n, m;
	scanf("%d%d", &n, &m);
	atcoder::mf_graph<int> mf(n * 2 + 2);
	int S = 2 * n, T = S + 1;

	for (int i = 0; i < m; ++i) {
		int u, v;
		scanf("%d%d", &u, &v);
		--u; --v;
		mf.add_edge(u + n, v, INF);
	}

	for (int i = 0; i < n; ++i) {
		mf.add_edge(S, i + n, 1);
		mf.add_edge(i, T, 1);
		mf.add_edge(i, i + n, INF);
	}

	printf("%d\n", n - mf.flow(S, T));
	auto min_cut = mf.min_cut(S);
	for (int i = 0; i < n; ++i)
		putchar(!min_cut[i] && min_cut[i + n] ? '1' : '0');
	puts("");

	std::vector<std::vector<int> > e(2 * n + 2);
	for (auto o : mf.edges()) {
		if (o.cap != o.flow)
			e[o.from].push_back(o.to);
		if (o.flow)
			e[o.to].push_back(o.from);
	}
	std::vector<std::vector<int> > reach(2 * n + 2, std::vector<int>(2 * n + 2));

	for (int i = 0; i < 2 * n + 2; ++i) {
		std::queue<int> q;
		q.push(i);
		reach[i][i] = true;
		for (; !q.empty(); q.pop())
			for (auto to : e[q.front()])
				if (!reach[i][to]) {
					reach[i][to] = true;
					q.push(to);
				}
	}

	for (int i = 0; i < n; ++i)
		putchar(!reach[i + n][T] && !reach[i + n][i] && !reach[S][i] ? '1' : '0');
	puts("");
	return 0;
}
```

---

## 作者：ppip (赞：18)

一种可能更优秀的做法，来自 @[kradcigam](/user/180242)。

## 约定

给定一个有源汇网络，对于任意流函数 $f$，满足如下限制：

1. 容量限制：$f(u,v)\le c(u,v)$；
2. 流量平衡：除去 $s,t$ 以外 $f(u)=\sum_v f(u,v)=0$；
3. 反对称性：$f(u,v)=-f(v,u)$

称这个流的流量为 $|f|$，显然有 $f(s)=-f(t)=|f|$。

割 $\set{S,T}$ 的权值记为 $||S,T||$。

残量网络是一个新的网络 $G_f$，满足 $c_f(u,v)=c(u,v)-f(u,v)$。

## 最小割的方案

首先我们研究全体最小割方案的形态。

结论 1. 任取流函数 $f$ 以及割 $\set{S,T}$，有 $\sum_{x\in S,y\in T} f(x,y)=|f|$。

证明。显然有 $f(s)=\sum_{x\in S} f(x)=\sum_{x\in S,y\in T} f(x,y)$。

由此可以得到对于任意流 $f$ 和割 $\set{S,T}$，有 $|f|\le ||S,T||$。

结论 2. 一个割 $\set{S,T}$ 是最小割，当且仅当存在最大流 $f$，有 $\forall_{x\in S,y\in T}\ c_f(x,y)=0$。

证明。若存在 $c_f(x,y)\ne 0$，则根据结论 1 有 $|f|<||S,T||$，与最大流最小割定理矛盾。

并且注意到这一性质若对于某个最大流成立当且仅当其对于所有最大流成立。总之我们得到了有关最小割的三个两两等价的命题。

所以我们现在可以如此描述所有合法的最小割：任取最大流 $f$，全体合法的最小割等价于残量网络 $G_f$ 上全体大小为 $0$ 的割。

## 求解本题第三问

前置知识：最大权闭合子图。

首先我们对本题采用最大权闭合子图的转化：对每个点拆成 $(u_0,u_1)$，其点权分别为 $-1$ 和 $1$，入边全部改到 $u_0$，出边改到 $u_1$，然后求最大权闭合子图。

此时所有 $u_1$ 被选且 $u_0$ 未被选的点就是一组最长反链。

这里我们最大权闭合子图采用左部点为正权，右部点为负权的建模。

所以，要求解该点是否可以被选，则等价于求最大权闭合子图上，是否存在一组最小割，满足 $u_0\in T,u_1\in S$。

将其转化到残量网络上大小为 $0$ 的割，则相当于问残量网络上 $u_1$ 能否走 $c_f(u,v)>0$ 的边到 $u_0$，若能则这个点不能被选。

由于 $u_0$ 显然总是能到 $u_1$，这等价于这两个点在 $G_f$ 上属于一个强连通分量。可以在求出残量网络后 $O(n+m)$ 解决。

需要注意的是，需要先考虑 $u_0$ 是否和 $S$ 在同一个强连通分量，若是的话显然没有割使得 $u_0\in T$，$u_1$ 同理。

## 求解最小字典序答案

接下来所说的图都是由 $c_f(u,v)>0$ 的边组成的图。

先对此图缩点。现在把 $s$ 能到达的点以及能到达 $t$ 的点在最小割中的归属已经确定，标记它们。

从小到大枚举每个点，如果 可以令 $u_0 \in S,u_1 \in T$ 并且不违反已有的标记，并且两个点不在一个强连通分量，则把这个点加入答案，然后把 $u_0$ 可达的点标记为 $S$，把可达 $u_1$ 的点标记为 $T$；否则我们直接跳过这个点，显然此时不关心这两个点最终在最小割中的位置。

复杂度也是 $O(n+m)$。

现在整个问题需要求出任意一组最大流，之后的部分都是线性。我不会将此题上的最大流分析到优于 $O(nm)$ 的复杂度，如果有大手子会分析请私信！！！

---

## 作者：_meaningless_ (赞：13)

强势推销[$blog$](https://blog.csdn.net/zxyoi_dreamer/article/details/83017459)

本来各大$OJ$上这道题不需要输出方案的。~~虽然说原题需要~~ 

然后洛谷上的$dalao$果断的给出了$SPJ$。。。

于是就跑去学习了一下怎么输出方案。

显然第一个方案就是要求我们构造一个最大独立集。
显然考虑做最小点覆盖，即最大独立集的补集。

我们这样做：先找一个最大匹配，然后从左边点集中每一个没有被匹配到的点做假的增广，一路标记增广到的点。最后左边没有标记过的或右边标记过的就是最小点覆盖。取反就是最大独立集。

而第二个问要求哪些点能够出现在最大独立集里面。

其实这个做法有点巧妙，
枚举我们要考虑的点，删去它以及它的前驱后继，就是它能到和能到它的点。
然后再求一次最长反链。

如果说这样求出来的最长反链比原来的小1，那么选了他就可以替换掉原来的最长反链中的一个点（可能本来就是它自己）而保持最长反链的性质，它就能够出现在最长反链中。

就相当于是我们先在一条反链中选择了这个点，我们就不能选择它的相邻点，然而如果这样求出来剩余点集的最长反链只比原来少$1$，那么加上这个点就能够形成我们已经求出的最长反链。

由于我学习的是 yler%%%的题解，所以代码不可避免就有点学（借）习（鉴）了他的一些写法，顺便改了一下我效率不高的匈牙利。

---
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register
#define gc getchar
#define pc putchar
#define cs const

inline int getint(){
	re int num;
	re char c;
	while(!isdigit(c=gc()));num=c^48;
	while(isdigit(c=gc()))num=(num<<1)+(num<<3)+(c^48);
	return num;
}

cs int N=105;
int n;
bool g[N][N],to[N];
int match[N],idx;
int vis[N];
bool ban[N],s[N],t[N];

inline bool find(int u){
	if(ban[u])return false;
	for(int re v=1;v<=n;++v){
		if((vis[v]^idx)&&g[u][v]&&!ban[v]){
			vis[v]=idx;
			if(!match[v]||find(match[v])){
				to[u]=true,match[v]=u;
				return true;
			}
		}
	}
	return false;
}

inline void dfs(int u){
	if(s[u])return ;
	s[u]=true;
	for(int re v=1;v<=n;++v){
		if(g[u][v]&&!t[v])t[v]=true,dfs(match[v]);
	}
}

int m;
signed main(){
	n=getint(),m=getint();
	for(int re i=1;i<=m;++i){
		int u=getint(),v=getint();
		g[u][v]=1;
	}
	
	for(int re k=1;k<=n;++k)
	for(int re i=1;i<=n;++i)
	for(int re j=1;j<=n;++j)
	g[i][j]=g[i][j]||(g[i][k]&&g[k][j]);
	
	int ans=n;
	for(int re i=1;i<=n;++i){
		++idx;
		if(find(i))--ans;
	}
	printf("%d\n",ans);
	
	for(int re i=1;i<=n;++i)if(!to[i])dfs(i);
	for(int re i=1;i<=n;++i)printf("%d",s[i]&&!t[i]);
	pc('\n');
	
	for(int re k=1;k<=n;++k){
		memset(match,0,sizeof match);
		memset(to,0,sizeof to);
		memset(ban,0,sizeof ban);
		int tmp=0;
		
		for(int re i=1;i<=n;++i)
		if(g[i][k]||g[k][i]||i==k)ban[i]=true;
		else ++tmp;
		
		for(int re i=1;i<=n;++i){
			++idx;
			if(find(i))--tmp;
		}
		printf("%d",tmp==ans-1);
		
	}
	return 0;
}
```

---

## 作者：Cyhlnj (赞：11)

# 假的题解
## 前面的话

这道题显然就是最长反链

根据 $Dilworth$ 定理：最小链覆盖数 = 最长反链长度

然后传递闭包跑匹配即可

交了一下，$WA$ 了

$QAQ$

本来各种 $OJ$ 上都是只要求最长反链，不需要构造方案

~~虽然原题要构造~~

然后一名同志写了个 $SPJ$， 然后就要输出方案了

~~表示切不掉很难受~~

## Sol

先放两个博客:

[r_64](http://r-64.blog.uoj.ac/blog/623)

[某神仙](https://blog.csdn.net/yeziqing10/article/details/50651560)

首先建图后发现最大独立集和最小点覆盖互为补集

而这个图中的最大独立集就是最长反链~~可能，猜的...~~(因为两两不可到达)

然后只要知道怎么构造最小点覆盖就好了

### 第一步

对于一个二分图，这样来做：

> 先最大匹配

> 每次从左边找到一个未匹配点增广(假的增广，显然增广不了，因为已经是最大匹配)

> 然后标记经过的点

最后左边没有标记过的点和右边标记过的点就是最小点覆盖

伪证：因为一条假的增广路一定是左边的点作为开头和结尾的，所以选右边的就能覆盖这个假的增广路

去掉这些点就是要找的最长反链

### 第二步

找到所有可以出现在最长反链上的点

枚举每个点，删掉它以及可以到达它和它可以到达的点(邻居)

再求最长反链，如果大小减小了 $1$，这个点就是可以的(显然选这个点不会和当前的集合冲突)

### 代码

```cpp

# include <bits/stdc++.h>
# define IL inline
# define RG register
# define Fill(a, b) memset(a, b, sizeof(a))
using namespace std;
typedef long long ll;

IL int Input(){
    RG char c = getchar(); RG int x = 0, z = 1;
    for(; c < '0' || c > '9'; c = getchar()) z = c == '-' ? -1 : 1;
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
    return x * z;
}

const int maxn(205);
const int maxm(1005);

int n, m, ans, match[maxn], to[maxn], vis[maxn], idx, f[maxn][maxn], g[maxn][maxn];
int ban[maxn], s[maxn], t[maxn];

IL int Dfs(RG int u){
	if(ban[u]) return 0;
    for(RG int i = 1; i <= n; ++i)
        if(f[u][i] && vis[i] != idx && !ban[i]){
            vis[i] = idx;
            if(!match[i] || Dfs(match[i])){
                to[u] = i, match[i] = u;
                return 1;
            }
        }
    return 0;
}

IL void Calc(RG int u){
    if(s[u]) return;
    s[u] = 1;
    for(RG int i = 1; i <= n; ++i)
        if(f[u][i] && !t[i]) t[i] = 1, Calc(match[i]);
}

int main(RG int argc, RG char* argv[]){
    n = Input(), m = Input();
    for(RG int i = 1; i <= m; ++i) g[Input()][Input()] = 1;
    for(RG int i = 1; i <= n; ++i)
        for(RG int j = 1; j <= n; ++j)
            for(RG int k = 1; k <= n; ++k) g[j][k] |= g[j][i] & g[i][k];
	memcpy(f, g, sizeof(f)), ans = n;
    for(RG int i = 1; i <= n; ++i) ++idx, ans -= Dfs(i);
    printf("%d\n", ans);
    for(RG int i = 1; i <= n; ++i) if(!to[i]) Calc(i);
    for(RG int i = 1; i <= n; ++i) printf("%d", s[i] && !t[i]);
	puts("");
	for(RG int nw = 1; nw <= n; ++nw){
		for(RG int i = 1; i <= n; ++i) match[i] = to[i] = 0;
		RG int ret = 0, nn = 0;
		Fill(f, 0), Fill(ban, 0);
		for(RG int i = 1; i <= n; ++i)
			if(g[i][nw] || g[nw][i] || i == nw) ban[i] = 1;
			else ++nn;
		ret = nn;
		for(RG int i = 1; i <= n; ++i)
			for(RG int j = 1; j <= n; ++j)
				if(!ban[i] && !ban[j]) f[i][j] = g[i][j];
		for(RG int i = 1; i <= n; ++i) if(!ban[i]) ++idx, ret -= Dfs(i);
		printf("%d", ret == ans - 1);
	}
    return 0;
}

```


---

## 作者：louhao088 (赞：10)

简化题意：给一张 DAG，要求选出一个最大子集，使子集中元素两两不能到达。


------------


题目要求的是 DAG 中最长反链数。

根据 Dilworth 定理：最小链覆盖数 = 最长反链长度

我们就将其转换为求最小链覆盖数。

我们再将图转换，用 Floyd 处理图的连通性，若连通则为 $1$。再根据这个进行连边。

这样最小链覆盖就转换为最小路径覆盖。这是一个网络流解决的经典问题。

具体的我们可以拆点，然后求最大能接前后的数量，用 n 减去这个就是答案。




------------


然后我们先解决问题 3

判断一个点能否是最长反链上的点：我们可以删去这个点，以及他能连出去的点和能连到他的点。如果在这个图上跑最长反链数的得到的答案比原答案少 $1$ 则说明是。暴力判断每个点就可以了。 


------------


然后就是构造一组方案。

这个可以对于能成为最长反链上的点，我们进行染色，在每种颜色中随便选一个点就可以。

具体的，我们随便选一个未染色的点，对其染色，然后对其能到达的点和能到达其的点染上相同颜色。重复上述操作，我们随便选出的点就是一组构造。


------------
总复杂度 $O(n^3 \sqrt n)$ 



------------
代码如下

```cpp
// Problem: P4298 [CTSC2008]祭祀
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4298
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 2022-02-11 14:27:27
// Author : louhao088
// 

#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define pi pair<int,int>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define ls (rt<<1)
#define rs (rt<<1|1)
#define mid (l+r>>1)
#define lowbit (x&-x)
const int maxn=205,M=34005,inf=1e9;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
inline void print(int x)
{
    static int a[55];int top=0;
    if(x<0) putchar('-'),x=-x;
    do{a[top++]=x%10,x/=10;}while(x);
    while(top) putchar(a[--top]+48);
}
int n,m,f[maxn][maxn],F[maxn],flag[maxn],col[maxn],ans,x,y,b[maxn],o;
struct dinic
{
	int head[maxn],cnt,to[maxn*maxn],w[maxn*maxn],nex[maxn*maxn],s,t,dis[maxn],cur[maxn],maxflow;
	void add(int x,int y,int z){
	to[++cnt]=y,w[cnt]=z,nex[cnt]=head[x],head[x]=cnt;
	to[++cnt]=x,w[cnt]=0,nex[cnt]=head[y],head[y]=cnt;}
	void clear(){memset(head,0,sizeof head);cnt=1;memset(cur,0,sizeof cur);maxflow=0;}
	bool bfs()
	{
		memset(dis,-1,sizeof dis);
		queue<int>q;while(!q.empty())q.pop();
		q.push(s);cur[s]=head[s];dis[s]=0;
		while(!q.empty())
		{
			int x=q.front();q.pop();
			for(int i=head[x];i;i=nex[i])
			{
				if(w[i]&&dis[to[i]]==-1)
				{
					q.push(to[i]);dis[to[i]]=dis[x]+1;
					cur[to[i]]=head[to[i]];
				}
			}
		}
		return dis[t]!=-1;
	}
	int dfs(int x,int flow)
	{
		if(x==t)return flow;
		int sum=0;
		for(int i=cur[x];i&&flow;i=nex[i])
		{
			cur[x]=i;
			if(w[i]&&dis[x]+1==dis[to[i]])
			{
				int k=dfs(to[i],min(flow,w[i]));
				w[i]-=k,w[i^1]+=k;flow-=k;sum+=k;
			}
		}return sum;
	}
	void work()
	{
		s=2*n+1,t=2*n+2;
		while(bfs())maxflow+=dfs(s,inf);
	}
	
}G;
void add(int x)
{
	G.clear();int s=2*n+1,t=2*n+2;o=n;
	for(int i=1;i<=n;i++)
		if(f[i][x]||f[x][i]||i==x)b[i]=1,o--;
		else b[i]=0;
	for(int i=1;i<=n;i++)
		if(!b[i])G.add(s,i,1),G.add(i+n,t,1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(!b[i]&&!b[j]&&f[i][j]&&i!=j)
				G.add(i,j+n,1);
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=m;i++)x=read(),y=read(),f[x][y]=1;
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				f[i][j]|=f[i][k]&f[k][j];
	add(0);G.work();
	ans=n-G.maxflow;cout<<ans<<endl;
	for(int i=1;i<=n;i++)
	{
		G.clear();add(i);G.work();
		if(o-G.maxflow==ans-1)F[i]=1;
	}
	int tot=0;
	for(int i=1;i<=n;i++)
		if(F[i]&&!col[i])
		{
			flag[i]=1;col[i]=++tot;
			for(int j=1;j<=n;j++)if(f[i][j]||f[j][i])col[j]=tot;
		}
	for(int i=1;i<=n;i++)cout<<flag[i];cout<<endl;
	for(int i=1;i<=n;i++)cout<<F[i];
 	return 0;
}


```




---

## 作者：LittleDino (赞：7)

啊，没有spj，不用输出后面那些的，只要输出最大值就可以了~（白白WA了两次……~~心疼地摸了摸自己~~）

这道题其实是一个很好的板子题啦，求最长反链长度裸题。

解释一下新名词~

在**有向无环图**中，我们定义：

链：图上一些点的集合，对于链上任意两个点x、y，满足x能到达y或者y能到达x。

反链：图上一些点的的集合，对于反链上任意两个点x、y，满足x不能到达y并且y不能到达x。

所以就是很显然的求最长反链长度了~

有以下定理：

**最长反链长度=最小链覆盖**（选取最少的链覆盖所有的点）->证明详见[最长反链与最小链覆盖](http://vfleaking.blog.163.com/blog/static/1748076342012918105514527/)

以及其对偶定理：**最长链长度=最小反链覆盖**

所以就又转化成了求最小路径（链）覆盖了，来看怎么求：

选择建一个二分图，两边各有n个点，原来的点node分别对应两个图中的node1、node2。如果原图中存在边 x->y，那么就在二分图上建立边 x1->y2。

跑一遍匈牙利，则有 **原图最小路径覆盖=原点数n-二分图最大匹配**

（当然也可以用网络流，则有 原图最小路径覆盖=原点数n-最大流）

为什么呢？考虑每在二分图上连一条边，就相当于将两条路径连成一条，那么最小链覆盖数就减少了1（少用一条链覆盖所有点了）。我们将一个点拆成两个，跑二分图最大匹配，避免了路径相交的问题，保证所选出来的每一条一定为一条链。

解决了以上这些，对于怎么求边 x->y，只用简单地跑一遍flyod就可以得出x是否能到达y了。

总结一下，本题算法：Floyd传递闭包+最长反链（二分图匹配/网络最大流）

以下使用二分图匹配的代码（网络流类似）

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=200*2+10;
int n,m,cnt,ans,G[210][210],Head[MAXN],vis[MAXN],fa[MAXN];

int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}

struct edge
{
    int to,next;
}E[40010];

void add(int u,int v)
{
    cnt++;
    E[cnt].to=v;
    E[cnt].next=Head[u];
    Head[u]=cnt;
}

void floyd()
{
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                G[i][j]|=(G[i][k]&G[k][j]);
}

void build()
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(G[i][j]) add(i,n+j),add(n+j,i);
}

bool Path(int u,int tim)
{
    for(int i=Head[u];i;i=E[i].next)
    {
        int v=E[i].to;
        if(vis[v]==tim) continue;
        vis[v]=tim;//时间戳->不用每次都写memset了
        if(fa[v]==-1||Path(fa[v],tim)) 
        {
            fa[v]=u;
            return true;
        }
    }
    return false;
}

void Hungary()
{
    memset(fa,-1,sizeof(fa));
    ans=0;
    for(int i=1;i<=n;i++)
        if(Path(i,i)) ans++;
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        int u=read(),v=read();
        G[u][v]=1;
    }
    floyd();
    build();
    Hungary();
    printf("%d\n",n-ans);//被吃掉的spj 
    return 0;
}
```


---

## 作者：Mars_Dingdang (赞：6)

## 题目大意
给定一张 $n$ 个节点 $m$ 条边的有向无环图 DAG，求出这张图的最大独立集的大小，并构造出一组可行解，然后再求出最大独立集的可行点。

$n\le 100, m\le 10^3$。

## 大体思路
### 前置一：$\text{DAG}$ 最小路径点覆盖。
> 给出一张 DAG，求出最少的**不相交**路径条数使得所选路径覆盖所有点。

考虑拆点，将原图中的点 $x$ 拆成两个点 $x, x'$，分别为出点和入点。对于一条边 $(x, y)\in E$, 在新图 $G'$ 中连接 $(x, y')$。可以证明，这样一张图 $G'$ 是一张二分图。

考虑最劣情况，即每个点单独作为一条路径，这样一共需要 $n$ 条路径覆盖。然后，我们对二分图 $G'$ 求最大匹配 $\mathbf M$。每一组匹配相当于将两条路径合并，因此总的路径数 $-1$。由此可得，答案为 $n-|\mathbf M|$。

### 前置二：$\text{DAG}$ 最小可重复路径点覆盖。
> 给出一张 DAG，求出最少的**节点可相交**路径条数使得所选路径覆盖所有点。


![](https://cdn.luogu.com.cn/upload/image_hosting/ulfypqed.png)

考虑如上图所示的两条相交路径 $x\to p\to y$，$u\to p\to v$。显然点 $p$ 可以被这两条路径中的任意一条覆盖。因此，我们可以在 $x, y$，$u, v$ 之间连边，这样对于任意交点，原先的“可相交”转换成了“不相交”，回到前置一的做法。

具体地，我们先对整张图做一次 $\text{Floyd}$ 传递闭包，并用 $\text{bitset}$ 优化，然后对任意可达两点 $u, v$ 按照拆点方式连边即可。时间复杂度 $O\left(\frac{n^3}{\omega}\right)$。

其本质为：一个传递闭包后的 DAG 对应一个偏序集 $\mathbf A$，即 $E=\{(x, y)\ |\ x,y\in \mathbf A,x\preceq y \}$。

### 前置三：$\text{Dilworth}$ 定理。
定义正链表示一个节点序列 $\{u_i\}$，其中 $u_i\preceq u_{i+1}$；反链表示一个节点**集合** $\{u_i\}$ 使得集合中任意两点没有偏序关系。那么有两个对偶定理：

1. 最大正链的大小 $L_1$ 等于反链的最小划分数 $M_1$；
2. 最大反链的大小 $L_2$ 等于正链的最小划分数 $M_2$。

对于定理一，因为正链上任意两个元素都不属于同一个反链，因此 $L_1\le M_1$；又，我们可以按高度构造划分使得反链划分数 $M_1=L_1$。对于定理二，同样可得 $L_2\le M_2$；又，利用数学归纳法，对偏序集的极大元进行分类讨论，可以构造出一组 $M_2=L_2$。

由于 DAG 图传递闭包后对应一个偏序集，Dilworth 定理二在 DAG 上有：**最大独立集的点数等于可重叠路径的最小划分数**，即最小可重叠路径覆盖。

### 前置四：二分图最大匹配时间复杂度
参考 2015 年陈胤伯的论文《浅谈图的匹配算法及其应用》。

>使用 Dinic 算法可以在 $O(m\sqrt n)$ 复杂度内求出二分图最大匹配。

由于二分图每条边的边权都是 $1$，因此 bfs 分层与 dfs 多路增广的复杂度均为 $O(m)$。对于前 $\sqrt n$ 轮，复杂度为 $O(m\sqrt n)$。在 $\sqrt n$ 轮后，利用反证法可以证明沿最短路增广不会产生更短的路，而 Dinic 一轮完毕意味着所有同一长度的增广路都已经增广完，因此 Dinic 算法每一次重建分层图后，$s→t$ 的最短增广路距离是严格递增的，那么此时任意一条增广路的长度不小于 $\sqrt n$。

也就是说，考虑最大匹配 $M$ 与当前匹配 $P$ 的对称差 $M⊕P$，其中一定是由若干条互不相交的交替环/链构成增广路，长度 $≥\sqrt n$。由于总点数 $<n$，此时这样的链的数量 $≤\sqrt n$，因此还剩 $O(\sqrt n)$ 条增广路，最多再进行 $\sqrt n$ 轮，总复杂度 $O(m\sqrt n)$。

_________________

回到本题。又前置三中的定理推论，可以很快求出第一问。

### 构造可行解
在 $\text{Konig}$ 定理的证明中，有以下构造方法：从右部每个非匹配点出发执行 dfs 寻找“增广路”（即非匹配边-匹配边交替），然后标记访问过的节点，此时左部访问过的节点和右部未访问过的节点就是一组二分图最小点覆盖。

因为独立集是点覆盖的补集，所以取**左部未访问过的节点和右部访问过的节点**构成最大独立集。对于出点和入点都属于最大独立集的原图节点 $x$，就是我们构造出的解。

对于非匹配点和匹配点的判断，可以根据该点与 $s, t$ 的连边是否满流。同理，寻找一个左部匹配点的匹配对象，只需要看哪条边满流即可。

### 求出所有可行点
怎样的点属于可行点呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/9j8l8bl4.png)

对上图片面地概括可以发现，两叉上都是可行点，下面地“干路”节点都是不可行点，原因是下面的节点与两叉节点均有偏序关系。推广可以得到以下算法：

1. 对于一个节点 $u$，删除所有与其有偏序关系的节点（包括本身，$u$ 的可达点和可达 $u$ 的点）。

2. 将剩下的点建图，记录剩余节点数量 $nV$，并求出最大独立集的大小 $M'$。

3. 记 $ans$ 为第一问答案。如果 $nV-M'=ans-1$，即点 $u$ 的删去只会影响一个节点不能成为最大独立集中的点，那么这个节点就可以看作 $u$，说明 $u$ 是可行点。

时间复杂度瓶颈在于第三问。枚举所有节点，每次需要求最大独立集。由于总边数 $O(n^2)$，使用 Dinic 求匹配的复杂度为 $O(n^2\sqrt n)$，$n$ 次的时间复杂度为 $O(n^3\sqrt n)$。注意建立数组时边数是 $n^2$ 级别而不是 $m$。

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <bitset>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int N = 205, M = 30005, inf = 1 << 30;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n, m, s, t, hd[N], ver[M], nxt[M], cap[M], tot = 1, ans;
inline void add(int u, int v, int c) {
	ver[++tot] = v; nxt[tot] = hd[u]; cap[tot] = c; hd[u] = tot;
}
int d[N], cur[N];
inline bool bfs() {
	queue <int> q;
	memset(d, -1, sizeof d);
	d[s] = 1; cur[s] = hd[s]; q.push(s);
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for(int i = hd[u]; i; i = nxt[i]) {
			int v = ver[i];
			if(cap[i] && d[v] == -1) {
				d[v] = d[u] + 1;
				cur[v] = hd[v];
				q.push(v);
				if(v == t) return 1;
			}
		}
	}
	return 0;
}
inline int dfs(int u, int limit) {
	if(u == t || !limit) return limit;
	int flow = 0;
	for(int &i = cur[u]; i && flow < limit; i = nxt[i]) {
		int v = ver[i];
		if(d[v] == d[u] + 1 && cap[i]) {
			int f = dfs(v, min(cap[i], limit - flow));
			if(!f) d[v] = -1;
			cap[i] -= f; cap[i ^ 1] += f; flow += f;
		}
	}
	return flow;
}
inline int Dinic() {
	int maxflow = 0, flow = 0;
	while(bfs())
		while(flow = dfs(s, inf)) maxflow += flow;
	return maxflow;
}
bitset <N> f[N];
int idL[N], idR[N], id[N], match[N];
bool vL[N], vR[N];
inline void dfs_match(int u) { // 走交替链标记点
	vR[u] = 1;
	rep(v, 1, n) 
		if(f[v][u] && !vL[v]) 
			vL[v] = 1, dfs_match(match[v]);
}
bool del[N];
int main () {
	read(n); read(m);
	s = 2 * n + 1, t = 2 * n + 2;
	rep(i, 1, m) {
		int u, v;
		read(u); read(v);
		f[u][v] = 1;
	}
	rep(k, 1, n)
		rep(i, 1, n) if(f[i][k])
			f[i] |= f[k];
	rep(u, 1, n) {
		idL[u] = u;
		idR[u] = u + n;
	}
	rep(u, 1, n) {
		add(s, idL[u], 1), id[u] = tot, add(idL[u], s, 0);
		add(idR[u], t, 1), add(t, idR[u], 0);
	}
	rep(u, 1, n)
		rep(v, 1, n)
			if(f[u][v]) {
				add(idL[u], idR[v], 1);
				add(idR[v], idL[u], 0);
			}
	writeln(ans = (n - Dinic())); // 1
	
	rep(u, 1, n) if(!cap[id[u]]) {
		for(int i = hd[u]; i; i = nxt[i]) {
			int v = ver[i];
			if(!cap[i]) { // 满流说明匹配
				match[u] = v - n;
				break;
			}
		}
	}
	rep(i, 1, n) if(cap[i * 4]) dfs_match(i); // 非匹配点
	rep(i, 1, n) write((!vL[i] && vR[i]));
	putchar('\n');// 2
	
	rep(u, 1, n) {
		memset(hd, 0, sizeof hd);
		tot = 1;
		int nV = 0; // 记录剩余点数
		rep(v, 1, n) del[v] = (u == v || f[u][v] || f[v][u]); // 删去有偏序关系的节点
		rep(u, 1, n) if(!del[u]) {
			++nV;
			add(s, idL[u], 1), add(idL[u], s, 0);
			add(idR[u], t, 1), add(t, idR[u], 0);
		}
		rep(u, 1, n) if(!del[u])
			rep(v, 1, n) 
				if(!del[v] && f[u][v]) {
					add(idL[u], idR[v], 1);
					add(idR[v], idL[u], 0);
				} // 连边
		write((nV - Dinic()) == ans - 1);
	}//3
	
	return 0;
}
```

## 后记
1. 本题三问结合，既要用 Dilworth 定理求最大独立集，又要构造出一组解，并求出可行解，**感觉珂以评黑**。

2. 截止至 $2022$ 年 $2$ 月 $19$ 日的最优解祭。

3. 来自 30s 后的 update：漏了个空格。

---

## 作者：QwQcOrZ (赞：5)

首先题意让我们求的就是一个 DAG 的最长反链，即在图中选出一个点集，使得它们之间两两不可达。

由 Dilworth 定理可知，DAG 的最长反链 $=$ 最小可重链覆盖。

关于 Dilworth 定理的具体内容可以看我的[这篇博客](https://www.luogu.com.cn/blog/61120/dilworth-proof)。

最小可重链覆盖又等于传递闭包上的最小不可重链覆盖。

最小不可重链覆盖是个经典问题，可以转化为拆点二分图的最大匹配。

求出图的传递闭包然后跑个匈牙利即可求出第一问，时间复杂度 $\mathcal O(n^3)$。

对于第二问，可以直接套用上面那篇博客中的调整法，也可以利用第三问的答案求解。

先来考虑一下第三问怎么求，考虑强制一个点选入反链，在图中删去这个点和它能到达和被到达的点后，再求一遍答案，如果此时答案比第一问小 $1$，说明这个点可以选入答案。时间复杂度 $\mathcal O(n^4)$。

求出第三问后，第二问就很好办了，直接每次从第三问的点集中选出一个点，删去点集中与它有可达关系的点，直到点集为空即可。正确性可以考虑求第三问的过程，显然是对的。

$\texttt{Code Below}$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=105;

ll read(){static ll x;scanf("%lld",&x);return x;}
void write(ll x){printf("%lld",x);}
void print(ll x,char c='\n'){write(x),putchar(c);}

bool is[N];
bitset<N>e[N];
int x[N],y[N],n,m;
bool dfs(int now)
{
	if (is[now]||x[now]<0) return 0;
	is[now]=1;
	for (int i=1;i<=n;i++)
	if (e[now][i]&&~x[i])
	if (!y[i]||dfs(y[i]))
	{
		x[now]=i,y[i]=now;
		return 1;
	}
	return 0;
}
bool can[N];

signed main()
{
	n=read(),m=read();
	for (int i=1;i<=m;i++)
	{
		int u=read(),v=read();
		e[u].set(v);
	}
	for (int k=1;k<=n;k++)
	for (int i=1;i<=n;i++)
	if (e[i][k]) e[i]|=e[k];
	int ans=n;
	for (int i=1;i<=n;i++) memset(is,0,sizeof(is)),ans-=dfs(i);
	print(ans);
	for (int i=1;i<=n;i++)
	{
		memset(x,0,sizeof(x));
		memset(y,0,sizeof(y));
		int tot=n;
		for (int j=1;j<=n;j++) if (i==j||e[i][j]||e[j][i]) x[j]=-1,tot--;
		for (int j=1;j<=n;j++) memset(is,0,sizeof(is)),tot-=dfs(j);
		can[i]=tot==ans-1;
	}
	memcpy(is,can,sizeof(is));
	for (int i=1;i<=n;i++) if (is[i])
	for (int j=1;j<=n;j++) if (e[i][j]||e[j][i]) is[j]=0;
	for (int i=1;i<=n;i++) putchar(is[i]+'0');;puts("");
	for (int i=1;i<=n;i++) putchar(can[i]+'0');;puts("");
	
	return 0;
}
```

---

## 作者：撤云 (赞：5)

[广告](https://www.cnblogs.com/hbxblog/p/11271140.html)
### 题目链接

[戳我](https://www.luogu.org/problem/P4298)

### $Solution$

#### 第一问

这道题要知道一个叫做$Dilworth$的定理

最长反链$=$最小链覆盖

证明([$from\ r\_64$](http://r-64.blog.uoj.ac/blog/623)):  

![](https://s2.ax1x.com/2019/07/30/eJ9ypF.png)

所以我们只要求一个最小链覆盖即可

这个很好求

对于每个点拆点，拆成$(x,x')$,$s->x$流量为$1$,$x'->t$,流量为$1$

对于每个相连通的边$(x,y)$,将$x->y'$流量为$1$

最后用$n-Dinic()$即可

但是注意不能根据输入的边连边，需要用传递闭包判一下连通性，因为如下图这种情况，就不对

![](https://s2.ax1x.com/2019/07/30/eJi8fK.png)

这样子如果直接连边跑出来的结果是$3$但是实际上应该是$2$

本来应该是没有后面两问的,但是因为有了$spj$导致后面两问又出来了

#### 第二问

它要求一个最长反链，也就是求一个最大独立集

![](https://s2.ax1x.com/2019/07/30/eJF1Bj.png)

[$from\ zsy$](https://www.cnblogs.com/zhoushuyu)

#### 第三问

我们删掉一个点和与他相关的点与边，再求一次最长反链，如果答案减少了$1$则这个可能在最长反链中否则不可能,具体见代码

### $Code$

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
typedef long long ll;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node{
    int to,next,v;
}a[2000001];
int head[1000001],cnt=1,tot,ans,n,m,s,t,x,y,z,dep[1000001],f[1001][1001],vis[1001],bj[1001];
void add(int x,int y,int c){
    a[++cnt].to=y,a[cnt].next=head[x],a[cnt].v=c,head[x]=cnt;
    a[++cnt].to=x,a[cnt].next=head[y],a[cnt].v=0,head[y]=cnt;
}
queue<int> q;
int bfs(){
    memset(dep,0,sizeof(dep));
    q.push(s);
    dep[s]=1;
    while(!q.empty()){
        int now=q.front();
        q.pop();
        for(int i=head[now];i;i=a[i].next){
            int v=a[i].to;
            if(!dep[v]&&a[i].v>0)
                dep[v]=dep[now]+1,q.push(v);
        }
    }
    if(dep[t])
        return 1;
    return 0;
}
int dfs(int k,int list){
    if(k==t||!list)
        return list;
    for(int i=head[k];i;i=a[i].next){
        int v=a[i].to;
        if(dep[v]==dep[k]+1&&a[i].v>0){
            int p=dfs(v,min(list,a[i].v));
            if(p){
                a[i].v-=p;
				a[i^1].v+=p;
                return p;
            }
        }
    }
    return dep[k]=0;
}
int Dinic(){
    int ans=0,k;
    while(bfs())
        while((k=dfs(s,inf)))
            ans+=k;
    return ans;
}
void floyd(){
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				f[i][j]=max(f[i][j],f[i][k]&f[k][j]);
}
void dfs1(int x){
	if(!vis[x]&&x<=n) return ;
	if(vis[x]&&x>n) return ;
	if(x<=n){
		vis[x]=0;
		for(int i=head[x];i;i=a[i].next)
			if(a[i].v)
				dfs1(a[i].to);
	}
	else {
		vis[x]=1;
		for(int i=head[x];i;i=a[i].next)
			 if(!a[i^1].v)
				 dfs1(a[i].to);
	}
}
int main(){
    n=read(),m=read(),s=0,t=2*n+1;
    for(int i=1;i<=m;i++)
        x=read(),y=read(),f[x][y]=1;
	for(int i=1;i<=n;i++)
		add(s,i,1),bj[i]=cnt-1,add(i+n,t,1),f[i][i]=1,vis[i]=1;
	floyd();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(i!=j&&f[i][j])
				add(i,j+n,1);
    printf("%d\n",ans=(n-Dinic()));
	for(int i=1;i<=n;i++)
		if(a[bj[i]].v)
			dfs1(i);
	for(int i=1;i<=n;i++)
		printf("%d",(vis[i]|vis[i+n])^1);
	cout<<endl;
	for(int k=1;k<=n;k++){
		memset(head,0,sizeof(head)),cnt=1,tot=0;
		for(int i=1;i<=n;i++)
			if(i!=k&&!f[i][k]&&!f[k][i])
				add(s,i,1),add(i+n,t,1),tot++;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				if(i!=j&&f[i][j]&&i!=k)
					add(i,j+n,1);
		printf("%d",ans-1==tot-Dinic());
	}
}
```


---

## 作者：xht (赞：4)

题目要求的实际上是一个偏序关系的**最长反链**，通过 Dilworth 定理可以发现就是 DAG 的**最小可重复路径点覆盖**。

最小可重复路径点覆盖又可以通过 $\mathcal O(n^3)$ 的传递闭包转化为**最小路径点覆盖**。

又 DAG 的最小路径点覆盖包含的路径条数 $= n -$ 其**拆点二分图**的最大匹配数。

使用**匈牙利算法**即可在 $\mathcal O(n^3)$ 的时间求出答案。

接下来的问题是如何构造方案。

我们先求出传递闭包后的图的最小路径点覆盖包含的路径集合 $path$：

1. 设在拆点二分图中左部点 $x$ 对应的右部点为 $x^{\prime}$，若 $x,y$ 匹配则有 $f_x = y, f_y = x$。
2. 依次考虑左部的每一个非匹配点 $x_0$。
3. 从 $x_0$ 出发，每次从 $x$ 走到 $f_{x^{\prime}}$，直至到达一个左部点 $y_0$，满足 $y_0^{\prime}$ 是非匹配点。
4. 那么经过的所有点构成一条以 $y_0$ 为起点 $x_0$ 为终点的路径。

接下来我们要从 $path$ 的每条路径上选出一个点构成原图的最长反链：

1. 将所有的终点 $x_0$ 放到一起构成一个集合 $E$。
2. 求出从 $E$ 中的所有节点出发，走一条边，到达的所有节点 $next(E)$。
3. 根据传递闭包的性质，若 $E$ 与 $next(E)$ 没有交，那么 $E$ 即为所求。
4. 否则考虑 $E \cap next(E)$ 的所有节点 $e$，沿着 $e$ 所在的路径反着走，直到一个节点 $e^{\prime} \notin next(E)$，在 $E$ 中将 $e$ 替换为 $e^{\prime}$。
5. 回到第 $3$ 步。

---

## 作者：KAMIYA_KINA (赞：1)

## Tag

最大匹配，$\text{Dilworth}$ 定理。

## Preface

联赛前了搞一下图论。

## Description

给定一个有向无环图 $G=(V,E)$，求其最大独立集，并构造方案。

$\texttt{data range:} |V|\leq 100, |E|\leq 1000$.

## Solution

### Question1

最大独立集也就是对于所有 $S\subseteq V$，求出一个 $S$ 使得 $|S|$ 最大，并且关于 $S$ 中的所有点，不会有一个点可以到达另一个点。

那么我们可以想到这个问题的补问题，也就是**最小可重链覆盖**，令这些链的顶点的点集为 $T$。

最小可重链覆盖也就是在这个图中，选取若干条链，使得这些链所包含的点集的交为全集 $V$。

对于第二个问题我们有很容易解决的方法，首先通过偏序关系的传递性将最小可重链覆盖变成**最小链覆盖**。

改变为最小链覆盖很简单，直接通过 floyd 算法求出全偏序关系就可以了，然后答案就是求解[最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)之后用全集 $V$ 的大小减去点集 $T$ 的大小。

自此第一问做完了，代码中用的是二分图实现的（主要是短的一笔的同时还能很容易的实现后面的问题）。

### Question2

接下来就是构造方案了，考虑最小路径覆盖中的构造方法，直接找到一个点，然后找到这个点的链的顶端，然后输出顶端即可。

### Question3

对于第三问，我们有一个很有意思的解决方法，同时这个方法也可以解决第二问。

考虑一个点在二分图中是否被匹配，如果没有被匹配那么就是不在其中的。（？）

这显然是错误的，比如该点在两个链的**交点处**，可能选取了该点之后就会使方案数减少，所以不能选择。

那么我们基于这种特殊情况考虑将于这点相关的所有点都删掉，如果删完之后剩下的点能形成的**最小链覆盖数量为原答案减一**的话，那么这个点就是可以被选取的，否则就是不能被选取的。

然后如果我们知道了第三问的结果与构造方法的话，我们很容易想出如果这个点如果可以选择的话，那么我们就可以在第二问中选择这个点，然后将与这个点有关的所有点都删掉，这就是第三问的**逆构造**，下面的代码中用的是这一种构造方法。

## Code

```cpp
const int N = 1e2 + 1;

int g[N][N], mch[N];
int vis[N], n, m;
bool kil[N], ans2[N], ans1[N];
vector<int> e[N];

bool xyl(const int u, const int now) {
    if(vis[u] == now) return false;
    vis[u] = now;
    for(int v : e[u]) {
        if(kil[v]) continue;
        if(!mch[v]) return mch[v] = u, true;
        if(xyl(mch[v], now)) return mch[v] = u, true;
    }
    return false;
}

inline void input() {
    n = rd, m = rd;
    for(int i = 1, u, v; i <= m; i++) {
        u = rd, v = rd;
        g[u][v] = true;
    }
    for(int i = 1; i <= n; i++) g[i][i] = true;
    return ;
}

inline void init() {
    FOR(k, 1, n) FOR(i, 1, n) FOR(j, 1, n) 
        g[i][j] = g[i][j] | (g[i][k] && g[k][j]);
    FOR(i, 1, n) FOR(j, 1, n) {
        if(i == j) continue;
        if(g[i][j]) e[i].push_back(j);
    }
    return ;
}

inline void work() {
    int ans = 0;
    FOR(i, 1, n) if(xyl(i, i)) ans++;
    cout << n - ans << '\n';//question 1
    
    FOR(i, 1, n) {
        int tem = n, tmp = 0;
        FOR(j, 1, n) kil[j] = false, vis[j] = 0, mch[j] = 0;
        FOR(j, 1, n) if(g[i][j] || g[j][i] || i == j) kil[j] = true, tem--;
        FOR(j, 1, n) {
            if(kil[j]) continue;
            if(xyl(j, j)) tmp++;
        }
        ans2[i] = (n - ans == tem - tmp + 1);
    }//question 3
    
    FOR(i, 1, n) kil[i] = false;
    FOR(i, 1, n) if(ans2[i] && !kil[i]) {
        ans1[i] = true;
        FOR(j, 1, n) if(g[i][j] || g[j][i] || i == j) kil[j] = true;
    }//question 2
    
    FOR(i, 1, n) cout << ans1[i];
    cout << '\n';
    FOR(i, 1, n) cout << ans2[i];
    return ;
}

inline void solve() {
    input();
    init();
    work();
    return ;
}
```

---

## 作者：tylon2006 (赞：1)

## 两个做法

### 1.二分图式

我觉得应该评黑 真的

这个思路转换挺神奇的

这里不会多讲 题解理论过程粉兔说得很详细 代码Cyhlnj比较好看 思路zxyoi较清晰

我只讲一下代码中比较容易看不懂的地方

先floyd传递闭包一下得到每个点能到的点集

第一问 Dilworth定理 最长反链=最小链覆盖

第二问 最长反链=最大独立集=n-最小覆盖点集=最大匹配

这个可以看粉兔+ [二分图的最小顶点覆盖 最大独立集 最大团](https://www.cnblogs.com/jianglangcaijin/p/6035945.html)

面对疾风吧 没学过这个可能要半h+

第三问 去掉当前点i与其**能到达**与**能被到达**的点判断一下剩下的图的最长反链是否等于原图最长反链-1

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int match[110],to[110]; //前驱 后继
bool s[110],t[110]; //出 入
bool mp[110][110]; //全图
bool e[110][110]; //剩余图
int ban[110]; //删的点
int vis[110]; //该轮增广到达过的点
int n,m,ind,ans; //n m 轮数 答案
bool find(int u){
	if(ban[u]) return 0;
	for(int i=1;i<=n;i++)
	if(e[u][i]&&ban[i]==0&&vis[i]!=ind){
		vis[i]=ind;
		if(match[i]==0||find(match[i])){
			match[i]=u;
			to[u]=i;
			return true;
		}
	}
	return false;
}
void dfs(int u){ //模拟找最小覆盖点集过程
	if(s[u]) return;
	s[u]=true;
	for(int i=1;i<=n;i++)
	if(e[u][i]&&t[i]==0){
		t[i]=true;
		dfs(match[i]);
	}
}
int main(){
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		mp[x][y]=true; //单向边
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	for(int k=1;k<=n;k++)
	mp[j][k]|=mp[j][i]&mp[i][k]; //
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	e[i][j]=mp[i][j]; ans=n;
	for(ind=1;ind<=n;ind++) 
	ans-=find(ind);
	printf("%d\n",ans);
	for(int i=1;i<=n;i++)
	if(to[i]==0) dfs(i);
	for(int i=1;i<=n;i++)
	printf("%d",s[i]&&!t[i]);//这里已经取反 原来求最小点集覆盖时是!s[i]||t[i] 即左端标记过的点与右端未标记的点
	printf("\n");
	int can=0,sum=0;
	for(int i=1;i<=n;i++){
		memset(e,0,sizeof(e));
		memset(to,0,sizeof(to));
		memset(ban,0,sizeof(ban));
		memset(match,0,sizeof(match));
		int res=0;
		for(int j=1;j<=n;j++){
			if(mp[j][i]||mp[i][j]||i==j) ban[j]=1; //可达与可被达统统删掉
			else res++;
		}
		for(int j=1;j<=n;j++)
		for(int k=1;k<=n;k++)
		if(ban[j]==0&&ban[k]==0) 
		e[j][k]=mp[j][k]; //删掉后的图
		for(int j=1;j<=n;j++) 
		if(ban[j]==0){
			ind++;
			res-=find(j);
		}
		printf("%d",res==ans-1); //res+1=ans
	}
}
```

---
### 2.网络流
奇妙的方法增加了！

拆个点 $X_{out}$连$Y_{in}$ S连$X_{out}$ $Y_{in}$连T 流量全为1 ans=n-maxflow!

代码康康[这个](https://www.cnblogs.com/GXZlegend/p/6476115.html)

其实跟最小割没关系⑧ 为什么说最小割

这玩意中间的边流量为1 最小割也是神奇

虽然对于这个题因为m>=n可以

但实际上是一个最小链覆盖的过程:

![](https://cdn.luogu.com.cn/upload/image_hosting/c5v7t197.png)

看着这个图 你发现了什么 

~~没错 你什么也发现不了~~

我们研究流量究竟会对图产生什么影响

可以看出 我们$X_{out}$与$Y_{in}$的边流1个单位(就满了) 相当于原图X流水到Y 即标记Y为不可用

而每个$X_{out}$只有一个流是限制它的最小链覆盖 只能流一个儿子即一条链

很容易发现 我们这样做会导致除了每个链头没有流 其他点都有流

当我们做到最大流时 完成了链头最少 即最小链覆盖 那么ans=n-maxflow

注意这里是最长反链=最小链覆盖 这里求的是链覆盖的链头而非最长反链方案

第三问还是那样 现在就求一个第二问

---
### 奇妙up!
还有一种第二问的写法

这是某csp500+ 省队预定syh靠直觉想出来的奇妙做法

我们先处理第三问 再做第二问

现在我们知道了哪些点可用作祭坛了

我们暴力找到第一个可用点 然后删掉它能达到和能被达到的点 加入方案

然后再找下一个可用点 重复操作

直到没有(

这就是方案！

下面是我的证明:
![](https://cdn.luogu.com.cn/upload/image_hosting/actibzpq.png)

假设最长反链点数为3 第一个选到的可用点为a 那么必有一组答案a,b,c

在删掉a与其能达到和能被达到的点后 若下一个选的可用点不是b 假设为d

那么d必在b或c的覆盖区域内 

1. 若d在b内 应有b->d 因为c流不到b 那么 d->b 出现环 不可能

2. 若d在c内 应有c->d 若d->b 则c->b 那么b不可在此方案内 矛盾

也就是说 对于一个已确定的祭坛 我们只有一种方案与它匹配 即上述做法正确

这样意味着方案互不相交 可用点总数为k*ans k为方案数 ans为最长反链大小

由这个性质也许可以出一下奇怪的题？

说真的这个过程很像第三问 只是需要预知可用点

code: 来自@suyiheng
```cpp
//前面与2一样 省略
	for(int i=1; i<=n; i++)k[i]=check(i);
	for(int i=1; i<=n; i++) {
		b[i]=k[i];
		for(int j=1; j<i; j++) {
			if(f[i][j]&&b[j]) {
				b[i]=0;
				break;
			}
			if(f[j][i]&&b[j]) {
				b[i]=0;
				break;
			}
		}
	}
	for(int i=1; i<=n; i++) {
		if(b[i])printf("1");
		else printf("0");
	}
	printf("\n");
	for(int i=1; i<=n; i++) {
		if(k[i])printf("1");
		else printf("0");
	}
	printf("\n");
```

这个也可以替换二分图的第二问啦

这样做法就亲民多了~

---

## 作者：SDNetFriend (赞：0)

题目链接：[P4298](https://www.luogu.com.cn/problem/P4298)

题意这里不再赘述。

### 简单来讲可以分成三个问题

1.在 DAG 中求最大点集大小，使得点集中的点两两不可达，可以叫作最大点独立集或者最长反链

2.构造出一种 1 问题的方案

3.求出所有可能被包含在集合内的点

#### 问题1

由 Dilworth 定理可知，最长反链=最小链覆盖，这里最小链覆盖可以看作可以选重复点的最小链覆盖

具体证明比较复杂，这里谈谈我自己的理解，可以采用反证法，证明如果不是最小链覆盖答案将不合法

首先可以看出，最终的方案会是在每条链中选择一个点构成方案，如何保证的正确性呢

1.不能在一条链中选两个点

一条链中的两个点一定具有可达关系，不合法

![](https://cdn.luogu.com.cn/upload/image_hosting/lby7c5th.png)

如此种情况打绿叉的两个点不可以同时选

2.不能不是最小链覆盖

如果不是最小链覆盖，则图中一定存在两条链可以首尾相接拼成一条链，这时在两条链中的点就会冲突，故也不会成为答案

![](https://cdn.luogu.com.cn/upload/image_hosting/gurjxscq.png)

如此种情况如果用蓝边把两条链拼起来，两个选中的点就会不合法

综上所述，我们将问题转变成了求 DAG 的最小链覆盖问题

因为可以走重点，可以用 Floyd 传递闭包，把所有可以到达的点连边，如果走了重点就可以相当于跳过走过的点

这样一来又转化成了求 DAG 的最小路径覆盖问题

最小路径覆盖问题怎么解呢

考虑把每个点拆点，使之成为二分图，这里采用 Dinic 解决问题

对于原图上的边 $u\to v$ ，由原图 $u$ 点的出点连向原图 $v$ 的入点，跑网络流，每个点的入点从 $s$ 连一条流量为 1 的边，出点向 $t$ 连一条流量为什么 1 的边

原图边对应的边有流量说明原图上这两个点被连了起来，就可以被理解是两条路径被合并，这样路径总数 -1

起初没合并时路径总数是 $n$ ，也就是说

DAG最小路径覆盖 $=$ 总点数 $-$ 对应二分图的最大流

至此问题 1 已经被我们解决

#### 问题3

我们可以先找到可能成为答案的点，然后再从里面构造方案

什么样的点可能成为答案？

如果一个点，删去自身，并且删去原图上和它有边的所有点，解决问题 1 ，如果答案只减少了 1 ，那么这个点就有可能成为答案

答案只减少一意思是当前点只对一条链有影响，不存在当前点处在两条或者多条链交点处的情况

#### 问题2

问题 3 中，我们已经筛选出了所有只会影响一条链的点，那么既然我们要从每条链中选一个，我们就枚举，每到一个可能成为答案的点，就把它加到答案里，并且标记下它所在的链以后不能再选点

这样我们就成功解决了三个问题

### 贴代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <queue>
#define rint register int
#define lint long long
#define ldouble long double
using namespace std;
inline int read(){
	char c;int res=0,f=1;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return f*res;
}
const int N=1e3+5,INF=1e9;
int hed[N<<3],nxt[N<<3],ver[N<<3],f[N<<3],hf[N<<3],cnt=1;
inline void inst(int u,int v,int _f){
	ver[++cnt]=v;
	nxt[cnt]=hed[u];
	hed[u]=cnt;
	f[cnt]=hf[cnt]=_f;//hf用来存初始的流量，用于恢复 
	ver[++cnt]=u;
	nxt[cnt]=hed[v];
	hed[v]=cnt;
	f[cnt]=hf[cnt]=0;
}
int n,m,s,t,ans0;
bool ex[N],g[N][N],flg[N];
int ans1[N],ans2[N];
int res,dep[N];
inline bool BFS(){
	memset(dep,0,sizeof dep);
	dep[s]=1;
	queue<int> que;
	que.push(s);
	while(!que.empty()){
		int u=que.front();
		que.pop();
		for(rint i=hed[u];i;i=nxt[i]){
			int v=ver[i];
			if(!f[i]||!ex[v]||dep[v])continue;
			dep[v]=dep[u]+1;
			que.push(v);
		}
	}
	if(!dep[t])return false;
	else return true;
}
int DFS(int u,int incf){
	int out=0;
	for(rint i=hed[u];i;i=nxt[i]){
		int v=ver[i];
		if(!f[i]||!ex[v]||dep[v]!=dep[u]+1)continue;
		int upd=DFS(v,min(incf,f[i]));
		f[i]-=upd;
		f[i^1]+=upd;
		out+=upd;
		incf-=upd;
	}
	if(u==t)return incf;
	else return out;
}
inline int Dinic(){//Dinic跑二分图 
	res=0;
	while(BFS())
		res+=DFS(s,INF);
	return res;
}
inline int cg(int u,bool tp){
	int sum=1;
	ex[u<<1]=ex[u<<1|1]=tp;
	for(rint i=1;i<=n;++i)
		if(g[u][i]||g[i][u]){
			ex[i<<1]=ex[i<<1|1]=tp;
			++sum;
		}
	return sum;
}
int main(){
	n=read();
	m=read();
	for(rint i=1;i<=m;++i){
		int u,v;
		u=read();
		v=read();
		g[u][v]=true;
	}
	for(rint k=1;k<=n;++k)//Floyd传递闭包 
		for(rint a=1;a<=n;++a)
			for(rint b=1;b<=n;++b)
				if(g[a][k]&&g[k][b])
					g[a][b]=true;			
	s=1;
	t=(n+1)<<1;
	ex[s]=ex[t]=true;//ex->exist 标记当前点是否没有被删除 
	for(rint i=1;i<=n;++i){
		ex[i<<1]=ex[i<<1|1]=true;//i<<1是入点 i<<1|1是出点 
		for(rint j=1;j<=n;++j)
			if(g[i][j])
				inst(j<<1,i<<1|1,1);//连边 
		inst(s,i<<1,1);
		inst(i<<1|1,t,1);
	}
	ans0=Dinic();
	printf("%d\n",n-ans0);
	for(rint i=1;i<=n;++i){
		memcpy(f,hf,sizeof f);//把图恢复到原状态 
		int _n=n-cg(i,false);//cg用来删点或者恢复点，返回删掉的点数 
		if(n-ans0==_n-Dinic()+1)//如果新的答案只比原答案小1 
			ans2[i]=1;
		cg(i,true);
	}
	for(rint i=1;i<=n;++i)
		if(!flg[i]&&ans2[i]){//当前点没有被标记并且可能成为答案 
			ans1[i]=1;
			flg[i]=true;
			for(rint j=1;j<=n;++j)
				if(g[i][j]||g[j][i])//标记所在链 
					flg[j]=true;
		}
	for(rint i=1;i<=n;++i)
		printf("%d",ans1[i]);
	printf("\n");
	for(rint i=1;i<=n;++i)
		printf("%d",ans2[i]);
	return 0;
}

```


---


# [THUSC 2017] 巧克力

## 题目描述

「人生就像一盒巧克力，你永远不知道吃到的下一块是什么味道。」

明明收到了一大块巧克力，里面有若干小块，排成 $n$ 行 $m$ 列。每一小块都有自己特别的图案 ，它们有的是海星，有的是贝壳，有的是海螺……其中还有一些因为挤压，已经分辨不出是什么图案了。明明给每一小块巧克力标上了一个美味值 $a_{i,j}$（$0\le a_{i,j}\le 10^6$），这个值越大，表示这一小块巧克力越美味。

正当明明咽了咽口水，准备享用美味时，舟舟神奇地出现了。看到舟舟恳求的目光，明明决定从中选出一些小块与舟舟一同分享。

舟舟希望这些被选出的巧克力是连通的（两块巧克力连通当且仅当他们有公共边），而且这些巧克力要包含至少 $k$（$1\le k\le 5$）种。而那些被挤压过的巧克力则是不能被选中的。

明明想满足舟舟的愿望，但他又有点「抠」，想将美味尽可能多地留给自己。所以明明希望选出的巧克力块数能够尽可能地少。如果在选出的块数最少的前提下，美味值的中位数（我们定义 $n$ 个数的中位数为第 $\left\lfloor\frac{n+1}{2}\right\rfloor$ 小的数）能够达到最小就更好了。

你能帮帮明明吗？

## 说明/提示

| 测试点编号 | $n,m$ 的限制 | $c_{i,j}$ 的限制 | 部分分说明 |
| :----------: | :----------: | :----------: | :----------: |
| 1 | $n=1,1\le m\le233$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le n\times m$ | $\text{A}$ |
| 2 | $1\le n\times m\le 20$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le n\times m$ | $\text{A}$ |
| 3~4 | $n=2,m=15$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le n\times m$ | $\text{A}$ |
| 5~6 | $1\le n\times m\le 30$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le n\times m$ | $\text{A}$ |
| 7~9 | $1\le n\times m\le 50$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le8$ | $\text{A}$ |
| 10 | $1\le n\times m\le 233$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le8$ | $\text{A}$ |
| 11~12 | $1\le n\times m\le 233$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le8$ | $\text{B}$ |
| 13~15 | $1\le n\times m\le 233$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le14$ | $\text{B}$ |
| 16~20 | $1\le n\times m\le 233$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le n\times m$ | $\text{B}$ |
| 21 | $1\le n\times m\le 233$ | $c_{i,j}=-1$ 或 $1\le c_{i,j}\le n\times m$ | 该测试点不计分。 |

$\text{A}$:若输出的最少块数均正确，但最小中位数存在错误，选手可以获得该测试点 $80\%$ 的分数。\
$\text{B}$:若输出的最少块数均正确，但最小中位数存在错误，选手可以获得该测试点 $60\%$ 的分数。

## 样例 #1

### 输入

```
1
5 4 5
3 4 3 4
5 5 -1 5
-1 4 5 5
5 5 4 2
1 -1 2 4
1 3 1 1
3 2 3 3
4 4 4 5
8 9 9 5
7 2 6 3```

### 输出

```
9 5```

# 题解

## 作者：_LPF_ (赞：15)

$\text{A Solution with Code}$

[巧克力](https://www.luogu.com.cn/problem/P7450)

> 给定 $n\times m$ 的网格以及两个参数 $a,c$。
>
> 要求选出一个连通块，不包含 $c=-1$ 的网格，且 $c$ 的种类数 $\geq k$。
>
> 在此前提下最小化连通块大小，并在此前提下最小化 $a$ 的中位数。

中位数直接套路的二分解决，不是本题的重点。看到 $k\leq 5$ 很难不想到一些偏乱搞的做法。

当 $n\times m$ 较小时，可以直接 $\binom{n\times m}{k}$ 钦定关键点，跑最小斯坦纳树的模板。

对更大的情况，考虑随机化，将所有颜色任意映射至 $[0,k)$ 中。

当最优解包含的 $k$ 个点被分配到不同的颜色中即可正确，一次成功的概率大概是 $P=k!/k^k$。

由于 $(1-P)^{200}$ 早已 $<1\%$，故正确性也基本上没啥问题。

实现上，这里的斯坦纳树将所有同色节点都近似的缩成了一个点，故初始化的时候有些特殊。

时间复杂度大概是 $O(Tnm3^k\log V)$。

```cpp
#include<bits/stdc++.h>
typedef long long LL;
#define rep(i, s, t) for(int i = (s); i <= (t); i ++)
#define per(i, s, t) for(int i = (s); i >= (t); i --)
#define Ede(i, u) for(int i = head[u]; i; i = e[i].nxt)
using namespace std;

const int N = 300;
const int INF = 0x3f3f3f3f;
int n, m, k, c[N][N], a[N][N], w[N][N], tt, col[N], to[N];
int f[N][N][1 << 6]; bool vis[N][N];
mt19937 myrand(20060814);

#define MP make_pair
typedef pair<int, int> PII;
queue<PII> q;
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

int read() {
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') f = (c == '-') ? -1 : 1, c = getchar();
	while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
	return x * f;
}

void spfa(int s) {
	while(! q.empty()) {
		PII now = q.front(); q.pop();
		int x = now.first, y = now.second;
		vis[x][y] = false;
		rep(o, 0, 3) {
			int tx = x + dx[o], ty = y + dy[o];
			if(tx < 1 || tx > n || ty < 1 || ty > m || c[tx][ty] == - 1) continue;
			if(f[x][y][s] + w[tx][ty] < f[tx][ty][s]) {
				f[tx][ty][s] = f[x][y][s] + w[tx][ty];
				if(! vis[tx][ty]) q.push(MP(tx, ty)), vis[tx][ty] = true;
			}
		}
	}
}

int work() {
	int ans = INF;
	rep(Q, 1, 233) {
		shuffle(col + 1, col + tt + 1, myrand);
		rep(i, 1, tt) to[col[i]] = i % k;
		rep(i, 1, n) rep(j, 1, m) {
			rep(s, 0, (1 << k) - 1) f[i][j][s] = INF;
			if(~ c[i][j]) f[i][j][1 << to[c[i][j]]] = w[i][j];
		}
		rep(s, 1, (1 << k) - 1) {
			rep(i, 1, n) rep(j, 1, m) if(~ c[i][j]) {
				for(int t = (s - 1) & s; t; t = (t - 1) & s)
					f[i][j][s] = min(f[i][j][s], f[i][j][t] + f[i][j][s ^ t] - w[i][j]);
				if(f[i][j][s] < 1e9) q.push(MP(i, j)), vis[i][j] = true;
			}
			spfa(s);
		}
		rep(i, 1, n) rep(j, 1, m) ans = min(ans, f[i][j][(1 << k) - 1]);
	}
	return ans;
}

int main() {
	int T = read();
	while(T --) {
		tt = 0;
		n = read(), m = read(), k = read();
		rep(i, 1, n) rep(j, 1, m) c[i][j] = col[++ tt] = read();
		rep(i, 1, n) rep(j, 1, m) a[i][j] = read(), w[i][j] = 1;
		sort(col + 1, col + tt + 1);
		tt = unique(col + 1, col + tt + 1) - (col + 1);

		int rec = work();
		if(rec == INF) {puts("-1 -1"); continue;}
		int l = 0, r = 1e6;
		while(l < r) {
			int mid = (l + r) >> 1;
			rep(i, 1, n) rep(j, 1, m) w[i][j] = ((a[i][j] <= mid) ? 9999 : 10001);
			int now = work();
			if(now <= rec * 10000) r = mid; else l = mid + 1;
		}
		printf("%d %d\n", rec, l);
	}
	return 0;
}
```



---

## 作者：FunnyCreatress (赞：11)

首先看到这个 $k\le 5$ 我们就觉得不对劲，显然是个指数级的玩意。我们也不可能暴枚选哪几种颜色，这个中位数的限制也相当离谱，于是我们先考虑只有 $k$ 种颜色且不管第二条限制的情况。

设 $f_{i,j,S}$ 为 $S$ 为与 $(i,j)$ 连通的颜色集合的子集时需要的最少格数，特别地，记 $f_{i,j,0}=0$，那么 $(i,j)$ 显然可以由四个方向转移得到：
$$f_{i,j,S}=\min_{S\subseteq S_1\cup S_2\cup S_3\cup S_4\cup\{c_{i,j}\}}\{f_{i-1,j,S_1}+f_{i,j-1,S_2}+f_{i+1,j,S_3}+f_{i,j+1,S_4}\}+1$$

显然，我们可以要求 $S_1,S_2,S_3,S_4$ 两两无交，这样通过枚举子集可以做到单次转移 $O(3^k)$，总复杂度就是 $O(nm3^k)$。这里需要注意就是不要让 $S_i=S$，否则会有后效性的问题，只需要每次整完从小往大搜一遍就行。

接下来考虑加上第二条限制。这也是一个比较经典的模型。首先显然需要二分答案，把大于二分值的点的权值记为 $1001$，其余点权值记为 $1000$，这样，我们仍然可以按之前的转移做。因为只要多选出一个格子，就会把第二维更优的部分全部覆盖，最后只要通过$\mod 1000$ 判断是否超过 $\lfloor \dfrac n2\rfloor$ 即可，复杂度 $O(nm3^k\log nm)$。

最后我们把颜色数限制放开，计算一下上面的运算量，发现还不到 $10^6$，甚至都跑不满。这就启示我们使用随机化（

我们每次把颜色随机分成 $k$ 组，把每组看成一种颜色，然后进行上面的过程，取个最优解就行了。

那么我们需要随多少次呢？显然，最优解的颜色正好错排的概率是 $\dfrac {k!}{k^k}$，大约是 $3.8\%$，那么我们随机 $200$ 次，出错的概率就不到千分之一了，复杂度 $O(Tnm3^k\log nm)$，其中 $T$ 为随机次数。由于剪枝比较强，可以轻松跑过。


---

## 作者：TianyiLemon (赞：6)

主要讲讲这类算法的正确率怎么分析，这样以后就不用瞎猜了。

顺便提一下，这题用的随机化 trick 在学术界叫作 color-coding，是很正经的算法，大家可以去搜一下论文。

color-coding 的流程是这样的：将每种图案随机映射到 $[0,k-1]$ 中的一个整数，从而将问题归约到一个新问题：找出一个联通块，使得 $0\sim k-1$ 在其中至少出现一次，最小化联通块的大小，如果联通块大小相同，则最小化美味度的中位数大小。

在介绍新问题的解法之前，我们先简单分析一下这个算法的正确率。

假设存在一个包含恰好 $k$ 种图案的联通块，且它是最优的。考虑这个联通块中的图案，所有可能的染色方案总共 $k^k$ 种。其中，恰好是一个 $0\sim k-1$ 排列的染色方案总共 $k!$ 种。

所以，运行一次上述算法，找出这个联通块的概率就是 $P=\frac{k!}{k^k}$。$k=5$ 时，$P≈\frac{1}{26}$。

btw，如果 $k$ 任意，根据斯特林公式，有如下估计：$P≈ \frac{\sqrt{2\pi k}}{e^k}$，虽然并不 practical。

如果最优联通块包含的图案数大于 $k$ 种，找出它的概率一定大于 $\frac{k!}{k^k}$，所以我们只需考虑 $P=\frac{k!}{k^k}$ 的情况。

假设我们运行了 $T$ 次，那么错误率 $\epsilon=(1-P)^T$。

这个东西不容易分析，我们先对它进行一些处理。

令 $\lambda=\frac{1}{P}$，则

$$\begin{aligned}
\epsilon=& \left(1-\frac{1}{\lambda}\right)^T
\\=&\left(\frac{\lambda-1}{\lambda}\right)^T
\\=&\left(\frac{1}{1+\frac{1}{\lambda-1}}\right)^T
\\=&\left(\left(\frac{1}{1+\frac{1}{\lambda-1}}\right)^{\lambda-1}\right)^{\frac{T}{\lambda-1}}
\\=&\left(\frac{1}{\left(1+\frac{1}{\lambda-1}\right)^{\lambda-1}}\right)^{\frac{T}{\lambda-1}}
\end{aligned}
$$

众所周知 $\lim_{n\to \infty}{\left(1+\frac{1}{n}\right)}^n=e$，所以 $\epsilon ≈\left(\frac{1}{e}\right)^{\frac{T}{\lambda-1}}$。

也就是说，我们每运行 $\lambda-1$ 次算法，错误率就会变为原来的 $\frac{1}{e}$，这个结论可以记一下。

代入数据算一下，取 $T=150\sim 200$ ，得到的答案就非常准确了。

接下来考虑新问题怎么做。

第一个限制是好处理的，仿照 Steiner Tree 的思路，设 $f_{S,i,j}$ 代表包含了颜色集合 $S$，当前树根位于$ (i,j)$，最小的联通块大小。

唯一不同的是贡献在点上，所以每次枚举子集的时候要减去根节点的贡献。

对于第二个限制，我们考虑常见的套路：二分 $mid$，将美味度 $\le mid$ 的巧克力的权值设为 $-1$，否则设为 $1$。

如果存在权值和小于 $0$ 的最小联通块，说明最小中位数 $\le  mid$，二分左边界；否则二分右边界。

如何实现 check 函数呢？

我们将 $f_{S,i,j}$ 设为一个二元组 $(cnt,sum)$，分别表示联通块大小和权值和。当 $cnt$ 相等时，最小化 $sum$ 即可。

时间复杂度 $O(T \log nm (3^k nm+2^knm\log nm))$。（写完才发现这里的运行次数 $T$ 好像和数据组数重复了，反正你们理解就行）

这里还有一个剪枝：因为每次二分求出的联通块大小都是相等的，如果这个联通块大小大于当前最优解 $ans$，可以不用二分。

亲测非常有效，对于我这种 STL 选手，运行时间直接从 5s 降到了 1.3s。

代码很丑。

```cpp
#include<bits/stdc++.h>
#define vi vector<int>
#define vvi vector<vi>
#define pII pair<int,int>
#define fi first
#define se second
#define rep(i,x,y) for(int i=(x);i<=(y);++i)
using namespace std;
const int inf=0x3f3f3f3f;
mt19937 gen(time(0));
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
int T,n,m,k,V,C,clr[250],num[250];
pII ans=make_pair(inf,inf);
vvi c,a;
vector<vector<pII>>f[1<<5];
vector<vector<bool>>vs;
pII operator+(const pII&a,const pII&b){return make_pair(a.fi+b.fi,a.se+b.se);}
pII operator-(const pII&a,const pII&b){return make_pair(a.fi-b.fi,a.se-b.se);}
pII operator-(const pII&b){return make_pair(-b.fi,-b.se);}
int id(int x){return lower_bound(num+1,num+V+1,x)-num;}
int sgn(int x){return x&1?-1:1;}
bool valid(int x,int y){return x>=1&&x<=n&&y>=1&&y<=m&&~c[x][y];}
int now=inf,mid;
pII add(int x,int y){return make_pair(1,sgn(a[x][y]<=mid));}
void dij(int p){
	priority_queue<pair<pII,pII>>q;
	vs=vector<vector<bool>>(n+1,vector<bool>(m+1));
	rep(i,1,n)rep(j,1,m)if(valid(i,j))q.emplace(-f[p][i][j],make_pair(i,j));
	while(q.size()){
		pII now=q.top().se;q.pop();
		int x=now.fi,y=now.se;
		if(vs[x][y])continue;
		vs[x][y]=1;
		rep(k,0,3){
			int nx=x+dx[k],ny=y+dy[k];
			if(!valid(nx,ny))continue;
			if(f[p][nx][ny]>f[p][x][y]+add(nx,ny)){
				f[p][nx][ny]=f[p][x][y]+add(nx,ny);
				q.emplace(-f[p][nx][ny],make_pair(nx,ny));
			}
		}
	}
}
bool check(){
	rep(p,0,(1<<k)-1)f[p]=vector<vector<pII>>(n+1,vector<pII>(m+1,make_pair(inf,inf)));
	rep(i,1,n)rep(j,1,m)if(valid(i,j))
		f[1<<clr[c[i][j]]][i][j]=add(i,j);
	rep(p,1,(1<<k)-1){
		for(int q=p&p-1;q;q=q-1&p)rep(i,1,n)rep(j,1,m)if(valid(i,j)){ 
			f[p][i][j]=min(f[p][i][j],f[q][i][j]+f[p-q][i][j]-add(i,j));
		}
		dij(p);
	}
	pII ans=make_pair(inf,inf);
	rep(i,1,n)rep(j,1,m)ans=min(ans,f[(1<<k)-1][i][j]);
	now=ans.fi;
	return ans.se<=0;
}
int main(){
	cin>>T;
	while(T--){
		cin>>n>>m>>k;
		ans=make_pair(inf,inf);V=C=0;
		c=a=vvi(n+1,vi(m+1));
		rep(i,1,n)rep(j,1,m)scanf("%d",&c[i][j]),C=max(C,c[i][j]);
		rep(i,1,n)rep(j,1,m)scanf("%d",&a[i][j]),num[++V]=a[i][j];
		sort(num+1,num+V+1);V=unique(num+1,num+V+1)-(num+1);
		rep(i,1,n)rep(j,1,m)a[i][j]=id(a[i][j]);
		int tt=150;
		while(tt--){
			rep(i,1,C)clr[i]=gen()%k;
			now=inf;
			int l=1,r=V;
			while(l<r){
				mid=l+r>>1;
				if(check())r=mid;
				else l=mid+1;
				if(now>ans.fi)break;
			}
			ans=min(ans,make_pair(now,num[l]));
		}
		if(ans.fi==inf)puts("-1 -1");
		else cout<<ans.fi<<" "<<ans.se<<endl;
	}
	return 0;
}
```


---

## 作者：Fucious_Yin (赞：6)

## [THUSCH2017 巧克力](https://www.luogu.com.cn/problem/P7450)

如果你被极其可恶的 **100 分 Unaccepted**，如果你千辛万苦调出了 subtask 1 但是前面却**无可奈何地 TLE**，如果你改了一些代码却**不明所以地 AC** 了，请略略浏览一下这篇题解的最后一个版块。附代码。
***
>给定 $n \times m$ 的网格，以及参数数组 $a$ 和 $c$，分别代表权值和颜色。
>
>选出一个连通块，要求：不能选择 $c = -1$ 的格子，连通块内颜色个数至少为 $k$。
>
>在此基础上最小化连通块内的权值，在此基础上最小化连通块的中位数。

这是一道集随机化、斯坦纳树、二分为一体的好题，~~早闻大名心中仰慕今日一见相见恨晚啊~~。所以如果有不会斯坦纳树的朋友请移步 [oiwiki 斯坦纳树](https://oi-wiki.org/graph/steiner-tree/) 以及 [P6192 最小斯坦纳树](https://www.luogu.com.cn/problem/P6192)，OI Wiki 上讲得很透彻。~~我们 OI Wiki 真是太强啦。~~

下面来分析题目，我们发现题目中给了三个限制：颜色、权值、中位数，然后尤其是颜色个数至少为 $k$ 这个条件极其难搞，我们不妨先把这个条件**放一放**，假设我们已经想好怎么处理，也就是我们已经转化为了：

* 总共只有 $k$ 种颜色，且每种颜色都要包含。

然后我们感觉中位数也能在外层处理，那也先不管她，问题进一步变成了：

* 共有 $k$ 种颜色，每种颜色都要包含，的最小连通块权值。

这牛魔不就是最小斯坦纳树的网格形式吗？！假设大家都会斯坦纳树，那么这一部分的复杂度显然是 $O(nm\ 3^{k} + nm \log nm\ 2^k)$，也就是同一个根枚举子集转移和最短路同集合转移的复杂度，这里我用的是 dij 跑最短路（**埋下伏笔**）。这样我们能够算出最小的连通块权值，当然，把权值全设为 1 即可算出最小连通块大小。

下面加入中位数的限制。题目中也给出了，中位数的定义是第 $\left\lfloor\frac{n+1}{2}\right\rfloor$ 小的数，那么我们可以上二分，二分这个中位数，如果存在至少 $\left\lfloor\frac{n+1}{2}\right\rfloor$ 个数不大于当前值，则当前值能作为中位数。考虑怎么做，我们的斯坦纳树只能算最小权值，这里上一个套路：由于 $n \times m \le 233$，我们不妨令大数 $M = 1000$，设当前二分值为 $mid$，我们把所有小于等于 $mid$ 的权值全设为 $M$，大于 $mid$ 的全设为 $M + 1$。这相当于一个两位的千进制数的状压，低位代表超过 $mid$ 的数个数，高位代表连通块大小。这是正确的，因为在斯坦纳树最小权值和大数 $M > n \times m$ 的前提下，如果多选一个数那么高位会覆盖所有低位贡献，故一定是最小连通块，同时低位也会尽量少选，就是在 $mid$ 的条件下尽量减小中位数。那么令 $tmp$ 为当前 $mid$ 所算出的最小权值，显然有 $tmp = x \times M + y$，则有 $x$ 为连通块大小，$y$ 为最少的大于 $mid$ 的数的个数。那么是否满足中位数条件就可以 $O(1)$ 判断了。

那么现在的复杂度为 $O(\log V\ (nm\ 3^{k} + nm \log nm\ 2^k))$，$V$ 为 $a$ 数组的值域。
***
以上所述，我们已经解决了全局只有 $k$ 种颜色且都要选的子问题，但是你还是会发现，原问题依然跟个刺猬一样。但是作为一位 OIer，你可以不会各种新发明的高科技，但你一定要会：乱搞。所以，我们考虑把局面中的所有颜色，以一个随机的方式映射到 $[1,\ k]$ 之中，然后跑上面的子问题。然后我们要估算一下大概要跑多少次。显然，跑一次得到正确答案的概率就是最为最优解的 $k$ 种颜色在这 $k$ 组中恰好错排的概率，也就是 $\frac{k!}{k^k}$，这东西居然有 $0.0384$，要知道随机化常见的概率可是千分之一万分之一啊，所以我们跑个两百多次绰绰有余了。

另外，这其实不是乱搞，是有严谨分析的。如果你看到了这篇题解，那么离你最近的分析应该是 TianyiLemon 在这一题的题解。建议去学学分析。

综上，我们已经**理论上**解决了这题。加上多测，我们的复杂度为 $O(T\times t \log V\ (nm\ 3^{k} + nm \log nm\ 2^k))$，其中 $T$ 为多测组数，$t$ 为随机次数。
***
>「人生就像一盒巧克力，你永远不知道吃到的下一块是什么味道。」

~~感觉 OI 是一个巨大的【数据删除】。~~

然后我就从又 T 又 WA（卡常且 hacked），改成了只 WA（hacked），又改成了只 T（卡常），最后才过。所以写下来希望有所帮助。

如果你是像这样分析的，那么你的程序很有可能跟我的第一稿差不多：

* 最外层随机映射，然后二分中位数，最内层跑斯坦纳树。

我的这一稿是不仅 hack 没过前面还被卡常了，这里我细想了一下，加了一个**剪枝**：如果随机映射后，最小连通块大小已经大于当前答案，可以直接 continue 掉，因为这显然是一次更劣的映射。然后喜提  **100 分 Unaccepted**。（不过这种写法也有人过，就是这个人 TianyiLemon，牛魔又是他。他不仅外层随机而且用的 stl 堆的 dij，然后还过了，真乃神人也。）

然后急了，百思不得其解开始乱交，以为是判无解和随机的问题，明明 loj 都过了 qwq。然后翻题解，发现大家的写法都是：

* **最外层**二分中位数，然后随机映射，最内层跑斯坦纳树。

好吧，的确是随机的问题。如果我们最外层随机，那随机次数就是妥妥的两百不多不少，但是如果我们调换位置，中间层随机最外层二分，那随机次数就会更多，而且每次随机两百次是独立的，这样会更加稳定可靠。_这么深刻这么深刻这么深刻？？？_

这是真的。那他是怎么 hack 的呢，我也不清楚，我写的时候讨论版因为维护看不了。不过估计应该是对映射要求极其严苛的一个手搓的构造吧。

然后我就 TLE 45，前面 T 飞了。（呜呜呜人家都是 TLE 75，我写的真有这么劣吗？！）然后就很急啊。我在斯坦纳树里的实现是 dij，但是我平时不喜欢用 pair，一般都结构体重载运算符，再加上【数据删除】的 stl 本来常数大得跟【数据删除】一样，就 T 飞了。然后我看到大家大多数都用的 spfa。

* 关于 SPFA，他死了，可她还活着。

为什么这里用 spfa 会比 dij 还要快？感觉其实在很多网格的问题中，spfa 总能发挥出惊人的实力，可能因为网格比较规整，点和边数量相当还算稀疏的缘故吧。我把 dij 换成 spfa，然后直接过了。

那么复杂度我们换一个位置，更准确的是：$O(T\times \log V\ t\ (nm\ 3^{k} + nm\ poly(nm) \ 2^k))$

~~感觉 OI 是一个巨大的【数据删除】。~~
***
虽说自己常数大不要怨天尤人，但这一题启发我们，随机化即使算过概率，也要尽量稳定；死未必死，活未必活，一切都要看情况分析。

[代码](https://loj.ac/s/2000092) 还算规整但是比较长，丢 loj 里大家觉得呢。

---

## 作者：shenxinge (赞：5)

>「人生就像一盒巧克力，你永远不知道吃到的下一块是什么味道。」

原题题意：给你 $n×m$ 个点，每个点含有两个元素 $a_{i,j}$ 和 $c_{i,j}$ 代表这个点的美味值大小和颜色，要求输出包含至少 $k$ 种颜色的联通块使得在点数最少的情况下美味度的中位数最小并输出他们。

考虑到这个 $k$ 很小，比较符合斯坦纳树的条件，所以在对于颜色总数较小的情况下直接跑斯坦纳树即可。但是颜色的总数可能很大，选择的方案有很多，不可以全部都枚举，这个时候就需要祭出**随机化**。也就是将颜色随机映射到 $[0,k)$ 上。

为什么这道题目可以进行随机化？

考虑某次斯坦纳树选择的解恰好为最优解选择的 $k$，最优解的种类情况就是对于 $k$ 的全排列，也就是方案数为 $k!$，然后考虑总方案数, 总共 $k$ 个位置上每个位置都有 $k$ 中选择，方案数为 $k^k$， 所以成功的概率为 $P=k!/k^k$。当 $k=5$ 时，成功概率 $P$ 只有 $0.0384$，这样跑一次是明显不够的。

很明显做 $T$ 次随机化之后 $(1-P)^{T}$ 明显当 $T$ 变得很大时错误率会很小。也就是 $0.9616 ^{T}$, 大概算个 $100$ 次的时候，错误率就可以降到 $2\%$ 以内了，再多算几次错误率就会降到很小很小，考虑和时间复杂度结合分析选择 $T$ 的大小。~~通过研究表明~~，做 $200$ 次随机化是完全可行的。 

然后考虑的是如何求出美味值的中位数，考虑进行二分，对于其小于 $mid$ 的美味值将其权重变为 $\inf-1$ 大于 $mid$ 的美味值将其权重变为 $\inf+1$，这样就可以保证是在其点数最小的情况下取到的中位数最小值。

代码如下，时间复杂度 $O(T \cdot 3^k \cdot nm \cdot \log_2nm)$，稍微估一下 $T$ 的大小跑 $T$ 遍随机化即可，由于有 $5$ 组且时限为 $5$ s，所以按上述时间复杂度考虑范围即可，这里取得是 $210$ 次。 ~~(绝对没有什么特殊的含义)~~ 

一个小点是在合并时其值会算两次，所以要减去点权。

```
#include<bits/stdc++.h>
#define Debug if(true)
#define x first
#define y second
#define pb push_back
#define For(i,a,b) for(int i=(a);i<=(b);i++)
#define Rep(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int maxn=235,maxk=7,inf=0x3f3f3f3f;
inline int read()
{
	int x=0,f=1;char c;
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-f;
	for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	return x*f;
}
mt19937 cjlak1o1(11451419);
//跑n多次斯坦纳树，随机化，给mid赋大权值
int n,m,k;
int dp[maxn][maxn][1<<maxk];
int c[maxn][maxn],w[maxn][maxn],a[maxn][maxn];
int col[maxn],cnt,to[maxn];

int dx[4]={0,0,1,-1};
int dy[4]={-1,1,0,0};
queue<pair<int,int> > que;
bool inq[maxn][maxn];
inline bool in_map(int x,int y)
	{return (x>=1)&&(x<=n)&&(y>=1)&&(y<=m);}
inline void SPFA(int st)
{
	while(!que.empty())
	{
		pair<int,int> u=que.front();que.pop(),inq[u.x][u.y]=false;
		For(i,0,3)
		{
			int tx=u.x+dx[i],ty=u.y+dy[i];
			if(!in_map(tx,ty)||c[tx][ty]==-1) continue;
			if(dp[u.x][u.y][st]+w[tx][ty]<dp[tx][ty][st])
			{
				dp[tx][ty][st]=dp[u.x][u.y][st]+w[tx][ty];
				if(!inq[tx][ty]) que.push({tx,ty}),inq[tx][ty]=true;
			}
		}
	}
}
inline int stenenior_tree(int ans=inf)
{
	For(_,1,210)
	{
		shuffle(col+1,col+1+cnt,cjlak1o1);
		For(i,1,cnt) to[col[i]]=i%k;
		int maxs=1<<k;
		For(st,1,maxs-1) For(i,1,n) For(j,1,m) dp[i][j][st]=inf;
		For(i,1,n) For(j,1,m) if(~c[i][j]) dp[i][j][1<<to[c[i][j]]]=w[i][j];
		For(st,1,maxs-1)
		{
			For(i,1,n)
				For(j,1,m) 
					if(~c[i][j])
					{
						for(int sub=st&(st-1);sub;sub=(sub-1)&st)
							dp[i][j][st]=min(dp[i][j][st],dp[i][j][sub]+dp[i][j][st^sub]-w[i][j]);
						if(dp[i][j][st]!=inf) que.push({i,j});
					}
			SPFA(st);
		}
		For(i,1,n) For(j,1,m) ans=min(ans,dp[i][j][maxs-1]);
	}
	return ans;
}
signed main()
{
	int T=read();
	while(T--)
	{
		cnt=0;
		n=read(),m=read(),k=read();
		For(i,1,n) For(j,1,m) c[i][j]=col[++cnt]=read();
		For(i,1,n) For(j,1,m) a[i][j]=read(),w[i][j]=1;
		sort(col+1,col+1+cnt);
		cnt=unique(col+1,col+1+cnt)-col-1;
		int ans=stenenior_tree();
		if(ans==inf) {puts("-1 -1");continue;}
		int l=0,r=1e6,res=0;
		while(l<=r)
		{
			int mid=(l+r)>>1;
			For(i,1,n) For(j,1,m)
				w[i][j]=(a[i][j]<=mid)?9999:10001;
			if(stenenior_tree()<=ans*10000) res=mid,r=mid-1;
			else l=mid+1;
		}
		printf("%d %d\n",ans,res);
	}
	return 0;
}
```


---

## 作者：born_to_sun (赞：4)

前置知识：**斯坦纳树**，如果你不会，请先学习[模板：斯坦纳树](https://www.luogu.com.cn/problem/P6192)。

### 形式化题意
给定一张挖掉部分点的网格图，每个点有一个颜色 $c_{i,j}$ 和权值 $a_{i,j}$，求一个连通块，满足该连通块的颜色种类数 $\geq k$，最小化连通块内点的数量，在此基础上，最小化点权的中位数。

### 解题思路
设连通块最小点的数量为 $ans$，套路化的，二分中位数 $mid$，统计 $\gt mid$ 的数量，判断是否 $\leq \lfloor{n\over 2}\rfloor$ 即可。

类似的思路还有题目：[P2839 [国家集训队] middle](https://www.luogu.com.cn/problem/P2839)（要用到主席树）。

朴素的 $dp$ 方法为：设 $f_{x,y,S}$ 表示根为点 $(x,y)$，包含颜色的集合为 $S$ 的最小点权，其中 $S$ 是一个二进制串，范围是 $[0,2^{\max c_{i,j}})$，转移跟最小斯坦纳树一样，这样你可以获得 $30$ 分的高分。

但是你发现 $k$ 值域很小，最大才 $5$，是否可以利用这一性质过掉此题？

于是就有了~~正解~~：**随机化**。

考虑对每个颜色 $c_{i,j}$，将它随机映射为 $[0,k)$ 中的一个颜色，然后跑最小斯坦纳树，我们随机多次，取最优解，就很有可能得到正确结果。

设随机化次数为 $sum$，二分复杂度为 $\log(nm)$，最小斯坦纳树复杂度为 $3^knm+2^knm\log(nm)$，
总时间复杂度为 $O(Tsum\log(nm)(3^knm+2^knm\log(nm)))$。

### 注意事项：
+ 随机次数大概在 $200$ 次时准确率就很高了，且不会 TLE。
+ 如果你常数过大，根本无法随机 $200$ 次，可以尝试将 $a_{i,j}$ **离散化**，缩小二分值域。
+ 注意本题的斯坦纳树求的是最小点权，在枚举子集时需要**减去根的权值**，避免重复计算。
+ 关于求解斯坦纳树时如何得出点权 $\gt mid$ 的点数量，一种方法是采用 pair，但是因为二倍常数可能会 T 掉（笔者就是如此）；另一种方法是将 $\leq mid$ 的点权设为 $inf$，$\gt mid$ 的点权设为 $inf+1$，这样算出的结果除以 $inf$ 就是点的总数，对 $inf$ 取模就是 $\gt mid$ 点的数量。

### 关于随机化下正确性的证明
假设正确答案对应的颜色集合 $S$ 唯一，能够得出正确答案当且仅当 $S$ 中每一个颜色被映射到的颜色不同，概率为 $k!\over k^k$，分子为合法方案数，分母为总方案数，这个值大约是 $0.0384$，我们重复 $200$ 次，得出正确答案的概率为 $0.9996$，这足够通过本题了！
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 mt(time(0));
int rd(int l,int r){
	return mt()%(r-l+1)+l;
}
const int inf=1e6;
int n,m,k;
int a[240][240];//color
int aa[240][240];
int nw[255];
int b[240][240],bb[240][240];//val
int mx;
int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};
int f[240][240][33];
int c[240],tot=0;
struct no{
	int x,y;
	int ds;
};
bool operator <(const no &n1,const no &n2){
	return n1.ds>n2.ds;
}
int vis[255][255];
void dij(int s){
	priority_queue<no> q;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]<0) continue;
			vis[i][j]=0;
			q.push({i,j,f[i][j][s]});
		}
	}
	while(!q.empty()){
		int x=q.top().x,y=q.top().y;int ds=q.top().ds;q.pop();
		if(vis[x][y]) continue;
		vis[x][y]=1;
		for(int i=0;i<4;i++){
			int xx=x+dx[i],yy=y+dy[i];
			if(a[xx][yy]<0) continue;
			if(f[xx][yy][s]>ds+b[xx][yy]){
				f[xx][yy][s]=ds+b[xx][yy];
				q.push(no{xx,yy,f[xx][yy][s]});
			}
		}
	}
}
int solve(int mx){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			memset(f[i][j],63,sizeof(f[i][j]));
			if(a[i][j]<0) continue;
			f[i][j][1<<a[i][j]]=b[i][j];
		}
	}
	for(int s=1;s<(1<<mx);s++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(a[i][j]<0) continue;
				for(int t=s;t;t=(t-1)&s){
					f[i][j][s]=min(f[i][j][s],f[i][j][t]+f[i][j][s^t]-b[i][j]);
				}
			}
		}
		dij(s);
	}
	int ans=1000*inf;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			ans=min(ans,f[i][j][(1<<mx)-1]);
		}
	}
	return ans;
}
bool check(int mid,int op=0){
	int ans=inf*1000;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			b[i][j]=(bb[i][j]>mid? inf+1: inf);
		}
	}
	for(int xx=1;xx<=200;xx++){
		for(int i=1;i<=mx;i++) nw[i]=rd(0,k-1);
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(a[i][j]<0) continue;
				a[i][j]=nw[aa[i][j]];
			}
		}
		ans=min(ans,solve(k));
	}
	if(op){
		cout<<ans/inf<<" "<<c[mid]<<'\n';
	}
	return ans%inf<=ans/inf/2;
}
void solve(){
	int low=1,high=tot;
	int res=1;
	while(low<=high){
		int mid=(low+high)>>1;
		if(check(mid)) res=mid,high=mid-1;
		else low=mid+1;
	}
	check(res,1);
}
set<int> st;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int T;cin>>T;
	while(T--){
		mx=0;st.clear();
		cin>>n>>m>>k;tot=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++) cin>>a[i][j],aa[i][j]=a[i][j],mx=max(mx,a[i][j]),st.insert(a[i][j]);
		}
		for(int i=0;i<=n+1;i++) a[i][0]=a[i][m+1]=-2;
		for(int j=0;j<=m+1;j++) a[0][j]=a[n+1][j]=-2;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++) cin>>b[i][j],c[++tot]=b[i][j];
		}
		sort(c+1,c+1+tot);
		tot=unique(c+1,c+1+tot)-c-1;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++) bb[i][j]=b[i][j]=lower_bound(c+1,c+1+tot,b[i][j])-c;
		}
		if(st.size()<k){
			cout<<"-1 -1\n";continue;
		}
		solve();
		// cout<<check(7);
	}
	return 0;
}
```

---

## 作者：Aiopr_2378 (赞：2)

solution of P7450 [THUSCH2017] 巧克力

## 解题思路

先考虑解决选出巧克力块数最小。

发现如果巧克力的种类（$c_{i,j}$）很小，可以转化为[最小斯坦纳树](https://www.luogu.com.cn/problem/P6192)。具体地，对每对相邻的未被挤压的巧克力建边，点权就是 $1$。令 $f_{i,S}$ 表示选出包括种类集合 $S$ 的巧克力，以节点 $i$ 为树根的最小权值和。记 $v_i$ 为节点 $i$ 的点权，进行如下转移：

$$
f_{i,S}=\min_{T\subseteq S}\{f_{i,T}+f_{i,S\backslash T}-v_i\}
$$

这是一个子集 DP，复杂度 $O(N3^k)$，其中 $N$ 为合法点数之和，下同。

$$
f_{i,S}=\min\{f_{j,S}+v_j\}
$$

这个式子可以在每一层（$S$ 同）使用最短路求解，时间复杂度 $O(2^kN\log N)$。

对于巧克力种类很大的情况，考虑讲每一种巧克力 $c_{i,j}$ 随机映射到 $1\sim 5$ 中，转化为上述情况。一次映射的正确率为 $P=\dfrac{k!}{k^k}=0.0384$，而映射 $120$ 次左右，错误率接近 $(1-P)^{120}=0.009$，可以被接受。

然后考虑怎样找到中位数。使用经典套路，对其进行二分，对于每个点的美味值 $a_{i,j}$，如果大于 $mid$，则设置点权为 $10000+1$，否则设置为 $10000-1$。最后按上面写的方法跑 $120$ 次最小斯坦纳树，将答案与 $10000N$ 比较即可。

总时间复杂度 $O(TQ\log V(2^kN\log N+3^kN))$，其中 $Q$ 为映射次数，笔者取 $125$ 次。

**注意常数优化。**

## 参考代码

```cpp
#include<iostream>
#include<cstring>
#include<random>
#include<chrono>
#include<algorithm>
#include<queue>
#include<cstdio>
using namespace std;
#define MAXN 255
#define inf 0x3f3f3f3f
mt19937 rnd(time(0));
int T,n,m,K,f[MAXN][MAXN][50],a[MAXN][MAXN],c[MAXN][MAXN];
int col[MAXN],top,val[MAXN][MAXN],setcol[MAXN];
bool vis[MAXN][MAXN];
int dx[5]={0,0,-1,1};
int dy[5]={1,-1,0,0};
struct node{
    int x,y,val;
    bool operator<(node k)const{
        return val>k.val;
    }
};
priority_queue<node> q;
void dij(int s){
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) vis[i][j]=0;
    while(q.size()){
        node nd=q.top();
        q.pop();
        int ux=nd.x,uy=nd.y;
        if(vis[ux][uy]) continue;
        vis[ux][uy]=1;
        for(int i=0;i<4;i++){
            int vx=ux+dx[i];
            int vy=uy+dy[i];
            if(vx<1||vx>n||vy<1||vy>m||c[vx][vy]==-1) continue;
            if(f[vx][vy][s]>f[ux][uy][s]+val[vx][vy]){
                f[vx][vy][s]=f[ux][uy][s]+val[vx][vy];
                q.push({vx,vy,f[vx][vy][s]});
            }
        }
    }
}
int solve(){
    int minn=inf;
    for(int tick=1;tick<=125;tick++){
        shuffle(col+1,col+1+top,rnd);
        for(int i=1;i<=top;i++) setcol[col[i]]=i%K+1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                for(int s=0;s<(1<<K);s++) f[i][j][s]=inf;
                if(c[i][j]!=-1) f[i][j][1<<(setcol[c[i][j]]-1)]=val[i][j];
            }
        }
        for(int s=1;s<(1<<K);s++){
            while(q.size()) q.pop();
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++){
                    for(int sub=s&(s-1);sub;sub=s&(sub-1)){
                        f[i][j][s]=min(f[i][j][s],f[i][j][sub]+f[i][j][s^sub]-val[i][j]);
                    }
                    if(f[i][j][s]!=inf) q.push({i,j,f[i][j][s]});
                }
            }
            dij(s);
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++) minn=min(minn,f[i][j][(1<<K)-1]);
        }   
    }
    return minn;
}
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        w=w*10+ch-'0';
        ch=getchar();
    }
    return w*f;
}
int main(){
    T=read();
    while(T--){
        n=read(),m=read(),K=read();
        int maxx=0;
        top=0;
        for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
            c[i][j]=read();
            if(c[i][j]!=-1) col[++top]=c[i][j];
        }
        for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
            a[i][j]=read();
            val[i][j]=1;
            maxx=max(maxx,a[i][j]);
        }
        sort(col+1,col+1+top);
        top=unique(col+1,col+1+top)-col-1;
        int ans=solve();
        if(ans==inf){
            printf("-1 -1\n");
            continue;
        }
        int l=0,r=maxx;
        while(l<r){
            int mid=(l+r)>>1;
            for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
                if(a[i][j]>mid) val[i][j]=10001;
                else val[i][j]=9999;
            }
            int now=solve();
            if(now<=ans*10000) r=mid;
            else l=mid+1;
        }
        printf("%d %d\n",ans,l);
    }
    return 0;
}
```

---

## 作者：Cindy_Li (赞：1)

中位数的限制是经典二分，$\le mid$ 的权值 $-1$，$>mid$ 的权值 $1$，看是否存在权值和 $\le 0$ 的连通块。

于是转化为求包含 $k$ 种颜色，大小最小的连通块，权值和的最小值。

不妨认为只有 $k$ 种颜色，这样就是[斯纳坦树](https://oi-wiki.org/graph/steiner-tree/)板子。

神奇的是，我们完全可以把颜色随机映射到 $[0,k-1]$，最优连通块恰好错排的概率是 $P=k!/k^k$，$(1-P)^{200}$ 就已经 $\le 1\%$，错误率非常低。

可能是我太常数大师了，在 Luogu 上卡了好多发 TLE/WA。

后来我进行了一个常数 $/2$ 的极限优化！

注意到题中 $a_i$ 的值域是 $10^6$，但是我们一共只有 $233$ 个数，在 $[0,10^6]$ 上二分不是太傻了吗。

于是我们给 $a_i$ 离散化！显然这并不影响求中位数，并且可以 $\log 10^6\approx 20 \to \log 233\approx 8$，大大的优化！

```c++
#define pii pair<int,int>
#define fr first 
#define sc second
inline pii operator+(pii a,pii b){return {a.fr+b.fr,a.sc+b.sc};};
inline pii operator-(pii a,pii b){return {a.fr-b.fr,a.sc-b.sc};};
const int N=235,K=5;
const int inf=1e9;
int n,m,k;
int a[N][N],c[N][N];
pii f[N][N][(1<<K)+5],w[N][N];
int dx[]={1,-1,0,0};
int dy[]={0,0,1,-1};

queue<pii > q;
bool inq[N][N];
inline void spfa(int s){
    while(!q.empty()){
        auto u=q.front();q.pop();
        int i=u.first,j=u.second;
        inq[i][j]=0;
        rep(o,0,3){
            int nx=i+dx[o],ny=j+dy[o];
            if(nx<1 || nx>n || ny<1 || ny>m || c[nx][ny]==-1) continue;
            if(f[i][j][s]+w[nx][ny]<f[nx][ny][s]) {
                f[nx][ny][s]=f[i][j][s]+w[nx][ny];
                if(!inq[nx][ny]) q.push({nx,ny}),inq[nx][ny]=1;
            }
        }
    }
}

mt19937 rnd(time(0));
int col[N];
inline pii calc(int mid){
    rep(i,1,n) rep(j,1,m) w[i][j]={1,a[i][j]<=mid?-1:1};
    pii res={inf,inf};
    rep(_,0,200){
        rep(i,1,n*m) col[i]=rnd()%k;
        rep(i,1,n) rep(j,1,m) {
            if(c[i][j]==-1) continue;
            rep(s,0,(1<<k)-1) f[i][j][s]={inf,inf};
            f[i][j][0]=w[i][j];
            f[i][j][1<<col[c[i][j]]]=w[i][j];
        }
        rep(s,1,(1<<k)-1){
            rep(i,1,n) rep(j,1,m){
                if(c[i][j]==-1) continue;
                for(int t=(s-1)&s;t;t=(t-1)&s)
                    f[i][j][s]=min(f[i][j][s],f[i][j][t]+f[i][j][s^t]-w[i][j]);
                if(f[i][j][s].fr!=inf) inq[i][j]=1,q.push({i,j});
            }
            spfa(s);
        }
        rep(i,1,n) rep(j,1,m) 
            if(c[i][j]!=-1) res=min(res,f[i][j][(1<<k)-1]);
    }
    return res;
}

int va[N];
inline void work(){
    read(n),read(m),read(k);
    rep(i,1,n) rep(j,1,m) read(c[i][j]);
    rep(i,1,n) rep(j,1,m) read(a[i][j]);
    int tot=0;
    rep(i,1,n) rep(j,1,m) va[++tot]=a[i][j];
    sort(va+1,va+tot+1),tot=unique(va+1,va+tot+1)-va-1;
    rep(i,1,n) rep(j,1,m) 
        a[i][j]=lower_bound(va+1,va+tot+1,a[i][j])-va;
    int sz=calc(0).fr;
    if(sz>n*m) 
        return printf("-1 -1\n"),void();
    int l=1,r=tot;
    while(l<r){
        int mid=(l+r)>>1;
        pii res=calc(mid);
        if(res.second<=0) r=mid;
        else l=mid+1;
    }
    printf("%d %d\n",sz,va[l]);
}
```

---

## 作者：R_shuffle (赞：0)

考虑两个问题分开。首先是最小，由于发现 $k$ 很小，所以考虑对颜色状压。具体的，如果只有 $k$ 种颜色，那么就考虑直接记录哪些颜色出现过。这个是简单的。但是现在不止 $k$ 种颜色，这就导致了不能直接记录。考虑类似哈希的方式，把每种颜色映射到 $[0,k-1]$ 的一个数，然后再状压即可。但是显然不一定最优，考虑多做几次，正确性就能够有保证了。

然后考虑中位数，不妨二分，然后对每个点再多加一个权值，表示是大于还是小于二分出来的值。dp 的时候记录一下就可以 check 了。

时间复杂度为 $O(Tnm3^k\log nm)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
inline int read()
{
    int re=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
    while( isdigit(ch)) re=(re<<3)+(re<<1)+(ch^48),ch=getchar();
    return re*f;
}
mt19937 rnd(time(0));
const int N=250,inf=1e9;
int n,m,k;
int f[N][N][1<<10],c[N][N],w[N][N],a[N][N],un[N*N],tot,mp[N*N];
int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
struct node
{
    int val,x,y;
    node(int V,int X,int Y)
    {
        val=V,x=X,y=Y;
    }
    bool operator <(const node &t) const
    {
        return val>t.val;
    }
};
priority_queue<node>q;
int solve()
{
    int re=inf;
    for(int o=1;o<=100;o++)
    {
        shuffle(un+1,un+tot+1,rnd);
        for(int i=1;i<=tot;i++) mp[un[i]]=i%k;
        for(int S=1;S<(1<<k);S++) for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) f[i][j][S]=inf;
        for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(~c[i][j]) f[i][j][1<<mp[c[i][j]]]=w[i][j];
        for(int S=1;S<(1<<k);S++)
        {
            for(int T=S&(S-1);T;T=(T-1)&S)
            {
                for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
                {
                    if(!~c[i][j]) continue;
                    f[i][j][S]=min(f[i][j][S],f[i][j][T]+f[i][j][S^T]-w[i][j]);
                }
            }
            for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(f[i][j][S]!=inf) q.emplace(f[i][j][S],i,j);
            while(!q.empty())
            {
                auto dq=q.top();
                q.pop();
                if(dq.val!=f[dq.x][dq.y][S]) continue;
                for(int i=0;i<4;i++)
                {
                    int xx=dq.x+dx[i],yy=dq.y+dy[i];
                    if(xx<1||yy<1||xx>n||yy>m||!~c[xx][yy]) continue;
                    if(f[xx][yy][S]>f[dq.x][dq.y][S]+w[xx][yy])
                    {
                        f[xx][yy][S]=f[dq.x][dq.y][S]+w[xx][yy];
                        q.emplace(f[xx][yy][S],xx,yy);
                    }
                }
            }
        }
        for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) re=min(re,f[i][j][(1<<k)-1]);
    }
    return re;
}
void work()
{
    n=read(),m=read(),k=read();
    tot=0;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) c[i][j]=un[++tot]=read();
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) a[i][j]=read(),w[i][j]=1;
    sort(un+1,un+tot+1);
    tot=unique(un+1,un+tot+1)-un-1;
    int ans=solve();
    if(ans==inf)
    {
        cout<<"-1 -1\n";
        return ;
    }
    int l=0,r=1e6,ans2=0;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) w[i][j]=(a[i][j]<=mid?9999:10001);
        if(solve()<=ans*10000) ans2=mid,r=mid-1;
        else l=mid+1;
    }
    cout<<ans<<" "<<ans2<<"\n";
}
signed main(){
#if __MY_TEST__
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int t=read();
    while(t--) work();
}
```

---

## 作者：xuyifei0302 (赞：0)

首先，我们看见巧克力种类数如此小，对于我这个刚学斯坦纳树的蒟蒻，就可以看得出来可以转换成斯坦纳树。

我们开心地写完了代码，结果发现时间复杂度是 $O(2 ^ k \times N \log_{2}{N} )$，完全过不了。但是 $k \le 5$，所以我们考虑直接随机化，我们将每一种巧克力映射到数字 $1 \dots  5$ 中，然后作者开启了无尽的尝试：

![](https://cdn.luogu.com.cn/upload/image_hosting/fpnu8tiy.png)

然后在随机 $90$ 次的时候成功通过。

既然过了，就要想为什么过。

我们可以发现，映射一次的成功率只有 $k$ 的阶乘除以 $k$ 的 $k$ 次幂的概率，大约是 $0.4$ 左右，而映射 $100$ 次的时候，成功率就很接近 $1$ 了。所以映射 $100$ 次以上绝对能成功。

当然，大家也可以挑战自己的运气，看看最少多少次可以通过。

对于找中位数，直接二分即可。

最终，单次映射的复杂度为 $O(\log_{2}{V(2 ^ k \times N \log_{2}{N} + 3 ^ k \times N)})$。

最后是代码环节：

~~代码长了一点，我自己改的时候都不想看~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int INF = 1e16;
struct Node {
	int x, y, dis;
	Node (int x_, int y_, int dis_) {
		x = x_, y = y_, dis = dis_;
	}
};
bool operator < (Node x, Node y) {
	return x.dis > y.dis;
}
int t, n, m, k, c[255][255], color[255], cnt, a[255][255], w[255][255], color1[255], dp[255][255][(1 << 5) | 5], dx[5] = {0, 0, -1, 1}, dy[5] = {1, -1, 0, 0};
bool mark[255][255];
priority_queue<Node> pq;
void dj(int s) {
	for (int i = 1; i <= n; i ++) {
		for (int j = 1; j <= m; j ++) {
			mark[i][j] = false;
		}
	}
	while (!pq.empty()) {
		int x = pq.top().x, y = pq.top().y;
		pq.pop();
		if (mark[x][y]) {
			continue;
		}
		mark[x][y] = true;
		for (int i = 0; i < 4; i ++) {
			int xx = x + dx[i], yy = y + dy[i];
			if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && c[xx][yy] != -1 && dp[xx][yy][s] > dp[x][y][s] + w[xx][yy]) {
				dp[xx][yy][s] = dp[x][y][s] + w[xx][yy];
				pq.push({xx, yy, dp[xx][yy][s]});
			}
		}
	}
}
signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> t;
	mt19937 rnd(time(0));
	while (t --) {
		cin >> n >> m >> k;
//		cout << "OK\n";
		cnt = 0;
		for (int i = 1; i <= n; i ++) {
			for (int j = 1; j <= m; j ++) {
				cin >> c[i][j];
				if (c[i][j] != -1) {
					color[++cnt] = c[i][j];
				}
			}
		}
		int maxn = 0;
		for (int i = 1; i <= n; i ++) {
			for (int j = 1; j <= m; j ++) {
				cin >> a[i][j];
				w[i][j] = 1;
				maxn = max(maxn, a[i][j]);
			}
		}
		sort(color + 1, color + 1 + cnt);
		cnt = unique(color + 1, color + 1 + cnt) - color - 1;
		int minn = INF;
		for (int Rnd = 1; Rnd <= 90; Rnd ++) {
			shuffle(color + 1, color + 1 + cnt, rnd);
			for (int i = 1; i <= cnt; i ++) {
				color1[color[i]] = i % k + 1;
			}
			for (int i = 1; i <= n; i ++) {
				for (int j = 1; j <= m; j ++) {
					for (int k1 = 0; k1 < (1 << k); k1 ++) {
						dp[i][j][k1] = INF;
					}
					if (c[i][j] != -1) {
						dp[i][j][1 << (color1[c[i][j]] - 1)] = w[i][j];
					}
				}
			}
			for (int i = 1; i < (1 << k); i ++) {
				for (int j = 1; j <= n; j ++) {
					for (int k1 = 1; k1 <= m; k1 ++) {
						for (int k2 = i & (i - 1); k2; k2 = i & (k2 - 1)) {
							dp[j][k1][i] = min(dp[j][k1][i], dp[j][k1][k2] + dp[j][k1][i - k2] - w[j][k1]);
						}
						if (dp[j][k1][i] < INF) {
							pq.push({j, k1, dp[j][k1][i]});
						}
					}
				}
				dj(i);
			}
			for (int i = 1; i <= n; i ++) {
				for (int j = 1; j <= m; j ++) {
					minn = min(minn, dp[i][j][(1 << k) - 1]);
				}
			}
		}
//		cout << "OK\n";
		if (minn == INF) {
			cout << "-1 -1\n";
			continue;
		}
		int l = 0, r = maxn, mid = (l + r) >> 1;
		while (l < r) {
//			cout << "OK\n";
			for (int i = 1; i <= n; i ++) {
				for (int j = 1; j <= m; j ++) {
					if (mid < a[i][j]) {
						w[i][j] = 10001;
					} else {
						w[i][j] = 9999;
					}
				}
			}
			int minx = INF;
			for (int Rnd = 1; Rnd <= 90; Rnd ++) {
				shuffle(color + 1, color + 1 + cnt, rnd);
				for (int i = 1; i <= cnt; i ++) {
					color1[color[i]] = i % k + 1;
				}
				for (int i = 1; i <= n; i ++) {
					for (int j = 1; j <= m; j ++) {
						for (int k1 = 0; k1 < (1 << k); k1 ++) {
							dp[i][j][k1] = INF;
						}
						if (c[i][j] != -1) {
							dp[i][j][1 << (color1[c[i][j]] - 1)] = w[i][j];
						}
					}
				}
				for (int i = 1; i < (1 << k); i ++) {
					for (int j = 1; j <= n; j ++) {
						for (int k1 = 1; k1 <= m; k1 ++) {
							for (int k2 = i & (i - 1); k2; k2 = i & (k2 - 1)) {
								dp[j][k1][i] = min(dp[j][k1][i], dp[j][k1][k2] + dp[j][k1][i - k2] - w[j][k1]);
							}
							if (dp[j][k1][i] < INF) {
								pq.push({j, k1, dp[j][k1][i]});
							}
						}
					}
					dj(i);
				}
				for (int i = 1; i <= n; i ++) {
					for (int j = 1; j <= m; j ++) {
						minx = min(minx, dp[i][j][(1 << k) - 1]);
					}
				}
			}
			if (minx <= minn * 10000) {
				r = mid;
				mid = (l + r) >> 1;
			} else {
				l = mid + 1;
				mid = (l + r) >> 1;
			}
		}
		cout << minn << " " << l << "\n";
	}
	return 0;
}
```

---

## 作者：Nygglatho (赞：0)

先考虑另一个问题：对于每块巧克力，有图案 $c_{i,j}(1\le c_{i,j}\le k \lor c_{i,j}=-1)$，以及权值 $d_{i,j}$，求出最小的选择方案使得在选择的巧克力为包含至少 $k$ 个不同的 $c_{i,j}$ 的连通块的前提下选择的 $d_{i,j}$ 和最小。

使用[【模板】最小斯坦纳树](https://www.luogu.com.cn/problem/P6192)的思想，DP 设 $dp(i,j,x)$ 表示选择 $(i,j)$ 的巧克力，并且已经选择的 $c_{i,j}$ 的状态为 $x$ 最小代价，初始 $dp(i,j,\{c_i\})=0$，其余为 $\infty$。

则 $dp(i,j,T)$ 分两种转移：

- $dp(i,j,T)\gets\min\limits_{S\subset T}(dp(i,j,S)+dp(i,j,T\setminus S)-d_{i,j})$。注意由于 $d_{i,j}$ 在 $dp(i,j,S)$ 和 $dp(i,j,T\setminus S)$ 被算了两遍，需要减去。
- 对于一个 $T$，在所有 $(i,j)$ 都计算了 $dp(i,j,T)$ 后，进行 Dijkstra，先对于不为 $\infty$ 的 $dp(i,j,T)$ 加入优先队列，然后进行松弛，即对于优先队列队首的 $(i,j)$，如果 $dp(i,j,T)+d_{x,y}<dp(x,y,T)(c_{x,y}\ne -1\land\max(\lvert i-x\rvert,\lvert j-y\rvert)\le 1)$，则 $dp(x,y,T)\gets dp(i,j,T)+d_{x,y}$ 将 $(x,y)$ 加入优先队列。

最后 $\min\limits_{1\le i\le n,1\le j\le m}dp(i,j,\{c_i\vert i\in[1,k]\})$ 即为答案，时间复杂度 $O(nm3^k+nm2^k\log nm)$。

---

考虑原问题的弱化版，即限定 $1\le c_{i,j}\le k$，先考虑求最小块数 $s_1$，那么相当于前面 $d_{i,j}=1$ 的情况，直接做即可，对于选择的 $a_{i,j}$ 中位数最小，套路地考虑二分中位数，令二分的数为 $s_0$，由于需要让数量仍然为最小值，如果 $a_{i,j}\le s_0$ 则 $d_{i,j}\gets V-1$，否则 $d_{i,j}\gets V+1$，其中 $V$ 是一个足够大的数，做一遍前面的问题，如果答案 $\le V\cdot s_1$ 则 $s_0$ 合法。

---

回到原问题，这里 $c_{i,j}\le n\cdot m$，那么考虑随机染色，对于不同的 $c_{i,j}$，随机映射至 $[1,k]$ 的区间，记为 $c'_{i,j}$（注意如果两个点的 $c_{i,j}$ 相同则这两个点 $c'_{i,j}$ 相同，如果 $c_{i,j}=-1$ 则 $c'_{i,j}=-1$）。

跑弱化版，找到正确答案的概率为 $\dfrac{k!}{k^k}$，大约跑 $200$ 次即可。时间复杂度 $O(200T\cdot (nm3^k+nm2^k\log nm)\cdot\log nm)$。

```cpp
#include "bits/stdc++.h"
#include "ext/pb_ds/assoc_container.hpp"
#include "ext/pb_ds/hash_policy.hpp"
using namespace __gnu_pbds;
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define ll long long
#define ull unsigned long long

#define OPEN freopen (".in", "r", stdin); freopen (".out", "w", stdout);
#define DATA freopen (".in", "w", stdout);

#define pc __builtin_popcount
#define db double
#define pii pair<int, int>
#define fi first
#define se second

#define F(i,x,y) for (int i = (x); i <= (y); ++i)
#define D(i,x,y) for (int i = (x); i >= (y); --i)

int n, m, k;

int c[240][240], a[240][240], _c[240][240];
ll dis[240][240];
ll dp[240][240][256], vis[240][240];
const ll inf = 1ll * 1e6;
vector <ll> _cl;

mt19937 rng(0xC0000005);

gp_hash_table <int, int> _mp;

struct Node {
    int x, y;
    ll dis;
    bool operator <(const Node& p) const {return dis > p.dis;}
};

void Dij (int s) {
    int dx[4] = {-1, 0, 0, 1};
    int dy[4] = {0, -1, 1, 0};
    priority_queue <Node> q;
    F (i, 1, n) F (j, 1, m) {
        if (c[i][j] != -1 && dp[i][j][s] != 1ll * 1e18) {
            q.push({i, j, dp[i][j][s]});
        }
    }
    F (i, 1, n) F (j, 1, m) vis[i][j] = 0;

    while (! q.empty()) {
        Node _u = q.top(); q.pop();
        auto [x, y, Dis] = _u;
        if (vis[x][y]) continue;
        vis[x][y] = 1;
        F (i, 0, 3) {
            int tx = x + dx[i], ty = y + dy[i];
            if (c[tx][ty] == -1 || x < 1 || x > n || y < 1 || y > m) continue;
            if (dp[tx][ty][s] > Dis + dis[tx][ty]) {
                dp[tx][ty][s] = Dis + dis[tx][ty];
                q.push ({tx, ty, dp[tx][ty][s]});
            }
        }
    }
}

void Solve () {
    _mp.clear();
    shuffle (_cl.begin(), _cl.end(), rng);
    F (i, 0, int(_cl.size()) - 1) _mp[_cl[i]] = i % k; // 这里 c[i,j] 映射至了 [0,k)
    F (i, 1, n) F (j, 1, m)
        if (c[i][j] == -1) _c[i][j] = -1; else _c[i][j] = _mp[c[i][j]];
    F (i, 1, n) {
        F (j, 1, m) {
            F (l, 0, (1 << k) - 1) dp[i][j][l] = 1ll * 1e18;
        }
    }

    F (i, 1, n) {
        F (j, 1, m) {
            if (_c[i][j] != -1) dp[i][j][1 << _c[i][j]] = dis[i][j];
        }
    }

    F (s, 1, (1 << k) - 1) {
        F (i, 1, n) F (j, 1, m) {
            for (int t = s & (s - 1); t; t = (t - 1) & s) {
                dp[i][j][s] = min (dp[i][j][s], dp[i][j][t] + dp[i][j][s ^ t] - dis[i][j]);
            }
        }
        Dij (s);
    }
}

ll Get () {
    _mp.clear();
    F (i, 1, n) F (j, 1, m)
        if (c[i][j] != -1 && ! _mp[c[i][j]]) _cl.push_back(c[i][j]), _mp[c[i][j]] = 1;
    ll mn = 1ll * 1e18;
    F (i, 1, 135) { // 这里写的不优，多了 O (nm log nm)，因此只能跑 135 次，对于不同随机种子容易爆，应该前面放在二分外面就不容易爆了
        Solve();
        F (i, 1, n) {
            F (j, 1, m)
                mn = min (mn, dp[i][j][(1 << k) - 1]);
        }
    }
    return mn;
}

void Main() {
    cin >> n >> m >> k;
    F (i, 1, n) F (j, 1, m) cin >> c[i][j];
    F (i, 1, n) F (j, 1, m) cin >> a[i][j];
    F (i, 1, n) F (j, 1, m) dis[i][j] = 1;
    ll L = 0ll, R = inf;
    ll _mn = Get();
    if (_mn == 1ll * 1e18) { // 无解
        cout << "-1 -1\n";
        return ;
    }
    while (L < R) {
        int mid = (L + R) / 2;
        F (i, 1, n) F (j, 1, m)
            if (a[i][j] <= mid) dis[i][j] = inf - 1;
            else dis[i][j] = inf + 1;
        ll Mn = Get();
        if (Mn <= _mn * inf) R = mid;
        else L = mid + 1;
    }
    cout << _mn << ' ' << R << '\n';
}

int main() {
    int T;
    IOS
    cin >> T;
    while (T --> 0) Main();
    // C++14 (GCC 9)
}
```

---

## 作者：LastKismet (赞：0)

# Sol
首先显然只选 $k$ 种最优。那么如何解决这个问题呢？

有一种科技叫 color-coding。我们把原有的所有颜色随机映射到 $[0,k)$ 的值域区间上，那么一个包含 $[0,k)$ 内所有颜色的块必然至少包含 $k$ 种颜色，且这么做得到正确的最小的包含 $k$ 种颜色的块大小的概率极大。正确性证明可以参见[这里](https://www.luogu.com.cn/article/n9hpqrfs)。

于是这就是一个最小斯坦纳树问题。

接下来考虑第二问，最小化中位数。这是个经典套路，我们二分中位数按大小新建正负一序列即可。一个 trick 是给一般的 $-1,1$ 变成 $999,1001$（举个例子），这样就能使程序自动在最小化块数的基础上尽可能地选 $-1$ 块。

记得多测要清空。
# Code
```cpp
#define id(x,y) ((x)*mm+(y))

int n,nn,mm,k;
int c[N],a[N],v[N],to[N];
int cx[N],cm;
vec<int> G[N];
int f[N][1<<K];
queue<int> q;
bool inq[N];
void spfa(int s){
	while(!q.empty()){
		int x=q.front();q.pop();inq[x]=0;
		for(auto y:G[x])if(f[y][s]>f[x][s]+v[y]){
			f[y][s]=f[x][s]+v[y];
			if(!inq[y])q.push(y),inq[y]=1;
		}
	}
}
int solve(){
	int res=inf;
	rep(t,1,200){
		shuffle(cx,cx+cm,rnd);
		repl(i,0,cm)to[cx[i]]=i%k;
		repl(i,0,n)repl(j,0,1<<k)f[i][j]=inf;
		repl(i,0,n)if(~c[i])f[i][1<<to[c[i]]]=v[i];
		repl(s,1,1<<k){
			repl(i,0,n)if(~c[i]){
				for(int t=s&s-1;t;t=s&t-1)chmin(f[i][s],f[i][t]+f[i][s^t]-v[i]);
				if(f[i][s]<inf)q.push(i),inq[i]=1;
			}
			spfa(s);
		}
		repl(i,0,n)if(~c[i])chmin(res,f[i][(1<<k)-1]);
	}
	return res;
}

int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};

inline void Main(){
	read(nn,mm,k);
	cm=0;
	repl(i,0,nn)repl(j,0,mm){read(c[id(i,j)]);if(~c[id(i,j)])cx[cm++]=c[id(i,j)];};
	n=nn*mm;
	sort(cx,cx+cm);cm=unique(cx,cx+cm)-cx;
	repl(i,0,n)if(~c[i])c[i]=lower_bound(cx,cx+cm,c[i])-cx;
	repl(i,0,cm)cx[i]=i;
	repl(i,0,nn)repl(j,0,mm)read(a[id(i,j)]),v[id(i,j)]=!!~c[id(i,j)];
	repl(i,0,nn)repl(j,0,mm)if(~c[id(i,j)])repl(k,0,4){
		int x=i+dx[k],y=j+dy[k];
		if(x<0||x>=nn||y<0||y>=mm||!~c[id(x,y)])continue;
		G[id(i,j)].pub(id(x,y));
	}
	int res=solve();
	if(res==inf)return put((string)"-1 -1");
	int l=0,r=1e6;
	while(l<r){
		int m=l+r>>1;
		repl(i,0,n)v[i]=a[i]<=m?999:1001;
		if(solve()<=res*1000)r=m;
		else l=m+1;
	}
	put(res,' '),put(l,'\n');
	repl(i,0,n)G[i].clear();
}

```

---


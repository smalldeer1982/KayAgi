# 「Wdoi-2」禁断之门对面，是此世还是彼世

## 题目背景

或许是后户之国轻易不与外界联系，或许是神职所限，又或许是性格喜好的原因，摩多罗作为最初建立幻想乡的几位贤者之一，和其他贤者之间的联系并不频繁。其他如八云紫、茨木华扇等贤者均亲身走在幻想乡之中，而摩多罗却置身之外。

耗费神力发动全幻想乡级别的异变，看似规模宏大，其实并未对幻想乡造成真正的伤害，只是让一群笨蛋妖精狂躁了些而已。 

谁也不知道门后的秘神心中真正的想法。

## 题目描述

给定一场长度为 $n$ 的正整数序列 $a$ 和一个长度为 $m$ 的正整数序列 $b$。

现在蓝根据序列 $a$ 与序列 $b$ 构造了一个 $n$ 行 $m$ 列的正整数矩阵 $A$ 满足 $A_{i,j}=a_ib_j$，你需要构造 $n+1$ 行 $t$ 列的正整数矩阵 $B$ 满足以下条件：

- 矩阵的每个元素取值在 $[1,m]$ 间；
- 矩阵同一行的元素**两两**不相同；
- 矩阵的每列**相邻元素**不同；
- 在所有满足上面三项要求的矩阵中**最小化**下式：
$$f(B)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{t}\sum\limits_{k=\min(B_{i,j},B_{i+1,j})}^{\max(B_{i,j},B_{i+1,j})}A_{i,k}$$

请输出构造出的 $B$ 矩阵的 $f(B)$ 的值模 $10^9+7$ 的结果。

## 说明/提示

### 样例解释 1

根据题意，可以构造出矩阵 $A=\begin{bmatrix}54 & 9 \\ 54 & 9 \end{bmatrix}$。

你需要构造出的 $3$ 行 $2$ 列的矩阵 $B=\begin{bmatrix}1 & 2 \\ 2 & 1 \\ 1 & 2 \end{bmatrix}$，此时 $f(B)=252$ 为最小值

可以证明 $f(B)=252$ 为所有情况中，$f(B)$ 的最小值。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n \le } & \bm{m \le } & \bm{t \le } & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 10 & 10 & 10 & - & 5 \\\hline
2 & 100 & 100 & 100 & - & 5 \\\hline
3 & 10^3 & 10^3 & 10^3 & - & 15 \\\hline
4 & 5\times 10^4 & 5\times 10^4 & 5\times 10^4 & - & 30 \\\hline
5 & 5\times 10^5 & 5\times 10^5 & 5\times 10^5 & \textbf{A} & 10 \\\hline
6 & 5\times 10^5 & 5\times 10^5 & 5\times 10^5 & \textbf{B} & 10 \\\hline
7 & 5\times 10^5 & 5\times 10^5 & 5\times 10^5 & - & 25 \\\hline
\end{array}$$

- **特殊性质** $\textbf{A}$：保证 $a_i=1$；
- **特殊性质** $\textbf{B}$：保证 $m=t$。

对于全部数据，保证 $1\le a_i, b_i\le 10^9$，$1\le n, m, t\le 5\times 10^5 $，$t\le m$。保证数据有解。

## 样例 #1

### 输入

```
2 2 2
9 9
6 1```

### 输出

```
252```

## 样例 #2

### 输入

```
10 10 10
2 8 10 10 10 2 5 8 9 3
2 1 5 2 10 7 8 9 10 6
```

### 输出

```
8040
```

# 题解

## 作者：Alex_Wei (赞：13)

> *K. [P8544 「Wdoi-2」禁断之门对面，是此世还是彼世](https://www.luogu.com.cn/problem/P8544)

很棒的一道题目。

先考虑一层 $A_i$ 产生的贡献。

考虑 $A_1$，它产生的贡献为对于每个 $j\in [1, t]$，$B_{1, j}$ 与 $B_{2, j}$ 之间所有下标 $k$ 的 $A_{1, k}$ 之和，令其为 $g(1)$。因为 $A_{1, j} = a_1b_j$，将 $a_1$ 提出，得 $g(1) = a_1h(1)$。全局最小值比较难考虑，我们尝试从局部最小值推出全局最小值。我们发现，如果构造出 $B_1, B_2$ 使得 $h(1)$ 最小，那么令 $B_3, B_5, \cdots$ 取到 $B_1$，$B_4, B_6, \cdots$ 取到 $B_2$，因为所有 $h(i) = h(1)$，所以所有 $h(i)$ 取到理论最小值，因而 $f(B)$ 取到最小值。

上述分析使得我们只需要求出 $h(1)$ 的最小值，将其乘上 $\sum a_i$ 后即为 $\min f(B)$。

进一步地，同一行元素互不相同，这让我们想到二分图匹配。所以 $h(1)$ 的求解又可以描述成如下问题：给定 $c_1\sim c_m$，求 $a_1\sim a_t$ 和 $b_1\sim b_t$，使得 $a_i$ 互不相同且 $1\leq a_i\leq m$，$b_i$ 同理，且 $a_i\neq b_i$，最小化 $\sum\limits_{i = 1} ^ t c(a_i, b_i)$，其中 $c(x, y)$ 表示 $\sum\limits_{i = \min(x, y)} ^ {\max(x, y)} c_i$ 且 $c_i > 0$。

很显然，我们可以用费用流解决上述问题，其中左部点 $x$ 向右部点 $y$ 连容量 $1$，费用 $c(x, y)$ 的边，则恰好 $t$ 条边的最小费用即答案。这样做的复杂度太高了，即使用 KM 也至少 $n ^ 3$。但它并不是完全没有用。它告诉我们，**答案关于 $\boldsymbol t$ 的函数 $\boldsymbol {f(t)}$ 下凸**，因为 **最小费用关于流量下凸**。这是本题相当关键的性质。

回到上述问题，我们发现使 $|x - y|$ 相差太大并不优秀。带着这样的感性理解，**我们先尝试解决 $\boldsymbol{m = t}$ 的情况**。此时每个 $a_i$ 都有一个对应的 $b_i$。如果建出一张 $n$ 个点的图 $G$，$a_i\to b_i$ 连一条边，那么 $G$ 由若干个环组成，因为每个点出度和入度均为 $1$。我们容易得到如下观察：

- 若存在 $a < b < c < d$ 使得 $a, c$ 在同一个环，$b, d$ 在同一个环，则交换 $b, c$ 一定不会使答案变劣。即 **环不相交**。

这说明每个环占用一段连续区间 $[l, r]$。

- 若存在 $a < b < c < d$ 使得 $a \to c \to b \to d$，则交换 $b, c$ 一定更优，即 **边不交叉**。

这说明每个环 $[l, r]$ 形如 $l\to l + 1\to \cdots \to r \to l$。

上述两条结论对环的形态做出了相当严格的规范，已经可以暴力 DP $\mathcal{O}(m ^ 2)$ 或类插头 DP $\mathcal{O}(m)$ 求解。但我们还可以更劲爆一点。

观察长度为 $4$ 的环 $\{1, 2, 3, 4\}$，我们发现 $c_2, c_3$ 贡献三次，$c_1, c_4$ 贡献两次。但若将其拆成两个长度为 $2$ 的环 $\{1, 2\}$ 和 $\{3, 4\}$，$c_1\sim c_4$ 均只贡献两次，更优。而长度为 $2$ 和 $3$ 的环不能再拆分，因为同一列相邻元素不同。因此，任何长度大于 $4$ 的环均可以拆成若干长度为 $2$ 和 $3$ 的环。实际上可以进一步证明长度为 $n(n > 4)$ 的环至多拆出 $n\bmod 2$ 个长度为 $3$ 的环，但对解题不必要。这样一来，直接暴力转移即可做到 $\mathcal{O}(m)$，比类插头 DP 方便一些。

**接下来考虑 $\boldsymbol {t < m}$ 的情况**。我们发现相比于 $m = t$，图 $G$ 上连通块的形态只会新增 **链**。同理可以证明链必然形如 $l\to l + 1\to \cdots \to r$，当然也可以反过来 $r\to l$，但两种情况贡献相等，无需区分。

结合 $t = m$，我们容易得出 DP $f_{i, j}$ 表示前 $i$ 个点产生 $j$ 条边，且这 $j$ 条边的端点均不超过 $i$ 的最小代价。转移时枚举环长 $2, 3$ 或链长 $[2, i]$ 转移，可以做到 $\mathcal{O}(mt ^ 2)$。

类似地，我们将链的转移写成类插头 DP 的形式，设 $f_{i, j, 0 / 1}$，第三维表示当前位置是否有插头，即继续向下延伸的链，则转移形如：

- $f_{i - 1, j - 1, 1} + c_{i - 1} + c_i\to f_{i, j, 1}$ 表示延伸插头。
- $f_{i - 2, j - 1, 0} + c_{i - 1} + c_i \to f_{i, j, 1}$ 表示新开一个插头。
- $f_{i - 2, j - 2, 0} + 2(c_{i - 1} + c_i) \to f_{i, j, 0}$ 表示新增长度为 $2$ 的环 $\{i - 1, i\}$。
- $f_{i - 3, j - 3, 0} + 2(c_{i - 2} + c_i) + 3c_{i - 1} \to f_{i, j, 0}$ 表示新增长度为 $3$ 的环 $\{i - 2, i - 1, i\}$。
- $f_{i - 1, j, 0}\to f_{i, j, 0}$ 表示啥都不干。
- $f_{i, j, 1} \to f_{i, j, 0}$ 表示在位置 $i$ 断掉插头。注意该转移要在 $f_{i, j, 1}$ 的转移结束后进行。

```cpp
void trans() {
  memset(f, 0x3f, sizeof(f));
  f[0][0][0] = f[1][0][0] = 0;
  for(int i = 2; i <= m; i++) {
    memcpy(f[i], f[i - 1], sizeof(f[i]));
    for(int j = 1; j <= t; j++) {
      f[i][j][1] = min(f[i - 1][j - 1][1], f[i - 2][j - 1][0]) + b[i - 1] + b[i];
    }
    for(int j = 2; j <= t; j++) {
      ll coef = 2 * (b[i - 1] + b[i]);
      f[i][j][0] = min(f[i][j][0], f[i - 2][j - 2][0] + coef);
    }
    if(i > 2) {
      for(int j = 3; j <= t; j++) {
        ll coef = 2 * (b[i - 2] + b[i]) + 3 * b[i - 1];
        f[i][j][0] = min(f[i][j][0], f[i - 3][j - 3][0] + coef);
      }
    }
    for(int j = 0; j <= t; j++) f[i][j][0] = min(f[i][j][0], f[i][j][1]);
  }
}
```

这样可以做到小常数 $\mathcal{O}(m ^ 2)$，结合 $m = t$ 可以获得 $35$ 分的高分！

看起来没有什么优化空间了。但这种限制了选取物品个数，且答案关于物品个数具有凸性的 DP，很难不让人想到 **wqs 二分**。想到这里，结合 $m ^ 2$ DP，我们已经完整解决了这道题目。如果你不会 wqs 二分，欢迎通过我的 [博客](https://www.cnblogs.com/alex-wei/p/DP_Involution.html) 学习。时间复杂度 $\mathcal{O}(m\log v)$。分析长为 $2, 3$ 的环的贡献差易知 $v\leq 3b_i$ 即 $3\times 10 ^ 9$。

实际上 “很难不让人想到 wqs” 这句话是在口嗨，因为我自己就没想到。我分析到 $m ^ 2$ 之后一直在想怎么贪心模拟费用流，结果做不动。点开标签一看凸完全单调性豁然开朗。

吐槽一句：$a_i = 1$ 和原问题等难，$n, m, t \leq 5\times 10 ^ 4$ 估计也和正解差不多，所以 $35$ 和 $100$ 分之间没有其它分数。区分度有点低。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using ull = unsigned long long;
inline ll read() {
  ll x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
inline void print(int x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
constexpr int N = 5e5 + 5;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 0x3f3f3f3f3f3f3f3f;
void add(int &x, int y) {x += y, x >= mod && (x -= mod);}
struct dat {
  ll val, num;
  dat operator + (const dat &x) const {return {val + x.val, num + x.num};}
  bool operator < (const dat &x) const {
    return val != x.val ? val < x.val : num < x.num;
  }
} f[N][2];
int n, m, t, coef;
ll b[N];
int calc(ll mid) {
  f[0][0] = f[1][0] = {0, 0};
  f[0][1] = f[1][1] = {inf, 0};
  for(int i = 2; i <= m; i++) {
    f[i][0] = f[i - 1][0];
    dat coef = {b[i - 1] + b[i] - mid, 1};
    f[i][1] = min(f[i - 1][1], f[i - 2][0]) + coef;
    coef = {2 * (b[i - 1] + b[i]) - 2 * mid, 2};
    f[i][0] = min(f[i][0], f[i - 2][0] + coef);
    if(i > 2) {
      coef = {2 * (b[i - 2] + b[i]) + 3 * b[i - 1] - 3 * mid, 3};
      f[i][0] = min(f[i][0], f[i - 3][0] + coef);
    }
    f[i][0] = min(f[i][0], f[i][1]);
  }
  return f[m][0].num;
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  cin >> n >> m >> t;
  for(int i = 1; i <= n; i++) add(coef, read());
  for(int i = 1; i <= m; i++) b[i] = read();
  ll l = 1, r = 3e9;
  while(l < r) {
    ll mid = l + r + 2 >> 1;
    if(calc(mid) <= t) l = mid;
    else r = mid - 1;
  }
  calc(l);
  cout << (f[m][0].val + l * t) % mod * coef % mod << endl;
  cerr << TIME << " ms\n";
  return 0;
}
```

---

## 作者：离散小波变换° (赞：9)

首先是进行一个柿子的推：

$$\begin{aligned}
f(B)&=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{t}\sum\limits_{k=\min(B_{i,j},B_{i+1,j})}^{\max(B_{i,j},B_{i+1,j})}A_{i,k} \\
&=\sum\limits_{i=1}^{n}a_i\sum\limits_{j=1}^{t}\sum\limits_{k=\min(B_{i,j},B_{i+1,j})}^{\max(B_{i,j},B_{i+1,j})}b_k \\
&=\sum\limits_{i=1}^{n}a_i\sum\limits_{j=1}^{t} s_{\max(B_{i,j},B_{i+1,j})}-s_{\min(B_{i,j},B_{i+1,j})-1} 
\end{aligned}$$

其中，$s_i=\sum_{j=1}^i b_j$。

注意到，$B$ 矩阵是一个 $n+1$ 行 $t$ 列的矩阵。一共会计算 $n$ 次贡献。每次会取出 $B$ 矩阵的相邻两行 $i$ 和 $i+1$，它们的贡献是 $\varphi(B_i,B_{i+1})$。其中 $\varphi(a,b)$ 定义如下：

$$\begin{aligned}
\varphi(a,b)&=\sum_{i=1}^t s_{\max(a_i,b_i)}-s_{\min(a_i,b_i)-1}\\
&=\sum_{i=1}^t s_{\max(b_i,a_i)}-s_{\min(b_i,a_i)-1}\\
&=\varphi(b,a)
\end{aligned}$$

也就是说，假如 $B_{2k+1}=P$，$B_{2k}=Q$，其中 $P,Q$ 为长度为 $t$ 的值域范围 $[1,m]$ 的每个元素互不相同且 $P,Q$ 对应位置值不同的序列，那么总贡献就是：

$$\left(\sum_{i=1}^n a_i\right) \varphi(P,Q)$$

从行来看，$B$ 经历了一个 $P\to Q\to P\to Q\to \cdots$ 的过程。可以证明，存在一种最优的方案就长成这种形状。

假设有某一种方案，形如 $B_1\to B_2\to \cdots \to B_{n+1}$，那么它的贡献就是 $\varphi(B_1,B_2)+\varphi(B_2,B_3)+\cdots+\varphi(B_{n-1},B_n)$。那么我们可以从这一大堆 $\varphi$ 里挑出**值最小**的，比如 $\varphi(B_k,B_{k+1})$。那么我们就可以构造出这样一组方案：$B_k\to B_{k+1}\to B_k\to \cdots$。容易发现，这组方案不可能会更劣。令 $P=B_k,Q=B_{k+1}$，可以发现存在一种形如 $P\to Q\to P\to Q\to \cdots$ 的方案是最优的。

也就是说，我们的问题转化为，找到一个 $P$，找到一个 $Q$，其中 $P,Q$ 为长度为 $t$ 的值域范围 $[1,m]$ 的每个元素互不相同且 $P,Q$ 对应位置值不同的序列，使得 $\varphi (P,Q)$ 最小。

假如我们把 $1\sim m$ 排成一列记作列 $\alpha$，视作 $P$ 的可选元素；另外再排一列 $1\sim m$，视作 $Q$ 的可选元素，记作列 $\beta$。我们的任务变成：

- 从 $\alpha$ 当中选择 $t$ 个元素，依次**匹配**上 $\beta$ 内的 $t$ 个元素，且不存在形如 $(i,i)$ 的匹配，最小化这一组匹配的价值。一对匹配的价值的计算方式是，假定有一对匹配 $(a,b)$，那么这一对匹配的价值就是 $S_{\max(a,b)}-S_{\min(a,b)-1}$；一组匹配的价值是，它里面所有的匹配的价值之和。

如果把它转化成费用流的模型，应该长这样：

- 有一个源点 $S$、汇点 $T$、中继点 $S'$ 和 $T'$。
- $S$ 连向了 $S'$ 点，流量为 $t$，费用为 $0$。
- $S'$ 点连向了点 $1,2,3,\cdots m$，流量为 $1$，费用为 $0$。
- $T'$ 连向了 $T$ 点，流量为 $t$，费用为 $0$。
- 点 $1,2,3,\cdots m$ 连向了 $T'$ 点，流量为 $1$，费用为 $0$。
- 对于 $(i,j),1\le i,j\le m,i\neq j$，点 $i$ 连向了点 $j'$，流量为 $1$，费用为 $S_{\max(i,j)}-S_{\min(i,j)-1}$。

要求在满流的前提下最小化费用，也就是最小费用最大流。

但是直接跑费用流是会 $\text{TLE}$ 的。注意一个重要性质：

- 存在一种最优解，对于任意 $\alpha$ 内的点 $a$，它只会匹配 $\beta$ 内的点 $a-2,a-1,a+1,a+2$（如果这个点存在的话）。

考虑使用调整法证明。

从左往右考虑 $\alpha$ 和 $\beta$ 的每个列。假定第 $i$ 列上 $\alpha_i$（或者 $\beta_i$，其实无所谓，因为你交换 $\alpha$ 和 $\beta$ 就一样了）不符合要求。值得注意的是，如果 $\alpha_i$ 不符合要求，它一定是连接到了 $\beta_{i+2}$ 右侧的点上去（不可能是 $\beta_{i-2}$ 左侧的点上去，否则 $\beta_{i-2}$ 左侧的那个点就是枚举到的第一个不符合性质的点了）。

- 如果 $\beta_{i+1}$ 或者 $\beta_{i+2}$ 还没有被占用，那么 $\alpha_i$ 连上那个没被占用的点，肯定是更优的。下面考虑 $\beta_{i+1},\beta_{i+2}$ 均被占用。
- 考虑 $\alpha_i$ 占用了 $\beta_k$，$\alpha_{x}$ 占用了 $\beta_{i+1}$，$\alpha_y$ 占用了 $\beta_{i+2}$。注意到 $x,y$ 肯定都比 $i$ 大。
  - 如果 $x=k$，那么我们可以让 $\alpha_i$ 连上 $\alpha_{i+2}$，让 $\alpha_{y}$ 连上 $\beta_k$。由于 $y\neq x=k$，于是这必定合法。![](https://cdn.luogu.com.cn/upload/image_hosting/nqacgjgi.png)![](https://cdn.luogu.com.cn/upload/image_hosting/mokrt3dn.png)
  - 如果 $x\neq k$，那么我们可以让 $\alpha_i$ 连上 $\alpha_{i+1}$，让 $\alpha_{x}$ 连上 $\beta_k$。由于 $x\neq k$，于是这必定合法。![](https://cdn.luogu.com.cn/upload/image_hosting/j58zojf0.png)

为什么这样肯定不劣呢？我们本质上是交换了两组匹配。对于 $i$ 来说，它匹配的位置向左移动了一格，代价减小；对于 $i$ 右侧那个被匹配的点来说，它匹配的位置向右移动到了 $k$ 的右侧，简单讨论一下就能发现总代价是减小了。

这样子有什么用呢？

考虑这样一个问题：

- 现在要从 $\alpha$ 中选出**任意个数**，匹配 $\beta$ 内的元素，使得费用和最小。比较常规的做法是，从左往右依次判断 $\alpha$ 内每个点咋连的。也就是设 $f(i)$ 表示考虑到前 $i$ 个点，连接后的最小费用。

现在问题拓宽到了恰好 $t$ 个数。怎么做呢？

考虑使用 $\textbf{wqs}$ **二分**解决本题。具体而言，我们给每个 $\alpha_i$ 加上一个相同的额外权重 $w$（可能为**负数**），作为选择这个数来匹配带来的代价。容易发现，随着 $w$ 的增加，那么费用最小的方案所使用的 $\alpha$ 肯定是**非严格单调递减**的。记 $w=x$ 时，费用最小的方案所使用的 $\alpha$ 内元素的个数为 $c_w$。

凸性的证明：

因为该问题等价于那个费用流问题，而费用流模型的函数一定是凸的，所以这个也是凸的，可以直接套 $\text{wqs}$ 二分。

---

回过头来，我们是要解决：

> 从 $\alpha$ 中选出**任意个数**，匹配 $\beta$ 内的元素，使得费用和最小。比较常规的做法是，从左往右依次判断 $\alpha$ 内每个点咋连的。也就是设 $f(i)$ 表示考虑到前 $i$ 个点，连接后的最小费用。

由于 $\alpha$ 内每个点只能往周围最多 $2$ 格远连边的结论，我们只需要知道 $\beta$ 中第 $i-2,i-1,i+1,i+2$ 个点的占用情况，就可以进行状态压缩 $dp$ 了。这种做法复杂度是 $\mathcal O(n)$，但是**常数极大**（因为你至少要保存 $4$ 个状态，而转移会有 $5$ 个方程，这些常数加一块儿就 $2^4\cdot 5$ 了）。考虑进一步地观察优化做法。

考虑 $b_i$ 的贡献。换言之，依次考虑 $b_1,b_2,\cdots,b_m$ 对答案进行了多少次贡献。试证明，贡献次数忽略 $0$ 后，只会由**以下三种子段**组成：

- 第一类形如 $\{2,\underbrace{3,3\cdots 3}_{k\text{ 个}},2\}$，这样可以处理掉 $k+2$ 对匹配（特别地，$k$ 可以为 $0$，此时退化为 $\{2,2\}$）；
- 第二类形如 $\{1,\underbrace{2,2\cdots 2}_{k\text{ 个}},1\}$，这样可以处理掉 $k+1$ 对匹配（特别地，$k$ 可以为 $0$，此时退化为 $\{1,1\}$）。

怎么证明呢？考虑将匹配方案划分为这样一些连续的子图（意会一下吧）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ybfancdo.png)

每个子图满足如下性质：

- 子图内的 $\alpha$ 节点和 $\beta$ 节点一样多，且一一对应。
- 子图内每个绿色虚线线段都有线穿过。

如果一个子图内，存在 $\alpha_i$ 和 $\beta_i$ 的度均为 $0$，为了保证它是个子图，就必须出现 $\alpha_{i-1}\to\beta_{i+1},\alpha_{i+1}\to\beta_{i-1}$ 这两条边。那么将这两条边换成 $\alpha_{i-1}\to\beta_i,\alpha_{i}\to\beta_{i-1}$ 肯定更优。于是不会有 $\alpha_i$ 和 $\beta_i$ 的度均为 $0$。那么对于任意 $i$，如果 $i$ 在这个子图的最左侧或者最右侧，那么 $b_i$ 的贡献次数不会小于 $1$；如果 $i$ 不在最左侧或者最右侧，为了使得这个图是个子图，那么 $b_i$ 的贡献次数不会小于 $2$。

也就是说，对于一个子图，它里边 $b_i$ 的贡献不严格大于 $\{1,2,2,\cdots,2,1\}$（这是一个偏序的关系）。对于贡献序列 $\{1,2,2,\cdots,2,1\}$，为了尽可能多地增加选择的边，最优的连边肯定如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/5wyz2tk4.png)

这就是第一类可能的子段。

对于一个有 $2t$ 个点的子图，如果想要选出 $t$ 组边，只有可能是这四种情况：

- $t=1$：无解。
- $t=2$：仅有一种方案，$\alpha_1\to\beta_2,\alpha_2\to\beta_1$。
- $t=3$：仅有一种方案，$\alpha_1\to\beta_2,\alpha_2\to\beta_3,\alpha_3\to\beta_1$。
- $t>3$：不会优于拆成若干个 $t=2$ 的子图和 $t=3$ 的子图。

这就是第二类可能的子段。

于是设计 $f_i$ 表示，考虑 $b_{1\sim i}$，可以达到的尽量小的价值。$g_i$ 表示，$b_{1\sim i}$ 取到 $f_i$ 时最多可以有多少个边。

$f$ 的转移方程共有四部分，一个是直接从 $f_{i-1}$ 转移过来，一个是 $\{2,2\}$ 型，一个是 $\{2,3,2\}$ 型，另一个就是 $\{1,2,2,\cdots 2,1\}$ 型。对应的方程如下：

$$\begin{aligned}
f_i\stackrel{\min}{\gets}&f_{i-1} \\
f_i\stackrel{\min}{\gets}&f_{i-2}+2b_i+2b_{i-1}\\
f_i\stackrel{\min}{\gets}&f_{i-3}+2b_i+3b_{i-1}+2b_i\\
f_i\stackrel{\min}{\gets}&\min_j\{f_j+2(s_i-s_j)-b_i-b_{j+1}-w(i-j-1)\} \\
=&\min_j\{f_j-2s_j-b_{j+1}+wj\}-w(i-1)+2s_i
\end{aligned}$$

其中 $\stackrel{\min}{\gets}$ 表示与箭头右侧的数取最小值放到左边上来。$\min$ 里面那一坨可以用前缀最小值优化。另外记得精细处理 $g_i$。

那么这题就做完了。时间复杂度 $\mathcal O(n\log v)$，其中 $v$ 是值域。

---

## 作者：juju (赞：5)

一十六题解

考察 $a=1$ 的情况，可以发现这样的事实 —— 我们选取的 $B$ 一定是 $1,3,5$ 行相同，$2,4,6$ 行相同的形式。 而以上的结论其实对于 $a \not=1$ 的情况也是正确的，只是不那么显然。

证明简单因此略过。

抛弃 $a$，只处理两行的情况。

可以构造出这样的费用流模型：

$$
S \xrightarrow {0,t} S'
$$
$$
S' \xrightarrow {0,1} x_{i}
$$
$$
x_{i} \xrightarrow{S_{\max(i,j)-S_{\min(i,j)-1},1}} y_{j}(i\not = j)
$$
$$
y_{i} \xrightarrow{0,1} T
$$

其中 $S$ 表示 $b$ 的前缀和。

而事实上整个匹配只是由几个基本的形态拼接得到：

$[1,2]\to[2,1]$

$[1,2,3] \to [2,3,1] ([1,2,3]\to[3,1,2],\text{等价})$

$[*,1,2,3,4,5] \to [1,2,3,4,5,*]$

给出简略证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/ybfancdo.png)

（来自小波的图片，在此感谢。）

注意红框之间的部分，将这些没有被边跨越的间隔提取出来将原序列分割，这样就把序列分成了若干个块。（就是红框）

尝试手动枚举出所有可能情况的形态。

由于每个间隔都有边，可以发现仅有上述的三种情况是优的。

令 $dp_{i,j}$ 表示已经将前 $i$ 组点匹配 $j$ 组，且没有边跨越 $i$ 和 $i+1$ 的间隙，最小贡献。

于是得到简单的转移：

$$
dp_{i+1,j} \leftarrow dp_{i,j}
$$

$$
dp_{i+2,j+2} \leftarrow dp_{i,j}+2(b_i+b_{i+1})
$$

$$
dp_{i+3,j+3} \leftarrow dp_{i,j}+2b_i+3b_{i+1}+2b_{i+2}
$$

$$
dp_{i+k,j+k-1} \leftarrow dp_{i,j}+b_i+2(S_{i+k-1}-S_i)+b_{i+k}
$$

则可以做到 $O(nt)$。

而凸性由前述的费用流不难得到，施以 wqs 二分即可在 $O(n\log v)$ 的时间内解决此问题。

解决此题需要一定的观察素养，发现 $B$ 具有周期性的关键性质，对匹配相关结论的熟知 / 大胆猜测结论，以及利用凸性解决 dp 问题的敏感。题出的好！！1



---

## 作者：forest114514 (赞：4)

### P8544 「Wdoi-2」禁断之门对面，是此世还是彼世

早就听说这道厉害的题了，今天来思考一下，然后怎么想成最大值了啊，难绷。不过几乎独立想出来真是酣畅淋漓啊 ~~（虽然一开始就知道是 wqs 优化 DP 了）~~，所以本题解主要是侧重于如何一步步剖析性质得到答案的。

首先 $f(B)$ 的式子可以拆开，变成这个样子（计 $s$ 为 $b$ 的前缀和 ~~，本来想取另一个名字但是过于文明了~~）：
$$
\sum\limits_{i=1}^{n}a_{i}\sum\limits_{j=1}^{t}s_{\max (B_{i,j},B_{i+1,j})}-s_{\min(B_{i,j},B_{i+1,j})-1}
$$
考虑 $n=1$，因为 $B_{i,j}\neq B_{i+1,j}$，而且 $B_{i},B_{i+1}$ 都是一个排列，可以转化为一个类似 $t$ 匹配的问题，然后 $i\neq j$ 之间连费用 $s_{\max (i,j)}-s_{\min(i,j)-1}$ 的边，相当于求流量为 $t$ 的最小费用流。

然后 $n>1$ 你发现 $B_{i}$ 分奇偶性构造两种排列然后对于所有 $i$，$\sum\limits_{j=1}^{t}s_{\max (B_{i,j},B_{i+1,j})}-s_{\min(B_{i,j},B_{i+1,j})-1}$ 都能取到最小值了，所以只用考虑一组的情况（而且特殊性质 A 提醒你只想一组的是不是）。

然后考虑这里匹配的点其实构成了若干覆盖的区间，这时可以考虑一种常规的 DP 思路：对还没结束的匹配区间作为状态，每个点就是枚举前后匹配或不用，这里我们认为左部点为 $A$ 集合的点，右部点为 $B$ 集合点，但是你发现要记录多少个 $A,B$ 集合的点要向后匹配，这样状态太大了，不能过，考虑观察性质。

**Lemma 1**：对于 $A_i<B_j<B_k<A_l$，不会有 $A_i$ 匹配 $B_k$ 和 $B_j$ 匹配 $A_l$ 同时存在；同理 $B_i<A_j<A_k<B_l$ 类似，不会有 $B_i$ 匹配 $A_k$ 和 $A_j$ 匹配 $B_l$ 同时存在。对于 $A_i<B_j<A_k<B_l$ 和 $B_i<A_j<B_k<A_l$ 也有有类似的不相交性质。

证明：显然考虑交换匹配的点后发现答案更小了。

**Lemma 2**：存在相交的匹配当且仅当两个匹配形如 $A_i\to B_j,B_i\to A_k$ 或 $A_j\to B_i,B_k\to A_i$，即相交的点在左右端点。

证明：由 Lemma 1 可以归纳出只有这种相交法了，不在端点相交都可以交换端点保证更优，端点相交交换会存在 $A_i\to B_i$  的不合法情况。

然后呢？你发现没有显著的优化做法，~~所以做不出来就打部分分然后润之~~，考虑特殊性质 B，然后发现在完美匹配的时候只有两种本质不同子图（蓝色反过来等价的）：

![本质不同子图](https://cdn.luogu.com.cn/upload/image_hosting/xpggwnbw.png)

所以完美匹配直接 DP 就好了，不一定是完美匹配的时候会不会有其他的匹配方式呢？

首先存在相交的子图显然有且仅有上面两种，然后发现一个匹配过远的点因为相交的图会导致很多有本来可以选的匹配不能选，不如直接匹配前面的一个不同集合的点，所以所有不存在相交的边的图都是一段下图的形式（反过来等价）：

![不相交子图](https://cdn.luogu.com.cn/upload/image_hosting/6s1locg3.png)

哎你发现这是一段无后效性的东西诶！也可以 DP 了，然后式子是简单的，就能做到 $O(mt)$ 了。

然后你发现恰好 $t$ 这个限制过于魔怔了，这里你又注意到了匹配这个流问题有答案凸性，自然想到 wqs 二分（而不是根据分 $k$ 段直接想 wqs 而抛弃凸性的分析并且简化思考，非常好！膜拜出题人！），注意 DP 有细微的变化。

设 $f_{i}$ 表示考虑完前 $i$ 个数后任意匹配的最小值，顺便记录选择的最大段数方便 wqs 二分，转移有（$C$ 表示切线的斜率）：

1. 什么都不选：$f_{i}\leftarrow f_{i-1}$；
2. 加一个红色的子图：$f_{i}\leftarrow f_{i-2}+2s_{i}-2s_{i-2}+2C=f_{i-2}+2(b_{i}+b_{i-1}+C)$；
3. 加一个蓝色的子图：$f_{i}\leftarrow f_{i-3}+2s_i+s_{i-1}-s_{i-2}-2s_{i-3}+3C=f_{i-3}+2b_i+3b_{i-1}+2b_{i-2}+3C$
4. 加一段绿色的子图：$f_{i}\leftarrow f_{j}+s_{i}+s_{i-1}-s_{j}-s_{j+1}+(i-j-1)C=f_{j}+2(s_i-s_j)-(b_i+b_{j+1})+(i-j-1)C$

前三个转移是容易的，第四个直接记录前缀最小值转移也是容易的，只用注意 $j<i-1$ 导致的加决策点细节，外层套个 wqs 二分就行了，时间复杂度 $O(n\log V)$。

code：

```cpp
const int N=5e5+100,mod=1e9+7;
int n,m,k,a[N],b[N];
LL s[N],sa;
struct NODE{
	LL val;int ch;
	NODE(LL v=INF,int c=0){val=v,ch=c;} 
	bool operator <(const NODE &T)const{
		return val==T.val?ch>T.ch:val<T.val;
	}
}f[N];
int check(LL mid){
	f[0]=NODE(0,0);
	rep(i,1,m) f[i]=NODE();
	NODE pre=NODE();int pos=-1;
	rep(i,1,m){
		f[i]=f[i-1];
		if(i>1) f[i]=min(f[i],NODE(f[i-2].val+2ll*(b[i]+b[i-1]+mid),f[i-2].ch+2));
		if(i>2) f[i]=min(f[i],NODE(f[i-3].val+2ll*(b[i]+b[i-2])+3ll*(b[i-1]+mid),f[i-3].ch+3));
		if(pos!=-1)f[i]=min(f[i],NODE(pre.val+2ll*s[i]-b[i]+1ll*(i-1)*mid,pre.ch+i-pos));
		if(i<m){
			NODE nxt=NODE(f[i-1].val-2ll*s[i-1]-b[i]-1ll*(i-1)*mid,f[i-1].ch);
			if(nxt<pre) pre=nxt,pos=i-1;
		}
	}
	return f[m].ch;
}
signed main(){
	read(n,m,k);
	rep(i,1,n) read(a[i]),sa+=a[i];sa%=mod;
	rep(i,1,m) read(b[i]),s[i]=s[i-1]+b[i];
	LL l=-5e9,r=0,ans=0;
	while(l<=r){
		LL mid=l+r>>1;
		if(check(mid)>=k) ans=mid,l=mid+1;
		else r=mid-1;
	}
	check(ans);
	write(1ll*(f[m].val-ans*k)%mod*sa%mod,'\n');
	return 0;
}
```

---

## 作者：Arghariza (赞：4)

<https://www.cnblogs.com/Ender32k/p/17713788.html>

#### Part 1. 转换

由于 $A_{i,j}=a_ib_j$，这个 $f(B)$ 显然可以化简：

$$\begin{aligned}f(B)&=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^t\sum\limits_{k=\min(B_{i,j},B_{i+1,j})}^{\max(B_{i,j},B_{i+1,j})}A_{i,k}\\&=\sum\limits_{i=1}^n\sum\limits_{j=1}^t\sum\limits_{k=\min(B_{i,j},B_{i+1,j})}^{\max(B_{i,j},B_{i+1,j})}a_ib_k\\&=\sum\limits_{i=1}^na_i\sum\limits_{j=1}^tS_{\max(B_{i,j},B_{i+1,j})}-S_{\min(B_{i,j},B_{i+1,j})-1}\end{aligned}$$

$S_i$ 为 $b$ 数组的前缀和。

发现若得到 $g(B_1,B_2)=\sum\limits_{j=1}^tS_{\max(B_{1,j},B_{2,j})}-S_{\min(B_{1,j},B_{2,j})-1}$ 的最小值，我们可以令 $B_{2k+1}=B_1,B_{2k+2}=B_2$。这样显然最优。也就是说，$f(B)=\left(\sum\limits_{i=1}^na_i\right)\cdot \min g(B_1,B_2)$。

问题转换为找到一个 $B_1,B_2$，分别满足每个元素两两不同，都在 $[1,m]$ 之间，并且对应的位置上的元素不同，使得 $g(B_1,B_2)$ 最小。

由于同一行元素两两不同以及值域的限制，考虑转换成匹配问题。相当于现在有两列数（分为左部和右部），分别为 $1,2,\cdots ,m$，在左部中选择 $t$ 个数，并和右部的 $t$ 个数匹配。满足不存在形如 $(i,i)$ 的匹配，一对匹配 $(i,j)$ 的价值就是 $S_{\max(i,j)}-S_{\min(i,j)-1}$，也就是 $b_{\min(i,j)}+b_{\min(i,j)+1}+\cdots+b_{\max(i,j)}$。一组匹配的价值就是每对匹配的价值之和，求**钦定有 $t$ 对匹配的最小匹配**。

#### Part 2. 猜想

有个比较感性的想法，就是**一对匹配不应该跨过太大的距离**。考虑从左到右按顺序匹配，如果匹配跨过了一段空区间，那么不如不跨过这段区间，因为这样减小了代价的同时也给后面的点更多的选择方案。

另一个比较感性的想法，**匹配应该尽可能不交叉**。这里借用[这篇题解](https://www.luogu.com.cn/blog/McHf/solution-Wdoi2-1E)的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/j58zojf0.png)

如上图，匹配 $(2,5)(4,3)$ 显然不如匹配 $(2,3),(4,5)$。即如果存在交叉的匹配，我们尝试交换匹配以减少价值。而且可以发现减少交叉必定不劣。

手玩一些数据之后，我们发现最优解中，$i$ 只能形成 $(i,j)(j\in \{i-2,i-1,i+1,i+2\})$ 的匹配。我们下面试图证明这个结论。

#### Part 3. 证明

$i$ 显然可以和 $i-1,i+1$ 匹配，即证最优解中合法匹配 $(i,j)$ 满足 $j-i\le 2$。下面**从左到右**考虑一组匹配 $(i,j)(j>i+2)$ 如何调整（小于 $i$ 的左部点的匹配均满足猜想），$j<i-2$ 根据对称性同理：

- 若 $\exists k\in \{1,2\}$，不存在匹配 $(?,i+k)$（即右部的 $i+k$ 没有被匹配），显然将 $(i,j)$ 调整为 $(i,i+k)$ 更优。
- 否则存在 $(x,i+1),(y,i+2)$ 的匹配，且我们从左到右调整，显然有 $x,y>i$ 且 $x\neq y$。注意到匹配 $(i,j)$ 和 $(x,i+1),(y,i+2)$ 都有上述的**交叉**，所以我们试图交换两个匹配的右部点以减少交叉：若 $x=j$，则 $y\neq j$，将原匹配 $(i,j)(y,i+2)$ 重组为 $(i,i+2)(y,j)$ 即可；若 $x\neq j$，将原匹配 $(i,j)(x,i+1)$ 重组为 $(i,i+1)(x,j)$ 即可。

这样我们就能够将任意的合法匹配调整为更优的、满足 $i$ 只能形成 $(i,j)(j\in \{i-2,i-1,i+1,i+2\})$ 的匹配的方案。

最终只剩下三种结构：连续的三元环，例如 $(i,i+1)(i+1,i+2)(i+2,i)$ ；连续的二元环，例如 $(i,i+1)(i+1,i)$；连续的一条链，例如 $(i,i+1)(i+1,i+2)(i+2,i+3)\cdots (i+k,i+k+1)$。前两种情况有交叉，但是无法调整；并且能够发现，只有前两种情况无法调整。

#### Part 4. 你会了

然后就能考虑 dp 了：令 $f_{i,j,0/1}$ 表示目前考虑到 $i$ 的匹配 $(i,?)$，前 $i$ 个点一共有 $j$ 对匹配，目前是否在一条形如 $(u,u+1)(u+1,u+2)\cdots(i-1,i)$ 的链中。

- $f_{i,j,1}\gets f_{i-1,j-1,1}+b_{i}+b_{i-1}$，表示延续一条链，增加一对匹配，连接 $(i-1,i)$。
- $f_{i,j,1}\gets f_{i-2,j-1,0}+b_i+b_{i-1}$，表示新建一条链，增加一对匹配，连接 $(i-1,i)$。
- $f_{i,j,0}\gets f_{i-2,j-2,0}+2(b_i+b_{i-1})$，表示新增一个二元环，增加两对匹配，连接 $(i-1,i)(i,i-1)$。
- $f_{i,j,0}\gets f_{i-3,j-3,0}+2b_i+3b_{i-1}+2b_{i-2}$，表示新增一个三元环，增加三对匹配，连接 $(i-2,i-1)(i-1,i)(i,i-2)$ 或者 $(i,i-1)(i-1,i-2),(i-2,i)$。
- $f_{i,j,0}\gets f_{i-1,j,0}$，表示 $i$ 没有匹配任何点。
- $f_{i,j,0}\gets f_{i,j,1}$，表示我摆烂了，不延续一条链。

乍一看是 $O(mt)$ 的？的确是 $O(mt)$ 的。

考虑瓶颈在于强制选择 $t$ 对匹配，对于这类问题，我们可以通过证明答案随匹配数的变化具有凸性，而进行 wqs 二分。

这题的凸性十分显然，因为是匹配问题，可以转化成费用流模型：

- 有超源 $S'$ 和超汇 $T'$，源点 $S$ 和汇点 $T$，$S'\to S$ 连流量 $t$，费用 $0$ 的边（以下 $u\to v$ 连流量 $f$ 费用 $w$ 的边简记为 $u\to v(f,w)$）。即 $S'\to S(t,0),T\to T'(t,0)$。
- 记 $i$ 的左部点为 $l_i$，右部点为 $r_i$，$S\to l_i(1,0),r_i\to T(1,0)$。
- 对于 $i\neq j$，$l_i\to r_i(1,S_{\max(i,j)}-S_{\min(i,j)-1})$。

不难发现最小费用最大流就是答案。根据费用流函数的凸性，原问题具有凸性，可以 wqs 二分。具体地，二分斜率 $k$，新建一对匹配时，直接减去 $k$ 的代价即可。

最终复杂度 $O(n\log V)$。代码好写得很。

```cpp
// Problem: P8544 「Wdoi-2」禁断之门对面，是此世还是彼世
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8544
// Memory Limit: 512 MB
// Time Limit: 2500 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define int long long
using namespace std;

namespace vbzIO {
    char ibuf[(1 << 20) + 1], *iS, *iT;
    #if ONLINE_JUDGE
    #define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
    #else
    #define gh() getchar()
    #endif
    #define mt make_tuple
    #define mp make_pair
    #define fi first
    #define se second
    #define pc putchar
    #define pb emplace_back
    #define ins insert
    #define era erase
    typedef tuple<int, int, int> tu3;
    typedef pair<int, int> pi;
    inline int rd() {
        char ch = gh();
        int x = 0;
        bool t = 0;
        while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
        while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
        return t ? ~(x - 1) : x;
    }
    inline void wr(int x) {
        if (x < 0) x = ~(x - 1), putchar('-');
        if (x > 9) wr(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace vbzIO;

const int N = 5e5 + 100;
const int P = 1e9 + 7;
const int inf = 1e12;

int n, m, t, sum, b[N];
pi f[N][2];

pi operator + (const pi &lh, const pi &rh) {
    return mp(lh.fi + rh.fi, lh.se + rh.se);
}

pi chk(int w) {
    for (int i = 0; i <= m; i++)
        f[i][0] = f[i][1] = mp(inf, 0);
    f[0][0] = mp(0, 0);
    for (int i = 1; i <= m; i++) {
        f[i][1] = min(f[i][1], f[i - 1][1] + mp(b[i] + b[i - 1] - w, 1));
        if (i >= 2) f[i][1] = min(f[i][1], f[i - 2][0] + mp(b[i] + b[i - 1] - w, 1));
        if (i >= 2) f[i][0] = min(f[i][0], f[i - 2][0] + mp(2 * (b[i] + b[i - 1] - w), 2));
        if (i >= 3) f[i][0] = min(f[i][0], f[i - 3][0] + mp(2 * b[i] + 2 * b[i - 2] + 3 * b[i - 1] - 3 * w, 3));
        f[i][0] = min(min(f[i][0], f[i - 1][0]), f[i][1]);
    }
    return f[m][0];
}

signed main() {
    n = rd(), m = rd(), t = rd();
    for (int i = 1; i <= n; i++) 
        (sum += rd()) %= P;
    for (int i = 1; i <= m; i++) b[i] = rd();
    int l = 0, r = 3e9, res = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (chk(mid).se <= t) res = mid, l = mid + 1;
        else r = mid - 1;
    }
    wr(((chk(res).fi % P + res * t % P) % P + P) * sum % P);
    return 0;
}
```

---

## 作者：251Sec (赞：3)

首先看到题就想到一个费用流建模，看起来没啥优化空间，不管它。然后观察样例发现答案是 $\sum a$ 的倍数，很难不猜测最后答案每一列都是两个数来回横跳。于是 $a$ 根本就没用，问题变成了：给定一个序列，选恰好 $t$ 条线段使得每个点是不超过 $2$ 条线段的端点，最小化线段覆盖点的权值和，注意线段的左右端点不能相等。容易得到 DP $f(i,j,k)$ 代表前 $i$ 个元素，有 $j$ 条线段从该位置往下延伸，目前已经有 $k$ 条线段结束。$j$ 只需要保留到 $2$，所以是 $O(n^2)$。然后我们想起来一开始有个费用流建模，所以答案关于 $t$ 是凸的，WQS 二分即可，$O(n \log V)$。

代码非常简短。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 1e9 + 7;
int m, n, t;
ll a[500005], b[500005], ans;
ll f[500005][3];
ll Calc(ll C) {
	memset(f, 0x3f, sizeof(f));
	f[0][0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int x = 0; x <= 2; x++) {
			for (int y = 0; x + y <= 2; y++) {
				for (int j = x; j <= 2; j++) {
					if (j + y - x <= 2) f[i][j] = min(f[i][j], f[i - 1][j + y - x] + (j + y) * a[i] + y * C);
				}
			}
		}
	}
	return f[n][0];
}
int main() {
	scanf("%d%d%d", &m, &n, &t);
	for (int i = 1; i <= m; i++) scanf("%lld", b + i);
	for (int i = 1; i <= n; i++) scanf("%lld", a + i);
	ll l = -1e12, r = 1e12;
	while (l + 1 < r) {
		ll m1 = (l + r) / 2, m2 = m1 + 1;
		ll w1 = Calc(m1) - m1 * t, w2 = Calc(m2) - m2 * t;
		if (w1 > w2) r = m2 - 1;
		else l = m1 + 1;
	}
	ans = max(Calc(l) - l * t, Calc(r) - r * t);
	ans = ans % P * (accumulate(b + 1, b + m + 1, 0ll) % P) % P;
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：_lbw_ (赞：1)

观察题目，你发现你连 5 分都不会？？？

但是我们先冷静一下，我们发现这题实际上等价于有 $t$ 个人，每个人往下一直走，路径不能重复，往下的时候必须横着移动，移动有一个代价，求最小代价。

这很显然可以流，于是你得到了 5 分（甚至过不去 $n,m,q\leq 200$）。

你想，这也太难了吧，于是可以把贡献拆分一下或许可以过 10 分。

你感觉你被诈骗了，观察样例，发现 Ans 是 $\sum a$ 的倍数？？？？

这下这下了，只需要考虑一层就可以了，感性理解发现确实如此。

再仔细思考，这个必须移动的条件很不自然，应该有很多的数都是来回走的。

于是我们猜测每个数只会来回走，但是这是错的，因为 $t=m=3$ 时这样甚至无解。

于是我们考虑加上 $1\to 2,2\to 3,3\to 1$ 这样会让 $2$ 被多算一次，DP 之，然后就拍过了。

DP 状态有两维，第二维是背包，于是直接上 wqs 二分，就做完了。

```cpp
#define ll long long
#define I ll
#define her1 20081214
#define IV void
#define cht 1000000007
#define mem(x,val)memset(x,val,sizeof x)
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define DL(i,j,n)for(register i64 i=j;i>=n;i--)
#define FL(i,j,n)for(register i64 i=j;i<=n;i++)
#undef ll
#include "assert.h"
mt19937_64 rnd(her1);
#include "functional"
using i64 = __int128;
const int maxn = 5e5+5;
IV cmin(i64&x,i64 val){x>val?x=val,0:0;}
i64 n,m,t,a[maxn],b[maxn],sum;
#define pii pair<i64,i64>
pair<i64,i64>dp[maxn][3];
IV cmin(pii&x,pii val){x>val?x=val,0:0;}
pii check(i64 V){
	F(i,1,m)F(p,0,2)dp[i][p]={(i64)1e18,0};
	dp[1][0]={0,0};
	F(i,1,m-1){
		F(p,0,2)F(q,0,2-p){
			auto[w,c]=dp[i][p];
			cmin(dp[i+1][q],pii{w+q*(b[i]+b[i+1])-q*V,c+q});
		}
		auto[w,c]=dp[i][0];
		cmin(dp[i+2][2],pii{w+b[i]*2+b[i+1]*3+b[i+2]*2-3*V,c+3});
	}
	return min({dp[m][0],dp[m][1],dp[m][2]});
}
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();m=read();t=read();
	F(i,1,n)a[i]=read(),sum+=a[i];sum%=cht;
	F(i,1,m)b[i]=read();

	i64 r=1e13;
	DL(i,60,0)if(r>=(1ll<<i)&&check(r-(1ll<<i)).second>=t)
		r-=(1ll<<i);
	
	auto[w,c]=check(r-1);
	i64 Ans=w+t*(r-1);
	return cout<<(long long)(Ans%cht*sum%cht),0;
}
```

---

## 作者：Mine_King (赞：1)

相当于有 $t$ 个点在数轴上 $m$ 个位置上走，要走 $n$ 次，在 $i$ 时刻走过第 $j$ 个点会产生 $a _ i \times b _ j$ 的代价。

首先考虑同时满足性质 A 和 B 的情况，发现当 $m$ 为偶数时是相邻两个来回走，即每次 $2 i - 1$ 走到 $2 i$，$2 i$ 走到 $2 i - 1$。当 $m$ 为奇数时则会出现一个三元环。

然后猜想当不满足 $a _ i = 1$ 时也是每个点都在两个点之间来回走，发现确实是这样，因为考虑单独一轮时求出来的就是最优解，然后来回走可以保证每次走的都是最优解。

对于每个点从起点向终点连一条边，变成 $n$ 个点连 $m$ 跳边形成若干个环或链。  
这个可以费用流解决，将点拆成两个，源点向入点连边，出点向汇点连边，入点向出点连代价为从入点走到出点的代价的边。

尝试模拟费用流发现不是很能做，考虑寻找一些性质。

可以发现对于一个大小超过 $3$ 的环，可以把前两个点单独扣出来组成一个二元环，剩下的不变，答案不会变劣，因此环的大小至多为 $3$。  
更进一步地，容易发现一个环或一条链上的点一定是连续的。  
现在答案里只会出现相邻两个点组成的二元环，相邻三个点组成的三元环和一段连续的点组成的链。以下用 $2 - 2, 2 - 3 - 2, 1 - 2 - 2 - 1$ 来表示这三种情况（对应图形中每个点产生的代价的系数）。

设 $dp _ {i, j, 0 / 1 / 2}$ 表示前 $i$ 个点连了 $j$ 条边，第 $i$ 个点连了 $0$ 或 $1$ 或 $2$ 条边时的答案，容易得到一个 $O(n ^ 2)$ 的 DP。

由于是费用流问题，因此答案关于流量也就是边的条数是凸的，可以用 wqs 二分优化，时间复杂度 $O(n \log n)$。

实际上，可以证明除了边数为 $1$ 的情况外，凸包上的点不会有 $1 - 2 - 2 -1$。  
证明就考虑如果有奇数个 $2$，如 $1 - 2 - 2 - 2 - 1$，则形成偶数条边，可以调整成若干个二元环（$2 - 2 - 2 - 2 - 0$ 或 $0 - 2 - 2 - 2 - 2$），一定有一种调整方法使答案不劣。  
而如果有偶数个 $2$，如 $1 - 2 - 2 - 1$，考虑 $1 - 2 - 2 - 1$ 第一次出现（只需保证在边数 $- 1$ 的情况下没有 $1 - 2 - 2 - 1$），则边数少一条的方案是 $0 - 2 - 2 - 0$，多一条的方案是 $2 - 2 - 2 - 2$，也就是这三个点在同一条直线上，那这个点就不在凸包上。

```cpp
// Think twice, code once.
#include <set>
#include <queue>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#define eputchar(c) putc(c, stderr)
#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define eputs(str) fputs(str, stderr), putc('\n', stderr)
using namespace std;

const int mod = 1e9 + 7;

int T, n, m, num[500005];
long long sum, a[500005], b[500005], dp[500005];

pair<long long, int> check(long long limit) {
	memset(dp, 0x3f, sizeof(dp));
	dp[0] = dp[1] = 0;
	num[0] = num[1] = 0;
	for (int i = 2; i <= n; i++) {
		dp[i] = dp[i - 1], num[i] = num[i - 1];
		long long cost = 2 * (b[i] + b[i - 1]) - 2 * limit;
		if (dp[i - 2] + cost < dp[i] || (dp[i - 2] + cost == dp[i] && num[i - 2] + 2 > num[i]))
			dp[i] = dp[i - 2] + cost, num[i] = num[i - 2] + 2;
		if (i > 2) {
			cost = 2 * (b[i] + b[i - 1] + b[i - 2]) + b[i - 1] - 3 * limit;
			if (dp[i - 3] + cost < dp[i] || (dp[i - 3] + cost  == dp[i] && num[i - 3] + 3 > num[i]))
				dp[i] = dp[i - 3] + cost, num[i] = num[i - 3] + 3;
		}
	}
	return make_pair(dp[n], num[n]);
}

int main() {
	scanf("%d%d%d", &T, &n, &m);
	for (int i = 1; i <= T; i++) scanf("%lld", &a[i]), sum += a[i];
	sum %= mod;
	for (int i = 1; i <= n; i++) scanf("%lld", &b[i]);
	long long l = 0, r = 3e9;
	while (l < r) {
		long long mid = (l + r) >> 1;
		if (check(mid).second >= m) r = mid;
		else l = mid + 1;
	}
	long long ans = check(r).first + m * r;
	ans = ans % mod * sum % mod;
	printf("%lld\n", ans);
	return 0;
}
```

---


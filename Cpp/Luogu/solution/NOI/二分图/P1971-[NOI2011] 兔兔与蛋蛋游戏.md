# [NOI2011] 兔兔与蛋蛋游戏

## 题目描述

这些天，兔兔和蛋蛋喜欢上了一种新的棋类游戏。

这个游戏是在一个 $n$ 行 $m$ 列的棋盘上进行的。游戏开始之前，棋盘上有一个格子是空的，其它的格子中都放置了一枚棋子，棋子或者是黑色，或者是白色。

每一局游戏总是兔兔先操作，之后双方轮流操作，具体操作为：

* 兔兔每次操作时，选择一枚与空格相邻的白色棋子，将它移进空格。
* 蛋蛋每次操作时，选择一枚与空格相邻的黑色棋子，将它移进空格。

第一个不能按照规则操作的人输掉游戏。为了描述方便，下面将操作“将第x行第y列中的棋子移进空格中”记为 $M(x,y)$。

例如下面是三个游戏的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/6wfmhuf2.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/j7vox6n7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/er1t5wpb.png)

最近兔兔总是输掉游戏，而且蛋蛋格外嚣张，于是兔兔想请她的好朋友——你——来帮助她。她带来了一局输给蛋蛋的游戏的实录，请你指出这一局游戏中所有她“犯错误”的地方。

注意：

* 两个格子相邻当且仅当它们有一条公共边。
* 兔兔的操作是“犯错误”的，当且仅当，在这次操作前兔兔有必胜策略，而这次操作后蛋蛋有必胜策略。


## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 40$，$1 \leq m\leq 40$，$1\leq k\leq 1000$。


::cute-table{tuack}

|测试点编号|$n$|$m$|
|:-:|:-:|:-:|
|$1,2$|$n=1$|$1\leq m\leq 20$|
|$3$|$n=3$|$m=4$|
|$4,5$|$n=4$|$m=4$|
|$6,7$|$n=4$|$m=5$|
|$8$|$n=3$|$m=7$|
|$9\sim 14$|$n=2$|$1\leq m\leq 40$|
|$15,16$|$1\leq n\leq 16$|$1\leq m\leq 16$|
|$17\sim 20$|$1\leq n\leq 40$|$1\leq m\leq 40$|


## 样例 #1

### 输入

```
1 6 
XO.OXO 
1 
1 2 
1 1 ```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3 3 
XOX 
O.O 
XOX 
4 
2 3 
1 3 
1 2 
1 1 
2 1 
3 1 
3 2 
3 3 ```

### 输出

```
0```

## 样例 #3

### 输入

```
4 4 
OOXX 
OXXO 
OO.O 
XXXO 
2 
3 2 
2 2 
1 2 
1 3 ```

### 输出

```
2
1
2```

# 题解

## 作者：apple365 (赞：147)

# [1971兔兔与蛋蛋](https://www.luogu.com.cn/problem/P1971)
# 二分图博弈论
### author: LiveDream 
#### 前置知识:
1. 对于二分图博弈，先手如果率先落入最大匹配的点x中，那么后手只需要选择与x匹配的点y走即可，走到最后先手必败； 
2. 如果是完全匹配，那么先手无论落子何处，均率先落入最大匹配点，先手必败；
3. 如果不是完全匹配，先手选择非最大匹配点x落子，那么后手无论落子何处，都是最大匹配中的某点y，
	因为如果y不是最大匹配的点, 则x到y形成增广路，最大匹配的边数还可以加1，导致矛盾；进而，
	后手率先落入最大匹配的点中，先手有必胜策略；
    
#### 本题策略： 
1. 把棋子的移动视为空格的移动，那么兔兔先手移动空格到白子处，因此可以将空格看作黑色， 黑白染色，建二分图；
2. 如果在移动空格前，空格处于最大匹配的非必须点，那么移动后必然率先进入最大匹配中，必败，反之有必胜策略；
3. 对于K轮游戏，第i轮游戏时空格的位置cur在(sx, sy), 如果cur不在最大匹配中，那么落子后必落入最大匹配，
所以无论怎么落子，必败；
4. 如果cur在最大匹配中,且有匹配match[cur]为nxt，那么删掉cur后从nxt跑匈牙利，看nxt是否还能有另外的匹配，如果有
那么cur就不是最大匹配的必须点，有必胜策略，反之仍然必败；对每1轮游戏重复操作，得到每1轮游戏的胜负情况win[i]； 
5. 如何判断兔兔犯了错误？——如果win[i]是必胜，而兔兔走完之后win[i+1]必胜，那么就说明兔兔犯了错； 

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N = 50, K = 1005;
int n, m, ans, cnt, tot, head[N*N];
char g[N][N];
int match[N*N], res[K*2], win[K*2]; 
bool vis[N*N], block[N*N], color[N][N];
int dx[4] = {1, 0, 0, -1};
int dy[4] = {0, 1, -1, 0};
struct node 
{
    int to, nxt;
}edge[N*N*2*4]; //每个点连4个方向，双向边 

void addedge(int s, int e) 
{
    cnt++;
    edge[cnt].to = e;
    edge[cnt].nxt = head[s];
    head[s] = cnt;
    return ;
}

bool dfs(int x) //匈牙利算法
{
    for(int i = head[x]; i != 0; i = edge[i].nxt) 
	{
        int y = edge[i].to;
        if(block[y] == true) //添加一行屏蔽已删掉的点 
        	continue;
        if(vis[y] == false) 
		{
            vis[y] = true;
			//如果y没有匹配 或者 y的匹配点match[y]能找到一个新的匹配
            if(match[y] == 0 || dfs(match[y]) == true) 
			{
                match[y] = x; //y的配对点是x
                match[x] = y; //增加这行代码的原因是为了找最大匹配非必须点
                return true;
            }
        }
    }
    return false;
}

int get_id(int x, int y)
{
	return (x-1) * m + y;
} 

bool check(int x, int y)
{
	if(x < 1 || x > n || y < 1 || y > m || color[x][y] == false)
		return false;
	return true;	
}

int main()
{
	//输入 
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
			cin >> g[i][j]; //迷宫数组 
	//染色
	int sx, sy;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
        	if(g[i][j] == 'O') //将白色的棋子染色 
        	{
        		color[i][j] = true;
        	}
        	else if(g[i][j] == '.') //起点记录，当作黑色对待 
        	{
        		sx = i;
        		sy = j;
			}
		}
    //建图 
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
        	if(color[i][j] == true) //白子跳过 
        		continue;
        	int cur = get_id(i, j); //当前点编号 
        	for(int k = 0; k < 4; k++)
        	{
        		int nx = i + dx[k];
        		int ny = j + dy[k];
        		if(check(nx, ny) == false)
        			continue;
        		int nxt = get_id(nx, ny);
        		addedge(cur, nxt); //建边 
        		addedge(nxt, cur); //找最大匹配不需要反边，但是找最大匹配非必须点需要折返跑 
			}
		}
	//匈牙利, 目的是看起点是否落在最大匹配中 
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
        	if(color[i][j] == false)
        		continue;
        	memset(vis, 0, sizeof(vis));
        	int cur = get_id(i, j); 
        	if(dfs(cur) == true) 
				ans++;
		}
	//输入游戏过程 
	int k; 
	cin >> k;
	for(int i = 1; i <= 2*k; i++)
	{
		int cur = get_id(sx, sy);
		block[cur] = true; //删掉cur 
		if(match[cur] == 0) //棋子当前不在匹配中，那么下一步会率先走到最大匹配中，必败 
			win[i] = false;
		else
		{
			int nxt =  match[cur];
			match[cur] = match[nxt] = 0;  //删掉cur与 nxt的匹配关系 
			memset(vis, 0, sizeof(vis)); //跑匈牙利记得清0 vis 
			if(dfs(nxt) == true) //若nxt还能找到匹配，则cur不是最大匹配必须, 那么下一步率先走到最大匹配，必败 
				win[i] = false;
			else
				win[i] = true; 
		}
		cin >> sx >> sy;
	}
	
	//处理输出 
    for(int i = 1; i <= k; i++) 
    {
    	if(win[2*i-1] == true && win[2*i] == true) //兔兔走之前是有必胜策略，走完蛋蛋有必胜策略 
    	{
    		res[++tot] = i; 
		}
	}
	cout << tot << endl;
	for(int i = 1; i <= tot; i++)
	{
		cout << res[i] << endl;
	}
    return 0;
}

```


---

## 作者：tyler178 (赞：27)

先审清楚题意。A 一步走错的判定：A 走这步之前，A先手采用最优策略必胜；A 走这步之后，B先手采用最优策略必胜。

可以直接用最基础的博弈论展开爆搜，判断是否必胜。本题非常良心，这就有75分。

先随便模拟几局游戏，可以发现，游戏的过程中不可能出现环，即空格的移动一定是不重复地经过一些位置，而这些位置原本的颜色依次白黑相间。

这让我们很容易联想到二分图的增广路：设起点和黑子为左边，白子为右边，那么 A 的移动可以看作是左边连向右边的一条边，而 B 的移动可以看作是从 A 刚刚到达的点连回左边的的一条边，且每条边的目标点都不能是已经到达过的点。这显然就是二分图增广路的样子。

如果 A 当前的局面必胜，说明这条增广路是增广成功的，即有奇数条边。因此判断局面是否必胜转化为判断当前点是否一定在二分图的最大匹配中。

判断的过程：强制当前点不选，如果它的匹配点仍然能找到新的匹配点，说明有一种最大匹配不包含它，自然它就不是 一定 在最大匹配中。


```
#include <bits/stdc++.h>
#define mset(a, b) memset(a, b, sizeof(a))
using namespace std;
typedef long long LL;
const int N = 50;
const int MAXN = N*N;
const int M = 1005;

template <typename T> inline void read(T &AKNOI)
{
	T x=0, flag=1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-') flag = -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x<<1) + (x<<3) + ch - '0';
		ch = getchar();
	}
	AKNOI = flag * x;
}

int nx[4] = {0, 1, 0, -1};
int ny[4] = {1, 0, -1, 0};

struct Edge
{
	int v, nxt;
}e[MAXN*8];
int first[MAXN], eCnt;

inline void AddEdge(int u, int v)
{
	e[++eCnt].v = v;
	e[eCnt].nxt = first[u];
	first[u] = eCnt;
}

char s[N];
int n, m, q, mp[N][N], bx, by, id[N][N], ID;
int match[MAXN], ban[MAXN], vis[MAXN], tim, win[MAXN];
int ans[M], top;

int Match(int u)
{
	if(ban[u]) return 0;
	for(int i=first[u];i;i=e[i].nxt){
		int v = e[i].v;
		if(vis[v] == tim || ban[v]) continue;
		vis[v] = tim;
		if(!match[v] || Match(match[v])){
			match[u] = v;
			match[v] = u;
			return 1;
		}
	}
	return 0;
}

void init()
{
	read(n); read(m);
	for(int i=1;i<=n;++i){
		scanf("%s", s + 1);
		for(int j=1;j<=m;++j){
			if(s[j] == 'O') mp[i][j] = 0;
			else if(s[j] == 'X') mp[i][j] = 1;
			else{
				mp[i][j] = 1;
				bx = i, by = j;
			} 
		}
	}
}

void build()
{
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			id[i][j] = ++ID;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(!mp[i][j]) continue;
			for(int k=0;k<4;++k){
				int x = i + nx[k], y = j + ny[k];
				if(x < 1 || x > n || y < 1 || y > m) continue;
				if(mp[x][y] == 1) continue;
				AddEdge(id[i][j], id[x][y]);
				AddEdge(id[x][y], id[i][j]);
			}
		}
	}
}

void solve()
{
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(mp[i][j]){
				++tim;
				Match(id[i][j]);
			}
		}
	}
	read(q);
	for(int i=1;i<=(q<<1);++i){
		int x = id[bx][by];
		ban[x] = 1;
		if(match[x]){
			int y = match[x];
			match[x] = match[y] = 0;
			++tim;
			win[i] = !Match(y);
		}
		read(bx); read(by);
	}
	for(int i=1;i<=q;++i){
		if(win[(i<<1)-1] && win[i<<1]){
			ans[++top] = i;
		}
	}
	printf("%d\n", top);
	for(int i=1;i<=top;++i){
		printf("%d\n", ans[i]);
	}
}

int main()
{
	init();
	build();
	solve();	
	return 0;
}

```

---

## 作者：是个汉子 (赞：22)

[洛谷传送门](https://www.luogu.com.cn/problem/P1971)	[LOJ传送门](https://loj.ac/problem/2447)

蒟蒻做题太少，这个**博弈论**的题实在是太好了！！！

### Solution

这个题需要细讲，咱们一步一步来

##### 1.思路的转化

这题看着很像博弈论，其实它就是博弈论。

但如果是对黑白棋子的移动路径进行判断，一共 $n\times m-1$ 枚棋子，~~好像也不多~~，情况很多，也递推不了，是不可的。

我们换个角度——既然棋子多，为什么不考虑空格呢？

将他们的操作看作轮流对空格进行移动。因为兔兔往左移棋子就是往右移空格，别的方向同理。蛋蛋同理。	

##### 2.空格移动路径的小性质

性质：空格的移动路径不会重复，即空格不会多次经过一个点。

我们用反证法证明：

记空格刚开始所在的格子为 $P_0$ ，第 $i$ 步到达 $P_i$ 。

假设在 $n$ 步之后回到了 $P_0$ ，即走了 $P_0,P_1,P_2,\cdots ,P_{n-1},P_n$ 。因为每次只能走上下左右，而回到了原点，所以往右走了多少，就往左走了多少；往下走了多少，就往上走了多少，那么 $n$ 是偶数。

所以第 $1$ 步是兔兔挪动的，第 $n$ 步是蛋蛋挪动的。但是当空格到了 $P_1$ 时，此时 $P_0$ 是白子，而空格想要回 $P_0$ 时，是蛋蛋拿着的，他动不了白子，所以矛盾。

##### 3.二分图的匹配和另一个小性质

如果将空格开始所在的格子看作黑色，由上面性质可得，空格的移动路径就是**黑白相间**的。

我们建一张二分图，左边是黑色，右边是白色，格子相邻的进行连边。兔兔就是从左到右，蛋蛋就是从右到左。

性质：当且仅当最大匹配**一定**覆盖空格所在格子，兔兔必胜；否则蛋蛋必胜。

我们讨论其中一种情况：如果存在一个最大匹配没有覆盖空格所在的格子，蛋蛋必胜。

因为最大匹配中没有起点，所以兔兔只能从某一条非匹配边走到右边（没有没走过的非匹配边兔兔就败了）。此时蛋蛋即将挪动的点必定是最大匹配中的（不然就可以将起点和这个点连起来了），所以蛋蛋可以挪回左边。

也就是说，蛋蛋必定能找到一种回到左边的方式，但兔兔可能没有。

另一种同理可得，就不再多浪费篇章了。

##### 4.此题解法

但是这个题不是普通的博弈论，所以它也不是问谁必胜，而是兔兔犯错误的次数

我们模拟一下二人的过程：

先是兔兔走，设兔兔走到了 $t$ ，由上面二分图的性质的可知，我们只需判断有起点和无起点的最大匹配是否不一样即可。不相等说明一定有起点，也就是兔兔必胜。

然后强迫覆盖起点和 $t$ 的匹配

现在是蛋蛋走，匹配边是兔兔走过来的，由上面二分图的性质可知，如果存在一个和 $t$ 相连的点没有在最大匹配中，那么蛋蛋就可以转化到兔兔的必败态，也就是蛋蛋必胜。

然后将蛋蛋走到的格子看作新的起点，继续重复上面的过程。

细节：都在代码里了(oﾟvﾟ)ノ

### Code

```c++
#include<bits/stdc++.h>

using namespace std;
const int N=50,M=N*N,K=1000,dx[]={0,0,-1,1},dy[]={1,-1,0,0};
int n,m,k;
char mp[N][N];
int idx[N][N],cntB,cntW;
int x,y;

template <typename T> void read(T &x){
     int f=1; x=0;
     char ch=getchar();
     while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
     while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
     x*=f;
}

int cnt,head[M];
struct edge{
    int to,nxt;
}e[M<<2];
inline void add(int u,int v){
    e[++cnt].to=v;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}

/*-------二分图匹配----------*/
int max_mat,match[M];
bool flag[M],vis[M];    //flag代表是否能匹配    vis表示是否匹配
inline bool find(int u){    //找到u的匹配
    vis[u]=1;
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(flag[v]==0&&(match[v]==0||(vis[match[v]]==0&&find(match[v])))){
            match[u]=v;
            match[v]=u;
            return 1;
        }
    }
    return 0;
}

inline bool check(int u){   //判断
    for(int i=1;i<=cntB+cntW;i++) vis[i]=0;
    return find(u);
}

inline void un_Matched(int u){      //将u的匹配断开
    if(match[u]==0) return ;
    int v=match[u];
    match[u]=match[v]=0;
    max_mat--;
    flag[u]=1;
    if(check(v)) max_mat++;
}

inline void Matched(int u){     //强制u匹配
    flag[u]=0;
    if(check(u)) max_mat++;
}

inline void cover(int u,int v){     //将u和v的匹配来覆盖原来的匹配
    if(match[u]==v){
        flag[u]=flag[v]=1;
        return ;
    }
    int f=0,g=0;
    if(match[u]!=0) g=match[u],match[g]=match[u]=0,max_mat--;
    if(match[v]!=0) f=match[v],match[f]=match[v]=0,max_mat--;
    match[u]=v;match[v]=u;
    flag[u]=flag[v]=1;
    max_mat++;
    if(f&&check(f)) max_mat++;
    if(g&&check(g)) max_mat++;
}
/*-------md 终于结束了-------*/
int tot,ans[K];

int main(){
    read(n);read(m);
    for(int i=1;i<=n;i++)
        scanf("%s",mp[i]+1);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(mp[i][j]=='O') idx[i][j]=++cntW;
            else idx[i][j]=++cntB;
            if(mp[i][j]=='.') mp[i][j]='X',x=i,y=j;
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(mp[i][j]=='O') idx[i][j]+=cntB;  //因为点不能重复,所以将所有白点往后移
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(mp[i][j]=='X')
                for(int k=0;k<=3;k++){
                    int xx=i+dx[k],yy=j+dy[k];
                    if(xx<1||n<xx||yy<1||m<yy) continue;
                    if(mp[xx][yy]=='O') add(idx[i][j],idx[xx][yy]),add(idx[xx][yy],idx[i][j]);
                }
    for(int i=1;i<=cntB;i++)
        if(check(i)) max_mat++;
    read(k);
    int sx,sy;
    for(int i=1;i<=k;i++){
        read(sx);read(sy);
        int u=idx[x][y],v=idx[sx][sy];  //因为移动的是空格,所以sx和sy就是空格要到的地方
        un_Matched(u);
        int tmp1=max_mat;
        Matched(u);
        int tmp2=max_mat;
        cover(u,v);
        if(tmp1!=tmp2){
            int _flag=0;
            for(int j=head[v];j;j=e[j].nxt){
                int t=e[j].to;
                if(flag[t]==0&&match[t]==0){
                    _flag=1;
                    break;
                }
            }
            if(!_flag){
                int tmp3=max_mat;
                for(int j=head[v];j;j=e[j].nxt){
                    int t=e[j].to;
                    if(flag[t]) continue;
                    un_Matched(t);
                    int tmp4=max_mat;
                    Matched(t);
                    if(tmp3==tmp4){
                        _flag=1;
                        break;
                    }
                }
            }
            if(_flag) ans[++tot]=i;
        }
        read(x);read(y);
    }
    printf("%d\n",tot);
    for(int i=1;i<=tot;i++) 
        printf("%d\n",ans[i]);
    return 0;
}
```

部分思路来自[这里](https://www.cnblogs.com/maijing/p/4703094.html)

---

## 作者：zac2010 (赞：14)

首先，棋子的颜色分黑和白，是一个标准的二分图形式。

其次，我们对操作进行观察，易得出：一个空位到过的位置之后不会再走了（考虑操作步骤的奇偶性以及棋子的颜色）。

于是我们大胆想象：移动棋子等价于移动空格，既然一个空格走了就不会再回到原来的位置，那么只需要把一个位置看成一个点（空格为初始位置），问题就可以转化为二分图博弈的形式。

以下关于二分图博弈模板的内容摘自我的文章：

* 给出一张二分图，将一个棋子放在起点。两人轮流操作，每人允许移动一步，不能移到曾经到过的点。无法操作者输。

* 结论：若最大匹配的所有方案都包含起点，先手必胜；反之后手必胜。

  判断方法：把整张图的最大匹配和去掉起点的图的最大匹配进行比较，相同则后手胜；反之先手胜。

* 证明：其余的连通块都走不到且不影响，只需要考虑起点所在的连通块。我们按照结论中的两种情况来考虑：

  * 存在最大匹配的方案不包含起点。

    那么有：必定存在一种最大匹配使得每一条路径都是交错路。

    其中交错路的定义是从一个未匹配点出发，经历的路径依次为未匹配边、匹配边、未匹配边……以此类推。

    那么先手一开始必然走一条未匹配边，后手只需要走匹配边。注意到最后一条边必定是匹配边（不然就形成增广路了，与”最大匹配“不符）。

    故而后手走完先手没法走，后手必胜。

  * 不存在最大匹配的方案不包含起点。

    不难发现所有路径上的边也都是交错的，只不过起点是一个匹配点。

    那么开头先手选择某一种方案，走匹配边。那后手必定只能走未匹配边，先手再选择匹配边……以此类推。

    最后一条必定为匹配边（否则与“所有方案都包含起点”矛盾），先手必胜。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 2010, M = 45;
int n, m, ans, k, s, vis[N], match[N], b[N], w[N];
int f[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
char c[M][M]; vector<int> e[N];
int id(int x, int y){return (x - 1) * m + y;}
int dfs(int u){
    for(int &v: e[u]){
        if(vis[v] || b[v]) continue; vis[v] = 1;
        if(!match[v] || dfs(match[v])){match[match[u] = v] = u; return 1;}
    }
    return 0;
}
int main(){
    scanf("%d%d", &n, &m);
    FL(i, 1, n) scanf("%s", c[i] + 1);
    FL(i, 1, n) FL(j, 1, m){
        if(c[i][j] == '.') s = id(i, j), c[i][j] = 'X';
        FL(l, 0, 3){
            int x = i + f[l][0], y = j + f[l][1];
            if(x < 1 || x > n || y < 1 || y > m || c[i][j] == c[x][y]) continue;
            e[id(i, j)].emplace_back(id(x, y));
        }
    }
    FL(i, 1, n) FL(j, 1, m) if(c[i][j] == 'X')
		memset(vis, 0, sizeof(vis)), dfs(id(i, j));
    scanf("%d", &k), b[s] = 1;
    FL(i, 1, k + k){
        if(match[s]){
            int u = match[s]; match[s] = match[u] = 0;
            memset(vis, 0, sizeof(vis)), w[i] = !dfs(u);
        }
        int x, y; scanf("%d%d", &x, &y);
        b[s = id(x, y)] = 1;
    }
    FL(i, 1, k) ans += (w[i + i] && w[i + i - 1]);
    printf("%d\n", ans);
    FL(i, 1, k) if(w[i + i] && w[i + i - 1]) printf("%d\n", i);
    return 0;
}
```


---

## 作者：LroseC (赞：10)

### 前置知识
* 二分图博弈

二分图博弈模板题[链接](https://www.luogu.com.cn/problem/P4617)

### 思路

首先这题有个并不显然的性质：我们发现，同一个格子不能经过两次。

简单证明：

如果我们走回这个格子，那么路径显然成一个环。我们把这个环拿出来，因为是网格图上的环，我们容易发现其周长必然是偶数。

如果现在格子里填的是黑棋子，那么经过偶数步我们当前必然只能走白格子，反之亦然（自己画图理解一下）。

有了这个性质，这题就成了二分图博弈模板题：有两类点，每次只能从一类点向另一类点走，无法移动的人失败。

二分图博弈经典结论：起点是二分图最大匹配必经点则先手必胜，否则先手必败。

题目告诉我们：兔兔犯错误当且仅当这次操作过后，必胜方由兔兔变成了蛋蛋。

于是我们只要判断所有操作过后的局面是先手必胜还是先手必败即可。如果兔兔操作前是先手必胜局面，操作后还是先手必胜局面（此时先手是蛋蛋），则兔兔犯错误。

判断一个局面是否先手必胜，也即判断当前点是否是二分图最大匹配必经点，首先要把之前操作过的点删掉（不能走第二遍），记录当前最大匹配，然后删掉当前点，看最大匹配是否减小即可。

听起来太麻烦了？我们有一个小 trick！

对于这种删掉点的，我们通常考虑把时间轴倒过来，让时间倒流。这样就把删点的操作变成了加点。

于是我们把操作的点按时间倒序加入。每次加入一个点后如果最大匹配变大，那么这个点是必经点，当前局面是先手必胜局面。

为什么加入点后最大匹配变大就是必经点？考虑反证法，如果不是，说明有一个最大匹配不经过该点，那么没有该点的最大匹配应该等于有该点的最大匹配，与加入点后最大匹配变大矛盾。

求最大匹配用 dinic 和匈牙利算法都可以，我这里用的是 dinic，参考代码较长，懒得写的可以自行换成匈牙利。

### 参考代码
```cpp
#include <queue>
#include <vector>
#include <cstring>
#include <climits>
#include <iostream>
#include <algorithm>

using i64 = long long;

const int N = 1e4 + 10, M = 1e5 + 10;
int gox[] = {1, -1, 0, 0};
int goy[] = {0, 0, 1, -1};

bool vis[50][50], win[N];
char G[50][50];
int n, m, K, S = N - 1, T = N - 2;
int idx = 1, head[N], nex[M], to[M], fl[M];
std::vector< std::pair<int, int> > del	;

void addEdge(int u, int v, int f)
{
	nex[++idx] = head[u];
	head[u] = idx;
	to[idx] = v, fl[idx] = f;
}
void addFlow(int u, int v, int f)
{
	addEdge(u, v, f);
	addEdge(v, u, 0);
}

namespace dinic
{
	int now[N], d[N];

	bool BFS(void)
	{
		std::queue<int> q;
		std::memset(d, 0, sizeof d);
		std::memcpy(now, head, sizeof head);
		d[S] = 1; q.emplace(S);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (int e = head[u]; e; e = nex[e])
				if (fl[e] && !d[to[e]]) {
					d[to[e]] = d[u] + 1;
					if (to[e] == T) return 1;
					q.emplace(to[e]);
				}
		}
		return 0;
	}
	int dfs(int u, int flow)
	{
		if (u == T)
			return flow;
		int rest = flow;
		for (int e = now[u]; rest && e; e = nex[e])
			if (fl[e] && d[to[e]] == d[u] + 1) {
				now[u] = e;
				int tmp = dfs(to[e], std::min(rest, fl[e]));
				if (!tmp) d[to[e]] = 0;
				rest -= tmp;
				fl[e] -= tmp;
				fl[e ^ 1] += tmp;
			}
		return flow - rest;
	}
	int main(void)
	{
		int res = 0;
		while (BFS())
			res += dfs(S, INT_MAX);
		return res;
	}
}

inline int getId(int x, int y)
{
	return (x - 1) * m + y;
}
int main(void)
{
	std::cin >> n >> m;
	// 在最开始把二分图连向源汇点的边连上
	for (int i = 1; i <= n; ++i) {
		std::cin >> G[i] + 1;
		for (int j = 1; j <= m; ++j) {
			if (G[i][j] == '.') {
				addFlow(S, getId(i, j), 1);
				vis[i][j] = 1;
				del.emplace_back(i, j);
			}
			if (G[i][j] == 'X')
				addFlow(S, getId(i, j), 1);
			if (G[i][j] == 'O')
				addFlow(getId(i, j), T, 1);
		}
	}
	std::cin >> K; //读入操作，把这些点删掉
	for (int i = 1, x, y; i <= K << 1; ++i) {
		std::cin >> x >> y;
		vis[x][y] = 1;
		del.emplace_back(x, y);
	}
	// 把没删的点之间的边连上
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			if (!vis[i][j] && G[i][j] == 'X')
				for (int k = 0; k < 4; ++k) {
					int xx = i + gox[k];
					int yy = j + goy[k];
					if (xx < 1 || xx > n || yy < 1 || yy > m) continue;
					if (!vis[xx][yy] && G[i][j] != G[xx][yy])
						addFlow(getId(i, j), getId(xx, yy), 1);
				}
	dinic::main(); // 先跑一遍 dinic
	// 按时间倒序把每个点和与它相连的边加入
	for (int i = K << 1; i >= 0; --i) {
		auto t = del[i];
		vis[t.first][t.second] = 0;
		for (int k = 0; k < 4; ++k) {
			int xx = t.first + gox[k];
			int yy = t.second + goy[k];
			if (xx < 1 || xx > n || yy < 1 || yy > m) continue;
			if (!vis[xx][yy] && G[t.first][t.second] != G[xx][yy]) {
				if (G[xx][yy] == 'X' || G[xx][yy] == '.')
					addFlow(getId(xx, yy), getId(t.first, t.second), 1);
				else
					addFlow(getId(t.first, t.second), getId(xx, yy), 1);
			}
		}
		win[i] = dinic::main(); //在残量网络上跑 dinic，如果有流量说明该点为必经点。
	}
	int res = 0;
	for (int i = 0; i <= K << 1; i += 2)
		if (win[i] && win[i + 1]) //当前先手必胜并且操作完依然先手必胜，就是犯了错误
			++res; //先统计答案数量
	std::cout << res << '\n';
	for (int i = 0; i <= K << 1; i += 2)
		if (win[i] && win[i + 1]) //输出答案
			std::cout << (i >> 1) + 1 << '\n';
	return 0;
}
```


---

## 作者：DaiRuiChen007 (赞：5)

# P1971 题解

## 前置知识

### I. 博弈规则

Undirected Vertex Geography（简称UVG）游戏规则如下：

在一张二分图 $\mathbf G=(\mathbf X,\mathbf Y,\mathbf E)$ 上有一个棋子在节点 $v$ 上，$v\in\mathbf X$：

两名玩家轮流将这枚棋子挪到某个 $v$ 之相邻的节点 $v'$ 上，如果某一方不能移动，则立刻判负，请问谁有必胜策略？



### II. 结论

记 $\mathbf M$ 为某个 $\mathbf G$ 的最大匹配，$V(\mathbf M)$ 是 $\mathbf M$ 中所有边连接的点构成的集合。

先手胜利当且仅当不存在 $\mathbf M$ 使得 $v\not\in V(\mathbf M)$。



### III. 证明

先证必要性：

> 证：
>
> 由假设得 $\forall \mathbf M:v\in V(\mathbf M)$。
>
> 我们为先手设计一个移动策略：即每次都沿着 $\mathbf M$ 中的边移动。
>
> 现在我们需要证明当到达某个 $x_i$ 后，一定存在一条边 $(x_i,y_j)\in\mathbf M$。
>
> 考虑反证法，若当前到达 $x_i$ 后 $\mathbf M$ 中没有相邻的匹配边，假设当前的移动路径为 $\mathbf A$，显然 $\mathbf A$ 是 $\mathbf M$ 的一条交错轨。
>
> 我们构造一个新的边集 $\mathbf{M'}=\mathbf M\oplus \mathbf A$，可以证明 $\mathbf{M'}$ 依然是 $\mathbf G$ 的一个匹配，且满足 $|\mathbf{M'}|=|\mathbf M|$，$v\not\in V(\mathbf{M'})$。
>
> 与原命题矛盾，故假设不成立，故原命题得证。

再证充分性：

现将原命题转化为其逆否命题：如果存在一个 $\mathbf G$ 的最大匹配 $\mathbf M$ 满足 $v\not\in V(\mathbf M)$，则后手一定有一个必胜策略：

>证：
>
>可以推知：$\forall (v,v')\in \mathbf E:v'\in\mathbf{M}$，否则 $(v,v')$ 也可以加入 $\mathbf M$ 中，与 $\mathbf M$ 是最大匹配矛盾。
>
>因此先手一定会把棋子移动到 $\mathbf M$ 中的某个顶点上。
>
>类似上面的证明：我们为后手设计一个移动策略：即每次都沿着 $\mathbf M$ 中的边移动。
>
>同上，原命题可以看做：证明当到达某个 $y_i$ 后，一定存在一条边 $(x_j,y_i)\in\mathbf M$。
>
>同样反证法，设 $y_i$ 没有 $\mathbf M$ 中的匹配边与其相连，则当前移动的路径 $\mathbf A$ 会形成一个增广轨，这与 $\mathbf M$ 是 $\mathbf G$ 的一个最大匹配同样矛盾，故原命题得证。

综上所述，当且仅当**不存在**最大匹配 $\mathbf M$ 使得 $v\not\in V(\mathbf M)$ 时，先手有必胜策略。



### IV. 算法实现

求解 UVG 问题，只需要判断某个点是否一定会在 $\mathbf G$ 的最大匹配中。

下面的伪代码给出了在 $\Theta(nm)$ 复杂度内计算所有先手必胜点的策略：

[![xMoAXV.png](https://s1.ax1x.com/2022/10/03/xMoAXV.png)](https://imgse.com/i/xMoAXV)



## 思路分析

黑子和白子都不独特，但是空格只有一个，因此应该重点关注空格，我们把棋子移动到空格上变成空格移动到棋子上。

这个时候看到棋盘问题，我们可以考虑黑白间隔染色，假设空格最开始在黑色格子上，那么每次移动的时候空格可以移动到黑色格子的黑色棋子上或者白色格子的白色棋子上（假设空格上有一枚黑色棋子）。

假如我们此时对所有能互相到达的格子之间连边，那么这张图就是一张二分图。

空格每次移动会交换两枚棋子的位置，注意到每次交换一定会让黑色棋子移动到白色格子上，白色棋子移动到黑色格子上，因此每当我们考虑完一个移动的操作，我们只需要把这个点从二分图中删掉即可。

原问题转化成在二分图上，双方轮流移动棋子，不能重复经过节点，移动不了的输，可以发现这就是刚刚介绍的 UVG 游戏，套结论：当且仅当空格在二分图最大匹配的一个必经点上，那么先手胜。

因此对于每次移动：我们考虑原来二分图的最大匹配和删掉当前位置的二分图的最大匹配，当且仅当这两个东西不相等的时候先手有必胜策略。

注意删掉点之后需要更新最大匹配的大小。

对于每个格子暴力做二分图最大匹配即可解决此问题。

时间复杂度 $\Theta(kn^2m^2)$。

## 代码呈现

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int MAXN=41,MAXS=1601,MAXK=1001;
int n,m,dx[]={0,0,1,-1},dy[]={1,-1,0,0};
int tar[MAXS];
bool vis[MAXS],win[MAXK];
bool bel[MAXN][MAXN],col[MAXN][MAXN],del[MAXS];
vector <int> edge[MAXS],src;
inline int id(int x,int y) {
	if(x<1||x>n||y<1||y>m||bel[x][y]!=col[x][y]) return -1;
	return (x-1)*m+y;
}
inline bool match(int p) {
	if(del[p]) return false;
	for(int x:edge[p]) {
		if(vis[x]||del[x]) continue;
		vis[x]=true;
		if(tar[x]==-1||match(tar[x])) {
			tar[x]=p;
			return true;
		}
	}
	return false;
}
inline int MM() {
	int ret=0;
	memset(tar,-1,sizeof(tar));
	for(int x:src) {
		memset(vis,false,sizeof(vis));
		if(match(x)) ++ret;
	}
	return ret;
}
signed main() {
	int kx,ky;
	cin>>n>>m;
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=m;++j) {
			char ch;
			cin>>ch;
			if(ch=='.') kx=i,ky=j,bel[i][j]=true;
			else bel[i][j]=(ch=='X');
		}
	}
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) col[i][j]=((i+j)%2==(kx+ky)%2);
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=m;++j) {
			if(bel[i][j]&&col[i][j]) {
				src.push_back(id(i,j));
				for(int k:{0,1,2,3}) {
					int x=i+dx[k],y=j+dy[k];
					if(id(x,y)!=-1) {
						edge[id(i,j)].push_back(id(x,y));
					}
				}
			}
		}
	}
	int stdv=MM(),k;
	del[id(kx,ky)]=true;
	int tmpv=MM();
	win[1]=tmpv!=stdv;
	stdv=tmpv;
	scanf("%d",&k);
	vector <int> ans;
	for(int i=1;i<=k;++i) {
		int tx,ty;
		scanf("%d%d",&tx,&ty);
		del[id(tx,ty)]=true;
		tmpv=MM();
		win[i*2]=tmpv!=stdv;
		stdv=tmpv;
		if(win[i*2]&&win[i*2-1]) ans.push_back(i);
		scanf("%d%d",&tx,&ty);
		del[id(tx,ty)]=true;
		tmpv=MM();
		win[i*2+1]=tmpv!=stdv;
		stdv=tmpv;
	}
	printf("%d\n",(int)ans.size());
	for(int p:ans) printf("%d\n",p);
	return 0;
}
```



---

## 作者：xsap (赞：5)

首先可以推出来一个引理：空格不可能在经过几次操作后回到原来的位置。
大概感性证明一下：容易发现这个空格如果想要走成一个环，向上走的次数=向下走的次数，向左走的次数=向右走的次数。那么如果开始是兔兔走的话，最后得是蛋蛋走的。假设开始兔兔从$(x_0,y_0)$走到了$(x_1,y_1)$，最后蛋蛋从$(x_n,y_n)$走到了$(x_0,y_0)$。我们不妨只考虑走出来的最短环（即最早走重的一次），那么当兔兔走完之后，$col(x_0,y_0)$变为了白色（相当于被兔兔的一个白色挤了过来），这样$col(x_0,y_0)$永远都应该是白色，那蛋蛋就永远走不到$(x_0,y_0)$，这样就矛盾了。

所以就有引理：走的路径肯定是一条类似链的结构。
这意味着什么？每次兔兔或蛋蛋走完了之后，他们走过的格子的颜色我们就不关心了。这样在挪空格的时候，我们就没有必要去考虑我挪完空格后格子颜色的变化。也就是说我这个棋盘的颜色永远不会变，只不过我有一个棋子在一直从某个位置走到白色，再走到黑色，再走到白色...这样其实就转化成了一个经典的问题，大概就是棋盘上有一个卒再走，每次颜色需要交替不同。

这个问题的做法大概就是对棋盘构造一个二分图，所有黑色的点像白色的点连一条无向边。那么就变成了又一个二分图，有起点，两个人沿着边挪棋子，不能回来。问谁有必胜策略。这是个经典问题，在此不再赘述其算法了。是铃酱博客中的例题的弱化版。

注意到这道题其实数据范围挺小的，建图是可以直接建的，提前跑出最大匹配，然后每次枚举删掉一个点每一次跑一个dinic就可以了。

---

## 作者：takanashi_mifuru (赞：4)

[Portal](https://www.luogu.com.cn/problem/P1971)

第一步：本题只有一个空位，理所当然应该是移动空位来做题。

第二步（本题最难点）：空位不能重复经过一个点。

因为什么呢，假设他兜兜转转一大圈回来，到了这个点，那么他的行进路径平移一下发现是一个长方形，长方形每一条边的边长都是整数的时候，周长一定是一个偶数，而如果路径长度是偶数，那就是说，第一步兔兔移一下，最后一步就必须是蛋蛋来移动兔兔移动过的点，这是不合法的。

第三步：这个问题就变成了，空格要在不同颜色上的点上面跑来跑去，什么时候跑不下去了，另一方就是赢的，在棋盘上跑相邻点，应该是二分图博弈论吧！

我们按照 `O` 和 `X` 染色整个棋盘，空格的话，因为最开始操作的是我们兔友，所以染成 `X` 同种颜色方便不同颜色之间的移位。

第四步：现在就是二分图博弈论的样板戏，先甩一个结论：如果一个点在这张图中一定在最大匹配中，那么以这个点作起始点的话先手必胜，这个结论还是非常显然的，先手可以走匹配点，后手随便走一个点，先手也一定可以再找一个匹配点，因为这其实是匈牙利算法的流程。

那么后手走一下，先手再跑跑匹配点就一定也能走一下，这样一直走下去，肯定是后手先无路可走。

那么非常自然就拥有另一个结论，如果一个点在二分图中不一定在最大匹配中，那么他作起始点先手是必败的。

为什么呢？假设他不是最大匹配，那他走一步就肯定走进最大匹配里啊！那不就变成上一种情况了吗。

那现在只需要判断空格所在点在不在最大匹配里面不就行了吗！

然而这个是[模板](https://www.luogu.com.cn/problem/P4055)。

那这个题就做完了啊！

---

## 作者：FZzzz (赞：3)

先证明不可能重复经过一个格子：简单环的长度必然是偶数，那么第一步和最后一步由不同玩家操作，但第一步已经把一个他的颜色的棋子推到了第一个格子里，也就是说最后一步不能进入这个格子。

那么，我们走向每个格子时，它里面的棋子都是从一开始就摆在这里的。所以，如果把起点看成黑色，能从一个格子走到相邻的另一个格子，当且仅当这个格子没有被走过且它们最开始棋子的颜色不同。

至此，我们的游戏转化为：给一个二分图和一个起点，两人轮流在上面走路，不能经过重复点，谁走不动谁输。结论是，若任何一个最大匹配都包含起点，则先手胜。

把走过一个点看作删掉它，那么走一步之后得到一个新的这样的问题，是一个组合游戏，考虑递归证明。首先终态显然不满足“任何一个最大匹配都包含起点”，我们需要证明两件事：
- 满足这个条件的状态可以一步走到一个不满足这个条件的状态。任何一个最大匹配都包含当前点，那么把它删掉以后最大匹配减一。任意拉一个最大匹配出来，走向当前点的匹配点，只需要在原图的最大匹配的基础上把这条匹配边去掉就可以得到一个新图的最大匹配，并且它不包含目标点。
- 不满足这个条件的状态必然一步走到一个满足这个条件的状态。如果不是这样，原图与新图的最大匹配大小一定相等，在新图中找出一个不包含目标点的最大匹配，在这个匹配的基础上加上当前点和目标点的这条边就可以得到一个原图的更大的匹配，矛盾。

于是我们证明了结论。原题转化为 $k$ 次询问某个点是否必然被最大匹配包含，然后删掉它。考虑时刻维护当前图的一个最大匹配。
- 若询问点不是匹配点，则它不必然被最大匹配包含；
- 否则，删掉询问点后它的匹配点变为未匹配状态。从这个点开始在新图上寻找增广路，若可以找到则说明询问点不必然被最大匹配包含，否则必然被包含。同时我们得到了新的最大匹配。

总时间复杂度 $O(nmk)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=40+5;
int n,m,k;
char s[maxn][maxn];
vector<int> g[maxn*maxn];
const int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
int p[maxn*maxn];
bool del[maxn*maxn],vis[maxn*maxn];
bool dfs(int u){
	if(vis[u]) return 0;
	vis[u]=1;
	for(int v:g[u])
		if(!del[v]&&(!p[v]||dfs(p[v]))){
			p[u]=v;
			p[v]=u;
			return 1;
		}
	return 0;
}
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	m=read();
	int u=0;
	for(int i=1;i<=n;i++){
		scanf("%s",s[i]+1);
		for(int j=1;j<=m;j++) if(s[i][j]=='.'){
			u=(i-1)*m+j;
			s[i][j]='X';
		}
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
		for(int k=0;k<4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(!x||x>n||!y||y>m) continue;
			if(s[i][j]!=s[x][y])
				g[(i-1)*m+j].push_back((x-1)*m+y);
		}
	for(int i=1;i<=n*m;i++) if(!p[i]){
		memset(vis,0,sizeof(vis));
		dfs(i);
	}
	k=read();
	del[u]=1;
	bool lst;
	if(!p[u]) lst=0;
	else{
		p[p[u]]=0;
		memset(vis,0,sizeof(vis));
		lst=!dfs(p[u]);
	}
	vector<int> ans;
	for(int i=1;i<=k*2;i++){
		int x,y;
		x=read();
		y=read();
		u=(x-1)*m+y;
		del[u]=1;
		bool res;
		if(!p[u]) res=0;
		else{
			p[p[u]]=0;
			memset(vis,0,sizeof(vis));
			res=!dfs(p[u]);
		}
		if(i%2==1&&lst&&res)
			ans.push_back((i+1)/2);
		lst=res;
	}
	printf("%d\n",(int)ans.size());
	for(int i:ans) printf("%d\n",i);
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

二分图 博弈论
一道二分图+博弈论套餐题。
列出几种情况就能发现其中的规律。
模拟一下二人的过程：
先是兔兔走，设兔兔走到了 
tttt
tt ，由上面二分图的性质的可知，我们只需判断有起点和无起点的最大匹配是否不一样即可。不相等说明一定有起点，也就是兔兔必胜。
然后强迫覆盖起点和 
tttt
tt 的匹配
现在是蛋蛋走，匹配边是兔兔走过来的，由上面二分图的性质可知，如果存在一个和 
tttt
tt 相连的点没有在最大匹配中，那么蛋蛋就可以转化到兔兔的必败态，也就是蛋蛋必胜。
然后将蛋蛋走到的格子看作新的起点，继续重复上面的过程。
可得代码如下：
```cpp
#include <bits/stdc++.h>//神奇 
using namespace std;
int n, m;
int arr[45][45];
vector<int> edges[10005];
int tot;
int x, y;
int num[45][45];
bool vis[10005], ban[10005];
int match[10050];
bool dfs(int i) {//bool深搜
	if (ban[i]) return false;
	for (int j = 0; j < edges[i].size(); j++) {
		int k = edges[i][j];
		if (!vis[k] && !ban[k]) {
			vis[k] = 1;
			if (!match[k] || dfs(match[k])) {
				match[k] = i;
				match[i] = k;
				return true;//就返回1 
			}
		}
	}
	return false;
}
int ans[10005];
int main() {
	cin >> n >> m;
	char str[45];
	for (int i = 1; i <= n; i++) {
		scanf("%s", str+1);//用cin不太好写 
		for (int j = 1; j <= m; j++) {
			if (str[j] == 'O') arr[i][j] = 1;
			else if (str[j] == 'X') arr[i][j] = 2;
			else arr[i][j] = 2, x = i, y = j;
		}
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (arr[i][j] == 1 ^ (((i + j) & 1) == ((x + y) & 1)))
				num[i][j] = ++tot;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (!num[i][j]) continue;
			if (num[i + 1][j]) {
				edges[num[i][j]].push_back(num[i + 1][j]);
				edges[num[i + 1][j]].push_back(num[i][j]);
			}
			if (num[i][j + 1]) {
				edges[num[i][j]].push_back(num[i][j + 1]);
				edges[num[i][j + 1]].push_back(num[i][j]);
			}
		}
	}
	for (int i = 1; i <= tot; i++) {
		memset(vis, 0, sizeof(vis));
		if (!match[i]) dfs(i);
	}
	int k;
	cin >> k;
	for (int i = 1; i <= k << 1; i++) {
		int kkk = num[x][y];
		ban[kkk] = 1;
		if (match[kkk]) {
			int match = match[kkk];
			match[match] = match[kkk] = 0;
			memset(vis, 0, sizeof(vis));
			ans[i] = (!dfs(match));
		}
		cin >> x >> y;
	}
	int res = 0;
	for (int i = 1; i <= k; i++)
		res += (ans[i * 2 - 1] & ans[i * 2]);
	cout << res << '\n';
	for (int i = 1; i <= k; i++) {
		if (ans[i * 2 - 1] & ans[i * 2]) {
			cout << i << '\n'
		}
	}
	return 0;
```

---

## 作者：_Ch1F4N_ (赞：2)

首先考虑到棋子很多，空格却很少所以不如把移动棋子变成移动空格。

然后发现一个人自己被有必要去走重复的路，而第二个人因为可以移动的棋子颜色不一样也不能重复上一个人走过的路，所以我们可以认为不会走重复的路。

又因为一个人走完之后一定是另一个人走，所以摆了黑色棋子的格子下一步一定到摆了白色棋子的格子，反之亦然，所以我们可以发现这是一个二分图。

那么这个问题就变成了二分图上博弈，考虑找出二分图匹配必选点与非必选点
1. 没有被匹配的点一定是非必选点。

2. 非匹配点连向的某个匹配点所对应的另一个匹配点也是非必选的，因为可以把这条边移过来。

如此便可以判断所有非必选点。

```cpp
#include<bits/stdc++.h>
#define pos(i,j)(i*m+j)
using namespace std;
const int maxn = 1e5+114;
int n,m;
char c[1001][1001];
int vis[maxn],match[maxn];
vector<int> edge[maxn];
int del[maxn]; 
bool hungary(int u,int tm){
	for(int v:edge[u]){
		if(vis[v]==tm||del[v]==true) continue;
		vis[v]=tm;
		if(match[v]==0||hungary(match[v],tm)==true){
			match[v]=u;
			match[u]=v;
			return true;
		}
	}
	return false;
}
void add(int u,int v){
	edge[u].push_back(v);
	edge[v].push_back(u);
}
int use[maxn];
int dx[4]={0,0,-1,1};
int dy[4]={1,-1,0,0};
int type[maxn];
int cnt;
int lx,ly;
vector<int> ans;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c[i][j];
			if(c[i][j]=='.'){
				lx=i;
				ly=j;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(c[i][j]=='O'){
				for(int k=0;k<4;k++){
					int nx=i+dx[k],ny=j+dy[k];
					if(nx>=1&&nx<=n&&ny>=1&&ny<=m){
						if(c[nx][ny]!='O'){
							add(pos(i,j),pos(nx,ny));						
						}
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(c[i][j]=='O'){
				hungary(pos(i,j),++cnt);
			}
		}
	}
	int k;
	cin>>k;
	for(int i=1;i<=2*k;i++){
		del[pos(lx,ly)]=true;
		if(match[pos(lx,ly)]==0){
			type[i]=false;
		}
		else{
			int mnxt=match[pos(lx,ly)];
			match[pos(lx,ly)]=match[mnxt]=0; 
			if(hungary(mnxt,++cnt)==true)
				type[i]=false;
			else
				type[i]=true; 
		}
		cin>>lx>>ly;
	}
    for(int i=1;i<=k;i++) {
    	if(type[2*i-1]==true&&type[2*i]==true){
    		ans.push_back(i);
		}
	}
	cout<<ans.size()<<'\n';
	for(int Out:ans) cout<<Out<<'\n';
}
```


---

## 作者：DengDuck (赞：2)

这道题是一个二分图博弈论。

> 二分图博弈是一类博弈模型。
>
> 给出一张二分图和博弈的起点，先手与后手轮流进行操作，每次操作只能走到与当前点相邻的点，每个点只能走一次。
>
> 最终无法选点的人则判负，问先手是否必胜。
>
> ——随便找个博客改的。

首先我们把目光聚焦在这个空格上，我们发现其走的棋子的颜色恰好是每次变换的，由于开始走的是白色，我们可以认为初始空格为黑色。

我们将相邻的不同颜色的棋子建边，不难发现其走的是一个二分图。

二分图博弈论的结论是，先手必胜当且仅当起点是所有最大匹配都需要的一个点。

具体如何判断？我们先求出二分图的最大匹配。

对于每个点的查询，我们先将其与原先匹配的点断边（当然，要是原来就没匹配肯定就不行了）。

断边之后，看看原先匹配的点是否还能再找一个点匹配，如果不行，自然当前点就是必须的了。

所以呢，这道题就很简单了，记录下每个点是先手必胜还是必输，然后看看兔兔的每次操作，如果操作前必胜，操作后还是必胜，那就是失误了。


```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=3605; 
const LL dx[4]={0,0,-1,1};
const LL dy[4]={1,-1,0,0};
LL n,m,x,y,vis[N],fgt[N],c[N],win[N];
char s[45][45];
LL num(LL x,LL y)
{
	return (x-1)*m+y;
}
bool pd(LL x,LL y)
{
	if(x<1||n<x||y<1||m<y||s[x][y]!='O')return false;
	return true;
}
vector<LL>v[N],ans;
LL choose(LL x)
{
	for(auto i:v[x])
	{
		if(vis[i])continue;
		if(fgt[i])continue;
		vis[i]=1;
		if(c[i]==0||choose(c[i]))
		{
			c[x]=i,c[i]=x;
			return 1;
		}
	}
	return 0;
}
void add(LL x,LL y)
{
	v[x].push_back(y);
	v[y].push_back(x);
}
LL link(LL x,LL y)
{
	for(int i=0;i<4;i++)
	{
		LL xx=x+dx[i],yy=y+dy[i];
		if(!pd(xx,yy))continue;
		add(num(x,y),num(xx,yy));
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>s[i][j];
			if(s[i][j]=='.')
			{
				x=i,y=j;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(s[i][j]=='O')continue;
			link(i,j);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(s[i][j]=='O')continue; 
			memset(vis,0,sizeof(vis));
			choose(num(i,j));
		}
	}
	LL k;
	cin>>k;
	for(int i=1;i<=2*k;i++)
	{
		LL t=num(x,y);
		cin>>x>>y;
		fgt[t]=1;
		if(c[t]==0)continue;
		LL nxt=c[t];
		c[t]=c[nxt]=0;
		memset(vis,0,sizeof(vis));
		if(!choose(nxt))win[i]=1;
		
	}
	for(int i=1;i<=k;i++)
	{
		if(win[2*i-1]==1&&win[2*i]==1)
		{
			ans.push_back(i);
		}
	}
	cout<<ans.size()<<endl;
	for(auto i:ans)
	{
		cout<<i<<endl;
	} 
}
```

---

## 作者：hejianxing (赞：1)


第一个黑题，写篇题解纪念一下。

双倍经验！

# 题目大意

两人博弈，有 $n\times m(1\le n,m\le 40)$ 的棋盘，每个格子中可能为空、黑棋或白棋，整个棋盘只有 $1$ 个空格。对于兔兔，每次操作将一枚与空格相邻的白色棋子移进空格。对于蛋蛋则相反。给出游戏过程，求出兔兔失误的步骤。

# 题解

每次操作是棋子与空格交换位置。

研究空格的移动，发现空格移动路径不能自交。当路径自交，代表行动了偶数步。假设空格第一次移动与白子交换，交换后将白子留在了起点，那么第偶数步必须与黑子交换。当空格在第偶数步回到起点，一定是与白子交换，与上句话矛盾，故证明空格路径不能自交。

在上述证明中更进一步，空格在偶数步行动中与黑子交换，在奇数步行动中与白子交换，$0$ 也是偶数，那么考虑将空格的初始位置看做黑色（不会随空格移动）。那么这时候你会发现，空格的移动路径就是黑白交替的。

容易想到二分图黑白染色。对矩阵分部，白色一部，黑色（包括空格初始位置）一部，将两部之间能够一步到达的点连边，跑最大匹配。

于是你发现，跟[这个题](https://www.luogu.com.cn/problem/P4055)有亿点点像。[题解](https://www.luogu.com.cn/blog/hejianxing/solution-p4055)

套用那个题的讨论，得出结论：先手走到**非最大匹配必须点**上必胜。

如何求这个东西？

首先求出一种匹配方案，当枚举到一个点时，有两种可能：

- 点 $p$ 没有被匹配
- 点 $p$ 被匹配

输入一个坐标后，将这个点删去，以免后面的过程走到这个点，因为空格的移动路径不能自交。

如果点 $p$ 没有被匹配，显然是非最大匹配必须点。

如果点 $p$ 被匹配，那么就将点 $p$ 删去（点 $p$ 对应的匹配点失配），然后从点 $p$ 的匹配点 $q$ 尝试增广，增广成功则 $p$ 是非最大匹配必须点。

于是能够轻松求出每个步骤的胜负态（即必胜还是必败）。

回到题目，“兔兔失误的步骤”是什么意思？

其实就是兔兔原本必胜，结果一不小心，操作之后变成蛋蛋必胜了。于是只需要记录每个步骤的胜负态，然后再判断即可。

时间复杂度 $O(nmk)$.

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4005;
int n, m, k, cnt = 0, fir[N], nxt[N << 1], to[N << 1], vis[N], cxy[N], nx = 0, p[N][N], sx, sy, cans = 0, ans[N], win[N], del[N];
char a[N][N];
void ade(int u, int v) {
    cnt++, nxt[cnt] = fir[u], fir[u] = cnt, to[cnt] = v;
    cnt++, nxt[cnt] = fir[v], fir[v] = cnt, to[cnt] = u;
}
int dfs(int r) {
    vis[r] = 1;
    for (int i = fir[r]; i; i = nxt[i])
        if (!vis[to[i]] && !del[to[i]]) {//需判断邻接点是否被删除
            vis[to[i]] = 1;
            if (!cxy[to[i]] || dfs(cxy[to[i]])) {
                cxy[cxy[r]] = 0, cxy[to[i]] = r, cxy[r] = to[i];
                return 1;
            }
        }
    return 0;
}
void match() {
    for (int i = 1; i <= nx; i++)
        if (!cxy[i])
            memset(vis, 0, sizeof(vis)), dfs(i);
}
void getp() {
    int tmp = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (a[i][j] == 'O')
                p[i][j] = ++tmp;
    nx = tmp;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (a[i][j] == 'X') p[i][j] = ++tmp;
            else if (a[i][j] == '.') p[i][j] = ++tmp, sx = i, sy = j;
}
int dx[5] = {0, 1, 0, -1};
int dy[5] = {1, 0, -1, 0};
void edge(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int xx = x + dx[i], yy = y + dy[i];
        if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && p[xx][yy] > nx) ade(p[x][y], p[xx][yy]);
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%s", a[i] + 1);
    getp();//重新标号，白点标 1~nx，剩下的 nx+1~n 依次标号
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (a[i][j] == 'O')
                edge(i, j);//建图
    match();//先来一发最大匹配
    scanf("%d", &k);
    for (int t = 1; t <= k * 2; t++) {
        int x = p[sx][sy];
        scanf("%d%d", &sx, &sy);//注意要在continue前输入
        del[x] = 1;//直接删除
        if (!cxy[x]) continue;
        int tmp = cxy[x];
        cxy[x] = cxy[tmp] = 0, memset(vis, 0, sizeof(vis));
        if (!dfs(tmp)) win[t] = 1;//当前状态下（未操作）先手必胜
    }
    for (int i = 2; i <= k * 2; i += 2)
        if (win[i] == 1 && win[i - 1] == 1)
            ans[++cans] = i / 2;
    printf("%d\n", cans);
    for (int i = 1; i <= cans; i++) printf("%d\n", ans[i]);
    return 0;
}
```

# END


---

## 作者：SunnyYuan (赞：0)

## 题解

**我主要画几张图帮助大家理解。**

## 思路

为了避免过于空虚，我先简述一下思路：

棋子太多，我们无法考虑这么多棋子的移动方式。

所以，我们可以想到用空格移动来代替棋子的移动，在移动过程中，空格的颜色也会变成棋子的颜色。比如一个白棋子移动到了空格里面，就可以理解为空格移动到了白棋子原有位置并变成了白空格，一个黑棋子移动到了空格里面就可以理解为空格移动到了黑棋子原有位置并变成了黑空格。

所以在空格的移动中，空格的颜色是黑-白-黑-白-黑-白这样交替的。

然后我们发现如果空格到过 $(x, y)$，就再也不会进入 $(x, y)$，且路径不会相交。

接着我们可以想到，将相邻的不同的颜色的点用边相连，形成二分图。

**重点来了：**

如果二分图的最大匹配覆盖了空格且空格是必须点，那么先手必胜。

因为先手总能根据最大匹配走到右边。

![](https://cdn.luogu.com.cn/upload/image_hosting/cp9p2oek.png)

比如这张图，实线表示匹配边，虚线表示非匹配边。

空格不论在哪里，先手先操作，都可以沿着匹配边（实线）到达另一边，但是后手就不一定能沿着非匹配边回来了：

![](https://cdn.luogu.com.cn/upload/image_hosting/uydfyi0c.png)

如果空格不是最大匹配的必须点，即失去这个点最大匹配不变。先手先操作，一定会沿着非匹配边到达匹配点，然后，后手就可以一直沿着匹配边到达另一边，先手就不一定能回来了。

![](https://cdn.luogu.com.cn/upload/image_hosting/3zj8libp.png)

---

这个题目要求让你判断每个操作是否正确。

那我们就可以暴力跑二分图，如果去掉空格后的二分图的最大匹配不变，那么兔兔必败，说明它做错了。然后还要检查它的这个匹配是否是唯一的，假如空格所在点为 $u$，那么它的匹配点 $match[u]$ 如果还可以找到其他匹配边来替代当前匹配，也说明空格点是非必须点，兔兔必败，它做错了。

## 代码

代码主要的分为

1. 二分图的最大匹配：匈牙利算法（`dfs` 函数）。
2. 将一个点 $u$ 删除并重新计算最大匹配（`cut` 函数）。
3. 将点 $u$ 进行匹配（`link` 函数）。
4. 强制将 $u, v$ 两点进行匹配（`connect` 函数）。
5. 对每一步进行处理（`solve` 函数）。

```cpp
/*******************************
| Author:  SunnyYuan
| Problem: P1971 [NOI2011] 兔兔与蛋蛋游戏
| Contest: Luogu
| URL:     https://www.luogu.com.cn/problem/P1971
| When:    2023-09-04 23:30:45
| 
| Memory:  125 MB
| Time:    1000 ms
*******************************/

#include <bits/stdc++.h>

using namespace std;

const int N = 50, K = N * N;
const int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};

vector<int> e[K];
int n, m, q;
char g[N][N];
int a[N][N];
int space_x, space_y;

int match[K];
bool vis[K], state[K];

vector<int> ans;
int match_cnt;

bool dfs(int u) {
    for (int to : e[u]) {
        if (vis[to]) continue;
        vis[to] = true;
        if ((!state[to]) && ((!match[to])||dfs(match[to]))) {
            match[to] = u;
            match[u] = to;
            return true;
        }
    }
    return false;
}

void cut(int u) {
    if (!match[u]) return;
    int mt = match[u];
    match[u] = match[mt] = 0;
    match_cnt--;
    state[u] = true;
    memset(vis, 0, sizeof(vis));
    match_cnt += dfs(mt);
}

void link(int u) {
    // if (match[u]) return;
    state[u] = 0;
    memset(vis, 0, sizeof(vis));
    match_cnt += dfs(u);
}

void connect(int u, int v) {
    if (match[u] == v) {
        state[u] = state[v] = 1;
        return;
    }

    // clear
    int m1 = match[u], m2 = match[v];
    if (m1) match[u] = match[m1] = 0, match_cnt--;
    if (m2) match[v] = match[m2] = 0, match_cnt--;
    match[u] = v, match[v] = u;

    state[u] = state[v] = 1;
    match_cnt++;

    if (m1) {
        memset(vis, 0, sizeof(vis));
        match_cnt += dfs(m1);
    }
    if (m2 && (!match[m2])) {
        memset(vis, 0, sizeof(vis));
        match_cnt += dfs(m2);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) iota(a[i] + 1, a[i] + m + 1, (i - 1) * m + 1);
    for (int i = 1; i <= n; i++) cin >> (g[i] + 1);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (g[i][j] == '.') space_x = i, space_y = j, g[i][j] = 'X';
            if (g[i][j] == 'X') {
                for (int k = 0; k < 4; k++) {
                    int nx = i + dx[k], ny = j + dy[k];
                    if (nx < 1 || ny < 1 || nx > n || ny > m || g[nx][ny] != 'O') continue;
                    e[a[i][j]].push_back(a[nx][ny]);
                    e[a[nx][ny]].push_back(a[i][j]);
                }
            }
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (g[i][j] == 'X') {
                memset(vis, 0, sizeof(vis));
                match_cnt += dfs(a[i][j]);
            }
        }
    }

    cin >> q;
    for (int p = 1; p <= q; p++) {
        int nx, ny;
        cin >> nx >> ny;
        int cur = a[space_x][space_y];
        int nxt = a[nx][ny];
        cut(cur);
        int tmp = match_cnt;
        link(cur);
        int tmp2 = match_cnt;
        connect(cur, nxt);
        if (tmp != tmp2) {
            bool f = true;
            int ys = match_cnt;
            for (int to : e[nxt]) {
                if (state[to]) continue;
                cut(to);
                tmp = match_cnt;
                link(to);
                if (tmp == ys) {
                    f = false;
                    break;
                }
            }
            if (!f) ans.push_back(p);
        }
        cin >> space_x >> space_y;
    }
    cout << ans.size() << '\n';
    for (auto x : ans) cout << x << '\n';
    return 0;
}
```

## 参考文献

1. [题解1](https://www.cnblogs.com/maijing/p/4703094.html)
2. [题解2](https://www.luogu.com.cn/blog/jasony/p1971-noi2011-tu-tu-yu-dan-dan-you-hu)

---


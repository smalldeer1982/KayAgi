# 「RdOI R3 附加」ACP-I

## 题目背景

**注意：这不是一道模拟题，请先完整地读完一遍题面后再开始做题。**

---

### 排行榜

| task | 最短行数 | 达成者      |
| ---- | -------- | ----------- |
| 1    | 5        | std         |
| 2    | 191     | \_\_Ultimium\_\_      |
| 3    | 845      | dead_X      |
| 4    | 24       | 囧仙        |
| 5    | 77       | dqstz  |
| 6    | 15078    | 寻逍遥2006       |
| 7    | 211      | liqingyang        |
| 8    | 6796     | liqingyang |

如有你的解法行数**严格小于**榜中行数，请联系 @[yzy1](/user/207996) 把你的成绩放到排行榜上。

---

题目 ACP 有两层意思：**A**ncient **C**omputer **P**rogram 和 **A**nother **C**onstruct **P**roblem。

在 1951 年，第 -32 届全国青少年信息学奥林匹克冬令营前夕，小 A 借助时空传输接口（**T**ime **T**ransport **I**nterface）连接了一台 2015 年的计算机，获取到了第 32 届冬令营的题目来练习。

他打开了第三题「未来程序」这道题目：

> 本题是一道提交答案题，一共 10 个测试点。  
> 对于每个测试点，你会得到一段程序的源代码和这段程序的输入。你要运行这个程序，并保存这个程序的输出。  
> 遗憾的是这些程序都效率极其低下，无法在比赛的 5 个小时内得到输出。

小 A 想了一下，决定用 1951 年的计算机来试着运行这个题目。但是因为 1951 年的电脑存储空间过小，导致他无法传输题目附件和数据，请你帮助小 A 写 std 造数据。


## 题目描述

**这是一道提交答案题。**

小 A 的古董计算机使用两个 $64$ 位无符号整数的栈 $S_0$ 和 $S_1$ 来存储数据。每个栈中初始存储着 $10^{10^{10}}$ 个 $0$。

为了表述方便，下文中记「$T_x$」表示栈 $S_x$ 的栈顶元素。记符号 「$\And$」「$\mid$」「$\oplus$」分别为按位与、按位或、按位异或运算。

这台计算机支持 $8$ 种汇编指令，若没有特殊说明，以下指令的参数均为整数。

| 名称                 | 参数                     | 说明                                                         | 伪代码                                                       |
| -------------------- | ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| $\textbf{and}\ i$ | $i \in [0,1]$            | 令 $T_i$ 为 $T_i$ 与另一个栈的栈顶数字按位与的结果。         | $T_i \gets T_i \operatorname{\And} T_{i \oplus 1}$           |
| $\textbf{or}\ i$  | $i \in [0,1]$            | 令 $T_i$ 为 $T_i$ 与另一个栈的栈顶数字按位或的结果。         | $T_i \gets T_i \mid T_{i \oplus 1}$                          |
| $\textbf{xor}\ i$    | $i \in [0,1]$            | 令 $T_i$ 为 $T_i$ 与另一个栈的栈顶数字按位异或的结果。       | $T_i \gets T_i \oplus T_{i \oplus 1}$                        |
| $\textbf{lsh}\ i\ j$ | $i \in [0,1],j\in[0,64]$ | 令 $T_i$ 为 $T_i$ 左移 $j$ 位的结果，自然溢出。   | $T_i \gets T_i \times 2^j \bmod 2^{64}$                      |
| $\textbf{rsh}\ i\ j$ | $i \in [0,1],j\in[0,64]$ | 令 $T_i$ 为 $T_i$ 右移 $j$ 位的结果，自然溢出。   | $T_i \gets \lfloor \dfrac{T_i}{2^j} \rfloor$                 |
| $\textbf{not}\ i$    | $i\in[0,1]$              | 令 $T_i$ 为 $T_i$ 按位取反的结果。                           | $T_i \gets (2^{64}-1)-T_i$                            |
| $\textbf{pop}\ i$    | $i\in[0,1]$              | 将栈 $S_i$ 的栈顶元素出栈。                                  | $\text{Remove top element of }S_i$                           |
| $\textbf{mov}\ i$    | $i\in[0,1]$              | 将 $T_i$ 出 $S_i$ 栈，然后将其入另一个栈。即移动 $T_i$ 至 $S_{i \oplus 1}$。 | $\text{Push}\ T_i\text{ to }S_{i\oplus 1};\ \textbf{pop}\ i$ |

你需要使用这些汇编指令实现若干计算任务，每个测试点对应一个单独的计算任务。下文中「输入 $a_1, a_2, \cdots$」表示将 $a_1,a_2,\cdots$ 这几个整数**依次**压入 $S_0$ 栈，而两栈栈底的 $0$ 不做变动。**若无特殊说明，输入的数均为 $\mathbf{[0,2^{64}-1]}$ 范围内的整数。**「输出 $x_1, x_2, \cdots$」表示指令运行结束后会从 $S_1$ 中**依次**取出若干个整数作为 $x_1,x_2,\cdots$ 来检验结果是否正确。除此之外，对于 $S_0$ 栈中所有的数和 $S_1$ 栈中**没有**被取出的数在指令运行结束后可以为任意值。

1. 输入 $a, b$，输出 $b,a$。即将两数交换。
1. 输入 $a,b$，输出 $(a-b+2^{64}) \bmod 2^{64}$。即求两数之差，自然溢出。
1. 输入 $a_1, a_2,\cdots,a_9;a_i\in[48,57]$，即 $a_i\in[\mathtt{'0'}, \mathtt{'9'}]$。将 $a_1\sim a_9$ 视为一个 ASCII 编码下的长度为 $9$ 的字符串，你需要将这个字符串**前后翻转后**转化为一个对应的十进制整数并输出。即实现一个快读。特别的，字符串中可能会有前导零。
1. 输入 $a$，输出 $(\operatorname{popcnt}a) \bmod 2$。其中 $\operatorname{popcnt} x$ 代表 $x$ 的二进制表示法中 $1$ 的个数。
1. 输入 $a,b$，输出 $\min\{a,b\}$。
1. 输入 $a,b,p$，满足 $p$ 为 $2$ 的非负整数次幂或零。输出 $(a\times b) \bmod p$。特别地，当 $p=0$ 时输出 $0$。
1. 输入 $a$，满足 $a$ 和答案都是 $2$ 的非负整数次幂或零，输出 $\sqrt a$。
1. 输入 $a,b;1\le a,b \le 63$，输出 $\gcd(a,b)$，即 $a,b$ 的最大公因数。

## 说明/提示

### 样例说明

上述「样例组 $1\sim 8$」代表 $1\sim8$ 子任务的样例输入输出。「样例组 $9\sim10$」为示例问题的一种最短的程序实现。

---

### 评分方法

下面用 `*` 代表测试点编号。如果你提交的指令（`*.out`）没有正确完成计算得零分，否则设你使用的指令个数为 $cnt$，若 `*.ans` 中有 $x$ 个 $\ge cnt$ 的数，你该测试点得 $x$ 分。

---

### 注意

虽然我们允许你提交最多 $999999$ 行的指令，但是由于洛谷对于 checker 的运行时间有限制，你的指令长度被强行加上了一个奇怪的上限：约是 $2\times 10^5$，超过这个长度的指令可能会因为 checker 超时而导致 UKE。

由于洛谷提交答案题的特性，如果你不会做一些 task，请在压缩包内放一个空的 `*.out` 文件占位，其中 `*` 代表 task 编号。否则你的整道题可能会出现答案错位（比如 `2.out` 交到了 $1$ 号测试点）的情况，导致后面的测试点变成零分。

## 样例 #1

### 输入

```
123456789
2147483648```

### 输出

```
2147483648
123456789```

## 样例 #2

### 输入

```
2147483647998244353
9982443532147483647```

### 输出

```
10611784189560312322```

## 样例 #3

### 输入

```
51
53
51
52
52
50
56
57
57```

### 输出

```
998244353```

## 样例 #4

### 输入

```
233456```

### 输出

```
1```

## 样例 #5

### 输入

```
2147483647998244353
9223372036854775808```

### 输出

```
2147483647998244353```

## 样例 #6

### 输入

```
2147483647998244353
9982443532147483647
9223372036854775808
```

### 输出

```
7806477557104029183```

## 样例 #7

### 输入

```
4611686018427387904
```

### 输出

```
2147483648```

## 样例 #8

### 输入

```
24 32```

### 输出

```
8```

## 样例 #9

### 输入

```
输入 a，b。输出 a 按位异或 b 的结果。```

### 输出

```
mov 0
xor 1```

## 样例 #10

### 输入

```
没有输入，输出数字 6。```

### 输出

```
not 1
lsh 1 62
rsh 1 61```

# 题解

## 作者：littleKtian (赞：17)

upd on 2021.9.20：得到了一种新的加减法做法。

upd on 2021.8.19：对 4 和 6 的做法进行了小修改。

------------

[题目](https://www.luogu.com.cn/problem/P7827)。

$8$ 个点各使用的操作次数：$5,194,1140,24,81,19931,257,8705$。

------------
### task 1

我估计大部分人上来看到交换第一时间想到的是这个：`int t=x;x=y,y=t;`

但这里没有直接对任意变量赋值的操作，所以这种想法没啥用。

实际上对于两个整数的交换我们还有另一种异或的做法：`x^=y,y^=x,x^=y;`

手玩一下很容易证明这是对的，所以利用异或操作就能做到 $5$ 步内了。

### task 2

我们先考虑如何计算 $a+b$。

令 $a'=a \operatorname{xor} b,b'=(a \operatorname{and} b)\times 2$，可以发现 $a+b=a'+b'$。

不断重复上面的操作，可以发现每次 $b$ 在 $2$ 进制下的最低位一定是在不断升高的，所以最多重复 $64$ 次 $b$ 就会变成 $0$，此时 $a$ 就是结果。

考虑 $a-b$。一种方法是先对 $b$ 取反得到 $b'$ 然后计算 $a+b'+1$（利用取反和右移操作可以得到 $1$）。另一种是先对 $a$ 取反得到 $a'$，计算 $a'+b$ 后再次取反即可得到 $a-b$。因为这个数据点的操作次数并没有卡的很死所以两者均可。

~~场上脑抽了以为不能直接得到 $1$ 所以写的第二种。~~

实际上减法还有一种直接做的做法（而且比加法还要短很多）：

考虑到二进制下的异或不仅在一定情况下和加法类似 $(0\operatorname{xor}1=0+1=1)$，也在某些情况下和减法类似 $(1\operatorname{xor}1=1-1=0)$，所以依然考虑从异或入手。

记 $c=a \operatorname{xor} b,x=a \operatorname{and} c,y=b \operatorname{and} c$，显然有 $a-b=x-y$ 和 $c=x+y$。

于是 $a-b=(x+y)-y\times2=c-y\times 2$，由上面同理可发现最多重复 $64$ 次操作就能使 $b$ 变为 $0$。

这个做法比上面最好的一点就是不需要再留空间存贮某些中间值，可以直接覆盖掉，所以会少掉很多中间移动变量的操作（实际上这个做法单次只需要 $3$ 步）。

当然也可以结合上面提到的取反的思想反过来实现加法。

### task 3

快读有一个比较经典的写法：`x=(x<<1)+(x<<3)+(ch^48)`，我们可以直接利用左移、异或以及之前的加法操作求出结果。

注意到每一步后的答案范围远小于 $2^{64}$，所以我们可以计算出每步操作后当前结果的最大范围来大幅减小每轮加法操作的重复次数，从而卡进要求的操作次数内。

### task 4

$(\operatorname{popcnt} a+\operatorname{popcnt} b) \bmod 2=\left(\operatorname{popcnt} (a\operatorname{xor} b)\right)\bmod 2$，所以我们每次讲 $x$ 拆成两部分异或起来直到剩下最后一位即可。

注意过程中可以不对前面位置清零，最后一次性清零来减小操作次数，另外最后一轮操作和前面略有不同（用来卡操作次数），需要微调。

另外过程中可以不使用右移而使用左移来把操作次数卡到 $24$（因为这样最后只需要一次右移，如果中间使用的是右移那么最后是需要一次左移和一次右移的）。

### task 5

首先我们默认 $a\neq b$，然后再考虑在 $a=b$ 时能不能正常工作。

求 $\min$ 的第一想法就是将两者逐位比较，所以我们会想到先将两者异或，求出异或结果中最高位的 $1$ 属于谁。

我们可以将 $a$ 跟异或的结果进行一次与运算，然后利用右移进行填充（可以利用倍增的思路来减小操作次数），使得与运算的结果从最高位的 $1$ 开始右边所有位置都被 $1$ 填满。

然后我们将其取反并再和之前异或的结果进行一次与运算，得到结果记为 $t$。此时如果得出的 $t=0$，那么说明最高位的 $1$ 是来自 $a$ 的，从而得出 $a>b$，否则反之。

再利用左移和右移将 $t$ 填充满（此时 $t$ 必定为 $0$ 或 $2^{64}-1$），对 $a$ 进行与运算。容易发现如果 $a>b$ 那么得到的结果就是 $0$，否则就是 $a$。

将 $t$ 取反后再对 $b$ 进行与运算，两次的结果进行或运算即可求出 $\min$。

最后检验一遍发现上面在 $a=b$ 时同样可以正常工作，所以直接按上面思路来即可。

### task 6

~~tm 搞个 $p=0$ 是个什么鬼。~~

考虑分成 $a\times b$ 和 $\bmod p$ 两部分处理。

因为我们已经有加法操作了，所以我们考虑对其中一个数从低到高拆位，从而将乘法分解成加法和 $\times 2$。这里建议对 $a$ 拆位。

问题变成如何判断对于每一位是否需要进行加法。

我们同样可以利用左移或右移来将这位的结果填满所有二进制位（也就是利用操作使得如果这位是 $1$，最后就会得到 $2^{64}-1$；如果是 $0$，最后就会得到 $0$）。完成上面操作后直接将所得的数对 $b$ 进行与运算即可得到这轮需要加上的数。

然后我们考虑取模。

因为模数是 $2$ 的非负整数次幂，所以我们可以利用与运算来取模。和上面类似，通过若干次右移和或运算得到用来进行与运算的数，将之前的结果和这个数进行与运算即可得到结果。

注意每次拆位完之后最好直接对当前位进行运算，这样不需要存贮结果，可以减少中间移动变量时的操作次数。另外因为过程中每次会对 $b\times 2$，这就意味着 $b$ 的最低位是不断升高的，可以利用这个来减小加法操作的重复次数。

### task 7

由题目条件可知 $a$ 必然为 $2$ 的偶数次幂或 $0$，直接每次取出两位即可。

### task 8

令 $a'=\min(a,b),b'=\max(a,b)$，有 $\gcd(a,b)=\gcd(a',b'-a')$。

通过 2 和 5 我们已经有了减法和求 $\min/\max$ 的操作（$\max$ 的操作可以直接在求 $\min$ 上稍作修改），直接套用即可。

另外实际上我们并不需要在这个点每轮重复 $64$ 次减法操作。因为 $a,b\leq 63$，所有计算结果都在 $2^6$ 内，所以只需要重复 $6$ 次即可。

代码（针对 task 8，不过里面也有其他 task 可能需要的操作的）：

```cpp
#include<bits/stdc++.h>
using namespace std;
void swa(){printf("xor 1\n"),printf("xor 0\n"),printf("xor 1\n");}//交换两个栈的栈顶 
void sub(){printf("xor 0\n"),printf("and 1\n"),printf("lsh 1 1\n");}
int main()
{
	freopen("8.out","w",stdout);
	for(int tt=0;tt<64;tt++)
	{
		printf("xor 1\n"),printf("mov 0\n");
		printf("xor 0\n"),printf("xor 1\n"),printf("mov 0\n");
		printf("xor 0\n"),printf("mov 1\n");
		printf("and 0\n");
		printf("mov 0\n"),swa(),printf("mov 0\n");
		for(int i=0;i<6;i++)
		{
			printf("or 0\n");
			printf("rsh 0 %d\n",(1<<i));
			if(i==5)printf("or 0\n");else printf("or 1\n");
		}
		printf("pop 1\n");
		printf("not 0\n"),printf("and 0\n");
		printf("rsh 1 64\n");
		for(int i=0;i<6;i++)
		{
			printf("or 1\n");
			printf("rsh 1 %d\n",(1<<i));
			printf("or 0\n");
		}
		for(int i=0;i<6;i++)
		{
			printf("or 1\n");
			printf("lsh 1 %d\n",(1<<i));
			printf("or 0\n");
		}
		//以上为5时取min操作主体部分，后面为针对8调整的部分
		printf("rsh 1 64\n"),printf("or 1\n");
		printf("mov 0\n"),printf("xor 0\n");
		printf("mov 0\n"),printf("xor 0\n");
		printf("mov 1\n"),printf("mov 1\n"),printf("mov 1\n");
		//左：4个t 右：a,b（从上到下） 
		printf("and 0\n"),swa(),printf("mov 0\n");
		printf("not 0\n"),printf("and 0\n"),printf("pop 1\n");
		printf("mov 1\n"),swa();
		printf("mov 0\n"),swa(),printf("mov 0\n");
		printf("and 0\n");
		swa(),printf("mov 0\n");
		printf("not 0\n"),printf("and 0\n"),printf("pop 1\n");
		printf("mov 1\n");
		//此时两栈栈顶从上往下第一个元素更新max，第二个元素更新min 
		printf("or 0\n"),printf("pop 1\n");
		swa(),printf("mov 0\n");
		printf("or 0\n"),printf("or 1\n");
		printf("mov 1\n"),swa();
		for(int i=0;i<6;i++)sub();
	}
	printf("mov 0\n");
}
```

---

## 作者：yzy1 (赞：11)

## Task 1

交换 $a,b$ 两数。

三次异或解决。

```cpp
void Swap() { Xor(1), Xor(0), Xor(1); }
```

## Task 2

求 $a-b$，自然溢出。

由于负数在计算机内部以补码存储，所以 $a-b=a+(-b)=a+ (\sim b+1)$。这个问题就被转化成了 A+B Problem。我们可通过异或和与运算来模拟二进制进位加法。由于本题的整数是 $64$ 位的，所以我们最多进位 $64$ 次。

```cpp
void Add(int x, int cnt) {
  re(_, cnt) {
    Mov(x ^ 1);
    Xor(x ^ 1);
    Mov(x);
    And(x ^ 1);
    Lsh(x ^ 1, 1);
    Mov(x ^ 1);
    Swap();
    Mov(x);
    Xor(x);
    Pop(x ^ 1);
  }
  Pop(x ^ 1);
}

void Fu(int x) {
  Not(x);
  Not(x ^ 1);
  Rsh(x ^ 1, 63);
  Add(x, 64);
}

void St2() {
  Fu(0);
  Mov(0);
  Add(1, 64);
}
```

## Task 3

实现十进制整数快读。

既然我们已经实现加减法了，就可以写一个快读了。但是如果直接暴力减 $48$，暴力做十次加法当乘法的话，汇编指令长度会超限。这里有两个小技巧。

1. 当计算减 `0` 的 ASCII 码（即 $48$）的时候，我们发现 $[48,57]$ 内的整数在与 $48$ 做二进制减法时都不会「退位」。所以我们可以用一次异或运算来代替减法。
2. 在计算乘 $10$ 时，我们可以把 `x*=10` 转化为 `x+=x<<2;x<<1`。这样可以尽可能的减少加法运算。

```cpp
void St3() {
  int n = 9;
  re(i, n) {
    Not(1);
    Lsh(1, 62);
    Rsh(1, 58);  // 48
    Xor(0);      // -48
    Pop(1);
    if (i != 1) {
      Add(0, ceil(log2(2 * pow(10, i - 1))));
    }
    if (i != n) {
      // x*=10 -> x+=x<<2;x<<1
      Xor(1);
      Lsh(0, 2);
      Add(0, ceil(log2(pow(10, i))));
      Lsh(0, 1);
      Swap();  // 让最顶上变成 0
      Mov(0);
    }
  }
  Mov(0);
}
```

## Task 4

求 $(\operatorname{popcnt}x) \bmod 2$。

考虑二分，`x^=x>>32, x^=x>>16, x^=x>>8, ..., x^=x>>1`。答案为 $x \bmod 2$。

```cpp
void St4() {
  for (int i = 32; i; i >>= 1) {
    Xor(i == 32);
    Rsh(0, i);
    Xor(1);
    Pop(0);
  }
  Lsh(1, 63);
  Rsh(1, 63);
}
```

## Task 5

求 $\min\{a,b\}$。

考虑异或运算的性质。设 $t=a\oplus b$，则 $t$ 正好是 $a$ 与 $b$ 中**零一不同**的位。而将 $t\And a$ 得到的结果是这些不同的位中哪些位 $a$ 为 $1$。同理，$t\And a$ 得到哪些位 $b$ 为 $1$。我们只要比较 $t\And a$ 和 $t \And b$ 的大小关系，就可以得出 $a$ 和 $b$ 的大小关系。考虑拼一个运算符 $\operatorname{hibFill} x$。它的作用是将 $x$ 的第一个 $1$ 后的位全填充为 $1$。这样的话如果 $\operatorname{hibFill}(t\And a)\And \operatorname{hibFill}(t \And b)$ 不为零，则 $a>b$，否则 $a<b$。$\operatorname{hibFill}$ 的实现利用倍增思想，类似于 Task 4，只不过将左移改成了右移。具体实现请参考代码。

但是这样会略微有些超出指令长度范围，我们需要优化一下。可以发现 $t$ 与 $b$ 的运算是不必要的。我们可以直接比较 $t$ 的最高位是否在 $a$ 中，如果在则 $a>b$，否则 $a<b$。由于这题要求输出的是 $a,b$ 中较小者，所以我们怎么处理 $a=b$ 的情况都可以。

剩下的事情就好办了，考虑拼一个 $\operatorname{if}(con,a,b)$ 运算符，它的作用类似于 C++ 中的 `if(con)return b;else return a`。这样我们就能求出答案了。

```cpp
// 将第一个 1 后的位全填充为 1
void HibFill(int x) {
  for (int i = 32; i; i >>= 1) {
    Xor(x ^ 1);
    Rsh(x ^ 1, i);
    Or(x);
    Pop(x ^ 1);
  }
}

// 两数都在 S[0]
// pop S[0] 的两数并将比较结果放在原位置
// 输入 [b a] 输出 [a<b]
void Cmp() {
  Xor(1);  // [a b] [b]
  Mov(0);  // [a] [b b]
  Xor(1);  // [a] [b t]
  Mov(1);  // [a t] [b]
  Swap();  // [a b] [t]
  Mov(1);  // [a b t] []
  HibFill(0);
  Xor(1);
  Rsh(1, 1);
  Xor(0);
  Pop(1);  // [a b t] []
  Mov(0);  // [a b] [t]
  Pop(0);
  And(0);
  Pop(1);  // [a] []
  HibFill(0);
  for (int i = 1; i <= 32; i <<= 1) {
    Or(1);
    Lsh(1, i);
    Or(0);
  }
  Pop(1);
}

// [a b con]
// 输入至 S_x，pop x, pop x，输出至 S_x^1
// if(con) b; else a
void If(int x) {
  Mov(x);      // [a b] [con]
  Swap();      // [a con] [b]
  And(x ^ 1);  // [a con] [b&con]
  Not(x);      // [a !con] [b&con]
  Mov(x);      // [a] [b&con !con]
  And(x);      // [a&!con] [b&con !con]
  Pop(x ^ 1);  // [a&!con] [b&con]
  Or(x ^ 1);
  Pop(x);
}

void St5() {
  Xor(1);  // [a b] [b]
  Mov(0);  // [a] [b b]
  Mov(0);  // [] [b b a]
  Xor(0);  // [a] [b b a]
  Mov(1);  // [a a] [b b]
  Swap();  // [a b] [b a]
  Mov(1);  // [a b a] [b]
  Mov(1);  // [a b a b] []
  Cmp();
  If(0);
}
```

## Task 6

求 $a \times b \bmod p$。

我们现在有加法，有 `if`，我们就可以搞一个乘法了。由于 $a,b$ 的范围都在 `unsigned long long` 级别，我们考虑一个类似于快速幂的「快速乘」：

```cpp
(伪代码)
int ans=0;
for i=1...64 {
  if(a&1) ans+=b;
  a>>=1;
  b<<=1;
}
return ans;
```

仿照快速幂的思想，设 $b=2^{i_1}+2^{i_2}+\cdots+2^{i_k}$，根据乘法分配律，将 $a\times b$ 拆分成 $a\times 2^{i_1}+a\times 2^{i_2}+\cdots+a\times 2^{i_k}$。复杂度 $O(\log b)$。但是因为只能同时操纵两个栈的栈顶元素，我们需要不断的 `Swap()`。实际写起来有点麻烦。由于模数是 $2$ 的整数次幂，我们可以先自然溢出，最后再取模。

```cpp
// 乘法
// 在 S0 上输入 0,a,b; (pop 0)*3; out to S1
void Mul(int x, int cnt) {
  // [0 a b] []
  Xor(x ^ 1);  // [0 a b] [b]
  Mov(x);      // [0 a] [b b]
  Swap();      // [0 b] [b a]
  Mov(x ^ 1);  // [0 b a] [b]
  Swap();      // [0 b b] [a]
  re(k, cnt) {
    // [ans b b] [a]
    Mov(x ^ 1);
    Xor(x ^ 1);  // [ans b b a] [a]
    Mov(x ^ 1);
    Not(x ^ 1);
    Rsh(x ^ 1, 63);  // [ans b b a a] [1]
    And(x);
    Pop(x ^ 1);  // [ans b b a a&1] []
    for (int i = 1; i <= 32; i <<= 1) {
      Or(x ^ 1);
      Lsh(x ^ 1, i);
      Or(x);
    }
    Pop(x ^ 1);
    Mov(x);
    Mov(x);
    // [ans b b] [f a]
    Swap();      // [ans b a] [f b]
    Mov(x ^ 1);  // [ans b a b] [f]
    Swap();      // [ans b a f] [b]
    Mov(x ^ 1);  // [ans b a f b] []
    Mov(x);
    Mov(x);
    Mov(x);
    Mov(x);      // [ans] [b f a b]
    Swap();      // [b] [b f a ans]
    Mov(x ^ 1);  // [b ans] [b f a]
    Swap();      // [b a] [b f ans]
    Mov(x ^ 1);  // [b a ans] [b f]
    Swap();      // [b a f] [b ans]
    Mov(x ^ 1);  // [b a f ans] [b]
    Swap();      // [b a f b] [ans]
    Mov(x ^ 1);
    Xor(x ^ 1);  // [b a f b ans] [ans]
    Mov(x);      // [b a f b] [ans ans]
    Swap();      // [b a f ans] [ans b]
    Mov(x ^ 1);  // [b a f ans b] [ans]
    Swap();      // [b a f ans ans] [b]
    Add(x, 64);  // [b a f ans ans+b] []
    Mov(x);      // [b a f ans] [ans+b]
    Swap();
    Mov(x);
    Swap();
    Mov(x ^ 1);
    Swap();
    Mov(x ^ 1);
    Not(x);
    // [b a ans+b ans !f] []
    If(x);
    // [b a] [f?ans+b:ans]
    // [b a] [ans]
    if (k == cnt) {
      Pop(x);
      Pop(x);
    } else {
      Rsh(x, 1);
      Swap();
      Mov(x);
      Swap();
      // [ans] [a b]
      Lsh(x ^ 1, 1);
      Mov(x ^ 1);  // [ans b] [a]
      Swap();      // [ans a] [b]
      Mov(x ^ 1);
      Xor(x ^ 1);  // [ans a b] [b]
      Mov(x);
      Swap();
      Mov(x ^ 1);
      Swap();  // [ans b b] [a]
    }
  }
}

void St6() {
  Xor(1);
  Rsh(0, 64);
  Mov(0);
  Mov(0);
  Mov(0);
  Mul(1, 63);
  Mov(1);
  Rsh(0, 1);
  LowbitFill(0);
  Mov(0);
  And(1);
}
```

## Task 7

求 $\sqrt a$，满足答案是 $2$ 的整数次幂。

手推一下发现只有输入 $a$ 是 $2^0, 2^2, 2^4$ 等 $2$ 的偶数次方时才有合法答案。且 $a=2^k$ 时答案一定是 $2^{k/2}$。两位两位左移并判断即可。

```cpp
void St7() {
  ste(k, 0, 62, 2) {
    Not(1);
    Rsh(1, 63);
    Lsh(1, k);
    And(1);  // [a] [ans 1<<k]
    Rsh(1, k / 2);
    Mov(1);  // [a 1<<k/2] [ans]
    Or(1);
    if (k != 62) {
      Mov(0);
      Rsh(1, 64);  // [a] [ans 0]
    }
  }
}
```

## Task 8

求 $\gcd(a,b)$。

$\gcd(a,b)=\gcd(\max\{a,b\}-\min\{a,b\},\min\{a,b\})$。不断求最大最小值并相减，直到其中一数为 $0$。最差情况发生在 $a=63,b=1$ 时，需要减 $62$ 次。

```cpp
void St8() {
  int n = 62;
  re(k, n) {
    Xor(1);
    Mov(1);  // [a b b] []
    Xor(1);
    Mov(0);  // [a b] [b b]
    Mov(0);  // [a] [b b b]
    Mov(0);
    Xor(0);  // [a] [b b b a]
    Mov(1);  // [a a] [b b b]
    Xor(1);  // [a a] [b b a^b]
    Swap();  // [a a^b] [b b a]
    Mov(0);
    Swap();  // [a^b] [b b a a]
    Mov(1);
    Mov(1);  // [a^b a a] [b b]
    Swap();  // [a^b a b] [b a]
    Mov(1);
    Mov(1);  // [a^b a b a b] []
    Cmp(0);  // [a^b a b f]
    If(0);   // [a^b] [min]
    Xor(0);  // [max] [min]
    Mov(1);
    Xor(1);  // [max min] [min]
    Mov(1);
    Fu(0);  // [max min -min] []
    Mov(0);
    Swap();     // [max -min] [min]
    Mov(0);     // [max] [min -min]
    Add(1, 6);  // [] [min max-min]
    Not(0);
    Rsh(0, 58);
    And(1);
    Pop(0);
    Mov(1);
    if (k == n)
      Or(1);
    else
      Mov(1);
  }
}
```

---

## 作者：dehsirehC (赞：5)

## 前言

联考要讲这题，所以写了篇题解。~~然后太菜了做了一两天才做出来。~~

## 测试点 $1$

交换两个数 $a,b$ 的一种方式为： `a^=b^=a^=b` 。直接暴力操作即可 $5$ 次完成。

## 测试点 $2$

首先不难想到先将 $a$ 取反，算出 $a+b$ 后再取反即为所求。因为 $2^{64}-1-(b+(2^{64}-1-a))=a-b$ 。

想到经典的形式： $a+b=2(a\ \&\ b)+(a\oplus b)$ ，因为 $a\ \&\ b$ 为 $1$ 的位就相当于进位的位，其余位均不进位。

由于对 $2^{64}$ 取模，而 $a$ 每次变为 $2(a\ \&\ b)$ ，即末尾 $0$ 的个数至少增加一个，也就是只需执行 $64$ 次如上变换。

由于求得 $a\ \&\ b$ 或 $a\oplus b$ 之一无法推得另一个，故需要复制一遍 $a$ 或 $b$ 再交换过去，常数很大。

~~由于你要拿最优解~~，又发现最优解常数只有 $3$ ，故基本可以排除该做法，考虑直接在减法上思考。

继续考虑减法的经典形式： $a-b=(a\oplus b)-2(((2^{64}-1)\oplus a)\ \&\ b)$ 。

如果直接做的话常数依旧非常大，考虑改一下 $(((2^{64}-1)\oplus a)\ \&\ b)$ ，即改成 $(a\oplus b)\ \&\ b$ 。

现在常数成功变成了 $3$ ，稍加优化可以拿到最优解。通过类似第一行的变换可以将减法转化成加法。

## 测试点 $3$

根据经典快读写法： `x=(x<<1)+(x<<3)+(ch^48)` ，直接运用 `测试点2` 的加法即可。

直接加的话常数太大，发现值域非常小，可以默认对 $2^k$ 取模，最后移一下位即可减少非常多操作。

~~由于卡不满，可以适量减少减法递归的次数，这样就可以超过最优解。~~不大清楚当前最优解怎么做的。

## 测试点 $4$

发现可以每次将后半部分和前半部分异或，此时答案不变。

由于每次值域开根，故只需要进行 $6$ 次上述操作，再稍微优化一下即可拿到最优解。

## 测试点 $5$

由于限制很紧，不大能拆位做，考虑整体运算。

先将 $a,b$ 异或一下，第一个为 $1$ 的位是比较大小的关键，考虑将它提出来。

提出来的方式就是让它不断右移然后或，此时 $1$ 扩散到后面所有位，此时再右移异或即可。

然后提取出来 $a$ 或 $b$ 的那一位，分 $0$ 或 $1$ 讨论一下再将 $1$ 扩散到 $2^{64}-1$ 再或上即可。

## 测试点 $6$

考虑先将 $a\times b$ 在模 $2^{64}$ 意义下的值算出来，再对 $p$ 取模。

考虑将乘法拆成若干次加法，即提取出来某一位 $b$ 是 $0$ 还是 $1$ 再将 $1$ 扩散到 $2^{64}-1$ 。

此时让扩散后的数或上 $a$ 再左移若干位加上当前答案。操作次数为 $64\times 64\times 3$ 左右。

现在考虑如何对 $p$ 取模，直接将 $p$ 右移一位再将那个 $1$ 扩散到后面再与上答案即可。

## 测试点 $7$

一个初始的思路是将 $p$ 的那个 $1$ 扩散到后面再拿 $11$ 不断与上它再左移右移和异或。

具体的，由于直接扩散会有奇数个 $1$ ，故考虑先左移一位再扩散。

提出来 $1$ 的个数除以 $2$ 个 $11$ ，然后让它们依次异或起来，最后再右移一位即可。

## 测试点 $8$

根据经典结论： $\gcd(a,b)=\gcd(\max(a,b)-\min(a,b),\min(a,b))$ 。

每次找一下最大值和最小值，这两个可以合并一起求，然后再调用减法不断递归即可。

注意值域比较小可以节省非常多的操作次数，而总共要递归差不多值域那么多次。

---


# [OOI 2024] Burenka and Pether

## 题目描述

曾几何时，Burlyandia 的公主 Burenka 决定让她的朋友 ReLu 开心一下。她知道 ReLu 也热衷于加密货币，于是 Burenka 决定创立属于自己的区块链加密货币，命名为 **Pether**。

在接受了一位个人成长与网络安全领域专家的课程培训后，Burenka 决定要让 **Pether** 拥有最强的安全保护。结果，由于极其复杂且曲折的限制，并非所有用户都可以互相转账 **Pether**。

**Pether** 区块链的结构确实复杂且曲折。所有用户编号为 $1$ 到 $n$。每个用户都分配有一个**唯一**的标识符 $a_i$。此外，货币系统还设定了一个安全参数 $d$。

用户 $i$ 只有在 $i < j$ 且 $a_i < a_j$ 时，才能直接给用户 $j$ 转账。但这还不够！用户之间的直接转账还需要经过若干中间用户组成的交易链。在每一步交易中，每个后续中间用户（包括最终的 $j$）的编号都必须递增，且每次编号增加不能超过 $d$。此外，除 $i$ 和 $j$ 之外的所有中间用户，其标识符必须**严格小于** $a_i$。

更正式地说，用户 $i$ 能否直接向用户 $j$ 转账，需要满足以下条件：
- $i < j$
- $a_i < a_j$
- 存在一组长度为 $k$ 的中间用户序列 $x$，使得：
   - $i = x_1 < x_2 < \ldots < x_{k-1} < x_k = j$
   - 对所有 $1 \le t \le k-1$，有 $x_{t+1} - x_t \le d$
   - 对所有 $2 \le t \le k-1$，有 $a_{x_t} < a_i$

Burenka 现在请你这位熟悉编程的朋友，帮她理解这个系统，并判断一些用户对之间能否转账 **Pether**。

你需要回答 $q$ 个询问。每个询问给定一对用户，询问是否存在一条（可能经过中间用户的）直接转账路径，使得可以从 $u_i$ 转账到 $v_i$。部分询问还要求**最小化**转账次数（即最少经过多少次直接转账，从 $u_i$ 到 $v_i$）。注意，在每次直接转账的实现过程中，不要求最小化中间用户数。

## 说明/提示

### 说明

在第一个样例中，用户之间的直接转账关系如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/znmqxem4.png)

第一个询问中，用户 $1$ 可通过用户 $2$ 作为中间人，经过 $2$ 次直接转账，将 **Pether** 转给用户 $3$。

第二个询问，用户 $1$ 无法直接转账给用户 $2$，因为 $a_1 = 2 > a_2 = 1$。

第三个询问，$1 \rightarrow 3 \rightarrow 4$，共 $2$ 次直接转账即可到达。因 $t_3 = 1$，只需判断可达性，输出 $1$。

第四个询问，可以 $1 \rightarrow 3 \rightarrow 4 \rightarrow 5$，共 $3$ 次直接转账。

第二个样例中，直接转账关系如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/zzagqjxa.png)

第三个样例中，直接转账关系如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/uj5b2pnx.png)

### 计分方式

本题共十二组测试。只有通过该组及其所有依赖组全部测试，才能获得该组分数。部分组不要求通过样例测试。**Offline-evaluation** 表示该组结果仅在赛后可见。

| 组别 | 分值 | 额外约束 | $n$ | $q$ | $v_i, a_n, t_i$ | 依赖组 | 备注 |
|:-----:|:------:|:----------------------:|:-:|:-:|:------:|:---------------:|:-------:|
| 0 | 0 | -- | -- | -- | -- | -- | 样例。 |
| 1 | 10 | $n \le 100$ | $q \le 100$ | -- | -- | |
| 2 | 7 | $n \le 1000$ | -- | -- | 1 | |
| 3 | 14 | -- | -- | $a_n = n, v_i = n$ | -- | |
| 4 | 10 | -- | $q = 1$ | $v_i = n$ | -- | |
| 5 | 9 | -- | -- | $v_i = n$ | 3, 4 | |
| 6 | 7 | -- | -- | $t_i=2$ | -- | 答案不超过 $10$ |
| 7 | 7 | -- | -- | $t_i=2$ | 1, 6 | 答案不超过 $150$ |
| 8 | 13 | -- | -- | $t_i = 1$ | -- | |
| 9 | 10 | $n \le 50\,000$ | $q \le 50\,000$ | -- | 1 | |
| 10 | 4 | $n \le 100\,000$ | $q \le 100\,000$ | -- | 1, 9 | |
| 11 | 4 | $n \le 200\,000$ | $q \le 200\,000$ | -- | 1, 9, 10 | |
| 12 | 5 | -- | -- | -- | 0--11 | **Offline-evaluation.** |

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
6 1 0
2 1 3 4 5 6
6
2 1 3
2 1 2
1 1 4
2 1 5
2 1 6
1 2 6```

### 输出

```
1
0
1
3
4
1```

## 样例 #2

### 输入

```
6 2 0
1 2 3 4 5 6
6
2 1 5
2 2 5
2 1 6
2 2 6
2 1 4
2 2 4```

### 输出

```
2
2
3
2
2
1```

## 样例 #3

### 输入

```
10 2 0
2 1 4 3 5 6 8 7 10 9
10
2 1 5
1 2 5
2 3 5
2 1 9
2 5 8
2 3 9
2 1 8
1 1 2
2 3 8
2 1 9```

### 输出

```
2
1
1
4
2
3
3
0
2
4```

# 题解

## 作者：chen_zhe (赞：2)

**这是官方题解的 AI 中文翻译。**

**子任务 1.**

$n, q \leq 100$。在本子任务中，$n$ 和 $q$ 的规模较小，因此可以直接构建跳跃图，并对每个询问独立使用广度优先搜索求最短路。复杂度为 $O(n^2 q)$。

**我们的图的结构**

**说明。** 我们来理解一下图的结构：即可以证明，从顶点 $u$ 出发，有边指向某个区间 $[u, r_u]$ 内所有满足 $a_t > a_u$ 的顶点 $t$。

**证明。** 为此，我们先去掉 $i$ 跳到 $j$ 时的 $a_i < a_j$ 限制（此时跳跃的终点可以任意，关键是能找到一条合法的中间顶点序列）。如果在这种情况下可以跳到某个子区间，那么在原问题中，唯一额外的限制就是 $a_i < a_j$，这正是我们所需的。假设存在一次跳跃 $u \rightarrow v$，那么可以证明一定存在 $u \rightarrow v-1$ 的跳跃。我们找到第一个 $t > v$，证明从 $v$ 可以跳到 $t-1$。到达顶点 $v$ 的路径可以通过某个中间顶点序列实现，设最后一个中间顶点为 $t$，则 $v - t \leq d$，因此要么 $t = v-1$，要么可以利用该序列到达 $v-1$。

**区间的求法**

现在我们学习如何为所有顶点求出 $r_i$。我们按照 $a_i$ 从大到小遍历，并在并查集中维护已“激活”元素的区间。当一个新元素被激活时，可能需要与 DSU 中相邻区间合并。我们还维护所有长度 $\geq d$ 的“长区间”右端点集合。要确定右边界，只需在 $i+d$ 右侧找到最近的“长区间”右端点 $e$，然后设 $r_i := \max(i+1, e - sz_e + 1) + d$，其中 $sz_e$ 是以 $e$ 为右端点的区间长度。这样的转移是正确的，因为所有未激活的元素都比 $a_i$ 小，可以随意跳过，唯一的障碍就是包含 $\geq a_i$ 的“长区间”。

**子任务 2.**

$n \leq 1000$。固定每个询问的第二个顶点。我们按编号递减顺序遍历所有顶点。要更新当前顶点 $u$ 到固定顶点 $v$ 的距离，只需在某个区间上取最小值即可。利用线段树可以高效实现。复杂度为 $O(n^2 \log n + q)$。

**子任务 3.**

$a_n = n, v_i = n$。现在是提出本题一个重要结论的时候了。

**结论。** 对于询问 $(u, v)$，若 $a_v = n$，则从 $u$ 出发，应直接跳到区间 $[u, r_u]$ 上值最大的数。

**证明。** 设该区间最大值为 $x$，而我们实际上跳到了 $y$。之后进行若干次跳跃，考虑首次到达 $q \geq x$ 的时刻：$y \rightarrow t_1 \rightarrow \ldots \rightarrow q$。若 $q = x$，则直接跳到 $q$ 显然更优。若 $pos_y < pos_x$，则到 $q$ 可以利用路径 $y \rightarrow t_1 \rightarrow \ldots \rightarrow q$ 的后缀到达 $x$。若 $pos_y > pos_x$，则存在路径 $u \rightarrow g_1 \ldots \rightarrow g_k \rightarrow y$，可取后缀与 $y \rightarrow t_1 \rightarrow \ldots \rightarrow q$ 拼接，得到 $x \rightarrow g_i \rightarrow \ldots \rightarrow g_j \rightarrow y \rightarrow t_1 \rightarrow \ldots \rightarrow q$，即 $x$ 也能跳到 $q$。因此，直接跳到 $x$ 至少不会比跳到 $y$ 更劣。

这一结论允许我们构建一棵树，使得所有路径均为 $u$ 到 $v$ 的最短路径。跳跃可以用线段树快速找到，查询可用倍增或 dfs 实现。复杂度 $O((n + q)\log n)$。

**子任务 4、5.**

上述结论对 $a_v \neq n$ 也成立，唯一的区别是此时不存在编号大于 $a_v$ 的顶点——从 $a_v$ 无法到达这些点。这个结论其实已经在前面证明过了。

**结论。** 对于询问 $(u, v)$，从 $u$ 出发，应跳到区间 $[u, r_u]$ 内所有 $\leq a_v$ 的最大值 $x$。

因此，本子任务只需构建一棵树并在其上做倍增，即可高效回答所有询问，复杂度 $O((n + q)\log n)$。

**子任务 6、7.**

我们进一步优化：由于跳跃次数不多，可以按照 $v_i$ 升序遍历所有询问，并在最大值上维护一棵线段树。回答每个询问时，只需在某个区间内查询最大值，不超过 $ans$ 次。复杂度 $O(n\log n + q \cdot ans \cdot \log n)$。

**子任务 8.**

本子任务暗示了 $O((n+q)\texttt{polylog}(n, q))$ 的解法。此前我们一直尝试跳到最大值以缩短距离，但本任务并不要求最短路径。

**结论。** 对于询问 $(u, v)$，若不要求距离最短，则可以从 $u$ 跳到区间 $[u, r_u]$ 内严格大于 $a_u$ 的最小值，或直接跳到 $v$。

**证明。** 假设从 $u$ 无法一步跳到 $v$，而存在路径 $u \rightarrow t_1 \rightarrow \ldots \rightarrow v$。我们证明从 $u$ 跳到 $[u, r_u]$ 内大于 $a_u$ 的最小值 $p$ 后，仍可到达 $v$。找第一个 $t > p$，证明从 $p$ 可以到 $t-1$。$t$ 是通过一系列中间顶点到达的，设最后一个中间顶点为 $t$，则 $v - t \leq d$，要么 $t = v-1$，要么可利用该序列到达 $v-1$。

将所有跨越分界线的询问用上述方式处理后，问题被划分为两个独立的子问题。每层递归处理 $O(q\log n)$，总复杂度 $O((n+q)\log^2 n)$，因“分治”递归深度为 $\log n$。

**子任务 9.**

通过前述分析可以发现，数值本身比下标更为关键。我们按 $a_i$ 从大到小排序，分成 $\sqrt{n}$ 大小的块。对于 $(u, i)$ 询问，只需在树上用倍增跳跃，每次跳跃只要能跳到 $\leq a_i$ 的数即可（前面已证明最优）。因此，每次查询倍增次数不超过 $\sqrt{n}$（我们总是跳到树上能到达的最左侧大于 $a_i$ 的元素，再用线段树跳一次即可）。由于“坏点”数量不超过块大小，因而最多倍增 $\sqrt{n}$ 次。

---


# 【模板】快速阶乘算法

## 题目背景

有一天，NaCly_Fish 无意间看到一种高效求阶乘模大质数的算法，但是她太菜，并不会写。  
于是她就暴力造了数据，请您帮忙写出 std 吧。  

什么，您问为什么不保证模数可以 NTT？  
那样的话就可能被打表水过，或者答案就爆 int 了。

反正您是神仙，肯定能秒掉这题。

## 题目描述

给你正整数 $n$，和一个质数 $p$，你需要求出：  
$$ n! \text{ mod } p$$  
有 $T$ 组数据。

## 说明/提示

### 数据范围：  

对于 $10\%$ 的数据：$p = 998244353$   
对于另外 $10\%$ 的数据：$p = 1004535809$   
对于 $100\%$ 的数据：$1\le n < p \le 2^{31}-1$，$1 \le T \le 5$    
保证 $p$ 为质数。

【提示】   
请确保你的算法时间复杂度不高于 $\Theta(\sqrt n \log n)$，时限为 std 的十倍以上。

## 样例 #1

### 输入

```
4
16777216 998244353
72267859 998244353
2333333 19260817
1919810 2147481811```

### 输出

```
789885751
569626621
16351109
1416439247```

# 题解

## 作者：bh1234666 (赞：150)

这是一篇非正解的题解，如想要学习 $O(\sqrt n\log n)$ 的解法请自行略过。

```不需要什么多项式，暴力是可以通过本题的。```

题意：给定 $n,p$,求 $n! \mod p$ 的值。

显然直接做是 $O(n)$ 的。

数据范围~~只~~有 $2^{31}$,题目却提示复杂度小于 $O(\sqrt n\log n)$。但是人家 $O(n^2)$ 都能过百万凭啥我 $O(n)$ 不能过 $2^{31}$。

于是考虑优化 $O(n)$。显然我们不能通过减少乘的次数来卡常，或者说通过某些方法减少乘的次数反而会导致变慢~~或者导致算法变高级~~。

阶乘是一个非常适合循环展开的东西，我们可以把阶乘每 $8$ 个一组分别计算。即分别计算 $1\times 9\times 17\times \dots \times 8k+1$，$2\times 10\times 18\times \dots \times 8k+2 \dots$ 后全部乘起来。

可惜循环展开还是不够快，但是有一个比循环展开更快且更直接的批量操作的东西：**指令集**。

这里我采用了 AVX2 指令集进行优化。AVX2 可以支持高效的 256 位向量运算，也就是可以同时运算 8 个整型。

由于指令集指令过于~~丰富~~复杂，下面只有代码中带有一些对指令的讲解。[这是微软提供的SSE2指令集的说明，与AVX2指令类似。](https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/84t4h8ys(v=vs.90))

AXV2 的一个变量占用 256 位空间，根据不同情况可以当作不同精度的浮点或整型使用，下面主要当作 8 个 int 使用。

它的整型支持大部分的位运算以及加减乘运算，但是不支持除法及取模，因此我们需要自己想办法实现取模。

下面有几种解决方案：

1：通过转换类型实现除法再进行取模。但是受到硬件限制 cpu 的除法运算极其慢，无法采用。

2：通过 barrett 约减实现取模。但是在本题数据范围内使用 barrett 约减将会涉及 AVX2 不支持的 128 位整数的运算，无法采用。

3：通过蒙哥马利约减实现取模。蒙哥马利约减可以仅在 64 位整数范围内完成取模且速度较快，因此我采用了蒙哥马利约减实现本题。

注：

barrett 约减：

对于 $r=z\mod p$ 基于低成本的除法运算获得 $q=[2^k/p]$，每次取模时先计算 $x=q\times z/2^k\approx z/p$，这样我们就通过一次乘法运算及一次位移运算高效的完成了一次不是很精确的除法。

接下来计算 $r'=r-x\times p$，在除法精确的情况下 $r'$ 即为答案，但是由于我们完成的除法不精确，我们需要再进行一次校验，若 $r'$ 大于 $p$ 则 $r'=r'-p$，在 $k$ 足够大时 $r'$ 即为所求。于是我们就通过两次乘法替换掉了一次取模，实际上编译器对于常量的取模优化就是基于此的。

但是由于 32 位整数作为模数时 $k$ 通常需要取 60 以上，计算 $x=q\times z/2^k\approx z/p$ 时需要用到 128 位整数，因此无法使用 barrett 约减优化此题。

蒙哥马利约减：

由于蒙哥马利约减证明及流程过于复杂，这里仅放一个[百度文库链接](https://wenku.baidu.com/view/a340c44e7d21af45b307e87101f69e314332fa7f.html)。（后续可能会填坑？）

简单来说，蒙哥马利约减就是通过将整数转换到蒙哥马利数域使得取模可以使用两次乘法及一次位移实现，且对于 32 位的模数可以在 64 位内完成运算。

预处理进入了蒙哥马利数域的 1-8 并放入 AVX2 变量内，假设叫 ml ，同时预处理一个塞了 8 个 8 的 AVX2 变量，假设叫 ad ，答案预设为塞了 8 蒙哥马利数域的 1 的 AVX2 变量。

这样我们只需要每次将答案与 ml 相乘，再将 ml 加上 ad 即可。所有运算均在数域内完成，没有进出数域的时间浪费。

于是我们所需要的所有运算都可以实现了，终于可以上代码了。

```cpp
#include<stdio.h>
#include<immintrin.h>
#pragma GCC target("avx2")
//__m256i为AVX2指令集的整型变量 
static unsigned mod,r,n2_;
static __m256i a0,mod1,R,hi32,ans,ml,ad;
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	long long d=a;
	if(b==0) x=1,y=0;
	else d=exgcd(b,a%b,y,x),y-=a/b*x;
	return d;
}
inline unsigned mul(unsigned x,unsigned y)//蒙哥马利数域内的乘法及取模 
{
	unsigned long long z=(unsigned long long)x*y;//计算乘积 
	return (z+(unsigned long long)(unsigned(z)*r)*mod)>>32;//对p取模 
}
inline __m256i add(__m256i _num1,__m256i _num2)//将8个32位整数相加并取模 
{
	__m256i apb=_mm256_add_epi32(_num1,_num2),//将num1,num2内的8个整数对应相加 
	ret=_mm256_sub_epi32(apb,mod1);//将答案减去mod 
	__m256i cmp=_mm256_cmpgt_epi32(a0,ret),//得到答案内小于0的数 
	add=_mm256_and_si256(cmp,mod1);
	return _mm256_add_epi32(add,ret);//将小于0的数加mod 
}
inline __m256i mul(__m256i _num1,__m256i _num2)//将8个32位整数相乘并取模 
{
	__m256i _num3=_num1,_num4,_num5=_num2;
	_num2=_mm256_mul_epu32(_num1,_num2);//将偶数位的整数相乘（得到4个64位整数并放回） 
	_num1=_mm256_mul_epu32(_mm256_mul_epu32(_num2,R),mod1);
    _num4=_mm256_srli_epi64(_mm256_add_epi64(_num1,_num2),32);//每个64位整数均左移32位，空出高32位（奇数位） 
	_num1=_mm256_srli_si256(_num3,4);_num2=_mm256_srli_si256(_num5,4);//进行4字节位移，即将奇数位的整数移动到偶数位 
	_num2=_mm256_mul_epu32(_num1,_num2);//将原奇数位的整数相乘 
	_num1=_mm256_mul_epu32(_mm256_mul_epu32(_num2,R),mod1);
    _num1=_mm256_and_si256(_mm256_add_epi64(_num1,_num2),hi32);//通过跟hi32做与取出低32位（偶数位） 
    return _mm256_or_si256(_num1,_num4);//将偶数位乘积和奇数位乘积合并位一个AVX2变量返回 
}
inline unsigned mon_in(unsigned x){return mul(x,n2_);}//进入蒙哥马利数域 
inline unsigned mon_out(unsigned x)//离开蒙哥马利数域 
{unsigned ret=((x+(unsigned long long)(unsigned(x)*r)*mod)>>32);return ret<mod?ret:ret-mod;}
void solve(int n,int p)
{
	unsigned i=1;
	long long x,y;
	mod=p;
	n2_=-(unsigned long long)mod%mod;exgcd(mod,1ll<<32,x,y);r=-unsigned(x);//初始化一些蒙哥马利约减需要使用的变量
	a0=_mm256_setzero_si256(),//预处理全0的AVX2变量（做加法有用） 
	mod1=_mm256_set1_epi32(mod),R=_mm256_set1_epi32(r);//预处理全mod1,全r的AVX2变量 
	hi32=_mm256_set_epi32(-1,0,-1,0,-1,0,-1,0);//预处理奇数位全1的AVX2变量（做乘法有用） 
	ans=_mm256_set1_epi32(mon_in(1));//初始化ans 
	ad=_mm256_set1_epi32(mon_in(8));//初始化全8的AVX2变量 
	ml=_mm256_set_epi32(mon_in(8),mon_in(7),mon_in(6),mon_in(5),mon_in(4),mon_in(3),mon_in(2),mon_in(1));//初始化因数 
	for(;i+8<=n;i+=8)
	{
		ans=mul(ans,ml);//将ans的8位与因数的8位依次相乘 
		ml=add(ml,ad);//将因数8位全部加8 
	}
	unsigned *fl=(unsigned*)&ans;
	unsigned as=mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7])));//取出ans的8位并相乘 
	as=mon_out(as);//离开蒙哥马利数域 
	for(;i<=n;i++)//处理整段未做掉的末几位 
		as=1ull*as*i%mod;
	printf("%u\n",as);
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n,p;
		scanf("%d%d",&n,&p);
		solve(n,p);
	}
	return 0;
}
```

然后就愉快的切掉了一道黑题[提交记录](https://www.luogu.com.cn/record/76437967)。~~其实时间卡的还是挺死的~~

---

## 作者：shadowice1984 (赞：80)

> 这篇题解算是zzq的blog的详细解释版吧

>如果看到这篇题解，请大喊三声"Min_25 牛逼!"

___________________________

## 前置芝士:任意模数fft

确保你写的不是三模ntt和未经过优化的拆系数fft这种做一次多项式乘法需要9次或者7次fft的丢人东西

~~9120年了，三次变两次优化早应该普及了~~

## 前置芝士:拉格朗日插值公式

假设我们有一个不超过$n$次的多项式$f$并且我们知道了这个多项式的m个点值对$(x_{i},f(x_{i}))$，并且$m \geq n+1$那么我们有如下公式

$$f(x)=\sum_{i=1}^{m}f(x_{i})\prod_{j \neq i} \frac{x-x_{j}}{x_{i}-x_{j}}$$

______________

# 本题题解

## $O(\sqrt{n}log^2n)$的解法

让我们来看看这道题要求我们做什么:计算$n! \mod P$

那么一个简单粗暴的思路是分块,我们希望计算$1 \dots n$的乘积，我们将序列分成长度为$B$的若干个块，如果我们能快速求出每个块的积，我们就能凑出n阶乘来

那具体来讲我构造这样的一个多项式$f(x)$

$$f(x)=\prod_{i=1}^{B}(x+i)$$

如果我们能求出$f(0),f(B),f(2B) \dots f(\lfloor \frac{n}{B} \rfloor B)$的话，我们就能在$O(\lfloor \frac{n}{B}\rfloor+B)$的时间内计算出答案了

使用多项式多点求值就可以在$O(\sqrt{N}log^2n)$的时间内计算出答案来

## $O(\sqrt{n}logn)$的做法

上面的做法可以通过玄学调整块长来优化常数，但是一个log做法只能求出$f(0),f(B) \dots f(B^2)$的值，因此我们需要把块长设为$\sqrt{n}$

我们发现我们只需要求出f这个多项式的一些点值就可以生成答案了，那么我们可以尝试不求出$f$的系数表达，而是直接使用f的点值进行迭代

为了让我们能够转移，我们将f的定义从一维的情况拓展到二维,我们定义这样一个多项式出来

$$f(d,x)=\prod_{i=1}^{d}(x+i)$$

那么我们最后要求的是$f(B,0),f(B,B) \dots f(B,B^2)$这些点值

一个显而易见的性质是,已知多项式f的$n+1$对点值$(x,f(x))$就可以唯一确定这个多项式，因此如果我们求出了$f(d,0),f(d,B) \dots f(d,dB)$我们就可以唯一的确定多项式$f(d,x)$了

现在我们尝试在d这一位上做倍增

具体来讲我们需要实现这两件事情

已知

$$f(d,0),f(d,B) \dots f(d,dB)$$

求出

$$f(2d,0),f(2d,B) \dots f(2d,2dB)$$

通过这个操作我们可以把d乘2

已知

$$f(d,0),f(d,B) \dots f(d,dB)$$

求出

$$f(d+1,0),f(d+1,B) \dots f(d+1,(d+1)B)$$

通过这个操作我们可以把$d$加$1$

然后有了这两个操作之后使用一个类似于快速幂的做法,我们迭代log轮就可以把求出$f(B,0),f(B,B) \dots f(B,B^2)$了

那么我们考虑如何实现这两个过程

## 将d乘2

我们知道$f(2d,x)=f(d,x)f(d,dx)$

因此我们只需要求出来

$$f(d,0),f(d,B) \dots f(d,2dB)$$

和

$$f(d,d),f(d,d+B) \dots f(d,2dB+d)$$

就能计算出我们想要的点值序列的

那么我们不妨构造一个新的多项式$h(x)=f(d,Bx)$

那么我们需要解决这样一个问题

已知

$$h(0),h(1),h(2) \dots h(d)$$

希望求出

$$h(d+1+0),h(d+1+1),h(d+1+1) \dots h(d+d+1)$$

求出上面的东西之后我们就已知了

$$h(0),h(1),h(2)\dots h(2d)$$

只要求出

$$h(d/B+0),h(d/B+1),h(d/B+2) \dots h(d/B+2d)$$

我们就可以把倍增需要的两个序列求出来了

所以总结一下就是已知

$$h(0),h(1) \dots h(k)$$

希望求解

$$h(\Delta+0),h(\Delta+1) \dots h(\Delta+k)$$

也就是说我们希望从点值转移到点值，那么我们学过的算法里面只有拉格朗日插值是一个完全不涉及多项式的系数还能算多项式的点值的算法

因此我们尝试使用拉格朗日插值算法

$$h(\Delta+n)=\sum_{i=0}^{k}h(i)\prod_{j \neq i}\frac{\Delta+n-j}{i-j}$$

我们将$\prod$里的分子提出来就是

$$h(\Delta+n)=\prod_{j=0}^{k}(\Delta+n-j)(\sum_{i=0}^{k}\frac{h(i)}{\Delta+n-i}\prod_{j \neq i}\frac{1}{i-j})$$

这里说明一下为什么$\Delta+n-i$不可能是0，因为$h(x)$本质上代表了一段连续数字的乘积，而根据我们算法的原理，$h(\Delta+n)$和$h(i)$一定代表了两段不同的数字，所以分母不可能为0

然后考虑$\prod_{j \neq }\frac{1}{i-j}$手玩一下会发现他是两段阶乘乘起来的,所以式子可以化成这样

$$h(\Delta+n)=\prod_{j=0}^{k}(\Delta+n-j)(\sum_{i=0}^{k}\frac{1}{\Delta+n-i}×\frac{h(i)}{i!(k-i)!(-1)^{k-i}})$$

如果我们设一些这样的函数出来

$$h'(n)=\frac{h(\Delta-k+n)}{\prod_{j=0}^{k}(\Delta+n-j)}$$

$$f(n)=\frac{h(n)}{n!(k-n)!(-1)^{k-n}}$$

$$g(n)=\frac{1}{\Delta-k+n}$$

那么我们就可以得到这样的式子

$$h'(n)=\sum_{i+j=k,i\geq 0,j\geq 0}f(i)g(j)$$

这东西当然是个标准卷积式子,把$f$和$g$求出来卷一卷就行了

知道了$h'(n+k)$之后我们就可以推出$h(n)$来了,发现$h'(n+k)$和$h(n)$的比值是一段区间当中数字的乘积，这个系数在可以$two-pointer$扫一遍在$O(k+logP)$的时间内求出

(这里直接求逆元是$O(klogP)$的，但是的确存在$O(k+logP)$的算法)

这样我们就可以成功的求出倍增需要的两个数组，于是就可以实现把$d$乘2的操作了

迭代一次是$O(nlogn)$的

## 将d加1

现在已知

$$f(d,0),f(d,B) \dots f(d,dB)$$

希望求出

$$f(d+1,0),f(d+1,B) \dots f(d+1,(d+1)B)$$

显然$f(d+1,(d+1)B)$暴力计算就行了

对于剩下的项，我们可以用这个式子计算

$$f(d+1,x)=f(d,x)(x+d+1)$$

显然迭代一次是$O(n)$的

完成了这两个操作之后我们就可以在$log$轮迭代中把d从0迭代到B了

然后我们乘一乘就能把阶乘算出来啦~

时间复杂度

$$T(n)=T(n/2)+O(nlogn)=O(nlogn)$$

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;const int N=262144+10;typedef unsigned long long ll;
const int P=65536;const int SF=16;const int msk=65535;ll mod;ll PP;
typedef long double ld;const ld pi=acos(-1.0);
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
struct cmp
{
    ld r;ld v;
    friend cmp operator +(cmp a,cmp b){return (cmp){a.r+b.r,a.v+b.v};}
    friend cmp operator -(cmp a,cmp b){return (cmp){a.r-b.r,a.v-b.v};}
    friend cmp operator *(cmp a,cmp b){return (cmp){a.r*b.r-a.v*b.v,a.r*b.v+a.v*b.r};}
    void operator /=(const int& len){r/=len;v/=len;}
}rt[2][22][N],tr[N],tr1[N],tr2[N],tr3[N],tr4[N],tr5[N],tr6[N];
int rv[22][N];ll m13[N],m14[N],m23[N],m24[N];
inline void pre()
{
    for(int d=1;d<=18;d++)
        for(int i=1;i<(1<<d);i++)rv[d][i]=(rv[d][i>>1]>>1)|((i&1)<<(d-1));
    for(int d=1,t=1;d<=18;d++,t<<=1)
        for(int i=0;i<(1<<d);i++)rt[0][d][i]=(cmp){cos(pi*i/t),sin(pi*i/t)};
    for(int d=1,t=1;d<=18;d++,t<<=1)
        for(int i=0;i<(1<<d);i++)rt[1][d][i]=(cmp){cos(pi*i/t),-sin(pi*i/t)};
}inline void fft(cmp* a,int len,int d,int o)
{
    for(int i=1;i<len;i++)if(i<rv[d][i])swap(a[i],a[rv[d][i]]);cmp* w;int i;
    for(int k=1,j=1;k<len;k<<=1,j++)
        for(int s=0;s<len;s+=(k<<1))
            for(i=s,w=rt[o][j];i<s+k;i++,++w)
                {cmp a1=a[i+k]*(*w);a[i+k]=a[i]-a1;a[i]=a[i]+a1;}
    if(o)for(int i=0;i<len;i++)a[i]/=len;
}inline void dbdft(ll* a,int len,int d,cmp* op1,cmp* op2)
{
    for(int i=0;i<len;i++)tr[i]=(cmp){(ld)(a[i]>>SF),(ld)(a[i]&msk)};
    fft(tr,len,d,0);tr[len]=tr[0];
    for(cmp* p1=tr,*p2=tr+len,*p3=op1;p1!=tr+len;++p1,--p2,++p3)
        (*p3)=(cmp){p1->r+p2->r,p1->v-p2->v}*(cmp){0.5,0};
    for(cmp* p1=tr,*p2=tr+len,*p3=op2;p1!=tr+len;++p1,--p2,++p3)
        (*p3)=(cmp){p1->r-p2->r,p1->v+p2->v}*(cmp){0,-0.5};
}inline void dbidft(cmp* tr,int len,int d,ll* a,ll* b)
{
    fft(tr,len,d,1);
    for(int i=0;i<len;i++)a[i]=(ll)(tr[i].r+0.5)%mod;
    for(int i=0;i<len;i++)b[i]=(ll)(tr[i].v+0.5)%mod;
}inline void poly_mul(ll* a,ll* b,ll* c,int len,int d)//以上都是任意模数fft的板子 
{
    dbdft(a,len,d,tr1,tr2);dbdft(b,len,d,tr3,tr4);
    for(int i=0;i<len;i++)tr5[i]=tr1[i]*tr3[i]+(cmp){0,1}*tr2[i]*tr4[i];
    for(int i=0;i<len;i++)tr6[i]=tr2[i]*tr3[i]+(cmp){0,1}*tr1[i]*tr4[i];
    dbidft(tr5,len,d,m13,m24);dbidft(tr6,len,d,m23,m14);
    for(int i=0;i<len;i++)c[i]=m13[i]*PP%mod;
    for(int i=0;i<len;i++)(c[i]+=(m23[i]+m14[i])*P+m24[i])%=mod;
}namespace iter
{
    ll f[N];ll g[N];ll h[N];ll ifac[N];
    inline void ih()
    {
        ifac[0]=ifac[1]=1;
        for(int i=2;i<min((ll)N,mod);i++)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;
        for(int i=1;i<min((ll)N,mod);i++)(ifac[i]*=ifac[i-1])%=mod;
    }inline void calch(ll del,int cur,ll* ip,ll* op)
    {
        int d=0;int len=1;while(len<=cur+cur+cur)len<<=1,d++;
        for(int i=0;i<=cur;i++)f[i]=ip[i]*ifac[i]%mod*ifac[cur-i]%mod;
        for(int i=cur-1;i>=0;i-=2)f[i]=(mod-f[i])%mod;
        for(int i=0;i<=cur+cur;i++)g[i]=po((del+mod-cur+i)%mod,mod-2); 
        for(int i=cur+1;i<len;i++)f[i]=0;for(int i=cur+cur+1;i<len;i++)g[i]=0;
        poly_mul(f,g,h,len,d);//卷积求出h' 
        ll xs=1;ll p1=del-cur;ll p2=del;
        for(int i=p1;i<=p2;i++)(xs*=i)%=mod;
        for(int i=0;i<=cur;i++,p1++,p2++)//双指针求出系数 
        {
            op[i]=h[i+cur]*xs%mod;
            (xs*=po(p1,mod-2))%=mod,(xs*=(p2+1))%=mod;
        }  
    }
}ll val[N];ll fv1[N];ll fv2[N];
inline void solve(int n)//倍增 
{
    int hb=0;for(int p=n;p;p>>=1)hb++;val[0]=1;
    for(int z=hb,cur=0;z>=0;z--)
    {
        if(cur!=0)//把d乘2 
        {
            iter::calch(cur+1,cur,val,fv1);
            for(int i=0;i<=cur;i++)val[cur+i+1]=fv1[i];val[cur<<1|1]=0;
            iter::calch(cur*po(n,mod-2)%mod,cur<<1,val,fv2);
            cur<<=1;for(int i=0;i<=cur;i++)(val[i]*=fv2[i])%=mod;
        }if((n>>z)&1)//把d加1 
        {
            for(int i=0;i<=cur;i++)(val[i]*=(ll)(n*i)+cur+1)%=mod;cur|=1;val[cur]=1;
            for(int i=1;i<=cur;i++)(val[cur]*=(ll)cur*n+i)%=mod;
        }
    }
}
int main()
{
    pre();int n;scanf("%d%lld",&n,&mod);iter::ih();
    int bl=sqrt(n);PP=(ll)P*P%mod;solve(bl);ll res=1;
    for(int i=0,id=0;;i+=bl,id++)//分块 
    {
        if((ll)i+bl>n){for(int j=i+1;j<=n;j++)(res*=j)%=mod;break;}
        (res*=val[id])%=mod;
    }printf("%lld",res);return 0;//拜拜程序~ 
}

```

















---

## 作者：bh1234666 (赞：41)

这是一篇非正解的题解，如想要学习 $O(\sqrt n\log n)$ 的解法请自行略过。

```不需要什么多项式，暴力是可以通过本题的。```

之前提交过 $O(n)$ 做法的卡常题解，但是出题人缩小了时限导致那篇题解过不去了。有人看了那篇题解写了卡常但过不去。但其实两个月后我发的洛谷日报里面讲了对其进一步卡常的方法。为了避免有人看了那篇题解卡不过去所以把它搬过来了。

### 从 [【模板】快速阶乘算法](https://www.luogu.com.cn/problem/P5282) 看更高级的卡常技巧

该部分可能涉及部分硬件知识，同时部分技巧优化效果与 cpu 架构及工艺有关。

该题正解为 $O(\sqrt n\log n)$ 的多项式解法，但是我们可以对 $O(n)$ 做法进行卡常。为便于比较速度，我们测试时取模数为 998244353（并非在程序内直接定义，因为固定模数时编译器会优化取模），并计算出 998244352 的阶乘。

- 直接计算

直接枚举 $1\sim n$ 相乘。


```
scanf("%d%d",&n,&mod);
start=clock();
for(int i=1;i<=n;i++)
	ans=1ll*ans*i%mod;
finish=clock();
printf("%d %.3f",ans,(double)(finish-start)/CLOCKS_PER_SEC);
```
耗时约十二秒。

实际上部分架构的 cpu 支持零开销硬件循环，但是仅仅会节省循环变量调用时间，由于上述代码主要耗时不在循环变量的加减，因此对耗时几乎没影响。

- 优化取模

上面提到固定模数时编译器会优化取模，但是由于这里模数是读入的，编译器无法优化，因此我们手动进行优化。

我们采用 barrett 约减（固定模数时编译器也会采用相同的方法优化），其原理是通过成本较低的乘法运算和位运算替换取模（整除）运算。

预处理 $brt=\lfloor 2^{r}/len\rfloor$，可以通过 $brt\times x /2^r$ 得到 $\lfloor x/len \rfloor$ 的近似值，当 $r$ 足够大时，得到的近似值与精确值至多差 1。

我们可以通过 $x-brt\times x /2^r$ 来得到 $x\bmod len$ 的近似值，若得到的值大于 $len$ 则减 $len$ 即可。

即使用低成本的加减乘及位运算代替高成本的取模运算。

```
scanf("%d%d",&n,&mod);
start=clock();
__uint128_t brt=((__uint128_t)1<<64)/mod;
for(int i=1;i<=n;i++)
{
	ans*=i;
	ans=ans-mod*(brt*ans>>64);
	while(ans>=mod) ans-=mod;
}
finish=clock();
printf("%d %.3f",ans,(double)(finish-start)/CLOCKS_PER_SEC);
```

耗时约三秒。

将上述代码 while 改成 if 不会影响结果，但是会使得耗时增加到三点四秒左右。具体原理不明，但作者怀疑是分支预测的影响。

程序中的条件分支是根据程序指令在流水线处理后结果再执行的，所以当CPU等待指令结果时，流水线前级处于空闲状况，因此部分 cpu 会加入分支预测提前执行部分指令来避免流水线的等待以提高 cpu 的运行效率。

但是 barrett 约减中由于精度较高，$ans\ge mod$ 几乎不会成立，此时分支预测提前执行的指令几乎全部作废，因此不会提高效率，反而因为需要将已经装入流水线执行的指令和结果全部清除，然后再装入正确指令重新处理导致效率更低。

有多个分支时可以使用 ```__builtin_expect(x,0/1)``` 来告诉编译器 $x$ 更倾向于 $0$（假）还是 $1$（真），以控制分支预测走向，不过这里条件判断语句只有一个分支因此这个方法没用。 

上述代码使用 while 时不会触发分支预测，因此效率反而高于 if。

- 循环展开

循环展开是一种牺牲程序的尺寸来加快程序的执行速度的优化方法，常用来降低循环开销，为具有多个功能单元的处理器提供指令级并行。也有利于指令流水线的调度。

展开可以积极调度（或管道化）循环以掩盖一些延迟。如果有足够的空闲寄存器使变量保持活动状态，因为通过展开相关性链展露了关键路径，这将非常有用。

要特别注意，循环展开时要尽量避免上下句使用相同变量，否则会导致 cpu 并行不充分。

```
scanf("%d%d",&n,&mod);
start=clock();
const __uint128_t brt=((__uint128_t)1<<64)/mod;
for(i=1;i+8<=n;i+=8)
{
	ans1*=i;ans2*=(i+1);ans3*=(i+2);ans4*=(i+3);ans5*=(i+4);ans6*=(i+5);ans7*=(i+6);ans8*=(i+7);
	ans1=ans1-mod*(brt*ans1>>64);
	ans2=ans2-mod*(brt*ans2>>64);
	ans3=ans3-mod*(brt*ans3>>64);
	ans4=ans4-mod*(brt*ans4>>64);
	ans5=ans5-mod*(brt*ans5>>64);
	ans6=ans6-mod*(brt*ans6>>64);
	ans7=ans7-mod*(brt*ans7>>64);
	ans8=ans8-mod*(brt*ans8>>64);
	if(ans1>=mod) ans1-=mod;
	if(ans2>=mod) ans2-=mod;
	if(ans3>=mod) ans3-=mod;
	if(ans4>=mod) ans4-=mod;
	if(ans5>=mod) ans5-=mod;
	if(ans6>=mod) ans6-=mod;
	if(ans7>=mod) ans7-=mod;
	if(ans8>=mod) ans8-=mod;
}
ans1=ans1*ans2%mod;
ans3=ans3*ans4%mod;
ans5=ans5*ans6%mod;
ans7=ans7*ans8%mod;
ans1=ans1*ans3%mod;
ans5=ans5*ans7%mod;
ans=ans1*ans5%mod;
for(;i<=n;i++)
	ans=ans*i%mod;
finish=clock();
printf("%d %.3f",ans,(double)(finish-start)/CLOCKS_PER_SEC);
```

耗时约 0.95s。

注意此时我把上面的 while 更换成了 if，因为 while 会影响 cpu 并发。使用 while 耗时约一秒。

- 指令集

循环展开本质是触发 cpu 并行，那是否存在一种办法直接让 cpu 并行呢，答案是肯定的。

AVX2 是一种实现 SIMD 操作的指令集。SIMD 的全称为：Single Instruction stream Multiple Data streams，对应的中文名为 单指令流多数据流。SIMD 为并行计算中的一种。

AVX 全称为：Advanced Vector Extensions（又名，Sandy Bridge New Extensions）,是 Intel 和 AMD 微服务器x86指令集的extension扩展，AVX2 为其升级版本，支持的位数扩展到了 256 位。

其核心代码较长，这里就不放了，可以参考我在这题提交的题解 [link](https://bh1234666.blog.luogu.org/solution-p5282)。

耗时约 0.85s。

我们通过一步步加强优化的力度，将耗时从 12s 一步步压到了 0.85s，并且使用 $O(n)$ 的暴力通过了这道正解 $O(\sqrt n\log n)$ 的题。相信从中读者也领会到了卡常的魅力及它的强大。

~~然后出题人就把时限从原来的 4s 改成了现在的 2s。~~

当然指令集也是可以循环展开的，但是一般不用，否则码量过大及可读性过差，同时使用指令集和循环展耗时可以到 0.2s 左右~~于是又通过了此题~~。

- 一个让常数再减半的优化

简单考虑阶乘的一些简单的性质，假如我们要求 $n$ 的阶乘，且我们已经通过指令集及循环展开得到了 $n/2$ 的阶乘。

我们发现，由于实际上我们得到的是 $8$ 个形如若干 $8n+k$ 的数分别相乘的结果，那么我们可以很轻易的从中分离出奇偶项。

考虑将 $n/2$ 的阶乘乘 $2^{n/2}$ ，我们就能得到 $n$ 以内所有偶数的乘积，且我们可以从 $n/2$ 的阶乘中分离出所有奇数的乘积，那么我们只需要再求出 $n/2$ 到 $n$ 之间所有奇数的乘积即可。

于是我们又节省了 $1/4$ 的常数，且求出 $n/2$ 的阶乘的过程也可以通过上述做法优化，最终可以优化掉一半的常数。

实际上为了方便，我将 $n$ 先缩小到了 $2$ 的整数次幂，最后再将未乘上去的部分暴力乘上去。可以发现进行第 $t$ 轮优化时缩小的常数为 $1/2^{t+1}$ ，因此轮数过多以后对常数几乎不再产生影响，反而会因为 $n$ 缩的过小导致之后暴力的成本增加，因此我只进行了 $8$ 轮优化。

部分核心代码：

~~~
#define mv 8//进行8轮 
int n=N-(N&(256*(1<<mv)-1));//先将n缩小到2的整数次幂 
...//初始化蒙哥马利约减 
unsigned as=mon_in(1),as2=mon_in(1),*fl;//as记录偶数的乘积，as2记录奇数的乘积
{
__m256i ans[8]={...};//将答案初始化为1 
ad=_mm256_set1_epi32(mon_in(64));//将每次步长初始化为64(指令集8位乘循环展开8位) 
__m256i ml[8]={...};//将乘数初始化为1-64 
for(unsigned i=1;i+63<=n>>mv;i+=64)
{
	ans[0]=mul(ans[0],ml[0]);
	...
	ans[7]=mul(ans[7],ml[7]); 
	ml[0]=add(ml[0],ad);
	...
	ml[7]=add(ml[7],ad);
}//得到前n>>mv位的乘积
fl=(unsigned*)(ans+0);
as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));//分离偶数 
as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));//分离奇数 
...
fl=(unsigned*)(ans+7);
as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
}
for(int j=mv-1;j>=0;j--)
{
as=mul(as,as2);as=mul(as,mon_in(qpow(2,n>>(j+1),p)));//as偶数项,as2前半奇数项 
__m256i ans[8]={...};//初始化ans为1 
ad=_mm256_set1_epi32(mon_in(128));//初始化步长为128(从这里开始仅需处理奇数位了) 
const unsigned add_=n>>(j+1);//初始化起始位置为n>>(j+1)，即上一次结束的位置 
__m256i ml[8]={...};//初始化乘数为从add_开始的64个奇数 
for(unsigned i=add_;i+127<=n>>j;i+=128)
{
	ans[0]=mul(ans[0],ml[0]);
	...
	ans[7]=mul(ans[7],ml[7]);
	ml[0]=add(ml[0],ad);
	...
	ml[7]=add(ml[7],ad);
}//得到当前处理段后半奇数的乘积 
fl=(unsigned*)(ans+0);
as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
...
fl=(unsigned*)(ans+7);//合并当前处理段后半奇数的乘积 
as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
}
as=mul(as,as2);//将奇数偶数部分相乘得到答案 
as=mon_out(as);//离开数域 
for(int i=n+1;i<=N;i++)//暴力将最后一段乘上去 
	as=1ull*as*i%p;
printf("%u\n",as);//输出答案 
~~~

于是我们又卡掉了一半的常数，耗时达到了约 0.1s，在原题中总时间 5.11s，已经超过了大部分 $O(\sqrt n\log n)$ 的正解。

从最开始的直接循环枚举取模的 12s，到最后的指令集加循环展开加小技巧的 0.1s，我们通过各种技巧卡掉了 $120$ 倍的常数~~同时码长翻了 200 倍~~，让一个 $O(n)$ 的暴力吊打了常数较大的 $O(\sqrt n\log n)$ 的正解。

一些误解：

- 循环展开属于指令级并行技巧，但是与指令集不冲突，两者可以同时使用。
- 循环展开通常 $4\sim 8$ 层即可，再多层数展开因为 cpu 资源不够没有提升。
- 卡常并没有凭空诞生资源，实际上相比于普通代码，虽然单核占用率都接近 $100\%$，极限卡常的代码运行时的单核活跃度以及功耗都会远大于未卡常的代码。
- 蒙哥马利约减的使用条件为模数与进制互质，在通常情况下为与 $2$ 互质即模数为奇数即可使用。

---

## 作者：JustinRochester (赞：21)

[传送门](https://www.luogu.com.cn/problem/P5282)

总算是学会了这个算法......

---

**【前置芝士】**
--

1. [多项式乘法](https://www.luogu.com.cn/problem/P3803)
2. [任意模数多项式乘法](https://www.luogu.com.cn/problem/P4245)
3. [多项式连续点值平移](https://www.luogu.com.cn/problem/P5667)

前两个用于处理任意模数意义下的多项式乘法；

第三个用于在未知一个不超过 $(r-l)$ 次的多项式具体形式，但已知其在某连续区间 $[l,r]$ 的 $(r-l+1)$ 个点值时，求出任一与之不交的、长度相同的区间的 $(r-l+1)$ 个点的值。复杂度为 $O(n\log n)$。

---

**【分析】**
--

考虑令 $s=\lfloor\sqrt n\rfloor$ ，则 $\displaystyle n!=\prod_{i=1}^n i=\prod_{i=0}^{s-1}\prod_{t=1}^s(is+t)\cdot \prod_{i=s^2+1}^n i$ 。

若已求出 $\displaystyle \prod_{i=0}^{s-1}\prod_{t=1}^s(is+t)$，则后面的那个式子直接暴力点乘，复杂度为 $o(\sqrt n)$ 的。

有个比较简单的方法是由分治 FFT 或多项式启发式合并求出 $s$ 次多项式 $\displaystyle g_s(x)=\prod_{t=1}^s (x+t)$ ；再由多项式多点求值求出 $g_s(0\cdot s),g_s(1\cdot s),g_s(2\cdot s),\cdots, g_s((s-1)\cdot s)$ 。这些乘起来即为待求项。

这样一来，复杂度为 $O(s\log^2 s)+O(s\log^2 s)=O(\sqrt n\log^2 n)$ 。

---

但考虑到最后实际对答案的贡献仅在若干个点处取到。若这些点所处的区间连续，则可能可用多项式连续点值平移求出答案。

很幸运的是，我们令 $h_s(x)=g_s(sx)$，则待求的点值变换为了 $h_s(0),h_s(1),h_s(2),\cdots, h_s(s-1)$ ，是长度为 $s$ 的连续区间。这就可以用到多项式连续点值平移了。

现在，我们可以考虑如何使用多项式连续点值平移凑出这些东西了。

而初始我们也并不知道 $h_s(x)$ 的任何一个点值，但是我们知道 $h_1(x)=x+1$ 的所有点值。

因此，我们考虑如何倍增得到 $h_s(x)$ 的那些点值。

当我们已知 $h_d(0),h_d(1),\cdots,h_d(d)$ 时，若我们想要得到 $h_{2d}(0),h_{2d}(1),\cdots,h_{2d}(2d)$。

对于 $\displaystyle \forall i\leq d\to h_{2d}(i)=g_{2d}(is)=\prod_{t=1}^{2d}(is+t)=g_d(is)\cdot g_d(is+d)$ 。

由于 $g_d(is+d)$ 在模 $P$ 意义下，与 $h_d(d\cdot s^{-1}+i)$ 等价，因此 $h_{2d}(i)=h_d(i)\cdot h_d(i+d\cdot s^{-1})$ 。

求解这些点值时，我们只要将 $h_d(0),h_d(1),\cdots,h_d(d)$ 这些连续点值平移出 $h_{2d}(0+d\cdot s^{-1}),h_d(1+d\cdot s^{-1}),\cdots, h_d(d+d\cdot s^{-1})$ ，直接两两点乘即可倍增。

而对于后面的那几个点，如果我们已知 $h_d(d+1),h_d(d+2),\cdots, h_d(2d)$ ，就也能通过这个方法求解。

那怎么知道呢？问就是多项式连续点值平移，用 $h_d(0),h_d(1),\cdots,h_d(d)$ 直接平移出 $h_d(d+1),h_d(d+2),\cdots,h_d(2d+1)$ 就可以了（这里因为要求区间不交，会额外平移出 $h_d(2d+1)$）。

既然这样，~~那也别客气了，分那么清楚，~~ 第一次先平移出 $h_d(d+1),h_d(d+2),\cdots, h_d(2d+1)$ ；拼接到原点值后面之后，第二次再直接用 $h_d(0),h_d(1),\cdots,h_d(2d+1)$ 直接平移出 $h_d(0+d\cdot s^{-1}),h_d(1+d\cdot s^{-1}),\cdots,h_d(2d+1+d\cdot s^{-1})$ 。点乘则可以得到我们要求的 $h_{2d}(0),h_{2d}(1),\cdots,h_{2d}(2d)$ 。复杂度为 $O(d\log d)+O(2d\log 2d)+O(2d)=O(d\log d)$ 。

---

由于我们可以从 $h_d$ 的状态推出 $h_{2d}$ 的状态，我们又已知 $h_1$ 的状态，待求 $h_s$ 的状态；于是我们去考虑用类似递归快速幂的迭代方法求出结果。

那还差的步骤就是由 $h_d$ 的状态推出 $h_{d+1}$ 的状态。

~~这个简单，~~ 由于 $\displaystyle h_{d+1}(i)=g_{d+1}(is)=\prod_{t=1}^{d+1}(is+t)=g_d(is)\cdot (is+d+1)=h_d(i)\cdot (is+d+1)$ ，我们直接 $O(d)$ 暴力跑过去就行了。

但是由 $h_d$ 推 $h_{d+1}$ 时，需要额外知道 $h_{d+1}(d+1)$ 的信息，它需要用到 $h_d(d+1)$ 的信息。

但这个无伤大雅，因为 $h_d$ 推出 $h_{d+1}$ 的状态一定发生在 $h_{d\over 2}$ 推出 $h_d$ 之后。而像上面说的，正好由于区间不交，恰好在 $h_d$ 推出 $h_{2d}$ 时，把 $h_{2d}(2d+1)$ 的给顺便算了。

那就好办了，如果接着要 $h_{2d}$ 推 $h_{2d+1}$ ，就把这个正好算了；如果不要，就顺手丢了。于是这一步的复杂度是严格 $O(d)$ 的。

---

综上，我们由已知的 $h_1$ 状态，倍增地推出 $h_s$ 的状态。最后累乘 $h_s(0),\cdots, h_s(s-1)$ ，再乘上那些尾巴，就可以算出总答案了。

复杂度 $\displaystyle T(s)=T({s\over 2})+O(s\log s)+O(s)$ 得到 $T(s)=O(s\log s)=O(\sqrt n\log n)$ 。（原本还要加上一个 $o(\sqrt n)$ ，但是作为低阶项舍去了。）

---

**【核心代码】**
--

```cpp
poly c, d;
inline int get_fac(int n) {
	int pos=curStk, s=sqrt(n)+1e-6;
	vir invs=Inv[s];
	for(int i=s;i>1;i>>=1) Stk[++curStk]=i;//手动压栈

	c.resize(2); c[0]=1; c[1]=s+1;//初始化 h_1 的状态
	for(int l=Stk[curStk]; curStk>pos; l=Stk[--curStk]) {
		ValueTrans(c, d, l>>1, (l>>1)+1);//点值平移出额外状态
		c.resize(2*sz(c));
		for(int i=0; i<sz(d); ++i) c[sz(d)+i]=d[i];
		ValueTrans(c, d, sz(c)-1, invs*vir(l>>1));//点值平移出点乘状态
		for(int i=0; i<sz(c); ++i) c[i]=c[i]*d[i];
		if(l&1) {
			for(int i=0; i<=l; ++i) c[i]=c[i]*vir(i*s+l);//h_l 转为 h_{l+1}
		}
		else c.resize(l+1);
	}

	vir res=1;
	for(int i=0; i<s; ++i) res=res*c[i];//累乘
	for(int i=s*s+1; i<=n; ++i) res=res*vir(i);//处理尾巴
	return res;
}
```

---

**【拓展】**
--

你以为这就完了？

我发现我的 [代码](https://www.luogu.com.cn/record/67992221) 跑得飞快，看到连时限 4s 的十分之一都没跑到，我不禁“恶向胆边生”。用这个板子改了改，测试了一下阶乘求和的结果。

做法是求出 $\displaystyle \sum_{i=1}^n i!$ 和 $\displaystyle \sum_{i=1}^{n-1} i!$，做差算出答案。

那这个问题怎么用点值平移处理呢？

我们记 $\displaystyle S_n=\sum_{i=1}^n i!$ ，考虑它的转移矩阵：

$\begin{aligned}
\begin{pmatrix}
(n+1)!
\\S_n
\end{pmatrix}&=
\begin{pmatrix}
n+1&0
\\1&1
\end{pmatrix}\cdot 
\begin{pmatrix}
n!
\\S_{n-1}
\end{pmatrix}
\\&=\prod_{i=1}^n
\begin{pmatrix}
i+1&0
\\1&1
\end{pmatrix}\cdot 
\begin{pmatrix}
1
\\0
\end{pmatrix}
\end{aligned}$

同理，我们考虑 $\displaystyle g_d(x)=\prod_{i=1}^d\begin{pmatrix}
x+i+1&0
\\1&1
\end{pmatrix},h_d(i)=g_d(is)$ 。

手玩一下会发现，这个矩阵这个矩阵的乘法也有特点：

$\begin{pmatrix}
a_1&\ 
\\b_1&c_1
\end{pmatrix}\cdot\begin{pmatrix}
a_2&\ 
\\b_2&c_2
\end{pmatrix}=\begin{pmatrix}
a_1a_2&\ 
\\b_1a_2+c_1b_2&c_1c_2
\end{pmatrix}$

也就是说，这个矩阵的乘积永远只有三个地方有值，并且右下角恒为 $1$ 。于是我们维护 $h_d(x)=\begin{pmatrix}mc_{d,0}(x)&\ \\mc_{d,1}(x)&1\end{pmatrix}$ 。

由原来维护一个点值变成了维护两个点值 ~~而已~~ 。

由于此时为矩阵乘法 $h_{2d}(i)=h_d(i+d\cdot s^{-1})\cdot h_d(i)$ 形式不会发生变化，但一定要注意矩阵的左右乘不等价。

发生变化的是 $h_d$ 转移到 $h_{d+1}$ 时，此时有：

$\begin{aligned}
&h_{d+1}(i)
\\=&\begin{pmatrix}mc_{d+1,0}(i)&\ \\mc_{d+1,1}(i)&1\end{pmatrix}
\\=&\begin{pmatrix}i+d+2&0\\1&1\end{pmatrix}h_d(i)
\\=&\begin{pmatrix}i+d+2&0\\1&1\end{pmatrix}\begin{pmatrix}mc_{d,0}(x)&\ \\mc_{d,1}(x)&1\end{pmatrix}
\\=&\begin{pmatrix}(i+d+2)mc_{d,0}(x)&\ \\mc_{d,0}+mc_{d,1}(x)&1\end{pmatrix}
\end{aligned}$

修改此处即可。

```cpp
poly mc[2], md[2];
inline int get_sumfac(int n) {
	int pos=curStk, s=sqrt(n)+1e-6;
	vir invs=Inv[s];
	for(int i=s;i>1;i>>=1) Stk[++curStk]=i;

	mc[0].resize(2); mc[0][0]=2; mc[0][1]=s+2;
	mc[1].resize(2); mc[1][0]=mc[1][1]=1;
	for(int l=Stk[curStk]; curStk>pos; l=Stk[--curStk]) {
		for(int t=0; t<2; ++t){
			poly &c = mc[t], &d = md[t];
			ValueTrans(c, d, l>>1, (l>>1)+1);
			c.resize(2*sz(c));
			for(int i=0; i<sz(d); ++i) c[sz(d)+i]=d[i];
			ValueTrans(c, d, sz(c)-1, invs*vir(l>>1));
		}
		for(int i=0; i<sz(mc[0]); ++i) {
			mc[1][i]=mc[0][i]*md[1][i]+mc[1][i];
			mc[0][i]=mc[0][i]*md[0][i];
		}
		if(l&1) {
			for(int i=0; i<=l; ++i) {
				mc[1][i]=mc[0][i]+mc[1][i];
				mc[0][i]=mc[0][i]*vir(i*s+l+1);
			}
		}
		else {
			mc[0].resize(l+1);
			mc[1].resize(l+1);
		}
	}

	vir res0=1, res1=0;
	for(int i=0; i<s; ++i){
		res1=res0*mc[1][i]+res1;
		res0=res0*mc[0][i];
	}
	for(int i=s*s+1; i<=n; ++i){
		res1=res1+res0;
		res0=res0*vir(i+1);
	}
	return res1;
}
```

[结果](https://www.luogu.com.cn/record/67992035) 还是没跑到一半的时间。

![](https://cdn.luogu.com.cn/upload/image_hosting/w1xs33od.png)

---

## 作者：Prean (赞：17)

Min_25牛逼！Min_25牛逼！Min_25牛逼！

设有 $f_d(x)=\prod_{i=1}^{d}(x+i)=f_{d-1}(x)(x+d)$，设 $B=\lfloor\sqrt{n}\rfloor$，那么计算阶乘就相当于需要计算 $f_B(iB)$（$i\in[0,B]$）

考虑倍增。如果我们知道了 $f_d(iB)$（$i\in[0,d]$），考虑应该如何计算 $f_{d+1}(iB))$（$i\in[0,d+1]$） 和 $f_{2d}(iB)$（$i\in[0,2d]$）

第一个是较为显然的，只需要对 $x+d+1$ 求出 $x\in[0,dB],B\mid x$ 时的点值即可，对于 $f_{d+1}(dB)$ 直接暴力计算即可。

第二个比较麻烦。

根据定义显然有 $f_{2d}(x)=f_d(x)f_d(x+d)$。也就是说我们只要知道了 $f_d(iB),f_d(iB+d)$（$i\in[0,2d]$） 的点值即可。

令 $g_d(x)=f_d(xB)$，上述问题变为给定 $g_d(x)$（$x\in[0,2d]$），求 $g(x+\frac{d}{B})$（$x\in[0,2d]$）。

很显然在模意义下有 $\frac{d}{B}>B$。

证明：因为 $n<p$，所以对于 $k\in[0,B]$ 都有 $kB<n<p$，所以 $kB\ne d$，那么 $[0,B]$ 中一定不存在 $\frac{d}{B}$。

你会发现这个和 [拉格朗日插值2](http://loj.ac/p/166) 很像，但是我们并不知道 $g_d(i)$（$i\in[d,2d]$）。

可以考虑通过 $g_d(i)$（$i\in[0,d]$）求出 $g_d(i)$（$i\in[d,2d]$），再求上面的那个东西。

这里可以直接套用 LOJ166 的做法了。复杂度 $T(n)=T(\frac{n}{2})+O(\log n)=T(n\log n)$，这里 $n=\sqrt N$ 所以复杂度是 $O(\sqrt{n}\log n)$。

第二部分的流程：$f_d(iB)$（$i\in[0,d]$）->$f_d(iB)$（$i\in[0,2d]$）->$f_d(iB+d)$（$i\in[2d]$）->$f_{2d}(iB)$（$i\in[0,2d]$）
```cpp
#include<cstdio>
#include<cmath>
#define IMP(lim,act) for(int qwq=(lim),i=0;i^qwq;++i)act
typedef double db;
const int M=3e5+5;
const db Pi=acos(-1);
int n,P,F[M],ifac[M];
struct Barrett{
	typedef unsigned long long ull;
	typedef __uint128_t LL;
	ull m,B;
	Barrett(const ull&m=2):m(m),B((LL(1)<<64)/m){}
	friend inline ull operator%(const ull&a,const Barrett&mod){
		ull r=a-mod.m*(LL(mod.B)*a>>64);return r>=mod.m?r-mod.m:r;
	}
}mod;
struct complex{
	db x,y;
	complex(const db&x=0,const db&y=0):x(x),y(y){}
	inline complex operator+(const complex&it)const{
		return complex(x+it.x,y+it.y);
	}
	inline complex operator-(const complex&it)const{
		return complex(x-it.x,y-it.y);
	}
	inline complex operator*(const complex&it)const{
		return complex(x*it.x-y*it.y,x*it.y+y*it.x);
	}
}buf[M],*w[20];
inline int Getlen(const int&n){
	int len(0);while((1<<len)<n)++len;return len;
}
inline void swap(complex&a,complex&b){
	complex c=a;a=b;b=c;
}
inline int Get(const db&x){
	return((long long)(x+.5))%mod;
}
inline int qpow(int a,int b=P-2){
	int ans(1);for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;
}
inline void NTT_init(const int&n){
	const int&m=Getlen(n)-1;complex*now=buf;w[m]=now;now+=1<<m;
	IMP(1<<m,w[m][i]=complex(std::cos(i*Pi/(1<<m)),std::sin(i*Pi/(1<<m))));
	for(int k=m-1;k>=0&&(w[k]=now,now+=1<<k);--k)IMP(1<<k,w[k][i]=w[k+1][i<<1]);
}
inline void DFT(complex*f,const int&M){
	const int&n=1<<M;
	for(int len=n>>1,d=M-1;d>=0;--d,len>>=1)for(int k=0;k^n;k+=len<<1){
		complex*W=w[d],*L=f+(k),*R=f+(k|len),x,y;IMP(len,(x=*L,y=*R)),*L++=(x+y),*R++=*W++*(x-y);
	}
}
inline void IDFT(complex*f,const int&M){
	const int&n=1<<M;
	for(int len=1,d=0;d^M;++d,len<<=1)for(int k=0;k^n;k+=len<<1){
		complex*W=w[d],*L=f+(k),*R=f+(k|len),x,y;IMP(len,(x=*L,y=*W++**R)),*L++=(x+y),*R++=(x-y);
	}
	IMP(n,(f[i].x/=n,f[i].y/=n));for(int i=1;(i<<1)<n;++i)swap(f[i],f[n-i]);
}
inline void MTT(int*f,int*g,int*h,const int&n,const int&m,const int&t,const int&Len=-1){
	static complex Q[M],P[M],T[M];const int&len=Getlen(!~Len?n+m-1:Len);
	IMP(n,(Q[i].x=f[i]&32767,P[i].x=f[i]>>15));IMP(m,T[i]=complex(g[i]&32767,g[i]>>15));
	DFT(Q,len);DFT(P,len);DFT(T,len);IMP(1<<len,(Q[i]=Q[i]*T[i],P[i]=P[i]*T[i]));IDFT(Q,len);IDFT(P,len);
	IMP(t,h[i]=(Get(Q[i].x)+(1ll*Get(Q[i].y+P[i].x)<<15)+(1ll*Get(P[i].y)<<30))%mod);IMP(1<<len,Q[i]=P[i]=T[i]=0);
}
inline void Getinv(int*f,const int&n){
	static int pre[M];pre[0]=f[0];for(int i=1;i<n;++i)pre[i]=1ll*pre[i-1]*f[i]%mod;
	int t,c=qpow(pre[n-1]);for(int i=n-1;i>=1;--i)t=f[i],f[i]=1ll*pre[i-1]*c%mod,c=1ll*c*t%mod;f[0]=c;
}
inline void PT(int*f,int*g,const int&n,const int&m){
	static int F[M],G[M],H[M];H[0]=1;IMP(n,H[0]=1ll*H[0]*(m-i)%mod);IMP(n+n,G[i]=m+i-n);G[0]=1;Getinv(G,n+n);
	IMP(n,F[i]=1ll*ifac[i]*(n-i-1&1?P-ifac[n-i-1]:ifac[n-i-1])%mod*f[i]%mod);
	const int&len=Getlen(n+n);for(int i=1;i<n;++i)H[i]=1ll*(m+i)*G[i]%mod*H[i-1]%mod;MTT(F,G,F,n,n+n,n+n,n+n);
	IMP(n,g[i]=1ll*F[n+i]*H[i]%mod);IMP(1<<len,F[i]=G[i]=H[i]=0);
}
inline int Getfac(const int&n,const int&p){
	static int F[M],G[M];const int&B=sqrt(n),m=Getlen(B)-1;
	mod=Barrett(P=p);ifac[0]=ifac[1]=1;for(int i=2;i<=B;++i)ifac[i]=1ll*(P-P/i)*ifac[P%i]%mod;
	for(int i=1;i<=B;++i)ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;F[0]=1;F[1]=B+1;
	for(int i=m;i>=0;--i){
		const int&q=B>>i+1,p=B>>i;if(!q)continue;
		PT(F,G,q+1,q+1);IMP(q,F[i+q+1]=G[i]),G[i]=0;G[q]=0;
		PT(F,G,q*2+1,1ll*q*qpow(B)%mod);IMP(q*2+1,F[i]=1ll*F[i]*G[i]%mod),G[i]=0;
		if(q*2+1==p){
			IMP(q*2+1,F[i]=1ll*F[i]*(i*B+p)%mod);F[p]=1;IMP(p,F[p]=1ll*F[p]*(p*B+i+1)%mod);
		}
	}
	int ans(1);IMP(B,ans=1ll*ans*F[i]%mod),F[i]=0;F[B]=0;for(int i=B*B+1;i<=n;++i)ans=1ll*ans*i%mod;return ans;
}
signed main(){
	int T,N,P;NTT_init(1<<17);scanf("%d",&T);while(T--)scanf("%d%d",&N,&P),printf("%d\n",Getfac(N,P));
}
```

---

## 作者：Jμdge (赞：15)

这位是神仙：[bztminamoto](https://www.cnblogs.com/bztMinamoto/p/10661226.html)，大家赶紧膜


前置芝士: 

>1. [任意模数 NTT (MTT)](https://www.luogu.org/problemnew/show/P4245)

>2. [多项式多点求值](https://www.luogu.org/problemnew/show/P5050)

>3. [拉格朗日插值法](https://www.luogu.org/problemnew/show/P4781)

>4. ~~min25筛【雾~~ 

我们考虑这道题如果模数固定（1e9+7 或者是 998244353），如果是可以 NTT 的模数当然是妙哉，但是模数是什么其实已经没有意义了，因为它是固定的...

既然模数固定的话分段打表还不能过？每个块的大小不超过 1e7 都是 ojbk 的吧？

所以如果**模数固定**，能分段打表（范围才整形）为什么要来个 FFT 呢【雾

但是很遗憾，这道题模数不固定...所以我们只能考虑用别的算法(~~乱搞~~)

然后我们发现，这个题...非常诡异，因为它的做法有两种，我们先来考虑跑得比较慢的一种...【雾

# solve1

虽说我们不能分段打表了，但是分段（块）这个思路是否能给我们一点启发呢？

首先我们考虑构造一个 bl-1 次多项式： 
$$F(x)=\prod_{i=0}^{bl-1} (x+i)$$

这个多项式有什么用呢？

我们考虑这里带入 x 之后这个多项式的值其实就是：

$$(x+bl-1)!\over (x-1)!$$

我们发现这是两个阶乘相除的形式...

那么我们是不是可以考虑令 bl 和分块算法里一样，为 $sqrt(n)$ 呢？

这样的话，我们把 $1,s+1,2s+1,...,s* s-s+1 $ 带入求值后再相乘，答案是否就比较显然了呢？

这时候我们把大于 s* s 的那个部分乘上去就是答案了啊


# watch out, gift!

于是乎我们尝试把隔壁多项式多点求值的代码 copy 过来，然后 NTT 改成 FFT 准备交上去...

但是这里出现了一个关键性的问题...这里的数要取模...那么也就是任意模数 NTT ，那么我们不能单纯用 FFT 啊，精度炸了吧...于是我们用 ~~三模 NTT~~ MTT


咳咳，关于 MTT 的话，这里有个优化：[发明者应该是毛爷爷？](https://www.cnblogs.com/bztMinamoto/p/10653220.html)

然后我是看懵了（主要是代码里面写的是啥我根本对应不上啊...QWQ 我太菜了）



然后的话多点求值应该都会吧（我们上面说了把 根号个数带入多项式求值的丫）...不然左转模板区（好像这道题就是 板子？【雾 ）

这里注意一下，如果用了秦九韶算法优化多点求值会快一丢丢（大概会少个十分之一的时间），但是循环展开写的我想吐，硬生生多了这么多码量...于是懒癌晚期的我就用了最朴素的做法...

于是我们愉快（mmp） 地抄了一堆板子，交上去发现 T 得就剩一个点了耶 （人傻常数大.jpg）

# code

所以下面的代码仅供娱乐：
```
// luogu-judger-enable-o2
//by Judge
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
#define db double
using namespace std;
const db PI=acos(-1);
const int M=(1<<17)+3;
typedef int arr[M];
int n,s,res,mod,d,limit,r[19][M],lg[M]; db inv[19];
inline int Max(int x,int y){return x>y?x:y;}
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int qpow(int x,int p=mod-2,int s=1){
    for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
struct cp{ db x,y; cp(){} cp(db xx,db yy){x=xx,y=yy;}
    cp operator +(const cp& b)const{return cp(x+b.x,y+b.y);}
    cp operator -(const cp& b)const{return cp(x-b.x,y-b.y);}
    cp operator *(const cp& b)const{return cp(x*b.x-y*b.y,x*b.y+y*b.x);}
    cp operator *(const db& b)const{return cp(x*b,y*b);}
}w[2][M],x,y;
inline void prep(){
    fp(d,0,17){
        fp(i,1,(1<<d)-1) r[d][i]=(r[d][i>>1]>>1)|((i&1)<<(d-1));
        lg[1<<d]=d,inv[d]=(db)1.0/(1<<d);
    }
    for(int i=1,d=0;i<131072;i<<=1,++d) fp(k,0,i-1){
        w[1][i+k]=cp(cos(PI*k*inv[d]),sin(PI*k*inv[d]));
        w[0][i+k]=cp(cos(PI*k*inv[d]),-sin(PI*k*inv[d]));
    }
}
inline void FFT(cp* a,int tp){
    fp(i,0,limit-1) if(i<r[d][i]) swap(a[i],a[r[d][i]]);
    for(int mid=1;mid<limit;mid<<=1){
        for(int j=0;j<limit;j+=mid<<1)
            for(int k=0;k<mid;++k)
                x=a[j+k],y=w[tp][mid+k]*a[j+k+mid],
                a[j+k]=x+y,a[j+k+mid]=x-y;
    } if(tp) return ;
    fp(i,0,limit-1) a[i]=a[i]*inv[d];
}
inline void MTT(int* a,int* b,int len,int* c){
    limit=len<<1,d=lg[limit];
    static cp A[M],B[M],C[M],D[M],F[M],G[M],H[M];
    fp(i,0,len-1){
        A[i].x=a[i]>>16,B[i].x=a[i]&65535,
        C[i].x=b[i]>>16,D[i].x=b[i]&65535,
        A[i].y=B[i].y=C[i].y=D[i].y=0;
    } fp(i,len,limit-1) A[i]=B[i]=C[i]=D[i]=cp(0,0);
    FFT(A,1),FFT(B,1),FFT(C,1),FFT(D,1);
    fp(i,0,limit-1) F[i]=A[i]*C[i],G[i]=A[i]*D[i]+B[i]*C[i],H[i]=B[i]*D[i];
    FFT(F,0),FFT(G,0),FFT(H,0);
    fp(i,0,limit-1) c[i]=((((ll)(F[i].x+0.5)%mod<<16)%mod<<16)+((ll)(G[i].x+0.5)<<16)+((ll)(H[i].x+0.5)))%mod;
}
void get_inv(int* a,int* b,int n){
    if(n==1) return b[0]=qpow(a[0]),void();
    get_inv(a,b,n>>1); static int A[M],B[M];
    MTT(a,b,n,A),MTT(A,b,n,B);
    fp(i,0,n-1) b[i]=dec(inc(b[i],b[i]),B[i]);
}
struct node{ node *lc,*rc; vector<int> vec; int deg;
    inline void MOD(const int* a,int* r,int n){
        static int A[M],B[M],D[M]; int m=deg;
        for(limit=1;limit<n-m;limit<<=1);
        fp(i,0,n) A[i]=a[n-i]; fp(i,0,m) B[i]=vec[m-i];
        fp(i,n-deg+1,limit-1) B[i]=0; get_inv(B,D,limit);
        fp(i,n-m+1,limit-1) A[i]=D[i]=0;
        MTT(A,D,limit,A),reverse(A,A+n-m+1);
        for(limit=1;limit<=Max(n-m,m);limit<<=1);
        fp(i,0,m) B[i]=vec[i]; fp(i,m+1,limit-1) B[i]=0;
        fp(i,n-m+1,limit-1) A[i]=0; MTT(A,B,limit,A);
        fp(i,0,deg-1) r[i]=dec(a[i],A[i]);
    }
    inline void Mul(){ static int A[M],B[M];
        deg=lc->deg+rc->deg,vec.resize(deg+1); for(limit=1;limit<=deg;limit<<=1);
        fp(i,0,lc->deg) A[i]=lc->vec[i]; fp(i,lc->deg+1,limit-1) A[i]=0;
        fp(i,0,rc->deg) B[i]=rc->vec[i]; fp(i,rc->deg+1,limit-1) B[i]=0;
        MTT(A,B,limit,A);
        fp(i,0,deg) vec[i]=A[i];
    }
}pool[M],*rt,*RT;
int A[M],a[M],tot;
inline node* newnode(){return &pool[tot++];}
inline void solv(node* &p,int l,int r){ p=newnode();
    if(l==r) return p->deg=1,p->vec.resize(2),p->vec[0]=a[l],p->vec[1]=1,void();
    int mid=(l+r)>>1; solv(p->lc,l,mid),solv(p->rc,mid+1,r),p->Mul(); fp(i,0,p->deg) if(p->vec[i]<0) puts("!!!");
}
inline void calc(node* p,int l,int r,const int *A){
    if(r-l<=400){  //暴力秦九韶优化 
        fp(i,l,r){ int x=a[i],now=A[r-l];
            fd(j,r-l-1,0) now=inc(mul(now,x),A[j]);
            res=mul(res,now);
        } return ;
    } int mid=(l+r)>>1,b[p->deg+1]; // 一边取模一边递归  
    p->lc->MOD(A,b,p->deg-1),calc(p->lc,l,mid,b);
    p->rc->MOD(A,b,p->deg-1),calc(p->rc,mid+1,r,b);
}
int main(){ cin>>n>>mod,res=1,s=sqrt(n),prep();
    fp(i,1,s) a[i]=i-1; solv(RT,1,s);
    fp(i,1,s) a[i]=mod-((i-1)*s+1); solv(rt,1,s);
    fp(i,0,s) A[i]=RT->vec[i];
    rt->MOD(A,A,s);
    fp(i,1,s) a[i]=(i-1)*s+1;
    calc(rt,1,s,A);
    fp(i,s*s+1,n) res=mul(res,i);
    return !printf("%d\n",res);
}
```

又 $T$ 又 $RE$ $.jpg$


但是能过的代码也是有的：

（无耻的偷了大佬的代码）

```
//minamoto
#include<bits/stdc++.h>
#define R register
#define ll long long
#define III __int128
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
const int N=(1<<17)+5;const double Pi=acos(-1.0);
int P;III zero;
inline int add(R int x,R int y){return 1ll*x+y>=P?1ll*x+y-P:x+y;}
inline int dec(R int x,R int y){return 1ll*x-y<0?1ll*x-y+P:x-y;}
inline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}
int ksm(R int x,R int y){
    R int res=1;
    for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;
    return res;
}
struct cp{
    double x,y;
    cp(){}
    cp(R double xx,R double yy):x(xx),y(yy){}
    inline cp operator +(const cp &b)const{return cp(x+b.x,y+b.y);}
    inline cp operator -(const cp &b)const{return cp(x-b.x,y-b.y);}
    inline cp operator *(const cp &b)const{return cp(x*b.x-y*b.y,x*b.y+y*b.x);}
    inline cp operator *(const double &b)const{return cp(x*b,y*b);}
    inline cp operator ~()const{return cp(x,-y);}
}w[2][N];
int r[21][N],lg[N];double inv[21];
void Pre(){
    fp(d,0,17){
        fp(i,1,(1<<d)-1)r[d][i]=(r[d][i>>1]>>1)|((i&1)<<(d-1));
        lg[1<<d]=d,inv[d]=1.0/(1<<d);
    }
    for(R int i=1,d=0;i<131072;i<<=1,++d)fp(k,0,i-1){
        w[1][i+k]=cp(cos(Pi*k*inv[d]),sin(Pi*k*inv[d])),
        w[0][i+k]=cp(cos(Pi*k*inv[d]),-sin(Pi*k*inv[d]));
    }
}
int lim,d;
void FFT(cp *A,int ty){
    fp(i,0,lim-1)if(i<r[d][i])swap(A[i],A[r[d][i]]);
    cp t;
    for(R int mid=1;mid<lim;mid<<=1)
        for(R int j=0;j<lim;j+=(mid<<1))
            fp(k,0,mid-1)
                A[j+k+mid]=A[j+k]-(t=A[j+k+mid]*w[ty][mid+k]),
                A[j+k]=A[j+k]+t;
    if(!ty)fp(i,0,lim-1)A[i]=A[i]*inv[d];
}
void MTT(int *a,int *b,int len,int *c){
    static cp f[N],g[N],p[N],q[N];
    lim=(len<<1),d=lg[lim];
    fp(i,0,len-1)f[i]=cp(a[i]>>15,a[i]&32767),g[i]=cp(b[i]>>15,b[i]&32767);
    fp(i,len,lim-1)f[i]=g[i]=cp(0,0);
    FFT(f,1),FFT(g,1);
    fp(i,0,lim-1){
        cp t,f0,f1,g0,g1;
        t=~f[i?lim-i:0],f0=(f[i]-t)*cp(0,-0.5),f1=(f[i]+t)*0.5;
        t=~g[i?lim-i:0],g0=(g[i]-t)*cp(0,-0.5),g1=(g[i]+t)*0.5;
        p[i]=f1*g1,q[i]=f1*g0+f0*g1+f0*g0*cp(0,1);
    }
    FFT(p,0),FFT(q,0);
    fp(i,0,lim-1)c[i]=(((ll)(p[i].x+0.5)%P<<30)+((ll)(q[i].x+0.5)<<15)+((ll)(q[i].y+0.5)))%P;
}
void Inv(int *a,int *b,int len){
    if(len==1)return b[0]=ksm(a[0],P-2),void();
    Inv(a,b,len>>1);
    static int c[N],d[N];
    MTT(a,b,len,c),MTT(c,b,len,d);
    fp(i,0,len-1)b[i]=dec(add(b[i],b[i]),d[i]);
}
struct node{
    node *lc,*rc;vector<int>vec;int deg;
    void Mod(const int *a,int *r,int n){
        static int A[N],B[N],D[N];
        int len=1;while(len<=n-deg)len<<=1;
        fp(i,0,n)A[i]=a[n-i];fp(i,0,deg)B[i]=vec[deg-i];
        fp(i,n-deg+1,len-1)B[i]=0;
        Inv(B,D,len);
        fp(i,n-deg+1,len-1)A[i]=D[i]=0;
        MTT(A,D,len,A);
        reverse(A,A+n-deg+1);
        len=1;while(len<=max(n-deg,deg))len<<=1;
        fp(i,0,deg)B[i]=vec[i];fp(i,deg+1,len-1)B[i]=0;
        fp(i,n-deg+1,len-1)A[i]=0;
        MTT(A,B,len,A);
        fp(i,0,deg-1)r[i]=dec(a[i],A[i]);
    }
    void Mul(){
        static int A[N],B[N];deg=lc->deg+rc->deg,vec.resize(deg+1);
        int len=1;while(len<=max(lc->deg,rc->deg))len<<=1;
        fp(i,0,lc->deg)A[i]=lc->vec[i];fp(i,lc->deg+1,len-1)A[i]=0;
        fp(i,0,rc->deg)B[i]=rc->vec[i];fp(i,rc->deg+1,len-1)B[i]=0;
        MTT(A,B,len,A);
        fp(i,0,deg)vec[i]=A[i];
    }
}pool[N<<1],*rt,*qwq,*pp=pool;
int A[N],a[N];
void solve(node* &p,int l,int r){
    p=pp++;
    if(l==r)return p->deg=1,p->vec.resize(2),p->vec[0]=a[l],p->vec[1]=1,void();
    int mid=(l+r)>>1;
    solve(p->lc,l,mid),solve(p->rc,mid+1,r);
    p->Mul();
}
int b[25],res;
void calc(node *p,int l,int r,const int *A){
    if(r-l<=512){
        fp(i,l,r){
            int x=a[i],c1,c2,c3,c4,now=A[r-l];
            b[0]=1;fp(j,1,16)b[j]=mul(b[j-1],x);
            for(R int j=r-l-1;j-15>=0;j-=16){
                c1=(zero+1ll*now*b[16]+1ll*A[j]*b[15]+1ll*A[j-1]*b[14]+1ll*A[j-2]*b[13])%P,
                c2=(zero+1ll*A[j-3]*b[12]+1ll*A[j-4]*b[11]+1ll*A[j-5]*b[10]+1ll*A[j-6]*b[9])%P,
                c3=(zero+1ll*A[j-7]*b[8]+1ll*A[j-8]*b[7]+1ll*A[j-9]*b[6]+1ll*A[j-10]*b[5])%P,
                c4=(zero+1ll*A[j-11]*b[4]+1ll*A[j-12]*b[3]+1ll*A[j-13]*b[2]+1ll*A[j-14]*b[1])%P,
                now=(0ll+c1+c2+c3+c4+A[j-15])%P;
            }
            fd(j,(r-l)%16-1,0)now=(1ll*now*x+A[j])%P;
            res=mul(res,now);
        }
        return;
    }
    int mid=(l+r)>>1,b[p->deg+1];
    p->lc->Mod(A,b,p->deg-1),calc(p->lc,l,mid,b);
    p->rc->Mod(A,b,p->deg-1),calc(p->rc,mid+1,r,b);
}
int n,s;
int main(){
    scanf("%d%d",&n,&P),res=1,s=sqrt(n),Pre(),zero=0;
    fp(i,1,s)a[i]=i-1;solve(qwq,1,s);
    fp(i,1,s)a[i]=P-((i-1)*s+1);solve(rt,1,s);
    fp(i,0,s)A[i]=qwq->vec[i];
    rt->Mod(A,A,s);
    fp(i,1,s)a[i]=(i-1)*s+1;
    calc(rt,1,s,A);
    fp(i,s*s+1,n)res=mul(res,i);
    printf("%d\n",res);
    return 0;
}
```

话说这个 MTT 右移 15 位真的可以的么？或者是没有炸精度吧...，但你可以看到就算是卡常巨佬也只是艰难卡过...所以这个做法就...下一个！




# solve2

上一种做法...反正我是过不了的，惹不起惹不起...

于是我们考虑用另外一种神仙的倍增做法（虽说我并看不懂...）

所以可以看这位大仙的？[虽说里面有些打错的 $\LaTeX$公式就是了](https://www.cnblogs.com/bztMinamoto/p/10661226.html)

做法还是令 $F_s(x)=\prod_{i=1}^{s}(x+i)$

然后求出 $F_s(0,s,2s,...,s* s-s)$ ，然后重点就是要用倍增从 $F_d$ 得到 $F_{2d}$ ，然后做法我就是真的看不懂了QWQ 

貌似是这样的，我们要考虑两个东西：

1. 已知 $F_d(0,...,ds)$ 求 $F_{d+1}(0,...,(d+1)s)$

2. 已知 $F_d(0,...,ds)$ 求 $F_{2d}(0,...,2ds)$

**然后为了式子推导方便，我们在这里设 $G(x)=F_{d}(xs)$**

注意，上面的小括号内是个等差数列，公差为 s ，至于下面的 F 中的数列公差都是 s ， G 中的公差为 1

---

第一个很好求，直接  $F_{d+1}(x)=F_d(x)(x+d+1)$ 就好了，多出来的 $F_{d+1}((d+1)s)$ 暴力求

---

至于第二个就灰常麻烦了...


首先我们考虑 $F_d(0,...,ds)$ 到 $F_d(0,...,2ds)$ 的转移：

我们发现，前面 d 项我们已知了，所以也就是说我们要求出：$F_d((d+1)s,...,2ds)$

那么我们的人物也就是：

>已知 $F_d(0,...,ds)$ ，即 $G(1,...,d)$

>求 $F_d((d+1)s,...,2ds)$ ，即 $G(d+1,...,2d)$ 


---

然后我们考虑从 $F_d(0,...,2ds)$ 到 $F_{2d}(0,...,2ds)$的转移：



可以发现： $F_{2d}(xs)=F_d(xs)F_d(xs+d)$，也就是：

$$F_{2d}(xs)=G(x)G(x+{d\over s})$$


然后我们发现现在的任务是：

>已知 $F_d(0,...,2ds)$ ，即 $G(1,...,2d)$

>求 $F_d(d,...,2ds+d)$ ，即 $G(1+{d\over s} ,...,2d+{d\over s})$

我们发现上面两个  **已知...求...** 本质是一样的，都是 G 中加上了一个常数，也就是已知 $G(x)$ 求 $G(x+m)$ ，其中 m 是给定的常量

那么我们考虑怎么求出这个东西（当然是用多项式咯~）

用到之前说要用的拉格朗日插值法：

$$h(m+k)=\sum_{i=1}^nh(i)\prod_{j≠i} {m+k-j\over i-j}$$

$$=\Big(\prod_{j=0}^n (m+k-j)\Big)      \sum_{i=0}^d h{h(i)\over i!(d-i)! (-1)^{d-i}}{1\over m+k-i}$$

我们发现后面的表达式是卷积的形式啊...

至于后面的那个 n 是哪里来的，以及 i 为什么从 1 到 d 而不是 n 什么的就不管啦，找 bzt 大仙问去吧~（疯狂甩锅）


然后按 bzt 大仙说的：

首先这里的逆元是 O(n) 求的（来做这道题的人都知道）

其次就是卷积时要多项式平移...（这个诡异的科技...）

# Upd (4.23)

关于代码中 main 函数部分有一个判断...

这个判断是用了威尔逊定理优化的...

可以康康[我的blog](https://www.cnblogs.com/Judge/p/10755703.html)？

具体代码实现这里也有...

# code

明明不知道代码在写些啥还是无耻地贴了上来.jpg

```
//by Judge
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
#define db double
using namespace std;
const db PI=acos(-1);
const int M=(1<<17)+3;
typedef int arr[M];
int n,s,res,mod,d,limit; db iv[19];
arr r[19],lg,inv,ifac;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int inc(int x,int y){return 0ll+x+y>=mod?0ll+x+y-mod:x+y;}
inline int qpow(int x,int p=mod-2,int s=1){
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
struct cp{ db x,y; cp(){} cp(db xx,db yy){x=xx,y=yy;}
	cp operator +(const cp& b)const{return cp(x+b.x,y+b.y);}
	cp operator -(const cp& b)const{return cp(x-b.x,y-b.y);}
	cp operator *(const cp& b)const{return cp(x*b.x-y*b.y,x*b.y+y*b.x);}
	cp operator *(const db& b)const{return cp(x*b,y*b);}
	cp operator ~()const{return cp(x,-y);}
}w[2][M],x,y;
inline void prep(){
	fp(d,0,17){
		fp(i,1,(1<<d)-1) r[d][i]=(r[d][i>>1]>>1)|((i&1)<<(d-1));
		lg[1<<d]=d,iv[d]=(db)1.0/(1<<d);
	} inv[0]=inv[1]=ifac[0]=ifac[1]=1;
	fp(i,2,131072) inv[i]=mul(mod-mod/i,inv[mod%i]),ifac[i]=mul(ifac[i-1],inv[i]);
	for(int i=1,d=0;i<131072;i<<=1,++d) fp(k,0,i-1){
		w[1][i+k]=cp(cos(PI*k*iv[d]),sin(PI*k*iv[d]));
		w[0][i+k]=cp(cos(PI*k*iv[d]),-sin(PI*k*iv[d]));
	}
}
inline void prep(){ inv[0]=inv[1]=ifac[0]=ifac[1]=1;
	fp(d,0,17){ lg[1<<d]=d,iv[d]=(db)1.0/(1<<d);
		fp(i,1,(1<<d)-1) r[d][i]=(r[d][i>>1]>>1)|((i&1)<<(d-1));
	}
	fp(i,2,131072) inv[i]=mul(mod-mod/inv[mod%i]),ifac[i]=mul(ifac[i-1],inv[i]);
	for()
}
inline void FFT(cp* a,int tp){
	fp(i,0,limit-1) if(i<r[d][i]) swap(a[i],a[r[d][i]]);
	for(int mid=1;mid<limit;mid<<=1)
		for(int j=0;j<limit;j+=mid<<1) for(int k=0;k<mid;++k)
			x=a[j+k],y=w[tp][mid+k]*a[j+k+mid],a[j+k]=x+y,a[j+k+mid]=x-y;
	if(!tp) fp(i,0,limit-1) a[i]=a[i]*iv[d];
}
inline void MTT(int* a,int* b,int len,int* c){
	static cp f[M],g[M],p[M],q[M]; limit=len,d=lg[limit];
	fp(i,0,len-1) f[i]=cp(a[i]>>16,a[i]&65535),g[i]=cp(b[i]>>16,b[i]&65535);
	fp(i,len,limit-1) f[i]=g[i]=cp(0,0); FFT(f,1),FFT(g,1);
	fp(i,0,limit-1){ cp t,f0,f1,g0,g1;
		t=~f[i?limit-i:0],f0=(f[i]-t)*cp(0,-0.5),f1=(f[i]+t)*0.5;
		t=~g[i?limit-i:0],g0=(g[i]-t)*cp(0,-0.5),g1=(g[i]+t)*0.5;
		p[i]=f1*g1,q[i]=f1*g0+f0*g1+f0*g0*cp(0,1);
	} FFT(p,0),FFT(q,0);
	fp(i,0,limit-1) c[i]=((((ll)(p[i].x+0.5)%mod<<16)%mod<<16)+((ll)(q[i].x+0.5)<<16)+((ll)(q[i].y+0.5)))%mod;
}
inline void calc(int* a,int* b,int n,int k){
	static int f[M],g[M],h[M],sum[M],isum[M],len;
	for(len=1;len<=n<<1;len<<=1);
	fp(i,0,n) f[i]=mul(a[i],mul(ifac[i],ifac[n-i]));
	for(int i=n-1;i>=0;i-=2) f[i]=mod-f[i];
	int t=dec(k,n); fp(i,0,n<<1) g[i]=inc(i,t);
	sum[0]=g[0]; fp(i,1,n<<1) sum[i]=mul(sum[i-1],g[i]);
	isum[n+n]=qpow(sum[n+n]);
	fd(i,n<<1,1) isum[i-1]=mul(isum[i],g[i]);
	fp(i,1,n<<1) g[i]=mul(isum[i],sum[i-1]); g[0]=isum[0];
	fp(i,n+1,len-1) f[i]=0; fp(i,n<<1|1,len-1) g[i]=0;
	
	MTT(f,g,len,h);
	int  res=1,p1=k-n,p2=k;
	fp(i,p1,p2) res=mul(res,i);
	
	fp(i,0,n) g[i]=inc(mod,inc(p1,i));
	sum[0]=g[0]; fp(i,1,n) sum[i]=mul(sum[i-1],g[i]);
	isum[n]=qpow(sum[n]);
	fd(i,n,1) isum[i-1]=mul(isum[i],g[i]);
	fp(i,1,n) g[i]=mul(isum[i],sum[i-1]); g[0]=isum[0];
	
	for(int i=0;i<=n;++i,p2=inc(p2,1))
		b[i]=mul(h[i+n],res),res=mul(res,mul(g[i],p2+1));
}
inline int solv(int bl){ static int a[M],b[M];
	int s=0; for(int p=bl;p;p>>=1) ++s; a[0]=1,--s;
	int x=qpow(bl);
	for(int p=0;s>=0;--s){
		if(p){
			calc(a,b,p,p+1);
			fp(i,0,p) a[p+1+i]=b[i]; a[p<<1|1]=0;
			calc(a,b,p<<1,mul(p,x));
			p<<=1; fp(i,0,p) a[i]=mul(a[i],b[i]);
		}
		if(bl>>s&1){
			fp(i,0,p) a[i]=mul(a[i],inc(mul(bl,i),p+1));
			p|=1,a[p]=1;
			fp(i,1,p) a[p]=mul(a[p],inc(mul(bl,p),i));
		}
	} int res=1;
	fp(i,0,bl-1) res=mul(res,a[i]);
	return res;
}
inline int GetFac(int n){
	int s=sqrt(n),res=solv(s);
	fp(i,s*s+1,n) res=mul(res,i);
	return res;
}
int main(){ cin>>n>>mod,prep();
	if(n>mod-1-n){ int res=qpow(GetFac(mod-1-n));
		return !printf("%d\n",n&1?res:mod-res);
	} return !printf("%d\n",GetFac(n));
}
```


我太菜了.jpg




---

## 作者：Ruiqun2009 (赞：12)

~~相信很多人都想到了 $O(n)$ 的解法：连着乘。此做法可以查看 @bh1234666 的博客获得更多信息。~~

观察题目数据可以发现：本题需要一个低于 $O(n)$ 的解法。

我们先设 $s=\lfloor\sqrt n\rfloor$ 且 $f(x)=\prod_{i=1}^s{x+i}$，那么
$$
n!\equiv (\prod_{i=0}^{s-1}f(is))\times\prod_{i=s^2+1}^{n}i\pmod p
$$
其中 $\prod_{i=s^2+1}^{n}i$ 可在 $O(\sqrt n)$ 内完成。我们希望快速计算 $\prod_{i=0}^{s-1}f(is)$。

## $O(\sqrt n\log^2 n)$ 的做法

我们可以使用多项式连续点值平移在 $O(s\log s)$ 得到 $f(x)$ 的各项系数，但是通过多项式多点求值得到 $f(0),f(s),f(2s),\cdots,f(s^2-s)$ 需要 $O(s\log^2 s)$ 的时间复杂度。于是整体时间复杂度为 $O(\sqrt n\log^2 n)$。

## $O(\sqrt n\log n)$ 的做法

令 $f_j(x)=\prod_{i=1}^j(x+i)$。通过倍增即可求出 $\prod_{i=0}^{s-1}f(is)$。

- 倍增方程1（乘以 $2$）

$$
\begin{aligned}
f_{2j}(x)&=\prod_{i=1}^{2j}(x+i)\\
&=\prod_{i=1}^j(x+i)\times\prod_{i=j+1}^{2j}(x+i)\\
&=\prod_{i=1}^j(x+i)\times\prod_{i=1}^j(x+j+i)\\
&=f_j(x)\times f_j(j+x)
\end{aligned}
$$

现在看怎么计算。设 $g(x)=f_j(sx)$，则：

1. 现有的点值是 $g(0),g(1),\cdots,g(j)$（即 $f_j(0),f_j(s),\cdots,f_j(js)$）。
2. 通过多项式连续点值平移得到 $g(j+1),g(j+2),\cdots,g(2j+1)$（这里由于要求区间不重叠，会多平移出一个 $g(2j+1)$，否则会因为除以零寄掉）。
3. 将其拼接后得到 $g(0),g(1),\cdots,g(2j)$（即 $f_j(0),f_j(0+s),\cdots,f_j(0+2js)$）。
4. 再次经过平移后得到 $g(0+\dfrac{j}{s}),g(1+\dfrac{j}{s}),\cdots,g(2j+\dfrac{j}{s})$（即 $f_j(j),f_j(j+s),\cdots,f_j(j+2js)$）。
5. 乘起来即得 $f_{2j}(0),f_{2j}(s),\cdots,f_{2j}(2js)$。

- 倍增方程2（加上 $1$）

直接暴力点乘就可以了。
$$
\begin{aligned}
f_{j+1}(x)&=\prod_{i=1}^{j+1}(x+i)\\
&=\prod_{i=1}^j(x+i)\times(x+j+1)\\
&=f_j(x)\times(x+j+1)
\end{aligned}
$$

然后就可以倍增了。

我们只需要计算 $s$ 个点值，所以时间复杂度为 $O(s\log s)=O(\sqrt n\log n)$。

上代码：

```cpp
// dill
inline int solve(int n, int p) {
	static vector<int> f, fd, st;
	st.resize(log2(n) + 5);
	f.resize(2);
	int top = 0;
	int s = n;
	while (n) {
		st[++top] = n;
		n >>= 1;
	}
	n = st[top--];
	f[0] = 1;
	f[1] = s + 1;
	while (top--) {
		f.resize(f.size() << 1);
		LagrangeInterpolation_ex(n, n + 1, p, f, fd);
		std::copy(fd.begin(), fd.end(), f.begin() + n + 1);
		f[n << 1 | 1] = 0;
		int tmp = 1ll * n * fpow(s, p - 2, p) % p;
		n <<= 1;
		LagrangeInterpolation_ex(n, tmp, p, f, fd);
		for (int i = 0; i <= n; i++) {
			f[i] = 1ll * f[i] * fd[i] % p;
		}
		if (!(st[top + 1] & 1)) continue;
		for (int i = 0; i <= n; i++) {
			f[i] = 1ll * f[i] * (1ll * s * i % p + n + 1) % p;
		}
		f[++n] = 1;
		for (int i = 1; i <= n; i++) {
			f[n] = 1ll * f[n] * (1ll * s * n % p + i) % p;
		}
	}
	int res = f[0];
	for (int i = 1; i < s; i++) {
		res = 1ll * res * f[i] % p;
	}
	return res;
}
inline int factorial(int n, int p) {
	int tn = p - 1 - n;
	int res = 0;
	if (tn <= n) {
		res = fpow(factorial(tn, p), p - 2, p);
		return (tn & 1) ? res : p - res;
	}
	int k = sqrt(n);
	res = solve(k, p);
	for (int i = k * k + 1; i <= n; i++) {
		res = 1ll * res * i % p;
	}
	return res % p;
}
signed main() {
	int T, n, p;
	cin >> T;
	while (T--) {
		cin >> n >> p;
		cout << factorial(n, p) << endl;
	}
}
```

习题：

1. [阶乘模大质数](https://loj.ac/p/170)
2. [移数字](http://www.51nod.com/Challenge/Problem.html#problemId=1387)

---

## 作者：Afishinsea (赞：11)

### 声明：本题解非 $O(\sqrt{n}\log n)$ 正解，欲寻正解请勿参考此篇题解。

[**P5282 【模板】快速阶乘算法**](https://www.luogu.com.cn/problem/P5282)

有一天，$\mathrm{Afishinsea}$ 在随机跳题时跳到了这题，并惊喜地发现了[这篇暴力卡常题解](https://www.luogu.com.cn/article/rvzalhmb)，可惜的是，由于本题时限的修改，此篇题解再也无法通过（[证据](https://www.luogu.com.cn/record/174038243))，于是 $ta$ 决定尝试在不使用多项式的 $O(T\sqrt{n}\log n)/O(T\sqrt{n}\log^2 n)$ 做法卡常通过此题。

回归正题，题目求 $n!\ \mathrm{mod}\ p$ 其中 $n,p$ 均为 `int` 范围内的正整数， $p$ 为质数。

考虑对 $n!$ 质因数分解再乘起来：

对于质数 $p_i$ ，$1\sim n$ 中 $p_i$ 的倍数有 $\lfloor\frac{n}{p_i}\rfloor$ 个，$p_i^2$ 的倍数有 $\lfloor\frac{n}{p_i^2}\rfloor$ 个，$p_i^k$ 的倍数有 $\lfloor\frac{n}{p_i^k}\rfloor$ 个。

对于 $p_i$ ，我们可以先让最终答案乘以 $p_i^{\lfloor\frac{n}{p_i}\rfloor+\lfloor\frac{n}{p_i^2}\rfloor+\lfloor\frac{n}{p_i^3}\rfloor+...}$

说明：因为在计算 $p_i^k$ 的倍数的贡献之前已经计算完了 $p_i^j(j<k)$ 的贡献，故底数为 $p_i$ 而不是 $p_i^k$ 。

对于 $k\ge2$ ，因为直接算复杂度不高，比  $O(\sqrt{n})$ 略大，可以不优化，暴力计算贡献。

对于 $k=1$ ，注意到较大的质数中满足 $\frac{n}{p_i}=\frac{n}{p_j}$ 的 $(i,j)$ 较多（说白了就是可以数论分块），可以将贡献的计算表示为 $\prod\limits_{l\le r\wedge \frac{n}{p_l}=\frac{n}{p_r}} (p_l p_{l+1} ... p_r)^{\frac{n}{p_l}}$ ，配合快速幂，我们只需要预处理出 $\le n$ 的质数 $\mathrm{mod}\ p$ 的前缀积即可。

考虑到这些质数有 $O(\frac{n}{\log n})$ 个，暴力预处理需要 $O(T\frac{n}{\log n})$ 的时间，实际看大约是 $5\times10^8$ 次 `long long` 乘法+取模，因为取模开销较大，故使用 $\mathrm{Barrett}$ 约减进行常数优化（具体内容较为玄学，可自行搜索资料）。

如何得到这么多质数？显然，我们需要一个足够优化的质数筛，尽管理论上讲 $O(n)$ 的欧拉筛比 $O\Big(n\log\big(\log(n)\big)\Big)$ 的埃氏筛更为优秀，但埃氏筛的潜力更多，经过 $\mathrm{Wheel\ Factorization}$ 优化后的埃氏筛足以在 1000ms(实测洛谷 ide 在 C++14 with O2 的情况下大概筛了 600~700ms，实际以评测结果为准) 内筛完 $2^{30}$（约 $10^9$ ）以内的所有质数。其大致思想如下：

正常埃氏筛有一个忽略偶数的优化，我们可以同理推出 $3,5,7$ 等质数倍数的优化，本题代码中选取了 $3,5,7,11,13$ 进行筛选，对 $2$ 特殊处理。筛法具体实现上细节特别多且十分复杂，可以参考[这题](https://www.luogu.com.cn/problem/SP6489)的题解。

~~我把这道黑题成功转化成了另一道黑题~~

小技巧：

- 分多个块区间筛
- 手写 bitset
- 根据[威尔逊定理](https://oiwiki.com/math/number-theory/wilson/)，$n!\equiv (p-1)\times \big((p-1-n)!\times (-1)^{p-1-n}\big)^{-1} (\mathrm{mod}\ p)$ ，当 $n>p-1-n$ 时可以计算右式以代替左式，此时阶乘中的 $n\le \frac{p-1}{2}<2^{30}$ ，优化了一半常数。
- 存储前缀积时只存储下标为 $s$ 倍数的前缀积 $prod_i=\prod\limits_{j=1}^{si}p_i =p_1p_2...p_{si}$，可以一定程度优化空间使用，查询时对于没有存储的部分暴力 $O(s)$ 乘，代码中取 $s=64$ 方便位运算代替除法。

## code (码风玄学，望谅解)
```cpp

#include <bits/stdc++.h>
using namespace std;

namespace prime_sieve{
	using uint=unsigned int;
	using ullong=unsigned long long;
	template<const uint size=0ull>
	struct bitset{
		ullong data[(size-1>>6)+1];
		ullong pow[64]={
			0x1ull,0x2ull,0x4ull,0x8ull,
			0x10ull,0x20ull,0x40ull,0x80ull,
			0x100ull,0x200ull,0x400ull,0x800ull,
			0x1000ull,0x2000ull,0x4000ull,0x8000ull,
			0x10000ull,0x20000ull,0x40000ull,0x80000ull,
			0x100000ull,0x200000ull,0x400000ull,0x800000ull,
			0x1000000ull,0x2000000ull,0x4000000ull,0x8000000ull,
			0x10000000ull,0x20000000ull,0x40000000ull,0x80000000ull,
			0x100000000ull,0x200000000ull,0x400000000ull,0x800000000ull,
			0x1000000000ull,0x2000000000ull,0x4000000000ull,0x8000000000ull,
			0x10000000000ull,0x20000000000ull,0x40000000000ull,0x80000000000ull,
			0x100000000000ull,0x200000000000ull,0x400000000000ull,0x800000000000ull,
			0x1000000000000ull,0x2000000000000ull,0x4000000000000ull,0x8000000000000ull,
			0x10000000000000ull,0x20000000000000ull,0x40000000000000ull,0x80000000000000ull,
			0x100000000000000ull,0x200000000000000ull,0x400000000000000ull,0x800000000000000ull,
			0x1000000000000000ull,0x2000000000000000ull,0x4000000000000000ull,0x8000000000000000ull
		};
		inline bitset(const ullong &x=0){
			reset();
			data[0]=x;
		}
		inline bool operator [](const int &pos){
			return data[pos>>6]&pow[pos&63];
		}
		inline void set(const int &pos){
			data[pos>>6]|=pow[pos&63];
		}
		inline void reset(const int &pos){
			data[pos>>6]&=~pow[pos&63];
		}
		inline void set(){
			memset(data,0xff,sizeof(data));
		}
		inline void reset(){
			memset(data,0x00,sizeof(data));
		}
	};
	
	const int prime_tot=54400028;
	const int max_primes=160000;
	const int sieve_span=1<<22;
	const int sieve_words=sieve_span>>7;
	const int wheel_size=3*5*7*11*13;
	
	bitset<sieve_words<<6> sieve;
	bitset<wheel_size<<6> pattern;
	int primes[max_primes],mcnt;
	int all_prime[prime_tot+sieve_span],pcnt;
	
	inline void pre_sieve(){
		for(int i=3;i<1024;i+=2){
			if(!sieve[i>>1]){
				for(int j=(i*i>>1);j<(1<<20);j+=i){
					sieve.set(j);
				}
			}
		}
		for(int i=8;i<(1<<20);i++){
			if(!sieve[i]){
				primes[mcnt++]=i<<1|1;
			}
		}
	    for(int i=1;i<wheel_size<<6;i+=3) pattern.set(i);
	    for(int i=2;i<wheel_size<<6;i+=5) pattern.set(i);
	    for(int i=3;i<wheel_size<<6;i+=7) pattern.set(i);
	    for(int i=5;i<wheel_size<<6;i+=11) pattern.set(i);
	    for(int i=6;i<wheel_size<<6;i+=13) pattern.set(i);
	}
	
	inline void update_sieve(int base){
		int tmp=base%wheel_size;
	    tmp=(tmp+((tmp*105)&127)*wheel_size)>>7; // 105*wheel_size%128=127
	    for(int i=0,k;i<sieve_words;i+=k,tmp=0){
	        k=min(wheel_size-tmp,sieve_words-i);
	        memcpy(sieve.data+i,pattern.data+tmp,k<<3);
	    }
	    if(base==0){
	        sieve.data[0]|=1;
	        sieve.data[0]&=~(0b1101110);
	    }
	    for(int i=0;i<mcnt;i++){
	        long long j=primes[i]*primes[i];
	        if(j>base+sieve_span-1) break;
	        if(j>base) j=(j-base)>>1;
	        else{
	            j=primes[i]-base%primes[i];
	            if(!(j&1)) j+=primes[i];
	            j>>=1;
	        }
	        while(j<sieve_span>>1){
	            sieve.set(j);
	            j+=primes[i];
	        }
	    }
	}
	
	inline void segment_sieve(int base,int lim){
	    update_sieve(base);
	    int u=min(base+sieve_span,lim);
	    for(int i=0;i<sieve_words;i++){
	        ullong tmp=~sieve.data[i];
	        while(tmp){
	            int p=__builtin_ctzll(tmp);
	            int u=base+(i<<7)+(p<<1)+1;
	            if(u>=lim) break;
	            all_prime[pcnt++]=u;
	            tmp-=tmp&-tmp;
	        }
	    }
	}
	
	inline void fast_sieve(int lim) {
	    pre_sieve();
	    all_prime[pcnt++]=2;
	    for(int base=0;base<lim;base+=sieve_span){
	    	segment_sieve(base,lim);
		}
	}
	
    #define prime all_prime
}
using namespace std;
using ll=long long;
using ld=long double;
using prime_sieve::prime;
const int maxn=1<<30;
const int ptot=54400028;
int T,n[5],p[5]={1,1,1,1,1}; // 不读入默认模 1 避免 RE
struct node{
	ll v[5];
	inline node(int vv=0){
		v[0]=v[1]=v[2]=v[3]=v[4]=vv;
	}
} prod[(ptot>>6)+114];

inline void prod_init(){
	__uint128_t brt[5]; // barrett 约减
	brt[0]=((__uint128_t)1<<64)/p[0];
	brt[1]=((__uint128_t)1<<64)/p[1];
	brt[2]=((__uint128_t)1<<64)/p[2];
	brt[3]=((__uint128_t)1<<64)/p[3];
	brt[4]=((__uint128_t)1<<64)/p[4];
	
	prod[0]=node(2);
	for(int i=64;i<ptot;i+=64){
		prod[i>>6]=prod[(i>>6)-1];
		for(int j=i-63;j<=i;j++){
			prod[i>>6].v[0]=prod[i>>6].v[0]*prime[j];
			prod[i>>6].v[1]=prod[i>>6].v[1]*prime[j];
			prod[i>>6].v[2]=prod[i>>6].v[2]*prime[j];
			prod[i>>6].v[3]=prod[i>>6].v[3]*prime[j];
			prod[i>>6].v[4]=prod[i>>6].v[4]*prime[j];
			
			prod[i>>6].v[0]=prod[i>>6].v[0]-p[0]*(brt[0]*prod[i>>6].v[0]>>64);
			prod[i>>6].v[1]=prod[i>>6].v[1]-p[1]*(brt[1]*prod[i>>6].v[1]>>64);
			prod[i>>6].v[2]=prod[i>>6].v[2]-p[2]*(brt[2]*prod[i>>6].v[2]>>64);
			prod[i>>6].v[3]=prod[i>>6].v[3]-p[3]*(brt[3]*prod[i>>6].v[3]>>64);
			prod[i>>6].v[4]=prod[i>>6].v[4]-p[4]*(brt[4]*prod[i>>6].v[4]>>64);
			
			while(prod[i>>6].v[0]>=p[0]) prod[i>>6].v[0]-=p[0];
			while(prod[i>>6].v[1]>=p[1]) prod[i>>6].v[1]-=p[1];
			while(prod[i>>6].v[2]>=p[2]) prod[i>>6].v[2]-=p[2];
			while(prod[i>>6].v[3]>=p[3]) prod[i>>6].v[3]-=p[3];
			while(prod[i>>6].v[4]>=p[4]) prod[i>>6].v[4]-=p[4];
		}
	}
}

inline int get_prod(int u,int v){
	/*
	int r=1;
	for(int i=0;i<=v;i++){
		r=1ll*r*prime[i]%p[u];
	}
	return r;
	*/
	int ret=prod[v>>6].v[u];
	for(int i=1;i<=(v&63);i++){
		ret=(ll)ret*prime[i+((v>>6)<<6)]%p[u];
	}
	return ret;
}

inline ll quick_power(ll x,int y,int p){
	ll r=1;
	while(y){
		if(y&1) (r*=x)%=p;
		(x*=x)%=p,y>>=1;
	}
	return r;
}

inline ll factorial(int n,int u){
	ll ret=1;
	for(int i=0;prime[i]*prime[i]<=n;i++){
		ll j=prime[i]*prime[i];
		while(j<=n){
			(ret*=quick_power(prime[i],n/j,p[u]))%=p[u];
			j*=prime[i];
		}
	}
	int l=1,r;
	using prime_sieve::pcnt;
	while(l<=n){
		int r=n/(n/l);
		int p1=lower_bound(prime,prime+pcnt,l)-prime;
		int p2=upper_bound(prime,prime+pcnt,r)-1-prime;
		int pp1=p1?quick_power(get_prod(u,p1-1),n/l,p[u]):1;
		int pp2=~p2?quick_power(get_prod(u,p2),n/l,p[u]):1;
		(ret*=1ll*pp2*quick_power(pp1,p[u]-2,p[u])%p[u])%=p[u];
		l=r+1;
	}
	return ret;
}

inline int solve(int u){
	if(n[u]>=p[u]) return 0;
	else if(n[u]<=(p[u]-1-n[u])) return factorial(n[u],u);
	else return quick_power(factorial(p[u]-1-n[u],u),p[u]-2,p[u])*
				quick_power(p[u]-1,p[u]-n[u],p[u])%p[u]; // 威尔逊定理优化
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	prime_sieve::fast_sieve(maxn);
	//for(int i=0;i<=10;i++) cout<<prime[i]<<' '; cout<<endl;
	cin>>T;
	for(int i=0;i<T;i++){
		cin>>n[i]>>p[i];
	}
	prod_init();
	for(int i=0;i<T;i++){
		cout<<solve(i)<<'\n';
	}
	return 0;
}
```

~~洛谷的评测机太慢了，在 Atcoder 不用 Barrett 约减优化也不会 TLE~~

[提交记录（挺惊险的，感觉还可以再优化）](https://www.luogu.com.cn/record/174037793)

---

## 作者：Zi_Gao (赞：9)

改了一下第一篇题解的做法，不知道能不能在投一次题解。

发现首先根据 Wilson 定理：

$$
\begin{aligned}
(p-1) &\equiv -1 \pmod{p}\\
\prod_{i=1}^n i \prod_{i=1}^{p-1-n} (-i)&\equiv -1 \pmod{p}\\
n!(p-n-1)!(-1)^{p-n-1}&\equiv -1 \pmod{p}
\end{aligned}
$$

于是可以选择 $n$ 和 $p-n-1$ 中较小者来算，这样已经卡掉一半常数了。

然后第一篇题解实际上跑了三秒多，于是加一次循环展开，用两个向量 AVX2 变量存，一次加上 16。这样时间会减少 $40\%$，应该是并行计算了。

放下代码：

```cpp
#include<stdio.h>
#include<immintrin.h>

#define inl inline __attribute((always_inline)) 

#pragma GCC target("avx2")
//__m256i为AVX2指令集的整型变量 
static unsigned mod,r,n2_;
static __m256i a0,mod1,R,hi32,ans1,ans2,ml1,ml2,ad;
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	long long d=a;
	if(b==0) x=1,y=0;
	else d=exgcd(b,a%b,y,x),y-=a/b*x;
	return d;
}
inl unsigned mul(unsigned x,unsigned y)//蒙哥马利数域内的乘法及取模 
{
	unsigned long long z=(unsigned long long)x*y;//计算乘积 
	return (z+(unsigned long long)(unsigned(z)*r)*mod)>>32;//对p取模 
}
inl __m256i add(__m256i _num1,__m256i _num2)//将8个32位整数相加并取模 
{
	__m256i apb=_mm256_add_epi32(_num1,_num2),//将num1,num2内的8个整数对应相加 
	ret=_mm256_sub_epi32(apb,mod1);//将答案减去mod 
	__m256i cmp=_mm256_cmpgt_epi32(a0,ret),//得到答案内小于0的数 
	add=_mm256_and_si256(cmp,mod1);
	return _mm256_add_epi32(add,ret);//将小于0的数加mod 
}
inl __m256i mul(__m256i _num1,__m256i _num2)//将8个32位整数相乘并取模 
{
	__m256i _num3=_num1,_num4,_num5=_num2;
	_num2=_mm256_mul_epu32(_num1,_num2);//将偶数位的整数相乘（得到4个64位整数并放回） 
	_num1=_mm256_mul_epu32(_mm256_mul_epu32(_num2,R),mod1);
    _num4=_mm256_srli_epi64(_mm256_add_epi64(_num1,_num2),32);//每个64位整数均左移32位，空出高32位（奇数位） 
	_num1=_mm256_srli_si256(_num3,4);_num2=_mm256_srli_si256(_num5,4);//进行4字节位移，即将奇数位的整数移动到偶数位 
	_num2=_mm256_mul_epu32(_num1,_num2);//将原奇数位的整数相乘 
	_num1=_mm256_mul_epu32(_mm256_mul_epu32(_num2,R),mod1);
    _num1=_mm256_and_si256(_mm256_add_epi64(_num1,_num2),hi32);//通过跟hi32做与取出低32位（偶数位） 
    return _mm256_or_si256(_num1,_num4);//将偶数位乘积和奇数位乘积合并位一个AVX2变量返回 
}
inl unsigned mon_in(unsigned x){return mul(x,n2_);}//进入蒙哥马利数域 
inl unsigned mon_out(unsigned x)//离开蒙哥马利数域 
{unsigned ret=((x+(unsigned long long)(unsigned(x)*r)*mod)>>32);return ret<mod?ret:ret-mod;}
inl int solve(int n,int p)
{
	unsigned i=1;
	long long x,y;
	mod=p;
	n2_=-(unsigned long long)mod%mod;exgcd(mod,1ll<<32,x,y);r=-unsigned(x);//初始化一些蒙哥马利约减需要使用的变量
	a0=_mm256_setzero_si256(),//预处理全0的AVX2变量（做加法有用） 
	mod1=_mm256_set1_epi32(mod),R=_mm256_set1_epi32(r);//预处理全mod1,全r的AVX2变量 
	hi32=_mm256_set_epi32(-1,0,-1,0,-1,0,-1,0);//预处理奇数位全1的AVX2变量（做乘法有用） 
	ans1=_mm256_set1_epi32(mon_in(1));//初始化ans 
    ans2=_mm256_set1_epi32(mon_in(1));//初始化ans 
    
	ad=_mm256_set1_epi32(mon_in(16));//初始化全16的AVX2变量 
	ml1=_mm256_set_epi32(mon_in(8),mon_in(7),mon_in(6),mon_in(5),mon_in(4),mon_in(3),mon_in(2),mon_in(1));//初始化因数 
    ml2=_mm256_set_epi32(mon_in(16),mon_in(15),mon_in(14),mon_in(13),mon_in(12),mon_in(11),mon_in(10),mon_in(9));//初始化因数 
    
	for(;i+16<=n;i+=16)
	{
		ans1=mul(ans1,ml1);//将ans的16位与因数的16位依次相乘 
        ans2=mul(ans2,ml2);
        
		ml1=add(ml1,ad);//将因数16位全部加16 
        ml2=add(ml2,ad);
        
	}
	unsigned *fl1=(unsigned*)&ans1;
	unsigned as1=mul(mul(mul(fl1[0],fl1[1]),mul(fl1[2],fl1[3])),mul(mul(fl1[4],fl1[5]),mul(fl1[6],fl1[7])));//取出ans的8位并相乘 
    unsigned *fl2=(unsigned*)&ans2;
	unsigned as2=mul(mul(mul(fl2[0],fl2[1]),mul(fl2[2],fl2[3])),mul(mul(fl2[4],fl2[5]),mul(fl2[6],fl2[7])));
    
	unsigned as=mon_out(mul(as1,as2));//离开蒙哥马利数域 
	for(;i<=n;i++)//处理整段未做掉的末几位 
		as=1ull*as*i%mod;
    return as;
}


long long inv(long long n,long long p){
    long long x,y;
    exgcd(n,p,x,y);
    x%=p;
    return x>=0?x:x+p;
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n,p,res;
		scanf("%d%d",&n,&p);
        if(n<=p-1-n) res=solve(n,p);
        else{
            res=inv(solve(p-1-n,p),p);
            if((p-n)&1) res=p-res;
        }
        printf("%d\n",res);
	}
	return 0;
}
```

---

## 作者：Great_Influence (赞：9)

这道题的数据范围太小了，卡不掉 $O(\sqrt n \log^2 n)$ 的算法。

为了方便设 $v=\lfloor\sqrt n\rfloor$ 。

我们考虑将 $n!$ 拆开，设 $g_v(x)=\prod_{i=1}^v (x+i)$ ，则

$$n!=\prod_{i=v^2+1}^n i*\prod_{i=0}^{v-1}g_v(iv)$$

我们考虑将 $g_v$ 通过分治乘法求出，然后再用多点插值将每个点值插出来即可得到 $O(\sqrt n \log^2n)$ 的优秀算法。模数不对可以用 $MTT$ 实现。

一个 $\log$ 的算法就是用倍增维护 $g$ 的点值。具体做法可以参见 [$zzq$的博客](https://www.cnblogs.com/zzqsblog/p/8408691.html) 。

代码:
```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<iostream>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

const int MAXN=1<<17;

static int mod;

namespace poly
{
	inline int power(int u,int v)
	{
		register int sm=1;
		for(;v;v>>=1,u=(uint64)u*u%mod)if(v&1)
			sm=(uint64)sm*u%mod;
		return sm;
	}

	static int Len,rev[MAXN];

	static struct comp
	{
		double re,im;

		comp(){}

		comp(double _r,double _i):re(_r),im(_i){}

		comp operator+(const comp&a){return comp(re+a.re,im+a.im);}

		comp operator-(const comp&a){return comp(re-a.re,im-a.im);}

		comp operator*(const comp&a)
		{return comp(re*a.re-im*a.im,re*a.im+im*a.re);}

		comp operator/(const int&a){return comp(re/a,im/a);}
	}g[19][MAXN];

	namespace MTT
	{
		const double pi=acos(-1);

		inline void predone()
		{
			Rep(i,1,17)rep(j,0,1<<i)
				g[i][j]=comp(cos(2*pi*j/pow(2,i)),sin(2*pi*j/pow(2,i)));
		}

		inline void FFT(comp*F,int tl)
		{
			rep(i,0,Len)if(i<rev[i])swap(F[rev[i]],F[i]);
			for(register int i=2,ii=1,t=1;i<=Len;i<<=1,ii<<=1,++t)
				for(register int j=0;j<Len;j+=i)rep(k,0,ii)
				{
					comp x=F[j+k+ii]*g[t][k];
					F[j+k+ii]=F[j+k]-x;
					F[j+k]=F[j+k]+x;
				}
			if(tl==-1)
			{
				reverse(F+1,F+Len);
				rep(i,0,Len)F[i]=F[i]/Len;
			}
		}

		static comp Z[MAXN];

		inline void DBLFFT(comp*F,comp*G,int tl)
		{
			if(tl==1)
			{
				memcpy(Z,F,sizeof(comp)*Len);
				FFT(Z,1);
				memcpy(F,Z,sizeof(comp)*Len);
				reverse(F+1,F+Len);
				rep(i,0,Len)F[i].im=-F[i].im;
				rep(i,0,Len)G[i]=(Z[i]-F[i])/2,F[i]=(Z[i]+F[i])/2
					,swap(G[i].re,G[i].im),G[i].im=-G[i].im;
			}
			else
			{
				rep(i,0,Len)F[i]=comp(F[i].re-G[i].im,F[i].im+G[i].re);
				FFT(F,-1);
				rep(i,0,Len)G[i]=comp(F[i].im,0),F[i]=comp(F[i].re,0);
			}
		}
	}
	using MTT::predone;
	using MTT::DBLFFT;
	using MTT::FFT;

	inline void calrev()
	{
		int II=log(Len)/log(2)-1;
		Rep(i,1,Len-1)rev[i]=rev[i>>1]>>1|(i&1)<<II;
	}

	inline int ad(int u,int v)
	{return ((unsigned)u+v>=mod?(unsigned)u+v-mod:u+v);}

	static int X[MAXN],Y[MAXN],Iv[MAXN],mlx[MAXN];

	static comp A[MAXN],B[MAXN],C[MAXN],D[MAXN];

	inline void mul(int*F,int*G,int*H,int lenl,int lenr)
	{
		if((ll)lenl*lenr<=300)
		{
			Rep(i,0,lenl+lenr)mlx[i]=0;
			Rep(i,0,lenl)Rep(j,0,lenr)
				mlx[i+j]=(mlx[i+j]+(ll)F[i]*G[j])%mod;
			Rep(i,0,lenl+lenr)H[i]=mlx[i];
			return;
		}
		for(Len=2;Len<=lenl+lenr;Len<<=1);
		calrev();
		rep(i,0,Len)A[i]=i<=lenl?comp(F[i]>>15,F[i]&32767):comp(0,0),
			C[i]=i<=lenr?comp(G[i]>>15,G[i]&32767):comp(0,0);
		DBLFFT(A,B,1),DBLFFT(C,D,1);
		rep(i,0,Len)
		{
			register comp t=A[i];
			A[i]=B[i]*C[i]+A[i]*D[i];
			B[i]=B[i]*D[i];
			C[i]=C[i]*t;
		}
		DBLFFT(A,B,-1),FFT(C,-1);
		rep(i,0,Len)
		{
			register int lz=((((ll)floor(C[i].re+0.5))%mod<<30)%mod
				 +((ll)floor(A[i].re+0.5))%mod*32768+(ll)floor(B[i].re+0.5))%mod;
			H[i]=i<=lenl+lenr?lz:0;
		}
	}

	inline void Inv(int*F,int*G,int ln)
	{
		Iv[0]=power(F[0],mod-2);
		for(register int Ln=2;Ln>>1<=ln;Ln<<=1)
		{
			rep(i,ln+1,Ln)F[i]=0;
			rep(i,0,Ln)X[i]=F[i],Y[i]=0;
			rep(i,0,(Ln>>1))Y[i]=Iv[i];
			mul(Y,X,X,(Ln>>1)-1,Ln-1),--X[0];
			mul(X,Y,X,Ln-1,(Ln>>1)-1);
			rep(i,(Ln>>1),Ln)Iv[i]=mod-X[i];
		}
		Rep(i,0,ln)G[i]=Iv[i];
	}

	static int ExX[MAXN],ExY[MAXN];

	inline void Div(int*F,int*G,int*Q,int*R,int lenf,int leng)
	{
		Rep(i,0,lenf)ExX[i]=F[lenf-i];
		Rep(i,0,leng)ExY[i]=G[leng-i];
		Rep(i,leng+1,lenf-leng)ExY[i]=0;
		Inv(ExY,ExY,lenf-leng);
		Rep(i,lenf-leng+1,lenf)ExX[i]=0;
		Rep(i,lenf-leng+1,leng)ExY[i]=0;
		mul(ExX,ExY,ExY,lenf-leng,lenf-leng);
		Rep(i,lenf-leng+1,(lenf-leng)<<1)ExY[i]=0;
		Rep(i,0,(lenf-leng)>>1)swap(ExY[i],ExY[lenf-leng-i]);
		mul(ExY,G,ExX,lenf-leng,leng);
		assert(F[leng]==ExX[leng]);
		Rep(i,0,leng-1)R[i]=ad(F[i],mod-ExX[i]);
		Rep(i,0,lenf-leng)Q[i]=ExY[i];
	}

	namespace Extend
	{
		static int solv[18][2][MAXN];

		void calc(int*a,int l,int r,int lev,int dir)
		{
			if(l==r)
			{
				solv[lev][dir][0]=mod-a[l];
				solv[lev][dir][1]=1;return;
			}
			int md=(l+r)>>1;
			calc(a,l,md,lev+1,0),calc(a,md+1,r,lev+1,1);
			mul(solv[lev+1][0],solv[lev+1][1],solv[lev][dir],md-l+1,r-md);
		}

		static int pol[18][MAXN],Q[MAXN];
		
		void getnum(int*a,int*ans,int l,int r,int lev,int n)
		{
			if(n>r-l)
			{
				calc(a,l,r,0,0);
				Div(pol[lev-(lev>0)],solv[0][0],Q,pol[lev],n,r-l+1);
				n=r-l;
			}
			else if(lev){Rep(i,0,n)pol[lev][i]=pol[lev-1][i];}
			if(l==r)
			{
				ans[l]=pol[lev][0];
				return;
			}
			int md=(l+r)>>1;
			getnum(a,ans,l,md,lev+1,n);
			getnum(a,ans,md+1,r,lev+1,n);
		}
	}
}
using poly::power;
using poly::predone;
using poly::ad;
using poly::Extend::pol;
using poly::Extend::getnum;
using poly::Extend::calc;
using poly::Extend::solv;

static int n,Z[MAXN],as[MAXN];

int main()
{
	file();
	predone();
	read(n),read(mod);
	int v=sqrt(n);
	Rep(i,1,v)Z[i]=mod-i;
	calc(Z,1,v,0,0);
	memcpy(pol[0],solv[0][0],sizeof(int)*(v+1));
	Rep(i,1,v)Z[i]=(i-1)*v;
	getnum(Z,as,1,v,0,v);
	static int ans=1;
	Rep(i,1,v)ans=(ll)ans*as[i]%mod;
	Rep(i,v*v+1,n)ans=(ll)ans*i%mod;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Nuisdete (赞：3)

考虑分块的思想，把 $n!$ 拆成 $\sqrt n$ 个连续段来求解，设 $m = \sqrt n$。

那么设多项式 

$$f_d(x) = \prod_{i = 1}^m (x + i)$$

那么相当于我们只需要求出来 $f_m(0), f_m(m), f_m(2m), \cdots f_m(m^2)$ 这题就做完了。

有一个双 $\log$ 做法就是直接分治 FFT 求出来 $f_m(x)$，然后多点求值。

单 $\log$ 做法可以考虑倍增。

考虑通过 $f_d(0), f_d(m), \cdots, f_d(dm)$，求 $f_{2d}(0), f_{2d}(m), \cdots, f_{2d}(2dm)$。

根据 $f_{2d}(km) = f_d(km)f_d(km + d)$，可以套用两次 [拉格朗日插值2](https://www.luogu.com.cn/problem/P5667) 的思路就可以实现了。

时间复杂度 $\mathcal{O}(\sqrt n \log n)$。

代码写太丑了，常数太大，不放了。

---

## 作者：OldDriverTree (赞：0)

# Solution

考虑分块，令 $m=\lfloor\sqrt n\rfloor$，$f(n,x)=\sum\limits_{i=1}^n (x+i)$，我们要求的是 $f(m,0),f(m,m),\dots,f(m,m^2)$。

一种暴力的做法是分治求出 $f(m,x)$ 的多项式，然后直接跑多项式多点求值，用脚维护，不需要任何脑子，但是时间复杂度 $O(T\sqrt m\log^2 m)$，这并不优雅。

考虑倍增，并动态维护 $f(n,0),\dots,f(n,nm)$（因为 $f(n,x)$ 是 $n$ 次多项式，所以考虑维护 $n+1$ 个点值）。

把 $n$ 变为 $n+1$ 是简单的，考虑如何做 $n$ 变为 $2n$，首先有 $f(2n,xm)=f(n,xm)f(n,xm+n)$，然后我们需要求出 $f(n,0),\dots,f(n,2nm)$ 和 $f(n,n),f(n,2nm+n)$，注意到要求的这两个东西都是等差数列，且公差与维护的点值公差都为 $n$，因此考虑把 $x$ 都除以 $n$，然后跑两次 [拉格朗日插值2](https://www.luogu.com.cn/problem/P5667) 即可。

注意不保证模数可以 $\text{NTT}$，因此要跑 [任意模数多项式乘法](https://www.luogu.com.cn/problem/P4245)

时间复杂度是 $T(m)=T\left(\dfrac m2\right)+O(m\log m)$，$T(m)$ 显然就为 $O(m\log m)$，因此总时间复杂度是 $O(T\sqrt m\log m)$。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
//using mint=modint998244353;
const long double Pi=acos(-1.0);
using poly=vector<int>;
int mod,tot,rev[1<<20];

struct Complex {
    long double x,y;
    Complex operator +(Complex o)const { return {x+o.x,y+o.y}; }
    Complex operator -(Complex o)const { return {x-o.x,y-o.y}; }
    Complex operator *(Complex o)const { return {x*o.x-y*o.y,x*o.y+y*o.x}; }
}A[1<<20],B[1<<20],C[1<<20],D[1<<20];

struct custom_hash
{
    static uint64_t splitmix64(uint64_t x) {
        x+=0x9e3779b97f4a7c15;
        x=(x^(x>>30) )*0xbf58476d1ce4e5b9;
        x=(x^(x>>27) )*0x94d049bb133111eb;
        return x^(x>>31);
    }
    size_t operator() (uint64_t x) const {
        static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x+FIXED_RANDOM);
    }
};
int read() {
    int x=0; bool _=true; char c=0;
    while (!isdigit(c) ) _&=(c!='-'),c=getchar();
    while (isdigit(c) ) x=x*10+(c&15),c=getchar();
    return _?x:-x;
}
int power(int a,int b=mod-2)
{
    int res=1;
    while (b) {
        if (b&1) res=res*a%mod;
        a=a*a%mod,b>>=1;
    }
    return res;
}
void FFT(Complex *a)
{
    for (int i=0;i<tot;i++)
    if (i<rev[i]) swap(a[i],a[rev[i] ]);
    for (int len=1;len<tot;len<<=1)
    {
        Complex w={cos(Pi/len),sin(Pi/len)};
        for (int i=0;i<tot;i+=len<<1) {
            Complex wk={1,0},x,y; for (int j=0;j<len;j++,wk=wk*w)
            x=a[i|j],y=a[i|len|j]*wk,a[i|j]=x+y,a[i|len|j]=x-y;
        }
    }
}
void IFFT(Complex *a) {
    FFT(a),reverse(a+1,a+tot);
    for (int i=0;i<tot;i++) a[i].x/=tot,a[i].y/=tot;
}
poly mul(poly a,poly b)
{
    int n=a.size()+b.size()-1; tot=1;
    int l=-1; while (tot<n) tot<<=1,l++;
    for (int i=0;i<tot;i++) A[i]=B[i]={0,0};
    for (int i=0;i<tot;i++) rev[i]=rev[i>>1]>>1|(i&1)<<l;
    for (int i=0;i<a.size();i++) A[i]={a[i]>>16,a[i]&65535};
    for (int i=0;i<b.size();i++) B[i]={b[i]>>16,b[i]&65535};
    FFT(A); for (int i=0;i<tot;i++) C[i]=A[(tot-i)%tot],C[i].y*=-1;
    FFT(B); for (int i=0;i<tot;i++) D[i]=B[(tot-i)%tot],D[i].y*=-1;
    for (int i=0;i<tot;i++) {
        auto x=A[i],y=B[i],p=C[i],q=D[i];
        A[i]=(p+x)*(q+y)*(Complex){0.25,0}+(p+x)*(q-y)*(Complex){-0.25,0};
        B[i]=(p-x)*(q+y)*(Complex){0,0.25}+(p-x)*(q-y)*(Complex){0,-0.25};
    }
    IFFT(A),IFFT(B),a.resize(n);
    for (int i=0;i<n;i++) {
        int x=round(A[i].x),y=round(A[i].y+B[i].x),z=round(B[i].y);
        a[i]=( (x%mod<<32)+(y%mod<<16)+z)%mod;
    }
    return a;
}
poly Lagrange(poly a,int l,int r)
{
    int m=a.size(); poly b;
    poly fact(r-l+m+1),ifact(r-l+m+1);
    if (l<m) {
        b.resize(r-l+1);
        for (int i=0;l+i<m&&l+i<=r;i++) b[i]=a[l+i];
        if (r<m) return b; poly c=Lagrange(a,m,r);
        for (int i=m;i<=r;i++) b[i-l]=c[i-m]; return b;
    }
    b.resize(r-l+m),fact[0]=ifact[0]=ifact[1]=1;
    for (int i=2;i<m;i++) ifact[i]=ifact[mod%i]*(mod-mod/i)%mod;
    for (int i=1;i<m;i++) ifact[i]=ifact[i-1]*ifact[i]%mod;
    for (int i=0;i<m;i++) {
        a[i]=a[i]*ifact[i]%mod*ifact[m-i-1]%mod;
        if ( (m-i-1)&1) a[i]=(mod-a[i])%mod;
    }
    for (int i=1;i<=r-l+m;i++) fact[i]=fact[i-1]*(i+l-m)%mod;
    ifact[r-l+m]=power(fact[r-l+m]);
    for (int i=r-l+m;i;i--) ifact[i-1]=ifact[i]*(i+l-m)%mod;
    for (int i=0;i<r-l+m;i++) b[i]=ifact[i+1]*fact[i]%mod;
    a=mul(a,b),b.resize(r-l+1); for (int i=0;i<=r-l;i++)
    b[i]=a[i+m-1]*fact[i+m]%mod*ifact[i]%mod; return b;
}
main()
{
    int T=read(),n;
    while (T--)
    {
        n=read(),mod=read(); int m=sqrt(n),res=1;
        poly a(2); a[0]=1,a[1]=(m+1)%mod;
        for (int i=__lg(m)-1,n=1;~i;i--)
        {
            int tmp=n*power(m)%mod; n<<=1;
            poly b=Lagrange(a,0,n),c=Lagrange(a,tmp,min(tmp+n,mod-1) );
            if (tmp+n>=mod) { poly d=Lagrange(a,0,(tmp+n)%mod); for (int x:d) c.push_back(x); }
            a.resize(n+1); for (int i=0;i<=n;i++) a[i]=b[i]*c[i]%mod;
            if (m>>i&1) {
                int val=1; n++;
                for (int i=0;i<n;i++)
                a[i]=a[i]*(i*m+n)%mod,
                val=val*(n*m+i+1)%mod;
                a.push_back(val);
            }
        }
        for (int i=0;i<m;i++) res=res*a[i]%mod;
        for (int i=m*m+1;i<=n;i++) res=res*i%mod;
        printf("%lld\n",res);
    }
    return 0;
}
```

---


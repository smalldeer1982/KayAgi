# 调和级数求和

## 题目描述

给定 $n,p$，求：

$$\sum_{i=1}^n \frac 1i $$

对 $p$ 取模的值。

如果你不知道怎么对分数取模，可以看[这题](https://www.luogu.com.cn/problem/P2613)。  
保证答案在模 $p$ 意义下存在。

为了方便你的计算，这里将给出 $p$ 的最小原根 $g$。

## 说明/提示

【数据范围】  
对于 $30\%$ 的数据，$1\le n \le 10^6$；  
对于 $100\%$ 的数据，$1 \le n < p < 2^{30}$，$1\le T \le 20$。  
保证 $p$ 为质数，且 $p-1$ 可以被 $2^{19}$ 整除。

注：时限为 std 的三倍，如果过不去请确认时间复杂度正确，并优化常数。

## 样例 #1

### 输入

```
5
998007 998244353 3
19260817 998244353 3
274829164 998244353 3
792846153 998244353 3
1924762 899678209 7```

### 输出

```
429767635
632288905
445668022
128133635
3097708```

# 题解

## 作者：Weng_Weijie (赞：16)

## 前言

去我的博客里看可能体验会更好。

如果真的决定要做这个题，建议先去做一下 P5282 快速阶乘算法。

这个算法（包括阶乘算法、调和数算法、组合数前缀和算法）都由 $\text{min\_25}$ 最先提出，具体可以看他的[博客](https://min-25.hatenablog.com)。

## 思路

总体的思路是：先分块，然后快速算出每一块内的倒数和。

首先构造函数：

$$h(x)=\sum_{i=1}^m\dfrac 1{x+i}$$

其中 $m=\mathrm O(\sqrt{n})$。

我们希望求出 $f(0), f(m), \ldots, f(m^2)$，这样就算出了大块内的总和，剩下的一部分直接暴力即可。

然而这个 $h(x)$ 并不是多项式，我们根本没办法表示它。

于是我们将 $h(x)$ 通分。

$$h(x)=\dfrac{\sum_i\prod_{j\neq i}(x+j)}{\prod_i(x+i)}$$

于是令

$$g(x)=\sum_{i=1}^m\prod_{j\neq i}(x+j)$$

$$f(x)=\prod_{i=1}^m(x+i)$$

那么 $h(x)=\dfrac{g(x)}{f(x)}$。

此时便可以直接使用多点求值的做法达到 $\mathrm O(\sqrt n\log^2n)$，但是应该无法通过。

## 优化

我们设 $f_t(x)=\displaystyle\prod_{i=1}^t(x+i)$， $g_t(x)$ 同理。

发现我们并不需要 $f, g$ 的每一项系数，只需要它在一些位置上的点值。

再设 $F_t=(f_t(0), f_t(m),\dots f_t(tm))$，$G_t$ 同理。

因为 $f_t(x)$ 是一个 $t$ 次多项式，因此 $F_t$ 是 $f_t(x)$ 的一个点值表示。

观察到：

$$f_{2t}(x)=f_t(x)f_t(x+t)$$

$$g_{2t}(x)=f_t(x)g_t(x+t)+f_t(x+t)g_t(x)$$

我们希望在已知 $F_t, G_t$ 的情况下，求出 $F_{2t}, G_{2t}$，这样就可以倍增求出 $F_m, G_m$，从而达成目标。

接下来以 $f$ 为例，$g$ 也是类似的。

在求 $f_{2t}(x)$ 时需要知道 $f_{t}(x), f_{t}(x+t)$，因此求 $F_{2t}$ 需要对每一个 $0\leq x\leq 2t$，求出 $f_t(mx)$ 和 $f_t{(mx+t)}$。

如果令 $p_t(x)=f_t(mx)$，那么 $F_t=(p(0),p(1),\ldots,p(t))$，$f_t(mx)=p_t(x), f_t(mx+t)=p_t\left(x+\dfrac tm\right)$。

如果我们在已知 $p(0),p(1),\ldots,p(t)$ 的情况下求出 $p(k),p(1+k),\ldots,p(t+k)$，那么就可以令 $k=t+1$ 先求出 $p(t+1),\ldots,p(2t)$，再令 $k=\dfrac tm$，求出需要的所有值。

事实上，由 $\text{Lagrange}$ 插值法：

$$p(x+k)=\sum_{i=0}^tp(i)\prod_{j\neq i}\dfrac{x+k-j}{i-j}$$

$$=\sum_{i=0}^t\dfrac {p(i)(-1)^{t-i}}{i!(t-i)!}\cdot \prod_{j\neq i} (x+k-j)$$

$$=\dfrac{(x+k)!}{(x+k-t-1)!}\sum_{i=0}^t\dfrac{p(i)(-1)^{t-i}}{i!(t-i)!}\cdot\dfrac{1}{x-i+k}$$

可以看到右边是一个卷积的形式，可以用 $\text{FFT}$ 实现。

可以证明不会出现没有逆元的情况（？不知道我有没有伪证）。

因此我们可以由 $F_t, G_t$ 得到 $F_{2t}, G_{2t}$，而得到 $F_{t+1}, G_{t+1}$ 是比较简单的（留给读者思考），这样倍增算出 $F_m, G_m$，就能得到大块内部的倒数和。

因此我们解决了整个问题，总复杂度 $O(\sqrt n\log n)$。

## 其他

在算阶乘时我们使用了威尔逊定理使 $n$ 的范围，缩小了一半，而在这题里可以发现 $H_n=H_{\mathrm{mod}-n-1}$，也达到了一样的效果。

在算逆元的时候强烈推荐使用离线求逆元（快速幂求逆元 $n$ 次有时会比两次左右的 $\mathrm{FFT}$ 慢）。

## 代码
```cpp
#include <bits/stdc++.h>

typedef long long LL;
typedef unsigned long long ULL;

const int N = 131072;

int mod, mod_g, factor[N], ifactor[N];

void reduce(int &x) { x += x >> 31 & mod; }
int pow(int x, int y, int ans = 1) {
	for (; y; y >>= 1, x = (LL) x * x % mod)
		if (y & 1) ans = (LL) ans * x % mod;
	return ans;
}

void init(int n) {
	factor[0] = 1;
	for (int i = 1; i <= n; ++i)
		factor[i] = (LL) factor[i - 1] * i % mod;
	ifactor[n] = pow(factor[n], mod - 2);
	for (int i = n; i; --i)
		ifactor[i - 1] = (LL) ifactor[i] * i % mod;
}

int wn[N], w[N], lim, s, rev[N];
void fftinit(int len) {
	wn[0] = lim = 1, s = -1; while (lim < len) lim <<= 1, ++s;
	for (int i = 1; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
	const int w = pow(mod_g, (mod - 1) / lim);
	for (int i = 1; i < lim; ++i) wn[i] = (LL) wn[i - 1] * w % mod;
}
void fft(int *A, int typ) {
	static ULL tmp[N];
	for (int i = 0; i < lim; ++i) tmp[rev[i]] = A[i];
	for (int i = 1; i < lim; i <<= 1) {
		for (int j = 0, t = lim / i / 2; j < i; ++j) w[j] = wn[j * t];
		for (int j = 0; j < lim; j += i << 1)
			for (int k = 0; k < i; ++k) {
				const ULL x = tmp[k + j + i] * w[k] % mod;
				tmp[k + j + i] = tmp[k + j] + mod - x, tmp[k + j] += x;
			}
	}
	for (int i = 0; i < lim; ++i) A[i] = tmp[i] % mod;
	if (!typ) {
		const int il = pow(lim, mod - 2); std::reverse(A + 1, A + lim);
		for (int i = 0; i < lim; ++i) A[i] = (LL) A[i] * il % mod;
	}
}

void clear(int *a) { std::memset(a, 0, lim << 2); }
void copy(int *a, int *b, int n) { std::memcpy(a, b, n + 1 << 2); }
void multiply(int *a, int *b, int *c) {
	fft(a, 1), fft(b, 1);
	for (int i = 0; i < lim; ++i) c[i] = (LL) a[i] * b[i] % mod;
	fft(c, 0);
}
void poly_shift(int *f, int n, int *g, int k) {
	static int a[N], b[N], q[N]; fftinit(n + n + 1), clear(a), clear(b);
	for (int i = 0; i <= n; ++i) a[i] = (LL) f[i] * ifactor[i] % mod * ifactor[n - i] % mod;
	for (int i = n - 1; i >= 0; i -= 2) a[i] = mod - a[i];
	
	b[0] = k - n;
	for (int i = 1; i <= 2 * n; ++i) b[i] = (LL) b[i - 1] * (k + i - n) % mod;
	q[2 * n] = pow(b[2 * n], mod - 2);
	for (int i = 2 * n; i; --i) q[i - 1] = (LL) q[i] * (k + i - n) % mod;
	for (int i = 2 * n; i; --i) b[i] = (LL) q[i] * b[i - 1] % mod; b[0] = q[0];
	
	multiply(a, b, a);
	static int suf[N], isuf[N]; suf[2 * n + 1] = 1;
	for (int i = 2 * n; ~i; --i)
		suf[i] = (LL) suf[i + 1] * (i + k - n) % mod;
	isuf[0] = pow(suf[0], mod - 2);
	for (int i = 0; i <= 2 * n; ++i)
		isuf[i + 1] = (LL) isuf[i] * (i + k - n) % mod;
	for (int i = 0; i <= n; ++i) {
		if ((i + k) % mod <= n) g[i] = f[(i + k) % mod];
		else g[i] = (LL) isuf[i + n + 1] * a[i + n] % mod * suf[i] % mod;
	}
}

int n, size, f[N], g[N];

void boom(int n) {
	static int a[N], b[N], c[N], d[N];
	poly_shift(f, n, a, n + 1);
	for (int i = 1; i <= n; ++i) f[n + i] = a[i - 1];
	poly_shift(f, 2 * n, b, pow(size, mod - 2, n));
	poly_shift(g, n, c, n + 1);
	for (int i = 1; i <= n; ++i) g[n + i] = c[i - 1];
	poly_shift(g, 2 * n, d, pow(size, mod - 2, n));
	for (int i = 0; i <= 2 * n; ++i) {
		g[i] = ((LL) g[i] * b[i] + (LL) d[i] * f[i]) % mod;
		f[i] = (LL) f[i] * b[i] % mod;
	}
}
void qaq(int n) {
	f[n + 1] = g[n + 1] = 1;
	int tmp = 1, x = (n + 1) * size % mod;
	for (int i = 1; i <= n; ++i)
		f[n + 1] = (LL) f[n + 1] * (x + i) % mod;
	for (int i = 2; i <= n; ++i) {
		tmp = tmp * (x + i - 1LL) % mod;
		g[n + 1] = ((LL) g[n + 1] * (x + i) + tmp) % mod;
	}
	for (int i = 0; i <= n + 1; ++i) {
		x = (LL) i * size % mod;
		g[i] = (g[i] * (x + n + 1LL) + f[i]) % mod;
		f[i] = f[i] * (x + n + 1LL) % mod;
	}
}

void solve(int n) {
	if (n == 1) {f[1] = size + 1, f[0] = g[0] = g[1] = 1; return;}
	solve(n >> 1), boom(n >> 1); if (n & 1) qaq(n - 1);
}

int solve() {
	if (!n) return 0; int ans = 0;
	size = std::sqrt(n), init(size), solve(size);
	int x = 0, y = 1;
	for (int i = 0; i < size; ++i)
		x = ((LL) f[i] * x + (LL) y * g[i]) % mod, y = (LL) y * f[i] % mod;
	for (int i = size * size + 1; i <= n; ++i)
		x = ((LL) i * x + y) % mod, y = (LL) i * y % mod;
	return pow(y, mod - 2, x);
}

void test() {
	std::cin >> n >> mod >> mod_g, n = std::min(n, mod - n - 1);
	std::cout << solve() << '\n';
}

int main() {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	int tc; std::cin >> tc; while (tc--) test();
	return 0;
}
```



---

## 作者：hly1204 (赞：7)

这里给出一种简单的理解方式，使用 [P5282 【模板】快速阶乘算法](https://www.luogu.com.cn/problem/P5282) 中的算法稍加改写即可。认为在同余素数 $p$ 意义下运算，下文省略了同余符号。

引用了很多 Min\_25 博客中的公式，加了一些自己的解释，如有错误感谢指出！

#### 矩阵描述

首先我们将阶乘使用矩阵表示如

$$
\begin{bmatrix}
n!
\end{bmatrix}
=\left(
\prod _ {i=0}^{n-1}
\begin{bmatrix}i+1\end{bmatrix}
\right)
\begin{bmatrix}
1
\end{bmatrix}
$$

本题中记调和数 $H_n=\sum _ {k=1}^n\frac{1}{k}$ 且 $0\lt n\lt p$ 改写为矩阵有

$$
\begin{bmatrix}
(n+1)!\\(n+1)!H _ {n+1}
\end{bmatrix}=
\begin{bmatrix}
n+1&0\\1&n+1
\end{bmatrix}
\begin{bmatrix}
n!\\n!H_n
\end{bmatrix}
$$

那么

$$
\begin{bmatrix}
{n+1\brack 1}\\{n+1\brack 2}
\end{bmatrix}=
\begin{bmatrix}
n!\\n!H_n
\end{bmatrix}=
\left(
\prod _ {i=0}^{n-1}
\begin{bmatrix}
i+1&0\\1&i+1
\end{bmatrix}
\right)
\begin{bmatrix}
1\\0
\end{bmatrix}
$$

在这里 ${n+1\brack 1}$ 和 ${n+1\brack 2}$ 为第一类无符号斯特林数，本题某种意义上可以认为是求这两列斯特林数远处的某个点值。

注意乘法的大运算符都表示矩阵“左乘”，我们取 $v=\left\lfloor \sqrt{n}\right\rfloor$ 并维护

$$
\begin{aligned}
\mathbf{M} _ d(x)&=
\prod _ {i=1}^{d}
\begin{bmatrix}
x+i&0\\1&x+i
\end{bmatrix}\\
&=
\begin{bmatrix}
g_d(x)&0\\h_d(x)&g_d(x)
\end{bmatrix}
\end{aligned}
$$

的点值 $\mathbf{M} _ d(0),\mathbf{M} _ d(v),\dots $ 即 $g_d(x),h_d(x)$ 的点值 $g_d(0),g_d(v),\dots $ 和 $h_d(0),h_d(v),\dots $ ，而

$$
\begin{aligned}
\mathbf{M} _ {2d}(x)&=
\mathbf{M} _ d(x+d)\mathbf{M} _ d(x)\\
&=
\begin{bmatrix}
g_d(x+d)&0\\h_d(x+d)&g_d(x+d)
\end{bmatrix}
\begin{bmatrix}
g_d(x)&0\\h_d(x)&g_d(x)
\end{bmatrix}\\
&=
\begin{bmatrix}
g_d(x)g_d(x+d)&0\\h_d(x+d)g_d(x)+g_d(x+d)h_d(x)&g_d(x)g_d(x+d)
\end{bmatrix}
\end{aligned}
$$

已经导出了整个算法。在实际编写时使用 $v=2^{\lceil \log_2(\sqrt{n})\rceil}$ ，最差的情况 $v\approx 2\sqrt{n}$ 只是常数影响，此时不需要由 $\mathbf{M} _ d(x)$ 的点值计算 $\mathbf{M} _ {d+1}(x)$ 的点值，若希望计算 $h _ d(x)$ 和 $g _ d(x)$ 某 *一个* 点值而非平移点值，之前的拉格朗日插值公式也给出了一个经典的线性做法。

我们在求出 $\mathbf{M} _ v(0),\mathbf{M} _ v(v),\dots $ 后有

$$
\begin{bmatrix}
(kv)!\\(kv)!H _ {kv}
\end{bmatrix}=
\begin{bmatrix}
g_v(kv-v)&0\\h_v(kv-v)&g_v(kv-v)
\end{bmatrix}
\dots 
\begin{bmatrix}
g_v(v)&0\\h_v(v)&g_v(v)
\end{bmatrix}
\begin{bmatrix}
g_v(0)&0\\h_v(0)&g_v(0)
\end{bmatrix}
\begin{bmatrix}
1\\0
\end{bmatrix}
$$

因为 $v^2\geq n$ 所以令 $kv\leq n$ 且 $kv$ 尽可能大，那么剩余的项 $n-kv=O(\sqrt n)$ 所以使用上述矩阵乘法模拟后求一次逆元即可，前面的点值的倍增与平移同 [P5282 【模板】快速阶乘算法](https://www.luogu.com.cn/problem/P5282) 中的一样为 $O(\sqrt{n}\log n)$ 时间。

#### 基本扩展

$$
\begin{bmatrix}
!n\\!(n+1)
\end{bmatrix}
=\left(
\prod _ {i=0}^{n-1}
\begin{bmatrix}
0&1\\i+1&i+1
\end{bmatrix}
\right)
\begin{bmatrix}
1\\0
\end{bmatrix}
$$

其中 $!n=n!\sum _ {k=0}^n\frac{(-1)^k}{k!}$ 是错位排列 $n$ 个物品的方案数（即 $\forall i$ 满足第 $i$ 个物品不在第 $i$ 个位置）。

$$
\begin{bmatrix}
!n\\(-1)^{n+1}
\end{bmatrix}
=\left(
\prod _ {i=0}^{n-1}
\begin{bmatrix}
i+1&1\\0&-1
\end{bmatrix}
\right)
\begin{bmatrix}
1\\-1
\end{bmatrix}
$$

$$
\begin{bmatrix}
(n+1)!\\\sum _ {i=0}^ni!
\end{bmatrix}
=\left(
\prod _ {i=0}^{n}
\begin{bmatrix}
i+1&0\\1&1
\end{bmatrix}
\right)
\begin{bmatrix}
1\\0
\end{bmatrix}
$$

$$
\begin{aligned}
\begin{bmatrix}
\binom{n}{m+1}\\
\sum _ {i=0}^m\binom{n}{i}
\end{bmatrix}
&=\left(
\prod _ {i=0}^{m}
\begin{bmatrix}
(n-i)/(i+1)&0\\1&1
\end{bmatrix}
\right)
\begin{bmatrix}
1\\0
\end{bmatrix}\\
&=
\frac{1}{(m+1)!}
\left(
\prod _ {i=0}^{m}
\begin{bmatrix}
n-i&0\\i+1&i+1
\end{bmatrix}
\right)
\begin{bmatrix}
1\\0
\end{bmatrix}
\end{aligned}
$$

#### 参考文献

- Min\_25 的[博客](http://min-25.hatenablog.com/entry/2017/04/10/215046)（已被删除）
- Alin Bostan, Pierrick Gaudry, and Eric Schost. Linear recurrences with polynomial coefficients and application to integer factorization and Cartier-Manin operator.

---

## 作者：Ruiqun2009 (赞：1)

~~相信很多人都想到了 $O(n)$ 的解法：线性处理逆元，然后计算。此做法可以通过 [$\color{#000000}30$](#quvvx52t) 分。~~

观察题目数据发现：本题需要一个低于 $O(n)$ 的解法。

我们先设 $s=\lfloor\sqrt{n}\rfloor$ 且 $h(x)=\sum_{i=1}^s\dfrac{1}{x+i}$，那么
$$
\sum_{i=1}^n\dfrac{1}{n}\equiv(\sum_{i=0}^{s-1}h(is))+\sum_{i=s^2+1}^{n}\dfrac{1}{i}\pmod p
$$


其中 $\sum_{i=s^2+1}^{n}\dfrac{1}{i}$ 可在 $O(s)$ 内完成。我们希望快速计算 $\sum_{i=0}^{s-1}h(is)$。

然而这个 $h(x)$ 根本就不是整式。我们试着将其通分：
$$
\begin{aligned}
h(x)&=\sum_{i=1}^s\dfrac{1}{x+i}\\
&=\dfrac{\sum_{i=1}^s\prod_{j\neq i}x+j}{\prod_{i=1}^{s}x+i}
\end{aligned}
$$
然后我们设分母为 $f(x)$，分子为 $g(x)$。于是我们成功地将非整式转换成了两个整式。

## $O(\sqrt n\log^2 n)$ 的做法

我们可以使用多项式连续点值平移在 $O(s\log s)$ 的时间复杂度内得到 $f(x)$ 和 $g(x)$ 的各项系数，但是通过多项式多点求值得到 $f(0),f(s),f(2s),\cdots,f(s^2-s)$ 有 $O(s\log^2 s)$ 的时间复杂度，$g(x)$ 同理。

于是总时间复杂度为 $O(s\log^2 s)=O(\sqrt n\log^2 n)$。

## $O(\sqrt n\log n)$ 的做法

令 $f_t(x)=\sum_{i=1}^{t}x+i,g_t(x)=\sum_{i=1}^t\prod_{j\neq i}x+j$。通过倍增即可求出 $f(0),f(s),f(2s),\cdots,f(s^2-s)$ 以及 $g(0),g(s),g(2s),\cdots,g(s^2-s)$。

试试倍增？

- 倍增方程1（乘以 $2$)

$$
\begin{aligned}
f_{2t}(x)&=f_t(x)\times f_t(t+x)\\
g_{2t}(x)&=\sum_{i=1}^{2t}\prod_{j\neq i}x+j\\
&=\sum_{i=1}^{t}\prod_{j\neq i}(x+j)\times\prod_{i=j+1}^{2j}(x+i)+\sum_{i=t+1}^{2t}\prod_{j\neq i}(x+j)\times\prod_{i=1}^{j}(x+j)\\
&=g_t(x)f_t(t+x)+\sum_{i=1}^{t}\prod_{j\neq i}(x+t+i)\times f_t(x)\\
&=g_t(x)f_t(t+x)+g_t(t+x)f_t(x)
\end{aligned}
$$

现在看怎么计算。设 $F(x)=f_t(sx),G(x)=g_t(sx)$，则：

1. 现有的点值是 $F(0), F(1), \cdots, F(j)$（即 $f_j(0), f_j(s),\cdots,f_j(js)$）和 $G(0), G(1), \cdots, G(j)$（即 $g_j(0), g_j(s),\cdots,g_j(js)$）
2. 通过多项式连续点值平移得到 $F(j+1), F(j+2), \cdots, F(2j+1)$ 以及 $G(j+1), G(j+2), \cdots, G(2j+1)$（这里由于要求区间不重叠，会多平移出一个 $F(2j+1)$ 和 $G(2j+1)$，否则会因为除以零寄掉）。
3. 将其拼接后得到 $F(0), F(1),\cdots,F(2j)$（即 $f_j(0), f_j(0+s),\cdots,f_j(2js)$）和 $G(0), G(1),\cdots,G(2j)$（即 $g_j(0), g_j(0+s),\cdots,g_j(2js)$）
4. 再次经过平移后得到 $F(0+\dfrac{j}{s}), F(1\dfrac{j}{s}),\cdots,F(2j\dfrac{j}{s})$（即 $f_j(j), f_j(j+s),\cdots,f_j(j+2js)$）和 $G(0+\dfrac{j}{s}), G(1\dfrac{j}{s}),\cdots,G(2j\dfrac{j}{s})$（即 $g_j(j), g_j(j+s),\cdots,g_j(j+2js)$）。
5. 乘起来即得 $f_{2j}(0),f_{2j}(s),\cdots,f_{2j}(2js)$ 和 $g_{2j}(0),g_{2j}(s),\cdots,g_{2j}(2js)$。

- 倍增方程2（加上 $1$）

$$
\begin{aligned}
f_{t+1}(x)&=f_t(x)\times (x+t+1)\\
g_{t+1}(x)&=\sum_{i=1}^{t+1}\prod_{j\neq i}x+j\\
&=\sum_{i=1}^{t}\prod_{j\neq i}(x+j)\times\prod_{i=t+1}^{t+1}(x+i)+\sum_{i=t+1}^{t+1}\prod_{j\neq i}(x+j)\times\prod_{i=1}^{t}(x+i)\\
&=g_t(x)\times(x+t+1)+f_t(x)
\end{aligned}
$$

然后就可以倍增了。

我们只需要计算 $s$ 个点值，所以时间复杂度为 $O(s\log s)=O(\sqrt n\log n)$。

### 优化

1. 由于我们在平移时已经计算出了 $g_t(2t+1)$ 的值，所以如果要加上 $1$，可以直接使用这个值。
2. 根据威尔逊定理，我们得到 $h(x)=h(p-x-1)$。这意味着我们可以将常数减半。

上代码：

```cpp
inline int harmonic(int n, int p) {
	(n > p - n - 1) && (n = p - n - 1);
	vector<int> mc[2], md[2];
	int pos = 0, s = sqrt(n) + 1e-6;
	mc[0].reserve(s);
	mc[1].reserve(s);
	md[0].reserve(s);
	md[1].reserve(s);
	int invs = fpow(s, p - 2, p);
	static vector<int> st;
	st.resize((int)log2(s) + 5);
	for (int i = s; i > 1; i >>= 1) {
		st[++pos] = i;
	}
	mc[0].resize(2);
	mc[1].resize(2);
	mc[0][0] = mc[1][0] = mc[1][1] = 1;
	mc[0][1] = s + 1;
	for (int l = st[pos]; pos; l = st[--pos]) {
        LagrangeInterpolation_ex(l >> 1, (l >> 1) + 1, p, mc[0], md[0]);
        mc[0].resize(mc[0].size() << 1);
        std::copy(md[0].begin(), md[0].end(), mc[0].begin() + md[0].size());
        LagrangeInterpolation_ex(mc[0].size() - 1, bt(1ll * invs * (l >> 1), p), p, mc[0], md[0]);
        LagrangeInterpolation_ex(l >> 1, (l >> 1) + 1, p, mc[1], md[1]);
        mc[1].resize(mc[1].size() << 1);
        std::copy(md[1].begin(), md[1].end(), mc[1].begin() + md[1].size());
        LagrangeInterpolation_ex(mc[1].size() - 1, bt(1ll * invs * (l >> 1), p), p, mc[1], md[1]);
		for (int i = (int)mc[0].size() - 1; ~i; i--) {
			mc[1][i] = bt(bt(1ll * mc[1][i] * md[0][i], p) + bt(1ll * mc[0][i] * md[1][i], p), p);
			mc[0][i] = bt(1ll * mc[0][i] * md[0][i], p);
		}
		if (l & 1) {
			for (int i = 0, x; i <= l; i++) {
				x = bt(bt(1ll * i * s, p) + l, p);
				mc[1][i] = bt(bt(1ll * mc[1][i] * x, p) + mc[0][i], p);
				mc[0][i] = bt(1ll * mc[0][i] * x, p);
			}
		}
		else {
			mc[0].resize(l + 1);
			mc[1].resize(l + 1);
		}
	}
	int res1 = 1, res2 = 0;
	for (int i = 0; i < s; i++) {
		res2 = bt(bt(1ll * res1 * mc[1][i], p) + bt(1ll * res2 * mc[0][i], p), p);
		res1 = bt(1ll * res1 * mc[0][i], p);
	}
	for (int i = s * s + 1; i <= n; i++) {
		int x = i;
		res2 = bt(res1 + bt(1ll * x * res2, p), p);
		res1 = bt(1ll * x * res1, p);
	}
	return bt(1ll * fpow(res1, p - 2, p) * res2, p);
}
int main() {
	int T, n, p;
	std::cin.tie(NULL)->sync_with_stdio(false);
	std::cin >> T;
	while (T--) {
		std::cin >> n >> p >> NTT::G;
		brt = ((unsigned __int128)1 << 64) / p; // 这题不用 barrett 取模约减 NTT 过不了
		NTT::invG = fpow(NTT::G, p - 2, p);
		NTT::mod = p;
		std::cout << harmonic(n, p) << std::endl;
	}
}
```

---

## 作者：OldDriverTree (赞：0)

# Solution

首先你要会 [快速阶乘算法](https://www.luogu.com.cn/article/oi3hwra5)。

然后考虑本题怎么做，按照上面那道题的套路，我们令 $f(n,x)=\sum\limits_{i=1}^n\dfrac 1{x+i}$，但是这个东西很抽象，不太能直接维护，因此我们可以考虑维护这个东西的分子和分母，即：$f(n,x)=\sum\limits_{i=1}^n\prod\limits_{i\neq j} (x+j)$，$g(n,x)=\prod\limits_{i=1}^n (x+i)$。

然后倍增维护，$n\to n+1$ 是简单的，考虑 $n\to 2n$ 怎么做，首先有 $f(2n,xm)=f(n,xm)g(n,xm+n)+f(n,xm+n)g(n,xm),g(2n,xm)=g(n,xm)g(n,xm+n)$，因此直接跑四次 [拉格朗日插值2](https://www.luogu.com.cn/problem/P5667) 求出这些东西即可。

总时间复杂度 $O(T\sqrt n\log n)$。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
//using mint=modint998244353;
using poly=vector<int>;
int mod,G,tot,rev[1<<21];

struct custom_hash
{
    static uint64_t splitmix64(uint64_t x) {
        x+=0x9e3779b97f4a7c15;
        x=(x^(x>>30) )*0xbf58476d1ce4e5b9;
        x=(x^(x>>27) )*0x94d049bb133111eb;
        return x^(x>>31);
    }
    size_t operator() (uint64_t x) const {
        static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x+FIXED_RANDOM);
    }
};
int read() {
    int x=0; bool _=true; char c=0;
    while (!isdigit(c) ) _&=(c!='-'),c=getchar();
    while (isdigit(c) ) x=x*10+(c&15),c=getchar();
    return _?x:-x;
}
int power(int a,int b=mod-2)
{
    int res=1;
    while (b) {
        if (b&1) res=res*a%mod;
        a=a*a%mod,b>>=1;
    }
    return res;
}
void init(int n) {
    tot=1; int l=-1; while (tot<n) tot<<=1,l++;
    for (int i=0;i<tot;i++) rev[i]=rev[i>>1]>>1|(i&1)<<l;
}
void NTT(poly &a)
{
    for (int i=0;i<tot;i++)
    if (i<rev[i]) swap(a[i],a[rev[i] ]);
    for (int len=1;len<tot;len<<=1) {
        int g=power(G,(mod-1)/(len<<1) );
        for (int i=0;i<tot;i+=len<<1)
            for (int j=0,gk=1,x,y;j<len;j++,gk=gk*g%mod)
                x=a[i|j],y=a[i|len|j]*gk%mod,a[i|j]=(x+y)%mod,a[i|len|j]=(x-y+mod)%mod;
    }
}
void INTT(poly &a) {
    NTT(a),reverse(a.begin()+1,a.end() );
    int inv=power(tot); for (int &x:a) x=x*inv%mod;
}
poly diff(const poly &a) {
    poly b(a.size()-1);
    for (int i=1;i<a.size();i++)
    b[i-1]=a[i]*i%mod; return b;
}
poly integ(const poly &a) {
    poly b(a.size()+1);
    for (int i=1;i<b.size();i++)
    b[i]=a[i-1]*power(i)%mod; return b;
}
poly add(poly a,poly b) {
    if (a.size()<b.size() ) swap(a,b);
    for (int i=0;i<b.size();i++) a[i]=(a[i]+b[i])%mod;
    return a;
}
poly sub(poly a,poly b) {
    for (int &x:b) x=(mod-x)%mod;
    return add(a,b);
}
poly mul(poly a,int k) {
    for (int &x:a) x=x*k%mod;
    return a;
}
poly mul(poly a,poly b) {
    int n=a.size()+b.size()-1; init(n),a.resize(tot),b.resize(tot);
    NTT(a),NTT(b); for (int i=0;i<tot;i++) a[i]=a[i]*b[i]%mod;
    INTT(a),a.resize(n); return a;
}
poly inv(const poly &a)
{
    poly b(1); b[0]=power(a[0]);
    while (b.size()<a.size() ) {
        int n=min(2*b.size(),a.size() );
        init(2*n),b.resize(tot); poly c(tot);
        for (int i=0;i<n;i++) c[i]=a[i];
        NTT(b),NTT(c); for (int i=0;i<tot;i++)
        b[i]=(2-b[i]*c[i]%mod+mod)*b[i]%mod;
        INTT(b),b.resize(n);
    }
    return b;
}
poly div(poly a,poly b) {
    if (a.size()<b.size() ) return {}; //注意这里
    int n=a.size()-b.size()+1;
    reverse(a.begin(),a.end() );
    reverse(b.begin(),b.end() );
    a.resize(n),b.resize(n);
    poly c=mul(a,inv(b) ); c.resize(n);
    return reverse(c.begin(),c.end() ),c;
}
poly Mod(poly a,poly b) {
    poly c=mul(b,div(a,b) );
    a=sub(a,c),a.resize(b.size()-1);
    return a;
}
poly sqrt(const poly &a)
{
    poly b(1); b[0]=1;
    int inv2=(mod+1)>>1;
    while (b.size()<a.size() ) {
        int n=min(2*b.size(),a.size() );
        poly c(n); for (int i=0;i<n;i++) c[i]=a[i];
        poly d(n); for (int i=0;i<b.size();i++) d[i]=b[i];
        b=add(d,mul(c,inv(d) ) ),b.resize(n);
        for (int &x:b) x=x*inv2%mod;
    }
    return b;
}
poly ln(const poly &a) {
    poly b=integ(mul(diff(a),inv(a) ) );
    return b.resize(a.size() ),b;
}
poly exp(const poly &a)
{
    poly b(1); b[0]=1;
    while (b.size()<a.size() ) {
        int n=min(2*b.size(),a.size() );
        poly c(n); for (int i=0;i<b.size();i++) c[i]=b[i];
        c=ln(c); for (int i=0;i<n;i++) c[i]=(a[i]-c[i]+mod)%mod;
        c[0]++,b=mul(b,c),b.resize(n);
    }
    return b;
}
poly power(poly a,int k) {
    return exp(mul(ln(a),k) );
}
poly Lagrange(poly a,int l,int r)
{
    int m=a.size(); poly b;
    poly fact(r-l+m+1),ifact(r-l+m+1);
    if (l<m) {
        b.resize(r-l+1);
        for (int i=0;l+i<m&&l+i<=r;i++) b[i]=a[l+i];
        if (r<m) return b; poly c=Lagrange(a,m,r);
        for (int i=m;i<=r;i++) b[i-l]=c[i-m]; return b;
    }
    b.resize(r-l+m),fact[0]=ifact[0]=ifact[1]=1;
    for (int i=2;i<m;i++) ifact[i]=ifact[mod%i]*(mod-mod/i)%mod;
    for (int i=1;i<m;i++) ifact[i]=ifact[i-1]*ifact[i]%mod;
    for (int i=0;i<m;i++) {
        a[i]=a[i]*ifact[i]%mod*ifact[m-i-1]%mod;
        if ( (m-i-1)&1) a[i]=(mod-a[i])%mod;
    }
    for (int i=1;i<=r-l+m;i++) fact[i]=fact[i-1]*(i+l-m)%mod;
    ifact[r-l+m]=power(fact[r-l+m]);
    for (int i=r-l+m;i;i--) ifact[i-1]=ifact[i]*(i+l-m)%mod;
    for (int i=0;i<r-l+m;i++) b[i]=ifact[i+1]*fact[i]%mod;
    a=mul(a,b),b.resize(r-l+1); for (int i=0;i<=r-l;i++)
    b[i]=a[i+m-1]*fact[i+m]%mod*ifact[i]%mod; return b;
}
poly MultiPoint(poly f,poly a)
{
    vector<poly> T; poly b;
    auto mulT=[&](poly a,poly b)->poly {
        int n=a.size(),m=b.size();
        reverse(b.begin(),b.end() ),b=mul(a,b),a.resize(n-m+1);
        for (int i=0;i<=n-m;i++) a[i]=b[m+i-1]; return a;
    };
    auto solve=[&](int rt,int l,int r,auto &&self) {
        if (l==r) return T[rt]={1,(mod-a[l])%mod},void();
        self(rt<<1,l,mid,self),self(rt<<1|1,mid+1,r,self);
        T[rt]=mul(T[rt<<1],T[rt<<1|1]);
    };
    auto Solve=[&](int rt,int l,int r,poly a,auto &&self) {
        if (l==r) return b[l]=a[0],void();
        self(rt<<1,l,mid,mulT(a,T[rt<<1|1]),self);
        self(rt<<1|1,mid+1,r,mulT(a,T[rt<<1]),self);
    };
    int n=max(f.size(),a.size() ),m=a.size();
    f.resize(n<<1),a.resize(n),b.resize(n),T.resize(n<<2);
    solve(1,0,n-1,solve),Solve(1,0,n-1,mulT(f,inv(T[1]) ),Solve);
    return b.resize(m),b;
}
poly Interpolate(poly a,poly b)
{
    vector<poly> T; T.resize(a.size()<<2);
    auto solve=[&](int rt,int l,int r,auto &&self) {
        if (l==r) return T[rt]={(mod-a[l]),1},void();
        self(rt<<1,l,mid,self),self(rt<<1|1,mid+1,r,self);
        T[rt]=mul(T[rt<<1],T[rt<<1|1]);
    };
    auto Solve=[&](int rt,int l,int r,auto &&self)->poly {
        if (l==r) return {b[l]};
        poly x=mul(self(rt<<1,l,mid,self),T[rt<<1|1]);
        poly y=mul(self(rt<<1|1,mid+1,r,self),T[rt<<1]);
        return add(x,y);
    };
    solve(1,0,a.size()-1,solve); poly c=MultiPoint(diff(T[1]),a);
    for (int i=0;i<a.size();i++) b[i]=b[i]*power(c[i])%mod;
    return Solve(1,0,a.size()-1,Solve);
}
main()
{
    int T=read(),n;
    while (T--)
    {
        n=read(),mod=read(),G=read(); int m=sqrt(n);
        poly f(1),g(2); f[0]=g[0]=1,g[1]=(m+1)%mod;
        for (int i=__lg(m)-1,n=1;~i;i--)
        {
            int tmp=n*power(m)%mod; n<<=1;
            poly a=Lagrange(f,0,n-1),b=Lagrange(f,tmp,min(tmp+n-1,mod-1) );
            if (tmp+n-1>=mod) { poly t=Lagrange(f,0,(tmp+n-1)%mod); for (int x:t) b.push_back(x); }
            poly c=Lagrange(g,0,n),d=Lagrange(g,tmp,min(tmp+n,mod-1) );
            if (tmp+n>=mod) { poly t=Lagrange(g,0,(tmp+n)%mod); for (int x:t) d.push_back(x); }
            f.resize(n),g.resize(n+1);
            for (int i=0;i<n;i++) f[i]=(a[i]*d[i]+b[i]*c[i])%mod;
            for (int i=0;i<=n;i++) g[i]=c[i]*d[i]%mod;
            if (m>>i&1) {
                for (int i=0;i<n;i++) f[i]=(f[i]*(i*m+n+1)+g[i])%mod;
                for (int i=0;i<=n;i++) g[i]=g[i]*(i*m+n+1)%mod; int val=0;
                for (int i=0,fact=1;i<=n;i++) val=(val*(n*m+i+1)+fact)%mod,
                fact=fact*(n*m+i+1)%mod; f.push_back(val),val=1;
                for (int i=0;i<=n;i++) val=val*( (n+1)*m+i+1)%mod;
                g.push_back(val),n++;
            }
        }
        int p=0,q=1;
        for (int i=0;i<m;i++) p=(p*g[i]+f[i]*q)%mod,q=q*g[i]%mod;
        for (int i=m*m+1;i<=n;i++) p=(p*i+q)%mod,q=q*i%mod;
        printf("%lld\n",p*power(q)%mod);
    }
    return 0;
}
```

---


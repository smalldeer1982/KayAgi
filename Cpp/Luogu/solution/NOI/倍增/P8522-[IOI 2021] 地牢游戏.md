# [IOI 2021] 地牢游戏

## 题目背景

**滥用本题评测将被封号**

**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

## 题目描述

Robert 正在设计一款新的电脑游戏。游戏中有一位英雄、$n$ 个敌人和 $n + 1$ 个地牢。敌人从 $0$ 到 $n - 1$ 编号，地牢从 $0$ 到 $n$ 编号。敌人 $i$（$0 \le i \le n - 1$）处在地牢 $i$，其能力值为 $s[i]$。地牢 $n$ 里没有敌人。

英雄一开始进入地牢 $x$，初始能力值为 $z$。每次英雄进入地牢 $i$（$0 \le i \le n - 1$）时，都需要面对敌人 $i$，且会发生以下情况中的一种：

如果英雄的能力值大于等于敌人 $i$ 的能力值 $s[i]$，那么英雄会胜出。这使得英雄的能力值增加 $s[i]$（$s[i] \ge 1$）。这种情况下，下一步英雄将会进入地牢 $w[i]$（$w[i] > i$）。

否则英雄会战败，这使得英雄的能力值增加 $p[i]$（$p[i] \ge 1$）。在这种情况下，下一步英雄将会进入地牢 $l[i]$。

注意 $p[i]$ 可能会小于、等于、大于 $s[i]$，$l[i]$ 可能会小于、等于、大于 $i$。无论对战结果如何，敌人 $i$ 始终处在地牢 $i$，且能力值为 $s[i]$。

当英雄进入地牢 $n$ 的时候，游戏结束。可以看出无论英雄的起始地牢和初始能力值如何，游戏一定会在有限次对战之后结束。

Robert 希望你通过 $q$ 次模拟来对游戏进行测试。对于每次模拟，Robert 输入英雄的起始地牢 $x$ 和初始能力值 $z$。你需要做的是对于每次模拟给出游戏结束时英雄的能力值。

## 说明/提示

对于所有数据：

- $1 \le n \le 400 \, 000$
- $1 \le q \le 50 \, 000$
- $1 \le s[i], p[i] \le {10}^7$（对于所有的 $0 \le i \le n - 1$）
- $0 \le l[i], w[i] \le n$（对于所有的 $0 \le i \le n - 1$）
- $w[i] > i$（对于所有的 $0 \le i \le n - 1$）
- $0 \le x \le n - 1$
- $1 \le z \le {10}^7$

子任务	|分值|特殊限制
:-:|:-:|:-:
$0$|$0$|样例
$1$|	$11$|	$n \le 50 \, 000$，$q \le 100$，$s[i], p[i] \le 10 \, 000$（对于所有的 $0 \le i \le n - 1$）
$2$|	$26$|	$s[i] = p[i]$（对于所有的 $0 \le i \le n - 1$）
$3$|	$13$|	$n \le 50 \, 000$，所有的敌人拥有相同的能力值，即 $s[i] = s[j]$，对于所有的 $0 \le i, j \le n - 1$
$4$|	$12$|	$n \le 50 \, 000$，所有的 $s[i]$ 至多有 $5$ 种不同的数值
$5$|	$27$|	$n \le 50 \, 000$
$6$|	$11$|	没有额外的约束条件

## 样例 #1

### 输入

```
3 2
2 6 9
3 1 2
2 2 3
1 0 1
0 1
2 3```

### 输出

```
24
25```

# 题解

## 作者：Mars_Dingdang (赞：6)

不理解啊，LOJ 上一发就过了，但是洛谷上一直被卡常。

## 题目大意
有 $n$ 个人，$n+1$ 个位置，一开始第 $i$ 个人在 $i$（编号从 $0$ 开始），能力值为 $s_i$。

$q$ 次询问，每次你初始在 $x$，能力值为 $z$。如果你能力值不小于当前位置人的能力值，那么你的能力值增加 $s_i$ 并且前往位置 $w_i$；否则你的能力值增加 $p_i$ 并前往位置 $l_i$。当你走到 $n$ 位置时游戏结束。求此时你的能力值。

$n\le 4\times 10^5$。

## 大体思路
最近新学习了倍增值域分块。

我们将能力值的值域分成 $[2^{\omega},2^{\omega+1})$。

对于一个 $s_i\le 2^{\omega}$ 的位置，我们显然会获胜。对于一个 $s_i\ge 2^{\omega+1}$ 的位置，我们显然会失败；而对于 $s_i\in [2^{\omega},2^{\omega+1})$ 的位置，在获胜后显然会前往下一个块。

我们可以对每一个块维护以下几个值：$gain$ 表示收获的能力值，$lim$ 表示战胜一个对手至少需要的能力值。

然后我们发现，我们的移动是每次往后跳一个位置。这样太劣了，考虑倍增，对每一个位置 $i$ 开始，在每一个块 $\omega$ 中都开一个倍增数组表示往后跳 $2^j$ 步。

初始的时候 $to(i,\omega,0)=w_i$ 或 $l_i$，$gain$ 和 $lim$ 赋值如上文所述。预处理倍增数组即可。

查询的时候，每次倍增往后跳必败或者必胜，最后遇到一个位置再基于 $s_i$ 判断胜负即可。这样的判断至多 $O(\log V)$ 次，单次复杂度为 $O(\log n\log V)$。

然而一开始被卡常了。一种是相信答案步数不会太多，倍增跳的时候可以开小一点；一种是倍增值域分块的 $Base$ 设置得大一点，减少预处理时候的块数。具体实现可以参考代码。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
// using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
// typedef unsigned long long ull;
// typedef double db;
// typedef std::pair<int, int> PII;
const int maxn = 4e5 + 5, Omega = 5, Bits = 17;
const ll inf = 1e18, Base = 32;
template <typename T>
inline void chkmax(T &x, T y) {x = (x > y ? x : y);}
template <typename T>
inline void chkmin(T &x, T y) {x = (x < y ? x : y);}
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n; std::vector<int> s, p, w, l;
int to[maxn][9][20];
ll lim[maxn][9][20], gain[maxn][9][20], P[9];
inline ll Min(ll a, ll b) {return a < b ? a : b;}
void init(int _n, std::vector <int> _s, std::vector <int> _p, std::vector <int> _w, std::vector <int> _l) {
	n = _n; s = _s, p = _p, w = _w, l = _l;
//	rep(i, 0, n - 1) s[i] = _s[i], p[i] = _p[i], w[i] = _w[i], l[i] = _l[i];
	P[0] = 1;
	rep(i, 1, Omega) P[i] = P[i - 1] * Base;
	rep(omega, 0, Omega) {
		rep(i, 0, n - 1) {
			if(P[omega] >= s[i]) {
				w[i] == n ? to[i][omega][0] = -1 : to[i][omega][0] = w[i], lim[i][omega][0] = inf, gain[i][omega][0] = s[i];
			}
			else {
				l[i] == n ? to[i][omega][0] = n : to[i][omega][0] = l[i], lim[i][omega][0] = s[i], gain[i][omega][0] = p[i];
			}
		}
	}
	rep(omega, 0, Omega) {
		rep(j, 1, Bits) {
			rep(i, 0, n - 1) {
				if(to[i][omega][j - 1] == -1 && to[to[i][omega][j - 1]][omega][j - 1] == -1) {
					to[i][omega][j] = -1;
					continue;
				}
				to[i][omega][j] = to[to[i][omega][j - 1]][omega][j - 1];
				gain[i][omega][j] = gain[i][omega][j - 1] + gain[to[i][omega][j - 1]][omega][j - 1];
				lim[i][omega][j] = Min(lim[i][omega][j - 1], lim[to[i][omega][j - 1]][omega][j - 1] - gain[i][omega][j - 1]);
			}
		}
	}
} 
//int omega;
ll simulate(int x, int z) {
	ll res = z; int omega = 0;
	while(x != n) {
		while(omega + 1 <= Omega && P[omega + 1] <= res) ++ omega;
		Rep(j, Bits, 0) {
			if(to[x][omega][j] == -1) continue;
			(res < lim[x][omega][j] ? res += gain[x][omega][j], x = to[x][omega][j] : 1);
		}
		res >= s[x] ? (res += s[x], x = w[x]) : (res += p[x], x = l[x]);
	}
	return res;
}
```

---

## 作者：_Ch1F4N_ (赞：5)

看到大于等于 $s_i$ 加上 $s_i$，考虑应该是倍增分块状物，于是先倍增分块，假设当前能力值处在块 $[B^k,B^{k+1})$ 中，那么对于任意 $s_i < B^k$ 必定成功，任意 $s_i \geq B^{k+1}$ 必定失败，对于 $s_i \in [B^k,B^{k+1}]$ 的情况不确定，但是这种情况只会成功 $B$ 次。

于是考虑我们认为一次过程是走若干步，在走到过程中能力值始终处在 $[B^k,B^{k+1})$ 范围内且经过所有的 $s_i \in [B^k,B^{k+1})$ 的情况必定失败，那么观察到至多 $B$ 个极大过程后所处块会增加，也就是至多进行 $\log_{B} V \times B$ 次极大过程。

找极大过程可以直接考虑倍增，具体而言，对于每个块处理 $dp_{u,i},f_{u,i},g_{u,i}$ 分别表示从 $u$ 出发走 $2^i$ 步，走到的节点，走的过程中能力值的增量与使得走 $2^i$ 步在一个过程中的最大初始值（显然初始值越大越容易在走了若干步后不满足在一次过程中的条件），这一部分是 $O(n \times \log_{B} V \times \log V)$ 的，所以总时间复杂度就是 $O(n \times \log_{B} V \times \log V + q \times \log_{B} V \times \log V \times B)$。

由于观察到 $q$ 相较 $n$ 要小很多，于是考虑令 $B = 64$ 即可通过。


```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
//#define lowbit(x) (x&(-x))
//#define bp push_back
//#define sz size
//#define cl clear
const int maxn = 4e5+14;
const int warma = 64;
int dp[6][maxn][25];//在第 i 块中点 u 出发跳 2^j 步抵达的点
long long f[6][maxn][25];//在第 i 块中点 u 出发跳 2^j 步获得加成
long long g[6][maxn][25];//在第 i 块中点 u 出发跳 2^j 步，中途不超过块，遇到 s_i 在块内的必失败，初始节点最大能力值
long long _pow[6];
vector<int> s,p,w,l;
int n;
void init(int N, vector<int> S, vector<int> P, vector<int> W, vector<int> L){
	n=N,s=S,p=P,w=W,l=L;
	_pow[0]=1;
	for(int i=1;i<5;i++) _pow[i]=_pow[i-1]*warma;
	_pow[5]=1e18;
	for(int bl=0;bl<5;bl++){
		for(int i=0;i<n;i++) dp[bl][i][0]=(s[i]<_pow[bl]?w[i]:l[i]),f[bl][i][0]=(s[i]<_pow[bl]?s[i]:p[i]),g[bl][i][0]=((_pow[bl]<=s[i]&&s[i]<_pow[bl+1])?min(1ll*s[i]-1,_pow[bl+1]-1):_pow[bl+1]-1);
		for(int j=1;j<25;j++){
			for(int i=0;i<n;i++){
				dp[bl][i][j]=dp[bl][dp[bl][i][j-1]][j-1];
				f[bl][i][j]=f[bl][i][j-1]+f[bl][dp[bl][i][j-1]][j-1];
				g[bl][i][j]=min(g[bl][i][j-1],g[bl][dp[bl][i][j-1]][j-1]-f[bl][i][j-1]);		
			}
			dp[bl][n][j]=n;
			f[bl][n][j]=0;
			g[bl][n][j]=1e18;
		}
	}
	return ;
} 
int chk(long long z){
	int mx=0;
	for(int i=0;i<6;i++){
		if(z>_pow[i]) mx=i;
	}
	return mx;
}
long long ask(int x,long long z,int h){
	for(int i=24;i>=0;i--){
		if(z<=g[h][x][i]) z+=f[h][x][i],x=dp[h][x][i];
	}
	if(x==n) return z;
	if(z>=s[x]) z+=s[x],x=w[x];
	else z+=p[x],x=l[x];
	if(x==n) return z;
	else return ask(x,z,chk(z));
}
long long simulate(int x, int z){
	return ask(x,z,chk(z));
}
```

---

## 作者：是青白呀 (赞：4)

**倍增分块**。

考虑将能力值分为 $[2^k,2^{k+1}-1]$ 的若干块。当英雄的能力值在 $[2^k,2^{k+1}-1]$ 块内时，对于 $s_i<2^k$ 的敌人 $i$，英雄会一直胜利，否则英雄若胜利，则会一步跳到下一个块中去。

我们预期对于 $s_i<2^k$ 的敌人，我们会一直胜利；对于 $s_i\geq 2^k$ 的敌人，我们会一直失败。对于每个块维护一个倍增数组表示一直按照预期进行 $2^x$ 步到达的位置、以及这部分增加的能力值。此外，还需要维护一个能按照预期一直进行到底，初始的能力值的最大值（更大的话，可能在中间某个 $s_i\geq 2^k$ 的敌人处也能胜利），在每个块内即可倍增维护整个过程。

倍增一旦结束，能力值就会跳到下一个块中去，所以复杂度为 $O((n+q)\log V\log n)$。

事实上，这样空间开不下，且预处理部分可能被卡常。解决办法是适当减少块数和倍增的最大距离，这样能使得空间和预处理的时间常数减小；副作用是一次倍增停止后可能还没有跨出整个块，需要进行多次倍增，但由于 $q$ 较小，这样的调整是可以接受的。

在我的实现中，分块底数设成了 $16$，总共只需要分 $7$ 块，但倍增途中会带 $16$ 左右的常数。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=400005,M=20,B=7,mo=1e9+7,bs=19491001;
const ll inf=(ll)1e18+7;
const double eps=1e-8;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int s[N],p[N],w[N],l[N],n;
struct node{
	int pos;
	ll lim,val;
	friend node operator+(node x,node y){
		return (node){y.pos,min(x.lim,y.lim-x.val),x.val+y.val};
	}
}f[B][N][M];
int stp[B];
void init(int _n, vector<int>_s, vector<int>_p, vector<int>_w, vector<int> _l){
    n=_n;
	rep(i,0,n-1)
	    s[i]=_s[i],p[i]=_p[i],w[i]=_w[i],l[i]=_l[i];
	stp[0]=1;
	rep(i,1,6)
	    stp[i]=stp[i-1]*16;
	w[n]=n;
	rep(b,0,6){
		rep(i,0,n){
			if(stp[b]<=s[i])f[b][i][0]=(node){l[i],s[i],p[i]};
			else f[b][i][0]=(node){w[i],inf,s[i]};
		}
		rep(j,1,19){
			rep(i,0,n)
			    f[b][i][j]=f[b][i][j-1]+f[b][f[b][i][j-1].pos][j-1];
		}
	}
}

ll simulate(int x, int z){
	ll res=z;
	while(x!=n){
		int nwb=0;
		rep(i,0,6)
		    if(res>=stp[i])nwb=i;
		repp(i,19,0)
			if(f[nwb][x][i].lim>res)res+=f[nwb][x][i].val,x=f[nwb][x][i].pos;
		if(res>=(ll)s[x])res+=(ll)s[x],x=w[x];
		else res+=p[x],x=l[x];//有可能是倍增数组太短导致的停止，现在到底能不能胜利还不一定
	}
	return res;
}
```

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P8522)

**题目大意**

> 你要挑战 $n$ 个人，假设当前对手为 $i$，如果你当前的实力 $\ge s_i$，则实力加上 $s_i$，接下来挑战 $w_i$，否则实力加上 $p_i$，接下来挑战 $l_i$。
>
> $q$ 次询问 $x$ 出发，初始实力为 $z$ 时几次操作挑战 $n+1$。
>
> 数据范围：$n\le 4\times 10^5,q\le 5\times 10^4,s_i,p_i\le 10^7$。

**思路分析**

倍增值域分块，设当前 $z\in[2^k,2^{k+1})$，考虑何时 $z\ge 2^{k+1}$，那么我们只要找到第一个 $s_i\ge 2^k$ 且 $s_i\le z$ 的点即可。

不妨钦定每次都有 $z<s_i$，那么获胜当且仅当 $s_i<2^k$，可以直接预处理得到从 $x$ 出发走 $2^d$ 步，如果想要输给所有 $s_i\ge 2^k$ 的点，那么 $z$ 至多是多少。

然后倍增一下就找到了第一个 $s_i\in[2^k,z]$ 的点。

但是空间复杂度太大，把块长放成 $[B^k,B^{k+1})$，那么 $B$ 次赢某些 $s_i$ 后就跳出这个块了，取 $B=16$ 课题通过。

时间复杂度 $\mathcal O(n\log_B V\log n+qB\log_B V\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
#include "dungeons.h"
using namespace std;
const int MAXN=4e5+5,pw[]={1,16,256,4096,65536,1048576,16777216};
const ll inf=1e18;
int n,s[MAXN],w[MAXN],l[MAXN],p[MAXN];
struct info {
    int u; ll lim,sum;
    friend info operator +(info x,info y) {
        return {y.u,min(x.lim,y.lim-x.sum),x.sum+y.sum};
    }
}   f[7][25][MAXN];
void init(int N,vector <int> S,vector <int> P,vector <int> W,vector <int> L) {
    n=N;
    for(int i=0;i<n;++i) s[i]=S[i],p[i]=P[i],w[i]=W[i],l[i]=L[i];
    for(int d=0;d<7;++d) {
        for(int i=0;i<n;++i) f[d][0][i]=(s[i]<=pw[d])?info{w[i],inf,s[i]}:info{l[i],s[i],p[i]};
        for(int k=1;k<25;++k) {
            info *g=f[d][k-1],*h=f[d][k];
            for(int i=0;i<n;++i) h[i]=(g[i].u==n)?g[i]:g[i]+g[g[i].u];
        }
    }
}
ll simulate(int x,int Z) {
    ll z=Z;
    while(x!=n) {
        int d=0;
        while(d<6&&pw[d+1]<=z) ++d;
        for(int k=24;~k;--k) {
            info e=f[d][k][x];
            if(e.u!=n&&z<e.lim) x=e.u,z+=e.sum;
        }
        z>=s[x]?(z+=s[x],x=w[x]):(z+=p[x],x=l[x]);
    }
    return z;
}
```

---

## 作者：Mirasycle (赞：1)

值域分块之后倍增的好题。

题目要求强制在线，我们必须对于初始值和初始位置预处理一些信息。可是初始值域非常大，我们难以对于每个位置都进行预处理。**于是考虑将初始值比较相似的值放在一起处理，它们的大部分过程都是一样的，在很少的位置发生分歧的时候我们暴力处理**。

基于以上思想，我们可以值域分块并倍增。值域分块是为了将值域分成 $[B^k,B^{k+1})$，把在这一范围内的统一处理。倍增是为了加速整个过程。

当 $s_i<B^k$ 的时候，该值域内的所有英雄都会战胜对手。当 $s_i\ge B^{k+1}$ 的时候，该值域内的所有英雄都会输掉对决。这两种情况都是可以统一处理的。当 $s_i\in [B^k,B^{k+1})$ 的时候，我们还是统一处理能力值 $< s_i$ 的情况，当能力值 $>s_i$ 的时候可以发现这种情况在当前值域范围内只会发生至多 $B$ 次，因为前提是 $s_i\ge B^k$，而每次胜利之后都会 $s_i$，所以最多加了 $B$ 次 $s_i$ 之后就会 $>B\times B^k=B^{k+1}$，从而进入下一个块。很巧妙对吧？根据以往的倍增技巧，我们之前只知道让某个数加上一个比它大的数，它的值会翻倍，但是这一次见到了如果让一个数加上比它小的数，在值域分块的情况下增加次数也是很少的。

上一段说了，在 $s_i\in [B^k,B^{k+1})$ 的时候，我们依然同一处理能力值 $<s_i$ 的情况，这就需要我们倍增的时候额外记录参数 $lim$ 代表能力值 $\le lim$ 的时候才能不断输掉与 $s_i$ 的比较。同时除了记录 $\lim$，倍增的时候还需要记录从 $i$ 开始跳了 $2^j$ 会到达哪里，能力值的增量式多少。注意倍增的条件是赢了 $s_z<B^k$，输了 $s_z\ge B^{k+1}$ 或者输给 $s_i\in [B^k,B^{k+1})$，一旦出现赢了 $s_i\in[B^k,B^{k+1})$，我们就终止倍增暴力判断。于是我们询问的时候倍增的复杂度是 $O(B\log V\log_BV)$，其中 $B\log V$ 是单个块内的跳跃次数上界，$\log_BV$ 是块的个数。总的时候复杂度是 $O(n\log V\log_B V+qB\log V\log_B V)$，综合空间限制的考量，平衡一下，取 $B=32$ 即可。


```cpp
#include<bits/stdc++.h>
#include "dungeons.h"
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int B=32;
const int maxn=4e5+10;
const ll inf=1e18;
int n,s[maxn],p[maxn],w[maxn],l[maxn];
struct INFO{
	int pos; ll lim,ad;
	INFO operator + (const INFO q) const {
		if(q.pos==n+1) return q;
		return (INFO){q.pos,min(lim,q.lim-ad),ad+q.ad};
	}
}d[6][20][maxn]; ll pw[maxn];
void init(int N,vi S,vi P,vi W,vi L){
	n=N; pw[0]=1; for(int k=1;k<=6;k++) pw[k]=pw[k-1]*B;
	for(int i=1;i<=n;i++) s[i]=S[i-1],p[i]=P[i-1],w[i]=W[i-1]+1,l[i]=L[i-1]+1;
	for(int k=0;k<6;k++){
		for(int i=1;i<=n;i++){
			if(s[i]<=pw[k]) d[k][0][i]=(INFO){w[i],inf,s[i]};
			else d[k][0][i]=(INFO){l[i],s[i],p[i]};
		}
		for(int z=1;z<20;z++)
			for(int i=1;i<=n;i++){
				int u=d[k][z-1][i].pos;
				d[k][z][i]=d[k][z-1][i]+d[k][z-1][u];
			}
	}
}
ll simulate(int x,int Z){
	x++; ll power=Z;
	while(x!=n+1){
		int k=0; while(k+1<6&&pw[k+1]<=power) k++;
		for(int z=19;z>=0;z--){
			INFO to=d[k][z][x];
			if(to.pos!=n+1&&power<to.lim) x=to.pos,power+=to.ad;
		}
		if(power>=s[x]) power+=s[x],x=w[x];
		else power+=p[x],x=l[x];	
	}
	return power;
}
```

---

## 作者：Purslane (赞：1)

# Solution

考虑 Sub 2 怎么做。

当英雄的能力值大于 $\max_{i} s_i$，那么他就可以直接到终点。

若英雄被一个敌人打败了，那么一定有 $z < s_i$，而会有 $z \leftarrow z + s_i$，所以 $z$ 至少翻了一倍。所以这种情况只会发生 $O(\log V)$ 次。

我们可以不断跳 $i \leftarrow w_i$ 直到第二种情况会发生。这个过程容易使用倍增维护。复杂度 $O((n+q) \log^2 V)$。

回到本题，考虑按照 $B$ 分块。每次考虑 $[B^k,B^{k+1})$ 的一个范围。

如果 $s_i \le B^k$，那么他是没有影响的，直接认为后继是 $w_i$；如果 $s_i \ge B^{k+1}$，他在 $z$ 跳到下一个块之前也是没用的，直接认为后继 $l_i$；如果 $B^k < s_i < B^{k+1}$，我们先默认后继是 $l_i$，并且维护 $z$ 最大小于等于多少才能跳 $2^t$ 次后继。

这样你会跳 $Bq \log_B V$ 次倍增，每次倍增复杂度为 $\log V$。

取 $B=8$（因为倍增预处理的复杂度为 $n \log_B V \log V$，所以 $qB=n$ 的时候看起来还不错，就是 $B = 8$）。

注意题目是在线的，所以你必须把倍增数组全都存下来。所以你需要 $3 \times 27 \times \log_B V$ 个倍增数组，总共需要的空间为 $16 \times 27 \times \log_B V \times n \times 2^{-20} \rm Mb$。

这样算下来你差不多能开 $6$ 到 $9$ 个，也就是 $\log_B V \le 9$。取 $B=8$ 即可。（同时你也可不严格开到 $\log_2 V$ 层，可以稍微小一点，让他多倍增几次，用时间换空间）

> 但是这样似乎过不去，因为预处理常数比较大。最后用 $B=32$ 过的。而且你要相信路径不会太长，所以倍增的时候可以把上界限制小一些。

总结一下，本题是经典的倍增分块套路。利用某一组合量所在块的变化以及块内的变化都比较小来维护这一流程。而此类题目往往都有“元素增量和它的差（按照比值看）非常接近”。还有一些有趣的空间技巧，是一个不错的题目。

代码：

```cpp
#include<bits/stdc++.h>
#include "dungeons.h"
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=400000+10,INF=0x3f3f3f3f;
int n,s[MAXN],p[MAXN],l[MAXN],w[MAXN];

int to[MAXN][6][20],lst[MAXN][6][20];
ll add[MAXN][6][20];
void init(int N,vector<int> S,vector<int> P,vector<int> W,vector<int> L) {
	n=N;
	ffor(i,1,n) s[i]=S[i-1],p[i]=P[i-1],l[i]=L[i-1]+1,w[i]=W[i-1]+1;
	ffor(tc,0,5) {
		ll ml=(1ll<<5*tc),mr=ml*32-1;
		ffor(i,1,n) {
			if(s[i]<=ml) to[i][tc][0]=w[i],lst[i][tc][0]=INF,add[i][tc][0]=s[i];
			else if(s[i]>mr) to[i][tc][0]=l[i],lst[i][tc][0]=INF,add[i][tc][0]=p[i];
			else to[i][tc][0]=l[i],lst[i][tc][0]=s[i]-1,add[i][tc][0]=p[i];
		}
		ffor(b,1,18) {
			ffor(i,1,n) {
				to[i][tc][b]=to[to[i][tc][b-1]][tc][b-1];
				add[i][tc][b]=add[i][tc][b-1]+add[to[i][tc][b-1]][tc][b-1];
				lst[i][tc][b]=INF;
				if(lst[i][tc][b-1]!=INF) lst[i][tc][b]=min(lst[i][tc][b],lst[i][tc][b-1]);
				if(lst[to[i][tc][b-1]][tc][b-1]!=INF) lst[i][tc][b]=min(lst[i][tc][b],(int)max(-1ll,lst[to[i][tc][b-1]][tc][b-1]-add[i][tc][b-1]));
			}
		}
	}
	return ;
}
ll solve(int x,ll z) {
	if(x==n+1) return z;
	ll mul=1;int k=0;
	while(mul*32<=z&&k<=4) mul*=32,k++;
	mul<<=5;
	roff(i,18,0) if(to[x][k][i]>=1&&to[x][k][i]<=n&&(lst[x][k][i]==INF||z<=lst[x][k][i])&&(k==5||z+add[x][k][i]<mul)) z+=add[x][k][i],x=to[x][k][i];	
	if(z>=s[x]) z+=s[x],x=w[x];
	else z+=p[x],x=l[x];
	return solve(x,z);
}
ll simulate(int x,int z) {
	return solve(x+1,z);	
}
```

---


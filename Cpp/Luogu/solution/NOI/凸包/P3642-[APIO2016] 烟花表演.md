# [APIO2016] 烟花表演

## 题目描述

烟花表演是最引人注目的节日活动之一。在表演中,所有的烟花必须同时爆炸。为了确保安全，烟花被安置在远离开关的位置上，通过一些导火索与开关相连。导火索的连接方式形成一棵树，烟花是树叶，如图所示。火花从开关出发，沿导火索移动。每当火花抵达一个分叉点时，它会扩散到与之相连的所有导火索，继续燃烧。导火索燃烧的速度是一个固定常数。图中展示了六枚烟花 $\{E_1, E_2, \dots, E_6\}$ 的连线布局，以及每根导火索的长度。图中还标注了当在时刻 $0$ 从开关点燃火花时，每一发烟花的爆炸时间。


 ![](https://cdn.luogu.com.cn/upload/pic/4429.png) 

Hyunmin 为烟花表演设计了导火索的连线布局。不幸的是，在他设计的布局中，烟花不一定同时爆炸。我们希望修改一些导火索的长度，让所有烟花在同一时刻爆炸。例如，为了让图中的所有烟花在时刻 $13$ 爆炸，我们可以像下图中左边那样调整导火索长度。类似地，为了让图中的所有烟花在时刻 $14$ 爆炸，我们可以像下图中右边那样调整长度。

 ![](https://cdn.luogu.com.cn/upload/pic/4430.png) 

修改导火索长度的代价等于修改前后长度之差的绝对值。例如，将上面那副图中布局修改为下面那副图的左边布局的总代价为 $6$，而修改为右边布局的总代价为 $5$。

导火索的长度可以被减为 $0$，同时保持连通性不变。

给定一个导火索的连线布局，你需要编写一个程序，去调整导火索长度，让所有的烟花在同一时刻爆炸，并使得代价最小。


## 说明/提示

【数据规模】

子任务 1（7 分）：$N = 1$，$1 \leq M \leq 100$。

子任务 2（19 分）：$1 \leq N+M \leq 300$，且开关到任一烟花的距离不超过 $300$。

子任务 3（29 分）：$1 \leq N+M \leq 5000$。

子任务 4（45 分）：$1 \leq N+M \leq 300000$。


## 样例 #1

### 输入

```
4 6
1 5
2 5
2 8
3 3
3 2
3 3
2 9
4 4
4 3```

### 输出

```
5```

# 题解

## 作者：xgzc (赞：76)

神仙题目啊QwQ

设$f_i(x)$表示以第$i$个点为根的子树需要$x$秒引爆的代价。

我们发现，这个函数是一个下凸的一次分段函数。

考虑这个函数合并到父亲节点时会发生怎样的变化。

设$f_i'(x)$是原函数，$f_i(x)$是新函数，$i$和父亲之间的边长度为$l$，$[L, R]$是$f_i'(x)$斜率为$0$的那一段的左右端点的横坐标，那么有：

$$f_i(x) = \begin{cases}f_i'(x) + l & x \leq L \\f_i'(L) + (l - (x - L)) & L < x \leq L + l \\f_i'(L) & L + l < x \leq R + l \\f_i'(L) + ((x - R) - l) & R + l < x\end{cases}$$

我们一个一个来看。

首先第一个，当$x \leq L$时，我们肯定要让新的$l$越小越好，因为改变$l$的代价为$1$，而这个函数在$\leq L$的时候斜率$\leq -1$，即修改一次$x$的代价$\geq 1$，所以干脆将$l$变成$0$。

第二个，我们只要保证$x = L$就能取到函数的最小值，于是$l$的变化量越小越好。

第三个，我们不用改变$l$就可以保证能取到最小值，那就不用改变了。

第四个和第一个很像，这里就略去了。

------

那么这个过程究竟对这个函数做了什么改变呢？

我们将$\leq L$部分的函数向上平移了$l$单位，将$[L,R]$部分向右平移$l$单位，在$[L,L+l]$部分插入了一条斜率为$-1$的直线，并将$> R + l$的部分的斜率改为了$1$。

于是大概变成了这个样子（图源网络）：

![](https://i.loli.net/2019/03/31/5ca05e4a15b2b.png)

这样，各个拐点之间的直线的斜率是从左到右递增的。

我们不妨假设各个拐点之间的直线斜率的增量为$1$，如果有一个斜率不存在，那么我们就用两个同一位置的拐点来表示这个不存在的斜率。

然后我们发现我们只可能存下拐点的横坐标，于是怎么求函数值是一个问题。

我们如果能知道$f(0)$的值，这个事情就好办了。

$f(0)$的值还不好求？？？就是所有边权之和啊。

于是我们得到了通过拐点横坐标求得$f(L)$的方法，皆大欢喜。

那么我们知道每个函数被合并上去之前会变成什么样子了，那么我们也可以非常简单的合并两个函数了，我们只需要将两个函数的拐点列表合并一下就可以了。

我们再看看在合并到父亲节点时要做的操作：

一、将斜率$> 0$的那一段的斜率改为$1$。

因为我们合并上来的函数的斜率最大值都为$1$，所以我们只需要删除$k - 1$个最大的拐点即可，其中$k$是这个点儿子的数量。

二、将斜率$=0$的那一段平移$l$单位。

首先，我们做完一操作之后，横坐标最大的两个拐点就是斜率为$0$的两个端点了，将它们弹出来，加上$l$再放进去就没了。

三、加入一段斜率为$-1$的直线。

这个其实在做操作二的时候就顺带做完了。

我们维护一个可并堆就可以做上面的所有操作。

最后求答案时，我们保留$L$及其左边的拐点，依次减去它们的横坐标就是我们想要的函数值了。

代码见我的[$\texttt{blog}$](https://www.cnblogs.com/cj-xxz/p/10631433.html)

---

## 作者：UltiMadow (赞：53)

首先有一个很显然的 dp 方程

设 $f_{u,x}$ 为以 $u$ 为根的子树中结束时间统一为 $x$ 的最小代价，有 $f_{u,x}=\sum \min_{y\le x}\{f_{v,y}+|w-x+y|\}$

于是有了一个 $\mathcal O(n(\sum w)^2)$ 的方程

接下来，我们考虑把 $f_u$ 的所有点值写成函数的形式 $f_u(x)$

考虑 $f_v(y)$ 对父亲 $f_u(x)$ 的贡献

首先，我们发现这个函数每一段的斜率一定是单调递增的，并且斜率均为整数，于是 $f_v(y)$ 的最优取值就是斜率为 0 的一段，记为 $[L,R]$，接下来，记 $f_v$ 对于 $f_u(x)$ 的贡献函数为 $F_v(x)$，记 $u\to v$ 的边权为 $w$

根据 $F_v$ 的定义，我们可以知道 $F_v(x)=\min_{y\le x}\{f_v(y)+|w-x+y|\}$

接下来，我们可以分三类来讨论一下：

1. 当 $x$ 很小的时候，最优情况一定是把 $w$ 修改为 0（由于修改 $w$ 一定比下面每一个都修改优）  
具体来说就是 $x<L$ 时，$F_v(x)=f_v(x)+w$ 一定最优，因为 $f_v(x)$ 在 $x<L$ 时为单调降函数，且斜率小于等于 -1，于是 $w$ 少缩短 $k$，则 $f_v$ 的增加量一定 $\ge k$，于是在 $w$ 修改为 0 时取到最优解

2. 当 $x$ 很大的时候，和上种情况类似，最优情况一定要把 $w$ 拉长  
具体来说就是 $x\ge R+w$ 时，$F_v(x)=f_v(R)+x-R-w$ 一定最优，因为 $f_v(x)$ 在 $x>R$ 时为单调升函数，且斜率大于等于 1，于是 $w$ 少拉长 $k$，$f_v$ 的增加量一定 $\ge k$，又 $f_v$ 在 $[L,R]$ 内都能取到最优值，所以 $w$ 拉长到 $x-R$ 时取到最优解

3. 当 $x$ 适中的时候，我们可以调整 $w$ 缩小的值使 $F_v$ 取到最优，我们可以继续分两类讨论  
	1）这种情况 $w$ 不用修改即可取到最优值，具体来说， $L+w\le x\le R+w$ 时， $F_v(x)=f_v(x-w)$ 一定最优，因为 $w$ 不修改，那么修改 $w$ 的代价取到了最小，同时由于 $x-w\in[L,R]$，$f_v(x-w)$ 也取到了最小，那么这就是最优值  
   2）这种情况 $w$ 需要修改，并且一定是缩小（拉伸属于 2. 情况），具体来说，$L\le x<L+w$ 时，$F_v(x)=f_v(L)+w-x+L$，原因与 1. 情况相同，只是这里没有必要把 $w$ 修改为 0（原因是 $w$ 多修改了以后 $f_v$ 并不会因此减小）
   
于是我们可以把这几种情况整理一下，得：
$$
F_v(x)=
\begin{cases}
f_v(x)+w & (x<L)\\
f_v(L)+w-x+L & (L\le x<L+w)\\
f_v(x-w)=f_v(L) &(L+w\le x\le R+w)\\
f_v(R)+x-R-w &(x>R+w)
\end{cases}
$$

考虑 $F_v$ 对于 $f_v$ 的变化关系

1. $x<L$ 时，$f_v$ 往上平移 $w$ 单位即可  
2. $L\le x<L+w$ 时，在向上平移 $w$ 的基础上需要把斜率修改为 -1  
3. $L+w\le x\le R+w$ 时，将原先 $[L,R]$ 的函数平移到 $[L+w,R+w]$ 即可  
4. $x>R+w$ 时，把这段函数的斜率统一修改为 1

又容易发现 $F_v$ 是连续的，于是我们在存储这段函数的时候只需要存储 $F_v$ 的各个拐点即可

于是，我们修改 $F_v$ 只需要把 $L$ 和 $L$ 之后的所有拐点全部删除，新加入 $L+w$，$R+w$ 两个拐点即可

与 $f_u$ 合并时，我们只需要把这些拐点序列直接和 $f_u$ 本身拥有的拐点序列合并，并且**不去重**，因为重复 $k$ 次的拐点可以表示这个点左右两边的斜率差为 $k$

又拐点横坐标单调下降，我们很容易可以想到用可并的大根堆来维护这个函数

接下来还有两个问题

1. 如何从可并堆中找到斜率为 0 的区间的两个拐点 $L,R$  
我们发现每次修改的 $F$ 函数中，斜率为正的拐点有且仅有一个（$R+w$），而一个函数 $f_v$ 会合并儿子个数 $k_v$ 次，也就是说 $f_v$ 中有 $k_v$ 个斜率为正的拐点，于是弹出 $k_v-1$ 个，剩下的第一个就是 $R$，下一个就是 $L$

2. 如何计算答案  
我们知道了根节点（1 号节点）的函数拐点集合，又知道了 $f_1(0)$ 时的取值（所有边的权值和），又知道了一个拐点和下一个拐点对应的函数斜率差为 1，于是我们就可以轻松地算出答案了

可并堆用左偏树实现即可，复杂度 $\mathcal O((n+m)\log (n+m))$

另外有一个细节就是左偏树的节点要开两倍大小，因为每次把 $f$ 修改成 $F$ 都要新建两个节点

code:
```cpp
#include<bits/stdc++.h>
#define MAXN 300010
#define int long long
using namespace std;
int n,m,ans;
int fa[MAXN],w[MAXN],deg[MAXN];
int val[MAXN<<1],d[MAXN<<1],rt[MAXN],tot;
int lc[MAXN<<1],rc[MAXN<<1];
int create(int v){
	val[++tot]=v;d[tot]=0;
	return tot;
}
int merge(int p,int q){
	if(!p||!q)return p+q;
	if(val[p]<val[q])swap(p,q);
	rc[p]=merge(rc[p],q);
	if(d[lc[p]]<d[rc[p]])swap(lc[p],rc[p]);
	d[p]=d[rc[p]]+1;return p;
}
void pop(int &p){p=merge(lc[p],rc[p]);}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=2;i<=n+m;i++){
		scanf("%lld%lld",&fa[i],&w[i]);
		ans+=w[i];deg[fa[i]]++;
	}
	for(int u=n+m;u>=2;u--){
		if(u<=n)while(deg[u]-->1)pop(rt[u]);
		int R=val[rt[u]];pop(rt[u]);
		int L=val[rt[u]];pop(rt[u]);
		rt[u]=merge(rt[u],merge(create(L+w[u]),create(R+w[u])));
		rt[fa[u]]=merge(rt[fa[u]],rt[u]);
	}
	while(deg[1]--)pop(rt[1]);
	while(rt[1])ans-=val[rt[1]],pop(rt[1]);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：shadowice1984 (赞：19)

可并堆好题啊……

不是很明白为啥左偏树是最常见的可并堆……

~~明明配对堆比左偏树又快又好写~~

除了可持久化可并堆这种东西以外左偏树似乎没有什么存在价值啊

~~但是这题又不需要可持久化~~

_________________

# 本题题解

给定一颗树每个边上有权值,你可以任意调整每个边的权值为一个非负的整数,将一条原来权值为val的边的权值调整为a的代价是$|val-a|$,要求调整完边权之后每个叶子到根的距离是相等的,求最小代价

### 从一个naive的dp开始

那么我们可以设计一个非常naive的dp状态就是$dp(u,i)$表示将u子树中的所有叶子节点调整至距u的父亲距离为$j$的最小代价

那么我们的转移方程也是十分的平凡的,枚举u和父亲的边到底变成了什么值然后进行取min操作

可以推出这样的一个式子

$$f(u,i)=\min_{k=0}^{i}|val-k|+\sum_{v \in u.son}f(v,i-k)$$

_____________

### 观察式子的特点

我们发现我们处理的函数是一个类似于min卷积一样的式子, 显然快速的计算这个东西是没什么可能的……

不过我们的$f(u,x)$这个函数相当的有特点，在接下来我们将会使用归纳法证明$f(u,x)$是一个关于x的分段函数并且在每段都是线性的

那么对于函数的min卷积这个运算，尽管一般情况下是没有什么性质的，但是在这道题里我们有一个函数是绝对值函数，而另一个函数是一个简单的分段函数

此时我们就有可能会有一些性质了

那么我们手动分情况大力讨论一波……（想证明的人自己手丸去吧,推式子推了我一个下午）

会发现min卷积大概有这么几个性质

1.一个斜率比-1大的直线卷积上斜率为-1的直线之后新函数截距为两个函数的截距之和,斜率不变

2.一个常数函数和一个斜率为-1的直线卷积之后截距为两个函数截距之和而斜率变为-1

3.对于一个下凸的分段函数并且每一段的斜率都大于1,和一个斜率为+1的直线卷积之后,这个函数将会变成一条斜率为1的直线

事实上刚才的结论只是一个感性理解,因为我们在卷积的时候远不止这几种情况

然后我们胡乱爆推一波结论之后可以得到这个式子,如果我们给$f(u,x)$这个函数添加一条父亲边的话我们函数会做这样的变化，假设这个函数在$[L,R]$处取值为0

1.将函数在$[1,L]$的一段向上平移$val$个单位

2.将函数在$[R,+\infty]$的一段向右平移$val$个单位并且斜率改为+1

3.将函数在$[L,R]$的一段向右平移$val$个单位

4.此时你发现中间空出了一段斜率为-1,$val$个单位高$val$个单位宽的线段,在中间插入一个线段就行了

合并相邻的子树就是将函数简单的相加起来

那么我们采用这样的方式来存储一个函数$f(u,x)$

通过数学归纳法可以得到$f(u,x)$的最右端斜率等于1,而在插入父亲之前函数的最左段斜率=u的儿子数目

我们现在通过存储这个分段函数的每一个拐点的x坐标来表示这个函数

并且我们认为，**从右向左,每经过一个拐点，函数的斜率-1**

那么初始的时候我们需要存储一个绝对值函数,这样的话我们就用两个在同一个位置的拐点来描述这个绝对值函数

这样储存函数有一个好处就是当我们把函数相加的时候只需要简易的将两个函数的拐点列表合并一下再将最右端斜率简单相加就可以完成函数的合并工作了

那么我们现在已经可以完成函数相加的操作了,我们现在需要兹瓷的操作就是将函数所有斜率为正的拐点全部弹出这个操作了(至于修改斜率什么的其实简单的就是插入两个拐点就行了)

那么我们发现其实这个操作就等价于弹出函数中x坐标前k大的拐点其中k为我们当前处理的点的孩子个数

那么这个操作很显然就是删除k次最大值

又发现我们之前将两个函数相加的操作就是将两个函数的拐点列表合并

所以我们写一个可并的大根堆(或者直接使用pb_ds)就可以完成合并函数和插入一条边的操作了

最后我们得到了根节点的函数,显然$f(root,0)=\sum val$也就是所有边的和,而最右段的斜率就是根节点的度数，我们还知道每经过一个点函数的斜率就会-1,因此根据这3点我们就可以反推出整个函数的表达式

然后就可以做了,提取一下这个分段函数斜率为0的那一段值就ok了

这里使用了配对堆来实现可并堆

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=6*1e5+10;typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
int n;int m;ll tot;ll ans[N];int tp;
namespace par_hp//简易配对堆板子 
{
    int x[N];int al[N];int ct;ll val[N];
    inline void add(int u,int v){x[v]=al[u];al[u]=v;}
    inline int mg(int u,int v)
    {
        if(!u)return v;if(!v)return u; 
        if(val[u]<val[v])swap(u,v);add(u,v);return u;
    }
    inline int fpop(int u)
    {
        if(!u)return 0;if(!x[u])return u;int v1=x[u];int v2=x[v1];
        x[u]=x[v1]=0;return mg(mg(u,v1),fpop(v2));
    }
    inline void dfs(int u){ans[++tp]=val[u];for(int i=al[u];i;i=x[i])dfs(i);}
    struct hp//为了方便起见单独封了一个可并堆结构体 
    {
        int rt;
        inline void push(const ll& x){val[++ct]=x;rt=mg(rt,ct);}
        inline ll top(){return val[rt];}
        inline void pop(){rt=fpop(al[rt]);}
        inline void join(int p){rt=mg(rt,p);}
    };
}par_hp::hp h[N];int fa[N];ll val[N];int d[N];ll sum;
int main()
{
    read(n);read(m);
    for(int i=2;i<=n+m;i++)read(fa[i]),read(val[i]),d[fa[i]]++,sum+=val[i];
    for(int i=n+m;i>1;i--)
    {
        ll l=0;ll r=0;//合并 
        while(d[i]--){r=h[i].top(),h[i].pop();}l=h[i].top();h[i].pop();
        h[i].push(l+val[i]);h[i].push(r+val[i]);h[fa[i]].join(h[i].rt);
    }par_hp::dfs(h[1].rt);sort(ans+1,ans+tp+1);tp-=d[1];//处理函数 
    for(int i=1;i<=tp;i++)
        sum-=(ll)(ans[i]-ans[i-1])*(tp-i+1);printf("%lld\n",sum);
}

```









---

## 作者：fy0123 (赞：15)

超神！！！根本想不到啊！

我可是理解了好久好久的喵呜。。。(σ-`д･´)

题解比代码还长.jpg


```cpp
/*
*	令f(x)表示将某个点为根的子树中所有叶子到它的距离置为x的最小代价；
*	发现它是一个下凸函数，并且是线性的，即一次函数；
*	形象地理解一下，最小值左边的部分，大部分是由原来的长度减去值得到；
*	最小值右边的部分，大部分是由原来的长度加上值得到；
*	考虑一个点u，从所有儿子v转移过来；
*	过程分两步：
*	<1> 将所有v的凸包加上u-v这条边；
*	<2> 将加完边的凸包合并；
*	假设现在要加一条边w，f(x)在x属于[L,R]是取到最小值，要从f(x)转移到f'(x)；
*	分四种情况：
*	+================================================================+
*	1.x<=L			f'(x)=f(x)+w;
*	原来这部分都是减去值得到，现在加了一条边之后仍要得到这个值x；
*	所以也必须要减去值才能满足，故直接减去w，将这条边变为0；
*	2.L<=x<=L+w		f'(x)=f(L)+w-(x-L)
*	这一段是从x=L开始的斜率为-1的一次函数；
*	由于之前将这条边减为0了，现在一点点加回去，相应的代价就逐渐减少1；
*	3.L+w<=x<=R+w	f'(x)=f(L)
*	将原先的取到最小值的部分转移到了这一段；
*	4.R+w<=x		f'(x)=f(L)+(x-R)-w
*	这一段是从x=R+w开始的斜率为1的一次函数；
*	原因是到了这里以后，每次只要在w这条边上+1即可；
*	+================================================================+
*	总结一下即，将[L,R]一段向右平移，[0,L]一段向上平移；
*	中间插入一段斜率为-1的线段，再将右边改为斜率为1的直线；
*	合并操作只要将函数相加即可；
*	考虑怎么维护：
*	不失一般性，认为每一个拐点都能使斜率+1；
*	///观察///：
*	- 每次加边后，会让凸包最右端斜率为1，即一次合并后最右端斜率即为儿子个数；
*	- 凸包左边一段借据已知，即f(0)=边权和；
*	据此推算凸包表达式：
*	设此时拐点个数为p，根的儿子个数为d，总边权和为s；
*	则f(x)在0处的表达式为：f(x)=-(d-p)*x+s；
*	从小到大扫描每个拐点就能得到整个凸包的表达式；
*	我们现在只关心拐点的横坐标位置；
*	考虑用可合并大根堆存储拐点；
*	于是 <1> 就变成了：从堆中弹出点直到斜率为0，再将[L,R]右移以后的两个拐点加入；
*	<2> 就直接合并即可；
*	最后计算答案只需找到斜率为0的那一段计算代价即可；
*	神题啊！
*/
#include<bits/stdc++.h>
#define rep(i, x, y) for(int i = (x); i <= (y); i++)
#define per(i, x, y) for(int i = (x); i >= (y); i--)
#define N 600010
#define ll long long
using namespace std;
int n, m, tot, fa[N], w[N], d[N], rt[N];
ll sum;
struct heap {//左偏树，维护大根堆
	int l, r, dis; ll v;//v存当前点的横坐标值
} tr[N];
inline int merge(int x, int y) {
	if(!x || !y) return x+y;
	if(tr[x].v < tr[y].v) swap(x, y);
	tr[x].r = merge(tr[x].r, y);
	if(tr[tr[x].l].dis < tr[tr[x].r].dis) swap(tr[x].l, tr[x].r);
	if(!tr[x].r) tr[x].dis = 0; else tr[x].dis = tr[tr[x].r].dis+1;
	return x;
}
inline int pop(int x) { return merge(tr[x].l, tr[x].r); }
int main() {
	scanf("%d%d", &n, &m);
	rep(i, 2, n+m) {
		scanf("%d%d", &fa[i], &w[i]);
		sum += w[i]; d[fa[i]] ++;//d[]儿子个数，sum边权和
	}
	per(i, n+m, 2) {
		ll l = 0, r = 0;//l,r保存当前的斜率为0的一段
		if(i <= n) {
			while(--d[i]) rt[i] = pop(rt[i]);//不停弹出最大的点，直到斜率为0；点数刚好是儿子数
			r = tr[rt[i]].v; rt[i] = pop(rt[i]);
			l = tr[rt[i]].v; rt[i] = pop(rt[i]);
		}
		tr[++tot].v = l+w[i]; tr[++tot].v = r+w[i];
		rt[i] = merge(rt[i], merge(tot, tot-1));
		rt[fa[i]] = merge(rt[fa[i]], rt[i]);//合并儿子
	}
	while(d[1]--) rt[1] = pop(rt[1]);
	while(rt[1]) { sum -= tr[rt[1]].v; rt[1] = pop(rt[1]); }
	printf("%lld\n", sum);
	return 0;
}
```

---

## 作者：lcjqwq (赞：14)

### Description 

给定一棵以 $1$ 为根的 $n$ 个节点的树，每条边有一个边权。有 $m$ 个叶子。将一条边的边权从 $x$ 修改至 $y$ 需要的代价是 $|x-y|$  。求将所有叶子到根节点的距离修改成相同的最小代价。


### Solution 

神仙题。参考：https://blog.csdn.net/u014609452/article/details/52347062；洛谷题解第一篇。

定义 $f_x(y)$ 表示将以 $x$ 为根的子树中所有叶子结点到 $x$ 节点的距离都修改成 $y$ 所需要的代价。我们得到的结论是：**$f_x$ 是个分段函数，每一段为一个一次函数，并且下凸（即一个凸壳）**。

这个结论的证明要用到数学归纳法，不多赘述。

考虑维护这个凸壳。即现在已知每个儿子的凸壳，应该如何合并出这个节点的凸壳。

儿子节点的凸壳首先需要往其中加入父亲到他的这一条边。可以证明有了这一条边后依然是一个凸壳。

对每个儿子都这么做，得到的所有凸壳相加即为父亲节点的凸壳。

于是问题变为如何维护 ”往上增加一条边“ 后凸壳的变化。

设增加这条边的边权是 $w$ ，要增加的这个函数是 $f$ ，新的函数是 $g$ ，最小值在 $L$ 到 $R$ 取到。

1. 对于 $x \leq L$ ，此时要把新加的这条边减成 $0$ ，代价 $w$ 即 $g(x) = f(x) + w$
2. 对于 $L \leq x \leq L + w$ ，此时先将原来的子树里的每个叶子到根的距离修改成 $L$ ，加上 $w$ 后要再修改成 $x$ 需要 $L + w - x$ 的代价 （先把 $w$ 的边干掉然后用 $L - x$ 的代价从 $L$ 到 $x$ ）。即 $g(x) = f(x) + w + L -x$
3. 对于 $L + w \leq x \leq R + w$ ，此时 $g(x) = f(x - w)$ 。又因为 $x - w \in [L, R]$ 都是最小值，所以 $g(x) = f(L)$ 
4. 对于 $R+w \leq x$ ，此时先将原来的子树里的每个叶子到根的距离修改成 $R$ ，加上 $w$ 再修改成 $x$ 需要 $|R + w - x| = x - w - R$ （其实和 2 差不多只是正负的问题）。即 $g(x) = f(x) + x - w - R$ 

容易看出，$g$ 的最小值在 $[L + w, R + w]$ 取到。

得到这些性质后，~~我已经自闭了...~~ 我们可以分析它的几何意义。

第一段（$x \leq L$） 相当于是往上做了一个平移。

第二段（$L \leq x \leq L + w$）你会发现，$g(x) = f(x) + w - L - x$ 中有一个 $-x$ 。这说明这一段的斜率是 $-1$ 

第三段（$L + w \leq x \leq R + w$）这一段其实就是一段平的（这也是为啥它是新函数取到最小值的段），斜率维 $0$

第四段（$R + w \leq x$ ）你会发现，$g(x) = f(x) + x - w - R$ 有一个 $+x$ 。这说明这一段的斜率是 $1$ 

这样我们就知道了新凸壳与原来的凸壳的区别：**将 $L$ 左边一段向上平移，删除右边，新增两个拐点 $L+w, R+w$ 并且 $L$  到 $L+w$ 的斜率为 $-1$ ，$L+w$ 到 $R + w$ 的斜率是 $0$，$R + w$ 往右的斜率是 $1$ **。

有了这个结论，然后的做法其实还不是很显然（至少对我来说）。

这个凸壳还有一个可以证明的性质：（从左到右）每当**经过一个拐点**，那么**斜率会增加 $1$ **

我们可以对每个点存放凸壳的拐点（的横坐标）。

每次将儿子节点的凸壳弹出后面的（从大到小）拐点，然后加入两个新拐点。然后将儿子节点的拐点合并到该节点的凸壳中。

这个过程中，需要支持：删除（横坐标）最大的拐点；合并。自然想到**可并堆**。

还剩下几个小问题：

1. **实现时，如何弹出拐点直到最小值的那一段**？最右边的那一段的斜率是儿子数量。（因为每合并一次右端斜率 ++） 所以弹出儿子数量个拐点即可。
2. **最后的答案如何计算？或：最小值那一段该如何计算？** $f_1(0)$ 很好计算，为所有边权的和。我们又知道，每一个拐点使得斜率++。于是可以先把右边的点弹掉（儿子个），然后计算即可

还有一个很骚的操作，即一种快乐的可并堆：

```cpp
int merge(int x, int y) {
  if(!x || !y) return x + y; 
  if(vx[x] < vx[y]) swap(x, y); 
  int d = rand() % 2; 
  ch[x][d] = merge(ch[x][d], y); 
  return x; 
}
```

懒人专用，复杂度很对（426ms）。会证明复杂度的可以私信我，我太菜了不会证...

### Code 

[看代码戳这里](https://acfunction.github.io/2019/04/05/BZOJ4585/)

看我写的这么辛苦，点个赞吧qaq

---

## 作者：RenaMoe (赞：8)

首先 DP 设 $f(u,i)$ 表示 $u$ 为根的子树内所有叶子到 $u$ 的爆炸时间为 $i$ 的最小代价。

代价函数是一个绝对值函数，可以发现 $f(u,x)$ 的图像是一个下凸包。

将 $u$ 的所有儿子合并就是凸包相加。

加入 $u$ 到 $\mathrm{fa}(u)$ 的边 $c_u$ 的代价时，

$$
f'(u,i)=\min_{0\le j\le i}\{|c_u-j|+f(u,i-j)|\}
$$

也就是函数 $|c_u-x|$ 和 $f(u,x)$ 形成的凸包的闵可夫斯基和（注：两个点集 $A,B$ 的闵可夫斯基和为 $\{x+y\mid x\in A,y\in B\}$）。

模拟一下闵可夫斯基和的归并过程，在这里只需要将 $f(u,x)$ 中斜率为 $0$ 的线段向后平移，前面插入向量 $(c_u,-c_u)$，后面只保留一条斜率为 $1$ 的射线。

具体实现，用拐点表示法可以方便地将两个凸包相加，用可并堆维护凸包的所有拐点，每个拐点同时代表后面线段斜率 $+1$。

每次合并子树注意结尾只保留一个斜率为 $+1$ 的射线。

最后取斜率 $0$ 处的值，可以用凸包开头的点值 $\sum_i c_i$ 减去每个拐点的横坐标。

代码：

```cpp
#include <bits/stdc++.h>

// 这是个自适应的左偏树，不用记 dist
struct Node {
    int64_t pos;
    Node *ls, *rs;
    
    Node(int64_t v) : pos(v), ls{}, rs{} {}
};

Node *merge(Node *x, Node *y) {
    if (!x) return y;
    if (!y) return x;
    if (x->pos < y->pos) std::swap(x, y);
    x->rs = merge(x->rs, y);
    std::swap(x->ls, x->rs);
    return x;
}

void pop(Node *&x) {
    x = merge(x->ls, x->rs);
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector<int> fa(n + m), c(n + m), son(n + m);
    for (int i = 1; i < n + m; ++i) {
        std::cin >> fa[i] >> c[i];
        --fa[i];
        ++son[fa[i]];
    }

    std::vector<Node *> f(n + m);
    for (int u = n + m - 1; u > 0; --u) {
        int64_t l = 0;
        int64_t r = 0;
        if (u < n) {
            --son[u];
            while (son[u]--) pop(f[u]);
            r = f[u]->pos;
            pop(f[u]);
            l = f[u]->pos;
            pop(f[u]);
        }
        // [l, r] 就是斜率为 0 的线段
        f[u] = merge(f[u], merge(new Node(l + c[u]), new Node(r + c[u])));
        f[fa[u]] = merge(f[fa[u]], f[u]);
    }

    while (son[0]--) pop(f[0]);
    int64_t ans = std::accumulate(c.begin(), c.end(), 0ll);
    while (f[0]) {
        ans -= f[0]->pos;
        pop(f[0]);
    }
    std::cout << ans << '\n';

    return 0;
}
```



---

## 作者：roger_yrj (赞：6)

## P3642 [APIO2016] 烟火表演

### 本题知识点

- DP 凸优化
- 闵可夫斯基和

### 题意

给定一棵 $n$ 个点的树，有边权。每次操作可以将一条边的权值 $+1$ 或 $-1$。求最少操作次数使得每个叶子到根的距离相等。

### 题解

我们考虑树形 $DP$。

令 $f_{i,x}$ 表示使子树 $i$ 的叶子到 $i$ 的距离为 $x$ 的最小代价。

很容易写出转移：

$$f_{i,x}=\sum\limits_{j\in son_i}\min\limits_{0\le y\le x}|c_j-y|+f_{j,x-y}$$

转移时间复杂度均摊 $O(\sum\limits_i c_i)$。

考虑优化转移。我们先引入一个概念：

---

#### 闵可夫斯基和

点集 $A$ 与 $B$ 的闵可夫斯基和被定义为：

$$A+B=\{(x+x',y+y')\mid (x,y)\in A,(x',y')\in B\}$$

如果 $A$ 与 $B$ 为凸集，那么 $A+B$ 为凸集。

---

注意到 $f_i$ 都是下凸的，证明：

- 当 $i$ 为叶子时，$f_{i,x}=0$，显然下凸；
- 当 $i$ 不为叶子时，令 $F_i=f_{j,i},G_i=|c_j-i|$。原转移方程转化为 $$f_{i,x}=\sum\limits_{j\in son_i}\min\limits_{0\le y\le x}G_y+F_{x-y}$$。
- $G$ 为下凸函数，假设 $F$ 为下凸函数，那么根据**闵可夫斯基和**，$f_i$ 为下凸函数。
- 根据数学归纳法，所有的 $f_i$ 都是下凸的。

我们可以通过图像来观察 $F$ 转移到 $F+G$ 的变化：

![](https://cdn.luogu.com.cn/upload/image_hosting/oqespmtl.png)

设 $F$ 中斜率为 $0$ 的那一段的左右端点分别为 $L$ 和 $R$。

我们发现，函数有四部分发生变化：

- $x\le L$ 的部分向上平移了 $c_j$ 个单位。
- $L\le x\le R$ 的部分向右平移了 $c_j$ 个单位。
- 两部分之间插入了一个斜率为 $-1$ 的直线。
- 最右边是一个斜率为 $1$ 的直线。

---

知道这些之后，我们开始尝试用代码维护他们。

由于 $F_0$ 是容易算的（就等于子树边权和），我们可以用数据结构去维护拐点。

比如上图的 $F$ 可以表示成：$\{2,3,6\}$。

每个数表示在这个位置斜率会增加 $1$。斜率会增加 $2$ 就用两个一样的数字，以此类推。

于是我们就可以将拐点列表合并，以此实现两个函数的合并。

具体如何实现合并儿子呢？

- 假设有 $k$ 个儿子。
- 对于最右边的斜率为 $1$ 的直线，我们已知每个儿子的最大斜率为 $1$，将儿子合并后最大斜率为 $k$，那么删掉前 $k-1$ 大的拐点后，次大和最大的拐点就是 $L$ 和 $R$。
- 我们接着将 $L$ 和 $R$ 拿出来，那么此时函数最右边的斜率为 $-1$。所以我们将 $L$ 和 $R$ 加上 $c_j$ 后扔进去就完成了。

我们可以用一个可并堆来实现以上操作。

时间复杂度 $O(n\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=6e5+10;
int n,m,tot,d[N],fa[N],ls[N],rs[N],dis[N],root[N];
ll val[N],c[N];
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(val[x]<val[y])swap(x,y);
	rs[x]=merge(rs[x],y);
	if(dis[ls[x]]<dis[rs[x]])swap(ls[x],rs[x]);
	dis[x]=dis[rs[x]]+1;
	return x;
}
int pop(int x){return merge(ls[x],rs[x]);}
int main(){
	cin>>n>>m;n+=m;
	for(int i=2;i<=n;i++){
		cin>>fa[i]>>c[i];
		d[fa[i]]++;
	}
	for(int i=n;i>1;i--){
		ll l=0,r=0;
		if(d[i]){
			while(--d[i])root[i]=pop(root[i]);
			r=val[root[i]],root[i]=pop(root[i]);
			l=val[root[i]],root[i]=pop(root[i]);
		}
		val[++tot]=l+c[i],val[++tot]=r+c[i];
		root[fa[i]]=merge(root[fa[i]],root[i]=merge(root[i],merge(tot-1,tot)));
	}
	while(d[1]--)root[1]=pop(root[1]);
	ll ans=0;
	for(int i=2;i<=n;i++)ans+=c[i];
	while(root[1])ans-=val[root[1]],root[1]=pop(root[1]);
	cout<<ans;
}
```

---

## 作者：HappyJaPhy (赞：6)

注：这是本蒟蒻目前的最长的题解，也是一篇学习笔记。题目引入部分是上课的记录，不完全是本蒟蒻的个人创造，但我觉得用来入门 Slope trick 应该很容易。

[博客传送门](https://www.luogu.com.cn/blog/ImDustSans/slope-trick)

# Slope trick 的定义

Slope trick 是一种通过分析 DP 函数在转移时的斜率变化来优化转移的技巧。通常来说，被维护的函数图像是离散的凸函数，Slope trick 会维护函数的斜率或者斜率的差分。

维护凸函数主要有以下几个优点：

1. 方便维护形如 $dp'[i]\leftarrow \max(dp[i],dp[i-1]+x)$ 的操作（等会的例题会讲怎么维护）。

2. 方便维护加法操作，两个凸函数相加仍然是凸函数。

3. 方便维护 $\max$ 加法卷积操作（形如 $h_k=\max_{i+j=k}(f_i+g_j)$）。

4. 维护差分后方便快速找极值。

# 题目引入

[Buy Low Sell High](https://www.luogu.com.cn/problem/CF865D)

这道经典题有多种做法和理解方式，这里仅介绍从 Slope trick 角度出发的思路。

首先令 $dp[i][j]$ 表示第 $i$ 天结束时持有 $j$ 份股票的最大的收益。方便起见，我们可以强制在每天开始时买一份，然后决策就变成了卖 $0\sim 2$ 份。不妨令 $f[j]$ 表示当前的 DP 图像，$f'[j]$ 表示变化后的图像，那么第 $i$ 天时 DP 图像的变化为：

- （$1$）$f'[j]\leftarrow f[j-1]-p_i$（买一份）
- （$2$）$f'[j]\leftarrow \max(f[j],f[j+1]+p_i)$
- （$3$）$f'[j]\leftarrow \max(f[j],f[j+1]+p_i)$

可以发现 $f$ 的图像始终是凸的。

感性认知一下：$f_i[j]$ 表示第 $i$ 天手上有 $j$ 份股票。因为每天只能卖一份，所以每天肯定先卖最贵的一份，所以卖的越多新卖的那个就越不值钱。$f_i[j]-f_i[j+1]$ 表示多卖的一张股票的价格，那么 $f_i[j]-f_i[j+1]$ 是递减的，因此 $f$ 的图像应该是凸的。

证明：（a）构建费用流模型；（b）归纳法（$\max$ 加法卷积）。下面用归纳法证明。

假设 $f$ 是凸函数，我们需要证明经过上面的 $123$ 三个操作后 $f'$ 也是凸函数。

首先，第 $1$ 个操作就相当于把 $f$ 向右平移一格然后向下平移 $p_i$ 格，因此函数图像凹凸性不变。然后看 $23$ 操作，假设有 $g$ 函数，满足 $g(0)=0$，$g(-1)=p_i$，那么 $f'$ 就等于 $f$ 和 $g$ 进行 $\max$ 加法卷积操作的结果。因为 $g$ 就只有两个值，所以可以认为 $g$ 是一个凸函数，因为两个凸函数进行 $\max$ 加法卷积的结果还是凸函数（这个可以用闵可夫斯基和证，这里就不证了），所以 $f'$ 是凸函数。因此 $f$ 的图像始终是凸的。

我们把 $f$ 变化前后的图像画出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/g1sjtxnm.png)

$f$ 的图像是凸函数有什么用呢？观察 $23$ 操作，其本质上就是：如果 $f[k+1]+p_i\le f[k]$，那么不转移；如果 $f[k+1]+p_i>f[k]$，则进行转移。注意到 $f$ 是凸的，因此只有左边会进行转移，而右边不会。则左边就是一段原本的函数图像向左平移一格，然后向上平移 $p_i$ 格（如上图中黑色线段的 $[0,3]$ 的部分就是红色线段 $[1,4]$ 部分平移的结果）。

根据上面的理论，对于左边进行了转移的那一部分，我们有 $f'[k-1]-f'[k]=f[k]-f[k+1]$，因此新的 $f'$ 在 $i$ 位置上的差分就等于 $f$ 在 $i+1$ 位置上的差分。因此第 $i$ 天的操作就是删除最小的（也就是最左端的）斜率，然后再插入一个斜率 $p_i$。

我们用堆来维护斜率，最终答案就是最左上角的高度。因为右下角的高度是 $\sum_{i=1}^n-p_i$（每天第 $1$ 个操作要向下平移），而高度差可以在每次进行操作 $23$ 时统计。代码如下，非常简单，复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, ans;
priority_queue<int, vector<int>, greater<int>> que;

inline int read(int &x) {
	char ch = x = 0;
	int m = 1;
	while (ch < '0' || ch > '9') {
		ch = getchar();
		if (ch == '-') m *= -1;
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + ch - 48;
		ch = getchar();
	}
	x *= m;
	return x;
}

signed main() {
	read(n);
	int p;
	for (int i = 1; i <= n; i++) {
		read(p);
		if (!que.empty() && que.top() < p) {
			ans += p - que.top();
			que.pop();
			que.push(p);
		}
		que.push(p);
	}
	printf("%lld", ans);
	return 0;
}
```

总结一下：当我们确定 DP 图像是凸的时，我们可以利用凸函数的性质（如：斜率单调，找极值等）快速维护状态转移对应的图像变化。再知道图像其中一个位置的值后，就可以通过斜率把所有 DP 值恢复过来。这一类题目往往要先发现凸性，然后要通过画图来感受转移带来的图像变化，选择合适的维护方式。

# P3642 [APIO2016] 烟火表演

[题目传送门](https://www.luogu.com.cn/problem/P3642)

同上处理，令 $f_i[x]$ 表示 $x$ 秒引爆第 $i$ 个节点的子树的代价，$l$ 为 $i$ 与 $fa[i]$ 的距离。可以发现，$f$ 应该是一个向下凸的函数。令$f$ 为原函数，即 $f_i$；$f'$ 为新函数，即 $f_{fa[i]}$，且 $f$ 在区间 $[L,R]$ 上取到最小值。推 dp 式子可以知道，$f$ 对 $f'[x]$ 的贡献应该是 $F[x]=\min_{k\le x}\{f[k]+|l-x+k|\}$。然后我们对 $x$ 分讨。

- （$1$）当 $x<L$ 时，这时直接修改 $l$ 肯定比修改下面子树更优，从式子上看就是 $k$ 越大越好，所以直接让 $k=x$，得到 $F[x]=f[x]+l$。

- （$2$）当 $x>R+l$ 时，从式子知道，因为 $f[k]$ 在 $k\ge R$ 时的变化率不小于 $k$ 的变化率，所以 $k$ 越接近 $R$ 越好，因此让 $k=R$，得到 $F[x]=f[R]-l+x-R$。

- （$3$）当 $L\le x<L+l$ 时，因为 $k\in(L,L+l)$ 时 $F[x]$ 在上升，$k\le L$ 时 $f[k]$ 比 $k$ 变化的更快，因此 $F[x]$ 在下降，所以我们让 $k=L$，于是有 $F[x]=f[L]+l-x+L$。

- （$4$）当 $L+1\le x\le R+l$ 时，令 $k=x-l$ 时明显是最小的，此时 $F[x]=f[L]$。

看一看这些操作在斜率数组上是怎样的（这里一定要画一下图！这样会更容易理解！）：操作 $1$ 是将 $f$ 向上平移 $l$ 格；操作 $2$ 是将 $f$ 的斜率修改为 $1$；操作 $3$ 是将斜率改为 $-1$；操作 $4$ 是将 $f$ 向右平移 $l$ 格。

因为要实现函数的加法，直接维护斜率不好维护，所以这里我们维护斜率的拐点（或者说差分），让一个拐点表示斜率在这个位置加一（所以拐点可重）。令 $i$ 有 $w$ 个儿子，因为合并一个儿子会增加一个斜率为正的拐点，因此删除 $w-1$ 个最大的拐点，接下来两个是 $R$ 和 $L$，也删除之后加入 $L+l$ 和 $R+l$ 就得到了 $F$ 的拐点表示堆，然后把 $F$ 的拐点合并进 $f'$。我们已知 $f_1[0]=\sum_{i=1}^nl_i$，答案就是 $f_1$ 的最小值。这些操作可以用可并堆完成，时间复杂度 $O((n+m)\log(n+m))$，代码如下。

```cpp
#include <bits/stdc++.h>
#define int long long
#define N 600005
using namespace std;
int n, m, fa[N], l[N], num[N], rt[N], ans, tot;

struct node {
	int l, r, val, dis;
} t[N];

inline int read(int &x) {
	char ch = x = 0;
	int m = 1;
	while (ch < '0' || ch > '9') {
		ch = getchar();
		if (ch == '-') m *= -1;
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + ch - 48;
		ch = getchar();
	}
	x *= m;
	return x;
}

int merge(int x, int y) {
	if (!x || !y) return x + y;
	if (t[x].val < t[y].val) swap(x, y);
	t[x].r = merge(t[x].r, y);
	if (t[t[x].l].dis < t[t[x].r].dis) swap(t[x].l, t[x].r);
	t[x].dis = t[t[x].r].dis + 1;
	return x;
}

inline int pop(int x) {
	return merge(t[x].l, t[x].r);
}

signed main() {
	read(n), read(m);
	for (int i = 2; i <= n + m; i++) {
		read(fa[i]), read(l[i]);
		num[fa[i]]++;
		ans += l[i];
	}
	for (int i = n + m; i > 1; i--) {
		int L = 0, R = 0;
		if (i <= n) {
			while (--num[i]) rt[i] = pop(rt[i]);
			R = t[rt[i]].val, rt[i] = pop(rt[i]);
			L = t[rt[i]].val, rt[i] = pop(rt[i]);
		}
		t[++tot].val = L + l[i];
		t[++tot].val = R + l[i];
		rt[i] = merge(rt[i], merge(tot, tot - 1));
		rt[fa[i]] = merge(rt[fa[i]], rt[i]);
	}
	while (num[1]--) rt[1] = pop(rt[1]);
	while (rt[1]) ans -= t[rt[1]].val, rt[1] = pop(rt[1]);
	printf("%lld", ans);
	return 0;
}
```

感谢围观！如有错误请大佬们指出！

---

## 作者：Purslane (赞：5)

# Solution

Slope Trick 的经典应用。

一个比较显然的思路是设 $dp_{u,x}$ 为**使 $u$ 节点子树内所有节点到 $u$ 的距离都为 $x$ 的最小代价**。那么它可以从子节点 $v$ 的信息转移过来。$dp_{v,i}$ 想要对 $dp_{u,x}$ 产生贡献，得有（设 $u$ 和 $v$ 之间的连边为 $w$） $dp_{v,i} + |w-(x-i)|$，其中 $i \le x$。

设 $f(x) = \min_{0 \le i \le x} \{dp_{v,i} + |w-(x-i)|\}$，可以看做函数 $f_1(x) = dp_{v,x}$ 和 $f_2(x) = |w-x|$ 的 $(\min,+)$ 卷积。

容易观察到 $f_2(x)$ 具有天然的凸性，根据 Minkowski 和的结论，用数学归纳法不难得出，$f_1(x)$ 是凸的。

还有一个值得注意的事实是，$f_2(x)$ 的定义域为所有自然数，那么它左边斜率为 $-1$ 的一段长度有限，右边斜率为 $1$ 的一段长度无限。所以我们可以感性推测一下 $f(x)$ 的图像，应该是一个左下部分的凸包，加上一段平的线（前两个可能都是不存在的），右边有一个好长好长的斜率为 $1$ 的直线。图像差不多长这样：![](https://i.loli.net/2019/03/31/5ca05e4a15b2b.png)，也是贺来的图。

而 $dp_{u,x} = \sum_{v \in son_u} f_v(x)$，我们剩下要处理的就是两个凸包直接相加，考虑如何维护。

注意到凸包上每个转折点都可以表示“之后的线段斜率加一”，且可以用多个重复的点表示斜率增加更多的数。于是我们维护这个凸包的所有转折点，合并两个凸包相当于直接把他们加起来。

再次注意到这时候末尾的线段斜率为 $2$ 了，那我们删掉最大的那个转折点就好了。这种每次合并两个集合或者删去最大值的操作，可以用左偏树维护。

现在只剩下一个问题：如何计算最终的答案。由于最终的 $dp_{rt,0}$ 为所有边权之和，且第一条线的斜率可以直接数点的个数，所以只需要模拟这个凸包的走势就好了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=600000+10;
int n,m,tot,ans,w[MAXN],v[MAXN],lson[MAXN],rson[MAXN],dis[MAXN],rt[MAXN];
int get_node(int val) {return v[++tot]=val,tot;}
int merge(int x,int y) {
	if(!x||!y) return x|y;
	if(v[x]<v[y]) swap(x,y);
	rson[x]=merge(rson[x],y),dis[x]=min(dis[lson[x]],dis[rson[x]])+1;
	if(dis[lson[x]]<dis[rson[x]]) swap(lson[x],rson[x]);
	return x;
}
vector<int> fin;
void add_fin(int u) {
	if(!u) return ;
	fin.push_back(v[u]),add_fin(lson[u]),add_fin(rson[u]);
	return ;	
}
vector<pair<int,int>> G[MAXN];
void dfs(int u) {
	if(G[u].empty()) return rt[u]=merge(get_node(w[u]),get_node(w[u])),void();
	for(auto pr:G[u]) dfs(pr.first),rt[u]=merge(rt[u],rt[pr.first]);
	ffor(i,1,G[u].size()-1) rt[u]=merge(lson[rt[u]],rson[rt[u]]);
	if(u-1) {
		int lst2=rt[u]; rt[u]=merge(lson[rt[u]],rson[rt[u]]);
		int lst1=rt[u]; rt[u]=merge(lson[rt[u]],rson[rt[u]]);
		v[lst2]+=w[u],v[lst1]+=w[u];
		lson[lst2]=rson[lst2]=lson[lst1]=rson[lst1]=0;
		rt[u]=merge(rt[u],merge(lst1,lst2));
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m,n+=m;
	ffor(i,2,n) {int f,c; cin>>f>>c,ans+=c,G[f].push_back({i,c}),w[i]=c;}
	dfs(1),add_fin(rt[1]),sort(fin.begin(),fin.end());
	int lst=0,k=1-fin.size();
	for(auto id:fin) ans=ans+k*(id-lst),k++,lst=id;
	cout<<ans;
	return 0;
}
```

---

## 作者：yshpdyt (赞：4)

题意
=== 
一棵树，给每条边确定一个新边权，代价为新旧之差，使得根节点到每个叶子节点的距离相同，求最小代价。



Slope Trick 部分
===
本题解主要讲述的部分，简单了解什么 Slope Trick 可以看[这篇博客](https://www.cnblogs.com/ruierqwq/p/18017106/slope-trick)。

记 $f(x)$ 表示在**当前节点**将子树内所有叶子的燃烧时间统一为 $x$ 的最小费用函数，$g(y)$ 表示在**当前节点的儿子节点**将子树内所有叶子的燃烧时间统一为 $y$ 的最小费用函数，$w$ 为他们之间的边权，显然有转移方程：

$$f(x)=\sum\limits_{y\in son_x}\left( \min_{y} g(y)+|y+w-x|\right)$$


注意到 $g(y)$ 显然是下凸的（感性理解，修改的值过大过小都不合适，严格的证明可以参考其它题解），于是便有上升段，最优答案的水平段 $[L,R]$，下降段，画出儿子的答案下凸包，研究一个儿子向父亲合并的过程，分为两部分：
- 儿子的凸包增加一条边的贡献，以下简称为**加边**操作。
- 将若干加完边的凸包在父亲处合并，以下简称为**合并**操作。

先考虑加边对于凸包的影响，改变 $f(x)$ 的定义为 $g(y)$ 加边后子树内的总代价，对 $x$ 处于不同位置分情况讨论，以下每种分类讨论种对于 $y+w$ 与 $x$ 关系的方程：

前半部分统一为： $f(x)=g(y)+x-y-w$。

后半部分统一为： $f(x)=g(y)+y+w-x$。

**注意一个隐藏条件：$y\le x$，也就是说只能选择 $x$ 左边的位置作为转移点。**

---
$x<L$
---

由于绝对值的存在，考虑对转移点位置分类讨论来确定最优情况。
- $y+w\le x$：
  >注意到 $g(y)-y$ 单调递减，其它不变，$y=w-x$ 最优，$f(x)=g(x-w)$。


- $x-w\le y\le x$：
    >$y$ 每增大 $1$，由于斜率 $k\le-1$，所以 $g(y)$ 减小值 $\ge 1$，所以 $g(y)+y$ 单调递减，其它不变，取 $y=x$ 最优，$f(x)=g(x)+w\le g(x-w)$。


**综上所述，这种情况取 $f(x)$ 选 $x$ 作为转移点最优。**
 
---
$L\le x\le L+w$
------

- $y\le x-w\le L$：
  >$g(y)$ 单调递减，$y$ 越大越优，取 $f(x)=g(x-w)$ 最优。

- $x-w\le L\le y\le x$：
  >$g(y)$ 不变，所以 $y$ 越小越优，取 $ y=L$ 最优，$f(x)=g(L)+L+w-x$，由于 $y\le L$ 段斜率 $\le -1$，$g(x-w)-g(L)\ge L+w-x$，所以第二种情况更优。


**综上所述，这种情况取 $f(x)$ 选 $L$ 作为转移点最优。**

---
$L+w\le x\le R+w$
---
-  $y\le L\le x-w$：
    >$g(y)$ 单调递减， $y$ 越大越优，取 $y=L$ 最优，取 $f(x)=g(L)+x-w-L$。
-  $L+w\le x-w\le y\le x$：
    >$g(y)$ 不变，$y$ 越小越优，取 $y=x-w$ 最优，$f(x)=g(x-w)=g(L)\le g(L)+x-w-L$，比第一种优。

**综上所述，这种情况取 $f(x)$ 选 $x-w$ 作为转移点最优。**

---

$R+w \le x$
--- 
- $y\le R\le x-w$：
  >$g(y)$ 不变，$y$ 越大越优，取 $y=R$ 最优，$f(x)=g(R)+x-w-R=g(L)+x-w-R$。
- $R\le x-w\le y\le x$：
  >$g(y)+y$ 单调递增，取 $y=x-w$ 最优，$f(x)=g(x-w)$，由于斜率不小于一，$x-w-R\le g(x-w)-g(R)$，所以不如第一种情况优。

**综上所述，这种情况 $f(x)$ 选 $R$ 作为决策点最优。**

--- 
所以总的转移方程为：

$$ f(x)=\begin{cases}
g(x)+w  &,\text{if } x\le L \\
g(L)+L+w-x  &,\text{if } L\le x\le L+w\\
g(L)  &,\text{if } L+w\le x\le R+w \\
g(L)+x-w-R  &,\text{if } R+w\le x
\end{cases}$$

加边合并
=== 
考虑如何快速实现 $g(y)$ 的加边操作的更新以及儿子间的合并，分段来看：

- 对于 $x\le L$ 来说，实际上是将 $g(x)$ 的图像向上平移了 $w$。
- 对于 $L\le x\le L+w$ 来说，实际上是插入了一条斜率为 $-1$ 的直线 $f(x)=-x+g(L)+L+w$。
- 对于 $L+w\le x\le R+w$ 来说，这段成为新的水平段，也是 $f(x)$ 的最小答案，相当于把原来的 $[L,R]$ 向右平移了 $w$。
- 对于 $ R+w\le x $ 来说，相当于改变成了斜率为 $1$ 的直线 $f(x)=x+g(L)+x-w-R$。

加边后的凸包有几个优良的性质：
- 代入端点值进行计算不难发现函数仍然是连续的。
- 每次加边后，凸包的左端斜率单调递增，右端斜率变成 $1$。
- $f(0)$ 的值为边权和。 

考虑合并凸包，暴力的方法是直接相加，瓶颈在于合并后对 $f(x)$ 的维护更新。**注意到凸包经过拐点斜率增加的性质，不妨认为经过每个拐点后斜率增加 $1$，不存在的段多个拐点重叠即可。**

这样做的优点：
- 方便合并凸包，只需要把儿子的凸包拐点全塞给父亲即可。
- 容易找到某段特定斜率的起始点：合并完后右边最右端斜率变成 $d$，从右往左数 $d$ 个可以找到 $R$ 的位置，再往左一个可以找到 $L$ 的位置。
- 知道斜率，截距 $f(0)$，可以推出第一段的表达式，知道每一个拐点的横坐标，就知道了整个凸包的表达式，从而可以算出 $g(L)$。

于是我们发现，**只需要维护拐点的横坐标，就能知道 $[L,R]$ 的位置，和 $g(L)$ 的大小**，把我们需要的要素集齐了，而维护横坐标的合并只需要一个可并堆即可。

返回去考虑加边在可并堆上如何操作，根据大根堆的性质，从右往左一个部分一个部分维护：

- 对于 $ R+w\le x $ 来说，弹出儿子数量 $d-1$ 个拐点就能使斜率变成 $1$。
- 对于 $L+w\le x\le R+w$ 来说，弹出 $d-1$ 次后的栈顶元素是 $R$，再弹出一次就是 $L$，弹出 $L$，$R$ 后重新塞入 $L+w$ 和 $R+w$ 即可。
- 对于 $L\le x\le L+w$ 来说，由于 $[L+w,R+w]$ 斜率为 $0$，所以前一段斜率必定是 $-1$，且必定包含 $[L,L+w]$，上一步已经顺带完成了。
- 对于 $x\le L$ 来说，只需要对 $f(0)$ 增加 $w$ 即可，横坐标不需要修改。

考虑最后答案的表示方法，对每个拐点按照右边线段斜率编号 $0$ 到 $k$，于是有：
$$f(L)+\sum\limits_{i=0}^{k-1} i(x_i-x_{i+1})=f(0)$$

然后变形：
$$f(L)=f(0)-\sum\limits_{i=0}^{k-1} i(x_i-x_{i+1})=f(0)-\sum\limits_{i=0}^k ix_i-(i-1)x_i=f(0)-\sum\limits_{i=0}^k x_i$$

只需要所有边权之和减去 $L$  及以前的所有点的横坐标就是答案。



代码部分
===
使用 pb_ds 的可并堆，代码非常好写，时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define ll long long
#define N 300005
#define endl "\n" 
#define fi first
#define se second
using namespace std;

const ll mod=1e9+7;
const ll inf=1e18;
const double eps=1e-6;
__gnu_pbds::priority_queue<ll> q[N];
ll n,m,w[N],d[N],res=0;
vector<ll>v[N];

void dfs(ll x){
    ll l=0,r=0;
    for(auto y:v[x]){
        dfs(y);
        q[x].join(q[y]);
    }
    if(x<=n){
        for(int i=1;i<d[x];i++)q[x].pop();
        r=q[x].top();q[x].pop();
        l=q[x].top();q[x].pop();
    }
    q[x].push(l+w[x]);
    q[x].push(r+w[x]);
}
int main(){
    cin>>n>>m;
    for(int i=2,x;i<=n+m;i++){
        cin>>x>>w[i];
        res+=w[i],d[x]++;
        v[x].push_back(i);
    }
    dfs(1);
    q[1].pop();
    ll now=1;
    while(!q[1].empty()){
        res-=q[1].top();
        q[1].pop();
    }
    cout<<res<<endl;
    return 0;
}
```

---

## 作者：Mirasycle (赞：3)

$F_u(x)$ 表示以 $u$ 为根的子树中到达时间为 $x$ 的代价，则有
$$ F_u(x)=\sum F_v(k)+\lvert x-k-l_{v \to u}\rvert$$

我们发现了绝对值函数，联系之前 $dp$ 优化策略可以联想到凸函数优化，数学归纳法可证 $F_u(x)$ 为下凸函数。

凸优化是需要通过一个堆维护点集，由于需要子节点的向上合并所以可以用到可并堆。

这题转移方程形式和 CF713C 不一样，那题的贡献函数与 $k$ 无关，$k$ 可以直接调整至最优，所以可以直接处理出前缀最大值。而这道题贡献函数与 $k$ 有关，所以我们应该思考对于父节点的 $x$ 子节点的什么 $k$ 转移过来才是最优的。

还是记子节点斜率为 $0$ 那一段左右端点为 $L$ 和 $R$ 与 $x$ 的关系。

$x \le L$ 时候 $f_u(x)=f(x-deta)+deta+l_{v \to v}$，考虑 $f(x-deta)+deta$ 有两种思考方案

1. 分析函数性质 $f(x)$ 斜率 $\le-1$，所以 $deta=0$ 的时候 $f(x-deta)+deta$ 取最小值

1. 思考实际意义，$deta=0$ 的时候相当于在 $u \to v$ 这条边上直接修改边权，如果 $deta>0$ 相当于对于 $v$ 的每一个子节点进行修改，因为 $v$ 的子节点个数 $ \ge 1$ 需要修改更多的边，所以对于子节点的边修改显然是需要更大代价。

于是就有 $x \le L$ 的时候 $f_u(x)=f_v(x)+ l_{u \to v}$

其他情况也是类似思考方式。

可以得到

$$ f_u(x) = \begin{cases} 
f_v(x)+l & x \le L 
\\ f_v(L)+l-(x-L) & L < x \le L+l 
\\ f_v(L) & L+l  < x \le R+l
\\ f_v(R)+x-R-l & R< x
\end{cases}$$

思考一下如何转移，第一段是向上平移，第二段是加入一条一次函数，第三段是向右边平移。第四段是将最后的斜率改为 $1$，原因是由 $f(R)$ 这个值加上一次函数得到的所以斜率为 $1$。其实第三段我们可以不用管因为在处理第二段的时候就相当于将第三段平移过了。可并堆维护即可。

这种复杂函数图象维护可以自己画图感受一下更好。网上有一些这种凸函数维护操作的模板方法，但是实际运用起来却不可照搬，像这题的处理操作就很灵活，和我之前看到的处理模板方法不太一样，每一题需要思考符合题意的维护方式，仔细画图研究，大胆维护。

---

## 作者：wind_whisper (赞：3)

# 解析
感觉是左偏树的神题了.

首先有一个比较显然的结论，一个合法的方案中，两个叶子到它们 $\text{lca}$ 的距离必须相等.

考虑设计 $\text{dp}$ ：

$f_{i,x}$ 表示 $i$ 的子树中，所有叶子到它的距离为 $x$ 的最小代价.

考虑这个函数如何向父亲合并.
设一个结点到父亲的距离为 $c_i$ .
朴素 $\text{dp}$ ，就有：
$$f_{i,x}=\sum_{j\in son_i}\min_{v\geq0}^xf_{j,x-v}+|c_j-v|$$
这玩意显然复杂度爆炸啊...

------
换个角度，考虑 $f$ 函数本身的性质.  
不难想到，原来的函数应该是一个下凸的线性函数.  
$son_i$ 的函数如何向 $i$ 合并？  
一开始，这个函数似乎就是简单的所有子节点函数相加合成.  
并且，由于 $c_{i}$ 的存在，这个函数肯定要往右移 $c_i$ .  
假设移动完长这样：

![请添加图片描述](https://img-blog.csdnimg.cn/eec4035e7b694f419a3300467b2f8c40.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2luZF9fd2hpc3Blcg==,size_12,color_FFFFFF,t_70,g_se,x_16)

但是，考虑到有 $i$ 连向 $fa_i$ 的边，有些修改可以在这里一起改，就不必各自麻烦了，所以肯定函数会变化，准确的说，变得更好.  

设斜率为 $0$ 的区间为 $[L,R]$ .  
然后我们发现 $R$ 右侧还有好多斜率大于 $1$ 的地方.  
大概的实际意义就是每个儿子都各自修改，这就很亏.  
所以对于 $f_{i,x}$ 我们干脆在先全部调整成距离为 $R$，支付 $f_{i,R}$ 的代价，再把当前结点连向父亲的边权值增大 $x-R$ .
这样就把 $R$ 右侧的斜率全都变成了 $1$ .
变成这样：  

![请添加图片描述](https://img-blog.csdnimg.cn/1a88c1c008ca486fb216a114074e4642.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2luZF9fd2hpc3Blcg==,size_20,color_FFFFFF,t_70,g_se,x_16)



另一边可以类似的搞吗？
差不多，但是有个问题...
**边的权值非负！**
所以我们斜率为 $1$ 的区间往左增加的长度最多为 $c_i$ .
后面的函数就往左顺延 $c_i$ .
也就是变成：

![请添加图片描述](https://img-blog.csdnimg.cn/2e90dda2055c4787959bb9cc371b7bf4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2luZF9fd2hpc3Blcg==,size_17,color_FFFFFF,t_70,g_se,x_16)


别忘了，本来这个函数是整体右移 $c_i$ .
这里左边的斜率大于1的区间又往左移动了 $c_i$ .
所以其实根本位置没变.

总结一下的话，这个函数合并到父亲后，就是 **把斜率为 $0$ 的区间 $[L,R]$ 右移 $c_i$ ，把 $R$ 右边的函数斜率全改为 $1$ ，斜率为 $0$ 的区间往右延长 $c_i$ 补上 $L$ 右移的空缺**. 
实现上，建一个可并堆维护所有的拐点，令相邻拐点斜率差为 $1$ （如果两端之间斜率差大于 $1$ 就插多个横坐标相同的拐点），那么其实就把 $R$  右侧的所有拐点弹掉，并把 $L$ 和 $R$ 的坐标加上 $c_i$ 就行了.

最后合并到根之后，我们只有拐点的横坐标，如何求出答案（也就是 $f_{1,L}$ ）呢？
注意到， $f_{1,0}$ 其实就是所有边权之和，能很方便的求出来，又因为我们知道相邻两个端点的斜率差均为 $1$ ， $[L,R]$ 的斜率为 $0$ ，那么我们只需要倒着推一遍就行了.
# 代码

```cpp
#include<bits/stdc++.h>
const int N=1e6+100;
const int mod=1e9+7;
#define ll long long
using namespace std;
inline ll read() {
	ll x(0),f(1);char c=getchar();
	while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}

int n,m;
int fa[N],fv[N],son[N];
int rt[N],tot,ls[N],rs[N],dis[N];
ll val[N];
int merge(int x,int y){
	//printf("merge x=%d y=%d\n",x,y);
	if(!x||!y) return x|y;
	if(val[x]<val[y]) swap(x,y);
	rs[x]=merge(rs[x],y);
	if(dis[ls[x]]<dis[rs[x]]) swap(ls[x],rs[x]);
	dis[x]=dis[rs[x]]+1;
	return x;
}
inline int pop(int x){
	return merge(ls[x],rs[x]);
}
ll sum;
void debug(int x){
	if(!x) return;
	printf("x=%d ls=%d rs=%d val=%lld\n",x,ls[x],rs[x],val[x]);
	debug(ls[x]);debug(rs[x]);
	return;
}
int main(){
	dis[0]=-1;
	n=read();m=read();
	for(int i=2;i<=n+m;i++){
		fa[i]=read();son[fa[i]]++;sum+=(fv[i]=read());
	}
	for(int i=n+m;i>=2;i--){
		ll l(0),r(0);
		//printf("i=%d\n",i);
		if(i<=n){
			while(--son[i]) rt[i]=pop(rt[i]);
			r=val[rt[i]];rt[i]=pop(rt[i]);
			l=val[rt[i]];rt[i]=pop(rt[i]);
			//printf("ok");
		}
		val[++tot]=l+fv[i];val[++tot]=r+fv[i];
		rt[i]=merge(rt[i],merge(tot-1,tot));//printf("OK rtfa=%d\n",rt[fa[i]]);
		printf("\ni=%d:\n",i);debug(rt[i]);
		rt[fa[i]]=merge(rt[fa[i]],rt[i]);
	}
	//debug(rt[1]);
	while(son[1]--){
		rt[1]=pop(rt[1]);
		//printf("\nrt=%d\n",rt[1]);
	}
	while(rt[1]){
		sum-=val[rt[1]];rt[1]=pop(rt[1]);
		//printf("\nrt=%d\n",rt[1]);
	}
	printf("%lld\n",sum);
}
/*
1
281239
*/
```


---

## 作者：Anoshag_Ruwan (赞：2)

祝 OIer 们新年快乐！

这是一道利用函数凸性优化 dp 的经典神题，且 THUPC2024 初赛的 B 题很大程度上沿用了它的思路。首先，最优方案显然可以让叶节点到根的距离统一成整点，我们考虑最暴力的 dp，对于以 $x$ 为根的子树，令 $f_{x,i}$ 表示子树内叶节点到 $x$ 距离统一成 $i$ 的代价，$g_{x,i}$ 表示子树内叶节点到 $p_x$ 距离统一成 $i$ 的代价，其中 $i \geq 0$，转移方程即为 $\begin {cases} f_{x,i}=\inf\times[i \neq 0],&x>n\\f_{x,i}=\sum\limits_{j \in son_x}g_{j,i},&x \leq n\\g_{x,i}=\min\limits_{k \in [0,i]}(f_{x,i-k}+|c_i-k|)\end {cases}$。换句话说，对于 $f(x)$ 合并子树的 $g(x)$ 直接按位相加就行了，而将一条边的贡献合并进它连接的子树则需要取 $\min$ 操作,时间复杂度为 $O(nv^2)$，其中 $v=\sum c_x$。

然后呃它实在是过于暴力了，甚至很难写好正确的离散化。于是考虑优化，对每条边令 $h_{x,i}=|c_x-i|$ 表示将边权修改为 $i$ 的代价，这是经典的凸函数，考虑函数凸性入手。转移方程中，按位相加不会损失凸性，而合并一条边的过程相当于对 $f(x)$ 和 $g(x)$ 做 $\min$ 卷积，也就是对两个向量集做[闵可夫斯基和](https://www.luogu.com.cn/blog/BingAD/min-ke-fu-si-ji-hu)并取同一纵坐标下的最低点，若 $f(x)$ 与 $h(x)$ 均为凸包则结果同样具有凸性。毫无疑问任意 $f(x)$ 和 $g(x)$ 都是满足下凸性的。那样 $\min$ 卷积直接取 $f(x)$ 中斜率为 $0$ 的一段，得到仅存在斜率为 $-1,0,1$ 的函数不就行了吗？显然不行，因为这样很可能出现把边权修改为负数的情况。我们不妨令 $[l,r]$ 表示 $f(x)$ 中斜率为 $0$ 的区间，则得到如下转移方程$g_{x,i}=\begin {cases} f_{x,i}+c_x&i \in [0,l]\\f_{x,l}+(l+c_x-i)&i \in [l,l+c_x]\\f_{x,i-c_x}&i\in[l+c_x,r+c_x]\\f_x,r+(i-c_x-r)&i\geq r+c_x\end {cases}$。（可以在坐标系上模拟闵可夫斯基和的过程）。

凸包的常见处理方式，这里不太好二分，于是处理方法是通过维护斜率差分数组的非零位置（或者说，凸壳的“拐点”坐标，若拐点重合则代表越过该点的斜率变化量 $>1$）维护凸包信息，那么按位相加相当于对该数组直接归并，更好的是而 $\min$ 卷积的四个操作在这里只需要两个操作：1.把斜率 $>1$ 的拐点都抹除（斜率 $\geq 1$ 的部分斜率变为 $1$），2.把剩余最大的两个拐点向右平移 $c_x$（把斜率 $\geq 0$ 的区间向右平移 $c_x$）。这样做的同时，原函数斜率为 $-1$ 的区间会比原先延长 $c_x$ ，而如果保证极小值不变，斜率 $<-1$ 的部分这时正好向上平移了 $c_x$ 步。需要维护有序数组并支持删除最大值与合并，显然可以直接用可并堆（左偏树）维护。我们只需要知道一个定点就可以通过差分数组还原出凸包各位置的值，最后计算答案时先求出 $dp_{1,0}=v=\sum\limits c_x$，然后对于斜率 $<0$ 的部分依次减掉即可。

值得一提的是，这个"找出一个新权值序列满足某种关系，使其与原权值序列的对应位置偏移量之和最小"的问题让人想到[序列保序回归](https://www.luogu.com.cn/problem/P4331)，同样是可并堆解决的经典问题。码量十分友善。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
using namespace std;
const int N=6e5+11; 
struct ltr{LL ls,rs,d,w;}t[N];
LL hd[N],nt[N],b[N],c[N],rt[N],h,n,m1,m=1;
inline void addln(LL x,LL y,LL z){
	nt[++m]=hd[x],b[m]=y,c[m]=z,hd[x]=m;}
inline LL rd(){
	LL i=0,j=1;char g=getchar();
	while(g>57||g<48){if(g=='-')j=-1;g=getchar();}
	while(g>47&&g<58)i=(i<<3)+(i<<1)+g-48,g=getchar();
	return i*j;
}
inline LL mrg(LL x,LL y){
	if(!x||!y)return x+y;
	if(t[x].w<t[y].w)swap(x,y);
	t[x].rs=mrg(t[x].rs,y);
	if(t[t[x].ls].d<t[t[x].rs].d)swap(t[x].ls,t[x].rs);
	t[x].d=t[t[x].rs].d+1;
	return x;
}
inline void del(LL x){rt[x]=mrg(t[rt[x]].ls,t[rt[x]].rs);} 
inline void dfs(LL x,LL y){
	if(x>n){t[x].ls=++h,t[x].w=t[h].w=y;return;}
	LL i,k,k1;
	for(i=hd[x];i;i=nt[i]){
		dfs(b[i],c[i]);rt[x]=mrg(rt[x],rt[b[i]]);
	}if(x==1)return;
	for(i=hd[x];i;i=nt[i])if(i!=hd[x])del(x);
	k=rt[x],t[rt[x]].w+=y;del(x);
	t[rt[x]].w+=y;t[k].ls=t[k].rs=0;
	rt[x]=mrg(rt[x],k);
}
int main()
{
	LL i,j,k=0,h1,h2;n=rd(),m1=rd();h=n+m1;rt[1]=1;
	for(i=2;i<=n+m1;rt[i]=i,i++){
		LL u=rd(),v=rd();addln(u,i,v);}
	dfs(1,0);
	for(i=2;i<=m;i++)k+=c[i];
	for(i=hd[1];i;i=nt[i])del(1);
	for(i=1;rt[1];i++){h1=t[rt[1]].w;del(1);h2=t[rt[1]].w;k-=(h1-h2)*i;}
	printf("%lld\n",k);
	return 0;
}
```




---

## 作者：Prean (赞：2)

设 $dp[u][k]$ 表示子树中所有叶子都距离自己的父亲节点长度为 $k$ 的最小代价。（定义 $1$ 号节点的父亲节点为 $0$，距离为 $0$）

不难发现有 $dp[u][k]=\min_{i=0}^{k}(|i+w-k|+(\sum_{v\in son(u)}dp[v][i]))$。其中 $w$ 表示父亲到自己的边权。

我们可以证明，若 $F_u(x)=dp[u][x]$，那么 $F_u$ 是一个分段一次函数，并且是一个单谷函数。

对于后面的 $\sum$ 可以看做是将若干分段函数加起来。将分段函数求导后会单调不增，加起来后一定仍然单调不增。

对于前面的加绝对值，可以把将边权变长和将边权变短分开讨论。

将边权变短类似于 $G[k]=\min_{i=k}^{k+w}(F[i]+(i-k))$。

将边权变长类似于 $G[k]=\min_{i=0}^{k}(F[i]+(k-i))$。

显然可以先变长再变短，这样是无所谓的。

可以发现边权变短相当于是在谷点的前面加了一段斜率为 $1$ 长度为 $w$ 的一次函数，变长相当于是把斜率对 $1$ 取 $\min$。

使用平衡树维护分段函数，只维护分段函数的斜率以及其在 $0$ 处的值（其实就是边权之和），复杂度 $O(n\log^2n)$。不知道 16 年的机子能不能跑。

但是当分段函数特殊时是可以使用堆维护分段点的，表示每经过一个分段点斜率就减小 $1$。

很显然一次操作结束后的分段函数最右边那个分段点代表的是右边斜率为 $1$。

于是可以使用可并堆维护分段点的最大值，每次弹出最大的两个然后将弹出值加上 $w$ 后再插回去即是将边权变短的操作。

然后再 pop 儿子数量-1 个分割点即可使最右侧的斜率为 $1$。

只需要写左偏树，且复杂度为 $O(n\log n)$。
```cpp
#include<cstdio>
#include<cctype>
namespace SOLVE{
	inline int read(){
		int n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
	}
	typedef long long ll;
	const int M=3e5+5;
	int n,ege,h[M];int tot,d[M<<1],ls[M<<1],rs[M<<1];ll w[M<<1];
	struct Edge{
		int v,nx;ll w;
	}e[M];
	inline void swap(int&a,int&b){
		int c=a;a=b;b=c;
	}
	inline void Add(const int&u,const int&v,const ll&w){
		e[++ege]=(Edge){v,h[u],w};h[u]=ege;
	}
	inline int merge(const int&q,const int&p){
		if(!q||!p)return q|p;if(w[q]<w[p])return merge(p,q);
		rs[q]=merge(rs[q],p);if(d[rs[q]]>d[ls[q]])swap(ls[q],rs[q]);d[q]=d[rs[q]]+1;return q;
	}
	inline int DFS(const int&u,const int&V){
		int rt(0),cnt(-1);for(int E=h[u];E;E=e[E].nx)rt=merge(rt,DFS(e[E].v,e[E].w)),++cnt;
		if(~cnt)while(cnt--)rt=merge(ls[rt],rs[rt]);if(u==1)return rt;
		const ll&X=w[rt]+V;rt=merge(ls[rt],rs[rt]);const ll&Y=w[rt]+V;rt=merge(ls[rt],rs[rt]);
		w[++tot]=X;d[tot]=1;rt=merge(rt,tot);w[++tot]=Y;d[tot]=1;rt=merge(rt,tot);return rt;
	}
	inline void main(){
		ll sum(0);n=read()+read();for(int f,w,i=2;i<=n;++i)f=read(),w=read(),Add(f,i,w),sum+=w;
		int rt=DFS(1,0);while(rt=merge(ls[rt],rs[rt]))sum-=w[rt];printf("%lld",sum);
	}
}
signed main(){
	SOLVE::main();
}
```

---

## 作者：lhm_ (赞：2)

设 $f_i(x)$ 为以节点 $i$ 为根的子树都以时刻 $x$ 爆炸的最小代价，发现其为一个下凸的分段函数，即为一个下凸包。

考虑一个节点加上其与父节点的边后函数的变化，设原函数的最小值为 $f_{\min}$，取到最小值的区间为 $[l,r]$，与父节点的边的边权为 $v$，得：
$$
{f}'(x) = 
\begin{cases}
f(x) + v & x \leqslant l \\
f_{\min} + l + v - x  & l < x \leqslant l + v \\
f_{\min} & l + v < x \leqslant r + v \\
f_{\min} + x - r - v & r + v < x
\end{cases}
$$
发现和原函数对比，加上这条边后，函数的变化为向上平移左边的一段，然后加入三段斜率分别为 $-1,0,1$ 的函数。对于一个节点，其所有儿子的新函数合并后的函数，即为该节点对应的函数。因为是合并起来的，所以该分段函数的每一段的斜率的差为 $1$，最小值右边的函数段数为其儿子个数。

对于函数，只需维护其端点位置即可，因为需要合并和删除，所以用可并堆来维护，我这里用的是左偏树。得 $f_{root}(0)$ 为所有边权和，结合端点位置，即可计算最小值。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 600010
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,tot;
ll ans;
int fa[maxn],rt[maxn],ls[maxn],rs[maxn],dis[maxn],son[maxn];
ll v[maxn],val[maxn];
int merge(int x,int y)
{
    if(!x||!y) return x+y;
    if(val[x]<val[y]) swap(x,y);
    rs[x]=merge(rs[x],y);
    if(dis[ls[x]]<dis[rs[x]]) swap(ls[x],rs[x]);
    dis[x]=dis[rs[x]]+1;
    return x;
}
int del(int x)
{
    return merge(ls[x],rs[x]);
}
int main()
{
    read(n),read(m);
    for(int i=2;i<=n+m;++i)
        read(fa[i]),read(v[i]),son[fa[i]]++,ans+=v[i];
    for(int i=n+m;i>1;--i)
    {
        ll l=0,r=0;
        if(son[i])
        {
            for(int j=1;j<son[i];++j) rt[i]=del(rt[i]);
            l=val[rt[i]],rt[i]=del(rt[i]);
            r=val[rt[i]],rt[i]=del(rt[i]);
        }
        val[++tot]=l+v[i],rt[i]=merge(rt[i],tot);
        val[++tot]=r+v[i],rt[i]=merge(rt[i],tot);
        rt[fa[i]]=merge(rt[fa[i]],rt[i]);
    }
    while(son[1]--) rt[1]=del(rt[1]);
    while(rt[1]) ans-=val[rt[1]],rt[1]=del(rt[1]);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Sakura_xyz (赞：1)

听学长讲的一道可并堆神题，被 [同机房的神](https://www.luogu.com.cn/user/429573) 秒了，写个题解加深一下理解。

### 题意
给定一棵树，每条边有边权，现在指定一种修改边权的操作，将边权 $x$ 修改至边权 $y$ 所需要的代价为 $|x - y|$ ，定义叶子结点的深度为其到根节点的路径长度总和，现求使得所有叶子结点的深度均相等的最小代价总和。

### 初步分析

首先，考虑这样一个 dp 转移，我们考虑设 $dp_{i,j}$ 为**在以 $i$ 为根的子树中**，所有的叶子结点深度均 **被统一成 $j$** 时，所需要的最小代价，我们定义节点 $u$ 到节点 $v$ 的边权为 $val(u,v)$ ，则有一个显然的转移如下：
$$dp_{i,j} = \sum_{v \in sons_i} \min_{k \leq j}( | val(i,v) - k | + dp_{v,j - k} )$$ 
枚举所改成的边权，依照状态的定义枚举即可。

现在，很明显这个算法是很劣的，状态数和边权值域有关，因此要继续优化。

### 进一步分析

我们将转移的过程分成两步来看：

1.将子树中的节点对于每个状态的转移取 $\min$ 。

2.将子树中处理好的最小值转移到父节点上。

我们设 $g_{i,j}$ 为以 $i$ 为根的子树中，只修改子树中的边与子树根节点及其父节点所连的边时，使得子树中所有叶子结点的距离到 $i$ 的父节点均为 $j$ 的最小代价，设 $i$ 的父节点为 $fa_i$ 即：

$$g_{i,j} = \min_{0\leq k\leq j }(|val(fa_i,i) - k| + dp_{i,j - k})$$
$$dp_{i,j} = \sum_{v \in sons_i} g_{v,j}$$

我们画出图像来观察转移的特点。

首先，对于叶子结点 $x$ :
![](https://cdn.luogu.com.cn/upload/image_hosting/5lnhsx79.png)

为方便表述，定义函数 $dp_i(x)$ 为 $dp_{i,x}$ 的取值，
$g_i(x)$ 为 $g_{i,x}$ 的取值。

很显然，我们只能修改一条边的权值，很显然， $g_x(j)$  关于 $j$ 的图像就是一个绝对值方程，其中两段的斜率分别为 $1$ 与 $-1$ ，在 $j$ 与 $x$ 和 $x$ 父节点连边的权值相等时取到最小值 $0$ 。

我们现在要证明一件事情：在每个点 $i$ , $dp_i(j)$ 与 $g_i(j)$ 关于 $j$ 的图像均为分段函数，且每段斜率单调递增。

根据归纳法，我们已经证明了对于叶子结点 $x$ , $g_{x,j}$ 满足条件。

易知转移时斜率均为整数。

现在，对于节点 $i$ ，若对于 $i$ 的所有子节点 $v$ ，其 $g_v(j)$ 的图像满足此规律，由于 $i$ 的 $dp_i(j)$ 在无论 $j$ 的取值时均为所有 $g_v(j)$ 之和，则 $i$ 的 $dp_i(j)$ 值必然也满足规律，这是显而易见的。

那么欲证明此命题，我们只需要证明对于所有的节点 $i$ ，若 $dp_i(j)$ 的值有关 $j$ 有上述规律，则 $g_i(j)$ 的值关于 $j$ 也满足上述规律即可。由于取 $\min$ 操作不存在优秀的性质，便可以考虑猜想什么样的操作是不优的。

我们欲得知 $g_i(j)$ 的最小值，只需保证选择转移位置后的图像尽量在下方即可。

首先，当 $dp_i(j)$ 在 $j$ 点斜率小于等于 $-1$ 时，不取 $g_i(j)$ 是一定不优的，因为假如选择的决策点更靠左，变化的速度一定比斜率为 $-1$ 的绝对值函数要快，因此取值就会更大，即此时 $dp_i(j)$ 的 图像就相当于 $g_i(j)$ 的图像向上平移了等于其与父节点边权的一段，满足条件。

其次，在 $dp_i(j)$ 的斜率大于等于 $1$ 时，一定有方法使 $g_i(j)$ 处斜率等于 $1$ ，由于我们可以直接选取 $dp_i(0)$ 与一个绝对值函数相加，此时斜率至多为 $1$ 。

接着，在 $dp_i(j)$ 的斜率为 $0$ 时， $g_i(j+val(i,fa_i))$ 不改变边权相加的两部分都是最优的，因此，这部分的图像可以由 $dp_i(j)$ 的图像向右平移得出。

最后，我们观察到，在 $dp_i(j)$ 转移到 $g_i(j)$ 的过程中，左侧斜率的函数图像向上平移了 $val(i,fa_i)$ ，右侧的函数图像向右平移了 $val(i,fa_i)$ ，再将斜率大于 $1$ 的部分推平为 $1$ ，那么，图像空出来的一段之间显然没有任何可以导致斜率变化的点，我们可以猜测此段斜率为 $-1$ ，事实上，我们可以找到最小的 $j_0$ 使得 $j_0$ 处 $dp_i(j)$ 的斜率为 $0$ ，同时，$j_0$ 也是所讨论情况的右端点。接着，固定选取 $dp_i(j_0)$ 可仅通过变换绝对值函数来达到取值，此时斜率为 $-1$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/hy3hu31g.png)

此时，结论得证，由此证明过程，我们还可以知道，**对于 $dp_i$ 与 $g_i$ 相邻的两段（段由可改变斜率的点构成，段的长度可以为 $0$ ）而言，其斜率之差为 $1$** 。利用归纳法，由于函数的斜率变化只与含有绝对值的一次函数的零点有关，而因零点左右的斜率相差为 $1$ ，故得证。

我们可以利用可并堆来维护函数每段之间的断点，形成斜率以 $1$ 为公差的区间，那么，在转移时，我们只需要做这些事情：

1.将节点 $i$ 对应的 $dp_i$ 图像通过子节点的 $g_v$ 图像合并。

2.设 $i$ 有 $x$ 个子节点，弹出可并堆中 $x - 1$ 个元素，由于共有 $x$ 个子节点，此时最右侧的斜率为 $x$ ，删去 $x - 1$ 个元素后，意味着最右侧的斜率变为 $1$ 。

3.将 $i$ 对应的可并堆中最大的两个元素加上其与父节点连边的权值，即相当于向右平移，同时补全了斜率为 $-1$ 的图像。

这样，我们便可以求得 $g_i$ 的图像。

合并至根节点 $1$ ，将右侧无用结点弹出，留下斜率小于 $0$ 的部分，现在，我们已知 $dp_{1,0}$ 的取值（边权和）以及每个点的 $x$ 坐标，需要知道 $y$ 坐标的取值，由于斜率按照 $1$ 的公差单减的性质，只需要将 $dp_{1,0}$ 减去每个点的 $x$ 坐标之和便是答案（考虑一段斜率为 $-k$ 的图像，意味着以 $k$ 倍的速率在减少，而实际上这段也被恰好计算了 $k$ 次）。

### AC 代码
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstdlib>
#define int long long
#define MAXN 600005

using namespace std;

vector <int> edge[MAXN];

int root[MAXN],val[MAXN],lc[MAXN],rc[MAXN];

int v[MAXN],fa[MAXN],cnt=0,n,deg[MAXN];

int New_Node(int v){
	val[++cnt]=v;
	return cnt;
}

int merge(int x,int y){
	if(!x||!y) return x|y;
	if(val[x]<val[y]) swap(x,y);
	if(rand()&1) lc[x]=merge(lc[x],y);
	else rc[x]=merge(rc[x],y);
	return x;
}

int top(int x){
	return val[root[x]];
}

void pop(int x){
	root[x]=merge(lc[root[x]],rc[root[x]]);
}

void dfs(int x){
	for(int i : edge[x]){
		dfs(i);
		for(int j=1;j<deg[i];j++) pop(i);
		int r=top(i); pop(i);
		int l=top(i); pop(i);
		root[i]=merge(root[i],New_Node(l+v[i]));
		root[i]=merge(root[i],New_Node(r+v[i]));
		root[x]=merge(root[x],root[i]);
	}
}

signed main(){
	srand(20070109);
	int a,b; scanf("%lld%lld",&a,&b);
	n=a+b;
	long long ans=0;
	for(int i=2;i<=n;i++){
		scanf("%lld%lld",fa+i,v+i);
		edge[fa[i]].push_back(i);
		ans+=v[i]; deg[fa[i]]++;
	}
	dfs(1);
	for(int i=1;i<=deg[1];i++) pop(1);
	while(root[1]) ans-=top(1),pop(1);
	printf("%lld\n",ans);
	return 0;
}
```

### 后记

现在我也想起了那天眺望到的海岸，

那在沙滩上刻下的话语以及你的背影，

拍来的海浪掠过脚边，带走了什么。

风平浪静中只有黄昏静静流过，

啪的一声，看到了烟花的光芒绽放。

那个夏天一定还没有结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/bgqa4z9a.png)

---

## 作者：lupengheyyds (赞：0)

# P3642 烟火表演

> slope trick

以这道题为例探讨一般情况下 slope trick 做题思路。

## 列出方程

> 找到一个朴素的 DP 方程，并使得这个转移是一个状态被包含进**绝对值**。

这个函数一定形如下图：

![pAV4owD.png](https://s21.ax1x.com/2024/09/03/pAV4owD.png)

本题中，令 $dp_{x,i}$  表示以 $x$ 为根的子树中，到所有叶子的时间为 $i$ 时的最小代价，可以得到朴素方程 $dp_{x,i}=\sum_{y\in \operatorname{son}(x)}\min_{j\le i}dp_{y,j}+|w-(i-j)|$，其中 $w$ 表示 $x\to y$ 的边权。

##### 拆绝对值

> 以函数斜率为零的最低段 $[L,R]$ 入手，把**绝对值**拆成分段函数的形式，并直接确定函数的取值位置。

考虑从一个节点到父亲节点的转移。

- 当 $i\le L$ 的时候，由于移动 $j\to j-1$ 会使 $dp_{y,j}$ 增加 $\ge 1$ （斜率 $\le-1$），而$|w-(i-j)|$ 无论如何增加的值 $\le 1$。所以 $j=i$ 取到最小值，$g(i)=f(i)+w$。

- 当 $L\le i$ 的时候，根据上文的分析，一定是 $j\in [L,R]$ 的时候取到最小值，于是考虑后面的权值如何取到最小。很明显我们想让 $w-(i-j)=0$ 即 $j=i-w$。
  
  - 当 $j=i-w\in [L,R]$ 即 $i\in [L+w,R+w]$ 的时候，有 $g(i)=f(L)$
  
  - 当 $j=i-w<L$ 即 $i\in [L,L+w)$ 的时候，$|w-(i-j)|=w-i+j$，我们想让值最小，就要让 $j$ 尽量小，所以 $j=L,g(i)=f(L)+w-i+L$。
  
  - 当 $j=i-w>R$ 即 $i\ge R+w$ 的时候， $|w-(i-j)|=i-w-j$，同理要让 $j$ 尽量大，所以 $j=R,g(i)=f(R)+i-w-R$。

综上所述：

$$
g(i)=\left\{\begin{aligned}
&f(i)+w&&i<L\\
&f(L)+w-i+L&&L\le i< L+w\\
&f(L)&&L+w\le i\le R+w\\
&f(L)+i-w-R&&i>R+w
\end{aligned}\right.
$$

## 合并函数

> 函数直接相加，可以直接将端点合并，不去重，注意维护新的 $L,R$。

直接暴力的用 `multiset` 都可以，但一般情况下只需要用可并堆，因为我们并不想要随机访问，一般是从左到右或从右到左顺序遍历。

## 维护端点

> 根据得到的分段函数，维护斜率变化位置的横坐标，相邻段变化为 $1$。

首先要得到 $L,R$ 的具体值，对于一般情况，可以手动维护，并将 $L$ 左侧，与 $R$ 右侧分开来，比如 [NarrowRectangles](https://www.luogu.com.cn/problem/AT_arc070_c) 这道题。

但这里不用，观察性质，每一个处理的函数 $R$ 右侧是无限远的斜率为 $1$ 段。假设一个点有 $k$ 个儿子，那么 $R$ 右边总共有 $k$ 个段，存储了 $k-1$ 个端点。直接弹出即可（反正我们不需要，都要覆盖为斜率为 $1$）。

## 计算答案

> 从 $f(0)$ 算起，往右边走。

假设第 $i$ 个端点为 $a_i$，$a_x=L,a_1=0$，则 $ans=f(0)-\sum_{i=2}^x(a_i-a_{i-1})\times(x-i+1)=f(0)-\sum_{i=1}^xa_i$。

对于本题，$f(0)=\sum w$。

---

## 作者：phil071128 (赞：0)

> 给定一棵树，边有边权，你可以花费 $|x-w|$ 的代价将一条原本权值为 $w$ 的边修改为 $x$ ，找出一种花费最小的方案，使得每个叶子到根的距离相等。

不难想到树形 dp ，$dp[u][s]$ 表示以 $u$ 为根的子树的叶子到 $u$ 的距离都是 $s$ 的花费，

$$
dp[u][s]=\sum \min_i\{ dp[v][s-i]+|{w-i}|\} 
$$

对于叶子节点来说，就只剩下绝对值一项了。显然，只带绝对值的函数（ 关于 $s$ ）是一个下凸函数。

下凸函数的`(min,+)` 卷积仍然是下凸的，所以 $dp_u$ 就是一个下凸函数。

这样写还是不大美观，我们可以先看 $dp'[v][s]=\min dp[v][s-i]+|w-i|$ ，合并后面再说。

因为 $i$ 是我们自己控制的，我们需要分类讨论，深入研究怎样才能使新的 dp 值尽可能小。

不妨设 $(u,v)$ 边权为 $w$ ， $dp_v$ 函数图像的最小值区间（即斜率为 $0$ ）为 $[L,R]$ ，显然，$L$ 有可能等于 $R$ ，这里一会再说，不需要特殊处理。

- 如果 $s\le L$ ，那么 $dp'[v][s]=dp[v][s]+w$ 是最优（不劣）的。因为考虑图像上 $s\le L$ 的部分斜率都 $\le -1$ ，而改变一次 $w$ 的收益最多只是 $1$ ，所以不妨 $w$ 根本就不变了。形式化的： $ dp[v][s-i]-dp[v][s]\ge |w-i|-w$  。
- 如果 $s\in(L,L+w)$ ，上一条告诉我们 $dp[v][s-i]$ 的影响更大，所以我们需要优先保证其能取到最小值，再使得 $|w-i|$ 尽可能小，即 $s-i=L$ 时，$dp'[v][s]=dp[v][L]+w+L-s$  。（ $i=s-L,w-i=w+L-s>0$ ）
- 如果 $s\in[L+w,R+w]$ ，一定可以取得最小值，即 $i=w$ 时，$dp'[v][s]=dp[v][L]$ 。
- 如果 $s>R+w$ ，那么类比第一条，需要让 $s-i=R$ ，即 $dp'[v][s]=dp[v][R]+s-w-R$ （ $i=s-R,w-i=w+R-s<0$ ）

放在图像上来看，相当于将 $\le L$ 的部分向上平移 $w$ ，先将 $[L,R]$ 向右平移 $w$ ，再将 $(L,L+w)$ 改为一条斜率为 $-1$ 的线段。$>R+w$ 的部分改为一条斜率为 $+1$ 的直线。可用初中数学知识验证。这样的分析过程被称作 `slope trick` 。

那么，我们肯定用一个数据结构维护每个拐点的横坐标。能够支持删除最大的若干个正斜率拐点，删除两个斜率为 $0$ 的拐点，插入一个斜率为 $-1$ 的拐点，插入两个斜率为 $0$ 的拐点。插入一个斜率为 $+1$ 的拐点。（注意顺序）容易发现，设当前节点儿子个数为 $deg[v]$ ，则删除的正斜率拐点个数为 $deg[v]-1$ ，因为每个儿子都只有一个正斜率拐点。

别忘了 $dp[u][s]=\sum dp'[v][s]$ ，就是若干个数据结构合并的过程。综上，选择可并堆（大根堆）是最好的。

最后怎么输出答案？我们需要得到根节点斜率为 $0$ 区间的纵坐标。注意到 $dp[rt][0]$ 就是所有边的和。如果相邻两个斜率的差都是 $1$ ，那么答案就是 $dp[rt][0]-1-2-3...-L$ ， 但是相邻两个斜率的差不确定。注意到如果我们合并的时候不对相同的斜率去重，重复几次就相当于当前斜率减左边一个斜率的差是多少，就能保证可并堆相邻两个元素之间斜率的差为 $1$ 。对于 $L=R$ 的情况也是这样，如果 $L=R$ 则说明左边斜率是 $-2$ 。

[代码](https://www.luogu.com.cn/record/147326878)

---

## 作者：takanashi_mifuru (赞：0)


容易发现如果整棵树都能同一时间爆，那么所有子树也都能。

考虑设计 $f_u(x)$ 表示以第 $u$ 个点为根的子树统一在第 $x$ 个时候爆。

然后容易发现他是一个下凸的，为什么呢？

我们考虑这棵树是一条长链，长度为 $L$，那么 $f_u(x)=|x-L|$，我们知道绝对值是下凸的。

那么很明显一个点是从若干个长链拼起来的，凸函数和凸函数相加，结果还是凸函数。

尝试用绝对值来分析这个题，我们考虑绝对值一个比较重要的内容是啥，零点分段对吧，也就是说他首先会为函数贡献 $-1$ 的值，过了零点之后转为贡献 $1$，所以我们考虑维护零点，也是下凸函数的分段点。

我们再来考虑一下如何向上转移，考虑维护一个 $f'_u(x)$ 表示从 $fa_u$ 开始搜 $u$ 的子树，$x$ 时刻时叶子统一爆了的最小代价。

因为是下凸函数所以一定会有最低点，可能还是个区间，假设这个区间最左端是 $L$，最右端是 $R$。

注意，这里的 $L$ 和 $R$ 是在 $f_u(x)$ 上的。

我们考虑怎么转移出 $f'_u(x)$。

我们对 $x$ 进行分类讨论。

首先设 $l$ 为 $fa_x$ 向 $x$ 连的边的边权。

1. 如果 $x\leqslant L$，那么 $f'_u(x)=f_u(x)+l$。
2. 如果 $L<x\leqslant L+l$，那么 $f'_u(x)=f_u(L)+(l-(x-L))$。
3. 如果 $L+l<x\leqslant R+l$，那么 $f'_u(x)=f_u(L)$。
4. 如果 $x>R+l$，那么 $f'_u(x)=f_u(L)+((x-R)-l)$。

一个一个分析，首先第一个，为什么这么做呢，因为我们知道得很清楚，$L$ 到 $R$ 之间的线段斜率为 $0$，那么左边的自然就是斜率为负数的了，而且因为是绝对值所以斜率最大也是 $-1$，这个时候如果不缩减 $l$，并尝试从前面转移是严格不优的，所以还不如直接把 $l$ 削成 $0$。

第二个。他原来处于那个平面中，但是因为加了一条边被踢出去了，那我们肯定希望在新图上通过删边权的方式回去啊，所以我们选择把 $l$ 卸掉 $l-(x-L)$ 的边权并转移，这明显是最优的，因为如果再往前走出于斜率是不会更优的。

第三个。最低点的区间转移了一下，正好处在那个最低点的区间内，最简单的一集，不需要变动就是最优。

第四个，容易发现这是本来选的太多了，加了一条边或多或少减了一些负担，但还是很多，我们把这些边权都加上然后凑到中间去就行了，具体证明过程仿第一个。

然后就转移完了。

然后我们考虑维护这个。

其实也不难维护，我们直接维护端点的横坐标，因为我也是从下面合过来的，假设我有 $k$ 个儿子那么我就会合出 $k-1$ 个 $+1$ 的端点，我们把这些全部扔掉.

然后剩下的两个点就是 $L$ 和 $R$，考虑把他们抽出来，然后横坐标加一个 $l$ 再扔回去，中间别忘了插入一条斜率为 $-1$ 的线段。

然后你说答案怎么求，答案不难求，我们求出 $f(0)$ 然后按端点递推就好了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
class LeftTree{ 
	public:
	int father[2000005];
	int lson[2000005];
	int rson[2000005];
	int dist[2000005];
	int val[2000005]; 
	int tot=n+m;
	int GetRt(int x){
		if(father[x]==x)return x;
		return father[x]=GetRt(father[x]);
	}
	int merge(int x,int y){
		if(!x||!y)return x+y;
		if(val[y]>val[x])swap(x,y);
		rson[x]=merge(rson[x],y);
		if(dist[lson[x]]<dist[rson[x]])swap(lson[x],rson[x]);
		dist[x]=dist[rson[x]]+1;
		return x;	
	}
	void del(int x){
		x=GetRt(x);
		father[lson[x]]=father[rson[x]]=father[x]=merge(lson[x],rson[x]);
		lson[x]=rson[x]=dist[x]=0;
		val[x]=0;
		return;
	}
	void unionn(int x,int y){
		x=GetRt(x),y=GetRt(y);
		if(x==y)return;
		father[x]=father[y]=merge(x,y);
		return;
	}
	void insert(int x,int y){
		x=GetRt(x);
		tot++;
		val[tot]=y;
		father[tot]=tot;
		father[x]=father[tot]=merge(x,tot);
		return;
	}
}P;
void print(int cur){
	vector<int> fvv;
	while(P.val[P.GetRt(cur)]>=0){
		fvv.push_back(P.val[P.GetRt(cur)]);
		P.del(cur);
	}
	for(int i=0;i<fvv.size();i++){
		P.insert(cur,fvv[i]);
	}
	return;
}
struct node{
	int v,w;
};
vector<node> ljb[300005];
vector<int> ans;
void dfs(int cur,int w){
	for(int i=0;i<ljb[cur].size();i++){
		int v=ljb[cur][i].v;
		int w=ljb[cur][i].w;
		dfs(v,w);
		int R=P.val[P.GetRt(v)];
		P.del(v);
		int L=P.val[P.GetRt(v)];
		P.del(v);
		P.insert(v,L+w);
		P.insert(v,R+w);
		P.unionn(cur,v);
	}
	if(ljb[cur].size()==0){
		P.insert(cur,0); 
		P.insert(cur,0); 
		P.insert(cur,0); 
		return;
	}
	for(int i=1;i<ljb[cur].size();i++){
		P.del(cur);
	}
	return; 
}
int f0;
signed main(){
	scanf("%lld%lld",&n,&m);
	P.father[1]=1;
	P.tot=n+m;
	for(int i=2;i<=n+m;i++){
		int fa,val;
		scanf("%lld%lld",&fa,&val);
		ljb[fa].push_back(node{i,val});
		P.father[i]=i;
		P.val[i]=-1;
		f0+=val;
	}
	dfs(1,0); 
	int now=1;
	while(P.val[P.GetRt(1)]>=0){
		ans.push_back(P.val[P.GetRt(1)]);
		P.del(1);
		now--;
	}
	int F=0;
	for(int i=ans.size()-1;i>=0;i--){
		f0+=now*(ans[i]-F);
		F=ans[i];
		now++;
	}
	printf("%lld",f0);
	return 0;
}
```

---


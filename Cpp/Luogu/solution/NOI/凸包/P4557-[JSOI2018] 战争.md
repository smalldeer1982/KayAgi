# [JSOI2018] 战争

## 题目描述

九条可怜是一个热爱读书的女孩子。

在她最近正在读的一本小说中，描述了两个敌对部落之间的故事。第一个部落有 $n$ 个人，第二个部落有 $m$ 个人，每一个人的位置可以抽象成二维平面上坐标为 $(x_i,y_i)$ 的点。

在这本书中，人们有很强的领地意识，对于平面上的任何一个点，如果它被三个来自同一部落的人形成的三角形（可能退化成一条线段）包含（包括边界），那么这一个点就属于这一个部落的领地。如果存在一个点同时在两个阵营的领地中，那么这两个部落就会为了争夺这一个点而发生战争。

常年的征战让两个部落不堪重负，因此第二个部落的族长作出了一个英明的决定，他打算选择一个向量 $(dx,dy)$ ，让所有的族人都迁徙这个向量的距离，即所有第二阵营的人的坐标都变成 $(x_i+dx,y_i+dy)$ 。

现在他计划了 $q$ 个迁徙的备选方案，他想要你来帮忙对每一个迁徙方案，计算一下在完成了迁徙之后，两个部落之间还会不会因为争夺领地而发生战争。


## 说明/提示

**样例 1 解释**

下图为第一组方案中两个部落的私人领地，点 $(0,0)$ 同时属于两个部落，因此会发生战争。

![0](https://i.loli.net/2018/05/05/5aed12638bab1.png)

下图为第二组方案中两个部落的私人领地，没有点同时属于两个部落，因此不会发生战争。

![1](https://i.loli.net/2018/05/05/5aed1293ce6ca.png)

下图为第三组方案中两个部落的私人领地，点 $(0,0)$ 同时属于两个部落，因此会发生战争。

![2](https://i.loli.net/2018/05/05/5aed12a4e3545.png)

**数据范围**

对于 $20\%$ 的数据， $n,m\le 5,q\le 500$。

对于 $40\%$ 的数据， $n,m\le 50,q\le 500$ 。

对于 $70\%$ 的数据， $n,m\le 10^4,q\le 500$ 。

对于 $100\%$ 的数据， $n,m\le 10^5,q\le 10^5$ 。

对于 $100\%$ 的数据，保证 $-10^8\le x_i,y_i,dx_i,dy_i\le 10^8;n,m\ge 3$ 。所有人的坐标两两不同且对于每一个阵营,所有人都不全共线。

**2024/08/20 增加 6 组 hack 数据，并公开在本题附件。**

## 样例 #1

### 输入

```
4 4 3
0 0
1 0
0 1
1 1
-1 0
0 3
0 2
0 -1
0 0
2 3
0 -1```

### 输出

```
1
0
1```

# 题解

## 作者：xzyxzy (赞：47)

# **[My Blog](https://www.cnblogs.com/xzyxzy/p/10229921.html)**
# **闵可夫斯基和**

# 一、概述
学习此内容需一定计算几何基础，出门右拐：https://www.cnblogs.com/xzyxzy/p/10033130.html

　
 
**官方定义**：两个图形$A,B$的闵可夫斯基和$C=\{a+b|a\in A,b\in B\}$

**通俗一点**：从原点向图形A内部的每一个点做向量，将图形$B$沿每个向量移动，所有的最终位置的并便是闵可夫斯基和

　
 
由于博主太菜，本文只讨论凸包的闵可夫斯基和

如下图，粉色区域便是三角形和一个不规则四边形的闵可夫斯基和
![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C1.png)

# 二、怎么求
利用瞪眼法得，闵可夫斯基和的边是由两凸包构成的

也就是说把两凸包的边极角排序后直接顺次连起来就是闵可夫斯基和

　
 
由于凸包的优美性质，直接归并排序就好了

但是需要注意的是可能会有三点共线的情况，于是再扔过去重新求一次凸包就好了

# 三、应用举例
### 题目

[[JSOI2018]战争](https://www.luogu.org/problemnew/show/P4557)

两个凸包$A,B$，移动$B$，问是否还有交点。$n\le10^5,q\le10^5$
### 正解
令$a\in A,b\in B$则移动向量$w$使得存在$b+w=a$

那么$w$需要满足$w=a-b$

构造闵可夫斯基和$C=\{a+(-b)\}$

在输入$B$的时候横纵坐标都取反即可

余下问题便是判断输入的移动向量是否在$C$内，[计算几何](https://www.cnblogs.com/xzyxzy/p/10033130.html)有讲
### 样例靓照
原图

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_step1.png)

取反

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_step2.png)

闵可夫斯基和

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_step3.png)

用题目意思去理解闵可夫斯基和:

橙色的向量是$B$可以移动的范围的边界，也就是说在绿色框之内的向量都满足条件

这些向量拖到以原点为起点，就是上面的闵可夫斯基和的粉色区域

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_step4.png)

### 代码
我觉得这题值这个黑色标签

不是很好转换，有点策不清
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
const ll N=1e5+10;
struct Node
{
	ll x,y;
	Node operator - (Node A) {return (Node){x-A.x,y-A.y};}
	Node operator + (Node A) {return (Node){x+A.x,y+A.y};}
	ll operator * (Node A) const {return x*A.y-y*A.x;}
	ll len() const {return x*x+y*y;}
}A[N],C1[N],C2[N],s1[N],s2[N],bs;
ll cmp1(const Node&A,const Node&B) {return A.y<B.y||(A.y==B.y&&A.x<B.x);}
ll cmp2(const Node&A,const Node&B) {return A*B>0||(A*B==0&&A.len()<B.len());}
ll n,m,sta[N],top,q,tot;
void Convex(Node *A,ll &n)
{
	sort(A+1,A+n+1,cmp1);
	bs=A[1];sta[top=1]=1;
	for(ll i=1;i<=n;i++) A[i]=A[i]-bs;
	sort(A+2,A+n+1,cmp2);
	for(ll i=2;i<=n;sta[++top]=i,i++)
		while(top>=2&&(A[i]-A[sta[top-1]])*(A[sta[top]]-A[sta[top-1]])>=0) top--;
	for(ll i=1;i<=top;i++) A[i]=A[sta[i]]+bs;
	n=top;A[n+1]=A[1];
}
void Minkowski()
{
	for(ll i=1;i<n;i++) s1[i]=C1[i+1]-C1[i];s1[n]=C1[1]-C1[n];
	for(ll i=1;i<m;i++) s2[i]=C2[i+1]-C2[i];s2[m]=C2[1]-C2[m];
	A[tot=1]=C1[1]+C2[1];
	ll p1=1,p2=1;
	while(p1<=n&&p2<=m) ++tot,A[tot]=A[tot-1]+(s1[p1]*s2[p2]>=0?s1[p1++]:s2[p2++]);
	while(p1<=n) ++tot,A[tot]=A[tot-1]+s1[p1++];
	while(p2<=m) ++tot,A[tot]=A[tot-1]+s2[p2++];
}
ll in(Node a)
{
	if(a*A[1]>0||A[tot]*a>0) return 0;
	ll ps=lower_bound(A+1,A+tot+1,a,cmp2)-A-1;
	return (a-A[ps])*(A[ps%tot+1]-A[ps])<=0;
}
int main()
{
	cin>>n>>m>>q;
	for(ll i=1;i<=n;i++)
		scanf("%lld%lld",&C1[i].x,&C1[i].y);
	Convex(C1,n);
	for(ll i=1;i<=m;i++)
	{
		scanf("%lld%lld",&C2[i].x,&C2[i].y);
		C2[i].x=-C2[i].x;C2[i].y=-C2[i].y;
	}
	Convex(C2,m);
	Minkowski();
	Convex(A,tot);
	bs=A[1];for(ll i=tot;i>=1;i--) A[i]=A[i]-A[1];
	while(q--)
	{
		scanf("%lld%lld",&A[0].x,&A[0].y);
		printf("%lld\n",in(A[0]-bs));
	}
	return 0;
}
```

---

## 作者：WinXP (赞：34)

~~写题解写到一半不小心弄没了体验极差~~

所以首先我们可以发现这是一道~~可怜~~计算几何题

首先有个重点，题目说的是存在平面上的任何一个点被两个部落包含是不合法情况，而不是$(n+m)$个点中的任何一个被两个部落包含。

考虑一个部落包含的平面上的所有的点，它们其实是一个凸包的形状，这是很显然而且很容易想到的。我们考虑求出这个点集的凸包，把这个凸包三角剖分后，这若干个三角形显然能覆盖整个凸包；而对于一个不在凸包上的点，它与任意其他两个点(不管在不在凸包上)所形成的三角形显然会被这个凸包覆盖。

那么现在问题变成了这样的形式，也就是给出一个向量 $\vec{x}$ ,询问大小为 $m$ 的点集构成的凸包 $B$ 平移向量 $\vec{x}$ 后，与大小为 $n$ 的点集构成的凸包 $A$ 是否有交。

也就是

$$\exists\ b + \vec{x}=a(a\in A,b\in B)$$

看一眼数据范围，本来我以为是$O(qn)$之类的东西，结果不是......果然做题的时候不能被数据结构误导...

我们考虑转化这个等式

$$\vec{x}\in\{a-b|(a\in A,b\in B)\}$$

因为$a-b=a+(-b)$，所以把 $B$ 的所有点都取反，求的集合就变成了$\{a+b|(a\in A,b\in B)\}$。如何求这个东西呢？

先试想点集 $B$ 是一个点的情况，那么结果显然是 $A$ 的平移：

![](https://cdn.luogu.com.cn/upload/pic/22391.png)

那么再考虑 $B$ 是一条线段的情况，也不难想象应该是这样的：

![](https://cdn.luogu.com.cn/upload/pic/22392.png)

如果 $B$ 也是一个凸包，相信聪明的你可以知道，结果应该是这样的:

![](https://cdn.luogu.com.cn/upload/pic/22393.png)

这个东西其实可以看做是 $A$ 对于 $B$ 内的每一个点平移的并集。我们可以清楚的看到这个并集的形状是一个凸包，而且这个凸包内的所有的边都属于原来的 $A$ 和 $B$ 。注意这一点，这个性质很重要。当我们求出凸包 $A$ 和凸包 $B$ 后，按照凸包上的点滚一遍就能拥有凸包 $A$ 和凸包 $B$ 的所有边关于这个凸包最左面的点的角度的排序，接下来仿照归并排序的方式，把这些边按照角度顺序加入，就可以得到答案集合的所有点。这些点虽然是按顺序加入的，但是最后不一定是一个凸包，所以再求一遍就好了。现在要做的全部事情已经很显然了。

如果把 $A+B$ 定义为 $\{a+b|(a\in A,b\in B)\}$，这个东西实际上叫做`Minkowski sum`。~~我并不知道这是个什么东西也不会~~ 代码是~~抄~~仿照了[别的大佬的](https://blog.csdn.net/cdsszjj/article/details/80392221)(不过是我自己写的QAQ)

代码里的注释还是蛮详细的

~~压行阅读无能？Astyle了解一下~~
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define rap(i,s,n) for(int i=s;i<=n;i++)
#define drap(i,n,s) for(int i=n;i>=s;i--)
#define N 111111
#define ll long long
#define lf double
#define m(s,k) memset(s,k,sizeof s)
using namespace std;
char xB[1<<15],*xS=xB,*xTT=xB;
#define getc() (xS==xTT&&(xTT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xTT)?0:*xS++)
#define isd(c) ((c>='0'&&c<='9')||(c=='-'))
template<typename T>
inline bool rd(T& xa){
    char xchh; T f=1; while(xchh=getc(),(!isd(xchh))&&(xchh!=0));
    if(xchh==0) return 0; if(xchh=='-') xchh=getc(),f=-1; xa=xchh-'0';
    while(xchh=getc(),isd(xchh)) xa=xa*10+xchh-'0'; xa*=f; return 1;
}//读入优化不用管
struct point{
    ll x,y; point(){} point(ll _,ll __):x(_),y(__){}
    point operator + (const point& b) const {return point(x+b.x,y+b.y);}
    point operator - (const point& b) const {return point(x-b.x,y-b.y);}//顾名思义的加减
    ll    operator * (const point& b) const {return x*b.y-y*b.x;}
    //这个X乘，a x b如果小于0说明b在a的右面，否则b在a的左面。如果x为0说明a与b平行。
}t[N*2],p[N*2],p1[N],p2[N],v1[N],v2[N];
//大家都知道点和向量其实是一样的 所以这个point又是point又是vector 其中t,p,p1,p2是点，v1v2是向量
ll len(point a){return a.x*a.x+a.y*a.y;}
point tss;//随便写的...
bool cmp(const point& a,const point& b){
    ll k=(a-tss)*(b-tss); if(k) return k>0;
    else return len(a-tss)<len(b-tss);
}//因为差积可以判断左右
int graham(point *a,int n){
    rap(i,1,n) t[i]=a[i]; rap(i,2,n) if(t[i].x<t[1].x||(t[i].x==t[1].x&&t[i].y<t[1].y)) swap(t[1],t[i]);
    tss=t[1]; sort(t+2,t+n+1,cmp); int top=1; rap(i,2,n){
        while(top>1&&(t[top]-t[top-1])*(t[i]-t[top-1])<=0) top--;
        t[++top]=t[i]; //保证从开始的点出来是一个不断左转的过程
    }
    rap(i,1,top) a[i]=t[i]; return top;
    //求凸包
}
int n,m,q,cnt;
bool init(point x){
	//init=in it?判断是否在里面 并不是初始化(233)
    point vx=x-p[1]; if(vx*(p[cnt]-p[1])<0||vx*(p[2]-p[1])>0) return 0;
    long int px=lower_bound(p+2,p+cnt+1,x,cmp)-p-1;
    //按照排序规则直接二分搞出它的下面的点
    //开始的时候忘了后面的-1WA了N发(MDZZ)
    return (x-p[px])*(p[px%cnt+1]-p[px])<=0;
}
int main(){
    rd(n); rd(m); rd(q);
    rap(i,1,n) rd(p1[i].x),rd(p1[i].y); n=Graham(p1,n);
    rap(i,1,m) rd(p2[i].x),rd(p2[i].y),p2[i].x=-p2[i].x,p2[i].y=-p2[i].y; m=Graham(p2,m);
    //注意取反
    rap(i,1,n-1) v1[i]=p1[i+1]-p1[i]; v1[n]=p1[1]-p1[n];
    rap(i,1,m-1) v2[i]=p2[i+1]-p2[i]; v2[m]=p2[1]-p2[m];
    //搞出所有的线段
    p[1]=p1[1]+p2[1]; cnt=1;
    int l1=1,l2=1; while(l1<=n&&l2<=m) ++cnt,p[cnt]=p[cnt-1]+((v1[l1]*v2[l2]>=0)?(v1[l1++]):(v2[l2++]));
    while(l1<=n) ++cnt,p[cnt]=p[cnt-1]+v1[l1++];
    while(l2<=m) ++cnt,p[cnt]=p[cnt-1]+v2[l2++];
    //参照归并排序
    while(cnt>1&&(p[cnt]-p[cnt-1])*(p[1]-p[cnt-1])<=0) cnt--;
    //因为后面有一些无用点 直接做凸包也可以不过这样常数小
    tss=p[1]; point qx; rap(i,1,q) rd(qx.x),rd(qx.y),printf("%d\n",init(qx));
    return 0;
}

```



---

## 作者：_LHF_ (赞：25)

这是一道计算几何题。

对于像本蒟蒻这种计算几何没做过几道题的来说实在是太要命了（虽然只花了几个小时）

前置知识：凸包，向量
### 吐槽环节（可以跳过）
我觉得第一篇题解某个地方有点点小问题：

```if(a*A[1]>0||A[tot]*a>0) return 0;```

这里 $A_1$ 已经是 $(0,0)$ 了，所以叉积一定为 $0$ 。

这不是关键，关键在于评论中说到：关于点是否在凸包内这东西弄错了！

比如像这种情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/nvuj0nv5.png)

叉积为 0，但是点确实不在凸包内。

好了好了。
# 进入正题
啥是闵可夫斯基和呢？

给定两个点集 $A,B$

则它们的闵可夫斯基和为 $C=A+B=\{a+b|a\in A,b\in B\}$

这里定义两个点的加法为他们的横坐标、纵坐标分别相加。

那么闵可夫斯基和集合的点的数量级是 $O(n^2)$ 的。

读者：您在逗我吗？您想让我 $n^2$ 过十万吗？

那当然不，我们要的是闵可夫斯基和做完之后得到的点集的凸包，毕竟这玩意儿才有用。

给些图（假设三角形最上面的那个点的坐标是 $(0,0)$）

![](https://cdn.luogu.com.cn/upload/image_hosting/r3tnf69b.png)

得到的就是

![](https://cdn.luogu.com.cn/upload/image_hosting/9a9wzra4.png)

观察一下构成凸包的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/snn2imdb.png)

我们发现，绿边经过平移可以构成原来的四边形，橙边经过平移可以构成原来的三角形。

再观察一下，可以发现闵可夫斯基和的凸包的边数是两个凸包的边数和，可以用归并排序之类的算法求出。

这一题中，考虑求出边界设移动向量 $w$ 之后存在 $b+w=a$，其中 $a\in A,b\in B$

移项变成 $w=a-b$

于是我们就要构造一个闵可夫斯基和凸包。

等等， $-b$ 怎么弄啊。

读入时把坐标取个反就可以了。

然后别的就没了。

代码：
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#define N 300010 
using namespace std;
struct point{
	double x,y;
	void read(){scanf("%lf%lf",&x,&y);}
	void write(){printf("%lf,%lf ",x,y);}
}a[N],b[N],s1[N],s2[N],s[N],k,O,q;
struct my_stack{
	int t[N],len;
	void push(int x){t[len++]=x;}
	int operator [](int w){return t[len-w];}
	void pop(){len--;}
	void clear(){t[len=0]=0;}
}t;
point operator +(point a,point b)
{return (point){a.x+b.x,a.y+b.y};}
point operator -(point a,point b)
{return (point){a.x-b.x,a.y-b.y};}
double operator *(point a,point b)
{return a.x*b.y-a.y*b.x;}
bool operator ==(point a,point b)
{return a.x==b.x&&a.y==b.y;}
point operator ~(point a){return (point){-a.x,-a.y};}
double sqr(double a){return a*a;}
double calc(point a,point b)
{return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
bool cmp(point a,point b)
{
	double x=(a-k)*(b-k);
	if(x==0) return calc(a,k)<calc(b,k);
	else return x>0;
}
bool cmp2(point a,point b)
{
	double x=a*b;
	if(x==0) return calc(a,O)<calc(b,O);
	else return x>0;
}
double ans;
void convex(point*p,int&n)
{
	int w=1;
	for(int i=1;i<=n;i++)
		if(p[i].y<p[w].y||(p[i].y==p[w].y&&p[i].x<p[w].x)) w=i;
	swap(p[1],p[w]);k=p[1];
	sort(p+2,p+n+1,cmp);
	t.clear();
	t.push(1),t.push(2);
	for(int i=3;i<=n;i++)
	{
		while(t.len>1&&(p[i]-p[t[2]])*(p[t[1]]-p[t[2]])>=0) t.pop();
		t.push(i);
	}
	n=t.len;
	for(int i=1;i<=n;i++) p[i]=p[t.t[i-1]];
}
int n,m,cnt,T;
void minkowski()
{
	int i,j;
	for(i=1;i<n;i++) s1[i]=a[i+1]-a[i];
	for(i=1;i<m;i++) s2[i]=b[i+1]-b[i];
	s2[m]=b[1]-b[m];s1[n]=a[1]-a[n];
	i=1,j=1;
	s[cnt=1]=a[1]+b[1];
	while(i<=n&&j<=m)
	{
		if(s1[i]*s2[j]>0) s[cnt+1]=s[cnt]+s1[i++];
		else s[cnt+1]=s[cnt]+s2[j++];
		cnt++;
	}
	while(i<=n) s[cnt+1]=s[cnt]+s1[i++],cnt++;
	while(j<=m) s[cnt+1]=s[cnt]+s2[j++],cnt++;
}
bool query(point x)
{
	if(x*s[2]>0||s[cnt]*x>0||(x*s[2]==0&&calc(x,O)>calc(s[2],O))
		||(x*s[cnt]==0&&calc(x,O)>calc(s[cnt],O))) return 1;
	int w=lower_bound(s+2,s+cnt+1,x,cmp2)-s-1;
	return (x-s[w])*(s[w+1]-s[w])>0;
}
int main()
{
	scanf("%d%d%d",&n,&m,&T);
	for(int i=1;i<=n;i++) a[i].read();
	for(int i=1;i<=m;i++) b[i].read(),b[i]=O-b[i];
	convex(a,n),convex(b,m);
	minkowski(),convex(s,cnt);
	k=s[1]; for(int i=1;i<=cnt;i++) s[i]=s[i]-k;
	while(T--)
	{
		q.read();
		printf("%d\n",!query(q-k));
	}
}
```


---

## 作者：bloodstalk (赞：16)

# 闵可夫斯基和
## 前言
入门建议看吉老师（吉如一）的[计算几何入门到放弃](https://www.bilibili.com/video/BV1Bt411j7bs/?spm_id_from=333.337.search-card.all.click&vd_source=f401181639eeb8ba7c03d5b63e1f7b5f)。感觉应该是讲的最通俗易懂的了。

本文借鉴了 [Winxp](https://www.luogu.com.cn/blog/winxp/solution-p4557) 的博客，以及吉老师视频中的思路。

写这篇博客的初衷是因为我作为一个初学者，此题里的题解对我来说理解起来不算太难，但是实现起来细节比较多，题解里也没有很详细地去解释（可能是因为我太菜了）。所以写这篇博客详细地解释一下这道题目里的一些操作。
## 定义
两个图形（也就是点集） $A,B$ 的闵可夫斯基和定义为 $C = \{a+b\mid a\in A,b\in B\}$。

画一画图可以看出，闵可夫斯基和形成的图形就是一个图形 $A$ 绕着图形 $B$ 转一圈。

给个典图。

![](https://cdn.luogu.com.cn/upload/image_hosting/jf0nrvcs.png)

由于我比较菜，所以我们只考虑凸包的闵可夫斯基和的一些性质。

## 性质
### 一、
两个凸包的闵可夫斯基和还是凸包。

证明：

考虑凸集的一个性质：若 $a,b\in A$，则 $c = xa+(1-x)b ,c\in A(0\leq x \leq 1)$。

设 $a_1,a_2\in A,b_1,b_2 \in B$ ，根据闵可夫斯基和的定义，$a_1+b_1,a_2+b_2\in C$

任取一个 
$$
x\in[0,1],x(a_1+b_1)+(1-x)(a_2+b_2)
$$
$$
= [xa_1+(1-x)a_2] + [xb_1(1-x)b_2]
$$
$$
[xa_1+(1-x)a_2]\in A, [xb_1(1-x)b_2]\in B
$$
证毕。
### 二、
闵可夫斯基和上的边是由两个凸包的边构成的

这个不好证，但是我们用瞪眼法看一看，应该是对的。

有了这两个性质，我们就能求闵可夫斯基和了。

## 求法
思路比较简单，但是细节比较多。

因为我们得到 $A,B$ 两个凸包后，它们的极角序其实是已经排好了的，所以我们就可以采用类似于归并排序的策略，将两个凸包结合起来。

得到闵可夫斯基和后，因为有可能会出现三点共线的情况，所以要再求一次凸包。

```cpp
il void Minkovski()
{
	for(re int i=1;i<n;i++) a[i] = s[i+1] - s[i]; a[n] = s[1] - s[n];//s是A凸包
	for(re int i=1;i<m;i++) b[i] = h[i+1] - h[i]; b[m] = h[1] - h[m];//h是B凸包
	int p1 = 1 , p2 = 1;
	tot = 1 , G[tot] = s[1] + h[1];//归并加入一下，G数组就是闵可夫斯基和
	while(p1 <= n && p2 <= m) tot++ , G[tot] = G[tot-1] + (a[p1]*b[p2]>=0 ? a[p1++]:b[p2++]);//极角序从小到大并从G[tot-1]开始往后接
	while(p1 <= n) tot++ , G[tot] = G[tot-1] + a[p1++];
	while(p2 <= m) tot++ , G[tot] = G[tot-1] + b[p2++];
}
```
我们用类似 `a[i] = s[i+1]-s[i]` 的操作得出每条边。再以 `s[1]+h[1]` 为起点开始往后加，每次加的时候就以 `G[tot-1]` 为基础往后接上。
## 应用
[P4557 [JSOI2018]战争](https://www.luogu.com.cn/problem/P4557)

一句话题意。
> 给定两个凸包 $A,B$，$q$ 次询问，每次给出一个向量 $\overrightarrow{x}$，问 $B$ 平移向量 $\overrightarrow{x}$ 后，$A$ 和 $B$ 是否还有交集。$n,m,q \leq 10^5$。

原题上领地是看三角形内部的区域，实际上就是凸包。而问是否有交集，数学化后就有了下面的式子：

如果有交，那么
$$
\exists b + \overrightarrow{x} = a(a\in A,b\in B)
$$
转化一下，则有
$$
\overrightarrow{x} \in \{a-b\mid a\in A,b\in B\}
$$
我们看到这个很像 $A,B$ 的闵可夫斯基和的形式，但是它们是相减，怎么办？把 $B$ 取反，就变成闵可夫斯基和的形式了。 

按照上述过程求出闵可夫斯基和后，接下来就剩下最后一个问题，如果判断一个点是否在凸包内，这个也比较好算，以图为例：
![](https://cdn.luogu.com.cn/upload/image_hosting/8vso6rrx.png)

我们选定凸包上最左下角的点为起点，并将这个凸包平移一下，使得左下角的点坐落在原点上。这样就容易得出其他点的极角序了，我们按极角序进行二分，找到当前这个点与起点的连线位于哪两条线（凸包上的点与起点的连线）之间。然后如图连两条线，运用叉积运算判断这个点是在凸包外还是在凸包内即可。

另外还有一些小细节，我会在代码中写清。
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 1e5 + 5;
const double eps = 1e-6;
const double Pi = acos(-1.0);
using namespace std;

struct Point{
	double x,y;
}a[N],b[N],s[N],h[N],A[N],G[N],d,st;
int n,m,q,tot;

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

Point operator +(Point a,Point b) { return Point{a.x+b.x,a.y+b.y}; }//加

Point operator -(Point a,Point b) { return Point{a.x-b.x,a.y-b.y}; }//减

il double operator *(Point a,Point b) { return a.x*b.y - a.y*b.x; }//叉积

il double operator &(Point a,Point b) { return a.x*b.x + a.y*b.y; }//点积

il double cross(Point a,Point b,Point c) { return (b-a)*(c-a); }//判断c和直线ab的关系 

il double len(Point a) { return sqrt(a&a); }

il bool cmp(Point a,Point b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }//以x为第一关键字，y为第二关键字排序

il bool cmp2(Point a,Point b) { return a*b > 0 || (a*b == 0 && len(a) < len(b)); }//按极角序排序，如果极角相同短的放前边

il void ConvexHull(Point *s,Point *p,int &n)//s是凸包数组，p是原数组
{
	int cnt = 0;
	sort(p+1,p+n+1,cmp);
	s[++cnt] = p[1];
	for(re int i=2;i<=n;i++) //Andrew求凸包
	{
		while(cnt > 1 && cross(s[cnt-1],s[cnt],p[i]) <= 0) cnt--;
		s[++cnt] = p[i];
	}
	int t = cnt;
	for(re int i=n-1;i>=1;i--)
	{
		while(cnt > t && cross(s[cnt-1],s[cnt],p[i]) <= 0) cnt--;
		s[++cnt] = p[i];
	}
	n = cnt - 1;//第一个点加了两次，别忘了-1
}

il void Minkovski()
{
	memset(a , 0 , sizeof a);
	memset(b , 0 , sizeof b);//重复利用一下a,b数组，其实可以不memset
	for(re int i=1;i<n;i++) a[i] = s[i+1] - s[i]; a[n] = s[1] - s[n];//最后一条线单独写一下
	for(re int i=1;i<m;i++) b[i] = h[i+1] - h[i]; b[m] = h[1] - h[m];
	int p1 = 1 , p2 = 1;
	tot = 1 , G[tot] = s[1] + h[1];//以s[1]+t[1]为起点开始加
	while(p1 <= n && p2 <= m) tot++ , G[tot] = G[tot-1] + (a[p1]*b[p2]>=0 ? a[p1++]:b[p2++]);
	while(p1 <= n) tot++ , G[tot] = G[tot-1] + a[p1++];
	while(p2 <= m) tot++ , G[tot] = G[tot-1] + b[p2++];
}

il bool Judge(Point a)
{
	if(a*A[1] > 0 || A[tot]*a > 0) return 0;//绝对不可能在凸包内的情况
	int pos = lower_bound(A+1,A+tot+1,a,cmp2) - A - 1;//lower_bound求的是第一个极角序不小于它的，所以减个1
	return (a-A[pos])*(A[pos%tot+1]-A[pos])<=0;//如上文所说
}

signed main()
{
	n = read() , m = read() , q = read();
	for(re int i=1;i<=n;i++) scanf("%lf%lf",&a[i].x,&a[i].y);
	for(re int i=1;i<=m;i++) scanf("%lf%lf",&b[i].x,&b[i].y) , b[i].x = -b[i].x , b[i].y = -b[i].y;
	ConvexHull(s,a,n);
	ConvexHull(h,b,m);
	Minkovski();
	ConvexHull(A,G,tot);
	st = A[1];//选定一个基准点，并且把这个基准点平移到(0,0)的位置上，这样有利于我们求极角序
	for(re int i=1;i<=tot;i++) A[i] = A[i] - st;//别的也减一下
	while(q--)
	{
		scanf("%lf%lf",&d.x,&d.y);
		printf("%d\n",Judge(d-st));//这个也别忘了减
	}
	return 0;
}
```
由此可以看出，整个复杂度是 $O((n+m+q)\log(n+m))$ 的，$n,m,q$ 同阶，复杂度也就是 $O(n\log n)$，可以通过。

---

## 作者：啊嘞嘞嘞嘞 (赞：9)

大概是JSOI2018不算难的一题吧（这是我A的第3道JSOI2018的题）。因为我是看了另一个题解的思路才会做的，所以不知道想到正解有多难。但可以肯定的是，实现起来难度不大，但有一些细节需要注意。

这题大概是紫题难度，别被黑标签吓到。（尽管我愉快地贡献了近10次提交）

预备知识：向量，凸包，数学技巧 ~~（没错就这么简单）~~

题意：给定凸包$α$和$β$，大小分别为$n$,$m$，$q$次询问将$β$平移$\vec{d}$后是否与$α$有交。$n$,$m$,$q$均为$10^5$级别。

先求2个点集的凸包肯定没问题吧。听说`Andrew`比`Graham`常数小，还有一个复杂度最优的`Melkman`，用起来有点麻烦。

由于询问较多，每次进行凸包判交复杂度很大（而且我不会判交），所以考虑先处理出可行域（即会导致两个凸包相交的向量$\vec{OP}$的点$P$形成的区域）。

我能想到的类似的问题就是线性规划，求$(x,y)$是否满足约束条件。做法可以是先处理出可行域（凸包），看点是否在凸包上而不用逐个判断是否符合约束条件。

我们以这两个凸包为例（造数据建议保证2个凸包边尽量不平行，棱角分明，这样容易看出来点性质）

![](https://cdn.luogu.com.cn/upload/pic/37486.png)

不可行域长啥样？先画图看看呗（如果手头没有好的绘图工具，ppt也可，效果比windows painter好）。我们只需要找出临界位置（这点类似线性规划），图中用灰色表示（应该有$(n+m)$个）。显然，将灰色凸包沿着$α$的边平移即可得到更完整的可行区域。

![](https://cdn.luogu.com.cn/upload/pic/37489.png)

在$β$上取一点$A$，设它在平移得到的凸包上的对应点为$A_i$（这些点都在可行域上，且是可行域的顶点），可以得到一个由这些点构成的凸包。关于这是凸包，应该可以用半平面交证明（我没证过）。

![](https://cdn.luogu.com.cn/upload/pic/37500.png)

将凸包转化成$\vec{OP}$的点$P$形成的区域，只需将凸包平移$\vec{AO}$。

![](https://cdn.luogu.com.cn/upload/pic/37501.png)

接下来我们来分析这个凸包$γ$的特点。因为有点$A_i$沿$α$的边平移形成边，所以$γ$的边包含$α$的边（当然位置不一样）。灰色三角形在$α$的某些顶点处，需要平移自身的一条边的长度才能绕过去，所以$γ$的边也包含$β$的边。因此，**$γ$由$α$和$β$的边组成，各顶点的坐标，则由来自$α$和$β$的对应点的坐标相加而成**。~~如果眼力够好，这些是可以瞪出来的。~~

接下来考虑如何合并两个凸包。

根据凸包的性质，按逆时针顺序各边向量的方向角是单调的，所以只需要将组成$α$和$β$的边按方向角排序就可以了。但一定要这么做吗？考虑到**求完凸包后$α$和$β$的边的方向角都是单调的**，可以直接用类似**归并**的方法。（不懂方向角？见任意角的定义）

可以将$β$取反，这样加边就是顺着的，也许更方便？

初始置入两个凸包的首个点。假设接下来待加的两个凸包的点分别为$A_i$和$B_j$（$0 \le i \lt n$, $0 \le j \lt m$，初始$i$,$j$都为1，这里$n$,$m$是实际点数+1），比较$\vec{A_i}-\vec{A_{i-1}}$和$\vec{B_j}-\vec{B_{j-1}}$，如果前者方向角小，则向$γ$加入点$C_{i+j-1}=A_i+B_{j-1}$，反之加入点$C_{i+j-1}=A_{i-1}+B_j$。（这里是对$β$取反后的）比较可以用叉积来做。注意如果一个凸包已经加完，就不用判大小关系了。设合并得到的凸包大小为$N (N=n+m-1)$，依旧将第一个点计2次。

到这里实际上已经70分了。对每次询问直接$O(N)$判点是否在凸包内（含边界）。

接下来要面对的是如何用$logN$的复杂度完成查询操作。

![](https://cdn.luogu.com.cn/upload/pic/37508.png)

如上图，绿线为查询的向量$P(dx,dy)$的纵坐标所在直线，它与凸包边有最多2个交点。显然只有图中特意标出来的2条蓝边决定点$P$是否在凸包内。由于顶点的纵坐标单调，可以`lower_bound`二分出线段的2个端点（将凸包包划分为左凸壳和右凸壳，在两个下标区间内分别二分，注意由于单调性不同所以cmp不同）。然后上叉积即可。 _我相信我的做法是最烂的_ 

Q1：如果绿线（不与任何一条边共线）恰好过一个顶点，那么该是哪两个点？

A1：都一样，$P$与某一端点重合，叉积为$0$，判点在凸包内。

Q2：如果绿线与某条边平行，该如何处理？

A2：显然这条边是凸包最上面或最下面的边。直接`lower_bound`，我是能处理和下边共线的情况的，只需要特判上边。很简单，记录凸包顶部的坐标范围，对于$y$与上边共线的情况，只判$x$是否在区间里就行了。如果不放心，也可以特判下边。我不特判只有80pts。

这样100pts就拿到了。

总之这题关键是思想，细节部分真的不难，自己推一遍会发现很简单。

还有注意开`ll`，坐标没有小数据，没`ll`就爆0。（我一开始注意到了结果还是忘开于是愉快爆了）。不涉及小数，所以不需要考虑精度误差。注意凸包大小不要搞混。

我代码应该还行吧。

```cpp
#include <cstdio>
#include <algorithm>
#include <functional>
#define reg register
using namespace std;
typedef long long ll;
const int MAXN=100010;
int n0,m0,n,m,N,Q; //原始点集大小，2个凸包大小，可行域凸包大小
struct point {
	int x,y;
	point() {}
	point(double X,double Y):x(X),y(Y) {}
} a0[MAXN],b0[MAXN],a[MAXN],b[MAXN],c[MAXN*2]; //原点集数组，2个凸包，可行域凸包
int high,high0; //最高点的下标
inline point operator +(const point &p1,const point &p2)  {
	return point(p1.x+p2.x,p1.y+p2.y);
}
inline point operator -(const point &p1,const point &p2)  {
	return point(p1.x-p2.x,p1.y-p2.y);
}
inline ll operator *(const point &p1,const point &p2) { //向量叉积，注意ll
	return (ll)p1.x*p2.y-(ll)p1.y*p2.x;
}
inline bool operator <(const point &p1,const point &p2)  {
	return p1.y<p2.y || p1.y==p2.y && p1.x<p2.x;
}
inline bool operator >(const point &p1,const point &p2) {
	return p1.y>p2.y;
}
int Andrew(int n,point a[],point sta[]) { //求凸包，返回凸包大小+1
	sort(a,a+n);
	int top=0;
	for (reg int i=0;i<n;i++) {
		while (top>1 && (sta[top-1]-sta[top-2])*(a[i]-sta[top-2])<=0) top--;
		sta[top++]=a[i];
	}
	int k=top;
	for (reg int i=n-2;i>=0;i--) {
		while (top>k && (sta[top-1]-sta[top-2])*(a[i]-sta[top-2])<=0) top--;
		sta[top++]=a[i];
	}
	return top;
}
void merge() { //合并凸包，求出不合法向量范围
	N=m+n-1;
	int i=1,j=1; //当前待选的点
	c[0]=a[0]+b[0];
	high=high0=0; //最高点的区间上界和下界
	//类似归并，按方向角顺序加入新凸包，方向角用
	for (reg int k=1;k<N;k++) {
		c[k]= i<n && (j==m || (a[i]-a[i-1])*(b[j]-b[j-1])>0) ? a[i++]+b[j-1] : a[i-1]+b[j++];
		if (c[k].y>c[high].y) high=k;
		if (c[k].y>=c[high].y) high=k;
	}
}
bool query(const point &p) { //判断点p是否在凸包内（含边界）
	if (p.y<c[0].y || p.y>c[high].y || p.y==c[high].y && (p.x<c[high].x || p.x>c[high0].x)) return false;
	//上面先特判一定在凸包外，和在顶部线段外的情况（因为下面的无法处理这种情况）
	point *p1=lower_bound(c,c+high,p),*p2=lower_bound(c+high,c+N,p,greater<point>()); //按y找所在位置
	return (p-*(p1-1))*(*p1-p)<=0 && (p-*(p2-1))*(*p2-p)<=0;
}
int main() {
	scanf("%d%d%d",&n0,&m0,&Q);
	for (reg int i=0;i<n0;i++) scanf("%d%d",&a0[i].x,&a0[i].y);
	for (reg int i=0;i<m0;i++) scanf("%d%d",&b0[i].x,&b0[i].y), b0[i].x*=-1, b0[i].y*=-1;
	n=Andrew(n0,a0,a);
	m=Andrew(m0,b0,b);
	merge();
	while (Q--) {
		int x,y;
		scanf("%d%d",&x,&y);
		printf("%d\n",query(point(x,y))); //查询，在凸包内即冲突
	}
	return 0;
}
```


---

## 作者：EnofTaiPeople (赞：6)

今天来聊聊[[JSOI2018]战争](/problem/P4557)。

这道题半年前就想做，一周前写完过样例，提交全 WA，就咕了一周，后来发现连凸包都求错了。

对于这道题，我们先将 $A,B$ 两个部落的区域表示出来，容易发现这就是它们围起来的最小凸多边形，可以求一个二维凸包来表示它们。
```cpp
inline int gb(V *P,V *G,int n){
	int i,t=0,h=0;sort(P+1,P+n+1);
	static V H[N];
	for(i=1;i<=n;++i){
		while(t>1&&(P[i]-G[t-1])*(G[t]-G[t-1])>=0)--t;
		G[++t]=P[i];
	}for(i=n;i;--i){
		while(h>1&&(P[i]-H[h-1])*(H[h]-H[h-1])>=0)--h;
		H[++h]=P[i];
	}for(i=1;i<=h;++i)G[++t]=H[i];
	return t=unique(G+1,G+t+1)-G-1;
}
```

容易发现对于一个迁移方案，视作一个向量 $p$，它不满足条件当且仅当 $\exists a\in A,b\in B,p=a-b$，$A,B$ 可以直接理解为凸包内的点集。

我们可以求出一个 $C=\{a-b|a\in A,b\in B\}$，这就是 $A$ 和 $-B$ 的闵可夫斯基和。

将 $B$ 取反，这是我们要求 $C=A+B$，对凸包求和结果的规律可以手玩发现，就是将向量极角归并，依次加入，比较极角可以用叉积：$f(x)\le f(y)\Leftrightarrow x\times y\le0$。
```cpp
n=gb(v1,g1,n),m=gb(v2,g2,m);
for(t1=t2=1;t1<n&&t2<m;){
	v1[++k]=g1[t1]+g2[t2];
	++((g1[t1+1]-g1[t1])*(g2[t2+1]-g2[t2])>0?t1:t2);
}
if(t1==n)while(t2<=m)v1[++k]=g1[t1]+g2[t2++];
else while(t1<=n)v1[++k]=g1[t1++]+g2[t2];
```

然后这就是一个可做题了，每次询问判断是否在凸包内即可，还是用叉积，边界判一下，时间 $O((n+m+q)\log_2(n+m))$，空间 $O(n+m)$。

后附 AC 代码，加 `fread` 恰好 100 行，2.84KB：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
namespace fast_io{
	char ib[N+5],ob[N+85],stk[85];
	int it,ed,c,ot,t;
#define _gc (it==ed&&(ed=(it=0)+fread(ib,1,N,stdin),it==ed))?EOF:ib[it++]
	template<typename _Tp>
	inline void read(_Tp &x){
		int f=0;for(c=_gc;c<48;c=_gc)if(c=='-')f=!f;
		for(x=0;c>47;c=_gc)x=x*10+(48^c);if(f)x=-x;
	}
	template<typename _Tp,typename..._tps>
	inline void read(_Tp &x,_tps&...y){
		read(x),read(y...);
	}
	inline void flush(){
		fwrite(ob,1,ot,stdout),ot=0;
	}
	inline void write(char c){
		ob[ot++]=c,ob[ot++]='\n';
		if(ot>N)flush();
	}
};using fast_io::read;
using fast_io::write;
using ll=long long;
struct V{
	ll x,y;
	inline bool operator<(const V &z)
	const{return x==z.x?y<z.y:x<z.x;}
	inline bool operator==(const V &z)
	const{return x==z.x&&y==z.y;}
	inline V operator-(const V &z)
	const{return V(x-z.x,y-z.y);}
	inline V operator+(const V &z)
	const{return V(x+z.x,y+z.y);}
	inline ll operator*(const V &z)
	const{return x*z.y-y*z.x;}
	V(){}
	template<typename _Tp1,typename _Tp2>
	V(_Tp1 a,_Tp2 b){x=a,y=b;}
}at;
V v1[N],v2[N],g1[N],g2[N];
inline int gb(V *P,V *G,int n){
	int i,t=0,h=0;sort(P+1,P+n+1);
	static V H[N];
	for(i=1;i<=n;++i){
		while(t>1&&(P[i]-G[t-1])*(G[t]-G[t-1])>=0)--t;
		G[++t]=P[i];
	}for(i=n;i;--i){
		while(h>1&&(P[i]-H[h-1])*(H[h]-H[h-1])>=0)--h;
		H[++h]=P[i];
	}for(i=1;i<=h;++i)G[++t]=H[i];
	return t=unique(G+1,G+t+1)-G-1;
}
inline void gb(V *P,V *U,V *D,int &u,int &d,int n){
	int i;sort(P+1,P+n+1),u=d=0;
	for(i=1;i<=n;++i){
		while(u>1&&(P[i]-U[u-1])*(U[u]-U[u-1])<=0)--u;U[++u]=P[i];
		while(d>1&&(P[i]-D[d-1])*(D[d]-D[d-1])>=0)--d;D[++d]=P[i];
	}u=unique(U+1,U+u+1)-U-1;
	d=unique(D+1,D+d+1)-D-1;
}
int n,m,q,k,U1,D1,U2,D2;
#define WC {write('0');continue;}
int main(){
	int i,x,y,t1,t2;read(n,m,q);
	for(i=1;i<=n;++i)
		read(x,y),v1[i]={x,y};
	for(i=1;i<=m;++i)
		read(x,y),v2[i]={-x,-y};
	n=gb(v1,g1,n),m=gb(v2,g2,m);
	for(t1=t2=1;t1<n&&t2<m;){
		v1[++k]=g1[t1]+g2[t2];
		++((g1[t1+1]-g1[t1])*(g2[t2+1]-g2[t2])>0?t1:t2);
	}if(t1==n)while(t2<=m)v1[++k]=g1[t1]+g2[t2++];
	else while(t1<=n)v1[++k]=g1[t1++]+g2[t2];
	gb(v1,g1,g2,t1,t2,k);
	U1=U2=-2e9,D1=D2=2e9;
	for(i=1;i<=t1;++i){
		if(g1[i].x==g1[1].x&&U1<g1[i].y)U1=g1[i].y;
		if(g1[i].x==g1[t1].x&&U2<g1[i].y)U2=g1[i].y;
	}for(i=1;i<=t2;++i){
		if(g2[i].x==g1[1].x&&D1>g2[i].y)D1=g2[i].y;
		if(g2[i].x==g1[t1].x&&D2>g2[i].y)D2=g2[i].y;
	}while(q--){
		read(x,y);
		if(x<g1[1].x||x>g1[t1].x){
			write('0');continue;
		}if(x==g1[1].x){
			write(y>=D1&&y<=U1?'1':'0');continue;
		}if(x==g1[t1].x){
			write(y>=D2&&y<=U2?'1':'0');continue;
		}k=upper_bound(g1+1,g1+t1+1,V(x,-1e18))-g1-1;
		if((V(x,y)-g1[k])*(g1[k+1]-g1[k])<0)WC
		k=upper_bound(g2+1,g2+t2+1,V(x,-1e18))-g2-1;
		if((V(x,y)-g2[k])*(g2[k+1]-g2[k])>0)WC
		write('1');
	}fast_io::flush();return 0;
}
```

---

## 作者：xtx1092515503 (赞：6)

整整debug五天。心态崩溃。

这里是一种**不需要用甚么闵可夫斯基**，纯粹暴力的算法（虽然复杂度高了点，是 $O(n\log^2n)$ 的——但反正能过就对了）

------

首先，无脑对两个点集跑一遍凸包没啥好说的罢。

然后，我们考虑分别找到两个凸包上的最高点与最低点（假如有多个，就随便取一个）。则对于一次询问，如果此时发现一个凸包上最高点的 $y$ 坐标还低于另一个凸包上最低点的 $y$ 坐标，则显然两个凸包不可能有交。

否则，我们考虑两个凸包中，最低点更高的那个凸包（假如两个凸包的最低点一样高，则随便取一个），并将其称作”**第一个凸包**“，而将另一个凸包称作”**第二个凸包**“。考虑经过该更高的最低点的水平直线，则该水平直线一定与第二个凸包有交（因为我们一开始已经判断了两个凸包在 $y$ 坐标方面上覆盖的线段是有交的）。

考虑判断该更高的最低点与第二个凸包的关系。假如该更高最低点自身就在第二个凸包内部，则显然二者必定有交。否则，即该更高最低点在第二个凸包的左侧或者右侧。不妨设其在第二个凸包的左侧。

则我们此时，只需要判断第一个凸包的右边界和第二个凸包的左边界是否有交即可。

画出图就可以猜出来，这两个边界间的距离，随着 $y$ 坐标的升高，必定是一个先减后增的单峰函数。而我们要判断的，就是其谷底处是否有距离小于等于 $0$（即有交）。

单峰函数的极值可以三分。本题因为保证所有坐标均是整数，所以可以直接在整数域上三分，当区间小到一定地步（例如长度小于 $3$）的时候，就直接暴力扫过区间中所有东西验证其是否小于等于 $0$ 即可。

但是，三分的话就无法避免一个问题——假如三分的两个端点处的距离相等怎么办？应该如何判断舍掉哪一半区间？

我们会发现，三分将大区间 $[l,r]$ 分成了三半—— $[l,lmid],[lmid,rmid],[rmid,r]$。但是，如果峰值出现在两边的两个区间中的话，因为其是单峰的，故这就意味着区间 $[lmid,rmid]$ 中两个边界间距离处处相等，而因为两条边界都是**凸**的，所以唯一可能就是两条区间在此处平行。但是出现平行的话，就意味着此处已经是极值了。所以如果发现两边相等，要么 $[lmid,rmid]$ 中所有东西都是极值，要么极值在 $[lmid,rmid]$ 中——所以此时无脑丢掉两边区间即可。

然后就是细节、细节、该死的细节了。

我们将会发现，凸包中可能会有一段线段，其与 $x$ 轴平行——这意味着此段线段中 $y$ 坐标全都相同。但是，还是因为凸包是凸的，所以平行线段只有可能在最高点/最低点附近出现。所以我们在关于最高点/最低点将整个凸包切成两条边界时，应该将最高点附近的平行线段同时分到两条边界中。同时，这也意味着我们需要实现两个不同的函数，一个用来查询一条边界上关于某一个特定的 $y$ 值最大的 $x$ 值，而另一个则是查询最小的 $x$ 值（这时为了三分时判断关于某个 $y$ 处两条边界间的距离）。那如何查询呢？我们发现边界上 $y$ 值不降，故直接二分即可。

所以总体实现是三分套二分，复杂度因此 $O(n\log^2n)$。LOJ可直接AC，Luogu需吸氧。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=200100;
const double pi=acos(-1);
const double eps=1e-6;
int cmp(double ip){if(ip>eps)return 1;if(ip<-eps)return -1;return 0;}
struct Vector{
	int x,y;
	Vector(){}
	Vector(int X,int Y){x=X,y=Y;}
	void read(){scanf("%d%d",&x,&y);}
	void print()const{printf("(%d,%d)",x,y);}
	friend Vector operator+(const Vector &u,const Vector &v){return Vector(u.x+v.x,u.y+v.y);}
	friend Vector operator-(const Vector &u,const Vector &v){return Vector(u.x-v.x,u.y-v.y);}
	friend ll operator&(const Vector &u,const Vector &v){return 1ll*u.x*v.y-1ll*u.y*v.x;}
	Vector operator-()const{return Vector(-x,-y);}
	double operator!()const{return atan2(y,x);}
	double operator~()const{return sqrt(1ll*x*x+1ll*y*y);}
};
typedef Vector Point;
namespace Hull{
	Point t[N];
	int stk[N],tp;
	bool cmp1(const Point &u,const Point &v){return u.y!=v.y?u.y<v.y:u.x<v.x;}
	bool cmp2(const Point &u,const Point &v){return (u&v)==0?cmp(~u-~v)==-1:(u&v)>0;}
	void ConvexHull(Point *p,int &n){//find the convex hull of a pointset
		sort(p,p+n,cmp1);
		for(int i=0;i<n;i++)t[i]=p[i]-p[0];
		sort(t,t+n,cmp2);
		tp=0,stk[tp++]=0;
		for(int i=1;i<n;i++){
			while(tp>=2&&((t[stk[tp-1]]-t[stk[tp-2]])&(t[stk[tp-1]]-t[i]))>=0)tp--;
			stk[tp++]=i;
		}
		for(int i=0;i<n;i++)t[i]=t[i]+p[0];
		n=tp;
		for(int i=0;i<n;i++)p[i]=t[stk[i]];
	}
	void SplitHull(Point *p,Point *r,Point *l,int n,int &R,int &L,Point &a,Point &b){//split a convex hull into two halves
		L=R=0;
		for(int i=0;i<n;i++)if(cmp1(p[L],p[i]))L=i;
		for(int i=0;i<=L;i++)l[i]=p[i];
		r[R++]=p[0];
		for(int i=1;i<L;i++)if(p[i].y==p[0].y)r[R++]=p[i];else break;
		reverse(r,r+R);
		for(int i=n-1;i>=L;i--)r[R++]=p[i];
		a=p[0],b=p[L];
		L++;
		while(L<n&&p[L].y==p[L-1].y)l[L]=p[L],L++;
	}
}
double findx(Point *p,int n,Vector v,int y,bool tp){//find the x of a particular y on a hull; tp(0/1) controls usage of minimal/maximal x.
	int l=0,r=n;
	while(r-l>1){
		int mid=(l+r)>>1;
		if((p[mid]+v).y<=y)l=mid;
		else r=mid;
	}
	if((p[l]+v).y!=y){
		if(l>=n-1)return (p[n-1]+v).x;
		return (p[l]+v).x+1.0*(p[l+1].x-p[l].x)*(y-(p[l]+v).y)/(p[l+1].y-p[l].y);
	}
	if(!l||p[l-1].y!=p[l].y)return (p[l]+v).x;
	return tp?max((p[l]+v).x,(p[l-1]+v).x):min((p[l]+v).x,(p[l-1]+v).x);
}
double findd(Point *p,int n,Point *q,int m,Vector v,int y){
	double P=findx(p,n,Vector(0,0),y,1),Q=findx(q,m,v,y,0);
	return Q-P;
}
bool CALC(Point *p,int n,Point *q,int m,Vector v){//of hull p and (q+v).
	int l=max(p[0].y,(q[0]+v).y),r=min(p[n-1].y,(q[m-1]+v).y);
	while(r-l>2){
		int lmid=(l+l+r)/3,rmid=(l+r+r)/3;
		double L=findd(p,n,q,m,v,lmid),R=findd(p,n,q,m,v,rmid);
//		printf("%d %d:%d %d:%lf %lf\n",l,r,lmid,rmid,L,R);
		int tmp=cmp(L-R);
		if(tmp==0)l=lmid,r=rmid;
		if(tmp==-1)r=rmid-1;
		if(tmp==1)l=lmid+1;
	}
	for(int i=l;i<=r;i++)if(cmp(findd(p,n,q,m,v,i))!=1)return false;
	return true;
}
int n,m,qq,PL,QL,PR,QR;
Point p[N],q[N];
Point pl[N],pr[N],ql[N],qr[N],pa,pb,qa,qb;
bool calc(Vector v){
	if(pa.y>(qb+v).y||pb.y<(qa+v).y)return true;//of course no intersection
	if(pa.y>=(qa+v).y){
		double qlx=findx(ql,QL,v,pa.y,0);
		double qrx=findx(qr,QR,v,pa.y,1);
//		printf("%lf %lf\n",qlx,qrx);
		if(cmp(qlx-pa.x)==1)return CALC(pr,PR,ql,QL,v);
		if(cmp(qrx-pa.x)==-1)return CALC(qr,QR,pl,PL,-v);
		return false;//pa itself is inside q.
	}else{
		double plx=findx(pl,PL,-v,qa.y,0);
		double prx=findx(pr,PR,-v,qa.y,1);
//		printf("%d %d\n",cmp(plx-qa.x),cmp(prx-qa.x));
		if(cmp(plx-qa.x)==1)return CALC(qr,QR,pl,PL,-v);
		if(cmp(prx-qa.x)==-1)return CALC(pr,PR,ql,QL,v);
		return false;//qa itself is inside p.
	}
}
int main(){
//	freopen("I.in","r",stdin);
	scanf("%d%d%d",&n,&m,&qq);
	for(int i=0;i<n;i++)p[i].read();Hull::ConvexHull(p,n),Hull::SplitHull(p,pl,pr,n,PL,PR,pa,pb);
	for(int i=0;i<m;i++)q[i].read();Hull::ConvexHull(q,m),Hull::SplitHull(q,ql,qr,m,QL,QR,qa,qb);
//	for(int i=0;i<n;i++)p[i].print();puts("");
//	for(int i=0;i<m;i++)q[i].print();puts("");
//	printf("%d:",PL);for(int i=0;i<PL;i++)pl[i].print();puts("");printf("%d:",PR);for(int i=0;i<PR;i++)pr[i].print();puts("");puts("");
//	printf("%d:",QL);for(int i=0;i<QL;i++)ql[i].print();puts("");printf("%d:",QR);for(int i=0;i<QR;i++)qr[i].print();puts("");puts("");
	for(int i=0,x,y;i<qq;i++)scanf("%d%d",&x,&y),printf("%d\n",!calc(Vector(x,y)));
	return 0;
}
```



---

## 作者：justalearner (赞：4)

这篇文章是我发的第一篇题解，这道题也是我 A 的第一道黑题。

遥想当年，适逢初二，蒟蒻一枚，试为此题，昼不能食，夜不能寐，调试三日方 A。一载春秋若白驹过隙矣，其间 Hack 良多，苦时间不足，实力欠缺，无力纠正。今幸得余闲，特来 Debug，视码风丑陋，Bug 繁多，题解一塌糊涂，乃重构之。此中 Tab 与 space 混用，诚非我意也，望恕之。

———————————重构记

## [战争](https://www.luogu.com.cn/problem/P4557)

抽象版题面：会冲突当且仅当 $\exist\boldsymbol v_1\in C_1,\boldsymbol v_2\in C_2$ 满足 $\boldsymbol v_2+\boldsymbol d=\boldsymbol v_1$。

移项得 $\boldsymbol d=\boldsymbol v_1-\boldsymbol v_2$，因此检索 $\boldsymbol v_1-\boldsymbol v_2$ 的所有可能性，看其包不包含向量 $\boldsymbol d$ 即可。

即，令 $C_3=\{\boldsymbol v_1-\boldsymbol v_2|\boldsymbol v_1\in C_1,\boldsymbol v_2\in C_2\}$，答案即为 $[\boldsymbol d\in C_3]$，这是一个闵可夫斯基和的形式。

## Definition

二维点集 $A,B$ 的闵可夫斯基和定义为 $C=\{\boldsymbol a+\boldsymbol b|\boldsymbol a\in A,\boldsymbol b\in B\}$。

有点像直积。

### Lemma 1

两个凸包的闵可夫斯基和仍是凸包。

让我们回顾一下凸包的定义：任意两个点的连线都在该多边形内的多边形，亦即：$C$ 是凸包当且仅当 $\forall \boldsymbol a,\boldsymbol b\in C,x\in[0,1],s.t.\boldsymbol ax+\boldsymbol b(1-x)\in C$。

考虑证明如下：对任意 $C$ 中两点 $\boldsymbol a_1+\boldsymbol b_1$ 和 $\boldsymbol a_2+\boldsymbol b_2$，其中 $\boldsymbol a_1,\boldsymbol a_2\in A,\boldsymbol b_1,\boldsymbol b_2\in B$ ，证明其连线 $(\boldsymbol a_1+\boldsymbol b_1)x+(\boldsymbol a_2+\boldsymbol b_2)(1-x)$ 在 $C$ 中。

则 $(\boldsymbol a_1+\boldsymbol b_1)x+(\boldsymbol a_2+\boldsymbol b_2)(1-x)=\boldsymbol a_1x+\boldsymbol a_2(1-x)+\boldsymbol b_1x+\boldsymbol b_2(1-x)$，由于 $\boldsymbol a_1x+\boldsymbol a_2(1-x)\in A,\boldsymbol b_1x+\boldsymbol b_2(1-x)\in B$，因此它们的和 $\in C$。得证。

### Theorem 1

两个凸包的闵可夫斯基和上的边恰由两个凸包上的边不重不漏地组成。

感性理解。可以把闵可夫斯基和理解为把 $B$ 的一个端点限制在 $A$ 里面扫来扫去得到的点集，因此其和的边界应为把 $B$ 的一个端点限制在 $A$ 的边上扫出来的。

如果 $B$ 是逆时针在A上运动的，那么在扫描的过程中，充当“笔尖”的顶点（即把当前所在的边从凸包的另一侧靠近而切出来的点，或许叫对踵点？）也是在 $B$ 上逆时针旋转变动的。当它在 $A$ 的边上运动时，扫出来的就是 $A$ 的边，当它驻留在 $A$ 的顶点上时，如果“笔尖”从 $b_i$ 变为 $b_{i+1}$ 那么 $b_i$ 到 $b_{i+1}$ 之间的 $B$ 的边就会被印下来。由于两个东西都是逆时针动的，而且 $A$ 上的边都会被扫到，$B$ 的“笔尖”从起点回到起点，因此两个凸包的闵可夫斯基和上的边恰由两个凸包上的边不重不漏地组成。

因此，我们可以对 $A,B$ 两个凸包上的边极角排序，以得到它们在 $C$ 上的出现顺序（显然，逆时针遍历凸包上的边时，其边的极角从 $[0,2\pi)$ 递增）。然后找到 $A$、$B$ 两凸包的起点 $\boldsymbol a_0$、$\boldsymbol b_0$（即纵坐标最小的点），易证 $\boldsymbol a_0+\boldsymbol b_0$ 也是 $C$ 的起点，然后在起点上依次放上边就可以了。

由于楼下的图挂了，我也来一张样例靓照。（

![](https://cdn.luogu.com.cn/upload/image_hosting/3hzn41tj.png)

## 查询凸包

在求出$ C_1$ 和 $C_2$ 的闵夫斯基和（闵可夫斯基差？）后，我们还要知道向量（直接视作点）$d$ 是否在凸包里。

为此，对于一个凸包![](https://cdn.luogu.com.cn/upload/image_hosting/f3mh4jzm.png)，把起点和其他点连线，得到一个三角剖分![](https://cdn.luogu.com.cn/upload/image_hosting/0jqdim07.png)。

然后二分找出点可能在哪个三角形里——如果把起点平移至原点，所连的线的极角是有序的，把一个小于平角的角，准确来说是第一条边旋转至最后一条边形成的角，划分成了 $n-2$ 块，然后二分找出它所属的块对应的凸包上的边，利用叉积就可以轻松判断是否在三角形里了。

## code

时间复杂度 $O(q\log n+n\log n)$。

```c++
#include<bits/stdc++.h>
using ll=long long;
const int N=1e6;
struct vector{
    int x,y;
    void input(){scanf("%d%d",&x,&y);}
}ch1[N],ch2[N],ch3[N],a[N];
vector operator+(vector a,vector b){return {a.x+b.x,a.y+b.y};}
vector operator-(vector a,vector b){return {a.x-b.x,a.y-b.y};}
vector operator-(vector a){return {-a.x,-a.y};}
ll operator*(vector a,vector b){return 1ll*a.x*b.y-1ll*a.y*b.x;}
ll operator&(vector a,vector b){return 1ll*a.x*b.x+1ll*a.y*b.y;}
ll square(vector a) {return a&a;}
vector origin;
bool cmp_vec(const vector& a,const vector& b){
    if(a.y>=0^b.y>=0) return a.y>=0;
    if(a.y==0&&b.y==0&&(a.x>0^b.x>0)) return a.x>0;
    if(a*b==0) return square(a)<square(b);
    return a*b>0;
}
bool cmp_pnt(const vector& a,const vector& b){
    return a.y<b.y||a.y==b.y&&a.x<b.x;
}
int stk[N],top;bool used[N];vector b[N];
void convex_hull(vector a[],int& n){
    std::sort(a+1,a+n+1,cmp_pnt);
    std::fill(used+1,used+n+1,0);
    stk[top=1]=1;
    for(int i=2;i<=n;i++){
        while(top>1&&(a[stk[top]]-a[stk[top-1]])*(a[i]-a[stk[top]])<=0) used[stk[top--]]=0;
        used[stk[++top]=i]=1;
    }
    int base=top;
    for(int i=n-1;i>=1;i--)if(!used[i]){
        while(top>base&&(a[stk[top]]-a[stk[top-1]])*(a[i]-a[stk[top]])<=0) used[stk[top--]]=0;
        used[stk[++top]=i]=1;
    }
    std::copy(a,a+n+1,b);
    for(int i=1;i<top;i++) a[i]=b[stk[i]];
    n=top-1;
}
bool in_hull(vector a,vector ch[],int n){
    if(a.y<0||a*ch[2]>0) return 0;
	int l=2,r=n;
	while(l<r){
		int mid=l+r+1>>1;
		if(ch[mid]*a>=0) l=mid;
		else r=mid-1;
	}
    if(l==n) return ch[n]*a==0&&square(a)<=square(ch[n]);
	return (ch[l+1]-ch[l])*(a-ch[l])>=0;
}
int main(){
	int n,m,q;scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++) ch1[i].input();
	for(int i=1;i<=m;i++) ch2[i].input(),ch2[i]=-ch2[i];
	convex_hull(ch1,n),convex_hull(ch2,m);
	for(int i=1;i<=n;i++) a[i]=ch1[i%n+1]-ch1[i];
	for(int i=1;i<=m;i++) a[n+i]=ch2[i%m+1]-ch2[i];
	std::sort(a+1,a+n+m+1,cmp_vec);
    int p=1;ch3[1]={0,0};
	for(int i=1;i<=n+m;i++){
        if(i>1&&a[i]*a[i-1]==0) ch3[p]=ch3[p]+a[i];
        else ch3[p+1]=ch3[p]+a[i],++p;
    }
    --p;
	while(q--){
		vector d;d.input();d=d-(ch1[1]+ch2[1]);
		printf("%d\n",in_hull(d,ch3,p));
	}
}
```

---

## 作者：MarsCheng (赞：2)

# 闵可夫斯基和

## 前言

众所周知这道题是闵可夫斯基和的板子题。

~~众所周知黑题是不可能没有前置知识的~~，所以请大家先学完凸包再来，可以看二维凸包板子题解区大佬的神文[数论小白都能看懂的平面凸包详解 - 洛谷专栏 (luogu.com.cn)](https://www.luogu.com.cn/article/td3ah746)。

## 概述

顾名思义，闵可夫斯基和是一个和，准确来说是两个图形的和。

图形怎么能相加呢？其实确实不好加，但是两个向量是可以加的，图形是由点组成的，把点看作一个向量，再两两相加，得到一个新的点集，这个点集构成的图形就是两个图形的闵可夫斯基和。

形式化的，闵可夫斯基和的定义是这样，其中 A 代表图形 A 的点集，B 代表图形 B 的点集，C 代表两个图形的闵可夫斯基和的点集：

$$
C = \{a + b ~\vert~ a \in A, b \in B\}
$$

光说可能不是很直观，下面放一个图，对于这两个图形：

![](https://cdn.luogu.com.cn/upload/image_hosting/49d5qofe.png)

图片源于 OI-Wiki，侵删，开源精神万岁！

它们的闵可夫斯基和长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/msy55e1i.png)

好了相信大家已经知道什么是闵可夫斯基和了，那么闵可夫斯基和要怎么求呢？

## 闵可夫斯基和的求法

我们现在只关心凸包的闵可夫斯基和，因为做这题只需要求凸包的闵可夫斯基和。

通过瞪眼法不难发现，两个凸包的闵可夫斯基和也是一个凸包，并且闵可夫斯基和的边集是两个凸包的边集并起来。所以我们把两凸包的边丢到一起，按极角排序后依次连接，就是两个凸包的闵可夫斯基和了。

乍一看貌似要 $\mathcal{O}(n \log n)$ 排序，但是实际上我们求完凸包后，它的边本身就是按极角排序的，于是可以直接用归并排序，是 $\mathcal{O}(n)$ 的，但注意这样求的话可能有三点共线的情况，再跑一次凸包就解决了（虽然貌似这还是 $\mathcal{O}(n \log n)$......）

## 具体应用

我们回来看题，显然两个部落的领土都可以看作是凸包，把第一个部落凸包称为 $A$，第二个部落的称为 $B$，将移动向量称为 $w$ 那么移动后会爆发冲突相当于：

$$
A = B + w
$$
当然这个式子不是特别严谨，需要感性理解一下。$B + w$ 就相当于把 $B$ 按 $w$ 移动后的图形，而这个等号意味着两个图形相互重叠。

~~十分抽象？没事，还有更抽象的。~~ 我们对这个“等式”移一下项，变成这样：

$$
A - B = w
$$

发现我们试图对两个凸包做减法！众所周知减一个东西等于加上它的相反数，所以可以把式子写成这样：

$$
A + (-B) = w
$$
图形间的加法！闵可夫斯基和！但是这个 $-B$ 又是什么鬼东西？？我们考虑到我们在定义闵可夫斯基和的时候是把每个点分别相加，那我们可以类似的定义这个$-B$，也就是把每个点 $(x, y)$ 变成 $(-x,-y)$。然后这个等于号又怎样定义呢？我们可以考虑把这个向量看成一个点，那等于自然就是看这个点是否在图形中了。

所以说，我们把 $B$ 中的每一个点 $(x, y)$ 都变成 $(-x,-y)$ 后，算出其与 A 的闵可夫斯基和，每一次询问判断一下询问的向量的末端是否在闵可夫斯基和里面就可以了。

以上内容显然十分抽象，大家继续感性理解一下。

### 判断点是否在凸包内

大部分题解都对这个讲的比较模糊，这里来完善一下。

先来看一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/921qfjs7.png)

画的比较抽象，将就看吧。

显然蓝点和红点在凸包外，而绿点在凸包内，以紫点为原点向各点连线。不难发现如果点在凸包外，它的连线要么与凸包有交点（原点不算），要么在黄线的外面。在黄线的外面是好判断的（用叉乘），但是怎么判断有无交点呢？再看一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/afo1otf4.png)

在这张图中红线上有两个点，红点在凸包外，绿点在凸包内，我们找到红线顺时针方向上第一个点（这可以二分找），对红绿两点连边，发现这两条线一个在橙边上面，一个在下面，使用叉乘判断一下。结合上面我们可以 $\mathcal{O}(\log n)$ 判断一个点在凸包内还是凸包外。

最终的时间复杂都就是 $\mathcal{O}(n \log n + q \log n)$。

## 代码实现

```cpp
#include <bits/stdc++.h>

const int N = 1e5 + 7;

int n, m, q, cac, cbc, pcnt;
struct Vec {
    long long x, y;	// 不开 long long 的话你懂的
    // 向量加法
    Vec operator+(const Vec& v) const {
        return {x + v.x, y + v.y};
    }
    // 向量减法
    Vec operator-(const Vec& v) const {
        return {x - v.x, y - v.y};
    }
    // 叉乘
    long long operator*(const Vec& v) const {
        return x * v.y - y * v.x;
    }
    // 向量模长
    long long len() const {
        return x * x + y * y;
    }
};
Vec a[N], b[N];			// 题目给出的点
Vec ca[N], cb[N];		// 求的凸包
Vec ea[N], eb[N];		// 凸包上的边
Vec p[N * 2], pv[N * 2]; // 闵可夫斯基和及重求一遍凸包的图形
Vec o;					// 即上文图中的紫点，用作原点
Vec off;				// 输入的移动向量

// 求凸包，从 a 中读点，答案存到 st 中，返回凸包点数
int convex(Vec* a, Vec* st, int n) {
    for (int i = 2; i <= n; i++)
        if (a[i].y < a[1].y || (a[i].y == a[1].y && a[i].x < a[1].x))
            std::swap(a[i], a[1]);
    std::sort(a + 2, a + n + 1, [&](const Vec& u, const Vec& v) {
        //　小心这里也要开 long long （我在这卡了2个多小时．．．）
        long long cr = (u - a[1]) * (v - a[1]);
        if (cr > 0)
            return true;
        if (cr == 0 && (u - a[1]).len() < (v - a[1]).len())
            return true;
        return false;
    });
    int tp = 1;
    st[tp] = a[1];
    for (int i = 2; i <= n; i++) {
        while (tp >= 2 && ((st[tp] - st[tp - 1]) * (a[i] - st[tp - 1])) <= 0)
            tp--;
        st[++tp] = a[i];
    }
    return tp;
}
// 求闵可夫斯基和
void minkowski() {
    // 求出两个凸包的边
    for (int i = 1; i < cac; i++)
        ea[i] = ca[i + 1] - ca[i];
    ea[cac] = ca[1] - ca[cac];

    for (int i = 1; i < cbc; i++)
        eb[i] = cb[i + 1] - cb[i];
    eb[cbc] = cb[1] - cb[cbc];

    // 使用归并排序（这里调试的时候一气之下把所有压行去掉了，从结果来看貌似可读性更强一些）
    int p1 = 1, p2 = 1;
    p[pcnt = 1] = ca[1] + cb[1];	// 两个凸包的最下面的点一定在闵可夫斯基和中，作为起始点
    while (p1 <= cac && p2 <= cbc) {
        pcnt++;
        if ((ea[p1] * eb[p2]) > 0) {	// 加入极角更小的边
            p[pcnt] = p[pcnt - 1] + ea[p1];
            p1++;
        } else {
            p[pcnt] = p[pcnt - 1] + eb[p2];
            p2++;
        }
    }
    // 有剩余的边也要加进来
    while (p1 <= cac) {
        pcnt++;
        p[pcnt] = p[pcnt - 1] + ea[p1];
        p1++;
    }
    while (p2 <= cbc) {
        pcnt++;
        p[pcnt] = p[pcnt - 1] + eb[p2];
        p2++;
    }
    pcnt = convex(p, pv, pcnt);	// 对求出的图形再求一遍凸包
    // 记录一下原点（即上图紫点），并把这个点平移到原点
    o = pv[1];
    for (int i = 1; i <= pcnt; i++)
        pv[i] = pv[i] - o;
}
// lower_bound 使用自定义比较函数时返回第一个使 cmp 返回 false 的点， 传进去的点永远是第二个参数
bool cmp(Vec u, Vec v) {
    long long cr = u * v;
    if (cr > 0)
        return true; // 如果在点的顺时针方向就返回 true
    if (cr == 0 && u.len() < v.len())
        return true;
    return false;	// 于是 lower_bound 返回第一个在点顺时针方向的点
}
bool check(Vec v) {	//　这个地方细节很多，我也不大确定我写的对不对（反正 hack 数据过了），欢迎大佬 hack
    // 先判断一下是不是在上图黄线的外面
    if (v * pv[2] > 0 || (pv[pcnt] * v) > 0 ||
        (v * pv[2] == 0 && pv[2].len() < v.len()) || 	// 如果出现共线的情况判断一下长度
        (pv[pcnt] * v == 0 && pv[pcnt].len() < v.len()))
        return false;
    int ps = std::lower_bound(pv + 2, pv + pcnt + 1, v, cmp) - pv - 1;	// 这里有一个 -1
    Vec v1 = v - pv[ps], v2 = pv[ps % pcnt + 1] - pv[ps];	// v1 对应上面的红/绿边，v2 对应上面橙边
    return (v1 * v2) <= 0;	// 再用叉乘判断一下方向
}

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; i++)
        scanf("%lld%lld", &a[i].x, &a[i].y);
    for (int i = 1; i <= m; i++) {
        scanf("%lld%lld", &b[i].x, &b[i].y);
        b[i].x = -b[i].x, b[i].y = -b[i].y;		// 取反
    }
    cac = convex(a, ca, n), cbc = convex(b, cb, m);	// 算凸包
    minkowski();	// 算闵可夫斯基和
    while (q--) {
        scanf("%lld%lld", &off.x, &off.y);
        printf(check(off - o) ? "1" : "0");	// 由于上面的地方把闵可夫斯基和平移了一下，所以这里也要平移
    }
    return 0;
}
```

---

## 作者：Mirasycle (赞：1)

定义对于两个点集 $A,B$，其闵可夫斯基和为 $A+B=\{a+b,a\in A,b\in B\}$。

我们研究两个凸包之间的闵可夫斯基和，可以发现是把凸包中的边进行了平移得到的，等价于对于两个凸包中的边进行极角排序之后放在一起。凸包本来就有单调性，所以可以直接归并这些边，复杂度是 $O(|A|+|B|)$ 的。

具体做法就是初始点是 $a_0+b_0$，然后我们把凸包中的相邻点作差分（得到了边），按照斜率把种边进行归并加入，每次都在上一个点的基础上加上一个新加入的向量（边）得到一个新的点。注意求完 Minkowski 之后最好再求一次凸包，去掉一次多余的点，比如三点共线之类的。如果不最后再求一次凸包的话，那些三点共线的点可能会对于后续的二分造成影响。

本题等价于对于 $A$ 和 $(-B)$ 求闵可夫斯基和之后，判断给定点是否在凸包之内。

按照上文所述求出凸包之后，我们任意选择一个点作为起点对于凸包进行三角剖分。也就是通过该起点和凸包中任意两个相邻点，把凸包划分为 $n-2$ 个三角形。然后我们只需要通过叉积判断方向，二分出给定点如果被凸包包含，会在哪个三角形之内，然后再判断是否在这个三角形之内（直接用叉积对于第三条边判定即可）。注意 corner case 就是可能出现某个点恰好处于最后一条边上，特判一下即可。

代码写的很顺，过了样例之后就一遍 AC 了。~~虽然我在样例完全错误（三个答案都错了）的时候还试着交了一次，结果居然获得了 $64$ 分的好成绩。~~


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=3e5+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
struct Point{
	int x,y;
	bool operator < (const Point &rhs) const { return x<rhs.x||(x==rhs.x&&y<rhs.y); }
}; typedef Point Vector; vector<Point> s,t,ps;
ll Cross (Vector v1,Vector v2){ return 1ll*v1.x*v2.y-1ll*v1.y*v2.x; }
Vector operator + (Vector v1,Vector v2){ return (Vector){v1.x+v2.x,v1.y+v2.y}; }
Vector operator - (Vector v1,Vector v2){ return (Vector){v1.x-v2.x,v1.y-v2.y}; }
int n,m,q; vector<Point> H;
vector<Point> Hull(vector<Point> S){
	int sz=S.size(); if(sz<=1) return S;
	sort(S.begin(),S.end()); int k=0,t; 
	H.clear(); H.resize(2*sz); 
	for(int i=0;i<sz;H[k++]=S[i++])
		while(k>1&&Cross(S[i]-H[k-1],H[k-1]-H[k-2])>=0) k--;
	for(int i=sz-2,t=k;i>=0;H[k++]=S[i--])
		while(k>t&&Cross(S[i]-H[k-1],H[k-1]-H[k-2])>=0) k--;
	H.resize(k-1); return H;
}
vector<Point> Minkowski(vector<Point> S,vector<Point> T){
	H.clear(); H.pb(S[0]+T[0]);
	int s1=S.size(),t1=T.size(); Point s0=S[0],t0=T[0];
	for(int i=0;i<s1-1;i++) S[i]=S[i+1]-S[i];
	for(int i=0;i<t1-1;i++) T[i]=T[i+1]-T[i];
	S[s1-1]=s0-S[s1-1]; T[t1-1]=t0-T[t1-1];
	for(int i=0,j=0;i<s1||j<t1;){
		if(i==s1) H.pb(H.back()+T[j++]);
		else if(j==t1) H.pb(H.back()+S[i++]);
		else if(Cross(S[i],T[j])>=0) H.pb(H.back()+S[i++]);
		else H.pb(H.back()+T[j++]);
	}
	return H;
}
bool chk(Point n0){
	int l=0,r=s.size()-1;
	while(l<r){
		int mid=(l+r+1)>>1;
		if(Cross(s[mid]-s[0],n0-s[0])>=0) l=mid;
		else r=mid-1;
	}
	if(l==s.size()-1){
		if(Cross(n0-s[0],n0-s[l])==0&&s[0].x<=n0.x&&n0.x<=s[l].x&&s[0].y<=n0.y&&n0.y<=s[l].y)
			return 1;
		return 0;
	}
	if(Cross(s[l+1]-s[l],n0-s[l])>=0) return 1;
	else return 0;
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++){
		int x,y; cin>>x>>y;
		s.pb((Point){x,y});
	}
	for(int i=1;i<=m;i++){
		int x,y; cin>>x>>y;
		t.pb((Point){-x,-y});
	}
	s=Hull(s); t=Hull(t);
	s=Minkowski(s,t); s=Hull(s);
	for(int i=1;i<=q;i++){
		int x,y; cin>>x>>y;
		if(chk((Point){x,y})) cout<<1<<endl;
		else cout<<0<<endl;
	}
	return 0;
}
```

---


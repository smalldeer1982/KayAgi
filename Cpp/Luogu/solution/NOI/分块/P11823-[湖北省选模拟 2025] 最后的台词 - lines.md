# [湖北省选模拟 2025] 最后的台词 / lines

## 题目描述

现某戏剧拟从一段优美的文字中截取若干片段作为剧本中的台词。具体的要求如下：

1. 剧本由若干句从给定文字中截取的台词组成。即，每句台词都必须是给定的字符串 $S$ 的一个子串。
2. 相邻的两句台词必须可以相互衔接。具体而言，给定一衔接系数 $k$，每一句台词的长度为 $k$ 的后缀必须和下一句台词的长度为 $k$ 的前缀相同。
3. 剧本最初的台词和最后的台词已经确定，第一句台词为 $S_{l_1\ldots r_1}$，最后一句台词为 $S_{l_2\ldots r_2}$。

现已知字符串 $S$，请你编写程序，对于多组给定的 $l_1, r_1, l_2, r_2$ 和衔接系数 $k$，计算是否存在满足上述限制的剧本。
如果存在，至少包含多少句台词。

## 说明/提示

**【样例 1 解释】**

对于第一组询问，给定的第一句台词和最后一句台词是完全相同的，因此剧本可以仅包含这一个字符串。

对于第二组询问，一种可行的方案为 $\{\text{ab}, \text{aba}, \text{ba}\}$。

对于第三组询问，一种可行的方案为 $\{\text{yaba}, \text{abax}\}$。

对于第四组询问，可以证明不存在可以满足题目中要求的剧本。

**【样例 2】**

见选手目录下的 `lines/lines2.in` 与 `lines/lines2.ans`。

样例 $2$ 满足测试点 $2\sim 3$ 的限制。

**【样例 3】**

见选手目录下的 `lines/lines3.in` 与 `lines/lines3.ans`。

样例 $3$ 满足测试点 $2\sim 3$ 的限制。

**【样例 4】**

见选手目录下的 `lines/lines4.in` 与 `lines/lines4.ans`。

样例 $4$ 满足测试点 $11\sim 12$ 的限制。

**【样例 5】**

见选手目录下的 `lines/lines5.in` 与 `lines/lines5.ans`。

样例 $5$ 满足测试点 $11\sim 12$ 的限制。

**【子任务】**

对于全部的测试数据，保证 $1 \le |S| \le 10^6$，$1 \le q \le 10^6$，$1 \le l_1 + k - 1 \le r_1 \le |S|$，$1 \le l_2 + k - 1 \le r_2 \le |S|$，$1 \le k \le |S|$。

| 测试点 | $\lvert  S \rvert \leq$ | $q \leq $ | 特殊性质 |
| :--: | :--: | :--: | :--: |
| $1$ | $10$ | $10$ | 无 |
| $2,3$ | $400$ | $400$ | 无 |
| $4\sim 6$ | $3000$ | $5\times 10^4$ | 无 |
| $7,8$ | $5\times 10^4$ | $5\times 10^4$ | $l_1 \le l_2$ |
| $9,10$ | $5\times 10^4$ | $5\times 10^4$ | $k \le 10$ |
| $11,12$ | $5\times 10^4$ | $5\times 10^4$ | 无 |
| $13\sim 16$ | $2\times 10^5$ | $2\times 10^5$ | 无 |
| $17\sim 20$ | $10^6$ | $10^6$ | 无 |

## 样例 #1

### 输入

```
abaxyaba
4
2 3 7 8 2
1 2 7 8 2
5 8 1 4 3
5 8 1 4 4```

### 输出

```
1
3
2
-1
```

# 题解

## 作者：eastcloud (赞：6)

先考虑 $k$ 固定怎么做，先把答案为 1 到 2 的情况简单特判掉，答案为 1 即为两个串相同，答案为 2 就是第一个串长度为 $k$ 的后缀和第二个串长度为 $k$ 的前缀相同。而对于剩下的情况，我们发现除了第一个和最后一个串，其他每个串的作用相当于把我们要匹配的串换成另一个串，直到这个串被换成结尾串的前缀。

设一个串 $u$ 的 endpos 集合为 $S_u$， $u$ 为初始串的长度为 $k$ 的后缀，$v$ 为结尾串长度为 $k$ 的前缀，于是问题变成初始令 $p \gets \min_{d \in S_u} d $，其中，每次我们可以找到一个 $q>p$，令 $T$ 为 $q$ 所在的串，则我们要做的就是 $p \gets \min_{d \in T} d$，问最少多少次操作 $p\le \max_{d\in S_v} d$。

对于固定的 $k$，每个 $p$ 对应的 $q$ 是唯一的，可以直接连边然后倍增往上跳，而 $k$ 不固定时可以考虑从大到小扫描 $k$，每次一个点的父亲要更改时对应着前缀树上两个节点合并，我们相当于把一个前缀树上节点的所有儿子的 endpos 集合的父亲对其最小值取 min，由于父亲编号是单调的，维护出连续段后可以操作就是区间覆盖。

于是问题又变成区间覆盖父亲，区间查某个点一直往上跳要跳几步才小于某个给定值，这个可以 LCT 维护，每次区间覆盖只修改连续段最左边点的父亲，其他的可以以 0 的边权连左边节点，每次 access 然后平衡树上二分即可，时间复杂度 $O(n \log n)$。

如果你不想写 LCT，可以考虑分块，区间覆盖小块暴力，大块打 tag，你需要对没打过 tag 的块预处理每个点第一次跳出块的位置和贡献，查询直接贪心跳即可，由于数据很水也可以通过。

提供个分块代码，~~写的时候没动脑子，实现比较呃呃，不太建议参考~~。


```cpp
#include<bits/stdc++.h>

#define vi vector<int>
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define pi pair<int,int>
#define ll long long
#define IL inline
#define For(i,j,k) for(int i=(j);i<=(k);i++)
#define Fol(i,j,k) for(int i=(j);i>=(k);i--)
#define fi first
#define se second

using namespace std;

#define N 2000005
#define inf 0x3f3f3f3f

int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9')f=(ch=='-'?-1:f),ch=getchar();
    while(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x/10)write(x/10);
    putchar(x%10+'0');
}

void debug(auto ...x){
    ((cerr<<x<<' '),...);
    cerr<<endl;
}

char s[N];
map<pi,int> t;
vector<array<int,3> > Q[N];
vector<pi> P[N];

namespace SAM{
    int nex[N][26],len[N],fa[N],mned[N],mxed[N],las,cnt,lasp[N];
    int f[21][N];
    basic_string<int> e[N];
    vi S[N];
    void extend(int it,int d){
        int cur=++cnt,p=las;len[cur]=len[p]+1;mxed[cur]=mned[cur]=d;las=cur;S[cur].pb(d);lasp[d]=cur;
        while(!nex[p][it])nex[p][it]=cur,p=fa[p];
        if(!p)return fa[cur]=1,void();
        int q=nex[p][it];
        if(len[q]==len[p]+1)return fa[cur]=q,void();
        int cl=++cnt;memcpy(nex[cl],nex[q],sizeof(nex[q]));len[cl]=len[p]+1;
        fa[cl]=fa[q];fa[q]=fa[cur]=cl;
        while(nex[p][it]==q)nex[p][it]=cl,p=fa[p];
    }
    void init(){
        For(i,1,cnt)if(fa[i])e[fa[i]]+=i,f[0][i]=fa[i];
        For(i,1,__lg(cnt))For(j,1,cnt)f[i][j]=f[i-1][f[i-1][j]];
        auto dfs=[&](auto &&self,int x)->void {
            if(!mxed[x])mxed[x]=0,mned[x]=0x3f3f3f3f;
            for(auto v:e[x]){
                self(self,v);mxed[x]=max(mxed[x],mxed[v]);
                mned[x]=min(mned[x],mned[v]);
            }
            P[len[x]].eb(mned[x],mxed[x]);
        };
        dfs(dfs,1);
    }
    pi jump(int x,int k){
        int now=lasp[x];
        if(len[now]>=k && len[fa[now]]<k)return mp(now,mned[now]);
        Fol(i,__lg(cnt),0)if(f[i][now] && len[f[i][now]]>=k)now=f[i][now];
        return mp(now,mned[now]);
    }
}

int f[N],ans[N];

int n;

struct Block{
    int a[N],tag[N],b[N],len[N];
    #define B 505
    void rebuild(int id){
        int l=id*B+1,r=min((id+1)*B,n);
        if(f[r]<l)return;
        For(i,l,r){
            if(a[i]<l)b[i]=a[i],len[i]=1;
            else if(a[i]==i)b[i]=i,len[i]=0;
            else b[i]=b[a[i]],len[i]=len[a[i]]+1;
        }
    }
    void upd(int l,int r){
        if(l>r)return;
        int Bl=(l-1)/B,Br=(r-1)/B;
        if(Bl==Br){
            if(tag[Bl]<l)return;
            Fol(i,r,l){
                a[i]=min(a[i],l);
                if(tag[Bl]!=inf && a[i]<l)return;
            }
            rebuild(Bl);return;
        }
        For(i,l,(Bl+1)*B)a[i]=min(a[i],l);
        For(i,Br*B+1,r)a[i]=min(a[i],l);
        if(tag[Bl]==inf)rebuild(Bl);
        if(tag[Br]==inf)rebuild(Br);
        For(i,Bl+1,Br-1)tag[i]=min(tag[i],l);
    }
    int ljump(int now,int goal){
        int res=0;
        while(now>goal){
            if(min(a[now],tag[(now-1)/B])==now)return -1;
            now=min(a[now],tag[(now-1)/B]);res++;
        }
        return res;
    }
    int bjump(int now,int goal){
        int res=0;
        while(now>goal){
            if(tag[(now-1)/B]!=inf)now=min(tag[(now-1)/B],a[now]),res++;
            else if(b[now]>=goal && b[now]!=now)res+=len[now],now=b[now];
            else{
                int ans=ljump(now,goal);
                if(ans==-1)return -1;
                return ans+res;
            }
        }
        return res;
    }
    #undef B
}Blo;

int main(){
    //freopen("lines5.in","r",stdin);
    //freopen("lines5.out","w",stdout);

    scanf("%s",s+1);n=strlen(s+1);SAM::las=SAM::cnt=1;
    int q=read();
    For(i,1,n)SAM::extend(s[i]-'a',i);SAM::init();
    For(i,1,q){
        int l1=read(),r1=read(),l2=read(),r2=read(),k=read();
        if(r1-l1==r2-l2 && SAM::jump(r1,r1-l1+1).fi==SAM::jump(r2,r1-l1+1).fi){ans[i]=1;continue;}
        Q[k].pb(array<int,3>{r1,l2+k-1,i});
    }
    For(i,0,n)f[i]=i,Blo.tag[i]=inf,Blo.a[i]=Blo.b[i]=i;
    Fol(k,n,1){
        for(auto [l,r]:P[k]){
            Blo.upd(l,r);
        }
        for(auto [now,goal,id]:Q[k]){
            pi A=SAM::jump(now,k),B=SAM::jump(goal,k);B.se=SAM::mxed[B.fi];
            if(A.fi==B.fi){ans[id]=2;continue;}
            now=A.se;goal=B.se;
            if(now<=goal){ans[id]=3;continue;}
            int res=Blo.bjump(now,goal);
            if(res==-1)ans[id]=-1;
            else ans[id]=res+3;
        }
    }
    For(i,1,q)write(ans[i]),putchar('\n');
    return 0;
}
```

---

## 作者：mRXxy0o0 (赞：4)

叠甲：这是场外乱胡的，估计不是最优的做法。

考虑 $k=n$ 时，我们每个位置有一个颜色 $c_i$，$c_i=c_j$ 表示从 $[i,i+k-1]=[j,j+k-1]$ ，那么跳跃的规则就是 $[l1,r1]\rightarrow [l2,r2],c_{r1}=c_{l2}$。

维护颜色可以建后缀树，总共只会合并 $n-1$ 次。

设 $F_i,G_i$ 表示颜色 $i$ 首次、最后出现位置。

考虑维护 $p_i=\min_{j\ge i}(F_{c_j})$。求答案的话就把这棵树建出来（显然 $p$ 是单调的），设 $u,u>G_{c_{l2}},p_u\le G_{c_{l2}}$ 且 $u$ 是询问给的 $r1$ 的祖先。那么答案就是 $dep_{r1}-dep_u+2$，注意可能无解。

如何在合并颜色的时候维护 $p$ 呢？设合并颜色 $x,y,G_x<G_y$，注意到只有 $p_i,i\in(G_x,G_y]$ 的值会变成 $p_{G_x}$。

这里刚学 c++ 的萌新提出一种很唐的做法，用 LCT 维护这棵树，区间连边太傻了，用一个并查集把 $p$ 取值相同的压缩成最左边的一个点（也可以 LCT，但是就要记边权了）。查询的时候就 `access`，到答案链就平衡树上二分。

---

## 作者：definieren (赞：2)

先考虑 $k$ 固定的做法。

发现我们每次加入一个字符串的过程就相当于：找到当前字符串的长为 $k$ 的后缀的出现位置，那么新加入的字符串的左端点一定在这些位置中，右端点可以任选。

不难发现，对于一个长度为 $k$ 的子串，只有它第一次出现的位置 $l$ 和最后一次出现的位置 $r$ 是有用的。

将一个长为 $k$ 的子串看成二元组 $(l, r)$，那么我们每次要做的就相当于：记 $s_{[r_1 - k + 1, r_1]}$ 这个子串的二元组为 $(L_1, R_1)$，$s_{[l_2, l_2 + k - 1]}$ 这个子串对应的二元组为 $(L_2, R_2)$，在二元组 $(l, r)$ 时每次可以跳到二元组 $(*, \ge l)$，问最少跳多少次才能从 $(L_1, R_1)$ 跳到 $(L_2, R_2)$。

显然我们每次只会跳到满足 $r' \ge l$ 的二元组 $(l', r')$ 中 $l'$ 最小的一个，因为这样后面能跳的位置最多。

记 $f_i$ 表示满足 $r \ge i$ 的二元组中 $l$ 最小是多少，此时有 $f$ 单调不降，且形成了一棵树，答案就是 $L_1$ 和祖先中第一个 $\le R_2$ 的点的距离，跳不到为 $-1$。

如果 $k$ 不固定，考虑维护这个树的结构。

求出 $s$ 的后缀数组，当 $k$ 固定时，所有的长为 $k$ 的本质不同的子串将 sa 数组划分成了若干段连续区间，且当 $k$ 减小时，只会产生区间的合并，合并的区间可以通过 height 数组快速找到。

这样就得到了一个暴力做法：从大往小扫 $k$，同时维护子串对应的区间以及最早和最晚的出现位置。合并子串可以并查集维护，在 $f$ 上的修改是区间 chkmin。查询暴力跳。

依据实现可以得到 $[60, 100]$ 分。

优化这个过程是简单的，考虑用 LCT 维护 $f$ 构成的树，并用一个 set 维护 $f$ 的颜色段。

由于 $f$ 不降，区间对 $x$ chkmin 就相当于区间推平，可以在 set 上找到对应区间，左侧的区间向它右边的区间在 LCT 上连边权为 0 的边，然后最后一个区间向 $x$ 连边权为 1 的边。

查询就是 splay 上二分。

注意特判答案为 $1$ 或 $2$ 的情况。

时间复杂度 $O(n \log n)$，细节可以看代码。


```cpp
#include <bits/stdc++.h>

using namespace std;

template<class T> bool chkmin(T &x, T y) {
	return x > y ? (x = y, true) : false;
}
template<class T> bool chkmax(T &x, T y) {
	return x < y ? (x = y, true) : false;
}

constexpr int N = 1e6 + 5, LG = 20;
int n, q, sa[N], rk[N], ans[N], ht[N], fa[N], L[N], R[N],
	ork[N << 1], id[N], pid[N], bin[N], st[LG][N];
vector<int> upd[N];
vector<tuple<int, int, int>> qry[N];
char s[N];

void Build() {
	int m = (int)'z', p = 0;
	auto cmp = [&](int i, int j, int w) -> bool {
		return ork[i] == ork[j] && ork[i + w] == ork[j + w];
	};
	for (int i = 1; i <= n; i ++) bin[rk[i] = s[i]] ++;
	for (int i = 1; i <= m; i ++) bin[i] += bin[i - 1];
	for (int i = n; i >= 1; i --) sa[bin[rk[i]] --] = i;
	for (int w = 1; ; w <<= 1, m = p, p = 0) {
		for (int i = n; i > n - w; i --) id[++ p] = i;
		for (int i = 1; i <= n; i ++) if (sa[i] > w) id[++ p] = sa[i] - w;
		for (int i = 1; i <= m; i ++) bin[i] = 0;
		for (int i = 1; i <= n; i ++) bin[pid[i] = rk[id[i]]] ++;
		for (int i = 1; i <= m; i ++) bin[i] += bin[i - 1];
		for (int i = n; i >= 1; i --) sa[bin[pid[i]] --] = id[i];
		for (int i = 1; i <= n; i ++) ork[i] = rk[i];
		p = 0;
		for (int i = 1; i <= n; i ++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++ p;
		if (p == n) break;
	}
	for (int i = 1, j = 0; i <= n; i ++) {
		if (j) j --;
		while (s[i + j] == s[sa[rk[i] - 1] + j]) j ++;
		ht[rk[i]] = st[0][rk[i]] = j;
	}
	for (int i = 1; i <= __lg(n); i ++)
		for (int j = 1; j + (1 << i) - 1 <= n; j ++)
			st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
	return;
}
int LCP(int i, int j) {
	if (!i || !j) return 0;
	if (i == j) return n - i + 1;
	if ((i = rk[i]) > (j = rk[j])) swap(i, j);
	int k = __lg(j - i);
	return min(st[k][i + 1], st[k][j - (1 << k) + 1]);
}

int Find(int u) {
	while (fa[u] != u)
		u = fa[u] = fa[fa[u]];
	return u;
}

namespace LCT {
	int fa[N], ch[2][N], vl[N], sm[N], mn[N];
	
	bool Get(int u) { return ch[1][fa[u]] == u; }
	bool Is_Root(int u) { return ch[Get(u)][fa[u]] != u; }
	void Push_Up(int u) {
		sm[u] = vl[u], mn[u] = u;
		for (int o : {0, 1}) if (ch[o][u]) {
			chkmin(mn[u], mn[ch[o][u]]);
			sm[u] += sm[ch[o][u]];
		}
		return;
	}
	void Rotate(int u) {
		int f = fa[u], ff = fa[f], k = Get(u);
		if (!Is_Root(f)) ch[Get(f)][ff] = u;
		fa[u] = ff, fa[ch[k][f] = ch[!k][u]] = f, fa[ch[!k][u] = f] = u;
		return Push_Up(f), Push_Up(u), void();
	}
	void Splay(int u) {
		for (int f = fa[u]; !Is_Root(u); Rotate(u), f = fa[u])
			if (!Is_Root(f)) (Get(u) ^ Get(f)) ? Rotate(u) : Rotate(f);
		return;
	}
	
	void Init(int n) {
		for (int i = 1; i <= n; i ++)
			mn[i] = i, sm[i] = vl[i] = 1;
		return;
	}
	int Access(int u) {
		int v = 0;
		for (; u; u = fa[v = u])
			Splay(u), ch[1][u] = v, Push_Up(u);
		return v;
	}
	void Link(int u, int f, int v) {
		Access(u), Splay(u);
		fa[ch[0][u]] = 0, ch[0][u] = 0;
		vl[u] = v, Push_Up(u), fa[u] = f;
		return;
	}
	int Calc(int p, int x) {
		p = Access(p);
		if (mn[p] > x) return -4;
		int ans = 0;
		while (true) {
			if (ch[1][p] && mn[ch[1][p]] <= x) p = ch[1][p];
			else if (p > x) ans += sm[ch[1][p]] + vl[p], p = ch[0][p];
			else { ans += sm[ch[1][p]]; break; }
		}
		return Splay(p), ans;
	}
}

using LCT::Link, LCT::Calc;

struct Node {
	int l, r, v;
	
	bool operator < (const Node& rhs) const {
		return l < rhs.l;
	}
}; set<Node> F;

auto Split(int pos) {
	if (pos > n) return F.end();
	auto it = F.lower_bound({pos, 0, 0});
	if (it != F.end() && it -> l == pos) return it;
	-- it; auto [l, r, v] = *it;
	F.erase(it), F.insert({l, pos - 1, v});
	return F.insert({pos, r, v}).first;
}

int main() {
	ios::sync_with_stdio(false);
	cin.getline(s + 1, N - 1), cin >> q;
	n = strlen(s + 1), Build();
	
	for (int i = 1; i <= n; i ++)
		upd[ht[i]].emplace_back(i);
	
	for (int i = 1; i <= q; i ++) {
		int l1, r1, l2, r2, k;
		cin >> l1 >> r1 >> l2 >> r2 >> k;
		if (r1 - l1 == r2 - l2 && LCP(l1, l2) >= r1 - l1 + 1)
			{ ans[i] = 1; continue; }
		if (LCP(r1 - k + 1, l2) >= k)
			{ ans[i] = 2; continue; }
		qry[k].emplace_back(r1 - k + 1, l2, i);
	}
	
	LCT::Init(n);
	for (int i = 1; i <= n; i ++)
		F.insert({i, i, i});
	for (int k = n; k >= 1; k --) {
		fa[rk[n - k + 1]] = rk[n - k + 1];
		L[rk[n - k + 1]] = R[rk[n - k + 1]] = n - k + 1;
		for (auto i : upd[k]) {
			int j = Find(i - 1);
			fa[i] = j, chkmin(L[j], L[i]), chkmax(R[j], R[i]);
			int r = R[j], l = r + 1;
			if ((-- F.upper_bound({r, 0, 0})) -> v <= L[j])
				continue;
			auto it = Split(r + 1);
			Link(r, L[j], 1);
			while (it != F.begin()) {
				auto x = *prev(it);
				if (x.v <= L[j]) break;
				if (x.r < r) Link(x.r, x.r + 1, 0);
				l = x.l, F.erase(prev(it));
			}
			F.insert({l, r, L[j]});
		}
		
		for (auto [l, r, id] : qry[k]) {
			l = L[Find(rk[l])], r = R[Find(rk[r])];
			ans[id] = 3 + Calc(l, r);
		}
	}
	
	for (int i = 1; i <= q; i ++)
		cout << ans[i] << '\n';
	
	return 0;
}
```

---

## 作者：xuanxuan001 (赞：2)

大力出奇迹。

考虑离线后求出后缀数组以及 weight 数组，然后可以从大到小扫 $k$，同时维护后面长度为 $k$ 的子段的等价类，发现只会合并 $O(n)$ 次。那么相当于每次选择的区间首尾相接的两个需要是同一个等价类，那么相当于可以无代价在同等价类内横跳，而从小编号到大编号需要一的代价，特判掉答案 $\le 2$ 的情况后答案就是代价加首尾的两个，那么求解过程一定是从 $l1$ 开始每次贪心选择一个能用一次有代价的移动到的最小编号，直到编号小于 $y$。

考虑维护出上面需要的最小编号 $p_i$，发现当合并两个等价类 $u,v$ 是，设它们的最小和最大编号分别为 $l_u,r_u,l_v,r_v$，并不妨设 $l_u < l_v$，那么其实就是将 $(r_u, r_v]$ 的部分与 $l_u$ 取 $\min$，发现这个过程和奇怪的查询方式让这个问题很难维护，赛时思考了很久 $\operatorname{polylog}$ 做法无果，但直接写暴力复杂度和纯搜可能差不多，就白想那么多了~~虽然好像基本所有人都能想到~~，于是开始考虑 $2 \times 10^5$ 的部分分，发现可以大力分块。

由于 $p$ 单调不降，所以取 $\min$ 实际上就是区间推平，而在分块中区间推平只需要重构端点并给中间的块打标记即可，而查询只需要维护出每个位置向上跳第一次跳出所在块时会跳到哪以及步数。由于整块的推平的值一定在块外，所以被标记的块的那些信息都很容易，一定是一步跳出去。

于是复杂度是 $O((n+m) \sqrt n)$，但发现跑得很快，因为确实难以跑满，再注意到 4s 时限，考虑开大数组。

发现这种区间推平操作由于需要重构两个块，而中间块的区间往往不能卡满，所以实际上散块上的常数比整块大一些，所以应调小块长，但我赛时忘了而直接开了 $10^3$，导致最后一个点 T 了，然后后缀数组上写挂了一个奇妙的地方导致 WA #1，于是 $100 \rightarrow 90$。但由于没开大数组并且每个块对应到区间是直接乘的，导致如果块长不整除 $n$ 就会越界，但刚好选了 $10^3|10^6$，也算是幸运了。

代码感觉不太需要放，也很丑，就不放了，[记录](https://www.luogu.com.cn/record/205039363)。

---

## 作者：Iniaugoty (赞：1)

~~还好我是口胡哥。~~

发现问题在不断重复这样一个过程：当前位于某个长为 $k$ 的字符串上，设它在原串中第一次出现的位置为 $x$，若另一个长为 $k$ 的字符串在 $x$ 后面出现了一次，就可以跳过去。要求从 $s _ {[r _ 1 - k + 1, r _ 1]}$ 跳到 $s _ {[l _ 2, l _ 2 + k - 1]}$，最小化跳的次数。

考虑建出 SAM 来维护“在原串中出现的位置”这个信息，即 $\operatorname {endpos}$ 集合。那么 $u$ 结点代表的串能跳到 $v$ 结点代表的串上，当且仅当 $\displaystyle \min _ {i \in \operatorname {endpos} (u)} i \le \max _ {j \in \operatorname {endpos} (v)} j$，即 $u$ 第一次出现在 $v$ 最后一次出现前面。原因显然。这两个 $\min$ 和 $\max$ 是好求的。

但是我们还要刻画长度为 $k$ 这个限制。过程中只能经过满足 $k \le \operatorname {maxlen} (u)$ 的 $u$。至于为什么不限制 $k > \operatorname {maxlen} (fa _ u)$：假设 $k \le \operatorname {maxlen} (fa _ u)$，$fa _ u$ 必然是满足条件的点，而 $\operatorname {endpos} (u)$ 被 $\operatorname {endpos} (fa _ u)$ 完全包含，在已有 $fa _ u$ 的基础上加入 $u$ 显然不会影响答案。

于是可以将询问离线，用一个类似双指针的东西，按照 $\operatorname {maxlen}$ 倒序加点，按照 $k$ 倒序添加询问。就能保证用到的点全都满足长度限制。

问题转化成了，有 $O(n)$ 个有序二元组 $(a _ i, b _ i)$ 满足 $1 \le a _ i \le b _ i \le n$，每次可以选择一个满足 $b _ j \ge a _ i$ 的 $j$，（贪心地考虑，还要选 $a _ j$ 最小的），然后从 $i$ 跳到 $j$。动态添加二元组，查询从一个二元组到另一个二元组最少要跳多少次。

~~然后就不会了。~~

考虑[弹飞绵羊](https://www.luogu.com.cn/problem/P3203)的分块。将二元组挂在 $a _ i$ 上。对每个单点，维护：只跳一步最小能跳到哪；第一次跳出块到达的位置，以及跳的次数。

考虑查询。不断使用“第一次跳出块到达的位置”往前跳，直到跳到终点所在块，设块长为 $B$，复杂度 $O(\frac {n} {B})$；然后使用“只跳一步最小能跳到哪”，直到跳过终点，复杂度 $O(B)$。

考虑修改。相当于对 $[a _ i, b _ i]$ 区间与 $a _ i$ 取 $\min$。散块直接暴力修改那三个信息，复杂度 $O(B)$；整块打标记，复杂度 $O(\frac {n} {B})$。

取 $B = n ^ {0. 5}$ 可以将时间复杂度平衡到 $O(n ^ {1.5})$。虽然 $n \le 10 ^ 6$，但是发现常数较小并且时限 4s 所以~~听群友说~~是能过的。

代码有空再补上。

---

## 作者：山田リョウ (赞：0)

场上优化建图以为只能建虚点所以只会根号……

先特判掉 $s[l_1,r_1]=s[l_2,r_2]$ 或 $s[r_1-k+1,r_1]=s[l_2,l_2+k-1]$ 的情况。

不难发现你倒数第二步前都会跳到长为 $k$ 后缀的第一次出现位置尽可能靠前的地方，且这样情况下跳出一步到哪里是确定的，且由于跳一步坐标一定变小故构成森林，所以你只需要维护出树然后链上二分即可。

对 $k$ 降序排序，先写个 SA 维护子串合并情况（相等就合并），每次会把一个区间的点的父亲改为 $u$，考虑差分优化建图，把每次操作的区间 $[l,r]$ 缩起来，其中对于所有 $i\in (l,r]$ 将 $i$ 向 $i-1$ 连一条边权为 $0$ 的边，再使 $l$ 向 $u$ 连一条边权为 $1$ 的边，每次最多拆分 $O(1)$ 个原有区间，所以只会进行 $O(n)$ 次连边和删边，故 LCT 维护即可，不难发现你其实不需要写 makeroot 故代码难度显著降低。

记得二分时要保证完整跳完最后一个 $0$ 链。

综上，时间复杂度为 $O((n+q)\log n)$，不难通过。

[submission.](https://www.luogu.com.cn/record/229121794)

---

## 作者：R_shuffle (赞：0)

不妨先考虑 $k$ 一定的时候的做法。

考虑所有长度为 $k$ 的子串，不妨设一个串为 $S$，其 endpos 集合为 $endpos_S$。由于对中间台词的长度没有限制，不难发现 $endpos_S$ 中真正有用的是最小值和最大值，不妨把这两个值记作 $L_S,R_S$。因为我们只关注一个字符串长度为 $k$ 的前缀和后缀。如果我们想要一个 $S$ 为后缀的字符串，且它的前缀是给定的某个串，那么在比最大值小的位置能取到这种字符串，在最大值处也能取到。反之也是同理。那么考虑怎么走才能从起始的串到最后的串。

有一个比较显然的方法，就是先通过某种方式到达 $l_2$ 的前面，然后直接从那个位置到 $l_2+k-1$ 再跳一步，然后就可以直接到 $l_2$ 了。所以现在需要往前跳。即想要让下一个字符串的左端点尽可能的往前。同时，由于往前跳是不劣的，所以需要尽可能的向前，不妨假设当前所在的字符串为 $S$，下一个转移的串是 $T$，那么对于 $T$ 的要求就是满足 $R_T\geq L_S$ 的所有 $T$ 中 $L_T$ 最小的。那么这样每个位置能跳到的位置就是确定的了，不妨记作 $pre_i$，由于 $pre_i\leq i$，所以 $pre_i$可以构造一个森林。

不难发现由于数据很水，所以直接用暴力跳即可。

然后考虑 $k$ 不一定，这样就非常的麻烦，不妨考虑 $k$ 变小的过程。显然 $k$ 在变小的时候 endpos 集合会不断变大，但是由于新的 endpos 集合包含了原来的，所以实际上 $pre_i$ 是单调不增的。而且由于一个 endpos 集合在变大后，对所有的 $pre_i$ 的影响相当于对一个区间取 $\min$，这个是很好维护的，虽然数据范围很大，但是不妨就直接分块，然后对散块直接改，整块打标记。也可以过去。

然后注意特判一下 corner case。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
inline int read()
{
    int re=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
    while( isdigit(ch)) re=(re<<3)+(re<<1)+(ch^48),ch=getchar();
    return re*f;
}
const int N=2e6+5,inf=1e9;
char str[N];
int n;
int len[N],fa[25][N],ch[N][26],tot=1,lst=1;
int L[N],R[N],pos[N];
vector<int>gra[N];
vector<pair<int,int> >V[N];
void insert(int u,int id)
{
    int*fa=::fa[0];
    int p=lst,np=lst=++tot;
    len[np]=len[p]+1;
    L[np]=R[np]=id;
    pos[id]=np;
    for(;p&&!ch[p][u];p=fa[p]) ch[p][u]=np;
    if(!p) fa[np]=1;
    else
    {
        int q=ch[p][u];
        if(len[q]==len[p]+1) fa[np]=q;
        else
        {
            int nq=++tot;
            memcpy(ch[nq],ch[q],sizeof ch[nq]);
            len[nq]=len[p]+1;
            fa[nq]=fa[q],fa[q]=fa[np]=nq;
            for(;p&&ch[p][u]==q;p=fa[p]) ch[p][u]=nq;
        }
    }
}
void dfs(int u)
{
    if(!L[u]) L[u]=inf,R[u]=0;
    for(auto v:gra[u])
    {
        dfs(v);
        L[u]=min(L[u],L[v]);
        R[u]=max(R[u],R[v]);
    }
    V[len[u]].emplace_back(L[u],R[u]);
}
int get_k(int u,int k)
{
    u=pos[u];
    for(int i=20;~i;i--)
    {
        if(fa[i][u]&&len[fa[i][u]]>=k) u=fa[i][u];
    }
    return u;
}
struct node
{
    int pend,sbeg,id;
    node(int P,int S,int I)
    {
        pend=P,sbeg=S,id=I;
    }
};
vector<node>que[N];
int ans[N];
int tag[N],f[N],kf[N],cnt[N];
const int B=500;
void rebuild(int num)
{
    int l=num*B+1,r=min(num*B+B,n);
    for(int i=l;i<=r;i++)
    {
        if(f[i]<l) kf[i]=f[i],cnt[i]=1;
        else if(f[i]==i) kf[i]=i,cnt[i]=0;
        else kf[i]=kf[f[i]],cnt[i]=cnt[f[i]]+1;
    }
}
void modify(int l,int r)
{
    if(l>r) return ;
    int lbl=(l-1)/B,rbl=(r-1)/B;
    if(lbl==rbl)
    {
        if(tag[lbl]<l) return ;
        for(int i=r;i>=l;i--)
        {
            f[i]=min(f[i],l);
            if(tag[lbl]!=inf&&f[i]<l) return ;
        }
        rebuild(lbl);
        return ;
    }
    for(int i=l;i<=lbl*B+B;i++) f[i]=min(f[i],l);
    for(int i=rbl*B+1;i<=r;i++) f[i]=min(f[i],l);
    if(tag[lbl]==inf) rebuild(lbl);
    if(tag[rbl]==inf) rebuild(rbl);
    for(int i=lbl+1;i<rbl;i++) tag[i]=min(tag[i],l);
}
int jump(int u,int v)
{
    int re=0;
    while(u>v)
    {
        if(min(f[u],tag[(u-1)/B])==u) return -1;
        u=min(tag[(u-1)/B],f[u]);
        re++;
    }
    return re;
}
int go(int u,int v)
{
    int re=0;
    while(u>v)
    {
        if(tag[(u-1)/B]!=inf) u=min(tag[(u-1)/B],f[u]),re++;
        else if(kf[u]>=v&&kf[u]!=u) re+=cnt[u],u=kf[u];
        else
        {
            int ree=jump(u,v);
            if(!~ree) return -1;
            return re+ree;
        }
    }
    return re;
}
signed main(){
#if __MY_TEST__
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    cin>>str+1;
    n=strlen(str+1);
    for(int i=1;i<=n;i++) insert(str[i]-'a',i);
    for(int i=2;i<=tot;i++) gra[fa[0][i]].push_back(i);
    for(int j=1;j<=20;j++) for(int i=1;i<=tot;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
    dfs(1);
    int q=read();
    for(int i=1;i<=q;i++)
    {
        int l1=read(),r1=read(),l2=read(),r2=read(),k=read();
        if(r1-l1==r2-l2&&get_k(r1,r1-l1+1)==get_k(r2,r2-l2+1)) ans[i]=1;
        else que[k].emplace_back(r1,l2+k-1,i);
    }
    for(int i=0;i<=n;i++) tag[i]=inf,f[i]=kf[i]=i;
    for(int len=n;len;len--)
    {
        for(auto x:V[len]) modify(x.first,x.second);
        for(auto x:que[len])
        {
            int pl=get_k(x.pend,len),pr=get_k(x.sbeg,len);
            if(pl==pr)
            {
                ans[x.id]=2;
                continue;
            }
            int bl=L[pl],br=R[pr];
            if(bl<=br)
            {
                ans[x.id]=3;
                continue;
            }
            int re=go(bl,br);
            if(!~re) ans[x.id]=-1;
            else ans[x.id]=re+3;
        }
    }
    for(int i=1;i<=q;i++) cout<<ans[i]<<'\n';
}
```
然后加一点分块部分的解释，首先肯定要维护 $pre_i$，然后在维护了 $pre_i$ 的基础上把块内的路径压缩，维护了每个点在块内的最远的祖先以及步数。同时由于块内统一标记的存在，所以上面的压缩技巧只有在块内没有标记的时候才能用，不然是很容易出问题的。

---


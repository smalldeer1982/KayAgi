# 「TPOI-5D」「僕は…」

## 题目背景

![](https://pic.kts.g.mi.com/e5e19c35ec3d824c4a6b5f7d094de6fd7605802814182560045.png)

## 题目描述

由于你让我看到了世界的绮丽，所以需要解决一道题目。

定义 $f(a,b)$ 为字符串 $a$ 在 $b$ 中出现的次数。

给出 $n$ 个字符串 $s_1,\dots,s_n$，$q$ 次询问 $l,r,L,R$，求：

$$\sum\limits_{i=l}^r\sum\limits_{j=L}^Rf(s_i,s_j)$$

## 说明/提示

记 $m=\sum\limits_{i=1}^n|s_i|$。

| $\text{Subtask}$ | $n,m,q\le$ |特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10^2$ | 无 | $5$ | 
| $2$ | $2\times 10^5$ | 所有字符串均为 `a` | ^ |
| $3$ | $10^4$ | 无 | $10$ |
| $4$ | $2\times 10^5$ | 所有字符串的长度不超过 $10$ | ^ |
| $5$ | ^ | $n\le 10^2$ | ^ |
| $6$ | $5\times 10^4$ | 无 | $20$ |
| $7$ | $2\times 10^5$ | ^ | $40$ |



对于 $100\%$ 的数据，满足 $1\le n,m,q\le 2\times 10^5$，$1\le l\le r\le n$，$1\le L\le R\le n$。

## 样例 #1

### 输入

```
5 5
a
ab
abab
ababab
b
1 5 4 5
3 5 4 5
1 5 2 4
1 5 3 5
2 4 3 4
```

### 输出

```
13
7
22
20
9
```

# 题解

## 作者：chenxumin1017 (赞：9)

## 前言

一周前学了 AC 自动机，昨天赛时看到了这题，很快就会了但一场都没调出来，写篇题解纪念一下。

## 做法

前置：AC 自动机，[CF547E](https://www.luogu.com.cn/problem/CF547E) 的单 $\log$ 做法。

观察到 $1 \le n, m, q \le 2 \times 10^{5}$ 和时限 $1.5$ 秒，考虑 $n \sqrt{n}$ 做法。

对 $[l,r]$ 进行分块。

### 整块

预处理出第 $i$ 个块的串在 $s_{1},s_{2},\cdots, s_{j}$ 中的出现次数，询问时用前缀相减。
具体的，对所有在第 $i$ 个块的串在 AC 自动机的 $fail$ 树的子树内全部加一，最后每个点的点权就为有多少个在第 $i$ 个块中的串为它的后缀，再对于每个串在 AC 自动机上跑一下就可以了。

由于空间只有 $128\text{MB}$，我们无法预处理，只能要离线并改为求出第 $1,2,\cdots,i$ 个块的串在 $s_{1},s_{2},\cdots, s_{j}$ 中的出现次数，询问时再次前缀和。

### 散块

直接使用 [CF547E](https://www.luogu.com.cn/problem/CF547E) 的单 $\log$ 做法，可以做到 $\mathcal{O}(N \sqrt{n \log n})$ 无法通过。
发现只有 $\mathcal{O}(n)$ 次修改但有 $\mathcal{O}(n \sqrt{n})$ 次查询使用 $\mathcal{O}(\sqrt{n}) - \mathcal{O}(1)$ 分块，可以做到 $\mathcal{O}(n \sqrt{n})$，可以通过。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, B = 250;
int n, q, id[N], dcnt = 1, Dcnt, dfn[N], sum[N], viss[N];
int v1[N], v2[N / B + 5];
long long c[N], summ[N], cntt, sum2[N], ans[N];
string s[N];
vector<int> v[N];
struct node{
	int r, x, y, id;
};
struct NODE{
	int r, l2, r2, y, id;
}vis[N * 4];
struct Node{
	int son[26], fail;
}tr[N];
vector<node> vis2[N];
// AC 自动机
int insert(string s){
	int now = 1;
	for(char i : s){
		if(!tr[now].son[i - 'a'])tr[now].son[i - 'a'] = ++dcnt;
		now = tr[now].son[i - 'a'];
	}
	return now;
}
void getfail(){
	queue<int> que;
	que.push(1);
	while(!que.empty()){
		int x = que.front();
		que.pop();
		if(tr[x].fail)v[tr[x].fail].push_back(x);
		for(int i = 0; i < 26; i++){
			if(tr[x].son[i]){
				tr[tr[x].son[i]].fail = (x == 1 ? 1 : tr[tr[x].fail].son[i]);
				que.push(tr[x].son[i]);
			}else tr[x].son[i] = (x == 1 ? 1 : tr[tr[x].fail].son[i]);
		}
	}
}
void dfs(int x){
	dfn[x] = ++Dcnt;
	viss[dfn[x]] = x;
	sum[x] = 1;
	for(int i : v[x]){
		dfs(i);
		sum[x] += sum[i];
	}
}
// 分块
void modify(int x){
	for(; x <= Dcnt && x % B != 1; x++)v1[x]++;
	if(x <= Dcnt){
		for(int i = (x - 1) / B + 1; i <= Dcnt / B + 1; i++)v2[i]++;
	}
}
inline int query(int x){
	return v2[(x - 1) / B + 1] + v1[x];
}
bool cmp(NODE i, NODE j){
	return i.r < j.r;
}
signed  main(){
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> q;
	for(int i = 1; i <= n; i++){
		cin >> s[i];
		id[i] = insert(s[i]);
	}
	getfail();
	dfs(1);
	for(int i = 1, l, r, L, R; i <= q; i++){
		cin >> l >> r >> L >> R;
		if(l % B != 1){
			vis[++cntt] = {R, l, min(r, ((l - 1) / B + 1) * B), 1, i};
			vis[++cntt] = {L - 1, l, min(r, ((l - 1) / B + 1) * B), -1, i};
			l = min(r + 1, ((l - 1) / B + 1) * B + 1);
		}
		if(r % B && l <= r){
			vis[++cntt] = {R, max(l, (r - 1) / B * B + 1), r, 1, i};
			vis[++cntt] = {L - 1, max(l, (r - 1) / B * B + 1), r, -1, i};
			r = max(l + 1, (r - 1) / B * B);
		}
		if(l <= r){
			vis2[r / B].push_back({L, R, 1, i});
		  vis2[l / B].push_back({L, R, -1, i});
		}
	}
  // 整块
	for(int i = 1; i <= n / B + 1; i++){
		fill(&c[0], &c[Dcnt] + 1, 0);
		for(int j = (i - 1) * B + 1; j <= min(n, i * B); j++){
			c[dfn[id[j]]]++;
			c[dfn[id[j]] + sum[id[j]]]--;
		}
		for(int i = 1; i <= Dcnt; i++)c[i] += c[i - 1];
		for(int i = 1; i <= n; i++){
			int now = 1; 
			summ[i] = summ[i - 1];
			for(char j : s[i]){
				now = tr[now].son[j - 'a'];
				summ[i] += c[dfn[now]];
			}
			sum2[i] += summ[i];
		}
		for(node j : vis2[i]){
			ans[j.id] += (sum2[j.x] - sum2[j.r - 1]) * j.y;
		}
	}
	stable_sort(vis + 1, vis + cntt + 1, cmp);
	int r = 0;
  // 散块
	for(int i = 1; i <= cntt; i++){
		while(r < vis[i].r){
			r++;
			int now = 1;
			for(char j : s[r]){
				now = tr[now].son[j - 'a'];
				modify(dfn[now]);
			}
		}
		for(int j = vis[i].l2; j <= vis[i].r2; j++){
			ans[vis[i].id] += (query(dfn[id[j]] + sum[id[j]] - 1) - query(dfn[id[j]] - 1)) * vis[i].y;
		}
	}
	for(int i = 1; i <= q; i++)cout << ans[i] << '\n';
	return 0;
}
``````

---

## 作者：Iniaugoty (赞：4)

SAM 做法。

考虑如何刻画匹配这个东西。$s$ 在 $t$ 中出现了 $k$ 次，也就是，$t$ 有恰好 $k$ 个前缀 $p_1, p_2, \dots, p_k$，使得 $s$ 是 $p_i$ 的后缀。

考虑如何刻画前缀的后缀这个东西。对 $s, t$ 建立广义 SAM，设 $s$ 对应的结点是 $u$，$p_i$ 对应节点是 $v_i$，若 $s$ 是 $p_i$ 的后缀，说明在 parent-tree 上 $u$ 是 $v_i$ 的祖先结点。

于是把首先所有串丢进一个广义 SAM 里。

拆一下贡献。把每个串的每个前缀挂到 parent-tree 的对应点上（需要注意的是，一个前缀对应一个点，但一个点可能对应多个前缀），考虑某个串 $s_i$ 对应结点 $u$，会使它产生贡献的点都在其子树中，$\sum_{L \le j \le R} f(s_i, s_j)$ 这个东西也就是 $u$ 子树中，在 $[L, R]$ 之间的点数量。

这样 parent-tree 上只有恰好 $m$ 个点是有用的（如果一个结点对应了多个串，我们认为它是多个点），把它们拍平到 dfs 序上，则子树变成了区间。

对和式的第一维差分、扫描线，问题转化成了，有一个序列，每个数字有初始为 $0$ 的权值，$O(n)$ 次区间加权值，$O(q)$ 次查询全局 $[L, R]$ 内的数的权值之和。（简单理解为在 $m \times n$ 的区域内有 $m$ 个散点，矩形加、矩形求和。）

考虑 KDT。发现常数过大且难以卡常，寄了。

考虑以 $\sqrt m$ 为块长分块。把每个数的权值拆成整块修改和散块修改两部分。

- 散块部分形如 $O(n \sqrt m)$ 次单点修改和 $O(q)$ 次区间求和，在 $[1, n]$ 的值域上操作。考虑一个 $O(1) - O(\sqrt n)$ 的值域分块即可。

- 整块部分块内每个数权值相同，修改直接打 tag，查询形如 $O(q \sqrt m)$ 次静态询问区间内有多少 $[L, R]$ 之间的数。对每个块暴力预处理一个值域上的前缀和即可单次 $O(1)$。

以上部分相当平凡，本题难点在于卡常。

首先每个块一个值域上的前缀和，空间 $O(n \sqrt m)$ 是要爆的，只能再离线下来逐块处理。

然后由于逐块处理常数巨大，疯快地把块长调大一些，减小块的数量，我最后取到了 $3 \times 2 ^ {10}$。

这样散块处理的地方又会变慢。但这里要做的事情没有上面那么复杂，形式比较简洁，手动循环展开力大砖飞。

需要注意的是序列分块和值域分块用不同的块长，因为序列是 $O(m)$ 的而值域是 $O(n)$ 的，前者块长大一些比较快，但后者还是严格 $\sqrt n$ 最牛。

还需要注意的是离线存询问的时候，不要用 vector 存，也不要手写链表存，就使用数组，跑得飞快。

这是[通过记录](/record/230128312)。那个代码太丑了，放一个未经卡常的，能得 45 分。

应该还有很大的优化空间，但我水平不行卡不动了。

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for (int i = (a); i <= (b); ++i)
#define dF(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
typedef long long LL;
const int N = 4e5 + 5;
const int K = 638;

int B, n, m, q; string str; LL ans[N];

int cnt = 1, las, fa[N], len[N], c[N][26], p[N], buc[N];
void Insert(char s) {
  int it = s - 'a', p = las, w = c[p][it];
  if (w && len[p] + 1 == len[w]) return las = w, void();
  int u = ++cnt; len[las = u] = len[p] + 1;
  if (w) {
    F(i, 0, 25) c[u][i] = c[w][i];
    fa[u] = fa[w], fa[w] = u;
    while (c[p][it] == w) c[p][it] = u, p = fa[p];
    return ;
  }
  while (!c[p][it]) c[p][it] = u, p = fa[p];
  if (!p) return fa[u] = 1, las = u, void();
  int q = c[p][it];
  if (len[p] + 1 == len[q]) return fa[u] = q, void();
  int v = ++cnt; F(i, 0, 25) c[v][i] = c[q][i];
  len[v] = len[p] + 1, fa[v] = fa[q], fa[q] = fa[u] = v;
  while (c[p][it] == q) c[p][it] = v, p = fa[p];
}
vector<int> id[N], e[N]; int node[N], siz[N], tot, dfn[N], a[N];
void Dfs(int u) {
  siz[u] = id[u].size(), dfn[u] = N;
  for (auto it : id[u])
    a[++tot] = it, dfn[u] = min(dfn[u], tot);
  for (auto v : e[u])
    Dfs(v), siz[u] += siz[v],
    dfn[u] = min(dfn[u], dfn[v]);
}

struct query { int l, r, k, id; } ;
vector<query> qu[N];
int bo[N], st[K], ed[K]; LL pre[K];
LL Sol(int l, int r) {
  LL res = 0; int ql = bo[l], qr = bo[r];
  if (ql == qr) F(i, l, r) res += buc[i];
  else {
    F(i, l, ed[ql]) res += buc[i];
    F(i, st[qr], r) res += buc[i];
    F(i, ql + 1, qr - 1) res += pre[i];
  }
  return res;
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> q;
  F(i, 1, n) {
    cin >> str, las = 1, m += str.size();
    for (auto ch : str) Insert(ch), id[las].push_back(i);
    node[i] = las;
  }
  B = sqrt(m);
  F(i, 1, cnt) ++buc[len[i]];
  F(i, 1, m) buc[i] += buc[i - 1];
  dF(i, cnt, 1) p[buc[len[i]]--] = i;
  dF(i, cnt, 1) e[fa[p[i]]].push_back(p[i]);
  Dfs(1);
  F(i, 1, q) {
    int l, r, L, R; cin >> l >> r >> L >> R;
    qu[r].push_back({L, R, 1, i});
    qu[l - 1].push_back({L, R, -1, i});
  }
  F(i, 1, m) bo[i] = (i - 1) / B + 1;
  F(i, 1, bo[m]) st[i] = ed[i - 1] + 1, ed[i] = ed[i - 1] + B;
  ed[bo[m]] = m;
  F(i, 1, bo[m]) {
    int tag = 0;
    F(j, 1, n) buc[j] = 0;
    F(j, st[i], ed[i]) ++buc[a[j]];
    F(j, 1, n) buc[j] += buc[j - 1];
    F(j, 1, n) {
      int u = node[j], ql = dfn[u], qr = dfn[u] + siz[u] - 1;
      if (ql < st[i] && ed[i] < qr) ++tag;
      for (auto [l, r, k, id] : qu[j]) ans[id] += k * tag * (buc[r] - buc[l - 1]);
    }
  }
  F(i, 1, n) buc[i] = 0;
  F(i, 1, n) {
    int u = node[i], ql = dfn[u], qr = ql + siz[u] - 1;
    if (bo[ql] == bo[qr]) F(j, ql, qr) ++buc[a[j]], ++pre[bo[a[j]]];
    else {
      F(j, ql, ed[bo[ql]]) ++buc[a[j]], ++pre[bo[a[j]]];
      F(j, st[bo[qr]], qr) ++buc[a[j]], ++pre[bo[a[j]]];
    }
    for (auto [l, r, k, id] : qu[i]) ans[id] += k * Sol(l, r);
  }
  F(i, 1, q) cout << ans[i] << "\n";
  return 0;
}
```

---

## 作者：lzyqwq (赞：4)

本文原本的标题是 `Mike is Mad, Duff and Friends.`，大家猜猜是什么意思。

> - 定义 $f(a,b)$ 为字符串 $a$ 在 $b$ 中出现的次数。
> - 给出 $n$ 个字符串 $s_1,\dots,s_n$，$q$ 次询问 $l,r,L,R$，求：
>    $$\sum\limits_{i=l}^r\sum\limits_{j=L}^Rf(s_i,s_j)$$
> - 字符串总长为 $m$，$n,m,q\le 2\times 10^5$。

首先 ACAM 和 SAM 选手不要骂我。将所有 $s_i$ 拼成大串 $S$ 进行后缀排序。对 $\text{height}$ 数组维护 ST 表。

可以对于每个 $s_i$ 求出排名区间 $[\text{ql}_i,\text{qr}_i]$ 表示其在这些排名的后缀中作为前缀出现。记排名为 $i$ 的后缀来源于编号为 $c_i$ 的字符串。考察用某个后缀的前缀刻画一次出现，那么对于 $s_i$，其在 $s_j$ 中出现的次数就是 $s_j$ 中排名位于 $[\text{ql}_i,\text{qr}_i]$ 的后缀数量，即 $f(s_i,s_j)=\sum\limits_{k=\text{ql}_i}^{\text{qr}_i}[c_k=j]$。

那么一次询问就是要求：

$$\sum\limits_{i=l}^r\sum\limits_{j=L}^R\sum\limits_{k=\text{ql}_i}^{\text{qr}_i}[c_k=j]$$

注意到可以合并后面两个和式，即：

$$\sum\limits_{i=l}^r\sum\limits_{k=\text{ql}_i}^{\text{qr}_i}[c_k\in [L,R]]$$

考虑以 $B=\mathcal{O}(\sqrt n)$ 为块长对字符串序列分块。

对于整块，离线逐块处理。记当前块编号为 $\text{id}$，范围为 $[\text{bl},\text{br}]$。考虑维护 $d_i$ 表示 $\sum\limits_{j=\text{bl}}^{\text{br}}\sum\limits_{k=\text{ql}_j}^{\text{qr}_j}[c_k=i]$。那么其对一个询问的贡献是 $\sum\limits_{i=L}^Rd_i$。考虑每个 $c_k$ 对 $d_i$ 的贡献，等价于求块中有多少区间包含了这个位置，二维数点即可。此时所有块一共有 $\mathcal{O}(n)$ 次修改，$\mathcal{O}(m\sqrt n)$ 次询问。使用 $\mathcal{O}(\sqrt m)-\mathcal{O}(1)$ 的分块维护即可。当然也可以考虑区间对位置的贡献，相当于每次区间加 $1$，差分维护即可。每个块求完 $d_i$ 后对其维护前缀和即可 $\mathcal{O}(1)$ 计算对询问的贡献。这里也可以考虑将一个询问包含的整块区间差分成两个前缀，逐块处理的时候累加每一块的 $d_i$ 的前缀和，在两个前缀的右端点统计贡献。这样就不需要在每个整块都遍历一次询问，而是一个询问只在 $\mathcal{O}(1)$ 的整块被遍历。实测效率更优。

对于散块，相当于 $\mathcal{O}(q\sqrt n)$ 次查询一个区间中值域在 $[L,R]$ 内的元素个数。二维数点即可。此时有 $\mathcal{O}(m)$ 次修改和 $\mathcal{O}(q\sqrt n)$ 次询问，使用 $\mathcal{O}(\sqrt m)-\mathcal{O}(1)$ 的分块维护。

注意这个时候我们不能存下所有询问不然空间是 $\mathcal{O}(q\sqrt n)$。接下来有两种处理方式：

- 按 $l,r$ 这一维扫描线，用 $\mathcal{O}(\sqrt m)-\mathcal{O}(1)$ 的分块维护每个值的出现次数。将 $n$ 个排名区间差分成两个前缀，考虑其对每个询问的贡献。将询问挂在散块上，每个前缀查询遍历其所属区间所在散块的询问，将包含她的询问加上对应的贡献。
- 按 $L,R$ 这一维扫描线，用 $\mathcal{O}(\sqrt m)-\mathcal{O}(1)$ 的分块维护每个下标上的值是否 $\le $ 当前扫描的值。将询问按 $L,R$ 这一维差分成两个前缀，把散块区间挂在前缀上。扫到每个前缀时遍历挂在她上的散块，将散块中每个区间的贡献加给对应的询问。

实测后者效率更优。

认为 $n,m,q$ 同阶（实际上 $m\ge n$），时间复杂度为 $\mathcal{O}(m\sqrt m)$，空间复杂度为 $\mathcal{O}(m\log m)$。后者瓶颈在于 ST 表，如果换成线段树二分维护可以做到线性，但是没必要。

---

## 作者：伊地知虹夏 (赞：2)

ACAM 取之！

首先差分成双前缀信息。具体地，记 $S(p,q) = \sum\limits_{i=1}^{p}\sum\limits_{j=1}^{q}{f(s_i,s_j)}$，那么有 $\sum\limits_{i=l}^{r}\sum\limits_{j=L}^{R}{f(s_i,s_j)} = S(r,R) - S(l-1, R) - S(r,L-1) + S(l-1, L-1)$。

多串匹配问题考虑建出所有串 ACAM。

考虑 $S(p,q)$ 怎么求，对 $q$ 扫描线，需要维护一个数据结构 $\mathcal D$ 支持：

- fail 树上链加法；
- 求前缀和。

现在就变成了一个树上数据结构问题，于是可以丢掉字符串了。

对序列 $s$ 进行分块，预处理贡献数组 $F(B,i)$ 表示点 $i$ 增加 $1$ 后块 $B$ 的和会增加 $F(B,i)$，这个容易做到 $\mathcal O(n\sqrt n)$。

整块的答案维护好了，考虑怎么求散块答案。这等价于维护一个单点加子树和的数据结构，把树拍成 dfn 序后用 $\mathcal O(\sqrt n) - \mathcal O(1)$ 的分块维护即可。时空复杂度 $\mathcal O(n \sqrt n)$。

到这里你会发现 MLE 了，原因是 $F$ 数组太占空间了，但是逐块处理又太慢了，怎么办呢？

天才的考虑每 $P$ 块一起处理，取 $P = 90$ 即可通过。代码就不给了，想要的可以找我。

---

## 作者：Mobius127 (赞：2)

[link](https://www.luogu.com.cn/problem/P13665)

为表意清晰，记 $P(t)$ 表示某串 $t$ 在 $s_n$ 的 ACAM 对应状态结点。

标解用很标准化的方式将所求转化为了常规数据结构计数问题，确实巧妙，不过美中不足的是：

::::info[点此一探究竟]
~~我不会 SA~~
::::

我们从 [CF547E](https://www.luogu.com.cn/problem/CF547E) 的做法入手，在此题中，我们可以利用 ACAM 进行简单计算对某个 $i$ 得到 $\sum_{j=L}^R f(s_i, s_j)$。


扫描线依次重新遍历每个 $s_j$，对于 $s_j$ 的某个前缀 $t$，若询问的 $s_i$ 为其后缀，则 $P(t)$ 必然是 $\text{Fail}$ 树上 $P(s_i)$ 的的儿子（相当于 $t$ 一直跳 $\text{Fail}$ 链能变为 $s_i$）。每次询问统计 $P(s_i)$ 子树中所有的 $s_{[1, j]}$ 前缀数量，差分即可得到答案。


简化求 $g(i, L, R)=\sum_{j=L}^R f(s_i, s_j)$ 的过程：给定一颗树（$\text{Fail}$ 树），有 单点加操作 以及 子树和询问。

对于实际所求 $\sum_{i=l}^{r} g(i, L, R)$，发现相当于上述过程的“子树和”变为“多个子树和的和”。

单次询问多个子树和涉及的节点已经是 $O(m^2)$ 级别，考虑将单点加视为路径加，子树和变为单点值进行降次。树剖后再次将树上问题链化，那么询问变为：

>给定置换 $p$，维护初始全 0 序列 $a$，$O(m\log m)$ 次 $a_{[l, r]}$ 区间加 1，$O(m)$ 次查询 $\sum_{i=l}^{r} a_{p_i}$。

通过对 $a, p$ 分块，可以做到查询和询问都是 $O(\sqrt{n})$。

::::success[点击收起]{open}
对 $a,p$ 都分块。对 $a$ 正常维护值，对 $p$ 则只维护整块 $\sum a_{p}$ 的值。

:::info[区间加 时]{open}
对于 $a$，整块打 $tag$，散点暴力修改。

对于 $p$，容易预处理 $pre_{j, i}$ 表示 对 $a_{[1, j]}$ 区间 ＋1 会对 $p$ 第 $i$ 个块产生多少的贡献。那么遍历所有整块 $i$，$sum_i+pre_{r, i}-pre_{l-1, i} \to sum_i$ 即可做到空间 $O(n\sqrt{n})$
:::

:::info[询问 时]{open}
询问 $[l, r]$ 可分为在 $p$ 上的若干整块和散点：整块直接用 $p$ 分块维护的 $sum$ 值得到；散点则直接逐个枚举，利用 $a$ 的分块 $O(1)$ 计算。
:::
::::

唯一瑕疵在于空间的开销太大，考虑进一步优化区间加。

设 $f_{i, j}$ 表示 $a$ 的第 $i$ 个块区间 +1 时，对第 $j$ 个块的贡献，同样容易预处理。

那么区间加时，我们对 $a$ 分整块和散块考虑它们对 $p$ 所有整块的贡献。

$a$ 的第 $x$ 到第 $y$ 个整块对于 $p$ 的某块 $i$ 的贡献是 $\sum_{j=x}^y f_{j, i}$，故处理 $f$ 的前缀和，对于 $p$ 的每一个散块可以 $O(1)$ 修改。

对于 $a$ 的 $O(\sqrt{n})$ 个散点，注意到一个散点会对应 $p$ 的多个位置修改，导致时间复杂度不对，那么对 $p$ 的值离散化后即可做到一一对应。

```cpp
for(int i=1; i<=n; ++i) p[i]=dfn[pos[i]], w[p[i]].pb(i);
for(int i=1; i<=m; ++i){
  pl[i]=pr[i-1], pr[i]=pl[i]+w[i].size();
  for(int j=pl[i]; j<pr[i]; ++j) p[w[i][j-pl[i]]]=j+1, rev[j+1]=w[i][j-pl[i]];
}
```

那么就做到了空间线性，时间复杂度 $O(q\sqrt{n}+m\sqrt{n}\log m)$，由于 $n, m$ 一定程度上有反比关系，所以跑的巨快。

```cpp
const int N=2e5+5;
int n, q, m=1, pos[N], fa[N], ch[N][26], fail[N], siz[N], son[N], dfn[N], top[N];vi G[N];
void dfs(int x){siz[x]=1;for(auto v:G[x]) dfs(v), siz[x]+=siz[v], son[x]=(siz[v]>siz[son[x]])?v:son[x];}
void dfs(int x, int rt){dfn[x]=++dfn[0], top[x]=rt;if(son[x]) dfs(son[x], rt);for(auto v:G[x]) if(!dfn[v]) dfs(v, v);}
struct qry{int op, l, r, id;};vector <qry> qr[N];ll ans[N];
namespace Block{
	const int M=450, B=450;
	int b, c, p[N], pp[N], pl[N], pr[N], rev[N], id[N], lnk[N], L[B], R[B], f[B][B];
	ll a[N], sum[B], tag[B];vi w[N];
	void init(){
		int b=sqrt(n);
		for(int i=1; i<=n; ++i) p[i]=dfn[pos[i]], w[p[i]].pb(i);
		for(int i=1; i<=m; ++i){
			pl[i]=pr[i-1], pr[i]=pl[i]+w[i].size();
			for(int j=pl[i]; j<pr[i]; ++j) p[w[i][j-pl[i]]]=j+1, rev[j+1]=w[i][j-pl[i]];
		}
		b=sqrt(n), c=(n+b-1)/b;
		for(int i=1; i<=c; ++i){
			L[i]=(i-1)*b+1, R[i]=min(n, L[i]+b-1);
			for(int j=L[i]; j<=R[i]; ++j) id[j]=i;
		}
		for(int i=1; i<=c; ++i){
			for(int x=L[i]; x<=R[i]; ++x) lnk[x]=id[rev[x]], pp[x]=id[p[x]], ++sum[lnk[x]];
			for(int j=1; j<=c; ++j) f[i][j]=sum[j];
		}
		for(int i=1; i<=c; ++i) sum[i]=0;
	}
	void add(int l, int r){
		l=pl[l]+1, r=pr[r];if(l>r) return ;
		int lp=id[l], rp=id[r];
		if(lp==rp) for(int i=l; i<=r; ++i) ++a[i], ++sum[lnk[i]];
		else{
			for(int i=1; i<=c; ++i) sum[i]+=f[rp-1][i]-f[lp][i];
			for(int i=l; i<=R[lp]; ++i) ++a[i], ++sum[lnk[i]];
			for(int i=L[rp]; i<=r; ++i) ++a[i], ++sum[lnk[i]];
			for(int i=lp+1; i<rp; ++i) ++tag[i];
		}
	}
	void ADD(int x){while(x) add(dfn[top[x]], dfn[x]), x=fail[top[x]];}
	ll query(int l, int r){
		int lp=id[l], rp=id[r];ll res=0;
		if(lp==rp) for(int i=l; i<=r; ++i) res+=a[p[i]]+tag[pp[i]];
		else{
			for(int i=l; i<=R[lp]; ++i) res+=a[p[i]]+tag[pp[i]];
			for(int i=L[rp]; i<=r; ++i) res+=a[p[i]]+tag[pp[i]];
			for(int i=lp+1; i<rp; ++i) res+=sum[i];
		}return res;
	}
}
signed main(){
	n=read(), q=read();
	for(int i=0; i<=25; i++) ch[0][i]=1, ch[1][i]=0;
	for(int i=1; i<=n; ++i){
		int u=1, t;char c=getchar();while(c<'a'||c>'z') c=getchar();
		for(; 'a'<=c&&c<='z'; c=getchar()){
			t=c-'a';
			if(!ch[u][t]) ch[u][t]=++m, fa[m]=u;
			u=ch[u][t];
		} 
		pos[i]=u;
	}
	queue <int> Q;Q.push(1);fail[1]=0;
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int i=0; i<=25; ++i) 
			if(!ch[u][i]) ch[u][i]=ch[fail[u]][i];
			else Q.push(ch[u][i]), fail[ch[u][i]]=ch[fail[u]][i];
	}
	for(int i=2; i<=m; ++i) G[fail[i]].pb(i);dfs(1);dfs(1, 1);
	for(int i=1; i<=q; ++i){
		int l=read(), r=read(), L=read(), R=read();
		if(L>R) continue;
		qr[R].pb((qry){1, l, r, i});
		qr[L-1].pb((qry){-1, l, r, i});
	}
	Block :: init();
	for(int i=1; i<=n; ++i){
		for(int p=pos[i]; p; p=fa[p]) Block :: ADD(p);
		for(auto [op, l, r, id]:qr[i]) ans[id]+=Block :: query(l, r)*op;
	}
	for(int i=1; i<=q; ++i) printf("%lld\n", ans[i]);
	return 0;
} 
```

另外，若不做 点-子树 到 路径-单点 的转化，不做树剖，将子树和看成 dfs 序的前缀和的差分，可以做到没有 $\log m$，但由于多一次差分处理可能会导致常数翻倍，以及修改会顶满（因为此时点变为完整的后缀加），反而容易 T。

---


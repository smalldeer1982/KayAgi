# 区间 LIS

## 题目描述

给定 $1\sim n$ 的排列 $p$，$q$ 次询问，每次查询区间 $[l,r]$ 内的最长上升子序列长度。

## 说明/提示

| 子任务编号 | $n$ | $q$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10^3$ | $10^3$ | $20$ |
| $2$ | $10^3$ | $10^5$ | $30$ |
| $3$ | $10^5$ | $10^5$ | $50$ |

对于所有数据，$1\leq n,q\leq10^5$，$1\leq l\leq r\leq n$。

## 样例 #1

### 输入

```
5 3
1 5 3 4 2
1 5
1 3
3 5```

### 输出

```
3
2
2```

## 样例 #2

### 输入

```
10 10
4 8 1 10 7 5 2 6 3 9
1 10
1 4
1 5
5 10
3 9
3 10
3 10
5 8
4 5
1 2```

### 输出

```
4
3
3
3
3
4
4
2
1
2```

# 题解

## 作者：lalaouye (赞：10)

好题。

LIS 有直接 dp 的做法，但是这个东西感觉做不了，于是这里有个很厉害的刻画方式。

维护一个集合 $S$，从 $1$ 到 $n$ 一次加入 $a_i$，找到第一个大于它的数（大于它的最小的数）删除，如果没有则不删，然后加入它，最后答案就是集合大小。

这个看起来非常不对，就像自己看错了一样。但是手玩一下发现答案对上了，让我们来试着分析一下它。以下是分析过程，如果想直接看分析出来的结论可以跳过。

首先从贪心意义上讲，找到第一个大于它的数删除是对的，因为当前加入的数在相同大小的 LIS 中它作为头部是比第一个大于它的数优的，那要是还有个更小的数介于两者之间导致第一个大于它的数作为头部的 LIS 更长怎么办？我们仔细想想发现并不会存在这种情况，因为这与我们的策略冲突。

那加入的数有没有机会再删别的数呢？没有机会，对于更大的数，它代表的 LIS 也一定长于当前加入的数代表的 LIS，代表就是作为头部的意思。这也是稍微分析就能得出的，但是我们依然不知道该算法整体为何是对的。

但是灵光乍现，我们发现集合中每个数代表的 LIS 长度都不同，进一步的，他们的长度分别是 $1,\cdots,|S|$，再进一步我们发现其中最小的数代表 $1$，次小的数代表 $2$......于是一切都解释得通了！它本质上是个依据单调性优化 dp 的过程，能刻画出这种策略的人真不一般！

然后关于本题这么做，我们考虑扫描线，扫到 $i$ 时，显然我们并不能直接对每个集合进行维护，我们设 $S_{l,r}$ 表示区间 $[l,r]$ 执行该算法的最终集合，我们发现对于固定的 $r$ 关于 $l$ 有类似单调性的性质，我们发现 $S_{j,i}$ 与 $S_{j+1,i}$ 的大小差距不大于 $1$，且 $S_{j+1,i}$ 是 $S_{j,i}$ 的一个子序列，这意味着每个元素的出现集合是一个前缀，我们扫到 $i$ 时维护每个元素 $x$ 的前缀 $b_x$， 表示其位置，我们考虑加入 $x$ 带来的改变，对于第一个大于 $x$ 的元素一点机会都没有啊，直接寄了，其前缀变为 $0$。而对于后面的数以此类推，我们发现改变的位置可以用一个序列 $c$ 表示，满足 $c_0=x,c_i>c_{i-1},b_i>b_{i-1}$，且 $c$ 字典序最小，改变是 $b_{c_{i}}=b_{c_{i-1}}$，$b_x=i$。

我们在一个序列上做，初始 $v=0$，$j$ 从 $x$ 开始从小往大枚举，若 $b_j>v$ 则交换它们的值。

我们发现这种修改对于整个集合而言是一个大根堆，那么我们考虑分块，散块重构整块用大根堆维护，并打 tag，标记是一个集合，用小根堆维护，重构时用。

用树状数组维护前缀贡献，每次修改只有 $\mathcal{O}(1)$ 次，总复杂度 $\mathcal{O}(n\sqrt n\log n+q\log n)$。

---

## 作者：N_z_ (赞：8)

[@ship2077](https://www.luogu.com.cn/user/1050064) 没有实名认证，我来代投一下题解。

[资料1](https://codeforces.com/blog/entry/111625)
[资料2](https://codeforces.com/blog/entry/111807)
[原题](https://judge.yosupo.jp/problem/static_range_lis_query)

$\tilde{\mathcal{O}}(n)$ 做法见上述资料。

介绍一种 $O(n\sqrt n\log n+q)$ 的做法，可以通过本题。


经典地，求 $lis$ 我们有一种二分贪心的方法，依次处理 $a_1,\cdots,a_n$，每次在一个集合中加入 $a_i$，然后删除一个大于 $a_i$ 的最小元素（如果没有不删除），最后集合的大小就是 $lis$ 长度。我们定义一个区间 $[l,r]$ 按这个操作执行的集合从小到大排的结果为 $A_{l,r}$，考虑如何刻画 $A_{l,r}$。

对于 $a=[10,3,4,9,1,5,7,2,8,6]$：

$A_{1,9}=[1,2,5,7,8],A_{2,9}=[1,2,5,7,8],A_{3,9}=[1,2,7,8],A_{4,9}=[1,2,7,8],A_{5,9}=[1,2,7,8],A_{6,9}=[2,7,8],A_{7,9}=[2,8],A_{8,9}=[2,8],A_{9,9}=[8]$

$A_{1,10}=[1,2,5,6,8],A_{2,10}=[1,2,5,6,8],A_{3,10}=[1,2,6,8],A_{4,10}=[1,2,6,8],A_{5,10}=[1,2,6,8],A_{6,10}=[2,6,8],A_{7,10}=[2,6],A_{8,10}=[2,6],A_{9,10}=[6],A_{10,10}=[6]$

我们注意到 $A_{l,r}$ 为 $A_{l+1,r}$ 长度至多差 1 的子序列（归纳证明），于是我们定义 $cnt_x$ 为元素 $x$ 在 $A_{1,m},A_{2,m},\cdots,A_{m,m}$ 中出现次数。知道 $cnt_x$ 后我们可以轻松完成查询，注意我们查询时只需要关心 $cnt_x$ 组成的集合。

当 $m$ 变成 $m+1$ 时，设当前加入的数为 $x$，考虑加入后改变的 $cnt_x$ 为 $p_0=x,p_1,p_2,\cdots,p_k$，需要满足 $p_i < p_{i+1}$ 且 $cnt_{p_i} < cnt_ {p_{i+1}}$，在此基础上 $p_i$ 最小。新的 $cnt'_{p_{i+1}}=cnt_{p_i}$（$cnt'_{x}=m+1$）。$cnt_x$ 组成的集合的修改量只有 $O(1)$。操作等价于 [该题](https://loj.ac/p/2736)，于是我们能够做到 $O(n\sqrt n\log n+q)$。

---

## 作者：云浅知处 (赞：7)

首先，求一个序列 $p_1,\cdots,p_n$ 的 LIS 有一个经典的算法：维护一个集合 $S$，初始为空，依次扫描 $i=1,2,\cdots,n$，每次如果 $S$ 中所有数都 $<p_i$，则令 $S\leftarrow S\cup\{p_i\}$；否则把 $S$ 中最小的 $>p_i$ 的数变为 $p_i$。这样最后 $|S|$ 就是 LIS 的长度（注意 $S$ 中的数并不一定构成 LIS）。

这可以解释为，对 $j=1,2,\cdots,n$ 维护了 $f_j$ 表示所有长度为 $j$ 的 LIS 中，最小的结尾元素是多少。初始，所有 $f_i=+\infty$。那么往末尾添加一个元素 $p_i$ 对 $f$ 的影响就是，如果本来的 $f_j<p_i$，则存在一个长度为 $j+1$ 的结尾为 $p_i$ 的元素，即我们需要令 $f_{j+1}\leftarrow \min(f_{j+1},p_i)$。可以发现 $f$ 是递增的，所以只有唯一的那个 $f_j<p_i<f_{j+1}$ 的位置会发生改变，那么造成的影响就和之前说的过程等价了：$S$ 中维护的本质上是所有 $f_i<+\infty$ 的 $f_i$，每次就是把最小的 $>p_i$ 的元素改成 $p_i$；如果最大的元素都 $<p_i$，那么就把 $p_i$ 插入进去。答案自然也就是最大的 $i$ 使得 $f_i<+\infty$，即 $|S|$。

------

现在我们考虑区间询问怎么做，设 $S_{l,r}$ 表示从空集开始，依次按照上述方法插入 $p_l,p_{l+1},\cdots,p_r$ 得到的最终集合。那么，对任意 $l<r$，我们总有 $S_{l+1,r}\subseteq S_{l,r}$。证明可以考虑如果当前 $A\subseteq B$，我们往 $A,B$ 中同时按上述方法加入 $x$（即，找到第一个 $>x$ 的变成 $x$，不存在则直接插入）造成的影响。手玩一下可以发现，不论 $x$ 如何取，操作结束后得到的新集合 $A',B'$ 总是仍然满足 $A'\subseteq B'$。那么对于前面所述的命题，由于初始 $S_{l+1,l+1}$ 肯定是 $S_{l,l+1}$ 的子集，所以对任意的 $r>l$ 都有 $S_{l+1,r}\subseteq S_{l,r}$。

既然如此，我们要求出 $l,r$ 的答案，就可以这样做：扫描线扫 $r=1,2,\cdots,n$，对每个 $x$，它总是在 $l$ 取一段前缀的 $S_{l,r}$ 中出现。我们考虑维护 $q_x$ 表示最大的 $l$ 使得 $x\in S_{l,r}$，即 $x$ 出现在 $S_{1,r},\cdots,S_{q_x,r}$ 中，不出现在 $S_{q_x+1,r},\cdots,S_{r,r}$ 中。那么对于一次询问 $l,r$，只需要查询有多少个 $x$，使得 $q_x\ge l$。

现在只需要考虑：在 $r\to r+1$ 时，如何维护序列 $q$，以及如何维护形如「查询全局有多少个 $\le l$ 的元素」这样的询问。

我们先来考虑 $r\to r+1$ 时序列 $q$ 是如何变化的。设 $v=p_{r+1}$，首先，对任意的 $l$，不论 $S_{l,r}$ 原先是什么样的，$v$ 总会要么替换掉一个元素，要么直接插入进去，从而出现在 $S_{l,r+1}$ 里，即必然有 $q_v=r+1$。接下来考虑 $q_{v+1}$，我们发现 $v+1$ 如果在某个 $S_{l,r}$ 中出现过，那么插入 $v$ 之后必然会被替换掉，所以 $q_{v+1}$ 必然会变成 $0$。那么 $v+2$ 呢？发现只有当 $v+1$ 出现过的时候才能帮它挡掉这一次操作的影响，否则他也会被替换掉。于是，如果原本序列中 $q_{v+2}>q_{v+1}$，那么新的 $q'_{v+2}$ 就是原本的 $q_{v+1}$；否则 $q_{v+2}$ 不变。

以此类推，读者想必已经看出：$r\to r+1$ 造成的影响可以用以下代码描述：（其中代码里的 $v=p_{r+1}$）

```cpp
q[v]=r+1,now=0
for(int i=v+1;i<=n;i++)if(q[i]>now)swap(q[i],now)
```

-------

此时，如果你做过[回转寿司](https://www.luogu.com.cn/problem/AT_joisc2016_h)，那么这个题的解法已经呼之欲出了。

考虑到这部分也并不算简单，我在这里也详细描述一下这部分是怎么做的。

我们先考虑一个简单的情形：每次操作，我们都是完整地枚举 $i$ 从 $1$ 到 $n$（而非 $v+1$ 到 $n$），以及给定初值 $now$（不一定为 $0$，尽管本题中总有 $now=0$，也不可能真的从 $1$ 枚举到 $n$），然后每次如果 $q_i>now$，则 $\text{swap}(q_i,now)$。可以发现，由于我们在查询的时候只关注 $\{q_i\}_{i=1}^n$ 这个可重集（因为只关注多少个 $q_x\ge l$），而操作对 $\{q_i\}_{i=1}^n$ 这个可重集造成的影响一定恰好是：如果 $now$ 大于 $q$ 的最大值则无事发生，否则就是在可重集中删除最大值，然后插入 $now$。那么我们可以简单用一个堆来维护。

现在我们的 $v$ 不一定是从 $1$ 开始的，那么考虑分块，每个块维护一个堆表示块内元素的可重集。对于整块，只需要每次把 $now$ 和当前块里的最大值 $mx$ 比较，如果 $mx>now$，则从当前块中删除 $mx$，插入 $now$，然后 $now$ 从这一块出去的时候的新值就是 $mx$；如果 $mx\le now$ 则无事发生。现在剩下的问题就是，对于散块的部分，该如何快速地知道这个块内的元素 $x_1,\cdots,x_B$ 经历一系列操作 $y_1,\cdots,y_k$（「经历一个操作 $y_i$」指的是枚举 $j=1,2,\cdots,B$，如果 $x_j>y_i$ 则交换二者）后分别变成了多少。注意这里我们必须还原出完整的序列。

我们不妨先来考虑第一个元素 $q_1$，它经历一系列操作 $x_1,\cdots,x_k$ 之后，如果 $q_1>\min x_i$，肯定会变成 $\min x_i$，否则无事发生；然后这一个操作序列 $x_1,\cdots,x_k$ 对 $q_2$ 的影响是什么呢，发现相当于把第一个 $<q_1$ 的 $x_i$ 变成 $q_1$，然后把 $x_i$ 后面第一个 $<x_i$ 的变为 $x_i$，以此类推。这是和原本的操作非常对称的一个操作，只不过 chkmax 变成了 chkmin。同理我们发现由于只关注 $\min$，可以拿一个堆来维护当前的操作序列 $x$。于是，我们便可以在 $O(B\log n)$ 的时间内重构这个块了。

综上，我们得到一个 $O((\frac{n}{B}+B)\log n)$ 单次操作的算法，取 $B=\sqrt{n}$，总的复杂度就是 $O(n\sqrt{n}\log n+q\log n)$。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

#define gc getchar
inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int N=1e5+5;
int a[N],q[N],n,ans[N],m;
vector<pair<int,int> >ques[N];

struct BIT{
	int c[N];
	int lowbit(int x){return x&(-x);}
	void add(int x,int v){x++;for(int i=x;i<=n+1;i+=lowbit(i))c[i]+=v;}
	int sum(int x){int res=0;for(int i=x+1;i;i-=lowbit(i))res+=c[i];return res;}
}T;

const int B=250;
const int NB=N/B+5;

priority_queue<int>P[NB],Q[NB];
int L[NB],R[NB],bl[N];
void rebuild(int p){
	if(Q[p].size()==0)return ;
	int l=L[p],r=R[p];
	for(int i=l;i<=r;i++)if(q[i]>-Q[p].top()){
		int cur=-Q[p].top();
		Q[p].pop(),Q[p].push(-q[i]),q[i]=cur;
	}
	priority_queue<int>().swap(Q[p]);
}

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++){
		int l=read(),r=read();
		ques[r].emplace_back(mk(l,i));
	}

	int S=sqrt(n);memset(L,63,sizeof(L));
	for(int i=1;i<=n;i++)bl[i]=(i-1)/S+1,cmin(L[bl[i]],i),cmax(R[bl[i]],i);
	for(int i=1;i<=bl[n];i++)for(int j=L[i];j<=R[i];j++)P[i].push(0);

	T.add(0,n);
	for(int i=1;i<=n;i++){
		int v=a[i],now=0;
		
		if(v+1<=n){
			int p=bl[v+1];rebuild(p);
			for(int j=v+1;j<=R[p];j++)if(q[j]>now)swap(now,q[j]);
			priority_queue<int>().swap(P[p]);
			for(int j=L[p];j<=R[p];j++)P[p].push(q[j]);
			
			for(int j=p+1;j<=bl[n];j++)if(P[j].top()>now){
				int cur=P[j].top();
				P[j].pop(),P[j].push(now),Q[j].push(-now),now=cur;
			}
			T.add(now,-1),T.add(0,1);
		}
		
		rebuild(bl[v]);
		T.add(q[v],-1),q[v]=i,T.add(q[v],1);
		priority_queue<int>().swap(P[bl[v]]);
		for(int j=L[bl[v]];j<=R[bl[v]];j++)P[bl[v]].push(q[j]);

		for(auto [l,id]:ques[i])ans[id]=T.sum(n)-T.sum(l-1);
	}
	for(int i=1;i<=m;i++)cout<<ans[i]<<'\n';

	return 0;
}
```

---


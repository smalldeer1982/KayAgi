# [BJOI2017] 开车

## 题目描述

有 $n$ 辆车，分别在 $a_1, a_2, \ldots , a_n$ 位置和 $n$ 个加油站，分别在 $b_1, b_2, \ldots ,b_n$ 位置。

每个加油站只能支持一辆车的加油，所以你要把这些车开到不同的加油站加油。一个车从 $x$ 位置开到 $y$ 位置的代价为 $|x-y|$，问如何安排车辆，使得代价之和最小。

同时你有 $q$ 个操作，每次操作会修改第 $i$ 辆车的位置到 $x$，你要回答每次修改操作之后最优安排方案的总代价。


## 说明/提示

【样例解释】

一开始将第一辆车开到位置 $4$，将第二辆车开到位置 $3$，代价为 $|4-1|+|3-2|=4$。

修改后第一辆车的位置变成 $3$，代价为 $|3-3|+|4-2|=2$。

|测试点|数据范围|
|:-:|:-:|
|$1$| $n\leq 10^3$，$q=0$|
|$2$| $n\leq 10^3$，$q\leq 10^3$|
|$3$| $n\leq 10^4$，$q\leq 10^4$|
|$4$| $n\leq 5\times 10^4$，$q=0$|
|$5\sim 6$| $n\leq 3\times 10^4$，$q\leq 3\times 10^4$|
|$7\sim 10$| $n\leq 5\times 10^4$，$q\leq 5\times 10^4$|

对于 $100\%$ 的数据，$1\leq n\leq 5\times 10^4$，$0\leq q\leq 5\times 10^4$。

## 样例 #1

### 输入

```
2
1 2
3 4
1
1 3
```

### 输出

```
4
2
```

# 题解

## 作者：shadowice1984 (赞：14)

喜闻乐见的5w分块……

需要稍微卡卡常数，(其实是我人傻常数大)
_______________________

## 本题题解

我们认为车和加油站是点，那么这就构成了一条链

直接两两匹配进行计算不是十分容易，所以我们考虑交换Σ，换句话说，考虑贡献

我们考虑在最后的方案中每一条边的贡献，那么我们会发现一条边的贡献应该是

### 这条边的长度×|这条边之前的车数-这条边之前的加油站数|

感性理解一下就是要么是车从左向右开过去，要么是加油站让车开过来，总之这条边上一定会通过二者之差的车数，所以贡献就是上面的式子

那么我们如果我们直接按照上面的式子进行对答案进行计算的话我们会发现这个做法不是十分明智

因为我们要支持以下操作

维护一个序列，每个点上有两个属性a和b

1.修改某个点的点权b

2.区间a加1区间a减1

3.区间平移

3.求上面带绝对值式子的和

我们发现似乎这个东西不是十分好用线段树做，于是我们考虑使用块状链表/块状数组强行维护这个东西

那么问题来了我们发现如果你使用块状链表来维护的话你会发现你要支持插入和删除一个点，那么换句话说你需要支持分裂一个较大的块这个操作……

此时你的代码就会极度恶心并且不能看了……

所以我们考虑加点常数然后消掉这个恶心的分裂操作

那么我们将所有修改强行离线之后我们将这15w个点强行离散化，然后对这15w个边进行分块

此时我们会发现，刚才的式子仍然成立，因为如果这个边的左端点暂时没有车的话，你相当于将一条长边拆成两条短边计算贡献，当然上边的式子还是成立的

但是此时就变成了普通的区间加区间减了因为我们已经把所有的询问离线塞到我们数据结构里了，也就是说我们没有了恶心的插入和删除操作，只剩下加法和减法了

这样的话我们会略微好写一点

这样的话我们就只需要区间加区间减了，恶心的修改点权和分裂块全部都没有了

那么现在我们考虑怎么做这个操作

我们将所有边分成$\sqrt{N}$块

然后每个块内按照a(也就是前面车的个数减加油站个数)进行排序

现在考虑如何维护块内答案(就是那个式子的和)

首先如果这个块不是整体的被加1或者减1的话可以直接重构了

因为每次操作最多重构两个块

如果是整体加1或者减1的话我们可能需要一些特殊技巧

注意这里如果是整体加a整体减b的话会更难写一点

先介绍一下一般的做法

我们假设$f(x)$为这个块在整体被加x的时候的答案值

你发现这是一个若干带绝对值式子求和的形式

高中数学知识告诉你这是一个分段函数，并且你发现这个函数仅仅分了$O(\sqrt{n})$段

因此我们可以暴力的维护每一个分段的函数此时我们就可以lower_bound
出x所在的分段，然后就可以直接计算了

但是我们发现只是加一和减一所以我们可以偷点懒

具体来说我们维护按a排序的序列，然后处理出这个按a排序的序列的b的前缀和

每次加1和减1的时候暴力的二分出此时0的位置

如果是加1，那么答案变化量是所有非负数的b值和-负数的b值和

如果是减1，那么答案变化量是所有非正数的b值和-正数的b值和

当我们二分出0的位置之后就可以使用前缀和表达这个答案的变化量了

然后分块打一下标记就可以愉快的做完这道题了

如果发现常数不是十分对劲的话可以将重构时的快速排序换成计数排序

复杂度$O(N\sqrt{N}logN)$

上代码~

```C
// luogu-judger-enable-o2
#pragma GCC optimize(2)
#include<cstdio>
#include<algorithm>
#include<map>
#include<cmath>
#include<ctime>
using namespace std;const int N=15*1e4+10;const int B=400;typedef long long ll;
map <int,int> mp1,mp2;int n;int m;int pos[N];int bs;int bt;int tot;int qu[N];int qv[N];
ll res=0;inline ll mabs(ll x){return x>0?x:-x;}int* AB;int st;int ed;
inline bool cmp(const int& a,const int& b){return AB[a]<AB[b];}
struct b_arr
{
    int st[B];int tp;int ab[B];int w[B];ll pre[B];int miu;ll ans;
    inline void app(){for(int i=1;i<=tp;i++)ab[i]-=miu;miu=0;}
    inline void rebuild()
    {
        AB=ab;sort(st+1,st+tp+1,cmp);//暴力重构
        for(int i=1;i<=tp;i++)pre[i]=pre[i-1]+w[st[i]];ans=0;
        for(int i=1;i<=tp;i++)ans+=mabs(ab[st[i]])*w[st[i]];
    }
    inline void rb_add(const int& lc,const int& p)
    {for(int i=1;i<=tp;i++)st[i]=i;app();for(int i=lc;i<=tp;i++)ab[i]+=p;rebuild();}
    inline void lb_miu()
    {
        int l=0;int r=tp;//打标记，可能这里为了方便二分的处理可能需要打减法标记
        while(l!=r){int mid=(l+r+1)/2;if(ab[st[mid]]<=miu)l=mid;else r=mid-1;}
        ans+=2*pre[l]-pre[tp];miu++;
    }
    inline void lb_add()
    {
        --miu;int l=0;int r=tp;
        while(l!=r){int mid=(l+r+1)/2;if(ab[st[mid]]<=miu)l=mid;else r=mid-1;}
        ans+=pre[tp]-2*pre[l];
    }
    inline void ins(const int& Ab,const int& W){++tp;st[tp]=tp;ab[tp]=Ab;w[tp]=W;}
}bl[B];int bu[N];int bv[N];//维护编号到块编号的映射
int main()
{
    scanf("%d",&n);//偷懒使用了map进行离散化
    for(int i=1;i<=n;i++){scanf("%d",&pos[i]);mp1[pos[i]]=1;mp2[pos[i]]++;}
    for(int i=1,po;i<=n;i++){scanf("%d",&po);mp1[po]=1;mp2[po]--;}
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {scanf("%d%d",&qu[i],&qv[i]);mp1[qv[i]]=1;if(mp2[qv[i]]==0)mp2[qv[i]]=0;}
    tot=mp1.size()-1;bs=sqrt(tot);//注意最后一个点没有边，所以删掉
    for(int i=0;i*bs<=tot;i++)
        for(int j=1;j<=bs&&i*bs+j<=tot;j++)bu[i*bs+j]=i+1,bv[i*bs+j]=j;
    map <int,int> :: iterator it,it1;tot=0;
    for(it=mp2.begin(),it1=it,++it1;it1!=mp2.end();++it,++it1)it1->second+=it->second;
    for(it=mp1.begin(),it1=it,++it1;it1!=mp1.end();++it,++it1)
    {it->second=++tot,bl[bu[tot]].ins(mp2[it->first],it1->first-it->first);}
    mp1.erase(--mp1.end());mp2.erase(--mp2.end()); 
    bt=(tot-1)/bs+1;for(int i=1;i<=bt;i++)bl[i].rebuild();
    for(int i=1;i<=bt;i++)res+=bl[i].ans;printf("%lld\n",res);
    for(int t=1;t<=m;t++)
    {
        int ls=mp1[pos[qu[t]]];int rs=mp1[qv[t]];//讨论下是区间加还是区间减
        if(ls==0){bl[bu[rs]].rb_add(bv[rs],1);for(int i=bu[rs]+1;i<=bt;i++)bl[i].lb_add();}
        else if(rs==0){bl[bu[ls]].rb_add(bv[ls],-1);for(int i=bu[ls]+1;i<=bt;i++)bl[i].lb_miu();}
        else if(ls<rs)
        {
            bl[bu[ls]].rb_add(bv[ls],-1);bl[bu[rs]].rb_add(bv[rs],1);
            for(int i=bu[ls]+1;i<=bu[rs];i++)bl[i].lb_miu();
        }
        else if(ls>rs)
        {
            bl[bu[ls]].rb_add(bv[ls],-1);bl[bu[rs]].rb_add(bv[rs],1);
            for(int i=bu[rs]+1;i<=bu[ls];i++)bl[i].lb_add();
        }res=0;for(int i=1;i<=bt;i++)res+=bl[i].ans;
        printf("%lld\n",res);pos[qu[t]]=qv[t];//更改位置
    }return 0;//拜拜程序~
}
```







---

## 作者：lzyqwq (赞：6)

先锐评一下幽默题解区，一篇自称单根号的题解是假的，另一篇自称单根号的题解没给代码，姑且认为她是变化莫测的。剩下的做法全部带 $\log$。所以来一篇正常题解。

先考虑每辆车到哪个加油站。显然是让第 $i$ 左的车去第 $i$ 左的加油站。下面给出证明：

> 假设第 $i$ 左的车位置为 $x$，去的加油站位置为 $X$。第 $i+1$ 左的车位置为 $y$，去的加油站位置为 $Y$。如果 $X \ge Y$，则交换两车的目的地后：
> - $x\le y\le Y\le X$：交换前总路程为 $X-x+Y-y$，交换后总路程为 $Y-x+X-y$，不劣。
> - $x\le Y\le y\le X$：交换前总路程为 $X-x+Y-y\ge X-x$，交换后的总路程为 $Y-x+X-y\le X-x$，不劣。
> - $x\le Y\le X\le y$：交换前总路程为 $X-x+Y-y\ge y-x$，交换后总路程为 $Y-x+y-X\le y-x$，不劣。
> - $Y\le x\le y\le X$：交换前总路程为 $X-x+y-Y\ge X - Y$，交换后总路程为 $x-Y+X-y\le X-Y$，不劣。
> - $Y\le x\le X\le y$：交换前总路程为 $X-x+Y-y\ge y-Y$，交换后总路程为 $x-Y+y-X\le y-Y$，不劣。
> - $Y\le X\le x\le y$：交换前总路程为 $x-X+y-Y$，交换后总路程为 $x-Y+y-X$，不劣。
>
> 因此记第 $i$ 左的车去的加油站为 $p_i$，则 $p_i$ 单调不降。故第 $i$ 左的车去的加油站为第 $i$ 左的。
>
> $\mathcal{Q.E.D.}$

那么我们记 $a_i,b_i$ 均为排过序的数组，则要求单点修改 $a_i$，然后对新数组重新排序，求 $\sum\limits_{i=1}^n|a_i-b_i|$。

这个比较困难，考虑把每一时刻车所在位置和加油站所在位置上的点 $P$ 在数轴上表示出来离散化一下，则一共有 $\mathcal{O}(n+q)$ 个点，且每一段路程一定由若干个相邻点构成的线段组成。所以考虑每一条线段的贡献。

记从左至右第 $i$ 条线段长度为 $w_i$，起点为 $P_i$，终点为 $P_{i+1}$。记 $\text{sa}_i$ 表示当前 $P_i$ 之前车的数量，$\text{sb}_i$ 表示 $P_i$ 之前加油站的数量。则第 $i$ 条线段会被经过 $|\text{sa}_i-\text{sb}_i|$ 次。

因为考虑什么情况下会经过这条线段，显然要求车和加油站分布在她的两侧。不妨令 $\text{sa}_i\ge \text{sb}_i$，则对于 $j\in [1,\text{sb}_i]$ 有 $a_j,b_j\le P_i$，对于 $j\in (\text{sb}_i,\text{sa}_i]$ 有 $a_j\le P_i<b_j$，对于 $j\in (\text{sb}_i,n]$ 有 $a_j,b_j>P_i$。因此在两侧的就是 $(\text{sb}_i,\text{sa}_i]$ 内的这些车和加油站，故被经过 $|\text{sa}_i-\text{sb}_i|$ 次。对于 $\text{sa}_i< \text{sb}_i$ 的情况是同理的。

记 $s_i=\text{sa}_i-\text{sb}_i$，则对于一次挪车的操作，设其从 $P_x$ 挪至 $P_y$，不考虑 $x=y$。若 $P_x<P_y$，相当于区间 $[x,y)$ 内 $\text{sa}_i$ 减 $1$ 即 $s_i$ 减 $1$。否则相当于区间 $[x,y)$ 内 $\text{sa}_i$ 加 $1$ 即 $s_i$ 加 $1$。

现在问题变成 $s_i$ 区间加减 $\boldsymbol 1$，求全局 $\sum\limits_{i=1}^m|s_i|w_i$，其中 $m$ 是线段的数量。

考虑以 $\mathcal{O}(\sqrt{n+q})$ 为块长分块，离线逐块处理。记当前块为 $[L,R]$。对于查询把绝对值拆开，对于 $s_i\ge 0$ 的部分贡献为 $\sum\limits_{s_i\ge 0} s_iw_i$，对于 $s_i<0$ 的部分贡献为 $-\sum\limits_{s_i<0} s_iw_i$。

考虑整块修改。维护辅助数组 $s'_i$ 和全局加标记 $T$ 使得任意时刻 $s'_i+T=s_i$。

当全局 $s_i$ 加 $1$ 时，$T$ 加 $1$，对于原来 $s_i\ge 0$ 的部分，$|s_i|$ 加 $1$，贡献增加 $\sum \limits_{s_i\ge 0}w_i$。对于原来 $s_i<0$ 的部分，$|s_i|$ 减 $1$，贡献减少 $\sum\limits_{s_i<0} w_i$。

当全局 $s_i$ 减 $1$ 时，$T$ 减 $1$，对于原来 $s_i\ge 1$ 的部分，$|s_i|$ 减 $1$，贡献减少 $\sum\limits_{s_i\ge 1}w_i$。对于原来 $s_i\le 0$ 的部分，$|s_i|$ 加 $1$，贡献增加 $\sum\limits_{s_i\le 0}w_i$。

维护 $\text{po}=\sum\limits_{s_i\ge 0}w_i,\text{ne} = \sum\limits_{s_i<0}w_i,\text{cn}_j=\sum\limits_{s'_i=j}w_i$。则当前块对修改后答案相较于修改前增加、减少的贡献可以通过 $\text{po},\text{ne},\text{cn}_{-T}$ 表示出来。同时 $\text{po},\text{ne}$ 的变化量也可以被 $\text{cn}_{-T},\text{cn}_{-T-1}$ 表示出来。注意这里给下标加一个偏移量。注意到 $|s_i|\le n$，偏移量设为 $n$ 即可，且 $\text{cn}$ 占用的空间为 $\mathcal{O}(n)$。

每次整块修改都是 $\mathcal{O}(1)$ 的，一共进行 $\mathcal{O}(q\sqrt{n+q})$ 次，故总时间复杂度为 $\mathcal{O}(q\sqrt{n+q})$。

对于散块修改，下放标记然后重构即可。但是重构 $\text{cn}$ 的时候不能暴力遍历值域。注意到整块修改不会修改 $s'_i$，因此 $\text{cn}$ 中不为 $0$ 的下标只有 $s'_L,\dots,s'_R$ 这些，存储每次的 $s'_i$ 并在重构时清空这些位置即可。单次时间复杂度为 $\mathcal{O}(\sqrt{n+q})$，一共 $\mathcal{O}(q)$ 次，故总时间复杂度 $\mathcal{O}(q\sqrt{n+q})$。

综上，该做法时间复杂度为 $\mathcal{O}(q\sqrt{n+q})$，空间复杂度为 $\mathcal{O}(n+q)$。

[AC Link](https://www.luogu.com.cn/record/195318702) / [Code](https://www.luogu.com.cn/paste/c0nvmitw)

---

## 作者：Rorschachindark (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P3992)
# 题目大意
有$n$个汽车和$n$个加油站，坐标分别为$a_{1,2,...,n}$和$b_{1,2,...,n}$。每辆汽车会到一个加油站，求出最小移动距离之和。有$m$次修改，每次将某辆汽车的坐标进行修改，求出修改后的最小移动距离之和。

$n,m\le 5\times 10^4$
# 思路
看到题解都写得比较繁杂，这里提供一种不是那么繁杂的方法。借鉴了[Miracle的博客](https://www.cnblogs.com/Miracevin/p/10691399.html)和[shadowice1984的题解](https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3992)。

首先，不难看出对于某一条边，它的贡献为它的长度乘上$|sum|$，其中，$sum$就是在它之前的汽车-在它之前的加油站。它的意义就是因为要一一对应，所以差的数量就需要通过移动填补，而移动就需要经过该边。

而我们的修改操作，相当于删掉一个点再加入一个点。考虑加入一个点，那我们就相当于把后面的点的$sum+1$。但是因为贡献里面带有绝对值，所以我们不能直接搞，对于这种问题我们一个常用的解决方法就是直接分块。对于某个块，我们可以按$sum$大小排序，二分找到分界点，然后分别考虑$sum< 0$和$sum\ge0$的情况即可。删掉一个点同理。

于是，我们就可以在$\Theta(n\sqrt n(\log \sqrt n))$的时间复杂度内解决这个问题。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Abs(x) ((x)>=0?(x):-(x))
#define Int register int
#define ll long long
#define MAXN 200005
#define MAXM 455

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,m,un,a[MAXN],b[MAXN],tmp[MAXN];

struct Query{
	int x,y;
}q[MAXN];

ll ans;
int siz,val[MAXN],sum[MAXN],bel[MAXN],ord[MAXN],col[MAXM],cor[MAXM],tag[MAXN],sval[MAXN];

bool cmp (int a,int b){return sum[a] < sum[b];}

void rebuild (int x){
	sort (ord + col[x],ord + cor[x] + 1,cmp);
	sval[col[x]] = val[ord[col[x]]];for (Int i = col[x] + 1;i <= cor[x];++ i) sval[i] = sval[i - 1] + val[ord[i]];
}

void init (){
	for (Int i = 1;i <= n;++ i) sum[a[i]] ++,sum[b[i]] --;
	for (Int i = 1;i <= un;++ i){
		if (i < un) val[i] = tmp[i + 1] - tmp[i];
		sum[i] += sum[i - 1],ans += 1ll * Abs (sum[i]) * val[i];
	}
	siz = ceil (sqrt (un));
	for (Int i = 1;i <= un;++ i){
		bel[i] = (i - 1) / siz + 1,ord[i] = i;
		if (!col[bel[i]]) col[bel[i]] = i;
		cor[bel[i]] = i;
	}
	for (Int i = 1;i <= bel[un];++ i) rebuild (i);
}

void ins (int x){
	for (Int i = x;i <= cor[bel[x]];++ i){
		ans += 1ll * val[i] * (sum[i] + tag[bel[x]] >= 0 ? 1 : -1);//注意：三目运算符优先级比加减乘除低 
		sum[i] ++;
	}
	rebuild (bel[x]);
	for (Int i = bel[x] + 1;i <= bel[un];++ i){
		int l = col[i],r = cor[i],res = -1;
		while (l <= r){
			int mid = (l + r) >> 1;
			if (sum[ord[mid]] + tag[i] >= 0) res = mid,r = mid - 1;
			else l = mid + 1;
		}
		if (res == -1) ans -= sval[cor[i]];
		else if (res == col[i]) ans += sval[cor[i]];
		else{
			ans -= sval[res - 1];
			ans += sval[cor[i]] - sval[res - 1];
		}
		tag[i] ++;
	}
}

void del (int x){
	for (Int i = x;i <= cor[bel[x]];++ i){
		ans += 1ll * val[i] * (sum[i] + tag[bel[x]] <= 0 ? 1 : -1);//注意：三目运算符优先级比加减乘除低 
		sum[i] --;
	}
	rebuild (bel[x]);
	for (Int i = bel[x] + 1;i <= bel[un];++ i){
		int l = col[i],r = cor[i],res = -1;
		while (l <= r){
			int mid = (l + r) >> 1;
			if (sum[ord[mid]] + tag[i] <= 0) res = mid,l = mid + 1;
			else r = mid - 1;
		}
		if (res == -1) ans -= sval[cor[i]];
		else if (res == cor[i]) ans += sval[cor[i]];
		else{
			ans += sval[res];
			ans -= sval[cor[i]] - sval[res];
		}
		tag[i] --;
	}
}

signed main(){
	read (n);
	for (Int i = 1;i <= n;++ i) read (a[i]),tmp[++ un] = a[i];
	for (Int i = 1;i <= n;++ i) read (b[i]),tmp[++ un] = b[i];
	read (m);for (Int i = 1;i <= m;++ i) read (q[i].x,q[i].y),tmp[++ un] = q[i].y;
	sort (tmp + 1,tmp + un + 1),un = unique (tmp + 1,tmp + un + 1) - tmp - 1;
	for (Int i = 1;i <= n;++ i) a[i] = lower_bound (tmp + 1,tmp + un + 1,a[i]) - tmp,b[i] = lower_bound (tmp + 1,tmp + un + 1,b[i]) - tmp;
	for (Int i = 1;i <= m;++ i) q[i].y = lower_bound (tmp + 1,tmp + un + 1,q[i].y) - tmp;
	init (),write (ans),putchar ('\n');
	for (Int i = 1,x,y;i <= m;++ i){
		x = q[i].x,y = q[i].y;
		del (a[x]),ins (a[x] = y);
		write (ans),putchar ('\n');
	}
	return 0;
}
```

---

## 作者：Forg1weN (赞：2)

# 题面

有 $n$ 辆车，分别在 $a_1, a_2, \ldots , a_n$ 位置和 $n$ 个加油站，分别在 $b_1, b_2, \ldots ,b_n$ 位置。

每个加油站只能支持一辆车的加油，所以你要把这些车开到不同的加油站加油。一个车从 $x$ 位置开到 $y$ 位置的代价为 $|x-y|$，问如何安排车辆，使得代价之和最小。

同时你有 $q$ 个操作，每次操作会修改第 $i$ 辆车的位置到 $x$，你要回答每次修改操作之后最优安排方案的总代价。



所有的车和加油站的范围一直在 $0$ 到 $10^9$ 之间。

$1\leq n\leq 5\times 10^4$，$0\leq q\leq 5\times 10^4$。

# Solution
先考虑朴素算法，在进行操作之前，进行简单的贪心可知，将序列 $a,b$ 分别从小到大排序，然后一一对应，例如 $a_1$ 对应 $b_1$，$a_n$ 对应 $b_n$。在进行操作时，操作完后的序列也应该为一一对应的有序序列。

给出简单证明：设有车 $a,b$ 有油站 $x,y$ 于数轴上，若 $a$ 对应 $x$ ，$b$ 对应 $y$，令其对应关系交换，简单枚举：

- $x,y$ 全在 $a,b$ 之内或之外，总花费增加 $\lvert x-y \rvert$
- $x,y$ 一个在 $a,b$ 之内，另一个则否，形如 $x\le a\le y\le b$，花费增加 $\lvert a-y \rvert$

故题目初步转化为有序数列 $a,b$ 中，求 $\sum_{i=1}^{n} \lvert a[i]-b[i] \rvert$。

考虑每一步操作对答案的贡献，设操作数字在有序数列的下标为 $x$，目标下标为 $y$，令 $x<y$，则区间 $[x,y)$ 内的对应关系全部右移一位，$a_y$ 对应上 $b_x$，由于此对应关系携带绝对值，故无法直接求出，考虑转化。

转化为求一条路径经过多少次的问题，设车与油站所有的下标在数轴上为 $d_1\dots d_n$ ，简单离散化。也就是说设当前道路左边的车为 $C_i$，当前道路左边的油站为 $P_i$，相当于做前缀和，道路长度为 $L_i$ ,第 $i$ 段道路对答案的贡献为 $L_i\times \lvert (C_i-P_i) \rvert $，即还有 $\lvert (C_i-P_i) \rvert$ 辆待匹配车要经过这条道路寻找匹配。

令 $Sum_i=\lvert (C_i-P_i) \rvert$ ，每一次操作令$a_i=y$，等同于离散化之后 $Sum$ 区间 $[l,r]$ 加一或减一，原因易得。

记第 $i$ 个块长度为$len_i$，记第 $i$ 条路径时 $Cnt_i=Sum_i\times (d_{i+1}-d_i)$，考虑没有区间懒标记时：$ans=\sum_{j=1}^{len_i}Cnt_{i,j}$，经过思考，原因为：距离常数 $d$ 在此为正数，$Sum_i$ 携带绝对值，故所得值一定为正。

若含有区间操作标记 $add_i$，则相当于有一部分的 $Sum_i$ 操作后非正，但注意：**此时的 $Sum_i$ 非正并不意味着其对答案的贡献为负数，而是意味着其的在数轴上的方向为负方向，询问时要枚举正负分界点，并分别求带绝对值后对答案的贡献，进行求和。**

由于操作后的 $Sum_i$ 非正，需要提前加一个偏移量，目的是为了防止访问到以负数为下标的数组。

## 时空复杂度
每一个块中，记录的 $Sum_i$ 为车与停车场的差的绝对值，一个块内最多有 $\sqrt N$ 的车与停车场，所以一个块内的桶的空间是不超过 $\sqrt N$ 的，故总的空间复杂度为 $O(N)$。

在一个询问中，我们暴力处理散块，对于整块携带散块通过懒标记加暴力处理，对于一次询问，最多修改两个块的内容，又因为预处理的复杂度相当于遍历每个元素，故而总时间复杂度为 $O(N\sqrt N)$。

## Code 
可参考题解区代码，这里无需多言。



---

## 作者：Eterna (赞：1)

将每个时刻上所有车和加油站位置丢到一起排序，放在数轴上，这样就有了 $\mathcal{O}(n+q)$ 个点 $\{p_i\}$。

任意两个相邻的点构成一条线段，对于一条线段 $[p_i,p_{i+1}]$，设其长度为 $w_i=p_{i+1}-p_i$。对于一种车的移动方式，显然它可以用只有这些线段的方式组成。考虑每一条线段会被经过几次，即 $w_i$ 会乘上什么系数贡献到答案。（因为我们将每个时刻上的车位置都维护了，所以 $w_i$ 的值不变）

贪心地想，对于每条线段我们都希望尽可能少的经过。设 $c_i$ 为 $[0,p_i]$ 中车的数量，$d_i$ 为 $[0,p_i]$ 中加油站的数量，而 $s_i=c_i-d_i$。因为车走到加油站和加油站走到车其实一样，所以线段 $[p_i,p_{i+1}]$ 左侧有 $\lvert s_i \rvert$ 个点没能匹配上其他点，需要经过这条线段去右边。那么答案即为 $\sum \lvert s_i \rvert w_i$。

考虑一个修改操作造成的影响，因为起始点和目标点我们都已经放在数轴上了，所以它一定是从某个 $p_x$ 到某个 $p_y$ 的形式。

若 $x=y$，操作无用，直接跳过。

若 $x<y$，也就是车向后移了，所以这辆车对 $p_i<p_y$ 的线段都没有了贡献，即对区间 $[x,y)$ 中的 $c_i$ 减取 $1$，相当于对区间 $[x,y)$ 中的 $s_i$ 减去 $1$。

若 $x>y$，车向前移，对区间 $[y,x)$ 中的 $c_i$ 加上 $1$，相当于对区间 $[y,x)$ 中的 $s_i$ 加上 $1$。

现在的问题化为对区间 $[l,r]$ 的 $s_i \pm 1$，查询全局 $\sum \lvert s_i \rvert w_i$。

以 $\mathrm{S}=\mathcal{O}(\sqrt{n+q})$ 为块长对序列分块。离线逐块处理。

对于该块的全局加减，维护偏移量 $t$ 即可，表示 $s_i$ 的真实值为 $s_i+t$。通过讨论操作后的 $\lvert s_i\rvert$ 的值，我们发现需要维护 $\sum\limits _{s_i \le x}w_i$。 

如果值域分块的话，散块重构，需要 $\mathcal{O}(n\sqrt{n})$ 次单点修改和 $\mathcal{O}(n\sqrt{n})$ 次区间查询。复杂度肯定不低于 $\mathcal{O}(n\sqrt{n}\log n)$，能过但不优秀。

我们发现，因为增量的绝对值只能为 $1$。对于 $\sum\limits _{s_i \le x}w_i$，我们只关心 $x=0,\pm 1,\infty$ 时的取值。

当 $x=\infty$ 时，$\sum\limits _{s_i \le x}w_i$ 固定，不需要另外维护。

考虑再维护出 $f_y=\sum \limits _{s_i=y}w_i$，这样 $x=\pm 1$ 的情况就可以变为 $x=0$ 的情况。

再考虑全局 $\pm 1$ 对 $\sum\limits _{s_i \le 0}w_i$ 影响。如果是 $+1$，它会减少 $c_{0}$。如果是 $+1$，它会减少 $c_{0}$。如果是 $-1$，它会增加 $c_1$。

对于 $c_i$ 的维护，全局加减利用偏移量相当于是静态的。散块修改先下发偏移量，然后暴力重构，重构时只需要提前存下有值的 $c_i$ 所对应的 $i$ 即可在 $\mathcal{O}(\sqrt{n+q})$ 的时间复杂度内清空。有值的位置其实就是没有偏移的 $s_i$。

然后总的时间复杂度就是 $\mathcal{O}(n\sqrt{n+q})$，空间复杂度是 $\mathcal{O}(n+q)$。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define rd read()
#define gc pa == pb && (pb = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pb) ? EOF : *pa++
using namespace std;
static char buf[100000], * pa(buf), * pb(buf);
inline int read()
{
	register int x=0,s=gc;
	while(!isdigit(s))s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+(s^48),s=gc;
	return x;
}
const int V=1000000000,N=200005,S=800;
int t,n,m,c,block,tot,L,R;
int a[N],b[N],p[N],w[N],s[N];
ll sum,al,fu,d[N],ans[N];
struct qry{int l,r,v;}q[N];
map<int,int> mp;
inline void clear(){for(int i=L;i<=R;i++)d[s[i]+n]=0;}
inline void build(){al=fu=t=sum=0;for(int i=L;i<=R;i++)al+=w[i],fu+=(s[i]<=0)*w[i],sum+=1ll*abs(s[i])*w[i],d[s[i]+n]+=w[i];}
inline void sol()
{
	build(),ans[0]+=sum;
	for(int i=1;i<=m;++i)
	{
		auto [l,r,v]=q[i];
		if(v)
		{
			l=max(l,L),r=min(r,R);
			if(l==L&&r==R)
			{
				if(v<0)sum+=2*fu-al,fu+=d[n-t+1];
				else sum+=al-2*fu+2*d[n-t],fu-=d[n-t];
				t+=v;
			}
			else if(l<=r)
			{
				clear();
				for(int i=L;i<=R;i++)s[i]+=t;
				for(int i=l;i<=r;i++)s[i]+=v;
				build();
			}
		}
		ans[i]+=sum;
	}
	clear();
}
signed main()
{
	n=rd;for(int i=1;i<=n;++i)p[++c]=a[i]=rd;
	for(int i=1;i<=n;++i)p[++c]=b[i]=rd;m=rd;
	for(int i=1,x;i<=m;i++)x=rd,p[++c]=rd,q[i]={x,p[c],0};
	sort(p+1,p+c+1),c=unique(p+1,p+c+1)-p-2,mp[p[c+1]]=c+1;
	block=1+sqrt(c),tot=(c-1)/block+1;
	for(int i=1;i<=c;i++)w[i]=p[i+1]-p[i],mp[p[i]]=i;
	for(int i=1;i<=n;i++)++s[mp[a[i]]],--s[mp[b[i]]];
	for(int i=2;i<=c;i++)s[i]+=s[i-1];
	for(int i=1,X;i<=m;i++)
	{
		auto [x,y,g]=q[i];
		X=x,x=a[x],x=mp[x],a[X]=y,y=mp[y];
		if(x!=y)x<y?q[i]={x,y-1,-1}:q[i]={y,x-1,1};
		else q[i]={0,0,0};
	}
	for(int i=1;i<=tot;i++)L=R+1,R=min(i*block,c),sol();
	for(int i=0;i<=m;i++)cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：lovely_nst (赞：1)

# P3992 [BJOI2017] 开车

## 前言

分块好题。

本文讲述的算法总复杂度为 $O(q\log n+q\sqrt{n}\log n)$，其中瓶颈在桶（unordered_map）。

## 正文

考虑不带修。首先将 $a$ 与 $b$ 的元素放入 $c$ 排序并去重，设第 $i$ 位及其以前车的数量减加油站的数量为 $s_i$，$w_i=c_{i+1}-c_i$ 则答案可以转换为 
$$
\sum_{i=1}^{n\times 2-1}|s_i|\times w_i
$$

为什么呢？因为若前面少了车（$s_i<0$）则后面一定有车来补，那就一定会经过 $[c_i,c_{i+1}]$，于是贡献就要加上 $w_i$；而当前面多了车（$s_i>0$），同理，前面的车也一定要补后面，贡献是一样的。而这样的车又有 $|s_i|$ 个，于是就得到上面的式子。

那带修怎么做？现在的 $c$ 还要加上修改的位置元素，之后考虑分块维护几样东西：


1. 加数 $tag$ 

2. $up=\sum_{s_i+tag\ge 0} s_i\times w_i$

3. $down=\sum_{s_i+tag<0} -s_i\times w_i$

4. $upcnt=\sum_{s_i+tag\ge 0} w_i$

5. $downcnt=\sum_{s_i+tag<0} w_i$

6. $cnt_i=\sum_{s_k=i} w_k$



散块暴力重构是简单的。而每次修改可以看作对一段区间的 $s_i$ 进行 $\pm 1$ 操作。当是 $-1$ 操作时（$pos<newpos$）：

$$
newupcnt=\sum_{s_i+tag>0}w_i=upcnt-cnt_{-tag}\\
newup=up-\sum_{s_i+tag>0}w_i=up-newup\\
newdowncnt=\sum_{s_i+tag\le0}w_i=downcnt+cnt_{-tag}\\
newdown=down+\sum_{s_i+tag\le0}w_i=down+newdown\\
newtag=tag-1
$$

当是 $+1$ 操作时（$pos>newpos$）：

$$
newupcnt=\sum_{s_i+tag\ge-1}w_i=upcnt+cnt_{-tag-1}\\
newup=up+\sum_{s_i+tag\ge0}w_i=up+upcnt\\
newdowncnt=\sum_{s_i+tag<-1}w_i=downcnt-cnt_{-tag-1}\\
newdown=down-\sum_{s_i+tag<0}w_i=down-newdown\\
newtag=tag+1
$$

最后的答案就是：

$$
\sum_{i=1}^{B} up_i+down_i
$$

## AC Code


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e4 + 5 , M = 2e5 , B_ = 500;
int n , m;
int a[N] , b[N] , d[N] , p[N] , s[M] , w[M];
vector <pair <int , int> > S;
int B , id[M] , tag[B_] , s_[B_] , t_[B_] , up[B_] , down[B_] , upcnt[B_] , downcnt[B_];
unordered_map <int , int> cnt[B_];

void rbd (int pid)
{
	cnt[pid].clear ();
	for (int i = s_[pid];i <= t_[pid];i ++)
		s[i] += tag[pid];
	tag[pid] = up[pid] = down[pid] = upcnt[pid] = downcnt[pid] = 0;
	for (int i = s_[pid];i <= t_[pid];i ++)
	{
		cnt[pid][s[i]] += w[i];
		if (s[i] >= 0) up[pid] += w[i] * s[i] , upcnt[pid] += w[i];
		else down[pid] -= w[i] * s[i] , downcnt[pid] += w[i];
	}
}

void upd (int l , int r , int C)
{
	if (r > n) r = n;
	int lid = id[l] , rid = id[r];
	if (lid == rid)
	{
		for (int i = l;i <= r;i ++)
			s[i] += C;
		rbd (lid);
		return ;
	}
	for (int i = l;id[i] == lid;i ++)
		s[i] += C;
	rbd (lid);
	for (int i = lid + 1;i < rid;i ++)
	{
		if (C == 1) up[i] += upcnt[i] , upcnt[i] += cnt[i][-tag[i] - 1] , down[i] -= downcnt[i] , downcnt[i] -= cnt[i][-tag[i] - 1];
		else upcnt[i] -= cnt[i][-tag[i]] , up[i] -= upcnt[i] , downcnt[i] += cnt[i][-tag[i]] , down[i] += downcnt[i];
		tag[i] += C;
	}
	for (int i = r;id[i] == rid;i --)
		s[i] += C;
	rbd (rid);
}
vector <pair <int , int> > unique ()
{
	vector <pair <int , int> > ans;
	int lst = -1 , sum = 0;
	for (auto it : S)
	{
		if (lst == it.first) sum += it.second;
		else
		{
			if (lst != -1) ans.push_back ({lst , sum});
			lst = it.first , sum = it.second;
		}
	}
	ans.push_back ({lst , sum});
	return ans;
}
signed main ()
{
	ios::sync_with_stdio (0); cin.tie (0) , cout.tie (0);
	cin >> n;
	for (int i = 1;i <= n;i ++) cin >> a[i] , S.push_back ({a[i] , 1});
	for (int i = 1;i <= n;i ++) cin >> b[i] , S.push_back ({b[i] , -1});
	cin >> m;
	for (int i = 1;i <= m;i ++) cin >> d[i] >> p[i] , S.push_back ({p[i] , 0});
	sort (S.begin () , S.end ());
	S = unique ();
	int l = S.size ();
	S.push_back ({2e9 , 0});
	for (int i = 1;i <= l;i ++)
		s[i] = s[i - 1] + S[i - 1].second , w[i] = S[i].first - S[i - 1].first;
	int ans = 0;
	n = l - 1;
	int cc = 0;
	B = sqrt (n);
	for (int i = 1;i <= n;i += B)
	{
		s_[++ cc] = i , t_[cc] = min (i + B - 1 , n);
		for (int j = s_[cc];j <= t_[cc];j ++) id[j] = cc;
		rbd (cc);
		ans += up[cc] + down[cc];
	}
	cout << ans << '\n';
	for (int i = 1;i <= m;i ++)
	{
		int P = lower_bound (S.begin () , S.end () , (pair <int , int>){a[d[i]] , 1e9}) - S.begin ();
		a[d[i]] = p[i];
		int Q = lower_bound (S.begin () , S.end () , (pair <int , int>){a[d[i]] , 1e9}) - S.begin ();
		if (P < Q)
			upd (P , Q - 1 , -1);
		else if (P > Q)
			upd (Q , P - 1 , 1);
		ans = 0;
		for (int j = 1;j <= cc;j ++)
			ans += up[j] + down[j];
		cout << ans << '\n';
	return 0;
}
```

最后提供一组[大样例](https://www.luogu.com.cn/paste/gkv6ybca)。

---

## 作者：Otomachi_Una_ (赞：0)

通过离散化容易把问题变成 $\sum_{i=1}^m |\sum_{j\leq i}x_j|v_i$。其中你要支持对 $x_i$ 的单点加 $1$、减 $1$。

对操作分块，那么这个 $x$ 序列中只有 $O(B)$ 个点可能被更改。我们把所有极长的没有被修改的点分成一块。对这个块内被修改的点直接暴力算。

假设这一块是 $[l,r]$ 考虑我们怎么快速计算这次操作过后 $[l,r]$ 的答案。

假设 $\sum_{j<l}x_i=X$。那么我们就只要计算 $\sum_{i=l}^r|X+\sum_{l\leq j\leq i}x_j|v_i$。你发现实际上所有询问中 $X$ 的不同取值是 $O(B)$ 的，且组成一个区间。因为你每次对 $x_*$ 修改对 $X$ 的变化量是 $O(1)$ 的。

问题变成怎么计算这个块对一个区间的 $X$ 快速计算答案。对每个 $i$ 单独考虑，容易写成 $|X+sx_i|v_i$ 的形式。差分维护即可。

时间复杂度：$O(q\sqrt n)$。

---

## 作者：StayAlone (赞：0)

考虑不带修版本，显然是先对 $a,b$ 分别排序，然后第 $i$ 小的车去第 $i$ 小的加油站。容易证明有交不优。

但是这个做法没什么前途。

将车的初始位置与加油站的位置视为关键点，一起排序，形成了一些线段 $[P_i,P_{i+1}]$。令 $s_i$ 表示 $(-\infin,P_i]$ 中，车的数量减去加油站的数量，则 $[P_i,P_{i+1}]$ 将被经过 $|s_i|$ 次。设这条线段的长度为 $w_i$，答案就是 $\sum |s_i|\cdot w_i$。

考虑带修，发现带修就是区间 $\pm 1$。于是问题转化成对 $s_{i}$ 区间 $\pm1$，维护 $\sum |s_i|\cdot w_i$。

考虑分块。对每个块，维护当前块内 $\sum |s_i|\cdot w_i$，$\sum\limits_{s_i\geq 0} |s_i|\cdot w_i$，$\sum\limits_{s_i< 0} |s_i|\cdot w_i$。为了整体加减，还需要一个增减的懒标记 $tag$，再维护一个桶 $cnt_v=\sum\limits_{s_i-tag=v} w_i$，注意有 $tag$ 造成的偏移。

如此就能简单维护整块修改了。散块修改直接重构即可，需要注意清空数组的复杂度。

由于带修，要注意修改后车的位置也要视为关键点。

认为 $n,q$ 同阶，时间复杂度 $\mathcal O(n\sqrt n)$。

[AC record](https://www.luogu.com.cn/record/201643189)

```cpp
int n, m, g, a[MAXN], b[MAXN], c[MAXN], d[MAXN]; ll ans[MAXN];
int len, bcnt, idx[MAXN], L[MAXN], R[MAXN];
int s[MAXN], w[MAXN];
ll buf[MAXN << 1], *sum = buf + MAXN;
pii q[MAXN]; vector <int> B;

il void operate(int t) {
	const int l = L[t], r = R[t];
	ll now, sn, sp; int tg = 0;
	auto rebuild = [&]() {
		now = sn = sp = 0;
		rep1(i, l, r) sum[s[i]] = 0;
		rep1(i, l, r) {
			ll g = 1ll * (s[i] += tg) * w[i];
			now += abs(g); sum[s[i]] += w[i];
			if (g >= 0) sp += w[i];
			else sn += w[i];
		} tg = 0;
	}; rebuild(); ans[0] += now;
	rep1(i, 1, m) {
		auto [x, y] = q[i]; int dt = d[i];
		gmax(x, l); gmin(y, r);
		if (x == l && y == r) {
			if (~dt) {
				now += sp; now -= sn;
				sn -= sum[-1 - tg]; sp += sum[-1 - tg];
			} else {
				sn += sum[-tg]; sp -= sum[-tg];
				now -= sp; now += sn;
			} tg += dt;
		} else if (x <= y) {
			rep1(i, l, r) sum[s[i]] = 0;
			rep1(i, l, r) s[i] += tg;
			rep1(i, x, y) s[i] += dt;
			tg = 0; rebuild();
		} ans[i] += now;
	}
	rep1(i, l, r) sum[s[i]] = 0;
}

int main() {
	read(n); rer(i, 1, n, a), B.eb(a[i]); rer(i, 1, n, b), B.eb(b[i]);
	read(m); rer(i, 1, m, q), B.eb(q[i].snd);
	sort(begin(B), end(B)); B.resize(g = unique(begin(B), end(B)) - begin(B));
	len = sqrt(n + m); bcnt = (g - 2) / len + 1;
	rep1(i, 1, bcnt) L[i] = R[i - 1] + 1, R[i] = L[i] + len - 1;
	rep1(i, 1, n) c[i] = a[i], d[i] = b[i];
	R[bcnt] = g - 1; int i1 = 0, i2 = 0;
	sort(c + 1, c + 1 + n); sort(d + 1, d + 1 + n);
	rep1(i, 1, g - 1) {
		w[i] = B[i] - B[i - 1];
		while (i1 < n && c[i1 + 1] <= B[i - 1]) ++i1;
		while (i2 < n && d[i2 + 1] <= B[i - 1]) ++i2;
		s[i] = i1 - i2;
	} --g;
	rep1(i, 1, m) {
		int x = q[i].fst; d[i] = -1;
		q[i].fst = a[x]; a[x] = q[i].snd;
		q[i].fst = lower_bound(begin(B), end(B), q[i].fst) - begin(B) + 1;
		q[i].snd = lower_bound(begin(B), end(B), q[i].snd) - begin(B) + 1;
		if (q[i].fst > q[i].snd) swap(q[i].fst, q[i].snd), d[i] = 1;
		--q[i].snd;
	}
	rep1(i, 1, bcnt) operate(i);
	rep1(i, 0, m) printf("%lld\n", ans[i]);
	return 0;
}
```

---

## 作者：piantouqu (赞：0)

考虑最小代价：$a,b$ 排一遍，$\sum_{i=1}^n| a_i-b_i|$ 就是最小代价。

证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/2xjfoxtm.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/uvjff1e9.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/6owarpp7.png)

…

由上图得知，橙的不比紫的劣（橙的是一一对应）。

直接去算 $|a_i-b_i|$ 显然是不好去处理的，但去维护序列上是否有边是较好维护的。

去计算贡献，$sum_i$ 表示 $[1,i]$ 之间车比加油站多多少，$w_i$ 表示离散化后 $i$ 到 $i+1$ 的距离，答案是 $\sum_{i=1}^n|sum_i|\times w_i$。

我们去维护这个东西发现不太好用线段树维护，~~虽然我想用就是了，然后左右脑互博了 3 次~~，考虑分块是否能够维护。

整块是去记录块中正负线段的距离，然后拿个桶快速查一下值为零的部分然后加入贡献。

```cpp
//po 是非负数，ne 是负数，s 是和，f 是 tag
    if(v>0) s+=po-ne,po+=ct[n-f-1],ne-=ct[n-f-1];
    else s+=ne-po+2*ct[n-f],po-=ct[n-f],ne+=ct[n-f];
    f+=v;
```

散块是直接暴力重构。

```cpp
void rebuild(int id,int l,int r,int v){
    if(l>r) return;
    rep(i,L[id],R[id]) sum[i]+=f;
    f=0;
    rep(i,l,r) sum[i]+=v;
    build(id);
}
```

注意：1. 不要每个块去开个桶，会炸；2. 因为无法开多个桶，所以要一个一个块处理，统计答案；3. 看到 $a,b\le10^9$ 且 $n,q\le5\times10^4$ 的数据范围，显然要离散化。

剩下的都不是很困难，就不放代码了。

---


# [Ynoi2018] 末日时在做什么？有没有空？可以来拯救吗？

## 题目背景

今天真是多谢你了

让我体验了许多美好

我留下了如同美梦一般的回忆 不过时间到了

最后我还想拜托你一件事

希望你可以把我忘掉

 ![](https://cdn.luogu.com.cn/upload/pic/13170.png) 

在自己消失之前

心怀不想消失的愿望

希望让某个人记住我

希望能留下羁绊

我这么希望着，又有什么不可以的吗

 ![](https://cdn.luogu.com.cn/upload/pic/13171.png) 

香香甜甜的，真好闻

看起来很好吃

 ![](https://cdn.luogu.com.cn/upload/pic/13173.png) 

我遵守了...

约...约定

我非常...非常努力哦...

 ![](https://cdn.luogu.com.cn/upload/pic/13172.png) 

欢迎回来，珂朵莉


## 题目描述

珂朵莉给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作。

1. 把区间 $[l,r]$ 内所有数都加上 $x$。
2. 查询区间 $[l,r]$ 内的最大子段和，可以不选数。


## 说明/提示

Idea：nzhtl1477，Solution：ccz181078，Code：nzhtl1477&ccz181078&mrsrz，Data：nzhtl1477&mrsrz&w33z8kqrqk8zzzx33

$1 \le n , m \le 10^5$，$| a_i | \leq 10^9$，$|x|\leq 10^9$。

**保证任意时刻 $|a_i|\leq 2\times 10^9$。**

By nzhtl1477 & ccz181078


## 样例 #1

### 输入

```
5 5
-2 -3 -3 -3 -3
2 1 5
1 2 4 4
2 1 5
1 2 3 1
2 3 3```

### 输出

```
0
3
2```

## 样例 #2

### 输入

```
5 5
-2 3 3 -3 3
2 1 5
1 2 4 -4
2 1 5
1 2 3 1
2 3 3```

### 输出

```
6
3
0
```

# 题解

## 作者：Sol1 (赞：66)

update：看这个题好像不咋换数据了于是确认代码能过之后再最后改一遍。。。。

目前看来最大点是 #21 1.16s。

别再改数据了吧，这代码我实在不想再卡常了/dk，这题解我也不想再更新了/dk

---

> 在太阳西斜的这个世界里，置身天上之森。等这场战争结束之后，不归之人与望眼欲穿的众人， 人人本着正义之名，长存不灭的过去、逐渐消逝的未来。我回来了，纵使日薄西山，即便看不到未来，此时此刻的光辉，盼君勿忘。————世界上最幸福的女孩

珂朵莉要一直幸福下去哦~

~~代码长达 12K，喜提最长解。wtcl~~

~~希望这道题不会让各位对珂学的热爱丧失殆尽。~~

---

~~臭名昭著的研究珂学的最佳方式~~ 举世闻名的「深潜循藏第六分块」。

## $0$ 前置知识

1.  SPOJ GSS 系列
	- 最大子段和的做法，写了你就知道是啥了。
2.  凸包、闵可夫斯基和、Jarvis
	- 不会的话可以去看一下二维凸包模板里面 ShineEternal 神仙的题解。
3.  线段树、分块
	- 如果这个还不会那就不要做 Ynoi 了吧
4.  基数排序
	- 这个在 v5 里面不需要，但是现在这题是 v6，所以一个高速的基数排序是很重要的~

好了，确认你都会了？

Then~start!

## $1$ 弱化

如果问题弱化为全局加区间最大子段和，这道题怎么做？

如果不带修，那么就是一个经典问题，可以维护一棵线段树，每一个节点上面维护区间和、区间最大后缀和、区间最大前缀和、区间最大子段和，合并的时候直接分类讨论即可。

然后如果加上全局加，我们还是考虑如何维护上面的四个信息。

首先区间和直接做就可以。

区间前缀和可以维护一个凸函数 $f(x)$ 表示长度为 $x$ 的前缀和。

后缀和同理，记这个函数为 $g(x)$。

全局加 $d$ 然后提取最大的时候是最大化 $f(x)+dx$（$g(x)+dx$），显然可以凸包二分。

然后我们去考虑如何求区间最大子段和。

还是维护凸包的思路，维护一个凸函数 $h(x)$，表示长度恰好为 $x$ 的子段和最大为多少。

然而这个东西是没法直接求的……

换一个思路，我们取在线段树上两个子节点的 $g_L(x)$ 和 $f_R(y)$，然后有关系式 $h(x+y)=g_L(x)+f_R(y)$。

所以这个 $h$ 实际上就是 $g_L$ 和 $f_R$ 的闵可夫斯基和再对 $h_L$ 和 $h_R$ 取 $\max$。

又因为我们的 $x$ 是区间长度，即定义域大小是线性的，那么凸包长度就也是线性的。

所以我们对于一个大小为 $s$ 的节点可以 $O(s)$ 求出这个点上面的所有凸包。

既然这样，我们就可以 $O(n\log n)$ 建出线段树。

提取答案的时候，每一个节点凸包二分，共 $\log n$ 个节点，故每次询问的复杂度为 $O(\log^2 n)$。

**注意：P5073 的解法与此稍有不同，因为 P5073 可以也需要通过离线转换为只加正数从而达到均摊单次询问 $O(\log n)$，但是这题并不完全需要，后面会讲到。**

我就是因为受 P5073 的思路制约导致在这题上面卡了好几天……

## $2$ 本题高复杂度解法

我们对这个序列分块，在每一块上面建 $1$ 中所说的线段树，每次整体修改可以直接做，零散修改重构线段树，整体查询和零散查询都查询线段树。

这样如果块长为 $s$，整体修改 $O(1)$，零散修改 $O(s\log s)$，整体查询 $O(\log s)$，零散查询 $O(\log^2 s)$，可以得到一个复杂度为 $O(n\sqrt n\log n)$ 的解法。

灵魂拷问：能 过 吗？

显然是不能的。

于是就有了——

## $3$ 本题低复杂度解法

我们发现复杂度有两个瓶颈：一是零散修改，二是整体查询。分开讨论怎么优化。

### $3.1$ 零散修改优化

真的有必要重构整棵线段树吗？

不要忘了：

1. 线段树的子树还是线段树
2. 这里的线段树支持整体加，不支持区间加

所以我们可以在零散修改的时候在终止节点上面打标记，非终止节点线性重构。

对于标记的下放，我们可以这样处理：我们在线段树上搞一个节点整体加的标记，这个是正常下放的；然后再在凸包上面维护一个凸包整体加的标记，这个标记是只叠加不下放的。取凸包内节点的时候考虑叠加的正比例函数对点的位置的影响即可。

因为每一层非终止节点的数量是 $O(1)$ 的，所以等比数列求和一下零散修改就变成 $O(s)$ 的了，但是常数比较大。

你可能会问，这里的线段树不是只支持加正数的吗？如果加负数怎么做呢？

事实是：**这个线段树支持加负数。** 因为 P5073 限制了我们的复杂度到 $O(\log n)$，**而这题并没有。** 所以采用二分的方式提取答案，是可以支持加负数的。

所以零散修改的复杂度就下降到了线性。

### $3.2$ 整体查询优化

首先我们引入一个科技：逐块处理。

这个科技适用于修改和查询都按块独立且允许离线的问题。

对于这个问题，区间加肯定是按块独立的没话说，最大子段和我们也有办法快速合并，所以就可以逐块处理。

而逐块处理就是离线每一个输入的操作对这个块的操作，然后依次算一遍第一块的所有操作，算一遍第二块的所有操作……

这样的好处在于，如果我们的第 $i$ 次操作和第 $j$ 次操作修改了这个块 $(i<j)$，那么此时这两个操作之间的所有操作都可以 **随意改变顺序**，而传统分块是做不到这一点的。

---

现在来看如何使用这个科技解决这题。

我们发现，整体查询一定是提取线段树根上面那个凸包，而因为整体修改是用一个全局 tag 保存，所以 **根上一定是没有标记的**。

既然这样，我们就可以把所有查询按照查询时整体加 tag 的值升序排序，然后转换成整体加只加正数。（这里就是逐块处理的应用——改变询问顺序。）

这样在根上面提取答案的时候可以类似 P5073 那样搞个指针往右爬，从而 $O(s)$ 处理所有询问。零散修改重构凸包的时候，直接把指针重置为 $0$ 即可。

这样处理询问的复杂度就是 $O(ms)$。

证明：

我们定义一个块的势能 $E$ 为根上面的指针距离块右端点的距离。

那么显然初始的势能 $\sum E=O(n)$。

那么我们每次零散操作会把指针置回 $0$，导致增加 $O(s)$ 的势能。

而每一次操作只会导致 $O(1)$ 个块被零散操作。

故总零散操作的数量是 $O(m)$ 量级的。

所以总势能是 $O(ms)$ 的。

又因为每次爬指针的时候是 $O(1)$ 时间减少 $O(1)$ 势能，故总时间最大为 $O(ms)$。

Q.E.D.

---

但是还有一个问题，排序的复杂度仍然是 $O(ms\log m)$。

所以换成基数排序，这样就实实在在地优化到 $O(ms)$ 了。

那么，现在得到了一个零散修改 $O(s)$，零散查询 $O(\log^2s)$（当然你也可以用暴力扫的方式来 $O(s)$，不过我觉得这样比较方便），整体修改 $O(1)$，整体查询均摊 $O(1)$（因为是 $O(ms)$ 时间， $O(ms)$ 次查询）的算法。

取 $s=\sqrt n$，得此时算法的复杂度为 $O(m\sqrt n)$。

~~芜湖，起飞！~~

## $4$ 常数优化

但是 lxl 显然不会让你就这样愉快地过掉这道题……

于是我们开始卡常：

### $4.1$ 优化 1

我们发现，$\log_{10}v$ 和 $\log_2n$ 的差距不是很大，除 $10$ 又会有很大的常数。所以基数排序的基数取 $2048$，这样可以位运算，$\log_{2048}v$ 也很小，速度就会快不少。

### $4.2$ 优化 2

我们发现，每次排序的时候用 2048 个 vector 来保存桶会导致动态分配内存占用巨大的时间。

然而我们在排整数序列的时候，是用 2048 个 int 来保存每一个数的出现次数，然后再放回到数组里面，这样就避免了分配内存的压力。

这里的应用是单关键字排序结构体，所以如果我们能把结构体的下标强行附加到全局 tag 上，一切问题就都解决了。

显然我们可以做到这一点，我们把下标乘上 $2^{35}$ 然后加到全局 tag 上面，排序仍然只排 $3$ 次。这样因为排序只会考虑到 $33$ 位以下的部分，下标就不会参与排序。

于是我们就得到了按照关键字排好序的下标数组，对应回去即可。全过程中可以完全避免动态分配内存，就会有很大的速度提升。

而且在结合了优化 $2$ 之后，可以将基数排序的基数改为 $256$，由于缓存的影响，速度会有极大的提升。

### $4.3$ 优化 3

维护凸包时不要使用 vector，使用数组和指针静态分配内存。这样进一步减少了 vector 动态内存分配的压力。

### $4.4$ 优化 4

由于在块长不变的时候内存分配情况一定不会变，所以只需要在第一个块分配一下内存，最后一个块重新分配一下内存就可以了，不需要每次都重新分配。

### $4.5$ 优化 5

一杯茶，一包烟，一个块长调一天。

---

加上这些常数优化，我就轻松（？）过掉了这题。

上面的常数优化大部分都围绕着消除动态分配内存导致的巨大常数，这个思路在其他场景下也适用。

---

[为了防止抄袭，这里仅贴出数据结构核心部分的代码，请读者自行完成其余部分（雾）](https://www.luogu.com.cn/paste/nbf0rpol)

---

## 作者：2018heyuyang (赞：31)

## 参考文献

[世界上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)和这道题------[shadowice1984](https://www.luogu.com.cn/user/56384)大佬的两篇题解

还有一个不记得在哪了，是lxl在某个地方发的改版前的题解

## 写在前面

我们知道“单点修区间最大子段和”用线段树维护四个值：区间和、最大前缀和、最大后缀和、最大子段和，下面分别用 $s/ls/rs/mx$ 表示

这题以前的版本是只加正数，官方解法是先分成 $\sqrt n$ 个块

然后对每个块建一颗凸包线段树，维护 $ls/rs/mx$ 的凸包 (上凸壳)（和[$P5073$](https://www.luogu.com.cn/problem/P5073)类似）

凸包的事我想[shadowice1984](https://www.luogu.com.cn/user/56384)大佬的题解很清晰，这里声明：必须要搞清楚他是怎么$O(N)$合并两个子凸包的

对于覆盖了整棵树的修改，由于加上的是正数，所以指针看情况往后拉就行，复杂度均摊$O(1)$

重点是部分修改，全部重造线段树会让你的代码T掉

这里要搞懂线段树构建的本质，这里以长方形类比，每层长$\sqrt N$，宽$log\sqrt N$

凸包从底层建起，合并信息是$O(\sqrt N)$的，这里的$\sqrt N$为整棵线段树的服务长度即块长

lxl给出的解决方案和第二篇题解一样，是按照线段树基本操作，将操作下传到 $log$ 个子节点

![](https://cdn.luogu.com.cn/upload/image_hosting/5crfaatu.png)

如图，红色部分为修改的区间，同时引起绿色部分的改变，红色部分打上标记日后处理底下的，黑色部分就不用动了

结合$O(\sqrt N)$合并子凸包的操作，我们这次修改的复杂度就是红绿色的长度和

复杂度$/$规模就是$O(k\sqrt N)$------$k$为一巨大常数

搞定了修改操作，询问就变得不堪一击，但值得一提的事，修改操作特别是对懒标记的处理十分繁琐

由于技艺不精，我的常数巨大，T到飞起，先后多次尝试此题，花费大量精力修改代码，均以失败告终

现在给出一个个人觉得方便的处理方法：

线段树只记一个 $c$，表示这一层所有点要加 $c$

下到目标节点时：
```cpp
if(l<=tr[now].l&&tr[now].r<=r){tr[now].c+=k;return ;}
```
懒标记下放时也只传个 $c$ 下去

然后上面节点引用下面的点集时
```cpp
struct point{ll x,y;point operator+(ll const&AK47)const{return point{x,y+AK47*x};}};
point jia(point a,point b){return (point){a.x+b.x,a.y+b.y};}

P=jia(A,B+tr[lc].c);
```
这样设置比较方便，但要注意运算顺序

## 正片（很短）

现在难度加大了，可以加负数了。。。唯一不变的还是两个字：分块

但有的东西你想不到就真的想不到了。。。

分块做区间加区间和做过吗？

是不是每个操作都是从左往右，小段----大段----小段，这样？

你试过按块处理问题吗？

就是对第一块扫描$n$个问题，然后再去下一个块

这里就有一个重要的思想，前提是数据可以合并，势能可以均摊(这里很抱歉用了势能，可能不太严谨)

我们知道小段共有 $n$ 个，单次操作复杂度$O(\sqrt n)$

又有大段 $n\sqrt n$ 个，单次操作复杂度$O(1)$

均摊下来每个块的复杂度是$O(n)$的，刚好有$\sqrt n$个块

所以——你懂得，这玩意用在这里真的真的真的，女少口阿

![](https://cdn.luogu.com.cn/upload/image_hosting/elzw5ge4.png)

如图，黑色为块的分界，绿色为询问，红色为修改，下面一段字的 $n$ 和 $m$ 表示规模

我们知道，有 $m$ 条红色，就可以通过分块变成 $m$ 条小块的红色，和$m\sqrt n$条整段的红色

又有 $m$ 条绿色，就可以通过分块变成 $m$ 条小块的绿色，和$m\sqrt n$条整段的绿色

其中绿色中的小块我们可以暴力解决

那么对于任意一个块中，就会出现如下情况

![](https://cdn.luogu.com.cn/upload/image_hosting/qsp9abtl.png)

不妨设为最坏情况，有最多$m$条绿色大段和最多$m$条红色大段 交错 在一个块里

那红色小段？。。。

大段的总量是红色小段总量的$\sqrt n$倍，即红色小段是极为稀疏的

然后只要把这玩意一圈

![](https://cdn.luogu.com.cn/upload/image_hosting/6ntjmiiv.png)

天哪这不就是P5073！！？

不说了。。。你们加油 $\color{white}\text{别问为什么没代码，问就是qwq}$

## 写在后面（雾

去年我看到这题就开始在机房没日没夜的尝试，尝试了好多个3天，都快憋出病了。。。如今终于敲出来了，但是细节超多，RE半天发现自己忘memset，max函数没开long long……

个人感受：lxl的一些题最妙的地方在于“总量一定”，从而达到均摊的复杂度

最后的最后，祝珂朵莉继续幸福下去。

还有，管他什么题总之lxl毒瘤数据结构天下第一！！

---

## 作者：SSerxhs (赞：26)

题意：给定一个序列，支持区间增减区间查询最大子段和

~~以下注意部分可能是个人写法问题~~

## 前置知识 1：线段树

~~能做这题都会线段树了吧~~

## 前置知识 2：分块

以分块做区间增减区间求和为例。（允许离线）时有两种做法，第一种是对每次操作分别处理每个块，第二种是离线所有操作，对每个块处理所有操作。第一种的优势是在线，第二种的优势是一大堆操作有一定的整体处理优化空间。本题需要使用的是第二种操作

## 前置知识 3：闵可夫斯基和

~~没学过先去写写 [[JSOI2018]战争](https://www.luogu.com.cn/problem/P4557)~~

注意这里的凸包用的是 Jarris 步进法，而闵可夫斯基和跑出来的凸包可能真的是凸包而不是这题需要的上凸壳，所以需要跑完之后再跑一次凸包

## 前置知识 4：基数排序

建议使用块长为 256 的松式基排，有可用位运算、卡 cache 、恰好运行 4 次的优势

# 本题正片

这里默认已经写过 [[Ynoi2015]世上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)

为什么不能直接拓展 5073 的思路？原因是这道题线段树 pushup 的复杂度是 $O(n)$ 的，打标记只要不是打在根节点上都等于暴力，也就是说这里的线段树并不支持快速区间修改

分块具有的特性之一就是大部分修改面向整块而散块非常暴力，这正好符合我们这题的需要。考虑对原序列分块、对每个块建线段树，那么整块修改就变成了 5073 了

想到这里似乎结束了？

分析一下复杂度，整块修改复杂度 $O(m\sqrt n)$，散块修改暴力重构 $O(m\sqrt nlogn)$，询问？

询问按照 5073 的套路需要离线跑，然而散块修改暴力重构会强行冲断整体离线（不再只和总标记相关），导致并不能所有询问一起离线。但是考虑到散块修改只有 $O(m)$ 次，最多也只能把询问冲断成 $O(m\sqrt n)$ 段，并不对复杂度造成影响

离线要后在 $log\sqrt n$ 层线段树上向右爬，可以计算复杂度为 $O(m\sqrt nlogn)$

正常情况下总复杂度 $O(m\sqrt nlogn)$ 是有机会跑过 $10^5$ 的范围的，然而这题线段树上维护的是个凸包显然常数上不允许卡过去

~~看到 Ynoi 题，套路卡掉 log~~

目前瓶颈在散块修改和询问

首先是散块修改，考虑到这里的线段树依然是个线段树，虽然不能快速区间修改但是可以龟速区间修改而不需暴力重构，由于每一层最多只有 2 个节点需要 pushup 单次复杂度是 $O(\sum\limits_{i=0}^\infty\dfrac{\sqrt n}{2^i})=O(\sqrt n)$ 从而消去了 log

区间询问可以直接暴力计算，由于区间询问只有 $O(m)$ 个复杂度是 $O(m\sqrt n)$ 的

所以最后剩下的问题就是：全局修改、全局最大子段和

这时可以发现并不需要在线段树的 log 层上向右爬而只需要在根节点做这一步，这样这一步复杂度也没有 log 了

然而排序部分还是有个 log，可以通过基数排序解决这个问题

解决完这些问题复杂度就变成了 $O(m\sqrt n)$，可以通过此题

~~TLE，0分~~

## 真·本题正片

接下来就是卡常数了（以下技巧不保证有用）

1. ~~我也不知道为什么封装了跑得更快~~

2. pushup 时，求**所有**凸包都只需要考虑子节点凸包上的点，可以证明这是正确的

3. 合理借助自然溢出可以让你在某些地方不需要开 long long

4. 基数排序部分可以循环展开，可以设定一个阈值小于这个阈值就暴力快排

5. 块长似乎不需要大调，最多稍微修改一下防止被卡满

6. pushdown 和普通的不同，普通的如果加 if 判断可能会更慢，但这题 pushdown 的代价是很高的，要先判断是否有修改

代码只给出核心部分

```
struct Q
{
	int z,y,wz;
	ll tot;
	Q(int a=0,int b=0,int c=0,ll d=0):z(a),y(b),wz(c),tot(d){}
	bool operator<(Q &o) {return tot<o.tot;}
	Q operator-(Q o) {return Q(z-o.z,y-o.y,wz-o.wz,tot-o.tot);}
};
struct P
{
	int wz;
	ll tot;
	bool operator<(register P&o) const{return tot<o.tot;}
};
struct pt
{
	int x;
	ll y;
	pt(register int a=0,register ll b=inf):x(a),y(b){}
	bool operator<(register pt o) {return (x*o.y<y*o.x);}//顺时针
	pt operator+(register pt o) {return pt(x+o.x,y+o.y);}
	pt operator-(register pt &o) {return pt(x-o.x,y-o.y);}
	ll operator*(register pt o) {return x*o.y-y*o.x;}
	ll operator/(register pt o) {return x*o.x+y*o.y;}
	bool operator^(register ll k) {return (k*x+y>0);}
	void operator+=(register pt &o) {x+=o.x;y+=o.y;}
	void operator-=(register pt &o) {x-=o.x;y-=o.y;}
};
P stt[N],ls[N];
Q q[N];
pt st[N],la[N],lb[N];
ll lsum[N],ans[N],qz[N];
ll mt;
int bel[N],l[N],r[N],a[N],px[N],tot[bas];
int n,m,ksiz,ks,x,y,z,qsum,i,j;
void qs(register int tp)
{
	tp-=4;register int i;
	for (i=1;i<=tp;i+=4)
	{
		stt[i].tot-=mt;
		stt[i+1].tot-=mt;
		stt[i+2].tot-=mt;
		stt[i+3].tot-=mt;
	}tp+=4;
	for (i;i<=tp;i++) stt[i].tot-=mt;
	memset(tot,0,sizeof(tot));
	for (register int i=1;i<=tp;i++) ++tot[stt[i].tot&bs];
	for (register int i=1;i<bas;i++) tot[i]+=tot[i-1];
	for (register int i=tp;i;i--) ls[tot[stt[i].tot&bs]--]=stt[i];
	memset(tot,0,sizeof(tot));
	for (register int i=1;i<=tp;i++) ++tot[ls[i].tot>>8&bs];
	for (register int i=1;i<bas;i++) tot[i]+=tot[i-1];
	for (register int i=tp;i;i--) stt[tot[ls[i].tot>>8&bs]--]=ls[i];
	memset(tot,0,sizeof(tot));
	for (register int i=1;i<=tp;i++) ++tot[stt[i].tot>>16&bs];
	for (register int i=1;i<bas;i++) tot[i]+=tot[i-1];
	for (register int i=tp;i;i--) ls[tot[stt[i].tot>>16&bs]--]=stt[i];
	memset(tot,0,sizeof(tot));
	for (register int i=1;i<=tp;i++) ++tot[ls[i].tot>>24&bs];
	for (register int i=1;i<bas;i++) tot[i]+=tot[i-1];
	for (register int i=tp;i;i--) stt[tot[ls[i].tot>>24&bs]--]=ls[i];
	tp-=4;
	for (i=1;i<=tp;i+=4)
	{
		stt[i].tot+=mt;
		stt[i+1].tot+=mt;
		stt[i+2].tot+=mt;
		stt[i+3].tot+=mt;
	}tp+=4;
	for (i;i<=tp;i++) stt[i].tot+=mt;
}
inline void mx(register ll &x,const ll y)
{
	if (x<y) x=y;
}
void tb(register pt *a,register int pre,register int &n)
{
	register int i,tp=pre-1;
	for (i=pre;i<n;i++)
	{
		while ((tp)&&(a[i]-a[tp-1]<a[tp]-a[tp-1])) --tp;
		a[++tp]=a[i];
	}
	n=tp+1;
}
void maintain(register pt *a,const int n,const int m)//old:n new: m
{
	register int i;
	for (i=m-1;i>=n;i--) a[i]=pt(i+1,inf);
	for (i=n-1;~i;i--) if (a[i].x!=i+1) {a[a[i].x-1]=a[i];a[i]=pt(i+1,inf);}
}
void spemaintain(register pt *a,const int n,const int m)
{
	register int i;
	for (i=0;i<m;i++) st[i]=pt(i+1,inf);
	for (i=0;i<n;i++) mx(st[a[i].x-1].y,a[i].y);
	memcpy(a,st,m*sizeof(pt));
}
int order(register pt *a,register int n)//old: n new: return
{
	register int i=1,tp=0;
	for (i=0;i<n;i++) if (a[i].y>inf) a[tp++]=a[i];
	tb(a,1,tp);return tp;
}
int sum(pt *a,pt *b,pt *c,int n,int m,int len)//a+b=c
{
	int i,j,tp=1;
	c[0]=a[0]+b[0];--n;--m;
	for (i=0;i<n;i++) la[i]=a[i+1]-a[i];la[n]=a[0]-a[n];
	for (i=0;i<m;i++) lb[i]=b[i+1]-b[i];lb[m]=b[0]-b[m];
	for (i=j=0;(i<=n)&&(j<=m);++tp)
	{
		if (la[i]<lb[j]) c[tp]=c[tp-1]+la[i++]; 
		else c[tp]=c[tp-1]+lb[j++];
	}--tp;
	while (i<=n) c[tp]=c[tp-1]+la[i++],++tp;
	while (j<=m) c[tp]=c[tp-1]+lb[j++],++tp;
	spemaintain(c,tp,len);
	tp=order(c,len);
	return tp;
}
bool cmp(register int &x,register int &y)
{
	return qz[x]<qz[y];
}
struct segmentree
{
	pt sl[O][M],sr[O][M],ss[O][M],scf,lcf,rcf;
	ll s[K],lz[M],ssum[M];
	ll mlz;
	int l[M],r[M],cs[M],scd[M],tcd[M],lcd[M],rcd[M],a[K],b[K];
	int dt,sy,ly,ry,tp,y,z,n;
private:
	void newpushup(const int x)
	{
		register int c=x<<1,cd;
		register ll ys;
		scd[x]=sum(sr[cs[c]]+l[c],sl[cs[c]]+l[c|1],ss[cs[x]]+l[x],rcd[c],lcd[c|1],tcd[x]);
		maintain(ss[cs[x]]+l[x],scd[x],tcd[x]);
		register pt *p1=ss[cs[x]]+l[x]-1,*p2=ss[cs[c]]+l[c];
		for (register int i=0;i<scd[c];i++,p2++) mx((*(p1+(*p2).x)).y,(*p2).y);
		c|=1;
		p2=ss[cs[c]]+l[c];
		for (register int i=0;i<scd[c];i++,p2++) mx((*(p1+(*p2).x)).y,(*p2).y);
		scd[x]=order(ss[cs[x]]+l[x],tcd[x]);//完成ss[x]
		c^=1;
		memcpy(sl[cs[x]]+l[x],sl[cs[c]]+l[c],lcd[c]*sizeof(pt));
		ys=ssum[c];cd=tcd[c];
		lcd[x]=lcd[c];c|=1;p1=sl[cs[x]]+l[x];p2=sl[cs[c]]+l[c];
		for (register int i=0;i<lcd[c];i++,++p2) *(p1+(lcd[x]++))=pt((*p2).x+cd,(*p2).y+ys);
		tb(sl[cs[x]]+l[x],lcd[c^1],lcd[x]);//完成sl[x]
		memcpy(sr[cs[x]]+l[x],sr[cs[c]]+l[c],rcd[c]*sizeof(pt));
		ys=ssum[c];cd=tcd[c];
		rcd[x]=rcd[c];c^=1;p1=sr[cs[x]]+l[x];p2=sr[cs[c]]+l[c];
		for (register int i=0;i<rcd[c];i++,++p2) *(p1+(rcd[x]++))=pt((*p2).x+cd,(*p2).y+ys);
		tb(sr[cs[x]]+l[x],rcd[c|1],rcd[x]);
		ssum[x]=ssum[c]+ssum[c^1];
	}
	inline void pushdown(register int x)
	{
		if (lz[x])
		{
			register int c=x<<1;
			lz[c]+=lz[x];ssum[c]+=lz[x]*tcd[c];
			for (register int i=0;i<scd[c];i++) ss[cs[c]][l[c]+i].y+=lz[x]*ss[cs[c]][l[c]+i].x;
			for (register int i=0;i<lcd[c];i++) sl[cs[c]][l[c]+i].y+=lz[x]*sl[cs[c]][l[c]+i].x;
			for (register int i=0;i<rcd[c];i++) sr[cs[c]][l[c]+i].y+=lz[x]*sr[cs[c]][l[c]+i].x;
			c|=1;
			lz[c]+=lz[x];ssum[c]+=lz[x]*tcd[c];
			for (register int i=0;i<scd[c];i++) ss[cs[c]][l[c]+i].y+=lz[x]*ss[cs[c]][l[c]+i].x;
			for (register int i=0;i<lcd[c];i++) sl[cs[c]][l[c]+i].y+=lz[x]*sl[cs[c]][l[c]+i].x;
			for (register int i=0;i<rcd[c];i++) sr[cs[c]][l[c]+i].y+=lz[x]*sr[cs[c]][l[c]+i].x;
			lz[x]=0;
		}
	}
	void build(int x)
	{
		lz[x]=0;tcd[x]=r[x]-l[x]+1;
		if (l[x]==r[x])
		{
			scd[x]=lcd[x]=rcd[x]=1;
			sr[cs[x]][l[x]]=ss[cs[x]][l[x]]=sl[cs[x]][l[x]]=pt(1,ssum[x]=a[l[x]]);
			return;
		}
		register int c=x<<1;
		cs[c]=cs[c|1]=cs[x]+1;
		l[c]=l[x];r[c]=l[x]+r[x]>>1;
		l[c|1]=r[c]+1;r[c|1]=r[x];
		build(c);build(x<<1|1);
		newpushup(x);
	}
	void modify(int x)
	{
		if ((z<=l[x])&&(r[x]<=y))
		{
			lz[x]+=dt;ssum[x]+=(ll)dt*tcd[x];
			for (register int i=0;i<scd[x];i++) ss[cs[x]][l[x]+i].y+=(ll)dt*ss[cs[x]][l[x]+i].x;
			for (register int i=0;i<lcd[x];i++) sl[cs[x]][l[x]+i].y+=(ll)dt*sl[cs[x]][l[x]+i].x;
			for (register int i=0;i<rcd[x];i++) sr[cs[x]][l[x]+i].y+=(ll)dt*sr[cs[x]][l[x]+i].x;
			return;
		}
		pushdown(x);
		if (z<=r[x<<1]) modify(x<<1);
		if (y>r[x<<1]) modify(x<<1|1);
		newpushup(x);
	}
	void allpush(int x,int cnt)
	{
		cnt+=(int)lz[x];
		if (l[x]==r[x]) {b[l[x]]=a[l[x]]+cnt;return;}
		x<<=1;
		if (z<=r[x]) allpush(x,cnt);
		if (y>r[x]) allpush(x|1,cnt);
	}
public:
	void sol()
	{
		sy=ly=ry=1;
		scf=ss[0][2]-ss[0][1];
		lcf=sl[0][2]-sl[0][1];
		rcf=sr[0][2]-sr[0][1];
		if (tp<=1500) sort(stt+1,stt+tp+1); else qs(tp);
			for (register int i=1;i<=tp;i++)
			{
				while ((sy<scd[1])&&(scf^stt[i].tot))
				{
					++sy;
					scf=ss[0][1+sy]-ss[0][sy];
				}
				while ((ly<lcd[1])&&(lcf^stt[i].tot))
				{
					++ly;
					lcf=sl[0][1+ly]-sl[0][ly];
				}
				while ((ry<rcd[1])&&(rcf^stt[i].tot))
				{
					++ry;
					rcf=sr[0][1+ry]-sr[0][ry];
				}
				mx(ans[stt[i].wz],max(lsum[stt[i].wz]+sl[0][ly].y+sl[0][ly].x*stt[i].tot,ss[0][sy].y+ss[0][sy].x*stt[i].tot));
				lsum[stt[i].wz]=max(lsum[stt[i].wz]+stt[i].tot*n+ssum[1],sr[0][ry].y+sr[0][ry].x*stt[i].tot);
			}
		tp=0;mt=-inf;
	}
	void init(const int nn,int *b)
	{
		mlz=tp=s[0]=0;
		for (register int i=1;i<=nn;i++) s[i]=s[i-1]+(a[i]=b[i]);
		r[l[1]=1]=n=nn;build(1);
	}
	void ask(int x)
	{

	}
	void mdf(const Q x)
	{
		if (x.tot)//询问
		{
			if ((x.y<n)||(x.z>1))
			{
				z=x.z;y=x.y;
				if ((x.y<n)&&(x.z>1))//小问
				{
					register ll ls=0,s=0;
					for (register int i=x.z;i<=x.y;i++) s=max(s,ls=max(ls,0ll)+(a[i]+(int)mlz));
					ans[x.wz]=s;
				}
				else if (x.y<n)
				{
					register ll ls=lsum[x.wz],s=0;
					for (register int i=x.z;i<=x.y;i++) s=max(s,ls=max(ls,0ll)+(a[i]+(int)mlz));
					mx(ans[x.wz],s);
				}
				else
				{
					register ll ls=0,s=0;
					for (register int i=x.z;i<=x.y;i++) s=max(s,ls=max(ls,0ll)+(a[i]+(int)mlz));
					ans[x.wz]=s;lsum[x.wz]=ls;
				}
				return;
			}
			else
			{
				mt=min(mt,stt[++tp].tot=mlz);stt[tp].wz=x.wz;
			}
		}
		else//修改
		{
			if ((x.y==n)&&(x.z==1)) mlz+=x.wz;
			else
			{
				sol();
				z=x.z;y=x.y;
				if ((dt=x.wz)==INF) return;
				for (register int i=z;i<=y;i++) a[i]+=dt;
				modify(1);
			}
		}
	}
};
```

---

## 作者：SrsgPrince_ (赞：12)

# Luogu P4118 [Ynoi2018] 末日时在做什么？有没有空？可以来拯救吗？

这题是 [Luogu P5073](https://www.luogu.com.cn/problem/P5073) 的加强版，建议先做 P5073。

题面传送门：[Luogu P4118 [Ynoi2018] 末日时在做什么？有没有空？可以来拯救吗？](https://www.luogu.com.cn/problem/P4118)。

推荐在我的 [博客](https://www.luogu.com.cn/blog/fy123333/LuoguP4118Solution) 中查看。

## 题目分析 Hint

给定一个长度为 $n$ 的序列，有 $m$ 次操作。

1. `1 l r x` 把区间 $[l,r]$ 的数字都加上 $x$。
2. `2 l r` 查询区间 $[l,r]$ 的最大子段和。

做过 P5073 的会感觉到有点熟悉，这题总感觉哪里见过。没错，这题是 P5073 的加强版，P5073 中的操作 $1$ 是全局加，只不过这题是区间加。

先给出前置知识：

1. 线段树与分块（十分的基础的知识）。
2. 最大子段和，不会可以先出门左转做 [Luogu P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)。
3. 凸包、闵可夫斯基和以及 Jarvis（具体哪里会用到及其原因在后面会提到）。
4. $\operatorname{RadixSort()}$，基数排序（这题要优化，所以要使用到基数排序）。

## 思路 Solution

首先先看简单一点的，就是不带修的最大子段和，这个很简单维护每个点的区间和，区间最大后缀和，区间最大前缀和，区间最大子段和，得出 $$sum_i=sum_{lson}+sum_{rson}$$ $$lmax=\max(lmax_{lson},sum_{lson}+lmax_{lson})$$ $$rmax_i=\max(rmax_{rson},sum_{rson}+rmax_{lson})$$ $$mx_i=\max(mx_{lson},\max(mx_{rson},rmax_{lson}+lmax_{rson}))$$

然后加上修改，先弱化一下，先考虑在 P5073 中出现的全局加。那么用区间前缀和去维护长度为 $x$ 的前缀和，记这个凸函数为 $lmax(x)$，区间后缀和维护一个长度为 $x$ 的后缀和，记为 $rmax(x)$，当全局加上一个数，我们暂且把它先叫做 $\varepsilon$，那么不难看出最大化是 $lmax(x) + \varepsilon x(rmax(x) + \varepsilon x)$，那么这就可以分块之后对每一个块建树，用凸包二分做，这里还用到了 Jarvis 步进法。

然后就是区间最大子段和，维护长度为 $x$ 的子段和的最大值，记为 $mx(x)$。我们求这个函数值只能通过取线段树上两个子节点，分别是 $rmax_{lson}(x)$ 与 $lmax_{rson}(y)$，能推出来 $mx(x+y)$ 就是 $rmax_{lson}(x) + lmax_{rson}(y)$。那么就能够通过 $rmax_{lson}(x)$ 与 $lmax_{rson}(y)$ 的闵可夫斯基和以及 $\max(mx_{lson}, mx_{rson})$，求出来 $mx$。对于一个大小为 $x$ 的节点我们就可以用 $O(x)$ 来求这个点的所有凸包。每次询问的复杂度为 $O(\log^2 n)$。但是这题和 P5073 不一样，不需要把这个复杂度降到 $O(\log n)$，而且打标记只要不是打在根节点上都等于暴力，也就是说这里的线段树并不支持快速区间修改，所以还是有一点不一样的。但是你会发现这个复杂度有点问题，单个修改和整体查询的复杂度不可接受，需要优化。

先考虑第一个，单个修改的优化。首先注意，这里不能全部重构线段树，否则 T 疯了。我们刚才说过，这里的线段树不支持区间加，支持整体加。所以我们在修改的时候给节点打标记，其它的重构，下放部分先打一个要下放的整体加的标记，然后在凸包上维护一个不下放的标记。

接下来是整体查询的优化。这里需要用到逐块处理，这里没有强制在线，于是可以用到这个逐块处理。做法是先把查询时整体加标记的值升序排一下，然后用一个指针向右走。重构时把这个指针重置就行。但是这个排序我们还需要优化，考虑换成计数排序，那么这个复杂度就可接受了，总复杂度约是 $O(m \log n)$。但我们还需要优化，在维护凸包的时候，我们尽量用数组和指针，这样就会减少 vector 的动态内存分配，然后就是块长，我取的是 $512$。

接下来放出代码。

```cpp
#define got(x,len) (((x)-1)/(len)+1)
#define LB(x,len) (((x)-1)*(len)+1)
#define RB(x,len) min(((x)*(len)),n)
struct Question{
    int op=0,lft=0,rgt=0;
    long long v=0;
}que[maxn];
namespace KamisatoAyaka{
    int blk[maxn/maxs+5],brgt[maxn/maxs+5],pos[maxn],tot;
    struct Point{
        long long x,y;
        inline Point operator+(register const Point &b)const{
            return{x+b.x,y+b.y};
        }
        inline Point operator-(register const Point &b)const{
            return{x-b.x,y-b.y};
            }
        inline bool operator <=(register const Point &b)const{
            return x*b.y>=y*b.x;
        }
    } pool[maxn];
    struct Hull{
        Point *pnt;
        int siz,mxpnt;
        long long tag;
        inline Point operator [](register const int x){
            return{pnt[x].x,pnt[x].y+tag*pnt[x].x};
        }
        inline void insert(register Point x){
            pnt[x.x].y=max(pnt[x.x].y,x.y);
        }
        inline void pushBack(register Point x){
            pnt[siz++]=x;
        }
        inline void init(register int len){
            pnt[0]={0,0},siz=len+1,tag=0;
            for(register int i=1;i<=len;++i) 
                pnt[i]={i,-inf};
        }
        inline void Jarvis(){
            if(siz<=2) return;
            int top=1;
            for(register int i=2;i<siz;++i){
                if(pnt[i].y==-inf) continue;
                while(top>=1&&(pnt[top]-pnt[top-1]) <=(pnt[i]-pnt[top-1]))
                    --top;
                pnt[++top]=pnt[i];
            }
            siz=top+1,tag=0;
        }
        inline bool check(register int x,register long long addv){
            return(pnt[x+1].x-pnt[x].x)*(tag+addv)+pnt[x+1].y-pnt[x].y>0;
        }
        inline long long Maxv(register long long addv){
            while(mxpnt<siz-1&&check(mxpnt,addv))
                ++mxpnt;
            return pnt[mxpnt].x*(tag+addv)+pnt[mxpnt].y;
        }
        inline long long MaxvBS(register long long addv){
            register int lft=-1,rgt=siz-1,mid;
            for(mid=lft+rgt>>1;lft<rgt-1;mid=lft+rgt>>1)
                if(check(mid,addv))
                    lft=mid;
                else 
                    rgt=mid;
            mxpnt=rgt;
            return pnt[mxpnt].x*(tag+addv)+pnt[mxpnt].y;
        }
    };
    struct AyakaNode{
        long long lmax,rmax,midmax,sum;
        inline AyakaNode operator+(const AyakaNode &b)const{
            return{max(lmax,sum+b.lmax),max(rmax+b.sum,b.rmax),max(max(midmax,b.midmax),rmax+b.lmax),sum+b.sum};
        }
    } res[maxn];
    struct LineTree{
        Hull lmax[maxs<<2],rmax[maxs<<2],midmax[maxs<<2];
        long long sum[maxs<<2],tag[maxs<<2];
        inline void init(register int rt,register int lft,register int rgt){
            lmax[rt].pnt=pool+tot;
            tot+=rgt-lft+3;
            rmax[rt].pnt=pool+tot;
            tot+=rgt-lft+3;
            midmax[rt].pnt=pool+tot;
            tot+=rgt-lft+3;
            if(lft==rgt) return;
            int mid=(lft+rgt)>>1;
            init(rt<<1,lft,mid);
            init(rt<<1|1,mid+1,rgt);
        }
        inline void preSufMerge(register Hull &c,register Hull &a,register Hull &b,register Point addb){
            for(register int i=0,t=a.siz;i<t;++i)
                c.pushBack(a[i]);
            for(register int i=0,t=b.siz;i<t;++i)
                c.pushBack(addb+b[i]);
            c.Jarvis();
        }
        inline void Minkowski(register Hull &c,register Hull &a,register Hull &b){
            int i=0,j=0,sa=a.siz-1,sb=b.siz-1;
            for(c.insert(a[i]+b[j]);i<sa&&j<sb;c.insert(a[i]+b[j]))
                a[i+1]-a[i]<=b[j+1]-b[j]?++j:++i;
            while(i<sa)
                c.insert(a[++i]+b[j]);
            while(j<sb)
                c.insert(a[i]+b[++j]);
        }
        inline void pushUp(register int rt,register int lft,register int rgt){
            int mid=(lft+rgt)>>1;
            preSufMerge(lmax[rt],lmax[rt<<1],lmax[rt<<1|1],{mid-lft+1,sum[rt<<1]});
            preSufMerge(rmax[rt],rmax[rt<<1|1],rmax[rt<<1],{rgt-mid,sum[rt<<1|1]});
            midmax[rt].init(rgt-lft+1);
            for(register int i=0,t=midmax[rt<<1].siz;i<t;++i)
                midmax[rt].insert(midmax[rt<<1][i]);
            for(register int i=0,t=midmax[rt<<1|1].siz;i<t;++i)
                midmax[rt].insert(midmax[rt<<1|1][i]);
            Minkowski(midmax[rt],rmax[rt<<1],lmax[rt<<1|1]);
            midmax[rt].Jarvis();
            lmax[rt].mxpnt=rmax[rt].mxpnt=midmax[rt].mxpnt=0;
            sum[rt]=sum[rt<<1]+sum[rt<<1|1];
        }
        inline void add(register int rt,register int lft,register int rgt,register long long d){
            tag[rt]+=d;
            lmax[rt].tag+=d;
            rmax[rt].tag+=d;
            midmax[rt].tag+=d;
            sum[rt]+=d*(rgt-lft+1);
        }
        inline void pushDown(register int rt,register int lft,register int rgt){
            if(lft==rgt||!tag[rt]) return;
            int mid=(lft+rgt)>>1;
            add(rt<<1,lft,mid,tag[rt]);
            add(rt<<1|1,mid+1,rgt,tag[rt]);
            tag[rt]=0;
        }
        inline void buildTree(register int rt,register int lft,register int rgt,register int bid){
            if(lft==rgt){
                sum[rt]=a[lft+blk[bid]-1];
                lmax[rt].pushBack({0,0});
                lmax[rt].pushBack({1,sum[rt]});
                rmax[rt].pushBack({0,0});
                rmax[rt].pushBack({1,sum[rt]});
                midmax[rt].pushBack({0,0});
                midmax[rt].pushBack({1,sum[rt]});
                return;
            }
            int mid=(lft+rgt)>>1;
            buildTree(rt<<1,lft,mid,bid);
            buildTree(rt<<1|1,mid+1,rgt,bid);
            pushUp(rt,lft,rgt);
        }
        inline void clear(register int rt,register int lft,register int rgt){
            lmax[rt].siz=rmax[rt].siz=midmax[rt].siz=0;
            lmax[rt].mxpnt=rmax[rt].mxpnt=midmax[rt].mxpnt=0;
            lmax[rt].tag=rmax[rt].tag=midmax[rt].tag=0;
            tag[rt]=0;
            if(lft==rgt) return;
            int mid=(lft+rgt)>>1;
            clear(rt<<1,lft,mid);
            clear(rt<<1|1,mid+1,rgt);
        }
        inline void change(register int rt,register int lft,register int rgt,register int l,register int r,register long long d){
            if(lft==l&&rgt==r)
                return add(rt,lft,rgt,d);
            pushDown(rt,lft,rgt);
            int mid=(lft+rgt)>>1;
            if(r<=mid) 
                change(rt<<1,lft,mid,l,r,d);
            else if(l>mid) 
                change(rt<<1|1,mid+1,rgt,l,r,d);
            else 
                change(rt<<1,lft,mid,l,mid,d),change(rt<<1|1,mid+1,rgt,mid+1,r,d);
            lmax[rt].siz=rmax[rt].siz=midmax[rt].siz=0;
            pushUp(rt,lft,rgt);
        }
        inline AyakaNode query(register int lft,register int rgt,register long long addv){
            return{lmax[1].Maxv(addv),rmax[1].Maxv(addv),midmax[1].Maxv(addv),sum[1]+(rgt-lft+1)*addv};
        }
        inline AyakaNode ask(register int rt,register int lft,register int rgt,register int l,register int r,register long long addv){
            if(lft==l&&rgt==r)
                return rt==1?query(l,r,addv):(AyakaNode){lmax[rt].MaxvBS(addv),rmax[rt].MaxvBS(addv),midmax[rt].MaxvBS(addv),sum[rt]+(r-l+1)*addv};
            pushDown(rt,lft,rgt);
            register int mid=(lft+rgt)>>1;
            if(r<=mid)
                return ask(rt<<1,lft,mid,l,r,addv);
            else if(l>mid)
                return ask(rt<<1|1,mid+1,rgt,l,r,addv);
            else
                return ask(rt<<1,lft,mid,l,mid,addv)+ask(rt<<1|1,mid+1,rgt,mid+1,r,addv);
        }
    };
    struct QuestionForBlock{
        int lft=0,rgt=0,id=0;
        long long v=0,typ=0;
        inline bool operator<(register const QuestionForBlock &b)const{
            return v<b.v;
        }
    };
    struct Block{
        LineTree ayaka;
        int bid,bn,bm,cnt[maxr];
        QuestionForBlock neq[maxn],tmp[maxn];
        long long tag,valt[maxn],val[maxn];
        inline void update(register long long d){
            tag+=d;
        }
        inline void change(register int lft,register int rgt,register long long d){
            if(d==0) return;
            if(lft==1&&rgt==bn)
                return tag+=d,void();
            neq[bm++]={lft,rgt,0,tag,d};
        }
        inline void query(register int lft,register int rgt,register int id){
            neq[bm++]={lft,rgt,id,tag,0};
        }
        #define geted(x,d)(((x)>>((d)*bit))&(maxr-1))
        inline void radixSort(register int lft,register int rgt){
            if(rgt-lft<=1500) 
                return sort(neq+lft,neq+rgt),void();
            register long long *x=val,*y=valt;
            register int tt=rgt-lft;
            for(register int i=lft;i<rgt;++i) 
                x[i-lft]=y[i-lft]=neq[i].v|((1ll*i)<<35);
            for(register int d=0;d<4;++d){
                for(register int i=0;i<maxr;++i) 
                    cnt[i]=0;
                for(register int i=0;i<tt;++i) 
                    ++cnt[geted(x[i],d)];
                for(register int i=1;i<maxr;++i) 
                    cnt[i]+=cnt[i-1];
                for(register int i=tt-1;i>=0;--i)
                     y[--cnt[geted(x[i],d)]]=x[i];
                swap(x,y);
            }
            for(register int i=lft;i<rgt;++i) 
                tmp[i-lft]=neq[i];
            for(register int i=lft;i<rgt;++i) 
                neq[i]=tmp[(x[i-lft]>>35)-lft];
        }
        inline void init(){
            register long long mintag=0;
            for(register int i=0;i<bm;++i) 
                mintag=min(mintag,neq[i].v);
            for(register int i=0;i<bm;++i) 
                neq[i].v-=mintag;
            for(register int i=blk[bid],t=brgt[bid];i<=t;++i) 
                a[i]+=mintag;
            ayaka.buildTree(1,1,bn,bid);
            register int last=0;
            for(register int i=0;i<bm;++i)
                if(neq[i].typ){
                    if(i!=last)
                        radixSort(last,i);
                    last=i+1;
            }
            if(last!=bm) 
                radixSort(last,bm);
        }
        inline void solve(){
            for(register int i=0;i<bm;++i)
                if(!neq[i].typ){
                    if(i&&neq[i-1].typ){
                        ayaka.lmax[1].MaxvBS(neq[i].v);
                        ayaka.rmax[1].MaxvBS(neq[i].v);
                        ayaka.midmax[1].MaxvBS(neq[i].v);
                    }
                    res[neq[i].id]=res[neq[i].id]+ayaka.ask(1,1,bn,neq[i].lft,neq[i].rgt,neq[i].v);
                }
                else 
                    ayaka.change(1,1,bn,neq[i].lft,neq[i].rgt,neq[i].typ);
        }
        inline void clear(){
            bm=tag=0;
            ayaka.clear(1,1,bn);
        }
    } ayk;
    inline void work(){  
        register int qcnt;
        for(register int i=1;i<=n;++i) 
            pos[i]=got(i,maxs);
        for(register int i=1;i<=pos[n];++i){
            blk[i]=LB(i,maxs);
            brgt[i]=RB(i,maxs);
        }
        for(register int i=1;i<=pos[n];++i){
            qcnt=0;
            for(register int j=1;j<=m;++j){
                if(que[j].op==2)
                    ++qcnt;
                if(que[j].lft>brgt[i]||que[j].rgt<blk[i])
                    continue;
                if(que[j].op==1){
                    if(que[j].lft<=blk[i]&&que[j].rgt>=brgt[i]) 
                        ayk.update(que[j].v);
                    else 
                        ayk.change(max(que[j].lft,blk[i])-blk[i]+1,min(que[j].rgt,brgt[i])-blk[i]+1,que[j].v);
                }
                else 
                    ayk.query(max(que[j].lft,blk[i])-blk[i]+1,min(que[j].rgt,brgt[i])-blk[i]+1,qcnt);
            }
            ayk.bid=i;
            ayk.bn=brgt[i]-blk[i]+1;
            if(i==1||i==pos[n])
                tot=0,ayk.ayaka.init(1,1,ayk.bn);
            ayk.init();
            ayk.solve();
            ayk.clear();
        }
        for(register int i=1;i<=qcnt;++i)
            quickWrite(res[i].midmax,'\n');
    }
}
namespace AetherKamisatoAyaka{
    long long check[100001],nowu,cnt1,cnt2,c[100001],qf[100001];
    bool check1,hmz;
    inline void add(register long long now,register long long v){
        for(;now<=n;now+=now & -now) 
            c[now]+=v;
    }
    inline long long sum(register long long tmp){
        register long long s=0;
        for(;tmp>0;tmp -= tmp & -tmp) s+=c[tmp];
        return s;
    }
    inline void getMid(register long long pos,register long long lft,register long long rgt,register bool vis);
    inline void getMid1(register long long pos,register long long lft,register long long rgt,register bool vis);
    inline void getMid2(register long long pos,register long long lft,register long long rgt,register bool vis);
    inline void getMin(register long long pos,register long long lft,register long long rgt);
    namespace Ayakawork1{
        struct Node{
            long long lft,rgt,mid,sum,maxx,minn,tag;
            bool need;
            Node(register long long lft=0,register long long rgt=0,register long long mid=0,register long long sum=0,register long long maxx=0,register long long minn=0,register long long tag=0):lft(lft),rgt(rgt),mid(mid),sum(sum),maxx(maxx),minn(minn),tag(tag){need=0;}
        } tree[262144];
        inline Node merge(register Node x,register Node y){
            return Node(max(x.lft,x.sum+y.lft),max(y.rgt,y.sum+x.rgt),max(max(x.mid,y.mid),x.rgt+y.lft),x.sum+y.sum,max(x.maxx,y.maxx),min(x.minn,y.minn),0ll);
        }
        inline void pushDown(register long long now,register long long lft,register long long rgt){
            register long long mid=(lft+rgt)>>1;
            if(tree[now].tag!=0){
                long long mid=(lft+rgt)>>1;
                tree[now<<1].sum +=(mid-lft+1)*tree[now].tag;
                tree[now<<1|1].sum +=(rgt-mid)*tree[now].tag;
                tree[now<<1].tag+=tree[now].tag;
                tree[now<<1|1].tag+=tree[now].tag;
                tree[now<<1].maxx+=tree[now].tag;
                tree[now<<1|1].maxx+=tree[now].tag;
                tree[now<<1].minn+=tree[now].tag;
                tree[now<<1|1].minn+=tree[now].tag;
                tree[now<<1].lft=tree[now<<1].rgt=tree[now<<1].mid=max(tree[now<<1].sum,0ll);
                tree[now<<1|1].lft=tree[now<<1|1].rgt=tree[now<<1|1].mid=max(tree[now<<1|1].sum,0ll);
                tree[now].tag=0;
            }
            if(tree[now].need&&lft!=rgt){
                tree[now<<1].need=true;
                tree[now<<1|1].need=true;
                getMid(now<<1,lft,mid,true);
                getMid(now<<1|1,mid+1,rgt,true);
                tree[now].need=false;
            }
        }
        inline void buildTree(register long long now,register long long lft,register long long rgt){
            if(lft==rgt){
                tree[now].need=false;
                tree[now].lft=tree[now].rgt=tree[now].mid=max(a[lft],0ll);
                tree[now].sum=tree[now].minn=tree[now].maxx=a[lft];
                tree[now].tag=0;
                return;
            }
            tree[now].need=false;
            register long long mid=(lft+rgt)>>1;
            buildTree(now<<1,lft,mid),buildTree(now<<1|1,mid+1,rgt);
            tree[now]=merge(tree[now<<1],tree[now<<1|1]);
        }
        inline void update(register long long now,register long long lft,register long long rgt,register long long x,register long long y,register long long w){
            if(lft>y||rgt<x) return;
            if(x<=lft&&rgt<=y){
                if(tree[now].maxx+w<=0||tree[now].minn+w>=0){
                    tree[now].sum +=(rgt-lft+1)*w;
                    tree[now].tag+=w;
                    tree[now].maxx+=w;
                    tree[now].minn+=w;
                    tree[now].lft=tree[now].rgt=tree[now].mid=max(tree[now].sum,0ll);
                    tree[now].need=false;
                    return;
                }
                else if((!check1&&rgt-lft+1<=500) ||(check1&&rgt-lft+1<=5000)){
                    tree[now].sum +=(rgt-lft+1)*w;
                    tree[now].tag+=w;
                    tree[now].maxx+=w;
                    tree[now].minn+=w;
                    tree[now].need=true;
                    getMid(now,lft,rgt,true);
                    return;
                }
            }
            if(rgt-lft+1<=500){
                getMin(now,lft,rgt);
                if(tree[now].maxx<=0||tree[now].minn>=0) 
                    tree[now].mid=tree[now].lft=tree[now].rgt=max(0ll,tree[now].sum);
                else 
                    getMid(now,lft,rgt,true);
                return;
            }
            pushDown(now,lft,rgt);
            register long long mid=(lft+rgt)>>1;
            update(now<<1,lft,mid,x,y,w);
            update(now<<1|1,mid+1,rgt,x,y,w);
            tree[now]=merge(tree[now<<1],tree[now<<1|1]);
        }
        inline Node query(register long long now,register long long lft,register long long rgt,register long long x,register long long y){
            if(x<=lft&&rgt<=y)
                return tree[now];
            if(lft<=x&&rgt<=y&&(rgt-x+1)<=700&&(tree[now].need||rgt-x<=500))
                return getMid(0,x,rgt,true),tree[0];
            if(lft>=x&&rgt>=y&&(y-lft+1)<=700&&(tree[now].need||y-lft<=500))
                return getMid(0,lft,y,true),tree[0];
            register long long mid=(lft+rgt)>>1;
            pushDown(now,lft,rgt);
            Node res;
            if(x>mid) 
                res=query(now<<1|1,mid+1,rgt,x,y);
            else if(y<=mid)
                res=query(now<<1,lft,mid,x,y);
            else {
                Node resa=query(now<<1,lft,mid,x,y),resb=query(now<<1|1,mid+1,rgt,x,y);
                res=Node(max(resa.lft,resa.sum+resb.lft),max(resb.rgt,resb.sum+resa.rgt),max(resa.mid,max(resb.mid,resa.rgt+resb.lft)),resa.sum+resb.sum,0ll,0ll,0ll);
            }
            tree[now]=merge(tree[now<<1],tree[now<<1|1]);
            return res;
        }
    }
    namespace Ayakawork2{
        long long eps;
        struct Node{
            long long lft,rgt,mid,sum,maxx,minn,tag;
            bool check;
        } tree[262144];
        inline bool get(register Node now,register long long len){
            return(now.maxx<=0||now.minn>=0);
        }
        inline void pushDown(register long long now,register long long lft,register long long rgt){
            long long mid=(lft+rgt)>>1;
            tree[now<<1].sum+=(mid-lft+1)*tree[now].tag,
            tree[now<<1|1].sum+=(rgt-mid)*tree[now].tag;
            tree[now<<1].tag+=tree[now].tag,
            tree[now<<1|1].tag+=tree[now].tag;
            tree[now<<1].maxx+=tree[now].tag,
            tree[now<<1|1].maxx+=tree[now].tag;
            tree[now<<1].minn+=tree[now].tag,
            tree[now<<1|1].minn+=tree[now].tag;
            tree[now<<1].check=get(tree[now<<1],mid-lft+1);
            tree[now<<1|1].check=get(tree[now<<1|1],rgt-mid);
            tree[now].tag=0;
        }
        inline Node merge(register Node x,register Node y,register long long len){
            Node res={max(x.lft,x.sum+y.lft),max(y.rgt,y.sum+x.rgt),max(max(x.mid,y.mid),x.rgt+y.lft),x.sum+y.sum,max(x.maxx,y.maxx),min(x.minn,y.minn)};
            if(x.check||y.check)
                res.check=true;
            else 
                res.check=false;
            return res;
        }
        inline void buildTree(register long long now,register long long lft,register long long rgt){
            tree[now].tag=0;
            tree[now].check=false;
            if(lft==rgt){
                tree[now].maxx=tree[now].minn=tree[now].sum=a[lft];
                return;
            }
            register long long mid=(lft+rgt)>>1;
            buildTree(now<<1,lft,mid);
            buildTree(now<<1|1,mid+1,rgt);
            tree[now]=merge(tree[now<<1],tree[now<<1|1],rgt-lft+1);
        }
        inline void update(register long long now,register long long lft,register long long rgt,register long long x,register long long y,register long long w){
            if(lft>y||rgt<x) return;
            if(x<=lft&&rgt<=y){
                tree[now].sum +=(rgt-lft+1)*w;
                tree[now].maxx+=w;
                tree[now].minn+=w;
                tree[now].tag+=w;
                if((tree[now].maxx<=0||tree[now].minn>=0)&&rgt-lft+1>=eps)
                    tree[now].check=true;
                else
                    tree[now].check=false;
                return;
            }
            pushDown(now,lft,rgt);
            register long long mid=(lft+rgt)>>1;
            update(now<<1,lft,mid,x,y,w);
            update(now<<1|1,mid+1,rgt,x,y,w);
            tree[now]=merge(tree[now<<1],tree[now<<1|1],rgt-lft+1);
        }
        inline Node query(register long long now,register long long lft,register long long rgt,register long long x,register long long y){
            tree[now].check=get(tree[now],rgt-lft+1);
            if(lft>y||rgt<x)
                return Node{-10000000,-10000000,-10000000,0,0,0,0,0};
            if(x<=lft&&rgt<=y){
                if(tree[now].maxx<=0||tree[now].minn>=0){
                    tree[now].lft=tree[now].rgt=tree[now].mid=max(tree[now].sum,0ll);
                    return tree[now];
                }
                else if(rgt-lft+1<=300){
                    getMid(now,lft,rgt,false);
                    return tree[now];
                }
            }
            Node res;
            pushDown(now,lft,rgt);
            register long long mid=(lft+rgt)>>1;
            if(lft>mid) 
                res=query(now<<1,lft,mid,x,y);
            else if(rgt<=mid) 
                res=query(now<<1|1,mid+1,rgt,x,y);
            else{
                Node a=query(now<<1,lft,mid,x,y),b=query(now<<1|1,mid+1,rgt,x,y);
                res={max(a.lft,a.sum+b.lft),max(b.rgt,b.sum+a.rgt),max(max(a.mid,b.mid),a.rgt+b.lft),a.sum+b.sum,max(a.maxx,b.maxx),min(a.minn,b.minn)};
            }
            tree[now]=merge(tree[now<<1],tree[now<<1|1],rgt-lft+1);
            return res;
        }
    }
    inline void work(){
        register long long lft,rgt,w;
        for(register long long i=1;i<=n;++i)
            qf[i]=a[i]-a[i-1],add(i,qf[i]);
        Ayakawork1::buildTree(1,1,n);
        for(register long long k=1;k<=m;++k){
            lft=que[k].lft;
            rgt=que[k].rgt;
            w=que[k].v;
            if(!lft) 
                ++lft;
            nowu=lft;
            if(!hmz){
                if(que[k].op==1){
                    qf[lft]+=w;
                    qf[rgt+1]-=w;
                    add(lft,w);
                    add(rgt+1,-w);
                    Ayakawork1::update(1,1,n,que[k].lft,que[k].rgt,que[k].v);
                }
                else{
                    if(rgt-lft+1<=50000){
                        register long long res=0,now=0,qlft=sum(lft),i;
                        for(i=lft;i<=rgt-11;i+=12){
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+1];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+2];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+3];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+4];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+5];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+6];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+7];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+8];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+9];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+10];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+11];
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[i+12];
                        }
                        while(i<=rgt){
                            now=(now<0?0:now)+qlft;
                            res=(res>now?res:now);
                            qlft+=qf[++i];
                        }
                        quickWrite(res,'\n');
                    }
                    else
                        quickWrite(Ayakawork1::query(1,1,n,que[k].lft,que[k].rgt).mid,'\n');
                }
            }
        }
    }
    inline void getMid(register long long pos,register long long lft,register long long rgt,register bool vis){
        if(!pos||!vis||!check1 ||(lft!=nowu&&Ayakawork1::tree[pos].maxx>=1e8+1e5)) 
            getMid1(pos,lft,rgt,vis);
        else 
            getMid2(pos,lft,rgt,vis);
    }
    inline void getMid1(register long long pos,register long long lft,register long long rgt,register bool vis){
        register long long res[3]={0,0,0},now[3]={0,0,0},qlft=sum(lft),i;
        for(i=lft;i<=rgt-3;i+=4){
            now[1]+=qlft;
            res[1]=(res[1]>now[1]?res[1]:now[1]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+1];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[1]+=qlft;
            res[1]=(res[1]>now[1]?res[1]:now[1]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+2];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[1]+=qlft;
            res[1]=(res[1]>now[1]?res[1]:now[1]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+3];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[1]+=qlft;
            res[1]=(res[1]>now[1]?res[1]:now[1]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+4];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
        }
        while(i<=rgt){
            now[1]+=qlft;
            res[1]=(res[1]>now[1]?res[1]:now[1]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+1];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            ++i;
        }
        if(vis){
            Ayakawork1::tree[pos].lft=res[1];
            Ayakawork1::tree[pos].rgt=now[2];
            Ayakawork1::tree[pos].mid=res[2];
        }
        else{
            Ayakawork2::tree[pos].lft=res[1];
            Ayakawork2::tree[pos].rgt=now[2];
            Ayakawork2::tree[pos].mid=res[2];
        }
    }
    inline void getMid2(register long long pos,register long long lft,register long long rgt,register bool vis){
        register long long now[3]={0,0,0},qlft=sum(lft),i,res[3]={0,0,0};
        for(i=lft;i<=rgt-12;i+=13){
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+1];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+2];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+3];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+4];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+5];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+6];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+7];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+8];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+9];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+10];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+11];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+12];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+13];
            res[2]=(res[2]>now[2]?res[2]:now[2]);
        }
        while(i<=rgt){
            now[2]=(now[2]<0?0:now[2])+qlft;
            qlft+=qf[i+1];
            res[2]=(res[2]>now[2]?res[2]:now[2]),
            ++i;
        }
        if(vis){
            Ayakawork1::tree[pos].lft=res[1];
            Ayakawork1::tree[pos].rgt=now[2];
            Ayakawork1::tree[pos].mid=res[2];
        }
        else{
            Ayakawork2::tree[pos].lft=res[1];
            Ayakawork2::tree[pos].rgt=now[2];
            Ayakawork2::tree[pos].mid=res[2];
        }
    }
    inline void getMin(register long long pos,register long long lft,register long long rgt){
        register long long i,sm=0,maxx=-1e10,minn=1e10,qlft=sum(lft);
        for(i=lft;i<=rgt-11;i+=12){
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+1];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+2];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+3];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+4];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+5];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+6];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+7];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+8];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+9];
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+10];
            sm+=qlft;maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+11];
            sm+=qlft;maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[i+12];
        }
        while(i<=rgt){
            sm+=qlft;
            maxx=(maxx<qlft?qlft:maxx);
            minn=(minn<qlft?minn:qlft);
            qlft+=qf[++i];
        }
        Ayakawork1::tree[pos].sum=sm;
        Ayakawork1::tree[pos].maxx=maxx;
        Ayakawork1::tree[pos].minn=minn;
    }
}
```

这道题全部的代码我写了 $946$ 行，然后调了我 $5$ 个小时，真折磨，不过总算是给弄过了。Ynoi 我估计是不再碰了（名题基本上也刷过一遍了）。


---

## 作者：zhenghanyun (赞：11)

## 「深潜循藏第六分块」

**【前置芝士】：分块，线段树，凸包，Minkowski Sum**

题目链接：[Link](https://www.luogu.com.cn/problem/P4118)

### Part 1 从弱化版说起

首先我们看一道 [弱化版](https://www.luogu.com.cn/problem/P5073)，修改是全局操作。

类似 [小白逛公园](https://www.luogu.com.cn/problem/P4513) 的思路，使用线段树进行对每个结点维护 $sum, lmax, rmax, ans$ 分别表示区间和，区间最大前缀和，区间最大后缀和，区间最大子段和。

合并两个相邻区间的答案，有

$$sum = sum_l + sum_r$$

$$lmax = \max\{lmax_l, sum_l + lmax_r\}$$

$$rmax = \max\{rmax_r, sum_r + rmax_l\}$$

$$ans = \max\{ans_l, ans_r, rmax_l + lmax_r\}$$

可以 $\mathcal{O}(1)$ 进行。

而这题带上全局加操作，我们无法很好地对每个结点动态维护 $lmax, rmax, ans$ 三个变量的值。

而如果我们对于每个结点的每个长度都维护一个 $lsum_x, rsum_x, res_x$ 分别表示长度为 $x$ 的前缀和，后缀和，以及长度为 $x$ 的最大和，那么每次全局加 $val$ 后，有：

$$lsum_x \gets lsum_x + x \times val$$

$$rsum_x \gets rsum_x + x \times val$$

$$res_x \gets res_x + x \times val$$

可以 $\mathcal{O}(1)$ 查询修改后的值。

这样下来，我们对于一层节点需要维护 $\mathcal{O}(n)$ 个值，总共有 $\mathcal{O}(\log n)$ 层，所以一共需要维护 $\mathcal{O}(n \log n)$ 个值。

为了方便下面的合并以及查询，对于每个结点我们并不维护整个数组，而是只维护所有**可能成为最大值**的元素。

那么，什么样的元素是可能成为最大值的呢？通过观察可以发现，如果我们将 $(x, lsum_x)$ 看做一个平面直角坐标系上的点，那么只有**上凸壳**上的点才有可能成为最大值，$rsum$ 与 $res$ 同理。

那么我们只需要维护上凸壳就可以了，建树时 pushup 合并过程如下：

- 维护 $lsum$ 时，将右子树的 $lsum$ 上凸壳所有点加上 $(len_l, sum_l)$ 再与左子树上的 $lsum$ 上凸壳合并求出新的上凸壳，$len_l$ 为左子树对应结点长度。

- 维护 $rsum$ 与维护 $lsum$ 同理。

- 维护 $res$ 时，先用左子树的 $rsum$ 与右子树的 $lsum$ 上凸壳算 Minkowski Sum，然后再用左右子树的 $res$ 上凸壳更新，并重新求出上凸壳。

这里解释一下为什么要用左子树的 $rsum$ 与右子树的 $lsum$ 上凸壳算 Minkowski Sum，注意到更新时

$$res_{x_1 + x_2} \gets \max\{res_{x_1 + x_2}, rsum_{x_1} + lsum_{x_2}\}$$

即将对应节点的横纵坐标相加，也就是求 Minkowski Sum。

这样 pushup 的时间复杂度是 $\mathcal{O}(len)$ 的，其中 $len$ 为结点长度。

于是我们成功在 $\mathcal{O}(n \log n)$ 的时间复杂度内建出了一颗线段树，然而这棵线段树似乎不支持修改。

但是这里是全局加，所以我们可以不修改，每次询问的时候带参数 $tag$ 进去，表示当前全局加了多少。

把询问按 $tag$ 排序可以使每次询问的 $tag$ 单调不减，而此时每个结点对应的区间最大前缀 / 后缀和，区间最大子段和的长度也一定单调不减。

所以我们可以将询问区间拆分成 $\mathcal{O}(\log n)$ 个线段树上的结点，再使用单指针维护，均摊单个节点单次查询时间复杂度为 $\mathcal{O}(1)$。

总时空复杂度 $\mathcal{O}((n + m) \log n)$，这个空间复杂度不能通过弱化版，需要进行优化，但和本题正解关系不大，所以不再赘述。

### Part 2 本题思路

本题需要使用分块，将原序列分成 $\mathcal{O}(\sqrt n)$ 个块，逐块处理修改与询问。

那么一共会产生 $\mathcal{O}(m)$ 个散块询问 / 修改，以及 $\mathcal{O}(m \sqrt n)$ 次整块询问 / 修改。

整块修改与整块 / 散块询问的处理方式与弱化版类似，按 $tag$ 排序部分需要使用基数排序，$base$ 取 $256$ 比较快。

不难发现，整块查询只在根节点询问，所以均摊时间复杂度其实是 $\mathcal{O}(1)$ 的。

散块查询建议直接暴力，虽然时间复杂度高达 $\mathcal{O}(\sqrt n)$，但常数较小，跑得可能会比在线段树上查询更快。

散块修改打懒标记，和普通线段树类似，由于 pushup 的时间复杂度是 $\mathcal{O}(len)$，所以修改时间复杂度为 $\mathcal{O}(\sqrt n)$，注意修改完成后要将单指针复位，并重新处理接下来的整块查询。

总时间复杂度 $\mathcal{O}(m \sqrt n)$，由于逐块处理，所以所有块可以共用一段空间，空间复杂度可达线性。

### Part 3 常数优化

感觉这道题目卡常难度比想象中低不少，可能是因为我 Coding 的时候常数就比较小，以下是一些小建议：

- 快读快输，函数前 `inline` 等卡常。

- 乱改块长。

- 数组访问比较慢，可以使用指针优化数组访问。

- 基数排序不要用 `vector` 数组，用链式前向星，`Next` 里面最好存指针而不是存下标。

- $lsum$ 从左往右存，$rsum$ 从右往左存，复制数组时 `memcpy` 会快一点。

本人使用以上优化可以轻松在 $800$ 毫秒以内跑过。

### Part 4 一句闲话

**说句闲话：研究珂学的最好方法是**

**A 了这道题**

祝你们成功（滑稽

---

## 作者：金珂拉 (赞：11)

因为大家写的都是序列分块基数排序套闵可夫斯基和，于是我来写一个既不用序列分块也不用闵可夫的对时间轴分块加普通凸包的版本。

时间轴分块是好文明。

## 弱化版

首先，先考虑一个全局修，全局查最大前缀和、最小前缀和，以及一个全局最大子段和的结构怎么做？

先将整个序列做一个前缀和。考虑第 $i$ 个位置，全局加了 $d$ 之后，这个位置上的值变为 $S_i={S_i}_0+i\times d$

这是一个关于 $d$ 的一次函数。于是我们把它当作一条直线，于是我们只需要维护这个 $S_i$ 即可。

我们发现这两个东西可以看成多个半平面的交，且半平面是递增的。于是我们考虑每个点维护由这多个直线分别构成的上凸壳和下凸壳。

下凸壳同理。

然后考虑全局最大子段和。

我们对每个点维护 $R,L$ 两个数组，表示以这个点为左端点/右端点的所有序列中至少有一个非负需要的最小的加值。

这个可以在 $i-S$ 图里迅速线性维护。具体的，我们考虑 $L$，则有

$$
	L(i)=\min{\dfrac{S_i-S_j}{j-i}}=-\max \dfrac{S_i-S_j}{i-j}
$$

于是我们就可以维护一个斜率优化了。具体的，我们从右往左扫描过去，每次往当前的凸包里加一个数的同时在当前凸包里做一下。

容易发现答案是单调的，因此我们可以直接在凸包上暴力做，时间复杂度 $O(N)$

然后我们考虑如何根据这个计算最大子段和。容易想到的是，最大子段一定是极大子段：若有一个子段 $B$ 与子段 $A$ 相交、相接触或相包含，则合并 $A$ 与 $B$ 后得到的子段和一定大于 $B$ 的子段和。

于是我们就可以考虑到，极大子段中一定不存在负数前缀和与负数后缀和。即，一个极大子段内的所有数，都满足以其为左端点/右端点的子段中至少有一个比他大。

然后我们就想到维护按照左右边界维护极大子段，然后随着 $d$ 的增加按顺序合并极大子段，并且最后把所有极大子段转一次函数放到凸包里就行。


## 强化版

我们发现这次是区间修。

于是我们每 $\sqrt N$ 个询问分一组。

这样子，序列就被这些询问分成了 $O(\sqrt N)$ 个部分。考虑每一部分，发现都可以看作一个全局修，全局查。

于是我们就直接线性地求出每个区间的最大前缀和，最小前缀和，最大子段和的凸包，然后对每个询问通过全局的排序（这里可以直接每组排序一次或者整体排序，因此不需要基数排序了）处理掉的情况，最终就直接普通的递推合并即可。

最终复杂度 $O(\dfrac M{\sqrt N}N+M\sqrt N) =O(M\sqrt N)$

代码咕了。

---

## 作者：添哥 (赞：9)

2022.7.30upd: 修改了一个小错误。

# 深浅值藏的第六分块

**注：本题解如无特殊说明均默认 $n,m$ 同阶**
# 前置知识
-  线段树、分块

来做这题的人应该都会了吧。
- 不带修 / 单点修改区间最大子段和

这是个经典问题，不会的可以看一看 [SP1043 GSS1](https://www.luogu.com.cn/problem/SP1043) 或者 [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)。
- 线段树维护分段函数

这个其实挺难的我待会稍微讲一讲。
- 基数排序

Version5 是区间加正数所以用不着，但是这题是 Version6，也就是区间加任意数，所以需要用到基数排序。

# 弱化版
先考虑全局加区间最大子段和，即 [P5073 [Ynoi2015] 世上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)。

还记得不带修 / 单点修改区间最大子段和怎么做吗？

定义：

- $sum_i$ 为节点 $i$ 内部的和。
- $L_i$ 为 $i$ 节点内部的最大前缀和。
- $R_i$ 为 $i$ 节点内部的最大后缀和。
- $ans_i$ 为 $i$ 节点内部的最大子段和。

那么显然有：

- $sum_i=sum_{lson}+sum_{rson}$
- $L_i=\max(L_{lson},sum_{lson}+L_{lson})$
- $R_i=\max(R_{rson},sum_{rson}+R_{lson})$
- $ans_i=\max(ans_{lson},ans_{rson},R_{lson}+L_{rson})$

那么这里我们维护的是后三者的分段函数，令：

- $L(x)$
- $R(x)$
- $ans(x)$

分别为该节点整体加了 $x$ 后的最大前缀和，最大后缀和，最大子段和。它们的合并方式同上。

这里的分段函数是几段一次函数。在线段树上的每一个节点我们维护每一段的断点和一次函数参数。因为一次函数的段数是不同且与线段树节点所代表的区间长度有关，所以要基于 vector 实现。易证线段树节点所代表区间长度的总和为 $n\log n$ ，所以空间复杂度是 $O(n\log n)$。

修改的时候打一个全局的 lazytag ，查询的时候加上去即可。

查询的时候我们找到覆盖的 $\log$ 个节点，在每个节点内部二分查找断点，总时间复杂度 $O(n\log^2n)$ ，无法通过本题。

然后我们注意到，这题没有强制在线。

所以我们把操作离线下来，基数排序后转换为全局加正数。

在每一个节点内我们设置一个指针记录上次出现的一次函数段，初始指向最小段。这样每次查找时指针从上次的位置往右查，均摊之后时间复杂度为 $O(n\log n)$。

# 正片开始
上述算法不能支持区间加是因为 pushup 的时间复杂度是 $O(n)$，那么初始化时间复杂度为 $O(n\log n)$ ，但是如果单点 / 区间修改的话，单次操作时间复杂度将达到 $O(n+\frac{n}{2}+\frac{n}{4}+···+1)=O(n)$，显然是过不去的。

**那么我们想想，什么数据结构是不用 pushup 的呢？**

分块。

将序列分块，对于每个块我们都开一棵上面所讲的线段树。设块长为 $m$，那么：

- 整块查询

在线段树根节点上二分查找断点，时间复杂度 $O(\log m)$。

- 零散块查询

在线段树上所覆盖的 $\log m$ 个节点上二分查找断点，时间复杂度 $O(\log^2 m)$。

- 整块修改

对于线段树来说就是全局加，$O(1)$ 打懒惰标记即可。

- 零散块修改

重构，时间复杂度 $O(m\log m)$。

$m$ 取 $\sqrt{n}$ 最优，总时间复杂度 $O(n\sqrt{n}\log n)$。

# 优化
零散块修改的时候真的有必要把线段树整个重构吗？

还记得我们之前说的吗？这个线段树区间修改的时间复杂度是 $O(n)$ 的。

所以零散块我们直接区间修改即可，注意线段树上的懒惰标记别和分块的搞混。

这样零散块修改的时间复杂度成功优化到了 $O(m)$。

还有一个基本操作就是离线然后逐块处理，顺便把空间优化到 $O(n)$，不然这题 64MB 别想过了。

对于每个块都进行基数排序，这样可以把整块查询优化到 $O(1)$，零散块查询优化到 $O(\log n)$，不过零散块查询并不是复杂度瓶颈，所以你哪怕写个 $O(m)$ 的大暴力都不会对总时间复杂度有影响。

这里有个细节就是因为有零散块修改的存在所以不能直接基数排序，但是我们仔细一想，即使在零散块修改时把查询的指针移到最左段也没有关系，因为把指针移到最左端其实均摊一下相当于增加 $O(\sqrt{n})$ 的时间复杂度，但是每次修改时最多也只有 $2$ 个零散块。所以这部分的时间复杂度也是 $O(n\sqrt{n})$ 的。

取 $m=\sqrt{n}$，总时间复杂度为 $O(n\sqrt{n})$。

然后就做完了。

---

## 作者：王熙文 (赞：8)

提供一个最大点 656ms，总时间 7.79s 的做法，目前最优解第一。

## 思路

和主流的做法相同。

如果没有修改，这是一个经典的线段树问题：对线段树上每个区间维护 $\text{sum},\text{lmax},\text{rmax},\text{ans}$ 表示区间总和、前缀和的最大值、后缀和的最大值、最大子段和。每次合并的时候，最大子段和为两边最大子段和、左子树 $\text{rmax}$ 加右子树 $\text{lmax}$ 的最大值。

如果是全局加，上面维护的问题出于不同区间长度的增量是不同的。注意到增量是一个一次函数，所以可以对每个节点维护一个长度作为横坐标、该长度的区间最大值作为纵坐标的凸包。每次合并时 $\text{sum}$ 并不好维护，但是注意到一并记录 $\text{lmax},\text{rmax}$ 的凸包后 $\text{sum}$ 就是左子树 $\text{rmax}$ 与右子树 $\text{lmax}$ 的闵可夫斯基和。对差分数组归并排序即可。

对于查询，需要在每个线段树上的节点二分。可以将所有值离线并排序，之后就只需要双指针了。这样就解决了 [P5073](https://www.luogu.com.cn/problem/P5073)（这道题里还需要将询问和维护的东西放在一起递归以卡空间）。

对于原题，考虑分块。对于整块的修改就相当于全局加，因此对每个块维护上面的线段树。接下来整块的修改就只需要打标记了。但是问题出在，散块需要重构这个线段树，而它的构建是 $\mathcal O(B \log B)$ 的。发现散块未必需要重构，操作在散块上仍然是一个区间加。注意到一次修改，线段树每层上只有两个点需要 `push_down` 和 `push_up`（当一个区间开始被分裂后两边只有一个儿子会再次递归），所以暴力修改的复杂度是 $\mathcal O(B)$ 的。

考虑查询。注意到对每个块只需要求出 $\text{sum},\text{lmax},\text{rmax},\text{ans}$ 这四个数，然后合并即可，因此每一个块是独立的。整块的查询需要在根节点二分，时间会多一个 $\log$。两个散块修改之间每个查询本质上是整块修改标记累加的数，使用基数排序将这些数排序再双指针即可去掉一个 $\log$。使用分散层叠算法也是可以的，但是需要在线，空间可能会出问题。散块的查询只需要在线段树上做普通的查询即可。

因为每个块是独立的，所以可以逐块处理，以减少空间复杂度。

## 一些常规的卡常技巧

* 散块查询时无须 `push_down`，而是直接记录一个变量传下来 $\text{tag}$。这样它的复杂度就不是 $\mathcal O(B)$，而是 $\mathcal O(\log^2 B)$ 的了。
* 计算斜率的时候转成 `__int128` 相乘比 `double` 快。
* 做闵可夫斯基和时需要维护一个数组记录每个长度的答案是多少。在对这个数组求凸包时，没有被遍历过的位置不合并。
* `push_down` 的时候如果没有标记直接返回。
* 基数排序时桶的大小设为 $256$。一方面是因为可以卡进 cache，另一方面是因为需要做 $\mathcal O(n)$ 次基数排序（相当于散块修改的个数），如果太大了乘上 $n$ 已经过不去了。
* 对排序的长度分治，如果很大才用基数排序。或者索性将基数排序删了，实测（与分治相比）没有任何速度变化。
* 散块修改时如果修改的左端点与块的左端点重合，可以认为是整块，右端点同理。
* 将所有 `vector` 换成指针，放到一个大的内存池里。这是为了防止 `vector` 动态开空间产生的消耗。
* 排序的时候将 `pair`（一个值是标记之和，另一个值是查询的时间）压成一个数。因为题目保证了任意时刻的绝对值，所以标记之和 $\in [-4 \times 10^9,4 \times 10^9]$，再乘上 $n$ 的大小不会爆。
* 讨论区里看到的神秘块长 $B=408$，实测对于最后一个点可以快 100ms。

## 一个非常规的卡常技巧

这个技巧我之前没见过，是我自己想出来的，所以想推广一下。

考虑使用 dp 求出最佳的块的分配。发现复杂度瓶颈在散块的修改和整块的查询。对于一个块 $[L,R]$，将复杂度抽象成下面的模型：

* 对于修改 $[l,r]$，代价为 $l \in (L,R],r \in [L,R)$ 成立的个数乘上 $R-L+1$。
* 对于查询 $[l,r]$，若 $[L,R] \in [l,r]$，代价为 $k$（$k$ 为一个常数）。

普通的 dp 会超时，但是注意到贡献满足四边形不等式（可以通过简单分讨证明），因此可以使用单调栈加二分解决。计算一个块的代价时，第一类贡献可以使用前缀和解决，第二类贡献可以使用主席树解决。

但是这个 dp 是 $\mathcal O(n \log^2 n)$ 的，自身会产生一些消耗。注意到只需要一个近似的解，因此考虑强制要求块的 $r$ 是 $\text{div}$ 的倍数，这样复杂度就可以除以 $\text{div}$。

这样 dp 出来的块有可能会很长导致空间超限，因此再设一个 $\text{axlen}$ 表示最长的块，如果超过了 $\text{axlen}$，在计算贡献时直接返回极大值。这样仍然是满足四边形不等式的。

我的代码中三个参数分别为：$k=15,\text{div}=100,\text{axlen}=5000$。

这个技巧对于非随机数据的优化效果非常大。

[提交记录](https://www.luogu.com.cn/record/214716024)

---

## 作者：可爱的小棉羊 (赞：5)

### 题意

区间加，区间最大子段和。

经典题目，因为【数据删除】要让【数据删除】知道【数据删除】的【数据删除】才出名的。

### 前置知识

- 线段树，分块

这都不会做啥 Ynoi。

- 闵可夫斯基和，以及凸优化（至少得会斜率优化）

感觉这个有点脑电波，贴个[相关资料](https://www.luogu.com.cn/article/ijtvzxt8)。

- 基数排序

### 弱化弱化再弱化（单点加版本）

~~考虑维护个矩阵，就出来了，很快啊。~~

但是这个东西怎么看都不好扩展。

要是大家写过分治求最大子段和那么就显然显然再显然。

维护一个线段树每个节点维护 $sum,lmax,rmax,ansmax$。

分别表示：区间总和，区间最大前缀和，区间最大后缀和，区间最大子段和。

设带 $0$ 角标的是左半边子树信息，$1$ 为右半边，不带标为这两个区间合并后的节点。

轻易的写出合并：

$$sum=sum_0+sum_1$$

$$lmax=\max(lmax_0,sum_0+lmax_1)$$

$$rmax=\max(rmax_1,sum_1+rmax_0)$$

$$ansmax=max(rmax_0+lmax_1,ansmax_0,ansmax_1)$$

好做吧，很快呀！

### 不是那么的弱化版（全局加）

我们问题再哪里？刚才的做法要是区间加，就要打 $tag$，我们无法高速更新！

来看一个节点需要记什么才可以高速更新。

先来搞前缀，$lmax$ 我们记下这个节点所有前缀，设长度为 $x$ 的前缀记为 $(x,lmax_x)$。那么假如这个节点有个全局加上 $mrk$ 的标记。我们是不是要求 $\max i\times mrk+lmax_i$。

这个时候请你务必会一些凸函数内容，在咋样都得会斜率优化。

我们考虑一个位置什么时候可能是最大值，假设有两个前缀 $i,i'(i<i')$。$i'$ 比 $i$ 优。

$$i\times mrk+lmax_i<i'\times mrk+lmax_{i'}$$

$$\frac{lmax_{i'}-lmax_i}{i'-i}>-mrk$$

将 $(i,lmax_i)$ 看成一个点。

这是个很典的斜率形式，这启发我们只需保留上凸壳的点，同时二分一下即可搞定。

后缀，字段和同理。记长度为 $x$ 的最大值同理。

只要合并可以高速就可以了。

区间和，草过去就行了。

后缀和前缀的合并显然，只需要将左/右区间中要拼上另一段的凸壳加一个向量就可以了。

注意一个点之前被踢出凸壳，那么接下来的合并他也不用参与。

关于子段和，我们注意到他就是如下生成方式。

加入左右区间的凸壳，另外还有左区间后缀和右区间前缀进行拼接，实际就是闵可夫斯基和。

跑完记得再跑一遍凸壳，空间是 $O(n\log n)$ 的。

目前时间复杂度是 $O(n\log ^2n)$，$O(\log)$ 的区间进行二分。

还可以更优，我们记一个全局 $tag$ 表示是原序列的加上了 $tag$，询问时记住当前 $tag$，然后离线按 $tag$ 排序。

具有单调性，这样做每个区间一个指针扫过去就完事了，$O(n\log n+m\log m)$。

### 正片（原版）

直接分块，设块长为 $B$。

- 零散查询，直接二分共 $O(\log^2 B)$。

- 整体查询，二分共 $O(\log B)$。

- 零散修改直接重构 $O(B\log B)$。

- 整体修改打个标记，$O(1)$。

恭喜你，你得到了一个常数巨史的 $O(m\sqrt n\log n)$ 的做法，空间是 $O(n\log n)$，空间和时间都乌拉。

如果你聪明点会离线后一块一块查询，空间倒没有问题。

我们的复杂度瓶颈在零散修改直接重构未免太暴力了，不妨在线段树上打个 tag，对于查询时再下传，对于经过的结点根据左右区间重构，时间复杂度 $O(B)$。

对于整体查询，一个块内，我们考虑一段没有零散修改的一段，这就是刚才的那个版本，然后快排排换成基数排序，我们就可以加起来 $O(\sqrt n)$。而零散修改后将指针拉回去，考虑最多有 $O(m)$ 次的零散修改，一次多拉 $O(\sqrt n)$ 的指针，共 $O(n+m\sqrt n)$。可过。

我们的复杂度到了 $O((n+m)\sqrt n)$。对啦！

### 正正片（常数优化）

要是这能过，那么 lxl 就不叫 lxl。

- 优化 $1$：用指针不要用 vector。

- 优化 $2$：乱调块长。

- 优化 $3$：基数排序用 $256$，将下标记在后 $35$ 位，可以规避掉 vector，还可以卡进缓存。

- 优化 $4$：线段树的节点信息封装一下，有空间连续更快。

- 优化 $5$：某些地方可以循环展开。

- 优化 $6$：记录每个节点的区间长，区间左右端点，节省栈空间。

- 优化 $7$：瞎搞块长。交之前可以去拜拜菩萨。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long TMP=0;

int CNT=0;
namespace fastio
{
    const int bufl=1<<20;
    const double base1[16]={1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8,1e-9,1e-10,1e-11,1e-12,1e-13,1e-14,1e-15};
    const double base2[16]={1,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13,1e14,1e15};
    struct IN{
        FILE *IT;char ibuf[bufl],*is=ibuf,*it=ibuf;
        IN(){IT=stdin;}IN(char *a){IT=fopen(a,"r");}
        inline char getChar(){if(is==it){it=(is=ibuf)+fread(ibuf,1,bufl,IT);if(is==it)return EOF;}return *is++;}
        template<typename Temp>inline void getInt(Temp &a){a=0;int b=0,c=getChar();while(c<48||c>57)b^=(c==45),c=getChar();while(c>=48&&c<=57)a=(a<<1)+(a<<3)+c-48,c=getChar();if(b)a=-a;}
        IN& operator>>(int &a){getInt(a);return *this;}
        IN& operator>>(long long &a){getInt(a);return *this;}
    };
    struct OUT{
        FILE *IT;char obuf[bufl],*os=obuf,*ot=obuf+bufl;int Eps;long double Acc;
        OUT(){IT=stdout,Eps=6,Acc=1e-6;}OUT(char *a){IT=fopen(a,"w"),Eps=6,Acc=1e-6;}
        inline void ChangEps(int x=6){Eps=x;}
        inline void flush(){fwrite(obuf,1,os-obuf,IT);os=obuf;}
        inline void putChar(int a){*os++=a;if(os==ot)flush();}
        template<typename Temp>inline void putInt(Temp a){if(a<0){putChar(45);a=-a;}if(a<10){putChar(a+48);return;}putInt(a/10);putChar(a%10+48);}
        template<typename Temp>inline void putLeading(Temp a,int b){if(!b)return;putLeading(a/10,b-1);putChar(a%10+48);}
        template<typename Temp>inline void putDouble(Temp a){if(a<0){putChar(45);a=-a;}__int128 b=a;putInt(b);a-=b;a*=base2[Eps];b=a+Acc;putChar(46);putLeading(b,Eps);}
        OUT& operator<<(char a){putChar(a);return *this;}
        OUT& operator<<(char *a){while(*a>32)putChar(*a++);return *this;}
        OUT& operator<<(int a){putInt(a);return *this;}
        OUT& operator<<(long long a){putInt(a);return *this;}
        ~OUT(){flush();}
    };
}
using fastio::IN;
using fastio::OUT;
IN fin;
OUT fout;
#define cin fin
#define cout fout
const int J=2005;
const int N=1e5,S=408;
const long long inf=0x3f3f3f3f3f3f3f3fll;
int bl[N/S+5],br[N/S+5],qcnt,pos[100005],n,m,a[100005];
struct Point{
	long long x,y;
	Point(long long x=0,long long y=0):x(x),y(y){}
	inline Point operator + (const Point& b)const{return {x+b.x,y+b.y};}
	inline Point operator - (const Point& b)const{return {x-b.x,y-b.y};}
	inline long long operator *(const Point& b)const{return x*b.y-y*b.x;}
	inline bool operator <= (const Point& x)const{return (*this)*x<=0;}
};
Point pool[100005];
int ptop;
struct Hull{
	int mxpnt,siz;
	long long tag;
//	vector<Point>Po;
	Point * Po;
	inline Point operator [](const int& x)const{return Point(Po[x].x,Po[x].y+tag*Po[x].x);}
	inline void Push_back(Point x){Po[siz++]=x;}
	inline void Insert(Point x){Po[x.x].y=max(Po[x.x].y,x.y);}
	inline void Empty(int len){
		Po[0]=Point(0,0);
		tag=0;
		mxpnt=0;
		siz=len+1;
		for(int i=1;i<=len;i++)Po[i]=Point(i,-inf);
		
	}
	inline void Convex(){
		if(siz<=2)return;
		tag=0;
		int nsiz=1;
		for(int i=2;i<siz;i++){
			if(Po[i].y==-inf)continue;
			while(nsiz>=1&&(Po[nsiz].y==-inf||Po[i]-Po[nsiz-1]<=Po[nsiz]-Po[nsiz-1])){
//				cout<<"POP "<<Po[nsiz].x<<" "<<Po[nsiz].y<<"\n";
				nsiz--;
			}
			Po[++nsiz]=Po[i];
		}
		siz=nsiz+1;
	}
	/*
	0 0
	1 -2
	1 -2
	2 -1
	*/
	inline long long Maxn(long long addv){
		long long T=tag+addv;
		while(mxpnt<siz-1&&(Po[mxpnt+1].x-Po[mxpnt].x)*T+Po[mxpnt+1].y-Po[mxpnt].y>0)mxpnt++;
		return Po[mxpnt].x*T+Po[mxpnt].y;
	}
	inline long long Maxn_Binary(long long addv){
		long long T=tag+addv;
		int l=-1,r=siz-1;
		while(l<r-1){
			int mid=(l+r)>>1;
			if((Po[mid+1].x-Po[mid].x)*T+Po[mid+1].y-Po[mid].y>0)l=mid;
			else r=mid;
		}
		mxpnt=r;
//		CNT++;
		return Po[r].x*T+Po[r].y;
	} 
};
struct Result{
	long long lmax,rmax,sum,ansmax;
	inline Result operator +(const Result& x){return {max(lmax,sum+x.lmax),max(rmax+x.sum,x.rmax),sum+x.sum,max(x.ansmax,max(x.lmax+rmax,ansmax))};}
};
Result ans[100005];
struct Infor{
	int l,r,len;
	long long sum,tag;
	Hull rmax,lmax,ansmax;
};
Result Ans={0,0,0,0};
struct Segment_Tree{
	Infor sg[(S<<2)+5];
	inline void Mukiowski(Hull& c,Hull& a,Hull& b){
		int i=0,j=0,siza=a.siz,sizb=b.siz;
		c.Insert(a[i]+b[j]);
		while(i<siza-1&&j<sizb-1){
			if(a[i+1]-a[i]<=b[j+1]-b[j])i++;
			else j++;
			c.Insert(a[i]+b[j]);
		}
		while(i<siza-1){
			i++;
			c.Insert(a[i]+b[j]);
		}
		while(j<sizb-1){
			j++;
			c.Insert(a[i]+b[j]);
		}
	}
	inline void PreMerge(Hull& c,Hull& a,Hull& b,Point addv){
		int siza=a.siz,sizb=b.siz;
//		cout<<siza<<"\n";
		for(int i=0;i<siza;i++){
			c.Push_back(a[i]);
//			cout<<a[i].x<<" "<<a[i].y<<"\n";
		}
		for(int i=0;i<sizb;i++){
			c.Push_back(b[i]+addv);
//			cout<<(b[i]+addv).x<<" "<<(b[i]+addv).y<<"\n";
		}
//		cout<<"c:"<<"\n";
//		for(int i=0;i<c.siz;i++)cout<<c[i].x<<" "<<c[i].y<<"\n";
		c.Convex();
//		cout<<"c:"<<"\n";
//		for(int i=0;i<c.siz;i++)cout<<c[i].x<<" "<<c[i].y<<"\n";
	}
	inline void Allocate(int rt,int l,int r){
		sg[rt].lmax.Po=pool+ptop;
		ptop+=r-l+3;
		sg[rt].rmax.Po=pool+ptop;
		ptop+=r-l+3;
		sg[rt].ansmax.Po=pool+ptop;
		ptop+=r-l+3;
		if(l==r)return;
		int mid=(l+r)>>1;
		Allocate(rt<<1,l,mid);
		Allocate(rt<<1|1,mid+1,r);
	}
	inline void Push_up(int rt){
		int mid=(sg[rt].l+sg[rt].r)>>1;
//		for(int i=0;i<sg[rt<<1|1].lmax.siz;i++)cout<<(sg[rt<<1|1].lmax[i]+(Point){mid-sg[rt].l+1,sg[rt<<1].sum}).y<<" ";
//		cout<<"\n";
		PreMerge(sg[rt].lmax,sg[rt<<1].lmax,sg[rt<<1|1].lmax,Point(mid-sg[rt].l+1,sg[rt<<1].sum));
		PreMerge(sg[rt].rmax,sg[rt<<1|1].rmax,sg[rt<<1].rmax,Point(sg[rt].r-mid,sg[rt<<1|1].sum));
		sg[rt].ansmax.Empty(sg[rt].r-sg[rt].l+1);
		for(int i=0;i<sg[rt<<1].ansmax.siz;i++)sg[rt].ansmax.Insert(sg[rt<<1].ansmax[i]);
		for(int i=0;i<sg[rt<<1|1].ansmax.siz;i++)sg[rt].ansmax.Insert(sg[rt<<1|1].ansmax[i]);
		Mukiowski(sg[rt].ansmax,sg[rt<<1].rmax,sg[rt<<1|1].lmax);
		sg[rt].ansmax.Convex();
		sg[rt].lmax.mxpnt=sg[rt].rmax.mxpnt=sg[rt].ansmax.mxpnt=0;
		sg[rt].lmax.tag=sg[rt].rmax.tag=sg[rt].ansmax.tag=0;
		sg[rt].sum=sg[rt<<1].sum+sg[rt<<1|1].sum;
		return;
	}
	inline void Build(int rt,int L,int R){
		sg[rt].l=L,sg[rt].r=R,sg[rt].tag=0;
		sg[rt].len=R-L+1;
		sg[rt].lmax.siz=0;
		sg[rt].rmax.siz=0;
		sg[rt].ansmax.siz=0;
		sg[rt].lmax.tag=0;
		sg[rt].rmax.tag=0;
		sg[rt].ansmax.tag=0;
		sg[rt].lmax.mxpnt=0;
		sg[rt].rmax.mxpnt=0;
		sg[rt].ansmax.mxpnt=0;
		if(L==R){
			sg[rt].sum=a[L+TMP];
//			sg[rt].rmax.Push_back(Point(0,0));
//			sg[rt].lmax.Push_back(Point(0,0));
//			sg[rt].ansmax.Push_back(Point(0,0));
			sg[rt].rmax.Push_back(Point(1,a[L+TMP]));
			sg[rt].lmax.Push_back(Point(1,a[L+TMP]));
			sg[rt].ansmax.Push_back(Point(1,a[L+TMP]));
			return;
		} 
		int mid=(L+R)>>1;
		Build(rt<<1,L,mid),Build(rt<<1|1,mid+1,R);
		Push_up(rt);
	}
	inline void Push_down(int rt){
		long long T=sg[rt].tag;
		if(T==0)return;
		sg[rt].tag=0;
		sg[rt<<1].lmax.tag+=T;
		sg[rt<<1].rmax.tag+=T;
		sg[rt<<1].ansmax.tag+=T;
		sg[rt<<1|1].lmax.tag+=T;
		sg[rt<<1|1].rmax.tag+=T;
		sg[rt<<1|1].ansmax.tag+=T;
		sg[rt<<1].sum+=T*sg[rt<<1].len;
		sg[rt<<1|1].sum+=T*sg[rt<<1|1].len;
		sg[rt<<1].tag+=T;
		sg[rt<<1|1].tag+=T;
		
	}
	inline void Add(int rt,int L,int R,long long k){
		if(L<=sg[rt].l&&sg[rt].r<=R){
			
			sg[rt].lmax.tag+=k;
			sg[rt].rmax.tag+=k;
			sg[rt].ansmax.tag+=k;
			sg[rt].sum+=k*sg[rt].len;
			sg[rt].tag+=k;
//			cout<<"SGT:"<<rt<<"\n";
//			for(int i=0;i<sg[rt].rmax.siz;i++)cout<<sg[rt].rmax[i].y<<" ";
//			cout<<"\n";
			return ;
		}
		Push_down(rt);
		int mid=(sg[rt].l+sg[rt].r)>>1;
		if(L<=mid)Add(rt<<1,L,R,k);
		if(R>=mid+1)Add(rt<<1|1,L,R,k);
		sg[rt].lmax.siz=0;sg[rt].rmax.siz=0;sg[rt].ansmax.siz=0;
//		cout<<"Merge: "<<rt<<"\n";
		Push_up(rt);
//		cout<<"SGT:"<<rt<<"\n";
//		for(int i=0;i<sg[rt].lmax.siz;i++)cout<<sg[rt].lmax[i].y<<" ";
//		cout<<"\n";
		return;
	}
	inline Result Allquery(long long addv){
		return {sg[1].lmax.Maxn(addv),sg[1].rmax.Maxn(addv),sg[1].sum+sg[1].len*addv,sg[1].ansmax.Maxn(addv)};
	}
	inline void Query(int rt,int L,int R,long long addv){
		if(rt==1&& L==sg[1].l&&R==sg[1].r){Ans=Ans+Allquery(addv);return ;}
		if(L<=sg[rt].l&&sg[rt].r<=R){Ans=Ans+(Result){sg[rt].lmax.Maxn_Binary(addv),sg[rt].rmax.Maxn_Binary(addv),sg[rt].sum+sg[rt].len*addv,sg[rt].ansmax.Maxn_Binary(addv)};return;}
		Push_down(rt);
		int mid=(sg[rt].l+sg[rt].r)>>1;
		if(L<=mid)Query(rt<<1,L,R,addv);
		if(R>=mid+1)Query(rt<<1|1,L,R,addv);
	} 
//	inline void Clear(int rt){
//		sg[rt].tag=0;
//		sg[rt].sum=0;
//		
//		if(sg[rt].l==sg[rt].r)return;
//		Clear(rt<<1),Clear(rt<<1|1);
//	}
};
struct Opt{
	int type,l,r,id;
	long long v;
	bool operator <(const Opt& x){return v<x.v;}
};

const int JS=255;
struct Block{
	Segment_Tree sgt;
	int n,m,bid,cnt[JS+5];
	Opt seq[100005],tmp[100005];
	long long mrk,val[100005],valt[100005];
	inline void AllAdd(long long addv){mrk+=addv;}
	inline void PartAdd(int l,int r,long long addv){
		if(addv==0)return;
		if(l==1&&r==n){
			mrk+=addv;
			return;
		}
		seq[++m]={addv,l,r,0,mrk};
	}
	inline void Query(int l,int r,int idx){seq[++m]={0,l,r,idx,mrk};}
	inline void Sort(int l,int r){
		if(r-l<=1500){
			sort(seq+l,seq+r+1);
			return;
		}
		for(int i=l;i<=r;i++)val[i-l]=valt[i-l]=seq[i].v|((1ll*i)<<36);
		for(int i=0;i<32;i+=8){
			memset(cnt,0,sizeof(cnt));
			for(int j=0;j<=r-l;j++)cnt[(val[j]>>i)&JS]++;
			for(int j=1;j<=JS;j++)cnt[j]+=cnt[j-1];
			for(int j=r-l;j>=0;j--){
				valt[cnt[(val[j]>>i)&JS]-1]=val[j];
				cnt[(val[j]>>i)&JS]--;
			}
			memcpy(val,valt,(r-l+5)*(sizeof(long long)));
//			for(int j=0;j<=r-l;j++)val[j]=valt[j];
		}
		for(int i=l;i<=r;i++)tmp[i]=seq[i];
		for(int i=l;i<=r;i++)seq[i]=tmp[(val[i-l]>>36)];
	}
	inline void Prefix(){
//		cout<<"Bid:"<< bid<<"\n";
		long long minmrk=inf;
//		for(int i=1;i<=m;i++)minmrk=min(minmrk,seq[i].v);
		long long minmrk1=0,minmrk2=0,minmrk3=0,minmrk4=0,minmrk5=0,minmrk6=0,minmrk7=0,minmrk8=0;
		for(int i=0;i+8<=m;i+=8){
			minmrk1=min(minmrk1,seq[i+1].v);
			minmrk2=min(minmrk2,seq[i+2].v);
			minmrk3=min(minmrk3,seq[i+3].v);
			minmrk4=min(minmrk4,seq[i+4].v);
			minmrk5=min(minmrk5,seq[i+5].v);
			minmrk6=min(minmrk6,seq[i+6].v);
			minmrk7=min(minmrk7,seq[i+7].v);
			minmrk8=min(minmrk8,seq[i+8].v);
		}
		switch(n&7){
			case 7:minmrk7=min(minmrk7,seq[m-6].v);
			case 6:minmrk6=min(minmrk6,seq[m-5].v);
			case 5:minmrk5=min(minmrk5,seq[m-4].v);
			case 4:minmrk4=min(minmrk4,seq[m-3].v);
			case 3:minmrk3=min(minmrk3,seq[m-2].v);
			case 2:minmrk2=min(minmrk2,seq[m-1].v);
			case 1:minmrk1=min(minmrk1,seq[m].v);
		}
		minmrk=min(min(min(minmrk1,minmrk2),min(minmrk3,minmrk4)),min(min(minmrk5,minmrk6),min(minmrk7,minmrk8)));
		for(int i=1;i<=m;i++)seq[i].v-=minmrk;
		for(int i=bl[bid];i<=br[bid];i++)a[i]+=minmrk;
		TMP=(bid-1)*S;
		sgt.Build(1,1,n);
		int last=1;
		for(int i=1;i<=m;i++){
			if(seq[i].type!=0){
				if(i!=last)Sort(last,i-1);
				last=i+1;
			}
		}
		if(last<m)Sort(last,m);
	}
	inline void Solve(){
//		cout<<m<<"\n";
		for(int i=1;i<=m;i++){
			long long TM=seq[i].v;
//			cout<<"Solve:"<<seq[i].l<<" "<<seq[i].r<<"\n";
			if(seq[i].type==0){
				if((i^1)&&seq[i-1].type){
//					sgt.sg[1].ansmax.mxpnt=0;
//					sgt.sg[1].rmax.mxpnt=0;
//					sgt.sg[1].lmax.mxpnt=0;
					sgt.sg[1].lmax.Maxn_Binary(TM);
					sgt.sg[1].rmax.Maxn_Binary(TM);
					sgt.sg[1].rmax.Maxn_Binary(TM); 
//					CNT++;
				}
				Ans={0,0,0,0};
				sgt.Query(1,seq[i].l,seq[i].r,TM);
//				cout<<tmp.lmax<<" "<<tmp.rmax<<' '<<tmp.sum<<" "<<tmp.ansmax<<"\n";
				ans[seq[i].id]=ans[seq[i].id]+Ans;
			}else {
				sgt.Add(1,seq[i].l,seq[i].r,seq[i].type);
			}
		}
	}
//	inline void Clear(){
//		m=0;
////		sgt.Clear(1);
//		mrk=0;
//	}
}blk;
struct Op{
	int opt,l,r;
	long long v;
};
Op rp[100005];
int main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		pos[i]=(i-1)/S+1;
	}
	for(int i=1;i<=m;i++){
		cin>>rp[i].opt;
		cin>>rp[i].l;
		cin>>rp[i].r;
		if(rp[i].opt==1)cin>>rp[i].v;
	}
	for(int i=1;i<=pos[n];i++){
		bl[i]=(i-1)*S+1;
		br[i]=min(i*S,n);
	}
	for(int i=1;i<=pos[n];i++){
		qcnt=0;
		for(int j=1;j<=m;j++){
			if(rp[j].opt==2)qcnt++;
			if(rp[j].l>br[i]||bl[i]>rp[j].r)continue;
			if(rp[j].opt==1){
//				if(rp[j].l<=bl[i]&&br[i]<=rp[j].r)blk.AllAdd(rp[j].v);
//				else blk.PartAdd(max(rp[j].l,bl[i])-bl[i]+1,min(rp[j].r,br[i])-bl[i]+1,rp[j].v);
				blk.PartAdd(max(rp[j].l,bl[i])-bl[i]+1,min(rp[j].r,br[i])-bl[i]+1,rp[j].v);
			}
			else blk.Query(max(rp[j].l,bl[i])-bl[i]+1,min(rp[j].r,br[i])-bl[i]+1,qcnt);
		}
		//252 194
		//1 134 159
//		if(i==1)return blk.m/256/256;
		blk.bid=i;
		blk.n=br[i]-bl[i]+1;
		if(i==1||i==pos[n]){
			ptop=0;
			blk.sgt.Allocate(1,1,blk.n);
		}
		blk.Prefix();
		blk.Solve();
//		blk.Clear();
		blk.m=0;blk.mrk=0;
//		if(i==1)return CNT/256/256;
	}
	for(int i=1;i<=qcnt;i++){
		cout<<ans[i].ansmax;
		cout << '\n';
	}
	return 0;
	
}
```

---

## 作者：cdx123456 (赞：3)

请先做完[世上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)再来做这道题。

### Solution

全局加变区间加，所以考虑分块，看到毒瘤的空间考虑逐块处理。对于每一个块，如果整块被加直接打标记就好，如果加的不是整块，那么朴素的想法是暴力重构，但是复杂度带 $\log{n}$，会被卡，考虑优化。

发现线段树上有很多位置不用改，那么对所有要改的位置打标记，一个节点要重新修改，当且仅当对它的子节点进行了修改操作，这样每一层最多改两个节点，复杂度 $O(B)$。

整块询问每次在散块修改前做一遍以及最后做一遍，排序要用基数排序。散块询问暴力做更快。

令块长为 $\sqrt{n}$，复杂度为 $O(n\sqrt{n})$。

### 卡常小技巧

块长和基数排序的底数调一调。

适当的循环展开。

减少凸壳合并和闵可夫斯基和的常数。

神秘的分块技巧，例如加随机偏移量或开头结尾分出两个长度较小的块。

---

## 作者：Fa_Nanf1204 (赞：2)

### 前言：
前置任务：[P5073 [Ynoi Easy Round 2015] 世上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)。本题是此题的加强版。

本题码量稍大，有点卡常，请谨慎食用。
### 分析：

先来回顾一下本题的弱化版：全局加区间查怎么做。因为是全局加，所以记录一个 $add$，表示当前全局一共加了多少。考虑用线段树维护最大前缀和，后缀同理，对于一个长度为 $x$ 的前缀，记它被加之前值为 $lamx$，那么被加之后值就是 $x \cdot add+lmax$，我们的目的是最大化这个值。所以此时将 $(x,x \cdot add+lmax)$ 看做一个点，维护一个凸包即可快速求出最大值，每次线段树上合并左右儿子的凸包来维护当前节点凸包即可。最大子段和也是同理维护。对于询问，按照当前全局加标记从小到大排序，可以线性扫指针快速解决询问。不过多赘述了，默认做过前置任务题目。

那么这题变成了区间加，考虑序列分块，对于每个块建立一棵线段树像上文一样维护，分类讨论如何处理：
- 散块查：考虑直接暴力扫一遍，求出最大子段和。
- 整块改：直接在块内打一个全局加的标记即可。
- 散块改：如果直接暴力重构整棵线段树时间复杂度多一个 $\log n$，肯定不行。考虑在线段树上打标记，每次修改递归到终止节点时就打一个加标记，表示对于这样的一个节点进行了一次全局加，所以在凸包上打个不下传的标记即可，当然为了更新子树节点，也需要一个下传的加标记。修改之后合并两个儿子的凸包来更新当前节点的凸包，单次合并时间复杂度是 $O(len)$ 的，其中 $len$ 是当前区间长度。因为线段树上每层需要修改的节点最多只有两个节点是非终止节点，所以散块修改的时间复杂度是 $O(\sqrt n)$ 的。
- 整块查：考虑逐块处理减小空间。对于一个块，每两次相邻的散块修改之间有一些整块查的询问，此时将这些询问按照当前全局加标记从小到大排序，此时凸包上的决策点一定单调不减，所以可以像弱化版那样直接拿个指针线性扫过去。分析下时间复杂度，散块修改有 $O(m)$ 次，平均能将整块查的询问分成 $O(m)$ 块，每块 $O(\sqrt n)$ 个询问，每次扫指针时间复杂度 $O(\sqrt n)$，所以花 $O(\sqrt n)$ 的时间解决了 $O(\sqrt n)$ 个整块查询问，故整块查时间复杂度为 $O(m \sqrt n)$。

所以总时间复杂度就是 $O(m \sqrt n)$，可以通过本题。
### 卡常：
本题重头戏，卡常时间严格大于写代码和调代码时间。

- 用基数排序代替普通块排，或者设置阀值，小于这个值跑普通块排，否则跑基数排序。
- 将维护凸包的 vector 改为指针。
- 如果你的第 $21$ 号测试点卡不过去，考虑暴力计算第一块的答案。
- 循环展开。
- 调调块长，本人亲测块长为 $408$ 时跑得比较快。

代码私信领取。

---

## 作者：mlvx (赞：1)

前置任务：[P5073 [Ynoi Easy Round 2015] 世上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)。

本题解默认已经写过 P5073。

P5073 中的线段树只能龟速向上更新，故不支持快速区间修改。

考虑分块，对每个块建一颗线段树。

散块加直接在树上打标记，然后向上更新，由于每次最多只有两个散块，故此部分单次时间复杂度为 $O(\sqrt n)$。

散块查询直接暴力跑或到线段树上查，实测后者由于常数过大跑不过前者，故此部分单次时间复杂度 $O(\sqrt n)$。

整块加、查询，在查询时，如果在线，则时间复杂度会多一个二分的 $\log$。

离线逐块处理，对于块内连续的一段整块加、查询，散块查询，进行排序，即可像 P5073 一样进行处理，处理部分可做到单个操作或查询 $\sqrt n$。

由于散块修改最多只有 $2q$ 个，故最多有 $2(q+1)$ 连续的整块加、查询，散块查询的段。

排序可以用基数排序，若每次排 $O(len)$ 个数，单次排序可以视作 $O(len)$。

若 $n,q$ 同阶，则总时间复杂度 $O(n^{1.5})$。

代码私信领取。

### 卡常方法

- 若排序的数字比较少就用快排，否则基排。

- 在查散块时，仅当同此查询时该散块其右还有此次查询的其他部分，才要算 $rmx$；$lmx$ 同理。

- 答案数组仅需存下 $rmx,mx$，其他信息不用存。

- 调块长。

---

## 作者：Furina_Hate_Comma (赞：0)

[更好的阅读体验](https://www.cnblogs.com/FurinaHateComma/p/18740711) [YNOI随笔合集](https://www.cnblogs.com/FurinaHateComma/collections/25668)

YNOI 智慧题：

EasyVer1：[Ynoi Easy Round 2015] 世上最幸福的女孩

EasyVer2：小白逛公园

先看 EasyVer2

单点修改，区间查询最大子段和。

考虑在线段树维护前缀 $\max$，后缀 $\max$，$\text{sum}$，和 $\text{ansmax}$。

合并的时候分讨，修改直接到底后 pushup 即可。

接下来是 EasyVer1：

全局修改，区间查询最大子段和。

思考全局修改的实质：
- $\text{sum}$ 是好维护的。
- 前缀 $\max$ 和 后缀 $\max$，修改是加上一个一次函数。
- $\text{ansmax}$ 是由前缀 $\max$ 和后缀 $\max$ 推出的。
  
所以问题就是前缀 $\max$ 和后缀 $\max$ 怎么维护，其实这是一个经典问题，在斜率优化里面经常使用：

**维护一个上凸壳，根据斜率二分最值点。**

但是问题又出现了：我们有两个上凸壳 $f(x)$ 与 $g(x)$ 我们需要求 $f(x) + g(x)$ 的最大值。

不难发现这个是 **闵可夫斯基和** 的应用之一，我们可以合并两个凸包然后在新凸包里面二分即可。

于是 EasyVer2 就写完了。

接下来是这道题：

由刚刚的题，产生一个典型想法，利用 EasyVer2 的全局套分块，这样整块就变成了 EasyVer2，散块重构线段树即可。

分析一下复杂度：
- 整块修改 $O(1)$。
- 散块修改 $O(B\ log\ B)$。
- 整块查询 $O(B\ log\ B)$。
- 散块查询 $O(B\ log^2\ B)$。
 
综上 $O(n\sqrt n\log n)$。

1s 1e5 这对吗？

考虑优化：

- 零散修改
   
我们不一定要重建整棵线段树，而是考虑在子树上打 tag，但是这个 tag 不能打在节点上，这样会干扰原来的标记，打在凸包上就不会有这个问题。

- 整块查询

分块，离线？逐块处理！

把查询按 tag 排序以后处理，用一个指针做就可以到线性？
不对，我们的排序确有log！但是基数排序就不会有这个问题

这样我们就优化到了 $O(m \sqrt n)$。
接下来常数优化一下就好了。

提供几个我用了的常数优化：

- 调参： 块长，基数排序基数，直接排序的阈值。
- 循环展开。
- 减少局部变量。
- 真正快的快读和基排。

本人其实没有特别卡常，也就和同学一起交了 5-6 页就过了XD。

鸣谢：

608273，765066：在调试，卡常过程中提供了帮助。

61088，553501等题解区巨佬提供了部分卡常的方法。

---


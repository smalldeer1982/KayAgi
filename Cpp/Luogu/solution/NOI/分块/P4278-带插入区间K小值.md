# 带插入区间K小值

## 题目背景

**本题时限已经修改为 $\text{2s}$**。

**请使用常数较小的写法或者比较好的科技去过本题**。

## 题目描述

从前有 $n$ 只跳蚤排成一行做早操，每只跳蚤都有自己的一个弹跳力 $a_i$ 。跳蚤国王看着这些跳蚤国欣欣向荣的情景，感到非常高兴。这时跳蚤国王决定理性愉悦一下，查询区间 $k$ 小值。他每次向它的随从伏特提出这样的问题：从左往右第 $x$ 个到第 $y$ 个跳蚤中，$a_i$ 第 $k$ 小的值是多少。  

这可难不倒伏特，他在脑袋里使用函数式线段树前缀和的方法水掉了跳蚤国王的询问。

这时伏特发现有些跳蚤跳久了弹跳力会有变化，有的会增大，有的会减少。

这可难不倒伏特，他在脑袋里使用树状数组套线段树的方法水掉了跳蚤国王的询问。（orz 主席树）

这时伏特发现有些迟到的跳蚤会插入到这一行的某个位置上，他感到非常生气，因为……他不会做了。

请你帮一帮伏特吧。

**快捷版题意：带插入、修改的区间第 $k$ 小值在线查询**。

## 说明/提示

$n \le 35000$；
插入个数 $\le 35000$，修改个数 $\le 70000$，查询个数 $\le 70000$  ,$0 \le$ 每时每刻的权值 $\le 70000$。

数据无梯度。

## 样例 #1

### 输入

```
10
10 5 8 28 0 19 2 31 1 22
30
I 6 9
M 1 11
I 8 17
M 1 31
M 6 26
Q 2 7 6
I 23 30
M 31 7
I 22 27
M 26 18
Q 26 17 31
I 5 2
I 18 13
Q 3 3 3
I 27 19
Q 23 23 30
Q 5 13 5
I 3 0
M 15 27
Q 0 28 13
Q 3 29 11
M 2 8
Q 12 5 7
I 30 19
M 11 19
Q 17 8 29
M 29 4
Q 3 0 12
I 7 18
M 29 27```

### 输出

```
28
2
31
0
14
15
14
27
15
14```

# 题解

## 作者：daniel14311531 (赞：53)

#### 这题真毒，BZOJ过了，Luogu没过（请求增长时限QwQ）  

题意（三种操作）：  
 - 插入一个数到数列中  
 - 修改数列中一个数的值  
 - 询问区间第$k$小  

**强制在线。**  

然后可怜的我只会 $O(n \log^3 n)$ 的做法QAQ……  
这道题可以**树套树**，由于需要动态插点，所以**外层树**是**平衡树**；由于需要询问区间$k$小值，所以**内层树**可以是**权值线段树**（不嫌烦可以写平衡树），维护外层树所在子树的权值信息，显然如果外层树需要旋转操作，维护内层树将相当麻烦，所以我建议外层树写**替罪羊树**。  
对于插入和修改操作，可以根据二叉搜索树的做法进行，同时子树不平衡时暴力重构。  
对于查询操作，用线段树上查询区间的方法用vector存储需要访问的区间，显然最多有$\log n$个区间，再二分答案计算（类似主席树的查询操作）。  
目前时间的瓶颈在于重构部分暴力点权插入线段树需要$O(n \log^3 n)$，使得Luogu上$TLE$，BZOJ上$AC$。  
然后是代码（$TLE$）：  
```cpp
#include<bits/stdc++.h>
#define ratio 4
using namespace std;
inline int read() {
	register int tmp=0;register char c=getchar(); while(c<'0'||c>'9')	c=getchar();
	while(c>='0'&&c<='9')	tmp=(tmp<<1)+(tmp<<3)+(c^48),c=getchar(); return tmp;
}
inline void print(int x) { if(x>9)	print(x/10); putchar(x%10+'0'); }

const int N=70010;
int n,m,a[N],ans;
vector <int> q,ttt;
int root;
int Tot=0;
struct ST {
	int l,r,s;
	ST(int L,int R,int S):l(L),r(R),s(S) {}
	ST() {}
};ST tr[20000010]; int Sta[20000010],Top=0;
int tot=0;
struct P {
	int l,r,val,rt,sz;
	P(int L,int R,int V,int Rt,int S):l(L),r(R),val(V),rt(Rt),sz(S) {}
	P() {}
};P t[N];
int sta[N],top=0;
//sgt_...：替罪羊树所属函数
//st_...：权值线段树所属函数

inline int Min(const int x,const int y) { return x<y?	x:y; }
inline int Max(const int x,const int y) { return x>y?	x:y; }
inline int st_node() {
	if(!Top) return ++Tot; --Top; return Sta[Top+1];
}
void clean(int &u) {
	if(tr[u].l)	clean(tr[u].l); if(tr[u].r)	clean(tr[u].r);
	Sta[++Top]=u,tr[u]=ST(0,0,0),u=0;
}
void st_insert(int &u,int l,int r,int x,int w) {
	if(!u)	u=st_node(); tr[u].s+=w;
	if(l>=r) { if(!tr[u].s)	clean(u); return ; }
	int mid=(l+r)>>1;
	x<=mid?	st_insert(tr[u].l,l,mid,x,w):
			st_insert(tr[u].r,mid+1,r,x,w);
	if(!tr[u].s)	clean(u);
}
void debug(int u,int Tab) {
	if(t[u].l)	debug(t[u].l,Tab+1);
	for(int i=1;i<Tab;i++)	printf("     |");
	printf(" %d\n",t[u].val);
	if(t[u].r)	debug(t[u].r,Tab+1);
}
inline bool Bad(int u) {
	return (double)t[t[u].l].sz>ratio*(double)t[t[u].r].sz||
	       (double)t[t[u].r].sz>ratio*(double)t[t[u].l].sz;
}
inline int sgt_node(int l,int r,int v,int sz) {
	t[sta[top]]=P(l,r,v,0,sz),--top; return sta[top+1];
}
void sgt_init(int &u,int l,int r) {
	int mid=(l+r)>>1; u=sgt_node(0,0,a[mid],r-l+1);
	for(int i=l;i<=r;i++)	st_insert(t[u].rt,0,70000,a[i],1);//瓶颈
	if(l<mid)	sgt_init(t[u].l,l,mid-1);
	if(mid<r)	sgt_init(t[u].r,mid+1,r);
}
void ask(int u,int l,int r,int L,int R) {//类似线段树的方法预处理出要询问的块
	if(L>R||l>r)	return ;
	if(l==L&&r==R) { q.push_back(u);return ; }
	int mid=t[t[u].l].sz+l;
	if(L<=mid&&mid<=R)	ttt.push_back(t[u].val);
	if(R<mid)	ask(t[u].l,l,mid-1,L,R);
	else if(L>mid)	ask(t[u].r,mid+1,r,L,R);
	else	ask(t[u].l,l,mid-1,L,mid-1),ask(t[u].r,mid+1,r,mid+1,R);
}
int solve(int l,int r,int k) {
	ask(root,1,t[root].sz,l,r); int L=0,R=70000,mid,sum;
	for(int i=0;i<q.size();i++)	q[i]=t[q[i]].rt;
//	printf("ASK : ");
//	for(int i=0;i<q.size();i++)	printf(" %d",tr[q[i]].s);printf("\n");
//	for(int i=0;i<ttt.size();i++)	printf(" 1",ttt[i]);printf("\n");
	while(L<R) {
		mid=(L+R)>>1,sum=0;
		for(int i=0;i<q.size();i++)	sum+=tr[tr[q[i]].l].s;
		for(int i=0;i<ttt.size();i++)	if(ttt[i]<=mid)	++sum;
//		printf("MWHAKIOI : %d %d\n",mid,sum);
		if(sum>=k) {
			R=mid; for(int i=0;i<q.size();i++)	q[i]=tr[q[i]].l;
		}
		else {
			k-=sum,L=mid+1;
			for(int i=0;i<q.size();i++)	q[i]=tr[q[i]].r;
			for(int i=0;i<ttt.size();i++)
				if(ttt[i]<=mid)	ttt[i]=70010;
		}
	}
	q.clear(),ttt.clear(); return R;
}
int sgt_find(int u,int k) {
	if(t[t[u].l].sz+1==k)	return t[u].val;
	if(k<=t[t[u].l].sz)	return sgt_find(t[u].l,k);
	return sgt_find(t[u].r,k-t[t[u].l].sz-1);
}
void sgt_mdy(int u,int k,int Old,int New) {
	st_insert(t[u].rt,0,70000,Old,-1),
	st_insert(t[u].rt,0,70000,New,1);
	if(t[t[u].l].sz+1==k) { t[u].val=New;return ; }
	k<=t[t[u].l].sz?	sgt_mdy(t[u].l,k,Old,New):
	sgt_mdy(t[u].r,k-t[t[u].l].sz-1,Old,New);
}
void dfs(int &u) {
	if(t[u].l)	dfs(t[u].l);
	a[++n]=t[u].val,clean(t[u].rt),sta[++top]=u;
	if(t[u].r)	dfs(t[u].r);
	u=0;
}
void rebuild(int &u) { n=0,dfs(u),sgt_init(u,1,n); }
void sgt_insert(int &u,int x,int w) {
	if(!u) {
		u=sgt_node(0,0,w,1),st_insert(t[u].rt,0,70000,w,1);
		return ;
	}
	st_insert(t[u].rt,0,70000,w,1),++t[u].sz;
	if(x<=t[t[u].l].sz)	sgt_insert(t[u].l,x,w);
	else	sgt_insert(t[u].r,x-t[t[u].l].sz-1,w);
	if(!Bad(u)) {
		if(Bad(t[u].l))	rebuild(t[u].l);
		if(Bad(t[u].r))	rebuild(t[u].r);
	}
}
int main() {
	n=read();
	for(register int i=1;i<=n;++i)	a[i]=read(); m=read();
	for(register int i=1;i<N;++i)	sta[++top]=i;
	sgt_init(root,1,n);
//	printf("Array : \n"),debug(root,1),printf("\n");
	for(;m;--m) {
		register char opt=getchar();
		while(opt<'A'||opt>'Z')	opt=getchar();
		if(opt=='Q') {
			register int l=read()^ans,r=read()^ans,k=read()^ans;
			ans=solve(l,r,k),print(ans),putchar(10);
		}
		else if(opt=='M') {
			register int x=read()^ans,y=read()^ans,z;
			z=sgt_find(root,x),sgt_mdy(root,x,z,y);
		}
		else {
			register int x=read()^ans,y=read()^ans;
			sgt_insert(root,x-1,y); if(Bad(root))	rebuild(root);
		}
//		printf("Array : \n"),debug(root,1),printf("\n");
	}
	return 0;
}
```  
目前想到的解决方式：  
 - 线段树合并  
 - leafy tree 实现重量平衡树（线段树合并） 

我们知道线段树合并的时间复杂度是 $O(n \log n)$ 加上重构的时间后为 $O(n \log^2 n)$ ，理论可过。但实际上在Luogu依旧被卡（1.2 s）。

被卡的代码：  
```cpp
#include<bits/stdc++.h>
#define ratio 3
using namespace std;
inline int read() {
	register int tmp=0;register char c=getchar();
	while(c<'0'||c>'9')	c=getchar();
	while(c>='0'&&c<='9')	tmp=(tmp<<1)+(tmp<<3)+(c^48),c=getchar();
	return tmp;
}
inline void print(int x) { if(x>9)	print(x/10); putchar(x%10+'0'); }

const int N=70010;
int n,m,a[N],ans;
vector <int> q,ttt;
int root;
int Tot=0;
struct ST {
	int l,r,s;
	ST(int L,int R,int S):l(L),r(R),s(S) {}
	ST() {}
};ST tr[20000010]; int Sta[20000010],Top=0;
int tot=0;
struct P {
	int l,r,val,rt,sz;
	P(int L,int R,int V,int Rt,int S):l(L),r(R),val(V),rt(Rt),sz(S) {}
	P() {}
};P t[N];
int sta[N],top=0;
//sgt_...：替罪羊树所属函数
//st_...：权值线段树所属函数

inline int Min(const int &x,const int &y) { return x<y?	x:y; }
inline int Max(const int &x,const int &y) { return x>y?	x:y; }
inline int st_node() {
	if(!Top) return ++Tot; --Top; return Sta[Top+1];
}
void clean(int &u) {
	if(tr[u].l)	clean(tr[u].l); if(tr[u].r)	clean(tr[u].r);
	Sta[++Top]=u,tr[u]=ST(0,0,0),u=0;
}
void st_insert(int &u,int l,int r,int x,int w) {
	if(!u)	u=st_node(); tr[u].s+=w;
	if(l>=r) { if(!tr[u].s)	clean(u); return ; }
	int mid=(l+r)>>1;
	x<=mid?	st_insert(tr[u].l,l,mid,x,w):
			st_insert(tr[u].r,mid+1,r,x,w);
	if(!tr[u].s)	clean(u);
}
void debug(int u,int Tab) {
	if(t[u].l)	debug(t[u].l,Tab+1);
	for(int i=1;i<Tab;i++)	printf("     |");
	printf(" %d\n",t[u].val);
	if(t[u].r)	debug(t[u].r,Tab+1);
}
inline bool Bad(int u) {
	return (double)t[t[u].l].sz>ratio*(double)t[t[u].r].sz||
	       (double)t[t[u].r].sz>ratio*(double)t[t[u].l].sz;
}
inline int sgt_node(int l,int r,int v,int sz) {
	t[sta[top]]=P(l,r,v,0,sz),--top; return sta[top+1];
}
void Merge(int &u,int l,int r,int L,int R) {//线段树合并
	if(!l&&!r)	return ;
	u=st_node(),tr[u].s=tr[l].s+tr[r].s;
	if(l==r)	return ;
	int mid=(L+R)>>1;
	Merge(tr[u].l,tr[l].l,tr[r].l,L,mid),
	Merge(tr[u].r,tr[l].r,tr[r].r,mid+1,r);
}
void sgt_init(int &u,int l,int r) {
	int mid=(l+r)>>1; u=sgt_node(0,0,a[mid],r-l+1);
	if(l<mid)	sgt_init(t[u].l,l,mid-1);
	if(mid<r)	sgt_init(t[u].r,mid+1,r);
	Merge(t[u].rt,t[t[u].l].rt,t[t[u].r].rt,0,70000);//线段树合并
	st_insert(t[u].rt,0,70000,a[mid],1);
}
void ask(int u,int l,int r,int L,int R) {//类似线段树的方法预处理出要询问的块
	if(L>R||l>r)	return ;
	if(l==L&&r==R) { q.push_back(u);return ; }
	int mid=t[t[u].l].sz+l;
	if(L<=mid&&mid<=R)	ttt.push_back(t[u].val);
	if(R<mid)	ask(t[u].l,l,mid-1,L,R);
	else if(L>mid)	ask(t[u].r,mid+1,r,L,R);
	else	ask(t[u].l,l,mid-1,L,mid-1),ask(t[u].r,mid+1,r,mid+1,R);
}
int solve(int l,int r,int k) {
	ask(root,1,t[root].sz,l,r); int L=0,R=70000,mid,sum;
	for(int i=0;i<q.size();i++)	q[i]=t[q[i]].rt;
//	printf("ASK : ");
//	for(int i=0;i<q.size();i++)	printf(" %d",tr[q[i]].s);printf("\n");
//	for(int i=0;i<ttt.size();i++)	printf(" 1",ttt[i]);printf("\n");
	while(L<R) {
		mid=(L+R)>>1,sum=0;
		for(int i=0;i<q.size();i++)	sum+=tr[tr[q[i]].l].s;
		for(int i=0;i<ttt.size();i++)	if(ttt[i]<=mid)	++sum;
//		printf("MWHAKIOI : %d %d\n",mid,sum);
		if(sum>=k) {
			R=mid; for(int i=0;i<q.size();i++)	q[i]=tr[q[i]].l;
		}
		else {
			k-=sum,L=mid+1;
			for(int i=0;i<q.size();i++)	q[i]=tr[q[i]].r;
			for(int i=0;i<ttt.size();i++)
				if(ttt[i]<=mid)	ttt[i]=70010;
		}
	}
	q.clear(),ttt.clear(); return R;
}
int sgt_find(int u,int k) {
	if(t[t[u].l].sz+1==k)	return t[u].val;
	if(k<=t[t[u].l].sz)	return sgt_find(t[u].l,k);
	return sgt_find(t[u].r,k-t[t[u].l].sz-1);
}
void sgt_mdy(int u,int k,int Old,int New) {
	st_insert(t[u].rt,0,70000,Old,-1),
	st_insert(t[u].rt,0,70000,New,1);
	if(t[t[u].l].sz+1==k) { t[u].val=New;return ; }
	k<=t[t[u].l].sz?	sgt_mdy(t[u].l,k,Old,New):
	sgt_mdy(t[u].r,k-t[t[u].l].sz-1,Old,New);
}
void dfs(int &u) {
	if(t[u].l)	dfs(t[u].l);
	a[++n]=t[u].val,clean(t[u].rt),sta[++top]=u;
	if(t[u].r)	dfs(t[u].r);
	u=0;
}
void rebuild(int &u) { n=0,dfs(u),sgt_init(u,1,n); }
void sgt_insert(int &u,int x,int w) {
	if(!u) {
		u=sgt_node(0,0,w,1),st_insert(t[u].rt,0,70000,w,1);
		return ;
	}
	st_insert(t[u].rt,0,70000,w,1),++t[u].sz;
	if(x<=t[t[u].l].sz)	sgt_insert(t[u].l,x,w);
	else	sgt_insert(t[u].r,x-t[t[u].l].sz-1,w);
	if(!Bad(u)) {
		if(Bad(t[u].l))	rebuild(t[u].l);
		if(Bad(t[u].r))	rebuild(t[u].r);
	}
}
int main() {
	n=read();
	for(register int i=1;i<=n;++i)	a[i]=read(); m=read();
	for(register int i=1;i<N;++i)	sta[++top]=i;
	sgt_init(root,1,n);
//	printf("Array : \n"),debug(root,1),printf("\n");
	for(;m;--m) {
		register char opt=getchar();
		while(opt<'A'||opt>'Z')	opt=getchar();
		if(opt=='Q') {
			register int l=read()^ans,r=read()^ans,k=read()^ans;
			ans=solve(l,r,k),print(ans),putchar(10);
		}
		else if(opt=='M') {
			register int x=read()^ans,y=read()^ans,z;
			z=sgt_find(root,x),sgt_mdy(root,x,z,y);
		}
		else {
			register int x=read()^ans,y=read()^ans;
			sgt_insert(root,x-1,y); if(Bad(root))	rebuild(root);
		}
//		printf("Array : \n"),debug(root,1),printf("\n");
	}
	return 0;
}
```  
然后仅剩下的思路是块状链表，若能做到$O(n \sqrt {n})$ 同样理论可过。  
我尝试去敲块状链表，由于常数优秀，跑得比$O(n \log^2 n)$还快，Luogu上过了60%的数据。听说某位大神用块状链表卡进去了，吾辈表示无能为力。  
**写题没有必要做对，写题的目的是锻炼思维和解题方式，留下思考的痕迹，这样写题才有意义。**  
最后我在这里留下块状链表写法的代码。  
```cpp
#include<bits/stdc++.h>
#define ONLINE_JUDGE
#define re register
using namespace std;
const int N=70000,BLOSIZE=1100,MXBLO=2*N/BLOSIZE;
int n,m;

struct P {
	int a[3*BLOSIZE+100],b[3*BLOSIZE+100],sz,to;
	void reset() {
		for(re int i=1;i<=sz;++i)	b[i]=a[i];
		sort(b+1,b+sz+1);
	}
};P t[MXBLO+100];
int tot=0;

inline int read() {
	re int x=0;re char c=getchar();
	while(c<'0'||c>'9')	c=getchar();
	while(c>='0'&&c<='9')	x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
void print(int x) { if(x>9)	print(x/10); putchar(x%10+'0'); }
inline void insert(int x,int w) {//插入一个数
	re int u,tt;
	for(u=0;u!=-1&&x>t[u].sz;u=t[u].to)	x-=t[u].sz;
	for(re int i=t[u].sz;i>=x;--i)	t[u].a[i+1]=t[u].a[i];
	t[u].a[x]=w,++t[u].sz;
	if(t[u].sz>=2*BLOSIZE) {//分裂块
		int nu=++tot; t[nu].to=t[u].to,t[u].to=nu;
		t[nu].sz=t[u].sz-BLOSIZE;
		for(re int i=BLOSIZE+1;i<=t[u].sz;++i)
			t[nu].a[i-BLOSIZE]=t[nu].b[i-BLOSIZE]=t[u].a[i];
		for(re int i=1;i<=BLOSIZE;++i) t[u].b[i]=t[u].a[i];
		t[u].sz=BLOSIZE;
		sort(t[nu].b+1,t[nu].b+t[nu].sz+1),
		sort(t[u].b+1,t[u].b+t[u].sz+1); return ;
	}
	tt=t[u].sz-1;
	for(;tt;--tt) {
		if(t[u].b[tt]>w)	t[u].b[tt+1]=t[u].b[tt];
		else	break;
	}
	t[u].b[tt+1]=w;
}
void modify(int x,int w) {//修改权值
	re int u,tt;
	for(u=0;u!=-1&&x>t[u].sz;u=t[u].to)	x-=t[u].sz;
	for(re int i=1;i<=t[u].sz;++i)
		if(t[u].b[i]==t[u].a[x]) {
			for(re int j=i;j<t[u].sz;++j)
				t[u].b[j]=t[u].b[j+1];
			t[u].b[t[u].sz--]=0;break;
		}
	t[u].a[x]=w,tt=t[u].sz;
	for(;tt;--tt) {
		if(t[u].b[tt]>w) t[u].b[tt+1]=t[u].b[tt];
		else	break;
	}
	t[u].b[tt+1]=w,++t[u].sz;
}
int query(int x,int y,int w) {//询问排名
	re int u,v,sum=0,l,r,mid,tt;
	for(u=0;u!=-1&&x>t[u].sz;u=t[u].to)	x-=t[u].sz;
	for(v=0;v!=-1&&y>t[v].sz;v=t[v].to)	y-=t[v].sz;
	if(u==v) {
		for(int i=x;i<=y;i++) if(t[u].a[i]<w) ++sum;
		return sum;
	}
	for(re int i=x;i<=t[u].sz;++i) if(t[u].a[i]<w) ++sum;
	for(re int i=1;i<=y;++i) if(t[v].a[i]<w) ++sum;
	for(re int i=t[u].to;i!=v;i=t[i].to) {
		l=1,r=t[i].sz,tt=0;
		while(l<=r) {
			mid=(l+r)>>1;
			t[i].b[mid]<w?	(tt=mid,l=mid+1):r=mid-1;
		}
		sum+=tt;
	}
	return sum;
}
void init() {//初始化
	t[0].to=-1,t[0].sz=0,n=read(); int cnt=BLOSIZE,Old=0;
	for(re int i=1;i<=n;++i) {
		if(cnt==BLOSIZE) {
			int u=++tot;
			t[u].to=t[Old].to,t[Old].to=u,
			sort(t[Old].b+1,t[Old].b+t[Old].sz+1);
			Old=u,cnt=0;
		}
		t[Old].a[++t[Old].sz]=read(),
		t[Old].b[t[Old].sz]=t[Old].a[t[Old].sz],
		++cnt;
	}
	if(cnt==BLOSIZE) {
		int u=++tot;
		t[u].to=t[Old].to,t[Old].to=u,
		sort(t[Old].b+1,t[Old].b+t[Old].sz+1);
		Old=u,cnt=0;
	}
	t[Old].a[++t[Old].sz]=70000,
	t[Old].b[t[Old].sz]=t[Old].a[t[Old].sz],
	sort(t[Old].b+1,t[Old].b+t[Old].sz+1);
	m=read();
}
void debug() {
	for(int i=0;i!=-1;i=t[i].to) {
		printf(" ( [%d]",i);
		for(int j=1;j<=t[i].sz;++j)
			printf(" %d",t[i].b[j]);
		printf(" )");
	}
	printf("\n");
}
int main() {
	#ifndef ONLINE_JUDGE
	freopen("Dynamic Kth in range.in","r",stdin);
	freopen("Dynamic Kth in range.out","w",stdout);
	int cur=clock();
	#endif
	char c; int x,y,k,ans=0,l,r,mid; init();
	for(;m;--m) {
		c=getchar(); while(c<'A'||c>'Z')	c=getchar();
		switch(c) {
			case 'Q':
				x=read()^ans,y=read()^ans,k=read()^ans;
				l=0,r=70000;
				while(l<=r) {
					mid=(l+r)>>1;
					query(x,y,mid)<k?
						(l=mid+1,ans=mid):r=mid-1;
				}
				print(ans),putchar(10);break;
			case 'I':
				x=read()^ans,y=read()^ans,insert(x,y);break;
			default:	x=read()^ans,y=read()^ans,modify(x,y);
		}
		#ifndef ONLINE_JUDGE
		ans=0;
		#endif
	}
	#ifndef ONLINE_JUDGE
	printf(">>> %d ms.",clock()-cur);
	fclose(stdin),fclose(stdout);
	#endif
	return 0;
}
```   
再次请求管理员增长时限！

---

## 作者：feecle6418 (赞：33)

块状链表。

为了尽量好理解，我会一个问题一个问题来讲。

## 前置知识

- 值域分块。
- 块状链表是什么？是很多块用链表的方式连起来。

## 一、如何求第 $k$ 小？

值域分块。

对于每个块，记录两个东西：

1. 值为 $x$ 的数的个数的前缀和。
2. 值属于第 $k$ 块的数的个数的前缀和。

代码：

```cpp
struct Block {
	int l,r,size;
	int sk[305];//块内有几个属于这一块 的前缀和
	int s[70005];//块内有几个等于x 的前缀和
	int a[605];
	int& operator [](const int k) {
		return a[k];
	}
} b[605];
```

有了这些东西，怎么求区间第 $k$ 小？

先要找到 $l,r$ 在哪个块。代码如下：

```cpp
	int now=L,lbel,rbel;
	while(b[now].size<l)l-=b[now].size,now=b[now].r;
	lbel=now,now=L;
	while(b[now].size<r)r-=b[now].size,now=b[now].r;
	rbel=now;
```

若 $l,r$ 在同一个块内，只需扫一遍，将值为 $x$ 的数的个数和值在某一块内的数的个数统计出来。

然后，先从小到大枚举块，边做前缀和。找到答案在哪一块后，从小到大枚举，找到答案的具体位置。

代码如下（注意清空临时数组）：

```cpp
	if(lbel==rbel) {
		for(int i=l; i<=r; i++)tmps[b[lbel][i]]++,tmpsk[bel[b[lbel][i]]]++;
		now=1;
		while(tmpsk[now]<k)k-=tmpsk[now],now++;
		now=(now-1)*THREEHUNDRED;
		while(tmps[now]<k)k-=tmps[now],now++;
		for(int i=l; i<=r; i++)tmps[b[lbel][i]]--,tmpsk[bel[b[lbel][i]]]--;
		return now;
	}
```

若 $l,r$ 不在同一个块内，先同样地将两边零散的个数统计出来。然后从小到大枚举答案所在的值域块，用总个数前缀和。找到答案在哪一块后，从小到大枚举，同样地做前缀和。

对于每一个数，它的出现次数等于：$s_{r\text{的左边}}-s_l+\text{两边零散的}$

代码如下：

```cpp
	for(int i=l; i<=b[lbel].size; i++)tmps[b[lbel][i]]++,tmpsk[bel[b[lbel][i]]]++;
	for(int i=1; i<=r; i++)tmps[b[rbel][i]]++,tmpsk[bel[b[rbel][i]]]++;
	now=1;
	while(tmpsk[now]+b[b[rbel].l].sk[now]-b[lbel].sk[now]<k)k-=tmpsk[now]+b[b[rbel].l].sk[now]-b[lbel].sk[now],now++;
	now=(now-1)*THREEHUNDRED;
	while(tmps[now]+b[b[rbel].l].s[now]-b[lbel].s[now]<k)k-=tmps[now]+b[b[rbel].l].s[now]-b[lbel].s[now],now++;
	for(int i=l; i<=b[lbel].size; i++)tmps[b[lbel][i]]--,tmpsk[bel[b[lbel][i]]]--;
	for(int i=1; i<=r; i++)tmps[b[rbel][i]]--,tmpsk[bel[b[rbel][i]]]--;
	return now;
```

你已经渡过了最难的一关，接下来的都很简单了。

## 二、如何修改？

首先找到这个数所在的块。从这个块往后跳，将他原来的值的的个数减一，新值的个数加一，同时维护值域分块。代码如下：

```cpp
	int now=L;
	while(b[now].size<x)x-=b[now].size,now=b[now].r;
	int before=b[now][x],after=k;
	if(before==after)return ;
	b[now][x]=after;
	while(now) {
		b[now].sk[bel[before]]--;
		b[now].sk[bel[after]]++;
		b[now].s[before]--;
		b[now].s[after]++;
		now=b[now].r;
	}
```

## 三、如何插入？

直接暴力插入，将他之后的所有元素后移，同时按照（二）中的方法维护前缀和。

但是，假如一直往同一个块里插东西，显然时间爆炸。

因此，当块的大小大于一个阈值的时候，我们就将其分裂成两个小块。方便起见，我们看成把原块的后一半分出去。

显然分裂不会对后面的块的前缀和产生影响，我们只需要考虑维护这两个小块。

后面的小块的所有信息其实和原来的是一样的，复制过去就行。

维护原来的块，只需要扫一遍后面的块，把后面的块中的元素减掉就行了。

然后同时维护一下链表，把分裂前后面那个块接到分出的块上就好了。

代码如下：

```cpp
void Split(int now) {
	int newb=++S;
	b[newb].r=b[now].r,b[b[now].r].l=newb,b[now].r=newb,b[newb].l=now;
	//cout<<"Splitting:"<<now<<' '<<newb<<endl;
	//cout<<b[now].l<<' '<<b[now].r<<' '<<b[newb].l<<' '<<b[newb].r<<endl;
	b[newb].size=b[now].size/2;
	int tmp=b[now].size-b[newb].size;
	memcpy(b[newb].sk,b[now].sk,sizeof(b[now].sk));
	memcpy(b[newb].s,b[now].s,sizeof(b[now].s));
	for(int i=tmp+1; i<=b[now].size; i++) {
		b[newb][i-tmp]=b[now][i];
		b[now].sk[bel[b[now][i]]]--,b[now].s[b[now][i]]--;
		b[now][i]=0;
	}
	b[now].size=tmp;
}
void Insert(int x,int k) {
	//cout<<"RealInsert:"<<x<<' '<<k<<endl;
	int now=L;
	while(b[now].size<x){
		if(b[now].r)x-=b[now].size,now=b[now].r;
		else break;
	}
	for(int i=b[now].size; i>=x; i--)b[now][i+1]=b[now][i];
	b[now][x]=k,b[now].size++;
	int tn=now;
	while(now) {
		b[now].sk[bel[k]]++;
		b[now].s[k]++;
		now=b[now].r;
	}
	if(b[tn].size>THREEHUNDRED*2)Split(tn);
}
```

# 四、结语

相信看到这里，你已经有能力自己写出代码了。

其实这题并不难，只要你想好了写，并且有一段充足的时间（我用了 2.5h）调试，应该是能够将其 AC 的。

这种值域分块的想法，其实在其他题中也可以借鉴。

完结撒花~~

---

## 作者：skip2004 (赞：22)

卡了半天，终于用树套树卡过去了。

正常的树套树是需要外层使用替罪羊树或者treap实现的，但是我们仔细考虑一下这个问题。

我们在树套树模板中，有一种比较不错的树套树可以求区间第 K 小，就是权值树套位置树。而这个题目中，值域是确定的，不会在两个值中间多出来一个值，所以外层的树结构也是确定的。

我们来思考内层，我们在二分第 K 大的时候，我们要求出一个区间的数有多少个。因此我们需要比较两个元素在序列中的相对位置关系。我们考虑到会有插入，所以我们不能用他们插入时的编号比较。我们考虑给每个位置附一个值，使得序列中每个元素都对应一个值，而且在越前面值越小。我们可以用替罪羊树/treap来维护这个值。当不平衡时候就重新将一个子树的值重新赋值就好了。

现在我们就支持比较两个元素在序列中的位置了。所以我们只需要一个树状数组套平衡树就可以了。但是平衡树不能太慢。

code:

```cpp
#include<bits/stdc++.h>
#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)
typedef unsigned long long u64;
typedef double db;
typedef long long ll;
typedef unsigned u32;
struct istream {
    static const int size = 1 << 23;
    char buf[size], *vin;
    inline istream() {
        fread(buf,1,size,stdin);
        vin = buf - 1;
    }
    inline istream& operator >> (int & x) {
        for(x = *++vin & 15;isdigit(*++vin);) x = x * 10 + (*vin & 15);
        return * this;
    }
    inline istream& operator >> (char & x) {
    	x = *++vin;
        return * this;
    }
} cin;
struct ostream {
    static const int size = 1 << 22;
    char buf[size], *vout;
    unsigned map[10000];
    inline ostream() {
        for(int i = 0;i < 10000;++i) {
            map[i] = i % 10 + 48 << 24 | i / 10 % 10 + 48 << 16 | i / 100 % 10 + 48 << 8 | i / 1000 + 48;
        }
        vout = buf + size;
    }
    inline ~ ostream()
    { fwrite(vout,1,buf + size - vout,stdout); }
    inline ostream& operator << (u32 x) {
        for(;x >= 10000;x /= 10000) *--(unsigned*&)vout = map[x % 10000];
        do *--vout = x % 10 + 48; while(x /= 10);
        return * this;
    }
    inline ostream& operator << (char x) {
        *--vout = x;
        return * this;
    }
} cout;


const int N = 100000;
const int M = 1 << 17;
const u64 Max = 1ull << 60;

inline int gen() {
	static u32 x = 2431898411;
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return x;
}

u64 value[N];
namespace treap {
	const int S = 20 * N;
	struct node {
		int ls, rs, p, v, size;
	} a[S];
	int tot;
	inline void update(int id) {
		a[id].size = a[a[id].ls].size + a[a[id].rs].size + 1;
	}
	inline int merge(int x, int y) {
		if(!x || !y) return x | y;
		if(a[x].p < a[y].p) {
			a[x].size += a[y].size;
			a[x].rs = merge(a[x].rs, y);
			return x;
		} else {
			a[y].size += a[x].size;
			a[y].ls = merge(x, a[y].ls);
			return y;
		}
	}
	inline void split(int rt, int idx, int & x, int & y) {
		if(!rt) x = y = 0;
		else {
			if(value[idx] < value[a[rt].v]) {
				split(a[rt].ls, idx, x, a[rt].ls);
				y = rt, a[y].size -= a[x].size;
			} else {
				split(a[rt].rs, idx, a[rt].rs, y);
				x = rt, a[x].size -= a[y].size;
			}
		}
	}
	inline void ins(int & rt, int idx) {
		a[++tot] = (node) {0, 0, gen(), idx, 1};
		int * x = &rt;
		for(;*x && a[tot].p > a[*x].p;) {
			++ a[*x].size;
			x = &(value[idx] < value[a[*x].v] ? a[*x].ls : a[*x].rs);
		}
		split(*x, idx, a[tot].ls, a[tot].rs);
		update(*x = tot);
	}
	inline void del(int & rt, int idx) {
		int * x = &rt;
		for(;a[*x].v != idx;) {
			-- a[*x].size;
			x = &(value[idx] < value[a[*x].v] ? a[*x].ls : a[*x].rs);
		}
		*x = merge(a[*x].ls, a[*x].rs);
	}
	inline int bet(int rt, u64 L, u64 R, int K) {
		for(;rt && value[a[rt].v] - L > R - L;) rt = L < value[a[rt].v] ? a[rt].ls : a[rt].rs;
		int res = bool(rt);
		for(int x = a[rt].ls;x && res < K;) {
			if(L <= value[a[x].v]) {
				res += a[a[x].rs].size + 1;
				x = a[x].ls;
			} else {
				x = a[x].rs;
			}
		}
		for(int x = a[rt].rs;x && res < K;) {
			if(value[a[x].v] <= R) {
				res += a[a[x].ls].size + 1;
				x = a[x].rs;
			} else {
				x = a[x].ls;
			}
		}
		return res;
	}
}

namespace seq { // for label
	const int S = 200000;
	int ls[S], rs[S], p[S], size[S], A[S], tot;
	inline void update(int id) { size[id] = size[ls[id]] + size[rs[id]] + 1; }
	inline void rls(int & rt){ int x = ls[rt]; ls[rt] = rs[x], update(rs[x] = rt), rt = x; }
	inline void rrs(int & rt){ int x = rs[rt]; rs[rt] = ls[x], update(ls[x] = rt), rt = x; }
	inline int merge(int x, int y) {
		if(!x || !y) return x | y;
		if(p[x] < p[y]) {
			size[x] += size[y], rs[x] = merge(rs[x], y);
			return x;
		} else {
			size[y] += size[x], ls[y] = merge(x, ls[y]);
			return y;
		}
	}
	inline void build(int rt, u64 L, u64 R) {
		u64 mid = value[rt] = (L + R) >> 1;
		if(ls[rt]) build(ls[rt], L, mid);
		if(rs[rt]) build(rs[rt], mid, R);
	}
	inline void ins(int & rt, int rank, int idx, int a, int fa, u64 L = 0, u64 R = Max) {
		if(!rt) {
			p[++tot] = gen(), size[tot] = 1, value[idx] = (L + R) >> 1, A[tot] = a, rt = tot;
		} else {
			u64 mid = (L + R) >> 1;
			if(size[ls[rt]] >= rank) {
				ins(ls[rt], rank, idx, a, rt, L, mid);
				if(p[ls[rt]] < p[rt]) rls(rt);
			} else {
				ins(rs[rt], rank - size[ls[rt]] - 1, idx, a, rt, mid, R);
				if(p[rs[rt]] < p[rt]) rrs(rt);
			}
			update(rt);
		}
		if((p[rt] >= p[fa] || !fa) && rt == idx) build(rt, L, R);
	}
	inline int kth(int root, int k) {
		for(;;) {
			if(size[ls[root]] >= k) {
				root = ls[root];
			} else {
				if(k == size[ls[root]] + 1) return root;
				k -= size[ls[root]] + 1;
				root = rs[root];
			}
		}
	}
}
int n, q;
int a[N];

int bit[M | 1];

const int U = 70001;
inline void ins(int v, int seq_id) {
	v += 1;
	for(;v <= U;v += v & -v)
		treap::ins(bit[v], seq_id);
}
inline void del(int v, int seq_id) {
	v += 1;
	for(;v <= U;v += v & -v)
		treap::del(bit[v], seq_id);
}
inline int find_kth(u64 L, u64 R, int k) {
	int l = 1, r = M;
	for(;l != r;) {
		int mid = l + r >> 1;
		if(mid > U) { r = mid; continue; }
		int cnt = treap::bet(bit[mid], L, R, k);
		if(cnt >= k) {
			r = mid;
		} else {
			k -= cnt;
			l = mid + 1;
		}
	}
	return l - 1;
}
int out[N], cnt;
int main() {
	std::ios::sync_with_stdio(false), std::cin.tie(0);
	int root = 0;
	cin >> n;
	for(int i = 1;i <= n;++i) {
		cin >> a[i];
		seq::ins(root, i, i, a[i], 0);
		ins(a[i], i);
	}
	cin >> q;
	int last = 0;
	size_t t = 0;
	for(int i = 1, l, r, k, val;i <= q;++i) {
		char type;
		cin >> type;
		if(type == 'Q') {
			cin >> l >> r >> k;
			l ^= last;
			r ^= last;
			k ^= last;
			int L = seq::kth(root, l);
			int R = seq::kth(root, r);
			last = find_kth(value[L], value[R], k);
			out[++cnt] = last;
		}
		if(type == 'M') {
			cin >> l >> val;
			l ^= last;
			val ^= last;
			int L = seq::kth(root, l);
			del(seq::A[L], L);
			seq::A[L] = val;
			ins(seq::A[L], L);
		}
		if(type == 'I') {
			cin >> l >> val;
			l ^= last;
			val ^= last;
			seq::ins(root, l - 1, ++n, val, 0);
			ins(val, n);
		}
		// last = 0;
	}
	for(int i = cnt;i >= 1;--i) 
		cout << '\n' << (u32) out[i];
	std::cerr << double(t) / CLOCKS_PER_SEC << '\n';
}

```


---

## 作者：Rui_R (赞：19)

题意：题如其名，带插入区间K小值。强制在线。

[原题](https://www.luogu.com.cn/problem/P4278)

这道题按道理来说是可以用奇妙的树套树两个$log$做过去的，但是由于题目右上角的那位毒瘤，被卡掉了。

那么能过的方法，就只有**块状链表+值域分块**了。

首先来介绍一下值域分块：

先看看怎么维护一个**数列**（不是区间）的静态K小值：

将值域(默认与 $n$ 同阶)分成$\sqrt{n}$块，第 $i$ 块表示第 $i$ 个范围为$\sqrt{n}$的值域。

弄两个数组，一个$Size$，一个$Alive$。$Size(i)$表示第 $i$ 块值域内出现了几个数，$Alive(i)$表示 $i$ 这个数在数列中共出现过几次。这两个数组可以轻松 $O(n)$ 建出。

然后对于整个K小值，我们可以**遍历每一块值域**，比较K与当前块内数的个数($Size$)的大小。若K大，将K减去当前块内个数，遍历下一块；否则**说明K小值就在这一块里了。** 那么就可以利用$Alive$数组，遍历该块内所有值直到找到K小值。复杂度显然为$O(\sqrt{n})$。

再来看看**区间**静态K小值：

仍然是值域分块，不过这次利用**前缀和**的思想。把序列也分成$\sqrt{n}$块，
将$Size,Alive$改成二维：$Size(i)(j)$表示序列前 $i$ 块中，值域第 $j$ 块内出现过几个数；$Alive(i)(j)$表示序列前 $i$ 块中，$j$ 这个数出现过几次。这两个数组能$O(n \sqrt{n})$ 得到。

在弄两个一维数组$s,cnt$ ，其用处大体与$Size,Alive$相同。具体见下文。

对于询问$l,r,k$ ，$l$属于第 $idl$ 块，$r$属于第 $idr$ 块

若$idl=idr$，暴力从 $l$ 扫到 $r$，把扫到的数拿去更新$s,cnt$。然后，用之前提到的做法$O(\sqrt{n})$得到答案。

否则，先暴力处理散块，更新$s,cnt$。然后，对于中间的块，我们可以利用
$Size(idr-1)(j)-Size(idl)(j)$得到 $idl+1$ 到 $idr-1$ 这一段的$s$。$cnt$ 同理。也就是在遍历值域时，以 $s(i)+Size(idr-1)(i)-Size(idl)(i)$ 作为真正的 $s(i)$ ，以$cnt(j)+Alive(idr-1)(j)-Alive(idl)$ 作为真正的 $cnt(j)$。
复杂度仍为$O(\sqrt{n})$。

在每次询问后，要把加进$s,cnt$里面的数从$s,cnt$里面扔掉，准备迎接下一次询问。

接下来考虑修改（单点）：

既然只要改一个值，那改掉其所在序列块及其以后所有块的$Size,Alive$即可。一次修改显然$O(1)$，由于序列块有$O(\sqrt{n})$ 块，单次修改复杂度仍为 $O(\sqrt{n})$，且几乎与静态代码量没有区别。

对比主席树，如果主席树要带修，那真是伤筋动骨的，对比值域分块也不再有多少优势。果然啊，越暴力的算法能维护的东西越多。

接下来，就是最后一关。插入：

介绍一下我们今天的第二位主角：块状链表。简单的说，就是序列块与序列块之间**以链表的形式相连**，**每个块内部维护其范围内的数列**。

那么插入的时候，就可以愉快的直接将对应序列块中该向后移的部分后移，复杂度为块长。之后再将$Size,Alive$中要增加的部分加上去，复杂度为块的数量。

问题来了，要是我们不断往同一个块里面插入呢？这个块岂不是会越来越长，最后导致复杂度倒退成$O(n)$?

这就是我们要把普通的分块改成块状链表的原因。当我们发现一个块长度变成
$2\sqrt{n}$的时候，我们直接把它弄成两半，每一份长为$\sqrt{n}$。
也就是把原来的块的后半部分撕下来，扔到一个新块上，且这个新块要变成在原来的块后面的第一个块。

考虑如何实现：把原块后半部分交给一个新块容易，毕竟数据量也就$O(\sqrt{n})$，且由于数据本身没有变化，不用去修改其他块，能够轻松$O(\sqrt{n})$ 解决。

而我们发现，要新开一个块，且该块要变成要求的块后面的第一个块，这个操作能够用**链表**相当容易的解决。于是，就有了块状链表。

复杂度，仍是铁打不动的$O(\sqrt{n})$ 。

$\texttt{Talk is cheap,show me your code.}$

```
#include <cstdio>

const int maxn=1e5+5,maxl=300;int maxx;

struct IO{
	IO(){};char c;
	inline char gc(){
		static char buf[maxn],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;
	}
	inline IO&operator>>(int &_){
		_=0;bool f=1;c=gc();while(c<'0'||c>'9'){if(c=='-') f=0; c=gc();}
		while(c>='0'&&c<='9'){_=_*10+c-48;c=gc();}if(!f) _=-_;return *this;
	}
	inline IO&operator<<(int x){
		if(!x){putchar(48);putchar('\n');return *this;}
		static int wt[40],len;len=0;if(x<0){putchar('-');x=-x;}
		for(;x;x/=10){wt[++len]=x%10;}
		while(len){putchar(wt[len--]+48);}
		putchar('\n');return *this;
	}
}io;

int n,m,block_size,last_ans;
int Size[maxl*3][maxl+5],Alive[maxl*3][maxn+5],pre_len[maxn],bl[maxn];//bl用来管下标的所属块，pre_len[i]表示c[i]前有几个数
int s[maxl+5],cnt[maxn];

inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}

inline int L(int id){return (id-1)*maxl+1;}
inline int R(int id){return min(id*maxl,maxx);}//这个用来管值域的分块情况
inline int where(int val){return (val-1)/maxl+1;}//值域所属块

struct Block{
	int size[maxl+5],alive[maxn];
	int a[(maxl<<1)+5],len;int lb,rb;
	inline void ins(int val){size[where(val)]++,alive[val]++;}
	inline void del(int val){size[where(val)]--,alive[val]--;}
	inline void insert(int pos,int val){
		len++;for(int i=len;i>=pos+2;i--) a[i]=a[i-1];
		a[pos+1]=val;//将val插到pos后面
	}
	inline void push_back(int val){a[++len]=val;}
	int& operator[](int id){
		return a[id];//这样会很舒爽
	}
}c[maxl];int block_len=0;

inline void modify(int pos,int val){
	int id=bl[pos],_=pos-pre_len[id];int old=c[id][_];
	c[id].del(old),c[id].ins(val);c[id][_]=val;
	for(int i=id;i;i=c[i].rb){
		Size[i][where(old)]--;Alive[i][val]++;
		Alive[i][old]--;Size[i][where(val)]++;
	}
}

inline void ins(int val){s[where(val)]++,cnt[val]++;}
inline void del(int val){s[where(val)]--,cnt[val]--;}

inline int query(int key){
	for(int i=1;i<=where(maxx);i++){
		if(key<=s[i]){
			for(int j=L(i);j<=R(i);j++){
				if(key<=cnt[j]) return j;
				key-=cnt[j];
			}
		}
		else key-=s[i];
	}//值域分块的玄妙操作
	return 0;
}

inline int Query(int l,int r,int key){
	int idl=bl[l],idr=bl[r];
	if(idl==idr){
		for(int i=l;i<=r;i++) ins(c[idl][i-pre_len[idl]]);
		int res=query(key);
		for(int i=l;i<=r;i++) del(c[idl][i-pre_len[idl]]);
		return res;
	}
	for(int i=l;i<=pre_len[c[idl].rb];i++) ins(c[idl][i-pre_len[idl]]);
	for(int i=pre_len[idr]+1;i<=r;i++) ins(c[idr][i-pre_len[idr]]);
	int res=0;
	for(int i=1;i<=where(maxx);i++){
		int now=s[i]+Size[c[idr].lb][i]-Size[idl][i];
		if(key<=now){
			for(int j=L(i);;j++){
				int _=cnt[j]+Alive[c[idr].lb][j]-Alive[idl][j];
				if(key<=_){res=j;break;}
				else key-=_;
			}break;
		}else key-=now;
	}//值域分块，多么美妙
	for(int i=l;i<=pre_len[c[idl].rb];i++) del(c[idl][i-pre_len[idl]]);
	for(int i=pre_len[idr]+1;i<=r;i++) del(c[idr][i-pre_len[idr]]);
	return res;
}

void split(int id){//把第id块拆了
	c[++block_len].lb=id;c[block_len].rb=c[id].rb;c[c[id].rb].lb=block_len;c[id].rb=block_len;
	int now=block_size+1;for(;now<=c[id].len;now++){c[block_len].push_back(c[id][now]),c[block_len].ins(c[id][now]),c[id].del(c[id][now]);}
	pre_len[block_len]=pre_len[id]+(c[id].len=block_size);
	for(int i=pre_len[block_len]+1;i<=pre_len[block_len]+c[block_len].len;i++) bl[i]=block_len;
	for(int i=1;i<=where(maxx);i++) Size[block_len][i]=(Size[id][i]=Size[c[id].lb][i]+c[id].size[i])+c[block_len].size[i];
	for(int i=1;i<=maxx;i++) Alive[block_len][i]=(Alive[id][i]=Alive[c[id].lb][i]+c[id].alive[i])+c[block_len].alive[i];
}

void insert(int pos,int val){
	int id=bl[pos];int _=pos-pre_len[id];
	c[id].insert(_,val);for(int i=c[id].rb;i;i=c[i].rb) pre_len[i]++;c[id].ins(val);
	for(int i=id;i;i=c[i].rb){
		Size[i][where(val)]++,Alive[i][val]++;
		bl[pre_len[i]+c[i].len]=i;bl[pre_len[i]+1]=i;
	}
	if(c[id].len>=block_size*2) split(id);//要是发现它不对劲
}

void build(){
	block_size=maxl;for(int i=1;i<=n;i++) bl[i]=(i-1)/block_size+1;
	block_len=bl[n];bl[0]=1;//我的代码中要是被要求把一个数插到第一个数，他会去找第零个数在哪块里面
	for(int i=1;i<=block_len;i++){
		c[i].lb=i-1,c[i].rb=i+1;
	}
	c[block_len].rb=0;
	for(int i=1;i<=n;i++){
		int x;io>>x;maxx=max(maxx,++x);//因为我讨厌0，所以所有出现的价值都被我加1了
		c[bl[i]].push_back(x);c[bl[i]].ins(x);
	}
	for(int i=1;i<=block_len;i++){
		pre_len[i]=pre_len[i-1]+c[i-1].len;
		for(int j=1;j<=where(maxx);j++) Size[i][j]=Size[i-1][j]+c[i].size[j];
		for(int j=1;j<=maxx;j++) Alive[i][j]=Alive[i-1][j]+c[i].alive[j];
	}
}

int main(){
	io>>n;build();io>>m;
	for(int i=1;i<=m;i++){
		char opt=io.gc();while(opt>'Z'||opt<'A') opt=io.gc();
		if(opt=='M'){
			int pos,val;io>>pos>>val;pos^=last_ans,val^=last_ans;maxx=max(maxx,val+1);
			modify(pos,val+1);
		}
		if(opt=='Q'){
			int l,r,k;io>>l>>r>>k;l^=last_ans,r^=last_ans,k^=last_ans;
			io<<(last_ans=Query(l,r,k)-1);//由于我把所有出现元素+1，这里要-1
		}
		if(opt=='I'){
			int pos,val;io>>pos>>val;pos^=last_ans,val^=last_ans;maxx=max(maxx,val+1);
			insert(pos-1,val+1);//意思是把(val+1)塞到(pos-1)后面
		}
	}
	return 0;
}
```

当然，需要吸氧才能卡过时限。这里我选择维护每个点的所属块和每个块之前有几个数，你也可以选择不维护，要用的时候$O(\sqrt{n})$扫一遍，得到其所属块和块前有几个数。

你甚至可以在块内部维护一个链表。这个写法常数比起块内维护数组要大一些，不过亲测也能卡过去。

---

## 作者：mrsrz (赞：19)

如果做过最初分块的话，看到这个题应该很快能想出$O(n\sqrt n)$的块状链表做法。

首先，对值域分块，然后只要知道区间中每个数的出现次数、每个块中数的出现次数，就可以$O(\sqrt n)$求出第$k$小。这个是一个常见套路。

然后我们需要维护的是一个序列，所以另一个常见的套路就是序列分块。

询问时，我们要快速求出一段区间内的每个数、每个块中数的出现次数，那么就有第三个常见套路：前缀和。对每个块，记录下每个数字出现次数的前缀和，每个值域块出现次数的前缀和。查询的时候，边角暴力统计，中间的直接用前缀和相减即可。其中预处理$O(n\sqrt n)$，查询单次$O(\sqrt n)$。

修改操作更新前缀和信息，有变化的数只有2个，因此直接暴力更新前缀和即可，单次$O(\sqrt n)$。

由于有插入操作的存在，所以普通的分块比较难维护。不难想到用块状链表来动态维护。时间复杂度为$O(\sqrt n)$。

其实并不一定需要块状链表，用分块套链表（和块状链表的区别是，和普通序列分块一样，块大小不变）也能做到同样的复杂度。

我们考虑在某个块插入一个数，这个块末尾就会多出一个数，我们要把它放在下一个块中，然后继续执行相同的操作。由于链表的尾部删除、头部插入为$O(1)$的，因此复杂度为$O(\sqrt n)$。而把一个数从一个块移动到下一个块，只会影响到它原来所在块的前缀和信息，所以更新信息的总复杂度也是$O(\sqrt n)$的。这样就同样做到了$O(n\sqrt n)$的总复杂度。

代码比块状链表要好写一点。我使用了```std::list```进一步简化了代码（但加大了常数，所以有点卡常）。

## Code：
```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<cctype>
#include<cstdio>
#include<list>
using namespace std;
char buf[(int)3e7],*ss=buf;
inline int init(){buf[fread(buf,1,(int)3e7-1,stdin)]='\n';fclose(stdin);return 0;}
const int __START__=init();
inline int readint(){
    int d=0;
    while(!isdigit(*ss))++ss;
    while(isdigit(*ss))d=d*10+(*ss++^'0');
    return d;
}
const int siz=300,blocks=235;
#define bel(x)((x-1)/siz+1)
list<int>s[300];
typedef list<int>::iterator iter;
int pre[70500][300],prb[300][300],m,ans,L[300],R[300],n,tot[70500],tob[300];
int sta[666],top=0;
inline int modify(list<int>&l,int x,int v){
	iter it=l.begin();
	while(x--)++it;
	const int ret=*it;
	*it=v;
	return ret;
}
void get(list<int>&l,int x,int s){
	iter it=l.begin();
	while(x--)++it;
	while(s--)++tot[sta[++top]=*it],++tob[bel(*it)],++it;
}
int main(){
	n=readint();
	for(int i=1;i<=blocks;++i)L[i]=R[i-1]+1,R[i]=i*siz;
	for(int i=1;i<=n;++i){
		int x=readint()+1;
		const int id=bel(i);
		s[id].push_back(x);
		int*P=pre[x],*B=prb[bel(x)];
		for(int j=id;j<=blocks;++j)++P[j],++B[j];
	}
	for(m=readint()^ans;m--;){
		while(isspace(*ss))++ss;
		switch(*ss){
			case'Q':{
				int l=readint()^ans,r=readint()^ans,k=readint()^ans;
				top=0;
				const int bL=bel(l),bR=bel(r);
				if(bL==bR){
					get(s[bL],l-L[bL],r-l+1);
					for(int i=1;;++i)
					if(k>tob[i])k-=tob[i];else{
						for(int j=L[i];;++j)
						if(k>tot[j])k-=tot[j];else{ans=j;break;}
						break;
					}
				}else{
					get(s[bL],l-L[bL],R[bL]-l+1),get(s[bR],0,r-L[bR]+1);
					for(int i=1;;++i)
					if(k>tob[i]+prb[i][bR-1]-prb[i][bL])k-=tob[i]+prb[i][bR-1]-prb[i][bL];else{
						for(int j=L[i];;++j)
						if(k>tot[j]+pre[j][bR-1]-pre[j][bL])k-=tot[j]+pre[j][bR-1]-pre[j][bL];else{ans=j;break;}
						break;
					}
				}
				printf("%d\n",--ans);
				for(int i=0;i<=top;++i)tot[sta[i]]=tob[bel(sta[i])]=0;
				break;
			}
			case'M':{
				int x=readint()^ans,v=readint()^ans;
				++v;
				const int id=bel(x);
				int old=modify(s[id],x-L[id],v);
				int*Po=pre[old],*Pn=pre[v],*Bo=prb[bel(old)],*Bn=prb[bel(v)];
				for(int i=id;i<=blocks;++i)
				--Po[i],--Bo[i],++Pn[i],++Bn[i];
				break;
			}
			case'I':{
				int x=readint()^ans,v=readint()^ans;
				++v;
				const int id=bel(x);
				iter it=s[id].begin();
				for(int i=x-L[id];i--;)++it;
				s[id].insert(it,v);
				int*P=pre[v],*B=prb[bel(v)];
				for(int i=id;i<=blocks;++i)++P[i],++B[i];
				for(int i=id+1;i<=blocks;++i)
				if(s[i-1].size()<=siz)break;else{
					int vl=s[i-1].back();
					--pre[vl][i-1],--prb[bel(vl)][i-1];
					s[i-1].pop_back();
					s[i].push_front(vl);
				}
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：Little_Fox_Fairy (赞：14)

~~前言：写了将近五个小时 。~~

如果做过 [最初分块](https://www.luogu.com.cn/problem/P4119) 的话，这道题还算挺好想的吧。

### 操作一：区间第 K 小。

序列分块加值域分块。

具体的，我们记录一个 $ sums $ 数组和 $ sumc $ 数组。$ sums[i][j] $ 表示在前 $ i $ 个序列块中有多少个数 $ j $。$ sumc[i][j] $ 表示在前 $ i $ 个序列块中有多少个数在值域的第 $ j $ 块当中。

然后对于散块，我们记录同样作用的 $ s $ 数组和 $ c $ 数组，不过只是对于散块的统计。

查询就是扫一遍值域块，用 $ sumc $ 和 $ c $ 数组来确定第 $ k $ 大在哪个值域块中。然后扫一遍答案所在的那个值域块，用 $ sums $ 数组和 $ s $ 数组就可以找到答案了。

值域毕竟只有 $ 7 \times 10^4 $ ，所以这个数组还是开得下的。

### 操作二：单点修改

这个就很好做了，对于我们要修改的那个点，先找到那个点所在的块，然后修改这个块以及后面块的 $ sums $ 数组和 $ sumc $ 数组就好了。

### 操作三：插入

由于有插入操作，那我们的序列分块就只能变为块状链表了。

块状链表，顾名思义，就是用链表穿起来的分块。

对于每一个块，还是维护三个：块内的值，$ sums $ 数组，和 $ sumc $ 数组。

但是要是一直在一个块内插入时间复杂度肯定会爆炸。所以要有一个分裂操作。

即当一个块的长度大于二倍块长时，我们就要将它分裂为两个块。分裂的时候就把信息拷贝一下，然后删去重复的，就做完了。

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fast_IO {
#define IOSIZE 100000
	char ibuf[IOSIZE], obuf[IOSIZE], *p1 = ibuf, *p2 = ibuf, *p3 = obuf;
#define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))
#define putchar(x) ((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
#define isdigit(ch) (ch>47&&ch<58)
#define isspace(ch) (ch<33)
	template<typename T> inline T read() { T s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s * w; }
	template<typename T> inline bool read(T &s) { s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s *= w, true; }
	template<typename T> inline void print(T x) { if (x < 0) putchar('-'), x = -x; if (x > 9) print(x / 10); putchar(x % 10 + 48); }
	inline bool read(char &s) { while (s = getchar(), isspace(s)); return true; }
	inline bool read(char *s) { char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) *s++ = ch, ch = getchar(); *s = '\000'; return true; }
	inline void print(char x) { putchar(x); }
	inline void print(char *x) { while (*x) putchar(*x++); }
	inline void print(const char *x) { for (int i = 0; x[i]; i++) putchar(x[i]); }
	inline bool read(std::string& s) { s = ""; char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) s += ch, ch = getchar(); return true; }
	inline void print(std::string x) { for (int i = 0, n = x.size(); i < n; i++) putchar(x[i]); }
	inline bool read(bool &b) { char ch; while(ch=getchar(), isspace(ch)); b=ch^48; return true; }
	inline void print(bool b) { putchar(b+48); }
	template<typename T, typename... T1> inline int read(T& a, T1&... other) { return read(a) + read(other...); }
	template<typename T, typename... T1> inline void print(T a, T1... other) { print(a), print(other...); }
	struct Fast_IO { ~Fast_IO() { fwrite(obuf, p3 - obuf, 1, stdout); } } io;
	template<typename T> Fast_IO& operator >> (Fast_IO &io, T &b) { return read(b), io; }
	template<typename T> Fast_IO& operator << (Fast_IO &io, T b) { return print(b), io; }
#define cout io
#define cin io
#define endl '\n'
} using namespace fast_IO;             //快读优化。
const int N=1e5+10;
const int C=350;
const int S=350;
struct Block
{
	vector<int> a;
	int lft=-1,rght=-1;
	int sums[N],sumc[C];
};
int n,m;
int limit=300,blo;
int bel[N],t[N];
int s[N],c[C],lst;
int T;
vector<Block> e;
Block tmp;
inline void init()
{
	bel[0]=1;for (int i=1;i<=1e5;i++) bel[i]=(i-1)/S+1;
	return ;
}                 //预处理值域块。
inline void split(int loc)
{
	tmp=e[loc];
	e.emplace_back(tmp);blo++;
	e[blo].lft=loc,e[blo].rght=e[loc].rght;
	if (e[loc].rght!=-1) e[e[loc].rght].lft=blo;
	e[loc].rght=blo;
	e[loc].a.erase(e[loc].a.begin()+limit,e[loc].a.end());
	e[e[loc].rght].a.erase(e[e[loc].rght].a.begin(),e[e[loc].rght].a.begin()+limit);
	for (auto v : e[e[loc].rght].a) e[loc].sums[v]--,e[loc].sumc[bel[v]]--;
	return ;
}             //块链的分裂操作。
inline void emplace(int pos,int x)     //插入。
{
	int loc=0;
//	if (pos==m+1)
//	{
//		e[blo].a.emplace_back(x);
//		loc=blo;
//	}
//	else
//	{
//		while (e[loc].a.size()<pos)
//		{
//			pos-=e[loc].a.size();
//			loc=e[loc].rght;
//			if (loc==-1) break;
//		}
//		pos--;
//		e[loc].a.emplace(e[loc].a.begin()+pos,x);
//	}                   //注意这里注释掉的做法是错的，有可能插入到最后一个数后面。
	while (e[loc].a.size()<pos)
	{
		pos-=e[loc].a.size();
		if (e[loc].rght==-1 and pos)
		{
			pos=e[loc].a.size()+1;
			break;
		}            //在这里特判一下。
		loc=e[loc].rght;
	}
	pos--;
	e[loc].a.emplace(e[loc].a.begin()+pos,x);
	for (int i=loc;i!=-1;i=e[i].rght) e[i].sums[x]++,e[i].sumc[bel[x]]++;
	if (e[loc].a.size()>(limit<<1)) split(loc);
	return ;
}
inline void update(int pos,int x)       //单点修改。
{
	int loc=0;
	while (e[loc].a.size()<pos)
	{
		pos-=e[loc].a.size();
		loc=e[loc].rght;
		if (loc==-1) break;
	}
	pos--;
	int pst=e[loc].a[pos];
	e[loc].sums[pst]--,e[loc].sumc[bel[pst]]--;
	e[loc].sums[x]++,e[loc].sumc[bel[x]]++;
	e[loc].a[pos]=x;
	for (int i=e[loc].rght;i!=-1;i=e[i].rght) e[i].sums[pst]--,e[i].sumc[bel[pst]]--,e[i].sums[x]++,e[i].sumc[bel[x]]++;
	return ;
}
inline int query(int l,int r,int k)   //查询区间第k大。
{
	int bll=0;
	while (e[bll].a.size()<l)
	{
		l-=e[bll].a.size();
		bll=e[bll].rght;
		if (bll==-1) break;
	}
	l--;
	int blr=0;
	while (e[blr].a.size()<r)
	{
		r-=e[blr].a.size();
		blr=e[blr].rght;
		if (blr==-1) break;
	}
	r--;
	if (bll==blr)
	{
		for (int i=l;i<=r;i++) s[e[bll].a[i]]++,c[bel[e[bll].a[i]]]++;
		int siz=0,ll,rr;
		for (int i=1;i<=C;i++)
		{
			siz+=c[i];
			if (siz>=k)
			{
				siz-=c[i];
				ll=(i-1)*S+1;
				if (i==1) ll=0;
				rr=i*S;
				break;
			}
		}
		int ans=0;
		for (int i=ll;i<=rr;i++)
		{
			siz+=s[i];
			if (siz>=k)
			{
				ans=i;
				break;
			}
		}
		for (int i=l;i<=r;i++) s[e[bll].a[i]]--,c[bel[e[bll].a[i]]]--;
		return ans;
	}
	if (e[blr].lft==-1) exit(0);
	for (int i=l;i<e[bll].a.size();i++) s[e[bll].a[i]]++,c[bel[e[bll].a[i]]]++;
	for (int i=0;i<=r;i++) s[e[blr].a[i]]++,c[bel[e[blr].a[i]]]++;
	int siz=0,ll,rr;
	for (int i=1;i<=C;i++)
	{
		siz+=(c[i]+e[e[blr].lft].sumc[i]-e[bll].sumc[i]);
		if (siz>=k)
		{
			siz-=(c[i]+e[e[blr].lft].sumc[i]-e[bll].sumc[i]);
			ll=(i-1)*S+1;
			if (i==1) ll=0;
			rr=i*S;
			break;
		}
	}
	int ans=0;
	for (int i=ll;i<=rr;i++)
	{
		siz+=(s[i]+e[e[blr].lft].sums[i]-e[bll].sums[i]);
		if (siz>=k)
		{
			ans=i;
			break;
		}
	}
	for (int i=l;i<e[bll].a.size();i++) s[e[bll].a[i]]--,c[bel[e[bll].a[i]]]--;
	for (int i=0;i<=r;i++) s[e[blr].a[i]]--,c[bel[e[blr].a[i]]]--;
	return ans;
}
inline void calc()   //对于原序列的块链处理。
{
	e.emplace_back();
	for (int i=1;i<=n;i++)
	{
		e[blo].a.emplace_back(t[i]);
		e[blo].sums[t[i]]++;
		e[blo].sumc[bel[t[i]]]++;
		if (e[blo].a.size()>(limit<<1)) split(blo);
	}
	m=n;
	return ;
}
signed main()
{
	init();
	cin>>n;
	for (int i=1;i<=n;i++) cin>>t[i];
	calc();
	cin>>T;
	while (T--)
	{
		char op;int x,val,l,r,k;
		cin>>op;
		if (op=='Q')
		{
			cin>>l>>r>>k;
			l^=lst,r^=lst,k^=lst;
			lst=query(l,r,k);
			cout<<lst<<endl;
		}
		if (op=='M')
		{
			cin>>x>>val;
			x^=lst,val^=lst;
			update(x,val);
		}
		if (op=='I')
		{
			cin>>x>>val;
			x^=lst,val^=lst;
			emplace(x,val);
			m++;
		}
	}
	return (0-0);
}
```

---

## 作者：Freopen (赞：10)

我是来给daniel14311531大佬的$n\sqrt n$[方法](https://www.luogu.org/blog/acdevelopers/dai-cha-ru-ou-jian-k-xiao-zhi-geng-wei-you-xiu-di-xie-fa)做注解的。

1.分块怎么高效求第K大。
首先网上那些二分套主席树套分块之类的都不在我们的讨论范围，一点也不优美。


下面介绍一个大杀器，时代的新（对博主来说是新）科技：

值域分块。

就是对查询的值域进行分块。

具体来说就是设两个数组S1[]和S2[]

S1[i] = 值在$[i*S,i*S+S-1]$间的数的数量。

S2[i] = 值为$i$的数的数量。

那么求第K大就可以从小到大枚举块，求出第K大在值域中的哪一块。

然后再在那一块中枚举权值。


两步都是$O(\sqrt n)$的。

那么如果跨越多块，我们就需要做到$O(1)$求出一个区间内所有块的S1,S2

可以前缀和。
恰好 。。。。。这个S1,S2的修改是$O(1)$的，那么修改前缀和就是$O(\sqrt n)$的，
所以总复杂度还是$O(\sqrt n)$的！
不完整的块把他们的S1,S2暴力求出即可。


2.如何在有插入的情况下维护分块。

块状链表。

就是不把块放在序列上。

前一块和后一块互相连接像链表一样。

块中是一个数组。

有$O(\sqrt n)$个块，块大小为$O(\sqrt n)$。

那么我们相当于是把对于插入-查询操作$O(1)-O(n)$的链表和$O(n)-O(1)$的数组按照一块一块交错实现，得到了一个对于插入-查询操作$O(1)+O(\sqrt n)-O(\sqrt n)+O(1)$的数据结构-块状链表。
其实链表套链表也是$O(\sqrt n) - O(\sqrt n)$的。。。。。。但是实现时会引起不适。
分块的所有操作都可以用块状链表实现，实现方法类似。
上面的值域分块同理。

真的比$O(n\log ^2n)$快好多。。。。。。。
AC Code:
```cpp
#include<bits/stdc++.h>
#define maxn 70005
#define S 310
using namespace std;

char cb[1<<17],*cs=cb,*ct=cb;
#define getc() (cs==ct&&(ct=(cs=cb)+fread(cb,1,1<<17,stdin),cs==ct)?0:*cs++)
inline void read(int &res){
	char ch;
	for(;!isdigit(ch=getc()););// if(ch=='-') f=1;
	for(res=ch-'0';isdigit(ch=getc());res=res*10+ch-'0');
	//(f) && (res=-res);
}

int n;

struct block{
	int lb,rb;
	int a[S*2+10],cntS[maxn/S+5],cnt[maxn],siz;
}B[maxn/S],Nb;
int flb = 1 , cnt_bl = 0 , Mx = 0;
int id[maxn];

int Query(int x,int y,int k){
	int lb=1,rb=1,ret=0;
	for(;B[lb].siz && B[lb].siz<x;x-=B[lb].siz,lb=B[lb].rb);
	for(;B[rb].siz && B[rb].siz<y;y-=B[rb].siz,rb=B[rb].rb);
	//printf("%d %d %d\n",lb,rb,B[1].siz);
	if(lb == rb){
		//printf("%d %d\n",x,y);
		for(int i=x-1,j=y-1,tmp;i<=j;i++){
			//printf("%d\n",id[B[lb].a[i]]);
			tmp = B[lb].a[i];
			Nb.cntS[id[tmp]]++,
			Nb.cnt[tmp]++;
		}
		for(int i=1;i<=id[maxn-1];i++){
			//printf("%d %d\n",Nb.cntS[i],k);
			if(Nb.cntS[i]>=k){
				for(int j=(i-1)*S;;j++){
					//printf("%d %d\n",j,k);
					if(k<=Nb.cnt[j]){ ret=j;break; }
					else k-=Nb.cnt[j];
				}
				break;
			}
			else k-=Nb.cntS[i];
		}
		for(int i=x-1,j=y-1,tmp;i<=j;i++){
			//printf("%d\n",id[B[lb].a[i]]);
			tmp = B[lb].a[i];
			Nb.cntS[id[tmp]]--,
			Nb.cnt[tmp]--;
		}
		return ret;
	}
	for(int i=x-1,tmp;i<B[lb].siz;i++){
		tmp = B[lb].a[i],
		Nb.cntS[id[tmp]]++,
		Nb.cnt[tmp]++;
	}
	for(int i=0,tmp;i<y;i++){
		tmp = B[rb].a[i],
		Nb.cntS[id[tmp]]++,
		Nb.cnt[tmp]++;
	}
	rb=B[rb].lb;
	for(int i=1,tmp;i<=id[Mx];i++){
		tmp = Nb.cntS[i]+B[rb].cntS[i]-B[lb].cntS[i];
		if(tmp>=k){
			for(int j=(i-1)*S,res;;j++){
				res = Nb.cnt[j]+B[rb].cnt[j]-B[lb].cnt[j];
				if(k<=res){ ret=j;break; }
				else k-=res;
			}
			break;
		}
		else k-=tmp;
	}
	rb=B[rb].rb;
	for(int i=x-1,tmp;i<B[lb].siz;i++){
		tmp = B[lb].a[i],
		Nb.cntS[id[tmp]]--,
		Nb.cnt[tmp]--;
	}
	for(int i=0,tmp;i<y;i++){
		tmp = B[rb].a[i],
		Nb.cntS[id[tmp]]--,
		Nb.cnt[tmp]--;
	}
	return ret;
}

void Modify(int x,int y){
	int lb=1;
	for(;B[lb].siz && B[lb].siz<x;x-=B[lb].siz,lb=B[lb].rb);
	int py = B[lb].a[x-1]; B[lb].a[x-1] = y;
	for(;lb;lb=B[lb].rb)
		B[lb].cntS[id[py]]--,
		B[lb].cntS[id[y]]++,
		B[lb].cnt[py]--,
		B[lb].cnt[y]++;
}

void split(int x){
	B[++cnt_bl].lb=x,B[cnt_bl].rb=B[x].rb;
	B[B[x].rb].lb=cnt_bl,B[x].rb=cnt_bl;
	B[cnt_bl].siz = S , B[x].siz -= S;
	memcpy(B[cnt_bl].a,B[x].a+B[x].siz,S*sizeof(int));
	memcpy(B[cnt_bl].cntS,B[x].cntS,sizeof B[x].cntS);
	memcpy(B[cnt_bl].cnt,B[x].cnt,sizeof B[x].cnt);
	for(int i=0;i<S;i++) 
		B[x].cntS[id[B[cnt_bl].a[i]]]--,
		B[x].cnt[B[cnt_bl].a[i]]--;
}

void Insert(int x,int y){
	int lb=1;x--;
	for(;B[lb].siz && B[lb].siz<x;x-=B[lb].siz,lb=B[lb].rb);
	for(int i=B[lb].siz++;i>x;i--) B[lb].a[i] = B[lb].a[i-1];
	B[lb].a[x]=y;
	for(int i=lb;i;i=B[i].rb)
		B[i].cntS[id[y]]++,
		B[i].cnt[y]++;
	if(B[lb].siz>=2*S) 
		split(lb);
}

int main(){
	//int t1 = clock();
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	read(n);
	for(int i=0;i<maxn;i++) id[i]=i/S+1;
	cnt_bl=id[n-1];
	for(int i=0;i<n;i++){
		int u = id[i] , x;
		read(x);
		B[u].a[B[u].siz++] = x;
		B[u].cntS[id[x]]++;
		B[u].cnt[x]++;
		Mx = max(Mx , x);
	}
	for(int i=2;i<=cnt_bl;i++)
	{
		B[i-1].rb=i,B[i].lb=i-1;
		for(int j=0;j<=Mx;j++){
			B[i].cnt[j] += B[i-1].cnt[j];
			if(j==0 || id[j]!=id[j-1]) 
				B[i].cntS[id[j]] += B[i-1].cntS[id[j]];
		}
	}
	int q;
	read(q);
	char s[2];
	for(int x,y,k,la=0;q--;){
		while(!isalpha(s[0]=getc()));
		//puts(s);
		//printf("@@@@%d\n",allsiz);
		if(s[0] == 'Q'){
			read(x),read(y),read(k);
			x ^= la , y ^= la , k ^= la;
			//printf("@@%d %d %d\n",x,y,k);
			printf("%d\n",la=Query(x,y,k));
		}
		else if(s[0] == 'M'){
			read(x),read(y);
			x ^= la , y ^= la;
			Mx = max(Mx ,y);
			//printf("$$%d %d\n",x,y);
			Modify(x,y);
		}
		else {
			read(x),read(y);
			x^=la , y ^= la;
			Mx = max(Mx , y);
			//printf("##%d %d\n",x,y);
			Insert(x,y);
		}
		//puts(s);
		//printf("%d\n",B[1].siz);
	}
	//freopen("CON","w",stdout);
	//printf("%d\n",clock()-t1);
}
```


---

## 作者：Seauy (赞：6)

目前有的做法是（默认元素个数、操作数、值域同阶）：

1. 重量平衡树/替罪羊树+线段树合并，时间 $O(n\log^2 n)$，空间 $O(n\log^2 n)$，常数较大。
2. 定期分裂块状链表，时间 $O(n\sqrt{n})$，空间 $O(n\sqrt n)$，常数较小。

其他什么二分+树套树、操作分块或各种分块、分块/平衡树/线段树/树状数组互相套的做法就不仔细列了，要么常数被第二个做法吊打要么理论复杂度被第一个做法吊打。

第一种做法的空间常数较为玄学导致数组大小有些难开（写指针式线段树时空常数双炸），原因是重量平衡树旋转时重构子树的 $\log n$ 的常数有些难估，以及替罪羊树的常数其实是一坨关于平衡系数 $\alpha$ 的式子。拿替罪羊树举例子，如果你把数据下下来，会发现全过程要新建非常多个结点，只能通过重构/删除元素时尽量回收结点降低常数，但并不会降低空间复杂度。

实际上我们采用这种策略：每 $\frac{n}{\log n}$ 次操作就重构整棵替罪羊树，时间上会增加整体重构的开销，一次重构复杂度 $O(n\log n)$ 所以总共是 $O(n \log^2 n)$ 不会使复杂度退化，此时空间就被优化为 $O(n \log n)$，因为建树需要的空间是 $O(n \log n)$，而 $\frac{n}{\log n}$ 次操作均摊每次增加 $O(\log^2 n)$ 的空间。

有人可能要问：替罪羊树的均摊是不是不对？$n$ 个元素 $m$ 次操作重构时遍历的结点个数其实是 $O((n+m)\log n)$ 的，令 $m=\frac{n}{\log n}$ 并不能降低复杂度。实际上 $n+m$ 中的 $n$ 是可以去掉的，[回顾替罪羊树的均摊分析](https://www.luogu.com.cn/article/gumagxls)，由于这题里我只有插入操作，所以初始的势能 $\phi_0$ 就是最低势能，得出重构的总复杂度跟插入的总复杂度成正比。

最终我们得到了时间 $O(n\log^2 n)$ 空间 $O(n \log n)$ 的做法，但时间常数进一步提升了所以不太指望能在当前数据下吊打块状链表，不过空间开销倒是可以一战了，~~可无奈其空间常数也实在太小了，拼尽全力无法战胜~~。

下面给出个参考代码，挺短的，最大的点 1.94s，63.42MB，或许可以继续调参做到更优。


```cpp
#include<bits/stdc++.h>
using namespace std;

const double alpha=0.955;
const int MAXN=35e3,MAXM=14e4,MAXV=7e4,LOGM=ceil(log(MAXM)/log(1.0/alpha)+1);
const int SIZE=6e6,LIM=5e6;

int Read()
{
	int res=0;char c;
	while(!isdigit(c=getchar()));
	while(isdigit(c)) res=res*10+c-'0',c=getchar();
	return res;
}
int GetOP()
{
	char c;
	while(!isalpha(c=getchar()));
	if(c=='Q') return 1;
	if(c=='M') return 2;
	return 3;
}
void Print(int x)
{
	if(x<10) {putchar('0'+x);return;}
	int y=x/10;
	Print(y);
	putchar('0'+x-y*10);
}

int sum[SIZE+5],lson[SIZE+5],rson[SIZE+5],tot;

int New(int x) {sum[++tot]=x; return tot;}
int Plus(int now,int L,int R,int x,int v)
{
	int res=New(sum[now]+v);
	if(L==R) {lson[res]=rson[res]=0; return res;}
	int mid=(L+R)>>1;
	if(x<=mid) lson[res]=Plus(lson[now],L,mid,x,v),rson[res]=rson[now];
	else lson[res]=lson[now],rson[res]=Plus(rson[now],mid+1,R,x,v);
	return res;
}
int Merge(int a,int b)
{
	if(!a || !b) return a^b;
	int res=New(sum[a]+sum[b]);
	lson[res]=Merge(lson[a],lson[b]);
	rson[res]=Merge(rson[a],rson[b]);
	return res;
}

int n,q,root,A[MAXM+5],Size[MAXM+5],Lson[MAXM+5],Rson[MAXM+5],rt[MAXM+5],val[MAXM+5],m;

int Q[4*LOGM+5],Tail;
void GetQ(int now,int L,int R)
{
	if(L==1 && R==Size[now]) {Q[++Tail]=rt[now];return;}
	if(L<=Size[Lson[now]]+1 && Size[Lson[now]]+1<=R) Q[++Tail]=val[now];
	if(L<=Size[Lson[now]]) GetQ(Lson[now],L,min(R,Size[Lson[now]]));
	if(Size[Lson[now]]+1<R) GetQ(Rson[now],max(1,L-Size[Lson[now]]-1),R-Size[Lson[now]]-1);
}
int Search(int L,int R,int x)
{
	if(L==R) return L;
	int Lsize=0,mid=(L+R)>>1;
	for(int i=1;i<=Tail;i++) Lsize+=sum[lson[Q[i]]];
	if(x<=Lsize) {for(int i=1;i<=Tail;i++) Q[i]=lson[Q[i]]; return Search(L,mid,x);}
	for(int i=1;i<=Tail;i++) Q[i]=rson[Q[i]]; return Search(mid+1,R,x-Lsize);
}
int Query(int L,int R,int x) {Tail=0,GetQ(root,L,R); return Search(0,MAXV,x);}

int Modify(int now,int x,int v)
{
	if(Size[Lson[now]]+1==x)
	{
		int res=A[now];
		val[now]=Plus(val[now],0,MAXV,A[now],-1),rt[now]=Plus(rt[now],0,MAXV,A[now],-1);
		A[now]=v;
		val[now]=Plus(val[now],0,MAXV,A[now],1),rt[now]=Plus(rt[now],0,MAXV,A[now],1);
		return res;
	}
	int res;
	if(x<=Size[Lson[now]]) res=Modify(Lson[now],x,v);
	else res=Modify(Rson[now],x-Size[Lson[now]]-1,v);
	rt[now]=Plus(rt[now],0,MAXV,res,-1),rt[now]=Plus(rt[now],0,MAXV,v,1);
	return res;
}

int tmp[MAXM+5];
void GetTmp(int now) {if(now) GetTmp(Lson[now]),tmp[++Tail]=now,GetTmp(Rson[now]);}
int Build(int L,int R)
{
	if(L>R) return 0;
	int mid=(L+R)>>1,now=tmp[mid];
	Lson[now]=Build(L,mid-1),Rson[tmp[mid]]=Build(mid+1,R);
	rt[now]=Merge(Merge(rt[Lson[now]],rt[Rson[now]]),val[now]=Plus(0,0,MAXV,A[now],1));
	Size[now]=Size[Lson[now]]+1+Size[Rson[now]];
	return now;
}
void Rebuild(int &now)  {Tail=0,GetTmp(now),now=Build(1,Tail);}
void Insert(int &now,int x,int v)
{
	if(!now) {A[now=++m]=v,rt[now]=val[now]=Plus(0,0,MAXV,v,1),Size[now]=1;return;}
	++Size[now];
	rt[now]=Plus(rt[now],0,MAXV,v,1);
	if(x<=Size[Lson[now]]+1) Insert(Lson[now],x,v);
	else Insert(Rson[now],x-Size[Lson[now]]-1,v);
	if(alpha*Size[now]<max(Size[Lson[now]],Size[Rson[now]])) Rebuild(now);
}

int main()
{
	n=m=Read();
	for(int i=1;i<=n;i++) A[i]=Read(),tmp[i]=i;
	root=Build(1,n);
	q=Read();
	int cnt=0;
	for(int opt,x,y,lst=0;q--;)
	{
		opt=GetOP(),x=Read()^lst,y=Read()^lst;
			 if(opt==1) Print(lst=Query(x,y,Read()^lst)),putchar('\n');
		else if(opt==2) Modify(root,x,y);
		else Insert(root,x,y);
		if(tot>LIM) tot=0,Rebuild(root);
	}
	return 0;
}
```

[UT](https://www.luogu.com.cn/user/250637) 给了个常数更小的做法：外层用树状数组维护值域，内层用平衡树维护下标，需要比较两个元素位置的前后关系，用动态标号法（参考[可持久化并查集](https://www.luogu.com/article/suz8viqt)和后缀平衡树）。

---

## 作者：缪凌锴_Mathew (赞：5)

### 前言

不会块状链表……

### 做法

既然不会块状链表，我们可以操作分块。

设块长是 $L$，那么每 $L$ 次修改重构出当前 $a$ 数组。

查询 $[l,r]$ 时先倒推出其对应在这个操作分块开始时的 $a$ 上的区间 $[l',r']$，计算这个操作分块内的修改对它的贡献加上 $[l',r']$的贡献。

具体的：

- 假设当前询问是 $[l,r]$，令 $l'=l,r'=r$。
- 倒推操作分块块内的修改：
- `M p v` 修改，那么记录修改前 $a_p$ 的数值 $lst$，如果 $l'\le p \le r'$ 则贡献 $v$ 个数 $+1$，$lst$ 个数 $-1$。
- `I p v` 插入，如果 $l'\le p \le r'$ 则贡献 $v$ 个数 $+1$，若 $l'>p$ 则 $l'\gets l'-1$，若 $r'\ge p$ 则 $r'\gets r'-1$
- 最后对于 $i\in[l',r']$，$a_i$ 个数 $+1$

总共有 $O(L)$ 个贡献加上 $a_{l'}\sim a_{r'}$ 的贡献。

如何维护 $O(L)$ 个贡献？把它们加入权值线段树就能线段树上二分了。

至于 $a_{l'}\sim a_{r'}$ 重构时主席树即可。

查询在这两棵树上多树二分。

这时候还漏了一件事：重构需要知道现在的 $a$ 序列，需要数据结构支持：插入，修改，遍历。用平衡树即可（~~当然可以偷懒直接 vector.insert~~）。

分析复杂度（假设 $n,m$ 同阶）：

查询 $O(nL\log V)$，重构 $O(\dfrac{n^2}{L}\log V)$，取 $L=\sqrt n$，复杂度 $O(n\sqrt n \log V)$。

但是实际上 $m$ 高达 $2.1\times10^5$，跑 $m\sqrt n \log V$ 根本过不去。

我们发现查询算贡献部分是 $O(n\sqrt n\log V)$，多树二分却是 $O(n\log V)$ 的，想办法平衡一下常数。

注意到二分的是一个前缀，那么我们想到用权值树状数组。

但是原本的主席树怎么办，可持久化树状数组（要么开 `map` 要么动态开点）和主席树吗没有两样。

我们可以序列分块，每个块开一个权值树状数组，设块长为 $B$，这样 $a_{l'}\sim a_{r'}$ 的贡献就是 $O(\dfrac{n}{B})$ 个整块权值树状数组加上 $O(B)$ 个散块权值。

把这 $O(B)$ 个散块权值加入刚刚的维护操作分块贡献的权值树状数组内，然后在 $O(\dfrac{n}{B})$ 个整块和这个权值树状数组上多树二分。

树状数组上二分（其实类似于倍增）：

> 树状数组的性质：节点 $tr_i$ 维护 $(i-\operatorname{lowbit}(i),i]$ 的区间。
>
> 查询最大前缀 $x$ 使 $1\sim x$ 权值和 $<k$（答案为 $x+1$，即最小的前缀权值和 $\ge k$）
>
> 设当前答案为 $res$，当前和为 $sum$（初值都为 $0$）。
>
> 从 $\log V$ 到 $0$ 枚举二进制位 $i$，若 $sum+tr_{res+2^i}\le k$，则 $sum\gets sum+tr_{res+2^i},res\gets res+2^i$，因为 $tr_{res+2^i}$ 维护的是区间 $(res,res+2^i]$。

最终复杂度：

操作分块散块 $O(nL\log V)$，重构 $O(\dfrac{n^2}{L}\log V)$，序列分块查询 $O(nB\log V)+O(\dfrac{n^2}{B}\log V)$，取 $L=\sqrt n,B=\sqrt n$，时间复杂度 $O(n\sqrt n\log V)$，但是树状数组常数小了。

空间复杂度：序列分块每块一个树状数组 $O(n\sqrt n)$。

### Code

```cpp
const int MAXN=7e4+10;
const int N=7e4;
const int INF=0x3f3f3f3f;
const long long LINF=0x3f3f3f3f3f3f3f3f;
int n,m,q,ans=0;
const int B=256;
const int MAXB=(N/B)+5;
const int V=7e4;
const int LIM=1024;
const int MAXM=LIM+5;
namespace BIT{
    int tr[MAXB][MAXN];
    #define lowbit(x) x&-x
    int cnt=0;
    int mdf[(MAXM+B)<<1];
    inline void clear_pos(int pos,int x){
        if(!pos){
            tr[x][0]=0;
            return ;
        }
        for(int i=pos;i<=V;i+=lowbit(i))
        {
            if(!tr[x][i]){
                return ;
            }
            tr[x][i]=0;
        }
    }
    inline void clear(){
        for(int i=1;i<=cnt;i++)
        {
            BIT::clear_pos(mdf[i],0);
        }
        cnt=0;
    }
    inline void modify(int pos,int val,int x){
        if(!x){
            cnt++;
            mdf[cnt]=pos;
        }
        if(!pos){
            tr[x][0]+=val;
            return ;
        }
        for(int i=pos;i<=V;i+=lowbit(i))
        {
            tr[x][i]+=val;
        }
    }
    inline int query_pos(int l,int r,int pos,int k){
        int res=tr[0][pos];
        for(int i=l;i<=r;i++)
        {
            res+=tr[i][pos];
            if(res>=k){[[unlikely]]
                return res;
            }
        }
        return res;
    }
    inline int query(int l,int r,int k){
        int res=0,now=query_pos(l,r,0,k);
        if(k<=now){
            return 0;
        }
        k-=now;
        for(int i=16;~i;i--)
        {
            int to=res|(1<<i);
            if(to>V){
                continue;
            }
            now=query_pos(l,r,to,k);
            if(now<k){
                k-=now;
                res=to;
            }
        }
        return res+1;
    }
}
basic_string <int> arr;
int a[MAXN];
int idx[MAXN];
inline void build(){
    int l=0,r=0;
    for(int i=1;i<=m;i++)
    {
        l=r+1;
        r=min(l+B-1,n);
        for(int j=l;j<=r;j++)
        {
            BIT::clear_pos(a[j],i);
        }
    }
    n=arr.size();
    for(int i=1;i<=n;i++)
    {
        a[i]=arr[i-1];
    }
    m=(n+B-1)/B;
    l=0;
    r=0;
    for(int i=1;i<=m;i++)
    {
        l=r+1;
        r=min(l+B-1,n);
        for(int j=l;j<=r;j++)
        {
            idx[j]=i;
            BIT::modify(a[j],1,i);
        }
    }
}
int cnt=0;
bool typ[MAXM];
int pos[MAXM],val[MAXM],lst[MAXM];
inline int query(int l,int r,int k){
    BIT::clear();
    for(int i=cnt;i;i--)
    {
        if(!typ[i]){
            if(l<=pos[i]&&pos[i]<=r){
                BIT::modify(lst[i],-1,0);
                BIT::modify(val[i],1,0);
            }
        }
        else{
            if(l<=pos[i]&&pos[i]<=r){
                BIT::modify(val[i],1,0);
            }
            (l>pos[i])&&(l--);
            (r>=pos[i])&&(r--);
        }
    }
    if(l<=r){
        if(idx[l]==idx[r]){
            for(int i=l;i<=r;i++)
            {
                BIT::modify(a[i],1,0);
            }
        }
        else{
            for(int i=l;idx[i]==idx[l];i++)
            {
                BIT::modify(a[i],1,0);
            }
            for(int i=r;idx[i]==idx[r];i--)
            {
                BIT::modify(a[i],1,0);
            }
        }
        return BIT::query(idx[l]+1,idx[r]-1,k);
    }
    return BIT::query(1,0,k);
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++)
    {
        arr.push_back(read());
    }
    build();
    q=read();
    for(int i=1;i<=q;i++)
    {
        char opt=getchar();
        while(opt^'Q'&&opt^'M'&&opt^'I')
        {
            opt=getchar();
        }
        if(opt=='Q'){
            int l=read()^ans,r=read()^ans,k=read()^ans;
            ans=query(l,r,k);
            printf("%d\n",ans);
        }
        if(opt=='M'){
            int p=read()^ans,v=read()^ans;
            cnt++;
            pos[cnt]=p;
            lst[cnt]=arr[p-1];
            val[cnt]=v;
            typ[cnt]=false;
            arr[p-1]=v;
        }
        if(opt=='I'){
            int p=read()^ans,v=read()^ans;
            cnt++;
            pos[cnt]=p;
            val[cnt]=v;
            typ[cnt]=true;
            arr.insert(arr.begin()+p-1,v);
        }
        if(cnt==LIM){
            cnt=0;
            build();
        }
    }
    return 0;
}
```

---

## 作者：金珂拉 (赞：5)

## 静态区间k小值

首先我们先考虑静态维护区间 $k$ 小值。

容易想到二维分块：对值域与下标都进行分块

考虑如果所有的 $l$ 到 $r$ 这个区间刚好是完整的块的时候，该怎么维护？

显然我们可以先维护一个数组 $ a_{ij} $ 表示在第i个下标块、第j个值域块的数的个数。再对每一个值域块维护前缀和 $ sum_{ij}=\sum_{k=1}^i a_{kj} $。

同样的对于块内的散点也维护一个数组 $ b_{i,j} $ 表示第i块内值刚好是j的数的个数，也个前缀和数组。然后就像权值分块那样扫过去，即可 $ T+\frac{n}{T} $ 求静态区间 $k$ 小值。

再考虑，在上面的基础上，额外给定一个数组（元素个数 $T_2$）,求这个数组与一个刚好是整块的区间合并起来之后的第 $k$ 小值，怎么做？

我们可以考虑把这 $T_2$ 个数全部塞到最右边的下标块里，或者放入新建的一个额外块中，在求完 $k$ 小值后再取出来。因为我们求 $k$ 小值不需要用到比最右边一块还要右侧的 $sum$ 数组，所以不用去维护前缀和，只要修改最右边一块的 $sum$ 值就行。

因此，当 $l$ 与 $r$ 不是整块的时候，我们就可以将两端的散点当成给定的数组丢进去就行了。

假设下标块长为 $T_2$，值域块长为 $T_1$。

所以查询一次静态区间k小值复杂度是 $O(T_2+T_1+\frac{n}{T_1})$,预处理复杂度为 $O(\frac{N}{T_2} \times N)$。

## 带插区间k小值

假设原序列为 $A$,则我们在任意时刻，任取一段区间，不考虑下标顺序，这段区间内的数集相当于是序列 $A$ 中取出一段，删除一些数，增加一些数得到的数集。

修改操作相当于删一个插一个，插入操作不用多说。

如果删除的数和增加的数的总数为 $T_3$,我们就可以通过上半部分提到的方法，$O(T_3+T_2+T_1+\frac{n}{T_1})$，通过维护原序列 $A$ 上的区间与增加的数合起来的区间第k小值来维护修改后序列的区间第k小值了。

我们可以维护一个链表，链表上存放一些四元组 $(l,r,tag1,tag2)$。

对于 $tag1=-1$ 的情况，这个四元组表示原数组的 $l$ 到 $r$ 的这段区间，$tag2$ 可被忽略。

对于 $tag\not=-1$ 的情况，这个四元组表示一个值为 $tag1$ 的数，$l$ 与 $r$ 可被忽略。此时，若 $tag2=0$ 表示这是插入的数；若 $tag2=1$ 表示这是对一个插入的数做修改操作得到的数；若 $tag2=3$ 表示这是原数列上的某个数被做修改得到的数。

我们设每次查询的时候，得到的一段区间是从原序列 $A$ 的某一个区间 $S$ 经过修改得到的。求 $S$ 区间的时候可以直接暴力在链表里扫一遍。

对于所有 $tag1!=-1$ 的情况相当于在S上加入了某个数，其中对于 $tag2=3$ 的情况相当于还要额外在 $S$ 中去除某个数。

对于插入或者修改操作，暴力在链表上找，如果要修改或者插入的位置刚好在某一个四元组代表的区间内，就通过修改l与r的值将这个四元组分成两个四元组，然后对于修改操作再注意一下 $tag2$ 的标记。

所以我们便可以用 $ O(T_2+T_1+\frac{n}{T_1}+T_3) $ 的复杂度完成询问操作，$O(T_3)$ 完成修改操作。

但是这样显然当链表内节点过多的时候会出现 $T_3=N$ 的情况。

所以我们可以做一个优化：

当链表内的节点个数超过某个值的时候，我们就需要把链表里的数取出来变成一个新的序列，把这个序列当作 $A$ 数组，然后重新预处理出静态区间第k小。

依旧设这个值为 $T_3$。

每次修改/插入操作都会导致多出 $2$ 个数。忽略常数并且最劣化考虑，假设全是修改没有查询，就是每经过 $T_3$ 次操作就要重新得到序列并且预处理。

也就是说多次重构的总复杂度是 $O(\frac{M}{T_3}\times \frac{N}{T_2} \times N)$。

再考虑单次操作的复杂度，假设全是询问操作，则询问总复杂度就是  $ O(M\times(T_2+T_1+\frac{N}{T_1}+T_3) ) $ 。

所以我们取 $ T_3 =T_2=T_1=N^{\frac{2}{3}}$ 就可以得到最优复杂度 $O(N^{\frac{5}{3}})$。

稍微优化下常数即可通过。


## 代码

```cpp
#include<stdio.h>
#include<iostream>
#include<math.h>
#include<cstring>
using namespace std;
class block{
	public:
	int l,r,nt,pr,tag,tag2;
	int sz(){
	return r-l+1;
	}
}a[700003];
int cnt=0,head;
int split(int x,int k){
	cnt++;
	a[cnt].r=a[x].r;
	a[cnt].l=a[x].l+k;
	a[x].r=a[cnt].l-1;
	if(a[x].nt!=0) a[a[x].nt].pr=cnt;
	a[cnt].pr=x;
	a[cnt].nt=a[x].nt;
	a[x].nt=cnt;
	a[cnt].tag=a[x].tag;
	a[cnt].tag2=a[x].tag2;
	return cnt;
}
void insert(int r,int val){
	if(r==0) a[++cnt].nt=head,a[head].pr=cnt,head=cnt;
	else{
	int q=head,sum=0;
	while(sum+a[q].sz()<r){
	sum+=a[q].sz();
	q=a[q].nt;
	}
	if(r-sum!=a[q].sz()) q=a[split(q,r-sum)].pr;
	cnt++;
	if(a[q].nt) a[a[q].nt].pr=cnt;
	a[cnt].nt=a[q].nt;
	a[cnt].pr=q;
	a[q].nt=cnt;
	}
	a[cnt].l=1,a[cnt].r=1,a[cnt].tag=val,a[cnt].tag2=0;
}
void change(int r,int val){
	int sum=0,p=head;
	while(sum+a[p].sz()<r) sum+=a[p].sz(),p=a[p].nt;
	if(r-1!=sum) p=split(p,r-sum-1);
	if(a[p].sz()!=1) split(p,1);
	a[p].l=a[p].r=1;
	a[p].tag=val;
	a[p].tag2|=1;
}
int d[80003],c[80003];
char op[230003];
int x[230003],y[230003],z[230003],M,Q,I;
class static_kth_block{
public:
int sum1[907][907],sum2[907][70008],sum3[70008],sum4[907];
int T=0,T2=400;
bool vis[70008];
void change(int val,int op){
	sum3[val]+=op,sum4[val/T2+1]+=op;
}
int N=0;
int static_kth(int l,int r,int k){
	int ll=(l-1)/T+2,rr=(r-1)/T,sum=0,p=1;
	for(int i=l;i<=(ll-1)*T;i++) if(i<=N)sum3[c[i]]++,sum4[(c[i])/T2+1]++;
	for(int i=rr*T+1;i<=r;i++) if(i<=N) sum3[c[i]]++,sum4[(c[i])/T2+1]++;
	while(sum+sum1[rr][p]-sum1[ll-1][p]+sum4[p]<k) {
	sum+=sum1[rr][p]-sum1[ll-1][p]+sum4[p],p++;
	}
	p=(p-1)*T2;
	while(sum+sum2[rr][p]-sum2[ll-1][p]+sum3[p]<k) sum+=sum2[rr][p]-sum2[ll-1][p]+sum3[p],p++;
	for(int i=l;i<=(ll-1)*T;i++) if(i<=N) sum3[c[i]]--,sum4[c[i]/T2+1]--;
	for(int i=rr*T+1;i<=r;i++) if(i<=N) sum3[c[i]]--,sum4[c[i]/T2+1]--;
	return p;
}
int tot=0,val[70003];
void init(int n){
	if(N)
	for(int i=1;i<=(N-1)/T+1;i++){
	for(int j=1;j<=tot;j++)
	sum2[i][val[j]]=0;	
	for(int j=1;j<=(70000/T2+1);j++)
	sum1[i][j]=0;
	}
	N=n;
	T=pow(n,0.667);
	if(T<=1) T=2;
	memset(vis,0,sizeof(vis));
	tot=0;
	for(int i=1;i<=n;i++){
	sum1[(i-1)/T+1][c[i]/T2+1]++;
	sum2[(i-1)/T+1][c[i]]++;	
	if(!vis[c[i]]) vis[c[i]]=1,val[++tot]=c[i];	
	}
	for(int i=1;i<=(n-1)/T+1;i++){
	for(int j=1;j<=tot;j++)
	sum2[i][val[j]]+=sum2[i-1][val[j]];	
	for(int j=1;j<=(70000/T2+1);j++)
	sum1[i][j]+=sum1[i-1][j];	
	}
}
} skb; 
/* 
*/
int n; 
#define kth(a,b,c) skb.static_kth(a,b,c) 
#define ins(x) skb.change(x,1)
#define del(x) skb.change(x,-1)
int top=0,top2=0,de[70003],in[70003];
int ask(int l,int r,int k){	
    int ans=0;
	int sum=0,p=head;
	while(sum+a[p].sz()<l) sum+=a[p].sz(),p=a[p].nt;
    int ll=70009,rr=-1;
    if(a[p].tag==-1) ll=a[p].l+l-sum-1;
	int q=p;
	while(sum+a[q].sz()<r){
	if(a[q].tag==-1) {if(ll==70009) ll=a[q].l;rr=a[q].r;}
	else{
	ins(a[q].tag);
	in[++top2]=a[q].tag;
	if(a[q].tag2==3 && rr!=-1) del(c[++rr]),de[++top]=c[rr];
	}
	sum+=a[q].sz();
	q=a[q].nt; 
	}
	if(a[q].tag==-1) {if(ll==70009) ll=a[q].l;rr=a[q].l+r-sum-1;}
	else{
	ins(a[q].tag);
	in[++top2]=a[q].tag;
	if(a[q].tag2==3 && rr!=-1) del(c[++rr]),de[++top]=c[rr];
	}
	if(ll>rr) {
	ll=1,rr=1;
	del(c[1]);
	de[++top]=c[1];
	}
	ans=kth(ll,rr,k);
	for(int i=1;i<=top;i++) ins(de[i]);
	top=0;
	for(int i=1;i<=top2;i++) del(in[i]);
	top2=0;
	return ans;
}
int tot=0;
void merge(){
	tot=0;
	for(int i=head;i;i=a[i].nt)
	for(int j=a[i].l;j<=a[i].r;j++) d[++tot]=(a[i].tag==-1)?c[j]:a[i].tag;
	swap(c,d);
	skb.init(tot);
	cnt=0;
	head=1;
	a[++cnt]={1,tot,0,0,-1,2};
}
int T,m;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&c[i]);		
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
	op[i]=getchar();
	while(op[i]!='I' && op[i]!='M' && op[i]!='Q') op[i]=getchar();
	if(op[i]=='I'){I++;
	scanf("%d%d",&x[i],&y[i]);
	}
	if(op[i]=='M'){M++;
	scanf("%d%d",&x[i],&y[i]);
	}
	if(op[i]=='Q'){Q++;
	scanf("%d%d%d",&x[i],&y[i],&z[i]);
	}
	}
	skb.init(n);
	cnt=0;
	head=1;	
	a[++cnt]={1,n,0,0,-1,2};	
	int temp=0;
	T=pow(n+m,0.667);
	if(T<=1) T=2; 
	for(int i=1;i<=m;i++){
	if(op[i]=='I'){
	x[i]^=temp;
	y[i]^=temp;
	insert(x[i]-1,y[i]);
	}
	if(op[i]=='M'){
	x[i]^=temp;
	y[i]^=temp;
	change(x[i],y[i]);
	}
	if(op[i]=='Q'){
	x[i]^=temp;
	y[i]^=temp;
	z[i]^=temp;
	temp=ask(x[i],y[i],z[i]);
	printf("%d\n",temp);
	}
	if(cnt>=T)
	merge();
	}
}
```


---

## 作者：konjacq (赞：4)

**[本文同步发表于窝的个人博客](http://39.107.58.77/index.php/archives/luogu-p4278.html).**

~~简单题~~,~~不用卡常~~.

![](http://39.107.58.77/usr/uploads/2020/07/2378295321.png)

## 解题思路

默认$n$询问,值域同阶.

首先看到待插入考虑平衡树和块状链表.理论上平衡树相关的有$\Theta(n\lg^3n)$的解法,但是窝不会而且这种解法常数巨大,所以考虑块状链表.

如果做过[洛谷P4119 \[Ynoi2018\]未来日记](http://39.107.58.77/index.php/archives/luogu-p4119.html)就会容易地想到在分块里面查第$k$大会用值域分块,套上去就行了.

### 修改

没什么好说的,找到所在的块(怎么找后面说),修改之后更新值域分块的前缀和即可.

### 查询

**值  域  分  块**.

### 插入

~~就和块状链表的一样,放进去就行.~~

#### 块状链表

好吧主要的难点就在这里.块状链表大概是长成这个样子的

![](http://39.107.58.77/usr/uploads/2020/07/3584722889.png)

譬如窝要在`E`后面插入一个`J`,那就将同一块里面的`F`往后移一位,然后把`J`放进去就行了,复杂度是$\Theta(块长)$的.像这样

![](http://39.107.58.77/usr/uploads/2020/07/3687332805.png)

如果再接着在`J`后面插入一个`K`和一个`L`,就分别是

![](http://39.107.58.77/usr/uploads/2020/07/2591586136.png)

![](http://39.107.58.77/usr/uploads/2020/07/3486188200.png)

但是这时候发现如果窝们一直在同一块里面插,那块长就会达到$n$,再插入时复杂度就太高了,所以当块长达到$2\sqrt n$时要将这个块拆成两个$\sqrt n$的小块,就像这样

![](http://39.107.58.77/usr/uploads/2020/07/2042476918.png)

当然实际上的小块并不是在中间,而是在最后面,通过维护左右两边的块来连成一个链表,所以叫块状链表.至于具体找某个块,就直接沿着链表依次找过去即可,因为最多新建$\sqrt n$个块,所以复杂度仍然是$\sqrt n$.

具体到这道题,那窝们就要将原来的块(会变成前一个小块)的前缀和信息复制到后面的小块,然后将原来大块的后$\sqrt n$个数放进后面小块,并在前面的块的前缀和信息减去.

```cpp
/*复制前缀和信息*/
for (int j=0;j<q;++j) b[cnt].sbk[j]=s->sbk[j];
for (int j=0;j<70001;++j) b[cnt].snm[j]=s->snm[j];
/*减去放到后面的小块的数的前缀和信息*/
for (int j=0;j<q;++j) {
	b[cnt][j]=s->a[j+q];
	--(s->sbk[p[b[cnt][j]]]);
	--(s->snm[b[cnt][j]]);
}
/*维护剩下相关内容*/
```

## 复杂度分析

查询和修改显然都是$\Theta(\sqrt n)$的(和未来日记类似),插入可以看到复制前缀和信息是单次$\Theta(n)$的,但是最多会建$\sqrt n$个新块,所以总体上仍然是$\Theta(\sqrt n)$.

并且这道题不像Ynoi那么毒瘤,不用调块长,直接取$\lceil\sqrt{70000}\rceil=265$即可,但是要记得数组要开到$265^2=70225$.

## Code

没什么好说的,注意细节.另外建议把块长调到$3$左右跑样例,能过再调回$265$交.

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;

#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048577,stdin),p0==p1)?EOF:*p0++)

const int q=265;

int cnt,p[70505];
char buf[1048577],*p0,*p1;
struct bxt {
	int lps,rps,siz;
	int a[545],sbk[545],snm[70505];
	bxt *lbk,*rbk;
	int& operator [] (const int p) {
		return a[p];
	}
} b[545],fir,lst;

inline int read() {
	int re=0; char ch=gc();
	while (ch<48||ch>57) ch=gc();
	while (ch>47&&ch<58) {
		re=(re<<3)+(re<<1)+(ch^48);
		ch=gc();
	}
	return re;
}

inline int ropt() {
	char ch;
	while (true) switch (ch=gc()) {
		case 81: return 0;
		case 77: return 1;
		case 73: return 2;
		default: break;
	}
}

inline int find_kth(int opl,int opr,int opk) {
	static int fbk[265],fnm[70505];
	int ql=opl,qr=opr,sum=0,ret=-1;
	bxt *pl=NULL,*pr=NULL;
	for (bxt *i=fir.rbk;i;i=i->rbk) {
		if ((!pl)&&i->siz>ql) pl=i;
		else if (!pl) ql-=i->siz;
		if ((!pr)&&i->siz>qr) pr=i;
		else if (!pr) qr-=i->siz;
	}
	if (pl==pr) {
		for (int i=ql;i<=qr;++i) {
			++fbk[p[pl->a[i]]]; ++fnm[pl->a[i]];
		}
		for (int i=0;i<q;++i)
			if ((sum+=fbk[i])>=opk) {
				for (int j=(i+1)*q-1;;--j)
					if ((sum-=fnm[j])<opk) {
						ret=j; break;
					}
				break;
			}
		for (int i=ql;i<=qr;++i) {
			--fbk[p[pl->a[i]]]; --fnm[pl->a[i]];
		}
		return ret;
	}
	for (int i=ql;i<pl->siz;++i) {
		++fbk[p[pl->a[i]]]; ++fnm[pl->a[i]];
	}
	for (int i=0;i<=qr;++i) {
		++fbk[p[pr->a[i]]]; ++fnm[pr->a[i]];
	}
	for (int i=0;i<q;++i)
		if ((sum+=(pr->lbk->sbk[i])-(pl->sbk[i])+fbk[i])>=opk) {
			for (int j=(i+1)*q-1;;--j)
				if ((sum-=(pr->lbk->snm[j])-(pl->snm[j])+fnm[j])<opk) {
					ret=j; break;
				}
			break;
		}
	for (int i=ql;i<pl->siz;++i) {
		--fbk[p[pl->a[i]]]; --fnm[pl->a[i]];
	}
	for (int i=0;i<=qr;++i) {
		--fbk[p[pr->a[i]]]; --fnm[pr->a[i]];
	}
	return ret;
}

inline void update(int opp,int opx) {
	int w=0,opo=0; bxt *r=fir.rbk;
	for (;r->rps<opp;r=r->rbk) w+=r->siz;
	for (int i=0;i<r->siz;++i) if (w+i==opp)
		{opo=r->a[i]; r->a[i]=opx;}
	for (;r!=&lst;r=r->rbk) {
		--(r->sbk[p[opo]]); --(r->snm[opo]);
		++(r->sbk[p[opx]]); ++(r->snm[opx]);
	}
}

inline void insert(int opp,int opx) {
	int w=0; bxt *r=fir.rbk,*s;
	for (;r->rps<opp;r=r->rbk) w+=r->siz;
	if (r==&lst) w-=(r=r->lbk)->siz;
	for (int i=0;i<=r->siz;++i) if (w+i==opp) {
		for (int j=r->siz;j>i;--j)
			r->a[j]=r->a[j-1]; r->a[i]=opx;
	}
	++((s=r)->siz); --(r->lps);
	for (;r!=&lst;r=r->rbk) {
		++(r->lps); ++(r->rps);
		++(r->sbk[p[opx]]); ++(r->snm[opx]);
	}
	if (s->siz==(q<<1)) {
		for (int j=0;j<q;++j) b[cnt].sbk[j]=s->sbk[j];
		for (int j=0;j<70001;++j) b[cnt].snm[j]=s->snm[j];
		for (int j=0;j<q;++j) {
			b[cnt][j]=s->a[j+q];
			--(s->sbk[p[b[cnt][j]]]);
			--(s->snm[b[cnt][j]]);
		}
		s->siz=b[cnt].siz=q;
		b[cnt].rps=(s->rps=(b[cnt].lps=s->lps+q)-1)+q;
		b[cnt].lbk=s; b[cnt].rbk=s->rbk;
		s->rbk->lbk=&b[cnt]; s->rbk=&b[cnt]; ++cnt;
	}
}

int main() {
	int n=read(),m,las=0,x,y,z;
	memset(fir.sbk,0x00,sizeof(fir.sbk));
	memset(fir.snm,0x00,sizeof(fir.snm));
	for (int i=0;i<70505;++i) p[i]=i/q;
	for (int i=0;i<n;++i) {
		b[p[i]][i%q]=read();
		++b[p[i]].siz;
	}
	for (int i=0;i<=p[n-1];++i) {
		b[i].lps=(i?b[i-1].rps+1:0);
		b[i].rps=b[i].lps+b[i].siz-1;
		(b[i].lbk=i?&b[i-1]:&fir)->rbk=&b[i];
		for (int j=0;j<q;++j)
			b[i].sbk[j]+=b[i].lbk->sbk[j];
		for (int j=0;j<70001;++j)
			b[i].snm[j]+=b[i].lbk->snm[j];
		for (int j=0;j<b[i].siz;++j) {
			++b[i].sbk[p[b[i][j]]];
			++b[i].snm[b[i][j]];
		}
	}
	b[p[n-1]].rbk=&lst;
	lst.lbk=&b[p[n-1]];
	lst.rps=0x3fffffff;
	cnt=p[n-1]+1; m=read();
	while (m--) {
		z=-1;
		switch (ropt()) {
			case 0:
				x=(read()^las)-1; y=(read()^las)-1;
				z=read()^las;
				printf("%d\n",las=find_kth(x,y,z));
				break;
			case 1:
				x=(read()^las)-1; y=read()^las;
				update(x,y); break;
			case 2:
				x=(read()^las)-1; y=read()^las;
				insert(x,y); break;
			default: break;
		}
	}
	return 0;
}
```

---

## 作者：MatKave (赞：1)

因为 [最初分块](https://www.luogu.com.cn/problem/P4119) 太难写了，所以我决定来这题写一下最初分块的那个做法

不过写个题解就复读别人说过的东西显然不好，所以我决定总结一下本题分块求 $k$ 小的三种做法

注意：我们默认值域和 $n,m$ 同阶

- $n \sqrt n \log n$ 的解法

  对每个块进行排序，我们设 $S$ 为初始块长，$len$ 为某个块的实际块长
  
  - 修改操作相当于是删除一个元素，插入一个元素，可以用 $O(len)$ 的复杂度解决
  
  - 插入操作也是插入一个元素，$O(len)$
  
  - 求 $k$ 小需要在每个块二分，求出一个 $\le x$ 有多少个数，再二分 $x$，复杂度是 $O(\frac{n}{len} \times \log ^ 2n)$
  
  但是一直插入会导致某个块变得很大，所以当 $len \ge 2 \times S$ 时，我们将这个块拆成两个，这样就保证了 $len$ 依然是 $S$ 的级别
  
  重构一次的复杂度是 $O(len)$，至多插入 $n$ 个元素，会引起 $\frac{n}{S}$ 次重构，所以重构总复杂度是 $O(n)$ 的
  
  可以解得：$S = \sqrt n \log n$ 时复杂度最优，是 $O(n \sqrt n \log n)$ 的
  
- $n \sqrt {n \log n}$ 的解法

  刚才那个解法二分了两次，显然是不好的，我们可以同时在 $\frac{n}{S}$ 个块上进行二分
  
  对于每个块建立一颗权值线段树，以及块内排序
  
  - 修改操作直接在线段树上进行 $\log n$，块内排序 $O(len)$ 修改
  
  - 插入操作在线段树上进行 $\log n$，块内排序 $O(len)$ 修改
  
  - 求第 $k$ 小在线段树上二分，边角块使用一个指针在块内排序数组上移动，就可以处理边角的影响，最多要移动 $len$ 次，每次在 $\frac{n}{len}$ 颗线段树上同时向 左 / 右 跳，$\frac{n}{len} \log n + len$
  
  还是要重构，重构一次的复杂度是 $O(len \log n)$ ，总复杂度 $O(n \log n)$ 
  
  可以解得：$S = \sqrt {n \log n}$ 时复杂度最优，是 $O(n \sqrt {n \log n})$ 的
  
- $n \sqrt n$ 的解法

  二分和分块两个东西是不搭的，所以我们要对权值进行分块
  
  块长都为 $\sqrt n$ 
  
  设 $v_{i,j}$ 为前 $i$ 个块，落在第 $j$ 个值域块的数的个数，$s_{i,j}$ 为前 $i$ 个块，值为 $j$ 个数的个数，这个可以 $n \sqrt n$ 预处理
  
  考虑边角的影响，再引入一个 $dv_i$ 表示边角落在值域 $i$ 的数量，$ds_i$ 为边角值为 $i$ 的数量，这两个表可以 $\sqrt n$ 求出，然后 $\sqrt n$ 清空
  
  知道了这些值，这样我们减一下就可以 $O(1)$ 知道区间 $[l,r]$ 有多少个数在值域块 $x$ 内，有多少个数值为 $x$ 
  
  从小到大用 $\sqrt n$ 的时间枚举出答案在哪个值域块，然后用 $\sqrt n$ 的时间求出答案是什么
  
  - 修改
  
     直接对 $v,s$ 进行修改，一共要修改 $\sqrt n$ 个值
    
     原序列 $O(1)$ 修改
    
  - 插入
  
     对 $v,s$ 进行修改，一共要修改 $\sqrt n$ 个值
    
     原序列 $O(\sqrt n)$ 修改
    
  重构一次的复杂度是 $O(n)$ ，总复杂度 $O(n \sqrt n)$
 
$n \sqrt n$ 的代码： 
 
```cpp

#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n,m;
int a[35005];

#define S 360
#define from(x) ((x - 1) / S + 1)
#define L(x) (x * S - S + 1)
#define R(x) (x * S)
int len;
struct BLock{
    int v1[70005],v2[S + 3],v[2 * S + 3],l,r;
}s[70005 / S + 3];
int dv1[70005],dv2[S + 3];

int query(int l,int r,int k){
    int x = 0,y = 0;
    int i,j,tmp;
    for(i = 1;i <= len;++i){
        if(s[i].r >= l && !x) x = i;
        if(s[i].r >= r && !y) y = i;
    }
    if(x ^ y){
        for(i = l - s[x].l;i < s[x].r - s[x].l + 1;++i){
            dv1[s[x].v[i]]++;
            dv2[from(s[x].v[i])]++;
        }
        for(i = 0;i <= r - s[y].l;++i){
            dv1[s[y].v[i]]++;
            dv2[from(s[y].v[i])]++;
        }

    }else{
        for(i = l - s[x].l;i <= r - s[x].l;++i){
            dv1[s[x].v[i]]++;
            dv2[from(s[x].v[i])]++;
        }
    }

    for(i = 1;i <= from(70001);++i){
        tmp = dv2[i];
        if(x ^ y) tmp += s[y - 1].v2[i] - s[x].v2[i]; 
        if(k > tmp) k -= tmp;
        else break;
    }
    for(j = L(i);j <= R(i);++j){
        tmp = dv1[j];
        if(x ^ y) tmp += s[y - 1].v1[j] - s[x].v1[j];
        if(k > tmp) k -= tmp;
        else break;
    }
    if(x ^ y){
        for(i = l - s[x].l;i < s[x].r - s[x].l + 1;++i){
            dv1[s[x].v[i]]--;
            dv2[from(s[x].v[i])]--;
        }
        for(i = 0;i <= r - s[y].l;++i){
            dv1[s[y].v[i]]--;
            dv2[from(s[y].v[i])]--;
        }
    }else{
        for(i = l - s[x].l;i <= r - s[x].l;++i){
            dv1[s[x].v[i]]--;
            dv2[from(s[x].v[i])]--;
        }
    }

    return j;
}

void modify(int x,int val){
    int id,tmp;
    for(int i = 1;i <= len;++i){
        if(s[i].r >= x){
            id = i;
            break;
        }
    }
    tmp = s[id].v[x - s[id].l];
    for(int i = id;i <= len;++i){
        s[i].v1[tmp]--;
        s[i].v1[val]++;
        s[i].v2[from(tmp)]--;
        s[i].v2[from(val)]++;
    }
    s[id].v[x - s[id].l] = val;
}

void split(int x){
    for(int i = len;i >= x + 1;--i){
        swap(s[i],s[i + 1]);
    }
    len++;
    s[x].r -= S;
    s[x + 1].l = s[x].r + 1;
    s[x + 1].r = s[x].r + S;
    for(int i = S;i < 2 * S;++i){
        s[x + 1].v[i - S] = s[x].v[i];
        s[x].v[i] = 0;
    }
    for(int i = 1;i <= 70001;++i){
        s[x + 1].v1[i] = s[x].v1[i];
    }
    for(int i = 1;i <= from(70001);++i){
        s[x + 1].v2[i] = s[x].v2[i]; 
    }
    for(int i = 0;i < S;++i){
        s[x].v1[s[x + 1].v[i]]--;
        s[x].v2[from(s[x + 1].v[i])]--;
    }
}

void insert(int x,int val){
    int id,tag = 0;
    for(int i = 1;i <= len;++i){
        s[i].l += tag;s[i].r += tag;
        if((s[i].r >= x || i == len) && !tag){
            id = i;
            s[i].r++;
            tag = 1;
        }
    }
    for(int i = id;i <= len;++i){
        s[i].v1[val]++;
        s[i].v2[from(val)]++;
    }
    for(int i = s[id].r - s[id].l;i >= x - s[id].l + 1;--i){
        s[id].v[i] = s[id].v[i - 1];
    }
    s[id].v[x - s[id].l] = val;
    if(s[id].r - s[id].l + 1 == 2 * S) split(id);
}

namespace io {
    const int __SIZE = (1 << 20) + 1;
    char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
    #define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
    inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
    inline void gc (char &x) { x = Gc(); }
    inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
    inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
    inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
        for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
    template <class I> inline bool gi (I &x) { _eof = 0;
        for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
        for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
    template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
        while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
    struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

int main(){
    gi(n);
    for(int i = 1;i <= n;++i){
        gi(a[i]);a[i]++;int x = from(i);
        s[x].v1[a[i]]++;
        s[x].v2[from(a[i])]++;
        s[x].v[i - L(x)] = a[i];
    }
    for(int i = 1;i <= from(n);++i){
        s[i].l = L(i);s[i].r = min(R(i),n);
        for(int j = 1;j <= 70001;++j){
            s[i].v1[j] += s[i - 1].v1[j];
        }
        for(int j = 1;j <= from(70001);++j){
            s[i].v2[j] += s[i - 1].v2[j];
        }
    }
    len = from(n);
    gi(m);
    char opt;
    int l,r,k,x,val,lastans = 0;
    for(int i = 1;i <= m;++i){
        do{
            gc(opt);
        }while(opt != 'Q' && opt != 'M' && opt != 'I');
        if(opt == 'Q'){
            gi(l);gi(r);gi(k);
            l ^= lastans;r ^= lastans;k ^= lastans;
            lastans = query(l,r,k) - 1;
            print(lastans);pc('\n');
        }else if(opt == 'M'){
            gi(x);gi(val);
            x ^= lastans;val ^= lastans;
            val++;
            modify(x,val);
        }else{
            gi(x);gi(val);
            x ^= lastans;val ^= lastans;
            val++;
            insert(x,val);
        }
    }
    return 0;
}
```

因为人傻常数大，所以开了 O2 也不一定过，需要刷脸

---

## 作者：ExplodingKonjac (赞：0)

### [【原题链接】](https://www.luogu.com.cn/problem/P4278)

## 大力块状链表套权值线段树

这题整整搞了两天，太毒瘤了。~~（真心感觉伏特太难了）~~

线段树套平衡树和平衡树套线段树的做法都有想过，但是不会写 qwq。最后瞄了一眼标签，决定使用块状链表套权值线段树。

思路相当的暴力：块状链表搞插入操作，每个块开一个权值线段树，查询时拎出完整块的跟，对于不完整的块加到一个临时的树里面。查询时一起查。

~~（什么？值域分块？？不会！）~~

当然这样的做法是 $O(n\sqrt{n}\log n)$ 的，在数据 $7e4$ 的范围下相当危，但是毕竟是可以卡常卡过去的。下面说几种优化：

### 手动设置块长

因为我们的临时树是需要每次清空的，所以零散块的影响会更大一些。我们考虑缩短块长。

经过实验，块长 $65$ 最优。~~别问为什么，问就是和另一个同学一共长达 $3$ 页的提交。~~

### 找对应块时分方向

由于我们的块是一个链表，无法 $O(1)$ 定位某一位置 $p$ 所在的块，只能暴力找。

考虑改成双向链表，当 $p\le n/2$ 时从左往右找，当 $p>n/2$ 时从右往左找。

### 使用快读快写

你可以将快读快写升级为超级快读快写，也就是给快读快写分别写一个 `char` 类型数组 buf 作为缓存区。输出时先放到缓存里，如果缓存满了就用玄学的 `fwrite` 全部输出，然后清空缓存。输入的话可以先用 `fread` 将缓存填满，然后一个个从 buf 里拿，buf 空了就再填一次。

当然别忘了在程序结束时清空输出的缓存。

~~[【广告】我写的快读快写类（在这题快读开启缓存会莫名其妙 TLE）](https://www.luogu.com.cn/paste/rmfl4cmy)~~

### 你那么聪明，肯定有其它的优化方法

用完上面的方法后，我已经卡过时限了，所以就不介绍其它方法了。

## 代码实现

由于以前没写过块状链表，写法可能与正常写法不太一样，见谅。

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
省略80多行的快读快写模板
也就是代码里用的qin、qout
*/

int n,m,size=65;
struct TreeNode
{
	int val;
	int lc,rc;
}t[20000005];
int cnt,rubbish[20000005],top;
inline int newNode()
	{ return top?rubbish[top--]:++cnt; }
inline void deleteNode(int &i)
	{ rubbish[++top]=i,t[i].lc=t[i].rc=t[i].val=0,i=0; }
void destroy(int &i)
	{ if(i)destroy(t[i].lc),destroy(t[i].rc),deleteNode(i); }
void add(int p,int &i,int l=0,int r=70000)
{
	if(!i)	i=newNode();
	t[i].val++;
	if(l!=r)
	{
		int mid=(l+r)>>1;
		if(mid>=p)	add(p,t[i].lc,l,mid);
		else	add(p,t[i].rc,mid+1,r);
	}
}
void sub(int p,int &i,int l=0,int r=70000)
{
	t[i].val--;
	if(l!=r)
	{
		int mid=(l+r)>>1;
		if(mid>=p)	sub(p,t[i].lc,l,mid);
		else	sub(p,t[i].rc,mid+1,r);
	}
	if(!t[i].val)	deleteNode(i);
}
struct Block
{
	int *b,cnt,rt;
	Block *nxt,*pre;
	Block(Block *p): cnt(0),rt(0),pre(p)
		{ b=new int[size+5],nxt=nullptr; }
	inline bool full()
		{ return cnt==size; }
}*head,*tail;
void build(Block *&i,int pos=1,Block *last=nullptr)
{
	i=new Block(last);
	int x;
	while(!i->full() && pos<=n)
		qin>>x,i->b[++i->cnt]=x,add(x,i->rt),pos++;
	if(pos<=n)	build(i->nxt,pos,i);
	else	tail=i;
}
Block *find(int &x)
{
	Block *i;
	if(x<=(n>>1))
		for(i=head;i->cnt<x;x-=i->cnt,i=i->nxt);
	else
	{
		x=n-x+1;
		for(i=tail;i->cnt<x;x-=i->cnt,i=i->pre);
		x=i->cnt-x+1;
	}
	return i;
}
int ans,tot,rt[200005];
int main()
{
	// freopen("P4278.in","r",stdin);
	// freopen("P4278.out","w",stdout);
	qin>>n,build(head);
	qin>>m;
	while(m--)
	{
		char opt;
		while((opt=getchar())<33);
		int x,y,z;
		qin>>x>>y,x^=ans,y^=ans;
		if(opt=='Q')
		{
			Block *a=find(x),*b=find(y);
			qin>>z,z^=ans,tot=rt[0]=0;
			if(a==b)
				for(int i=x;i<=y;i++)	add(a->b[i],rt[0]);
			else
			{
				for(int i=x;i<=a->cnt;i++)	add(a->b[i],rt[0]);
				for(int i=1;i<=y;i++)	add(b->b[i],rt[0]);
				for(;a->nxt!=b;a=a->nxt,rt[++tot]=a->rt);
			}
			int oldrt=rt[0],l=0,r=70000;
			while(l<r)
			{
				int sz=0,mid=(l+r)>>1;
				for(int i=0;i<=tot;i++)	sz+=t[t[rt[i]].lc].val;
				if(sz>=z)
				{
					r=mid;
					for(int i=0;i<=tot;i++)	rt[i]=t[rt[i]].lc;
				}
				else
				{
					l=mid+1,z-=sz;
					for(int i=0;i<=tot;i++)	rt[i]=t[rt[i]].rc;
				}
			}
			qout.writeln(ans=l),destroy(oldrt);
		}
		else if(opt=='M')
		{
			Block *i=find(x);
			sub(i->b[x],i->rt),add(i->b[x]=y,i->rt);
		}
		else if(opt=='I')
		{
			Block *i,*j;
			if(x==n+1)
			{
				i=find(--x),x++;
				if(i->full())
					i->nxt=new Block(i),i=i->nxt,tail=i,x=1;
			}
			else	i=find(x);
			if(i->full())
			{
				j=i->nxt;
				if(!j || j->full())
				{
					i->nxt=new Block(i),i->nxt->nxt=j;
					if(j)	j->pre=i->nxt;
					else	tail=i->nxt;
					j=i->nxt;
				}
				for(int k=++j->cnt;k>1;k--)	j->b[k]=j->b[k-1];
				j->b[1]=i->b[size];
				add(j->b[1],j->rt),sub(i->b[size],i->rt);
				for(int k=size;k>x;k--)	i->b[k]=i->b[k-1];
			}
			else
				for(int k=++i->cnt;k>x;k--)	i->b[k]=i->b[k-1];
			i->b[x]=y,add(y,i->rt),n++;
		}
	}
	return qout.flush(),0;
}
```


---


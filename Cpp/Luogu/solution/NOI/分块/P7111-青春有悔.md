# 青春有悔

## 题目背景

岁月奔波，已值青年的 Gnar 踏上了梦想与未来的征途。

他终失败而归。

## 题目描述

那是一次持续 $n$ 天的角逐，每天 Gnar 必须参加一场考试，受诸多因素影响第 $i$ 天 Gnar 理论得分上限为 $a_i$，实际他当天考试的得分为 $[0, a_i]$ 中**等概率随机的整数**（因时间不够、简单题丢分等）。$n$ 天后，官方将结算总分，并划定分数线，总分达到**分数线及以上**者方可入围。

无数个“凭什么”横生于脑海，似乎每天都有发挥的缺陷。“缺陷……要是能改写过往的遗憾……”

深夜，Gnar 开始了 $q$ 次幻想。每次幻想中 Gnar 重返了角逐的第 $p$ 天，以不同的状态参加考试，使当天得分变为 $[0,x]$ 中**等概率随机的整数**，其余 $n-1$ 天依旧在 $[0,a_i]$ 中随机。然而一些微妙的效应导致分数线变为了 $y$，入围的机会真能如所料高于现实吗？

请你求出每次幻想中的入围概率对 $998244353$ 取模的结果。容易证明答案可以表示为最简分数 $\frac{Q}{P}$，你输出的 $R$ 即满足 $R \cdot P \equiv Q \pmod{998244353}$ 的最小非负整数。

毕竟幻想，重返第 $p$ 天新的得分上限 $x$ 并不会改变现实 $a_p$ 的值，唯一萌生的只有对青春的悔恨。

## 说明/提示

**【样例解释 #1】**

第一次幻想，Gnar 重返了第一天，两天分别的得分情况在 $\{0,0\}$，$\{0,1\}$，$\{1,0\}$，$\{1,1\}$，$\{2,0\}$，$\{2,1\}$ 内等概率产生，其中只有后三种能够入围，故答案为 $\frac{1}{2}$。

第二次幻想，Gnar 重返了第二天，状态反而变差，即使拿满两天的得分上限也没机会入围。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (10 points)：$n,q,a_i,x,y \le 100$。
- Subtask #2 (10 points)：$n,q,a_i,x,y \le 500$。
- Subtask #3 (10 points)：$a_i,x \le 1$。
- Subtask #4 (20 points)：$\sum a_i \le 10^5$。
- Subtask #5 (25 points)：$q = 1$。
- Subtask #6 (25 points)：无特殊限制。

对于所有的数据，保证 $1 \le n,q \le 10^5$，$1 \le p \le n$，$0 \le a_i,x,y \le 10^5$。

## 样例 #1

### 输入

```
2 2
1 1
1 2 2
2 0 2```

### 输出

```
499122177
0```

## 样例 #2

### 输入

```
5 3
12 16 3 15 9
1 13 25
3 10 30
4 11 17```

### 输出

```
743774619
107297923
234909256```

# 题解

## 作者：Elegia (赞：14)

本文给出一个 $\tilde O(n^{4/3})$ 的算法（下文均认为 $n,q$ 同阶，且用 $\tilde O$ 符号避免 $\log$ 因子的讨论），虽然复杂度较优，但其所带的 $\log $ 因子以及常数因子使其在目前的数据范围内并没有太大的优势。（[这里](https://www.luogu.com.cn/record/43107202)是一个实现）

-------------

让我们先来回顾一下前面不太关键的部分，设 $f(x) = \sum_{n\ge 0} a_n x^n$ 为总分数为 $n$ 的方案数的生成函数，那么考虑计数总分小于 $y$ 的情况，这无非就是

$$
[x^{y-1}] \frac 1{1-x} f(x)
$$

根据诸个比赛日相互之间的独立性，$f(x)$ 可确定为一个简单的乘积式

$$
f(x) = \prod_{i=1}^n \frac{1-x^{a_i+1}}{1-x}
$$

即 $g(x) = \frac 1{1-x} f(x)$，那么考虑整理各 $(1-x^k)$ 指数上的幂次，可得到整数数列 $c_k$，满足

$$
\begin{aligned}
g(x) &= \prod_{k\ge 1} (1-x^k)^{c_k}\\
 &= \exp\left(\sum_{k\ge 1} c_k \ln (1-x^k)\right)\\
\end{aligned}
$$

注意到这是可以 $\Theta(n\log n)$ 计算的。

而对于每次询问，设其将一个原本在 $[0, s]$ 内的分数改为了 $[0, t]$，那么我们询问的实则就是

$$
\begin{aligned}
& \quad [x^{y-1}] \frac{1-x^{t+1}}{1-x^{s+1}} g(x)\\
&= \left([x^{y-1}] - [x^{y-t-2}]\right) \frac 1{1-x^{s+1}} g(x)
\end{aligned}
$$

因此，我们将问题转化为了如下情况：多次给出 $m, k$，询问 $[x^m] \frac 1{1-x^k} g(x)$，也即

$$
\sum_{j\ge 0} g_{m-jk}
$$

--------------

接下来给出解决转化后问题的关键。我们首先考虑一个稍微弱一点的问题，即给出 $0\le r < k$，求

$$
\sum_{j \bmod k = r}g_j
$$

这个问题不难写做生成函数的形式：

$$
[x^r] g(x) \bmod (x^k-1)
$$

因此我们不妨令 $B$ 为阈值，预处理对于所有的 $k\le B$，其 $g(x) \bmod (x^k-1)$，这通过经典的分治取模可得一个复杂度为 $\tilde O(n + B^2)$ 的算法。

因此复杂度为 $\tilde O(n + B^2 + \frac {n^2}B)$，不难得到当 $B = \tilde O(n^{2/3})$ 的时候渐进复杂度的指数取到最优，为 $\tilde O(n^{4/3})$。

而对于原问题呢？实际上这可以通过加一层分治，每层都按照本层的 $B=\tilde O(n^{2/3})$ 进行预处理，那么预处理的复杂度为 $T(n) = 2T(n/2) + \tilde O(n^{4/3})$，这还是 $T(n) = \tilde O(n^{4/3})$ 的。而一次询问是 $Q(n) = Q(n/2) + \tilde O(n^{1/3})$ 的，因此询问还是 $\tilde O(n^{1/3})$ 的。

综上，我们就得到了一个 $\tilde O(n^{4/3})$ 的做法。



---

## 作者：wlzhouzhuan (赞：10)

## T6 青春有悔

设 $F(x)=\sum\limits_{i}a_ix^i$ 表示答案的**前缀和**，则显然有 
$$F(x)=\frac{1}{1-x}\prod\limits_{i=1}^{n}\frac
{1-x^{a_i+1}}{1-x}=\left(\frac{1}{1-x}\right)^{n+1}\prod\limits_{i=1}^{n}(1-x^{a_i+1})$$

前半部分由二项式定理得：
$$\left(\frac{1}{1-x}\right)^{n+1}=\sum\limits_{i=0}^{\infty}\binom{n+i}{i}x^i$$

后半部分取个 $ln$ ，由泰勒展开 $ln(1+x)=\sum\limits_{i=1}^{\infty}(-1)^{i-1}\frac{x^i}{i}$ 得：

$$\sum\limits_{i=1}^{n}ln(1-x^{a_i+1})=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{\infty}-\frac{x^{(a_i+1)j}}{j}$$

用桶记录 $cnt[i]$ 表示 $a_j=i$ 的个数，可 $O(nlnn)$ 复杂度求出系数，再 $exp$ 回去即可。

现在得到了 $F(x)$ ，反面考虑，求的即 $[x^y]\frac{1-x^{b+1}}{1-x^{a_p+1}}F(x)$ 。

将其拆开：

$$[x^y]\frac{1}{1-x^{a_p+1}}F(x)-[x^{y-b-1}]\frac{1}{1-x^{a_p+1}}F(x)$$

发现需要计算 $[x^y]\frac{1}{1-x^a}F(x)$ ，考虑根号分治：

- 若 $a>\sqrt{n}$ ，则有系数的位置只有 $<\sqrt{n}$ 个，暴力计算；

- 若 $a\le \sqrt{n}$ ，预处理 $g[a][y]$ 表示答案。

时间复杂度 $O(n\sqrt{n})$ 。

```cpp
// Author: wlzhouzhuan
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define poly vector<int>
#define SZ(a) int(a.size())
#define pb push_back
#define fir first
#define sec second
#define rep(i, l, r) for (int i = l; i <= r; i++)
#define per(i, l, r) for (int i = l; i >= r; i--)
#define mset(s, t) memset(s, t, sizeof(s))
#define mcpy(s, t) memcpy(s, t, sizeof(t))
template<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }
template<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }
int read() {
  int x = 0, f = 0; char ch = getchar();
  while (!isdigit(ch)) f |= ch == '-', ch = getchar();
  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();
  return f ? -x : x;
}
template<typename T> void print(T x) {
  if (x < 0) putchar('-'), x = -x;
  if (x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
template<typename T> void print(T x, char let) {
  print(x), putchar(let);
}

const int N = 200005;
const int mod = 998244353;
const int G = 3;
const int Gi = 332748118;

int g[129][100001];
int cnt[N], aa[N];
int n, q, tot;

int qpow(int a, int b = mod - 2) {
  int res = 1;
  while (b > 0) {
    if (b & 1) res = 1ll * res * a % mod;
    a = 1ll * a * a % mod;
    b >>= 1;
  }
  return res;
}
int inv[N], fac[N], ifac[N];
void init(int n) {
  inv[1] = 1;
  rep(i, 2, n) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
  fac[0] = ifac[0] = 1;
  rep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % mod;
  ifac[n] = qpow(fac[n]);
  per(i, n - 1, 1) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
}
int C(int n, int m) {
  return 1ll * fac[n] * ifac[n - m] % mod * ifac[m] % mod;
}

namespace Poly {
vector<int> Rev, W;
int lim, L;
void getR(int len) {
  lim = 1, L = 0;
  while (lim <= len) lim <<= 1, L++;
  Rev.resize(lim), W.resize(lim), W[0] = 1;
  for (int i = 0; i < lim; i++) Rev[i] = (Rev[i >> 1] >> 1) | ((i & 1) << L - 1);
}
void wf(poly &a) {
  int n = a.size();
  for (int i = 0; i < n - 1; i++) a[i] = 1ll * (i + 1) * a[i + 1] % mod;
  a[n - 1] = 0;
}
void jf(poly &a) {
  int n = a.size() - 1;
  for (int i = n - 1; i >= 1; i--) a[i] = 1ll * a[i - 1] * qpow(i) % mod;
  a[0] = 0;
}
void NTT(poly &a, int opt) {
  for (int i = 0; i < lim; i++) if (i < Rev[i]) swap(a[i], a[Rev[i]]);
  for (int mid = 1; mid < lim; mid <<= 1) {
    int Wn = qpow(opt == 1 ? G : Gi, (mod - 1) / (mid << 1));
    for (int k = 1; k < mid; k++) W[k] = 1ll * W[k - 1] * Wn % mod;
    for (int j = 0; j < lim; j += mid << 1) {
      for (int k = 0; k < mid; k++) {
        int x = a[j + k], y = 1ll * W[k] * a[j + k + mid] % mod;
        a[j + k] = (x + y) % mod;
        a[j + k + mid] = (x - y + mod) % mod;
      }
    }
  }
  if (opt == -1) {
    int linv = qpow(lim);
    for (int i = 0; i < lim; i++) a[i] = 1ll * a[i] * linv % mod;
  }
}
poly operator * (poly a, poly b) {
  int len = a.size() + b.size() - 1;
  getR(len);
  a.resize(lim), b.resize(lim);
  NTT(a, 1), NTT(b, 1);
  for (int i = 0; i < lim; i++) a[i] = 1ll * a[i] * b[i] % mod;
  NTT(a, -1);
  a.resize(len);
  return a;
}
poly Inv(poly a) {
  if (SZ(a) == 1) return {qpow(a[0])};
  int len = a.size();
  poly ta = a; ta.resize((len + 1) / 2);
  poly tb = Inv(ta);
  getR(2 * len), a.resize(lim), tb.resize(lim);
  NTT(a, 1), NTT(tb, 1);
  for (int i = 0; i < lim; i++) tb[i] = 1ll * tb[i] * (mod + 2 - 1ll * a[i] * tb[i] % mod) % mod;
  NTT(tb, -1);
  tb.resize(len);
  return tb;
}
poly Ln(poly a) {
  poly ta = a; wf(ta);
  int len = a.size();
  a = ta * Inv(a), jf(a);
  a.resize(len);
  return a;
}
poly Exp(poly a) {
  if (SZ(a) == 1) return {1};
  int len = a.size();
  poly ta = a; ta.resize((len + 1) / 2);
  poly tb = Exp(ta); tb.resize(len);
  poly Lnb = Ln(tb);
  for (int i = 0; i < len; i++) Lnb[i] = (a[i] - Lnb[i] + mod) % mod;
  Lnb[0] = (Lnb[0] + 1) % mod;
  tb = tb * Lnb;
  tb.resize(len);
  return tb;
}
}
using namespace Poly;
poly a, b, F;

int calc(int A, int y) {
  if (y < 0) return 0;
  if (A <= 128) return g[A][y];
  else {
    int res = 0;
    for (int i = 0; i <= y; i += A) {
      res += F[y - i];
      if (res >= mod) res -= mod;
    }
    return res;
  }
}
int main() {
  init(2e5);
  n = read(), q = read(), tot = 1;
  for (int i = 1; i <= n; i++) {
    aa[i] = read();
    tot = 1ll * tot * (aa[i] + 1) % mod;
    cnt[aa[i]]++;
  }
  
  a.resize(100001), b.resize(100001);
  for (int i = 0; i <= 100000; i++) a[i] = C(n + i, i);
  for (int i = 1; i <= 100000; i++) if (cnt[i - 1]) {
    int coef = mod - cnt[i - 1];
    for (int j = 1; i * j <= 100000; j++) {
      b[i * j] = (b[i * j] + 1ll * coef * inv[j]) % mod;
    }
  }
  b = Exp(b);
  F = a * b; F.resize(100001);
  
  //for (int i = 0; i <= 5; i++) printf("%d ", F[i]);
  //puts("");
  
  for (int A = 1; A <= 128; A++) {
    for (int i = 0; i <= 100000; i++) {
      g[A][i] = ((i >= A ? g[A][i - A] : 0) + F[i]) % mod;
    }
  }
  while (q--) {
    int p = read(), b = read(), y = read() - 1;
    int num = (calc(aa[p] + 1, y) - calc(aa[p] + 1, y - b - 1) + mod) % mod; 
    int new_tot = 1ll * tot * inv[aa[p] + 1] % mod * (b + 1) % mod;
    //printf("%d %d %d\n", calc(aa[p] + 1, y), calc(aa[p] + 1, y - b - 1), new_tot);
    print((mod + 1 - 1ll * num * qpow(new_tot) % mod) % mod, '\n');
  }
  return 0;
}
```

---

## 作者：AsunderSquall (赞：9)

## 题意

有一个序列 $a_i$，多组询问，求出：  
如果把 $a_j$ 改成 $b$，那么对于所有 $a_i$，在 $[0,a_i]$ 中等概率随机选择一个数求和，该值 $\ge y$ 的概率。

--------

## 题解

默认 $n$ 与值域、询问次数同阶。  

题意可以简单转化为求更改过后的 $a_i$，选择 $n$ 个数使得和 $\le y$ 的方案数。  

考虑令 $[x^t] F(x)$ 表示**更改前**选择数的和 $\le t$ 的方案数，有  
$$F(x)= \dfrac{1}{1-x} \prod \sum_{i=0}^{a_i} x^i=\left ( \dfrac 1 {1-x}\right)^{n+1} \prod (1-x^{a_i+1})$$  

考虑后半部分可以用付公主的背包那个套路 $n \log n$ 解决。  

前半部分可以归纳证明得到 $[x^t] \dfrac{1}{(1-x)^{n+1}}= {n+t \choose t}$。  

那么我们就可以在 $n \log n$ 的时间内求出 $F(x)$。

----------

考虑询问，就是求 $[x^y] \dfrac{1-x^{b+1}}{1-x^{a_j+1}}F(x)$。  
即 $[x^y]\dfrac{1}{1-x^{a_j+1}}F(x)- [x^{y-b-1}]\dfrac{1}{1-x^{a_j+1}}F(x)$。  

那么目标就是求 $[x^y]\dfrac{1}{1-x^t}F(x)$。

----------

设置一个阈值 $B$，对于小于 $B$ 的数 $t$，用**递推**（不要用卷积）预处理出 $A_t(x)=\dfrac{1}{1-x^t} F(x)$，复杂度 $nB$。  

对于大于 $B$ 的数，发现有值的位置只有 $\dfrac n B$ 个，暴力计算即可，复杂度 $\dfrac{n^2}{B}$。

取 $B= \sqrt n$ 可以得到复杂度 $O(n \sqrt n)$。

## 代码  

除了板子不到 1k，其实还是很好写的。

```cpp
int a[N],cnt[N];
int F[N],G[N];
int n,m,q,tot;
int A[205][100005];
int query(int y,int t)
{
    if (y<0) return 0;
    if (t<=200) return A[t][y];
    int ret=0;
    for (int i=0;i<=y;i+=t) add(ret,F[y-i]);
    return ret;
}
int Query(int j,int b,int y)
{
    int tmp=query(y,a[j])-query(y-b,a[j]);
    int T=tot*inv[a[j]]%mod*b%mod;
    return (T-tmp)*ksm(T)%mod;
}
signed main()
{
    rd(n);rd(q);m=1e5+2;Init(N-1);tot=1;
    for (int i=1;i<=n;i++) rd(a[i]),a[i]++,cnt[a[i]]++,tot=tot*a[i]%mod;
    for (int i=1;i<m;i++) if (cnt[i]) for (int j=1;i*j<m;j++) add(G[i*j],inv[j]*(mod-cnt[i]));
    for (int i=0;i<m;i++) F[i]=C(n+i,i);exp(G,m);times(F,G,m,m);
    for (int k=1;k<=200;k++) for (int i=0;i<m;i++) A[k][i]=((i>=k?A[k][i-k]:0)+F[i])%mod;
    while (q--)
    {
        int j,b,y;rd(j);rd(b);rd(y);b++;y--;
        cout<<(Query(j,b,y)+mod)%mod<<"\n";
    }
}
```

## 后记  

今天是 NOIP2021 前一天，高二了，最后一搏了。

曾经也有过很多悔恨吧，该认真学习的时候不该摸鱼，考场上不该犯这样那样的错误之类的……

也有想过退役之后文化课会怎样怎样苦痛。

真的退役临近时，其实并没有太多感觉，基本上只有释然。

至少，我希望我能在退役之时说出“我从未后悔踏上 OI 这条道路”这样帅气的话。

当然也不可能不留遗憾吧，或许未来的我也会躺在床上做梦，“我本可以……”，或许这就是青春吧。

这是我在洛谷上的第 1000 AC，可能也是最后一道 AC 了，以此纪念退役。

坦然接受一切吧。

---

## 作者：Lyrella (赞：6)

一道有意思的计数题。算概率相当于合法的情况，因为总情况是容易得到的。我们思考如何表示出某一种得分的情况，这个显然用生成函数刻画。对于第 $i$ 天我们用生成函数 $F_i(x)=\sum\limits_{k=0}^{a_i} x^k$ 表示，显然它还有封闭型式：$1-x^{a_i+1}\over1-x$。于是我们就能方便地表示出考试的情况了：
$$
G=\prod_{i=1}^n{1-x^{a_i+1}\over1-x}
$$
考虑到合法的情况是一段后缀，于是我们运用 [P5488](https://www.luogu.com.cn/problem/P5488) 的一点小技巧，令 $G\leftarrow G\times{1\over1-x}$，然后就变成了求单点的信息。观察到后面的询问都是在最开始状态的基础上单点修改，所以考虑快速求出 $G$ 然后通过 $G$ 直接求答案。

我们接下来处理 $G$。考虑对其进行化简：
$$
G=\left({1\over1-x}\right)^{n+1}\prod_{i=1}^n(1-x^{a_i+1})
$$
我们分别处理出前后两部分最后再拼到一起。先考虑前面的部分，我们尝试广义二项式定理：
$$
\begin{aligned}
\left({1\over1-x}\right)^{n+1}&=(1-x)^{-n-1}\\
&=\sum_{i=0}^\infty{-n-1\choose i}(-x)^i\\
&=\sum_{i=0}^\infty(-1)^i{i-(-n-1)-1\choose i}(-x)^i\\
&=\sum_{i=0}^\infty{n+i\choose i}x^i\\
\end{aligned}
$$
其中第三行运用上指标反转。这样我们轻松得到了前半部分，接下来考虑后面怎么搞。注意到后面有 $\mathcal O(n)$ 个少项式进行 $\prod$ 运算，于是考虑 [P4389](https://www.luogu.com.cn/problem/P4389) 的技巧，通过 $\exp\ln$ 将连乘变成连加。不考虑 $\exp$ 现在我们要处理的是：
$$
\sum_{i=1}^n\ln(1-x^{a_i+1})
$$
注意到有 $-\ln(1-x)=\sum\limits_{i=0}^\infty{x^i\over i}$，所以有：
$$
\sum_{i=1}^n\ln(1-x^{a_i+1})=-\sum_{i=1}^n\sum_{j=1}^\infty{x^{(a_i+1)j}\over j}
$$
证明上面的式子是相等的方法考虑对两边同时求导。所以后半部分调和级数枚举即可求得。现在加入单点修改我们就直接写式子了：
$$
ans=[x^{b-1}]{1-x^{a+1}\over1-x^{a_p+1}}G=[x^{b-1}]{G\over1-x^{a_p+1}}-[x^{b-a-2}]{G\over1-x^{a_p+1}}
$$
于是我们需要处理两个形如 $[x^b]{G\over1-x^a}$ 的式子。注意到一次询问中的 $a$ 会对 $ka,k\in \mathbb Z+$ 的位置产生影响所以考虑根号分治，对于 $a\le\sqrt n$ 的情况我们提前对每个 $a$ 都暴力算出每一位的值并记下来，询问的时候直接 $\mathcal O(1)$ 查；对于 $a>\sqrt n$ 的时候因为需要改的位置很少于是就在询问时暴力改即可，时间复杂度 $\mathcal O(n\ln n+n\sqrt n)$。

---

## 作者：irris (赞：1)

> 生成函数 / 卷积 / 拆贡献

## Preface

老早就想写一个 1100 AC 了，毕竟青春有悔。

题解区另一个老哥是 1000 AC，不禁深深感受到 oi 的发展趋势。

还是退役一了了之（？）。

## Solution

还是挺简单的，gf 入门题。

分母容易求，我们只求分子，然后 $\geq y$ 先容斥成 $\leq (y  - 1)$。

假设单次询问。写出分子的生成函数

$$F(x) = \prod_{i=1}^n \frac{1 - x^{a_i + 1}}{1 - x}$$

**为了便于求前缀和，让** $F(x) \gets \frac{1}{1-x} \cdot F(x)$。

这时

$$F(x) = \left( \frac{1}{1-x} \right)^{n+1} \prod_{i=1}^n (1 - x^{a_i + 1})$$

$\prod (1 - x^k)$，不保证 $\sum k$，就用 [P4839](https://www.luogu.com.cn/problem/P4389) 这一套，ln 再 exp 回去即可。

另一侧，$[x^k](\frac{1}{1 - x})^{n+1} = {n + k \choose n}$。

于是我们有了一个 $\mathcal O(q((n + y)\log y))$ 的做法，不过这也太慢了。

因为每次询问只修改一项（还不保留），那么（此处的 $t$ 为题面中的 $x$）

$$F'(x) = \frac{1 - x^{t+1}}{1 - x^{a_p + 1}}F(x)$$

因为只要 $[x^{y-1}]F'(x)$，容易想到，拆分子，实际上计算的就是

$$[x^{y-1}]\frac{1}{1 - x^{a_p + 1}}F(x) - [x^{y-t-2}]\frac{1}{1 - x^{a_p + 1}}F(x)$$

转化为，给出 $F(x)$，多次给出 $k, r$ 计算 $[x^k]\frac{1}{1 - x^r}F(x)$。

由于 $\frac{1}{1 - x^r} = 1 + x^r + x^{2r} + \dots $，那么我们单次显然有 $\mathcal O(\frac kr)$ 做法。

这个做法只在 $r$ 小时较慢，因此取 $B = \mathcal O(\sqrt{y})$ 对 $r \leq B$ 预处理，时间复杂度就做到了 $\mathcal O((q + y)\sqrt{y} + y\log y)$。

---


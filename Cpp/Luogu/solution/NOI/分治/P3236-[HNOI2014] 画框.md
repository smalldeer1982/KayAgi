# [HNOI2014] 画框

## 题目描述

小 T 准备在家里摆放几幅画，为此他买来了 $N$ 幅画和 $N$ 个画框。为了体现他的品味，小 T 希望能合理地搭配画与画框，使得其显得既不过于平庸也不太违和。

对于第 $i$ 幅画与第 $j$ 个画框的配对，小 T 都给出了这个配对的平凡度 $A_{i, j}$ 与违和度 $B_{i, j}$ 。整个搭配方案的总体不和谐度为每对画与画框平凡度之和与每对画与画框违和度的乘积。具体来说，设搭配方案中第 $i$ 幅画与第 $P_i$ 个画框配对，则总体不和谐度为

$$\mathrm{disharmony}=\sum_{i=1}^{N}A_{i,p_i}\times \sum_{i=1}^{N}B_{i,p_i}$$
小 T 希望知道通过搭配能得到的最小的总体不和谐度是多少。


## 说明/提示

第 $1$ 幅画搭配第 $3$ 个画框，第 $2$ 幅画搭配第 $1$ 个画框，第 $3$ 幅画搭配第 $2$ 个画框，则总体不和谐度为 $30$。

对于 $100\%$ 的数据，$N\leq 70$，$T\leq 3$，$A_{i, j}\leq 200$，$B_{i, j}\leq 200$。


## 样例 #1

### 输入

```
1
3
4 3 2
2 3 4
3 2 1
2 3 2
2 2 4
1 1 3```

### 输出

```
30```

# 题解

## 作者：Ameyax (赞：12)

类似于最小乘积生成树，把一种匹配的$\sum A_i$和$\sum B_i$分别看作横纵坐标，然后找$x \times y$最小的点。  
可以先找出$x$最小的点$A$和$y$最小的点$B$，然后找$AB$左下方离$AB$最远的点$C$，即$\overrightarrow{AB}\times\overrightarrow{AC}$最小。  
$$\overrightarrow{AB}\times\overrightarrow{AC}=(x_B-x_A)\times(y_C-y_A)-(y_B-y_A)\times(x_C-x_A)$$
$$=(x_B-x_A)\times y_C+(y_A-y_B)\times x_C+y_B\times x_A-x_B\times y_A$$  
那么把权值改成$g[i][j]=(y_A-y_B)\times a[i][j]+(x_B-x_A)\times b[i][j]$，再用二分图带权匹配就可以找出$C$。  
找出$C$后用叉积判断$C$是不是在$AB$的下方，如果是，就递归解决线段$AC$和$CB$。  
常数巨大的代码，之前写费用流还T了一次。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i, u) for (int i = fir[u]; i; i = e[i].nxt)
int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
	while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
const int inf = 50000000;
int T, n, ans, a[73][73], b[73][73];
struct Vector
{
	int x, y;
	Vector() {}
	Vector(int xx, int yy) { x = xx, y = yy; }
	friend Vector operator - (Vector a, Vector b) { return Vector(a.x - b.x, a.y - b.y); }
	friend int operator * (Vector a, Vector b) { return a.x * b.y - a.y * b.x; }
};
struct Graph
{
	int g[73][73], lx[73], ly[73], sla[73], match[73];
	bool visx[73], visy[73];
	void build(int wx, int wy)
	{
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				g[i][j] = -(wx * a[i][j] + wy * b[i][j]);
	}
	bool dfs(int u)
	{
		visx[u] = true;
		for (int v = 1; v <= n; v++) if (!visy[v])
		{
			int t = lx[u] + ly[v] - g[u][v];
			if (!t)
			{
				visy[v] = 1;
				if (!match[v] || dfs(match[v]))
				{
					match[v] = u;
					return true;
				}
			}
			else sla[v] = min(sla[v], t);
		}
		return false;
	}
	Vector km()
	{
		memset(lx, 0, sizeof lx);
		memset(ly, 0, sizeof ly);
		memset(match, 0, sizeof match);
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				lx[i] = max(lx[i], g[i][j]);
		for (int i = 1; i <= n; i++)
		{
			memset(sla, 63, sizeof sla);
			while (true)
			{
				memset(visx, 0, sizeof visx);
				memset(visy, 0, sizeof visy);
				if (dfs(i)) break;
				int d = inf;
				for (int i = 1; i <= n; i++)
					if (!visy[i]) d = min(d, sla[i]);
				for (int i = 1; i <= n; i++)
					if (visx[i]) lx[i] -= d;
				for (int i = 1; i <= n; i++)
					if (visy[i]) ly[i] += d;
					else sla[i] -= d; 
			}
		}
		Vector re(0, 0);
		for (int i = 1; i <= n; i++)
			re.x += a[match[i]][i], re.y += b[match[i]][i];
		return re;
	}
} g;
void solve(Vector A, Vector B)
{
	g.build(A.y - B.y, B.x - A.x);
	Vector C = g.km();
	ans = min(ans, C.x * C.y);
	if ((B - A) * (C - A) >= 0) return;
	solve(A, C), solve(C, B);
}
int main()
{
	T = read();
	while (T--)
	{
		n = read();
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				a[i][j] = read();
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				b[i][j] = read();
		g.build(1, 0);
		Vector A = g.km();
		g.build(0, 1);
		Vector B = g.km();
		ans = min(A.x * A.y, B.x * B.y);
		solve(A, B);
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：5)

# 洛谷 P3236 题解



## 思路分析

我们把每一个决策（匹配） $p$ 看成一个二维平面上的点 $(X_p,X_p)$，其中 $X_p=\sum_{i=1}^n A_{i,p_i}$，$Y_p=\sum_{i=1}^n B_{i,p_i}$

我们要找到最小的 $X_p\times Y_p$ ，有一个显然的优化：对于两个决策 $p_1,p_2$，如果 $X_{p_1}\le X_{p_2}$ 且 $Y_{p_1}\le Y_{p_2}$ 那么 $p_2$ 肯定是不优的，因此剪枝之后我们需要维护的 $p$ 在二维平面上一定构成一个下凸壳 $\mathbf H$

对于 $\mathbf H$ 最左边的点 $A$ 和最右边的点 $B$ 应该是显然的：就是最小化 $X_p$ 和最小化 $_p$ Y得到的两个决策

显然，在 $AB$ 下方可以找到一个点 $C$ 并且最大化 $C$ 到 $AB$ 的距离，那么此时的 $C$ 一定在 $\mathbf H$ 上，那么我们就可以对 $AC$，$BC$ 分别分治了

问题转化为求 $C$，首先考虑过 $AB$ 的一条直线 $(Y_A-Y_B)\times x+(X_B-X_A)\times y=X_B\times Y_A-X_A\times Y_B$

不妨记 $F_{AB}(x,y)=(Y_A-Y_B)\times x+(X_B-X_A)\times y$，原直线方程变为 $F_{AB}(x,y)=F_{AB}(A_X,A_Y)$

接下来考虑与 $AB$ 平行且过某一点 $P$ 的直线 $F_{AB}(x,y)=F_{AB}(P_X,P_Y)$，显然我们只需要最大化 $F_{AB}(A_X,A_Y)-F_{AB}(P_X,P_Y)$ 即可得到 $C$

所以我们只需要把每条边 $E_{i,j}$ 的边权设置为 $A_{i,j}\times(Y_A-Y_B)+B_{i,j}\times(X_B-X_A)$，然后求出新二分图的最小权完美匹配即可

使用 KM 解决此问题，时间复杂度 $\Theta(|\mathbf H|n^3)$，其中 $|\mathbf H|$ 为维护的凸壳的总大小

## 代码呈现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=71,INF=1e18,MAXV=3e6;
int n,ans;
struct point {
	int x,y;
	point() { x=0,y=0; }
	inline int calc(point A,point B) {
		return x*(A.y-B.y)+(B.x-A.x)*y;
	}
};
struct B_graph {
	int a[MAXN][MAXN],b[MAXN][MAXN];
	int w[MAXN][MAXN],lx[MAXN],ly[MAXN],slack[MAXN],tar[MAXN];
	bool sx[MAXN],sy[MAXN];
	inline void Read() {
		for(int i=1;i<=n;++i) {
			for(int j=1;j<=n;++j) {
				scanf("%lld",&a[i][j]);
			}
		}
		for(int i=1;i<=n;++i) {
			for(int j=1;j<=n;++j) {
				scanf("%lld",&b[i][j]);
			}
		}
	}
	inline bool find(int x) {
		if(sx[x]) return false;
		sx[x]=true;
		for(int y=1;y<=n;++y) {
			if(sy[y]) continue;
			int k=lx[x]+ly[y]-w[x][y];
			if(!k) {
				sy[y]=true;
				if(tar[y]==-1||find(tar[y])) {
					tar[y]=x;
					return true;
				}
			} else slack[y]=min(slack[y],k);
		}
		return false;
	}
	inline point MM(int cx,int cy) {
		memset(tar,-1,sizeof(tar));
		memset(lx,0,sizeof(lx));
		memset(ly,0,sizeof(ly)); 
		for(int i=1;i<=n;++i) {
			for(int j=1;j<=n;++j) {
				w[i][j]=MAXV-(a[i][j]*cx+b[i][j]*cy);
				lx[i]=max(lx[i],w[i][j]);
			}
		}
		for(int t=1;t<=n;++t) {
			memset(slack,0x3f,sizeof(slack));
			memset(sx,false,sizeof(sx));
			memset(sy,false,sizeof(sy));
			if(find(t)) continue;
			while(true) {
				int delta=INF,y=0;
				for(int i=1;i<=n;++i) if(!sy[i]) delta=min(delta,slack[i]);
				for(int i=1;i<=n;++i) {
					if(sx[i]) lx[i]-=delta;
					if(sy[i]) ly[i]+=delta;
					else {
						slack[i]-=delta;
						if(!slack[i]) y=i;
					}
				}
				if(tar[y]==-1) break;
 				int x=tar[y];
 				sx[x]=true,sy[y]=true;
 				for(int i=1;i<=n;++i) slack[i]=min(slack[i],lx[x]+ly[i]-w[x][i]);
			}
			memset(sx,false,sizeof(sx));
			memset(sy,false,sizeof(sy));
			find(t);
		}
		point ret;
		for(int i=1;i<=n;++i) {
			ret.x+=a[tar[i]][i];
			ret.y+=b[tar[i]][i];
		}
		return ret;
	}
}	G;
inline void solve(point A,point B) {
	point C=G.MM(A.y-B.y,B.x-A.x);
	ans=min(C.x*C.y,ans);
	if(C.calc(A,B)>=A.calc(A,B)) return ;
	solve(A,C); solve(C,B); 
}
signed main() {
	int T;
	scanf("%lld",&T);
	while(T--) {
		scanf("%lld",&n);
		G.Read();
		point A=G.MM(1,0),B=G.MM(0,1);
		ans=min(A.x*A.y,B.x*B.y);
		solve(A,B);
		printf("%lld\n",ans);
	}
	return 0;
}
```



---

## 作者：zzxLLL (赞：1)

### [P3236 [HNOI2014] 画框](https://www.luogu.com.cn/problem/P3236)

对于每种匹配方式 $P$ 将其看作平面上一点 $(\sum\limits_{i=1}^N A_{i,P_i}, \sum\limits_{i=1}^N B_{i,P_i})$，那么显然答案在左下凸包上。所以求出左下凸包即可。

但是 $P$ 总共有 $n!$ 种，一个一个枚举会 T 飞。所以考虑 Quick Hull 算法：

先找出离 x 轴最近的点 $D$ 和离 y 轴最近的点 $E$，即分别让 $\sum\limits_{i=1}^N A_{i,P_i}$ 和 $\sum\limits_{i=1}^N B_{i,P_i}$ 最小，显然可以用费用流求，边 $i \to j$ 费用分别为 $A_{i,j}$ 和 $B_{i,j}$。

然后在直线 $DE$ 的左下方找一点 $F$，使得 $F$ 离直线 $DE$ 的距离最远。注意到距离最远意味着 $S_{\triangle DEF}$ 面积最大，而 $S_{\triangle DEF} = \overrightarrow{DF} \times \overrightarrow{DE}$。设 $P_{A,i}$ 为点 $A$ 代表的方案中 $i$ 的匹配，这里可以推一波柿子：

$$\begin{aligned} \max(S_{\triangle DEF})
&= -\min(-\overrightarrow{DF} \times \overrightarrow{DE})
\\&= -\min[-(x_E-x_F)(y_D-y_F)+(y_E-y_F)(x_D-x_F)]
\\&= -\min[(x_Dy_E - x_Ey_D) + x_F(y_D-y_E) + y_F(x_E-x_D)])
\\&= -\min[(x_Dy_E - x_Ey_D) + \sum\limits_{i=1}^N A_{i,P_{F,i}}(y_D-y_E) + \sum\limits_{i=1}^N B_{i,P_{F,i}}(x_E-x_D)] \end{aligned}$$

所以若 $S_{\triangle DEF}$ 最大，则满足 $\sum\limits_{i=1}^N A_{i,P_{F,i}}(y_D-y_E) + \sum\limits_{i=1}^N B_{i,P_{F,i}}(x_E-x_D)$ 最小，而这个东西也可以用费用流求。将边 $u \to v$ 费用设为 $(y_D-y_E)A_{u,v}+(x_E-x_D)B_{u,v}$ 即可。

如果 $F$ 在 $DE$ 上或 $DE$ 右上，那么说明底下没有点了，直接返回。

这题卡费用流但是被我卡过去了（

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
//using namespace std;
const int M=233,inf=1e9+7;

inline int read(){
    char ch=getchar(); int f=0;
    while(ch<'0' || ch>'9') ch=getchar();
    while(ch>='0' && ch<='9') f=f*10+ch-'0',ch=getchar();
    return f;
}
inline int min(int A,int B){return A<B?A:B;}

int T,n,A[71][71],B[71][71];

int head[160],cnte=1;
struct Edge{int to,nxt,flow,cap,cost;}e[150*150];
void add(int u,int v,int w,int c){
    e[++cnte]=(Edge){v,head[u],0,w,c};
    head[u]=cnte;
}
void addedge(int u,int v,int w,int c){
    //printf("add(%d,%d)\n",u,v);
    add(u,v,w,c),add(v,u,0,-c);
}

int s,t;
void build(){
    for(int i=1;i<=n;i++) addedge(s,i,0,0);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++) addedge(i,j+n,0,0);
    for(int j=1;j<=n;j++) addedge(j+n,t,0,0);
}
void rebuild(int P,int Q){
    for(int i=head[s];~i;i=e[i].nxt){
        e[i].cap=1,e[i].flow=e[i].cost=0;
        e[i^1].cap=e[i^1].flow=e[i^1].cost=0;
    }
    for(int u=1;u<=n;u++)
        for(int i=head[u];~i;i=e[i].nxt){
            int v=e[i].to;
            if(v!=s)
                e[i].cap=1,e[i].flow=0,e[i].cost=P*A[u][v-n]+Q*B[u][v-n],
                e[i^1].cap=e[i^1].flow=0,e[i^1].cost=-e[i].cost;
        }
    for(int i=head[t];~i;i=e[i].nxt){
        e[i].cap=e[i].flow=e[i].cost=0;
        e[i^1].cap=1,e[i^1].flow=e[i^1].cost=0;
    }
}

std::queue<int>q;
int infl[160],dis[160],pre[160]; bool inq[160];
bool SPFA(){
    for(int i=s;i<=t;i++) infl[i]=dis[i]=inf;
    q.push(s),dis[s]=0,inq[s]=true;
    while(!q.empty()){
        int u=q.front(); q.pop(),inq[u]=false;
        //printf("SPFA: u = %d\n",u);
        for(int i=head[u];~i;i=e[i].nxt){
            int v=e[i].to;
            //printf("SPFA: (%d,%d) cost=%d dis[%d]=%d\n",u,v,e[i].cost,v,dis[v]);
            if(e[i].cap>e[i].flow && dis[v]>dis[u]+e[i].cost){
                pre[v]=i,infl[v]=min(infl[u],e[i].cap-e[i].flow),dis[v]=dis[u]+e[i].cost;
                if(!inq[v]) inq[v]=true,q.push(v);
            }
        }
    }
    return dis[t]!=inf;
}
int MCMF(){
    int cost=0,cur;
    while(SPFA()){
        cost+=infl[t]*dis[t]; cur=t;
        while(cur!=s){
            e[pre[cur]].flow+=infl[t];
            e[pre[cur]^1].flow-=infl[t];
            cur=e[pre[cur]^1].to;
        }
    }
    //printf("cost = %d\n",cost);
    return cost;
}

struct Vector{
    int x,y;
    Vector(int _x=0,int _y=0):x(_x),y(_y){}
    //Vector operator+(const Vector &o)const{return Vector(x+o.x,y+o.y);}
    Vector operator-(const Vector &o)const{return Vector(x-o.x,y-o.y);}
}D,E;
int cross(Vector A,Vector B){return A.x*B.y-A.y*B.x;}

int ans;
inline void solve(Vector D,Vector E){
    Vector F;
    rebuild(D.y-E.y,E.x-D.x),MCMF();
    for(int u=1;u<=n;u++)
        for(int i=head[u];~i;i=e[i].nxt){
            int v=e[i].to; if(v==s) continue;
            if(e[i].cap<=e[i].flow) F.x+=A[u][v-n],F.y+=B[u][v-n];
        }
    if(cross(E-D,F-D)>=0) return;
    solve(D,F),solve(F,E);
    ans=min(ans,F.x*F.y);
}

void clear(){
    ans=inf,cnte=1;
    for(int i=s;i<=t;i++) head[i]=-1;
    //for(int i=2;i<=cnte;i++)
        //e[i].to=e[i].nxt=e[i].cap=e[i].flow=e[i].cost=0;
}

int main(){
    T=read();
    s=0,t=149;
    while(T--){
        clear();
        n=read();
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++) A[i][j]=read();
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++) B[i][j]=read();
        
        s=0,t=(n<<1)|1,build();

        D.x=D.y=E.x=E.y=0;
        rebuild(1,0),MCMF();
        for(int u=1;u<=n;u++)
            for(int i=head[u];~i;i=e[i].nxt){
                int v=e[i].to;
                if(v!=s && e[i].cap<=e[i].flow) D.x+=A[u][v-n],D.y+=B[u][v-n];
            }
        //printf("D:(%d,%d)\n",D.x,D.y);
        rebuild(0,1),MCMF();
        for(int u=1;u<=n;u++)
            for(int i=head[u];~i;i=e[i].nxt){
                int v=e[i].to; if(v==s) continue;
                if(v!=s && e[i].cap<=e[i].flow) E.x+=A[u][v-n],E.y+=B[u][v-n];
            }
        ans=min(ans,min(D.x*D.y,E.x*E.y));
        solve(D,E);
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## title Brief description
题中已有公式，就不另外介绍了
[Link](https://www.luogu.com.cn/problem/P3236)
## Source
　　值得一写的脑洞题!

　　最开始没有任何思路，看了题解后才会做。

　　考虑将 $a$ 的和与 $b$ 的和表示为坐标，那么可能为答案的点一定是下凸包中的点，这样优化枚举就保证了效率。

　　然而并不知道到底哪些点是凸包中的点，但我们知道边界的两点（$a$ 最小于 $b$ 最小）一定在凸包上，如果已知两个凸包上的点，我们将它们连线，那么属于原图中的点若距离此直线最远，则一定是凸包上的点，于是可以二分，用向量的叉积求出那个点。

## Code
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=102;
const int INF=0x3f3f3f3f;
inline int read(){
    int X=0,w=0;char ch=0;
    while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
struct point{
    int x,y;
    point(int xx=0,int yy=0){x=xx,y=yy;}
    point operator -(const point &b)const{
        return point(x-b.x,y-b.y);
    }
    int operator *(const point &b)const{
        return x*b.y-y*b.x;
    }
};
int n,ans,a[N][N],b[N][N];
int dis[N][N],wx[N],wy[N],match[N],sla[N];
bool vx[N],vy[N];
bool dfs(int u){
    vx[u]=1;
    for(int v=1;v<=n;v++){
        if(!vy[v]){
            int w=wx[u]+wy[v]-dis[u][v];
            if(!w){
                vy[v]=1;
                if(!match[v]||dfs(match[v])){
                    match[v]=u;return 1;
                }
            }else sla[v]=min(sla[v],w);
        }
    }
    return 0;
}
point KM(){
    point res=point(0,0);
    memset(wx,0,sizeof(wx));
    memset(wy,0,sizeof(wy));
    memset(match,0,sizeof(match));
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            wx[i]=max(wx[i],dis[i][j]);
    for(int i=1;i<=n;i++){
        memset(sla,INF,sizeof(sla));
        while(1){
            memset(vx,0,sizeof(vx));
            memset(vy,0,sizeof(vy));
            if(dfs(i))break;
            int minn=INF;
            for(int j=1;j<=n;j++)
                if(!vy[j])minn=min(minn,sla[j]);
            for(int j=1;j<=n;j++){
                if(vx[j])wx[j]-=minn;
                if(vy[j])wy[j]+=minn;
                else sla[j]-=minn;
            }
        }
    }
    for(int i=1;i<=n;i++)
        res.x+=a[match[i]][i],res.y+=b[match[i]][i];
    ans=min(ans,res.x*res.y);
    return res;
}
void work(point l,point r){
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            dis[i][j]=-(a[i][j]*(l.y-r.y)+b[i][j]*(r.x-l.x));
    point mid=KM();
    if((r-l)*(mid-l)>=0)return;
    work(l,mid);work(mid,r);
}
int main(){
    int t=read();
    while(t--){
        ans=INF;n=read();
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                a[i][j]=read();
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                b[i][j]=read();
        for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)dis[i][j]=-a[i][j];
        point p1=KM();
        for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)dis[i][j]=-b[i][j];
        point p2=KM();
        work(p1,p2);
        printf("%d\n",ans);
    }
    return 0;
}
```


---


# [CTSC2010] 珠宝商

## 题目描述

Louis.PS 是一名精明的珠宝商，他出售的项链构造独特，很大程度上是因为他的制作方法与众不同。每次 Louis.PS 到达某个国家后，他会选择一条路径去遍历该国的城市。在到达一个城市后，他会使用在这个城市流行的材料制作一颗珠子，并按照城市被访问的顺序将珠子串联做成项链，为了使制作出来的项链不会因为城市之间的竞争而影响销量，路径中同一个城市不会重复出现（因为如果项链中 $A$ 城市的材料比 $B$ 城市的材料使用的多，则项链在 $B$ 城市的宣传可能会受到影响）。经过多年对消费者的调查，Louis.PS 已经掌握了判断一条项链吸引消费者程度的方法，具体来说，Louis.PS 经过调查得出了受消费者欢迎的项链的特征，并基于此制作了一个长项链（Louis.PS 称之为特征项链）。对于一条待售的项链，这条项链在特征项链里出现的次数越多，这条项链就越受消费者欢迎。

考虑到现实情况的复杂性，我们对条件做出适当的简化。对于每个国家，在某些城市间存在道路直接相连，对于两个不同的城市，有且仅有一条路径连接这两个城市（即国家是连通的，且不存在一个环）。对于每个城市，我们用一个小写字母来表示在这个城市流行的材料类型。这样，我们就可以用一个仅包含小写字母的字符串来表示一条项链，我们将特征项链所对应的字符串称作特征字符串，设为 $\mathit{EigenString}[1\ldots M]$，$M$ 为特征项链的长度。对于一条项链，假设其对应字符串为 $P[1\ldots L]$，$L$ 为这条项链的长度。如果存在一个正整数 $K$，使 $\mathit{EigenString}[K\ldots K+L-1]=P[1\ldots L]$，称这条项链在特征项链中出现了一次。满足上述条件的正整数 $K$ 的个数即为这条项链在特征项链的出现次数，记为 $\mathit{Popularity}(P)$。

Louis.PS 使用数学中的期望概念来评价一个国家是否适合珠宝的采集,对于一个包含 $N$ 个城市的国家，令 $\mathit{Str}_{u,v}$ 表示沿着从 $u$ 开始,至 $v$ 结束的路径所得到的项链的对应字符串。（$\mathit{Str}_{u,v}$ 与 $\mathit{Str}_{v,u}$ 表示的串一般不相同），则

$$
\mathit{Expectation}=\frac{\sum_{u,v}{\mathit{Popularity}(\mathit{Str}_{u,v})}}{N^2}
$$

对于如下的例子（图中实线表示两端点的国家有直接道路相连）：

$N=3$，所流行的材料类型分别为 $\tt{a,a,b}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9zkwho64.png)

$$
\mathit{Expectation}=\frac{3+1+2+1+3+1+1+1+2}{9}=\frac53
$$

对于一个国家，Louis.PS 想知道其 $\mathit{Expectation}$ 的值，但苦于计算期望的工作量太大。作为珠宝店的学徒，你当然不愿放过难得在老板面前展示自己的机会。

## 说明/提示

有 $20\%$ 的数据，满足 $M \leq 1000$；

有 $40\%$ 的数据，满足ܰ $N \leq 8000, M \leq 50000$；

对于 $100\%$ 的数据，$N,M \leq 50000$。

## 样例 #1

### 输入

```
3 5
1 2
1 3
aab
abaab```

### 输出

```
15```

# 题解

## 作者：w4p3r (赞：25)

### 一丶前言：
这道题真的好巧啊，是一道很好的训练后缀自动机与点分治 ~~(与让自己自闭)~~ 的题

### 二丶思路：
假设匹配串为$S$

~~显然，对匹配串$S$建后缀自动机~~

然后有一个十分简单的暴力思路，我们枚举树上的起始点$x$，然后从$x$开始直接dfs，在dfs的同时在SAM的DAG上跑匹配（如果找不到转移直接return）就好了。

假设到了后缀自动机的$y$号节点，$ans+=size[y]$就好了($size$是SAM点上的$right$集合大小)

对于学过后缀自动机 ~~（如果你没学过来做这道题干嘛）~~ 的各位来说，相信还是十分简单的，时间复杂度$O(n^2)$

接着，我们开始考虑正解。

看到我们要处理树上的所有路径，我们不由自主地会想到点分治。假设当前分治中心是$x$，我们该怎么处理？

直接算$\sum_{a} \sum_{b}[a$ 到 $x$组成的字符串在$S$出现的次数$]\times[x$到$b$组成的字符串在$S$出现的次数$]$ ？

这样显然不对，因为我们不能说前面出现在$S$，后面也出现在$S$，它们拼起来就一定出现在$S$

换句话说，它们在$S$中出现的位置不一定相同

**再换句话说，我们要求的是：**

$\sum_{p}\sum_{a}\sum_{b} [a$ 到 $x$组成的字符串出现在$S$且末尾为$p] \times [x$到$b$组成的字符串出现在$S$且起点是$p]$

(请看清楚上面那个和式qwq)

那我们只用枚举$p$，然后统计有多少个$a,b$满足$[a$到$x$组成的字符串出现在$S$且末尾为$p]$与$[x$到$b$组成的字符串出现在$S$且起点是$p]$就行了

显然两个统计是对称的（把$S$倒过来后者就变成了前者），所以我们只用考虑对第一种情况进行统计。

为了方便，下面假设$T$为是$a$到$x$形成的字符串，$pos[p]$为$S[1,p]$在SAM对应的节点

如果一个$T$是合法的，那么应该满足:
 
$\quad$1.$T$出现在$S$中

$\quad$2.$T$在SAM上对应的点的$right$集合包含$p$（既然它出现在$S$中那它肯定能对应SAM上一个点）

那我们只需要整一个$num$数组，并在$dfs$中途随时在找出$T$在SAM上的对应的节点$v$，并$num[v]++$就好了（如果没有直接return就好了）

问题就来了，如果我是在往$T$后面加字符，我直接在SAM的DAG上转移就好了，问题在于现在我是在往$T$前面加字符，我该怎么转移呢？

这个东西涉及到$Parent Tree$求儿子的问题，我们接下来再讲（当然你如果会了可以略过）

现在假设我们已经知道了在$T$前面加字符是如何转移的，并统计出了$num$数组，然后我们怎么求答案呢？

直接枚举$pos[p]$的所有祖先的$num$加起来？显然TLE

其实只要至上而下$num[x]+=num[fa[x]]$，然后$num[pos[p]]$就是答案了

现在我们回到上面的那个问题，我们往$T$前面加字符在SAM对应的点的变化情况。假设现在$T$对应SAM上的点$v$，并在$T$的前面加一个字符$c$，分两种情况讨论（假设$R[v]$表示$v$节点的任意一个$right$）：

1. $|T|<len[v]$，直接看接判断$[c==S[R[v]-|T|]]$，若为真$T$仍然对应$v$，否则$T$将不再出现在$S$中

2. $|T|==len[v]$，看有没有一个点$x$满足$fa[x]=v$，且$S[R[x]-len[v]]==c$，若有则$T$对应$x$，否则$T$将不再出现在$S$中

这样关于$ParentTree$的儿子的定义也呼之欲出了：

$son[x][p]$表示在$p+S[R[x]-len[x]+1,R[x]]$在$S$中对应的节点（这个数组可以在build时求出）

那么上面的第二条也可以改写成:

若$son[v][c]$存在，则$T$对应$son[v][c]$，否则$T$将不再出现在$S$中

时间复杂度为$O(nlogn+nm)$

等等，我们整了那么久，搞出来那么多东西，复杂度还变劣了？？~~（不做了下一道）~~

我们研究一下这个算法缺点在哪儿？其实缺点就在于，不管我们现在处理的分治子树多么的小，我们都需要把整个$m$遍历一遍，这样是很不划算的。

那咋办呢？等等，我们是不是还有一个$O(n^2)$的做法，那我们对小的分治子树直接进行$O(n^2)$的做法不就好了

自然考虑分块，对于小于等于$sqrt(n)$的分治子树直接暴力$n^2$，而对大的分治子树进行~~刚刚我们神奇的操作~~

还有个小问题 **（几乎是所有点分治都记得要考虑的问题）**，$a$和$b$可能来自同一个子树，其实也很简单，直接容斥减掉就好了。

相信你现在几乎是一定一脸懵逼的 ~~（如果不是那说明你太强了%%%）~~，所以我们接下来结合代码理解一下吧。

### 三丶代码
```cpp
//BadWaper gg
#include<bits/stdc++.h> 
#define inf 1e9
#define eps 1e-6
#define N 100010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
ll n,m;
struct edge
{
	ll next,to;
}e[N<<1];
ll head[N],cnt,vis[N];
ll pos1[N],pos2[N];
ll a[N],s[N];
char s1[N],s2[N];
ll size[N],C[N],p[N],ans;
ll minn=inf,rt,block;
struct SAM
{
	ll len[N],ch[N][26],fa[N];
	ll tot,son[N][26],R[N],size[N],num[N],last;
	ll p[N],c[N];
	ll s[N];
	SAM(){tot=last=1;}
	inline void insert(ll x)
	{
		ll nowp=++tot,p=last;len[nowp]=len[p]+1;size[nowp]=1;R[nowp]=len[nowp];
		while(p&&!ch[p][x])ch[p][x]=nowp,p=fa[p];
		if(!p)fa[nowp]=1;
		else 
		{
			ll q=ch[p][x];
			if(len[q]==len[p]+1)fa[nowp]=q;
			else
			{
				ll nowq=++tot;len[nowq]=len[p]+1;
				fa[nowq]=fa[q];fa[q]=nowq,fa[nowp]=nowq;
				for(register ll i=0;i<26;i++)ch[nowq][i]=ch[q][i];
				while(p&&ch[p][x]==q)ch[p][x]=nowq,p=fa[p];
			}
		}
		last=nowp;
	}//建SAM
	inline void build()
	{
		for(register ll i=1;i<=tot;i++)c[len[i]]++;
		for(register ll i=1;i<=m;i++)c[i]+=c[i-1];
		for(register ll i=1;i<=tot;i++)p[c[len[i]]--]=i;//基排
		for(register ll i=tot;i>=2;i--)
		{
			ll x=p[i];
			size[fa[x]]+=size[x];R[fa[x]]=R[x];//R是right集合内任意一个值，所以这里你爱咋搞咋搞啦qwq
			son[fa[x]][s[R[x]-len[fa[x]]]]=x;//求son
		}
	}
	inline void clear(){for(register ll i=1;i<=tot;i++)num[i]=0;}
	inline void calc(ll now,ll father,ll p,ll L)
	{
		if(len[p]==L)p=son[p][a[now]];//情况2
		else if(s[R[p]-L]!=a[now])p=0;//情况1
		if(!p)return ;//T不在S直接return
                num[p]++;
		for(register ll i=head[now];i;i=e[i].next)
		{
			if(e[i].to==father||vis[e[i].to])continue;
			calc(e[i].to,now,p,L+1);
		}
	}
	inline void pushdown()
	{
		for(register ll i=2;i<=tot;i++)//自上而下
		{
			ll x=p[i];
			num[x]+=num[fa[x]];
		}
	}
}S1,S2;
inline void add_edge(ll from,ll to){e[++cnt]=(edge){head[from],to};head[from]=cnt;}
void getroot(ll now,ll Ns,ll father)
{
	size[now]=1;ll maxn=-inf;
	for(register ll i=head[now];i;i=e[i].next)
	{
		if(e[i].to==father||vis[e[i].to])continue;
		getroot(e[i].to,Ns,now);size[now]+=size[e[i].to];
		maxn=max(maxn,size[e[i].to]);
	}
	maxn=max(maxn,Ns-size[now]);
	if(maxn<minn)minn=maxn,rt=now;
}//点分治求根
void dfs1(ll now,ll father)
{
	p[++p[0]]=now;
	for(register ll i=head[now];i;i=e[i].next)
	{
		if(e[i].to==father||vis[e[i].to])continue;
		dfs1(e[i].to,now);
	}
}//n^2暴力
void dfs2(ll now,ll father,ll x)
{
	x=S1.ch[x][a[now]];if(!x)return ;
	ans+=S1.size[x];
	for(register ll i=head[now];i;i=e[i].next)
	{
		if(e[i].to==father||vis[e[i].to])continue;
		dfs2(e[i].to,now,x);
	}
}//n^2暴力
void calc(ll x,ll father,ll f)
{
	S1.clear(),S2.clear();
	if(father)
	{
		S1.calc(x,0,S1.son[1][a[father]],1);
		S2.calc(x,0,S2.son[1][a[father]],1);
	}
	else {S1.calc(x,0,1,0);S2.calc(x,0,1,0);}
	S1.pushdown();S2.pushdown();
	for(register ll i=1;i<=m;i++)
	{
		ans+=f*S1.num[pos1[i]]*S2.num[pos2[m-i+1]];
	}//统计答案，注意因为串反过来了所以后面是m-i+1
}
void DFS(ll now,ll father)
{
	C[now]=1;
	for(register ll i=head[now];i;i=e[i].next)
	{
		if(e[i].to==father||vis[e[i].to])continue;
		DFS(e[i].to,now);C[now]+=C[e[i].to];
	}
}//求分治子树大小
void dfs(ll now,ll Ns)
{
	if(Ns<=block)
	{
		p[0]=0;dfs1(now,0);
		for(register ll i=1;i<=p[0];i++)dfs2(p[i],0,1);
		return ;
	}//n^2暴力
	vis[now]=1;calc(now,0,1);DFS(now,0);
	for(register ll i=head[now];i;i=e[i].next)
	{
		if(vis[e[i].to])continue;
		calc(e[i].to,now,-1);//容斥，把同一子树的答案容斥掉
                minn=inf,rt=0;
		getroot(e[i].to,C[e[i].to],0);dfs(rt,C[e[i].to]);
	}
}
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read();block=sqrt(n);
	for(register ll i=1;i<n;i++)
	{
		ll x=read(),y=read();
		add_edge(x,y);add_edge(y,x);
	}
	scanf("%s",s1+1);
	for(register ll i=1;i<=n;i++)a[i]=s1[i]-'a';
	scanf("%s",s2+1);
	for(register ll i=1;i<=m;i++)s[i]=s2[i]-'a';
	for(register ll i=1;i<=m;i++)S1.insert(s[i]),pos1[i]=S1.last,S1.s[i]=s[i];
	reverse(s+1,s+m+1);//把串翻转之后第二个统计与第一个统计类似
	for(register ll i=1;i<=m;i++)S2.insert(s[i]),pos2[i]=S2.last,S2.s[i]=s[i];
	S1.build();S2.build();
	getroot(1,n,0);dfs(rt,n);
	printf("%lld\n",ans);
	return 0;
}

```

### 四丶后记
我们做一道题不仅仅是要搞懂这道题怎么做，更要学会从这道题上反思与总结。

在平时的SAM学习中，我们几乎只用过在字符串后加字符（跑DAG），或者是在字符串前删字符（跳ParentTree），但这道题特殊之处就在于我们是在字符串前加入字符，并由此定义出了ParentTree上儿子的定义。（如果是在字符串后面删字符该怎么做呢qwq）

这是我从这道题收获到的东西，当然每个人收获到的东西多半都不一样，希望你也能从我的题解和这道题上有一定收获。

**如果你觉得这篇题解对你有帮助，那你可以点个赞支持我一下qwq。如果你对题解有任何问题/认为我的题解有任何问题，可以私信/在评论区发出来，当然如果你对我的题解有任何意见/建议也欢迎指出。我会尽我全力把我题解写到最好的qwq**

~~这篇题解大部分我认为人人皆知的东西我就没定义了，往谅解qwq~~

---

## 作者：GK0328 (赞：13)

### $SAM$+点分治+根号分治

又被$SAM$神仙题教育了一顿。。。

字符串上树了，看起来很不可做的样子。由于本题需要维护的是所有链的信息，容易想到点分治。

既然要使用点分治，不可避免地要面临统计子树信息和两条链合并的难题。

比如当前连通块的重心为$x$，要统计信息并合并$u \rightarrow x \rightarrow v$，如何操作呢？

我们统计答案时，必然需要把信息集中在合并点处，也就是说，链$u \rightarrow x$对应模式串$T$的区间$[l,i]$，而链$x \rightarrow v$对应模式串$T$的区间$[i,r]$，那么我们可以在$i$处统计贡献。

考虑$SAM$上只有后缀会拥有一个指定的节点，我们先考虑$u \rightarrow x$的一部分，它将作为$[l,i]$出现，而节点$x$将作为$i$位置。

发现我们遍历子树时，不是我们习惯的向后插入字符，而是向前插入字符。

但是这仅仅是查找而已，强大的$SAM$可以完成这个任务。具体来说，我们考虑原串一定是新串的后缀，那么对应于$parent$树上，原串所在位置$p$与新串所在位置相同或是它的父亲。当长度小于$len_p$时，要么失配（只要记录$p$的任意一个后缀位置即可），要么长度$+1$；而长度大于$len_p$时，它可能失配，也可能到达它的其中一个儿子节点。我们需要建立一种全新的转移边，表示一个节点到达最大长度之后加入字符$c$会到达哪个儿子，可以在建$SAM$时预处理（不明白可以看代码，很容易理解）。

而链$x \rightarrow v$只是$S$的反串$S^r$上同样的操作而已。

接下来，就是合并答案了。

对于$i$位置，我们会在$S$的$SAM$上记录其后缀，在$S^r$的$SAM$上记录其前缀，我们发现只要是$i$的前缀、后缀都可以记录入答案，也就是$i$所在的节点以及其$parent$树上的祖先，我们可以最后一次处理统计答案，一次计算时间复杂度为$O(m+size)$。

但是点分治需要有去重，直接去重一次时间复杂度仍然是$O(m+size)$。

我们一分析复杂度$O(n \log n + nm)$，白干了？？？

**根号分治**就出场了。

除了$O(m+size)$的统计算法，我们显然还有$O(size^2)$的暴力。

我们设定一个阈值$B=\sqrt n$，使得在$\le B$时跑暴力，$>B$时跑$O(m+size)$的算法。

由于点分治一层子节点必然比上一次至少减半，那么我们计算一下，第$k$层的子树大小不会超过$\frac{n}{2^k}$，在本题数据范围中第$8$层的数据已经小于$\sqrt n$了，这时候子树个数上限大约是$2^8=256$，可以近似看成$\sqrt n$了。所以这一部分的复杂度为$O(n \sqrt n)$。

对于大子树，可以把小子树看成它们的叶子节点，那么大子树个数与小子树个数同阶，这一部分时间复杂度为$O(m \sqrt n)$。

现在我们的去重仍然存在时间复杂度问题。

我们需要观察重复的是哪一部分，也就是说原来的$u \rightarrow x \rightarrow v$的$u,v$在同一子树中。

同样进行根号分治，对于大子树仍然执行$O(m+size)$算法。而小子树可以$O(size)$枚举子树中一个点，记录其到达当前点分到的重心节点的路径，然后返回同一子树中进行暴力统计，时间复杂度为$O(size^2)$。

进行平衡后，时间复杂度为$O(n \sqrt n)$，可以轻松通过此题。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define N 50005
using namespace std;
const int INF=1000000007;
char s[N],t[N];
int n,m,x,y,block,rc[N],c[N];
ll ans=0;
struct edge
{
    int nxt,v;
    edge (int Nxt=0,int V=0)
    {
        nxt=Nxt,v=V;
    }
}e[N << 1];
int tot,fr[N];
int lsz,rt,rtsz,sz[N],f[N],q[N];
bool vis[N];
void add(int x,int y)
{
    ++tot;
    e[tot]=edge(fr[x],y),fr[x]=tot;
}
struct SAM
{
    int cnt=1,lst=1,tr[N << 1][26],pre[N << 1],len[N << 1],R[N << 1];
    int g[N << 1],a[N << 1],loc[N],ct[N << 1],son[N << 1][26];
    char t[N];
    void ins(int c,int I)
    {
        int p=lst,np=++cnt;
        loc[I]=lst=np,len[np]=len[p]+1,R[np]=I,++ct[np];
        for (;p && !tr[p][c];p=pre[p])
            tr[p][c]=np;
        if (!p)
            pre[np]=1; else
            {
                int q=tr[p][c];
                if (len[p]+1==len[q])
                    pre[np]=q; else
                    {
                        int g=++cnt;
                        memcpy(tr[g],tr[q],sizeof(tr[q]));
                        len[g]=len[p]+1,pre[g]=pre[q],R[g]=R[q];
                        for (;p && tr[p][c]==q;p=pre[p])
                            tr[p][c]=g;
                        pre[q]=pre[np]=g;
                    }
            }
    }
    void build()
    {
        for (int i=1;i<=m;++i)
            ins(t[i]-'a',i);
        memset(c,0,(m+1)*sizeof(int));
        for (int i=1;i<=cnt;++i)
            ++c[len[i]];
        for (int i=1;i<=m;++i)
            c[i]+=c[i-1];
        for (int i=1;i<=cnt;++i)
            a[c[len[i]]--]=i;
        for (int i=cnt;i>=2;--i)
        {
            int u=a[i];
            ct[pre[u]]+=ct[u];
            if (pre[u]!=1)
                son[pre[u]][t[R[u]-len[pre[u]]]-'a']=u;
        }
    }
    int nxt(int u,int L,char c)
    {
        if (len[u]>=L)
            return (t[R[u]-L+1]==c)?u:0;
        return son[u][c-'a'];
    }
    void clear()
    {
        memset(g,0,(cnt+1)*sizeof(int));
    }
    void dfs(int u,int F,int Len,int st)
    {
        if (!st)
            return;
        ++g[st];
        for (int i=fr[u];i;i=e[i].nxt)
        {
            int v=e[i].v;
            if (v==F || vis[v])
                continue;
            dfs(v,u,Len+1,nxt(st,Len+1,s[v]));
        }
    }
    void calc()
    {
        for (int i=2;i<=cnt;++i)
            g[a[i]]+=g[pre[a[i]]];
    }
}s1,s2;
void findrt(int u,int F,int rn)
{
    int mx=-1;
    sz[u]=1;
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if (v==F || vis[v])
            continue;
        findrt(v,u,rn);
        sz[u]+=sz[v],mx=max(mx,sz[v]);
    }
    mx=max(mx,rn-sz[u]);
    if (mx<rtsz)
        rtsz=mx,rt=u;
}
void getrt(int u,int rn)
{
    rtsz=INF,findrt(u,0,rn);
}
void dfs1(int u,int F)
{
    q[++q[0]]=u;
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if (v==F || vis[v])
            continue;
        f[v]=u;
        dfs1(v,u);
    }
}
void dfs2(int u,int F,int st,int t)
{
    if (!st)
        return;
    ans+=t*s1.ct[st];
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if (v==F || vis[v])
            continue;
        dfs2(v,u,s1.tr[st][rc[v]],t);
    }
}
void calc(int u,int c,int t)
{
    s1.clear(),s2.clear();
    if (t==1)
    {
        s1.dfs(u,0,1,s1.tr[1][rc[u]]);
        s2.dfs(u,0,1,s2.tr[1][rc[u]]);
    } else
    {
        s1.dfs(u,0,2,s1.nxt(s1.tr[1][c],2,s[u]));
        s2.dfs(u,0,2,s2.nxt(s2.tr[1][c],2,s[u]));
    }
    s1.calc(),s2.calc();
    for (int i=1;i<=m;++i)
        ans+=(ll)t*s1.g[s1.loc[i]]*s2.g[s2.loc[m-i+1]];
}
void calc2(int u,int rt)
{
    q[0]=0,f[u]=rt,dfs1(u,0);
    for (int i=1;i<=q[0];++i)
    {
        int t=q[i],st=1;
        while (t!=rt)
            st=s1.tr[st][rc[t]],t=f[t];
        st=s1.tr[st][rc[t]],st=s1.tr[st][rc[u]];
        dfs2(u,0,st,-1);
    }
}
void solve(int u)
{
    if (lsz<=block)
    {
        q[0]=0,dfs1(u,0);
        for (int i=1;i<=q[0];++i)
            dfs2(q[i],0,s1.tr[1][rc[q[i]]],1);
        return;
    }
    int tsz=lsz;
    vis[u]=true;
    calc(u,1,1);
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if (vis[v])
            continue;
        int ts=(sz[u]<sz[v])?tsz-sz[u]:sz[v];
        if (ts>block)
            calc(v,rc[u],-1); else
            calc2(v,u);
    }
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if (vis[v])
            continue;
        lsz=(sz[u]<sz[v])?tsz-sz[u]:sz[v];
        getrt(v,lsz);
        solve(rt);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<n;++i)
    {
        scanf("%d%d",&x,&y);
        add(x,y),add(y,x);
    }
    scanf("%s%s",s+1,t+1);
    for (int i=1;i<=n;++i)
        rc[i]=s[i]-'a';
    block=(int)sqrt(n);
    for (int i=1;i<=m;++i)
        s1.t[i]=t[i],s2.t[i]=t[m-i+1];
    s1.build(),s2.build();
    lsz=n,getrt(1,n);
    solve(rt);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Calculatelove (赞：6)

## Description

给出一棵包含 $n$ 个节点的树，每个节点上都有一个字符。除此之外，还会给出一个长度为 $m$ 的文本串。

求树上所有路径，经过的所有字符按顺序连接形成的字符串，在文本串中的出现次数之和。

数据范围：$1 \leq n, m \leq 5 \times 10^4$，给出的字符均为小写字母。  
时空限制：$8000 \ \mathrm{ms} / 500 \ \mathrm{MiB}$。

## Solution

运用点分治统计路径答案。对于当前大小为 $\mathbf{size}$ 的分治块，有两种内核不同的算法。

### 算法一：$\mathcal{O}(\mathbf{size}^2)$

将原串的 SAM 建出。

直接计算当前分治块的所有路径对答案的贡献。

枚举当前分治块的每一个点，计算以当前点为起点的所有路径对答案的贡献。

可以从该起点开始搜索，维护起点到当前点所形成的字符串在 SAM 上的状态，则当前路径对答案的贡献即为该状态所对应的 $\mathrm{endpos}$ 集合大小。

### 算法二：$\mathcal{O}(\mathbf{size} + m)$

将原串、反串的 SAM 建出。

考虑计算跨越当前分治重心 $u$ 的所有路径对答案的贡献，其他情况递归求解。

对于一个跨越当前分治重心 $u$ 的路径 $x \to u \to y$，可以考虑将其拆成 $x \to u$ 的前缀段与 $u \to y$ 的后缀段。

考虑计算出两个数组 $\mathrm{le}(i), \mathrm{rg}(i)$ 分别表示，在模式串中以位置 $i$ 为结尾的前缀段个数、以位置 $i$ 为开头的后缀段个数。则跨越当前分治重心的所有路径对答案的贡献即为 $\sum_{i = 1}^m \mathrm{le}(i) \cdot \mathrm{rg}(i)$。

但由于这样做可能会额外计算到来自同一颗子树的前缀串、后缀串组合的贡献。所以还需要对所有的子分治块进行相似的统计，减去错误的贡献即可。

可以从分治重心开始搜索，维护当前点到分治重心所形成的字符串在正串、反串 SAM 上的状态，则在正串 SAM 里的状态所对应 $\mathrm{endpos}$ 集合里的 $\mathrm{le}(i)$，反串 SAM 里的状态所对应 $\mathrm{endpos}$ 集合里的 $\mathrm{rg}(i)$ 都要加一。在对应状态上打上一个标记，最后自上而下传递一遍即可。

> 在维护当前点到分治重心所形成的字符串在 SAM 上的状态时，涉及到在一个状态的开头插入字符，SAM 也是可以做的。具体地，在加字符之前：
>
> - 若当前串的长度等于当前状态的 $\mathrm{maxl}$，则相当于要在 parent 树上向一个儿子节点走。在建 parent 树的时候，预处理每一个状态前加一个字符，能走到哪个儿子即可。
> - 若当前串的长度小于当前状态的 $\mathrm{maxl}$，则相当于要考虑当前状态是否可以容纳新串，只需判断新加的字符是否与原串对应位置上的字符匹配即可。

### 算法一 & 二

在下文的探讨中，视 $n, m$ 同阶。

注意到算法一在 $\mathbf{size}$ 较小时表现较好，算法二在 $\mathbf{size}$ 较大时表现较好。不妨将两种算法相结合。

针对当前分治块的大小 $\mathbf{size}$ 进行平衡规划。取阈值 $B$，当 $\mathbf{size} \leq B$ 时使用算法一，$\mathbf{size} > B$ 时使用算法二。

注意到在点分治的过程中，只需要在点分树上遍历 $\mathcal{O}(\frac{n}{B})$ 个节点，即可保证分治出的最大子树大小为 $\mathcal{O}(B)$ 的，并且这些叶子节点的个数也为 $\mathcal{O}(\frac{n}{B})$ 的。因此：

- 算法一开销：$\mathcal{O}(B^2) \cdot \mathcal{O}(\frac{n}{B}) = \mathcal{O}(nB)$。
- 算法二开销：$\mathcal{O}(n) \cdot \mathcal{O}(\frac{n}{B}) + \mathcal{O}(n \log \frac{n}{B}) = \mathcal{O}(\frac{n^2}{B})$。

取 $B = \sqrt{n}$，可以取得理论最优复杂度 $\mathcal{O}(n \sqrt{n})$。取得最优运行效率，可能需要进行微调。

需要注意的是，对满足 $\mathbf{size} > B$ 的分治块运用了算法二后，要对满足 $\mathbf{size}' \leq B$ 的子分治块进行类算法一的容斥。否则会被菊花图卡掉。

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>

using std::vector;

template <class T>
inline void read(T &x) {
	static char s;
	while (s = getchar(), s < '0' || s > '9');
	x = s - '0';
	while (s = getchar(), s >= '0' && s <= '9') x = x * 10 + s - '0';
}

const int N = 50100;

int n, m, Bn;

int tot, head[N], ver[N * 2], Next[N * 2];
void add_edge(int u, int v) {
	ver[++ tot] = v;    Next[tot] = head[u];    head[u] = tot;
}

char a[N], tex[N];

int A_sz, A_rt;
int sz[N], mp[N];
bool ban[N];

int temp_sz[N];
int Get_sz(int u, int fu) {
	int cnt = 1;
	for (int i = head[u]; i; i = Next[i]) {
		int v = ver[i];
		if (v == fu || ban[v]) continue;
		cnt += Get_sz(v, u);
	}
	return cnt;
}

void Get_rt(int u, int fu) {
	sz[u] = 1, mp[u] = 0;

	for (int i = head[u]; i; i = Next[i]) {
		int v = ver[i];
		if (v == fu || ban[v]) continue;
		Get_rt(v, u);
		sz[u] += sz[v];
		if (sz[v] > mp[u]) mp[u] = sz[v];
	}

	if (A_sz - sz[u] > mp[u]) mp[u] = A_sz - sz[u];
	if (A_rt == 0 || mp[u] < mp[A_rt]) A_rt = u;
}

struct SAM {
	static const int SIZE = N * 2;

	int strL, s[N];

	int cT = 1, Last = 1;
	struct node {
		int trans[26];
		int link, maxl;
	} t[SIZE];

	int pos[SIZE], cnt[SIZE];

	vector<int> go[SIZE];
	int net[SIZE][26];

	int extend(int c) {
		int p = Last,
			np = Last = ++ cT;

		s[pos[np] = ++ strL] = c;
		cnt[np] ++;

		t[np].maxl = t[p].maxl + 1;

		for (; p && t[p].trans[c] == 0; p = t[p].link) t[p].trans[c] = np;

		if (!p) {
			t[np].link = 1;
		} else {
			int q = t[p].trans[c];

			if (t[q].maxl == t[p].maxl + 1) {
				t[np].link = q;
			} else {
				int nq = ++ cT;

				t[nq] = t[q], t[nq].maxl = t[p].maxl + 1, pos[nq] = pos[q];
				t[np].link = t[q].link = nq;
				for (; p && t[p].trans[c] == q; p = t[p].link) t[p].trans[c] = nq;
			}
		}

		return np;
	}

	void scout(int u) {
		for (int v : go[u]) {
			net[u][s[pos[v] - t[u].maxl]] = v;
			scout(v);
			cnt[u] += cnt[v];
		}
	}

	void build() {
		for (int u = 2; u <= cT; u ++) go[t[u].link].push_back(u);
		scout(1);
	}

	int tag[SIZE];

	void remake() {
		for (int i = 1; i <= cT; i ++) tag[i] = 0;
	}

	void mark(int u, int fu, int p, int curL) {
		if (curL == t[p].maxl) p = net[p][a[u] - 'a'];
		else if (s[pos[p] - curL] != a[u] - 'a') p = 0;

		if (p == 0) return;

		tag[p] ++;

		for (int i = head[u]; i; i = Next[i]) {
			int v = ver[i];
			if (v == fu || ban[v]) continue;
			mark(v, u, p, curL + 1);
		}
	}

	void spread(int u) {
		tag[u] += tag[t[u].link];
		for (int v : go[u]) spread(v);
	}
} A, B;

int posA[N], posB[N];

long long ans;

void path_calc(int u, int fu, int p, int opt) {
	p = A.t[p].trans[a[u] - 'a'];
	if (p == 0) return;

	ans += opt * A.cnt[p];

	for (int i = head[u]; i; i = Next[i]) {
		int v = ver[i];
		if (v == fu || ban[v]) continue;
		path_calc(v, u, p, opt);
	}
}

void work_sm(int u, int fu) {
	path_calc(u, 0, 1, 1);

	for (int i = head[u]; i; i = Next[i]) {
		int v = ver[i];
		if (v == fu || ban[v]) continue;
		work_sm(v, u);
	}
}

void work_bg(int u, int fu, int opt) {
	A.remake(), B.remake();

	if (fu == 0)
		A.mark(u, 0, 1, 0),
		B.mark(u, 0, 1, 0);
	else
		A.mark(u, fu, A.t[1].trans[a[fu] - 'a'], 1),
		B.mark(u, fu, B.t[1].trans[a[fu] - 'a'], 1);

	A.spread(1), B.spread(1);

	for (int i = 1; i <= m; i ++) ans += 1ll * opt * A.tag[posA[i]] * B.tag[posB[i]];
}

int A_son;
void plus_bg(int u, int fu, int p, int curL) {
	if (curL == A.t[p].maxl) p = A.net[p][a[u] - 'a'];
	else if (tex[A.pos[p] - curL] != a[u]) p = 0;

	if (p == 0) return;

	path_calc(A_son, A_rt, p, -1);

	for (int i = head[u]; i; i = Next[i]) {
		int v = ver[i];
		if (v == fu || ban[v]) continue;
		plus_bg(v, u, p, curL + 1);
	}
}

void solve(int u) {
	if (A_sz <= Bn) {
		work_sm(u, 0);

		ban[u] = 1;
		return;
	} else {
		work_bg(u, 0, 1);

		for (int i = head[u]; i; i = Next[i]) {
			int v = ver[i];
			if (ban[v]) continue;

			temp_sz[v] = Get_sz(v, u);

			if (temp_sz[v] <= Bn) {
				A_son = v;
				plus_bg(v, u, A.t[1].trans[a[u] - 'a'], 1);
			} else {
				work_bg(v, u, -1);
			}
		}

		ban[u] = 1;
	}

	for (int i = head[u]; i; i = Next[i]) {
		int v = ver[i];
		if (ban[v]) continue;

		A_sz = temp_sz[v], A_rt = 0;
		Get_rt(v, 0), solve(A_rt);
	}
}

int main() {
	read(n), read(m), Bn = 1200;

	for (int i = 1, u, v; i < n; i ++) {
		read(u), read(v);
		add_edge(u, v), add_edge(v, u);
	}

	scanf("%s", a + 1);
	scanf("%s", tex + 1);

	for (int i = 1; i <= m; i ++) posA[i] = A.extend(tex[i] - 'a');
	A.build();

	for (int i = m; i >= 1; i --) posB[i] = B.extend(tex[i] - 'a');
	B.build();

	A_sz = n, A_rt = 0;
	Get_rt(1, 0), solve(A_rt);

	printf("%lld\n", ans);

	return 0;
}
```

---

## 作者：lhm_ (赞：5)

首先对特征字符串建 $SAM$，来实现对子串的匹配。

有一个 $O(n^2)$ 的暴力，分别以每个点为根进行 $dfs$，遍历树时记录当前字符串在 $SAM$ 上匹配到的节点即可。

考虑用点分治来解决本题这样的树上路径统计问题。对于当前的分治重心 $x$，统计连通块中经过 $x$ 的路径的贡献。经过 $x$ 的路径拆分为 $x$ 子树内一个点到 $x$ 的路径和 $x$ 到 $x$ 子树内一个点的路径。因为 $SAM$ 可以用 $endpos$ 统计以 $x$ 所对应的字符结束的子串，所以对特征字符串的反串也建出 $SAM$，把第二种路径也转化为第一种路径来便于统计。

从 $x$ 出发 $dfs$ 统计路径时，到达一个节点后要往当前字符串前端加入该节点所对应的字符，直接用 $SAM$ 是无法处理匹配的。发现在 $SAM$ 对应的 $Parent$ 树上，一个点到其儿子节点，就是在其对应的子串前端加入字符，所以可以处理出 $Parent$ 树上每个点加入字符后对应的儿子节点，这样就可以通过 $Parent$ 树来实现前端加入字符来匹配了。这里其实就是建出了后缀树。

两条路径对应的字符串要保证是在特征字符串上是相邻的，因此在 $Parent$ 树上打标记，统计时遍历整棵 $Parent$ 树来使标记下放到儿子，对于特征字符串的每个位置，两种路径的方案相乘来贡献答案。

直接点分治的复杂度是 $O(n \log n + nm)$ 的，仍然无法接受，考虑结合 $O(n^2)$ 的暴力进行根号分治。点分治时，连通块大小 $\leqslant \sqrt n$  时采取 $O(n^2)$ 暴力，大小 $> \sqrt n$ 时采取统计路径贡献。

对这种方法来进行复杂度分析。连通块大小 $\leqslant \sqrt n$  的情况复杂度为 $O(n \sqrt n)$。考虑点分治进行到第 $k$ 层时，最大的连通块大小为 $\frac{n}{2^k}$，连通块个数为 $2^k$，若限制连通块大小最小为 $\sqrt n$，连通块个数的级别就为 $\sqrt n$ 了，所以连通块大小 $> \sqrt n$  的情况复杂度为 $O(m \sqrt n)$。得总复杂度为 $O((n+m) \sqrt n)$。

注意统计路径贡献时还需容斥，减去两条路径来自同一个子树的情况。容斥时也需要对每个儿子进行根号分治来保证复杂度。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 100010
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,S,root,tot,goal,rt;
ll ans;
int siz[maxn],ma[maxn];
bool vis[maxn];
char c[maxn],s[maxn];
struct edge
{
    int to,nxt;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to)
{
    e[++edge_cnt]=(edge){to,head[from]};
    head[from]=edge_cnt;
}
struct SAM
{
    int tot=1,root=1,las=1;
    int fa[maxn],ch[maxn][30],son[maxn][30],len[maxn],siz[maxn],pos[maxn],bel[maxn];
    ll tag[maxn];
    char s[maxn];
    vector<int> ve[maxn];
    void insert(int c,int id)
    {
        int p=las,np=las=++tot;
        len[np]=len[p]+1,siz[np]=1,pos[np]=id,bel[id]=np;
        while(p&&!ch[p][c]) ch[p][c]=np,p=fa[p];
        if(!p) fa[np]=root;
        else
        {
            int q=ch[p][c];
            if(len[q]==len[p]+1) fa[np]=q;
            else
            {
                int nq=++tot;
                memcpy(ch[nq],ch[q],sizeof(ch[q]));
                len[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;
                while(ch[p][c]==q) ch[p][c]=nq,p=fa[p];
            }
        }
    }
    void dfs(int x)
    {
        for(int i=0;i<ve[x].size();++i)
        {
            int y=ve[x][i];
            dfs(y),siz[x]+=siz[y];
            pos[x]=pos[y],son[x][s[pos[y]-len[x]]]=y;
        }
    }
    void build()
    {
        for(int i=1;i<=m;++i) insert(s[i],i);
        for(int i=2;i<=tot;++i) ve[fa[i]].push_back(i);
        dfs(root);
    }
    void match(int x,int fa,int p,int lenth)
    {
        if(lenth==len[p]) p=son[p][c[x]];
        else if(s[pos[p]-lenth]!=c[x]) p=0;
        if(!p) return;
        tag[p]++;
        for(int i=head[x];i;i=e[i].nxt)
        {
            int y=e[i].to;
            if(vis[y]||y==fa) continue;
            match(y,x,p,lenth+1);
        }
    }
    void update(int x)
    {
        for(int i=0;i<ve[x].size();++i)
            tag[ve[x][i]]+=tag[x],update(ve[x][i]);
    }
    void clear()
    {
        for(int i=1;i<=tot;++i) tag[i]=0;
    }
}A,B;
void dfs_root(int x,int fa)
{
    siz[x]=1,ma[x]=0;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(vis[y]||y==fa) continue;
        dfs_root(y,x),siz[x]+=siz[y];
        ma[x]=max(ma[x],siz[y]);
    }
    ma[x]=max(ma[x],tot-siz[x]);
    if(ma[x]<ma[root]) root=x;
}
void dfs_get(int x,int fa,int p,int type)
{
    p=A.ch[p][c[x]];
    if(!p) return;
    ans+=A.siz[p]*type;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(vis[y]||y==fa) continue;
        dfs_get(y,x,p,type);
    }
}
void dfs_del(int x,int fa,int p)
{
	if(x!=goal) p=A.ch[p][c[x]];
    else
    {
        p=A.ch[p][c[x]],p=A.ch[p][c[rt]];
        if(p) dfs_get(x,0,p,-1);
        return;
    }
    if(!p) return;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(vis[y]||y==fa) continue;
        dfs_del(y,x,p);
    }
}
void dfs_find(int x,int fa,int type)
{
	if(type) dfs_get(x,0,1,1);
	else dfs_del(x,0,1);
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(vis[y]||y==fa) continue;
        dfs_find(y,x,type);
    }
}
void calc(int x,int fa)
{
    A.clear(),B.clear();
    if(!fa) A.match(x,fa,1,0),B.match(x,fa,1,0);
    else A.match(x,fa,A.ch[1][c[fa]],1),B.match(x,fa,B.ch[1][c[fa]],1);
    A.update(1),B.update(1);
    for(int i=1;i<=m;++i)
	{
		if(!fa) ans+=A.tag[A.bel[i]]*B.tag[B.bel[m-i+1]];
		else ans-=A.tag[A.bel[i]]*B.tag[B.bel[m-i+1]];
	}
}
void solve(int x)
{
    if(tot<=S)
    {
        dfs_find(x,0,1);
        return;
    }
    int now=tot;
    vis[x]=true,calc(x,0);
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(vis[y]) continue;
        root=0,tot=siz[y];
        if(siz[y]>siz[x]) tot=now-siz[x];
		if(tot<=S) rt=x,goal=y,dfs_find(y,x,0);
		else calc(y,x);
        dfs_root(y,x),solve(root);
    }
} 
int main()
{
    read(n),read(m),S=sqrt(n);
    for(int i=1;i<n;++i)
    {
        int x,y;
        read(x),read(y);
        add(x,y),add(y,x);
    }
    scanf("%s%s",c+1,s+1);
    for(int i=1;i<=n;++i) c[i]-='a';
    for(int i=1;i<=m;++i) s[i]-='a',A.s[i]=s[i],B.s[m-i+1]=s[i];
    A.build(),B.build(),tot=ma[0]=n,dfs_root(1,0),solve(root);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：ywy_c_asm (赞：5)

假如你对后缀树很熟悉的话这题基本上就能秒了，否则……可能需要稍微理解+写上几个小时……~~因为后缀树这玩意太自闭了……~~

首先，对于路径的统计我们可以想到点分治，然后既然是点分治，设重心为$x$，我们就要考虑形如$u->x->v$的路径，这个看上去相当的不可做，你需要保证$u->x$这个串在$s$中的出现位置正好接在$x->v$之前，很难用SAM处理。

那么我们可以把这个转化一下，对于$s$中的每个位置$i$，我们要求出$begin[i]$为在树上有多少$x->v$的串满足这个串是$i$**后缀的前缀**，$end[i]$为在树上有多少$u->x$的串满足这个串是$i$**前缀的后缀**，显然答案就是$\sum_ibegin[i]*end[i]$，然后我们还要减去u和v在同一个子树里的情况。

其实我们只需要考虑$begin[i]$因为$end[i]$就是把串倒过来的$begin[i]$，对于这种东西最直观的处理方式就是从$x$开始维护一个SAM上的指针$cur$不断地走，然而我们要对所有可行的左端点进行统计，那么既然是左端点我们不妨**对每个后缀统计有多少串当过他的前缀**，这咋做？

然后有个东西叫做后缀树，就是把一个串的所有后缀暴力插到trie里，咦，既然它是个Trie，我们直接在后缀树上从上到下走不就行了？我们每走到一个点就打个标记，最后再对后缀树dfs推一遍标记，然后对每个后缀看他后缀树上对应节点有几个标记就行了。

显然咱们不能暴力建trie的后缀树，有个广为人知的结论是后缀树等价于反串的parent树，因为parent树的祖先后代关系是有相同后缀的子串或者前缀，后缀树的祖先后代关系是有相同前缀的子串或者后缀，这不正好反过来？那么这样的话每条边都对应了一个子串，我们把这个点到根的路径上边表示的串一连接就成了这个点对应的后缀或子串。我们考虑如何用parent树完成到后缀树的转化，对反串的parent树随便找个right，显然一条$(u,v)$的边在**反串**上对应的子串长度为$len[v]-len[u]$，它对应的区间右端点是$right[v]-len[u]$，注意实际的后缀树上还要反过来，然后我们为了能够完美的在后缀树上从上到下走，需要把这个重构成一棵Trie，但这棵Trie只对应边上的第一个字符，我们在不断添加字符的时候需要维护一个指针在边对应的串上移动，注意不能直接跳点，并且每次都要在上面打标记。

（如果你对这个一脸懵逼的话……其实画棵后缀树就都明白了……

~~（另外另一篇题解的本质其实就是建了个后缀树……~~

然后我们发现一个问题，这样单次复杂度是$O(size+m)$的，并不是正确的点分治的均摊复杂度，总体上是$O(nm+nlogn)$的……

其实这个根号分治一下就行了……

我们考虑一个简单的$O(n^2)$暴力是对s建个SAM然后以每个点为起点暴力跑SAM匹配，然后当$size<=\sqrt n$的时候直接用这个暴力，$size>\sqrt m$的时候用后缀树$O(m)$做，复杂度是$O((n+m)\sqrt n)$的，对，不带log。

这个复杂度可以类比链上的证明，分治的时候会分成$O(n)$个区间，换句话说是2*分治树上的叶子个数即n，当$size<=\sqrt n$时可以直接$O(size^2)$暴力，显然暴力复杂度是$O(n\sqrt n)$的，然后考虑使用后缀树的$size>\sqrt n$的区间，显然分治树上的叶子大小至少是$\sqrt n$的所以有$O(\sqrt n)$个这样的区间，所以，使用后缀树的复杂度是$O(m\sqrt n+nlogn)$，总复杂度就是$O((n+m)\sqrt n)$。

~~我好像块大小设的$\sqrt m$啊……算了不管了~~

上代码~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define ll long long
using namespace std;
namespace ywy {
	inline int get() {
	    int n = 0;
	    char c;
	    while ((c = getchar()) || 23333)
	        if (c >= '0' && c <= '9')
	            break;
	    n = c - '0';
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 + c - '0';
	        else
	            return (n);
	    }
	}
	int blo;
	typedef struct _b {
	    int dest;
	    int nxt;
	} bian;
	bian memchi[2000001];
	int gn = 1;
	typedef struct _SAM {
	    int sam[200001][26], len[200001], fa[200001], size[200001], gsam;
	    _SAM() { gsam = 2; }
	    int heads[200001];
	    inline int zhuanyi(int p, int x) {
	        int me = gsam;
	        gsam++;
	        len[me] = len[p] + 1;
	        size[me] = 1;
	        while (p && !sam[p][x]) sam[p][x] = me, p = fa[p];
	        if (!p) {
	            fa[me] = 1;
	            return (me);
	        }
	        int q = sam[p][x];
	        if (len[q] == len[p] + 1) {
	            fa[me] = q;
	            return (me);
	        }
	        int nq = gsam;
	        gsam++;
	        len[nq] = len[p] + 1;
	        fa[nq] = fa[q];
	        fa[q] = fa[me] = nq;
	        for (register int i = 0; i < 26; i++) sam[nq][i] = sam[q][i];
	        while (p && sam[p][x] == q) sam[p][x] = nq, p = fa[p];
	        return (me);
	    }
	    int pos[100001];
	    int tag[200001], right[200001], trie[200001][26];
	    char str[200001];
	    inline void build(int n) {
	        int p = 1;
	        for (register int i = 1; i <= n; i++) p = zhuanyi(p, str[i] - 'a'), right[p] = i, pos[i] = p;
	        for (register int i = 2; i < gsam; i++) {
	            memchi[gn].dest = i;
	            memchi[gn].nxt = heads[fa[i]];
	            heads[fa[i]] = gn;
	            gn++;
	        }
	    }
	    inline void clear() {
	        for (register int i = 1; i < gsam; i++) tag[i] = 0;
	    }
	    void dfs(int pt) {
	        for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	            dfs(memchi[i].dest);
	            size[pt] += size[memchi[i].dest];
	            right[pt] = max(right[pt], right[memchi[i].dest]);
	            trie[pt][str[right[memchi[i].dest] - len[pt]] - 'a'] = memchi[i].dest;
	        }
	    }
	    void efs(int pt) {
	        for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	            tag[memchi[i].dest] += tag[pt];
	            efs(memchi[i].dest);
	        }
	    }
	} SAM;
	SAM zheng, fan;
	int heads[100001];
	inline void add(int s, int t) {
	    memchi[gn].dest = t;
	    memchi[gn].nxt = heads[s];
	    heads[s] = gn;
	    gn++;
	}
	int tot, zx, size[100001];
	unsigned char bv[100001];
	int xl[100001], ptr;
	int fun[100001];
	void afs(int pt, int baba) {
	    tot++;
	    xl[ptr] = pt;
	    ptr++;
	    fun[pt] = baba;
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	        if (memchi[i].dest == baba || bv[memchi[i].dest])
	            continue;
	        afs(memchi[i].dest, pt);
	    }
	}
	void bfs(int pt, int baba) {
	    size[pt] = 1;
	    int mx = 0;
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	        if (memchi[i].dest == baba || bv[memchi[i].dest])
	            continue;
	        bfs(memchi[i].dest, pt);
	        mx = max(mx, size[memchi[i].dest]);
	        size[pt] += size[memchi[i].dest];
	    }
	    if (max(mx, tot - size[pt]) <= tot / 2)
	        zx = pt;
	}
	ll ans = 0;
	char str[100001], strrev[100001], chs[100001];
	int m;
	void cfs(int pt, int baba, int p) {  //暴力
	    p = zheng.sam[p][chs[pt] - 'a'];
	    if (!p)
	        return;
	    ans += zheng.size[p];
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	        if (memchi[i].dest == baba || bv[memchi[i].dest])
	            continue;
	        cfs(memchi[i].dest, pt, p);
	    }
	}
	void kaitou(int pt, int baba, int pos, int p) {  // p是还未到达的点
	    if (!p)
	        return;
	    if (strrev[fan.right[p] - fan.len[fan.fa[p]] - pos] != chs[pt])
	        return;
	    pos++;
	    fan.tag[p]++;
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	        if (memchi[i].dest == baba || bv[memchi[i].dest])
	            continue;
	        if (pos == fan.len[p] - fan.len[fan.fa[p]])
	            kaitou(memchi[i].dest, pt, 0, fan.trie[p][chs[memchi[i].dest] - 'a']);
	        else
	            kaitou(memchi[i].dest, pt, pos, p);
	    }
	}
	void jiewei(int pt, int baba, int pos, int p) {
	    if (!p)
	        return;
	    if (str[zheng.right[p] - zheng.len[zheng.fa[p]] - pos] != chs[pt])
	        return;
	    pos++;
	    zheng.tag[p]++;
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	        if (memchi[i].dest == baba || bv[memchi[i].dest])
	            continue;
	        if (pos == zheng.len[p] - zheng.len[zheng.fa[p]])
	            jiewei(memchi[i].dest, pt, 0, zheng.trie[p][chs[memchi[i].dest] - 'a']);
	        else
	            jiewei(memchi[i].dest, pt, pos, p);
	    }
	}
	int pam[100001];
	void ffs(int pt, int baba, int p) {
	    p = zheng.sam[p][chs[pt] - 'a'];
	    if (!p)
	        return;
	    ans -= zheng.size[p];
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	        if (memchi[i].dest == baba || bv[memchi[i].dest])
	            continue;
	        ffs(memchi[i].dest, pt, p);
	    }
	}
	void digui(int pt, int baba) {
	    tot = 0;
	    ptr = 1;
	    afs(pt, 0);
	    if (tot <= blo) {
	        if (baba) {
	            for (register int i = 1; i < ptr; i++) {
	                int me = xl[i];
	                int cur = 1;
	                while (me) {
	                    cur = zheng.sam[cur][chs[me] - 'a'];
	                    me = fun[me];
	                }
	                pam[xl[i]] = zheng.sam[cur][chs[baba] - 'a'];
	                ffs(pt, 0, pam[xl[i]]);
	            }
	        }
	        for (register int i = 1; i < ptr; i++) cfs(xl[i], 0, 1);
	        return;
	    }
	    int fdd = fan.trie[1][chs[baba] - 'a'];
	    if (fdd) {
	        int pos = 1;
	        if (fan.len[fdd] == 1) {
	            fdd = fan.trie[fdd][chs[pt] - 'a'];
	            pos = 0;
	        }
	        kaitou(pt, 0, pos, fdd);
	    }
	    fdd = zheng.trie[1][chs[baba] - 'a'];
	    if (fdd) {
	        int pos = 1;
	        if (zheng.len[fdd] == 1) {
	            fdd = zheng.trie[fdd][chs[pt] - 'a'];
	            pos = 0;
	        }
	        jiewei(pt, 0, pos, fdd);
	    }
	    zheng.efs(1);
	    fan.efs(1);
	    for (register int i = 1; i <= m; i++) {
	        ll begin = zheng.tag[zheng.pos[i]], end = fan.tag[fan.pos[m - i + 1]];
	        ans -= begin * end;
	    }
	    zheng.clear();
	    fan.clear();
	    bfs(pt, 0);
	    int me = zx;
	    kaitou(me, 0, 0, fan.trie[1][chs[me] - 'a']);
	    jiewei(me, 0, 0, zheng.trie[1][chs[me] - 'a']);
	    zheng.efs(1);
	    fan.efs(1);
	    for (register int i = 1; i <= m; i++) {
	        ll begin = zheng.tag[zheng.pos[i]], end = fan.tag[fan.pos[m - i + 1]];
	        ans += begin * end;
	    }
	    zheng.clear();
	    fan.clear();
	    bv[me] = 1;
	    for (register int i = heads[me]; i; i = memchi[i].nxt) {
	        if (bv[memchi[i].dest])
	            continue;
	        digui(memchi[i].dest, me);
	    }
	}
	void ywymain() {
	    int n = get();
	    m = get();
	    blo = sqrt(m);
	    for (register int i = 1; i < n; i++) {
	        int s = get(), t = get();
	        add(s, t);
	        add(t, s);
	    }
	    scanf("%s", chs + 1);
	    scanf("%s", str + 1);
	    memcpy(strrev, str, sizeof(str));
	    reverse(strrev + 1, strrev + 1 + m);
	    for (register int i = 1; i <= m; i++) zheng.str[i] = str[i], fan.str[i] = strrev[i];
	    zheng.build(m);
	    fan.build(m);
	    zheng.dfs(1);
	    fan.dfs(1);
	    digui(1, 0);
	    cout << ans << endl;
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：Hyscere (赞：3)

~~先来一发广告：~~[https://www.cnblogs.com/hbyer/p/10456260.html](https://www.cnblogs.com/hbyer/p/10456260.html)

点分治+后缀自动机。

先考虑暴力，有一个很显然的$O(n^2)$的暴力：

- 枚举每个点作为起点，$dfs$另一个点，$dfs$的同时在特征字符串$S$的$SAM$上跑，顺便统计答案就好了。
- 这个在$SAM$上跑实际上就相当于每次在一个已经匹配了的串后面加一个字符，那么直接沿着$SAM$的转换边走就好了。

换个角度思考，还有另一种暴力：

- 枚举一个点$x$，统计出每条以这个点为$lca$的路径的代价。
- 考虑这个看起来高级一点的暴力怎么做，
- 对于点$x$，路径肯定是$a\to x \to b$的形式，那么我们把他拆成两段$a\to x$和$x \to b$，注意到如果我们把特征字符串反过来，那么这两种其实就是一样的，所以我们现在考虑$a \to x$怎么统计，然后在翻转过的$S$上再做一遍就好了。
- 那么我们就是要统计出对于自动机上的点$i$，有多少以$x$结尾的路径字符串在这个点。
- 那么问题就相当于当前已经匹配了一个串，要在这个串前面加一个字符，那么沿着$parent$树跳就好了。
- 最后答案就是对于字符串上每个点，这个点开始和这个点结束的方案之积 的和。

注意到第二种暴力可以用点分治优化，那么第二种暴力的复杂度就是$O(n\log n+nm)$。

考虑如何把后面一项优化一下，注意到第一种方案是不需要每次都扫一遍自动机的，所以可以在点分治的时候设一个阀值$B$，若$size>B$就用第二种，否则用第一种。

可以发现当$B=\sqrt{n}$的时候复杂度最优，此时时间复杂度为$O((n+m)\sqrt{n})$。


```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long 

void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(ll x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(ll x) {if(!x) putchar('0');else print(x);putchar('\n');}

const int maxn = 2e5+10;
const int inf = 1e9;

ll ans;
char s[maxn];
int n,m,rt,siz,B,top;
int head[maxn],tot,a[maxn];
int vis[maxn],f[maxn],sz[maxn],tmp[maxn],t[maxn];
struct edge{int to,nxt;}e[maxn<<1];

void ins(int u,int v) {e[++tot]=(edge){v,head[u]},head[u]=tot;}

struct Suffix_Automaton {
	int cnt,qs,lstp;
	int par[maxn],tr[maxn][26],ml[maxn],pos[maxn],sz[maxn];
	int t[maxn],r[maxn],son[maxn][26],str[maxn],tag[maxn],rev[maxn];

	void append(int x,int v) {
		int p=lstp,np=++cnt;pos[np]=v,sz[np]=1,ml[np]=ml[p]+1,rev[v]=np;lstp=np;
		for(;p&&tr[p][x]==0;p=par[p]) tr[p][x]=np;
		if(!p) return par[np]=qs,void();
		int q=tr[p][x];
		if(ml[p]+1<ml[q]) {
			int nq=++cnt;ml[nq]=ml[p]+1;
			memcpy(tr[nq],tr[q],sizeof tr[nq]);
			par[nq]=par[q],par[q]=par[np]=nq;
			for(;p&&tr[p][x]==q;p=par[p]) tr[p][x]=nq;
		} else par[np]=q;
	}

	void prepare(char *ss) {
		lstp=qs=cnt=1;
		for(int i=1;i<=m;i++) append(str[i]=ss[i]-'a',i);

		for(int i=1;i<=cnt;i++) t[ml[i]]++;
		for(int i=1;i<=m;i++) t[i]+=t[i-1];
		for(int i=1;i<=cnt;i++) r[t[ml[i]]--]=i;

		for(int i=cnt;i;i--) {
			int p=r[i];
			sz[par[p]]+=sz[p];
			if(!pos[par[p]]) pos[par[p]]=pos[p];
			son[par[p]][str[pos[p]-ml[par[p]]]]=p;
		}
	}

	void mark(int x,int fa,int now,int len) {
		if(len==ml[now]) now=son[now][a[x]];
		else if(str[pos[now]-len]!=a[x]) now=0;
		if(!now) return ;len++;tag[now]++;
		for(int i=head[x];i;i=e[i].nxt)
			if(e[i].to!=fa&&!vis[e[i].to]) mark(e[i].to,x,now,len);
	}

	void push() {for(int i=1;i<=cnt;i++) tag[r[i]]+=tag[par[r[i]]];}
}sam1,sam2;

void get_rt(int x,int fa) {
	sz[x]=1,f[x]=0;
	for(int i=head[x];i;i=e[i].nxt)
		if(e[i].to!=fa&&!vis[e[i].to]) 
			get_rt(e[i].to,x),sz[x]+=sz[e[i].to],f[x]=max(f[x],sz[e[i].to]);
	f[x]=max(f[x],siz-sz[x]);
	if(f[x]<f[rt]) rt=x;
}

void get_node(int x,int fa) {
	t[++top]=x;
	for(int i=head[x];i;i=e[i].nxt)
		if(e[i].to!=fa&&!vis[e[i].to]) get_node(e[i].to,x);
}

void dfs(int x,int fa,int now) {
	now=sam1.tr[now][a[x]];
	if(!now) return ;
	ans+=sam1.sz[now];
	for(int i=head[x];i;i=e[i].nxt)
		if(e[i].to!=fa&&!vis[e[i].to]) dfs(e[i].to,x,now);
}

void work(int x,int fa,int op) {
	memset(sam1.tag,0,(sam1.cnt+2)*4);
	memset(sam2.tag,0,(sam2.cnt+2)*4);
	if(fa) sam1.mark(x,fa,sam1.tr[1][a[fa]],1),sam2.mark(x,fa,sam2.tr[1][a[fa]],1);
	else sam1.mark(x,fa,1,0),sam2.mark(x,fa,1,0);
	sam1.push(),sam2.push();
	for(int i=1;i<=m;i++) ans+=1ll*op*sam1.tag[sam1.rev[i]]*sam2.tag[sam2.rev[m-i+1]];
}

void solve(int x) {
	get_rt(x,0);siz=sz[x];
	if(siz<=B) {
		top=0,get_node(x,0);
		for(int i=1;i<=top;i++) dfs(t[i],0,sam1.qs);
		for(int i=1;i<=top;i++) vis[t[i]]=0;
		return ;
	}
	for(int i=head[x];i;i=e[i].nxt) tmp[e[i].to]=sz[e[i].to];
	work(x,0,1);
	for(int i=head[x];i;i=e[i].nxt) if(!vis[e[i].to]) work(e[i].to,x,-1);
	vis[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
		if(!vis[e[i].to]) siz=tmp[e[i].to],rt=0,get_rt(e[i].to,x),solve(rt);
}

int main() {
	read(n),read(m);B=sqrt(n);
	for(int i=1,x,y;i<n;i++) read(x),read(y),ins(x,y),ins(y,x);
	scanf("%s",s+1);
	for(int i=1;i<=n;i++) a[i]=s[i]-'a';
	scanf("%s",s+1);
	sam1.prepare(s);
	reverse(s+1,s+m+1);
	sam2.prepare(s);
	siz=n,f[0]=inf,get_rt(1,0),solve(rt);write(ans);
	return 0;
}
```

---

## 作者：Lyrella (赞：1)

# 题解

考虑暴力怎么做？我们枚举树上的点作为起点，然后在 $\text{dfs}$ 的过程中同时在 $\text{SAM}$ 上 走。如果 $\text{SAM}$ 上走不下去就说明串已经不在 $S$ 中，否则就加上 $\text{SAM}$ 上当前状态的 $\text{endpos}$ 集合大小。这样是 $O(n^2)$ 的。

考虑我们要统计树上所有的路径于是点分治启动！若当前分治中心为 $u$，我们需要统计出跨过 $u$ 的答案。串从分治中心分成两个部分，相当于要求出这两个串在原串中在一起的方案数。这两个东西显然独立，我们设 $f_i$ 表示有多少个一个点到根的字符串以 $i$ 结尾，设 $g_i$ 表示有多少个一个点到根的字符串以 $i$ 开头，答案为 $\sum\limits_{i=1}^mf_i\times g_i$。

对 $g$ 的处理相当于是在反串上处理 $f$，所以只考虑 $f$。求 $f$ 的过程还是 $\text{dfs}$，只是每次我们**在原来的字符串前面加字符**，然后这个位置对应 $\text{SAM}$ 上的点的 $\text{cnt}$ 就加一。因为 $\text{SAM}$ 上的点相对其子树是一个后缀，所以 $\text{dfs}$ 结束后还要在 $\text{SAM}$ 上 $\text{dfs}$ 一遍将 $\text{cnt}$ 下放。现在先讲怎么处理**在原来的字符串前面加字符**。

假设现在在 $u$，我们需要往当前串的前面加入 $c$，此时要分两种情况讨论。因为一个点代表了若干的串，而我们对一个点只记录了 $\text{maxlen}$，所以要讨论字符串长度与其的关系：

1. 当前串长等于 $\text{maxlen}$，说明我再往前加一个字符就会跳到其他点，我们就需要找一个点 $v$ 满足 $fa_v=u$ 且 $S[\text{rpos}_v-\text{len}_u]=c$，其中 $\text{rpos}_v$ 表示 $v$ 的 $\text{endpos}$ 中任意一点（任一点都是等价的）。如果有就能够跳，否则新串就不是 $S$ 的子串了。
2. 如果当前串长小于 $\text{maxlen}$，我们就看 $S[\text{rpos}_u-|T|]$ 是否等于 $c$，其中 $T$ 为原串，$|T|$ 表示其长度。如果不等于就说明新串就不是 $S$ 的子串，否则不变。

我们对所有的情况一都预处理出来，存在 $\text{son}$ 中即可。

最后还要讲一下容斥。就是说我们的 $f$ 和 $g$ 的贡献有都来自同一个子树的，我们需要减去这部分贡献。具体的，我们去枚举 $u$ 的每个子树 $v$，正常计算答案即可。只不过我们处理的时候**已经确定了最开始两个字符**（也就是 $u,v$ 对应的字符）所以要在 $\text{SAM}$ 上先走一步。

分治加上遍历树是 $O(n\log n)$，但是每次我们统计答案的时候都枚举了 $m$，所以还有一个 $O(nm)$，这样我们的复杂度成功劣于 $O(n^2)$ 暴力。

因为在 $n$ 很小的时候暴力更优秀，而 $n$ 较大的时候点分治更好，所以我们把两个算法结合一下，我们分治的时候判一下当前分治部分的大小，如果小于 $B$ 就跑暴力，否则正常点分治。其中 $B$ 的设定是根号级别的，~~复杂度我不太会证只会感性理解~~现在再次分析复杂度。

# 时间复杂度

我们知道每次分治点数会减半，考虑第 $k$ 层区间能用暴力计算，用暴力计算的区间有 $\le\sqrt n$ 个，所以暴力带来的总复杂为 $O(n\sqrt n)$，而上面的 $k-1$ 层一共 $O(\sqrt n)$ 个区间，所以分治的复杂度为 $O(m\sqrt  n+n\log n)$。

最后要注意的就是容斥的时候也要考虑根号分治，否则如果图是菊花图就 T 飞了。

# 代码实现细节

因为代码太长就讲一下实现。因为要维护 $f$ 和 $g$ 所以我们需要两个 $\text{SAM}$，于是就写成结构体的形式。注意每个 $\text{SAM}$ 都要对 $\text{parent tree}$ 建边，所以**存边的东西要放在结构体内部**！

然后就是普通的暴力和容斥的暴力应该怎么写。普通的暴力就是外层一个 $\text{dfs}$ 去遍历所有起点，内层的就是从一个起点开始**不停往后加字符**；但是在写容斥的暴力的时候，我们一定要明白我们需要做什么？我们要把前缀和后缀在同一个子树内的贡献减去。也就是需要找到所有形如 $T1a_va_ua_vT2$ 的字符串，其中 $a$ 为树上的点对应的字符，$T1,T2$ 是任意的子串。所以我们外层搜索的时候就有了限制，我们考虑固定两个点然后去搜索，每次内层统计答案的时候就固定从 $v$ 开始算答案。这段有些抽象，可结合代码理解。然后分治做法就类比即可。

# 代码

```cpp
/*
 * @Author: Nekopedia 
 * @Date: 2025-05-12 14:24:26 
 * @Last Modified by: Nekopedia
 * @Last Modified time: 2025-05-12 18:21:50
 */
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e5 + 5, inf = 1e9;
const ll INF = 2e18;

int hd[N], cnt, n, m, sn;
struct edge{int nxt, to;}e[N];
inline void add(int u, int v){e[++cnt] = {hd[u], v}; hd[u] = cnt;}
char s1[N], s2[N], a[N];
ll ans;
int rt, mi = inf, sz[N], sum[N];
bitset < N > tg;

struct sam{
    vector < int > g[N];
    int ch[N][26], fa[N], son[N][26], len[N], sz[N], pos[N], rp[N];
    int tot, ep, s[N];
    ll cnt[N];
    sam(){tot = ep = 1;}
    inline void clr(){for(int i = 1; i <= tot; ++i)cnt[i] = 0;}
    void ins(int c){
        int u = ep; ep = ++tot;
        rp[ep] = len[ep] = len[u] + 1; sz[ep] = 1;
        for(; u and ! ch[u][c]; u = fa[u])ch[u][c] = ep;
        if(! u)return fa[ep] = 1, void();
        int v = ch[u][c];
        if(len[u] + 1 == len[v])return fa[ep] = v, void();
        int x = ++tot; len[x] = len[u] + 1;
        fa[x] = fa[v]; fa[v] = fa[ep] = x;
        for(int i = 0; i < 26; ++i)ch[x][i] = ch[v][i];
        for(; u and ch[u][c] == v; u = fa[u])ch[u][c] = x;
    }
    void dfs(int u){
        for(int v : g[u]){
            dfs(v);
            sz[u] += sz[v]; rp[u] = rp[v];
            son[u][s[rp[v] - len[u]]] = v;
        }
    }
    void init(){
        for(int i = 1; i <= m; ++i)ins(s[i]), pos[i] = ep;
        for(int i = 2; i <= tot; ++i)g[fa[i]].push_back(i);
        dfs(1);
    }
    void upd(int u, int ff, int p, int l){
        if(len[p] == l)p = son[p][a[u] - 'a'];
        else if(s[rp[p] - l] ^ (a[u] - 'a'))p = 0;
        if(! p)return; ++cnt[p];
        for(int i = hd[u]; i; i = e[i].nxt){
            int v = e[i].to; if(v == ff or tg[v])continue;
            upd(v, u, p, l + 1);
        }
    }
    void pd(int u){cnt[u] += cnt[fa[u]]; for(int v : g[u])pd(v);}
    void pt(){
        cout << tot << endl;
        for(int i = 1; i <= tot; ++i)cout << sz[i] << ' ' << rp[i] << endl;
        for(int i = 1; i <= m; ++i)cout << s[i]; cout << endl;
    }
}sp, sf;

void getrt(int u, int fa, int tot){
    sz[u] = 1; int ma = - inf;
    for(int i = hd[u]; i; i = e[i].nxt){
        int v = e[i].to; if(v == fa or tg[v])continue;
        getrt(v, u, tot); sz[u] += sz[v];
        ma = max(ma, sz[v]);
    }
    ma = max(ma, tot - sz[u]);
    if(ma < mi)mi = ma, rt = u;
}
void dfs1(int u, int fa, int p, ll o){
    p = sp.ch[p][a[u] - 'a']; if(! p)return;
    ans += o * sp.sz[p];
    for(int i = hd[u]; i; i = e[i].nxt){
        int v = e[i].to; if(v == fa or tg[v])continue;
        dfs1(v, u, p, o);
    }
}
void dfs2(int u, int fa){
    dfs1(u, 0, 1, 1);
    for(int i = hd[u]; i; i = e[i].nxt){
        int v = e[i].to; if(v == fa or tg[v])continue;
        dfs2(v, u);
    }
}
void dfs3(int u, int fa){
    sum[u] = 1;
    for(int i = hd[u]; i; i = e[i].nxt){
        int v = e[i].to; if(v == fa or tg[v])continue;
        dfs3(v, u); sum[u] += sum[v];
    }
}
int st;
void dfs4(int u, int fa, int p, int l){
    if(sp.len[p] == l)p = sp.son[p][a[u] - 'a'];
    else if(sp.s[sp.rp[p] - l] ^ (a[u] - 'a'))p = 0;
    dfs1(st, rt, p, - 1);
    for(int i = hd[u]; i; i = e[i].nxt){
        int v = e[i].to; if(v == fa or tg[v])continue;
        dfs4(v, u, p, l + 1);
    }
}
void sol(int u, int fa, ll o){
    sp.clr(); sf.clr();
    if(fa)
        sp.upd(u, 0, sp.son[1][a[fa] - 'a'], 1),
        sf.upd(u, 0, sf.son[1][a[fa] - 'a'], 1);
    else sp.upd(u, 0, 1, 0), sf.upd(u, 0, 1, 0);
    sf.pd(1); sp.pd(1);
    for(int i = 1; i <= m; ++i)ans += o * sp.cnt[sp.pos[i]] * sf.cnt[sf.pos[m - i + 1]];
}

void dfs(int u, int tot){
    if(tot < sn)return dfs2(u, 0), void();
    tg.set(u); sol(u, 0, 1); dfs3(u, 0);
    for(int i = hd[u]; i; i = e[i].nxt){
        int v = e[i].to; if(tg[v])continue;
        if(sz[v] < sn)st = v, dfs4(v, u, sp.son[1][a[u] - 'a'], 1); else sol(v, u, - 1);
        mi = inf, rt = 0; getrt(v, u, sum[v]); dfs(rt, sum[v]);
    }
}

signed main(){
    ios :: sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
    cin >> n >> m; sn = 600;
    for(int i = 1, u, v; i < n; ++i)cin >> u >> v, add(u, v), add(v, u);
    cin >> a + 1 >> s1 + 1;
    for(int i = 1; i <= m; ++i)sp.s[i] = sf.s[m - i + 1] = s1[i] - 'a', s2[m - i + 1] = s1[i];
    sp.init(); sf.init();
    getrt(1, 0, n); dfs(rt, n);
    cout << ans;
    return 0;
}
```

---

## 作者：xfrvq (赞：1)

对特征串建 $\tt SAM$，点分治，考虑计算一个大小为 $s$ 的子树的答案。

+ 暴力 1：假如固定起点，直接遍历子树，维护指针在 $\tt SAM$ 上走。不断往该指针后加字符，容易动态求出现次数。枚举每个起点做这个过程复杂度 $O(s^2)$。
+ 暴力 2：将串分为 $i\to u\to j$，现在即要求出 $i\to u$ 的 $\tt endpos$ 等价类（即在 $\tt SAM$ 上节点）以及 $u\to j$ 的 $\tt startpos$ 等价类（即在反串 $\tt SAM$ 上节点），需要解决：在当前指针的**前面**加字符，求在 $\tt SAM$ 上位置的问题。

这时有两种情况。

+ 当前串长度 $\le$ 当前节点的 `len`，即还在这个节点中。此时判断当前要加的字符是否等于这个节点中这个位置该有的字符，返回原节点或空节点。
+ 当前串长度已经顶到 `len` 了，那么会来到当前节点某个出边连向的节点之中，枚举所有出边，看是否存在一个点的串符合这个字符，是则返回，否则返回空。

预处理后即可 $O(1)$ 正常跳了，跳完在正反串 $\tt parent$ 树上分别下放标记到原串位置，然后枚举每个位置，两个标记相乘算答案。最后还需要再每个儿子中分别做一次去重。暴力 2 复杂度 $O(s+m)$。

根号分治，对 $\le\sqrt n$ 的子树做暴力 1（只需要做一次，不用递归儿子了），$\gt\sqrt n$ 的子树做暴力 2。考虑暴力 2 部分复杂度，点分治每层最坏子树大小折半，即每轮有 $1,2,\cdots,2^d$ 个儿子，子树大小分别为 $n,\dfrac n2,\cdots \dfrac n{2^d}$。$\dfrac n{2^d}\le\sqrt n$ 即 $2^d\le\sqrt n$，此时最多产生 $1+2+\cdots+2^d=O(\sqrt n)$ 量级的儿子。总复杂度单根号。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;

int n,m,sq,f[2][N];
int siz[N],P,X;
bool vis[N];
char a[N],b[N];
vector<int> G[N];
long long sum;

struct SAM{
	int f[N],g[N],h[N],ft[N],R = 1,C = 1;
	struct node{ int G[26],H[26],len,fa; } T[N];
	vector<int> G[N];
	char s[N];
	
	void add(int i,int x){
		int p = R,q,u,v = R = ++C;
		T[v].len = T[p].len + 1,f[v] = 1,g[h[i] = v] = i;
		for(;p && !T[p].G[x];p = T[p].fa) T[p].G[x] = v;
		if(!p) return T[v].fa = 1,void();
		if(T[q = T[p].G[x]].len == T[p].len + 1) return T[v].fa = q,void();
		T[u = ++C] = T[q];
		T[T[q].fa = T[v].fa = u].len = T[p].len + 1;
		for(;p && T[p].G[x] == q;p = T[p].fa) T[p].G[x] = u;
	}
	
	void dfs(int u){
		for(int v : G[u]) dfs(v),g[u] = max(g[u],g[v]),f[u] += f[v];
	}
	
	void init(){
		for(int i = 1;i <= m;++i) add(i,s[i] = b[i]);
		for(int i = 2;i <= C;++i) G[T[i].fa].push_back(i);
		dfs(1);
		for(int i = 1;i <= C;++i)
			for(int j : G[i]) T[i].H[s[g[j] - T[i].len]] = j;
	}
	
	void calc(int u,bool _){
		for(int v : G[u]) ::f[_][v] += ::f[_][u],calc(v,_);
	}
	
	int jump(int u,int c,int d){
		if(T[u].len == d) return T[u].H[c];
		return c == s[g[u] - d] ? u : 0;
	}
} S1,S2;

int size(int u,int ft,int s = 1){
	for(int v : G[u]) if(v != ft && !vis[v]) s += size(v,u);
	return s;
}

void fnd(int u,int ft,int m,int s = 0){
	siz[u] = 1;
	for(int v : G[u]) if(v != ft && !vis[v])
		fnd(v,u,m),s = max(s,siz[v]),siz[u] += siz[v];
	if((s = max(s,m - siz[u])) < X) P = u,X = s;
}

void dfs0(int u,int ft,int p,int t){
	if(!p) return;
	sum += S1.f[p] * t;
	for(int v : G[u]) if(v != ft && !vis[v]) dfs0(v,u,S1.T[p].G[a[v]],t);
}

void dfs1(int u,int ft){
	dfs0(u,0,S1.T[1].G[a[u]],1);
	for(int v : G[u]) if(v != ft && !vis[v]) dfs1(v,u);
}

void dfs2(int u,int ft,int d,int p,int q){
	if(!p && !q) return;
	if(p) ++f[0][p]; if(q) ++f[1][q];
	for(int v : G[u]) if(v != ft && !vis[v])
		dfs2(v,u,d + 1,S1.jump(p,a[v],d),S2.jump(q,a[v],d));
}

void sol(int u){
	if(size(u,0) <= sq) return dfs1(u,0),void(vis[u] = 1);
	for(int i = 1;i <= S1.C;++i) f[0][i] = 0;
	for(int i = 1;i <= S2.C;++i) f[1][i] = 0;
	dfs2(u,0,1,S1.jump(1,a[u],0),S2.jump(1,a[u],0));
	S1.calc(1,0),S2.calc(1,1);
	for(int i = 1;i <= m;++i) sum += 1ll * f[0][S1.h[i]] * f[1][S2.h[m - i + 1]];
	vis[u] = 1;
	for(int v : G[u]) if(!vis[v]){
		for(int i = 1;i <= S1.C;++i) f[0][i] = 0;
		for(int i = 1;i <= S2.C;++i) f[1][i] = 0;
		dfs2(v,u,2,S1.jump(S1.jump(1,a[u],0),a[v],1),S2.jump(S2.jump(1,a[u],0),a[v],1));
		S1.calc(1,0),S2.calc(1,1);
		for(int i = 1;i <= m;++i) sum -= 1ll * f[0][S1.h[i]] * f[1][S2.h[m - i + 1]];
	}
	for(int v : G[u]) if(!vis[v]) X = 2e9,fnd(v,u,size(v,u)),sol(P);
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1,u,v;i < n;++i)
		scanf("%d%d",&u,&v),G[u].push_back(v),G[v].push_back(u);
	scanf("%s%s",a + 1,b + 1);
	for(int i = 1;i <= n;++i) a[i] -= 'a';
	for(int i = 1;i <= m;++i) b[i] -= 'a';
	S1.init(),reverse(b + 1,b + m + 1),S2.init();
	sq = sqrt(m),X = 2e9,fnd(1,0,n),sol(P);
	printf("%lld\n",sum);
	return 0;
}
```

---


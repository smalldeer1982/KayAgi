# [CTSC2018] 暴力写挂

## 题目描述

temporaryDO 是一个很菜的 OIer。在 4 月，他在省队选拔赛的考场上见到了《林克卡特树》一题，其中 $k = 0$ 的部分分是求树 $T$ 上的最长链。可怜的 temporaryDO 并不会做这道题，他在考场上抓猫耳挠猫腮都想不出一点思路。

这时，善良的板板出现在了空中，他的身上发出璀璨却柔和的光芒，荡漾在考场上。“题目并不难。” 板板说。那充满磁性的声音，让 temporaryDO 全身充满了力量。

他决定：写一个枚举点对求 LCA 算距离的 $k = 0$ 的 $O(n^2 \log n)$ 的部分分程序！于是， temporaryDO 选择以 $1$ 为根，建立了求 LCA 的树链剖分结构，然后写了二重 for 循环枚举点对。

然而，菜菜的 temporaryDO 不小心开小了数组，于是数组越界到了一片神秘的内存区域。但恰好的是，那片内存区域存储的区域恰好是另一棵树 $T'$ 。这样一来，程序并没有 RE ，但他求 $x$ 和 $y$ 的距离的时候，计算的是 

$$ \mathrm{depth}(x) + \mathrm{depth}(y) -  ({\mathrm{depth}(\mathrm{LCA}(x,y))}+{\mathrm{depth'}(\mathrm{LCA'}(x,y))})$$



最后程序会输出每一对点对 $i, j$（$i \le j$） 的如上定义的“距离” 的最大值。
temporaryDO 的程序在评测时光荣地爆零了。但他并不服气，他决定花好几天把自己的程序跑出来。请你根据 $T$ 和 $T'$ 帮帮可怜的 temporaryDO 求出他程序的输出。

## 说明/提示

### 样例解释 1
点对 $(3, 4)$ 的距离计算为 $3 + 0 - (0 + (-2)) = 5$ 。

### 数据范围
对于所有数据， $1\le n \le 366666$，$|v| \le 2017011328$ 。 详细数据范围见下表，表格中的“无” 表示无特殊限制。

测试点编号|$n \le$|$v$|$T$ 是一条链|$T'$ 是一条链
-|-|-|-|-
$1$|$36$|$=1$|否|否
$2$|$366$|$=1$|否|否
$3$|$1388$|$>0$|否|否
$4$|$1999$|$>0$|否|否
$5$|$2666$|$>0$|否|否
$6$|$5666$|无|否|否
$7$|$8666$|无|否|否
$8$|$11111$|无|否|否
$9$|$12345$|无|否|否
$10$|$366666$|$>0$|是|是
$11$|$366666$|无|是|是
$12\sim 13$|$366666$|$>0$|是|否
$14$|$366666$|无|是|否
$15\sim 16$|$366666$|$>0$|否|是
$17$|$366666$|无|否|是
$18\sim 20$|$366666$|无|否|否

$\mathrm{depth}(p)$ 和 $\mathrm{depth'}(p)$ 分别表示树 $T$，$T'$ 中点 $1$ 到点 $p$ 的距离，这里规定，距离指的是经过的边的边权总和，其中 $\mathrm{depth}(1) = 0$。

$\mathrm{LCA}(x, y)$ 和 $\mathrm{LCA'}(x, y)$ 分别表示树 $T$，$T'$ 中点 $x$ 与点 $y$ 的最近公共祖先，即在从 $x$ 到 $y$ 的最短路径上的距离根**经过边数最少**的点。

## 样例 #1

### 输入

```
6
1 2 2
1 3 0
2 4 1
2 5 -7
3 6 0
1 2 -1
2 3 -1
2 5 3
2 6 -2
3 4 8```

### 输出

```
5
```

# 题解

## 作者：Y_B_X (赞：34)

>在 $366666$ 的天幕下，点分治、边分治与虚树的磨合正轰轰烈烈地进行着，似将前路雪封。  
正当边分治能以一个 $\log$ 的优势一马当先之际；  
殊不知，怀揣着 $\log^3$ 的三人小队已一举拿下[暂时最优解](https://www.luogu.com.cn/record/68875662)。  
他们是谁？不出所料，正是小常数三人组：$\text{Dsu on Tree}$，树剖，$\text{Bit}$。

[原题链接](https://www.luogu.com.cn/problem/P4565)

>题意：给定两棵树，边有边权，求 $\mathrm{MAX}\left(\operatorname{dep}_x+\operatorname{dep}_y-\operatorname{dep}_{\operatorname{lca}(x,y)}-\operatorname{\hat {dep}}_{\operatorname{\hat{lca}}(x,y)}\right)$，$n\leq 366666$

对第一棵树进行 $\text{Dsu on Tree}$，目标是在每个节点处理出跨过它的所有点对。

由于式子具有良好的对称性，所以重儿子的信息能直接利用，只需在轻子树内**查询**，每个儿子子树查完后**更新**信息。

假设目前在处理节点 $t$，则 $t=\operatorname{lca}(x,y)$，而 $x$ 在 $t$ 的一个轻儿子子树内，$y$ 是 $t$ 之前遍历过的儿子子树内一点（包括重儿子）。

轻子树是允许直接遍历的，所以此时 $\operatorname{dep}_x$ 与 $\operatorname{dep}_t$ 都已知，只需求 $\mathrm{MAX}\left(\operatorname{dep}_y-\operatorname{\hat {dep}}_{\operatorname{\hat{lca}}(x,y)}\right)$

这仅仅与第二棵树有关了，问题转化为一个树上动态加 $y$，查 $\mathrm{MAX}\left(a_y-\operatorname{dep}_{\operatorname{lca}(x,y)}\right)$

这可以用树剖优化了，上图：

![](https://cdn.luogu.com.cn/upload/image_hosting/e8nyukim.png)

其中 $u$ 是 $x$ 跳到的一个重链上一点，$\text{Part 2,3}$ 是 $u$ 子树中除了 $x$ 一边的两部分，$\text{Part 1,4}$ 是重链 $u$ 上下的部分。

如果 $y$ 在 $\text{Part}\ 1,2,3$ 中，$\operatorname{lca}(x,y)=u$ 只需求这部分的 $\mathrm{MAX}(a_y)$。

这可以在每次加入 $y$ 时向上跳链，将信息存在**链上** $\text{Part 1}$ 以及**点上** $\text{Part 2,3}$

而 $y$ 在 $\text{Part 4}$ 中，$\operatorname{lca}(x,y)$ 一定是**重链上 $y$ 跳到的位置**，在更新 $y$ 时同样可以存到重链上。

而对于重链以及儿子信息的存储，可以对每条链，每个点开**树状数组**实现。

查询与更新就此结束，但 $\text{Dsu on Tree}$ 还会自带一个删除，似乎树状数组实现不了。

但由于 $\text{Dsu on Tree}$ 时时只会处理一个子树，直接在第二棵树把影响的点清除即可。

理论时间复杂度是 $O(n\log^3 n)$，后面的树剖以及树状数组其实也能用 $\text{LCT}$ 做到大常数 $O(n\log^2n)$。

由于外层有 $\text{Dsu on Tree}$，十分难卡满，但临时最优解确实出乎意料。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=4e5+10;
const ll inf=1e18;
int n,m,x,y,v,tot;ll res,ans;
int to[N<<1],nextn[N<<1],w[N<<1],h[N],edg;
int son[N],sz[N],tmp[N];ll d[N];
char ch;bool rf;
inline void read(int &x){
	x=0;ch=getchar();while(ch<47)ch=getchar();
	while(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
inline void read_(int &x){
	x=0;ch=getchar();rf=0;while(ch<47&&ch^'-')ch=getchar();
	if(ch=='-')rf=1,ch=getchar();
	while(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(rf)x=-x;
}
inline ll max(ll a,ll b){return a>b?a:b;}
inline void add(){to[++edg]=y,nextn[edg]=h[x],h[x]=edg,w[edg]=v;}
void init(int x,int anc){
	int i,y;sz[x]=1;
	for(i=h[x];y=to[i];i=nextn[i])if(y^anc){
		d[y]=d[x]+w[i];init(y,x);sz[x]+=sz[y];
		sz[y]>sz[son[x]]?son[x]=y:0;
	}
}
#define lowbit(i) i&(-i) 
struct bit{
	ll *t,res;int n;bit()=default;
	bit(ll *tt,int nn):t(tt),n(nn){for(int i=1;i<=n;++i)t[i]=-inf;}
	inline void update(int i,ll v){for(;i<=n;i+=lowbit(i))t[i]=max(t[i],v);}
	inline void inquiry(int i){for(res=-inf;i;i-=lowbit(i))res=max(res,t[i]);}
	inline void clear(int i){for(;i<=n;i+=lowbit(i))t[i]=-inf;} 
};
struct the_second_tree{
	int x,y,tot,nn,i,edg;
	int to[N<<1],nextn[N<<1],w[N<<1],h[N],tmp[N],id[N];
	int sz[N],son[N],anc[N],top[N],cnum[N],vnum[N];
	int crk[N],crk_[N],vrk[N],vrk_[N];
	ll up_[N<<1],*upp=up_,dn_[N<<1],*dnn=dn_;
	ll vl_[N<<1],*vll=vl_,vr_[N<<1],*vrr=vr_;
	bit up[N],dn[N],vl[N],vr[N];
	ll a[N],d[N],res,ax,dx;bool b[N];
	inline void add(){to[++edg]=y,nextn[edg]=h[x],h[x]=edg,w[edg]=v;}
	void dfs(int x,int anc_){
		anc[x]=anc_;sz[x]=1;int i,y;
		for(i=h[x];y=to[i];i=nextn[i])if(y^anc_){
			d[y]=d[x]+w[i];dfs(y,x);sz[x]+=sz[y];
			sz[y]>sz[son[x]]?son[x]=y:0;
		}
	}
	void init(int x,int anc_,int tp){
		top[x]=tp;
		if(!son[x]){
			++nn;i=0;id[tp]=nn;
			while(top[x]==tp)++i,crk[x]=i,x=anc[x];cnum[nn]=i;
			up[nn]=bit(upp,i),upp+=i+1;dn[nn]=bit(dnn,i),dnn+=i+1; 
		}
		else {
			init(son[x],x,tp);int i,y,j=0;
			for(i=h[x];y=to[i];i=nextn[i])if(y^anc_&&y^son[x])
				vrk[y]=++j,init(y,x,y);vnum[x]=j;
			vl[x]=bit(vll,j),vll+=j+1;vr[x]=bit(vrr,j),vrr+=j+1;
		}
	}
	void update(int x){
		ax=a[x];b[x]=1;
		while(x){
			y=top[x];i=id[y];
			dn[i].update(crk[x],ax);
			up[i].update(crk_[x],ax-d[x]);
			x=anc[y];
			if(x){
				vl[x].update(vrk[y],ax);
				vr[x].update(vrk_[y],ax);
			} 
		}
	}
	void inquiry(int x){
		res=-inf;
		if(vnum[x]){
			vl[x].inquiry(vnum[x]);res=max(res,vl[x].res-d[x]);
			vr[x].inquiry(vnum[x]);res=max(res,vr[x].res-d[x]);
		}
		while(x){
			y=top[x];i=id[y];
			dn[i].inquiry(crk[x]-1);res=max(res,dn[i].res-d[x]);
			up[i].inquiry(crk_[x]-1);res=max(res,up[i].res);
			x=anc[y];b[x]?res=max(res,a[x]-d[x]):0;x=anc[y];
			if(x){
				vl[x].inquiry(vrk[y]-1);res=max(res,vl[x].res-d[x]);
				vr[x].inquiry(vrk_[y]-1);res=max(res,vr[x].res-d[x]);
			}
		}
	}
	void clear(int x){
		b[x]=0;
		while(x){
			y=top[x];i=id[y];
			dn[i].clear(crk[x]);
			up[i].clear(crk_[x]);
			x=anc[y];
			if(x){
				vl[x].clear(vrk[y]);
				vr[x].clear(vrk_[y]);
			}
		}
	}
	void pre_work(){
		int i;
		for(i=1;i^n;++i)read(x),read(y),read_(v),add(),x^=y^=x^=y,add();
		dfs(1,0);init(1,0,1);
		for(i=1;i<=n;++i)crk_[i]=cnum[id[top[i]]]-crk[i]+1;
		for(i=1;i<=n;++i)if(vrk[i])vrk_[i]=vnum[anc[i]]-vrk[i]+1;
	}
}T;
void clear(int x,int anc){
	int i,y;T.clear(x);
	for(i=h[x];y=to[i];i=nextn[i])if(y^anc)clear(y,x);
}
void dfs(int x,int anc){
	int i,y;T.inquiry(x);res=max(res,T.res+d[x]);tmp[++tot]=x;
	for(i=h[x];y=to[i];i=nextn[i])if(y^anc)dfs(y,x);
}
void solve(int x,int anc){
	int i,y,j;
	for(i=h[x];y=to[i];i=nextn[i])if(y^anc&&y^son[x])solve(y,x),clear(y,x);
	if(son[x])solve(son[x],x);res=-inf;
	for(i=h[x];y=to[i];i=nextn[i])if(y^anc&&y^son[x]){
		tot=0;dfs(y,x);
		for(j=1;j<=tot;++j)T.update(tmp[j]); 
	}
	T.inquiry(x);res=max(res,T.res+d[x]);
	T.update(x);ans=max(ans,res-d[x]);
}
main(){
	read(n);register int i;
	for(i=1;i^n;++i)read(x),read(y),read_(v),add(),x^=y^=x^=y,add();
	init(1,0);T.pre_work();for(i=1;i<=n;++i)T.a[i]=d[i];
	solve(1,0);
	for(i=1;i<=n;++i)ans=max(ans,d[i]-T.d[i]);
	printf("%lld",ans);
}
```

---

## 作者：ywy_c_asm (赞：16)

感谢i207M神犇教我的边分树Orz

这题让我们求这个：

$ans=max_{x,y}\{deep_x+deep_y-deep_{LCA(x,y)}-deep'_{LCA'(x,y)}\}$

然后这式子里带了2个LCA不好处理，给他变形：

$ans=\frac 1 2max_{x,y}\{dis(x,y)+deep_x+deep_y-2deep'_{LCA'(x,y)}\}$

然后这里出现了$dis(x,y)$，不难想到[通道那题](https://www.luogu.org/problemnew/show/P4220)的边分治做法，我们把它照搬过来，对$T_1$进行边分治，然后这个过程中划分了两个连通块，把一边的看成黑点，一边的看成白点，然后令$val_i$为当前边分治的时候的$i$的深度$+deep_i$，那么我们相当于最大化$val_x+val_y-2deep'_{LCA'(x,y)}$，其中x为黑点，y为白点，这个在$T_2$上建个虚树枚举$LCA'$就可以统计答案了，加上建虚树的排序这是$O(n\log^2n)$的显然~~同一位~~出题人故意卡了这个过不去……~~毕竟1个log都要跑2s多……~~

然后我们把上面那个思路稍微改一下，考虑在$T_2$上直接枚举$LCA'$，然后合并两棵$LCA'$为这个点的子树的时候统计这两棵子树之间在$T_1$上产生的贡献，然而显然我们就不能边分治了，然而……有个东西叫边分树……

所谓边分树其实和点分树完全不同，实际上它初始的时候是一个森林的形式，我们先对$T_1$进行一遍边分治，然后我们在每个点上**维护一条高度为$O(logn)的二叉树链$**（注意此树非彼树），在分治的时候，我们把一端深度较大的那个连通块里的所有点的链的底部都添加一个右儿子，深度较小的那一端的连通块的所有点都添加一个左儿子。这里所说的“深度”是用于区分这条边的两个端点的。每个点上维护的这条链上的点其实就是表示了这个点自己在边分治时所属的$O(\log n)$个连通块。所以这个空间复杂度是$O(\log n)$的，其实这个类似于动态开点线段树。

然后考虑两个$T_1$上的点$a$和$b$什么时候会产生贡献，显然就是两个点第一次不在一个连通块内，也就是说，考虑a的边分树上一个点$i$与b的边分树上一个点j，$ij$深度相同，那么i的所有祖先的左右父子关系都与j的相同，直到i和j他们与父亲的左右父子关系才开始变得不同。

那么，我们就可以对边分树进行合并了，这个合并和线段树合并完全一样，同时我们可以在合并的时候顺便把对答案的贡献统计出来。我们现在不是在枚举$LCA'$吗？就在这个$dfs$的时候合并子树的边分树，我们求的相当于最大的$val_i+val_j$，当合并$ab$两棵边分树的时候，显然$a$的所有祖先的父子的左右关系都和$b$的相等（因为这个和线段树合并一样），那么就相当于$ab$表示的是同一个连通块，我们就可以把他们合并成一个点，同时维护这个点表示的连通块里最大的$val$（取个max即可），然后a的左儿子显然是和b的右儿子分治在一条边的两边的，同理a的右儿子与b的左儿子也如此，那么把他们产生的贡献统计一下即可。于是就做到了$O(n\log n)$。

不难发现，我们最后会合并成一棵极大的边分树，这棵边分树就真的是真正意义上的“边分树”了，即父亲的左右儿子是一个大连通块分治成的两个小连通块，另外还要注意在边分树上维护子树的信息没有任何意义……

哦这题还需要特判$x=y$的情况，因为你的答案是边分树合并统计出来的，所以一个点自身与自身的答案统计不出来……

上代码~

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#define ll long long
#define inf (1ll << 60)
#define abs(_o) ((_o < 0) ? -(_o) : _o)
using namespace std;
namespace ywy {
	inline int get() {
	    int n = 0;
	    char c;
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            break;
	        if (c == '-')
	            goto s;
	    }
	    n = c - '0';
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 + c - '0';
	        else
	            return (n);
	    }
	s:
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 - c + '0';
	        else
	            return (n);
	    }
	}
	int n;
	typedef struct _b {
	    int dest;
	    int nxt;
	    int len;
	    unsigned char gg;
	} bian;
	int root[400001];
	ll val[10000001];
	int gb;
	int ch[10000001][2];
	namespace t1 {
		bian memchi[2000001];
		int gn = 2, heads[800001];
		inline void add(int s, int t, int l) {
		    memchi[gn].dest = t;
		    memchi[gn].len = l;
		    memchi[gn].nxt = heads[s];
		    heads[s] = gn;
		    gn++;
		}
		ll deep[800001];
		int size[800001], tot, zx, minn;
		ll dp[800001];
		int rdp[800001];
		void dfs(int pt, int baba) {
		    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
		        if (memchi[i].dest == baba)
		            continue;
		        deep[memchi[i].dest] = deep[pt] + memchi[i].len;
		        rdp[memchi[i].dest] = rdp[pt] + 1;
		        dfs(memchi[i].dest, pt);
		    }
		}
		void afs(int pt, int baba) {
		    tot++;
		    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
		        if (memchi[i].gg || memchi[i].dest == baba)
		            continue;
		        afs(memchi[i].dest, pt);
		    }
		}
		void bfs(int pt, int baba) {
		    size[pt] = 1;
		    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
		        if (memchi[i].gg || memchi[i].dest == baba)
		            continue;
		        bfs(memchi[i].dest, pt);
		        size[pt] += size[memchi[i].dest];
		        if (abs(tot - 2 * size[memchi[i].dest]) < minn) {
		            minn = abs(tot - 2 * size[memchi[i].dest]);
		            zx = i;
		        }
		    }
		}
		void cfs(int pt, int baba, int op) {
		    if (pt <= n) {
		        int me = gb;
		        gb++;
		        val[me] = deep[pt] + dp[pt];
		        ch[root[pt]][op] = me;
		        root[pt] = me;
		    }
		    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
		        if (memchi[i].dest == baba || memchi[i].gg)
		            continue;
		        dp[memchi[i].dest] = dp[pt] + memchi[i].len;
		        cfs(memchi[i].dest, pt, op);
		    }
		}
		void digui(int pt) {
		    tot = 0;
		    afs(pt, 0);
		    if (tot == 1)
		        return;
		    minn = 12345678;
		    bfs(pt, 0);
		    int me = zx, a = memchi[me].dest, b = memchi[me ^ 1].dest;
		    memchi[me].gg = memchi[me ^ 1].gg = 1;
		    dp[a] = memchi[me].len;
		    dp[b] = 0;
		    cfs(a, 0, rdp[a] > rdp[b]);
		    cfs(b, 0, rdp[b] > rdp[a]);
		    digui(a);
		    digui(b);
		}
	}
	vector<int> vec[400001], len[400001];
	int gpt;
	void rebuild(int pt, int baba) {
	    int lst = pt;
	    for (register int i = 0; i < vec[pt].size(); i++) {
	        if (vec[pt][i] == baba)
	            continue;
	        int me = gpt;
	        gpt++;
	        t1::add(lst, me, 0);
	        t1::add(me, lst, 0);
	        t1::add(me, vec[pt][i], len[pt][i]);
	        t1::add(vec[pt][i], me, len[pt][i]);
	        rebuild(vec[pt][i], pt);
	        lst = me;
	    }
	}
	ll maxn = -inf;
	ll ans = -inf;
	inline int united(int a, int b) {
	    if (!(a && b))
	        return (a | b);
	    if (ch[a][0] && ch[b][1]) {
	        ans = max(ans, val[ch[a][0]] + val[ch[b][1]]);
	    }
	    if (ch[a][1] && ch[b][0]) {
	        ans = max(ans, val[ch[a][1]] + val[ch[b][0]]);
	    }
	    val[a] = max(val[a], val[b]);
	    ch[a][0] = united(ch[a][0], ch[b][0]);
	    ch[a][1] = united(ch[a][1], ch[b][1]);
	    return (a);
	}
	namespace t2 {
		bian memchi[1000001];
		int gn = 1, heads[400001];
		inline void add(int s, int t, int l) {
		    memchi[gn].dest = t;
		    memchi[gn].len = l;
		    memchi[gn].nxt = heads[s];
		    heads[s] = gn;
		    gn++;
		}
		ll deep[400001];
		void dfs(int pt, int baba) {
		    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
		        if (memchi[i].dest == baba)
		            continue;
		        deep[memchi[i].dest] = deep[pt] + memchi[i].len;
		        dfs(memchi[i].dest, pt);
		        ans = -inf;
		        root[pt] = united(root[pt], root[memchi[i].dest]);
		        if (ans != -inf)
		            maxn = max(maxn, ans - 2 * deep[pt]);
		    }
		}
	}
	void ywymain() {
	    n = get();
	    gpt = n + 1;
	    for (register int i = 1; i <= n; i++) root[i] = i;
	    gb = n + 1;
	    val[0] = -inf;
	    for (register int i = 1; i < n; i++) {
	        int s = get(), t = get(), l = get();
	        vec[s].push_back(t);
	        len[s].push_back(l);
	        vec[t].push_back(s);
	        len[t].push_back(l);
	    }
	    for (register int i = 1; i < n; i++) {
	        int s = get(), t = get(), l = get();
	        t2::add(s, t, l);
	        t2::add(t, s, l);
	    }
	    rebuild(1, 0);
	    t1::dfs(1, 0);
	    t1::digui(1);
	    for (register int i = 1; i <= n; i++) root[i] = i;
	    t2::dfs(1, 0);
	    maxn /= 2;
	    for (register int i = 1; i <= n; i++) {
	        maxn = max(maxn, t1::deep[i] - t2::deep[i]);
	    }
	    cout << maxn << endl;
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：asuldb (赞：13)

[题目](https://www.luogu.org/problem/P4565)

边分治+虚树=双倍的快乐

这个柿子里有两个$LCA$，我们考虑魔改一下前面的$\operatorname{depth(x)+depth(y)-depth(LCA(x,y))}$，为了方便边分，我们考虑把$\operatorname{depth(LCA(x,y))}$去掉变换为树上距离

经过一番魔改，这个柿子变成了$\frac{1}{2}(\operatorname{depth(x)+depth(y)+dis(x,y)})$

至于第二棵树上的$\operatorname{LCA}$，我们只能考虑到虚树上去搞了

对于当前的分治边$w$，我们处理处分块内所有点$i$到这条边的距离$p_i$，那么$\operatorname{depth(x)+depth(y)+dis(x,y)}=p_x+p_y+w+depth_x+depth_y$

同时我们把分治边左右两边的点黑白染色，点权设为$p_i+depth_i$，到第二颗树上去建虚树，对于虚树上的每个点考虑其作为$\operatorname{LCA}$时的贡献，于是把问题转化成了在一个点的不同儿子里找到一对异色点，使得点权最大，显然直接虚树上dp就好了

如果虚树实现得不好，这个算法就是$\operatorname{O(nlog^2n)}$

如果使用st表求$\operatorname{LCA}$，并且在一开始就把所有点按照$\operatorname{dfn}$排序，每次根据这个点染成的颜色分到两个接下来的分治块里去，就能做到线性建虚树，整个算法的复杂度就能到$\operatorname{O(nlogn)}$

记得特判$x=y$的情况

代码

```cpp
#include<bits/stdc++.h>
#define re register
#define LL long long
#define pt putchar(1)
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=366667;
const int M=maxn*4;
const LL inf=-1e15;
inline int read() {
	char c=getchar();int x=0,r=1;
	while(c<'0'||c>'9') {if(c=='-') r=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3ll)+(x<<1ll)+c-48,c=getchar();return r*x;
}
std::vector<int> son[M];
std::vector<LL> v[M];
struct E{int v,nxt,w;}e[M<<1];
int head[M],sum[M],vis[M],dfn[maxn],b[maxn];
int S,mnow,rn,n,num,col[maxn],rt,Mnow,tp[2],c[2][maxn];
LL g[maxn],dp[maxn][2],deep[maxn],tmp,ans;
inline int cmp(int A,int B) {return dfn[A]<dfn[B];}
inline void add(int x,int y,LL w) {
	e[++num].v=y;e[num].nxt=head[x];head[x]=num,e[num].w=w;
}
void dfs1(int x,int fa) {
	for(re int i=head[x];i;i=e[i].nxt) {
		if(e[i].v==fa) continue;
		deep[e[i].v]=deep[x]+e[i].w;
		son[x].push_back(e[i].v);v[x].push_back(e[i].w);
		dfs1(e[i].v,x);
	}
} 
void getrt(int x,int fa) {
	sum[x]=1;
	for(re int i=head[x];i;i=e[i].nxt) {
		if(vis[i>>1]||e[i].v==fa) continue;
		getrt(e[i].v,x);sum[x]+=sum[e[i].v];
		int now=max(sum[e[i].v],S-sum[e[i].v]);
		if(now<Mnow) Mnow=now,rt=i;
	}
}
struct Virtual_Tree {
	struct E{int v,nxt,w;}e[maxn<<1];
	int pos[maxn],f[21][maxn<<1],lg[maxn<<1];
	LL pre[maxn];int num,cnt,tot,head[maxn],top,st[maxn],d[maxn],root;
	inline void add(int x,int y,LL w) {
		e[++num].v=y;e[num].nxt=head[x];head[x]=num;e[num].w=w;
	}
	void dfs(int x) {
		dfn[x]=++cnt,f[0][++tot]=x;pos[x]=tot;
		for(re int i=head[x];i;i=e[i].nxt) {
			if(dfn[e[i].v]) continue;
			pre[e[i].v]=pre[x]+e[i].w;d[e[i].v]=d[x]+1;
			dfs(e[i].v);f[0][++tot]=x;
		}
	}
	inline int LCA(int x,int y) {
		int l=pos[x],r=pos[y];
		if(l>r) std::swap(l,r);
		int k=lg[r-l+1];
		if(d[f[k][l]]<d[f[k][r-(1<<k)+1]]) return f[k][l];
		return f[k][r-(1<<k)+1];
	}
	inline void build() {
		for(re int x,y,w,i=1;i<rn;i++) {
			x=read(),y=read(),w=read();
			add(x,y,w),add(y,x,w);
		}
		d[1]=1;dfs(1);memset(head,0,sizeof(head));
		for(re int i=2;i<=tot;i++) lg[i]=lg[i>>1]+1;
		for(re int j=1;j<=lg[tot];j++)
			for(re int i=1;i+(1<<(j-1))<=tot;i++)
				if(d[f[j-1][i]]<d[f[j-1][i+(1<<(j-1))]]) f[j][i]=f[j-1][i];
					else f[j][i]=f[j-1][i+(1<<(j-1))];
		for(re int i=1;i<=rn;i++) b[i]=i;
		std::sort(b+1,b+rn+1,cmp);
	}
	inline void ins(int x) {
		if(top<1) {st[++top]=x;return;}
		int lca=LCA(x,st[top]);
		if(lca==st[top]) {st[++top]=x;return;}
		while(top>1&&dfn[st[top-1]]>=dfn[lca]) 
			add(st[top-1],st[top],0),top--;
		if(lca!=st[top]) add(lca,st[top],0),st[top]=lca;
		st[++top]=x;
	}
	void tree_dp(int x) {
		dp[x][col[x]]=g[x];
		for(re int i=head[x];i;i=e[i].nxt) {
			tree_dp(e[i].v);
			tmp=max(tmp,-2ll*pre[x]+dp[x][0]+dp[e[i].v][1]);
			tmp=max(tmp,-2ll*pre[x]+dp[x][1]+dp[e[i].v][0]);
			dp[x][0]=max(dp[x][0],dp[e[i].v][0]);
			dp[x][1]=max(dp[x][1],dp[e[i].v][1]);
		}
	}
	inline void get_tree(int l,int r) {
		top=0;num=0;
		if(b[l]!=1) ins(1);
		for(re int i=l;i<=r;i++) ins(b[i]);
		while(top>1) add(st[top-1],st[top],0),top--;
		tree_dp(1);
	}
	void del(int x) {
		for(re int i=head[x];i;i=e[i].nxt) del(e[i].v);
		dp[x][0]=dp[x][1]=g[x]=inf;head[x]=0;
	}
}T;
void dfs2(int x,int fa,int o,LL d) {
	if(x<=rn) col[x]=o,g[x]=deep[x]+d;
	for(re int i=head[x];i;i=e[i].nxt) {
		if(vis[i>>1]||e[i].v==fa) continue;
		dfs2(e[i].v,x,o,d+e[i].w);
	}
}
void solve(int x,int s,int l,int r) {
	if(l>r) return;
	Mnow=M,S=s,getrt(x,0);
	if(Mnow==M) return;vis[rt>>1]=1;
	dfs2(e[rt].v,0,0,0),dfs2(e[rt^1].v,0,1,e[rt].w);
	tmp=inf;T.get_tree(l,r);
	ans=max(ans,tmp);
	tp[0]=tp[1]=0;T.del(1);
	for(re int i=l;i<=r;i++) c[col[b[i]]][++tp[col[b[i]]]]=b[i];
	for(re int i=l,k=1;k<=tp[0];i++,k++) b[i]=c[0][k];
	for(re int i=l+tp[0],k=1;k<=tp[1];i++,k++) b[i]=c[1][k];
	int now=s-sum[e[rt].v],k=rt,L=l+tp[0]-1,R=r-tp[1]+1;
	solve(e[k].v,sum[e[k].v],l,L);
	solve(e[k^1].v,now,R,r);
}
int main() {
	rn=n=read();
	for(re int w,x,y,i=1;i<n;i++) {
		x=read(),y=read(),w=read();
		add(x,y,w),add(y,x,w);
	}
	dfs1(1,0);num=1;memset(head,0,sizeof(head));
	int s[2];
	for(re int i=1;i<=n;i++) {
		int t=son[i].size();
		if(!t) continue;
		if(t==1) {
			add(i,son[i][0],v[i][0]),add(son[i][0],i,v[i][0]);
			continue;
		}
		if(t==2) {
			add(i,son[i][0],v[i][0]),add(son[i][0],i,v[i][0]);
			add(son[i][1],i,v[i][1]),add(i,son[i][1],v[i][1]);
			continue;
		}
		s[0]=++n,s[1]=++n;
		add(i,s[0],0),add(s[0],i,0);add(i,s[1],0),add(s[1],i,0);
		for(re int j=0;j<v[i].size();j++)
			son[s[j&1]].push_back(son[i][j]),v[s[j&1]].push_back(v[i][j]);
	}
	T.build();ans=inf;
	for(re int i=1;i<=rn;i++) dp[i][0]=dp[i][1]=g[i]=inf;
	solve(1,n,1,rn);ans>>=1ll;
	for(re int i=1;i<=n;i++) ans=max(ans,deep[i]-T.pre[i]);
	std::cout<<ans;
	return 0;
}
```


---

## 作者：seajupiter (赞：10)

看到点分治的题解如此孤独，我也就来添一篇……

**算法：点分治+虚树**

像这种“多树统计”问题，往往会用到虚树（比如[P4220 [WC2018]通道](https://www.luogu.com.cn/problem/P4220)，~~我才不会告诉你们我是随机化瞎搞AC的那道题~~）。为什么呢？首先我们得转化一下这个式子，因为在一棵树树分治过程中，**原来以1为根时的lca已经不在好处理了**。但是，我们可以想到，树分治很善于解决两点之间距离类的问题，那么我们就往这方面想：

$val(x, y)=depth(x)+depth(y)-depth(lca(x, y))-depth'(lca'(x,y))$

$=\frac{1}{2}(depth(x)+depth(y)-2\cdot depth(lca(x, y))+depth(x)+depth(y)-2*depth'(lca'(x, y))$

$=\frac{1}{2}(dist(x, y)+depth(x)+depth(y)-2\cdot depth'(lca'(x, y))$

使用点分治，若当前分治中心为 $rt$ ，令 $w(x)=dist(x, rt)+depth(x)$ ， 则

$ans(x, y)=w(x)+w(y)-2\cdot depth'(lca'(x, y))$

那么，我们每次点分治过程中，就将**rt 自己**和他的每颗子树染上不同的颜色，$x$ 的颜色记为 $col_x$，然后就是求

$\max\limits_{col_x\ne col_y} w(x)+w(y)-2\cdot depth'(lca'(x, y))$

发现，我们可以一遍树形 DP 求出最大答案，方法如下：

- 设 $f_{u, 0/1}$ 表示以 $u$ 为根的子树中，最大/次大的 $w(x)$ 及其对应的颜色（两个颜色要求不同）。

- 每次 dp 完一个儿子，都先用当前儿子的 dp 值和前面已经统计的儿子的 dp 值（也就是现在父亲的 dp 值）来更新答案。

- 更新完答案后，用该儿子的 dp 值来更新父亲的 dp 值。

（这种形式的 dp 似乎是 noip 阶段经常用的一个 trick）

然而，不能够每次都对整棵树 dp，否则你点分治就白写了，这时候我们就要用到**虚树**。这样，复杂度得到了保证，如果使用 st 表求 lca ，并用基数排序+单调栈来建虚树，则可以达到 $O(n\log n)$ 的复杂度，可以通过此题。

（可以通过个锤子，我在 loj 上跑的飞快，结果不知道为啥 luogu 上一直被卡 #13 TLE QAQ，~~只能通过一些不地道的手段来谋求AC~~）

下面是代码（注意会TLE #13，我之后打了表（~~毕竟其他oj上能A嘛，求不要棕名QAQ~~）

```cpp
#include <bits/stdc++.h>
#define mkp make_pair
#define ft first
#define sd second
#define Path(i, u, G) for(int i=G.hd[u]; i!=-1; i=G.nxt[i])
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x){
	char c=getchar();x=0;int f=1;
	while(!isdigit(c))f=c=='-'?-f:f,c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();x*=f;
}
const int N=4e5+5;
const ll inf=0x3f3f3f3f3f3f3f3fll;
int n, col[N];
ll wgt[N];
struct standard_Graph{
	int e, hd[N], to[N<<1], nxt[N<<1];
	ll val[N<<1];
	inline standard_Graph(){
		e=-1, memset(hd, 0xff, sizeof(hd));
	}
	inline void add_path(int u, int v, ll w){
		to[++e]=v;
		val[e]=w;
		nxt[e]=hd[u];
		hd[u]=e;
	}
	inline void add_edge(int u, int v, int w){
		add_path(u, v, w);
		add_path(v, u, w);
	}
};
struct simple_Graph{
	int e, hd[N], to[N<<1], nxt[N<<1];
	inline simple_Graph(){
		e=-1, memset(hd, 0xff, sizeof(hd));
	}
	inline void add_path(int u, int v){
		to[++e]=v;
		nxt[e]=hd[u];
		hd[u]=e;
	}
};
namespace VT{int p[N], cnt, stk[N], top;}
namespace T2{
	standard_Graph G0;
	simple_Graph G;
	int dep[N], dfn[N], dfn_clock, od[N<<1], pos[N], mi[N<<1][22], lg[N<<1];
	ll d[N];
	inline void dfs(int u, int fa, ll dis){
		od[pos[u]=++od[0]]=u;
		d[u]=dis;
		dep[u]=dep[fa]+1;
		dfn[u]=++dfn_clock;
		Path(i, u, G0){
			int v=G0.to[i];
			ll w=G0.val[i];
			if(v!=fa){
				dfs(v, u, dis+w);
				od[++od[0]]=u;
			}
		}
	}
	inline int Min(int x, int y){
		return dep[x]<dep[y]?x:y;
	}
	inline void prepro(){
		for(int i=2; i<=od[0]; ++i) lg[i]=lg[i>>1]+1;
		for(int i=1; i<=od[0]; ++i) mi[i][0]=od[i];
		for(int j=1; j<=lg[od[0]]; ++j)
			for(int i=1; i+(1<<j)-1<=od[0]; ++i)
				mi[i][j]=min(mi[i][j-1], mi[i+(1<<(j-1))][j-1]);
	}
	inline void init(){
		for(int i=1; i<n; ++i){
			int u, v; ll w;
			read(u);read(v);read(w);
			G0.add_edge(u, v, w);
		}
		dfs(1, 0, 0);
		prepro();
	}
	inline int get_lca(int x, int y){
		x=pos[x], y=pos[y];
		if(x>y) swap(x, y);
		int l=lg[y-x+1];
		return Min(mi[x][l], mi[y-(1<<l)+1][l]);
	}
	inline void Sort(int* l, int *r){
		static int cnt[10], mx, key[N], tmp[N];
		mx=1;
		for(int *i=l; i<r; ++i) while(dfn[*i]>=mx) mx*=10;
		for(int o=1; o<mx; o*=10){
			for(int i=0; i<10; ++i) cnt[i]=0;
			for(int *i=l; i<r; ++i) key[*i]=dfn[*i]/o%10;
			for(int *i=l; i<r; ++i) ++cnt[key[*i]];
			for(int i=1; i<10; ++i) cnt[i]+=cnt[i-1];
			for(int *i=r-1; i>=l; --i) tmp[cnt[key[*i]]--]=*i;
			for(int *i=l; i<r; ++i) *i=tmp[i-l+1];
		}
	}
	inline void get_G(){
		using namespace VT;
		Sort(p+1, p+1+cnt);
		stk[top=1]=1;
		G.e=G.hd[1]=-1;
		for(int i=1, lca; i<=cnt; ++i) if(p[i]!=1){
			lca=get_lca(p[i], stk[top]);
			if(lca!=stk[top]){
				while(dfn[lca]<dfn[stk[top-1]]){
					G.add_path(stk[top-1], stk[top]);
					--top;
				}
				if(dfn[lca]>dfn[stk[top-1]]){
					G.hd[lca]=-1;
					G.add_path(lca, stk[top]);
					stk[top]=lca;
				}
				else G.add_path(lca, stk[top--]);
			}
			G.hd[p[i]]=-1;
			stk[++top]=p[i];
		}
		for(int i=1; i<top; ++i)
			G.add_path(stk[i], stk[i+1]);
	}
	ll ans;
	pair<ll, int> f[N][2];
	inline void upd_f(int u, pair<ll, int> g){
		if(g.ft>f[u][0].ft){
			if(g.sd!=f[u][0].sd) f[u][1]=f[u][0];
			f[u][0]=g;
		}
		else if(g.ft>f[u][1].ft&&g.sd!=f[u][0].sd)
			f[u][1]=g;
	}
	inline void upd_ans(int u, int v){
		if(f[v][0].sd!=f[u][0].sd) ans=max(ans, ((f[v][0].ft+f[u][0].ft)>>1)-d[u]);
		if(f[v][0].sd!=f[u][1].sd) ans=max(ans, ((f[v][0].ft+f[u][1].ft)>>1)-d[u]);
		if(f[v][1].sd!=f[u][0].sd) ans=max(ans, ((f[v][1].ft+f[u][0].ft)>>1)-d[u]);
		if(f[v][1].sd!=f[u][1].sd) ans=max(ans, ((f[v][1].ft+f[u][1].ft)>>1)-d[u]);
	}
	inline void dp(int u){
		f[u][0]=f[u][1]=mkp(-inf, 0);
		if(col[u]) upd_f(u, mkp(wgt[u], col[u]));
		wgt[u]=col[u]=0;
		Path(i, u, G){
			int v=G.to[i];
			dp(v);
			upd_ans(u, v);
			upd_f(u, f[v][0]);
			upd_f(u, f[v][1]);
		}
	}
	inline ll work(){
		get_G();
		ans=-inf;
		dp(1);
		return ans;
	}
}
namespace T1{
	standard_Graph G;
	ll d[N], ans;
	inline void get_d(int u, int fa, ll dis){
		d[u]=dis;
		Path(i, u, G) if(G.to[i]!=fa)
			get_d(G.to[i], u, dis+G.val[i]);
	}
	inline void init(){
		for(int i=1; i<n; ++i){
			int u, v; ll w;
			read(u);read(v);read(w);
			G.add_edge(u, v, w);
		}
		get_d(1, 0, 0);
	}
	int sz[N], rt, Size, maxp[N]={0x3f3f3f3f};
	bool vis[N];
	inline void get_sz(int u, int fa){
		sz[u]=1, maxp[u]=0;
		Path(i, u, G){
			int v=G.to[i];
			if(v==fa||vis[v]) continue;
			get_sz(v, u);
			sz[u]+=sz[v];
			maxp[u]=max(maxp[u], sz[v]);
		}
		maxp[u]=max(maxp[u], Size-sz[u]);
		if(maxp[u]<maxp[rt]) rt=u;
	}
	inline void calc(int u, int fa, ll dis, const int &C){
		using namespace VT;
		col[u]=C;
		wgt[u]=d[u]+dis;
		p[++cnt]=u;
		Path(i, u, G){
			int v=G.to[i];
			if(v==fa||vis[v]) continue;
			calc(v, u, dis+G.val[i], C);
		}
	}
	inline void divide(int u){
		using namespace VT;
		vis[u]=true;
		get_sz(u, 0);
		int C=1;
		col[u]=C, wgt[u]=d[u];
		p[cnt=1]=u;
		Path(i, u, G){
			int v=G.to[i];
			if(vis[v]) continue;
			calc(v, u, G.val[i], ++C);
		}
		ans=max(ans, T2::work());
		Path(i, u, G){
			int v=G.to[i];
			if(vis[v]) continue;
			rt=0, Size=sz[v];
			get_sz(v, u);
			divide(rt);
		}
	}
	inline ll work(){
		ans=-inf;
		for(int i=1; i<=n; ++i)
			ans=max(ans, d[i]-T2::d[i]);
		rt=0, Size=n;
		get_sz(1, 0);
		divide(rt);
		return ans;
	}
}
int main(){
	read(n);
	T1::init();
	T2::init();
	printf("%lld\n", T1::work());
	return 0;
}
```


---

## 作者：AzusaCat (赞：8)

给定两棵树，求 $\text{depth}(x)+\text{depth}(y)-(\text{depth}(\text{lca}(x,y))+\text{depth}'(\text{lca}'(x,y)))$ 的最大值，$n\leqslant 366666$。

这里有一个叫做边分树合并的东西，我们考虑边分治过程中，把每次分治的边看作点，分治过程中相邻两层的重边连边，当连通块大小为 $1$ 时，与点连边，这样会形成一棵二叉树，其中叶子都是原树中的点，非叶子是原树中的边。然后我们一开始把边分树拆成根节点到每个叶子节点的链，并按照某种顺序合并，注意到边分树是二叉树，所以我们可以使用和线段树合并一样的方法合并。并且对于每一条路径 $(x,y)$ 的贡献，它都可以在 $x$ 和 $y$ 第一次被合并时在边分树中 $x,y$ 的 lca 处统计到。

我们把答案改写成 $\dfrac{1}{2}(\text{dis}(x,y)+\text{depth}(x)+\text{depth}(y)-2\text{depth}'(\text{lca}'(x,y)))$ 的形式，我们考虑对第一棵树进行边分治，并建出每个点从根到这个点的边分树（$n$ 条链），我们在边分树上每个非叶子结点维护以下信息：分别来自左、右子树所包含的原树中的点中 $\text{dis}(x)+\text{depth(x)}$ 的最大值 $vl,vr$，其中 $\text{dis}(x)$ 是 $x$ 到原树中这个点对应的边某一个端点的距离。

接着我们对第二棵树进行 dfs，我们枚举 $\text{lca}'(x,y)$，每遇到一条边，就把两个端点的边分树按照线段树的合并方法合并起来，然后我们在合并过程中统计答案：假设这两棵边分树同时包括某一个点，这个点在两棵边分树的编号分别是 $u,v$，那么我们可以用 $\max(vl_u+vr_v,vr_u+vl_v)-2\text{depth}'(\text{lca}'(x,y))$ 来更新全局答案，并更新合并后的点的 $vl,vr$，不难发现这样统计的点对 $(x,y)$ 的 lca 一定都是我们当前枚举到的点。注意特判 $x=y$ 的情况和边分治前记得三度化。这样做的复杂度是 $O(n\log n)$ 的（边分治和边分树合并都是 1 个 log 的）。

可能有些细节可以看代码（懒得开 long long 所以不做猫了）：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int const N=366671;
template<unsigned M>struct graph
{
    int target[2*M],pre[2*M],last[M],tot,w[2*M];
    void add(int x,int y,int z)
    {
        target[++tot]=y;
        pre[tot]=last[x];
        last[x]=tot;
        w[tot]=z;
    }
};
graph<N>g1,g3;graph<N<<1>g2;
int n,now,siz[N<<1],nows,ed,li,cnt,mx[N<<5|1][2],ch[N<<5|1][2],last[N],dis[N],
tmp,ans=-1e18,rt[N];
bool del[N<<2];
void dfs(int x,int fa)
{
    int las=x;
    for(int i=g1.last[x];i;i=g1.pre[i])
    {
        int tar=g1.target[i];
        if(tar==fa)continue;
        g2.add(las,++now,0),g2.add(now,las,0),g2.add(now,tar,g1.w[i]),g2.add(tar,now,g1.w[i]);
        dis[tar]=dis[x]+g1.w[i];las=now;dfs(tar,x);
    }
}
void dfs2(int x,int fa,int nowd,int op)
{
    if(!op)tmp++;
    if(x<=n)
    {
        cnt++;
        if(!last[x])rt[x]=last[x]=cnt,cnt++;
        ch[last[x]][op]=cnt;
        mx[last[x]][op]=dis[x]+nowd;
        last[x]=cnt;
    }
    for(int i=g2.last[x];i;i=g2.pre[i])
    {
        int tar=g2.target[i];
        if(tar==fa||del[i])continue;
        dfs2(tar,x,nowd+g2.w[i],op);
    }
}
void get(int x,int fa)
{
    siz[x]=1;
    for(int i=g2.last[x];i;i=g2.pre[i])
    {
        int tar=g2.target[i];
        if(tar==fa||del[i])continue;
        get(tar,x);siz[x]+=siz[tar];
        if(max(siz[tar],nows-siz[tar])<li)li=max(siz[tar],nows-siz[tar]),ed=(i+1)>>1;
    }
}
void solve(int x,int s)
{
    if(s==1)return;
    ed=li=1e9;nows=s;
    get(x,0);
    int r1=g2.target[(ed<<1)-1],r2=g2.target[ed<<1];
    del[(ed<<1)-1]=del[ed<<1]=1;tmp=0;
    dfs2(r1,r2,0,0),dfs2(r2,r1,g2.w[ed<<1],1);
    int tt=siz[x]-tmp;
    solve(r1,tmp);solve(r2,tt);
}
int merge(int x,int y,int t)
{
    if((!x)||(!y))return x+y;
    ans=max(ans,max(mx[x][0]+mx[y][1],mx[y][0]+mx[x][1])+2*t);
    mx[x][0]=max(mx[x][0],mx[y][0]),mx[x][1]=max(mx[x][1],mx[y][1]);
    ch[x][0]=merge(ch[x][0],ch[y][0],t),ch[x][1]=merge(ch[x][1],ch[y][1],t);
    return x;
}
void dfs3(int x,int fa,int nowd)
{
    ans=max(ans,2*(dis[x]-nowd));
    for(int i=g3.last[x];i;i=g3.pre[i])
    {
        int tar=g3.target[i];
        if(tar==fa)continue;
        dfs3(tar,x,nowd+g3.w[i]);
        rt[x]=merge(rt[x],rt[tar],-nowd);
    }
}
signed main()
{
    memset(mx,0xc0,sizeof(mx));
    int x,y,z;
    scanf("%lld",&n);now=n;
    for(int i=1;i<n;i++)scanf("%lld%lld%lld",&x,&y,&z),g1.add(x,y,z),g1.add(y,x,z);
    dfs(1,0);
    solve(1,now);
    for(int i=1;i<n;i++)scanf("%lld%lld%lld",&x,&y,&z),g3.add(x,y,z),g3.add(y,x,z);
    dfs3(1,0,0);
    printf("%lld",ans>>1);
    return 0;
}
```


---

## 作者：ILoLy (赞：5)

**题意**:  

> 给两棵树 $A,B$ ,求 $\max depA_x+depA_y-(depA_{lca(x,y)}+depB_{lca(x,y)})$ .  
>
> $n\le366666$ .  

**题解**:  

> 点分+虚树.  
>
> 时间久远,仅口胡.  
>
> 先处理 $x=y$ 的情况.  
>
> 将柿子变形: $\frac{1}{2}(depA_x+depA_y+disA(x,y)-2depB_{lca(x,y)})$ .  
>
> (先 $\times2$ 最后再除回来).  
>
> 在 $A$ 上点分,设 $u$ 为分治中心,给每个点点权 $a_x=depA_x+disA(u,x)$ ,并按子树给每个点颜色.  
>
> (注意这里的所有点是在 $u$ 的分治范围内的点).  
>
> 再将所有点按 $B$ 建虚树,设虚树为 $C$ ,答案为 $C$ 中 $\max\limits_{col_x\not=col_y}a_x+a_y-2depB(lca(x,y))$ .  
>
> 在 $C$ 上 dp , $f[u][2]$ 记录 $u$ 子树内颜色不同的两点的最大权值及其颜色,合并时将不同颜色合并.  
>
> $O(n\log^2n)$ .  
>
> (为啥找不到点分题解啊,全是边分).  

```c++
#include <algorithm>
// #include <cstdlib>
#include <cstring>
#include <cstdio>
#include <string>
#include <queue>
#include <cmath>
#include <set>
#include <map>
#include <bitset>
using namespace std;
typedef long long LL;
typedef double db;
const int oo=2139063143;
const int N=510000;
const int P=1000000007;
const db eps=1e-7;
#define pritnf printf
//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
template <typename T>
inline void sc (T &x)
{
    x=0; static int p; p=1; static char c; c=getchar();
    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }
    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }
    x*=p;
}
template <typename T>
inline void print (T x)
{
    if (x< 0) putchar('-'),x=-x;
    if (x>=10) print(x/10);
    putchar(x%10+'0');
}
template <typename T>
inline void pr (T x) { print(x),putchar('\n'); }
template <typename T1,typename T2>
void chkmax (T1 &A,T2 B) { A=A>=B?A:B; }
template <typename T1,typename T2>
void chkmin (T1 &A,T2 B) { A=A<=B?A:B; }
int n;
struct EDGE { int v,w,nx; };
struct TREE2
{
	EDGE lb[N<<1]; int tot=1,top[N];
	void add (int u,int v,int w) { lb[++tot]=(EDGE){v,w,top[u]},top[u]=tot; }
	LL dis[N]; int dep[N],siz[N],son[N],faa[N];
	void dfs0 (int u,int fa)
	{
		dep[u]=dep[faa[u]=fa]+(siz[u]=1);
		for (int kb=top[u]; kb; kb=lb[kb].nx)
		{
			int v=lb[kb].v,w=lb[kb].w;
			if (v==fa) continue;
			dis[v]=dis[u]+w;
			dfs0 (v,u);
			siz[u]+=siz[v];
			if (siz[v]> siz[son[u]]) son[u]=v;
		}
	}
	int dfn[N],ddd[N],tf[N];
	void dfs00 (int u,int tof)
	{
		tf[u]=tof;
		ddd[dfn[u]=++dfn[0]]=u;
		if (son[u]) dfs00 (son[u],tof);
		for (int kb=top[u]; kb; kb=lb[kb].nx)
		{
			int v=lb[kb].v;
			if (v==faa[u]||v==son[u]) continue;
			dfs00 (v,v);
		}
	}
	int lca (int x,int y)
	{
		while (tf[x]!=tf[y])
		{
			if (dep[tf[x]]< dep[tf[y]]) swap (x,y);
			x=faa[tf[x]];
		}
		return dep[x]< dep[y]?x:y;
	}
}B;
LL ans=-1e18;
LL a[N]; int col[N];
struct TREE3
{
	struct EDGE { int v,nx; }lb[N]; int tot=1,top[N];
	void add (int u,int v) { lb[++tot]=(EDGE){v,top[u]},top[u]=tot; }
	int st[N],z=0;
	void init () { tot=1; z=0; }
	void ins (int x)
	{
	    if (z<=1) return st[++z]=x,void ();
	    int y=B.lca (x,st[z]);
	    if (y==st[z]) return st[++z]=x,void ();
	    while (B.dep[st[z-1]]>=B.dep[y]) add (st[z-1],st[z]),--z;
	    if (y!=st[z]) add (y,st[z]),st[z]=y;
	    st[++z]=x;
	}
	void build (int *q,int n)
	{
		init ();
		if (q[1]!=1) ins (1);
		for (int i=1; i<=n; i++)
			ins (q[i]);
		while (z> 1) add (st[z-1],st[z]),--z;
	}
	struct LY { LL w; int c; }f[N][2],O;
	void update (int u,LY x)
	{
		if (f[u][1].c==x.c) chkmax (f[u][1].w,x.w);
		else if (f[u][0].c==x.c) chkmax (f[u][0].w,x.w);
		else if (f[u][1].w< x.w) f[u][1]=x;
		if (f[u][1].w> f[u][0].w) swap (f[u][0],f[u][1]);
	}
	void dfs (int u)
	{
		f[u][0]=f[u][1]=O;
		if (col[u]) update (u,(LY){a[u],col[u]});
		col[u]=a[u]=0;
		for (int kb=top[u]; kb; kb=lb[kb].nx)
		{
			int v=lb[kb].v;
			dfs (v);
			for (int i=0; i<=1; i++)
				for (int j=0; j<=1; j++)
					if (f[u][i].c!=f[v][j].c) chkmax (ans,f[u][i].w+f[v][j].w-2*B.dis[u]);
			for (int j=0; j<=1; j++)
				update (u,f[v][j]);
		}
		top[u]=0;
	}
}C;

struct TREE1
{
	EDGE lb[N<<1]; int tot=1,top[N];
	void add (int u,int v,int w) { lb[++tot]=(EDGE){v,w,top[u]},top[u]=tot; }
	LL dis[N];
	void dfs0 (int u,int fa)
	{
		for (int kb=top[u]; kb; kb=lb[kb].nx)
		{
			int v=lb[kb].v,w=lb[kb].w;
			if (v==fa) continue;
			dis[v]=dis[u]+w;
			dfs0 (v,u);
		}
	}
	int siz[N],masiz[N]; bool vis[N]; int q[N],he,ta;
	void dfsiz (int u)
	{
		vis[u]=1;
		q[++ta]=u;
		siz[u]=1,masiz[u]=0;
		for (int kb=top[u]; kb; kb=lb[kb].nx)
		{
			int v=lb[kb].v;
			if (vis[v]) continue;
			dfsiz (v);
			siz[u]+=siz[v];
			chkmax (masiz[u],siz[v]);
		}
		vis[u]=0;
	}
	void dfsa (int u,int rt)
	{
		vis[u]=1;
		q[++ta]=u;
		col[u]=rt?rt:u;
		for (int kb=top[u]; kb; kb=lb[kb].nx)
		{
			int v=lb[kb].v,w=lb[kb].w;
			if (vis[v]) continue;
			a[v]=a[u]+w;
			dfsa (v,rt?rt:v);
		}
		vis[u]=0;
	}
	void solve (int u)
	{
		he=1,ta=0; dfsiz (u);
		int mi=oo,s=siz[u];
		for (int i=1; i<=ta; i++)
		{
			int v=q[i],ma=max (masiz[v],s-siz[v]);
			if (ma< mi) mi=ma,u=v;
		}
		he=1,ta=0; a[u]=0,dfsa (u,0);
		sort (q+1,q+ta+1,[](int x,int y) { return B.dfn[x]< B.dfn[y]; });
		for (int i=1; i<=ta; i++)
			a[q[i]]+=dis[q[i]];
		C.build (q,ta);
		C.dfs (1);
		vis[u]=1;
		for (int kb=top[u]; kb; kb=lb[kb].nx)
		{
			int v=lb[kb].v;
			if (!vis[v]) solve (v);
		}
	}
}A;

int main ()
{
    // freopen (".in","r",stdin);
    // freopen (".out","w",stdout);
	sc(n);
	for (int i=1; i< n; i++)
	{
		int x,y,w; sc(x),sc(y),sc(w);
		A.add (x,y,w),A.add (y,x,w);
	}
	for (int i=1; i< n; i++)
	{
		int x,y,w; sc(x),sc(y),sc(w);
		B.add (x,y,w),B.add (y,x,w);
	}
	A.dfs0 (1,0);
	B.dfs0 (1,0),B.dfs00 (1,1); 
	C.O.w=-1e18,C.O.c=0;
	A.solve (1);
	ans>>=1;
	for (int i=1; i<=n; i++)
		chkmax (ans,A.dis[i]-B.dis[i]);
	pr(ans);

    return 0;
}

---

## 作者：disangan233 (赞：5)

大家好这里是**点名被卡**的 $O\left(n\log^2{n}\right)$ 做法。  

PS：感谢 [yyb大佬](https://www.cnblogs.com/cjyyb/p/10197651.html) 的博客给蒟蒻的参考。  

---

### 题意

给你两颗树 $tree1$、$tree2$，让你求出： 

$$\mathrm{max} \left\{ dep(x)+dep(y)-dep(lca(x,y))-dep'(lca'(x,y)) \right\}$$ 

其中： 

$$
x,y,lca(x,y)\in \{ tree1\}\ \ \ x,y,lca'(x,y) \in \{tree2\}
$$

显然 $dep'(lca'(x,y))$ 不能直接求，考虑树形 $dp$。
* 于是我们只需要巧妙地求出 $dep(x)+dep(y)-dep(lca(x,y))$ 即可。

考虑改一下式子：

$$
Ans=\dfrac{1}{2}\left( dep(x)+dep(y)+dis(x,y)\right)
$$

因为出现了 $dis(x,y)$，考虑对于 $tree1$ 进行边分治，然后对于$tree2$ 进行 $dp$。

* 这样的时间复杂度是 $O\left( n^2\log{n}\right)$，树形 $dp$ 复杂度为 $O(n)$。 

---

考虑优化，跑虚树 $dp$，这样就可以做到 $O\left(n\log^2{n}\right)$啦！会 TLE 一个点。  

### tricks

倍增 $lca$ 太慢了，考虑 $O(n\log{n})-O(1)$ 的 `RMQ-LCA`，可以拿来卡卡常数。  

* 可以通过基数排序做到 $O\left(n\log{n}\right)$，但是窝太菜了，加加编译优化松松松就过了。


## Code(复制会Re)

```cpp
// 保证不影响观看
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
#define re register int
#define ak *
#define ll long long
inline char getch()
{
    static char buf[10000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;
}
#define gc() getch()
char qwq;
inline ll read()
{
    ll cz=0,ioi=1;qwq=gc();
    while(qwq<'0'||qwq>'9') ioi=qwq=='-'?~ioi+1:1,qwq=gc();
    while(qwq>='0'&&qwq<='9') cz=(cz<<3)+(cz<<1)+(qwq^48),qwq=gc();
    return cz ak ioi;
}
const int M=400005;
int ans[2][M],num[2],tp[M],m;
ll res=-1e18,w[M];
namespace t2
{
    int cnt=1,h[M],dfn[M],low[M],sum,tim,dep[M],st[M<<1][21];
    int lg2[M<<1],fir[M],vis[M];
    ll f[M][2],dis[M];
    struct did{int next,to;ll w;}e[M<<1];
    void add(re x,re y,ll z) {e[++cnt]=(did){h[x],y,z},h[x]=cnt;}
    void dfs(re u,re fa)
    {
        dep[u]=dep[fa]+1;dfn[u]=++tim;
        st[++sum][0]=u;fir[u]=sum;
        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)
        {
            if(v==fa) continue;
            dis[v]=dis[u]+e[i].w;dfs(v,u);
            st[++sum][0]=u;
        }
        low[u]=tim;
    }
    int cmp(re x,re y) {return dep[x]<dep[y]?x:y;}
    void ST()
    {
        for(re i=2;i<=sum;i++) lg2[i]=lg2[i>>1]+1;
        for(re j=1;j<=lg2[sum];j++)
        for(re i=1;i+(1<<j)-1<=sum;i++)
        st[i][j]=cmp(st[i][j-1],st[i+(1<<(j-1))][j-1]);
        memset(h,0,sizeof(h));
    }
    int lca(re u,re v)
    {
        u=fir[u],v=fir[v];if(u>v) swap(u,v);
        re k=lg2[v-u+1];
        return cmp(st[u][k],st[v-(1<<k)+1][k]);
    }
    void dp(re u,ll sum)
    {
        f[u][0]=f[u][1]=-1e18;
        if(vis[u]) f[u][tp[u]]=w[u];
        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)
        {
            dp(v,sum);ll nw=max(f[u][0]+f[v][1],f[u][1]+f[v][0]);
            res=max(res,sum+nw-2*dis[u]);
            f[u][0]=max(f[u][0],f[v][0]);
            f[u][1]=max(f[u][1],f[v][1]);
        }
        vis[u]=h[u]=0;
    }
    int q[M<<1],stk[M],tot;
    bool dfn_cmp(int a,int b){return dfn[a]<dfn[b];}
    void svt(ll sum)
    {
        cnt=1;tot=0;
        for(re i=1;i<=num[0];i++) q[++tot]=ans[0][i];
        for(re i=1;i<=num[1];i++) q[++tot]=ans[1][i];
        for(re i=1;i<=tot;i++) vis[q[i]]=1;
        sort(q+1,q+tot+1,dfn_cmp);
        re top=0; if(q[1]!=1) stk[++top]=1;
        for(re i=1;i<=tot;i++)
        {
            re u=q[i],v=lca(u,stk[top]);
            while(top>1&&dep[stk[top-1]]>=dep[v])
            add(stk[top-1],stk[top],0),top--;
            if(v!=stk[top]) add(v,stk[top],0),stk[top]=v;
            stk[++top]=u;
        }
        while(top>1) add(stk[top-1],stk[top],0),top--;
        dp(1,sum);
    }
};
namespace t1
{
    int cnt=1,h[M<<2],size[M<<2],vis[M<<2],n,ct,maxn;
    ll dis[M<<2],dep[M<<2];
    struct did{int next,to;ll w;}e[M<<3];
    struct par{int a,b;par() {} par(re x,re y) : a(x),b(y) {}};
    vector<par>ve[M<<2];
    void add(re x,re y,ll z)
    {
        e[++cnt]=(did){h[x],y,z},h[x]=cnt;
        e[++cnt]=(did){h[y],x,z},h[y]=cnt;
    }
    void pre(re u,re fa)
    {
        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)
        {
            if(v==fa) continue;
            ve[u].push_back(par(v,e[i].w));
            dep[v]=dep[u]+e[i].w,pre(v,u);
        }
    }
    void rebuild()
    {
        memset(h,0,sizeof(h));cnt=1;
        for(re x=1;x<=n;x++)
        {
            re sz=ve[x].size();
            if(sz<=2)
            {
                for(re i=0;i<sz;i++)
                add(x,ve[x][i].a,ve[x][i].b);
            }
			else
            {
                re ls=++n,rs=++n;
                add(x,ls,0);add(x,rs,0);
                for(re i=0;i<sz;i++)
                ve[i&1?ls:rs].push_back(par(ve[x][i].a,ve[x][i].b));
            }
        }
    }
    void find_ct(re u,re fa,re sum)
    {
        size[u]=1;
        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)
        {
            if(v==fa||vis[i>>1]) continue;
            find_ct(v,u,sum);size[u]+=size[v];
            re now=max(size[v],sum-size[v]);
            if(maxn>now) maxn=now,ct=i;
        }
    }
    void dfs(re u,re fa,re pos)
    {
        if(u<=m) ans[pos][++num[pos]]=u,tp[u]=pos;
        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)
        {
            if(v==fa||vis[i>>1]) continue;
            dis[v]=dis[u]+e[i].w,dfs(v,u,pos);
        }
    }
    bool getans()
    {
        if(!num[0]&&!num[1]) return 0;
        for(re i=1;i<=num[0];i++) w[ans[0][i]]+=dis[ans[0][i]]+dep[ans[0][i]];
        for(re i=1;i<=num[1];i++) w[ans[1][i]]+=dis[ans[1][i]]+dep[ans[1][i]];
        t2::svt(e[ct].w);
        for(re i=1;i<=num[0];i++) w[ans[0][i]]-=dis[ans[0][i]]+dep[ans[0][i]];
        for(re i=1;i<=num[1];i++) w[ans[1][i]]-=dis[ans[1][i]]+dep[ans[1][i]];
        return 1;
    }
    void divide(re u,re sum)
    {
        maxn=1e9,find_ct(u,0,sum);
        if(maxn>=1e9) return;
        re s=e[ct].to,t=e[ct^1].to;vis[ct>>1]=1;
        num[0]=num[1]=dis[s]=dis[t]=0;
        dfs(s,0,0);dfs(t,0,1);
        if(!getans()) return;
        re nw=ct,ss=sum-size[e[nw].to];
        divide(s,size[e[nw].to]);divide(t,ss);
    }
};
int main()
{
    int sized=40<<20;
    __asm__ ("movq %0,%%rsp\n"::"r"((char*)malloc(sized)+sized));
    t1::n=m=read();
    for(re i=1;i<m;i++)
    {
        re x=read(),y=read(),z=read();
        t1::add(x,y,z);
    }
    for(re i=1;i<m;i++)
    {
        re x=read(),y=read(),z=read();
        t2::add(x,y,z);t2::add(y,x,z);
    }
    t1::pre(1,0);t1::rebuild();
    t2::dfs(1,0);t2::ST();
    t1::divide(1,t1::n);
    res/=2;
    for(re i=1;i<=m;i++) res=max(res,t1::dep[i]-t2::dis[i]);
    printf("%lld\n",res);
    return 0; 
}
```

---

## 作者：TTpandaS (赞：3)

以下所提的深度均为题目所指深度。

考虑一些正确性较优秀的算法。

第一种，枚举第一棵树上的点作为 lca，找到以该节点为 lca 的深度最大的两个点计算答案。

第二种，枚举第二棵树上的点作为 lca，找到以该节点为 lca 的深度最大的两个点计算答案。

第三种，将所有点按照在第一棵树上的深度从大到小排序，对于每个点，只与深度最大的 $\dfrac{B}{n}$ 个点和其后 $\dfrac{B}{n}$ 个点计算答案。考虑时间的正确性，$B$ 取 $10^7$。

将三种算法结合即可通过。

注意，一个点可以和自己计算答案，否则只有 $90$ 分。

稍微卡一下常数，现为洛谷最优解。以下为未卡常数的正常代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int Tim=1;
const long long inf=1e18;
const int N=4e5+5;
int n;
vector<pair<int,long long> > g[N][2];
int dep[N][2],son[N][2],siz[N][2],top[N][2],fa[N][2];
long long len[N][2];
void dfs1(int x,int faa,int op){
	dep[x][op]=dep[faa][op]+1;
	siz[x][op]=1;
	fa[x][op]=faa;
	for(auto it:g[x][op]){
		int y=it.first;
		long long z=it.second;
		if(y==faa){
			continue;
		}
		len[y][op]=len[x][op]+z;
		dfs1(y,x,op);
		siz[x][op]+=siz[y][op];
		if(siz[y][op]>siz[son[x][op]][op]){
			son[x][op]=y;
		}
	}
}
void dfs2(int x,int faa,int topp,int op){
	top[x][op]=topp;
	if(son[x][op]){
		dfs2(son[x][op],x,topp,op);
	}
	for(auto it:g[x][op]){
		int y=it.first;
		if(y==faa||y==son[x][op]){
			continue;
		}
		dfs2(y,x,y,op);
	}
}
int LCA(int x,int y,int op){
	while(top[x][op]!=top[y][op]){
		if(dep[top[x][op]][op]<dep[top[y][op]][op]){
			swap(x,y);
		}
		x=fa[top[x][op]][op];
	}
	if(dep[x][op]>dep[y][op]){
		swap(x,y);
	}
	return x;
}
int p[N];
bool cmp2(int x,int y){
	return len[x][0]>len[y][0];
}
long long maxn[N];
int pos[N];
long long ans;
void dfs(int x,int faa){
	maxn[x]=len[x][0];
	pos[x]=x;
	long long nm=-inf;
	int npos=0;
	for(auto it:g[x][0]){
		int y=it.first;
		if(y==faa){
			continue;
		}
		dfs(y,x);
		if(maxn[y]>=maxn[x]){
			nm=maxn[x];
			npos=pos[x];
			pos[x]=pos[y];
			maxn[x]=maxn[y];
		}
		else if(maxn[y]>=nm){
			nm=maxn[y];
			npos=pos[y];
		}
	}
	if(npos){
		ans=max(ans,len[pos[x]][0]+len[npos][0]-len[x][0]-len[LCA(pos[x],npos,1)][1]);
	}
}
long long maxn2[N];
int pos2[N];
void ddfs(int x,int faa){
	maxn2[x]=len[x][0];
	pos2[x]=x;
	long long nm=-inf;
	int npos=0;
	for(auto it:g[x][1]){
		int y=it.first;
		if(y==faa){
			continue;
		}
		ddfs(y,x);
		if(maxn2[y]>=maxn2[x]){
			nm=maxn2[x];
			npos=pos2[x];
			pos2[x]=pos2[y];
			maxn2[x]=maxn2[y];
		}
		else if(maxn2[y]>=nm){
			nm=maxn2[y];
			npos=pos2[y];
		}
	}
	if(npos){
		ans=max(ans,len[pos2[x]][0]+len[npos][0]-len[LCA(pos2[x],npos,0)][0]-len[x][1]);
	}
}
void Solve(){
	cin>>n;
	for(int i=1,x,y;i<n;i++){
		long long z;
		cin>>x>>y>>z;
		g[x][0].push_back({y,z});
		g[y][0].push_back({x,z});
	}
	for(int i=1,x,y;i<n;i++){
		long long z;
		cin>>x>>y>>z;
		g[x][1].push_back({y,z});
		g[y][1].push_back({x,z});
	}
	dfs1(1,0,0);
	dfs2(1,0,1,0);
	dfs1(1,0,1);
	dfs2(1,0,1,1);
	long long minn1=inf,minn2=inf;
	for(int i=1;i<=n;i++){
		minn1=min(minn1,len[i][0]);
		minn2=min(minn2,len[i][1]);
	}
	for(int i=1;i<=n;i++){
		p[i]=i;
	}
	ans=-inf;
	sort(p+1,p+n+1,cmp2);
	dfs(1,0);
	ddfs(1,0);
	int B=10000000;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i-B/n+1&&j<=B/n;j++){
			int x=p[i],y=p[j];
			if(len[x][0]+len[y][0]-minn1-minn2<=ans){
				break;
			}
			ans=max(ans,len[x][0]+len[y][0]-len[LCA(x,y,0)][0]-len[LCA(x,y,1)][1]);
		}
		for(int j=i;j<=i+B/n&&j<=n;j++){
			int x=p[i],y=p[j];
			if(len[x][0]+len[y][0]-minn1-minn2<=ans){
				break;
			}
			ans=max(ans,len[x][0]+len[y][0]-len[LCA(x,y,0)][0]-len[LCA(x,y,1)][1]);
		}
	}	
	cout<<ans<<'\n';
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	//cin>>Tim;
	while(Tim--){
		Solve();
	}
	return 0;
}
```

---

## 作者：ZillionX (赞：3)

# Description

给定大小为 $n$ 的两棵有根树 $T_1,T_2$，两棵树均以 $1$ 为根，边有权值。定义 ${\rm dep}_x$ 为根到 $x$ 的距离，求

$$\max_{x\le y} {{\rm dep}T_1}_x+{{\rm dep}T_1}_y-{{\rm dep}T_1}_{{\rm LCA}(x,y)}-{{\rm dep}T_2}_{{\rm LCA}(x,y)}$$

。

$n \le 366666, |V| \le 2017011328$，时限 4s。

# Solution

典型的树上距离问题，不妨考虑对 $T_1$ 进行点分治。

${\rm LCA}(x,y)$ 不是很好看，我们可以把原式转化成

$$\dfrac{1}{2}\bigg({{\rm dep}T_1}_x+{{\rm dep}T_1}_y+ {\rm dis}{T_1}(x,y)-2{{\rm dep}T_2}_{{\rm LCA}(x,y)}\bigg)$$

在以 $1$ 为根时，${{\rm dep}T_1}_x$ 和 ${{\rm dep}T_1}_y$ 都很容易被预处理出来。而假设目前点分治的分治中心为 $u$，${\rm dis}{T_1}(x,y)$ 又可以被写成 ${\rm dis}{T_1}(u,x)+{\rm dis}{T_1}(u,y)$。

因此我们可以给每个点（这里的每个点都是 $u$ 的分治范围内的）赋一个点值 $v_x={{\rm dep}T_1}_x+{\rm dis}{T_1}(u,x)$。此时对应到 $T_2$ 上，我们要求出的答案即为

$$\max v_x+v_y-2{{\rm dep}T_2}_{{\rm LCA}(x,y)}$$

（注意到假如 $x,y$ 来自 $T_1$ 中 $u$ 的同一棵子树，这样会算重，所以需要在赋点值时同时给 $T_1$ 中来自 $u$ 的不同子树的点染不同的颜色）

这个显然就可以用树形 DP 来处理。设 $f_{u,0/1}$ 表示 $u$ 子树内颜色不同的两个点的最大点值及颜色（不要和上面的 $u$ 搞混了）。转移时将不同子树的 $f$ 合并即可，答案也可以在合并时同时求出来。这是 NOIP 范围内的 DP，这里不做过多讲解。

但是假如对整棵 $T_2$ 进行树形 DP 显然是不行的。所以我们要将 $T_1$ 上 $u$ 的分治范围内的点投影到 $T_2$ 上建一棵虚树，在虚树上跑 DP，这样复杂度就有了保证。

最后切记处理 $x=y$ 的情况。

至此我们在 $\mathcal O(n \log^2 n)$ 的时间复杂度内完成了本题。

# Code

代码写的很丑。

```cpp
#include <bits/stdc++.h>
#define int long long
#define cmx(x,y) x=max(x,y)
using namespace std;
const int N=8e5+5;
int n,sl[N],sz[N],rt,Sum,dfsc,Ans=-1e18,dep1[N],dis[N],fa[N],s[N],d[N],zs[N],tp[N],st[N],top,dep2[N],dis2[N],dfn2[N],a[N],col[N];
bool vis[N],fl;
bool mdfk[N];
struct Grp {
	int NumE,Fir[N];
	struct Edge {
		int v,w,nxt;
	}E[N];
	void AddE(int u,int v,int w) {
		E[++NumE]=(Edge){v,w,Fir[u]};
		Fir[u]=NumE;
	}
}T1,T2,X;
void Dfs1(int x,int ft) {
	fa[x]=ft,s[x]=1,d[x]=d[ft]+1;
    for (int i=T2.Fir[x];i;i=T2.E[i].nxt) 
    	if (T2.E[i].v!=ft) {
    		Dfs1(T2.E[i].v,x);
			s[x]+=s[T2.E[i].v];
        	if (s[zs[x]]<s[T2.E[i].v]) zs[x]=T2.E[i].v;
		}
}
void Dfs2(int x,int ft) {
	tp[x]=ft;
    if (!zs[x]) return;
	Dfs2(zs[x],ft);
    for (int i=T2.Fir[x];i;i=T2.E[i].nxt)
      	if (T2.E[i].v!=fa[x] && T2.E[i].v!=zs[x])
			Dfs2(T2.E[i].v,T2.E[i].v);
}
int LCA(int x,int y) {
	while (tp[x]!=tp[y]) {
		if (d[tp[x]]<d[tp[y]]) swap(x,y);
		x=fa[tp[x]];
	}
	if (d[x]>d[y]) swap(x,y);
	return x;
}
void GetR(int x,int fa) {
	sl[x]=0,sz[x]=1;
	for (int i=T1.Fir[x];i;i=T1.E[i].nxt) {
		if (!vis[T1.E[i].v] && T1.E[i].v!=fa) {
			if (!fl) dep1[T1.E[i].v]=dep1[x]+T1.E[i].w;
			GetR(T1.E[i].v,x);
			sl[x]=max(sl[x],sz[T1.E[i].v]);
			sz[x]+=sz[T1.E[i].v];
		}
	}
	sl[x]=max(sl[x],Sum-sz[x]);
	if (sl[x]<sl[rt]) rt=x;
}
int cnt;
struct ddd {
	int v,id,col;
	bool operator<(const ddd &x) const {
		return dfn2[id]<dfn2[x.id];
	}
}p[N];
void GetD(int x,int fa,int gua) {
	p[++cnt]=(ddd){dis[x]+dep1[x],x,gua};
	for (int i=T1.Fir[x];i;i=T1.E[i].nxt) {
		int to=T1.E[i].v;
		if (!vis[to] && to!=fa) {
			dis[to]=dis[x]+T1.E[i].w;
			GetD(to,x,gua);
		}
	}
}
void gsmg(int x,int fa) {
	dfn2[x]=++dfsc;
	dep2[x]=dep2[fa]+1;
	for (int i=T2.Fir[x];i;i=T2.E[i].nxt) {
		int to=T2.E[i].v;
		if (to!=fa) {
			dis2[to]=dis2[x]+T2.E[i].w;
			gsmg(to,x);
		}
	}
}
void InsV(int x) {
	if (!top) {
		st[1]=x,top=1;
		return;
	}
	int lca=LCA(st[top],x);
	while (top>1 && dep2[lca]<dep2[st[top-1]])
		X.AddE(st[top-1],st[top],0),top--;
	if (dep2[lca]<dep2[st[top]])
		X.AddE(lca,st[top],0),top--;
	if (!top || st[top]!=lca) st[++top]=lca;
	st[++top]=x;
}
struct jjzf {
	int v,c;
}f[N][2];
void Chg(int x,jjzf y) {
	if (f[x][0].c==y.c) cmx(f[x][0].v,y.v);
	else if (f[x][1].c==y.c) cmx(f[x][1].v,y.v);
	else if (f[x][1].v<y.v) f[x][1]=y;
	if (f[x][0].v<f[x][1].v) swap(f[x][0],f[x][1]);
}
void Dp2(int u) {
	f[u][0].v=f[u][1].v=-1e18;
	f[u][0].c=f[u][1].c=0;
	if (col[u]) Chg(u,(jjzf){a[u],col[u]});
	col[u]=a[u]=0;
	for (int i=X.Fir[u];i;i=X.E[i].nxt) {
		int to=X.E[i].v;
		Dp2(to);
		for (int j=0;j<=1;j++)
			for (int k=0;k<=1;k++)
				if (f[u][j].c!=f[to][k].c)
					cmx(Ans,f[u][j].v+f[to][k].v-dis2[u]*2);
		Chg(u,f[to][0]),Chg(u,f[to][1]);
	}
	X.Fir[u]=0;
}
void Dfs(int u) {
	dis[u]=0;
	vis[u]=1;
	cnt=0;
	p[++cnt]=(ddd){dep1[u],u,u};
	for (int i=T1.Fir[u];i;i=T1.E[i].nxt) {
		int to=T1.E[i].v;
		if (!vis[to]) {
			dis[to]=dis[u]+T1.E[i].w;
			GetD(to,u,to);
		}
	}
	GetR(u,0);
	sort(p+1,p+cnt+1);
	top=0;
	if (p[1].id!=1) InsV(1);
	for (int i=1;i<=cnt;i++) InsV(p[i].id),a[p[i].id]=p[i].v,col[p[i].id]=p[i].col;
	if (top) {
		while (--top) X.AddE(st[top],st[top+1],0)/*,printf("%lld %lld\n",st[top],st[top+1])*/;
	}
	Dp2(1);
	for (int i=1;i<=X.NumE;i++) X.E[i]=(Grp::Edge){0,0,0};
	X.NumE=0;
	for (int i=T1.Fir[u];i;i=T1.E[i].nxt) {
		int to=T1.E[i].v;
		if (!vis[to]) {
			rt=0,Sum=sz[to],sl[0]=n;
			GetR(to,u);Dfs(rt);
		}
	}
}
signed main() {
	scanf("%lld",&n);
	for (int i=1;i<n;i++) {
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		T1.AddE(x,y,z),T1.AddE(y,x,z);
	}
	for (int i=1;i<n;i++) {
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		T2.AddE(x,y,z),T2.AddE(y,x,z);
	}
	Sum=sl[0]=n;
	GetR(1,0);fl=1;
	gsmg(1,0);
	Dfs1(1,0),Dfs2(1,1);
//	printf("%lld\n",LCA(4,5));
//	for (int i=1;i<=n;i++) printf("%lld\n",dep2[i]);
	Dfs(rt);
	Ans/=2;
	for (int i=1;i<=n;i++) cmx(Ans,dep1[i]-dis2[i]);
	printf("%lld",Ans);
	return 0;
}
```


---

## 作者：TangyixiaoQAQ (赞：2)

# 题意简析

给出两棵树，每棵树有 $n$ 个节点，求点对 $(x, y)$，使得下式最大化：

$$

\mathrm{deep}_x + \mathrm{deep}_y - \mathrm{deep}_{\mathrm{LCA}(x, y)} - \mathrm{deep'}_{\mathrm{LCA'}(x, y)}

$$

$n \le 366666$，边权可能为负。

# 思路解析

## [点分治/边分治](https://oi-wiki.org/graph/tree-divide/) 做法

![1784X1419/graph.png](https://tc.z.wiki/autoupload/f/zxQNBpW_35CgDFweEyl5EA/20250726/gjO4/1784X1419/graph.png)

以点分治为例，在有根的情况下分治结构如上。设 $root$ 为根节点，$x$ 是当前的重心。

显然的，非 $root$ 所在的其余子树 $son_1,son_2,son_{\cdots}$ ，地位相等，正常合并。

对于 $root$ 所在的部分，还需要分类讨论成 $fa_1, fa_2,fa_{\cdots},root$ 这几种情况。

对于每个部分分别暴力统计，显然是会超时的。依据经验，做有根点分治/边分治题目时，要利用题目中的特殊性质。

- 利用 LCA 与另一个点无关的性质，将影响范围缩小到系数。
- 利用题目的特殊性质，将 $root$ 所在的部分进行动态单点查询。
- 有根的关键点不在 LCA（与本题无关）

---

为简化思考过程，以使用边分治为例。

对于跨越了中心边的点对 $(x, y)$，假设 $y$ 处于根所在的连通块，且处在局部根为 $r$ 的部分。则题中所要求的量转化为：

$$\mathrm{deep}_r + \mathrm{deep}_y - \mathrm{deep}_{\mathrm{LCA}(r, y)} - \mathrm{deep}_{\mathrm{LCA}(x', y)}$$

其中 $x'$ 与 $y$ 无关，于是可以把这部分贡献直接计算到 $y$ 上。

现在所求的量为带点权的第二棵树上的 LCA 深度的最小值。仍然建立虚树进行树形 DP。时间复杂度 $\mathcal{O}(n \log^2 n)$ 或 $\mathcal{O}(n \log n)$。


但是如果我们不会写虚树呢？


## [树上启发式合并（dsu on tree）](https://oi-wiki.org/graph/dsu-on-tree/)做法

我们可以有两种写法：

1. 完全启发性合并，优点是十分短小精悍。（~~其实是我点分治调了两年半~~）
2. 先树链剖分选出重儿子，再暴力枚举轻儿子进行合并，优点是不会拆除父亲所在的部分。

对第一棵树进行重链剖分，利用 DSU on Tree 处理每个节点。对每个节点 $x$，考虑以 $x$ 为 LCA 的点对 $(u, v)$，其中 $u$ 和 $v$ 属于 $x$ 的不同子树。

在第二棵树上进行树链剖分，对每条重链维护树状数组以支持动态更新和查询。对于每个点 $v$，维护 $a[v] = \text{depth}_T(v)$（第一棵树中的深度）。动态添加/删除点时，更新重链和轻儿子子树的信息。

# 代码实现

$$

\log(366666) \approx 13

$$

点分治十分通用，边分治思路简单，对它们做树形 DP，可以在 $\mathcal{O}(n \log^2 n)$ 和 $\mathcal{O}(n \log n)$ 时间内解决。

DSU on Tree 的思路更加清新，时间复杂度 $\mathcal{O}(n \log^3 n)$。但是，我们可以考虑使用数据结构优化，使得时间复杂度降低到 $\mathcal{O}(n \log^2 n)$，但常数大。或者也可以用小常数的树状数组进行优化，详见[这篇题解](https://www.luogu.com.cn/article/047gfyq5)。


由于 $n \le 366666$，记得使用较快的输入方式。

# 后记

~~暴力写挂的这个标题很具有喜感啊。~~

---

## 作者：XZhuRen (赞：2)

图床挂了，重传。

一种不用脑子的小常数 $\log^3$ 做法……和目前其他题解不一样。

考虑询问的形状。

给定两棵树 $t1,t2$，接下来带的下标就是树编号。

对于任意**可相同**两点 $x,y$，求:

$(d_1(x)+d_1(y)-d_1(lca_1(x,y)))-d_2(lca_2(x,y))$

即：这两点在 $t1$ 上的路径**并**减去在 $t2$ 上的路径**交**。

考虑 $\text{Dsu On Tree}$，路径并不是很好确定，考虑路径交一定是当前 $t2$ 上 $lca(x,y)$ 的深度。

用 $\text{Dsu On Tree}$ 化简了 $t2$ 上的问题，转而到了求 $t1$ 的问题：

合并的根为 $u$，对于已有的一个点集 $S$，对于当前的一个点 $x$，对于任意的 $y\in S$，$lca_1(x,y)=u$，现在要求：对于每一个 $y$，$x$ 与 $y$ 在 $t2$ 上到根路径并的最大值。

考虑对 $t2$ 树剖，我们考虑在 $lca$ 处统计答案，则如图：

[![pEDR2QA.png](https://s21.ax1x.com/2025/03/26/pEDR2QA.png)](https://imgse.com/i/pEDR2QA)

有这样几种情况：

1. $x$ 子树内的任何点可以作为答案。

2. $x$ 从重儿子跳上去，则任意**祖先**的轻儿子作为答案。

3. $x$ 从轻儿子跳上去，任意非 $x$ 所属的轻儿子和重儿子都作为答案。

考虑这怎么维护，直接树状数组对每条重链维护前缀最大值，可以解决 $\text{case 2}$，维护后缀最大值可以解决 $\text{case 1}$。

前缀最大值即：对于一个节点 $u$，它的轻儿子内节点的最深深度为 $D$，则权值为 $D-d_2(u)$。

后缀最大值即：对于一个节点，它的子树内的节点最深深度为 $D$，则权值为 $D$。

考虑 $\text{case 3}$，这里考虑直接用堆维护一个每个轻儿子内的最深深度即可，用的时候是均摊 $\Theta (1)$ 取的，重儿子直接查 v 在链上的后继的后缀最大值即可。

所以总共需要维护两个 $\text{BIT}$，一个堆。

时间复杂度 $\mathcal{O}(n\log_2^3n)$，实际跑很快，最慢点 $2s$ 左右。

注意细节，合并的时候注意单点情况，所以对于当前点 $u$，是先 $ins(u)$ 再 $query(u)$ 的。
 
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll1;
#define int long long
#define mkp make_pair
const ll1 inf=1e18;
const int N=1e6+5;
struct edge{
	int u,v,nxt;
	ll1 w;
};
int n;
namespace bit{//链前缀最大值
	#define lowbit(x) (x&-x)
	ll1 bit[N];
	void mdf(int st,int ed,int x,ll1 y){
		st--;x-=st;
		for(;x>0&&x<=ed-st;x+=lowbit(x))bit[x+st]=max(y,bit[x+st]);
	}
	void m0(int st,int ed,int x){
		st--;x-=st;
		for(;x>0&&x<=ed-st;x+=lowbit(x))bit[x+st]=-inf;
	}
	ll1 qmx(int st,int ed,int x){
		if(x<st||x>ed)return -inf;
		ll1 res=-inf;st--;x-=st;
		for(;x>0;x-=lowbit(x))res=max(res,bit[x+st]);
		return res;
	}
	void init(){for(int i=1;i<=n;i++)bit[i]=-inf;}
	#undef lowbit
}
namespace bit1{//倒着的链修改后缀最大值（轻子树）
	#define lowbit(x) (x&-x)
	ll1 bit[N];
	void mdf(int st,int ed,int x,ll1 y){
		st--;x=ed-x+1;
		for(;x>0&&x<=ed-st;x+=lowbit(x))bit[x+st]=max(y,bit[x+st]);
	}
	void m0(int st,int ed,int x){
		st--;x=ed-x+1;
		for(;x>0&&x<=ed-st;x+=lowbit(x))bit[x+st]=-inf;
	}
	ll1 qmx(int st,int ed,int x){
		ll1 res=-inf;
		st--;x=ed-x+1;
		for(;x>0;x-=lowbit(x))res=max(res,bit[x+st]);
		return res;
	}
	void init(){for(int i=1;i<=n;i++)bit[i]=-inf;}
	#undef lowbit
}
namespace t1{
	edge g[N*2];
	int head[N],tote=0;
	void ae(int u,int v,ll1 w){g[++tote]=(edge){u,v,head[u],w};head[u]=tote;}
	priority_queue<pair<ll1,int> >sons[N];//轻子树的每个儿子答案
	int dfn[N],tdfn=0;
	int fa[N],top[N],bot[N];//每条链的头/尾
	ll1 d[N];int sz[N],hs[N];
	void dfs1(int u,int Fa,int D){
		fa[u]=Fa,d[u]=D,sz[u]=1;
		for(int e=head[u],v;e;e=g[e].nxt){
			v=g[e].v;if(v==Fa)continue;
			dfs1(v,u,D+g[e].w);
			sz[u]+=sz[v];
			if(sz[v]>sz[hs[u]])hs[u]=v;
		}
	}
	void dfs2(int u,int Top){
		top[u]=Top;
		dfn[u]=++tdfn;
		if(hs[u])dfs2(hs[u],Top),bot[u]=bot[hs[u]];
		else bot[u]=u;
		for(int e=head[u],v;e;e=g[e].nxt){
			v=g[e].v;if(v==fa[u]||v==hs[u])continue;
			dfs2(v,v);
		}
	}
	int cp[N];bool vc[N];//轻子树修改的点=等于放que的点
	int tc=0;
	ll1 mxs[N];
	int ms[N];bool mc[N];
	int tm=0;
	void clear(){
		int u;
		while(tc){
			u=cp[tc--];
			while(!sons[u].empty())sons[u].pop();
			bit::m0(dfn[top[u]],dfn[bot[u]],dfn[u]);
			bit1::m0(dfn[top[u]],dfn[bot[u]],dfn[u]);
			vc[u]=0;
		}
		while(tm){
			u=ms[tm--];
			mc[u]=0;mxs[u]=-inf;
		}
	}
	void init(){
		dfs1(1,0,0),dfs2(1,1);
		bit::init();bit1::init();
		for(int i=1;i<=n;i++)mxs[i]=-inf;
	}
	ll1 query(int u){
		ll1 dd=d[u];
		ll1 res=-inf;int v;
		ll1 opers=-inf;
		res=max(res,bit1::qmx(dfn[top[u]],dfn[bot[u]],dfn[u]))-d[u];//查这个链后面的，相当于子树查询
		while(u){
			res=max(res,bit::qmx(dfn[top[u]],dfn[bot[u]],dfn[u]-1));//链前缀最大，不包含本身（视为轻子树跳上来的）
			u=top[u],v=fa[u];
			if(!v)break;
			if(v!=bot[v])res=max(res,bit1::qmx(dfn[top[v]],dfn[bot[v]],dfn[v]+1)-d[v]);//链后缀最大
			if(!sons[v].empty()){
				opers=-inf;
				if(sons[v].top().second==u)
					opers=sons[v].top().first;//轻子树询问
				while(!sons[v].empty()){
					if(sons[v].top().second==u){
						sons[v].pop();
					}else break;
				}
				if(!sons[v].empty())res=max(res,sons[v].top().first-d[v]);
				if(opers!=-inf)sons[v].push(mkp(opers,u));
			}
			u=v;
		}
		return res+dd;
	}
	void ins(int u){//加入 u
		ll1 dd=d[u];
		bit::mdf(dfn[top[u]],dfn[bot[u]],dfn[u],dd-d[u]);//取更大
		if(!vc[u])cp[++tc]=u;
		vc[u]=1;
		int v=fa[top[u]];
		for(;u;u=v){
			bit1::mdf(dfn[top[u]],dfn[bot[u]],dfn[u],dd);
			u=top[u],v=fa[u];
			if(!v)break;
			if(!vc[v])cp[++tc]=v;
			vc[v]=1;
			if(!mc[u])ms[++tm]=u;
			mc[u]=1;
			if(mxs[u]>=dd)continue;
			sons[v].push(mkp(dd,u));
			bit::mdf(dfn[top[v]],dfn[bot[v]],dfn[v],dd-d[v]);//取更大
		}
	}
}
ll1 Ans=-inf;
namespace t2{
	edge g[N*2];
	int head[N],tote=0;
	void ae(int u,int v,ll1 w){g[++tote]=(edge){u,v,head[u],w};head[u]=tote;}
	ll1 d[N];
	int sz[N],hs[N],fa[N];
	void dfs1(int u,int Fa,int D){
		fa[u]=Fa,d[u]=D,sz[u]=1;
		for(int e=head[u],v;e;e=g[e].nxt){
			v=g[e].v;if(v==Fa)continue;
			dfs1(v,u,D+g[e].w);
			sz[u]+=sz[v];
			if(sz[v]>sz[hs[u]])hs[u]=v;
		}
	}
	void init(){dfs1(1,0,0);}
	void Q(int u,int nw){Ans=max(Ans,-d[nw]+t1::query(u));}
	void solve1(int u,int nw){
		Q(u,nw);
		for(int v,e=head[u];e;e=g[e].nxt){
			v=g[e].v;if(v==fa[u])continue;
			solve1(v,nw);
		}
	}
	void solve2(int u){
		t1::ins(u);
		for(int v,e=head[u];e;e=g[e].nxt){
			v=g[e].v;if(v==fa[u])continue;
			solve2(v);
		}
	}
	void solve(int u){
		for(int e=head[u],v;e;e=g[e].nxt){
			v=g[e].v;if(v==fa[u]||v==hs[u])continue;
			solve(v);
			t1::clear();
		}
		if(hs[u])solve(hs[u]);
		t1::ins(u);Q(u,u);
		for(int e=head[u],v;e;e=g[e].nxt){
			v=g[e].v;if(v==fa[u]||v==hs[u])continue;
			solve1(v,u),solve2(v);
		}
	}
}
void init(){
	scanf("%lld",&n);
	int u,v;ll1 w;
	for(int i=1;i<n;i++){
		scanf("%lld%lld%lld",&u,&v,&w);
		t1::ae(u,v,w),t1::ae(v,u,w);
	}
	for(int i=1;i<n;i++){
		scanf("%lld%lld%lld",&u,&v,&w);
		t2::ae(u,v,w),t2::ae(v,u,w);
	}
	t1::init();
	t2::init();
}
void work(){
	t2::solve(1);
	printf("%lld\n",Ans);
}
signed main(){
	init();
	work();
	return 0;
}
/*
给定两棵树，求：
Max{
	d1(x)+d1(y)−d1(LCA1(x,y))-d2(LCA2(x,y))
	即：第一颗树上两节点到根路径并-第二棵树上到根路径交
}
直接对第二棵树上的到根路径交 dsu on tree
这样就可以转化为：
所有 LCA 为 u 的点对中，到根路径并的最大值
考虑如何让到根路径并最大，一定是让 LCA 尽可能浅。
考虑求到根上每一个点的最大的：
-d[x]+val[x]，val[x] 即不在 x 子树中的最值。
这个并不好搞
考虑分为两种：
1.从重儿子跳上去，val[x] 为轻子树最值。
2.从轻儿子跳上去，val[x] 即维护每个轻儿子的最值和重儿子权值的最大值
而：重链剖分线段树只要维护轻/重儿子的最值就好
*/
```

---

## 作者：_Ch1F4N_ (赞：2)

忘记是谁推荐写的了，早知道不听了，真的难调。

大规模树上路径统计，考虑边分治，当然你需要先把式子化成适合边分治的形式，至少消除一个 $depth(LCA(x,y))$ 所以我们考虑将贡献变为 $\frac{depth(x) + depth(y) + dis(x,y) - 2 \times depth'(LCA'(x,y))}{2}$。

那么三度化原树然后边分治，每次将两个分治中心的点集到对应的分治中心的距离处理出来，记录为 $d(x)$，分治中心间的距离为 $w$，那么贡献就变成 $\frac{depth(x) + depth(y) + d(x) + d(y) + w - 2 \times depth'(LCA'(x,y))}{2}$ 然后对于每个点将 $dep(x) + d(x)$ 打包，接下来就是处理另一棵树上的贡献与合并贡献。

考虑将分治边左右的点染成黑白两种颜色，然后全部丢到另一棵树上建出虚树，通过记录下子树内的黑色白色的贡献最大值然后在最近公共祖先处合并贡献即可。

建虚树可以考虑在最开始把所有点按照 dfs 序排序，然后分治时再分入不同的连通块，使用 st 表加上 dfs 序 $O(1)$ 求解最近公共祖先可以将全过程加速到 $O(n \log n)$。

最后算上自己对自己的贡献即可，记得实现的好点，别像我一样被卡空间。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5+114;
const long long inf = 1e17+114;
struct Node{
    int to,nxt,flag;
    long long w;
}edge[maxn<<2];
int head[maxn<<1],tot=1;
int cnt;
void add(int u,int v,long long w){
    edge[++tot].to=v;
    edge[tot].nxt=head[u];
    edge[tot].w=w;
    head[u]=tot;
    edge[++tot].to=u;
    edge[tot].nxt=head[v];
    edge[tot].w=w;
    head[v]=tot;
}
vector< pair<int,int> > E[maxn<<1];
int vis[maxn<<1];
long long DEP[maxn<<1];
void dfs(int u,int fa){
    vis[u]=true;
    if(E[u].size()>3){
        int p=0;
        int v1=++cnt;
        int v2=++cnt;
        for(pair<int,int> x:E[u]){
            if(vis[x.first]==true) continue;
            if(p&1) E[v1].push_back(x);
            else E[v2].push_back(x);
            ++p;
        }
        DEP[v1]=DEP[u];
        DEP[v2]=DEP[u];
        add(u,v1,0);
        add(u,v2,0);
        dfs(v1,u);
        dfs(v2,u);
    }else{
        for(pair<int,int> v:E[u]) if(vis[v.first]==false) add(u,v.first,v.second),DEP[v.first]=DEP[u]+v.second,dfs(v.first,u);
    }
}
long long dep[maxn<<1];
int sz[maxn<<1];
void calc(int u,int fa,int lst){
    dep[u]=dep[fa]+edge[lst].w;
    sz[u]=1;
    for(int i=head[u];i;i=edge[i].nxt){
        if(edge[i].to!=fa&&edge[i].flag!=true) calc(edge[i].to,u,i),sz[u]+=sz[edge[i].to];
    }
}
int findroot(int u,int fa,int rt,int lst){
    int mx=u,res=lst;
    for(int i=head[u];i;i=edge[i].nxt){
        if(edge[i].to!=fa&&edge[i].flag!=true){
            int v=findroot(edge[i].to,u,rt,i);
            if(max(sz[edge[v].to],sz[rt]-sz[edge[v].to])<=max(sz[mx],sz[rt]-sz[mx])){
                mx=edge[v].to;
                res=v;
            }
        }
    }
    return res;
}
vector<int> vec;
void search(int u,int fa,int lst){
    dep[u]=dep[fa]+edge[lst].w;
    vec.push_back(u);
    for(int i=head[u];i;i=edge[i].nxt){
        if(edge[i].to!=fa&&edge[i].flag!=true) search(edge[i].to,u,i);
    }
}
//第二棵树上操作
int dfncnt,dfn[maxn];
int st[maxn][20],n;
long long depth[maxn];
int lg[maxn];
void init(){
    lg[1]=0;
    for(int i=2;i<=n;i++) lg[i]=lg[i/2]+1;
    for(int j=1;j<=19;j++){
        for(int i=1;i+(1<<j)-1<=n;i++){
            if(dfn[st[i][j-1]]<dfn[st[i+(1<<(j-1))][j-1]]) st[i][j]=st[i][j-1];
            else st[i][j]=st[i+(1<<(j-1))][j-1]; 
        }
    }
}
vector< pair<int,long long> > road[maxn];
void dfs_init(int u,int fa,long long w){
    dfn[u]=++dfncnt;
    st[dfncnt][0]=fa;
    depth[u]=depth[fa]+w;
    for(pair<int,long long> v:road[u]){
        if(v.first!=fa) dfs_init(v.first,u,v.second);
    }
}
int LCA(int u,int v){
    if(u==v) return u;
    if(dfn[u]>dfn[v]) swap(u,v);
    int l=dfn[u]+1,r=dfn[v];
    int k=lg[r-l+1];
    if(dfn[st[l][k]]<dfn[st[r-(1<<k)+1][k]]) return st[l][k];
    else return st[r-(1<<k)+1][k];
}
vector<int> VE[maxn];//建立虚树
long long dp[maxn][2];//子树内两种颜色的点的最大值
long long ans=-inf;
int col[maxn];
void DP(int u,int fa,long long w){
    dp[u][0]=(col[u]==1?dep[u]+DEP[u]:-inf);
    dp[u][1]=(col[u]==2?dep[u]+DEP[u]:-inf);
    col[u]=0;
    for(int v:VE[u]){
        DP(v,u,w);
        ans=max(ans,dp[u][0]+dp[v][1]-2*depth[u]+w);
        ans=max(ans,dp[v][0]+dp[u][1]-2*depth[u]+w);
        dp[u][0]=max(dp[u][0],dp[v][0]);
        dp[u][1]=max(dp[u][1],dp[v][1]);
    }
    VE[u].clear();
}
int top,sta[maxn];
void Link(int u,int v){VE[u].push_back(v);}
vector<int> B,W;
void solve(int x,vector<int> &Point){
    calc(x,0,0);
    int e=findroot(x,0,x,0);
    if(e==0) return ;
    int u=edge[e].to,v=edge[e^1].to;
    edge[e].flag=true;
    edge[e^1].flag=true;
    B.clear();
    W.clear();
    vec.clear();
    search(u,0,0);
    swap(B,vec);
    vec.clear();
    search(v,0,0);
    swap(W,vec);
    for(int x:B) if(x<=n) col[x]=1;
    for(int x:W) if(x<=n) col[x]=2;
    sta[top=1]=1;
    for(int i=0,l;i<Point.size();i++)
        if(Point[i]!=1){
            int l=LCA(Point[i],sta[top]);
            if(l!=sta[top]){
                while(dfn[l]<dfn[sta[top-1]]) Link(sta[top-1],sta[top]),top--;
                if(dfn[l]>dfn[sta[top-1]]) Link(l,sta[top]),sta[top]=l;
                else Link(l,sta[top--]);
            }
            sta[++top]=Point[i];
        }
    for(int i=1;i<top;i++) Link(sta[i],sta[i+1]);
    vector<int> L,R;
    for(int x:Point){
        if(col[x]==1) L.push_back(x);
        else R.push_back(x);        
    }    
    DP(1,0,edge[e].w);
    Point.clear();
    solve(u,L);
    solve(v,R);
    return ;
}
bool cmp(int x,int y){
    return dfn[x]<dfn[y];
}
signed main(){
    //freopen("1.in","r",stdin);
    //freopen("1.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    memset(st,0x3f3f3f,sizeof(st));
    cin>>n;
    cnt=n;
    for(int i=1;i<n;i++){
        int u,v;
        long long w;
        cin>>u>>v>>w;
        E[u].push_back(make_pair(v,w));
        E[v].push_back(make_pair(u,w));
    }   
    dfs(1,0);
    for(int i=1;i<n;i++){
        int u,v;
        long long w;
        cin>>u>>v>>w;
        road[u].push_back(make_pair(v,w));
        road[v].push_back(make_pair(u,w));
    }
    dfs_init(1,0,0);
    init();
    vector<int> Point;
    for(int i=1;i<=n;i++) Point.push_back(i);
    sort(Point.begin(),Point.end(),cmp);
    solve(1,Point);
    ans/=2;
    for(int i=1;i<=n;i++) ans=max(ans,DEP[i]-depth[i]);
    cout<<ans<<'\n';
    return 0;
}
```


---

## 作者：R_shuffle (赞：0)

由于不会比较巧妙的方法，于是考虑暴力。

为了可怜的时间复杂度，考虑优秀的暴力。然后不难发现我还不会树分块，所以只能用树上启发式合并这种暴力。

不妨设现在处理的子树是 $lca$ 的子树，需要找到两个点在 $lca$ 的两个子树内。不妨设两个点为 $x,y$，其中 $x$ 在已经处理过的子树内，$y$ 在正在处理的子树内。由于支持暴力遍历 $y$，而我们又固定了 $LCA(x,y)$，所以需要快速求出 $depth_x-depth'(LCA'(x,y))$ 的最大值。

然后考虑第二棵树的暴力怎么做。不妨考虑枚举 $LCA'(x,y)$，然后区间查询子树中 $depth_x$ 的最大值。然后考虑能不能用树剖优化枚举 $LCA'(x,y)$ 的过程。然后不难发现问题就被分成了三种情况。

1. $x$ 与自己子树内的点的贡献；
2. $x$ 从重儿子跳到父亲，父亲的轻儿子的贡献；
3. $x$ 从轻儿子跳到父亲，父亲的所有儿子中除了 $x$ 所在的之外的儿子的贡献。

然后不难发现直接用什么数据结构维护每条重链的前后缀最大值可以解决前两个。第三个考虑用堆维护每个儿子的答案，显然查询的时候最多取其中两个元素。

所以这个方法实际上是三个 $\log$ 的，不难注意到三个 $\log$ 都是小常数 $\log$ 的代表。所以实际上跑的飞快。

---

## 作者：xuyiyang (赞：0)

### [P4565 [CTSC2018] 暴力写挂](https://www.luogu.com.cn/problem/P4565)

久闻本题大名。遂来写。$\\$
首先转化一下式子，把 $T$ 中的 lca 去掉，因为你在点分治的过程中对 lca 一无所知。$\\$
$d_x + d_y - d_{T,\operatorname{lca}(x,y)} - d_{T',\operatorname{lca}(x,y)} = \frac{1}{2}(d_x +d_y + \operatorname{dist}(x,y) - 2d_{T',\operatorname{lca}(x,y)})$。 $\\$
注意到距离在点分治上是好做的。首先判掉 $u = v$ 的情况。然后考虑点分治，在树 $T$ 上做点分治，设重心为 $R$，把 $R$ 在 $T$ 上的连通块拉出来，令 $val_x = d_x + \operatorname{dist}(x,R)$，那么原式就只剩下了 $val_x, val_y,d_{T',\operatorname{lca}(x, y)}$。对于这个东西，我们在 $T'$ 上做树形 DP，那么记录子树的最大和次大 $val$ 就可以解决。注意到不能暴力遍历整棵树，那么就建立虚树。即可做到 $\mathcal O(n \log ^ 2 n)$。$\\$
一些注意事项：不仅在虚树 DP 后要恢复 $f$，最开始也要清空。虚树的根取深度最小时不能用带权的深度最小点，因为有负权边。注意把虚树中新加入的 lca 点的 $val$ 值清空。
```cpp
int n; bool vis[N];
vector<pii> e1[N], e2[N];
vector<int> e[N];
pli f[N][2];
int mx[N], sz[N], R;
ll w[N], res = -1e18;
ll d1[N], d2[N];
int col[N], d3[N];
bool st[N];
int dfn[N], dn;
int mi[K][N];

inline int get(int x, int y) { return dfn[x] < dfn[y] ? x : y; }
inline int lca(int u, int v) {
	if (u == v) return u;
	if ((u = dfn[u]) > (v = dfn[v])) swap(u, v);
	int k = __lg(v - (u ++ ));
	return get(mi[k][u], mi[k][v - (1 << k) + 1]);
}
void dfs1(int id, int f) {
	for (pii _ : e1[id]) {
		int it = _.fi; if (it == f) continue ;
		d1[it] = d1[id] + _.se; dfs1(it, id); 
	}
}
void dfs2(int id, int f) {
	mi[0][dfn[id] = ++ dn] = f; d3[id] = d3[f] + 1;
	for (pii _ : e2[id]) {
		int it = _.fi; if (it == f) continue ;
		d2[it] = d2[id] + _.se; dfs2(it, id);
	}
}
void findroot(int id, int f, int tot) {
	mx[id] = 0; sz[id] = 1;
	for (pii _ : e1[id]) {
		int it = _.fi; if (it == f || st[it]) continue ;
		findroot(it, id, tot); sz[id] += sz[it];
		mx[id] = max(mx[id], sz[it]);
	} mx[id] = max(mx[id], tot - sz[id]);
	if (mx[R] > mx[id]) R = id;
}
vector<int> cur;
void dfs(int id, int f, int anc) {
	cur.push_back(id); sz[id] = 1; col[id] = anc;
	for (pii _ : e1[id]) {
		int it = _.fi; if (st[it] || it == f) continue ;
		w[it] = w[id] + _.se; dfs(it, id, anc); sz[id] += sz[it];
	}
}
void Dfs(int id) {
	if (vis[id]) f[id][0].fi = w[id], f[id][0].se = col[id];
	for (int it : e[id]) {
		Dfs(it);
		if (f[it][0].se != f[id][0].se)
			res = max(res, f[it][0].fi + f[id][0].fi - 2 * d2[id]);
		else res = max(res, max(f[it][0].fi + f[id][1].fi - 2 * d2[id], f[it][1].fi + f[id][0].fi - 2 * d2[id]));
		if (f[it][0].fi > f[id][0].fi) {
			if (f[it][0].se == f[id][0].se) f[id][0] = f[it][0];
			else f[id][1] = f[id][0], f[id][0] = f[it][0];
		} 
		if (f[it][0].fi > f[id][1].fi) {
			if (f[it][0].se != f[id][0].se) f[id][1] = f[it][0];
		}
		if (f[it][1].fi > f[id][1].fi) {
			if (f[it][1].se != f[id][0].se) f[id][1] = f[it][1];
		}
	}
}
void solve(vector<int> arr) {
	//for (int it : arr) printf("%d %lld %d\n", it, w[it], col[it]); 
	sort(arr.begin(), arr.end(), [](int x, int y) { return dfn[x] < dfn[y]; });
	int m = arr.size();
	for (int i = 0; i < m; i ++ ) vis[arr[i]] = 1;
	for (int i = 0; i < m - 1; i ++ ) arr.push_back(lca(arr[i], arr[i + 1]));
	sort(arr.begin(), arr.end(), [](int x, int y) { return dfn[x] < dfn[y]; });
	arr.erase(unique(arr.begin(), arr.end()), arr.end());
	int minv = n + 1, rt = 0;
	for (int i = 0; i < (int)arr.size() - 1; i ++ ) {
		int p = lca(arr[i], arr[i + 1]);
		e[p].push_back(arr[i + 1]);
		if (minv > d3[p]) minv = d3[p], rt = p;
	}
	Dfs(rt);
	for (int i = 0; i < (int)arr.size(); i ++ ) {
		e[arr[i]].clear(); vis[arr[i]] = 0;
		f[arr[i]][0] = f[arr[i]][1] = {-1e18, -1};
	}
}
void divide(int id) {
	st[id] = 1; cur.push_back(id); w[id] = 0; col[id] = id;
	for (auto _ : e1[id]) {
		int it = _.fi; if (st[it]) continue ;
		w[it] = _.se; dfs(it, id, it);
	} for (int it : cur) w[it] += d1[it];
	solve(cur); cur.clear();
	for (auto _ : e1[id]) {
		int it = _.fi; if (st[it]) continue ;
		R = 0; findroot(it, id, sz[it]); divide(R);
	}
}

int main() {
	scanf("%d", &n);
	for (int i = 0, u, v, w; i < n - 1; i ++ ) {
		scanf("%d%d%d", &u, &v, &w);
		e1[u].push_back({v, w}), e1[v].push_back({u, w});
	}
	for (int i = 0, u, v, w; i < n - 1; i ++ ) {
		scanf("%d%d%d", &u, &v, &w);
		e2[u].push_back({v, w}), e2[v].push_back({u, w});
	}
	for (int i = 1; i <= n; i ++ ) f[i][0] = f[i][1] = {-1e18, -1};
	dfs1(1, 0), dfs2(1, 0);
	for (int i = 1; i <= n; i ++ ) res = max(res, 2ll * (d1[i] - d2[i]));
	for (int i = 1; i <= __lg(n); i ++ ) for (int j = 1; j + (1 << i) - 1 <= n; j ++ )
		mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 << (i - 1))]);
	mx[0] = N; findroot(1, 0, n); divide(R);
	printf("%lld\n", res / 2); return 0;
}
```

---

## 作者：Acee (赞：0)

听说这题边分没前途，我试试。

首先，这个式子十分难看，推一推，发现可以变成 $\frac{1}{2}(dis(x,y)+dep(x)+dep(y)-2dep'(lca'(x,y)))$。

然后树上邻域问题考虑树分治，这个东西点分有点难做，所以考虑边分治，第一棵树就可以解决了，考虑第二棵树的贡献。

对边的端点的所属连通块进行黑白染色，去第二棵树上建虚树，在虚树上面去 dp 计算贡献即可。

虚树不用 $O(n)$ 建树的话，复杂度可能就变成 $O(n \log^2 n)$ 了。

难看的代码就不放了，想要私信。

---


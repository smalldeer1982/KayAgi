# 【XR-2】永恒

## 题目背景

> 我一直认为这世界没有永恒，如果非要说永恒，宇宙间唯一的永恒就是——所有的一切都会随着时光消失。——梧桐《那片星空，那片海》

## 题目描述

有一棵 $n$ 个点的永恒的树，树中每个点 $x(1 \le x \le n)$ 上都有一个永恒的字符串 $S(x)$。

但这世界没有永恒，所有的一切都会随着时光消失。我们只能给每个所谓永恒的东西定义一个永恒值 $f$。这个值本身没有意义，只是一个象征罢了。

- 一个字符串 $S$ 的永恒值 $f(S)$ 定义为它的长度 $\mathrm{Len}(S)$，即：

$$f(S) = \mathrm{Len}(S)$$

- 树上的一条无向路径 $K = [u, v](u < v)$ 指的是 $u,v$ 之间的简单路径（包括 $u, v$），其永恒值 $f(K)$ 定义为路径上所有不同的无序点对 $(x, y)(x \in K, y \in K, x < y)$ 上的字符串 $S(x), S(y)$ 的最长公共前缀 $\mathrm{LCP}(S(x), S(y))$ 的永恒值 $f(\mathrm{LCP}(S(x), S(y)))$ 之和，即：

$$f(K) = \sum_{x \in K, y \in K, x < y} f(\mathrm{LCP}(S(x), S(y)))$$

- 一棵树 $T$ 的永恒值 $f(T)$ 定义为树上所有的无向路径 $[u, v](u \in T, v \in T, u < v)$ 的永恒值之和，即：

$$f(T) = \sum_{u \in T, v \in T, u < v} f([u,v])$$

特别的是，树中每个点上的字符串都来自一棵永恒的以点 $1$ 为根的 Trie 树，即每个树中的点都对应着一个 Trie 树中的点，点上的字符串就是 Trie 树中从根节点到其对应的点形成的字符串。

你需要求出这棵树的永恒值，答案对 $998244353$ 取模。

## 说明/提示

【样例 $1$ 说明】

所有的 $S(x)$ 为：

$S(1) = \texttt{"mayqueen"}$

$S(2) = \texttt{"mayking"}$

$S(3) = \texttt{"market"}$

所有的 $f(\mathrm{LCP}(S(x), S(y)))$ 为：

$f(\mathrm{LCP}(S(1), S(2))) = f(\mathrm{LCP}(\texttt{"mayqueen"}, \texttt{"mayking"})) = f(\texttt{"may"}) = \mathrm{Len}(\texttt{"may"}) = 3$

$f(\mathrm{LCP}(S(1), S(3))) = f(\mathrm{LCP}(\texttt{"mayqueen"}, \texttt{"market"})) = f(\texttt{"ma"}) = \mathrm{Len}(\texttt{"ma"}) = 2$

$f(\mathrm{LCP}(S(2), S(3))) = f(\mathrm{LCP}(\texttt{"mayking"}, \texttt{"market"})) = f(\texttt{"ma"}) = \mathrm{Len}(\texttt{"ma"}) = 2$

所有的 $f([u, v])$ 为：

$f([1,2]) = f(\mathrm{LCP}(S(1), S(2))) = 3$

$f([1,3]) = f(\mathrm{LCP}(S(1), S(2))) + f(\mathrm{LCP}(S(1), S(3))) + f(\mathrm{LCP}(S(2), S(3))) = 3 + 2 + 2 = 7$

$f([2,3]) = f(\mathrm{LCP}(S(2), S(3))) = 2$

所以：

$f(T) = f([1,2]) + f([2,3]) + f([1,3]) = 3 + 7 + 2 = 12$

【数据规模与约定】

**本题采用捆绑测试。**

Subtask 1（3 points）：$n, m \le 10$，时限 1s。  
Subtask 2（5 points）：$n, m \le 100$，时限 1s。  
Subtask 3（9 points）：$n, m \le 1000$，时限 1s。  
Subtask 4（7 points）：$n, m \le 5000$，时限 2s。  
Subtask 5（9 points）：$n, m \le 20000$，时限 3s。  
Subtask 6（11 points）：$n, m \le 10^5$，时限 4s。  
Subtask 7（19 points）：$m=2$，时限 3s。  
Subtask 8（37 points）：无特殊限制，时限 10s。

对于 $100\%$ 的数据，$2 \le n,m \le 3\times 10^5$。

## 样例 #1

### 输入

```
3 17
2 0 2
0 1 2 3 4 5 6 7 8 4 10 11 12 3 14 15 16
0mayqueenkingrket
9 13 17
```

### 输出

```
12
```

# 题解

## 作者：Elegia (赞：20)

#### 题目大意

> 给两颗树 $T_1, T_2$ 以及映射 $f: T_1 \rightarrow T_2$，其中 $T_2$ 有根，记 $[u,v]$ 为 $T_1$ 上两点 $u, v$ 的简单路径上点集，求
> $$\sum_{x \in T_1} \sum_{y \in T_1} \sum_{u\in T_1} \sum_{v\in T_1} [x<y][u<v][[u,v] \subseteq [x, y]] (\operatorname{dep}(\operatorname{lca}(f(u),f(v))) - 1)$$
> 其中求 LCA 和深度均为在 $T_2$ 上。

#### 前置知识

- 点分治
- 虚树

#### 题解

改变求和顺序，考虑将与值主要相关的 $u, v$ 放到前面：
$$\sum_{u\in T_1} \sum_{v\in T_1} [u<v] (\operatorname{dep}(\operatorname{lca}(f(u),f(v))) - 1)\sum_{x \in T_1} \sum_{y \in T_1} [x<y][[u,v] \subseteq [x, y]]$$
注意 $[u<v]+[v<u] = \frac{[u\neq v]}2$，不妨将问题转化为求不同点之间关系：
$$\frac14 \sum_{u\in T_1} \sum_{v\in T_1} [u\neq v] (\operatorname{dep}(\operatorname{lca}(f(u),f(v))) - 1)\sum_{x \in T_1} \sum_{y \in T_1} [x\neq y][[u,v] \subseteq [x, y]]$$
考虑进行点分治，对穿过重心 $c$ 的所有 $[u,v]$ 对答案的贡献进行统计。记当前分治时 $c$ 为根，$\operatorname{sub}(u)$ 为 $u$ 节点在整个 $T_1$ 的子树大小。首先考虑 $u, v$ 均不为 $c$ 的情况，若它们在不同子树内，则贡献为
$$(\operatorname{dep}(\operatorname{lca}(f(u),f(v))) - 1) \operatorname{sub} (u) \operatorname{sub} (v)$$
考虑按照此定义将整个分治的连通块的贡献进行计算，然后容斥掉每个子树内的贡献。即我们要解决对于 $T_1$ 上一个点集 $S$，求出
$$\left(\sum_{u\in S} \sum_{v\in S} (\operatorname{dep}(\operatorname{lca}(f(u),f(v))) - 1) \operatorname{sub} (u) \operatorname{sub} (v) \right) - \sum_{u\in S} (\operatorname{dep}(f(u)) - 1)\operatorname{sub}(u)^2$$
考虑在 $T_2$ 上 $(\operatorname{dep}(\operatorname{lca}(f(u),f(v))) - 1) \operatorname{sub} (u) \operatorname{sub} (v)$ 的意义，这等价于将 $f(u)$ 到 $T_2$ 的根上的每一个节点加上 $\operatorname{sub}(u)$ 的权值，询问 $f(v)$ 的父亲到根节点的路径上权值和与 $\operatorname{sub}(v)$ 的乘积。如果通过数据结构进行计算会多出一个 $\log$ 的代价，考虑该问题是离线的，通过虚树优化复杂度。

将 $\{f(u) | u\in S\} \cup \{ \operatorname{root}(T_2) \}$ 的虚树建出，考虑先将每个点映射到的点加上对应权值 $w(f(u)) \leftarrow w(f(u)) + \operatorname{sub}(u)$，这维护了实际修改对应的差分，第二步将虚树从下至上进行累加，这时每个点与原本的点权概念一致，第三步从上至下累加，记 $p(x)$ 为在虚树上的父节点，$s(f(u)) = s(p(f(u))) + w(p(f(u)))[\operatorname{dep} (f(u)) - \operatorname{dep}(p(f(u)))]$。

这时 $\sum_{v\in S} s(f(v)) \operatorname{sub}(v)$ 即为所求。虚树计算的时间复杂度为 $\Theta(|S|)$。但注意建立虚树时通常有一个对 DFS 序排序的问题，考虑到本题所求全部为离线问题，所以离线进行多数组的基数排序即可做到严格的 $\Theta\left(m + \sum |S|\right) = \Theta(m + n\log n)$。

对于 $u$ 为重心的情况，可以枚举 $v$ 进行计算。

综上所述，点分治内部所消耗的时间复杂度为 $\Theta(|S|)$，故点分治的总体复杂度为 $\Theta(n\log n)$。为了辅助求出虚树，可能需要 $\Theta(1)$ LCA 计算，预处理的理论复杂度可以做到 $\Theta(m)$，使用朴素的 ST 表可以做到 $\Theta(m\log m)$。

因此，本题的理论时间复杂度为 $\Theta(m + n\log n)$，需要 $\Theta(m + n\log n)$ 的空间。本题 std(by PinkRabbit) 的实现时间复杂度为 $\Theta(m\log m + n\log n)$，空间复杂度为 $\Theta(m\log m + n\log n)$。

取决于求权值这一部分的不同实现，可能有例如以下一些复杂度的算法可能卡过时限：

树链剖分：$\Theta(m + n\log n\log^2 m)$

LCT / 全局平衡二叉树优化：$\Theta(m\log m + n\log n \log m)$

使用 `std::sort()` 进行 DFS 序的排序：$\Theta(m\log m + n\log^2 n)$，空间 $\Theta(m\log m + n)$

#### 代码

```cpp
#include <cstdio>
#include <algorithm>
// #include <ctime>
#define il inline
typedef long long LL;
const int MN = 300005;
const int MV = 12000005; // max virtual tree nodes < 2 N log N
const int Mod = 998244353, Inv2 = (Mod + 1) / 2;
il void ad(int &x, int y) { x -= (x += y) >= Mod ? Mod : 0; }

int N, M, Ans;
int id[MN], h[MN], g[MN], nxt[MN * 3], to[MN * 3], tot;
il void ins(int *a, int x, int y) { nxt[++tot] = a[x], to[tot] = y, a[x] = tot; }
il void init() {
	int x;
	scanf("%d%d", &N, &M);
	for (int i = 1; i <= N; ++i) {
		scanf("%d", &x);
		if (x) ins(g, x, i), ins(g, i, x);
	}
	scanf("%*d");
	for (int i = 2; i <= M; ++i) scanf("%d", &x), ins(h, x, i);
	scanf("%*s");
	for (int i = 1; i <= N; ++i) scanf("%d", &id[i]);
} // read & edge-linking part

int idf[MN], dfn[MN], dfc;
int dep[MN], lg[MN * 2], st[MN * 2][20], ldf[MN], rdf[MN], ecn;
void tdfs(int u) {
	idf[++dfc] = u, dfn[u] = dfc;
	st[++ecn][0] = u, ldf[u] = ecn;
	for (int i = h[u]; i; i = nxt[i])
		dep[to[i]] = dep[u] + 1, tdfs(to[i]), st[++ecn][0] = u;
	rdf[u] = ecn;
}
il int chkdep(int i, int j) { return dep[i] < dep[j] ? i : j; }
il void _st() {
	lg[0] = -1;
	for (int i = 1; i <= ecn; ++i) lg[i] = lg[i >> 1] + 1;
	for (int j = 0; j < lg[ecn]; ++j)
		for (int i = 2 << j; i <= ecn; ++i)
			st[i][j + 1] = chkdep(st[i - (1 << j)][j], st[i][j]);
}
il int qurdep(int l, int r) { int b = lg[r - l + 1]; return chkdep(st[l + (1 << b) - 1][b], st[r][b]); }
il int lca(int x, int y) {
	if (rdf[x] < ldf[y]) return qurdep(rdf[x], ldf[y]);
	else if (rdf[y] < ldf[x]) return qurdep(rdf[y], ldf[x]);
	else return dep[x] < dep[y] ? x : y;
} // dfn & O(M log M) - O(1) RMQ-LCA part

int Q, ty[MN * 2], qh[MN * 2], buk[MN], nx[MV * 2], b[MV * 2], w[MV * 2], vcn;
il void add(int *h, int x, int y, int z) { nx[++vcn] = h[x], b[vcn] = y, w[vcn] = z, h[x] = vcn; }
// queries part

int faz[MN], siz[MN], _siz[MN];
void _dfs(int u, int fz) {
	faz[u] = fz, siz[u] = 1;
	for (int i = g[u]; i; i = nxt[i]) if (to[i] != fz)
		_dfs(to[i], u), siz[u] += siz[to[i]];
	_siz[u] = siz[u];
}
int vis[MN], sz[MN], ts, rsz, rt;
void getrt(int u, int fz) {
	int mxs = 0; sz[u] = 1;
	for (int i = g[u]; i; i = nxt[i]) {
		if (to[i] == fz || vis[to[i]]) continue;
		getrt(to[i], u), sz[u] += sz[to[i]];
		mxs = std::max(mxs, sz[to[i]]);
	}
	mxs = std::max(mxs, ts - sz[u]);
	if (mxs < rsz) rt = u, rsz = mxs;
}
void fors(int u, int fz) {
	add(buk, dfn[id[u]], Q, siz[u]);
	for (int i = g[u]; i; i = nxt[i]) if (to[i] != fz && !vis[to[i]]) fors(to[i], u);
}
void dfs(int u) {
	if (ts == 1) return ; // no-op
	siz[u] = N;
	for (int x = u; !vis[faz[x]]; x = faz[x]) siz[faz[x]] = N - _siz[x];
	ty[++Q] = 0, fors(u, 0);
	for (int i = g[u]; i; i = nxt[i]) if (!vis[to[i]])
		ty[++Q] = 1, add(buk, dfn[id[u]], Q, siz[to[i]]), fors(to[i], u);
	for (int x = u; !vis[x]; x = faz[x]) siz[x] = _siz[x];
	vis[u] = 1;
	int nsz = ts;
	for (int i = g[u]; i; i = nxt[i]) if (!vis[to[i]]) {
		rsz = ts = sz[to[i]] < sz[u] ? sz[to[i]] : nsz - sz[u];
		getrt(to[i], 0), dfs(rt);
	}
} // O(N log N) tree decomposition part

int Sum, sum[MN], rch[MN], tp;
il void C(int x, int y) { if (x) ad(Sum, (LL)y * y % Mod * (dep[x] - dep[rch[tp]]) % Mod); }

int main() {
//	freopen("eternal-8-3.in", "r", stdin);
//	int tim1, tim2, tim3, tim4, tim5, tim6, tim7;
//	tim1 = clock();
	init();
//	tim2 = clock();
	dep[1] = 0, tdfs(1);
//	tim3 = clock();
	_st();
//	tim4 = clock();
	_dfs(1, 0), vis[0] = 1, rsz = ts = N, getrt(1, 0), dfs(rt);
//	tim5 = clock();
	for (int i = M; i >= 1; --i)
		for (int j = buk[i]; j; j = nx[j])
			add(qh, b[j], idf[i], w[j]);
	// O(N log N) radix sort part
//	tim6 = clock();
	for (int q = 1; q <= Q; ++q) {
		int s = 0, x, y; Sum = 0;
		rch[tp = 1] = 1, sum[1] = 0;
		for (int i = qh[q]; i; i = nx[i]) {
			int u = b[i];
			ad(Sum, Mod - (LL)w[i] * w[i] * dep[u] % Mod);
			ad(s, w[i]);
			if (nx[i] && b[nx[i]] == u) continue;
			int lc = lca(rch[tp], u);
			for (x = y = 0; dep[rch[tp]] > dep[lc]; ad(y, sum[tp]), x = rch[tp--]) C(x, y);
			if (dep[rch[tp]] < dep[lc]) rch[++tp] = lc, sum[tp] = 0;
			ad(sum[tp], y);
			C(x, y);
			rch[++tp] = u, sum[tp] = s;
			s = 0;
		}
		for (x = y = 0; tp; ad(y, sum[tp]), x = rch[tp--]) C(x, y);
		ad(Ans, ty[q] ? Mod - Sum : Sum);
	} // virtual tree part
//	tim7 = clock();
	Ans = (LL)Ans * Inv2 % Mod, printf("%d\n", Ans);
/*	printf(" Init : %dms\n", tim2 - tim1);
	printf(" Trie : %dms\n", tim3 - tim2);
	printf(" ST   : %dms\n", tim4 - tim3);
	printf(" DFZ  : %dms\n", tim5 - tim4);
	printf(" sort : %dms\n", tim6 - tim5);
	printf(" vt   : %dms\n", tim7 - tim6);*/
	return 0;
}
```



---

## 作者：kyel (赞：9)

去看边上的题解，你一定看到了不少诸如“把y->rt加sizy”，“子树大小乘子树大小”之类的字眼。这里会结合图像加以说明它们的意义及理解它们的正确性。**我们用map来表示储存原图数据的对象，用trie来表示储存Trie树的对象**。trie树上根节点的深度为0，map树上则无要求。

---

首先我们来理解一下点对贡献的计算。对于一个**无序**点对(u,v)，若map.LCA(u, v)不为u或v，则它应该是这样的：

![](https://cdn.luogu.com.cn/upload/pic/69928.png )

可以看出，任何以红、蓝圈内点为两端点的路径都会穿过点对(u,v)。

这时，map树上穿过该点对的路径条数为map.size[u] \* map.size[v],贡献就应该是map.size[u] \* map.size[v] \* trie.dep[trie.LCA(mapto[u], mapto[v])]。这里需要注意区分何时是map，何时用trie，而其中的mapto是题目中输入的、从map到trie的映射关系。

否则，它应该是这样的（假定u的深度更小）：
![](https://cdn.luogu.com.cn/upload/pic/69950.png )

那么，map树上穿过该点对的路径条数为(n - map.size[w]) \* map.size[v],同理，贡献要再乘上其trie树上的LCA的深度。

当然，上面那部分还是比较好想清楚的，未必需要画图。然而接下来，我们需要以某种玄妙的方式**将“计算点对的贡献”转换为“计算点的贡献”**。

接下来要考虑在map与trie树上进行转换，因此我们**用x,y描述在map上的点，用u,v描述在trie树上的点**。

考虑统计v的贡献时，如何计入u。
![](https://cdn.luogu.com.cn/upload/pic/69933.png)

显然，u->trie.root与v->trie.root两条路径将会交于trie.LCA(u,v)处。

可以想到，若我们**把u能对v造成的贡献以某种方式记录在u->trie.root上**，那么在访问到v时，**只需要沿着它的路径往上走到根，就可以得知其它点对v的贡献的影响**。当然这个权值必须**要便于合并**，而且对于任何的v都适用（即不能出现类似trie.LCA(u,v)的字眼）。接下来你会看到，这个“合并”实际上只是个普通加法。

先考虑怎么这样做。这个“权值”是什么？让我们看一下我们的式子：
```cpp
map.size(x) * map.size(y) * trie.dep[trie.LCA(u, v)]
```
trie.dep[trie.LCA(u, v)]实际上是trie.LCA(u,v)到根的距离，或者说是需要经过的路径条数。

那么若我们将trie.LCA(u,v)->trie.root上的所有**边**加上权值map.size(x)，"map.size(x)"与"trie.dep[trie.LCA(u, v)]"这两个与v相关的项就可以扔掉了——trie.dep[trie.LCA(u, v)]会在累加至根的时候“自动”乘上，而map.size[v]在统计v的贡献的时候是已知量。

结合上面的思考以及u->trie.root与v->trie.root交于trie.LCA(u,v)的性质，方法很显然了：我们将u->trie.root上所有的**边**都加上map.size[x]，对所有点做完这件事情之后，v的**总贡献**就是v->trie.root路径上所有边的权值和与map.size[v]的积！

似乎觉得哪里不对劲？不对劲就对了←←。

实际上我们这样统计的时候有一个非常显而易见的问题：**照这么计算，点对(v,v)居然能有贡献**？点对(v,v)当然不能有贡献，因此我们要在第一次统计答案的时候把它去掉（未考虑取模）：
```cpp
ans -= map.size[v] \* map.size[v] \* trie.dep[mapto[v]]
```
这个应该没什么问题吧，读者仔细想想应该能理解。

具体实现"将v->trie.root路径上所有边权求和"时，我们当然可以用树剖+树状数组/线段树来做，而且实际上接下来的统计也要用到这些算法，但**实际上我们是可以O(n)做出这一步的**。

**考虑在写平衡树时的标记下传**，我们不难想到：当我们要把u->trie.root上所有边权值加map.size[x]时，我们可以先在u处打上标记，之后利用dfs一次性将所有子节点的权值累加回收至根（即将整条路径上的边加上权值），再用一次dfs将权值从根累加至子节点（即求出该点往上至根的路径权值和）。

当然，在之后我们还要除2（乘2的逆元），因为我们这么做会同时统计(u,v)与(v,u)，而题中要求的是无序点对。

当然，如果你老老实实把上面所有内容码好，你会发现样例过不去：程序给出了**17**（17可以验证你上面是否写对）。为什么？

因为我们这样考虑的时候，**将x,y的map.LCA为x或y的情况忽略了**，而这两种情况是不能合并进上述一种方式进行统计的。这意味着我们上面的转移方式**有的地方可能多算了，有的地方又可能少算了**。听上去非常棘手，怎么办？

我们先列出之前的式子，理性分析一下：
```cpp
A : map.size[x] * map.size[y] * C
B : (n - map.size[z]) * map.size[y] * C
C : trie.dep[trie.LCA(u, v)]
众所周知，A + (-A + B) = B
D = -A + B : (n - map.size[x] - map.size[z]) * map.size[y] * C
E : (n - map.size[x] - map.size[z])，与y或C无关
```
如果我们对所有被误算为A的点，都能够给它重新补上权值D，那么之前的错误就被“弥补”了。

虽然D中有多了一个变量z，非常可怕，但实际上z是x的一个子节点（可以参照前面那张出现了x、y、z的图），那么我们可以考虑模仿上面在路径上加权值的方法，统计一下所有点的D类贡献。**由于要求x、y、z在同一条“直”（深度单调）路径上**，这一次必须在线统计答案：当从x点经过z点进入下面的子树时，在路径x->trie.root上加上E；当更改儿子z或者是从x退出dfs时，在路径x->trie.root上减去E。这显然是我们可以用树剖+线段树或区间加树状数组维护的。

（上面一段思维难度可能较大，希望读者仔细体会。）

下面附上数据生成器（含生成数据及调用程序）
```cpp
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

int main() {
	srand(time(0));
	while (1) {
		FILE *out(fopen("data.in", "w"));
		int n = 3, m = 3;//3，3应该可以解决较为平凡的代码错误了；小数据能过大数据爆炸可以考虑取模的漏洞
		fprintf(out, "%d %d\n0 ", n, m);
		for (int i(2); i <= n; ++i) {
			fprintf(out, "%d ", rand() % (i - 1) + 1);
		} fprintf(out, "\n0 ");
		for (int i(2); i <= m; ++i) fprintf(out, "%d ", rand() % (i - 1) + 1);
		fprintf(out, "\n0");
		for (int i(1); i != m; ++i) fprintf(out, "%c", char(rand() % 26 + 'a'));//象征性的字符串
		fprintf(out, "\n");
		for (int i(1); i <= n; ++i) {
			fprintf(out, "%d ", rand() % (m - 1) + 2);
		}
		fclose(out);
		system("std.exe < data.in > std.out");//std
		system("P5439.exe < data.in > mine.out");//需要调试的代码
		if (system("fc std.out mine.out")) {
			printf("orz\n");//good luck!
			system("pause");
			break;
		}
	}
	return 0;
}

```
当然，还有我上交的代码。奇丑无比(
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

namespace kyel {
	typedef long long lint;
	const lint mod(998244353);
	const int maxn(312345);
	char str[maxn];
	int n, m;
	class graph {
	public:
		graph() : end(2) {}
		class node {
		public:
			int to, next;
		}all[maxn];
		int head[maxn], dep[maxn], end;
		lint size[maxn];
		void add(int fr, int to) {
			all[end].to = to, all[end].next = head[fr];
			head[fr] = end++;
		}
	}trie, map;
	int root, mapto[maxn];
	lint val[maxn], ans;//val即第一步附在路径上的权值
	inline void add(lint& a, lint b) { a = (a + b) % mod; }
	inline void sub(lint& a, lint b) { a = ((a - b) % mod + mod) % mod; } 
	inline lint mulv(lint a, lint b) { return a * b % mod; } 
	void dfs1(int now) {//初始化map.size与map.dep，其中map.dep好像没用到？
		map.size[now] = 1;
		for (int i(map.head[now]); i; i = map.all[i].next) {
			int to(map.all[i].to);
			map.dep[to] = map.dep[now] + 1;
			dfs1(to);
			map.size[now] += map.size[to];
		}
		add(val[mapto[now]], map.size[now]);//第一步统计的步骤，给点打上标记
	}
	void dfs2(int now) {//初始化trie的size与dep，注意到dep从0开始。
		trie.size[now] = 1;
		for (int i(trie.head[now]); i; i = trie.all[i].next) {
			int to(trie.all[i].to);
			trie.dep[to] = trie.dep[now] + 1;
			dfs2(to);
			trie.size[now] += trie.size[to];
		}
	}
	void dfs3(int now) {//将trie点上的标记转移到路径上
		for (int i(trie.head[now]); i; i = trie.all[i].next) {
			int to(trie.all[i].to);
			dfs3(to);
			if (now != 1) add(val[now], val[to]);
		}
	}
	void dfs4(int now) {//将trie路径上的标记累加至点上
		for (int i(trie.head[now]); i; i = trie.all[i].next) {
			int to(trie.all[i].to);
			add(val[to], val[now]);
			dfs4(to);
		}
	}
	int heavy[maxn], top[maxn], ttos[maxn], father[maxn];//树剖
	void dfs(int now) {
		lint *sz(trie.size);
		for (int i(1); i <= m; ++i) {
			now = i;
			for (int j(trie.head[i]); j; j = trie.all[j].next) {
				int to(trie.all[j].to);
				father[to] = now;
				if (sz[to] > sz[heavy[now]]) heavy[now] = to;
			}
		}
	}
	void dfs(int now, int up) {
		graph::node *all(trie.all);
		top[now] = up;
		ttos[now] = ++ttos[0];
		if (heavy[now]) dfs(heavy[now], up);
		for (int i(trie.head[now]); i; i = all[i].next) {
			if (all[i].to == heavy[now]) continue;
			dfs(all[i].to, all[i].to);
		}
	}
	namespace seg {//永久化标记线段树
		#define ls (n << 1)
		#define rs (n << 1 | 1)
		lint val[maxn << 2], tag[maxn << 2];
		void add(int n, int left, int right, int l, int r, lint v) {
			if (left == l && right == r) {
				kyel::add(val[n], v * (r - l + 1) % mod);
				kyel::add(tag[n], v);
				return;
			}
			int mid(left + right >> 1);
			if (r <= mid) add(ls, left, mid, l, r, v);
			else if (l > mid) add(rs, mid + 1, right, l, r, v);
			else add(ls, left, mid, l, mid, v), add(rs, mid + 1, right, mid + 1, r, v);
			val[n] = (val[ls] + val[rs] + tag[n] * (right - left + 1) % mod) % mod;
		}
		lint query(int n, int left, int right, int l, int r) {
			if (left == l && right == r) return val[n];
			lint ret(0);
			int mid(left + right >> 1);
			if (r <= mid) ret = query(ls, left, mid, l, r);
			else if (l > mid) ret = query(rs, mid + 1, right, l, r);
			else ret = (query(ls, left, mid, l, mid) + query(rs, mid + 1, right, mid + 1, r)) % mod;
			kyel::add(ret, tag[n] * (r - l + 1) % mod);
			return ret;
		}
	}
	void segadd(int pos, lint v) {//将trie树上从pos到根的路径权值加v
		while (pos) {
			seg::add(1, 1, m, ttos[top[pos]], ttos[pos], v);
			pos = father[top[pos]];
		}
	}
	lint segask(int pos) {//求trie树上从pos到根的路径上的权值和
		lint ret(0);
		while (pos) {
			add(ret, seg::query(1, 1, m, ttos[top[pos]], ttos[pos]));
			pos = father[top[pos]];
		}
		sub(ret, seg::query(1, 1, m, ttos[1], ttos[1]));//注意到边权实际附于深度较大的点上。当然也可以上一个segadd函数只加到距离根距离为1的地方。（总之要小心边权与点权的区别就好了）
		return ret;
	}
	void dfs5(int now) {//最后一次统计，将所有点的错误贡献进行修正
		add(ans, segask(mapto[now]) * map.size[now]);
		for (int i(map.head[now]); i; i = map.all[i].next) {
			int to(map.all[i].to);
			segadd(mapto[now], n - map.size[now] - map.size[to]);
			dfs5(to);
			segadd(mapto[now], -n + map.size[now] + map.size[to]);
		}
	}
	inline void read(int& x) {
		char c(getchar()); x = 0;
		while (c < '0' || c > '9') c = getchar();
		while (c >= '0' && c <= '9') x = x * 10 + (c & 15), c = getchar();
	}
	void kyel() {
		read(n), read(m);
		for (int i(1); i <= n; ++i) {
			int fth; read(fth);
			if (fth == 0) root = i;
			else map.add(fth, i);
		}
		for (int i(1); i <= m; ++i) {
			int fth; read(fth);
			if (fth)
				trie.add(fth, i);
		} scanf("%s", str);
		for (int i(1); i <= n; ++i) {
			read(mapto[i]);
		}
		dfs1(root);
		dfs2(1);
		dfs3(1);
		dfs4(1);
		for (int i(1); i <= n; ++i) {
			add(ans, mulv(map.size[i], val[mapto[i]]));
			sub(ans, map.size[i] * map.size[i] % mod * trie.dep[mapto[i]] % mod);
		}//统计第一次统计的答案
		ans = ans * (((mod + 1) >> 1) % mod) % mod;//除2
		dfs(1), dfs(1, 1);
		dfs5(root);
		printf("%lld\n", ans);
	}
}                           
int main() {
	kyel::kyel();
	return 0;
}

```


---

## 作者：Owen_codeisking (赞：9)

如果没有 $subtask$ 时间取 $min$ 的机制，这份代码将跑得比所有代码都快得多。。。

首先看到这题一眼边分治 + 虚树上 $dp$，后来看到没有保证 $d_i$ 互不相等就不会搞了。。。

算了，老老实实算贡献吧。

我们对于每个点对 $(x,y)$ 算它的贡献。

$x,y\not =LCA(x,y)$，贡献是 $siz_x\times siz_y\times dep_{LCA(x,y)}$

不妨令 $x=LCA(x,y)$，那么若 $z$ 是 $x\rightarrow y$ 路径的第二个点，贡献是 $(n-siz_z)\times siz_y\times dep_{LCA(x,y)}$

因为三个东西乘起来不好处理，我们把 $dep$ 这个限制差分一下，把 $y\rightarrow rt$ 加 $siz_y$，然后枚举 $x$，求 $x\rightarrow rt$ 的和，乘上 $siz_x$。

第一个部分的贡献是可以离线处理的，时间复杂度 $O(n)/O(n\log n)$，你可以像我一样求和那部分直接预处理 $dfs$ 序前缀和后暴力向上跳。

当然，第一个部分的贡献我们多算了，我们要在第二部分减掉。

第二个部分的贡献就暴力多了，假设 $dfs$ 的时候遍历的是 $x\rightarrow y$ 这条边，我们把 $d_x\rightarrow rt$ 加 $n-siz_y-siz_x$，遍历完 $y$ 的子树后减去这个值，然后遍历到一个点暴力向上跳就行了。

时间复杂度 $O(n\log^2 m)$，而且这一个是树剖的 $\log$ 一个是线段树/树状数组的 $\log$，常数极小就对了。

$Code\ Below:$

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int maxn=300000+10;
const int mod=998244353;
int n,m,rt,a[maxn],fa[maxn],siz[maxn],ans,head[maxn],to[maxn<<1],nxt[maxn<<1],tot;

namespace Tree
{
int c[2][maxn],w[maxn],val[maxn],head[maxn],to[maxn],nxt[maxn],tot;
int top[maxn],dep[maxn],siz[maxn],son[maxn],fa[maxn],id[maxn],mp[maxn],tim;
#define lowbit(x) ((x)&(-(x)))
inline void add(int *c,int x,int y)
{
    for(;x<=m;x+=lowbit(x)) c[x]=(c[x]+y)%mod;
}
inline int Ask(int *c,int x)
{
    int ans=0;
    for(;x;x-=lowbit(x)) ans=(ans+c[x])%mod;
    return ans;
}
inline void Update(int x,int v) {add(c[0],x,v);add(c[1],x,1ll*(x-1)*v%mod);}
inline void update(int l,int r,int v) {Update(l,v);Update(r+1,mod-v);}
inline int Query(int x) {return (1ll*x*Ask(c[0],x)%mod-Ask(c[1],x)+mod)%mod;}
inline int query(int l,int r) {return (Query(r)-Query(l-1)+mod)%mod;}
inline void modify(int x,int y)
{
    for(;x;x=fa[top[x]]) update(id[top[x]],id[x],y);
}
inline int ask(int x)
{
    int ans=0;
    for(;x;x=fa[top[x]]) ans=(ans+query(id[top[x]],id[x]))%mod;
    return ans;
}
inline int ask_pre(int x)
{
    int ans=0;
    for(;x;x=fa[top[x]]) ans=(ans+(val[id[x]]-val[id[top[x]]-1]+mod)%mod)%mod;
    return ans;
}
inline void addedge(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void dfs1(int x,int f)
{
    siz[x]=1;fa[x]=f;dep[x]=dep[f]+1;
    int maxson=-1;
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        dfs1(y,x);siz[x]+=siz[y];w[x]=(w[x]+w[y])%mod;
        if(siz[y]>maxson) maxson=siz[y],son[x]=y;
    }
}
void dfs2(int x,int topf)
{
    id[x]=++tim;mp[tim]=x;top[x]=topf;
    if(son[x]) dfs2(son[x],topf);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==son[x]) continue;
        dfs2(y,y);
    }
}
inline void init()
{
    scanf("%d",&fa[1]);
    for(int i=2;i<=m;i++) scanf("%d",&fa[i]),addedge(fa[i],i);
    scanf("%*s");
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) w[a[i]]=(w[a[i]]+::siz[i])%mod;
    for(int i=head[1];i;i=nxt[i]) dfs1(to[i],0),dfs2(to[i],to[i]);
    for(int i=1;i<=m;i++) val[i]=w[mp[i]];
    for(int i=1;i<=m;i++) val[i]=(val[i]+val[i-1])%mod;
}
}

inline void addedge(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void dfs(int x)
{
    siz[x]=1;
    for(int i=head[x];i;i=nxt[i]) dfs(to[i]),siz[x]+=siz[to[i]];
}
void dfs1(int x)
{
    ans=(ans+1ll*Tree::ask(a[x])*siz[x]%mod)%mod;
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        Tree::modify(a[x],(n-siz[y]-siz[x]+mod)%mod);
        dfs1(y);
        Tree::modify(a[x],(siz[y]+siz[x]-n+mod)%mod);
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&fa[i]);
        if(!fa[i]) rt=i;
        else addedge(fa[i],i);
    }
    dfs(rt);Tree::init();
    for(int i=1;i<=n;i++)
    {
        ans=(ans+1ll*Tree::ask_pre(a[i])*siz[i]%mod)%mod;
        ans=(ans+1ll*siz[i]*siz[i]%mod*(mod-Tree::dep[a[i]])%mod)%mod;
    }
    ans=1ll*ans*((mod+1)>>1)%mod;dfs1(rt);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Arghariza (赞：6)

upd 2023/9/7：修了一点锅。

$T$ 是节点数为 $n$ 的那棵树，$T'$ 是 Trie 树。带 $'$ 的，比如 $\text{dep}'_u$，表示 Trie 上的信息（注意到 $\text{dep}'$ 要从 $0$ 开始），不带的表示原树。$[u,v]$ 表示 $u\to v$ 的路径，$S$ 是原树上无序点对的全集。

那么答案就是：

$$\sum\limits_{(s,t)\in S}\sum\limits_{[u,v]\subseteq [s,t]}\text{dep}'_{\text{lca}(u,v)}$$

考虑枚举 $(u,v)$ 分情况计算贡献：

- $\text{lca}(u,v)\neq u,v$：显然包含 $[u,v]$ 的路径数为 $\text{siz}_u\text{siz}_v$
- 否则设 $u$ 为 $v$ 的祖先，$w$ 为 $u$ 向 $v$ 延伸的那个儿子，那么经过 $[u,v]$ 的路径数为 $(n-\text{siz}_w)\text{siz}_v$。

考虑第一种贡献咋算，根据某道[经典题](https://www.luogu.com.cn/problem/P4211)的套路，一个简单的想法是枚举 $u$，然后 $[u\to \text{root}']$ 上面所有点增加 $\text{siz}_u$，然后枚举 $v$，对 $[v\to\text{root}']$ 求和乘上 $\text{siz}_v$ 即可。但是要除掉根的贡献，因为 $\text{dep}'_{\text{root}'}=0$。

然后对于第二种贡献，我们直接对 $T$ 搜一遍，到了一个点 $v$，考虑它到 $\text{root}$ 的路径对 $v$ 的贡献和。我们到一个点 $u$，枚举出边 $u\to w$，直接给 $[u,\text{root}']$ 加上 $n-\text{siz}_w$，然后往 $w$ 走，回溯的时候再减去即可。

但是这样会算重，发现在第一种贡献中，在 $u$ 子树内的 $v$ 也被计算了。冷静分析一下，因为算重的 $(u,v)$ 均满足 $v$ 在 $u$ 子树内，所以我们做第二种贡献的时候将增量 $n-\text{siz}_w$ 变成 $n-\text{siz}_w-\text{siz}_u$ 即可。

然后线段树随便做了，复杂度 $O(n\log^2 n)$。自认为写得很清新。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace vbzIO {
    char ibuf[(1 << 20) + 1], *iS, *iT;
    #if ONLINE_JUDGE
    #define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
    #else
    #define gh() getchar()
    #endif
    #define pc putchar
    #define pi pair<int, int>
    #define tu3 tuple<int, int, int>
    #define tu4 tuple<int, int, int, int>
    #define mp make_pair
    #define mt make_tuple
    #define fi first
    #define se second
    #define pb push_back
    #define ins insert
    #define era erase
    inline int read () {
        char ch = gh();
        int x = 0;
        bool t = 0;
        while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
        while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
        return t ? ~(x - 1) : x;
    }
    inline void write(int x) {
        if (x < 0) {
            x = ~(x - 1);
            putchar('-');
        }
        if (x > 9)
            write(x / 10);
        putchar(x % 10 + '0');
    }
}
using vbzIO::read;
using vbzIO::write; 

const int mod = 998244353;
const int maxn = 3e5 + 300;
const int inv2 = (mod + 1) / 2;
struct seg { int sum, tag; } tr[maxn << 2];
int n, m, rt, dfc, ans, fa[maxn], a[maxn];
int sz[maxn], dep[maxn], siz[maxn], fath[maxn], son[maxn], top[maxn], id[maxn], d[maxn];
vector<int> t1[maxn], t2[maxn];

#define ls x << 1
#define rs x << 1 | 1
#define mid ((l + r) >> 1)
void pushup(int x) { tr[x].sum = (tr[ls].sum + tr[rs].sum) % mod; }
void pushtag(int x, int c, int l, int r) { (tr[x].sum += 1ll * c * (r - l + 1) % mod) %= mod, (tr[x].tag += c) %= mod; }
void pushdown(int x, int l, int r) {
	if (!tr[x].tag) return;
	pushtag(ls, tr[x].tag, l, mid), pushtag(rs, tr[x].tag, mid + 1, r);
	tr[x].tag = 0;
}

void upd(int l, int r, int s, int t, int c, int x) {
	if (s <= l && r <= t) return pushtag(x, c, l, r);
	pushdown(x, l, r);
	if (s <= mid) upd(l, mid, s, t, c, ls);
	if (t > mid) upd(mid + 1, r, s, t, c, rs);
	pushup(x);
}

int qry(int l, int r, int s, int t, int x) {
	if (s <= l && r <= t) return tr[x].sum;
	int res = 0;
	pushdown(x, l, r);
	if (s <= mid) (res += qry(l, mid, s, t, ls)) %= mod;
	if (t > mid) (res += qry(mid + 1, r, s, t, rs)) %= mod;
	return res;
}

void updp(int u, int c) {
	c %= mod;
	while (u) {
		upd(0, m, id[top[u]], id[u], c, 1);
		u = fath[top[u]];
	}
}

int qryp(int u) {
	int res = 0;
	while (u) {
		(res += qry(0, m, id[top[u]], id[u], 1)) %= mod;
		u = fath[top[u]];
	}
	return res;
}

void dfs1(int u, int fat) {
	siz[u] = 1, dep[u] = dep[fat] + 1;
	for (int v : t2[u]) {
		dfs1(v, u), siz[u] += siz[v];
		if (siz[v] > siz[son[u]]) son[u] = v; 
	}
}

void dfs2(int u, int pre) {
	top[u] = pre, id[u] = ++dfc;
	if (son[u]) dfs2(son[u], pre);
	for (int v : t2[u]) {
		if (v == son[u]) continue;
		dfs2(v, v);
	}
} 

void dfs3(int u) {
	sz[u] = 1;
	for (int v : t1[u]) 
		dfs3(v), sz[u] += sz[v];
}

void dfs4(int u) {
	for (int v : t2[u]) 
		dfs4(v), (d[u] += d[v]) %= mod;
}

void dfs5(int u, int fat) {
	(d[u] += d[fat]) %= mod;
	for (int v : t2[u]) dfs5(v, u);
}

void dfs6(int u) {
	(ans += 1ll * sz[u] * qryp(a[u]) % mod) %= mod;
	for (int v : t1[u]) {
		updp(a[u], mod + n - sz[u] - sz[v]);
		dfs6(v);
		updp(a[u], mod - n + sz[u] + sz[v]); 
	}
}

int main() {
	n = read(), m = read();
	for (int i = 1; i <= n; i++) {
		fa[i] = read(); 
		if (!fa[i]) rt = i;
		else t1[fa[i]].pb(i);
	}
	for (int i = 1; i <= m; i++) {
		fath[i] = read();
		if (fath[i]) t2[fath[i]].pb(i);
	}
	scanf("%*s");
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int u : t2[1]) dep[u] = 1, fath[u] = 0, dfs1(u, 0), dfs2(u, u);
	dfs3(rt);
	for (int i = 1; i <= n; i++) (d[a[i]] += sz[i]) %= mod;
	dfs4(1), d[1] = 0, dfs5(1, 0);
	for (int i = 1; i <= n; i++) {
		ans = (ans + 1ll * sz[i] * d[a[i]] % mod) % mod;
		ans = (ans + mod - 1ll * sz[i] * sz[i] % mod * dep[a[i]] % mod) % mod;
	}
	ans = 1ll * ans * inv2 % mod;
	dfs6(rt);
	write(ans);
	return 0;
}
```

---

## 作者：Petit_Souris (赞：4)

别点分治了兄弟，这个题不是随便 1log 嘛！

首先 LCP 的长度就是两个串在 trie 树上的 LCA 的深度，这是显然的。出现了 LCA 的深度，你应当条件反射出 LNOI LCA 那个题的做法，也就是将 $dep_{\operatorname{LCA}(u,v)}$ 转化为 $u\to rt$ 路径 $+1$，查询 $v\to rt$ 路径和。

那么我们改变一下贡献方式，枚举子路径，计算包含他的路径条数。这时候需要分类讨论一下（设 $dep_u\le dep_v$）：当 $u,v$ 之间没有祖先后代关系时，有 $sz_usz_v$ 条路径包含 $(u,v)$；当 $u$ 是 $v$ 的祖先时，有 $sz_v(n-sz_u)$ 条路径包含 $(u,v)$。这时候一个 naive 的想法就是直接搞个树套树来做这件事情（trie 树 dfn 一个限制，原树祖先链一个限制，动态二维数点），但是会得到 $\mathcal O(n\log ^3n)$ 的升天复杂度。

仔细一想发现祖先 - 后代这个限制可以直接 dfs 一遍，每次维护根到当前点的信息，这样这个限制就直接搞定了。直接树剖是 $\mathcal O(n\log^2n)$ 的。LCT 或者全局平衡二叉树做链加链查可以做到 $\mathcal O(n\log n)$。不过我好像根本不会全局平衡二叉树，找个时间学一下看看。

实际上细节比较多。我们先把祖先 - 后代当成一般情况算，最后再把祖先 - 后代要额外加入的贡献计入答案。额外的贡献实际上是 $n-sz_u-sz_z$，其中 $z$ 是 $u\to v$ 路径上第一个点（因为 $sz_u$ 的贡献已经在一般情况里算过了），那么 dfs 的时候修改应该在遍历对应的边的时候改而不是在对应的根节点改。

看懂了 GBST，补个代码。GBST 可以标记永久化，常数爆小。~~建议时限开小到 1s。~~

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=3e5+9,Mod=998244353;
ll n,m,fa1[N],fa2[N],rt1,a[N];
vector<ll>to1[N],to2[N];
ll sz1[N],sz2[N],son[N];
char str[N];
void dfs1(ll x){
    sz1[x]=1;
    for(ll y:to1[x])dfs1(y),sz1[x]+=sz1[y];
}
void dfs2(ll x){
    sz2[x]=1;
    for(ll y:to2[x]){
        dfs2(y),sz2[x]+=sz2[y];
        if(sz2[y]>sz2[son[x]])son[x]=y;
    }
}
ll pt[N],sum[N],hsiz[N],ls[N],rs[N],gfa[N],tag[N],tr[N];
ll Build(ll l,ll r){
    ll ql=l,qr=r-1,cent=l;
    while(ql<=qr){
        ll mid=(ql+qr)>>1;
        if(2*(sum[mid]-sum[l])<=sum[r]-sum[l])cent=mid,ql=mid+1;
        else qr=mid-1;
    }
    hsiz[pt[cent]]=r-l;
    if(l<cent)ls[pt[cent]]=Build(l,cent),gfa[ls[pt[cent]]]=pt[cent];
    if(cent+1<r)rs[pt[cent]]=Build(cent+1,r),gfa[rs[pt[cent]]]=pt[cent];
    return pt[cent];
}
ll Build(ll x){
    ll u=x;
    do{
        for(ll v:to2[u]){
            if(v==son[u])continue;
            gfa[Build(v)]=u;
        }
        u=son[u];
    }while(u);
    ll len=0;u=x;
    do{
        pt[len]=u,len++,sum[len]=sum[len-1]+sz2[u]-sz2[son[u]];
        u=son[u];
    }while(u);
    return Build(0,len);
}
ll S;
void Add(ll x,ll k){
    S=(S+k)%Mod;
    bool rg=1;ll siz=0;
    while(x){
        tr[x]=(tr[x]+siz*k)%Mod;
        if(rg){
            tag[x]=(tag[x]+k)%Mod;
            if(rs[x])tag[rs[x]]=(tag[rs[x]]-k+Mod)%Mod;
            siz+=hsiz[ls[x]]+1;
            tr[x]=(tr[x]-hsiz[rs[x]]*k%Mod+Mod)%Mod;
        }
        rg=(x!=ls[gfa[x]]);
        if(x!=ls[gfa[x]]&&x!=rs[gfa[x]])siz=0;
        x=gfa[x];
    }
}
ll Query(ll x){
    bool rg=1;ll siz=0,res=0;
    while(x){
        if(rg){
            res=(res+tr[x])%Mod;
            if(rs[x])res=(res-tr[rs[x]]+Mod)%Mod;
            res=(res-hsiz[rs[x]]*tag[rs[x]]%Mod+Mod)%Mod;
            siz+=hsiz[ls[x]]+1;
        }
        res=(res+siz*tag[x])%Mod;
        rg=(x!=ls[gfa[x]]);
        if(x!=ls[gfa[x]]&&x!=rs[gfa[x]])siz=0;
        x=gfa[x];
    }
    return (res-S+Mod)%Mod;
}
ll ans;
void dfs3(ll x){
    ans=(ans+Query(a[x])*sz1[x])%Mod;
    for(ll y:to1[x]){
        Add(a[x],(n-sz1[x]-sz1[y]+Mod)%Mod);
        dfs3(y);
        Add(a[x],(-n+sz1[x]+sz1[y]+Mod)%Mod);
    }
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    n=read(),m=read();
    rep(i,1,n)fa1[i]=read();
    rep(i,1,n){
        if(!fa1[i])rt1=i;
        else to1[fa1[i]].push_back(i);
    }
    rep(i,1,m)fa2[i]=read();
    rep(i,2,m)to2[fa2[i]].push_back(i);
    scanf("%s",str);
    rep(i,1,n)a[i]=read();
    dfs1(rt1),dfs2(1),Build(1);
    rep(i,1,n){
        ans=(ans+Query(a[i])*sz1[i])%Mod;
        Add(a[i],sz1[i]);
    }
    rep(i,1,n)Add(a[i],(Mod-sz1[i])%Mod);
    dfs3(rt1);
    write(ans);
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：N2MENT (赞：3)

不知道 xjx 在干什么。

***

转换一下题意，答案为 $\sum_{(x, y),x<y} \sum_{[u, v]\supseteq[x,y]}\operatorname{lcp} (S_x, S_y)$，记 $cnt_{x, y}$ 表示经过 $x$ 和 $y$ 的无向路径数 $ans = \sum_{(x, y),x<y}  \operatorname{lcp} (S_x, S_y) cnt_{x, y}$。

经过 $x$ 和 $y$ 的路径如何计数，分两种情况：

- $x$ 和 $y$ 无祖先关系，$cnt_{x, y} = siz_x siz_y$；

- $x$ 为 $y$ 的祖先，$cnt_{x, y}= siz_y (n - siz_z),z\in son_u,y\in subtree_z$。

由于[这道题](https://www.luogu.com.cn/problem/P4211)的存在，立刻想到在 trie 上链加链求和来统计贡献，两种情况都挺好算的，边遍历边处理就好了，下面是先算的第二种情况。

有祖先关系：
```cpp
void Dfs1(int u, int fa) {
	ans = (ans + 1ll * T.Query(d[u]) * siz[u] % mod) % mod;
	T.Modify(d[u], n);
	for(int v : G[u]) {
		if(v == fa) continue;
		T.Modify(d[u], mod - siz[v]);
		Dfs1(v, u);
		T.Modify(d[u], siz[v]);
	}
	T.Modify(d[u], mod - n);
}
```

无祖先关系：

```cpp
void Dfs2(int u, int fa) {
	ans = (ans + 1ll * T.Query(d[u]) * siz[u] % mod) % mod;
	for(int v : G[u]) {
		if(v == fa) continue;
		Dfs2(v, u);
	}
	T.Modify(d[u], siz[u]);
}
```

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO {
}
using IO::read;
using IO::write;
const int maxn = 3e5 + 10;
const int mod = 998244353;
int n, m;
class SegTree {
public:
	#define lc (k << 1)
	#define rc (k << 1 | 1)
	int tr[maxn << 2], lazy[maxn << 2];
	void Update(int k) {
		tr[k] = (tr[lc] + tr[rc]) % mod;
	}
	void Push(int k, int l, int r) {
		if(!lazy[k]) return;
		lazy[k] = (lazy[k] % mod + mod) % mod;
		int mid = (l + r) >> 1;
		tr[lc] = (tr[lc] + 1ll * lazy[k] * (mid - l + 1) % mod) % mod, lazy[lc] = (lazy[lc] + lazy[k]) % mod;
		tr[rc] = (tr[rc] + 1ll * lazy[k] * (r - mid) % mod) % mod, lazy[rc] = (lazy[rc] + lazy[k]) % mod;
		lazy[k] = 0;
	}
	void Modify(int k, int l, int r, int L, int R, int val) {
		if(L <= l && r <= R) {
			val = (val % mod + mod) % mod;
			tr[k] = (tr[k] + 1ll * val * (r - l + 1) % mod) % mod;
			lazy[k] = (lazy[k] + val) % mod;
			return;
		}
		Push(k, l, r);
		int mid = (l + r) >> 1;
		if(L <= mid) Modify(lc, l, mid, L, R, val);
		if(R > mid) Modify(rc, mid + 1, r, L, R, val);
		Update(k);
	}
	int Query(int k, int l, int r, int L, int R) {
		if(L <= l && r <= R) return tr[k];
		Push(k, l, r);
		int mid = (l + r) >> 1, res = 0;
		if(L <= mid) res = (res + Query(lc, l, mid, L, R)) % mod;
		if(R > mid) res = (res + Query(rc, mid + 1, r, L, R)) % mod;
		return res;
	}
};
class Trie {
public:
	SegTree sgt;
	vector<int> G[maxn];
	int fa[maxn], top[maxn], dep[maxn], siz[maxn], son[maxn], id[maxn], cnt;
	void Dfs1(int u, int f) {
		fa[u] = f;
		dep[u] = dep[f] + 1;
		siz[u] = 1;
		for(int v : G[u]) {
			if(v == f) continue;
			Dfs1(v, u);
			siz[u] += siz[v];
			if(!son[u] || siz[son[u]] < siz[v]) son[u] = v;
		}
	} 
	void Dfs2(int u, int tp) {
		id[u] = ++cnt;
		top[u] = tp;
		if(son[u]) Dfs2(son[u], tp);
		for(int v : G[u]) {
			if(v == fa[u] || v == son[u]) continue;
			Dfs2(v, v);
		}
	}
	void Init() {
		Dfs1(1, 0),	Dfs2(1, 1);
	}
	void Modify(int u, int val) {
		while(top[u]) {
			sgt.Modify(1, 1, m, id[top[u]], id[u], val);
			u = fa[top[u]];
		}
		sgt.Modify(1, 1, m, 1, 1, -val);
	}
	int Query(int u) {
		int res = 0;
		while(top[u]) {
			res = (res + sgt.Query(1, 1, m, id[top[u]], id[u])) % mod;
			u = fa[top[u]];
		}
		return res;
	}
}T;
vector<int> G[maxn];
int siz[maxn];
int d[maxn];
int ans = 0;
int root;
void Dfs(int u, int fa) {
	siz[u] = 1;
	for(int v : G[u]) {
		if(v == fa) continue;
		Dfs(v, u);
		siz[u] += siz[v];
	}
}
void Dfs1(int u, int fa) {
	ans = (ans + 1ll * T.Query(d[u]) * siz[u] % mod) % mod;
	T.Modify(d[u], n);
	for(int v : G[u]) {
		if(v == fa) continue;
		T.Modify(d[u], mod - siz[v]);
		Dfs1(v, u);
		T.Modify(d[u], siz[v]);
	}
	T.Modify(d[u], mod - n);
}
void Dfs2(int u, int fa) {
	ans = (ans + 1ll * T.Query(d[u]) * siz[u] % mod) % mod;
	for(int v : G[u]) {
		if(v == fa) continue;
		Dfs2(v, u);
	}
	T.Modify(d[u], siz[u]);
}
int main() {
	n = read(), m = read();
	for(int i = 1; i <= n; i++) {
		int f = read();
		if(!f) {
			root = i;
			continue;
		}
		G[i].emplace_back(f);
		G[f].emplace_back(i);
	}
	for(int i = 1; i <= m; i++) {
		int f = read();
		if(!f) continue;
		T.G[i].emplace_back(f);
		T.G[f].emplace_back(i);
	}
	read();
	for(int i = 1; i <= n; i++)	d[i] = read();
	T.Init();
	Dfs(root, 0);
	Dfs1(root, 0);
	Dfs2(root, 0);
	write(ans);
}
```


---

## 作者：EternalAlexander (赞：3)

出题人在NOI的时候告诉了我这道题，然后就口胡了一个和标算不太一样的做法。
    
​	首先考虑点对的贡献，即$\sum depth(lca(u,v))$如何处理。

​	对第一棵树重链剖分，然后对每一个节点$u$考虑lca是$u$的所有点对的贡献。依次dfs节点$u$的每一棵子树中的所有节点，对于dfs到的节点$v$，因为点对有序，只需要考虑$u$的所有子树中$v$所在的子树之后的子树中的节点与$v$匹配产生的贡献，显然这些点对应dfs序上一个区间，求点到区间lca的深度和可以采用[LNOI2014 LCA] 的计算方法。然后发现显然最后一个子树不需要dfs，我们把重子树放到最后一个就能类似dsu on tree的做了。最后对于根节点单独处理一下。

​	然后考虑扩展到所有路径的所有点对的和。对于点对$(u, v)$，显然它们被$size(u)\times size(v)$条路径包含，贡献为$size(u)\times size(v) \times depth(lca(u,v))$ 。在上面dsu on tree的过程中我们枚举$u$，可以在询问区间lca的时候可以直接乘上$size(u)$，然后考虑被询问的$v$，我们令$v$被作为lca端点计算的时候贡献乘以$size(v)$即可。如果类似[LNOI2014 LCA]地采用lct解法回答区间lca询问，在操作时将当前点到根的所有点权值$+1$改成$+size(v)$就能处理了。

​	认为$n,m$同级的话，复杂度$nlog^2n$。

---

## 作者：sqrtqwq (赞：1)

为了方便，我们定义没有 $'$ 的就是原本的树上的，有 $'$ 的就是 Trie 树上的。以及 $[u,v]$ 是 $u$ 到 $v$ 的路径，$S$ 表示原树的点集。所以答案就是：

$$\sum_{(s,t) \in S} \sum_{[u,v] \in [s,t]} dep^{'}_{lca(u,v)}$$

所以贡献就可以分成两种：

1. $\operatorname{lca}(u,v) \neq u,v$：显然，包含 $u$ 和 $v$ 的路径一共有 $siz_u \times siz_v$。

对于这种情况，我们可以直接枚举 $u$，然后在路径 $[u,root^{'}]$ 中的所有点加上 $siz_u$，并且求出路径 $[v,root^{'}]$ 上所有点的和再乘上 $siz_v$。最后在除掉根的贡献即可。

2. $u$ 是 $v$ 的祖先，此处定义 $w$ 为 $u$ 向 $v$ 方向延伸的儿子，那么通过 $u,v$ 的路径树为 $(n - siu_w) \times siz_v$。

对于这种贡献，我们直接对于原树搜索一遍，到了一个 $v$，考虑它到根节点的路径对 $v$ 的贡献和。然后我们到了一个点 $u$，然后枚举边 $u \to w$，并给 $[u,root^{'}]$ 加上 $n - siz_w$，然后向 $w$ 走，当回溯时消去贡献即可。

但是我们发现这么做会有问题。在 $u$ 子树内的 $v$ 也被计算了。算重的 $(u,v)$ 均满足 $v$ 在 $u$ 子树内，所以把加的数改为 $n - siz_w - siz_u$ 即可。

然后拿一个线段树维护即可，时间复杂度为 $O(n \log^2 n)$。

---

## 作者：hfjh (赞：1)

# P5439 【XR-2】永恒
## 题意

给出两棵树  $T_{1}, T_{2}$ , 其中  $T_{1}$  的大小为 $n\left(1 \leq n \leq 2 * 10^{5}\right)$, $T_{2}$ 的大小为 $m\left(1 \leq m \leq 10^{6}\right)$。在 $T_{1}$ 上每个点有一个权值 $a_{i}$，满足 $1 \leq a_{i} \leq m$。

定义无向点对 $(u, v)$ 的权值 $f(u, v)$ 为 $u, v$ 在 $T_{2}$ 上的 $lca$ 的深度, 这里定义根节点深度为 $1$。
定义 $\operatorname{Path}_{(u, v)}$ 为 $T_{1}$ 中从 $u$ 到 $v$ 最短路径上的点的集合。
请你求出 $\sum_{1 \leq u<v \leq n} \sum_{i, j \in \text { Path }_{(u, v)}} f\left(a_{i}, a_{j}\right)[i<j] \bmod 998244353$。

$n\le10^5$

## 题解

先考虑 $O(n^2)$ 枚举 $(u,v)$ 点对，然后 $O(\log n)$ 求出 $f(a_i,a_j)$，再看一下 $T_1$ 中有多少条路径会包含 $(u,v)$。

若 $(u,v)$ 是祖先后代关系，就有 $siz_v \times (n-siz_{son_u})$，否则就是 $siz_u \times siz_v$。

（$son_u$ 表示 $v$ 对应那棵子树）。

我们现在枚举 $T_1$ 中一个点 $x$ 考虑其他点和他的贡献。

我们先考虑点是非祖先后代关系的情况。

$$
siz_x\sum_jf(a_x,a_j)siz_j = siz_x\sum_j dep_{lca(a_x,a_j)} siz_j
$$

我们考虑 $\sum_j dep_{lca(a_x,a_j)} siz_j$ 可以这样做：

- 在 T2 中树链剖分，把 $a_j$ 到根的所有节点加上 $siz_j$。

- 求答案就直接查找 $a_x$ 到根节点和。

再乘上系数 $siz_x$。

我们考虑祖先后代关系情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/o389mzhy.png)

分为左，下，右，上三个部分。

左，右和 $x$ 都是非祖先后代关系，按照 $siz_x$ 和按照 $siz_j$ 的系数计算。

上点 $j$ 和 $x$ 按照 $siz_x$ 和 $n-siz_{son_i}$ 的系数计算。

下点 $j$ 和 $x$ 按照 $siz_{son_x}$ 和 $j$ 的系数计算。

我们建 3 棵线段树分别记录左，上，右的节点。（等会儿在考虑下的节点）

用 dfs，那么左，上，右的节点分别表示：搜过了且不在搜索栈，搜过且在搜索栈，没搜过且不在子树内。

最初线段树 $3$ **有所有点**，权值为 $siz_i$。

这是核心代码，可以根据代码理解过程。

```cpp
void dfs(int x){
    (ans += E1::siz[x] *  E2::query(1, a[x]) % mod) %= mod;//计算左的答案
    E2::add(3, a[x], -E1::siz[x]);//线段树3中删除 a[x] 点，权值为siz[x]
    for(int y : E1::e[x]){
        E2::add(2, a[x], E1::n - E1::siz[y]);//线段树2中添加 a[x] 点，权值为 n - siz[y]
        dfs(y);
        E2::add(2, a[x], -(E1::n - E1::siz[y]));//线段树2中删除 a[x] 点，权值为 n - siz[y]
    }
    (ans += E2::query(2, a[x]) * E1::siz[x] % mod) %= mod;//计算上的答案
    (ans += E2::query(3, a[x]) * E1::siz[x] % mod) %= mod; //计算右的答案
    E2::add(1, a[x], E1::siz[x]);//线段树1中添加 a[x] 点，权值为 siz[x]
    return ;
}
```

现在来考虑下的答案。

当处理完 $x$ 的儿子 $y$ 的一棵子树时，这棵子树的所有节点都会到线段树 1 中，我们可以根据这个性质进行查分从而只考虑 $y$ 中的贡献。

```cpp
void dfs(int x){
	ll las = E2::query(1, a[x]), now;//差分
	(ans += E1::siz[x] * las % mod) %= mo//计算左的答案﹁竟
	E2::add(3, a[x], -E1::siz[x] + mod);//线段树3中删除 a[x] 点，权值为siz[x]
	for(int y : E1::e[x]){
		E2::add(2, a[x], E1::n - E1::siz[y] + mod);//线段树2中添加 a[x] 点，权值为 n - siz[y]

		dfs(y);
		now = E2::query(1, a[x]);//
		(ans += (now - las) * (E1::n - E1::siz[y]) % mod) %= mod;//计算下的答案
		las = now;//差分
		E2::add(2, a[x], -(E1::n - E1::siz[y]) + mod);//线段树2中删除 a[x] 点，权值为 n - siz[y]
	}
	(ans += E2::query(2, a[x]) * E1::siz[x] % mod) %= mod;//计算上的答案
	(ans += E2::query(3, a[x]) * E1::siz[x] % mod) %= mod; //计算右的答案
	E2::add(1, a[x], E1::siz[x]);//线段树1中添加 a[x] 点，权值为 siz[x]
	return ;
}
```


## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long 
#define puba push_back
using namespace std;
const int N = 1e6 + 10, mod = 998244353;
int fa, a[N];
ll ans = 0;
string _; 
struct SGT{
	struct node{
		ll sum, tag;
		
	}tr[4 * N];
	void updata(int x){
		tr[x].sum = (tr[x << 1].sum + tr[x << 1 | 1].sum) % mod;
	}
	void pushtag(int x, int l, int r){
		if(tr[x].tag){
			int mid = (l + r) >> 1;
			(tr[x << 1].sum += tr[x].tag * (mid - l + 1) % mod) %= mod;
			(tr[x << 1].tag += tr[x].tag) %= mod;
			(tr[x << 1 | 1].sum += tr[x].tag * (r - mid) % mod) %= mod;
			(tr[x << 1 | 1].tag += tr[x].tag) %= mod;
			tr[x].tag = 0;
		}
	}
	void add(int x, int l, int r, int L, int R, ll v){
		if(L <= l && r <= R){
			(tr[x].sum += (r - l + 1) * v % mod) %= mod;
			(tr[x].tag += v) %= mod;
			return ;
		}
		pushtag(x, l, r);
		int mid = (l + r) >> 1;
		if(L <= mid) add(x << 1, l, mid, L, R, v);
		if(R > mid) add(x << 1 | 1, mid + 1, r, L, R, v);
		updata(x);
	}
	ll query(int x, int l, int r, int L, int R){
		if(L <= l && r <= R){
			return tr[x].sum %= mod;
		}
		pushtag(x, l, r);
		ll ans = 0;
		int mid = (l + r) >> 1;
		if(L <= mid) (ans += query(x << 1, l, mid, L, R)) %= mod;
		if(R > mid) (ans += query(x << 1 | 1, mid + 1, r, L, R)) %= mod;
		updata(x);
		return ans;
	}
	void print(){
		for(int i = 1; i <= 10; ++i){
			cout<<i<<' '<<tr[i].sum<<' '<<tr[i].tag<<'\n';
		}
	}
}sgt[4];
namespace E1{
	int n, rt;
	int siz[N];
	vector<int> e[N];
	void dfs(int x){
		siz[x] = 1;
		for(int y : e[x]){
			dfs(y);
			siz[x] += siz[y];
		}
	}
}
namespace E2{
	int n, rt, tot;
	int fa[N], dep[N], siz[N], hs[N];
	int top[N], dfn[N]; 
	vector<int> e[N];
	void dfs1(int x){
		siz[x] = 1;
		int mx = 0;
		for(int y : e[x]){
			dep[y] = dep[x] + 1;
			fa[y] = x;
			dfs1(y);
			siz[x] += siz[y];
			if(mx < siz[y]){
				mx = siz[y];
				hs[x] = y;
			}
		}
	}
	void dfs2(int x){
		dfn[x] = ++tot;
		if(!hs[x]) return ;
		top[hs[x]] = top[x]; 
		dfs2(hs[x]);
		for(int y : e[x]){
			if(y == hs[x]) continue;
			top[y] = y;  
			dfs2(y);
		}
	}
	void add(int id, int x, ll v){
		while(x != 0){
			if(dfn[top[x]] != 1) sgt[id].add(1, 1, n, dfn[top[x]], dfn[x], v);
			else sgt[id].add(1, 1, n, dfn[top[x]] + 1, dfn[x], v);
			x = fa[top[x]];
		}
	}
	ll query(int id, int x){
		ll ans = 0;
		while(x != 0){
			(ans += sgt[id].query(1, 1, n, dfn[top[x]], dfn[x])) %= mod;
			x = fa[top[x]];
		}
		return ans % mod;
	}
}

void input(){
	cin >> E1::n >> E2::n;
	for(int i = 1; i <= E1::n; ++i){
		cin >> fa; 
		if(fa == 0) E1::rt = i;
		else E1::e[fa].puba(i);
	}
	for(int i = 1; i <= E2::n; ++i){
		cin >> fa; 
		if(fa == 0) E2::rt = i;
		else E2::e[fa].puba(i);
	}
	cin>>_;
	for(int i = 1; i <= E1::n; ++i) cin >> a[i];
}

void pre(){
	E2::dep[E2::rt] = 1;
	E2::top[E2::rt] = E2::rt;
	E1::dfs(E1::rt);
	E2::dfs1(E2::rt);
	E2::dfs2(E2::rt);
	for(int i = 1; i <= E1::n; ++i){
		E2::add(3, a[i], E1::siz[i]);
	}
}
void dfs(int x){
	ll las = E2::query(1, a[x]), now;
	(ans += E1::siz[x] * las % mod) %= mod;//宸﹁竟
	E2::add(3, a[x], -E1::siz[x] + mod);
	for(int y : E1::e[x]){
		E2::add(2, a[x], E1::n - E1::siz[y] + mod);

		dfs(y);
		now = E2::query(1, a[x]);
		(ans += (now - las) * (E1::n - E1::siz[y]) % mod) %= mod;//涓嬮潰
		las = now;
		E2::add(2, a[x], -(E1::n - E1::siz[y]) + mod);
	}
	(ans += E2::query(2, a[x]) * E1::siz[x] % mod) %= mod;//涓婇潰
	(ans += E2::query(3, a[x]) * E1::siz[x] % mod) %= mod; //鍙宠竟
	E2::add(1, a[x], E1::siz[x]);
	return ;
}
int main(){
	cin.tie(0)->sync_with_stdio(false);
	input();

	pre();
	dfs(E1::rt);
	cout<<(ans + mod) % mod * ((mod + 1) / 2) % mod;
	return 0;
}

```

---

## 作者：fzitb7912 (赞：0)

为什么黑。这个字符串有什么用。

## 分析

不难发现题面很难受。它就是在求：$\sum\limits_{u=1}^{n}\sum\limits_{v=u+1}^{n}dep_{\operatorname{LCA(d_u,d_v)}}g_{u,v}$。其中 $dep_i$ 表示 Trie 树上点 $i$ 的深度（根节点深度为 $0$），$\operatorname{LCA}(u,v)$ 为 $u,v$ 两点在 Trie 树上的最近公共祖先，$g_{u,v}$ 为普通树上经过 $u,v$ 两点的简单路径数量。

先看 $g_{u,v}$ 怎么求。简单观察会发现，如果 $u,v$ 不为祖孙关系，那么 $g_{u,v}=siz_u siz_v$，否则 $g_{u,v}=(n-siz_{to})siz_v$。其中 $siz_u$ 表示普通树中 $u$ 为根的子树大小，$to$ 是同时为 $u$ 的儿子与 $v$ 的祖先的点。

如果我们默认所有点都是前一种情况，则需要求：$\sum\limits_{u=1}^{n}\sum\limits_{v=u+1}^{n}siz_usiz_vdep_{\operatorname{LCA}(d_u,d_v)}$。这里有个简单的 trick：求 $dep_{\operatorname{LCA}(u,v)}$ 时可以先将 $u\to root$ 所有边权设为 $1$，那么 $v \to root$ 的边权和就是深度大小。这个证明是简单的。所以我们可以这么干：对于所有 $u$，将 Trie 树上 $d_u \to root$ 的边权增加 $siz_u$，那么对于一个 $v$ 来说，$\sum\limits_{u=1}^{n}siz_udep_{\operatorname{LCA}(d_u,d_v)}$ 就是 $d_v \to root$ 的边权和了。但是这个会将 $(u,u)$ 也算进贡献，减去 $\sum siz_usiz_udep_{d_u}$ 即可。

再考虑祖孙关系。因为我们将 $(n-siz_{to})$ 当作了 $siz_u$，所以还需要增加的贡献是 $\sum (n-siz_{to}-siz_u)siz_vdep_{\operatorname{LCA}(d_u,d_v)}$。根据上面那个 Trick，我们可以去枚举 $u$ 和它的一个儿子 $to$，那么将 $d_u \to root$ 的边权增加 $(n-siz_{to}-siz_u)$ 后，$to$ 为根的子树中任意一个点 $v$ 都可以直接计算 $u,v$ 之间的额外贡献了。最后再遍历完 $to$ 为根的子树后撤销这次修改即可。

那么我们需要维护的就只有链加和链和了，时间复杂度 $O(n\log^2 n)$。

## 代码

```cpp
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)

const int N=3e5+10,p=998244353;
int n,m,root;
int dfn[N],id[N],cnt;
int f[N],top[N],d[N],dep[N];
int siz[N],siz_[N],mson[N];
vector<int> e1[N],e2[N];
struct Tree{
	int l,r,tag,s;
}tr[N<<2];
int ans;

il void up(int u){tr[u].s=(tr[ls(u)].s+tr[rs(u)].s)%p;}
il void down(int u){
	tr[ls(u)].tag+=tr[u].tag,
	tr[rs(u)].tag+=tr[u].tag;
	tr[ls(u)].s+=(tr[ls(u)].r-tr[ls(u)].l+1)*tr[u].tag,
	tr[rs(u)].s+=(tr[rs(u)].r-tr[rs(u)].l+1)*tr[u].tag;
	tr[ls(u)].s=(tr[ls(u)].s%p+p)%p,
	tr[rs(u)].s=(tr[rs(u)].s%p+p)%p;
	return tr[u].tag=0,void(0);
}
il void build(int u,int l,int r){
	tr[u].l=l,tr[u].r=r;
	if(l==r) return ;
	int mid=l+r>>1;
	build(ls(u),l,mid),build(rs(u),mid+1,r);
	return ;
}
il void modify(int u,int l,int r,int x){
	if(l>r) return ;
	if(tr[u].l>=l&&tr[u].r<=r){
		tr[u].tag+=x,
		tr[u].s+=(tr[u].r-tr[u].l+1)*x;
		tr[u].s=(tr[u].s%p+p)%p;
		return ;
	}
	down(u);
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid) modify(ls(u),l,r,x);
	if(mid< r) modify(rs(u),l,r,x);
	return up(u),void(0); 
}
il int query(int u,int l,int r){
	if(l>r) return 0;
	if(tr[u].l>=l&&tr[u].r<=r) return (tr[u].s%p+p)%p;
	down(u);
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid&&mid< r) return ((query(ls(u),l,r)+query(rs(u),l,r))%p+p)%p;
	if(l<=mid) return query(ls(u),l,r);
	return query(rs(u),l,r);
}
il void Modify(int x,int y,int w){
	while(top[x]!=top[y]){
		if(dep[top[x]]>=dep[top[y]]) modify(1,dfn[top[x]],dfn[x],w),x=f[top[x]];
		else modify(1,dfn[top[y]],dfn[y],w),y=f[top[y]];
	}
	if(dep[x]<=dep[y]) modify(1,dfn[x]+1,dfn[y],w);
	else modify(1,dfn[y]+1,dfn[x],w);
	return ;
}
il int Query(int x,int y){
	int res=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]>=dep[top[y]]) res=(res+query(1,dfn[top[x]],dfn[x]))%p,x=f[top[x]];
		else res=(res+query(1,dfn[top[y]],dfn[y]))%p,y=f[top[y]];
	}
	if(dep[x]<=dep[y]) res=(res+query(1,dfn[x]+1,dfn[y]))%p;
	else res=(res+query(1,dfn[y]+1,dfn[x]))%p;
	return res;
}
il void dfs_T1_1(int u){
	siz[u]=1;
	for(auto v:e1[u]){
		dfs_T1_1(v);
		siz[u]+=siz[v];
	}
	return ;
}
il void dfs_T2_1(int u){
	dep[u]=dep[f[u]]+1;
	siz_[u]=1,mson[u]=0;
	for(auto v:e2[u]){
		dfs_T2_1(v);
		siz_[u]+=siz_[v];
		if(siz_[v]>siz_[mson[u]]) mson[u]=v;
	}
	return ;
}
il void dfs_T2_2(int u,int tp){
	top[u]=tp;
	dfn[u]=++cnt,id[cnt]=u;
	if(mson[u]) dfs_T2_2(mson[u],tp);
	for(auto v:e2[u])
	if(v!=mson[u]) dfs_T2_2(v,v);
	return ;
}
il void dfs_T1_2(int u){
	int sum=Query(1,d[u]);
	ans=(ans+sum*siz[u]%p)%p;
	for(auto v:e1[u]){
		int val=(n-siz[v]-siz[u]);
		Modify(1,d[u], val);
		dfs_T1_2(v);
		Modify(1,d[u],-val);
	}
	return ;
}

il void solve(){
	n=rd,m=rd;
	for(re int i=1;i<=n;++i){
		int x=rd;
		if(!x) root=i;
		else e1[x].push_back(i);
	}
	for(re int i=1;i<=m;++i){
		f[i]=rd;
		e2[f[i]].push_back(i);
	}
	string s;cin>>s;
	for(re int i=1;i<=n;++i) d[i]=rd;
	dfs_T1_1(root);
	dfs_T2_1(1),dfs_T2_2(1,1),build(1,1,m);
	for(re int i=1;i<=n;++i) Modify(1,d[i], siz[i]);
	for(re int i=1;i<=n;++i) ans=(ans+siz[i]*Query(1,d[i])%p)%p;
	for(re int i=1;i<=n;++i) ans=((ans-siz[i]*siz[i]%p*(dep[d[i]]-1)%p)%p+p)%p;
	ans=ans*qmi(2,p-2,p)%p;
	for(re int i=1;i<=n;++i) Modify(1,d[i],-siz[i]);
	dfs_T1_2(root);
	printf("%lld\n",ans);
	return ;
}
```

---


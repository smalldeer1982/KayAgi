# [CmdOI2019] 口头禅

## 题目背景

**温馨提示** : 请注意本题特殊的时空限制。

（若您认为使用了复杂度正确的算法但被卡常，可以联系出题人）

一个悠闲的午后，机房里的大佬们都在水群。

## 题目描述

蒟蒻出题人收集了某位大佬的 $n$ 条语录，并按时间为序编号为 $1...n$ 。

他发现这位大佬的口头禅是随着时间而变化的，而且里面有些看不懂的内容。

在请教了群 DS 带师之后，他得到了某种 hash 方法，把这些语录都变成了 01 串，这样似乎好懂一些。

为了研究水群的奥秘，他进行了多次询问 : $[l,r]$ **之间的所有语录，最长公共子串的长度是多少**?

出题人知道这并不是一个简单的问题，所以他并不急于即时得知每个询问的答案。

## 说明/提示

| subtask编号 | 　$\bf n$　 | 　$\bf m$　 | 语录总长 | 分值 |
| :--: | :--: | :--: | :--: | :--: |
| 1 | $50$ | $50$ | $500$ | $10$ |
| 2 | $50$ | $50$ | $8\times 10^4$ | $15$ |
| 3 | $2000$ | $10^4$ | $1.6\times 10^5$ | $15$ |
| 4 | $2\times 10^4$ | $10^5$ | $4\times 10^5$ | $15$ |
| 5 | $2\times 10^4$ | $10^5$ | $4\times 10^5$ | $45$ |

对于subtask**4** : 语录生成后，**之间**的顺序经过随机打乱。

对于subtask**5** : 空间限制为$\texttt{128Mb}$，其他的数据为$\texttt{500Mb}$。

## 样例 #1

### 输入

```
3 3
10111
1111010111
010111111101
1 3
1 2
2 3```

### 输出

```
5
5
6```

## 样例 #2

### 输入

```
10 10
00
010
1000000001
1000000110000001
00010100110101001011000110100001
10111001001010100100000011011
101110010010101001000000101011
1011100100101010010010000111011
1011100100101010011010000101011
0001101001101011
1 4
6 10
5 6
4 6
9 10
7 10
2 10
1 5
1 8
4 7```

### 输出

```
1
6
9
6
10
6
2
1
1
5```

# 题解

## 作者：command_block (赞：27)

这里是官方题解。

**题意** ： 给出 $n$ 个字符串 $S_1,S_2,...S_n$。

共有 $m$ 次询问，每次给出 $l,r$ 求字符串 $S_l,S_{l+1},...S_r$ 的最长公共子串长度。

$n\leq 2\times 10^5,m\leq 10^5,\sum_{i=1}^nS_i\leq 4\times 10^5$ ，时限 $\texttt{0.8s}$ ，空限 $\texttt{64Mb}$。

------------

本题的 SAM 上两个自然根号做法，以及一个 ${\rm poly}(\log)$ 做法 /jy。

关于“自然根号”结论说明，可见 ： [分块相关杂谈](https://www.luogu.com.cn/blog/command-block/fen-kuai-xiang-guan-za-tan)。

小声说 ：这是 $\rm CmdOI2019$ 中唯一一个先有题面后有算法的题目。

- ### **做法①**（std）： 分治

广告 : [后缀自动机学习笔记(应用篇)](https://www.luogu.com.cn/blog/command-block/hou-zhui-zi-dong-ji-xue-xi-bi-ji-ying-yong-pian-post)

- 前置知识 A ： 用 **SAM** 做 [SP-LCS2](https://www.luogu.org/problem/SP1812)

假设有 $n$ 个串，总长为 $len$ ，我们把某个串 $S$ 当做基准匹配串，剩下的是文本串。

对于其中一个匹配串 $T$ ，求 :

$slen[i]$ 表示 $S$ 中 $S[i-slen[i]+1,i]$ 在 $T$ 中出现过，即以 $i$ **结尾**的位置的**最长**匹配长度。

这是经典问题，用 $S$ 在 $T$ 的 SAM 中匹配一次即可求得，故不赘述。

最后将所有匹配串所得到的 $slen[i]$ 取 $\min$ ，最后把整个数组取 $\max$ 即可。

复杂度为 $O(|S|n+len)$ ，建 SAM 的总复杂度 $O(len)$ ，$S$ 要在每个串上跑匹配，复杂度是$O(|S|n)$。

很明显，选择这些字符串中长度最短的串做基准串，跑的最快。

- 前置知识 B ：猫树分治，又称二区间合并等。

可见 [P6240 好吃的题目](https://www.luogu.com.cn/problem/P6240) 及相关题解。

- 原问题

并没有强制在线，考虑猫树分治。

(附 : 把分治树存下来，类似于猫树就可以做到强制在线了。但是所需空间较大，并不实用)

当分治到某个区间时 $[l,r]$ ，选取关键串 $S_k,k\in[l,r]$。处理所有跨越 $k$ 的询问。

以 $S_k$ 为基准匹配串，分别向左向右匹配，求出各个 $slen$ 数组的“前缀 $\min$”

在求答案时，将询问区间的两个端点处的 $slen$ 前缀 $\min$ 合并，然后对整个数组取 $\max$ 即可。

这样，若分治时选择的 $S_k$ 较长，则复杂度会退化。直接使用取中点的普通分治是不可行的，考虑设计更好的分治策略 : **倍增分治**。

对于一个阈值 $x$ ，称长度小于等于 $2^x$ 的为短串，长度大于 $2^{x+1}$ 的为长串。显然长串的个数为 $O(len/2^x)$。

分治到某区间之后，找出所有短串，取其中间位置做基准串。这样分治直到区间里都是长串，将阈值 $x$ 增加 $1$。

接下来计算该算法的复杂度。首先考虑求 $slen$ 的部分。

观察分治树，对于一个 $x$ ，对应的短串在 $O(\log n)$ 层分治后就被耗尽。

而阈值为 $x$ 时，分治区间的总大小是 $O(len/2^x)$ 的，基准匹配串的长度为 $O(2^x)$ ，故花费的时间为 $O(2^x(len/2^x)\log n)=O(len\log n)$。

阈值 $x$ 共有 $O(\log len)$ 个，故总复杂度为 $O(len\log len\log n)$ 。

接下来考虑处理询问的复杂度。

分治中合并答案的复杂度为 $O(\text{对应基准串长度})$。

观察上面的分治，不难发现，一个询问区间所对应的基准串,不会超过区间中最短串的 $2$ 倍。(因为倍增嘛)

由最小值分治的结论，这里会产生一个自然根号。

即 ： 对询问记忆化后，复杂度为 $O(len\sqrt{m})$。

综上所述，总时间复杂度为 $O\big((len+m)\log len\log n+len\sqrt{m}\big)$ ，空间复杂度线性。

由于所有操作均为暴力 `for` 和取 $\min$ ，常数**较小**，可以轻松通过本题的数据范围。

**Code:**

特别神奇的是，下面这份代码我一遍写完就和暴力拍上了，可喜可贺。

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<map>
#define MaxS 400500
#define MaxM 100500
#define MaxN 20500
using namespace std;
inline int read()
{
  int X=0;char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
struct Node
{int t[2],f,len;}a[MaxS<<1];
int tn;
struct SAM
{
  int las,root;
  void add(int c)
  {
    int np=++tn,p=las; las=np;
    a[np].len=a[p].len+1;
    for (;p&&!a[p].t[c];p=a[p].f)a[p].t[c]=np;
    if (!p)a[np].f=root;
    else {
      int v=a[p].t[c];
      if (a[p].len+1==a[v].len)a[np].f=v;
      else {
        int nv=++tn; a[nv]=a[v];
        a[nv].len=a[p].len+1;
        for (;p&&a[p].t[c]==v;p=a[p].f)a[p].t[c]=nv;
        a[v].f=a[np].f=nv;
      }
    }
  }
  void build(char *str,int len)
  {
    las=root=++tn;
    for (int i=0;i<len;i++)
      add(str[i]-'0');
  }
}t[MaxN];
char _str[MaxS],*sp=_str,*str[MaxN];
int ans[MaxM],len[MaxN];
struct Data
{int l,r,pos;}b[MaxM],bl[MaxM],br[MaxM];
int _slen[MaxS<<3],*slen[MaxN],*lenp;
int tp[MaxN];
map<pair<int,int>,int> sav;
void solve(int l,int r,int tl,int tr,int lim)
{
  if (tl>tr)return ;
  int tot=0;
  while(1){
    for (int i=l;i<=r;i++)
      if (len[i]<=lim)tp[++tot]=i;
    if (tot)break;
    else lim<<=1;
  }int mid=tp[(tot+1)/2];

  lenp=_slen;
  for (int i=l;i<=r;i++){
    slen[i]=lenp;
    lenp+=len[mid]+1;
  }for (int i=0;i<len[mid];i++)slen[mid][i]=i+1;

  for (int i=mid-1,p,plen;i>=l;i--){
    p=t[i].root;plen=0;
    for (int j=0,c;j<len[mid];j++){
      c=str[mid][j]-'0';
      if (!a[p].t[c]){
        while(p!=t[i].root&&!a[p].t[c])p=a[p].f;
        plen=a[p].len;
      }
      if (a[p].t[c]){
        p=a[p].t[c];plen++;
      }slen[i][j]=min(slen[i+1][j],plen);
    }
  }
  
  for (int i=mid+1,p,plen;i<=r;i++){
    p=t[i].root;plen=0;
    for (int j=0,c;j<len[mid];j++){
      c=str[mid][j]-'0';
      if (!a[p].t[c]){
        while(p!=t[i].root&&!a[p].t[c])p=a[p].f;
        plen=a[p].len;
      }
      if (a[p].t[c]){
        p=a[p].t[c];plen++;
      }slen[i][j]=min(slen[i-1][j],plen);
    }
  }
  
  int nl=0,nr=0;
  for (int i=tl;i<=tr;i++){
    if (b[i].l<=mid&&mid<=b[i].r){
      pair<int,int> kk=make_pair(b[i].l,b[i].r);
      if (sav.count(kk))
        ans[b[i].pos]=sav[kk];
      else {
        int ret=0;
        for (int j=0;j<len[mid];j++)
          ret=max(ret,min(slen[b[i].l][j],slen[b[i].r][j]));
        sav[kk]=ans[b[i].pos]=ret;
      }
    }else if (b[i].r<mid)bl[++nl]=b[i];
    else br[++nr]=b[i];
  }int tmid=tl+nl-1;
  for (int i=1;i<=nl;i++)b[tl+i-1]=bl[i];
  for (int i=1;i<=nr;i++)b[tl+nl+i-1]=br[i];
  solve(l,mid-1,tl,tl+nl-1,lim);
  solve(mid+1,r,tl+nl,tl+nl+nr-1,lim);
}
int n,m;
int main()
{
  n=read();m=read();
  for (int i=1;i<=n;i++){
    scanf("%s",str[i]=sp);
    len[i]=strlen(sp);
    t[i].build(str[i],len[i]);
    sp+=len[i];
  }
  for (int i=1;i<=m;i++){
    b[i].l=read();b[i].r=read();
    b[i].pos=i;
  }
  solve(1,n,1,m,10);
  for (int i=1;i<=m;i++)
    printf("%d\n",ans[i]);
  return 0;
}
```

**附** ： 利用 $slen$ 数组也可求出区间本质不同公共子串数目。留做习题。

- ### **做法②** ： 广义 SAM + 扫描线

对于广义 SAM 上的节点 $u$ ，记 $P_u$ 为在 $parent$ 树中 $u$ 子树内存在终止节点的串的集合。

当询问区间 $[l,r]$ 时，若 $[l,r]\subseteq P_u$ ，则点 $u$ 可以向答案贡献。

考虑逐步增大 $r$ ，维护每个 $l$ 的答案。

对于 SAM 上的点 $u$ ，记 $P_u$ 中从 $r$ 向前的极长连续段的左端点为 $l_u$。

在询问 $[l,r]$ 时，若 $l_u\leq l$ 则点 $u$ 能贡献。

这里又有一个自然根号 ： 广义 SAM 上 $\sum_u |T_u|$ 是 $O(len\sqrt{len})$ 级别的。

于是，在 $r$ 增加时，对所有 $P_u$ 中含 $r$ 的点暴力更新即可。

有 $O(len\sqrt{len})$ 次单点修改，$O(m)$ 次区间查 $\rm max$ ，使用 $O(1)-O(\sqrt{n})$ 分块，复杂度为 $O(len\sqrt{len}+m\sqrt{n})$。

卡常后可以通过本题。

- ### **做法③** ： 广义 SAM + 线段树

可见 [（Mina）【题解】[CmdOI2019] 口头禅 广义 SAM -永无岛](https://www.mina.moe/archives/13606)

这里也简要地介绍一下该做法。

用 `std::set` 维护 $P_u$ 中的连续段，然后启发式合并。这部分复杂度为 $O(len\log len\log n)$。

按照节点的 $len$ 从大到小枚举，由于 $parent$ 树上 $len$ 从深到浅递减，故按这个顺序也可以顺便进行合并。

每次合并后，若产生新的连续段（该事件最多会发生 $O(len)$ 次），回答所有当前节点能够贡献到的询问，然后将这些询问删除。

使用线段树维护询问，将询问 $[l,r]$ 挂在位置 $l$ ，权值为 $r$。

需要寻找 $[L,R]$ 包含的所有询问时，查询 $[L,R]$ 内的权值最小值 $c$ ，若 $c\leq R$ ，则说明找到了一个合适的区间。

则复杂度为 $O(len\log len\log n)$ ，空间也是线性。

有空补代码。

---

## 作者：xtx1092515503 (赞：15)

[Portal](https://www.luogu.com.cn/problem/P5576)

这份题解使用的是官方题解中给出的算法3，即广义 SAM+线段树的做法。

真的超超超好写，并且（几乎）不卡常！

膜出题人！

------------

首先建出广义 SAM。然后，我们把每条字符串看作一种颜色，并且在插入该字符串时到达的所有点处染上这种颜色（自然，一个点可以被多次染色）。因为在 parent tree 中向儿子走等价于在串前加字符，所以一个点同时还具有其所有儿子的颜色。那么问题转换为对于所有颜色中包含了 $[l,r]$ 区间中所有颜色的点，求它们长度的最大值。

维护一个点上到底有哪些颜色是经典问题，线段树合并是常规操作。

但是线段树合并就不好回答询问（可能也不是不行，但我不会）。不如使用启发式合并。

我们发现我们如果将所有点长度递减排序，然后依次进行启发式合并（即用一个点的所有儿子的颜色与其合并。明显儿子的深度肯定大于该点，因此这种排序后合并的算法是正确的），用 `set` 维护每个点所有出现的连续颜色段。那么对于所有询问显然是第一次合并出来一个包含其的颜色段时答案最优（因为我们已经递减排序）。

那么我们就考虑对于每次合并，找到那些新产生的连续颜色段，用它来回答那些可以被其回答的询问。

明显每插入一段最多只会产生一个新连续颜色段，故总产生的连续颜色段数即为插入次数。因为使用了启发式合并，所以插入次数即为 $n\log n$。

现在考虑一个连续颜色段 $[L,R]$ 能回答哪些询问。这是二维数点问题。但是没有必要使用二维线段树，因为我们在回答一个询问后就可以立刻把它删除。因此我们开一个普通线段树，对于询问 $[l,r]$ 在叶节点 $l$ 上挂上值 $r$​，然后在区间 $[L,R]$​ 询问最小值，如果最小值不大于 $R$ 则显然就有询问可以被回答，那就回答后删掉即可。

现在考虑分析复杂度。定义 $S=\sum|s|$​​​​​。广义 SAM $O(|\Sigma|S)$​​​​​（其中 $|\Sigma|$​​​​​ 是字符集大小，本题为 $2$​​​​​），`set` 进行启发式合并 $O(S\log^2S)$​​​​​，对于每次合并的东西扔到线段树里询问是 $S\log S\log n$​​​​​ 的，一次询问被回答时必定需要 $\log n$​​​​​，则回答所有询问的复杂度是 $m\log n$​​​​​。因为必有 $S\geq n$​，所以合并后总计复杂度 $O(|\Sigma|S+S\log^2S+m\log n)$​。

~~所以询问压根不算事，完全可以问得更多，瓶颈完全不在这​​​​~~

至于空间复杂度，没啥好说就是线性。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt=1,S;
char s[400100];
struct Suffix_Automaton{int ch[2],fa,len;}t[800100];
int Add(int x,int c){
	if(t[x].ch[c]){
		int y=t[x].ch[c];
		if(t[y].len==t[x].len+1)return y;
		int yy=++cnt;t[yy]=t[y],t[y].fa=yy,t[yy].len=t[x].len+1;
		for(;x&&t[x].ch[c]==y;x=t[x].fa)t[x].ch[c]=yy;
		return yy;
	}
	int xx=++cnt;t[xx].len=t[x].len+1;
	for(;x&&!t[x].ch[c];x=t[x].fa)t[x].ch[c]=xx;
	if(!x)return t[xx].fa=1,xx;
	int y=t[x].ch[c];
	if(t[y].len==t[x].len+1)return t[xx].fa=y,xx;
	int yy=++cnt;t[yy]=t[y],t[yy].len=t[x].len+1;
	t[y].fa=t[xx].fa=yy;
	for(;x&&t[x].ch[c]==y;x=t[x].fa)t[x].ch[c]=yy;
	return xx;
}
set<pair<int,int> >st[800100];
int res[100100];
#define lson x<<1
#define rson x<<1|1
#define mid ((l+r)>>1)
vector<pair<int,int> >u[20100];
int mn[80100];
void pushup(int x){mn[x]=min(mn[lson],mn[rson]);}
void build(int x,int l,int r){
	if(l==r){sort(u[l].rbegin(),u[l].rend()),mn[x]=(u[l].empty()?0x3f3f3f3f:u[l].back().first);return;}
	build(lson,l,mid),build(rson,mid+1,r),pushup(x);
}
void query(int x,int l,int r,int L,int R,int val){
	if(r<L||mn[x]>R)return;
	if(l==r){
		while(!u[l].empty()&&u[l].back().first<=R)res[u[l].back().second]=val,u[l].pop_back();
		mn[x]=(u[l].empty()?0x3f3f3f3f:u[l].back().first);return;
	}
	query(lson,l,mid,L,R,val),query(rson,mid+1,r,L,R,val),pushup(x);
}
int ord[800100];
void INS(int x,int L,int R,bool upd){
//	printf("%d[%d,%d]\n",x,L,R);
	auto it=st[x].upper_bound(make_pair(R+1,0x3f3f3f3f));
	if(it==st[x].begin())return void(st[x].emplace(L,R));
	it--;
	if(it->first<=L&&it->second>=R)return;
	bool en=false;
	while(it->second+1>=L){
		if(it->second>R)en=true,R=it->second;
		if(it->first<L)en=true,L=it->first;
		it=st[x].erase(it);
		if(it==st[x].begin())break;
		it--;
	}
	if(en&&upd)query(1,1,n,L,R,t[x].len)/*,printf("%d<<%d,%d>>\n",t[x].len,L,R)*/;
	st[x].emplace(L,R);
}
vector<int>v[800100];
inline void read(int&x){
	x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
inline void print(int x){if(x<=9)putchar('0'+x);else print(x/10),putchar('0'+x%10);}
int main(){
	read(n),read(m);
	for(int i=1;i<=n;i++){
		scanf("%s",s),S=strlen(s);
		for(int j=0,las=1;j<S;j++)INS(las=Add(las,s[j]-'0'),i,i,false);
	}
	for(int i=1,l,r;i<=m;i++)read(l),read(r),u[l].emplace_back(r,i);
	build(1,1,n);
	for(int i=2;i<=cnt;i++)v[t[i].fa].push_back(i);
	for(int i=1;i<=cnt;i++)ord[i]=i;
	sort(ord+1,ord+cnt+1,[](int x,int y){return t[x].len>t[y].len;});
	for(int i=1;i<=cnt;i++){
		int x=ord[i];
		for(auto j:st[x])if(j.first!=j.second)query(1,1,n,j.first,j.second,t[x].len);
		for(auto y:v[x]){
			if(st[y].empty())continue;
			if(st[x].empty()){swap(st[x],st[y]);continue;}
			auto &L=st[x],&R=st[y];
			if(L.size()<R.size())swap(L,R);
			while(!R.empty())INS(x,R.begin()->first,R.begin()->second,true),R.erase(R.begin());			
		}
	}
	for(int i=1;i<=m;i++)print(res[i]),putchar('\n');
	return 0;
}
```



---

## 作者：hs_black (赞：9)


[博客内查看更香](https://www.cnblogs.com/Hs-black/p/13121957.html)

## 后缀自动机做法

### 后缀自动机

首先先膜出题人 @command_block

很神奇的思路

首先要会用后缀自动机来求多串的最长公共字串

两个做法，一个是对一个字符串建后缀自动机，然后将其他串在上面打标记，记录匹配到节点 x 的最长长度是多少，另一个方法是选一个字符串 S，剩下的分别建后缀自动机，然后这个字符串分别在其他串上跑，记录 $f[x]$ 表示 S[1...x] 能够匹配的最长后缀是多少。本题两种方法均可。

那么神仙的分治就来了

### 倍增分治

对于一个区间，将长度小于等于 $2^x$ 的串提出来进行分治，直到子区间没有这样的串为止，这时候我们 ++x 继续此过程

显然我们有一个 x 最大深度是 $\log N$ 的，又一共有 $\log (Len)$ 个 x，总分治深度是 $\log N*\log (Len)$，但实际上并跑不满 (fixed by 独秀平川,换了更严谨的说法)

为什么要这么分治，显然我们使用后缀自动机时选出的字符串大小越小越好，这样我们才能方便的记录前缀信息和后缀信息，否则空间都开不下

### 询问答案

考虑跨过区间 mid 的答案，记录从 mid 开始的前缀 f 和后缀 f，查询时合并答案即可

时间复杂度证明

考虑区间字符串长度总和为 len，区间长度为 k，最小的串长度则不超过 $\frac {len}k$

扫一遍此区间的复杂度为 $\Theta(k * \frac {len}k) = \Theta(len)$，所以分治扫所有的区间记录前缀后缀时间复杂度是 $\Theta(len\log^2N)$

如果串长小于 $\frac {len}{\sqrt m}$，有复杂度 $\Theta(len\sqrt m)$

如果串长大于 $\frac {len}{\sqrt m}$ 则无法保证复杂度，但很好的发现 k 小于 $\sqrt m$，想一想，为什么，也就是本质不同区间有 $k^2$ 个，记忆化一下可以得到 $\Theta(m\log m+k^2*\frac {len}{k}) = \Theta(m\log m+len*k)$

代码就先不放了

## 后缀数组做法

这题 SA 被卡空间了，所以我懒了还没有写，但不妨作为一种启发，dalao 发现了什么问题欢迎来踩和讨论，毕竟我只是口胡

感谢 @z7z_eta 的帮助

### SA求多串最长公共子串

看到这题你应该有些基础，我就稍微简略些吧

将所有串首尾相连拼起来求 SA 数组，将 height 数组看成隔板，从大到小拆，直到所有串的后缀均在某一个区间内出现，这个 height 就是答案

如何看所有串均出现在某一个区间呢

### set 启发式合并

每个位置开个 set，维护当前联通块的 “颜色” （每个原串是一种颜色）集合，当然我们维护区间会好一些，比如 2，3，4，5 颜色可以直接压成 [2，5]，在用上启发式合并就可以 $\Theta(N\log^2N)$ 的维护了，注意启发式合并时不要看 set 的 size 而是颜色的个数

在本题中可以发现如果颜色区间 [l, r] 被某一次包含就是答案了，问题又来了，如何看 [l, r] 最早什么时候被包含呢

### 扫描线

不妨将区间看成二维平面上的点 （L, R)，那么在 set 中合并时比如有 $[1, 3], [5,6]$，这时新插入一个区间 $[4,4]$，会使 set 中的区间融合 $[1,6]$，那么新的大区间所包含的所有小区间答案和当前的答案取 max 就行了，那么 $[1, 6]$ 可以看成二维平面上的一个矩形 $[1,6],[1,6]$，对里面的点取 max 即可，发现所有的点都在 $y = x$ 的上方，矩形可以换成 $[1,+\infty],[-\infty,6]$，这样扫描线加树状数组即可维护，单独是 $\Theta(n\log n)$ 的，但事实上启发式合并会产生 $\Theta(n\log n)$ 个矩形，所以总复杂度 $\Theta(n \log^2n)$

时间复杂度 $\Theta(len\log len+len\log^2 n+n \log^2 n)$，空间复杂度 $\Theta(n \log n)$

这个做法比较好想，但应该没有 sam 快，但那个太难想了啊

---

## 作者：MuelsyseU (赞：7)

**upd:** 修改了一些思路的表达，帮助理解。 

首先膜拜 yyc 大佬出这样的~~毒瘤~~好题。另外感谢 永无岛、xtx1092515503、hs_black 提供的思路。这里整理了一下这些思路，可能会有所启发。

**题意：** 给定一个字符串构成的序列，多次查询给定区间内各字符串的最长公共子串长度。

提供一种 后缀数组 + 线段树合并 的在线单 $\log$ 实现。

## 1. 思路

由于本题是区间查询版的 [LCS2](https://www.luogu.com.cn/problem/SP1812) 所以笔者首先找到了在该题中使用的一种尺取做法。

下文中，**极长**表示不被任何满足条件的更大区间完全包含。具体来说，当询问 $[l,r]$ 的字符串的最长公共子串时，对于后缀数组上的一个区间，满足对任意 $[l,r]$ 中的字符串，该区间至少包含其一个后缀，则该区间包含的所有后缀的最长公共前缀，显然是这些字符串的一个**极长**公共子串。直接通过尺取法找到包含 $[l,r]$ 中所有字符串的每个**极长**区间，则对应公共子串长度即为所有取出的区间在高度数组上对应的区间 $\min$，对这些长度再取 $\max$ 即为答案。很容易将一个后缀对应的原字符串编号联想成颜色，那么对于找到所有包含 $[l,r]$ 中每个颜色的串。

现在有多次询问，给定颜色区间，这种尺取法每次都需要 $O(len)$ 时间，不能使用。考虑利用静态和离线的条件处理，可以发现，在需要尺取的这个序列（下称序列 $a$）中，任何两个区间对应的 $\min$ 值（答案）都可以快速合并；并且两个区间对应含有的所有颜色也可以用启发式合并或线段树合并快速合并。

于是可以考虑按照**高度从大到小**的顺序，对 $a$ 上的每个元素，合并它两边的比它高的元素所在的段。这样每次合并完之后，这个元素所在的段的最小值就是这个元素的高度，并且我们可以得到这个段包含的所有颜色区间 $[l,r]$。这就可以用它的高度 $h$ 更新那些被其中某个区间完全包含的询问区间的答案。显然，这里我们依次合并出的所有区间，其答案**单调不增**。

这样，询问是在线地找到**第一次**包含询问区间 $[l,r]$ 的颜色区间的对应答案。考虑把合并出的每个颜色区间 $[x,y]$ 用二元组 $(r,h)$ 表示其右端点及答案，存储在位置 $x$ 上，则问题转变为查询 $[0,l]$ 中 $y\ge r$ 的二元组中 $h$ 的最大值。对该二元组按照 $x$ 递增顺序，建立前缀值域主席树，在第 $x$ 棵上的位置 $y$ 插入数值 $h$，维护值域上区间最大值即可。

## 2. 优化

观察可以发现瓶颈在这里的启发式合并带两个 $\log$，但是很容易处理出一个段的所有颜色区间。而线段树合并似乎难以处理。但是 永无岛 大佬提出一种处理跨过线段树节点中点的区间的做法，可以胜任这种情况。然而这种做法有很多种具体实现，笔者使用的是个人认为比较清晰的做法。

具体来说，首先定义“跨越中点”段是指左儿子的后缀和右儿子的前缀拼成的段（这两者中也可能为空）。同时为了避免一个串被它的后代多次处理，只有这个段整体不是该节点前缀或后缀时才处理。显然任何极长颜色段就和线段树上的节点建立了一个双射。那么维护每个节点的前缀有颜色段和后缀有颜色段即可。

另一方面，如果一个节点在合并后它对应的区间长度没有变长，那么不用这个区间重复更新答案。

综上可以得到复杂度为 $O((len + n + m)\log{n})$，空间为 $O((len + n)\log n + m)$。这个空间是无法通过的，但如果离线实现，可以做到空间 $O(n\log n + len + m)$。

**更新：** 如果在线段树合并中，对于只有包含一个值的值域区间对应的线段树节点，打上标记而直到合并时再建出它的一个儿子，并重复利用被删除的节点空间，可以达到 $O(n\log n + len + m)$ 的空间复杂度。

## 4. 实现

**离线：**

```cpp
#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;

// Input
int n, m, len, x, y, ans[100005], str[420005], sa[420005], ht[420005];
int rt[420005], a[100005], b[420005], fa[420005], now;
pair<int, int> baf[420005];
char c;
vector<pair<short, int>> u[20010];
// Sa
namespace Sa {
int n, m, rk[420005], x[420005], y[420005];
void init() {
    m = 20002;
    for (int i = 1; i <= n; ++i) ++fa[x[i] = str[i]];
    for (int i = 2; i <= m; ++i) fa[i] += fa[i - 1];
    for (int i = n; i >= 1; --i) sa[fa[x[i]]--] = i;
    for (int k = 1; k <= n; k <<= 1) {
        int num = 0;
        for (int i = n - k + 1; i <= n; ++i) y[++num] = i;
        for (int i = 1; i <= n; ++i)
            if (sa[i] > k) y[++num] = sa[i] - k;
        for (int i = 1; i <= m; ++i) fa[i] = 0;
        for (int i = 1; i <= n; ++i) ++fa[x[i]];
        for (int i = 2; i <= m; ++i) fa[i] += fa[i - 1];
        for (int i = n; i >= 1; --i) sa[fa[x[y[i]]]--] = y[i], y[i] = 0;
        swap(x, y);
        x[sa[1]] = 1;
        num = 1;
        for (int i = 2; i <= n; ++i)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
        if (num >= n) break;
        m = num;
    }
    int k = 0;
    for (int i = 1; i <= n; ++i) rk[sa[i]] = i;
    for (int i = 1; i <= n; ++i) {
        if (rk[i] == 1) continue;
        if (k) --k;
        int j = sa[rk[i] - 1];
        while (j + k <= n && i + k <= n && str[i + k] == str[j + k]) ++k;
        ht[rk[i]] = k;
    }
}
}
namespace Ans {
int tot;
struct Node {
    int l, r, x;
} t[400010];
inline int build(int l, int r) {
    int p = ++tot;
    if (l == r)
        sort(u[l].rbegin(), u[l].rend()), t[p].x = (u[l].empty() ? 0x3f3f3f3f : u[l].back().first);
    else {
        int mid = (l + r) >> 1;
        t[p].l = build(l, mid);
        t[p].r = build(mid + 1, r);
        t[p].x = min(t[t[p].l].x, t[t[p].r].x);
    }
    return p;
}
inline void query(int p, int l, int r, int x, int y) {
    if (r < x || t[p].x > y) return;
    int mid = (l + r) >> 1;
    if (l == r) {
        while (!u[l].empty() && u[l].back().first <= y) ans[u[l].back().second] = now, u[l].pop_back();
        t[p].x = (u[l].empty() ? 0x3f3f3f3f : u[l].back().first);
    } else {
        query(t[p].l, l, mid, x, y), query(t[p].r, mid + 1, r, x, y);
        t[p].x = min(t[t[p].l].x, t[t[p].r].x);
    }
}
}
// Segment Tree
namespace Seg {
struct Node {
    int l, r;
    short lv, rv;
} t[8000001];
int tot;
inline void pushup(int p, int l, int r) {
    int mid = (l + r) >> 1;
    if (t[p].l) t[p].lv = t[t[p].l].lv;
    if (t[p].r) t[p].rv = t[t[p].r].rv;
    if (t[t[p].l].lv == mid - l + 1) t[p].lv += t[t[p].r].lv;
    if (t[t[p].r].rv == r - mid) t[p].rv += t[t[p].l].rv;
}
inline int insert(int l, int r, int i) {
    int p = ++tot;
    if (l == r) t[p].lv = t[p].rv = 1;
    else {
        int mid = (l + r) >> 1;
        if (i <= mid) t[p].l = insert(l, mid, i), t[p].lv = t[t[p].l].lv;
        else t[p].r = insert(mid + 1, r, i), t[p].rv = t[t[p].r].rv;
    }
    return p;
}
inline int merge(int p, int q, int l, int r, int k = 0) {
    if (p == q) return p;
    if (!p || !q) return p ^ q;
    int mid = (l + r) >> 1, lt = t[t[p].l].rv, rt = t[t[p].r].lv;
    t[p].lv = max(t[p].lv, t[q].lv), t[p].rv = max(t[p].rv, t[q].rv);
    t[p].l = merge(t[p].l, t[q].l, l, mid, 1), t[p].r = merge(t[p].r, t[q].r, mid + 1, r, 2);
    pushup(p, l, r);
    if (t[t[p].l].rv == lt && t[t[p].r].lv == rt) return p;
    if ((t[t[p].l].rv || t[t[p].r].lv) &&
        (!k || (k == 2 && t[t[p].l].rv < mid - l + 1) || (k == 1 && t[t[p].r].lv < r - mid)))
        Ans::query(1, 1, n, mid - t[t[p].l].rv + 1, mid + t[t[p].r].lv);
    return p;
}
};
inline int read() {
    char c = getchar();
    int x = 0, f = 1;
    while (!isdigit(c)) f = (c == '-' ? -1 : f), c = getchar();
    while (isdigit(c)) x = (x << 3) + (x << 1) + c - '0', c = getchar();
    return x * f;
}
inline int find(int x) {
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}
int i, j, num;
signed main() {
    n = read(), m = read();
    for (i = 1; i <= n; ++i) {
        while (!isdigit(c)) c = getchar();
        while (isdigit(c)) str[++len] = c - '0' + 1, b[len] = i, c = getchar();
        str[++len] = i + 2;
    }
    Sa::n = len, Sa::init();
    for (i = 1; i <= len; ++i){
        if(b[sa[i]]) baf[++num] = make_pair(-ht[i], i), fa[i] = i, rt[i] = Seg::insert(1, n, b[sa[i]]);
        else fa[i] = i - 1;
    } sort(baf + 2, baf + 1 + num);
    for (int i = 1; i <= m; ++i) a[i] = read(), u[a[i]].emplace_back(read(), i);
    Ans::build(1, n);
    for (i = 2; i <= num; ++i) {
        x = baf[i].second, now = -baf[i].first;
        rt[find(x)] = Seg::merge(rt[find(x)], rt[find(x - 1)], 1, n), fa[find(x - 1)] = find(x);
    }
    for (int i = 1; i <= m; ++i) printf("%d\n", ans[i]);
    return 0;
}
```
以下代码为了可读性和在线，效率较低（此题线段树合并可能只有理论上才优于启发式合并），不开 `O2` 不保证随时都可以通过。

**在线：**
```cpp
#include <algorithm>
#include <cmath>
#include <cstring>
#include <fstream>
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

// Input
int n, m, len, x, y, sa[500005], ht[500005];
pair<int, int> baf[500005];
int rt[500005], b[500005], fa[500005], now;
char c;
short str[500005];
vector<pair<short, short>> u[20010];
// Sa
namespace Sa {
int n, m, ans, rk[500005], c[500005], x[500005], y[500005];
void init() {
    m = 20002;
    for (int i = 1; i <= n; ++i) ++c[x[i] = str[i]];
    for (int i = 2; i <= m; ++i) c[i] += c[i - 1];
    for (int i = n; i >= 1; --i) sa[c[x[i]]--] = i;
    for (int k = 1; k <= n; k <<= 1) {
        int num = 0;
        for (int i = n - k + 1; i <= n; ++i) y[++num] = i;
        for (int i = 1; i <= n; ++i)
            if (sa[i] > k) y[++num] = sa[i] - k;
        for (int i = 1; i <= m; ++i) c[i] = 0;
        for (int i = 1; i <= n; ++i) ++c[x[i]];
        for (int i = 2; i <= m; ++i) c[i] += c[i - 1];
        for (int i = n; i >= 1; --i) sa[c[x[y[i]]]--] = y[i], y[i] = 0;
        swap(x, y);
        x[sa[1]] = 1;
        num = 1;
        for (int i = 2; i <= n; ++i)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
        if (num >= n) break;
        m = num;
    }
    int k = 0;
    for (int i = 1; i <= n; ++i) rk[sa[i]] = i;
    for (int i = 1; i <= n; ++i) {
        if (rk[i] == 1) continue;
        if (k) --k;
        int j = sa[rk[i] - 1];
        while (j + k <= n && i + k <= n && str[i + k] == str[j + k]) ++k;
        ht[rk[i]] = k;
    }
    // for (int i = 1; i <= n; ++i) cout << sa[i] << " ";
    // cout << endl;
    // for (int i = 1; i <= n; ++i) cout << ht[i] << " ";
    // cout << endl;
}
}
namespace Ans {
int tot, rt[20010];
struct Node {
    int l, r, x;
} t[200010];
inline int insert(int p, int l, int r, int i, int x) {
    int tp = ++tot;
    t[tp] = t[p], t[tp].x = max(t[tp].x, x);
    if (l ^ r) {
        int mid = (l + r) >> 1;
        if (i <= mid)
            t[tp].l = insert(t[p].l, l, mid, i, x);
        else
            t[tp].r = insert(t[p].r, mid + 1, r, i, x);
    }
    return tp;
}
inline int ask(int p, int pl, int pr, int l) {
    if (pl >= l) return t[p].x;
    int mid = (pl + pr) >> 1, ans = 0;
    if (l <= mid) ans = max(ans, ask(t[p].l, pl, mid, l));
    return max(ans, ask(t[p].r, mid + 1, pr, l));
}
}
// Segment Tree
namespace Seg {
struct Node {
    int l, r;
    short lv, rv, lt, rt;
} t[8000001];
int tot, bk[8000001], top;
inline void pushup(int p, int l, int r) {
    int mid = (l + r) >> 1;
    if (t[p].l) t[p].lv = t[t[p].l].lv;
    if (t[p].r) t[p].rv = t[t[p].r].rv;
    if (t[t[p].l].lv == mid - l + 1) t[p].lv += t[t[p].r].lv;
    if (t[t[p].r].rv == r - mid) t[p].rv += t[t[p].l].rv;
}
inline int insert(int l, int r, int i) {
    int p = ++tot;
    if (l == r)
        t[p].lv = t[p].rv = 1;
    else {
        int mid = (l + r) >> 1;
        if (i <= mid)
            t[p].l = insert(l, mid, i), t[p].lv = t[t[p].l].lv;
        else
            t[p].r = insert(mid + 1, r, i), t[p].rv = t[t[p].r].rv;
    }
    return p;
}
inline int merge(int p, int q, int l, int r, int k = 0) {
    if (p == q) return p;
    if (!p || !q) return p ^ q;
    int mid = (l + r) >> 1, lt = t[t[p].l].rv, rt = t[t[p].r].lv;
    t[p].lv = max(t[p].lv, t[q].lv), t[p].rv = max(t[p].rv, t[q].rv);
    t[p].l = merge(t[p].l, t[q].l, l, mid, 1), t[p].r = merge(t[p].r, t[q].r, mid + 1, r, 2);
    pushup(p, l, r);
    t[q] = {}, bk[++top] = q;
    if (t[t[p].l].rv == lt && t[t[p].r].lv == rt) return p;
    if ((t[t[p].l].rv || t[t[p].r].lv) &&
        (!k || (k == 2 && t[t[p].l].rv < mid - l + 1) || (k == 1 && t[t[p].r].lv < r - mid)))
        u[mid - t[t[p].l].rv + 1].emplace_back(mid + t[t[p].r].lv, now);
    return p;
}
};
inline int read() {
    char c = getchar();
    int x = 0, f = 1;
    while (!isdigit(c)) f = (c == '-' ? -1 : f), c = getchar();
    while (isdigit(c)) x = (x << 3) + (x << 1) + c - '0', c = getchar();
    return x * f;
}
inline int find(int x) {
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}
int i, j, num;
signed main() {
    n = read(), m = read();
    for (i = 1; i <= n; ++i) {
        while (!isdigit(c)) c = getchar();
        while (isdigit(c)) str[++len] = c - '0' + 1, b[len] = i, c = getchar();
        str[++len] = i + 2;
    }
    Sa::n = len, Sa::init();
    for (i = 1; i <= len; ++i){
        if(b[sa[i]]) baf[++num] = make_pair(-ht[i], i), fa[i] = i, rt[i] = Seg::insert(1, n, b[sa[i]]);
        else fa[i] = i - 1;
    } sort(baf + 2, baf + 1 + num);
    for (i = 2; i <= num; ++i) {
        x = baf[i].second, now = -baf[i].first;
        // j = b[sa[x - 1]] ? x - 1 : x - 2;
        rt[find(x)] = Seg::merge(rt[find(x)], rt[find(x - 1)], 1, n), fa[find(x - 1)] = find(x);
    }
    for (i = 1; i <= n; ++i) {
        Ans::rt[i] = Ans::rt[i - 1];
        for (j = 0; j < u[i].size(); j++)
            Ans::rt[i] = Ans::insert(Ans::rt[i], 1, n, u[i][j].first, u[i][j].second);
    }
    while (m--) {
        x = read(), y = read();
        printf("%d\n", Ans::ask(Ans::rt[x], 1, n, y));
    }
    return 0;
}
```

---

## 作者：iodwad (赞：6)

看到静态区间查询问题，我们首先考虑猫树分治。

先要解决的基本问题是如何查询多个串的最长公共子串，从中选出一个长度最小的串 $S$，对于其他每个串建一个 SAM，然后将 $S$ 放在 SAM 上匹配。最后会得到 $S$ 的每个前缀与其他串的 LCS，合并即可。复杂度是 $\mathcal O(len+|S|)$ 的。

我们可以将猫树分治的复杂度分成几个部分：

1. 分割询问数组的复杂度。在分治途中需要分别往子分治区间放询问，以及找出需要在当前区间解决的询问，这个只能单次 $\mathcal O(qcnt)$ 的复杂度。因此我们需要保证分治树的高度不能太大。
2. 对于分治到区间 $[l,r]$ 时找到的分割点 $p$，分别计算 $[l,p]$ 后缀与 $[p,r]$ 前缀答案的复杂度。
3. 合并前缀后缀答案的复杂度。

我们考虑当前分治到了区间  $[l,r]$。根据前面计算公共子串大小的算法，显然我们要找一个长度较小的串作为分割点。我们尝试一下每次选择一个最小值作为分割点，对于一个长度 $v$，以其为最小值的区间 $[l,r]$ 至多长 $\mathcal O(\dfrac{len}{v})$，则单层分治（若干个同层分治）计算用于合并的信息的复杂度为 $\mathcal O(v\times\dfrac{len}{v})=\mathcal O(len)$。然后我们每次选取所有最小值中中间那个作为划分点就能保证这个最小值只会贡献 $\mathcal O(\log n)$ 层分治。又我们知道至多只有 $\mathcal O(\sqrt{len})$ 个不同的长度，因此这样子的复杂度是 $\mathcal O(len\sqrt{len} \log n)$。对于合并答案的部分，每个询问的复杂度贡献是其区间中的长度最小值，这个在记忆化保证点对不重后就至多是 $\mathcal O(Q\sqrt{len}+len\sqrt{len})$。

上面那个算法劣的原因是分治树过高，但是我们需要保证计算用于合并的信息的复杂度正确的话一定要保证每轮分治里选的划分点是一个 $\mathcal O(minval)$ 的位置。那么考虑倍增，在分治过程中维护一个极小的阈值 $x$，然后将分治区间中的所有在 $[2^x,2^{x+1})$ 里的长度拿出来取中点为划分点，直到不存在 $[2^x,2^{x+1})$ 里的长度后将 $x$ 加 $1$。这样子在分析计算信息的复杂度与单个 $x$ 的分治深度时可以套用上面的过程，因为显然选出来的长度不会超过其中最小值的两倍。不同的是只有 $\mathcal O(\log len)$ 个 $x$，因此复杂度优化为 $\mathcal O(len \log len \log n+(Q+len) \sqrt{len})$。

```cpp
// by iodwad
#include <cstdio>
#include <iostream>
#include <cassert>
#include <string>
#include <map>
#include <numeric>
#include <vector>
#include <cstring>

using namespace std;

const int MAXN = 2e4;
const int MAXM = 1e5;
const int MAXL = 4e5;

int n, m, L[MAXM + 5], R[MAXM + 5], ans[MAXM + 5], len[MAXN + 5];
map<pair<int, int>, int> buc;
string str[MAXN + 5];

const int maxl = MAXL << 1 | 1;
struct SAM {
  int len[maxl + 5], link[maxl + 5], trans[maxl + 5][2], Last, Size;
  SAM() : Last(1), Size(1) {}
  void extend(int c) {
    c -= '0';
    int cur = ++Size, p; 
    len[cur] = len[Last] + 1;
    for (p = Last; p && !trans[p][c]; p = link[p]) trans[p][c] = cur;
    if (!p) link[cur] = 1;
    else {
      int q = trans[p][c];
      if (len[q] == len[p] + 1) link[cur] = q;
      else {
        int cln = ++Size;
        len[cln] = len[p] + 1;
        link[cln] = link[q];
        memcpy(trans[cln], trans[q], sizeof(trans[q]));
        for (; p && trans[p][c] == q; p = link[p]) trans[p][c] = cln;
        link[cur] = link[q] = cln;
      }
    }
    Last = cur;
  }
  vector<int> query(const string &s) {
    int n = s.size();
    vector<int> ans(n);
    for (int i = 0, mlen = 0, p = 1; i < n; ++i) {
      int c = s[i] - '0';
      while (p != 1 && !trans[p][c]) p = link[p], mlen = len[p];
      if (trans[p][c]) p = trans[p][c], ++mlen;
      else mlen = 0;
      ans[i] = mlen;
    }
    return ans;
  }
  void clear() {
    memset(len, 0, sizeof(int) * (Size + 1));
    memset(link, 0, sizeof(int) * (Size + 1));
    memset(trans, 0, sizeof(int) * 2 * (Size + 1));
    Last = Size = 1;
  }
} sam;

vector<int> operator< (const vector<int> &lhs, const vector<int> &rhs) {
  int n = lhs.size();
  vector<int> ans(n);
  for (int i = 0; i < n; ++i) ans[i] = min(lhs[i], rhs[i]);
  return ans;
}

int idx[MAXM + 5];
void solve(int al, int ar, int ql, int qr, int t) {
  if (al > ar || ql > qr) return;
  int tot0 = 0, tot1 = 0, tot2 = 0;
  static int idx0[MAXM + 5], idx1[MAXM + 5], idx2[MAXM + 5];
  static vector<int> mlen1[MAXN + 5], mlen2[MAXM + 5];
  static vector<int> pos; pos.clear();
  int lt = 1 << t, rt = (lt << 1);
  for (int i = al; i <= ar; ++i) if (lt <= len[i] && len[i] < rt) pos.push_back(i);
  if (pos.empty()) return solve(al, ar, ql, qr, t + 1);
  int mid = pos[pos.size() >> 1];
  for (int i = mid; i >= al; --i) {
    sam.clear(); 
    for (int j = 0; j < len[i]; ++j) sam.extend(str[i][j]);
    vector<int> tmp = sam.query(str[mid]);
    if (i != mid) mlen1[i] = mlen1[i + 1] < tmp;
    else mlen1[i] = tmp;
  }
  for (int i = mid; i <= ar; ++i) {
    sam.clear();
    for (int j = 0; j < len[i]; ++j) sam.extend(str[i][j]);
    vector<int> tmp = sam.query(str[mid]);
    if (i != mid) mlen2[i] = mlen2[i - 1] < tmp;
    else mlen2[i] = tmp;
  }
  for (int i = ql; i <= qr; ++i) {
    int l = L[idx[i]], r = R[idx[i]];
    if (l <= mid && mid <= r) idx0[++tot0] = idx[i];
    else if (r < mid) idx1[++tot1] = idx[i];
    else idx2[++tot2] = idx[i];
  }
  for (int i = 1; i <= tot0; ++i) {
    int id = idx0[i], l = L[id], r = R[id], res = 0;
    if (buc.count(make_pair(l, r))) {
      ans[id] = buc[make_pair(l, r)];
      continue;
    }
    vector<int> tmp = mlen1[l] < mlen2[r];
    for (int j : tmp) res = max(res, j);
    ans[id] = buc[make_pair(l, r)] = res;
  }
  for (int i = 1; i <= tot1; ++i) idx[ql + i - 1] = idx1[i];
  for (int i = 1; i <= tot2; ++i) idx[ql + tot1 + i - 1] = idx2[i];
  solve(al, mid - 1, ql, ql + tot1 - 1, t);
  solve(mid + 1, ar, ql + tot1, ql + tot1 + tot2 - 1, t);
}

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  cin >> n >> m;
  for (int i = 1; i <= n; ++i) cin >> str[i], len[i] = str[i].size();
  for (int i = 1; i <= m; ++i) cin >> L[i] >> R[i];
  iota(idx, idx + m + 1, 0);
  solve(1, n, 1, m, 0);
  for (int i = 1; i <= m; ++i) cout << ans[i] << "\n";
  return 0;
}
```

---

## 作者：chenxinyang2006 (赞：6)

感觉很多字符串问题转化完就变 DS 题了

先特判掉 $l = r$ 的情况，然后我们考虑把所有串拼在一起，中间加上彼此不同的分割符，然后对整个串建 SAM

然后我们可以转化一下问题，给串 $i$ 对应的所有终止节点染上颜色 $i$，这样问题转化为：

给定一颗有根树，每个节点有颜色和权值，$q$ 次询问，给出 $l,r$，让你找一个权值最大的节点，满足其子树内包含 $[l,r]$ 这些颜色

考虑扫描 $r$，动态维护所有节点的最小 $x$，满足其子树内包含 $[x,r]$ 的全部颜色

然后考虑加入 $r$ 的影响，可以发现，除了所有颜色为 $r$ 的节点到根的路径上节点的并以外，其他节点的 $x$ 都会变为 $r + 1$，其他不影响

然后我们考虑树剖一下，这样路径直接转化为区间，变为 $r+1$ 的就可以表示为若干个区间

这样问题又进一步转化为：

给定一个长度为 $n$ 的序列，每个位置有一个权值和一个时间，$n \log n$ 次把一个区间的时间修改为 $x$，$q$ 次查询时间 $\le l$ 的位置中，权值的最大值

看起来还是比较困难，但注意到全是区间推平，于是我们直接用颜色段均摊，显然一个同色段中只要保留权值最大的就可以了，然后我们再用一颗线段树去维护一下单点修改，区间 $\max$ 之类的，就做完了

时间复杂度是 $O(L \log^2 n + q \log n)$，$L$ 是字符串长度之和

写了份代码，但是因为滥用 STL 之类的被卡常了，就不放上来了（

总之就是说官方题解里的解法二可以做到 poly log

---

## 作者：永无岛 (赞：4)

前置：

1.目前没有进行代码实现，所有内容均是口胡，如有错误或者不严谨的地方烦请指出，谢谢！

2.由于这篇文章中会同时出现“线段树上的节点”，“parent 树上的结点”等多种点，为便于理解，维护连续段的线段树的点统称“节点”，parent 树的点统称“结点”。


3.线段树上的节点对应/表示的区间指线段树函数参数中的 $l$，$r$。



一句话题意：给定若干个字符串，多次询问区间最长公共子串。

书接[上回](https://www.mina.moe/archives/13606)，上一次通过利用离线的性质有了一个 $O(len\,\log n\,\log len\,+\,q\,\log n)$ 的做法，回忆一下是怎么做的：

1.通过 SAM 将这道题转化为数据结构题：一棵树，叶子节点有颜色，点有点权，保证任何一个点的权值大于父亲节点的权值，每次询问子树内包含 $[l,r]$ 所有颜色的所有节点中权值的最大值。

2.想到可以按照节点权值大小合并儿子，维护颜色连续段，当产生新的连续段时查询有没有可回答的询问。

之所以用了两个 $\log$，瓶颈在于维护连续段用的是 set + 启发式合并。

想一想，有没有什么数据结构可以1个 $\log$ 的维护相关信息？

不如试试线段树合并？( 这里是受到了 [NOI2018你的名字](https://www.luogu.com.cn/problem/P4770) 的启发 )

如果可以做到刚好在产生新的连续段时去查找有没有新的可回答询问，理论上是可以实现1个 $\log$ 的(查询可回答询问的部分可以看[这题洛谷题解中用户“xtx1092515503”的文章](https://www.luogu.com.cn/problem/solution/P5576?orderBy=weight&page=1) ，讲的比较清晰，我在上一篇博客中口胡的那个有问题)。

这里又有一个经典处理方式，受[【美团杯2020】半前缀计数](https://uoj.ac/contest/53/problem/523) 启发，我们可以考虑把每个连续段在它的"最后出现时刻"计算 ( 这里的"最后出现时刻"比较抽象，也许看到最后会帮助理解 )，具体到这道题中，我们考虑：

对于一个连续段，我们令“线段树上能覆盖整个连续段的深度最大的节点”为 $x$，那么有如下性质：

1.这个连续段跨过 $x$ 对应区间的正中间 ( 否则 $x$ 的左 / 右儿子能覆盖整个连续段 )。

2.对于树上一个结点，子树内的所有连续段，对应的 $x$ 各不相同 ( 由1可得 )。

称 $x$ 和这个连续段“对应”，相当于构造了一个线段树上节点和连续段的双射。

所以，如果我们能对于一个结点的维护连续段的线段树的所有节点，维护跨过其中点的连续段的最左端和最右端，就可以知道所有连续段的信息。

这个信息可以很简单的通过 push_up 来维护。只要记 $f(id,0/1)$ 表示线段树节点 $id$ 表示区间的最长前缀连续段和最长后缀连续段。

考虑三种情况：

1.一个连续段在其对应的线段树节点表示的区间中既不是前缀也不是后缀，这种情况直接在线段树合并遍历到这个节点时查询一下跨过其中点的连续段的最左端和最右端，如果和合并之前的两个线段树都不相同 ( 说明产生了新的连续段 )，就去查询有无新的可回答询问。

2.一个连续段在其对应的线段树节点表示的区间中是前缀或后缀，假设是前缀，后缀同理。这时如果直接对每个跨越中点前缀询问复杂度会多出一个 $\log$。这时考虑到，这个连续段的存在一定会导致在其对应线段树节点某个祖先 ( 其实就是最近的是其父亲节点的右儿子的祖先 ) 的左儿子的后缀最长连续段长度是0( 否则违背假设 )，右儿子前缀最长连续段就是这个连续段。实现的时候在这个节点进行情况1的考虑即可。或者在之前定义对应时就把这个连续段的对应线段树节点修改为这里提到的这个“祖先”也行，仍然是满足双射的。

3.既是前缀也是后缀，显然这个节点表示的区间的颜色在当前子树内都存在，这时可以直接对这样的线段树节点表示区间进行询问，这部分总询问次数不超过线段树总结点个数，也就是 $2n$ 的。

复杂度分析：

线段树合并的部分：parent 树上每一个叶子节点上插入一种颜色，总插入次数不超过 $O(len)$。合并复杂度不超过 $O(len \, \log n)$。在合并到某个节点时同时处理连续段的变化(在每个节点上操作次数不会超过常数次)，不影响复杂度。

广义 SAM：$O(\lvert \Sigma \lvert \, len)$。

查询询问： $O(q\,\log n \, + \, len\, \log n\, +n\,\log \, n)$。

总复杂度：$O(\lvert \Sigma \lvert \, len\,+\,q\,\log n \, + \, len\, \log n\, +n\,\log \, n)$。


---

## 作者：青君 (赞：3)

标签：SAM，随机化
## 多串最长公共子串做法
选取最短的串作为模板建 SAM ，然后把每一个串放在 SAM 上跑匹配，开个 mx 数组记录每个节点的最大匹配长度，对每个串的 mx 数组在对应位置上取 mn 得到一个 mn 数组，mn 数组的最大值就是答案。  
在 SAM 上匹配大概是这样写的：
```cpp
for(int i=0,mxlen=0,cur=1;i<s.length();++i){
	//cur:当前匹配到的最深的节点  mxlen:最大长度（注意最大长度不一定是l[cur]) 
	int c=s[i]-'0';
	for(;cur&&!ch[cur][c];cur=fa[cur],mxlen=l[cur]) ;
	if(!cur) cur=1,mxlen=0;
	else cur=ch[cur][c],++mxlen;
	mx[cur]=max(mx[cur],mxlen);	 
}
```
更新 mn 数组：
```cpp
for(int i=tot;i;--i){
//p:按l排序后的节点顺序
	mn[p[i]]=min(mn[p[i]],mx[p[i]]);
	if(fa[p[i]]&&mx[p[i]])mx[fa[p[i]]]=max(mx[fa[p[i]]],l[fa[p[i]]]);
//如果p[i]能匹配到，那么parent树上p[i]到根路径上的所有节点都能匹配到，所以也要更新它们的mx值。
}
```
复杂度分析：  
令 $L=\text{模板串长度}$，$n=\text{字符串数量}$，$T=\text{字符串长度之和}$。时间复杂度为 $\Theta(T+n*L)$。
## 本题做法

考虑分治优化上面这个暴力。
- 设 $solve(l,r)$ 表示，当前要处理被区间 $[l,r]$ **完全包含** 的询问。
- 在 $[l,r]$ 中选取一个 $mid$ ，以 $s[mid]$ 为模板串建立 SAM，设
$|s[mid]|=L$。
- 对$s[i...mid](l\le i \le mid)$ 求出 **后缀mn数组**，对 $s[mid+1...i](mid+1\le i \le r)$ 求出**前缀mn数组**。
- 遍历当前要处理的询问，设一个询问为 $(ll,rr)$ ，如果 $rr\le mid$ 分治到 $solve(l,mid)$ ，如果 $ll>mid$ 分治到 $solve(mid+1,r)$，否则考虑回答这个询问，因为我们已经预处理了左/右边的后/前缀mn数组，可以 $\Theta(L)$ 合并 $s[ll..mid]$ 与 $s[mid+1,rr]$ 对应的mn数组，得到答案。
- 假设当前层共有 $cnt$ 个询问，回答了 $num$ 个询问，则复杂度为 $\Theta(cnt+num*L)$。  

显然如何选取 $mid$ 是关键。但是我们面临一个尴尬的情况，选最短的串作为 $mid$ 呢，可能 $num$ 会很小导致递归下去的 $cnt$ 很大，选使 $num$ 最大的串呢，又可能 $L$ 过大导致回答询问复杂度过高。  
这个时候考虑~~玄学~~随机化。多次随机位置，取最短的串作为 $mid$。  

经过多次实验，我发现随机次数取 $\log(r-l+1)*0.7$ 比较优。由于我的常数比较大，加了火车头都卡不过#13。等到晚上九点多评测姬飞快的时候，`srand(19260817)`以763ms卡过了[评测记录](https://www.luogu.com.cn/record/38334845)。  
## 代码

下面的代码去掉了火车头，请加上火车头并在晚上食用。不保证随时能AC。~~供测试随机种子玩。~~
```cpp
#include<bits/stdc++.h>
#define mk make_pair
#define pk push_back 
using namespace std;
typedef long long LL;
typedef pair<int,int> pi;
const int N=2e4+5,K=4e5+5,M=1e5+5,D=20;
namespace SAM{
	int tot,lst,ch[K<<1][2],fa[K<<1],l[K<<1];
	void init(){
		for(int i=1;i<=tot;++i) ch[i][0]=ch[i][1]=fa[i]=l[i]=0;
		tot=lst=1;
	}
	void insert(int c){
		int p=lst,np=++tot;lst=np;l[np]=l[p]+1;
		for(;p&&!ch[p][c];p=fa[p]) ch[p][c]=np;
		if(!p) fa[np]=1;
		else{
			int q=ch[p][c];
			if(l[q]==l[p]+1) fa[np]=q;
			else{
				int nq=++tot;
				ch[nq][0]=ch[q][0],ch[nq][1]=ch[q][1],fa[nq]=fa[q],l[nq]=l[p]+1;
				for(;p&&ch[p][c]==q;p=fa[p]) ch[p][c]=nq;
				fa[q]=fa[np]=nq; 
			}
		}
	}
	int c[K],p[K<<1],mx[K<<1],mn[K<<1];
	void prework(int len,vector<int> &f){
		for(int i=0;i<=len;++i) c[i]=0;
		for(int i=1;i<=tot;++i) ++c[l[i]],f.pk(l[i]),mn[i]=l[i];
		for(int i=1;i<=len;++i) c[i]+=c[i-1];
		for(int i=1;i<=tot;++i) p[c[l[i]]--]=i;
	}
	void setmin(){
		for(int i=1;i<=tot;++i) mn[i]=l[i];
	}
	void match(string &s,vector<int> &f){
		for(int i=1;i<=tot;++i)	mx[i]=0;
		int mxlen=0,cur=1; 
		for(int i=0;i<s.length();++i){
			int c=s[i]-'0';
			for(;cur&&!ch[cur][c];cur=fa[cur],mxlen=l[cur]) ;
			if(!cur) cur=1,mxlen=0;
			else cur=ch[cur][c],++mxlen;
			mx[cur]=max(mx[cur],mxlen);
		}
		for(int i=tot;i;--i){
			mn[p[i]]=min(mn[p[i]],mx[p[i]]);
			if(fa[p[i]]&&mx[p[i]])mx[fa[p[i]]]=max(mx[fa[p[i]]],l[fa[p[i]]]); 
		}
		for(int i=1;i<=tot;++i) f.pk(mn[i]);
	}
}
struct Query{
	int l,r,id;	
}q[M],t[M];
int n,m,lg[N],ans[M];
string s[N]; 
vector<int> tl[N],tr[N];
int merge(vector<int> &A,vector<int> &B){
	int ret=0;
	for(int i=0;i<A.size();++i) ret=max(ret,min(A[i],B[i]));
	return ret;
}
void solve(int l,int r,int ll,int rr){
	if(l>r||ll>rr) return ;
	if(l==r){
		for(int i=ll;i<=rr;++i) ans[q[i].id]=s[l].length();
		return ;
	}
	int mid=0,rep=max(1.0,lg[r-l+1]*0.7);
	while(rep--){
		int t=l+rand()%(r-l+1);
		if(!mid||s[t].length()<s[mid].length()) mid=t; 
	}
	SAM::init();
	for(int i=0;i<s[mid].length();++i) SAM::insert(s[mid][i]-'0');
	tl[0].clear();SAM::prework(s[mid].length(),tl[0]);
	for(int i=mid-1;i>=l;--i) tl[mid-i].clear(),SAM::match(s[i],tl[mid-i]);
	SAM::setmin();for(int i=mid+1;i<=r;++i) tr[i-mid].clear(),SAM::match(s[i],tr[i-mid]);
	int p1=ll,p2=rr;
	for(int i=ll;i<=rr;++i) t[i]=q[i];
	for(int i=ll;i<=rr;++i)
		if(t[i].r<=mid) q[p1++]=t[i];
		else if(t[i].l>mid) q[p2--]=t[i];
		else ans[t[i].id]=merge(tl[mid-t[i].l],tr[t[i].r-mid]);
	solve(l,mid,ll,p1-1),solve(mid+1,r,p2+1,rr);
} 
int main(){
	srand(19260817);
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;++i) cin>>s[i];
	for(int i=1;i<=m;++i) cin>>q[i].l>>q[i].r,q[i].id=i;
	lg[0]=-1;
	for(int i=1;i<=n;++i) lg[i]=lg[i>>1]+1;
	solve(1,n,1,m);
	for(int i=1;i<=m;++i) cout<<ans[i]<<endl;
	return 0;
}
```



---

## 作者：fjy666 (赞：2)

为官方题解的第二种方法的较详细版本。

离线询问，使用扫描线处理询问。  

先对于所有 $01$ 串建立广义后缀自动机，对于广义后缀自动机上的每一个节点，维护 $l,r$ 表示它在 $s_l, s_{l+1}, \cdots, s_r$ 中都出现过，如果有多个 $[l,r]$，优先取 $r$ 最大的，其次取 $r-l+1$ 最大的。

那么对于所有 $R=i$ 的询问，我们可以在广义后缀自动机上找到所有维护信息形如 $[l,i]$ 的节点 $x$（即：$x$ 表示的 endpos 等价类是 $s_i$ 的子串），对于所有 $l\le L\le i$ 的左端点更新答案 $ans_L\gets \max(ans_L,\operatorname{len}_x)$。注意，当我们扫描线指针移动到一个新的 $R$ 的时候，必须清空 $ans$ 数组。

引理：
> 设 $\operatorname{siz}_x$ 表示包含广义自动机上节点 $x$ 的字符串个数（这里的字符串指的是原串），则 $\sum\operatorname{siz}_x$ 是 $\sum\operatorname{len}\times \sqrt{\sum\operatorname{len}}$ 级别的。

所以，我们需要做 $\sum\operatorname{len}\times \sqrt{\sum\operatorname{len}}$ 区间修改操作，以及 $m$ 次单点查询操作。

差分转化为单点修改，区间查询，然后使用分块根号平衡。  
实现小技巧：如何在广义后缀自动机上找到所有 $s$ 的子串？在 $s$ 的前缀节点上跳 $\operatorname{link}$ 树即可。

时间复杂度：$\mathcal{O}(\sum\operatorname{len}\times \sqrt{\sum\operatorname{len}}+m\sqrt{n})$。  
不过没有体会到官方题解说的卡常，因为我没卡就是最优解。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define _rep(i_,a_,b_) for(int i_ = (a_); i_ <= (b_); ++i_)
#define mid ((L+R) >> 1)
#define multiCase() int testCnt = in(); _rep(curCase,1,testCnt)
#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif
using ll = long long;
using pii = pair<int,int>;

int in(void) { int x; scanf("%d", &x); return x; } ll inl(void) { ll x; scanf("%lld", &x); return x; }
void out(int x) { printf("%d ", x); } void outln(int x) { printf("%d\n", x); }
void out(ll x) { printf("%lld ", x); } void outln(ll x) { printf("%lld\n", x); }
template<typename T> void chkmax(T &a, const T &b) { a = max(a, b); } 
template<typename T> void chkmin(T &a, const T &b) { a = min(a, b); } 
const int kM = 805000;
int n, m;
string s[25000];
struct Query { int l, r, id; } q[kM]; int res[kM];

//general suffix automaton
int ch[kM][2], link[kM], len[kM], l[kM], r[kM], nc, vis[kM];
int clone(int x) { 
	++nc; memcpy(ch[nc], ch[x], sizeof(ch[nc]));
	link[nc] = link[x], l[nc] = l[x], r[nc] = r[x];
	return nc;
}
int extend(int last, int c) { c -= '0';
	if(ch[last][c]) {
		int p = ch[last][c];
		if(len[p] == len[last] + 1) return p;
		else {
			int q = clone(p); len[q] = len[last] + 1;
			while(~last && ch[last][c] == p) ch[last][c] = q, last = link[last];
			link[p] = q; return q;
		}
	}
	int cur = ++nc; len[cur] = len[last] + 1; 
	while(~last && !ch[last][c]) ch[last][c] = cur, last = link[last];
	if(last == -1) link[cur] = 0;
	else {
		int p = ch[last][c];
		if(len[p] == len[last] + 1) link[cur] = p;
		else {
			int q = clone(p); len[q] = len[last] + 1;
			while(~last && ch[last][c] == p) ch[last][c] = q, last = link[last];
			link[p] = link[cur] = q;
		}	
	}
	return cur;
}

int single[25000], bkmx[25000]; const int bk = 200;
void update(int pos, int x) {
	chkmax(single[pos], x);
	chkmax(bkmx[(pos - 1) / bk + 1], x);
} 
int query(int r) {
	int res = 0;
	for(int i = 1; i < (r - 1) / bk + 1; ++i) chkmax(res, bkmx[i]);
	for(int i = (r - 1) / bk * bk + 1; i <= r; ++i) chkmax(res, single[i]);
	return res;
}
void reset(int pos) { single[pos] = 0, bkmx[(pos - 1) / bk + 1] = 0; }

int main() {
	link[0] = -1; memset(r, -1, sizeof(r));
	ios::sync_with_stdio(false);
	cin >> n >> m;
	_rep(i,1,n) cin >> s[i];
	_rep(i,1,m) { cin >> q[i].l >> q[i].r; q[i].id = i; }
	sort(q + 1, q + 1 + m, [](const Query &a, const Query &b) -> int {
		return a.r < b.r;
	});
	int p = 0;
	_rep(i,1,n) {
		// debug("init r = %d\n", i);
		int cur = 0;
		vector<int> prefixNode, resume;
		for(auto &c : s[i]) cur = extend(cur, c), prefixNode.push_back(cur);
		for(auto &x : prefixNode) {
			while(~x && vis[x] < i) {
				vis[x] = i;
				if(r[x] == i - 1) ++r[x];
				else l[x] = i, r[x] = i;
				update(l[x], len[x]);
				// if(i == 8109) debug("Update [%d, %d] len %d\n", l[x], i - 1, len[x]);
				resume.push_back(l[x]);
				x = link[x];
			}
		}
		// if(i >= 8000 && i <= 8109) debug("l[1] = %d, r[1] = %d\n", l[1], r[1]);
		while(p < m && q[p + 1].r == i) {
			++p; 
			// debug("res[%d] = query(%d)\n", q[p].id, q[p].l);
			res[q[p].id] = query(q[p].l);
		}
		for(auto &id : resume) reset(id);
	}
	_rep(i,1,m) outln(res[i]);
	return 0;
}
```

---

## 作者：Illusory_dimes (赞：2)

猫树好题！！1

## Description

给定 $n$ 个模式串 $s_i$ ， $q$ 个询问，求区间内所有字符串最长公共子串长度。

$n \leq 2 \cdot 10 ^ 4,\ \ q\leq 10 ^ 5,\ \ \sum s_i \leq 4 \cdot 10 ^ 5$

## Analysis

区间 [LCS2](https://www.luogu.com.cn/problem/SP1812 "LCS2") ，并且没有修改。

## Solution

看到 LCS2 的做法，好像这并不太能快速合并，似乎就用不了线段树之类的数据结构，但是发现没有修改。

考虑猫树。

那就对于一段区间 $[l,\ r]$ 里的所有字符串，以中点的串为基准串，向两边处理 LCS2 中的我们要处理的前缀答案。

但是我们发现如果以中点的串为基准串的话，一旦分到了一个比较长的串时间会退化的有点严重，所以又要有另外一个做法。

倍增分治，规定一个阈值 $x$ ，把区间内所有长度在 $2^{x}$ 到 $2 ^ {x + 1}$ 里的所有字符串找出来，然后再取中点的串作为基准串去算。

然后继续分治。

看起来很时间很玄学，但是因为有 $\sum len$ 的约束，所以这个部分的串数量是 $\frac{\sum len}{2 ^ x}$ 的，并且整个区间的字符串只会贡献 $\log n$ 次，基准串长度是 $2 ^ x$ ，所以总体时间是 $O(2 ^ x \cdot \frac{\sum len}{2 ^ x} \cdot \log n) = O(\sum len \cdot \log n)$ 的，总共 $\log \sum len$ 层，所以总时间就是 $O(\sum len \cdot \log n \cdot \log \sum len)$ 。

好办了，但是空间不允许，所以改一下，改成猫树分治，也就是说我们要在预处理猫树的时候就要算好对应的查询答案。

直接每次找对应的区间计算基准串的答案就行了，看起来很暴力，所以来分析一下时间：

每个区间只会被遍历 $\log n$ 次；

其次，回想猫树查询的做法，是对所有左端点在左遍历区间，右端点在右遍历区间的区间们求得答案，然后在这个题目中一个区间的查询时间是遍历区间的基准串长度（因为是对于基准串每个位置答案求 $\max$ ）。

发现这个基准串在这个遍历区间中是属于长度最小的几个字符串之一，我们可以默认为 $\min_{i = l} ^ r len(s_i)$ 。所以加入区间没有重复的话，要求总时间尽可能大的话（需要稍微意会一下），设总操作数是 $q$ ，大概有这样的一个式子（默认 $t_i$ 是 $s_i$ 长度从大到小排序）：

$$\sum_{i = 1} ^ {\sqrt{q}} len(t_i) \cdot i$$

又因为有 $\sum len$ 的约束，所以上式最大是在 $O(n \cdot \sqrt{q})$ 。

总时间复杂度 $O(\sum len \cdot \log n \cdot \log \sum len + n \cdot \sqrt{q})$ 。

## Code

```cpp
/*

*/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e4 + 10, M = 1e5 + 10, S = 3e6 + 10;
int n, m, len[N], cnt, pos[N], p[M], k, ip[M], ans[M];
char sp[S], *str[N], *st = sp;
int slen[S];
inline int read() {
	char ch = getchar();
	int s = 0, w = 1;
	while (!isdigit(ch)) {if (ch == '-') w = -1; ch = getchar();}
	while (isdigit(ch)) {s = (s << 3) + (s << 1) + (ch ^ 48); ch = getchar();}
	return s * w;
}
struct mdzz {int l, r;} q[M];
struct SAM_mdzz {int len, link, ch[2];} a[S];
struct SAM {
	int rt, las;
	inline void init() {rt = las = ++cnt; memset(a[cnt].ch, 0, sizeof(a[cnt].ch));}
	inline void SAM_stru(int c) {
		int cur = ++cnt, p = las;
		memset(a[cur].ch, 0, sizeof(a[cur].ch));
		las = cur;
		a[cur].len = a[p].len + 1;
		while (p && !a[p].ch[c]) a[p].ch[c] = cur, p = a[p].link;
		if (!p) {a[cur].link = rt; return ;}
		int q = a[p].ch[c];
		if (a[p].len + 1 == a[q].len) {a[cur].link = q; return ;}
		int clo = ++cnt;
		a[clo] = a[q];
		a[clo].len = a[p].len + 1;
		a[q].link = a[cur].link = clo;
		while (p && a[p].ch[c] == q) a[p].ch[c] = clo, p = a[p].link;
	}
} s[N];
struct immortalCO {
	#define lson l, mid
	#define rson mid + 1, r
	int *f[N], *g;
	inline void solve(int it, int mid, int sig) {
		int v = s[it].rt, u = v, lth = 0;
		for (int i = 0, c; i < len[mid]; ++i) {
			c = str[mid][i] - '0';
			if (!a[v].ch[c]) {
				while (v != u && !a[v].ch[c]) v = a[v].link;
				lth = a[v].len;
			}
			if (a[v].ch[c]) v = a[v].ch[c], ++lth;
			f[it][i] = min(f[it + sig][i], lth);
		}
	}
	inline void build(int lim, int l, int r, int L, int R) {
		if (L > R) return ;
		int pk = 0, ik, mid;
		while (2333) {
			for (int i = l; i <= r; ++i) {
				if (len[i] <= lim) pos[++pk] = i;
			}
			if (pk) break;
			lim <<= 1;
		}
		mid = pos[(pk + 1) >> 1];
		g = slen;
		for (int i = l; i <= r; ++i) {
			f[i] = g, g += len[mid] + 1;
		}//
		for (int i = 0; i < len[mid]; ++i) f[mid][i] = i + 1;
		for (int i = mid - 1; i >= l; --i) solve(i, mid, 1);
		for (int i = mid + 1; i <= r; ++i) solve(i, mid, -1);
		pk = L - 1; ik = 0;
		for (int i = L, u; i <= R; ++i) {
			u = p[i];
			if (q[u].r < mid) p[++pk] = u;
			else if (q[u].l > mid) ip[++ik] = u;
			else {
				int res = 0;
				for (int j = 0; j < len[mid]; ++j) {
					res = max(res, min(f[q[u].l][j], f[q[u].r][j]));
				}
				ans[u] = res;
			}
		}
		for (int i = 1; i <= ik; ++i) p[i + pk] = ip[i];
		R = pk + ik;
		build(lim, l, mid - 1, L, pk); build(lim, mid + 1, r, pk + 1, R);
	}
	#undef lson
	#undef rson
} ct;
int main() {
	n = read(); m = read();
	for (int i = 1; i <= n; ++i) {
		scanf("%s", str[i] = st);
		len[i] = strlen(str[i]);
		s[i].init();
		for (int j = 0; j < len[i]; ++j)
			s[i].SAM_stru(str[i][j] - '0');
		st += len[i];//
	}
	for (int i = 1; i <= m; ++i) {
		q[i] = (mdzz) {read(), read()}; p[i] = i;
	}
	ct.build(10, 1, n, 1, m);
	for (int i = 1; i <= m; ++i) printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：2018LZY (赞：2)

[更好的阅读体验](https://blog.csdn.net/qq_42886072/article/details/105232088)
# 前言
毒瘤题 $and$ 毒瘤出题人.

无限 $orz~~ cmd.$
# 前置知识
**内存池小技巧**:开一大块静态内存,然后用指针标记位置.

(避免用$vector$等常数巨大的$STL$).

[**猫树**](https://blog.csdn.net/qq_42886072/article/details/105200387):本题运用了类似的思想,但是并没有用线段树.

(我称本题运用的方法为"**猫树分治**).

猫树分治的思想:
>把区间询问,转化为以中间某个状态为中心的DP.
>结合前缀/后缀最值,达到问题的要求.

# 正题
考虑暴力.
对于$[l,r]$区间,我们可以选择其中一个位置$mid$.

定义$f[j]$表示$s[mid]$的前缀$j$在$s[l...r]$的最长公共后缀.(子串一定是一个前缀的后缀)

对于其他所有位置$i\ne mid$,让$s[mid]$在$SAM[i]$上跑,假如已加入$j$个字符,成功匹配$len$个后缀,那么$f[j]=min(f[j],len)$.

最后$ans=\max_{i=1}^{|s[mid]|} f[i]$.


设$len$为总字符数,$S=s[mid]$.
复杂度为$O((r-l+1)|S|+len)$.
显然,取较短的求得更快.

当然我们不可能每个询问都是这样处理,实际上我们先对$f$做以$mid$为中心的前后缀处理,然后用$O(|S|)$扫描数组合并答案.

___
根据上面的思想,我们先把长度小的用于求解.

我们采取倍增分治,每次把 $\le 2^x$ 的串给 提取出来做贡献,之后$x++$.(这样的好处在于,每个询问产生贡献的$S$和最小串的很接近)


单次(一个$x$)每个串会被遍历$O(\log n)$次,总共有$\log len$个$x$.所以总共每个串会被遍历$O(\log n\log len)$.

首先,分治预处理(求$mid$为中心的前后缀)的复杂度为$O(len\log n\log len)$.

然后,设区间内跨$mid$的询问数有$m$个.

如果$|S|\le \dfrac {len}{\sqrt m}$,那么扫描的复杂度即为$O(|S|\sqrt m)=O(len\sqrt m)$.
否则,那么区间的长度$k=r-l+1\le \sqrt m$,本质不同的区间为$k^2$个,记忆化一下,总复杂度为$O(k^2\cdot  \dfrac{len}{k})=O(len\sqrt m)$.

总复杂度为$O(len(\log n\log len+\sqrt m)+m\log m)$.

~~码风好评~~

```cpp
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define gc getchar()
#define cmin(x,y) ((x)>(y)?x=y:0)
using namespace std;
const int N=20010,M=1e5+10,S=800010;

void qr(int &x) {
	char c=gc; x=0;
	while(!isdigit(c))c=gc;
	while(isdigit(c))x=x*10+c-'0',c=gc;
}
void qw(int x) {
	if(x/10) qw(x/10);
	putchar(x%10+'0');
}
void pr(int x) {qw(x); puts("");}

struct node{int fa,len,v[2];}tr[S]; int tot;
struct SAM {
	int last,root;
	void add(int c) {
		register int p=last,x=last=++tot; tr[x].len=tr[p].len+1;
		for(	;p&&!tr[p].v[c];p=tr[p].fa) tr[p].v[c]=x;
		if(!p) tr[x].fa=root;
		else {
			int q=tr[p].v[c],y;
			if(tr[p].len+1==tr[q].len) tr[x].fa=q;
			else {
				tr[y=++tot]=tr[q];
				tr[y].len=tr[p].len+1;
				tr[q].fa=tr[x].fa=y;
				for(	;p&&tr[p].v[c]==q;p=tr[p].fa) tr[p].v[c]=y;
			}
		}
	}
	void bt(char *s) {
		last=root=++tot;
		for(int i=0;s[i];i++) 
			add(s[i]-'0');
	}
}t[N];

int n,m;
char _str[S],*str[N],*spos=_str; int len[N];
int _f[S],*f[N],*Fpos=_f;

//询问 
struct Q {
	int l,r,pos;
	bool operator <(Q b) const {
		return l^b.l?l<b.l:r<b.r;
	}
	bool operator ==(Q b) const {
		return l==b.l&&r==b.r;
	}
}q[M],lq[M],rq[M];
int ans[M];

int sta[N],top;

void solve(int l,int r,int L,int R,int lim) {//[l,r],[L,R]分别为串范围,询问范围 
	if(L>R) return ;
    do {
        top=0;
        for(int i=l;i<=r;i++) if(len[i]<=lim) sta[++top]=i;
        if(top) break;
        lim *= 2;
    } while(1);
    int mid=sta[top+1>>1];//取一个较小又在中间的数
	int tmp=len[mid];
	
	Fpos=_f;
	for(int i=l;i<=r;i++) f[i]=Fpos,Fpos+=tmp+1;//分配区间 
	for(int i=0;i<tmp;i++) f[mid][i]=i+1;//类似猫树思想进行处理
	
	for(int i=mid-1;i>=l;i--) {
		int p=t[i].root,cnt=0;//对应状态,匹配长度 
		for(int j=0;j<tmp;j++) {
			int c=str[mid][j]-'0';
			if(!tr[p].v[c]) {
				while(p!=t[i].root&&!tr[p].v[c]) 
					p=tr[p].fa;
				cnt=tr[p].len;
			}
			if(tr[p].v[c]) p=tr[p].v[c],cnt++;
			f[i][j]=min(f[i+1][j],cnt);
			//f[i][j] 表示str[mid] 前缀j在[i,mid]这些串中的最长公共后缀. 
		}
	}
	
	for(int i=mid+1;i<=r;i++) {
		int p=t[i].root,cnt=0;
		for(int j=0;j<tmp;j++) {
			int c=str[mid][j]-'0';
			if(!tr[p].v[c]) {
				while(p!=t[i].root&&!tr[p].v[c]) 
					p=tr[p].fa;
				cnt=tr[p].len;
			}
			if(tr[p].v[c]) p=tr[p].v[c],cnt++;
			f[i][j]=min(f[i-1][j],cnt);
		}
	}
	
	int lt=0,rt=0;
	for(int i=L;i<=R;i++) {
		int a=q[i].l,b=q[i].r;
		if(a<=mid&&mid<=b) {
			if(q[i]==q[i-1]) ans[q[i].pos]=ans[q[i-1].pos];
			else {
				int res=0;
				for(int j=0;j<tmp;j++)
					res=max(res,min(f[a][j],f[b][j]));
				ans[q[i].pos]=res;
			}
		}
		else if(b<mid) lq[++lt]=q[i];
		else rq[++rt]=q[i];
	}
	
	Q *g=q+L-1;
	for(int i=1;i<=lt;i++) g[i]=lq[i];
	g+=lt;
	for(int i=1;i<=rt;i++) g[i]=rq[i];
	
	solve(l,mid-1,L,L+lt-1,lim);
	solve(mid+1,r,L+lt,L+lt+rt-1,lim);
}

int main() {
	qr(n); qr(m);
	for(int i=1;i<=n;i++) {
		scanf("%s",str[i]=spos);
		len[i]=strlen(str[i]);
		spos+=len[i];
		t[i].bt(str[i]);
	}
	for(int i=1;i<=m;i++)
		qr(q[i].l),qr(q[i].r),q[i].pos=i;
	sort(q+1,q+m+1);
	solve(1,n,1,m,10);
	for(int i=1;i<=m;i++) pr(ans[i]);
	return 0;
}

```





---

## 作者：老莽莽穿一切 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16454997.html)

---

[**你谷 link**](https://www.luogu.com.cn/problem/P5576)

一道综合性相当强的题目，用到了许多算法。

首先看到公共子串可以想到广义 SAM，先建出广义 SAM，在每个节点处记录它被那些串覆盖过，当询问 $[l,r]$ 时，即查找**至少**被 $[l,r]$ 区间内所有串覆盖的节点的 $\mathrm{len}$ 的最大值，问题就是处理每个字串被那些区间覆盖以及快速查询。

回忆我们建广义 SAM 的过程，一共分为两步，首先是建出字典树，然后再连接 $\textrm{fail}$，考虑在这两部分中分别处理，首先我们可以用一个 `set` 用类似珂朵莉树的方法维护区间集合，此时插入单个区间并完成合并可以做到均摊 $\mathcal O\left(\log n\right)$，在建字典树的过程中，我们可以先给所有的字典树中的节点维护好，以便我们下一步操作，此时的总时间复杂度是 $\mathcal O\left(\sum|S|\log n\right)$。

下一步就是建 $\mathrm{fail}$ 指针，直接边建边维护显然不太对，因为我们一个点被覆盖的区间是 $\mathrm{fail}$ 树的子孙及自己的区间并，所以可以先把 $\mathrm{fail}$ 指针全部建好，然后沿叶子到根自底向上拓扑维护，一般使用线段树合并，但是这里前面用的是珂朵莉树，且此处是要取出所有的区间，线段树合并不好维护，可以考虑启发式合并，即每次将小的往大的合并，无非会破坏儿子的集合，之后处理的时候我们就会发现无所谓，时间复杂度证明是老套路，每对时间复杂度有一次贡献就会让所在集合大小翻倍，没几次就到上界了，如果写 Splay 时间复杂度似乎能压到 $\mathcal O\left(\sum|S|\log n\right)$，但是因为插入的操作关系到区间合并，直接用 `set` 更加简单，所以用 `set` 实现，时间复杂度是 $\mathcal O\left(\sum|S|\log^2n\right)$。

接下来就是解决另一个难题，即快速查询，考虑将所有询问离线下来用线段树维护，将所有询问按左端点放在线段树叶子结点上，每个叶子节点上所有询问按右端点从小到大排序，我们发现在广义 SAM 上自底向上维护区间集合的过程中 $\mathrm{len}$ 单调递减，即如果一个节点的区间包含了一个询问，则这个询问可以直接被回答，基于这个性质，每次我们处理完一个节点对应的区间集合，把每个区间扔到线段树上询问，我们上面的维护方法保证了在线段树上当前区间被询问区间包含后，只有当子树内询问右端点最小值比询问区间右端点小时才往下继续走，每次走到叶子一定能回答至少一个询问，时间复杂度得到保证。

最后时间复杂度就是 $\mathcal O\left(\sum|S|\log^2n+m\log n\right)$，记得回收 `set` 的空间，稍微有点卡常，开了 O2 后可过。

[代码](https://www.cnblogs.com/LaoMang-no-blog/p/16454997.html)

---


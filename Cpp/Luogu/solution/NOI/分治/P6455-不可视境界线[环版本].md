# 不可视境界线[环版本]

## 题目背景

- 原题 : [P5617 [MtOI2019]不可视境界线](https://www.luogu.com.cn/problem/P5617)

**附** : [关于本题的`SPJ`和数据的一些信息](https://www.luogu.com.cn/paste/tmwvh5vh)

若出现卡精度或数据出锅,吊打标算等情况,请联系出题人。

## 题目描述

有 $n$ 个半径为 $r$ 的圆,画在一个长度为 $L$ 的首尾相接的纸环上。

所有的圆心都在同一高度,可以看做在纸上画一个数轴然后卷起来,圆心的位置用这个数轴上的点描述。

如果无法理解纸环上圆的分布,可以查看样例解释以及子问题。

要求选出 $k$ 个圆,使得所有圆的并面积最大。

注意,您需要回答确切的选取方案而不是仅仅给出最大并面积。

## 说明/提示

**样例解释** : 

- **样例1** : 最终的并面积约为 $565.871835$。

圆的分布如图所示,其中, $⊙A$ 和 $⊙A2$ 是同一个圆, $⊙B$ 和 $⊙B2$ 是同一个圆。

可以视作向右平移 $L=30$ 个单位长度而得,事实上就相当于在纸环上绕了一圈回到起点。

由于是同一个圆,被红色部分覆盖的面积不能重复计算,最大的并面积即为蓝色部分的面积。

![](https://cdn.luogu.com.cn/upload/image_hosting/g2dk0sqv.png)

- **样例2** : 最终的并面积约为 $942.477796$。

- **样例3** : 最终的并面积约为 $16817.058547$。

**数据范围与约定** :

| 子任务编号 | n | k | 时限 |
| :--: | :--: | :--: | :--: |
| 1 | $10$ | - | $\texttt{1s}$ |
| 2 | $100$ | - | $\texttt{1s}$ |
| 3 | $2000$ | - | $\texttt{1.6s}$ |
| 4 | $3\times 10^4$ | $100$ | $\texttt{2.2s}$ |
| 5 | $1\times 10^5$ | - | $\texttt{3s}$ |

时限在 `std` 耗时的两倍以上。

对于所有的数据, $n\leq 10^5$，$10\leq r\leq 2000$，$0\leq p[i]< L\leq 10^8$，$4r<L$，$3\leq k \leq n$。

表格中均为上界。注意,一些下界限制可能帮助省去了问题的某些边界情况。

## 样例 #1

### 输入

```
5 3 10 30
0 7 14 21 28 ```

### 输出

```
2 3 5 ```

## 样例 #2

### 输入

```
10 3 10 65
0 7 15 24 30 36 41 49 57 63 ```

### 输出

```
3 6 9```

## 样例 #3

### 输入

```
30 10 50 169
0 7 14 21 28 35 42 45 51 55 61 65 68 75 79 83 87 94 97 105 113 118 126 133 140 147 151 156 163 167 ```

### 输出

```
3 5 8 11 15 19 21 24 27 30 ```

# 题解

## 作者：command_block (赞：10)

- 原版 : [P5617 [MtOI2019]不可视境界线](https://www.luogu.com.cn/problem/P5617)

建议去看看我的题解,可以帮助理解本文。关于面积计算和预处理就不赘述了。

首先这是有决策单调性的。前置芝士 : [DP的决策单调性优化总结](https://www.luogu.com.cn/blog/command-block/dp-di-jue-ce-dan-diao-xing-you-hua-zong-jie)

- 方法0

  考虑枚举起点,断环为链,就变成了原版问题。
  
  那么显然有$O(n^2k)$的背包做法,总复杂度就是$O(n^3k)$.

  为了方便对拍这里给出代码:
  
```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<ctime>
#define db long double
using namespace std;
const db Pi=acos(-1);
inline int read(){
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,k,R,L,x[2050],s[1050],tp[1050][1050];
db cir,f[1050][1050],ts[40500];
inline db c(int b,int a){
  if (x[b]-x[a]>=R+R)return cir+(x[b]-x[a])*1e-10;
  return ts[x[b]-x[a]];
}
int st[1050];
db ans;
void calc(int bg)
{
  f[1][1]=cir;
  for (int i=2;i<=n+1;i++)
    for (int j=2;j<=k+1;j++){
      f[i][j]=0;
      for (int p=1;p<i;p++){
        db sav=f[p][j-1]+c(i,p);
        if (sav>f[i][j]){
          f[i][j]=sav;
          tp[i][j]=p;
        }
      }
    }
  db tmp=f[n+1][k+1]-cir;
  if (tmp>ans){
    ans=tmp;
    for (int p=tp[n+1][k+1],c=k;p;p=tp[p][c--])
      st[c]=p;
    for (int i=1;i<=k;i++)st[i]=(st[i]+bg-2+n)%n+1;
    sort(st+1,st+k+1);
  }
}
int main()
{
  if (n>1000)return 0;
  n=read();k=read();R=read();L=read();
  cir=Pi*R*R;
  for (int i=1;i<=R+R;i++)
    ts[i]=(Pi-acos(0.5*i/R)*2)*R*R+sqrt(R*R-i*i*0.25)*i;
  for (int i=1;i<=n;i++)
    s[i+n]=(s[i]=read())+L;
  x[0]=-100000;
  db ans=0;
  for (int i=0;i<n;i++){
    for (int j=1;j<=n+1;j++)
      x[j]=s[i+j];
    calc(i+1);
  }
  for (int i=1;i<=k;i++)
    printf("%d ",st[i]);
  return 0;
}
```

- 方法①

  更快地解决原问题,层单调性分治分治即可$O(nklogn)$,或者原问题的`WQS`+二分队列做到$O(n\log S\log n)$
  
  总复杂度是$O(n^2k\log n)$或者$O(n^2\log S\log n)$.

- 方法②

	考虑路径交错,先$O(nk\log n)$单调性分治求出任意一种方案,然后剩余的所有方案就都是交错的。

	选取最短的(决策点最少)一段,这一段的长度是$O(n/k)$的,在这一段里面枚举起点即可。
    
   这样是$O(n/k)$个原问题,每个的复杂度是$O(nk\log n)$,总复杂度是$O(n^2\log n)$.

接下来是$O(n\log S\log n+n\log^2n)$的魔法。

先考虑如何快速求出任意一种钦定起点的方案。当然直接大力分治就可以$O(nk\log n)$。

根据原题这是凸的,使用`WQS`二分+二分队列即可做到$O(n\log n\log S)$。

但是可能在构造方案上遇到一点麻烦……

可以对圆的位置玄学扰动避免答案凸包三点共线,这样会导致预处理失效引来巨大的时间常数。

考虑仔细分析。

计算扰动对面积的影响时,可以先算出接触弧长,再计算扰动距离。

由于扰动距离很小,扰动后接触弧长变化不大,所以两者相乘即为误差极小的答案。

然后弄个`pair`,如果两种转移原值差距不超过 $eps$ ,则比较扰动损失。

多随机几次应该就能得到恰为$k$个的方案了。

注意,如果能够选出不相交的$k$个圆,扰动也就失效了,此时需要特判。

似乎有比较系统的构造方法……改日再学吧。

由于这是乱搞,精度比较玄学,需要`long double`和玄学调 $eps$,具体可以看代码。

得到了一种方案之后,由于路径交错,可以把每个点的决策区间划分出来,其长度总和是$O(n)$的。

注意,两个端点都要包含,所以可能会产生一些边界情况。

考虑把一段段的决策区间拆下来分层排成一排,则有这样的模式:

![](https://cdn.luogu.com.cn/upload/image_hosting/65qaunah.png)

一条折线则表示某种钦定起始点的最优决策,不难发现折线相交就代表着路径不交错,所以所有折线都是不交的。

现在重头戏来了,我们对起始点分治,对于后面的点采用一般的决策单调性分治。

我们会得到一条折线,把所有的层分成了两部分,大小和为$O(n)$,于是分治下去找折线,决策区间长度总和是$O(n\log n)$的。

注意,正好在分界线上的点是分不清在哪一边的,所以有$O(k)$的额外花费。

我们把起点选在最短的一段,这部分花费就是最坏$O(n/k*k)=O(n)$的了。

当然内层还有普通的决策单调性分治,所以复杂度是$O(n\log^2n)$

由于我们真正做`DP`的时候会拆环为链,有可能最后一块的决策恰为第一个圆,此时需要特判。

折腾了两天终于写完了……

总结一下坑点吧:

- 需要预处理几何部分躲掉大常数。

- 玄学的 $eps$.

- 找到最短的一段之后,要把坐标和下标旋转一下方便处理。

- 决策区间同时包含两个端点,所以是会略微重合的,`DP`的时候需要滚动数组。

- 可能最后一段包含了第一个圆,这是需要特判的。

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#define db long double
#define MaxN 100500
using namespace std;
const db Pi=acos(-1);
inline int read(){
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,cnt,R,x[MaxN];
db f[MaxN],fl[MaxN],ts[MaxN],tl[MaxN],cir;
//a -> b
inline db c(int b,int a){
  // 实际面积 
  if (x[b]-x[a]>=R+R)return f[a]+cir;
  return f[a]+ts[x[b]-x[a]];
}
int tp[MaxN];
inline db rc(int b,int a){
  // 扰动权值 
  if (x[b]-x[a]>=R+R)return fl[a];
  return fl[a]+tl[x[b]-x[a]]*(tp[b]-tp[a]);
}
bool flag;//是否计入扰动 
db eps;
bool cmp(int p,int x,int y){
  db cx=c(p,x),cy=c(p,y);
  if (flag||cx-cy>eps||cy-cx>eps)
    return cx>cy;
  return rc(p,x)>rc(p,y)+eps;
}
int query(int i,int j)
{
  int l=max(i,j),r=min(n,l+R),mid;
  while(l<r){
  	mid=(l+r)>>1;
  	if (cmp(mid,i,j))r=mid;
  	else l=mid+1;
  }if (r==n)return n+cmp(n,j,i);
  return r;
}
int k[MaxN],stk[MaxN],p[MaxN],tot;
db ans,mid,mid2;
void check()
{
  int l=1,r=1;stk[1]=0;
  for (int i=1;i<=n;i++){
  	while(l<r&&k[l+1]<=i)l++;
  	f[i]=c(i,p[i]=stk[l])+mid;
  	fl[i]=rc(i,p[i])+mid2;
  	while(l<r&&k[r]>=query(i,stk[r]))r--;
    stk[++r]=i;k[r]=query(i,stk[r-1]);
  }int tp=n;tot=0;
  while(tp){tp=p[tp];tot++;}
  ans=f[n];
}
int L;
void adjust()
{
  for (int i=1;i<=n;i++)
    tp[i]=(rand()<<12^rand())%10000000;
  //随机扰动并再次WQS
  double l=-R*1e8,r=R*1e8;
  for (int qt=0;qt<=45&&tot!=cnt;qt++){
    mid2=(l+r)/2;check();
    //printf("%d %.8lf\n",tot,(double)mid2);
    if (tot>cnt)r=mid2;
    if (tot<cnt)l=mid2;
  }
}
int st[MaxN];
bool getone()
{
  tot=0;
  db l=-cir,r=0;flag=1;
  while(r-l>eps*1e-4&&tot!=cnt){
    mid=(l+r)/2;check();
    if (tot>cnt)r=mid;
    if (tot<cnt)l=mid;
  }
  /*printf("%.9lf %.9lf\n",(double)((ans-mid*cnt)-cir),(double)ans);
  printf("%.6lf %.18lf\n",(double)cir,(double)mid);
  printf("%d %d\n",tot,cnt);*/
  // 查看初始WQS 

  if (cir+mid>eps){//可以选出k个整圆,则扰动无效
    flag=0;//开始扰动 
    while(tot!=cnt)adjust();
  }//else printf("       Error  %.9lf",(double)(cir*(cnt-1)));
  ans=0;cnt--;
  for (int i=cnt,tp=p[n];i;i--,tp=p[tp])st[i]=tp;
  return cir+mid>eps;
}
void sol(int l,int r,int tl,int tr,db *f,int *p)
{
  int mid=(l+r)>>1;
  f[mid]=0;p[mid]=tl;
  for (int i=tl;i<=min(tr,mid-1);i++){
    db sav=c(mid,i);
    if (sav>f[mid]){
      f[mid]=sav;p[mid]=i;
    }
  }
  if (l<mid)sol(l,mid-1,tl,p[mid],f,p);
  if (mid<r)sol(mid+1,r,p[mid],tr,f,p);  
}
db ff[2][MaxN];
int pp[2][MaxN];
void calc(int bp,int *l,int *r,int *sp)
{
  f[bp]=cir;
  if (bp==1&&r[cnt]==n+1)r[cnt]--;
  /*for (int i=2;i<=cnt;i++)
    printf("  [%d,%d]\n",l[i],r[i]);*/
  //查看决策区间
  sol(l[2],r[2],bp,bp,ff[0],pp[0]);
  for (int i=l[2];i<=r[2];i++)f[i]=ff[0][i];
  for (int i=3;i<=cnt;i++){
    sol(l[i],r[i],l[i-1],r[i-1],ff[i&1],pp[i&1]);
    for (int j=l[i];j<=r[i];j++)f[j]=ff[i&1][j];
  }
  int tp;x[n+2]=L+x[bp];
  db ret=0;
  for (int i=l[cnt];i<=r[cnt];i++){
    db sav=c(n+2,i);
    if (sav>ret){ret=sav;tp=i;}
  }
  ret-=cir;
  for (int i=cnt;i;i--){
    sp[i]=tp;
    tp=pp[i&1][tp];
  }
  /*for (int i=1;i<=cnt;i++){
    printf("%d ",sp[i]);
    //if (sp[i]<=sp[i-1])puts("!");
  }puts("");
  printf("  %d %.9lf\n",bp,(double)ret);*/

  if (ret+eps>ans){
    ans=ret;
    for (int i=1;i<=cnt;i++)
      st[i]=sp[i];
  }if (bp==1&&r[cnt]==n)r[cnt]++;
}
int sl[MaxN<<1],sr[MaxN<<1],sp[MaxN<<1];
void solve(int *l,int *r,int *sp)
{
  if (l[1]>r[1])return ;
  //printf("Solve [%d,%d]\n",l[1],r[1]);
  int mid=(l[1]+r[1])>>1,*tl=l+cnt+1,*tr=r+cnt+1,*tp=sp+cnt+1;
  calc(mid,l,r,sp);
  tl[1]=l[1];tr[1]=mid-1;
  for (int i=2;i<=cnt;i++)
    {tl[i]=l[i];tr[i]=sp[i];}
  solve(tl,tr,tp);
  tl[1]=mid+1;tr[1]=r[1];
  for (int i=2;i<=cnt;i++)
    {tl[i]=sp[i];tr[i]=r[i];}
  solve(tl,tr,tp);
}
int getall()
{
  int ml=1<<30,pos=0,sav=1;n--;
  for (int i=1;i<cnt;i++)
    if (st[i+1]-st[i]<ml){
      ml=st[i+1]-st[i];
      pos=i;
    }//寻找最短的一段并位移
  //for (int i=1;i<=cnt;i++)printf("%d ",st[i]);puts("");
  ml=x[st[pos]];
  for (int i=1;i<=n;i++)x[i]=(x[i]-ml+L)%L;
  sav=ml=st[pos];
  for (int i=1;i<=cnt;i++)st[i]=(st[i]-ml+n)%n+1;
  sort(st+1,st+cnt+1);sort(x+1,x+n+1);
  x[st[cnt+1]=n+1]=x[1]+L;
  for (int i=1;i<=cnt;i++){ 
    sl[i]=st[i];sr[i]=st[i+1];
    //注意保留端点
  }solve(sl,sr,sp);
  return sav;
}
int main()
{
  n=read();cnt=read();R=read();L=read();
  cir=Pi*R*R;eps=1e-10*sqrt(R);
  for (int i=1;i<=R+R;i++){
    tl[i]=acos(0.5*i/R)*2*R;
    ts[i]=(Pi-acos(0.5*i/R)*2)*R*R+sqrt(R*R-i*i*0.25)*i;
  }x[0]=-1000000;
  for (int i=1;i<=n;i++)
    x[i]=read();
  x[++n]=L+x[1];cnt++;
  int sav=1;
  if (getone())sav=getall();
  for (int i=1;i<=cnt;i++)st[i]=(st[i]+sav-2)%n+1;
  sort(st+1,st+cnt+1);
  for (int i=1;i<=cnt;i++)printf("%d ",st[i]);
  return 0;
}
```



---

## 作者：forest114514 (赞：6)

### P6455 不可视境界线[环版本]

卡精度卡了一万年，最后用了一种常数很大的 wqs 二分方法才勉强过去（本题好多人的代码和 cmd 大佬的长度一样的，鉴定为你谷 ctj 的 xxs 过于多了。）

cmd 大佬的讲解已经非常详细了，所以我补充一下严格证明和 wqs 二分的通用构造。

首先这是一个环上的决策单调性最短路问题，最暴力的肯定是断环为链分开跑，不过这显然没有好好利用决策单调性最短路的性质。

> **Lemma 1**（决策单调性最短路的路径单调性）：如果 $x_1=S_1<x_2<\ldots<x_{k+1}=T_1$ 和 $y_1=S_2<y_2<\ldots<y_{k+1}=T_2$ 分别是 $S_1$ 到 $T_1$ 和 $S_2$ 到 $T_2$ 的长度为 $k$ 的字典序最小的最短路，而且 $S_1\leq S_2<T_1\leq T_2$，则有 $\forall i\in [1,k+1],x_i\leq y_i$。
>
> 证明：考虑反证法，假设当前是字典序最小的 $x_{1\sim k+1},y_{1\sim k+1}$，如果找到了最小的 $y_i<x_i$ 和后面第一个 $j>i,y_i\geq x_i$，交换两段变成 $x_{1\sim i-1},y_{i\sim j-1},x_{j\sim k+1}$ 和 $y_{1\sim i-1},x_{i\sim j-1},y_{j\sim k+1}$ 发现路径长度不变而且字典序改变。

利用上述结论，我们先断环为链复制一遍，跑一遍普通版本的 $O(n\log n\log V)$ 的 wqs 二分+二分队列 DP，得到一个长为 $k$ 的决策单调性最短路的决策点，然后在一段里面枚举起点，显然所有起点的开始的决策单调性最短路的每一个点都在一个固定的范围内即我们求出的 $k$ 个点构成的区间中，总长是 $O(n)$ 级别的。

然后现在我们可以类比决策单调性分治的思想，显然一个起点求出的最短路又可以把剩余点的决策区间分成两部分，所以可以套个分治下去，每个段之间用决策单调性分治转移，看着是 $O(n\log^2 n)$，但是每一层至少有个 $O(k)$ 的枚举时间，所以还是 $O(nk+n\log^2 n)$ 的。

不过注意到把一条链划分成 $k$ 段后根据鸽巢原理，最短段是 $O(\frac{n}{k})$ 级别的，从最短的那一段枚举起点分治时间就对了，最后时间 $O(n\log n\log V+n\log^2n)$，换成 Wilber 和 SMAWK 就是 $O(n\log n+n\log V)$ 不过常数上没有任何优势还更难写。

细节 1：一个长为 $n$ 的层其实决策点长度为 $O(n+k)$，会有一个点在两段的情况，都要分别记录决策点和 $f$ 值，这里决策点可以保存在 $i+d$ （$d$ 是段数）的位置就不会重复，然后 $f$ 值的话先用之前 $f_i$ 更新完后面的点再赋值即可。

细节 2：有首尾重叠的情况，直接把初始点 $p_0$ 设为 $p_n-L$ 即可；后面不同起点 $i$ 的初始点显然就是 $p_{i-1}$，这样就算到了重叠的部分。

然后讲讲 wqs 二分优化 DP 解的系统构造（显然就是切不到 $k$ 的时候）：

1. Itst 课件里的做法

   首先 $(k,f(k))$ 不和其他点共线是容易的，然后共线的时候设斜率为 $K$，这个斜率切的点范围为 $[p,q]$，计算出 $p$ 和 $q$ 对应的决策单调性最短路的方案 $P_{1\sim p+1},Q_{1\sim q+1}$，设 $v=k-p$，只用找到满足 $i\in [1,p],P_{i}\leq Q_{i+v}\leq Q_{i+v+1}\leq P_{i+1}$ 的 $i$，即可构造 $Q_{1},\ldots ,Q_{i+v},P_{i+1},\ldots ,P_{p+1}$ 这条长为 $k$ 的决策单调性最短路，可以证明一定存在，而且一定答案是 $f(k)$。

2. 不怎么要脑子的做法

   对 $1\sim n$ 求出最优解能划分的最小/大段数 $ch_{i,0/1}$，从 $i=n$ 开始假设现在还要划分 $x$ 段一直往前找到 $i$ 的一个决策点 $j$ 满足 $x\in [ch_{j,0},ch_{j,1}]$，然后变成下一个子问题了，不难发现一定有解。不过字典序没有保证最小？不过做法 1 我也不知道字典序有没有保证？

很可惜我不知道两个做法的字典序大小保证，不过做法 2 怎么像字典序最大的解？不过一般用 2 没有问题的，当然保险用做法 1 即可。

然后本题比较吃精度，我的做法是在 wqs 二分的时候同时求出最小和最大段数去决策，当 $k$ 被当前斜率切的时候先保证二分迭代次数够多才有精度保证，显然这个东西有两倍常数。

代码（加了一点防抄袭，不过不影响关键部分，本题 ctj 现象过于严重了）：

```cpp
const int N=2e5+100;
const LD pi=acos(-1);
int n,k,r,L,p[N];
db v[N],eps,ans;
vector<int> C,res;
db calc(int d){
	return (d>=2*r)?pi*r*r:v[d];
}
db w(int l,int r){
	return calc(p[r]-p[l]);
}
namespace DP1{
	int pos[N],ch[2][N];
	db f[N];
	struct NODE{
		int p,l,r;
	}q[N]；
	bool cmp(int i,int j,int p,int op){
		db fi=f[i]+w(i,p),fj=f[j]+w(j,p);
		return (fi>fj)||(abs(fi-fj)<eps
			&&((!op&&ch[0][i]<ch[0][j])||(ch[1][i]>ch[1][j]&&op)));
	}
	int check(db mid,int op){//钦定选最后一个，要算最后和第一个选的的交 
		q[head=tail=1]=(NODE){0,1,n};
		rep(i,1,n){
			while(q[head].r<i) ++head;
			q[head].l=i;
			
			f[i]=f[q[head].p]+w(q[head].p,i)+mid;
			ch[op][i]=ch[op][q[head].p]+1;
			
			while(head<=tail&&!cmp(q[tail].p,i,q[tail].l,op)) --tail;
			if(head<=tail){
				int ll=q[tail].l,rr=q[tail].r;
				while(ll<rr){
					int qmid=(ll+rr+1)>>1;
					if(cmp(q[tail].p,i,qmid,op)) ll=qmid;
					else rr=qmid-1;
				}
				q[tail].r=rr;	
				if(rr<n) q[++tail].p=i,q[tail].l=rr+1,q[tail].r=n;
			}
			else q[++tail]=(NODE){i,i+1,n};
		} 
		return ch[op][n];
	}
	void wqs(){
		db L=-pi*r*r,R=0,mid;
		rep(i,1,80){
			mid=(L+R)/2;
			int ml=check(mid,0),mr=check(mid,1);
			if(ml<=k&&k<=mr&&i>70) break;
	 		if(mr<=k) L=mid;
	 		else R=mid;
		}
		int cur=n,rk=k-1;C.pb(n);
		for(int i=n-1;i>-1;--i){
			if(abs(f[i]+w(i,cur)+mid-f[cur])<eps&&ch[0][i]<=rk&&rk<=ch[1][i]){
				C.pb(cur=i),--rk;
			}
		}
		reverse(C.begin(),C.end());
		ans=f[n]-mid*k,res=C;
	}	
}
namespace DP2{
	db f[N];int ch[N<<1];
	void solve(int l,int r,int L,int R,int d){
		if(l>r) return;
		int mid=l+r>>1;db g=-INF;
		rep(i,L,min(mid-1,R)){
			db tmp=f[i]+w(i,mid);
			if(tmp>g) g=tmp,ch[mid+d]=i;
		}
		solve(mid+1,r,ch[mid+d],R,d);
		f[mid]=g;//注意这里 f[mid] 还要更新后面的 f，因为分治的时候决策区间有重 
		solve(l,mid-1,L,ch[mid+d],d);
	}
	void divide(vector<int> cl,vector<int> cr){
		if(cl[0]>cr[0]) return;
		int mid=cl[0]+cr[0]>>1;
		rep(i,cl[1],cr[1]) f[i]=w(mid,i),ch[i+1]=mid;
		rep(i,2,k-1) solve(cl[i],cr[i],cl[i-1],cr[i-1],i);
		solve(mid+n,mid+n,cl[k-1],cr[k-1],k);
		
		vector<int> cmid(0);cmid.pb(mid+n);
		int cur=mid+n,rk=k;
		while(rk--) cmid.pb(cur=ch[cur+rk+1]);
		reverse(cmid.begin(),cmid.end());
		
		if(f[mid+n]>ans) ans=f[mid+n],res=cmid;
		
		--cmid[0],divide(cl,cmid);
		cmid[0]+=2,divide(cmid,cr);
	}
}
signed main(){
	read(n,k,r,L),eps=min((LD)1e-6,1.0*r*r*pi/1e8);
	rep(i,1,r*2) v[i]=pi*r*r-2.0*acos(0.5*i/r)*r*r+1.0*i*sqrt(r*r-0.25*i*i);
	rep(i,1,n) read(p[i]),p[i+n]=p[i]+L;
	p[0]=p[n]-L;
	
	DP1::wqs();
	int pos=1;
	rep(i,1,k) if(C[i]-C[i-1]<C[pos]-C[pos-1]) pos=i;
	vector<int> cl(k+1,0),cr(k+1,0);
	cl[0]=C[pos-1]+(pos==1),cr[0]=C[pos]; 
	rep(i,pos+1,k) cl[i-pos]=C[i-1],cr[i-pos]=C[i];
	rep(i,1,pos-1) cl[i+k-pos]=C[i-1]+n,cr[i+k-pos]=C[i]+n;
	
	DP2::divide(cl,cr);
	cerr<<fixed<<setprecision(6)<<ans<<endl;

	rep(i,1,k) ch.pb((res[i]-1)%n+1);
	sort(ch.begin(),ch.end());
	for(auto i:ch) write(i,' ');
	return 0;
}
```

---

## 作者：251Sec (赞：4)

任取一个起点断环为链，使用 WQS 二分 + 决策单调性，求解这个问题的最大字典序解（具体方法大概是 DP 的时候记一下最多和最少段数），复杂度 $O(n \log n \log V)$。

上述求解过程会得到 $k$ 个断点，把环分成了 $k$ 段，我们宣称：最优解一定是在每一段各取一个断点。证明可以看其它题解。

找到最短的一段。假如我们已知最优解中这一段里选择的断点，接下来就是每一段贡献到下一段，使用决策单调性分治求解。

然而我们还没有确定出这一段选择的断点，不妨对这个东西再次分治，指定这一段最中间的点作为起始断点得到一组方案，而这会把剩下的所有点作为起始断点时，后续段断点的可选范围分成两半。于是可以分治。这里分治的区间划分不是严格不交的，实际上每个分治节点上会多一个 $k$ 的代价，但因为我们是对最短段分治，它的长度不超过 $\frac{n}{k}$，所以乘起来是对的。

总复杂度 $O(n \log n \log V+n \log ^2n)$。

---


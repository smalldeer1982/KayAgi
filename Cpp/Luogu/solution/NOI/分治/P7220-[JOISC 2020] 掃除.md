# [JOISC 2020] 掃除

## 题目背景

JOISC2020 Day 1 T3

由于数据点较多，本题只评测其中的部分数据。

希望获得完整数据的可以到[这里](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day1/sweeping-data.zip)自行下载。

## 题目描述

由于 Bitaro AK 了 IOI，所以 IOI 主办方送了他一套房子，为一个边长为 $N$ 的等腰直角三角形。房间内一点用坐标 $(x,y)$ 表示，其中 $0\leq x+y\leq N$。直角顶点为原点，三角形两腰分别为 $x$ 轴与 $y$ 轴。

![](https://cdn.luogu.com.cn/upload/image_hosting/3m2wdn4u.png)

一天，Bitaro 发现自己已经 AK 了 1919810 届 IOI 闲的没事做准备打扫房间里的灰尘。这些灰尘一开始一共有 $M$ 堆，其中第 $i$ 堆位于 $(X_i,Y_i)$。同时，可能存在多堆灰尘位于同一个位置上的情况。

现在 Bitaro 准备用扫帚打扫房间。我们认为扫帚是放置在房间里的一条线段，并且将这条线段的长度称为扫帚的宽度。由于 Bitaro 很有条理，所以他只会用以下的两种方式打扫房间：

- Bitaro 将扫帚平行于 $y$ 轴放置，一端位于原点。然后他会垂直向右移动扫帚，直到不能移动为止。如果扫帚的宽度为 $l$，那么原来一堆满足 $x<N-l,y\leq l$ 的灰尘 $(x,y)$ 将会被移动到 $(N-l,y)$。（这个位置可能会存在多堆灰尘）我们称这个过程为过程 H。

- Bitaro 将扫帚平行于 $x$ 轴放置，一端位于原点。然后他会水平向上移动扫帚，直到不能移动为止。如果扫帚的宽度为 $l$，那么原来一堆满足 $x\leq l,y<N-l$ 的灰尘 $(x,y)$ 将会被移动到 $(x,N-l)$。（这个位置可能会存在多堆灰尘）我们称这个过程为过程 V。

在 Bitaro 的房间里，依次会发生 $Q$ 个事件。第 $i$ 个事件形如以下 $4$ 种：

- Bitaro 想要计算第 $P_i$ 堆灰尘的位置坐标；

- Bitaro 使用宽度为 $L_i$ 的扫帚，进行了过程 H；

- Bitaro 使用宽度为 $L_i$ 的扫帚，进行了过程 V；

- 有一堆新的灰尘出现在点 $(A_i,B_i)$ 处。如果在这个事件之前一共有 $c$ 堆灰尘，那么这堆灰尘就是房间中的第 $c+1$ 堆灰尘。

由于 Bitaro 已经 AK 了 IOI，啥都不想干，所以你需要写一个程序，给出房间的腰长，每一堆灰尘的位置坐标和每个事件的细节，求出要求的某堆灰尘的位置坐标。

## 说明/提示

### 样例 1 解释

一开始第一堆灰尘位于 $(1,1)$，第二堆灰尘位于 $(4,0)$。图一描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/8e305ll6.png)

在第一个事件中，添加了 $(2,3)$ 位置上的第三堆灰尘。图二描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/wili6lmg.png)

在第二个事件中，Bitaro 用宽度为 $3$ 的扫帚进行了过程 V。之后，第一堆灰尘移动到了 $(1,3)$，图三描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/x5x5nsvb.png)

在第三个事件中，Bitaro 计算了第一堆灰尘的坐标 $(1,3)$。

在第四个事件中，添加 $(1,2)$ 位置上的第四堆灰尘。图四描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxqf521x.png)

在第五个事件中，Bitaro 用宽度为 $3$ 的扫帚进行了过程 H，第一堆灰尘移到了 $(3,3)$，第三堆灰尘移到了 $(3,3)$，第四堆灰尘移到了 $(3,2)$。图五描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/0lt0inff.png)

在第六个事件中，Bitaro 用宽度为 $0$ 的扫帚进行了过程 H，第二堆灰尘移到了 $(6,0)$。图六描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/wnv1lqz7.png)

在第七个事件中，Bitaro 计算了第四堆灰尘的坐标 $(3,2)$。

在第八个事件中，Bitaro 用宽度为 $2$ 的扫帚进行了过程 V，然而什么都没有发生。图七描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/s4rebol9.png)

在第九个事件中，Bitaro 计算了第三堆灰尘的坐标 $(3,3)$。

在第十个事件中，Bitaro 计算了第二堆灰尘的坐标 $(6,0)$。

这组样例满足子任务 1 和子任务 5 的限制。

#### 样例 2~5 解释

第二组样例满足子任务 1,2,4,5 的限制。

第三组样例满足子任务 1,2,5 的限制。

第四组样例满足子任务 1,3,4,5 的限制。

第五组样例满足子任务 1,5 的限制。

#### 子任务

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| Subtask 1 | $m\leq 2\times 10^3,Q\leq 5\times 10^3$ | $1$ |
| Subtask 2 | $T\in\{1,2,4\}$ | $10$ |
| Subtask 3 | $T\in\{1,2,3\},X_i\leq X_{i+1},Y_i\geq Y_{i+1}(1\leq i\leq m-1)$ | $11$ |
| Subtask 4 | $T\in\{1,2,3\}$ | $53$ |
| Subtask 5 | 无 | $25$ | 

对于 $100\%$ 的数据，$1\leq n\leq 10^9,1\leq m\leq 5\times 10^5,1\leq Q\leq 10^6$。保证：

- $0\leq X_i,Y_i\leq N,X_i+Y_i\leq N(1\leq i\leq m)$；

- $1\leq P_i\leq M^\prime(1\leq i\leq Q)$，其中 $M^\prime$ 表示事件 $i$ 发生时灰尘的堆数；

- $0\leq L_i\leq n-1(1\leq i\leq Q)$；

- $0\leq A_i,B_i\leq n,A_i+B_i\leq n(1\leq i\leq Q)$；

- 至少存在一个 $T_i=1$ 的事件。


## 样例 #1

### 输入

```
6 2 10
1 1
4 0
4 2 3
3 3
1 1
4 1 2
2 3
2 0
1 4
3 2
1 3
1 2```

### 输出

```
1 3
3 2
3 3
6 0```

## 样例 #2

### 输入

```
9 4 8
2 3
3 1
1 6
4 3
2 6
1 3
2 2
1 4
2 3
1 2
2 4
1 1```

### 输出

```
3 6
4 3
7 1
6 3```

## 样例 #3

### 输入

```
8 1 8
1 5
4 4 1
2 6
1 2
2 3
4 2 2
2 5
1 1
1 3```

### 输出

```
4 1
3 5
3 2```

## 样例 #4

### 输入

```
7 4 9
1 5
2 2
4 2
5 0
2 6
2 3
1 2
3 6
1 4
3 1
1 1
2 2
1 3```

### 输出

```
4 2
5 1
1 6
5 2```

## 样例 #5

### 输入

```
20 5 25
10 6
0 4
2 1
1 0
2 3
2 18
3 9
4 1 5
4 0 2
3 10
4 3 3
3 3
2 9
4 9 1
3 12
1 4
3 19
1 3
1 9
2 1
1 7
1 6
4 3 3
1 10
1 1
1 5
2 0
1 2
2 2
1 7```

### 输出

```
2 17
2 17
9 8
0 17
1 17
3 3
10 10
2 17
2 17
0 17```

# 题解

## 作者：jun头吉吉 (赞：16)

## 题意

平面直角坐标系上一个等腰直角三角形，维护 $4$ 种操作：

1. 加入 $(x,y)$
2. 把 $y\le l$ 的点横坐标变成 $\max(x,n-l)$
3. 把 $x\le l$ 的点纵坐标变成 $\max(y,n-l)$
4. 查询第 $i$ 个点现在的位置。

## 题解
从测试点出发。 前两个 subtask 我啥都没看出来，所以从第三个开始。

这个就是没有加点操作，并且形状是 $\ddots$。这个有什么用呢？手玩一下发现如果一开始满足这个性质，那么被推一次之后仍然满足这个性质，并且每次更改的是一段连续的点。然后这个玩意儿很容易维护，直接写平衡树即可，复杂度 $\mathcal O(Q\log Q)$，可以参考这份 [11分代码](https://loj.ac/s/1461007)。

然后看第四个 subtask，没有了 $x$ 递增 $y$ 递减的性质，怎么办呢？继续手玩，发现所有推过一次之后的点都满足上面的性质，所以我们只需要计算出每个点第一次被推的时间然后在那个时间加入即可。求第一次被推的时间求相当于求第一个覆盖的矩形，可以正着求直接找但是我只会两只 $\log$ 的，考虑倒过来，一个包含 $(a,b)$ 的矩形的右端点的横坐标在 $[a,N-b]$，于是单点改区间查就是一只 $\log$ 了，总的复杂度还是 $\mathcal O(Q\log Q)$，可以参考这份 [64分代码](https://loj.ac/s/1461102)。

也就是说，我们现在不支持中间加点，我们不希望有这个操作。可不可以没有这个操作呢？其实可以用一只 $\log$ 的代价扔掉这个操作，具体的做法就是线段树分治，每次询问放到 $\log Q$ 个区间上，那么每个区间内都是一个 subtask4，因此总的复杂度就是 $\mathcal O(Q\log^2Q)$，得到了 [100分代码](https://loj.ac/s/1461094)。

## 代码
```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define mt make_tuple
#define eb emplace_back
#define pb push_back
#define pc putchar
#define chkmx(a,b) (a)=max((a),(b))
#define chkmn(a,b) (a)=min((a),(b))
#define fi first
#define se second
using namespace std;
template<class T>
void read(T&x){x=0;char c=getchar();bool f=0;for(;!isdigit(c);c=getchar())f^=c=='-';for(;isdigit(c);c=getchar())x=x*10+c-'0';if(f)x=-x;}
template<class T,class ...ARK>void read(T&x,ARK&...ark){read(x);read(ark...);}
template<class T>void write(T x){if(x<0)pc('-'),x=-x;if(x>=10)write(x/10);pc(x%10+'0');}
template<class T,class ...ARK>void write(T x,ARK...ark){write(x);pc(' ');write(ark...);}
template<class ...ARK>void writeln(ARK...ark){write(ark...);pc('\n');}
typedef long long ll;
const int mod=998244353;
struct mint{
	int x;mint(int o=0){x=o;}mint&operator+=(mint a){return(x+=a.x)%=mod,*this;}mint&operator-=(mint a){return(x+=mod-a.x)%=mod,*this;}
	mint&operator*=(mint a){return(x=1ll*x*a.x%mod),*this;}mint&operator^=( int b){mint a=*this;x=1;while(b)(b&1)&&(*this*=a,1),a*=a,b>>=1;return*this;}
	mint&operator/=(mint a){return*this*=(a^=mod-2);}friend mint operator+(mint a,mint b){return a+=b;}friend mint operator-(mint a,mint b){return a-=b;}
	friend mint operator*(mint a,mint b){return a*=b;}friend mint operator/(mint a,mint b){return a/=b;}friend mint operator^(mint a, int b){return a^=b;}
};
#define lowbit(x) ((x)&-(x))
#define mid ((l+r)>>1)
const int N=2e6+100;
int n,m,q,root,cnt;
mt19937 myrnd(114514);
namespace fhq{
	//x单调不降，y单调不升
	struct node{
		int x,y,tagx,tagy,lc,rc,rnd,fa;
		node(){tagx=tagy=-1,rnd=myrnd();}
		void clr(){x=y=lc=rc=fa=0;tagx=tagy=-1;}
	}t[N];
	void pushup(int x){
		if(t[x].lc)t[t[x].lc].fa=x;
		if(t[x].rc)t[t[x].rc].fa=x;
	}
	void pushtag(int x,int tagx,int tagy){
		if(!x)return;
		if(~tagx)t[x].x=t[x].tagx=tagx;
		if(~tagy)t[x].y=t[x].tagy=tagy;
	}
	void pushdown(int x){
		pushtag(t[x].lc,t[x].tagx,t[x].tagy);
		pushtag(t[x].rc,t[x].tagx,t[x].tagy);
		t[x].tagx=t[x].tagy=-1;
	}
	void splitX(int x,int&a,int&b,int k){
		//按x分裂 <=k 的给 a >k 的给 b
		if(!x)return a=b=0,void();
		pushdown(x);
		if(t[x].x<=k){
			a=x;splitX(t[x].rc,t[x].rc,b,k);
			pushup(a);
		}else{
			b=x;splitX(t[x].lc,a,t[x].lc,k);
			pushup(b);
		}
	}
	void splitY(int x,int&a,int&b,int k){
		//按y分裂 >=k 的给 a <k 的给 b
		if(!x)return a=b=0,void();
		pushdown(x);
		if(t[x].y>=k){
			a=x;splitY(t[x].rc,t[x].rc,b,k);
			pushup(a);
		}else{
			b=x;splitY(t[x].lc,a,t[x].lc,k);
			pushup(b);
		}
	}
	int merge(int x,int y){
		if(!x||!y)return x^y;
		pushdown(x);pushdown(y);
		if(t[x].rnd<t[y].rnd){
			t[x].rc=merge(t[x].rc,y);
			pushup(x);return x;
		}else{
			t[y].lc=merge(x,t[y].lc);
			pushup(y);return y;
		}
	}
	void dfs(int x){
		if(!x)return;
		pushdown(x);
		dfs(t[x].lc);
		dfs(t[x].rc);
	}
};
int x[N],y[N],tim[N];
int op[N],l[N];int qid[N];
namespace sgt{
	#define lc (x<<1)
	#define rc (x<<1|1)
	//单点覆盖 区间最小值
	vector<int>num;
	int mn[N<<2];
	void pushup(int x){mn[x]=min(mn[lc],mn[rc]);}
	void build(int x,int l,int r){mn[x]=q+1;if(l==r)return;build(lc,l,mid);build(rc,mid+1,r);}
	void mdf(int x,int l,int r,int p,int v){if(l==r)return mn[x]=v,void();if(p<=mid)mdf(lc,l,mid,p,v);else mdf(rc,mid+1,r,p,v);pushup(x);}
	int qry(int x,int l,int r,int ql,int qr){if(ql<=l&&r<=qr)return mn[x];if(r<ql||qr<l)return q+1;return min(qry(lc,l,mid,ql,qr),qry(rc,mid+1,r,ql,qr));}
	void init(){
		sort(num.begin(),num.end());num.resize(unique(num.begin(),num.end())-num.begin());
		build(1,0,num.size());
	}
	void mdf(int p,int v){
		p=lower_bound(num.begin(),num.end(),p)-num.begin();
		mdf(1,0,num.size(),p,v);
	}
	int qry(int ql,int qr){
		ql=lower_bound(num.begin(),num.end(),ql)-num.begin();
		qr=lower_bound(num.begin(),num.end(),qr)-num.begin();
		return qry(1,0,num.size(),ql,qr);
	}
}
int xx[N],yy[N],vcnt;vector<int>ids[N];
void ins(int id){
	fhq::t[id].x=xx[id],fhq::t[id].y=yy[id];
	int a,b,c;
	fhq::splitX(root,a,c,xx[id]);fhq::splitY(a,a,b,yy[id]);
	root=fhq::merge(fhq::merge(a,id),fhq::merge(b,c));
}
vector<int>qrys[N<<2];
void add(int x,int l,int r,int ql,int qr,int v){
	if(ql<=l&&r<=qr)return qrys[x].pb(v);
	if(r<ql||qr<l)return;
	add(lc,l,mid,ql,qr,v);add(rc,mid+1,r,ql,qr,v);
}
void solve(int x,int l,int r){
	sgt::num.clear();
	for(int i=l;i<=r;i++){
		ids[i].clear();
		if(op[i]==2)sgt::num.pb(n-::l[i]);
		if(op[i]==3)sgt::num.pb(::l[i]);
	}
	for(auto id:qrys[x])sgt::num.pb(xx[id]),sgt::num.pb(n-yy[id]);
	sgt::init();
	for(int i=r;i>=l;i--){
		if(op[i]==2)sgt::mdf(n-::l[i],i);
		if(op[i]==3)sgt::mdf(::l[i],i);
	}
	root=0;
	for(auto id:qrys[x])fhq::t[id].clr(),fhq::t[id].x=xx[id],fhq::t[id].y=yy[id],ids[sgt::qry(xx[id],n-yy[id])].pb(id);
	for(int i=l;i<=r;i++){
		if(op[i]==2){
			int a,b,c;
			fhq::splitX(root,a,c,n-::l[i]);
			fhq::splitY(a,a,b,::l[i]+1);
			fhq::pushtag(b,n-::l[i],-1);
			root=fhq::merge(fhq::merge(a,b),c);
			for(auto id:ids[i])xx[id]=n-::l[i],ins(id);
		}else if(op[i]==3){
			int a,b,c;
			fhq::splitX(root,a,c,::l[i]);
			fhq::splitY(a,a,b,n-::l[i]);
			fhq::pushtag(b,-1,n-::l[i]);
			root=fhq::merge(fhq::merge(a,b),c);
			for(auto id:ids[i])yy[id]=n-::l[i],ins(id);
		}
	}
	fhq::dfs(root);
	for(auto id:qrys[x])xx[id]=fhq::t[id].x,yy[id]=fhq::t[id].y;
	if(l==r)return;
	solve(lc,l,mid);solve(rc,mid+1,r);
}
signed main(){
	read(n,m,q);
	for(int i=1;i<=m;i++)cnt++,read(x[cnt],y[cnt]);
	for(int i=1;i<=q;i++){
		read(op[i]);
		if(op[i]!=4)read(l[i]);
		else tim[++cnt]=i,read(x[cnt],y[cnt]);
		if(op[i]==1){
			qid[i]=++vcnt;xx[vcnt]=x[l[i]],yy[vcnt]=y[l[i]];
			add(1,1,q,tim[l[i]],i,vcnt);
		}
	}
	solve(1,1,q);
	for(int i=1;i<=q;i++)if(op[i]==1)writeln(xx[qid[i]],yy[qid[i]]);
}
```

---

## 作者：周子衡 (赞：14)

将操作序列离线下来。不妨先考虑只有 `H` 操作的情况。可以发现，每次操作相当于将 $x$ 坐标在 $[0,l]$ 范围内的点的 $y$ 坐标全部对 $n-l$ 取最大值。因而我们设计的算法也简单明了：扫描所有操作，用数据结构维护每个位置上的最大值，然后对每个点查询该位置上的最大值即可。

接着我们考虑只有 `H,V` 操作而没有插入点操作的情况。这时我们不能再简单地取最大值了：`V` 操作对后面的 `H` 操作是有影响的，`H` 操作也对后面的 `V` 操作有影响。怎么办呢？

假设我们在进行一次参数为 $l_h$ 的 `H` 操作前，已经进行了一次参数为 $l_v$ 的 `V` 操作，且 $l_h+l_v < n$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fcmxft5m.png)

可以看出，由于在之前的 `H` 操作中，在区域 $[0,l_h]\times [0,n-l_h]$ 的点都被移动到了直线 $y=n-l_h$ 上（这里区域 $[l_x,r_x]\times [l_y,r_y]$ 描述所有横坐标在 $[l_x,r_x]$ 且纵坐标在 $[l_y,r_y]$ 内的点）。那么 `V` 操作实际上只能影响那些横坐标在 $[l_h+1,n-l_v]$ 的点，而纵坐标的影响范围依旧是 $[0,l_v]$，而内容依旧是将它们的横坐标对 $n-l_v$ 取最大值。`V` 操作对 `H` 操作的影响同理。我们考虑计算出，对每个操作，它能影响到的**最小坐标** $p$ 值是多少（这里的 $p$ 也就是上文中的 $l_h+1$）。如果能计算出 $p$ 值，可以发现事实上 `H,V` 操作已经互相独立了，那么就可以将 `H,V` 操作分别按照 $p$ 值排序，然后询问点也分别按照横、纵坐标排序，顺序扫描并在线段树上更新即可。于是，问题的关键在于 $p$ 值的计算。

对于 $p$ 的计算，我们顺序扫描每一个操作，同时维护两个数组 $H,V$——$V_i$ 表示参数为 $l=i$ 的 `V` 操作此时的 $p$ 值。不失一般性，设扫描到了一个 `V` 操作，我们取出其参数值 $l$，接着：

- 该操作的 $p$ 即为 $V_l$。
- 对于每个 $p\leq i < n-l-1$，$H_i$ 会受到 $l+1$ 的影响，将其对 $l+1$ 取最大值。

观察到 $H,V$ 的维护和坐标的维护类似，使用线段树即可。注意到 $n$ 的范围很大，可以采用离散化或者动态开点线段树的方法。

最后我们处理有插入操作的情形。对每个询问操作，我们可以简单地求出插入该点后的第一个操作和询问前的最后一个操作。再建立一棵以修改操作为下标的线段树，将每个询问的修改区间插入线段树，然后在对线段树 DFS 的过程中套用前面的做法即可。总时间复杂度 $O((m+q)\log q\log n)$，空间复杂度 $O((m+q)\log n)$（主要来自于动态开点线段树，使用离散化可优化到 $O((m+q)\log (m+q))$）。

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#include<set>
#include<iostream>

using namespace std;

int n=0,m=0,q=0;

struct pnt
{
	int x,y;pnt(int xx=0,int yy=0):x(xx),y(yy){}
}P[1500000],A[1500000],F[1500000],tmp[1500000];int ql[1500000],qr[1500000],ins[1500000];

bool xcmp(int a,int b){return A[a].x<A[b].x;}
bool ycmp(int a,int b){return A[a].y<A[b].y;}
bool operator<(pnt a,pnt b){return a.x<b.x;}

struct President
{
	struct nd
	{
		int val,lc,rc;
	}t[30000000];int used;
	int new_node(){++used;t[used].val=t[used].lc=t[used].rc=0;return used;}
	void clear()
	{
		for(int i=0;i<=used;i++)t[i].val=t[i].lc=t[i].rc=0;
		used=0;new_node();
	}
	void modify(int x,int y,int val,int l,int r,int k=1)
	{
		if(l>y||r<x)return;if(x<=l&&r<=y){t[k].val=max(t[k].val,val);return;}
		int mid=(l+r)>>1;
		if(x<=mid){if(!t[k].lc)t[k].lc=new_node();modify(x,y,val,l,mid,t[k].lc);}
		if(y>mid){if(!t[k].rc)t[k].rc=new_node();modify(x,y,val,mid+1,r,t[k].rc);}
	}
	int query(int pos,int l,int r,int k=1)
	{
		if(!k)return 0;
		if(l==r)return t[k].val;
		int x=t[k].val,mid=(l+r)>>1;
		return pos<=mid?max(x,query(pos,l,mid,t[k].lc)):max(x,query(pos,mid+1,r,t[k].rc));
	}
}T,S;

struct Segment_Divide
{
	struct nd
	{
		int l,r;vector<int> P;
	}t[4000000];
	void build(int l,int r,int k=1)
	{
		t[k].l=l,t[k].r=r;if(l==r)return;int mid=(l+r)>>1;build(l,mid,k<<1),build(mid+1,r,k<<1|1);
	}
	void ins(int l,int r,int id,int k=1)
	{
		if(l>t[k].r||r<t[k].l)return;
		if(l<=t[k].l&&t[k].r<=r){t[k].P.push_back(id);return;}
		ins(l,r,id,k<<1),ins(l,r,id,k<<1|1);
	}
	void solve(int k=1)
	{
		if(t[k].P.size())
		{
			vector<pnt> X,Y;
			T.clear(),S.clear();
			for(int i=t[k].l;i<=t[k].r;i++)
			{
				int l=F[i].y;
				if(F[i].x)
				{
					int p=T.query(l,0,n);Y.push_back(pnt(p,l));
					S.modify(p,n-l-1,l+1,0,n);
				}
				else
				{
					int p=S.query(l,0,n);X.push_back(pnt(p,l));
					T.modify(p,n-l-1,l+1,0,n);
				}
			}
			for(int i=0;i<t[k].P.size();i++){tmp[t[k].P[i]]=A[t[k].P[i]];}
			
			sort(t[k].P.begin(),t[k].P.end(),xcmp);
			sort(X.begin(),X.end());
			T.clear();
			for(int i=0,j=0;i<t[k].P.size();i++)
			{
				int u=t[k].P[i];
				while(j<X.size()&&X[j].x<=A[u].x)
				{
					T.modify(0,X[j].y,n-X[j].y,0,n);
					j++;
				}
				tmp[u].x=max(tmp[u].x,T.query(A[u].y,0,n)); 
			}
			
			sort(t[k].P.begin(),t[k].P.end(),ycmp);
			sort(Y.begin(),Y.end());
			T.clear();
			for(int i=0,j=0;i<t[k].P.size();i++)
			{
				int u=t[k].P[i];
				while(j<Y.size()&&Y[j].x<=A[u].y)
				{
					T.modify(0,Y[j].y,n-Y[j].y,0,n);
					j++;
				}
				tmp[u].y=max(tmp[u].y,T.query(A[u].x,0,n)); 
			}
			
			for(int i=0;i<t[k].P.size();i++)A[t[k].P[i]]=tmp[t[k].P[i]];
		}
		if(t[k].l==t[k].r)return;solve(k<<1);solve(k<<1|1);
	}
}D;

int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++)scanf("%d%d",&P[i].x,&P[i].y);
	int c=0,k=0;
	for(int i=1;i<=q;i++)
	{
		int op=0;scanf("%d",&op);
		if(op==1)
		{
			int t=0;scanf("%d",&t);c++;A[c]=P[t];ql[c]=ins[t]+1,qr[c]=k;
		}
		else if(op==2)
		{
			k++;F[k].x=0;scanf("%d",&F[k].y);
		}
		else if(op==3)
		{
			k++;F[k].x=1;scanf("%d",&F[k].y);
		}
		else
		{
			m++;scanf("%d%d",&P[m].x,&P[m].y);ins[m]=k;
		}
	}
	if(k==0){for(int i=1;i<=c;i++)printf("%d %d\n",A[i].x,A[i].y);return 0;}
    
	D.build(1,k);for(int i=1;i<=c;i++)if(ql[i]<=qr[i])D.ins(ql[i],qr[i],i);
    D.solve();
	for(int i=1;i<=c;i++){printf("%d %d\n",A[i].x,A[i].y);}
}

---

## 作者：lcjqwq (赞：6)

考虑把一个点 $(x,y)$ 对应到一个区间 $[x,n-y]$。对于 H 操作而言，相当于给定一个 $x$，对每一个区间 $[l,r]$，如果 $l \leq x \leq r$，那么就把这个区间变成 $[x,r]$。对于 V 操作就是变成 $[l,x]$。

考虑如果所有区间都包含某一个 $p$。那么我们执行一个值为 $x$ 的操作，若 $x \leq p$，那么 V 操作相当于把这个区间的右端点直接设为 $x$，且该区间就不会再包含 $p$ 了。H 操作相当于所有左端点对 $x$ checkmx，并且不会出现不再包含 $p$ 的情况。

我们可以把这个过程放在线段树的分治结构上进行考虑。我们把每个区间存在最小的包含它的区间处（类似猫树的结构）。一个区间被划分后有可能跑到左儿子或者右儿子里面去了，我们要用数据结构来维护这个过程。

在线的做的话我们对每一个线段树节点开一个线段树维护左右端点 checkmx 和 minpos 就能做了，时间 log 方但是空间也带 log。考虑离线把空间变成线性的。我们最开始在根处处理所有的操作，按照时间顺序从前往后维护左端点，如果碰到一个 checkmx 操作把小于他的那些 $l$ 拿出来 merge 在一起再塞回去。碰到一个 $[l,r] \to [l,x]$ 操作就把 $l \leq x$ 全拿出来 pop 了，处理询问就开个数组记录一下第 $i$ 个点当前的 $l$ 是啥，如果已经似了就把询问也丢到儿子里面去。用堆和并查集上记录链表维护就好了捏。  

那么就可以做到时间 $O(n \log^2 n)$，空间线性了。并且常数这块，真的很❤️小❤️的❤️哦

代码：https://www.luogu.com.cn/paste/7dkooj1i


---

## 作者：crashed (赞：5)

# 题目

[点这里](https://loj.ac/p/3273)看题目。

# 分析

观察一下部分分，前三个 subtasks 都比较简单。

仔细思考一下，发现之后的难点都在于 **$x,y$ 两个坐标分离处理**，这导致我们无法轻易地找出需要被修改的点。不过，一旦找出了需要被修改的点，我们反而可以直接暴力修改，只不过**需要保证相同坐标的点在合并过程中不被拆开**，这样复杂度才是对的。

再思考一下，操作这么难受，主要原因是图形太奇怪了。如果整个图形是一个矩形/正方形，那么 $x,y$ 两个坐标就可以分离处理。为了达成这一点，我们考虑一种常见的策略——**分治**：

![](https://cdn.luogu.com.cn/upload/image_hosting/oufhid2h.png)

具体的思路是，我们每次选取一个右上角在直线 $x+y=N$ 上的矩形，**处理在这一局部中的所有操作**。处理完之后，我们可能需要递归到子三角形中，并继续进行划分。于是我们看到了如上图所示的划分形态——蓝色表示第一层、红色表示第二层、绿色表示第三层......

那么，粗糙地看，我们在一个分治矩形中需要做的就是快速地处理操作，以求**在这一系列操作结束后，确定所有点的去向**（要么是到某个子三角形中，要么是留在矩形内），并且相应地处理询问。由于所有的操作都有较严格的时间顺序，并且这样的分治结构并不能帮助我们调整这一顺序，我们需要**按照时间扫描所有的操作**——换言之，“在线”处理。

------------

在一个分治矩形中，我们主要关注 H,V 两种操作的执行逻辑。以 H 操作为例，假设矩形的长为 $x$，宽为 $N-x$，扫帚的长度为 $l$，那么：

1. 如果 $l<N-x$，那么对于矩形内的操作相当于是把 $y\le l$ 的点全部推到右侧的子三角形上。为了维护这个操作，我们需要**能够将点按照 $y$ 从小到大取出**，用一个堆即可。

   这一类操作之后只会影响右侧三角形的点，所以它只需要下放到右侧三角形处理。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/sehy8ddw.png)

2. 如果 $l\ge N-x$，那么相当于将所有 $x<N-l$ 的点的 $x$ 坐标改成 $N-l$。这个操作也可以用堆维护：暴力地弹出 $x<N-l$ 的点，修改之后放回堆。为了保证复杂度，**我们需要这些点全部合在一起，作为一个等价类处理**。幸运的是，复杂度分析说明我们不需要维护全局的等价类，只需要在每个分治矩形的局部维护这样的等价类。

   这一类操作之后只会影响上侧三角形的点，所以它只需要下放到上侧三角形处理。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/3rxuvrxy.png)

V 操作也类似。这是一部分，对于剩下的“点”和“询问”，执行逻辑是：

- 点：如果遇到了第一类 H 操作，我们需要将取出来的 $y\le l$ 的点全部推送到右侧子三角形中，留着之后处理；如果遇到了第二类 H 操作，我们可以直接维护好坐标。

  而对于 V 操作的处理方式完全对称。

- 询问：因为操作是按照时间扫描的，所以扫描到询问时我们可以知道对应点是否还在矩形内。如果在，我们可以解决它；否则，递归到对应的子三角形处理。

堆里面维护的是等价类，我们还需要能够枚举等价类中的所有元素，并且支持快速合并——用自顶向下的树形结构维护即可。在询问的时候，我们需要能够快速查询某一个等价类的坐标值，这个可以直接并查集维护。

所以，如果某一层分治矩形中一共有 $c$ 个操作，这一层的复杂度即为 $O(c\log c)$。

----------

全局的细节：虽然我们要求按照时间顺序处理，但是**同一层的子三角形是完全独立的**，它们之间没有时间的羁绊，所以可以分别处理。

对于任何一个操作，它至多出现在 $O(\log n)$ 个分治矩形中，所以复杂度实际上为 $O((m+q)\log (m+q)\log n)$，空间是线性的。看起来常数比较大，但是跑起来还是非常之优秀的。

另外，我们实际上是在全局中维护了一个分治树的结构，并且根据操作的性质，按树的遍历顺序而非时间处理所有操作，所以这个分治算法**可以倒回去还原出一个在线的算法**，唯一的问题就是空间会增大到 $O((m+q)\log (m+q))$。

# 代码

```cpp
#include <queue>
#include <cstdio>
#include <vector>
#include <utility>

#define rep( i, a, b ) for( int i = (a) ; i <= (b) ; i ++ )
#define per( i, a, b ) for( int i = (a) ; i >= (b) ; i -- )

const int MAXM = 1.5e6 + 5;

template<typename _T>
inline void Read( _T &x ) {
    x = 0; char s = getchar(); bool f = false;
    while( s < '0' || '9' < s ) { f = s == '-', s = getchar(); }
    while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar(); }
    if( f ) x = -x;
}

template<typename _T>
inline void Write( _T x ) {
    if( x < 0 ) putchar( '-' ), x = -x;
    if( 9 < x ) Write( x / 10 );
    putchar( x % 10 + '0' );
}

template<typename _T>
inline _T Max( const _T &a, const _T &b ) {
    return a > b ? a : b;
}

struct Operation {
    int opt, arg1, arg2, id;

    Operation(): opt(), arg1(), arg2(), id( 0 ) {}
    Operation( int O, int A1, int A2, int I ): opt( O ), arg1( A1 ), arg2( A2 ), id( I ) {}
};

struct Point {
    int x, y, id;

    Point(): x( 0 ), y( 0 ), id( 0 ) {}
    Point( int X, int Y, int I ): x( X ), y( Y ), id( I ) {}
};

struct PointCompByX {
    inline bool operator () ( const Point &a, const Point &b ) const {
        return ! ( a.x < b.x );
    }
};

struct PointCompByY {
    inline bool operator () ( const Point &a, const Point &b ) const {
        return ! ( a.y < b.y );
    }
};

struct UFS {
    int fa[MAXM];

    UFS(): fa{} {}

    inline void MakeSet( const int &n ) {
        rep( i, 1, n ) fa[i] = i;
    }

    int FindSet( const int &u ) {
        return fa[u] == u ? u : ( fa[u] = FindSet( fa[u] ) );
    }

    inline void UnionSet( const int &u, const int &v ) {
        fa[FindSet( u )] = FindSet( v );
    }
};

UFS faX, faY;

std :: priority_queue<Point, std :: vector<Point>, PointCompByX> srtByX;
std :: priority_queue<Point, std :: vector<Point>, PointCompByY> srtByY;
std :: vector<Operation> ini; 
std :: vector<int> sonX[MAXM], sonY[MAXM];

int q[MAXM];

bool imp[MAXM];

int extc[MAXM];
int ansX[MAXM], ansY[MAXM];
int posX[MAXM], posY[MAXM];

int N, M, Q;

inline void Read( Operation &op ) {
    Read( op.opt ), Read( op.arg1 );
    if( op.opt == 4 ) Read( op.arg2 );
}

void Divide( const int &sL, const int &sR, std :: vector<Operation> &glb ) {
    if( sL > sR || glb.empty() ) return ;
    if( sL == sR ) {
        for( const auto &x : glb ) if( x.opt == 1 )
            ansX[x.id] = sL, ansY[x.id] = N - sL;
        return ;
    }
    bool any = false;
    for( const auto &x : glb )
        if( x.opt == 1 ) {
            any = true; break;
        }
    if( ! any ) return ;
    std :: vector<Operation> sub[2];
    int mid = ( sL + sR ) >> 1;
    // use potential to handle merging
    while( ! srtByX.empty() ) srtByX.pop();
    while( ! srtByY.empty() ) srtByY.pop();
    for( const auto &x : glb ) {
        if( x.opt == 1 ) {
            if( ~ extc[x.arg1] )
                sub[extc[x.arg1]].push_back( x );
            else
                ansX[x.id] = posX[faX.FindSet( x.arg1 )],
                ansY[x.id] = posY[faY.FindSet( x.arg1 )];
        }
        if( x.opt == 2 ) {
            if( x.arg1 < N - mid ) {
                // push out
                Point tmp;
                while( ! srtByY.empty() ) {
                    tmp = srtByY.top();
                    if( tmp.y > x.arg1 ) break;
                    srtByY.pop();
                    int h = 1, t = 0; q[++ t] = tmp.id;
                    while( h <= t ) {
                        int u = q[h ++];
                        if( extc[u] == -1 )
                            sub[extc[u] = 1].push_back( Operation( 4, mid + 1, posY[tmp.id], u ) );
                        for( const int &x : sonY[u] ) q[++ t] = x;
                        std :: vector<int>().swap( sonY[u] );
                    }
                }
                sub[1].push_back( x );
            } else {
                // add a tag on
                if( x.arg1 > N - mid ) sub[0].push_back( x );
                int prev = 0; Point lst;
                while( ! srtByX.empty() && srtByX.top().x <= N - x.arg1 ) {
                    lst = srtByX.top(), srtByX.pop();
                    posX[lst.id] = lst.x = N - x.arg1;
                    if( prev ) 
                        faX.UnionSet( prev, lst.id ), 
                        sonX[lst.id].push_back( prev );
                    prev = lst.id;
                }
                if( lst.id ) srtByX.push( lst );
            }
        }
        if( x.opt == 3 ) {
            if( x.arg1 < mid ) {
                // push out
                Point tmp;
                while( ! srtByX.empty() ) {
                    tmp = srtByX.top();
                    if( tmp.x > x.arg1 ) break;
                    srtByX.pop();
                    int h = 1, t = 0; q[++ t] = tmp.id;
                    while( h <= t ) {
                        int u = q[h ++];
                        if( extc[u] == -1 )
                            sub[extc[u] = 0].push_back( Operation( 4, posX[tmp.id], N - mid + 1, u ) );
                        for( const int &x : sonX[u] ) q[++ t] = x;
                        std :: vector<int>().swap( sonX[u] );
                    }
                }
                sub[0].push_back( x );
            } else {
                // add a tag on
                if( x.arg1 > mid ) sub[1].push_back( x );
                int prev = 0; Point lst;
                while( ! srtByY.empty() && srtByY.top().y <= N - x.arg1 ) {
                    lst = srtByY.top(), srtByY.pop();
                    posY[lst.id] = lst.y = N - x.arg1;
                    if( prev ) 
                        faY.UnionSet( prev, lst.id ),
                        sonY[lst.id].push_back( prev );
                    prev = lst.id;
                }
                if( lst.id ) srtByY.push( lst );
            }
        }
        if( x.opt == 4 ) {
            if( x.arg2 > N - mid ) {
                sub[extc[x.id] = 0].push_back( x ); continue;
            }
            if( x.arg1 > mid ) {
                sub[extc[x.id] = 1].push_back( x ); continue;
            }
            sonX[x.id].clear(), sonY[x.id].clear();
            faX.fa[x.id] = x.id, faY.fa[x.id] = x.id;
            extc[x.id] = -1, posX[x.id] = x.arg1, posY[x.id] = x.arg2;
            srtByX.push( Point( posX[x.id], posY[x.id], x.id ) );
            srtByY.push( Point( posX[x.id], posY[x.id], x.id ) );
        }
    }
    std :: vector<Operation> ().swap( glb );
    Divide( sL, mid - 1, sub[0] );
    Divide( mid + 1, sR, sub[1] );
}

int main() {
    Read( N ), Read( M ), Read( Q ), ini.reserve( M + Q );
    rep( i, 1, M ) {
        int x, y; Read( x ), Read( y );
        ini.push_back( Operation( 4, x, y, i ) );
    }
    rep( i, 1, Q ) {
        Operation tmp; Read( tmp );
        tmp.id = tmp.opt == 4 ? ++ M : i;
        ini.push_back( tmp ), imp[i] = tmp.opt == 1;
    }
    Divide( 0, N, ini );
    rep( i, 1, Q ) if( imp[i] )
        Write( ansX[i] ), putchar( ' ' ), Write( ansY[i] ), putchar( '\n' );
    return 0;
}
```

---

## 作者：Seauy (赞：4)

[题目链接](https://www.luogu.com.cn/problem/P7220)

## 题目大意

- 一开始所有 $m$ 个点都在 $x=0,y=0,x+y=n$ 围成的三角形内。

- 支持四种操作：

1. 查询某个点的位置。

2. 把 $y\leq l$ 的点的 $x$ 与 $n-l$ 取最大值。

3. 把 $x\leq l$ 的点的 $y$ 与 $n-l$ 取最大值。

4. 插入一个在三角形内的点。

- $m\leq 5\times 10^5$，$q \leq 10^6$，坐标 $\leq 10^9$，11s。

题面里 H 和 V 的含义反了，底下的样例解释是对的。

# Solution

给个 CDQ分治 的做法。

一般的 CDQ 是通过时间上的分治做到计算每对 修改-查询 的影响，在这题里类似，可以计算每对 插入-若干修改-查询。

类似于猫树，每个 插入-查询 在中点分割他们的分治区域内处理好。比如现在 CDQ 的左区间为 $[L,mid]$，右区间为 $(mid,R]$，首先所有在左区间插入的点都得处于完成了 $[L,mid]$ 所有修改后的状态，这个注意一下 CDQ 的顺序即可，可以先递归 $[L,mid]$ 再递归 $(mid,R]$，然后处理跨过 $mid$ 的 插入-查询，最后想办法把左区间插入的点都改成经过 $(mid,R]$ 所有修改后的状态。

每个分治区域内都是一组静态问题，即没有插入只有修改和查询。可以发现所有修改的矩形的并的轮廓线上的点很好维护，因为如果把他们先按 $x$ 后按 $y$ 坐标排好序，每次修改相当于区间 x/y 赋值。所以可以先扫描线求出每个点移动到轮廓线上的时间，用平衡树维护即可。

时间 $O((m+q)\log^2 (m+q))$，空间 $O(m+q)$。

所以其实去掉修改全在斜边上的限制也能这样做。

# Code

```cpp
#include<bits/stdc++.h>
#define Lson(x) node[x].Son[0]
#define Rson(x) node[x].Son[1]
#define fa(x) node[x].father
using namespace std;

typedef long long ll;

const int MAXN=1e9,MAXM=5e5,MAXQ=1e6,MAXT=MAXM+MAXQ;

inline int Read()
{
	int res;char c;
	while(1) {c=getchar();if('0'<=c && c<='9') {res=c-'0';break;}}
	while(1) {c=getchar();if('0'<=c && c<='9') res=res*10+c-'0';else break;}
	return res;
}

int n,m,q;

struct Query
{
	int opt,x,ID;
	inline int X()
	{
		if(opt==2) return n-x;
		return x;
	}
}ope[MAXT+5];int T;

struct Point
{
	int x,y;
	inline void Scan() {x=Read(),y=Read();}
	inline void Print() {printf("%d %d\n",x,y);}
}ver[MAXT+5];

Point ans[MAXQ+5];int anum;
int Tim[MAXT+5];//每个点出现的时间

struct fhqTreap
{
	int Son[2],tag1,tag2,KEY;
	//对于操作：最小时间戳，操作 x 坐标
	//对于灰尘：x 懒标记，y 懒标记
	int father;
}node[MAXT+5];int root;

inline void PushUp(int now)
{
	node[now].tag1=now;
	if(Lson(now)) node[now].tag1=min(node[now].tag1,node[Lson(now)].tag1);
	if(Rson(now)) node[now].tag1=min(node[now].tag1,node[Rson(now)].tag1);
}
void SplitOpe(int now,int &a,int &b,int x)
{
	if(!now) {a=b=0;return;}
	if(node[now].tag2<=x) a=now,SplitOpe(Rson(now),Rson(a),b,x);
	else b=now,SplitOpe(Lson(now),a,Lson(b),x);
	PushUp(now);
}
int MergeOpe(int a,int b)
{
	if(!a || !b) return a^b;
	if(node[a].KEY>node[b].KEY)
	{
		Rson(a)=MergeOpe(Rson(a),b);
		PushUp(a);
		return a;
	}
	Lson(b)=MergeOpe(a,Lson(b));
	PushUp(b);
	return b;
}
inline int GetMin(int L,int R)
{
	int a,b,c;
	SplitOpe(root,a,b,L-1);
	SplitOpe(b,b,c,R);
	int res=node[b].tag1;
	root=MergeOpe(MergeOpe(a,b),c);
	return res;
}
inline void InsertOpe(int x)
{
	Lson(x)=Rson(x)=0;
	node[x].tag1=x;
	node[x].tag2=ope[x].X();
	node[x].KEY=rand();
	int a,b;
	SplitOpe(root,a,b,node[x].tag2);
	root=MergeOpe(MergeOpe(a,x),b);
}

Point Ask(int x)
{
	Point res=ver[x];
	while(1)
	{
		if(node[x].tag1) res.x=node[x].tag1;
		if(node[x].tag2) res.y=node[x].tag2;
		if(fa(x)) x=fa(x);
		else break;
	}
	return res;
}
inline void PushDown(int now)
{
	if(node[now].tag1)
	{
		if(Lson(now)) node[Lson(now)].tag1=ver[Lson(now)].x=node[now].tag1;
		if(Rson(now)) node[Rson(now)].tag1=ver[Rson(now)].x=node[now].tag1;
		node[now].tag1=0;
	}
	if(node[now].tag2)
	{
		if(Lson(now)) node[Lson(now)].tag2=ver[Lson(now)].y=node[now].tag2;
		if(Rson(now)) node[Rson(now)].tag2=ver[Rson(now)].y=node[now].tag2;
		node[now].tag2=0;
	}
}
void SplitX(int now,int &a,int &b,int x)
{
	if(!now) {a=b=0;return;}
	PushDown(now);
	if(ver[now].x<=x)
	{
		a=now;
		if(Rson(a)) fa(Rson(a))=0;
		SplitX(Rson(now),Rson(a),b,x);
		if(Rson(a)) fa(Rson(a))=a; 
	}
	else
	{
		b=now;
		if(Lson(b)) fa(Lson(b))=0;
		SplitX(Lson(now),a,Lson(b),x);
		if(Lson(b)) fa(Lson(b))=b;
	}
}
void SplitY(int now,int &a,int &b,int y)
{
	if(!now) {a=b=0;return;}
	PushDown(now);
	if(ver[now].y<=y)
	{
		b=now;
		if(Lson(b)) fa(Lson(b))=0;
		SplitY(Lson(now),a,Lson(b),y);
		if(Lson(b)) fa(Lson(b))=b;
	}
	else
	{
		a=now;
		if(Rson(a)) fa(Rson(a))=0;
		SplitY(Rson(now),Rson(a),b,y);
		if(Rson(a)) fa(Rson(a))=a;
	}
}
void SplitXY(int now,int &a,int &b,int x,int y)
{
	if(!now) {a=b=0;return;}
	PushDown(now);
	if(ver[now].x<x || (ver[now].x==x && ver[now].y>y))
	{
		a=now;
		if(Rson(a)) fa(Rson(a))=0;
		SplitXY(Rson(now),Rson(a),b,x,y);
		if(Rson(a)) fa(Rson(a))=a; 
	}
	else
	{
		b=now;
		if(Lson(b)) fa(Lson(b))=0;
		SplitXY(Lson(now),a,Lson(b),x,y);
		if(Lson(b)) fa(Lson(b))=b;
	}
}
int MergeAsh(int a,int b,int c)
{
	if(!a || !b) {if(a^b) fa(a^b)=c; return a^b;}
	PushDown(a),PushDown(b);
	if(node[a].KEY>node[b].KEY)
	{
		fa(a)=c;
		Rson(a)=MergeAsh(Rson(a),b,a);
		return a;
	}
	fa(b)=c;
	Lson(b)=MergeAsh(a,Lson(b),b);
	return b;
}
inline void InsertAsh(int x)
{
	Lson(x)=Rson(x)=fa(x)=0;
	node[x].tag1=node[x].tag2=0;
	node[x].KEY=rand();
	int a,b;
	SplitXY(root,a,b,ver[x].x,ver[x].y);
	root=MergeAsh(MergeAsh(a,x,0),b,0);
}
inline void Hmove(int x)
{
	int a,b,c;
	SplitX(root,b,c,n-x);
	SplitY(b,a,b,x);
	if(b) node[b].tag1=ver[b].x=n-x;
	root=MergeAsh(MergeAsh(a,b,0),c,0);
}
inline void Vmove(int x)
{
	int a,b,c;
	SplitX(root,b,c,x);
	SplitY(b,a,b,n-x);
	if(b) node[b].tag2=ver[b].y=n-x;
	root=MergeAsh(MergeAsh(a,b,0),c,0);
}

void AllPushDown(int now)
{
	if(!now) return;
	PushDown(now);
	AllPushDown(Lson(now));
	AllPushDown(Rson(now));
}

int Head[MAXT+5],nxt[MAXT+5];
inline void Push(int x,int v)
{
	if(!x) return;
	nxt[v]=Head[x],Head[x]=v;
}
bool V[MAXT+5];
void CDQ(int L,int R)
{
	if(L==R) return;
	int mid=(L+R)>>1;
	CDQ(L,mid),CDQ(mid+1,R);
	root=0;
	for(int i=mid+1;i<=R;i++)
		if(ope[i].opt==2 || ope[i].opt==3) InsertOpe(i),Head[i]=0;
	for(int i=L,x;i<=mid;i++)
		if(ope[i].opt==4)
		{
			x=ope[i].x;//灰尘编号 
			Push(GetMin(ver[x].x,n-ver[x].y),x);
			V[x]=0;
		}
	root=0;
	for(int i=mid+1;i<=R;i++)
		if(ope[i].opt==1)
		{
			if(L<=Tim[ope[i].x] && Tim[ope[i].x]<=mid)
			{
				if(V[ope[i].x]) ans[ope[i].ID]=Ask(ope[i].x);
				else ans[ope[i].ID]=ver[ope[i].x];
			}
		}
		else if(ope[i].opt==2)
		{
			Hmove(ope[i].x);
			for(int j=Head[i];j;j=nxt[j])
				V[j]=1,ver[j].x=n-ope[i].x,InsertAsh(j);
		}
		else if(ope[i].opt==3)
		{
			Vmove(ope[i].x);
			for(int j=Head[i];j;j=nxt[j])
				V[j]=1,ver[j].y=n-ope[i].x,InsertAsh(j);
		}
	AllPushDown(root);
}

int main()
{
	srand(unsigned(time(0)));
	n=Read(),m=Read(),q=Read();
	for(int i=1;i<=m;i++) ver[i].Scan(),ope[++T]=Query{4,i,0},Tim[i]=T;
	for(int opt,x;q--;)
	{
		opt=Read();
			 if(opt==1) x=Read(),ope[++T]=Query{1,x,++anum};
		else if(opt==2) x=Read(),ope[++T]=Query{2,x,0};//向右 
		else if(opt==3) x=Read(),ope[++T]=Query{3,x,0};//向上 
		else ver[++m].Scan(),ope[++T]=Query{4,m,0},Tim[m]=T;
	}
	CDQ(1,T);
	for(int i=1;i<=anum;i++) ans[i].Print();
	return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：4)

**P7220** 

此题的加强版即为 Ynoi 的 T166，期望在 2077 年加入出题库。

**无序性**：观察到一段连续的 $H/V$ 操作其实是可以无续操作的。

**非容斥事件的无序性**：观察到对于一个间接的插入，根据上文同类操作的无序性，我们维护异类操作互相的影响。

这里的影响是抽象的，以 $H$ 操作举例，我们维护 $l_V$ 在该操作之前小于该 $n - l_{H_i}$ 最大的 $l_V$，即确定了该 $H$ 操作实际影响的矩形。

考虑任意一个查询等价于一个点从第 $l$ 个修改开始到第 $r$ 个修改结束后的点状态。

问题变成：给定 $m$ 个修改操作，等价于将一个矩形内的点的 $(x,y)$ 中的一维取到一个给定的矩形边界，给定 $q$ 个询问，且每个矩形信息由查询的区间信息决定，但修改具有子问题划分的性质。

考虑建立线段树，对于每个修改区间 $[l,r]$ 维护出当前每个位置的矩形，我们显然可以将修改看作一个函数层面上的映射，所以将一个点 $x \rightarrow f_1(x) = y,y \rightarrow f_2(y) = z$ 这样，在线段树上做 $O(\log n)$ 次无序的二维数点，即排一下序退化到一维的数点即可。

时间复杂度 $O(m \log q \log n)$。

此题在谷上空间限制太小，建议去 loj 交。

---

## 作者：yuguanchen2022 (赞：3)

# [P7220 [JOISC 2020] 掃除](https://www.luogu.com.cn/problem/P7220)
## 题意简述
平面直角坐标系上一个等腰直角三角形，维护 4 种操作：
+ 查询第 $ i $ 个点现在的位置
+ 把 $ y \le l $ 的点的横坐标变成 $ \max(x,n−l) $
+ 把 $ x \le l $ 的点纵坐标变成 $ \max(y,n−l) $
+ 加入 $ (x,y) $
## 思路
容易发现操作 4 特别难弄，因此我们先考虑没有操作 4 怎么做。

容易发现对于任意时刻都存在一条左上到右下的轮廓线，满足所有点要么在轮廓线上，要么位置没有发生改变。

所以先求出每个点第一次被移动的时刻 $ p_i $，同时维护一个平衡树表示轮廓线上的点，在 $ p_i $ 时刻将 $ i $ 号点加入平衡树，修改时直接将需要修改的区间 split 出来打标记即可。

如果有操作 4，会让某个点在加入的时候在轮廓线下面，导致上面的做法不正确。考虑规避掉操作 4。

假设要求出某个点 $ p $ 经过 $ [l, r] $ 操作后的结果，那么在线段树上找到 $ [l, r] $ 对应的 $ \log_2^n $ 个区间，并将这个点依次插入这些区间。

求答案时进行类似线段树分治的做法，每次将当前线段树节点 $ [l, r] $ 上的点一起做 $ [l, r] $ 操作，然后将这些点操作完的坐标挂到对应的线段树上的下一个区间即可。

时间复杂度：$ O((m + Q) \log (m + Q)) $

## Code

```
#include <bits/stdc++.h>
#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define lop(i, a, b) for (int i = (a); i < (b); i++)
#define dwn(i, a, b) for (int i = (a); i >= (b); i--)
#define mp(a, b) make_pair(a, b)
#define pr pair<int, int>
#define fir first
#define sec second
#define pb push_back
#define iosfst ios::sync_with_stdio(false);cin.tie(0), cout.tie(0)
#define File(x) freopen(x".in", "r", stdin), freopen(x".out", "w", stdout);
using namespace std;
namespace An{
const int M = 1.5e6 + 5, Q = 1e6 + 5;
int n, m, q;
int x[M], y[M], t[M], pos[M], ansx[Q], ansy[Q];
std::vector<int> vec[Q << 2], unq;
struct Query {
  	int op, x, y;
  	Query(int _op = 0, int _x = 0, int _y = 0) : op(_op), x(_x), y(_y) {}
} qq[Q];
struct Node {
  	int ls, rs, val, x, y, tagx, tagy;
  	Node(int _ls = 0, int _rs = 0, int _val = 0, int _x = 0, int _y = 0, int _tagx = 0, int _tagy = 0) : ls(_ls), rs(_rs), val(_val), x(_x), y(_y), tagx(_tagx), tagy(_tagy) {}
};
struct FHQTreap {
  	int rt, tot;
  	Node t[M];
  	void clear() {
    	rep (i, 1, tot) t[i] = Node();
    	rt = tot = 0;
    	return;
  	}
  	int newnode(int p, int y) {
    	t[++tot] = {0, 0, rand(), p, y, 0, 0};
    	return tot;
  	}
  	void addtag(int p, int tagx, int tagy) {
    	if (~tagx) t[p].x = t[p].tagx = tagx;
    	if (~tagy) t[p].y = t[p].tagy = tagy;
    	return;
  	}
  	void pushdown(int p) {
    	if (t[p].ls) addtag(t[p].ls, t[p].tagx, t[p].tagy);
    	if (t[p].rs) addtag(t[p].rs, t[p].tagx, t[p].tagy);
    	t[p].tagx = t[p].tagy = -1;
    	return;
  	}
  	int merge(int L, int R) {
    	if (!L || !R) return L + R;
    	pushdown(L), pushdown(R);
    	if (t[L].val < t[R].val) {
      		t[L].rs = merge(t[L].rs, R);
      		return L;
    	}
		else {
      		t[R].ls = merge(L, t[R].ls);
      		return R;
    	}
  	}
  	void splitx(int p, int x, int &L, int &R) {
    	if (!p) return void(L = R = 0);
    	pushdown(p);
    	if (t[p].x <= x) L = p, splitx(t[p].rs, x, t[p].rs, R);
		else R = p, splitx(t[p].ls, x, L, t[p].ls);
		return;
  	}
  	void splity(int p, int x, int &L, int &R) {
    	if (!p) return void(L = R = 0);
    	pushdown(p);
    	if (t[p].y >= x) L = p, splity(t[p].rs, x, t[p].rs, R);
    	else R = p, splity(t[p].ls, x, L, t[p].ls);
    	return;
  	}
  	int insert(int x, int y) {
    	int a, b, c, id;
    	id = newnode(x, y);
    	splitx(rt, x, a, c);
    	splity(a, y, a, b);
    	rt = merge(merge(a, id), merge(b, c));
    	return id;
  	}
  	void pushall(int p) {
    	if (!p) return;
    	pushdown(p);
    	if (t[p].ls) pushall(t[p].ls);
    	if (t[p].rs) pushall(t[p].rs);
    	return;
  	}
} ft;
struct SGT {
  	int N, val[M << 2];
  	void build(int n) {
    	for (N = 1; N <= n + 1; N <<= 1) {}
    	fill_n(val, 2 * N, 1e9);
    	return;
  	}
  	void update(int x, int v) {
    	for (x += N; x; x >>= 1) val[x] = v;
    	return;
  	}
  	int query(int l, int r) {
    	if (l > r) return 1e9;
    	int ret = 1e9;
    	for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {
      		if (~l & 1) ret = min(ret, val[l ^ 1]);
      		if (r & 1) ret = min(ret, val[r ^ 1]);
    	}
    	return ret;
  	}
} sgt[2];
void update(int x, int l, int r, int ql, int qr, int id) {
  	if (l > qr || r < ql) return;
  	if (l >= ql && r <= qr) return void(vec[x].emplace_back(id));
  	int mid = (l + r) >> 1;
  	update(x << 1, l, mid, ql, qr, id), update(x << 1 | 1, mid + 1, r, ql, qr, id);
  	return;
}
void discrete(int l, int r) {
  	unq.clear();
  	for (int i = l; i <= r; ++i) if (qq[i].op == 2 || qq[i].op == 3) unq.emplace_back(qq[i].x);
 	sort(unq.begin(), unq.end());
  	unq.erase(unique(unq.begin(), unq.end()), unq.end());
  	return;
}
int getid(int x) { return lower_bound(unq.begin(), unq.end(), x) - unq.begin() + 1; }
void solve(int x, int l, int r) {
  	static vector<int> vv[M];
  	ft.clear();
  	discrete(l, r);
  	sgt[0].build(unq.size()), sgt[1].build(unq.size());
  	dwn(i, r, l) {
    	if (qq[i].op == 2) sgt[0].update(getid(qq[i].x), i);
    	else if (qq[i].op == 3) sgt[1].update(getid(qq[i].x), i);
  	}
  	for (auto i : vec[x]) {
    	int p = min(sgt[0].query(getid(ansy[i]), getid(n - ansx[i] + 1) - 1), sgt[1].query(getid(ansx[i]), getid(n - ansy[i] + 1) - 1));
    	if (p <= r) vv[p].emplace_back(i);
  	}
  	rep (i, l, r) {
    	int x, y, z;
    	if (qq[i].op == 2) {
      		ft.splitx(ft.rt, n - qq[i].x, x, z);
      		ft.splity(x, qq[i].x + 1, x, y);
      		if (y) ft.addtag(y, n - qq[i].x, -1);
      		ft.rt = ft.merge(ft.merge(x, y), z);
    	}
		else if (qq[i].op == 3) {
      		ft.splitx(ft.rt, qq[i].x, x, z);
      		ft.splity(x, n - qq[i].x + 1, x, y);
      		if (y) ft.addtag(y, -1, n - qq[i].x);
      		ft.rt = ft.merge(ft.merge(x, y), z);
    	}
    	for (auto id : vv[i]) {
      		if (qq[i].op == 2) ansx[id] = max(ansx[id], n - qq[i].x), assert(ansy[id] <= qq[i].x);
      		else ansy[id] = max(ansy[id], n - qq[i].x), assert(ansx[id] <= qq[i].x);
      		pos[id] = ft.insert(ansx[id], ansy[id]);
    	}
  	}
  	ft.pushall(ft.rt);
  	rep (i, l, r) for (auto id : vv[i]) ansx[id] = ft.t[pos[id]].x, ansy[id] = ft.t[pos[id]].y;
  	rep (i, l, r) vv[i].clear();
  	for (auto i : vec[x]) pos[i] = 0;
  	if (l != r) {
    	int mid = (l + r) >> 1;
    	solve(x << 1, l, mid), solve(x << 1 | 1, mid + 1, r);
  	}
  	return;
}
void dickdreamer() {
  	cin >> n >> m >> q;
  	rep (i, 1, m) cin >> x[i] >> y[i], t[i] = 1;
  	rep (i, 1, q) {
    	cin >> qq[i].op;
    	if (qq[i].op == 1) {
      		cin >> qq[i].x;
      		ansx[i] = x[qq[i].x], ansy[i] = y[qq[i].x];
      		update(1, 1, q, t[qq[i].x], i, i);
    	}
		else if (qq[i].op == 2) cin >> qq[i].x;
    	else if (qq[i].op == 3) cin >> qq[i].x;
    	else {
      		cin >> qq[i].x >> qq[i].y;
      		t[++m] = i, x[m] = qq[i].x, y[m] = qq[i].y;
    	}
  	}
  	solve(1, 1, q);
  	rep (i, 1, q) if (qq[i].op == 1) cout << ansx[i] << ' ' << ansy[i] << '\n';
  	return;
}
}
signed main() {
	An::dickdreamer();
	return 0;
}
```

---

## 作者：Coward2008 (赞：2)

首先考虑：所有修改进行后再询问，怎么弄。

我们把所有 $y:=n-y$ ，则两个修改变成：每次给定一个 $x$ ，对于$l\le x\le r$ 的线段 $[l,r]$ ，把它变成 $[l,x]$ 或 $[x,r]$ 。称改成 $[x,r]$ 为操作 $1$ ，改成 $[l,x]$ 为操作 $2$ 。

如果只有操作 $1$，发现这些操作是 **无序** 的，对于初始的 $[l,r]$ ，查询 $\le r$ 的 $x$ 的最大值即可。

现在我们有两种操作，不同的操作之间会互相制约。考察一个先发生的变成操作 $2$ (权值为 $x$)，如何影响后发生的操作 $1$ (权值为 $y$)。

你发现，如果 $x<y$ ，那么 $y$ 操作能影响的线段 $[l,r]$ 一定满足 $x<l\le y\le r$ 。

由此可求出一个操作的影响范围。就把两种操作拆开了。但现在，我们同种之间的操作似乎变得**有序**了，不好搞。

以操作 $1$ 为例：

我们令 $p_i$ 表示一个操作 $x_i$ 影响范围是 $p_i\le l\le x_i\le r$ 。

按 $x_i$ 从小到大的顺序进行操作，它就是正确的。

---

原因：如果有两个操作 $i,j$ 满足 $x_i>x_j,t_i<t_j$ ，那我们担忧，是否有 $l<p_i$ ，因为顺序交换使之最后能变成 $x_i$ 。

分类讨论：如果 $p_i\le x_j$ ，那由 $p$ 的定义，$p_i\le p_j$ ，所以 $l$ 不会被 $i$ 和 $j$ 操作。

如果 $p_i>x_j$ ，那即使 $l$ 先被 $j$ 操作变成 $x_j$，它也无法被 $i$ 操作。

---

由此，我们用线段树维护 $f(l)$ 表示 $l$ 经过当前的所有操作后会变成什么。那插入一个 $(p,x)$ 等同于将所有 $p\le f(l)\le x$ 的 $f(l)$ 改成 $x$ 。

我们在插入所有 $x\le r$ 的操作后询问 $f(l)$ 即可。操作 $2$ 就类似的做就好了。

现在中途有查询和插入，套一个线段树分治就转化成上述做法了。复杂度 $O(n\log^2 n)$ 。


---

## 作者：baka24 (赞：0)

这个二维坐标一看就不是很好维护，所以先将其转化为一维。

![](https://cdn.luogu.com.cn/upload/image_hosting/264ytsmx.png)

如图，像这样把一个点投影到斜边上，将一个点转化为一个区间。

此时一次扫除就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/1402sonm.png)

如图，所有受到影响的点在区间上都跨过了指定点。

对于两种方向的扫除，相当于把左\右端点向对应方向推。

考虑如何维护这个操作。

可以把区间挂到线段树上，每个区间挂在最靠上的、跨过 `mid` 的区间里。

就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/p2fies0a.png)

这样的好处是：

如果一次修改没有改变某个区间所属的节点，那么就只会有左右端点的微量移动，在节点上用数据结构维护即可。

如果一次修改改变了某个区间所属的节点，这个区间就只会向下走，最多移动 $O(\log)$ 次。

所以对于每个节点开两颗平衡树维护左右端点的区间赋值，超过 `mid` 就递归处理。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lson t[now].ls
#define rson t[now].rs
#define pii pair<int,int> 
#define fr first
#define sc second 
#define mk make_pair
#define pb push_back
int read(){int x=0,f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}x=c-'0';c=getchar();while(c<='9'&&c>='0'){x*=10;x+=c-'0';c=getchar();}return x*f;}
const int MAXN=1500010,N=31,M=510,B=700,Mod=998244353;
int n,m,q;
mt19937 rng(time(0));
vector<int>G;
struct Treap{
    int cnt;
    struct node{
        int ls,rs,pri,val,lz,fa;
    }t[MAXN<<1];
    void pushup(int now){
        t[now].fa=0;
        if(lson)t[lson].fa=now;
        if(rson)t[rson].fa=now;
    }
    void pushdown(int now){
        if(t[now].lz!=-1){
            if(lson)t[lson].lz=t[lson].val=t[now].lz;
            if(rson)t[rson].lz=t[rson].val=t[now].lz;
            t[now].lz=-1;
        }
    }
    int mrge(int x,int y){
        if(!x||!y)return x|y;
        pushdown(x),pushdown(y);
        if(t[x].pri<t[y].pri){
            int tmp=mrge(t[x].rs,y);
            t[x].rs=tmp;
            pushup(x);
            return x;
        }
        else{
            int tmp=mrge(x,t[y].ls);
            t[y].ls=tmp;
            pushup(y);
            return y;
        }
    }
    pii split(int now,int key){

        if(!now)return mk(0,0);
        pushdown(now);
        if(t[now].val<=key){
            pii tmp=split(rson,key);
            rson=tmp.fr;
            pushup(now);
            return mk(now,tmp.sc);
        }
        else{
            pii tmp=split(lson,key);
            lson=tmp.sc;
            pushup(now);
            return mk(tmp.fr,now);
        }
    }
    int nnd(int x){
        t[++cnt]={0,0,(int)rng(),x,-1,0};
        return cnt;
    }
    void insert(int &rt,int x){
        int val=t[x].val;
        pii tmp=split(rt,val);
        rt=mrge(mrge(tmp.fr,x),tmp.sc);
    }
    void chmax(int &rt,int x){
        pii tmp=split(rt,x);
        if(tmp.fr)t[tmp.fr].lz=t[tmp.fr].val=x;
        rt=mrge(tmp.fr,tmp.sc);
    }
    void chmin(int &rt,int x){
        pii tmp=split(rt,x-1);
        if(tmp.sc)t[tmp.sc].lz=t[tmp.sc].val=x;
        rt=mrge(tmp.fr,tmp.sc);
    }
    void dfs(int now){
        if(!now)return;
        pushdown(now);
        G.pb(now);
        if(lson)dfs(lson);
        if(rson)dfs(rson);
        t[now].fa=lson=rson=0;
    }
    void get(int x){
        if(t[x].fa)get(t[x].fa);
        pushdown(x);
    }
    int query(int id){
        get(id);
        return t[id].val;
    }
    void cut(int &rt,int now){
        get(now);

        int tmp=mrge(lson,rson);
        lson=rson=0;
        if(!t[now].fa)rt=tmp;
        else {
            if(t[t[now].fa].ls==now)t[t[now].fa].ls=tmp;
            else                    t[t[now].fa].rs=tmp;
        }
        if(tmp)t[tmp].fa=t[now].fa;
        t[now].fa=0;
    }
    void getmx(int &rt,int x){
        pii tmp=split(rt,x-1);
        rt=tmp.fr;
        dfs(tmp.sc);
    }
    void getmn(int &rt,int x){
        pii tmp=split(rt,x);
        rt=tmp.sc;
        dfs(tmp.fr);
    }
}L,R;
struct segtree{
    struct treap{
        int tl,tr,ls,rs;
    }s[MAXN*N];
    int cnt;
    #undef lson
    #undef rson
    #define lson s[pos].ls
    #define rson s[pos].rs
    void update(int &pos,int l,int r,int ql,int qr,int id){
        if(!pos)pos=++cnt;
        int mid=(l+r)>>1;
        if(l==r||ql<=mid&&mid<qr){
            L.insert(s[pos].tl,id),R.insert(s[pos].tr,id);
            return;
        }
        if(qr<=mid)update(lson,l,mid,ql,qr,id);
        if(ql>mid)update(rson,mid+1,r,ql,qr,id);
    }
    void updatel(int pos,int l,int r,int x){
        if(!pos)return;
        if(l==r)return;
        int mid=(l+r)>>1;
        if(x<=mid)L.chmax(s[pos].tl,x),updatel(lson,l,mid,x);
        else{
            R.getmx(s[pos].tr,x);
            for(auto o:G)L.cut(s[pos].tl,o),L.t[o].val=x;
            for(auto o:G)update(rson,mid+1,r,L.t[o].val,R.t[o].val,o);
            G.clear();
            updatel(rson,mid+1,r,x);
        }
    }
    void updater(int pos,int l,int r,int x){
        if(!pos)return;
        if(l==r)return;
        int mid=(l+r)>>1;
        if(x>mid)R.chmin(s[pos].tr,x),updater(rson,mid+1,r,x);
        else{
            L.getmn(s[pos].tl,x);
            for(auto o:G)R.cut(s[pos].tr,o),R.t[o].val=x;
            for(auto o:G)update(lson,l,mid,L.t[o].val,R.t[o].val,o);
            G.clear();
            updater(lson,l,mid,x);
        }
    }
}T;
int rt;
void slv(){
    n=read(),m=read(),q=read();
    for(int i=1;i<=m;i++){
        int x=read(),y=n-read();
        int id=L.nnd(x);id=R.nnd(y);
        T.update(rt,0,n,x,y,id);
    }
    while(q--){
        int op=read();
        if(op==1){
            int x=read();
            printf("%d %d\n",L.query(x),n-R.query(x));
        }
        if(op==2){
            int x=n-read();
            T.updatel(rt,0,n,x);
        }
        if(op==3){
            int x=read();
            T.updater(rt,0,n,x);
        }
        if(op==4){
            int x=read(),y=n-read();
            int id=L.nnd(x);id=R.nnd(y);
            T.update(rt,0,n,x,y,id);
        }
    }
}
signed main(){
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    // int _=read();while(_--)
    slv();
    cerr<<(clock()*1.0)/CLOCKS_PER_SEC<<"s"<<endl;
    return 0;
}
```

---


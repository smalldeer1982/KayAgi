# [THUSC 2017] 杜老师

## 题目描述

杜老师可是要打 $+∞$ 年 World Final 的男人，虽然规则不允许，但是可以改啊！

但是今年 WF 跟 THUSC 的时间这么近，所以他造了一个 idea 就扔下不管了……

给定 $L,R$，求从 $L$ 到 $R$ 的这 $R-L+1$ 个数中能选出多少个不同的子集，满足子集中所有的数的乘积是一个完全平方数。特别地，空集也算一种选法，定义其乘积为 $1$。

由于杜老师忙于跟陈老师和鏼老师一起打 ACM 竞赛，所以，你能帮帮杜老师写写标算吗？

## 说明/提示

对于 $L=1,R=8$，对应的 $16$ 种选法为：

1. 空集
1. $4$
1. $3,6,8$
1. $3,4,6,8$
1. $2,8$
1. $2,4,8$
1. $2,3,6$
1. $2,3,4,6$
1. $1$
1. $1,4$
1. $1,3,6,8$
1. $1,3,4,6,8$
1. $1,2,8$
1. $1,2,4,8$
1. $1,2,3,6$
1. $1,2,3,4,6$

| 测试点 $\operatorname*{Id}$ | $R_i\le$ | $T\le$ | $\sum R_i-L_i+1\le$ | 特殊约束 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 1~2 | $30$ | $10$ | $10^3$ | 无特殊约束 |
| 3 | $100$ | $10$ | $10^3$ | 保证答案不超过 $5\times 10^6$ |
| 4 | $100$ | $10$ | $10^3$ | 无特殊约束 |
| 5~6 | $10^3$ | $10$ | $10^3$ | $R-L\le22$ |
| 7~8 | $10^3$ | $10$ | $10^3$ | 保证答案不超过 $2\times 10^6$ |
| 9~10 | $10^3$ | $10$ | $5\times10^3$ | 无特殊约束 |
| 11~12 | $10^6$ | $10$ | $10^7$ | $R-L\ge999990$ |
| 13~14 | $10^6$ | $10$ | $10^7$ | 无特殊约束 |
| 15~20 | $10^7$ | $100$ | $(\operatorname*{Id}-14)\times 10^7$ | 无特殊约束 |

## 样例 #1

### 输入

```
3
1 8
12 24
1 1000000```

### 输出

```
16
16
947158782```

## 样例 #2

### 输入

```
6
3761870 4957871
2262774 4279409
3027437 5896884
3884310 5021632
3373244 5464739
5063504 5368121```

### 输出

```
953622420
551347610
583188135
582472626
190680894
268824018```

# 题解

## 作者：Schwarzkopf_Henkal (赞：13)

这是道大 nb 题，就在我开始写的时候这还是道紫题，写着写着就变成黑的了。

首先，我们观察题面，发现是求乘积为完全平方数的子集的方案数。然后我们有一个套路，如果这个子集内的所有数的质因数分解结果相加全部都是偶数，那么这一定是个完全平方数，而这个奇偶性的合并跟异或是等价的。然后想到线性基，问题等价于求使得线性基所有位为 $0$ 的方案数，这边可以略微思考一下，或者当成套路记忆，考虑到线性基是一个基，也就是说如果这个基里面有任意一个被选择了，那么最后一定至少有一位不为 $0$，设总集大小 $S_1$，线性基大小（不是最大大小，而是插进去了的个数，也即，**基**的大小） $S_2$，合法方案数为 $2^{S_1-S_2}$ 即 $2$ 的自由元次幂。

也就是说，我们可以处理 $n$ （$R$ 的最大值）以内的所有质数，然后以此建立线性基，暴力做，插入单个数的复杂度为 $\text O(\frac{\pi^2(n)}{\omega})$，用 `bitset` 做少一个 $\omega$ 应该不用多说了。这样，你就可以拿到 $\huge 50$ 分的好成绩！

但是根据质因数分解的性质，我们知道，对于一个数，大于 $\sqrt n$ 的质因数至多只有一个，并且是可以**直接求出来**的，那么，我们每一个数都扫一遍 $[1,n]$ 的所有质数岂不是太浪费了吗？我们可以对于每一个数只扫一遍 $[1,\sqrt n]$ 以内的质数，并且除去这些质因数，如果剩下的结果不为 $1$，那么一定是大于 $\sqrt n$ 的质数，而且是最大的质因数。我们开一个 `unordered_map<int,bitset<455> >` 来专门存储这部分的线性基，插入单个数的复杂度就变成了 $\text O(\frac{\pi^2(\sqrt n)}{\omega})$。这样，你就可以拿到 $\huge 50$ 分的好成绩！没错，根本没有这档部分分！

我们发现，相比于线性基的最大大小，可能的区间长度实际上非常大，也就是说，线性基非常被填满。然后我们从裤裆里掏出一个结论，当区间长度大于一个特定的值的时候，一定有一个方案使得每一个*出现*过的质因数都能够在线性基里面占据一个单独的位置。此处的出现，指的是作为某个数的**因数**出现。

于是我们可以处理出 $n$ 以内的质数并暴力检查它是否*出现*过。用是否有 $\frac{R}{p}\ne\frac{L-1}{p}$ $\text O(1)$ 检查。临界长度是 $\sqrt n$。

隐蔽的坑：我发过一个[帖子](https://www.luogu.com.cn/discuss/show/313613)，如果踩进那个坑里将会只剩下 $70$ 分。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long Mod=998244353;
long long T,L,R,mk[10000005],pr1[114514],pr2[665000],t1,t2,S;
bitset<455>a[455];
unordered_map<int,bitset<455>>mts;
void insert(int u){
    bitset<455>v;
    for(int i=1;i<=t1&&u!=1;i++){
        while(u%pr1[i]==0){
            u/=pr1[i];
            v[i]=!v[i];
        }
    }
    if(u!=1){
        if(!mts.count(u)){
            mts[u]=v;
            S++;
            return;
        }
        v^=mts[u];
    }
    for(int i=t1;i>=1;i--)
        if(v[i]){
            if(!a[i].any()){
                a[i]=v;
                S++;
                return;
            }
            v^=a[i];
        }
}
void clear(){
    S=0;
    mts.clear();
    for(int i=1;i<=t1;i++)
        a[i].reset();
}
long long Pow(long long u,long long v){
    long long res=1;
    while(v){
        if(v&1)
            res=res*u%Mod;
        u=u*u%Mod;
        v>>=1;
    }
    return res;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    for(int i=2;i<=10000000;i++)
        if(!mk[i]){
            if(i<=3200)
                pr1[++t1]=i;
            pr2[++t2]=i;
            if(1ll*i*i<=10000000)
                for(int j=i*i;j<=10000000;j+=i)
                    mk[j]=1;
        }
    cin>>T;
    while(T--){
        clear();
        cin>>L>>R;
        if(R-L+1<=7000){
            for(int i=L;i<=R;i++)
                insert(i);
        }else {
            for(int i=1;i<=t2&&pr2[i]<=R;i++)
                if(R/pr2[i]!=(L-1)/pr2[i])
                    S++;
        }
        cout<<Pow(2,R-L+1-S)<<'\n';
    }
}/*
首先，预处理根号以内的质数，
然后bitset预处理谔谔。
不过，这样不会超时吗？
对啊，它不是要求O(n)吗

看起来是个大nb题但是为什么这个只有紫
好棒/se有50分
*/
```



---

## 作者：tzc_wk (赞：11)

[题面传送门](https://www.luogu.com.cn/problem/P7451)

看到乘积为平方数我们可以很自然地想到[这道题](https://www.luogu.com.cn/problem/CF895C)，具体来说，我们对 $1\sim 10^7$ 中所有质因子标号 $1,2,\cdots,\pi(10^7)$，对于 $x\in[l,r]$ 中的数我们采用试除法对 $x$ 分解质因数并求出每个质因子次数的奇偶性。我们建一个每个元素都是 $0/1$ 的向量 $b$，对于质因子 $p_i$，如果 $p_i$ 在 $x$ 的质因数分解式中次数为奇数，那么 $b$ 的第 $i$ 位为 $1$，否则 $b$ 的第 $i$ 位为 $1$，那么一个集合 $S$ 中所有数的乘积为完全平方数当且仅当 $S$ 中所有数表示的向量在 $\bmod 2$ 意义下的和为零向量。这显然可以通过线性基维护，01 向量的异或运算可用 `bitset` 优化。记线性基大小为 $x$，那么答案为 $2^{r-l+1-x}$。复杂度 $\dfrac{n\pi^2(n)}{\omega}\approx 10^{18}$，无法通过。

考虑优化，注意到对于所有 $>\sqrt{10^7}$ 的因子，它在所有数中至多出现一次。我们考虑只对 $1\sim\sqrt{10^7}$ 中的质数编号——这样的质数的个数大约在 $450$ 左右。记 $mxp_i$ 为 $i$ 最大的质因子。我们对每个 $>\sqrt{n}$ 的质因子 $p$ 额外建一个 `bitset` 维护最大质因子为 $p$ 的数的质因子情况，当我们插入某个数 $x$ 的时候，若 $mxp_x>\sqrt{10^7}$，我们就检验 $mxp_x$ 对应的 `bitset` 是否为空，如果是那就令该 `bitset` 为 $x$ 表示的向量，否则就用 $x$ 表示的向量异或上 $mxp_x$ 对应的 `bitset` 再插入线性基，不难发现该操作与线性基实际上是等价的，只不过将线性基的规模由 $\pi(10^7)\approx 10^6$ 缩小到了 $\pi(\sqrt{10^7})\approx 450$。不过复杂度还是高达 $\dfrac{n\pi^2(\sqrt{n})}{\omega}\approx 10^{10}$，还是无法通过。

下一步就非常考验观察能力了，注意到当区间长度大于某个临界值的时候，线性基是非常容易塞满的，在这种情况下所有在 $[l,r]$ 中出现过的质因子都会被加入线性基中，因此我们只需统计 $[l,r]$ 中有多少个质因子即可，具体来说枚举所有 $[1,r]$ 的质因子 $p$ 并检验是否有 $\lfloor\dfrac{l-1}{p}\rfloor\ne\lfloor\dfrac{r}{p}\rfloor$，累加入答案即可，复杂度 $\pi(10^7)$。那么这个临界值是多少呢？打个表发现临界值大约在 $2\sqrt{n}$ 左右，因此可以像根号分治一样对区间长度 $<2\sqrt{n}$ 的询问跑线性基，对区间长度 $\ge 2\sqrt{n}$ 的询问枚举质因子，这样复杂度就降到了 $6000\times\dfrac{450^2}{64}+6\times 10^6\approx10^7$，即可通过此题。

总之这道题就是线性基+根号分治+猜结论的 nb tea %%%

```cpp
const int MAXN=1e7;
const int MAXB=446;
const int MOD=998244353;
int pw2[MAXN+5],lim=3162;bitset<MAXN+5> vis;
int mxp[MAXN+5],pr[MAXN/10+5],prcnt=0,id[MAXN+5];
bitset<MAXB+5> hi[MAXN/10+5];bool used[MAXN/10+5];
int need[MAXN/10+5],need_n=0;
bitset<MAXB+5> b[MAXB+5];
void sieve(int n){
	for(int i=2;i<=n;i++){
		if(!vis[i]){pr[++prcnt]=i;mxp[i]=i;id[i]=prcnt;}
		for(int j=1;j<=prcnt&&pr[j]*i<=n;j++){
			vis[pr[j]*i]=1;mxp[pr[j]*i]=max(mxp[i],pr[j]);
			if(i%pr[j]==0) break;
		}
	}
}
int cnt=0;
void ins(bitset<MAXB+5> x){
	for(int i=MAXB;i;i--) if(x[i]){
		if(!b[i].any()){b[i]=x;return;}
		else x^=b[i];
	} cnt++;
}
void add(int x){
	int mx=mxp[x];if(mx>=lim) x/=mx;
	bitset<MAXB+5> bt;
	while(x!=1){
		int v=mxp[x],par=0;
		while(x%v==0) x/=v,par^=1;
		bt[id[v]]=par;
	}
	if(mx>=lim){
		if(used[id[mx]]) bt^=hi[id[mx]];
		else{
			used[id[mx]]=1;hi[id[mx]]=bt;
			need[++need_n]=id[mx];
			return;
		}
	} ins(bt);
}
void solve(){//remember to clear it at last
	int l,r;scanf("%d%d",&l,&r);
	if(r-l+1<=7000){
		for(int i=l;i<=r;i++) add(i);printf("%d\n",pw2[cnt]);
		for(int i=1;i<=need_n;i++) used[need[i]]=0,hi[need[i]].reset(),need[i]=0;
		need_n=0;for(int i=1;i<=MAXB;i++) b[i].reset();cnt=0;
	} else {
		int tot=r-l+1;
		for(int i=1;i<=prcnt;i++){
			if(pr[i]>r) break;
			if((l-1)/pr[i]!=r/pr[i]) --tot;
		} printf("%d\n",pw2[tot]);
	} 
}
int main(){
	pw2[0]=1;for(int i=1;i<=MAXN;i++) pw2[i]=2*pw2[i-1]%MOD;
	sieve(MAXN);int qu;scanf("%d",&qu);while(qu--) solve();
	return 0;
}
```



---

## 作者：whiteqwq (赞：8)

[P7451 [THUSCH2017] 杜老师](https://www.luogu.com.cn/problem/P7451)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1786200)

## 题意

给定$T$组数据，每组数据询问区间$[L,R]$中选出乘积为完全平方数的子集数量。（$1\leqslant T\leqslant 100,1\leqslant L\leqslant R\leqslant 10^7,\sum (R-L+1)\leqslant 6\times 10^7$）

## 分析

首先看到乘积为完全平方数的子集数量完全可以想到线性基（详见[CF895C Square Subsets](https://www.luogu.com.cn/problem/CF895C)）。

那么我们有一个初步想法：把是否含有某个质数的奇次幂压成一个二进制数（用$\text{bitset}$存储），然后对这些二进制数建立一个线性基，求$2$的自由元数量次幂。

想法很好，但时间复杂度为$O(\sum_T \sum_{i=L}^R\frac{\pi(maxR)^2}{\omega})$，空间复杂度为$O(\frac{\pi(maxR)^2}{\omega})$，均会超过限制。（$\pi(x)$为不超过$x$的质数数量，且$\pi(x)\sim\frac{x}{\ln(x)}$）

考虑根号分治，设$N$为$maxR$，那么$\leqslant\sqrt{N}$的质数最多只有$453$个。

枚举$[L,R]$中每一个数，进行质因数分解，不难发现$>\sqrt{N}$的质因数最多一个，且是一次幂，那么我们可以把$\leqslant\sqrt{N}$的质数的$\text{bitset}$与$>\sqrt{N}$的质数的$\text{bitset}$分开处理。

对于$\leqslant\sqrt{N}$的质数，我们在质因数分解的时候处理出$\text{bitset}$，然后插入线性基。

对于$>\sqrt{N}$的质数，我们发现最多会有$R-L+1$个有用的质数，每次遇到某个质数才建立某个线性基，那么只会建出很少的线性基，且每次插入的复杂度是$O(1)$的。

如果设$len=R-L+1$，那么时间复杂度被我们优化到了$O(\sum_T len(\log len+\frac{\pi(\sqrt{N})^2}{\omega})$，空间复杂度则是$O(\frac{N\pi(\sqrt{N})}{\omega})$，仍然不能通过本题。

这里就要用到一个很玄妙的结论：如果区间长度大于$2\sqrt{N}$，那么区间里的质数一旦出现就会出现在线性基内，然后我们枚举所有质数判断是否在这个区间内出现过就好了。

时间复杂度：$O(T\pi(N)+T\sqrt{N}(\log\sqrt{N}+\frac{\pi(\sqrt{N})^2}{\omega}))$，空间复杂度：$O(N+\frac{\sqrt{N}\pi(\sqrt{N})}{\omega})$。

时空复杂度分析有点问题，请轻喷。

## 代码
```
#include<stdio.h>
#include<bitset>
using namespace std;
const int maxn=10000005,maxm=455,mod=998244353,t=3200;
int T,A,B,cnt,tp;
int sump[maxn],minn[maxn],ord[maxn],p[maxn],a[maxn],L[maxn],tmpord[maxn];
bitset<maxm>tmp;
bitset<maxm>b[maxm],l[maxm],val[t<<1];
void sieve(int n){
	p[1]=1,sump[1]=0,minn[1]=1;
	for(int i=2;i<=n;i++){
		if(p[i]==0)
			a[++cnt]=i,ord[i]=cnt,minn[i]=i;
		for(int j=1;j<=cnt;j++){
			if(i*a[j]>n)
				break;
			p[i*a[j]]=1,minn[i*a[j]]=minn[i];
			if(i%a[j]==0)
				break;
		}
		sump[i]=sump[i-1]+(p[i]^1);
	}
}
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod,b>>=1;
	}
	return res;
}
int insert(bitset<maxm>b){
	for(int i=tp;i>=1;i--){
		if(b[i]==0)
			continue;
		if(l[i].any()==false){
			l[i]=b;
			return 1;
		}
		b^=l[i];
	}
	return 0;
}
int main(){
	sieve(10000000);
	for(tp=1;a[tp]<=t;tp++);
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&A,&B);
		if(B-A+1>2*t){
			int res=B-A+1;
			for(int i=1;i<=cnt&&a[i]<=B;i++)
				if(B/a[i]!=(A-1)/a[i])
					res--;
			printf("%d\n",ksm(2,res));
			continue;
		}
		int res=0,tmps=0;
		for(int i=1;i<=tp;i++)
			l[i].reset();
		for(int i=A;i<=B;i++){
			int k=i,rec=minn[i];
			if(rec>t)
				k/=rec;
			tmp.reset();
			while(k>1){
				int w=minn[k],cnt=0;
				while(k%w==0)
					k/=w,cnt^=1;
				tmp[ord[w]]=cnt;
			}
			if(rec>t){
				if(tmpord[rec]==0){
					tmpord[rec]=++tmps,val[tmps]=tmp;
					continue;
				}
				tmp^=val[tmpord[rec]];
			}
			res+=(insert(tmp)^1);
		}
		for(int i=A;i<=B;i++)
			tmpord[minn[i]]=0;
		printf("%d\n",ksm(2,res));
	}
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：2)

假设 $n=R$。

我们可以把第 $i$ 个质数 $p_i$ 视作一个二进制位，一个数 $n$ 对应一个二进制数 $f(n)$，其中 $f(n)$ 的第 $i$ 位为 $1$ 当且仅当 $V_p(n)$ 是奇数（$V_p(n)$ 表示正整数 $n$ 中含 $p$ 因子的数量）。

那么一个集合 $S$ 是合法的当且仅当：$\text{XOR}_{s\in S}f(s)=0$，这个部分可以通过线性基解决，时间复杂度是 $\mathcal O(\dfrac{n\times\pi(n)}{w})$

这样子显然过不去，我们根据 2022 联合省选 D2T1 的套路，我们把 $>\sqrt n$ 的质因子单独处理（这样的质因子只有一个），复杂度就能做到 $\mathcal O(\dfrac{n\times \pi(\sqrt n)}{w})$。

我们发现合适不能消掉 $n$ 这个大头，我们充分开发人类智慧，发现 $R-L+1$ 太大的时候（大概是 $2\sqrt n$ 的时候）每个质数位的线性基都会被塞满，我们只需要统计 $L\sim R$ 这个区间出现的质因子个数。

复杂度可以做到 $\mathcal O(\dfrac{\sqrt n\times \pi(\sqrt n)}{w})$，随便过。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=1e7+5;
const int B=500;
const int MOD=998244353;
bool vis[MAXN];int d[MAXN],pr[MAXN],id[MAXN],m=0;
ll ksm(ll a,int b){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}
bitset<B> bs[B];
void init(){
	for(int i=2;i<MAXN;i++){
		if(!vis[i]) pr[++m]=i,id[i]=m;
		for(int j=1;pr[j]*i<MAXN&&j<=m;j++){
			d[pr[j]*i]=pr[j];
			vis[pr[j]*i]=true;
			if(i%pr[j]==0) break;
		}
	}
}
void solve(){
	int l,r;cin>>l>>r;
	if(r-l+1>=10000){
		int cnt=0;
		for(int i=1;i<=m;i++) if(r/pr[i]!=(l-1)/pr[i]) cnt++;
		cout<<ksm(2,r-l+1-cnt)<<'\n';
	}else{
		unordered_map<int,bitset<B> > mp;
		for(int i=1;i<B;i++) bs[i].reset();
		int cnt=0;
		for(int i=l;i<=r;i++){
			bitset<B> b;
			int n=i;
			for(int j=1;j<B;j++){
				while(n%pr[j]==0) n/=pr[j],b[j]=1-b[j];
			}
			if(n>1){
				if(mp.count(n)) b^=mp[n];
				else {mp[n]=b,cnt++;continue;}
			}
			for(int j=B-1;j>=1;j--) if(b[j]){
				if(bs[j].any()) b^=bs[j];
				else {cnt++,bs[j]=b;break;}
			}
		}
		cout<<ksm(2,r-l+1-cnt)<<'\n';
	}
}
int main(){
	ios::sync_with_stdio(false);
	// freopen("dls.in","r",stdin);
	// freopen("dls.out","w",stdout);
	init();
	int _;cin>>_;
	while(_--) solve();
	return 0;
}
```

---

## 作者：Butterfly_qwq (赞：1)

以下设 $n=\max R,O(\pi(n))=O(\frac{n}{\log n})$。

平方数乍一看没思路，仔细想想就是所有数的质因子都是偶数次幂，先分解质因数。

然后乍一看还是没思路，但是我们可以发现：

两个数乘起来质因子相加，在模 $2$ 意义下就是异或。

两个数相乘就是所有质因子对应的位异或，平方数就是异或和为 $0$。

异或和为 $0$ 的子集个数就是一个经典题了，肯定需要建立异或线性基。

下设元素个数为 $a=R-L+1$，线性基大小为 $b$。

下述证明若只想看结论请划至下一个分割线处。

---

对于 $a_0,a_1,\dots,a_{n-1}\in\mathbb F_2^n$，设 $B=\{2^x|x\in[0,n)\cap\mathbb Z\}$

设 $\mathbf f$ 是满足 $\mathbf f(2^i)=a_i$ 所确定的唯一线性映射。

答案即为 $|\ker \mathbf{f}|=2^{\dim \ker \mathbf{f}}=2^{a-\dim \operatorname{Im}\mathbf{f}}=2^{a-\dim\operatorname{span}\{a_0,a_1,\dots,a_{n-1}\}}=2^{a-b}$。

---

因此异或和为 $0$ 的子集个数为 $2^{a-b}$。

只需要解决插入问题就可以了。

若直接暴力解决，时间复杂度为 $O(\frac{n^3}{\log^2n})$ 可以拿到 $40$ 分。

容易想到 bitset 优化一下，除个 $\omega$ 就可以获得 $50$ 分。

考虑优化，你发现大于 $\sqrt{n}$ 的约数最多一个，那么把单独的约数单独存，剩下的约数正常存就行，时间复杂度为 $O(\frac{n^2}{\omega\log^2n})$，消掉了一个 $n$。这样就可以拿到……欸？怎么还是 $50$ 分？

想想也是，这个优化有点过于简单了一点，不给分也正常。

然后我们小胆猜测在区间长度大于一个值的时候，线性基一定满秩。

通过证明这个值为 $2\sqrt{n}$。

不想看证明的请划至下一个分割线处。

---

考虑线性基不满秩的话，必将满足 $\exist p,q\in\mathbb{P},p<q,\forall L\le i\le R,p|i,s.t.\ q|i$。

若 $R-L+1>2\sqrt{n}$：

设 $x=kpq$，则 $p\le\sqrt{\frac{n}{k}}
\le\sqrt{n}$。$2p\le2\sqrt{n}\le R-L+1$。

则必有 $L\le x-p\le R$ 或 $L\le x+p\le R$，这里设其为后者，前者类似。

$x+p=p(kq+1)$，则 $p\mid x+p$ 而 $q\nmid x+p$，与假设不符！

所以有：$R-L+1\le2\sqrt{n}$。

---

然后如果区间小于这个值就直接按原方法做，大于的话考虑直接大力枚举质因子，即检验 $[1,r]$ 中的质数 $p$，判断是否有 $\lfloor\frac{l-1}{p}\rfloor<\lfloor\frac{r}{p}\rfloor$ 即可。

时间复杂度为 $O(\frac{n\sqrt{n}}{\omega\log^2n})$。

其实这题时限开 500ms 就行，不用 5s。因为我的程序第一次提交（没卡常）可以跑到 300ms 以内。

![](https://cdn.luogu.com.cn/upload/image_hosting/0bsd9ihi.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5,M=1e6+5,P=450,mod=998244353;
int t,l,r,pt,cnt,ans,pr[M],p2[N],mxp[N],id[N],vis[M],f[N],p[M];
bitset<P>bs[M],c[P];
void getprime()
{
	for(int i=2;i<N;i++)
	{
		if(!f[i]){pr[++pt]=i;mxp[i]=i;id[i]=pt;}
		for(int j=1;j<=pt&&i*pr[j]<N;j++)
		{
			f[i*pr[j]]=1;mxp[i*pr[j]]=max(mxp[i],pr[j]);
			if(i%pr[j]==0)break;
		}
	}
}
void insert(bitset<P> x)
{
	for(int i=P;i;i--)if(x[i])
	{
		if(!c[i].any()){c[i]=x;return;}
		x^=c[i];
	}
	ans++;
}
void Insert(int x)
{
	int z=mxp[x];
	if(z>=3162)x/=z;
	bitset<P>b;
	while(x!=1)
	{
		int z=mxp[x],f=0;
		while(!(x%z)){x/=z;f^=1;}
		b[id[z]]=f;
	}
	if(z>=3162)
	{
		if(vis[id[z]])b^=bs[id[z]];
		else
		{
			vis[id[z]]=1;
			bs[id[z]]=b;
			p[++cnt]=id[z];
			return;
		}
	}
	insert(b);
}
int main()
{
	p2[0]=1;
	for(int i=1;i<N;i++)p2[i]=(p2[i-1]<<1)%mod;
	getprime();
	cin>>t;
	while(t--)
	{
		cin>>l>>r;
		if(r-l+1<=6500)
		{
			for(int i=l;i<=r;i++)Insert(i);
			cout<<p2[ans]<<'\n';
			for(int i=1;i<=cnt;i++)
			{
				vis[p[i]]=0;
				bs[p[i]].reset();
				p[i]=0;
			}
			cnt=ans=0;
			for(int i=1;i<=P;i++)c[i].reset();
		}
		else
		{
			ans=r-l+1;
			for(int i=1;i<=pt;i++)
			{
				if(pr[i]>r)break;
				if((l-1)/pr[i]<r/pr[i])ans--;
			}
			cout<<p2[ans]<<'\n';ans=0;
		}
	}
}
```

---

## 作者：MerlinLee (赞：1)

一个数是完全平方数，等价于它的每个质因子的次数都是偶数。

如果我们可以把每个数质因数分解了，由于一个数的贡献只需要考虑它的每种质因数次数的奇偶性，所以就可以被表示为一个二进制数。

这样一来，一个非空子集的乘积为完全平方数，当且仅当其中数对应的二进制数异或和为 0。

要判断有多少数异或和为 0 就很简单，只要把所有数插入线性基，那么线性基外的每个数都可以表示为线性基中若干数的异或和，进而线性基外的每个非空集合都可以表示为线性基中若干数的异或和。

所以假设线性基外有 $t$ 个数，则答案就是 $2^{t-1}$。

但是对于此题，值域为 $10^7$，不可能把每个数暴力插入线性基，一定需要一些优化。

根号分治，
令 $n$ 为值域上界 $10^7$。

显然，一个大于 $\sqrt n$ 的质因子最多只可能存在一个。

因此，我们最初的线性基只需要记录 $\sqrt n$ 以内的所有质因子（大约 450 个）。

插入一个数时如果它存在一个新的大因子就专门为它设一个特殊位，把它扔那里。否则，把它和它的大因子对应的特殊位异或一下就把大因子消掉了，且根据我们的操作它不可能存在其他特殊位为 1，所以接下来就可以直接把它插入普通的线性基了。

但由于 $l\le r\le10^7$，即便这样似乎也完全不可能过。

但随便想想就知道，这个线性基是很容易被塞满的，实际上可以认为当 $r-l+1\ge2\sqrt n$ 时，所有出现过的质因子都将存在于线性基中，此时只要枚举所有质数判断一下是否在区间内即可。


```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define ll long long
using namespace std;
const int N=10000000;
const int SN=3200;
const int T=450;
const ll X=998244353;
int L,R,pw[N+5],St[N+5];bitset<T+5> s,S[T+5],G[2*SN+5];
int Pt,P[N+5],id[N+5];
inline void Sieve() 
{
	for(RI i=2,j;i<=N;i++)//线性筛求质数
	  for(!P[i]&&(P[++Pt]=i),j=1;j<=Pt and i*P[j]<=N;++j) 
	    if(P[i*P[j]]=1,!(i%P[j])) 
		  break;
}
inline bool Ins(bitset<T+5> x) 
{	for(RI i=1;i<=T;i++)//插入线性基
	  if(x.test(i)) 
	  {
	  	  if(S[i].any()) 
			x^=S[i];
		  else 
		    return S[i]=x,1;
	  }
	return 0;
}
int main()
{
	RI i,j;
	for(Sieve(),i=1;i<=T;i++) 
	  id[P[i]]=i;//给小质数标号
	RI Tt,x,y,t,TP;
	for(pw[0]=i=1;i<=N;i++) 
	  pw[i]=2LL*pw[i-1]%X;
	scanf("%d",&Tt);
	while(Tt--)
	{
		if(scanf("%d%d",&L,&R),R-L+1>2*SN)//如果区间长度超过2sqrt(n)
		{
			for(t=R-L+1,i=1;i<=Pt and P[i]<=R;i++) 
			  ((L-1)/P[i])^(R/P[i]) and --t;
			  printf("%d\n",pw[t]);
			  continue;
		}//枚举每个质因子判断是否出现过
		for(i=1;i<=T;i++) 
		  S[i].reset();
		for(t=TP=0,i=L;i<=R;i++)
		{
			for(s.reset(),x=i,j=1;j<=Pt and P[j]*P[j]<=x;j++) 
			{
				y=0;
				while(!(x%P[j])) 
				  x/=P[j],y^=1;
				  y and (s.set(j),0);
			}//质因数分解
			x^1 and x<=P[T] and (s.set(id[x]),x=1);//如果剩余的是小质数
			if(x^1) 
			{
				if(!id[x]) 
				{
					St[id[x]=++TP]=x,G[TP]=s;
					continue;
				}s^=G[id[x]];
			}
			!Ins(s) and ++t;//如果剩余大质数和特殊位搞一搞，然后插入普通线性基
		}
		printf("%d\n",pw[t]);
		while(TP) 
		  id[St[TP]]=0,G[TP--].reset();
	}return 0;
}
```

---

## 作者：Acoipp (赞：0)

## 分析

看到平方质数我们就可以想到是根号分治，设 $K=\sqrt{10^7}$，那么一个数分解之后最多含有一个大于 $K$ 的质数。

又因为平方是相当于指数对 $2$ 取模，我们很自然地想到是线性基。

我们就可以对于小于等于 $K$ 的质数开一个 `bitset`，第 $i$ 位表示分解之后是否含有第 $i$ 个质数，然后对于剩下的大于 $K$ 的所有质数都开一个 `bitset`，因为一个数不可能含有多于 $2$ 个的质数大于 $K$，所以我们不需要记录大于 $K$ 的质数被选没有，于是直接异或就可以了。

那么算法流程就是遍历 $l \sim r$ 中的所有数，然后对这些数进行分解，如果这个数有大于 $K$ 的质数，那么要先更新这个质数所代表的 `bitset`，然后枚举小于等于 $K$ 的质数被选的情况，按照线性基的基本操作即可。

那么答案是多少呢？注意到线性基中可以表出所有原序列的数字异或的结果，那么我们从剩下没在线性基里面的数字中随便选择一些数异或起来，总能在线性基里面找到一个集合使其异或和等于选择的数的异或和，两者相异或就变成了 $0$，设有 $k$ 个数在线性基里面，一共有 $n$ 个数，答案就是 $2^{n-k}$。

这样的话，再增加一点剪枝技巧（`bitset` 的 `_Find_first` 和 `_Find_next` 函数可以帮助查找第一个 $1$ 和下一个 $1$ 的位置），或者线性基满了之后直接返回即可。

洛谷和 LOJ 均可通过，但是对于某些 OJ 不可以通过，于是我们需要找一些性质。

剪枝中有一个很引人注目的点就是线性基什么时候会满？打表可以得出大概在 $r-l+1 >10^4$ 的时候线性基是会跑满的，也就是 $l \sim r$ 中出现过的质因子都会贡献答案，所以线性基中的元素个数就是 $l \sim r$ 中质因子的数量，于是暴力枚举 $1 \sim r$ 中的质数判断是否在这之中出现过即可，这样就能跑得很快了。

## 时间复杂度

当 $r-l>10^4$ 时，循环次数大概是 $\pi(10^7)$。

当 $r-l \le 10^4$ 时，循环次数大概是 $\dfrac{10^7}{w}$，显然可过。
## 代码

代码如下：

```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define N 10000005
#define M 5005
using namespace std;
int T,K,l,r,tot,i,j,poss;
int vis[N],vis2[N],vis3[N],pri[N],id[N],belong[N];
int qmi(int a,int b,int p){
	int res = 1%p,t=a;
	while(b){
		if(b&1) res=1ll*res*t%p;
		t=1ll*t*t%p;
		b>>=1;
	}
	return res;
}
struct xxj{
	bitset<450> p[450],pr[700005];
	int pos[N],now,now1,now2,len1,len2;
	bool vis[700005];
	inline void clear(){
		now = 0,now1 = 0,now2 = 0;
		len1 = poss,len2 = tot-poss;
		for(int i=poss-1;i>=0;i--) p[i]=0,pos[i]=0; 
		for(int i=1;i<=len2;i++) pr[i]=0,vis[i]=0;
	}
	inline void insert(bitset<450> x,int belong){
		if(belong){
			if(!vis[belong]){
				pr[belong] = x,vis[belong] = 1,now++,now2++;
				return ;
			}
			x = (x^pr[belong]);
		} 
		if(now1==len1) return ;
		for(int i=x._Find_first();i<poss;i=x._Find_next(i)){
			if(x[i]){
				if(p[i]==0){p[i]=x;now++;now1++;return;}
				x = (x^p[i]);
			}
		}
		return;
	}
}a;
inline bitset<450> get(int x){
	bitset<450> cnt = 0;
	for(int i=x;i>1;i/=vis[i]) if(vis3[i]<=K) cnt[id[vis3[i]]]=vis2[i];
	return cnt;
}
inline int solve(int l,int r){
	if(r-l+1<=6e3){
		a.clear();
		for(int i=l;i<=r;i++) a.insert(get(i),belong[i]);
		return qmi(2,r-l+1-a.now,mod);
	}
	else{
		int cnt = 0;
		for(int i=1;i<=tot;i++){
			if(pri[i]>r) break;
			if(r/pri[i]!=(l-1)/pri[i]) cnt++;
		}
		return qmi(2,r-l+1-cnt,mod);
	}
}
int main(){
	ios::sync_with_stdio(false);
	for(i=2;i<=1e7;i++){
		if(!vis[i]) pri[++tot] = i,id[i] = tot-1,vis[i] = vis3[i] = i,vis2[i] = 1;
		else id[i] = -1;
		for(j=1;j<=tot;j++){
			if(i*pri[j]>1e7) break;
			vis3[i*pri[j]] = pri[j];
			if(i%pri[j]==0){
				vis[i*pri[j]] = vis[i]*pri[j];
				vis2[i*pri[j]] = (vis2[i]^1);
				break;
			}
			else{
				vis[i*pri[j]] = pri[j];
				vis2[i*pri[j]] = 1;
			}
		}
	}
	K=sqrt(1e7);
	for(i=1;i<=tot;i++) if(pri[i]<=K) poss=i;
	for(i=poss+1;i<=tot;i++) for(j=pri[i];j<=1e7;j+=pri[i]) belong[j] = i-poss;
	cin>>T;
	while(T--){
		cin>>l>>r;
		cout<<solve(l,r)<<endl;
	}
	return 0;
}
/*
Input:
3
1 8
12 24
1 1000000

Output:
16
16
947158782

Input2:
6
3761870 4957871
2262774 4279409
3027437 5896884
3884310 5021632
3373244 5464739
5063504 5368121

Output2:
953622420
551347610
583188135
582472626
190680894
268824018 
*/
```

---


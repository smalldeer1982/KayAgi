# [CQOI2017] 小 Q 的表格

## 题目描述

小 Q 是个程序员。

作为一个年轻的程序员，小 Q 总是被老 C 欺负，老 C 经常把一些麻烦的任务交给小 Q 来处理。每当小 Q 不知道如何解决时，就只好向你求助。

为了完成任务，小 Q 需要列一个表格，表格有无穷多行，无穷多列，行和列都从 $1$ 开始标号。为了完成任务，表格里面每个格子都填了一个整数，为了方便描述，小 Q 把第 $a$ 行第 $b$ 列的整数记为 $f(a, b)$。为了完成任务，这个表格要满足一些条件：

1. 对任意的正整数 $a, b$，都要满足 $f(a, b) = f(b, a)$；
2. 对任意的正整数 $a, b$，都要满足 $b \times f(a, a + b) = (a + b) \times f(a, b)$。

为了完成任务，一开始表格里面的数很有规律，第 $a$ 行第 $b$ 列的数恰好等于 $a \times b$，显然一开始是满足上述两个条件的。为了完成任务，小 Q 需要不断的修改表格里面的数，每当修改了一个格子的数之后，为了让表格继续满足上述两个条件，小 Q 还需要把这次修改能够波及到的全部格子里都改为恰当的数。由于某种神奇的力量驱使，已经确保了每一轮修改之后所有格子里的数仍然都是整数。为了完成任务，小 Q 还需要随时获取前 $k$ 行前 $k$ 列这个有限区域内所有数的和是多少，答案可能比较大，只需要算出答案 ${} \bmod 1,000,000,007$ 之后的结果。

## 说明/提示

**【样例解释 #1】**

一开始，表格的前 $3$ 行前 $3$ 列如图中左边所示。前 $2$ 次操作后表格没有变化，第 $3$ 次操作之后的表格如右边所示。

```cpp
1 2 3     2  4  6
2 4 6     4  4 12
3 6 9     6 12  9
```

**【数据范围】**

对于 $100 \%$ 的测试点，$1 \le m \le {10}^4$，$1 \le a, b, k \le n \le 4 \times {10}^6$，$0 \le x \le {10}^{18}$。

![](https://cdn.luogu.com.cn/upload/pic/5012.png)


## 样例 #1

### 输入

```
3 3
1 1 1 2
2 2 4 3
1 2 4 2
```

### 输出

```
9
36
14
```

## 样例 #2

### 输入

```
4 125
1 2 4 8
1 3 9 27
1 4 16 64
1 5 25 125
```

### 输出

```
2073
316642
12157159
213336861
```

# 题解

## 作者：zhoutb2333 (赞：14)

首先题目里说$f(a,b)=f(b,a)$，说明我们只用维护半个棋盘的信息就够了。

然后$b *f(a,a+b)=(a+b)*f(a,b)$这个式子我们化成$\frac{f(a,b)}{a*b}=\frac{f(a,a+b)}{a*(a+b)}$

那么就有$\frac{f(a,b)}{a*b}=\frac{f(a,a \% b)}{a*(a \% b)}$

发现这个形式很像辗转相除法求$\gcd$的过程，所以我们如果一直这样递归下去的话可以得到$\frac{f(a,b)}{a*b}=\frac{f(\gcd(a,b),\gcd(a,b))}{\gcd^2(a,b)}$。

即$f(a,b)=\frac{a*b}{d^2}*f(d,d)$，令$d=\gcd(a,b)$

发现如果修改值的话，$\gcd$不同的位置的$f$值相互独立。也就是说修改一个位置$(a,b)$的值后有且仅有$\gcd(x,y)=d$的$(x,y)$位置的$f$值会跟着变化。（这句话对求答案没什么用，是为方便理解写的）

然后回去看$ans$，

$$\sum \limits ^{k}_{i=1}\sum \limits ^{k}_{j=1} f(i,j)$$

$$= \sum \limits ^{k}_{d=1} f(d,d) \sum \limits _{d|i} \sum \limits _{d|j} \frac{i*j}{d^2} \varepsilon(\gcd(i,j)==d)$$

$$= \sum \limits ^{k}_{d=1} f(d,d) \sum \limits^{\lfloor \frac{k}{d} \rfloor} _{i=1} \sum \limits^{\lfloor \frac{k}{d} \rfloor} _{j=1} i*j* \varepsilon(\gcd(i,j))$$

所以说我们可以根据$k/d$分块，这样需要动态维护$f(i,i)$的前缀和。观察到$n$为
$4*10^6$而$m$为$10^4$，所以我们大概需要一个数据结构，支持单点修改$O(\sqrt{n})$，查前缀和$O(1)$。分块正好可以做到这个。具体就是块内每个位置维护本块内的前缀和，然后每个块末尾维护一下总的前缀和，这样查询的时候等于上一块的总答案加上这个位置的块答案。修改暴力重构，只会影响到$\sqrt{n}$左右个值。

设$G(x)=\sum \limits^{x} _{i=1} \sum \limits^{x} _{j=1} i*j* \varepsilon(\gcd(i,j))$。那么根据$\sum \limits ^{x}_{i=1}i*\varepsilon(\gcd(i,x))=\frac{x*(\varphi(x)+\varepsilon(x))}{2}$，有$G(x)=\sum \limits ^{x}_{i=1} i^2 *\varphi(i)$（考虑$G(x)$比$G(x-1)$多了什么），这个东西可以线性筛预处理。（然而蒟蒻这一步只会$n \sqrt{n}$的算法导致做不出来了..QAQ）

注意不要爆$int$

代码略丑，维护块的方式比较清奇
``` cpp
%:pragma GCC optimize(2)
#include<bits/stdc++.h>
#define maxn 4000010
#define ll long long
using namespace std;

int pri[maxn/8],phi[maxn],pricnt=0;
int bel[maxn],bpos[2010],epos[2010],size,tn,n,q;
//bel为每个位置属于哪个块，bpos,epos为每个块的初始位置和末尾位置
ll val[maxn],ans[maxn],ANS[2010],f[maxn];
//ans为块内前缀和，ANS为总前缀和
const ll p=1e9+7;
bool notpri[maxn];
inline int gcd(int x,int y){
    if(!x||!y)
        return x|y;
    return x>y?gcd(y,x%y):gcd(x,y%x);
}
inline ll sum(int x){
    if(!x)
        return 0;
    return (ANS[bel[x]-1]+ans[x])%p;
}
inline ll pw(ll a,ll b){
    ll ret=1;
    while(b){
        if(b&1)
            ret=ret*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ret;
}
void init(){
    phi[1]=1;
    for(int i=2;i<=n;i++){
        if(!notpri[i]){
            pri[++pricnt]=i;
            phi[i]=i-1;
        }
        for(int j=1;j<=pricnt;j++){
            if(i*pri[j]>n)
                break;
            notpri[i*pri[j]]=true;
            if(i%pri[j]==0){
            	phi[i*pri[j]]=phi[i]*pri[j];
            	break;
            }
            phi[i*pri[j]]=phi[i]*(pri[j]-1);
        }
    }
    for(int i=1;i<=n;i++)
        f[i]=(f[i-1]+1LL*phi[i]*i%p*i%p)%p;
}
int main(){
    scanf("%d%d",&q,&n),size=sqrt(n),init();
    for(int i=1;i<=n;i++){
        bel[i]=i/size+1;
        if(bel[i]>bel[i-1])	
            bpos[bel[i]]=i,epos[bel[i]-1]=i-1;
    }
    tn=bel[n],epos[tn]=n;
    for(int i=1;i<=n;i++)
        val[i]=1LL*i*i%p;
    for(int i=1;i<=tn;i++){
        for(int j=bpos[i];j<=epos[i];j++)
            ans[j]=(ans[j-1]*(j>bpos[i])+val[j])%p;
        ANS[i]=(ANS[i-1]+ans[epos[i]])%p;
    }
    for(int i=1;i<=q;i++){
        int a,b,k,d,pos;
        ll x,Ans=0;
        scanf("%d%d%lld%d",&a,&b,&x,&k),x%=p,d=gcd(a,b);
        val[d]=x*d%p*d%p*pw(1LL*a*b%p,p-2)%p;
        for(int j=d;j<=epos[bel[d]];j++)
            ans[j]=(ans[j-1]*(j>bpos[bel[d]])+val[j])%p;
        for(int j=bel[d];j<=tn;j++)
            ANS[j]=(ANS[j-1]+ans[epos[j]])%p;
        for(int j=1;j<=k;j=pos+1){
            pos=k/(k/j);
            Ans=(Ans+f[k/j]*(sum(pos)-sum(j-1)+p)%p)%p;
        }	 
        printf("%lld\n",Ans);
    }
    return 0;
}
```

---

## 作者：asuldb (赞：13)

[题目](https://www.luogu.org/problemnew/show/P3700)

神仙题，神仙题

这是一道很适合盯着发呆的题目

看到这个规律

$$
f(a,b)=f(b,a)
$$

$$
b\times f(a,a+b)=(a+b)\times f(a,b)
$$

这也没什么规律啊

于是自闭了

盯着发呆一个小时之后发现，这个$f(a,a+b)$和$f(a,b)$有关系

因为修改$(a,b)$就一定会影响$(a,a+b)$，同时也会影响$(a,a+2b)...$

停

$$
gcd(a,a+b)=gcd(a+b,a)=gcd(a,a+b-a)=gcd(a,b)
$$

这不是更相减损术吗

于是我们得出了第一个结论

**修改$a,b$这个值只会影响$gcd(x,y)=gcd(a,b)$的$f(x,y)$的值**

但是这样我们还是没有什么办法来维护啊，毕竟矩阵那么大，我们修改一次影响的数那么多

我们大胆猜想格子的值存在某种关系，如果$gcd(a,b)=d$，那么$f(a,b)$肯定和$f(d,d)$存在某种关系

尝试去求一下这个关系

$$f(d,d)\times 2d=f(d,2d)\times d$$

$$
f(d,2d)\times 3d=f(d,3d)\times 2d
$$

显然$f(d,kd)=\frac{k}{(k-1)}f(d,(k-1)d)=k\times f(d,kd)$

显然纵坐标也会有这样的性质

于是$f(k_1d,k_2d),k_1\perp  k_2$，就会有$k_1\times k_2\times f(d,d)=f(k_1d,k_2d)$

其实也就是这样

$$f(a,b)=\frac{a\times b}{(a,b)^2}f((a,b),(a,b))$$

考虑把$f(a,b)$写成$\frac{ab}{d^2}f(d,d)$

于是我们只需要记录$f(d,d)$的值了，这样就可以处理修改操作了

接下来把$f(d,d)$简记做$f(d)$

现在我们要求的柿子是

$$\sum_{i=1}^n\sum_{j=1}^n\frac{i\times j}{(i,j)^2}f((i,j)$$

考虑一下枚举$gcd$

$$\sum_{d=1}^nf(d)\sum_{i=1}^{\left \lfloor \frac{n}{d} \right \rfloor}\sum_{j=1}^{\left \lfloor \frac{n}{d} \right \rfloor}[(i,j)=1]i\times j$$

那个除以$(i,j)^2$消失了是因为我们后面乘上的是$i,j$，本来就是都除以$d$了的

之后只要记住一条，千万别反演就好了

我们能通过欧拉函数把上面的柿子写成这个样子

$$\sum_{d=1}^nf(d)\sum_{i=1}^{\left \lfloor \frac{n}{d} \right \rfloor}i^2\varphi(i)$$

至于为什么，我们需要这个柿子

$$\sum_{i=1}^n[(i,n)=1]i=\frac{n\varphi(n)+[n=1]}{2}$$

至于这个柿子这么来的，我们证明一下

$$\sum_{i=1}^n[(i,n)=1]i=\sum_{i=1}^ni\sum_{d|i,d|n}\mu(d)$$

交换一下求和符号

$$=\sum_{d|n}\mu(d)\sum_{d|i}i=\sum_{d|n}\mu(d)\sum_{i=1}^{\frac{n}{d}}i\times d$$

$$=\sum_{d|n}\mu(d)d\sum_{i=1}^{\frac{n}{d}}i=\sum_{d|n}\mu(d)d\frac{(\frac{n}{d}+1)\frac{n}{d}}{2}$$

$$=\frac{n}{2}\sum_{d|n}\mu(d)(\frac{n}{d}+1)=\frac{n}{2}(n\sum_{d|n}\frac{\mu(d)}{d}+\sum_{d|n}\mu(d))$$

我们现在需要两条很基础的结论

$$\sum_{d|n}\mu(d)=[n=1],\sum_{d|n}\frac{\mu(d)}{d}=\frac{\varphi(n)}{n}$$
这里就不再证明了

根据上面那条结论我们有

$$\sum_{i=1}^n\sum_{j=1}^n[(i,j)=1]i\times j=\sum_{i=1}^ni^2\times \varphi(i)$$

我们设$S(n)=\sum_{i=1}^ni^2\times \varphi(i)$

答案就是

$$\sum_{i=1}^nS(\left \lfloor \frac{n}{d} \right \rfloor)f(d)$$

我们现在就可以尽情的整除分块了

但是由于$f$需要支持修改我们还要查询前缀和，于是看起来有点自闭，因为树状数组的复杂度高达$O(m\sqrt{n}logn)$，好像不是很科学

但是修改却快的一批，低到$O(mlogn)$，考虑一个神奇的数据结构，可以做到$O(1)$单点求和

自然是神奇的分块了，我们直接把$f$做成前缀和，单点修改我们直接搞成区间修改，之后我们单点查询前缀和就可以很快了

代码

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=4e6+5;
const LL mod=1e9+7;
inline int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
inline LL read() {
	char c=getchar();LL x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
int f[maxn],p[maxn>>1];
LL phi[maxn],pre[maxn],F[maxn];
int n,m;
struct Block {
	int sz,tot;
	int l[3005],r[3005],id[maxn];
	LL tag[3005];
	inline void Build() {
		sz=std::sqrt(n);
		for(re int i=1;i<=n;i+=sz) {
			l[++tot]=i,r[tot]=min(i+sz-1,n);
			for(re int j=l[tot];j<=r[tot];j++) id[j]=tot;
		}
	}
	inline LL ask(int x) {return (pre[x]+tag[id[x]])%mod;}
	inline void change(int x,LL val) {
		int j=id[x];
		if(x==l[j]) tag[j]+=val,tag[j]=(tag[j]+mod)%mod;
		else for(re int i=x;i<=r[j];i++) pre[i]=(pre[i]+val+mod)%mod;
		j++;while(j<=tot) tag[j]+=val,tag[j]=(tag[j]+mod)%mod,j++;
	}
}B;
int main() {
	m=read(),n=read();
	phi[1]=1;
	for(re int i=2;i<=n;i++) {
		if(!f[i]) p[++p[0]]=i,phi[i]=i-1;
		for(re int j=1;j<=p[0]&&p[j]*i<=n;j++) {
			f[p[j]*i]=1;
			if(i%p[j]==0) {phi[p[j]*i]=p[j]*phi[i];break;}
			phi[p[j]*i]=phi[p[j]]*phi[i];
		}
	}
	for(re LL i=1;i<=n;i++) phi[i]=phi[i-1]+i*i%mod*phi[i]%mod,phi[i]%=mod;
	for(re LL i=1;i<=n;i++) F[i]=(i*i)%mod;
	for(re int i=1;i<=n;i++) pre[i]=pre[i-1]+F[i],pre[i]%=mod;
	B.Build();
	int a,b,k;LL v;
	while(m--) {
		a=read(),b=read(),v=read(),k=read();
		int t=gcd(a,b);LL ans=0;
		B.change(t,-1ll*F[t]);
		F[t]=v/((LL)(a/t)*(LL)(b/t));
		B.change(t,F[t]);
		for(re int l=1,r;l<=k;l=r+1) {
			r=k/(k/l);
			ans+=phi[k/l]*(B.ask(r)-B.ask(l-1)+mod)%mod,ans%=mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：shadowice1984 (赞：10)

又是一道数论神题……

这种数学题，第一要耐心推结论，第二要动起手来化简式子

所以……

#### 开始愉快的推倒结论吧~

已知 f(a,b)=f(b,a) && b\*(f(a,a+b))=(a+b)\*f(a,b)

那么我们发现简单变换一下就是

**f(a,a+b)/f(a,b)=(a+b)/b**

也就是说 f(a,a+b)∝f(a,b)，我们发现可以令 b=a+b，比例式仍然成立

另外我们发现这个比值等于 a\*(a+b)/a\*b,，后边会很有用

那么我们就可以递推出来这个等式

**f(a,k\*a+b)∝f(a,b) k∈Z+**

此时我们考虑一下%运算的定义，若 a=Kx+b(k,b∈Z)，那么 a%K=b

又因为f(a,b)=f(b,a)，可以得到这个等式

**f(a,b)∝f(b,a%b)**

然后我们来看另外一个等式

**gcd(a,b)=gcd(b,a%b)**

所以这个f函数的变化情况和其实gcd函数完全一样，只是每一步都是成正比的传递，gcd是等式传递

所以我们发现这个花里胡哨的函数，其实是套了一个gcd函数在里面，刚才的推倒关键在将 k\*a+b b代换为 a%b,b的关系，从而让我们想到了gcd函数

另外，由刚才的比值定义可以得到这个东西

**f(a,b)/f(gcd(a,b),gcd(a,b))=a\*b/gcd(a,b)^2**

化简下就是(以下过程全部用(i,j)代指gcd(i,j)) 

**f(i,j)=f((i,j),(i,j))\*i\*j/(i,j)^2**

还记得我们求的是什么式子吗？

**Σ(1~k)Σ(1~k)f(i,j)**,好像是……反演？

由于猝不及防就是一口反演，我们这里会简（xiang）单（xi）的介绍一下什么是莫比乌斯反演，希望大家可以看懂

## 前置芝士：莫比乌斯反演

### 前置芝士的芝士：狄利克雷卷积X积性函数

所谓数论函数，是一类定义域在自然数上的函数,然后我们会把自然数映射到复数域去，但是OI中常用的数论函数都是**自然数**映射到**整数**上的函数

那么我们定义一种神奇的运算，称之为**Dirichlet卷积**

对于两个数论函数 f，g，我们对于每一个n,**枚举n的所有约数对**，分别计算f值和g值后**相乘再相加**，会得到一个值，记为F(n)那么通过这样的手段我们可以计算出所有的F()值，那么就称F是f和g进行狄利克雷卷积的结果，数学表达式大概是这个样子，(狄利克雷卷积的符号记做X)

**(fXg)(n)=Σ(d|n)f(d)\*g(n/d)**

下面我们来介绍另一些有趣的函数，它们被称之为**积性函数**，所谓积性函数，就是一个函数f满足下列性质

1.f(1)=1

**2.若(i,j)=1,则有f(i\*j)=f(i)\*f(j)**

下面是一些常用的积性函数

1.φ函数，φ(n)表示1~n中有多少数和i互质

2.μ函数，若n有多个相同的质因子，μ(n)=0，若n=1,μ(n)=1,若n有多个相异的质因子，μ(n)=(-1)^质因子个数

3.常函数 1(n)=1

4.id函数 id(n)=n

5.ε函数 ε(n)仅在n=1时为1，其他情况均为零，ε是X运算的单位元，也就是说，任意 fXε=f

### 下面是莫比乌斯反演
------------------------

所谓莫比乌斯反演呢，就是有这样一个公式

fX1=g<->μXg=f

但是这个公式在OI中的应用更主要体现在下面四个公式上，也就是说，如果你的反演十分的不**熟练**的话，可以用这4个公式来**替代**莫比乌斯反演公式(而且好多题基本套完就结束了，反演令人头大的地方是各种骚气的代数变换，例如交换Σ，例如偷换变量，反演难理解的主要原因就是换Σ，同时偷换变量意义)

**1.id=φX1**

**2.ε=μX1**

**3.φ=μXid**

**4.εX1=1**

好了，有了这四个公式辅以**适(sao)当(qi)**的代数变换我们就可以解决大部分的反演问题了

-------------------

### 开始推倒后边的式子吧~

题目让求的是

**Σ(1~k)Σ(1~k)f(i,j)**

套上我们之前的公式，会有

**Σ(1~k)Σ(1~k)i\*j\*f((i,j),(i,j))/(i,j)^2**

这里使用一个非常传统的技巧，叫**枚举gcd**，令gcd=d，统计有多少后边的式子对这个d值做出了贡献，那么我们发现，**令i=i/d，j=j/d**，原来的式子可以变形成这样

**Σ\[d](1~k) f(d,d)\*Σ(1~k/d)Σ(1~k/d)i\*j\*ε((i,j))**

 _(如果d是i\*d和j\*d的gcd，那么(i,j)必须等于1，否则gcd是d\*(i,j))_
 
 下面我们不要着急反演ε，为什么？因为现在就反演你就走远了，最后推出来的式子复杂度不对然后gg
 
 我们观察得到后边的式子，运算式是i\*j\*ε((i,j)),发现**交换i，j后式子的值是不变的**，因此，我们可以**只枚举一半(i,j)**，然后\*2，美中不足的是我们发现i=j的情况会被计算两次，因此我们要再减去i==j的情况，变化之后得到下面的式子，(这个是题最难想的变换，因为看到了ε之后立即反演会导致gg，所以我们要这样变换一下)
 
** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)Σ(1~i)i\*j\*ε((i,j))-Σ\[i](1~k/d)i^2\*ε(i))**

发现Σ(1~k/d)i^2\*ε(i)仅在i==1的时候有值，所以，可以换成1，再次小小的变换下就是

** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)i\*Σ(1~i)j\*ε((i,j))-1)**

此时我们反演ε，会得到

** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)i\*Σ(1~i)j\*Σ\[t](t|i&t|j)μ(t)-1)**

下面是另一步蛇皮操作，**交换Σ**，我们先枚举t,看有多少个j可以和μ(t)相乘发现对一个t，**令j/=t**，此时j在1~i/t里都可以满足原先枚举时的约束，所以就是变化出来这个式子

** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)i\*Σ\[t](t|i)μ(t)\*Σ(1~i/t)j-1)**

发现Σ(1~i/t)j是一个等差数列求和公式，可以快速求出值，让我们继续变换~

** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)i\*Σ\[t](t|i)μ(t)\*(i*(i/t+1))/2-1)**

我们发现i和那个/2都可以通过**乘法分配律**提出去，此时得到

** Σ\[d](1~k)f(d,d)\*(Σ\[i](1~k/d)i^2\*Σ\[t](t|i)μ(t)\*(i/t+1)-1)**

我们令i/t=id(i/t),1=1(i/t),此时得到

** Σ\[d](1~k)f(d,d)\*(Σ\[i](1~k/d)i^2\*(Σ\[t](t|i)μ(t)\*id(i/t)+Σ\[t](t|i)μ(t)\*1(i/t)))-1)**

我们发现这里好像有两个**标准狄利克雷卷积的形式**？‘

** Σ\[d](1~k)f(d,d)\*(Σ\[i](1~k/d)i^2\*((μXid)(i)+(μX1)(i))-1)**

此时自行回去看公式吧，这两个卷积都是可以化简的

** Σ\[d](1~k)f(d,d)\*(Σ\[i](1~k/d)i^2\*((φ(i)+ε(i))-1)**

发现ε(i)\*i^2仅在i=1的时候等于1，可以化简，变成一个1提出去和外面的-1消掉

** Σ\[d](1~k)f(d,d)\*Σ\[i](1~k/d)i^2\*φ(i)**

到此为止，数学竞赛生的工作完成了，现在让我们**正式回到OI**上来

----------------------

我们发现暴力的效率十分的差劲，所以我们考虑**交换Σ**，枚举k/d的值，那么我们发现，若k/d=p，那么满足条件的d是连续的，也就是说，**是一段区间**，
而我们发现，这段区间里p的值都是一样的，也就是说Σ\[i](1~k/d)i^2\*φ(i)这一坨的的值是个定值，因此我们查出f(d,d)区间和，再乘上这个值就好了

我们发现Σ\[i](1~k/d)i^2\*φ(i)，这个东西的值啊，非常的好求，算个前缀和就好了，但是我们查区间和的操作就会十分的辣手，第一我们根本不知道查那一段，这个后边会通过一些奇技淫巧解决，但是我们知道一个结论n/d的值种类是n^0.5级别的，也就是说，我们不管怎样都要查n^0.5次区间和

而修改操作，其实由最早推出的成比例结论，我们会发现，其实就是把f((a,b),(a,b))的值修改为 x/(a/(a,b))/(b/(a,b)) 这里我们千万别犯傻去求逆元，常数贼大不说，膜的还贼多，注意这是两个longlong整除，是可以除的！

此时我们需要的数据结构就十分明了了，我们发现我们需要资瓷**单点修改区间求和**，可能你会瞬间想到大家所热爱的**树状数组**，这样我们就会有logN的优秀复杂度……

## 醒醒！这个做法的复杂度是O(N+MlogN√N)!

树状数组的优秀复杂度是建立在只有M个修改/查询操作的基础上的，问题是，这道题有M个修改，却有M√N个查询……出题人把数据范围开到4\*1e6就是为了卡掉这个次优算法……

也就是说，既然操作都不平衡了，我们的复杂度也不应该平衡，一种修改为√N，查询O(1)的数据结构就可以很好的满足我们的要求

再具体来讲，我们暴力对f建一个前缀和，之后我们每次单点修改在前缀和上都相当于一个区间加，那么我们暴力的分块打标记即可。算法复杂度O(N+M√N)，但是其实还是有些吃不消的，注意卡常数吧，至于那个枚举k/d的奇技淫巧，我们还是见代码吧，对了，我们的枚举的小技巧可以也可以处理出对应的区间

上代码~(其实代码非常短)

```c
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;//unsigned long long 的常数较小…… 
typedef unsigned long long ll;const int N=4000010;ll mod=1e9+7;
inline ll gcd(ll a,ll b){if(a<b)swap(a,b);while(b){ll c=a%b;a=b;b=c;}return a;}
int n;int m;int bs;ll add[N];ll f[N];
inline void ih(){for(ll i=1;i<=n;i++){f[i]=(f[i-1]+(i*i)%mod)%mod;}}
inline ll fb(ll p){return (p)?p-(p-1)%bs:0;}//这里动态找出分块左端点 
inline ll sum(int l,int r){return (f[r]+add[fb(r)]+2LL*mod-f[l-1]-add[fb(l-1)])%mod;}
inline void setval(ll p,ll val)
{
    val=(val+mod-sum(p,p))%mod;
    for(;fb(p)==fb(p-1);p++){f[p]=(f[p]+val)%mod;}//先枚举左边的散点 
    for(;p+bs-1<=n;p+=bs){add[p]=(add[p]+val)%mod;}//中间的区间，枚举左端点 
    for(;p<=n;p++){f[p]=(f[p]+val)%mod;}//再枚举右边的散点 
}
bool book[N];int zhi[N];int cnt;ll phi[N];ll sump[N];
int main()
{
    scanf("%d%d",&m,&n);bs=sqrt(n);ih();phi[1]=1;
    for(int i=2;i<=n;i++)//欧拉筛phi 
    {
        if(!book[i]){zhi[++cnt]=i;phi[i]=i-1;}
        for(int j=1;j<=cnt&&i*zhi[j]<=n;j++)
        {
            book[i*zhi[j]]=true;
            if(i%zhi[j]==0){phi[i*zhi[j]]=phi[i]*zhi[j];break;}
            else {phi[i*zhi[j]]=phi[i]*phi[zhi[j]];}
        }
    }
    for(ll i=1;i<=n;i++){sump[i]=(sump[i-1]+phi[i]*((i*i)%mod))%mod;}//打表前缀和 
    for(int i=1;i<=m;i++)
    {
        ll a;ll b;ll x;int k;scanf("%lld%lld%lld%d",&a,&b,&x,&k);
        ll g=gcd(a,b);x/=(a/g)*(b/g);setval(g,x);int p=1;ll res=0;//这里就是那个枚举n/d的黑科技啦 
        for(int i=1;i<=k;i=p+1){p=k/(k/i);res=(res+sum(i,p)*sump[k/i])%mod;}
        printf("%llu\n",res); 
    }return 0;//拜拜程序~ 
}

```






















 
 
















---

## 作者：Last_Flame (赞：6)

### UPD20231121

现在看当年写的这个题解，感觉真的太稚嫩了，趁没人看到这个黑历史重置一遍。

# 思路

蒟蒻没有什么数论基础，决定乱搞，找出了题目的一些性质。

我们在修改某一个位置的数的时候，表格中一定会有其他一些位置会同步修改。

先尝试找出会同步修改的位置。

一眼看不出来，于是就在 Excel 里面弄了张图，大概长这样：

![毛巾](https://cdn.luogu.com.cn/upload/image_hosting/53f9ge0z.png)

修改任意绿色位置，所有绿色位置都会被修改。

然后我们发现，对于位置 $(a,b)$，如果 $\gcd (a,b)=1$，那么这个位置就应该修改。

分析条件 $2$：

$$b \times f(a,a+b) = (a+b) \times f(a,b)$$

即修改位置 $(a,b)$ 的时候，位置 $(a,a+b)$ 也会被修改。

然后我们来看到条件 $1$：

$$f(a,b) = f(b,a)$$

结合条件 $2$ 可以转换为：
$$b \times f(a+b,a) = (a+b) \times f(a,b)$$

那么假如我们修改了位置 $(i,j)$，那么对于 $\forall t \in \mathbb{N} ^ {\star}$，位置 $(i,t \times i + j)$，$(i + t \times j,j)$ 也要修改。

这个东西看起来像什么？

$$\gcd(i,j) = \gcd(i,t \times i + j) = \gcd(i + t \times j,j)$$

所以说，假如修改位置 $(a,b)$，那么对于任意位置 $(i,j)$，如果 $\gcd(a,b)=\gcd(i,j)$，那么位置 $(i,j)$ 会随位置 $(a,b)$ 一起修改。

(所以这道题的题面也是互质表的一种画法，使用 Excel 自带的复制功能可以很方便地画出上文的那张表)

---

好了，我们已经知道修改任一位置，应该同时修改的位置有哪些了。但是到底要怎么求出数和呢？

条件 $1,2$ 可以转换为：

- $f(a,a+b) = \frac{a+b}{b} \times f(a,b)$

- $f(a+b,a) = \frac{a+b}{b} \times f(a,b)$

简单概括一下，就是说对于同一行的两个位置，它们的数之比等于列数之比；对于同一列的两个位置，它们的数之比等于行数之比。初始时，$f(i,j)=i \times j$。

还能发现，当我们把某位置的值修改为原来的 $t$ 倍，那么所有同时修改的位置的值都应该变为原来的 $t$ 倍。题面还提到了保证所有位置的数修改后仍然为整数，难得一见的良心出题人！

那么我们考虑未修改时 $k \in [1,n]$ 的答案，可以算出是：

$$ \sum_{i=1}^{k} i^{3}$$

这个可以用自然数幂方求和公式 $O(1)$ 算出：

$$ \sum_{i=1}^{k} i^{3} = \frac{k^{2} \times (k+1)^{2}}{4} $$

然后对于修改操作，由于是一次性修改 $\gcd$ 相等的所有位置，那么正常来说考虑莫比乌斯反演。

但是我不正常，毕竟当时考试做到这道题的时候我还不会莫反，我直接考虑使用欧拉函数！

这个修改操作就是给定 $t,k$，修改 $\forall i,j \in [1,k] ,gcd(i,j)=t$ 的位置 $(i,j)$，边界都是 $k$，而两个量边界条件相等时可以直接使用欧拉函数前缀和求得，时间复杂度直接从 $O(\sqrt{k})$ 降到了 $O(1)$。酷炫！

但是这道题我们要求的是：

$$\sum_{i=1}^{k} \sum_{j=1}^{k} [\gcd(i,j)=1] ij$$

那么我们就是要求这个函数（需要注意 $n=1$ 时 $f(n)$ 不为整数，向下取整会变成 $0$，需要注意在使用该函数后加上缺失的值）：

$$g(n)=\frac{\varphi(n) \times n}{2}$$

那么原式可以化为：

$$\sum_{i=1}^{k}g(i) \times 2$$

由于每次修改后，所有修改的位置都会变为原来的值的倍数，那么对于每个 $\gcd$ 我们只需要记录修改后的值相对于初始值的倍数是多少，最后暴力修改即可。

总复杂度 $O(n+m^{2})$，可以通过。但由于 $\gcd$ 的位置分配性质，若没有刻意构造数据，复杂度会在 $O(n+m \sqrt{m})$ 级别，甚至更小，所以这个方法跑的飞快。

# code

~~~cpp
#include<bits/stdc++.h>
using namespace std;
const int mn=1048576,mod=1e9+7;
int m,n,k;
long long a,b,x;

vector<int> prime,chl;
int ppt;
int answ;
long long pgcd,pgcd2;
long long mpt,ans[4*mn],pans;
long long sumphin[4*mn],phi[4*mn],phin[4*mn];
long long ch[4*mn];
bool isphi[4*mn],isch[4*mn];
bitset<4*mn> isprime;

int getgcd(int x1,int x2){
	if(x1<x2) swap(x1,x2);
	while(x2>0){
		x1%=x2;
		swap(x1,x2);
	}
	return x1;
}

void euler(){
	phi[1]=1;sumphin[1]=1;phin[1]=1;sumphin[1]=1;
	isprime.set();
	for(int i=2;i<=n;i++){
		if(isprime[i]){
			prime.push_back(i);
			phi[i]=i-1;
		}
		for(int i1=0,pi;i1<prime.size();i1++){
			pi=i*prime[i1];
			if(pi>n) break;
			isprime[pi]=false;
			if(i%prime[i1]==0){
				phi[pi]=phi[i]*prime[i1];
				break;
			}
			else phi[pi]=phi[i]*phi[prime[i1]];
		}
	}
	
	for(int i=2;i<=n;i++){
		phin[i]=phi[i]*i/2;
		phin[i]%=mod;
		phin[i]*=i;
		phin[i]%=mod;
		sumphin[i]=sumphin[i-1]+(phin[i])*2;
		sumphin[i]%=mod;
	}
	return;
}

int main(){
	cin>>m>>n;
	
	for(int i=1;i<=n;i++){
		mpt+=2*i-1;
		mpt%=mod;
		ans[i]=ans[i-1]+mpt*i;
		ans[i]%=mod;
	}
	
	euler();
	
	for(int i=1;i<=m;i++){
		cin>>a>>b>>x>>k;
		
		pgcd=getgcd(a,b);
		pgcd2=pgcd*pgcd;
		ch[pgcd]=x/((a*b)/pgcd2);
		ch[pgcd]%=mod;
		if(!isch[pgcd]){
			chl.push_back(pgcd);
			isch[pgcd]=true;
		}
		
		pans=ans[k];
		for(int i1=0;i1<chl.size();i1++){
			answ=k/chl[i1];
			pans-=((sumphin[answ]*chl[i1])%mod)*chl[i1];
			pans+=sumphin[answ]*ch[chl[i1]];
			pans%=mod;
		}
		if(pans<0) pans+=mod;
		cout<<pans<<endl;
	}
	return 0;
} 
~~~

---

## 作者：qwaszx (赞：6)

神仙数论题

由$bf(a,a+b)=(a+b)f(a,b)$得到$\frac{f(a,a+b)}{a(a+b)}=\frac{f(a,b)}{ab}$

然后发现这个式子很像辗转相减...于是一直辗转相除下去

$\frac{f(a,b)}{ab}=\frac{f(a,a\mod b)}{a(a\mod b)}=\cdots =\frac{f(\gcd(a,b),\gcd(a,b))}{\gcd(a,b)\times\gcd(a,b)}$

换句话说设$d=\gcd(a,b)$，那么$f(a,b)=\frac{abf(d,d)}{d^2}$

我们现在可以用对角线上的$f$来表示整个表格了

要求前$n$行前$n$列的答案(以下除法均向下取整):

$\sum\limits_{i=1}^n\sum\limits_{j=1}^n\frac{ijf(\gcd(i,j),\gcd(i,j)}{\gcd(i,j)^2}$

$=\sum\limits_{d=1}^n\frac{f(d,d)}{d^2}\sum\limits_{i=1}^n\sum\limits_{j=1}^nij[\gcd(i,j)=d]$

$=\sum\limits_{d=1}^nf(d,d)\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{n/d}ij[\gcd(i,j)=1]$

$=\sum\limits_{d=1}^nf(d,d)\sum\limits_{k=1}^{n/d}k^2\mu(k)(S(n/d/k))^2$

其中$S(n)=\sum\limits_{i=1}^n=\frac{n(n+1)}{2}$

于是我们可以对$n/d$分块，然后维护$f$的前缀和以及后面的一坨东西

提出来后面的一块，我们需要预处理它

$G(n)=\sum\limits_{i=1}^ni^2\mu(i)(S(\left\lfloor\frac{n}{i}\right\rfloor))^2$

现在我们是数学竞赛生了(雾

使用关于下取整的技巧——差分

$\left\lfloor\frac{n}{i}\right\rfloor-\left\lfloor\frac{n-1}{i}\right\rfloor=[i\mid n]$

于是$G(n)-G(n-1)=\sum\limits_{i\mid n}i^2\mu(i)(S(n/i)^2-S(n/i-1)^2)$

$=\sum\limits_{i|n}i^2\mu(i)\left(\frac{n}{i}\right)^3=n^2\sum\limits_{i|n}\mu(i)\frac{n}{i}=n^2\varphi(n)$

所以$G(n)=\sum\limits_{i=1}^ni^2\varphi(i)$

然后直接$O(n)$预处理$G$就好了

还需要修改怎么办

如果修改$f(a,b)=w$，那么根据一开始的等式我们得到$f(d,d)=\frac{d^2f(a,b)}{ab}$

所以我们需要一个支持单点修改和前缀查询的数据结构

总的复杂度是$\sqrt{n}\times\text{查询复杂度}+\text{修改复杂度}$

那当然是分块了，维护一个前缀和就好了，$O(\sqrt{n})-O(\sqrt{n})$

也可以做到$O(\sqrt{n})-O(n^\frac{1}{3})$，不过亲测没什么用

最优解跑了个基于修改中不同$gcd$个数的做法...这波乱搞我服(虽然可以卡掉)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int mod=1e9+7;
const int N=5e6;
int a[N],s[N],ss[N],prime[N],p[N],phi[N],cnt,f[N],bl[N],blo,n,m;
void make(int n)
{
	phi[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!p[i])prime[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			int x=i*prime[j];p[x]=1;
			if(i%prime[j])phi[x]=phi[i]*(prime[j]-1);
			else{phi[x]=phi[i]*prime[j];break;}
		}
	}
	for(int i=1;i<=n;i++)f[i]=(f[i-1]+1ll*i*i%mod*phi[i])%mod;
	
	blo=sqrt(n);
	for(int i=1;i<=n;i++)bl[i]=(i-1)/blo+1,a[i]=1ll*i*i%mod;
	for(int i=1;i<=bl[n];i++)
	{
		int l=(i-1)*blo+1,r=min(i*blo,n);s[l]=a[l];
		for(int j=l+1;j<=r;j++)s[j]=(s[j-1]+a[j])%mod;
		ss[i]=(ss[i-1]+s[r])%mod;
	}
}
int query(int n){return (s[n]+ss[bl[n]-1])%mod;}
void update(int x,int w)
{
	int blx=bl[x],r=min(blx*blo,n);
	int tw=(w-a[x]+mod)%mod;a[x]=w;
	for(int i=x;i<=r;i++)s[i]=(s[i]+tw)%mod;
	for(int i=blx;i<=bl[n];i++)ss[i]=(ss[i]+tw)%mod;
}
int solve(int n)
{
	int i=1,lt=sqrt(n);
	int ans=0;

	for(;i<=lt;i++)ans=(ans+1ll*a[i]*f[n/i])%mod;
	for(;i<=n;i=lt+1)
	{
		lt=n/(n/i);
		ans=(ans+1ll*(query(lt)-query(i-1))*f[n/i])%mod;
	}
	return (ans+mod)%mod;
}
int gcd(int x,int y){return y?gcd(y,x%y):x;}
int main()
{
	scanf("%d%d",&m,&n);
	make(n);
	for(int i=1;i<=m;i++)
	{
		int u,v,k;long long x;
		scanf("%d%d%lld%d",&u,&v,&x,&k);
		int d=gcd(u,v);
		update(gcd(u,v),(x/(u/d)/(v/d))%mod);
		printf("%d\n",solve(k));
	}
}
```

---

## 作者：orz_z (赞：2)

### [P3700 [CQOI2017]小Q的表格](https://www.luogu.com.cn/problem/P3700)

有一个表格，满足：
$$
\begin{aligned}
&f(a,b)=f(b,a)\\
&b \times f(a,a+b)=(a+b)\times f(a,b)
\end{aligned}
$$

且一开始 $f(a,b)=a\times b$，然后带上一个单点修改操作。

每当修改了一个格子的数之后，为了让表格继续满足上述两个条件，你还需要把这次修改能够波及到的全部格子里都改为恰当的数。

你还需要随时输出前 $k$ 行前 $k$ 列这个有限区域内所有数的和 $\pmod {10^9+7}$。

考虑从下面那个式子得出一些可以反演的东西，有：
$$
\begin{aligned}
b \times f(a,a+b)&=(a+b)\times f(a,b)\\
ab \times f(a,a+b)&=a(a+b)\times f(a,b)\\
\frac{f(a,a+b)}{a(a+b)}&=\frac{f(a,b)}{ab}\\
\frac{f(a,b)}{ab}&=\frac{f(\gcd(a,b),\gcd(a,b))}{\gcd(a,b)^2}
\end{aligned}
$$
设 $\gcd(a,b)=d$，则有：
$$
\begin{aligned}
\frac{f(a,b)}{ab}&=\frac{f(d,d)}{d^2}\\
f(a,b)&=\frac{f(d,d)\times ab}{d^2}
\end{aligned}
$$
考虑到这个矩阵要变换，因为修改一个位置 $(a,b)$ 的值后有且仅有 $\gcd(x,y)=d$ 的 $(x,y)$ 位置的 $f$ 值会跟着变化，那么用一个树状数组维护 $f(d,d)$ 即可。

设 $f(d,d)=g(d)$，再考虑答案：
$$
\begin{aligned}
ans&=\sum_{d=1}^{n}g(d)\sum_{i=1}^{n}\sum_{j=1}^{n}\frac{ij}{\gcd(i,j)^2}[\gcd(i,j)=d]\\
&=\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}ij[\gcd(i,j)=1]\\
&=\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}ij\sum_{p|\gcd(i,j)}\mu(p)\\
&=\sum_{d=1}^{n}g(d)\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}i[p|i]\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}j[p|j]\\
&=\sum_{d=1}^{n}g(d)\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)p^2\left(\sum_{i=1}^{\lfloor\frac{\lfloor\frac{n}{d}\rfloor}{p}\rfloor}i\right)^2\\
&=\sum_{d=1}^{n}g(d)\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)p^2S(\lfloor\frac{\lfloor\frac{n}{d}\rfloor}{p}\rfloor) ^2
\end{aligned}
$$

设 $G(n)=\sum\limits_{i=1}^{n}i^2\mu(i)S(\lfloor\frac{n}{i}\rfloor)^2$，则原式等于：
$$
\sum_{d=1}^{n}g(d)G(\lfloor\frac{n}{d}\rfloor)
$$
根据 $\lfloor\frac{n}{i}\rfloor-\lfloor\frac{n-1}{i}\rfloor=[i|n]$，有：
$$
\begin{aligned}
G(n)-G(n-1)&=\sum_{i|n}i^2\mu(i)(S(\lfloor\frac{n}{i}\rfloor)^2-S(\lfloor\frac{n}{i}\rfloor-1)^2\\
&=\sum_{i|n}i^2\mu(i)(\frac{n}{i})^3\\
&=n^2\sum_{i|n}\mu(i)\frac{n}{i}\\
&=n^2\varphi(n)
\end{aligned}
$$
那么有：
$$
G(n)=\sum_{i=1}^{n}i^2\varphi(i)
$$
那么原式等于：
$$
\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}i^2\varphi(i)
$$
线性筛，维护前缀和，再数论分块即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int mod = 1e9 + 7;

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = ((x << 1) + (x << 3) + (c ^ 48)) % mod;
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if(x < 0)
	{
		putchar('-');
		x = -x;
	}
	if(x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 4e6 + 10;

int n, m;

int cnt, pr[_], vis[_], phi[_];

int f[_];

int c[_];

int val[_];

int Gcd(int x, int y)
{
    if (!y)
        return x;
    return Gcd(y, x % y);
}

void inc(int &x, int y)
{
	x += y;
	if(x >= mod) x -= mod;
	else if(x < 0) x += mod;
}

int add(int x, int y)
{
	int temp = x + y;
    if (temp >= mod)
        temp -= mod;
    else if (temp < 0)
        temp += mod;
    return temp;
}

int qpow(int x, int y)
{
	int res = 1;
	while(y)
	{
		if(y & 1) res = res * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return res;
}

void init()
{
	phi[1] = 1;
	for(int i = 2; i <= n; ++i)
	{
		if(!vis[i])
		{
			pr[++cnt] = i;
			phi[i] = i - 1;
		}
		for(int j = 1; j <= cnt && i * pr[j] <= n; ++j)
		{
			vis[i * pr[j]] = 1;
			if(i % pr[j] == 0)
			{
				phi[i * pr[j]] = phi[i] * pr[j];
				break;
			}
			phi[i * pr[j]] = phi[i] * (pr[j] - 1);
		}
	}
	for(int i = 1; i <= n; ++i)
		f[i] = (f[i - 1] + i * i % mod * phi[i] % mod) % mod;
}

#define lowbit(x) (x & -x)

void update(int x, int val)
{
	while(x <= n)
	{
		inc(c[x], val);
		x += (x & -x);
	}
}

int query(int x)
{
	int res = 0;
	while(x)
	{
		inc(res, c[x]);
		x -= (x & -x);
	}
	return res;
}

int Query(int l, int r)
{
	return add(query(r), -query(l - 1));
}

signed main()
{
	m = read(), n = read();
	init();
	for(int i = 1; i <= n; ++i)
	{
		val[i] = i * i % mod;
		update(i, val[i]);
	}
	while(m--)
	{
		int a = read(), b = read(), x = read(), k = read(), d = Gcd(a, b);
        int upt = x * d % mod * d % mod * qpow(a * b % mod, mod - 2ll) % mod;
        update(d, add(upt, -val[d]));
        val[d] = upt;
        int ans = 0;
        int S = sqrt(k);
        for(int i = 1; i < S; ++i) inc(ans, f[k / i] * Query(i, i) % mod);
        for (int l = S, r; l <= k; l = r + 1) 
		{
            r = k / (k / l);
            inc(ans, f[k / l] * Query(l, r) % mod);
        }
        write(ans);
        putchar('\n');
	}
	return 0;
}
```



---

## 作者：Supor__Shoep (赞：1)

这真是一道神仙数论题。

转念一想这明显又是一道莫比乌斯反演的神仙题。

[没有学莫比乌斯反演的朋友们来看一看这个博客](https://www.cnblogs.com/Mobius-strip/p/15243609.html)

首先我们要整理一下题目给出的所有条件。

根据最大公约数的性质得到：

$$\gcd(a+b,b)=\gcd(a,b+a)=\gcd(a,b)$$

接着我们还发现若改变了 $(x,y)$，所有 $\gcd(x,y)=\gcd(l,j)$ 中的 $(l,j)$ 的位置都会发生改变，这里令 $d=\gcd(l,j)$，则有：

$$f(l,j)=\frac{f(d,d)\times i\times j}{d^2}$$

我们以只保留一维，对于所有 $\gcd(i,j)=d$ 的数对 $(i,j)$ 都有  $f(i,j)=f(d)\times i\times j$

那么答案就有：

$$ans=\sum_{d=1}^{n}f(d) \sum_{i=1}^{n} \sum_{j=1}^{n}[\gcd(i,j)=d]i\times j$$

$$ans=\sum_{d=1}^{n}f(d)\times d^2\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}[\gcd(i,j)=1]i\times j$$

做到这里就是两种途径了。

第一种是根据：

$$\sum_{i=1}^{n}\sum_{j=1}^{n}[\gcd(i,j)=1]i\times j\Longleftrightarrow \sum_{i=1}^{n}\varphi(i)\times i^2$$

来筛破 $\varphi$，由于本人是个大蒟蒻，所以不做过多讲解。

第二种比较复杂，看到题里面有布尔表达式，自然而然想到了套 $\mu$。

$$ans=\sum_{d=1}^{n}f(d)\times d^2\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}i\times j\sum_{x|\gcd(i,j)}\mu (x)$$

接着推到：

$$ans=\sum_{d=1}^{n}f(d)\times d^2\sum_{x=1}^{\lfloor \frac{n}{d} \rfloor} \mu (x)\times x^2\times S(\lfloor \frac{n}{dx} \rfloor)^2$$

令

$$g(n)=\sum_{i=1}^{n}\mu (i)\times i^2\times S(\lfloor \frac{n}{i} \rfloor)^2$$

我们不难发现 $g(n)$ 是可以递推发展的，公式为：

$$g(n)=g(n-1)+n^3\sum_{i|n}\frac{\mu (i)}{i}$$

中间又令

$$w(n)=\sum_{i|n}\frac{\mu (i)}{i}$$

又发现 $w(n)$ 是一个积性函数，可以来一波线性筛，同时 $g(n)$ 也可以轻轻松松地推理出来。

最后用分块优化时间复杂度，用前缀和增效，就完成了一道黑题。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define rep(i,st,ed) for(register int i=st;i<=ed;i++)
#define drp(i,st,ed) for(register int i=st;i>=ed;i--)
typedef long long LL;
const int MOD=1000000007;
LL inv[4000005],f[4000005],g[4000005],h[4000005];
LL t[2005][2005],sum[2005];
int st[2005],ed[2005],bel[2005],prime[4000005];
int n,m;
bool nprime[4000005];
void mod(LL &x)
{
    x-=x>=MOD?MOD:0;
}
inline int gcd(int x,int y)
{
    return (!y)?(x):gcd(y,x%y);
}
void pre_work()
{
    inv[1]=f[1]=g[1]=h[1]=1;
    rep(i,2,n)
	{
        f[i]=1;
        inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
        if(!nprime[i])
		{
            prime[++prime[0]]=i;
            h[i]=(1-inv[i]+MOD)%MOD;
        }
        for(register int j=1,x=i*prime[j];i*prime[j]<=n&&j<=prime[0];x=i*prime[++j])
		{
            nprime[x]=1;
            if(i%prime[j]==0)
			{
                h[x]=h[i];
                break;
            }
            h[x]=(h[i]*h[prime[j]])%MOD;
        }
        mod(g[i]=g[i-1]+((LL)i%MOD*(LL)i%MOD*(LL)i%MOD*h[i]%MOD)%MOD);
    }
    int size=(int)ceil(sqrt(n));
    rep(i,1,n)
	{
        bel[i]=(i-1)/size+1;
        if(!st[bel[i]]) st[bel[i]]=i;
        ed[bel[i]]=std:: max(ed[bel[i]],i);
    }
    rep(b,1,bel[n])
	{
        rep(i,st[b],ed[b])
		{
            t[b][i-st[b]+1]=(t[b][i-st[b]]+f[i]*i%MOD*i%MOD)%MOD;
        }
    }
    drp(b,bel[n],1)
	{
        sum[b]=(sum[b+1]+t[b][ed[b]-st[b]+1])%MOD;
    }
}
inline void modify(int x)
{
    int bx=bel[x];
    rep(i,x,ed[bx]) t[bx][i-st[bx]+1]=(t[bx][i-st[bx]]+f[i]*(LL)i%MOD*(LL)i%MOD)%MOD;
    drp(i,bx,1) sum[i]=(sum[i+1]+t[i][ed[i]-st[i]+1])%MOD;
}
inline LL query(int x,int y)
{
    int bx=bel[x],by=bel[y];
    if(bx==by) return (t[bx][y-st[bx]+1]%MOD-t[bx][x-st[bx]]%MOD+MOD)%MOD;
    LL ret=0;
    mod(ret+=t[bx][ed[bx]-st[bx]+1]-t[bx][x-1-st[bx]+1]+MOD);
    mod(ret+=t[by][y-st[by]+1]);
    mod(ret+=sum[bx+1]-sum[by]+MOD);
    return ret;
}
inline void solve(int n)
{
    LL ans=0;
    for(register int i=1,j;i<=n;i=j+1)
	{
        j=n/(n/i);
        mod(ans+=query(i,j)*g[n/i]%MOD);
    }
    cout<<ans<<endl;
}
int main(void)
{
    cin>>m>>n;
    pre_work();
    int a,b,k,d;LL x;
    while(m--)
	{
        cin>>a>>b>>x>>k;
        x=x%MOD;
        f[d=gcd(a,b)]=x*inv[a]%MOD*inv[b]%MOD;
        modify(d);solve(k);
    }
    return 0;
}
```

---

## 作者：mango09 (赞：1)

[P3700 [CQOI2017]小Q的表格](https://www.luogu.com.cn/problem/P3700)

## Description

- 有一个无穷多行，无穷多列的表格，行列从 $1$ 开始标号，第 $a$ 行 $b$ 列有一个整数 $f(a, b)$；
- $f(a, b)$ 应满足：
  - $\forall a, b \in \mathbb{N}^*, f(a, b) = f(b, a)$；
  - $\forall a, b\in \mathbb{N}^*, b\cdot f(a, a + b) = (a + b) \cdot f(a, b)$。
- 初始时，$\forall a, b\in \mathbb{N}^*, f(a, b) = ab$（显然这满足要求）；
- $m$ 次操作，每次给出 $4$ 个整数 $a, b, x, k$，表示令 $f(a, b) \gets x$，然后把它能够波及到的所有格子全部修改，保证修改之后所有格子的数仍然都是整数，修改完成后计算前 $k$ 行前 $k$ 列里所有数的和 $\bmod (10^9 + 7)$；
- $1 \le m \le 10^4, 1 \le a, b, k \le n \le 4 \times 10^6, 0 \le x < 10^{18}$。

## Solution

对于性质 $2$，直接看是不会有任何思路的。

我们尝试对式子进行移项：

$$b\cdot f(a, a + b) = (a + b) \cdot f(a, b)$$

$$\dfrac{f(a, a + b)}{a + b} = \dfrac{f(a, b)}{b}$$

根据性质 $1$，也就是说，当 $a > b$ 时，有

$$\dfrac{f(a, b)}{a} = \dfrac{f(b, a \bmod b)}{a \bmod b}$$

回忆辗转相除法的公式：

$$\gcd(a, b) = \gcd(b, a \bmod b)$$

发现和上面长的很像。

我们再把这个式子改造一下：

$$\dfrac{f(a, b)}{a \cdot b} = \dfrac{f(b, a\bmod b)}{b\cdot (a\bmod b)}$$

辗转相除法的最后一步是

$$\gcd(a, b) = \gcd(\gcd(a, b), 0)$$

而这里要求 $a, b > 0$，即

$$\gcd(a, b) = \gcd(\gcd(a, b), \gcd(a, b))$$

体现在原式中就是

$$\dfrac{f(a, b)}{a\cdot b} = \dfrac{f(\gcd(a, b), \gcd(a, b))}{\gcd(a, b)^2}$$

即

$$f(a, b) = \dfrac{ab\cdot f(\gcd(a, b), \gcd(a, b))}{\gcd(a, b)^2}$$

对于查询操作：

$$
\begin{aligned}
ans
& = \sum_{d = 1}^k \sum_{i = 1}^k \sum_{j = 1}^k \dfrac{ij\cdot f(d, d)}{d^2} [\gcd(i, j) = d] \\
& = \sum_{d = 1}^k f(d, d) \sum_{i = 1}^{\left\lfloor\frac{k}{d}\right\rfloor} i \sum_{j = 1}^{\left\lfloor\frac{k}{d}\right\rfloor} j [\gcd(i, j) = 1]
\end{aligned}
$$

根据

$$n \sum_{i = 1}^n i [\gcd(i, n) = 1] = n \cdot \dfrac{n \varphi(n) + \varepsilon(n)}{2}$$

发现这里 $j$ 可能大于 $i$，根据对称性乘 $2$ 即可。

但所有 $i = j$ 的情况都被重复算了 $2$ 次；不过对于 $i = j > 1$ 的情况，$\gcd(i, j) \ne 1$，本身不会产生贡献；只有 $i = j = 1$ 的情况被重复算了。

实际上 $i = j = 1$ 的贡献是 $1\times 1\times 1 = 1$，而 $\dfrac{1\times \varphi(1) + \varepsilon(1)}{2} \times 2 = 2$，解决方案是直接把 $\varepsilon$ 给扔掉，这样 $\dfrac{1\times\varphi(1)}{2} \times 2 = 1$ 而且对于 $i > 1$ 的情况去掉 $\varepsilon$ 没有影响。

综上，

$$
\begin{aligned}
\sum_{i = 1}^n i \sum_{j = 1}^n  j [\gcd(i, j)]
& = \sum_{i = 1}^n i\cdot \dfrac{i \varphi(i)}{2} \cdot 2 \\
& = \sum_{i = 1}^n i^2 \varphi(i)
\end{aligned}
$$

设其为 $g(n)$，发现 $g$ 可以 $O(n)$ 预处理 $O(1)$ 回答。

代回原式

$$
ans = \sum_{d = 1}^k f(d, d) g\left(\left\lfloor\dfrac{k}{d}\right\rfloor \right)
$$

愉快地整除分块。

整除分块中要用到 $f(n, n)$ 的前缀和，那么修改直接用树状数组单点修改即可，查询就是区间查询。

查询是 $O(m\sqrt{n} \log n)$ 的，而修改才 $O(m \log n)$，虽然能过但很不优。

考虑有什么数据结构能做到 $O(1)$ 查询：分块——但只能单点查询。

这也不难，把维护的东西改为前缀和，查询就是 $O(1)$，修改就修改 $\gcd(a,b) \sim n$，是 $O(\sqrt{n})$ 的。

具体地，题目中要 $f(a, b) \gets x$，根据上面的公式就是

$$
f(\gcd(a, b), \gcd(a, b)) \gets \dfrac{x \cdot \gcd(a, b)^2}{ab}
$$

这样就做到了平衡——修改查询均为 $O(m\sqrt{n})$，比树状数组不知道快了多少倍。

## Code

```cpp
//18 = 9 + 9 = 18.
#include <iostream>
#include <cstdio>
#include <cmath>
#define Debug(x) cout << #x << "=" << x << endl
typedef long long ll;
using namespace std;

const int MOD = 1e9 + 7;
int add(int a, int b) {return (a + b) % MOD;}
int sub(int a, int b) {return (a - b + MOD) % MOD;}
int mul(int a, int b) {return (ll)a * b % MOD;}

const int MAXN = 4e6 + 5;
typedef int arr[MAXN];

struct DS
{
	arr L, R, belong, val, tag, a;
	
	void build(int n)
	{
		int t = sqrt(n);
		for (int i = 1; i <= t; i++)
		{
			L[i] = R[i - 1] + 1, R[i] = i * t;
		}
		if (R[t] < n)
		{
			t++;
			L[t] = R[t - 1] + 1, R[t] = n;
		}
		for (int i = 1; i <= t; i++)
		{
			for (int j = L[i]; j <= R[i]; j++)
			{
				belong[j] = i;
				a[j] = mul(j, j);
				val[j] = add(val[j - 1], a[j]);
			}
		}
	}
	
	void update(int l, int r, int x)
	{
		int k = sub(x, a[l]);
		a[l] = x;
		int p = belong[l], q = belong[r];
		if (p == q)
		{
			for (int i = l; i <= r; i++)
			{
				val[i] = add(val[i], k);
			}
		}
		else
		{
			for (int i = l; i <= R[p]; i++)
			{
				val[i] = add(val[i], k);
			}
			for (int i = L[q]; i <= r; i++)
			{
				val[i] = add(val[i], k);
			}
			for (int i = p + 1; i < q; i++)
			{
				tag[i] = add(tag[i], k);
			}
		}
	}
	
	int query(int x)
	{
		return add(val[x], tag[belong[x]]);
	}
	
	int GetSum(int l, int r)
	{
		return sub(query(r), query(l - 1));
	}
}D;

struct Math
{
	arr p, phi, g;
	bool vis[MAXN];
	
	void pre(int n)
	{
		phi[1] = 1;
		for (int i = 2; i <= n; i++)
		{
			if (!vis[i])
			{
				p[++p[0]] = i;
				phi[i] = i - 1;
			}
			for (int j = 1; j <= p[0] && i * p[j] <= n; j++)
			{
				vis[i * p[j]] = true;
				if (i % p[j] == 0)
				{
					phi[i * p[j]] = phi[i] * p[j];
					break;
				}
				phi[i * p[j]] = phi[i] * phi[p[j]];
			}
		}
		
		for (int i = 1; i <= n; i++)
		{
			g[i] = add(g[i - 1], mul(mul(i, i), phi[i]));
		}
	}
	
	int gcd(int a, int b)
	{
		if (!b)
		{
			return a;
		}
		return gcd(b, a % b);
	}
	
	int block(int n)
	{
		int res = 0;
		for (int l = 1, r; l <= n; l = r + 1)
		{
			int k = n / l;
			r = n / k;
			res = add(res, mul(D.GetSum(l, r), g[k]));
		}
		return res;
	}
}M;

int main()
{
	int m, n;
	scanf("%d%d", &m, &n);
	D.build(n), M.pre(n);
	while (m--)
	{
		int a, b, k; ll xx;
		scanf("%d%d%lld%d", &a, &b, &xx, &k);
		int d = M.gcd(a, b);
		xx = xx / (a / d) / (b / d);
		int x = xx % MOD;
		D.update(d, n, x);
		printf("%d\n", M.block(k));
	}
	return 0;
}
```



---

## 作者：Leasier (赞：1)

前置芝士：[莫比乌斯反演](https://oi-wiki.org/math/mobius/)

本题解省略部分分做法及其代码。

将 $b f(a, a + b) = (a + b) f(a, b)$ 变形为 $\frac{f(a, b)}{b} = \frac{f(a, a + b)}{a + b}$。

两边分母都是 $f$ 函数的第二个参数。那我要是把加号变成减号并一直这样做呢？

然后就变成了这个形式：$\frac{f(a, b)}{b} = \frac{f(a, a \bmod b)}{a \bmod b}$。

怎么这么像辗转相除法？

由于 $f(a, b) = f(b, a)$，原式可以变成这个形式：$\frac{f(a, b)}{ab} = \frac{f(a \bmod b, a)}{a \bmod b \times a}$。

以此类推：$\frac{f(a, b)}{ab} = \frac{f(\gcd(a, b), \gcd(a, b))}{\gcd^2(a, b)}$。

于是，我们发现，$f(a, b)$ 的值只与 $f(\gcd(a, b), \gcd(a, b))$ 有关，每次修改相当于修改了 $f(\gcd(a, b), \gcd(a, b))$。

设一个最大公约数 $d$ 被上次修改时的 $a, b, x$ 为 $a_d, b_d, x_d$，我们可以迅速写出每个最大公约数 $d$ 修改后对最初答案 $(\frac{k(k + 1)}{2})^2$ 的贡献：

$$(\frac{x_d}{\frac{a_d}{d} \times \frac{b_d}{d}} - d^2) \sum_{i = 1}^k \sum_{j = 1}^k [\gcd(i, j) = d] \frac{ij}{\gcd^2(i, j)}$$

前面那部分的信息是可以在每次修改时保存的。我们考虑后面那部分：

$\displaystyle\sum_{i = 1}^k \sum_{j = 1}^k [\gcd(i, j) = d] \frac{ij}{\gcd^2(i, j)}$

$ = \displaystyle\sum_{i = 1}^{\lfloor \frac{k}{d} \rfloor} \sum_{j = 1}^{\lfloor \frac{k}{d} \rfloor} [\gcd(i, j) = 1] ij$

设 $S_1(n) = \frac{n(n + 1)}{2}$，有：

原式 $= \displaystyle\sum_{p = 1}^{\lfloor \frac{k}{d} \rfloor} \mu(p) p^2 S_1^2(\lfloor \frac{k}{dp} \rfloor)$

这个东西预处理 / 在线计算看上去都会 TLE。事实上，遇见数论分块形式的不好处理的式子，我们可以考虑**差分**，因为存在以下对正整数 $n, m$ 恒成立的等式：

$$\lfloor \frac{n}{m} \rfloor - \lfloor \frac{n - 1}{m} \rfloor = [m\ |\ n]$$

设 $g(n) = \displaystyle\sum_{p = 1}^n \mu(p) p^2 S_1^2(\lfloor \frac{n}{p} \rfloor)$，有：

$g(n) - g(n - 1) = \displaystyle\sum_{p\ |\ n} \mu(p) p^2 (S_1^2(\frac{n}{p}) - S_1^2(\frac{n}{p} - 1))$（因为只有 $n$ 的约数处的点值会发生改变）。

$ = \displaystyle\sum_{p\ |\ n} \mu(p) \frac{n^3}{p}$

$ = n^2 \displaystyle\sum_{p\ |\ n} \mu(p) \frac{n}{p}$

$ = n^2 \varphi(n)$

于是我们通过线性筛预处理出它的前缀和并在每次查询时遍历之前被修改过的点值并统计贡献即可。时间复杂度为 $O(m^2 + n)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int N = 4e6 + 7, M = 1e4 + 7, mod = 1e9 + 7;
int prime[N], phi[N], f[N], modification[M];
ll sum[N];
bool p[N], vis[N];

inline void init(int n){
	int cnt = 0;
	p[0] = p[1] = true;
	phi[1] = 1;
	for (register int i = 2; i <= n; i++){
		if (!p[i]){
			prime[++cnt] = i;
			phi[i] = i - 1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] <= n; j++){
			int t = i * prime[j];
			p[t] = true;
			if (i % prime[j] == 0){
				phi[t] = phi[i] * prime[j];
				break;
			}
			phi[t] = phi[i] * (prime[j] - 1);
		}
	}
	for (register int i = 1; i <= n; i++){
		sum[i] = (sum[i - 1] + (ll)i * i % mod * phi[i] % mod) % mod;
	}
}

int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}

inline ll sqr(ll n){
	return n * n % mod;
}

int main(){
	int m, n, modification_cnt = 0;
	scanf("%d %d", &m, &n);
	init(n);
	for (register int i = 1; i <= m; i++){
		int a, b, k, d;
		ll x, ans;
		scanf("%d %d %lld %d", &a, &b, &x, &k);
		d = gcd(a, b);
		f[d] = x / (a / d) / (b / d) % mod;
		ans = sqr((ll)k * (k + 1) / 2 % mod);
		if (!vis[d]){
			vis[d] = true;
			modification[++modification_cnt] = d;
		}
		for (register int j = 1; j <= modification_cnt; j++){
			ans = ((ans + sum[k / modification[j]] * (f[modification[j]] - (ll)modification[j] * modification[j] % mod) % mod) % mod + mod) % mod;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：STPGUY (赞：1)

# [小Q的表格](https://www.luogu.com.cn/problem/P3700)

## 题目描述

给定一个表格，满足：

- $\forall a,b\;f(a,b)=f(b,a)$
- $\forall a,b\;b\cdot f(a,a+b)=(a+b)\cdot f(a,b)$

有$m$次操作：

- 每次操作修改$f(a,b)$的值，为了使整个表满足条件，所以要修改的点还挺多的。
- 然后让你输出$k*k$的范围内的数的和。

## Solution

对于性质$\forall a,b\;b\cdot f(a,a+b)=(a+b)\cdot f(a,b)$，观察发现它可以转化一下：

![](https://s1.ax1x.com/2020/09/21/wqmXWt.png)

所以可以得到一个结论：

![](https://s1.ax1x.com/2020/09/21/wqmOJI.png)

那么就得到了一个线性的表了。

那么再回头看看题目要求的问题。

![](https://s1.ax1x.com/2020/09/21/wqmvSP.png)

考虑:

$$
\sum_{i=1}^ni[\gcd(i,n)=1]=\frac{n\times\varphi(n)}{2}
$$
所以原式可以化为:

$$
ans= \sum_{d=1}^ng(d)\sum_{i=1}^{\left\lfloor\frac nd\right\rfloor}i^2\varphi(i)
$$
那么这个时候我们发现，后面的是可以直接$O(1)$求解的（先预处理，就可以直接查询）。

然而前面那个$g(d)$是会发生改变的。

这个可以用树状数组或者是分块来维护。

这两个理论上是可以过的，实测再[loj](https://loj.ac)是可以过的。

洛谷似乎有点卡常，要$TLE$一两个点。

[树状数组实现](https://loj.ac/submission/937220)，[分块实现](https://loj.ac/submission/937110)

因为有点慢，就不细说了，代码链接里应该是可以看的。

## 进一步考虑

我们每次修改的值其实是$f(\gcd(a,b))$，所以真时要改的值并不多。

- 那么我们可以先求出原表中$k*k$范围内的值

- 再求出修改的值对答案贡献相对原来的偏移量

$$
\Delta ans=\sum_{i=1}^{cnt}(changed(i)-pre^2(i))\sum_{j=1}^{\left\lfloor\frac ki\right\rfloor}j^2\varphi(j)
$$

所以这个就是$O(cnt)$的复杂度。

然后又是可以证明对于所有的$\gcd(n,m)$的个数时处于$\log n\sim\sqrt n$这个级别。

所以修改大概就是$O(m\log n)\sim O(m\sqrt n)$。

然而实际跑下来要比这快得。

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const ll maxn = 4e6 + 10;
const ll mod = 1e9 + 7;

inline ll __read() {
    ll x(0);
    char o(getchar());
    while (o < '0' || o > '9') o = getchar();
    for (; o >= '0' && o <= '9'; o = getchar()) x = (x << 1) + (x << 3) + (o ^ 48);
    return x;
}

ll size, n, q, len;
ll pr[maxn], phi[maxn], f[maxn], cnt;
ll stk[maxn], upt[maxn], top;
bool vis[maxn], che[maxn];

inline void init() {
    phi[1] = 1;
    for (ll i = 2; i <= n; ++i) {
        if (!vis[i])
            pr[++cnt] = i, phi[i] = i - 1;
        for (ll j = 1; j <= cnt && i * pr[j] <= n; ++j) {
            vis[i * pr[j]] = 1;
            if (i % pr[j]) {
                phi[i * pr[j]] = phi[i] * phi[pr[j]];
            } else {
                phi[i * pr[j]] = phi[i] * pr[j];
                break;
            }
        }
    }
    for (ll i = 1; i <= n; ++i) f[i] = (f[i - 1] + i * i % mod * phi[i] % mod) % mod;
}

inline ll sum(ll x) { return x * (x + 1) / 2 % mod; }

ll gcd(ll x, ll y) {
    if (!y)
        return x;
    return gcd(y, x % y);
}

signed main() {
    q = __read(), n = __read();
    init();
    while (q--) {
        ll a = __read(), b = __read(), x = __read(), k = __read(), d = gcd(a, b);

        upt[d] = x / (a / d) / (b / d) % mod;
        if (!che[d]) {
            stk[++top] = d;
            che[d] = 1;
        }

        ll ans(sum(k));
        ans = ans * ans % mod;

        for (ll i = 1; i <= top; ++i) {
            d = stk[i];
            ans = (ans + ((upt[d] - d * d % mod) % mod + mod) % mod * f[k / d] % mod) % mod;
        }
        printf("%lld\n", ans);
    }
}
```


---

## 作者：I_am_Accepted (赞：1)

这题黑？2.04s 抢到最优解。

题面给的两个条件就是辗转相除（减），进一步当 $\gcd(x',y')=\gcd(x,y)$，则
$$\frac{f(x,y)}{xy}=\frac{f(x',y')}{x'y'}$$
恒成立。

所以变量只有 $\forall x\in[1,n]\cap\mathbb Z,f(x,x)$。

对于询问有
$$\begin{aligned}
&
\sum_{i=1}^m\sum_{j=1}^mf(i,j)
\\=&
\sum_{i=1}^mf(i,i)\sum_{j=1}^{\lfloor m/i\rfloor}\sum_{k=1}^{\lfloor m/i\rfloor}jk[\gcd(j,k)=1]
\\=&
\sum_{i=1}^mf(i,i)\sum_{j=1}^{\lfloor m/i\rfloor}j^2\varphi(j)
\end{aligned}$$
后面可以线性筛线性预处理，前面按除 $m$ 的商整除分块。

$f(i,i)$ 用分块，记录块内前缀和，单点改复杂度为块长，区间查询复杂度为包含在区间内整块个数。

块长取 $\sqrt n$，复杂度 $O(n+m\sqrt n)$。

---

## 作者：intel_core (赞：0)

 我们首先把题目中的第二个式子变一下形式成 $\frac{f(a,b)}{b}=\frac{f(a,a+b)}{a+b}$。再结合第一个条件，再次变形成 $\frac{f(b,a)}{a\times b}=\frac{f(a,b)}{a\times b}=\frac{f(a,a+b)}{a\times (a+b)}$，接着不难得到对于所有 $\gcd(a,b)$ 相同的 $(a,b)$，都有 $\frac{f(a,b)}{a\times b}$ 为定值。
 
记 $g(d)=\frac{f(a,b)}{a\times b}|\gcd(a,b)=d$。我们考虑最终答案的形式，即为 $\sum_{x=1}^k\sum_{y=1}^k f(x,y)=\sum_{d=1}^k g(d) \sum_{x=1}^{ \lfloor \frac{k}{d} \rfloor } \sum_{y=1}^{ \lfloor \frac{k}{d} \rfloor} xy[\gcd(x,y)=1]$。

不难看出，后面形如 $\sum_{x=1}^k\sum_{y=1}^k xy[\gcd(x,y)=1]$ 这个东西通过算两次转化一下就是 $P(k)=\sum_{i=1}^k \phi(i)\times i^2$。这个可以线性预处理出来。

我们考虑根号分治求答案，不难发现求和式里面的 $d$ 一共只有 $O(\sqrt{k})$ 种取值，所以我们枚举每个可能的取值，对于每个取值，我们相当于要对 $g(i)$ 进行一次区间求和。

我们总共对 $g(i)$ 要进行 $m$ 次修改，$O(m\sqrt{n})$ 次查询。我们直接使用 $O(\sqrt{n})-O(1)$ 的分块即可做到 $O(m\sqrt{n})$ 的复杂度。

（下面的实现是 $O(m\sqrt{n}\log n)$ 的树状数组）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=4e6+10;
#define int long long
const int MOD=1e9+7;
const int Inv2=5e8+4;
int n,q,a[NR],vis[NR],prime[NR],tot,sum[NR],phi[NR],cnt[NR];

int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=res*x%MOD;
		x=x*x%MOD;y>>=1;
	}
	return res;
}
int Inv(int x){return qpow(x%MOD,MOD-2);}
int gcd(int x,int y){
	if(!x||!y)return x|y;
	return gcd(y,x%y);
}
void init(){
	phi[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i])prime[++tot]=i,phi[i]=i-1;
		for(int j=1;j<=tot&&i*prime[j]<=n;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
	for(int i=1;i<=n;i++)
		sum[i]=(sum[i-1]+phi[i]*i%MOD*i)%MOD,cnt[i]=(cnt[i-1]+i*i)%MOD;
}

int c[NR];
int lowbit(int x){return x&(-x);}
void modify(int x,int y){
	while(x<=n){
		c[x]=(c[x]+y)%MOD;
		x+=lowbit(x);
	}
}
int ask(int x){
	int res=0;
	while(x){
		res=(res+c[x])%MOD;
		x-=lowbit(x);
	}
	return res;
}
int calc(int l,int r){return ask(r)-ask(l-1);}

signed main(){
	cin>>q>>n;init();
	for(int i=1;i<=n;i++)modify(i,a[i]=i*i%MOD);
	while(q--){
		int x,y,z,k;cin>>x>>y>>z>>k;
		int d=gcd(x,y),v=(z%MOD)*Inv(x*y)%MOD*(d*d%MOD)%MOD;
		modify(d,v-a[d]);a[d]=v;
		int ans=0;
		for(int l=1,now,r;l<=k;l=r+1){
			now=k/l;r=k/now;
			ans=(ans+calc(l,r)*sum[now]%MOD)%MOD;
		}
		cout<<(ans+MOD)%MOD<<endl;
	}
	return 0;
}
```

---

## 作者：FjswYuzu (赞：0)

先简单的列出性质：

1. $f(a,b)=f(b,a)$；   
2. $b f(a,a+b) = (a+b)f(a,b)$。

先考虑这个 $f$ 两个恒等式的形式。将 $f$ 视作一个状态，那么有转移 $(a,a+b) \to (a,b)$，且 $(a,b) \to (b,a)$。

不难联想到辗转相减求最大公约数的过程，最终 $(a,b)$ 一定可以转移到 $(\gcd(a,b),\gcd(a,b))$ 上。

那么，表格上的所有数都可以用对应的一个对角线上的数乘上一个系数表示。修改一个数的话，我们只用管它的对角线元素就行了。

注意到 $b f(a,a+b) = (a+b)f(a,b)$，进行简单处理后可以得到 $\dfrac{f(a,a+b)}{a(a+b)} = \dfrac{f(a,b)}{ab}$。于是思考辗转相减的过程，易得 $\dfrac{f(a,b)}{ab} = \dfrac{f(\gcd(a,b),\gcd(a,b))}{\gcd(a,b)^2}$。

下面的 $i/j$ 均表示 $\left\lfloor \dfrac{i}{j} \right\rfloor$。

然后求和的工作话，我们先记 $g(i) = f(i,i)$，直接推式子：

$$
\begin{aligned}
\sum_{i=1}^k \sum_{j=1}^k f(i,j)
&= \sum_{d=1}^n g(d) \sum_{i=1}^n \dfrac{i}{d} \sum_{j=1}^n \dfrac{j}{d} [\gcd(i,j)=d] \\
&= \sum_{d=1}^n g(d) \sum_{i=1}^{n/d} i \sum_{j=1}^{n/d} j[\gcd(i,j)=1]
\end{aligned}
$$

注意到后面的 $\displaystyle \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} j[\gcd(i,j)=1]$ 看起来就非常可以预处理。研究一下这个东西。

首先这个上界不优美。注意到在原式中，$i=j \neq 1$ 的时候不会造成贡献，并且 $i \neq j$ 的贡献会算两次。我们强制 $i>j$，然后乘 $2$ 即可。（下面用 $\frac{i}{D}$ 的原因是其一定是一个整数）

$$
\begin{aligned}
2\sum_{j=1}^i j[\gcd(i,j)=1]
&= 2\sum_{j=1}^i j \sum_{D|\gcd(i,j)} \mu(D) \\
&= 2\sum_{D|i} \mu(D) \sum_{j=1}^{\frac{i}{D}} jD \\
&= 2\sum_{D|i} \mu(D) D \sum_{j=1}^{\frac{i}{D}} j \\
&= 2\sum_{D|i} \mu(D) D \dfrac{\left(\frac{i}{D}+1\right)\times \frac{i}{D}}{2} \\
&= \sum_{D|i} \mu(D) D \left(\frac{i}{D}+1\right)\times \frac{i}{D} \\
&= i\sum_{D|i} \mu(D) \left(\frac{i}{D}+1\right)
\end{aligned}
$$

推到这里基本可以结束了。注意到和式是 $\mu * (id+1)$ 的形式，那么这个函数就相当于 $\varphi + \epsilon$。但是注意到，在 $i=1$ 的时候，我们将 $i=j=1$ 的情况算了两次……处理方式是直接把 $\epsilon$ 直接阉割了，这样就不会重了。

那么继续推之前的式子：

$$
\begin{aligned}
\sum_{i=1}^k \sum_{j=1}^k f(i,j)
&= \sum_{d=1}^n g(d) \sum_{i=1}^n \dfrac{i}{d} \sum_{j=1}^n \dfrac{j}{d} [\gcd(i,j)=d] \\
&= \sum_{d=1}^n g(d) \sum_{i=1}^{n/d} i^2 \varphi(i)
\end{aligned}
$$

后面的和式是个前缀和形式。然后预处理 $i^2 \varphi(i)$ 的前缀和非常简单，外层直接整除分块做就可以了。

但是还有个修改。这是个方程形式，采用之前的那个关于 $f(a,b),g(\gcd(a,b))$ 的等式，采用树状数组求出新的 $g(\gcd(a,b))$，直接改就行了。求 $g$ 的区间和也可以用树状数组。

但是有点慢……还凑合，就这样吧。时间复杂度 $O(n \sqrt n \log n)$。不懂这个题的神性在哪里。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
char buf[1<<18],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
void write(LL x)
{
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
const LL MOD=1e9+7;
inline LL Add(LL x,LL y){return x+y>=MOD?x+y-MOD:x+y;}
inline LL Sub(LL x,LL y){return x<y?x-y+MOD:x-y;}
inline LL Mul(LL x,LL y){return 1ll*x*y%MOD;}
LL QuickPow(LL x,LL p)
{
	LL ans=1,base=x;
	while(p)
	{
		if(p&1)	ans=Mul(ans,base);
		base=Mul(base,base);
		p>>=1;
	}
	return ans;
}
LL N,m;
inline LL lowbit(LL x){return x&(-x);}
struct BinaryIndexedTree{
	LL tr[4000005];
	void modify(LL x,LL val){for(LL i=x;i<=N;i+=lowbit(i))	tr[i]=Add(tr[i],val);}
	LL query(LL x){LL ans=0;for(LL i=x;i;i^=lowbit(i))	ans=Add(ans,tr[i]);return ans;}
	LL query(LL l,LL r){return Sub(query(r),query(l-1));}
}bit;
LL cnt,prime[4000005];
bool vis[4000005];
LL phi[4000005],f[4000005];
void shai(LL up)
{
	vis[phi[1]=1]=true;
	for(LL i=2;i<=up;++i)
	{
		if(!vis[i])	phi[i]=i-1,prime[++cnt]=i;
		for(LL j=1;j<=cnt && i*prime[j]<=up;++j)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)
			{
				phi[i*prime[j]]=Mul(phi[i],prime[j]);
				break;
			}
			phi[i*prime[j]]=Mul(phi[i],prime[j]-1);
		}
	}
	for(LL i=1;i<=up;++i)	f[i]=Mul(Mul(i,i),phi[i]),f[i]=Add(f[i],f[i-1]);
}
LL gcd(LL a,LL b){return !b?a:gcd(b,a%b);}
LL g[4000005];
int main(){
	shai(4000000);
	m=read(),N=read();
	for(LL i=1;i<=N;++i)	bit.modify(i,g[i]=Mul(i,i));
	while(m-->0)
	{
		LL a=read(),b=read(),x=read(),n=read();
		LL d=gcd(a,b);
		bit.modify(d,MOD-g[d]);
		long long tmp=x;
		tmp/=a/d;
		tmp/=b/d;
		tmp%=MOD;
		g[d]=tmp;
		bit.modify(d,g[d]);
		LL ans=0;
		for(LL l=1,r;l<=n;l=r+1)	r=n/(n/l),ans=Add(ans,Mul(f[n/l],bit.query(l,r)));
		write(ans),puts("");
	}
	return 0;
}
```

---


# 毒瘤之神的考验

## 题目背景

Salamander 的家门口是一条长长的公路。


又是一年春天将至，Salamander 发现路边长出了一排毒瘤！

Salamander 想带一些毒瘤回家，但是，这时毒瘤当中钻出来了一个毒瘤之神！

毒瘤之神：你想要带毒瘤走吗？想要带走毒瘤，就必须回答我的问题！如果答不出来的话，你还是乖乖回家吧！

## 题目描述

毒瘤之神会问 $T$ 次，每次给定 $n, m$，Salamander 需要回答出 $\left( \sum_{i=1}^n \sum_{j=1}^m \varphi(ij) \right)\! \bmod 998244353$。

Salamander 这么辣鸡当然不会做啦，于是把问题丢给了你。

## 说明/提示

对于 $40\%$ 的数据，$T=1$，$n, m \le {10}^5$。  
对于 $50\%$ 的数据，$T \le {10}^3$，$n, m \le {10}^5$。  
对于另外 $10\%$ 的数据，$T \le {10}^4$，$n = m \le {10}^5$。  
对于 $100\%$ 的数据，$1 \le T \le {10}^4$，$1 \le n, m \le {10}^5$。

## 样例 #1

### 输入

```
3
1 1
2 2
3 3```

### 输出

```
1
5
19```

# 题解

## 作者：YLWang (赞：35)

## 请务必在博客中查看

莫比乌斯反演与杜教筛详解可以见[我的博客](https://www.luogu.com.cn/blog/YLWang/post-xue-xi-bi-ji-mu-bi-wu-si-fan-yan)。非常详细，大家可以来围观围观。

--- 
## [P4240 毒瘤之神的考验](https://www.luogu.com.cn/problem/P4240)

$$
\begin{aligned} 

\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} \varphi(ij)

&= \sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} \frac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}

\\&= \sum\limits_{d=1}^{n}\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} \frac{\varphi(i)\varphi(j)d[\gcd(i,j)=d]}{\varphi(d)}

\\&= \sum\limits_{d=1}^{n}\frac{d}{\varphi(d)}\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m }\varphi(i)\varphi(j)[\gcd(i,j)=d]

\\&= \sum\limits_{d=1}^{n}\frac{d}{\varphi(d)}\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor}\mu(t)\cdot \sum\limits_{i=1}^{\lfloor\frac{n}{dt}\rfloor }\sum\limits_{j=1}^{\lfloor\frac{m}{dt}\rfloor }\varphi(idt)\varphi(jdt)

\\&= \sum\limits_{d=1}^{n}\frac{d}{\varphi(d)}\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor}\mu(t)\cdot \sum\limits_{i=1}^{\lfloor\frac{n}{dt}\rfloor }\sum\limits_{j=1}^{\lfloor\frac{m}{dt}\rfloor }\varphi(idt)\varphi(jdt)

\\&= \sum\limits_{k=1}^{n}\sum\limits_{d|k} \frac{d\cdot\mu(\frac{k}{d})}{\varphi(d)} \sum\limits_{i=1}^{\lfloor\frac{n}{k}\rfloor }\varphi(ik)\sum\limits_{j=1}^{\lfloor\frac{m}{k}\rfloor }\varphi(jk) 

\end{aligned}
$$

令 
$$
\begin{aligned}
f(n) = \sum\limits_{d|n} \frac{d\cdot\mu(\frac{k}{d})}{\varphi(d)}
\end{aligned}
$$

则可以套路地枚举倍数预处理出来。这一部分的复杂度是 $O(n \operatorname{ln} n)$.

再令
$$
\begin{aligned}
g(k, n) = \sum\limits_{i=1}^{n}\varphi(ik)
\end{aligned}
$$

我们有递推式
$$
\begin{aligned}
g(i, j) = g(i, j-1) +\varphi(ij)
\end{aligned}
$$

因为$k\cdot n \leqslant 10^5$, 所以这一部分的复杂度为 $O(n \operatorname{ln} n)$.

我们把原式用 $f$ 与 $g$ 代入。

$$
\begin{aligned} 

\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} \varphi(ij)

&=\sum\limits_{k=1}^{n}f(k)\cdot g(k, \lfloor\frac{n}{k}\rfloor )\cdot g(k,\lfloor\frac{m}{k}\rfloor )

\end{aligned}
$$

然后你会发现这个时候 $g$ 里面是带 $k$ 的不能整除分块。

还是很套路的把整个式子用参数表示出来。令：
$$
\begin{aligned} 

t(a, b,n) = \sum\limits_{k=1}^{n}f(k)\cdot g(k, a)\cdot g(k, b)

\end{aligned}
$$

那么最终的结果就是一个差分形式（其实 $l$ 和 $r$ 是整除分块的两端。）
$$
\begin{aligned} 

\sum\limits_{\lfloor\frac{n}{l}\rfloor = \lfloor\frac{n}{r}\rfloor \& \lfloor\frac{m}{l}\rfloor = \lfloor\frac{m}{r}\rfloor} t(\lfloor\frac{n}{r}\rfloor, \lfloor\frac{m}{r}\rfloor,r) - t(\lfloor\frac{n}{r}\rfloor, \lfloor\frac{m}{r}\rfloor,l)

\end{aligned}
$$
那么问题就是如何求出 $t$ 数组了。容易发现直接全部预处理会 T 到原地升天。

我们发现这实际上是一个预处理和查询的平衡，所以引出根号分治那一套理论。

因为我们发现，$l$ 和 $r$ 越大，相同一段长度就越大，暴力的复杂度就相对越劣（意思就是用整除分块处理越快）。我们考虑在 $l$ 和 $r$ 较小的时候暴力，否则预处理。


我们设一个阈值 $S$，将所有 $t(1,1,1) - t(S,S,n)$ 的 $t$ 值预处理出来。

预处理的式子就是 

$$ 
t(j,k,i)=t(j,k,i-1) + f(i)\cdot g(i, j)\cdot g(i, k)
$$


然后查询的时候，对于所有 $\lfloor\dfrac{n}{r}\rfloor \leqslant S$ 可以直接查询。否则，可得知 $ r \leqslant \lfloor\dfrac{n}{S}\rfloor$。 这个时候就可以暴力计算了.

总的复杂度 $O(n \ln n + nB^2 + T(\sqrt{n} +\dfrac{n}{B}))$。 至于如何调整 $B$ 参照 Ynoi。


这个题真的是一个好题，可谓是推式子与平衡思想结合的极致。

代码链接：https://www.luogu.com.cn/paste/fk563xya

---

## 作者：y2823774827y (赞：27)

$\Longrightarrow\Longrightarrow\Longrightarrow$**[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10235949.html)**

## 题目
[P4240 毒瘤之神的考验](https://www.luogu.org/problemnew/show/P4240)

神仙题$emmm$

## 前置

首先有一个很神奇的性质：

$\varphi(ij)=\dfrac{\varphi(i)\varphi(j)gcd(i,j)}{\varphi(gcd(i,j))}$

证明：

$$\varphi(i)\varphi(j) =i\prod\limits_{p|i}\frac{p-1}{p}j\prod\limits_{p|j}\frac{p-1}{p}$$


$$~~~~~~~~~~~~~~~~~~~~~= ij\prod\limits_{p|ij}\frac{p-1}{p}\prod\limits_{q|gcd(i,j)}\frac{p-1}{p}$$

$$\therefore \varphi(i)\varphi(j)gcd(i,j)=\varphi(ij)\varphi(gcd(i,j))$$

## 具体做法

求$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\varphi(i,j)$

我们最终是能得到：$$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\varphi(ij)=\sum\limits_{T=1}^n\sum\limits_{k|T}\mu(\frac{T}{k})\frac{k}{\varphi(k)}\sum\limits_{i=1}^{\lfloor\frac{n}{T}\rfloor}\varphi(iT)\sum\limits_{j=1}^{\lfloor\frac{m}{T}\rfloor}\varphi(jT)$$

网上好像很多人的证明都有些错误

证明：

$$Ans=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\varphi(ij)$$

$$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=\sum\limits_{i=1}^n \sum\limits_{j=1}^m \varphi(i)\varphi(j)\frac{gcd(i,j)}{\varphi(gcd(i,j))}$$
$$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=\sum\limits_{d=1}^n\sum\limits_{i=1}^n\sum\limits_{j=1}^m\varphi(i)\varphi(j)\frac{d}{\varphi(d)}[gcd(i,j)=d]$$

$$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=\sum\limits_{d=1}^n\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(id)\varphi(jd)\frac{d}{\varphi(d)}[gcd(i,j)=1]$$
$$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=\sum\limits_{d=1}^n\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(id)\varphi(jd)\frac{d}{\varphi(d)}\sum\limits_{k|i,k|j}\mu(k)$$
$$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=\sum\limits_{d=1}^n\frac{d}{\varphi(d)}\sum\limits_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\sum\limits_{i=1}^{\lfloor\frac{n}{dk}\rfloor}\varphi(idk)\sum\limits_{j=1}^{\lfloor\frac{m}{dk}\rfloor}\varphi(jdk)$$
$$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=\sum\limits_{T=1}^n\sum\limits_{k|T}\mu(\frac{T}{k})\frac{k}{\varphi(k)}\sum\limits_{i=1}^{\lfloor\frac{n}{T}\rfloor}\varphi(iT)\sum\limits_{j=1}^{\lfloor\frac{m}{T}\rfloor}\varphi(jT)$$

看我们最终得到的式子，多次查询完全在线做，参数这么多时间肯定承受不住

$\sum\limits_{k|T}\mu(\frac{T}{k})\frac{k}{\varphi(k)}$设有函数$F(x)=\sum\limits_{k|x}\mu(\frac{x}{k})\frac{k}{\varphi(k)}$再普通不过就不多讲了

$\sum\limits_{i=1}^{\lfloor\frac{n}{T}\rfloor}\varphi(iT)$参数有两个，设有函数$G(y,x)=\sum\limits_{i=1}^{x}\varphi(iy)$

显然$G(y,x)=G(y,x-1)+\varphi(xy)$

整个式子设为函数$S(y,z,x)=\sum\limits_{T=1}^x\sum\limits_{k|T}\mu(\frac{T}{k})\frac{k}{\varphi(k)}\sum\limits_{i=1}^{y}\varphi(iT)\sum\limits_{j=1}^{z}\varphi(jT)$

显然$S(y,z,x)=S(y,z,x-1)+F[x]*G(x,y)*G(x,z)$

$F(x)(x<=n),G(y,x)(x<=n,y<=B),S(y,z,x)(x<=n,y,z<=B)$

B是自己取的任意参数，或许你会想$\frac{n}{T}>B$怎么办，$\Rightarrow T<\frac{n}{B}$，这部分暴力算，后面分块

```cpp
#include<cstring>
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#include<vector>
using namespace std;
typedef long long LL;
const int B=35;
const int maxn=1e5+9;
const LL p=998244353;
inline int Read(){
    int x(0),f(1); char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f=-1; c=getchar();
    }
    while(c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
bool visit[maxn];
int mu[maxn],phi[maxn],prime[maxn];
int *G[maxn],*S[B+1][B+1],F[maxn];
int inv[maxn];

inline void First(LL N){
    mu[1]=phi[1]=inv[1]=1;
    int tot(0);
    for(int i=2;i<=N;++i){
        if(!visit[i]){
            prime[++tot]=i,
            mu[i]=-1,
            phi[i]=i-1;
        }
        for(int j=1;j<=tot&&i*prime[j]<=N;++j){
            visit[i*prime[j]]=true;
            if(i%prime[j]==0){
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }else{
                phi[i*prime[j]]=phi[i]*phi[prime[j]],
                mu[i*prime[j]]=-mu[i];
            }
        }
    }
    for(int i=2;i<=N;++i)
        inv[i]=p-1ll*p/i*inv[p%i]%p;
    for(int i=1;i<=N;++i)
        for(int j=1;j*i<=N;++j)
            F[i*j]=1ll*(1ll*F[i*j]+1ll*i*inv[phi[i]]%p*mu[j]%p)%p;
    for(int i=1;i<=N;++i){
        G[i]=new int [N/i+1];
        G[i][0]=0;
        for(int j=1;j<=N/i;++j)
            G[i][j]=1ll*(1ll*G[i][j-1]+1ll*phi[j*i])%p;
    }
    for(int j=1;j<=B;++j)
        for(int k=1;k<=B;++k){
        	int len(N/(max(j,k)));
        	S[j][k]=new int [len+1];
        	S[j][k][0]=0;
        	for(int i=1;i<=len;++i)
        		S[j][k][i]=1ll*(1ll*S[j][k][i-1]+1ll*F[i]*G[i][j]%p*G[i][k]%p)%p;
        }
}
inline LL Solve(int n,int m){
    if(n>m)
        swap(n,m);
    LL ans(0);
    for(int i=1;i<=m/B;++i)
        ans=(ans+1ll*F[i]*G[i][n/i]%p*G[i][m/i]%p)%p;
    for(int l=m/B+1,r;l<=n;l=r+1){
        r=min(n/(n/l),m/(m/l));
        ans=(ans+1ll*(S[n/l][m/l][r]-S[n/l][m/l][l-1]+p)%p)%p;
    }
    return ans;
}
int main(){
    int T=Read();
    First(100000);
    while(T--){
        int n(Read()),m(Read());
        printf("%lld\n",Solve(n,m));
    }
    return 0;
}/*
3
1 1
2 2
3 3

1 5 19
*/
```

---

## 作者：1saunoya (赞：11)

神仙莫比乌斯反演。

有个结论。

$\varphi(i\times j) = \huge{\left(\frac{\varphi(i) \times \varphi(j) \times \gcd(i,j)}{\varphi(\gcd(i,j))}\right)}$

首先假设 $n\leq m$

$\sum_i \sum_j \varphi(i\times j) = \sum_i \sum_j {\large \left(\frac{\varphi(i) \times \varphi(j) \times \gcd(i,j)}{\varphi(\gcd(i,j))}\right)}$

枚举$\gcd$！

$\sum_d  \sum_i \sum_j \frac{\varphi(i) \times \varphi(j) \times \gcd(i,j)}{\varphi(\gcd(i,j))}[\gcd(i,j) = d]$

然后
$\sum_d {\left(\frac{d}{\varphi(d)}\right)} \sum_i^{\frac{n}{d}} \sum_j^{\frac{m}{d}}\varphi(i\times d) \varphi(j\times d)[\gcd(i,j) = 1]$

发现 $\gcd$ 可以用 $\mu$ 搞

$\sum_{d|x} \mu(d) = [x=1]$

$\sum_d {\left(\frac{d}{\varphi(d)}\right)}\sum_i^{\frac{n}{d}} \sum_j^{\frac{m}{d}}\varphi(i\times d) \varphi(j\times d){\left(\sum_{k|\gcd(i,j)} \mu(k)\right)}$


然后顺手枚举一波 $k$！

$\sum_d {\left(\frac{d}{\varphi(d)}\right)} \sum_{k}^{\frac{n}{d}}\mu(k) \sum_{i}^{\frac{n}{kd}}\sum_j^{\frac{m}{kd}}\varphi(i\times  kd) \times \varphi(j \times kd)$

改变枚举顺序，令 $T=k\times d$

$\sum_T \sum_{d|T} \mu(\frac{T}{d}) \frac{d}{\varphi(d)} \sum_i^{\frac{n}{T}} \sum_j^{\frac{m}{T}} \varphi(i\times T) \times \varphi(j\times T)$


然后我们搞搞 $F(T) = \sum_T \sum_{d|T} \mu(\frac{T}{d}) \frac{d}{\varphi(d)}$

$(T, n, m) = \sum_i^{\frac{n}{T}} \sum_j^{\frac{m}{T}} \varphi(i\times T) \times \varphi(j\times T)$

发现其实可以令 $G(x, y) = \sum_i^x \varphi(i\times y)$

$G(x, y) = G(x - 1, y) +  \varphi(xy)$

然后整个式子就变成了 $\sum_T F(T)\times G(\frac{n}{T},T) \times G(\frac{m}{T},T)$

$G$ 可以直接暴力算，因为这个玩意是调和级数的。

但是发现这个答案数组不能搞得太大，所以需要一个根号分治，$\leq B$ 的部分暴力，$\geq B+1$ 的整除分块。



---

## 作者：Salamander (赞：8)

大意：求$\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)\ mod\ 998244353$。

比较难想到的数学题。

注意到本题为多组询问，并且$n$、$m$不算大，所以可以想到用分块打表的方式优化。

(下面的说明中$n$和$m$的大小关系不重要，可以默认$n\leq m$)

首先推公式：

令$gcd(i,j)=\xi(i,j)$，
那么
$\displaystyle{\varphi(ij)=\frac{\varphi(i)\varphi(j)\xi(i,j)}{\varphi(\xi(i,j))}}$

莫比乌斯反演，那么原式=$\displaystyle{\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)=\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\varphi(j)\xi(i,j)}{\varphi(\xi(i,j))}}$

$\displaystyle=\sum_{z=1}^n\frac{z}{\varphi(z)}\sum_{z|d}\mu\left(\frac{d}{z}\right)\left(\sum_{d|k}^n\varphi(k)\right)\left(\sum_{d|k}^m\varphi(k)\right)$

$\displaystyle=\sum_{d=1}^n\left(\sum_{z|d}\frac{z}{\varphi(z)}\mu\left(\frac{d}{z}\right)\right)\left(\sum_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\varphi(dk)\right)\left(\sum_{k=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\varphi(dk)\right)$

不妨记$\displaystyle G(i,j)=\sum_{k=1}^i\varphi(jk)\ \ \ \ \ (ij\leq n)$

那么原式转化为

$\displaystyle\sum_{d=1}^n\left(\sum_{z|d}\frac{z}{\varphi(z)}\mu\left(\frac{d}{z}\right)\right)G(\lfloor\frac{n}{d}\rfloor,d)G(\lfloor\frac{m}{d}\rfloor,d)$

注意到$G$数组由于$ij\leq n$所以实际有用的空间只需要$O(n)$，于是我们可以用动态数组的方式将$10^5$以内的$G$数组预处理然后存下来，预处理复杂度$O(n\log n)$。

同样，对于不同的$d$，$\displaystyle\sum_{z|d}\frac{z}{\varphi(z)}\mu\left(\frac{d}{z}\right)$也是可以预处理出来的。

然后我们考虑怎么询问。

熟悉莫比乌斯反演题目的人应该知道，$\lfloor\frac{n}{d}\rfloor$这样的东西的不同取值为$O(\sqrt n)$种。

我们可以预处理一部分答案：

令

$\displaystyle T(n,i,j)=\sum_{d=1}^n\left(\sum_{z|d}\frac{z}{\varphi(z)}\mu\left(\frac{d}{z}\right)\right)G(i,d)G(j,d)\ \ \ \ \ (i,j\leq B)$

$B$为我们预处理答案的上界，是待定的，之后根据复杂度可以计算出最优值。

那么我们在$\lfloor\frac{n}{d}\rfloor=i,\lfloor\frac{m}{d}\rfloor=j$时的答案就是$T(up,i,j)-T(down-1,i,j)$，$up$表示$\lfloor\frac{n}{d}\rfloor=i,\lfloor\frac{m}{d}\rfloor=j$时$d$的最大值，$down$表示$\lfloor\frac{n}{d}\rfloor=i,\lfloor\frac{m}{d}\rfloor=j$时$d$的最小值，跟那种莫比乌斯反演的模板题的计算前缀和然后差分很像。

但是由于$T$数组不能开太大，$T$的空间为$O(nB^2)$，所以我们只能在$\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor\leq B$时直接调用$T$数组，每次询问在这一部分的复杂度为$O(\sqrt n)$。

那么对于$\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor>B$，我们会发现一定有$d\leq\lfloor\frac{n}{B}\rfloor$，我们可以直接暴力算出这一部分的答案，每次询问复杂度为$O(\lfloor\frac{n}{B}\rfloor)$。

所以，我们最终的复杂度为$O(n\log n+nB^2+T(\sqrt n+\lfloor\frac{n}{B}\rfloor))$。

计算一下，发现$B=T^{\frac{1}{3}}$左右的时候能取到较优的复杂度，稍微偏大一点好像比较快一点。

代码还是比较好写的：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define M(x) ((x)>=mod?((x)-mod):(x))
#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
    T f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
    x*=f;
}

typedef long long LL;
const int maxn=100010,B=35,mod=998244353;
int Test,n,m,phi[maxn],mu[maxn],prime[maxn],cnt;
int *G[maxn],F[maxn],*T[B+1][B+1],inv[maxn];
bool ok[maxn];

void Init(int n){
    mu[1]=phi[1]=inv[1]=1;
    For(i,2,n){
        if(!ok[i]){
            prime[++cnt]=i;
            mu[i]=-1;phi[i]=i-1;
        }
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++){
            ok[i*prime[j]]=true;
            if(i%prime[j]){
                mu[i*prime[j]]=-mu[i];
                phi[i*prime[j]]=phi[i]*(prime[j]-1);
            }
            else{
                mu[i*prime[j]]=0;
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
        }
    }
    For(i,2,n) inv[i]=mod-1LL*(mod/i)*inv[mod%i]%mod;
    For(i,1,n) for(int j=i;j<=n;j+=i)
        F[j]=M(F[j]+M(1LL*mu[j/i]*i*inv[phi[i]]%mod+mod));
    For(i,1,n){
        G[i]=new int [(n/i)+1];G[i][0]=0;
        For(j,1,n/i) G[i][j]=M(G[i][j-1]+phi[i*j]);
    }
    For(j,1,B) For(k,j,B){
        int len=n/Max(j,k);
        T[j][k]=new int [len+1];T[j][k][0]=0;
        For(i,1,len) T[j][k][i]=M(T[j][k][i-1]+1LL*F[i]*G[i][j]%mod*G[i][k]%mod);
    }
}
LL Solve(int n,int m){
    if(n>m)swap(n,m);
    LL res=0;
    For(i,1,m/B) res=M(res+1LL*F[i]*G[i][n/i]%mod*G[i][m/i]%mod);
    for(int i=m/B+1,nxt;i<=n;i=nxt+1){
        nxt=Min(n/(n/i),m/(m/i));
        res=M(res+M(T[n/i][m/i][nxt]-T[n/i][m/i][i-1]+mod));
    }
    return res;
}

int main(){
    read(Test);Init(100000);
    while(Test--){
        read(n);read(m);
        printf("%lld\n",Solve(n,m));
    }
    return 0;
}
```


---

## 作者：WeLikeStudying (赞：7)

- QwQ。

**[题意](https://www.luogu.com.cn/problem/P4240)**
- 查询：
$$\sum_{i=1}^n\sum_{j=1}^m\varphi(i\cdot j)$$
- 测试组数 $T$ 不大于 $10^4$，$n,m\le 10^5$。

**分析**
- 经过[套路](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/solution-p4240)之后，我们可以得到：
$$g(n)=\sum_{d|n}\frac{d\mu(n/d)}{\varphi(d)}$$
$$G(n,k)=\sum_{i=1}^n\varphi(i\cdot k)$$
- 我们要求的就是：
$$H(n,m)=\sum_{i=1}^{+\infty}g(i)G(\lfloor n/i\rfloor,i)G(\lfloor m/i\rfloor,i)$$
- 注意上面那个求和号上标其实可以缩小到 $\min(n,m)$，但是为了下面推导方便。
- 然后我们发现：$H(n-1,m)$ 转移到 $H(n,m)$ 只需要 $O(\sigma_0(n))$ 的时间（因为只有这么多个项不一样）。
- 于是暴力跑莫队，复杂度经分析可得是 $O(n\sqrt T\log n)$，利用合理的分块或许可以让复杂度严格一点，但是直接分块也不至于被卡，常数应该较小，[代码](https://www.luogu.com.cn/paste/almivd07)。
- 还有个有趣的事情，这里另外乱入一个东西：$n\le 10^5,m\le 10^9$ 不多测怎么搞？
- 设：
$$F(n,m)=\sum_{i=1}^m\varphi(n\cdot i)$$
- 考虑质数 $p|n$，根据性质分类讨论，可以得到公式：
$$F(n,m)=\begin{cases}F(n/p,m)\cdot p&p^2|n\\F(n/p,m)\cdot (p-1)+F(n,\lfloor m/p\rfloor)&\text{otherwise}\end{cases}$$
- 边界是 $n=1$ 时需要使用杜教筛。
- 状态数目前复杂度未知，但是它可过，[代码](https://www.luogu.com.cn/paste/9mwx5idd)，跑得还挺快。
- 有谁能告诉我 $f(n,m)$（随便挑 $[1,n]$ 的质因子，可重复，满足积不大于 $m$ 的方案数）的渐进界，我就可以告诉你准确复杂度拉。

---

## 作者：ghj1222 (赞：6)

[安利一波cnblogs](https://www.cnblogs.com/oier/p/10307241.html)

题意：求出$\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)$，对998244353取模

多组数据，$T\le 10^4,n,m\le 10^5$。

前置知识：$\varphi(ij)=\frac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$

证明：~~我是口胡呢还是好好证呢~~还是口胡吧

按照欧拉函数的计算式展开，会发现，左边是$ij\prod_{p|i \mathrm{\color{red}or}p|j}\frac{p-1}p$

右边是$\frac{i\prod_{p|i}\frac{p-1}pj\prod_{p|j}\frac{p-1}p\gcd(i,j)}{\gcd(i,j)\prod_{p|i\mathrm{\color{red}and}p|j}\frac{p-1}p}$

显然，根据容斥原理，两边是相等的

然后推式子

$\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)$

$=\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(ij))}$

$=\sum_{p=1}^n\frac p{\varphi(p)}\sum_{i=1}^n\sum_{j=1}^m\varphi(i)\varphi(j)[\gcd(i,j)=p]$

$=\sum_{p=1}^n\frac p{\varphi(p)}\sum_{i=1}^{n/p}\sum_{j=1}^{m/p}\varphi(ip)\varphi(jp)[\gcd(i,j)=1]$

$=\sum_{p=1}^n\frac p{\varphi(p)}\sum_{i=1}^{n/p}\sum_{j=1}^{m/p}\varphi(ip)\varphi(jp)\sum_{d|i,d|j}\mu(d)$

$=\sum_{p=1}^n\frac p{\varphi(p)}\sum_{d=1}^n\mu(d)\sum_{i=1}^{n/dp}\sum_{j=1}^{m/dp}\varphi(idp)\varphi(jdp)$

$=\sum_{q=1}^n\sum_{p|q}\frac{p\mu(\frac qp)}{\varphi(p)}\sum_{i=1}^{n/q}\sum_{j=1}^{m/q}\varphi(iq)\varphi(jq)$

$=\sum_{q=1}^n\left(\sum_{p|q}\frac{p\mu(\frac qp)}{\varphi(p)}\right)\left(\sum_{i=1}^{n/q}\varphi(iq)\right)\left(\sum_{i=1}^{m/q}\varphi(iq)\right)$

前面这一部分好处理--$O(n\log n)$枚举倍数。后面？按照套路？数论分块？怎么分？？？？

~~观察了你谷题解后，终于懂了~~

设$sum(q)=\sum_{p|q}\frac{p\mu(\frac qp)}{\varphi(p)}$，显然可以在$O(n\log n)$的时间复杂度内处理出来。

设$g(x,y)=\sum_{i=1}^x\varphi(iy)$，显然有递推式$g(x,y)=g(x-1,y)+\varphi(xy)$。

由于$xy<=n$，对于每个$x$，有$\frac nx$的数值，我们可以通过动态申请内存，在$O(n\log n)$的时间复杂度和空间复杂度内求出$g$数组。

设$T(n,a,b)=\sum_{q=1}^n\left(\sum_{p|q}\frac{p\mu(\frac qp)}{\varphi(p)}\right)\left(\sum_{i=1}^{a}\varphi(iq)\right)\left(\sum_{i=1}^{b}\varphi(iq)\right)=\sum_{q=1}^nsum(q)g(a,q)g(b,q)$

显然T的递推式为$T(n,a,b)=T(n-1,a,b)+sum(n)g(a,n)g(b,n)$

根据数论分块那套理论，对于一个$n/q$和$m/q$相同的$q$的区间，当$n/q=a,m/q=b$时，这一区间的$ans=T(r,a,b)-T(l-1,a,b)$，r和l是这一区间内的最大值和最小值

我们考虑预处理$n*B*B$范围的答案，B是我们钦定的一个数字，T数组开的空间复杂度为$O(nB^2)$（实际上由于$a*n,b*n\le 10^5$的限制，应该开不到$O(nB^2)$。

对于每次询问，我们只能在$n/q\le B$时候进行数论分块操作通过$T$数组计算答案，复杂度根据数论分块那套理论为$O(\sqrt n)$。

对于$n/q>B$的部分，有$q<n/B$，暴力枚举$q$，通过$g$数组计算答案，这一部分单次计算的复杂度为$O(n/B)$。

总复杂度为$O(n\log n+nB^2+T(\sqrt n+n/B))$。实测，B开到50左右跑的快一点，且内存占用超小。

下面是乱七八糟的代码= =

注意讲文明，new来的内存要主动回收垃圾

注意取模（这题如果写的复杂度没错的话不卡常，开#define int long long也是没问题的

```cpp
#include <cstdio>
#include <functional>
using namespace std;

const int p = 998244353;
const int b = 50;
bool vis[100010];
int prime[100010], tot, fuck = 100000;
int mu[100010], phi[100010], invphi[100010];
int sum[100010];
int *g[100010], *t[100][100]; //注意这里t数组下标是[2][3][1]

int qpow(int x, int y)
{
	int res = 1;
	for (x %= p; y > 0; x = x * (long long)x % p, y >>= 1) if (y & 1) res = res * (long long)x % p;
	return res;
}

int main()
{
	//线性筛phi,mu，预处理前面的部分
	phi[1] = mu[1] = invphi[1] = 1;
	for (int i = 2; i <= fuck; i++)
	{
		if (vis[i] == false) prime[++tot] = i, phi[i] = i + (mu[i] = -1);
		for (int j = 1; j <= tot && i * prime[j] <= fuck; j++)
		{
			vis[i * prime[j]] = true;
			if (i % prime[j] == 0) { phi[i * prime[j]] = phi[i] * prime[j]; break; }
			phi[i * prime[j]] = phi[i] * (prime[j] - 1);
			mu[i * prime[j]] = -mu[i];
		}
		invphi[i] = qpow(phi[i], p - 2);
		if (phi[i] * (long long)invphi[i] % p != 1) { return -233; printf("cnm\n"); }
	}
	for (int pp = 1; pp <= fuck; pp++)
		for (int q = pp, d = 1; q <= fuck; q += pp, d++)
			sum[q] = (sum[q] + pp * (long long)invphi[pp] % p * mu[d]) % p, sum[q] += (sum[q] < 0 ? p : 0);

	//处理g数组
	for (int i = 1; i <= fuck; i++)
	{
		g[i] = new int[(fuck / i) + 1], g[i][0] = 0;
		for (int j = 1, sb = fuck / i; j <= sb; j++)
			g[i][j] = (g[i][j - 1] + phi[i * j]) % p;
	}
	
	//处理t数组 注意有第一维<=第二维，因为下面我们强制n<=m了
	for (int j = 1; j <= b; j++)
		for (int k = j; k <= b; k++)
		{
			int len = fuck / max(j, k);
			t[j][k] = new int[len + 1], t[j][k][0] = 0;
			for (int i = 1; i <= len; i++)
				t[j][k][i] = (t[j][k][i - 1] + sum[i] * (long long)g[i][j] % p * g[i][k] % p) % p;
		}
	
	//处理询问
	int tat;
	scanf("%d", &tat);
	while (tat --> 0)
	{
		int n, m, res = 0;
		scanf("%d%d", &n, &m);
		if (n > m) swap(n, m);
		//对于n/q>b的部分，暴力，通过g数组和sum数组计算计算
		for (int i = 1, sb = m / b; i <= sb; i++)
			res = (res + sum[i] * (long long)g[i][n / i] % p * g[i][m / i] % p) % p;
		//对于n/q<b的部分，数论分块，通过b数组计算
		for (int i = m / b + 1, j; i <= n; i = j + 1)
		{
			j = min(n / (n / i), m / (m / i));
			res = (res + t[n / i][m / i][j] - t[n / i][m / i][i - 1]) % p, res += (res < 0 ? p : 0);
		}
		printf("%d\n", res);
	}
	
	//垃圾回收
	for (int i = 1; i <= fuck; i++)
		delete []g[i], g[i] = 0;
	for (int i = 1; i <= b; i++)
		for (int j = i; j <= b; j++)
			delete[] t[i][j], t[i][j] = 0;
	return 0;
}
```





---

## 作者：Kreado (赞：5)

[P4240 毒瘤之神的考验](https://www.luogu.com.cn/problem/P4240)：

反正反演部分很简单，比较水的黑题。

$$\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)$$

有 $\varphi(ij)=\dfrac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$

所以有

$$\sum_{i=1}^n\sum_{j=1}^m\dfrac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$$

枚举 $\gcd(i,j)$

$$\sum_{k=1}^n\sum_{i=1}^n\sum_{j=1}^m\dfrac{\varphi(i)\varphi(j)k}{\varphi(k)}[\gcd(i,j)=k]$$

枚举 $ik,jk$

$$\sum_{k=1}^n\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}\dfrac{\varphi(ik)\varphi(jk)k}{\varphi(k)}[\gcd(i,j)=1]$$

$$\sum_{k=1}^n\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}\dfrac{\varphi(ik)\varphi(jk)k}{\varphi(k)}\sum_{d|\gcd(i,j)}\mu(d)$$

移项得到

$$\sum_{k=1}^n\dfrac{k}{\varphi(k)}\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\varphi(ik)\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}\varphi(jk)\sum_{d|\gcd(i,j)}\mu(d)$$

$$\sum_{k=1}^n\dfrac{k}{\varphi(k)}\sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor \frac{n}{kd}\rfloor}\varphi(ikd)\sum_{j=1}^{\lfloor \frac{m}{kd}\rfloor}\varphi(jkd)$$

考虑枚举 $P=kd$。

$$\sum_{P=1}^n\sum_{k|P}\frac{k}{\varphi(k)}\mu(\frac{P}{k})\sum_{i=1}^{\lfloor \frac{n}{P}\rfloor}\varphi(iP)\sum_{j=1}^{\lfloor \frac{m}{P}\rfloor}\varphi(jP)$$

似乎不能再化简了，令

$$f(x)=\sum_{k|x}\frac{k}{\varphi(k)}\mu(\frac{x}{k})$$

可以预处理出来，接下来令

$$g(x,y)=\sum_{i=1}^{x}\varphi(iy)$$

$$g(x,y)=g(x-1,y)+\varphi(xy)$$

$$q_i=\sum_{P=1}^n f(P)g(\frac{n}{P},P)g(\frac{m}{P},P)$$

暴力莫队可以过，时间复杂度 $O(n\ln n + q\sqrt n\ln n)$。

#### CODe

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=1e5+7,Mod=998244353;
ll f[Maxn],Q,sq,phi[Maxn],mu[Maxn],ans[Maxn],res,prime[Maxn],cnt,inv[Maxn];
vector<ll>g[Maxn],d[Maxn];
bool isprime[Maxn];
struct ques{
    ll n,m,id;
}q[Maxn];
inline bool cmp(ques x,ques y){
    return x.n/sq==y.n/sq?((x.n/sq)&1)?y.m<x.m:x.m<y.m:x.n<y.n;
}
void init(ll N){
    phi[1]=1;isprime[1]=isprime[0]=1;
    mu[1]=1,phi[1]=1;
    for(ll i=2;i<=N;i++){
        if(!isprime[i]) prime[++cnt]=i,phi[i]=i-1,mu[i]=-1;
        for(ll j=1;j<=cnt&&prime[j]*i<=N;j++){
            isprime[i*prime[j]]=1;
            if(!(i%prime[j])){
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
            mu[i*prime[j]]=-mu[i];
        }
    }
    inv[1]=1;
    for(ll i=2;i<=N;i++)
    	inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;
    for(ll i=1;i<=N;i++){
        g[i].resize(N/i+2);
        for(ll j=1;j<=N/i;j++)
            g[i][j]=(g[i][j-1]+phi[i*j])%Mod;    
    }
    for(ll i=1;i<=N;i++)
        for(ll j=i;j<=N;j+=i)
            f[j]=f[j]%Mod+i*inv[phi[i]]%Mod*mu[j/i]%Mod,d[j].push_back(i);

}
inline void add(ll a,ll b,ll w){
    for(ll i=0;i<d[a].size();++i)
        res=(res+1ll*w%Mod*phi[a]%Mod*g[d[a][i]][b/d[a][i]]%Mod*f[d[a][i]]%Mod)%Mod;
    res=(res+Mod)%Mod; 
}
int main(){
    scanf("%lld",&Q);
    init(Maxn-7);
    for(ll i=1;i<=Q;i++){
        scanf("%lld%lld",&q[i].n,&q[i].m);
        if(q[i].m<q[i].n) swap(q[i].n,q[i].m);
        q[i].id=i;
    }
    sq=sqrt(Q);
    sort(q+1,q+Q+1,cmp);
    ll l=0,r=0;
    for(ll i=1;i<=Q;i++){
        while(l<q[i].n) add(++l,r,1);
        while(r<q[i].m) add(++r,l,1);
        while(l>q[i].n) add(l--,r,-1);
        while(r>q[i].m) add(r--,l,-1);
        ans[q[i].id]=res%Mod;
    }
    for(ll i=1;i<=Q;i++) printf("%lld\n",ans[i]);
    return 0;
}
```


---

## 作者：Linshey (赞：5)

感觉这题真的特别有意思，涉及了 OI 中很多非常有意思、非常美的手法，比如——平衡两部分的时间复杂度、$n \ln n$ 的那个 Trick等等，真的一种暴力的美学。

![没错，就是这种美](https://cdn.luogu.com.cn/upload/pic/11191.png)

题目大意：

多组询问，求 $f_{n,m}=\sum\limits_{i=1}^n\sum\limits_{j=1}^m \varphi(i\cdot j)$，$1 \le n,m \le 1e5$，$T \le 1e4$.

解法：

这里用一个套路一点的式子：$\varphi(i\cdot j)=\frac{\varphi(i)\cdot \varphi(j)\cdot \gcd(i,j)}{\varphi(\gcd(i,j))}$，于是我们可以得到：

$$f_{n,m}=\sum_{i=1}^n\sum_{j=1}^m \frac{\varphi(i)\cdot \varphi(j)\cdot \gcd(i,j)}{\varphi(\gcd(i,j))}$$

运用上面那个式子的意义在于现在所有的参数都在值域 $[1,\min(n,m)]$ 之内了，于是我们可以将相同的东西提出来，也就是我上一篇博客中提到的那种方法，得到：

$$f_{n,m}=\sum_{d=1}^{\min(n,m)} \frac{d}{\varphi(d)} \sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor} \sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\varepsilon\left(\gcd(i,j)\right)\varphi(id)\varphi(jd)$$

运用莫比乌斯反演得的意义在于，它把条件式又转化为了贡献式，使它可以快速球和，于是我们运用莫反，并将 $\mu$ 提出来：

$$f_{n,m}=\sum_{x=1}^{\min(n,m)}\frac{x}{\varphi(x)}\sum_{y=1}^{\left\lfloor \frac{\min(n,m)}{x}\right\rfloor}\mu(y)\sum_{i=1}^{\left \lfloor \frac{n}{xy} \right \rfloor}\sum_{j=1}^{\left \lfloor \frac{m}{xy} \right \rfloor} \varphi(ixy)\varphi(jxy)$$

遇到这样挺极致的情况，我们可以提出一个 $T=xy$，然后枚举 $T$ 的因数，以期实现莫反/调和级数的效果。得到：

$$f_{n,m}=\sum_{T=1}^{\min(n,m)} \left(\sum_{x|T} \frac{x}{\varphi(x)} \mu\left(\frac{T}{x}\right)\right)\cdot \left(\sum_{i=1}^{\left \lfloor \frac{n}{T} \right \rfloor}\varphi(iT)\right)\cdot \left(\sum_{j=1}^{\left \lfloor \frac{m}{T} \right \rfloor}\varphi(jT)\right)$$

我们设 $g(T)=\sum_{x|T} \frac{x}{\varphi(x)} \mu(\frac{T}{x})$，$h(n,T)=\sum_{i=1}^{\left \lfloor n \right \rfloor}\varphi(iT)$，于是：

$$f_{n,m}=\sum_{T=1}^{\min(n,m)}g(T)\cdot h(\left\lfloor \frac{n}{T} \right\rfloor,T)\cdot h(\left\lfloor \frac{m}{T} \right\rfloor,T)$$

注意到 $g$ 中，$\sum\limits x \le n \ln n$；$h$ 中，$nT \le n \ln n$，所以这两个东西都可以用调和级数预处理出来，于是我们有了一个 $\Theta(nT)$ 的做法，这是调和级数的美。

考虑继续优化。因为右手边的东西含有下取整，所以我们考虑整除分块；但是这个整除分块中 $h$ 函数同时含有这两种参数，所以我们考虑前缀和优化：

$$t_{n,m,d}=\sum_{i=1}^d g(i)\cdot g(n,i) \cdot g(m,i)$$

这个显然过于庞大无法预处理，并且没什么办法快速求值；一旦预处理，询问只要 $\Theta(\sqrt n)$，但是预处理会超时；一旦不预处理，那么询问会超时，所以我们考虑 **平衡两部分时间复杂度**。

具体来说，我们预处理 $n\le S$ 且 $m \le S$，的部分，复杂度 $nS^2$；查询的时候我们暴力查询 $\left[ 1, \left\lceil \frac{\min(n,m)}{S}\right\rceil \right]$ 的部分；其余的因为 $\left \lfloor \frac{n}{T} \right \rfloor$ 都小于等于 $S$，所以可以整除分块了查询。

总的时间复杂度就等于 $\gamma = n \ln n + nS^2+T\cdot\left( \sqrt S + \frac{n}{S}\right)$，当 $\frac{\partial \gamma}{\partial S}=2nS-\frac{Tn}{S^2}+\frac{T}{2\sqrt S}=0$ 时最优，大概是 $S=50$，并且总的可以在 $0.5s$ 之内跑出来，这是 **平衡之美**。

代码：[https://www.luogu.com.cn/paste/hxjugkts](https://www.luogu.com.cn/paste/hxjugkts).


---

## 作者：ForgotMe (赞：5)

$T$ 次询问，每次询问给出 $n,m$。

求 
$$
\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)
$$
这个 $\varphi(ij)$ 不是很好做，考虑拆开。

这里有两种处理方式：

1.直接拆成 $\varphi(i)\varphi(j)$，然后利用性质 $\varphi(n)=n\prod_{d|n}[d\in\operatorname{Prime}](1-\dfrac{1}{d})$ 补上 $\varphi(i),\varphi(j)$  都有的质因子。

即 
$$
\varphi(ij)=\varphi(i)\varphi(j)\prod_{k=1}^{\min(i,j)}[k\in\operatorname{Prime}][k|i][k|j]\dfrac{k}{k-1}
$$
2.有一个公式：
$$
\varphi(ij)=\dfrac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}
$$
我用的是第一种，代回原式可得：
$$
\sum_{i=1}^n\sum_{j=1}^m\varphi(i)\varphi(j)\prod_{k=1}^{\min(i,j)}[k\in\operatorname{Prime}][k|i][k|j]\dfrac{k}{k-1}
$$

$$
\sum_{i=1}^n\sum_{j=1}^m\varphi(i)\varphi(j)\prod_{k=1}^{\min(i,j)}[k\in\operatorname{Prime}][k|\gcd(i,j)]\dfrac{k}{k-1}
$$

$$
\sum_{d=1}^{\min(n,m)}\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1}\sum_{i=1}^n\sum_{j=1}^m\varphi(i)\varphi(j)[\gcd(i,j)=d]
$$

$$
\sum_{d=1}^{\min(n,m)}\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1}\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}\varphi(id)\varphi(jd)[\gcd(i,j)=1]
$$

直接莫比乌斯反演。
$$
\sum_{d=1}^{\min(n,m)}\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1}\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}\varphi(id)\varphi(jd)\sum_{D|\gcd(i,j)}\mu(D)
$$

$$
\sum_{d=1}^{\min(n,m)}\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1}\sum_{D=1}^{\min(\frac{n}{d},\frac{m}{d})}\mu(D)\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}\varphi(id)\varphi(jd)[D|i][D|j]
$$

$$
\sum_{d=1}^{\min(n,m)}\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1}\sum_{D=1}^{\min(\frac{n}{d},\frac{m}{d})}\mu(D)\sum_{i=1}^{\frac{n}{dD}}\sum_{j=1}^{\frac{m}{dD}}\varphi(idD)\varphi(jdD)
$$

$$
\sum_{T=1}^{\min(n,m)}\sum_{d|T}((\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1})\mu(\dfrac{T}{d}))\sum_{i=1}^{\frac{n}{T}}\varphi(iT)\sum_{j=1}^{\frac{m}{T}}\varphi(jT)
$$

$\sum_{d|T}((\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1})\mu(\dfrac{T}{d}))$ 这一坨直接 $\mathcal{O(n\log n)}$ 的筛法预处理。

然后对 $T$ 进行数论分块，右边那坨 $\varphi$ 求和直接暴力算，至此我们就得到了单次询问 $\mathcal{O(n+m)}$ 的算法。

怎么优化呢？显然瓶颈在后面那一坨 $\varphi$ 求和里。这时我们就需要乱搞了。

设一个阈值 $B$，函数 $F(x),G(x,y),S(x,y,z)$。
$$
F(x)=\sum_{d|x}((\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1})\mu(\dfrac{x}{d}))
$$

$$
G(x,y)=\sum_{i=1}^x\varphi(iy)
$$

$$
S(x,y,z)=\sum_{T=1}^{z}\sum_{d|T}((\prod_{k|d}[k\in\operatorname{Prime}]\dfrac{k}{k-1})\mu(\dfrac{T}{d}))\sum_{i=1}^{y}\varphi(iT)\sum_{j=1}^{x}\varphi(jT)
$$

显然有
$$
G(x,y)=G(x,y-1)+\varphi(xy)
$$

$$
S(x,y,z)=S(x,y,z-1)+F(z)G(z,x)G(z,y)
$$

然后对于 $\dfrac{m}{B}$ 的部分直接用 $G$ 函数暴力算，后面的部分整除分块即可。

时间复杂度 $\mathcal{O(n+n\log n+nB^2+T(\sqrt{n}+\dfrac{n}{B}))}$。

```cpp
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
#define LL long long
const int MAXN = 1e5 + 5;
bool vis[MAXN];
int len, mu[MAXN], prime[MAXN], B = 100;
const LL mod = 998244353;
LL qkpow(LL x, LL power, LL mod) {
    x %= mod;
    LL ans = 1;
    for (; power; power >>= 1, (x *= x) %= mod)
        if (power & 1)
            (ans *= x) %= mod;
    return ans;
}
LL Prime[MAXN], f[MAXN], phi[MAXN];
vector<int> G[MAXN], S[105][105];
void Getmu() {
    mu[1] = 1, phi[1] = 1;
    Prime[1] = 1;
    for (int i = 2; i <= MAXN - 5; i++) {
        Prime[i] = 1;
        if (!vis[i])
            prime[++len] = i, mu[i] = -1, phi[i] = i - 1;
        for (int j = 1; j <= len && i * prime[j] <= MAXN - 5; j++) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            mu[i * prime[j]] = -mu[i];
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
    for (int i = 1; i <= len; i++)
        for (int j = prime[i]; j <= MAXN - 5; j += prime[i])
            Prime[j] = (Prime[j] * prime[i] % mod * qkpow(prime[i] - 1, mod - 2, mod) % mod) % mod;
    for (int i = 1; i <= MAXN - 5; i++)
        for (int j = i; j <= MAXN - 5; j += i)
            f[j] = (f[j] + Prime[i] * mu[j / i]) % mod, f[j] = (f[j] + mod) % mod;
    for (int i = 1; i <= MAXN - 5; i++) {
        G[i].push_back(0);
        for (int j = 1; j <= (MAXN - 5) / i; j++) G[i].push_back((G[i][j - 1] + phi[i * j]) % mod);
    }
    for (int i = 1; i <= B; i++) {
        for (int j = 1; j <= B; j++) {
            S[i][j].push_back(0);
            for (int k = 1; k <= (MAXN - 5) / max(i, j); k++) {
                S[i][j].push_back((S[i][j][k - 1] + f[k] * G[k][i] % mod * G[k][j]) % mod);
            }
        }
    }
}
int T;
LL n, m;
LL calc(LL n, LL m) {
    LL ans = 0;
    for (int i = 1; i <= max(n, m) / B; i++) ans = (ans + f[i] * G[i][n / i] % mod * G[i][m / i] % mod) % mod;
    for (int i = max(n, m) / B + 1, j; i <= min(n, m); i = j + 1) {
        j = min(n / (n / i), m / (m / i));
        ans = (ans + (S[n / i][m / i][j] - S[n / i][m / i][i - 1]) % mod) % mod;
    }
    return (ans + mod) % mod;
}
int main() {
    Getmu();
    scanf("%d", &T);
    while (T--) {
        scanf("%lld %lld", &n, &m);
        printf("%lld\n", calc(n, m));
    }
    return 0;
}
```



---

## 作者：Vidoliga (赞：4)

题意：求 $\sum_{i=1}^{n}\sum_{j=1}^{m} \varphi(ij)$ ，多组询问。

首先有个性质 ：
$\varphi(ab)\varphi(\gcd(ab))=\varphi(a)\varphi(b)\gcd(a,b)$

然而这很好证明：

$$\varphi(ab)=ab\prod_{p|ab} \dfrac{p-1}{p}=\dfrac{a\prod_{p|a} \dfrac{p-1}{p} b\prod_{p|b} \dfrac{p-1}{p}}{\prod_{p|\gcd(a,b)} \dfrac{p-1}{p}}$$

上下两边同乘 $\gcd(a,b)$ 。

$$\varphi(ab)=\dfrac{\varphi(a)\varphi(b)\gcd(a,b)}{\varphi(\gcd(a,b))}$$

那好，我们带回原来的式子：

注： $n>m$

$$\sum_{i=1}^{n}\sum_{j=1}^{m} \varphi(ij)=\sum_{i=1}^{n}\sum_{j=1}^{m} \dfrac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$$

$$=\sum_{T=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{T}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{T}\rfloor} \dfrac{\varphi(iT)\varphi(jT)T}{\varphi(T)}[\gcd(i,j)=1]$$

$$=\sum_{T=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{T}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{T}\rfloor} \dfrac{\varphi(iT)\varphi(jT)T}{\varphi(T)}\sum_{k|i,k|j} \mu(k)$$

$$=\sum_{T=1}^{n}\sum_{k=1}^{\lfloor\frac{n}{T}\rfloor} \mu(k) \sum_{i|k}\sum_{j|k}\dfrac{\varphi(iT)\varphi(jT)T}{\varphi(T)} $$


$$=\sum_{T=1}^{n}\sum_{k=1}^{\lfloor\frac{n}{T}\rfloor} \mu(k) \sum_{i=1}^{\lfloor\frac{n}{kT}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{kT}\rfloor} \dfrac{\varphi(ikT)\varphi(jkT)T}{\varphi(T)} $$

$$=\sum_{T=1}^{n}\dfrac{T}{\varphi(T)}\sum_{k=1}^{\lfloor\frac{n}{T}\rfloor} \mu(k) \sum_{i=1}^{\lfloor\frac{n}{kT}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{kT}\rfloor} \varphi(ikT)\varphi(jkT)$$

$$=\sum_{T=1}^{n}\dfrac{T}{\varphi(T)}\sum_{k=1}^{\lfloor\frac{n}{T}\rfloor} \mu(k) \left[ \sum_{i=1}^{\lfloor\frac{n}{kT}\rfloor} \varphi(ikT) \right] \left[\sum_{j=1}^{\lfloor\frac{m}{kT}\rfloor} \varphi(jkT)\right]$$

发现式子极其丑陋，设： $g(x,y)=\sum_{i=1}^{x} \varphi(iy)$ 。

原式就可以写成：

$$\sum_{T=1}^{n}\dfrac{T}{\varphi(T)}\sum_{k=1}^{\lfloor\frac{n}{T}\rfloor} \mu(k) g(\left\lfloor\frac{n}{kT}\right\rfloor,kT)g(\left\lfloor\frac{m}{kT}\right\rfloor,kT)$$

发现莫比乌斯函数在这个式子不好搞，果断独立：

设 ： $d=kT$

$$=\sum_{d=1}^{n}g(\left\lfloor\frac{n}{kT}\right\rfloor,kT)g(\left\lfloor\frac{m}{kT}\right\rfloor,kT)\sum_{k|d} \dfrac{\mu(\dfrac{d}{k})d}{\varphi(d)}$$

设： $f(x)=\sum_{k|x} \dfrac{\mu(\frac{x}{k})x}{\varphi(x)}$

设： $h(x,y,z)=\sum_{T=1}^{x}f(T)g(\frac{y}{T},T)g(\frac{z}{T},T)$

我们发现 $h$ 不好处理，但我们可以差分。

设： $F(x,y,z)=\sum_{i=1}^{x} f(i)g(y,i)g(z,i)$

然后我们在用整除分块算 $h$ 时考虑 $l,r$ 为块左右端点：

$$h(x,y,z)=F(r,\left\lfloor\frac{n}{r}\right\rfloor,\left\lfloor\frac{m}{r}\right\rfloor)-F(l-1,\left\lfloor\frac{n}{l}\right\rfloor,\left\lfloor\frac{m}{l}\right\rfloor)$$

然而 $t$ 次询问，显然全部预处理复杂度吃不消。

考虑分治：设个 $B$ ，小于 $\left\lfloor\frac{n}{B}\right\rfloor$ 暴力做，大于则整除分块。

复杂度： $O(n\log n+B^2n+q(\sqrt n+\dfrac{n}{B}))$ 。

对于 $B$ 的取值，我选取了 $\sqrt[3]{n}$ 。

算出来复杂度为： $O(n\log n+n^{\frac{5}{3}}+qn^{\frac{2}{3}})$ 。

然后这是可过的。

~~代码就不放了，实现较短。~~

---

## 作者：_LHF_ (赞：2)

### 另一种做法：莫反+莫队

也很套路，我们使用二维莫队，问题变成了如何快速计算 $\sum_{i=1}^n\varphi(ix)$。

一种想法是直接上莫反，最后变成了 $\varphi(x)\sum_{d|x}f(d)\sum_{d|i}^n\varphi(i)$。

其中 $f(n)=\sum_{d|n}\frac{\mu(n/d)d}{\varphi(d)}$，可以通过简单的莫比乌斯反演计算得出。

但我们发现这样做会凉凉……毕竟 $10^5$ 级别内约数最大为 $128$，怎么办呢？

一种神奇的方法：找到一对 $(a,b)$ 满足 $a\times b=x$，则原式可以改写成 $\sum_{i=1}^{n\times a}\varphi(ib)[a|i]=\varphi(b)\sum_{d|b}f(d)\sum_{d|i,a|i}^n\varphi(i)$。

而 $d|i,a|i$ 等价于 $\text{lcm}(d,a)|i$，对于不同的 $a$，我们可以提前预处理这些。

所以说我们如果能找到约数尽量少 $b$，为了减少预处理量，我们还希望不同的 $a$ 也尽量的少。

一种做法是令 $B=2^2\times 3\times 5$，然后我们令 $a=\gcd(x,B),b=x/\gcd(x,B)$，这样不难发现 $b$ 的约数个数最大为 $16$（当然还有少量的几个为 $32$，如 $2^3\times3^2\times7\times11\times13$，但这样的数还是非常少的），其实也可以调整 $B$ 的质因数组合（不过我懒得搞了），不过整体上来说还是不错的。

预处理复杂度为 $O(n\ln n\times d(B))$，询问复杂度约为 $O(16\times n\sqrt T)$。

---

## 作者：hzoi_liuchang (赞：2)

## 题目描述
求 $\sum\limits_{i=1}^n\sum\limits_{j=1}^m \varphi(ij)(mod\ 998244353)$

$T$ 组询问

$1 \leq n,m,T \leq 10^5$

## 分析
令 $n<m$

首先，我们把 $\varphi(ij)$ 拆成 $\varphi(i)\varphi(j)\frac{gcd(i,j)}{\varphi(gcd(i,j))}$

考虑求单个欧拉函数的方法

$\varphi(i)=i\prod\limits_{d \in prime,d|i}\frac{d-1}{d}$

$\varphi(i)\varphi(j)$ 比 $\varphi(ij)$ 多乘了 $i,j$ 共有的质因子

所以我们要把这些共有的质因子做出的贡献消除

即乘上一个 $\frac{gcd(i,j)}{\varphi(gcd(i,j))}$

那么式子就变成了

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\varphi(i)\varphi(j)\frac{gcd(i,j)}{\varphi(gcd(i,j))}$

按照莫比乌斯反演的套路，枚举 $gcd(i,j)$

$\sum\limits_{d=1}^n\frac{d}{\varphi(d)}\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}\varphi(id)\varphi(jd)[gcd(i,j)=1]$

$\sum\limits_{d=1}^n\frac{d}{\varphi(d)}\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}\varphi(id)\varphi(jd)\sum\limits_{k|gcd(i,j)}\mu(k)$

$\sum\limits_{d=1}^n\frac{d}{\varphi(d)}\sum\limits_{k=1}^{n/d}\mu(k)\sum\limits_{i=1}^{n/dk}\sum\limits_{j=1}^{m/dk}\varphi(idk)\varphi(jdk)$

$\sum\limits_{T=1}^n\sum\limits_{d|T}\frac{d}{\varphi(d) }\mu(\frac{T}{d})\sum\limits_{i=1}^{n/T}\sum\limits_{j=1}^{m/T}\varphi(iT)\varphi(jT)$

设 $g(T)=\sum\limits_{d|T}\frac{d}{\varphi(d) }\mu(\frac{T}{d}),s(n,m)=\sum\limits_{i=1}^n\varphi(mi)$

原式变成

$\sum\limits_{T=1}^ng(T)s(n/T,T)s(m/T,T)$

$g$ 数组和 $s$ 数组可以 $nlogn$ 预处理出来

然后就可以 $O(n)$ 计算每一次的答案

总复杂度就是 $O(nT)$，还是不够优秀

我们可以人为地设一个值 $top$

当 $T<\frac{m}{top}$ 时暴力计算

否则 $\frac{n}{T},\frac{m}{T}$ 一定是小于 $top$ 的

那么我们就可以开一个数组把小于 $top$ 的这一部分预处理出来

查询的时候就可以直接用
## 代码
``` cpp
#include<cstdio>
#include<cmath>
#include<vector>
#define rg register
const int maxn=1e5+5,maxm=55,mod=998244353,tp=52;
inline int addmod(rg int now1,rg int now2){
	return now1+=now2,now1>=mod?now1-mod:now1;
}
inline int delmod(rg int now1,rg int now2){
	return now1-=now2,now1<0?now1+mod:now1;
}
inline int mulmod(rg long long now1,rg int now2){
	return now1*=now2,now1>=mod?now1%mod:now1;
}
int pri[maxn],mmax,phi[maxn],mu[maxn],g[maxn],*f[maxm][maxm],buf[maxn*160],*o=buf,*s[maxn];
int ksm(rg int ds,rg int zs){
	rg int nans=1;
	while(zs){
		if(zs&1) nans=mulmod(nans,ds);
		ds=mulmod(ds,ds);
		zs>>=1;
	}
	return nans;
}
bool not_pri[maxn];
void pre(){
	not_pri[0]=not_pri[1]=1;
	phi[1]=mu[1]=1;
	for(rg int i=2;i<=mmax;i++){
		if(!not_pri[i]){
			pri[++pri[0]]=i;
			phi[i]=i-1;
			mu[i]=mod-1;
		}
		for(rg int j=1;j<=pri[0] && 1LL*i*pri[j]<=mmax;j++){
			not_pri[i*pri[j]]=1;
			if(i%pri[j]==0){
				phi[i*pri[j]]=mulmod(pri[j],phi[i]);
				break;
			} else {
				phi[i*pri[j]]=mulmod(phi[pri[j]],phi[i]);
				mu[i*pri[j]]=mulmod(mu[pri[j]],mu[i]);
			}
		}
	}
	rg int cs;
	for(rg int i=1;i<=mmax;i++){
		cs=mulmod(i,ksm(phi[i],mod-2));
		for(rg int j=i,now=1;j<=mmax;j+=i,now++){
			g[j]=addmod(g[j],mulmod(cs,mu[now]));
		}
	}
	for(rg int i=1;i<=mmax;i++){
		cs=mmax/i;
		s[i]=o;
		o+=(cs+1);
		for(rg int j=1;j<=cs;j++){
			s[i][j]=addmod(s[i][j-1],phi[i*j]);
		}
	}
	for(rg int i=1;i<=tp;i++){
		for(rg int j=1;j<=tp;j++){
			f[i][j]=o;
			f[i][j][0]=0;
			cs=std::min(mmax/i,mmax/j);
			o+=(cs+1);
			for(rg int k=1;k<=cs;k++){
				f[i][j][k]=(addmod(f[i][j][k-1],mulmod(g[k],mulmod(s[k][i],s[k][j]))));
			}
		}
	}
}
int t,n,m;
int main(){
	mmax=1e5;
	pre();
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&m);
		if(n>m) std::swap(n,m);
		rg int nans=0,mmax=m/tp,orz1,orz2;
		for(rg int i=1;i<=mmax;i++){
			nans=addmod(nans,mulmod(g[i],mulmod(s[i][n/i],s[i][m/i])));
		}
		for(rg int l=mmax+1,r;l<=n;l=r+1){
			r=std::min((n/(n/l)),m/(m/l)),orz1=n/l,orz2=m/l;
			nans=addmod(nans,delmod(f[orz1][orz2][r],f[orz1][orz2][l-1]));
		}
		printf("%d\n",nans);
	}
	return 0;
}
```

---

## 作者：_Fontainebleau_ (赞：1)

### 题意

- 给定 $n,m$，求 $\displaystyle \sum_{i=1}^n\sum_{j=1}^m \varphi(ij)$，答案对 $998244353$ 取模。多组测试数据。
- $1\le T\le 10^4,1\le n,m\le 10^5$

### 做法

**莫反+根号分治** 神仙题

$\varphi$ 里面是 $i\cdot j$，感觉不太好做，考虑将其拆开来。

这里有一个神奇的性质： $\varphi(ij)=\dfrac {\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$。

证明的话，根据 $\varphi(x)=x\prod\limits_{p\mid x}\frac{p-1}p$ 一展开就没了。稍微写一下：

$$\begin{aligned}\varphi(ij)\varphi(\gcd(i,j))&=ij\prod_{p\mid ij}\frac{p-1}p\gcd(i,j)\prod_{p\mid \gcd(i,j)}\frac{p-1}p\\&=i\prod_{p\mid i}\frac{p-1}pj\prod_{p\mid j}\frac{p-1}p\gcd(i,j)\\&=\varphi(i)\varphi(j)\gcd(i,j) \end{aligned}$$

然后暴力推式子：

$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)&=\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}\\&=\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m\dfrac{\varphi(i)\varphi(j)d\left[\gcd(i,j)=d\right]}{\varphi(d)}&\color{pink}\text{枚举 gcd}\\&=\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{i=1}^n\sum_{j=1}^m\varphi(i)\varphi(j)\left[\gcd(i,j)=d\right]\\&=\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{i=1}^n\sum_{j=1}^m\varphi(i)\varphi(j)\left[\gcd\left(\frac{i}{d},\frac{j}d\right)=1\right]\\&=\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}d\right\rfloor}\varphi(id)\varphi(jd)\left[\gcd(i,j)=1\right]&\color{pink}\text{枚举 }\frac{i}d,\frac{j}d\\&=\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}d\right\rfloor}\varphi(id)\varphi(jd)\sum_{k\mid \gcd(i,j)}\mu(k)&\color{pink}\text{Mobius inversion!}\\&=\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(k)\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dk}\right\rfloor}\varphi(idk)\varphi(jdk)&\color{pink}\text{枚举 }k\\&=\sum_{t=1}^n\sum_{d\mid t}\dfrac{d\cdot\mu\left(\frac{t}{d}\right)}{\varphi(d)}\sum_{i=1}^{\left\lfloor\frac{n}{t}\right\rfloor}\varphi(it)\sum_{j=1}^{\left\lfloor\frac{m}{t}\right\rfloor}\varphi(jt)&\color{pink}\text{枚举 }t=dk \end{aligned}$$

令 $\displaystyle f(n)=\sum_{d\mid n}\frac{d\cdot \mu\left(\frac{n}d\right)}{\varphi(d)}$，则这一部分可以通过枚举 $1$ 到 $n$，然后枚举其倍数可以 $O(n\ln n)$ 求得。

令 $\displaystyle g(k,n)=\sum_{i=1}^n \varphi(ik)$，有递推式 $g(i,j)=g(i,j-1)+\varphi(ij)$，这一部分复杂度同样是 $O(n\ln n)$。

把 $f,g$ 带回原式，得：

$$\displaystyle \sum_{i=1}^n\sum_{j=1}^m\varphi(ij)=\sum_{t=1}^nf(t)\cdot{g}\left(t,\left\lfloor\frac{n}{t}\right\rfloor\right)\cdot{g\left(t,\left\lfloor{\frac{m}{t}}\right\rfloor\right)}$$

可惜的是，$g$ 中有 $t$ 整出分块不了。把整个式子设出来，令：

$$\displaystyle h(a,b,n)=\sum_{t=1}^n f(t)\cdot{g(t,a)}\cdot{g(t,b)}$$

容易发现，这其实就是一个整除分块的首尾两端的差分形式：

$$\displaystyle h(a,b,n)=\sum_{\left\lfloor{\frac{n}{l}}\right\rfloor=\left\lfloor{\frac{n}{r}}\right\rfloor \text{and} \left\lfloor{\frac{m}{l}}\right\rfloor=\left\lfloor{\frac{m}{r}}\right\rfloor}h\left({\left\lfloor{\frac{n}{r}}\right\rfloor},{\left\lfloor{\frac{m}{r}}\right\rfloor},r\right)-h\left({\left\lfloor{\frac{n}{l}}\right\rfloor},{\left\lfloor{\frac{m}{l}}\right\rfloor},l\right)$$

如今的问题就在于怎么求 $h$ 了。

容易发现，如果全部预处理，会 $\color{MidNightBlue}\text{TLE}$ 飞。怎么办？我们考虑 **根号分治**，优美地将预处理和查询的时间复杂度平衡一下。

$l,r$ 越大，整除分块的那一块就更大，相对更具优势。所以考虑在 $l,r$ 较小时暴力。

设阈值为 $B$，预处理 $h\left({1,1,1}\right)$ 至 $h\left(B,B,n\right)$。

怎么预处理？ $h\left(j,k,i\right)=h\left(j,k,i-1\right)+f(i)\cdot{g(i,j)}\cdot{g(i,k)}$。

时间复杂度是 $O(nB^2)$ 的。

预处理解决了，查询呢？

对于所有的 $\left\lfloor{\dfrac{n}{r}}\right\rfloor\le B$ 可以直接查询，否则 $r\le \left\lfloor{\dfrac{n}{B}}\right\rfloor$，暴力即可。

总复杂度为 $O\left(n\ln n+nB^2+T\left(\sqrt n+\frac{n}B\right)\right)$。

当 $B$ 取 $50$ 左右，跑得比较快。目前是 rk2？

### 代码

```c++
#include<bits/stdc++.h>
#define mod 998244353
using namespace std;
const int B=50;
vector<int> g[100005];
vector<int> t[60][60];
int f[100005],mu[100005],cnt;
int phi[100005],inv[100005],prime[100005];
bitset<100005>used;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
inline int ksm(int a,int b)
{
	int res=1,p=a;
	while(b)
	{
		if(b&1)	res=1ll*res*p%mod;
		p=1ll*p*p%mod;b>>=1;
	}
	return res;
}
inline void add(int &a,int b){int t=a+b;a=t>=mod?t-mod:t;}
inline void init(int n)
{
	mu[1]=1,phi[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!used[i])	prime[++cnt]=i,mu[i]=-1,phi[i]=i-1;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			int t=i*prime[j];used[t]=1;
			if(i%prime[j])	mu[t]=-mu[i],phi[t]=phi[i]*(prime[j]-1);
			else{phi[t]=phi[i]*prime[j];break;}
		}
	}
	for(int i=1;i<=n;i++)	inv[i]=ksm(phi[i],mod-2);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n/i;j++)
			add(f[i*j],(1ll*i*mu[j]*inv[i]%mod+mod)%mod);
	for(int i=1;i<=n;i++)
	{
		g[i].resize(n/i+10);g[i][0]=0;
		for(int j=1;j<=n/i;j++)
			g[i][j]=(g[i][j-1]+phi[i*j])%mod;
	}
	for(int j=1;j<=B;j++)
		for(int k=j;k<=B;k++)
		{
			t[j][k].resize(n/k+10);t[j][k][0]=0;
			for(int i=1;i<=n/k;i++)
				t[j][k][i]=(t[j][k][i-1]+1ll*f[i]*g[i][j]%mod*g[i][k]%mod)%mod;
		}
}
inline int solve(int n,int m)
{
	int res=0;
	for(int i=1;i<=m/B;i++)	add(res,1ll*f[i]*g[i][n/i]%mod*g[i][m/i]%mod);
	for(int l=m/B+1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		add(res,(t[n/l][m/l][r]-t[n/l][m/l][l-1]+mod)%mod);
	}
	return res;
}
int main()
{
	int tc=read();
	init(100000);
	while(tc--)
	{
		int n=read(),m=read();
		if(n>m)	swap(n,m);
		printf("%d\n",solve(n,m));
	}
	return 0;
}
```







---

## 作者：Dzhao (赞：1)

性质：$\varphi(ij)=\dfrac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$

我们假设 $n\leq m$，可将原式化简：
$$\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)$$
$$=\sum_{i=1}^n\sum_{j=1}^m\dfrac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$$
$$=\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m\dfrac{\varphi(i)\varphi(j)d[\gcd(i,j)=d]}{\varphi(d)}$$
$$=\sum_{d=1}^n\dfrac{d}{\varphi(d)}\sum_{i=1}^n\sum_{j=1}^m\varphi(i)\varphi(j)[\gcd(i,j)=d]$$
$$=\sum_{d=1}^n\dfrac{d}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(id)\varphi(jd)[\gcd(i,j)=1]$$
$$=\sum_{d=1}^n\dfrac{d}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(id)\varphi(jd)\epsilon(\gcd(i,j))$$
又因为 $\mu\ast\operatorname{I}=\epsilon$，所以可以将原式转化为：
$$=\sum_{d=1}^n\dfrac{d}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(id)\varphi(jd)\sum_{t|\gcd(i,j)}\mu(t)$$
$$=\sum_{d=1}^n\dfrac{d}{\varphi(d)}\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor}\mu(t)\sum_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dt}\rfloor}\varphi(idt)\varphi(jdt)$$
设 $k=dt$，则可以继续化简：
$$=\sum_{k=1}^n\sum_{d|k}\dfrac{d\mu(\frac{k}{d})}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dt}\rfloor}\varphi(ik)\varphi(jk)$$
$$=\sum_{k=1}^n\sum_{d|k}\dfrac{d\mu(\frac{k}{d})}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\varphi(ik)\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\varphi(jk)$$
设： 
$$f(n)=\sum_{d|n}\dfrac{d\mu(\frac{n}{d})}{\varphi(d)}$$
$$g(k,n)=\sum_{i=1}^n\varphi(ik)$$
所以原式可以化简为：
$$=\sum_{k=1}^nf(k)g(k,\lfloor\frac{n}{k}\rfloor)g(k,\lfloor\frac{m}{k}\rfloor)$$
现在我们就需要知道如何求出 $f(n)$ 和 $g(k,n)$。

求 $f(n)$，我们可以预处理，枚举每一个除数，然后枚举每一个他的倍数就行了，时间复杂度为 $\mathcal{O}(n\ln n)$。

求 $g(k,n)$，我们可以推出 $g(k,n)$ 的递推式为 
$$g(k,n)=g(k,n-1)+\varphi(nk)$$
因为 $k\times n\leq10^5$，所以我们只要用一个 ```std::vector``` 递推就行了，这块预处理的复杂度也为 $O(n\ln n)$。

这时我们已经预处理出了 $f(n)$ 和 $g(k,n)$，求答案时只要整除分块就行了。

我们令：
$$t(a,b,n)=\sum_{k=1}^nf(k)g(k,a)g(k,b)$$
所以：
$$t(a,b,n)=t(a,b,n-1)+f(n)g(n,a)g(n,b)$$
预处理出 $t(a,b,n)$ 这个前缀和，就可以 $\mathcal{O}(n\sqrt n)$ 的求解这个问题了。但是我们发现，预处理 $t(a,b,n)$ 不光会 $\texttt{TLE}$，还会 $\texttt{MLE}$。这时我们就要使用根号分治，即部分预处理，部分暴力。我们定义一个块长 $S$，对于 $a\leq b\leq S$ 的情况预处理，进行整除分块，剩下的情况直接暴力计算，复杂度为：
$$\mathcal{O}(n\ln n+S\sum_{i=1}^{S}\frac{n}{i}+T(\sqrt n+\frac{n}{S}))$$
$$=\mathcal{O}(n\ln n+S\cdot\frac{n}{S}\sum_{i=1}^{S}\frac{S}{i}+T(\sqrt n+\frac{n}{S}))$$
$$=\mathcal{O}(n\ln n+nS\ln S+T(\sqrt n+\frac{n}{S}))$$
块长 $S$ 会影响复杂度的部位只有 $nS\ln S+\dfrac{Tn}{S}$，除以 $n$，影响复杂度的部分为 $S\ln S+\dfrac{T}{S}$。这时我们可以写一个程序，枚举 $S$ 从 $1$ 到 $n$，得出一个复杂度最小值，该复杂度时的 $S$ 即为块长。

```cpp
#include<bits/stdc++.h>
using namespace std;
double S,T,n=1e5,Omin=1e9;
int pos;

int main()
{
	T=1e4;
	for(S=1;S<=100000;S++)
	{
		double t=S*log(S)+T/S;
		if(t<Omin) Omin=t,pos=S;
	}
	printf("S = %d\n",pos);
	double O=n*log(n)+n*pos*log(pos)+T*(sqrt(n)+n/pos);
	printf("time = %lf\n",O);
	return 0;
}
```
跑了下程序，得出块长为 $46$，时间大约为 $0.44s$，可以通过本题。

$\mathcal{View\ Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,P=998244353,S=46;
int phi[N],mu[N],pr[N],cnt,f[N],iphi[N];bool flg[N];
vector<int>g[N],t[S+5][S+5];
inline void add(int &x,int y) {x=x+y>=P?x+y-P:x+y;}
inline void mul(int &x,int y) {x=1ll*x*y%P;}
inline int ksm(int x,int y) 
{
	int res=1;
	while(y)
	{
		if(y&1) mul(res,x);
		mul(x,x),y>>=1;
	}
	return res;
}
void init(int n)
{
	phi[1]=mu[1]=flg[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!flg[i]) pr[++cnt]=i,phi[i]=i-1,mu[i]=-1;
		for(int j=1;j<=cnt && i*pr[j]<=n;j++) 
		{
			flg[i*pr[j]]=1;
			if(i%pr[j]==0) {phi[i*pr[j]]=phi[i]*pr[j],mu[i*pr[j]]=0;break;}
			phi[i*pr[j]]=phi[i]*phi[pr[j]],mu[i*pr[j]]=-mu[i];
		}
	}
	for(int i=1;i<=n;i++) iphi[i]=ksm(phi[i],P-2);
	for(int i=1;i<=n;i++)	
		for(int j=1;j<=n/i;j++)
			add(f[i*j],(1ll*i*mu[j]*iphi[i]%P+P)%P);
	for(int i=1;i<=n;i++)	
	{
		g[i].resize(n/i+2);
		for(int j=1;j<=n/i;j++)
			g[i][j]=(g[i][j-1]+phi[i*j])%P;
	}
	for(int a=1;a<=S;a++)
		for(int b=a;b<=S;b++)
		{
			t[a][b].resize(n/b+2);
			for(int i=1;i<=n/b;i++)
				t[a][b][i]=(t[a][b][i-1]+1ll*f[i]*g[i][a]%P*g[i][b]%P)%P;
		}
}
int solve(int n,int m)
{
	int ans=0;
	for(int i=1;i<=m/S;i++) add(ans,1ll*f[i]*g[i][n/i]%P*g[i][m/i]%P);
	for(int l=m/S+1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		add(ans,(t[n/l][m/l][r]-t[n/l][m/l][l-1]+P)%P);
	}
	return ans;
}

int main()
{
	init(1e5);
	int T,n,m;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		if(n>m) swap(n,m);
		printf("%d\n",solve(n,m));
	}
	return 0;
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：1)


$$\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)$$

$$=\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\varphi(j)(i,j)}{\varphi((i,j))}$$

$$=\sum_{g=1}^n\frac{g}{\varphi(g)}\sum_{i=1}^{n/g}\sum_{j=1}^{m/g}\varphi(gi)\varphi(gj)[i\perp j]$$
$$=\sum_{g=1}^n\frac{g}{\varphi(g)}\sum_k\mu(k)\sum_{i=1}^{\frac{n}{gk}}\sum_{j=1}^{\frac{n}{gk}}\varphi(gki)\varphi(gkj)$$
$$=\sum_{T=1}^n\left(\sum_{g|T}\frac{g}{\varphi(g)}\mu(\frac Tg)\right)\left(\sum_{i=1}^{n/T}\varphi(Ti)\right)\left(\sum_{j=1}^{m/T}\varphi(Tj)\right)$$

定：

$$S(x,T)=\sum_{i=1}^x\varphi(Ti)$$
$$H(T)=\sum_{g|T}\frac{g}{\varphi(g)}$$

则：

$$=\sum_{T=1}^nH(T)S(\lfloor\frac nT\rfloor,T)S(\lfloor\frac mT\rfloor,T)$$

对 $x,T$ 必须有 $xT\le\max(n,m)$，则有 $O(n\ln n)$ 组可能的 $(x,T)$ 对，用前缀和预处理 $S$ 即可做到 $O(n)$ 询问。考虑设赋予线 $B$：

$$=\sum_{T=1}^{B-1}H(T)S(\lfloor\frac nT\rfloor,T)S(\lfloor\frac mT\rfloor,T)+\sum_{T=B}^nH(T)S(\lfloor\frac nT\rfloor,T)S(\lfloor\frac mT\rfloor,T)$$

对右边有 $\lfloor\frac nT\rfloor,\lfloor\frac mT\rfloor\le \lfloor\frac{\max n}{B}\rfloor$。考虑数论分块时候，$x=\lfloor\frac nT\rfloor,y=\lfloor\frac mt\rfloor$。

我们需要高速求（预处理）这东西：

$$f(x,y,R)=\sum_{T=1}^RH(T)S(x,T)S(y,T)$$

对所有 $x,y$ 暴力前缀和即可。注意对某个固定 $x,y$ 只需要处理到 $R=\lfloor\frac{\max n}{\max(x,y)}\rfloor$。

接下来愉快分析复杂度。

预处理 $S$ 耗时：$O(n\ln n)$。  
数论分块：$O(T\sqrt n)$。  
预处理 $f$：$O(\frac{n^3}{B^2})$。  
式子赋予线之前暴力：$O(TB)$。

考虑平衡 $\frac{n^3}{B^2}+TB$，得

$$\frac{d}{dB}\left(\frac{n^3}{B^2}+TB\right)=T-2\frac{n^3}{B^3}=0$$
$$B=O(\frac{n}{\sqrt[3]{T}})$$

整体时间复杂度 $O(n\ln n+Tn^{1/2}+nT^{2/3})$。

~~喜提最优解~~

---

## 作者：whiteqwq (赞：1)

注：集合$\mathbb{P}$为质数集。

[P4240 毒瘤之神的考验](https://www.luogu.com.cn/problem/P4240)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1710296)

## 题意
- 给定$n,m$，求$\sum_{i=1}^n\sum_{j=1}^m \varphi(i\cdot j)$；
- 多组数据，数据组数$T\leqslant 10^4$。
- 数据范围：$1\leqslant n,m\leqslant 10^5$。

## 分析

莫比乌斯反演结合根号分治好题。

首先，欧拉函数有一个性质：
$$\varphi(n\cdot m)\cdot\varphi(\gcd(n,m))=\varphi(n)\cdot\varphi(m)\cdot\gcd(n,m)$$

证明如下：

由欧拉函数的公式有：

$$\varphi(n\cdot m)\cdot\varphi(\gcd(n,m))$$

$$=n\cdot m\cdot\prod_{p\mid n\cdot m,p\in\mathbb{P}}\frac{p-1}{p}\cdot\gcd(n,m)\cdot\prod_{q\mid\gcd(n,m),q\in\mathbb{P}}\frac{q-1}{q}=n\cdot m\cdot\prod_{p\mid lcm(n,m),p\in\mathbb{P}}\frac{p-1}{p}\cdot\prod_{q\mid\gcd(n,m),q\in\mathbb{P}}\frac{q-1}{q}\cdot\gcd(n,m)$$

$$=n\cdot m\cdot\prod_{p\mid n\ and\ p\mid m,p\in\mathbb{P}}\frac{p-1}{p}\cdot\prod_{q\mid n\ or\ q\mid m,q\in\mathbb{P}}\frac{q-1}{q}\cdot\gcd(n,m)$$

我们根据容斥的思想可以得到：

$$\varphi(n\cdot m)\cdot\varphi(\gcd(n,m))=n\cdot\prod_{p\mid n,p\in\mathbb{P}}\frac{p-1}{p}\cdot m\cdot\prod_{q\mid m,q\in\mathbb{P}}\frac{q-1}{q}\cdot\gcd(n,m)$$

$$=\varphi(n)\cdot\varphi(m)\cdot\gcd(n,m)$$

设$n\geqslant m$，然后我们就可以带入最开始的式子推一下：
$$\sum_{i=1}^n\sum_{j=1}^m\varphi(i\cdot j)=\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\cdot\varphi(j)\cdot\gcd(i,j)}{\varphi(\gcd(i,j))}$$

然后枚举$\gcd$（不妨设$n\leqslant m$：

$$\sum_{i=1}^n\sum_{j=1}^m\varphi(i\cdot j)=\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)==d]\frac{\varphi(i)\cdot\varphi(j)\cdot d}{\varphi(d)}$$
$$=\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)==1]\frac{\varphi(i\cdot d)\cdot\varphi(j\cdot d)\cdot d}{\varphi(d)}$$
$$=\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{k\mid\gcd(i,j)}\mu(k)\cdot\frac{\varphi(i\cdot d)\cdot\varphi(j\cdot d)\cdot d}{\varphi(d)}$$
$$=\sum_{d=1}^n\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{n}{d\cdot k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d\cdot k}\rfloor}\mu(k)\cdot\frac{\varphi(i\cdot d\cdot k)\cdot\varphi(j\cdot d\cdot k)\cdot d}{\varphi(d)}$$
$$=\sum_{t=1}^n\sum_{d\mid t}\frac{d}{\varphi(d)}\cdot\mu(\frac{t}{d})\cdot\sum_{i=1}^{\lfloor\frac{n}{t}\rfloor}\varphi(i\cdot t)\cdot\sum_{j=1}^{\lfloor\frac{m}{t}\rfloor}\varphi(j\cdot t)$$

这个式子并不好处理，可以先设$f(x)=\sum_{d\mid x}\frac{d}{\varphi(d)}\cdot\mu(\frac{x}{d})$，$g(x,y)=\sum_{i=1}^y\varphi(i\cdot x)$，然后原式化为：
$$\sum_{t=1}^n f(t)\cdot g(t,\lfloor\frac{n}{t}\rfloor)\cdot g(t,\lfloor\frac{m}{t}\rfloor)$$

$f(x)$很容易处理，直接枚举因数，然后就可以用总体$O(n\log n)$的复杂度解决。

关于$g(x,y)$，我们可以得到一个很显然的递推式：$g(x,y)=g(x,y-1)+\varphi(x\cdot y)$。

不妨再设$S(x,y,z)=\sum_{t=1}^z f(t)\cdot g(t,x)\cdot g(t,y)$，同样$S(x,y,z)=S(x,y,z-1)+f(t)\cdot g(t,x)\cdot g(t,y)$

但是$x$和$y$的大小均可以到达$n$，因此预处理$g$是不可行的，那么预处理$S$更不行了。

考虑根号分治，我们设一个阈值$t$，那么把答案分成两部分考虑：

- 对于大于$\lfloor\frac{n}{t}\rfloor$的答案部分，可以使用整除分块加$S$的预处理来解决问题，对于整除分块中的区间$[l,r]$，我们答案为$S(\lfloor\frac{n}{l}\rfloor,\lfloor\frac{m}{l}\rfloor,r)-S(\lfloor\frac{n}{l}\rfloor,\lfloor\frac{m}{l}\rfloor,l-1)$，因为$l,r$均大于$t$，所以我们只需要预处理$x\leqslant t,y\leqslant t,z\leqslant n$的所有$S(x,y,z)$，预处理复杂度$O(n\cdot t^2)$，查询复杂度$O(\sqrt{n})$。（注意：如果直接开数组空间会炸，我们可以用$\text{vector}$来实现动态申请$S$的空间）
- 对于小于等于$\lfloor\frac{n}{t}\rfloor$的答案部分，可以直接暴力算答案，即暴力求$\sum_{i=1}^{\lfloor\frac{n}{t}\rfloor}f(i)\cdot g(i,\lfloor\frac{n}{i}\rfloor)\cdot g(i,\lfloor\frac{m}{i}\rfloor)$，因为里面需要用到的$g(x,y)$满足$x\leqslant \lfloor\frac{n}{t}\rfloor,y\leqslant t$，所以我们可以同样预处理满足上述条件的所有$g$，预处理复杂度为$O(n)$，查询为$O(\lfloor\frac{n}{t}\rfloor)$，同样也要动态申请空间。

总复杂度为$O(n\log n+n\cdot t^2+T\cdot(\sqrt{n}+\lfloor\frac{n}{t}\rfloor))$，$t$取$50$左右可过。

## 代码

```
#include<stdio.h>
#include<vector>
#define int long long
using namespace std;
const int maxn=100005,mod=998244353,maxt=55;
int T,n,m,cnt,t;
int a[maxn],p[maxn],miu[maxn],phi[maxn],nphi[maxn],f[maxn];
vector<int>g[maxn],S[maxt][maxt];
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)
			res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}
void init(){
	t=50;
	p[1]=miu[1]=phi[1]=1;
	for(int i=2;i<maxn;i++){
		if(p[i]==0)
			a[++cnt]=i,miu[i]=-1,phi[i]=i-1;
		for(int j=1;j<=cnt;j++){
			if(i*a[j]>=maxn)
				break;
			p[i*a[j]]=1;
			if(i%a[j]==0){
				miu[i*a[j]]=0;
				phi[i*a[j]]=phi[i]*a[j];
				break;
			}
			miu[i*a[j]]=-miu[i];
			phi[i*a[j]]=phi[i]*(a[j]-1);
		}
	}
	for(int i=1;i<maxn;i++)
		nphi[i]=ksm(phi[i],mod-2);
	for(int i=1;i<maxn;i++)
		for(int j=1;i*j<maxn;j++)
			f[i*j]=(f[i*j]+i*nphi[i]%mod*miu[j])%mod;
	for(int i=1;i<maxn;i++){
		g[i].push_back(0);
		for(int j=1;i*j<maxn;j++)
			g[i].push_back((g[i][j-1]+phi[i*j])%mod);
	}
	for(int i=1;i<=t;i++)
		for(int j=1;j<=t;j++){
			S[i][j].push_back(0);
			for(int k=1;k*max(i,j)<maxn;k++)
				S[i][j].push_back((S[i][j][k-1]+f[k]*g[k][i]%mod*g[k][j]%mod)%mod);
		}
}
int solve(int n,int m){
	int res=0,l,r;
	for(int i=1;i<=max(n,m)/t;i++)
		res=(res+f[i]*g[i][n/i]%mod*g[i][m/i]%mod)%mod;
	l=max(n,m)/t+1;
	while(l<=min(n,m)){
		r=min(n/(n/l),m/(m/l));
		res=(res+(S[n/l][m/l][r]-S[n/l][m/l][l-1]+mod)%mod)%mod;
		l=r+1;
	}
	return res;
}
signed main(){
	init();
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld",&n,&m);
		printf("%lld\n",solve(n,m));
	}
	return 0;
}
```

---

## 作者：Phartial (赞：0)

神仙题。

以下设 $n\le m$。

首先有一个经典结论：

$$
\varphi(ij)\varphi(\gcd(i,j))=\varphi(i)\varphi(j)\gcd(i,j)
$$

证明：

我们有

$$
\begin{aligned}
  \varphi(ij)\varphi(\gcd(i,j))
  &=ij\prod_{p\mid i\lor p\mid j} p^{-1}\cdot\gcd(i,j)\prod_{p\mid i\land p\mid j} p^{-1}\\
  &=\gcd(i,j)i\prod_{p\mid i} p^{-1}\cdot j\prod_{p\mid j} p^{-1}\\
  &=\gcd(i,j)\varphi(i)\varphi(j)
\end{aligned}
$$

（第二步由容斥原理可得）

因此有

$$
\begin{aligned}
  &\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)\\
  =&\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}\\
  =&\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=d]\varphi(i)\varphi(j)\\
  =&\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}[\gcd(i,j)=1]\varphi(id)\varphi(jd)\\
  =&\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\varphi(id)\varphi(jd)\sum_{p\mid i,p\mid j}\mu(p)\\
  =&\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{p=1}^{\lfloor n/d\rfloor}\mu(p)\sum_{i=1}^{\lfloor n/dp\rfloor}\sum_{j=1}^{\lfloor m/dp\rfloor}\varphi(idp)\varphi(jdp)\\
  =&\sum_{t=1}^n\sum_{d\mid t}\frac{d}{\varphi(d)}\mu(t/d)\sum_{i=1}^{\lfloor n/t\rfloor}\varphi(it)\sum_{j=1}^{\lfloor m/t\rfloor}\varphi(jt) & t=dp\\
\end{aligned}
$$

设 $f(n)=\displaystyle\sum_{d\mid n}\frac{d}{\varphi(d)}\mu(n/d)$，预处理是简单的，可以做到 $O(n\log n)$。

设 $g(k,n)=\displaystyle\sum_{i=1}^{n}\varphi(ik)$，由于 $ik\le m$，显然此式只有 $O(n\log n)$ 种取值，也可以直接预处理。

那么原式就成了

$$
\begin{aligned}
  &\sum_{t=1}^n\sum_{d\mid t}\frac{d}{\varphi(d)}\mu(t/d)\sum_{i=1}^{\lfloor n/t\rfloor}\varphi(it)\sum_{j=1}^{\lfloor m/t\rfloor}\varphi(jt)\\
  =&\sum_{t=1}^nf(t)g(t,\lfloor n/t\rfloor)g(t,\lfloor m/t\rfloor)
\end{aligned}
$$

发现这个式子不太好数论分块，考虑设 $h(a,b,n)=\displaystyle\sum_{i=1}^nf(i)g(i,a)g(i,b)$，那么原式即可数论分块，即

$$
\begin{aligned}
  &\sum_{t=1}^nf(t)g(t,\lfloor n/t\rfloor)g(t,\lfloor m/t\rfloor)\\
  =&\sum_{\lfloor n/l\rfloor=\lfloor n/r\rfloor,\lfloor m/l\rfloor=\lfloor m/r\rfloor}h(\lfloor n/r\rfloor,\lfloor m/r\rfloor,r)-h(\lfloor n/r\rfloor,\lfloor m/r\rfloor,l-1)\\
\end{aligned}
$$

（可以看成是直接对 $f(t)g(t,\lfloor n/t\rfloor)g(t,\lfloor m/t\rfloor)$ 求前缀和）

但是 $h$ 的取值数量很多，预处理不论是时间还是空间开销都是极大的。

考虑根号分治，设一个阈值 $B$，对于 $\lfloor m/r\rfloor\le B$ 的数预处理，对于 $\lfloor m/r\rfloor >B$ 的数，我们有 $r<\lfloor m/B\rfloor$，这一段可以直接暴力。

这时我们考虑 $h$ 的取值数量量级。对于 $h(a,b,k)$，不妨设 $a\le b$，我们有 $bk\le n$，故取值数量为 $\displaystyle B\sum_{i=1}^Bn/i=Bn\sum_{i=1}^B 1/i=Bn\log B$。

总时间复杂度为 $O(n\log n+Bn\log B+T\cdot(\dfrac{n}{B}+\sqrt{n}))$，空间复杂度为 $O(n\log n+Bn\log B)$。若要最小化上面那个式子，我们就需要满足 $B^2\log B=T$，近似解为 $B=50$。

```cpp
#include <iostream>
#include <vector>

using namespace std;
using LL = long long;

const LL kM = 998244353;
const int kN = 1e5 + 1, kB = 51;

int t, n, m, phi[kN], mu[kN];
LL f[kN];
vector<LL> g[kN], h[kB][kB];
bool v[kN];
vector<int> pri;

LL P(LL b, int e) {
  LL s = 1;
  for (; e; e >>= 1, b = b * b % kM) {
    (e & 1) && (s = s * b % kM);
  }
  return s;
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  mu[1] = phi[1] = 1;
  for (int i = 2; i < kN; ++i) {
    if (!v[i]) {
      pri.push_back(i), phi[i] = i - 1, mu[i] = -1;
    }
    for (int j : pri) {
      int k = i * j;
      if (k >= kN) {
        break;
      }
      v[k] = 1;
      if (i % j) {
        mu[k] = -mu[i], phi[k] = phi[i] * (j - 1);
      } else {
        mu[k] = 0, phi[k] = phi[i] * j;
        break;
      }
    }
  }
  for (int d = 1; d < kN; ++d) {
    LL x = d * P(phi[d], kM - 2) % kM;
    for (int i = 1; i * d < kN; ++i) {
      f[i * d] = (f[i * d] + x * mu[i] % kM + kM) % kM;
    }
  }
  for (int k = 1; k < kN; ++k) {
    g[k].push_back(0);
    for (int i = 1; i * k < kN; ++i) {
      g[k].push_back((g[k].back() + phi[i * k]) % kM);
    }
  }
  for (int i = 1; i < kB; ++i) {
    for (int j = i; j < kB; ++j) {
      h[i][j].push_back(0);
      for (int k = 1; j * k < kN; ++k) {
        h[i][j].push_back((h[i][j].back() + f[k] * g[k][i] % kM * g[k][j] % kM) % kM);
      }
    }
  }
  for (cin >> t; t--; ) {
    cin >> n >> m;
    if (n > m) {
      swap(n, m);
    }
    LL ans = 0;
    for (int l = 1; l <= m / kB; ++l) {
      ans = (ans + f[l] * g[l][n / l] % kM * g[l][m / l] % kM) % kM;
    }
    for (int l = m / kB + 1, r; l <= n; l = r + 1) {
      r = min(n / (n / l), m / (m / l));
      ans = (ans + (h[n / l][m / l][r] - h[n / l][m / l][l - 1] + kM)) % kM;
    }
    cout << ans << '\n';
  }
  return 0;
}
```


---

## 作者：hbhz_zcy (赞：0)

这题相当的神奇，并没有用到筛法。  

令 $d=\gcd(x,y)$，则 $\varphi(xy)=\frac{\varphi (x)\varphi(y)d}{\varphi(d)}$。  
证明：  
不妨设 $x=p^a,y=p^b,0<a\le b$。则 $d=p^x$。  
因此有 $\varphi(xy)=p^{a+b-1}(p-1),\varphi(x)\varphi(y)=p^{a+b-2}(p-1)^2$，而 $\frac{d}{\varphi(d)}=\frac{p}{p-1}$，把额外产生的一个 $p-1$ 变回 $p$。  
对于 $b=0$ 的情况 $d=1,\varphi(d)=1$，依旧成立。又因为 $\varphi$ 是积性函数，所以对于一般情况下也成立。  

不妨设 $n \ge m$，则套路莫反：  
$$\begin{aligned}  
&\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\varphi(ij)\\  
=&\sum\limits_{d=1}^{n}\sum\limits_{i=1}^{\lfloor \frac n d\rfloor}\sum\limits_{j=1}^{\lfloor \frac m d\rfloor}\frac{\varphi(i)\varphi(j)d}{\varphi(d)}\cdot[i \bot j]\\  
=&\sum\limits_{d=1}^{n}\frac{d}{\varphi(d)}\sum\limits_{k=1}^{\lfloor \frac n d\rfloor }\mu(k)\sum\limits_{i=1}^{\lfloor \frac{n}{dk}\rfloor}\sum\limits_{j=1}^{\lfloor \frac{m}{dk}\rfloor}\varphi(idk)\varphi(jdk)\\  
=&\sum\limits_{T=1}^{n}(\sum\limits_{d \mid T}\frac{d}{\varphi(d)}\mu(\frac T d))(\sum\limits_{i=1}^{\lfloor \frac n T \rfloor}\varphi(iT))(\sum\limits_{i=1}^{\lfloor \frac m T \rfloor}\varphi(iT))\\  
\end{aligned}$$

令 $f(T)=\sum\limits_{d \mid T}\frac{d}{\varphi(d)}\mu(\frac T d),g(x,y)=\sum\limits_{i=1}^{y}\varphi(ix)$，则答案为 $\sum\limits_{T=1}^{n}f(T)g(T,\lfloor\frac n T\rfloor)g(T,\lfloor\frac m T\rfloor)$。  
考虑 $f$，我们可以筛出 $\varphi,\mu$，然后枚举倍数 $O(n\ln n)$ 做。对于 $g$，有性质 $xy \le n$，所以可以暴力枚举合法的 $x,y$，复杂度 $O(\log n\cdot\sum\limits_{i=1}^{n}\lfloor\frac n i\rfloor)=O(n \log^2 n)$。因为利用最开始的性质，对于 $1 \le x,y \le n$ 可以 $O(\log n)$ 复杂度求出 $\gcd$，并求出 $\varphi(xy)$。  

发现卷积很难做。具体的，不可能预处理出所有 $T,n,m$。所以只考虑预处理一部分。  
选取一个 $B$，对于 $1 \le t \le n,1 \le x,y \le B$，求出 $s(t,x,y)=\sum\limits_{i=1}^{t}f(i)g(i,x)g(i,y)$。这样的话可以代入 $T,n,m$ 并解决 $\lfloor\frac{n}{T}\rfloor \le B$ 的求值。这部分要求 $T \ge \lfloor \frac n B \rfloor$，可以直接从此处开始进行整除分块，每次差分算贡献 $s(r,\lfloor \frac n l \rfloor,\lfloor \frac m l \rfloor)-s(l-1,\lfloor \frac n l \rfloor,\lfloor \frac m l \rfloor)$。对于 $T \le \lfloor \frac n B \rfloor$，可以直接暴力求。  
概括的说，原本可以都整除分块，但是为了平衡复杂度，只预处理出固定 $n,m$ 的上界和 $T$ 的下界的一部分，剩下的枚举 $T$ 暴力计算。  
时间复杂度 $O(n\log n+n\log^2 n+nB^2+q(\frac n B +\sqrt n))=O(n(\log^2 n+B^2+\frac n B+\sqrt n))$。  
由于 $n,q$ 大致同阶，$B$ 应当取 $n^{\frac 1 3}$，然而空间是 $O(n+n\log n+nB^2)=O(n\log n+nB^2)$ 的，承受不住，所以代码中 $B$ 取的是 $30$。  

理论上能过，实际也能，但是觉得常数很大所以在 $nB^2$ 的地方循环展开了一下。  
$g$ 的定义里先因子再次数，是因为长度不定使用 `vector` 较为方便进行实现。  


```cpp
//g++ c.cpp -o c -g -std=c++14 -O0 -Wall -fsanitize=undefined
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<chrono>
#define LL long long
using namespace std;
const int maxr=1e6+10,maxn=1e5+10,_maxn=1e5,mod=998244353,maxsqn=33,_maxsqn=32;
int N,sqn,prime[maxn],ptop=0,vis[maxn],phi[maxn],mu[maxn],s[maxn][maxsqn][maxsqn];LL ni[maxn],f[maxn];
vector<int>g[maxn];
int stime(){return chrono::steady_clock::now().time_since_epoch().count()/1000;}
namespace rdin{
	char buf[maxr],*l,*r;
	inline char gtc(){if(l==r){r=(l=buf)+fread(buf,1,maxr,stdin);}return l==r?EOF:*l++;}
	inline int qd(){
		int rt=0;char c=gtc();
		while(c<'0'||c>'9')  c=gtc();
		while('0'<=c&&c<='9')  rt=(rt<<3)+(rt<<1)+(c^48),c=gtc();
		return rt;
	}
}
using rdin::qd;
LL piphi(int x,int y){int t=__gcd(x,y);return (LL)phi[x]*phi[y]%mod*t%mod*ni[phi[t]]%mod;}
int main(){
	freopen("in.txt","r",stdin);int cntt=stime();
	phi[1]=mu[1]=ni[0]=ni[1]=1;for(int i=2;i<=_maxn;i++)  ni[i]=mod-mod/i*ni[mod%i]%mod;
	for(int i=2;i<=_maxn;i++){
		if(!vis[i])  prime[++ptop]=i,mu[i]=-1,phi[i]=i-1;
		for(int j=1;j<=ptop&&i*prime[j]<=_maxn;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j])  phi[i*prime[j]]=phi[i]*phi[prime[j]],mu[i*prime[j]]=-mu[i];
			else{phi[i*prime[j]]=phi[i]*prime[j];break;}
		}
	}
//	printf("%d us\n",stime()-cntt);cntt=stime();
	for(int i=1;i<=_maxn;i++)  for(int j=i;j<=_maxn;j+=i)  (f[j]+=i*ni[phi[i]]*mu[j/i])%=mod;
//	printf("%d us\n",stime()-cntt);cntt=stime();
	for(int i=1;i<=_maxn;i++){//i:fac,j:times;
		LL sum=0;g[i].push_back(0);
		for(int j=1;i*j<=_maxn;j++)  g[i].push_back((sum+=piphi(i,j))%=mod);
	}
//	printf("%d us\n",stime()-cntt);cntt=stime();
	/*
	for(int i=1;i<=_maxn;i++){
		for(int j=1;j<=_maxsqn&&i*j<=_maxn;j++){
			LL pi=f[i]*g[i][j]%mod;
			for(int k=1;k<=_maxsqn&&i*k<=_maxn;k++)  s[i][j][k]=(s[i-1][j][k]+pi*g[i][k])%mod;
		}
	}*/
	for(int i=1;i<=_maxn;i++){
		for(int j=min(_maxsqn,_maxn/i);j;j--){
			int k=min(_maxsqn,_maxn/i);LL pi=f[i]*g[i][j]%mod;
			for(;k&7;k--)  s[i][j][k]=(s[i-1][j][k]+pi*g[i][k])%mod;
//			for(;k;k-=8){
//				s[i][j][k]=(s[i-1][j][k]+pi*g[i][k])%mod;s[i][j][k-1]=(s[i-1][j][k-1]+pi*g[i][k-1])%mod;
//				s[i][j][k-2]=(s[i-1][j][k-2]+pi*g[i][k-2])%mod;s[i][j][k-3]=(s[i-1][j][k-3]+pi*g[i][k-3])%mod;
//				s[i][j][k-4]=(s[i-1][j][k-4]+pi*g[i][k-4])%mod;s[i][j][k-5]=(s[i-1][j][k-5]+pi*g[i][k-5])%mod;
//				s[i][j][k-6]=(s[i-1][j][k-6]+pi*g[i][k-6])%mod;s[i][j][k-7]=(s[i-1][j][k-7]+pi*g[i][k-7])%mod;
//			}
			int *p1=&s[i][j][k],*p2=&s[i-1][j][k],*p3=&g[i][k];//we can find that when only use both will be fast
//			for(;k;k--,p1--,p2--,p3--)  p1[0]=(p2[0]+pi*p3[0])%mod;
			for(;k;k-=8,p1-=8,p2-=8,p3-=8){
				p1[0]=(p2[0]+pi*p3[0])%mod;p1[-1]=(p2[-1]+pi*p3[-1])%mod;p1[-2]=(p2[-2]+pi*p3[-2])%mod;p1[-3]=(p2[-3]+pi*p3[-3])%mod;
				p1[-4]=(p2[-4]+pi*p3[-4])%mod;p1[-5]=(p2[-5]+pi*p3[-5])%mod;p1[-6]=(p2[-6]+pi*p3[-6])%mod;p1[-7]=(p2[-7]+pi*p3[-7])%mod;
			}
		}
	}
//	printf("%d us\n",stime()-cntt);cntt=stime();
	int T=qd();
	while(T--){
		int N=qd(),M=qd(),i=1;LL ans=0;if(N<M)  swap(N,M);
		for(;i<=N/_maxsqn;i++)  (ans+=f[i]*g[i][N/i]%mod*g[i][M/i]%mod)%=mod;
		for(int l=i,r;l<=M;l=r+1){r=min(N/(N/l),M/(M/l));(ans+=s[r][N/l][M/l]-s[l-1][N/l][M/l])%=mod;}
		printf("%lld\n",(ans+mod)%mod);
	}
	return 0;
}
```

---

## 作者：SunsetSamsara (赞：0)

## 题意

给定 $n$ 和 $m$，求 $\sum\limits_{i = 1}^n\sum\limits_{j=1}^m\varphi(ij)\bmod{998244353}$（$n \le 10^5$，$m \le 10^5$）

## 前置知识

莫比乌斯反演，杜教筛

## 分析

为了变形这个式子，我们需要利用欧拉函数的一个性质：$\varphi(ij) = \dfrac{\varphi(i)\varphi(j)\gcd(i, j)}{\varphi(\gcd(i, j))}$

这个性质的证明很简单，直接质因数分解展开欧拉函数和最大公因数就可以了。

接下来就是用性质后按套路推式子。

$$
\begin{aligned}
\sum\limits_{i = 1}^n\sum\limits_{j = 1}^m\varphi(ij) &= \sum\limits_{i = 1}^n\sum\limits_{j = 1}^{m}\dfrac{\varphi(i)\varphi(j)\gcd(i, j)}{\varphi(\gcd(i, j))}\\
&= \sum\limits_{d = 1}^n\dfrac{d}{\varphi(d)}\sum\limits_{i = 1}^n\sum\limits_{j = 1}^{m}\varphi(i)\varphi(j)[\gcd(i, j) = d]\\
&= \sum\limits_{d = 1}^n\dfrac{d}{\varphi(d)}\sum\limits_{k = 1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\sum\limits_{i = 1}^{\lfloor\frac{n}{dk}\rfloor}\sum\limits_{j = 1}^{\lfloor\frac{n}{dk}\rfloor}\varphi(idk)\varphi(jdk)\\
&= \sum\limits_{k = 1}^n\sum\limits_{d \mid k}\dfrac{d\mu(\frac{k}{d})}{\varphi(d)}\sum\limits_{i = 1}^{\lfloor\frac{n}{k}\rfloor}\varphi(ik)\sum\limits_{j = 1}^{\lfloor\frac{m}{k}\rfloor}\varphi(jk)
\end{aligned}
$$

容易发现因子部分 $\sum\limits_{d \mid k}\dfrac{d\mu(\frac{k}{d})}{\varphi(d)}$ 可以预处理，把它记作 $f(k)$

接下来另一个部分 $\sum\limits_{i = 1}^{\lfloor\frac{n}{k}\rfloor}\varphi(ik)$ 也设一个函数来处理，令 $g(x, y) = \sum\limits_{i = 1}^y\varphi(ix)$

显然 $g(x, y) = g(x, y - 1) + \varphi(xy)$

再设一个函数 $T(n, a, b) = \sum\limits_{k = 1}^n f(k) g(a, k) g(b, k)$

显然 $T(n, a, b) = T(n - 1, a, b) + f(n)g(a, n)g(b, n)$

于是可以准备数论分块了：对于 $\lfloor\frac{n}{q}\rfloor$ 和 $\lfloor\frac{m}{q}\rfloor$ 相等的区间，答案就是 $T(r, a, b) - T(l - 1, a, b)$。

接下来考虑预处理 $nB^2$ 范围内的答案，$B$ 是随便取的一个常数。

然后就可以在$n / k$ 小于等于 $B$ 的部分用 $T$ 数组数论分块 $O(\sqrt n)$ 地计算答案，大于 $B$ 的部分枚举 $k$ 在 $O(n / B)$ 的时间内计算答案。

最后复杂度 $O(n \log n + nB^2 + T(\sqrt n + n / B))$。

## 代码

```cpp
#include <stdio.h>
#include <math.h>
#include <vector>
#include <algorithm>
#define lld long long
using namespace std;
const lld mod = 998244353;
const int B = 50;
const int maxn = 100000;
int pr[100010];
bool sve[100010];
int mu[100010];
int phi[100010];
int inv[100010];
int f[100010];
int * g[100010]; // 动态申请内存 
int * t[110][110]; // 动态申请内存 
void sieve() {
	mu[1] = phi[1] = inv[1] = sve[1] = 1;
	int cnt = 0;
	for (int i = 2, j, t; i <= maxn; ++ i) {
		if (!sve[i]) {
			pr[++ cnt] = i;
			mu[i] = -1;
			phi[i] = i - 1;
		}
		for (j = 1; j <= cnt && (t = pr[j] * i) <= maxn; ++ j) {
			sve[t] = 1;
			if (!(i % pr[j])) {
				phi[t] = phi[i] * pr[j];
				break;
			}
			phi[t] = phi[i] * (pr[j] - 1);
			mu[t] = -mu[i];
		}
	}
	for (int i = 2; i <= maxn; ++ i)
        inv[i] = mod - 1ll * mod / i * inv[mod % i] % mod;
	for (int i = 1, j, d; i <= maxn; ++ i)
		for (j = i, d = 1; j <= maxn; j += i, ++ d)
			f[j] = 1ll * (1ll * f[j] + 1ll * i * inv[phi[i]] % mod * mu[d] % mod) % mod;
	// 处理 f 
	for (int i = 1, mx; i <= maxn; ++ i) {
		g[i] = new int[(mx = maxn / i) + 1];
		g[i][0] = 0;
		for (int j = 1; j <= mx; ++ j)
			g[i][j] = 1ll * (1ll * g[i][j - 1] + 1ll * phi[i * j]) % mod;
	}
	// 处理 g
	for (int j = 1, i, k, mx; j <= B; ++ j)
		for (k = 1; k <= B; ++ k) {
			t[j][k] = new int[(mx = maxn / max(j, k)) + 1];
			t[j][k][0] = 0;
			for (i = 1; i <= mx; ++ i)
				t[j][k][i] = 1ll * (1ll * t[j][k][i - 1] + 1ll * f[i] * g[i][j] % mod * g[i][k] % mod) % mod;
		}
	// 处理 t 
}
int main() {
	sieve();
	int T, n, m;
	scanf("%d", &T);
	while (T --) {
		scanf("%d%d", &n, &m);
		if (n > m) swap(n, m);
		lld ans = 0;
		for (int i = 1, mx = m / B; i <= mx; ++ i)
			ans = (ans + 1ll * f[i] * g[i][n / i] % mod * g[i][m / i] % mod) % mod;
		for (int i = m / B + 1, j; i <= n; i = j + 1) {
			j = min(n / (n / i), m / (m / i));
			ans = (ans + 1ll * (t[n / i][m / i][j] - t[n / i][m / i][i - 1] + mod) % mod) % mod;
		}
		printf("%lld\n", ans);
	}
}
```

---

## 作者：orz_z (赞：0)

### [P4240 毒瘤之神的考验](https://www.luogu.com.cn/problem/P4240)

求：

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}\varphi(ij)
$$

先要考虑怎么把 $\varphi$ 转成带有 $\gcd$ 或 $\operatorname{lcm}$ 的形式。

性质：$\varphi(ij)=\frac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$。

证明：
$$
\begin{aligned}
\varphi(i)\varphi(j)&=i\prod_{p|i}\frac{p-1}{p}j\prod_{p|j}\frac{p-1}{p} &p\in \text{primes}\\
&=ij\prod_{p|ij}\frac{p-1}{p}\prod_{p|\gcd(i,j)}\frac{p-1}{p}
\end{aligned}
$$
所以有：
$$
\begin{aligned}
\varphi(i)\varphi(j)\gcd(i,j)&=ij\prod_{p|ij}\frac{p-1}{p}\gcd(i,j)\prod_{p|\gcd(i,j)}\frac{p-1}{p}\\
&=\varphi(ij)\varphi(\gcd(i,j))
\end{aligned}
$$


化简式子，有：
$$
\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=1}^{m}\varphi(ij)\\
&=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}\\
&=\sum_{d=1}^{n}\frac{d}{\varphi(d)}\sum_{i=1}^{n}\sum_{j=1}^{m}\varphi(i)\varphi(j)[gcd(i,j)=d]\\
&=\sum_{d=1}^{n}\frac{d}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(id)\varphi(jd)[gcd(i,j)=1]\\
&= \sum_{d=1}^{n}\frac{d}{\varphi(d)}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(id)[p|i]\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(jd)[p|j]\\
&=\sum_{d=1}^{n}\frac{d}{\varphi(d)}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}\varphi(ikd)\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}\varphi(jkd)\\
&=\sum_{T=1}^{n}\left(\sum_{d|T}\frac{d}{\varphi(d)}\mu(\frac{T}{p})\right)\left(\sum_{i=1}^{\lfloor\frac{n}{T}\rfloor}\varphi(iT)\right)\left(\sum_{j=1}^{\lfloor\frac{m}{T}\rfloor}\varphi(jT)\right)& 设 \ T=dp \\
\end{aligned}\\
$$
设 $f(n)=\sum\limits_{d|n}\frac{d}{\varphi(d)}\mu(\frac{n}{p})$，线性筛预处理即可，$\mathcal{O}(n \ln n)$。

设 $g(k,n)=\sum\limits_{i=1}^{n}\varphi(i,k)$，显然 $g(k,n)=g(k,n-1)+\varphi(nk)$。

则原式等于：
$$
\begin{aligned}
\sum_{T=1}^{n}f(T)\times g(T,\lfloor\frac{n}{T}\rfloor)\times g(T,\lfloor\frac{m}{T}\rfloor)
\end{aligned}
$$
发现整除分块不了，考虑把整个式子设出来：
$$
h(a,b,n)=\sum_{t=1}^{n}f(t)\times g(t,a) \times g(t,b)
$$
容易发现，这其实就是一个差分：
$$
h(a,b,n)=\sum_{\lfloor\frac{n}{l}\rfloor=\lfloor\frac{n}{r}\rfloor \operatorname{and} \lfloor\frac{m}{l}\rfloor=\lfloor\frac{m}{r}\rfloor}h(\lfloor\frac{n}{r}\rfloor,\lfloor\frac{m}{r}\rfloor,r)-h(\lfloor\frac{n}{r}\rfloor,\lfloor\frac{m}{r}\rfloor,l)
$$
再考虑根号分治，我们设一个阈值 $S$，将所有 $h(1,1,1) \sim h(S,S,n)$ 的 $h$ 值预处理出来。

预处理式子就是：
$$
h(j,k,i)=h(j,k,i-1)+f(i)\times g(i,j)\times g(i,k)
$$
对于 $\lfloor\frac{n}{r}\rfloor \leq S$ 可直接查询。

否则，可知 $r \leq \lfloor\frac{n}{S}\rfloor$，数论分块计算即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int mod = 998244353;

const int S = 50;

const int maxn = 1e5;

bool vis[maxn + 7];

int tot, prime[maxn + 7];

int mu[maxn + 7], phi[maxn + 7], invphi[maxn + 7];

int sum[maxn + 7];

int *g[maxn + 7], *t[100][100];

int qpow(int x, int y)
{
    int res = 1;
    while (y)
    {
        if (y & 1)
            res = res * (long long)x % mod;
        x = x * (long long)x % mod;
        y >>= 1;
    }
    return res;
}

void init()
{
    phi[1] = mu[1] = invphi[1] = 1;
    for (int i = 2; i <= maxn; i++)
    {
        if (!vis[i])
            prime[++tot] = i, phi[i] = i + (mu[i] = -1);
        for (int j = 1; j <= tot && i * prime[j] <= maxn; j++)
        {
            vis[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            mu[i * prime[j]] = -mu[i];
        }
        invphi[i] = qpow(phi[i], mod - 2);
    }
    for (int pp = 1; pp <= maxn; pp++)
        for (int q = pp, d = 1; q <= maxn; q += pp, d++)
            sum[q] = (sum[q] + pp * (long long)invphi[pp] % mod * mu[d]) % mod, sum[q] += (sum[q] < 0 ? mod : 0);
    for (int i = 1; i <= maxn; i++)
    {
        g[i] = new int[(maxn / i) + 1], g[i][0] = 0;
        for (int j = 1, sb = maxn / i; j <= sb; j++)
            g[i][j] = (g[i][j - 1] + phi[i * j]) % mod;
    }
    for (int j = 1; j <= S; j++)
        for (int k = j; k <= S; k++)
        {
            int len = maxn / max(j, k);
            t[j][k] = new int[len + 1], t[j][k][0] = 0;
            for (int i = 1; i <= len; i++)
                t[j][k][i] = (t[j][k][i - 1] + sum[i] * (long long)g[i][j] % mod * g[i][k] % mod) % mod;
        }
}

signed main()
{
	init();
    int T;
    scanf("%d", &T);
    while (T--)
    {
        int n, m, res = 0;
        scanf("%d%d", &n, &m);
        if (n > m)
            swap(n, m);
        for (int i = 1, kkk = m / S; i <= kkk; i++)
            res = (res + sum[i] * (long long)g[i][n / i] % mod * g[i][m / i] % mod) % mod;
        for (int i = m / S + 1, j; i <= n; i = j + 1)
        {
            j = min(n / (n / i), m / (m / i));
            res = (res + t[n / i][m / i][j] - t[n / i][m / i][i - 1]) % mod, res += (res < 0 ? mod : 0);
        }
        printf("%d\n", res);
    }
    return 0;
}
```

---

## 作者：peterwuyihong (赞：0)

多测，组数小于等于 $10^4$ 求：

$$\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)$$

我们先掏出一个性质。

![](https://i.loli.net/2021/09/14/7wU3hpL5lBuKTJG.png)

默认 $n\le m,x/y\rightarrow\lfloor\frac{x}{y}\rfloor$，然后你一演

$$\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\varphi(j)\gcd(i,j)}{\varphi(\gcd(i,j))}$$

$$\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\varphi(id)\varphi(jd)[\gcd(i,j)=1]$$

$$\sum_{d=1}^n\frac{d}{\varphi(d)}\sum_{k=1}^{n/d}\mu(k)\sum_{i=1}^{n/dk}\sum_{j=1}^{m/dk}\varphi(idk)\varphi(jdk)$$

$$dk\rightarrow T,\sum_{T=1}^n\sum_{d|T}\frac{d}{\varphi(d)}\mu(\frac{T}{d})\sum_{i=1}^{n/T}\varphi(iT)\sum_{j=1}^{m/T}\varphi(jT)$$

你设 $\sum_{d|T}\frac{d}{\varphi(d)}\mu(\frac{T}{d})$ 为 $F$ 函数，它是一个积性函数，可以线性筛。于是我掏出一个线性筛的柿子。

![](https://i.loli.net/2021/09/14/M4iVhPeKsW7u12j.png)

然后就是发扬人类智慧的时候了！

你发现变化后的柿子只要求 $\varphi$ 在 $\text{maxn}$ 以内的值，于是你就掏出来一个 $G$，表示：

$$G(x,y)=\sum_{i=1}^x\varphi(yi)$$

显然 $G$ 不超过调和大小个，暴力预处理即可。

然后你又掏出一个 $H$ ，表示：

$$H(x,y,z)=\sum_{T=1}^z\sum_{d|T}\frac{d}{\varphi(d)}\mu(\frac{T}{d})\sum_{i=1}^{x}\varphi(iT)\sum_{j=1}^{y}\varphi(jT)$$

$$=\sum_{T=1}^zF(T)G(x,T)G(y,T)$$

差分一下，就是 $H(x,y,z)=H(x,y,z-1)+F(z)G(x,z)G(y,z)$

如果你能把答案预处理出来，那将是非常美妙的事，但是会 $\text{MTLE}$，所以我们掏出一个人类智慧，考虑预处理一些东西出来，剩下暴力。

弄出来一个值域 $B$，对于 $m/B$ 以内的 $z$ 暴力用 $G$ 算，其他注意到 $H(x,y,z)$ 中的 $x,y$ 实质就是 $n/T,m/T$，使用整除分块来优化即可。

现在是 $11:33$，我嘴巴完了，看我什么时候写完。

现在是 $11:45$，我写完了。

```cpp
#define int long long
#define maxn 100010
const int p=998244353;
int pri[maxn],f[maxn],phi[maxn],tot;
bitset<maxn>v;
const int B=100;
vector<int>G[maxn],H[B+10][B+10];
int ksm(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=a*a%p)
	if(b&1)ans=ans*a%p;
	return ans;
}
void shai(int n){
	f[1]=phi[1]=1;
	for(int i=2;i<=n;i++){
		if(v[i]==0)pri[++tot]=i,phi[i]=i-1,f[i]=ksm(i-1,p-2);
		for(int j=1;j<=tot&&i*pri[j]<=n;j++){
			v[i*pri[j]]=1;
			if(i%pri[j]==0){
				phi[i*pri[j]]=phi[i]*pri[j];
				if(i/pri[j]%pri[j])f[i*pri[j]]=(p+f[i]-f[pri[j]]*f[i/pri[j]])%p;
				else f[i*pri[j]]=f[i];
				break;
			}
			phi[i*pri[j]]=phi[i]*(pri[j]-1);
			f[i*pri[j]]=f[i]*f[pri[j]]%p;
		}
	}
	for(int i=1;G[i].push_back(0),i<=n;i++)//下标狗才从零开始 
	for(int j=1;j*i<=n;j++)
	G[i].push_back((G[i][j-1]+phi[i*j])%p);
	for(int i=1;i<=B;i++)for(int j=1;j<=B;j++){
		H[i][j].push_back(0);
		for(int k=1;k<=n/max(i,j);k++)
		H[i][j].push_back((H[i][j][k-1]+f[k]*G[k][i]%p*G[k][j])%p);
	}
}
int T,n,m,ans;
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	shai(100000);
	for(cin>>T;T;T--){
		cin>>n>>m;
		if(n>m)swap(n,m);
		ans=0;
		for(int i=1;i<=m/B;i++)ans=(ans+f[i]*G[i][n/i]%p*G[i][m/i])%p;
		for(int L=m/B+1,R;L<=n;L=R+1){
			R=min(n/(n/L),m/(m/L));
			ans=(ans+H[n/L][m/L][R]-H[n/L][m/L][L-1]+p)%p;
		}
		cout<<ans<<endl;
	}
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
为了开内存方便，我把 $G$ 的表示中一二维换了一下。

笑死，根本不卡常。

吐槽一句，跟我之前出的[一道题](https://www.luogu.com.cn/problem/U154979)重了，but全方位吊打我的题。

---


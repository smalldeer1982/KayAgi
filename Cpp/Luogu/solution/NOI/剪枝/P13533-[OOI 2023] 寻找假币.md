# [OOI 2023] 寻找假币

## 题目描述

**这是一个交互式问题。**

你面前有一批 $n$ 枚金币，其中有 $k$ 枚是假币。所有金币排成一行。第 $i$ 枚金币的理论重量为 $i$ 克。如果某枚金币是假币，它的重量为 $0$ 克。

禁止触碰金币，你唯一能进行的操作是选择某个 $1 \leq p \leq n$，称为称重操作，对前 $p$ 枚金币进行称重。你将得到这 $p$ 枚金币的真实总重量。

请你用尽量少的操作，找出哪 $k$ 枚金币是假币。你做的称重次数越少，得分越高，具体请见评分说明。

### 交互说明

每个测试包含 $t$ 局游戏，你需要在每局中找出哪些金币是假币。输入的第一行包含一个整数 $t$（$1 \leq t \leq 50$），表示游戏的局数。每局的交互格式如下。所有局结束后，你的程序应当终止。

每局开始时，给出两个整数 $n$ 和 $k$（$1 \leq n \leq 10^9$，$1 \leq k \leq \min(100, n)$）。此后你可以进行多次称重操作。

要进行一次称重操作，输出 `? p`（注意空格），表示你要称重前 $p$ 枚金币。你将获得一个整数 $a$。如果 $a = -1$，说明你已经超过了本局允许的最大称重次数，你的程序必须立即终止。每局最多允许 $3500$ 次称重。若 $a \geq 0$，则 $a$ 是金币 $1, 2, \ldots, p$ 的真实总重量。

当你确定了假币的位置后，输出 $!\ i_1\ i_2\ \ldots\ i_k$，其中 $1 \leq i_1, i_2, \ldots, i_k \leq n$ 且互不相同，表示你认为是假币的编号，顺序任意。此后你会收到一个整数 $a$。如果 $a = -1$，说明你的答案错误，你的程序必须立即终止。否则 $a = 1$，表示答案正确，你应继续进行下一局或终止（如果这是最后一局）。

注意，交互器是**自适应**的。并不保证每局假币的位置在游戏开始前就已确定。唯一保证的是，交互器给出的所有称重结果，在任何时刻都与某个假币集合相符。你的答案是正确的，如果它与所有你收到的称重结果一致，且不存在另一个假币集合也能与所有称重结果一致。

每次输出后请输出换行符，并刷新输出缓冲区。

如果你使用 Pascal 的 `writeln`，C++ 的 `cout << ... << endl`，Java 的 `System.out.println`，Python 的 `print`，C# 的 `Console.WriteLine`，则会自动刷新缓冲区，无需特殊处理。如果你使用其他输出方式，建议手动刷新。无论如何，每次输出都要换行。


## 说明/提示

### 样例解释

在第一局中，金币 $1$ 和 $3$ 是假币，因此实际重量为 $[0, 2, 0]$。只需一次称重即可得到总重量 $2$，据此可以唯一确定假币的位置。

在第二局中，金币 $2, 6, 8, 10$ 是假币，实际重量为 $[1, 0, 3, 4, 5, 0, 7, 0, 9, 0]$。通过称重结果可以唯一确定假币集合。

### 评分说明

本题测试点分为 6 组。设 $q$ 为你在一局中称重的次数。

前 5 组，每组有一个 $maxQ$，如果你在一局中 $q \leq maxQ$，则该测试点通过。只有通过某组全部测试点，且通过部分之前组全部测试点，才能获得该组分数。

第 6 组为部分分，单局得分为 $\min\left(50, \left\lfloor 50 \sqrt{\frac{k + 30}{q}} \right\rfloor\right)$。该组的总分为所有测试中单局得分的最小值。

注意：如果你在所有测试的所有局中都能做到 $q \leq k + 30$，则可获得 $100$ 分。

| 组别 | 分值 | $n$ | $k$ | $maxQ$ | 必须通过的组 | 备注 |
|:----:|:----:|:---:|:---:|:------:|:------------:|:----:|
| 0    | 0    | --  | --  | $3500$ | --           | 样例测试点 |
| 1    | 5    | $n \leq 1000$ | --   | $1000$ | 0           |      |
| 2    | 9    | $n \leq 1000$ | --   | $600$  | 0, 1        |      |
| 3    | 10   | --  | $k \leq 30$ | $1000$ | 0           |      |
| 4    | 13   | --  | $k = 3$ | $33$   | --           |      |
| 5    | 13   | --  | $k = 4$ | $34$   | --           |      |
| 6    | $\leq 50$ | -- | -- | $3500$ | --           | 部分分数 |


## 样例 #1

### 输入

```
2
3 2

2

1
10 4

13

13

20

29

1```

### 输出

```


? 3

! 1 3


? 5

? 6

? 8

? 10

! 10 8 6 2
```

# 题解

## 作者：chen_zhe (赞：5)

为了解决 $n$ 次询问的情形，我们可以询问所有前缀和。通过相邻前缀和的差值即可还原原序列中的真实元素。

若要用 $\frac{n}{2} + k$ 次询问解决问题，我们可以依次询问前缀和 $n, n-2, n-4, \ldots, n \bmod 2$。如果 $pref_i = i + i-1 + pref_{i-2}$，则 $i-1, i$ 这两个数未被替换。若该等式不成立，则询问 $i-1$。此外我们至多再进行 $k$ 次询问。用类似方法可以找出所有被替换的数字。

接下来，将所有关于 $a$ 的答案替换为 $\frac{p(p+1)}{2} - a$，这样就可以得到被替换数字的前缀和。

来看一个 $k \log n$ 次询问的解法。我们从左到右依次找出每个被替换的数字。为找到第一个 $\geq i$ 的被替换数字，可以用二分查找，找到最小的 $j$，使得 $pref_j > pref_i$。

这个思路可用如下函数实现：${func(l, r, s_l, s_r)}$，它在已知 $[l, r]$ 区间内被替换数字的和为 $s = s_r - s_l$ 时，查找所有被替换数字：

- 若 $s = 0$，则该区间没有被替换的数字。
- 若 $l \leq s \leq 2l$，则区间内必有且仅有一个被替换数字，且它等于 $s$。
- 否则，询问 $mid = \lfloor \frac{l + r}{2} \rfloor$，递归调用：
   - $func(l, mid, s_l, s_{mid})$
   - $func(mid + 1, r, s_{mid}, s_r)$

总操作次数仍为 $O(k \log n)$，但常数更小。

再来看 $2k \log k$ 次询问的解法。我们用 $func(l, r, s_l, s_r)$。假设我们知道区间内有 $c$ 个被替换数字。若我们询问 $p = \lfloor \frac{s}{c} \rfloor$，则至少有一个被替换数字在左侧，至少一个在右侧。通过对 $c$ 做二分查找可以确定分割点。我们无需精确知道 $c$，只需将被替换数字分成两部分。用 $\leq \log k$ 次询问即可分割。总共不会超过 $2k$ 次 $\texttt{func}$ 调用，因为每次都会分割被替换数字的集合。

在上述方案中，我们对 $c$ 在 $[c_l, c_r]$ 区间内二分，其中 $c_l$、$c_r$ 是区间 $[l, r]$ 和为 $s$ 时被替换数字的最小/最大可能数量。一旦分割成功，递归处理两半。这样最多做 $\leq 2k + \log n$ 次询问。证明思路：可以设计一个势能函数，每次询问后势能至少减少 $1$。

完整解法是在上述基础上加入所有可能的优化和剪枝。实现 $func(l, r, c_l, c_r, s_l, s_r)$，初始调用为 $func(1, n, k, k, 0, s_n)$。判断当前区间是否无被替换数字、仅有一个、全被替换，或只差一个未被替换。否则，令 $c_{mid} = \lceil \frac{c_l + c_r}{2} \rceil$，询问 $p = \lfloor \frac{s}{c_{mid}} \rfloor$。若无法分割，则递归调整参数继续。若分割成功，则分别找到左右两段的 $c_l, c_r$，优先递归处理 $c_r - c_l$ 较小的一段，结束后再处理另一半。

在 $\texttt{func}$ 中加入 $c_l, c_r$ 参数，可以利用“被替换数字正好为 $k$ 个”的信息。该函数包含大量 $\texttt{break}$ 和参数约束，因此无法分割的次数很少。实际操作次数通常不超过 $k + 30$。

---


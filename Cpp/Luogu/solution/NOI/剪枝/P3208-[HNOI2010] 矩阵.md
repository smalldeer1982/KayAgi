# [HNOI2010] 矩阵

## 题目描述

小 Z 近日闲来无事，便研究起矩阵来。他先写了一个 $N\times M$ 的矩阵，每个格子里填入了一个小于 $P$ 的非负整数，然后他对于每个 $2\times 2$ 的子矩阵，算出了其中数的和。

譬如 $N=3, M=3, P=3$，小 Z 写的矩阵如下：

$$ A = \begin{pmatrix} 0 & 1 & 2 \\ 1 & 2 & 0 \\ 2 & 0 & 1 \end{pmatrix} $$

共有 $4$ 个 $2\times 2$ 的子矩阵，容易算出它们的和如下：

$$ A = \begin{pmatrix} 0 & 0 & 0 \\ 0 & 4 & 5 \\ 0 & 5 & 3 \end{pmatrix} $$

(第一行和第一列的 $0$ 是为了格式美观而添加进去的)

现在小 Z 想试一试能不能根据这些和推算出原矩阵。由于小 Z 的数学并不好，因此这个任务就交给你了。

当然，小 Z 早就发现了，解很可能不唯一，譬如下面的矩阵算出的和与 $A$ 相同：

$$ A = \begin{pmatrix} 0 & 2 & 1 \\ 0 & 2 & 0 \\ 2 & 1 & 0 \end{pmatrix} $$

示意图在有多个矩阵满足要求的情况下请你输出字典序最小的那一个。

字典序的比较方式如下：对于两个解矩阵 $X$ 和 $Y$，找到 $X$ 和 $Y$ 不同的位置中行数最小的那一个格子，若有多个则取列数最小的那个格子，该位置较小的矩阵字典序较小。

譬如上述的矩阵 $A$ 和 $B$，第一个不同的格子应是第一行第二个格子，而 $A[1][2] < B[1][2]$，故矩阵 $A$ 的字典序比 $B$ 小。

另外，小 Z 的数学还没有差到加法都做错，因此保证输入数据都是有解的。


## 说明/提示

$1 \le N, M \le 200$

$2 \le P \le 10$

感谢 @ASC\_8384 提供题面


## 样例 #1

### 输入

```
3 3 3
0 0 0
0 4 5
0 5 3
```

### 输出

```
0 0 2
2 2 1
1 0 0
```

# 题解

## 作者：lovelyboy (赞：26)

调一年后终于过了，兴奋地点开了题解，然后居然是
# dfs+剪枝
然后楼下大神的代码只有60行，emm

哎简单讲一下我的做法，2-sat+前缀和优化建图+bitset压位
首先发现确定第一行和第一列就可以确定整个矩阵，而且矩阵第i行第j列的值一定可以通过$(1,1)(i,1)(1,j)$三个值算出来。由于每个格子的取值范围很小，我们不妨枚举第一个格子的取值，那么整个矩阵的限制就会转化为$l\leq(i,1)\pm(1,j)\leq r$ 其中$l$和$r$都是可以通过矩阵的信息算出来的。

然后对于将每个$(1,j)$和$(i,1)$的取值拆成$P$个状态，第$i$状态表示这个格子是否可以取小于等于$i$的值，根据2-sat对每个状态建$true$和$false$两个点，然后$i$的$true$向$i+1$的$true$连边，因为如果取了小于等于$i$那一定取$i+1$，同时第$p-1$个格子一定选，那么将$p-1$的$false$向$p-1$的$true$连边。

对于节点之间不等式的关系我们将大于和小于拆成两条限制，然后建边。不妨以
$l\leq(i,1)+(1,j)$为例（$(i,1)+(1,j)\leq r$和这个是一样的）。我们枚举$(i,1)$的取值。假设我们令$(i,1)\leq k$，那么可得$(1,j)\gt l-k-1$
所以我们将$(i,1)$的$k$号节点的$true$向$(1,j)$的$l-k-1$的$false$连边（false表示小于等于不成立也就是大于）即可。

最后跑2-sat，由于要求字典序最小所以需要用$O(VE)$的那个暴力算法，但是这样过不了所以可以用bitset压一下变成$O(\frac{VE}{64})$就可以过了

---

## 作者：DOTime (赞：17)

http://www.cnblogs.com/D-O-Time/p/7999880.html

标签：dfs+剪枝。

题解：

这道题看着就像一道dfs题目，没有什么算法可以用来算这个东西，于是想想暴搜。

如果我们确定因为是2\*2的子矩阵的和，如果确定了其中三个，那么就可以确定第四个，发现如果确定了第一行和第一列的话，就可以确定整个矩阵了，于是我们枚举只有399个了。

因为要求字典序最小，我们先默认第一行和第一列全部是0，求出一个矩阵。我们先搜索第一行，从左到右。发现在（1,1）位置的数+k，那么在除了第一行和第一列的矩阵中，要合法，就要i+j为偶数的-=k，i+j为奇数的+=k即可。同样在（1，j）位置+=k，那么只影响这一列，便偶数行号-=k，奇数行号+=k即可。我们在保证了第一行最小的情况下，只要保证第一列最小即可满足字典序最小，因为确定第一行和第一列可以唯一的确定一个矩阵。

第一行我们暴搜，当然需要剪枝了，对于每搜到第一行的一个数，就要扫一遍这一列，并且更新这一列的每个元素的所在行的行首的范围，也就是矩阵第一列每一个元素的范围，因为矩阵中的每一个元素只被三个数影响，那就是（1,1），以及行首与列首。更新了第一列每一个元素的范围之后，如果冲突即（L>R）那么就返回0。

这里有一个技巧：按道理范围只要开一个O(n)的数组即可，但是这样需要备份，因为如过搜索失败了，那么回溯也要恢复范围数组的值，很麻烦，那么我们直接开一个二维数组，每次更新时取上一列的值与当前值比较之后再更新，这样就没有回溯的问题了，因为我们是从左到右枚举第一行的。


```cpp
 1 #include<cstdio>
 2 #include<iostream>
 3 #include<algorithm>
 4 using namespace std;
 5 const int MAXN=205,INF=0x3f3f3f3f;
 6 int n,m,P;
 7 int L[MAXN][MAXN],R[MAXN][MAXN],A[MAXN][MAXN];
 8 inline int gi(){int res; scanf("%d",&res); return res;}
 9 int F(int x){return (x&1)?1:-1;}
10 int cal(int x,int y) { return A[x][y]+F(x+y)*A[1][1]+F(y)*L[x][m]+F(x)*A[1][y]; }
11 bool dfs(int y)
12 {
13   if(y>m)return 1;
14   int bacl[MAXN]={0},bacr[MAXN]={0};
15   for(A[1][y]=0;A[1][y]<P;A[1][y]++)
16     {
17       bool flag=1;
18       for(int i=2;i<=n;i++)
19         {
20           int tl=(A[i][y] + A[1][1]*F(i+y) + A[1][y]*F(i)) * F(y+1);
21           int tr=(A[i][y] + A[1][1]*F(i+y) + A[1][y]*F(i)-(P-1)) * F(y+1);
22           if(tl>tr)swap(tl,tr);
23           L[i][y]=max(L[i][y-1],tl);
24           R[i][y]=min(R[i][y-1],tr);
25           if(L[i][y]>R[i][y])
26             {flag=0; break;}
27         }
28       if(flag)
29         if(dfs(y+1))
30           return 1;
31     }
32   return 0;
33 }
34 int main()
35 {
36   n=gi(); m=gi(); P=gi();
37   for(int i=1;i<=n;i++)
38     {
39       for(int j=1;j<=m;j++)
40         {
41           A[i][j]=gi();
42           if(i!=1 && j!=1)
43             A[i][j]-=(A[i][j-1]+A[i-1][j]+A[i-1][j-1]);
44           R[i][j]=P-1;
45         }
46     }
47   for(;A[1][1]<P;A[1][1]++)
48     {
49       if(dfs(2))
50         {
51           for(int i=1;i<=n;i++)
52             for(int j=1;j<=m;j++)
53               {
54                 if(j==1 && i>1)
55                   printf("%d ",L[i][m]);
56                 else if(i==1 && j>1)
57                   printf("%d%c",A[1][j],j==m?'\n':' ');
58                 else
59                   printf("%d%c",cal(i,j),j==m?'\n':' ');
60               }
61           return 0;
62         }
63     }
64   return 0;
65 }
```

---

## 作者：Grisses (赞：7)

[题面](https://www.luogu.com.cn/problem/P3208)

看完题目后，我们可以先发现：如果我们确定了原矩阵的第一行和第一列，那么结合给我们的 $S$ 矩阵，我们可以推出原矩阵 $A$ 的每一个元素。式子如下：
$$A_{i,j}=S_{i,j}-A_{i-1,j}-A_{i,j-1}-A_{i-1,j-1}$$

这很明显，因为题目定义对于每一个 $i\in[2,n],j\in[2,m]$ 都有 $S_{i,j}=A_{i-1,j-1}+A_{i-1,j}+A_{i,j-1}+A_{i,j}$。

---

那么，我们假设我们已经枚举出了矩阵 $A$ 的第一行和第一列，我们该如何求出矩阵的所有元素呢？

大家可以自己在纸上手推一下这个表格，大概就长这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/47l6gsi0.png)

经过整理，我们可以发现，$A_{i,j}$ 是由一堆与 $S$ 有关的值与 $A_{1,1},A_{1,j},A_{i,1}$ 进行加加减减得来的。我们再进一步分析，不妨先设 $B_{i,j}$ 表示前面那一堆与 $S$ 有关的值，我们可以找到一点规律：
$$B_{i,j}=S_{i,j}-B_{i-1,j}-B_{i,j-1}-B_{i-1,j-1}$$

~~也不知道为什么我的同学管这玩意叫差分！~~

那么我们就可以先将 $B$ 给预处理出来。

这样式子就处理了一半了，对于后面的与 $A$ 有关的部分，我们发现，它可以写成这样：
$$(-1)^{i+1}\times A_{1,j}+(-1)^{j+1}\times A_{i,1}+(-1)^{i+j+1}\times A_{1,1}$$

证明如下：

对于 $A_{1,j}$ 的部分：

对于 $i=1$ 的情况，显然。

对于 $i>1$ 的情况，不妨设对于 $i-1$ 成立，那么在推 $A_{i,j}$ 的式子中，只有 $A_{i-1,j}$ 会含有 $A_{1,j}$ 这一项。那么结合第一个式子，$A_{i,j}$ 中 $A_{1,j}$ 的系数应为 $-1\times (-1)^{(i-1)+1}$，即 $(-1)^{i+1}$。

那么对于所有 $i\in[1,n]$ 就都成立了。

同理可以证明另外两个部分，只是对于 $A_{1,1}$ 的部分需要升到二维。

---

那么，现在我们也证明了式子是正确的，就可以开始搜索了吗？

当然不够，我们还需要一些优化剪枝，而这个式子只是用来剪枝的。

我们一边枚举第一行的时候，我们就可以通过式子以及每一个元素的范围求出第一列每个元素 $A_{1,j}$ 的范围了，当范围不合法时，就回溯。否则贪心的取范围的最小值最为最终的 $A_{1,j}$。

---

然后，我们就完美的完成了这一道简单的黑题。~~（话说我们的教练拿这玩意作为我们的 CSP-S 的复习题）~~

---

代码：
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,m,p,L[205],R[205],a[205][205],b[205][205],c[205][205];//a是给我们的，b是预处理出来的，c是答案，L、R用来存储范围
  void dfs(int j){
      if(j==m+1){//搜索完了
          for(int i=2;i<=n;i++){
              for(int j=2;j<=m;j++){
                  c[i][j]=a[i][j]-c[i-1][j]-c[i][j-1]-c[i-1][j-1];
              }
          }
          for(int i=1;i<=n;i++){
              for(int j=1;j<=m;j++){
                  printf("%d ",c[i][j]);
              }
              puts("");
          }//输出
          exit(0);//结束
      }
      int l[205],r[205];
      for(int i=2;i<=n;i++)l[i]=L[i],r[i]=R[i];//把范围先存下来
      for(int k=0;k<p;k++){//枚举值
          c[1][j]=k;//更新答案
          bool flag=1;
          if(j>1){
              for(int i=2;i<=n&&flag;i++){
                  c[i][j]=b[i][j]+((i&1)?1:-1)*c[1][j]+(((j+i)&1)?1:-1)*c[1][1];
                  if(j&1){
                      if(c[i][j]>=p)flag=0;
                      else if(c[i][j]<0)L[i]=max(L[i],-c[i][j]);
                      else R[i]=min(R[i],p-c[i][j]-1);
                  }
                  else{
                      if(c[i][j]<0)flag=0;
                      else if(c[i][j]>=p)L[i]=max(L[i],c[i][j]+1-p);
                      else R[i]=min(R[i],c[i][j]);
                  }//更新范围
                  if(L[i]>R[i])flag=0;//不合法
                  c[i][1]=L[i];//合法，贪心的选择
              }
          }
          if(flag)dfs(j+1);//是合法的，递归
          for(int i=2;i<=n;i++)L[i]=l[i],R[i]=r[i];//否则回溯
      }
  }
  signed main()
  {
      scanf("%d%d%d",&n,&m,&p);
      for(int i=1;i<=n;i++)
          for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
      for(int i=2;i<=n;i++)L[i]=0,R[i]=p-1;//范围的处理
      for(int i=1;i<=n;i++)
          for(int j=1;j<=m;j++)b[i][j]=a[i][j]-b[i-1][j]-b[i][j-1]-b[i-1][j-1];//预处理b
      dfs(1);//搜索
      return 0;
  }
```

---

## 作者：BotYoung (赞：5)

前置知识：**dfs及其优化**

拿到题目，我们的目的是根据一个给定的前缀和数组，求出字典序最小的原矩阵。

首先很容易得到，只要确定 $2\times2$ 矩阵中的任意三个数，我们就可以推出该矩阵的全部内容（即：用该矩阵的和减去已知的三个数的和）。将其推广可知，如果我们知道整个矩阵的第一行和第一列，那么我们就可以推出整个矩阵。此题虽然是一道构造题，但是每次构造出来的序列之间毫无关联。所以我们使用搜索算法枚举序列，然后剪枝。

不妨设我们有一个 $3\times3$ 的矩阵，我们来找找规律。假设我们构造出来的部分为 $a$，前缀和数组为 $b$，那么这个矩阵可以表示为：

$A=\left[\begin{matrix}
a_{11} & a_{12} & a_{13}\\
a_{21} & b_{22}-a_{11}-a_{12}-a_{21} & b_{23}-b_{22}+a_{11}-a_{13}+a_{21}\\
a_{31} & b_{32}-b_{22}+a_{11}+a_{12}-a_{31} & b_{33}-b_{23}-b_{32}+b_{22}-a_{11}+a_{13}-a_{31}
\end{matrix}\right]
$

看着有些复杂，但是我们把 $b$ 和 $a$ 分开来看，你会发现：与 $b$ 相关的部分的和是 $b$ 的差分数组。前缀和数组的差分数组为原数组，所以这个多项式与 $b$ 有关的部分，其实是一个构造原数组的可行方案（暂不考虑 $p$ 的大小）。我们预处理出 $b$ 的差分数组 $c$，$c$ 数组即为上述“可行方案”。 $c$ 的计算方法如下:

$$c_{i,j}=b_{i,j}-c_{i-1,j}-c_{i,j-1}-c_{i-1,j-1}$$

但这样构造的数组并不满足 $0\leq a_{i,j}<p$ 的条件，于是我们可以枚举第一行与第一列的情况，同时修改 $i>1,j>1$ 的 $a_{i,j}$ 的值，这里 $a_{i,j}$ 初始化为 $c_{i,j}$。考虑修改第一行的某个数，为了保持整个前缀和数组不变，在 $a_{1,j}+=k$ 的情况下，对该列奇数行的每个数 $+k$，偶数行的每个数 $-k$。具体的，原数组的变动如下：

![示例1](https://cdn.luogu.com.cn/upload/image_hosting/c5isu0p8.png?x-oss-process=image/resize,m_lfit,h_300)

同理，若修改第一列的某个数，原数组的变动如下：

![示例2](https://cdn.luogu.com.cn/upload/image_hosting/91bmnsd3.png?x-oss-process=image/resize,m_lfit,h_300)

唯一特殊的是 $a_{1,1}$，它的值修改后会影响到所有 $i>1,j>1$ 的 $a_{i,j}$，若一个方格的横纵坐标之和为奇数，则该方格内的数 $+k$，否则 $-k$。具体如下：


![示例3](https://cdn.luogu.com.cn/upload/image_hosting/ns89pht5.png?x-oss-process=image/resize,m_lfit,h_300)

最后总结起来。如果将其公式化，可以表示为：

$$a_{i,j}=c_{i,j}+ (-1)^{i-1}a_{1,j}+(-1)^{j-1}a_{i,1}+(-1)^{i+j-1}a_{1,1}  (i>1,j>1)$$

如此一来，我们可以依次搜索枚举出第一行和第一列的数列，进而判断是否合法。搜索时每次优先选择较小的数，即可构造出字典序最小的合法序列。

真有这么简单？

要是真这么简单，这题就不会是黑题了。若如此做，您将会得到 $10$ 分的好成绩。

我们既然已经知道 $c_{i,j}$、$a_{1,j}$ 和 $a_{i,1}$ 的值，那么我们就可以根据最终 $0\leq a_{i,j} < p$ 的条件，计算出 $a_{i,1}$ 的取值范围 $[l_i,r_i]$，然后根据取值范围判断是否合法。根据可行性剪枝，若存在 $i$ 使得 $l_i > r_i$，那么现在构造的矩阵一定是不合法的，跳过此次枚举即可。

然而我们还要行和列的情况处理在一起，事实证明，如果分开构造第一行和第一列，你将仍旧得到 $10$ 分的好成绩。所以我们要计算出每一行的数值的同时，判断当时 $l_i$、$r_i$ 是否合法。开一个数组维护进入搜索时 $l$ 和 $r$ 的值，回溯时将其还原。我们不能只开一个数组，因为每一次搜索都会改变里面的值。所以对于每一次搜索都开一个新的数组，再从当前数组中取出原值即可。

**Code**
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int s = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9'){
		if (c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9'){
		s = s * 10 + c - '0';
		c = getchar();
	}
	return s * f;
} 
inline void write(int x){
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
int n, m, p, a[205][205], b[205][205], c[205][205];
int l[205], r[205], tl[205][205], tr[205][205];
inline bool dfs(int j){
	//搜索定义为bool类型便于判断是否找到了满足条件的解 
	if (j == m + 1) return 1;//边界条件 
	for (int i = 2; i <= n; i++) tl[j][i] = l[i], tr[j][i] = r[i];
	//存储l、r的原值 
	for (int k = 0; k < p; k++){
		a[1][j] = k;
		bool flag = 1;
		//flag标记判断是否合法 
		if (j > 1){
			for (int i = 2; i <= n && flag; i++){
				a[i][j] = c[i][j];
				if (i & 1) a[i][j] += a[1][j];
				else a[i][j] -= a[1][j];
				if ((i + j) & 1) a[i][j] += a[1][1];
				else a[i][j] -= a[1][1];
				if (j & 1){
					if (a[i][j] >= p) flag = 0;
					//加法操作，并且a[i][j]>=p，一定无解 
					else if (a[i][j] < 0) l[i] = max(l[i], -a[i][j]);
					else r[i] = min(r[i], p - 1 - a[i][j]);
					//否则修改a[i][1]的取值范围 
				}
				else{
					//减法操作同理 
					if (a[i][j] < 0) flag = 0;
					else if (a[i][j] >= p) l[i] = max(l[i], a[i][j] - p + 1);
					else r[i] = min(r[i], a[i][j]);
				}
				if (l[i] > r[i]) flag = 0;
				//判断是否合法 
				a[i][1] = l[i];
				//在所有满足条件的数中取最小的，保证字典序最小 
			}
		}
		if (flag) if (dfs(j + 1)) return 1;
		for (int i = 2; i <= n; i++) l[i] = tl[j][i], r[i] = tr[j][i];
		//还原l、r 
	}
	return 0;
}
signed main(){
	n = read(), m = read(), p = read();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			b[i][j] = read();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			c[i][j] = b[i][j] - c[i - 1][j] - c[i][j - 1] - c[i - 1][j - 1];
	//初始化c数组 
	for (int i = 1; i <= n; i++) l[i] = 0, r[i] = p - 1;
	dfs(1);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			if (i == 1 || j == 1) write(a[i][j]), putchar(' ');
			else{
				a[i][j] = c[i][j];
				if (i & 1) a[i][j] += a[1][j];
				else a[i][j] -= a[1][j];
				if (j & 1) a[i][j] += a[i][1];
				else a[i][j] -= a[i][1];
				if ((i & 1) != (j & 1)) a[i][j] += a[1][1];
				else a[i][j] -= a[1][1];
				//根据公式还原原数组 
				write(a[i][j]), putchar(' ');
			}
		}
		putchar('\n');
	}
	return 0;
}
```


------------

upd 2023/10/16: 感谢 @Magic_World 指出的错误

---

## 作者：SUNCHAOYI (赞：3)

这道题不难发现是一道**搜索题 + 找规律题**。

首先根据题意，可以发现若矩阵第一行与第一列被确定，那么整个矩阵中的元素也就能被一一确定。所以每个元素很可能可以根据第一行与第一列上的元素推导出来。需要注意的一点就是 $a[1][1]$ 这个元素，因为它是行与列的相交处。

继续进行推导，设 $s[i][j]$ 表示给定和中的每一项，$a[i][j]$ 表示所求的答案，$f[i][j]$ 表示一个值，即 $f[i][j] = s[i][j] - f[i - 1][j] - f[i][j - 1] - f[i - 1][j - 1]$。

则有：

$$f[i][j] = a[i][j] + (-1)^i \times a[1][j] + (-1) ^ j \times a[i][1] + (-1) ^ {i + j} \times a[1][1]$$ 

因此，我们想要确定一个字典序最小的矩阵，只需要每一行的行首最小。记录的时候可以根据每一个位置的答案范围来记录 ($l-r$)。

完整代码就不给了，放个伪代码吧：


```cpp
//dx - dy 表示符合条件的取值范围 
int work (int x,int y,int value)
{
	if (x % 2 == 1) value += s[1][y];
	else value -= s[1][y];
	if (y % 2 == 1) value += s[x][1];
	else value -= s[x][1];
	if ((x + y) % 2 == 1) value += s[1][1];
	else value -= s[1][1];
	//do sth.
}
bool dfs (int x)
{
	//return
	for (int i = 0;i < p;++i)
	{
		s[1][x] = i;
		bool ok = 1;
		for (int j = 2;j <= n;++j)
		{
			int tmp = work (j,x,a[j][x]);
			if (x % 2 == 1) 
			{
				dx[x][j] = max (dx[x - 1][j],-tmp);
				dy[x][j] = min (dy[x - 1][j],p - 1 - tmp);
			}
			else
			{
				dx[x][j] = max (dx[x - 1][j],tmp + 1 - p);
				dy[x][j] = min (dy[x - 1][j],tmp);
			}
			if (dx[x][j] >= p || dx[x][j] > dy[x][j])// 不符合条件
			{
				ok = 0;
				break;
			}
		}
		//do sth.
 	}
 	//return
}

```

---


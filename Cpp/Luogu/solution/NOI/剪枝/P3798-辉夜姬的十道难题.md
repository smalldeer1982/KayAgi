# 辉夜姬的十道难题

## 题目背景

妹红最近玩了一款叫 $2048$ 的小游戏。

![](https://cdn.luogu.com.cn/upload/pic/5857.png)

(图为个人无撤销最高纪录~ 纯手玩)。

## 题目描述

$2048$ 是一个非常简单的数字游戏，它在 $4\times 4$ 的棋盘上进行，通过移动来合并数字，达到 $2048$ 即算胜利。妹红最近沉迷上了这个游戏，事情传到辉夜那里后，辉夜决定用曾经无人破解的十道难题来考考妹红。

游戏规则：

1. 游戏在 $n\times m$ 的方格棋盘上进行。

2. 两个玩家，其中一个可以移动棋盘上的数字，记做 M，另外一个可以向棋盘上放数字，记做 C。

3. 移动数字的规则如下：可以向上/下/左/右四个方向的其中之一移动。选定好方向后，所有数字都会向该方向靠拢，相同的两个数字相撞时会合并成一个新数字，这个数字是它们的和。在一次移动中，每个数字最多只能合并一次，优先合并靠近移动方向棋盘边缘的数字。

以 $n=2,m=4$ 的情况举例如下（$0$ 表示该位置为空）：

```
2 2 2 2
2 2 0 2
```

向左移动后变为：

```
4 4 0 0
4 2 0 0
```

每次合并后，将会获得一定的分数，获得的分数等于所有合并后数字相加之和。若无任何合并发生，则不得分。在上例中，得分为 $12$。

移动前后，若棋盘上的所有数字大小和位置均没有变化，则不算做有效移动，否则即是有效移动。

4. 向棋盘放置数字的规则如下：只能选择棋盘上没有数字的位置放置一个数字，可以放置的数字和放置方法在每个子任务中会具体描述。

5. 游戏开始时棋盘为空，分数为 $0$。先由玩家 C 行动两步，接着玩家 M 和 C 轮流行动，中间的每一步都必须是有效的。当轮到玩家 M 时，若不能够进行有效移动，则游戏结束，此时的得分为最终得分。

本题目为提交答案题，共有 $10$ 个子任务需要你来完成。将你的答案写到 $10$ 个文件中，分别命名为 ```gamex.out```，$x$ 表示子任务的编号（$0\ldots 9$）。

子任务内无部分分，你可以得到该任务的分数当且仅当你的输出和标准答案完全相同。

十道难题如下:

0. $n=1,m=2$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示在一局游戏中玩家 M 最多可以行动 $x$ 次，那么这个 $x$ 的最值是多少？输出两行，第一行一个整数表示 $x$ 的最小值，第二行一个整数表示 $x$ 的最大值。

1. $n=10738029,m=921023$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示棋盘上所有数字之和，请问 $x$ 的最大值是多少。因为这个值可能过大，只需要输出它除以 $10^9+7$ 的余数即可。

2. $n=2,m=2$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字， $x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，求一个最大的 $x$，使得玩家 M 能达到自己的目标。

3. $n=4,m=4$。玩家 C 行动时可以放置 $2,4$。输出两行，每行一个数字。第一行的数字表示能达到的最大分数。第二行的数字表示当数字总和达到最大时，分数的最小值。

4. $n=7393,m=9133$。玩家 C 可以放置数字 $2$ 共 $6144$ 次。棋盘初始为空，初始分数为 $0$。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。

5. $n=7,m=233$。初始分数为 $0$,玩家 C 可以放置数字 $2$ 共 $233$ 次，数字 $4$ 共 $66$ 次。棋盘第一行一开始有若干数字，第 $i$ 列的数字为 $\text{lowbit}(i)\times 2$，$\text{lowbit}(i)$ 表示数字 $i$ 的二进制形式只取最后一个 $1$ 构成的数字。如 $\text{lowbit}(1\ldots 8)$ 为 $1,2,1,4,1,2,1,8$。棋盘的其他位置均为空。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。

6. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字，$x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现数字 $x$，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，输出一个最大的 $x$，使得玩家 M 能达到自己的目标。

7. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。玩家 M 的目标是让得分最大化，玩家 C 的目标是让得分最小化，在两方均最优决策的情况下，输出一个整数，表示最终的分数。

8. $n=3,m=3$。玩家 C 行动时，有 $90\%$ 的几率放置一个 $2$，$10\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。用 $x$ 表示目标数字，玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数。在玩家 M 最优决策的情况下，输出一行，$9$ 个实数，四舍五入到小数点后 $2$ 位，用空格隔开，分别表示 $x=2,4,8,16,32,64,128,256,512$ 时，达成目标数字的概率。

9. $n=3,m=3$。玩家 C 行动时，有 $90\%$ 的几率放置一个 $2$，$10\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。玩家 M 的目标是让分数最大化。在玩家 M 最优决策的情况下，输出一个实数，四舍五入保留整数，表示分数的期望值。

妹红虽然对 $2048$ 有一定了解，但她并不能解决全部的问题，于是就交给了学 OI 的你。

## 说明/提示

如果对移动规则有疑惑，可以到 $2048$ 网站进行尝试:

http://gabrielecirulli.github.io/2048/

by-orangebird


## 样例 #1

### 输入

```
样例任务（无需提交）:
 n=2,m=2。 玩家C行动时只可以放置2。请输出一个整数，表示棋盘上可能出现的最大数字。
```

### 输出

```
16```

# 题解

## 作者：orangebird (赞：72)

#### 第0个测试点

送分，注意开局C连续行动两次。


#### 第1个测试点

可以推出公式为2^(nm+2)-4，用快速幂处理即可。


#### 第2个测试点

n,m只有2，手玩即可


#### 第3个测试点

经典2048规则。

盘面达到

13W 64K 32K 16K

8K  4K  2K  1K

512 256 128 64

32  16  8   4

时和最大。

最大分数:除了16个合成最大数的关键

时刻必须出4以外，其他均出2，可以得到3632164-16\*4=3932100分。

和最大时的最小得分:每一步都出4，可以得到3670024分。


#### 第4个测试点

非常裸的贪心，全部放在一列即可，最好写程序来模拟一下，手动计算分数太麻烦。


#### 第5个测试点

动态规划。

dfs预处理每一列第一行的数字为x，放i个2，j个4可以得到的最大价值val(x,i,j)。

用dp[i][j][k]表示当前已经完成了前i行,还剩j个2,k个4时的最大得分。

可以得到递推式dp[i][j][k]=max(dp[i-1][j'][k']+val(i,j'-j,k'-k))

初始状态所有dp值均为0

最终答案是max(dp[m][i][j])


#### 第6个测试点

与第2个测试点相同，只是棋盘大小变为3\*3。

虽然只增大了一点范围但是绝对不可手玩。

双方是对抗关系，因此选择max-min搜索法,每个格子的数字有11种可能，每个局面可以轮到玩家M或C，因此状态是11^9\*2。

由于2048游戏的特点，一个状态可以由不同状态转移而来，因此使用记忆化搜索可以大大节省时间。


#### 第7个测试点

注意分数不能算作状态的一部分，否则状态数量会爆炸。

正确的做法应该是保存当前节点向下可以得多少分，然后用与第6个测试点相同的方法搜索即可。

如果记忆化的话就不能用alpha-beta剪枝，因为被beta截断后记忆化存下的结果可能是错误的。

如果仔细分析会发现一个问题，如果直接存储状态，需要的内存超过8GB，一般机器难以接受。

我们记忆化搜索可以只存move节点的结果，这样最坏情况下，时间会增加4倍。因为在move节点的4个移动方向得不到create的答案，只能再往下搜索。

但不是所有节点4个移动方向都是有效的，实际看来时间只增加了一倍，空间可以优化到1/2。


#### 第8个测试点

这里玩家C不再和玩家M对抗，因此改变搜索策略，在玩家C行动的节点取所有子节点达到目标数字的概率和走到该子节点概率相乘，求和的结果。

因为最高只要求算出达到512的概率，所以实际搜索的节点数会大大减少，再加上只对部分节点进行记忆化的优化，空间不会爆。


#### 第9个测试点

与第8个测试点搜索方法类似，但需要搜完全部的节点，对内存要求更高。

下面祭出终极优化，同时优化时间和空间:

一个局面旋转和翻转可以变换成8个等价局面，我们只需要存字典序最小的那个就行。


---

## 作者：_LiWenX_ (赞：10)

车万人看到这个题直接点进来了，然后硬控我好久/tuu。

鉴于没有好抄的题解，我来一篇造福社会。

## sub0

直接手玩，最小直接放 `2 4`，最大先放 `2 2`，变成 `4 0`,再变成 `8 0`，答案分别是 $0,2$。

## sub1

发现明显的上界：每个位置都是不同的二的幂，发现容易构造，而且由于你可以放置 $4$，答案为 $4\sum\limits_{i=0}^{nm-1}2^i=4(2^{nm}-1)$。

## sub2

手玩发现，只要矩形出现连续的 `2 4` 后，答案必然变成 $8$，然而这是无法避免的所以输出 $8$ 即可。

## sub3

直接贪心，具体来说，为了分数尽量大，直接能放 $2$ 就放 $2$，因为 $2+2=4$，可以产生额外贡献，如果只剩下一个位置能放东西，并且最小值为 $4$，那就只能放个 $4$ 了，模拟即可。

为了让分数尽量小，且最大值达到最大，发现直接全部放 $4$ 就好了，模拟一下即可。

答案是 $3932100,3670024$。

## sub4

直接放一长列的 $2$，然后模拟，算出答案，这是显然最大的。

答案是 $143360$。

## sub5

发现放的东西并不多，列与列之间没有啥关联性，所以考虑一列一列背包做。

而对于每一列，考虑设 $p_{i,j,k}$ 表示第 $i$ 列放 $j$ 个 $4$，$k$ 个 $2$ 的最大分数，其实你能放的也就 $7$ 个数，所以直接爆搜放置情况，然后模拟计算即可，使用这个数组就可以辅助转移 dp，答案为 $2932$。

## sub6

其实不是啥正经做法，两个人去对抗的话，能放东西的一方其实挺恶心的，所以猜测答案不会比 $8$ 大多少，所以直接猜测是 $32$，交上去 A 了，一遍过有点难绷的。

正经一点做那就是博弈论状物的爆搜，还是由于最大值不会太大，所以爆搜的代价也不高。

## sub7

上强度了。

显然是一个博弈状物，所以考虑爆搜和 dp 来解决，设 $f_{S,op}$ 表示当前游戏局面为 $S$，是放置还是移动，那么若 $op=1$ 表示放置的话，可以得到转移：

$$f_{S,1}=\min\limits_{S\to S^\prime}f_{S^\prime,0}$$

其中 $S^\prime$ 表示 $S$ 放一个数字可以到达的状态。

$$f_{S,0}=\max\limits_{S\to S^\prime,(S\not= S^\prime)}f_{S^\prime,1}+val$$

其中 $S^\prime$ 表示 $S$ 一次移动可以到达的状态，$val$ 表示此次移动产生的分数。

到这里你会发现，使用记忆化搜索算法，问题会变成一个大模拟，有一些帮助实现或者减少常数上的细节还是可以提一下的：

发现过程中的最大值不会很大，最大也就 $32$，而数字都是 $2$ 的幂，所以只用存指数，一个状态使用 $6$ 进制装压存储，同时实现一个状压数字变成矩阵，矩阵变成状压数字的东西。

加上这个优化直接可以跑出来这一组数据的答案 $164$。

## sub8

发现上述 dp 代码改一改就变成了概率，具体来说，状态依然没啥变化，转移变成:

$$f_{S,1}=\sum\limits_{S\to S^\prime}\dfrac{f_{S^\prime,0}}{cnt}p$$

其中 $cnt$ 是可以放置的数量，$p$ 是放下一个数的概率，放的是 $2$ 则 $p=0.9$，放 $4$ 同理。

$$f_{S,0}=\max\limits_{S\to S^\prime,(S\not= S^\prime)}f_{S^\prime,1}$$

同时，加以限制：我们一个一个跑答案，对于当前求解超过 $x$ 是，若 $S$ 中存在一个位置 $\ge x$，则立刻返回 $1$。

但加上这个优化也甚至不可战胜 $256$。

加上如下优化：

1. 所有式子都变成先加再一起乘。
2. 对于 $f_{S,1}$ 的转移时，求解 $S^\prime$ 的状压值不要重新算，它和 $S$ 只差一个地方，所以类似 hash 一样搞就好了。
3. 记忆化的 map 换成 pbds 的 cc_hash_table。
4. 发现一个状态的翻转，转置矩阵完全等价，直接合并起来这些状态。
5. 换一个好一点的电脑，像我直接换了一个机房去测。

注意一个细节：$2,0,2$ 向左操作会变成 $4,0,0$，被这个东西卡了好久。

然后惊讶的发现，跑 $512$ 只花了仅仅 $45s$！

答案是 `1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 0.74`。

## sub9

和上一个包来比较，转移方程区别更小了，唯一区别可能就是边界情况 dp 值是 $0$，以及 $f_{S,0}$ 的转移要加上操作分数 $val$，然后完全没有区别了。

直接去掉上一个包的最大值限制，放手开跑就对了。

最后答案取整是 $5468$。

三分钟可以跑出来最后一个 sub 的代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")

#define ll long long
using namespace std;
using namespace __gnu_pbds;
const ll B = 11;

int res[5][5], mp[5][5],Res[5][5];

ll P[5][5];

cc_hash_table<ll,double> f;

inline ll to_(){
    // for(int i=1;i<=3;i++){
    //     for(int j=1;j<=3;j++){
    //         if(res[i][j]<0){
    //             cout<<'*';
    //             exit(1);
    //         }
    //     }
    // }
	ll s=0;
    s=s*B+res[1][1];
    s=s*B+res[1][2];
    s=s*B+res[1][3];
    s=s*B+res[2][1];
    s=s*B+res[2][2];
    s=s*B+res[2][3];
    s=s*B+res[3][1];
    s=s*B+res[3][2];
    s=s*B+res[3][3];
	return s;
}
// int lim=10;
double dfs(ll x, int p){
    // if(x<0){
    //     exit(1);
    // }
//	if(x>2e7) exit(0);
	// if(x==0) return 1e9;
	ll Now=x+2357947691ll*p;
	if(f.find(Now)!=f.end()) return f[Now];
	ll now=x; int num[5][5];
	for(int i=3;i>=1;--i){
		for(int j=3;j>=1;--j){
			num[i][j]=now%B;
			now/=B;
			// if(num[i][j]>=lim) return f[Now]=0;
		}
	}

    {
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			res[i][j]=num[3-i+1][3-j+1];
		}
	}
	if(f.find(to_()+2357947691ll*p)!=f.end()) return f[to_()+2357947691ll*p];
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			res[i][j]=num[3-j+1][3-i+1];
		}
	}
	if(f.find(to_()+2357947691ll*p)!=f.end()) return f[to_()+2357947691ll*p];
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			res[i][j]=num[i][3-j+1];
		}
	}
	if(f.find(to_()+2357947691ll*p)!=f.end()) return f[to_()+2357947691ll*p];
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			res[i][j]=num[3-i+1][j];
		}
	}
	if(f.find(to_()+2357947691ll*p)!=f.end()) return f[to_()+2357947691ll*p];
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			Res[i][j]=res[i][j]=num[j][3-i+1];
		}
	}
	if(f.find(to_()+2357947691ll*p)!=f.end()) return f[to_()+2357947691ll*p];
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			res[i][j]=Res[j][3-i+1];
		}
	}
	if(f.find(to_()+2357947691ll*p)!=f.end()) return f[to_()+2357947691ll*p];
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			res[i][j]=num[3-j+1][i];
		}
	}
	if(f.find(to_()+2357947691ll*p)!=f.end()) return f[to_()+2357947691ll*p];
    }
	

	if(p==0){
		int add=0;
		double ans=0;
		for(int is=1;is<=3;++is)
			for(int js=1;js<=3;++js) res[is][js]=num[is][js];
		for(int i=1;i<=3;++i){
			int pos=1, cur=1;
            for(int j=1;j<=3;++j){
                if(res[i][j]==0) continue;
                res[i][cur]=res[i][j]; ++cur;
            }
            while(cur<=3) res[i][cur]=0, ++cur;
			for(int j=1;j<=3;++j){
				if(res[i][j]==0) continue;
				if(res[i][j]==res[i][j+1]){
					res[i][pos]=res[i][j]+1;
					add+=1<<res[i][pos]; 
					++j; ++pos;
				}
				else res[i][pos]=res[i][j], ++pos;
			}
			while(pos<=3) res[i][pos]=0, ++pos;
		}
		if(to_()!=x) ans=max(ans,dfs(to_(),1)+add);
		
		add=0;
		for(int is=1;is<=3;++is)
			for(int js=1;js<=3;++js) res[is][js]=num[is][js];
		for(int i=1;i<=3;++i){
			int pos=3, cur=3;
            for(int j=3;j>=1;--j){
                if(res[i][j]==0) continue;
                res[i][cur]=res[i][j]; --cur;
            }
            while(cur>=1) res[i][cur]=0, --cur;
			for(int j=3;j>=1;--j){
				if(res[i][j]==0) continue;
				if(res[i][j]==res[i][j-1]){
					res[i][pos]=res[i][j]+1;
					add+=1<<res[i][pos]; 
					--pos; --j;
				}
				else res[i][pos]=res[i][j], --pos;
			}
			while(pos>=1) res[i][pos]=0, --pos;
		}
		if(to_()!=x) ans=max(ans,dfs(to_(),1)+add);
		
		add=0;
		for(int is=1;is<=3;++is)
			for(int js=1;js<=3;++js) res[is][js]=num[is][js];
		for(int i=1;i<=3;++i){
			int pos=1, cur=1;
            for(int j=1;j<=3;++j){
                if(res[j][i]==0) continue;
                res[cur][i]=res[j][i]; ++cur;
            }
            while(cur<=3) res[cur][i]=0, ++cur;
			for(int j=1;j<=3;++j){
				if(res[j][i]==0) continue;
				if(res[j][i]==res[j+1][i]){
					res[pos][i]=res[j][i]+1;
					add+=1<<res[pos][i]; 
					++j; ++pos;
				}
				else res[pos][i]=res[j][i], ++pos;
			}
			while(pos<=3) res[pos][i]=0, ++pos;
		}
		if(to_()!=x) ans=max(ans,dfs(to_(),1)+add);
		
		add=0;
		for(int is=1;is<=3;++is)
			for(int js=1;js<=3;++js) res[is][js]=num[is][js];
		for(int i=1;i<=3;++i){
			int pos=3, cur=3;
            for(int j=3;j>=1;--j){
                if(res[j][i]==0) continue;
                res[cur][i]=res[j][i]; --cur;
            }
            while(cur>=1) res[cur][i]=0, --cur;
			for(int j=3;j>=1;--j){
				if(res[j][i]==0) continue;
				if(res[j][i]==res[j-1][i]){
					res[pos][i]=res[j][i]+1;
					add+=1<<res[pos][i]; 
					--pos; --j;
				}
				else res[pos][i]=res[j][i], --pos;
			}
			while(pos>=1) res[pos][i]=0, --pos;
		}
		if(to_()!=x) ans=max(ans,dfs(to_(),1)+add);
		return f[Now]=ans;
	}
	else{
		double ans=0;
		int cnt=0;
		for(int i=1;i<=3;++i){
			for(int j=1;j<=3;++j){
				if(num[i][j]==0){
                    cnt++;
					ans+=0.9*dfs(x+P[i][j],0);
					ans+=0.1*dfs(x+P[i][j]*2,0);
				}
			}
		}
		ans/=cnt;
		return f[Now]=ans;
	}
}

int main(){
//	freopen("game7.out","w",stdout);

	P[3][3]=1;for(int i=3;i;i--){
		for(int j=3;j;j--){
            if(P[i][j]) continue;
			P[i][j]=P[i][j+1]*B;
		}
		P[i-1][4]=P[i][1];
	}

	double ans=0;
	for(int i=1;i<=3;++i){
		for(int j=1;j<=3;++j){
			for(int k=1;k<=3;++k){
				for(int l=1;l<=3;++l){
					for(int w=1;w<=2;++w){
						for(int o=1;o<=2;++o){
							for(int is=1;is<=3;++is){
								for(int js=1;js<=3;++js)
									res[is][js]=0;
							}
							if((pair<int,int>){i,j}==(pair<int,int>){k,l}) continue;
							res[i][j]=w, res[k][l]=o;
							double p1=0.9,p2=0.9;
							if(w==2) p1=1-p1;
							if(o==2) p2=1-p2;
							double ret=dfs(to_(),0);
							ans+=p1*p2*ret/72;
							// cout<<fixed<<setprecision(10)<<ans<<'\n';
						}
					}
				}
			}
		}
	}
	cout<<fixed<<setprecision(10) << ans;
	return 0;
}
```

精确值为 `5468.4867974103`。

后话：感觉这个题没有原作（东方永夜抄）五个「难题」符卡难？只是特别花时间罢了，也许也并没有黑题难度。

---


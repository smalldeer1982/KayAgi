# 区间本质不同子串个数

## 题目描述

给定一个长度为 $n$ 的仅包含小写字母的字符串 $S$，$m$ 次询问由 $S$ 的第 $L$ 到第 $R$ 个字符组成的字符串包含多少个本质不同的非空子串。

定义两个字符串 $a,b$ 相同当且仅当 $|a|=|b|$ 并且对于 $i\in[1,|a|]$ 都有 $a_i=b_i$。

## 说明/提示

#### 样例 1 解释

- 第一次询问，字符串为 $\texttt{aa}$，包含 $\texttt{a}$,$\texttt{aa}$ 共 $2$ 种本质不同子串。
- 第二次询问，字符串为  $\texttt{aba}$，包含  $\texttt{a},\texttt{b},\texttt{ab},\texttt{ba},\texttt{aba}$, 共  $5$ 种本质不同子串。
- 第三次询问，字符串为 $\texttt{babc}$，包含 $\texttt{a}$,$\texttt{b}$,$\texttt{c}$,$\texttt{ab}$,$\texttt{ba}$,$\texttt{bc}$,$\texttt{bab}$,$\texttt{abc}$,$\texttt{babc}$ 共 $9$ 种本质不同子串。

#### 数据规模与约定

- 对于 $20\%$ 的数据，满足 $n\leq 3\times 10^3$，$m\leq 3\times 10^3$。
- 对于 $100\%$ 的数据，满足 $1\leq n\leq 10^5$，$1\leq m\leq 2\times 10^5$，$1\leq l_i\leq r_i\leq n(i\in[1,m])$。

## 样例 #1

### 输入

```
aababc
3
1 2
2 4
3 6```

### 输出

```
2
5
9```

# 题解

## 作者：Fuyuki (赞：76)

对于每个本质不同的字符串 $T$，假设在前缀 $[1,r]$ 中最后一次出现的位置（右端点）为 $last_T$，那么当左端点取到 $[1,last_T-|T|+1]$ 这个区间内的时候，$T$ 会对答案产生 $1$ 的贡献。

采用扫描线的思路，对每个右端点维护所有左端点的答案。

如果把反串的后缀树建出来，那么将右端点右移一位到达 $r$ 就相当于将后缀树上一条到根的路径上的所有字符串的 $last$ 修改成 $r$。如果把这个看作 LCT 中的 access 操作，可以发现划分出来的每条链上的 $last$ 都相同，并且代表的字符串长度连续。

因此直接用 LCT 进行修改，将链合并的时候就是将一段长度连续的本质不同字符串的 $last$ 进行修改，这个对答案的影响可以表现成区间加一个公差为 $1$ 的等差数列，用线段树维护即可。

注意到 access 操作的次数是均摊 $O(logn)$，那么只会进行 $O(nlogn)$ 次线段树上的区间修改，复杂度是 $O(nlog^2n)$ 的。而线段树上查询一次的复杂度是 $O(logn)$，所以总复杂度是 $O(nlog^2n+mlogn)$。

我的实现中将区间加等差数列单点查询转化成区间加常数区间查询，用树状数组实现的时候感觉稍微好写一些。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define P pair<int,int>
#define ll long long int
#define FOR(i,a,b) for(int i=a;i<=b;i++)
const int N=2e5+1,INF=0x3f3f3f3f;
V cmin(int&x,int y){if(y-x>>31)x=y;}
namespace SAM{
	int ch[N][26],fa[N],len[N],tot=1,last=1;
	V cpy(int x,int y){FOR(i,0,25)ch[x][i]=ch[y][i];}
	I ins(int x){
		int p(last),np,q,nq;
		len[np=last=++tot]=len[p]+1;
		while(p&&!ch[p][x])ch[p][x]=np,p=fa[p];
		if(!p)return fa[np]=1,last;
		if(len[q=ch[p][x]]==len[p]+1)return fa[np]=q,last;
		cpy(nq=++tot,q),len[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;
		while(p&&ch[p][x]==q)ch[p][x]=nq,p=fa[p];
		return last;
	}
}
namespace seg{
	ll c[N],d[N];
	I lowbit(int x){return x&-x;}
	V add(int x,int y){for(ll w=x*y;x<N;x+=lowbit(x))c[x]+=y,d[x]+=w;}
	ll ask(int x){
		ll out=0,tmp=0;
		for(int p=x;p;p^=lowbit(p))out+=c[p],tmp+=d[p];
		return out*(x+1)-tmp;
	}
	ll ask(int l,int r){return ask(r)-ask(l-1);}
	V add(int l,int r,int x){add(l,x),add(r+1,-x);}
}
namespace LCT{
	int fa[N],ch[N][2],last[N],tag[N],len[N],val[N];
	I id(int x){return x==ch[fa[x]][1];}
	I nrt(int x){return x==ch[fa[x]][id(x)];}
	V upd(int x){val[x]=len[x];FOR(i,0,1)cmin(val[x],val[ch[x][i]]);}
	V rot(int x){
		int y=fa[x],z=fa[y],p=id(x),w=ch[x][p^1];
		if(nrt(y))ch[z][id(y)]=x;if(w)fa[w]=y;
		fa[y]=x,fa[x]=z,ch[x][p^1]=y,ch[y][p]=w,upd(y),upd(x);
	}
	V add(int x,int w){last[x]=tag[x]=w;}
	V psd(int x){if(tag[x])FOR(i,0,1)add(ch[x][i],tag[x]);tag[x]=0;}
	V psa(int x){if(nrt(x))psa(fa[x]);psd(x);}
	V spl(int x){
		for(psa(x);nrt(x);rot(x))if(nrt(fa[x]))
			rot(id(x)==id(fa[x])?fa[x]:x);
	}
	V acc(int x,int now){
		for(int p=x,y=0;p;p=fa[y=p]){
			spl(p),ch[p][1]=y,upd(p);
			if(last[p])seg::add(last[p]-SAM::len[p]+1,last[p]-val[p]+1,-1);
		}
		spl(x),add(x,now),seg::add(now-SAM::len[x]+1,now,1);
	}
	V init(){
		val[0]=INF;
		FOR(i,1,SAM::tot){
			val[i]=len[i]=SAM::len[fa[i]=SAM::fa[i]]+1;
			tag[i]=ch[i][0]=ch[i][1]=last[i]=0;
		}
	}
}
char a[N];
ll ans[N];
vector<P>q[N];
int T,n,m,l,r,pos[N];
int main(){
	scanf("%s%d",a+1,&m),n=strlen(a+1);
	FOR(i,1,m)scanf("%d%d",&l,&r),q[r].push_back(P(i,l));
	FOR(i,1,n)pos[i]=SAM::ins(a[i]-'a');
	LCT::init();
	FOR(i,1,n){
		LCT::acc(pos[i],i);
		for(P x:q[i])ans[x.first]=seg::ask(x.second,i);
	}
	FOR(i,1,m)cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：灵梦 (赞：46)

为了求解这个问题，我们先考虑「静态区间不同元素种类数」的经典问题。下面是这个问题的一种常见解法：

>对于一个固定的右端点 $i$，贪心地只考虑 $i$ 之前每种元素最后出现的位置。按下标从左到右扫描线，用一棵线段树维护每个位置是否在前缀 $i$ 种最后一次出现。加入第 $i$ 个元素时，在线段树中把当前位置 $+1$，把上一个相同元素的位置 $-1$。询问直接区间查询即可。

对于这道题我们采用相同的思路。把本质相同的子串看作同一种元素，那么插入位置 $i$ 时应该在线段树中加入所有以 $i$ 结尾的子串的贡献。子串是有长度的，但我们只需维护左端点即可。那么「在线段树中把当前位置 $+1$」可以直接一次区间修改来完成，而把「上一个相同元素的位置 $-1$」目前来看不太好做，因为我们还不知道每个子串上一次出现的位置。

为了解决这个问题，我们对原串建立后缀自动机。那么以 $i$ 结尾的子串就是前缀 $i$ 对应的节点在 $parent$ 树上的所有祖先节点。由同一个状态表示的子串，它们「上一次出现的位置」的右端点是相同的，而左端点是连续的一段，所以我们可以通过暴力跳 $parent$ 树上祖先并在线段树上区间修改来达到目的。同时还需要把这条链上的节点都染成 $i$ 颜色，表示把这些子串最后一次出现的位置修改为 $i$。但这样做的复杂度显然是不对的，需要寻求更优的方法。

发现颜色相同的节点的节点会连成一段，我们可以将它们一起处理。由于只有「将某一点到根节点的颜色染成一种没有出现过的颜色」这一种操作，所有需要处理的链上的总颜色数实际上是 $O(n\log n)$ 的。原因是染色操作其实对应着 LCT 的 $\text{Access}$ 操作，可以套用其复杂度证明方法。所以在实现时我们也可以直接使用 LCT 来维护，因为一条实链上的颜色一定都是相同的，直接模拟 $\text{Access}$ 的过程即可。

复杂度是 LCT 的复杂度加上线段树的复杂度，为 $O(n\log^2n+q\log n)$。如果要求在线就上可持久化吧。

下面是两道选做的题目：

- [树点涂色](https://www.luogu.com.cn/problem/P3703) 这道题对最后一段的理解会有很大启发；
- [事情的相似度](https://loj.ac/problem/6041) 一道可以用类似 Trick 解决的题目。

然后是这道题代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN=220000;
int n, q;
char s[MAXN];
namespace SAM
{
	struct Node
	{
		int nxt[26], fail, len;
	} st[MAXN];
	int m, root, lst;
	int pos[MAXN];
	inline int newNode(int l)
	{
		m++;
		memset(st[m].nxt, 0, sizeof st[m].nxt);
		st[m].fail=0, st[m].len=l;
		return m;
	}
	void extend(int x)
	{
		int p=lst, np=newNode(st[p].len+1); lst=np;
		while (p&&!st[p].nxt[x]) st[p].nxt[x]=np, p=st[p].fail;
		if (!p) { st[np].fail=root; return; }
		int q=st[p].nxt[x]; if (st[q].len==st[p].len+1) { st[np].fail=q; return; }
		int nq=newNode(st[p].len+1); memcpy(st[nq].nxt, st[q].nxt, sizeof st[q].nxt);
		st[nq].fail=st[q].fail; st[np].fail=st[q].fail=nq;
		while (p&&st[p].nxt[x]==q) st[p].nxt[x]=nq, p=st[p].fail;
	}
	void build()
	{
		m=0; lst=root=newNode(0);
		for (int i=1; i<=n; i++)
			extend(s[i]-'a'), pos[i]=lst;
	}
}
namespace SGT
{
	struct Node
	{
		int l, r;
		ll sum; int add;
	} tr[4*MAXN];
	#define lc (o<<1)
	#define rc (o<<1|1)
	inline void pushup(int o)
	{
		tr[o].sum=tr[lc].sum+tr[rc].sum;
	}
	inline void add(int o, int k)
	{
		tr[o].sum+=1ll*k*(tr[o].r-tr[o].l+1);
		tr[o].add+=k;
	}
	inline void pushdown(int o)
	{
		if (tr[o].add)
		{
			add(lc, tr[o].add);
			add(rc, tr[o].add);
			tr[o].add=0;
		}
	}
	void build(int o, int l, int r)
	{
		tr[o].l=l, tr[o].r=r;
		tr[o].sum=tr[o].add=0;
		if (l==r) return;
		int mid=l+r>>1;
		build(lc, l, mid), build(rc, mid+1, r);
	}
	void modify(int o, int l, int r, int k)
	{
		if (tr[o].l>r||tr[o].r<l) return;
		if (l<=tr[o].l&&tr[o].r<=r) { add(o, k); return; }
		pushdown(o);
		modify(lc, l, r, k), modify(rc, l, r, k);
		pushup(o);
	}
	ll query(int o, int l, int r)
	{
		if (tr[o].l>r||tr[o].r<l) return 0;
		if (l<=tr[o].l&&tr[o].r<=r) return tr[o].sum;
		pushdown(o);
		return query(lc, l, r)+query(rc, l, r);
	}
	#undef lc
	#undef rc
}
namespace LCT
{
	struct Node
	{
	    int val, cov;
	    int fa, c[2];
	} tr[MAXN];
	#define lc tr[x].c[0]
	#define rc tr[x].c[1]
	#define par tr[x].fa
	inline bool isroot(int x)
	{
	    return tr[par].c[0]!=x&&tr[par].c[1]!=x;
	}
	inline void cover(int x, int k)
	{
		tr[x].val=tr[x].cov=k;
	}
	inline void pushdown(int x)
	{
		if (tr[x].cov)
		{
			if (lc) cover(lc, tr[x].cov);
			if (rc) cover(rc, tr[x].cov);
			tr[x].cov=0;
		}
	}
	inline bool getlr(int x)
	{
	    return tr[par].c[1]==x;
	}
	inline void rotate(int x)
	{
	    int y=par, z=tr[y].fa;
	    bool k=getlr(x); int w=tr[x].c[!k];
	    if (!isroot(y)) tr[z].c[getlr(y)]=x; par=z;
	    tr[y].c[k]=w; if (w) tr[w].fa=y;
	    tr[x].c[!k]=y; tr[y].fa=x;
	}
	void pushall(int x)
	{
	    if (!isroot(x)) pushall(par);
	    pushdown(x);
	}
	void splay(int x)
	{
	    pushall(x);
	    while (!isroot(x))
	    {
	        if (!isroot(par)) rotate(getlr(x)^getlr(par)?x:par);
	        rotate(x);
	    }
	}
	void access(int x, int p)
	{
		int y=0;
	    while (x)
		{
			splay(x);
			if (int k=tr[x].val)
				SGT::modify(1, k-SAM::st[x].len+1, k-SAM::st[par].len, -1);
			rc=y, y=x, x=par;
		}
		cover(y, p);
		SGT::modify(1, 1, p, 1);
	}
	void build()
	{
		for (int i=2; i<=SAM::m; i++)
		{
			tr[i].val=tr[i].cov=0;
			tr[i].c[0]=tr[i].c[1]=0;
			tr[i].fa=SAM::st[i].fail;
		}
	}
	#undef lc
	#undef rc
	#undef par
}
struct Query
{
	int l, r, id;
	bool operator < (const Query& rhs) const
	{
		return r<rhs.r;
	}
} a[MAXN];
ll ans[MAXN];
int main()
{
//	freopen("P6292.in", "r", stdin);
//	freopen("P6292.out", "w", stdout);
	scanf("%s", s+1), n=strlen(s+1);
	SAM::build();
	LCT::build();
	scanf("%d", &q);
	for (int i=1; i<=q; i++)
	{
		scanf("%d%d", &a[i].l, &a[i].r);
		a[i].id=i;
	}
	sort(a+1, a+q+1);
	SGT::build(1, 1, n);
	for (int i=1, j=1; i<=q; i++)
	{
		while (j<=a[i].r)
			LCT::access(SAM::pos[j], j), j++;
		ans[a[i].id]=SGT::query(1, a[i].l, a[i].r);
	}
	for (int i=1; i<=q; i++) printf("%lld\n", ans[i]);
	return 0;
}
```


---

## 作者：灵乌路空 (赞：22)

知识点：SAM，LCT，线段树

原题面：[Luogu](https://www.luogu.com.cn/problem/P6292)。

## 简述

>给定一长度为 $n$ 的字符串 $S$，给定 $m$ 次询问。每次询问给定参数 $l,r$，求由 $s$ 的第 $l$ 到第 $r$ 个字符组成的字符串包含多少个本质不同的子串。  
>定义两个字符串 $a,b$ 相同当且仅当 $|a|=|b|$ 且对于 $i\in[1,|a|]$ 都有  $a_i=b_i$。  
>$1\le n\le 10^5$，$1\le m\le 2\times 10^5$。  
>1S，500MB。

## 分析

一些约定：

记 $s$ 的第 $l$ 到第 $r$ 个字符组成的子串为 $s[l:r]$。  
SAM 的状态 $u$ 的后缀链接为 $\operatorname{link}(u)$。其维护的字符串的终止集合为 $\operatorname{endpos}(u)$，其中最长串的长度为 $\operatorname{len}(u)$，。

### 算法一

先考虑最简单的暴力。  

套路地考虑此类区间无重问题（[P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)），离线询问并按右端点排序。之后枚举右端点，考虑新加入新字符的影响，并回答以枚举位置为右端点的询问。设当前枚举到的右端点为 $r$，某次询问的区间为 $[l,r]$。对于前缀 $s[1:r]$ 中的一个子串 $t$，当且仅当其最后一次出现位置的左端点 $p$ 满足 $p\ge l$ 时，它会对这次询问做出 1 的贡献。  
由上，考虑维护一个权值数列。对于前缀 $s[1:r]$ 中的每种本质不同子串 $t$，记其最后一次出现位置的左端点为 $p$，令权值数列位置 $p$ 加 1。询问区间 $[l,r]$ 的答案即为权值数列对应区间的和。

考虑右端点 $r$ 右移一位的影响。发现仅会影响作为前缀 $s[1:r+1]$ 的后缀的子串的最后一次出现位置。又发现这些子串对应的状态恰好就是前缀 $s[1:r + 1]$ 的 SAM 上从 $s[1:r+1]$ 对应状态到根的链上的所有状态，于是考虑对每个 SAM 的状态 $u$ 维护其 $\operatorname{endpos}$ 集合中的最大值，即其中所有串最后一次出现位置的右端点，记为 $\operatorname{end}_u$。SAM 的每个状态对应子串的 $\operatorname{endpos}$ 集合相同，则同一状态所有串最后一次出现位置的左端点也构成了一段区间，即为 $[\operatorname{end}_u - \operatorname{len}(u) + 1, \operatorname{end}_u - \operatorname{len}(\operatorname{link} (u))]$。并且可以发现这些区间的并即为 $[1,r + 1]$。

考虑动态维护 SAM，在加入新字符后暴力跳 parent 树枚举所有被影响的串对应状态，更新它们最后一次出现位置的左端点对权值区间的贡献即可。权值数列可以使用线段树维护，单次右端点移动复杂度 $O(n\log n)$ 级别，总复杂度 $O((n^2 + m)\log n)$ 级别。

### 算法二

考虑上述算法中在 parent 树上进行了什么操作：

- 从链底暴力上跳，并对每个状态上对应区间进行区间减。
- 将链上每个节点的 $\operatorname{end}_u$ 都修改为 $r+1$。

瓶颈在于操作 1 中每个状态对应的区间不同，必须暴力上跳。但可以发现操作 1 类似 LCT 的 access 操作，操作 2 是以根为端点的链覆盖，考虑使用 LCT 维护 parent 树。

发现 parent 树是一棵有根树，且链覆盖操作一端点为根，仅需对被修改节点 access 成实链后即可直接进行覆盖。且根据此过程可知，一条实链所有状态的 $\operatorname{end}$ 均相同，它们影响的位置构成了一段连续区间，又 LCT 上一个点到根最多有 $\log n$ 级别个 splay，区间减的次数变为 $\log n$ 次，顺便削除了操作 1 造成的瓶颈。

但上述算法中存在一个漏洞。在动态维护 SAM 的过程中需要进行加边删边操作。在此过程中需要进行 access，破坏了上述链覆盖得到的“一条实链所有状态的 $\operatorname{end}$ 均相同”的优美性质。  
但是可以发现根本没有必要动态维护 SAM。可以预先建立 SAM，并维护每个前缀对应的状态。令初始 LCT 中的边全为虚边，LCT 操作时对维护的前缀状态进行操作即可。由于每次链覆盖的对象，都是一段前缀的后缀，显然这样不会使得没有出现过的串做出贡献，可以保证正确性。

单次右端点移动复杂度变为 $O(\log^2 n)$ 级别，总复杂度 $O(n\log^2 n + m\log n)$ 级别。

## 代码

只需要 access 的 LCT 真是太好写辣！

### 算法二

```cpp
//知识点：SAM，LCT，线段树
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#define LL long long
const int kN = 1e5 + 10;
//=============================================================
struct Que {
  int l, r, id;
} q[kN << 1];
int n, m, pos[kN];
LL ans[kN << 1];
char S[kN];
//=============================================================
inline int read() {
  int f = 1, w = 0;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void Chkmax(int &fir, int sec) {
  if (sec > fir) fir = sec;
}
void Chkmin(int &fir, int sec) {
  if (sec < fir) fir = sec;
}
bool CMP(Que fir_, Que sec_) {
  return fir_.r < sec_.r;
}
namespace Seg {
  #define ls (now_<<1)
  #define rs (now_<<1|1)
  #define mid ((L_+R_)>>1)
  const int kNode = kN << 2;
  LL sum[kNode], tag[kNode];
  void Pushup(int now_) {
    sum[now_] = sum[ls] + sum[rs];
  }
  void Pushdown(int now_, int L_, int R_) {
    sum[ls] += 1ll * tag[now_] * (mid - L_ + 1);
    sum[rs] += 1ll * tag[now_] * (R_ - mid);
    tag[ls] += tag[now_];
    tag[rs] += tag[now_];
    tag[now_] = 0ll;
  }
  void Modify(int now_, int L_, int R_, int l_, int r_, LL val_) {
    if (l_ <= L_ and R_ <= r_) {
      sum[now_] += 1ll * (R_ - L_ + 1) * val_;
      tag[now_] += val_;
      return ;
    }
    Pushdown(now_, L_, R_);
    if (l_ <= mid) Modify(ls, L_, mid, l_, r_, val_);
    if (r_ > mid) Modify(rs, mid + 1, R_, l_, r_, val_);
    Pushup(now_);
  }
  LL Query(int now_, int L_, int R_, int l_, int r_) {
    if (l_ <= L_ and R_ <= r_) return sum[now_];
    Pushdown(now_, L_, R_);
    LL ret = 0;
    if (l_ <= mid) ret += Query(ls, L_, mid, l_, r_);
    if (r_ > mid) ret += Query(rs, mid + 1, R_, l_, r_);
    return ret;
  }
  #undef ls
  #undef rs
  #undef mid
}
namespace SAM {
  const int kNode = kN << 2;
  int node_num = 1, last = 1, tr[kNode][26], len[kNode], link[kNode];
  int end[kNode];
  void Insert(int ch_, int pos_) {
    int p = last, now = last = ++ node_num;
    pos[pos_] = now;
    len[now] = len[p] + 1;
    for (; p && !tr[p][ch_]; p = link[p]) tr[p][ch_] = now;
    if (!p) {
      link[now] = 1;
      return ;
    }
    
    int q = tr[p][ch_];
    if (len[q] == len[p] + 1) {
      link[now] = q;
      return ;
    }

    int newq = ++ node_num;
    memcpy(tr[newq], tr[q], sizeof (tr[q]));
    len[newq] = len[p] + 1;
    end[newq] = end[q];
    link[newq] = link[q], link[q] = link[now] = newq;
    for (; p && tr[p][ch_] == q; p = link[p]) tr[p][ch_] = newq;
  }
}
namespace LCT {
  #define f fa[now_]
  #define ls son[now_][0]
  #define rs son[now_][1]
  const int kNode = kN << 2;
  int fa[kNode], son[kNode][2], end[kNode], tag[kNode];
  void Modify(int now_, int val_) {
    if (!now_) return;
    end[now_] = tag[now_] = val_;
  }
  void Pushdown(int now_) {
    if (tag[now_]) Modify(ls, tag[now_]), Modify(rs, tag[now_]);
    tag[now_] = 0;
  }
  bool IsRoot(int now_) {
    return son[f][0] != now_ && son[f][1] != now_;
  }
  bool WhichSon(int now_) {
    return son[f][1] == now_;
  }
  void Rotate(int now_) {
    int fa_ = f, w = WhichSon(now_);
    if (!IsRoot(f)) son[fa[f]][WhichSon(f)] = now_;
    f = fa[f];

    son[fa_][w] = son[now_][w ^ 1];
    fa[son[fa_][w]] = fa_;

    son[now_][w ^ 1] = fa_;
    fa[fa_] = now_;
  }
  void Update(int now_) {
    if (!IsRoot(now_)) Update(f);
    Pushdown(now_);
  }
  void Splay(int now_) {
    Update(now_);
    for (; !IsRoot(now_); Rotate(now_)) {
      if (!IsRoot(f)) Rotate(WhichSon(f) == WhichSon(now_) ? f : now_);
    }
  }
  void Access(int pos_) {
    int last_ = 0, now_ = pos[pos_];
    for (; now_; last_ = now_, now_ = f) {
      Splay(now_), rs = last_;
      if (end[now_]) { //减去之前 end 的贡献
        Seg::Modify(1, 1, n, end[now_] - SAM::len[now_] + 1,
                             end[now_] - SAM::len[f], -1); //注意被修改区间
      }
    }
    Seg::Modify(1, 1, n, 1, pos_, 1); //
    Modify(last_, pos_); //链覆盖，更新 end
  }
}

void Init() {
  scanf("%s", S + 1);
  n = strlen(S + 1);
  m = read();
  for (int i = 1; i <= m; ++ i) q[i] = (Que) {read(), read(), i};
  std::sort(q + 1, q + m + 1, CMP);
  for (int i = 1; i <= n; ++ i) SAM::Insert(S[i] - 'a', i);
  for (int i = 1; i <= SAM::node_num; ++ i) LCT::fa[i] = SAM::link[i]; //初始时全为虚边
}
//=============================================================
int main() { 
  Init();
  for (int r = 1, i = 1; r <= n; ++ r) {
    LCT::Access(r);
    for (; q[i].r <= r && i <= m; ++ i) {
      ans[q[i].id] = Seg::Query(1, 1, n, q[i].l, q[i].r);
    }
  }
  for (int i = 1; i <= m; ++ i) printf("%lld\n", ans[i]);
  return 0; 
}
```

### 算法一

```cpp
//知识点：SAM
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#define LL long long
const int kN = 1e5 + 10;
//=============================================================
struct Que {
  int l, r, id;
} q[kN << 1];
int n, m;
LL ans[kN << 1];
char S[kN];
//=============================================================
inline int read() {
  int f = 1, w = 0;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void Chkmax(int &fir, int sec) {
  if (sec > fir) fir = sec;
}
void Chkmin(int &fir, int sec) {
  if (sec < fir) fir = sec;
}
bool CMP(Que fir_, Que sec_) {
  return fir_.r < sec_.r;
}
namespace Seg {
  #define ls (now_<<1)
  #define rs (now_<<1|1)
  #define mid ((L_+R_)>>1)
  const int kNode = kN << 2;
  LL sum[kNode], tag[kNode];
  void Pushup(int now_) {
    sum[now_] = sum[ls] + sum[rs];
  }
  void Pushdown(int now_, int L_, int R_) {
    sum[ls] += 1ll * tag[now_] * (mid - L_ + 1);
    sum[rs] += 1ll * tag[now_] * (R_ - mid);
    tag[ls] += tag[now_];
    tag[rs] += tag[now_];
    tag[now_] = 0ll;
  }
  void Modify(int now_, int L_, int R_, int l_, int r_, LL val_) {
    if (l_ <= L_ and R_ <= r_) {
      sum[now_] += 1ll * (R_ - L_ + 1) * val_;
      tag[now_] += val_;
      return ;
    }
    Pushdown(now_, L_, R_);
    if (l_ <= mid) Modify(ls, L_, mid, l_, r_, val_);
    if (r_ > mid) Modify(rs, mid + 1, R_, l_, r_, val_);
    Pushup(now_);
  }
  LL Query(int now_, int L_, int R_, int l_, int r_) {
    if (l_ <= L_ and R_ <= r_) return sum[now_];
    Pushdown(now_, L_, R_);
    LL ret = 0;
    if (l_ <= mid) ret += Query(ls, L_, mid, l_, r_);
    if (r_ > mid) ret += Query(rs, mid + 1, R_, l_, r_);
    return ret;
  }
  void Debug(int now_, int L_, int R_) {
    if (L_ == R_) {
      printf("%lld ", sum[now_]);
      return ;
    }
    Pushdown(now_, L_, R_);
    Debug(ls, L_, mid), Debug(rs, mid + 1, R_);
  }
}
namespace SAM {
  const int kNode = kN << 2;
  int node_num = 1, last = 1, tr[kNode][26], len[kNode], link[kNode];
  int end[kNode];
  void Insert(int ch_) {
    int p = last, now = last = ++ node_num;
    len[now] = len[p] + 1;
    for (; p && !tr[p][ch_]; p = link[p]) tr[p][ch_] = now;
    if (!p) {
      link[now] = 1;
      return ;
    }
    
    int q = tr[p][ch_];
    if (len[q] == len[p] + 1) {
      link[now] = q;
      return ;
    }

    int newq = ++ node_num;
    memcpy(tr[newq], tr[q], sizeof (tr[q]));
    len[newq] = len[p] + 1;
    end[newq] = end[q];
    link[newq] = link[q], link[q] = link[now] = newq;
    for (; p && tr[p][ch_] == q; p = link[p]) tr[p][ch_] = newq;
  }
  void Modify(int pos_) {
    int u = last;
    for (; u != 1; u = link[u]) {
      if (end[u]) Seg::Modify(1, 1, n, end[u] - len[u] + 1, end[u] - len[link[u]], -1);
      end[u] = pos_;
    }
    Seg::Modify(1, 1, n, 1, pos_, 1);
  }
}
void Init() {
  scanf("%s", S + 1);
  n = strlen(S + 1);
  m = read();
  for (int i = 1; i <= m; ++ i) q[i] = (Que) {read(), read(), i};
  std::sort(q + 1, q + m + 1, CMP);
}
//=============================================================
int main() { 
  Init();
  for (int r = 1, i = 1; r <= n; ++ r) {
    SAM::Insert(S[r] - 'a');
    SAM::Modify(r);
    for (; q[i].r <= r && i <= m; ++ i) {
      ans[q[i].id] = Seg::Query(1, 1, n, q[i].l, q[i].r);
    }
  }
  for (int i = 1; i <= m; ++ i) printf("%lld\n", ans[i]);
  return 0; 
}
```

---

## 作者：封禁用户 (赞：16)

题解区清一色地都是 LCT ，但是本题并不需要这个十级算法。给出一种树剖做法。  
~~啥，你说 SAM 也是十级？不好意思，我只用到了后缀树~~  
~~不过貌似不仅没有 LCT 做法好写，也没有 LCT 做法常数小~~  

首先建出 SAM 。  
SAM 可以表达所有子串，这给予了我们一个对每个子串计算贡献的平台。

我们考虑如下问题：  
对于 SAM 上的一个节点 $x$，假设它代表的长度区间为 $[l_1,l_2]$，的出现位置集合为 $edp$（也就是 SAM 上对应节点的 $\text{endpos}$ 集合）。如果询问区间的右端点在 $r$，那么如果询问的左端点在 $l$，那节点 $x$ 对询问的贡献是多少呢？  

首先，我们找到 $edp$ 中 $\leq r$ 的最大的元素是谁，记为 $p$ （当然，如果不存在 $\leq r$ 的元素就没有贡献）。那么贡献分三种：
- 若 $l > p-l_1+1$，贡献为 $0$。
- 若 $p-l_2+1 \leq l \leq p-l_1+1$，那么贡献为 $(p-l_1+1) - (l) + 1$。
- 否则 $l < p-l_2+1$，贡献为 $l_2-l_1+1$。  

（这里可以画个图理解一下）  
那这三段每段的贡献都是一个一次函数（自变量为 $l$）。  
一次函数的求和是一个简单的问题，可以通过两个 BIT ，一个维护常数项，一个维护一次项解决。  

而且 $r \gets r+1$（$r$ 自增 $1$）导致了 $x$ 的贡献出现了变化，当且仅当自增后的 $r$ 在 $x$ 的 $\text{endpos}$ 集合 $edp$ 中出现过，因为我们的 $p$ 是 $edp$ 中 $\leq r$ 的最大元素。

所以我们现在有这样一个做法：扫描线，扫右端点 $r$，两个 BIT 维护每个左端点的答案。具体的维护就是每次 $r$ 自增 $1$ 的时候会有若干节点的贡献产生变化，在 BIT 上做对应修改即可（先减掉原来的贡献，再加上新的贡献）。

但是这样至少可以卡到 $\mathcal{O}(n^2)$，因为所有节点 $\text{endpos}$ 集合的大小之和是 $\mathcal{O}(n^2)$ 的，所以总的贡献变化次数也是 $\mathcal{O}(n^2)$ 的。

我们考虑优化它。  
首先，$\text{endpos}$ 集合中出现过某个数 $r$ 的点一定是 Parent Tree 上代表 $r$ 前缀的点到根的所有点。  

想一想，为什么我们不能直接对这条链的贡献做修改？因为他们上一次被覆盖的 $r$（也就是 $\text{endpos}$ 集合中上一个数）是不一样的，所以要先去掉的贡献也是不一样的。  

定义一个点的颜色为其上次被覆盖的 $r$，那么我们可以对更新贡献之前颜色相同的点一起更新，因为它们要减掉的贡献是一样的，同时代表的长度也是一段连续区间。  

我们现在要进行的更新是，找到一条链上所有不同的颜色段（相同的颜色只会呈一条链），分别更新贡献，并把它们染成一种新的颜色。  

**这个东西是可以证明每次更新的不同颜色段个数的和是 $\mathcal{O}(n \log n)$ 的。** 因为每更新一条重链，这条链上会减少若干个同色段，但是增加的同色段个数是常数个（其实就 $1$ 个）。根据简单的势能分析，每次更新的同色段个数之和上界就是所有更新遍历的重链次数和，这个明显是 $\mathcal{O}(n \log n)$ 。

那么我们每次更新（$r$ 自增 $1$）的时候，把它到根的路径拆成 $\log n$ 条重链，不同重链之间互相独立更新。每次看重链上是否都是同一个颜色，如果是，一起更新；否则，找到最下面的同色段，更新它们。这个找同色段可以通过线段树完成（线段树维护区间左、右的颜色和最靠右的与下一个位置异色的位置）。

那么我们共有 $\mathcal{O}(n\log n)$ 次贡献的更新，每次都付出了 $\mathcal{O}(\log n)$ 的代价。所以复杂度是 $\mathcal{O}(n\log^2 n+m\log n)$ 的，与 LCT 做法相同。

```cpp
#include <stdio.h>
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 1e5 + 5;
const int M = 2e5 + 5;
int n, m;
char s[N];
struct Query { int id, l, r; } q[M];
inline bool operator < (Query A, Query B) { return A.r < B.r; }
ll ans[M];

struct BIT {
	ll tr[N];
	BIT () { memset(tr, 0, sizeof tr); }
	inline int lowbit (int x) { return x & (-x); }
	void update (int x, int c) { for(; x <= n; x += lowbit(x)) tr[x] += c; }
	void update (int l, int r, int c) { update(l, c); update(r + 1, -c); }
	ll query (int x) { ll r = 0; for(; x; x -= lowbit(x)) r += tr[x]; return r; }
};

struct Contributor {
	BIT bit0, bit1; // 常数项、一次项系数
	void update (int l, int r, int p, int c) {
		if(p != r) bit0.update(1, p - r, c * (r - l + 1));
		bit0.update(p - r + 1, p - l + 1, c * (p - l + 2));
		bit1.update(p - r + 1, p - l + 1, c * (-1));
	}
	ll query (int p) {
		ll ans = 0;
		ans += bit0.query(p);
		ans += p * bit1.query(p);
		return ans;
	}
} con;

namespace SAM {
	const int N = 2e5 + 5;
	int lst, n;
	int ch[N][26];
	int fa[N], len[N];
	
	int head[N], cnt;
	struct Edge { int to, nxt; } e[N];
	inline void addE (int x, int y) {
		e[++ cnt] = (Edge){y, head[x]};
		head[x] = cnt;
	}
	
	int dep[N], siz[N], son[N];
	int top[N], dfn[N], ind[N], D;
	
	struct Node { int lc, rc, pos; };
	inline Node merge (Node A, Node B, int mid) {
		Node C;
		C.lc = A.lc; C.rc = B.rc;
		if(B.pos) C.pos = B.pos;
		else if(A.rc != B.lc) C.pos = mid;
		else C.pos = A.pos;
		return C;
	}
	inline void operate (Node &A, int tg) {
		A.lc = A.rc = tg;
		A.pos = 0;
	}
	
	struct SegmentTree {
		Node tr[N << 2];
		int tg[N << 2];
		
		inline void pushup (int x, int mid) { tr[x] = merge(tr[x << 1], tr[x << 1 | 1], mid); }
		inline void modify (int x, int v) { operate(tr[x], v); tg[x] = v; }
		inline void pushdown (int x) {
			if(!tg[x]) return;
			modify(x << 1, tg[x]);
			modify(x << 1 | 1, tg[x]);
			tg[x] = 0;
		}
		
		void update (int x, int ul, int ur, int l, int r, int c) {
			if(l >= ul && r <= ur) { modify(x, c); return; }
			pushdown(x); int mid = l + r >> 1;
			if(mid >= ul) update(x << 1, ul, ur, l, mid, c);
			if(mid < ur) update(x << 1 | 1, ul, ur, mid + 1, r, c);
			pushup(x, mid);
		}
		
		Node query (int x, int ql, int qr, int l, int r) {
			if(l >= ql && r <= qr) return tr[x];
			pushdown(x); int mid = l + r >> 1;
			bool c1 = (mid >= ql), c2 = (mid < qr);
			if(c1 && !c2) return query(x << 1, ql, qr, l, mid);
			else if(!c1 && c2) return query(x << 1 | 1, ql, qr, mid + 1, r);
			else return merge(query(x << 1, ql, qr, l, mid), query(x << 1 | 1, ql, qr, mid + 1, r), mid);
		}
	} sgt;
	
	void insert (int c) {
		int p = lst, np = ++ n;
		lst = np; len[np] = len[p] + 1;
		
		for(; p && !ch[p][c]; p = fa[p])
			ch[p][c] = np;
		
		if(!p) fa[np] = 1;
		else {
			int q = ch[p][c];
			if(len[q] == len[p] + 1) fa[np] = q;
			else {
				int nq = ++ n;
				memcpy(ch[nq], ch[q], sizeof ch[q]);
				fa[nq] = fa[q];
				len[nq] = len[p] + 1;
				fa[np] = fa[q] = nq;
				
				for(; p && ch[p][c] == q; p = fa[p])
					ch[p][c] = nq;
			}
		}
	}
	
	void dfs1 (int x) {
		dep[x] = dep[fa[x]] + 1;
		siz[x] = 1;
		for(int i = head[x]; i; i = e[i].nxt) {
			int y = e[i].to;
			dfs1(y);
			siz[x] += siz[y];
			if(siz[y] > siz[son[x]]) son[x] = y;
		}
	}
	
	void dfs2 (int x, int tp) {
		top[x] = tp;
		dfn[x] = ++ D;
		ind[D] = x;
		
		if(!son[x]) return;
		dfs2(son[x], tp);
		
		for(int i = head[x]; i; i = e[i].nxt) {
			int y = e[i].to;
			if(y == son[x]) continue;
			dfs2(y, y);
		}
	}
	
	void build (char *s) {
		lst = n = 1;
		for(int i = 1; s[i]; ++ i)
			insert(s[i] - 'a');
		for(int x = 2; x <= n; ++ x)
			addE(fa[x], x);
		dfs1(1);
		dfs2(1, 1);
	}
	
	void update (int p, int c) {
		static int cur = 1;
		cur = ch[cur][c];
		
		for(int x = cur; x; x = fa[top[x]]) {
			int curX = x;
			while(1) {
				int y;
				Node res = sgt.query(1, dfn[top[x]], dfn[x], 1, n);
				if(res.pos == 0) y = top[x]; //只有一段颜色相同的，直接改到链顶
				else y = ind[res.pos + 1];
				
				if(res.rc) con.update(len[fa[y]] + 1, len[x], res.rc, -1);
				con.update(len[fa[y]] + 1, len[x], p, 1);
				//上面两行都是更新贡献
				
				if(y == top[x]) break;
				else x = fa[y];
			}
			
			sgt.update(1, dfn[top[curX]], dfn[curX], 1, n, p);
			//染色
		}
	}
}

int main () {
	
	ios :: sync_with_stdio(0);
	cin >> s + 1;
	n = strlen(s + 1);
	cin >> m;
	for(int i = 1; i <= m; ++ i) {
		int l, r; cin >> l >> r;
		q[i] = (Query){i, l, r};
	}
	
	SAM :: build(s);
	sort(q + 1, q + m + 1);
	
	for(int r = 1, p = 1; r <= n; ++ r) {
		SAM :: update(r, s[r] - 'a');
		for(; p <= m && q[p].r == r; p ++ ) {
			int id = q[p].id, l = q[p].l;
			ans[id] = con.query(l);
		}
	}
	
	for(int i = 1; i <= m; ++ i)
		printf("%lld\n", ans[i]);
	
	return 0;
}
```

---

## 作者：_SeeleVollerei_ (赞：8)

不会 LCT。

子串问题先把 SAM 建出来。

一种很显然的想法是离线下来扫描线，将 $r$ 往右扫，维护每个 $l$ 当前的答案。同时需要维护每个子串最后出现的位置，也就是目前最大的 endpos。

把子串对应到后缀树的结点上。$r$ 往右移相当于在树上加入一个它对应的结点，并把所有的祖先的 endpos 都更新。但是算贡献我们需要先把祖先的贡献减掉，然后把它们的 endpos 更新以后再重新加上。

到根的路径图方便考虑直接树剖。然后考虑怎么算贡献。 

事实上如果我们把每个 endpos 看成一种颜色，每次相当于把当前点到根路径上所有点染成同一种新的颜色，就会形成一个颜色段。

对于每条重链，我们维护其形成的所有颜色段，每次更新的时候，我们暴力把所有经过的颜色段逐个贡献删掉即可，复杂度只和颜色段个数有关。

问题转化为对于某条链上当前 endpos 一样的一段点，算他们对 $l$ 的贡献。但是由于 $minlen_{u}=maxlen_{fa_{u}}+1$，所以显然一条链的贡献是一个大的区间，这样我们每一段的更新都是一个区间加，然后查询是区间求和。

由于每个 $r$ 只会贡献 $O(\log n)$ 个颜色段，所以删除和添加颜色段的复杂度均摊是 $O(\log n)$ 的，每次更新区间加要一个 $\log$，查询要一个 $\log$，所以复杂度为 $O(n\log^2n+m\log n)$。



---

## 作者：RPChe_ (赞：8)

**这是一个使用后缀数组来替代后缀自动机的做法。**

以前我也曾认为区间本质不同子串个数这类问题，SA 是完全无法解决的；直到某次做题时偶然受到 SAM 的 parent tree 启发，才发现了这种非常强的做法。

考虑这样一个问题：我们定义 ${\rm beginpos}(t)$ 表示字符串 $s$ 的子串 $t$ 在 $s$ 中的所有起始位置所构成的集合。显然，所有这样的 $t$ 都可以根据 ${\rm beginpos}(t)$ 而被划分为若干个等价类；我们的目标则是对于每一个这样的等价类，求出其所包含的本质不同的 $t$ 的数量。

你一定可以发现：这就是 SAM 中反串的 ${\rm endpos}$ 集合。但现在我们不妨站在 SA 的角度来思考问题：我们知道如上定义的本质不同的等价类的数量是 $O(n)$ 的，那么我们能否使用 SA 来求解呢？

我们知道每一个等价类在 sa 数组上都会对应一个区间，直观的想法是枚举每个左端点，再计算 $|t|=1$ 时的右端点。然后我们确定这个区间所允许的最长的 $t$ ，再直接计算允许更大的 $|t|$ 的右端点，直到这样的区间不存在为止，时间复杂度 $O(n\log n)$ 。这是一个笨拙的方法，也不具有可扩展性，但其暗示我们考虑按最小值来划分区间的过程，所以我们不妨对 height 数组建立笛卡尔树，并将原串的后缀作为其叶子节点。

观察这棵笛卡尔树，我们可以发现其具备很多优美的性质：每个等价类都在其上对应了一棵子树，也对应了 sa 数组的一段区间；其先序遍历的结果就是后缀数组；任意两个叶子节点的 lca 就是它们的 lcp …… 可以发现，它几乎就是一棵后缀树！

现在，我们终于可以借助这棵笛卡尔树，把 SA 与线段树合并或是 LCT 等数据结构结合起来，这棵树完全可以发挥与 SAM 的 parent tree 相同的效力，而且代码实现也并不复杂。另外值得一提的是，我们甚至可以在这棵树上实现在线的匹配。

这样一来，剩下的过程就与其它的题解无异了。模仿区间数颜色的做法，我们首先将离线询问，再从右往左扫描线。每插入一个新的后缀，其在笛卡尔树上涉及的仅是一条由叶子到根的链，且操作过程形似 LCT 的 access 操作，所以可以使用 LCT 优化。我们只需再维护区间加法和区间求和即可，我的实现是 $O(n\log ^2 n)$ 的，如下：

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define endl putchar('\n')
const int N=200005;
#define int long long
using namespace std;

int n,Q,sa[N],rk[N],h[N],root,val[N],pre[N],ans[N];
char s[N];
struct ques {
	int l,r,id;
	bool operator < (const ques &t) const { return l<t.l; }
} q[N];

struct suffix_array {
	int k1[N],k2[N],cnt[N],mx,num;
	void radix_sort() {
		rep(i,1,mx) cnt[i]=0;
		rep(i,1,n) cnt[k1[i]]++;
		rep(i,1,mx) cnt[i]+=cnt[i-1];
		for(int i=n;i>=1;i--) sa[cnt[k1[k2[i]]]--]=k2[i];
	}
	void sort() {
		rep(i,1,n) k1[i]=s[i],k2[i]=i; mx='z';
		radix_sort();
		for(int j=1;j<=n;j<<=1,num=0) {
			rep(i,n-j+1,n) k2[++num]=i;
			rep(i,1,n) if(sa[i]-j>=1) k2[++num]=sa[i]-j;
			radix_sort(),swap(k2,k1);
			num=k1[sa[1]]=1;
			rep(i,2,n) k1[sa[i]]=k2[sa[i]]==k2[sa[i-1]]&&k2[sa[i]+j]==k2[sa[i-1]+j]?num:++num;
			if(num==n) break;
			mx=num;
		}
	}
	void height() {
		rep(i,1,n) rk[sa[i]]=i;
		int k=0;
		rep(i,1,n) {
			if(rk[i]==1) continue;
			if(k) k--;
			int j=sa[rk[i]-1];
			while(max(i,j)+k<=n&&s[i+k]==s[j+k]) k++;
			h[rk[i]]=k;
		}
	}
} SA;

struct SMT {
	int sm[N<<1],ad[N<<1];
	#define ls (k<<1)
	#define rs (k<<1|1)
	#define mid ((l+r)>>1)
	void add(int k,int l,int r,int v) { sm[k]+=(r-l+1)*v,ad[k]+=v; }
	void pushdown(int k,int l,int r) {
		if(ad[k]) add(ls,l,mid,ad[k]),add(rs,mid+1,r,ad[k]),ad[k]=0;
	}
	void pushup(int k) { sm[k]=sm[ls]+sm[rs]; }
	void add(int k,int l,int r,int x,int y,int v) {
		if(x<=l&&r<=y) return add(k,l,r,v);
		pushdown(k,l,r);
		if(x<=mid) add(ls,l,mid,x,y,v);
		if(y>mid) add(rs,mid+1,r,x,y,v);
		pushup(k);
	}
	int query(int k,int l,int r,int x,int y) {
		if(x<=l&&r<=y) return sm[k];
		pushdown(k,l,r);
		int res=0;
		if(x<=mid) res+=query(ls,l,mid,x,y);
		if(y>mid) res+=query(rs,mid+1,r,x,y);
		return res;
	}
	#undef ls
	#undef rs
	#undef mid
} smt;

struct LCT {
	struct node {
		int sm,top,bel,fa,ch[2];
		#define ls(x) nod[x].ch[0]
		#define rs(x) nod[x].ch[1]
		#define fa(x) nod[x].fa
		#define sm(x) nod[x].sm
		#define top(x) nod[x].top
		#define bel(x) nod[x].bel
	} nod[N];
	bool cmp(int x) { return x==rs(fa(x)); }
	bool isroot(int x) { return nod[fa(x)].ch[cmp(x)]!=x; }
	void pushdown(int x) { bel(ls(x))=bel(rs(x))=bel(x); }
	void pushup(int x) {
		sm(x)=sm(ls(x))+val[x]+sm(rs(x));
		top(x)=ls(x)?top(ls(x)):pre[x];
	}
	void connect(int x,int fa,int son) { nod[fa].ch[son]=x,fa(x)=fa; }
	void rotate(int x) {
		int y=fa(x),z=fa(y),ys=cmp(x),zs=cmp(y);
		if(isroot(y)) fa(x)=z; else connect(x,z,zs);
		connect(nod[x].ch[ys^1],y,ys),connect(y,x,ys^1),pushup(y),pushup(x);
	}
	void pushall(int x) { if(!isroot(x)) pushall(fa(x)); pushdown(x); }
	void splay(int x) {
		pushall(x);
		while(!isroot(x)) {
			if(!isroot(fa(x))) rotate(cmp(x)^cmp(fa(x))?x:fa(x));
			rotate(x);
		}
	}
	void access(int x) {
		int pos=x; x=rk[x]+n;
		for(int y=0;x;y=x,x=fa(x)) {
			splay(x),rs(x)=0,pushup(x);
			int l=top(x),r=top(x)+sm(x)-1;
			if(l<=r&&bel(x)) smt.add(1,1,n,bel(x)+l,bel(x)+r,-1);
			bel(x)=pos;
			if(l<=r) smt.add(1,1,n,bel(x)+l,bel(x)+r,1);
			rs(x)=y,pushup(x);
		}
	}
} lct;

struct treap {
	int ls[N],rs[N],s[N],top,fa[N];
	void build() {
		if(n==1) return root=2,void();
		ls[2]=n+1,rs[2]=n+2,fa[ls[2]]=fa[rs[2]]=root=s[++top]=2;
		rep(i,3,n) {
			while(top&&h[s[top]]>h[i]) top--;
			if(top) ls[i]=rs[s[top]],fa[rs[s[top]]]=i,rs[s[top]]=i,fa[i]=s[top];
			else ls[i]=root,fa[root]=i,root=i;
			rs[i]=n+i,fa[rs[i]]=i,s[++top]=i;
		}
		rep(i,2,n+n) val[i]=(i>n?n-sa[i-n]+1:h[i])-h[fa[i]];
	}
	void prep(int x) {
		lct.sm(x)=val[x],lct.top(x)=pre[x];
		if(x>n) return;
		pre[ls[x]]=pre[rs[x]]=pre[x]+val[x];
		lct.fa(ls[x])=lct.fa(rs[x])=x;
		prep(ls[x]),prep(rs[x]);
	}
} trp;

void init() {
	SA.sort(),SA.height();
	trp.build(),trp.prep(root);
}

void solve() {
	sort(q+1,q+Q+1);
	int j=Q;
	for(int i=n;i>=1;i--) {
		lct.access(i);
		while(j>=1&&q[j].l==i) {
			ans[q[j].id]=smt.query(1,1,n,q[j].l,q[j].r);
			j--;
		}
	}
}

signed main() {
	scanf("%s",s+1),n=strlen(s+1);
	init();
	scanf("%lld",&Q);
	rep(i,1,Q) scanf("%lld%lld",&q[i].l,&q[i].r),q[i].id=i;
	solve();
	rep(i,1,Q) printf("%lld\n",ans[i]);
	return 0;
}

```


---

## 作者：yszs (赞：6)

### **颜色段怎么能没有珂朵莉？这是一篇在后缀树组上树剖套珂朵莉的题解。**

由于鄙人不会 $\text{SAM}$ 后缀树都是用后缀数组建的。

想想本质不同子串的做法是什么。

有两种做法，第一种容斥，第二种就是树的大小。

考虑第二种。

先对于字符串建出后缀树！

这种形式的询问肯定考虑离线扫描线啊！

那么从左往右扫还是从右往左扫捏？

是从右往左扫哒。

感性思考一下就是左到右加入的是一个字符，右到左加入的是一整个后缀。

现在左端点固定，我们要得到任意右端点的答案。$($ 扫描线的思考方式 $)$

我们考虑新加入一个后缀，它可能造成的贡献范围就是这个后缀开始的叶子到根的路径，如果右端点是 $n$ 的话，这条路径的所有点都会造成贡献，可以看成这条路径被它染了个色，如果右端点是 $n-1$ 的话，这条路径除了叶子的其他点都被它染色了。

那一次询问的答案就是所有被染色点的个数和。

但是一个点可能会被染成多种颜色，但是可以发现它被染的最后一种颜色的优先度大于其他颜色，那这个怎么证明呢，就是考虑右端点左移，就相当于一个从叶子到根褪色的过程，而从右往左扫每次加入的一个后缀的深度是比之前的所有后缀要深的，所以它染得点一定是相较别的颜色褪色最晚的。

然后一种颜色做的贡献实际上是一个一次函数，这个可以用树状数组维护一个常数项和一次项来做，具体来说就是一个长度为 $len$ 的颜色，当右端点距离 $n$ 为 $k$ 时，贡献就是 $len-k$。 

那我们插入一个后缀我们就要把它从叶子到根的路径所有颜色都染成它的颜色，这个东西我们树剖，把它变成序列问题，一种颜色就会染 $\log n$ 条树链。每次染色就用珂朵莉推平顺便维护颜色长度，单次查询用树状数组。

复杂度 $O(n \log^2 n +m \log n)$。

[code](https://www.luogu.com.cn/paste/859m2an0)

---

## 作者：GavinZheng (赞：6)

又是一道SAM+LCT综合运用的题。

因为是区间查询，所以我们可以把询问离线下来，然后依次加入字符并考虑$r$端点为这个字符的所有询问。然后我们需要实现两个操作：

- 插入一个字符
- 查询最晚的起始位置$\geq l$的本质不同字串个数

考虑插入一个字符会对答案造成的影响：显然会把$x$经过$x$的所有祖先最后到$root$的这条路径上的节点的最晚起始位置进行更新。这样就出现了一个问题：虽然LCT能进行链加/链覆盖，但是区间查询却做不到。那就考虑再维护一个线段树，线段树第$i$位代表$startpos=i$的本质不同子串的个数。

当先加入一个节点的时候，我们需要再线段树上移除会被更改的节点原来的贡献并加入新的贡献。而一个很显然的性质就是当$SAM$上一条从儿子到祖先路径代表的所有子串的最后一个$endpos$是相同的时，那么他们的$startpos$就是一段连续的区间。而根据LCT的性质，一个点到根的路径上只有$\log$个`splay`，所以我们可以根据某个节点属于哪个`splay`将路径上节点分为$\log$个类，每个类进行一次修改都能转化成线段树的区间加操作，然后就做完了。复杂度$O(m\log^2n)$。

有个地方需要注意一下：
因为我们定义下的`LCT`是需要满足每个`splay`中的所有点的最大的`endpos`均相同，所以我们不能到处`access`，只有在修改的时候才能做一次`access`。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#include<queue>
#include<set>
#define vi vector<int>
#define pb push_back
#define mk make_pair
#define pii pair<int,int>
#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)
#define fi first
#define se second
#define int long long
typedef long long ll;
using namespace std;
const int maxn=2e5+10000;
int n,len[maxn];
struct segment_tree{
	ll val[maxn<<2],tag[maxn<<2];
	segment_tree(){memset(val,0,sizeof(val));memset(tag,0,sizeof(tag));}
	void push_down(int rt,int l,int r){
		if(tag[rt]){
			int mid=(l+r)>>1;
			tag[rt<<1]+=tag[rt],tag[rt<<1|1]+=tag[rt];
			val[rt<<1]+=tag[rt]*(mid-l+1);val[rt<<1|1]+=tag[rt]*(r-(mid+1)+1);
			tag[rt]=0;
		}
	}
	void push_up(int rt){
		val[rt]=val[rt<<1]+val[rt<<1|1];
	}
	void add(int l,int r,int rt,int tl,int tr,ll w){
		if(tl<=l&&r<=tr){
			tag[rt]+=w;val[rt]+=w*(r-l+1);return;
		}
		push_down(rt,l,r);
		int mid=(l+r)>>1;
		if(tl<=mid)add(l,mid,rt<<1,tl,tr,w);
		if(tr>=mid+1)add(mid+1,r,rt<<1|1,tl,tr,w);
		push_up(rt);
	}
	ll query(int l,int r,int rt,int tl,int tr){
		if(tl<=l&&r<=tr){return val[rt];}
		push_down(rt,l,r);
		int mid=(l+r)>>1;ll ans=0;
		if(tl<=mid)ans+=query(l,mid,rt<<1,tl,tr);
		if(tr>=mid+1)ans+=query(mid+1,r,rt<<1|1,tl,tr);
		return ans;
	}
}t;
struct LCT{
	int ch[maxn][2],f[maxn],tag[maxn],endpos[maxn],stk[maxn];
	bool isrt(int rt){return (ch[f[rt]][0]!=rt)&&(ch[f[rt]][1]!=rt);}
	void rotate(int rt){
		int x=rt,y=f[x],z=f[y],o=ch[y][1]==x,w=ch[x][o^1];
		bool flag=isrt(y);
		ch[y][o]=w;
		f[w]=y;
		ch[x][o^1]=y;
		f[y]=x;
		if(!flag)ch[z][ch[z][1]==y]=x;
		f[x]=z;
	}
	void push_down(int rt){
		if(tag[rt]){
			tag[ch[rt][0]]=tag[ch[rt][1]]=tag[rt];
			endpos[ch[rt][0]]=endpos[ch[rt][1]]=tag[rt];
			tag[rt]=0;
		}
	}
	void splay(int rt){
		int top=0,x=rt;
		for(int y=rt;;y=f[y]){
			stk[++top]=y;if(isrt(y))break;
		}
		while(top)push_down(stk[top--]);
		for(;!isrt(x);rotate(x)){
			int y=f[x];if(isrt(y))continue;
			rotate((ch[f[x]][1]==x)==(ch[f[y]][1]==y)?y:x);
		}
	}
	void chain_update(int x1,int x2,int edpos,bool dodel,int ck){
		if(dodel){
			for(int y=0,x=(ck)?ck:x2;x;y=x,x=f[x]){
				
				splay(x);ch[x][1]=y;int st_l=len[f[x]]+1,ed_l=len[x];
				if(ed_l)t.add(1,n,1,endpos[x]-ed_l+1,endpos[x]-st_l+1,-1);
			}
		}
		for(int y=0,x=x1;x;y=x,x=f[x]){
			splay(x);ch[x][1]=y;int st_l=len[f[x]]+1,ed_l=len[x];
			if(ed_l)t.add(1,n,1,edpos-ed_l+1,edpos-st_l+1,1);
		}
	}
	void add(int x,int val){
		endpos[x]=val,tag[x]=val;
	}
	void link(int x,int fa,int edpos,int ty,int ck=0){
		splay(x);f[x]=fa;
		if(ty)
		chain_update(x,fa,edpos,edpos!=1,ck);
		if(ty){splay(x);add(x,edpos);}
	}
	void cut(int x,int st_l,int ed_l){
		splay(x);
		if(ed_l){t.add(1,n,1,endpos[x]-ed_l+1,endpos[x]-st_l+1,-1);}
		f[ch[x][0]]=f[x],ch[x][0]=0;
	}
}lct;
struct SAM{
	int link[maxn],ch[maxn][27],cnt,last;
	SAM(){cnt=last=1;}
	void insert(int c,int edpos){
		int p=last,cur=++cnt;len[cur]=len[p]+1;
		while(p&&!ch[p][c])ch[p][c]=cur,p=link[p];
		if(!p)link[cur]=1,lct.link(cur,1,edpos,1);
		else{
			int q=ch[p][c];
			if(len[p]+1==len[q])link[cur]=q,lct.link(cur,q,edpos,1);
			else{
				int cl=++cnt;len[cl]=len[p]+1;lct.splay(q);lct.endpos[cl]=lct.endpos[q];
				memcpy(ch[cl],ch[q],sizeof(ch[cl]));
				lct.cut(q,len[link[q]]+1,len[cl]);
				link[cl]=link[q];lct.link(cl,link[q],edpos,0);
				lct.link(cur,cl,edpos,1,link[cl]);
				lct.link(q,cl,edpos,0);
				link[cur]=link[q]=cl;
				while(p&&ch[p][c]==q)ch[p][c]=cl,p=link[p];
			}
		}
		last=cur;
	}
}sam;
char s[maxn];
struct QAQ{
	int l,r,id;
}query[maxn];
bool cmp(QAQ a,QAQ b){return a.r<b.r;}
ll out[maxn];
signed main(){
	scanf("%s",s+1);n=strlen(s+1);
	int q;scanf("%lld",&q);
	rep(i,1,q){
		scanf("%lld%lld",&query[i].l,&query[i].r);query[i].id=i;
	}
	sort(query+1,query+1+q,cmp);
	int top=0;
	rep(i,1,q){
		while(top<query[i].r)sam.insert(s[top+1]-'a',top+1),top++;
		ll ans=t.query(1,n,1,query[i].l,query[i].r);
		out[query[i].id]=ans;
	}
	rep(i,1,q)printf("%lld\n",out[i]);
	return 0;
}
```

---

## 作者：Warriors_Cat (赞：5)

[题面传送门](https://www.luogu.com.cn/problem/P6292)。

> 题意：给一个字符串 $s$，多次询问其区间本质不同子串个数，非强制在线。

在我的认知中算是一道神仙题了吧 orz

---

### $Solution:$

先考虑一个小问题：静态区间数颜色。

对于这题，一个常见做法是把询问离线，按照右端点排序。定义一个指针 $i$，从左到右扫描，每次给当前点 +1，上一次出现该颜色的点 -1，然后若有 $r = i$ 则直接区间查询即可。这个东西可以用线段树维护。

将这个套路转移到这题上：定义一个指针 $i$，从左到右扫描，定于每个状态定义其上一个状态 $lst$ 为 $s[1, i]$ 最后出现的位置。那么在 SAM 的 parent tree 上起所有的祖先节点都要变为 $lst$。

于是，我们可以这么做：每次更新节点先取消其根到此点的贡献，然后再更新新贡献即可。

发现这个操作和 LCT 的 access 操作差不多，于是直接用 LCT 维护即可。

重新捋一下思路：

1.建立 SAM 并存储每个节点的位置。

2.将询问离线，按照右端点排序。每次枚举到一个新的右端点就取消旧贡献并增加新贡献，用 LCT 的 access 操作和线段树维护。

3.对于所有 $r = i$，线段树区间查询答案即可。

over，时间复杂度为 $O(n\log^2 n + q\log n)$，其中 $\log^2$ 是 LCT 套线段树的复杂度。

---

### $Code:$

看着较长，但大部分都是板子，可以说挺好写。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define int long long
#define ull unsigned long long
#define fi first
#define se second
#define lc ch[x][0]
#define rc ch[x][1]
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = x; i >= y; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
#define repv(i, u) for(int i = 0; i < g[u].size(); ++i)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 200010, M = 26;
int n, m, x, y, z, pos[N], ans[N]; char s[N];
namespace SAM{
	int len[N], fail[N], nxt[N][M], tail = 1, tot = 1;
	inline void SAMadd(int c){
		len[++tot] = len[tail] + 1; int p = tail; tail = tot;
		for(; p && !nxt[p][c]; p = fail[p]) nxt[p][c] = tail;
		if(!p){ fail[tail] = 1; return; } int q = nxt[p][c];
		if(len[q] == len[p] + 1){ fail[tail] = q; return; }
		len[++tot] = len[p] + 1; fail[tot] = fail[q];
		rep(i, 0, 25) nxt[tot][i] = nxt[q][i];
		for(; p && nxt[p][c] == q; p = fail[p]) nxt[p][c] = tot;
		fail[tail] = fail[q] = tot;
	}
}
namespace SMT{
	int d[N << 2], f[N << 2];
	inline void pushup(int p){ d[p] = d[p << 1] + d[p << 1 | 1]; }
	inline void upd(int p, int l, int r, int x){ d[p] += (r - l + 1) * x; f[p] += x; }
	inline void pushdown(int p, int l, int r){
		if(f[p]){
			dingyi;
			upd(ls, l, mid, f[p]);
			upd(rs, mid + 1, r, f[p]);
			f[p] = 0;
		}
	}
	inline void change(int p, int l, int r, int x, int y, int z){
		if(x <= l && r <= y){ upd(p, l, r, z); return; }
		dingyi; pushdown(p, l, r);
		if(x <= mid) change(ls, l, mid, x, y, z);
		if(y > mid) change(rs, mid + 1, r, x, y, z);
		pushup(p);
	}
	inline int query(int p, int l, int r, int x, int y){
		if(x <= l && r <= y) return d[p];
		dingyi; pushdown(p, l, r); int ans = 0;
		if(x <= mid) ans += query(ls, l, mid, x, y);
		if(y > mid) ans += query(rs, mid + 1, r, x, y);
		return ans; 
	}
}
namespace LCT{
	int f[N], val[N], ch[N][2], tag[N], st[N];
	inline bool nroot(int x){ return ch[f[x]][0] == x || ch[f[x]][1] == x; }
	inline void pushtag(int x, int y){ val[x] = tag[x] = y; }
	inline void pushdown(int x){ if(!tag[x]) return; if(lc) pushtag(lc, tag[x]); if(rc) pushtag(rc, tag[x]); tag[x] = 0; }
	inline void Rotate(int x){
		int y = f[x], z = f[y], k = ch[y][1] == x, w = ch[x][!k]; if(nroot(y)) ch[z][ch[z][1] == y] = x;
		ch[x][!k] = y; ch[y][k] = w; if(w) f[w] = y; f[y] = x; f[x] = z;
	}
	inline void Splay(int x){
		int y = x, z = 0; st[++z] = y; while(nroot(y)) st[++z] = y = f[y];
		while(z) pushdown(st[z--]);
		while(nroot(x)){ y = f[x]; z = f[y]; if(nroot(y)) Rotate((ch[y][0] == x) ^ (ch[z][0] == y) ? x : y); Rotate(x); }
	}
	inline void access(int x, int z){
		int y; for(y = 0; x; x = f[y = x]){
			Splay(x), rc = y;
			if(val[x]) SMT::change(1, 1, n, val[x] - SAM::len[x] + 1, val[x] - SAM::len[f[x]], -1);
		}
		pushtag(y, z); SMT::change(1, 1, n, 1, z, 1);
	}
}
struct ask{
	int l, r, idx;
	bool operator < (const ask&rhs)const{
		return r < rhs.r;
	}
}q[N << 1];
inline void mian(){
	scanf("%s", s + 1); n = strlen(s + 1); m = read();
	rep(i, 1, n) SAM::SAMadd(s[i] - 'a'), pos[i] = SAM::tail;
	rep(i, 2, SAM::tot) LCT::f[i] = SAM::fail[i];
	rep(i, 1, m) q[i].l = read(), q[i].r = read(), q[i].idx = i;
	sort(q + 1, q + m + 1); int p = 1;
	rep(i, 1, m){
		x = q[i].l; y = q[i].r; int idx = q[i].idx;
		while(p <= y) LCT::access(pos[p], p), ++p;
		ans[idx] = SMT::query(1, 1, n, x, y);
	}
	rep(i, 1, m) printf("%lld\n", ans[i]);
}
signed main(){ int qwq = 1; while(qwq--) mian(); return 0; }
```


---

## 作者：A1443356159 (赞：4)

# 区间本质不同子串个数

考虑离线，不断扩展右端点，加上 $r$ 的贡献，减去重复子串贡献，用线段树维护不同左端点的答案。

构建 SAM，对于字符串 $S$ 中的一个字符 $ch_x$，$pos_x$ 表示 $x$ 在 SAM 上代表的点。

根据 SAM ，加入 $ch_r$ 时需要减去贡献的子串对应在 SAM 上是 $pos_r$ 的祖先。

考虑暴力，每次扩展右端点 $r$ ，$[1,r]$ 进行区间加1操作，表示以 $ch_r$ 为结尾的子串对答案的贡献。然后暴力跳 $pos_r$ 的祖先 $u$ ，若 $u$ 最后被 $lst$ 打上了标记，则以 $lst$ 为结尾的长度为 $[minlen_u,maxlen_u]$ 的的子串都是被重复计算的了，要减去，所以对 $[lst-maxlen_u,lst-minlen_u]$ 进行区间减1操作。最后再给所有祖先打上一个标记。

这样复杂度显然是不对的。

我们发现这个操作很像 LCT 的 access 操作，考虑用 LCT 优化。

在此之前，先说一个十分显然的性质：在任意时刻，以某个右端点的对答案产生贡献的子串的最端点一定是以1开始的一段连续区间（或者没贡献），原因就是大的串重复了，小的肯定也会重复。

我们用 LCT 维护 SAM 的 parent 树，扩展 $r$ 时，对 $pos_r$ 进行 access 操作，这样被同一右端点打过标记的点就会在同一条重链上。

根据之前那个性质，对于每个**之前的**的右端点，每次需要被减掉贡献的子串的左端点一定是一个**后缀**（也可以考虑一下parent 树的特征，$maxlen$ 随深度递增，对于每个右端点的标记，深度大的被覆盖了，深度小的也一定被覆盖），形象地

![](https://cdn.luogu.com.cn/upload/image_hosting/nzdicj4u.png)

我们新加入右端点 $r$ ，对 $r'$ ，会有以黄色段为最左端点的子串的贡献需要被减去，所以我们只需要知道 $r'$ 粉色段的长度和蓝色段的长度。

对于一条重链，我们维护一下它最后一次被哪个点打上了标记（也就是 $r'$），粉色段的长度和蓝色段的长度则没必要刻意维护。其实，在 access 过程中，每次通过虚边向上跳到的那个点的 $maxlen$ 就是粉色段的长度，而蓝色段的长度则是这条重链中深度最小的点的在 parent 树上的父亲（由于没有 makeroot 操作，树的形态不会改变，LCT 上的父亲其实也是原树上的父亲） $maxlen$。

复杂度 $\mathcal{O}(n\log^2n)$

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define int long long
int read() {
	int x=0,f=1;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=3e5+5;
int n,m,pos[N];
char ch[N];
namespace SAM {
	struct PT {
		int ch[26],len,fa;
	}a[N];
	int tot=1,lat=1;
	void insert(int c) {
		int np=++tot,p=lat;lat=np;
		a[np].len=a[p].len+1;
		for(;p&&!a[p].ch[c];p=a[p].fa)a[p].ch[c]=np;
		if(!p)a[np].fa=1;
		else {
			int q=a[p].ch[c];
			if(a[q].len==a[p].len+1)a[np].fa=q;
			else {
				int nq=++tot;a[nq]=a[q];
				a[nq].len=a[p].len+1;
				a[q].fa=a[np].fa=nq;
				for(;p&&a[p].ch[c]==q;p=a[p].fa)a[p].ch[c]=nq;
			}
		}
	}
	void build() {
		for(int i=1;i<=n;++i) {
			insert(ch[i]-'a');
			pos[i]=lat;
		}
	}
}
namespace SGT {
	#define ls (i<<1)
	#define rs (i<<1|1)
	#define mid ((l+r)>>1)
	int sum[N<<2],tag[N<<2],len[N<<2];
	void change(int i,int k) {sum[i]+=k*len[i];tag[i]+=k;}
	void pushup(int i) {sum[i]=sum[ls]+sum[rs];}
	void pushdown(int i) {
		if(tag[i]) {
			change(ls,tag[i]);
			change(rs,tag[i]);
			tag[i]=0;
		}
	}
	void updata(int i,int l,int r,int x,int y,int k) {
		if(x<=l&&r<=y) {
			change(i,k);
			return;
		}
		pushdown(i);
		if(x<=mid)updata(ls,l,mid,x,y,k);
		if(y>mid)updata(rs,mid+1,r,x,y,k);
		pushup(i);
	}
	int qry(int i,int l,int r,int x,int y) {
		if(x<=l&&r<=y)return sum[i];
		int res=0;
		pushdown(i);
		if(x<=mid)res+=qry(ls,l,mid,x,y);
		if(y>mid)res+=qry(rs,mid+1,r,x,y);
		return res;
	}
	void build(int i,int l,int r) {
		len[i]=r-l+1;
		if(l^r) {
			build(ls,l,mid);
			build(rs,mid+1,r);
		}
	}
}
namespace LCT {
	int ch[N][2],fa[N];
	void build() {for(int i=2;i<=SAM::tot;++i)fa[i]=SAM::a[i].fa;}
	bool notrt(int x) {return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}
	int val[N],tag[N];
	void change(int i,int k) {
		val[i]=k;
		tag[i]=k;
	}
	void pushdown(int i) {
		if(tag[i]) {
			if(ch[i][0])change(ch[i][0],tag[i]);
			if(ch[i][1])change(ch[i][1],tag[i]);
			tag[i]=0;
		}
	}
	void pushall(int x) {
		if(notrt(x))pushall(fa[x]);
		pushdown(x);
	}
	bool who(int f,int x) {return ch[f][1]==x;}
	void rotate(int x) {
		int y=fa[x],w,z=fa[y];
		bool k=who(y,x);
		w=ch[x][k^1];
		if(notrt(y))ch[z][who(z,y)]=x;
		ch[x][k^1]=y;
		ch[y][k]=w;
		if(w)fa[w]=y;
		fa[y]=x;
		fa[x]=z;
	}
	void splay(int x) {
		pushall(x);
		int y,z;
		while(notrt(x)) {
			int y=fa[x],z=fa[y];
			if(notrt(y))rotate(who(z,y)==who(y,x)?y:x);
			rotate(x);
		}
	}
	void access(int x,int ps) {
		int t=x,y;
		for(y=0;x;x=fa[y=x]) {
			splay(x);ch[x][1]=y;
			if(val[x])
				SGT::updata(1,1,n,val[x]-SAM::a[x].len+1,val[x]-SAM::a[fa[x]].len,-1);
		}
		splay(t);change(t,ps);
		SGT::updata(1,1,n,1,ps,1);
	}
}
struct Q {
	int l,r,i;
}q[N];
bool cmp(const Q &p,const Q &q) {
	return p.r<q.r;
}
int ans[N];
main() {
	scanf("%s",ch+1);
	n=strlen(ch+1);
	SAM::build();
	LCT::build();
	SGT::build(1,1,n);
	m=read();
	for(int i=1;i<=m;++i) {
		q[i].l=read();
		q[i].r=read();
		q[i].i=i;
	}
	sort(q+1,q+m+1,cmp);
	for(int R=1,i=1;R<=n;++R) {
		LCT::access(pos[R],R);
		while(q[i].r==R)ans[q[i].i]=SGT::qry(1,1,n,q[i].l,q[i].r),++i;
	}
	for(int i=1;i<=m;++i)printf("%lld\n",ans[i]);
	return 0;
}
```



---

## 作者：PragmaGCC (赞：2)

题意已经很清楚了。

我们首先考虑：怎样统计一段区间的颜色个数。我们可以将询问离线。对于每一个节点，我们将其 $+1$，同时将上一次出现的位置 $-1$。

然后对于所有的 $r = i$ 进行区间查询。

回到这道题目上来。区间不同子串个数，肯定要用后缀自动机。

对于 SAM 上的一个状态 $p$ 而言，我们定义 last 为在考虑到 $i$ 时，在 $[1,i]$ 中最后一次出现的位置。即 `lst[i]=SAM.last` 。

在后缀自动机中，以 $ch$ 结尾的子串就是其 parent 树上的所有祖先。我们每次更新也必定会让这些祖先全部变成 last。

那我们不妨直接取消掉这整条路径上的信息，再全部赋值。

我们要动态维护整棵树，也要维护链上的信息，可以使用 Link-Cut Tree。

区间修改区间查询操作可以线段树维护。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
#define mp make_pair
#define pb push_back
const int N = 2e5 + 5;
int n, m;
struct Suffix_Automaton {
    struct node {
        int ch[26];
        int len, fail;
    } tr[N<<1];
    int last = 1, tot = 1;
    void ins(int x) {
        int p = last, q, now = ++tot;
        tr[now].len = tr[p].len + 1;
        for (; p && !tr[p].ch[x]; p = tr[p].fail)
            tr[p].ch[x] = now;
        if (!p) { tr[now].fail = 1; }
        else {
            q = tr[p].ch[x];
            if (tr[q].len == tr[p].len + 1) tr[now].fail = q;
            else {
                int cl = ++tot;
                tr[cl] = tr[q];
                tr[cl].len = tr[p].len + 1;
                tr[q].fail = tr[now].fail = cl;
                for (; p && tr[p].ch[x] == q; p = tr[p].fail)
                    tr[p].ch[x] = cl; 
            }
        } 
        last = now;
    }
} SAM;
struct Segment_Tree {
    struct node {
        int l, r;
        ll sum, add;
        ll len() { return 1ll * (r - l + 1); }
    } t[N<<1];
    #define ls(k) k << 1
    #define rs(k) k << 1 | 1 
    void pushup(int k) { t[k].sum = t[ls(k)].sum + t[rs(k)].sum; }
    void build(int k, int l, int r) {
        t[k].l = l, t[k].r = r;
        if (l == r) return ;
        const int mid = l + r >> 1;
        build(ls(k), l, mid), build(rs(k), mid+1, r);
    }
    void change(int k, ll d) {
        t[k].sum += t[k].len() * d;
        t[k].add += d;
    }
    void pushdown(int k) {
        if (!t[k].add) return ;
        change(ls(k), t[k].add), change(rs(k), t[k].add);
        t[k].add = 0;
    }
    void update(int k, int ql, int qr, ll x) {
        int l = t[k].l, r = t[k].r, mid = l + r >> 1;
        if (l >= ql && r <= qr) return change(k, x);
        pushdown(k);
        if (ql <= mid) update(ls(k), ql, qr, x);
        if (qr > mid) update(rs(k), ql, qr, x);
        pushup(k);
    }
    ll query(int k, int ql, int qr) {
        int l = t[k].l, r = t[k].r, mid = l + r >> 1;
        if (l >= ql && r <= qr) return t[k].sum;
        pushdown(k);
        ll res = 0;
        if (ql <= mid) res += query(ls(k), ql, qr);
        if (qr > mid) res += query(rs(k), ql, qr);
        return res;
    }
} SGT;
struct Link_Cut_Tree {
    int val[N], ch[N][2], rev[N], siz[N], fa[N];
    void pushup(int k, int x) {
        val[k] = rev[k] = x;
    }
    void pushdown(int k) {
        if (!rev[k]) return ;
        if (ch[k][0]) pushup(ch[k][0], rev[k]);
        if (ch[k][1]) pushup(ch[k][1], rev[k]);
        rev[k] = 0;
    }
    bool isroot(int k) { return (ch[fa[k]][0] != k) && (ch[fa[k]][1] != k); }
    int get(int k) { return ch[fa[k]][1] == k; }
    void rotate(int x) {
        int y = fa[x], z = fa[y], k = get(x);
        if (!isroot(y))
            ch[z][ch[z][1] == y] = x;
        ch[y][k] = ch[x][!k], fa[ch[x][!k]] = y;
           ch[x][!k] = y, fa[y] = x, fa[x] = z;
//	    pushup(y), pushup(x);
    }
    void update(int p) {
        if (!isroot(p))
            update(fa[p]);
        pushdown(p);
    }
    void splay(int x) {
        update(x);
        for (int fat; fat = fa[x], !isroot(x); rotate(x)) {
            if (!isroot(fat))
                rotate(get(fat) == get(x) ? fat : x);
        }
    }
    void access(int x, int d) {
        int p = 0;
        for (; x; p = x, x = fa[x]) {
            splay(x), ch[x][1] = p;
            if (val[x]) {
                SGT.update(1, val[x] - SAM.tr[x].len + 1, val[x] - SAM.tr[fa[x]].len, -1);
            }
        }
        pushup(p, d);
        SGT.update(1, 1, d, 1); 
    }
} LCT;
int lst[N];
ll ans[N];
vector<pii> q[N];
char s[N];
int main(void) {
    scanf("%s", s + 1);
    n = strlen(s + 1);
    SGT.build(1, 1, n);
    for (int i=1; i<=n; i++) {
        SAM.ins(s[i] - 'a');
        lst[i] = SAM.last;
    }
    for (int i=2; i<=SAM.tot; i++) LCT.fa[i] = SAM.tr[i].fail;
    scanf("%d", &m);
    for (int i=1, l, r; i<=m; i++) {
        scanf("%d%d", &l, &r);
        q[r].pb(mp(l, i));
    }
    for (int i=1; i<=n; i++) {
        LCT.access(lst[i], i);
        for (auto j : q[i]){
            ans[j.second] = SGT.query(1, j.first, i); 
        }
    }
    for (int i=1; i<=m; i++) printf("%lld\n", ans[i]);
    return 0;
}
```



---

## 作者：Rorschachindark (赞：2)

# 区间本质不同子串个数
[题目传送门](https://www.luogu.com.cn/problem/P6292)
## 题目大意
给定一个母串$\text s$，有$q$次询问，每次查询$l,r$区间的本质不同子串个数。
## 解题思路
不得不说，这道题太妙了。

我们来考虑一下，我们如何解决这样一个问题：

>给定一个长度为$n$的序列，每次询问区间$[l,r]$之间的颜色个数。

我们对于这个问题可以采取这样一种方法：我们把询问离线下来，从左往右扫一遍，对于当前点，我们把该点权值+1，上次出现该颜色的点权值-1，然后对于所有$r=i$的询问计算区间权值之和即可。

对于这道题我们可以采用类似的思路。我们考虑，如果当前点拓展到$i$,如果我们对于一个状态定义$last$为在子串$s_{1,2,...,i}$最后出现的位置，那么，对于$S_{1,2,..,i}$在$\text {SAM}$上对应的状态以及它的$fail$祖先的$last$都会变成$last$。

于是，我们就可以自然而然的想到一种解法，每次把该点到根的点都先取消掉它们的贡献，然后把$last$都赋为当前拓展节点，即$i$，再增加起贡献。

我们发现，到根这个操作可以使用$\text {LCT}$中的$\text {Access}$操作解决，而我们只需要再实现区间更改以及区间查询即可，这个可以使用线段树/树状数组解决。

于是，我们最终可以用离线方法在$\Theta(n\log^2n+m\log n)$的时间复杂度解决，其中$n$是字符串的长度,$m$是查询次数。
## $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int,int>
#define Int register int
#define ll long long
#define MAXN 200005

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = t * 10 + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,m;

char s[MAXN]; 

struct SAM{
	int lst = 1,cur = 1;
	int ch[MAXN][26],len[MAXN],fail[MAXN];
	void Insert (int c){
		if (ch[lst][c] && len[ch[lst][c]] == len[lst] + 1) return lst = ch[lst][c],void ();
		int q = ++ cur,f = lst;len[q] = len[f] + 1,lst = q;
		while (f && !ch[f][c]) ch[f][c] = q,f = fail[f];
		if (f == 0) fail[q] = 1;
		else{
			int x = ch[f][c];
			if (len[x] == len[f] + 1) fail[q] = x;
			else{
				if (len[q] == len[f] + 1) lst = cur + 1;
				int p = ++ cur;fail[p] = fail[x],len[p] = len[f] + 1;
				memcpy (ch[p],ch[x],sizeof (ch[x])),fail[x] = fail[q] = p;
				while (f && ch[f][c] == x) ch[f][c] = p,f = fail[f];
			}
		}
	}
}Sam; 

struct Segment{
	ll sumv[MAXN << 1],tag[MAXN << 1];
	void Pushadd (int i,int l,int r,int x){
		sumv[i] += 1ll * (r - l + 1) * x;
		tag[i] += x;
	}
	void Pushdown (int i,int l,int r){
		int mid = (l + r) >> 1;
		if (tag[i]){
			Pushadd (i << 1,l,mid,tag[i]);
			Pushadd (i << 1 | 1,mid + 1,r,tag[i]);
			tag[i] = 0;
		}
	}
	void Pushup (int i){
		sumv[i] = sumv[i << 1] + sumv[i << 1 | 1];
	}
	void modify (int i,int l,int r,int tl,int tr,int x){
		if (l >= tl && r <= tr) return Pushadd (i,l,r,x);
		Pushdown (i,l,r);
		int mid = (l + r) >> 1;
		if (tl <= mid) modify (i << 1,l,mid,tl,tr,x);
		if (tr > mid) modify (i << 1 | 1,mid + 1,r,tl,tr,x);
		Pushup (i);
	}
	ll query (int i,int l,int r,int tl,int tr){
		if (l >= tl && r <= tr) return sumv[i];
		Pushdown (i,l,r);
		int mid = (l + r) >> 1;ll res = 0;
		if (tl <= mid) res += query (i << 1,l,mid,tl,tr);
		if (tr > mid) res += query (i << 1 | 1,mid + 1,r,tl,tr);
		return res;
	}
}Tree;

struct LCT{
#define ls son[x][0]
#define rs son[x][1]
	int fa[MAXN],val[MAXN],cov[MAXN],last[MAXN],son[MAXN][2];
	bool rnk (int x){
		return son[fa[x]][1] == x;
	}
	bool Isroot (int x){
		return son[fa[x]][0] != x && son[fa[x]][1] != x;
	}
	void Pushadd (int x,int k){
		val[x] = cov[x] = k;
	}
	void Pushdown (int x){
		if (cov[x]){
			if (ls) Pushadd (ls,cov[x]);
			if (rs) Pushadd (rs,cov[x]);
			cov[x] = 0;
		}
	}
	void rotate (int x){
		int y = fa[x],z = fa[y],k = rnk (x),w = son[x][!k];
		if (!Isroot (y)) son[z][rnk (y)] = x;son[x][!k] = y,son[y][k] = w;
		if (w) fa[w] = y;fa[x] = z,fa[y] = x;
	}
	void Pushall (int x){
		if (!Isroot (x)) Pushall (fa[x]);
		Pushdown (x);
	}
	void Splay (int x){
		Pushall (x);
		while (!Isroot (x)){
			int y = fa[x];
			if (!Isroot (y)) rotate (rnk (x) == rnk (y) ? y : x);
			rotate (x);
		}
	}
	void Access (int x,int k){
		int y;
		for (y = 0;x;x = fa[y = x]){
			Splay (x),rs = y;
			if (val[x]) Tree.modify (1,1,n,val[x] - Sam.len[x] + 1,val[x] - Sam.len[fa[x]],-1); 
		}
		Pushadd (y,k),Tree.modify (1,1,n,1,k,1); 
	}
#undef ls
#undef rs
}Lct;

int pos[MAXN];ll ans[MAXN];

vector <PII> que[MAXN];

signed main(){
	scanf ("%s",s + 1);
	n = strlen (s + 1);
	for (Int i = 1;i <= n;++ i) Sam.Insert (s[i] - 'a'),pos[i] = Sam.lst;
	for (Int i = 2;i <= Sam.cur;++ i) Lct.fa[i] = Sam.fail[i]; 
	read (m);
	for (Int i = 1;i <= m;++ i){
		int l,r;read (l,r);
		que[r].push_back (make_pair (i,l));
	}
	for (Int i = 1;i <= n;++ i){
		Lct.Access (pos[i],i);
		for (Int j = 0;j < que[i].size();++ j){
			PII Now = que[i][j];
			ans[Now.first] = Tree.query (1,1,n,Now.second,i); 
		}
	}
	for (Int i = 1;i <= m;++ i) write (ans[i]),putchar ('\n');
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：1)

**P6292**题解。

个人感觉总的来说，想清楚了还是比较 ez 的。

~~可惜你还是没想清楚第一遍做法就假了。~~

还调了好久。

--------------------------------------------------------

考虑先一波把 SAM 建好，根据 endpos 在 parent tree 上划分的原理，我们不难想到将每个点代表的子串贡献尽量摊到**在查询区间内的最后一个 endpos 上**。

不难想到扫描线，建立 SAM 的同时维护字符串的每个前缀 $i$ 所对应的 SAM 节点。显然，有且仅有该节点的所有祖先的 endpos 具有 $i$ 位置。

将这一段路径进行一个暴力操作：找到每个点之前的 lst 然后把之前的贡献扔了，加上现在的贡献，这里的贡献指的是**当前节点所代表的本质不同子串数量 $v$（即当前节点的 $len$ 减去了父亲的 $len$）对于区间 $[lst - v + 1 , lst]$ 进行的一个等差数列加，对 $[1,lst-1]$ 进行了一个区间加 $v$。**

发现这东西与 access 太像了，考虑直接拉一个 LCT 出来，一条实链就对应一段 lst 相同的节点，显然根据上述暴力操作的性质，parent tree 在任意时刻都是被分成很多条实链的。

但是我们发现，这样每次去除贡献还是只能暴力扔，因为上述的贡献不具有快速合并的性质，所以得稍微动动手脚。

我们发现 LCT 本质维护的就是 parent tree，而贡献虽然不能快速合并但是可以叠加，我们干脆就将每个节点的 $v$ 直接设为它们的 $len$，差分后一条实链的贡献就等价于用链底节点的贡献减去链头父亲节点的贡献，可以快速维护了。

然后等差数列加和单点查也很 ez，差分后等价于区间加区间查，上线段树即可。

总结一下：

- 扫描线。建立 SAM，维护 parent tree；

- 每次 access 前缀 $i$ 所对应的路径，对于每条实链维护链底节点本身（在实现时可以省去）与链头节点的父亲，即可快速回退/加入实链贡献；

- 离线后做区间加区间查线段树。

最后时间复杂度是 $O(n \log ^ 2 n + q \log n)$，去调线段树的叉数可以获得更快的理论时间复杂度。

```cpp
/*
区间本质不同逆序对。
哦打错了是区间本质不同子串（bushi 
我会暴力！可以暴力建出 [L,R] 的子串的形式然后暴力统计答案
回滚莫队？笑安逸了
可以考虑在构建 SAM 的时候其实维护的是 [1,R] 的情况，我们现在不过是想去除 [1,l - 1] 的情况
感觉还是对结构理解的不到位，不妨将 [R,R],[R - 1,R],......这些子串的 lst 都改一下
思考插入后缀字符的过程，显然当前节点到根都需要将最后出现的后缀的 lst 都变成 r
整理一下：一直向上爬，找到一个扔一个进去，如果需要拆分就拆出来然后把 lst 搞一下
好像做复杂了，根据 endpos 传递的原理我们只需要找到 fa 是谁然后连边，最后 access 一下这条路径把 lst 全赋值为 r 就行
每个点的点权其实在加入的时候就已经固定了，LCT 需要帮忙每次把 lst < l 的位置都给杀掉
诶呀我是 SB……这样 lct 的剖分就是颜色段剖分啊，可以直接维护。
我日哦怎么还有单点改点权……烦死了
感觉连边删边很烦，如果不在一个 Splay 里面就直接断开否则就得先 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e5 + 5;
int n,m;
struct Seg
{
	#define ls(p) p << 1
	#define rs(p) p << 1 | 1
	long long sum[Len << 2];int tag[Len << 2];
	void push_up(int p){sum[p] = sum[ls(p)] + sum[rs(p)];}
	void push_down(int p,int l,int r)
	{
		if(tag[p])
		{
			int mid = (l + r) >> 1;
			tag[ls(p)] += tag[p] , tag[rs(p)] += tag[p];
			sum[ls(p)] += 1ll * (mid - l + 1) * tag[p] , sum[rs(p)] += 1ll * (r - mid) * tag[p];
			tag[p] = 0;
		}
	}
	void upd(int p,int l,int r,int nl,int nr,int w)
	{
		if(nl <= l && nr >= r){sum[p] += 1ll * (r - l + 1) * w;tag[p] += w;return;}
		int mid = (l + r) >> 1;
		push_down(p , l , r);
		if(nl <= mid) upd(ls(p) , l , mid , nl , nr , w);
		if(nr > mid) upd(rs(p) , mid + 1 , r , nl , nr , w);
		push_up(p);
	}
	long long qry(int p,int l,int r,int nl,int nr)
	{
		if(nl <= l && nr >= r) return sum[p];
		push_down(p , l , r);
		int mid = (l + r) >> 1;long long res = 0;
		if(nl <= mid) res += qry(ls(p) , l , mid , nl , nr);
		if(nr > mid) res += qry(rs(p) , mid + 1 , r , nl , nr);
		return res;
	}
	#undef ls(p)
	#undef rs(p)
}T1;
struct node
{
	int ch[2],v,sum,lst,f,tag;
	node(){ch[0] = ch[1] = v = sum = lst = f = tag = 0;}
	node(int CH0,int CH1,int V,int SUM,int LST,int F,int TAG){ch[0] = CH0 , ch[1] = CH1 , v = V , sum = SUM , lst = LST , f = F , tag = TAG;}
};
struct Link_Cut_Tree
{
	node t[Len << 1];
	#define ls t[x].ch[0]
	#define rs t[x].ch[1]
	inline void push_up(int x)
	{
		if(!t[rs].sum) t[x].sum = t[x].v;
		else t[x].sum = t[rs].sum;
	}
	inline void push_down(int x)
	{
		if(t[x].tag)
		{
			if(ls) t[ls].tag = t[ls].lst = t[x].tag;
			if(rs) t[rs].tag = t[rs].lst = t[x].tag;
			t[x].tag = 0;
		}
	}
	inline int idf(int x)
	{
		if(!t[x].f) return -1;
		if(t[t[x].f].ch[0] == x) return 0;
		if(t[t[x].f].ch[1] == x) return 1;
		return -1;
	}
	inline void llcon(int son,int fa,int op)
	{
		if(op != -1) t[fa].ch[op] = son;
		t[son].f = fa;
	}
	inline void rotate(int x)
	{
		int y = t[x].f , z = t[y].f , opx = idf(x) , opy = idf(y) , u = t[x].ch[opx ^ 1];
		llcon(u , y , opx);
		llcon(y , x , opx ^ 1);
		llcon(x , z , opy);
		push_up(y) , push_up(x);
	}
	void push_all(int x)
	{
		if(idf(x) != -1) push_all(t[x].f);
		push_down(x);
	}
	inline void Splay(int x)
	{
		push_all(x);
		while(idf(x) != -1)
		{
			int ff = t[x].f;
			if(idf(ff) == -1) rotate(x);
			else
			{
				if(idf(ff) == idf(x)) rotate(ff) , rotate(x);
				else rotate(x) , rotate(x);
			}
		}
	}
	inline int finddel(int x){return t[t[x].f].v;}
	inline void access(int x,int R)//对之前的每条实链重新操作 
	{
		int lst = 0 , now = x;
		while(x)
		{
			Splay(x);
			t[x].ch[1] = 0;
			push_up(x);
			if(t[x].lst) 
			{
				int dl = finddel(x);	
				if(t[x].v) T1.upd(1 , 1 , n , t[x].lst - t[x].v + 1 , t[x].lst , -1);
				if(dl) T1.upd(1 , 1 , n , t[x].lst - dl + 1 , t[x].lst , 1);
			}
			t[x].ch[1] = lst;
			push_up(x);
			lst = x;
			x = t[x].f;
		}
		x = now;
		Splay(x);
		t[x].tag = t[x].lst = R;
		if(t[x].lst) T1.upd(1 , 1 , n , t[x].lst - t[x].v + 1 , t[x].lst , 1);
	}
	#undef ls
	#undef rs
}LCT;
struct Node
{
	int ch[28];
	int len,fa;
	Node(){memset(ch , 0 , sizeof ch);len = fa = 0;}
};
struct Auto
{
	Node t[Len << 1];
	int tot;
	Auto(){tot = 1;}
	inline int Add(int c,int lst)
	{
		int p = lst;
		int np = lst = ++ tot;
		t[np].len = t[p].len + 1;
		for(; p && !t[p].ch[c] ; p = t[p].fa) t[p].ch[c] = np;
		if(!p) t[np].fa = 1;
		else
		{
			int q = t[p].ch[c];
			if(t[q].len == t[p].len + 1) t[np].fa = q;
			else
			{
				int nq = ++ tot;t[nq] = t[q];
				t[nq].len = t[p].len + 1;
				t[np].fa = t[q].fa = nq;
				for(; p && t[p].ch[c] == q ; p = t[p].fa) t[p].ch[c] = nq;
			}
		}
		return np;
	}
	inline void Init(){for(int i = 2 ; i <= tot ; i ++) LCT.t[i].f = t[i].fa , LCT.t[i].v = t[i].len , LCT.push_up(i);}
}T2;
char s[Len];
int pos[Len];
long long Print[Len];
struct nnode
{
	int l,id;
	nnode(){l = id = 0;}
	nnode(int L,int ID){l = L , id = ID;}
};
vector<nnode> v[Len];
int main()
{
	scanf("%s",s + 1);
	n = strlen(s + 1);
	int lst = 1;
	for(int i = 1 ; i <= n ; i ++) 
	{	
		
		lst = T2.Add(s[i] - 'a' , lst);
		pos[i] = lst;
	}
	T2.Init();
	scanf("%d",&m);
	for(int i = 1 ; i <= m ; i ++)
	{
		int l,r;
		scanf("%d %d",&l,&r);
		v[r].push_back(nnode(l , i));
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		LCT.access(pos[i] , i);
		for(int j = 0 ; j < v[i].size() ; j ++) Print[v[i][j].id] = T1.qry(1 , 1 , n , v[i][j].l , i);
	}
	for(int i = 1 ; i <= m ; i ++) printf("%lld\n",Print[i]);
	return 0;	
} 
```

---

## 作者：Illusory_dimes (赞：0)

复盘 $\color{black}{{\rm P}}\color{red}{{\rm itiless0514}}$ 的 LCT ，找了一道好题做做。

[Plus 版](https://www.fzoi.top/problem/4449 "Plus 版") 这是 [sol](https://www.cnblogs.com/Illusory-dimes/p/16010779.html "sol")

## Description

给定长度为 $n$ 的模式串， $m$ 次询问，求区间本质不同子串个数。

$n \leq 10 ^ 5,\ \ m \leq 2 \cdot 10 ^ 5$

## Analysis

没有修改，静态的，好，这样 SAM 就能派上用场了。

但是求区间内的话，我们发现还想也只能重构，顶多能把被包含的区间排除，没啥用。

可能直接 SAM 是有点毛病的，所以想考虑点其他东西。

比如说求区间不同颜色数，静态的，有这么一种解法：

- 首先离线。

- 类似一个扫描线的想法，定好右端点，从左往右扫，用一个线段树或者树状数组记录，每次加入一个颜色 $col_r$ 后，这个点的权值定位 $1$ ，取消这个颜色上一个出现的地方的权值。

- 这样的话有查询右边界是 $r$ 就可以找区间权值和，因为这样相同颜色只会算一次，所以没有问题。

## Solution

那其实这道题也能有类似的想法，但是每次新加进来一个字符可能会多很多种子串，咋办捏？？

还是回归到 SAM 上，加入一个新字符之后会有一些字串对应的状态的 $endpos$ 会多一个位置，并且这一定是在一条链上（还是顶到了根的那种）的状态，因为一些小性质（具体是什么不细讲了）。

然后发现越想越像[树点染色](https://www.luogu.com.cn/problem/P3703 "树点染色")，并且也能联想到 LCT 的 $access$ 操作。

那如果我们用上 LCT ，在 $access$ 的时候更新一下新出现的字符串就行了吧。

那那怎么更新呢？？

既然我们是选择了数据结构算区间和，又封死了右边界，所以我们就要在区间和上体现出来初始位置，于是就把在 $j$ 出现的字符串的贡献标记到 $j - len + 1$ 上。

更新的话我们就要取消在上次出现位置标记的地方的贡献，然后转到新地方再标记，这样的话因为区间的特殊性不管怎么样查询都不会算漏。

因为这些如果要出现就全部是连续出现，所以可以区间修改。因为我们已经把 SAM 搬到 LCT 上面了，所以我们在 $access$ 的时候对于一个状态取消上次的贡献，最后全局加就行了。

线段树和树状数组都可以捏。

## Code

```cpp
/*

*/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4e5 + 10, M = 2e6 + 10;
int n, pos[N]; ll ans[N];
struct mdzz {
	int l, r, id;
	bool operator < (const mdzz &it) const {
		return r < it.r;
	}
} a[N];
inline int read() {
	char ch = getchar();
	int s = 0, w = 1;
	while (!isdigit(ch)) {if (ch == '-') w = -1; ch = getchar();}
	while (isdigit(ch)) {s = (s << 3) + (s << 1) + (ch ^ 48); ch = getchar();}
	return s * w;
}
struct SAM {
	int n, cnt, las, len[N], link[N], ch[N][26];
	char s[N]; int tong[N], rk[N];
	inline void init() {cnt = las = 1; memset(ch[1], 0, sizeof(ch[1]));}
	inline void SAM_stru(int c) {
		int cur = ++cnt, p = las;
		memset(ch[cur], 0, sizeof(ch[cur]));
		las = cur;
		len[cur] = len[p] + 1;
		while (p && !ch[p][c]) ch[p][c] = cur, p = link[p];
		if (!p) {link[cur] = 1; return ;}
		int q = ch[p][c];
		if (len[p] + 1 == len[q]) {link[cur] = q; return ;}
		int clo = ++cnt;
		link[clo] = link[q]; len[clo] = len[p] + 1;
		link[q] = link[cur] = clo;
		memcpy(ch[clo], ch[q], sizeof(ch[clo]));
		while (p && ch[p][c] == q) ch[p][c] = clo, p = link[p];
	}
	inline void Tong_sort() {
		for (int i = 1; i <= cnt; ++i) ++tong[len[i]];
		for (int i = 1; i <= cnt; ++i) tong[i] += tong[i - 1];
		for (int i = 1; i <= cnt; ++i) rk[tong[len[i]]--] = i;
	}
} s;
struct SGT {
	ll c[M], d[M];
	inline int lowbit(int k) {return k & (-k);}
	inline void add(int x, int y) {
		for (int p = x; x <= s.n; x += lowbit(x)) c[x] += y, d[x] += p * y;
	}
	inline ll ask(int x) {
		ll tmp = 0, res = 0, p = x;
		for (; x; x -= lowbit(x)) tmp += c[x], res += d[x];
		return tmp * (p + 1) - res;
	}
	inline void add(int l, int r, int k) {add(l, k); add(r + 1, -k);}
} seg;
struct LCT {
	#define ls(x) ch[x][0]
	#define rs(x) ch[x][1]
	int ch[N][2], fa[N], xr[N], cov[N], val[N], len[N], top, sta[N];
	inline void build() {
		val[0] = 1e9;
		for (int i = 1; i <= s.cnt; ++i) {
			fa[i] = s.link[i];
			val[i] = len[i] = s.len[fa[i]] + 1;
			xr[i] = cov[i] = ls(i) = rs(i) = 0;
		}
	}
	inline void pushcov(int x, int k) {xr[x] = cov[x] = k;}
	inline void pushup(int x) {
		val[x] = min(len[x], min(val[ls(x)], val[rs(x)]));
	}
	inline void pushdown(int x) {
		if (cov[x]) {
			if (ls(x)) pushcov(ls(x), cov[x]);
			if (rs(x)) pushcov(rs(x), cov[x]);
			cov[x] = 0;
		}
	}
	inline bool nroot(int x) {return ls(fa[x]) == x || rs(fa[x]) == x;}
	inline void rotate(int x) {
		int y = fa[x], z = fa[y], k = rs(y) == x, w = ch[x][!k];
		if (nroot(y)) ch[z][rs(z) == y] = x;
		ch[x][!k] = y; ch[y][k] = w;
		if (w) fa[w] = y;
		fa[y] = x; fa[x] = z; pushup(y); pushup(x);
	}
	inline void splay(int x) {
		int y = x, z; top = 0;
		sta[++top] = y;
		while (nroot(y)) sta[++top] = y = fa[y];
		while (top) pushdown(sta[top--]);
		while (nroot(x)) {
			y = fa[x]; z = fa[y];
			if (nroot(y)) rotate((ls(y) == x) ^ (ls(z) == y) ? x : y);
			rotate(x);
		}
	}
	inline void access(int x, int k) {
		int y = 0;
		while (x) {
			splay(x);
			if (xr[x]) seg.add(xr[x] - s.len[x] + 1, xr[x] - val[x] + 1, -1);
			rs(x) = y; y = x, x = fa[x];
		}
		pushcov(y, k); seg.add(1, k, 1);
	}
	#undef ls
	#undef rs
} lct;
int main() {
	scanf("%s", s.s + 1); s.n = strlen(s.s + 1); s.init();
	for (int i = 1; i <= s.n; ++i) {
		s.SAM_stru(s.s[i] - 'a'); pos[i] = s.las;
	}
	s.Tong_sort();
	n = read();
	for (int i = 1; i <= n; ++i) {
		a[i] = (mdzz) {read(), read(), i};
	}
	sort(a + 1, a + 1 + n);
	lct.build();
	for (int i = 1, j = 1; i <= n; ++i) {
		while (j <= a[i].r) lct.access(pos[j], j), ++j;
		ans[a[i].id] = seg.ask(a[i].r) - seg.ask(a[i].l - 1);
	}
	for (int i = 1; i <= n; ++i) printf("%lld\n", ans[i]);
	return 0;
}
```

---


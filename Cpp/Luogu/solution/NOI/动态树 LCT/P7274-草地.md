# 草地

## 题目描述

给定一 $n \times m$ 的网格，其中每个格子均有颜色，可以为黑色或白色。

现可以进行若干次操作。一次操作中，你需选定上、下、左和右中的一个方向，然后，对于每个黑色的格子，若其指定方向上对应的位置不为网格的边界，则对应的那个格子变为黑色。

求：至少进行几次操作，才能使任意两个黑色格子八连通。八连通的定义可参考【提示/说明】部分。

## 说明/提示

----

**【样例解释 #1】**

对于第一组样例，一开始的网格如图（1）所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/7amyon0v.png)

（1）

进行一次操作，选择下方向，网格会变为图（2）所示的样子（标红的是新变为黑色的格子），此时任意两个黑格都八连通。

![](https://cdn.luogu.com.cn/upload/image_hosting/9aszlhed.png)

（2）

----

**【数据范围】**

**本题采用捆绑测试**

- Subtask 1（$10$ 分）：保证 $n, m\leq 3$。
- Subtask 2（$10$ 分）：保证 $n, m \leq 80$。
- Subtask 3（$5$ 分）：保证黑色格子的数量不超过 $20$。
- Subtask 4（$5$ 分）：保证 $m = 1$。
- Subtask 5（$25$ 分）：保证 $n, m \leq 300$。
- Subtask 6（$45$ 分）：没有特殊限制。

对于 $100 \%$ 的数据，保证 $1 \leq n,m \leq 10^3$，至少有一个黑色格子。

**八连通的定义**

两个黑色格子八连通，当且仅当在它们之间有公共顶点或公共边，或存在一个黑色格子同时与它们八连通。

用比较通俗的话说，就是它们在只能向周围相邻的八个格子行走，且只能经过黑色格子的条件下相互可达。

## 样例 #1

### 输入

```
5 4
1100
1000
0011
0000
0001```

### 输出

```
1```

## 样例 #2

### 输入

```
8 10
0000000011
0000000000
0000000000
0000000010
0000000000
0001010100
0000000000
0001000100```

### 输出

```
3```

# 题解

## 作者：Miko35 (赞：17)

Orz EA!

首先你发现，向上流和向下流实际上是一样的，左右同理，并且操作顺序是没有关系的，所以一定存在一种最优策略是下移 $A$ 次后右移 $B$ 次，此时一个点会向右向下延伸出一个 $(A+1) \times (B+1)$ 的矩形。

考虑两个黑点 $(x,y) \to (x',y')$ 啥时候能联通（不妨 $x<x'$, $y<y'$），那就是 $A \ge x'-x-1$，$B \ge y'-y-1$ 的时候。最暴力的想法是，把两黑点间连一条权值为二元组 $(x'-x-1,y'-y-1)$ 的边，那我们就要求的是 $\max x + \max y$ 的 MST。

一种求法是枚举 $\max x$ 然后计算 $\max y$ 的最小值。具体而言，将所有 $M$ 条边按照 $x$ 从小到大排序，逐条加入进来，同时 LCT 维护 $y$ 这维的 MST，可以 $O(M \log n)$。当然也可以 $O(M \log^2 M)$ 整体二分，比较好写。

黑点数较多时 $M$ 可以到 $O(n^2m^2)$ 的级别，但其实有很多边是不需要的：以两个黑点 $p,q$ 为对角的矩形内，如果还存在其他黑点，则这条边就不需要了，因为可以由这两条较短的边“拼合”起来得到。这样连边的话，显然同一行内的点连出的边是 $O(m)$ 级别，故总边数是 $O(nm)$ 级别的。套用上面求 MST 的做法，我们就以 $O(nm \log nm)$ 的复杂度解决了这道题。

可能会卡常，但显而易见这个 $O(nm)$ 的边数很难卡到很满。有一个有力的剪枝：一开始存在于一个连通块的黑点可以直接缩起来。

这份代码是 $O(nm \log n \log m)$ 的整体二分，可以比较快跑过去。

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a,i##i=b;i<=i##i;++i)
#define ROF(i,a,b) for(int i=a,i##i=b;i>=i##i;--i)
using namespace std;
const int N=1e3+7,M=3*N*N;
int n,m,C=1,lm,ct[M],T,ans[N],h[N],id[N],res=M,X[N],Y[N],g;
char s[N];
struct mem{int t,p,v;};
struct unf{
	int a[M],C=0;mem f[M];
	int& operator[](int x){return a[x];}
	void st(int x,int v){f[++C]={T,x,a[x]},a[x]=v;}
	void rbk(int t){for(;C&&f[C].t>=t;--C)a[f[C].p]=f[C].v;}
}fa,rk;
int rbk(int t){return fa.rbk(t),rk.rbk(t),T=t-1;}
int fd(int x){return fa[x]==x?x:fd(fa[x]);}
int merge(int x,int y){
	x=fd(x),y=fd(y);
	if(x!=y){
		if(rk[x]<rk[y])swap(x,y);
		ct[T+1]=ct[T]-1,++T,fa.st(y,x);
		if(rk[x]==rk[y])rk.st(x,rk[x]+1);
	}
	return ct[T]==1;
}
struct edge{
	int u,v,x,y;
	void mtn(){
		u=fd(u),v=fd(v);
		if(u==v)x=m+1,y=n+1;
	}
	int add(int o){return x<=o?merge(u,v):0;}
}x[M],y[M];
void solve(int l,int r,int L,int R){
	if(L==R)FOR(i,l,r)ans[i]=L;
	if(l>r||L>R)return;
	int d=(l+r)/2,G,t=T+1,p=R;
	FOR(i,X[l],X[d+1]-1)if(x[i].y<L)x[i].add(M);
	G=T+1;
	FOR(i,Y[L],Y[R+1]-1)if(y[i].add(d)){p=y[i].y;break;}
	ans[d]=p,rbk(G),solve(d+1,r,L,p),rbk(t);
	FOR(i,Y[L],Y[p]-1)y[i].add(l-1);
	solve(l,d-1,p,R);
}
void link(int i,int j){
	if(id[i]&&id[j])++C,x[C]=y[C]={id[i],id[j],max(j-i-1,0),max(abs(h[j]-h[i])-1,0)};
}
signed main(){
	scanf("%d%d",&n,&m),lm=max(n,m);
	FOR(i,1,n){
		scanf("%s",s+1),s[m+1]='1';
		int w=1;
		FOR(j,1,m)if(s[j]=='1'){
			if(id[j])++C,x[C]=y[C]={ct[0]+1,id[j],0,i-h[j]-1};
			g=h[j],id[j]=++ct[0],h[j]=i;
			for(int p=j-1,k=g;p>=w;--p)if(h[p]>k)k=h[p],link(p,j);
			for(int p=j+1,k=g;s[p]<'1';++p)if(h[p]>k)k=h[p],link(j,p);
			w=j;
		}
	}
	FOR(i,1,ct[0])fa[i]=i;
	FOR(i,1,C)if(!x[i].y)x[i].add(0);
	FOR(i,1,C)x[i].mtn(),y[i].mtn();
	sort(x+1,x+C+1,[](edge a,edge b){return a.x<b.x;});
	sort(y+1,y+C+1,[](edge a,edge b){return a.y<b.y;});
	while(x[C-1].y>n)--C;
	ROF(i,C,1)X[x[i].x]=Y[y[i].y]=i;
	ROF(i,m,1)if(!X[i])X[i]=X[i+1];
	ROF(i,n,1)if(!Y[i])Y[i]=Y[i+1];
	Y[n+2]=C+1,X[m+2]=C+1,solve(0,m,0,n+1);
	FOR(i,0,m)if(ans[i]<=n)res=min(res,i+ans[i]);
	printf("%d",res);
	return 0;
}
```


---

## 作者：crs_line (赞：7)

首先考虑我们并不需要四个方向都移动，只需从左右，上下中任选两个方向即可，证明简要来说就是操作方案只与相对距离有关，与具体扩展的方向没有必然联系。另外我们也可以发现操作之间可以互换，对答案不会产生影响。以此为基础，在以下内容，笔者默认只考虑左与下方向。

那以此为基础，我们不难想出可以二分操作次数，同时暴力枚举左边扩展了多少步，模拟 check 即可，复杂度为 $O(n^3\log n)$，同时因为本题具有单调性，达到合法状态的左侧操作次数增加，下侧操作次数就会减少，可以用类似单调指针的方法优化到 $O(n^3)$。

考虑正解，我们对任意两个黑点建边，定义边权为二元组 $(a,b)$ 表示两点在两个方向坐标值的差距，即两点联通的代价。那我们最后只需要选出最小代价意义下边的集合，使任意两点联通即可，这个过程可以用枚举 $max_a$，对 $b$ 跑 $MST$ 来实现，但边数是 $n^2$ 级别的，复杂度为 $O(nm\log n)$。

考虑进一步优化，我们发现有很多边是多余的。如下图所展示，同时选择 $A$，$B$ 要比选择 $C$ 更优。 

![](https://cdn.luogu.com.cn/upload/image_hosting/4xibuu0c.png)

于是我们考虑把所有类似 $C$ 的边删掉，不难发现整张图会呈现如下形式(图画的很烂，有一些错误，感性理解....)

![](https://cdn.luogu.com.cn/upload/image_hosting/2uo289i6.png)

也就是说一个点只会向在其下方且高度最大的点连边，有效边只有 $O(n)$ 条，考虑如何实现，我们顺序遍历每一行，记录每一列出现的最靠下黑点的编号与位置，分别维护以这一列向左，向右的单调栈，顺序建边就好。(讲的不是很明白，如果不理解可以看代码)。

解决了边数的问题后，我们只剩下一个问题，如何快速的求出 $n$ 次最小生成树，在这里我们可以用整体二分，将权值 $a$ 视做二分的对象，每次找到在对应二分对象下满足条件的 $b$ 的最小值，再继续划分部分求解即可，为避免使用 $LCT$，我们可以写可持久化并查集模拟此过程。一个更好的优化是，预先将在一个联通块中的黑点缩起来，会提升效率。本题就做完了，时间复杂度为 $O(n^2\log n)$。

code:(有些压行情谅解)

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1005;
inline int read()
{
    int x=0,f=1; char c;
    while(!isdigit(c=getchar())) if(c=='-') f=-1;
    do x=(x<<1)+(x<<3)+(c^48); while(isdigit(c=getchar()));
    return x*f;
}
int H,L,kk,acn,ret,tot;
int sig[N],lin[N],ans[N],X[N],Y[N],in[N];
struct node{int x,y,a,b;}fir[N*N<<1],sec[N*N<<1];
struct Diset
{
    int fa[N*N],size[N*N],ope=0; struct His{int pos,fid;}his[N*N]; 
    int find(int x){ return (x==fa[x])?fa[x]:find(fa[x]); } 
    void init(int len){ for(int i=1;i<=len;i++) fa[i]=i,size[i]=1; }
    bool merge(int x,int y)
    {
        x=find(x); y=find(y); if(x==y) return tot==1;
        if(size[x]>size[y]) swap(x,y); fa[x]=y; size[y]+=size[x];
        tot--; his[++ope]=(His){x,y}; return tot==1;
    }
    void Revoke(int tim) { while(ope>tim) fa[his[ope].pos]=his[ope].pos,size[his[ope].fid]-=size[his[ope].pos],tot++,ope--; }
}self;
void Divid(int l,int r,int F,int T)
{
    if(F>T||l>r) return; if(F==T){ for(int i=l;i<=r;i++) ans[i]=F; return; }
    int mid=(l+r)>>1,pre=self.ope,fro,boun=T;
    for(int i=X[l];i<=X[mid+1]-1;i++) if(fir[i].b<F) self.merge(fir[i].x,fir[i].y); fro=self.ope;
    for(int i=Y[F];i<=Y[T+1]-1;i++) if(sec[i].a<=mid&&self.merge(sec[i].x,sec[i].y)){ boun=sec[i].b; break; }
    ans[mid]=boun; self.Revoke(fro); Divid(mid+1,r,F,boun); self.Revoke(pre);
    for(int i=Y[F];i<=Y[boun]-1;i++) if(sec[i].a<=l-1) self.merge(sec[i].x,sec[i].y); Divid(l,mid-1,boun,T);
}
signed main()
{
    H=read(); L=read(); in[L+1]=1;
    for(int i=1;i<=H;i++)
    {
        for(int j=1;j<=L;j++) scanf("%1d",&in[j]);
        for(int j=1,pre=1;j<=L;j++) if(in[j])
        {
            if(sig[j]) ++kk,fir[kk]=sec[kk]=(node){sig[j],tot+1,0,i-lin[j]-1}; sig[j]=++tot; 
            for(int k=j-1,s=lin[j];k>=pre;k--) if(lin[k]>s) s=lin[k],++kk,fir[kk]=sec[kk]=(node){sig[k],tot,j-k-1,max(i-lin[k]-1,0)};
            for(int k=j+1,s=lin[j];!in[k];k++) if(lin[k]>s) s=lin[k],++kk,fir[kk]=sec[kk]=(node){sig[k],tot,k-j-1,max(i-lin[k]-1,0)};
            pre=j; lin[j]=i;
        }
    }
    self.init(tot);
    for(int i=1;i<=kk;i++) if(!fir[i].a&&!fir[i].b) self.merge(fir[i].x,fir[i].y);
    if(tot==1) return printf("0\n"),0;
    for(int i=1;i<=kk;i++)
    {
        fir[i].x=sec[i].x=self.find(fir[i].x); fir[i].y=sec[i].y=self.find(fir[i].y);
        if(fir[i].x==fir[i].y) fir[i].a=L+1,sec[i].b=H+1;
    }
    sort(fir+1,fir+kk+1,[&](const node A,const node B){return A.a<B.a;});
    sort(sec+1,sec+kk+1,[&](const node A,const node B){return A.b<B.b;});
    while(fir[kk].a>L) kk--; for(int i=kk;i>=1;i--) X[fir[i].a]=i,Y[sec[i].b]=i;
    X[L+2]=X[L+1]=kk+1; for(int i=L;i>=0;i--) if(!X[i]) X[i]=X[i+1];
    Y[H+2]=Y[H+1]=kk+1; for(int i=H;i>=0;i--) if(!Y[i]) Y[i]=Y[i+1];
    ret=1e9; Divid(0,L,0,H+1); for(int i=0;i<=L;i++) if(ans[i]<=H) ret=min(ret,ans[i]+i); printf("%d",ret);
    return 0;
}
```

---

## 作者：OrinLoong (赞：1)

# LGP7274 [EAPrac R2 B] 草地

### 题意简述
给定一 $N\times M$ 的黑白网格。可以进行 $k$ 次操作，选定上下左右四个方向中的一个，对于每个黑色格子，若其此方向往前一格没出边界，把这个变为黑色。最小化 $k$ 使得所有黑格八联通。

### 解法分析
显然向上等价向下，向左等价向右。因此只用考虑两个方向。下文假设 $NM$ 同阶，相当于把原网格图当成一个正方形来讲。规定坐标最大为 $N$ 的一维为 x 维度，坐标最大为 $M$ 的一维为 y 维度。规定 $V=NM$。

要连通？考虑转化为图论问题。单独考虑初始的两个黑格 $u,v$，其要想不借助其它结点联通，等价于需要执行 $|x_u-x_v|$ 次向下，$|y_u-y_v|$ 次向右，我们建一张图论图，黑格两两连这样一条边。然后原问题就转化为求其 MST。

但是这么连边太野蛮了，评测机无法忍受我们 $V^2$ 边数带来的时空复杂度。

> \**悠久的观察性质\**

我们发现，若有一个黑格 $c$ 处在两个黑格 $u,v$ 围成的矩形中间，那么只用连 $(u,c),(v,c)$，不用连 $(u,v)$。可以理解为一方面 $u,v$ 可以借助 $c$ 连通，另一方面能使 $(u,v)$ 联通的方案也一定可以让 $c$ 和 $u,v$ 联通。

我们还发现（注意力惊人）这样做的话边数就变成 $O(V)$ 了。为什么呢？因为：
1. $x$ 相同的点之间连的边数（就是完全横着的边）数量显然为 $O(V)$。
2. 我们让所有边都是从 $x$ 更大的那个点往 $x$ 更小的那个点连。对于 $x$ 维都为 $i$ 的点而言，其往上连的点种数最多为 $O(M)$，否则根据鸽巢原理至少有两个点 $y$ 坐标相同，那么x更小的那个点不应该参与此次连边。
3. 在上条的基础上，每一个 $x$ 坐标小于 $i$ 的点最多被下面的两个点连上，且其来自两个方向。否则同向中离得远的那个点不应该参与。

观察到其有两种权值，我们考虑枚举向下几次，计算对于向下 $i$ 次，最少需要向右 $ans_i$ 次。观察到这玩意可以整体二分。具体来说，这题的整体二分有点特殊：

![pEAcVSA.png](https://s21.ax1x.com/2025/01/22/pEAcVSA.png)


没错，这题有一个性质：$\forall i<j,ans_i\ge ans_j$。
整体二分嘛，我们写一个 `solve(al,ar,ql,qr)`。`solve` 开始，并查集里有一些边（零），还有一些边满足 $al\le dx\le amid,dy\le ql$ 的边，这些边应该加上（一），然后我们从 $ql$ 开始枚举 $i$，对于每一个 $i$ 把所有 $dx=i,dy\le amid$ 的边加上（二）。如果 $i=bkp$ 时加联通了，就说明 $ans_{bkp-1}<amid,ans_{bkp}\ge amid$。

对于 `solve(amid+1,ar,ql,bkp-1)`，我们要回滚到只有（零）（一）部分的边的状态，对于 `solve(al,amid,bkp,qr)`，我们要回滚到只有（零）部分的边的状态。递归下去的时候要撤一部分边，这需要用到回滚并查集。

不过我们怎么做到既能按 $x$ 遍历边集，又能按 $y$ 遍历边集呢？答案是把边存进一个边数组里，然后分别以 $x,y$ 为索引把这条边的编号插进两个vector 数组里。然后对两个 vector 数组的每个索引，把它按另一维排序。（详见代码）这样我们要是想遍历 $x$ 维上长为 $k$ 的区间内满足某条件的区间，就可以 $O(kN)$ 做完了，对 $y$ 同理。

时间复杂度 $O(V\log V\log N)$。

等等，这时间复杂度保真吗？看图。
![pEAcAWd.png](https://s21.ax1x.com/2025/01/22/pEAcAWd.png)
![pEAcFFe.png](https://s21.ax1x.com/2025/01/22/pEAcFFe.png)

（以防图挂了，还是说两句）

每一次遍历边集可以粗略看作是 $O(kN)$ 的，而每一层的所有 `solve` 里 $\sum k$ 是 $O(N)$ 的，`solve` 总共 $\log N$ 层，因此遍历边集的复杂度是 $O(V\log N)$ 的。

至于加边问题，可以证明：同层以内任何边最多只会被一次当作一类边加入，一次当作二类边加入。所以每条边最多被操作 $O(\log N)$ 次，所有边一起最多就是 $O(V\log N)$ 次的。并查集查找和合并带一个 $O(\log V)$ 的复杂度，回滚带 $O(1)$ 复杂度，所以加边总复杂度 $O(V\log N\log V)$。

好，证毕。

### 代码实现

对于上下或左右方向相邻的点，代码里面特殊处理让它们永远连上了，算是个小优化？
注意一开始 `ar` 应该设为 `M` 而不是 `M-1`。这是为了避免 `M=1` 时合法与否没判断就直接更新 `ans` 了。（相当于为无解的 $x$ 留了个发泄出口）
另外特判一下初始就全部联通的情况！

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace obasic{
    typedef pair<int,int> pii;
    template <typename _T>
    void fredi(_T &x){
        _T k=1;x=0;char ch=getchar();
        for(;!isdigit(ch);ch=getchar())if(ch=='-')k=-1;
        for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+ch-'0';
        x*=k;return;
    }
    template <typename _T>
    void fwrti(_T x){
        if(x<0)putchar('-'),x=-x;
        if(x>9)fwrti(x/10);
        putchar(x%10+'0');
    }
};
using namespace obasic;
const int MaxN=1e3+5,MaxNs=1e6+5;
const int Inf=0x3f3f3f3f;
int N,M,ans[MaxN],fans;char S[MaxN];
int pcnt,upp[MaxN],lh,rh;
struct node{int x,y;}P[MaxNs];
struct RekaUnionFind{
    int n,ufa[MaxNs],hei[MaxNs],tim,tot;
    struct oper{int fx,fy,hc;}mem[MaxNs*3];
    void init(int x){
        n=x;for(int i=1;i<=n;i++)ufa[i]=i,hei[i]=1;
        memset(mem,0,sizeof(mem)),tim=0,tot=n;
    }
    int find(int u){return ufa[u]==u?u:find(ufa[u]);}
    void merge(int x,int y){
        int fx=find(x),fy=find(y);
        if(fx==fy)return;
        if(hei[fx]<hei[fy])swap(fx,fy);
        int chc=(hei[fx]==hei[fy]);hei[fx]+=chc;
        mem[++tim]={fx,fy,chc},ufa[fy]=fx,tot--;
    }
    void revoke(int p){
        while(tim>p){
            auto [cfx,cfy,chc]=mem[tim--];
            ufa[cfy]=cfy,hei[cfx]-=chc,tot++;
        }
    }
    bool isaun(){return tot==1;}
}RevUf;
int trg(){return RevUf.tim;}
struct edge{int p1,p2,dx,dy;};
bool cmpdy(edge a,edge b){return a.dy<b.dy;}
vector<edge> E0;vector<int> E1[MaxN],E2[MaxN];
void insedge(int p1,int p2,int dx,int dy){
    E0.push_back({p1,p2,dx,dy});int cid=E0.size()-1;
    E1[dx].push_back(cid),E2[dy].push_back(cid);
}
bool cmp1(int a,int b){return E0[a].dy<E0[b].dy;}
bool cmp2(int a,int b){return E0[a].dx<E0[b].dx;}
void solve(int al,int ar,int ql,int qr){
    if(ql>qr||al>ar)return;
    if(al==ar){for(int i=ql;i<=qr;i++)ans[i]=al;return;}
    int amid=(al+ar)>>1,tm0=trg();
    for(int i=al;i<=amid;i++){
        if(E2[i].size())for(int j : E2[i]){
            auto [cp1,cp2,cdx,cdy]=E0[j];
            if(cdx>=ql)break;RevUf.merge(cp1,cp2);
        }
    }
    int tm1=trg(),bkp=qr+1;
    for(int i=ql,flag=1;i<=qr&&flag;i++){
        if(E1[i].size())for(int j : E1[i]){
            auto [cp1,cp2,cdx,cdy]=E0[j];
            if(cdy>amid)break;RevUf.merge(cp1,cp2);
            if(RevUf.isaun())bkp=i,flag=0;
        }
    }
    RevUf.revoke(tm1);solve(amid+1,ar,ql,bkp-1);
    RevUf.revoke(tm0);for(int i=ql;i<=bkp;i++){
        if(E1[i].size())for(int j : E1[i]){
            auto [cp1,cp2,cdx,cdy]=E0[j];
            if(cdy>al)break;RevUf.merge(cp1,cp2);
        }
    }
    solve(al,amid,bkp,qr);
}
int main(){
    fredi(N),fredi(M);
    P[0]={0,0};E0.push_back({0,0,0,0});
    vector<pii> hcn;for(int i=1;i<=N;i++){
        scanf("%s",S+1);S[M+1]='1';
        for(int j=1,lp=0,dx,dy;j<=M;j++){
            if(S[j]!='1')continue;P[++pcnt]={i,j};
            dx=i-P[upp[j]].x,dy=j-P[lp].y;
            if(lp&&dy==1)hcn.push_back({pcnt-1,pcnt});
            if(lp&&dy!=1)insedge(pcnt-1,pcnt,0,dy-1);
            if(upp[j]&&dx==1)hcn.push_back({upp[j],pcnt});
            if(upp[j]&&dx!=1)insedge(upp[j],pcnt,dx-1,0);
            lh=rh=P[upp[j]].x;
            for(int k=j-1;k>P[lp].y;k--){
                if(!upp[k])continue;auto [cux,cuy]=P[upp[k]];
                if(cux>lh)insedge(upp[k],pcnt,i-cux-1,j-k-1),lh=cux;
            }
            for(int k=j+1;S[k]!='1';k++){
                if(!upp[k])continue;auto [cux,cuy]=P[upp[k]];
                if(cux>rh)insedge(upp[k],pcnt,i-cux-1,k-j-1),rh=cux;
            }
            lp=upp[j]=pcnt;
        }
    }
    RevUf.init(pcnt);for(auto [cp1,cp2] : hcn)RevUf.merge(cp1,cp2);
    if(RevUf.isaun()){puts("0");return 0;}
    for(int i=0;i<N;i++)sort(E1[i].begin(),E1[i].end(),cmp1);
    for(int i=0;i<M;i++)sort(E2[i].begin(),E2[i].end(),cmp2);
    solve(0,M,0,N-1);fans=Inf;for(int i=0;i<N;i++)if(ans[i]<M)fans=min(fans,ans[i]+i);
    fwrti(fans);
    return 0;
}
```

---

## 作者：IdnadRev (赞：1)

可以发现上和下是等价的，同理左和右也是等价的。

枚举一共向右移动了 $a$ 步，将水平距离小于等于 $a$ 的黑点连一条边权为垂直距离的边，那么此时向下至少需要移动的步数 $b$ 就是最小生成树的最大边权。

显然这个最小生成树可以用 LCT 来维护。

但是边实在是太多了，于是考虑单调栈优化一下连边，那么边数就是 $O(nm)$ 了，可以通过。

```
#include<stdio.h>
#include<algorithm>
#include<set>
#include<iostream>
#include<vector>
#define inf 1000000000
using namespace std;
const int maxN=1000005,maxn=maxN*3,maxm=1005;
int n,m,ans,etot,es,vtot,top;
int a[maxm][maxm],lft[maxm][maxm],rgt[maxm][maxm];
int f[maxN],val[maxn];
set< pair<int,int> >s;
string str;
struct edge {
	int L,x,y,z;
} d[maxN<<1];
struct point {
	int x,y;
} stk[maxN];
inline int cmp(edge a,edge b) {
	return a.L<b.L;
}
struct Link_Cut_Tree {
	int cnt;
	int chd[maxn][2],f[maxn],tag[maxn],mx[maxn],id[maxn];
	inline void build() {
		cnt=0;
	}
	inline int check(int now) {
		return chd[f[now]][0]==now? 0:1;
	}
	inline int checkroot(int now) {
		return chd[f[now]][0]^now&&chd[f[now]][1]^now;
	}
	inline void connect(int now,int son,int dir) {
		f[son]=now,chd[now][dir]=son;
	}
	inline void pushup(int now) {
		mx[now]=val[now],id[now]=now;
		if(chd[now][0]&&mx[chd[now][0]]>mx[now])
			mx[now]=mx[chd[now][0]],id[now]=id[chd[now][0]];
		if(chd[now][1]&&mx[chd[now][1]]>mx[now])
			mx[now]=mx[chd[now][1]],id[now]=id[chd[now][1]];
	}
	inline void getlazy(int now) {
		swap(chd[now][0],chd[now][1]),tag[now]^=1;
	}
	inline void pushdown(int now) {
		if(tag[now])
			getlazy(chd[now][0]),getlazy(chd[now][1]),tag[now]=0;
	}
	void deal(int now) {
		if(checkroot(now)==0)
			deal(f[now]);
		pushdown(now);
	}
	inline void rotate(int now) {
		int fth=f[now],gfth=f[fth],frlt=check(now),grlt=check(fth);
		if(checkroot(fth)==0)
			chd[gfth][grlt]=now;
		f[now]=gfth;
		connect(fth,chd[now][frlt^1],frlt),connect(now,fth,frlt^1);
		pushup(fth),pushup(now);
	}
	void splay(int now) {
		deal(now);
		while(now&&checkroot(now)==0) {
			int fth=f[now],frlt=check(now),grlt=check(fth);
			if(checkroot(fth)==0)
				rotate(frlt^grlt? now:fth);
			rotate(now);
		}
		pushup(now);
	}
	void access(int now) {
		int last=0;
		while(now) {
			splay(now);
			chd[now][1]=last;
			pushup(now);
			last=now,now=f[now];
		}
	}
	void makeroot(int now) {
		access(now),splay(now),getlazy(now),pushup(now);
	}
	void split(int x,int y) {
		makeroot(x),access(y),splay(y);
	}
	void link(int x,int y) {
		makeroot(x),f[x]=y;
	}
	void cut(int x,int y) {
		split(x,y);
		if(chd[y][0]==x&&chd[x][1]==0) {
			f[x]=chd[y][0]=0;
			pushup(x);
		}
	}
} LCT;
int find(int x) {
	return f[x]==x? x:f[x]=find(f[x]);
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		cin>>str;
		for(int j=1; j<=m; j++)
			if(str[j-1]=='1')
				a[i][j]=++vtot;
	}
	if(vtot==1) {
		puts("0");
		return 0;
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++)
			lft[i][j]=a[i][j-1]? j-1:lft[i][j-1];
		for(int j=m; j>=1; j--)
			rgt[i][j]=a[i][j+1]? j+1:rgt[i][j+1];
	}
	for(int j=1; j<=m; j++) {
		top=0;
		for(int i=n; i>=1; i--) {
			if(rgt[i][j]) {
				while(top&&stk[top].y>=rgt[i][j])
					top--;
				stk[++top]=point {i,rgt[i][j]};
			}
			if(a[i][j]) {
				while(top) {
					d[++es]=edge {abs(j-stk[top].y),a[i][j],a[stk[top].x][stk[top].y],abs(i-stk[top].x)};
					top--;
				}
				stk[++top]=point {i,j};
			}
		}
	}
	for(int j=m; j>=1; j--) {
		top=0;
		for(int i=n; i>=1; i--) {
			if(lft[i][j]) {
				while(top&&stk[top].y<=lft[i][j])
					top--;
				stk[++top]=point {i,lft[i][j]};
			}
			if(a[i][j]) {
				while(top) {
					if(stk[top].x!=i&&stk[top].y!=j)
						d[++es]=edge {abs(j-stk[top].y),a[i][j],a[stk[top].x][stk[top].y],abs(i-stk[top].x)};
					top--;
				}
				stk[++top]=point {i,j};
			}
		}
	}
	for(int i=1; i<=vtot; i++)
		f[i]=i,val[i]=-inf;
	LCT.build();
	sort(d+1,d+1+es,cmp),ans=inf;
	for(int i=0,j=1; i<=m; i++) {
		for(; j<=es&&d[j].L<=i+1; j++) {
			int x=d[j].x,y=d[j].y,z=d[j].z;
			if(x==y)
				continue;
			val[vtot+j]=d[j].z;
			if(find(x)!=find(y)) {
				etot++,f[find(x)]=find(y);
				s.insert(make_pair(z,j)),LCT.link(x,vtot+j),LCT.link(y,vtot+j);
			} else {
				LCT.split(x,y);
				if(LCT.mx[y]<=z)
					continue;
				int k=LCT.id[y]-vtot;
				s.erase(make_pair(d[k].z,k)),LCT.cut(d[k].x,vtot+k),LCT.cut(d[k].y,vtot+k);
				s.insert(make_pair(z,j)),LCT.link(x,vtot+j),LCT.link(y,vtot+j);
			}
		}
		if(etot==vtot-1)
			ans=min(ans,i+max((s.rbegin()->first)-1,0));
	}
	printf("%d\n",ans);
	return 0;
}
```

---


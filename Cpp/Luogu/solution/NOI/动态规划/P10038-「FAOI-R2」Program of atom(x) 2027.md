# 「FAOI-R2」Program of atom(x) 2027

## 题目背景

**Update on 2025/5/11：我们在附件处新增了一份可视化工具。**

**Update on 2025/5/26：可视化工具已经更新。**

这是来自 $2027$ 年的 FAOI 的一道题目，是一道带有 SPJ 的传统题。

------------

自从 [krjt](https://www.luogu.com.cn/user/691537) 上次被 $160$ 人 [JC](https://www.luogu.com.cn/problem/T573220) 后，他换了一个「量子密码锁」，并用它锁上了自己的电脑包——打不开密码锁，就取不出包里的电脑。理论上，一旦 krjt 忘了密码，就连造这把锁的人也打不开。

然而，这把锁并非固若金汤。~~有一天，krjt 突然对化学产生了浓厚的兴趣。他拿起那把锁，放在酒精灯上加热，结果发现：~~ 在高温环境下，这把锁内的原子（严格来说是「离子」，下同）排布变得不稳定，这将导致它瘫痪。

## 题目描述

krjt 找来了密码锁的说明书：

> 在密码锁中，有一条长度为 $n$（不能更改，$n$ 的具体取值见密码锁铭牌）的链，链上共有 $n$ 个结点。每个结点上可以存放至多一个原子。初始时，$1,2,\ldots,n$ 号原子以某个顺序（可以由用户自行调整）被存放在其中，每个结点存放一个原子。
> 
> 定义 $i$ 号原子的电荷量为 $i!=1 \times 2\times 3 \times \ldots \times i$。
> 
> 现有一个计时器 $b$（单位为秒），其初值为 $0$。
>
> 密码锁被加热后，以下事件**依次循环发生**，直至达成终止条件：
> 
> 1. 位于链两端的原子被移除（**这不会使链变短**），**不再对后续事件产生影响**；
> 2. 判定终止条件：
>    - 若此时链中剩下**不多于 $1$ 个**原子（**也可以是 $0$ 个**），则**达成终止条件**，密码锁瘫痪（**此时计时器 $b$ 的值不会增加 $1$**）；
>    - 否则，将计时器 $b$ 的值增加 $1$。
> 3. 给每个原子标定运动方向（**标定的运动方向是临时的，只生效一次，在下一次标定前会被重置**）：
>    - 计算它左边所有原子的电荷量之和，设计算结果为 $x$；
>    - 计算它右边所有原子的电荷量之和，设计算结果为 $y$；
>    - 如果 $x<y$，则标定方向为「向左」；
>    - 如果 $x>y$，则标定方向为「向右」；
>    - 可以证明，$x \ne y$。
> 4. 所有原子按照所标定的运动方向，移动一条边的距离，来到相邻的结点。

此外，krjt 从铭牌上读取到了 $n$ 的值。

krjt 定义，密码锁的瘫痪用时，为它瘫痪时 $b$ 的值。当然，krjt 希望密码锁尽量安全，因此他想**最大化密码锁的瘫痪用时**。

~~为了不让更多人再次 JC krjt~~，请问：他该如何排列密码锁中 $n$ 个原子的初始顺序？

## 说明/提示

**样例解释：**

$6$ 个样例的瘫痪用时分别为 $0,0,0,1,1,2$ 秒。

实际上，枚举可知：当 $n \le 6$ 时，输出任何一个 $1 \sim n$ 的排列都能 AC。

下面对样例 $6$ 进行模拟。在链的描述中：

- $0$ 表示该结点为空；
- $i$ 表示该结点上存放着 $i$ 号原子；
- $(x,y)$ 为计算结果。

1. **初始的链**为 $\color{blue}2-4-5-1-6-3$；
2. $b$ 初始为 $0$；
3. **位于两端的原子被移除**，链变为 $\color{blue}0-4-5-1-6-0$；
4. $b$ 增加至 $1$；
5. **计算**，$4$ 个原子（从左向右）的结果分别为 $(\color{red}0\color{black},841),(\color{red}24\color{black},721),(\color{red}144\color{black},720),(145,\color{red}0\color{black})$；
6. 根据结果，左边 $3$ 个原子（$4,5,1$）**向左运动**，最右边的原子（$6$）**向右运动**，链变为 $\color{blue}4-5-1-0-0-6$；
7. **位于两端的原子被移除**，链变为 $\color{blue}0-5-1-0-0-0$；
8. $b$ 增加至 $2$；
9. **计算**，$2$ 个原子（从左向右）的结果分别为 $(\color{red}0\color{black},1),(120,\color{red}0\color{black})$；
10. 根据结果，左边的原子（$5$）**向左运动**，右边的原子（$1$）**向右运动**，链变为 $\color{blue}5-0-0-1-0-0$；
11. **位于两端的原子被移除**，链变为 $\color{blue}0-0-0-1-0-0$；
11. 此时链中只剩下 $1$ 个原子（$1$），**反应结束，密码锁瘫痪**。

综上，样例 $6$ 的瘫痪用时为 $2$ 秒。

------------

本题共有 $100$ 个测试点，分别有 $n=1,2,\ldots,100$，每个 $1$ 分。

对于 $100\%$ 的数据，$1 \le n \le 100$。

## 样例 #1

### 输入

```
1```

### 输出

```
1```

## 样例 #2

### 输入

```
2```

### 输出

```
1 2```

## 样例 #3

### 输入

```
3```

### 输出

```
2 1 3```

## 样例 #4

### 输入

```
4```

### 输出

```
4 2 3 1```

## 样例 #5

### 输入

```
5```

### 输出

```
5 4 1 2 3```

## 样例 #6

### 输入

```
6```

### 输出

```
2 4 5 1 6 3```

# 题解

## 作者：封禁用户 (赞：11)

# Part 1

下面的「最大编号原子」代指链中编号最大的原子。

首先不难发现：$n!>(n-1)!+(n-2)!+\ldots+1!$。证明不给了。

**于是原子的运动方式简化为：**

- **最大编号原子向远离第二大（次大）编号原子的方向移动。**
- **其他原子向远离最大编号原子的方向移动。**

由于初始状态（$n$ 个原子）和最终状态（$0/1$ 个原子）中的原子都形成一个区间，**我们考虑区间 DP**。先看一看，当原子形成一个区间时，是什么情况（以下是一个例子）：

```plain
(n = 14)
Start:
(--) -- -- -- 08 04 02 09 14 06 11 05 -- (--)
Steps:
[Stage 1]
(--) -- -- -- 08 04 02 09 14 06 11 05 -- (--)
(--) -- -- 08 04 02 09 14 -- -- 06 11 05 (--)
[Stage 2]
(--) -- 08 04 02 09 14 -- -- -- -- 06 11 (05)
(--) 08 04 02 09 14 -- -- -- -- -- -- 06 (11)
(08) 04 02 09 -- -- 14 -- -- -- -- -- -- (06)
[Stage 3]
(04) 02 09 -- -- -- -- 14 -- -- -- -- -- (--)
(02) 09 -- -- -- -- -- -- 14 -- -- -- -- (--)
(09) -- -- -- -- -- -- -- -- 14 -- -- -- (--)
Stop:
(--) -- -- -- -- -- -- -- -- 14 -- -- -- (--)
```

不难发现，这个区间被分裂成三段，其中最大编号原子是分界线：

- 最大编号原子左边的所有原子构成一段（`08 04 02 09`）；
- 最大编号原子单独构成一段（`14`）；
- 最大编号原子右边的所有原子构成一段（`06 11 05`）。

这个运动过程也先后分为三个阶段：

- 最大编号原子推动其他原子向两端运动（`Stage 1`）；
- 原子开始被移出，直至其中一段原子全部被移出（`Stage 2`）；
- 原子继续被移出，直至其中两段原子全部被移出（`Stage 3`）。

此外，还有以下特点：

- 同一段中的原子总是成一个区间，从不分开；
- **原子从不会相互越过对方**；
- 第一段全部被移出的原子不会是最大编号原子单独构成的那一段；
- 在有限的时间后，其中两段的原子被全部移走，剩下的原子又形成一个区间。

于是我们可以区间 DP 了。定义 $g_{i,j}(2 \le i \le j \le n-1)$ 为：当剩下的原子形成区间 $[i,j]$ **且不能确定任何原子的编号及其相对大小关系时**，所经过的最长可能时间（$g_{2,n-1}=0$）。

在状态转移时，分 $10$ 种情况枚举下列维度即可：

- 最大编号原子的位置；（$k$）
- 最大编号原子的运动方向（左 $0$ / 右 $1$）；（$w$）
- 最大编号原子在第二阶段的位移量。（$l$）

这 $10$ 种情况分别是：

- 最大编号原子在**最左端**；（**L**）
- 最大编号原子在**最右端**；（**R**）
- 最大编号原子在第一阶段中向**左**运动，第一个被移出的原子位于最大编号原子**左**侧，最大编号原子**左**边的那段原子率先被全部移出；（**LLL**）
- 最大编号原子在第一阶段中向**左**运动，第一个被移出的原子位于最大编号原子**左**侧，最大编号原子**右**边的那段原子率先被全部移出；（**LLR**）
- 最大编号原子在第一阶段中向**左**运动，第一个被移出的原子位于最大编号原子**右**侧，最大编号原子**左**边的那段原子率先被全部移出；（**LRL**）
- 最大编号原子在第一阶段中向**左**运动，第一个被移出的原子位于最大编号原子**右**侧，最大编号原子**右**边的那段原子率先被全部移出；（**LRR**）
- 最大编号原子在第一阶段中向**右**运动，第一个被移出的原子位于最大编号原子**左**侧，最大编号原子**左**边的那段原子率先被全部移出；（**RLL**）
- 最大编号原子在第一阶段中向**右**运动，第一个被移出的原子位于最大编号原子**左**侧，最大编号原子**右**边的那段原子率先被全部移出；（**RLR**）
- 最大编号原子在第一阶段中向**右**运动，第一个被移出的原子位于最大编号原子**右**侧，最大编号原子**左**边的那段原子率先被全部移出；（**RRL**）
- 最大编号原子在第一阶段中向**右**运动，第一个被移出的原子位于最大编号原子**右**侧，最大编号原子**右**边的那段原子率先被全部移出。（**RRR**）

例如，上面的例子属于 **LRR**。

至于构造，大体上把握以下要点即可：

- 在一次转移内，总可以让最大编号原子改变**至多一次**方向来满足 $l$ 的要求；
- **从两边开始从大往小**（即从最大编号原子开始）向构造方案（$arr$）中填写原子编号（$lf$）；
- 每次只填写**被移除的**原子的编号，这样才没有后效性；
- 当不希望某个原子对运动产生影响（即不成为最大 / 次大编号原子）时，可以填写**最小编号** （$llf$）；
- 最后可能会有 $1$ 个或 $2$ 个编号漏填，需要补填（$2$ 个编号的顺序任意）。

最终的时间复杂度为 $O(n^4)$，空间复杂度为 $O(n^2)$。

上面的 DP 状态设计沿用了区间 DP 的传统思路。此外，还有另一种思路（**写在最后**，这也是 [Hanghang](https://www.luogu.com.cn/user/178992) 题解中的做法），它与传统思路代码量相当（都是 $10$ 种情况，基本一致），时间和空间复杂度也相同，**并且输入 $n=100$ 就可以同时得到 $100$ 个测试点的答案**。然而，由于它的常数较大（根据循环次数估计，约为传统思路的 $4$ 倍），~~并且它是在我写完 std 之后才想到的~~，所以就没写代码了。

# Part 2

std：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100 + 12;
int g[N][N], arr[N], ans = -1;
struct REC
{
	int i;
	int j;
	int k;
	int l;
	int w;
};
REC recs[N][N], ansrec;
int main()
{
	int n;
	cin >> n;
	if (n == 1) cout << "1";
	if (n == 2) cout << "1 2";
	if (n <= 2) return 0;
	memset (g, -1, sizeof g);
	arr[1] = n - 1, arr[n] = n;
	recs[2][n - 1] = (REC) {1, n, 0, 0, 0}, g[2][n - 1] = 0;
	for (int len = n - 2; len >= 3; len--)
		for (int i = 2, j = 2 + len - 1; j <= n - 1; i++, j++)
		{
			int c = min (i - 1, n - j);
			if (g[i][j] == -1) continue;
			for (int k = i; k <= j; k++)
			{
				if (k != i && k != j)
				{
					int d = min (k - 2, n - k - 1);
					for (int l = -(d - c); l <= d - c; l += 2)
					{
						int r = min (d, n - j) - c;
						if ((l + d - c) / 2 > d - c - r) continue;
						int p = k - c + l;
						if (k + 1 + d == n)
						{
							if (k - 1 - d - n + p <= 1)
							{
								if (ans < g[i][j] + k - 2)
								{
									ans = g[i][j] + k - 2;
									ansrec = (REC) {i, j, k, l, 0};
								}
							}
							else if (g[max (2, i - d - n + p)][k - 1 - d - n + p] < g[i][j] + d + n - p)
							{
								g[max (2, i - d - n + p)][k - 1 - d - n + p] = g[i][j] + d + n - p;
								recs[max (2, i - d - n + p)][k - 1 - d - n + p] = (REC) {i, j, k, l, 0};
							}
						}
						else
						{
							if (k + 1 + d + p - 1 >= n)
							{
								if (ans < g[i][j] + n - k - 1)
								{
									ans = g[i][j] + n - k - 1;
									ansrec = (REC) {i, j, k, l, 0};
								}
							}
							else if (g[k + 1 + d + p - 1][min (n - 1, j + d + p - 1)] < g[i][j] + d + p - 1)
							{
								g[k + 1 + d + p - 1][min (n - 1, j + d + p - 1)] = g[i][j] + d + p - 1;
								recs[k + 1 + d + p - 1][min (n - 1, j + d + p - 1)] = (REC) {i, j, k, l, 0};
							}
						}
					}
					for (int l = -(d - c); l <= d - c; l += 2)
					{
						int r = min (d, i - 1) - c;
						if ((l + d - c) / 2 < r) continue;
						int p = k + c + l;
						if (k + 1 + d == n)
						{
							if (k - 1 - d - n + p <= 1)
							{
								if (ans < g[i][j] + k - 2)
								{
									ans = g[i][j] + k - 2;
									ansrec = (REC) {i, j, k, l, 1};
								}
							}
							else if (g[max (2, i - d - n + p)][k - 1 - d - n + p] < g[i][j] + d + n - p)
							{
								g[max (2, i - d - n + p)][k - 1 - d - n + p] = g[i][j] + d + n - p;
								recs[max (2, i - d - n + p)][k - 1 - d - n + p] = (REC) {i, j, k, l, 1};
							}
						}
						else
						{
							if (k + 1 + d + p - 1 >= n)
							{
								if (ans < g[i][j] + n - k - 1)
								{
									ans = g[i][j] + n - k - 1;
									ansrec = (REC) {i, j, k, l, 1};
								}
							}
							else if (g[k + 1 + d + p - 1][min (n - 1, j + d + p - 1)] < g[i][j] + d + p - 1)
							{
								g[k + 1 + d + p - 1][min (n - 1, j + d + p - 1)] = g[i][j] + d + p - 1;
								recs[k + 1 + d + p - 1][min (n - 1, j + d + p - 1)] = (REC) {i, j, k, l, 1};
							}
						}
					}
				}
				if (k == i)
				{
					if (k + k + 1 - 1 >= n)
					{
						if (ans < g[i][j] + n - k - 1)
						{
							ans = g[i][j] + n - k - 1;
							ansrec = (REC) {i, j, k, 0, 0};
						}
					}
					else if (g[k + k + 1 - 1][min (n - 1, j + k - 1)] < g[i][j] + k - 1)
					{
						g[k + k + 1 - 1][min (n - 1, j + k - 1)] = g[i][j] + k - 1;
						recs[k + k + 1 - 1][min (n - 1, j + k - 1)] = (REC) {i, j, k, 0, 0};
					}
				}
				if (k == j)
				{
					if (k + k - 1 - n <= 1)
					{
						if (ans < g[i][j] + k - 2)
						{
							ans = g[i][j] + k - 2;
							ansrec = (REC) {i, j, k, 0, 1};
						}
					}
					else if (g[max (2, i - n + k)][k + k - 1 - n] < g[i][j] + n - k)
					{
						g[max (2, i - n + k)][k + k - 1 - n] = g[i][j] + n - k;
						recs[max (2, i - n + k)][k + k - 1 - n] = (REC) {i, j, k, 0, 1};
					}
				}
			}
		}
	for (int i = 2; i <= n - 2; i++)
	{
		if (ans < g[i][i + 1] + min (i - 1, n - i - 1))
		{
			ans = g[i][i + 1] + min (i - 1, n - i - 1);
			ansrec = recs[i][i + 1];
		}
	}
	for (int i = 2; i <= n - 1; i++)
	{
		if (ans < g[i][i])
		{
			ans = g[i][i];
			ansrec = recs[i][i];
		}
	}
	stack <REC> st;
	REC cur = ansrec;
	while (cur.k)
	{
		st.push(cur);
		cur = recs[cur.i][cur.j];
	}
	int cl = 2, cr = n - 1, lf = n - 2, llf = 1;
	while (!st.empty())
	{
		int nc = 0;
		cur = st.top();
		st.pop();
		if (cur.k == cur.i)
		{
			arr[cl] = lf, cl++, lf--;
			if (cur.k + cur.k + 1 - 1 < n) nc = min (n - 1, cur.j + cur.k - 1) - (cur.k + cur.k + 1 - 1) + 1;
			for (int i = cl, j = 1; i <= cr; i++, j++)
				if (j > nc) arr[i] = lf, lf--;
			cr = cl + nc - 1;
			continue;
		}
		if (cur.k == cur.j)
		{
			arr[cr] = lf, cr--, lf--;
			if (cur.k + cur.k - 1 - n) nc = cur.k + cur.k - 1 - n - max (2, cur.i - n + cur.k) + 1;
			for (int i = cr, j = 1; i >= cl; i--, j++)
				if (j > nc) arr[i] = lf, lf--;
			cl = cr - nc + 1;
			continue;
		}
		int d = min (cur.k - 2, n - cur.k - 1);
		int c = min (cur.i - 1, n - cur.j);
		int rt = (cur.l + d - c) / 2;
		int lt = d - c - rt;
		int ck = cl + cur.k - cur.i;
		int p;
		arr[ck] = lf, lf--;
		if (cur.w == 0)
		{
			p = cur.k - c + cur.l;
			if (cur.i - 1 < n - cur.j && cur.k - 2 < n - cur.k - 1)
			{
				if (cur.k + 1 + d + p - 1 < n) nc = min (n - 1, cur.j + d + p - 1) - (cur.k + 1 + d + p - 1) + 1;
				for (int i = ck + 1, j = 1; i <= cr; i++, j++)
					if (j > nc)
					{
						if (cur.k + j + c <= n - lt - 1) arr[i] = llf, llf++;
						else arr[i] = lf, lf--;
					}
				for (int i = ck - 1; i >= cl; i--)
				{
					if (rt) arr[i] = lf, lf--;
					else arr[i] = llf, llf++;
				}
				cl = ck + 1, cr = cl + nc - 1;
			}
			if (cur.i - 1 < n - cur.j && cur.k - 2 >= n - cur.k - 1)
			{
				for (int i = d - c, j = 1; i >= lt + 2; i--, j++)
					arr[ck + j] = llf, llf++;
				for (int j = d - c + 1 - lt; ck + j <= cr; j++)
					arr[ck + j] = lf, lf--;
				for (int i = 0; i <= d - c; i++)
					arr[cl] = lf, cl++, lf--;
				cr = ck - 1;
				if (cur.k - 1 - d - n + p > 1) nc = cur.k - 1 - d - n + p - max (2, cur.i - d - n + p) + 1;
				for (int i = cr, j = 1; i >= cl; i--, j++)
					if (j > nc) arr[i] = lf, lf--;
				cl = cr - nc + 1;
			}
			if (cur.i - 1 >= n - cur.j && cur.k - 2 < n - cur.k - 1)
			{
				for (int i = 0; i <= lt; i++)
					arr[cr] = lf, cr--, lf--;
				for (int i = lt + 1; i <= d - c; i++)
					arr[cr] = llf, cr--, llf++;
				for (int i = ck - 1; i >= cl; i--)
					arr[i] = lf, lf--;
				cl = ck + 1;
				if (cur.k + 1 + d + p - 1 < n) nc = min (n - 1, cur.j + d + p - 1) - (cur.k + 1 + d + p - 1) + 1;
				for (int i = cl, j = 1; i <= cr; i++, j++)
					if (j > nc) arr[i] = lf, lf--;
				cr = cl + nc - 1;
			}
			if (cur.i - 1 >= n - cur.j && cur.k - 2 >= n - cur.k - 1)
			{
				for (int i = 0; i <= lt; i++)
					arr[cr] = lf, cr--, lf--;
				for (int i = lt + 1; i <= d - c; i++)
					arr[cr] = llf, cr--, llf++;
				cr = ck - 1;
				if (cur.k - 1 - d - n + p > 1) nc = cur.k - 1 - d - n + p - max (2, cur.i - d - n + p) + 1;
				for (int i = cr, j = 1; i >= cl; i--, j++)
					if (j > nc) arr[i] = lf, lf--;
				cl = cr - nc + 1;
			}
		}
		if (cur.w == 1)
		{
			p = cur.k + c + cur.l;
			if (cur.i - 1 < n - cur.j && cur.k - 2 < n - cur.k - 1)
			{
				for (int i = 0; i <= rt; i++)
					arr[cl] = lf, cl++, lf--;
				for (int i = rt + 1; i <= d - c; i++)
					arr[cl] = llf, cl++, llf++;
				cl = ck + 1;
				if (cur.k + 1 + d + p - 1 < n) nc = min (n - 1, cur.j + d + p - 1) - (cur.k + 1 + d + p - 1) + 1;
				for (int i = cl, j = 1; i <= cr; i++, j++)
					if (j > nc) arr[i] = lf, lf--;
				cr = cl + nc - 1;
			}
			if (cur.i - 1 < n - cur.j && cur.k - 2 >= n - cur.k - 1)
			{
				for (int i = 0; i <= rt; i++)
					arr[cl] = lf, cl++, lf--;
				for (int i = ck + 1; i <= cr; i++)
					arr[i] = lf, lf--;
				for (int i = rt + 1; i <= d - c; i++)
					arr[cl] = llf, cl++, llf++;
				cr = ck - 1;
				if (cur.k - 1 - d - n + p > 1) nc = cur.k - 1 - d - n + p - max (2, cur.i - d - n + p) + 1;
				for (int i = cr, j = 1; i >= cl; i--, j++)
					if (j > nc) arr[i] = lf, lf--;
				cl = cr - nc + 1;
			}
			if (cur.i - 1 >= n - cur.j && cur.k - 2 < n - cur.k - 1)
			{
				for (int i = d - c, j = 1; i >= rt + 2; i--, j++)
					arr[ck - j] = llf, llf++;
				for (int j = d - c + 1 - rt; ck - j >= cl; j++)
					arr[ck - j] = lf, lf--;
				for (int i = 0; i <= d - c; i++)
					arr[cr] = lf, cr--, lf--;
				cl = ck + 1;
				if (cur.k + 1 + d + p - 1 < n) nc = min (n - 1, cur.j + d + p - 1) - (cur.k + 1 + d + p - 1) + 1;
				for (int i = cl, j = 1; i <= cr; i++, j++)
					if (j > nc) arr[i] = lf, lf--;
				cr = cl + nc - 1;
			}
			if (cur.i - 1 >= n - cur.j && cur.k - 2 >= n - cur.k - 1)
			{
				if (cur.k - 1 - d - n + p > 1) nc = cur.k - 1 - d - n + p - max (2, cur.i - d - n + p) + 1;
				for (int i = ck - 1, j = 1; i >= cl; i--, j++)
					if (j > nc)
					{
						if (cur.k - j - c >= rt + 2) arr[i] = llf, llf++;
						else arr[i] = lf, lf--;
					}
				for (int i = ck + 1; i <= cr; i++)
				{
					if (lt) arr[i] = lf, lf--;
					else arr[i] = llf, llf++;
				}
				cr = ck - 1, cl = cr - nc + 1;
			}
		}
	}
	for (int i = 1; i <= n; i++)
	{
		if (!arr[i]) arr[i] = llf, llf++;
		cout << arr[i] << ' ';
	}
	return 0;
}
```

# Part 3

~~放一个你们估计喜闻乐见的东西！~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100 + 12;
const string ans[N] =
{
"",
"1",
"1 2",
"2 1 3",
"3 1 2 4",
"4 1 3 2 5",
"5 2 4 1 3 6",
"6 4 2 3 1 5 7",
"7 5 3 4 2 1 6 8",
"8 6 5 3 1 2 4 7 9",
"9 7 6 3 1 4 2 5 8 10",
"10 9 6 3 1 2 5 4 7 8 11",
"11 9 8 1 6 3 4 2 5 7 10 12",
"12 10 9 6 7 2 3 1 5 4 8 11 13",
"13 12 9 5 6 2 3 1 4 8 7 10 11 14",
"14 12 11 8 9 5 2 3 1 4 7 6 10 13 15",
"15 13 12 9 10 6 3 4 2 1 5 8 7 11 14 16",
"16 15 12 8 9 6 3 4 2 5 1 7 11 10 13 14 17",
"17 15 14 11 12 8 1 6 3 4 2 5 7 10 9 13 16 18",
"18 16 15 12 13 9 7 5 3 2 4 1 6 8 11 10 14 17 19",
"19 18 15 11 12 9 7 2 3 1 6 4 5 8 10 14 13 16 17 20",
"20 19 16 12 13 10 8 4 2 3 1 6 5 7 9 11 15 14 17 18 21",
"21 19 18 15 16 12 10 8 6 7 2 3 1 5 4 9 11 14 13 17 20 22",
"22 20 19 16 17 13 11 9 7 8 2 3 1 6 4 5 10 12 15 14 18 21 23",
"23 22 19 15 16 13 11 6 7 4 2 3 1 5 9 8 10 12 14 18 17 20 21 24",
"24 22 21 18 19 15 13 11 9 10 6 2 3 1 5 4 8 7 12 14 17 16 20 23 25",
"25 24 21 17 18 15 13 8 9 5 6 2 3 1 4 7 11 10 12 14 16 20 19 22 23 26",
"26 24 23 20 21 17 15 13 11 12 8 5 2 3 1 4 7 6 10 9 14 16 19 18 22 25 27",
"27 25 24 21 22 18 16 14 12 13 9 7 3 4 2 6 5 8 11 1 10 15 17 20 19 23 26 28",
"28 26 25 22 23 19 17 15 13 14 10 7 5 3 1 2 4 6 9 8 12 11 16 18 21 20 24 27 29",
"29 27 26 23 24 20 18 16 14 15 11 8 6 4 2 3 1 5 7 10 9 13 12 17 19 22 21 25 28 30",
"30 29 26 22 23 20 18 13 14 10 11 8 6 3 1 2 5 4 7 9 12 16 15 17 19 21 25 24 27 28 31",
"31 30 27 23 24 21 19 14 15 11 12 9 7 4 2 3 1 6 5 8 10 13 17 16 18 20 22 26 25 28 29 32",
"32 30 29 26 27 23 21 19 17 18 14 11 9 6 7 3 1 2 5 4 8 10 13 12 16 15 20 22 25 24 28 31 33",
"33 31 30 27 28 24 22 20 18 19 15 12 10 7 8 3 1 4 2 6 5 9 11 14 13 17 16 21 23 26 25 29 32 34",
"34 32 31 28 29 25 23 21 19 20 16 13 11 8 9 6 4 2 3 5 7 10 1 12 15 14 18 17 22 24 27 26 30 33 35",
"35 34 31 27 28 25 23 18 19 15 16 13 11 7 1 8 4 2 3 6 5 10 9 12 14 17 21 20 22 24 26 30 29 32 33 36",
"36 35 32 28 29 26 24 19 20 16 17 14 12 10 6 7 4 2 3 5 9 8 11 13 1 15 18 22 21 23 25 27 31 30 33 34 37",
"37 35 34 31 32 28 26 24 22 23 19 16 14 11 12 7 8 4 2 3 6 5 10 1 9 13 15 18 17 21 20 25 27 30 29 33 36 38",
"38 36 35 32 33 29 27 25 23 24 20 17 1 15 13 10 11 7 3 4 2 6 5 9 8 12 14 16 19 18 22 21 26 28 31 30 34 37 39",
"39 38 35 31 32 29 27 22 23 19 20 17 15 13 9 10 6 7 3 4 2 5 8 12 11 14 16 1 18 21 25 24 26 28 30 34 33 36 37 40",
"40 38 37 34 35 31 29 27 25 26 22 19 1 17 15 12 13 8 6 4 2 3 5 7 11 9 10 14 16 18 21 20 24 23 28 30 33 32 36 39 41",
"41 40 37 33 34 31 29 24 25 21 22 19 1 17 14 12 9 7 8 3 4 2 6 5 11 10 13 16 15 18 20 23 27 26 28 30 32 36 35 38 39 42",
"42 41 38 34 35 32 30 25 26 22 23 20 18 16 12 13 9 10 7 4 5 2 3 6 8 11 15 14 17 19 1 21 24 28 27 29 31 33 37 36 39 40 43",
"43 42 39 35 36 33 31 26 27 23 24 21 1 19 16 14 11 9 10 6 3 4 2 5 8 7 13 12 15 18 17 20 22 25 29 28 30 32 34 38 37 40 41 44",
"44 42 41 38 39 35 33 31 29 30 26 23 1 21 19 16 17 13 10 8 4 5 3 7 6 9 2 12 11 15 14 18 20 22 25 24 28 27 32 34 37 36 40 43 45",
"45 43 42 39 40 36 34 32 30 31 27 24 22 19 20 15 16 9 10 6 7 2 3 1 5 4 8 12 11 14 13 18 17 21 23 26 25 29 28 33 35 38 37 41 44 46",
"46 45 42 38 39 36 34 29 30 26 27 24 22 18 19 14 15 12 13 9 5 6 2 3 1 4 8 7 11 10 17 16 21 20 23 25 28 32 31 33 35 37 41 40 43 44 47",
"47 46 43 39 40 37 35 30 31 27 28 25 23 21 17 18 14 15 12 10 8 9 3 4 2 6 5 7 11 13 16 20 19 22 24 1 26 29 33 32 34 36 38 42 41 44 45 48",
"48 46 45 42 43 39 37 35 33 34 30 27 1 25 23 20 21 17 14 12 8 6 7 3 4 2 5 10 9 11 13 16 15 19 18 22 24 26 29 28 32 31 36 38 41 40 44 47 49",
"49 48 45 41 42 39 37 32 33 29 30 27 25 23 19 20 16 17 14 12 10 11 6 3 4 2 5 8 7 9 13 15 18 22 21 24 26 1 28 31 35 34 36 38 40 44 43 46 47 50",
"50 48 47 44 45 41 39 37 35 36 32 29 1 27 25 22 23 19 16 14 11 9 7 8 4 5 3 6 10 13 12 15 2 18 17 21 20 24 26 28 31 30 34 33 38 40 43 42 46 49 51",
"51 49 48 45 46 42 40 38 36 37 33 30 1 28 26 23 24 20 17 15 11 6 7 3 4 2 5 9 8 10 14 12 13 16 19 18 22 21 25 27 29 32 31 35 34 39 41 44 43 47 50 52",
"52 50 49 46 47 43 41 39 37 38 34 31 1 29 27 24 25 21 18 16 13 11 9 10 7 4 5 3 6 8 12 15 14 17 2 20 19 23 22 26 28 30 33 32 36 35 40 42 45 44 48 51 53",
"53 51 50 47 48 44 42 40 38 39 35 32 1 30 28 25 26 22 19 2 17 13 10 11 7 8 5 3 4 6 9 12 15 14 16 18 21 20 24 23 27 29 31 34 33 37 36 41 43 46 45 49 52 54",
"54 52 51 48 49 45 43 41 39 40 36 33 1 31 29 26 27 23 20 18 14 9 10 7 5 3 4 2 6 8 12 11 13 17 15 16 19 22 21 25 24 28 30 32 35 34 38 37 42 44 47 46 50 53 55",
"55 53 52 49 50 46 44 42 40 41 37 34 1 32 30 27 28 24 21 19 16 14 12 13 3 10 8 5 6 4 7 9 11 15 18 17 20 2 23 22 26 25 29 31 33 36 35 39 38 43 45 48 47 51 54 56",
"56 54 53 50 51 47 45 43 41 42 38 35 1 33 31 28 29 25 22 20 16 11 12 9 6 7 3 4 2 5 8 10 14 13 15 19 17 18 21 24 23 27 26 30 32 34 37 36 40 39 44 46 49 48 52 55 57",
"57 56 53 49 50 47 45 40 41 37 38 35 33 31 27 28 24 25 22 19 18 20 16 14 15 11 9 6 3 4 2 5 8 7 10 13 12 17 21 23 26 30 29 32 34 1 36 39 43 42 44 46 48 52 51 54 55 58",
"58 56 55 52 53 49 47 45 43 44 40 37 1 35 33 30 31 27 24 22 18 13 14 11 8 9 6 3 4 2 5 7 10 12 16 15 17 21 19 20 23 26 25 29 28 32 34 36 39 38 42 41 46 48 51 50 54 57 59",
"59 58 55 51 52 49 47 42 43 39 40 37 35 33 29 30 26 27 24 21 20 22 18 16 17 13 11 8 6 3 4 2 5 7 10 9 12 15 14 19 23 25 28 32 31 34 36 1 38 41 45 44 46 48 50 54 53 56 57 60",
"60 58 57 54 55 51 49 47 45 46 42 39 37 34 35 30 31 24 25 21 22 17 14 15 10 11 5 6 3 1 2 4 8 7 9 13 12 16 20 18 19 23 27 26 29 28 33 32 36 38 41 40 44 43 48 50 53 52 56 59 61",
"61 59 58 55 56 52 50 48 46 47 43 40 1 38 36 33 34 30 27 25 21 16 17 14 11 12 2 9 7 4 5 3 6 8 10 13 15 19 18 20 24 22 23 26 29 28 32 31 35 37 39 42 41 45 44 49 51 54 53 57 60 62",
"62 60 59 56 57 53 51 49 47 48 44 41 1 39 37 34 35 31 28 26 22 17 18 15 12 13 10 8 5 6 3 4 2 7 9 11 14 16 20 19 21 25 23 24 27 30 29 33 32 36 38 40 43 42 46 45 50 52 55 54 58 61 63",
"63 62 59 55 56 53 51 46 47 43 44 41 39 37 33 34 30 31 28 25 24 26 22 20 21 17 15 12 10 8 4 2 3 6 5 7 9 11 14 13 16 19 18 23 27 29 32 36 35 38 40 1 42 45 49 48 50 52 54 58 57 60 61 64",
"64 63 60 56 57 54 52 47 48 44 45 42 40 38 34 35 31 32 2 29 26 27 24 20 18 16 14 10 8 5 6 4 7 9 12 11 13 15 17 19 3 22 21 23 25 28 30 33 37 36 39 41 1 43 46 50 49 51 53 55 59 58 61 62 65",
"65 63 62 59 60 56 54 52 50 51 47 44 42 39 40 35 36 29 30 26 27 22 19 20 15 16 10 11 7 8 2 3 1 5 4 6 9 13 12 14 18 17 21 25 23 24 28 32 31 34 33 38 37 41 43 46 45 49 48 53 55 58 57 61 64 66",
"66 64 63 60 61 57 55 53 51 52 48 45 1 43 41 38 39 35 32 30 26 21 22 19 16 17 14 12 10 8 7 9 3 4 2 6 5 11 13 15 18 20 24 23 25 29 27 28 31 34 33 37 36 40 42 44 47 46 50 49 54 56 59 58 62 65 67",
"67 66 63 59 60 57 55 50 51 47 48 45 43 41 37 38 34 35 2 32 29 30 27 23 21 19 17 13 11 9 6 7 4 5 8 10 12 15 14 16 18 20 22 3 25 24 26 28 31 33 36 40 39 42 44 1 46 49 53 52 54 56 58 62 61 64 65 68",
"68 66 65 62 63 59 57 55 53 54 50 47 1 45 43 40 41 37 34 32 28 23 24 21 18 19 16 2 14 11 12 8 9 6 4 5 3 7 10 13 15 17 20 22 26 25 27 31 29 30 33 36 35 39 38 42 44 46 49 48 52 51 56 58 61 60 64 67 69",
"69 68 65 61 62 59 57 52 53 49 50 47 45 43 39 40 36 37 34 31 30 32 28 26 27 23 21 18 16 14 12 7 8 5 3 4 6 10 9 11 13 15 17 2 20 19 22 25 24 29 33 35 38 42 41 44 46 1 48 51 55 54 56 58 60 64 63 66 67 70",
"70 69 66 62 63 60 58 53 54 50 51 48 46 44 40 41 37 38 35 32 31 33 29 27 28 24 22 19 17 15 12 9 6 4 5 3 8 7 11 10 14 13 16 2 18 21 20 23 26 25 30 34 36 39 43 42 45 47 1 49 52 56 55 57 59 61 65 64 67 68 71",
"71 69 68 65 66 62 60 58 56 57 53 50 1 48 46 43 44 40 37 35 31 26 27 24 21 22 2 19 17 15 13 11 12 8 4 5 3 7 6 10 9 14 16 18 20 23 25 29 28 30 34 32 33 36 39 38 42 41 45 47 49 52 51 55 54 59 61 64 63 67 70 72",
"72 70 69 66 67 63 61 59 57 58 54 51 49 46 47 42 43 36 37 33 34 29 26 27 22 23 17 18 14 15 8 9 5 3 1 2 4 7 6 12 10 11 13 16 20 19 21 25 24 28 32 30 31 35 39 38 41 40 45 44 48 50 53 52 56 55 60 62 65 64 68 71 73",
"73 72 69 65 66 63 61 56 57 53 54 51 49 47 43 44 40 41 2 38 35 36 33 29 27 25 23 19 17 4 15 12 13 10 8 6 7 5 9 11 14 16 18 21 20 22 24 26 28 3 31 30 32 34 37 39 42 46 45 48 50 1 52 55 59 58 60 62 64 68 67 70 71 74",
"74 72 71 68 69 65 63 61 59 60 56 53 1 51 49 46 47 43 40 38 34 29 30 27 24 25 2 22 20 18 16 14 15 3 11 8 5 6 4 7 10 9 13 12 17 19 21 23 26 28 32 31 33 37 35 36 39 42 41 45 44 48 50 52 55 54 58 57 62 64 67 66 70 73 75",
"75 74 71 67 68 65 63 58 59 55 56 53 51 49 45 46 42 43 40 37 36 38 34 32 33 29 27 24 22 20 15 16 11 8 9 4 5 3 7 6 10 13 12 14 2 18 17 19 21 23 26 25 28 31 30 35 39 41 44 48 47 50 52 1 54 57 61 60 62 64 66 70 69 72 73 76",
"76 74 73 70 71 67 65 63 61 62 58 55 1 53 51 48 49 45 42 40 36 31 32 29 26 27 2 24 22 20 18 16 17 3 13 10 8 5 6 4 7 9 12 11 15 14 19 21 23 25 28 30 34 33 35 39 37 38 41 44 43 47 46 50 52 54 57 56 60 59 64 66 69 68 72 75 77",
"77 76 73 69 70 67 65 60 61 57 58 55 53 51 47 48 44 45 42 39 38 40 36 34 35 31 29 26 24 22 17 18 13 10 11 7 5 3 4 6 9 8 12 15 14 16 2 20 19 21 23 25 28 27 30 33 32 37 41 43 46 50 49 52 54 1 56 59 63 62 64 66 68 72 71 74 75 78",
"78 76 75 72 73 69 67 65 63 64 60 57 1 55 53 50 51 47 44 42 39 37 35 36 3 33 31 29 27 25 26 23 21 19 16 14 11 6 7 5 9 8 10 13 12 15 18 17 20 4 22 24 28 30 32 34 38 41 40 43 2 46 45 49 48 52 54 56 59 58 62 61 66 68 71 70 74 77 79",
"79 77 76 73 74 70 68 66 64 65 61 58 1 56 54 51 52 48 45 43 39 34 35 32 29 30 2 27 25 23 21 19 20 3 16 13 11 9 7 5 6 4 8 10 12 15 14 18 17 22 24 26 28 31 33 37 36 38 42 40 41 44 47 46 50 49 53 55 57 60 59 63 62 67 69 72 71 75 78 80",
"80 78 77 74 75 71 69 67 65 66 62 59 1 57 55 52 53 49 46 44 40 35 36 33 30 31 28 26 24 22 23 2 19 17 18 15 11 12 9 6 4 5 3 8 7 10 14 13 16 21 20 25 27 29 32 34 38 37 39 43 41 42 45 48 47 51 50 54 56 58 61 60 64 63 68 70 73 72 76 79 81",
"81 79 78 75 76 72 70 68 66 67 63 60 1 58 56 53 54 50 47 45 41 36 37 34 31 32 2 29 27 25 23 21 22 3 18 15 13 11 8 9 6 4 5 7 10 12 14 17 16 20 19 24 26 28 30 33 35 39 38 40 44 42 43 46 49 48 52 51 55 57 59 62 61 65 64 69 71 74 73 77 80 82",
"82 81 78 74 75 72 70 65 66 62 63 60 58 56 52 53 49 50 47 44 43 45 41 39 40 36 34 31 29 27 25 20 21 17 18 15 10 11 8 5 6 4 7 9 13 12 14 16 3 19 23 22 24 26 28 30 2 33 32 35 38 37 42 46 48 51 55 54 57 59 1 61 64 68 67 69 71 73 77 76 79 80 83",
"83 82 79 75 76 73 71 66 67 63 64 61 59 57 53 54 50 51 48 45 44 46 42 40 41 37 35 32 30 28 26 21 22 18 19 16 14 12 9 6 4 5 8 7 11 10 13 15 17 20 3 24 23 25 27 29 31 2 34 33 36 39 38 43 47 49 52 56 55 58 60 1 62 65 69 68 70 72 74 78 77 80 81 84",
"84 82 81 78 79 75 73 71 69 70 66 63 1 61 59 56 57 53 50 48 44 39 40 37 34 35 2 32 30 28 26 24 25 3 21 18 4 16 14 12 9 10 6 7 5 8 11 13 15 17 20 19 23 22 27 29 31 33 36 38 42 41 43 47 45 46 49 52 51 55 54 58 60 62 65 64 68 67 72 74 77 76 80 83 85",
"85 83 82 79 80 76 74 72 70 71 67 64 1 62 60 57 58 54 51 49 45 40 41 38 35 36 2 33 31 29 27 25 26 3 22 19 17 15 12 13 9 10 5 6 4 8 7 11 14 16 18 21 20 24 23 28 30 32 34 37 39 43 42 44 48 46 47 50 53 52 56 55 59 61 63 66 65 69 68 73 75 78 77 81 84 86",
"86 85 82 78 79 76 74 69 70 66 67 64 62 60 56 57 53 54 51 48 47 49 45 43 44 40 38 35 33 31 29 24 25 21 22 19 17 15 12 8 9 5 6 4 7 11 10 14 13 16 18 20 23 3 27 26 28 30 32 34 2 37 36 39 42 41 46 50 52 55 59 58 61 63 1 65 68 72 71 73 75 77 81 80 83 84 87",
"87 85 84 81 82 78 76 74 72 73 69 66 1 64 62 59 60 56 53 51 47 42 43 40 37 38 2 35 33 31 29 27 28 3 24 21 19 17 14 15 11 12 8 6 4 5 7 10 9 13 16 18 20 23 22 26 25 30 32 34 36 39 41 45 44 46 50 48 49 52 55 54 58 57 61 63 65 68 67 71 70 75 77 80 79 83 86 88",
"88 86 85 82 83 79 77 75 73 74 70 67 1 65 63 60 61 57 54 52 48 43 44 41 38 39 2 36 34 32 30 28 29 3 25 22 20 18 15 16 12 13 9 7 5 6 4 8 11 10 14 17 19 21 24 23 27 26 31 33 35 37 40 42 46 45 47 51 49 50 53 56 55 59 58 62 64 66 69 68 72 71 76 78 81 80 84 87 89",
"89 88 85 81 82 79 77 72 73 69 70 67 65 63 59 60 56 57 54 51 50 52 48 46 47 43 41 38 36 34 32 27 28 24 25 22 17 18 15 13 10 11 8 6 4 5 7 9 12 14 16 20 19 21 23 3 26 30 29 31 33 35 37 2 40 39 42 45 44 49 53 55 58 62 61 64 66 1 68 71 75 74 76 78 80 84 83 86 87 90",
"90 88 87 84 85 81 79 77 75 76 72 69 1 67 65 62 63 59 56 54 50 45 46 43 40 41 2 38 36 34 32 30 31 3 27 24 22 20 17 18 14 15 11 8 9 5 6 4 7 10 13 12 16 19 21 23 26 25 29 28 33 35 37 39 42 44 48 47 49 53 51 52 55 58 57 61 60 64 66 68 71 70 74 73 78 80 83 82 86 89 91",
"91 90 87 83 84 81 79 74 75 71 72 69 67 65 61 62 58 59 56 53 52 54 50 48 49 45 43 40 38 36 34 29 30 26 27 24 22 20 17 13 14 11 8 5 6 4 7 10 9 12 16 15 19 18 21 23 25 28 3 32 31 33 35 37 39 2 42 41 44 47 46 51 55 57 60 64 63 66 68 1 70 73 77 76 78 80 82 86 85 88 89 92",
"92 90 89 86 87 83 81 79 77 78 74 71 1 69 67 64 65 61 58 56 52 47 48 45 42 43 2 40 38 36 34 32 33 3 29 26 24 22 19 20 16 17 13 10 11 8 5 6 4 7 9 12 15 14 18 21 23 25 28 27 31 30 35 37 39 41 44 46 50 49 51 55 53 54 57 60 59 63 62 66 68 70 73 72 76 75 80 82 85 84 88 91 93",
"93 92 89 85 86 83 81 76 77 73 74 71 69 67 63 64 60 61 58 55 54 56 52 50 51 47 45 42 40 38 36 31 32 28 29 26 24 22 19 15 16 13 10 8 6 4 5 7 9 12 11 14 18 17 21 20 23 25 27 30 3 34 33 35 37 39 41 2 44 43 46 49 48 53 57 59 62 66 65 68 70 1 72 75 79 78 80 82 84 88 87 90 91 94",
"94 93 90 86 87 84 82 77 78 74 75 72 70 68 64 65 61 62 59 56 55 57 53 51 52 48 46 43 41 39 37 32 33 29 30 27 25 23 20 16 17 14 11 9 7 5 6 4 8 10 13 12 15 19 18 22 21 24 26 28 31 3 35 34 36 38 40 42 2 45 44 47 50 49 54 58 60 63 67 66 69 71 1 73 76 80 79 81 83 85 89 88 91 92 95",
"95 93 92 89 90 86 84 82 80 81 77 74 1 72 70 67 68 64 61 59 55 50 51 48 45 46 2 43 41 39 37 35 36 3 32 29 27 25 22 23 19 20 16 13 14 11 9 5 6 4 8 7 10 12 15 18 17 21 24 26 28 31 30 34 33 38 40 42 44 47 49 53 52 54 58 56 57 60 63 62 66 65 69 71 73 76 75 79 78 83 85 88 87 91 94 96",
"96 95 92 88 89 86 84 79 80 76 77 74 72 70 66 67 63 64 61 58 57 59 55 53 54 50 48 45 43 41 39 34 35 31 32 29 27 25 22 18 19 16 13 11 8 9 5 6 4 7 10 12 15 14 17 21 20 24 23 26 28 30 33 3 37 36 38 40 42 44 2 47 46 49 52 51 56 60 62 65 69 68 71 73 1 75 78 82 81 83 85 87 91 90 93 94 97",
"97 95 94 91 92 88 86 84 82 83 79 76 1 74 72 69 70 66 63 61 57 52 53 50 47 48 2 45 43 41 39 37 38 3 34 31 29 27 24 25 21 22 18 15 16 13 11 8 6 4 5 7 10 9 12 14 17 20 19 23 26 28 30 33 32 36 35 40 42 44 46 49 51 55 54 56 60 58 59 62 65 64 68 67 71 73 75 78 77 81 80 85 87 90 89 93 96 98",
"98 96 95 92 93 89 87 85 83 84 80 77 1 75 73 70 71 67 64 62 58 53 54 51 48 49 2 46 44 42 40 38 39 3 35 32 30 28 25 26 22 23 19 16 17 14 12 9 7 5 6 4 8 11 10 13 15 18 21 20 24 27 29 31 34 33 37 36 41 43 45 47 50 52 56 55 57 61 59 60 63 66 65 69 68 72 74 76 79 78 82 81 86 88 91 90 94 97 99",
"99 97 96 93 94 90 88 86 84 85 81 78 1 76 74 71 72 68 65 63 59 54 55 52 49 50 2 47 45 43 41 39 40 3 36 33 31 29 26 27 23 24 20 17 18 15 13 9 10 6 7 5 8 12 11 14 4 16 19 22 21 25 28 30 32 35 34 38 37 42 44 46 48 51 53 57 56 58 62 60 61 64 67 66 70 69 73 75 77 80 79 83 82 87 89 92 91 95 98 100"
};
int main()
{
    int n;
    cin >> n;
    cout << ans[n];
    return 0;
}
```

# Part 4

接下来给出验题人 [irris](https://www.luogu.com.cn/user/419487) 所写的 SPJ：

```cpp
#include "testlib.h"
#include <bits/stdc++.h>
#define MAXN 111
int pa[MAXN], ja[MAXN];
bool perm[MAXN];
bool checkPerm(int *a, int N) {
	memset (perm, 0, sizeof perm);
	for (int i = 1; i <= N; ++i)
	    perm[a[i]] = true;
	for (int i = 1; i <= N; ++i)
	    if (!perm[i]) return false;
	return true;
}
int getCnt(int *a, int N) {
	int cnt = 0;
	while (true) {
		a[1] = a[N] = 0;
		int m1 = 0, p1 = 0, m2 = 0, p2 = 0;
		for (int i = 1; i <= N; ++i)
			if (a[i] > m1) m1 = a[i], p1 = i;
		for (int i = 1; i <= N; ++i)
			if (a[i] > m2 && i != p1) m2 = a[i], p2 = i;
		if (p1 == 0 || p2 == 0) break;
		for (int i = 1; i < p1; ++i) a[i] = a[i + 1];
		for (int i = N - 1; i > p1; --i) a[i + 1] = a[i];
		a[p1 - 1] = a[p1 + 1] = 0;
		a[p1 < p2 ? p1 - 1 : p1 + 1] = a[p1], a[p1] = 0;
		int lf = 0;
		for (int i = 1; i <= N; ++i) lf += (a[i] != 0);
		if (lf <= 1) break;
		++cnt;
	}
	return cnt;
}
int main(int argc, char* argv[]) {
    registerTestlibCmd(argc, argv);
	int N = inf.readInt();
	for (int i = 1; i <= N; ++i) ja[i] = ans.readInt(1, N);
	for (int i = 1; i <= N; ++i) pa[i] = ouf.readInt(1, N);
	if (!checkPerm(ja, N)) quitf(_fail, "The jury breaks down!");
	if (!checkPerm(pa, N)) quitf(_wa, "Your answer is invalid!");
	int J = getCnt(ja, N), P = getCnt(pa, N);
	if (P > J) quitf(_fail, "You beat the jury! (%02d\'%02d\" / %02d\'%02d\")", P / 60, P % 60, J / 60, J % 60);
	if (P == J) quitf(_ok, "Congratulations! (%02d\'%02d\" / %02d\'%02d\")", P / 60, P % 60, J / 60, J % 60);
	quitf(_wa, "Your answer is worse than the jury! (%02d\'%02d\" / %02d\'%02d\")", P / 60, P % 60, J / 60, J % 60);
}
```

这个 SPJ 是 $O(n^3)$ 的。~~感兴趣的可以帮我们写一写 $\sout{O(n)}$ 的 SPJ~~，做法与 std 类似。

# Part 5

但是，[xuanxuan001](https://www.luogu.com.cn/user/184168) 等人的题解指出：$l$ 不需要考虑，因为最大编号原子不会掉转方向。

此时的时间复杂度变成了 $O(n^3)$，就像这样：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100 + 12;
int g[N][N], arr[N], ans = -1;
struct REC
{
    int i;
    int j;
    int k;
};
REC recs[N][N], ansrec;
int main()
{
    int n;
    cin >> n;
    if (n == 1) cout << "1";
    if (n == 2) cout << "1 2";
    if (n <= 2) return 0;
    memset (g, -1, sizeof g);
    arr[1] = n - 1, arr[n] = n;
    recs[2][n - 1] = (REC) {1, n, 0}, g[2][n - 1] = 0;
    for (int len = n - 2; len >= 3; len--)
        for (int i = 2, j = 2 + len - 1; j <= n - 1; i++, j++)
            for (int k = i; k <= j - 1; k++)
            {
                if (g[i][j] == -1) continue;
                if (2 * k == n && ans < g[i][j] + k / 2 - 1)
                {
                    ans = g[i][j] + k / 2 - 1;
                    ansrec = (REC) {i, j, k};
                }
                if (2 * k < n && g[k + 1 + k - 1][min(n - 1, j + k - 1)] < g[i][j] + k - 1)
                {
                    g[k + 1 + k - 1][min(n - 1, j + k - 1)] = g[i][j] + k - 1;
                    recs[k + 1 + k - 1][min(n - 1, j + k - 1)] = (REC) {i, j, k};
                }
                if (2 * k > n && g[max(2, i + k + 1 - n)][k + k + 1 - n] < g[i][j] + n - k - 1)
                {
                    g[max(2, i + k + 1 - n)][k + k + 1 - n] = g[i][j] + n - k - 1;
                    recs[max(2, i + k + 1 - n)][k + k + 1 - n] = (REC) {i, j, k};
                }
            }
    for (int i = 2; i <= n - 2; i++)
    {
        if (ans < g[i][i + 1] + min(i - 1, n - i - 1))
        {
            ans = g[i][i + 1] + min(i - 1, n - i - 1);
            ansrec = recs[i][i + 1];
        }
    }
    for (int i = 2; i <= n - 1; i++)
    {
        if (ans < g[i][i])
        {
            ans = g[i][i];
            ansrec = recs[i][i];
        }
    }
    stack <REC> st;
    REC cur = ansrec;
    while (cur.k)
    {
        st.push(cur);
        cur = recs[cur.i][cur.j];
    }
    int cl = 2, cr = n - 1, lf = n - 2, llf = 1;
    while (!st.empty())
    {
        int nc = 0;
        cur = st.top();
        st.pop();
        int ck = cl + cur.k - cur.i;
        if (cur.k * 2 <= n)
        {
            arr[ck] = lf, lf--;
            for (int i = cl; i <= ck - 1; i++)
                arr[i] = llf, llf++;
            cl = ck + 1;
            for (int i = cr, j = cur.k + cur.j - 1; i >= ck + 1; i--, j--)
                if (j >= n) arr[cr] = lf, cr--, lf--;
        }
        else
        {
            arr[ck + 1] = lf, lf--;
            for (int i = ck + 2; i <= cr; i++)
                arr[i] = llf, llf++;
            cr = ck;
            for (int i = cl, j = cur.i + cur.k + 1 - n; i <= ck; i++, j++)
                if (j <= 1) arr[cl] = lf, cl++, lf--;
        }
    }
    for (int i = 1; i <= n; i++)
    {
        if (!arr[i]) arr[i] = llf, llf++;
        cout << arr[i] << ' ';
    }
    return 0;
}
```

数据证明了这一点。实际上，在上面的程序中，只考虑以下 $4$ 种情况也能 AC：

- $k=i$；
- $k=i+1$；
- $k=j-2$；
- $k=j-1$。

其中，即使只考虑 $k=i$ 和 $k=j-1$ 的 $2$ 种情况（贪心），也能得到 $35$ 分。

用以上情况代替 $k$  的循环，时间复杂度又变成了 $O(n^2)$。

# Part 6

下面有两句题外话：
- 出题人偶然发现，如果将最优解的瘫痪用时（$ans$）记为函数 $f(n)$，那么 $f(n)$ 有一个优秀的近似拟合：$f(n)\approx \dfrac{n^2}{7}$。例如，$f(50)=340\approx\dfrac{50^2}{7}=357$，$f(100)=1390\approx \dfrac{100^2}{7}=1429$。
- **我们可以重新定义 $g_{i,j}$ 中的 $i,j$ 为左端和右端的空结点个数（$g_{0,0}=0$，$n$ 不确定，最终状态为 $i+j=n-1/n$，其余类似）。**

最后的最后，来玩个大冒险吧：取一张纸条，然后以秒为单位，**接连**写下 $n=62$ 和 $n=97$ 时答案的瘫痪用时，第二天把纸条扔给你的同桌。~~看看你的同桌是什么反应，回来后在这里分享！~~

---

## 作者：Hanghang (赞：11)

好题！讲讲我自己场上的思路历程把。

首先把 $n\le 6$ 的部分分拿了。

手玩 $n=7,8,9,10$ 大概找到了些规律

>当前局面的最大值影响左右方向的断点，左边一定向左走，右边一定向右走
>
>每次一定是一坨点向一个方向移动，一个点向另一个方向移动。

 $n=8$ 得情况大概的贪心过程：

```cpp
a b c d e f g h -> 0 b c d e f g 0 #
b 0 0 c d e f g -> 0 0 0 c d e f 0 #
0 0 c d e 0 0 f -> 0 0 c d e 0 0 0 #
0 c 0 0 d e 0 0 -> 0 c 0 0 d e 0 0
c 0 0 0 0 d e 0 -> 0 0 0 0 0 d e 0 #
0 0 0 0 d 0 0 e -> 0 0 0 0 d 0 0 0
```

具体而言就是当遇到 ```#``` 局面（只有左右两侧有连续段 $0$ ），整体向 $0$ 多的那个方向移动，剩下一个往另一个方向移动。

要达成这一目标将剩下的这一个设置为当前局面最大值即可。

代码比较好写：（模拟每次遇到 `#` 局面左右两边零的个数即可）

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=1e6+3;
int n,a[N]; 
int main()
{
	cin>>n;a[n]=2;a[1]=1;
	int x=n,l=2,r=n-1,kl=1,kr=1;
	while(x>2)
	{
		if(kl<=kr)a[l]=x,l++,kr-=kl,kl=kl*2+1;
		else a[r]=x,r--,kl-=kr,kr=kr*2+1;
		x--;
	}
	for(int i=1;i<=n;i++)cout<<a[i]<<" ";
}
```

本以为直接过了，结果一看只有 `35` 分，看到除了 $n=12$ 其他小的点都过了，比较奇怪。

没办法，只有打个暴力先看看情况：

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=1e6+3;
int n,ans,a[N],b[N],k[N];
bool Chk()
{
	int mk=0;
	for(int i=2;i<n;i++)mk+=a[i]>0;
	return mk>=2; 
}
int Ans()
{
	int cnt=0;
	for(int i=1;i<=n;i++)a[i]=b[i];
	while(Chk())
	{
		a[1]=a[n]=0;int mx=0,z=0,fl=0;cnt++;
		for(int i=1;i<=n;i++)if(a[i]>a[mx])mx=i;
		for(int i=1;i<=n;i++)if(i!=mx)z=max(z,a[i]);
		for(int i=1;i<mx;i++)if(a[i]==z)fl=1;
		if(fl)
		{
			for(int i=1;i<mx-1;i++)a[i]=a[i+1];
			for(int i=n;i>mx;i--)a[i]=a[i-1];
			a[mx]=a[mx-1]=0;
		}
		else
		{
			for(int i=1;i<mx;i++)a[i]=a[i+1];
			for(int i=n;i>mx+1;i--)a[i]=a[i-1];
			a[mx]=a[mx+1]=0;
		}
	}
	return cnt;
}
int main()
{
	cin>>n;b[n]=2;b[1]=1;
	for(int i=2;i<n;i++)b[i]=i+1;
	while(1)
	{
		int x=Ans();
		if(x>ans)
		{
			ans=x;
			for(int i=1;i<=n;i++)k[i]=b[i];
		}
		if(!next_permutation(b+2,b+n))break;
	}
	cout<<ans<<endl;
	for(int i=1;i<=n;i++)cout<<k[i]<<" ";
}
```

$n=12$ 的时候答案是

```cpp
1 12 10 8 6 5 7 9 4 11 3 2
```

模拟过程：

```cpp
1 12 10 8 6 5 7 9 4 11 3 2 -> 0 12 10 8 6 5 7 9 4 11 3 0
12 0 0 10 8 6 5 7 9 4 11 3 -> 0 0 0 10 8 6 5 7 9 4 11 0
0 0 10 8 6 5 7 9 4 0 0 11  -> 0 0 10 8 6 5 7 9 4 0 0 0
0 10 0 0 8 6 5 7 9 4 0 0   -> 0 10 0 0 8 6 5 7 9 4 0 0
10 0 0 0 0 8 6 5 7 9 4 0   -> 0 0 0 0 0 8 6 5 7 9 4 0
0 0 0 0 8 6 5 7 0 0 9 4    -> 0 0 0 0 8 6 5 7 0 0 9 0
0 0 0 8 6 5 7 0 0 0 0 9    -> 0 0 0 8 6 5 7 0 0 0 0 0
...
```

看到这里应该就发现了问题，它会向右同时走了俩数并非我们观察的只会走一个。

这时我就明白贪心大抵是没了前途。

注意到其实 `#` 局面是非常好设计 `dp` 的，那就直接大力设 $f_{x,y}$ 表示 `#` 局面左边还剩下 $x$ 个 $0$，右边还剩 $y$ 个 $0$ 此时还能走多少秒。

注意到最大值直接影响全局走向，那直接枚举最大值位置以及最大值本身的走向，大力记忆化搜索即可。（转移方程跟一开始的贪心类似，只是加了个最大值位置）

现在要求方案，注意到最大值走向由次大值在左侧还是右侧直接有关（与次大值位置相反），一种比较好的方案是在最大值走的方向上放最小的几个数，找位置的时候跟求 $f$ 数组类似再写个记忆化搜索即可。

复杂度 $O(n^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=103;
int n,st,ed,kl,kr,a[N],f[N][N],g[N][N],h[N][N];
int Dfs(int x,int y)
{
	if(x+y>=n-1)return 0;
	if(f[x][y]!=-1)return f[x][y];
	int res=0,pos=0,op=0;
	for(int i=1,z;i<n-x-y&&i+x-1<=y;i++)
		if((z=i+x-1+Dfs(i+x+i+x-1,y-(i+x-1)))>res)res=z,pos=i,op=0;
	for(int i=1,z;i<n-x-y&&i+y-1<=x;i++)
	    if((z=i+y-1+Dfs(x-(i+y-1),i+y+i+y-1))>res)res=z,pos=i,op=1; 
	g[x][y]=pos;h[x][y]=op;return f[x][y]=res;
}
void Out(int x,int y)
{
	if(x+y>=n-1)return;
	if(!h[x][y])
	{
		a[kl+g[x][y]-1]=ed--;
		for(int i=g[x][y]-1;i>0;i--)a[kl+i-1]=st++;
		kl+=g[x][y];
		Out(g[x][y]+x+g[x][y]+x-1,y-(g[x][y]+x-1));
	}
	else
	{
		a[kr-g[x][y]+1]=ed--;
		for(int i=g[x][y]-1;i>0;i--)a[kr-i+1]=st++;
		kr-=g[x][y];
		Out(x-(g[x][y]+y-1),g[x][y]+y+g[x][y]+y-1);
	}
}
int main()
{
	cin>>n;memset(f,-1,sizeof(f));
	if(n<=6)
	{
		for(int i=1;i<=n;i++)cout<<i<<" ";
		return 0;
	}
	a[n]=2;a[1]=1;st=3;ed=n;kl=2;kr=n-1;
	Dfs(1,1);Out(1,1);
	for(int i=1;i<=n;i++)if(!a[i])a[i]=ed--;
	for(int i=1;i<=n;i++)cout<<a[i]<<" ";
}
```

后记：出题组说我的代码是 $O(n^2)$ 的？不懂，但是感觉复杂度确实会比普通区间 dp 稍微优秀一点。（希望出题组能解答一下）

std 在写啥呀，不是很能看懂，感觉有点麻烦了。



---

## 作者：封禁用户 (赞：2)

这题实际上区间 dp 就好了，不知道为什么有黑。

纪念独立做出来的第一道黑题。

首先，显然，$i! > \sum\limits_{j=1}^{i-1} j!$，所以每个元素一定会远离除了自己的最大值，所以除了最大值都远离最大值，最大值远离次大值，所以最大值一定会把其左边或右边的元素全部清掉才会被清除。

这里尝试给一个别的题解都感性证明的部分的严谨证明，如果次大值比最大值先被清，那么最大值会左右反复，导致其他元素被清的更多，但是由于左右最多保留一边，所以单边只有相对大小有关系，而留下的元素越多计时器越大，所以一定会使得一边比另一边都大，来让被清的元素达到最少。

有了这个理论，接下来直接区间 dp 就好了，我这里定义第一位是区间长度，第二维是区间左端点（相对大小有关，绝对大小无关，所以不用第三维剩余元素集合），细节有点多。

直接放代码吧，代码里有状态定义的更准确的注释，看注释就行，[AC 记录](https://www.luogu.com.cn/record/141932455)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[109][109],g[109][109],m[109][109],q[109][109],a[109],r,w,o,z;//f[r][d]:[k,k+r-1]在[d,d+r-1]时最大的b,g[r][d]:最大值位置,m[r][d]:消除最大值后左端点的位置,q[r][d]:消除最大值后的区间长度
bool h[109][109];//h[r][d]:[次大值在最大值右边]
int main(){
    cin>>n;
    if(n==1) return cout<<"1",0;
    for(int i=1;i<=n;++i) f[1][i]=0,g[1][i]=i,h[1][i]=0,m[1][i]=0,q[1][i]=0;
    // for(int i=1;i<n;++i) g[2][i]=i,h[2][i]=1,i+(i+1)==n+1?(f[2][i]=i-1,m[1][i]=0,q[1][i]=0):i-1<n-(i+1)?(f[2][i]=i-1,m[2][i]=(i+1)+i-1,q[2][i]=1):(f[2][i]=n-(i+1),m[2][i]=i-(n-(i+1)),q[2][i]=1);
    for(int i=2;i<=n;++i){
        for(int u=1,v=i;v<=n;++u,++v) for(int s=u;s<v;++s){r=s-1,w=0;if(s+1+r-1<n) s+1+r>=n?(w=r-1+(s+1+r-1<n),o=z=0):(w=f[z=min(v+r,n-1)-(s+1+r)+1][o=s+1+r]+r);if(w>f[i][u]) f[i][u]=w,g[i][u]=s,m[i][u]=o,q[i][u]=z,h[i][u]=1;}//次大值在s右边
        for(int u=1,v=i;v<=n;++u,++v) if(n+1!=u+v&&h[i][n+1-v]){w=f[i][n+1-v];if(f[i][u]<w) f[i][u]=w,h[i][u]=0,g[i][u]=n+1-g[i][n+1-v],m[i][u]=n+1-(m[i][n+1-v]+q[i][n+1-v]-1),q[i][u]=q[i][n+1-v];}//次大值在s左边
    }
    a[1]=1,a[n]=2;
    int u=2,v=n-1,d=2,l=3,r=n;
    while(1){
        if(u>v) break;
        if(u==v){a[d]=l;break;}
        if(!f[v-u+1][u]){iota(a+d,a+d+v-u+1,l);break;}
        int t=g[v-u+1][u];
        bool s=h[v-u+1][u];
        o=m[v-u+1][u],z=q[v-u+1][u];
        if(s){
            for(int i=u;i<t;++i) a[i+d-u]=l++;
            for(int i=t+1+z;i<=v;++i) a[i+d-u]=l++;
            a[t+d-u]=r--;
            d=t+d-u+1,u=o,v=u+z-1;
        }
        else{
            for(int i=t+1;i<=v;++i) a[i+d-u]=l++;
            for(int i=u;i<=t-1-z;++i) a[i+d-u]=l++;
            a[t+d-u]=r--;
            u=o,v=u+z-1;
        }
    }
    for(int i=1;i<=n;++i) cout<<a[i]<<" ";
}
```

---

## 作者：快斗游鹿 (赞：1)

参考了 @Hanghang 的做法。

## 思路

首先不难得到 $i!>\sum_{j=1}^{i-1} j!$，这意味着每次运动一定会以当前序列最大值为断点。对于左侧的点，左边和肯定小于右边，所以会向左运动，右侧点同理。而最大值向左向右走皆可。

可以发现，当序列中最大值发生改变时，即最大值移到了端点处且被删除。序列中所有非 $0$ 的数一定连续，假设左边有 $x$ 个连续的 $0$，右边有 $y$ 个连续的 $0$，可以设 $f_{x,y}$ 表示该状态下最多还能再持续多少时间。我们并不关心这时序列中具体剩下什么数，因为最大值是相对的。转移时枚举最大值所在位置 $i$ 和运动方向。

当它向左运动时，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/sd0fcir5.png)

最大值被删除后 $x$ 变为 $i+i-1$，$y$ 变为 $y-(i-1)$。得到转移 $f_{x,y}=i-1+f_{i+i-1,y-(i-1)}$。向右运动同理。可以采用记忆化搜索实现。

处理完最长时间后，考虑如何构造方案。因为枚举了最大值位置和运动方向，我们可以分别记录这两个值。注意到次大值的运动方向与最大值的运动方向相反，所以在与最大值同向处把最小的几个数填入即可，它们一定不会影响后面的次大值。

需要注意的是，最终可能会剩下一些数还未被填入，由于它们并不会影响整体运动状态，随便填就可以了。填数的过程和转移过程类似，递归处理即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=105;
int n,a[N],f[N][N],pos[N][N],flag[N][N];
int s,t,l,r;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int dfs(int x,int y){
	if(x+y>=n-1)return 0;
	if(f[x][y]!=-1)return f[x][y];
	int mx=0,p=0,op;
	for(int i=x+1;i<n-y&&i-1<=y;i++){//往左
		int w=i-1+dfs(i+i-1,y-(i-1));
		if(w>mx){
			mx=w;p=i;op=0;
		}
	}
	for(int i=y+1;i<n-x&&i-1<=x;i++){//往右
		int w=i-1+dfs(x-(i-1),i+i-1);
		if(w>mx){
			mx=w;p=i;op=1;
		}
	}
	pos[x][y]=p;flag[x][y]=op;f[x][y]=mx;
  //记录位置，方向
	return mx;
}
void print(int x,int y){
	if(x+y>=n-1||!pos[x][y])return;
	//for(int i=1;i<=n;i++)printf("%lld ",a[i]);
	//putchar('\n');
	if(flag[x][y]==0){
		a[l+(pos[x][y]-x)-1]=t;t--;
		for(int i=pos[x][y]-x-1;i>=1;i--){
			//cout<<l+i-1<<" "<<l<<" "<<i<<endl; 
			a[l+i-1]=s;s++;
		}//往里填小的数
		int i=pos[x][y];l+=(i-x);
		print(i+i-1,y-(i-1));
	}
	else{
		a[r-(pos[x][y]-y)+1]=t;t--;
		for(int i=pos[x][y]-y-1;i>=1;i--){
			//cout<<r-i+1<<endl;
			a[r-i+1]=s;s++;
		}
		int i=pos[x][y];r-=(i-y);
		print(x-(i-1),i+i-1);
	}
	//for(int i=1;i<=n;i++)printf("%lld ",a[i]);
	//putchar('\n');
}
signed main(){
	n=read();
	a[n]=2;a[1]=1;s=3;t=n;
	memset(f,-1,sizeof(f));
	dfs(1,1);
	l=2;r=n-1;
	print(1,1);
	//cout<<f[1][1];
	for(int i=1;i<=n;i++)if(!a[i])a[i]=s,s++;
	for(int i=1;i<=n;i++)printf("%lld ",a[i]);
}
```


---

## 作者：xuanxuan001 (赞：1)

其实不需要官方题解那么多的讨论。

~~题外话，35pts 是啥做法啊。~~

不难发现阶乘只是诈骗的，因为 $n! > \sum\limits_{i=1}^{n-1}i!$，所以其实就是比较两边的 $\max$。

那么发现所有的原子一定会以最大值为分界，所有非最大值都会向离开最大值的方向走，最大值的方向取决于非最大值相对于它的位置。

然后自然而然地想到在两边放大的值，通过它们的消失让中间小的值反复来回走，然后发现怎么构造都不行。

看到 $n \le 100$ 的限制，想想应该不是什么贪心，所以考虑 dp，发现一开始的原子一定是一个区间，之后分成两个部分的时候这两部分一定会背道而驰直到某一部分彻底地消失掉，因为最大值在分界处，它会永远压着两边不断地离开。

当然有一个例外，就是在次大值离开的时候可能会改变最大值的方向，但感性理解以下这样应该一定不优，因为离开大部队的最大值会不断地压着两边继续分开，这时可能有一边已经消失了但另一边还要继续跑而不能进行下一步分裂。

于是可以直接枚举断开的位置 $k$，然后可以直接求出接下来会演变成什么区间以及需要的时间。

但这时还需要考虑前面对最大值的限制，但发现其实不用考虑，因为有一边在演化后会直接消失，所以把最大值放在消失的这一边就行了，这一边的其他位置用最小的几个值就能保证次大值在另一边，然后输出方案即可。

代码

```
#include<cstdio>
#define TY int
#define MAXN 102
#define debug if( 1 &&putchar('>'))
#define FOR(i,a,b) for(TY i=(a);i<=(b);i=-~i)
#define fOR(i,a,b) for(TY i=(a);i<(b);i=-~i)
#define ROF(i,a,b) for(TY i=(a);i>=(b);i=~-i)
#define rOF(i,a,b) for(TY i=(a);i>(b);i=~-i)
#define EDG(i,u) for(TY i=hed[u];i;i=nxt[i])
using namespace std;
typedef long long ll;
const TY M=998244353;
typedef unsigned long long ull;
TY _abs(TY a){return a<0?-a:a;}
TY maxn(TY a,TY b){return a>b?a:b;}
TY minn(TY a,TY b){return a<b?a:b;}
inline void updmx(TY &x,TY y){if(x<y)x=y;}
inline void updmn(TY &x,TY y){if(x>y)x=y;}
inline void add(TY &x,TY y){if((x+=y)>=M)x-=M;}
TY gcd(TY a,TY b){return b?gcd(b,a%b):a;}
TY qp(TY a,TY b){TY ans=1;do{if(1&b)ans=ans*a%M;a=a*a%M;}while(b>>=1);return ans;}
char getc(){char ch=getchar();while(ch==' '||ch=='\n'||ch=='\r')ch=getchar();return ch;}
TY qr(){
	char ch=getchar();TY s=0,x=1;
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')x=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())s=s*10+ch-'0';return x*s;
}void qw(TY a){if(a>9)qw(a/10);putchar(a%10+'0');}
void qw(TY a,char ch){
	if(a<0){a=-a;putchar('-');}
	if(a>9)qw(a/10);putchar(a%10+'0');
	if(ch)putchar(ch);
}TY n=qr(),dp[MAXN][MAXN],l,r,tim,ct,ans[MAXN];
TY js(TY L,TY R,TY k){//[L,R]从k这里断开得到的值
	tim=minn(k,n-k);l=r=0;//tim即经过时间
	if(tim<k){l=maxn(L-tim,1);r=k-tim;}
	if(tim<n-k){r=minn(R+tim,n);l=k+1+tim;}
	return dp[l][r]+tim;
}void findans(TY l,TY r,TY det){
	//找方案，det即为这里的区间与初始位置对应的偏差
	if(l==r){ans[l+det]=++ct;return;}
	fOR(k,l,r)if(js(l,r,k)==dp[l][r]){
		if(k==n-k){
			FOR(i,l,k)ans[i+det]=++ct;
			rOF(i,r,k)ans[i+det]=++ct;break;
		}tim=minn(k,n-k);
		if(tim<k){
			FOR(i,l-tim,0)ans[i+det+tim]=++ct;
			rOF(i,r,k+1)ans[i+det]=++ct;
			findans(maxn(l-tim,1),k-tim,det+tim);
			ans[k+1+det]=++ct;
		}else{
			rOF(i,r+tim,n)ans[i+det-tim]=++ct;
			fOR(i,l,k)ans[i+det]=++ct;
			findans(k+1+tim,minn(r+tim,n),det-tim);
			ans[k+det]=++ct;
		}break;
	}
}int main(){
	if(n==1){putchar('1');return 0;}
	if(n==2){printf("1 2");return 0;}
	n-=2;fOR(i,1,n)ROF(j,n-i,1)fOR(k,j,i+j)
		updmx(dp[j][i+j],js(j,i+j,k));
	//注意这里一定要按长度转移，因为转移的位置不一定被原来的包含
	findans(1,n,0);qw(n+2,' ');
	FOR(i,1,n)qw(ans[i],' ');
	qw(n+1);return 0;
}
```

---


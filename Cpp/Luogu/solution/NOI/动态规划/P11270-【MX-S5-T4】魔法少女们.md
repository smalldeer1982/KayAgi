# 【MX-S5-T4】魔法少女们

## 题目背景

原题链接：<https://oier.team/problems/S5D>。

---

> 祈祷着今后的你的人生，永远都有幸福的“魔法”相伴。

**以下是本题所用记号的约定。**

字符串下标均从 $1$ 开始。

$|S|$ 表示字符串 $S$ 的长度。

$S_i$ 表示字符串 $S$ 的第 $i$ 个字符。

记字符串 $S$ 为 $T$ 的前缀，当且仅当：

- $|S|\leq |T|$，
- $\forall i\in[1,|S|]$，$S_i=T_i$。

记字符串 $S$ 为 $T$ 的后缀，当且仅当：

- $|S|\leq |T|$，
- $\forall i\in[1,|S|]$，$S_{|S|-i+1}=T_{|T|-i+1}$。

合法括号序列的定义如下：

- 空串是合法括号序列。
- 若 $A$ 为合法括号序列，则 $(A)$ 为合法括号序列。
- 若 $A,B$ 为合法括号序列，则 $AB$ 为合法括号序列。

## 题目描述

千和有 $n$ 个**括号序列**，分别是 $S_1,S_2,S_3,\dots,S_n$。

小黑有 $m$ 个**括号序列**，分别是 $T_1,T_2,T_3,\dots,T_m$。

对一个括号序列 $A$，$f(A)$ 为满足以下条件的正整数对 $(i,j)$ 对数：

- $i\in[1,n]$，$j\in [1,m]$；
- $S_i$ 是 $A$ 的**前缀**且 $T_j$ 是 $A$ 的**后缀**。

她们想知道对于所有长度为偶数 $k$ 的**合法括号序列** $S$，$f(S)$ 的和。答案对 $10^9+7$ 取模。

## 说明/提示

**【样例解释 #1】**

长度为 $6$ 的合法括号序列有 `()()()`、`()(())`、`(())()`、`(()())`、`((()))`，分别记作 $S_1,S_2,S_3,S_4,S_5$，答案为 $f(S_1)+f(S_2)+f(S_3)+f(S_4)+f(S_5)=1+1+1+1+0=4$。

**【样例 #2】**

见附件中的 `bracket/bracket2.in` 与 `bracket/bracket2.ans`。

该组样例满足测试点 $1\sim 2$ 的约束条件。

**【样例 #3】**

见附件中的 `bracket/bracket3.in` 与 `bracket/bracket3.ans`。

该组样例满足测试点 $3\sim 4$ 的约束条件。

**【样例 #4】**

见附件中的 `bracket/bracket4.in` 与 `bracket/bracket4.ans`。

该组样例满足测试点 $14\sim 15$ 的约束条件。

**【样例 #5】**

见附件中的 `bracket/bracket5.in` 与 `bracket/bracket5.ans`。

该组样例满足测试点 $20\sim 21$ 的约束条件。

**【数据范围】**

对于所有测试数据，保证 $1\leq n,m\leq 2\times 10^5$，$1\leq \vert S_i\vert,\vert T_j\vert\leq \min(k,5\times 10^5)$，$1\leq \sum \vert S_i\vert,\sum \vert T_j\vert\leq 10^7$，$2\leq k\leq 10^6$，$k$ 为偶数。

| 测试点编号 | $n,m\leq$      | $\vert S_i\vert,\vert T_j\vert\leq$ | $\sum \vert S_i\vert,\sum \vert T_j\vert\leq$ | $k\leq$       | 特殊性质 |
| :----------: | :--------------: | :-----------------------------------: | :---------------------------------------------: | :-------------: | :--------: |
| $1\sim2$   | $10$           | $10$                                | $100$                                         | $15$          | 无       |
| $3\sim4$   | $50$           | $100$                               | $5\times10^3$                                 | $100$         | 无       |
| $5\sim8$   | $250$          | $5\times10^3$                       | $5\times10^5$                                 | $5\times10^3$ | 无       |
| $9\sim11$  | $5\times 10^3$ | $10^5$                              | $5\times10^5$                                 | $2\times10^5$ | 无       |
| $12\sim13$ | $5\times10^4$  | $10^5$                              | $5\times10^5$                                 | $2\times10^5$ | A        |
| $14\sim15$ | $5\times10^4$  | $10^5$                              | $5\times10^5$                                 | $2\times10^5$ | B        |
| $16\sim17$ | $10^5$         | $2\times10^3$                       | $10^6$                                        | $2\times10^5$ | C        |
| $18\sim19$ | $10^5$         | $10^5$                              | $10^6$                                        | $2\times10^5$ | C        |
| $20\sim21$ | $10^5$         | $10^5$                              | $10^6$                                        | $2\times10^5$ | 无       |
| $22\sim23$ | $2\times10^5$  | $5\times 10^5$                      | $10^7$                                        | $10^6$        | C        |
| $24\sim25$ | $2\times10^5$  | $5\times 10^5$                      | $10^7$                                        | $10^6$        | 无       |

* 特殊性质 A：$k<\min\vert S_i\vert+\min\vert T_j\vert$；
* 特殊性质 B：保证 $S_i,T_j$ 是合法的括号序列；
* 特殊性质 C：$k\geq\max\vert S_i\vert+\max\vert T_j\vert$。



## 样例 #1

### 输入

```
0
1 2 6
(
()
())```

### 输出

```
4```

# 题解

## 作者：tobie (赞：15)

想题五分钟，调试两年半，码力有待加强。

首先把所有一定不可能匹配的括号串扔掉，他们没有用。

不妨设 $n,m$ 同阶，所有字符串的总长度为 $L$

对于原问题，考虑拆贡献：枚举每一对 $(i,j)$ ，求出有多少个合法括号串满足 $S_i$ 为前缀，$T_i$ 为后缀。

对 $|S|+|T|$ 和 $K$ 的大小关系分类讨论一下。

- - -

先考虑 $|S|+|T|>K$ 的部分，这意味着 $S$ 和 $T$ 在最终的序列中存在重叠部分。

考虑枚举 $S$ 和重叠部分长度 $d$，则根据 $|T|+|S|-d=k$ 可以知道 $T$ 的两个限制：

1. 长度为一个定值 $l$。
2. $T$ 的长度为 $d$ 的前缀和 $S$ 的长度为 $d$ 的后缀相同。
3. $T$ 的左右括号数量之差为 $\delta$。

判断字符串是否相等可以使用字符串哈希。接下来我们枚举所有长度和 $\delta$ 满足条件的串 $T$，转化为查询 $T$ 的前缀的哈希值在刚刚出现了几次，可以再开一个哈希表维护。

因为所有字符串的长度之和是 $L$，所以这部分的枚举量是 $O(L)$ 的，常数较小。

- - -

方便起见，以下记 $k=\frac k 2$，即左括号数量。

接下来是 $|S|+|T|\le K$。这说明 $S$ 和 $T$ 中间存在一段空缺。

根据经典套路，将括号串转化为一个 $(0,0)\to (k,k)$ 并且不碰到 $y=x+1$ 直线的路径。则这个路径的开头和结尾部分已知，则开头走到了 $(s_x,s_y)$，结尾走到了 $(e_x,e_y)$。

将坐标稍微平移一下，则我们需要解决如下问题：

记 $f(i,j)$ 表示 $(ax_i,ay_i)$ 走到 $(bx_j,by_j)$ 并且不经过 $y=x$ 的路径数量。你需要求出所有 $i,j$ 的 $f(i,j)$ 的和。

再次根据经典转化，我们将经过 $y=x$ 的路径，和到达 $(by,bx)$ 的路径建立一个双射。则答案可以转化成两个组合数相减的形式，可以再次拆开。

所以我们再次将问题转化为：

记 $g(i,j)$ 表示 $(ax_i,ay_i)$ 走到 $(bx_j,by_j)$ 的路径数量。你需要求出所有 $i,j$ 的 $g(i,j)$ 的和。

>#### Lemma：最多有 $O(L^{\frac 2 3})$ 个本质不同的点。
> 注意到 $L=\sum (ax_i+ay_i)$ 的限制，取 $B=L^{\frac 1 3}$。
>
> 若 $ax+ay\le B$，则有 $O(B^2)$ 个小点。
>
> 若 $ax+ay>B$ 则最多只有 $O(\frac L B)$ 个大点。
>
> 综上，点数为 $O(B^2+\frac L B)=O(L^{\frac 2 3})$。

所以暴力枚举计算贡献就可以做到 $O(L^{\frac 4 3})$，但是对于赛后 vp 玩家来说还不够。

大点之间肯定没办法继续优化，考虑优化小点的计算过程。

再次联想到 [AGC001E](https://www.luogu.com.cn/problem/AT_agc001_e)。我们发现，对于值域较小的情况，直接用 dp 就可以让复杂度和点数无关。

所以对于小点到小点的情况，我们可以把所有小点先走到 $x+y=B$ 和 $x+y=k-B$ 上，而这两条直线上分别只有 $O(B)$ 个点，就可以直接 $O(B^2)$ 统计答案。

对于大点到小点的情况，考虑对大点在 $x+y=B$ 直线的哪个部分分类讨论：如果 $bx+by\le B$，则我们可以使用刚才的 $dp$ 数组直接计算答案，否则继续枚举 $x+y=B$ 上的点计算贡献。

总时间复杂度为 $O(B^2+\frac {L^2} {B^2}+B\times \frac L B)=O(L)$，可能需要特别处理 $k\le B$ 的情况，细节较多。

（小声BB）这种题评紫是不是有点过于先进了？

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+9,M=1e6+9,mod=1e9+7;
namespace io{

inline void gi(int &x)
{
	x=0;char ch=getchar();
	while(ch<'0'||'9'<ch) ch=getchar();
	while('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();
}
void print(int x)
{
	if(x<=9) return putchar(x+'0'),void();
	print(x/10),putchar(x%10+'0');
}
inline void gstr(string &s)
{
	s.clear();
	char ch=getchar();
	if(ch!='('&&ch!=')') ch=getchar();
	while(ch=='('||ch==')') s.push_back(ch),ch=getchar();
}

}using io::gi;using io::print;using io::gstr;

void Add(int &x,int y){x+=y;if(x>=mod) x-=mod;}
int n,m,K,ans=0;
string S[N],T[N];
void readIn()
{
	gi(n);gi(m);gi(K);
	int n0=0,m0=0;
	for(int i=1;i<=n;i++)
	{
		gstr(S[++n0]);
		if(S[n0].size()>K){n0--;continue;}
		int cnt=0,cnt0=0,cnt1=0;
		for(int j=0;j<S[n0].size();j++)
		if(S[n0][j]=='(') cnt++,cnt0++;
		else if(!cnt){n0--;break;}
		else cnt--,cnt1++;
		if(cnt0*2>K||cnt1*2>K) n0--;
	}
	for(int i=1;i<=m;i++)
	{
		gstr(T[++m0]);
		if(T[m0].size()>K){m0--;continue;}
		int cnt=0,cnt0=0,cnt1=0;
		for(int j=T[m0].size()-1;j>=0;j--)
		if(T[m0][j]==')') cnt++,cnt0++;
		else if(!cnt){m0--;break;}
		else cnt--,cnt1++;
		if(cnt0*2>K||cnt1*2>K) m0--;		
	}
	n=n0,m=m0;
}

int fac[M],inv[M],ifac[M];
void ycl(int lim=1e6)
{
	fac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;
	for(int i=2;i<=lim;i++)
	{
		fac[i]=1ll*fac[i-1]*i%mod;
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	}
}
inline int C(int x,int y){return x>=y&&y>=0?1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod:0;}

namespace tobie{

const int Base=3;
int pw[M];
vector<int> hsh_S[N],hsh_T[N];
vector<int> id_S[M],id_T[M];
vector<int> sum_S[N];
int sum_T[N];
typedef pair<int,int> pii;
struct Node{
	pii key;
	int val,nxt;
}a[N];
int head[M],node_cnt=0;
inline int hsh2(pii num){return (1ll*num.first*(n+1)+num.second)%1000003;}
void Clear()
{
	for(int i=1;i<=node_cnt;i++) head[hsh2(a[i].key)]=0;
	node_cnt=0;
}
void Ins(pii key,int val)
{
	int h=hsh2(key);
	bool pd=0;
	for(int i=head[h];i;i=a[i].nxt)
	if(a[i].key==key)
	{
		pd=1;
		a[i].val+=val;
		break;
	}
	if(!pd)
	{
		node_cnt++;
		a[node_cnt].key=key;
		a[node_cnt].val=val;
		a[node_cnt].nxt=head[h];
		head[h]=node_cnt;
	}
}
int Qry(pii key)
{
	for(int i=head[hsh2(key)];i;i=a[i].nxt)
	if(a[i].key==key) return a[i].val;
	return 0;
}
void chkmx(int &x,int y){if(y>x) x=y;}
int nxt[N];
void work()
{
	pw[0]=1;
	for(int i=1;i<=K;i++) pw[i]=1ll*pw[i-1]*Base%mod;
	int mxlen_A=0,mxlen_B=0;
	for(int i=1;i<=n;i++)
	{
		chkmx(mxlen_A,S[i].size());
		id_S[S[i].size()].push_back(i);
	}
	for(int i=1;i<=m;i++)
	{
		chkmx(mxlen_B,T[i].size());
		id_T[T[i].size()].push_back(i);
	}
	for(int i=1;i<=n;i++)
	{
		int siz=S[i].size();
		hsh_S[i].resize(siz);
		hsh_S[i][0]=(S[i][siz-1]=='('?1:2);
		for(int j=1;j<siz;j++)
		hsh_S[i][j]=(hsh_S[i][j-1]+1ll*pw[j]*(S[i][siz-j-1]=='('?1:2)%mod)%mod;
		sum_S[i].resize(siz);
		sum_S[i][0]=(S[i][0]=='('?1:-1);
		for(int j=1;j<siz;j++)
		sum_S[i][j]=sum_S[i][j-1]+(S[i][j]=='('?1:-1);
	}
	for(int i=1;i<=m;i++)
	{
		int siz=T[i].size();
		hsh_T[i].resize(siz);
		hsh_T[i][0]=(T[i][0]=='('?1:2);
		for(int j=1;j<siz;j++)
		hsh_T[i][j]=(1ll*hsh_T[i][j-1]*Base%mod+(T[i][j]=='('?1:2))%mod;
		for(int j=0;j<siz;j++) sum_T[i]+=(T[i][j]==')'?1:-1);
	}
	nxt[mxlen_A]=mxlen_A+1;
	for(int i=mxlen_A-1;i>=1;i--)
	{
		if(id_S[i+1].size()) nxt[i]=i+1;
		else nxt[i]=nxt[i+1];
	}
//	cerr<<mxlen_A<<" "<<mxlen_B<<endl;
	int st=1;
	for(int d=1;d<=mxlen_A;d++)
	{
		while(st<d) st=nxt[st];
		for(int lenA=st;lenA<=mxlen_A;lenA=nxt[lenA])
		{
			int lenB=K-lenA+d;
			if(lenB>mxlen_B) continue;
			if(!id_S[lenA].size()||!id_T[lenB].size()) continue;
			Clear();
			for(int id:id_S[lenA]) Ins(make_pair(hsh_S[id][d-1],lenA==d?0:sum_S[id][lenA-d-1]),1);
			for(int id:id_T[lenB]) Add(ans,Qry(make_pair(hsh_T[id][d-1],sum_T[id])));
		}
	}
}

}
namespace eibot{

const int B0=3200;
struct Point{
	int x,y,v;
}a[N],b[N<<1];
int dp1[B0+10][B0+10],dp2[B0+10][B0+10];
inline int js(int x1,int y1,int x2,int y2){return C(x2-x1+y2-y1,x2-x1);}
vector<int> fz1,fz2;
void work()
{
	for(int i=1;i<=n;i++)
	{
		int cnt1=0,cnt2=0;
		for(int j=0;j<S[i].size();j++)
		if(S[i][j]=='(') cnt1++;
		else cnt2++;
		a[i]={cnt1+1,cnt2,1};
	}
	for(int i=1;i<=m;i++)
	{
		int cnt1=K/2,cnt2=K/2;
		for(int j=0;j<T[i].size();j++)
		if(T[i][j]=='(') cnt1--;
		else cnt2--;
		b[i]={cnt1+1,cnt2,1};
		b[m+i]={cnt2,cnt1+1,-1};
	}
	int k=K/2+1;
	int B=min(3200ll,k-1);
	for(int i=1;i<=n;i++)
	if(a[i].x+a[i].y<=B) dp1[a[i].x][a[i].y]++;
	for(int i=1;i<=m+m;i++)
	if(b[i].x+b[i].y>=k+k-B) Add(dp2[k-b[i].x][k-b[i].y],(mod+b[i].v)%mod);
	for(int i=0;i<=B;i++)
	for(int j=0;j<=B;j++)
	{
		if(i) Add(dp1[i][j],dp1[i-1][j]),Add(dp2[i][j],dp2[i-1][j]);
		if(j) Add(dp1[i][j],dp1[i][j-1]),Add(dp2[i][j],dp2[i][j-1]);
	}
	if(k<=B)
	{
		for(int i=1;i<=m;i++) Add(ans,dp1[b[i].x][b[i].y]);
		for(int i=m+1;i<=m+m;i++) Add(ans,mod-dp1[b[i].x][b[i].y]);
	}
	else
	{
		for(int i=0;i<=B;i++)
		for(int j=0;j<=B;j++)
		Add(ans,1ll*dp1[i][B-i]*dp2[j][B-j]%mod*js(i,B-i,k-j,k-B+j)%mod);
		for(int i=1;i<=n;i++)
		if(a[i].x+a[i].y>B)
		{
			fz1.push_back(i);
			if(a[i].x+a[i].y>=k+k-B) Add(ans,dp2[k-a[i].x][k-a[i].y]);
			else for(int j=0;j<=B;j++) Add(ans,1ll*dp2[j][B-j]*js(a[i].x,a[i].y,k-j,k-B+j)%mod);
		}
		for(int i=1;i<=m+m;i++)
		if(b[i].x+b[i].y<k+k-B)
		{
			fz2.push_back(i);
			int v=(b[i].v+mod)%mod;
			if(b[i].x+b[i].y<=B) Add(ans,1ll*dp1[b[i].x][b[i].y]*v%mod);
			else for(int j=0;j<=B;j++) Add(ans,1ll*dp1[j][B-j]*js(j,B-j,b[i].x,b[i].y)%mod*v%mod);
		}
		for(int x:fz1)
		for(int y:fz2)
		{
			int v=(b[y].v+mod)%mod;
			Add(ans,1ll*js(a[x].x,a[x].y,b[y].x,b[y].y)*v%mod);
		}
	}
}

}
signed main()
{
	int id__;
	scanf("%d",&id__);
	readIn();
	ycl();
	tobie::work();
	eibot::work();
	print(ans);
}
```

---

## 作者：ZhongYuLin (赞：3)

场上没有发现存在重合的情况，痛失一堆分。

不妨先去掉所有已经不合法的前、后缀。例如，将左括号看做 $1$，右括号看做 $-1$，如果一个前缀的某个前缀和小于 $0$，那么这个前缀是不合法的。

先考虑存在重合的情况怎么做。枚举重合长度 $len$，将所有后缀的长度为 $len$ 的前缀取出，哈希后存入哈希表中。一对前、后缀合法，当且仅当：

1. 重合部分哈希值相等。

2. 长度和减去 $len$ 等于 $K$。

3. 括号序列和为 $0$。

记 $L=\sum S_i+\sum T_i$，复杂度为 $O(L)$。

接下来考虑没有重合的情况。将每个括号序列视为平面上的一个点 $(x_i,y_i)$，其中 $x_i$ 等于其中左括号的个数，$y_i$ 等于其中右括号的个数。既然括号序列要求合法，我们要计数的便是：从 $S$ 中某个点出发，不经过直线 $y=x+1$，抵达 $T$ 中某个点的总方案数。

使用枚举法，枚举起点与终点，考虑对这个东西快速计数。假设没有不经过直线 $y=x+1$ 的限制，答案显然是 $\binom{x_2-x_1+y_2-y_1}{x_2-x_1}$。

考虑反射容斥，减去所有不合法的方案。

设**不合法**路径与直线 $y=x+1$ 的横坐标最大的交点是 $A$，将此后乃至终点的路径沿直线翻折，容易发现终点变为了 $(y_2-1,x_2+1)$。既然从起点到 $(y_2-1,x_2+1)$ 必然经过直线，同时反射后向右走变为向上走、向上走变为向右走，一一对应，因此，不合法方案数为 $\binom{x_2-x_1+y_2-y_1}{y_2-x_1-1}$。

故，总方案数为 $\binom{x_2-x_1+y_2-y_1}{x_2-x_1}-\binom{x_2-x_1+y_2-y_1}{y_2-x_1-1}$。

于是我们得到了一个 $O(nm)$ 的做法。进一步地，将所有坐标相等的点压起来，可以证明只有 $O(L^{\frac{2}{3}})$ 个本质不同的点，因此复杂度为 $O(L^\frac{4}{3})$。

证明：贪心地将这个做法卡满，我们必然是从小的长度往大的长度填，一定是使用完了当前长度后再使用下一个长度。设我们使用到长度 $n$。有：

$$\sum_{i=1}^n\frac{1}{2}i^2$$

即每个长度 $i$ 有 $\frac{1}{2}i$ 个方案，使用这个方案的代价为 $i$。

上式估计为：$n^3$，因此估计上界为 $\sqrt[3]{L}$，故估计有 $L^{\frac{2}{3}}$ 个本质不同的点。

发现可恶的出题人倾向于在较小的值域范围内构造一堆点来 hack 我们。于是，我们对于横纵坐标在 $\sqrt{L}$ 内的点使用暴力 dp，将它们推到边界上，使得所有点的横纵坐标不小于 $\sqrt{L}$。此时边界上只有 $\sqrt{L}$ 个点，不在边界上的也只有 $\sqrt{L}$ 个点。仍然使用上文的暴力，复杂度为 $O(L)$，常数有点大。可以将 $\frac{1}{2}K-x\le\sqrt{L}$ 且 $\frac{1}{2}K-y\le\sqrt{L}$ 的点放到对面，即左右括号分别还有小于 $\sqrt{L}$ 个没有被确定，dp 的时候直接处理掉即可。


```cpp
#include<bits/stdc++.h>
#define se second
#define fi first
using namespace std;
using ll=long long;
using pii=pair<int,int>;
const int MUL1=13331,MUL2=1331;
const int P1=998244853,P2=1e9+9;
const int P=1e9+7;
const int V=2e6+3;
const int N=5e5+3;
const int M=2e3+3;
template<class T>
static inline void add(T &x,int y){if((x+=y)>=P)x-=P;}
template<class T>
static inline void add(T &x,ll y,int z){x=(x+y*z)%P;}
int n,m,K;
int inv[V],fc[V];
ll pw1[N],pw2[N];
string s[N],t[N];
int a[N],b[N],la[N],lb[N];
struct Node{ll h;int sum;bool op;};
vector<Node>tmp[N];
unordered_map<ll,int>cnt[N];
map<pii,int>pa,pb;
int f[M][M],g[M][M],tf[M][M],tg[M][M];
int C(int n,int m){
    if(n<0||m<0||n<m)return 0;
    return (ll)fc[n]*inv[m]%P*inv[n-m]%P;
}
int calc(int x1,int y1,int x2,int y2){
    return C(x2-x1+y2-y1,x2-x1);
}
int Catalan(int x1,int y1,int x2,int y2){
    return calc(x1,y1,x2,y2)-calc(x1,y1,y2-1,x2+1);
}
int main(){
    int u,v,w,x,y,z,id;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>id>>n>>m>>K;
    inv[1]=1;for(int i=2;i<V;++i)inv[i]=(ll)inv[P%i]*(P-P/i)%P;
    fc[0]=inv[0]=1;for(int i=1;i<V;++i)fc[i]=(ll)fc[i-1]*i%P,inv[i]=(ll)inv[i-1]*inv[i]%P;
    pw1[0]=pw2[0]=1;for(int i=1;i<N;++i)pw1[i]=pw1[i-1]*MUL1%P1,pw2[i]=pw2[i-1]*MUL2%P2;
    for(int i=1;i<=n;++i){
        cin>>s[i];la[i]=s[i].size();a[i]=0;
        for(auto c:s[i]){
            a[i]+=(c=='('?1:-1);
            if(a[i]<0){--i;--n;break;}
        }
    }
    for(int i=1;i<=m;++i){
        cin>>t[i];lb[i]=t[i].size();b[i]=x=0;
        for(auto c:t[i])b[i]+=(c=='('?1:-1);
        for(auto c:t[i])if((x+=(c=='('?1:-1))<b[i]){--i;--m;break;}
    }
    if(!n||!m){puts("0");return 0;}
	int lim=max(*max_element(la+1,la+1+n),*max_element(lb+1,lb+1+m));
	for(int i=1;i<=m;++i){
		ll h1=0,h2=0;int sum=b[i];
		for(int j=1;j<=lb[i];++j){
			auto c=t[i][j-1];
			h1=(h1*MUL1+c)%P1;h2=(h2*MUL2+c)%P2;
			sum-=(c=='('?1:-1);tmp[j].push_back({(h1<<30|h2)+lb[i]-j,sum,1});
		}
	}
	for(int i=1;i<=n;++i){
		ll h1=0,h2=0;
		for(int j=1;j<=la[i];++j){
			auto c=s[i][la[i]-j];
			h1=(h1+c*pw1[j-1])%P1;
			h2=(h2+c*pw2[j-1])%P2;
			tmp[j].push_back({(h1<<30|h2)+K-la[i],a[i],0});
		}
	}
	ll ans=0;
	for(int i=1;i<=lim;++i){
		for(auto [h,sum,op]:tmp[i])
			if(op)++cnt[-sum][h];
			else{
				auto it=cnt[sum].find(h);
				if(it!=cnt[sum].end())ans+=it->se;
            }
		for(auto [h,sum,op]:tmp[i])
			if(op)cnt[-sum].clear();
	}
    ans%=P;
    K>>=1;int B=1000;
    for(int i=1;i<=n;++i){
        x=la[i]+a[i]>>1;y=la[i]-a[i]>>1;
        if(x<B&&y<B)++f[x][y];
        else if(K-x<B&&K-y<B)++tf[K-x][K-y];
        else ++pa[{x,y}];
    }
    for(int i=1;i<=m;++i){
        x=K-(lb[i]+b[i])/2;y=K-(lb[i]-b[i])/2;
        if(x<B&&y<B)++tg[x][y];
        else if(K-x<B&&K-y<B)++g[K-x][K-y];
        else ++pb[{x,y}];
    }
    for(int i=0;i<=B;++i)
        for(int j=0;j<=i;++j)
            if(i==B)add(pa[{i,j}],f[i][j]);
            else{
                add(ans,f[i][j],tg[i][j]);
                add(f[i+1][j],f[i][j]);
                if(i>j)add(f[i][j+1],f[i][j]);
            }
    for(int i=0;i<=B;++i)
        for(int j=i;j<=B;++j)
            if(j==B)add(pb[{K-i,K-j}],g[i][j]);
            else{
                add(ans,g[i][j],tf[i][j]);
                add(g[i][j+1],g[i][j]);
                if(i<j)add(g[i+1][j],g[i][j]);
            }
    vector<pair<pair<int,int>,int>>ta,tb;
    for(auto [p,k]:pa)if(k)ta.push_back({p,k});
    for(auto [p,k]:pb)if(k)tb.push_back({p,k});
    for(auto [p1,k1]:ta)for(auto [p2,k2]:tb)
        ans=(ans+(ll)k1*k2%P*Catalan(p1.fi,p1.se,p2.fi,p2.se))%P;
    printf("%lld\n",(ans%P+P)%P);
    return 0;
}
```

---

## 作者：Register_int (赞：3)

新时代的根号分治题？实在太前卫了。

直接算权值和太困难，可以枚举前缀 $S$ 和后缀 $T$ 是什么算有多少种对应的括号序列。于是可以分成两种情况：

下文设 $\sum|S|+\sum|T|=P$。

#### 1. $|S|+|T|>k$。

先去掉所有已经不可能合法的前缀和后缀。考虑枚举 $S,T$ 的长度，这样可以确定重叠部分的长度为 $l=|S|+|T|-k$。对于前缀 $S$，可以算出它长度为 $l$ 的后缀的哈希值以及它还需要的右括号数量，用 $T$ 去逐个匹配即可。根据经典结论长度只有 $O(\sqrt P)$ 种，所以前两层循环的复杂度为 $O(P)$。对于内层循环，由于所有前缀的后缀（$S_{|S|-l+1\sim|S|}$）与所有后缀的前缀（$T_{1\sim l}$）都最多只会被枚举到一次，所以复杂度为 $O(P)$。

#### 2. $|S|+|T|\le k$。

此时要求在两串中间填入一串括号使得序列合法。转化为格路计数问题，设 $S_i,T_j$ 内的左右括号数分别为 $sx_i,sy_i,tx_j,ty_j$，则相当于与求从 $(sx_i,sy_i)$ 走到 $(tx_j,ty_j)$ 且不经过直线 $y=x+1$ 的方案数。这是经典的，反射容斥即可，单次复杂度是 $O(1)$ 的。由于需要枚举起点终点，复杂度为 $O(nm)$，无法接受。

发现因为 $sx_i+sy_i=|S_i|$，坐标很大的起点并不会有很多。考虑根号分治：$sx_i+sy_i\le B$ 的点最多只有 $O(B^2)$ 个本质不同，而 $sx_i+sy_i>B$ 的点最多只有 $O(\frac PB)$ 个，所以本质不同的点数为 $O(B^2+\frac PB)=O(P^{2/3})$。这对于终点也是一样的，故只要将坐标相同的点合并即可，时间复杂度为 $O((P^{2/3})^2)=O(P^{4/3})$。

但是我缺的 $P\le 10^7$ 这块谁给我补啊？还需进一步优化。考虑在 $B$ 的范围内先做一个 $O(B^2)$ 的 dp，算出每个点到达横坐标为 $B$ 的点的方案数，然后用横坐标为 $B$ 的这 $O(B)$ 个点代表这些点。对于横坐标 $\le B$ 的终点，可以直接在 dp 数组内查询。这样本质不同点的个数就是 $O(B+\frac PB)=O(\sqrt P)$ 的，复杂度为 $O(P)$，可以通过。

13:35~15:23，代码能力有待提升。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const int MAXN = 2e5 + 10;
const int MAXM = 5e5 + 10;
const int MAXB = 3e3 + 10, B = 3e3;
const int mod = 1e9 + 7;

inline void add(int &x, int y) { x += y, x < mod || (x -= mod); }
inline void sub(int &x, int y) { x -= y, x < 0 && (x += mod); }

inline 
int qpow(int b, int p) {
	int res = 1;
	for (; p; p >>= 1, b = (ll)b * b % mod) if (p & 1) res = (ll)res * b % mod;
	return res;
}

int fac[MAXM << 1], ifac[MAXM << 1]; ull p[MAXM];

inline 
void init(int n) {
	*fac = 1;
	for (int i = 1; i <= n; i++) fac[i] = (ll)fac[i - 1] * i % mod;
	ifac[n] = qpow(fac[n], mod - 2);
	for (int i = n; i; i--) ifac[i - 1] = (ll)ifac[i] * i % mod;
}

inline 
int c(int n, int m) {
	if (n < 0 || m < 0 || n < m) return 0;
	return (ll)fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

inline 
int calc(int sx, int sy, int tx, int ty) {
	if (sx > tx || sy > ty) return 0;
	return c(tx - sx + ty - sy, tx - sx);
}

int n, m, k, ans; string tmp;

vector<string> s[MAXM], t[MAXM];

vector<int> ls, lt, dt[MAXM]; vector<vector<int>> ds[MAXM];

vector<vector<ull>> hs[MAXM], ht[MAXM];

map<pair<int, int>, int> cs, ct;

vector<pair<pair<int, int>, int>> vcs, vct;

int dp[MAXB][MAXB];

int main() {
	scanf("%*d%d%d%d", &n, &m, &k), init(k);
	*p = 1;
	for (int i = 1; i <= 5e5; i++) p[i] = p[i - 1] * 131;
	for (int i = 1; i <= n; i++) {
		cin >> tmp; int l = tmp.length(), c = 0, f = 1;
		for (int j = 0; j < l; j++) if ((tmp[j] == '(' ? ++c : --c) < 0) { f = 0; break; }
		if (!f) continue; int x = 0, y = 0;
		for (int j = 0; j < l; j++) tmp[j] == '(' ? x++ : y++;
		if (x > k || y > k) continue; cs[make_pair(x, y)]++;
		s[l].emplace_back(tmp), ls.emplace_back(l);
		ds[l].emplace_back(vector<int>(l)), c = 0;
		for (int j = 0; j < l; j++) ds[l].back()[j] = (tmp[j] == '(' ? c++ : c--);
		hs[l].emplace_back(vector<ull>(l)), hs[l].back()[0] = tmp[0];
		for (int j = 1; j < l; j++) hs[l].back()[j] = hs[l].back()[j - 1] * 131 + tmp[j];
	}
	sort(ls.begin(), ls.end()), ls.erase(unique(ls.begin(), ls.end()), ls.end());
	for (int i = 1; i <= m; i++) {
		cin >> tmp; int l = tmp.length(), c = 0, f = 1;
		for (int j = l - 1; ~j; j--) if ((tmp[j] == ')' ? ++c : --c) < 0) { f = 0; break; }
		if (!f) continue; int x = k / 2, y = k / 2;
		for (int j = 0; j < l; j++) tmp[j] == '(' ? x-- : y--;
		if (x < 0 || y < 0) continue; ct[make_pair(x, y)]++;
		t[l].emplace_back(tmp), lt.emplace_back(l), dt[l].emplace_back(c);
		ht[l].emplace_back(vector<ull>(l)), ht[l].back()[0] = tmp[0];
		for (int j = 1; j < l; j++) ht[l].back()[j] = ht[l].back()[j - 1] * 131 + tmp[j];
	}
	sort(lt.begin(), lt.end()), lt.erase(unique(lt.begin(), lt.end()), lt.end());
	for (int x : ls) {
		for (int y : lt) {
			if (x + y <= k) continue;
			int l = x + y - k; unordered_map<ull, int> cnt;
			for (int i = 0; i < s[x].size(); i++) {
				ull val = hs[x][i][x - 1];
				if (l < x) val -= hs[x][i][x - l - 1] * p[l];
				cnt[val * 114514191981llu + ds[x][i][x - l]]++;
			}
			for (int i = 0; i < t[y].size(); i++) {
				ull val = ht[y][i][l - 1];
				ans += cnt[val * 114514191981llu + dt[y][i]];
			}
		}
	}
	for (pair<pair<int, int>, int> x : cs) {
		int sx = x.first.first, sy = x.first.second;
		if (sx > B || sy > B) vcs.emplace_back(x);
		else dp[sx][sy] = x.second;
	}
	for (int i = 0; i <= B; i++) {
		for (int j = 0; j <= i; j++) {
			if (i && j < i) add(dp[i][j], dp[i - 1][j]);
			if (j && i < B) add(dp[i][j], dp[i][j - 1]);
		}
	}
	for (int i = 0; i <= B; i++) {
		if (dp[B][i]) vcs.emplace_back(make_pair(make_pair(B, i), dp[B][i]));
	}
	for (pair<pair<int, int>, int> x : ct) vct.emplace_back(x);
	for (pair<pair<int, int>, int> y : vct) {
		int tx = y.first.first, ty = y.first.second;
		if (tx < B) { add(ans, (ll)dp[tx][ty] * y.second % mod); continue; }
		for (pair<pair<int, int>, int> x : vcs) {
			int sx = x.first.first, sy = x.first.second;
			if (sx > tx || sy > ty) continue;
			int res = calc(sx, sy, tx, ty);
			sub(res, calc(sx, sy, ty - 1, tx + 1));
			add(ans, (ll)x.second * y.second % mod * res % mod);
		}
	}
	printf("%d", ans);
}
```

---

## 作者：王熙文 (赞：1)

## 思路

考虑枚举两个字符串 $s,t$，并对合法括号序列计数。

如果 $|s|+|t| \ge k$，则只需要判断它们中间的部分是否相同，以及拼起来是否是一个合法括号序列。前者可以哈希判断，后者可以考虑将左括号设为 $1$，右括号设为 $-1$ 得到一个折线图，那么将 $s$ 正推、$t$ 倒推得到拼接处它们的高度，判断是否相等即可。

如果 $|s|+|t| < k$，仍然使用折线图，可以将问题转化为：坐标系中有两个点 $A,B$，从一个点 $(x,y)$ 出发每次可以走到 $(x+1,y+1)$ 或 $(x+1,y-1)$，要求 $y$ 始终 $\ge 0$，求 $A$ 走到 $B$ 的方案数。

结论：方案数为不考虑 $\ge 0$ 的条件时，$A$ 走到 $B$ 的方案数减去 $A$ 走到 $B$ 关于 $y=-1$ 直线的对称点 $B'$ 的方案数。

证明：只需要证明存在点 $<0$ 的路径数等于 $A$ 走到 $B'$ 的路径数。考虑 $A$ 到 $B$ 的路径中第一次 $<0$ 的位置，将后面的路径关于 $y=-1$ 对称即可得到一条 $A$ 到 $B'$ 的路径，且容易证明不同的 $A$ 到 $B$ 的路径翻折得到的 $A$ 到 $B'$ 的路径不同。将 $A$ 到 $B'$ 的路径按照同样的方式翻折也可以得到 $A$ 到 $B$ 的路径，所以两者一一对应。

对于不考虑 $\ge 0$ 的条件的问题，可以求出向上的个数，然后用组合数计算方案数即可。

回到原问题，设 $s$ 和 $t$ 的长度分别为 $s_1,t_1$，结束时折线的高度分别为 $s_2,t_2$，那么方案数即为：

$${k-s_1-t_1 \choose \frac{k-s_1-t_1-s_2+t_2}{2}}-{k-s_1-t_1 \choose \frac{k-s_1-t_1-2-s_2-t_2}{2}}$$

接下来考虑优化。对于 $|s|+|t| \ge k$ 的情况，可以枚举 $t$ 以及 $t$ 与 $s$ 重合的前缀，那么限制放到 $s$ 上就是：长度为某个数，$s$ 的某个后缀与 $t$ 这个前缀的哈希值相同，那个后缀的前面折线图的高度为某个数。把这三个数压成一个数并放到哈希表里即可。

对于 $|s|+|t| <k$ 的情况，考虑使用 [AT_agc001_e](https://www.luogu.com.cn/problem/AT_agc001_e) 的套路，将组合数转化为两个点每次只能向上或向右的路径数。对于第一个式子，便是求 $\left( \dfrac{t_1+t_2}{2},\dfrac{t_1-t_2}{2}\right )$ 到 $\left( \dfrac{k-(s_1-s_2)}{2},\dfrac{k-(s_1+s_2)}{2}\right)$ 的路径数。但这道题的值域较大，不能直接 dp。

考虑根号分治，$s_1\le B$ 的点会分布在左上角的一个边长为 $B$ 的正方形，$t_1 \le B$ 的点会分布在右下角的一个变成为 $B$ 的正方形。若这两个正方形相交，则 $k \le 2B$，可以直接 dp。接下来只需要解决正方形不相交的情况。发现在右下角的所有点想走到上面一定会经过正方形的边界。考虑对每个边界统计它是某个点第一次走上的边界的路径数，这个问题可以 $\mathcal O(B^2)$ 做。这样就将点数从 $\mathcal O(n)$ 变为 $\mathcal O(B)$ 了。接下来对于左上角的正方形的边界也求出它是某个点第一次走上的边界的路径数，这个问题可以通过枚举右下角的正方形的边界解决。接下来从边界的这些点走到左上角的点即可。

对于 $s_1> B$ 或 $t_1>B$ 的点，只会有 $\dfrac{\sum |S|+\sum |T|}{B}$ 个，枚举剩下的点并暴力计算即可。

时间复杂度：$\mathcal O(\sum |S|+\sum |T|+B^2+n \cdot \dfrac{\sum |S|+\sum |T|}{B})$。

## 代码

将三个数压成一个数可以直接用 `unsigned long long` 存并自然溢出，用 `__int128` 可能过不去。dp 的过程可能需要用滚动数组。理论上 $B$ 应该取 $10^4$，但是过不去。代码中的 $B=4000$。实测 $B=500$ 也能过而且跑得飞快，可能数据比较水。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long 
const int mod=1e9+7; const long long mmod=1e16-63;
void add(int &a,int b) { a=(a+b<mod?a+b:a+b-mod); }
int qpow(int a,int b)
{
	int ans=1;
	while(b!=0)
	{
		if(b%2==1) ans=1ll*ans*a%mod;
		a=1ll*a*a%mod,b/=2;
	}
	return ans;
}
long long base[1000010];
int jc[1000010],invjc[1000010];
inline int C1(int n,int m) { return n<m || m<0?0:1ll*jc[n]*invjc[n-m]%mod*invjc[m]%mod; }
inline long long C2(int n,int m) { return n<m || m<0?0:1ll*jc[n]*invjc[n-m]%mod*invjc[m]; }
inline int get_ans1(int x,int y) { return C1(x+y,x); }
inline long long get_ans2(int x,int y) { return C2(x+y,x); }
int n,m,k;
string s[200010],t[200010];
long long hsh[500010],qzh[500010];
ull now[(1<<25)+10]; int cnt[(1<<25)+10];
void upd(ull x)
{
	int nowx=x&((1<<25)-1);
	while(now[nowx]!=0 && now[nowx]!=x) nowx=(nowx+1145141919)&((1<<25)-1);
	now[nowx]=x,++cnt[nowx];
}
int query(ull x)
{
	int nowx=x&((1<<25)-1);
	while(now[nowx]!=0 && now[nowx]!=x) nowx=(nowx+1145141919)&((1<<25)-1);
	return cnt[nowx];
}
int tot1=0; pair<int,int> a[200010];
int tot2=0; pair<int,int> b[200010];
vector<int> vec[100010],q[100010];
int dp[2][100010];
int dp1[2][50010],dp2[2][50010];
int bj1[50010],bj2[50010],bj3[50010],bj4[50010];
int main()
{
	base[0]=1; for(int i=1; i<=1e6; ++i) base[i]=base[i-1]*131%mmod;
	jc[0]=1; for(int i=1; i<=1e6+5; ++i) jc[i]=1ll*jc[i-1]*i%mod;
	invjc[(int)1e6+5]=qpow(jc[(int)1e6+5],mod-2);
	for(int i=1e6+4; i>=0; --i) invjc[i]=1ll*invjc[i+1]*(i+1)%mod;
	ios::sync_with_stdio(false),cin.tie(0);
	int testid; cin>>testid>>n>>m>>k;
	for(int i=1; i<=n; ++i)
	{
		cin>>s[i];
		hsh[s[i].size()]=0;
		for(int j=s[i].size()-1; j>=0; --j) hsh[j]=(hsh[j+1]+s[i][j]*base[s[i].size()-j-1])%mmod;
		bool flag=1;
		for(int j=0; j<s[i].size(); ++j)
		{
			qzh[j]=(j==0?0:qzh[j-1])+(s[i][j]=='('?1:-1);
			if(qzh[j]<0) { flag=0; break; }
		}
		if(!flag) continue;
		upd(s[i].size()*(ull)1e18+hsh[0]*(ull)1e6);
		for(int j=0; j<s[i].size()-1; ++j) upd(s[i].size()*(ull)1e18+hsh[j+1]*(ull)1e6+qzh[j]);
		int x=s[i].size(),y=qzh[s[i].size()-1];
		a[++tot1]={(x+y)/2,(x-y)/2};
	}
	int ans=0;
	for(int i=1; i<=m; ++i)
	{
		cin>>t[i];
		for(int j=0; j<t[i].size(); ++j) hsh[j]=((j==0?0:hsh[j-1])*131ll+t[i][j])%mmod;
		qzh[t[i].size()]=0;
		bool flag=1;
		for(int j=t[i].size()-1; j>=0; --j)
		{
			qzh[j]=qzh[j+1]+(t[i][j]==')'?1:-1);
			if(qzh[j]<0) { flag=0; break; }
		}
		if(!flag) continue;
		for(int j=0; j<t[i].size(); ++j) add(ans,query((k-t[i].size()+j+1)*(ull)1e18+hsh[j]*(ull)1e6+qzh[0]));
		int x=t[i].size(),y=qzh[0];
		b[++tot2]={(x+y)/2,(x-y)/2};
	}
	k/=2;
	const int lim=4000;
	if(k<=2*lim)
	{
		for(int i=1; i<=tot2; ++i) vec[b[i].first].push_back(b[i].second);
		for(int i=1; i<=tot1; ++i) q[k-a[i].second].push_back(k-a[i].first);
		for(int i=0; i<=k; ++i)
		{
			memset(dp[i&1],0,sizeof(dp[i&1]));
			for(int j:vec[i]) ++dp[i&1][j];
			for(int j=0; j<=k; ++j) add(dp[i&1][j],dp[i-1&1][j]),add(dp[i&1][j],(j==0?0:dp[i&1][j-1]));
			for(int j:q[i]) add(ans,dp[i&1][j]);
		}
		memset(dp[1],0,sizeof(dp[1]));
		for(int i=0; i<=k; ++i) vec[i].clear(),q[i].clear();
		for(int i=1; i<=tot2; ++i) vec[b[i].second].push_back(b[i].first);
		for(int i=1; i<=tot1; ++i) if(a[i].first!=k) q[k+1-a[i].second].push_back(k-1-a[i].first);
		for(int i=0; i<=k+1; ++i)
		{
			memset(dp[i&1],0,sizeof(dp[i&1]));
			for(int j:vec[i]) ++dp[i&1][j];
			for(int j=0; j<=k; ++j) add(dp[i&1][j],dp[i-1&1][j]),add(dp[i&1][j],(j==0?0:dp[i&1][j-1]));
			for(int j:q[i]) add(ans,mod-dp[i&1][j]);
		}
		cout<<ans;
	}
	else
	{
		for(int i=1; i<=tot1; ++i)
		{
			if(a[i].first<=lim) continue;
			for(int j=1; j<=tot2; ++j)
			{
				ans=(ans+get_ans2(k-a[i].second-b[j].first,k-a[i].first-b[j].second)
						-get_ans2(k+1-a[i].second-b[j].second,k-1-a[i].first-b[j].first))%mod;
			}
		}
		for(int j=1; j<=tot2; ++j)
		{
			if(b[j].first<=lim) continue;
			for(int i=1; i<=tot1; ++i)
			{
				if(a[i].first>lim) continue;
				ans=(ans+get_ans2(k-a[i].second-b[j].first,k-a[i].first-b[j].second)
						-get_ans2(k+1-a[i].second-b[j].second,k-1-a[i].first-b[j].first))%mod;
			}
		}
		ans=(ans+mod)%mod;
		for(int i=1; i<=tot2; ++i)
		{
			if(b[i].first<=lim) vec[b[i].first].push_back(b[i].second);
		}
		for(int i=0; i<=lim; ++i)
		{
			memset(dp1[i&1],0,sizeof(dp1[i&1]));
			for(int j:vec[i]) ++dp1[i&1][j];
			for(int j=0; j<=lim; ++j) add(dp1[i&1][j],dp1[i-1&1][j]),add(dp1[i&1][j],(j==0?0:dp1[i&1][j-1]));
			bj1[i]=dp1[i&1][lim];
		}
		for(int i=0; i<=lim; ++i) bj2[i]=dp1[lim&1][i];
		add(bj1[lim],mod-bj1[lim-1]),add(bj1[lim],mod-bj2[lim-1]),bj2[lim]=0;
		for(int i=lim-1; i>=1; --i) add(bj1[i],mod-bj1[i-1]),add(bj2[i],mod-bj2[i-1]);
		for(int i=0; i<=lim; ++i)
		{
			for(int j=0; j<=lim; ++j)
			{
				bj3[i]=(bj3[i]+1ll*bj1[j]*get_ans1(k-(lim-i)-j,k-lim-lim)
							  +1ll*bj2[j]*get_ans1(k-lim-(lim-i),k-lim-j))%mod;
				bj4[i]=(bj4[i]+1ll*bj1[j]*get_ans1(k-lim-j,k-lim-(lim-i))
							  +1ll*bj2[j]*get_ans1(k-lim-lim,k-(lim-i)-j))%mod;
			}
		}
		for(int i=lim; i>=1; --i) add(bj3[i],mod-bj3[i-1]),add(bj4[i],mod-bj4[i-1]);
		for(int i=0; i<=lim; ++i) vec[i].clear();
		for(int i=1; i<=tot1; ++i)
		{
			if(a[i].first<=lim) vec[lim-a[i].second].push_back(lim-a[i].first);
		}
		for(int i=0; i<=lim; ++i)
		{
			memset(dp2[i&1],0,sizeof(dp2[i&1]));
			if(i==0) for(int j=0; j<=lim; ++j) dp2[i&1][j]=bj4[j];
			else dp2[i&1][0]=bj3[i];
			for(int j=0; j<=lim; ++j) add(dp2[i&1][j],dp2[i-1&1][j]),add(dp2[i&1][j],(j==0?0:dp2[i&1][j-1]));
			for(int j:vec[i]) add(ans,dp2[i&1][j]);
		}
		memset(dp1[1],0,sizeof(dp1[1]));
		for(int i=0; i<=lim; ++i) vec[i].clear();
		for(int i=1; i<=tot2; ++i)
		{
			if(b[i].first<=lim) vec[b[i].second].push_back(b[i].first);
		}
		for(int i=0; i<=lim; ++i)
		{
			memset(dp1[i&1],0,sizeof(dp1[i&1]));
			for(int j:vec[i]) ++dp1[i&1][j];
			for(int j=0; j<=lim; ++j) add(dp1[i&1][j],dp1[i-1&1][j]),add(dp1[i&1][j],(j==0?0:dp1[i&1][j-1]));
			bj1[i]=dp1[i&1][lim];
		}
		for(int i=0; i<=lim; ++i) bj2[i]=dp1[lim&1][i];
		add(bj1[lim],mod-bj1[lim-1]),add(bj1[lim],mod-bj2[lim-1]),bj2[lim]=0;
		for(int i=lim-1; i>=1; --i) add(bj1[i],mod-bj1[i-1]),add(bj2[i],mod-bj2[i-1]);
		for(int i=0; i<=lim+2; ++i)
		{
			bj3[i]=bj4[i]=0;
			for(int j=0; j<=lim; ++j)
			{
				bj3[i]=(bj3[i]+1ll*bj1[j]*get_ans1(k-(lim+1-i)-j,k-(lim+1)-lim)
							  +1ll*bj2[j]*get_ans1(k-lim-(lim+1-i),k-(lim+1)-j))%mod;
				bj4[i]=(bj4[i]+1ll*bj1[j]*get_ans1(k-(lim+1)-j,k-lim-(lim+1-i))
							  +1ll*bj2[j]*get_ans1(k-(lim+1)-lim,k-(lim+1-i)-j))%mod;
			}
		}
		for(int i=lim+2; i>=1; --i) add(bj3[i],mod-bj3[i-1]),add(bj4[i],mod-bj4[i-1]);
		memset(dp2[1],0,sizeof(dp2[1]));
		for(int i=0; i<=lim+2; ++i) vec[i].clear();
		for(int i=1; i<=tot1; ++i)
		{
			if(a[i].first<=lim) vec[lim+2-a[i].second].push_back(lim-a[i].first);
		}
		for(int i=0; i<=lim+2; ++i)
		{
			memset(dp2[i&1],0,sizeof(dp2[i&1]));
			if(i==0) for(int j=0; j<=lim+2; ++j) dp2[i&1][j]=bj4[j];
			else dp2[i&1][0]=bj3[i];
			for(int j=0; j<=lim+2; ++j) add(dp2[i&1][j],dp2[i-1&1][j]),add(dp2[i&1][j],(j==0?0:dp2[i&1][j-1]));
			for(int j:vec[i]) add(ans,mod-dp2[i&1][j]);
		}
		cout<<ans;
	}
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：1)

### P11270

令 $L=\sum |S_i|+\sum |T_j|$。定义一个括号串的【和】为将左括号记作 $1$，右括号记作 $-1$ 后求和所得的值。

拆贡献，枚举 $S_i,T_j$ 计算有多少个长度为 $k$ 的 $A$ 以 $S_i$ 为前缀，$T_j$ 为后缀，贡献均为 $1$。对于左括号视为 $1$，右括号视为 $-1$ 时，我们要求 $S_i$ 的任意前缀和都 $\ge 0$，否则这样的 $S_i$ 没有用；对于左括号视为 $-1$，右括号视为 $1$ 时，我们要求 $T_j$ 的任意后缀和都 $\ge 0$，否则这样的 $T_j$ 没有用。

先考虑 $S_i,T_j$ 中间不存在新插入字符的情况，我们可以用 $-1,1$ 用最小前缀和 $=0$ 来进行判定。直接枚举所有的长度为 $len$ 的重叠部分即可。考虑枚举 $T_j$ 计算有多少个 $S$ 合法。此时相当于给定了后面部分的最小前缀和，就要求 $S$ 的和必须 $\geq$ 某个值。你发现你是唐诗，因为最小前缀和完全不用管，你现在保留的 $S,T$ 都是有希望合法的。两部分叠一起自然是有希望合法的，所以只需要判定 $S,T$ 的总和是否 $=0$。直接用哈希刻画相等关系，记录此时 $S$ 所有后缀 $[p,|S_i|]$ 的哈希值以及 $[1,p-1]$ 的和即可。把同个和的放到一起然后用哈希表维护，这部分时间复杂度 $\mathcal O(L)$。

再考虑 $S_i,T_j$ 中间存在插入字符的情况，发现此时要做的是一个反射容斥。具体的，每个前缀可以刻画为点 $(x,y)$ 分别表示左括号，右括号的个数。如果出现 $x<y$ 就寄了，每次移动是 $(x,y)\to (x,y+1),(x+1,y)$。然后如果确定了 $S,T$，起终点都是确定的，需要求的是 $(x_S,y_S)\to (k/2-x_T,k/2-y_T)$ 的方案数。此时就是总数减去穿过直线 $y=x-1$ 的方案数。显然是可以拆贡献的。需要考虑的就是对 $\binom{\Delta x+\Delta y}{\Delta x}-\binom{\Delta x+\Delta y}{by-1-ax}$ 求和。组合数是无法拆开的，考虑一些暴力的方法。

我们可以说明，$(ax,ay)$ 以及 $(bx,by)$ 的本质不同个数各自有 $\mathcal O(L^{2/3})$ 个。首先不考虑 $y$ 是经典的 $\mathcal O(\sqrt L)$ 个。只分析 $x\leq y$ 的话我们贪心放置尽量多的本质不同的点，那么每次加入 $x+y=t$ 的点即可，那么就是 $\sum t^2$ 相关状物，因此可以分析出 $\mathcal O(L^{2/3})$ 的上界。直接暴力匹配两端的等价类可以做到 $\mathcal O(L^{4/3})$ 的。考虑进行根号分治减小等价类个数，可以将 $x,y\leq \sqrt L$ 的点用 dp 推到 $\sqrt L$ 的地方，这样有效减小了等价类个数。这样总时间复杂度 $\mathcal O(L)$。

---

## 作者：wwwwwza (赞：0)

神仙题。

有很多个字符串的计数题一般用根号分治。

先把一看就不是前缀的 $S_i$ 和一看就不是后缀的 $T_j$ 扔掉。

设左括号为 $+1$，右括号为 $-1$。

对于一个合法的前缀 $S_i$，其每一个前缀和都要 $\ge 0$。

对于一个合法的后缀 $T_j$，其每一个后缀和都要 $\le 0$。

设 $N=\sum\left | S_i \right |+ \sum\left | T_j \right |$。

分两种情况讨论。

---
- $\left|S_i\right | +\left|T_j\right |> k$。

有一个小性质：对于总长度为 $N$ 的字符串，不同的字符串长度个数只有 $\sqrt{N}$ 个。

枚举 $S$ 与 $T$ 的长度，时间复杂度是 $O(N)$ 的，计算出重叠部分的长度 $d$，并将 $S_i$ 长度为 $d$ 的后缀、$T_j$ 长度为 $d$ 的前缀扔进哈希表，设重叠部分组成的字符串为 $P$。


可以发现，当 $S_i$ 的前缀和 $T_j$ 的后缀相同，且 $v_{S_i}+v_{T_j}-v_{P}=0$ 可以将 $S_i$ 和 $T_j$ 拼起来。

$v_{S}$ 表示将左括号为 $+1$，右括号为 $-1$ 时 $S$ 的值。

因为不合法的前后缀都被扔掉了，所以只用考虑重叠部分的哈希值和 $v_{S-P+T}$ 是否等于 $0$。

如果不想手写 $O(1)$ 哈希表可以用 map，虽然多一个 $\log$ 但我跑得飞快。

---

- $\left|S_i\right | +\left|T_j\right |\le k$。

考虑求出每一对数对 $(i,j)$ 有多少符合的长度为 $k$ 的括号序列。

若 $S_i$ 为前缀，$T_j$ 为后缀，考虑中间怎么放。

转化为格路计数，横坐标为左括号个数，纵坐标为有括号个数，设 $sx_i$ 为 $S_i$ 的左括号个数，$sy_i$ 为 $S_i$ 的右括号个数，$tx_j$ 为 $\frac{k}{2}$ 减 $T_j$ 的左括号个数，$ty_j$ 为 $\frac{k}{2}$ 减 $T_j$ 的右括号个数。

那么方案数就是从 $(sx_i,sy_i)$ 走到 $(tx_j,ty_j)$ 不经过直线 $y=x+1$ 的格路计数问题。

又一次根号分治，设 $B=\sqrt{\sum\left |S_i \right |}$。

如果 $k$ 比较小，可以直接格路计数，当 $k\le 3\times B$ 的时候直接 $O(k^2)$ 计算。

$sx_i+sy_i>B$ 的个数一定不大于 $\frac{N}{B}$。同理，$tx_j+ty_j<k-B$ 的个数一定不大于 $\frac{N}{B}$。

直接 $O(B^2)$ 格路计数，将 $sx_i+sy_i\le B$ 的坐标走到 $x+y=B$ 的直线上，同理，将 $tx_j+ty_j\ge k-B$ 的坐标走到 $x+y=k-B$ 的直线上。

![](https://cdn.luogu.com.cn/upload/image_hosting/7we12f5o.png)

如图，最后 $S_i$ 和 $T_j$ 只能在三个地方。

$S3$ 和 $T3$ 直接在 $B^2$ 的格路计数表里求。

$S1$ 和 $T1$ 每个只有 $B$ 个点。预处理阶乘和逆元 $O(1)$ 求组合数，时间 $B^2$。

$S1 T2$ 和 $S2 T1$，因为 $S2$ 和 $T2$ 最多只有 $B$ 个，所以还是 $O(B^2)$。对于 $S2T2$也是同理。

因为 $y=x+1$ 的限制，点数还会更少。

因为 $B^2=N$，所以总时间复杂度是 $O(N)$ 的。

---

- 对于不碰线格路计数问题。

对于任意一条碰线的路径，将前面形成的折线全部翻转。

$(x,y)$ 关于 $y=x+1$ 的对称点是 $(y-1,x+1)$。

所以从 $(x_1,y_1)$ 到 $(x_2,y_2)$ 的答案为 $\binom{x_2-x_1+y_2-y_1}{x_2-x_1}-\binom{x_2-x_1+y_2-y_1}{x_2-y_1+1}$。

---
- 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5,M=5e5+10,K=2e6+5;
const int inf=5e5;
const int mod=1e9+7;
const int base=3;
const int B=707;
map<pair<int,int>,int>mp;
int type,n,m,k,vis[M],ans=0,bas[M];
int lens[N],tots=0,lent[N],tott=0,vals[N],valt[N];
int sx[N],sy[N],tx[N],ty[N],fac[K],inv[K];
int ms[N],ls=0,mt[N],lt=0;
vector<int>ps[M],pt[M],hs[N],ht[N],ks[N],kt[N];
string s[N],t[N],str;
int add(int x,int y){
	x+=y;
	return (x>=mod?x-=mod:x);
}
int del(int x,int y){
	x-=y;
	return (x<0?x+mod:x);
}
int ksm(int a,int b){
	int sum=1;
	while(b){
		if(b&1)sum=1ll*sum*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return sum;
}
int c(int n,int m){
	if(n<0||m<0||n<m)return 0;
	return 1ll*(1ll*fac[n]*inv[m]%mod)*inv[n-m]%mod;
}
int calc(int x1,int y1,int x2,int y2){
	return max(del(c(x2-x1+y2-y1,x2-x1),c(x2-x1+y2-y1,x2-y1+1)),0);
}
void init(){
	fac[0]=1;
	for(int i=1;i<=K-5;i++)fac[i]=1ll*i*fac[i-1]%mod;
	inv[K-5]=ksm(fac[K-5],mod-2);
	for(int i=K-6;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	bas[0]=1;
	for(int i=1;i<=inf;i++)bas[i]=1ll*bas[i-1]*base%mod;
	cin >>type>>n>>m>>k;
	for(int i=1,tot=0;i<=n;i++){
		cin >>str;
		int len=str.size(),now=0,cnt=0;
		for(int j=0;j<len;j++)cnt+=(str[j]=='(');
		if(cnt>k/2||len-cnt>k/2)continue;
		for(int j=0;j<len;j++){
			if(str[j]=='(')now++;
			else now--;
			if(now<0)break;
		}
		if(now>=0)s[++tot]=str,vis[len]=1;
		if(i==n){
			n=tot;
			break;
		}
	}
	for(int i=1;i<=inf;i++){
		if(vis[i])lens[++tots]=i;
		vis[i]=0;
	}
	for(int i=1,tot=0;i<=m;i++){
		cin >>str;
		int len=str.size(),now=0,cnt=0;
		for(int j=0;j<len;j++)cnt+=(str[j]=='(');
		if(cnt>k/2||len-cnt>k/2)continue;
		for(int j=len-1;j>=0;j--){
			if(str[j]=='(')now++;
			else now--;
			if(now>0)break;
		}
		if(now<=0)t[++tot]=str,vis[len]=1;
		if(i==m){
			m=tot;
			break;
		}
	}
	for(int i=1;i<=inf;i++){
		if(vis[i])lent[++tott]=i;
		vis[i]=0;
	}
	for(int i=1;i<=n;i++){
		int len=s[i].size();
		ps[len].push_back(i);
		s[i]=" "+s[i];
		hs[i].push_back(0),ks[i].push_back(0);
		for(int j=1;j<=len;j++){
			hs[i].push_back(add(1ll*hs[i][j-1]*base%mod,s[i][j]-'('+1));
			ks[i].push_back(ks[i][j-1]+(s[i][j]=='('?1:-1));
			vals[i]+=(s[i][j]=='(');
		}
	}
	for(int i=1;i<=m;i++){
		int len=t[i].size();
		pt[len].push_back(i);
		t[i]=" "+t[i];
		ht[i].push_back(0),kt[i].push_back(0);
		for(int j=1;j<=len;j++){
			ht[i].push_back(add(1ll*ht[i][j-1]*base%mod,t[i][j]-'('+1));
			kt[i].push_back(kt[i][j-1]+(t[i][j]=='('?1:-1));
			valt[i]+=(t[i][j]=='(');
		}
	}
}
void work1(){
	for(int i=1;i<=tots;i++){
		for(int j=1;j<=tott;j++){
			if(lens[i]+lent[j]<=k)continue;
			int d=lens[i]+lent[j]-k;
			for(int p=0;p<pt[lent[j]].size();p++){
				int id=pt[lent[j]][p];
				mp[make_pair(ht[id][d],kt[id][lent[j]]-kt[id][d])]++;
			}
			for(int p=0;p<ps[lens[i]].size();p++){
				int id=ps[lens[i]][p];
				ans=add(ans,mp[make_pair(
				del(hs[id][lens[i]],1ll*hs[id][lens[i]-d]*bas[d]%mod),-ks[id][lens[i]]
				)]);
			}
			for(int p=0;p<pt[lent[j]].size();p++){
				int id=pt[lent[j]][p];
				mp[make_pair(ht[id][d],kt[id][lent[j]]-kt[id][d])]--;
			}
		}
	}
}
int dp[4*B+5][4*B+5],f[B+5][B+5],g[B+5][B+5];
void work2(){
	if(k<=3*B){
		for(int i=1;i<=tots;i++){
			for(int j=0;j<ps[lens[i]].size();j++){
				int id=ps[lens[i]][j];
				dp[vals[id]][lens[i]-vals[id]]++;
			}
		}
		for(int i=0;i<=k;i++){
			for(int j=0;j<=k;j++){
				if(i<j)continue;
				if(i)dp[i][j]=add(dp[i][j],dp[i-1][j]);
				if(j)dp[i][j]=add(dp[i][j],dp[i][j-1]);
			}
		}
		for(int i=1;i<=tott;i++){
			for(int j=0;j<pt[lent[i]].size();j++){
				int id=pt[lent[i]][j];
				ans=add(ans,dp[k/2-valt[id]][k/2-(lent[i]-valt[id])]);
			}
		}
		return;
	}
	for(int i=1;i<=tots;i++){
		for(int j=0;j<ps[lens[i]].size();j++){
			int id=ps[lens[i]][j];
			sx[id]=vals[id],sy[id]=lens[i]-vals[id];
		}
	}
	for(int i=1;i<=tott;i++){
		for(int j=0;j<pt[lent[i]].size();j++){
			int id=pt[lent[i]][j];
			tx[id]=k/2-valt[id],ty[id]=k/2-(lent[i]-valt[id]);
		}
	}
	for(int i=1;i<=n;i++){
		if(sx[i]+sy[i]<=B)f[sx[i]][sy[i]]++;
	}
	for(int i=0;i<=B;i++){
		for(int j=0;j<=B-i;j++){
			if(i<j)continue;
			if(i)f[i][j]=add(f[i][j],f[i-1][j]);
			if(j)f[i][j]=add(f[i][j],f[i][j-1]);
		}
	}
	for(int i=1;i<=m;i++){
		if(tx[i]+ty[i]>=k-B)g[tx[i]-k/2+B][ty[i]-k/2+B]++;
	}
	for(int i=k/2;i>=k/2-B;i--){//-k/2+B
		for(int j=k/2;j>=k-B-i;j--){
			if(i<j)continue;
			g[i-k/2+B][j-k/2+B]=add(g[i-k/2+B][j-k/2+B],g[i+1-k/2+B][j-k/2+B]);
			g[i-k/2+B][j-k/2+B]=add(g[i-k/2+B][j-k/2+B],g[i-k/2+B][j+1-k/2+B]);
		}
	}
	for(int i=1;i<=n;i++){
		if(sx[i]+sy[i]>=k-B)ans=add(ans,g[sx[i]-k/2+B][sy[i]-k/2+B]);
	}
	for(int i=1;i<=m;i++){
		if(tx[i]+ty[i]<=B)ans=add(ans,f[tx[i]][ty[i]]);
	}
	for(int i=0;i<=B;i++){
		for(int j=0;j<=B;j++){
			int x1=i,y1=B-i,x2=j,y2=(k-B)-(j+k/2-B)-k/2+B;
			ans=add(ans,1ll*calc(x1,y1,x2+k/2-B,y2+k/2-B)*(1ll*f[x1][y1]*g[x2][y2]%mod)%mod);
		}
	}
	for(int i=1;i<=n;i++){
		if(sx[i]+sy[i]>B&&sx[i]+sy[i]<k-B){
			ms[++ls]=i;
			for(int j=0;j<=B;j++){
				int x=j,y=B-j;
				ans=add(ans,1ll*calc(sx[i],sy[i],x+k/2-B,y+k/2-B)*g[x][y]%mod);
			}
		}
	}
	for(int i=1;i<=m;i++){
		if(tx[i]+ty[i]>B&&tx[i]+ty[i]<k-B){
			mt[++lt]=i;
			for(int j=0;j<=B;j++){
				int x=j,y=B-j;
				ans=add(ans,1ll*calc(x,y,tx[i],ty[i])*f[x][y]%mod);
			}
		}
	}
	for(int i=1;i<=ls;i++){
		for(int j=1;j<=lt;j++){
			ans=add(ans,calc(sx[ms[i]],sy[ms[i]],tx[mt[j]],ty[mt[j]]));
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	init();
	work1();
	work2();
	cout <<ans;
	return 0;
}
```

---

## 作者：Petit_Souris (赞：0)

很有想法的一道难题（？）给出题人磕了。

设总串长为 $L\le 2\times 10^7$。

首先我们肯定不能真的去一个一个枚举合法括号串算答案，我们应当枚举 $(i,j)$，计算有多少种方案填完剩下部分使得整个串是个合法括号串。这时候很明显要分 $|S_i|+|T_j|>K$ 和 $|S_i|+|T_j|\le K$ 两种情况考虑了。

### $|S_i|+|T_j|>K$

这时候两个串会出现重合部分。枚举 $i$，枚举重合部分的长度。这时候 $|T_j|$ 已经确定，现在只需要满足剩下三个条件即可：

- $|T_j|$ 的一个前缀和 $|S_i|$ 的对应后缀相等；
- $T_j$ 中的左右括号个数可以使整个串平衡；
- $T_j$ 拼上之后不存在一个前缀右括号比左括号多。

前两个条件容易哈希处理。第三个条件实际上只和 $T_j$ 有关，我们只要限定 $S_i$ 正着读没问题，$T_j$ 反着读没问题（即每个后缀右括号比左括号多）即可。

所以整个过程复杂度为 $\mathcal O(L)$，需要较好的实现，否则常数极大。

### $|S_i|+|T_j|\le K$

这时候中间可能需要补上一段。很容易联想到格路计数，即设 $S_i$ 中有 $sx,sy$ 个左括号 / 右括号，$T_j$ 中有 $tx,ty$ 个左括号 / 右括号，那么一个合法序列相当于一条 $(sx,sy)$ 到 $(\frac{K}{2}-tx,\frac{K}{2}-ty)$ 的路径，且不触碰直线 $y=x+1$。

这是很经典的反射容斥问题，设 $rx=\frac{K}{2}-tx,ry=\frac{K}{2}-ty$，路径数量为 $\binom{rx-sx+ry-sy}{rx-sx}-\binom{rx-sx+ry-sy}{ry-sx-1}$。注意和上面 $|S_i|+|T_j|>K$ 的情况一样，我们还是需要保证 $S_i$ 正着读没问题，$T_j$ 反着读没问题。

直接做是 $\mathcal O(nm)$ 的。观察到本质不同状态数不会很多：对于 $x,y\le B$ 的，有 $\mathcal O(B^2)$ 种；对于 $x,y>B$ 的，由于串长总和为 $L$，至多有 $\mathcal O(\frac{L}{B})$ 种。取 $B=L^{\frac{1}{3}}$ 得到 $\mathcal O(L^{\frac{2}{3}})$，因此复杂度为 $\mathcal O(L^{\frac{4}{3}})$，期望得分 84 分。

能不能再给力一点？根据上面的复杂度证明，我们发现，复杂度瓶颈就在 $x,y\le B$ 的点上。很难不联想到 AGC001E，因此我们可以直接对 $B\times B$ 的网格做 dp，这样 $x,y\le B$ 的点可以转化为一些 $x=B$ 的点，这样至多就只有 $\mathcal O(B+\frac{L}{B})=\mathcal O(\sqrt L)$ 种状态了，总复杂度为 $\mathcal O(L)$，可以通过。

需要注意实现常数，不然可能线性和 4/3 次方一个分。

细节比较多，比如 dp 那部分，不能重复计算，所以要限制最后不能在 $x=B$ 上走；当串长比较少的时候，$S,T$ 的两个 $B\times B$ 区域可能相交，这时候小点到小点的贡献不能重复算。

代码丑得不行。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=1e6+5,L=1e7+5,O=1000,B=3197463,Mod=1e9+7,Mod2=998244353;
const ull B1=13745359827,B2=134957623453,B3=324986543597,B4=2349728432;
ll typ,n,m,_n,_m,K,len,pwb[N],fac[N],ifac[N],ans;
array<ll,2>a[N],b[N];
ll dp[O+5][O+5],dp2[O+5][O+5];
vector<ll>sufa[N],preb[N];
vector<ull>vec1[N],vec2[N];
unordered_map<ull,ll>mp;
unordered_map<ll,ll>S,T;
char s[N];
ll Hp(ll x,ll y){
    return x*Mod+y;
}
ull Ha(ll x,ll y,ll z){
    return 1ull*x*B1+1ull*y*B2+1ull*z*B3;
}
ll pw(ll x,ll p){
    ll res=1;
    while(p){
        if(p&1)res=res*x%Mod;
        x=x*x%Mod,p>>=1;
    }
    return res;
}
ll C(ll x,ll y){
    if(x<y||y<0)return 0;
    return fac[x]*ifac[y]%Mod*ifac[x-y]%Mod;
}
void Upd(ll&x,ll y){
    x+=y;
    if(x>=Mod)x-=Mod;
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    typ=read(),n=read(),m=read(),K=read();
    pwb[0]=1,fac[0]=1;
    rep(i,1,K)pwb[i]=pwb[i-1]*B%Mod;
    rep(i,1,K)fac[i]=fac[i-1]*i%Mod;
    ifac[K]=pw(fac[K],Mod-2);
    per(i,K-1,0)ifac[i]=ifac[i+1]*(i+1)%Mod;
    rep(i,1,n){
        scanf("%s",s+1),len=strlen(s+1);
        array<ll,2>tmp;tmp[0]=tmp[1]=0;
        bool fl=1;
        rep(j,1,len){
            if(s[j]=='(')tmp[0]++;
            else tmp[1]++;
            if(tmp[1]>tmp[0]){
                fl=0;
                break;
            }
        }
        if(fl){
            a[++_n]=tmp;
            sufa[_n].resize(len);
            sufa[_n][len-1]=s[len];
            per(j,len-2,0)sufa[_n][j]=(sufa[_n][j+1]+s[j+1]*pwb[len-j-1])%Mod;
        }
    }
    rep(i,1,m){
        scanf("%s",s+1),len=strlen(s+1);
        array<ll,2>tmp;tmp[0]=tmp[1]=0;
        bool fl=1;
        per(j,len,1){
            if(s[j]=='(')tmp[0]++;
            else tmp[1]++;
            if(tmp[1]<tmp[0]){
                fl=0;
                break;
            }
        }
        if(fl){
            b[++_m]=tmp;
            preb[_m].resize(len);
            preb[_m][0]=s[1];
            rep(j,1,len-1)preb[_m][j]=(preb[_m][j-1]*B+s[j+1])%Mod;
            rep(j,0,len-1){
                if(s[j+1]=='(')tmp[0]--;
                else tmp[1]--;
                vec1[len].push_back(Ha(tmp[1]-tmp[0],preb[_m][j],j+1));
            }
        }
    }
    n=_n,m=_m;
    rep(i,1,n){
        ll sz=sufa[i].size(),c=a[i][0]-a[i][1];
        rep(j,1,sz){
            ll t=K-(sz-j);
            if(t<=0||t>K)continue;
            ll H=sufa[i][sz-j];
            vec2[t].push_back(Ha(c,H,j));
        }
    }
    rep(i,1,K){
        if(!vec1[i].size()||!vec2[i].size())continue;
        sort(vec1[i].begin(),vec1[i].end());
        for(ull x:vec2[i])ans+=upper_bound(vec1[i].begin(),vec1[i].end(),x)-lower_bound(vec1[i].begin(),vec1[i].end(),x);
    }
    ans%=Mod;
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    rep(i,1,n){
        if(a[i][0]<O&&a[i][1]<O)dp[a[i][0]][a[i][1]]++;
        else S[Hp(a[i][0],a[i][1])]++;
    }
    rep(i,0,O-1){
        rep(j,0,i){
            if(!dp[i][j])continue;
            Upd(dp[i+1][j],dp[i][j]);
            Upd(dp[i][j+1],dp[i][j]);
        }
    }
    rep(i,1,m){
        ll bx=K/2-b[i][0],by=K/2-b[i][1];
        if(bx<0||by<0)continue;
        if(bx<O&&by<O)ans=(ans+dp[bx][by])%Mod;
    }
    rep(j,0,O){
        if(dp[O][j])S[Hp(O,j)]=(S[Hp(O,j)]+dp[O][j])%Mod;
    }
    rep(i,1,m){
        if(b[i][0]<O&&b[i][1]<O)dp2[b[i][1]][b[i][0]]++;
        else T[Hp(b[i][0],b[i][1])]++;
    }
    rep(i,0,O-1){
        rep(j,0,i){
            if(!dp2[i][j])continue;
            Upd(dp2[i+1][j],dp2[i][j]);
            Upd(dp2[i][j+1],dp2[i][j]);
        }
    }
    rep(i,1,n){
        ll ax=K/2-a[i][1],ay=K/2-a[i][0];
        if(ax<0||ay<0)continue;
        if(ax<O&&ay<O){
            if(a[i][0]<O&&a[i][1]<O)continue;
            ans=(ans+dp2[ax][ay])%Mod;
        }
    }
    rep(j,0,O){
        if(dp2[O][j])T[Hp(j,O)]=(T[Hp(j,O)]+dp2[O][j])%Mod;
    }
    for(pii p:S){
        ll ax=p.first/Mod,ay=p.first-ax*Mod;
        for(pii q:T){
            ll bx=q.first/Mod,by=q.first-bx*Mod;
            ll tarx=K/2-bx,tary=K/2-by;
            if(ax>tarx||ay>tary)continue;
            ll res=(C(tarx-ax+tary-ay,tary-ay)-C(tarx-ax+tary-ay,tary-ax-1)+Mod)%Mod;
            ans=(ans+res*p.second%Mod*q.second)%Mod;
        }
    }
    write(ans),putchar('\n');
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---


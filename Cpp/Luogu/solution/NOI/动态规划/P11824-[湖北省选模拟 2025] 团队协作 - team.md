# [湖北省选模拟 2025] 团队协作 / team

## 题目描述

小 X 建立的团队一共有 $n$ 名队员，所有队员依次编号为 $1,2\dots n$，作为队长的小 X 编号为 $1$，除了小 X 之外的所有员工均有一个**直系领导** $p_i$，保证 $p_i<i$。同时每一名队员都有一个能力值，其中第 $i$ 名队员的能力值为 $v_i$。

小 X 接到了 $10^{10^{100}}$ 个任务，每一个任务需要派遣团队中一部分的队员。出于团队的特色，小 X 对于对于每一次派出的队员有一定的要求。

1. 队员都不愿意与他的直系领导共同参与任务，如果某次任务中派遣了除小 X 之外的某名队员，则不能派遣这名队员的直系领导。
2. 重复的组队会让队员感到厌烦，所以小 X 希望每一次派出的队员组合都是不同的，也就是对于任意两个任务，都至少存在一名队员只在其中一个任务中被派遣。

对于一次任务，小 X 都会给所有此次任务中被派遣的队员增加一定的积分，其中积分为所有被派遣的员工的**能力值的最大值**。

如果需要满足小 X 的要求，显然无法完成所有的任务，所以小 X 希望你告诉他，在他在满足要求的情况下完成最多的任务之后，每一名队员的积分是多少，由于这个数可能过大，所以小 X 只需要你告诉他积分对 $998\ 244\ 353$ 取模的结果。

## 说明/提示

**【样例 1 解释】**

可以列举出所有可能的派遣队员的方式共有 $13$ 种：

* 派遣编号为 $1$ 的队员，增加的积分为 $1$。
* 派遣编号为 $1,4$ 的队员，增加的积分为 $4$。
* 派遣编号为 $1,4,5$ 的队员，增加的积分为 $4$。
* 派遣编号为 $1,5$ 的队员，增加的积分为 $1$。
* 派遣编号为 $2$ 的队员，增加的积分为 $2$。
* 派遣编号为 $2,3$ 的队员，增加的积分为 $2$。
* 派遣编号为 $3$ 的队员，增加的积分为 $2$。
* 派遣编号为 $3,4$ 的队员，增加的积分为 $4$。
* 派遣编号为 $3,4,5$ 的队员，增加的积分为 $4$。
* 派遣编号为 $3,5$ 的队员，增加的积分为 $2$。
* 派遣编号为 $4$ 的队员，增加的积分为 $4$。
* 派遣编号为 $4,5$ 的队员，增加的积分为 $4$。
* 派遣编号为 $5$ 的队员，增加的积分为 $1$。

由此可得五名队员的积分依次为：$1+4+4+1=10$，$2+2=4$，$2+2+4+4+2=14$，$4+4+4+4+4+4=24$，$4+1+4+2+4+1=16$。

**【样例 2】**

见选手目录下的 `team/team2.in` 与 `team/team2.ans`。

样例 $2$ 满足测试点 $1\sim 2$ 的限制。

**【样例 3】**

见选手目录下的 `team/team3.in` 与 `team/team3.ans`。

样例 $3$ 满足测试点 $4\sim 5$ 的限制。

**【样例 4】**

见选手目录下的 `team/team4.in` 与 `team/team4.ans`。

样例 $4$ 满足测试点 $8\sim 9$ 的限制。

**【样例 5】**

见选手目录下的 `team/team5.in` 与 `team/team5.ans`。

样例 $5$ 满足测试点 $10\sim 11$ 的限制。

**【样例 6】**

见选手目录下的 `team/team6.in` 与 `team/team6.ans`。

样例 $6$ 满足测试点 $15\sim 17$ 的限制。

**【子任务】**

对于全部的测试数据，保证 $2\le n\le 3\times 10^5$，$1\le v_i\le n$，$1\le p_i<i$。

| 测试点 | $n \le$ | 特殊性质 |
| :--: | :--: | :--: |
| $1,2$ | $20$ | 无 |
| $3$ | $100$ | 无 |
| $4,5$ | $500$ | 无 |
| $6,7$ | $1000$ | 无 |
| $8,9$ | $5000$ | 无 |
| $10,11$ | $3\times 10^5$ | $v_i \le 10$ |
| $12\sim 14$ | $10^5$ | 无 |
| $15\sim 17$ | $2\times 10^5$ | 无 |
| $18\sim 20$ | $3\times 10^5$ | 无 |

## 样例 #1

### 输入

```
5
1 1 2 2
1 2 2 4 1
```

### 输出

```
10 4 14 24 16
```

# 题解

## 作者：寻逍遥2006 (赞：23)

原问题等价于对于每一个点 $i$，求树上包含 $i$ 的所有树上独立集的最大点权之和。

## 测试点 $1\sim 2$

暴力枚举派遣的队员的集合，如果其满足限制，则统计其贡献。

时间复杂度 $O(2^nn)$。

## 测试点 $3$

先考虑只求解 $1$ 号点。

尝试计算对于 $k=1,2\dots n$，包含 $1$ 号点，且 $v$ 的最大值**恰好**为 $k$ 的独立集数量，考虑使用树形 DP：

设计 DP 状态 $f_{i,j,0/1}$ 表示在 $i$ 的子树内，选择一个 $v$ 的最大值为 $j$ 的集合，且不包含/包含 $i$ 的集合数量。

求解 $i$ 点的状态时依次将每一个儿子 $v$ 合并。

具体的贡献形式有 $f_{i,j,0}\times (f_{v,k,0}+f_{v,k,1})\to f_{i,\max(j,k),0}$，$f_{i,j,1}\times f_{v,k,0}\to f_{i,\max(j,k),1}$。

单次合并时枚举 $j,k$，时间复杂度 $O(n^2)$。

最终 $1$ 号点的答案就是 $\sum\limits_{i=1}^nif_{1,i,1}$，时间复杂度 $O(n^3)$。

对于每一个点进行这一过程，时间复杂度 $O(n^4)$。

## 测试点 $4\sim 5$

上面的合并结构时 $\max$ 卷积，考虑较为一般的形式：

$h_k=\sum\limits_{\max(i,j)=k}f_ig_j$。

有 $\sum\limits_{k=1}^{m}h_k=\sum\limits_{k=1}^m\sum\limits_{\max(i,j)=k}f_ig_j=\sum\limits_{\max(i,j)\le m}f_ig_j=\left(\sum\limits_{i\le m}f_i\right)\left(\sum\limits_{j\le m}g_j\right)$。

因此，我们对 $f$ 和 $g$ 求前缀和，对位相乘，然后再做差分，就可以得到 $h$。

这样单次合并的复杂度可以优化至 $O(n)$，总时间复杂度优化到 $O(n^3)$。

## 测试点 $4\sim 5$ 另解

考虑放宽限制，计算对于 $k=1,2\dots n$，包含 $1$ 号点，且 $v$ 的最大值**至多**为 $k$ 的独立集数量。

发现这时每一个点只有可以选择和不可选择两种状态，对于单个的 $k$，可以直接树形 DP $O(n)$ 解决。

求解一个点的答案时间复杂度为 $O(n^2)$，总时间复杂度为 $O(n^3)$。

## 测试点 $6\sim 7$

考虑 $k$ 从小到大的过程，每一个点有且仅有一次从不可选择到可选择的变化，因此考虑使用数据结构维护 DP 值变化的过程，这就是经典的动态 DP 问题。

使用树剖线段树总时间复杂度为 $O(n^2\log^2n)$，使用全局平衡二叉树时间复杂度为 $O(n^2\log n)$，但实现效率差距不大，可能需要卡常。

## 测试点 $8\sim 9$

对于每一个点进行一次求解太麻烦了，发现 $4\sim 5$ 的两种做法都是可以使用换根 DP 进行求解，时间复杂度 $O(n^2)$。

## 测试点 $10\sim 11$

注意到在上面的做法中，DP 状态第第二维实际上只与 $v_i$ 的值域有关，更本质得说，只与本质不同的 $v_i$ 的数量有关。

所以复杂度实际上是 $O(Vn)$ 的，其中 $V$ 是本质不同的 $v_i$ 的数量。

## 满分做法

使用**转置原理**求解这个问题。

考虑这样一个问题：记 $a_{i,j}$ 为包含点 $i$ 且 $v$ 最大的点为 $j$ 的独立集数量，那么记 $n$ 阶方阵 $A=(a_{i,j})$。记向量 $a=[v_1,v_2\dots v_n]^\top$，则我们要求的就是向量 $b=Aa$。

考虑这个问题的转置，给每一个点设置一个额外的权值 $w_i$，记 $a'=[w_1,w_2\dots w_n]^\top$，考虑问题 $b'=Aa'$。

这个问题就是：对于每一个 $i$，求所有 $v$ 权值最大值等于 $i$ 的独立集的 $w$ 权值之和的和。

发现新问题是可以使用树剖线段树解决的。

考虑按照点的 $v$ 权值从小到大一次加入每一个点。

实时维护 $f_{i,0/1}$ 表示在 $i$ 的子树内不包含/包含 $i$ 的情况下，可能的独立集数量和 $w$ 权值之和的和。

事实上 $f$ 是一个二元组 $(cnt,val)$。

对其进行的加法和乘法运算分别为 $(cnt_1,val_1)+(cnt_2,val_2)=(cnt_1+cnt_2,val_1+val_2)$，$(cnt_1,val_1)\times (cnt_2,val_2)=(cnt_1\times cnt_2,cnt_1\times val_2+cnt_2\times val_1)$。

首先考虑转移：

$f_{i,0}=\prod\limits_{v\in son_i}(f_{v,1}+f_{v,0}),f_{i,1}=op_i\prod\limits_{v\in son_i}f_{v,0}$。

其中 $op_i$ 在 $i$ 还没有出现过是为 $(0,0)$，在 $i$ 出现过之后为 $(1,w_i)$，单独将重儿子 $u$ 提取出来，此时记 $son_i$ 为除 $u$ 之外的所有儿子，那么就可以得到矩阵转移：

$\begin{bmatrix}f_{i,0}\\f_{i,1}\end{bmatrix}=\begin{bmatrix}\prod\limits_{v\in son_i}(f_{v,0}+f_{v,1})&\prod\limits_{v\in son_i}(f_{v,0}+f_{v,1})\\op\prod\limits_{v\in son_i}f_{v,0}&0\end{bmatrix}\begin{bmatrix}f_{u,0}\\f_{u,1}\end{bmatrix}$

不妨记这个矩阵为 $B_i$。每一次修改相当于修改一个点 $u$ 的 $op$，考虑修改之后，矩阵 $B$ 会发生变化的位置只有 $u$ 到根的路径上跳轻边跳到的点，根据重链剖分的性质，这样个点只有 $O(\log n)$ 个。

对于每一个节点建立维护 $B$ 矩阵中的两个连乘 $\prod\limits_{v\in son_i}(f_{v,0}+f_{v,1})$ 和 $\prod\limits_{v\in son_i}f_{v,0}$ 的线段树，这样就能够支持对于单个轻儿子的 $f$ 的修改。

同时对于每一条重链维护矩阵 $B$ 的线段树，这样边能够支持对于单个 $B$ 的修改以及链顶节点的 $f$ 值得查询。

具体的修改过程，就是根据计算出的 $\prod\limits_{v\in son_i}(f_{v,0}+f_{v,1})$ 和 $\prod\limits_{v\in son_i}f_{v,0}$ 的值更新新的 $B_u$。就可以通过整条链上面的矩阵来计算出新的 $f_{top_u,0}$ 和 $f_{top_u,1}$，然后就可以更新 $fa_{top_u}$ 的线段树，以此类推一直更新到 $f_{1,0}$ 和 $f_{1,1}$。

因此按照 $v$ 从小到大修改每一个 $u$，每一次修改后 $f_{1,0}+f_{1,1}$ 的增加量就是所有包含 $u$ 且以 $u$ 为最大值的独立集数量以及重量之和。

假设每 $i$ 次修改之后 $f_{1,0}+f_{1,1}$ 的值为 $las_i$。

那么对于第 $i$ 小的来说答案就是 $las_i-las_{i-1}$ 的第二维。

发现所有对于第二维的操作都是形如 $a_i\gets a_i+a_j\times k$ 的操作，所以对其进行转置操作有 $a_j\gets a_j+a_i\times k$。

对于第二维的加法，都可以写成 $val_1\gets val_1+val_2$ 的形式，因此转置之后有 $val_2\gets val_1+val_2$，减法同理。

对于第二维的乘法，可以写成 $val_3\gets val_3+val_1\times cnt_2+val_2\times cnt_1$ 的形式，因此转置之后有 $val_1\gets val_1+val_3\times cnt_2$，$val_2\gets val_2+val_3\times cnt_1$。

因此可以直接封装出所有操作的逆，然后倒序执行之前执行过的所有操作即可。

时间复杂度 $O(n\log^2n)$，空间复杂度 $O(n\log n)$ 或 $O(n)$。

可以将树剖线段树替换成全局平衡二叉树，将时间复杂度优化至 $O(n\log n)$，但实际效率差距不大。

---

## 作者：min_inf (赞：7)

场上以为是一坨就打了个 $O(nV)$ 的暴力跑路还被卡常了，赛后想了下还是有非常好写的做法的。

题目需要求的就是一个点选上的状态对答案的贡献。

先考虑一个点怎么做。考虑从小到大加入点，动态 DP 维护一下 $\le i$ 的点的方案数。最终在 $n$ 处产生 $n$ 的贡献，在 $i$ 处产生 $-1$ 的贡献，这样贡献加起来就是一个方案的最大值。

注意到转移过程只有一个终点但是有 $n$ 个起点，考虑在转移图上从后往前做。在静态 top tree 上维护一个类似主席树的结构，每次修改一个点就更新一条链，然后给新的根一个贡献，最后再从上往下 DP 一遍。（应该就是官方题解中的转置原理）

但是这样需要 $O(n\log n)$ 的空间还要维护八个状态，空间有点爆。认真观察一下发现从大往小删点的话一个结点往下转移完了就再也没用了，类似一个 `pushdown` 的过程，每次删点一路 `pushdown` 到这个点加入这个点的答案，然后清空从上往下的转移值再删掉点重新 DP 一下这条链，这样我们就能在 $O(n\log n)$ 的时间和 $O(n)$ 的空间内解决这道题。

代码非常好写！！！111

```cpp
void psu(int x){
    int l=ls[x],r=rs[x];
    rep(a,0,1)rep(b,0,1)f[x][a][b]=0;
    if(typ[x]){
        rep(a,0,1)rep(b,0,1)rep(c,0,1)rep(d,0,1)if(!b||!c)Add(f[x][a][d],mul(f[l][a][b],f[r][c][d]));
    }
    else{
        rep(a,0,1)rep(b,0,1)rep(c,0,1)rep(d,0,1)Add(f[x][a||c][d],mul(f[l][a][b],f[r][c][d]));
    }
}
void psd(int x){
    int l=ls[x],r=rs[x];
    if(typ[x]){
        rep(a,0,1)rep(b,0,1)rep(c,0,1)rep(d,0,1)if(!b||!c){
            Add(g[l][a][b],mul(g[x][a][d],f[r][c][d]));
            Add(g[r][c][d],mul(g[x][a][d],f[l][a][b]));
        }
    }
    else{
        rep(a,0,1)rep(b,0,1)rep(c,0,1)rep(d,0,1){
            Add(g[l][a][b],mul(g[x][a||c][d],f[r][c][d]));
            Add(g[r][c][d],mul(g[x][a||c][d],f[l][a][b]));
        }
    }
    rep(a,0,1)rep(b,0,1)g[x][a][b]=0;
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin>>n;
    rep(i,2,n)cin>>tf[i],G[tf[i]].push_back(i);
    rep(i,1,n)cin>>a[i],vc[a[i]].push_back(i);
    dfs1(1),tot=n,dfs2(1);
    rep(i,1,tot)f[i][0][0]=1;
    rep(i,1,n)for(auto x:vc[i]){
        f[x][1][1]=1;
        while(x=fa[x])psu(x);
    }
    per(i,n,1){
        rep(a,0,1)rep(b,0,1)Add(g[tot][a][b],i==n?n:mod-1);
        for(auto x:vc[i]){
            static int stk[100];
            int tp=0,y=x;
            while(y)stk[++tp]=y,y=fa[y];
            per(i,tp,2)psd(stk[i]);
            Add(ans[x],g[x][1][1]);
            f[x][1][1]=0;
            while(x=fa[x])psu(x);
        }
    }
    rep(i,1,n)cout<<ans[i]<<" \n"[i==n];
}
```

---

## 作者：_Ch1F4N_ (赞：5)

luogu 同步赛场上开文件喜提 $0$ 分，希望能为省选攒 rp 吧。

给出一种基于静态 Top tree 的做法。

不妨令 $dp_{i,j}$ 表示加入小于等于 $i$ 的点时，包含点 $j$ 的独立集数。

显然有 $ans_j = \sum_{i=1}^n i \times (dp_{i,j}-dp_{i-1,j})$。

拆下贡献，$ans_j = \sum_{i=0}^{n-1} -dp_{i,j} + dp_{n,j} \times n$。

先考虑怎么计算包含一个点的独立集数。

考虑使用静态 Top tree 来先处理一个形如：对点修改，求独立集数的问题。

不妨对每个簇设计一个状态 $f_{0/1,0/1}$ 表示上下界点是否选择的前提下，簇内选独立集方案数。

然后我们考虑在合并两个簇时，通过新簇的 $f$ 贡献到最后的独立集数的系数来求出在合并过程中被删去的界点必选时的独立集数。

也就是只需要再维护一个 $g_{0/1,0/1}$ 表示 $f$ 贡献到总独立集数的贡献系数即可。

但是我们需要从大往小，边删点，改变贡献路径上的贡献系数边给根簇的 $g$ 加系数。

考虑将 $g$ 作为一个类似懒标记的东西，在删点产生的修改链上下传 $g$ 到儿子簇与在合并过程中被删去的界点的答案数组即可。

时间复杂度 $O(n \log n)$ 空间 $O(n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int maxn = 3e5+114;
struct toptree{
	int f[2][2];
	int g[2][2];
	int fa,ls,rs;
	char ty;
	int id;
	int u,v;
	int key;
}CL[maxn<<1];
int tot;
int ans[maxn];
int fa[maxn];
int fapos[maxn];
vector<int> E[maxn];
int sz[maxn],son[maxn];
int begpos[maxn];
void dfs1(int u){
	sz[u]=1;
	for(int v:E[u]){
		fapos[v]=++tot;
		CL[fapos[v]].u=u,CL[fapos[v]].v=v;
		CL[fapos[v]].id=fapos[v];
		CL[fapos[v]].f[0][1]=CL[fapos[v]].f[1][0]=CL[fapos[v]].f[0][0]=1;
		begpos[v]=fapos[v];
		dfs1(v);
		if(sz[v]>sz[son[u]]) son[u]=v;
		sz[u]+=sz[v];
	}
}
vector<int> top[maxn];
void dfs2(int u,int tp){
	top[tp].push_back(u);
	if(son[u]!=0) dfs2(son[u],tp);
	for(int v:E[u]){
		if(v!=son[u]) dfs2(v,v);
	}
}
int stk[maxn],pre[maxn],tp;
void pushup(toptree &x){
	if(x.key==0) return ;
	for(int i=0;i<2;i++){
		for(int j=0;j<2;j++) x.f[i][j]=0;
	}
	if(x.ty=='C'){
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++) x.f[i][k]=(1ll*x.f[i][k]+1ll*CL[x.ls].f[i][j]*CL[x.rs].f[j][k])%mod;
			}
		}			
	}else{
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++) x.f[i][k]=(1ll*x.f[i][k]+1ll*CL[x.ls].f[i][j]*CL[x.rs].f[i][k])%mod;
			}
		}		
	}
}
void compress(toptree &x,toptree &y,toptree &w){
	w.u=x.u,w.v=y.v,w.key=x.v;
	w.ty='C';
	w.ls=x.id,w.rs=y.id;
	x.fa=y.fa=w.id;
	pushup(w);
}
void rake(toptree &x,toptree &y,toptree &w){
	w.u=y.u,w.v=y.v,w.key=x.v;
	w.ls=x.id,w.rs=y.id;
	w.ty='R';
	x.fa=y.fa=w.id;
	pushup(w);
}
int solve(int l,int r,char ty){
	if(l==r) return stk[l];
	int lt=l,rt=r;
	while(lt+1<rt){
		int mid=(lt+rt)>>1;
		if((pre[mid]-pre[l-1])*2<=(pre[r]-pre[l-1])) lt=mid;
		else rt=mid;
	}
	int lson=solve(l,lt,ty);
	int rson=solve(lt+1,r,ty);
	tot++;
	CL[tot].id=tot;
	if(ty=='C') compress(CL[lson],CL[rson],CL[tot]);
	else rake(CL[lson],CL[rson],CL[tot]);
	return tot;
}
void dfs3(int u){
	for(int v:top[u]){
		for(int w:E[v]){
			if(w!=son[v]) dfs3(w);
		}
		tp=0;
		for(int w:E[v]){
			if(w!=son[v]){
				stk[++tp]=fapos[w];
				pre[tp]=sz[w];
			}
		}
		if(son[v]!=0){
			stk[++tp]=fapos[son[v]];
			pre[tp]=1;
			for(int i=1;i<=tp;i++) pre[i]+=pre[i-1];
			fapos[son[v]]=solve(1,tp,'R');
		}
	}
	tp=0;
	for(int v:top[u]){
		if(v!=1){
			stk[++tp]=fapos[v];
			pre[tp]=sz[fa[v]]-sz[v];
		}
	}
	for(int i=1;i<=tp;i++) pre[i]+=pre[i-1];
	fapos[u]=solve(1,tp,'C');
}
void pushdown(toptree &w){
	if(w.key==0) return ;
	if(w.ty=='C'){
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				ans[w.key]=(1ll*ans[w.key]+1ll*w.g[i][j]*CL[w.ls].f[i][1]%mod*CL[w.rs].f[1][j]%mod)%mod;
			}
		}
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					//ls
					CL[w.ls].g[i][j]=(1ll*CL[w.ls].g[i][j]+1ll*CL[w.rs].f[j][k]*w.g[i][k])%mod;
					//rs
					CL[w.rs].g[j][k]=(1ll*CL[w.rs].g[j][k]+1ll*CL[w.ls].f[i][j]*w.g[i][k])%mod;
				}
			}
		}
	}else{
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				ans[w.key]=(1ll*ans[w.key]+1ll*w.g[i][j]*CL[w.ls].f[i][1]%mod*CL[w.rs].f[i][j]%mod)%mod;
			}
		}
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					//ls
					CL[w.ls].g[i][j]=(1ll*CL[w.ls].g[i][j]+1ll*CL[w.rs].f[i][k]*w.g[i][k])%mod;
					//rs
					CL[w.rs].g[i][k]=(1ll*CL[w.rs].g[i][k]+1ll*CL[w.ls].f[i][j]*w.g[i][k])%mod;
				}
			}
		}
	}
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++) w.g[i][j]=0;
}
void todown(int x){
	if(CL[x].fa!=0) todown(CL[x].fa);
	pushdown(CL[x]);
}
void upd(int x){
	pushup(CL[x]);
	if(CL[x].fa!=0) upd(CL[x].fa);
}
int v[maxn];
vector<int> vec[maxn];
int n;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>fa[i];
		E[fa[i]].push_back(i);
	}
	dfs1(1);
	dfs2(1,1);
	dfs3(1);
	for(int i=1;i<=n;i++){
		cin>>v[i];
		vec[v[i]].push_back(i);
	}
	int root=fapos[1];
	for(int i=n;i>=0;i--){
		int add=(i==n?n:(mod-1));
		ans[CL[root].u]=(1ll*ans[CL[root].u]+(1ll*CL[root].f[1][0]+1ll*CL[root].f[1][1])%mod*add%mod)%mod;
		ans[CL[root].v]=(1ll*ans[CL[root].v]+(1ll*CL[root].f[0][1]+1ll*CL[root].f[1][1])%mod*add%mod)%mod;
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				CL[root].g[i][j]=(1ll*CL[root].g[i][j]+1ll*add)%mod;
			}
		}
		for(int x:vec[i]){
			for(int y:E[x]){
				todown(begpos[y]);
			}
			if(fa[x]!=0) todown(begpos[x]);
		}
		for(int x:vec[i]){
			for(int y:E[x]){
				CL[begpos[y]].f[1][0]=0;
				upd(begpos[y]);
			}
			if(fa[x]!=0){
				CL[begpos[x]].f[0][1]=0;
				upd(begpos[x]);
			}
		}
	}
	for(int i=tot;i>=1;i--) pushdown(CL[i]);
	for(int i=1;i<=n;i++) cout<<ans[i]<<' ';
	return 0;
}
```

---

## 作者：littlez_meow (赞：2)

### 题意

对每个点求出包含这个点的所有独立集中点权最大值的和，对 $998244353$ 取模。

### 思路

我们称节点 $i$ 的点权比节点 $j$ 大当且仅当 $v_i>v_j$ 或 $v_i=v_j,i>j$。

考虑转置原理。设 $a_{i,j}$ 表示包含点 $i$ 且点权最大的点为 $j$ 的独立集个数，$n$ 阶方阵 $A=(a_{i,j})$，列向量 $\vec{a}=[v_1,v_2,\cdots,v_n]^{\top}$，则答案向量为 $\vec b=A\vec a$。

它的转置问题即为：对于每个 $i$，求满足 $i$ 是独立集中点权最大的点的所有独立集的点权和。

按点权从小到大加入每个点，加入点 $i$ 时所有独立集点权和的变化量就是 $i$ 的答案。在这里，一个点被加入指的是可以在独立集中出现，未被加入指的是不能出现在独立集中。

这是一个经典的 ddp 问题，我们使用静态 top tree 解决。对每个簇设 $f(0/1,0/1),g(0/1,0/1)$ 分别表示不选/选上界点、不选/选下界点的独立集方案数和权值和，转移是显然的。值得注意的是，此处 $g(1,*)$ 我们不计入上界点的贡献。可以新建一个虚点 $0$ 作为 $1$ 的父亲方便统计答案。

如果把 $f$ 视为常量（矩阵里的量），则转移关于 $g$ 是线性的。

需要注意，你可以把 ddp 的每次修改看成持久化的，即我们修改的时候变量所占用的内存都是不同的，需要先赋值一次。

然后转置就行了。时间复杂度 $O(n\log n)$。发现我们实际上并不需要持久化，每次直接覆盖就行，所以空间 $O(n)$。如果还是不明白可以看代码，注释里标了转置前后的内容。

事实上，用转置原理得到的做法和其他几篇直接用 top tree 得到的做法是一样的。

### 代码

```cpp
#include <bits/stdc++.h>
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define fi first
#define se second
using namespace std;
const int MAXN=3e5+2,MOD=998244353;
int n;
pair<int,int>val[MAXN];
int cnt;
struct Node{
	short type;//-1unit,0rake,1compress
	int up,dn,mid;
	int siz,lc,rc,fa;
	ll f[2][2],g[2][2];
	Node(const int&t=-1,const int&d=0,const int&e=0,const int&a=1,const int&b=0,const int&c=0){
		type=t,siz=a,lc=b,rc=c,up=d,dn=e,fa=0;
		memset(f,0,sizeof(f)),memset(g,0,sizeof(g));
		return;
	}
}node[MAXN<<1];
bool isin[MAXN]; 
inline void upd(int now){
	Node&qwq(node[now]),&l(node[qwq.lc]),&r(node[qwq.rc]);
	memset(qwq.f,0,sizeof(qwq.f));
	if(node[now].type) F(i,0,1) F(j,0,1) F(k,0,isin[l.dn]) qwq.f[i][j]=(qwq.f[i][j]+l.f[i][k]*r.f[k][j])%MOD;
	else F(i,0,1) F(j,0,1) F(k,0,isin[r.dn]) qwq.f[i][j]=(qwq.f[i][j]+l.f[i][j]*r.f[i][k])%MOD;
	return;
}
inline void psd(int now){
	Node&qwq(node[now]),&l(node[qwq.lc]),&r(node[qwq.rc]);
	if(node[now].type){
		/*
		转置前 
		F(i,0,1) F(j,0,1) F(k,0,isin[l.dn]){
			qwq.g[i][j]=(qwq.g[i][j]+l.f[i][k]*r.g[k][j])%MOD;
			qwq.g[i][j]=(qwq.g[i][j]+l.g[i][k]*r.f[k][j])%MOD;
		}
		*/ 
		F(i,0,1) F(j,0,1) F(k,0,isin[l.dn]){
			r.g[k][j]=(r.g[k][j]+l.f[i][k]*qwq.g[i][j])%MOD;
			l.g[i][k]=(l.g[i][k]+r.f[k][j]*qwq.g[i][j])%MOD;
		}//倒不倒序不影响 
	}else{
		/*
		转置前 
		F(i,0,1) F(j,0,1) F(k,0,isin[r.dn]){
			qwq.g[i][j]=(qwq.g[i][j]+l.f[i][j]*r.g[i][k])%MOD;
			qwq.g[i][j]=(qwq.g[i][j]+l.g[i][j]*r.f[i][k])%MOD;
		}
		*/ 
		F(i,0,1) F(j,0,1) F(k,0,isin[r.dn]){
			r.g[i][k]=(r.g[i][k]+l.f[i][j]*qwq.g[i][j])%MOD;
			l.g[i][j]=(l.g[i][j]+r.f[i][k]*qwq.g[i][j])%MOD;
		}
	}
	memset(qwq.g,0,sizeof(qwq.g));
	return;
}
inline int merge(int x,int y,int type){
	node[x].fa=node[y].fa=++cnt;
	node[cnt]=Node(type,node[x].up,node[type?y:x].dn,node[x].siz+node[y].siz,x,y);
	return upd(cnt),cnt;
}
#define Poi vector<int>::iterator
int build(Poi l,Poi r,int type){
	if(l==r) return 0;
	if(l+1==r) return *l;
	int sum=0,all=0;
	for(auto it=l;it!=r;++it) all+=node[*it].siz;
	Poi mid=l+1;
	for(auto it=l;it!=r;++it){
		sum+=node[*it].siz;
		if(sum*2<=all) mid=it+1;
		else break;
	}
	return merge(build(l,mid,type),build(mid,r,type),type);
}
int siz[MAXN],fa[MAXN],son[MAXN],rt[MAXN];//根为 cnt 
vector<int>g[MAXN];
void dfs1(int now){
	siz[now]=1;
	node[now]=Node(-1,fa[now],now);
	node[now].f[0][0]=node[now].f[1][0]=node[now].f[0][1]=1;
	isin[now]=1;
	for(int i:g[now]){
		dfs1(i);
		siz[now]+=siz[i];
		if(siz[son[now]]<siz[i]) son[now]=i;
	}
	return;
}
void dfs2(int now,bool heavy){
	if(son[now]) dfs2(son[now],1);
	for(int i:g[now]) if(i!=son[now]) dfs2(i,0);
	if(!heavy){
		vector<int>chain;
		chain.push_back(now);
		for(int i(son[now]);i;i=son[i]){
			vector<int>sub({i});
			for(int j:g[fa[i]]) if(j!=i) sub.push_back(rt[j]);
			chain.push_back(build(sub.begin(),sub.end(),0));
		}
		rt[now]=build(chain.begin(),chain.end(),1);
	}
	return;
}
int ans[MAXN];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	F(i,2,n) cin>>fa[i],g[fa[i]].push_back(i);
	F(i,1,n) cin>>val[i].fi,val[i].se=i;
	sort(val+1,val+n+1);
	dfs1(1),cnt=n,dfs2(1,0);
	R(i,n,1){//倒序执行 
		/*
		转置前 (ans[i]-ans[i-1])+=node[cnt].g[0][0/1] 
		转置后倒序变成 node[cnt].g[0][0/1]+=val[i]-val[i+1] 
		*/
		node[cnt].g[0][0]=(node[cnt].g[0][0]+val[i].fi-val[i+1].fi+MOD)%MOD;
		if(isin[node[cnt].dn]) node[cnt].g[0][1]=(node[cnt].g[0][1]+val[i].fi-val[i+1].fi+MOD)%MOD;
		int now=val[i].se,tp=0;
		static int path[MAXN];
		while(node[now].fa) path[++tp]=node[now].fa,now=path[tp];
		R(j,tp,1) psd(path[j]);//从上到下倒序执行 
		now=val[i].se;
		ans[now]=node[now].g[0][1],node[now].g[0][1]=0;//node[now].g[0][1]=val[now]的转置 
		isin[now]=0,node[now].f[0][1]=0; 
		while(node[now].fa) upd(node[now].fa),now=node[now].fa;//按原顺序更新常量（矩阵里的量） 
	}
	F(i,1,n) cout<<ans[i]<<" "; 
	return 0;
}
```

---

## 作者：Lgx_Q (赞：1)

感觉只要想到静态 Top Tree 就会这个题了。

我们可以默认所有方案的贡献都为 $n$，然后枚举 $i = 1\dots n - 1$，给所有只选择权值 $\le i$ 的点的方案贡献减一。然后换根求出包含每个点的独立集个数，这样可以做到 $\mathtt {55pts}$。

建立静态 Top Tree，设 $fas(p, 0/1, 0/1)$ 表示 Top Tree 上的点 $x$ 的上界点是/否选择，下界点是/否选择，此时树簇 $p$ 内所有点的独立集方案数。

每次给当前所有合法独立集增加贡献 $v$ 时，我们考虑在 Top Tree 上每个点 $p$ 维护一个标记 $tag(p, 0/1, 0/1)$ 表示 $x$ 的上界点是/否选择，下界点是/否选择，此时所有贡献乘上对应树簇外方案数的总和。

设 $p$ 的左右儿子为 $lc_p$ 和 $rc_p$。以 compress 为例，我们给点 $p$ 下传标记的时候，设上、下界点的选择状态为 $i$ 和 $j$，枚举中间界点的选择状态 $k$，更新 $tag(lc_p, i, k) \xleftarrow{+} tag(p, i, j)\times fas(rc_p, k, j)$，右儿子同理。

从大到小枚举值域的过程中，我们会修改若干个点强制不能被选，每次修改时先将路径上的点都 pushdown，修改后往上 pushup 更新 fas 的值。

时间复杂度 $\mathcal O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned ll
#define fi first
#define se second
#define mkp make_pair
#define pir pair <ll, ll>
#define pb push_back
#define i128 __int128
using namespace std;
char buf[1 << 22], *p1, *p2;
// #define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, (1 << 22) - 10, stdin), p1 == p2)? EOF : *p1++)
template <class T>
const inline void rd(T &x) {
	char ch; bool neg = 0;
	while(!isdigit(ch = getchar()))
		if(ch == '-') neg = 1;
	x = ch - '0';
	while(isdigit(ch = getchar()))
		x = (x << 1) + (x << 3) + ch - '0';
	if(neg) x = -x;
}
const ll maxn = 6e5 + 10, inf = 1e18, mod = 998244353, iv = mod - mod / 2;
ll power(ll a, ll b = mod - 2, ll p = mod) {
	ll s = 1;
	while(b) {
		if(b & 1) s = 1ll * s * a % p;
		a = 1ll * a * a % p, b >>= 1;
	} return s;
}
template <class T, class _T>
const inline ll pls(const T x, const _T y) { return x + y >= mod? x + y - mod : x + y; }
template <class T, class _T>
const inline void add(T &x, const _T y) { x = x + y >= mod? x + y - mod : x + y; }
template <class T>
const inline void chkmax(T &x, const T y) { x = x < y? y : x; }
template <class T>
const inline void chkmin(T &x, const T y) { x = x < y? x : y; }

ll n, q, b[maxn];
vector <ll> to[maxn];

namespace Build_TopTree {
	ll tot, lc[maxn], rc[maxn], op[maxn];
	ll siz[maxn], son[maxn], nowid[maxn], fa[maxn], ft[maxn];
	vector <ll> nd, nds;
	void dfs1(ll u, ll f = 0) {
		siz[u] = 1;
		for(ll v: to[u])
			if(v ^ f) {
				dfs1(v, u), siz[u] += siz[v];
				if(siz[v] > siz[son[u]]) son[u] = v;
			}
	}
	ll build(ll l, ll r, ll o) {
		if(l == r) return nd[l];
		ll w = nds[r] - (l? nds[l - 1] : 0), lo = l, hi = r - 2;
		while(lo <= hi) {
			ll mid = lo + hi >> 1;
			if((nds[mid] - (l? nds[l - 1] : 0)) * 2 < w) lo = mid + 1;
			else hi = mid - 1;
		}
		ll x = lo, a = build(l, x, o), b = build(x + 1, r, o), id = ++tot;
		op[id] = o, ft[id] = ft[nd[o == 1? r : l]];
		return fa[lc[id] = a] = fa[rc[id] = b] = id;
	}
	void dfs2(ll u, ll f = 0, bool istp = true) {
		nowid[u] = ft[u] = u;
		for(ll v: to[u])
			if(v != f && v != son[u]) dfs2(v, u);
		if(son[u]) {
			dfs2(son[u], u, false);
			nd.clear(), nds.clear();
			nd.pb(nowid[son[u]]), nds.pb(1);
			for(ll v: to[u])
				if(v != son[u] && v != f)
					nd.pb(nowid[v]), nds.pb(siz[v]);
			for(ll i = 1; i < nds.size(); i++) nds[i] += nds[i - 1];
			nowid[son[u]] = build(0, nd.size() - 1, 2);
			if(istp) {
				nd.clear(), nds.clear();
				for(ll x = u; x; x = son[x])
					nd.pb(nowid[x]), nds.pb(siz[x] - siz[son[x]]);
				for(ll i = 1; i < nds.size(); i++) nds[i] += nds[i - 1];
				nowid[u] = build(0, nd.size() - 1, 1);
			}
		}
	}
} using namespace Build_TopTree;

ll tag[maxn][2][2], fas[maxn][2][2], a[maxn], rt;
vector <ll> vec[maxn];

namespace Pushdown {
	void pushdown_compress(ll x) {
		ll t = a[ft[lc[x]]];
		for(ll i = 0; i < 2; i++)
			for(ll j = 0; j < 2; j++)
				for(ll k = 0; k <= t; k++)
					add(tag[lc[x]][i][k], tag[x][i][j] * fas[rc[x]][k][j] %mod),
					add(tag[rc[x]][k][j], tag[x][i][j] * fas[lc[x]][i][k] %mod);
	}
	void pushdown_rake(ll x) {
		ll t = a[ft[rc[x]]];
		for(ll i = 0; i < 2; i++)
			for(ll j = 0; j < 2; j++) {
				add(tag[lc[x]][i][j], tag[x][i][j]
				 * (fas[rc[x]][i][0] + fas[rc[x]][i][1]) %mod);
				add(tag[rc[x]][i][0], tag[x][i][j] * fas[lc[x]][i][j] %mod);
				if(t) add(tag[rc[x]][i][1], tag[x][i][j] * fas[lc[x]][i][j] %mod);
			}
	}
	void pushdown(ll x) {
		if(op[x] == 1) pushdown_compress(x);
		else pushdown_rake(x);
		memset(tag[x], 0, sizeof tag[x]);
	}
} using namespace Pushdown;

namespace Pushup {
	void pushup_compress(ll x) {
		ll t = a[ft[lc[x]]];
		for(ll i = 0; i < 2; i++)
			for(ll j = 0; j < 2; j++)
				for(ll k = 0; k <= t; k++)
					add(fas[x][i][j], fas[lc[x]][i][k] * fas[rc[x]][k][j] %mod);
	}
	void pushup_rake(ll x) {
		ll t = a[ft[rc[x]]];
		for(ll i = 0; i < 2; i++)
			for(ll j = 0; j < 2; j++)
				for(ll k = 0; k < 2; k++)
					add(fas[x][i][j], fas[lc[x]][i][j] * fas[rc[x]][i][k] %mod);
	}
	void pushup(ll x) {
		memset(fas[x], 0, sizeof fas[x]);
		if(op[x] == 1) pushup_compress(x);
		else pushup_rake(x);
	}
} using namespace Pushup;


void modify(ll x) {
	static ll stk[maxn], top;
	top = 0;
	for(ll i = fa[x]; i; i = fa[i]) stk[++top] = i;
	while(top) pushdown(stk[top--]);
	a[x] = 0, fas[x][0][1] = 0;
	for(ll i = fa[x]; i; i = fa[i]) pushup(i);
}

int main() {
	rd(n); tot = n;
	for(ll i = 2, x; i <= n; i++) rd(x), to[x].pb(i);
	dfs1(1), dfs2(1); rt = nowid[1];
	for(ll i = 1; i <= n; i++) rd(b[i]), vec[b[i]].pb(i);
	tag[rt][0][0] = tag[rt][0][1] = n;
	for(ll i = 1; i <= n; i++)
		fas[i][0][1] = fas[i][1][0] = fas[i][0][0] = 1;
	for(ll i = 1; i <= n; i++) a[i] = 1;
	for(ll i = n + 1; i <= tot; i++) pushup(i);
	for(ll i = n; i > 1; i--) {
		for(ll j: vec[i]) modify(j);
		add(tag[rt][0][0], mod - 1);
		if(a[ft[rt]]) add(tag[rt][0][1], mod - 1);
	}
	for(ll i = tot; i > n; i--) pushdown(i);
	for(ll i = 1; i <= n; i++)
		printf("%lld ", tag[i][0][1]);
	return 0;
}
```

---


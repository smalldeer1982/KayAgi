# [科大国创杯初中组 2025] 抽卡

## 题目背景

Subtask 0 为民间数据，Subtask 1 为官方数据。

## 题目描述

小可可正在和波特玩卡牌游戏。

这个游戏有 $m$ 种卡牌。种类为 $x$ 的卡牌价值也为 $x$。首先，波特一共会进行 $n$ 次抽卡来确定游戏的牌堆。第 $i$ 次，会有 $a_i$ 种新的卡牌解锁。也就是说如果第 $i$ 次抽卡之前第 $1 \sim s$ 种卡牌解锁了，那么第 $i$ 次时第 $1 \sim s + a_i$ 种卡牌都会解锁。保证 $\displaystyle \sum_{i=1}^{n} a_i = m$。初始没有卡牌解锁。

在第 $i$ 次抽卡时，波特会等概率随机选择一种已经被解锁的卡牌，并且取出两张这个种类的卡牌，依次放在现在所有牌的右边。在 $n$ 次抽卡结束后，一共会有 $2n$ 张卡牌从左向右排成一排作为游戏的牌堆。小可可知道这 $2n$ 张卡牌各自的价值。

现在，小可可和波特会轮流从这个牌堆中进行抽卡，直到抽完所有卡牌，小可可先手。波特每次抽卡只会取走当前牌堆中最左边的卡牌。而小可可可以在当前牌堆中任意选择一张取走。小可可希望抽卡结束后自己手中的卡牌价值总和最大。他想要知道，如果自己采取最优策略，那么期望得到的价值是多少呢？你只需要告诉他答案对 $10^9 + 7$ 取模的结果就行。

关于期望：设离散型随机变量 $X$ 的概率分布为 $p_i = P\{X = x_i\}$，那么我们称 $E = \sum x_i p_i$ 的值为 $X$ 的期望。不过在本题中，由于每种可能的情况出现概率相等，所以你可以简单地理解为所有方案中小可可得到的卡牌价值总和除以总方案数。

关于有理数取余：不难发现答案一定是一个有理数，设其为 $C = \frac{A}{B}$，其中 $A, B$ 互质，你需要输出 $C \bmod 1000000007$ 的值。这个值被定义为 $Bx \equiv A \pmod {1000000007}$ 的最小非负整数解。

## 说明/提示

### 样例 1 解释

第 $1$ 次，解锁的卡牌种类只有 $1$，于是波特会取出两张 $1$ 卡牌。

第 $2$ 次，解锁的卡牌种类有 $1, 2, 3$。波特会随机取出某一种类的两张卡牌。于是有如下三种可能：

- 牌堆中的卡牌从左到右分别为：$1, 1, 1, 1$，概率为 $\frac{1}{3}$，小可可可以获得的最大价值为 $1 + 1 = 2$。
- 牌堆中的卡牌从左到右分别为：$1, 1, 2, 2$，概率为 $\frac{1}{3}$，小可可可以获得的最大价值为 $2 + 2 = 4$。
- 牌堆中的卡牌从左到右分别为：$1, 1, 3, 3$，概率为 $\frac{1}{3}$，小可可可以获得的最大价值为 $3 + 3 = 6$。

于是答案为 $2 \times \frac{1}{3} + 4 \times \frac{1}{3} + 6 \times \frac{1}{3} = 4$。

### 数据规模与约定

| 测试点编号 | $n \leq$ | $m \leq$ | 特殊性质 |
|:-----------:|:---------:|:---------:|:---------:|
| $1 \sim 2$       | $3$         | $3$         | 无        |
| $3 \sim 6$       | $8$         | $8$         | 无        |
| $7 \sim 9$       | $500$       | $500$       | $a_1 = m$ |
| $10 \sim 13$     | $500$       | $500$       | 无        |
| $14 \sim 15$     | $500$       | $10^5$    | 无        |
| $16 \sim 19$     | $100$       | $10^9$    | 无        |
| $20 \sim 21$     | $500$       | $10^9$    | $a_1 = m$ |
| $22 \sim 25$     | $500$       | $10^9$    | 无        |

对于 $100\%$ 的数据，满足 $1 \leq n \leq 500, 1 \leq m \leq 10^9, 0 \leq a_i \leq m$。保证 $\displaystyle \sum_{i=1}^{n} a_i = m$ 并且 $a_1 > 0$。

## 样例 #1

### 输入

```
2 3
1 2```

### 输出

```
4```

# 题解

## 作者：Purslane (赞：15)

# Solution

来个拉格朗日插值优化 DP 的方法。~~现在的安徽小朋友越来越不容易了，一年一年的上强度。~~

阅读题面的时候一眼看到三个可：![](https://s21.ax1x.com/2025/04/20/pE4qdc8.png)，非常有趣。

可能会有一些小朋友阅读这篇文章，所以我写的详细一些。

---------

首先，考虑固定局面下小可可怎么取牌可以获得最大收益。

假设有一个集合 $U=\{1,2,3,\cdots,2n\}$ 表示牌的编号（注意和牌上的值并不相通），小可可选取的牌的集合 $C$ 是 $U$ 的一个大小为 $n$ 的子集。在这 $\binom{2n}{n}$ 个子集中，我们需要选出合法的且代价最大的那一个。

为什么要强调“合法”呢？比如，小可可并不能选出前 $n$ 张牌（$n \ge 2$），因为波特肯定会在第一张牌和第二张牌中选出一个。

我们断言：小可可取出的集合 $C$ 合法，当且仅当 $\forall 1 \le k \le n$，$C$ 中小于等于 $2k$ 的牌的个数 $\le k$。使用数学归纳法容易证明。

那么不妨设小可可初始的牌放在 $1$，$3$，$\cdots$，$2n-1$。每一张牌**可以移动到后面的任何一个位置**，最终不能重叠。换句话说，小可可的最后一张牌可以在**后两张牌中选取**，倒数第二张排可以在**后四张牌中选取**，依次类推。

这样我们就会计算答案了——显然每一步都可以贪心。所以你开一个堆，从 $n$ 到 $1$，每次往堆里面加入 $2$ 个 $a_i$，并且取出堆顶。复杂度 $O(m^n \times n \log n)$。

这样也许可以拿到 $24$ 分？看你常数怎么样了。拿到这档分的小朋友未来很有希望的：你有很强的分析问题的能力，和获得更高的分只差了经典技巧的积累，多做点题就能克服这一关了！

------

这类问题有一个经典的讨论：“二分”转 $01$。

设 $f_i$ 表示，最终取出的 $n$ 张牌中，有多少张排的大小 $\ge i$。答案显然就是 $\sum_{i=1}^m f_i$。根据期望的线性性，$E(\sum_{i=1}^m f_i) = \sum_{i=1}^m E(f_i)$，所以你想方设法算出 $E(f_i)$。

可以证明，$f_i$ 等于：**将 $\ge i$ 的数看做 $1$，$\le i$ 的数看做 $0$，执行上面贪心的流程得到的结果**。

这么做的好处是什么呢？由于所有数要么是 $0$ 要么是 $1$，我们只需要关心堆里面**有多少个 $1$**，而这样的状态数就比较少，可以进行 DP！（这里有点 DP 套 DP 的感觉了，和去年 T4 很像！）

假设我们需要求 $f_x$。设 $dp_{i,j}$ 表示，执行了所有 $i_0 \ge i$ 后，堆中有 $j$ 个 $1$ 的概率。最终状态是 $dp_{1,j}$，表示堆里面还剩了 $j$ 个 $1$。这样假设加入了 $k$ 个 $1$，小可可就取出了 $k-j$ 个 $1$。我们的答案是 $E(k-j)=E(k)-E(j)$，其中 $E(j) = \sum_j (j-\min\{j,i-1\}) dp_{i,j}$，$E(k) = E(\sum_{i=1}^n [a_i \ge x]) = \sum_{i=1}^n E([a_i \ge x]) = \sum_{i=1}^n p(a_i \ge x)$，其中 $p$ 表示概率。

$dp_{i,j}$ 的转移是容易的，你分类讨论一下 $a_i$ 和 $x$ 的关系即可。

复杂度 $O(n^2 m)$，可以拿到 $52$ 分。拿到这一档分的小朋友很强大：你有很强的算法功底，和正解只差了高级算法，多学一段时间就可以克服！

-----

给定 $x$ 做 DP 的时候，$[a_i \ge x]$ 一共有 $2^n$ 种可能。每一种可能都有出现的概率 $p(A)$，以及贡献 $c(A)$。$c(A)$ 在 $A$ 确定的时候是一个常数，而 $p(A)$ 应当是每一位对应概率的乘积。而这个概率要么是常数，要么是关于 $x$ 的一次函数。所以 $p(A)$ 是一个关于 $x$ 的不超过 $n$ 次多项式。对 $2^n$ 种情况求和，**还是关于 $x$ 的不超过 $n$ 次多项式**。

一个值得关注的事情是，设 $pre_i = \sum_{j \le i} a_j$。当 $x \le pre_i$ 时概率是关于 $x$ 的一次函数，$> x$ 时概率是常数。所以本质上要把 $x$ 分为 $n$ 段去算，同一段内 $p(A)$ 是相同的，$f_x = Z(x)$ 的这个 $Z$ 也是相同的。

所以我们相当于知道了 $Z$，求出 $\sum_{x=pre_{i-1}+1}^{pre_i} Z(x)$。

所以我们可以设 $dp_{i,j}$ 为一个关于 $x$ 的多项式，记录它的系数。转移是 $O(n)$ 的，因为要乘上一个一次函数。不同的段对应的其实是 DP 终点不同，发现可以共用同一个 $dp_{i,j}$。然后你就只需要求出：$\sum_{x=1}^n x^k$。这是经典的拉格朗日插值优化问题。

其实你可以直接把 $x$ 挂进 $dp_{i,j}$ 里算的，然后使用拉格朗日插值求出 $Z(x)$ 的前缀和。后者是关于 $x$ 的 $n+1$ 次多项式，需要 $n+2$ 个点值。

我选择了后者，因为它实现起来更加方便。

复杂度 $O(n^3)$。我猜赛时没人过。

-------

所以什么时候我能给科大国创出题啊 /kel

哎拉插常数太大了，拼尽全力卡进了 1 秒。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=500+10,MOD=1e9+7;
int n,m,a[MAXN],pre[MAXN],inv[MAXN],dp[MAXN][MAXN],E[MAXN][MAXN];
ll qpow(ll base,int p) {
	ll ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
void solve(int v) {
	dp[n+1][0]=1;
	int ad=0;
	roff(i,n,1) {
		ffor(j,0,n-i+1) dp[i][j]=0;
		ffor(j,0,n-i+1) {
			ll p=1ll*(pre[i]-v+1)%MOD*inv[i]%MOD;
			dp[i][j+1]=(dp[i][j+1]+dp[i+1][j]*p)%MOD;
			p=(1-p)%MOD; 
			dp[i][max(0,j-1)]=(dp[i][max(0,j-1)]+dp[i+1][j]*p)%MOD;
		}
		ll p=1ll*(pre[i]-v+1)%MOD*inv[i]%MOD;
		ad=(ad+p)%MOD,E[i][v]=2*ad%MOD;
		ffor(j,0,n-i+1) E[i][v]=(E[i][v]-1ll*dp[i][j]*(j-min(i-1,j)))%MOD;
	}
	return ;
}
int tot;
pair<int,int> vc[MAXN];
inline int lagrange(const int x1,const int x2) {
	int ans=0;
	ffor(id,1,tot) {
		auto pr=vc[id];
		ll mul,mul1=pr.second,mul2=pr.second,div=1;
		ffor(j,1,tot) if(j!=id) {auto npr=vc[j]; mul1=(x1-npr.first)*mul1%MOD,mul2=(x2-npr.first)*mul2%MOD,div=(pr.first-npr.first)*div%MOD;}
		mul=(mul1-mul2)%MOD,mul=mul*qpow(div,MOD-2)%MOD;
		ans=(ans+mul)%MOD;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,n) cin>>a[i],pre[i]=pre[i-1]+a[i];
	ffor(i,1,n) inv[i]=qpow(pre[i],MOD-2);
	ffor(v,1,n+2) solve(v);
	ffor(i,1,n) ffor(j,1,n+2) E[i][j]=(E[i][j]+E[i][j-1])%MOD;
	int ans=0;
	ffor(i,1,n) {
		tot=0;
		ffor(j,1,n+2) vc[++tot]={j,E[i][j]};
		ans=(ans+lagrange(pre[i],pre[i-1]))%MOD;
	}
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：zxc_a (赞：13)

# $\text{Solution}$

先分析一下如果牌堆确定了应该怎么做最优：

倒着处理牌堆，每次将两张卡牌的价值加入堆中并再弹出堆中最大值，$n$ 次之后牌取完，所有牌的值之和减堆中剩的 $n$ 个数之和就是答案。

## $52$ 分 $\mathcal{O}(n^2m)$ 做法

先分析一下 $52$ 分 $\mathcal{O}(n^2m)$ 怎么写：

所有牌的值之和很好求。

对于一种方案堆中剩的所有值之和我们考虑拆贡献：

$$ans=\sum_{k=1}^{n}v_k=\sum_{k=1}^{n}\sum_{i=1}^{m}[v_k\ge i]=\sum_{i=1}^{m}\sum_{k=1}^{n}[v_k\ge i]$$

$v$ 指的是堆中剩的 $n$ 个值。

所以我们考虑枚举 $i$，求：

$$S=\sum_{j=1}^{n}[v_j\ge i]$$

此时只分两种权值 $1/0$，即 $[v_j\ge i]$。

设 $b_i=\sum_{j=1}^{i}a_i$，若当前枚举的数为 $w$，则第 $i$ 次随机选择的卡牌值为 $0$ 的方案数为 $\min(w-1,b_i)$，为 $1$ 的方案数为 $\max(0,b_i-w+1)$。

我们从后往前 dp，$f_{i,j}$ 表示处理好了第 $i$ 到 $n$ 次选择堆中有个 $j$ 数值为 $1$。

转移即：

$$\large{f_{i,j}=f_{i+1,j+1}\times \min(w-1,b_i) +f_{i+1,j-1}\times \max(0,b_i-w+1)}$$

$$\large{S=\sum_{j=1}^{n}[v_j\ge i]=\sum_{i=1}^{n} f_{1,i} \times i}$$

至此 $52$ 分结束。

## $100$ 分 $\mathcal{O}(n^3)$

比较明显 $f_i$ 数组维护的是一个关于 $w$ 的多项式，因为 $b_i$ 递增我们可以发现对于 $b_i\ge w$ 的所有 $w,f_i$ 维护的多项式系数相同。

现在如果我们得到了 $f_i$ 的系数，并且 $b_{i-1}<w$。那么 $f_{i-1,j}=f_{i,j+1}\times b_{i-1} +f_{i,j-1}\times 0=f_{i,j+1}\times b_{i-1}$。

所以 $f_{1,j}=f_{i,j+i-1}\times \prod_{k=1}^{i-1}b_k$。

因此从后往前暴力算 $f_{i}$ 的系数，然后就可以统计 $b_{i-1}<w\le b_i$ 的所有 $w$ 的答案。

设 $f_{i,j}$ 为 $f_i$ 第 $j$ 项的系数。

即:

$$\sum_{w=b_{i-1}+1}^{b_i} \sum_{j=1}^{n} f_{i,j+i-1} \times \prod_{k=1}^{i-1}b_k \times w^{j+i-1}=\prod_{k=1}^{i-1}b_k \times \sum_{j=1}^{n} f_{i,j+i-1} \times \sum_{w=b_{i-1}+1}^{b_i}w^{j+i-1}$$

最后我们用斯特林数或拉插求自然数幂和即可。

斯特林数求法：

$$\sum_{i=1}^{n} i^k=\sum_{i=1}^{n}\sum_{j=1}^{k}\begin{Bmatrix} k \\ j\end{Bmatrix}\times j! \times {i \choose j}=\sum_{j=1}^{k}\begin{Bmatrix} k \\ j\end{Bmatrix}\times j! \times \sum_{i=1}^{n}{i \choose j}=\sum_{j=1}^{k}\begin{Bmatrix} k \\ j\end{Bmatrix}\times j! \times {n+1 \choose j+1}$$

数据出来再放代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505,mod=1e9+7;
#define vr vector<int>
int n,m,a[N],s=1,ans,sss,mi[N],inv[N],st[N][N],ss[N][N];vr f[N][N];
inline int pw(int x,int y) {
  int z=1;
  for(;y;y>>=1,x=x*1ll*x%mod) if(y&1) z=z*1ll*x%mod;
  return z;
}
inline void ad(int &u,int v) {u+=v;(u>=mod&&(u-=mod));}
inline vr add2(vr x,vr y) {
  vr z(max(x.size(),y.size()),0);
  for(int i=0;i<x.size();++i) ad(z[i],x[i]);
  for(int i=0;i<y.size();++i) ad(z[i],y[i]);
  return z;
}
inline vr mul(vr x,vr y) {
  vr z(x.size()+y.size()-1,0);
  for(int i=0;i<x.size();++i) for(int j=0;j<y.size();++j) ad(z[i+j],x[i]*1ll*y[j]%mod);
  return z;
}
inline int calc(int x) {return x*1ll*(x+1)/2ll%mod;}
vr tp;
inline vr make(int x,int y) {vr().swap(tp);tp.emplace_back(y);tp.emplace_back(x);return tp;}
inline vr make2(int x) {vr().swap(tp);tp.emplace_back(x);return tp;}
int main() {
  scanf("%d%d",&n,&m);
  for(int i=1;i<=n;++i) scanf("%d",a+i),a[i]+=a[i-1],s=s*1ll*a[i]%mod;sss=s;
  for(int i=1;i*2<=n;++i) swap(a[i],a[n+1-i]);
  for(int i=1;i<=n;++i) ans=(ans+calc(a[i])*1ll*s%mod*pw(a[i],mod-2))%mod;
  st[0][0]=1;ans=ans*2%mod;
  for(int i=1;i<=n;++i) for(int j=1;j<=i;++j) st[i][j]=(j*1ll*st[i-1][j]+st[i-1][j-1])%mod;
  for(int i=1;i<=n+2;++i) inv[i]=pw(i,mod-2);
  for(int i=1;i<=n;++i) {
    mi[0]=1;
    for(int j=1;j<=n+1;++j) mi[j]=mi[j-1]*1ll*(a[i]+2-j)%mod;
    for(int j=0;j<=n;++j) for(int k=0;k<=j;++k) ss[i][j]=(ss[i][j]+st[j][k]*1ll*inv[k+1]%mod*mi[k+1])%mod;
  }
  f[0][0].emplace_back(1);ss[n+1][0]=1;
  for(int i=1;i<=n;++i) {
    for(int j=0;j<i;++j) {
      f[i][j+1]=add2(f[i][j+1],mul(make(mod-1,a[i]+1),f[i-1][j]));
      f[i][max(j-1,0)]=add2(f[i][max(j-1,0)],mul(make(1,mod-1),f[i-1][j]));
    }
    vr g;g.clear();
    for(int j=n-i+1;j<=n;++j) g=add2(g,mul(make2(j-n+i),f[i][j]));
    s=s*1ll*pw(a[i],mod-2)%mod;
    for(int j=0;j<(int)g.size();++j) ans=(ans-g[j]*1ll*s%mod*(ss[i][j]-ss[i+1][j]))%mod;
  }
  if(ans<0) ans+=mod;ans=ans*1ll*pw(sss,mod-2)%mod;
  printf("%d\n",ans);
  return 0;
}
```

---

## 作者：huangleyi0129 (赞：6)

场外 VP，小朋友太惨了。

## $O(n^2m)$ 做法
非常经典地，将 $\ge x$ 的数视为 $1$，其余视为 $0$，这样就将贡献拆掉，问题简化。

与马队和 asdfz 的诸位大佬不同的是，我的朴素 DP 是正着做的（这样似乎更易理解和记答案？）。

设 $f_{i,j}$ 表示前 $2i$ 个数中合法选出 $j$ 个 $1$ 的概率，$p_i=\sum_{k=1}^{i} a_k$。

则 $f_{i,j}=f_{i-1,j-2}\cdot (1-\frac{x-1}{p_i})
+f_{i-1,j}\cdot \frac{x-1}{p_i} $，其中 $j\le i,p_i\ge x$。

易知对答案的贡献为 $\sum j f_{n,j}$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
const long long mod=1000000007;
long long f[N][2],inv,ans;
int n,m,s,a[N],p[N];
long long qpow(long long x,int y)
{
	long long z=1;
	while(y)
	{
		if(y&1)
			z=z*x%mod;
		x=x*x%mod,y>>=1;
	}
	return z;
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0);
	int cur;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>a[i],p[i]=a[i]+p[i-1];
	for(int t=1;t<=n;s+=a[t],++t)
	{
		for(int x=s+1;x<=s+a[t];++x)
		{
			memset(f,0,sizeof f),f[0][0]=1,cur=1;
			for(int i=t;i<=n;++i,cur^=1)
			{
				inv=(p[i]-x+1)*qpow(p[i],mod-2)%mod;
				for(int j=0;j<=i;++j)
				{
					f[j][cur]=f[j][!cur]*(1-inv)%mod;
					if(j>=2)
						f[j][cur]=(f[j][cur]+f[j-2][!cur]*inv)%mod;
				}
				f[i][cur]=(f[i][cur]+f[i-1][!cur]*inv)%mod;
			}
			for(int j=1;j<=n;++j)
				ans=(ans+j*f[j][!cur])%mod;
		}
	}
	cout<<(ans+mod)%mod;
	return 0;
}
```

## $O(n^3)$ 做法
上述做法大约只能用拉插优化到 $O(n^4)$，原因在于未能有效利用之前的信息。

要作一个转化，合法相当于后 $2i$ 个数至少取 $i$ 个，即在每个 $2j+1$ 处取局部最优值，再拆一下期望，具体见 Purslane 的题解。

下面就与他们的 DP 式子一样了，处理时我是记录下降幂的系数，使用一些有限微积分的技巧求和，即：

$\sum_a^{b-1} x^{\underline{n}}=\frac{b^{\underline{n+1}}-a^{\underline{n+1}}}{n+1}$。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
const long long mod=1000000007;
long long q[N][2],invv[N],ans;
int n,m,s,a[N],p[N];
struct poly{
	long long a[N];					//下降幂 
	void operator+=(const poly &x)
	{
		for(int i=0;i<=n;++i)
			a[i]=(a[i]+x.a[i])%mod;
	}
	poly operator*(const long long x)
	{
		poly y;
		for(int i=0;i<=n;++i)
			y.a[i]=a[i]*x%mod;
		return y;
	}
}f[N][2],A;
poly times(const poly &x,const long long a,const long long b)
{
	poly y;
	y.a[0]=x.a[0]*b%mod*a%mod;
	for(int i=1;i<=n;++i)
		y.a[i]=(x.a[i-1]+x.a[i]*(b+i))%mod*a%mod;
	return y;
}
long long qpow(long long x,int y)
{
	long long z=1;
	while(y)
	{
		if(y&1)
			z=z*x%mod;
		x=x*x%mod,y>>=1;
	}
	return z;
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0);
	int cur=1;
	long long inv,u=0,v=0;
	cin>>n>>m;
	invv[0]=1;
	for(int i=1;i<=n;++i)
		cin>>a[i],p[i]=a[i]+p[i-1],invv[i]=qpow(i+1,mod-2);
	f[0][0].a[0]=1;
	for(int i=n;i>=1;--i,cur^=1)
	{
		memset(A.a,0,sizeof A.a),inv=qpow(p[i],mod-2)%mod,u+=2,v=(v-2*inv)%mod;
		for(int j=n-i+1;j>=0;--j)
		{
			f[j][cur]=times(f[j+1][!cur],inv,0);
			if(j==0)
				f[j][cur]+=times(f[j][!cur],inv,0);
			else
				f[j][cur]+=times(f[j-1][!cur],-inv,-p[i]);
		}
		for(int j=0;j<=n;++j)
			A+=f[j][cur]*(-max(j-i+1,0));
		A.a[0]+=u,A.a[1]+=v;
		q[0][0]=q[0][1]=1;
		for(int j=1;j<=n+1;++j)
			q[j][0]=q[j-1][0]*(p[i]+1-j)%mod,q[j][1]=q[j-1][1]*(p[i-1]+1-j)%mod;
		for(int j=0;j<=n;++j)
			ans+=A.a[j]*invv[j]%mod*(q[j+1][0]-q[j+1][1])%mod;
		ans%=mod;
	}
	cout<<(ans+mod)%mod;
	return 0;
}
```
所以什么时候我能给科大国创出题啊。

本题解与笔者的代码在伟大的 Purslane 的指导下完成，让我们一起拜谢马队，祝他在绍兴 Au。

---

## 作者：251Sec (赞：4)

花了 40mins 过掉这个题。这个题给初中生做真的大丈夫？？？

首先瞪一下对一个序列怎么求答案，你发现就是维护一个小根堆，每次把一个数插入两次，然后弹掉堆顶。最后堆里所有元素的和就是答案。

我们先把 $a_i$ 做个前缀和，这样比较方便描述。然后我们算方案数，最后除掉 $\prod a_i$ 即可。

那么套路地，枚举一个阈值 $w$，转 01，设 $f(i,j)$ 代表已经考虑前 $i$ 次解锁，目前堆里有 $j$ 个 $1$ 的方案数。这样就做到了 $O(n^2m)$。不难观察到这是一个以 $a_i$ 为分段点的 $O(n)$ 次的分段多项式，容易拉插做到 $O(n^4)$。

但是然后怎么办？这个做法看起来并没有什么优化前途。我们不得不转换视角：我们发现，对于 $w > a_i$ 的部分，我们的转移非常简单：就是对应项乘上 $a_i$。而满足 $w > a_i$ 的部分是一个前缀——这给了我们一个启示：把 DP 倒过来。

把 DP 的过程看成 DAG 上的游走后，我们当然可以把整个 DAG 的边全部反过来，这样，我们就会先走若干 $w \le a_i$ 的边，然后走若干 $w > a_i$ 的边。前面这一部分不再是一个分段多项式：它整个就是个多项式。而后面这部分的系数我们可以在 DP 外乘上去。这样，我们可以写出如下暴力算法：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 1e9 + 7;
int n, m, a[505];
ll ans, f[505][505];
void F(int w) {
	memset(f, 0, sizeof(f));
	for (int i = 0; i <= n; i++) f[n][i] = i;
	for (int i = n; i; i--) {
		for (int j = 0; j <= i; j++) f[i][j] %= P;
		for (int j = 0; j < i; j++) {
			f[i - 1][j] += f[i][j] * (w - 1);
			f[i - 1][j] += f[i][j + 2 - (j == i - 1)] * (a[i] - w + 1);
		}
	}
}
ll QPow(ll a, ll b) {
	ll res = 1;
	for (; b; b >>= 1, a = a * a % P) if (b & 1) res = res * a % P;
	return res;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", a + i), a[i] += a[i - 1];
	for (int i = 1; i <= n; i++) {
		for (int j = a[i - 1] + 1; j <= a[i]; j++) {
			F(j);
			ll t = f[i - 1][0];
			for (int k = 1; k < i; k++) t = t * a[k] % P;
			ans += t;
		}
	}
	ans %= P;
	for (int i = 1; i <= n; i++) ans = ans * QPow(a[i], P - 2) % P;
	printf("%lld\n", ans);
	return 0;
}
```

接下来的部分就顺理成章了。我们对这个 DP 的前缀和进行插值即可。注意前缀和是 $(n+1)$ 次而不是 $n$ 次。复杂度 $O(n^3)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 501, P = 1e9 + 7;
int n, m, a[505];
ll ans, f[505][505], g[505][505];
void F(int w) {
	memset(f, 0, sizeof(f));
	for (int i = 0; i <= n; i++) f[n][i] = i;
	for (int i = n; i; i--) {
		for (int j = 0; j <= i; j++) f[i][j] %= P;
		for (int j = 0; j < i; j++) {
			f[i - 1][j] += f[i][j] * (w - 1);
			f[i - 1][j] += f[i][j + 2 - (j == i - 1)] * (a[i] - w + 1);
		}
	}
	for (int i = 0; i <= n; i++) g[i][w] = f[i][0] % P;
}
ll QPow(ll a, ll b) {
	ll res = 1;
	for (; b; b >>= 1, a = a * a % P) if (b & 1) res = res * a % P;
	return res;
}
ll Calc(int u, int x) {
	ll res = 0;
	for (int i = 0; i <= N; i++) {
		ll a = 1, b = 1;
		for (int j = 0; j <= N; j++) {
			if (i == j) continue;
			a = a * (x - j) % P;
			b = b * (i - j) % P;
		}
		res += g[u][i] * a % P * QPow(b, P - 2) % P;
	}
	return (res % P + P) % P;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", a + i), a[i] += a[i - 1];
	for (int i = 0; i <= N; i++) F(i);
	for (int i = 0; i <= n; i++) {
		for (int j = 1; j <= N; j++) (g[i][j] += g[i][j - 1]) %= P;
	}
	for (int i = 1; i <= n; i++) {
		ll t = Calc(i - 1, a[i]) - Calc(i - 1, a[i - 1]) + P;
		for (int k = 1; k < i; k++) t = t * a[k] % P;
		ans += t;
	}
	ans %= P;
	for (int i = 1; i <= n; i++) ans = ans * QPow(a[i], P - 2) % P;
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Petit_Souris (赞：4)

您管这叫初中组？现在初中小朋友日子不好过啊...感觉找个 NOI rk 100 水平的选手也不能保证 1h 通过啊...

首先第一步是明显的：先考虑给定一个序列，如何快速计算答案。

一个合法的序列需要满足前 $2k$ 个中至多选出 $k$ 个。因此一个简单的贪心方法就是，倒着做，每次加入两个数，并取出最大值。

接下来考虑计算期望。经典套路是拆贡献，枚举 $x$，计算期望选到几个 $\ge x$ 的数。这样就转化成了 01 序列的问题，容易导出一个 $\mathcal O(n^2)$ 的 dp 做法：设 $f_{i,j}$ 表示 $[i,n]$，目前堆里有 $j$ 个 $1$ 的方案数以及权值总和。总复杂度 $\mathcal O(n^2m)$。

进一步优化显然需要去掉这个 $m$。容易发现对应的贡献应该是关于 $x$ 的分段多项式，次数不超过 $n+1$，段数不超过 $n$。因此可以分别拉插求出每个 $(a_{i-1},a_i]$ 的贡献。

我们可以预处理出 $g_{i,j}$ 表示带入 $x=1,2\dots,i$ 时，$[j,n]$ 的贡献。这里不完全是 $f$ 的总和，还需要把残留在堆里的都 pop 出去。

并且这里我们要作为多项式计算，所以计算上下界的时候，必须不跟 $0$ 取 max，即使变成负数。

最终时间复杂度 $\mathcal O(n^3)$。可以预处理拉插系数，减小常数。

实现的时候注意方案数 $\equiv 0$ 不等价于这个状态无效，不要卡常卡过头了获得 96 分。（民间数据和官方数据都卡了这一点）

```cpp
#include<bits/stdc++.h>
#define debug(x) cerr<<(#x)<<": "<<x<<endl
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=519,Mod=1e9+7;
ll n,m,a[N],f[2][N],g[2][N],cur,F[N][N],inv[N];
ll pw(ll x,ll p){
    ll res=1;
    while(p){
        if(p&1)res=res*x%Mod;
        x=x*x%Mod,p>>=1;
    }
    return res;
}
ll fm[N],fz[N][N];
ll Lagrange(ll id,ll l){
    ll res=0;
    if(a[l]<=n+2)return F[id][a[l]];
    rep(i,1,n+2)res=(res+fz[l][i]*fm[i]%Mod*F[id][i])%Mod;
    return res;
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    n=read(),m=read();
    rep(i,1,n)a[i]=read(),a[i]+=a[i-1];
    rep(i,1,n)inv[i]=pw(a[i],Mod-2);
    ll ans=0;
    rep(i,1,n+2){
        memset(f,0,sizeof(f));
        memset(g,0,sizeof(g));
        f[0][0]=1,g[0][0]=0,cur=0;
        per(j,n,1){
            memset(f[cur^1],0,sizeof(f[cur^1]));
            memset(g[cur^1],0,sizeof(g[cur^1]));
            ll p0=i-1,p1=(a[j]-p0+Mod)%Mod;
            p0=p0*inv[j]%Mod,p1=p1*inv[j]%Mod;
            rep(k,0,n-j){
                if(!f[cur][k]&&!g[cur][k])continue;
                f[cur^1][k+1]=(f[cur^1][k+1]+f[cur][k]*p1)%Mod;
                g[cur^1][k+1]=(g[cur^1][k+1]+(f[cur][k]+g[cur][k])*p1)%Mod;
                if(k){
                    f[cur^1][k-1]=(f[cur^1][k-1]+f[cur][k]*p0)%Mod;
                    g[cur^1][k-1]=(g[cur^1][k-1]+(f[cur][k]+g[cur][k])*p0)%Mod;
                }
                else {
                    f[cur^1][k]=(f[cur^1][k]+f[cur][k]*p0)%Mod;
                    g[cur^1][k]=(g[cur^1][k]+g[cur][k]*p0)%Mod;
                }
            }
            cur^=1;
            rep(k,0,n-j+1)F[j][i]=(F[j][i]+g[cur][k]+f[cur][k]*min(k,j-1))%Mod;
        }
    }
    rep(i,1,n){
        rep(j,1,n+2)F[i][j]=(F[i][j]+F[i][j-1])%Mod;
    }
    rep(i,0,n){
        ll full=1,cnt=0;
        rep(j,1,n+2){
            if(a[i]-j)full=full*(a[i]-j+Mod)%Mod;
            else cnt++;
        }
        rep(j,1,n+2){
            if(a[i]-j){
                if(cnt)fz[i][j]=0;
                else fz[i][j]=full*pw(a[i]-j+Mod,Mod-2)%Mod;
            }
            else {
                if(cnt==1)fz[i][j]=full; 
                else fz[i][j]=0;
            }
        }
    }
    rep(i,1,n+2){
        fm[i]=1;
        rep(j,1,n+2){
            if(i!=j)fm[i]=fm[i]*(i-j+Mod)%Mod;
        }
        fm[i]=pw(fm[i],Mod-2);
    }
    rep(i,1,n)ans=(ans+(Lagrange(i,i)-Lagrange(i,i-1)+Mod))%Mod;
    write(ans),putchar('\n');
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：1)

### Solution

考虑如果牌堆已经确定，怎么刻画小可可的取法。不难发现可以维护一个小根堆，每次将抽出的两张卡加入堆中，再将堆顶弹出，最后堆内的卡牌即为小可可选中的卡牌。

然后考虑计数。直接记录堆内元素状态数爆炸了，考虑到小根堆只需要比相对大小，据此想到拆 $01$：枚举 $k\ge 0$，将 $\le k$ 的看作 $0$，$>k$ 的看作 $1$，只需对于每个 $k$ 算出堆中 $1$ 的个数的期望再相加即可。

据此可以得到一个 $O(n^2m)$ 的做法：枚举 $k$，再设 $f_{i,j}$ 表示考虑到第 $i$ 个人，堆内有 $j$ 个 $1$ 的概率，一个 $k$ 的贡献即为 $\sum_{i=0}^ni\times f_{n,i}$。可以写出转移：

$$
f_{i-1,j}\times\frac{\min(k,a_i)}{a_i}\to f_{i,j}\\
f_{i-1,j}\times\frac{\max(a_i-k,0)}{a_i}\to f_{i,\min(i,j+2)}
$$

考虑到转移通过 $\min$ 与 $\max$ 划分为了 $O(n)$ 段且每段中的转移都是简单加乘，于是每段都是一个 $O(n)$ 次多项式，找出 $O(n)$ 个点值后拉插即可 $O(n^4)$。

考虑优化。主要瓶颈在于 dp 部分，考虑到 $a_i$ 不降，尝试据此优化做法。

设 $p$ 满足 $a_{p}$ 是第一个 $>k$ 的值，则有 $k\in[a_{p-1},a_p)$。那么可以分别去掉 $i<p$ 与 $i\ge p$ 转移中的 $\min$ 和 $\max$。$i<p$ 的部分是简单的（即 $f_{p-1,j}=[j=0]$），对于 $i\ge p$ 的部分可以考虑将 dp 倒过来，每一个位置都维护一个多项式，最终就只需要计算形如 $\sum_{x=L}^RF(x)=\sum_{x=L}^R\sum_{i=0}^kF_ix^i$ 形式的问题。差分一下拆成前缀和，交换一下求和号即可转化为自然数幂和，直接拉插或斯特林数解决即可。

复杂度 $O(n^3)$，可能需要注意一下空间。

### Code

以下是一份不怎么好看的代码。

```cpp
bool Mst;
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=505,mod=1e9+7;
inline ll add(ll x,ll y){return (x+=y)>=mod&&(x-=mod),x;}
inline ll Add(ll &x,ll y){return x=add(x,y);}
inline ll sub(ll x,ll y){return (x-=y)<0&&(x+=mod),x;}
inline ll Sub(ll &x,ll y){return x=sub(x,y);}
inline ll qpow(ll a,ll b){
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)res=res*a%mod;
	return res;
}
int n,m,a[N];ll f[N][N],S[N][N],inv[N];
inline ll calc(int k,int n){
	if(!~n)return 0;
	ll res=0,dn=1;
	for(int i=0;i<=k;i++){
		dn=dn*(n-i+1)%mod;
		Add(res,S[k][i]*dn%mod*inv[i+1]%mod);
	}
	return res;
}
inline ll calc(int k,int l,int r){
	return sub(calc(k,r),calc(k,l-1));
}
bool Med;
int main(){
	cerr<<abs(&Mst-&Med)/1048576.0<<endl;
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i],a[i]+=a[i-1];
	S[0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=i;j++)
			S[i][j]=add(S[i-1][j-1],j*S[i-1][j]%mod);
	inv[1]=1;
	for(int i=2;i<=n+1;i++)
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(int i=0;i<=n;i++)
		f[i][0]=i;
	ll ans=0;
	for(int i=n;i>=1;i--){
		ll coef=qpow(a[i],mod-2);
		for(int j=0;j<i;j++){
			for(int k=n-i;k>=0;k--)
				f[j][k+1]=f[j][k];
			f[j][0]=0;
			int t=min(i,j+2);
			for(int k=n-i;k>=0;k--){
				Add(f[j][k],f[t][k]*a[i]%mod);
				Sub(f[j][k+1],f[t][k]);
			}
			for(int k=0;k<=n-i+1;k++)
				f[j][k]=f[j][k]*coef%mod;
		}
		for(int j=0;j<=n-i+1;j++)
			Add(ans,f[0][j]*calc(j,a[i-1],a[i]-1)%mod);
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：R_shuffle (赞：1)

唉，这题没人场切的主要原因是这场比赛出晚了，要是去年出伟大的 huangleyi0129 就能直接切了。

----------
实际上我并不会这道题，所以不妨先考虑暴力。

即先枚举所有可能的**牌堆**，然后分析怎么选。

如果直接正着考虑，发现这个策略是难以描述的。虽然波特的策略是固定的，但是小可可的策略是比较复杂的，需要同时考虑两件事，一个是让自己最大化，一个是让波特最小化。

那么还是考虑暴力，如果暴力模拟小可可和波特的操作过程是比较简单的。用这个暴力打表可以发现，小可可的操作大部分都会集中在右边。进一步分析，可以得到一个结论。

结论一：若设小可可拿到的牌的位置为 $p_1,p_2,…,p_n$，则有 $\forall i\in[1,n],p_i>2(i-1)$。

证明是简单的，由于两人是交替操作，所以可以保证前 $2i$ 个位置的牌至少有一半是会被波特取走。这也解释了小可可的大部分操作集中在右边的情况。

然后求最大值就比较简单了，由于得到的价值和操作的顺序无关，所以考虑从后往前枚举，用堆维护最大值，每次往堆中加入两个数，然后取走其中的最大值即可。

然后考虑优化这个东西，由于枚举还是非常慢的，所以考虑拆贡献。一种常见的拆贡献的方法就是把 $i$ 的贡献拆到 $[1,i]$ 各有 $1$ 的贡献。所以这样拆过，贡献上就具有单调性了。显然较小的数的贡献一定不小于较大的数的贡献。

由这个方法，不妨考虑 dp，设 $f_i$ 表示最终选出的牌中不小于 $i$ 的牌数，则显然最后的价值为 $\sum\limits_{i=1}^mf_i$。然后由于是求期望，所以可以按照题目给出的式子把和的期望拆成期望的和。即 $E(\sum\limits_{i=1}^mf_i)=\sum\limits_{i=1}^mE(f_i)$。然后考虑 $E(f_i)$ 怎么求。

显然，可以用一个二分的常用思路，即把 $\geq i$ 的数看做 $1$，其余的看做 $0$，然后这样个数就直接变成原先的价值了。

然后就可以设计 dp 了，考虑设 $dp_{i,j}$ 表示把 $i$ 即以后的牌都加入了，堆中还有 $j$ 个 $1$ 的概率。那么通过对后面的 $1$ 计数就可以知道小可可取了多少个 $1$。所以这部分的期望也可以拆，拆成 $i$ 及后面所有的 $1$ 的个数的期望减去堆中还剩的 $1$ 的个数的期望。这两个期望用 dp 数组都是好算的。dp 的转移也是简单的，考虑 $a$ 数组中每个数与当前考虑的数的关系即可。

但是这样状态数还是非常多的，考虑怎么不依赖 $m$。这里将 $dp_{i,j}$ 看做关于考虑的数的一个多项式，然后发现可以用拉格朗日插值优化，复杂度就变成 $O(n^3)$ 了。

---


# 『STA - R9』咏叹调调律

## 题目描述

一段旋律是一个仅含 $\tt ABC$ 的字符串 $S$。一段旋律被称作咏叹调当且仅当可以通过每次删除一个 $\tt AB$ 子序列、$\tt CA$ 子序列、$\tt AAA$ 子序列或 $\tt CCB$ 子序列来得到空串。

对于非负整数 $p,q,r$，一段含 $a$ 个 $\tt A$、$b$ 个 $\tt B$、$c$ 个 $\tt C$ 的旋律的音韵被定义为 $p^aq^br^c$（其中 $0^0=1$）。

给定正整数 $n,p,q,r$，对于每个 $1\le k\le n$，问长度为 $k$ 的咏叹调的音韵之和。答案可能很大，对 $998244353$ 取模。

## 说明/提示

**样例解释**

长度为 4 的咏叹调：AABB, ABAB, ABCA, ACAB, ACBA, CAAB, CABA, CACA, CCAA。

**数据范围**

本题各数据点分值等分。令 $M=998244353$ 是模数。

| 测试点编号 | $n$ | $p$ | $q$ | $r$ |
| :--: | :--: | :--: | :--: | :--: |
| $1$ | $\le 10$ | $\in[0,M)$ | $\in[0,M)$ | $\in[0,M)$ |
| $2$ | $\le200$ | $\in[0,M)$ | $=0$ | $=0$ |
| $3\sim4$ | $\le200$ | $=0$ | $\in[0,M)$ | $\in[0,M)$ |
| $5\sim6$ | $\le200$ | $\in[0,M)$ | $=0$ | $\in[0,M)$ |
| $7\sim8$ | $\le200$ | $\in[0,M)$ | $\in[0,M)$ | $=0$ |
| $9\sim11$ | $\le30$ | $\in[0,M)$ | $\in[0,M)$ | $\in[0,M)$ |
| $12\sim14$ | $\le50$ | $\in[0,M)$ | $\in[0,M)$ | $\in[0,M)$ |
| $15\sim19$ | $\le200$ | $\in[0,M)$ | $\in[0,M)$ | $\in[0,M)$ |
| $20$ | $\le500$ | $\in[0,M)$ | $\in[0,M)$ | $\in[0,M)$ |

对于全部数据，$1\le n\le 500$，$0\le p,q,r<M$。

## 样例 #1

### 输入

```
4 1 1 1```

### 输出

```
0 2 2 9```

# 题解

## 作者：wang54321 (赞：8)

update：应 jijidawang 要求在末尾换成了一份调试版代码

可能是内测人员题解。

这个题场上很多选手都写了假的 dp，获得了 $35$ 分，事实上当初验这个题的时候大家都写假 dp 爆炸了，然后前面 $5$ 分暴力的包其实能起到一个提示你假了的作用，然后这个题拥有一份正确的指数暴力是非常重要的，然而场上并没有很多人去写这个暴力，我们几个翻提交记录的时候一起变身急急大王。

首先子串的可删性是不好刻画的，首先看一下特征，就是 $\text{B}$ 全在结尾，$\text{C}$ 全在开头，那么如果只有 $\text{B}$ 和 $\text{C}$ 就只有 $\text{CCB}$ 一种消除方式，考虑一个括号序列，左括号匹配一个右括号，这里两个 $\text{CC}$ 匹配一个 $\text{B}$，就是 $\text{C}$ 是左括号，$\text{B}$ 是两个右括号。

那么我们发现 $\text{A}$，相当于是选择成为两个左括号或者一个右括号。

现在考虑简单情况，就是一个括号序列，可以填写 $\text{(},\text{?},\text{)}$，其中问号代表通配符，问合法的括号序列的个数。

发现如果一个序列合法的话必然将一个前缀的问号全换成左括号，后缀全部换成右括号不劣，并且这样合法的分界点只有一个，设 $dp_{i,j,0/1}$ 表示填到第 $i$ 个数，前面剩下 $j$ 个没匹配的左括号，当前的问号代表 左/右 括号，直接做就好了（事实上这题已经能做[1e7](https://yundouxueyuan.com/p/YDRG006G)了，灌注 jijidawang 谢谢喵，灌注 joke3579 谢谢喵）。

接下来考虑原问题，这个 $\text{A}$ 就是刚才的问号的地位，接下来所有特殊性质就显然了。

然后有一个深刻的问题就是 $\text{AACB}$ 转化成括号之后是 $\text{(()())}$，但是它消不掉，这里需要特殊注意一下，因为后面的 $\text{B}$ 不能拆成一半和前面的 $\text{AA}$ 匹配，一半和前面的 $\text{C}$ 匹配。

那么我们仿照上面的括号处理方式，先来考虑如何判定：

1. 每当遇到一个单独的右括号的时候肯定优先匹配双左括号，注意剩下的这一个括号是特殊的（只能用 $\text{A}$ 也就是单右括号删除,但是可以被 $\text{B}$ 抢夺）。

2. 每当遇到一个双右括号的时候优先匹配双左括号，否则的话匹配两个单左括号。

于是设 $dp_{i,j,k,s,0/1}$ 表示到第 $i$ 个数，前面有 $j$ 个单左括号，$k$ 个双左括号，特殊括号的状态，当前问号的状态。

直接 dp 就好了，代码非常难看。

提供一份调试用代码，输入 $n$，它会按照字典序输出所有长为 $n$ 的咏叹调，大概能跑 $n \le 15$。

它实现和正解的 dp 几乎没区别，就是把答案集合全部记录了，一些实现细节也可以看里面的。

```cpp
#include<bits/stdc++.h>
using namespace std;
using llt=long long;
const llt N=20,mod=998244353;
llt n;vector<string> dp[N][N][N][3][2],Ans;
void add(vector<string> &S,vector<string> A,char s){if(s=='O')for(auto v:A)   S.push_back(v);else for(auto v:A)   S.push_back(v+s);}
int main()
{
    cin>>n;
    dp[0][0][0][0][0].push_back("");
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=i;j++)
            for(int k=0;k+j<=i;k++)
            {
                if(j>=1)
                    add(dp[i][j][k][0][0],dp[i-1][j-1][k][0][0],'A'),
                    add(dp[i][j][k][1][0],dp[i-1][j-1][k][1][0],'A'),
                    add(dp[i][j][k][2][0],dp[i-1][j-1][k][2][0],'A');
                add(dp[i][j][k][(k>0)+1][1],dp[i-1][j+1][k][0][1],'A');
                add(dp[i][j][k][(k>0)+1][1],dp[i-1][j+1][k][0][0],'A');
                add(dp[i][j][k][0][1],dp[i-1][j][k][1][1],'A');  
                add(dp[i][j][k][0][1],dp[i-1][j][k][2][1],'A');  
                add(dp[i][j][k][0][0],dp[i-1][j+1][k][0][0],'B'),
                add(dp[i][j][k][0][1],dp[i-1][j+1][k][0][1],'B'),
                add(dp[i][j][k][1][0],dp[i-1][j+1][k][1][0],'B'),
                add(dp[i][j][k][1][1],dp[i-1][j+1][k][1][1],'B'),
                add(dp[i][j][k][2][0],dp[i-1][j+1][k][2][0],'B'),
                add(dp[i][j][k][2][1],dp[i-1][j+1][k][2][1],'B');
                if(k>=1)
                    add(dp[i][j][k][0][0],dp[i-1][j][k-1][0][0],'C'),
                    add(dp[i][j][k][0][1],dp[i-1][j][k-1][0][1],'C'),
                    add(dp[i][j][k][1][0],dp[i-1][j][k-1][1][0],'C'),
                    add(dp[i][j][k][1][1],dp[i-1][j][k-1][1][1],'C'),
                    add(dp[i][j][k][2][0],dp[i-1][j][k-1][2][0],'C'),
                    add(dp[i][j][k][2][1],dp[i-1][j][k-1][2][1],'C');
            }
        for(int k=0;k<=i;k++) 
            add(dp[i][0][k][0][0],dp[i-1][0][k+2][0][0],'B'),
            add(dp[i][0][k][0][1],dp[i-1][0][k+2][0][1],'B'),
            add(dp[i][0][k][1][0],dp[i-1][0][k+2][1][0],'B'),
            add(dp[i][0][k][1][1],dp[i-1][0][k+2][1][1],'B'),
            add(dp[i][0][k][0][1],dp[i-1][0][k+1][0][0],'A'),
            add(dp[i][0][k][0][1],dp[i-1][0][k+1][0][1],'A'),
            add(dp[i][0][k][0][1],dp[i-1][0][k+1][2][1],'B');
        for(int j=0;j<=i;j++)   add(dp[i][j][0][1][1],dp[i][j][0][2][1],'O');
    }
    add(Ans,dp[n][0][0][0][0],'O');add(Ans,dp[n][0][0][0][1],'O');sort(Ans.begin(),Ans.end());
    for(auto v:Ans) cout<<v<<endl;
    return 0;
}
```

---

## 作者：jijidawang (赞：8)

首先把题面转化为有四种字符 $\tt U_1,U_2,D_1,D_2$：原串中的 $\tt A$ 对应 $\tt U_2$ 或 $\tt D_1$、原串中的 $\tt B$ 对应 $\tt D_2$、原串中的 $\tt C$ 对应 $\tt U_1$。一个串是咏叹调当且仅当存在新串可以通过每次删 $\tt U_2D_2,\,U_1D_1,\,U_2D_1D_1,\,U_1U_1D_2$ 子序列来得到空串。

考虑把四种字符 $\tt U_2,U_1,D_1,D_2$ 分别改成 $2,1,-1,-2$，那么串是咏叹调的一个必要条件是序列的总和为 $0$，那么可以计算出原串中 $\tt A$ 有多少个变成 $\tt U_2$、多少个变成 $\tt D_1$，也就是转化后的串中每种字符的出现次数都是一定的。

注意到每个 $\tt U_2$ 只能和后面的元素匹配，每个 $\tt D_1$ 只能和前面的元素匹配。如果新串 $T$ 中两个位置 $i,j$（$i<j$）满足 $T_i={\tt D_1},T_j={\tt U_2}$，那么交换 $T_i,T_j$ 可以使得它们都获得更多的匹配机会，也就是一定不劣。那么可以钦定转化后的串中一段前缀的 $\tt A$ 替换为 $\tt U_2$、剩余位置的 $\tt A$ 替换为 $\tt D_1$。

到这里问题被转化为这样的问题：一个 $\tt U_2,U_1,D_1,D_2$ 序列是好的当且仅当每个 $\tt U_2$ 都在 $\tt D_1$ 前面，并且可以通过每次删一个 $\tt U_2D_2,\,U_1D_1,\,U_2D_1D_1,\,U_1U_1D_2$ 子序列来得到空串。一个含 $a,b,c,d$ 个 $\tt U_2,U_1,D_1,D_2$ 的序列的权值为 $p^{a+c}q^dr^b$，求所有长度为 $n$ 的好序列的权值和。

先考虑如何判定一个串是否能被删子序列操作删空，考虑一个贪心匹配的策略：按顺序扫描整个串，并且记录当前未被匹配的 $\tt U_1,U_2$ 的数量。当遇到一个 $\tt D_1$ 时优先和 $\tt U_2$ 结合得到一个 $\tt U_2D_1$ 组，等待结合一个 $\tt D_1$ 后消除（这样的组任意时刻最多存在一个），如果没有 $\tt U_2$ 则和 $\tt U_1$ 结合消除 $\tt U_1D_1$，如果结合不了则不合法。当遇到一个 $\tt D_2$ 时，如果有自由 $\tt U_2$ 则结合消除 $\tt U_2D_2$，否则如果有多于 $2$ 个自由 $\tt U_1$ 则结合消除 $\tt U_1U_1D_2$，否则如果夺取 $\tt U_2D_1$ 组中的 $\tt U_2$ 消除 $\tt U_2D_2$ 后的 $\tt D_1$ 后 $\tt D_1$ 还能和他所在位置左侧的 $\tt U_1$ 结合则又得到 $\tt U_1D_1$ 消除，否则不合法。

关于怎么把判定改成权值和，考虑设计一个 DP，根据上述分析状态只需要记录序列长度、存活的 $\tt U_1,U_2$ 个数、当前填的 $\tt A$ 是 $\tt U_2$ 还是 $\tt D_1$、$\tt U_2D_1$ 组状态（不存在、存在且前面没有 $\tt U_1$、存在且前面有 $\tt U_1$）即可，那么问题可以在 $\Theta(n^3)$ 内被解决。

---

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P12264)
## 题意
对于一个字符集为 $\{\tt A,B,C\}$ 的字符串，若其可通过不断删去其中的 $\tt AB,CA,AAA,CCB$ 子序列将其删空，则称该串是好的。

给定常数 $p,q,r$，对于一个好的串，若其中分别有 $a,b,c$ 个 $\tt A,B,C$，那么定义其权值为 $p^aq^br^c$。

给定正整数 $n$，对于所有的 $1\le k\le n$，求出所有长为 $k$ 的好的串的权值和，对 $998244353$ 取模。

$n\le 500$。
## 题解
首先观察字符 $\tt A$，可以知道必定有一个前缀的 $\tt A$ 匹配 $\tt AB$、一个后缀的 $\tt A$ 匹配 $\tt CA$。如果我们可将 $\tt AAA$ 划分为两部分，那么就可以变为一个前缀的 $\tt A$ 匹配 $\tt AB$ 或 $\tt AAA$ 的前半部分，而剩余后缀中的 $\tt A$ 匹配 $\tt CA$ 或 $\tt AAA$ 的后半部分，接下来将前缀 $\tt A$ 与后缀 $\tt A$ 分别记作 $\tt A_L,A_R$。

接下来是一个核心观察：**将 $\tt{{ A_L,C,A_R,B}}$ 分别看作两个左括号、一个左括号、一个右括号、两个右括号，则一次操作可删去的串为合法括号串**。注意这只是必要条件，因为我们不能将两个左括号或右括号匹配不同类型的字符，如 $\tt A_LA_RCB$ 是不合法的，我们只能通过括号匹配的思想进行性质推导。

由于替换后的括号串，其合法首先是一个必要条件，这也告诉我们如果一个字符串合法，其必定唯一对应一种替换 $\tt A$ 为 $\tt A_L,A_R$  的方式。由于单括号的匹配自由度高于双括号的匹配自由度，故四种删除方式的优先级为 $\tt A_LB>A_LA_RA_R/CCB>CA_R$。

接下来开始考虑 DP。首先必须要记录当前的总长与字符 $\tt A_L$ 与 $\tt C$ 分别剩余的个数 $i,j,k$ 三维，故接下来只能增加一些常数维度：
- 需要增加一维 $0/1$ 表示当前的字符 $\tt A$ 对应字符 $\tt A_L$ 还是字符 $\tt A_R$；
- 当出现字符 $\tt A_R$ 时，我们优先考虑匹配 $\tt A_LA_R$ 并等待下一个 $\tt A_R$，但由于 $\tt A_LB$ 的优先级高于 $\tt A_LA_RA_R$，故如果当前可匹配 $\tt CA_R$，需要预留一次反悔机会，增加一维 $0/1/2$ 分别表示不存在 $\tt A_LA_R$/存在不可反悔的 $\tt A_LA_R$/存在可反悔的 $\tt A_LA_R$ 即可。

当出现 $\tt B$ 时，优先考虑与当前未配对的 $\tt A_L$ 匹配，再考虑与当前可反悔的 $\tt A_LA_R$ 进行匹配，最后尝试匹配 $\tt CCB$；若存在已配对的 $\tt A_LA_R$ 时再出现 $\tt A_R$，那么必定将其匹配为 $\tt A_LA_RA_R$，如果不这么做则此时必定存在两个 $\tt C$，下次出现 $\tt B$ 必定可匹配一组 $\tt CCB$。

直接枚举添加的字符类型做 DP 即可，时间复杂度 $O(n^3)$。
****
代码实现需要特别注意匹配顺序，不然就会出现 35 分笑传之错 Code B。

```cpp
//f[i][j][k][0/1][0/1][0/1]:填了 i 位, 当前有 j 个可用 A_L, k 个 C, 是否切换至选择 A_R, 是否存在反悔机会, 是否已强制匹配 A_LA_R 
int main(){
	n=read(),p=read(),q=read(),r=read();
	f[0][0][0][0][0][0]=1;
	for(int i=0,t=1;i<n;i++,t^=1){
		for(int j=0;j<=i;j++)
			for(int k=0;j+k<=i;k++)
				for(int a=0;a<2;a++)
					for(int b=0;b<2;b++)
						for(int c=0;c<2;c++){
							int w=f[!t][j][k][a][b][c];
							if(!w) continue;
							int wa=1ll*w*p%mod,wb=1ll*w*q%mod,wc=1ll*w*r%mod;
							//A_L
							if(!a) inc(f[t][j+1][k][0][0][0],wa);
							//A_R
							if(c) inc(f[t][j][k][1][b][0],wa);
							else if(b) inc(f[t][j][k+1][1][0][0],wa);
							else if(j&&k) inc(f[t][j-1][k-1][1][1][0],wa);
							else if(j) inc(f[t][j-1][k][1][0][1],wa);
							else if(k) inc(f[t][j][k-1][1][0][0],wa);
							//B
							if(j) inc(f[t][j-1][k][a][b][c],wb);
							else if(b) inc(f[t][j][k][1][0][c],wb);
							else if(k>=2) inc(f[t][j][k-2][a][b][c],wb);
							//C
							inc(f[t][j][k+1][a][b][c],wc);
							f[!t][j][k][a][b][c]=0;
						}
		for(int a=0;a<2;a++)
			inc(ans[i+1],f[t][0][0][a][0][0]);
	}
	for(int i=1;i<=n;i++)
		write(ans[i]),putc(' ');
	flush();
}
```

---

## 作者：Nephren_Sakura (赞：1)

很有意思的计数题！观察！注意！启示！

观察给出的四个字符串，注意到这四个串的 B 都在结尾，C 都在开头，这启示我们把 C 当成左括号，B当成右括号进行括号匹配，因为给出的字符串是 CCB，所以 B 要当成两个右括号。

接下来观察 A，注意到 A 出现在 CA、AB 中，这启示我们把 A 当成一个可以成为单右括号或双左括号的通配符。代入发现这同样能凑出 AAA。

继续观察，注意如果你将前面的 A 当作右括号，后面的 A 当作左括号，你直接交换过来是不劣的，因为你匹配的是子序列，这启示我们存在一个分界线，使得前面的 A 被当成双左括号，右边被当成单右括号。这代表我们可以直接把当前 A 是左括号还是右括号扔进状态里。

试着写个 DP，发现算重了，这是因为一个字符串会有多种匹配方式，这启示我们钦定一个优先级，使得某个优先级优先匹配。

注意到你两个左括号或右括号不能各自匹配一半，比如 AACB，直接转括号序列是 ```(()())```，但事实上是不合法的，因为 A 的第一个左括号和 B 的最后一个右括号匹配了。这启示我们优先匹配变成两个括号的字母，也就是左 A 和 B。

此时还有一个问题，就是你加入右 A 时，和左 A 匹配，剩下的那个括号只能与另一个右 A 匹配。这个时候你再加入一个 B，如果你加入的右 A 左边有 C，按照优先匹配双括号的优先级，你应该是要用这个 B 去匹配左 A，然后 C 匹配右 A 的。于是再加入一维状态，表示现在是否存在只能匹配右 A 的特殊括号。如果存在，这个括号是否能和 B 交换。

所以最终的状态就是 $dp_{i,j,k,0/1,0/1/2}$ 表示使用了 $i$ 个字母，剩下 $j$ 个左 A，$k$ 个 C，当前 A 是否已经只能取右括号，只能与右 A 匹配的括号的状态。转移枚举每种字符进行转移即可。时间复杂度 $O(n^3)$，空间复杂度滚动数组优化后 $O(n^2)$。

我代码里最后一维是 $1/2/3$，相当于把 $0/1/2$ 都加了 $1$，事实上没有必要，但懒得改了。

代码，注释应该算比较清晰的：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
int n,p,q,r,dp[2][505][505][2][4];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>p>>q>>r;
	dp[0][0][0][0][1]=1;
	for(int i=0; i<n; i++){
		for(int j=0; j<=i; j++){
			for(int k=0; j+k<=i; k++){
				for(int l=0; l<2; l++){
					for(int s=1; s<=3; s++){
						if(!dp[i&1][j][k][l][s]) continue;
						if(!l) (dp[i+1&1][j+1][k][0][s]+=dp[i&1][j][k][l][s]*p)%=mod;//加入左 A
						if(s==3) (dp[i+1&1][j][k][1][1]+=dp[i&1][j][k][l][s]*p)%=mod;//加入右 A，发现存在只能匹配右 A 的右括号，且右括号前面没 C
						else if(s==2) (dp[i+1&1][j][k+1][1][1]+=dp[i&1][j][k][l][s]*p)%=mod;//加入右 A，发现存在只能匹配右 A 且前面有 C 的右括号，把被预留的 C 加回来。
						else if(j&&k) (dp[i+1&1][j-1][k-1][1][2]+=dp[i&1][j][k][l][s]*p)%=mod;//加入右 A，发现不存在只能匹配右 A 的左括号，且前面既有左 A 又有 C，匹配左 A 并预留一个 C
						else if(j) (dp[i+1&1][j-1][k][1][3]+=dp[i&1][j][k][l][s]*p)%=mod;//同上，发现只存在左 A，特殊括号增加只能匹配右 A 且前面没 C 的右括号
						else if(k) (dp[i+1&1][j][k-1][1][1]+=dp[i&1][j][k][l][s]*p)%=mod;//同上，发现只存在 C，直接匹配
						if(j) (dp[i+1&1][j-1][k][l][s]+=dp[i&1][j][k][l][s]*q)%=mod;//加入 B，优先和左 A 匹配
						else if(s==2) (dp[i+1&1][j][k][1][1]+=dp[i&1][j][k][l][s]*q)%=mod;//如果没有，考虑和特殊括号置换
						else if(k>=2) (dp[i+1&1][j][k-2][l][s]+=dp[i&1][j][k][l][s]*q)%=mod;//如果还没有，考虑和两个 C 匹配
						(dp[i+1&1][j][k+1][l][s]+=dp[i&1][j][k][l][s]*r)%=mod;//加入 C
						dp[i&1][j][k][l][s]=0;
					}
				}
			}
		}
		cout<<(dp[i+1&1][0][0][0][1]+dp[i+1&1][0][0][1][1])%mod<<' ';
	}
	return 0;
}
```

---


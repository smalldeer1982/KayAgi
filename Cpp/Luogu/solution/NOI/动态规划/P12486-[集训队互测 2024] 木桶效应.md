# [集训队互测 2024] 木桶效应

## 题目背景

构成组织的各个部分往往是优劣不齐的，而劣势部分往往决定整个组织的水平。 

## 题目描述

小 D 有 $n$ 个木桶，每个木桶由 $m$ 块类型互不相同的木板构成。对于一个木桶，如果它的木板长度为 $a_1,a_2,...,a_m$，那么这个木桶所能盛放的液体体积为 $\min_{i=1}^m a_i$。小 D 的 $n$ 个木桶很神奇，它们所能造成的收益并不简单的是每个木桶的液体体积之和，而是每个木桶的液体体积之积。也就是说，对于这 $n$ 个木桶，如果第 $i$ 个木桶的第 $j$ 块木板的高度为 $p_{j,i}$，那么这些木桶造成的收益为 $\prod_{i=1}^n (\min_{j=1}^m p_{j,i})$。

小 D 已经从木材店买到了一些木板，但是，木材店的木板数量是很有限的。具体来说，对于这 $m$ 种木板，每种木板小 D 恰好有 $1\sim n$ 长度的木板各一个。小 D 现在已经放好了 $q$ 条木板，但还没有想好怎么放置这些木板，所以，他希望你能求出来对于所有合法的放置木板的方案对应的收益之和。由于这个数可能很大，所以他只需要你输出对 $998244353$ 取模的结果。

### 形式化题意

有 $m$ 个长度为 $n$ 的排列，其中共有 $q$ 个位置的值已经确定，其余位置未确定。求所有本质不同的排列组对应的 $\prod_{i=1}^n (\min_{j=1}^m p_{j,i})$ 之和。对 $998244353$ 取模。两组排列 $P,Q$ 本质不同，当且仅当存在 $i,j$ 使得 $P_{i,j}\neq Q_{i,j}$。保证至少存在一种合法方案。

## 说明/提示

**本题采用捆绑测试。**

对于所有的数据，满足 $1\leq n\leq 50,1\leq m<998244353,0\leq q\leq 10,1\leq x\leq m,1\leq y,w\leq n$。

- Subtask 1(4pts)：$n\leq 5,m\leq 3$。

- Subtask 2(8pts)：$n\leq 7,m\leq 3$。

- Subtask 3(8pts)：$m\leq 2,q=0$。

- Subtask 4(12pts)：$q=0$。

- Subtask 5(16pts)：$n\leq 20,q\leq 5$。

- Subtask 6(12pts)：$q\leq 5$。

- Subtask 7(20pts)：$q\leq 7$。

- Subtask 8(12pts)：$q\leq 9$。

- Subtask 9(8pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2 0```

### 输出

```
6```

## 样例 #2

### 输入

```
3 2 1
1 1 1```

### 输出

```
38```

## 样例 #3

### 输入

```
50 50 5
6 18 17
10 2 14
43 12 40
11 50 37
45 23 4```

### 输出

```
830538815```

# 题解

## 作者：Wonder_Fish (赞：4)

学到了一个比较好的做法，遂记录一下。

---

### 问题转化

本题要求 $\sum_p \prod_{i=1}^n (\min_{j=1}^m p_{j,i})$，考虑其组合意义：对于每个由 $m$ 个排列组成的排列组 $p$，为每一列 $i$ 分配一个数 $val_i$ 满足 $\forall 1\leq j \leq m,val_i \leq p_{j,i}$，求所有排列组分配 $val$ 的方案数之和。

对 $p$ 计算 $val$ 的方案需要容斥，较为复杂，考虑对每组 $val$，计算其对于多少排列组 $p$ 是合法的。

考虑从小到大枚举 $i$，确定 $val=i$ 的列并填入每个排列值为 $i$ 的位置。注意到排列的 $i$ 只能填入 $val \leq i$ 的列，所以每次先插入列，恰好可以在插入后计算填入排列的 $i$ 的方案，并且这两部分几乎是独立的。

---

### 特殊性质 $q=0$

考虑根据上述转化设计 dp，设 $f_{i,j}$ 表示考虑到数值 $i$，已经有 $j$ 列的 $val$ 被确定的所有方案，其填完所有排列 $\leq i$ 的位置的方案数之和。

枚举 $i$，转移分为两部分：

- 枚举 $val=i$ 的列数 $k$，插入前的列数 $j$，然后加入这 $k$ 列。转移需要乘上一个组合数。对于每个 $i$ 这部分复杂度 $O(n^2)$

- 枚举插入完后的列数 $j$，填入所有排列的 $i$。对 $f_{i,j}$ 乘上填 $i$ 的方案数，此时每行剩下的能填的空位数都是 $j-i+1$，所以方案数是 $(j-i+1)^m$。这部分复杂度 $O(n)$

最终答案为 $f_{n,n}$。时间复杂度 $O(n^3)$。

---

### 满分做法

确定值的存在，影响了对方案数的计算。对于 $f_{i,j}$，其代表的所有方案的填法数不一定相同了。

下面称存在确定值的行为特殊行，列为特殊列，其余为普通行，列。

注意到 $q\leq 10$，说明存在确定值的行和列都不多，考虑状压。设 $f_{i,j,S}$ 表示考虑到 $i$，已经有 $j$ 个普通列和集合 $S$ 中的特殊列的 $val$ 被确定了，填完所有排列 $\leq i$ 的位置的方案数之和。

转移依然可以分成两部分：

- 插入 $val=i$ 的列，这部分可以继续分为插入普通列和特殊列，并且这两部分相对独立，可以分开考虑。对于普通列，固定 $S$，其余和特殊性质的部分相似，复杂度是 $O(n^22^q)$。对于特殊列，固定 $j$，剩余部分相当于高维前缀和，可以做到 $O(nq2^q)$。

- 计算填入排列的方案数，同样继续分为普通行和特殊行的方案数。普通行每行空位是 $j+popcnt(S)-i+1$，特殊行需要考虑是否有特殊位置的值为 $i$，若有表示已经确定位置，方案数为 1；否则空位数是普通行空位数减去这行值 $>i$ 的特殊位置个数。这部分是 $O(nq2^q)$ 的。

综上，总复杂度是 $O(n^22^q(n+q))$ 的。

---

### Code

代码写的比较丑 QAQ

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
#define mod 998244353
#define N 60
#define pii pair<int,int>
#define fi first
#define sc second
#define mp make_pair
#define int long long
#define il inline
int n,m,k,h,q,a[N],b[N],cnt[1<<10],f[N][N][1<<10],c[N][N];
int s[N],t[N],v[N],d[N]; pii p[N];
il void madd(int &x,int y){
    x=(x+y>=mod)?(x+y-mod):(x+y); return ;
}
il int qpow(int a,int b){
    int res=1;
    while(b){if(b&1) res=res*a%mod;a=a*a%mod,b>>=1;}
    return res;
}
signed main(){
    // freopen("a.in","r",stdin);
    // freopen("a.out","w",stdout);
    scanf("%lld%lld%lld",&n,&m,&q);
    for(int i=0;i<=n;++i) c[i][0]=1;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
    for(int i=1;i<=q;++i){
        scanf("%lld%lld%lld",&p[i].fi,&p[i].sc,&v[i]);
        a[i]=p[i].sc,b[i]=p[i].fi,++s[v[i]];
    }
    sort(a+1,a+q+1),k=unique(a+1,a+q+1)-a-1;
    for(int i=1;i<=q;++i){
        p[i].sc=lower_bound(a+1,a+k+1,p[i].sc)-a-1;
        t[v[i]]|=(1<<p[i].sc);
    }
    sort(b+1,b+q+1),h=unique(b+1,b+q+1)-b-1;
    for(int i=1;i<=q;++i)
        p[i].fi=lower_bound(b+1,b+h+1,p[i].fi)-b;
    for(int S=1;S<(1<<k);++S) cnt[S]=cnt[S>>1]+(S&1);
    f[0][0][0]=1;
    for(int i=1;i<=n;++i){
        for(int j=0;j<=n-k;++j)
            for(int S=0;S<(1<<k);++S) if(f[i-1][j][S])
                for(int l=0;j+l<=n-k;++l)
                    f[i][j+l][S]=(f[i][j+l][S]+f[i-1][j][S]*c[n-k-j][l])%mod;
        for(int j=0;j<=n-k;++j)
            for(int l=0;l<k;++l)
                for(int S=0;S<(1<<k);++S)
                    if(S&(1<<l)) madd(f[i][j][S],f[i][j][S^(1<<l)]);
        for(int j=0;j<=n-k;++j)
            for(int S=0;S<(1<<k);++S){
                if((S&t[i])!=t[i]||j+cnt[S]<i) f[i][j][S]=0;
                if(!f[i][j][S]) continue;
                memset(d,0,(h+1)<<3);
                for(int l=1;l<=q;++l) if(S&(1<<p[l].sc)){
                    if(v[l]==i) d[p[l].fi]=-inf; if(v[l]>i) ++d[p[l].fi];
                }
                f[i][j][S]=f[i][j][S]*qpow(j+cnt[S]-i+1,m-h)%mod;
                for(int l=1;l<=h;++l) if(d[l]>=0)
                    f[i][j][S]=f[i][j][S]*(j+cnt[S]-i+1-d[l])%mod;
            }
    }
    printf("%lld\n",f[n][n-k][(1<<k)-1]);
    return 0;
}
```

---

## 作者：Erine (赞：1)

暴力过了，出题人你有什么头猪吗？？？

---

感觉上这个权值就得组合意义搞一下，相当于选出 $a_1\sim a_n$ 使得 $p_{i,j}\ge a_j$ 的方案数，然后交换求和顺序，就可以先确定 $a_1\sim a_n$ 再计算 $p$ 的方案数，而这样每个排列就是独立的，可以单独算了。所以这样我们已经解决掉了 $q=0$，因为对一个排列钦定每个位置 $\ge a_i$ 的方案数是排序后可以计算的，因此我们要做的仅仅是从大到小加入 $a_i$，以及记录加入了多少数。然后你就得到了多项式复杂度的 dp。

接下来我们加入一些特殊点，就不得不往里面加入一些状压的成分。不妨定义有点的行是特殊行，否则是普通行；列同理。于是有 $f_{i,S,j}$ 表示，当前钦定加入了所有 $a\ge i$ 的列，其中覆盖了 $S$ 这个状态的特殊列以及 $j$ 个普通列。

转移枚举一个 $T\subseteq S$，$k\le j$，从 $f_{i+1,T,k}$ 转移过来。考虑计算系数。所有普通行系数相同，随便计算。每个特殊行都要特别计算。建议读者自己手推。还要乘一个组合数表示选择普通列。注意钦定 $S$ 中所有特殊点都要 $\ge i$，否则状态无效。

然后你的式子可能会长的很丑陋（当然有可能很优美，而且可以直接优化做掉；但是我手推的时候得到了一个丑陋的无法优化的形式），只能做到 $\Theta(3^q n^3)$，而且常数还没小到能直接过掉，但是卡卡上界啥的可以获得 $92$ 分（？）。而现在要做的实际上是把这个很丑陋的系数式子化成一个好看的形式，hint：对每一位分开考虑。你可能需要一些“$S$ 中所有特殊点都要 $\ge i$”带来的性质，否则没有简易形式。建议读者自己手推。

把式子写成好看的之后你会发现瓶颈只剩下了一个子集求和，然后可以高维前缀和预处理掉。但是不写高维前缀和而是仅仅交换一次求和顺序就能通过这道题（复杂度不变，常数变小了，可能还有内存连续啥的，但是不应该过的！！）。写了高维前缀和也不过快一倍而已。

所以正解的总复杂度会长成 $\Theta(2^qn^3)$ 这样。可以通过。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P12486)

**题目大意**

> 给定 $m\times n$ 网格，每行要是一个 $1\sim n$ 排列，权值定义为每列最小值乘积，给定 $q$ 个位置的值，求每种方案的权值乘积。
>
> 数据范围：$n\le 50,m\le 10^9,q\le 10$。

**思路分析**

考虑 $q=0$ 时怎么做，注意到权值相当于选定 $a_1\sim a_n$，要求第 $i$ 列所有元素 $\ge a_i$，求 $a$ 的方案数。

那么对 $a$ 的形态 dp，已知 $a_i$ 的情况下，递减排序后方案数为 $\prod (n-a_i+1-i+1)$，总方案数就乘上 $m$ 次方。

因此从大到小加入每种 $a$ 即可，我们只关心已经填入的列总个数。

然后考虑有 $q$ 的情况，对于没有确定位置的列，正常 dp，而有确定位置的列状压。

同理求普通行的方案数可以直接计算，而特殊行提前删掉已经确定的位置和元素，特殊计算方案数即可。

时间复杂度 $\mathcal O(2^qq^2n^2+2^qn^3)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pc __builtin_popcount
using namespace std;
const int MOD=998244353;
ll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }
int n,m,q;
ll f[55][1<<10],pw[55],fac[55],ifac[55],w[55];
vector <array<int,2>> a[15];
map <int,vector<array<int,2>>> A;
map <int,int> yid;
int S[55],to[15][55],vl[15][55];
bool vis[15][55];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	int qn=0,qm=0;
	for(int i=1,x,y,v;i<=q;++i) {
		cin>>x>>y>>v;
		if(!yid.count(y)) yid[y]=qn++;
		A[x].push_back({yid[y],v});
	}
	for(auto it:A) a[qm++]=it.second;
	for(int i=0;i<qm;++i) {
		for(auto o:a[i]) vis[i][o[1]]=true,vl[i][o[0]]=o[1],S[i]|=1<<o[0];
		for(int j=1,e=1;j<=n;++j) to[i][j]=e,e+=!vis[i][j];
	}
	for(int i=fac[0]=ifac[0]=1;i<=n;++i) ifac[i]=ksm(fac[i]=fac[i-1]*i%MOD);
	for(int i=0;i<=n;++i) pw[i]=ksm(i,m-qm);
	f[0][0]=1;
	for(int v=n;v>=1;--v) {
		for(int k=0;k<qn;++k) {
			for(int i=0;i<=n-qn;++i) for(int s=(1<<qn)-1;~s;--s) {
				int o=pc(s);
				if(!f[i][s]||(s>>k&1)||n-v+1<i+o+1) continue;
				ll p=pw[(n-v+1)-(i+o)];
				for(int t=0;t<qm;++t) {
					if(S[t]>>k&1) {
						if(v>vl[t][k]) { p=0; break; }
					} else {
						int tv=to[t][v],tc=i+o+1-pc(s&S[t]);
						if(n-pc(S[t])-tv+1<tc) { p=0; break; }
						p=p*((n-pc(S[t])-tv+1)-(tc-1))%MOD;
					}
				}
				if(p) f[i][s|1<<k]=(f[i][s|1<<k]+f[i][s]*p)%MOD;
			}
		}
		for(int s=0;s<(1<<qn);++s) {
			int o=pc(s);
			memset(w,0,sizeof(w));
			for(int i=1;i+o<=n-v+1&&i<=n-qn;++i) {
				w[i]=pw[(n-v+1)-(i+o-1)];
				for(int t=0;t<qm;++t) {
					int tv=to[t][v],tc=i+o-pc(s&S[t]);
					if(n-pc(S[t])-tv+1<tc) { w[i]=0; break; }
					w[i]=w[i]*((n-pc(S[t])-tv+1)-(tc-1))%MOD;
				}
			}
			for(int i=n-qn;~i;--i) if(f[i][s]) {
				ll p=1;
				for(int c=1;i+o+c<=n-v+1&&i+c<=n-qn;++c) {
					p=p*w[i+c]%MOD; if(!p) break;
					f[i+c][s]=(f[i+c][s]+f[i][s]*p%MOD*ifac[c])%MOD;
				}
			}
		}
	}
	cout<<f[n-qn][(1<<qn)-1]*fac[n-qn]%MOD<<"\n";
	return 0;
}
```

---


# [集训队互测 2024] 链覆盖

## 题目背景

你的学弟向你请教这样一道题：

- 给定一颗 $n$ 个点的有根树，初始所有点均为白色。

- 你可以执行不超过 $k$ 次操作，每次操作为选定一个点，把它到根简单路径上的所有点涂成黑色。

-  求你最终最多能涂黑多少点。对 $k=1 \sim n$ 分别求解。
这当然不是什么难题，你很快向学弟解释清楚了这应该怎么做，他惊叹于做法的巧妙，然后满意地离开了。

你看着他离去的身影，想起两三年前，你第一次得知这道题怎么做时，也曾为这道题的解法赞叹过。但对于现在的你来说，这也并没有什么神奇之处，只是一个平凡的套路罢了。

但熟知的原题与结论并不一定真的就乏味无趣、无甚可观，这样想着，你记录下了这道题：

## 题目描述

- 给定一颗 $n$ 个点的有根树，初始所有点均为白色。

- 你可以执行不超过 $k$ 次操作，每次操作为选定一个点，把它到根简单路径上的所有点涂成黑色。

-  求你最终最多能涂黑多少点。对 $k=1 \sim n$ 分别求解。

记对于有标号有根树 $T$，上述问题在 $k=i$ 时的答案为 $ans(T,i)$。

给定 $n,mod$，对所有 $1 \le k \le n,1 \le m \le n$，计算有多少不同的 $n$ 个点以 $1$ 为根的有标号树 $T$ 满足 $ans(T,k)=m$。答案对 $mod$ 取模。

两颗有标号以 $1$ 为根的树被认为是不同的，当且仅当它们的边集不同。

## 说明/提示

本题使用捆绑测试，你只有通过一个子任务的所有测试点，才能获得这个子任务的分数。

| Subtask | $n \le$ | 分值 |
| :-----: | :-----: |  :--: |
|   $1$   |   $5$   |  $1$  |
|   $2$   |  $10$   | $9$ |
|   $3$   |  $20$  |   $10$ |
|   $4$   |  $32$  | $15$ |
|   $5$   | $40$  | $5$ |
|   $6$   | $50$  | $15$ |
|   $7$   | $65$  |  $5$ |
|   $8$   | $80$  |  $5$ |
|   $9$   | $120$ |  $15$ |
|   $10$   | $300$  |  $20$ |

对于所有数据：$1 \le n \le 300$，$10^8 \le mod \le 1.05 \times 10^9$，保证 $mod$ 是质数。

## 样例 #1

### 输入

```
2 998244353```

### 输出

```
0 1 
0 1```

## 样例 #2

### 输入

```
3 998244353```

### 输出

```
0 1 2 
0 0 3 
0 0 3```

## 样例 #3

### 输入

```
4 998244353```

### 输出

```
0 1 9 6 
0 0 1 15 
0 0 0 16 
0 0 0 16```

## 样例 #4

### 输入

```
5 998244353```

### 输出

```
0 1 40 60 24 
0 0 1 28 96 
0 0 0 1 124 
0 0 0 0 125 
0 0 0 0 125```

## 样例 #5

### 输入

```
6 998244353```

### 输出

```
0 1 195 560 420 120 
0 0 1 75 500 720 
0 0 0 1 75 1220 
0 0 0 0 1 1295 
0 0 0 0 0 1296 
0 0 0 0 0 1296```

# 题解

## 作者：隔壁泞2的如心 (赞：2)

集训队互测出现大量不可做计数 我被吓死了 余生在阿巴阿巴中度过……

首先你可以发现！想要解决原问题我们只需要将树进行长链剖分然后贪心地选前 $k$ 长的链即可。你可以用你喜欢的方式证明它，我用的是类似 Slope Trick 的推法（

那么要想解决计数版问题，我们可以考虑给定长剖完的链长集合后，有多少棵树可以被剖成给定的集合。首先我们要规范一下长剖的过程，如果一个节点的多个儿子深度相等，我们要选择 **链底节点编号最小** 的儿子。那么我们就要考虑有多少棵树，满足它被长剖之后被分为了 $h$ 条链，并且将这些链按链底节点编号排序后，第 $i$ 个链长度为 $h_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8tyohk11.png)

如图所示，我们只需要为每个不为 $1$ 的链顶选一个父亲即可。首先每个节点的父亲都必须比自己高，不然就会违反长剖中的深度限制。如图中蓝色的连接合法，红色的连接不合法。但还要额外注意一点！如果某个点的父亲只比自己高 $1$ 条边，那么这条边一定是往左连的，不然就会违反长剖中的链底编号限制。如图中绿色的连接合法，紫色的连接不合法。当然还要乘上分配编号的方案数，不过分配编号的方案很独立，在任何情况下都是 $\dfrac{(n-1)!}{h!}$。

推到这里之后，这题的关键部分就已经过去了。题目中的 $k$ 和 $m$ 限制其实就是指“集合中前 $k$ 长的链总长为 $m$”。而我们可以很容易地通过按长度从大到小/从小到大加入链、记录已加入的链数和链的总长来 dp。

不过，本题的 dp 其实比较复杂，想要的答案和 dp 过程之间的相性并不好。“前 $k$ 长的链的总长”在 dp 中只是中间值，所以你需要用正反两个方向的 dp 数组才能将答案按照中间值分类——当然也许可以不用，dp 题最好玩的地方就是你很可能被一些不难的地方卡住……

最后需要注意答案矩阵的最后一列和别的列不太一样，由于这一列的 $m=n$，所有的链都已被选，你可能需要对它做一下前缀和（


```
#include<bits/stdc++.h>
#define int long long
#define FSIZ 407693
#define add(a,b) (a+=(b),a>=mod?a-=mod:0)
#define neg(x) ((x)&1?mod-1:1)
#define Q(a,b) C((a)+(b)-1,(b)-1)
#define cond(a,b)((a)?(b):0)
using namespace std;
int fac[FSIZ],ifac[FSIZ],inv[FSIZ];
int n,mod,dp1[304][304][304],dp2[304][304][304];
int C(int n1,int m1){
    if(m1<0||m1>n1)return 0;
    return fac[n1]*ifac[m1]%mod*ifac[n1-m1]%mod;
}
inline int qpow(int n1,int n2){
    int n3=n1,n4=1;
    while(n2){
        if(n2&1)n4*=n3,n4%=mod;
        n3*=n3,n3%=mod;n2>>=1;
    }return n4;
}
inline int mut(initializer_list<int> arg){
	int ret=1;
	for(auto i:arg)ret*=i,ret%=mod;
	return ret;
}
int res[304][304][304],ans[350][350];
signed main(){
    scanf("%lld%lld",&n,&mod);
    if(n==1){printf("1");return 0;}
    fac[0]=1;for(int i=1;i<=FSIZ-1;i++)fac[i]=fac[i-1]*i%mod;
    ifac[FSIZ-1]=qpow(fac[FSIZ-1],mod-2);for(int i=FSIZ-1;i>=1;i--)ifac[i-1]=ifac[i]*i%mod;
    inv[0]=0;for(int i=1;i<=FSIZ-1;i++)inv[i]=ifac[i]*fac[i-1]%mod;
    for(int i=0;i<=n;i++){
        res[i][0][0]=1;
        for(int j=1;j<=n-i;j++){
            for(int h=0;h<=j;h++){
                if(h>0)add(res[i][j][h],res[i][j-1][h-1]);
                add(res[i][j][h],res[i][j-1][h]*(i+h)%mod);
            }
        }
    }
    for(int i=n;i>=1;i--)dp1[i][1][i]=1;
    for(int i=n-1;i>=1;i--){
        for(int j=1;j<=n;j++){
            for(int h1=j+1;h1<=n;h1++){
                for(int h2=(i*h1)+(h1-j);h2<=n;h2++){
                    //printf("%lld %lld %lld %lld\n",i,j,h1,h2);
                    add(dp1[i][h1][h2],dp1[i+1][h1-j][h2-i*j]*res[h2-(i*h1)-(h1-j)][h1][h1-j]%mod);
                    
                }
            }
        }
        for(int h1=1;h1<=n;h1++){
            for(int h2=1;h2<=n;h2++){
                add(dp1[i][h1][h2],dp1[i+1][h1][h2]);
            }
        }
    }
    for(int i=1;i<n;i++)dp2[1][i][n]=fac[n-1]*ifac[i]%mod;
    for(int i=1;i<n;i++){
        for(int h1=1;h1<=n;h1++){
            for(int h2=h1*i;h2<=n;h2++){
                for(int j=1;h1-j>=0&&h2-i*j>=0;j++){
                    if(h2-i*h1-(h1-j)>=0)add(dp2[i+1][h1-j][h2-i*j],dp2[i][h1][h2]*res[h2-i*h1-(h1-j)][h1][h1-j]%mod);
                }
            }
        }
        for(int h1=1;h1<=n;h1++){
            for(int h2=1;h2<=n;h2++){
                add(dp2[i+1][h1][h2],dp2[i][h1][h2]);
            }
        }
    }
    for(int i=2;i<=n;i++){
        for(int j=1;j<=n;j++){
            for(int h1=1;h1<=n-j;h1++){
                for(int h2=h1*i;h2<=n-(i-1)*j;h2++){
                    for(int j2=1;j2<=j;j2++){
                        add(ans[h1+j2][h2+j2*(i-1)],dp1[i][h1][h2]*res[h2-h1-(i-1)*h1][h1+j][h1]%mod*dp2[i-1][h1+j][h2+(i-1)*j]%mod);
                    }
                }
            }
        }
    }
    for(int i=2;i<=n;i++){
        add(ans[1][i],dp2[i][1][i]);
    }
    for(int i=2;i<=n;i++){
        add(ans[i][n],ans[i-1][n]);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            printf("%lld ",ans[i][j]);
        }
        printf("\n");
    }
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P12495)

**题目大意**

> 给定 $n$，对于所有 $m,k$ 计算：所有 $n$ 个点的有标号树中（根为 $1$），有多少个树选出 $k$ 条一端为根的路径，其并集的最大值为 $m$。
>
> 数据范围：$n\le 300$。

**思路分析**

假设所求的树根节点任意，最后除以 $n$。

从 $k$ 算 $m$ 是经典长剖问题，但这里肯定不能 dp 树的长链集合。

考虑换一种方式刻画，设 $h_u$ 表示 $u$ 子树最大深度，$c_x$ 表示 $h_u=x$ 的点数，则 $m=\sum\min(c_x,k)$。

那么对 $c$ 数组 dp，显然 $c$ 必须递减。

从大往小确定 $c$，考虑 $c_i$ 的这些点怎么填：首先他们的父亲肯定是 $h_u>i$ 的点，且 $c_{i+1}$ 个 $h=i+1$ 的点，每个点至少有一个 $h=i$  的儿子，而连向 $h_u>i+1$ 的点则无区别。

因此我们只要记录 $f_{i,j,k}$ 表示 $c_i=j,\sum_{t>i}c_t=k$。

转移的时候要算一个系数，$c_{x}=i,c_{x+1}=j,\sum_{t>x+1}c_t=k$ 时 $h=i$ 的父亲选法，每次加入一个点，如果父亲 $h=i+1$，讨论该点是不是其父亲的最后一个 $h=i$ 的儿子即可。

然后考虑如何根据 $f$ 计算答案。

在首个 $c_i\ge k$ 的位置算答案，枚举 $c_i,c_{i+1}$，则贡献到 $k\in[c_{i+1},c_i)$ ，$m=ik+\sum_{t>i}c_t$。

直接在 dp $f$ 的过程中实现，只要提前求出从 $f_{i,j,k}\to f_{1}$ 的系数即可，转置原理就能解决。

注意 $k\ge c_1$ 的情况没算，此时 $m=n$，只要减去 $m<n$ 的方案数即可。

注意到 $j\le c_i\le \dfrac ni$，因此转移的复杂度 $\mathcal O(n^3)$。

暴力实现复杂度 $\mathcal O(n^4)$，瓶颈在枚举 $k$，算答案的时候前缀和优化一下可以做到 $\mathcal O(n^3)$。

时间复杂度 $\mathcal O(n^3)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace FastMod {
typedef unsigned long long ull;
typedef __uint128_t uLL;
ull b,q,r; uLL m;
inline void init(const ull &B) { b=B,m=(uLL(1)<<64)/B; }
inline ull mod(const ull &a) {
	r=a-((m*a)>>64)*b;
	return r>=b?r-b:r;
}
}
#define o(x) FastMod::mod(x)
const int MAXN=305;
int n,MOD;
ll fac[MAXN],ifac[MAXN],f[MAXN][MAXN][MAXN],g[MAXN][MAXN][MAXN],h[MAXN][MAXN][MAXN],w[MAXN][MAXN],dp[MAXN][MAXN];
ll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=o(a*a),b>>=1) if(b&1) s=o(s*a); return s; }
void add(ll &x,const ll &y) { x=o(x+y); }
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>MOD,FastMod::init(MOD);
	if(n==1) return cout<<"1\n",0;
	for(int i=fac[0]=ifac[0]=1;i<MAXN;++i) ifac[i]=ksm(fac[i]=o(fac[i-1]*i));
	for(int k=0;k<=n;++k) h[0][0][k]=1;
	for(int i=1;i<=n;++i) for(int j=0;j<=i;++j) for(int k=0;i+j+k<=n;++k) {
		h[i][j][k]=o(h[i-1][j][k]*(j+k)+(j?h[i-1][j-1][k]*j:0));
	}
	for(int i=1;i<=n;++i) g[1][i][n-i]=ifac[i];
	for(int i=1;i<n;++i) {
		for(int j=0;j<=n/i;++j) for(int k=0;j+k<=n;++k) if(g[i][j][k]) {
			for(int v=0;v<=n/(i+1)&&v<=k&&v<=j;++v) {
				add(g[i+1][v][k-v],o(g[i][j][k]*ifac[v])*h[j][v][k-v]);
			}
		}
	}
	f[n][1][0]=1;
	for(int i=n-1;i;--i) {
		f[i][1][0]=1,memset(w,0,sizeof(w));
		for(int j=1;j<=n/(i+1);++j) for(int k=0;j+k<=n;++k) if(f[i+1][j][k]) {
			for(int v=j;v<=n/i&&v+j+k<=n;++v) {
				add(f[i][v][j+k],o(f[i+1][j][k]*ifac[v])*h[v][j][k]);
				ll z=o(o(o(f[i+1][j][k]*g[i][v][j+k])*h[v][j][k])*fac[n-1]);
				add(w[j+k][j],z),add(w[j+k][v],MOD-z);
			}
		}
		for(int s=1;s<=n;++s) for(int t=1;t<=n;++t) {
			add(w[s][t],w[s][t-1]),add(dp[t][s+t*i],w[s][t]);
		}
	}
	ll wys=ksm(n,n-2);
	for(int i=1;i<=n;++i) {
		dp[i][n]=wys;
		for(int j=1;j<n;++j) cout<<dp[i][j]<<" ",add(dp[i][n],MOD-dp[i][j]);
		cout<<dp[i][n]<<"\n";
	}
	return 0;
}
```

---


# 贴海报

## 题目描述

有一面 $n\times m$ 的墙，墙上有若干个窟窿。现在要在墙上贴上海报，海报是 $2\times 3$ 大小的长方形，且每条边与墙面边缘平行或者垂直。海报可以横着贴也可以竖着贴，但是窟窿上不能贴海报。请问这面墙最多可以贴多少个海报？

## 说明/提示

数据保证，$1\leq n\leq 150$，$1\leq m\leq 10$。

## 样例 #1

### 输入

```
6 6
0 0 0 1 0 0 
0 1 0 0 0 0
0 0 0 0 0 1
0 0 0 0 0 1
0 0 0 0 0 0
0 0 0 1 0 0```

### 输出

```
3```

# 题解

## 作者：Rorshach (赞：19)

@wine 大佬发的并不是正解，生成一张全为0的大图就可以让他的程序跑到3s左右……
（无意diss）

然后看了一下好像通过的程序跑得时间都差不多啊，看来思路都是从他这边学习的

此题原身为poj 1038。

开始时并不会做，然后看了网上n篇题解才搞明白

用三进制数表示每一个状态，然后以行号为阶段，相邻两行用dfs来进行转移

详细可见[我的cnblog](https://www.cnblogs.com/Rorshach/p/9279058.html)

这里给出dfs的代码

```cpp
/* pre 为上一行状态 i为当前行，j为当前状态，
cnt为格子数目，tmp为当前压缩后整行状态*/
void dfs(int i, int j, int cnt, int tmp){
	int k;
	dp[i & 1][tmp] = max(dp[i & 1][tmp], cnt);
	if(j >= m) return ;
	/*放上3行2列的格子
	  如果该层状态和前一层的状态都允许 那么就放上格子继续搜下去*/
	if(!pre[j] && !pre[j + 1] && !now[j] && !now[j + 1]){
		now[j] = now[j + 1] = 2;  //放格子之后状态就都是2了
		k = trans(now); dfs(i, j + 2, cnt + 1, k);//因为两格都被覆盖，跳过去搜
		now[j] = now[j + 1] = 0;  //回溯
	}
	/*放上2行3列的格子
	 这个就只跟你当前的状态有关了*/
	if(j < m - 1 && !now[j] && !now[j + 1] && !now[j + 2]){
		now[j] = now[j + 1] = now[j + 2] = 2; //同样修改 搜下去 回溯
		k = trans(now);  dfs(i, j + 3, cnt + 1, k);
		now[j] = now[j + 1] = now[j + 2] = 0;
	}
	dfs(i, j + 1, cnt, tmp);
	return ;
}
```

---

## 作者：wine (赞：13)

数据范围 1<=n<=150，1<=m<=10

m很小，可以考虑状压。

为方便把01互换，找全1矩阵。

2\*3的海豹，除了横着贴也可竖着贴，这一行选择只受前两行影响，f[i][j][k]表示海豹数,j是i-1行状态，即j二进制这一位是1表示该点可用且之前没有用，k是i-2行状态。枚举j，k,j是a[i-1]子集，枚举s子集黑科技

```cpp
for(int j=s;j;j=(j-1)&s)； 
```
上2行状态确定后，暴力枚举选海豹，更新答案，这样做比较暴力，需卡常，f要滚动，不用memset，因为同一f[0/1]至少差两行，不会相互影响，且i变大，f不会变小，f[k][a][b] > num，没有必要更新其子集。


``` cpp
#prag\
ma GCC optimize("Ofast")
#include <cstdio>
#include <cstring> 
 
inline void read(int &x) {
    char c; while((c=getchar())<'0'||c>'9');
    x=c-'0';while((c=getchar())>='0'&&c<='9') x=x*10+c-'0';
}

#define R register 

int f[2][1025][1025],ans;

__attribute__((optimize("-Os"))) inline void dfs(R int a,R int b,R int c,R int num,R int k,R int li) {
    if (f[k][a][b] > num) return;
    if (ans < num) ans = num;  
    f[k][a][b] = num;
    R int t = a&b&c;    
    t = t&(t>>1)&li;
    while (t) {
        R int tp = t&-t;
        t ^= tp; 
        R int p = tp|(tp<<1);
        dfs(a^p,b^p,c^p,num+1,k,~(tp-1));
    }
    t = a&b&li;
    t = t&(t>>1)&(t>>2);
    while (t) {
        R int tp = t&-t;
        t ^= tp;
        R int p = tp|(tp<<1)|(tp<<2);
        dfs(a^p,b^p,c,num+1,k,~(tp-1));
    }
}

__attribute__((optimize("-Os"))) inline int work() {
    R int a[152],n,m; memset(a,0,sizeof a); 
    read(n); read(m); 
    for (R int i = 1; i <= n; i++) 
     for (R int j = 0,x; j < m; j++) 
       read(x),a[i] |= (x^1)<<j;
    for (R int i = 2; i <= n; i++) {
      for (R int j = a[i-1]; ; j = (j-1)&a[i-1]) {
       for (R int k = a[i-2]; ; k = (k-1)&a[i-2]) {
           dfs(a[i],j,k,f[(i&1)^1][j][k],i&1,(1<<11)-1);
           if (!k) break;
       }
       if(!j) break;
      }
    }
    printf("%d",ans);
    return 0;
}

int haha = work();
main() {;}
```

---

## 作者：913887524gsd (赞：11)

这道题磨了我好久，下面dalao的程序可以当正解，所以我给某些和我一样看不懂题解的蒟蒻做一些解释，关于下面的dfs的lim变量应该是这道题的精髓。这个lim的优化决定你的第六个点能不能过，t指的是可行状态，tp所指的是lowbit（应该都知道吧） t后的位置。

最重要的来了，这时候给下一层递归的lim用~（tp-1）。tp-1表示把这一位右边的位都置1，然后就是**按位取反**，这指的是把tp位置右边的方块相当于挖掉。这样能保证只会枚举这一位及其左边的方块，这意味着什么？这相当于你的搜索会有一定的方向性，能够很大程度上去优化你dfs的常数。这就是位运算的魅力。

最后提醒一下，**register**一定都要用上（所有变量），不然你会吃亏的



---

## 作者：WilliamFranklin (赞：1)

看到很多大佬都是直接 dfs 做的，太强了，我的插头 dp 甘拜下风。

### Solution

首先用插头 dp 的话我们要考虑如何转成插头 dp 可做的。考虑一共有两种海报，一种是 $2\times3$，另一种是 $3\times2$，表面上只是反转了一下，但其实必须要区别一下。我们对于每个海报中相邻两个格子之间的“插头”编号：

![](https://cdn.luogu.com.cn/upload/image_hosting/nh9bo1g1.png)

这样就可以直接套上插头 dp 的板子进行插头 dp 了，只是此时用的是 $8$ 进制，状态会爆 int，所以需要开 long long。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define x first
#define y second
#define mp(Tx, Ty) make_pair(Tx, Ty)
#define For(Ti, Ta, Tb) for(auto Ti = (Ta); Ti <= (Tb); Ti++)
#define Dec(Ti, Ta, Tb) for(auto Ti = (Ta); Ti >= (Tb); Ti--)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define range(Tx) begin(Tx),end(Tx)
const int N = 3000, M = N * 2 + 7;
int n, m;
int g[155][15];
long long h[2][M];
int q[2][N], f[2][M], cnt[2];
int find(int cur, long long x) {
	int t = x % M;
	while (h[cur][t] != -1 && h[cur][t] != x) if (++t == M) t = 0;
	return t;
}
void insert(int cur, long long state, int w) {
	int t = find(cur, state);
	if (h[cur][t] == -1) {
		h[cur][t] = state, q[cur][++cnt[cur]] = t;
		f[cur][t] = w;
	} else f[cur][t] = max(f[cur][t], w);
}
int get(long long state, int k) {
	return state >> k * 3 & 7;
}
long long make(int k, int x) {
	return (long long)x << k * 3;
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> m;
	int end_x = 0, end_y = 0;
	For(i, 1, n) For(j, 1, m) {
		cin >> g[i][j];
		if (!g[i][j]) end_x = i, end_y = j;
		g[i][j] = 1 - g[i][j];
	}
	int cur = 0;
	memset(h, -1, sizeof(h));
	insert(cur, 0, 0);
	int res = 0;
	For(i, 1, n) {
		For(j, 1, cnt[cur]) h[cur][q[cur][j]] <<= 3;
		For(j, 1, m) {
			int last = cur;
			cur ^= 1, cnt[cur] = 0;
			memset(h[cur], -1, sizeof(h[cur]));
			For(k, 1, cnt[last]) {
				long long state = h[last][q[last][k]];
				int w = f[last][q[last][k]];
				int x = get(state, j - 1), y = get(state, j);
				if (!g[i][j]) {
					if (!x && !y) insert(cur, state, w);
				} else if (!x && !y) {
					if (state == 0 && i == end_x && j == end_y) res = max(res, w);
					insert(cur, state, w);
					if (g[i + 1][j] && g[i][j + 1]) insert(cur, state + make(j - 1, 1) + make(j, 1), w);
					if (g[i + 1][j] && g[i][j + 1]) insert(cur, state + make(j - 1, 4) + make(j, 5), w);
				} else if (x == 1 && !y) {
					if (g[i + 1][j] && g[i][j + 1]) insert(cur, state + make(j - 1, 1) + make(j, 2), w);
				} else if (x == 2 && !y) {
					if (g[i + 1][j]) insert(cur, state + make(j - 1, 1), w);
				} else if (!x && y == 1) {
					if (g[i][j + 1]) insert(cur, state + make(j, 2), w);
				} else if (x == 3 && y == 2) {
					if (g[i][j + 1]) insert(cur, state - make(j - 1, 3) + make(j, 2), w);
				} else if (x == 4 && y == 3) {
					if (state == make(j - 1, 4) + make(j, 3) && i == end_x && j == end_y) res = max(res, w + 1);
					insert(cur, state - make(j - 1, 4) - make(j, 3), w + 1);
				} else if (x == 5 && !y) {
					if (g[i + 1][j]) insert(cur, state, w);
				} else if (!x && y == 4) {
					if (g[i + 1][j] && g[i][j + 1]) insert(cur, state + make(j - 1, 6) + make(j, 2), w);
				} else if (x == 6 && y == 5) {
					if (g[i + 1][j]) insert(cur, state + make(j - 1, 1) - make(j, 5), w);
				} else if (!x && y == 6) {
					if (g[i][j + 1]) insert(cur, state + make(j, 1), w);
				} else if (x == 7 && y == 7) {
					if (state == make(j - 1, 7) + make(j, 7) && i == end_x && j == end_y) res = max(res, w + 1); 
					insert(cur, state - make(j - 1, 7) - make(j, 7), w + 1);
				}
			}
		}
	}
	cout << res;
	return 0;
} 
```

竟然抢到了次优解。

---

## 作者：天南星魔芋 (赞：1)

* 看到此题题解只有一篇较为完整却会被卡的，所以写了此篇题解。

* 因为原题数据坏了，就自己造了些数据 [U178862](https://www.luogu.com.cn/problem/U178862)


------------

## 前置芝士

普通的状压DP ~~不会的出门右转百度~~

插头DP（其实就是一点思想） [模板](https://www.luogu.com.cn/problem/P5056) [awa](https://www.luogu.com.cn/blog/wyd20230071/solution-p1713)

------------

## Solution

看到数据范围 $1\le n\le 150$，$1\le m\le10$ ，很容易想到状态压缩。（因为 $m\le10$ ）

然后考虑如何状压:


* 我们在这里将一行压缩为一个数，DP 时一行一行处理。

1. 对于一个状态，我们可以什么都不做，转移到下一行。

2. 对于一个状态，我们可以以此行的某个空白的点为左上角，贴上 $2 \times 3$ 或 $3 \times 2$ 的海豹（当然要先判断不会贴到窟窿上），然后加入此行状态。（因为每行可能贴不止一张海豹）

然后考虑如何实现：

* 我们用每一位上的数表示从当前位置开始（向下）有几个格子被现有海豹占据。

* 每换一行将所有的数值减 $1$ 。

* 对于一张海豹，有 $2 \times 3$ 和 $3 \times 2$ 两种规格，那么对于一个点，有 $3,2,1,0$ 四种数值。（对于一个空白点（数值为 $0$），若贴上 $3 \times 2$ 的海豹则标记为 $3$，意为从这个点开始有 $3$ 格被海豹占据，$2 \times 3$ 同理）。

* 于是用 $4$ 进制表示，最大不超过 $4^{10}$，即 $2^{20}$。


然后算一下复杂度，$O(2^{20} \times 150 \times 10)$，$15$ 亿，还有一些常数没算，肯定超时。

随即我们可以发现 $2^{20}$ 个状态中有很多没用上。（比如在 $m=5$ 时 $1,2,0,0,0$ 就不可能出现）。


于是开始优化:

学过 插头DP 的人应该知道，插头DP 里无用的状态有很多，于是就用一个哈希去重，将剩下的存入一个列表中。

我们也学 插头DP，发现其实有用的状态不超过 $5500$ 个。![](//啧.tk//jk)


这复杂度一下就下来了。

有一个要特别注意的是 DP 的顺序要从小到大，否则 ~~你会WA#7~~ 你转移的状态不是最优，我的解决办法是把每个转移过元素都移除，这样就算第一次不是最优第二次还会再更新，还有一种理论可行的方法（我没试过，太麻烦）是把所有元素放到一个小根堆里。（因为只能贴海豹，所以数值只能变大）

然后就是些细节。

#### $code:$ 

因为本人太菜码的太烂，所以写的代码要开氧。（开不开氧天差地别）


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int inline maxx(int x,int y){
	return x>y? x:y;
}
struct DP{
	int zy[5500];
	int gs[5500];
	int top;
	map<int,int>mp;
	void inline clear(){
		top=0;
		mp.clear();
	}
	void inline add(int x,int y){
		int k=mp[x];
		if(!k){
			mp[x]=++top;
			k=top;
			zy[k]=x;
			gs[k]=y;
		}
		else{
			gs[k]=maxx(gs[k],y);
		}
	}
}dp[2];
int n,m;
int dt[155][12];
int inline cl(int k){
	int zan[12],ztop=0;
	while(k){
		zan[++ztop]=k%4;
		if(zan[ztop])zan[ztop]--;
		k>>=2;
	}
	while(ztop){
		k+=zan[ztop--];
		k<<=2;
	}
	k>>=2;
	return k;
}
bool inline pd(int l,int r,int ll,int rr){
	if(ll>n||rr>m)return 1;
	for(int i=l;i<=ll;i++){
		for(int j=r;j<=rr;j++){
			if(dt[i][j])return 1;
		}
	}
	return 0;
}
void ask32(int zy,int k,int x,int y){
	if(y>m-1)return ;
	k++;
	int zan[16];
	for(int i=1,zzy=zy;i<=m;i++){
		zan[i]=zzy%4;
		zzy>>=2;
	}
	if(zan[y]||zan[y+1])return ;
	if(pd(x,y,x+2,y+1))return ;
	zan[y]=zan[y+1]=3;
	zy=0;
	for(int i=m;i>0;i--){
		zy+=zan[i];
		if(i>1)zy<<=2;
	}
	dp[0].add(zy,k);
}
void ask23(int zy,int k,int x,int y){
	if(y>m-2)return ;
	k++;
	int zan[16];
	for(int i=1,zzy=zy;i<=m;i++){
		zan[i]=zzy%4;
		zzy>>=2;
	}
	if(zan[y]||zan[y+1]||zan[y+2])return ;
	if(pd(x,y,x+1,y+2))return ;
	zan[y]=zan[y+1]=zan[y+2]=2;
	zy=0;
	for(int i=m;i>0;i--){
		zy+=zan[i];
		if(i>1)zy<<=2;
	}
	dp[0].add(zy,k);
}
void js(int x){
	for(int i=1;i<=dp[0].top;i++){
		int zy=dp[0].zy[i],k=dp[0].gs[i];
		dp[0].mp[zy]=0;
		dp[1].add(cl(zy),k);
		for(register int i=1;i<m;i++){
			ask32(zy,k,x,i);
			ask23(zy,k,x,i);
		}
	}
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%lld",&dt[i][j]);
		}
	}
	dp[0].clear();
	dp[1].clear();
	dp[0].add(0,0);
	for(int i=1;i<=n;i++){
		js(i);
		dp[0]=dp[1];
		if(i!=n)dp[1].clear();
	}
	int zz=dp[1].mp[0];
	cout<<dp[1].gs[zz]<<endl;
}
```

---


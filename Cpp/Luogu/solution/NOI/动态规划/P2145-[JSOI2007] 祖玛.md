# [JSOI2007] 祖玛

## 题目背景

管理员备注：本题可能是错题。

2025.1.27 update：现在本题存在多项式解，但仍然无法在原数据范围下通过（UOJ941）。

## 题目描述

这是一个流行在 Jsoi 的游戏，名称为祖玛。

精致细腻的背景，外加神秘的印加音乐衬托，彷佛置身在古老的国度里面，进行一个神秘的游戏——这就是著名的祖玛游戏。祖玛游戏的主角是一只石青蛙，石青蛙会吐出各种颜色的珠子，珠子造型美丽，并且有着神秘的色彩。

环绕着石青蛙的是载着珠子的轨道，各种颜色的珠子会沿着轨道往前滑动，石青蛙必需遏止珠子们滚进去轨道终点的洞里头，如何减少珠子呢？就得要靠石青蛙吐出的珠子与轨道上的珠子相结合，颜色相同者即可以消失得分！直到轨道上的珠子通通都被清干净为止。 或许你并不了解祖玛游戏。没关系。这里我们介绍一个简单版本的祖玛游戏规则。一条通道中有一些玻璃珠，每个珠子有各自的颜色，如图 1 所示。玩家可以做的是选择一种颜色的珠子（注意：颜色可以任选，这与真实游戏是不同的）射入某个位置。

 ![](https://cdn.luogu.com.cn/upload/pic/1446.png) 

图 2 中玩家选择一颗蓝色珠子，射入图示的位置，于是得到一个图 3 的局面。

当玩家射入一颗珠子后，如果射入的珠子与其他珠子组成了三颗以上连续相同颜色的珠子，这些珠子就会消失。例如，将一颗白色珠子射入图 4 中的位置，就会产生三颗颜色相同的白色珠子。这三颗珠子就会消失，于是得到图 5 的局面。

需要注意的一点是，图 4 中的三颗连续的黄色珠子不会消失，因为并没有珠子射入其中。 珠子的消失还会产生连锁反应。当一串连续相同颜色的珠子消失后，如果消失位置左右的珠子颜色相同，并且长度大于 2，则可以继续消失。例如，图 6 中，射入一颗红色珠子后，产生了三颗连续的红色珠子。当红色珠子消失后，它左右都是白色的珠子，并且一共有四颗，于是白色珠子也消失了。之后，消失位置的左右都是蓝色珠子，共有三颗，于是蓝色珠子也消失。最终得到图 7 的状态。注意，图 7 中的三颗黄色珠子不会消失，因为蓝色珠子消失的位置一边是紫色珠子，另一边是黄色珠子，颜色不同。

除了上述的情况，没有其他的方法可以消去珠子。现在，我们有一排珠子，需要你去消除。对于每一轮，你可以自由选择不同颜色的珠子，射入任意的位置。你的任务是射出最少的珠子，将全部珠子消去。


## 说明/提示



------------
2024/2/13 添加 2 组 hack 数据。

## 样例 #1

### 输入

```
9
1 1 2 2 3 3 2 1 1```

### 输出

```
1```

# 题解

## 作者：AchorX (赞：8)

## Update 20250121
如果你是大牛，建议直接抬走我的，跳过交流这一步，因为我大概率会听不懂你的想法 TT

修了一下图片。无法通过数据：

```latex
10
1 1 2 1 1 3 4 1 1 1
```
（output: $7$ ; ans: $6$ )
## 写在前面
Q：为什么要写这篇题解？

A：我综合了一下原有题解的两种思路，杂交了一个目前过掉数据最多的，复杂度不正确的代码。也就是说，仍然不是正解。
## 题意
在本题目下有以下规则：
- 起始时无论有几个连续相同的珠子都无法消除。
- 可在任意两颗珠子中插入任意颜色珠子。
- 当插入珠子后，包含该珠子的 连续相同珠子段 若长度大于 $2$ ，则消除。
- 消除后，若消除段前的珠子与消除段后的珠子颜色相同且长度和大于 $2$ ，再次消除。

## 分析

第一种思路是将连续相同珠子段视为整体，进行区间 DP 。

可以分以下情况：（用o代表一个珠子，用【】代表一段）
1. o【】、【】【】 即分段。
2. o【】o 前后珠子一样可以凑一起。
3. o【】o【】o 同理。
4. o【】o【】o【】o 可以先消除左右两个【】，再消除中间的。
5. o【】o【】o【】o【】o  本质上和3是一样的，多加同理。

但是我们发现了问题

![](https://cdn.luogu.com.cn/upload/image_hosting/18jek0tw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们不得不把视为整体的部分分解，于是有了第二种思路。

不把起始珠子合并，同样的，有
1. o【】、【】【】 
2. o【】o 
3. o【】o【】o
4. o【】o【】o【】o 

以上均同理。
 
前三个的计算很简单，$4$  要寻找四个颜色相同且孤立的珠子，那就要在区间中枚举每一坨珠子（注意不是一个），并且要有两重循环来寻找，复杂度算上外层区间 DP ，接近（因为跑不满）于 $O(n^4)$ ，显然错误。
但我目前没有找到合适的解决方法。

综上所述，我们可以采用将两种 DP 结合起来的方法来解决此题（部分）。

代码如下（部分参考其他题解）：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e2 + 5;
int n, a[N], b[N], num[N], w, cnt, dp[N][N], to[N], ttoo[N], f[N][N];
void read() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
	for (int i = 1; i <= n; ++i) {
		w = a[i], b[++cnt] = a[i], num[cnt] = 1, to[cnt] = i, ttoo[i] = cnt;
		while (a[i + 1] == w) num[cnt] ++, i++, ttoo[i] = cnt;
	}
	memset(f, 0x3f, sizeof f);
	for (int len = 1; len <= n; ++len)
		for (int i = 1, j = len; j <= n; ++i, ++j) {
			if (ttoo[i] == ttoo[j]) {
				f[i][j] = max(1, 2 - j + i);
				continue;
			}
			for (int k = i; k < j; ++k)
				f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);
			if (a[i] == a[j]) {
				int x = to[ttoo[i] + 1], y = to[ttoo[j]] - 1;//第一个与i, j颜色不同的
				int len1 = x - i, len2 = j - y;//此区间内与i,j 紧挨着 且颜色相同的个数
				f[i][j] = min(f[i][j], f[x][y] + (len1 + len2 < 3));
				if (min(len1, len2) < 3) continue;
				for (int k = x + 1; k <= y - 1; ++k)
					if (a[k] == a[i] && num[ttoo[k]] + min(len1, len2) < 3)
						f[i][j] = min(f[i][j], f[x][k - 1] + f[k + num[ttoo[k]]][y]);
			}
		}
	memset(dp, 0x3f, sizeof dp);
	for (int i = 1; i <= cnt; ++i) dp[i][i] = (num[i] >= 2 ? 1 : 2);
	for (int len = 1; len < cnt; ++len)
		for (int i = 1, j = i + len; j <= cnt; ++i, ++j) {
			if (ttoo[to[i] + num[i] - 1] == i && ttoo[to[j] - num[i] + 1] == j) dp[i][j] = min(dp[i][j], f[to[i]][to[j]]);
			if (b[i] == b[j] && len > 1) dp[i][j] = min(dp[i][j], dp[i + 1][j - 1] + (num[i] + num[j] <= 2));
			if (b[i] == b[j]) {
				for (int k = i + 1; k < j; ++k)
					if (b[i] == b[k] && (num[i] + num[k] < 3 || num[k] + num[j] < 3)) dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k + 1][j - 1]);
				if (num[i] == num[j] && num[i] == 1)
					for (int x = i + 1; x < j; ++x)
						for (int y = x + 1; y < j; ++y)
							if (b[x] == b[y] && b[x] == b[i] && num[x] == num[y] && num[x] == 1)
								dp[i][j] = min(dp[i][j], dp[i + 1][x - 1] + dp[x + 1][y - 1] + dp[y + 1][j - 1]);
			}
			for (int k = i; k < j; ++k) {
				dp[i][j] = min(dp[i][k] + dp[k + 1][j], dp[i][j]);
				dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + (num[k] >= 2 ? 1 : 2));
			}
		}
	printf("%d", dp[1][cnt]);
}
int main() {
	read();
	return 0;
}
```

再次声明，此代码复杂度错误，思路不太正确，本篇题解仅为思路参考。当然，这么写可以 AC。期待您的新思路！

---

## 作者：CRH_Beijingzhan (赞：6)

[洛谷P2145 [JSOI2007] 祖玛](https://www.luogu.com.cn/problem/P2145)

很经典的一道区间```dp```
题，区间```dp```的部分其实很好想。

我们用数组 $f[i][j]$ 表示消除区间 $[i,j]$ 需要的珠子的个数。那我们进行区间```dp```，从区间合并到大区间状态转移方程是就是

```cpp
f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
```
这里是先求出小区间的贡献值，再将小区间转化为大区间，求出大区间的贡献值。这就是常规部分的写法。但是还存在另外的情况：当区间两个端点的值相等 $arr[i]=arr[j]$，那么考虑我们是否可以把中间的部分消除后，两边是否能继续消除？如果这两个端点的相同颜色珠子数相加是大于3的，那么就可以不用发射弹珠，直接消灭，反之则是还需要射出一颗珠子。

现在就到了难点：我们如何判断这两端的珠子可以直接进行消去呢？如果判断这两个珠子两边是否同色，这样处理的话就超出了原有的需要处理的区间，是不可以去的。那么我们可以尝试把原来的珠子串进行压缩，把他们压缩成一个个区间：

```cpp
for(int i=1; i<=n; ++i){
    cin>>arr[i];
    if(i!=1 and arr[i]==arr[i-1]){
        b[tot]++;
    }else{
        arr[++tot]=arr[i];
        b[tot]=1;
    }
}

```
这样处理后，举个例子，题目给的样例就会产生如下变化：
```cpp
变化前：
1 1 2 2 3 3 2 1 1
变化后：
1 2 3 2 1
```

然后b数组就记录了每个位置上该种类珠子的连续个数。这样，我们按照上面的想法，判断是否需要新打出一颗珠子吧剩余消灭的情况，只需要判断 $b[i]+b[j]$ 是否大于2了。如果大于2就表明我们把中间的区间的珠子全部消去后，两端的珠子会直接消除，不需要打出新的珠子。情况如下：
```cpp
if(arr[l]==arr[r]){
	if(b[l]+b[r]>2){
		f[l][r]=min(f[l][r],f[l+1][r-1]);
	}else{
		f[l][r]=min(f[l][r],f[l+1][r-1]+1);
	}
}
```

讲一下如果不进行上文的预处理，那么连续很多个相同珠子的情况就不好用该方法处理。所以我们直接预处理后跑区间```dp```
即可。

```cpp
//参考代码：
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10,mod=998244353;
int f[101][101],arr[101],b[101],tot;
signed main(){
	memset(f,0x3f,sizeof f);
	int n;
	cin>>n;
	for(int i=1; i<=n; ++i){
		cin>>arr[i];
		if(i!=1 and arr[i]==arr[i-1]){
			b[tot]++;
		}else{
			arr[++tot]=arr[i];
			b[tot]=1;
		}
	}n=tot;
	for(int i=1; i<=n; ++i){
		if(b[i]>1){
			f[i][i]=1;
		}else{
			f[i][i]=2;
		}
	}for(int len=2; len<=n; len++){
		for(int l=1; l+len-1<=n; l++){
			int r=l+len-1;
			if(arr[l]==arr[r]){
				if(b[l]+b[r]>2){
					f[l][r]=min(f[l][r],f[l+1][r-1]);
				}else{
					f[l][r]=min(f[l][r],f[l+1][r-1]+1);
				}
			}for(int mid=l; mid<r; mid++){
				f[l][r]=min(f[l][r],f[l][mid]+f[mid+1][r]);
			}
		}
	}if(f[1][n]==3){
		cout<<2<<endl;
	}else{
		cout<<f[1][n]<<endl;
	}return 0;
}

```

---

## 作者：alice_c (赞：2)

## 题意

有一个珠子序列，你可以在任意位置插入任意颜色的珠子。每当连续 $\ge 3$ 个相同颜色的珠子相邻时，它们会消失，并可能引发连锁反应。求至少需要插入几个珠子使所有珠子都被消除。

## 思路

很显然，这是一道区间 DP 题，我们设 $dp[l][r]$ 表示消除区间 $[l,r]$ 里的珠子需要的最少发射次数。

为了更好的模拟，我们不用关心每个珠子，而是关心颜色段，如果一段珠子被消没了，我们要检查左右颜色段是否颜色相同，可以继续消除。我们可以压缩区间，设 $b_i$ 和 $c_i$ 分别表示每个颜色段的颜色和珠子个数。样例 `a: 1 1 2 2 3 3 2 1 1`，压缩区间后就会变成 `b: 1 2 3 2 1` 和 `c: 2 2 2 1 2`。

初始化很明显，如果 $c_i=1$，那么还需要发射两个珠子才能消除；如果 $c_i=2$，还需要发射一个珠子；否则，注意，也需要插入一个珠子。

进行区间 DP，$l$ 是左端点，$r$ 是右端点，如果 $b_l=b_r$ 就可以考虑合并消除，我们把两端和中间 $[l+1,r-1]$ 分开考虑。如果 $c_l+c_r \ge 3$ 就可以直接消除，否则需要再插入一个。枚举中间断点 $k$，主要状态转移方程很板，就是 `dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]`。但是还要考虑三个颜色段颜色相同的情况，即 $b_l=b_k=b_r$（$l<k<r$），且 $c_l+c_k<3$ 或 $c_k+c_r<3$（用于排除已经能自动消除的情况发生重复转移），那么 `dp[l][r]=min(dp[l][r],dp[l+1][k-1]+dp[k+1][r-1]`。

时间复杂度 $O(cnt^3)$，$cnt$ 表示压缩区间后的颜色段总数。

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int n,a[505];
int b[505],c[505],cnt=0;
int f[505][505];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        if(i>1 && a[i]==a[i-1]) c[cnt]++;
        else{
            b[++cnt]=a[i];
            c[cnt]=1;
        }
    }
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=cnt;i++)
        f[i][i]=(c[i]==1?2:1);
    for(int i=2;i<=cnt;i++){
        for(int l=1;l+i-1<=cnt;l++){
            int r=l+i-1;
            if(b[l]==b[r]){
                if(c[l]+c[r]>=3) f[l][r]=min(f[l][r],f[l+1][r-1]);
                else f[l][r]=min(f[l][r],f[l+1][r-1]+1);
            }
            for(int k=l;k<r;k++){
                f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]);
                if(k>l && b[l]==b[k] && b[k]==b[r])
                    if(c[l]+c[k]<3 || c[k]+c[r]<3)
                        f[l][r]=min(f[l][r],f[l+1][k-1]+f[k+1][r-1]);
            }
        }
    }
    printf("%d",f[1][cnt]);
}
``````

---


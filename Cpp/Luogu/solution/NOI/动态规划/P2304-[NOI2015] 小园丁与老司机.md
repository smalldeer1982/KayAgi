# [NOI2015] 小园丁与老司机

## 题目描述

小园丁 Mr. S 负责看管一片田野，田野可以看作一个二维平面。田野上有 $n$ 棵 许愿树，编号 $1,2,3,\dots,n$ ，每棵树可以看作平面上的一个点，其中第 $i$ 棵树 $(1 \leq i \leq n)$ 位于坐标 $(x_i, y_i)$ 。任意两棵树的坐标均不相同。

老司机 Mr. P 从原点 $(0,0)$ 驾车出发，进行若干轮行动。每一轮，Mr. P 首先选择任意一个满足以下条件的方向：

1.为左、右、上、左上 $45\degree$、右上 $45\degree$ 五个方向之一。

2.沿此方向前进可以到达一棵他尚未许愿过的树。

完成选择后，Mr.P 沿该方向直线前进，必须到达该方向上距离最近的尚未许愿的树，在树下许愿并继续下一轮行动。如果没有满足条件的方向可供选择，则停止行动。他会采取最优策略，在尽可能多的树下许愿。若最优策略不唯一，可以选择任意一种。

不幸的是，小园丁 Mr.S 发现由于田野土质松软，老司机 Mr.P 的小汽车在每轮行进过程中，都会在田野上留下一条车辙印，一条车辙印可看作以两棵树（或原点和一棵树）为端点的一条线段。

在 Mr.P 之后，还有很多许愿者计划驾车来田野许愿，这些许愿者都会像 Mr.P 一样任选一种最优策略行动。Mr.S 认为非左右方向（即上、左上  $45\degree$、右 上 $45\degree$ 三个方向）的车辙印很不美观，为了维护田野的形象，他打算租用一些轧路机，在这群许愿者到来之前夯实所有“可能留下非左右方向车辙印”的地面。“可能留下非左右方向车辙印”的地面应当是田野上的若干条线段，其中每条线段都包含在某一种最优策略的行进路线中。每台轧路机都采取满足以下三个条件的工作模式：

1.从原点或任意一棵树出发。

2.只能向上、左上 $45\degree$、右上 $45\degree$ 三个方向之一移动，并且只能在树下改变方向或停止。

3.只能经过“可能留下非左右方向车辙印”的地面，但是同一块地面可以 被多台轧路机经过。

现在 Mr. P 和 Mr. S 分别向你提出了一个问题：

1.请给 Mr.P 指出任意一条最优路线。

2.请告诉 Mr.S 最少需要租用多少台轧路机。

## 说明/提示

#### 样例 1 解释

最优路线共 $2$ 条，可许愿 $3$ 次：$(0,0) \rightarrow (1,1) \rightarrow (-1,1) \rightarrow (-2,2)$ 或 $(0,0) \rightarrow (0,8) \rightarrow (0,9) \rightarrow (0,10)$。

至少 $3$ 台轧路机，路线是 $(0,0) \rightarrow (1,1)$，$(-1,1) \rightarrow (-2,2)$ 和 $(0,0) \rightarrow (0,8) \rightarrow (0,9) \rightarrow (0,10)$。

#### 样例 2 解释

最优路线唯一：$(0,0) \rightarrow (0,1) \rightarrow (-2,1) \rightarrow (2,1) \rightarrow (3,2)$，可许愿 $4$ 次。其中在 $(0,1)$ 许愿后，从 $(-2,1)$ 出发沿着向右的方向能够到达的最近的未许愿过的树是 $(2,1)$，所以可以到达 $(2,1)$。

而如果沿着 $(0,0) \rightarrow (0,1) \rightarrow (2,1) \rightarrow (-2,1)$ 的方向前进，此时 $(-2,1)$ 右边所有树都是许愿过的，根据题目条件规定，停止前进。故无法获得最优解。

$(0,0) \rightarrow (0,1)$ 与 $(2,1) \rightarrow (3,2)$ 会留下非左右方向车辙印，需 $2$ 台轧路机。

![](https://cdn.luogu.com.cn/upload/pic/1509.png)

## 样例 #1

### 输入

```
6
-1 1
1 1
-2 2
0 8
0 9
0 10
```

### 输出

```
3
2 1 3
3
```

## 样例 #2

### 输入

```
4
0 1
-2 1
2 1
3 2
```

### 输出

```
4
1 2 3 4
2```

# 题解

## 作者：litble (赞：27)

# 题目分析

[爱我请戳这里](https://blog.csdn.net/litble/article/details/80463466)

[图挂了请戳这里](https://blog.csdn.net/litble/article/details/80463466)

## 老司机
关于老司机的这一部分，显而易见是个dp。将纵坐标相等的点组成的集合称为层，则我们要逐层dp。

将(0,0)这个点看作一棵树，算出答案后再减去它的贡献。

首先预处理出每棵树向左上，上，右上会到哪棵树，这个可以离散+桶完成，正上的处理就是将x坐标放桶里，左上右上的就把经过该点的直线$y=x+b_1$和$y=x-b_2$对应的$b_1$，$b_2$搞进去。

然后就逐层dp撒，如图，会发现假如我们从i点到达该层，从j点离开该层。如果$i<j$，则该层在$j$左边的树都会被走到。如果$i>j$，则该层在$j$右边的树都会被走到。当然啦，如果$i=j$，就只有这棵树会被走到。

~~我才不会告诉你我一开始没想清楚必须是没许愿的树才能在此转向而GG了一个小时呢~~

![灵魂画手litble](https://img-blog.csdn.net/20180526170855289?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGJsZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

于是我们就可以设$f(i)$表示从i树进入i所在层，可以走的树的最大值。从y最大的层往y最小的处理，对每一层按x排序后，先从左到右扫一遍，再从右往左扫一遍，同时记录一种方案（记录以i进入该层，要以哪个点出去最优和以j出去，是走左上右上还是正上）。

利用我们记录的信息递归输出一种方案，即可获得40分。

## 小园丁

由于有每层树的个数不超过1000或只有一条路径的限制，所以我们可以从y最小的层往y最大的处理，对于每一个“可以作为这层起点”的树i，枚举这层所有树j，看是否可以从j出去。如果可以，那么j出去达到的树也要标记为“可以作为这层起点”，如此如此，可以弄出所有需要压路机压的路径，但是千万别弄出重边。

这是一个经典的有上下界网络流的模型，即每条边的流量上下界为$[1,inf]$，然后建立源点$S$和汇点$T$，$S$往每个点连一条$[0,inf]$的边，每个点往$T$连一条$[0,inf]$的边。

什么？你不会有上下界网络流？[还不去学!](https://blog.csdn.net/litble/article/details/78757040)就是这篇文章讲的“有源汇最小流”的模型。

可是如果你打完，就TLE了。

以下没看懂文字请直接看代码。

这张图由于比较特殊，所以可以考虑，我们首先让每条边流量等于其下界，那么有些点进出不平衡了嘛，由于$S$和$T$与所有点都有无限流量的边，所以在此时我们可以直接让“积蓄”了流量的点将流量排到$T$，“缺少”流量的点从$S$拿一点来补充，那么此时的流为所有“积蓄”的流量之和。

然后我希望最小流，也就是想让这张图自己“消化调整”，那么求一次超级源汇之间的最大流$kans$，这就是这张图自己不经过S和T做调节的最大限度，“积蓄”流量之和减去$kans$就是答案。

```cpp
void work2() {
	build();
	S=n+1,T=n+2,ss=n+3,tt=n+4;//呃，其实这个S和T可以删掉
	for(RI i=1;i<=n;++i) {
		if(du[i]>0) adde(ss,i,du[i]),ans+=du[i];//du:如果有[1,inf]边(x,y)，那么++du[y],--du[x]
		else adde(i,tt,-du[i]);
	}
	while(bfs(ss,tt)) ans-=dfs(ss,inf,tt);
	printf("%d\n",ans);
}
```

# 代码

~~哈哈哈哈我没疯放开我我怎么可能敲码农题敲了一下午就疯了呢哈哈哈哈~~

如果是考场上我肯定选择弃疗。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int q=0,w=1;char ch=' ';
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-') w=-1,ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q*w;
}
#define RI register int
const int N=50010,inf=0x3f3f3f;
int n,jsx,jsy,js1,js2;
struct node{int x,y,b1,b2,id;}p[N];
int bx[N],by[N],bb1[N],bb2[N];

int up[N],lup[N],rup[N],f[N],Tx[N],Tb1[N],Tb2[N],bj[N],tx[N],ty[N],gup[N],bup[N];
//gup:往上走最多走几棵树，bup:往上走走最多的树，下一步走到哪颗树,bj:记录方案,T开头的都是桶
bool cmpy(node a,node b) {return a.y>b.y;}
bool cmpx(node a,node b) {return a.x<b.x;}
vector<int> iny[N];
void prework() {//预处理每个点左上，右上，正上是那些点
	sort(bx+1,bx+1+n),sort(by+1,by+1+n);
	sort(bb1+1,bb1+1+n),sort(bb2+1,bb2+1+n);
	jsx=1;for(RI i=2;i<=n;++i) if(bx[i]!=bx[jsx]) bx[++jsx]=bx[i];
	jsy=1;for(RI i=2;i<=n;++i) if(by[i]!=by[jsy]) by[++jsy]=by[i];
	js1=1;for(RI i=2;i<=n;++i) if(bb1[i]!=bb1[js1]) bb1[++js1]=bb1[i];
	js2=1;for(RI i=2;i<=n;++i) if(bb2[i]!=bb2[js2]) bb2[++js2]=bb2[i];
	for(RI i=1;i<=n;++i) {
		p[i].x=lower_bound(bx+1,bx+1+jsx,p[i].x)-bx,tx[i]=p[i].x;
		p[i].y=lower_bound(by+1,by+1+jsy,p[i].y)-by,ty[i]=p[i].y;
		p[i].b1=lower_bound(bb1+1,bb1+1+js1,p[i].b1)-bb1;
		p[i].b2=lower_bound(bb2+1,bb2+1+js2,p[i].b2)-bb2;
	}
	sort(p+1,p+1+n,cmpy);
	for(RI i=1;i<=n;++i) {
		int k=p[i].id;
		up[k]=Tx[p[i].x],lup[k]=Tb1[p[i].b1],rup[k]=Tb2[p[i].b2];
		Tx[p[i].x]=Tb1[p[i].b1]=Tb2[p[i].b2]=k;
	}
	sort(p+1,p+1+n,cmpx);
	for(RI i=1;i<=n;++i) iny[p[i].y].push_back(p[i].id);
}
void print(int num) {//输出方案
	int y=ty[num],sz=iny[y].size(),nxt=bj[num];
	if(num!=n) printf("%d ",num);
	if(tx[nxt]<tx[num]) {
		for(RI i=0;i<sz;++i)
			if(tx[iny[y][i]]>tx[num]) printf("%d ",iny[y][i]);
		for(RI i=sz-1;i>=0;--i)
			if(tx[iny[y][i]]<tx[num]&&tx[iny[y][i]]>=tx[nxt]) printf("%d ",iny[y][i]);
	}
	else if(tx[nxt]>tx[num]) {
		for(RI i=sz-1;i>=0;--i)
			if(tx[iny[y][i]]<tx[num]) printf("%d ",iny[y][i]);
		for(RI i=0;i<sz;++i)
			if(tx[iny[y][i]]>tx[num]&&tx[iny[y][i]]<=tx[nxt]) printf("%d ",iny[y][i]);
	}
	if(bup[nxt]) print(bup[nxt]);
}
void work1() {//DP主体
	prework();
	for(RI y=jsy;y>=1;--y) {
		int kmx=0,kbj=0,sz=iny[y].size();
		for(RI i=0;i<sz;++i) {
			int k=iny[y][i];
			if(up[k]&&f[up[k]]>gup[k]) gup[k]=f[up[k]],bup[k]=up[k];
			if(lup[k]&&f[lup[k]]>gup[k]) gup[k]=f[lup[k]],bup[k]=lup[k];
			if(rup[k]&&f[rup[k]]>gup[k]) gup[k]=f[rup[k]],bup[k]=rup[k];
			f[k]=kmx,bj[k]=kbj;
			if(sz-i+gup[k]>kmx) kmx=sz-i+gup[k],kbj=k;
		}
		kmx=kbj=0;
		for(RI i=sz-1;i>=0;--i) {
			int k=iny[y][i];
			if(kmx>f[k]) f[k]=kmx,bj[k]=kbj;
			if(gup[k]+1>f[k]) f[k]=gup[k]+1,bj[k]=k;
			if(i+1+gup[k]>kmx) kmx=i+1+gup[k],kbj=k;
		}
	}
	printf("%d\n",f[n]-1),print(n),puts("");
}

int tot=1,S,T,ss,tt,ans;
int ok[N],du[N],h[N],ne[N*10],to[N*10],flow[N*10],lev[N],q[N];
void adde(int x,int y,int z) {
	to[++tot]=y,ne[tot]=h[x],h[x]=tot,flow[tot]=z;
	to[++tot]=x,ne[tot]=h[y],h[y]=tot,flow[tot]=0;
}
void add(int x,int y) {
	for(RI i=h[x];i;i=ne[i]) if(to[i]==y) return;//注意不要重复（由于数据特殊性不会很慢）
	ok[y]=1,++du[y],--du[x],adde(x,y,inf);
}
void calc(int y,int i) {//暴力查看符合条件的点
	int sz=iny[y].size(),num=iny[y][i];
	for(RI j=0;j<i;++j) {
		int k=iny[y][j];
		if(up[k]&&f[up[k]]+sz-j==f[num]) add(k,up[k]);
		if(lup[k]&&f[lup[k]]+sz-j==f[num]) add(k,lup[k]);
		if(rup[k]&&f[rup[k]]+sz-j==f[num]) add(k,rup[k]);
	}
	for(RI j=i+1;j<sz;++j) {
		int k=iny[y][j];
		if(up[k]&&f[up[k]]+j+1==f[num]) add(k,up[k]);
		if(lup[k]&&f[lup[k]]+j+1==f[num]) add(k,lup[k]);
		if(rup[k]&&f[rup[k]]+j+1==f[num]) add(k,rup[k]);
	}
	if(up[num]&&f[up[num]]+1==f[num]) add(num,up[num]);
	if(lup[num]&&f[lup[num]]+1==f[num]) add(num,lup[num]);
	if(rup[num]&&f[rup[num]]+1==f[num]) add(num,rup[num]);
}
void build() {//网络流建图
	ok[n]=1;
	for(RI y=1;y<=jsy;++y) {
		int sz=iny[y].size();
		for(RI i=0;i<sz;++i) if(ok[iny[y][i]]) calc(y,i);
	}
}
int dfs(int x,int liu,int t) {//dinic的dfs
	if(x==t) return liu;
	int kl,sum=0;
	for(RI i=h[x];i;i=ne[i])
		if(flow[i]>0&&lev[to[i]]==lev[x]+1) {
			kl=dfs(to[i],min(flow[i],liu-sum),t);
			sum+=kl,flow[i]-=kl,flow[i^1]+=kl;
			if(sum==liu) return sum;
		}
	if(!sum) lev[x]=-1;
	return sum;
}
int bfs(int s,int t) {//dinic的bfs
	for(RI i=1;i<=n+4;++i) lev[i]=0;
	int he=1,ta=1; lev[s]=1,q[1]=s;
	while(he<=ta) {
		int x=q[he];++he;
		if(x==t) return 1;
		for(RI i=h[x];i;i=ne[i])
			if(flow[i]>0&&!lev[to[i]])
				lev[to[i]]=lev[x]+1,q[++ta]=to[i];
	}
	return 0;
}
void work2() {
	build();
	S=n+1,T=n+2,ss=n+3,tt=n+4;
	for(RI i=1;i<=n;++i) {
		if(du[i]>0) adde(ss,i,du[i]),ans+=du[i];
		else adde(i,tt,-du[i]);
	}
	while(bfs(ss,tt)) ans-=dfs(ss,inf,tt);
	printf("%d\n",ans);
}

int main()
{
	n=read();
	for(RI i=1;i<=n;++i) {
		bx[i]=p[i].x=read(),by[i]=p[i].y=read();
		bb1[i]=p[i].b1=p[i].y-p[i].x,bb2[i]=p[i].b2=p[i].x+p[i].y;
		p[i].id=i;
	}
	++n,p[n].id=n;
	work1(),work2();
    return 0;
}
```


---

## 作者：Sol1 (赞：12)

提供一个 **不依赖于题面中给出的「仅有一条最优路径或者 $y$ 相同的树不超过 $1000$ 棵」这一限制** 的做法。

首先对于 Mr. P 的部分有一个 DP：

考虑每一层，这一层有若干个点，形成一条链。

![](https://cdn.luogu.com.cn/upload/image_hosting/0iq58rm6.png)

然后，考虑在这一层从一个点移动到另一个点的时候，如何最大化经过的点数。

发现：

- 当我们要从左边的某个点移动到右边的某个点的时候，可以经过所有左边的这个点左边的点。例如上图从 $3$ 移动到 $4$，最优方案一定是 $3\rightarrow 2\rightarrow 1\rightarrow 4$。
- 当我们要从右边的某个点移动到左边的某个点的时候，可以经过所有右边的这个点右边的点。例如上图从 $4$ 移动到 $2$，最优方案一定是 $4\rightarrow 5\rightarrow 3\rightarrow 2$。

所以对向左走和向右走分开建图，再对每一个点在图里面建一个点用于向外连边。显然每向左/向右移动一个位置就多 1 个许愿的位置，而从在链上移动的点走到离开这条链的点显然不会多贡献。建出有权图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bvhlhbjl.png)

这样，如果一个点 $S$ 可以到点 $3$，那么在新图上体现为：

1. 不在链上移动：$S$ 向 $3\text{U}$ 连权值为 $1$ 的边。
2. 在链上向左移动：$S$ 向 $\text{2L}$ 连权值为 $(5-3+1)+1=4$ 的边。（**注意不是向 $\text{3L}$ 连边，因为必须向左移动才能获得右边的点**）
3. 在链上向右移动：类似向左，$S$ 向 $\text{4R}$ 连权值为 $3+1=4$ 的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/o42c795c.png)

这显然是一个 DAG。不妨设 $(0,0)$ 为点 $n+1$，从 $(n+1)\text U$ 开始在 DAG 上求最长路，就是第一问的答案了。

任意取一条最长路出来，按顺序考虑边的种类：

- $a\text U\rightarrow b\text U$：输出 $b$。
- $a\text U\rightarrow b\text L$：输出 $b$ 以及 $b$ 右边的所有点。
- $a\text U\rightarrow b\text R$：输出 $b$ 以及 $b$ 左边的所有点。
- $a\text L\rightarrow b\text L$：输出 $b$。
- $a\text R\rightarrow b\text R$：输出 $b$。
- 其他类型的边：什么也不输出。

这样就可以解决掉第二问。

第三问很简单，建一个上下界网络流，直接从原点开始 DFS，考虑所有 $a\text U\rightarrow b\text{U/L/R}$ 的边，如果 $a\text U$ 的 DP 值等于对应边的终点的 DP 值，那么这条边就可以在最长路上，在网络中建一条从 $a$ 到 $b$（注意在网络中不需要体现出 $\text{U/L/R}$ 的区别），下界为 $1$，上界为 $+\infty$ 的边。

然后从 $0$ 向所有点连下界 $0$，上界 $+\infty$ 的边；从所有点向 $T$ 连下界 $0$，上界 $+\infty$ 的边。

从 $S$ 到 $T$ 跑有源汇上下界最小流，就是第三问的答案了。

复杂度 $O(\text{Dinic})$。由于这题的图不是任意给定所以跑得非常快。

```cpp
struct Edge {
	int to, nxt, len;
	Edge() {
		nxt = -1;
	}
};
Edge e[1000005];
int n, hd[150055], pnt, x[50055], y[50055], s[50055], d[50055], tmp[50055], lcnt[50055], rcnt[50055], dp[150055], vi[50055], vj[50055];
bool vis[150055];
vector <int> vc[50055], vc2[50055];
vector <pair <int, int> > gt[150005];

namespace Dinic {
	struct Edge2 {
		int to, nxt, cap;
		Edge2() {
			nxt = -1;
		}
	};
	int hd[50055], pnt, d[50055], iter[50055], lv[50055];
	Edge2 e[3000015];
	set <int> st[50055];
	inline void AddEdge(int u, int v, int l, int r) {
		if (st[u].find(v) != st[u].end()) return;
		if (l) st[u].insert(v);
		d[u] -= l; d[v] += l;
		e[pnt].to = v;
		e[pnt].nxt = hd[u];
		e[pnt].cap = r - l;
		hd[u] = pnt;
		pnt++;
		e[pnt].to = u;
		e[pnt].nxt = hd[v];
		e[pnt].cap = 0;
		hd[v] = pnt;
		pnt++;
	}
	inline void Bfs(int s) {
		queue <int> que;
		que.push(s);
		memset(lv, -1, sizeof(lv));
		lv[s] = 0;
		while (!que.empty()) {
			int u = que.front();
			que.pop();
			for (int i = hd[u];~i;i = e[i].nxt) {
				if (e[i].cap && !~lv[e[i].to]) {
					lv[e[i].to] = lv[u] + 1;
					que.push(e[i].to);
				}
			}
		}
	}
	inline int Dfs(int u, int t, int f) {
		if (u == t) return f;
		int flw = 0;
		for (int &i = iter[u];~i;i = e[i].nxt) {
			if (e[i].cap && lv[e[i].to] == lv[u] + 1) {
				int d = Dfs(e[i].to, t, Min(f - flw, e[i].cap));
				if (d) {
					flw += d;
					e[i].cap -= d;
					e[i ^ 1].cap += d;
				} else lv[e[i].to] = -1;
			}
			if (flw == f) break;
		}
		return flw;
	}
	inline int Flow(int s, int t) {
		int ans = 0;
		for (;;) {
			Bfs(s);
			if (!~lv[t]) break;
			memcpy(iter, hd, sizeof(iter));
			ans += Dfs(s, t, 0x3f3f3f3f);
		}
		return ans;
	}
	inline int solve(int s, int t) {
		int ans = 0;
		for (int i = s;i <= t;i++) {
			if (d[i] > 0) AddEdge(t + 1, i, 0, d[i]), ans += d[i];
			if (d[i] < 0) AddEdge(i, t + 2, 0, -d[i]);
		}
		ans -= Dinic::Flow(t + 1, t + 2);
		//AddEdge(t, s, 0, 0x3f3f3f3f);
		//Dinic::Flow(t + 1, t + 2);
		return ans;
	}
}

inline void AddEdge(int u, int v, int w) {
	//printf("%d->%d %d\n", u, v, w);
	e[++pnt].to = v;
	e[pnt].len = w;
	e[pnt].nxt = hd[u];
	hd[u] = pnt;
	gt[v].push_back(make_pair(u, w));
}

inline void Read() {
	n = qread();
	for (int i = 1;i <= n;i++) {
		x[i] = qread(); y[i] = qread();
		s[i] = x[i] + y[i];
		d[i] = x[i] - y[i];
	}
	n++;
}

inline bool cmp1(int i, int j) {
	return y[i] < y[j];
}

inline bool cmp2(int i, int j) {
	return x[i] < x[j];
}

inline void Construct(int *x, bool clr) {
	memcpy(tmp, x, sizeof(tmp));
	sort(tmp + 1, tmp + n + 1);
	for (int i = 1;i <= n;i++) {
		int cur = lower_bound(tmp + 1, tmp + n + 1, x[i]) - tmp;
		vc[cur].push_back(i);
	}
	for (int i = 1;i <= n;i++) sort(vc[i].begin(), vc[i].end(), cmp1);
	if (clr) {
		for (int i = 1;i <= n;i++) {
			int siz = vc[i].size();
			for (int j = 0;j < siz - 1;j++) {
				AddEdge(vc[i][j] + 2 * n, vc[i][j + 1] + 2 * n, 1);
				int nxt = vj[vc[i][j + 1]] + 1;
				if (nxt < vc2[vi[vc[i][j + 1]]].size()) AddEdge(vc[i][j] + 2 * n, vc2[vi[vc[i][j + 1]]][nxt] + n, lcnt[vc[i][j + 1]] + 1);
				int pre = vj[vc[i][j + 1]] - 1;
				if (pre >= 0) AddEdge(vc[i][j] + 2 * n, vc2[vi[vc[i][j + 1]]][pre], rcnt[vc[i][j + 1]] + 1);
			}
		}
		for (int i = 1;i <= n;i++) vc[i].clear();
	}
}

inline void BuildG() {
	// horizontal
	memcpy(tmp, y, sizeof(tmp));
	sort(tmp + 1, tmp + n + 1);
	for (int i = 1;i <= n;i++) {
		vi[i] = lower_bound(tmp + 1, tmp + n + 1, y[i]) - tmp;
		vc2[vi[i]].push_back(i);
	}
	for (int i = 1;i <= n;i++) sort(vc2[i].begin(), vc2[i].end(), cmp2);
	for (int i = 1;i <= n;i++) {
		int siz = vc2[i].size();
		for (int j = 0;j < siz;j++) {
			vj[vc2[i][j]] = j;
			lcnt[vc2[i][j]] = j + 1;
			rcnt[vc2[i][j]] = siz - j;
		}
		for (int j = 0;j < siz - 1;j++) {
			AddEdge(vc2[i][j + 1], vc2[i][j], 1);
			AddEdge(vc2[i][j] + n, vc2[i][j + 1] + n, 1);
		}
	}
	//printf("(%d,%d)\n", lcnt[1], rcnt[1]);
	Construct(x, 1);
	Construct(d, 1);
	Construct(s, 1);
	for (int i = 1;i <= n;i++) {
		AddEdge(i, 2 * n + i, 0);
		AddEdge(i + n, 2 * n + i, 0);
	}
	AddEdge(3 * n + 1, n, 0); AddEdge(3 * n + 1, 2 * n, 0); AddEdge(3 * n + 1, 3 * n, 0);
}

inline int Dfs(int u) {
	if (vis[u]) return dp[u];
	//printf("DFS %d\n", u);
	vis[u] = 1;
	for (int i = hd[u];~i;i = e[i].nxt) {
		dp[u] = Max(dp[u], Dfs(e[i].to) + e[i].len);
	}
	return dp[u];
}

inline void Dfs2(int u) {
	for (int i = hd[u];~i;i = e[i].nxt) {
		if (dp[e[i].to] + e[i].len == dp[u]) {
			int v = e[i].to;
			if (u > 2 * n && u <= 3 * n && v <= 3 * n) {
				if (v <= n) {
					int siz = vc2[vi[v]].size();
					//printf("v=%d vi=%d vj=%d siz=%d\n", v, vj[v], siz);
					for (int j = vj[v] + 1;j < siz;j++) printf("%d ", vc2[vi[v]][j]);
					printf("%d ", (v - 1) % n + 1);
				} else if (v <= 2 * n) {
					for (int j = vj[v - n] - 1;j >= 0;j--) printf("%d ", vc2[vi[v - n]][j]);
					printf("%d ", (v - 1) % n + 1);
				} else {
					printf("%d ", (v - 1) % n + 1);
				}
			} else if (v <= 2 * n) printf("%d ", (v - 1) % n + 1);
			//printf("v=%d\n", v);
			Dfs2(v);
			return;
		}
	}
}

inline void Dfs3(int u) {
	if (vis[u]) return;
	vis[u] = 1;
	for (int i = hd[u];~i;i = e[i].nxt) {
		if (dp[e[i].to] + e[i].len == dp[u]) {
			int v = e[i].to;
			if (u > 2 * n && u <= 3 * n && v <= 3 * n) {
				if (v <= n) {
					int nxt = vc2[vi[v]][vj[v] + 1];
					Dinic::AddEdge(u - 2 * n, nxt, 1, 0x3f3f3f3f);
				} else if (v <= 2 * n) {
					int pre = vc2[vi[v - n]][vj[v - n] - 1];
					Dinic::AddEdge(u - 2 * n, pre, 1, 0x3f3f3f3f);
				} else Dinic::AddEdge(u - 2 * n, v - 2 * n, 1, 0x3f3f3f3f);
			}
			//printf("v=%d\n", v);
			Dfs3(v);
		}
	}
}

inline void Solve() {
	memset(Dinic::hd, -1, sizeof(Dinic::hd));
	memset(vis, 0, sizeof(vis));
	Dfs3(3 * n + 1);
	printf("%d", Dinic::solve(0, n + 1));
}
```

---

## 作者：jamespaul (赞：6)

预处理出每个点在非左右方向离该点最近的点，然后以纵坐标为第一关键字，横坐标为第二关键字排序。以纵坐标为阶段做dp，同层的也做dp。这里只讲同层如何dp。

枚举从哪一个点向上走(i)，假设之前在下一层往上走到j，如果xj<xi，那么与i同层的，且在i左边的都可以到达（从j走到同层的最左边，然后走到j+1，再走到i），如果xi<xj，那么与i同层的，且在i右边的都可以到达（从j走到同层的最右边，然后走到j−1,再走到i），那么正向做一次，反向做一次就可以知道最大值了，同时记住方案。

根据方案将非左右方向的边找出，并构出新图，因为有可能多条最长路径同时经过某些边，因此每条边的下界为1，做一次最小流即可。


---

## 作者：LinkyChristian (赞：4)

**每周文章计划 2021.12 第四周**

解法其实最顶上的题解讲得很清楚了，我来补充一些实现细节以及注释代码

管理求过

预处理时从上往下预处理每一行，用三个桶处理每条竖线和斜线在这一层交的点，之后每一层从上一层的桶里提取点

$dp$ 时依旧是从上往下处理每一层，先处理出以每个点为出点到上一层的最大值，在处理以每个点为入点到这一层出去的最大值，记下后驱，以便输出答案。

对于网络流，因为要求每个非左右边至少有一个轧路机经过，所以是跑有下界的最小网络流，具体建模方法见最上。

代码才是重点

```cpp
//Linky
#include<bits/stdc++.h>
using namespace std;
#define N 50010
using namespace std;
const int INF=0x3f3f3f3f;
struct node{
	int x,y,b1,b2,id;
}p[N];
int n,bx[N],by[N],tb1[N],tb2[N];//用于离散 
int tx[N],ty[N]; //未排序编号下的xy 
int up[N]/*向上走*/,rup[N]/*向右上走*/,lup[N]/*向左上走*/; 
int bacx[N],bacb1[N],bacb2[N];//上一层在x的点，上一层在b1斜线的点，上一层在b2斜线的点 
vector<int> row[N];
bool cmp1(node a1,node a2) {return a1.y>a2.y;}
bool cmp2(node a1,node a2) {return a1.x<a2.x;}
int t1,t2,t3,t4;
int lst[N]/*不同层后驱点*/;
int cen[N]/*同层后驱点*/; 
int f[N]/*从此点进入的最大权值*/;
int gup[N]/*从此点往上走的最大值*/;
void prework() {
	sort(bx+1,bx+n+1),sort(by+1,by+n+1);
	sort(tb1+1,tb1+n+1),sort(tb2+1,tb2+n+1);
	t1=unique(bx+1,bx+n+1)-bx-1;
	t2=unique(by+1,by+n+1)-by-1;
	t3=unique(tb1+1,tb1+n+1)-tb1-1;
	t4=unique(tb2+1,tb2+n+1)-tb2-1;
	for(int i=1; i<=n; i++) {
		p[i].x=lower_bound(bx+1,bx+t1+1,p[i].x)-bx,tx[i]=p[i].x;
		p[i].y=lower_bound(by+1,by+t2+1,p[i].y)-by,ty[i]=p[i].y;
		//tx,ty记录原编号的xy 
		p[i].b1=lower_bound(tb1+1,tb1+t3+1,p[i].b1)-tb1;
		p[i].b2=lower_bound(tb2+1,tb2+t4+1,p[i].b2)-tb2;
	}
	sort(p+1,p+n+1,cmp1);
	for(int i=1; i<=n; i++) {
		int id=p[i].id;
		up[id]=bacx[p[i].x];
		rup[id]=bacb1[p[i].b1];
		lup[id]=bacb2[p[i].b2]; 
		bacx[p[i].x]=bacb1[p[i].b1]=bacb2[p[i].b2]=id;
	}
	sort(p+1,p+n+1,cmp2);
	for(int i=1; i<=n; i++) row[p[i].y].push_back(p[i].id);
}
void print(int num)//输出方案
{
    int y=ty[num],siz=row[y].size(),nxt=cen[num];
	if(num!=n) printf("%d ",num);	
	if(tx[nxt]<tx[num]) {//右进左出
	    for(int i=0; i<siz; i++)
		    if(tx[row[y][i]]>tx[num]) printf("%d ",row[y][i]);//先输出进点右边
		for(int i=siz-1; i>=0; i--)
		    if(tx[row[y][i]]<tx[num]&&tx[row[y][i]]>=tx[nxt]) printf("%d ",row[y][i]);//输出进点到出点之间的 		
	}  else if(tx[nxt]>tx[num]) {//左进右出，以下同理 
		for(int i=siz-1; i>=0; i--)
		    if(tx[row[y][i]]<tx[num]) printf("%d ",row[y][i]);
		for(int i=0; i<siz; i++)
		    if(tx[row[y][i]]>tx[num]&&tx[row[y][i]]<=tx[nxt]) printf("%d ",row[y][i]);
	}
	if(lst[nxt]) print(lst[nxt]);//往出点连接的上一层 
}
void work1()
{
	prework();
	for(int y=t2; y>0; y--) {
		int mx=0,bak=0,siz=row[y].size();
		for(int i=0; i<siz; i++) {//右进左出 
			int k=row[y][i];
			if(up[k]&&f[up[k]]>gup[k]) gup[k]=f[up[k]],lst[k]=up[k];
			if(rup[k]&&f[rup[k]]>gup[k]) gup[k]=f[rup[k]],lst[k]=rup[k];
			if(lup[k]&&f[lup[k]]>gup[k]) gup[k]=f[lup[k]],lst[k]=lup[k];
			f[k]=mx,cen[k]=bak;
			if(siz-i+gup[k]>mx) mx=siz-i+gup[k],bak=k;//出点右边的点有siz-i个 
		}
		mx=bak=0;
		for(int i=siz-1; i>=0; i--) {//左进右出 
			int k=row[y][i];
			if(mx>f[k]) f[k]=mx,cen[k]=bak;
			if(gup[k]+1>f[k]) f[k]=gup[k]+1,cen[k]=k;//从此点入此点出
			if(i+1+gup[k]>mx) mx=i+1+gup[k],bak=k; //出点左边的点有i+1个 
		}
	}
	printf("%d\n",f[n]-1);
	print(n);//从原点开始（n） 
	cout<<endl;
}
int s,t,ans;
int dep[N];
int cnt=1,head[N],nxt[N*20],to[N*20],val[N*20];
void insert(int u,int v,int w) {
	cnt++;
	to[cnt]=v;
	val[cnt]=w;
	nxt[cnt]=head[u];
	head[u]=cnt;
} 
void ins(int u,int v,int w) {
	insert(u,v,w);
	insert(v,u,0);
}
int ok[N],du[N];//是否可以作为此层起点 
void add(int x,int y) //连上下界为[1,INF）的边
{
	for(int i=head[x]; i; i=nxt[i]) if(to[i]==y) return ;
	ok[y]=1,++du[y],--du[x],ins(x,y,INF);
}
void calc(int y,int i) {//暴力检测符合作为最优路径本层起点的边 
	int siz=row[y].size(),num=row[y][i];
	for(int j=0; j<i; j++) {//右进左出 
		int k=row[y][j];
		if(up[k]&&f[up[k]]+siz-j==f[num]) add(k,up[k]);
		if(rup[k]&&f[rup[k]]+siz-j==f[num]) add(k,rup[k]);
		if(lup[k]&&f[lup[k]]+siz-j==f[num]) add(k,lup[k]);
	}
	for(int j=i+1; j<siz; j++) {//左进右出 
		int k=row[y][j];
		if(up[k]&&f[up[k]]+j+1==f[num]) add(k,up[k]); 
		if(rup[k]&&f[rup[k]]+j+1==f[num]) add(k,rup[k]);
		if(lup[k]&&f[lup[k]]+j+1==f[num]) add(k,lup[k]);
	}
	//直进直出 
	if(up[num]&&f[up[num]]+1==f[num]) add(num,up[num]);
	if(rup[num]&&f[rup[num]]+1==f[num]) add(num,rup[num]);
	if(lup[num]&&f[lup[num]]+1==f[num]) add(num,lup[num]);
} 
void build() {//逐层向上建边
	ok[n]=1;
	for(int y=1; y<=t2; y++) {
		int siz=row[y].size();
		for(int i=0; i<siz; i++) if(ok[row[y][i]]) calc(y,i);
	}
}
bool bfs() {
	memset(dep,0,sizeof(dep));
	queue<int> q;
	q.push(s),dep[s]=1;
	while(!q.empty()) {
		int now=q.front();q.pop();
		for(int i=head[now]; i; i=nxt[i])
		    if(val[i]&&!dep[to[i]])
		        dep[to[i]]=dep[now]+1,
		        q.push(to[i]);
	}
	return dep[t]>0;
}
int dfs(int now,int dis) 
{
	if(now==t) return dis;
	int res=0;
	for(int i=head[now]; i; i=nxt[i])
	    if(val[i]&&dep[to[i]]==dep[now]+1) {
	    	int tmp=dfs(to[i],min(val[i],dis-res));
	    	res+=tmp,val[i]-=tmp,val[i^1]+=tmp;
	    	if(res==dis) return res;
 		}
 	if(!res) dep[now]=-1;
 	return res;
}
void work2() {//上下界网络流 
	build();
	s=n+1,t=n+2;
	for(int i=1; i<=n; i++)
	    if(du[i]>0) ins(s,i,du[i])/*缺少的从s要*/,ans+=du[i]/*预先流的最大流*/; 
	    else ins(i,t,-du[i])/*多余的向t流*/;
	while(bfs()) ans-=dfs(s,INF);/*调整*/ 
	printf("%d",ans);
}
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>p[i].x>>p[i].y;
		bx[i]=p[i].x,by[i]=p[i].y;
		tb1[i]=p[i].b1=p[i].y-p[i].x;//往右上斜的线 
		tb2[i]=p[i].b2=p[i].x+p[i].y;//往左上斜的线 
		p[i].id=i;
	}
	p[++n].id=n;//最后一个点是（0,0） 
	work1(),work2();
	return 0;
}

```


---

## 作者：TianyiLemon (赞：1)

关键词：离散化，DP，分层图，上下界最小流。

### 预处理

首先将坐标按 y 离散化，每层打包装进 vector 里，按 x 坐标排序。

分别用 $to[i,0/1/2]$ 代表向正上方/左上/右上可以走到的点。

计算的时候可以采用编号排序的方式，分别按照 3 个关键字排序，只需检查相邻两个元素是否合法即可。注意不同编号不要混淆。

### DP

这题 DP 的方式多种多样，这里给出我的做法。

注意到不同层之间转移是没有后效性的，只有层之间转移才有后效性。

所以我们不妨状态具体化一发，$f[u,0]$ 代表沿非左右方向的边到达 u，经过最多树的数目；$f[u,1]$ 代表沿所有方向走到 u，经过最多树的树木。

层数从小到大循环，层之间转移时用 $f[u,1]+1$ 更新 $f[v,0]$ (存在边 $u\to v$)。

层内转移时，如果从 u 左边进入该层，那么 u 左边的点都可以取，反之亦然。

根据定义，还要用 $f[u,0]$ 更新一下 $f[u,1]$。

初状态：$f[0,1]=0$ ($f[0,0]$ 不用管，因为树的 x 坐标一定大于 0)

目标状态：$\max_{u=1}^n{\{ f[u,1]\}}$。

题目还要求输出方案，用 $pre[i,0/1]$ 记录一下从哪个状态更新过来，然后递归输出，注意一下实现细节就可以了。

### 网络流

首先是判断哪些边需要被经过。实际上就是倒着做一遍 DP，层数从大到小循环，$ok[i,0/1]$ 代表从 $f[i,0/1]$ 能否转移到最优解，$need[i,0/1/2]$ 代表这条边是否需要被经过。实现上要特别仔细。

最后跑一个上下界最小流就可以，这里不再赘述。我的 dinic 加入了一些剪枝，所以跑得飞快。

### 总结

+ 实现的时候要特别注意变量的含义，必要的地方加上注释。~~不要像我一样乱用编号，然后一个小时调不出来~~

超丑的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 50009
#define rep(i,x,y) for(int i=(x);i<=(y);++i)
#define per(i,x,y) for(int i=(x);i>=(y);--i)
#define pII pair<int,int>
#define fi first
#define se second
#define pb push_back
int n,pos[N][3],num[N],cnt,dep[N],to[N][3],id[N];//id[i]代表排序后编号为i的元素原来处于第几位
vector<int> v[N];
pII p[N];
int gethash(int x){return lower_bound(num+1,num+cnt+1,x)-num;}
bool cmp1(const int &a,const int &b){return p[a]<p[b];}
bool cmp2(const int &a,const int&b){return p[a].fi+p[a].se<p[b].fi+p[b].se||p[a].fi+p[a].se==p[b].fi+p[b].se&&p[a].se<p[b].se;}
bool cmp3(const int &a,const int &b){return p[a].se-p[a].fi<p[b].se-p[b].fi||p[a].se-p[a].fi==p[b].se-p[b].fi&&p[a].se<p[b].se;}
void prework(){
	num[++cnt]=0;
	rep(i,1,n)scanf("%d %d",&p[i].fi,&p[i].se),num[++cnt]=p[i].se;
	sort(num+1,num+cnt+1);cnt=unique(num+1,num+cnt+1)-num-1;//离散化
	rep(i,0,n){
		int x=gethash(p[i].se);v[x].pb(i);dep[i]=x;
		id[i]=i;
	}//按照3个关键字排序
	sort(id,id+n+1,cmp1);
	rep(i,0,n-1)
		if(p[id[i]].fi==p[id[i+1]].fi)to[id[i]][0]=id[i+1];
	sort(id,id+n+1,cmp2);
	rep(i,0,n-1){
		int b1=p[id[i]].fi+p[id[i]].se,b2=p[id[i+1]].fi+p[id[i+1]].se;
		if(b1==b2)to[id[i]][1]=id[i+1];
	}
	sort(id,id+n+1,cmp3);
	rep(i,0,n-1){
		int b1=p[id[i]].se-p[id[i]].fi,b2=p[id[i+1]].se-p[id[i+1]].fi;
		if(b1==b2)to[id[i]][2]=id[i+1];
	}
}
const int inf=0x3f3f3f3f;
int f[N][2],rk[N];
struct dat{int i;bool j;} pre[N][2],res;
bool upd(int&a,int b){if(a<b){a=b;return 1;}return 0;}
void print(int i,bool j){
	if(!i)return;
	print(pre[i][j].i,pre[i][j].j);
	if(!j)printf("%d ",i);
	else if(pre[i][j].i!=i){
		int k=pre[i][j].i,x=rk[i],y=rk[k],sz=v[dep[i]].size();//x,y编号为i,k点排序后的排名
		//v[dep[i]][w]是原始编号
		if(y<x){
			per(w,y-1,0)printf("%d ",v[dep[i]][w]);
			rep(w,y+1,x)printf("%d ",v[dep[i]][w]);
		}else {
			rep(w,y+1,sz-1)printf("%d ",v[dep[i]][w]);
			per(w,y-1,x)printf("%d ",v[dep[i]][w]);
		}
	}
}
int ans;
bool need[N][3],ok[N][2];
void check(){//判断合法
	rep(i,1,n)rep(j,0,1)if(f[i][j]==ans)ok[i][j]=1;
	per(x,cnt,1){
		int sz=v[x].size();
		rep(i,0,sz-1){
			int p=v[x][i];//
			rep(j,0,2)if(to[p][j]&&ok[to[p][j]][0]&&f[to[p][j]][0]==f[p][1]+1)ok[p][1]=1,need[p][j]=1;
			if(ok[p][1]){
				if(f[p][0]==f[p][1])ok[p][0]=1;
				rep(j,0,i-1){
					int q=v[x][j];
					if(f[p][1]==f[q][0]+i)ok[q][0]=1;
				}
				rep(j,i+1,sz-1){
					int q=v[x][j];
					if(f[p][1]==f[q][0]+sz-1-i)ok[q][0]=1;
				}
			}
		}
	}
}
void DP(){
	rep(i,1,cnt){
		sort(v[i].begin(),v[i].end(),cmp1);
		rep(j,0,(int)v[i].size()-1)rk[v[i][j]]=j;
	}
	rep(i,0,n)rep(j,0,1)f[i][j]=-inf;
	f[0][1]=0;
	rep(x,1,cnt){
		int sz=v[x].size();
		rep(i,0,sz-1){
			int p=v[x][i];//当前节点编号
			if(upd(f[p][1],f[p][0]))pre[p][1]=(dat){p,0};
			rep(j,0,i-1){
				int q=v[x][j];
				if(upd(f[p][1],f[q][0]+i))pre[p][1]=(dat){q,0};
			}
			rep(j,i+1,sz-1){
				int q=v[x][j];
				if(upd(f[p][1],f[q][0]+sz-1-i))pre[p][1]=(dat){q,0};
			}
		}
		rep(i,0,sz-1){
			int p=v[x][i];
			rep(j,0,2)if(to[p][j]){
				int k=to[p][j];
				if(upd(f[k][0],f[p][1]+1))pre[k][0]=(dat){p,1};
			}
		}
	}
	rep(i,1,n)if(upd(ans,f[i][1]))res=(dat){i,1};
	cout<<ans<<endl;
	print(res.i,res.j);puts("");
}
#undef N
#define N 100009
#define M 350009
namespace flow{
	int hd[N],tot,d[N],now[N],s,t,ss,tt,nV,deg[N],minflow;
	struct edge{int t,w,nxt;} es[M<<1];
	void adde(int u,int v,int w){es[++tot]=(edge){v,w,hd[u]},hd[u]=tot;}void add(int u,int v,int w){adde(u,v,w),adde(v,u,0);}
	bool bfs(){queue<int> q;fill(d+1,d+nV+1,0);q.push(s);d[s]=1;now[s]=hd[s];while(q.size()){int u=q.front();q.pop();for(int i=hd[u],v;i;i=es[i].nxt)if(es[i].w&&!d[v=es[i].t]){d[v]=d[u]+1;now[v]=hd[v];q.push(v);if(v==t)return 1;}}return 0;}
	int dinic(int u,int flow){if(u==t)return flow;int rest=flow;for(int i=now[u],v;i&&rest;i=es[i].nxt)if(es[now[u]=i].w&&d[v=es[i].t]==d[u]+1){int k=dinic(v,min(rest,es[i].w));if(!k)d[v]=0;es[i].w-=k,es[i^1].w+=k;rest-=k;}return flow-rest;}
	void FLOW(){
		check();
		nV=n+5;s=nV-1,t=nV,ss=nV-3,tt=nV-2;tot=1;//编号从1开始！
		rep(u,0,n)rep(j,0,2)if(need[u][j]){
			int v=to[u][j];
			add(u+1,v+1,inf);++deg[v+1],--deg[u+1];
		}
		rep(i,1,n+1){
			add(ss,i,inf),add(i,tt,inf);
			if(deg[i]>0)add(s,i,deg[i]);else if(deg[i]<0)add(i,t,-deg[i]);
		}
		add(tt,ss,inf);
		while(bfs())dinic(s,inf);
		for(int  i=hd[ss];i;i=es[i].nxt)if(es[i].t==tt){
			minflow=es[i].w;hd[ss]=es[hd[ss]].nxt;hd[tt]=es[hd[tt]].nxt;//删边
			break;
		}
		s=tt,t=ss;
		while(bfs())minflow-=dinic(s,inf);
		cout<<minflow<<endl;
	}	
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen(".in","r",stdin);freopen(".out","w",stdout);
	#endif
	cin>>n;
	prework();DP();flow::FLOW();
	return 0;
}
```

---

## 作者：zhiyin123 (赞：0)

# 第三问不用上下界网络流的做法

## 前置知识

- Dilworth 定理 [oi-wiki](https://oi-wiki.org/math/order-theory/#dilworth-%E5%AE%9A%E7%90%86%E4%B8%8E-mirsky-%E5%AE%9A%E7%90%86)
- 最大权闭合子图 [oi-wiki](https://oi-wiki.org/graph/flow/min-cut/#%E9%97%AE%E9%A2%98%E6%A8%A1%E5%9E%8B-2)

## 正文

前两问其他题解已经说得很清楚了，但是第三问似乎都是用上下界网络流的，这里提供一个最大流的做法。

首先，将压路机要压的边都找出来，构成图 $G$。当然，这里 $G$ 是一个 DAG。

因为点更好处理一些，所以将 $G$ 中的所有边中间加一个点。例如，边 $u\to v$，需要先新增一个点 $e$，然后连边 $u\to e,e\to v$，然后删除边 $u\to v$。处理完后，得到图 $G'$。这里图 $G'$ 仍然是一个 DAG。

于是，原问题转化为，求图 $G'$ 的**最小链覆盖**。

这里“最小链覆盖”的意思是，用尽可能少的链覆盖图 $G'$ 的每一个**点**，链之间可以**相交**。

根据 Dilworth 定理：

> 最小链覆盖 = 最长反链

我们将原问题转化为求图 $G'$ 的**最长反链**。

“最长反链”是什么意思呢？首先，我们定义“**前驱**”：我们称节点 $u$ 是节点 $v$ 的前驱，当且仅当 $G'$ 上存在一条从 $u$ 到 $v$ 的**路径**。而找**最长反链**的意思是，找到最大的由**节点**构成的集合 $A$，使得 $A$ 是 $G'$ 点集的**子集**，并且 $\forall u,v\in A$，满足 $u$ **不**是 $v$ 的前驱，并且 $v$ **不**是 $u$ 的前驱。

那么如何求最长反链呢？考虑拆点，对于图 $G'$ 中的每个点 $x$，我们把它拆成点入点 $i_x$ 和出点 $o_x$，并连接 $i_x\to o_x$；对于原图中的所有边 $u\to x$，将其改为 $o_u\to i_x$；对于原图中的所有边 $x\to v$，将其改成 $o_x\to i_v$；然后设置**点权**，让 $i_x$ 的点权为 $-1$，让 $o_x$ 的点权为 $1$。对处理后的图 $H$，直接跑最大权闭合子图就行了。

DAG 的最大权闭合子图是什么意思呢？就是，DAG 的每个点都有点权（可以为负数），你需要选择一些点，使得选则点的权值之**和**最大化，但是，选择的点有限制条件。当且仅当节点 $u$ 是节点 $v$ 的**前驱**时，我们称 $v$ 是 $u$ 的**后继**。限制条件是：如果选择了点 $u$，那么 $u$ 的**所有**后继**必须**被选择。

实际上，因为这里求最大权闭合子图时建的边权只有 $1$ 和 $+\operatorname{inf}$，如果认为边数和点数同阶，那么复杂度为 $O(n\sqrt n)$，而 Dinic 远比预期跑的快。

## 代码

~~代码有点丑~~。用 `std::vector` 实现的 Dinic。

```cpp
#include<iostream>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;
template<typename Tp>
void appd(vector<Tp> &vec,const vector<Tp> &o){
    for(const auto& v:o) vec.push_back(v); 
    return ;
}
template<typename Tp>
bool tomax(Tp &x,const Tp &y){return x<y?(x=y,true):false;}
using ll=long long;
constexpr int MAXN=5e4,NSI=(MAXN+1)*(1+3)*2+2,INFi=0x3f3f3f3f;
struct ed_t{int v,rid,flo;};
vector<ed_t> ed[NSI+5];
constexpr int fS=1,fT=2;
int ncnt=2,oin[MAXN+5]={},oout[MAXN+5]={};
void con(int u,int v,int flo){
    ed_t fo{v,ed[v].size(),flo},ba{u,ed[u].size(),0};
    ed[u].push_back(fo); ed[v].push_back(ba);
    return ;
}
int lev[NSI+5],cur[NSI+5];
bool bfs(){
    fill(lev,lev+ncnt+1,-1);
    lev[fS]=1;
    queue<int> que;
    que.push(fS);
    while(!que.empty()){
        int u=que.front();
        que.pop();
        for(auto e:ed[u]){
            if(e.flo==0) continue;
            if(lev[e.v]==-1){
                lev[e.v]=lev[u]+1;
                que.push(e.v);
            }
        }
    }
    return lev[fT]!=-1;
}
int dfs(int it,int tflo){
    if(it==fT) return tflo;
    int rest=tflo;
    for(int &i=cur[it];i<ed[it].size();i++){
        auto &e=ed[it][i];
        if(e.flo==0||lev[e.v]!=lev[it]+1) continue;
        int rec=dfs(e.v,min(rest,e.flo));
        if(rec==0){
            lev[e.v]=-1;
        }else{
            e.flo-=rec;
            rest-=rec;
            ed[e.v][e.rid].flo-=rec;
            if(rest==0) break;
        }
    }
    return tflo-rest;
}
int zhen=0;
void inout(int &in,int &out){
    ++zhen;
    in=++ncnt; out=++ncnt;
    con(fS,out,1);
    con(in,fT,1);
    con(in,out,INFi);
    return ;
}
int N=0;
struct opo_t{ll x,y;}opo[MAXN+5]{};
struct re_t{
    ll *re;
    int cnt;
    re_t():re(new ll[MAXN+5]{}),cnt(0){}
    void ins(ll val){re[++cnt]=val; return ;}
    void uni(){sort(re+1,re+cnt+1); cnt=unique(re+1,re+cnt+1)-re-1; return ;}
    int getid(ll val){return lower_bound(re+1,re+cnt+1,val)-re;}
}yre,xre,sre,dre;
struct po_t{
    int oid,xid,sid,did,f,g;
};
bool po_cmp(const po_t &a,const po_t &b){return a.xid<b.xid;}
void upd(int &val,vector<int> &prv,int nval,int id){
    if(val<nval){
        val=nval;
        prv.clear();
        prv.push_back(id);
    }else if(val==nval){
        prv.push_back(id);
    }
    return ;
}
vector<int> tprv[MAXN+5],cprv[MAXN+5];
vector<po_t> po[MAXN+5];
struct prv_t{int oid,g;}xprv[MAXN+5],sprv[MAXN+5],dprv[MAXN+5];
int maxdis=0;
vector<int> smem;
void setmem(int it,bool isf){
    if(it==0) return ;
    if(smem.empty()||smem.back()!=it)smem.push_back(it);
    if(!isf){
        int v=tprv[it].front();
        int yid=yre.getid(opo[it].y);
        if(opo[v].x<opo[it].x){
            vector<int> fi,se;
            for(auto p:po[yid]){
                if(opo[p.oid].x<opo[v].x){
                    se.push_back(p.oid);
                }else if(opo[v].x<opo[p.oid].x&&opo[p.oid].x<opo[it].x){
                    fi.push_back(p.oid);
                }
            }
            reverse(fi.begin(),fi.end());
            appd(smem,fi);
            appd(smem,se);
        }else if(opo[it].x<opo[v].x){
            vector<int> fi,se;
            for(auto p:po[yid]){
                if(opo[it].x<opo[p.oid].x&&opo[p.oid].x<opo[v].x){
                    fi.push_back(p.oid);
                }else if(opo[v].x<opo[p.oid].x){
                    se.push_back(p.oid);
                }
            }
            reverse(se.begin(),se.end());
            appd(smem,fi);
            appd(smem,se);
        }
        setmem(v,true);
    }else{
        int v=cprv[it].front();
        setmem(v,false);
    }
    return ;
}
bool vis[MAXN+5][2]={};
void build(int it,bool isf){
    if(vis[it][isf]) return ;
    vis[it][isf]=true;
    if(!isf){
        for(int v:tprv[it]) build(v,true);
    }else{
        for(int v:cprv[it]){
            if(oin[it]==0) inout(oin[it],oout[it]);
            if(oin[v]==0) inout(oin[v],oout[v]);
            int in,out;
            inout(in,out);
            con(oout[v],in,INFi);
            con(out,oin[it],INFi);
            build(v,false);
        }
    }
    return ;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    fill(xprv,xprv+MAXN+5,prv_t{-1,-INFi});
    fill(sprv,sprv+MAXN+5,prv_t{-1,-INFi});
    fill(dprv,dprv+MAXN+5,prv_t{-1,-INFi});
    cin>>N;
    xre.ins(0);
    sre.ins(0);
    dre.ins(0);
    for(int i=1;i<=N;i++){
        cin>>opo[i].x>>opo[i].y;
        yre.ins(opo[i].y);
        xre.ins(opo[i].x);
        sre.ins(opo[i].x+opo[i].y);
        dre.ins(opo[i].y-opo[i].x);
    }
    yre.uni();
    xre.uni();
    sre.uni();
    dre.uni();
    for(int i=1;i<=N;i++){
        po[yre.getid(opo[i].y)].push_back({
            i,
            xre.getid(opo[i].x),
            sre.getid(opo[i].x+opo[i].y),
            dre.getid(opo[i].y-opo[i].x),
            -INFi,
            -INFi
        });
    }
    for(int yid=1;yid<=yre.cnt;yid++)
        sort(po[yid].begin(),po[yid].end(),po_cmp);
    xprv[xre.getid(0)]={0,0};
    sprv[sre.getid(0)]={0,0};
    dprv[dre.getid(0)]={0,0};
    for(int yid=1;yid<=yre.cnt;yid++){
        for(auto &p:po[yid]){
            upd(p.f,cprv[p.oid],xprv[p.xid].g+1,xprv[p.xid].oid);
            upd(p.f,cprv[p.oid],sprv[p.sid].g+1,sprv[p.sid].oid);
            upd(p.f,cprv[p.oid],dprv[p.did].g+1,dprv[p.did].oid);
            upd(p.g,tprv[p.oid],p.f,p.oid);
        }
        for(int i=0;i<po[yid].size();i++){
            auto &up=po[yid][i];
            for(int j=0;j<po[yid].size();j++){
                auto &np=po[yid][j];
                if(j<i){
                    upd(up.g,tprv[up.oid],np.f+i,np.oid);
                }else if(i<j){
                    upd(up.g,tprv[up.oid],np.f-i-1+po[yid].size(),np.oid);
                }
            }
            tomax(maxdis,up.g);
        }
        for(auto &p:po[yid]){
            xprv[p.xid]={p.oid,p.g};
            sprv[p.sid]={p.oid,p.g};
            dprv[p.did]={p.oid,p.g};
        }
    }
    cout<<maxdis<<'\n';
    for(int yid=1,ok=0;yid<=yre.cnt;yid++){
        for(auto p:po[yid]){
            if(p.g==maxdis){
                setmem(p.oid,false);
                ok=1;
                break;
            }
        }
        if(ok==1) break;
    }
    reverse(smem.begin(),smem.end());
    for(int v:smem) cout<<v<<' ';
    cout<<'\n';
    for(int yid=1;yid<=yre.cnt;yid++){
        for(auto p:po[yid]){
            if(p.g==maxdis){
                build(p.oid,false);
            }
        }
    }
    int chang=zhen;
    while(bfs()){
        fill(cur,cur+ncnt+1,0);
        chang-=dfs(fS,INFi);
    }
    cout<<chang<<'\n';
    return 0;
}

```

---

## 作者：Basori_Tiara (赞：0)

城里送回乡下过暑假的小园丁开大车。

先来解决问题第一问，找最长路。

这个比较 sb，考虑这个东西按照纵坐标排序之后，整张图形成一个 DAG，在这个上面拓扑排序然后 dp 就可以了。

然后是第二问，就是我们把所有可能成为最长路的一部分的不是横着的车辙全部拿出来，然后问需要几条路径可以覆盖所有这样的车辙。

这个东西你考虑直接用有源汇上下界最小流就可以了。

考虑一点流量的意义就是车来碾了一遍，每一条必须走的车辙都是上下界为 $[1,\inf]$ 表示着这条边必须被车碾一遍。

然后源点连一下入度为 $0$ 的点，流量为 $[0,\inf]$，因为从这些点出发一定是更优的。

出度为 $0$ 的点再连一下汇点，流量为 $[0,\inf]$，因为在这些点结束一定是更优的。

然后跑有源汇上下界最小流就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int> rnk;
map<int,int> mp1,mp2,mp3;
int n;
struct node{
   int x,y,id;
}A[50005];
bool cmp(node a,node b){
   return a.y<b.y||a.y==b.y&&a.x<b.x;
}
int pos;
vector<int> Needx[50005];
int val[50005];
bool can[50005];
int dp[50005],F[50005];
vector<int> premid[50005];
int predown[50005];
vector<int> ljb[50005],bjl[50005];
void print(int now){
   if(now==1)return;;
   int L=premid[now][0];
   print(predown[Needx[rnk[A[now].y]][L]]);
   int need;
   int siz=Needx[rnk[A[now].y]].size();
   for(int i=0;i<siz;i++){
      int idx=Needx[rnk[A[now].y]][i];
      if(idx==now){
         need=i;
         break;
      }
   }
   if(L<need){
      for(int i=L;i>=0;i--){
         printf("%d ",A[Needx[rnk[A[now].y]][i]].id);
      }
      for(int i=L+1;i<need;i++){
         printf("%d ",A[Needx[rnk[A[now].y]][i]].id);
      }
   }
   if(L>need){
      for(int i=L;i<siz;i++){
         printf("%d ",A[Needx[rnk[A[now].y]][i]].id);
      }
      for(int i=L-1;i>need;i--){
         printf("%d ",A[Needx[rnk[A[now].y]][i]].id);
      }
   }
   printf("%d ",A[now].id);
   return;
}
struct edge{
   int u,v,L,R;
}E[500005],dinner[500005];
int rd[50005],cd[50005];




class LTDZ{
	public:
	int dep[1000005];
	int E[1000005];
	int nxt[1000005];
	int head[1000005];
	int flow[1000005];
	bool in[1000005];
	int pos[1000005];
	int cnt=1;
	int s,t,n;
	void addedge(int u,int v,int fl){
		cnt++;
		E[cnt]=v;
		flow[cnt]=fl;
		nxt[cnt]=head[u];
		head[u]=cnt;
		return;
	}
	void Add(int u,int v,int fl){
		addedge(u,v,fl);
		addedge(v,u,0);
		return;
	}
	bool SPFA(){
		queue<int> q;
		q.push(s);
		for(int i=1;i<=n;i++){
			dep[i]=1e8;
		}
		dep[s]=0;
		in[s]=true;
		while(!q.empty()){
			int t=q.front();
			q.pop();
			in[t]=false;
			for(int i=head[t];i;i=nxt[i]){
				int v=E[i];
				int fl=flow[i];
				if(fl&&dep[t]+1<dep[v]){
					dep[v]=dep[t]+1;
					if(!in[v]){
						q.push(v);
						in[v]=true;
					}
				}
			}
		}
		return dep[t]<100000000;
	}
	bool vis[1000005];
	int ansflow,anscost;
	int dfs(int cur,int mini,int Pre){
		vis[cur]=true;
		if(cur==t){
			ansflow+=mini;
			return mini;
		}
		int fl=0;
		for(int i=pos[cur];i;i=nxt[i]){
			pos[cur]=i;
			if(i==Pre)continue;
			int v=E[i];
			int F=flow[i];
			if(F&&dep[cur]+1==dep[v]&&(v==t||!vis[v])){
				int tmp=dfs(v,min(mini-fl,F),i^1);
				if(tmp){
					flow[i]-=tmp;
					flow[i^1]+=tmp;
					fl+=tmp;
					if(fl==mini){
						break;
					}
				}
			}
		}
		vis[cur]=false;
		return fl;
	}
	void dinic(){
		while(SPFA()){
        //  exit(0);
			do{
				for(int i=1;i<=n;i++){
					vis[i]=false;
					pos[i]=head[i];
				}
				dfs(s,1e8,0);
			}while(vis[t]);
		}
		return;
	}
}G;


   int cnt=0;


int main(){
   scanf("%d",&n);
   for(int i=1;i<=n;i++){
      scanf("%d%d",&A[i].x,&A[i].y);
      A[i].id=i;
   }
   A[++n]=node{0,0,0};
   sort(A+1,A+1+n,cmp);
   A[0].y=-1;
   for(int i=1;i<=n;i++){
      if(A[i].y!=A[i-1].y)rnk[A[i].y]=++pos,val[pos]=A[i].y;
      Needx[pos].push_back(i);
   }
   for(int i=n;i>=1;i--){
      int lst=mp1[A[i].x];
      if(lst){
         ljb[i].push_back(lst);
         bjl[lst].push_back(i);
      }
      mp1[A[i].x]=i;
      lst=mp2[A[i].x-A[i].y];
      if(lst){
         ljb[i].push_back(lst);
         bjl[lst].push_back(i);
      }
      mp2[A[i].x-A[i].y]=i;
      lst=mp3[A[i].x+A[i].y];
      if(lst){
         ljb[i].push_back(lst);
         bjl[lst].push_back(i);
      }
      mp3[A[i].x+A[i].y]=i;
   }
   can[1]=true;
   dp[1]=1;
   // puts("");
   for(int i=1;i<=pos;i++){
      int siz=Needx[i].size();
      for(int j=0;j<siz;j++){
         int idx=Needx[i][j];
         for(int k=0;k<bjl[idx].size();k++){
            int v=bjl[idx][k];
            if(dp[v]+1==dp[idx]){
               E[++cnt]=edge{v,idx,1,100000000};
            }
         }
      }
      for(int j=0;j<siz;j++){
         int idx=Needx[i][j];
         F[idx]=max(F[idx],dp[idx]);
         premid[idx].push_back(j);
      }
      bool tag=false;
      for(int j=0;j<siz;j++){
         int idx=Needx[i][j];
         if(!can[idx])continue;
         tag=true;
         for(int k=0;k<j;k++){
            int idy=Needx[i][k];
            int tmp=dp[idx]+siz-k-1;
            if(F[idy]<tmp){
               F[idy]=tmp;
               premid[idy].clear();
            }
            if(F[idy]==tmp){
               premid[idy].push_back(j);
            }
         }
         for(int k=j+1;k<siz;k++){
            int idy=Needx[i][k];
            int tmp=dp[idx]+k;
            if(F[idy]<tmp){
               F[idy]=tmp;
               premid[idy].clear();
            }
            if(F[idy]==tmp){
               premid[idy].push_back(j);
            }
         }
      }
      if(!tag)continue;
      for(int j=0;j<siz;j++){
         int idx=Needx[i][j];
         dp[idx]=F[idx];
         for(int k=0;k<ljb[idx].size();k++){
            int v=ljb[idx][k];
            can[v]=true;
            if(dp[idx]+1>dp[v]){
               dp[v]=dp[idx]+1;
               predown[v]=idx;
            }
         }
      }
   }
   ;
   int ans=0,id=0;
   for(int i=1;i<=n;i++){
      if(dp[i]>ans){
         ans=dp[i];
         id=i;
      }
   }
   printf("%d\n",ans-1);
   print(id);
   puts("");
   memset(can,false,sizeof(can));
   for(int i=1;i<=n;i++){
      if(dp[i]==ans){
         for(int j=0;j<premid[i].size();j++){
            can[Needx[rnk[A[i].y]][premid[i][j]]]=true;
         }
      }
   }
   for(int i=cnt;i>=1;i--){
      int u=E[i].u,v=E[i].v;
      if(can[v]){
         for(int j=0;j<premid[u].size();j++){
            int v=premid[u][j];
            can[Needx[rnk[A[u].y]][v]]=true;
         }
      }
      else{
         E[i].L=0;
      }
   }
   for(int i=1;i<=cnt;i++){
      int u=E[i].u,v=E[i].v,f=E[i].L;
      rd[v]+=f,cd[u]+=f;
   }
   G.s=n+3,G.t=n+4;
   G.n=G.t;
   G.Add(n+2,n+1,1e8);
   for(int i=1;i<=n;i++){
      if(rd[i]>cd[i]){
         G.Add(G.s,i,rd[i]-cd[i]);
      }
      else{
         G.Add(i,G.t,cd[i]-rd[i]);
      }
   }
   for(int i=1;i<=cnt;i++){
      int u=E[i].u;
      int v=E[i].v;
      int fl=E[i].R-E[i].L;
      if(!E[i].L)continue;
      G.Add(u,v,fl);
   }
   for(int i=1;i<=n;i++)rd[i]=cd[i]=0;
   for(int i=1;i<=cnt;i++){
      int u=E[i].u,v=E[i].v;
      cd[u]++,rd[v]++;
   }
   for(int i=1;i<=n;i++){
      G.Add(i,n+2,1e8);
      G.Add(n+1,i,1e8);
   }
   G.dinic();
   ans=G.flow[3];
   for(int i=1;i<=n+1;i++){
      int now=2*(i);
      G.flow[now]=G.flow[now^1]=0;
   }
   G.n=n+2;
   G.s=n+2,G.t=n+1;
   G.ansflow=0;
   G.dinic();
   printf("%d\n",ans-G.ansflow);
   return 0;
   return 0;
}
```

---


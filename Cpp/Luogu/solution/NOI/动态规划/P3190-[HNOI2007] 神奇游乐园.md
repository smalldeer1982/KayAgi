# [HNOI2007] 神奇游乐园

## 题目描述

经历了一段艰辛的旅程后，主人公小 P 乘坐飞艇返回。在返回的途中，小 P 发现在漫无边际的沙漠中，有一块狭长的绿地特别显眼。往下仔细一看，才发现这是一个游乐场，专为旅途中疲惫的人设计。

娱乐场可以看成是一块大小为 $n\times m$ 的区域，且这个 $n\times m$ 的区域被分成 $n\times m$ 个小格子，每个小格子中就有一个娱乐项目。

然而，小 P 并不喜欢其中的所有娱乐项目，于是，他给每个项目一个满意度。满意度为正时表示小 P 喜欢这个项目，值越大表示越喜欢。为负时表示他不喜欢，这个负数的绝对值越大表示他越不喜欢。为 $0$ 时表示他对这个项目没有喜恶。

小 P 决定将飞艇停在某个小格中，然后每步他可以移动到相邻的上下左右四个格子的某个格子中。

小 P 希望找一条路径，从飞艇所在格出发，最后又回到这个格子。

小 P 有一个习惯，从不喜欢浪费时间。因此，他希望经过每个格子都是有意义的：他到一个地方后，就一定要感受以下那里的惊险和刺激，不管自己是不是喜欢那里的娱乐项目。而且，除了飞艇所在格，其他的格子他不愿意经过两次。小 P 希望自己至少要经过四个格子。

在满足这些条件的情况下，小 P 希望自己玩过的娱乐项目的满意度之和最高。你能帮他找到这个最高的满意度之和吗？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\leq n\leq 100$，$2\leq m\leq 6$，$-10^3\leq a_{i,j}\leq 10^3$。

## 样例 #1

### 输入

```
4 4
100 300 -400 400
-100 1000 1000 1000
-100 -100 -100 -100
-100 -100 -100 1000```

### 输出

```
4000```

# 题解

## 作者：Orion545 (赞：14)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8629572.html)

内有多篇插头dp题解，可配合使用，口感更佳orz

# 思路：

[没学过插头dp的可以看这里](http://www.cnblogs.com/dedicatus545/p/8638869.html)

先理解一下题意：实际上就是要你求这个棋盘总权值最大的一个回路

看到这个数据范围，还有回路处理，就想到使用插头dp来做了

观察一下发现，这道题因为都是回路，所以联通块上方的插头一定两两配对，可以使用括号序列代替最小表示法

分情况讨论一下

 

情况一：当前格子上方和左方都没有插头

这种时候可以继续，也可以给当前格子加一个下插头一个右插头，相当于一个新的联通分量

 

情况二：上方有一个下插头，左边没有

这时有两个决策：可以向右转，也可以继续向下，操作就是分别给这个格子一个右插头或者一个下插头

注意此时新插头的括号类型和原来的那个插头相同（画个图可以理解一下）

情况三：左边有一个右插头，上面没有

同情况二，转弯或者直走

 

情况四：都有插头，而且两个插头是同一括号

这种情况，我们可以将这两个插头合并，在当前格子把这条路径封闭了

但是这里需要考虑一下其他的插头

我们去掉了两个相同的括号，就需要把另外一个括号反过来配对才行

比如当前的括号序列是 ((##()#(##**))**##)，加粗的是我们要合并的两个括号，那么这两个)变成#以后，它们原来匹配的左括号(就失配了，需要其中一个（右边的那个）左括号变成右括号，两个重新配对

也就是((##()#(**))**##)变成((##()#(**##**##)变成((##()#**)**####)

当然也可以画个图理解一下，两条路径相当于是绕了圈接起来了

这个操作需要扫一遍整个序列，是$O\left(n\right)$的，当然也可以预处理变成$O\left(1\right)$

 

情况五：都有插头，且两个是)(

这时候直接合并就好了

情况六：都有插头，而且两个是()

这种时候，只有在整个轮廓线上只剩下这两个插头时才能合并，路径完全封闭，得到了一个答案

 

状态数略多，可以滚动数组+哈希处理

分类讨论的时候注意可不可以这么做（需要判断下一个格子是否为障碍）

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define hash deep_dark_fantasy
#define inf 1e9
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,m,x[150][150],cur,pre,ex,ey;
int st[2][300010];ll ans[2][300010],re;
int tot[2],bit[20],state[300010],st_tot,hash=300000;
struct edge{
    int to,next;
}a[300010];
void insert(int sta,ll val){//往哈希表里插入一个状态，顺便更新答案
    int p=sta%hash,i;
    for(i=state[p];i;i=a[i].next){
        if(st[cur][a[i].to]==sta){
            ans[cur][a[i].to]=max(ans[cur][a[i].to],val);return;
        }
    }
    tot[cur]++;
    a[++st_tot].to=tot[cur];
    a[st_tot].next=state[p];
    state[p]=st_tot;st[cur][tot[cur]]=sta;ans[cur][tot[cur]]=val;
}
void dp(){
    int i,j,k,l,now,down,right;ll val;re=-inf;
    cur=0;tot[cur]=1;ans[cur][1]=0;st[cur][1]=0;
    for(i=1;i<=n;i++){
        for(j=1;j<=tot[cur];j++) st[cur][j]<<=2;
        for(j=1;j<=m;j++){
            pre=cur;cur^=1;tot[cur]=0;st_tot=0;memset(state,0,sizeof(state));
            for(k=1;k<=tot[pre];k++){
                now=st[pre][k];val=ans[pre][k];
                right=(now>>bit[j-1])%4;down=(now>>bit[j])%4;
                if(!down&&!right){//新建联通分量，加一个下插头一个右插头
                    insert(now,val);
                    if(j!=m) 
                        insert(now+(1<<bit[j-1])+((1<<bit[j])<<1),val+x[i][j]);
                }
                if(down&&!right){//延续下插头
                    insert(now-down*(1<<bit[j])+down*(1<<bit[j-1]),val+x[i][j]);
                    if(j!=m)insert(now,val+x[i][j]);
                }
                if(right&&!down){//延续右插头
                    insert(now,val+x[i][j]);
                    if(j!=m) 
                        insert(now+right*(1<<bit[j])-right*(1<<bit[j-1]),val+x[i][j]);
                }
                if(right==1&&down==1){//合并两个左括号
                    int cnt=1;
                    for(l=j+1;l<=m;l++){
                        if((now>>bit[l])%4==1) cnt++;
                        if((now>>bit[l])%4==2) cnt--;
                        if(!cnt){
                            insert(now-(1<<bit[l])-(1<<bit[j])-(1<<bit[j-1]),val+x[i][j]);
                            break;
                        }
                    }
                }
                if(right==2&&down==2){//合并两个右括号
                    int cnt=1;
                    for(l=j-2;l>=0;l--){
                        if((now>>bit[l])%4==1) cnt--;
                        if((now>>bit[l])%4==2) cnt++;
                        if(!cnt){
                            insert(now+(1<<bit[l])-((1<<bit[j])<<1)-((1<<bit[j-1])<<1),val+x[i][j]);
                            break;
                        }
                    }
                }
                if(right==2&&down==1){//合并)(
                    insert(now-((1<<bit[j-1])<<1)-(1<<bit[j]),val+x[i][j]);
                }
                if(right==1&&down==2){//合并()，统计答案
                    if((now==(1<<bit[j-1])+((1<<bit[j])<<1))&&(val+x[i][j]>re)){
                        re=val+x[i][j];
                    }
                }
            }
        }
    }
}
int main(){
    int i,j;
    n=read();m=read();
    for(i=1;i<=10;i++) bit[i]=(i<<1);
    for(i=1;i<=n;i++) for(j=1;j<=m;j++) x[i][j]=read();
    dp();
    printf("%lld",re);
}
```

---

## 作者：aaaaaaaawsl (赞：6)

upd 2022/11/12: 重新梳理了一遍插头 DP，改了一些错误的描述，补充下我没讲清的东西。

--------

没做过插头 DP 的人，建议先去做
 [P5074](https://www.luogu.com.cn/problem/P5074)。 （不需要括号序列，只需判断插头间联通。）
 
其次再做一下 [ P5065 ](PPttps://www.luogu.com.cn/problem/P5056) 。（模板题，正常插头 DP ，学会了这道模板题的写法大部分插头 DP 的题只需再细节上略加改动，比如此道题。）

---------- 

### 题目大意：

给定 $n \times m$ 的网格图，每格内有一个权值，求一个任意不交叉回路使取得权值最大。

------------


这里做完上两道题的人应该很明了了，就是模板的变版。所以就不详细谈基础知识了，只说一下不同的点。

- 模板求的是方案数，所以取出上一个阶段的方案数，转移的时候求和。这道题在转移的时候应该传入当前经过更改的权值，在更新 val 的时候取 max。

- 不要求全部联通，所以在转移的时候只需要判断是否越界即可。
    
- 对于题目所要求的联通，我们在原题的时候是在最后考虑，所以不需要考虑除了当前合并的两个连通块是否有其他的连通块，这题是转移中更新答案，所以要考虑时候可能有其他的连通块。

--------------

下面是代码，注释应该很明白。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long

using namespace std;

const int Mod = 299987;
const int N = 14;
const int M = 2 << 16;

int n, m, ans;
int a[101][N];
char s;
int que[2][M], val[2][M]; // que是当前状态/上一状态, val是状态所代表的价值。
int tw[N], cnt[2]; // tw是预处理的四进制数字，cnt为当前阶段可行的状态数。
int ei, ej;
int now;
int last, num;

int Next[M], head[300000];
void Zip(int bit, int num){// hash 压缩和连边  bit为当前状态，num要更新的值.
	long long u = bit % Mod + 1;// 取head 
	for(int i = head[u]; i; i = Next[i]){// 当前状态属于u集合
		if(que[now][i] == bit){ // 找到了
			if(val[now][i] < num) val[now][i] = num; // 更新
			return;
		}
	}// 没有return就说明是新的点，建新边并且赋值 
	Next[++ cnt[now]] = head[u];
	head[u] = cnt[now];
	que[now][cnt[now]] = bit;
	val[now][cnt[now]] = num;
}

bool check(int k, int j, int x, int y){
	return (k == (x * (1 << (j - 1) * 2) + y * (1 << (j * 2)))); // 判断是否只有一个连通块
}

void dp(){
	cnt[now] = 1;
	val[now][1] = 0;
	que[now][1] = 0;
	for(int i = 1; i <= n; ++ i){// 逐行转移
		for(int j = 1; j <= cnt[now]; ++ j) que[now][j] <<= 2;/*
		que是个队列，装的是上一步转移后的合法状态，由于我们是>>取插头，同时
		由上一条轮廓线的末状态（每个状态是进行一次转移的来的，可以看作剩下的部分不转移而直接到末状态）转移到这一条轮廓线的初状态，画图
		得知，上一个状态的最后一个插头一定不会有（不可能指向格外），这一个状态的第一个插头肯定不会存在(不可能由格外指进来)，即上一个状态
		一定是 00(最后一格储存在最高位） …… （两个二进制表示一个三进制数) 下一个状态还没开始转移的时候一定是  ……00 （第一格储存在第一位 
		这两个省略号表达的是相同的 ，因为还没发生转移。所以我们发现，由上一个转移的结束状态转为这个转移的初始状态，只需要 << 2
		*/ 
		for(int j = 1; j <= m; ++ j){  // 逐格枚举
			memset(head, 0, sizeof head);
			last = now; now ^= 1;// 滚动数组 
			cnt[now] = 0; 
			for(int k = 1; k <= cnt[last]; ++ k){
				int bit = que[last][k], num = val[last][k] + a[i][j];// last阶段第k个状态， last阶段第k个状态对应的值 
				int b1 = (bit >> ((j - 1) * 2)) % 4, b2 = (bit >> (j * 2)) % 4;// 二进制表示四进制存储，位数*2，所以左移的位数*2 
				if(!b1 && !b2){
					Zip(bit, num - a[i][j]); // 不选 
					if(i != n && j != m) Zip(bit + tw[j - 1] + tw[j] * 2, num); //不越界，选
				}
				else if(!b1 && b2) { // 下同
					if(j != m) Zip(bit, num);
					if(i != n) Zip(bit - tw[j] * b2 + tw[j - 1] * b2, num);
				}
				else if(b1 && !b2){
					if(i != n) Zip(bit, num);
					if(j != m) Zip(bit - tw[j - 1] * b1 + tw[j] * b1, num);
				} 
				else if(b1 == 1 && b2 == 1){ // 两个左括号
					int flag = 1;
					for(int l = j + 1; l <= m; ++ l){
						if((bit >> (l * 2)) % 4 == 1) flag ++;
						if((bit >> (l * 2)) % 4 == 2) flag --;
						if(!flag){ // 找最左的右括号
							Zip(bit - tw[j] - tw[j - 1] - tw[l], num);
							break;
						}
					}
				}
				else if(b1 == 2 && b2 == 2){
					int flag = 1;
					for(int l = j - 2; l >= 0; -- l){
						if((bit >> (l * 2)) % 4 == 1) flag --;
						if((bit >> (l * 2)) % 4 == 2) flag ++;
						if(!flag){
							Zip(bit - tw[j] * 2 - tw[j - 1] * 2 + tw[l], num);
							break; 
						}
					}
				}
				else{
					if(b1 == 2 && b2 == 1) Zip(bit - tw[j - 1] * 2 - tw[j], num);
					/*要合并连通块了*/else if(ans <= num && check(bit, j, b1, b2)) ans = num;
				}
			}
		}
	}
}

signed main(){
	scanf("%lld%lld", &n, &m);
	for(int i = 1; i <= n; ++ i)
		for(int j = 1; j <= m; ++ j){
			scanf("%lld", &a[i][j]); 
		}
	tw[0] = 1; 
	for(int i = 1; i <= 9; ++ i) tw[i] = tw[i - 1] << 2;
	ans = -(n * m) * 10001; // 初始化
	dp();
	printf("%lld\n", ans);
	return 0;
}
```


------------

最后浅谈下知识点和我学习插头 DP 时疑惑的点 ：

	1. 状态维护的是在轮廓线上的对于轮廓线对应的方格的决策。状态实际是二进制，但是每两位一考虑，就是所谓的四进制。两位二进制能表达0 1 2 3，用两位二进制表示一个插头。

	2. 关于括号的含义是当前轮廓线仅上方的联通的线与轮廓线的相交状况，因为括号的匹配可以区分不同的连通块。

	3. 转移的时候更新的是决策完的状态而不是普通 DP 的那种原本的状态不变。

	4. 状态转移的时候记得想象原图，对于是否增加新括号和删除某些括号很有帮助 （背下来更好）。
    
    5.对于大多数题解或博客里画的图，通常会画出一种合法方案，再画轮廓线，但是不容易理解状态之间的转移，所以我们无视轮廓线下方的图，把它当作未知的皆有可能的，可能会更好理解插头之间的变化。


---

## 作者：LittleMoMol (赞：4)

[欢迎博客食用！](https://www.cnblogs.com/LittleMoMol-kawayi/p/solution_LuoGu_P3190.html)

---
首先不难发现，这是一道插头 DP 题，因为做到这道题的神犇应该对插头 DP 有所了解，那么我就简单总结一下插头 DP 的大致内容。

对于每一行我们用**四进制**表示其状态，因为四进制方便些。我们对于每一个方块维护一个数 $num \in \{0,1,2\}$，其中 $0$ 表示这个块之前没有插头指向它；对于有插头指向的方块，因为最终是个环，所以对于每一行被线穿过的次数必定为偶数（上去了必定要下来），所以我们维护指向该方块的插头是左边的还是右边的，所以有下面 $7$ 种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/ahue73if.png)

接下来我们一个一个地思考对应转移方程，直接上图吧

先来看前三种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/qcid85yo.png)

再来看 4、5 两种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/7ndlbnqf.png)

再看第 6 种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/bul6ae6r.png)

最后看第 7 种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/zj92s35y.png)

你会发现第 7 种情况你只能封口（感性理解），此时一个环已经形成，对答案进行更新。

代码如下

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 600, M = 107, INF = 0x3f3f3f3f;

int n, m;
int maze[110][10], q[2][N], cnt[2];
int h[2][M], v[2][M];

int find_pos(int cur, int x)
{
	int t = x % M;
	while (h[cur][t] != -1 && h[cur][t] != x)
		if ( ++ t == M) t = 0;
	return t;
}

int get(int state, int k)
{
	return (state >> (k * 2)) & 3;
}

int stt(int k, int v)
{
	return v * (1 << (k * 2));
}

void add(int cur, int state, int w)
{
	int t = find_pos(cur, state);
	if (h[cur][t] == -1)
	{
		h[cur][t] = state;
		v[cur][t] = w;
		q[cur][ ++ cnt[cur]] = t;
	}
	else v[cur][t] = max(v[cur][t], w);
	return;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= m; j ++ )
			cin >> maze[i][j];
	
	int ans = -INF;
	memset(h, -1, sizeof h);
	int cur = 0;
	add(cur, 0, 0);
	for (int i = 1; i <= n; i ++ )
	{
		for (int j = 1; j <= cnt[cur]; j ++ )
			h[cur][q[cur][j]] <<= 2;
		for (int j = 1; j <= m; j ++ )
		{
			int lst = cur;
			cur ^= 1, cnt[cur] = 0;
			memset(h[cur], -1, sizeof h[cur]);
			for (int k = 1; k <= cnt[lst]; k ++ )
			{
				int state = h[lst][q[lst][k]];
				int w = v[lst][q[lst][k]];
				int x = get(state, j - 1);
				int y = get(state, j);
				if (!x && !y)
				{
					add(cur, state, w);
					if(i < n && j < m) add(cur, state + stt(j - 1, 1) + stt(j, 2), w + maze[i][j]);
				}
				else if (!x && y)
				{
					if (i < n) add(cur, state - stt(j, y) + stt(j - 1, y), w + maze[i][j]);
					if (j < m) add(cur, state, w + maze[i][j]);
				}
				else if (x && !y)
				{
					if (i < n) add(cur, state, w + maze[i][j]);
					if (j < m) add(cur, state - stt(j - 1, x) + stt(j, x), w + maze[i][j]);
				}
				else if (x == 1 && y == 1)
				{
					for (int u = j + 1, s = 1; ; u ++ )
					{
						int z = get(state, u);
						if (z == 1) s ++ ;
						else if (z == 2) s -- ;
						if (s == 0)
						{
							add(cur, state - stt(j - 1, x) - stt(j, y) - stt(u, 1), w + maze[i][j]);
							break;
						}
					}
				}
				else if (x == 2 && y == 2)
				{
					for (int u = j - 2, s = 1; ; u -- )
					{
						int z = get(state, u);
						if (z == 2) s ++ ;
						else if (z == 1) s -- ;
						if (s == 0)
						{
							add(cur, state - stt(j - 1, x) - stt(j, y) + stt(u, 1), w + maze[i][j]);
							break;
						}
					}
				}
				else if (x == 2 && y == 1)
				{
					add(cur, state - stt(j - 1, x) - stt(j, y), w + maze[i][j]);
				}
				else if (x == 1 && y == 2)
				{
					if (state == stt(j - 1, x) + stt(j, y))
						ans = max(ans, w + maze[i][j]);
				}
			}
		}
	}
	
	cout << ans << endl;
	
	return 0;
}
```

---

## 作者：maomao9173 (赞：3)

### 最小表示法。

虽然比括号序列慢一点，但是真的很好理解，也不容易写错。

（没有$1A$是因为$i$和$j$写反了$QwQ$

> 最小表示法是什么呢？举个例子，现在有这样一个序列(5,5,3,2,4,1,3,2)，序列中的每一个数代表第i个格子所属的连通分量。因为编号是人为设置的，所以其每一个编号也可以一一映射成等效的其他编号。为了连通性表示的规范和不重不漏，我们就把这个序列整理成意义等效的前提下字典序最小的形式，对这个序列就是(1,1,2,3,4,5,2,3)。

在这个题目中同理。我们整理每一个连通分量，对格子考虑连通方式（应该没什么难度吧？）。

设当前格子左边轮廓线为$b_1$，右边轮廓线为$b_2$。

- $b1 = b2 = 0$ ：
	
    - 这个格子可以没有插头。
    
    - 也可以新建连通分量，向下向右连接。
    
- $b1$ 和 $b2$一个为 $0$ 一个非 $0$：
	
    - 可以向左连或者向下连。
    
- $b1 != b2$ 且二者均不为 $0$

	- 合并两个连通分量，把其中一个全都改为另一个。
    
- $b1 = b2$ 且二者均不为 $0$

	- 即终态，记录答案，不做转移。
    
$Code$：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100 + 5;
const int base = 999983;
const int M = 1000000 + 5;
const int INF = 0x7fffffff;

int n, m, ans = -INF, w[N][N], in[N][N]; 

int las, cur, cnt[2], nxt[M];

int head[M], dp[2][M], Hash[2][M];

int get_wei (int zt, int wei) {
	return (zt >> (wei * 3)) % 8;
}

int alt_wei (int zt, int wei, int val) {
	return zt - ((get_wei (zt, wei) - val) << (wei * 3));
}

void cmax (int &x, int y) {x = max (x, y);}

void min_express (int &zt) {
	int tot = 0, bel[10] = {0};
	for (int i = 0; i <= m; ++i) {
		int now = get_wei (zt, i);
		if (now == 0) continue;
		if (bel[now]) {
			zt = alt_wei (zt, i, bel[now]);
		} else {
			zt = alt_wei (zt, i, bel[now] = ++tot);
		}
	}
}

bool one_block (int zt) {
	min_express (zt);
	for (int i = 0; i <= m; ++i) {
		if (get_wei (zt, i) > 1) {
			return false;
		}	
	}
	return true;
}

void update (int zt, int val) {
	min_express (zt); 
	int _zt = zt % base;
	for (int i = head[_zt]; i; i = nxt[i]) {
		if (Hash[cur][i] == zt) {
			cmax (dp[cur][i], val); return;
		}
	}
	nxt[++cnt[cur]] = head[_zt];
	head[_zt] = cnt[cur];
	Hash[cur][cnt[cur]] = zt;
	dp[cur][cnt[cur]] = val;
}	

int solve () {
	update (0, 0);
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= cnt[cur]; ++j) {
			Hash[cur][j] <<= 3;
		}
		for (int j = 1; j <= m; ++j) {
			las = cur, cur ^= 1, cnt[cur] = 0;
			memset (head, 0, sizeof (head));
			for (int k = 1; k <= cnt[las]; ++k) {
				int zt = Hash[las][k];
				int b1 = get_wei (zt, j - 1);
				int b2 = get_wei (zt, j - 0);
				int val = dp[las][k];
				if (b1 + b2 == 0) {
					update (zt, val); // 不选
					if (in[i][j + 1] && in[i][j + 1]) {
						int _zt = zt; // 新建连通分量设置为 7
						_zt = alt_wei (_zt, j - 1, 7); 
						_zt = alt_wei (_zt, j - 0, 7);
						update (_zt, val + w[i][j]);
					} 
				}
				if (b1 != 0 && b2 == 0) {
					if (in[i][j + 1]) {
						int _zt = zt; 
						_zt = alt_wei (_zt, j - 1, 0);
						_zt = alt_wei (_zt, j - 0, b1);
						update (_zt, val + w[i][j]); 
					}
					if (in[i + 1][j]) { 
						update (zt, val + w[i][j]);
					}
				}
				if (b1 == 0 && b2 != 0) {
					if (in[i + 1][j]) {
						int _zt = zt;
						_zt = alt_wei (_zt, j - 1, b2);
						_zt = alt_wei (_zt, j - 0, 0);
						update (_zt, val + w[i][j]);
					}
					if (in[i][j + 1]) {
						update (zt, val + w[i][j]);
					}
				}
				if (b1 && b2 && b1 != b2) {
					int _zt = zt;
					_zt = alt_wei (_zt, j - 1, 0);
					_zt = alt_wei (_zt, j - 0, 0);
					for (int t = 0; t <= m; ++t) {
						if (get_wei (_zt, t) == b2) {
							_zt = alt_wei (_zt, t, b1);
						}
					}
					update (_zt, val + w[i][j]);
				} 
				if (b1 && b2 && b1 == b2) {
					if (one_block (zt)) {
						ans = max (ans, val + w[i][j]);
					}
				} 
			}
		}
	}
	return ans;
}

int main () {
//	freopen ("data.in", "r", stdin);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			cin >> w[i][j];
			in[i][j] = true;
		}
	}
	cout << solve () << endl;
}
```

---

## 作者：Belarus (赞：2)

### 什么是插头DP   

插头DP通常用来解决一些奇奇怪怪的棋盘问题，比如给你一些限制条件，让你求棋盘上的一个环，或者一个特殊形状。本质上是一种状压DP，其实是状压DP的升级版。这里就拿~~学长推荐~~的毒瘤题[神奇游乐园](https://www.luogu.com.cn/problem/P3190)为例吧。

### 一些概念

#### 插头

给你一个网格图，还有一个没完成的环路，你会发现有左端点和右端点，端点可以在网格的四个边上的任意一边，我们称左端点为**左插头**或者**开插头**，类似地，称右端点为**右插头**或者**闭插头**。

#### 轮廓线

我们的DP是一格一格地进行的，完成了DP的网格和未进行DP的网格形成了一条分界线，这条分界线就是轮廓线。

如图所示：蓝色的是轮廓线，黄色的是正在进行DP的格子，绿色的是插头。

![chatou1.JPG](https://i.loli.net/2020/06/11/WpbOyShQtlDo2uC.jpg)

### 如何进行DP

#### 预处理

我们设 $f_{i,j,k}$ **表示当前处理格子为 $(i,j)$，状态为 $k$ 时最大的满意度之和**（题目要求的）。  

Q：等等，什么叫“状态为 $k$”？

A：这里，$k$ **是一个四进制数，每一位都代表着轮廓线上每一小段的状况，这一位为 $0$ 代表这一段没有插头**（就像上图的第三行第二列），**这一位为 $1$ 代表这一段有一个开插头**（就像上图的第三行第一列），**这一位为 $2$ 代表这一段有一个闭插头**（就像上图的第二行第四列）。那么，上图的状态就是 `101220` 。

Q：既然没有 $3$，那为什么不用三进制？

A：~~辣你自己写三进制位运算啊~~！用四进制的好处就是，它可以和二进制联系起来，这样就不用预处理啦！具体来说就是，假如**要取四进制下的第 $k$ 位，那就是二进制的第 $2k$ 位和第 $2k+1$ 位**。

那现在就把代码写出来吧：

```cpp
inline int get(int x,int k){//取出二进制状态 x 的第 k 位
    return (x>>(k<<1))&3;
}
```

Q：等等，这是什么鬼我看不懂啊！

A：那我解释一下：`k<<1` 意思就是 `k*2` ，那么 `x>>(k<<1)` 意思就是**状态 $x$ 的第 $2k$ 位**，又由于前面说的，要取出 $2k$ 和 $2k+1$ 位，就和 3（在二进制下是 11​）进行按位与就行了。

状压DP的一个重要步骤就是**预处理**，所以我们先预处理出所有可行的状态。

Q：什么叫可行？

A：一个状态可行，那么它必须满足以下的条件：

1. 不可能出现 3。（废话）
2. 从左往右扫，遇到一个闭插头，就必须与他**左边最近的未配对的的开插头配对**。（仔细想想为什么）
3. 所有插头都配对了。（废话）

我们用 `s[]` 数组记录插头的位置，`Map[i][j]` 表示状态 $i$ 下 $j$ 配对的插头，`sta[]` 记录合法的状态。

那么写出代码：

``` cpp
inline void prework(){
    maxk=1<<((m+1)<<1);//我知道你可能对此不理解，请看注解1
    for(int k=0;k<maxk;++k){
        bool flag=true;//flag=true 表示这种状态是合法的
        sp=0;//表示这种状态有几个开插头
        for(int j=0,cur;j<=m;++j){//从左往右扫
            cur=get(k,j);//轮廓线上这一段是什么
            if(cur==3){flag=false;break;}//合法的状态不会出现3
            if(cur==2){//这是个闭插头
                if(sp<=0){flag=false;break;}//没有可以配对的插头，状态不合法
                Map[k][j]=s[sp];//遇到一个闭插头，就必须与他左边最近的未配对的的开插头配对
                Map[k][s[sp]]=j;
                sp--;//可以配对的开插头减一
			}
            else if(cur==1)s[++sp]=j;//这是一个新的开插头
        }
        if(flag&&sp==0)sta[++cnt]=k;//合法的话记录这个状态
	}
}
```

> 注解1：`maxk=1<<((m+1)<<1)` 用数学语言表达就是 $maxk=2^{2(m+1)}=4^{m+1}$ ，表示有多少种状态；是 `m+1` 而不是 `m` 是因为轮廓线的长度是 `m+1` 而不是 `m` （因为有一个小拐弯）。

#### 递推过程

接下来是重头戏，也就是递推过程。状态转移需要分很多情况。

我们令 `cur` 为当前格上插头的状态，`last` 为当前格左插头的状态。

#### 情况一：`cur==0&&last==0`

**将当前格的下插头设为新的开插头，当前格右插头设为新的闭插头**。

#### 情况二：`cur==0||last==0`

两种方法：

1. **把插头拉到格子右边，右插头的值就是原插头的值**。
2. **把插头拉到格子下边，下面的插头的值就是原插头的值**。

#### 情况三：`cur==2&&last==1`

**一条环路结束了，更新答案**。

#### 情况四：`cur==1&&last==2`

**删去插头代表的回路**。

#### 情况五：`cur==last`

两个插头同开同闭。那么**首先清空匹配，然后重新分配**。

具体来说，如果是两个闭插头在一起，把 `last` 对应的开插头改成闭插头；如果是两个开插头在一起，把 `cur` 对应的闭插头改成开插头。

不清楚的话可以在纸上模拟一下。

#### 递推过程的代码

那么下面是递推过程的代码：

```cpp
inline void Update(int &x,int k){
    if(x<k)x=k;
}
inline void solve(){
    for(int i=1;i<=n;++i){
        for(int K=1,k;K<=cnt;++K){//对于每一种可行的状态
            k=sta[K];
            if(f[i-1][m][k]!=-inf&&get(k,m)==0)//导入上一行的扫描线：如果上一行的这个状态被更新过而且上一行这一个状态的轮廓线的这个位置并不是什么都没有
            f[i][0][k<<2]=f[i-1][m][k];
        }
        for(int j=1;j<=m;++j){
            Update(f[i][j][(1<<((j-1)<<1))|(2<<(j<<1))],a[i][j]);//初始化
            for(int K=1,k,ck,cur,last;K<=cnt;++K){
                k=sta[K];
                if(f[i][j-1][k]==-inf)continue;//非法情况
                ck=k&(~(3<<((j-1)<<1)))&(~(3<<(j<<1))); //获得下一位置状态的模板，空出 j-1 和 j 位以填写
                cur=get(k,j);last=get(k,j-1);//插头状态
                if(cur==0&&last==0){//情况一
                    Update(f[i][j][k],f[i][j-1][k]);//什么也不放
                    Update(f[i][j][ck|(1<<((j-1)<<1))|(2<<(j<<1))],f[i][j-1][k]+a[i][j]);//在 j-1 和 j 插入 1 和 2，代表将当前格的下插头设为新的开插头，当前格右插头设为新的闭插头
                }
                else if(cur==0||last==0){//情况二
                    int t=max(cur,last);//选出不为空的
                    //接下来两种方法
                    Update(f[i][j][ck|(t<<((j-1)<<1))],f[i][j-1][k]+a[i][j]);
                    Update(f[i][j][ck|(t<<(j<<1))],f[i][j-1][k]+a[i][j]);
                }
                else if(cur==2&&last==1){//情况三
                    if(!ck)//如果确实是个回路
                     Update(res,f[i][j-1][k]+a[i][j]);//更新答案
                }
                else if(cur==1&&last==2){
                    Update(f[i][j][ck],f[i][j-1][k]+a[i][j]);//删去这两个插头代表的回路
                }
                else if(cur==last){
                    int t=ck&(~(3<<(Map[k][j-1]<<1)))&(~(3<<(Map[k][j]<<1)));//清空匹配
                    t=t|(1<<(Map[k][j]<<1))|(2<<(Map[k][j-1]<<1));//重新匹配
                    Update(f[i][j][t],f[i][j-1][k]+a[i][j]);
                }
            }
        }
    }
    cout<<res<<endl;
}
```

### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=110;
const int maxm=20;
const int maxs=(1<<14);
const int inf=1e9;
int f[maxn][maxm][maxs],a[maxn][maxm];
int Map[maxs][maxm],sta[maxs],cnt=0,s[maxs],sp;
int n,m,maxk,res=-inf;
inline int get(int x,int k){//取出二进制状态 x 的第 k 位
    return (x>>(k<<1))&3;
}
inline void prework(){
    maxk=1<<((m+1)<<1);//我知道你可能对此不理解，请看注解1
    for(int k=0;k<maxk;++k){
        bool flag=true;//flag=true 表示这种状态是合法的
        sp=0;//表示这种状态有几个开插头
        for(int j=0,cur;j<=m;++j){//从左往右扫
            cur=get(k,j);//轮廓线上这一段是什么
            if(cur==3){flag=false;break;}//合法的状态不会出现3
            if(cur==2){//这是个闭插头
                if(sp<=0){flag=false;break;}//没有可以配对的插头，状态不合法
                Map[k][j]=s[sp];//遇到一个闭插头，就必须与他左边最近的未配对的的开插头配对
                Map[k][s[sp]]=j;
                sp--;//可以配对的开插头减一
			}
            else if(cur==1)s[++sp]=j;//这是一个新的开插头
        }
        if(flag&&sp==0)sta[++cnt]=k;//合法的话记录这个状态
	}
}
inline void Update(int &x,int k){
    if(x<k)x=k;
}
inline void solve(){
    for(int i=1;i<=n;++i){
        for(int K=1,k;K<=cnt;++K){//对于每一种可行的状态
            k=sta[K];
            if(f[i-1][m][k]!=-inf&&get(k,m)==0)//导入上一行的扫描线：如果上一行的这个状态被更新过而且上一行这一个状态的轮廓线的这个位置并不是什么都没有
            f[i][0][k<<2]=f[i-1][m][k];
        }
        for(int j=1;j<=m;++j){
            Update(f[i][j][(1<<((j-1)<<1))|(2<<(j<<1))],a[i][j]);//初始化
            for(int K=1,k,ck,cur,last;K<=cnt;++K){
                k=sta[K];
                if(f[i][j-1][k]==-inf)continue;//非法情况
                ck=k&(~(3<<((j-1)<<1)))&(~(3<<(j<<1))); //获得下一位置状态的模板，空出 j-1 和 j 位以填写
                cur=get(k,j);last=get(k,j-1);//插头状态
                if(cur==0&&last==0){//情况一
                    Update(f[i][j][k],f[i][j-1][k]);//什么也不放
                    Update(f[i][j][ck|(1<<((j-1)<<1))|(2<<(j<<1))],f[i][j-1][k]+a[i][j]);//在 j-1 和 j 插入 1 和 2，代表将当前格的下插头设为新的开插头，当前格右插头设为新的闭插头
                }
                else if(cur==0||last==0){//情况二
                    int t=max(cur,last);//选出不为空的
                    //接下来两种方法
                    Update(f[i][j][ck|(t<<((j-1)<<1))],f[i][j-1][k]+a[i][j]);
                    Update(f[i][j][ck|(t<<(j<<1))],f[i][j-1][k]+a[i][j]);
                }
                else if(cur==2&&last==1){//情况三
                    if(!ck)//如果确实是个回路
                     Update(res,f[i][j-1][k]+a[i][j]);//更新答案
                }
                else if(cur==1&&last==2){
                    Update(f[i][j][ck],f[i][j-1][k]+a[i][j]);//删去这两个插头代表的回路
                }
                else if(cur==last){
                    int t=ck&(~(3<<(Map[k][j-1]<<1)))&(~(3<<(Map[k][j]<<1)));//清空匹配
                    t=t|(1<<(Map[k][j]<<1))|(2<<(Map[k][j-1]<<1));//重新匹配
                    Update(f[i][j][t],f[i][j-1][k]+a[i][j]);
                }
            }
        }
    }
    cout<<res<<endl;
}
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m;
    for(int i=1;i<=n;++i)
     for(int j=1;j<=m;++j)
      cin>>a[i][j];
    prework();
    for(int i=0;i<=n;++i)
     for(int j=0;j<=m;++j)
      for(int k=0;k<maxk;++k)
       f[i][j][k]=-inf;
    solve();
    return 0;
}
```



---

## 作者：bztMinamoto (赞：2)

大概是算第一道自己做出来的插头dp？

（虽然都是照着抄板子的）

（虽然有个地方死活没调出来最后只能看题解才发现自己错在哪里的）

我就当你们都会插头dp了……

因为必须得是一条路径，所以扫描线上的插头得两两对应，要用括号序列

然后分情况讨论一下，记$p1$为当前关键格左边的插头，$p2$为当前关键格上面的插头

$0$表示无插头，$1$表示左括号，$2$表示右括号

1.$p1==0$且$p2==0$

那么很明显我们可以把下方插头设为$1$右方插头设为$2$，就形成一个新的连通块了

然后注意不设任何插头的状态也要转移（我就是在这里坑了一个晚上）

2.$p1!=0$且$p2==0$

那么我们有两种走法，一是直走，那么右插头的值就是原插头的值，一是拐弯，那么下面的插头的值就是左插头的值

3.$p1==0$且$p2!=0$

同上，不多说了

4.$p1==1$且$p2==1$

就是两个左括号撞到一起了，那么把$p2$对应的右括号改成左括号

5.$p1==1$且$p2==2$

这种情况就说明一条路径已经结束了，那么此时如果轮廓线上没有其他任何插头就可以更新答案了

6.$p1==2$且$p2==1$

两条路径在这里汇合，直接合并

7.$p1==2$且$p2==2$

两个右括号撞到一起了，那么把$p1$对应的左括号改成右括号

然后……剩下的看代码好了（似乎我的插头dp写法和很多人不一样诶……跑得好慢……）
```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define inf 0x3f3f3f3f3f3f3f3f
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
const int mod=200097;
int n,m,c[105][105];ll ans=-0x3f3f3f3f3f3f3f3f;
struct Ha{
	int key[mod],sz,Hash[mod];ll val[mod];
	inline void init(){
		memset(val,0xef,sizeof(val)),memset(key,-1,sizeof(key));
		sz=0,memset(Hash,0,sizeof(Hash));
	}
	inline void newhash(int id,int state){Hash[id]=++sz,key[sz]=state,val[sz]=-inf;}
	ll &operator [](const int state){
		for(int i=state%mod;;i=(i+1==mod)?0:i+1){
			if(!Hash[i]) newhash(i,state);
			if(key[Hash[i]]==state) return val[Hash[i]];
		}
	}
}f[2];
inline int find(int state,int id){return (state>>((id-1)<<1))&3;}
inline void set(int &state,int pos,int val){
	pos=(pos-1)<<1,state|=3<<pos,state^=3<<pos,state|=val<<pos;
}
int link(int state,int pos){
	int cnt=0,del=(find(state,pos)==1)?1:-1;
	for(int i=pos;i&&i<=m+1;i+=del){
		int plug=find(state,i);
		if(plug==1) ++cnt;
		else if(plug==2) --cnt;
		if(!cnt) return i;
	}
	return -1;
}
void solve(int x,int y){
	int now=((x-1)*m+y)&1,last=now^1,tot=f[last].sz;
	f[now].init();
	for(int i=1;i<=tot;++i){
		int state=f[last].key[i];ll val=f[last].val[i];
		int plug1=find(state,y),plug2=find(state,y+1);
		if(!plug1&&!plug2){
			cmax(f[now][state],val);
			if(x!=n&&y!=m) set(state,y,1),set(state,y+1,2),cmax(f[now][state],val+c[x][y]);
		}
		else if(plug1&&!plug2){
			if(x!=n) cmax(f[now][state],val+c[x][y]);
			if(y!=m) set(state,y,0),set(state,y+1,plug1),cmax(f[now][state],val+c[x][y]);
		}
		else if(!plug1&&plug2){
			if(y!=m) cmax(f[now][state],val+c[x][y]);
			if(x!=n) set(state,y,plug2),set(state,y+1,0),cmax(f[now][state],val+c[x][y]);
		}
		else if(plug1==1&&plug2==1)
		set(state,link(state,y+1),1),set(state,y,0),set(state,y+1,0),cmax(f[now][state],val+c[x][y]);
		else if(plug1==1&&plug2==2){
			set(state,y,0),set(state,y+1,0);
			if(!state) cmax(ans,val+c[x][y]);
		}
		else if(plug1==2&&plug2==1) set(state,y,0),set(state,y+1,0),cmax(f[now][state],val+c[x][y]);
		else if(plug1==2&&plug2==2)
		set(state,link(state,y),2),set(state,y,0),set(state,y+1,0),cmax(f[now][state],val+c[x][y]);
	}
}
int main(){
//	freopen("testdata.in","r",stdin);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	scanf("%d",&c[i][j]);
	f[0].init(),f[0][0]=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j) solve(i,j);
		if(i!=n){
			int now=(i*m)&1,tot=f[now].sz;
			for(int j=1;j<=tot;++j)
			f[now].key[j]<<=2;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：foreverlasting (赞：2)

[题面](https://www.luogu.org/problemnew/show/P3190)

插头DP，括号序列。

具体做法以及分类都与[这道题](https://www.lydsy.com/JudgeOnline/problem.php?id=1814)一样，具体讨论请看[这篇博客](https://www.luogu.org/blog/foreverlasting/ural-1519formula-1-post)，那里很详细地讲解了。这里只不过是把转移方程换了一下。

code:
```
//2018.9.10 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register LL
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline LL read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline LL _abs(const res &x){
    return x>0?x:-x;
}
inline LL _max(const res &x,const res &y){
    return x>y?x:y;
}
inline LL _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=1e2+10,M=6+10,P=5e3+10;
const int kcz=23333;
namespace MAIN{
    int n,m;
    int va[N][M];
    int cur,cnt[2];
    int hsh[kcz+10];
    int vis[2][P];
    LL dp[2][P],ans=-inf;
    inline void insert(res S,LL sum){
        res pos=S%kcz;
        while(hsh[pos]){
            if(vis[cur][hsh[pos]]==S){dp[cur][hsh[pos]]=_max(dp[cur][hsh[pos]],sum);return;}
            pos=(pos+1)%kcz;
        }
        hsh[pos]=++cnt[cur],vis[cur][hsh[pos]]=S,dp[cur][hsh[pos]]=sum;
    }
    inline void MAIN(){
        n=read(),m=read();
        for(res i=1;i<=n;i++)
            for(res j=1;j<=m;j++)
                va[i][j]=read();
        cnt[0]=1;
        for(res i=1;i<=n;i++){
            for(res j=1;j<=m;j++){
                cnt[cur^=1]=0;
                memset(hsh,0,sizeof(hsh));
                for(res k=1;k<=cnt[cur^1];k++){
                    res S=vis[cur^1][k],l=(S>>((j-1)<<1))&3,r=(S>>(j<<1))&3;
                    LL las=dp[cur^1][k],now=las+va[i][j];
                    if(!l&&!r){
                        if(i<n&&j<m)insert(S^(1<<((j-1)<<1))^(2<<(j<<1)),now);
                        insert(S,las);
                    }
                    if(l&&!r){
                        if(j<m)insert(S^(l<<((j-1)<<1))^(l<<(j<<1)),now);
                        if(i<n)insert(S,now);
                    }
                    if(!l&&r){
                        if(i<n)insert(S^(r<<(j<<1))^(r<<((j-1)<<1)),now);
                        if(j<m)insert(S,now);
                    }
                    if(l==1&&r==1){
                        res dt=1;
                        for(res p=j+1;p<=m;p++){
                            res val=(S>>(p<<1))&3;
                            if(val==1)dt++;
                            if(val==2)dt--;
                            if(!dt){S^=(2<<(p<<1))^(1<<(p<<1));break;}
                        }
                        insert(S^(1<<((j-1)<<1))^(1<<(j<<1)),now);
                    }
                    if(l==2&&r==2){
                        res dt=1;
                        for(res p=j-2;~p;p--){
                            res val=(S>>(p<<1))&3;
                            if(val==1)dt--;
                            if(val==2)dt++;
                            if(!dt){S^=(1<<(p<<1))^(2<<(p<<1));break;}
                        }
                        insert(S^(2<<((j-1)<<1))^(2<<(j<<1)),now);
                    }
                    if(l==2&&r==1)insert(S^(2<<((j-1)<<1))^(1<<(j<<1)),now);
                    if(l==1&&r==2&&(S^(l<<((j-1)<<1))^(r<<(j<<1)))==0)ans=_max(ans,now);
                }
            }
            for(res j=1;j<=cnt[cur];j++)vis[cur][j]<<=2;
        }
        printf("%lld\n",ans);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：Hanx16Kira (赞：1)

# [HNOI2007]神奇游乐园

[Luogu P3190](https://www.luogu.com.cn/problem/P3190)


## Solution

可以说是模板题的另一种形式了，做法基本和模板题一致，只有少部分地方需要更改。如果你对插头 DP 还不熟，那写一写这道题也是个不错的选择~~（插头 DP 的黑题还是有很多水题的）~~（推销下我写的[插头DP的博客](https://www.cnblogs.com/hanx16msgr/p/16572885.html)）。

与模板题不同的是，此题的回路并不要求走完整个方格图，这也就是说每个格子具有的插头可能有 $2$ 个或者是 $0$ 个。那么知道了这点就可以来尝试讨论一下各种情况了。

此题解使用括号表示法~~，如果不会的话上面的博客链接有请~~。

### 分类讨论

#### 1. 没有左插和上插

此种情况下，当前格子可以没有任何插头（也就是说不走这个格子），也可以同时具有右插和下插（作为一条路径的拐点）：

$$
\begin{matrix}
&0\\
0&\square&0\\
&0
\end{matrix}
$$

或者是

$$
\begin{matrix}
&0\\
0&\square&\rightarrow_2\\
&\downarrow_1
\end{matrix}
$$

#### 2. 只有左插

此时当前格子可以有一个下插或者右插：

$$
\begin{matrix}
&0\\
\rightarrow_{1/2}&\square&\rightarrow_{1/2}\\
&0
\end{matrix}
$$

或者是

$$
\begin{matrix}
&0\\
\rightarrow_{1/2}&\square&0\\
&\downarrow_{1/2}
\end{matrix}
$$

此时的右插或下插应该与左插的编号保持一致。

#### 3. 只有下插

与上述情况几乎相同，就不详细再写了。

#### 4. 左插上插都为 $1$

如果把 $1$ 的插头看做是进入当前格子，$2$ 的插头看做走出当前格子，那么如果左插和上插都是 $1$，就应该将一个插头代表的路径反向，具体实现就是将上插对应的那个 $2$ 的插头更改为 $1$，同时删除当前格子的左插和上插（这个不好用矩阵来画图表达，可以自己在草稿纸上画一画~~，草稿纸的功能可比这玩意多多了~~）。

#### 5. 左插上插都为 $2$

与上面的那种情况也是类似的，需要将当前的两个插头删除，然后找到左插对应的 $1$ 的插头并将其更改为 $2$。

#### 6. 左插为 $2$，上插为 $1$

当前格子的插头刚好是能让两条路径一进一出的接上，所以直接删除这两个插头就可以了（我把 $2$ 的插头画成远离当前格子的方向会不会更好看）：

$$
\begin{matrix}
&\downarrow_1\\
\leftarrow_2&\square&0\\
&0
\end{matrix}
$$

#### 7. 左插为 $1$，上插为 $2$

既然这条路径都能向上走了，那么肯定就会构成回路了，所以此时更新答案：

$$
\begin{matrix}
&\uparrow_2\\
\rightarrow_1&\square&0\\
&0
\end{matrix}
$$

因为在写这篇代码的时候直接套用了模板题的思路和代码，所以使用了哈希来优化状态数，但是实际上 $m\le 6$ 的数据量完全是不需要的~~（所以我就把哈希的模写成了与数组长度相等）~~。需要注意的是上面分类讨论的时候的转移是需要进行一定的判断的（判断新的状态是否合法，比如插头是否插到方格图外面去了这种情况），因为使用了哈希，如果出现了非法情况，那么之后会再在这些非法情况上生成新的非法情况，会导致 `RE` 或者是 `TLE`（这两者的区别取决于你的数组开了多大，太大就会超时，太小就会运行时错误）。如果判断了非法情况的话，数组可以开的非常小（实测出来大概只有 $200$ 左右的样子）。

### Code

代码细节其实和模板题需要注意的几乎一致，所以就不再讲解了。

```c++
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof a)
#define int long long
using namespace std;
void read(auto &k)
{
	k=0;auto flag=1;char b=getchar();
	while (!isdigit(b)) {flag=(b=='-')?-1:1;b=getchar();}
	while (isdigit(b)) {k=k*10+b-48;b=getchar();}
	k*=flag;
}
void write(auto k) {if (k<0) {putchar('-'),write(-k);return;}if (k>9) write(k/10);putchar(k%10+48);}
void writewith(auto k,char c) {write(k);putchar(c);}
int n,m,a[105][105],Fans=INT_MIN;
int pre=1,cur=0;
const int _SIZE=200,HSIZE=200;
int f[2][_SIZE+5],state[2][_SIZE+5],tot[2],bits[15];
struct HASH{
	int nxt,to;
}H[_SIZE+5];
int ptr[HSIZE+5],at;
void modify(int sta,int val)
{
	int key=sta%HSIZE;
	for (int i=ptr[key];i;i=H[i].nxt)
		if (state[cur][H[i].to]==sta)
		{
			f[cur][H[i].to]=max(f[cur][H[i].to],val);
			return;
		}
	tot[cur]++;if (tot[cur]>_SIZE) printf("?"),exit(0);//这一句类似于assert，只不过是想看测试点RE的原因
	state[cur][tot[cur]]=sta;
	f[cur][tot[cur]]=val;
	H[++at].nxt=ptr[key];
	H[at].to=tot[cur];
	ptr[key]=at;
}
void init(){for (int i=1;i<=10;i++) bits[i]=i<<1;}
void PlugDP()
{
	tot[cur]=1;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=tot[cur];j++) state[cur][j]<<=2;
		for (int j=1;j<=m;j++)
		{
			swap(cur,pre);
			tot[cur]=0;at=0;mem(ptr,0);
			for (int k=1;k<=tot[pre];k++)
			{
				int nowans=f[pre][k],nowsta=state[pre][k];
				int isR=(nowsta>>bits[j-1])%4,isD=(nowsta>>bits[j])%4;
				if ((!isR) && (!isD))
				{
					if (j!=m && i!=n) modify(nowsta+(1<<bits[j-1])+2*(1<<bits[j]),nowans+a[i][j]);
					modify(nowsta,nowans);
				}
				else if ((!isR) && isD)
				{
					if (j!=m) modify(nowsta,nowans+a[i][j]);
					if (i!=n) modify(nowsta-isD*(1<<bits[j])+isD*(1<<bits[j-1]),nowans+a[i][j]);
				}
				else if (isR && (!isD))
				{
					if (i!=n) modify(nowsta,nowans+a[i][j]);
					if (j!=m) modify(nowsta-isR*(1<<bits[j-1])+isR*(1<<bits[j]),nowans+a[i][j]);
				}
				else if (isR==1 && isD==1)
				{
					int cnt=1;
					for (int l=j+1;l<=m;l++)
					{
						if ((nowsta>>bits[l])%4==1) cnt++;
						else if ((nowsta>>bits[l])%4==2) cnt--;
						if (!cnt)
						{
							modify(nowsta-(1<<bits[j-1])-(1<<bits[j])-(1<<bits[l]),nowans+a[i][j]);
							break;
						}
					}
				}
				else if (isR==2 && isD==2)
				{
					int cnt=1;
					for (int l=j-2;l;l--)
					{
						if ((nowsta>>bits[l])%4==1) cnt--;
						else if ((nowsta>>bits[l])%4==2) cnt++;
						if (!cnt)
						{
							modify(nowsta-2*(1<<bits[j-1])-2*(1<<bits[j])+(1<<bits[l]),nowans+a[i][j]);
							break;
						}
					}
				}
				else if (isR==2 && isD==1)
					modify(nowsta-(1<<bits[j])-2*(1<<bits[j-1]),nowans+a[i][j]);
				else if (isR==1 && isD==2 && 2*(1<<bits[j])+(1<<bits[j-1])==nowsta)
					Fans=max(Fans,nowans+a[i][j]);
			}
		}
	}
}
signed main()
{
	read(n),read(m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) read(a[i][j]);
	init();
	PlugDP();
	writewith(Fans,'\n');
	return 0;
}

```

---

## 作者：luqyou (赞：1)

# 前言
[题目传送门](https://www.luogu.com.cn/problem/P3190)



# 本题思路

题目的意思就是让你求出求一个最大点权回路，不难想到插头 DP。

那么我们直接套插头 DP 的模板。

有一些细节性的问题需要注意注意：

- 枚举最右点，不能存在右插头。不然之后转移状态虽然没考虑但是会一直记录，然后炸时间和空间。

- 形成一个连通分量只会出现一次 ```()``` 的情况，不要再 ```push``` 进状态。

这题对于背过模板的伙伴们来说还是比较简单的，注意一下就 AC 了。

# code
```cpp
#include <bits/stdc++.h>
using namespace std;

struct hash_table {
    int hash_mod = 19991;
    int state[20000], ans[20000], up;
    int tot, first[20000], nxt[20000], w[20000];
    void init() {
        memset(first, 0, sizeof(first));
        tot = 0;
        up = 0;
    }
    int ins(int sta, int val) {
        int key = sta%hash_mod;
        for(int i = first[key]; i; i = nxt[i]) {
            if(state[w[i]] == sta) return ans[w[i]] = max(ans[w[i]],val);
        }
        state[++up] = sta;
        ans[up] = val;
        nxt[++tot] = first[key];
        w[tot] = up;
        first[key] = tot;
        return val;
    }
}dp[2];

#define prel (1<<bit[j-1])
#define prer (1<<bit[j])
int n, m, a[105][10], bit[10];

void solve() {
    int cur = 0, ans = -1e9;
    dp[cur].init();
    dp[0].ins(0,0);
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= dp[cur].up; ++j) dp[cur].state[j] <<= 2;
        for(int j = 1; j <= m; ++j) {
            cur ^= 1;
            dp[cur].init();
            for(int k = 1; k <= dp[cur^1].up; ++k) {
                int sta = dp[cur^1].state[k];
                int w = dp[cur^1].ans[k];
                int d = (sta>>bit[j])&3;
                int r = (sta>>bit[j-1])&3;
                if(!r && !d) {
                    dp[cur].ins(sta,w);
                    if(j != m) dp[cur].ins(sta+prel+2*prer,w+a[i][j]);
                }
                else if(!r && d) {
                    if(j != m) dp[cur].ins(sta,w+a[i][j]);
                    dp[cur].ins(sta-d*prer+d*prel,w+a[i][j]);
                }
                else if(r && !d) {
                    dp[cur].ins(sta,w+a[i][j]);
                    if(j != m) dp[cur].ins(sta-r*prel+r*prer,w+a[i][j]);
                }
                else if(r == 1 && d == 1) {
                    int cnt = 1;
                    for(int p = j+1; p <= m; ++p) {
                        if(((sta>>bit[p])&3) == 1) ++cnt;
                        if(((sta>>bit[p])&3) == 2) --cnt;
                        if(!cnt) {
                            dp[cur].ins(sta-prel-prer-(1<<bit[p]),w+a[i][j]);
                            break;
                        }
                    }
                }
                else if(r == 2 && d == 2) {
                    int cnt = 1;
                    for(int p = j-2; p >= 0; --p) {
                        if(((sta>>bit[p])&3) == 1) --cnt;
                        if(((sta>>bit[p])&3) == 2) ++cnt;
                        if(!cnt) {
                            dp[cur].ins(sta-2*prel-2*prer+(1<<bit[p]),w+a[i][j]);
                            break;
                        }
                    }
                }
                else if(r == 2 && d == 1) {
                    dp[cur].ins(sta-prel*r-prer*d,w+a[i][j]);
                }
                else {
                    if(sta == prel+2*prer) ans = max(ans,w+a[i][j]);
                    // 形成一个连通分量，不能再push进去不然存在多个回路
//                    else dp[cur].ins(sta-prel-2*prer,w+a[i][j]);
                }
            }
        }
    }
    printf("%d\n",ans);
}

int main() {
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; ++i) for(int j = 1; j <= m; ++j) scanf("%d",&a[i][j]);
    for(int i = 1; i <= m; ++i) bit[i] = i<<1;
    solve();
	return 0;
}

```
[AC记录](https://www.luogu.com.cn/record/68753336)

---

## 作者：SIGSEGV (赞：1)

一道~~奇怪的~~插头dp（默认你们会插头dp）

## 用不着哈希，直接存合法下标和它们对应的的值就够了

> 我的奇丑无比的代码用hash后就TLE了......

然后是插头dp正题

---

1. 00： 00（不开始回路）12（开始一个转角）
2. 插头里有一个是0：延长或转弯
3. 两个插头相同且不为0：如果两个都是1就改上插头对应的2，否则改左插头对应的1
4. 12： 结束回路，判断轮廓线上有没有其它插头再算答案
5. 21： 直接进行连接（相当于添加一个转角） 


其中2，3，5都是与正常的插头dp相同的，只有1和4要注意一下

剩下的看代码吧
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,bits[20];
inline void ch(int &val,const int &pos,const int &vv) //查询
{val &= ~(3 << bits[pos - 1]);val |= (vv << bits[pos - 1]);}
inline int query(const int &val,const int &pos) //更改
{ return (val >> bits[pos - 1]) & 3;}
const int N = 1048576;
int sub[N],val[N],l;
struct DP 
{
    int ptr = 0,_sub[N],_val[N];//_sub:下标 _val:值（不用long long）
    bool last = 0,vis[N];
    inline void clear() 
    { memset(vis,0,sizeof(vis));ptr = last = 0; }
    inline void set_last() {last = 1;} //是否为最后一列
    DP() {clear(); }
    inline void add(int s,int vv)
    {
        if (last) s <<= 2; //最后一列的特殊处理
       	if (vis[s]) //下标出现过
       	{
       		if (_val[s] < vv) _val[s] = vv;	
        }
        else
        {
            _sub[ptr++] = s;_val[s] = vv; vis[s] = 1;
        }
    }
    inline void fetch_all() //获取所有
    {
        l = 0;
        for (int i = 0;i < ptr;i++)
        {
            sub[++l] = _sub[i];
            val[l] = _val[_sub[i]];
         } 
    }
} h[2];
int a[105][10],ans;
int find_pos(int cur,int pos,int dirc)
{
    int tmp = query(cur,pos),top = 0;
    if (tmp == 1) ++top;else if (tmp == 2) --top;
    pos += dirc;
    while (1)
    {
        tmp = query(cur,pos);
        if (tmp == 1) ++top;else if (tmp == 2) --top;
        if (top == 0) return pos;
        pos += dirc;
    }
}

void dp(int now,int i,int j)
{
    int pre = now ^ 1,cnt = 0;
    if (j == m) h[now].set_last();
    h[pre].fetch_all();
    for (int k = 1;k <= l;k++)
    {
        int stat = sub[k],cur = sub[k],vv = val[k] + a[i][j];
        int left = query(stat,j),up = query(stat,j + 1);
        ++cnt;
        if (left == 0 && up == 0) //Case 1
        {
            h[now].add(stat,vv - a[i][j]);
            if (i == n || j == m) continue;
            ch(cur,j,1);ch(cur,j + 1,2);h[now].add(cur,vv);
        }
        else if (left == 0 || up == 0) //Case 2
        {
            if (i != n)
            {
                ch(cur,j,left + up);ch(cur,j + 1,0);h[now].add(cur,vv);
            }
            if (j != m)
            {
                ch(cur,j,0);ch(cur,j + 1,left + up);h[now].add(cur,vv);
            }
        }
        else if (left == up) //Case 3
        {
            if (left == 1)
            {
                ch(cur,find_pos(stat,j + 1,1),1);
                ch(cur,j,0);ch(cur,j + 1,0);h[now].add(cur,vv);
            }
            else if (left == 2)
            {
                ch(cur,find_pos(stat,j,-1),2);  
                ch(cur,j,0);ch(cur,j + 1,0);h[now].add(cur,vv);
            }
        }
        else if (left == 1 && up == 2) //Case 4
        {
            ch(cur,j,0);ch(cur,j + 1,0);if (!cur) ans = max(ans,vv);
        }
        else if (left == 2 && up == 1) //Case 5
        {
            ch(cur,j,0);ch(cur,j + 1,0);h[now].add(cur,vv);
        }
    }
}
int main ()
{
    for (int i = 0;i < 20;i++) bits[i] = (i << 1);
    int num = 0;ch(num,1,2);
    scanf("%d%d",&n,&m);
    for (int i = 1;i <= n;i++)
        for (int j = 1;j <= m;j++) scanf("%d",&a[i][j]);
    if (m > 6) throw;
    int now = 0;h[1].add(0,0);
    ans = INT_MIN;
    for (int i = 1;i <= n;i++)
        for (int j = 1;j <= m;j++)
        {
            dp(now,i,j);now ^= 1;h[now].clear();
        } 
    printf("%d",ans);
    return 0;
}             
```

---


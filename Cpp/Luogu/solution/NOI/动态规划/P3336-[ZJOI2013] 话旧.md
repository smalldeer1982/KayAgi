# [ZJOI2013] 话旧

## 题目描述

小林跟着银河队选手去了一趟宇宙比赛，耳濡目染，变得学术起来。回来后，他发现世界大变样了。比丘兽究级进化，成了凤凰兽；金先生因为发了一篇 paper，一跃成为教授，也成为了银河队选拔委员会成员。

一日，小林与金教授聊天。金教授回忆起过去的岁月，那些年他学过的电路原理。他曾经对一种三角波很感兴趣，并且进行了一些探究。小林感到很好奇，于是金教授就将课题形式化地说了一遍。

有一定义在 $[0,N]$ 的连续函数 $f(x)$，其中 $N$ 是整数，满足 $f(0)=f(N)=0$，它的所有极值点在整数处取到，且 $f(x)$ 的**极小值**均是 $0$。对于任意的 $0$ 到 $N-1$ 间的整数 $I$，$f(x)$ 在 $(I, I+1)$ 上是斜率为 $1$ 或 $-1$ 的一次函数。

金先生研究的是，若他知道其中 $K$ 个整点的函数值，那么：

1. 有多少个函数满足条件？
2. 满足条件的函数中，$f(x)$ 的最大值，最大能是多少？

小林思考了一下，便想出了很好的算法。那么作为经过多年训练的你呢？

## 说明/提示

- 对于 $10\%$ 的数据，$N \leq 10$。
- 对于 $20\%$ 的数据，$N \leq 50$。
- 对于 $30\%$ 的数据，$N \leq 100$，$K \leq 100$。
- 对于 $50\%$ 的数据，$N \leq 10^3$，$K \leq 10^3$。
- 对于 $70\%$ 的数据，$N \leq 10^5$。
- 另有 $10\%$ 的数据，$K=0$。
- 对于 $100\%$ 的数据，$ 0 \leq N \leq 10^9$，$0 \leq K \leq 10^6$。

## 样例 #1

### 输入

```
2 0```

### 输出

```
1 1```

## 样例 #2

### 输入

```
6 9
4 2
4 2
2 0
4 2
6 0
5 1
2 0
0 0
0 0```

### 输出

```
1 2```

# 题解

## 作者：awapwq233 (赞：13)

# P3336 [ZJOI2013]话旧 题解

 [目前最优解 / 55ms](https://www.luogu.com.cn/record/88977144)
 
![](https://cdn.luogu.com.cn/upload/image_hosting/cxkf173c.png)

-----

### $\texttt{0x01}$ 形式化题意

[自己看](https://www.luogu.com.cn/problem/P3336)，懒得写。

反正就是只要**开始**往下走了就一定要走到 $0$。

---
 
### $\texttt{0x02}$ 思路

把所有给过的点排个序，相邻的每两个点计算方案数，发现对之前的计算结果影响很小，故考虑 $\texttt{dp}$。

考虑到当前点**向上向下走**会对结果产生影响（就是形式化题意里面说的），因此将当前点**向上 / 向下**加入状态，于是我们设：

${f_i}$ 表示经过前 $ i$ 个点**且在第 $i$ 个点左导数 $F'(x_i)=1$** 的函数的个数。

${g_i}$ 表示经过前 $ i$ 个点**且在第 $i$ 个点左导数 $F'(x_i)=-1$** 的函数的个数。

值得注意的是，该函数一定经过 $(0, 0),(n, 0)$，记得把这两个点加上。

第一问答案即为 ${g_m}$（$m$ 已去重）。

第二问在转移的时候随手算算啦。

---

### $\texttt{0x03 Q1}$

别忘了**sort & unique**。

对于两个相邻的点 $(x_1, y_1), (x_2, y_2)$，首先考虑其斜率 ${k}=\frac{y_2-y_1}{x_2-x_1}$。

显然的，当 $|k| > 1$ 时，函数不存在，此时第二问无解。

因此题目中**默认**$ |k|\in [0,1]$，应注意。

-----

$\texttt{when k = 1:}$


那就只能上升啦？ 

${f_i = f_{i-1}}\ ?$

![](https://cdn.luogu.com.cn/upload/image_hosting/fl9bvacv.png)

能不能由下降转为上升？

只要前面那个点 $F(x_{i-1}) = 0$ 就可以啦。

![](https://cdn.luogu.com.cn/upload/image_hosting/mk5ou1db.png)

${f_i} =\Big\{^{ f_{i-1} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  {(F(x_{i-1}) \neq 0)}} _{ f_{i-1} + g_{i - 1}\ \ \ \ \ {(F(x_{i-1}) = 0)}}$


-----

$\texttt{when k = -1:}$

上升下降都可以啦。

![](https://cdn.luogu.com.cn/upload/image_hosting/kkpqt63i.png)

${g_i = f_{i-1} + g_{i-1}}$

-----

$\texttt{when k} \in \texttt{[0,1):}$

你要想一下：如果按照贪心的思路一直向下，能不能碰到**最底下**？

为什么要这么想呢？

&nbsp;&nbsp;&nbsp;&nbsp;如果不能碰到：只能在上面出现拐点，且**拐点 & 路径唯一**。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这很好想叭。要是开始往下就不能回头了。其他地方**必定**会错过那个点。

![](https://cdn.luogu.com.cn/upload/image_hosting/rmidac86.png)



&nbsp;&nbsp;&nbsp;&nbsp;如果刚好碰到：上面下面两条路，均**唯一**。

![](https://cdn.luogu.com.cn/upload/image_hosting/cnskx58s.png)


&nbsp;&nbsp;&nbsp;&nbsp;如果很早就能碰到：好多好多好多好多好多好多

![](https://cdn.luogu.com.cn/upload/image_hosting/yt1u76ls.png)

接着分类讨论。那么如何区分这几种情况呢？

注意到我们画的图：两个点总是尽可能向下走与 $x$ 轴相交。

一般的，对于 $(x_{i-1}, y_{i-1}),(x_i, y_i)$，分别代入 $y=-x+b_1,y=x+b_2$，有 $b_1=x_{i-1}+y_{i-1}, b_2=-x_i+y_i$，截距分别为 $-\frac{b_1}{k_1}=x_{i-1}+y_{i-1},-\frac{b_2}{k_2}=x_{i}-y_{i}$，二者作差，得

$ l = x_i-y_i-x_{i-1}-y_{i-1}$

这就是分类讨论的依据。

----

$\texttt{when l < 0:}$

${g_i} =\Big\{^{ f_{i-1} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  {(F(x_{i-1}) \neq 0)}} _{ f_{i-1} + g_{i - 1}\ \ \ \ \ {(F(x_{i-1}) = 0)}}$

和上面类似，自己想。

-----

$\texttt{when l = 0:}$

${f_i = f_{i-1} + g_{i-1}}$

${g_i} =\Big\{^{ f_{i-1} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  {(F(x_{i-1}) \neq 0)}} _{ f_{i-1} + g_{i - 1}\ \ \ \ \ {(F(x_{i-1}) = 0)}}$

和上面类似，懒得写。

----

$\texttt{when l > 0:}$


观察可以发现，$(x-1,0)\to(x,1)\to(x+1,0)$ 的小结构（我们称它为“齿”）的个数为 $\frac{l}{2}$。

每次选定一个“齿”，将其往上翻，我们都可以得到一条新的路径。

设方案数为 $k$：

如果初始点为上升：$k=2^{\frac{l}{2}}$

如果初始点为下降：$k=2^{\frac{l}{2}-1}$，**因为第一个向下的齿不能向上翻转，它必须碰到最下面**。

${f_i} =\Big\{^{ f_{i-1}\times 2^{\frac{l}{2}}+g_{i-1}\times 2^{\frac{l}{2}-1} \ \ \ \ \ \ \ \ \  {(F(x_{i}) \neq 0)}} _{0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {(F(x_{i}) = 0)}}$

$g_i=f_{i-1}\times 2^{\frac{l}{2}}+g_{i-1}\times 2^{\frac{l}{2}-1}$


-----

### $\texttt{0x04 Q2}$ 

第二问的话，贪心就好啦。

但是如果正在往下走的话贪心会寄。判断一下。

----

### $\texttt{0x05 Code}$ 

代码美学。

```cpp
int main()
{
	read(n, m);
	F(i, 1, m) P[i].input();
	P[++ m].input(0, 0), P[++ m].input(n, 0);
	sort(P + 1, P + m + 1); m = unique(P + 1, P + m + 1) - P - 1;
	g[1] = 1;
	F(i, 2, m)
	{
		int l = b.x - b.y - a.x - a.y >> 1;
		if(a.x - b.x == a.y - b.y) 		f[i] = (f[i - 1] + (a.y ? 0 : g[i - 1])) % mod;
		else if(a.x - b.x == b.y - a.y) g[i] = (f[i - 1] + (g[i - 1])) % mod;
		else if(l < 0) 					g[i] = (f[i - 1] + (a.y ? 0 : g[i - 1])) % mod;
		else if(l == 0)					f[i] = (f[i - 1] + (g[i - 1])) % mod,
										g[i] = (f[i - 1] + (a.y ? 0 : g[i - 1])) % mod;
		else 
		{
			int k = fastpow(2, l - 1, mod);
			if(b.y) f[i] = 1ll * ((f[i - 1] << 1) + g[i - 1]) * k % mod;
					g[i] = 1ll * ((f[i - 1] << 1) + g[i - 1]) * k % mod;
		}
		if(g[i] || !b.y) ans = qmax(ans, b.y, b.x + b.y - a.x + a.y >> 1);
	}
	write(' ', g[m], ans);
	return 0;
}

```

> 三目运算符要是再不打括号 $awa$ 就吃了自己吧。





---

## 作者：sunzh (赞：9)

首先考虑方案。

我们用$dp_{i,0/1}$表示函数图象到$(x_i,y_i)$点，前一段线段的方向是$1/-1$的方案数

设前一个节点与当前节点坐标分别为$(x1,y1),(x2,y2)$考虑以下几种情形：
1.  $x2-x1=y2-y1$，此时唯一的方案是一整条方向1的线段

1. $x2-x1=y1-y2$，此时唯一的方案是一整条方向-1的线段

1. 设$len=x2-x1-y1-y2$
如果$len< 0$只有先向上后向下一种方案
否则分别考虑前后上升或下降的四种情况。
可以发现会形成一种类似锯齿的形状，锯齿的边可以移动。先上后下本质上就是所有上升边移到左边得到的。cnt个锯齿的边的移动方案可以表示为$2^{cnt}$

然后考虑最大值，最大值也可以类似的转移。不存在方案时这个值被赋为$-inf$。从前面上升后面下降的方式得到的一定是最优的，但是如果这样的方案不符合转移时，就要考虑其他情况。包括但不限于先向下，然后向上向下，向上向下向上等。每一种最大值一定是某一段上升再下降的顶点或是$y1,y2$。

代码如下

```
#include<cstdio>
#include<iostream>
#include<queue>
#include<algorithm>
#include<cstring>
#include<set>
#include<vector>
#include<cmath>
#define PII pair<int,int>
#define pb push_back
#define ep emplace_back
#define mp make_pair
#define fi first
#define se second
//#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){ if(c=='-') f=-1; c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return f==1?x:~x+1;
}
inline void print(int x){
	if(x<0) putchar('-'),x=~x+1;
	if(x>=10) print(x/10);
	putchar((x%10)|48);
}
const int mod=19940417;
int n,k;
set<PII>st;
PII a[1000010];
int dp[1000010][2],mxn[1000010][2];// 0 up 1 down
int qpow(int x,int k){
	if(k<=0) return 1;
	int res=1;
	while(k){
		if(k&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		k>>=1;
	} 
	return res;
}
void uad(int &x,int y){
	x=(x+y>=mod?x+y-mod:x+y);
}
int add(int x,int y){
	return x+y>=mod?x+y-mod:x+y;
}
signed main(){
	n=read(),k=read();
	st.insert(mp(0,0));
	st.insert(mp(n,0));
	for(int i=1;i<=k;++i){
		int x=read(),y=read();
		st.insert(mp(x,y));
	}
	int m=0;
	for(auto i:st){
		a[++m]=i;
	}
	memset(mxn,-0x3f,sizeof(mxn));
	dp[1][1]=1;mxn[1][0]=0;
	for(int i=2;i<=m;++i){
		int x1=a[i-1].fi,y1=a[i-1].se;
		int x2=a[i].fi,y2=a[i].se;
		if(x2-x1==y2-y1){
			uad(dp[i][0],dp[i-1][0]);
			mxn[i][0]=max(mxn[i-1][0],y2);
			if(y1==0) uad(dp[i][0],dp[i-1][1]),mxn[i][0]=max(mxn[i-1][1],y2);
		} 
		else if(x2-x1==y1-y2){
			uad(dp[i][1],dp[i-1][1]);uad(dp[i][1],dp[i-1][0]);
			mxn[i][1]=max(max(mxn[i-1][1],mxn[i-1][0]),y2);
		}
		else{
			int len=x2-x1-y1-y2;
			if(len<=0){
				int pre=mxn[i-1][0];
				uad(dp[i][1],dp[i-1][0]);if(y1==0) uad(dp[i][1],dp[i-1][1]),pre=max(pre,mxn[i-1][1]);
				if(dp[i][1])mxn[i][1]=max(pre,(x2+y2-y1-x1>>1)+y1);//x+y=x2-x1,x-y=y2-y1 x=x2+y2-y1-x1
			}
			if(len>=0){
				if(len==0){
					uad(dp[i][0],dp[i-1][0]);uad(dp[i][0],dp[i-1][1]);
					mxn[i][0]=max(max(mxn[i-1][1],mxn[i-1][0]),y2);
				}
				else{
					int t,t2;
					if(dp[i-1][0]>0){
//						printf("O:%d\n",i);
						t=max(max(y1==0?mxn[i-1][1]:-0x3f3f3f3f,mxn[i-1][0]),(x2+y2-y1-x1>>1)+y1);
						t2=max(max(y1==0?mxn[i-1][1]:-0x3f3f3f3f,mxn[i-1][0]),y1+(x2-y2-y1-x1>>1));
					}
					else{
//						printf("i:%d\n",i);
						t=max(mxn[i-1][1],(x2-x1-y1+y2>>1));//x+y=x2-x1-y1,x-y=y2
						t2=max(mxn[i-1][1],len>>1);//x+y=x2-x1-y1-y2,x-y=0
					}
					int k=add(1ll*dp[i-1][1]*qpow(2,(len>>1)-1)%mod,1ll*dp[i-1][0]*qpow(2,len>>1)%mod);
					if(y2>0) uad(dp[i][0],k),mxn[i][0]=max(t2,y2);
					uad(dp[i][1],k);mxn[i][1]=max(t,y2);
				}
			}
		}
		if(!dp[i][0]) mxn[i][0]=-0x3f3f3f3f;
		if(!dp[i][1]) mxn[i][1]=-0x3f3f3f3f;
//		printf("i:%d,mxn:%d,%d\n",i,mxn[i][0],mxn[i][1]);
	}
	printf("%d %d\n",dp[m][1],mxn[m][1]);
}
```


---

## 作者：Presentation_Emitter (赞：8)

Upd 2025/8/9：完全重构本题解与代码。

记 $X_0$ 是 $0 \sim n$ 中所有偶数组成的集合，可以发现全体 $f(x)$ 组成的集合与 $\{X \mid \{0,n\} \subseteq X \subseteq X_0\}$ 之间存在双射。

对于第一问，考虑将问题转化为统计满足条件的 $X_0$ 的子集 $X$。对于一个 $f(x_i)=y_i$，记 $B_i=(x_i-y_i,x_i+y_i)$，$P_i=\{x_i-y_i,x_i+y_i\}$，发现这个条件等价于 $X \cap B_i=\varnothing$，且 $X \cap P_i \neq \varnothing$。记 $C=(\{0,n\}\cup\bigcup\limits_{i=1}^k P_i) \setminus \bigcup\limits_{i=1}^k B_i$，$c_1,c_2,\cdots,c_m$ 是其中全体元素从小到大排序形成的数列。则所求的 $X$ 需要为 $C \cup (X_0 \setminus \bigcup\limits_{i=1}^k P_i)$ 的子集。

考虑如何求 $C$ 的满足所有限制条件的子集数量。对于 $1 \le i \le n$，可能存在下面的限制条件：

- $c_i \in X$（记为 $L_1(i)$）；
- $i<n$ 且 $\{c_i,c_{i+1}\} \cap X \neq \varnothing$（记为 $L_2(i)$）。

对于一个极长区间 $[l,r]$ 满足 $\forall l \le i \le r$，不存在限制条件 $L_1(i)$，且对于 $i<r$ 存在限制 $L_2(i)$。容易证明 $\{c_l,c_{l+1},\cdots,c_r\}$ 的满足条件的子集数量为 $\operatorname{fib}_{r-l+2}$（$\operatorname{fib}$ 指斐波那契数列，其中 $\operatorname{fib}_0=\operatorname{fib}_1=1$，$\operatorname{fib}_n=\operatorname{fib}_{n-1}+\operatorname{fib}_{n-2}$）。不同的极长区间之间相互独立，故 $C$ 的合法子集数为 $\prod\limits_{[l,r] \in I_C}\operatorname{fib}_{r-l+2}$，其中 $I_C$ 为所有极长区间组成的集合。

对于 $X_0 \setminus \bigcup\limits_{i=1}^k P_i$ 内的所有元素，除 $0,n$ 外其它元素均不被限制。于是可以得到第一问的答案为 $2^{|X_0 \setminus (\{0,n\} \cup \bigcup\limits_{i=1}^k P_i)|}\prod\limits_{[l,r] \in I_C}\operatorname{fib}_{r-l+2}$。

对于第二问，设最大值两侧最近的零点为 $x_0,x_1$。注意到若 $x_0 \not \in C$，则可以选择 $x_0-2,x_1$ 获得一个更大的值。$x_1$ 同理。于是 $x_0,x_1 \in C$。

记 $x_0=c_i,x_1=c_j$。有结论 $j-i \le 3$。

证明：若 $j-i \ge 4$，则 $L_1(i+1),L_1(i+2),L_1(i+3),L_2(i+1),L_2(i+2)$ 中必有至少一个成立，与最近的零点矛盾。

于是直接枚举 $i,j$ 就行。即：

- 用 $c_i,c_{i+1}$ 更新答案；
- 若不存在限制条件 $L_1(i+1)$，则用 $c_i,c_{i+2}$ 更新答案；
- 若不存在限制条件 $L_1(i+1),L_1(i+2),L_2(i+1)$，则用 $c_i,c_{i+3}$ 更新答案；

Code:

```cpp
int n,k,x[1000005],v[1000005],fib[1000005];
pair<int,int>rban[1000005];int bcnt,ban[2000005];
int pos[2000005],pcnt;pair<int,int>edge[1000005];int ecnt;
bool lk[2000005];int pre[2000005];
il bool banned(int x)
{
	int p=lower_bound(ban+1,ban+1+bcnt,x)-ban;
	ret p<=bcnt&&!(p&1);
}
int main()
{
	n=rd();k=rd();x[k+1]=n;v[k+1]=0;bcnt=pcnt=ecnt=0;bool flag=!(n&1);fib[0]=1;fib[1]=2;
	for(int i=2;i<=k;++i)pls(fib[i]=fib[i-1],fib[i-2]);
	for(int i=1;i<=k;++i)x[i]=rd(),v[i]=rd();
	for(int i=0;i<=k;++i)if((x[i]-v[i]<0)||(x[i]+v[i]>n)||((x[i]^v[i])&1)||uabs(v[i]-v[i+1])>uabs(x[i]-x[i+1])){flag=0;break;}
	if(!k){prt(qpow(2,(n>>1)-1),' ');prt(n>>1);ret 0;}
	int tmp=0,fcnt=(n>>1)+1;
	for(int i=1;i<=k;++i)if(v[i])rban[++tmp]=make_pair(x[i]-v[i]+1,x[i]+v[i]-1);
	sort(rban+1,rban+1+tmp);
	for(int i=1;i<=tmp;++i)
	{
		int l=rban[i].fir,r=rban[i].sec;l+=l&1;r-=r&1;
		if(l>r)continue;
		if(bcnt&&l<=ban[bcnt]+2)tomax(ban[bcnt],r);
		else ban[++bcnt]=l-1,ban[++bcnt]=r;
	}
	for(int i=1;i<=(bcnt>>1);++i)fcnt-=((ban[i<<1]-ban[(i<<1)-1]-1)>>1)+1;
	for(int i=1;i<=k;++i)
	{
		int a=x[i]-v[i],b=x[i]+v[i];
		if(banned(b))b=-1;
		if(banned(a))a=b,b=-1;
		if(a==b)b=-1;
		if(!~a){flag=0;break;}
		pos[++pcnt]=a;
		if(~b)pos[++pcnt]=b;
		edge[++ecnt]=make_pair(a,b);
	}
	edge[++ecnt]=make_pair(pos[++pcnt]=0,-1);
	edge[++ecnt]=make_pair(pos[++pcnt]=n,-1);
	if(!flag){puts("no solution UwU");ret 0;}
	sort(edge+1,edge+1+ecnt);ecnt=unique(edge+1,edge+1+ecnt)-edge-1;
	sort(pos+1,pos+1+pcnt);pcnt=unique(pos+1,pos+1+pcnt)-pos-1;
	clr(lk,pcnt+1);clr(pre,pcnt+1);
	int ans1=qpow(2,fcnt-pcnt),ans2=1;
	for(int i=1,j=1,las=1;i<=pcnt&&j<=ecnt;++i)
	{
		while(j<=ecnt&&edge[j].fir<pos[i])++j;
		if(j>ecnt||edge[j].fir>pos[i])ans1=1ll*ans1*fib[i-las+1]%mod,las=i+1;
		else if(!~edge[j].sec)lk[i]=1,++j,ans1=1ll*ans1*fib[i-las]%mod,las=i+1;
	}
	for(int i=1,i1=1,i2=1;i<=ecnt;++i)
	{
		int a=edge[i].fir,b=edge[i].sec;
		if(~b)
		{
			while(i1<pcnt&&pos[i1]<a)++i1;
			while(i2<pcnt&&pos[i2]<b)++i2;
			pre[i2]=i1;
		}
	}
	for(int i=1;i<pcnt;++i)
	{
		int res=pos[i+1]-pos[i];
		if(i+2<=pcnt&&!lk[i+1])
		{
			tomax(res,pos[i+2]-pos[i]);
			if(i+3<=pcnt&&!lk[i+2]&&!pre[i+2])tomax(res,pos[i+3]-pos[i]);
		}
		tomax(ans2,res>>1);
	}
	prt(ans1,' ');prt(ans2);
	ret 0;
}
```

---

## 作者：x383494 (赞：3)

Luogu [P3336](https://www.luogu.com.cn/problem/P3336)有两（？）篇题解，亿篇被[Hack](https://www.luogu.com.cn/discuss/455534)了，另一篇也被[Hack](https://www.luogu.com.cn/discuss/552341)了，于是蒟蒻前来说说自己的思路。

~~来写黑题题解我是不是飘了orz~~

2023.1.18 upd: 更正一处错误

2023.6.28 upd: 被大佬 @aisib Hack 了，已更正

# 分析

其他大佬说的很明白，下降只能一直到 $0$，此处不再赘述。

# 第一问

可以参考[这篇带图文的题解](https://www.luogu.com.cn/blog/renfei147/solution-p3336)，这里补充一个空间上的优化。

考虑滚动数组。

原本是 $f_{i,0/1}$ 的 dp 数组，可以优化成两个变量 `up,down` ，分别表示原来的 $f_{i,0}$ 和 $f_{i,1}$。

# 第二问

约定：当前点的横纵坐标分别为 $x_1, y_1$,上一个点为 $x_0, y_0$，$dx=x_1-x_0$，$dy=y_1-y_0$.

这里不能**直接**用贪心（虽然数据里没有卡这一条），否则会出现最大值所在路线不合法的情况。

我的做法是用两个变量 `dtop` 和 `utop` 分别维护“一定合法的最大值”和“可能合法的更大值”，以下简写为 $u,d$；代码里还有 `ndt` 和 `nut`，表示这次修改的值，会在每次循环最后同步。

$d$ 是向下走到这个点的最大值，要接受这个值还要这个点向下走能到 $y=0$。
类似地，$u$ 是一定能接受的最大值。

如果 $dx=dy$，则 $d\leftarrow0$（因为只能向上走，所以舍去，也可以设置为 $u$）；

如果 $dx=-dy$，$d$ 和 $u$ 不必做任何变动，除非当前点的纵坐标为 $0$，那么 $u=\max(u, d)$；

否则，当前点和上一个点之间必定有转折点。可以证明，无论怎么走，向上走的总距离为 $s_{up}=\dfrac{dx+dy}{2}$，向下的距离为 $s_{down}=\dfrac{dx-dy}{2}$.

对于 `up` 不为 $0$ 的情况，按照贪心的思路，先向上走到一个尽可能高的地方 $h=y_0+s_{up}=y_1-s_{down}$ 可以取到可能的最优解，此时 $d\leftarrow\max(h, d)$ 更新 $d$ 的值。

否则，只能降到 $y=0$ 后尽快上升，$h=s_{up}$。

考虑 $u$ 的可能取值。显然这条路线要在最后一个 $y=0$ 的点后一路上升到 $(x_1, y_1)$（否则不满足有降有升且上升到当前点），问题转化为求 $(x_0, y_0)$ 到 $(x_1-y_1, 0)$ 的路线最高点。因为 $y=0$，所以 $u$ 和 $d$ 都可以接受。

值得注意的是，$x_0 \ge x_1-y_1$ 时，$u$ 不可能被更新，要特判（对应两个点太高路线不经过 $y=0$ 的情况）。

最后，输出 $\max(u,d)$ 即可。

# Code

```cpp
#include <cstdio>
#include <algorithm>
typedef long long ll;
constexpr int MAXK = 0xFe203;
constexpr int MODN = 19940417;
struct Pt { int x, y; } pts[MAXK];
bool operator<(Pt a, Pt b){return a.x<b.x;}
int qpow(int x, ll base){
    int ans=1;
    while(x){
        if(x&1) ans=(ans*base)%MODN;
        x>>=1;
        base = (base*base)%MODN;
    }
    return ans;
}
int main(){
    int in, ik;
    scanf("%d%d", &in, &ik);
    ik+=2;
    pts[0].x=0, pts[0].y=0, pts[1].x=in, pts[1].y=0;
    for(int i=2; i<ik; ++i){ scanf("%d%d", &pts[i].x, &pts[i].y); }
    std::sort(pts, pts+ik);
    ll up=1, down=0;
    int utop=0, dtop=0, nut=0, ndt=0;
    for(Pt *cur=pts+1; cur!=pts+ik; ++cur){
        Pt *last=cur-1;
        int dx = cur->x-last->x, dy = cur->y-last->y;
        utop=std::max(utop, cur->y);
		ndt = dtop, nut = utop;
        if(dx==0){
            continue;
        } else if(dx == dy){
            down=0; dtop=0; ndt=0;
        } else if(dx == -dy){
            down+=up; up=0;
            if(cur->y==0){
                nut = std::max(utop, dtop);
                up+=down;
                down=0;
            }
        } else {
            auto step_up=(dx+dy)/2, step_down=(dx-dy)/2;
            if(up) {
                ndt=std::max(dtop, last->y+step_up);
                nut=std::max(utop, last->y+step_up-cur->y);
            } else {
                ndt=std::max(dtop, cur->y+step_down-last->y);
                nut=std::max(utop, step_up-cur->y);
            }

            if(step_down-last->y<0){
                ndt=std::max(0, last->y+step_up);
                down=up;
                up=0;
            } else if(step_down-last->y>0){
                nut=std::max(nut, std::max(utop, dtop));

                if(last->y==0){
                    std::swap(up, down);    // mathmagical tricks
                }
                down = (((2*up+down)%MODN)*qpow(step_down-last->y-1, 2))%MODN;
                up = down;
                if(cur->y == 0){ 
                    down = 0; 
                }
            } else {
                ll wayup = (up+down)%MODN;
                down = up;
                up = wayup;
            }
        }
		utop = nut;
		dtop = ndt;
    }
    printf("%lld %d", (up+down)%MODN, std::max(utop, dtop));
    return 0;
}
```


---

## 作者：Mzk2333 (赞：2)

先做第一问。
显然离散化，发现函数图像和到每个点的导函数正负强相关，故考虑 $f_{i,\text{0/1}}$ 表示在离散化后**到达**第 $i$ 个点时导函数是正/负时的总方案数。 
转移时先排除掉函数值只能为 $\text{1,-1}$ 的情况。接下来按照函数能不能触底分类，记 $p=dy-dx$，其中 $dy,dx$ 表示函数 $y$ 值和 $x$ 值的变化量，则有
   
$p<0$ 时，函数不能触底，有 $f[i+1][1]=f[i][0]$  
$p=0$ 时，函数只能触底一次，有 $f[i+1][1]=f[i][0],f[i+1][0]=f[i][0]+f[i][1]$   
$p>0$ 时，函数可以触底多次，考虑将可以触底的部分一上一下组合，然后只考虑导函数为正的部分，每一个部分可以和上一个部分合成一个更大的凸起，也可以自成一个新的凸起，故此时情况为 $k=2^{\frac{p}2-1}$，转移为

$$
\begin{cases}
f[i+1][0]=2 \times k \times (f[i][0]+f[i][1]) ,& a[i+1].y>0\\\  
f[i+1][1]=2 \times k \times (f[i][0]+f[i][1])
\end{cases}  
$$

这样第一问就做完了。
对于第二问，我们考虑引入数组 $g$， 其中 $g_{i,\text{0/1}}$ 表示从第 $i$ 个点**出发**时的导函数**是否可以为**正/负。故有

$p<0$ 时，函数不能触底，有 $g[i][0]=1$  
$p=0$ 时，函数只能触底一次，有 $g[i][0]=1,g[i][1]=1$，特别地，当纵坐标为 $0$ 时，后者也为 $0$。   
$p>0$ 时，函数可以触底多次，此时转移同上。  

计算时先排除掉只能一直向上或向下的情况，然后对 $f,g$ 分讨即可。
```
#include<bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f 
#define int long long 

const int N=1e6+9,M=3e5+9;
const int mod=19940417;
#define fir first
#define sec second	

int n,k,ans,f[N][2],g[N][2];
pair<int,int> a[N];

int qpow(int a,int b,int p){
	int ret=1;
	while(b){
		if(b&1) ret=ret*a%p;
		a=a*a%p;
		b>>=1;
	}
	return ret;
}
signed main(){ 
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	
	cin>>n>>k;
	for(int i=1;i<=k;++i) cin>>a[i+1].fir>>a[i+1].sec;
	k+=2; 
	a[1].fir=a[1].sec=0;
	a[k].fir=n; a[k].sec=0;
	sort(a+1,a+k+1);
	k=unique(a+1,a+k+1)-a-1;
	
	f[1][1]=1; 
	for(int i=1;i<k;++i){
		if(a[i+1].fir-a[i].fir==a[i+1].sec-a[i].sec){
			f[i+1][0]=(f[i][0]+(a[i].sec==0)*f[i][1])%mod;
			g[i][0]=1;
		}
		else if(a[i+1].fir-a[i].fir==a[i].sec-a[i+1].sec){
			f[i+1][1]=(f[i][0]+f[i][1])%mod;
			g[i][1]=1;
		}
		else{
			int p=(a[i+1].fir-a[i].fir)-(a[i+1].sec+a[i].sec);
			p>>=1;
			if(p<0){
				f[i+1][1]=f[i][0];
				g[i][0]=1; 
			}
			else if(p==0){
				f[i+1][1]=f[i][0];
				f[i+1][0]=(f[i][0]+f[i][1])%mod;
				g[i][0]=1; g[i][1]=(a[i].fir!=0);
			}else{
				int q=qpow(2,p-1,mod);
				if(a[i+1].sec) f[i+1][0]=((2ll*f[i][0]+f[i][1])%mod*q)%mod;
				f[i+1][1]=((2ll*f[i][0]+f[i][1])%mod*q)%mod;
				g[i][0]=1; g[i][1]=(a[i].fir!=0);
			}
		}
	} 
	cout<<f[k][1]<<' ';
	
	ans=a[1].sec;
	for(int i=1;i<k;++i){
		ans=max(ans,a[i+1].sec);
		if(a[i+1].fir-a[i].fir==a[i+1].sec-a[i].sec) continue;
		else if(a[i+1].fir-a[i].fir==a[i].sec-a[i+1].sec) continue;
		else{
			int p=(a[i+1].fir-a[i].fir)-(a[i+1].sec+a[i].sec);
			p>>=1;
			if((a[i].sec==0 || (f[i][0] && g[i][0])) &&
			   (f[i+1][1] && (a[i+1].sec==0 || g[i+1][1])))
				ans=max(ans,(a[i+1].fir-a[i].fir+a[i+1].sec+a[i].sec)/2);
			if((a[i].sec==0 || (f[i][0] && g[i][0])) &&
			   (a[i+1].sec!=0 && f[i+1][0]))
				ans=max(ans,p+a[i].sec);
			if((a[i].sec!=0 && g[i][1]) &&
			   (f[i+1][1] && (a[i+1].sec==0 || g[i+1][1])))
			    ans=max(ans,p+a[i+1].sec);
			if((a[i].sec!=0 && g[i][1]) &&
			   (a[i+1].sec!=0 && f[i+1][0]))
			    ans=max(ans,p);
		} 
	} 
	cout<<ans;
}
```

---

## 作者：bmatrix (赞：2)

因为我也是看了大佬的题解才写的（第一问），自认为自己讲得不可能比他们再好了，但是因为好多第二问的题解都被hack了，所以这里详细讲一下第二问的正确做法。

管理大大求过啊QwQ

~~初中平几课堂开课啦~~

其实思路很简单，利用贪心的思想，能往上走就往上走，能走多高就走多高，来看这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/8wda4rse.png)

点 $A$ 是当前点，点 $B$ 是前一个点，点 $C$ 是这个路径能到达的最高点，设 $A$ 坐标是 $(x_1,y_1)$ ， $B$ 坐标为 $(x_0,y_0)$ 。

容易得出：
$$\because AD=x_1-x_0,BD=y_1-y_0=DE$$
$$\therefore AE=(x_1-x_0)-(y_1-y_0)=x_1-x_0+y_0-y_1$$
$$\therefore CF=\frac{1}{2}AE=\frac{x_1-x_0+y_0-y_1}{2}$$
$$\therefore y_C=y_1+CF=\frac{x_1-x_0+y_0+y_1}{2}$$

第二问答案就是所有 $C$ 的最大值，即：
```cpp
maxn=max(maxn,(x1-x0+y0+y1)>>1);
```

但是，需要注意的是，如果在 $B$ 点**不能往上走**，上面的公式就不好用了，比如这个hack：
```
18 3
2 2
4 2
12 6

ans:
1 6
```
画出来唯一解法是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/64l3z5mx.png)

但如果我们按上面的方法做，第二问的答案会是```8```，为什么呢？

如果我们仍按以上方法算，第二问会被认为这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/ddbll4by.png)

但显然这是错的，因为不满足题目所要求的**函数极小值为 $0$** 。

分析产生这种情况的原因：在计算第二问的时候，**没有考虑到前一个点不能往上走的情况**。

那么何时不能往上走呢？

也很简单，因为我们之前设 $f_{i,0/1}$ 为第 $i$ 个点上升/下降的方案数，则第 $i$ 个点不能上升就是 $f_{i,0}=0$ 的情况。

那么如果它不能上升，我们就让它下降到 $0$ ，以这个点作为我们之前分析的 $B$ 点，即：
```cpp
if(!f[i-1][1])x0=x0+y0,y0=0;
```
这样第二问就结束了。第二问本身不难，但问题出在没有把情况像第一问一样考虑全，导致一些想当然的错误做法，因此告诫自己：

**一定要在考虑问题时思考全面，实在不行把所有可能性罗列出来！**

---

## 作者：Shunpower (赞：1)

给我整吐了。

-----------------

**首要任务是读对题。**

题的意思其实是，整个折线每次下降就要碰到 $0$。于是直接设 $f_{i,0/1}$ 表示到达点 $i$ 时前面的折线是向下或向上的方案数。初始我们设置 $f_{0,0}=1$。

然后考虑怎么从上一个转移过来。

- $f_{i-1,0}$：
	- 考虑向上。此时我们要求 $y_{i-1}=0$，因为前面是向下的。
		- 考虑转移到 $f_{i,1}$，那么此时中间的长相：
		![](https://cdn.luogu.com.cn/upload/image_hosting/woo4l7sj.png)  
    考虑我们就是要取一个序列 $P$ 使得 $2\sum P=x_i-x_{i-1}-y_{i}$。不妨对 $\frac{x_i-x_{i-1}-y_i}{2}$ 运用插板，这就是 $2^{\frac{x_i-x_{i-1}-y_i}{2}-1}$。  
    特别地，如果 $x_i-x_{i-1}-y_i=0$，答案是 $1$：我们只有直接向上一种办法了。
		- 考虑转移到 $f_{i,0}$，那么此时中间的长相：
		![](https://cdn.luogu.com.cn/upload/image_hosting/v0ttln2w.png)  
		考虑我们依旧是要取一个序列 $P$ 使得 $2\sum P=x_i-x_{i-1}+y_i$，然而 $P$ 的最后一个元素需要大于 $y_i$。所以我们考虑先把后 $y_i$ 个元素拨给 $P_n$，随后你发现这也是 $2^{\frac{x_i-x_{i-1}-y_i}{2}-1}$。
	- 考虑向下。由于我们这个一旦向下就要下到 $0$，所以我们本质上是在对 $x_{i-1}+y_{i-1}$ 做上述的转移。  
   当然，也有可能向下还没下到 $0$ 就抵达我们要的那个点了，这种特判一下。
- $f_{i-1,1}$：
	- 考虑向上。
		- 考虑转移到 $f_{i,1}$，那么此时中间的长相：
		![](https://cdn.luogu.com.cn/upload/image_hosting/69j2f3nc.png)  
		考虑我们依旧是要取一个序列 $P$ 使得 $2\sum P=x_i-x_{i-1}-y_{i}+y_{i-1}$。特别地，序列的第一个元素需要大于 $y_{i-1}$。类似地，我们把前 $y_{i-1}$ 个元素拨给 $P_1$，这是 $2^{\frac{x_i-x_{i-1}-y_i-y_{i-1}}{2}-1}$。**然而前 $y_{i-1}$ 个元素也可以是 $0$ 个元素（直接向下走了），所以这里还要乘一个 $2$**，系数实际上是 $2^{\frac{x_i-x_{i-1}-y_i-y_{i-1}}{2}}$。  
    特别地，如果 $x_i-x_{i-1}=y_i-y_{i-1}$，那么我们只有直接向上一种办法了。
		- 考虑转移到 $f_{i,0}$，那么我们实际上是要取一个序列 $P$ 使得 $2\sum P=x_i-x_{i-1}+y_{i-1}+y_i$。特别地，序列的第一个元素需要大于 $y_{i-1}$，最后一个元素需要大于 $y_i$。类似地，我们把前 $y_{i-1}$ 个元素拨给 $P_1$，后 $y_i$ 个元素拨给 $P_n$，这也是 $2^{\frac{x_i-x_{i-1}-y_i-y_{i-1}}{2}-1}$。类似上面地，这里也需要乘一个 $2$，系数实际上是 $2^{\frac{x_i-x_{i-1}-y_i-y_{i-1}}{2}}$。  
    特别地，需要特判一下 $n=1$（只有一个凸起）的情况，这种情况我们的系数显然是错误的。
	- 考虑向下。由于我们这个一旦向下就要下到 $0$，所以我们本质上是在对 $x_{i-1}+y_{i-1}$ 做 $f_{i-1,0}$ 出发的转移。  
   当然，也有可能向下还没下到 $0$ 就抵达我们要的那个点了，这种特判一下。
		
数数的部分就做完了。

注意写的时候一定要想清楚，牢记状态的定义，否则转移就会乱飞。虽然上面的讨论已经把大部分情况都考虑到了，还是有些细节需要考虑一下。

作为一个直观的 dp 题，在诸多 Hack 数据的帮助下并不算很难调。

然后考虑第二问，显然我们可以在第一问的同时 dp 它。只需考虑每种转移能产生的最高点，在搞清楚每种转移的系数是怎么回事的情况下还是比较简单的。

注意如果不存在方案就不要转移它的最大值。

我自认为很清晰的代码（使用了一种具有争议，可能会被刻意构造叉掉的判断是否有方案的方式）：

```cpp
//Author:KIT / Shunpower
//Cloud Island & Rain Temperature
//May the force be with you and me.
#include <bits/stdc++.h>
#define ET return 0
#define fi first
#define se second
#define mp make_pair
#define pb emplace_back
#define ll long long
#define ull unsigned long long
#define inf INT_MAX
#define uinf INT_MIN
#define pii pair<int,int>
#define pll pair<ll,ll>
#define fr1(i,a,b) for(int i=a;i<=b;i++)
#define fr2(i,a,b) for(int i=a;i>=b;i--)
#define ld long double
#define il inline
using namespace std;
const int N=1e6+10;
const int mod=19940417;
int n,k;
int f[N][2];
int g[N][2];
vector <pii> p;
ll qpow(ll b,int p){
    if(!p) return 1;
    ll d=qpow(b,p>>1);
    if(p&1) return d*d%mod*b%mod;
    else return d*d%mod;
}
void add(int &x,int y){
    x+=y;
    if(x>=mod) x-=mod;
}
void mge(int &x,int y){
    x=max(x,y);
}
#define X(i) p[i].fi
#define Y(i) p[i].se
int main(){
#ifdef Ltp
    freopen("hack.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n>>k;
    fr1(i,1,k){
        int x,fx;
        cin>>x>>fx;
        p.push_back({x,fx});
    }
    p.push_back({0,0});
    p.push_back({n,0});
    sort(p.begin(),p.end());
    p.resize(unique(p.begin(),p.end())-p.begin());
    fr1(i,1,(int)p.size()-1) assert(p[i].fi!=p[i-1].fi);
    f[0][0]=1;
    g[0][0]=0;
    fr1(i,1,(int)p.size()-1){
        mge(g[i][0],Y(i));
        mge(g[i][1],Y(i));
        if(f[i-1][0]){
            if(Y(i-1)==0){
                int d=X(i)-X(i-1)-Y(i);
                if(d>0&&!(d&1)){
                    mge(g[i][0],max(g[i-1][0],d/2));
                    add(f[i][0],1ll*f[i-1][0]*qpow(2,d/2-1)%mod);
                }
            }
            else{
                if(X(i)-X(i-1)==Y(i-1)-Y(i)){
                    mge(g[i][0],g[i-1][0]);
                    add(f[i][0],f[i-1][0]);
                }
                else{
                    int d=X(i)-(X(i-1)+Y(i-1))-Y(i);
                    if(d>0&&!(d&1)){
                        mge(g[i][0],max(g[i-1][0],d/2));
                        add(f[i][0],1ll*f[i-1][0]*qpow(2,d/2-1)%mod);
                    }
                }
            }
        }//f[i-1][0]->f[i][0]
        if(f[i-1][0]){
            if(Y(i)!=0){
                if(Y(i-1)==0){
                    int d=X(i)-X(i-1)-Y(i);
                    if(d==0){
                        mge(g[i][1],g[i-1][0]);
                        add(f[i][1],f[i-1][0]);
                    }
                    else if(d>0&&!(d&1)){
                        mge(g[i][1],max(g[i-1][0],d/2));
                        add(f[i][1],1ll*f[i-1][0]*qpow(2,d/2-1)%mod);
                    }
                }
                else{
                    int d=X(i)-X(i-1)-Y(i-1)-Y(i);
                    if(d==0){
                        mge(g[i][1],g[i-1][0]);
                        add(f[i][1],f[i-1][0]);
                    }
                    else if(d>0&&!(d&1)){
                        mge(g[i][1],max(g[i-1][0],d/2));
                        add(f[i][1],1ll*f[i-1][0]*qpow(2,d/2-1)%mod);
                    }
                }
            }
        }//f[i-1][0]->f[i][1]
        if(f[i-1][1]){
            int d=X(i)-X(i-1)-Y(i)-Y(i-1);
            int d2=d+2*Y(i)+2*Y(i-1);
            bool fl=0;
            if(!(d2&1)&&d2/2!=Y(i)){
                mge(g[i][0],max(g[i-1][1],d2/2));
                add(f[i][0],f[i-1][1]),fl=1; 
            }
            if(d>0&&!(d&1)){
                mge(g[i][0],max(g[i-1][1],(d+2*Y(i-1))/2));
                add(f[i][0],1ll*f[i-1][1]*(qpow(2,d/2)-fl)%mod);
            }
        }//f[i-1][1]->f[i][0]
        if(f[i-1][1]){
            if(Y(i)!=0){
                if(Y(i)-Y(i-1)==X(i)-X(i-1)){
                    mge(g[i][1],g[i-1][1]);
                    add(f[i][1],f[i-1][1]);
                }
                else{
                    int d=X(i)-X(i-1)-Y(i)-Y(i-1);
                    if(d==0){
                        mge(g[i][1],g[i-1][1]);
                        add(f[i][1],f[i-1][1]);
                    }
                    else if(d>0&&!(d&1)){
                        mge(g[i][1],max(g[i-1][1],(d+2*Y(i-1))/2));
                        add(f[i][1],1ll*f[i-1][1]*qpow(2,d/2)%mod);
                    }
                }
            }
        }//f[i-1][1]->f[i][1]
        // cout<<p[i].fi<<' '<<p[i].se<<' '<<g[i][0]<<' '<<g[i][1]<<endl;
    }
    cout<<f[p.size()-1][0]<<" "<<g[p.size()-1][0]<<'\n';
    ET;
}
//ALL FOR Zhang Junhao.
```

---


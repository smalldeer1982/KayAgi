# [AHOI2017/HNOI2017] 大佬

## 题目描述

人们总是难免会碰到大佬。他们趾高气昂地谈论凡人不能理解的算法和数据结构，走到任何一个地方，大佬的气场就能让周围的人吓得瑟瑟发抖，不敢言语。你作为一个 OIer，面对这样的事情非常不开心，于是发表了对大佬不敬的言论。 大佬便对你开始了报复，你也不示弱，扬言要打倒大佬。现在给你讲解一下什么是大佬，大佬除了是神犇以外，还有着强大的自信心，自信程度可以被量化为一个正整数 $C$，想要打倒一个大佬的唯一方法是摧毁 Ta 的自信心，也就是让大佬的自信值**等于** $0$（恰好等于 $0$，不能小于 $0$）。由于你被大佬盯上了，所以你需要准备好 $n$ 天来和大佬较量，因为这 $n$ 天大佬只会嘲讽你动摇你的自信，到了第 $n+1$ 天，如果大佬发现你还不服，就会直接虐到你服，这样你就丧失斗争的能力了。

你的自信程度同样也可以被量化，我们用 $\mathrm{mc}$ 来表示你的自信值**上限**。在第 $i \ (i\ge 1)$ 天，大佬会对你发动一次嘲讽，使你的自信值减小 $a_i$，如果这个时刻你的自信值**小于** $0$ 了，那么你就丧失斗争能力，也就**失败**了（特别注意你的自信值为 $0$ 的时候还可以继续和大佬斗争）。 在这一天，大佬对你发动嘲讽之后，如果你的自信值仍大于等于 $0$，你**能且仅能**选择如下的行为**之一**：

1. 还一句嘴，大佬会有点惊讶，导致大佬的自信值 $C$ 减小 $1$。
2. 做一天的水题，使得自己的当前自信值增加 $w_i$，并将新自信值和自信值上限 $\mathrm{mc}$ 比较，若新自信值大于 $\mathrm{mc}$，则新自信值更新为 $\mathrm{mc}$。例如，$\mathrm{mc} = 50$，当前自信值为 $40$，若 $w_i = 5$，则新自信值为 $45$，若 $w_i = 11$，则新自信值为 $50$。
3. 让自己的等级值 $L$ 加 $1$。
4. 让自己的讽刺能力 $F$ 乘以自己当前等级 $L$，使讽刺能力 $F$ 更新为 $F\cdot L$。
5. 怼大佬，让大佬的自信值 $C$ 减小 $F$。并在怼完大佬之后，你自己的等级 $L$ 自动降为 $0$，讽刺能力 $F$ 降为 $1$。由于怼大佬比较掉人品，所以这个操作只能做**不超过两次**。

**特别注意**的是，在任何时候，你**不能**让大佬的自信值**为负**，因为自信值为负，对大佬来说意味着屈辱，而大佬但凡遇到屈辱就会进化为更厉害的大佬直接虐飞你。在第 $1$ 天，在你被攻击之前，你的自信是满的（初始自信值等于自信值上限 $\mathrm{mc}$），你的讽刺能力 $F$ 是 $1$，等级是 $0$。


现在由于你得罪了大佬，你需要准备和大佬正面杠，你知道世界上一共有 $m$ 个大佬，他们的嘲讽时间都是 $n$ 天，而且第 $i$ 天的嘲讽值都是 $a_i$。不管和哪个大佬较量，你在第 $i$ 天做水题的自信回涨都是 $w_i$。这 $m$ 个大佬中**只会有一个**来和你较量（$n$ 天里都是这个大佬和你较量），但是作为你，你需要知道对于任意一个大佬，你是否能摧毁他的自信，也就是让他的自信值恰好等于 $0$。和某一个大佬较量时，其他大佬不会插手。

## 说明/提示

- 对于 $20\%$ 的数据，$1\le n\le 10$；
- 另有 $20\%$ 数据，$1\le C_i,n,\mathrm{mc}\le 30$；
- 对于 $100\%$ 的数据，$1\le n, \mathrm{mc}\le 100, 1\le m\le 20; 1\le a_i, w_i\le\mathrm{mc}, 1\le C_i\le 10^8$。

## 样例 #1

### 输入

```
30 20 30
15 5 24 14 13 4 14 21 3 16 7 4 7 8 13 19 16 5 6 13 21 12 7 9 4 15 20 4 13 12
22 21 15 16 17 1 21 19 11 8 3 28 7 10 19 3 27 17 28 3 26 4 22 28 15 5 26 9 5 26
30
10
18
29
18
29
3
12
28
11
28
6
1
6
27
27
18
11
26
1```

### 输出

```
0
1
1
0
1
0
1
1
0
0
0
1
1
1
1
1
1
0
0
1```

# 题解

## 作者：yybyyb (赞：47)

这题好神啊。

首先仔细观察几种操作，发现和自己的自信值有关的只有一个。
因此，自己死不死与怼大佬无关。
所以，相当于拆成两个部分，一个是怼大佬，另外一个是让自己的自信值大于$0$。

所以，我们先做一次$dp$，求出最多可以空出多少天来怼大佬，也就是刷水题的最少次数。

这样，恢复自信与怼大佬两个分开，互相不影响。

现在的问题就变成了给你$N$天，能否怼死大佬？

我们怼大佬只与两个因素有关：天数和嘲讽值。

因此，求出所有的可行的天数和嘲讽值的集合，按照嘲讽值从大到小排序。至于怎么求，暴力$BFS$+$Hash$判重就行了。

不怼或者怼一次解决大佬的情况很容易判断（如果你只判断这个就可以拿到$40$分了。。）

现在要解决的问题是怼两次大佬。

不妨设两次怼大佬花费的天数分别是$d1,d2$，总共可以怼$D$天。嘲讽值分别是$f1,f2$。

我们可以列出不等式：
$$f1+f2<=C,f1+f2+(D-d1-d2)>=C$$
考虑按照$f$为第一关键字，$d$为第二关键字排序。

现在维护两个指针，分别从大往小和从小往大枚举，每次保证$fi+fj<=C$

因为我们固定了一个方向，不妨固定了$fi$。

所以，此时的定值是$fi,di,D,C$。
那么，这个时候要求的就是$f2-d2$的最大值。

在从小到大扫的过程中，显然是单调的，因此不需要再从头开始扫，直接继承上一次的指针位置继续向后即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define RG register
#define MAX 111
#define ft(i) (zt[i].first)
#define sd(i) (zt[i].second)
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int f[MAX][MAX];
int n,m,MC,Day,a[MAX],w[MAX],C[MAX];
struct Node{int i,F,L;};
pair<int,int> zt[1111111];
int tot,mx;
int MOD=1000007;
struct Hash
{
	struct Line{int x,y,next;}e[1111111];
	int h[1000007+1],cnt;
	void Add(int x,int y)
	{
		int pos=(1ll*x*101+y)%MOD;
		e[++cnt]=(Line){x,y,h[pos]};h[pos]=cnt;
	}
	bool Query(int x,int y)
	{
		int pos=(1ll*x*101+y)%MOD;
		for(int i=h[pos];i;i=e[i].next)
			if(e[i].x==x&&e[i].y==y)return true;
		return false;
	}
}Map;
void BFS()
{
	queue<Node> Q;Q.push((Node){1,1,0});
	while(!Q.empty())
	{
		Node u=Q.front();Q.pop();
		if(u.i==Day)continue;
		Q.push((Node){u.i+1,u.F,u.L+1});
		if(u.L>1&&1ll*u.F*u.L<=1ll*mx&&!Map.Query(u.F*u.L,u.i+1))
		{
			Q.push((Node){u.i+1,u.F*u.L,u.L});
			zt[++tot]=make_pair(u.F*u.L,u.i+1);
			Map.Add(u.F*u.L,u.i+1);
		}
	}
}
int main()
{
	n=read();m=read();MC=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)w[i]=read();
	for(int i=1;i<=m;++i)mx=max(mx,C[i]=read());
	for(int i=1;i<=n;++i)
		for(int j=a[i];j<=MC;++j)
		{
			f[i][j-a[i]]=max(f[i-1][j]+1,f[i][j-a[i]]);
			f[i][min(j-a[i]+w[i],MC)]=max(f[i-1][j],f[i][min(j-a[i]+w[i],MC)]);
		}
	for(int i=1;i<=n;++i)
		for(int j=1;j<=MC;++j)Day=max(Day,f[i][j]);
	BFS();sort(&zt[1],&zt[tot+1]);
	for(int i=1;i<=m;++i)
	{
		if(C[i]<=Day){puts("1");continue;}
		bool fl=false;int mm=1e9;
		for(int j=tot,k=1;j;--j)
		{
			while(k<tot&&ft(k)+ft(j)<=C[i])
				mm=min(mm,sd(k)-ft(k)),++k;
			if(mm+C[i]-ft(j)<=Day-sd(j)){fl=true;break;}
			if(ft(j)<=C[i]&&C[i]-ft(j)<=Day-sd(j)){fl=true;break;}
		}
		fl?puts("1"):puts("0");
	}
	return 0;
}

```


---

## 作者：Piwry (赞：25)

这道题成功让我对 `枚举/暴力` 这个标签留下了深刻的印象（

另外感谢 loj 的 [这份](https://loj.ac/submission/8507) 提交记录（之前的 rk1），本文的大部分优化都参考自这里，~~虽然这码风以及代码没有注释让我看得很费劲...~~

## 解析

先将题面中每天能进行的 行为 $1$ ~ $5$，记为 操作 $1$ ~ $5$

### 0. dp 部分

首先要发现，保持自己自信值不低于 $0$ 的操作和攻击大佬的操作是完全**没有关联**的

于是我们可以先 dp 出最大的能用于攻击大佬的操作的天数。设为 $M$

这个直接 $O(n^2)$ 暴力 dp 就行了，状态也很好设，这里不提了

不过有一点要注意的是，虽然题目没有明说，但**战斗在击败大佬时就结束了**，dp 时需要注意

### 1. bfs 及剪枝

$C_i$ 的范围有点大，直接 dp 可能不太可做

发现操作 $5$ 至多做两次，因此我们可以考虑求出得到每个 $F$ （以 $\max\{C_i\}$ 为上界）所需的最少的天数，然后再分类讨论

显然 $F$ 只能有 $100$ 以内的质数的质因子；而 $100$ 以内的质数只有 $25$ 个，直觉告诉我们 $F$ 可能的取值不会很多。打个爆搜，可以发现 $F$ 的取值最多只有约 $10^6$ 种

想要知道得到每个 $F$ 所需的最少的天数，打 bfs 就可保证复杂度了，总复杂度为总的状态数 乘 在每个状态做的操作的复杂度

但当你兴致勃勃地去打 bfs 时，会发现 “状态” 中不仅包含 $F$，也必须包含 $L$：因为 $L$ 关系到状态的儿子情况（或者说转移？其实这也可归类于 dp）及所需的天数

而我们在每个状态只需考虑：

1. 将 $L$ 加一（操作 $3$）
2. 将 $F$ 乘 $L$（操作 $4$）

虽然这是 $O(1)$ 的，但 $F$ 的取值最多约有 $10^6$ 种，$L$ 的取值最多约有 $10^2$ 种，两者相乘一下复杂度肯定会炸

&nbsp;

考虑剪枝。显然可以发现，当一个状态的 $F\cdot L$ 大于 $\max\{C_i\}$ 时，它肯定就不能再接着向下搜索了。我们不将这些状态加入队列，只**统计这些状态**（统计具体实现可见代码）

这个剪枝看起来很弱，但实际上优化幅度很大，我们粗略地估计一下：

1. 对于 $F\leq 10^6$，约有 $10^5$ 种；它们的 $L$ 的取值约有 $10^2$ 种；共有约 $10^7$ 种组合
2. 对于 $10^6<F\leq 10^7$，约有 $2\cdot 10^5$ 种；它们的 $L$ 的取值约有 $10$ 种；共有约 $2\cdot 10^6$ 种组合
3. 对于 $10^7<F\leq 10^8$，约有 $6\cdot 10^5$ 种；它们的 $L$ 的取值低于 $10$ 种，就取平均 $5$ 种；共有约 $3\cdot 10^6$ 种组合

可以发现总的状态数的估值还不到 $2\cdot 10^7$

其实仔细想想，这种优化幅度也是在预料之中的。因为在较小的值域内，素数的密度会相对较大；对于仅由 $100$ 内质数组成的 $F$，一定大部分都分布在较大的值域范围内

### 2. 查询表的优化

（好像这个小标题可以有两种解读方法...）

虽然 bfs 得到的是到达每个状态所需的最小天数，但每个 $F$ 都有可能和不同的 $L$ 组合；且我们也得对每个状态判重

用平衡树肯定是行不通的；如果用哈希表，并用好一些的 hash 函数，也勉强可以。这里有一个我自己乱搞得到的 hash 函数，性能还不错：

```cpp
const int M =1e7+19;

inline int hsh(int F, int L){
	return (F+C_max/n*L)%M;
}
```

其中 `C_max` 就是 $\max\{C_i\}$，`n` 就是 $n$

如采用挂链法实现，这个 hash 函数最坏产生的最大冲突数只有 $23$，且总共和其它元素产生冲突的元素只有约 $\frac 1 3$

&nbsp;

但可以发现，我们仅仅是想知道每个状态**是否被访问过**，并无储存其它的信息；因此可以想到用 `bitset` 来充当查询表（可以手写，也可以用 `stl` 的）

不过显然对每个 $L$ 开一个 $10^8$ 位的 `bitset` 是行不通的。我们回想上一节做的剪枝，可以想到对于出现在队列中的每个 $L$，其对应的 $F$ 的取值**也是有上限的**；例如对于 $L=100$，就有 $F\leq 10^6$

于是我们可以想到，对每个 $L$ 只开适当大小的 `bitset`；或者干脆在一个大 `bitset` 里给不同的 $L$ 划分出不同大小的区域

具体来说，每个 $L$ 的区域是 $\frac {\max\{C_i\}} {L}$；若 $L\leq 100$，那么大 `bitset` 的位数就为 $\sum\limits_{k=1}^{100}{\frac {\max\{C_i\}} {k}}$。把里面的 $\max\{C_i\}$ 拆出来，显然就是一个调和级数的前 $100$ 项的求和；而 $\sum\limits_{k=1}^{100}{\frac {1} {k}}$ 只有大约 $5$

于是我们只需开一个约 $5\cdot 10^8$ 的 `bitset`，只需约 `60MB`，完全开得下

### 3. 求得答案

现在我们已经知道了每个 $F$ 的取值及得到这个 $F$ 所需的最少天数，还有最多的用于攻击的天数 $M$

我们先按 $F$ 的大小从小到大排序，将得到的序列的第 $j$ 项的 $F$ 的值标记为 $F_j$，得到 $F_j$ 的最少天数再**加一**（也就是操作 $5$ 的消耗）记为 $d_j$

#### 情况 $1.$

如果满足 $M\geq C_i$，

我们可以直接用 操作 $1$ 将大佬击败

这个直接判断就行了

#### 情况 $2.$

如果 $\exists j$，满足：

1. $F_j\leq C_i$
2. $F_j-d_j+M\geq C_i$

我们可以用一次 操作 $5$ 加若干次（可能为 $0$ 次） 操作 $1$ 将大佬击败

因为 $F$ 至多有约 $10^6$ 种，这个暴力扫一遍就行了

#### 情况 $3.$

如果 $\exists j,k$，满足：

1. $F_j+F_k\leq C_i$
2. $F_j-d_j+F_k-d_k+M\geq C_i$
3. $M-d_j-d_k\geq 0$

接着可以用两次 操作 $5$ 加若干次（可能为 $0$ 次） 操作 $1$ 将大佬击败

这个暴力找会 T

首先可以发现当 $1., 2.$ 满足时，$3.$ 也一定满足

接着注意到随着 $j$ 的增大，最大的满足 $1.$ 的 $k$ 是**单调不增**的（注意我们已经排好序了）

于是可以在枚举 $j$ 的时候，另设一个指针随着 $j$ 一起移动，维护的是对于某个 $j$ 满足 $1.$ 的最大的下标 $k$

&nbsp;

接着问题就转化成：对于确定的 $j, r$，且对于任意 $1\leq k\leq r$ 均满足 $1.$，问是否存在 $1\leq k\leq r$ 满足 $2.$

可以发现使 $F_k-d_k$ 尽量大总是不劣的。于是只需维护一个前缀的最大值即可

## CODE

注意代码中 bfs 的是：得到每个 $F$，并且做一次操作 $5$ 后**剩下的**最多的天数。于是一些相关的代码也有改动。原因是当时敲代码时顺手就这么写了，现在写完题解懒得改了X

另外，在 bfs 中还避免了 $L\leq 1$ 的状态出现，因为这是没有意义的（还不如直接做 操作 $1$）。于是我还把 $L=1$ 的 `bitset` 空间拿来记录每个 $F$ 是否出现过了

关于统计，注意虽然我们不把 $L\cdot F>\max\{C_i\}$ 的状态放入队列，但它**仍有可能是合法的**，只要用掉的天数不超过最大天数就行；因此注意对这种状态，虽然不把它放入队列，但还是要统计的

代码里还有许多 “魔数” 定义的数组大小，这些都是我分析数据范围上界得出的X

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <bitset>
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast", "-funroll-loops", "-fdelete-null-pointer-checks")
#pragma GCC target("ssse3", "sse3", "sse2", "sse", "avx2", "avx")
using std::max;
using std::sort;
using std::bitset;

const int MAXN =120;

/*------------------------------Set------------------------------*/

bitset<(int)5.2e8> vis;
int start_chunk_L[MAXN];/*每个 L 的区块的开始下标减一。L = 1 的区块则用来记录每个 F 的第一次出现*/

void pre_set(const int &n, const int &C_max){
	for(int i =2; i <= n; ++i)
		start_chunk_L[i] =start_chunk_L[i-1]+C_max/(i-1);
}

inline void insert(const int &F, const int &L){ vis[start_chunk_L[L]+F] =1; }

inline bool find(const int &F, const int &L){ return vis[start_chunk_L[L]+F]; }

/*------------------------------res_F------------------------------*/

struct qaq{
	int F, day_left;
	
	qaq(){}
	qaq(const int &F_in, const int &day_left_in):F(F_in), day_left(day_left_in){}
	
	bool operator < (const qaq &B) const{
		return F < B.F;
	}
}res_F[(int)1e6];
int tot;

/*------------------------------Bfs------------------------------*/

struct queue{
	int F, L, day_left;
	queue(){}
	queue(const int &F_in, const int &L_in, const int &day_left_in):F(F_in), L(L_in), day_left(day_left_in){}
}q[(int)4e6], *head =q, *tail =q;

inline void push_insert(const int &F, const int &L, const int &day_left){
	if(!find(F, L)){
		insert(F, L);
		*tail =queue(F, L, day_left);
		++tail;
	}
}

void bfs(const int &max_day_to_attack, const int &C_max){
	/*这里也没添加 F=1 的最优情况，因为这样还不如直接做操作 1*/
//	res_F[tot++] =qaq(1, max_day_to_attack);
	push_insert(1, 2, max_day_to_attack-2);/*这里避免出现 L 为 0, 1 的状态，因为这样还不如直接做操作 1*/
	while(head != tail){
		queue *front =head++;
		if(front->day_left > 1){/*如果是 day_left = 1 的话，即使达到了对应的 F 也没法做操作 5*/
			/*这里用除法就不用转 ll 了*/
			if(C_max/front->F >= front->L+1)
				push_insert(front->F, front->L+1, front->day_left-1);
			if(C_max/front->F/front->L/front->L >= 1)/*1. 如果相乘后还能接着提升 F*/
				push_insert(front->F*front->L, front->L, front->day_left-1);
			if(C_max/front->F/front->L >= 1){/*2. 如果相乘后合法*/
				front->F *=front->L;
				if(!find(front->F, 1)){/*<- L = 1 的区块则用来记录每个 F 的第一次出现*/
					insert(front->F, 1);
					/*下面 day_left 共 -2，一天用来提升 F，一天用来做操作 5*/
					res_F[tot++] =qaq(front->F, front->day_left-1-1);
				}
			}
		}
	}
}

/*------------------------------Dp-max_day_to_attack------------------------------*/

int dp[MAXN][MAXN];/*第 i 天，剩余 j 自信值，[1, i] 天中最大的空闲天数*/

/*------------------------------Main------------------------------*/

int a[MAXN], w[MAXN], C[MAXN];
int F_max_pre[(int)1e6];/*res_F 前缀的 F+day_left 的最大值*/

int main(){
	int n, m, mc, C_max =0;
	scanf("%d%d%d", &n, &m, &mc);
	for(int i =1; i <= n; ++i)
		scanf("%d", &a[i]);
	for(int i =1; i <= n; ++i)
		scanf("%d", &w[i]);
	for(int i =0; i < m; ++i){
		scanf("%d", &C[i]);
		C_max =max(C_max, C[i]);
	}
	
	/*暴力 dp 出最多能用来攻击的天数*/
	memset(dp, -0x3f, sizeof(dp));/*-0x3f 代表状态不合法 ( 活不到这种状态 )*/
	dp[0][mc] =0;
	for(int i =0; i < n; ++i)
		for(int j =a[i+1]; j <= mc; ++j){
			dp[i+1][j-a[i+1]] =max(dp[i+1][j-a[i+1]], dp[i][j]+1);
			if(j-a[i+1]+w[i+1] <= mc)
				dp[i+1][j-a[i+1]+w[i+1]] =max(dp[i+1][j-a[i+1]+w[i+1]], dp[i][j]);
			else
				dp[i+1][mc] =max(dp[i+1][mc], dp[i][j]);
		}
	/*虽然没有明说，但在击败大佬后战斗就结束了 (*/
	/*下面这段就是在找能活到的最后一天，这一天的最大 dp 值*/
	int max_day_to_attack =0;
	for(int i =1; i <= n; ++i)
		for(int j =0; j <= mc; ++j)
			max_day_to_attack =max(max_day_to_attack, dp[i][j]);
	
	/*处理出得到每个 F 并使用后的最大的剩余天数，以及 F_max_pre[.]*/
	pre_set(n, C_max);
	bfs(max_day_to_attack, C_max);
	sort(res_F, res_F+tot);
	for(int i =0, mx =-0x3f3f3f3f; i < tot; ++i){
		mx =max(mx, res_F[i].F+res_F[i].day_left);
		F_max_pre[i] =mx;
	}
	
	for(int i =0; i < m; ++i){
		bool able_to_beat =0;
		if(max_day_to_attack >= C[i])
			able_to_beat =1;
		else{
			for(int j =0, k =tot-1; j < tot; ++j){
				/*一次 操作 5 击败*/
				if(res_F[j].F <= C[i] && res_F[j].F+res_F[j].day_left >= C[i]){
					able_to_beat =1;
					break;
				}
				/*两次 操作 5 击败*/
				while(k >= 0 && res_F[j].F+res_F[k].F > C[i])/*k 单调不增*/
					--k;
				if(k >= 0 && res_F[j].F+res_F[j].day_left+F_max_pre[k]-max_day_to_attack >= C[i]){
					able_to_beat =1;
					break;
				}
			}
		}
		if(able_to_beat)
			puts("1");
		else
			puts("0");
	}
}
```

---

## 作者：DOTime (赞：21)

标签：DP+map（Hash）+单调性

题解：


觉得这道题很妙，题目说每天每天有那么多选择，但是其实只要不死，那么选择最大伤害可以枚举，而不死又可以DP。

具体来说：首先要保证不死，那么我们设dp[i][j]代表在前i天，第i天的自信值为j，那么前i天中可以最多不刷题几天，也就是，可以用来打伤害。其实就相当于全部的状态都枚举出来的裸DP。

做完这一步，我们取dp数组的最大值，也就是我最多有多少天可以使用。假设D天。

在D天中，要选择3、4、5即可，剩下的天数，多退少补，执行1操作到正好即可。

设两次怼大佬的情况分别为（d1，f1）、（d2，f2），即花费多少天打出多少伤害。假设大佬生命为HP，那么：

HP-f1-f2>=0，否则大佬生命值就为负了，然后还要满足能打死，也就是HP-f1-f2<=D-d1-d2，也就是大佬剩下的生命我要能在剩余天数内执行1操作打完。

当然这是怼两次的情况，怼一次就是HP-f1>=0 && HP-f1<=D-d1即可，不怼就是 HP>=0 && HP<=D即可。只要有符合条件的就是1.

我们bfs+判重的枚举出所有可能的（d，f），然后以f为第一关键字，d为第二关键字排序。按照f从大到小的枚举第一次怼，然后发现这个是有单调性的：我们移项D>=HP-f1+d1-f2+d2，f1,d1是枚举的，那么自然-f1+d2最小即可。那么在满足f1+f2<=HP的条件下，增大f2，即指针向后扫，每次取-f1+d2最小，然后比较，O(状态数)扫过去即可。

```cpp
http://www.cnblogs.com/D-O-Time/p/7953435.html
 1 #include<queue>
 2 #include<cstdio>
 3 #include<cstring>
 4 #include<iostream>
 5 #include<algorithm>
 6 #define LL long long
 7 #define pa pair<int,int>
 8 using namespace std;
 9 const int MAXN=2100000,mod=3587201;
10 pa Q[MAXN];
11 int n,m,mc,D,MAXC,tp,Maxsize;
12 int dp[105][105],a[105],w[105],C[105];
13 struct ed {int step,F,L;};
14 queue<ed>Que;
15 struct ED
16 {
17   struct gg{int x,y,Next;}edge[MAXN];
18   int top,head[mod+5];
19   void insert(int x,int y)
20   {
21     int tmp=((LL)x*100+y)%mod;
22     edge[++top]=(gg){x,y,head[tmp]};head[tmp]=top;
23   }
24   bool query(int x,int y)
25   {
26     int tmp=((LL)x*100+y)%mod;
27     for(int i=head[tmp];i;i=edge[i].Next)
28       if(x==edge[i].x&&y==edge[i].y)return 1;
29     return 0;
30   }
31 }map;//手写map，Hash判重
32 inline int gi() { int res; scanf("%d",&res); return res; }
33 void prepare()
34 {
35   for(int i=1;i<=n;i++)
36     for(int j=a[i];j<=mc;j++)
37       {
38         dp[i][j-a[i]]=max(dp[i][j-a[i]],dp[i-1][j]+1);
39         int tmp=min(mc,j-a[i]+w[i]);
40         dp[i][tmp]=max(dp[i][tmp],dp[i-1][j]);
41       }
42   for(int i=1;i<=n;i++)
43     for(int j=0;j<=mc;j++)
44       D=max(D,dp[i][j]);
45 }
46 void bfs()
47 {
48   Que.push((ed){1,1,0});//初始状态：使用一天，打出1伤害，等级0。
49   while(!Que.empty())
50     {
51       ed now=Que.front();
52       Que.pop();
53       if(now.step<D)
54         {
55           Que.push((ed){now.step+1,now.F,now.L+1});//加1等级
56           if(now.L>1 && (LL)now.F*now.L<=(LL)MAXC && !map.query(now.F*now.L,now.step+1))//注意爆int，hash炸掉了也没事。
57             {
58               ed tmp=(ed){now.step+1,now.F*now.L,now.L};
59               Que.push(tmp);
60               Q[++tp]=(pa){tmp.F,tmp.step};//此处才加入队列，不能直接从Que取出来就加入，因为只加等级的状态是不优的，只有乘了，才更好。
61               map.insert(tmp.F,tmp.step);
62             }
63         }
64     }
65 }
66 int main()
67 {
68   freopen("dalao.in","r",stdin);
69   freopen("dalao.out","w",stdout);
70   n=gi();m=gi();mc=gi();
71   for(int i=1;i<=n;i++)a[i]=gi();
72   for(int i=1;i<=n;i++)w[i]=gi();
73   for(int i=1;i<=m;i++)C[i]=gi(),MAXC=max(MAXC,C[i]);
74   prepare();  bfs();
75   sort(Q+1,Q+tp+1);
76   for(int i=1;i<=m;i++)
77     {
78       if(C[i]<=D) {puts("1"); continue;}
79       int flag=0,mi=0x3f3f3f3f;
80       for(int j=tp,k=1;j>=1;j--)//按照单调性找是否有解。
81         {
82           while(k<tp && Q[k].first+Q[j].first<=C[i]) mi=min(mi,Q[k].second-Q[k].first) , k++;
83           if(mi+Q[j].second-Q[j].first+C[i]<=D) {flag=1; break;}
84           if(Q[j].first<=C[i] && C[i]-Q[j].first+Q[j].second<=D) {flag=1; break;}
85         }
86       printf("%d\n",flag);
87     }
88   return 0;
89 }
```

---

## 作者：lcjqwq (赞：10)

### Description

你现在要怼 $m$ 个大佬，第 $i$ 个大佬的自信值是 $C_i$ 。每次怼大佬之前，你的自信值是 $mc$，等级 $L=0$，嘲讽值 $F = 1$。对于每一个大佬，你都有 $n$ 天时间来怼大佬。无论哪个大佬，他们都会在第 $i$ 天使你的的自信值下降 $a_i$ 如果你的自信值为负数，那么你失败了。在第 $i$ 天，你可以干一下事情中的恰好一件：

1. 使得大佬自信值下降 $1$
2. 使得自己的自信值增加 $w_i$ 
3. 把自己的等级 $+1$ 
4. 把自己的 $F$ 乘上 $L$
5. 怼大佬，使得大佬的自信值下降 $F$，之后$L=0$  ，$F=1$

如果中途大佬自信值为负数，你失败了。若大佬自信值恰好为 $0$ ，则你成功了。

对于每个大佬求你能否成功。

### Solution

首先，可以发现，怼大佬和活下来两件事是互相独立的。并且怼大佬只与天数相关。显然天数越多越有可能。

所以先用一遍简单 dp 得出最多能剩下多少天来怼大佬并且保证自己活下来。设最多天数是 $D$ 。

然后用一遍 BFS 的出所有二元组 $(d, f)$ 表示用了 $d(<D)$  天并且此时 $F = f$ 。注意去重。

你能怼死大佬有三种情况：

1. 不怼大佬。只执行 $1$ 操作。此时需要满足 $C_i \leq D$ 
2. 只怼一次大佬。这时能怼死大佬需要满足存在一个二元组 $(d',f')$ 使得 $f' \leq C_i$ 并且 $f'+D - d \ge C_i$ （一次不能怼死，用 $1$ 操作耗死）
3. 怼两次。可以发现，若两次分别是 $(d_1,f_1), (d_2, f_2)$ 则类似于第二种情况，有 $f_1+f_2\leq C_i$ 并且 $f_1+f_2+(D-d_1-d_2) \ge C_i$ 。显然，对于一个 $f_i$ ，只有最小的那个 $d_i$ 才是最优的。所以我们对每个 $f$  只保存最小的 $d$ ，并且按照 $f$ 排序。由于需要满足$f_1+f_2\leq C_i$， 就可以直接用双指针扫一遍，中途判断是否存在 $f_1+f_2+(D-d_1-d_2) \ge C_i$ 即可。

由于 $f$ 增长的很快，导致二元组不会特别多，于是可以通过此题。

### Code

[看代码戳这里](https://acfunction.github.io/2019/06/21/BZOJ4828/#Code)

---

## 作者：xin700 (赞：5)

正解： dp + map + bfs

首先看到这个神题，第一感觉就是不可做，但是经过长时间的理解读题之后，发现这个题目还是很好理解的，根据题目的意思下 ~~暴搜~~ [XIN队算法](https://www.luogu.com.cn/blog/liurongxin/xin-dui-suan-fa)也是很好打出的

首先考虑部分 $40pts$

我们设置递归函数 `xin_team()`

之后在设置所需要的变量：

`day self him f l cnt`

分别代表：现在的时间，自己的自信值，大佬的自信值，自己的讽刺值，现在的等级和使用讽刺的次数

理论上复杂度为 $\mathcal O(5^n)$，实际上要低的多。

所以可以得出 $40pts$ 解法：
```cpp
#include<cmath>
#include<queue>
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define int long long
#define m(c,num) memset(c,num,sizeof c)
#define INF 0x7f7f7f7f
#define debug cout<<"debug"<<endl
#define freopen eat = freopen
#define scanf a14 = scanf
#define eps (1e-8)
namespace xin_io
{
	#define gc() p1 == p2 and (p2 = (p1 = buf) + fread(buf,1,1<<20,stdin),p1 == p2) ? EOF : *p1++
	char buf[1<<20],*p1 = buf,*p2 = buf; FILE *eat; int a14;
	inline void openfile() {freopen("t.txt","r",stdin);}
	inline void delfile()  {freopen("o.txt","w",stdout);}
	inline int get()
	{
		int s = 0,f = 1;register char ch = gc();
		while(!isdigit(ch))
		{if(ch == '-') f = -1;ch = gc();}
		while(isdigit(ch))
		{s = s * 10 + ch - '0';	ch = gc();}
		return  s * f;
	}
}
using namespace xin_io;
static const int maxn = 1e3+10;
namespace xin
{
	int a[maxn],c,w[maxn],mc,m,n;
	bool ok;
	void dfs(int tim,int self,int him,int f,int l,int cnt)
	{
		if(ok)return ;
		if(!him) {ok = true; return;}
		self -= a[tim];
		if(tim > n) return;
		if(self < 0 or him < 0 or cnt > 2) return;
		dfs(tim+1,self,him-1,f,l,cnt);
		dfs(tim+1,min(self + w[tim],mc),him,f,l,cnt);
		dfs(tim+1,self,him,f,l+1,cnt);
		dfs(tim+1,self,him,f*l,l,cnt);
		if(cnt + 1 <= 2) 
		dfs(tim+1,self,him-f,1,0,cnt+1);
	}
	inline short main()
	{
	#ifndef ONLINE_JUDGE
		openfile();
	#endif
		n = get(); m = get(); mc = get();
		for(register int i=1;i<=n;++i) a[i] = get();
		for(register int i=1;i<=n;++i) w[i] = get();
		while(m--)
		{
			ok = 0;
			c = get();
			dfs(1,mc,c,1,0,0);
			if(ok) printf("1\n");
			else printf("0\n");
		}
		return 0;
	}
}
signed main() {return xin::main();}
```
接下来我们考虑正解：

对于我们真正需要的，其实就是要将大佬的自信值减少到 $0$ ，所以，我们的 **最佳战略** 就可以分为两个步骤：

**1.养精蓄锐**

**2.开始攻击**

我们设置 $f_{i,j}$ 数组来计算养精蓄锐的时间，可以有 $dp$ 转移：
$$
f_{i,j-a_i}=max(f_{i,j-a_i},f_{i-1,j}+1)
$$
$$
f_{i,min(j-a_i+w_i,mc)}=max(f_{i-1,j},f_{i,min(j-a_i+w_i,mc)}); 
$$
之后可以进行 $bfs$ 之后开始扫描一边，~~因为比较懒~~用了`map`没有去手写 $hash$ 来判断重复，~~还不是因为不会写。~~

剩下的细节在代码里的英文注释里面都有，$English$ 好的同学沾光了。

 $code$ 
```cpp
#include<cmath>
#include<queue>
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<map>
#include<algorithm>
using namespace std;
#define int long long
#define m(c,num) memset(c,num,sizeof c)
#define INF 0x7f7f7f7f
#define debug cout<<"debug"<<endl
#define freopen eat = freopen
#define scanf a14 = scanf
#define eps (1e-8)
namespace xin_io
{
	#define gc() p1 == p2 and (p2 = (p1 = buf) + fread(buf,1,1<<20,stdin),p1 == p2) ? EOF : *p1++
	char buf[1<<20],*p1 = buf,*p2 = buf; FILE *eat; int a14;
	inline void openfile() {freopen("t.txt","r",stdin);} inline void outfile()  {freopen("o.txt","w",stdout);}
	inline int get()
	{	
		int s = 0,f = 1;register char ch = gc();
		while(!isdigit(ch))
		{if(ch == '-') f = -1;ch = gc();}
		while(isdigit(ch))
		{s = s * 10 + ch - '0';	ch = gc();}
		return  s * f;
	}
}
using namespace xin_io;
inline int max(int x,int y) {return x > y ? x : y;}
inline int min(int x,int y) {return x < y ? x : y;}
static const int maxn = 1e3+10,mod = 1e9+7;
namespace xin
{
	class xin_bfs{public:int d,f,l;xin_bfs(int x,int y,int z):d(x),f(y),l(z){}}; //this is for BFS to record state
	pair<int,int>p[maxn*10000];int tot = 0;
	queue <xin_bfs> q;
	int n,m,mc;
	int a[maxn],c[maxn],w[maxn];
	int f[maxn][maxn];
	map<pair<unsigned long long,int>,bool>hash;
	int maxx = -0x7f7f7f7f,day = maxx; //here is the max day and the max c
	void bfs() //this bfs is for f and day
	{
		q.push(xin_bfs(1,1,0));
		while(q.size())
		{
			xin_bfs u = q.front(); q.pop();
			if(u.d == day) continue; //if now is equal to max day ,continue
			q.push(xin_bfs(u.d+1,u.f,u.l+1)); //here is going to bfs the next point
			if(u.l > 1 and u.f * u.l <= maxx and !hash[make_pair(u.f * u.l,u.d + 1)])
			{
				q.push(xin_bfs(u.d + 1, u.f*u.l , u.l));
				p[++tot] = make_pair(u.f * u.l,u.d+1);
				hash[make_pair(u.f * u.l,u.d + 1)] = 1;
			}
		}
		hash.clear();
	}
	inline short main()
	{
	#ifndef ONLINE_JUDGE
		openfile();
	#endif
		n = get(); m = get(); mc = get();
		for(register int i=1;i<=n;++i) a[i] = get();
		for(register int i=1;i<=n;++i) w[i] = get();
		for(register int i=1;i<=m;++i) c[i] = get(),maxx = max(maxx,c[i]);
		for(register int i=1;i<=n;++i)   //for here I am going to get f[i][j] for(i for day and j for self),and f[i][j] represent the max day I am going to hit darklao
			for(register int j=a[i];j<=mc;++j)
				f[i][j-a[i]] = max(f[i][j-a[i]],f[i-1][j] + 1), //nothing to do
				f[i][min(j-a[i]+w[i],mc)] = max(f[i-1][j],f[i][min(j-a[i]+w[i],mc)]); //there is that I do so many water problems	
		for(register int i=1;i<=n;++i)
			for(register int j=1;j<=mc;++j)
				day = max(day,f[i][j]);   //calc the maxday
		bfs();
		sort(&p[1],&p[tot+1]);
		for(register int i=1;i<=m;++i)
		{
			if(c[i] <= day) {printf("1\n"); continue;}
			bool ok = false;
			int mm = 0x7f7f7f7f7f7f7f7f;
			for(register int j=tot,k = 1;j;--j)
			{
				while(k < tot and p[k].first + p[j].first <= c[i])
					mm = min(mm,p[k].second - p[k].first),++k;
				if(mm + c[i] - p[j].first <= day - p[j].second) {ok = true; break;}
				if(p[j].first <= c[i] and c[i] - p[j].first <= day - p[j].second) {ok = true; break;}
			}
			printf("%d\n",ok);
		}
		return 0;
	}
}
signed main() {return xin::main();}
```

---

## 作者：Varuxn (赞：5)

## 解题思路
### 暴力打法
这个题一看题面和题目，令人畏惧，但是细细读题后可以发现：好像就是个**深搜**，再一看数据范围，直接开码 ~~（然后我们愉快的**TLE40pts**）~~。

#### [code](https://www.luogu.com.cn/paste/v4eihez1)
### 正解
有一个十分重要的地方就是**怼大佬与活下来是两个事**。

然后我们就可以分别运算了：
#### DP最多天数
类似于背包 DP ，利用前面的更新现在的直接 +1 就好了，最后对于所有的 dp 值取 mod ，求出最大天数就好了。
```cpp
void get_Day()
{
	for(int i=1;i<=n;i++)//枚举天数
		for(int j=a[i];j<=mc;j++)//枚举自己的自信
		{
			dp[i][j-a[i]]=max(dp[i][j-a[i]],dp[i-1][j]+1);
			int temp=min(mc,j-a[i]+w[i]);
			dp[i][temp]=max(dp[i][temp],dp[i-1][j]);
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=mc;j++)
			day=max(day,dp[i][j]);
}
```
#### BFS求二元组(d,f)
二元组 $(d,f)$ 表示第 d 天 $(d<D)$ 并且此时的 $F=f$ ，运算的过程中需要去重，用 Hash 或者 map 可以很好的解决这个问题这里给出 map 做法。

队列的数组三维分别表示: 天数， L ，F，对于大于上面求的D，直接跳过，其他的枚举并更新 L 和 F 入队就好了，然后用一个 S1 数组储存所有的二元组。

```cpp
void get_Dui()
{
	int head=1,tail=0;
	q[++tail]=make_pair(1,make_pair(0,1));
	a1[make_pair(1,1)]=1;
	while(head<=tail)
	{
		pair<int,pair<int,int> > temp;
		temp=q[head++];
		if(temp.first>=day)
			continue;
		int da=temp.first,l=temp.second.first,f=temp.second.second;
		q[++tail]=make_pair(da+1,make_pair(l+1,f));
		a1[make_pair(da+1,f)]=1;
		if(l>1&&l*f<=mxc&&!a1[make_pair(da+1,l*f)])
		{
			int new_f=l*f;
			q[++tail]=make_pair(da+1,make_pair(l,new_f));
			a1[make_pair(da+1,new_f)]=1;
			s1[++cnt]=make_pair(da+1,new_f);
		}
	}
}
```
#### 算法主体
显然，可以怼没大佬自信值的情况有三种：
1. **一次都不怼**，仅用 1 操作消磨他并且 $C_i\le D$ 。
2. **只怼一次大佬**，剩下的拿 1 来凑，这是需要有一个二元组 $(d,f)$ 满足 $f\le C_i$ ,并且 $f+D-d\ge C_i$
3. **怼两次大佬**，两次分别为 $(d_1,f_1)$ 和 $(d_2,f_2)$ 并且满足$f_1+f_2 \le C_i$ 和 $f_1+f_2-d_1-d_2+D \ge C_i$。
	诚然，对于同一个 $f$ 只有最小的 $d$ 是最优的，因此我们只需要对于每一个 $f$ 保存最小的 $d$ 就好了， map 有一次正好的满足了这个条件~~（那还用Hash干嘛）~~,然后我们双向指针扫一下，再判断一小下就可以过掉此题了。
    
题目对于各项要求比较严格，具体实现细节见代码。
## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e2+10,M=3e6+10,INF=1e9;//注意数组大小 
int n,m,mc,mxc,a[N],w[N],c[25];
int tot,cnt,day,dp[N][N];
pair<int,int> s1[M],s2[M];
pair<int,pair<int,int> > q[M];//day l f
map<pair<int,int>,int> a1;
map<int,bool> a2;
void get_Day()//求出最大的day 
{
	for(int i=1;i<=n;i++)//类似于背包dp 
		for(int j=a[i];j<=mc;j++)
		{
			dp[i][j-a[i]]=max(dp[i][j-a[i]],dp[i-1][j]+1);
			int temp=min(mc,j-a[i]+w[i]);
			dp[i][temp]=max(dp[i][temp],dp[i-1][j]);
		}
	for(int i=1;i<=n;i++)//取最值 
		for(int j=1;j<=mc;j++)
			day=max(day,dp[i][j]);
}
void get_Dui()//求二元组(d,f) 
{
	int head=1,tail=0;
	q[++tail]=make_pair(1,make_pair(0,1));
	a1[make_pair(1,1)]=1;
	while(head<=tail)
	{
		pair<int,pair<int,int> > temp;
		temp=q[head++];
		if(temp.first>=day)
			continue;
		int da=temp.first,l=temp.second.first,f=temp.second.second;
		q[++tail]=make_pair(da+1,make_pair(l+1,f));
		a1[make_pair(da+1,f)]=1;
		if(l>1&&l*f<=mxc&&!a1[make_pair(da+1,l*f)])
		{
			int new_f=l*f;
			q[++tail]=make_pair(da+1,make_pair(l,new_f));
			a1[make_pair(da+1,new_f)]=1;
			s1[++cnt]=make_pair(da+1,new_f);
		}
	}
}
bool comp(pair<int ,int > x,pair<int ,int > y)//重新定义sort排序规则 
{
	if(x.second==y.second)
		return x.first<y.first;
	return x.second<y.second;
}
#undef int
int main()
{
	#define int register long long
	#define ll long long
	scanf("%lld%lld%lld",&n,&m,&mc);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)
		scanf("%lld",&w[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%lld",&c[i]);
		mxc=max(mxc,c[i]);
	}
	get_Day();
	get_Dui();
	sort(s1+1,s1+cnt+1,comp);
	for(int i=1;i<=cnt;i++)
		if(!a2[s1[i].second])
		{
			a2[s1[i].second]=true;
			s2[++tot]=s1[i];
		}
	for(int k=1;k<=m;k++)
	{
		if(c[k]<=day)//一次也不怼 
		{
			printf("1\n");
			continue;
		}
		bool vis=false;
		int pos=1;
		for(int i=tot;i>=1;i--)
		{
			int da=s2[i].first,f=s2[i].second;
			if(f<=c[k]&&day-da+f>=c[k])
			{
				vis=true;
				break;
			}
			int maxn=-INF;
			while(pos<=tot&&f+s2[pos].second<=c[k])
			{
				maxn=max(maxn,s2[pos].second-s2[pos].first);//如果是int，应该把+f卸载循环里不然会爆掉 
				pos++;
			}
			if(f-da+maxn>=c[k]-day)//判断符合条件 
			{
				vis=true;
				break;
			}
		}
		printf("%d\n",vis?1:0);
	}
	return 0;
}
```

---

## 作者：_LHF_ (赞：3)

看到大家都在打 map/hash，我流下了长长的眼泪。

首先可以将五种操作转化成两种操作：攻击操作和回血操作。

于是随便 dp 一下计算出在不死掉的情况下最多能怼大佬多少次。

于是问题转化成对于每个大佬，是否能通过若干次攻击把它干掉。

显然是要拆成 $s1+s2+k$，其中 $s1,s2\in A$，$A$ 集合表示所有包含的质因子在 $100$ 以内且小于 $10^8$ 的数构成的集合。

爆搜一下，发现 $|A|$ 大约为九十多万。

然后 dp 一下，设 $f_i$ 表示达到 $i$ 的伤害的最小代价。

显然数组可能会爆炸，于是需要用双指针弄一弄。

具体双指针方法：先把所有的数排序，然后维护两个指针，根据单调性可得一次的复杂度是 $O(|A|)$ 的。

然后对于每次询问操作，同样双指针算一下答案即可。

一个小小的优化：可以发现 $97$ 这个质数基本是没有用的，可以特判掉。

然后跑了 rk1 了（截止至2021-10-19）

---

## 作者：PMZG (赞：3)

### 部分分
仔细理解题意，发现实际上有五个操作，你可以选择五个操作中的任意一种，问最后能不能在大佬打死你之前把大佬打死。  
考场上第一眼没什么思路，但是发现数据范围不是很大，可以直接考虑暴力dfs。  
将所有参数都传进去直接搜就可以获得 $40pts$ 。 
```cpp 
bool dfs(int day,int hp,int c,int f,int l,int k)
{
	if(hp<0)return 0;
	if(c<0)return 0;
	if(k<0)return 0;
	if(day>n)return 0;
	if(c==0)return 1;
	if(hp<a[day+1])return 0;
	if(dfs(day+1,hp-a[day+1],c-1,f,l,k)||
	   dfs(day+1,min(hp-a[day+1]+w[day+1],mc),c,f,l,k)||
	   dfs(day+1,hp-a[day+1],c,f,l+1,k)||
	   dfs(day+1,hp-a[day+1],c,f*l,l,k)||
	   dfs(day+1,hp-a[day+1],c-f,1,0,k-1))
	return 1;
   return 0;
}
```  
### 正解  
#### 1.dp天数
发现在什么时候进行攻击的伤害都一样，只是自己回血和大佬伤害不一样，其实活下来和怼大佬是相互分离的，所以可以分开考虑。  
分析一下会发现不让自己死一定不会劣，因为假如今天不回血会死，回血能多活一天，那么你与其今天不要命怼大佬不如先奶自己一口然后明天接着干，所以可以简单的dp求出在 $n$ 天最多有几天不刷水题怼大佬。  
设 $f_{i,j}$ 表示在第 $i$ 天，剩 $j$ 滴血的时候最多用于攻击大佬的天数 。   
避免边界问题可以采用刷表转移：  
$$dp_{i+1,j-a_{i+1}}=\max(dp_{i,j-a_{i+1}},dp_{i,j}+1)$$  
$$dp_{i+1,j-a_{i+1}+w_{i+1}}=\max(dp_{i+1,j-a_{i+1}+w_{i+1}},dp_{i,j})$$  
初始化 $dp_{0,mc}=0$，其余为负无穷。
```cpp
inline int gandp()
{
	memset(dp,128,sizeof(dp));
	dp[0][mc]=0;
	for(int i=0;i<n;i++)
	{
		for(int j=a[i+1];j<=mc;j++)
		{
			dp[i+1][j-a[i+1]]=max(dp[i+1][j-a[i+1]],dp[i][j]+1);
			dp[i+1][min(j-a[i+1]+w[i+1],mc)]=max(dp[i+1][min(j-a[i+1]+w[i+1],mc)],dp[i][j]);
		}
	}
	int day=0;	
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=mc;j++)
	  day=max(day,dp[i][j]);	
	return day;
}
```  
注意题目中说**每回合大佬先攻击**，所以只有这一轮不死才能接着操作，所以内层 $j$ 循环从 $a_{i+1}$ 开始。  
  
#### 2.bfs搜索状态  
由于规定最多只能怼两次大佬，所以可以从每一次的伤害入手，处理出当前在每天可以利用大招打出多少伤害。  
没有什么别的办法，参考暴力的dfs，可以将当前的等级 $L$，伤害 $F$，天数 $d$，拿出来枚举，在不开大的情况下，每天只有两种选择：升级或升伤害，所以可以bfs。  
总的状态比较多，直接枚举至少 $10^8$ 数量级，由于我们只想知道最终有多少符合条件的二元组 $F,d$ 可以用来打伤害，所以对它开一个 ```set``` 进行去重就行。  
然而这样还是容易超时，发现**不能让大佬生命为负**，一个小减枝是如果当前伤害已经超过了大佬生命值，肯定不合法，不用接着搜。  
进一步思考，对于一种 伤害 $F$ ，我们一定希望用尽量少的时间把它打出来，因为剩下的时间是你的，你可以普攻输出也可以不打，一定不劣，所以对于一个 $F$ ，只需要保存它对应最小的 $d$ 就行，这个可以用```map```实现，这样状态总数就只有 $10^6$ 级别了。  
```cpp
struct p{int l,f,d;};
queue <p> q;set <pair<int,int> >s; 
pair <int,int> h[4000050];int num;
int ma[4000050];
map <int,int> mp;
inline void bfs()
{
	q.push((p){0,1,0});
	while(q.size())
	{
		p x=q.front();q.pop();
		if(x.d==day-1)continue;//还有一天要用来打伤害
		int ga=max(x.f,x.l*x.f);//处理一下L等于0的情况
		if(x.f*x.l<=1e8&&s.find(make_pair(ga,x.d+1))==s.end())
		{
			s.insert(make_pair(ga,x.d+1));int t;
			if(mp.find(ga)==mp.end())t=++num,mp[ga]=t,h[t].first=ga,h[t].second=x.d+1;
			else t=mp[ga],h[t].second=min(h[t].second,x.d+1);//状态去重
			q.push((p){x.l+1,x.f,x.d+1});
			if(x.l>1)q.push((p){x.l,ga,x.d+1});
		}
	}
}
```  
  
#### 3.分类讨论答案  
首先如果$c<=day$可以直接平A干掉大佬，这个可以直接判断。  
然后是怼一次大佬，能打死需要满足： 
$$F<=c$$  
$$F+day-1-d>=c$$  
由于我bfs时候算的是伤害提升到 $F$ 需要的时间，还要一天把伤害打出去，所以减一。 这个直接枚举一边也能判断。  
最恶心的是怼两次大佬，首先我们把式子列出来,设两次攻击分别为 $i,j$:  
$$F_i+F_j<=c$$  
$$F_i+F_j+day-2-d_i-d_j>=c$$  
我们先对处理出来的二元组按 $F$ 从小到大排序，那么我们会发现，对于满足第一个条件的 $i$ 从小到大递增时，$j$ 一定**单调不升**，所以可以每次从小到大枚举 $i$,同时维护单调指针 $j$，处理出 $j$ 的最右段点 $p$，那么问题就转化成 $1-p$ 中是否存在一个符合条件的点满足第二个式子，发现肯定是越大越优，所以对上面得到的 $h$ 数组做一个前缀最大值就能直接判断了，复杂度为状态数，可以通过。
完整代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
inline int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
int n,m,mc,c,day;
int a[105],w[105];
int dp[105][105];
inline int gandp()
{
	memset(dp,128,sizeof(dp));
	dp[0][mc]=0;
	for(int i=0;i<n;i++)
	{
		for(int j=a[i+1];j<=mc;j++)
		{
			dp[i+1][j-a[i+1]]=max(dp[i+1][j-a[i+1]],dp[i][j]+1);
			dp[i+1][min(j-a[i+1]+w[i+1],mc)]=max(dp[i+1][min(j-a[i+1]+w[i+1],mc)],dp[i][j]);
		}
	}
	int day=0;	
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=mc;j++)
	  day=max(day,dp[i][j]);	
	return day;
}

struct p{int l,f,d;};
queue <p> q;set <pair<int,int> >s; 
pair <int,int> h[4000050];int num;
int ma[4000050];
map <int,int> mp;
inline void bfs()
{
	q.push((p){0,1,0});
	while(q.size())
	{
		p x=q.front();q.pop();
		if(x.d==day-1)continue;
		int ga=max(x.f,x.l*x.f);
		if(x.f*x.l<=1e8&&s.find(make_pair(ga,x.d+1))==s.end())
		{
			s.insert(make_pair(ga,x.d+1));int t;
			if(mp.find(ga)==mp.end())t=++num,mp[ga]=t,h[t].first=ga,h[t].second=x.d+1;
			else t=mp[ga],h[t].second=min(h[t].second,x.d+1);
			q.push((p){x.l+1,x.f,x.d+1});
			if(x.l>1)q.push((p){x.l,ga,x.d+1});
		}
	}
	sort(h+1,h+num+1);
	for(int i=1;i<=num;i++)ma[i]=max(ma[i-1],h[i].first-h[i].second);
}
inline bool gan0()
{
	if(c<=day)return 1;
	return 0;
}
inline bool gan1()
{
	for(int i=1;i<=num;i++)
	{
		if(h[i].first>c)break;
		if(h[i].first+day-1-h[i].second>=c)return 1;
	}
	return 0;
}
inline bool gan2()
{
	int i=1,j=num;
	for(int i=1;i<=num;i++)
	{	
		if(h[i].first>c)break;
		while(h[i].first+h[j].first>c)j--;
		int p=c-(day-2)-(h[i].first-h[i].second);
		if(ma[j]>=p)return 1;
	}
	return 0;
}
signed main()
{
	n=read();m=read();mc=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)w[i]=read();
	day=gandp();bfs();
	while(m--)
	{
		c=read();
		if(gan0()||gan1()||gan2())puts("1");
		else puts("0");
	}
	return 0;
}
```

---


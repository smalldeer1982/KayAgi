# 一次函数

## 题目描述

给定 $n$ 个一次函数 $f_i(x) = a_ix + b_i$，其中 $x$ 为形式幂级数的占位符。

从这 $n$ 个中选出 $k$ 个 $g_i(x)$ （$1\leq i \leq k$），定义集合 $H$ 为 $g_i$ 的若干次幂的乘积模 $x^2$ 的值所构成的集合。即：

$$H=\left\{\prod_{i=1}^k g_i(x)^j\bmod x^2\middle|0 \leq a, b < p \right\}$$

其中 $j$ 是任意非负整数且对于每个 $i$ 可以有不同的 $j$。

需要注意的是，$0\cdot x+1$ 始终在集合 $H$ 中（而非 $0 \cdot x + 0$），即使 $k = 0$ 也是如此。

给定 $A, B$，求出所有满足 $Ax+B\in H$ 的集合 $H$ 的 $k$ 的最小值。

若不存在 $H$ 使得 $Ax+B\in H$，输出 `-1`。

所有运算均在模 $p$ 意义下进行。

## 说明/提示

**另有两组大样例与 checker，下载地址见附件。**

要测试你某个测试点的答案，你需要在你本题目录下的命令行中执行：

``<checker> <input‐file> <output‐file> <answer‐file> [<report‐file>]``

其中：

* ``<checker>`` 表示校验器可执行文件；
* ``<input‐file>`` 表示该测试点的输入文件，如 ``func1.in``；
* ``<output‐file>`` 表示该测试点你的答案，如 ``func1.out``；
* ``<answer‐file>`` 表示该测试点的答案文件（只需要提供输出的第一行），如 ``func1.ans``；
* ``<report‐file>`` 为可选参数，如果没有给定该参数，校验器将输出至终端；否则将输出至该文件，如 ``report1.txt``。

对于所有数据，$2\leq p\leq 10^9$，保证 $p$ 为质数，$1\leq n \leq 5 \times 10^3$，$0\leq a_i, A < p$，$1\leq b_i, B < p$。

详细的数据限制及约定如下（留空表示和上述所有数据的约定相同）：

| 子任务编号 | 分值 | $n$ | $p$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $=1$ | $\leq 1000$ |  |
| $2$ | $5$ | $\leq 3$ | $=7$ |  |
| $3$ | $15$ | $\leq 100$ | $=31$ |  |
| $4$ | $20$ | |  | $A=B=1$ |
| $5$ | $25$ | $\leq 20$ |  |  |
| $6$ | $15$ | $\leq 500$ |  |  |
| $7$ | $15$ | |  |  |

## 样例 #1

### 输入

```
1 997 603 648
200 61
```

### 输出

```
1
1 140787
```

## 样例 #2

### 输入

```
1 953 712 307
534 750
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3 7 6 5
3 4
5 6
4 6
```

### 输出

```
2
2 5
1 20
```

# 题解

## 作者：_sys (赞：48)

我们设 $g$ 为模 $p$ 意义下的原根，$G(x) = x + g$。

则 $G^i$ （$1 \leq i \leq p(p-1)$）遍历了所有的 $ax + b$（$0\leq a < p, 1\leq b < p$）。

考虑 $G^i=(x+g)^i=ig^{i-1}x+g^i$。

$g^i$ 相同对应的两个 $i$ 需满足在 ${} \bmod \phi (p)$ 的意义下同余，在这个基础上一次项相同需满足在 ${}\bmod p$ 的意义下同余，所以 $G$ 的周期是 $p(p-1)$。

于是我们可以把所有的 $ax + b$ 取 “离散对数”，方法是对常数项 BSGS，一次项通过解方程求出。得到一个数组 $\textrm{arr}$，$Ax + B$ 转变为 $\textrm{goal}$。

现在的问题变为：给你一个数组 $\textrm{arr}$，问至少从中选出多少个使得他们的某个线性组合等于 $\textrm{goal}$。

我们设选出来的数组为 $s$。

根据裴蜀定理，我们得知若 $\gcd \{s\}|\textrm{goal}$，则一定有解。

我们将 $\textrm{arr}$ 中的每个数变为 $\gcd(\textrm{arr}_i, \textrm{goal})$。于是问题变为，选出尽可能少的数使得 $\gcd\{s\}=1$。

我们可以通过简单的状压 dp 解决这个问题，状态数为 $2^{\omega(p-1)+1}$。

得到了选出的数的集合，我们便可以逐位构造方案。

我们假设已知 $a$，要构造出 $\sum_{i=1}^k a_ix_i=b$ 的一组解，我们将式子写成 $a_1x_1+\gcd_{i=2}^k\{a_i\}X=b$，发现 $\sum_{i=2}^ka_ix'_i=b'$ 有解当且仅当 $\gcd_{i=2}^k\{a_i\}|b'$。所以我们通过 exgcd 求出 $x_1$ 和 $X$，之后解 $\sum_{i=2}^ka_ix_i=\gcd_{i=2}^k\{a_i\}X$ 即可。

时间复杂度为 $O(2^{\omega(p)+1}n+\sqrt{np}\log p)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int Maxi = 1030, Maxn = 5005;
int n, m, ct, bloc, f[Maxn][Maxi], pos[Maxi], fac[Maxi];
pair <int, int> from[Maxn][Maxi];
long long d, p, goal, val[Maxn], arr[Maxn];
pair <int, long long> ans[Maxn];
unordered_map <int, int> Ma;
typedef pair <long long, long long> pll;
pll G;
pll operator * (const pll &x, const pll &y)
{
	return make_pair((x.first * y.second + x.second * y.first) % p, x.second * y.second % p);
}
long long gcd(long long x, long long y)
{
	return x == 0 ? y : gcd(y % x, x);
}
long long fast_pow(long long x, long long y)
{
	long long ans = 1, now = x;
	while (y)
	{
		if (y & 1) ans = ans * now % p;
		now = now * now % p;
		y >>= 1;
	}
	return ans;
}
pll fast_pow(pll x, long long y)
{
	pll ans = make_pair(0, 1), now = x;
	while (y)
	{
		if (y & 1) ans = ans * now;
		now = now * now;
		y >>= 1;
	}
	return ans;
}
void dp(void)
{
	int maxi = (1 << ct) - 1;
	memset(f, 0x3f, sizeof(f));
	f[0][maxi] = 0;
	for (int i = 1; i <= n; i++)
	{
		int sta = 0;
		long long tmp_val = gcd(val[i], p * (p - 1));
		tmp_val = tmp_val / gcd(tmp_val, goal);
		for (int j = 1; j <= ct; j++)
			if (tmp_val % fac[j] == 0) sta |= 1 << (j - 1);
		for (int j = 1; j <= maxi; j++)
			if (f[pos[j]][j] + 1 < f[pos[j & sta]][j & sta])
			{
				pos[j & sta] = i;
				f[i][j & sta] = f[pos[j]][j] + 1;
				from[i][j & sta] = make_pair(pos[j], j);
			}
	}
}
int get_unit(void)
{
	int maxi = sqrt(p - 1);
	for (int i = 2; ; i++)
	{
		for (int j = 2; j <= maxi; j++)
			if ((p - 1) % j == 0)
			{
				if (fast_pow(i, j) == 1) goto END;
				if (fast_pow(i, (p - 1) / j) == 1) goto END;
			}
		return i;
		END:;
	}
}
void get_factor(void)
{
	int maxi = sqrt(p - 1), tmp = p - 1;
	for (int i = 2; i <= maxi; i++)
		if (tmp % i == 0)
		{
			fac[++ct] = i;
			while (tmp % i == 0) tmp /= i;
		}
	if (tmp != 1) fac[++ct] = tmp;
	fac[++ct] = p;
}
pll exgcd(long long x, long long y)
{
	if (!x)
		return make_pair(0, 1);
	else
	{
		pll tmp = exgcd(y % x, x);
		return make_pair(tmp.second - tmp.first * (y / x), tmp.first);
	}
}
long long multi(long long x, long long y)
{
	x = (x % (p * (p - 1)) + (p * (p - 1))) % (p * (p - 1));
	y = (y % (p * (p - 1)) + (p * (p - 1))) % (p * (p - 1));
	long long ans = 0, now = x;
	while (y)
	{
		if (y & 1) ans = ((unsigned long long) ans + now) % (p * (p - 1));
		now = (now * 2ull) % (p * (p - 1));
		y >>= 1;
	}
	return ans;
}
void work(int lt, long long goal_now)
{
	long long g = 0, div;
	for (int i = lt + 1; i <= m; i++)
		g = gcd(g, arr[i]);
	div = gcd(arr[lt], gcd(goal_now, g));
	for (int i = lt; i <= m; i++)
		arr[i] /= div;
	g /= div, goal_now /= div;
	pll result = exgcd(arr[lt], g);
	ans[lt].second = multi(result.first, goal_now);
	if (lt == m - 1) return ;
	work(lt + 1, multi(multi(result.second, goal_now), g));
}
void BSGS_init(void)
{
	bloc = sqrt(n * p) / 2;
	long long now = 1;
	d = get_unit();
	for (int i = 0; i < bloc; i++)
	{
		Ma[now] = i;
		now = now * d % p;
	}
}
long long BSGS(pll val_now)
{
	long long inv = fast_pow(fast_pow(d, bloc), p - 2), now_inv = 1;
	for (int j = 0; j < p / bloc + 1; j++)
	{
		if (Ma.find(now_inv * val_now.second % p) != Ma.end())
		{
			long long tmp = Ma[now_inv * val_now.second % p] + j * (long long) bloc;
			pll tmp_val = val_now * fast_pow(make_pair(1, d), p * (p - 1) - tmp);
			return ((p - 1) * (p - tmp_val.first * d % p) + tmp) % (p * (p - 1));
		}
		(now_inv *= inv) %= p;
	}
}
int main()
{
	scanf("%d%lld%lld%lld", &n, &p, &G.first, &G.second);
	if (G == make_pair(0LL, 1LL))
	{
		puts("0");
		return 0;
	}
	BSGS_init();
	get_factor();
	goal = BSGS(G);
	long long g = gcd(p * (p - 1), goal);
	for (int i = 1; i <= n; i++)
	{
		pll x;
		scanf("%lld%lld", &x.first, &x.second);
		val[i] = BSGS(x), g = gcd(g, val[i]);
	}
	for (int i = 1; i <= n; i++) val[i] /= g;
	goal /= g;
	dp();
	if (f[pos[0]][0] > n)
	{
		puts("-1");
		return 0;
	}
	pair <int, int> now = make_pair(pos[0], 0);
	while (now.first)
	{
		arr[++m] = val[now.first];
		ans[m].first = now.first;
		now = from[now.first][now.second];
	}
	arr[++m] = p * (p - 1);
	work(1, goal);
	printf("%d\n", m - 1);
	for (int i = 1; i < m; i++)
		printf("%d_%lld\n", ans[i].first, ans[i].second);
	return 0;
}
```

---

## 作者：Edward1002001 (赞：5)

这是一篇不需要考虑新数域内原根 $(x+g)$ 的题解，做法可能与其本质等价。

## 一些性质

首先我们意识到新数域中的乘法没有一些明显的特殊性质，新的一次项形式很怪异，这让我们联想到二次剩余算法中对 i 进行的扩域，二次剩余算法中通过对 $a+bi$ 的 $p$ 次方进行计算，然后约掉许多项，获得了十分漂亮的结论。这引导我们对该数域中数的 $p$ 次方进行探索。

#### Lemma 1.$(ax+b)^p=b$

证明：$(ax+b)^p=pab^{p-1}x+b^p=b^p=b$

#### Lemma 2.$(ax+b)^{p-1}=-a/bx+1$

证明和上面同理或者除一下就可以得到。

此时我们注意到对 $A=0$ 的情况只要凑出 $qx+B$ (其中 $q$ 是任意数)然后再将其取 $p$ 次方就能得到 $B$ 了，这样就可以忽略 $a_i$ 的取值，造出单个的常数。但此时我们注意到没有 $A=0$ 的部分分，而是 $A=B=1$ 的部分分，这引导我们向 $x+1$ 的性质发起探索。

#### Lemma 3.$(x+1)^k=kx+1$

#### Lemma 4.若 $ab \equiv 1\ (\bmod p)$，则有 $(ax+1)^b=x+1$，即 $(ax+1)^{bc}=(cx+1)$

证明：$(ax+1)^b=(x+1)^{ab}=(ab)x+1=x+1$

#### Lemma 5.对任意 $a,b$，$(ax+b)^{p(p-1)}=b^{p-1}=1$，即 $p(p-1)$ 是一个普适的循环节

## 构造

首先，取一些元素，使其常数项的乘积能构造出 $B$ ，再将得到的某个 $mx+B$ 自乘到 $p$ 次方，成为 $B$。

其次，若 $A \neq 0$ ，找到（在前一步中需要保证有这样的元素）一个 $a \neq 0$的元素，将其变为其 $p-1$ 次方，以得到某个 $mx+1$ ，其中 $m \neq 0$，这样保证了 $m$ 在模 $p$ 意义下有逆元。

接着，将 $mx+1$ 自乘到 $A/Bm$ 次方，得到 $A/Bx+1$，再将其乘以 $B$ 就得到了我们想要的多项式。

为什么这是用了最小个数一次函数的构造呢？~~其实我也不知道，我是按可行解做的~~。按 Lemma 1，凑出 $Ax+B$ 就能凑出 $B$ ，而我们构造了方法使凑出 $Ax+B$ 的使用个数比 $B$ 最多多一（在凑出 $B$ 的元素均有 $A=0$ 时多一，其他情况不变）

在凑出 $B$ 的元素均有 $A=0$ 时，光靠这些元素显然凑不出我们需要的结果，因此加一是最优的结果。

## 如何构造 $B$

1. 找出原根 $g$

2. 使用 BSGS 找出所有 $b_i$ 以及 $B$ 的对数，分别记为 $lnb_i$,$lnB$

3. 将所有对数值与 $p-1$ 取 gcd，然后对其分解质因数，问题转化为找到最小解集使其 $\operatorname{gcd}$ 整除 $\operatorname{gcd}(lnB,p-1)$

4. 对每个质因数以及是否有 $A$ 非零的元素做状压，最后的答案就是dp[n][ALL]。

## 一些细节

1. 注意超过 $10^{18}$ 时对 $p(p-1)$ 取模

2. BSGS 注意平衡复杂度做到 $O(\sqrt{nq})$，实测 $B=1300000$ 跑得比较快

---


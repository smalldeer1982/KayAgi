# [ZJOI2022] 深搜

## 题目描述

九条可怜是一个喜欢算法的女孩子，在众多算法中她尤其喜欢深度优先搜索（DFS）。

有一天，可怜得到了一棵有根树，树根为 $\mathit{root}$，树上每个节点 $x$ 有一个权值 $a_x$。

在一棵树上从 $x$ 出发，寻找 $y$ 节点，如果使用深度优先搜索，则可描述为以下演算过程：

1. 将递归栈设置为空。
2. 首先将节点 $x$ 放入递归栈中。
3. 从递归栈中取出栈顶节点，如果该节点为 $y$，则结束演算过程；否则，如果存在未访问的直接子节点，则以均等概率随机选择一个子节点加入递归栈中。
4. 重复步骤 3，直到不存在未访问的直接子节点。
5. 将上一级节点加入递归栈中，重复步骤 3。
6. 重复步骤 5，直至当前一级节点为 $x$，演算过程结束。

我们定义 $f(x, y)$ 合法当且仅当 $y$ 在 $x$ 的子树中。它的值为从 $x$ 出发，对 $x$ 的子树进行深度优先搜索寻找 $y$ 期间访问过的所有节点（包括 $x$ 和 $y$）权值最小值的期望。

九条可怜想知道对于所有合法的点对 $(x, y)$，$\sum f(x, y)$ 的值。你只需要输出答案对 $998244353$ 取模的结果。具体地，如果答案的最简分数表示为 $\frac{a}{b}$，输出 $a \times b^{-1} \bmod 998244353$。

## 说明/提示

对于所有测试点，满足 $1 \le T \le 100$，$\sum n \le 8 \times {10}^5$，$1 \le n \le 4 \times {10}^5$，$1 \le \mathit{root}, u, v \le n$，$1 \le a_i \le {10}^9$。

每个测试点的具体限制见下表：

| 测试点编号 | $\sum n \le$ | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1$ | $50$ | $10$ | 无 |
| $2 \sim 4$ | $40000$ | $5000$ | 无 |
| $5 \sim 10$ | $4 \times {10}^5$ | ${10}^5$ | 无 |
| $11$ | $8 \times {10}^5$ | $4 \times {10}^5$ | 树的生成方式随机 |
| $12$ | $8 \times {10}^5$ | $4 \times {10}^5$ | 树是一条链 |
| $13$ | $8 \times {10}^5$ | $4 \times {10}^5$ | 根的度数为 $n - 1$ |
| $14 \sim 20$ | $8 \times {10}^5$ | $4 \times {10}^5$ | 无 |

对于测试点 $11$，树的生成方式为：以 $1$ 为根，对于节点 $i \in [2, n]$，从 $[1, i - 1]$ 中等概率随机选
择一个点作为父亲。之后将编号随机重排。

## 样例 #1

### 输入

```
4
1 1
1
3 3
3 3 4
3 1
3 2
6 1
5 2 4 1 3 6
1 2
1 6
2 3
2 4
4 5
5 1
5 4 3 2 1
1 2
1 3
3 4
3 5
```

### 输出

```
1
16
34
499122202
```

## 样例 #2

### 输入

```
见附件中的 dfs/dfs_ex2.in```

### 输出

```
见附件中的 dfs/dfs_ex2.ans```

# 题解

## 作者：xtx1092515503 (赞：13)

考虑关于每个权值分开处理：对于权值 $V$，我们计算 $\min\geq V$ 的概率，则对每个 $V$ 的概率求和即得到最终期望。

对于某个 $V$，我们记 $\geq V$ 的位置为 **黑点**，$<V$ 的位置为 **白点**。

考虑针对路径 $x\to y$ 计算答案。

模拟 dfs 的流程，就能发现，一旦我们进入到某棵 **存在白点的子树**，则这次搜索就不合法了。

考虑当前在节点 $u$。记除去 $y$ 所在的子树外，$u$ 还有 $c_u$ 棵存在白点的子树，$d_u$ 棵全黑子树。

在前往 $y$ 所在的子树前不经过任何存在白点的子树的概率是多少呢？

考虑随机一组排列，按照这种顺序访问每棵子树。则，$y$ 所在子树在每个位置被访问的概率均相同，即为 $\dfrac1{c_u+d_u+1}$。

其在第 $i$ 个位置被访问前不经过任何白子树的概率是 $\dfrac{d_u^{\underline{i-1}}}{(c_u+d_u)^{\underline{i-1}}}$，则我们要计算 $\dfrac1{c_u+d_u+1}\sum\limits_{i=1}^{c_u+d_u+1}\dfrac{d_u^{\underline{i-1}}}{(c_u+d_u)^{\underline{i-1}}}$。

稍微推一下式子吧！

$$
\dfrac1{c_u+d_u+1}\sum\limits_{i=1}^{c_u+d_u+1}\dfrac{d_u^{\underline{i-1}}}{(c_u+d_u)^{\underline{i-1}}}
\\=\dfrac{d_u!}{(c_u+d_u+1)(c_u+d_u)!}\sum\limits_{i=1}^{d_u+1}\dfrac{(c_u+d_u+1-i)!}{(d_u-i+1)!}
\\=\dfrac{d_u!c_u!}{(c_u+d_u+1)(c_u+d_u)!}\sum\limits_{i=1}^{d_u+1}\dfrac{(c_u+d_u+1-i)!}{(d_u-i+1)!c_u!}
\\=\dfrac{\sum\limits_{i=1}^{d_u+1}\dbinom{c_u+d_u+1-i}{c_u}}{(c_u+d_u+1)\dbinom{c_u+d_u}{c_u}}
\\=\dfrac{\sum\limits_{i=c_u}^{c_u+d_u}\dbinom{i}{c_u}}{(c_u+d_u+1)\dbinom{c_u+d_u}{c_u}}
\\=\dfrac{\dbinom{c_u+d_u+1}{c_u+1}}{(c_u+d_u+1)\dbinom{c_u+d_u}{c_u}}
\\=\dfrac1{c_u+1}
$$

而这个式子是很符合直觉的，因为事实上我们摇到纯黑子树可以相当于做了无效决策，故只需找到 $y$ 所在子树在所有非纯黑子树前摇到的概率即可，而该概率即为上式。

令 $f_u$ 表示上式与 $[u\text{是黑点}]$ 的积，则 $w(x\to y)=[y\text{是黑点}]\prod\limits_{z\in[x\to y)}f_z$，其中 $z$ 枚举到 $x$，不枚举到 $y$。

但是我们发现，对于同一个 $u$ 和不同的 $y$，$c_u$ 可能是不同的（因为 $c_u$ 并不包含 $y$ 所在子树），故 $f_u$ 也是不同的。

但是再注意到对于纯黑子树和非纯黑子树，它们对应的 $c_u$ 各自是相同的。故我们只需对 $y$ 所在子树是 $u$ 的纯黑子树还是非纯黑子树分别讨论一下即可。

到现在，我们已经会一个若干方的垃圾做法了，考虑进一步做点操作。

令 $dp_i$ 表示，$x=i$ 且 $y$ 为 $i$ 子树中全体点时，$\sum w(x\to y)$。则权值为 $c$ 时的答案即为 $\sum dp_i$。

考虑用 $w$ 的式子来推出 DP。然后我们发现 $dp_x=[x\text{是黑点}]+\sum\limits_{y\in\text{son}_x}dp_yf_{x,y}$，其中 $f_{x,y}$ 为 $y$ 所在子树与 $x$ 间的 $f$ 值。

这个式子允许我们在线性时间内对一个权值 $V$ 求解。

现在我们要对多个 $V$ 求解。考虑 $V$ 不同时上述条件的变化。

$V$ 不同时，仅有节点颜色会变化。记 $b_x$ 为节点 $x$ 的颜色，其在 $x$ 为黑时等于一，$x$ 为白时等于零。

考虑从大往小对 $V$ 做扫描线。则，所有 $b_x$ 都只会由白翻黑一次，所有子树都会由非纯黑翻成纯黑一次。因为只有这两个信息会影响我们的转移式，所以自然想到用 DDP 维护这个式子。

可以使用全局平衡二叉树搞，但是我不会。

djq 神仙教我了一种用树剖做到 $O(n\log n)$ DDP 的方法。

upd: 这就是全局平衡二叉树。学过的人就直接忽略这一段吧。

> 树剖的 $\log$ 肯定是免不了的。关键是线段树的 $\log$ 能不能省掉呢？
>
> 我们把每条重链拎出来单独建一棵线段树。但是这里的线段树比较奇葩：其在 **轻子树大小折半** 处分裂。
>
> 也即，考虑重链上每个节点的权重为其轻子树大小和，则我们在节点下方的权重和恰为总权重和一半的位置把区间分开。
>
> 可以发现，在线段树上每跳一步，其管辖的轻子树大小和就会翻倍；在树剖上每跳一步，轻子树大小也会翻倍；故总跳跃次数是 $O(\log n)$ 的。
>
> 折半的位置可以在建树时预处理出来。

我们考虑把转移式写成 $dp_x=K_xdp_{son_x}+B_x$，其中 $K,B$ 是由轻儿子维护的信息。这个东西显然是可以用线段树维护的。然后还要额外记一个 $DP_x=\sum dp_x$，这玩意可以另外开一个二元组维护。最后我们每个节点上需要记四个值。

如果一个点由白翻黑，则 $f$ 值会变化（因为 $f_u=\dfrac{b_u}{c_u+1}$），且转移式也会变化（$dp_x$ 的转移式中也有 $b$）。

如果一个子树由非全黑翻成全黑，则 $f$ 值会变化，且对于全黑子树和非全黑子树变动还不一样（因为它们对应的 $f$ 也不一样）。

怎么办呢？当 $f$ 变化时，重儿子的 $f$ 以及 DP 转移式的变化可以暴力在线段树上修改四元组；轻儿子的 $f$ 变化可以分全黑轻儿子和非全黑轻儿子分开搞。

故大力写就完事了。

复杂度 $O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int&x){
	x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
void print(int x){if(x>=10)print(x/10);putchar('0'+x%10);}
const int N=400100;
const int mod=998244353;
void ADD(int&x,int y){if((x+=y)>=mod)x-=mod;}
int T,n,RT,a[N],b[N],m,INV[N],res;
int dfn[N],rev[N],top[N],bot[N],son[N],fa[N],dep[N],sz[N],tot;
bool col[N],asc[N];int c[N];
vector<int>v[N],w[N];
void dfs1(int x){
	dep[x]=dep[fa[x]]+1,sz[x]=1,son[x]=0;
	for(auto y:v[x])if(y!=fa[x]){fa[y]=x,dfs1(y),sz[x]+=sz[y];if(sz[y]>sz[son[x]])son[x]=y;}
}
void dfs2(int x){
	dfn[x]=++tot,rev[tot]=x;bot[top[x]]=x;
	if(son[x])top[son[x]]=top[x],dfs2(son[x]);
	for(auto y:v[x])if(y!=fa[x]&&y!=son[x])top[y]=y,dfs2(y);
}
int lid[N][2],lis[N];
struct dat{
int kd,bd,ks,bs;
dat(){kd=bd=ks=bs=0;}
dat(int KD,int BD,int KS,int BS){kd=KD,bd=BD,ks=KS,bs=BS;}
friend dat operator*(const dat&u,const dat&v){
	dat w;
	w.kd=1ll*u.kd*v.kd%mod,w.bd=(1ll*u.kd*v.bd+u.bd)%mod;
	w.ks=(1ll*u.ks*v.kd+v.ks)%mod,w.bs=(1ll*u.ks*v.bd+u.bs+v.bs)%mod;
	return w;
}
};
int cnt,rt[N];
#define lson seg[x].ch[0]
#define rson seg[x].ch[1]
struct SegTree{int ch[2],l,r;dat tr;}seg[N<<3];
void build(int&x,int l,int r){
	x=++cnt,seg[x].l=l,seg[x].r=r,seg[x].tr=dat();
	if(l==r)return;
	int L=l+1,R=r,B=(rev[r]==bot[top[rev[r]]]?0:sz[rev[r+1]]);
	while(L<R){
		int mid=(L+R+1)>>1;
		if(sz[rev[l]]-sz[rev[mid]]<sz[rev[mid]]-B)L=mid;else R=mid-1;
	}
	build(lson,l,R-1),build(rson,L,r);
}
void reset(int x,int P,dat val){
	if(seg[x].l==seg[x].r){seg[x].tr=val;return;}
	P<=seg[lson].r?reset(lson,P,val):reset(rson,P,val),seg[x].tr=seg[lson].tr*seg[rson].tr;
}
void account(int x,int tp){
	if(top[x]==RT)return;
	int dp=seg[rt[top[x]]].tr.bd,dps=seg[rt[top[x]]].tr.bs;
	if(tp==1)ADD(lid[fa[top[x]]][asc[top[x]]],dp),ADD(lis[fa[top[x]]],dps);
	else ADD(lid[fa[top[x]]][asc[top[x]]],mod-dp),ADD(lis[fa[top[x]]],mod-dps);
}
void reset(int x){
	int dp=(col[x]?(1ll*lid[x][0]*INV[c[x]]+1ll*lid[x][1]*INV[c[x]+1]+1)%mod:0);
	int dps=(lis[x]+dp)%mod;
	reset(rt[top[x]],dfn[x],dat(col[x]*INV[c[x]+asc[son[x]]],dp,col[x]*INV[c[x]+asc[son[x]]],dps));
}
void flip(int x){
	for(int i=x;i;i=fa[top[i]])account(i,-1);
	col[x]=true;
	for(int i=x;i;i=fa[top[i]])reset(i),account(i,1);
	while(x!=RT&&!c[x]&&col[x]){
		int y=(son[fa[x]]==x?fa[x]:x);
		for(int i=y;i;i=fa[top[i]])account(i,-1);
		asc[x]=true,c[fa[x]]--;
		for(int i=y;i;i=fa[top[i]])reset(i),account(i,1);
		x=fa[x];
	}
}
void mina(){
	read(n),read(RT),cnt=res=0;
	INV[1]=1;for(int i=2;i<=n;i++)INV[i]=1ll*INV[mod%i]*(mod-mod/i)%mod;
	for(int i=1;i<=n;i++)read(a[i]),b[i]=a[i];
	sort(b+1,b+n+1),m=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)w[lower_bound(b+1,b+m+1,a[i])-b].push_back(i);
	for(int i=1,x,y;i<n;i++)read(x),read(y),v[x].push_back(y),v[y].push_back(x);
	dep[RT]=fa[RT]=0,dfs1(RT),top[RT]=RT,dfs2(RT),tot=0;
	for(int i=1;i<=n;i++)if(top[i]==i)build(rt[i],dfn[i],dfn[bot[i]]);
	for(int i=1;i<=n;i++)col[i]=asc[i]=false,lid[i][0]=lid[i][1]=lis[i]=0;
	for(int i=1;i<=n;i++)if(i!=RT)c[fa[i]]++;
	for(int i=m;i;i--){
		for(auto x:w[i])flip(x);w[i].clear();
		res=(1ll*seg[rt[RT]].tr.bs*(b[i]-b[i-1])+res)%mod;
	}
	print(res),putchar('\n');
	for(int i=1;i<=n;i++)v[i].clear();
}
int main(){
	freopen("dfs.in","r",stdin);
	freopen("dfs.out","w",stdout);
	read(T);
	while(T--)mina();
	return 0;
}
```



---

## 作者：Renshey (赞：10)

#### 题解

考虑最小值的期望，可以直接差分处理，转化为求最小值 $\ge x$ 的概率。于是可以枚举 $x$，然后将所有点分为两类，$<x$ 的点设为白点（用 $0$ 表示），$\ge x$ 的点设为黑点（用 $1$ 表示）。

考虑 dp，设 $f_u$ 表示从 $u$ 出发的所有链的全黑概率之和，$g_u$ 表示从 $u$ 的子树内的点出发的所有链的全黑概率之和，$col_u$ 为 $u$ 的颜色。考虑如何转移，首先注意到从 $u$ 出发的链中，经过一个全黑的子树不会产生任何影响，而经过一个非全黑的子树则直接停止，因此在某个子树内结束的概率即为所有非全黑的子树均未在该子树之前被选择的概率。因此设 $tag_u$ 表示 $u$ 是否全黑，$tag_u=1$ 时表示 $u$ 的子树全为黑点；再设 $cnt_u$ 表示 $\sum_{v\in son(u)} 1-tag_v$，即 $u$ 的非全黑儿子个数。可以列出转移式如下：

$$f_u = [col_u = 1] (1+\sum_{v \in son(u)}\frac{1}{cnt_u+tag_v} \times f_v)$$

$$g_u = f_u + \sum_{v \in son(u)} g_v$$

由于 $tag_v\in\{0,1\}$，因此可以将 $f_u$ 拆为 $f_{u,i}$，其中当 $i=tag_u$ 时表示原来的 $f_u$，否则表示 $0$。这样的意义在于转移可以直接写为 $\sum_{v \in son(u)}\frac{1}{cnt_u} \times f_{v,0} + \frac{1}{cnt_u+1} \times f_{v,1}$，这样就可以将 dp 写为矩阵形式方便优化。

写出矩阵形式后形如 $F_u = G_u + T_u \times \sum_{v \in son(u)} F_v$，其中 $G_u$ 和 $T_u$ 只与 $col_u,tag_u,cnt_u$ 相关。

考虑如何快速计算每一个 $x$ 对应的答案，不难发现可以按 $x$ 从大到小的顺序进行修改，由于每个点只会发生一次 $col$ 与 $tag$ 的改变，因此需要修改的次数是 $O(n)$ 级别的。直接使用全局平衡二叉树维护动态 dp 即可。

具体实现时可能较为卡常，注意到矩阵中非常数项较少，可以直接记录矩阵中的非常数项进行计算，可以简单理解为每个节点维护的信息是一个函数。

时间复杂度 $O(n \log n)$，空间复杂度 $O(n)$。

#### 代码
```cpp
#include <bits/stdc++.h>
#define Getchar() p1 == p2 and (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++
char buf[1 << 21], *p1, *p2;
inline int read (void)
{
	int x = 0; char c = Getchar(); bool f = (c != '-');
	while (c < '0' or c > '9') c = Getchar(), f &= c != '-';
	while (c >= '0' and c <= '9') x = x * 10 + c - 48, c = Getchar();
	return f ? x : -x;
}
const int mod = 998244353;
const int maxn = 400000 + 10;
int n, m, r, inv[maxn], a[maxn], b[maxn], t[maxn], ans;
int dep[maxn], fa[maxn], siz[maxn], son[maxn], top[maxn], dfn[maxn], times;
int root, anc[maxn], ch[maxn][2], st[maxn], tp; bool vis[maxn];
std::vector<int> e[maxn], w[maxn];
inline int plus (int x, int y) {return x + y < mod ? x + y : x + y - mod;}
inline void dfs1 (int u, int fr)
{
	dep[u] = dep[fa[u] = fr] + 1; siz[u] = 1; son[u] = 0;
	for (int v: e[u]) if (v != fr)
	{
		dfs1(v, u); siz[u] += siz[v];
		if (siz[v] > siz[son[u]]) son[u] = v;
	}
}
inline void dfs2 (int u)
{
	dfn[u] = ++times;
	if (son[u]) top[son[u]] = top[u], dfs2(son[u]);
	for (int v: e[u]) if (v != fa[u] and v != son[u]) top[v] = v, dfs2(v);
}
struct matrix
{
	int a[3][3];
	inline int * operator [] (int x) {return a[x];}
	inline void clear (void) {memset(a, 0, sizeof(a));}
	inline friend matrix operator * (matrix A, matrix B)
	{
		matrix C; long long D[3][3] = {0};
		for (int i = 0; i < 3; i++) for (int k = 0; k < 3; k++) for (int j = 0; j < 3; j++) D[i][j] += 1LL * A[i][k] * B[k][j];
		for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) C[i][j] = D[i][j] % mod;
		return C;
	}
} tr[maxn], K[maxn];
struct vector
{
	int a[3];
	inline int & operator [] (int x) {return a[x];}
	inline void clear (void) {a[0] = a[1] = a[2] = 0;}
	inline friend vector operator + (vector A, vector B)
	{
		vector C;
		for (int i = 0; i < 3; i++) C[i] = plus(A[i], B[i]);
		return C;
	}
	inline friend vector operator - (vector A, vector B)
	{
		vector C;
		for (int i = 0; i < 3; i++) C[i] = plus(A[i], mod - B[i]);
		return C;
	}
	inline friend vector operator * (matrix A, vector B)
	{
		vector C; long long D[3] = {0};
		for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) D[i] += 1LL * A[i][j] * B[j];
		for (int i = 0; i < 3; i++) C[i] = D[i] % mod;
		return C;
	}
} g[maxn], h[maxn], B[maxn];
int cnt[maxn]; bool col[maxn], tag[maxn];
inline void pushup (int u)
{
	B[u] = B[ch[u][0]] + K[ch[u][0]] * (g[u] + tr[u] * (h[u] + B[ch[u][1]]));
	K[u] = K[ch[u][0]] * tr[u] * K[ch[u][1]];
}
inline int build2 (int l, int r)
{
	int sum = 0;
	for (int i = l; i <= r; i++) sum += siz[st[i]] - siz[son[st[i]]];
	for (int i = l, cnt = 0; i <= r; i++)
		if (2 * (cnt += siz[st[i]] - siz[son[st[i]]]) >= sum)
		{
			ch[st[i]][0] = l < i ? build2(l, i - 1) : 0;
			ch[st[i]][1] = i < r ? build2(i + 1, r) : 0;
			anc[ch[st[i]][0]] = anc[ch[st[i]][1]] = st[i];
			return pushup(st[i]), st[i];
		}
	return 0;
}
inline int build1 (int p)
{
	for (int u = p; u; u = son[u]) vis[u] = true;
	for (int u = p; u; u = son[u]) for (int v: e[u]) if (!vis[v]) anc[build1(v)] = u;
	tp = 0;
	for (int u = p; u; u = son[u]) st[++tp] = u;
	return build2(1, tp);
}
inline void calc (int u)
{
	g[u].clear(); tr[u].clear(); tr[u][0][0] = 1;
	if (col[u])
	{
		g[u][0] = g[u][tag[u] + 1] = 1;
		tr[u][0][1] = inv[cnt[u]]; tr[u][0][2] = inv[cnt[u] + 1];
		tr[u][tag[u] + 1][1] = inv[cnt[u]]; tr[u][tag[u] + 1][2] = inv[cnt[u] + 1];
	}
	for (; u; u = anc[u])
	{
		if (anc[u] and ch[anc[u]][0] != u and ch[anc[u]][1] != u) h[anc[u]] = h[anc[u]] - B[u];
		pushup(u);
		if (anc[u] and ch[anc[u]][0] != u and ch[anc[u]][1] != u) h[anc[u]] = h[anc[u]] + B[u];
	}
}
inline void add (int x) {for (int i = x; i <= n; i += i & (-i)) t[i]++;}
inline int ask (int l, int r)
{
	int res = 0;
	for (int i = r; i; i -= i & (-i)) res += t[i];
	for (int i = l - 1; i; i -= i & (-i)) res -= t[i];
	return res;
}
inline void flip (int x)
{
	col[x] = true; add(dfn[x]);
	for (int u = x; u and ask(dfn[u], dfn[u] + siz[u] - 1) == siz[u]; u = fa[u])
	{
		tag[u] = true;
		if (fa[u]) cnt[fa[u]]--;
	}
	calc(x);
	for (int u = x; fa[u] and ask(dfn[u], dfn[u] + siz[u] - 1) == siz[u]; u = fa[u]) calc(fa[u]);
}
inline void solve (void)
{
	n = read(); r = read(); inv[0] = inv[1] = 1; ans = 0;
	for (int i = 2; i <= n; i++) inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;
	for (int i = 1; i <= n; i++) a[i] = b[i] = read();
	std::sort(b + 1, b + n + 1); m = std::unique(b + 1, b + n + 1) - b - 1;
	for (int i = 1; i <= n; i++) w[std::lower_bound(b + 1, b + m + 1, a[i]) - b].push_back(i);
	for (int i = 1, u, v; i < n; i++) u = read(), v = read(), e[u].push_back(v), e[v].push_back(u);
	dfs1(r, 0); top[r] = r; times = 0; dfs2(r); K[0].clear(); K[0][0][0] = K[0][1][1] = K[0][2][2] = 1;
	for (int i = 1; i <= n; i++) if (i != r) cnt[fa[i]]++;
	for (int i = 1; i <= n; i++) tr[i][0][0] = 1;
	anc[root = build1(r)] = 0;
	for (int i = m; i; i--)
	{
		for (int u: w[i]) flip(u);
		ans = (ans + 1LL * (b[i] - b[i - 1] + mod) * B[root][0]) % mod;
	}
	printf("%d\n", ans);
	for (int i = 1; i <= n; i++) std::vector<int>().swap(e[i]), vis[i] = col[i] = tag[i] = false, cnt[i] = t[i] = 0;
	for (int i = 1; i <= n; i++) g[i].clear(), h[i].clear(), B[i].clear(), tr[i].clear(), K[i].clear();
	for (int i = 1; i <= m; i++) std::vector<int>().swap(w[i]);
}
signed main ()
{
	for (int T = read(); T--; ) solve();
	return 0;
}
```

---

## 作者：pigstd (赞：9)

写在前面：三个月前的 ZJOI Day2 考场上，我感觉自己口胡出了树剖的 $\log ^2$ 做法，但是仅剩的一小时以及前一天的惨痛经历让我选择放弃，最终在 T2 暴力没写完以及挂分下结束了比赛。我无法得知我做出了另一个选择的结局是什么，会是没写完或者没调出来——这是大概率的事情吧，还是直接奇迹翻盘？但是结局已经固定了，这只是我自己的意淫罢了。

------------------------------------------------------------------------------------------------------------

先离散化，考虑对于每个 $i$ 计算答案 $\ge i$ 的几率。令 $\min_v$ 表示 $v$ 子树中的权值最小值。

考虑 $f_{u,i}$ 表示 $\displaystyle \sum_{v\in tree(u)}\text{u 到 v 的权值最小值 }\ge \text{i 的几率}$。那么转移的时候，对于每个 $v \in son(u),i\in [1,n]$，若其余儿子的最小值中 $< i$ 的有 $x$ 个，那么 $f_{v,i}$ 转移到 $f_{u,i}$ 的时候就要 $\times \frac 1 {i+1}$，这是因为必须在走到这个 $i$ 个节点前走到 $v$ 里面。然后要给 $f_{u,i},i\in [1,a_u]$ 加上 $1$（$F(u,u)$ 本身），并且将 $f_{u,i},i\in [a_u+1,n]$ 全部设置成 $0$。

其实考虑到这转移的时候，看起来可以先把所有儿子的值加起来，但是这个东西是要除掉 $v$ 后的，比较恶心，但是也没有想象中那么恶心。实际上只要把每个 $v$，$f_{v,i},i\le \min_v$ 与 $f_{v,i},i > \min_v$ 分开来，然后就可以愉快的把每个儿子的值都加起来了。

这显然可以想到线段树合并，那么分开来这个操作其实就是线段树分裂，然后便是一个区间乘和区间加，打个标记就行，一看就是 $\mathcal{O}(n\log n)$ 的，代码不好写，而且还比较卡常，uoj 上被 hack 数据卡了，但是官方数据能过。

[代码实现](https://www.luogu.com.cn/paste/blglh59t)。

---

## 作者：2022tysc0776 (赞：7)

本篇题解需要大家先学习好动态 DP 的基础内容后再来观看。

---

这种题要么直接算出遍历每个点算出 $f$ 值，要么枚举最小值用一些办法计算答案，而本题不好直接计算 $f$ 值，所以选择后者。

枚举最小值 $mn$，称 $u$ 是 good 点，当且仅当 $a_u\ge mn$，否则称 $u$ 是 bad 点。

设 $sub_u$ 为 $u$ 的子树。称 $sub_u$ 是 good 子树，当且仅当 $sub_u$ 中没有 bad 点，否则称 $sub_u$ 是 bad 子树。

遍历了 bad 点后，这次深搜的最小值一定会比 $mn$ 小，就不合法了。

深搜进入一个点后不遍历完整个子树是不会出来的，所以当进入一个 bad 子树后，是不会再出来了，因为不能碰到 bad 点，所以在遍历到 bad 点前必须到终点停下来。

所以在进入终点前不能进入 bad 子树（当然，如果终点就在一个 bad 子树中，肯定是要进入这个子树中的，但是不能进入别的 bad 子树），而进入 good 子树后不会有任何影响。

那么我们考虑，有 $n$ 个 bad 子树，$m$ 个 good 子树，和一个目标子树（就是终点所在的子树），每次等概率选择一个，good 子树摇到后会直接扔掉（因为不会影响局面），bad 子树摇到后就退出（和前面同理，进入终点前不能进入 bad 子树），目标子树摇到后胜利，那么胜利的概率是多少？

答案是 $\frac{1}{n+1}$，为什么？

考虑对于每一个没有结束的局面，都会在 $n$ 个 bad 子树和目标子树中等概率选择一个，所以概率为 $\frac{1}{n+1}$。

接下来就可以推 DP 方程了。设 $dp_{u} = \sum f(u,x)$ ，$cnt_u$ 表示 $u$ 的 bad 子树个数。

表达式如下：

$$
dp_{u}=(\sum_{v\in son(u)}\frac{1}{cnt_u+[sub_v\ is\ good]} dp_v + 1) \times [u\ is\ good] 
$$

$$
sum_{u}=\sum_{v\in son(u)} sum_v + dp_{u}
$$

最后的答案为 $sum_{root}$。

我们发现枚举最小值后会对某一些信息进行修改，所以考虑动态 DP。

由于有一个对 good 和 bad 子树不一样的项，所以我们把其分开，$fg$ 表示轻儿子中 good 子树的贡献，$fb$ 表示轻儿子中 bad 子树的贡献，$wson$ 表示重儿子，$g_u=\sum_{v\in son(x)\ and\ v \ne wson(x)} sum_v$，然后方程就变成了：

$$
dp_{u}=(\frac{1}{cnt_u+1}fg_u+\frac{1}{cnt_u}fb_u+1+\frac{1}{cnt(x)+[sub_{wson(x)}\ is\ good]}dp_{wson_u})\times [u\ is\ good]
$$

$$
sum_{u}=g_u+sum_{wson_u}+dp_u
$$

然后考虑矩阵，**钦定**：
$$
k=\frac{1}{cnt(x)+[sub_{wson(x)}\ is\ good]}\times [u\ is\ good]\\
b=(\frac{1}{cnt(x)}fb_x+\frac{1}{cnt(x)+1}fg_x+1)\times [u\ is\ good]\\
c=g_x
$$

$$
\begin{bmatrix}
  k& 0 & b\\
  k& 1 & b+c\\
  0& 0 &1
\end{bmatrix}
\begin{bmatrix}
  dp_{wson(x)}\\
  sum_{wson(x)}\\
  1
\end{bmatrix}
=
\begin{bmatrix}
  dp_x\\
  sum_x\\
  1
\end{bmatrix}
$$

然后我们考虑会修改的内容如下:

$$
\left \{  
 \begin{array}{lcr}
   u\::\ good\to bad & \\
   sub_u\:: good\to bad & \\
   cnt(u)\:: +1
 \end{array}
\right.
$$

然后发现一共其实只有 $n$ 个点需要修改，对于子树的修改也只需要修改 $n$ 次（仔细思考一下就知道了），$\sum cnt(u)$ 的总值为 $n-1$。所以修改次数是 $O(n)$ 级别的。

对于修改一个点，把 good 变成 bad，只需要改变当前点的 $k$ 和 $b$ 即可。

对于修改一个子树，把 good 变成 bad，需要分类讨论一下：

​	1.当其是父亲的重儿子时，只需要修改 $k$ 即可。

​	2.当其是父亲的轻儿子时，需要修改 $fg_{fa}$ 和 $fb_{fa}$（因为当前子树变成了 bad，所以其贡献会从 $fg_{fa}$ 转移到 $fb_{fa}$ 中）。

对于修改 $cnt$ 值，修改 $k$ 和 $b$ 即可。

然后每次对于某种修改，按正常动态 DP 的方式修改好整个全局平衡二叉树即可。

（这里讲的可能不够细节，如有问题可在评论区指出）

[代码](https://www.luogu.com.cn/paste/m1k74imo)。

（~摆出来也没人看~）

---

## 作者：Graphcity (赞：6)

动态规划方面其它题解已经讲的非常清楚了，这篇题解主要分析的是其它题解一笔带过的计算细节。

从大到小枚举一个值 $mn$，当最小值 $\ge mn$ 时，首先设 $f(x)$ 为从 $x$ 开始深搜的概率之和，$f'(x)$ 为所有轻子树造成的贡献；$g(x)$ 为 $x$ 子树内的 $f(x)$ 之和，$g'(x)$ 为轻子树对和造成的贡献。给出如下定义：

- 结点 $i$ 为 **黑色** 当且仅当 $val_i<mn$，否则它为 **白色**。

- 子树 $i$ 为 **灰色** 当且仅当 $i$ 中存在一个黑色结点，否则它为 **白色**。

设结点 $x$ 当前有 $cnt_x$ 个灰色子树，可以列出如下状态转移方程：

$$
\begin{cases}
f(x)=[x\ \text{is white}]\times(1+\sum_{y\in son(x)}\dfrac{1}{cnt_x+[sub_y\ \text{is white}]}f(y))\\
g(x)=f(x)+\sum_{y\in son(x)}g(y)
\end{cases}
$$

根据动态 DP 的套路，分离轻重子树的贡献（下面的 $y$ 指的是 $x$ 的重儿子）：

$$
\begin{cases}
f(x)=[x\ \text{is white}]\times(f'(x)+\dfrac{1}{cnt_x+[sub_y\ \text{is white}]}f(y))\\
g(x)=f(x)+g'(x)+g(y)
\end{cases}
$$

但是，$f'(x)$ 中既有灰色子树，又有白色子树，不好修改。这时我们考虑分离这两种子树：设 $f'_0(x)$ 为灰色子树的 $f$ 之和，$f'_1(x)$ 就是白色子树的 $f$ 之和，再次改写状态转移方程：

$$
\begin{cases}
f(x)=[x\ \text{is white}]\times(f'_0(x)\dfrac{1}{cnt_x}+f'_1(x)\dfrac{1}{cnt_x+1}+\dfrac{1}{cnt_x+[sub_y\ \text{is white}]}f(y))\\
g(x)=f(x)+g'(x)+g(y)
\end{cases}
$$

事实上，在动态 DP 的过程中，**与轻子树相关的数都可以视为常数**。我们用字母来替代常数，有：

$$
\begin{cases}
f(x)=kf(y)+b\\
g(x)=kf(y)+g(y)+b+c
\end{cases}
$$

写成矩阵乘法的形式：

$$
\begin{bmatrix}k & 0 & b\\ k & 1 & b+c\\ 0 & 0 & 1 \end{bmatrix}
\times
\begin{bmatrix}f(y)\\ g(y)\\ 1\end{bmatrix}
=
\begin{bmatrix}f(x)\\ g(x)\\ 1\end{bmatrix}
$$

根据 [P3781 SDOI2017 切树游戏](https://www.luogu.com.cn/problem/P3781) 的套路，这样的转移矩阵是可以简便计算的：

$$
\begin{bmatrix}a_1 & 0 & b_1\\ c_1 & 1 & d_1\\ 0 & 0 & 1 \end{bmatrix}
\times
\begin{bmatrix}a_2 & 0 & b_2\\ c_2 & 1 & d_2\\ 0 & 0 & 1 \end{bmatrix}
=
\begin{bmatrix}a_1a_2 & 0 & a_1a_2+b_1\\ c_1a_2+c_2 & 1 & a_1b_2+d_1+d_2\\ 0 & 0 & 1 
\end{bmatrix}
$$

这样就只需要维护四个位置的值了。每次修改，我们会将一个黑色结点变为一个白色结点，一共有三种类型的操作：

- 单点：由黑色变为白色
- 子树：部分子树由灰色变为白色
- $cnt$：部分点的 $cnt$ 会减去一

由于子树至多进行一次变色，且 $cnt$ 总和为 $n-1$，所以可以暴力跳父亲来做下面两种操作。在每次操作之前，先要将当前点对所有轻边父亲造成的贡献消去，操作完再加上，这样才能保证结果的正确性。

这三种操作都会对自己，父亲和祖先轻边的父亲造成一些影响，用全局平衡二叉树来维护即可。操作间顺序不重要，不会影响答案，但必须保证操作完单点信息正确。时间复杂度 $O(n\log n)$。

[Code](https://www.luogu.com.cn/paste/4hkpaor5)

---

## 作者：whiteqwq (赞：5)

[P8334 [ZJOI2022] 深搜](https://www.luogu.com.cn/problem/P8334) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/16227139.html)

## 题意

定义 $f(x,y)$ 合法当且仅当 $y$ 在 $x$ 子树中，其值为对 $x$ 的子树进行 dfs，往下走随机选一个没有访问过的点，遇到 $y$ 时经过的点点权最小值的期望。

求 $\sum_{x,y}f(x,y)$。

$1\leqslant n\leqslant 4\times 10^5$。

## 分析

可能有点口胡，假了赶紧来喷我（

离散化，枚举一个 $i$，令权值大于等于 $i$ 的点为黑点，那么我们就是要支持将一个点由黑染白，以及维护简单路径只经过黑点的点对，dfs 时不遇到白点的概率之和。

考虑将子树内有白点的点叫灰点，那么可以发现我们不能 dfs 入没有 $y$ 的灰点子树。转移方程大概长这样：（令 $s(x)$ 为 $x$ 的灰儿子数量）

$$f_x=\begin{cases}0&[x\ \text{is}\ \text{white}]\\\sum_{y\in son(x)}\begin{cases}\frac{f_y}{s_x}&[y\ \text{is}\ \text{grey}]\\\frac{size_y}{s_x+1}&\text{otherwise}\end{cases}\end{cases}$$

这样我们就得到了一个 $O(n^2)$ 的解法。

直接将转移方程刻画成矩阵，每次加入白点的时候暴力更新非灰的祖先（更新单点的转移系数以及一条链的 $f$），用一个全局平衡二叉树就是 $O(n\log n)$ 了。

## 代码

暂时鸽一手。

---

## 作者：UKE_Automation (赞：1)

### [ZJOI2022] 深搜

[$\text{Link}$](https://www.luogu.com.cn/problem/P8334)

首先最小值期望不好直接转移，所以考虑拆成最小值乘上概率。如果用传统的树形 dp 状态数必然是两维的，承受不了，考虑另一种思路。我们从大往小枚举当前最小值 $k$，只保留所有权值 $\ge k$ 的节点，然后直接算可达概率和即可。这样的话我们求出来的就是最小值 $\ge k$ 的概率总和，在最后做一下差分即可得到真实答案。

接下来令权值 $\ge k$ 的节点为白点，权值 $<k$ 的为黑点，记作 $col_i=1/0$；子树内全为白点的子树为白子树，否则为黑子树，记作 $tag_i=1/0$。设 $f(i)$ 表示从 $i$ 出发，只经过白点到达子树中每个点的概率总和。

考虑转移，先判掉 $col_i=0$ 的情况，然后枚举转移的子树；但是此时我们并不一定是直接走进这个子树，而是有可能先走一些白子树后再走。设 $cnt_i$ 表示 $i$ 有多少个黑子树，那么这个概率就是 $\tfrac{1}{1+cnt_i-(1-tag_j)}=\tfrac{1}{cnt_i+tag_j}$，原因在于我们随机到白子树相当于重选，而第一次在其他黑子树与目标子树之间选择的概率就是上式。于是不难得出转移方程：
$$
f(i)=[col_i=1]\left(1+\sum_{j\in son(i)} \frac{1}{cnt_i+tag_j} f(j)\right)
$$
然后我们再设 $g(i)$ 表示子树内所有 $f(i)$ 的和，答案就是 $g(rt)$。这样的话我们就可以得出一个 $O(n^2)$ 的做法。考虑优化，我们在 $k$ 减小的时候，改变的值有 $col,cnt,tag$，而这些值的改变总次数都是 $O(n)$ 的，所以考虑使用动态 dp。

先把 $f(i)$ 拆开：
$$
f(i)=[col_i=1]\left(1+\sum_{} \frac{1}{cnt_i+tag_j}f(j)\right)+[col_i=1]\times \frac{1}{cnt_i+tag_{\text{son}(i)}} f(\text{son(i)})
$$
显然这可以写成 $f(i)=af(\text{son(i)})+b$ 的形式，然后用矩阵优化。不过这里会发现，当我们修改 $cnt_i$ 的时候，$b$ 的变化是不好计算的，原因在于我们没有把轻子树贡献单独拎出来。这里运用一个经典技巧，我们统计轻子树贡献的时候开两个 $f$，分别统计 $tag=0$ 和 $tag=1$ 的贡献和 $fa,fb$，这样前面的和式就可以直接单独计算了。

最后我们再维护一下轻儿子 $g(i)$ 的和 $g$，那么我们就可以写出转移矩阵：
$$
\begin{bmatrix}
a& 0& b\\
a& 1& b+g\\
0& 0& 1
\end{bmatrix}\times 
\begin{bmatrix}
f(\text{son}(i))\\
g(\text{son}(i))\\
1\\

\end{bmatrix}=
\begin{bmatrix}
f(i)\\
g(i)\\
1
\end{bmatrix}
$$
这样的话用全局平衡二叉树维护一下就可以做到 $O(n\log n)$ 了。注意我们在全局平衡二叉树上找 $tag$ 的时候找的不是当前树根，而是对应链的链头。

```cpp
#include <bits/stdc++.h>
#define il inline

using namespace std;

const int Maxn = 8e5 + 5;
const int Inf = 2e9;
const int Mod = 998244353;
il int Add(int x, int y) {return x + y >= Mod ? x + y - Mod: x + y;} il void pls(int &x, int y) {x = Add(x, y);}
il int Del(int x, int y) {return x - y < 0 ? x - y + Mod : x - y;} il void sub(int &x, int y) {x = Del(x, y);}
il int qpow(int a, int b) {int res = 1; for(; b; a = 1ll * a * a % Mod, b >>= 1) if(b & 1) res = 1ll * res * a % Mod; return res;}
il int Inv(int a) {return qpow(a, Mod - 2);}
template <typename T> il void chkmax(T &x, T y) {x = (x >= y ? x : y);}
template <typename T> il void chkmin(T &x, T y) {x = (x <= y ? x : y);}
template <typename T>
il void read(T &x) {
	x = 0; char ch = getchar(); bool flg = 0;
	for(; ch < '0' || ch > '9'; ch = getchar()) flg = (ch == '-');
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	flg ? x = -x : 0;
}
template <typename T>
il void write(T x, bool typ = 1) {
	static short Stk[50], Top = 0;
	x < 0 ? putchar('-'), x = -x : 0;
	do Stk[++Top] = x % 10, x /= 10; while(x);
	while(Top) putchar(Stk[Top--] | 48);
	typ ? putchar('\n') : putchar(' ');
}
il void IOS() {ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);}
il void File() {freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);}
bool Beg;

int T, n, rt;
int a[Maxn], b[Maxn], tot;
int head[Maxn], edgenum;
struct node {
	int nxt, to;
}edge[Maxn << 1];
void add(int u, int v) {
	edge[++edgenum] = {head[u], v}; head[u] = edgenum;
	edge[++edgenum] = {head[v], u}; head[v] = edgenum;
}
vector <int> m1[Maxn], m2[Maxn];
int fth[Maxn], siz[Maxn], son[Maxn], mn[Maxn];
int col[Maxn], tag[Maxn], cnt[Maxn], f[Maxn], sf[Maxn][2], g[Maxn], sg[Maxn];
void dfs1(int x, int f) {
	siz[x] = 1; mn[x] = a[x]; fth[x] = f;
	for(int i = head[x]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if(to == f) continue;
		cnt[x]++;
		dfs1(to, x); chkmin(mn[x], mn[to]); siz[x] += siz[to];
		if(siz[son[x]] < siz[to]) son[x] = to;
	}
	m2[mn[x]].push_back(x);
}

int inv[Maxn];
struct Mat {
	int a, b, c, d;
	Mat operator * (Mat y) {return {1ll * a * y.a % Mod, Add(1ll * a * y.b % Mod, b), Add(1ll * c * y.a % Mod, y.c), Add(1ll * c * y.b % Mod, Add(d, y.d))};}
}p[Maxn];

int root;
int bel2[Maxn];
namespace GBT {
	struct node {
		int l, r, fa;
		Mat sum;
	}t[Maxn];
	int bel[Maxn];
	#define ls(p) t[p].l
	#define rs(p) t[p].r
	#define fa(p) t[p].fa
	int b[Maxn], bs[Maxn], tot;
	void clear() {
		for(int i = 1; i <= n; i++) ls(i) = rs(i) = fa(i) = t[i].sum.a = t[i].sum.b = t[i].sum.c = t[i].sum.d = 0;
	}
	int cbuild(int l, int r) {
		int L = l, R = r, res = 0;
		while(L <= R) {
			int mid = (L + R) >> 1;
			if(2 * (bs[mid - 1] - bs[l - 1]) <= bs[r] - bs[l - 1]) res = mid, L = mid + 1;
			else R = mid - 1;
		}
		int rt = b[res];
		if(l < res) ls(rt) = cbuild(l, res - 1), fa(ls(rt)) = rt;
		if(r > res) rs(rt) = cbuild(res + 1, r), fa(rs(rt)) = rt;
		return rt;
	}
	int build(int x) {
		int y = x;
		do {
			for(int i = head[x]; i; i = edge[i].nxt) {
				int to = edge[i].to;
				if(to == son[x] || to == fth[x]) continue;
				fa(build(to)) = x;
			}
			bel[x] = y;
		}while(x = son[x]);
		tot = 0;
		do {
			b[++tot] = y;
			bs[tot] = bs[tot - 1] + siz[y] - siz[son[y]];
		}while(y = son[y]);
		int rt = cbuild(1, tot);
		for(int i = 1; i <= tot; i++) bel2[b[i]] = rt;
		return rt;
	}
	void pushup(int x) {
		t[x].sum = p[x];
		if(ls(x)) t[x].sum = t[ls(x)].sum * t[x].sum;
		if(rs(x)) t[x].sum = t[x].sum * t[rs(x)].sum;
	}
	int isroot(int x) {return ls(fa(x)) != x && rs(fa(x)) != x;}
	void reset(int x) {
		int k = col[x] * inv[cnt[x] + tag[son[x]]];
		int b = col[x] * Add(Add(1ll * inv[cnt[x]] * sf[x][0] % Mod, 1ll * inv[cnt[x] + 1] * sf[x][1] % Mod), 1);
		int g = sg[x];
		p[x] = {k, b, k, Add(b, g)}; pushup(x);
	}
	void mdf(int x) {
		bool flg = 1;
		while(x) {
			if(flg) reset(x);
			else pushup(x);
			if(isroot(x) && fa(x)) {
				sub(sf[fa(x)][tag[bel[x]]], f[x]), sub(sg[fa(x)], g[x]);
				f[x] = t[x].sum.b, g[x] = t[x].sum.d;
				pls(sf[fa(x)][tag[bel[x]]], f[x]), pls(sg[fa(x)], g[x]);
				flg = 1;
			}
			else flg = 0;
			x = fa(x);
		}
	}
}

int ans[Maxn];
void init() {
	tot = edgenum = 0;
	for(int i = 1; i <= n; i++) {
		ans[i] = p[i].a = p[i].b = p[i].c = p[i].d = son[i] = head[i] = col[i] = tag[i] = cnt[i] = sf[i][0] = sf[i][1] = sg[i] = f[i] = g[i] = 0;
		m1[i].clear(), m2[i].clear();
	}
	GBT::clear();
}

void solve() {
	init();
	read(n), read(rt);
	for(int i = 1; i <= n; i++) read(a[i]), b[++tot] = a[i];
	sort(b + 1, b + tot + 1); tot = unique(b + 1, b + tot + 1) - b - 1;
	for(int i = 1; i <= n; i++) m1[a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b].push_back(i); 
	for(int i = 1, u, v; i < n; i++) {
		read(u), read(v);
		add(u, v);
	}
	inv[1] = 1;
	for(int i = 2; i <= n; i++) inv[i] = 1ll * inv[Mod % i] * (Mod - Mod / i) % Mod;
	dfs1(rt, 0);
	root = GBT::build(rt);
	for(int i = tot; i >= 1; i--) {
		for(auto x : m1[i]) col[x] = 1, GBT::mdf(x);
		for(auto x : m2[i]) {
			tag[x] = 1;
			if(!fth[x]) continue;
			if(son[fth[x]] == x) cnt[fth[x]]--, GBT::mdf(fth[x]);
			else {
				int sum = f[bel2[x]];
				sub(sf[fth[x]][0], sum), pls(sf[fth[x]][1], sum);
				cnt[fth[x]]--;
				GBT::mdf(fth[x]);
			}
		}
		ans[i] = GBT::t[root].sum.d;
	}
	int res = 0;
	for(int i = tot; i >= 1; i--) pls(res, 1ll * Del(ans[i], ans[i + 1]) * b[i] % Mod);
	write(res);
}

bool End;
il void Usd() {cerr << (&Beg - &End) / 1024.0 / 1024.0 << "MB " << (double)clock() * 1000.0 / CLOCKS_PER_SEC << "ms\n"; }
int main() {
	read(T);
	while(T--) solve();
	Usd();
	return 0;
}
```

---

## 作者：居然有个高手 (赞：1)

怎么大家都会拆贡献？来写一篇与拆贡献无关的做法。

若对每个点 $u$ 钦定其儿子访问顺序，我们发现 $f(x,y)$ 等于 $x\to y$ 路径上的最小点权或每次 $u\to v(y\in subtree(v))$ 之前 $u$ 访问的其他儿子的子树最小值。即若干个子树 $\min$ 与单点点权取 $\min$ 的形式。

我们不妨对每个 $y$ 考虑其所有祖先对它的贡献。我们称上述的某个子树访问或单点访问为一个贡献点，钦定是哪个贡献点对 $y$ 产生了贡献，那么就要求所有比它小的贡献点均没有被取到，也就是对于某个点 $u$ 钦定了一些儿子的访问顺序在我们 $x\to y$ 路径上的儿子的后面。不难发现若钦定了 $w$ 个儿子，则其概率为 $1-\sum_{i=1}^w \frac 1 {i\times (i+1)}$。枚举 $y$ 与 $x$，按权值从小往大处理所有 $x\to y$ 的贡献点权值，即可做到 $O(n^3)$。

考虑上述过程的优化：对于一个贡献点，每次加入新的贡献点导致其权值改变时，其变化量不与 $x$ 相关。于是我们可以按照 dfs 序处理 $y$，每次加入一些贡献点，处理其与前面的贡献点的影响，简单统计答案即可。值得注意的是对于点 $u$ 的每个儿子 $v$，贡献点存在一定差别，但若将 $v$ 按照其子树 $\min$ 排序后则邻项贡献点差别数量为 $1$。因此可以简单做到 $O(n^2)$。

放一份 $25$ 分的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4e5+5,mod=998244353;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
inline int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}return ans;
}
int T,n,rt,a[N],mn[N],ans,cnt,inv[N],vvv[N],d[N];
vector<int>e[N];
inline void dfs(int x,int fa){
	mn[x]=a[x];
	if(fa)mn[x]=min(mn[x],a[fa]);
	for(int y : e[x]){
		if(y^fa)d[y]=d[x]+1,dfs(y,x),mn[x]=min(mn[x],mn[y]);
	}
}
struct node{
	int val,w,w2,op,d,id;
}tmp[N];
struct DATA{
	int val,d,id;
}p[N<<2];
inline bool cmp(int a,int b){
	return mn[a]<mn[b];
}
inline void insert(int val,int w,int w2,int d,int r,int id){
	for(int j = 1;j<=cnt;j++)if(tmp[j].val>val||tmp[j].val==val&&(tmp[j].d<d||tmp[j].d==d&&tmp[j].id>id)){
		if(w2==0)tmp[j].op++;
		else tmp[j].w=tmp[j].w*1ll*w2%mod;
	}
	tmp[++cnt]={val,0,w2,0,d,id};
	int ggg=d;
	for(int j = 1;j<cnt;j++)if((tmp[j].val<val||tmp[j].d==d&&tmp[j].id<id)&&!tmp[j].op)ggg=(ggg-tmp[j].w+mod)%mod;
	tmp[cnt].w=ggg*1ll*r%mod;
}
inline void del(int id){
	swap(tmp[id],tmp[cnt]);
	int w=ksm(tmp[cnt].w2,mod-2);
	for(int i = 1;i<cnt;i++)if(tmp[i].val>tmp[cnt].val||tmp[i].val==tmp[cnt].val&&(tmp[i].d<tmp[cnt].d||tmp[i].d==tmp[cnt].d&&tmp[i].id>tmp[cnt].id)){
		if(tmp[cnt].w2==0)tmp[i].op--;
		else tmp[i].w=1ll*tmp[i].w*1ll*w%mod;
	}
	cnt--;
}
inline void dfs2(int x,int fa){
	int gg=d[x];
	for(int i = 1;i<=cnt;i++){
		if(!tmp[i].op&&tmp[i].val<a[x])ans=(ans + tmp[i].val*1ll*tmp[i].w)%mod,gg=(gg+mod-tmp[i].w)%mod;
	}
	ans=(ans+1ll*a[x]*gg)%mod;
	vector<int>v;
	for(auto y : e[x])if(y!=fa)v.push_back(y);
	sort(v.begin(),v.end(),cmp);
	if(v.size())insert(a[x],inv[v.size()],0,d[x],1,v.size());
	for(int i = v.size()-1,y;i>=1;i--){
		y=v[i];
		insert(mn[y],inv[i]*1ll*inv[i+1]%mod,i*1ll*inv[i+1]%mod,d[x],inv[i+1],i);
	}
	int now = cnt;
	for(int i = 0,y;i<v.size();i++){
		y=v[i];
		dfs2(y,x);
		del(now--);
		insert(mn[y],inv[i+1]*1ll*inv[i+2]%mod,(i+1ll)*inv[i+2]%mod,d[x],inv[i+2],i);
	}
	for(int i = 0;i<v.size();i++)del(cnt);
}
int main(){
	T=read();
	while(T--){
		n=read(),rt=read();ans=0;
		inv[0]=inv[1]=1;
		cnt=0;
		for(int i = 2;i<=n+1;i++)inv[i]=inv[mod%i]*1ll*(mod-mod/i)%mod;
		for(int i = 1;i<=n;i++)e[i].clear(),a[i]=read();
		for(int i = 1,x,y;i<n;i++)x=read(),y=read(),e[x].push_back(y),e[y].push_back(x);
		d[rt]=1;dfs(rt,0);
		dfs2(rt,0);
		printf("%d\n",ans);
	}
	return 0;
}
```
不难发现，贡献点之间影响操作为区间乘，单点改，询问操作为区间和。不过需要维护乘 $0$ 的撤销操作。我们可以暴力打标记记录哪些点被归零，并放入栈中等待撤销。由于线段树结点总访问次数为 $O(n\log n)$ 级别，因此撤销操作复杂度也为 $O(n\log n)$。

时空复杂度：$O(n\log n)$。

贴一份代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4e5+5,mod=998244353;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
inline int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}return ans;
}
inline int md(int x){
	return x>=mod?x-mod:x;
}
int T,n,rt,a[N],mn[N],ans,cnt,inv[N],vvv[N],d[N],num,q[N],C;
vector<int>e[N];
inline void dfs(int x,int fa){
	mn[x]=a[x];
	if(fa)mn[x]=min(mn[x],a[fa]);
	for(int y : e[x]){
		if(y^fa)d[y]=d[x]+1,dfs(y,x),mn[x]=min(mn[x],mn[y]);
	}
}
inline bool cmp(int a,int b){
	return mn[a]<mn[b];
}
struct node{
	int val,w,w2,op,d,id;
}tmp[N];
struct DATA{
	int val,d,id;
	inline bool operator<(DATA b){
		if(val^b.val)return val<b.val;
		if(d^b.d)return d>b.d;
		return id<b.id;
	}
}p[N<<1];
struct tree{
	int l,r,tag1,tag2,s1,s3;
}t[N<<3];
#define mid (t[p].l+t[p].r>>1)
inline void up(int p){
	t[p].s1=md(t[p<<1].s1+t[p<<1|1].s1),t[p].s3=md(t[p<<1].s3+t[p<<1|1].s3);
}
inline void build(int p,int l,int r){
	t[p]={l,r,0,1,0,0};
	if(l==r)return;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
}
vector<pair<int,tree>>g[N];
inline void cg2(int p,int v);
inline void cg1(int p,int v){
	g[v].push_back({p,t[p]});
	t[p].tag1=v;t[p].tag2=1;t[p].s1=t[p].s3=0;
}
inline void cg2(int p,int v){
	t[p].tag2=1ll*v*t[p].tag2%mod,t[p].s1=1ll*v*t[p].s1%mod;t[p].s3=1ll*v*t[p].s3%mod;
}
inline void spread(int p,int op=1){
	if(t[p].tag1&&op){
		cg1(p<<1,t[p].tag1),cg1(p<<1|1,t[p].tag1);
		t[p].tag1=0;
	}
	if(t[p].tag2!=1){
		cg2(p<<1,t[p].tag2),cg2(p<<1|1,t[p].tag2);
		t[p].tag2=1;
	}
}
inline void change(int p,int l,int r,int v,int op){
	if(l<=t[p].l&&t[p].r<=r){
		if(!v)cg1(p,op);
		else cg2(p,v);
		return;
	}
	spread(p);
	if(!v)g[op].push_back({p,t[p]});
	if(l<=mid)change(p<<1,l,r,v,op);
	if(r>mid)change(p<<1|1,l,r,v,op);
	up(p);
}
inline void insert(int p,int pos,int val,int w){
	if(t[p].l==t[p].r){
		t[p].s1=w,t[p].s3=val*1ll*w%mod;
		return;
	}
	spread(p);
	if(pos<=mid)insert(p<<1,pos,val,w);
	else insert(p<<1|1,pos,val,w);
	up(p);
}
inline int query(int p,int l,int r,int op){
	if(l<=t[p].l&&t[p].r<=r){
		if(op==1)return t[p].s1;
		return t[p].s3;
	}
	spread(p);int ans=0;
	if(l<=mid)ans=query(p<<1,l,r,op);
	if(r>mid)ans=md(ans+query(p<<1|1,l,r,op));
	return ans;
}
inline void insert(int val,int w,int w2,int d,int r,int id){
	int pos = lower_bound(p+1,p+num+1,(DATA){val,d,id})-p;
	if(pos^num)change(1,pos+1,num,w2,d);
	tmp[++cnt]={val,0,w2,0,d,id};
	int ggg = d;
	if(pos>1)ggg=(ggg+mod-query(1,1,pos-1,1))%mod;
	insert(1,pos,val,ggg*1ll*r%mod);
}
inline void del(int id){
	swap(tmp[id],tmp[cnt]);
	int w = ksm(tmp[cnt].w2,mod-2);
	int pos = lower_bound(p+1,p+num+1,(DATA){tmp[cnt].val,tmp[cnt].d,tmp[cnt].id})-p;
	insert(1,pos,0,0);
	if(pos^num){
		if(w)change(1,pos+1,num,w,-1);
		else{
			for(auto[i,k]:g[tmp[cnt].d]){
				spread(i,0);
				t[i]=k;
			}
			g[tmp[cnt].d].clear();
		}
	}
	cnt--;
}
inline void dfs2(int x,int fa){
	int pos = lower_bound(p+1,p+num+1,(DATA){a[x],n+1,0})-p-1;
	if(pos>=1)ans=(ans+query(1,1,pos,2)+1ll*a[x]*(d[x]+mod-query(1,1,pos,1)))%mod;
	else ans=(ans+1ll*a[x]*d[x])%mod;
	vector<int>v;
	for(auto y : e[x])if(y!=fa)v.push_back(y);
	sort(v.begin(),v.end(),cmp);
	if(v.size())insert(a[x],inv[v.size()],0,d[x],1,v.size());
	for(int i = v.size()-1,y;i>=1;i--){
		y=v[i];
		insert(mn[y],inv[i]*1ll*inv[i+1]%mod,i*1ll*inv[i+1]%mod,d[x],inv[i+1],i);
	}
	int now = cnt;
	for(int i = 0,y;i<v.size();i++){
		y=v[i];
		dfs2(y,x);
		if(i!=v.size()-1){
			del(now--);
			insert(mn[y],inv[i+1]*1ll*inv[i+2]%mod,(i+1ll)*inv[i+2]%mod,d[x],inv[i+2],i);
		}
	}
	for(int i = 0;i<v.size();i++)del(cnt);
}
inline void predfs(int x,int fa){
	vector<int>v;
	for(auto y : e[x])if(y!=fa)v.push_back(y);
	sort(v.begin(),v.end(),cmp);
	if(v.size()){
		p[++num]=(DATA){a[x],d[x],(int)v.size()};
		for(int i = 0,y;i<v.size();i++){
			y=v[i];
			predfs(y,x);
			p[++num]=(DATA){mn[y],d[x],i};
		}
	}
}
int main(){
	T=read();
	while(T--){
		n=read(),rt=read();ans=0;
		inv[0]=inv[1]=1;
		cnt=0;num=0;
		for(int i = 2;i<=n+1;i++)inv[i]=inv[mod%i]*1ll*(mod-mod/i)%mod;
		for(int i = 1;i<=n;i++)e[i].clear(),a[i]=read();
		for(int i = 1,x,y;i<n;i++)x=read(),y=read(),e[x].push_back(y),e[y].push_back(x);
		d[rt]=1;dfs(rt,0);predfs(rt,0);
		sort(p+1,p+num+1);
		if(num)build(1,1,num);
		dfs2(rt,0);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：SegTree (赞：0)

拆贡献，考虑算 $\min=w$ 的点对个数，然后转化成 $\min\ge w$ 的点对个数。

我们将 $\min\ge w$ 的点称为 **好点**，否则称为 **坏点**。如果一颗子树内的点都是好点，则成为 **好子树**，否则称为 **坏子树**。

考虑 `dfs(x,y)` 的进程，假设现在在 $x\to y$ 的路径上点 $p$：

+ 如果随机到的儿子子树内含 $y$，合法；
+ 随机到一颗好子树，合法；
+ 随机到一颗不含 $y$ 的坏子树，不合法。

考虑不出现不合法情况的概率，注意到好子树没用，相当于在坏子树和含 $y$ 子树中随机第一个是含 $y$ 子树，换言之记坏子树个数为 $c$，则概率为 $\dfrac{1}{c+1}$。

考虑 dp，设 $dp_u$ 为 $\sum f(u,i)$，算出 $cnt_u$ 为坏子树的个数，有转移：

+ $u$ 为坏点：$dp_u=0$。
+ 子节点 $x$ 为好点：$dp_u\gets dp_u+\dfrac{dp_x}{cnt_u+1}$。
+ 子节点 $x$ 为坏点：$dp_u\gets dp_u+\dfrac{dp_x}{cnt_u}$。

则答案为 $\sum dp_i$，至此 $O(n^2)$。

考虑用 ddp 优化这个过程。注意我们还需要记 $sdp_u=\sum_{x\in subtree(u)}dp_x$。

记 $s0_u,s1_u$ 为好子节点、坏子节点（非重儿子）的 $dp$ 值之和，$sdp$ 值之和。

点的好坏、子树的好坏只会变化一次，$cnt$ 总共变化 $n$ 次，故最多做 $O(n)$ 次转移系数的修改，用全局平衡二叉树维护，时间复杂度 $O(n\log n)$，可以通过。

```cpp
#include<bits/stdc++.h>
#define up(i,l,r) for(int i=(l);i<=(r);++i)
#define down(i,l,r) for(int i=(l);i>=(r);--i)
#define pi pair<int,int>
#define p1 first
#define p2 second
#define m_p make_pair
#define p_b push_back
#define ppc __builtin_popcount
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int maxn=1e6+10,mod=998244353;
inline ll read(){
    ll x=0;short t=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*t;
}
int n,rt,alive[maxn],cnt[maxn],dp[maxn],ok[maxn],iv[maxn],root[maxn],sum[maxn];
vector<int>E[maxn];pi a[maxn];
inline int add(int a,int b){if((a+=b)>=mod)a-=mod;return a;}
int dfn[maxn],idfn[maxn],siz[maxn],son[maxn],top[maxn],fa[maxn],leaf[maxn],ct;
struct BIT {
    int t[maxn];
    int lb(int x){return x&(-x);}
    void upd(int x){for(;x<=n;x+=lb(x))t[x]++;}
    int ask(int x){int res=0;for(;x;x-=lb(x))res+=t[x];return res;}
}T;
void dfs(int u){
    siz[u]=1,son[u]=0;
    for(int x:E[u])if(x!=fa[u])fa[x]=u,dfs(x),siz[u]+=siz[x],son[u]=siz[x]>siz[son[u]]?x:son[u];
}
void dfs2(int u,int tp){
    idfn[dfn[u]=++ct]=u,top[u]=tp,leaf[tp]=ct;
    if(!son[u])return;
    dfs2(son[u],tp);for(int x:E[u])if(x!=fa[u]&&x!=son[u])dfs2(x,x);
}
struct _ {
    int k,b,sk,sb;
    _(){}
    _(int _k,int _b,int _sk,int _sb){k=_k,b=_b,sk=_sk,sb=_sb;}
}sum0[maxn],sum1[maxn];
_ operator+(_ a,_ b){
    return _(a.k*1ll*b.k%mod,add(b.k*1ll*a.b%mod,b.b),add(a.sk,b.sk*1ll*a.k%mod),add(a.sb,add(b.sk*1ll*a.b%mod,b.sb)));
}
_ add(_ a,_ b){return _(add(a.k,b.k),add(a.b,b.b),add(a.sk,b.sk),add(a.sb,b.sb));}
_ sub(_ a,_ b){return _(add(a.k,mod-b.k),add(a.b,mod-b.b),add(a.sk,mod-b.sk),add(a.sb,mod-b.sb));}
struct SegTree {
    int mid[maxn<<2],ls[maxn<<2],rs[maxn<<2],cnt;
    _ T[maxn<<2];
    void pu(int p){T[p]=T[rs[p]]+T[ls[p]];}
    void bd(int l,int r,int &p){
        p=++cnt;
        T[p]=_(0,0,0,0);
        if(l==r)return;
        mid[p]=lower_bound(sum+l,sum+r+1,(sum[r]-sum[l-1]+1)/2+sum[l-1])-sum;
        if(mid[p]==r)--mid[p];
        bd(l,mid[p],ls[p]),bd(mid[p]+1,r,rs[p]);
    }
    void modify(int l,int s,int t,int p,_ x){
        if(s==t)return T[p]=x,void();
        if(l<=mid[p])modify(l,s,mid[p],ls[p],x);else modify(l,mid[p]+1,t,rs[p],x);pu(p);
    }
}T2;
pi eval(int u){
    _ val=T2.T[root[u]];
    return {val.b,val.sb};
}
_ cal(int u){
    int K=alive[u]*1ll*iv[cnt[u]+1-(!ok[son[u]])]%mod,B=add(sum0[u].b*1ll*iv[cnt[u]]%mod,add(sum1[u].b*1ll*iv[cnt[u]+1]%mod,1))*alive[u],SK=K,SB=add(add(sum0[u].sb,sum1[u].sb),B);
    return _(K,B,SK,SB);
}
void modify(int u,_ x){T2.modify(dfn[u],dfn[top[u]],leaf[top[u]],root[top[u]],x);}
void del(int u,int o=0){
    if(o)return modify(u,cal(u)),void();
    vector<int>nd;
    while(top[u]!=rt)nd.p_b(u),u=fa[top[u]];
    reverse(nd.begin(),nd.end());
    for(int i:nd){
        int u=top[i];
        if(!fa[u])break;auto v=eval(u);
        if(ok[u])sum1[fa[u]]=sub(sum1[fa[u]],_(0,v.p1,0,v.p2));
        else sum0[fa[u]]=sub(sum0[fa[u]],_(0,v.p1,0,v.p2));
    }
}
void ins(int u,int o=0){
    if(o)return modify(u,cal(u)),void();
    while(u){
        modify(u,cal(u));u=top[u];
        if(!fa[u])break;auto v=eval(u);
        if(ok[u])sum1[fa[u]]=add(sum1[fa[u]],_(0,v.p1,0,v.p2));
        else sum0[fa[u]]=add(sum0[fa[u]],_(0,v.p1,0,v.p2));u=fa[u];
    }
}
int res[maxn];
void slv(){
    n=read(),rt=read();up(i,1,n)E[i].clear(),T.t[i]=fa[i]=0;
    iv[1]=1;up(i,2,n)iv[i]=(mod-iv[mod%i])*1ll*(mod/i)%mod;
    up(i,1,n)a[i]=m_p(read(),i);
    up(i,1,n-1){
        int x=read(),y=read();
        E[x].p_b(y),E[y].p_b(x);
    }
    up(i,1,n)cnt[i]=E[i].size()-(i!=rt);
    up(i,1,n)alive[i]=ok[i]=0,sum0[i]=sum1[i]=_(0,0,0,0);
    sort(a+1,a+n+1);T2.cnt=0;
    int ans=0;res[n+1]=0;dfs(rt);ct=0;dfs2(rt,rt);
    up(i,1,n)sum[i]=sum[i-1]+siz[idfn[i]]-siz[son[idfn[i]]];
    up(i,1,n)if(top[i]==i)T2.bd(dfn[i],leaf[i],root[i]);
    down(i,n,1){
        int p=a[i].p2;
        del(p);alive[p]=1;ins(p);
        T.upd(dfn[p]);
        while(p){
            if(T.ask(dfn[p]+siz[p]-1)-T.ask(dfn[p]-1)!=siz[p])break;
            if(top[p]==p)del(p),ok[p]=1,ins(p);
            else del(fa[p]),del(p,1),ok[p]=1,ins(p,1),ins(fa[p]);
            if(fa[p]){
                del(fa[p]);--cnt[fa[p]];ins(fa[p]);
            }
            p=fa[p];
        }
        res[i]=eval(rt).p2;
    }up(i,1,n)ans=add(ans,add(res[i],mod-res[i+1])*1ll*a[i].p1%mod);
    printf("%d\n",ans);
}
int main(){
    // freopen("1.in","r",stdin),freopen("1.out","w",stdout);
    int t=read();while(t--)slv();
    // slv();
    cerr<<clock()*1.0/CLOCKS_PER_SEC<<"s\n";
    return 0;
}
```

---

## 作者：KSCD_ (赞：0)

题解好像大部分是差分拆贡献，这是 SD 二轮省集 Harry27182 老师的做法，感觉很牛，在此记录。

注：以下用 $w(x,y)$ 代表原题中的 $f(x,y)$，$mn_u$ 表示 $u$ 子树内 $a$ 的最小值。 

显然可以先把 $a$ 离散化，之后考虑对最终答案相同的方案整体计算贡献。设 $f_{u,i}$ 表示对于所有合法的 $w(u,x)$，它们中值为 $i$ 的期望个数。转移时讨论子树内路径最小值是否仍为最小，乘上组合数转移。

具体地，对于 $u$ 的儿子 $v$，若以 $v$ 为起点时的最小值 $i$ 仍最小，需要 $u$ 其他子树中 $mn_x\le i$ 的所有 $x$ 在搜索时均排在 $v$ 之后。此处计算方案数时，可设 $u$ 共有 $S$ 个儿子，则先拿出 $mn_x\le i$ 的 $c$ 个（其中必然包含 $v$），要求 $v$ 在开头，其他随意排列，剩余的 $(S-c)$ 个也随意排列。之后将 $S$ 个位置分类并分别放入，即为合法排列数。因此概率为
$$
\frac{{S\choose c}\times (c-1)!\times (S-c)!}{S!}=\frac{S!}{c!\times (S-c)!}\times (c-1)!\times (S-c)!\times \frac 1{S!}=\frac 1 c.
$$
转移即为 $f_{u,i}\leftarrow f_{v,i}\times\frac 1 {\sum_{x\in son(u)}[mn_x\le i]}$。

另一种情况是最小值变成了另一子树 $x$ 的最小值 $mn_x$，最终结束于 $v$ 子树内的终点，这里显然有限制 $mn_x\le i$。此时先将 $u$ 的所有子树按 $mn$ 从小到大排序，设 $rk_x$ 为排序后 $x$ 的排名。则所有排在 $x$ 前面的子树中，除 $v$ 外的其他子树必须排在 $v$ 之后。

那么需要分 $v$ 在 $x$ 之前和之后讨论，以确定需要在 $v$ 之后的子树个数。这里以 $v$ 在 $x$ 之前为例，仿照上面可以把 $rk_x$ 个子树拿出来单独排列，并将 $x,v$ 分别放到前两位，概率即为
$$
\frac{{S\choose rk_x}\times (rk_x-2)!\times (S-rk_x)!}{S!}=\frac{S!}{rk_x!\times (S-rk_x)!}\times (rk_x-2)!\times (S-rk_x)!\times \frac 1{S!}=\frac 1 {rk_x(rk_x-1)}.
$$
同理可得 $v$ 在 $x$ 之后时系数为 $\frac 1{rk_x(rk_x+1)}$。转移时为降低复杂度，可以枚举 $x$，从而用前缀和优化省去对 $v,i$ 的枚举，即
$$
f_{u,mn_x}\leftarrow\frac 1 {rk_x(rk_x-1)}\sum_{rk_v<rk_x}\sum_{i\ge mn_x} f_{v,i}+\frac 1{rk_x(rk_x+1)}\sum_{rk_v>rk_x}\sum_{i\ge mn_x} f_{v,i}.
$$

这两种转移完成后，由于从 $u$ 出发必然经过 $a_u$，需要把所有 $f_{u,i}$ 的 $i$ 对 $a_u$ 取 min，即将大于 $a_u$ 的 DP 值均加到 $f_{u,a_u}$ 上并清空。最后给答案加上所有 $w(u,x)$ 的贡献，即 $\sum i\times f_{u,i}$。

另外注意到会有相等的 $a$ 值，这时钦定 $f_{v,i}$ 中的 $i$ 为等大的数中最大的，其余相等的 $mn_x$ 中 $rk$ 在前的较小，这样定义后整个 DP 过程即上述，可以实现不重不漏。目前时间复杂度为 $O(n^2)$。

考虑优化 DP 过程，注意到第一种转移是对应位置累加，且每个位置上转移系数相等，可以使用线段树合并。同时由于转移系数只与不超过 $i$ 的 $mn_x$ 个数有关，不同的区间只有 $O(deg_u)$ 个，可以用区间乘解决。

进行第二种转移时，可以开一棵临时的线段树，通过合并得到 $rk$ 数组上前后缀的线段树，再进行 $i\ge mn_x$ 的区间查询，最后进行单点加即可。注意两者的系数不同，需要分别顺序和逆序做。最后对 $a_u$ 取 min 只需区间查询，清空即为区间乘 $0$，也是区间乘。

所以需要实现线段树合并，并支持区间乘，单点加，区间求和，这些操作均不难实现，时空复杂度 $O(n\log n)$。由于有区间乘和临时的前后缀线段树，最终空间大概需要 $4$ 倍的 $n\log n$，$3\times 10^7$ 就足够了。

附上代码：

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#define pb push_back
#define mid ((l+r)>>1)
using namespace std;
const int N=4e5+10;
const int P=4e5;
const int M=3e7+10;
const int mod=998244353;
void add(int &a,int b) {a+=b;if(a>=mod)a-=mod;}
int n,m,rot,res,a[N],b[N],x[N],mn[N],rt[N],inv[N];
vector <int> e[N];
bool cmp(int i,int j) {return mn[i]<mn[j];}
struct sgmtt
{
	int t,lc[M],rc[M],w[M],k[M],tag[M];
	void cle(int u) {lc[u]=rc[u]=w[u]=k[u]=0,tag[u]=1;} 
	void pushup(int u) {w[u]=w[lc[u]],k[u]=k[lc[u]],add(w[u],w[rc[u]]),add(k[u],k[rc[u]]);}
	void pt(int u,int x) {w[u]=1ll*w[u]*x%mod,k[u]=1ll*k[u]*x%mod,tag[u]=1ll*tag[u]*x%mod;}
	void pushdown(int u) {if(tag[u]!=1) pt(lc[u],tag[u]),pt(rc[u],tag[u]),tag[u]=1;}
	void update(int u,int l,int r,int L,int R,int x)
	{
		if(!u||L>R) return;
		if(l>=L&&r<=R) {pt(u,x); return;}
		pushdown(u);
		if(L<=mid) update(lc[u],l,mid,L,R,x);
		if(R>mid) update(rc[u],mid+1,r,L,R,x);
		pushup(u);
	}
	void change(int &u,int l,int r,int p,int x)
	{
		if(!u) u=++t,cle(t);
		if(l==r) {add(k[u],x),w[u]=1ll*k[u]*b[l]%mod; return;}
		pushdown(u);
		if(p<=mid) change(lc[u],l,mid,p,x);
		else change(rc[u],mid+1,r,p,x);
		pushup(u);
	}
	int query(int u,int l,int r,int L,int R)
	{
		if(!u||L>R) return 0;
		if(l>=L&&r<=R) return k[u];
		pushdown(u); int tr=0;
		if(L<=mid) add(tr,query(lc[u],l,mid,L,R));
		if(R>mid) add(tr,query(rc[u],mid+1,r,L,R));
		return tr;
	}
	int merg(int u,int v,int l,int r)
	{
		if(!u||!v) return u+v;
		int p=++t; cle(t);
		if(l==r) w[p]=w[u],k[p]=k[u],add(w[p],w[v]),add(k[p],k[v]);
		else pushdown(u),pushdown(v),lc[p]=merg(lc[u],lc[v],l,mid),rc[p]=merg(rc[u],rc[v],mid+1,r);
		if(l<r) pushup(p);
		return p;
	}
}T;
void dfs(int u,int fat)
{
	mn[u]=a[u]; vector <int> p;
	for(int v:e[u]) if(v!=fat)
	{
		dfs(v,u),p.pb(v);
		mn[u]=min(mn[u],mn[v]);
	}
	sort(p.begin(),p.end(),cmp);
	int s=p.size(),cur=0;
	for(int i=0;i<s;i++)
	{
		x[i]=1ll*T.query(cur,1,m,mn[p[i]],m)*inv[i]%mod*inv[i+1]%mod;
		cur=T.merg(cur,rt[p[i]],1,m);
	}
	cur=0;
	for(int i=s-1;~i;i--)
	{
		add(x[i],1ll*T.query(cur,1,m,mn[p[i]],m)*inv[i+1]%mod*inv[i+2]%mod);
		cur=T.merg(cur,rt[p[i]],1,m),rt[u]=T.merg(rt[u],rt[p[i]],1,m);
	}
	for(int i=1;i<s;i++) if(mn[p[i]]!=mn[p[i-1]]) T.update(rt[u],1,m,mn[p[i-1]],mn[p[i]]-1,inv[i]);
	if(s) T.update(rt[u],1,m,mn[p[s-1]],m,inv[s]);
	for(int i=0;i<s;i++) T.change(rt[u],1,m,mn[p[i]],x[i]);
	T.change(rt[u],1,m,a[u],T.query(rt[u],1,m,a[u]+1,m)+1),T.update(rt[u],1,m,a[u]+1,m,0),add(res,T.w[rt[u]]);
}
void sol()
{
	cin>>n>>rot,res=T.t=0;
	for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i],rt[i]=0,e[i].clear();
	sort(b+1,b+1+n),m=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+1+m,a[i])-b; 
	for(int i=1,u,v;i<n;i++) cin>>u>>v,e[u].pb(v),e[v].pb(u);
	dfs(rot,0),cout<<res<<'\n';
}
int main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	inv[0]=inv[1]=1;
	for(int i=2;i<=P;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	int TT; cin>>TT;
	while(TT--) sol();
	return 0;
}
```

---


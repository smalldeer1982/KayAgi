# [北大集训 2021] 末日魔法少女计划

## 题目背景

CTT2021 D1T1

## 题目描述

对于给定的 $n,k$，你需要构造一个只含 $0,1$ 的矩阵 $A_{i,j}$，$0\le i,j\le n$，满足：

1. $A_{i,i}=1$；
2. $A_{i,i+1}=1$；
3. 对 $i>j$ 有 $A_{i,j}=0$；
4. 若 $A_{i,j}=1$，$j-i>1$，则存在 $i<t<j$，满足 $A_{i,t}=A_{t,j}=1$；
5. 对 $i\le j$ 有 $(A^k)_{i,j}>0$。

你需要输出满足 $A_{i,j}=1$ 且 $j-i>1$ 的每个 $(i,j)$，设这样的 $(i,j)$ 共有 $m$ 个。

若输出不满足要求，则不能得到该测试点的任何分数。若输出满足要求，则根据 $m$ 进行评分。


## 说明/提示

- $1900\le n\le 2000$；
- $2\le k\le 15$。

| $k$  |  $f(k)$  | $s(k)$ |
| :--: | :------: | :----: |
| $2$  | $7.9870$ |  $22$  |
| $3$  | $3.8085$ |  $14$  |
| $4$  | $2.3960$ |  $11$  |
| $5$  | $1.9610$ |  $9$   |
| $6$  | $1.6065$ |  $7$   |
| $7$  | $1.4515$ |  $6$   |
| $8$  | $1.2540$ |  $5$   |
| $9$  | $1.1980$ |  $5 $   |
| $10$ | $1.0995$ |  $4$   |
| $11$ | $1.0705$ |  $4 $   |
| $12$ | $1.0345$ |  $4$   |
| $13$ | $1.0120$ |  $3$   |
| $14$ | $1.0015$ |  $3 $   |
| $15$ | $0.9940$ |  $3$   |



每个 $2\le k\le 15$ 对应一个总分为 $s(k)$ 的子任务，每个子任务的得分是子任务中每个测试点的得分的最小值。

每个测试点的得分为所在子任务的总分的 $\max\left(0,1-\sqrt{\max\left(0,\frac{m}{n\cdot f(k)}-1\right)}\right)$ 倍。


## 样例 #1

### 输入

```
3 2```

### 输出

```
1
0 2```

# 题解

## 作者：nullqtr_pwp (赞：5)

省流：披着个构造皮子的 dp 题。

讲课讲了这题，感觉很厉害啊。

注意到 $A_{i,j}=1$ 的点对 $(i,j)$ 可以改写成一张有向图上 $i\to j$ 的边，考虑把这张图建出来。那么 $\forall i,j:(A^k)_{i,j}=1$ 的意思就是存在一条路径，使得 $i$ 到 $j$ 经过不超过 $k$ 条边。现在我们就是要构造这张有向图上的非平凡边（$i\to i+1$ 都是给出的）。

评分标准告诉我们存在一种方案，$m\leq nf(k)$。$0.9\leq f(k)\leq 8$。大概边数要做到 $O(n)$，这其实很困难，但这引导我们去往**最小化边数**去思考。


**$\bm{k=2}$ 怎么做？**

显然就是分治：对于每个 $[l,r]$，$[l,mid-1)$ 都向 $mid$ 连边，$mid$ 都向 $(mid+1,r]$ 连边。分治解决 $[l,mid),(mid,r]$ 即可。这样的边数恰好满足 $m\leq nf(2)$。

**$\bm{k=3}$ 怎么做？**

注意到 $mid$ 是个很厉害的性质，然而只找一个有点亏，依旧考虑当前区间 $[l,r]$，我们可以找两个关键点 $a,b$，使得区间被划分为 $[l,a),(a,b),(b,r]$。我们考虑 $a,b$ 都往相邻的区间中的所有点都连边，并且连接边 $a\to b$，这样可以得到比猫树分治做法更优的解。

注意到这个关键点可以选不止一个，其实可以选任意 $t$ 个，设为 $p_1,p_2,\cdots,p_t$，此时被分割成的若干段区间内部都满足相同子结构性质。也就是说，$\forall i,(p_i,p_{i+1})$ 的区间的划分是递归进行的，**相同子结构**的问题（定义 $p_0=l-1,p_{t+1}=r+1$）

注意到要保证两两能跳到，因此 $p_1,p_2,\cdots,p_t$ 这些关键点之间两两都必须有边，此时会多产生 $\dfrac{t(t-1)}{2}$ 的代价。

**$\bm{k>3}$ 怎么做？**

注意到关键点之间两两需要保证在 $k-2$ 步之内可以互相抵达，这同样可以被归类为一个长度为 $t$，$K=k-2$ 的子结构。

**算法设计**

上面一车东西都是「在 $n$ 个点的图中，$k=t$ 时最少需要添加多少条边」的子结构，直接把这个写成 dp，记为 $f_{t,n}$。

转移按照 $k$ 从小往大进行，每次枚举一个长度 $n$，然后枚举关键点个数 $t$。

考虑关键点内部怎么划分。注意到我们要求中间划分出来的段尽量均摊，调整法理解一下就会发现这是对的，但是两边与中间的贡献是不平衡的，我们只能保证两边选出来的数量尽量一致，不能去考虑与中间的一致，之前在这里卡了半天。

因此考虑一个「辅助情况」：两边都划分为 $0$ 个，直接钦定 $p_1=l,p_t=r$，中间直接被划分为 $t-1$ 段。此时可以刻画出来每一段的长度，就是直接均摊。继承子结构的贡献之后，然后加上这一层关键点对两边区间的新边，以及关键点之间的边的数量。

然后你发现，枚举两边的点的个数相等为 $h$ 时，减去两侧的点之后，就是一个规模为 $n-h$ 的「辅助情况」的解。

这样容易将一层的 dp 做到 $O(n^2)$，总共 dp 的复杂度就是 $O(n^2k)$。

构造方案？直接由最后的 dp 值倒序进行整个 dp 过程，找到每个 dp 值是从哪里来的，输出每一次产生的新的贡献的边即可。

[提交记录](https://loj.ac/s/2054352)

---

## 作者：ducati (赞：3)

花了 5~6h 才把这题弄出来。发现洛谷上竟然没有题解，于是来贡献一篇。

做法可能比较复杂。

## 初步观察

问题等价于：
- 有一条长度为 $N$ 的单向链 $1 \to 2 \to \cdots \to N$。
- 你需要连 $m$ 条额外的单向边，每条边从编号小的连向编号大的。
- 条件一：对于任意两点 $u,v(u < v)$，均能从 $u$ 出发，经过不超过 $K$ 条边到达 $v$。
- 条件二：对于所有新加入的边 $u \to v$，$\exists p \in (u, v)$，边 $u \to p, p \to v$ 存在。
- 我们需要在满足条件的前提下，让 $m$ 尽量小。

## 第一部分: $K = 2$

先考虑 $K=2$ 怎么做。

不难想到分治。设目前处理的区间为 $[l, r]$，令 $M = \lfloor \frac {l + r} {2} \rfloor$，则：
- $\forall u \in [l, M)$，连边 $u \to M$。
- $\forall v \in (M, r]$，连边 $M \to v$。

此时，$\forall u \in [l,M], \forall v \in [M, r]$，$u$ 均可经过不超过 $2$ 条边到达 $v$。那么，向 $[l, M - 1], [M + 1, r]$ 递归处理即可。

$N = 2000$ 时，按此方法新添的边数 $m$ 恰好有 $\frac m N = 7.9870$。

## 第二部分：$K = 3$

再考虑 $K = 3$ 怎么做。

依然考虑分治。一个初步的想法是，用两个关键点 $p,q$ 将当前所在区间 $[l,r]$ 划分为三个部分，连边 $p \to q$，并对于划分出的每个部分，将其中的所有点与其两侧的关键点（若存在）连边。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ucbwuaj.png)

但这样并不能通过 $K = 3$ 的测试点。

考虑扩展上述方法，设置 $c$ 个关键点 $p_1,p_2,\cdots,p_c$，$\forall 1 \le i < j \le c$，连边 $p_i \to p_j$。对于划分出的 $c + 1$ 段区间，将其中的所有点与其两侧的关键点（若存在）连边，再递归处理即可。

那么，该如何确定 $c, p_1, p_2, \cdots, p_c$ 呢？考虑 dp，令 $f_{i, c}$ 表示，看了前 $i$ 个位置，设置了 $c$ 个关键点，且 $i$ 本身为关键点的最小代价。至于如何转移，枚举最后一个关键点支配的后缀长度 $lst$ 即可。在 dp 的同时，我们也对所有 $n \in [1, N]$，枚举最后一个关键点的位置算出答案。

由于 $m$ 与 $n$ 同阶，而 $m \ge \frac {c(c-1)} {2}$，因此 $c$ 只用枚举到 $\sqrt n$ 级别。时间复杂度 $O(N^{2.5})$，可以通过 $K = 3$。

## 第三部分：$K > 3$

考虑如何扩展 $K=3$ 的做法。

由于 $K > 3$，关键点 $p_1,p_2,\cdots,p_c$ 不需两两连边了，只需保证 $\forall 1 \le i < j \le c$，$p_i$ 到 $p_j$ 的距离 $\le K -2$ 即可。预处理出 $k = 1,2$ 的所有结果，然后从小到大枚举 $k \in [3,K]$，此时 $k - 2$ 的结果已经求出，可以直接在计算答案时调用。这里注意，$p_i \to p_{i+1}(i \in [1,c))$ 的边也需要计入。

然而，$c$ 不再与 $\sqrt n$ 同阶了，时间复杂度退化至恐怖的 $O(KN^3)$。

不过好在，此时 $m$ 已经能符合所有测试点的要求了，现在关键在于，如何优化时间复杂度。

## 第四部分：复杂度优化

注意到，每个关键点支配的区间长度是**相对平均的**，我们在枚举 $lst$ 的过程中，只用枚举到 $\lfloor \frac {i} {c} \rfloor$ 左右。不过，最后一个关键点的位置可能与 $n$ 距离较大，因为这段后缀只用向一个关键点连边，因此这个距离需要枚举到 $k_0 \lfloor \frac {i} {c} \rfloor$ 左右，其中 $k_0$ 是一个大于 $1$ 的常量。

时间复杂度 $O(KN^2 \ln N)$，根据代码常数、$m$ 的大小，对 $k_0$ 进行调整，即可通过本题。实际取 $k_0 = 8$ 即可通过。

## 代码实现

实现细节极多：
- 由于空间被卡，$c$ 最大只枚举到了 $1000$。
- 构造方案时别忘了先连出一条链。
- 需要精细实现，否则易被卡常。
- $\cdots \cdots$

```cpp
#include <bits/stdc++.h>
#define eb emplace_back
using namespace std;
const int MAXN = 2005, MAXK = 16, MAXC = 1000, inf = 1e9;

int n, m, links_len[MAXK][2], con_l[MAXK][MAXN]; bitset<MAXN> GA[MAXN];
struct info_t{
	int num, bel_c, bel_lst;
	info_t() {num = bel_c = bel_lst = 0;}
	info_t(int v, int x, int y) {num = v, bel_c = x, bel_lst = y;}
	bool operator < (const info_t &A) const {return num < A.num;}
}f[MAXK][MAXN], dp[MAXK][MAXN][MAXC];
template<typename T> void chkmin(T x, T &y) {if(x < y)y = x;}

int main() {
	cin >> n >> m, n++;
	for (int i = 1; i < n; i++)  GA[i].set(i + 1);
	for (int sz = 1; sz <= n; sz++)  f[1][sz].num = ((sz * (sz - 1)) >> 1) - (sz - 1);
	for (int sz = 1; sz <= n; sz++) {
		function<void(int, int)> calc_two = [&](int l, int r) {
			if (r - l < 3)  return;

			int mid = (l + r) >> 1;
			for (int i = l; i + 1 < mid; i++)  f[2][sz].num++;
			for (int i = mid + 2; i <= r; i++)  f[2][sz].num++;
			calc_two(l, mid - 1), calc_two(mid + 1, r);
		};
		calc_two(1, sz);
	}
	for (int k = 3; k <= m; k++)  links_len[k][0] = k - 2, links_len[k][1] = 2;
	for (int k = 1; k <= m; k++) {
		for (int j = k + 1; j <= n; j += k)  con_l[k][j]++;
		for (int j = 1; j <= n; j++)  con_l[k][j] += con_l[k][j - 1];
	}
	for (int k = 3; k <= m; k++) {
		int lk0 = links_len[k][0], lk1 = (links_len[k][1] >> 1);
		for (int c = 1; c < MAXC; c++)  dp[k][0][c].num = inf;
		for (int i = 1; i <= n; i++)  dp[k][i][0].num = inf;
		for (int i = 1; i <= n; i++) {
			if (i > k + 1) {
				f[k][i].num = inf;
				for (int c = 1; c < MAXC; c++) {
					int max_lst = min(i, (i / c) << 3);
					for (int lst = 1; lst <= max_lst; lst++) {
						chkmin(info_t(dp[k][i - lst][c].num + f[lk0][c].num
														 + con_l[lk1][lst]
														 + f[k][lst].num, c, lst), f[k][i]);
					}
				}
			}
			for (int c = 1, max_lst; c < MAXC; c++) {
				dp[k][i][c].num = inf, max_lst = min(i, (i / c));
				for (int lst = 1; lst <= max_lst; lst++) {
					chkmin(info_t(dp[k][i - lst][c - 1].num + ((c ^ 1) ? (con_l[lk1][lst - 1] << 1) : con_l[lk1][lst - 1])
													 		+ f[k][lst - 1].num + (c > 1 && lst > 1), c, lst), dp[k][i][c]);
				}
			}
		}
	}
	auto Add = [&](int u, int v) {GA[u].set(v);};
	auto Counting_edges = [&]() {
		int tot = 0;
		for (int i = 1; i < n; i++)  tot += GA[i].count() - 1;
		return tot;
	};
	function<void(vector<int> &, int)> Construct = [&](vector<int> &nds, int k) {
		int n = nds.size();
		for (int i = 1; i < n; i++)  GA[nds[i - 1]].set(nds[i]);
		if (n > k + 1) {
			if (k == 1) {
				for (int x : nds) {
					for (int y : nds) {
						if (x < y)  Add(x, y);
					}
				}
			}
			else if (k == 2) {
				function<void(int, int)> Construct_two = [&](int l, int r) {
					if (r - l < 3)  return;

					int mid = (l + r) >> 1;
					for (int i = l; i + 1 < mid; i++)  Add(nds[i], nds[mid]);
					for (int i = mid + 2; i <= r; i++)  Add(nds[mid], nds[i]);
					Construct_two(l, mid - 1), Construct_two(mid + 1, r);
				};
				Construct_two(0, n - 1);
			}
			else {
				vector<int> kp, lens; lens.eb(f[k][n].bel_lst);
				for (int x = n - f[k][n].bel_lst, c = f[k][n].bel_c; c;
																	 x -= dp[k][x][c].bel_lst, c--)  lens.eb(dp[k][x][c].bel_lst);
				reverse(lens.begin(), lens.end());

				int ed = lens.size() - 1, lk1 = (links_len[k][1] >> 1);
				for (int i = 0, sum = 0; i <= ed; i++) {
					int l = sum, r = sum + lens[i] - 1; sum += lens[i];
					if (i) {
						int maxj = ((i ^ ed) ? (r - 1) : r);
						for (int j = l + lk1; j <= maxj; j += lk1)  Add(nds[l - 1], nds[j]);
					}
					if (i ^ ed) {
						for (int j = r - lk1 - 1; j >= l; j -= lk1)  Add(nds[j], nds[r]);
					}
					vector<int> vec;
					for (int j = l; j < r; j++)  vec.eb(nds[j]);
					if (i ^ ed)  kp.eb(nds[r]);
					else vec.eb(nds[r]);
					Construct(vec, k);
				}
				Construct(kp, links_len[k][0]);
			}
		}
	};
	vector<int> all_pos;
	for (int i = 1; i <= n; i++)  all_pos.eb(i);
	Construct(all_pos, m), printf("%d\n", Counting_edges());
	for (int i = 1; i <= n; i++) {
		for (int j = i + 2; j <= n; j++) {
			if (GA[i][j])  printf("%d %d\n", i - 1, j - 1);
		}
	}
	return 0;
}
```


---

## 作者：anotherobject (赞：2)

题意很清楚！需要注意的一点就是 $A^k$ 的含义是矩阵 $A$ 的 $k$ 次幂。orz 神题，乍一看是线性代数，结果推一推发现是图论，最后变成了数据结构，用动态规划解决。（雾）

## 题解
看到 0/1 矩阵，还有幂次的操作，而且初始的时候 $A_{i,i}=1$，就很像邻接矩阵，尝试把 $A$ 当成邻接矩阵看待。则要求构造图满足 $i,i+1$ 间有有向边，每条边从小指向大，且对于任何一条有向边 $(i,j)(j\gt i+1)$ 满足 $\exist t\in (i,j)$，存在 $(i,t)$ 和 $(t,j)$。现在要边数最小！

先从 $k=2$ 的情况入手，尝试分治，则选取 $M$，把 $[L,M)$ 向 $M$ 连边，$M$ 向 $(M,R]$ 连边，剩下两边递归下去即可！复杂度 $O(n\log n)$，因为最底层那个 $i\to i+1$ 的链不算，所以正好卡入了限制内。

上述做法非常像一种数据结构：猫树（或者更广为人知的名字叫猫树分治或者分治树之类的？反正就是那个 $O(1)$ 查离线线段树）。

转化题意，发现本质上就是要求维护序列，静态，要求 $O(k)$ 查询，限制不能超过 $O(nm)$ 次预处理合并区间的机会。

猫树对于所有的区间都只需要两次询问，太浪费。拿出另一个算法：sqrt-tree。

先简要介绍一下这个算法吧，其实就是分块 + 维护整块与整块之间 $O(\frac{n^2}{B^2})$ 种不同区间的信息 + 块内维护前缀信息和后缀信息 + 块内嵌套一个一模一样的数据结构。如果查询跨块就可以用 $3$ 次操作查出来（散块前缀 + 整块 + 散块后缀），如果在一个块内就递归进块内的子结构。

然而要是把这个板子打上去加边次数就多到飞起了（因为这个算法不也是最多用三次操作吗还是浪费的过分）。

所以要尝试优化，发现其实并不需要存所有 $O(\frac{n^2}{B^2})$ 种不同信息是不是？只要能在 $k-2$ 次操作内查出任意一个区间就可以了。而且最左边和最右边的块只需要分别维护后缀和和前缀和就可以了。

然后就可以动态规划了！具体地设：

- $f_{n,k}$ 为 $n$ 个元素作为一整块至多用 $k$ 次合并所需的最少加边数量。
- $g_{n,k}$ 为 $n$ 个元素拼成若干块满足条件（即支持前缀后缀查，$k-2$ 次操作查出来任意区间）的最少加边数量。
- $p_{n,k}$ 为 $n$ 个元素作为一整块，至多用 $k$ 次合并，且要支持**前缀** $O(1)$ 查出来所需的最少加边数量（其实如果是后缀也一样，就不单独列一个数组了）。
- $q_{n,k}$ 为 $n$ 个元素作为一整块，至多用 $k$ 次合并，且要支持**前后缀** $O(1)$ 查出来所需的最少加边数量。
  
然后有了：$p_{n,k}=n-1+f_{n-1,k},q_{n,k}=2n-3+f_{n-2,k}$（对于 $p$，区间所有元素连向开头即可查出所有前缀，连边 $n-1$ 次，除了开头其他的元素又要满足 $k$ 次合并所以再加上 $f_{n-1,k}$；对于 $q$，区间所有元素连向开头和结尾，同时开头连结尾，剩下的加上 $f_{n-2,k}$）。

$g$ 的转移如下：

$$g_{n,k}=\min_i(f_{i,k-2}+q_{\left\lfloor\frac{n}{i}\right\rfloor,k}(i-n\bmod i)+q_{\left\lfloor\frac{n}{i}\right\rfloor+1,k}(n\bmod i))$$

具体什么意思？枚举 $i$ 作为块数量，然后 $f_{i,k-2}$ 为让这些块互相连结（因为块内的元素互连还要走出来，走到另一个块内，多走两步，所以 $k$ 减去 $2$），然后中间的块要尽可能大小均分。

$f$ 的转移如下：

$$f_{n,k}=\min_i(g_{n-2i,k}+2p_{i,k})$$

具体什么意思？枚举 $i$ 作为边缘两个块的大小，然后把这若干个块拼成一个大块（为什么要枚举边缘两个块大小？因为他们并不用同时维护前缀和后缀，理应大小大一些，分摊压力，所以要单独算）。

在动态规划的时候记录转移点，就可以直接构造方案了，具体见代码吧。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e3+10,inf=1e9;
int f[N][20],ff[N][20],g[N][20],gf[N][20];

int tool(int n,int k,int op){
	if(n<=1) return 0;
	if(op==1) return n-1+f[n-1][k];
	if(op==3) return n*2-3+f[n-2][k];
	return f[n][k];
}

struct interval{int l,r;friend bool operator <(interval a,interval b){if(a.l==b.l) return a.r<b.r;return a.l<b.l;}};
vector<interval>E;
void adde(interval u,interval v){E.push_back({u.l,v.r});}

void dfs(vector<interval> vec,int k,int op){
	int n=vec.size();
	if(n<=1) return;
	if(op==1){//只连前缀 
		for(int i=1;i<n;i++) adde(vec[0],vec[i]);
		return dfs({vec.begin()+1,vec.begin()+n},k,0);
	}else if(op==2){//只连后缀 
		for(int i=0;i<n-1;i++) adde(vec[i],vec[n-1]);
		return dfs({vec.begin(),vec.begin()+n-1},k,0);
	}else if(op==3){//连前后缀 
		for(int i=1;i<n-1;i++){adde(vec[0],vec[i]);adde(vec[i],vec[n-1]);}
		adde(vec[0],vec[n-1]);return dfs({vec.begin()+1,vec.begin()+n-1},k,0);
	}
	if(n<=k) return;
	else if(k==1){for(int i=0;i<n;i++){for(int j=i+1;j<n;j++){adde(vec[i],vec[j]);}}//k=1没办法了，连成完全图吧 
	}else if(k==2){dfs({vec.begin(),vec.begin()+n/2},k,2);dfs({vec.begin()+n/2,vec.begin()+n},k,1);}else{//k=2的时候猫树 
		int pos=ff[n][k];
		dfs({vec.begin(),vec.begin()+pos},k,2);//先把两侧的块单独连了，这俩长度和中间的不一样 
		dfs({vec.begin()+n-pos,vec.begin()+n},k,1);
		vector<interval>tmp;int len=gf[n-pos*2][k];int tme=(n-pos*2)/len;int r=(n-pos*2)%len;
		int j=pos;//开始连中间的那些块 
		for(int i=0;i<len-r;i++){dfs({vec.begin()+j,vec.begin()+j+tme},k,3);tmp.push_back({vec[j].l,vec[j+tme-1].r}); j+=tme;}
		for(int i=0;i<r;i++){dfs({vec.begin()+j,vec.begin()+j+tme+1},k,3);tmp.push_back({vec[j].l,vec[j+tme].r}); j+=tme+1;}
		dfs(tmp,k-2,0);//连结块与块 
	}
}

signed main(){//先预处理f和g以及他们的转移位置，这部分就是抄式子就可以了（才不会告诉你我这里调了一晚上） 
	for(int i=1;i<=15;i++){for(int j=2;j<=2000;j++){g[j][i]=1e9;
		for(int k=1;k<=j;k++){
			int len=j/k;int r=j%k;
			int tmp=tool(k,i-2,0)+tool(len,i,3)*(k-r)+tool(len+1,i,3)*r;
			if(tmp<g[j][i]){g[j][i]=tmp;gf[j][i]=k;
		}}
		if(j<=i) f[j][i]=0;else if(i==1) f[j][i]=j*(j-1)/2;
		else if(i==2) f[j][i]=tool(j/2,i,1)+tool(j-j/2,i,1);
		else{f[j][i]=1e9;for(int k=1;k<=j/2;k++){
			int tmp=g[j-k*2][i]+tool(k,i,1)*2;
			if(tmp<f[j][i]){f[j][i]=tmp;ff[j][i]=k;}
		}}	
	}}
	vector<interval>vec;
	int n,k; cin>>n>>k;for(int i=0;i<n;i++) vec.push_back({i,i+1});//dfs构造方案，这个vec存了当前每个元素对应哪个区间（这里的元素称作子树或许更好？毕竟sqrt-tree 是一棵树） 
	dfs(vec,k,0); cout<<E.size()<<"\n"; sort(E.begin(),E.end());
	for(auto i:E) cout<<i.l<<" "<<i.r<<"\n";
}

```

---

## 作者：DaiRuiChen007 (赞：2)

# P8984 题解

[Problem Link](https://www.luogu.com.cn/problem/P8984)

**题目大意**

> 给定 $n,k$，构造一个 $0,1$ 矩阵 $A$ 使得：
>
> - $A_{i,i}=A_{i,i+1}=1$。
> - 对于所有 $j<i$，$A_{i,j}=0$。
> - 对于所有 $A_{i,j}=1$，存在 $x$ 使得 $A_{i,x}=A_{x,j}=1$。
> - 对于所有 $i\le j$，$A^k_{i,j}=1$。
>
> 对于每个 $k$，你需要保证 $j-i>1$ 且 $A_{i,j}=1$ 的 $(i,j)$ 不超过 $Q_k\times n$，其中 $Q_k$ 是给定的系数。
>
> 数据范围：$k\le 15,n\le 2000$。

**思路分析**

考虑把所有 $[i,i+1)$ 看成半群信息，那么我们就是要进行不超过 $Q_k\times n$ 次合并运算以预处理，然后以不超过 $k$ 次合并回答任意区间半群信息查询。

显然 $k=2$ 的时候是猫树，直接分治两边即可。

对于更一般的情况，考虑 Sqrt-Tree，维护一棵 $b+2$ 叉树，要求：

- 每个子树都要求 $k$ 次合并内解决内部问题。
- 中间 $b$ 个子树可以 $1$ 次合并回答任意前缀后缀。
- 左右两个子树可以 $1$ 次合并回答任意前缀或者后缀。
- 中间 $b$ 个子树可以 $k-2$ 次合并回答任意整块之间的区间问题。

对于最优的 Sqrt-Tree 形态，根据对称性，显然两侧的块大小一致，而中间的块大小也尽量平均，可以考虑 dp，设：

- $f_{n,k}$ 表示 $n$ 个半群元素要求 $k$ 次合并内回答询问的最小代价。
- $g_{n,k}$ 表示 $n$ 个半群元素作为某个区间的内部 $b$ 个子树，满足条件的最小代价。
- $p_{n,k}$ 表示 $n$ 个半群元素支持 $k$ 次合并内回答询问，并且可以 $1$ 次操作询问回答任意前缀或后缀。
- $q_{n,k}$ 表示 $n$ 个半群元素支持 $k$ 次合并内回答询问，并且可以 $1$ 次操作询问回答任意前缀和后缀。

显然有 $p_{n,k}=(n-1)+f_{n-1,k}$，$q_{n,k}=(2n-3)+f_{n-2,k}$，暴力连前后缀即可。

不难得到如下转移：
$$
\begin{aligned}
g_{n,k}&=\min_{b}\{f_{k-2,b}+q_{k,\lfloor n/b\rfloor}\times (b-n\bmod b)+q_{k,\lfloor n/b\rfloor +1}\times (n\bmod b)\}\\
f_{n,k}&=\min_{i}\{g_{n-2i,k}+2p_{i,k}\}
\end{aligned}
$$
预处理出转移点后暴力递归求解。

时间复杂度 $\mathcal O(n^2k)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
int f[16][2005],g[16][2005],fx[16][2005],gx[16][2005];
int eval(int k,int n,int o) {
    //o=1:pre, o=2:suf, o=3:pre&suf
    if(n<=1) return 0;
    if(o==1) return n-1+f[k][n-1];
    if(o==2) return n-1+f[k][n-1];
    if(o==3) return 2*n-3+f[k][n-2];
    return f[k][n];
}
struct info { int l,r; };
vector <info> e;
void link(info u,info v) { e.push_back({u.l,v.r}); }
void sol(vector<info>q,int k,int o) {
    #define sc(x,y) {q.begin()+x,q.begin()+y}
    int n=q.size();
    if(n<=1) return ;
    if(o==1) {
        for(int i=1;i<n;++i) link(q[0],q[i]);
        return sol(sc(1,n),k,0);
    }
    if(o==2) {
        for(int i=0;i<n-1;++i) link(q[i],q[n-1]);
        return sol(sc(0,n-1),k,0);
    }
    if(o==3) {
        for(int i=1;i<n-1;++i) link(q[0],q[i]),link(q[i],q[n-1]);
        return link(q[0],q[n-1]),sol(sc(1,n-1),k,0);
    }
    if(n<=k) return ;
    else if(k==1) for(int i=0;i<n;++i) for(int j=i+1;j<n;++j) link(q[i],q[j]);
    else if(k==2) sol(sc(0,n/2),k,2),sol(sc(n/2,n),k,1);
    else {
        int wd=fx[k][n];
        sol(sc(0,wd),k,2),sol(sc(n-wd,n),k,1);
        vector<info> s;
        int b=gx[k][n-2*wd],d=(n-2*wd)/b,r=(n-2*wd)%b,it=wd;
        for(int i=0;i<b-r;++i) sol(sc(it,it+d),k,3),s.push_back({q[it].l,q[it+d-1].r}),it+=d;
        for(int i=0;i<r;++i) sol(sc(it,it+d+1),k,3),s.push_back({q[it].l,q[it+d].r}),it+=d+1;
        sol(s,k-2,0);
    }
}
signed main() {
    for(int k=1;k<=15;++k) for(int n=2;n<=2000;++n) {
        g[k][n]=inf;
        for(int b=1;b<=n;++b) {
            int d=n/b,r=n%b,tmp=eval(k-2,b,0)+eval(k,d,3)*(b-r)+eval(k,d+1,3)*r;
            if(tmp<g[k][n]) g[k][n]=tmp,gx[k][n]=b;
        }
        if(n<=k) f[k][n]=0;
        else if(k==1) f[k][n]=n*(n-1)/2;
        else if(k==2) f[k][n]=eval(k,n/2,2)+eval(k,n-n/2,1);
        else {
            f[k][n]=inf;
            for(int i=1;i<=n/2;++i) {
                int tmp=g[k][n-2*i]+eval(k,i,2)+eval(k,i,1);
                if(tmp<f[k][n]) f[k][n]=tmp,fx[k][n]=i;
            }
        }
    }
    int N,K;
    scanf("%d%d",&N,&K);
    vector <info> I;
    for(int i=0;i<N;++i) I.push_back({i,i+1});
    sol(I,K,0);
    printf("%d\n",(int)e.size());
    for(auto x:e) printf("%d %d\n",x.l,x.r);
    return 0;
}
```

---

## 作者：rubbishZZZ (赞：1)

## P8984 [北大集训 2021] 末日魔法少女计划



### 题意：

- 对于给定的 $n,k$，你需要构造一个只含 $0,1$ 的矩阵 $a_{i,j}$，$0\leq i,j\leq n$，满足：

  1. $a_{i,i}=1$。
  2. $a_{i,i+1}=1$。
  3. 对 $i\gt j$ 有 $a_{i,j}=0$。
  4. 若 $a_{i,j}=1,j-i\gt 1$，则存在 $i\lt t\lt j$，满足 $a_{i,t}=a_{t,j}=1$。
  5. 对 $i\leq j$ 有 $(a^k)_{i,j}\gt 0$。

  请构造方案，对 $a_{i,j}=1,j-i\gt 1$ 的个数有限制，尽可能少的选。



### 解法：

- 这个问题要找到一个好的方式去刻画。

  题目中的一些要求能给我们一些提示：$a_{i,i}=1$，$\forall i\gt j,a_{i,j}=0$ 以及 $a_{i,t}=a_{t,j}=1$，都提示我们往连通性的方向思考。

  我们将 $a_{i,j}=1$ 的 $i$ 向 $j$ 连一条边，则原问题是：有一个 $n$ 个点的图，连的边都是从小往大连。初始时 $i$ 向 $i+1$ 连一条边，如果 $i$ 向 $i+1\lt j$ 连一条边则一定有中转点 $k$ 使得 $i,j$ 都和 $k$ 有连边。$(a^k)_{i,j}\gt 0$ 就表示对于任何两个点都可以经过不超过 $k$ 步到达。

  从 $k$ 较小的方向思考。$k=1$ 一定是完全图，$k=2$ 的时候，我们取 $mid$，将 $1\sim mid-1$ 向 $mid$ 连边，$mid$ 向 $mid+1\sim n$，$[1,mid),(mid,n]$ 内部连成完全图。测一下就可以发现刚好达到限制。

  对于 $k$ 更大的呢？我们可以效仿 $k=2$ 的思路，选出 $k-2$ 个中转点 $p_1,p_2,\dots,p_{k-2}$，中转点之间连边，$[p_i,p_{i+1}]$ 连前后缀（这里设 $p_0=0,p_{k-1}=n$）。

  这样并不能通过，选 $k-2$ 个中转点答案是 $\dfrac{n^2}{k}$ 级别的。

  那我们能不能多选一些中转点？此时中转点之间就构成了一个子问题，对于选出的 $x$ 个中转点，在 $k-2$ 步之内需要相互到达。

  我们做一个 DP，设 $f_{i,j}$ 表示 $i$ 个点 $j$ 步之内到达的最小边数。

  我们选出的中转点一定是尽可能平均的。特别的，头尾只需要连前缀或者连后缀，因此头尾可能稍长一些。

  因此我们可以枚举选出的中转点个数，以及前后缀长度，这样复杂度是 $O(n^3k)$ 的。

  这是好优化的，我们设 $g_{i,j}$ 表示不考虑头尾 $j$ 步内最小边数，则求解 $f$ 只需要枚举两头的长度即可，复杂度是 $O(n^2k)$ 的。

  在 DP 中记录转移点即可还原方案。



### 代码：

```cpp
#include<bits/stdc++.h>
//#include<ext/pb_ds/assoc_container.hpp>
#define pii pair<int,int>
#define fi first
#define se second
#define MP make_pair
//#define int long long
#define rep(i,j,k) for(int i=j;i<=(int)k;i++)
#define per(i,j,k) for(int i=j;i>=(int)k;i--)
#define SZ(v) (int)v.size()
#define ALL(v) v.begin(),v.end()
#define eb emplace_back
#define ep emplace
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
//typedef __int128 lll;
//typedef unsigned __int128 ulll;
using namespace std;
//using namespace __gnu_pbds;
bool Mbe;

//char buf[1<<20],*p1,*p2;
//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1<<20,stdin), p1 == p2) ? 0 : *p1++)
int read(){
	int s=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')f^=(c=='-'),c=getchar();
	while(c>='0'&&c<='9')s=s*10+c-'0',c=getchar();
	return f?s:-s;
}
template<typename T>void chkmin(T&x,T y){if(y<x)x=y;}
template<typename T>void chkmax(T&x,T y){if(y>x)x=y;}
//int fplus(int x,int y){return x+y>=mod?x+y-mod:x+y;}
//void Fplus(int&x,int y){x=fplus(x,y);}
//int fminus(int x,int y){return x-y<0?x+mod-y:x-y;}
//void Fminus(int&x,int y){x=fminus(x,y);}

const int N=2005,M=16,inf=0x3f3f3f3f;
int f[N][16],g[N][16],p[N][16],q[N][16],ff[N][16],gg[N][16];
void upd(int o,int i,int j,int val,int pos){
	if(!o&&g[i][j]>val)g[i][j]=val,gg[i][j]=pos;
	if(o&&f[i][j]>val)f[i][j]=val,ff[i][j]=pos;
}
vector<pii>ans;
void add(pii x,pii y){ans.eb(x.fi,y.se);}
void dfs(vector<pii>vec,int k,int op){
	#define sub(x,y) {vec.begin()+x,vec.begin()+y}
	int n=SZ(vec);
	if(n<=1)return;
	if(op==1){
		rep(i,1,n-1)add(vec[0],vec[i]);
		dfs(sub(1,n),k,0);
	}else if(op==2){
		rep(i,0,n-2)add(vec[i],vec[n-1]);
		dfs(sub(0,n-1),k,0);
	}else if(op==3){
		rep(i,1,n-2)add(vec[0],vec[i]),add(vec[i],vec[n-1]);
		add(vec[0],vec[n-1]);
		dfs(sub(1,n-1),k,0);
	}else if(n<=k)return;
	else if(k==1){
		rep(i,0,n-1)rep(j,i+1,n-1)add(vec[i],vec[j]);
	}else if(k==2){
		dfs(sub(0,n/2),k,2),dfs(sub(n/2,n),k,1);
	}else{
		int pos=ff[n][k];
		dfs(sub(0,pos),k,2);
		dfs(sub(n-pos,n),k,1);
		vector<pii>tmp;
		int len=gg[n-pos*2][k],cnt=(n-pos*2)/len,r=(n-pos*2)%len;
		int cur=pos;
		rep(i,1,len-r){
			dfs(sub(cur,cur+cnt),k,3);
			tmp.eb(vec[cur].fi,vec[cur+cnt-1].se);
			cur+=cnt;
		}
		rep(i,1,r){
			dfs(sub(cur,cur+cnt+1),k,3);
			tmp.eb(vec[cur].fi,vec[cur+cnt].se);
			cur+=cnt+1;
		}
		dfs(tmp,k-2,0);
	}
}

bool Med;
signed main(){
	fprintf(stderr,"%.3lfMb\n",(&Mbe-&Med)/1024./1024.);
	rep(j,1,15)rep(i,2,2000){
		f[i][j]=g[i][j]=inf,p[i][j]=f[i-1][j]+i-1,q[i][j]=f[i-2][j]+i+i-3;
		rep(k,1,i){
			int len=i/k,r=i%k;
			upd(0,i,j,f[k][j-2]+q[len][j]*(k-r)+q[len+1][j]*r,k);
		}
		if(i<=j)f[i][j]=0;
		else if(j==1)f[i][j]=i*(i-1)/2;
		else if(j==2)f[i][j]=p[i/2][j]+p[i-i/2][j];
		else rep(k,1,i/2)upd(1,i,j,g[i-k-k][j]+p[k][j]*2,k);
	}
	vector<pii>vec;
	int n=read(),K=read();
	rep(i,0,n-1)vec.eb(i,i+1);
	dfs(vec,K,0);
	printf("%d\n",SZ(ans));
	sort(ALL(ans));
	for(pii p:ans)printf("%d %d\n",p.fi,p.se);
	return 0;
}
```

---

## 作者：EuphoricStar (赞：1)

可以将题意转化成：有一个有向图，初始只有边 $i \to i + 1$。需要添加 $m$ 条 $u < v$ 的有向边 $u \to v$，使得任意两点都可以在 $k$ 步内到达，且对于每条边 $u \to v$ 满足 $u + 1 < v$，都存在 $w \in (u, v)$ 使得存在边 $u \to w$ 和 $w \to v$。

先考虑 $k = 2$ 怎么做。考虑类似猫树的思路去分治。分治到区间 $[l, r]$ 时，设 $mid = \left\lfloor\frac{l + r}{2}\right\rfloor$。连边 $\forall i \in [l, mid - 2], i \to mid$ 和 $\forall i \in [mid + 2, r], mid \to i$。这样可以保证 $[l, mid]$ 中的点至多花两步到达 $[mid, r]$ 中的点。当 $n = 2000$ 时得到 $m$ 恰好等于 $n f(2) = 15974$。

考虑 $k \ge 3$。拓展 $k = 2$ 的思路，设置若干个关键点 $p_1, p_2, \ldots, p_c$。对于每个段 $(p_i, p_{i + 1})$ 的所有点，向 $p_i$ 和 $p_{i + 1}$ 连边。对于两端的所有点 $[1, p_1)$ 和 $(p_c, n]$ 也分别向 $p_1$ 和 $p_c$ 连边。这样若 $p_1, p_2, \ldots, p_c$ 两两都可以在 $k - 2$ 步内到达，那么我们就满足了跨过至少一个关键点的点对的条件。可以发现 $[1, p_1), (p_i, p_{i + 1}), (p_c, n]$ 是 $k' = k$ 的子问题，$[p_1, p_2, \ldots, p_c]$ 是 $k' = k - 2$ 的子问题。

题目给出的 $f(k)$ 没什么规律，所以题目可能是想让我们求出 $m$ 的最优解（或者一个很优的解）。观察到子问题的结构后可以设计 DP。设 $f_{k, n}$ 为要求 $n$ 个点要在 $k$ 步内互相到达，且已经连了所有 $i \to i + 1$ 的边，还要连的边数量的最小值。

处理 $k \le 2$ 的边界。至于转移，发现令关键点之间的间隔 $p_{i + 1} - p_i$ 全部相等看起来很优。所以我们枚举关键点的个数和间隔，那么关键点到两侧的距离 $p_1 - 1$ 和 $n - p_c$ 显然均分比较优。仔细地列出连边数量的式子后就可以转移，不要忽略常数。这部分时间复杂度是 $O(kn^2 \log n)$。构造方案就直接倒推，模拟一遍递归即可。

于是你按照上述思路写了一发，[获得了 99.899979 分](https://qoj.ac/submission/983532)。怎么回事呢？关键点的间隔全部相等并不是最优的。于是当 $n \le 100$ 时换一种转移方式：枚举 $p_c - p_1$ 和关键点的个数，关键点之间的距离尽量均分，就能过了。

```cpp
#include <bits/stdc++.h>
#define fst first
#define scd second
#define pb emplace_back
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef pair<int, int> pii;

const int maxn = 2020;

int n, m, f[16][maxn], tot;
pii ans[99999];

struct node {
	int len, cnt, l, r;
	node(int a = 0, int b = 0, int c = 0, int d = 0) : len(a), cnt(b), l(c), r(d) {}
} g[16][maxn];

void dfs(int k, vector<int> vc) {
	int n = (int)vc.size();
	if (n <= k + 1) {
		return;
	}
	if (k == 1) {
		for (int i = 0; i < n; ++i) {
			for (int j = i + 2; j < n; ++j) {
				ans[++tot] = mkp(vc[i], vc[j]);
			}
		}
		return;
	}
	if (k == 2) {
		int mid = (n - 1) / 2;
		for (int i = 0; i <= mid - 2; ++i) {
			ans[++tot] = mkp(vc[i], vc[mid]);
		}
		for (int i = mid + 2; i < n; ++i) {
			ans[++tot] = mkp(vc[mid], vc[i]);
		}
		vector<int> nv;
		for (int i = 0; i < mid; ++i) {
			nv.pb(vc[i]);
		}
		dfs(k, nv);
		vector<int>().swap(nv);
		for (int i = mid + 1; i < n; ++i) {
			nv.pb(vc[i]);
		}
		dfs(k, nv);
		return;
	}
	int len = g[k][n].len, cnt = g[k][n].cnt, l = g[k][n].l, r = g[k][n].r;
	for (int i = 0; i <= l - 2; ++i) {
		ans[++tot] = mkp(vc[i], vc[l]);
	}
	for (int i = n - r + 1; i < n; ++i) {
		ans[++tot] = mkp(vc[n - r - 1], vc[i]);
	}
	vector<int> key;
	for (int i = l, c = 0; i < n - r - 1; ++c) {
		int x = (c < cnt ? len + 1 : len);
		key.pb(vc[i]);
		for (int j = i + 2; j < i + x; ++j) {
			ans[++tot] = mkp(vc[i], vc[j]);
		}
		for (int j = i + 1; j <= i + x - 2; ++j) {
			ans[++tot] = mkp(vc[j], vc[i + x]);
		}
		vector<int> nv;
		for (int j = i + 1; j < i + x; ++j) {
			nv.pb(vc[j]);
		}
		dfs(k, nv);
		ans[++tot] = mkp(vc[i], vc[i + x]);
		i += x;
	}
	key.pb(vc[n - r - 1]);
	vector<int> nv;
	for (int i = 0; i < l; ++i) {
		nv.pb(vc[i]);
	}
	dfs(k, nv);
	vector<int>().swap(nv);
	for (int i = n - r; i < n; ++i) {
		nv.pb(vc[i]);
	}
	dfs(k, nv);
	dfs(k - 2, key);
}

void solve() {
	scanf("%d%d", &n, &m);
	++n;
	mems(f, 0x3f);
	f[1][0] = f[1][1] = f[2][0] = f[2][1] = f[2][2] = f[2][3] = 0;
	for (int i = 2; i <= n; ++i) {
		f[1][i] = i * (i - 1) / 2 - (i - 1);
	}
	for (int i = 4; i <= n; ++i) {
		int j = (i + 1) / 2;
		f[2][i] = f[2][j - 1] + f[2][i - j] + i - 3;
	}
	for (int k = 3; k <= m; ++k) {
		for (int i = 0; i <= n; ++i) {
			if (i <= k + 1) {
				f[k][i] = 0;
				continue;
			}
			if (i <= 100) {
				for (int j = 1; j <= i; ++j) {
					for (int p = 2; p <= j; ++p) {
						int l = (i - j) / 2, r = (i - j + 1) / 2, len = (j - 1) / (p - 1);
						int x = max(l - 1, 0) + max(r - 1, 0) + (max(len - 1, 0) * 2 + f[k][len]) * ((j - 1) % (p - 1)) + (max(len - 2, 0) * 2 + f[k][len - 1]) * (p - 1 - (j - 1) % (p - 1)) + p - 1 + f[k - 2][p] + f[k][l] + f[k][r];
						if (x < f[k][i]) {
							f[k][i] = x;
							g[k][i] = node(len, (j - 1) % (p - 1), l, r);
						}
					}
				}
			} else {
				for (int j = 1; j <= i; ++j) {
					for (int p = 1; j * p + 1 <= i; ++p) {
						int l = (i - j * p - 1) / 2, r = (i - j * p) / 2;
						int x = max(l - 1, 0) + max(r - 1, 0) + max(j - 2, 0) * 2 * p + f[k][j - 1] * p + p + f[k - 2][p + 1] + f[k][l] + f[k][r];
						if (x < f[k][i]) {
							f[k][i] = x;
							g[k][i] = node(j, 0, l, r);
						}
					}
				}
			}
		}
	}
	vector<int> vc;
	for (int i = 1; i <= n; ++i) {
		vc.pb(i);
	}
	dfs(m, vc);
	printf("%d\n", tot);
	for (int i = 1; i <= tot; ++i) {
		printf("%d %d\n", ans[i].fst - 1, ans[i].scd - 1);
	}
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
```

做完这题可以去做 [P11366 [Ynoi2024] 末日的魔法少女计划](https://www.luogu.com.cn/problem/P11366)，两题的想法非常相似（

---


# [JOI Open 2016] 摩天大楼 / Skyscraper

## 题目背景

**译自 [JOI Open 2016](https://contests.ioi-jp.org/open-2016/index.html) T3 「高層ビル街 / Skyscraper」**

## 题目描述

将互不相同的 $N$ 个整数 $A_1, A_2, \cdots, A_N$ 按照一定顺序排列。

假设排列为 $f_1, f_2, \cdots, f_N$，要求：$| f_1 - f_2| + | f_2 - f_3| + \cdots + | f_{N-1} - f_N| \leq L$。

求满足题意的排列的方案数对 $10^9+7$ 取模后的结果。

## 说明/提示

### 样例 1 解释

满足条件的六种方案分别为：
$$
\begin{matrix}
2\ 3\ 6\ 9,& |2 - 3| + |3 - 6| + |6 - 9| &=& 7 \\
2\ 3\ 9\ 6,& |2 - 3| + |3 - 9| + |9 - 6| &=& 10 \\
3\ 2\ 6\ 9,& |3 - 2| + |2 - 6| + |6 - 9| &=& 8 \\
6\ 9\ 3\ 2,& |6 - 9| + |9 - 3| + |3 - 2| &=& 10 \\
9\ 6\ 2\ 3,& |9 - 6| + |6 - 2| + |2 - 3| &=& 8 \\
9\ 6\ 3\ 2,& |9 - 6| + |6 - 3| + |3 - 2| &=& 7 \\
\end{matrix}
$$

### 数据规模与约定

**本题采用捆绑测试。**

对于所有数据，$1\le N\le 100$，$1\le L\le 1000$，$1\le A_i\le 1000$。

- Subtask 1（5 points）：$N\le 8$。
- Subtask 2（15 points）：$N\le 14$，$L\le 100$。
- Subtask 3（80 points）：没有额外限制。

## 样例 #1

### 输入

```
4 10
3 6 2 9```

### 输出

```
6```

## 样例 #2

### 输入

```
8 35
3 7 1 5 10 2 11 6```

### 输出

```
31384```

# 题解

## 作者：AFewSuns (赞：59)

很套路的一道题。

### 题目大意

给定长为 $n$ 的序列 $a$，$a_i$ 互不相同。你要将其重排成 $f_1,f_2,\dots,f_n$，需要满足 $|f_1-f_2|+|f_2-f_3|+\dots+|f_{n-1}-f_n| \leq L$，求满足条件的重排方案数，对 $10^9+7$ 取模。

$1 \leq n \leq 100,1 \leq L,a_i \leq 1000$

### 题目分析

首先把重排后的序列 $f$ 拍到平面上，横坐标为下标，纵坐标为 $f_i$，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/o5ll2dz5.png)

那么所要求的就是红线的（纵坐标差）长度和。容易想到从上往下扫，然后动态计算目前的折线长度和：

![](https://cdn.luogu.com.cn/upload/image_hosting/3crdjp0i.png)

每次从大到小加入 $a_i$，那么新增加的折线就有 $2 \times$ 目前连续段数个（下图绿色部分）：

![](https://cdn.luogu.com.cn/upload/image_hosting/dzez98mv.png)

不过注意到当最后一个数已经插入时，后面不能再算贡献（绿色紫色虚线部分），同理，第一个数已经插入时前面不能再算贡献。于是设 $dp_{i,j,0/1,0/1}$ 表示目前已经有 $i$ 个连续段，答案为 $j$，第一个数/最后一个数有没有被加进去，答案就是 $dp_{1,\leq L,1,1}$。

转移的话大致有三种：

- 这个数新开了一个段，段数 $+1$。
- 这个数合并了两段，段数 $-1$。
- 这个数延续了其中一段，段数不变。

时间复杂度 $\mathcal O(n^2L)$，足以通过。

### 代码

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define ll long long
#define fr(i,x,y) for(register ll i=(x);i<=(y);i++)
using namespace std;
ll n,lim,a[110],f[110][1010][2][2],g[110][1010][2][2],ans=0;
inline void inc(ll &x,ll y){
	((x+=y)>=mod)?(x-=mod):0;
}
int main(){
	scanf("%lld %lld",&n,&lim);
	fr(i,1,n) scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	reverse(a+1,a+n+1);//从大到小排序 
	fr(p,0,1) fr(q,0,1) f[1][0][p][q]=1;
	fr(i,2,n){
		fr(j,1,i-1) fr(k,0,lim) fr(p,0,1) fr(q,0,1) g[j][k][p][q]=f[j][k][p][q];
		fr(j,1,i-1) fr(k,0,lim) fr(p,0,1) fr(q,0,1) f[j][k][p][q]=0;
		fr(j,1,i-1){
			fr(k,0,lim){
				fr(p,0,1){
					fr(q,0,1){
						if(!g[j][k][p][q]) continue;
						ll kk=k+(2*j-p-q)*(a[i-1]-a[i]);
						if(kk>lim) continue;
						//新开一个段 
						if(j>1) inc(f[j+1][kk][p][q],(j-1)*g[j][k][p][q]%mod);//在中间开段 
						if(!p){//在最左边开段 
							inc(f[j+1][kk][0][q],g[j][k][p][q]);
							inc(f[j+1][kk][1][q],g[j][k][p][q]);
						}
						if(!q){//在最右边开段 
							inc(f[j+1][kk][p][0],g[j][k][p][q]);
							inc(f[j+1][kk][p][1],g[j][k][p][q]);
						}
						//延续一段 
						if(j>1) inc(f[j][kk][p][q],2*(j-1)*g[j][k][p][q]%mod);
						if(!p){
							inc(f[j][kk][0][q],g[j][k][p][q]);
							inc(f[j][kk][1][q],g[j][k][p][q]);
						}
						if(!q){
							inc(f[j][kk][p][0],g[j][k][p][q]);
							inc(f[j][kk][p][1],g[j][k][p][q]);
						}
						//合并两段 
						if(j>1) inc(f[j-1][kk][p][q],(j-1)*g[j][k][p][q]%mod);
					}
				}
			}
		}
	}
	fr(i,0,lim) ans=(ans+f[1][i][1][1])%mod;
	printf("%lld",ans);
}
```

---

## 作者：chroneZ (赞：33)

> 广告：笔者的[《浅谈一类转移过程中依赖已插入元素的具体信息的序列计数问题 - 连续段 dp》](https://www.cnblogs.com/chroneZ/p/17938137)

注意到绝对值求和的形式，因此考虑将权值 $a$ 排序以规避绝对值。下文默认 $a$ 已按从小到大排序，且插入元素的顺序亦为从小到大。

记当前所有相邻项的绝对值之和为 $k$，当我们在两个已有相邻项之间插入新元素 $a_i$ 时，经过尝试我们发现新的 $k$ 值依赖于已有元素的具体取值。让我们重点考虑一下在端点处插入的情况，表面上我们需要知道端点元素的值 $x$ 并令 $k \gets k + a_i - x$，但是事实上，由于**对于一个单调递增的序列 $b$，其相邻项间绝对值之和 = $\sum b_i - b_{i - 1} = b_n -  b_1$**，这意味着，如果新插入的元素不是连续段的边界（如果一个端点被称为“边界”，则这个端点处不会再有新的元素插入），我们可以暂时忽略这个元素对 $k$ 的贡献，利用作为连续段边界的元素来统一处理这些贡献。

比较容易发现，每个未经过合并的连续段都是一个单谷序列（即 $\exists k \in [1, n], a_i > a_{i + 1} \forall i \in [1, k - 1] , a_i < a_{i + 1} \forall i \in [k, n - 1]$），如果确定了连续段的左右边界，并知道连续段中的最小元素（称这个最小元素的位置为“中间”），则这个连续段相邻项间的绝对值之和 = 右边界元素的值 - 中间元素的值 + 左边界元素的值 - 中间元素的值。我们将这三种贡献拆开，作为独立的三部分分别考虑：

- “边界”可以在合并两连续段时被添加，此时 $k' \gets k + 2a_i$，因为它同时作为了左侧连续段的右边界及右侧连续段的左边界。或者将插入元素强行作为边界插入到到目前最左侧 / 最右侧的连续段的左端 / 右端上，此时 $k' \gets k + a_i$。

- “中间”元素其实就是一个连续段中第一个被插入的元素，我们只需要在新建连续段时，$k' \gets k - 2a_i$。（注意在实现时必须分类讨论这个“中间”元素是否作为连续段的边界，如果“中间”元素同时作为边界的话，$k' \gets k - a_i$ 即可。）

这样一来，我们完成了关于 $k$ 的转移。因此记 $f_{i, j, k, d}$ 表示考虑了前 $i$ 个元素，形成了 $j$ 个连续段，贡献和为 $k$，已存在 $d$ 个边界（此处及下文的“边界”意为“被强行插入到最左端 / 最右端的边界”），满足以上约束的方案数。我们可以按如下方式写出状态转移方程：

- 作为一个新的连续段插入到不为边界的间隙中，即 $f_{i + 1, j + 1, k - 2a_{i + 1}, d} \gets f_{i, j, k, d} \times (j + 1 - d)$。
- $(j \geq 2)$ 合并两个连续段，即 $f_{i + 1, j - 1, k + 2a_{i + 1}, d} \gets f_{i, j, k, d} \times (j - 1)$。
- $(j \geq 1)$ 作为一个新元素插入到某个连续段的非边界端点处，即 $f_{i + 1, j, k, d} \gets f_{i, j, k, d} \times (2j - d)$。
- $(d < 2)$ 作为一个新的连续段作为边界插入，即 $f_{i + 1, j + 1, k - a_{i + 1}, d + 1} \gets f_{i, j, k, d} \times (2 - d)$。
- $(d < 2, j \geq 1)$ 作为一个新元素作为边界端点插入到某个连续段，即 $f_{i + 1, j, k + a_{i + 1}, d + 1} \gets f_{i, j, k, d} \times (2 - d)$。

最终答案为 $Ans = \sum \limits_{i = 0} ^ {L} f_{n, 1, i, 2}$。

然而，分析一下时间复杂度，记 $V$ 表示 $a_i$ 的值域，则 $k$ 这一维的状态数会达到 $\mathcal{O}(nV)$，总复杂度 $\mathcal{O}(n ^ 3V)$，对于本题是一个错误的复杂度。

瓶颈在哪里呢？前面提到 $k$ 的状态数达到 $\mathcal{O}(nV)$，但是事实上最终统计答案时有用的状态数仅是 $\mathcal{O}(L)$ 的。但是，按照我们 dp 的分析过程，这 $\mathcal{O}(nV)$ 个状态是不能直接省去的，因为 $k$ 在转移过程中可增可减，可以达到 $\mathcal{O}(nV)$ 的状态数。是否能换一种角度考虑贡献，使得贡献的转移只增不减，从而能够尽可能地去除无用状态呢？

---

考虑一种**差分**的思想：$\forall i < j, a_j - a_i = \sum \limits_{k = i} ^ {j - 1} a_{k + 1} - a_k$，则此时 $a_{k + 1} - a_k$ 对总贡献的贡献为所有贡献中满足 $i \leq k < j$ 的 $a_j - a_i$ 数量。

形式化一下，记 $b$ 为对 $a$ 进行任意重排列后的序列，$g(i)$ 表示 $b_i$ 这个数值在 $a$ 中的位置（$\text{i.e. } a_{g(i)} = b_i$）。显然总贡献即 $\sum b_{i + 1} - b_i = \sum a_{g(i + 1)} - a_{g(i)}$，记 $x_i = \min(g(i), g(i + 1)), y_i = \max(g(i), g(i + 1))$，依据上文差分的方法可以将总贡献写作 $\sum a_{y_i} - a_{x_i} = \sum \sum \limits_{k = x_i}^{y_i - 1}a_{k + 1} - a_k$，因此可以说明 $a_{k + 1} - a_k$ 对总贡献的贡献为满足 $x_i \leq k < y_i$ 的 $(x_i, y_i)$ 数量，也即前述结论。

它其实就是个差分。但是从贡献的角度考虑也能归为一种叫**微元贡献法**的 trick。其本质为，面对多个不同的贡献，但我们可以用若干个微元组合出所有不同贡献时，可以考虑此类微元贡献法。

由于上文提到 $a_{k + 1} - a_k$ 对总贡献的贡献为所有贡献中满足 $i \leq k < j$ 的 $a_j - a_i$ 数量，而我们插入元素的顺序是从小到大，因此**此后在每个连续段的两个端点处插入的新元素，都一定且仅能构成** $1$ **次这样的** $i \leq k < j$。（“一定”是因为连续段的端点处一定会插入新的值，“仅能”是因为插入新的值后新的值一定会大于 $a_k$，无法再组成新的 $i \leq k < j$。) 

由于确定一个边界后无法再向边界处插入新元素/连续段，因此边界的数量会降低此后新元素对总贡献的增量，仍然需要单独记录边界的数量 $d$。

设计 dp 状态为 $f_{i, j, k, d}$，意为考虑 $a$ 中前 $i$ 个元素构成了 $j$ 个连续段，当前总贡献为 $k$，边界数量为 $d$ 的方案数。综上，当我们插入一个新数 $a_{i + 1}$ 时，新的总贡献 $k' = k + (a_{i + 1} - a_i) \times (2j - d)$，并且可以直接忽略 $k' > L$ 的无用状态。

最后，考虑连续段 dp 的几种转移即可。记 $k' \gets k + (a_{i + 1} - a_i) \times (2j - d)$。当我们插入 $a_{i + 1}$ 时，

- 作为一个新的连续段插入到不为边界的间隙中，即 $f_{i + 1, j + 1, k', d} \gets f_{i, j, k, d} \times (j + 1 - d)$。
- $(j \geq 2)$ 作为中间点合并两个连续段，即 $f_{i + 1, j - 1, k', d} \gets f_{i, j, k, d} \times (j - 1)$。
- $(j \geq 1)$ 作为一个新元素插入到某个连续段的非边界端点处，即 $f_{i + 1, j, k', d} \gets f_{i, j, k, d} \times (2j - d)$。
- $(d < 2)$ 作为一个新的连续段作为边界插入，即 $f_{i + 1, j + 1, k', d + 1} \gets f_{i, j, k, d} \times (2 - d)$。
- $(d < 2, j \geq 1)$ 作为一个新元素作为边界端点插入到某个连续段，即 $f_{i + 1, j, k', d + 1} \gets f_{i, j, k, d} \times (2 - d)$。

答案显然为 $Ans = \sum \limits_{i = 0} ^ {L} f_{n, 1, i, 2}$。

> 值得一提的是，上文提及的两种 dp 方法中，$k$ 都并非仅考虑 $a$ 中这前 $i$ 个元素互相之间的总贡献，而是**提前计算**了这些元素之后所能产生的一切贡献，从而规避了后效性。这里也分享一篇介绍这种贡献提前计算的[好文](https://www.luogu.com.cn/blog/LgxTpre/qian-tan-yi-lei-you-hua-sai-xiang-fei-yong-ti-qian-ji-suan)。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

constexpr int N = 100 + 10, MOD = 1e9 + 7, M = 1000 + 10;
inline void pl(int &x, i64 y) {x = (y + x) % MOD;}

int f[N][N][M][3], a[N];

void solve(){
    int n, l; cin >> n >> l;
    for(int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a + 1, a + n + 1);
    f[0][0][0][0] = 1;
    for(int i = 0; i < n; i++) for(int j = 0; j <= i; j++)
        for(int k = 0; k <= l; k++) for(int d = 0; d < 3; d++){
            i64 p = k + (a[i + 1] - a[i]) * (2 * j - d), t = f[i][j][k][d];
            if(!t) continue;
            if(p > l) continue;
            
            pl(f[i + 1][j + 1][p][d], t * (j + 1 - d));
            if(j >= 2) pl(f[i + 1][j - 1][p][d], t * (j - 1));
            if(j >= 1) pl(f[i + 1][j][p][d], t * (2 * j - d));
            if(d < 2) pl(f[i + 1][j + 1][p][d + 1], t * (2 - d));
            if(d < 2 && j >= 1) pl(f[i + 1][j][p][d + 1], t * (2 - d));
        }
    int ans = 0;
    for(int i = 0; i <= l; i++)
        pl(ans, f[n][1][i][2]);
    cout << (n == 1 ? 1 : ans) << "\n";
}
```

> UPD 2023.11.18: 感谢 @Missa 指出的一些细节错误。

---

## 作者：cwfxlh (赞：15)

# [P9197](https://www.luogu.com.cn/problem/P9197)   

对于这种问题有一个经典的处理方式，按值排序后从大往小扫，同时确定每一个数的位置。这时候，一个排列的总贡献就是 $\sum_{i=1}^{n-1}(a_{i+1}-a_i)\times s(i+1)$，这里 $s(x)$ 指的是将下标在 $[x,n]$ 的数加入后，连续段的个数（因为两头没有贡献，所以还要考虑两头是否被选中）。令 $dp_{i,j,k,0/1,0/1}$ 表示选了下标在 $[i,n]$ 的数，当前有 $j$ 个连续段，当前权值和为 $k$，左/右两头选/不选的方案数。注意这里记的只是连续段，并没有钦定它们的具体位置，所以限制会松很多，也很方便转移。于是每次考虑加入一个元素，考虑它是自成一段还是续上一段，或者将两段连起来，同时再考虑是否占据两头即可。    

~~丑陋的~~代码:    

```cpp
#include<bits/stdc++.h>
#define int long long
#define MOD 1000000007
using namespace std;
int n,l,a[500003],dp[103][103][1003][2][2],ans;
signed main(){
	scanf("%lld%lld",&n,&l);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	if(n==1){
		puts("1");
		return 0;
	}
	sort(a+1,a+n+1);
	dp[n][1][0][0][0]=1;
	dp[n][1][0][1][0]=1;
	dp[n][1][0][0][1]=1;
	for(int i=n-1;i;i--){
		for(int j=1;j<=n-i+1;j++){
			for(int u=0;u<=l;u++){
				if(u-2ll*j*(a[i+1]-a[i])>=0){
					dp[i][j][u][0][0]+=dp[i+1][j][u-2ll*j*(a[i+1]-a[i])][0][0]*(2ll*j);
					dp[i][j][u][0][1]+=dp[i+1][j][u-2ll*j*(a[i+1]-a[i])][0][0];
					dp[i][j][u][1][0]+=dp[i+1][j][u-2ll*j*(a[i+1]-a[i])][0][0];
				}
				if(u-(2ll*j-1ll)*(a[i+1]-a[i])>=0){
					dp[i][j][u][0][1]+=dp[i+1][j][u-(2ll*j-1ll)*(a[i+1]-a[i])][0][1]*(2ll*j-1ll);
					dp[i][j][u][1][0]+=dp[i+1][j][u-(2ll*j-1ll)*(a[i+1]-a[i])][1][0]*(2ll*j-1ll);
					dp[i][j][u][1][1]+=dp[i+1][j][u-(2ll*j-1ll)*(a[i+1]-a[i])][0][1];
					dp[i][j][u][1][1]+=dp[i+1][j][u-(2ll*j-1ll)*(a[i+1]-a[i])][1][0];
				}
				if(u-(2ll*j-2ll)*(a[i+1]-a[i])>=0){
					dp[i][j][u][0][0]+=dp[i+1][j-1][u-(2ll*j-2ll)*(a[i+1]-a[i])][0][0]*j;
					dp[i][j][u][0][1]+=dp[i+1][j-1][u-(2ll*j-2ll)*(a[i+1]-a[i])][0][0];
					dp[i][j][u][1][0]+=dp[i+1][j-1][u-(2ll*j-2ll)*(a[i+1]-a[i])][0][0];
					dp[i][j][u][1][1]+=dp[i+1][j][u-(2ll*j-2ll)*(a[i+1]-a[i])][1][1]*(2ll*j-2ll);
				}
				if(u-(2ll*j-3ll)*(a[i+1]-a[i])>=0){
					dp[i][j][u][0][1]+=dp[i+1][j-1][u-(2ll*j-3ll)*(a[i+1]-a[i])][0][1]*(j-1ll);
					dp[i][j][u][1][0]+=dp[i+1][j-1][u-(2ll*j-3ll)*(a[i+1]-a[i])][1][0]*(j-1ll);
					dp[i][j][u][1][1]+=dp[i+1][j-1][u-(2ll*j-3ll)*(a[i+1]-a[i])][0][1];
					dp[i][j][u][1][1]+=dp[i+1][j-1][u-(2ll*j-3ll)*(a[i+1]-a[i])][1][0];
				}
				if(u-(2ll*j)*(a[i+1]-a[i])>=0)dp[i][j][u][1][1]+=dp[i+1][j+1][u-(2ll*j)*(a[i+1]-a[i])][1][1]*j;
				if(u-(2ll*j+1ll)*(a[i+1]-a[i])>=0)dp[i][j][u][1][0]+=dp[i+1][j+1][u-(2ll*j+1ll)*(a[i+1]-a[i])][1][0]*j;
				if(u-(2ll*j+1ll)*(a[i+1]-a[i])>=0)dp[i][j][u][0][1]+=dp[i+1][j+1][u-(2ll*j+1ll)*(a[i+1]-a[i])][0][1]*j;
				if(u-(2ll*j+2ll)*(a[i+1]-a[i])>=0)dp[i][j][u][0][0]+=dp[i+1][j+1][u-(2ll*j+2ll)*(a[i+1]-a[i])][0][0]*j;
				if(u-(2ll*j-4ll)*(a[i+1]-a[i])>=0)dp[i][j][u][1][1]+=dp[i+1][j-1][u-(2ll*j-4ll)*(a[i+1]-a[i])][1][1]*(j-2);
				dp[i][j][u][0][0]%=MOD;
				dp[i][j][u][0][1]%=MOD;
				dp[i][j][u][1][0]%=MOD;
				dp[i][j][u][1][1]%=MOD;
				if((n-i+1)+(j+1)>n)dp[i][j][u][0][0]=0;
				if((n-i+1)+j>n)dp[i][j][u][0][1]=dp[i][j][u][1][0]=0;
				if((n-i+1)+(j-1)>n)dp[i][j][u][1][1]=0;
			}
		}
	}
	for(int j=0;j<=l;j++)ans=(ans+dp[1][1][j][1][1])%MOD;
	ans+=MOD;
	ans%=MOD;
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：HANGRY_sol (赞：11)

先考虑一下 $O(n^2\sum\limits a_i)$ 的做法：

我们为了处理掉绝对值号，直接将 $A_i$ 从小到大排序。

如果我们不进行连续段合并，就是说只考虑往两端加的情况，显然是一个钩子状的。

图：

![](https://cdn.luogu.com.cn/upload/image_hosting/diz5oy8p.png)

然后我们对于这样的段来说，其答案显然为 $left + right - 2 \times mid$。

（$left$ 指最左端值，$right$ 指最右段值，$mid$ 指中间段最小的那个数）。

然后如果两个钩子合并的话，图：

![](https://cdn.luogu.com.cn/upload/image_hosting/grejzofz.png)

我们就发现中间那个最高的变成左右两个的左端或右端。

那总答案的 $\Delta$ 为 $2 \times new - left_{right} - right_{left}$。

我们发现只要不是最左端或最右端，那么都会经历一个这样的过程，因此在我们 DP 的时候，只将区间最左和区间最右的特殊考虑。

具体的，设 $dp_{i , j , k , d}$ 表示前 $i$ 个，$j$ 段，答案为 $k$，拥有 $d$ 个端点（$1$ 或 $n$）。

那如果是合并段：

$$dp_{i , j , k , d} = dp_{i - 1 , j + 1 , k - 2 \times a_i , d} \times j$$

至于为什么从 $k-2 \times a_i$ 转移来，就是为了上图中可能的减法（我们不知道那俩数是啥）准备的，非极端点不加入转移。

若是新加段且不为端点：

$$dp_{i , j , k , d} = dp_{i - 1 , j - 1 , k + 2 \times a_i , d} \times j$$

$a_i$ 将是 $a_i$ 所在钩子的最小值（上面不是算出 $-2mid$ 吗）。

若是新加段并是端点：

$$dp_{i , j , k , d} = dp_{i - 1 , j - 1 , k + a_i , d - 1} \times(2 - d + 1)$$

端点只有左右两种情况了吧，为什么从 $k + a_i$ 转移来是因为其与某个 $left$ 或 $right$ 重合，需特殊处理。

若是并在某段两边，且不为端点：

$$dp_{i , j , k , d} = dp_{i - 1 , j , k , d} \times (2j - d)$$

若是并在某段两边，且为端点：

$$dp_{i , j , k , d} = dp_{i - 1 , j , k + a_i , d - 1} \times (2 - d + 1)$$

然后我们发现这个 DP 第三维是要处理到 $\sum a_i$ 的，因为既有加又有减。

所以时间复杂度是 $O(n^2 \sum a_i)$ 的，寄了。

然后考虑一下优化哈，有这么个东西叫提前处理答案。

对于一个差分 $a_{i + 1} - a_i$ 他的贡献。

我们发现对于 $a_i - a_j (i > j)$ 来说，我们知道这个：

$$a_i - a_j  = \sum_{k = j + 1}^{i}a_k - a_{k - 1}$$

那么只有左右 $i < k \le j$ 时 $a_k - a_{k - 1}$ 才被计算。

那么就是说在当 $a_{i + 1}$ 加入时：

现在共有 $j$ 个段吧，那么这 $j$ 个段里每个数都是小于 $a_{i + 1}$ 的。

那么加入 $a_{i + 1}$ 以后，很多数并在了 $j$ 个段的左右两端。

假设段 $k$ 在左端未处理 $a_{i + 1}$ 前数为 $x$ , 第一个在处理完 $a_{i + 1}$ 后数为 $y$。

显然 $y > a_{i + 1} > x$。 

那么 $y - x$ 的值就有 $a_{i + 1} - a_i$ 的一份贡献。

再往后，新并在 $y$ 左的值就不满足条件了。同理，$k$ 右端第一个新并上的值一样，所有端包括 $a_{i + 1}$ 所处的端也一样。

那么我们就发现共有 $2\times j$ 个位置是符合条件的，是能被贡献上的。当然还要考虑左右极端点，设已有个数为 $d$, 所以本差分贡献为 $(2\times j - d) \times (a_{i + 1} - a_i)$（$j$ 是处理前的段的数量）。

然后就可以得到式子了。DP 设计不变，只要将所有的 $k$ 加减什么数全部改成 $k_2 =(2\times j - d) \times (a_{i + 1} - a_i)$ 就可以了。

如果目前的 $k_2$ 超过 $L$ 直接不算弃了就行，时间复杂度 $O(n^2L)$。

```cpp
#include <bits/stdc++.h>
using namespace std ; 
typedef long long ll ; 
const int N = 101 ; 
const int M = 1010 ; 
const int mod = 1e9 + 7 ; 

int n , m , a[N] ; 
int dp[N][N][M][3] ; 

signed main() {
	ios :: sync_with_stdio(0) , cin.tie(0) , cout.tie(0) ; 
	cin >> n >> m ; 

	if (n == 1) { // 特判 n = 1
		cout << 1 ; return 0 ; 
	}

	for (int i = 1 ; i <= n ; ++ i) cin >> a[i] ; 

	stable_sort(a + 1 , a + n + 1) ; 
	dp[0][0][0][0] = 1 ; 

	for (int i = 0 ; i < n ; ++ i) {
		for (int j = 0 ; j <= i ; ++ j) {
			for (int k = 0 ; k <= m ; ++ k) {
				for (int d = 0 ; d <= 2 ; ++ d) {
					ll k2 = 1ll * (2 * j - d) * (a[i + 1] - a[i]) + 1ll * k ; 
					if (k2 > m || k2 < 0) continue ; 
					if (!dp[i][j][k][d]) continue ; 

					if (j >= 2) dp[i + 1][j - 1][k2][d] = (1ll * dp[i + 1][j - 1][k2][d] + 1ll * dp[i][j][k][d] * (j - 1)) % mod ; // 合并两个区间
					if (j >= 1) dp[i + 1][j][k2][d] = (1ll * dp[i + 1][j][k2][d] + 1ll * dp[i][j][k][d] * (2 * j - d)) % mod ; // 并在一个区间左右且不为端点
					dp[i + 1][j + 1][k2][d] = (1ll * dp[i + 1][j + 1][k2][d] + 1ll * dp[i][j][k][d] * (j + 1 - d)) % mod ; // 重开一个且不为端点
					
					if (d < 2 && j >= 1) dp[i + 1][j][k2][d + 1] = (1ll * dp[i + 1][j][k2][d + 1] + 1ll * dp[i][j][k][d] * (2 - d)) % mod ; //  并在一个区间左右且为端点
					if (d < 2) dp[i + 1][j + 1][k2][d + 1] = (1ll * dp[i + 1][j + 1][k2][d + 1] + 1ll * dp[i][j][k][d] * (2 - d)) % mod ; // 重开一个且为端点
				}
			}
		}
	}

	ll ans = 0 ; 

	for (int i = 0 ; i <= m ; ++ i) {
		ans = (ans + 1ll * dp[n][1][i][2]) % mod ; 
	}

	cout << ans ; 
}
```

---

## 作者：Acoipp (赞：8)

# [**[JOI Open 2016] 摩天大楼**](https://www.luogu.com.cn/problem/P9197)

## **初探题面**

首先，看到绝对值想到分类讨论，即为：
$$
\operatorname{g}(i,i+1) = \begin{cases} f_i-f_{i+1} & f_i \ge f_{i+1} \\ f_{i+1}-f_i & f_i < f_{i+1} \end{cases}
$$

那么又是根据大小关系来决定权值大小了，所以考虑插入 DP。  

## **状态推导**

因为这里的状态因为没有段长的硬性要求，所以 $W,V,A,M$ 形状的段都是可以的，因此也减少了初始和结尾字符的特判（尽管题目也不需要特判）。

设 $dp_{i,j,k}$ 表示 $1\sim i$ 这些数所代表的数值插入进去之后有 $j$ 段当前权值总和为 $k$ 的情况总数。

注意到最开始是不用 $f_1-f_0$ 或者 $f_0-f_1$，结尾同理，所以依旧需要特判。

再发现，如果我们不记录开始和结尾数值的话，很难维护，所以我们要 **用尽可能小的空间传递更多的信息**。

- 如果我们能够确定第一个位置是否已经被填了，那么就不存在其它特判情况了，即在填的时候特判一下就可以了。（结尾同理）

根据上面那一条发现的性质，我们对 DP 状态进行修改，设 $dp_{i,j,k,0/1,0/1}$ 表示 $1\sim i$ 这些数所代表的数值插入进去之后有 $j$ 段当前权值总和为 $k$ 且开头结尾有没有被确定的情况总数。

这个转移方程一确定，那么事情就简单多了。

## **转移方程**
首先，明确一下状态的后效性如何去除（因为 $\operatorname{g}(i,i+1)$ 与两个元素有关）。

看下面这幅图：
![](https://cdn.luogu.com.cn/upload/image_hosting/4t9nejw4.png)

（其中横轴为元素的位置，纵轴为元素的值）

容易看出这样的总的权值和是：$\left\vert 5-1\right\vert +\left\vert1-6\right\vert+\left\vert6-4\right\vert+\left\vert4-3\right\vert+\left\vert3-2\right\vert+\left\vert2-7\right\vert+\left\vert7-8\right\vert$ 的。

在我们按照大小顺序插入的前提下考虑分开：$5-1+6-1+6-4+4-3+3-2+7-2+8-7$，消项得：$5-1+6-1+6-2+8-2$。

这样我们就可以得知，每个**极小值**会被减去两次（但是如果是在序列开头或末尾只会被减一次），每个**极大值**会被加两次（但是如果是在序列开头或末尾只会被加一次）。

即遇到极大值看它是不是在开头或者末尾，如果在，贡献就会一份，否则为两份，极小值同理。

综上，我们就把 $i,i+1$ 的贡献分开了，而且也利用到了我们知晓元素之间大小关系的性质，DP 转移就可以开始执行了。

**以下状态设计均为从大往小插入考虑**

然后，熟悉的分类讨论：
- 对于 $i$，它合并了两个段，段数少 $1$  

因为 $i$ 合并两个段，所以它不能在最左边或者最右边，而且它两端都是比它小的数，那么它便是这个区间的极小值，对全局的贡献是负的两倍。即：
$$
dp_{i,j,k,p,l} = jdp_{i-1,j+1,k+2a_i,p,l}
$$

（为什么是加 $2a_i$，是因为，它插入之后贡献为 $k$，插入之前肯定就是加上）

- 对于 $i$，它新开了一个段，段数多 $1$

因为 $i$ 新开了一个段，之后合并它和其它段的数一定比它小，所以它是区间极大值，对全局的贡献是正两倍，注意，它如果是在最左边，它的贡献就只有一倍，在最右边同理。特别注意，如果左右两边已经确定了，那么它能够新开段的位置会少 $1\sim 2$ 个。即：

$$
\begin{aligned}
dp_{i,j,k,0,0} &= jdp_{i-1,j-1,k-2a_i,0,0} \\
dp_{i,j,k,0,1} &= (j-1)dp_{i-1,j-1,k-2a_i,0,1}+dp_{i-1,j-1,k-a_i,0,0} \\
dp_{i,j,k,1,0} &= (j-1)dp_{i-1,j-1,k-2a_i,1,0}+dp_{i-1,j-1,k-a_i,0,0} \\
dp_{i,j,k,1,1} &= (j-2)dp_{i-1,j-1,k-2a_i,1,1}+dp_{i-1,j-1,k-a_i,1,0}+dp_{i-1,j-1,k-a_i,0,1}  
\end{aligned}
$$

- 对于 $i$，它延续了某个段，并接在该段的左/右边，段数不变

我们以左边为例，因为 $i$ 在普通情况下一边会有比它小的，一边会有比它大的，所以 $i$ 对总的值没有贡献，但是当 $i$ 在左边或者右边时，它是区间极小值，贡献是负一倍。即：

$$
\begin{aligned}
dp_{i,j,k,0,0} &= jdp_{i-1,j,k,0,0} \\
dp_{i,j,k,0,1} &= jdp_{i-1,j,k,0,1} \\
dp_{i,j,k,1,0} &= (j-1)dp_{i-1,j,k,1,0}+dp_{i-1,j,k+a_i,0,0} \\
dp_{i,j,k,1,1} &= (j-1)dp_{i-1,j,k,1,1}+dp_{i-1,j,k+a_i,0,1}
\end{aligned}
$$

加在右边同理，由此我们推导完了整个 DP，但是实现过程中还要注意一下转移时的细节：左右端点固定后权值是多少？有多少个段可以插入等。

这种方法常数很大，同时不利于优化，但是更好想一些。

## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
ll n,i,j,k,l,a[105],dp[2][105][8005][2][2],ans;
bool cmp(ll a,ll b){return a>b;}
void add(ll &a,ll b){
	a += b;
	a %= mod;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>l;
	for(i=1;i<=n;i++) cin>>a[i];
	if(n==1){
		cout<<1<<endl;
		return 0;
	} 
	sort(a+1,a+n+1,cmp);
	dp[0][0][0][0][0] = 1;
	for(i=1;i<=n;i++){
		for(j=0;j<=i;j++) for(k=0;k<=6000;k++) dp[i&1][j][k][0][0]=dp[i&1][j][k][1][0]=dp[i&1][j][k][0][1]=dp[i&1][j][k][1][1]=0;
		for(j=1;j<=i;j++){
			for(k=0;k<=6000;k++){
				//MERGE
				add(dp[i&1][j][k][0][0],j*dp[(i-1)&1][j+1][k+2*a[i]][0][0]);
				add(dp[i&1][j][k][0][1],j*dp[(i-1)&1][j+1][k+2*a[i]][0][1]);
				add(dp[i&1][j][k][1][0],j*dp[(i-1)&1][j+1][k+2*a[i]][1][0]);
				add(dp[i&1][j][k][1][1],j*dp[(i-1)&1][j+1][k+2*a[i]][1][1]);
				if(k>=2*a[i]){
					//NEW
					add(dp[i&1][j][k][0][0],j*dp[(i-1)&1][j-1][k-2*a[i]][0][0]);
					add(dp[i&1][j][k][1][0],(j-1)*dp[(i-1)&1][j-1][k-2*a[i]][1][0]);
					add(dp[i&1][j][k][0][1],(j-1)*dp[(i-1)&1][j-1][k-2*a[i]][0][1]);
					if(j-1>1) add(dp[i&1][j][k][1][1],(j-2)*dp[(i-1)&1][j-1][k-2*a[i]][1][1]);
				}
				if(k>=a[i]){
					//NEW
					add(dp[i&1][j][k][1][0],dp[(i-1)&1][j-1][k-a[i]][0][0]);
					add(dp[i&1][j][k][0][1],dp[(i-1)&1][j-1][k-a[i]][0][0]);
					add(dp[i&1][j][k][1][1],dp[(i-1)&1][j-1][k-a[i]][0][1]+dp[(i-1)&1][j-1][k-a[i]][1][0]);
				}
				//LEFT
				add(dp[i&1][j][k][0][0],j*dp[(i-1)&1][j][k][0][0]);
				if(j>1) add(dp[i&1][j][k][1][0],(j-1)*dp[(i-1)&1][j][k][1][0]);
				add(dp[i&1][j][k][1][0],dp[(i-1)&1][j][k+a[i]][0][0]);
				add(dp[i&1][j][k][0][1],j*dp[(i-1)&1][j][k][0][1]);
				if(j>1) add(dp[i&1][j][k][1][1],(j-1)*dp[(i-1)&1][j][k][1][1]+dp[(i-1)&1][j][k+a[i]][0][1]);
				else add(dp[i&1][j][k][1][1],dp[(i-1)&1][j][k+a[i]][0][1]);
				//RIGHT
				add(dp[i&1][j][k][0][0],j*dp[(i-1)&1][j][k][0][0]);
				add(dp[i&1][j][k][1][0],j*dp[(i-1)&1][j][k][1][0]);
				if(j>1) add(dp[i&1][j][k][0][1],(j-1)*dp[(i-1)&1][j][k][0][1]);
				add(dp[i&1][j][k][0][1],dp[(i-1)&1][j][k+a[i]][0][0]);
				if(j>1) add(dp[i&1][j][k][1][1],(j-1)*dp[(i-1)&1][j][k][1][1]+dp[(i-1)&1][j][k+a[i]][1][0]);
				else add(dp[i&1][j][k][1][1],dp[(i-1)&1][j][k+a[i]][1][0]);
			}
		}
	}
	for(i=0;i<=l;i++) ans=(ans+dp[n&1][1][i][1][1])%mod;
	cout<<ans<<endl;
}
```

---

## 作者：Leasier (赞：5)

感觉我一直不是很会这种排列计数的题啊 /oh

------------

**连续段 dp 的套路。**

考虑把原问题转化为 $(i, a_i)$ 所画出的折线图长度之和 $\leq l$。

从横坐标的角度不便讨论，不妨考虑讨论纵坐标上每段的贡献。

**注意到从 $v + 1 \to v$ 时对应所有折线段的贡献只跟下顶点在 $y = v$ 及其上方的连续折线段个数及其是否作为开头 / 结尾段有关。**

考虑对**连续段信息** dp。首先对 $a$ 排序，设 $dp_{i, j, k, l = 0/1/2}$ 表示考虑到 $y = a_i$ 及其上方的所有折线段，顶点在 $y = a_i$ 下方的连续段条数为  $j$，当前讨论到的所有折线段的贡献之和为 $k$，作为开头 / 结尾段的点已被确定了 $l$ 个。

转移时需要讨论以下三种情况以及其涉及边界的情况：

- 开一个不在端点处的新连续段。
- 延续此前的某个连续段。
- 合并此前的某两个连续段。

具体转移方式请自行推导或参考代码。

时间复杂度为 $O(n^2l)$。

代码：
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int mod = 1e9 + 7;
int a[107], dp[1007][107][1007][3];

int main(){
	int n, l, ans = 0;
	cin >> n >> l;
	for (int i = 1; i <= n; i++){
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
	dp[n][1][0][0] = dp[n][1][0][2] = 1;
	dp[n][1][0][1] = 2;
	for (int i = n - 1; i >= 1; i--){
		int t = n - i;
		for (int j = 1; j <= t; j++){
			for (int k = 0; k <= l; k++){
				for (int x = 2; x >= 0; x--){
					int k_ = k + (a[i + 1] - a[i]) * (j * 2 - x);
					if (k_ > l) break;
					dp[i][j + 1][k_][x] = (dp[i][j + 1][k_][x] + 1ll * dp[i + 1][j][k][x] * (j - x + 1) % mod) % mod;
					if (x < 2) dp[i][j + 1][k_][x + 1] = (dp[i][j + 1][k_][x + 1] + dp[i + 1][j][k][x] * (2 - x) % mod) % mod;
					dp[i][j][k_][x] = (dp[i][j][k_][x] + 1ll * dp[i + 1][j][k][x] * (j * 2 - x) % mod) % mod;
					dp[i][j][k_][x + 1] = (dp[i][j][k_][x + 1] + 1ll * dp[i + 1][j][k][x] * (2 - x) % mod) % mod;
					if (j > 1) dp[i][j - 1][k_][x] = (dp[i][j - 1][k_][x] + 1ll * dp[i + 1][j][k][x] * (j - 1) % mod) % mod;
				}
			}
		}
	}
	for (int i = 0; i <= l; i++){
		ans = (ans + dp[1][1][i][2]) % mod;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：4)

补一个自己不会的套路

## 题目简述

> - 数列 $\{a_n\}$，询问有多少个 $1,2,\dots,n$ 的排列 $p_i$ 满足：
>
> - $$
   val(a,p)=\sum_{i=1}^{n-1}|a_{p_i}-a_{p_{i+1}}|\leq l
   $$
>
> - 数据保证 $n\leq 100,l\leq 1000$。



## 解题思路

显然考虑从小到大插入 $a$。考虑怎么拆绝对值。

举个栗子而言，如果当前决定的序列为 $[?_1,1,2,?_2,?_3,?_4,3,4,5]$，其中 $?_i$ 表示未决策位。我们考虑填入 $7$ 的贡献，不难发现其在 $4$ 个未决策位产生的贡献是不同的，这很难让我们 dp。我们想要决策位的贡献尽可能的相同。解决办法是我们添加一个数 $a_i$ 的时候，所有「决策位-未决策位」、「未决策位-决策位」对 $val(a)$ 的贡献先加上 $a_i-a_{i-1}$。这样子无论选哪个未决策位所产生的贡献都已相同的。

在上面的例子当中，无论如何插入 $7$，相邻对 $(?_1,1),(2,?_2),(?_4,3)$ 都要对 $val$ 产生 $a_i-a_{i-1}=7-5=2$ 的贡献，也就是插入 $7$ 对 $val$ 的贡献是 $3\times 2=6$。

这样插入的影响只和极长连续段的相对位置有关，直接 dp 即可。定义 $f[i][j][k][t]$ 表示前 $i$ 个数当中，有 $j$ 个连续段，当前 $val(a)$ 为 $k$，当前有 $t\in\{0,1,2\}$ 个挨到边界，大力分讨即可。具体见「实现细节」。

## 实现细节

下面考虑具体 $f$ 的转移，注意我们所需要的的 $f$ 只关注所有连续段的**相对位置**，而不是具体在数列当中的位置。考虑所有可能 $a_i$ 放的位置，对于 $f[i-1][j][k][t]$ 的转移，知道 $a_i$ 对 $val$ 的贡献为 $(2j-t)\times a_i$，假设 $k'=(2j-t)\times a_i+k$，转移不难分成以下 $5$ 种：

- $a_i$ 接在某个连续段的开头或结尾，且没有挨到整个序列的开头或结尾。这样的转移是 $f[i][j][k'][t]\leftarrow f[i][j][k][t]\times (2j-t)$。
- $a_i$ 接在某个连续段的开头或结尾，且挨到整个序列的开头或结尾。这样的转移是 $f[i][j][k'][t+1]\leftarrow f[i][j][k][t]\times (2-t)$。
- $a_i$ 连接了两个相邻的段。这样的转移是 $f[i][j-1][k'][t]\leftarrow f[i][j][k][t]\times (j-1)$。
- $a_i$ 独立成段，没挨边界。这样的转移是 $f[i][j+1][k'][t]\leftarrow f[i][j][k][t]\times (j+1-t)$。
- $a_i$ 独立成段，挨边界。这样的转移式 $f[i][j+1][k'][t+1]\leftarrow f[i][j][k][t]\times (2-t)$。

以上便是 $dp$ 的转移式，时间复杂度是 $O(n^2l)$。常数很大，感觉有点悬。不过不难发现有很多 $f$ 的值是 $0$，转移时跳过这些值跑得飞快。

还要注意特判掉 $n=1$ 的情况。因为这样加入 $a_1$ 会挨两个边界，和上面不符。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
const int MOD=1e9+7;
int n,l;
ll f[105][105][1005][3];
int a[105];
void add(ll &a,ll b){a+=b;if(a>=MOD) a-=MOD;}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>l;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	if(n==1){cout<<"1";return 0;}
	f[0][0][0][0]=1;
	sort(a+1,a+n+1);
	for(int i=0;i<n;i++){
		for(int j=0;j<=n;j++)
			for(int k=0;k<=l;k++)
				for(int t=0;t<=2;t++){
					ll val=(2*j-t)*(a[i+1]-a[i]);
					if(!f[i][j][k][t]||2*j<t||val+k>l) continue;
					// case 1: a[i+1] 丢到某个连续段开头或末尾，不连接末尾
					add(f[i+1][j][k+val][t],f[i][j][k][t]*(2*j-t)%MOD);
					// case 2: a[i+1] 丢到某个连续段开头或末尾，连接末尾
					if(t<2) add(f[i+1][j][k+val][t+1],f[i][j][k][t]*(2-t)%MOD);
					// case 3: a[i+1] 连接两个连续段
					if(j>0) add(f[i+1][j-1][k+val][t],f[i][j][k][t]*(j-1)%MOD);
					// case 4: a[i+1] 成为独立段（不靠墙）
					add(f[i+1][j+1][k+val][t],f[i][j][k][t]*(j+1-t)%MOD);
					// case 5: a[i+1] 成为独立段（靠墙）
					if(t<2) add(f[i+1][j+1][k+val][t+1],f[i][j][k][t]*(2-t)%MOD);
				}
	}
	ll ans=0;
	for(int i=0;i<=l;i++)
		ans+=f[n][1][i][2];
	cout<<ans%MOD;
	return 0;
}
```



---

## 作者：Mo默Sh笙 (赞：2)

### [传送门](https://www.luogu.com.cn/problem/P9197)

**插入 DP** 好题，与 [P5999](https://www.luogu.com.cn/problem/P5999) 类似。

~~题解区都是刷表法题解，但是蒟蒻只会填表法，所以就有了这篇填表法题解。~~

------------

先考虑如何把绝对值拆开，可以想到排序。考虑插入的过程，进行插入 DP。

**设 $dp_{i,j,k,S}$ 表示当前处理到第 $i$ 个数，有 $j$ 个连续段，当前贡献值为 $k$，首尾的覆盖状态为 $S$，其中 $S=0/1/2$ 分别表示都未覆盖/覆盖其一/都覆盖**。

按从大到小排序依次插入 $A_{i}$，分以下几种情况讨论：

- 新开一段（作为首尾）：只相邻一个数，该数小于 $A_{i}$，贡献为 $A_{i}$；
- 接在一段上（作为首尾）：只相邻一个数，该数大于 $A_{i}$，贡献为 $-A_{i}$；
- 新开一段（不作为首尾）：相邻两个数，两数都小于 $A_{i}$，贡献为 $2\times A_{i}$；
- 合并两段（不作为首尾）：相邻两个数，两数都大于 $A_{i}$，贡献为 $-2\times A_{i}$；
- 接在一段上（不作为首尾）：相邻两个数，一数大于 $A_{i}$，一数小于 $A_{i}$，贡献为 $A_{i}-A_{i}=0$。

$ans = \sum_{i=1}^{l}{dp_{n,1,i,2}}$。

这几种情况除了最后一种情况都有贡献值的变化，所以转移还得满足转移过来的状态贡献值合法（不为负数不越界），需要加以判断。

作为首尾的情况也得满足当前状态首尾被覆盖，即 $S=1/2$。

------------

有人可能有疑问：为什么不从小到大排序？

因为一开始插入的数只能作为新的段，如果从小到大排序，贡献就是负数，就会出现 $k$ 值为负数的情况，不好处理。从大到小就保证了 $k$ 值为正数。

------------

最后说一下几个坑点：

- $n=1$ 要特判。
- 因为转移的贡献有正有负，所以超出上限 $L$ 的状态也可能对最终答案有贡献，需要保留，实测将上限开到 $8\times L$ 就差不多了，因此不能开 `long long`，可能会爆空间。
- 笔者人傻常数大，记得开 O2


------------

$\texttt{Code}$：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define db double
#define il inline
#define re register
#define INF 0x3f3f3f3f
#define LINF 0x3f3f3f3f3f3f3f3f
#define pii pair<int,int>
#define mp make_pair
#define F(i,a,b) for(re int (i)=(a);(i)<=(b);(i)++)
#define DF(i,a,b) for(re int (i)=(a);(i)>=(b);(i)--)
#define G(i,u) for(re int (i)=head[u];(i);(i)=nxt[(i)])
inline ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}return x*f;}
const int N=110,L=8010,p=1e9+7;
int n,l;
int a[N];
int dp[N][N][L][3];
il bool cmp(int x,int y){return x>y;}
il void add(int &x,int y){x=(x+y)>=p?x+y-p:x+y;}
signed main()
{
	n=read(),l=read();
	if(n==1)
	{
		putchar('1');
		return 0;
	}
	F(i,1,n) a[i]=read();
	sort(a+1,a+n+1,cmp);//必须从大到小排序，保证初始插入贡献为正，方便处理 
	dp[0][0][0][0]=1;
	F(i,1,n)
		F(j,1,i)
			F(k,0,8*l)//转移时可能超过上界 
				F(S,0,2)
				{
					if(S&&k>=a[i]) add(dp[i][j][k][S],1ll*dp[i-1][j-1][k-a[i]][S-1]*(3-S)%p);//新开一段 
					if(S&&k+a[i]<L) add(dp[i][j][k][S],1ll*dp[i-1][j][k+a[i]][S-1]*(3-S)%p);//插在一段上
					if(j>S&&k>=2*a[i]) add(dp[i][j][k][S],1ll*dp[i-1][j-1][k-2*a[i]][S]*(j-S)%p);//新开一段 
					if(k+2*a[i]<L) add(dp[i][j][k][S],1ll*dp[i-1][j+1][k+2*a[i]][S]*j%p);//合并两段 
					add(dp[i][j][k][S],1ll*dp[i-1][j][k][S]*(2*j-S)%p);//插在一段上 
				}
	int ans=0;
	F(i,0,l) ans=(ans+dp[n][1][i][2])%p;
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：MatrixGroup (赞：2)

## 题意

给定 $N$ 个互不相同的整数 $A_i$，请问有多少个 $A$ 的排列 $B$ 使得 $\sum\limits_{i=1}^{N-1}|B_i-B_{i+1}|\le L$。

$N\le 10^2,A_i,L\le 10^3$。

## 解法

绝对值问题很难处理，考虑将 $A$ 排序，从小到大插入，dp 记录目前有几个连续段。根据左右端点是否已占、是否左右与已有连续段不难计算 $A_i$ 对答案造成 $kA_i$ 的贡献，其中 $k=\{-2,-1,0,1,2\}$。这样当前贡献可能会有 $O(NA)$ 种，复杂度 $O(N^3A)$，无法通过。

只要让答案递增，当前贡献就只有 $O(L)$ 种。考虑将一个在 $L$ 处减少 $R$ 处增加的贡献转化为在 $(L,R]$ 中加入差分的贡献。这样复杂度就是 $O(N^2L)$ 的，可以通过。转移细节见代码。

## 相似题目

[Group Projects, \*2400](https://www.luogu.com.cn/problem/CF626F)

## 代码

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll mod2=1000000007;
int n,l,a[105],f;
ll dp[105][105][1005][2][2],answer;
int main()
{
	cin>>n>>l;
	for(int i=1;i<=n;++i) cin>>a[i];
	sort(a+1,a+n+1);
	if(n==1)
	{
		cout<<1<<endl;return 0;
	}
	dp[1][1][0][0][0]=dp[1][1][0][0][1]=dp[1][1][0][1][0]=1;
	for(int i=1;i<n;++i)
	{
		for(int j=1;j<=i;++j)
		{
			for(int k=0;k<=l;++k)
			{
				// 从 dp[i][j][k][0][0] 向后转移 
				f=k+2*j*(a[i+1]-a[i]);
				if(f<=l)
				{
					// 在最左点插入，与最左的连续段连接起来 
					dp[i+1][j][f][1][0]=(dp[i+1][j][f][1][0]+dp[i][j][k][0][0])%mod2;
					// 在最左点插入，自成一段 
					dp[i+1][j+1][f][1][0]=(dp[i+1][j+1][f][1][0]+dp[i][j][k][0][0])%mod2;
					// 在中间插入，自成一段 
					dp[i+1][j+1][f][0][0]=(dp[i+1][j+1][f][0][0]+(j+1)*dp[i][j][k][0][0])%mod2;
					// 在中间插入，在连续段的左端/右端连接 
					dp[i+1][j][f][0][0]=(dp[i+1][j][f][0][0]+2*j*dp[i][j][k][0][0])%mod2;
					// 在中间插入，连接两个连续段 
					dp[i+1][j-1][f][0][0]=(dp[i+1][j-1][f][0][0]+(j-1)*dp[i][j][k][0][0])%mod2;
					// 在最右点插入，与最左的连续段连接起来 
					dp[i+1][j][f][0][1]=(dp[i+1][j][f][0][1]+dp[i][j][k][0][0])%mod2;
					// 在最右点插入，自成一段
					dp[i+1][j+1][f][0][1]=(dp[i+1][j+1][f][0][1]+dp[i][j][k][0][0])%mod2;
				}
				f=k+(2*j-1)*(a[i+1]-a[i]);
				if(f<=l)
				{
					// 从 dp[i][j][k][0][1] 向后转移 
					// 在最左点插入，与最左的连续段连接起来 
					dp[i+1][j][f][1][1]=(dp[i+1][j][f][1][1]+dp[i][j][k][0][1])%mod2;
					// 在最左点插入，自成一段 
					dp[i+1][j+1][f][1][1]=(dp[i+1][j+1][f][1][1]+dp[i][j][k][0][1])%mod2;
					// 在中间插入，自成一段 
					dp[i+1][j+1][f][0][1]=(dp[i+1][j+1][f][0][1]+j*dp[i][j][k][0][1])%mod2;
					// 在中间插入，在连续段的左端/右端连接 
					dp[i+1][j][f][0][1]=(dp[i+1][j][f][0][1]+(2*j-1)*dp[i][j][k][0][1])%mod2;
					// 在中间插入，连接两个连续段 
					dp[i+1][j-1][f][0][1]=(dp[i+1][j-1][f][0][1]+(j-1)*dp[i][j][k][0][1])%mod2;
					// 从 dp[i][j][k][1][0] 向后转移 
					// 在最右点插入，与最左的连续段连接起来 
					dp[i+1][j][f][1][1]=(dp[i+1][j][f][1][1]+dp[i][j][k][1][0])%mod2;
					// 在最右点插入，自成一段
					dp[i+1][j+1][f][1][1]=(dp[i+1][j+1][f][1][1]+dp[i][j][k][1][0])%mod2;
					// 在中间插入，自成一段 
					dp[i+1][j+1][f][1][0]=(dp[i+1][j+1][f][1][0]+j*dp[i][j][k][1][0])%mod2;
					// 在中间插入，在连续段的左端/右端连接 
					dp[i+1][j][f][1][0]=(dp[i+1][j][f][1][0]+(2*j-1)*dp[i][j][k][1][0])%mod2;
					// 在中间插入，连接两个连续段 
					dp[i+1][j-1][f][1][0]=(dp[i+1][j-1][f][1][0]+(j-1)*dp[i][j][k][1][0])%mod2;
				}
				// 从 dp[i][j][k][1][1] 向后转移 
				f=k+2*(j-1)*(a[i+1]-a[i]);
				if(f<=l)
				{
					// 在中间插入，自成一段 
					dp[i+1][j+1][f][1][1]=(dp[i+1][j+1][f][1][1]+(j-1)*dp[i][j][k][1][1])%mod2;
					// 在中间插入，在连续段的左端/右端连接 
					dp[i+1][j][f][1][1]=(dp[i+1][j][f][1][1]+2*(j-1)*dp[i][j][k][1][1])%mod2;
					// 在中间插入，连接两个连续段 
					dp[i+1][j-1][f][1][1]=(dp[i+1][j-1][f][1][1]+(j-1)*dp[i][j][k][1][1])%mod2;
				}
			}
		}
	}
	for(int i=0;i<=l;++i) answer+=dp[n][1][i][1][1];
	cout<<answer%mod2<<endl;
	return 0;
}
```

---

## 作者：Forg1weN (赞：1)

## 题面


将互不相同的 $N$ 个整数 $A_1, A_2, \cdots, A_N$ 按照一定顺序排列。

假设排列为 $f_1, f_2, \cdots, f_N$，要求： $| f_1 - f_2| + | f_2 - f_3| + \cdots + | f_{N-1} - f_N| \leq L$。

求满足题意的排列的方案数对 $10^9+7$ 取模后的结果。

$1\le N\le 100$，$1\le L\le 1000$，$1\le A_i\le 1000$。

## Solution

先考虑去绝对值，若从小到大依次插入，就能把绝对值符号去掉。

要求出序列的形状显然不行，且填入的数字在序列内的位置未知，考虑插入DP。

一般而言，记 $f_{i,j,k}$ 为当前有 $i$ 个数字 $j$ 个连通块权值为 $k$ 的方案数，但这样设状态显然无法做，因为无法确定填入的数字是否为总序列的端点，端点要特殊考虑。

于是乎，记 $f_{i,j,k,t}$ 为当前有 $i$ 个数字 $j$ 个连通块权值为 $k$ 找到了 $t$ 个总序列的端点的方案数，其中 $t\in[0,2]$。

那么，由于是依次插入的，每插入一个数，前面的数字旁边相邻的数字便会相应增加，总贡献会增加若干倍 $x=a_i-a_{i-1}$。举个例子，现在有两个连通块 $K_1= \{a_1,a_2\}$ ，$K_2=\{a_3,a_4\}$。现在把 $a_5$ 填入，无论填入哪一个块，都会有 $a_5-a_4$ 的贡献，接着填入 $a_6$ 时，又会产生 $a_6-a_5$ 的贡献，相当于依次填入$a_5,a_6$ 的贡献 $a_6-a_5-(a_5-a_4)$。以此类推，根据这种差分思想，过程被极大简化了。

现在考虑转移。

插入一个块的两段，不能插入 $t$ 个顶点，有 $(2\times j-t)$ 种可能。

$f_{i,j,(2\times j -t)\times x +k,t}+=f_{i-1,j,k,t}\times (2\times j -t)$。

合并两个块，选择两个块之间的空位。

$f_{i,j,(2\times (j+1)-t)\times x +k,t}+=f_{i-1,j+1,k,t}\times j$。

单独成段，可以选择在任意一块的块头块尾，注意不能在已经闭口的首尾段。

$f_{i,j,(2\times (j-1)-t)\times x+k,t}+=f_{i-1,j-1,k,t}\times (j-t)$。

单独成闭口的边界段。

$f_{i,j,(2 \times (j-1)-(t-1))\times x+k,t}+=f_{i-1,j-1,k,t-1}\times(2-(t-1))$。

将当前数字连接到边界段上。

$f_{i,j,(2 \times j-(t-1))\times x +k,t}+=f_{i-1,j,k,t-1}\times (2-(t-1))$。

最后 $ans=\sum\limits_{i=0}^{l}f_{n,1,i,2}$。

注意，转移不一样，状态不一样，这里采用人人为我的转移，$k$ 的值由 $j$ 决定。

## code
```cpp
int main() {
	scanf("%lld%lld",&n,&l);
	for(LL i=1;i<=n;i++)scanf("%lld",&a[i]);
	sort(a+1,a+1+n);
	if(n==1) {
		printf("1");
		return 0;
	}
	f[0][0][0][0]=1;
	for(LL i=1;i<=n;i++) {
		for(LL j=1;j<=i;j++) {
			for(LL k=0;k<=l;k++) {
				for(LL t=0;t<=2;t++) {
					LL x=a[i]-a[i-1];
					//插入一段 
					if((2*j-t)*x+k<=l)
						(f[i][j][(2*j-t)*x+k][t]+=f[i-1][j  ][k][t]*(2*j-t))%=mod;
					//合并两段 
					if((2*(j+1)-t)*x+k<=l)
						(f[i][j][(2*(j+1)-t)*x+k][t]+=f[i-1][j+1][k][t]*j)%=mod;
					//单独成段 
					if((2*(j-1)-t)*x+k<=l)
						(f[i][j][(2*(j-1)-t)*x+k][t]+=f[i-1][j-1][k][t]*(j-t))%=mod;
					//单独成靠边界段
					if(t!=0)
					if((2*(j-1)-t+1)*x+k<=l)
						(f[i][j][(2*(j-1)-t+1)*x+k][t]+=f[i-1][j-1][k][t-1]*(3-t))%=mod;
					//将一段连到边界上
					if(t!=0)
					if((2*j-t+1)*x+k<=l)
						(f[i][j][(2*j-t+1)*x+k][t]+=f[i-1][j  ][k][t-1]*(3-t))%=mod; 
				}
			}
		}
	}	
	for(LL i=0;i<=l;i++)
		(ans+=f[n][1][i][2])%=mod;
	printf("%lld",ans);
	return 0;
}
```

---


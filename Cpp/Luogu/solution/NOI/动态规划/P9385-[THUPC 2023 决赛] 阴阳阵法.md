# [THUPC 2023 决赛] 阴阳阵法

## 题目背景

“余于久远之书，见一阴阳阵，必可助君征服九州。用此阵，须出诸阴阳大将。所谓阴将者，武勇而玉恶；所谓阳将者，善谋时且忠厚。凡阴阳阵，各将皆须择一将，以通之。又有两法皆牢记，不可即弱阵：一曰阴援阴，易激性情，或避之；二曰援与环，环阴与阳同，守以衡……”

正当你准备征服九州时，你仿佛听见一个熟悉的声音在远处喊：“工作的时候不准睡觉，你这样会被开除的……”你终于回过神来，发现你的 XCPC 队友在旁边熟练地拧着螺丝，流水线前已经漏过几个不合格的工品。刚刚什么都没发生啊，你哀叹道，但是……

## 题目描述

有一张图，图上有 $n$ 个白点和 $m$ 个黑点。白点之间两两不同，黑点之间两两不同。

每个节点有一条出边，每个节点出边指向的节点可以在 $n+m$ 个节点中任意选择。

此时共有 $(n+m)^{n+m}$ 个方案，每个方案是一个有向基环树森林。

称一个方案是好的当且仅当其满足以下条件：

- 任何一个黑点都指向一个白点，
- 每个环上的黑点数量和白点数量的乘积是偶数。

你需要求出所有方案中好的方案数量，对输入模数 $P$ 取模。

## 说明/提示

### 样例 1 解释

考虑黑点必须连向白点的限制共有 $3 \times 3 \times 2 = 18$ 种方案，其中一个黑点和一个白点构成一个环的方案非法。选择一个白点和黑点构成环的方案数为 $2$，剩下的一个白点有三种方案，因此非法的方案数为 $2 \times 3 = 6$，答案为 $18-6=12$。

### 数据规模与约定

对于所有测试数据，$1 \le n,m \le 2000$，$1 \le P \le 10^9$。

### 提示

你可能需要注意常数对算法效率产生的影响。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。

## 样例 #1

### 输入

```
2 1 1000000
```

### 输出

```
12
```

## 样例 #2

### 输入

```
8 8 8888888
```

### 输出

```
2973992
```

## 样例 #3

### 输入

```
1000 1000 123456789
```

### 输出

```
55105667
```

# 题解

## 作者：Aleph1022 (赞：13)

抄一个 EI 做法。  
其实我在赛场上就是这么想的，但是因为一些原因推错了，然后直到比赛结束也没改对……  
~~痛失首杀（？）~~

经常用多元 Lagrange 反演的同学都知道，这个题很能多元 Lagrange 反演。用 $x, y$ 计量白、黑点，$W, B$ 计量根为白、黑点的树，立刻有方程

$$
\begin{cases}
W = x \exp(W+B) \\
B = y \exp W
\end{cases}
$$

然后考虑环。我们知道一个任意的环是

$$
\ln \frac1{1-BW-W}
$$

$B, W$ 均出现奇数次的情况是

$$
\frac14\ln \frac{(1+BW)^2-W^2}{(1-BW)^2-W^2}
$$

上式减下式再 $\exp$ 可得

$$
\frac1{1-BW-W} \left(\frac{(1-BW)^2-W^2}{(1+BW)^2-W^2}\right)^{1/4}
$$

我们要求其 $\left[\frac{x^ny^m}{n!m!}\right]$，施多元 Lagrange 反演得

$$
\left[\frac{x^ny^m}{n!m!}\right]\left(\frac{(1-xy)^2-y^2}{(1+xy)^2-y^2}\right)^{1/4}\mathrm e^{(n+m)x+ny}
$$

欲有 $O(nm)$ 做法，只需先求出 $\left(\frac{(1-xy)^2-y^2}{(1+xy)^2-y^2}\right)^{1/4}$ 的系数，且其微分方程是容易得到的。

记 $a_n(y) = \left[\frac{x^n}{n!}\right]\left(\frac{(1-xy)^2-y^2}{(1+xy)^2-y^2}\right)^{1/4}$，我们有递推式

$$
\begin{aligned}
a_n =& -ya_{n-1} \\
& +2(n-1)(n-2)(1+y^2) a_{n-2} \\
& -(n-1)(n-2)y(1-y^2) a_{n-3} \\
& -(n-1)(n-2)(n-3)(n-4)(1-y^2)^2 a_{n-4}
\end{aligned}
$$

---

## 作者：Rainbow_qwq (赞：9)

大概出题人是对着 idea 出的题，所以正着想很难。

类似强连通分量耳分解的思想。我们每次钦定从编号最小、并且没定出边的点开始（有白点则为最小的白点，否则为最小的黑点，这里钦定了标号所以不用乘系数），一路确定出边，并最终到达一个定过出边的点（新加了一条链）或形成新的连通块（新加了一个 $ρ$ 型，一条杆一个环）。

设 $f_{i,j}$ 表示已经扩展了若干轮，用了 $i$ 个白点和 $j$ 个黑点。

类似 dp 分步转移的思想，每次从当前状态新加一个点作为转移，或者结束这一轮加点（转移到 $f$）。

设 $g_{i,j,0/1,0/1}$ 表示正在加一条链，记录钦定链末尾的颜色以及当前点的颜色。

设 $h_{i,j,0/1}$ 表示正在加一个 $ρ$ 型的杆，记录当前点颜色。

设 $l_{i,j,0/1,0/1,0/1,0/1}$ 表示正在加一个 $ρ$ 型的环，记录环末尾的颜色，当前点颜色，环上的白点个数奇偶性，环上的黑点个数奇偶性。

然后讨论一下转移就好了，就是枚举下一个加的点的颜色，从 $g$ 转移到 $g/f$，从 $h$ 转移到 $h/l$，从 $l$ 转移到 $l/f$，从 $f$ 转移到 $g/h$。具体转移可以见代码。

时间复杂度 $O(nm)$。

```cpp
#define N 2005
#define inf 0x3f3f3f3f

int n,m;
modint f[N][N],g[N][N][2][2],h[N][N][2],l[N][N][2][2][2][2];

signed main()
{
	n=read(),m=read(),mod=read();
	f[0][0]=1;
	// g(i,j,结束col,当前col)
	// h(i,j,当前col)
	// l(i,j,结束col,当前col,white sum,black sum)
	For(i,0,n)
		For(j,0,m){
			
			For(x,0,1)For(y,0,1){
				if(!(x&&y)) f[i][j]+=g[i][j][x][y];
				For(z,0,1)
					if(!(y&&z)) g[i+(!z)][j+z][x][z]+=g[i][j][x][y]*(z?(m-j):(n-i));
			}
			For(y,0,1){
				if(!h[i][j][y].x)continue;
				For(z,0,1)
					if(!(y&&z)) h[i+(!z)][j+z][z]+=h[i][j][y]*(z?(m-j):(n-i));
				l[i][j][y][y][!y][y]+=h[i][j][y];
			}
			For(a,0,1)For(b,0,1)For(c,0,1)For(d,0,1){
				if(!l[i][j][a][b][c][d].x)continue;
				if((!(a&&b)) && (!(c&&d))) f[i][j]+=l[i][j][a][b][c][d];
				For(z,0,1)
					if(!(b&&z)) l[i+(!z)][j+z][a][z][c^(!z)][d^z]+=l[i][j][a][b][c][d]*(z?(m-j):(n-i));
			}
			if(i!=n){
				g[i+1][j][0][0]+=f[i][j]*i;
				g[i+1][j][1][0]+=f[i][j]*j;
				h[i+1][j][0]+=f[i][j]; 
			}else{
				g[i][j+1][0][1]+=f[i][j]*i;
				g[i][j+1][1][1]+=f[i][j]*j;
				h[i][j+1][1]+=f[i][j];
			}
		}
	modint res=f[n][m];
	cout<<res.x;
	return 0;
}
```

---


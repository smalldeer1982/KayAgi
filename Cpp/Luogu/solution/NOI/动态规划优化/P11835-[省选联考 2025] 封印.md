# [省选联考 2025] 封印

## 题目描述

在一次探险中，小 H 发现了一个古老的封印。封印的本体是一个长度为 $n$ 的序列 $A = [a_1, a_2, \ldots, a_n]$。初始，每个元素都是 1 至 $m$ 间的正整数。

设 $|A|$ 表示序列 $A$ 的长度，小 H 可以对序列进行以下修改:
1. 选择序列 $A$ 的某个**严格**前缀最大值元素 $a_s$，即选择 $1 \leq s \leq |A|$ 满足 $\forall 1 \leq j < s, a_s > a_j$，特别地，$a_1$ 总是序列 $A$ 的严格前缀最大值;
2. 若 $a_s \neq 1$，将 $(a_s - 1)$ 插入序列 $A$ 的尾端;
3. 删去序列 $A$ 的前 $s$ 个元素。

考虑如下例子：在 $A = [1, 3, 2, 3, 4]$ 时，
- 小 H 可以选择 $s = 1$，此时修改后的序列变为 $[3, 2, 3, 4]$;
- 小 H 可以选择 $s = 2$，此时修改后的序列变为 $[2, 3, 4, 2]$;
- 小 H 不能选择 $s = 4$，因为 $a_2 = a_4 = 3$，这意味着 $a_4$ 并非严格前缀最大值。

小 H 可以进行任意多次修改操作，也可以不进行任何修改。为了解开封印，小 H 想知道：通过以上修改操作，他可以得到多少种不同的非空序列。

认为两个序列 $A = [a_1, \ldots, a_n]$ 和 $B = [b_1, \ldots, b_m]$ 不同，当且仅当 $n \neq m$ 或 $\exists 1 \leq i \leq \min\{n, m\}$，$a_i \neq b_i$。

由于答案可能很大，你只需告诉小 H 答案对 $998\,244\,353$ 取模后的结果。

## 说明/提示

**【样例 1 解释】**

该组样例共有 4 组测试数据。
- 对于第一组测试数据，可以通过修改得到的非空序列有 $[1, 2, 1]$，$[2, 1]$，$[1, 1]$，$[1]$。
- 对于第二组测试数据，可以通过修改操作得到的非空序列有 $[3, 1, 2, 1]$，$[1, 2, 1, 2]$，$[2, 1, 2]$，$[1, 2, 1]$，$[2, 1]$，$[1, 1]$，$[1]$。

**【样例 3】**

见选手目录下的 `seal/seal3.in` 与 `seal/seal3.ans`。

该组样例满足测试点 3 ~ 5 的限制。

**【样例 4】**

见选手目录下的 `seal/seal4.in` 与 `seal/seal4.ans`。

该组样例满足测试点 10 的限制。

**【样例 5】**

见选手目录下的 `seal/seal5.in` 与 `seal/seal5.ans`。

该组样例满足测试点 11 ~ 14 的限制。

**【样例 6】**

见选手目录下的 `seal/seal6.in` 与 `seal/seal6.ans`。

该组样例满足测试点 15 的限制。

**【样例 7】**

见选手目录下的 `seal/seal7.in` 与 `seal/seal7.ans`。

该组样例满足测试点 17 ~ 19 的限制。

**【样例 8】**

见选手目录下的 `seal/seal8.in` 与 `seal/seal8.ans`。

该组样例满足测试点 22 ~ 25 的限制。

**【子任务】**

对于所有测试点，
- $1\leq T\leq 10$，
- $1\leq n,m\leq 2500$，
- $\forall 1\leq i\leq n$，$1\leq a_i\leq m$。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | $m \leq$ | 特殊性质 |
|:------------:|:------------:|:------------:|:----------:|
| $1, 2$ | $10$ | $10$ | 无 |
| $3 \sim 5$ | $18$ | $70$ | ^ |
| $6$ | ^ | ^ | A |
| $7, 8$ | ^ | ^ | AB |
| $9$ | $70$ | ^ | A |
| $10$ | ^ | ^ | AB |
| $11 \sim 14$ | ^ | ^ | 无 |
| $15$ | $300$ | $300$ | A |
| $16$ | ^ | ^ | AB |
| $17 \sim 19$ | ^ | ^ | 无 |
| $20$ | $2\,500$ | $2\,500$ | A |
| $21$ | ^ | ^ | AB |
| $22 \sim 25$ | ^ | ^ | 无 |

- 特殊性质 A：$\forall 1 \leq i < j \leq n, a_i \neq a_j$。
- 特殊性质 B：$\forall 1 \leq i < n, a_i < a_{i+1}$。

## 样例 #1

### 输入

```
0 4
3 2
1 2 1
4 3
3 1 2 1
5 4
1 3 2 3 4
7 5
4 4 5 2 3 3 1```

### 输出

```
4
7
20
59```

## 样例 #2

### 输入

```
0 2
11 10
8 8 8 9 9 8 8 9 9 9 8
12 2500
1529 1470 1361 1416 1492 1503 1641 1868 1829 1959 2052 2105```

### 输出

```
694
4961744```

# 题解

## 作者：隔壁泞2的如心 (赞：33)

> 完蛋了 我被封印了 功力只剩一成

这题最重要的一步在于——

![](https://cdn.luogu.com.cn/upload/image_hosting/vv8mbhpz.png)

不妨令 $m$ 为整个数列的最大值。称所有 $m$ 以及最后一个 $m$ 后的所有 $m-1$ 所在的位置为**关键的**，即图中红框内的数。我们发现，无论如何操作，**关键的**位置数量永远不会变化，除非这些位置上的数一直被删到了 $0$。

同时，我们可以发现，给定一个经过一系列操作的数列，那么它的每个关键位置在原数列的位置是可以被计算出来的。也就是说，这些关键位置虽然值可能相同，但它们其实是可以被视为是**两两不同**的！这样，我们成功回避了此题的去重灾难。

——这大概就是这题的封印。如果没注意到这一步却强行做这题会导致你指望着自动机上 dp、功力只剩一成、余生在阿巴阿巴中度过……

接下来先考虑两个关键位置之间的数被移到后面之后，后面留下来的数应该是这个前缀整体 $-1$ 的一个子序列。可并非所有的子序列都满足条件。我们可以发现，如果在上图中给每个数向其左边的第一个不小于它的数连边，则会连成一棵树。那么如果一个数被留下来，则它在这棵树上的父亲也一定会留下来。同时，由于一个数的每个儿子的数值都是不同的，因此凡是满足上述条件的子序列都**一定是满足条件且两两不同的**！

这样的话，当这个数列已经被操作过一整轮之后，任意两个关键位置之间的数都是可以按照上述规则独立选取的！所以我们可以对于每个关键位置和整数 $h$ 求出“在它到下一个关键位置间的区域选取数，且被选的数不小于 $h$ ”的方案数。这个方案可以直接 dp 算出，再以 $O(nm)$ 的时间复杂度合并答案就可以啦！

可是，这个做法面临着很多很多的细节……比如说在数列未被操作完一整轮时，有些关键位置间的数是没被操作过的，所以这里要特别处理一下。

为了方便考虑，我们把原数组不断地整体减一、删去 $0$ 再接到原数组后面。

![](https://cdn.luogu.com.cn/upload/image_hosting/qpx2awq6.png)

我的代码里分了三个阶段计数。稍微详细地说一下吧（

- 第一个阶段对应图中蓝色的区域，此时原数列中还有数没被删除过，对于每个 $1 \le i \le n-1$ 算出“原数组的前 $i$ 个数已被挪到了后面，而后 $n-i$ 个数未被操作过时可以生成数列的种数”。

- 第三个阶段对应图中紫色的区域，第一个关键位置已经第二次被操作，这时所有关键位置独立且等价。有一个关键位置之后的数会跨过数列首尾，其他的关键未知间的数可以随便选。这里我枚举了新数列的结尾是在原数列的哪个关键位置后，然后用 dp 对这个关键位置求出“它到下一个关键位置间的区域选取数，且额外标记一个被选的数，被选的数不小于 $h-1$，被标记的数及其之前的被选的数不小于 $h$”的方案数。这个被标记的数就是被钦定的数组结尾。

- 第二阶段作为过渡，对于最后一个关键位置到第二次出现的第一个关键位置之间的选数方案进行统计，这里的做法和第三阶段类似，不过这里被钦定的数组结尾的下标必须不小于 $n$。

- 需要注意原数组以 $2$ 开头、以 $1$ 结尾的特殊情况，就是这个情况把两篇题解都卡掉了。由于 $1$ 无法被挪到后面，会被直接删除，所以按照这个方法会出现算重的情况。我的处理方法是将第二阶段提前到原数组的最后一个非 $1$ 位置，这样避免了跨阶段处理连续的 $1$ ，就可以通过了（

这是代码：


```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define int long long
#define FSIZ 407693
#define add(a,b) (a+=(b),a>=mod?a-=mod:0)
#define neg(x) ((x)&1?mod-1:1)
#define Q(a,b) C((a)+(b)-1,(b)-1)
#define cond(a,b)((a)?(b):0)
using namespace std;
int fac[FSIZ],ifac[FSIZ],inv[FSIZ];
int C(int n1,int m1){
    if(m1<0||m1>n1)return 0;
    return fac[n1]*ifac[m1]%mod*ifac[n1-m1]%mod;
}
inline int qpow(int n1,int n2){
    int n3=n1,n4=1;
    while(n2){
        if(n2&1)n4*=n3,n4%=mod;
        n3*=n3,n3%=mod;n2>>=1;
    }return n4;
}
inline int mut(initializer_list<int> arg){
	int ret=1;
	for(auto i:arg)ret*=i,ret%=mod;
	return ret;
}
int c,t,n,m;
int a[5016],icp[5016],pci[5016],dp0[5016],dp1[5016][2][2],fa0[5016],ins[5016],dp[5016][2600][2],pfmut[2600][2600],sfmut[2600][2600];
int sta[5016],tp=0;
vector<int> sn[5016];
void recurupd(int now){
    dp0[now]=1;
    for(auto to:sn[now])dp0[now]=dp0[now]*(dp0[to]+(!(ins[to]||a[to]==1)))%mod;
    if(now==0)return;
    recurupd(fa0[now]);
}
signed main(){
    fac[0]=1;for(int i=1;i<=FSIZ-1;i++)fac[i]=fac[i-1]*i%mod;
    ifac[FSIZ-1]=qpow(fac[FSIZ-1],mod-2);for(int i=FSIZ-1;i>=1;i--)ifac[i-1]=ifac[i]*i%mod;
    inv[0]=0;for(int i=1;i<=FSIZ-1;i++)inv[i]=ifac[i]*fac[i-1]%mod;
    scanf("%lld%lld",&c,&t);
    while(t--){
        memset(a,0,sizeof(a));memset(icp,0,sizeof(icp));memset(pci,0,sizeof(pci));
        memset(dp0,0,sizeof(dp0));memset(dp1,0,sizeof(dp1));memset(ins,0,sizeof(ins));
        memset(dp,0,sizeof(dp));memset(pfmut,0,sizeof(pfmut));memset(sfmut,0,sizeof(sfmut));
        memset(fa0,0,sizeof(fa0));
        for(int i=0;i<=5010;i++)sn[i].clear(),sn[i].shrink_to_fit();
        scanf("%lld%lld",&n,&m);m=0;
        for(int i=1;i<=n;i++)scanf("%lld",a+i);
        for(int i=1;i<=n;i++)m=max(m,a[i]);
        if(m==1){
            printf("%lld\n",n);
            continue;
        }
        int lasp=0,pcc=0,coef=0;
        for(int i=1;i<=n;i++){
            if(a[i]==m){
                lasp=i;icp[i]=1;pci[++pcc]=i;
            }
        }
        coef=pcc;
        for(int i=lasp+1;i<=n;i++){
            if(a[i]==m-1){
                icp[i]=1;pci[++pcc]=i;
            }
        }
        //for(int i=1;i<=pcc;i++)printf("%lld ",pci[i]);printf("!!!!\n");
        int n0=n;while(a[n]==1)n--;
        for(int i=1;!icp[i];i++){
            a[++n0]=a[i]-1;
        }
        int ans=0;
        //第一阶段
        tp=0;dp0[0]=1;a[0]=m+1;sta[++tp]=0;ins[0]=1;
        for(int i=1;i<=n0;i++){
            int pop0=sta[tp];
            while(tp&&a[sta[tp]]<a[i])ins[sta[tp--]]=0;
            if(!ins[pop0])recurupd(pop0);
            fa0[i]=sta[tp];ins[sta[++tp]=i]=1;
            sn[fa0[i]].push_back(i);
            dp0[i]=1;
            recurupd(fa0[i]);
            //printf("*%lld %lld\n",fa0[i],dp0[0]);
            if(i<n)add(ans,dp0[0]);
        }
        //printf("solve0:%lld\n",ans);
        //第二阶段
        for(int i=1;i<=n0;i++)reverse(sn[i].begin(),sn[i].end());
        for(int i=n0;i>=pci[1];i--){
            if(a[i]==0)continue;
            if(a[i]==1){
                dp1[i][0][1]=1;
            }
            else{
                dp1[i][0][0]=1;
            }
            for(auto to:sn[i]){
                dp1[i][1][1]=dp1[i][1][1]*(dp1[to][0][0]+1)%mod;
                dp1[i][1][0]=dp1[i][1][0]*(dp1[to][0][0]+1)%mod;
                add(dp1[i][1][1],dp1[i][0][1]*(dp1[to][1][0]+dp1[to][1][1])%mod);
                add(dp1[i][1][1],dp1[i][0][0]*dp1[to][1][1]%mod);
                add(dp1[i][1][0],dp1[i][0][0]*dp1[to][1][0]%mod);
                dp1[i][0][1]=dp1[i][0][1]*(dp1[to][0][1]+dp1[to][0][0]+1)%mod;
                add(dp1[i][0][1],dp1[i][0][0]*dp1[to][0][1]%mod);
                dp1[i][0][0]=dp1[i][0][0]*(dp1[to][0][0]+1)%mod;
            }
            if(i>=n&&a[i]>1){
                add(dp1[i][1][1],dp1[i][0][1]);
                add(dp1[i][1][0],dp1[i][0][0]);
            }
            //printf("#1 %lld:%lld %lld %lld %lld",i,dp1[i][0][0],dp1[i][0][1],dp1[i][1][0],dp1[i][1][1]);printf("\n");
        }
        add(ans,(dp1[pci[1]][1][0]+dp1[pci[1]][1][1])%mod);
        //printf("solve1:%lld\n",ans);
        //第三阶段
        for(int i=n0;i>=pci[1];i--){
            //printf("%lld:",i);
            //for(auto to:sn[i])printf("%lld ",to);printf("\n");
            for(int j=0;j<=a[i];j++){
                dp[i][j][0]=1;
            }
            for(auto to:sn[i]){
                if(icp[to])continue;
                for(int j=0;j<=a[to];j++){
                    dp[i][j][1]=dp[i][j][1]*(dp[to][j][0]+1)%mod;
                }
                for(int j=0;j<a[to];j++){
                    add(dp[i][j+1][1],dp[i][j][0]*dp[to][j+1][1]%mod);
                }
                for(int j=0;j<=a[to];j++){
                    dp[i][j][0]=dp[i][j][0]*(dp[to][j][0]+1)%mod;
                }
            }
            for(int j=0;j<a[i];j++){
                add(dp[i][j+1][1],dp[i][j][0]);
            }
        }
        for(int i=0;i<=m;i++){
            pfmut[0][i]=1;
            for(int j=1;j<=pcc;j++){
                pfmut[j][i]=pfmut[j-1][i]*dp[pci[j]][i][0]%mod;
            }
            sfmut[pcc+1][i]=1;
            for(int j=pcc;j>=1;j--){
                sfmut[j][i]=sfmut[j+1][i]*dp[pci[j]][i][0]%mod;
            }
            //for(int j=1;j<=pcc;j++)printf("(%lld,%lld) ",dp[pci[j]][i][0],dp[pci[j]][i][1]);printf("\n");
            //for(int j=1;j<=pcc;j++)printf("[%lld,%lld] ",pfmut[j][i],sfmut[j][i]);printf("\n");
        }
        for(int val0=0;val0<=m;val0++){
            for(int i=1;i<=pcc;i++){
                add(ans,mut({pfmut[i-1][val0+3],sfmut[i+1][val0+2],dp[pci[i]][val0+3][1]}));
                //printf("#n %lld:%lld\n",val0,mut({pfmut[i-1][val0+3],sfmut[i+1][val0+2],dp[pci[i]][val0+3][1]}));
            }
        }
        //printf("%lld\n",ans);
        if(m>2)printf("%lld\n",(ans+pcc)%mod);
        else printf("%lld\n",(ans+coef)%mod);
    }
}
/*
10 1
3 10
2 10 1
*/
*/
```

抱歉……我知道我完全没讲明白。我原本真的很想好好写这篇题解的，可是我看到另一篇题解里 1k 的代码之后我一下子就布响丸辣！事实上注意到“关键位置”之后这道题对于绝大多数选手而言都是可做的了，而在细节上大家一定都有比我更好的实现（

~~需要注意民间数据里没有 $m$ 较小的情况，所以这个做法可能会被正式数据卡，到时候再说吧（~~

这道题确实很有意思，但它的细节也是真的多。对于我这种做题全靠猜的人来说这道题简直像神一样，是不可战胜的……

其实“梦想”和“兴趣”之间完全可以是没有关系的。也许梦想会被现实破碎，但只要兴趣还在，你随时可以回来。不管你的梦想和兴趣在哪，祝你旅途愉快，愿你一路顺风。

---

## 作者：Nightingale_OI (赞：28)

场上拼尽全力口胡出 $O(n^6)\to O(n^4)$ 还没调完，出来发现 DP 优化简直唐到没边。大败而归。

upd 2025.3.8：

修改了第一轮特殊 DP 的定义问题和代码问题。

原代码会恰好在 $a_1=2,a_n=1$ 的情况被卡掉，获得 88 分。官方数据还是太超模了。

upd 2025.3.14

修改了第一轮特殊 DP 的代码问题。

hack 数据 `2 2 4 1 1`（感谢@[Acoipp](https://www.luogu.com.cn/user/674469)）。

upd 2925.3.24

非严格前缀最大值 $\to$ 非严格后缀最大值（感谢@[1795MiB](https://www.luogu.com.cn/user/250810)）。

---

在一次操作中，如果当前序列 $A$ 的开头是 $1$，我们可以删除这个 $1$，但是我们看成找到第一个不是 $1$ 的位置 $A_p$（如果找不到说明 $A$ 全是 $1$，最后特判掉），删除位置在 $A_{p-1}$ 的这个 $1$。

虽然表面上它们的结果是一样的，但是这会方便我们后续的刻画。

最好把 $\max(a_i)\leq 2$ 特判掉防止一些边界情况。

---

我们将 $a$ 序列扩展 $m$ 次，并在开头增加 $a_n+1$，成如下形式：

$$(a_n+1),a_1,a_2,\dots a_{n-1},a_n,(a_1-1),\dots,(a_n-1),(a_1-2),\dots,(a_n-m)$$

**钦定新的 $a$ 序列下标从 $0$ 开始**，即 $a_0=a_n+1$（事实上 $a_0$ 的取值没有意义）。

$a$ 序列一个显然的性质是 $a_i-1=a_{i+n}$。

对于一个任意的序列 $a_{1\sim k}$，其每个前缀 $a_{[1,i]}$ 的**非严格后缀最大值**序列互不相同。

结合 $a_i-1=a_{i+n}$，我们可以证明 $a_{[i+1,i+n]}$ 的**非严格后缀最大值**序列互不相同。

后面会用到这个性质。证明不难但是不好写。~~请读者把它当做一个练习~~。

---

观察最终的序列 $b$ 可能形如什么样子。

选出若干下标 $0\leq p_1<p_2<p_3<\dots<p_k$，满足：

1. $p_1+n=p_k$。
2. $a_{p_i}>0$。
3. $\forall p_{i-1}<j<p_i,a_j<a_{p_i}$。

最终得到 $b=[a_{p_2},a_{p_3},\dots,a_{p_n}]$，注意这里的下标从 $2$ 开始。

例如 $a=[1,3,2,3,4]$，新 $a=[5,1,3,2,3,4,0,2,1,2,3,\dots]$。选择 $p=[4,5,7,9]$ 可得到 $b=[4,2,2]$。

这样的刻画会有什么问题呢？

首先会遗漏 $b=[1,1,\dots,1,1]$ 的情况，最后加上即可。

对于 $p_1<n$ 的情况，会出现一些无法到达的情况。

如 $a=[1,2,3,4]$，新 $a=[5,1,2,3,4,0,1,2,3,\dots]$，但是 $p=[2,4,6],b=[4,1]$ 是不合法的。

也就是说，我们还需要钦定 $\forall p_i<n,p_i+1=p_{i+1}$。吗？

然而，这样会遗漏从开头删除若干个 $1$ 的情况，如 $a=[1,1,4]$，新 $a=[5,1,1,4,0,0,3]$，选择 $p=[0,3],b=[4]$ 是合法的。或者选择 $p=[0,1,3],b=[1,4]$ 是合法的。

由于我们将删除 $1$ 看成从连续段的末尾删除，所以最终的限制如下：

1. $p_1+n=p_k$。
2. $a_{p_i}>0$。
3. $\forall p_{i-1}<j<p_i,a_j<a_{p_i}$。
4. $\forall p_i<n$ 若 $p_i+1<p_{i+1}$，设 $k$ 是最小满足 $p_i<k,a_k>1$ 的位置，则有：$\forall 1<j\leq i,a_{p_i}=1$ 且（$p_{i+1}=k$ 或 $k>n$）。

这个限制 $4$ 比较复杂，其实是 $\forall p_i<n$，$p_{i+1}$ 需要满足下三者之一（$k$ 的意义同上）：
+ $p_i+1=p_{i+1}$。
+ $\forall 1<j\leq i,a_{p_i}=1$ 且 $k>n$。
+ $\forall 1<j\leq i,a_{p_i}=1$ 且 $p_{i+1}=k$。

---

这里证明由不同 $p_{1\sim k}$ 得到的 $b$ 是互不相同的。

先忽略限制 $2,4$，在更弱的限制下证明，则原限制也一定互不相同。

考虑由 $p_{1\sim k}$ 生成的 $b$ 和由 $q_{1\sim k}$ 生成的 $c$。

若 $p_1=q_1$：

当 $b=c$ 时，由于限制 $3$，一定有 $p_i=q_i$，即 $p=q$。

若 $p_1\neq q_1$：

设 $A_i$ 为 $a_{[i+1,i+n]}$ 的**非严格后缀最大值**序列，则 $A_i$ 互不相同。

还是由于限制 $3$：$A_{p_1}$ 一定是 $b$ 的**非严格后缀最大值**序列。$A_{q_1}$ 一定是 $c$ 的**非严格后缀最大值**序列。$p_1\neq q_1$ 时 $A_{p_1}\neq A_{q_1}$，则 $b\neq c$。

---

照着上面四条性质 DP 就可以获得一个多项式做法，复杂度在 $O(n^2)\sim O(n^6)$ 不等。

$0\leq p_1\leq n$ 的情况比较特殊，枚举 $p_1$ 然后 DP 即可（优化方式和后面的 $g$ 一致），单次 $O(n)$。

这部分的 DP 比较魔怔，建议写完了以后照着限制 $4$ 对一下。（非常不建议学习我代码中的写法）

对于剩下的部分，注意到 $p=[p_1,p_2,\dots,p_k]$ 满足限制 $3$ 当且仅当 $p'=[p_1+n,p_2+n,\dots p_k+n]$ 满足限制 $3$。

枚举 $k$，我们对所有满足限制 $3$ 且 $n<p_1\leq 2n$ 且 $\min(a_{p_i})=k$ 的序列 $p$ 计数，设这样的序列有 $f(k)$ 个，则它们对答案的贡献是 $k\times f(k)$。

这个枚举 $k$ 不好消掉，于是考虑枚举 $a_{p_i}$ 中最靠左的最小值位置 $x$，钦定它左边所有选择的位置 $>x$，右边所有选择的位置 $\geq x$。

设 $f_i$ 表示 $p_1=i$ 的方案数，$g_i$ 表示 $p_k=i$ 的方案数。

使用单调栈优化 DP 即可快速计算 $f$。

我们需要把单调栈转置过来快速计算 $g$。

单调栈优化 DP 可以看成 $f_i\to f_{l_i\sim i-1}$，所以转置可以看成 $g_i\leftarrow g_{l_i\sim i-1}$，前缀和维护即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define f(i,j,k) for(int i=j;i<=k;++i)
#define g(i,j,k) for(int i=j;i>=k;--i)
int n,m,s,l;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;'0'>ch||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;'0'<=ch&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
const int N=9999,mo=998244353;
int a[N],b[N],c[N],f[N],g[N],p,w;
inline void doing(){
	n=read();read();m=n*3;s=l=w=0;
	f(i,1,n)w=max(w,a[i]=read());
	if(w<2)return cout<<n<<"\n",void();
	f(i,1,n)if(a[i]==w)l=i;
	f(i,1,n)s+=(i<l&&a[i]==w)||(i>l&&a[i]==w-1&&w>2);//b=[1,1,...,1,1]的情况
	f(i,n+1,m)a[i]=a[i-n]-1;a[l=0]=N;
	g(i,m,0){//预处理单调栈
		while(l&&a[b[l]]<=a[i])c[b[l--]]=max(i-1,0ll);
		b[++l]=i;
	}
	f(x,0,n)if(a[x]>1){//0<=p1<=n的情况，枚举p1=x
		f(i,0,m)g[i]=b[i]=0;g[x]=1;
		g(i,m,x+1)if(a[i]!=1)l=i-1;
		f(i,x,m){
			if(i==l)g[i]=min(n,l)-x+1;//这里是一个非常魔怔的分讨（限制4，这样写比较短，相当于等效合并了一些转移）
			else if(i<=n)g[i]+=g[i-1];
			else g[i]+=a[i]<1?0:(b[i-1]-b[max(c[i],n-1)])%mo;
			b[i]=b[i-1]+g[i];
		}
		s=(s+g[x+n])%mo;
	}
	f(x,n+1,m)if((p=a[x])>0){//枚举x计算fi,gi
		f(i,0,m)f[i]=b[i]=0;f[x]=1;
		g(i,x,1){
			f[i]+=a[i]<=p?0:b[i]%mo;
			b[c[i]]-=f[i];b[i-1]+=b[i]+f[i];
		}
		f(i,0,m)g[i]=b[i]=0;g[x]=1;
		f(i,x,m){
			g[i]+=a[i]<p?0:(b[i-1]-b[c[i]])%mo;
			b[i]=b[i-1]+g[i];
		}
		f(i,1,n)s=(s+f[i+n]*g[i+n+n]%mo*p)%mo;
	}
	cout<<s<<"\n";
}
signed main(){
	// freopen("seal.in","r",stdin);
	// freopen("seal.out","w",stdout);
	int c=read(),t=read();
	while(t--)doing();
	return 0;
}
```

---

## 作者：H_W_Y (赞：20)

这道题疑似会 $\mathcal O(2^n n)$ 即会 $\mathcal O(n^2)$？

但是笔者太菜场上写了两个小时 $2^n$，最后喜提没有时间优化了（但是优化其实是显然的）。

以下的思路完全顺着场上的思路做下来的，有很大可能有很多地方都可以优化（场上没想清楚就一直在改）。



---



首先先把 $m \le 2$ 判掉，这一部分直接跑爆搜时间复杂度是对的（后面会说原因）。

我们认为第一轮操作表示操作若干个数直到下一次操作的是之前操作过的数，同理定义第二轮……

那么我们把计数过程分成两个部分：

- 第一轮到达的状态。
- 第二轮即之后到达的状态。

因为每一轮都会让我们的 $\max-1$，所以属于不同轮之间的状态一定不会重（不是很严谨）。

接下来都是先考虑 $\mathcal O(2^n \operatorname{poly} n)$ 做法，再进行简单优化得到 $\mathcal O(n^3) \sim \mathcal O(n^2)$ 的做法。



---



考虑 **第二轮即之后到达的状态**，发现显然我们可以把 $a_i=1$ 的去掉。

接下来考虑 $2^n$ 枚举子集 $S$，表示我们计数保留 $S$ 中的元素的方案数。

由于需要保留下 $S$，那么这个集合中每个元素都是从前面一个选中元素到这里的 **严格最大值**，并且第一个数还需要比最后一个数往后的数 $+1$ 还要大。

那么在没有删任何元素之前（也就是没有操作到 $1$），整轮的代价是 $(\min-2) \times |S|$。

现在考虑操作到当前这一轮，有一个元素会变成 $1$，假设它位于第 $i$ 个，则对答案的贡献就是 $i$（操作 $0 \sim i-1$ 次）。

反之在操作了第 $i$ 个之后，$S$ 这个集合就变化了，那么会被其他的集合计算到。

真的会计算到吗？

发现有 corner，也就是如果选出来的集合形如

```
2 1 1
```

就是不会被计算的。具体来说它们都形如 $\max,\max,\cdots,\max-1,\max-1$，因为当有一个 $1$ 被拿走之后，剩下的集合初始是不合法的。

所以这种东西还有一个额外的贡献 $|S|$。

综上，直接模拟出来就是（这里每一个 $S$ 的贡献都 $-1$，因为第二轮的初始状态是在第一轮的状态中计数了的）

~~场上代码，希望能看，有些地方因为场上太急了非常冗余。~~

```cpp
  int len=n;n=0;
  for(int i=1;i<=len;i++) if(a[i]>1) a[++n]=a[i];

  for(int S=1;S<(1<<n);S++){
  	int mx=0;bool fl=true;
  	for(int i=1;i<=n;i++){
  	  if(S>>(i-1)&1){
  	    if(mx>=a[i]){fl=false;break;}
		mx=0;	
	  }else mx=max(mx,a[i]);
	}
	if(mx) ++mx;
  	for(int i=1;i<=n;i++){
  	  if(S>>(i-1)&1){
  	    if(mx>=a[i]){fl=false;break;}
		mx=0;	
	  }else mx=max(mx,a[i]);
	}
	if(!fl) continue;
	
	int mn=m+1,id=0,ct=0;
	vector<int> V;
	for(int i=1;i<=n;i++) if((S>>(i-1))&1){
	  V.pb(a[i]);
	  if(a[i]<mn) mn=a[i],id=ct;
	  ++ct;
	}
	add(res,mul(mn-2,pc(S)));
	
	for(int i=id;i<(int)V.size();i=(i+1)%((int)V.size())){
	  if(V[i]!=mn){ct=i;break;}
	  if(i==(int)V.size()-1) ++mn;
	}
	add(res,(ct==id?(pc(S)-1):0)+id);
  }
```



---



考虑优化。

观察到上述贡献跟 $\min$ 的位置有关，和集合大小有关。

所以考虑枚举 $\min$ 的位置，并且将 $A$ 倍长使得 $a[i+n] = a[i]-1$（这样方便处理跨过 $n$ 的贡献）。

设当前认为第一个 $\min$ 的位置在 $id$，我们考虑将序列 $a[id \sim id+n]$ 拿出来 dp。

设 $g_i$ 表示选了 $i$ 这个位置的方案数，$f_i$ 表示选了 $i$ 这个位置的所有方案的目前 $(\min-2) \times |S|$ 之和 + 若 $i \gt n$ 有额外 $1$ 的贡献（也就是暴力中的 $id$）。

dp 时直接枚举上一个元素选什么即可。



---



而对于 $\max,\max,\cdots,\max-1,\max-1$ 的情况，发现我们一定会把所有的 $\max$ 选了并且把之后的 $\max-1$ 都选了，最后计算上这里的贡献就可以了。

以下 $\mathcal O(n^3)$ 实现，可以过 [96pts](https://www.luogu.com.cn/record/206314962)（拼上 AB 性质能过）。

``` cpp
  int len=n;n=0;
  for(int i=1;i<=len;i++) if(a[i]>1) a[++n]=a[i];
  for(int i=n+1;i<=2*n;i++) a[i]=a[i-n]-1;
  
  for(int id=1,cur=0;id<=n;id++){
  	for(int i=1;i<=2*n;i++) f[i]=g[i]=0;
  	g[id]=1,cur=a[id]-2;
  	for(int i=id+1;i<=id+n;i++) if(i==id+n||a[i]>=a[id]){
  	  for(int j=i-1,mx=0;j>=id;j--){
  	    if(a[i]<=mx) break;
		add(f[i],f[j]),add(g[i],g[j]);
		mx=max(mx,a[j]);	
	  }
  	  add(f[i],mul(cur,g[i]));
  	  if(i!=id+n&&i>n) add(f[i],g[i]);	  
	}
    add(res,f[id+n]);
  }
  
  for(int i=n,fl=0;i>=1;i--){
  	if(a[i]==m) fl=1,add(res,1);
  	else if(!fl&&a[i]==m-1) add(res,1);
  }
  del(res,1);
```



---



从 $\mathcal O(n^3) \to \mathcal O(n^2)$ 的优化显然，容易发现这里能转移的 $j$ 是一个后缀，于是直接用单调栈维护 + 前缀和优化即可。

于是这一部分时间复杂度 $\mathcal O(n^2)$。

```cpp
  int len=n;n=0;
  for(int i=1;i<=len;i++) if(a[i]>1) a[++n]=a[i];
  for(int i=n+1;i<=2*n;i++) a[i]=a[i-n]-1;
  
  for(int id=1,cur=0;id<=n;id++){
  	for(int i=1;i<=2*n;i++) f[i]=g[i]=sf[i]=sg[i]=0;
  	g[id]=sg[id]=1,cur=a[id]-2,st[tp=1]=id;
  	
  	for(int i=id+1;i<=id+n;i++){
  	  while(tp&&a[i]>a[st[tp]]) --tp;
	  if(i==id+n||a[i]>=a[id]){
  	    f[i]=dec(sf[i-1],sf[max(id,st[tp])-1]);
  	    g[i]=dec(sg[i-1],sg[max(id,st[tp])-1]);
  	    
  	    add(f[i],mul(cur,g[i]));
  	    if(i!=id+n&&i>n) add(f[i],g[i]);
	  }
	  st[++tp]=i;
      sf[i]=adc(sf[i-1],f[i]),sg[i]=adc(sg[i-1],g[i]);
	}
	add(res,f[id+n]);
  }
  
  for(int i=n,fl=0;i>=1;i--){
  	if(a[i]==m) fl=1,add(res,1);
  	else if(!fl&&a[i]==m-1) add(res,1);
  }
  del(res,1);
```



---



现在再来考虑 **第一轮能到达的状态**。

同样我们枚举操作集合 $S$，表示我们操作了这些数。

同样的，这个集合的每个元素都要是和前一个元素之间的严格最大值。

并且为了不算重，我们还有一些额外的限制：

- 如果操作了 $1$，那么后面一定不能再操作 $\gt 1$ 的元素。

  因为这个方案会被不操作 $1$ 的集合也统计到。

- 如果操作了序列末尾的 $1$，那么第一个操作的元素一定不是 $2$。

  考虑最终操作完之后留在序列前面的 $1$ 的个数，在开头操作 $2$ 是往里面 $+1$，在末尾操作 $1$ 是往里面 $-1$，这样一去一回抵消了就算重了。

（或许这里的这些 corner 就是我们需要特判 $m \le 2$ 的原因）

于是直接模拟上述过程得到如下代码

```cpp
  int res=0,ret=0;
  for(int i=n;i>=1;i--){
  	if(a[i]!=1) break;
  	++ret;
  }

  for(int S=0;S<(1<<n);S++){
  	int mx=0;bool fl=true,vis=false;
	for(int i=1;i<=n;i++){
      if(S>>(i-1)&1){
  	    if(mx>=a[i]){fl=false;break;}
		if(a[i]>1&&vis){fl=false;break;}
  	    vis|=a[i]==1;
	    mx=0;
	  }else mx=max(mx,a[i]);
	}
	if(!fl) continue;
	
	bool chk=0;
	for(int i=n;i>n-ret;i--) chk|=(S>>(i-1)&1);
	for(int i=1;i<=n;i++) if(S>>(i-1)&1){
	  chk&=a[i]==2;
	  break;
	}
	if(!chk) add(res,fl);
  }
```



---



这里的优化就变得容易了很多了，我们对前 $n-ret$ 个元素进行 dp。

设 $h_{i,0/1}$ 表示选了第 $i$ 个元素，第一个元素是否时 $2$ 的方案数。

直接做就是 $\mathcal O(n^2)$ 的，最后是否选后面 $ret$ 个 $1$，也就是带来 $h_{n-ret,0} \times ret$ 的贡献（容易发现 $n-ret$ 这个位置是一定要选的）。

```cpp
  int res=1,ret=0;
  for(int i=n;i>=1;i--) if(a[i]!=1){ret=n-i;break;}
  
  for(int i=0;i<=n;i++) h[i][0]=h[i][1]=0;
  h[0][0]=1;
  
  for(int i=1;i<=n-ret;i++){
  	for(int j=i-1,mx=0;j>=0;j--){
  	  if(a[i]<=mx) break;
  	  if(j==0){
  	    if(a[i]==2) add(h[i][1],1);
		else add(h[i][0],1);	
	  }else if(!(a[i]>1&&a[j]==1))
	  	for(int k:{0,1}) add(h[i][k],h[j][k]);
	  mx=max(mx,a[j]);
	}
    add(res,adc(h[i][0],h[i][1]));
  }
  add(res,mul(h[n-ret][0],ret));
```

注意需要记上初始状态，所以从 $res=1$ 开始。



---



这样就做完了，总时间复杂度 $\mathcal O(n^2)$。[代码](https://www.luogu.com.cn/record/206322889)。

想清楚其实很简单，但是我场上为什么写了两个小时暴力/ll/ll/ll

```cpp
#include <bits/stdc++.h>
using namespace std;
#define pb push_back

const int N=5005,H=998244353;
int n,m,a[N],f[N],g[N],h[N][2],sf[N],sg[N],tp=0,st[N];

int adc(int a,int b){return a+b>=H?a+b-H:a+b;}
int dec(int a,int b){return a<b?a-b+H:a-b;}
int mul(int a,int b){return 1ll*a*b%H;}
void add(int &a,int b){a=adc(a,b);}
void del(int &a,int b){a=dec(a,b);}

namespace BF{
  map<vector<int>,bool > mp;

  void dfs(vector<int> V){
    if(mp.count(V)) return;
    mp[V]=1;
  
    vector<int> nw;
    int mx=0;
    for(int i=0;i<(int)V.size();i++){
  	  if(V[i]>mx){
  	    nw.clear();
  	    for(int j=i+1;j<(int)V.size();j++) nw.pb(V[j]);
  	    if(V[i]>1) nw.pb(V[i]-1);
  	    dfs(nw);
	  }
	  mx=max(mx,V[i]);
    }
  }

  void SOLVE(){
    vector<int> V;
    for(int i=1;i<=n;i++) V.pb(a[i]);
    mp.clear(),dfs(V);
    cout<<((int)mp.size()-1)%H<<'\n';
  }
}

int pc(int x){return __builtin_popcount(x);}

void SOLVE(){
  cin>>n>>m;m=0;
  for(int i=1;i<=n;i++) cin>>a[i],m=max(m,a[i]);
  
  if(m<=2) return BF::SOLVE();
  
  int res=1,ret=0;
  for(int i=n;i>=1;i--) if(a[i]!=1){ret=n-i;break;}
  
  for(int i=0;i<=n;i++) h[i][0]=h[i][1]=0;
  h[0][0]=1;
  
  for(int i=1;i<=n-ret;i++){
  	for(int j=i-1,mx=0;j>=0;j--){
  	  if(a[i]<=mx) break;
  	  if(j==0){
  	    if(a[i]==2) add(h[i][1],1);
		else add(h[i][0],1);	
	  }else if(!(a[i]>1&&a[j]==1))
	  	for(int k:{0,1}) add(h[i][k],h[j][k]);
	  mx=max(mx,a[j]);
	}
    add(res,adc(h[i][0],h[i][1]));
  }
  add(res,mul(h[n-ret][0],ret));
  
  int len=n;n=0;
  for(int i=1;i<=len;i++) if(a[i]>1) a[++n]=a[i];
  for(int i=n+1;i<=2*n;i++) a[i]=a[i-n]-1;
  
  for(int id=1,cur=0;id<=n;id++){
  	for(int i=1;i<=2*n;i++) f[i]=g[i]=sf[i]=sg[i]=0;
  	g[id]=sg[id]=1,cur=a[id]-2,st[tp=1]=id;
  	
  	for(int i=id+1;i<=id+n;i++){
  	  while(tp&&a[i]>a[st[tp]]) --tp;
	  if(i==id+n||a[i]>=a[id]){
  	    f[i]=dec(sf[i-1],sf[max(id,st[tp])-1]);
  	    g[i]=dec(sg[i-1],sg[max(id,st[tp])-1]);
  	    
  	    add(f[i],mul(cur,g[i]));
  	    if(i!=id+n&&i>n) add(f[i],g[i]);
	  }
	  st[++tp]=i;
      sf[i]=adc(sf[i-1],f[i]),sg[i]=adc(sg[i-1],g[i]);
	}
	add(res,f[id+n]);
  }
  
  for(int i=n,fl=0;i>=1;i--){
  	if(a[i]==m) fl=1,add(res,1);
  	else if(!fl&&a[i]==m-1) add(res,1);
  }
  del(res,1);
  
  cout<<res<<'\n';
}

int main(){
//  freopen("seal.in","r",stdin);
//  freopen("seal.out","w",stdout);
  ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
  int cas,_;cin>>cas>>_;
  while(_--) SOLVE();
  return 0;
}
```

~~拿到了目前最优解（~~

---

## 作者：mRXxy0o0 (赞：6)

# D2T3

## 转化

考虑 $b$ 数组最终的形态。称全局最大值 $x$ 的位置、最后一个 $x$ 后面的所有 $x-1$ 为关键位置。那么所有状态可以划分成：必然包含关键位置、序列长度小于关键位置数且均为 $1$。

### Part 1.1

后一个好求，考虑前一个。我们考虑算没有前驱状态的状态的贡献。换而言之，一个序列不停操作第一个数且保证不删空，这样的序列是我们想一起计算的（贡献是什么待会再说）。我们称这样的状态中的元素是“被选择的”。现在要干的事是从初始 $a$ 中进行一些操作，使序列变成选择元素的循环置换。

- 若合法，从前往后操作一轮或一轮多一次可以得到选择元素的循环置换。

这个比较明显。可能多的这一次取决于 $a_n$ 选没选，没选会再操作一次其后面的元素。我们为了计数方便，钦定所有选法都需要一轮加一次。

于是给定选择元素的贡献就好表示了：$(v-2)len+Id_v-1$。$v$ 是选择序列中最靠左的最小值，$Id$ 是**选出来序列**的下标。

我们可以让 $i$ 和前面第一个 $a_j\ge a_i$ 的 $j$ 连边。注意可以循环连边，这时是 $a_j>a_i$。枚举最小值 $v$，然后就是一个树上问题了，根节点和 $v$ 必选，求所有选择方案 $siz$ 之和。求 $\sum Id_v-1$ 就只记入下标 $<pos_v$ 的就可以了。

式子是：$f'_u=f_ug_v+f_vg_u,g'_u=g_ug_v$。如果 $u$ 不是必选点，最后要加 $1$。

复杂度 $O(n^2)$。

### Part 1.2

注意到上面还没算没有进入循环的方案，换句话说没算最后一次操作位置 $\le n$ 的方案。

思路是钦定最后一个操作的位置来计数。

- 选 $1$ 后不再选 $>1$ 的数。

不这么干会算重。设 $p_i$ 表示 $i$ 前面第一个大于等于 $a_i$ 的数，据此列出 DP 式子。

$$f_i=\sum\limits_{p_i\le j<i} f_j[a_j\neq 1]$$

在 $a_1=2,a_n=1$ 且时会算重，原因是我们钦定了选 $1$ 后不再选 $>1$ 的数，可是 $a_1$ 转一圈接到 $a_n$ 后面的限制并没有刻画出来。

设 $[pr,n]$ 是末尾极长 $1$ 连续段，$[1,pl]$ 是开头极长 $a_i\le2,a_{pl}=2$ 连续段。

类似断环成链的 DP，我们枚举两种情况。

1. 不选两端这些 $1,2$。

从 $1$ 开始 DP 到 $pr-2$，答案加上每一位的 DP 值。

2. 选两端这些 $1,2$。

从 $pl+1$ 开始 DP 到 $pl$（循环移位），答案加上 $pr-1$ 及之后的 DP 值。原因是要选两端，$(pl,pr)$ 必然全部选择。

> 关于 $pl$ 的定义：不要忘了中间可以有 $1$，因为可以先删掉中间的这些 $1$，然后 $2$ 就可以继续往后面放了。

复杂度 $O(n)$。

### Part 2

上述关键位置个数减 $1$。复杂度 $O(1)$。

感觉这么写又简单常数又小，斩获最优解\~


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const int N=2510,mod=998244353;
int n,m,a[N<<1],q[N],hh,ans,ch[N];
bool fg[N],vis[N],pd[N];
vector<int>G[N],val[N];
inline int mo(int x){return x<mod?x:x-mod;}
inline void ad(int &x,int y){(x+=y)>=mod&&(x-=mod);}
int f[N<<1],g[N];
inline void dfs(int u,const int &lim){
	ch[u]=fg[u],f[u]=(u<lim),g[u]=1;
	for(int v:G[u]){
		if(!vis[v]) continue;
		dfs(v,lim);
		ch[u]+=ch[v];
		f[u]=(1ll*f[u]*g[v]+1ll*f[v]*g[u])%mod;
		g[u]=1ll*g[u]*g[v]%mod;
	}
	ad(g[u],!ch[u]);
}
inline void solve(){
	scanf("%d%d",&n,&m);
	f[hh=0]=1,ans=1;
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		while(hh&&a[q[hh]]<a[i]) --hh;
		q[++hh]=i,G[i].clear();
		val[a[i]].push_back(i);
	}
	int len=-1,px=q[1],mx=a[px],pr=n,pl=1;
	while(hh) len+=((fg[q[hh]]=(a[q[hh]]>=a[q[1]]-1))&&a[q[hh]]>1),--hh;
	if(a[1]!=2||a[n]!=1||mx<=2) pr=n+1,pl=0;
	else{
		while(a[pr]==1) --pr;
		while(a[pl]<=2) a[pl+n]=a[pl]-1,++pl;
	}
	hh=0;
	for(int i=1,dp=1;i<pr;++i){
		while(hh&&a[q[hh]]<a[i]) --hh;
		if(a[i]>1) dp=hh?mo(f[i-1]+mod-f[q[hh]-1]):f[i-1];
		ad(ans,dp);
		f[i]=mo(f[i-1]+dp*(a[i]>1));
		q[++hh]=i;
	}
	hh=0,f[pl-1]=1;
	for(int i=pl,dp=1;pl&&i<pl+n;++i){
		while(hh&&a[q[hh]]<a[i]) --hh;
		if(a[i]>1) dp=hh?mo(f[i-1]+mod-f[q[hh]-1]):f[i-1];
		ad(ans,dp*(i>=pr&&a[i]));
		f[i]=mo(f[i-1]+dp*(a[i]>1));
		q[++hh]=i;
	}
	hh=1;
	for(int i=px+1;i<=n;++i){
		while(hh&&a[q[hh]]<a[i]) --hh;
		G[q[hh]].push_back(i);
		if(fg[i]&&a[i]==a[px]-1) mx=a[i];
		pd[i]=(a[q[hh]]>a[i]);
		q[++hh]=i;
	}
	for(int i=1;i<px;++i){
		while(hh&&a[q[hh]]-(q[hh]<px)<a[i]-1) --hh;
		G[q[hh]].push_back(i);
		pd[i]=(q[hh]>=px||a[q[hh]]>a[i]);
		q[++hh]=i;
	}
	pd[px]=1;
	ad(ans,len);
	for(int i=m;i>1;--i){
		reverse(val[i].begin(),val[i].end());
		for(int j:val[i]){
			vis[j]=1;
			if(!pd[j]||i>mx) continue;
			bool tmp=fg[j];
			fg[j]=1;
			dfs(px,n+1);
			ans=(ans+(i-2ll)*f[px]*(ch[px]==len+2-tmp))%mod;
			dfs(px,j);
			ad(ans,f[px]*(ch[px]==len+2-tmp));
			fg[j]=tmp;
		}
		val[i].clear();
	}
	val[1].clear(),val[mx+1].clear();
	printf("%d\n",ans);
	memset(fg,0,sizeof fg);
	memset(vis,0,sizeof vis);
	memset(pd,0,sizeof pd);
}
int main(){
	int T;
	scanf("%*d%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：ZnPdCo (赞：5)

分为两个部分：第一部分：每个位置被操作至多一次；第二部分：存在位置操作超过一次。

先计算第二部分。

发现对于 $a$ 的一个子序列下标集合（递增）$S$，如果可以在第二部分，只保留 $S$ 中的位置，就需要满足：$\forall i$，$a_{S_i}$ 是 $a_{(S_{i-1},S_i]}$ 的严格最大值。同时，$S_1$ 大于 $a_{(S_{|S|},n]}$ 中的数**加一**。满足上述条件，我们可以通过下述方式构造出只包含这些位置的序列：

- $i=1,2,\cdots,|S|$，操作 $S_i$ 这个位置的数。操作完后，可能 $a_{(S_{|S|},n]}$ 还留在序列中，所以再操作一次 $S_1$。

在上述条件下，这些操作都是可以完成的。

如果 $S_{|S|}=n$ 的话，其实不需要再操作一次 $S_1$，因为 $a_{(S_{|S|},n]}=\varnothing$，但是为了计数方便，所以依旧再操作一次 $S_1$。不再操作一次 $S_1$ 的话，每个位置被操作至多一次，属于第一部分，我们这里不计入。

观察留下下标为 $S$ 的数之后，$a$ 会发生什么变化：$a_{S_1}$ 被移到最后一个，减去了 $2$（因为最后又再次操作了一次 $S_1$），$a_{S_2}\sim a_{S_{|S|}}$ 在前面顺次排列，它们均减去了 $1$：$\{a_{S_2}-1,a_{S_3}-1,\cdots,a_{S_n}-1,a_{S_1}-2\}$。

第二部分的序列形态，无非就是对于上述合法的 $S$，对于任意的 $i,d$，把 $S_{[1,i]}$ 的数移动至序列末端，减去 $(d+1)$；$S_{(i,n]}$ 的数在序列前端顺次排列，减去 $d$。

我们对于一个合法的 $S$ 形成的数列 $\{a_{S_2}-1,a_{S_3}-1,\cdots,a_{S_n}-1,a_{S_1}-2\}$，让它不断进行下述操作：

- 操作当前序列中的第一个数，直到第一个数为 $1$（也就是删去后 $S$ 会发生改变）。

上述操作相当于将一个 $S$ 构成的序列的 $i,d$ 不断增加，最终达到所有 $i,d$ 构成的数列，而**不会算重**。

所以说，我们枚举一个 $S$，计算它形成的序列 $\{a_{S_2}-1,a_{S_3}-1,\cdots,a_{S_n}-1,a_{S_1}-2\}$，然后计算出“不断操作第一个数，直到第一个数为 $1$”总共能够形成的局面（因为这么做不会算重，实际上我们只需要计算能够操作多少次就好了），把它们加起来就是答案。

所以做法也相应的出来了。我们枚举一个 $S$，先将 $a_{S_1}$ 减一，然后找到 $a_S$ 的最小值 $mn$，以及从 $S_1+1$ 开始遍历到 $n$ 再从 $1$ 到 $S_1$（因为 $S_1$ 被移到最后一个了）第一个找到的最小值前面（包括这一个）总共经过的数 $num$（注意我的用词，我说的不是最小值相对于 $S$ 的下标，而是从 $S_1+1$ 开始遍历，经过的数个数）。它的贡献如下：
$$
(mn-2)\times |S|+num
$$
这是因为进入第二部分时，每个数都被减了 $1$，然后我们又不能把 $a$ 减完，所以只能减到 $mn-2$ 次。然后后面我们可以继续减到最小值，也就是还能多减 $num-1$ 次。因为最开始不操作也是一种情况，所以总共贡献如上这个式子次。

这样能够统计全吗？并不完全。例如 $a=\{3,2,2\}$，我们的 $S$ 按照上述规则只能取 $\{1,2,3\}$，但其实我们并没有算入 $a=\{1,1\}$ 与 $a=\{1\}$ 的情况。

这是为何？因为我们可以取 $S=\{1,3\}$，因为其中 $a_2=2$ 被恰好删去了，后面的 $a_3=2$ 虽然不是 $[2,3]$ 的严格最大值，但是也可以算入贡献。我们也可以只取 $S=\{1\}$，这是因为此时 $a_2=a_3=2$ 都被删去了。

所以，为了构成这些“巧合”，当 $a_S$ 形如：
$$
a_S=\{v,v,\cdots,v,v-1,v-1,\cdots,v-1\}
$$
时，会产生 $|S|-1$ 的贡献，分别对应 $1\sim |S|-1$ 个 $1$。

因为其它数都将被删去，所以为了留下这些 $S$，$v$ 只能是 $\max a$。那么这个多余贡献其实就相当于 $a$ 中的最大值数量与最后一个最大值后面最大值减一的数量之和减一。

综上所述，第二部分的算法就是枚举 $S$，把 $a_S$ 进行一定的操作，然后计算出它的贡献。最后再加上上述的额外贡献。这部分是 $O(2^nn)$ 的。其中因为经过第一部分后，所有为 $1$ 的数都会被删掉，所以在最开始把它们剔除。代码如下：

```cpp
int solve2() {
    int mx = 0, res = 0;
    int len = n; n = 0;
    for (int i = 1; i <= len; i++) if (a[i] > 1) a[++n] = a[i];
    for (int i = 1; i <= n; i++) mx = max(mx, a[i]);
    for (int i = 1; i <= n; i++) res += a[i] == mx;
    for (int i = n; i >= 1; i--) if (a[i] == mx - 1) res++;
                            else if (a[i] == mx) break;
    res--;
    for (int s = 1; s < (1 << n); s++) {
        bool flag = 1;
        mx = 0;
        for (int i = 1; i <= n; i++) if (s & (1 << (i - 1))) {
            if (a[i] <= mx) flag = 0;
            mx = 0;
        } else {
            mx = max(mx, a[i]);
        }
        if (!flag) continue;
        for (int i = 1; i <= n; i++) if (s & (1 << (i - 1))) {
            if (a[i] <= mx + 1) flag = 0;
            break;
        }
        if (!flag) continue;
        
        int mn = 1e18, S1 = 0;

        for (int i = 1; i <= n; i++) if (s & (1 << (i - 1))) {
            S1 = i;
            break;
        }

        for (int i = 1; i <= n; i++) if (s & (1 << (i - 1))) {
            mn = min(mn, a[i] - (i == S1));
        }

        if (mn < 2) continue;

        int num = 0;
        for (int i = S1 + 1; ; i = i % n + 1) if (s & (1 << (i - 1))) {
            num++;
            if (a[i] - (i == S1) == mn) {
                (res += (mn - 2) * __builtin_popcountll(s) % P + num) %= P;
                break;
            }
        }
    }
    return res;
}
```

怎么优化？枚举最小值所在的位置（当然这里的最小值是从 $S_1+1$ 开始遍历的第一个最小值位置）$pos$，$\forall i$，$a_{S_i}$ 是 $a_{(S_{i-1},S_i]}$ 的严格最大值这一点比较容易通过 dp 刻画。但是，$S_1$ 大于 $a_{(S_{|S|},n]}$ 中的数加一似乎比较难于刻画？

我们将 $a$ 全部减去 $1$ 拼接到原本的 $a$ 后面，形成新的 $a$：
$$
a=\{a'_1,a'_2,\cdots,a'_n,a'_1-1,a'_2-1,\cdots,a'_n-1\}
$$
我们把 $a_{[pos,pos+n]}$ 这些数拿出来 dp，要求 $S_i$ 是距离上一次选择之间的前缀严格最大值。那么因为 $pos$ 和 $pos+n$ 必选，所以 $S_n\le n$、$S_1$ 在序列中对应的数下标 $>n$，那么“要求 $S_i$ 是距离上一次选择之间的前缀严格最大值”就相当于同时要求 $S_1$ 大于 $[S_n,n]$ 这一段加一（因为 $S_1$ 这个对应位置被减一了）。

所以就可以开始 dp 了，dp 相对于是容易的。

设 $f_i$ 表示：当前计算到第 $i$ 个且选择第 $i$ 个，$[pos,n]$ 均大于等于 $mn(=a_{pos}-1-2)$，同时 $[n+1,pos)$ 不选，可以计算 $pos$ 对应的数为 $S_1$ 的方案数。

设 $g_i$ 表示：当前计算到第 $i$ 个且选择第 $i$ 个，$[pos,pos+n]$ 均大于等于 $mn(=a_{pos}-2)$（这里的大于等于有一些门道，需要留给读者自行研究，写成文字难以理解），可以计算 $pos$ 对应的数不为 $S_1$ 的方案数。

在计算的过程中维护 $(mn-2)\times |S|+num$ 的值的和就好了。

朴素是 $O(n^3)$ 的。 注意到我们使用单调栈找到前面第一个大于等于 $a_i$ 的数 $j$，$[j,i)$ 都可以转移至 $i$。

这样就可以做到 $O(n^2)$ 了：

```cpp
int solve2() {
    int mx = 0, res = 0;
    int len = n; n = 0;
    stk[0] = 1;
    for (int i = 1; i <= len; i++) if (a[i] > 1) a[++n] = a[i];
    for (int i = 1; i <= n; i++) a[i + n] = a[i] - 1, mx = max(mx, a[i]);
    for (int i = 1; i <= n; i++) res += a[i] == mx;
    for (int i = n; i >= 1; i--) if (a[i] == mx - 1) res++;
                            else if (a[i] == mx) break;
    res--;
    for (int i = 1; i <= n; i++) {
        // i 不为 S1
        if (a[i] >= 2) {
            memset(f, 0, sizeof f), memset(g, 0, sizeof g), memset(sf, 0, sizeof sf), memset(sg, 0, sizeof sg), top = 0;
            f[i] = sf[i] = 1;
            g[i] = sg[i] = a[i] - 2;
            for (int j = i + 1; j < n + i; j++) {
                while (top && a[stk[top]] < a[j]) top--;
                if (a[j] >= a[i]) {
                    f[j] = (sf[j - 1] - sf[stk[top] - 1] + P) % P;
                    g[j] = (f[j] * (a[i] - 2 + (j > n)) % P + (sg[j - 1] - sg[stk[top] - 1] + P) % P) % P;
                }
                sf[j] = (sf[j - 1] + f[j]) % P;
                sg[j] = (sg[j - 1] + g[j]) % P;
                stk[++top] = j;
            }
            while (top && a[stk[top]] < a[n + i]) top--;
            for (int j = max(n + 1, stk[top]); j < n + i; j++) {
                (res += g[j]) %= P;
            }
        }
        // i 为 S1
        if (a[i] >= 3) {
            memset(f, 0, sizeof f), memset(g, 0, sizeof g), memset(sf, 0, sizeof sf), memset(sg, 0, sizeof sg), top = 0;
            f[i] = sf[i] = 1;
            g[i] = sg[i] = a[i] - 3 + 1;
            for (int j = i + 1; j < n + i; j++) {
                while (top && a[stk[top]] < a[j]) top--;
                if (a[j] >= a[i] && j <= n) {
                    f[j] = (sf[j - 1] - sf[stk[top] - 1] + P) % P;
                    g[j] = (f[j] * (a[i] - 3 + 1) % P + (sg[j - 1] - sg[stk[top] - 1] + P) % P) % P;
                }
                sf[j] = (sf[j - 1] + f[j]) % P;
                sg[j] = (sg[j - 1] + g[j]) % P;
                stk[++top] = j;
            }
            while (top && a[stk[top]] < a[n + i]) top--;
            for (int j = max(i, stk[top]); j <= n; j++) {
                (res += g[j]) %= P;
            }
        }
    }
    return res;
}
```

接下来计算第一部分。

因为不存在元素被操作两次及以上，所以枚举 $S$ 表示操作了 $S$ 这些位置。依旧需要满足：$\forall i$，$a_{S_i}$ 是 $a_{(S_{i-1},S_i]}$ 的严格最大值。但是不需要满足 $S_1$ 大于 $a_{(S_{|S|},n]}$ 中的数加一。

看似满足后计算出来的序列都是互不相同的，但是实际上注意 $1$ 的存在，删去 $1$ 后直接没了，会算重一部分情况。

所以，还有另外两个限制：

1. 删 $1$ 之后只能删 $1$，假如删 $1$ 之后删了一个 $x$，那么我们可以只删这个 $x$，结果一致；

2. 如果 $a_{S_1}=2$，则 $a_{[S_{|S|},n]}$ 不能全为 $1$。如果 $a_{[S_{|S|},n]}$ 全为 $1$ 的话，会算重：设我们的 $a_{(S_1,S_{|S|})}$ 中最靠后的一个 $>2$ 的数为 $x$。那么我们必定会选择 $x$。我们观察到选择的集合包含 $S_1,x,S_{|S|}$ 会造成什么：$S_1$ 会被移到最后面并被减去 $1$，相当于移去开头的 $2$ 并在序列末尾增加一个 $1$，而因为 $a_{S_{|S|}}=1$，也同时删掉了这个 $S_{|S|}$ 的话，一加一减，相当于只是删掉了开头的 $S_1$ 罢了。

   而注意到如果我们不选择 $S_1,S_{|S|}$，也可以达到同样的效果：因为 $a_x>2$，所以它可以删掉前缀的数，也相当于只是删掉了开头的 $S_1$。

   所以会算重。

朴素实现为 $O(2^nn)$。

```cpp
int solve1() {
    int res = 0, num = 0, mx = 0;
    for (int i = n; i >= 1; i--) if (a[i] == 1) {
        num++;
    } else break;
    for (int s = 0; s < (1 << n); s++) {
        bool flag = 1, vis = 0;
        mx = 0;
        for (int i = 1; i <= n; i++) if (s & (1 << (i - 1))) {
            if (a[i] <= mx) flag = 0;
            if (a[i] != 1 && vis) flag = 0;
            if (a[i] == 1) vis = 1;
            mx = 0;
        } else {
            mx = max(mx, a[i]);
        }
        if (!flag) continue;
        
        for (int i = 1; i <= n; i++) if (s & (1 << (i - 1))) {
            if (a[i] == 2) {
                for (int j = n; j >= n - num + 1; j--) if (s & (1 << (j - 1))) {
                    flag = 0;
                }
            }
            break;
        }

        if (!flag) continue;

        res++;
    }
    return res;
}
```

这里的 dp 可以和上面类似，不过不需要重复一遍数组了，更简单，设 $f_{i,0/1,0/1}$ 表示当前计算到第 $i$ 个且选择第 $i$ 个，$S$ 是否包含 $1$？$S$ 开头是否为 $2$？

直接做是 $O(n^2)$ 的，甚至不需要单调栈优化。

综上，复杂度就是 $O(n^2)$ 的了。

```cpp
int solve1() {
    int res = 0, num = 0, mx = 0;
    for (int i = n; i >= 1; i--) if (a[i] == 1) {
        num++;
    } else break;
    memset(dp, 0, sizeof dp);
    for (int i = 1; i <= n; i++) {
        bool flag = 1;
        for (int j = 1; j < i; j++) flag &= (a[j] < a[i]);
        dp[i][a[i] == 1][a[i] == 2] = flag;
        for (int j = i - 1; j >= 1; j--) {
            (dp[i][a[i] == 1][0] += dp[j][0][0]) %= P;
            (dp[i][a[i] == 1][1] += dp[j][0][1]) %= P;
            if (a[i] == 1) (dp[i][1][0] += dp[j][1][0]) %= P;
            if (a[i] == 1) (dp[i][1][1] += dp[j][1][1]) %= P;
            if (a[j] >= a[i]) break;
        }
        (res += dp[i][0][0]) %= P;
        (res += dp[i][1][0]) %= P;
        if (i <= n - num) (res += dp[i][0][1]) %= P;
        if (i <= n - num) (res += dp[i][1][1]) %= P;
    }
    res++;      // 不选
    return res;
}
```

这样就对了吗？不然，你还记得计算第一部分时的一句话：

> ……设我们的 $a_{(S_1,S_{|S|})}$ 中最靠后的一个 $>2$ 的数为 $x$……

如果 $\max a>2$，这个 $x$ 是必然存在的，因为 $a_{S_1}=2$，那么前缀必定小于 $2$，而 $a_{[S_{|S|},n]}$ 全为 $1$ 的话，所以最大值只能在 $a_{(S_1,S_{|S|})}$ 间，所以肯定存在这个 $x$。

如果 $\max a<2$ 的话，你可以暴力解决这个问题，时间复杂度为 $O(n^2)$ 或者 $O(n^2\log n)$ 或者更优。

总复杂度忽略暴力就是 $O(n^2)$ 的：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define P 998244353
#define N 5010
int T, n, m, a[N], f[N], g[N], sf[N], sg[N], dp[N][2][2], stk[N], top;
set<vector<int>> S;
int solve1() { /*见上*/ }
int solve2() { /*见上*/ }
void bf(vector<int> a) {
    if (a.empty()) return ; 
    if (S.count(a)) return ;
    S.insert(a);
    int mx = 0;
    while (!a.empty()) {
        int ai = a[0];
        a.erase(a.begin());
        if (ai > mx) {
            if (ai > 1) a.push_back(ai - 1);
            bf(a);
            if (ai > 1) a.pop_back();
        }
        if (mx >= 2) break;
        mx = max(mx, ai);
    }
}
void solve() {
    scanf("%lld %lld", &n, &m);
    vector<int> A; S.clear();
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
        A.push_back(a[i]);
    }
    printf("%lld\n", (m <= 2) ? (bf(A), S.size()) : (solve1() + solve2()) % P);
}
signed main() {
    scanf("%*lld %lld", &T);
    while (T--)
        solve();
}
```

---


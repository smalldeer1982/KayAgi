# [KOI 2025 #2] 庆典

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 国由 $N$ 个城市组成，各城市分别编号为 $1, 2, \dots, N$。1 号城市是 KOI 国的首都。

KOI 国有 $N-1$ 条双向道路。对于所有满足 $2 \le i \le N$ 的 $i$，$i$ 号城市都与 $P_i$ 号城市通过一条双向道路相连。此时，满足 $P_i < i$，且连接 $i$ 号城市和 $P_i$ 号城市的道路的每日通行费是 $W_i$。

如果 $u$ 号城市位于从 1 号城市（首都）到 $v$ 号城市的简单路径上，我们定义为 $u$ 号城市**管制** $v$ 号城市。$i$ 号城市的**管辖区域**被定义为 $i$ 号城市所管制的所有城市的集合。因此，1 号城市的管辖区域是所有城市，并且对于所有 $1 \le i \le N$，$i$ 号城市本身也属于其管辖区域。如果将 KOI 国的道路网看作一个以 1 号城市为根的树形结构，那么 $i$ 号城市的管辖区域就与以 $i$ 号城市为根的子树相对应。

KOI 国的各个城市计划举办庆典。平时所有道路的通行费都是免费的，但在庆典期间，为了分担举办庆典的费用，计划对部分道路征收通行费。

如果在 $i$ 号城市举办庆典，可以选择一部分道路来征收通行费。单日通行费收入是所有征收通行费的道路的每日通行费之和。为了减少民众的不满，选择的道路必须满足以下两个条件：

*   在 KOI 国内任意两个城市之间的简单路径上，征收通行费的道路数量必须不多于 $K$ 条。
*   征收通行费的道路，其两端点城市都必须位于 $i$ 号城市的管辖区域内。

请你编写一个程序，对于所有 $1 \le i \le N$ 的 $i$，分别计算当庆典在 $i$ 号城市举办时，能够获得的最大单日通行费收入。

## 说明/提示

### 限制条件

*   所有给定的数都是整数。
*   $1 \le K < N \le 300\,000$
*   对于所有 $2 \le i \le N$，满足 $1 \le P_i < i$。
*   对于所有 $2 \le i \le N$，满足 $0 \le W_i \le 10^9$。

### 子任务

1.  (4 分) $N \le 3\,000$。
2.  (5 分) 与三个或更多道路相连的城市最多只有一个。
3.  (11 分) 设连接 1 号城市和 $N$ 号城市的简单路径为 $T$。对于所有城市，最多经过 10 条道路即可移动到路径 $T$ 上的某个城市。
4.  (13 分) $N \le 100\,000$，且对于所有 $2 \le i \le N$，满足 $W_i = 1$。
5.  (8 分) 对于所有 $2 \le i \le N$，满足 $W_i = 1$。
6.  (17 分) $N \le 100\,000$，且对于所有 $2 \le i \le N$，$W_i$ 的值等于 $i$ 号城市管辖区域内所含城市的数量。
7.  (10 分) 对于所有 $2 \le i \le N$，$W_i$ 的值等于 $i$ 号城市管辖区域内所含城市的数量。
8.  (15 分) $N \le 100\,000$。
9.  (17 分) 无额外限制条件。

## 样例 #1

### 输入

```
7 2
1 5
1 5
2 2
2 2
3 2
3 2```

### 输出

```
10
4
4
0
0
0
0```

## 样例 #2

### 输入

```
7 3
1 5
1 5
2 2
2 2
3 2
3 2```

### 输出

```
14
4
4
0
0
0
0```

## 样例 #3

### 输入

```
7 3
1 5
1 5
2 3
2 3
3 3
3 3```

### 输出

```
17
6
6
0
0
0
0```

## 样例 #4

### 输入

```
20 4
1 1
1 2
2 4
3 0
4 7
6 2
4 10
2 9
4 2
2 5
8 1
6 1
11 5
5 9
1 1
16 6
7 10
6 3
8 7```

### 输出

```
78
60
9
41
9
16
10
8
0
0
5
0
0
0
0
6
0
0
0
0```

# 题解

## 作者：chen_zhe (赞：4)

### 子问题 1

我们定义 `dp[u][d]` 为：在以 `u` 为根的子树中，从 `u` 到叶节点的路径上，当选择的边的数量不超过 `d` 时，每日使用费总和的最大值。对于每个顶点 `u`，答案是 `dp[u][K]`。

添加一条每日使用费为 `w` 的边时的状态转移是：不选择该边，$dp[d] \rightarrow dp'[d]$；选择该边，$dp[d] + w \rightarrow dp'[d+1]$。

合并 `dp[u]` 和 `dp[v]` 时的状态转移是：对于满足 $d_1 + d_2 \le K$ 的 $d_1, d_2$，有 $dp[u][d_1] + dp[v][d_2] \rightarrow dp'[\max(d_1, d_2)]$。

如果直接这样实现，时间复杂度为 $O(NK^2)$，但可以通过多种方法优化到 $O(NK)$。例如，通过固定 $\max(d_1, d_2)$ 来在 $O(K)$ 时间内合并，或利用 $d$ 的值不超过子树高度的性质，在 $O(\min(\text{depth}(u), K) \cdot \min(\text{depth}(v), K))$ 时间内合并等。

### 子问题 5

所有每日使用费都相同，为 1。在这种情况下，对于一棵树，最优策略是重复进行“选择并删除与叶节点相连的边”这一操作 $\lfloor K/2 \rfloor$ 次。如果 $K$ 是奇数且仍有剩余的边，则额外再使用一条。

在为所有子树求答案时，可以利用“每条边都会对其上方顶点到根的某条路径上的顶点的答案产生贡献”这一事实，在 $O(N \log N)$ 时间内解决。

### 子问题 9

证明每个 `dp` 数组关于 `d` 是凹的。

添加一条每日使用费为 `w` 的边时，与闵可夫斯基和（Minkowski sum）的原理相同，凹性得以保持。

在合并 `dp[u]` 和 `dp[v]` 时，当有两个凹且单调递增的数组 $A$ 和 $B$ 时，我们需要证明由 $C[k] = \max_{i \le k, j \le k, i+j \le K} A[i] + B[j]$ 定义的数组 $C$ 也是凹的。当 $k \le K/2$ 时，$C[k] = A[k] + B[k]$，这是显而易见的。当 $k > K/2$ 时，$C[k] = \max_{K-k \le i \le k} A[i] + B[K-i]$。若定义对于特定 $k$ 的最优 $i$ 为 $f(k)$，则可以利用 $K-k \le \lfloor\frac{f(k-1)+f(k+1)}{2}\rfloor \le \lceil\frac{f(k-1)+f(k+1)}{2}\rceil \le k$ 这一性质，证明 $2C[k] \ge C[k-1] + C[k+1]$。

现在，`dp` 数组可以用 $dp[d] - dp[d-1]$ 的值的多重集（multiset）来表示。

添加一条每日使用费为 `w` 的边的状态转移，就简化为向多重集中添加 `w`，如果其大小超过 `K`，则移除最小的元素即可。

如果能将两个高度为 $h_1, h_2$（$h_1 \le h_2$）的 `dp` 数组在 $O(h_1 \log K)$ 时间内合并，那么整个问题就可以在 $O(N \log K)$ 时间内解决。如果 $h_1 \ge K/2$，则可以像子问题 1 那样在 $O(K)$ 等时间内合并。否则，可以发现，使得 $\max(d_1, d_2) = d_1$ 或 $d_1 + d_2 > K$ 成立的 $d_2$，只可能出现在前后长度为 $h_1$ 的部分。我们只对这部分直接计算 `dp` 值，而其余的值只是被平移，其差值不变，利用这一性质可以在 $O(h_1 \log K)$ 时间内处理。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=300005;
const ll inf=1e18;
int n,k,p[N];
ll w[N],sum[N],ans[N];
ll cdp[2][N],ndp[N];
multiset<ll> dp[N];
vector<int> c[N];
void mrg(int u,int v){
	if(dp[u].size()<dp[v].size()){
		swap(dp[u],dp[v]);
		swap(sum[u],sum[v]);
	}
	if(dp[v].empty()) return;
	int h=dp[v].size(),h2=dp[u].size();
	if(h+2<=min(h2,k-h)){
		for(int i=1;i<=h;i++){
			auto iter=prev(dp[u].end());
			cdp[0][i]=cdp[0][i-1]+*iter;
			dp[u].erase(iter);
		}
		for(int i=1;i<=h;i++){
			auto iter=prev(dp[v].end());
			cdp[1][i]=cdp[1][i-1]+*iter;
			dp[v].erase(iter);
		}
		for(int i=h2;i>=k-h+1;i--){
			auto iter=dp[u].begin();
			cdp[0][i]=sum[u];
			sum[u]-=*iter;
			dp[u].erase(iter);
		}
		ndp[min(h2,k-h)]=sum[u]+sum[v];
		auto iter=prev(dp[u].end());
		ndp[h+1]=cdp[0][h]+*iter+sum[v];
		dp[u].erase(iter);
		for(int i=1;i<=h;i++) ndp[i]=cdp[0][i]+cdp[1][i];
		for(int i=k-h+1;i<=h2;i++) ndp[i]=cdp[0][i]+cdp[1][k-i];
		for(int i=1;i<=h+1;i++) ndp[i]=max(ndp[i],ndp[i-1]);
		for(int i=k-h+1;i<=h2;i++) ndp[i]=max(ndp[i],ndp[i-1]);
		for(int i=1;i<=h+1;i++) dp[u].insert(ndp[i]-ndp[i-1]);
		for(int i=k-h+1;i<=h2;i++) dp[u].insert(ndp[i]-ndp[i-1]);
		sum[u]=ndp[h2];
	} else{
		h=dp[u].size();
		for(int i=1;i<=h;i++){
			auto iter=prev(dp[u].end());
			cdp[0][i]=cdp[0][i-1]+*iter;
			dp[u].erase(iter);
		}
		for(int i=1;i<=h;i++){
			if(dp[v].empty()){
				cdp[1][i]=cdp[1][i-1];
				continue;
			}
			auto iter=prev(dp[v].end());
			cdp[1][i]=cdp[1][i-1]+*iter;
			dp[v].erase(iter);
		}
		for(int i=1;i<=h;i++) ndp[i]=max(cdp[0][i]+cdp[1][min(i,k-i)],cdp[1][i]+cdp[0][min(i,k-i)]);
		for(int i=1;i<=h;i++) ndp[i]=max(ndp[i],ndp[i-1]);
		sum[u]=ndp[h];
		for(int i=1;i<=h;i++) dp[u].insert(ndp[i]-ndp[i-1]);
	}
	while(dp[u].size()&&!*dp[u].begin()) dp[u].erase(dp[u].begin());
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>k;
	for(int i=2;i<=n;i++){
		cin>>p[i]>>w[i];
		c[p[i]].push_back(i);
	}
	for(int u=n;u>=1;u--){
		for(int v: c[u]) mrg(u,v);
		ans[u]=sum[u];
		if(w[u]){
			dp[u].insert(w[u]);
			sum[u]+=w[u];
			if((int)dp[u].size()>k){
				sum[u]-=*dp[u].begin();
				dp[u].erase(dp[u].begin());
			}
		}
	}
	for(int i=1;i<=n;i++) cout<<ans[i]<<"\n";
	return 0;
}
```

---


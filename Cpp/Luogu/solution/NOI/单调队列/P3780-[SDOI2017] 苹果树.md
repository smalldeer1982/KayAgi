# [SDOI2017] 苹果树

## 题目背景

**提示：第三档部分分中正确的数据范围应为 $v_i=1$，为尊重原题未进行数据范围修改**。

## 题目描述

夏天近了，又到了恋爱的季节，小 Q 家门前的苹果树上结满了红红圆圆的苹果。

这株苹果树是一个有着 $n$ 个结点的有根树，其中结点被依次编号为 $1$ 至 $n$。$1$ 号结点为根，其余每一个结点的父结点一定是某个编号较小的结点。每一个结点上都有一些苹果，第 $i$ 个结点上有 $a_i (a_i > 0)$ 个苹果，每取走其中一个苹果就可以得到 $v_i (v_i > 0)$ 的幸福度（若在这个结点取走 $k \leq a_i$ 个苹果，则可以收获 $kv_i$ 的幸福度）。如果在一个结点取走了至少一个苹果，则必须要在其父结点处取走至少一个苹果。

现在，给定正整数 $k$，请从树上取走若干苹果。如果总计取走了 $t$ 个苹果，且所有取了至少一个苹果的那些结点的最大深度为 $h$（这里规定根结点的深度为 $1$），则要求 $t-h \leq k$。问最大可以收获多少的幸福度？（这些幸福度全都归属于恋爱中的小 Q。）

## 说明/提示

- 有 $10\%$ 的数据，满足 $nk \leq 3000000$ 且给定的树的高度为 $2$。
- 有 $20\%$ 的数据，满足 $nk \leq 25000000$ 且给定的树的高度为 $2$。
- 有 $20\%$ 的数据，满足 $nk \leq 25000000$ 且所有 $a_i$ 均为 $1$。
- 还有 $20\%$ 的数据，满足 $nk \leq 3000000$，没有上述额外限制。
- 对于 $100\%$ 的数据，满足 $1 \leq Q \leq 5$；$1 \leq n \leq 20000$；$1 \leq k \leq 500000$；$1 \leq nk \leq 25000000$；$1 \leq a_i \leq 10^8$；$1 \leq v_i \leq 100$。

## 样例 #1

### 输入

```
2
5 1
0 1 1
1 1 1
1 1 3
2 1 10
3 1 4
9 15
0 1 1
1 7 2
2 5 10
1 3 1
4 3 17
4 3 18
4 4 19
1 1 1
8 1 100```

### 输出

```
15
316```

# 题解

## 作者：shadowice1984 (赞：49)

感谢管理员的大时限…

这道题终于极限卡常数过了233

 _(在我AC这道题的时候它还是道蓝牌题，但是我怎么都觉得假蓝牌题害人啊)_ 

# ~~我背包今天就是要卡死你~~

所以说不要觉得背包问题是一个很无脑的dp问题啊……

就算是纯粹的背包问题，其实也是非常有思维含量的

## 前置芝士：树的后序遍历

我们一般的dfs序其实是记录入栈顺序

但是其实这样的dfs序是最没用的，唯一的性质也就是一个子树的节点的dfs序是连续的这个性质可以用

但是如果我们不存入栈顺序而是求弹栈顺序呢？

那么我们会发现，除了dfs序的性质得以保留，而且还多了一个新的性质

**任意一个点i的子树在这个序列上都是一个区间，并且i是区间右端点**

~~(其实dfs序也有，只是是左端点)~~

而这种求弹栈顺序的得到的序列，在一定程度上部分还原了dfs序的信息，我们称之为后序遍历。

(请牢记后续遍历的性质，这个性质对于做题非常关键！)

______________
## 本题题解

先让我们理一下题意：树上求背包最大收益，每个物品的体积都是1，同一个物品可以取ai次，并且取儿子必须取父亲，除此之外，我们还可以免费取一条最长链

嗯~ o(*￣▽￣*)o这里我们发现点权都是正的，所以我们可以确定免费的链一定是从**根节点到叶子的一条路径**(因为如果不是叶子的话我们可以继续贪心的向下取)

发现如果没有这个叶子的限制这题似乎还给了一些扑腾的空间，但是加上这个限制之后我们就只能死鱼了……情况开始变得辣手

### 当问题开始变得辣手的时候，我们要想一些暴力的方法，比如枚举

所以我们枚举每一个叶子到根节点的路径，并且删掉这条路径

这个树大概会被分为4个部分

1.链上免费取的部分

2.链上付费取的部分

3.树左边(这里暂时不理解没关系)的部分

4.树右边的部分

发现4个部分的情况太过复杂，而最为辣手的东西是第2个部分，因为这部分的点甚至不满足树形依赖关系，我们希望通过适(奇)当(技)的(淫)操(巧)作来让这部分东西满足树形依赖关系

我们发现对于所有物品都有这样一个隐含的逻辑关系在

**如果我要取点i的第2个及以后的物品，我首先要选取点i第一个物品**

观察题目中给出的逻辑关系

**如果我要取i的第一个物品，我首先要选取他父亲的第一个物品**

我们发现这个隐含的逻辑关系和题目中的父子关系是一致的

所以我们可以考虑**拆点**

一个点，如果物品数大于1，拆成两个点，一个点是i，物品数只有一个，但是保留所有树上的连边关系，另一个是i'物品数是ai-1不和任何其他点连边，只和i连边并且作为i的儿子出现

这样的话我们的i'就代表了这个点剩下的物品，并且i和i'的父子关系等价的描述了"如果我要取点i的第2个及以后的物品，我首先要选取点i第一个物品"的逻辑关系

那这样的话我们再次枚举路径会发生什么有趣的现象呢？

观察一下这个两个图，其中的蓝色数字是后续遍历，橙色数字是将临界表全部reverse的后续遍历，黑色点是原来的点，红色点是拆点之后的点

![](https://cdn.luogu.com.cn/upload/pic/15978.png)

![](https://cdn.luogu.com.cn/upload/pic/15980.png)

我们会发现一个有趣的事实，树的左半部分(被绿色圈起来的部分)和树的右半部分(被紫色圈起来的部分)刚好是两种后序遍历上一段连续的区间……

并且，中间剩下的链部分只剩下了黑色点，也就是说，黑链上的东西被孤立了出来，这些东西可全部是免费的……

此时我们只需要枚举树的左半边选多少和树的右半边选多少个点就行了……

因为不包含免费部分并且包含了全部的付费部分，所以左边+右边刚好是k个

我们$O(k)$的枚举就行了,这样枚举的总复杂度是$O(nk)$注意到nk是爆炸的$2.5×10^{7}$这种丧病的数据范围，这样我们需要在$O(1)$时间内回答形如“在后续遍历前i个点中选择k个物品的最大收益”这样的问题

那么我们自然而然的想到了dp

我们设$dp_{i,j}$表示决策到了后序遍历第i个点，选取j个物品的最大收益

那么我们枚举这个物品选还是不选，如果不选的话，它的子树全部不可选，而不可选的子树是一段区间，所以只能由$dp_{i-siz_{i},j}$转移过来，如果选的话，我们枚举这个物品选几个

转移方程大概长这样？

# $dp_{i,j}=max_{k=1}^{a_{i}}(dp_{i-1,j-k},dp_{i-siz_{i},j})$

似乎和多重背包的转移方程很像？

准确来说除了最后那个$i-siz_{i}$以外是一膜一样吧……

而这个东西根本不影响多重背包的单调队列优化……

~~(蛤，你不会多重背包的单调队列优化？，去问度娘，包教包会)~~

(这里默认大家会多重背包的单调队列优化)

~~(不要妄想使用二进制优化，这道题$O(nk)$都吃力别说再加个log了)~~

所以我们可以做到$O(nk)$的求出每个dp的值

然后我们要先后续跑一边dp，之后把邻接表reverse一遍再跑一边dp

此时我们的$dp_{i,k}$值就是那个“在后续遍历前i个点中选择k个物品的最大收益”的答案

最后一个问题，我们发现这样做的话有些点的父亲是没有被选择的

比如图片中的第9，11，12号点它们的父亲在dp的时候没有确保被选上

## 醒醒啊，它们的父亲是你枚举的免费点！

所以可以确保父亲一定被选上了233

另一个问题，我们发现如果枚举叶子i时无脑的认为正着后续遍历区间是i正着的后续遍历序-1，倒着后续遍历区间是i倒着的后续遍历序-1，那么最后会发现他拆点之后的儿子被选了两遍，(比如图中的9/12号点)，因此确定区间的时候需要有一个是减$siz_{i}$的

然后我们的算法复杂度是$O(nk)$的，然而本题的$nk=2.5×10^{7}$这个丧病的nk数值决定了我们的算法需要一些底(大)层(力)优(卡)化(常)，和坚定的(大)信(时)仰(限)才可以避免T飞的惨剧……

### 一些玄学卡常技巧

1.一维数组模拟二位的映射公式请选用$i×(k+1)+j$因为这样的话你会连续的访问一段内存大大减少二级缓存未命中事件的发生，从而节约一定的常数

2.请存单向边，卡常效果显著

3.如果像我一样使用了vector来存边，那么在清空vector的时候请新建一个空vector再swap两个vector，这样的话可以O(1)完成clear操作

4.不要写双端队列！双端队列的操作也不要封装在结构体里，更不要用stl!所有的操作全部手动inline，包括模拟二维数组的映射函数也是……

但是代码还是挺短的

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int N=4*1e4+10;const int K=5*1e5+10;const int NK=6*1e7+10;
inline void clear(vector <int>& ve){vector <int> emp;swap(emp,ve);}//高速清空函数 
vector <int> v[N];int w[N];int a[N];int n;int res;int ctt;int k;
int dfn1[N];int dfn2[N];int df1;int df2;int siz[N];int line[N];
int dp1[NK];int dp2[NK];bool lf[N];int nfd1[N];int nfd2[N];int T;
int h;int fa[N];int q1[2*K];int q2[2*K];int hed=1;int til=0;
inline void dypr(int* dfn,int* dp)//dp的函数 
{
    for(int i=1;i<=ctt;i++)
    {
        int v=dfn[i];hed=1;til=1;q1[til]=q2[til]=0;//手动inline了全部的deque操作，凑合着看吧 
        for(int j=1;j<=k;j++)
        {
            hed+=(q1[hed]<j-a[v])?1:0;int val=dp[(i-1)*(k+1)+j]-j*w[v];
            dp[i*(k+1)+j]=max(q2[hed]+j*w[v],dp[(i-siz[v])*(k+1)+j]);//单调队列优化转移 
            while(hed<=til&&q2[til]<=val){til--;}q1[++til]=j;q2[til]=val;
        }
    }
}
inline void clear_all()//清空函数 
{
    for(int i=0;i<=ctt;i++){clear(v[i]);lf[i]=line[i]=siz[i]=0;}
    for(int i=0;i<=(ctt+1)*(k+1);i++){dp1[i]=dp2[i]=0;}
    df1=df2=res=ctt=0;h=0;
}
void dfs1(int x)//正着dfs，原谅我毒瘤压行 
{
    siz[x]=1;
    for(int i=0;i<v[x].size();i++)
    {dfs1(v[x][i]);siz[x]+=siz[v[x][i]];}dfn1[++df1]=x;nfd1[x]=df1;
}
void dfs2(int x)//reverse后dfs 
{
    for(int i=v[x].size()-1;i>=0;i--)
    {line[v[x][i]]=line[x]+w[v[x][i]];dfs2(v[x][i]);}
    dfn2[++df2]=x;nfd2[x]=df2;
}
inline void solve()
{
    scanf("%d%d",&n,&k);ctt=n;
    for(int i=1;i<=n;i++){scanf("%d%d%d",&fa[i],&a[i],&w[i]);lf[fa[i]]=true;}
    for(int i=1;i<=n;i++)//加边和拆点 
    {
        v[fa[i]].push_back(i);
    	if(a[i]>1){a[++ctt]=a[i]-1;a[i]=1;w[ctt]=w[i];v[i].push_back(ctt);}
    }line[1]=w[1];dfs1(1);dfs2(1);dypr(dfn1,dp1);dypr(dfn2,dp2);//dfs和dp 
    for(int i=1;i<=n;i++)//枚举叶子更新答案 
    {
        if(lf[i])continue;
        for(int j=0;j<=k;j++)
        {res=max(res,dp1[(nfd1[i]-1)*(k+1)+j]+line[i]+dp2[(nfd2[i]-siz[i])*(k+1)+(k-j)]);}
    }printf("%d\n",res);//然后靠信仰卡常吧 
}
int main()
{scanf("%d",&T);for(int z=1;z<=T;z++){solve();clear_all();}return 0;}//拜拜程序~ 

```
















---

## 作者：SovietPower✨ (赞：22)

$shadowice$已经把他的思路说的很清楚了，可以[先看一下](https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3780)会更好理解？

这篇主要是对[$Claris$题解](https://www.cnblogs.com/clrs97/p/7842530.html)的简单说明。与$shadowice$的做法还是有差异的（比如并没有明显用到后序遍历的性质），而且用这种写法可能跑的比较轻松？

（另外你只要想明白$f,h$是代表啥，就很好理解了...）

-----
> 问题等价于树形依赖背包，允许一条链每个点各免费取一次。

免费取一条链即$t\leq h+k$的限制。这样最优解一定会免费取了一条从叶子到根节点的链。

现在考虑一下怎么做。不妨枚举这条链（也就是枚举叶子）。

假如我们枚举的叶子是7，也就是这样：

![](https://cdn.luogu.com.cn/upload/pic/45236.png)

同样我们可以考虑这么4部分：

$(1)$ $1-4-6-7$这条链可以免费取一次

$(2)$ $1-4-6-7$这条链还可以付费取$a_i-1$次

$(3)$ 链左边的点可以各付费取$a_i$次

$(4)$ 链右边的点可以各付费取$a_i$次

-----
$(1)$只需要在叶子处算一下到根节点路径上的权值和就可以了（就是$val_1+val_4+val_6+val_7$）。

$(2)$就是对当前链做多重背包（不过每个物品的个数为$a_i-1$）。

$(3)$是对前边枚举过的非链上的点做背包。如果把邻接表反过来，$(4)$和$(3)$的求法是一样的（也是对前面的点背包）。

单是枚举叶子就是$O(n)$的了。所以我们八成需要DP预处理每个叶子处$(2)(3)(4)$三个值。

不妨DP的时候将$(2)(3)$合并到一起算，$(4)$在反转边表后再计算。

-----
> 设$f[i][j]$表示按DFS序考虑到$i$，体积为$j$的最大收益。

$f[i][j]$就是到$i$节点，已用体积为$j$，同时考虑了$(2)(3)$两种情况的最大值（只考虑了当前点到根节点的链和链左边的点）。

比如$f[7][j]$就是对$2,3,5,1,4,6,7$做完多重背包，已用体积为$j$的最大价值（背包时$1,4,6,7$的个数分别都是$a_i-1$）。

![](https://cdn.luogu.com.cn/upload/pic/45237.png)

怎么求呢？可以先看一下$Claris$的代码。

> 先放入不能免费的物品，等遍历完儿子后再放入必选的物品，那么$i$到根路径上所有点都只算了不能免费的部分。

举个例子：从$4$访问完$5$子树后，然后访问$6$，显然$f[6]$就是$f[5]$再加入$1$个$5$和$a_6-1$个$6$做一次多次背包（$5$此时就不能免费取了，因为之前是免费且必选的所以并没有计算；而$6$此时会免费取一次，最后加到链上就可以了，所以此时计算$a_6-1$个，即不能免费的）。

当然我们不能直接去修改$f[5]$这个数组，但我们可以更新数组$f[4]$，因为它不是叶子，最后就用不到它的$f$值。而且$4$的其它儿子比如$11$，也可以直接用$f[4]$更新它。

也就是我们要用$f[5]$和$1$个$5$更新$f[4]$，即$f[4][j]=\max\{f[4][j],\ f[5][j-1]+val_5\}$。

注意此时$f[5][j]$是考虑过$5$子树内的，不能直接用$f[5][j]$转移（可能一个$5$也没有选），要强制选一个$5$再转移。

然后用$f[4]$更新$f[6]$。其实就是先把$f[4]$复制给$f[6]$，然后用$f[6]$和$a_6-1$个$6$做多重背包。

那么算法流程大概是：记$v$的父节点为$x$，先把$f[x]$复制给$f[v]$，然后用$a_v-1$个$v$更新$f[v]$，递归到$v$。处理完$v$子树后，再用$f[v]$加入一个$v$做背包来更新$f[x]$，以便更新后面的子节点。

这里对$f[i]$做多重背包是$f[i][j]=\max_{k=1}^{a_i-1}\{f[i][j-k]+k*val_i\}$，可以用单调队列维护，$O(k)$更新。

-----
> 然后将DFS序翻转，设$h[i][j]$表示按DFS序考虑到$i$，体积为$j$的最大收益。

$h[i][j]$表示到节点$i$，已用体积$j$，情况$(4)$的最大价值，也就是只考虑它到根节点的链的右边的点的最大价值。

比如$h[7]$，就是对$9,10,11,8$做多重背包后的dp数组：

![](https://cdn.luogu.com.cn/upload/pic/45238.png)

> 等遍历完儿子后再放入必选的物品和不能免费的物品，那么$i$到根路径上所有点都没有算。

转移方式与$f$很类似，只是需要在遍历完$i$的子树后，才用$a_i,val_i$更新$h[i]$（这样在用$h[i]$更新子树时并没有计算当前链上的，只考虑了链右边的点）。不细说了。（和后序遍历也挺类似的？）

> 如此一来，对于每个叶子$i$，用 $f[i][j]+h[i][k-j]+$免费取一次到根节点的路径的权值 更新答案即可。

> 对于不能免费的物品，需要用单调队列优化转移。

> 时间复杂度$O(nk)$。

细节：二维数组最好用一维数组代替（注意每个点的空间是$k+1$）。其它注意一下就好了。

代码看$Claris$博客好了，感觉没多少可改的了orz。

---

## 作者：Alex_Wei (赞：18)

> [P3780 [SDOI2017] 苹果树](https://www.luogu.com.cn/problem/P3780)

问题相当于选择从根到某个点的路径，免费选一个苹果，再做 [树上依赖性背包](https://www.cnblogs.com/alex-wei/p/dp_tricks.html)。这个点肯定是叶子，因为多选免费苹果一定更优。

设 $f$ 表示当前可以继续往下延伸免费苹果的背包数组，$g$ 表示不可以再向下延伸免费苹果的背包数组，则对于 $u$ 及其子节点 $v$，$f_u \otimes f_v\to g_u$，$f_u\otimes g_v\to g_u$，$g_u\otimes g_v \to g_u$。很遗憾，如果用树上依赖性背包，我们会发现上面三种转移无法合并，必须向下递归三个子问题。也就是说，每层将凭空多出来一个背包数组。这个方法行不通。

换种角度，想象一棵树，每个儿子按访问顺序从左到右排列，则从根到叶子的路径将整棵树劈成两半，左边和右边时间戳分别连续。对于中间有特殊部分的问题，套路地维护前后缀再合并。又因为树上依赖背包可以算出每个时间戳前缀的答案，所以可行。

因此，设 $f_i$ 表示考虑到时间戳前缀 $i$ 的答案，满足时间戳为 $i$ 的节点 $rev_i$ 到根的路径上所有节点还没有被加入背包。$g_i$ 同理表示后缀。求出 $f, g$ 后枚举每个节点 $i$，则相当于合并 $f_{dfn_i}$，$g_{dfn_i}$ 和 $i$ 到根上所有节点 $j$ 在 $a_j$ 减掉 $1$ 之后的背包 $h_i$，得到一个大背包 $K$，则 $K_k$ 加上 $i$ 到根上所有节点的 $v$ 之和的最大值即为答案。

这样还是不太行，因为 $K_k$ 需要 $k ^ 2$ 的时间。考虑将 $h$ 巧妙地融合到 $f$ 或 $g$ 当中，发现设 $f_i$ 满足 $rev_i$ 到根的路径上所有节点 $j$ 暂时只考虑了 $a_j - 1$ 个苹果，且这 $a_j - 1$ 个苹果不强制至少选一个，即可满足条件。也就是说，进入 $j$ 时只不强制必须选地加入 $a_j - 1$ 个苹果，回溯时再强制加入最后一个苹果。

单调队列优化多重背包，时间复杂度 $\mathcal{O}(nk)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using uint = unsigned int;
// using lll = __int128;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using ull = unsigned long long;
inline ll read() {
  ll x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
inline void print(ll x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
constexpr int N = 2e4 + 5;
constexpr int K = 5e5 + 5;
int n, k, fa[N], a[N], v[N], s[N];
int ans, hd, tl, d[K], val[K];
vector<int> e[N], f[N], g[N];
void dfs1(int id) {
  s[id] = s[fa[id]] + v[id];
  hd = 1, tl = 0;
  for(int i = 0; i <= k; i++) {
    int c = f[id][i] - i * v[id];
    while(hd <= tl && c >= val[tl]) tl--;
    d[++tl] = i, val[tl] = c;
    while(hd <= tl && d[hd] <= i - a[id]) hd++;
    f[id][i] = val[hd] + i * v[id];
  }
  g[id] = f[id];
  for(int it : e[id]) {
    f[it] = f[id], dfs1(it);
    for(int i = 0; i <= k; i++) f[id][i] = max(f[id][i], f[it][i]);
  }
  for(int i = k; i; i--) f[id][i] = f[id][i - 1] + v[id];
}
void dfs2(int id) {
  for(int i = 0; i <= k; i++) ans = max(ans, f[id][i] + g[id][k - i] + s[id]);
  for(int it : e[id]) {
    f[it] = f[id], dfs2(it);
    for(int i = 0; i <= k; i++) f[id][i] = max(f[id][i], f[it][i]);
  }
  d[hd = tl = 0] = 0, val[0] = 0;
  for(int i = 1; i <= k; i++) {
    int c = f[id][i] - i * v[id];
    while(hd <= tl && d[hd] < i - a[id]) hd++;
    f[id][i] = val[hd] + i * v[id];
    while(hd <= tl && c >= val[tl]) tl--;
    d[++tl] = i, val[tl] = c;
  }
  f[id][0] = 0;
}
void solve() {
  cin >> n >> k, ans = 0;
  for(int i = 1; i <= n; i++) {
    cin >> fa[i] >> a[i] >> v[i];
    e[fa[i]].push_back(i);
  }
  for(int i = 1; i <= n; i++) f[i].resize(k + 1), g[i].resize(k + 1);
  dfs1(1);
  for(int i = 1; i <= n; i++) reverse(e[i].begin(), e[i].end());
  for(int i = 1; i <= n; i++)
    for(int j = 0; j <= k; j++)
      f[i][j] = 0;
  dfs2(1), cout << ans << "\n";
  for(int i = 1; i <= n; i++) {
    e[i].clear();
    vector<int> ().swap(f[i]);
    vector<int> ().swap(g[i]);
  }
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T;
  cin >> T;
  while(T--) solve();
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/10/2
author: Alex_Wei
start coding at 6:25
finish debugging at 9:00
*/
```

---

## 作者：wukaichen888 (赞：12)

题解区做法均为根据中间链拆两半分别 dp，本文讲述一种直接 dp 的做法。

树上依赖背包，考虑类似 [P12444](https://www.luogu.com.cn/problem/P12444) 和 [P6326](https://www.luogu.com.cn/problem/P6326) 的 trick。

即提取先序遍历，在 dfn 序上顺序做背包，若是不选则跳到子树外。

本题多了扣掉最大深度的条件。考虑弱化条件，任意位置可以选择扣掉当前深度。那么开两个 dp 数组，扣掉当前深度就转移到另一个 dp 数组，分别跑上面的背包。

具体地，一维表示当前在 dfn 中的位置，一维表示当前花费的代价，前者 $\le n$，后者 $\le n+k$。

但是你发现这是 $O(n(n+k))$ 的，题目居然没限制 $n^2$。

注意到 dp 数组中很多位置没用，将当前花费的代价对深度做差，然后 $\le k$，就 $O(nk)$ 了。

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define ll long long
const int N=2e4+5,M=5e5+5,inf=50000000;
int T,n,k,V,par[N];
int dfn[N],rev[N],dep[N],nxt[N],siz[N],l1;
vector<int>v[N],f0[N],f1[N],g0,g1;
struct node{int cnt,val;}b[N],pre[N];
void dfs1(int x){
	pre[++l1]=b[x];siz[x]=1;dfn[x]=l1;rev[l1]=x;
	for(int i=0;i<v[x].size();i++){dep[v[x][i]]=dep[x]+1;dfs1(v[x][i]);siz[x]+=siz[v[x][i]];}
	nxt[dfn[x]]=dfn[x]+siz[x];
}
int que[N+M],head,tail;
inline void chx(int &x,int y){x=max(x,y);}
signed main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&k);V=k;
		g0=g1=vector<int>(V+2,-inf);
		for(int i=1;i<=n+1;i++) f0[i]=f1[i]=vector<int>(V+2,-inf);
		l1=0;
		for(int i=1;i<=n;i++){scanf("%d%d%d",&par[i],&b[i].cnt,&b[i].val),v[par[i]].push_back(i);b[i].cnt=min(b[i].cnt,V);}
		dep[1]=dep[n+1]=1,dfs1(1);
		for(int i=0;i<=V;i++) f0[1][i]=f1[1][i]=0;
		for(int i=1;i<=n;i++){
			pre[i].cnt--;
			for(int j=0;j<=V;j++){
				if(j+dep[rev[i]]-dep[rev[nxt[i]]]<=V)
					chx(f0[nxt[i]][j+dep[rev[i]]-dep[rev[nxt[i]]]],f0[i][j]);
				chx(f1[nxt[i]][j],f1[i][j]);
			}
			for(int j=0;j<=V;j++) g0[j]=g1[j]=-inf;
			for(int j=0;j<=V;j++) chx(g0[j],f0[i][j]+pre[i].val);
			head=1,tail=0;
			for(int j=0;j<=V;j++){
				while((head<=tail)&&(que[head]<j-pre[i].cnt)) head++;
				while((head<=tail)&&(g0[que[tail]]+pre[i].val*(j-que[tail])<=g0[j])) tail--;
				que[++tail]=j; g1[j]=g0[que[head]]+pre[i].val*(j-que[head]);}
			for(int j=0;j<=V;j++) chx(g0[j],g1[j]);
			
			for(int j=0;j<=V;j++)
				if(j+dep[rev[i]]+1-dep[rev[i+1]]<=V)
					chx(f0[i+1][j+dep[rev[i]]+1-dep[rev[i+1]]],g0[j]);
			for(int j=0;j<=V;j++) chx(f1[i+1][j],g0[j]);
			
			
			for(int j=0;j<=V;j++) g0[j]=g1[j]=-inf;
			for(int j=0;j<V;j++) chx(g0[j+1],f1[i][j]+pre[i].val);
			head=1,tail=0;
			for(int j=0;j<=V;j++){
				while((head<=tail)&&(que[head]<j-pre[i].cnt)) head++;
				while((head<=tail)&&(g0[que[tail]]+pre[i].val*(j-que[tail])<=g0[j])) tail--;
				que[++tail]=j; g1[j]=g0[que[head]]+pre[i].val*(j-que[head]);}
			for(int j=0;j<=V;j++) chx(g0[j],g1[j]);
			
			for(int j=0;j<=V;j++) chx(f1[i+1][j],g0[j]);
		}
		int res=0;
		for(int i=0;i<=k;i++) chx(res,f1[n+1][i]);
		printf("%d\n",res);
		for(int i=0;i<=n+1;i++) v[i].clear(),f0[i].clear(),f1[i].clear();
	}
	return 0;
}

```

---

## 作者：王鲲鹏 (赞：12)

# [SDOI2017]苹果树 解题报告
截至2020-11-12 rank1/cy。
以下是我的又臭又长的解题报告...主要是我自己的思考和总结...会比较细，~~更不可读~~。有问题欢迎d我

发现了几个很妙的处理方式，总结一下。

题意是在树上做一个多重背包，如果这个点选择了至少一个，父节点至少要选一个。同时允许在一条到根的链上每个点免费选一个。

我觉得最妙的地方是在处理那条免费链上。以前我见过的在树上dp状态都类似于这个子树选了什么，这道题就不一样了。因为dfs是有个顺序的，如果把先dfs到的画在左边，后dfs到的画在右边，那一条到叶子的链会把这棵树分为左右两半，就可以考虑像处理前缀和后缀那样来设状态。

具体来说，设 $F[x][i]$ 表示在dfs序上考虑到了点  $x$，其中 $x$ 到根的链上最多选了$a_i-1$个，一共选择了 $i$ 个物品所得到的最大价值；设 $G[x][i]$ 表示在反着dfs得到的dfs序上考虑到点 $x$ ，其中 $x$ 到根的链上一个都不选，一共选择了 $i$ 个的最大价值。这两个定义是差不多对称的，而且还要满足除了 $x$ 到根的这条链上的点，其他所有的点如果子节点选了，自己也一定选了。

这样设的好处是我们对每个叶子 $x$，可以直接用 $F[x][i]+G[x][k-i]+S_x$ 来更新答案，其中 $S_x$ 表示 $x$ 到根路径上点的价值和。一定是满足父节点限制的，因为除了 $x$ 到根的点，其他点都满足了，而现在强制选了 $x$ 到根的链。

具体考虑怎么dp。应该是有两种写法。

第一种是直接一边dfs一边dp。先说对 $F$ 。如果现在处于 $x$，要递归子节点 $y$。那就把 $x$ 的背包复制到 $y$，然后在 $y$ 时，首先把自己的 $a_y-1$ 个尝试去更新背包（为什么减一见后文），继续递归，最后回到 $x$ 时，需要决策是否选择 $y$ 及其子树中可能选的那些。因为现在 $y$ 的背包中已经决策过它的子节点们，而背包里选了些什么，具体选了几个我们是不知道的，但我们知道如果我们选了 $y$，$y$ 这个物品就至少得选 $1$ 个，才能满足了父节点限制。用 $F[y][i-1]+v_y$ 去更新 $F[x][i]$。

对于 $G$，对父节点限制的解决方法是一样的。与 $F$ 的区别仅在于我们要求这条链是不选的。又因为我们更新完答案之后也就可以破坏这个性质，所以如果没有子节点，更新答案；有子节点就在考虑完子节点后用 $a_x-1$ 个物品去更新背包。



这种对父节点至少选一个的解决方法是也是我觉得很妙的地方。

第二种写法就是先求出后缀dfs序，然后在上面dp。这种方法应该会常数小一点。回头再考虑一下第一种，您~~（其实是我）~~也许有疑问，这样用 $x$ 更新 $y$，回来又拿 $y$ 更新 $x$ ，不会不满足无后效性吗？

但稍加思考，我们状态的定义是在 dfs 序上，其实是子节点有了一个很新的版本，然后父节点发现自己过时了，拿过来先把自己更新一下，再去更新下一个子节点罢了。

如果我们直接从dfs的上一个点拉过来，不是更省事exp(/youl)...我感觉这就是在dfs序上直接dp的方法...~~没写，说错了别打我/kk~~。


最后还有一个要注意的是，每个背包是 $k+1$ 大的...所以空间是 $n(k+1)$，只开 $nk$ 会 TLE+RE...

代码

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
int const maxn = 20003, maxk = 500003, NK = 25020003;
inline int read() {
	int x = 0, c = 0;
	while (c < '0' || '9' < c) c = getchar();
	while ('0' <= c && c <= '9') x = 10 * x + c - '0', c = getchar();
	return x;
}
int n = 0, k = 0;
int a[maxn], v[maxn], fa[maxn];
int head[maxn], nxt[maxn];
inline void add(int u, int e) { nxt[e] = head[u]; head[u] = e; }
int F[NK], G[NK];
inline int index(int i, int j) { return (i - 1) * (k + 1) + j; }
int ans = 0;
inline void bag(int *f, int A, int V) {
	if (A <= 0) return;
	static int q[maxk], p[maxk];
	int ql = 1, qr = 0;
	for (int i = 0; i <= k; ++i) {
		f[i] -= i * V;
		while (ql <= qr && f[q[qr]] <= f[i]) --qr;
		q[++qr] = i;
		while (ql <= qr && i - q[ql] > A) ++ql;
		p[i] = f[q[ql]] + i * V;
	}
	memcpy(f, p, (k + 1) * sizeof(int));
}
void dfsL(int x) {
	bag(F + index(x, 0), a[x] - 1, v[x]);
	for (int i = head[x]; i; i = nxt[i]) {
		memcpy(F + index(i, 0), F + index(x, 0), (k + 1) * sizeof(int));
		dfsL(i);
		for (int j = 1; j <= k; ++j)
			F[index(x, j)] = max(F[index(x, j)], F[index(i, j - 1)] + v[i]);
	}
}
void dfsR(int x, int sum) {
	sum += v[x];
	for (int i = head[x]; i; i = nxt[i]) {
		memcpy(G + index(i, 0), G + index(x, 0), (k + 1) * sizeof(int));
		dfsR(i, sum);
		for (int j = 1; j <= k; ++j)
			G[index(x, j)] = max(G[index(x, j)], G[index(i, j - 1)] + v[i]);
	}
	if (head[x] == 0) {
		for (int j = 0; j <= k; ++j)
			ans = max(ans, F[index(x, j)] + G[index(x, k - j)] + sum);
	}
	bag(G + index(x, 0), a[x] - 1, v[x]);
}
int main() {
	int T = read();
	while (T--) {
		n = read(); k = read();
		ans = 0;
		int const rt = 1;
		for (int i = 1; i <= n; ++i) head[i] = 0;
		for (int i = 1; i <= n; ++i) {
			fa[i] = read(); a[i] = read(); v[i] = read();
			if (fa[i] != 0)
				add(fa[i], i);
		}
		memset(F + index(rt, 0), 0, (k + 1) * sizeof(int));
		memset(G + index(rt, 0), 0, (k + 1) * sizeof(int));
		dfsL(rt);
		for (int i = 1; i <= n; ++i) head[i] = 0;
		for (int i = n; i >= 1; --i) if (fa[i] != 0) add(fa[i], i);
		dfsR(rt, 0);
		printf("%d\n", ans);
	}
	return 0;
}
```



---

## 作者：Otomachi_Una_ (赞：9)

我们考虑化简条件，$t-h\leq k$，也就是 $t\leq h+k$，换句话说取得苹果数不大于最大深度加一个常数。

我们发现不大于和最大这两玩意太啰嗦了，转换成选一条到 $1$ 的链，取得苹果数不多于这条链深度加上一个常数。

换句话说也就是免费取一条链每个节点上的一个苹果，其余部分在这条链的基础上拓展取 $k$ 个苹果。显然这条取的链肯定直接到达某个叶子。

那么对于拓展取得苹果我们可以分为以下几个部分：

- 原来在链上的。
- 在链左边的。
- 在链右边的。

对于第一种情况，注意到一个隐含条件就是要取第 $2,3,\dots$ 个水果，首先要取第 $1$ 个水果。这个我们选了儿子必选父亲的感觉很像，我们可以考虑树上原来的节点只挂一个苹果，每个原节点新增一个儿子节点当分身，存储剩下的 $a_u-1$ 个苹果。这样子，取原树上的链就会被全部取走，也就不存在情况一了。

举个栗子，比如原树是下面这样子（每个点第一个数表示苹果个数，第二个数表示价格）：

![](https://cdn.luogu.com.cn/upload/image_hosting/x5g4bn9e.png)

我们可以建成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/dl1hicnd.png)

这样子，比如我们要取原树 $(2,3)$ 到 $(1,1)$ 的路径直接取就行了。

然后整棵树就会被分为好多瓣，总体来说有左和右的区别：

![](https://cdn.luogu.com.cn/upload/image_hosting/v18y0tba.png)

上图当中选择 $1\to 13$ 的链会把图分成左右两部分的节点，我们要对两部分单独求解即可。

很大的问题是这两部分点的编号不连续，不太好做。

实际上我们使用**跳栈顺序**（即 dfs 的出栈顺序）可以把左边的节点编号搞到连续，比如上图当中的跳栈顺序如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/2tqwg5fg.png)

读者不难发现无论哪一条根到叶子的链，左边的节点总是连续的，证明不难。同理，把每个点遍历的顺序反过来也可以得到右边连续编号。

现在的问题就是对每个前缀，求拿了 $k$ 个苹果的最大收益。这玩意显然是个多重背包，以左边节点为例：

- 如果当前编号 $u$ 不选，那么其子树都不能选，$f_{u,k}\leftarrow f_{u-siz_u,k}$。
- 如果选择 $u$，那么枚举使用的次数，$f_{u,k}\leftarrow \max_{k-t\leq a_u} f_{u-1,t}+(k-t)\times v_u$

第二种情况是标准的单调栈维护多重背包。

时间复杂度：$\mathcal O(nk)$。轻微卡常。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
const int MAXN=40005;
vector<int> son[MAXN];
vector<int> f[MAXN],g[MAXN];
int n,k,tot;
int siz[MAXN],dfnl[MAXN],dfnr[MAXN];
int ls[MAXN],rs[MAXN],dep[MAXN];
int a[MAXN],v[MAXN];
int st[MAXN<<4],le,ri;
void dfs(int *dfn,int *s,int u){
	siz[u]=1; 
	for(int i:son[u]){dep[i]=dep[u]+v[i];dfs(dfn,s,i);siz[u]+=siz[i];}
//	cout<<tot<<' '<<u<<endl;
	dfn[++tot]=u;s[u]=tot;
	return; 
}
void solve(){
	cin>>n>>k;
	for(int i=1;i<=2*n;i++) son[i].clear();
	for(int i=0;i<=2*n;i++){f[i].clear();f[i].resize(k+1);g[i].clear();g[i].resize(k+1);} 
	for(int i=1;i<=n;i++){
		int f;cin>>f>>a[2*i-1]>>v[2*i-1];
		v[2*i]=v[2*i-1];a[2*i]=a[2*i-1]-1;a[2*i-1]=1;
		if(f) son[2*f-1].push_back(2*i-1);
		son[2*i-1].push_back(2*i);
	}
	tot=0;dfs(dfnl,ls,1);
	for(int i=1;i<=2*n;i++)
		reverse(son[i].begin(),son[i].end());
	dep[1]=v[1];tot=0;dfs(dfnr,rs,1);
	for(int i=1;i<=2*n;i++){
//		cout<<"dpf"<<i<<endl;
		f[i]=f[i-siz[dfnl[i]]];
		le=1,ri=1;st[1]=0;
		for(int j=1;j<=k;j++){
			while(le<=ri&&j-st[le]>a[dfnl[i]]) le++;
			if(le<=ri) f[i][j]=max(f[i][j],f[i-1][st[le]]+(j-st[le])*v[dfnl[i]]);
			while(le<=ri&&f[i-1][st[ri]]-st[ri]*v[dfnl[i]]<=f[i-1][j]-j*v[dfnl[i]]) ri--;
			st[++ri]=j;
		}
	}
	for(int i=1;i<=2*n;i++){
		g[i]=g[i-siz[dfnr[i]]];
		le=1,ri=1;st[1]=0;
		for(int j=1;j<=k;j++){
			while(le<=ri&&j-st[le]>a[dfnr[i]]) le++;
			if(le<=ri) g[i][j]=max(g[i][j],g[i-1][st[le]]+(j-st[le])*v[dfnr[i]]);
			while(le<=ri&&g[i-1][st[ri]]-st[ri]*v[dfnr[i]]<=g[i-1][j]-j*v[dfnr[i]]) ri--;
			st[++ri]=j;
		}
	}
	int ans=0;
	for(int i=1;i<=2*n;i++)
		if(siz[i]==2){
			for(int j=0;j<=k;j++)
				ans=max(ans,f[ls[i]-2][j]+g[rs[i]-1][k-j]+dep[i]);
		}
	cout<<ans<<endl;
	for(int i=0;i<=2*n;i++)
		f[i].clear(),f[i].shrink_to_fit(),g[i].clear(),g[i].shrink_to_fit();
}
signed main(){
//	freopen("apple1.in","r",stdin);
	ios::sync_with_stdio(false);
	int _;cin>>_;
	while(_--) solve();
}
```

---

## 作者：喵仔牛奶 (赞：5)

# Solution

深度的条件可以转化为免费选一条链，得到链每个点上的一个苹果。

考虑枚举这条链，链将苹果分为三类：链上每个点的一个免费苹果，链左边的与链上剩余付费苹果，链右边的付费苹果。第一类可以简单处理出每个点到根路径上的价值和，对于第二三类考虑 DP 后对每条链合并。

设 $f_{i,k,j}$ 为考虑根到节点 $i$ 的链及其左边的，$i$ 的前 $k$ 棵子树里的，除去链上每个点免费的苹果，摘了 $j$ 个最大的价值。转移分两种：
- 父亲将链及左边转移给儿子：枚举 $u$ 的每个儿子 $v$，设 $v$ 为 $u$ 从左到右的第 $t$ 个儿子。先将 $f_{u,t-1}$ 的值拷贝给 $f_{v,0}$，然后加入 $v$ 的苹果，对 $f_{v,0}$ 跑多重背包（可以不选）。由于要减去一个免费的，所以只能加入 $a_{v}-1$ 个苹果。转移后递归 $v$ 的子树。
- 儿子将子树转移给父亲：沿用上文的 $u,v,t$。递归 $v$ 的子树后，更新 $f_{u,t}$。由于 $v$ 处不一定选了苹果，所以要强制加入一个 $v$ 苹果来更新：$\displaystyle f_{u,t,j}=\max\{f_{u,t-1,j},f_{v,\operatorname{sonsize}(v),j-1}+val_{v}\}$。

实现的时候不用记第二维。多重背包要用单调队列优化，如果您不会可以先去学习 [P1776 宝物筛选 ](https://www.luogu.com.cn/problem/P1776)。

同理，设 $g_{i,k,j}$ 为考虑根到节点 $i$ 的链**右边**的（不包括这条链），$i$ 的**后** $k$ 棵子树里的的苹果，摘了 $j$ 个最大的价值。转移类似：
- 父亲将链右边转移给儿子：枚举 $u$ 的每个儿子 $v$，设 $v$ 为 $u$ 从右到左的第 $t$ 个儿子。将 $g_{u,t-1}$ 的值拷贝给 $g_{v,0}$，然后递归 $v$ 的子树。
- 儿子将子树转移给父亲：沿用 $u,v,t$。递归 $v$ 的子树后，复制一份 $tmp=g_{v,\operatorname{sonsize}(v)}$，用 $v$ 节点上的苹果对 $tmp$ 跑多重背包（不能不选），然后来更新 $g_{u,t}$ 即可：$\displaystyle g_{u,t,j}=\max\{g_{u,t-1,j},tmp_{j}\}$。

为了方便，实现时 $a_{v}$ 次不能不选的背包可以转化成 $a_{v}-1$ 可以可以不选的背包与最后一次必选。

时间复杂度 $\mathcal{O}(nk)$。

# Code
```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
    typedef vector<LL> poly;
	const int N = 2e4 + 5;
	int n, k, u, v, ans, a[N], val[N], sum[N], siz[N];
	vector<int> G[N], f[N], g[N];
	void update(vector<int>& f, int c, int v) {
		vector<int> g(f.size()); deque<int> q;
		for (int i = 0; i <= k; i ++) {
			while (!q.empty() && i - q.front() > c) q.pop_front();
			while (!q.empty() && f[i] - v * i > f[q.back()] - v * q.back()) q.pop_back();
			q.push_back(i), g[i] = f[q.front()] + v * (i - q.front());
		}
		g.swap(f);
	}
	void dfs1(int u, int fa) {
		update(f[u], a[u] - 1, val[u]);
		sum[u] = sum[fa] + val[u], siz[u] = 1;
		for (int v : G[u]) {
			if (v == fa) continue;
			f[v] = f[u], dfs1(v, u), siz[u] += siz[v];
			for (int i = 1; i <= k; i ++)
				f[u][i] = max(f[u][i], f[v][i - 1] + val[v]);
		}
	}
	void dfs2(int u, int fa) {
		reverse(G[u].begin(), G[u].end());
		for (int v : G[u]) {
			if (v == fa) continue;
			g[v] = g[u], dfs2(v, u);
			vector<int> tmp(g[v]);
			update(tmp, a[v] - 1, val[v]);
			for (int i = 1; i <= k; i ++)
				g[u][i] = max(g[u][i], tmp[i - 1] + val[v]);
		}
	}
	int main() {
		cin >> n >> k;
		for (int i = 1; i <= n; i ++) {
			cin >> u >> a[i] >> val[i];
			if (u) G[u].pb(i), G[i].pb(u); 
		}
		f[1].resize(k + 2), g[1].resize(k + 2);
		dfs1(1, 0), dfs2(1, 0);
		for (int i = 1; i <= n; i ++) {
			if (siz[i] > 1) continue;
			for (int j = 0; j <= k; j ++)
				ans = max(ans, f[i][j] + g[i][k - j] + sum[i]);
		}
		cout << ans << '\n';
		return 0;
	}
	void clear() {
		f[1].clear(), g[1].clear(), ans = 0;
		for (int i = 1; i <= n; i ++) G[i].clear();
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
    int T = 1; cin >> T;
    while (T --) Milkcat::main(), Milkcat::clear();
    return 0;
}
```

---

## 作者：zxcen (赞：4)

## [P3780 [SDOI2017]苹果树](https://www.luogu.com.cn/problem/P3780)

~~SDOI 阴间本色~~

第一次写 dfs 序 dp，写了整一天 qwq，写篇题解记录一下。

### 题意

$Q$ 组数据，在 $n$ 个点的树上做多重背包，容量为 $k$，节点物品数为 $a_i$，价值为 $v_i$，可以免费选最深的一条链。

- $Q\leq5$
- $n\leq2\times 10^4$
- $k\leq5 \times 10^5$
- $nk\leq2.5\times 10^7$
- $1\leq v_i\leq100$
- 时限 $5s$
- 空间限制 $500MB$

### 分析

首先背包容量增大这一条件可以转化成免费选从根开始一条链，然后在长度不超过这条链的链上选物品，所以我们有一个暴力的想法是枚举每条链为最长链然后在整棵树上做背包，但是这样复杂度是 $O(n^2k)$ 的。

这时候我们就可以考虑根据 dfs 序 dp，预处理出来对于每个节点从前到后跑儿子的 dfs 序和从后到前跑儿子的 dfs 序的 dp 数组然后对于每条链把以它为最长链的答案拆成：

链本身

正 dfs 序上 dfs 序小于它的

反 dfs 序上 dfs 序小于它的

但是这时候我们就会发现一件尴尬的事情——这样直接 dp 会使我们无法统计在最长链上节点选多于 $1$ 个物品的贡献。所以我们需要在多记一个 dp 数组吗?

其实不用，我们可以将每个点拆点拆成一个只有一个物品的点表示钦定最长链包含这个点是必须要选的点，和一个有 $a_i-1$ 个物品的点，然后我们再用后序做 dfs 序进行 dp。为什么要用后序呢？因为我们已经考虑过的点在后序上是连续的一段，即下图中蓝色圈出的部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/07do2kid.png)

状态为 $f_{i,j}$ 表示考虑到 $i$ 点，选了 $j$ 个物品的最大价值。

转移考虑两种情况一种是在当前子树内不选点，另一中是在子树内选点，然后我们发现可以直接从 dfs 序为当前点 dfs 序 $-1$ 的点转移过来，并用单调队列维护一下。

### 注意事项

本题需要将 dp 数组压到一维

本题因为不用开 long long 所以空间是够用的

本题虽然不卡常但是写的时候还是需要注意一下常数问题，有一些卡常小技巧：
- 每遍初始化的时候只清理用过的。
- 如果你用的是 vector 存图，每遍清 vector 的时候可以参考 shadowice1984 大佬的方法，新开一个 vector 然后 swap。
- 使用快读
- 减少乘法操作
- 少用或者不用 **stl**。

### 代码

```cpp
#include<bits/stdc++.h>
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)

using namespace std;
const int inf=6e7;
int T;
int n,k,idx;
int fa,u,tmp,res,pos1,pos2;
vector<int>g[40001];
int a[40001],v[40001];
int dfn1[40001],red1[40001],dfs_num1=0,dfn2[40001],red2[40001],dfs_num2=0;
int siz[40001],s[40001];
int f1[inf],f2[inf];
int q1[1000001],q2[1000001],fr,t;
bool lf[40001];
char buf[1<<25],*p1=buf,*p2=buf;
inline void read(int &x){
	x=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	return ;
}
inline void clear(vector<int>&tmp){
	vector<int>neww;
	swap(neww,tmp); 
}
inline int _max(int a,int b){
	return a<b?b:a;
}
inline void dp(int *red,int *f){
	for(int i=1;i<=idx;++i){
		u=red[i];
		fr=t=1;
		q1[1]=q2[1]=0;
		pos1=i*(k+1);
		pos2=(i-siz[u])*(k+1);
		for(int j=1;j<=k;++j){
			tmp=f[pos1-k-1+j]-j*v[u];
			q1[fr]<j-a[u]?++fr:0;
			f[pos1+j]=_max(q2[fr]+j*v[u],f[pos2+j]);
			while(fr<=t&&q2[t]<=tmp){
				--t;
			}
			q1[++t]=j;
			q2[t]=tmp;
		}
	}
	return ;
}
inline void pre(int u,int fa){
	s[u]=s[fa]+v[u];
	siz[u]=1;
	for(int i=0;i<g[u].size();++i){
		pre(g[u][i],u);
		siz[u]+=siz[g[u][i]];
	}
	dfn1[u]=++dfs_num1;
	red1[dfs_num1]=u;
}
inline void bac(int u,int fa){
	for(int i=g[u].size()-1;~i;--i){
		bac(g[u][i],u);
	}
	dfn2[u]=++dfs_num2;
	red2[dfs_num2]=u;
}
int main(){
	read(T);
	while(T--){
		read(n);
		read(k);
		idx=n;
		for(int i=1;i<=n;++i){
			read(fa);
			read(a[i]);
			read(v[i]);
			lf[fa]=true;
			g[fa].push_back(i);
			if(a[i]^1){
				a[++idx]=a[i]-1;
				v[idx]=v[i];
				a[i]=1;
				g[i].push_back(idx);
			}
		}
		pre(1,0);
		bac(1,0);
		dp(red1,f1);
		dp(red2,f2);
		res=0;
		for(int i=1;i<=n;++i){
			if(lf[i]){
				continue;
			}
			pos1=(dfn1[i]-1)*(k+1);
			pos2=(dfn2[i]-siz[i])*(k+1);
			for(int j=0;j<=k;++j){
				res=_max(res,f1[pos1+j]+s[i]+f2[pos2+k-j]);
			}
		}
		printf("%d\n",res);
		dfs_num1=dfs_num2=0;
		for(int i=1;i<=idx;++i){
			clear(g[i]);
			lf[i]=false;
		}
		for(int i=(idx+1)*(k+1);~i;--i){
			f1[i]=f2[i]=0;
		}
	}
	return 0;
}
```

---

## 作者：陈刀仔 (赞：3)

利用dfs序设状态DP。

这题最重要的地方是把题目条件翻译成人话，不难发现题目要求中选苹果的覆盖情形是若干从根出发的链组成的，**并且若取走一个苹果的费用是 $1$ ，则我们可以免费在我们最深的一条链的每一个点上各取一个苹果**。

那么我们的方案就必须取决于最深的那一条链，考虑枚举最深链，那么我们能考虑的答案来源于四部分：链上免费部分，链上付费部分，树的链左部分，树的链右部分。

后三个部分都可以考虑DP，链上显然可以背包，树的链左、链右部分我们也考虑DP。

**DFS出栈序有个有意思的性质，链左、链右部分节点的出栈序是一段连续区间（画个图）**，设出 $dp[i][j]$ 表示考虑出栈序在 $[1,i]$ 中的节点，选择 $j$ 个苹果的最大价值。


画个图分析一下一段出栈序前缀的节点的排布方式，必然是一些分散的子树，且都蹭在一条链上（画个图），且假设当前出栈序前缀是 $[1,i]$，那么 $i$ 对应的节点一定是最后一棵子树的根节点。

那么设这个根节点（当前考虑到的点）是 $x$，它有两种情况，要么选，要么不选。如果不选，那么 $x$ 子树内的点都不能选，只能够从在它之前最后一个遍历完的子树转移过来，这个子树的根节点出栈序是 $i-siz[x]$。如果选了，那么它的子树内所有节点都可以纳入考虑范围，就可以从 $dp[i-1][...]$转移来，那么可以得到如下方程：

$$ dp[i][j]=dp[i-1][j] $$
$$dp[i][j]=\max_{k=1}^{num[i]}\{dp[i-1][j-k]+k*val[x]\} $$

这个多重背包的过程可以用单调队列优化。


这样DP完，我们只要枚举完最深链，再把三个背包合并一下就好，$\mathcal{O(nk^2)}$。

明显过不了，发现瓶颈是最后合并背包的过程，考虑优化。直观上来说链左和链右都很难优化掉，考虑优化链付费部分。

我们利用题目的选苹果条件来改造一下树的结构，拆个点，把一个点 $(x,num[x])$ 拆成 $(x,1)$，和儿子 $(x',num[x]-1)$，要选大于 $1$ 个苹果的先决条件是先选了一个苹果，这也满足题目中的选苹果的父子限制关系，照样DP。

这样我们枚举最深链时不经过新点，链上苹果数都是 $1$ ，自然去掉了链付费部分，我们合并背包的过程就可以被优化，复杂度 $\mathcal{O(nk)}$。

---

## 作者：robertuu (赞：2)

 [题目传送门](https://www.luogu.com.cn/problem/P3780)

~~$5$ 秒时限？！一看就不是什么友善的东西，肯定巨卡常~~

## 简化版题意

给出一棵有 $n$ 个节点的树，树上的每一个节点都有 $a_i$ 个价值为 $v_i$ 的物品。如果要选择 $i$ 号节点的物品，就必须至少选择一个其父节点的物品（子节点的选择依赖于父节点）。求出最多选 $ \max (dep_y) + k $（$y$ 为选择了物品的节点，$dep$ 为点的深度）个物品可以得到的最大价值。

## 题目分析

由于选择物品的节点存在儿子对父节点第一个物品的依赖关系（只有父节点第一个物品被选择了才能选择儿子），因此第一个物品有比其他物品更高的重要性，可以考虑将一个 $a_i > 1$ 的节点拆为两个节点，第一个节点在原节点的位置上，$a = 1$，$v = v_i$，拥有原来这个节点的所有儿子（依赖关系），第二个节点作为第一个节点的一个子节点，它没有儿子，$a = a_i - 1$，$v = v_i$，相当于原节点的第 $2$ 到 $a_i$ 个元素（可以视为这些元素与第 $1$ 个元素也具有依赖关系）。这样就可以把一个节点选多个也转换成父子之间的以来关系。

这道题另一个比较恶心的点是：最多选 $ \max (dep_y) + k $ 个物品。对于这一点，可以使用贪心思想，因为 $v_i > 0$，所以只要能多选点就尽量多选，如果一次选择中深度最深的点不是叶子结点，那么可以将这个点的一个儿子选中一个物品，最大深度增加 $1$，这个多选择的物品可以视为是免费送的，同理，我们可以视为从这个最深点到根节点的所有点都是免费送的（包括根节点）。

根据这一点，可以确定这道题的一大核心思路：枚举每个叶子结点，求出将这个叶子节点到根的路径设为“免费链”时，在其他点中“付费”选择 $k$ 个物品（不用担心选择了深度更深的点，这次可以先视为那些点都是付费的，更到以那些点为免费叶子时再更新答案即可），求出能得到的最大价值。**注意这个叶子节点一定是拆点前的叶子**（拆点后是 $a_i = 1$ 的那个，这些点组成的树才是原始的树，拆出的另一个点可以看成是一个虚拟的点）。

由于遍历了免费链的时间复杂度为 $O(n)$，必须要在 $O(k)$ 的时间内求出在其他点中选择 $k$ 个的最大收益。

可以发现这句话的描述很像背包问题，其实它的确可以转化为多重背包。免费链相当于一座“墙”，将树的左右两侧割裂了，因此可以考虑分别求左右两侧选 $x$ 的最大价值，在统计答案时通过扫描给两侧分多少更新答案。

我们可以发现：对这棵树使用前序遍历时，一条链右侧的点的 `dfs` 序（时间戳）是连续的；后续遍历时，一条链左侧的时间戳是连续的。由于右侧会造成倒序循环等不必要的麻烦，我们采用后序遍历。（想使得右侧的连续怎么办？把树左右颠倒一下右侧的就到左侧了）

终于，到了树形多重背包的环节了！定义 $dp_{i,j}$ 表示后序遍历的前 $i$ 个点选择了 $j$ 个物品的最大价值（这里的物品体积都是 $1$），状态转移的决策也很好想，就是要么选 $1$ 至 $a_i$ 个，要么一个都不选（要从 $i$ 号点的子树时的状态进行转移）。转移方程是：

$dp_{i,j} = max(dp_{i-1,j-x}+v_i \times x,dp_{i-sz[i],j})$，$sz[i]$ 为节点 $i$ 的子树节点数（包括拆出的虚拟节点）

这样就能保证一定满足依赖性（有些点的父亲没被选，因为它的父亲是免费点）。

由于 $O(nk)$ 的复杂度已经相当高了（毒瘤的数据范围：$nk ≤ 2.5 \times 10^7$），必须使用[**单调队列优化**多重背包](https://www.luogu.com.cn/problem/P1776)的写法（二进制优化多了个 $\log$，在这道题的数据范围下一定过不了），毕竟这道题体积为 $1$，单调队列也比标准版好些不少，只是由于要用到 $i-sz[i]$，不能用滚动数组压空间。

到这里~~这道题~~分析应该算是结束了。

## 细节问题

这个题有很多细节~~和卡常~~问题

- 数组中和节点个数有关的内容一律要开到 $2n$，因为拆点后点数会翻倍。

- 二维的 $dp_{i,j}$ 开不下（$n$，$k$ 都较大），需要压成一维，把 $dp_{i,j}$ 通过进制对应到 $dp_{i \times (k+1)+j}$，数组需要开到**比 $2nk$ 大一些**（$2n+1$ 行，$k+1$ 列），反正 $500$ 兆内存能开下 $1.6 \times 10^8$ 的整型数组。

- 选中的叶子结点也可能存在分身节点，这个分身节点根据后序遍历的性质是在正序处理时计算的，倒序（左右颠倒后）处理时需要把这个点减掉，以免重复计算。

- **多组数据一定要清空数组！！！**

- **更新答案时必须得是叶子再更新，否则会出错！**

如果被**卡常**了的话一定要注意：

一定不要用 `cin` 和 `cout` 输入输出（这个提的输入规模还是挺大的）,推荐用 `scanf` 和 `printf`；尽量不要用 `STL`（如动态数组和双端队列），`STL` 有常数。但是很可惜，这道题为了实现左右颠倒，存树要用邻接表，需要用到 `STL` 的 `vector`，访问的时候尽量把要多次调用的值用临时变量存下来（访问有常数），清空的时候选择直接 `clear` 和 `swap` 都可以（`clear` 重置大小比释放内存，`swap` 只交换首地址的迭代器，都是 $O(1)$ 的）。

----

最后上代码：

~~抵制复制题解代码 AC 黑题人人有责~~

代码有注释，只是稍微有点长
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;
vector<int> e[40001]; // 由于需要左右对称一下，不能用前向星
int n,k,ex,a[40001],v[40001];
int dfn1[40001],rdfn1[40001],dfn2[40001],rdfn2[40001],qzh[40001],sz[40001],dfn;
bool flag[40001];
void dfs1(int x) // 正序dfs
{
	sz[x] = 1;
	int tmp = e[x].size(); // 防止size过慢（卡常）
	for(int i = 0;i < tmp;i++)
	{
		qzh[e[x][i]] = qzh[x] + v[e[x][i]]; // 更新链上权值和
		dfs1(e[x][i]);
		sz[x] += sz[e[x][i]]; // 更新节点子树大小
	}
	dfn1[x] = ++dfn; // 后序遍历
	rdfn1[dfn] = x;
}
void dfs2(int x) // 逆序dfs
{
	int tmp = e[x].size(); // 防止size过慢（卡常）
	for(int i = tmp-1;i >= 0;i--) dfs2(e[x][i]); // 倒序循环
	dfn2[x] = ++dfn; // 后序遍历
	rdfn2[dfn] = x;
}
struct node {int id,x;} q[1100001];
int dp1[60000001],dp2[60000001]; // dp必须要压成一位，否则空间不够
void getdp1()
{
	for(int i = 1;i <= n+ex;i++)
	{
		int head = 1,tail = 1; // 初始化单调队列
		q[1] = (node){0,0};
		for(int j = 1;j <= k;j++)
		{
			int A = a[rdfn1[i]],V = v[rdfn1[i]],SZ = sz[rdfn1[i]];
			//head += (q[head].id<j-min(A,j))?1:0;
			while(head <= tail && q[head].id < j-min(A,j)) head++; // 队首越界失效
			if(head <= tail) dp1[i*(k+1)+j] = max(q[head].x + j*V,dp1[(i-SZ)*(k+1)+j]); // 队首还存在
			else dp1[i*(k+1)+j] = dp1[(i-SZ)*(k+1)+j];
			while(head <= tail && q[tail].x <= dp1[(i-1)*(k+1)+j]-j*V) tail--; // 队尾不符合单调性
			q[++tail] = (node){j,dp1[(i-1)*(k+1)+j]-j*V}; // 将新点加入单调队列
		}
	}
}
void getdp2()
{
	for(int i = 1;i <= n+ex;i++)
	{
		int head = 1,tail = 1; // 初始化单调队列
		q[1] = (node){0,0};
		for(int j = 1;j <= k;j++)
		{
			int A = a[rdfn2[i]],V = v[rdfn2[i]],SZ = sz[rdfn2[i]];
			//head += (q[head].id<j-min(A,j))?1:0;
			while(head <= tail && q[head].id < j-min(A,j)) head++; // 队首越界失效
			if(head <= tail) dp2[i*(k+1)+j] = max(q[head].x + j*V,dp2[(i-SZ)*(k+1)+j]); // 队首还存在
			else dp2[i*(k+1)+j] = dp2[(i-SZ)*(k+1)+j];
			while(head <= tail && q[tail].x <= dp2[(i-1)*(k+1)+j]-j*V) tail--; // 队尾不符合单调性
			q[++tail] = (node){j,dp2[(i-1)*(k+1)+j]-j*V}; // 将新点加入单调队列
		}
	}
}
int main()
{
	int qq;
	scanf("%d",&qq);
	while(qq--)
	{
		int x,y,z;
		scanf("%d%d",&n,&k);
		for(int i = 1;i <= n;i++) e[i].clear(); // 多测要清空
		memset(flag,0,sizeof(flag)); // 多测要清空
		memset(dp1,0,sizeof(dp1)); // 多测要清空
		memset(dp2,0,sizeof(dp2)); // 多测要清空
		ex = 0; // 多测要清空
		for(int i = 1;i <= n;i++)
		{
			scanf("%d%d%d",&x,&a[i],&v[i]);
			flag[x] = 1; // 父节点不是叶子
			e[x].push_back(i); // 父亲指向儿子的边
			if(a[i] > 0) // 是多重点，拆点
			{
				a[n+(++ex)] = a[i]-1; a[i] = 1;
				v[n+ex] = v[i];
				e[i].push_back(n+ex); // 把新点当做原本点的儿子
			}
		}
		qzh[1] = v[1]; // 根节点的链和
		dfn = 0; dfs1(1); dfn = 0; dfs2(1); // 进行正反两次dfs，求出后序编号
		getdp1(); getdp2(); // 动态规划（单调队列优化下的树上拆点多重背包）
		int ans = 0;
		for(int i = 1;i <= n;i++)
			if(!flag[i]) for(int j = 0;j <= k;j++) // 是叶子就更新
				ans = max(ans,dp1[(dfn1[i]-1)*(k+1)+j]+dp2[(dfn2[i]-2)*(k+1)+k-j]+qzh[i]);
		printf("%d\n",ans);
	}
	return 0;
}
```
[record](https://www.luogu.com.cn/record/120911486)

完结撒花~~~

感谢各位管理们！！

---

## 作者：yanchengzhi (赞：2)

## [SDOI 2017 苹果树](https://www.luogu.com.cn/problem/P3780)（转化，树形依赖背包）

首先问题可以转化为可以免费选一条从根出发的链，再对剩下部分做一次**树形依赖背包**。

先考虑一般的树形依赖背包怎么做。

求出 $\text{dfs}$ 序后设 $f(i,j)$ 表示 $\text{dfs}$ 序上 $i$ 到 $n$，选择 $j$ 个物品的最大值，有转移
$$
f(i,j)=\max(f(i+\text{sz}(i),j),\max_{k>0}f(i+1,j-k))
$$
能这样转移是因为在 $\text{dfs}$ 序上一个点子树的 $\text{dfs}$ 序对应一段区间。

下面再来思考这道题怎么做。

由之前的分析，树形依赖背包需要在 $\text{dfs}$ 序上 $\text{dp}$，那么我们可以考虑设 $f(i,j)$ 表示 $\text{dfs}$ 序考虑到点 $i$，选了 $j$ 个**需要花费空间**的物品的最大值，且根到 $i$ 的这条链作为**免费链**，**依赖关系**只考虑了**非免费链上的点**。

接下来考虑点 $u$ 怎么转移到其它点，假设 $v$ 是 $u$ 的儿子。

首先，如果 $v$ 是 $u$ 的第一个儿子，那么 $v$ 肯定也在**免费链**上，直接 $\mathcal{O}(k)$ 多重背包转移即可（要用双端队列优化）。

如果 $v$ 不是 $u$ 的第一个儿子，很明显我们不能直接转移，因为前面的子树内的点不在免费链上，我们需要考虑它们的**依赖关系**。

我们考虑在 $\text{dfs}$ 完 $u$ 的一个儿子后修改 $f(u,*)$，即考虑那个儿子与它的依赖关系。

注意到这样一个性质，免费链的端点一定是一个**叶子**，于是我们可以直接修改 $f(u,*)$（其实新开一个数组也可以，这样写只是为了实现方便）。

设 $b_i$ 表示节点 $i$ 的权值，于是有转移
$$
f(u,i)=\max(f(u,i),f(v,i-1)+b_v)
$$
即我们钦定必须选择一个节点 $v$（结合代码理解）。

总复杂度 $\mathcal{O(nk)}$。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxN = 20005;
const int maxK = 500005;
const int maxNK = 26000005;
int S, f[maxNK], g[maxNK];
int n, k, tote, ans, head[maxN], a[maxN], b[maxN], fa[maxN], dis[maxN];
int q[maxK], tmp[maxK];
struct edge {
	int to, nxt;
} e[maxN];
void add(int u, int v) {
	e[++tote].to = v;
	e[tote].nxt = head[u];
	head[u] = tote;
}
void work(int *F, int A, int B) {
	if(A == 0) {
		return;
	}
	int l = 0, r = -1;
	memcpy(tmp, F, S);
	for(int i = 1; i <= k; i++) {
		while(l <= r && i - q[l] > A) {
			l++;
		}
		while(l <= r && tmp[i - 1] - B * (i - 1) >= tmp[q[r]] - B * q[r]) {
			r--;
		}
		q[++r] = i - 1;
		if(l <= r) {
			F[i] = max(F[i], tmp[q[l]] + B * (i - q[l]));
		}
//		for(int j = max(0, i - A); j < i; j++) {
//			F[i] = max(F[i], tmp[j] + B * (i - j));
//		}
	}
}
void dfs1(int u) {
	work(f + u * (k + 1), a[u], b[u]);
	for(int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		memcpy(f + v * (k + 1), f + u * (k + 1), S);
		dfs1(v);
		int *x = f + u * (k + 1) + 1;
		int *y = f + v * (k + 1);
		for(int j = 1; j <= k; j++, x++, y++) {
			*x = max(*x, *y + b[v]);
		}
	}
}
void dfs2(int u, int from) {
	dis[u] = dis[from] + b[u];
	for(int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		memcpy(g + v * (k + 1), g + u * (k + 1), S);
		dfs2(v, u);
		int *x = g + u * (k + 1) + 1;
		int *y = g + v * (k + 1);
		for(int j = 1; j <= k; j++, x++, y++) {
			*x = max(*x, *y + b[v]);
		}
	}
	if(!head[u]) {
		int *x = f + u * (k + 1) + k;
		int *y = g + u * (k + 1);
		for(int i = 0; i <= k; i++, x--, y++) {
			ans = max(ans, *x + *y + dis[u]);
		}
	}
	work(g + u * (k + 1), a[u], b[u]);
}
void solve() {
	S = (k + 1) * sizeof(int);
	memset(f + k + 1, 0, S);
	memset(g + k + 1, 0, S);
	tote = 0;
	for(int i = 1; i <= n; i++) {
		a[i]--;
		head[i] = 0;
	}
	for(int i = 1; i <= n; i++) {
		if(fa[i]) {
			add(fa[i], i);
		}
	}
	dfs1(1);
	tote = 0;
	for(int i = 1; i <= n; i++) {
		head[i] = 0;
	}
	for(int i = n; i >= 1; i--) {
		if(fa[i]) {
			add(fa[i], i);
		}
	}
	ans = 0;
	dfs2(1, 0);
	cout << ans << '\n';
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T;
	cin >> T;
	for(int i = 1; i <= T; i++) {
		cin >> n >> k;
		for(int j = 1; j <= n; j++) {
			cin >> fa[j] >> a[j] >> b[j];
		}
		solve();
	}
	return 0;
}

```

---

## 作者：lnzwz (赞：2)

首先，观察题意，可以发现在最长链下再接一个点，结果一定更优。

也就是说，可以免费选一条最长链，之后正常选。

我们枚举选的最长链，然后算出剩下部分的最优解。

有4部分：

1、链上每个点都选一个。

2、链上剩下的部分。

3、链的左面。

4、链的右面。

1可以直接计算。

那么，我们需要先进行树形背包，然后再通过某方式将其余3个合并。

我们知道，在此问题中，合并2个背包是$O(k)$的；

但3个及以上则是$O(k^2)$的，无法承受。

所以，我们只能在计算中就把其中两个合并，这样就只需合并2个了。

可以发现，3和4是正常的树形背包，而2是一个贪心的问题。

但是，我们没有时间给链上的点排序，再贪心选择。

所以，只能将2转为正常的树形背包问题。

可以这样想：选x则要选fx，选x的第二个则要选x的第一个。

那么，我们可以把大于1的拆点，拆成1和a-1。连上父子关系。

不难发现，这样我们就只需要3,4两个合并了。所以，只要算出3,4部分，就

能$O(k)$出解了。

先考虑如何进行树形背包：

树形背包有2种实现：dfs合并的和dfs序上dp的。

由于本题每个节点上有多个，所以之前的$O(nk)$的分析不适用，复杂度是$O(nk^2)$，显然超时。

而且，复杂度的瓶颈合并背包至少是$O(k^2)$的，这个是max卷积，不能优化。
所以，这种方法不行。

但是，由于我们不需要知道每个节点的子节点的选择信息（如每个点选择了多少子树节点），

所以，可以考虑dfs序上dp的算法。[见博客](https://www.cnblogs.com/lnzwz/p/11519977.html)

这个算法的状态数是$O(nk)$的，且相当于逐渐添加，没有合并背包。

添加的过程是一个多重背包(由于每个节点上有多个)，可以用单调队列优化。这部分可以做到$O(nk)$。

而且，我们发现：对于问题3，4（即树链的左右），在dfs序上是一段连续区间。这意味着我们可以直接得出3,4的dp值。

对树做先序遍历，可以得到链的右面（后缀）。对树做后遍历，可以得到链的左面（前缀）。

总结下：

首先，拆点。

然后，对树进行先后序遍历，并用多重背包的单调队列优化算出dp值，$O(nk)$。

最后，枚举一个**叶子**，在$O(k)$时间算出结果，总共$O(nk)$。

此外，对于子节点，在3,4两部分都会被算到，要注意排除。

注意卡常。

代码：

```cpp
#include <stdio.h> 
#define inf 999999999
#define setdp(i, j, x) dp[i * (k + 1) + j] = x
#define getdp(i, j) dp[(i) * (k + 1) + j]
#define getod(i, j) ld[(i) * (k + 1) + j] 
int fr[40010],ne[40010],v[40010],bs = 0,sl[40010],sz[40010],n,k;
void addb(int a, int b) {
	v[bs] = b;
	ne[bs] = fr[a];
	fr[a] = bs++;
}
int xl[40010],si[40010],jl[40010],tm = 0,x1[40010],x2[40010];
void dfs1(int u) {
	x1[u] = tm;
	xl[tm++] = u;
	si[u] = 1;
	for (int i = fr[u]; i != -1; i = ne[i]) {
		jl[v[i]] = jl[u] + sz[v[i]];
		dfs1(v[i]);
		si[u] += si[v[i]];
	}
}
void dfs2(int u) {
	for (int i = fr[u]; i != -1; i = ne[i]) dfs2(v[i]);
	xl[++tm] = u;
	x2[u] = tm;
}
int dl[500010],dz[500010],he = 0,ta = 0,dp[60000010],ld[60000010];
void insert(int i, int x) {
	dz[i] = x;
	while (he < ta && dz[dl[ta - 1]] <= x) ta -= 1;
	dl[ta++] = i;
}
void del(int i) {
	if (he < ta && dl[he] == i) he += 1;
}
int getma() {
	if (he < ta) return dz[dl[he]];
	else return - inf;
}
bool ez[20010],kz[20010];
int main() {
	int T;
	scanf("%d", &T);
	while (T--) {
		scanf("%d%d", &n, &k);
		bs = 0;
		for (int i = 1; i <= n + n; i++) fr[i] = -1;
		for (int i = 1; i <= n; i++) ez[i] = kz[i] = false;
		for (int i = 1; i <= n; i++) {
			int a;
			scanf("%d%d%d", &a, &sl[i], &sz[i]);
			if (i > 1) addb(a, i);
			ez[a] = true;
		}
		for (int i = 1; i <= n; i++) {
			if (sl[i] > 1) {
				sl[i + n] = sl[i] - 1;
				sz[i + n] = sz[i];
				addb(i, i + n);
				sl[i] = 1;
				kz[i] = true;
			}
		}
		jl[1] = sz[1];
		tm = 0;
		dfs1(1);
		for (int i = tm - 1; i >= 0; i--) {
			he = ta = 0;
			for (int j = 0; j <= k; j++) {
				int u = xl[i],
				ma = getdp(i + si[u], j);
				del(j - sl[u] - 1);
				if (j > 0) insert(j - 1, getdp(i + 1, j - 1) - sz[u] * (j - 1));
				int t = getma() + sz[u] * j;
				if (t > ma) ma = t;
				setdp(i, j, ma);
			}
		}
		for (int i = 0; i <= tm * (k + 1) + k; i++) {
			ld[i] = dp[i];
			dp[i] = 0;
		}
		tm = 0;
		dfs2(1);
		for (int i = 1; i <= tm; i++) {
			he = ta = 0;
			for (int j = 0; j <= k; j++) {
				int u = xl[i],
				ma = getdp(i - si[u], j);
				del(j - sl[u] - 1);
				if (j > 0) insert(j - 1, getdp(i - 1, j - 1) - sz[u] * (j - 1));
				int t = getma() + sz[u] * j;
				if (t > ma) ma = t;
				setdp(i, j, ma);
			}
		}
		int jg = -inf;
		for (int i = 1; i <= n; i++) {
			if (ez[i]) continue;
			int ma = -inf;
			for (int j = 0; j <= k; j++) {
				int t = getod(x1[i] + 1, j);
				if (!kz[i]) t += getdp(x2[i] - 1, k - j);
				else t += getdp(x2[i + n] - 1, k - j);
				if (t > ma) ma = t;
			}
			ma += jl[i];
			if (ma > jg) jg = ma;
		}
		printf("%d\n", jg);
		for (int i = 0; i <= tm * (k + 1) + k; i++) ld[i] = dp[i] = 0;
	}
	return 0;
}
```

---


# [HAOI2015] 数组游戏

## 题目描述

有一个长度为 $n$ 的数组，甲乙两人在上面进行这样一个游戏：首先，数组上有一些格子是白的，有一些是黑的。然后两人轮流进行操作。

每次操作选择一个白色的格子，假设它的下标为 $x$。接着，选择一个大小在 $1\ldots \lfloor\dfrac{n}{x}\rfloor$ 之间的整数 $k$，然后将下标为 $x,2\times x,\ldots ,k\times x$ 的格子都进行颜色翻转。不能操作的人输。

现在甲（先手）有一些询问。每次他会给你一个数组的初始状态，你要求出对于这种初始状态他是否有必胜策略。

## 说明/提示

#### 样例输入输出 1 解释

在第一个询问中，甲选择点 $1$，然后将格子 $1\times 1$ 和 $2\times 1$ 翻过来即可。

第二个询问中，无论甲选择哪个点，都只能翻掉一个格子。乙只需翻掉另一个格子就行了。

#### 数据规模与约定

对于 $30 \%$ 的数据，$N \leq 20$；    
对于 $50 \%$ 的数据，$N \leq 10^6$；    
对于 $70 \%$ 的数据，$N \leq 10^7$；    
对于 $100 \%$ 的数据，$N \leq 10^9$，$K,W \leq 100$，不会有格子在同一次询问中多次出现。

## 样例 #1

### 输入

```
3
2
2
1 2
2
2 3```

### 输出

```
Yes
No```

# 题解

## 作者：sbno333 (赞：30)

# 博弈论公平组合游戏从入门到这道入土题。

sbno333 手把手教你 sg 函数。

## 前言

2025.8.2 更新：删除一些问题，添加复杂度证明，添加笔者最新理解。

发现其它题解写的并不清晰，缺少一些证明，导致在看题界的时候遇到了极大的困难，同时为了纪念首 A 黑题，所以有了这篇题解。

首先，不是所有游戏都要用到博弈论知识，很多游戏递推解决即可，但有些游戏需要用到，具体按情况而论，一般的，看着像 Nim 游戏的都是递推（诈骗）或者贪心之类的东西，看着和 Nim 半毛钱没有的是博弈论。

## 前置知识

动态规划思想，异或，整数分块，$\text{mex}$，可以上 [OI 维基](https://oi.wiki)自主学习。

## 游戏

我们考虑有两个人（Alice 和 Bob）玩游戏，只有输和赢，并且不没有同输同赢的情况，游戏保证无论二人如何操作，都不会一直无法停止。现在，二人绝对聪明，谁赢？

事实上，除去 [最长待机](https://www.luogu.com.cn/problem/P10222) 这种难评的游戏，都在最开始确定了胜负。

我们可以把每种游戏可能形成的局面设成一个状态。

每个状态都向一步之后能到的状态连一条有向边，由于保证能不会无法停止，所以没有环，此时游戏形成了一个 dag。

我们可以设 $dp_S$ 表示 $S$ 状态下，Alice 是否必胜，必胜是 $1$，否则是 $0$。

对于走投无路的节点，我们判定其 $dp_S$ 的值，然后向前递推。

具体的，我们状态中记录此时谁先手，然后根据谁先手，在所有状态中到达的状态中，取最大或最小值即可。

然而游戏一般状态很多，公平组合游戏具有一定优秀的性质，能够帮我们大幅降低复杂度。

## 一般公平组合游戏

两个人轮流操作，没有平局，每个人每次能进行的操作与人无关，并且能结束。比如国际象棋就不是这类游戏，因为它有平局，而且你只能动自己的棋子，不能动对方的，无法操作的一方输。

### sg 函数

在这之前，我们应当学习 Nim 游戏，这个游戏在博弈论学习中起到**极其重要**的地位。

#### Nim 游戏

[如题](https://www.luogu.com.cn/problem/P2197)，有 $n$ 堆石子，每堆石子有若干个石子，不能不取，每次可以选取一堆石子，取走若干石头。

下文中用 $\oplus$ 代替按位异或。

这道题有一个必胜策略就是当石子堆石子数量异或和为 $0$ 时，先手必败，否则必胜。

具体的，当异或和为 $0$ 时，显然我们操作后肯定改变了某个石堆，设其它石堆异或和为 $x$，这个石堆原本也一定为 $x$，改变后为 $y<x$，对于两个不同的数，其异或和一定不为 $0$，因此取完后为异或和不为 $0$。

对于不为 $0$，设这个值为 $x$，其最高位为 $1$，显然存在一个石堆，其和异或和的最高位对应也是 $1$，设其有 $y$ 个石子，此时其他石子堆异或和为 $x\oplus y$，由于 $x,y$ 在 $x$ 最高位都是 $1$，因此 $x\oplus y$ 那一位为 $0$。

我们此时只需要将 $y$ 变得使 $x=0$，即 $x\oplus y=y$，显然 $x\oplus y$ 不会随操作 $y$ 而改变（操作当前不会改变其他石子），可以这么操作当且仅当原来的 $y$ 比 $x\oplus y$ 大，这样才能将 $y$ 取到 $x\oplus y$。 

问题变成了 $y$ 异或上一个没有 $y$ 位数多，且那个数最高位 $y$ 对应位也是 $1$ 的数（上述提到的 $x$ 具有的性质）与其异或后能否比 $y$ 小。

对于比 $x$ 最高位高的位，显然异或后不改变，不考虑。

对于 $x$ 最高位，异或后 $y$ 对应位减少（从 $1$ 到 $0$)，其他位怎么增加也比不上，所以正确，即可以将异或和从 $\not=0$ 变为 $0$。

一个人输的时候显然石子堆异或和为 $0$，所以 $\not=0$ 时不为输的状态。

所以如果先手时异或和 $\not=0$，总是可以给到对方 $=0$，而对方又只能返回 $\not=0$，这样下先手必胜。

如果先手为 $0$，则只能把 $\not=0$ 给到对方，对方再采用上述策略，先手必败。

所以结论就是判断异或和是否为 $0$。

#### 从 Nim 升级开始代入 sg 定理

我们不妨升级 Nim 游戏，每次不但可以取走，还可以放入，但不能不操作，为了游戏的有限，每次放入后如果满足某个条件，之后双方将无法放入，而且每次放入对放入的数量有限制。

对于异或和 $\not=0$，显然可以看作只能减少，然后显然可以把异或和变为 $0$。

对于 $=0$，显然还是要改变，因此还是会重新变为 $\not=0$ 给对方。

因此这个游戏与上述普通 Nim 游戏必胜策略一致，**与放入的条件之类无关**，但当**减少有限制时，游戏结果或受到影响**。

####  sg 函数及定理

对于公平组合游戏，我们设置的状态可以是 $dp_S$ 表示局面初始为 $S$ 时，先手是否必胜。因为公平组合游戏我们并不关心当前到底是该谁操作。此时我们转移就只有简单的寻找能到达的状态中是否有 $0$，若有，则 $dp_S=1$，否则 $dp_S=0$。当然，此时还是复杂度很高。我们可以模拟 Nim 游戏进行考虑，这样我们或许能借用异或的性质来增速。设 $sg(S)$ 表示状态 $S$ 等价于 Nim 游戏中一个有 $sg(S)$ 个石子的石堆。如果 $S$ 状态指向 $P$ 集合中每一个状态，我们有 $sg(s)=\text{mex}_{T\in P} sg(T)$。由上面的升级 NIM 容易得出。如果不借助性质，此时 $sg(S)\not=0$ 对应原来的 $dp_S=1$，$sg(S)=0$ 对应原来的 $dp_S=0$。容易看出确实等价。不过 $sg(S)$ 有一个很大的性质，可以让我们优化转移。那就是如果当前状态 $S$ 可以分成若干**互不影响**的子游戏，每次选取一个子游戏进行操作，比如 Nim 取石子可以分成 $n$ 个子游戏，每个子游戏都是一堆石子，显然取走这堆石子不会影响其他石子堆。我们设这些子游戏组成集合 $G$。我们有 $sg(S)=\oplus_{T\in G}sg(T)$。

证明的话就是数学归纳法。对状态 $S$ 操作一次到的状态相当于对于 $T\in G$，对恰好一个 $T$ 进行一次操作。

根据上文，一个状态 $A$ 操作之后成为状态 $B$，只有 $sg(B)<sg(A)$ 才有意义，所以我们只保留这一种。

如果对 $S$ 操作一次之后，这个性质成立，根据数学归纳法，最终无法操作状态显然也只能分成若干无法操作的子游戏，便可以得证。

于是我们要证明的东西等价于如下问题：

一个序列 $a$ 的异或和为 $x$，请问对于任意 $0\le y<x$，是否存在 $t,p$，使得 $p<a_t$，并且将 $a_t$ 修改为 $p$ 之后序列异或和为 $y$。

我们分析一下，相当于 $x\oplus a_t\oplus p=y$。

推导可得 $(x\oplus y)\oplus a_t=p$。

因为 $y<x$。

因此存在某一位二进制，使得更高位二者相等，$x$ 这一位是 $1$，$y$ 是 $0$，异或和后就是这一位最高，因为原序列的异或和 $x$ 这一位是 $1$，因此必然能找到一个这一位是 $1$ 的数 $a_t$，异或和之后得到的 $p$ 这一位必定是 $0$，更高位和 $a_t$ 相等，因此 $p<a_t$，因此得证！

我们练习一下，尝试给出 Nim 游戏 sg 函数。

每堆石子都是一个子游戏，$0$ 个石子 sg 值为 $0$，$i$ 个石子可以转移为 $0\sim i-1$ 任意数量石子，数学归纳可以得出 sg 值为 $i$。具体的如果，$0\sim i-1$ 成立， $sg(i)=\text{mex}_{j=0}^{i-1} j=i$。

最后大游戏的 sg 就是每个子游戏 sg 的异或和，即石子数量的异或和。此时如果不是 $0$ 先手赢，否则后手赢。

我们梳理一下，一个游戏可以分成若干子游戏，每个子游戏为一个有向无环图，终点 sg 值为 $0$，每个节点为其后继的 $\text{mex}$，游戏的 sg 值为子游戏 sg 值的异或和，如果游戏的 sg 值为 $0$，先手必败，否则必胜。

这里给出一个性质：有 mex 得出某个状态的 sg 值一定在 $O(\sqrt m)$ 以内，其中 $m$ 为状态所在子游戏构成的图的边数。

## 这道题的正式题解

### 翻格子游戏的性质

我们设每次选择一个白色的格子 $i$，选择一个满足条件的 $k$，翻转 $S_{i,k}$ 集合内的格子，保证当前格子一定被翻转，且游戏能结束。

我们可以将游戏转化为每个格子有一个数，原游戏中白色初始是 $1$，黑色初始为 $0$。

每次可以选择一个非 $0$ 的数进行操作，当前数的值减一 ，$S_{i,k}$ 的其他数加一。

游戏中，显然白色对应奇数，黑格对应偶数，我们只需要证明这个游戏与原游戏等价（必胜判定相同）。

设原游戏先手为必胜方，显然可以按照原游戏策略进行，只翻转奇数，监督必败方是否也只反转奇数，如果翻转偶数，将其变为奇数，则先手再次对那个格子进行翻转，可以证明奇偶性可以与后手操作前一样，使得后手在奇偶性上操作无效，重新变回自己，而先手由于前提是必生，所以总有奇数可以翻，$0$ 是偶数，于是可以证明新游戏也是必胜方。

如果原先后手必胜，仿照上述，易证。

所以等价。

结论就是可以分成 $w$ 个子游戏，第 $i$ 个子游戏只有第 $i$ 原来的白格是 $1$ 其他都是 $0$。

而我们每次都是在一个子游戏上进行的，你可以能认为这仍然会互相影响，但其实不是，这个序列在现实中表现为每个子问题的序列对应位置的和，如果这个位置是 $0$，则子游戏都为 $0$，不能操作。否则一定能看作一个子游戏进行的一次操作，因此可以分解。

### 这道题目求 sg 的具体方法

于是这样我们就将其分解成了若干子游戏，并且始终存在分解方案，这时候我们不妨设 $sg(x)$ 表示只有 $x$ 为白格，我们考虑列式子。

我们选择 $k=1$，此时得到游戏结束状态，sg 为 $0$。

选择 $k=2$，此时转化为只有 $2x$ 为白色，为 $sg(2x)$。

选择 $k=3$，此时转化为 $2x,3x$ 为白色，不妨再次按照刚刚的结论分解，分解为只有 $2x$ 和只有 $3x$ 为白色两个子游戏，按照 sg 定理，答案为起点 sg 的异或和，所以此时为 $sg(2x)\oplus sg(3x)$。

以此类推。

于是我们得到了 $sg(x)=\text{mex}(0,\text{mex}_{i=2}^{\frac n x}\oplus_{j=2}^i sg(j))$，即 $sg(x)=\text{mex}(0,sg(2x),sg(2x)\oplus sg(3x),sg(2x)\oplus sg(3x)\oplus sg(4x)\dots)$。

我们可以从 $n$ 枚举到 $1$，暴力求出 $sg(i)$，可以做到 $O(w)$ 处理询问，但预处理时间复杂度高达 $O(n^2)$，不能接受。

于是考虑优化。

有一些 $sg(i)$ 可能是相同的，我们考虑这段优化。

#### 整数分块引入

可以发现，对于 $\lfloor\frac n x\rfloor=\lfloor\frac n y\rfloor$，有 $sg(x)=sg(y)$。

显然，它们 $\text{mex}$ 内部项数相同，对于每一项，我们发现如果 $sg(2x)=sg(2y),sg(3x)=sg(3y)\dots$，则猜想成立。

当 $x,y>\frac n 2$ 时，显然 $sg(x)=sg(y)=0$，且 $\lfloor\frac n x\rfloor=\lfloor\frac n y\rfloor$ 成立。

对于 $tx,ty$，如果 $\lfloor\frac n x\rfloor=\lfloor\frac n y\rfloor$ 成立，则 $\lfloor\frac n {tx}\rfloor=\lfloor\frac {\lfloor\frac{n}{x}\rfloor} {t}\rfloor=\lfloor\frac {\lfloor\frac{n}{y}\rfloor} {t}\rfloor=\lfloor\frac n {ty}\rfloor$，由于前者已经在题设中成立，因此结论成立，因此当 $tx>x,\lfloor\frac n {tx}\rfloor=\lfloor\frac n {ty}\rfloor$ 时，$sg(tx)=sg(ty)$ 成立，$sg(x)=sg(y)$ 可以推导成前式题设，对于 $t>1$ 都成立，$x$ 成立，由于当 $tx>\frac{n}{2}$ 时成立，因此对于 $x$ 成立。使用的~~嗜血~~**数学归纳法**，没看懂可以自行推导。

因此可以整数分块处理每一种 $\frac{n}{x}$，处理每一个也可以整数分块，对于 $\frac{n}{tx}=\frac{n}{px}$，显然 $sg(tx)=sg(px)$，因此内部也是根号，但由于外部循环枚举的不同，内部根号也不同，最后得 $O(n^\frac{3}{4})$ 时间复杂度。

证明：

看之前可以先移步整数分块复杂度证明。

对于每个 $x$，我们相当于要枚举 $k$ 等于 $2,3,4$ 一直到 $\lfloor\frac{n}{x}\rfloor$。

由于 $sg(x)$ 只取决于 $\lfloor\frac{n}{x}\rfloor$。

我们处理 $x$ 的复杂度相当于 $\lfloor\frac{n}{kx}\rfloor$ 有几种不同的值。

进一步的，$\lfloor\frac{\lfloor\frac{n}{x}\rfloor}{k}\rfloor$，根据整数分块，答案为 $O(\sqrt \frac{n}{x})$ 级别的。

当 $x$ 大于 $\sqrt n$ 时，只有 $\sqrt n$ 种 sg 可能不同的取值，$\sqrt \frac{n}{x}$ 最大取到 $O(n^{\frac{1}{4}})$，得到 $O(n^\frac{3}{4})$。

当 $x$ 小于等于 $\sqrt n$ 时，每个 $x$ 我们都觉得它能取到，那就是 $\sum_{x=1}^{\sqrt n}\sqrt \frac{n}{x}<\sum_{c=0}^{\log_2(\sqrt n)}2^c\sqrt \frac{n}{2^c}=\sqrt n \sum_{c=0}^{\log_2(\sqrt n)}\sqrt{2}^c=\sqrt n\frac{(\sqrt 2)^{\log_2 \sqrt n+1}-1}{\sqrt 2-1}=\sqrt n\frac{(2\sqrt {n})^{0.5}-1}{\sqrt 2-1}$。

得到 $O(\sqrt n\times n^{\frac{1}{4}})$ 得到 $O(n^\frac{3}{4})$。

#### 代码

```cpp
#include<bits/stdc++.h>//可以自行阅读理解
using namespace std;
int s[100009][2];
int n;
int sg(int x){
	if(x>sqrt(n))return s[n/x][0];return s[x][1];
}
int z[100009];
int inn;
int mex[2400009];
void inite(){
	for(int i=1,j=0;i<=n;i=j+1){
	j=n/(n/i);
		z[++inn]=j;
	}
	for(int t=inn;t>=1;t--){
		int yh;
		yh=0;
		mex[yh]=t;
		for(int i=z[t]*2,j;i<=n;i=j+z[t]){j=n/(n/i)/z[t]*z[t];
			mex[yh^sg(i)]=t;
			if(((j-i)/z[t]+1)&1){
				yh^=sg(i);
			}
		}
		int ans;
		ans=0;
		while(mex[ans]==t){
			ans++;
		}
		if(z[t]>sqrt(n))s[n/z[t]][0]=ans;
		else s[z[t]][1]=ans;
		
	}
}
signed main(){
    std::ios::sync_with_stdio(0);
    cin.tie(0);
	cin>>n;
	inite();
	int q;
	cin>>q;
	for(int i=1;i<=q;i++){
		int m;
		cin>>m;
		int yh;
		yh=0;
		for(int i=1;i<=m;i++){
			int x;
			cin>>x;
			yh^=sg(x);
		}
		cout<<(yh==0?"No":"Yes")<<endl;
	}
	return 0;
} 
```

## 拓展

* 反常游戏，无法操作的一方获胜，具体可以参考 OI 维基举得 Nim 游戏在反常下的值，对应 sg 函数合并求结果时按照反常 Nim 进行判断即可。

---

## 作者：VinstaG173 (赞：18)

感觉现有题解不太清楚……

### 前置知识：翻棋子游戏，SG函数的基本定义，整除分块（数论分块）。

这是翻棋子游戏没错。

翻棋子游戏的解法就是把初始状态的SG值即所有棋子的SG值异或和求出来，为0必败，否则必胜。

以上两句话是老生常谈。

首先棋子的对应一个数，其SG值就是这个数的SG值。

我们看看SG的定义。

设一个状态的后继状态的SG值构成的集合为$S$，那么这个状态的SG值为$mex\{S\}$，其中$mex\{S\}$是指不属于集合$S$的最小自然数。

我们现在要做的就是求每个数的SG值，首先得找出数$x$的后继状态。

我们假设只有$x$是白色。于是，我们可以选择翻$x,2x,\dots,kx$。翻完之后$x$会变黑，其他的会变白。

根据翻棋子游戏的解法，此时这个后继状态的SG值为现在的白色棋子的SG值异或和。由于只翻$x$时没有任何棋子是白色，故此后继状态SG值为$0$。其他后继状态的SG值分别为$SG(2x)$，$SG(2x) xor SG(3x)$，$\dots$，故我们得到当前的$S_x=\{0,SG(2x),SG(2x) xor SG(3x),\dots\}$。由于$2x,3x,\dots$均大于$x$，所以需要从大至小推SG值。

下面证明对于$\left\lfloor \dfrac{n}{x} \right\rfloor$相同的$x$有$SG(x)$相同。假设对$t>x$的$t$上述结论都成立。

我们知道$S_x=\{0,SG(2x),SG(2x) xor SG(3x),\dots\}$。对于$\left\lfloor \dfrac{n}{x} \right\rfloor=\left\lfloor \dfrac{n}{y} \right\rfloor$的$x,y$，容易发现$S_x$与$S_y$的大小均为$\left\lfloor \dfrac{n}{x} \right\rfloor$。对于$S_x$与$S_y$中的每个元素，由于$\left\lfloor \dfrac{n}{x} \right\rfloor=\left\lfloor \dfrac{n}{y} \right\rfloor$时有$\left\lfloor \dfrac{n}{tx} \right\rfloor=\left\lfloor \dfrac{\left\lfloor \frac{n}{x} \right\rfloor}{t} \right\rfloor=\left\lfloor \dfrac{\left\lfloor \frac{n}{y} \right\rfloor}{t} \right\rfloor=\left\lfloor \dfrac{n}{ty} \right\rfloor$。所以$S_x$和$S_y$完全相同。故$mex\{S_x\}=mex\{S_y\}$，即$SG(x)=SG(y)$。

然后知道了这点后我们就只要以整除分块的方式对$O(\sqrt{n})$个数求出SG值了。

又因为在$tx$中有一些可能满足$\left\lfloor \dfrac{n}{t_1x} \right\rfloor=\left\lfloor \dfrac{n}{t_2x} \right\rfloor$的$t_1,t_2$。所以再对$t$进行整除分块，设对于在范围$l_i \le t \le r_i$内的$t$有$\left\lfloor \dfrac{n}{tx} \right\rfloor$相同，则我们只需将此状态的SG值与当前维护的前缀异或和取异或得到的结果标记入$S_x$，然后再判断区间长度奇偶性，奇数则将前缀异或和异或上此状态的SG值，否则前缀异或和不变。

我们对于$>\sqrt{n}$的$x$将其SG值存储在另一个数组的$\left\lfloor \dfrac{n}{x} \right\rfloor$位置就可以只用数组解决问题了。预处理出SG就可以求解了。

但是复杂度较玄学，开O2能过。。。

Code:
```cpp
#include<cstdio>
#define rg register
int n,t,w,a;
int root,cnt,res;
int sg[2][400007],rt[400007],mrk[400007];
inline int SG(int x)
{
	return ((x=n/(n/x))>root)?sg[1][n/x]:sg[0][x];
}
inline void prework()
{
	for(rg int i=1,j;i<=n;i=j+1)
	{
		j=n/(n/i);rt[++cnt]=j;
	}
	++cnt;
	while(--cnt)
	{
		int x=rt[cnt],psg=0,rsg=1;mrk[psg]=cnt;
		for(rg int i=x+x,j;i<=n;i=j+x)
		{
			j=n/(n/i)/x*x,mrk[psg^SG(j)]=cnt;
			((j-i)/x&1^1)&&(psg^=SG(j));
		}
		while(mrk[rsg]==cnt)++rsg;
		(x>root)?sg[1][n/x]=rsg:sg[0][x]=rsg;
	}
}
int main()
{
	scanf(" %d %d",&n,&t);
	while(root*root<=n)++root;--root;
	prework();
	while(t--)
	{
		scanf(" %d",&w);res=0;
		while(w--)scanf(" %d",&a),res^=SG(a);
		printf("%s\n",res?"Yes":"No");
	}
	return 0;
}
```

---

## 作者：Autre (赞：7)

唉唉。垃圾题解毁选手。

$n$ 个黑白格子排成一排，每次可以选择一个编号为 $x$ 的**白色格子**和正整数 $k$，将编号为 $x,2x,3x,\cdots,kx$ 黑白反色。

首先这是一个公平游戏，若白代表 $1$，黑代表 $0$，将这排格子的状态从左到右写成一个二进制数，那么一次操作一定会导致这个二进制数减小，所以游戏一定在有限步操作内到达终止状态。

所以一贯的经验提示我们，能否将每个可操作的格子（即白格子）分开考虑。即将当前局面拆解为若干个“只有这个格子为白色，其余位置皆为黑色”的游戏的组合。

这样显然是有问题的。游戏的组合要求“这一步选择某个子游戏操作，不能影响其余子游戏的状态”。但是仅有格子 $x$ 为白色的游戏，和仅有格子为 $y$ 为白色的游戏，两者均存在一种后继状态使得 $xy$ 格子都是白色的，即它们的组合游戏中分别对一个子游戏做对应的操作后的组合游戏中，有两个子游戏都是“只有 $xy$ 格子为白色”。而 $x,y$ 均为白色的游戏中，给两个“子游戏”分别做一次使得 $xy$ 反色的操作后 $xy$ 其实是黑色的。

不过呢，经过这样的分析，我们又发现了其中的可疑之处——若干个游戏组合时，若其中两个子游戏等价，那么删掉这两个子游戏后 SG 值不变。从策略的角度说，先手在这个子游戏中进行了某步操作，后手一定可以仿照先手，在和先手操作的游戏等价的另一个游戏中做同样的操作。这样，这两个子游戏一定同时到达终止状态，不会对整个游戏局面产生任何影响。

也就是说上述的“两个子游戏都是‘只有 $xy$ 格子为白色’的局面”作为组合游戏的一部分，它的存在是不会产生什么影响的。而把这样成对的子游戏删掉后，这个被我们发明出来的组合游戏就变成了原游戏。

---

经过一通混沌的分析，我们改动这个游戏规则后发明了一个新游戏，然后发现这个游戏和原游戏是等价的。我们尝试写出这个游戏的形式：

长为 $n$ 的非负整数数列，每次可以选择一个不为 $0$ 的位置 $x$ 和一个正整数 $k$，给 $x$ 位置上的数减 $1$，给 $2x,3x,\cdots,kx$ 上的数加 $1$。

首先可以类似地得出，这个游戏是一个公平组合游戏。然后根据上面的分析，这个游戏是可以拆解为若干个“只有某个位置上的数为 $1$”的游戏的组合的。然后把每个位置上的数的奇偶性对应到这个题目中的黑白，显然两个问题的答案还是一样的。因为一个位置的数大于等于 $2$，那么每次先手以这个位置为 $x$ 做操作，后手都可以模仿地也对这个位置做操作。

于是可以简单地列出来其 SG 函数递推式。

剩下的整除分块套整除分块部分，其它题解写得勉强能看。

时间复杂度 $O(n^\frac34)$。轻松通过。

---

## 作者：zyn0309 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3179)
## 思路
先给一个结论，所有的白色格子 SG 函数值独立，也就是可以对每个白色各自单独考虑其它格子都为黑的 SG 函数值，然后异或起来。
### 证明
如下图，上面是原本的情况，下面是独立计算 SG 函数的情况。对 $1$ 和 $2$ 翻转后，原序列上从两个白变为了两个黑。而对于拆开后的情况，从两个位置上各有一个白色变为了第一个全都是黑色，第二个有两个白色，而同一个位置上多两个一样的状态，最后得到的 SG 函数值不变，因为两种状态可以做出的转移是一模一样的。

![证明图片](https://cdn.luogu.com.cn/upload/image_hosting/4704fter.png)

定义 $sg(x)$ 为只有 $x$ 一个白点的 SG 函数值。

容易发现对于两个点 $a$ 和 $b$，如果 $\lfloor \frac{n}{a} \rfloor=\lfloor \frac{n}{b} \rfloor$，那么 $sg(a)=sg(b)$，因为 $a$ 和 $b$ 的后继个数相同，且对于 $a$ 和 $b$ 的 $k$ 倍后继，有 $\lfloor \frac{n}{ka} \rfloor=\lfloor \frac{n}{kb} \rfloor$ ，即所有后继的后继个数也相同，所以 $a$ 和 $b$ 所有后继 SG 函数值相同。

然后就可以预处理 SG 函数值，暴力做法是枚举所有的数，然后枚举所有倍数。

类似的，可以用数论分块枚举数 $x$，把 $\lfloor \frac{n}{x} \rfloor$ 相同的 SG 值存到一起。（由于数组开不下，受到数论分块复杂度证明的启发，对于 $x \le \sqrt n$，下标为 $x$，否则下标为 $\lfloor \frac{n}{x} \rfloor$。）

枚举倍数时，设倍数为 $k$，则可以把 $\lfloor \frac{n}{kx} \rfloor$ 相等的 $k$ 再用一层数论分块处理，复杂度为 $O(n^{\frac{3}{4}})$，证明参考[杜教筛复杂度证明](https://oi.wiki/math/number-theory/du/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,sg1[N],sg2[N],limit,cnt[N];
#define pii  pair<int,int> 
#define pb push_back
#define mk make_pair
inline int get_sg(int x){
	if(x<=limit)return sg1[x];
	else return sg2[n/x];
}
inline void push_sg(int l,int r,int x){
	if(r<=limit){
	  for(int i=l;i<=r;++i)
		sg1[i]=x;
	}
	else sg2[n/l]=x;
}
inline void solve(){
	int len,x,ans=0;
	cin>>len;
	while(len--){
	  cin>>x;
	  ans^=get_sg(x);
	}
	if(ans)cout<<"Yes\n";
	else cout<<"No\n";
}
signed main(){
//	freopen("color.in","r",stdin);
//	freopen("color.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	limit=sqrt(n);
	vector<pii>q;
	for(int l=1;l<=n;++l){
	  int r=n/(n/l);
	  q.pb(mk(l,r));
	  l=r;
	}
	int len=q.size();
	cnt[0]=1;
	for(int i=len-1;i>=0;--i){
	  int now=0;
	  for(int l=2;l<=(n/q[i].second);++l){
		int r=(n/q[i].second)/((n/q[i].second)/l);
		now^=get_sg(l*q[i].second);
		++cnt[now];
		if(!((r-l+1)&1))now^=get_sg(l*q[i].second);
		l=r;
	  }
	  int sg=0;
	  while(cnt[sg])++sg;
	  now=0;
	  for(int l=2;l<=(n/q[i].second);++l){
		int r=(n/q[i].second)/((n/q[i].second)/l);
		now^=get_sg(l*q[i].second);
		--cnt[now];
		if(!((r-l+1)&1))now^=get_sg(l*q[i].second);
		l=r;
	  }
	  push_sg(q[i].first,q[i].second,sg);
	}
	int T;
	cin>>T;
	while(T--)solve();
	return 0;
}
```

---

## 作者：wangziyue_AK (赞：2)

## 前置知识:
#### SG 函数:
假如你并不了解可以在[我这里](https://www.luogu.com.cn/article/rumdvjxq)学习，如果你觉得我讲的不好也可以出门左转 OI-Wiki。
#### 整除分块：
要点：$ \lfloor \frac{n}{x}\rfloor$ 的不同取值只有 $O(\sqrt{n})$ 种，因为值小于根号的至多有根号种，而值大于根号时的合法 $x$ 又只有根号种。最大的使 $ \lfloor \frac{n}{x}\rfloor=v$ 的 $x$ 为 $ \lfloor \frac{n}{v}\rfloor$。
## 结论：
每一个白色格子都是独立的，即一个白色格子处的决策与 SG 函数与其他格子的状态无关。那么下文用 $SG(x)$ 表示下标为 $x$ 处有一个白格子，其他位置均为黑格的状态的 SG 值。这是翻棋子游戏或者叫翻硬币游戏的经典结论。
#### 证明：
因为一个白格子可能会影响其他白格的情况，当且仅当这个白格翻转后有产生与其他白格重合的白格。这时我们应把重合格视为黑格，但我们认为它是两个独立的白格。但这显然是等价的，因为这两个独立部分是相同的，SG 值异或和显然为 $0$，也就是说对这两个白格操作没有意义。感性理解就是一方操作了这两个白格中的一个，另一方可以立刻操作另一个，局势不发生变化。
## 简单暴力：
从后往前考虑，求出每一个白格出现在每一个位置时的 SG 值。对于一个白格，考虑枚举 $k$ 的值，此时的新状态 SG 值是 $SG(x+ix)$ （$1\le i \le k-1$）的异或和，最后再求出所有转移到的状态 SG 值加上一个 $0$（$k=1$ 时只把白格变没，不产生新白格）的 mex。复杂度显然是 $\sum_{i-1}^{n} \lfloor \frac{n}{i}\rfloor=O(n\log{n})$。
## 性质：
稍微观察一下题目可以发现，对于所以 $\lfloor \frac{n}{x}\rfloor$ 相同的 $x$，它们转移与后续状态本质相同，所以 SG 函数也相同，感性理解很合理。
## 正解：
只维护 $\lfloor \frac{n}{x}\rfloor$ 不同的根号个 $x$ 的 SG 函数，仍然按 $x$ 从大往小考虑。对于每一个 $x$ 考虑它的所有转移到的状态的 SG 值仍然有上述性质，所以可以考虑  $\lfloor \frac{n}{x}\rfloor$ 相同的后续状态一起计算，这一步也是一个整除分块。这样的整除分块套整除分块复杂度是 $O(n^{\frac{3}{4}})$ 次的，复杂度证明参考没有预处理的杜教筛。具体实现上大于根号的 SG 值以 $\lfloor \frac{n}{x}\rfloor$ 为下标，小于根号的直接以 $x$ 为下标存贮。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,q,x,s[N][2];
inline int sg(int x){
	if(x>sqrt(n)) return s[n/x][0];
	else return s[x][1];
}
int pos[N],cnt,mex[N<<2];
void init(){
	for(int l=1,r;l<=n;l=r+1){
		r=n/(n/l),pos[++cnt]=r;
	}
	for(int i=cnt;i;i--){
		int t=0,res=0;mex[0]=i;
		for(int l=pos[i]<<1,r;l<=n;l=r+pos[i]){
			r=n/(n/l)/pos[i]*pos[i],mex[t^sg(l)]=i;
			if(((r-l)/pos[i]+1)&1) t^=sg(l);
      //区间中有奇数个后继状态则SG值被异或了一次，否则相当于没异或
		}
		while(mex[res]==i) res++;
		if(pos[i]>sqrt(n)) s[n/pos[i]][0]=res;
		else s[pos[i]][1]=res; 
	}
}
int main(){
	scanf("%d%d",&n,&q);
	init();
	while(q--){
		scanf("%d",&m);
		int res=0;
		for(int i=1;i<=m;i++){
			scanf("%d",&x);
			res^=sg(x);
		}
		if(res) puts("Yes");
		else puts("No");
	}
	return 0;
}
```

---


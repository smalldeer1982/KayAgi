# [HNOI2010] 取石头游戏

## 题目描述

A 公司正在举办一个智力双人游戏比赛 - 取石子游戏，游戏的获胜者将会获得 A 公司提供的丰厚奖金，因此吸引了来自全国各地的许多聪明的选手前来参加比赛。

与经典的取石子游戏相比，A 公司举办的这次比赛的取石子游戏规则复杂了很多：

* 总共有 $N$ 堆石子依次排成一行，第 $i$ 堆石子有 $a_i$ 个石子。

* 开始若干堆石子已被 A 公司故意拿走。

* 然后两个玩家轮流来取石子，每次每个玩家可以取走一堆中的所有石子，但有一个限制条件：一个玩家若要取走一堆石子，则与这堆石子相邻的某堆石子已被取走(之前被某个玩家取走或开始被 A 公司故意拿走)。注意：第 $1$ 堆石子只与第 $2$ 堆石子相邻，第 $N$ 堆石子只与第 $N-1$ 堆石子相邻，其余的第 $i$ 堆石子与第 $i-1$ 堆和第 $i+1$ 堆石子相邻。

* 所有石子都被取走时，游戏结束。谁最后取得的总石子数最多，谁就获得了这场游戏的胜利。

作为这次比赛的参赛者之一，绝顶聪明的你，想知道对于任何一场比赛，如果先手者和后手者都使用最优的策略，最后先手者和后手者分别能够取得的总石子数分别是多少。


## 说明/提示

样例解释：两个玩家都使用最优策略时取走石子的顺序依次为 $9, 2, 1, 4, 7, 3$，因此先手者取得 $9 + 1 + 7 = 17$ 个石子，后手者取得 $2 + 4 + 3 = 9$ 个石子。

$30\%$ 的数据满足 $2\leq N\leq 100$。

$100\%$ 的数据满足 $2\leq N\leq 10^6$。


## 样例 #1

### 输入

```
8
1 2 0 3 7 4 0 9```

### 输出

```
17 9
```

# 题解

## 作者：lhm_ (赞：24)

考虑到先手和后手都使用最优策略，所以可以像对抗搜索一样，设 $val$ 为先手收益减去后手收益的值。那么先手想让 $val$ 尽可能大，后手想让 $val$ 尽可能小。

继续分析题目性质，发现取石子的过程可以转化为两端分别有一个栈，可以从栈顶取石子，中间有若干个双端队列，可以从其两端取石子。

如果取一个位置后，接下来的位置比刚才取的那个位置权值小，也就是从选择方向开始权值是递减的，每次决策肯定都是取当前局面权值最大的位置。如果不保证递减，就有可能取完一个位置后，使得一个权值更大的位置可以取，这时按最大值决策就有可能不是最优。

对于 $a_{i-1},a_i,a_{i+1}$，若其满足 $a_i \geqslant a_{i-1},a_i \geqslant a_{i+1}$，当一次决策选 $a_{i-1}$ 最优时，先手选 $a_{i-1}$，其后手一定会接着选 $a_i$，然后先手会接着选 $a_{i+1}$。选 $a_{i-1}$ 时，当前局面一定没有比 $a_{i-1}$ 更好的选择，而 $a_i$ 比 $a_{i-1}$ 更优，所以后手一定选 $a_i$，因为之前  $a_{i-1}$ 是最优的选择，所以先手会接着选 $a_{i+1}$。因此把 $a_{i-1},a_i,a_{i+1}$ 对 $val$ 的贡献看作整体，将其合并为一个权值为 $a_{i-1}+a_{i+1}-a_i$ 的石子。

合并完后所有的权值情况只存在递增，递减和下凹的情况了，这三个情况对于双端队列都是可以单调的从大到小选，对于从栈顶方向开始递减的栈的部分位置，也是可以单调的从大到小选，这些位置就可以直接排序后先后手一个一个选了。

而对于从栈顶方向开始递增的栈的部分位置，一定是最后才开始选的，因为这些决策一定是劣于其他决策，提前处理出其选择的结果，最后根据先后手的情况分配即可。

合并删除操作可以用链表来实现。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 2000010
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,sum,val,s,L,R,tot;
ll l[maxn],r[maxn],v[maxn];
bool tag[maxn];
bool cmp(const ll &a,const ll &b)
{
    return a>b;
}
int main()
{
    read(n),r[0]=1,l[n+1]=n;
    for(int i=1;i<=n;++i)
        read(v[i]),sum+=v[i],l[i]=i-1,r[i]=i+1,tag[i]=(v[i]!=0);
    for(int i=3;i<=n;i=r[i])
        while(tag[l[l[i]]]&&tag[l[i]]&&tag[i]&&v[l[i]]>=v[l[l[i]]]&&v[l[i]]>=v[i])
            v[i]=v[l[l[i]]]+v[i]-v[l[i]],r[l[l[l[i]]]]=i,l[i]=l[l[l[i]]];
    L=r[0],R=l[n+1];
    while(v[L]>=v[r[L]]&&tag[L]&&tag[r[L]]) s+=v[r[L]]-v[L],L=r[r[L]];
    while(v[R]>=v[l[R]]&&tag[R]&&tag[l[R]]) s+=v[l[R]]-v[R],R=l[l[R]];
    for(int i=L;i<=R;i=r[i])
        if(tag[i])
            v[++tot]=v[i];
    sort(v+1,v+tot+1,cmp),v[++tot]=s;
    for(int i=1;i<=tot;++i)
    {
        if(i&1) val+=v[i];
        else val-=v[i];
    }
    printf("%lld %lld",(sum+val)/2,(sum-val)/2);
    return 0;
}
```

---

## 作者：彭俊皓123 (赞：10)

# 洛谷 P3210 题解

## 一、简化题面
给定 $N$ 及长度为 $N$ 的序列 $a_1,a_2\dots a_n$，

要求先后手轮流选取 $a_{i}$ 满足 $(i\in[1,N],a_{i-1}=0$ 或 $a_{i+1}=0)$，并将 $a_i$ 变为 $0$。

问在先后手均为**最优决策**的情况下，先手及后手选取的数字之和。

## 二、分析

简化题意可得，设先手数字和减去后手数字和为 $val$，最优决策下先手会将 $val$ 最大化，而后手会将 $val$ 最小化。

由题意可知，先后手选择数时只能从一开始给定的 $0$ 两侧，或经过操作后变为 $0$ 的位置两侧开始选择。可以将由 $0$ 分割出来的子段，看作是由开头结尾两个**栈**与中间若干个**双端队列**组成。

考虑一种特殊情况：若存在 $a,b,c$ 三个相邻的数满足 $(a\le b)$ 且 $(c\le b)$，则在选取到时**必然**有此时先手选 $a$ 与 $c$，后手选 $b$ 的情况（因为若后手选 $a$ 或 $c$ 则会使得 $val$ 更大）。

>可以发现无论是从两头都可以选，还是只能选一头，$val$ 的值都不会改变。

因此对于以上的特殊情况，可以得到 $val=val+a+c-b$，即可将这种特殊情况合并为一个权值为 $(a+c-b)$ 的点，再加入原序列中与其他情况合并。

在合并之后，子段中只剩下了三种情况：单调递增，单调递减及先单调递减后单调递增。对于中间若干双端队列，显然可以贪心地去取得最大，可以直接**从大到小**轮流取得。

而对于开头及结尾的栈，可以进行分类讨论（以开头为例）：

### 1. 单调递减的部分：

如果此段长度为偶数，则可以先后手轮流取得答案，可以直接计算；如果长度为奇数，则先手会多取一个数，可能此时先手会优于后手。

### 2. 单调递增的部分：

由于存在 $a_{i-1}\le a_i$，$val\le val+a_i-a_{i-1}$，则可以同样与中间段一起贪心地取。

而对于结尾的栈，可以将以上分类讨论的部分反过来。

以上讨论已处理完了大部分情况，接下来对于需要特殊处理的情况进行讨论:

已知前后剩余的部分在最后是必选的，由于这部分值对于取时的先手可能是不利的，因此可以**直接模拟**，放在贪心取的部分后面由奇偶性决定给谁。

以上就讨论完了所有情况，处理出了先手与后手取值的差值 $val$。

设先手取值为 $ans_a$，后手取值为 $ans_b$，全局总和为 $sum$，则有：

$$
\begin{cases}
   ans_a+ans_b=sum\\
   ans_a-ans_b=val\\
\end{cases}
$$

解得：

$$
\begin{cases}
	ans_a=(sum+val)/2\\
   ans_b=(sum-val)/2\\
\end{cases}
$$

以下是代码：
```cpp
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int MAXN=1000005,INF=0x3f3f3f3f;
int a,b,c,tot=0,cnt=0;
int bj[MAXN];
ll sum=0,que[MAXN],num[MAXN],isort[MAXN];
inline char bit(){
	static char buf[1005],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1005,stdin),p1==p2)?EOF:*p1++;
}//一个普普通通的快读 
inline int read(){
	#define getchar() bit()
	char x=getchar();int t=0;
	while(!isdigit(x))x=getchar();
	while(isdigit(x))t=(t<<3)+(t<<1)+(x^48),x=getchar();
	return t;
}//又一个普普通通的快读 
bool cmp(ll x,ll y){return x>y;}
int main()
{
	a=read();
	for(register int i=1;i<=a;++i)
	{
		sum+=(num[i]=read());//全局和 
		que[++tot]=num[i];//开单点 
		bj[tot]=(num[i]!=0);
		/*注意：
			如果直接用que[i]去判断是否为初始为0的断点是不行的，
			因为有可能合并后的值也为0，而忘记加入贪心策略中继续判，
			从而导致奇偶性错误(本人因为这个WA了许多次T_T) */ 
		if(num[i])//如果用bj[i]去判会WA四个点，具体原因未知。 
		while(tot>2&&que[tot-2]<=que[tot-1]&&que[tot-1]>=que[tot]&&bj[tot-2]&&bj[tot-1]&&bj[tot])
			que[tot-2]+=que[tot]-que[tot-1],tot-=2;
		//只要还能合并就继续合并
		/*关于为什么要合并tot-2,tot-1,tot而不是tot-1,tot,tot+1：
			此时扫到的状态为最末尾的tot，而tot-2与tot-1已经被前面的处理过，
			合并tot+1的部分放在扫到tot+1时再处理。*/ 
	}
	ll val=0;
	int lt=1,rt=tot;
	for(;bj[lt]&&bj[lt+1]&&que[lt+1]<=que[lt];lt+=2)val+=que[lt+1]-que[lt];//合并开头单调递减部分
	for(;bj[rt-1]&&bj[rt]&&que[rt-1]<=que[rt];rt-=2)val+=que[rt-1]-que[rt];//合并结尾单调递增部分 
	/*关于为什么要把初始为0的断点也加进来:
		合并之后具有单调性的部分不便于枚举，可以直接判0断点来把单调部分取出。
		本人之前开了一堆乱七八糟的左右端点数组,调了一大堆乱七八糟的东西，
		最后发现不如直接把所有加进来特判 */
	for(int i=lt;i<=rt;++i)
	if(bj[i])isort[++cnt]=que[i];//将可以贪心地部分直接进行处理(记得判的是bj!!!!!) 
	sort(isort+1,isort+cnt+1,cmp);isort[++cnt]=val;//把特殊部分直接放到最后按结果模拟 
	val=0;//记得清空 
	for(register int i=1;i<=cnt;++i)
	if(i&1)val+=isort[i];//先手取差值增大 
	else val-=isort[i];//后手取差值减小 
	printf("%lld %lld",(sum+val)/2,(sum-val)/2);
	return 0;
}
```


---

## 作者：jiayixuan1205 (赞：5)

## 题解：P3210 [HNOI2010] 取石头游戏
### 题目大意
给定 $n$ 堆石子，两人轮流取石子，规定取走第 $i$ 堆石子时当且仅当第 $i-1$ 堆石子或 第 $i+1$ 堆石子为空。求在最优策略下先后手能取得的石子数。
### 标签
贪心，博弈论。
### 分析
可以发现，在初始部分石子被取走后，以 $0$ 为断点，那么石子堆就相当于转化为了开头结尾两个栈和中间一些双端队列。

我们现在定义一个变量 $\text{val}$ 用于表示先手和后手取得石子数量的差值。那么在最优情况下，先手就会希望这个值尽可能大，而后手就会希望这个值尽可能小。

那么，现在给出的这些序列中就会有以下几种情况：

- 单调递增
- 单调递减
- 先单调递增再单调递减
- 先单调递减再单调递增

首先，通过分析我们可以将第三种情况转化掉，分析只有三个数的情况，那么先手只能取两端的数，后手为使 $\text{val}$ 的值最小，就会选取中间的数（因为如果选取两端的数只会使得差值变大），那么最后的结果就是先手取走了两端的数，而后手取得了中间的数。所以产生的贡献一定为 $a+b-c$，就可以将其看作一个点，那么我们就只减去了一个操作。

- 双端队列部分：很明显最优策略是选取前后中最大的一个，即贪心策略选取最大值即可。
  
- 栈部分：单调递减的直接轮流取即可，但是在这里需要注意一下奇偶性，如果是奇数，先手会比后手多取一次，可能会更优。单调递增的部分可以同中间部分一起贪心取。

以上处理了大部分的情况，还有一些特殊情况需要讨论：
之前有一部分剩余的，我们直接采用模拟即可，由奇偶性决定应该怎么取。

那么我们就处理好了先手与后手取得的差值 $\text{val}$ 并且我们已知两者取得石子数的和，那么我们通过简单的和差问题就可以获得答案了。

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N = 1e6+10;
const int inf = 0x7fffffff;
int n;
int a[N],que[N],ta[N];
/*
a：记录初始石子数量
que：用于合并产生的双端队列
ta：各点合并完后直接用来进行贪心的数组 
*/ 
int sum=0,tot=0,cnt=0;
/*
sum：记录所有石子和
tot：记录合并后相当于一堆石子的数量
ta：记录最后用于贪心的石子数量 
*/ 
bool check[N];
//用于记录该堆是否为空 

inline bool cmp(int a,int b)
{
	return a>b;
}

signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		sum+=a[i];//求石子数量总和 
		tot++;
		que[tot]=a[i];//初始石子堆数 
		if(a[i]!=0) check[tot]=1;//记录不为空的石子堆数 
		else check[tot]=0;
		if(a[i])
		{
			while(tot>2&&que[tot-2]<=que[tot-1]&&que[tot-1]>=que[tot]&&check[tot-2]&&check[tot-1]&&check[tot])//如果出现分析过的可合成情况 
			{
				que[tot-2]+=que[tot]-que[tot-1];
				tot-=2;//并为一堆后总数减少 
			}
		}
	}
	int val=0;//先手与后手产生的差值 
	int l=1,r=tot;
	for(;check[l]&&check[l+1]&&que[l+1]<=que[l];l+=2) val+=que[l+1]-que[l];
	for(;check[r-1]&&check[r]&&que[r-1]<=que[r];r-=2) val+=que[r-1]-que[r];
	//分别从头尾处理单调递增与单调递减的情况 
	for(int i=l;i<=r;i++)
	{
		if(check[i])
		{
			cnt++;
			ta[cnt]=que[i];
		}
	}
	sort(ta+1,ta+cnt+1,cmp);
	cnt++;
	ta[cnt]=val;
	val=0;
	//对需要贪心的部分进行处理 
	for(int i=1;i<=cnt;i++)
	{
		if(i&1) val+=ta[i];
		else val-=ta[i];
	}
	//分奇偶进行讨论 
	cout<<(sum+val)/2<<" "<<(sum-val)/2<<endl;
	return 0;
}
```

---

## 作者：Tyher (赞：4)

感谢巨捞YCB orz

部分内容来自GuessYCB博客


  题目的意思是：给两个栈和一些双端队列，问先后手最优方案下的取值。
  
  因为总价值已经确定，那么先手的目标是使得自己与对方的差值尽可能大，后手的目标时尽可能小
  
  先看栈，栈的取值其实是固定了的。
  
  对于每一个栈，如果是单调下降
  
  例如左边的栈 若有ai<ai-1<ai-2
  
  那么当前取先手一定不是最优
  
  因为后手取到的ai一定大于ai-1
  
  如果对于栈单调上升
  
  那么当前取后手一定不是最优
  
  对于没有单调关系的变化
  
  如果是ai-1<ai>ai+1这种情况
  
  那么此时的先手与后手的收益差其实是确定了的
  
  先手先取旁边两个点中的一个，后手一定取中间最优
  
  先手再取另外一个
  
  这样的取法对于中间的队列可行，对于两边的栈也是可行的
  
  那么我们可以将三个合并为一个
  
  即anew=ai−1+ai+1−ai
  
  这样把所有的上凸关系全部合并完之后，大概整个图长这个样子

  每一块一定是开口向上的二次函数形状
  
  对于中间的队列，最优一定可以立刻取到
  
  为什么呢，因为两边最大中间最小，当前先手一定会取两边，而两边又是合法的
  
  对于左右两个栈的靠近里面的段也是合法的情况
  
  那么对于这些石头排序后贪心选就可以了
  
  对于栈单调靠近外面的段，进行相邻两两配对
  
  无法配对的靠内单项和之前的石头一起排序
  
  这样保证是最优的
  
  因为没有人愿意第一个开始选那两段
  
  所以在中间全部选完后，判断奇偶性直接算贡献就好了
  
  附代码
  
  
```
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#include<stack>
#define il inline
#define rg register
#define ll long long
#define ld long double
#define inf 2147483647000
#define mod 998244353
#define N 1000001
using namespace std;
ll n,op,Qcnt,Gcnt;
ll tot,now,fir,ans,w[N],Q[N],G[N];
ll A[N],Acnt,B[N],Bcnt;
il void re(rg int &x);
il void Re(rg ll &x);
int main(){
    Re(n),G[0]=-inf;
    for(rg int i=1;i<=n;++i)
        Re(w[i]),tot+=w[i];
    for(rg int i=1;i<=n;++i){
        if(w[i]){
            G[++Gcnt]=w[i],w[i]=0;
            if(Gcnt>=3)
                while(G[Gcnt]<=G[Gcnt-1]&&G[Gcnt-1]>=G[Gcnt-2]){
                    G[Gcnt-2]=G[Gcnt]+G[Gcnt-2]-G[Gcnt-1];
                    Gcnt-=2;
                    if(Gcnt<=2)break;
                }
        }
        else break;
    }
    for(op=Gcnt;op>=1;--op){
        if(G[op]>=G[op-1])
            Q[++Qcnt]=G[op];
        else break;
    }
    for(rg int i=1;i+1<=op;i+=2)
        A[++Acnt]+=G[i+1]-G[i];
    if(op&1)Q[++Qcnt]=G[op];
//预处理前面
    Gcnt=0;
    for(rg int i=n;i>=1;--i){
        if(w[i]){
            G[++Gcnt]=w[i],w[i]=0;
            if(Gcnt>=3)
                while(G[Gcnt]<=G[Gcnt-1]&&G[Gcnt-1]>=G[Gcnt-2]){
                    G[Gcnt-2]=G[Gcnt]+G[Gcnt-2]-G[Gcnt-1];
                    Gcnt-=2;
                    if(Gcnt<=2)break;
                }
        }
        else break;
    }
    for(op=Gcnt;op>=1;--op){
        if(G[op]>=G[op-1])
            Q[++Qcnt]=G[op];
        else break;
    }
    for(rg int i=1;i+1<=op;i+=2)
        B[++Bcnt]+=G[i+1]-G[i];
    if(op&1)Q[++Qcnt]=G[op];
//预处理后面
    Gcnt=0;
    for(rg int i=1;i<=n;++i){
        if(w[i]){
            G[++Gcnt]=w[i];
            if(Gcnt>=3)
                while(G[Gcnt]<=G[Gcnt-1]&&G[Gcnt-1]>=G[Gcnt-2]){
                    G[Gcnt-2]=G[Gcnt]+G[Gcnt-2]-G[Gcnt-1];
                    Gcnt-=2;
                    if(Gcnt<=2)break;
                }
        }
        else while(Gcnt)Q[++Qcnt]=G[Gcnt--];
    }
    sort(Q+1,Q+Qcnt+1),op=1;
    for(rg int i=Qcnt;i>=1;--i)
        ans+=op*Q[i],op*=-1;
    ll AA=0,BB=0;
    for(rg int i=1;i<=Acnt;++i)
        AA+=A[i];//,cout<<A[i]<<' ';
    for(rg int i=1;i<=Bcnt;++i)
        BB+=B[i];//,cout<<B[i]<<' ';
//	cout<<endl;
//	cout<<ans<<' '<<AA<<' '<<BB<<endl;
    if(Qcnt&1)ans-=(AA+BB);
    else ans+=(AA+BB);
    printf("%lld %lld\n",(tot+ans)>>1,(tot-ans)>>1);
    return 0;
}
il void re(rg int &x){
    x=0;rg int w=1;char c=getchar();
    while((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')w=-1,c=getchar();
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
    x*=w;
}
il void Re(rg ll &x){
    x=0;rg int w=1;char c=getchar();
    while((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')w=-1,c=getchar();
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
    x*=w;
}
```


---

## 作者：chlchl (赞：3)

双倍经验：P6377。

## Solution
由于得分之和是定值，且双方都想让自己分数最大，那么令 $res$ 为**先手得分与后手得分的差**，那么先手的目的是让这个数尽可能大，后手则是尽可能小。

显然原序列可以拆分成若干个区间，其中开头和结尾的区间可以看做栈，每次从栈顶取；中间的区间则可以看成若干个双端队列，每次从两边取。

这个题给部分分可能会好做一些，考虑一个区间的单调性。

对于中间的区间，如果是**单调的**，那么先手直接从最大的一侧取，显然不劣。

开头的区间如果是单调递**增**、结尾的区间如果是单调递**减**的也同理，贪心做就行。

现在讨论不单调的情况。如果 $\exist i\in(1,n),a_{i-1}<a_i,a_i>a_{i+1}$，那么可以证明的是，如果 $a_{i-1}$ 或 $a_{i+1}$ 是可取的值中最大的，先手一定会取 $a_{i-1}$ 和 $a_{i+1}$，后手则一定会取 $a_i$。

考虑反证：若先手取完 $a_{i-1}$ 之后，后手取了一个 $a_j,j\ne i$，那么会有 $a_{i-1}<a_i<a_j$，且 $a_j$ 在取 $a_{i-1}$ 前就已经可被取（因为取走 $a_{i-1}$ 后只有 $a_i$ 是新增加的可取数）。

那先手取 $a_j$ 一定更优，矛盾，证毕。

至于取完 $a_i$ 后为什么会马上再取 $a_{i-1}$ 是类似的。

那么对于这样连续三个数的“山峰”，就可以缩点，权值为 $a_{i-1}+a_{i+1}-a_i$，采用**链表**维护。并且这样缩点，每次取完一个数后先后手是**一定发生变化的**，不用担心最后的统计。

缩完点后，剩下的区间就只剩三种情况：单调递减、单调递增、先减后增，这个时候贪心是可做的。将所有数扔进堆里，**每次取最大**就行。

剩下几种特殊情况：第一个区间单调递减、先减后增，最后一个区间单调递增、先减后增。

其中先减后增的情况，可以把靠近 $0$ 的那一段也放进堆里（这一段显然是可以直接贪心的）。那么就剩下第一个区间单调递减、最后一个区间单调递增的情况。这里以第一个区间单调递减作为例子（最后一个区间是类似的）。

若区间长度是偶数，由于只能从一端取，先手每取一个，后手必然可以取一个比先手更大的，先手是亏的。

所以策略就是先跑完上面贪心的点，把这部分的点留到最后（因为希望把先手挪到别人身上）。

而且这部分取完**先后手是不变的**，因此不可以在中间某个时间段做，一做后面就会全亏。

若区间长度是奇数，最靠近 $0$ 的那个数先手是可以马上取的，这个数可以扔进堆里，剩下的数就变成偶数的情况了。

这部分实现的时候可以把两个相邻的数作差缩点。

最后利用一个和式一个差式可以求出双方的分数。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 10;
int n, sum, res, len, a[N], b[N], op[N];
int l[N], r[N];

#define l(i) (l[i])
#define ll(i) (l[l[i]])
#define lll(i) (l[l[l[i]]])

bool cmp(int a, int b){
	return a > b;
}

main(){
	scanf("%lld", &n);
	r[0] = 1, l[n + 1] = n;
	for(int i=1;i<=n;i++){
		scanf("%lld", &a[i]), op[i] = (a[i] != 0);
		sum += a[i], l[i] = i - 1, r[i] = i + 1;
	}
	for(int i=3;i<=n;i=r[i]){
		while(op[ll(i)] && op[l(i)] && op[i] && a[l(i)] >= a[ll(i)] && a[l(i)] >= a[i])
			a[i] = a[ll(i)] + a[i] - a[l(i)], r[lll(i)] = i, l[i] = lll(i);
	}
	int val = 0, hd = r[0], tl = l[n + 1];
	while(a[hd] >= a[r[hd]] && op[hd] && op[r[hd]])
		val += a[r[hd]] - a[hd], hd = r[r[hd]];
	while(a[tl] >= a[l[tl]] && op[tl] && op[l[tl]])
		val += a[l[tl]] - a[tl], tl = l[l[tl]];//处理那些需要最后取的 
	for(int i=hd;i<=tl;i=r[i]){
		if(op[i])
			a[++len] = a[i];
	}
	sort(a + 1, a + 1 + len, cmp);
	a[++len] = val;//不能取的那些部分留到最后
	for(int i=1;i<=len;i++){
		if(i & 1)
			res += a[i];
		else
			res -= a[i]; 
	}
	printf("%lld %lld\n", (sum + res) / 2, (sum - res) / 2);
	return 0;
}
```

---

## 作者：LingHusama (赞：3)

## [HNOI2010] 取石头游戏

### 前言：
个人感觉这道题很有难度，很有思维，这种博弈方式也值得积累。
### 正文：
1. 确定博弈：首先你得知道，很多博弈题目都是假的，可能是贪心啊什么的。这道题看起来是两个人都想要自己的得分更大，但是实际上为了让自己得分更大，就必须让对方在对方的回合中取的少一些。因此这肯定是博弈而非每次贪心只顾自己，取能取到的最大值。

2. 思考模型：大多数博弈都有基础模型，由于这道题是很明显的那种“我可以死，但你要死得更惨”的题目。这种题目通常是设定一个值 $val=a-b$，在两轮游戏中，前者取得 $a$，后者取得 $b$ 时，前者期望 $val$ 越大越好，后者反之。
3. 落实限制：找到模型后，我们看看取到一个值的限制，发现就像是在双端队列或者栈中取值（用零来分段，开口都是面向这个零的）。我们在一个双端队列中进行考虑。
4. 分类讨论：我们对连续的三个元素进行考虑，总共有四种情况：递增，递减，先增后减，先减后增。（后文我们称一次情况为一个过程）我们这里的渐变方向都是由外到内的（后文也一样）。对于递增的话，我们肯定要放到后面选择，因为这时候先手选择了，后手肯定可以选择到比它大的这个数字的。递减的话，我肯定优先选择目前所有递减里面最大的。先减少后增加同上。
5. 特殊性质：当我们分类讨论到先减少后增加的情况的话，你会发现后手肯定会选择中间的，先手肯定会选择左后两个。为什么会这样？如果当前先手发现选取最优秀的话，他会把这个选走。由于先增加后减少，所以当前对于后手而言，选取比上一次最优还优秀的点肯定是最佳的，所以他肯定会选择中间那个。虽然对于先手而言，此时选取剩下的那个不一定最优秀，那我要是现在选取到其他更优的决策点的话，就变成了其他情况了，最终你还是要选取到这个剩下的点（即使中间可能会穿插很多其他过程）。那么我们直接把这种情况压成一个点。于是乎，所有的双端队列和栈中不会出现任何先增加后减少的情况了。
6. 扩展：当发现上面这个性质后，所有的三个元素的情况可以扩展到一整个双端队列或栈的情况了，还是按照上面那个规则贪心轮流选取即可。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') {
            f = -1;
        }
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}
int l[2000006], r[2000006];
int a[2000006];
bool iszeroo[2000006];
int n;
int sum = 0;
int s = 0;
int tot = 0;
int val = 0;
bool cmp(int x, int y) { return x > y; }
signed main() {
    n = read();
    iszeroo[0]=1;
    for (int i = 1; i <= n; i++) {
        a[i] = read();
        sum += a[i];
        if (a[i] == 0) {
            iszeroo[i] = 1;
        }
        l[i] = i - 1;
        r[i] = i + 1;
    }
    r[0] = 1;
    l[n + 1] = n;
    for (int i = 3; i <= n; i = r[i]) {  //从位置i开始，尝试与前面的所有数字合并
                                         //合并操作
        while (!iszeroo[i] && !iszeroo[l[i]] && !iszeroo[l[l[i]]] && a[l[i]] >= a[l[l[i]]] && a[l[i]] >= a[i]) {                  //满足条件
//        	printf("test:%lld\n",i);
            iszeroo[l[i]] = iszeroo[l[l[i]]] = 1;  //删除这两个数字
            a[i] = a[l[l[i]]] + a[i] - a[l[i]];
            r[l[l[l[i]]]] = i;  //上一个不参与合并数字的右端点为i
            l[i] = l[l[l[i]]];  //左端点为上一个不参与合并的位置
        }
    }
    
    int L = r[0], R = l[n + 1];
    // L:第一个链表
    // R:最后一个链表
    while (a[L] >= a[r[L]] && !iszeroo[L] && !iszeroo[r[L]]) {
        s += a[r[L]] - a[L];
        L = r[r[L]];
    }
    while (a[R] >= a[l[R]] && !iszeroo[R] && !iszeroo[l[R]]) {
        s += a[l[R]] - a[R];
        R = l[l[R]];
    }
    //先处理两个栈，统计出最后贡献s
    for (int i = L; i <= R; i = r[i]) {
        if (!iszeroo[i]) {
        	
            a[++tot] = a[i];
        }
    }
    //对中间所有有值的链表
    sort(a + 1, a + tot + 1, cmp);  //贪心，两者轮流从大到小选取
    a[++tot] = s;                   //栈的东西放在最后
//    printf("test:%lld\n",tot);
    for (int i = 1; i <= tot; ++i) {
        if (i & 1)
            val += a[i];
        else
            val -= a[i];
    }
    printf("%lld %lld", (sum + val) / 2, (sum - val) / 2);
}      
```


---

## 作者：Xlon_WU (赞：2)

## $\large\mathfrak{1st.\ Preamble|}$ 前言

题目传送门：[P3210 [HNOI2010] 取石头游戏](https://www.luogu.com.cn/problem/P3210)。

更好的阅读体验：[Xlon WU's Blog](https://xlon-wu.github.io/2024/08/27/solution-luogu-p3210/) or [博客园](https://www.cnblogs.com/Xlon-WU/p/18382441)。

主要是参考楼下大佬的题解，对于其中没讲到或比较难懂的地方进行讲解，以及配上了图。

## $\large\mathfrak{2nd.\ Solution|}$ 题解

楼下大佬的比喻十分形象生动地描绘了俩人去石头的过程：

> 取石子的过程可以转化为两端分别有一个栈，可以从栈顶取石子，中间有若干个双端队列，可以从其两端取石子。

我们可以根据俩人取石子的过程推算出**先手积分减去后手积分的差值** $dif$，然后根据总和就能求出最终俩人的积分。先手肯定希望 $dif$ 尽可能大，后手肯定希望 $dif$ 尽可能小。

Q：为什么是算差值而不是直接算积分？

A：因为差值好算呗！等会你就知道了。

为了方便计算，我们肯定希望每次的全局最大权值的位置都是可以直接取的。接下来我们分两个部分讨论这俩人取石子的过程。

注：接下来的递减、递增均指非严格递减和递增。

### 中间部分（双端队列）

对于每个中间区块（双端队列）中，权值递增、递减和下凹的情况都很好解决，如下图箭头所示，从其中一端或两端开始取就行。

![](https://cdn.luogu.com.cn/upload/image_hosting/pjvres8m.png)

然后我们来看看上凸该如何解决。

![](https://cdn.luogu.com.cn/upload/image_hosting/ypke9wf7.png)

我们先来考虑最简单的三个位置的上凸情况：若存在 $a_{i-1}\le a_i$ 并且 $a_i\ge a_{i+1}$，若当前最优选择为 $a_{i-1}$，则先手会选择 $a_{i-1}$，接着后手会选择 $a_i$，然后先手会选择 $a_{i+1}$，最终 $dif$ 会增加（或减少）$a_{i-1}-a_i+a_{i+1}$，于是我们就可以把 $a_{i-1}, a_i, a_{i+1}$ 三个位置打包成一个权值为 $a_{i-1}-a_i+a_{i+1}$​​ 的位置。反之同理。这也是为什么我们是算差值而不是直接算积分。

当我们把每个上凸都打包完，剩下就只剩下上面的三种情况，当前最大都是可以直接取到的。

### 两端（栈）

对于左边部分，我们希望是单调递增的（因为只能从中间往外取）；反之，对于右边部分，我们希望是单调递减的。

左边部分中，若存在递减的部分，那我们可以像刚才一样，将其打包起来，即：若存在 $a_i>=a_{i+1}$，且 $a_{i+1}$ 为目前全局最优，因为先手只能从右侧开始选，所以先手比选 $a_{i+1}$，后手必选 $a_i$，于是我们可以把 $a_i$ 和 $a_{i+1}$ 打包成一个权值为 $a_{i+1}-a_i$  的位置。

右边部分同理。

### 实现方法

打包的过程我们使用链表来实现。

全部打包完后，接下来每次的全局最大值必定可以直接取到，所以我们可以直接将所有位置按权值从大到小排序，然后从大到小取即可。

## $\large\mathfrak{3rd.\ Code|}$ 代码

代码中过于简单的细节就不标注了。敢做黑题的相信一定能看懂。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define FOR(i,l,r) for(int i=l;i<=r;i++)
#define FILE(x) freopen(x".in","r",stdin),freopen(x".out","w",stdout);
#define pii pair<int,int>
#define pll pair<long long,long long>
// #define Clock
using namespace std;
const ll N=2e6+10;
ll n,a[N],sum,l[N],r[N],L,R,p[N],cnt,s,ans;
bool book[N];
inline bool cmp(ll a,ll b){return a>b;}
int main(){
    #ifdef Clock
        clock_t Start_Time=clock();
    #endif
    // ios::sync_with_stdio(false);
    // cin.tie(0),cout.tie(0);
    // FILE("xxx");
    cin>>n; r[0]=1,l[n+1]=n;
    for(ll i=1;i<=n;i++){
        cin>>a[i];
        sum+=a[i],book[i]=a[i];   // 计算总和；标记是否存在
        l[i]=i-1,r[i]=i+1;
    }
    for(ll i=3;i<=n;i=r[i]){
        ll x=l[l[i]],y=l[i],z=i;
        while(book[x]&&book[y]&&book[z]&&a[y]>a[x]&&a[y]>a[z]){
            a[i]=a[x]+a[z]-a[y],r[l[x]]=i,l[i]=l[x];    // 打包中间上凸块
            x=l[l[i]],y=l[i],z=i;
        }
    }
    L=r[0],R=l[n+1];
    while(a[L]>=a[r[L]]&&book[L]&&book[r[L]])s-=a[L]-a[r[L]],L=r[r[L]];    // 打包左侧递减块
    while(a[R]>=a[l[R]]&&book[R]&&book[l[R]])s-=a[R]-a[l[R]],R=l[l[R]];    // 打包右侧递增块
    for(ll i=L;i<=R;i=r[i])if(book[i])p[++cnt]=a[i];
    sort(p+1,p+cnt+1,cmp);    // 从大到小排序
    p[++cnt]=s;
    for(ll i=1;i<=cnt;i++)ans+=(i%2?p[i]:-p[i]);
    cout<<(sum+ans)/2<<' '<<(sum-ans)/2;
    #ifdef Clock
        cout<<"\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nRuntime: "<<clock()-Start_Time<<" ms\n";
        system("pause");
    #endif
    return 0;
}
```

## $\large\mathfrak{4th.\ Postscript|}$ 后记

第一天写的时候没过，那时还是紫题，并且不能写题解。第二天过完后发现变成了黑题，而且还可以写题解！于是遍欣喜若狂地写下了这篇题解。

---

## 作者：uncle_steve (赞：1)

### 思路：单调博弈问题

## 解题过程

**引入一个结论：**

如果一段序列中，出现了三个相邻位置 $A$，$B$，$C$，满足 $A \le B≥C$，那么可以把这三个数替换成 $A−B+C$。原因是假设先手某一次要取 $A$（要取 $C$ 同理），显然如果要取 $A$，说明此时 $A$ 是最优决策，然后后手一定会取 $B$，因为后手选 $B$ 一定不差。同理，先手后面会取 $C$，这样取完三个数先手收益就是 $A−B+C$。

## 程序实现

做完以后，所有栈/队列都会变成**先递减后递增**的形式。对于队列，因为可以从两边取，那么每次只要取最大值：

1. 可以把所有队列元素放在一起排序，然后依次取；对于栈元素，从栈顶开始一直递减的那一段也是和队列一样的。

2. 递增的一段，显然先手一取，后手就会取下一个，导致先手亏，所以谁都不会先取。把这一部分单独处理，即从栈底开始两两配对，把亏损的代价统计，放在最后面，看谁会取到即可。

3. 最后通过**简单的和差问题**即可获得答案。

## AC CODE


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int lint
typedef long long lint;
typedef long double louble;
template<typename T1,typename T2> inline T1 max(T1 a,T2 b){return b<a?a:b;}
template<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}
namespace ae86{
	const int bufl = 1<<15;
	char buf[bufl],*s=buf,*t=buf;
	inline int fetch()
	{
		if(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}
		return *s++;
	}
	inline int ty()
	{
		int a=0,b=1,c=fetch();
		while(!isdigit(c))b^=c=='-',c=fetch();
		while(isdigit(c))a=a*10+c-48,c=fetch();
		return b?a:-a;
	}
}
using ae86::ty;
const int _ = 1000007;
lint stk[_]={0},temp[_];
int got[_]={0},n,top=0,ltemp=0;
signed main()
{
	int who=0;
	lint sum=0,ans=0;
	n=ty();
	for(int i=1;i<=n;i++)
	{
		stk[++top]=ty(),got[top]=0;
		if(stk[top]>0)who^=1,sum+=stk[top],got[top]=1;
		while(top>=3 && got[top] && got[top-1] && got[top-2]
				&& stk[top-2]<=stk[top-1] && stk[top]<=stk[top-1])
			stk[top-2]=stk[top-2]+stk[top]-stk[top-1],got[top]=got[top-1]=0,stk[top]=stk[top-1]=0,top-=2;
	}
	int l=1,r=top;
	who=who+who-1;
	for(l=1;l<=top && got[l] && got[l+1] && stk[l]>=stk[l+1];l+=2)
		ans=ans+(stk[l]-stk[l+1])*who;
	for(r=top;r>l && got[r] && got[r-1] && stk[r]>=stk[r-1];r-=2)
		ans=ans+(stk[r]-stk[r-1])*who;
	for(int i=l;i<=r;i++)if(got[i])temp[++ltemp]=stk[i];
	sort(temp+1,temp+ltemp+1,greater<int>());
	for(int i=1;i<=ltemp;i++)ans=ans+(i&1?(1ll):(-1ll))*temp[i];
	printf("%lld %lld\n",(sum+ans)/2,(sum-ans)/2);

	return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

[镜像题解](https://www.luogu.com.cn/article/fh05qufp)

首先考虑一个弱化的问题：如果 $a$ 单调怎么做？

这个问题是易于解决的，每个人都只需要从大往小取即可。

但是问题在于，原序列并没有单调性，我们考虑让它具有单调性。

不妨考虑每一个峰，即 $a_i\ge\max\{a_{i-1},a_{i+1}\}$，此时先手取 $a_{i-1}/a_{i+1}$ 后，后手必须取 $a_i$，然后先手再取另一个。如果取的是其它更优的值，先手显然不会取 $a_{i-1}/a_{i+1}$。

考虑这个博弈问题，其实就是先手要最大化两个的差，后手要最小化两个的差，那么此时先手造成的收益其实就是 $a_{i-1}+a_{i+1}-a_{i}$，我们就可以合并这三个。

容易发现，此时合并之后就只剩下三种情况：

- 单增

- 单减

- 单谷

但是注意到无论哪种情况，极值都一定在两端，所以我们只需要把它们全部塞堆里每次取最大值即可。

此时有些问题，因为边上可能存在取不了极值的情况，因为有一边取不了，不妨以左边为例。

如果左边是个单增序列的话，正常取即可。

如果左边是单减序列的话，长度为偶数是先手后手轮流取，后手一定比先手收益更大，所以先手一定不会取，单独算即可；如果长度为奇数，那么最后一个是可以取的，因为这样对方不会取，把它塞进堆里面即可。

如果左边是单谷的话，就分单增和单减部分分别处理即可。

---


# 「Stoi2033」世界未末日 加强版

## 题目背景

注意：**利用提交反馈以套取数据的行为属于作弊**。

> 就算是世界要崩溃  
> 亲爱的我也绝不会落泪  
> 不放弃爱过的那种感觉  
> 珍惜着有你记忆的一切  
> 就算是世界要倾斜  
> 亲爱的我也绝不说离别  
> 尽管末日威胁再强烈  
> 有爱就不累  
> ——《世界未末日》

## 题目描述

Vinsta 和 Stella 有 $n$ 堆石子，第 $i$ 堆有 $s_i$ 个。

她们约定从 Vinsta 开始轮流操作，每次操作可以选择不少于 $1$ 堆且不超过 $k$ 堆的石子。对于第 $i$ 堆石子，可以选取两个实数 $a,b$ 满足：

- $a \times b=s_i$
- $a+b=c,c\in[1,s_i]\cap\Z$

并丢掉第 $i$ 堆的 $c$ 个石子，即 $s_i\leftarrow s_i-c$。不能操作者败，她们想要知道 Vinsta 是否有必胜策略。

## 说明/提示

对于 $100\%$ 的数据， $1 \le T \le 10$, $1 \le k \le n \le 3 \times 10^6$，$1 \le S \le 3 \times 10^{17}$。

## 样例 #1

### 输入

```
2
7 1 13
2 3 4 5 7 10 11
8 1 13
2 3 4 5 7 10 11 13
```

### 输出

```
YES
NO
```

## 样例 #2

### 输入

```
1
7 2 100
19 26 8 17 11 45 14
```

### 输出

```
YES
```

# 题解

## 作者：VinstaG173 (赞：31)

数据范围：$1 \le k \le n \le 3 \times 10^6,1 \le S \le 3 \times 10^{17}$。

首先原来的做法显然用不了了。我们考虑找一下 dSG 函数（即从 SG 值对应回最少石子数的函数）的性质。

我们发现数列长这样（称为数列 $0$，下标从 $0$ 开始，其余数列下标均从 $1$ 开始）：

$$0,4,11,20,32,46,62,80,100,123,148,\dots$$

差分一下（得到的数列称为数列 $1$）：

$$4,7,9,12,14,16,18,20,23,25,\dots$$

再差分一下（得到的数列称为数列 $2$）：

$$3,2,3,2,2,2,2,3,2,\dots$$

发现数列 $2$ 里全是 $2$ 或 $3$。多算一些会发现当我们以每个 $3$ 为结尾带上前面连续一些 $2$ 组成一些段后，这些段的长度分别是 $1,2,5,10,21,42,85,170,\dots$，即二进制表示下为 $0$ 与 $1$ 相间的数。我们设第 $i$ 个这样的数为 $x_i$。

首先我们尝试解数列 $1$ 的通式。由于数列 $2$ 里只有 $3$ 和 $2$，我们考虑把数列 $1$ 里的数表示成 $2a_i+b_i$ 的形式，令 $a_1=2,b_1=0$。则对于每个 $i$ 有 $a_{i+1}=a_i+1$，对于数列 $2$ 中第 $i$ 个数为 $3$ 的 $i$ 有 $b_{i+1}=b_i+1$，否则有 $b_{i+1}=b_i$。

令 $S_i$ 为 $x_i$ 的前缀和，则当且仅当 $i=S_j$ 有数列 $2$ 中第 $i$ 个数为 $3$。于是 $a_i=i+1$，$b_i=\max\{j:S_j \le i\}-1$。

那么我们可以分别求 $a_i$ 和 $b_i$ 的前缀和得到数列 $0$ 中的数。设数列 $0$ 中下标为 $i$ 的是 $2c_i+d_i$，则 $c$ 为 $a$ 的前缀和，$d$ 为 $b$ 的前缀和。因此有

$$c_v=\sum_{i=1}^{v}a_i$$

$$=\sum_{i=1}^{v}(i+1)$$

$$=\dfrac{v(v+3)}{2}$$

$$d_v=\sum_{i=1}^{v}b_i$$

$$=\sum_{i=1}^{v}(\max\{j:S_j \le i\}-1)$$

令 $t=\max\{j:S_j \le v\}$，则上式

$$=t(v-S_t)+\sum_{j=1}^{t}(j-1)x_j$$

$$=\sum_{i=1}^{t}(v-S_t)+\sum_{j=1}^{t}\sum_{i=1}^{j-1}x_j$$

$$=\sum_{i=1}^{t}\left(v-S_t+\sum_{j=i+1}^{t}x_j\right)$$

$$=\sum_{i=1}^{t}(v-S_i)$$

令 $T_i$ 为 $S_i$ 的前缀和，则 $d_v=tv-T_t$。

因此数列 $0$ 的第 $v$ 项为 $\operatorname{dSG}(v)=2c_v+d_v=v^2+(3+t)v-T_t$。由于 $\operatorname{dSG}(v)$ 不减，并且 $S_t \le v < S_{t+1}$，因此我们只要二分出最大的 $S_t^2+(3+t)S_t-T_t \le s$ 的 $t$，再求出满足 $v^2+(3+t)v-T_t \le s$ 的最大 $v$，那么 $v$ 就是 $s$ 的 SG 值。前面的二分是 $O(\log\log{S})$ 的，后面求 $k$ 由于左边是二次函数且开口朝上，可以直接解出方程正根然后下取整，显然就是所求。这一步是 $O(n\log\log{S})$ 的。

然后由于暴力求每个二进制位上数值和是 $O(n\log{S})$ 的，会被卡，所以要优化（如果您能卡过去可以私信我）。以下优化方案由永远滴神 @[tiger2005](https://www.luogu.com.cn/user/60864) 提出。（据说是常见 trick？是我不行）

考虑分治计算贡献。设所有 SG 值最大的二进制位数为 $m$，我们把每个数的二进制拆成 $w$ 段，每段不超过 $\left\lceil\dfrac{m}{w}\right\rceil$ 位。（尽可能平均分，为简便接下来省略上取整符号）

对于每段，先将每个数这一段中二进制位对应的所有可能取值出现次数用一个下标为 $[0,2^{\frac{m}{w}})$ 的桶存起来。如 $\dfrac{m}{w}=5$，某个数的二进制第 $5 \sim 9$ 位为 $01011$，则将 $11$ 位的计数器加上 $1$，类似处理。

然后对于这 $2^{\frac{m}{w}}$ 个数暴力枚举每个数二进制表示里面 $1$ 的位置计算贡献。

这样的时间复杂度是 $O(w(n+2^{\frac{m}{w}-1}))$，由于 SG 值不超过 $\sqrt{S}$，取 $w=2$ 时复杂度是 $O(n+S^{\frac{1}{4}}\log{S})$ 的，可以通过。

总时间复杂度是 $O(n\log\log{S}+S^{\frac{1}{4}}\log{S})$。

Code:
```cpp
#include<cmath>
#include<cstdio>
#define rg register
#define ll long long
#define lb(x) (x&(-x))
inline char gc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=gc();
	while(cc<'0'||cc>'9')cc=gc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=gc();
	return x;
}
inline ll _read()
{
	ll x=0;
	char cc=gc();
	while(cc<'0'||cc>'9')cc=gc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=gc();
	return x;
}
ll S,s;
int n,k;
int t,w,m;
int v,flag;
ll ssmv[37];
int cnt[37],pw2[17];
int x[37],sm[37],ssm[37];
int cnt1[32773],cnt2[32773];
int ans1[32773],ans2[32773];
int main()
{
	n=read(),k=read()+1,S=_read();
	while(1ll<<(m<<1)<=S)++m;
	--m,t=(m>>1)+1,w=(1<<t)-1;
	pw2[0]=x[1]=sm[1]=ssm[1]=1;
	for(rg int i=1;i<t;++i)pw2[i]=(pw2[i-1]<<1);
	for(rg int i=2;i<=m;++i)
	{
		x[i]=(x[i-1]<<1)|(i&1),sm[i]=sm[i-1]+x[i];
		ssm[i]=ssm[i-1]+sm[i],ssmv[i]=(sm[i]+3ll+i)*sm[i]-ssm[i];
	}
	for(rg int i=0,l,r,mid;i<n;++i)
	{
		s=_read(),l=0,r=m;
		while(l<r)mid=r-((r-l)>>1),(ssmv[mid]<=s)?(l=mid):(r=mid-1);
		v=int((sqrt((l+3)*(l+3)+((s+ssm[l])<<2))-l-3)/2),++cnt1[v&w],++cnt2[v>>t];
	}
	for(rg int i=0;i<=w;++i)
	{
		for(rg int j=i;j;j^=lb(j))
		{
			ans1[lb(j)]+=cnt1[i];
		}
	}
	for(rg int i=0;i<t;++i)cnt[i]=ans1[pw2[i]];
	for(rg int i=0;i<=w;++i)
	{
		for(rg int j=i;j;j^=lb(j))
		{
			ans2[lb(j)]+=cnt2[i];
		}
	}
	for(rg int i=0;i<t;++i)cnt[i+t]=ans2[pw2[i]];
	for(rg int i=0;i<=m;++i)(cnt[i]%k)&&(flag=1);
	puts((flag)?"YES":"NO");
	return 0;
}
```

关于解法中关于 $2,3$ 个数的结论我还没有找到一个证明（但是跑完整个数据范围验证确实暂时没有出错），如果有神仙找到了证明方法或举出了反例欢迎私信我。~~如果证明很简单请顺带把我这个垃圾爆踩一顿~~

---

## 作者：EDPZnCl (赞：5)

本篇题解是对 @[VinstaG173](https://www.luogu.com.cn/user/59388) 的题解的补充。

### 1. 证明其解法中关于 $2,3$ 个数的结论

我们知道，dSG 数列满足
$$a_0=0, a_{n}=\min\ \{m\in\mathbb{Z_+}\mid m-2\sqrt{m}\ge a_{n-1}\}, \forall n\in\mathbb{Z_+} $$
算出该数列前几项，发现其可以划分成若干段二次函数。可以猜测如下结论成立：
$$a_n=n^2+kn-c_k,b_{k-1}\le n\le b_k,\forall k\in\mathbb{Z_+}$$
其中 $b_k=\lfloor\dfrac{2^{k}}{3}\rfloor-\lfloor\dfrac{k}{2}\rfloor , c_k=\dfrac{\lfloor\frac{2^{k+2}}{3}\rfloor-k^2-1}{4}$。
下面对 $k,n$ 双重归纳证之。

$k=1,2,3:$ 直接验证即可。

$k-1\to k:$ 再对 $n$ 归纳证明上式。

$n=b_{k-1}:$ 先证 $c_{k-1}+b_{k-1}=c_k$。
注意到确定了 $k$ 的奇偶就可以拆掉取整符号，故按 $k$ 的奇偶性讨论即可，具体计算略。于是由归纳假设可知
 $$\begin{aligned} a_{b_{k-1}} &= b_{k-1}^2+(k-1)b_{k-1}-c_{k-1} \\ &= b_{k-1}^2+kb_{k-1}-c_k\end{aligned}$$
即原式对 $n=b_{k-1}$ 成立。

$n-1 \to n:$ 由 $y=x-2\sqrt{x}$ 的单调性，我们只需证
$$a_n-2\sqrt{a_n}\ge a_{n-1}, a_n-1-2\sqrt{a_n-1}< a_{n-1}$$
对 $a_n=n^2+kn-c_k$ 成立。

对前一式，将 $a_n=n^2+kn-c_k,a_{n-1}=(n-1)^2+k(n-1)-c_k$ 代入化简得
$$2\sqrt{n^2+kn-c_k}\le 2n+k-1,$$
$$4(n^2+kn-c_k)\le 4n^2+4(k-1)n+(k-1)^2,$$
$$n\le c_k+\frac{(k-1)^2}{4}=\frac{\lfloor\frac{2^{k+2}}{3}\rfloor -2k}{4}.$$
按 $k$ 的奇偶性讨论可得 $b_k\le \dfrac{\lfloor\frac{2^{k+2}}{3}\rfloor -2k}{4}$，故此式成立。

对后一式，代入化简得
$$2\sqrt{n^2+kn-c_k-1}> 2n+k-2,$$
$$4(n^2+kn-c_k-1)> 4n^2+4(k-2)n+(k-2)^2,$$
$$n> \frac{c_k+1}{2}+\frac{(k-2)^2}{8} =\frac{\lfloor\frac{2^{k+2}}{3}\rfloor-4k+7}{8}.$$
注意 $n\ge b_{k-1}+1$，按 $k$ 的奇偶性讨论可得 $b_{k-1}+1>\dfrac{\lfloor\frac{2^{k+2}}{3}\rfloor-4k+7}{8}$，故此式成立。证毕。

从而 $\{a_n\}$ 的差分（记为 $\{d_n\}$）满足
$$d_n=2n+k-1,b_{k-1}+1\le n\le b_k,\forall k\in\mathbb{Z_+}$$
可以发现 $\{d_n\}$ 的差分数列里全是 $2$ 或 $3$，且当我们以每个 $3$ 为结尾带上前面连续一些 $2$ 组成一些段后，这些段的长度分别为 $b_3-b_2,b_4-b_3,b_5-b_4,\dots$。不难得到 $b_{k+1}-b_k=\lfloor\dfrac{2^k}{3}\rfloor$，这即为二进制表示下 $0$ 与 $1$ 相间的数。这样我们就证明了关于 $2,3$ 个数的结论。

### 2. 优化时间复杂度

沿着上述思路继续探索：对于要求 SG 值的 $s$，若确定了 $s$ 在第 $k$ 段二次函数上，则 $\text{SG}(s)$ 即为最大的满足 $n^2+kn-c_k\le s$ 的正整数 $n$，这即为方程正根下取整，即
$$\text{SG}(s)=\lfloor\frac{-k+\sqrt{4(c_k+s)+k^2}}{2}\rfloor.$$
那么如何确定 $s$ 在哪一段上呢？

注意到 $a_{b_k}$ 十分接近 $\dfrac{4^k}{9}$，进一步计算可得
$$b_k^2+kb_k-c_k< \dfrac{4^k}{9}< (b_k+1)^2+k(b_k+1)-c_k,\forall k \in \mathbb{Z_+}.$$
因此可以把 $\left[\dfrac{4^{k-1}}{9},\dfrac{4^k}{9} \right)$ 作为第 $k$ 段的范围。反过来，$\lfloor\log_4{9s}\rfloor+1$ 即为 $s$ 所在段的序号，其中 $\log_4$ 下取整可以用 clz 函数实现。

SG 函数部分的代码：
```cpp
int SG(ll s)
{
	int k=65-__builtin_clzll(9*s)>>1;//求出s所在的段 
	return int(sqrt(4*s+c[k]))-k>>1;//二次方程求解，预处理c[k]=4*c_k+k^2 
}
```

这样，求 SG 函数的时间复杂度可以降到 $O(n)$，总时间复杂度为 $O(n+S^\frac{1}{4}\log S)$。

### 3. 压缩代码长度

到这里已经难以再优化时间复杂度了，最后我们尝试写一份极简代码。

经过[实测](https://www.luogu.com.cn/record/129172613)，应用上述优化后，二进制逐位求和部分直接暴力即可通过，这样就可将代码长度压到 850B 以内。下附完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
ll c[32],T,n,k,S,x;
int i,j,y,b[32],ans[10];
char buf[1<<21],*p1=buf,*p2=buf;
int SG(ll s)
{
	int k=65-__builtin_clzll(9*s)>>1;
	return int(sqrt(4*s+c[k]))-k>>1;
}
ll read()
{
	ll s=0;
	char cc=getchar();
	while(cc<'0' || cc>'9')
		cc=getchar();
	while(cc>='0' && cc<='9')
	{
		s=s*10+cc-'0';
		cc=getchar();
	}
	return s;
}
int main()
{
	for(i=1;i<32;i++)
		c[i]=(1ll<<(i+2))/3-1;
	T=read();
	for(i=0;i<T;i++)
	{
		n=read(),k=read()+1,S=read();
		for(j=0;j<n;j++)
		{
			x=SG(read());
			while(x)
			{
				b[y]+=x&1;
				x>>=1;
				y++;
			}
			y=0;
		}
		for(j=0;j<32;j++)
		{
			if(b[j]%k)
				ans[i]=1;
			b[j]=0;
		}
		puts(ans[i]?"YES":"NO");
	}
}
```


---


# 四暗刻单骑

## 题目描述

Alice 和 Bob 很喜欢打麻将。他们在对麻将规则熟悉后，开始对「四暗刻单骑」感兴趣。而在这局游戏中，Alice 和 Bob 都已经集齐了四暗刻，处于听牌状态并准备「四暗刻单骑」，于是我们将这样的局面简化如下：

- 一张麻将牌可以用一个范围在 $[1, k]$ 内的正整数表示，数字相同的牌相同，数字不同的牌不相同。
- Alice 和 Bob 手中各有 $1$ 张牌作为手牌。两人轮流进行摸牌，每次摸牌的玩家会得到一张牌堆顶部的牌，Alice 先进行。摸牌后会有 $2$ 张手牌，此时需要选择一张牌打出。打出的牌双方可见。
- 当摸牌时两张手牌相同时，或当前对方打出的牌和自己目前手牌相同时，该玩家「和牌」并获胜，游戏结束。

若牌摸完后无玩家「和牌」，则判为「荒牌流局」，此时判定两位玩家平局。

现在 Alice 和 Bob 都绝顶聪明，并且已经得知了牌堆顶部的所有牌，以及对方手牌。他们都希望自己可以「和牌」并获胜，若自己无法「和牌」就会尽可能阻止对方「和牌」。

你现在拿到了 $n$ 张麻将牌组成的 $a$ 数组，下标依次为 $1\dots n$。现在有 $m$ 次询问，每次会给定 $x, y, l, r$ 表示：若目前 Alice 手牌为 $x$，Bob 手牌为 $y$，且 **按顺序** 取出 $a$ 中下标为 $[l, r]$ 的所有牌作为游戏牌堆，其中牌 $a_l$ 位于牌堆顶部，Alice 和 Bob 按要求进行游戏，最后结局如何。

询问之间相互独立。特别地，**保证 $l$ 为奇数**。

## 说明/提示

**【样例 1 解释】**

在第 $1$ 组询问中，牌堆自顶至底依次是 $3, 4$，Alice 手牌为 $1$，Bob 手牌为 $2$。不难发现此局面会导致「荒牌流局」。 

在第 $2$ 组询问中，牌堆自顶至底依次是 $1, 3, 1, 5, 4, 3$，Alice 手牌为 $5$，Bob 手牌为 $5$。此时 Bob 只需要一直保留这张 $5$，就可以在摸上下一张 $5$ 时「和牌」；而 Alice 不能打出 $5$，因为一旦打出就会导致 Bob 立刻「和牌」。

在第 $3$ 组询问中，牌堆自顶至底依次是 $1, 2, 3, 4, 1$，Alice 手牌为 $3$，Bob 手牌为 $4$。Alice 第一局摸上一张 $1$，她打出这张 $1$。Bob 第一局摸上一张 $2$，他无论是否打出这张 $2$，Alice 都可以在下回合「和牌」。 

---

#### 【样例 3】

见附件下的 $\verb!mahjong/mahjong3.in!$ 与 $\verb!mahjong/mahjong3.ans!$。

---

#### 【样例 4】

见附件下的 $\verb!mahjong/mahjong4.in!$ 与 $\verb!mahjong/mahjong4.ans!$。

---

**【数据范围】**

| 测试点编号 | $n\le$ | $m\le$ | $k\le$ | 特殊性质 |
| :--------: | :----: | :----: | :----: | :------: |
| $1$ | $3$ | $3$ | $3$ | A, B |
| $2$ | $5$ | $5$ | $5$ | 无 |
| $3\sim 5$ | $100$ | $100$ | $100$ | 无 |
| $6\sim 7$ | $2000$ | $2000$ | $2000$ | 无 |
| $8\sim 10$ | $5\times 10^4$ | $50$ | $5\times 10^4$ | 无 |
| $11$ | $2\times 10^5$ | $2\times 10^5$ | $2$ | 无 |
| $12$ | $2\times 10^5$ | $2\times 10^5$ | $80$ | 无 |
| $13$ | $2\times 10^5$ | $2\times 10^5$ | $2\times 10^5$ | A, B |
| $14\sim 15$ | $2\times 10^5$ | $2\times 10^5$ | $2\times 10^5$ | B |
| $16$ | $2\times 10^5$ | $2\times 10^5$ | $2\times 10^5$ | C |
| $17\sim 20$ | $10^5$ | $10^5$ | $10^5$ | 无 |
| $21\sim 25$ | $2\times 10^5$ | $2\times 10^5$ | $2\times 10^5$ | 无 |

+ 特殊性质 A：保证每次询问 $l = 1$。
+ 特殊性质 B：保证每次询问 $r = n$。
+ 特殊性质 C：保证每次询问 $x = y$。

对于 $100\%$ 的数据，保证 $3 \leq n \leq 2\times 10^5$，$1 \leq m \leq 2\times 10^5$，$1 \leq a_i, x, y \leq k \leq n$，$1 \leq l \leq r \leq n$，**保证 $l$ 是奇数**。

## 样例 #1

### 输入

```
12 3 5
2 3 1 2 3 4 1 3 1 5 4 3
1 2 5 6
5 5 7 12
3 4 3 7```

### 输出

```
D
B
A```

## 样例 #2

### 输入

```
7 6 3
2 3 3 3 1 3 3 
1 2 5 7
1 1 5 6
1 3 1 6
2 3 7 7
1 3 3 5
1 2 1 4```

### 输出

```
A
A
B
D
B
D
```

# 题解

## 作者：樱雪喵 (赞：34)

### Part 1. $O(nm)$

先观察题目的一些基本性质。

- 交替摸牌，所以每张牌被谁摸到是固定的。
- 因为游戏过程中每个人手里的两张牌都不会相同（不然就结束了），他们一定不会打出和对手手里一样那张牌。所以最后和牌的方式一定是一个人从牌堆中摸到了和自己一样的牌。
- 再考虑两个人手牌一样的情况，他们任何一人都不能丢掉这张牌，不然对面就赢了。因此这种情况的结局是能够直接判定的：判断下一张相同的牌被谁摸到即可，如果没有就是平局。

那么，一个人想和牌，他的策略一定是从某个时刻开始一直拿着某张牌，直到摸到下张一样的。

考虑某个人一直拿着第 $i$ 张牌会产生什么效果：
- 如果下一张同色的牌被自己摸到，设它的位置是 $x$。那么拿着这张牌的结果是在 $x$ 时刻胜利。
- 如果下一张同色的牌被对手摸到，对手必然不能把这张牌丢掉。因此双方手牌相同，结局已经确定。
  - 再下一张被自己摸到，但因为从 $x$ 时刻开始对面就没有翻盘的机会了，我们记它的结果是在 $x$ 时刻直接胜利。
  - 被对手摸到，记它的结果是在 $x$ 时刻失败。
  - 否则是在 $x$ 时刻达成平局。

那么我们可以在序列上模拟这个过程，如果牌的效果是胜利就选择胜利更早的；失败就选择失败得更晚的，因为可能后面能摸到胜利的牌而翻盘。如果当前已经到达了某个人手里的牌的胜利或失败时刻，则判定答案。

然而直接这样搞并不正确，~~可怜的樱雪喵写假了一天也没想明白哪里不对。~~

考虑这样的一组数据：牌堆依次为 $3,1,4,3,4$，初始手牌为 $1,2$。  
Alice 在第一轮是否把牌换成 $3$ 都是平局，她更希望等到后面胜利。而 Bob 如果寄希望于后面胜利，不选择把 $2$ 换成 $1$，他最后只能失败。而如果他的目标是平局，他会摸走牌堆中的 $1$，并成功平局。  
这启发我们思考一个问题：存在一些情况，如果一个人目标是取得胜利，他就输了；但如果他的目标仅仅是保住平局，却能成功阻止对面赢。这是不能直接贪心判断的。

考虑用如下做法改变他们的目标：先钦定平局算 Alice 赢，这等价于 Alice 的目标是保住平局。如果此时 Bob 仍然能赢，才算作 Bob 必胜。反之同理。  
如果正反都不满足条件，则说明存在一种方式使本来要输的人保住平局，答案为平局。

细节想不清楚的话很容易写假，可以参考代码理解。
```cpp
const int N=2e5+5;
int id,n,m,k,a[N],flag;
vector<int> pos[N];
il int find(int x,int l,int r)
{
    auto qwq=upper_bound(pos[x].begin(),pos[x].end(),l);
    if(qwq==pos[x].end()||(*qwq)>r) return -1;
    return *qwq;
}
il int getw(int x,int l,int r,int fg=0)
{
    int qwq=find(x,l+fg,r);
    if(qwq==-1) return (l&1)==flag?n+1:-n-1;
    if((qwq&1)==(l&1)) return qwq;
    int nqwq=find(x,qwq,r);
    if(nqwq==-1) return (l&1)==flag?qwq:-qwq;
    else if((nqwq&1)==(l&1)) return qwq;
    else return -qwq;
}
il int solve(int x,int y,int l,int r)
{
    if(x==y)
    {
        int nxt=find(x,l-1,r);
        if(nxt==-1) return flag?1:-1;
        else if((nxt&1)==(l&1)) return 1;
        else return -1;
    }
    int wx=getw(x,l-2,r,1),wy=getw(y,l-1,r);
    for(int i=l;i<=r;i++)
    {
        if(wx==i) return 1; if(wy==i) return -1;
        if(-wx==i) return -1; if(-wy==i) return 1;
        if(x==y)
        {
            int nxt=find(x,i-1,r);
            if(nxt==-1) return flag?1:-1;
            else if((nxt&1)==(l&1)) return 1;
            else return -1;
        }
        if((i&1)==(l&1))
        {
            int nxt=getw(a[i],i,r);
            if(nxt>0&&(nxt<wx||wx<0)) wx=nxt,x=a[i];
            else if(nxt<0&&wx<0&&nxt<wx) wx=nxt,x=a[i];
        }
        else 
        {
            int nxt=getw(a[i],i,r);
            if(nxt>0&&(nxt<wy||wy<0)) wy=nxt,y=a[i];
            else if(nxt<0&&wy<0&&nxt<wy) wy=nxt,y=a[i];
        }
    }
    return flag?1:-1;
}
int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++) a[i]=read(),pos[a[i]].push_back(i);
    while(m--)
    {
        id++;
        int x=read(),y=read(),l=read(),r=read();
        flag=1; int res1=solve(x,y,l,r);
        flag=0; int res0=solve(x,y,l,r);
        if(res1==-1) printf("B\n");
        else if(res0==1) printf("A\n"); else printf("D\n");
    }
    return 0;
}
```

### Part 2. $O((n+m)\log n)$

假设每张牌的结局是已经确定的，依旧不容易快速地维护答案，因为输了要尽可能晚输，赢了又要尽可能早赢。  

我们继续观察性质。

注意到，到达某张手牌判定答案的时刻时，被判定的一定是赢的那张牌。换句话说，一个人必然不会一直拿着一张输的牌，直到因为这张牌而输掉。

考虑证明这个结论。假设 Alice 现在手里拿着一张输的牌，并且下一轮就要输了；这时候她又摸到了另一张要输的牌。因为这两张牌不同，它们输的位置也一定不同。那么新摸的这张牌一定输得比原来那张要晚。每当出现这种情况 Alice 就换牌，即可保证始终不因为输的牌而输掉。    
当然这里要特判拿着初始手牌在第一轮就输掉的情况，因为此时他们没有选择权。

因此我们只需判断一段区间内最早赢的牌被谁摸到了。

考虑离线询问，从左向右扫描 $r$。对于在 $i$ 位置的牌，它的贡献只与它下一张相同的牌、下下张相同的牌是否在区间内有关。因此一张牌的贡献只会改变 $3$ 次，可以每次修改暴力求新值。  
那么对于每个询问，最早赢的牌即为区间内最小值所在的位置，判断这张牌位置的奇偶性即可。

我们需要一个数据结构支持单点修改，区间查询最小值和最小值的位置。这里使用线段树维护。

```cpp
const int N=2e5+5,inf=1e9;
int id,n,m,k,a[N],flag;
vector<int> pos[N];
il int find(int x,int l,int r)
{
    auto qwq=upper_bound(pos[x].begin(),pos[x].end(),l);
    if(qwq==pos[x].end()||(*qwq)>r) return -1;
    return *qwq;
}
il int getw(int x,int l,int r,int fg=0)
{
    int qwq=find(x,l+fg,r);
    if(qwq==-1) return inf;
    if((qwq&1)==(l&1)) return qwq;
    int nqwq=find(x,qwq,r);
    if(nqwq==-1) return (l&1)==flag?qwq:inf;
    else if((nqwq&1)==(l&1)) return qwq;
    else return inf;
}
struct segtree
{
    struct node{int mn,pos;} tr[N<<2];
    #define ls (x<<1)
    #define rs (x<<1|1)
    #define mid (l+r>>1)
    il node pushup(const node &l,const node &r)
    {
        if(l.mn<r.mn) return l;
        else return r;
    }
    void build(int x,int l,int r) 
    {
        if(l==r) {tr[x]={inf,l};return;}
        build(ls,l,mid),build(rs,mid+1,r);
        tr[x]=pushup(tr[ls],tr[rs]);
    }
    void upd(int x,int l,int r,int p,int k)
    {
        if(l==r) {tr[x]={k,l};return;}
        if(p<=mid) upd(ls,l,mid,p,k);
        else upd(rs,mid+1,r,p,k);
        tr[x]=pushup(tr[ls],tr[rs]);
    }
    node query(int x,int l,int r,int ml,int mr) 
    {
        if(l==ml&&r==mr) return tr[x];
        if(mr<=mid) return query(ls,l,mid,ml,mr);
        else if(ml>mid) return query(rs,mid+1,r,ml,mr);
        else return pushup(query(ls,l,mid,ml,mid),query(rs,mid+1,r,mid+1,mr));
    }
}seg;
int ans[2][N];
vector<int> nd[N];
struct node{int x,y,l,r,id;};
vector<node> q[N];
il int calc(int x,int y,int l,int r)
{
    if(x==y)
    {
        int nxt=find(x,l-1,r);
        if(nxt==-1) return flag?1:-1;
        else if((nxt&1)==(l&1)) return 1;
        else return -1;
    }
    if(y==a[l])
    {
        int nxt=find(y,l,r);
        if(nxt!=-1&&((nxt&1)==(l&1))) return 1;
        else if(nxt==-1) return flag?1:-1;
    }
    int wx=getw(x,l-2,r,1),wy=getw(y,l-1,r);
    int ans=min(wx,wy),pos=(wx<wy)?l-2:l-1;
    segtree::node qwq=seg.query(1,1,n,l,r);
    if(qwq.mn<ans) ans=qwq.mn,pos=qwq.pos;
    if(ans==inf) return flag?1:-1;
    return ((l&1)==(pos&1))?1:-1;
}
void solve()
{
    seg.build(1,1,n);
    for(int r=1;r<=n;r++)
    {
        for(auto x:nd[r]) seg.upd(1,1,n,x,getw(a[x],x,r));
        for(auto i:q[r])
        {
            int x=i.x,y=i.y,l=i.l,r=i.r,id=i.id;
            ans[flag][id]=calc(x,y,l,r);
        }
    }
}
int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++) a[i]=read(),pos[a[i]].push_back(i);
    for(int i=1;i<=m;i++) 
    {
        int x=read(),y=read(),l=read(),r=read();
        q[r].push_back({x,y,l,r,i});
    }
    for(int i=1;i<=n;i++) 
    {
        int nxt=find(a[i],i,n);
        if(nxt==-1) continue;
        nd[nxt].push_back(i);
        int nnxt=find(a[i],nxt,n);
        if(nnxt!=-1) nd[nnxt].push_back(i);
    }
    for(flag=0;flag<2;flag++) solve();
    for(int i=1;i<=m;i++)
    {
        if(ans[1][i]==-1) printf("B");
        else if(ans[0][i]==1) printf("A");
        else printf("D");
        printf("\n");
    }
    return 0;
}
```

---

## 作者：lkytxdy (赞：14)


题解参考了 [here](https://www.luogu.com.cn/problem/U381383)。


## Solution

### 1. $x=y$

- 不难发现，此时无论是 Alice 还是 Bob，都不能弃掉初始手牌，否则对方就和牌了。

  因此，赢家是先成功自摸的一个。找出 $[l,r]$ 中 $x$ 的首次出现位置（vector 存每种值的出现位置，每次在对应 vector 中二分），若是 Alice 取的，则 Alice 赢；若是 Bob 取的，则 Bob 赢；若没有出现，则平局。


### 2. $\mathcal O(nm\log n)$

（$\log$ 来自二分）

- 根据 $x=y$ 的做法，我们发现，若某个时刻两人手牌相同了，之后他们的打法就是唯一的，结局就注定了。

  假设 $x\neq y$，目前牌堆顶部的牌为 $z$。对于当前操作者而言：

  - 若 $z$ 与自己的手牌相同，则成功自摸，胜利。
  - 若 $z$ 与对方的手牌相同，那么自己取了 $z$ 后必然不能将它舍弃（否则对方就和牌了），转化为了上述 $x=y$ 的情形，此后虽然牌局尚未结束，但已决胜负。

  综上，**若 $x,y,z$ 中有某两个相同，结局就注定了**。

- 于是，对于位置 $i$，设 $a_i$ 下一次出现位置在 $j$（若不存在则为 $\infty$），那么若操作者取了 $i$ 后始终不把它弃掉，且游戏在 $j$ 处时还未终止，则在 $j$ 处时结局就注定了。因此，一张牌 $i$，可以转化为二元组 $(time_i,op_i)$，表示 **若保留 $i$，且 $time_i$ 时游戏还没有结束，则到 $time_i$ 处时结局注定是 $op_i$**。

  处理出 $[l,r]$ 中的牌以及初始手牌对应的 $(time_i,op_i)$ 后，从前往后决策，Alice 和 Bob 每次都会选择更有利于自己的牌留下。具体地，赢的牌一定比输的优，赢的牌中 $time$ 越小越优（减小对手翻盘的希望），输的牌中 $time$ 越大越优（增大自己翻盘的希望，因为可能后面能摸到胜利的牌就能翻盘）。

  （$(time_i,op_i)$ 描述的其实是一种趋势，博弈论一般是从后往前做的，但是这里已经预处理了进行每次决策后的趋势，并且我们可以比较每种趋势的牌选哪种在之后的局面中更优，所以可以从前往后进行决策）

  注意，$op_i$ 仅仅是表示一种结局的趋势，因为 **有可能根本等不到 $time_i$ 去注定 $op_i$**。

  所以就有一个问题：我们不知道 赢的牌 与 平局的牌 哪个优，因为赢的牌在 $time$ 之前可能对方就已经赢了，结局是对方赢；而平局的牌可能因为 $time$ 比较小，等不到对方赢，结局是平局。而 赢的牌 与 输的牌 是可以比较的，选赢的牌总归结果不会更差。

  所以必须把平局的牌处理掉。

- **对平局的处理：如果平局算作 Bob 赢的情况下，Alice 还能赢，说明必然是 Alice 赢；如果平局算作 Alice 赢的情况下，Bob 还能赢，说明必然是 Bob 赢；否则平局**。

  （设 Alice 赢 / Bob 赢 / 平局 的局面集合为 $A,B,C$，初始局面为 $x$。我们先判断了 $x\in A$ 还是 $x\in B\cup C$；再判断了 $x\in B$ 还是 $x\in A\cup C$。根据这个信息就能判断 $x\in A$ 还是 $x\in B$ 还是 $x\in C$ 了）
  
  对平局算作 Bob/Alice 赢分别跑一次即可。

  这样就只有 赢和输 两种牌了。

```cpp
//52 分暴力
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,k,a[N],o,x,y,l,r;	//o=1/0：平局算 Alice/Bob 赢
vector<int>v[N];
array<int,2>A,B;
bool calc(int l,int r,int x){	//x=y，牌堆为 [l,r]，结局是什么
	int i=*lower_bound(v[x].begin(),v[x].end(),l);
	return i>r?o:i&1;
}
array<int,2> get(int who,int i,int x){	//当前 who 取第 i 张牌（who=1/0: Alice/Bob），第 i 张牌数字是 x，这张牌对应的 (time,op=1/0: Alice/Bob 赢)
	int j=*upper_bound(v[x].begin(),v[x].end(),i),op;
	if(j>r) op=o;
	else{
		if((j&1)==who) op=who;
		else op=calc(j+1,r,x);
	}
	return {j,op};
}
bool work(){
	if(x==y) return calc(l,r,x);
	A=get(1,l-1,x),B=get(0,l-1,y);
	for(int i=l;i<=r;i++){
		auto p=get(i&1,i,a[i]);
		if(i&1){
			if(p[1]>A[1]||(p[1]==A[1]&&((p[1]&&p[0]<A[0])||(!p[1]&&p[0]>A[0])))) A=p;
		}
		else
			if(p[1]<B[1]||(p[1]==B[1]&&((!p[1]&&p[0]<B[0])||(p[1]&&p[0]>B[0])))) B=p;
		if(A[0]==i) return A[1];
		if(B[0]==i) return B[1];
	}
	return o;
}
signed main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),v[a[i]].push_back(i);
	for(int i=1;i<=k;i++) v[i].push_back(n+1);
	while(m--){
		scanf("%d%d%d%d",&x,&y,&l,&r);
		int a,b;
		o=0,a=work(),o=1,b=work();
		puts(a?"A":(!b?"B":"D"));
	}
	return 0;
}
```

### 3. $\mathcal O((n+m)\log n)$

- 一个重要的结论是，若 Alice 在 $i$ 处取了 $a_i$，其对应的二元组为 $(j,0)$，那么 Alice 一定不会因此在 $j$ 处输掉（一定不会始终保留这张 $i$，直到因为这张牌在 $j$ 输掉）；同理，若 Bob 在 $i$ 处取了 $a_i$，其对应的二元组为 $(j,1)$，那么 Bob 一定不会因此在 $j$ 处输掉。（其中，$op=1$ 表示 Alice 赢，$op=0$ 表示 Bob 赢）

  换句话说，**对于牌堆里的一个让自己输的牌 $i$，一定会在 $j$ 之前换牌**。

  > 证明：以 Alice 为例。因为输掉，所以 $j$ 一定是 Bob 摸的，那么 $j-1$ 会是 Alice 摸的，而 $j-1$ 处的二元组一定比 $(j,0)$ 优，就算前面没有换牌，到 $j-1$ 处时 Alice 也一定会换牌。

  注意初始手牌比较特别，如果初始手牌是 $(l,?)$，没办法在区间外（$l-1$ 处）换牌，所以需要特判；而牌堆里的牌显然有 $j>l$。

- **特判掉初始手牌后**，本题的关键性质就出来了：我们可以 **忽略所有让自己输的牌**。

  好处是，原本我们需要依次枚举每张牌比较优劣，因为要依次扫过去才知道是赢的牌还是输的牌。现在只要考虑赢的牌，那么只要直接找到 $time$ 最小的就好了。

  找到所有 **让自己赢的牌中，$time$ 最小的，看是被谁取的** 即可。

- 最后的问题是，怎么快速算所有 $(time,op)$。

  对于牌 $l\leq i$，设下一次出现在 $j$，下下次出现在 $k$。根据二元组的计算方式，可以发现我们只关心 $j,k$ 是否在区间内。分别算出 $r<j$、$r\geq j$、$r\geq k$ 三种情况分别对应的三元组即可。

  扫描线 $r$，线段树来支持“单点修改，区间查询最小值和最小值的位置”即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,k,a[N],r,o,ans[2][N];
vector<int>v[N],upd[N];
array<int,2>A,B,mn[N<<2];
vector<array<int,4> >q[N];
bool calc(int l,int r,int x){
	int i=*lower_bound(v[x].begin(),v[x].end(),l);
	return i>r?o:i&1;
}
array<int,2> get(int who,int i,int x){
	int j=*upper_bound(v[x].begin(),v[x].end(),i),op;
	if(j>r) j=n+1,op=o;
	else{
		if((j&1)==who) op=who;
		else op=calc(j+1,r,x);
	}
	return {j,op};
}
void modify(int p,int l,int r,int pos,int v){
	if(l==r){mn[p]={v,l};return ;}
	int mid=(l+r)/2;
	if(pos<=mid) modify(p<<1,l,mid,pos,v);
	else modify(p<<1|1,mid+1,r,pos,v);
	mn[p]=min(mn[p<<1],mn[p<<1|1]);
}
auto query(int p,int l,int r,int lx,int rx){
	if(l>=lx&&r<=rx) return mn[p];
	int mid=(l+r)/2;
	array<int,2>ans={n+2,0};
	if(lx<=mid) ans=query(p<<1,l,mid,lx,rx);
	if(rx>mid) ans=min(ans,query(p<<1|1,mid+1,r,lx,rx));
	return ans;
}
signed main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),v[a[i]].push_back(i);
	for(int i=1;i<=k;i++)
		v[i].push_back(n+1),v[i].push_back(n+2);
	for(int i=1;i<=n;i++){
		int j=*upper_bound(v[a[i]].begin(),v[a[i]].end(),i),
		k=*upper_bound(v[a[i]].begin(),v[a[i]].end(),j);
		for(int x:{i,j,k}) upd[x].push_back(i);
	}
	for(int i=1,x,y,l;i<=m;i++)
		scanf("%d%d%d%d",&x,&y,&l,&r),q[r].push_back({x,y,l,i});
	for(o=0;o<2;o++){
		for(int i=1;i<=(n<<2);i++) mn[i][0]=1e9;
		for(r=1;r<=n;r++){
			for(int i:upd[r]){
				auto p=get(i&1,i,a[i]);
				modify(1,1,n,i,p[1]==(i&1)?p[0]:1e9);
			}
			for(auto i:q[r]){
				int x=i[0],y=i[1],l=i[2],&f=ans[o][i[3]];
				if(x==y){f=calc(l,r,x);continue;}
				A=get(1,l-1,x),B=get(0,l-1,y);
				if(A[0]==l) f=A[1];
				else if(B[0]==l) f=B[1];
				else{
					auto x=query(1,1,n,l,r);
					if(A[1]) x=min(x,{A[0],1});
					if(!B[1]) x=min(x,{B[0],0});
					f=x[0]<=r?x[1]&1:o;
				}
			}
		}
	}
	for(int i=1;i<=m;i++)
		puts(ans[0][i]?"A":(!ans[1][i]?"B":"D"));
	return 0;
}
```

有错请指出 qwq。

---

## 作者：Little09 (赞：11)

## mahjong solution

### $O(nm)$ 做法

第一步也是很重要的一步，因为有平局，所以我们应当先钦定平局算 Bob 胜利，这样如果 Alice 还能胜利那么答案是 Alice；再钦定平局算 Alice 胜利，这样如果 Bob 还能胜利那么答案是 Bob；否则答案是 Draw。

先进行观察，我们首先可以发现点炮的和牌是行不通的，要和一定是自摸，也就是对手不会打给你你当前有的牌。接下来我们发现，当两个玩家目前手牌相同时，他们只能一直摸切，直到有人自摸或平局。也就是这类情况我们可以直接判定获胜的人。

再观察，如果某一方将一张牌 A 一直握在手里，考虑下一张 A 出现时的情况。不妨设下一张 A 在 $x$ 时刻出现。那么如果下一张 A 就是此人摸到，那么一直握着这张 A 的收益就是在 $x$ 时刻直接获胜。否则双方会进入上述的摸切环节，那么考虑再下一张 A 是谁摸到，如果是自己，那么收益还是在 $x$ 时刻直接获胜；如果是对方，那么收益是在 $x$ 时刻直接失败。注意如果根本没有下一张牌，那么这张牌的收益就是啥也没有；如果有下一张牌但没有再下一张，那么根据平局算谁胜来判断对应收益。

因此对于每张牌，我们可以计算出它对应的收益，也就是一直拿着它，你会在第几轮立刻获胜，还是在第几轮立刻输掉，还是啥事没有。我们再声称游戏的胜负仅和握的牌产生的收益相关。例如如果有一局你打出一张牌恰好等于对手的手牌，那么这个应当已经在对手的这张牌的收益中进行计算。所以我们直接扫一遍序列，维护当前两个人持有的手牌，每次贪心选择更优的手牌，如果当前时刻有人的手牌收益产生，那么判定胜负。

一个小细节需要注意：如果双方初始手牌相同，那么立刻进入摸切环节，只需要判断下一张这个牌是谁摸上来就行，需要特判这种情况。

### $O((n+m)\log n)$ 做法

在用数据结构维护上述过程中一个麻烦的问题是，对于收益是在某回合立刻输掉的牌，操作者的方案是选择回合较大的牌留下，而这样不满足二分性并且不方便用数据结构维护。但是我们可以继续观察性质：假设当前为第 $x$ 回合，该玩家两张手牌都是收益是在某回合输掉的牌，注意到首先这两个回合一定都大于 $x$，且一定和 $x$ 的奇偶性不同，而且这两个回合还一定不相等，所以至少有一张牌会在 $x+2$ 回合以上输掉，那么保留这张牌，每回合都这么做，就会永远不会因为收益是在某回合立刻输掉的牌而输掉。所以我们根本不用管这些输掉的牌。

一个细节是，如果 Bob 的初始手牌是收益是在某回合立刻输掉的牌，由于 Bob 一开始没有选择权，所以这张牌是有可能导致一回合后 Bob 立刻输掉的，这种情况需要特判。

那么我们只要关注收益是在某回合获胜的牌。要是我们能找到区间内所有这样的牌，我们只需要找到导致获胜回合最小的那张，显然只需要判断这张牌属于谁就行。考虑随着 $r$ 端点的移动，每张牌的收益发生的变化：假设这张牌和其后两张相同牌出现位置分别为 $x,y,z$，那么当 $r\in[x,y]$ 时，这张牌没有收益；当 $r\in[y,z]$ 时，这张牌收益为平局的收益；当 $r\in[z,n]$ 时，这张牌收益根据 $z$ 的奇偶性决定。所以每张牌收益会变化 $O(1)$ 次，我们在扫描 $r$ 的时候动态维护，然后每次查询就是区间最小值，线段树维护即可。

最后一步也可以扫描 $l$，然后观察到每种牌只有最近 $3$ 张有效，从而数据结构维护。当然也有一些其他维护方法，这里不再赘述。

---

## 作者：Gmt丶FFF (赞：8)

非常好玩的题目，但是有点难度。

首先可以想到这题是个贪心，我们可以先去考虑怎么暴力贪心。

如果开局两个人牌是一样的，都为 $x$，那答案已经确定了，可以直接用二分查找下一个 $x$ 的位置即可。

如果开局两个人牌不一样，我们先看手上两张牌的贡献。

若手上拿的牌为 $x$，贡献分为五种：

一、后面没有 $x$ 了，空听，贡献为 $0$。

二、后面有 $x$ 且下一个 $x$ 我能摸到，贡献即为在下一个 $x$ 的位置我就可以和牌。

三、后面有 $x$ 但下一个我摸不到，且再下一个 $x$ 我摸得到，那么贡献即为在下一个 $x$ 的位置我就提前赢得比赛。

四、后面有 $x$ 但下一个我摸不到，且再下一个 $x$ 我摸不到，那么贡献即为在下一个 $x$ 的位置我就提前输掉比赛。

五、后面有 $x$ 但下一个我摸不到，且再后面没有 $x$ 了，那么贡献为即为在下一个 $x$ 的位置我就提前获得平局。

解释一下三四五三种情况，如果我手上拿 $x$，下一个 $x$ 我摸不到，必然是另一个人拿到，那他肯定不能扔出，现在情况就转换为两个人牌一样的情况。

可以发现，四情况实际不存在，因为一个人知道自己要输了，不可能还傻傻的去拿这个牌（除了初始手牌，特殊情况后面讨论）。

对于一情况，我们不会主动获得这种情况，因为如果能稳定赢和平，那不可能会去选择空听。

对于五情况，这是应急情况，如果在计算二三两种情况时发现自己必输，才会去考虑四情况来平局，很简单个道理，如果在计算二三两种情况时发现自己必赢，那肯定不会考虑平局。

对于二三两种情况，都是赢的两种情况，并且我们已经得到了其赢的时间点，也就是贡献，那么贡献得到的时间最靠前的一定就是必赢的。

我们也就得到了一个暴力，预处理出每个点的二三五这三种贡献，然后我们先看二三两种情况的贡献，得到胜者，再看败者的五贡献是否先于胜者的贡献。如果是，说明败者可以追平，否则原胜者必赢。

对于初始手牌的特判，分三种。

一、如果牌一样，那么直接找到下一个牌的奇偶性来判断即可。

二、如果先手摸到的第一张牌与 $y$ 的初始手牌相同，判断是否有四情况的出现，如果有，那先手可以选择摸第一张牌使 $y$ 必败。

三、计算初始手牌的二三五贡献，与区间内所有的贡献取最小值。

这样我们就得到了一个 $O(nm)$ 的暴力。

优化很显然，我们可以把询问离线下来，然后扫描线，因为所有点固定，且题目还甚至保证 $l$ 为奇数的情况下，每个人摸的牌也就固定了。由于一个点的贡献只受后两个点与自己值相同的点的影响，所以我们可以在扫描时修改点的值。

至于取最小值，线段树维护即可。初始的点该特判还是正常特判。

时间复杂度降为 $O((n+m)\log n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int N=2e5+5;
const int inf=1e9;
int a[N],n,m,k,res[N];
struct node
{
	int name,l,x,y;
};
vector<node>q[N];
vector<int>t[N];
struct node2
{
	int x,y;
};
bool operator <(node2 x,node2 y)
{
	return x.x<y.x;
}
struct tree
{
	node2 f[4*N];
	inline int ls(int x)
	{
		return x<<1;
	}
	inline int rs(int x)
	{
		return x<<1|1;
	}
	void pushup(int x)
	{
		f[x]=min(f[ls(x)],f[rs(x)]);
	}
	void build(int x,int l,int r)
	{
		if(l==r)return (void)(f[x]={inf,l});
		int mid=(l+r)>>1;
		build(ls(x),l,mid);
		build(rs(x),mid+1,r);
		pushup(x);
	}
	void update(int x,int l,int r,int nl,int k)
	{
		if(l==r)return (void)(f[x]={k,l});
		int mid=(l+r)>>1;
		if(mid>=nl)update(ls(x),l,mid,nl,k);
		else update(rs(x),mid+1,r,nl,k);
		pushup(x);
	}
	node2 query(int x,int l,int r,int nl,int nr)
	{
		if(nl>nr)return {inf,inf};
		if(l>=nl&&r<=nr)return f[x];
		int mid=(l+r)>>1;
		node2 sum={inf,inf};
		if(mid>=nl)sum=min(sum,query(ls(x),l,mid,nl,nr));
		if(mid<nr)sum=min(sum,query(rs(x),mid+1,r,nl,nr));
		return sum;
	}
}p[3];
int main()
{
//	freopen("mahjong4.in","r",stdin);
//	freopen("data.out","w",stdout);
//	system("fc mahjong4.ans data.out");
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)
	{
		int x,y,l,r;
		scanf("%d%d%d%d",&x,&y,&l,&r);
		q[r].push_back({i,l,x,y});
//		cerr<<x<<" "<<y<<endl;
//		for(int j=l;j<=r;j++)cerr<<a[j]<<" ";
//		cerr<<endl; 
	}
	p[0].build(1,1,n);
	p[1].build(1,1,n);
	p[2].build(1,1,n);
	for(int i=1;i<=n;i++)
	{
//		cerr<<i<<endl;
		int len=t[a[i]].size();
		if(len>=1&&!((t[a[i]][len-1]^i)&1))p[2].update(1,1,n,t[a[i]][len-1],i);
		else if(len>=2&&!((t[a[i]][len-2]^i)&1))p[2].update(1,1,n,t[a[i]][len-2],t[a[i]][len-1]);
		if(len>=1&&((t[a[i]][len-1]^i)&1))p[t[a[i]][len-1]&1].update(1,1,n,t[a[i]][len-1],i);
		if(len>=2)p[t[a[i]][len-2]&1].update(1,1,n,t[a[i]][len-2],inf);
		t[a[i]].push_back(i);
		len=q[i].size();
		for(int j=0;j<len;j++)
		{
			int name=q[i][j].name,x=q[i][j].x,y=q[i][j].y,l=q[i][j].l,r=i;
			node2 ans=p[2].query(1,1,n,l,r);
			int nl=0,nr=t[x].size()-1;
//			cout<<ans.x<<" "<<ans.y<<" "<<nl<<" "<<nr<<" "<<x<<endl;
			while(nl<nr)
			{
				int mid=(nl+nr)>>1;
				if(t[x][mid]<l)nl=mid+1;
				else nr=mid;
			}
			int xx=nl;
			nl=0,nr=t[y].size()-1;
			while(nl<nr)
			{
				int mid=(nl+nr)>>1;
				if(t[y][mid]<l)nl=mid+1;
				else nr=mid;
			}
			int yy=nl;
			int len1=t[x].size(),len2=t[y].size(),px=1e9,py=1e9;
			
			if(x==y)ans={inf,inf};
			if(xx<len1&&t[x][xx]<l)xx++;
			if(xx<len1&&(t[x][xx]&1))ans=min(ans,{t[x][xx],1});
			else if(x!=y&&xx<len1-1&&(t[x][xx+1]&1))ans=min(ans,{t[x][xx],1});
			else if(xx==len1-1)px=t[x][xx];
			if(yy<len2&&t[y][yy]<l)yy++;
			if(yy<len2&&!(t[y][yy]&1))ans=min(ans,{t[y][yy],0});
			else if(x!=y&&yy<len2-1&&!(t[y][yy+1]&1))ans=min(ans,{t[y][yy],0});
			else if(yy==len2-1)py=t[y][yy];
			if(x!=y)
			{
				px=min(px,p[1].query(1,1,n,l,ans.x-1).x);
				py=min(py,p[0].query(1,1,n,l,ans.x-1).x);
				if(a[l]==y)
				{
					if(yy==len2-1)px=l;
					else if(yy<len2-1&&(t[y][yy+1]&1))ans={l,1};
				}
			}
			else px=py=1e9;
//			cerr<<xx<<" "<<ans.x<<" "<<ans.y<<" "<<px<<" "<<py<<" "<<endl;
			if(ans.x>n)res[name]=0;
			else if((ans.y&1)&&py>=ans.x)res[name]=1;
			else if(!(ans.y&1)&&px>=ans.x)res[name]=-1;
			else res[name]=0;
		}
	}
	for(int i=1;i<=m;i++)
	{
		if(res[i]==1)puts("A");
		else if(res[i]==-1)puts("B");
		else puts("D");
	}
	return 0;
}
```


---

## 作者：王熙文 (赞：4)

感觉现有两篇题解的“钦定平局算某人赢”的思想有点奇怪，因此写一篇不需要这个想法的题解。但是做法应该本质相同。

## 思路

首先考虑 $x=y$ 时的情况。此时每个人都不能打出原来的牌，那么答案就是第一个 $a_i=x$ 的 $i$ 被摸到的人（如果不存在答案为平局）。

根据上面，可以发现当接下来要摸的牌与某一个人的牌相同，则结局是确定的。这也是这道题的关键。

还可以发现，除了第一个人第一次摸牌或 A 的牌已经与 B 的牌相同的情况，出现 A 的手牌与 B 摸到的牌相同的情况一定是 A 乐意的，即 A 接下来不可能输。因为如果 A 接下来会输，他可以之前换牌，当前可选择的两个牌一定都与 B 当前的牌不同（否则牌就相同了），那么选择不与 B 接下来摸到的牌相同的牌保留即可。

这样我们可以对每个人维护想让自己赢或平局确定的最早的时间。对于每一个牌，假设这个牌要一直保留，求出下一个相等的牌的位置，并求出胜负，更新时间。最后，如果第一个人赢的时间小于第二个人赢的时间或平局的时间，第一个人赢。同理判断第二个人。如果都不满足就是平局。

为什么这样做是对的？因为对于时间最早的方案，之前一定不可能有干扰，即 A 摸到了 B 的手牌且接下来 A 不能赢的情况，否则这个方案就不是时间最早的。这样 A 就一直拿着他要胡的牌即可。

可以先看我写的暴力代码以便更好地理解。

```cpp
void upd(int r,int wz,bool op,int &w,int &d) // wz 是第二次摸到牌的时间，op 是第一次摸到牌的人，w 和 d 是 op 这个人想让自己赢或平局确定的最早的时间，这个函数的作用是更新 w,d
{
	if(wz<=r)
	{
		if(wz%2==op) w=min(w,wz); // 直接胡了
		else if(lst[wz]>r) d=min(d,wz); // 不存在第三次摸到牌的时间，是平局
		else if(lst[wz]%2==op) w=min(w,wz); // 第三次是 op 这个人摸到的，op 赢了
	}
}
int main()
{
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>n>>m>>k;
	for(int i=1; i<=n; ++i) cin>>a[i],e[a[i]].push_back(i);
	memset(vis,0x3f,sizeof(vis));
	for(int i=n; i>=1; --i) lst[i]=vis[a[i]],vis[a[i]]=i;
	for(int i=1; i<=m; ++i)
	{
		int x,y,l,r; cin>>x>>y>>l>>r;
		if(x==y) // 最开始两个人的牌就相同，也需要特判
		{
			auto wz=lower_bound(e[x].begin(),e[x].end(),l);
			cout<<(wz==e[x].end() || (*wz)>r?'D':(*wz)%2==1?'A':'B')<<'\n';
			continue;
		}
		int aw=1e9,ad=1e9,bw=1e9,bd=1e9;
		if(a[l]==y) // 第一个人第一次摸牌，此时第二个人无法选择与第一个人摸到的牌不相同，需要特判
		{
			if(lst[l]>r) ad=min(ad,l);
			else if(lst[l]%2==1) aw=min(aw,l);
		}
		auto wz1=lower_bound(e[x].begin(),e[x].end(),l);
		if(wz1!=e[x].end() && (*wz1)<=r) upd(r,(*wz1),1,aw,ad);
		auto wz2=lower_bound(e[y].begin(),e[y].end(),l);
		if(wz2!=e[y].end() && (*wz2)<=r) upd(r,(*wz2),0,bw,bd);
		for(int i=l; i<=r; i+=2) upd(r,lst[i],1,aw,ad);
		for(int i=l+1; i<=r; i+=2) upd(r,lst[i],0,bw,bd);
		if(aw<min(bw,bd)) cout<<"A\n";
		else if(bw<min(aw,ad)) cout<<"B\n";
		else cout<<"D\n";
	}
	return 0;
}
```

考虑优化暴力枚举并 upd 这个过程。设 $lst_i$ 表示在 $i$ 后面第一个等于 $a_i$ 的位置。现在考虑对 $[l,r]$ 内的奇数 $i$ upd，偶数同理。设第一个人想让自己赢或平局的最早的时间分别为 $w,d$。

* 若 $lst_i$ 是奇数，$w\gets \min(w,lst_i)$。

* 若 $lst_i$ 是偶数且 $lst_{lst_i}>r$，$d \gets \min(d,lst_i)$。

* 若 $lst_i$ 是偶数且 $lst_{lst_i} \le r,lst_{lst_i}$ 是奇数，$w \gets \min(w,lst_i)$。

这个问题如果暴力做是统计矩形最小值，有一些高复杂度的做法。但是对于 $lst$ 相关的问题，有一个很好的性质是 $i$ 与 $lst_i$ 唯一对应。设 $pre_i$ 表示在 $i$ 前面第一个等于 $a_i$ 的位置，则 $i=pre_{lst_i}$。

观察到上面的问题跟 $l$ 没有太大关系，唯一有关系的是 $l \le i$。考虑离线，动态增加 $r$，并对每个 $i$ 维护 $lst_i$ 是否存在（存在就是它本身，否则是无穷大）。因为 $i$ 与 $lst_i$ 唯一对应，修改的位置只有 $\mathcal O(1)$ 个：$pre_i$ 和 $pre_{pre_i}$。因此暴力更新它们的值即可。查询的时候需要求区间最小值。可以使用线段树维护。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int a[200010];
int vis[200010],lst[200010],pre[200010];
vector<int> e[200010];
int aw[200010],ad[200010],bw[200010],bd[200010];
int ans[200010];
void upd(int r,int wz,bool op,int &w,int &d)
{
	if(wz<=r)
	{
		if(wz%2==op) w=min(w,wz);
		else if(lst[wz]>r) d=min(d,wz);
		else if(lst[wz]%2==op) w=min(w,wz);
	}
}
struct Query { int l,id; }; vector<Query> q[200010];
struct Seg_tree
{
	int tree[800010];
	void upd(int now,int l,int r,int qx,int qz)
	{
		if(l==r) return tree[now]=qz,void();
		int mid=l+r>>1;
		if(qx<=mid) upd(now<<1,l,mid,qx,qz);
		else upd(now<<1|1,mid+1,r,qx,qz);
		tree[now]=min(tree[now<<1],tree[now<<1|1]);
	}
	int query(int now,int l,int r,int ql,int qr)
	{
		if(ql<=l && r<=qr) return tree[now];
		int mid=l+r>>1,in=1e9;
		if(ql<=mid) in=min(in,query(now<<1,l,mid,ql,qr));
		if(qr>mid) in=min(in,query(now<<1|1,mid+1,r,ql,qr));
		return in;
	}
} saw,sad,sbw,sbd;
int main()
{
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>n>>m>>k;
	for(int i=1; i<=n; ++i) cin>>a[i],e[a[i]].push_back(i);
	memset(vis,0x3f,sizeof(vis));
	for(int i=n; i>=1; --i)
	{
		lst[i]=vis[a[i]],vis[a[i]]=i;
		if(lst[i]<=n) pre[lst[i]]=i;
	}
	memset(ans,-1,sizeof(ans));
	memset(aw,0x3f,sizeof(aw)),memset(ad,0x3f,sizeof(ad));
	memset(bw,0x3f,sizeof(bw)),memset(bd,0x3f,sizeof(bd));
	for(int i=1; i<=m; ++i)
	{
		int x,y,l,r; cin>>x>>y>>l>>r;
		if(x==y)
		{
			auto wz=lower_bound(e[x].begin(),e[x].end(),l);
			ans[i]=(wz==e[x].end() || (*wz)>r?2:(*wz)%2==1?0:1);
		}
		else
		{
			if(a[l]==y)
			{
				if(lst[l]>r) ad[i]=min(ad[i],l);
				else if(lst[l]%2==1) aw[i]=min(aw[i],l);
			}
			auto wz1=lower_bound(e[x].begin(),e[x].end(),l);
			if(wz1!=e[x].end() && (*wz1)<=r) upd(r,(*wz1),1,aw[i],ad[i]);
			auto wz2=lower_bound(e[y].begin(),e[y].end(),l);
			if(wz2!=e[y].end() && (*wz2)<=r) upd(r,(*wz2),0,bw[i],bd[i]);
			q[r].push_back({l,i});
		}
	}
	memset(saw.tree,0x3f,sizeof(saw.tree)),memset(sad.tree,0x3f,sizeof(sad.tree));
	memset(sbw.tree,0x3f,sizeof(sbw.tree)),memset(sbd.tree,0x3f,sizeof(sbd.tree));
	for(int i=1; i<=n; ++i)
	{
		if(pre[i]!=0)
		{
			if(i%2==1 && pre[i]%2==1) saw.upd(1,1,n,pre[i],i);
			if(i%2==0 && pre[i]%2==0) sbw.upd(1,1,n,pre[i],i);
			if(i%2==0 && pre[i]%2==1) sad.upd(1,1,n,pre[i],i);
			if(i%2==1 && pre[i]%2==0) sbd.upd(1,1,n,pre[i],i);
			if(pre[pre[i]]!=0)
			{
				if(pre[i]%2==0 && pre[pre[i]]%2==1) sad.upd(1,1,n,pre[pre[i]],1e9);
				if(pre[i]%2==1 && pre[pre[i]]%2==0) sbd.upd(1,1,n,pre[pre[i]],1e9);
				if(i%2==1 && pre[i]%2==0 && pre[pre[i]]%2==1) saw.upd(1,1,n,pre[pre[i]],pre[i]);
				if(i%2==0 && pre[i]%2==1 && pre[pre[i]]%2==0) sbw.upd(1,1,n,pre[pre[i]],pre[i]);
			}
		}
		for(Query j:q[i])
		{
			aw[j.id]=min(aw[j.id],saw.query(1,1,n,j.l,i));
			ad[j.id]=min(ad[j.id],sad.query(1,1,n,j.l,i));
			bw[j.id]=min(bw[j.id],sbw.query(1,1,n,j.l,i));
			bd[j.id]=min(bd[j.id],sbd.query(1,1,n,j.l,i));
		}
	}
	for(int i=1; i<=m; ++i)
	{
		if(ans[i]!=-1) cout<<(ans[i]==0?'A':ans[i]==1?'B':'D')<<'\n';
		else
		{
			if(aw[i]<min(bw[i],bd[i])) cout<<"A\n";
			else if(bw[i]<min(aw[i],ad[i])) cout<<"B\n";
			else cout<<"D\n";
		}
	}
	return 0;
}
```

---

## 作者：McIron233 (赞：3)

[cnblogs。](https://www.cnblogs.com/McIron233/p/sol-mahjong.html)

考场上，可以先考虑暴力，不仅有保底分，而且方便对拍。

## 测试点 $1,2$

大力枚举两个人接下来会出什么牌即可。期望得分 $8$ 分。

## 测试点 $3 \sim 5$

和普通博弈论题目一样，考虑使用动态规划。状态设计和转移平凡，也可以使用记忆化搜索。期望得分 $20$ 分。代码中我使用了记忆化搜索。

```cpp
namespace test_1_to_5{
    int f[105][105][105];
    int dfs(int x,int y,int p,int r){
	if(f[x][y][p]!=INF)return f[x][y][p];
	if(p>r)return f[x][y][p]=0; //平局
	if((p&1) && x==a[p])return f[x][y][p]=1; //Alice 自摸
	else if((p&1)==0 && y==a[p])return f[x][y][p]=2; //Bob 自摸
	if(p&1){ //Alice 抽牌
	    int r1,r2; //代表 Alice 丢哪一张牌会得到什么结果
	    if(a[p]==y)r1=2; else r1=dfs(x,y,p+1,r);
	    if(x==y)r2=2; else r2=dfs(a[p],y,p+1,r);
	    if(r1==2 && r2==2)return f[x][y][p]=2; //Bob 稳赢才算 Bob 赢
	    if(r1==1 || r2==1)return f[x][y][p]=1;
	    //Alice 有赢的机会就会去赢，这是根据题意来的
	    return f[x][y][p]=0;
	}
	int r1,r2; //Bob 抽牌，计算方式同前
	if(a[p]==x)r1=1; else r1=dfs(x,y,p+1,r);
	if(x==y)r2=1; else r2=dfs(x,a[p],p+1,r);
	if(r1==1 && r2==1)return f[x][y][p]=1;
	if(r1==2 || r2==2)return f[x][y][p]=2;
        return f[x][y][p]=0;
    }
    void Main(){
        while(m--){
            memset(f,0x3f,sizeof(f));
            //注意每次询问都得 memset
            //经过测试，大样例下跑得飞快
            //50ms 以内能够胜任 n=100 的测试点
            int x,y,l,r; cin>>x>>y>>l>>r;
            int res=dfs(x,y,l,r);
            if(res==0)cout<<"D\n";
            if(res==1)cout<<"A\n";
            if(res==2)cout<<"B\n";
        }
    }
}
```

做完暴力，观察题目描述以及样例，不难发现如下性质：

- 放炮（也就是出一张和另外一个人手牌中颜色一样的牌）是不可能的，这是因为 Alice 和 Bob 都希望自己可以和牌并获胜，若自己无法和牌就会尽可能阻止对方和牌。
- 题目保证了 $l$ 为奇数，所以每个人将抽到什么牌是固定的。

## 测试点 $11$

只有两个颜色，因此直接分类讨论，如果手里颜色相同就看谁会先抽到指定牌堆里那个相同颜色的牌，如果不相同，那么先看 Alice 会抽到什么牌，如果和手里的一样就直接和牌，不一样就只能将原先的手牌打出去（否则就放 Bob 的炮了），问题转化成手里颜色相同的情况。实现的时候使用二分查找即可。期望得分 $24$ 分。

```cpp
/*
解释一下：
e[x] 是一个 vector，存的是颜色 x 对应的位置
a[] 是原本的牌堆
*/
namespace test_11{
	void Solve(int x,int y,int l,int r){
		if(x==y){
			auto it=lower_bound(e[x].begin(),e[x].end(),l);
			if(it==e[x].end() || (*it)>r){ cout<<"D\n"; return; }
			//注意二分到的位置也不能超过 r
			else{ cout<<(((*it)&1)?"A\n":"B\n"); return; }
		} if(a[l]==x){ cout<<"A\n"; return; }
		x=a[l]; ++l; auto it=lower_bound(e[x].begin(),e[x].end(),l);
		if(it==e[x].end() || (*it>r)){ cout<<"D\n"; return; }
		else{ cout<<(((*it)&1)?"A\n":"B\n"); return; }
	}
	void Main(){
		while(m--){
			int x,y,l,r; cin>>x>>y>>l>>r;
			Solve(x,y,l,r);
		}
	}
}
```

## 测试点 $16$

测试点 $11$ 的第一种情况，同样使用二分查找即可。期望得分 $28$ 分，考场上这个分数是相当可观的，如果前面的题目不能太过保证的话回去检查前面的题目是一个非常不错的选择。

```cpp
//vec 是存储了询问的 vector,e[x] 的含义和测试点 11 的一样
namespace test_16{
	void Main(){
		for(int i=1;i<=m;++i){
			int x=vec[i-1].x,l=vec[i-1].l,r=vec[i-1].r;
			auto it=lower_bound(e[x].begin(),e[x].end(),l);
			if(it==e[x].end() || (*it)>r){ cout<<"D\n"; continue; }
			cout<<(((*it)&1)?"A\n":"B\n");
		}
	}
}
```

## 测试点 $1 \sim 10$

根据测试点 $11$ 和 $16$ 的提示，我们考虑使用分类讨论下的贪心来解决问题。

由于题面中要求双方采取最优策略，因此有可能会出现有玩家发现自己已经不能胜利，使用尽力得到平局结果的情况。所以需要先假定平局算 Alice 胜，若 Bob 仍能胜出才算 Bob 胜；假定平局算 Bob 胜，若 Alice 仍能胜出才算 Alice 胜；否则，算平局。接下来分类讨论：

- 若双方手牌相同，显然他们将进入摸切（摸到什么出什么）的环节，直到一方自摸。
- 若双方手牌不同，他们会考虑在一个时刻摸到一张合适的牌之后，一直捏着它直到结束，并且如果摸到的牌会使得自己胜，那么越早越好；若会败，则越晚越好。

那么我们就需要计算一直捏着一张牌会在什么时刻产生定胜负的局面。如果自己捏着一张牌，我们需要考虑下一张牌和再下一张牌的位置对答案的影响。设摸到下一张牌的时刻是 $x$。

- 若下一张牌自己摸到，说明自己直接在 $x$ 时刻胜利了。

- 若对方摸到，问题又转化成了测试点 $16$ 的情况，此时双方不能丢掉自己的手牌。因此只需要计算下一张牌被谁摸到了即可，胜负判断仍然在 $x$ 时刻。

  - 若再下一张牌自己摸到，说明在 $x$ 时刻自己胜利了。

  - 若对方摸到，说明在 $x$ 时刻自己失败了。

  - 若不存在再下一张，算平局。

直接模拟这个过程即可，个人码量 $1.8 \text{ KiB}$。该算法时间复杂度 $O(nm \log n)$，算上测试点 $11$ 和 $16$ 期望得分 $48$ 分。实际多过了一个测试点 $12$，得 $52$ 分，一般在考场上做到这个分数就可以回去检查前面的题目了。

```cpp
namespace test_1_to_10{
	int findpos(int x,int l,int r){
		auto it=upper_bound(e[x].begin(),e[x].end(),l);
		if(it==e[x].end() || (*it)>r)return -1;
		return *it;
	}
	int calc(int x,int l,int r,int o,int flg){
		//使用二分查找计算贡献
		int pos=findpos(x,l+o,r);
		if(!(~pos))return (((l&1)==flg)?(n+1):(-n-1));
		if((pos&1)==(l&1))return pos;
		int pos2=findpos(x,pos,r);
		if(!(~pos2))return (((l&1)==flg)?pos:-pos);
		else if((pos2&1)==(l&1))return pos;
		else return -pos;
	}
	bool solve(int x,int y,int l,int r,int o){
		if(x==y){ //同色，第一种情况
			int pos=findpos(x,l-1,r);
			if(!(~pos))return o;
			else if((pos&1)==(l&1))return 1;
			return 0;
		}
		int vx=calc(x,l-2,r,1,o),vy=calc(y,l-1,r,0,o);
		//计算手牌贡献
		for(int i=l;i<=r;++i){
			if(vx==i)return 1; if(vy==i)return 0;
			if(-vx==i)return 0; if(-vy==i)return 1;
			//贡献产生，返回答案
			if(x==y){ //同色，第一种情况
				int pos=findpos(x,l-1,r);
				if(pos==-1)return o;
				else if((pos&1)==(l&1))return 1;
				return 0;
			}
			//第二种情况，继续计算贡献，注意赢得越早越好，输得越晚越好
			int val=calc(a[i],i,r,0,o);
			if((i&1)==(l&1)){
				if(val>0 && (val<vx || vx<0))vx=val,x=a[i];
				else if(val<0 && val<vx && vx<0)vx=val,x=a[i];
			}else{
				if(val>0 && (val<vy || vy<0))vy=val,y=a[i];
				else if(val<0 && val<vy && vy<0)vy=val,y=a[i];
			}
		}
		return o;
	}
	void Main(){
		while(m--){
			int x,y,l,r; cin>>x>>y>>l>>r;
			//假定平局也算一个人胜利
			bool _A=solve(x,y,l,r,0);
			bool _B=solve(x,y,l,r,1);
			if(_A)cout<<"A\n"; //A 稳赢
			else if(!_B)cout<<"B\n"; //B 稳赢
			else cout<<"D\n"; //都不能稳赢
		}
	}
}
```

## 测试点 $11 \sim 25$

**这部分参考了樱雪喵大佬的题解，在此表示感谢。**

考虑快速获得结果。一般有两种方案：单次询问快速处理，或者离线处理多个询问。

根据题意，我们可以通过一定的观察，发现其实不需要维护接下来会使得自己输掉的牌。

证明：假设当前是第 $x$ 回合，Alice 的手牌会使得她在回合 $a$ 失败，并且她又摸到了一张会使得自己在回合 $b$ 输掉的牌。显然，一定有 $a>x,b>x,a \not = b$，且 $a$ 与 $b$ 都跟 $x$ 的奇偶性不相同（有相同的就是自己抽到这张牌了，不符合使得自己失败的条件），即 $\left|a-x\right| \bmod 2=1, \left|b-x\right| \bmod 2=1$。因此，有至少一张牌是在 $x+2$ 回合以后才会使得 Alice 失败，丢掉另一张牌就可以保证 Alice 不会立即失败。

注意需要特判 Bob 初始手牌会使得他立即输掉的情况。

根据这个性质，我们只需要获得最早使得自己胜利的牌的信息即可，最早胜利的牌就是每个区间内最小值所在位置，查询其奇偶性即可。我们发现区间内产生贡献的牌最多 $3$ 张，并且会随着右端点的移动而发生贡献的更改，因此我们可以离线询问，从左向右遍历 $r$，并使用一个支持单点修改，区间查询最小值位置的数据结构即可。线段树可以完美解决这个问题。

该算法时间复杂度 $O((n+m) \log n)$。

```cpp
#define N 200005
#define pii pair<int,int>
namespace Correct{
	int ans[N][2];
	vector<int>A[N];
	struct que{ int x,y,l,r,id; };
	vector<que>q[N];
	int findpos(int x,int l,int r){
		auto it=upper_bound(e[x].begin(),e[x].end(),l);
		if(it==e[x].end() || (*it)>r)return -1;
		return *it;
	}
	int calc(int x,int l,int r,int o,int flg){
		int pos=findpos(x,l+o,r);
		if(!(~pos))return INF;
		if((pos&1)==(l&1))return pos;
		int pos2=findpos(x,pos,r);
		if(!(~pos2))return (((l&1)==flg)?pos:INF);
		else if((pos2&1)==(l&1))return pos;
		return INF;
		//注意这里计算贡献的时候只考虑会产生胜利的情况，如果不能产生胜利贡献就应该返回 INF
	}
	struct segment_tree{ //单点修改，区间查询最小值及其位置
		#define ls (k<<1)
		#define rs (k<<1|1)
		#define mid ((l+r)>>1)
		pii sum[N<<2];
		pii Min(pii x,pii y){
			if(x.first<y.first)return x;
			return y;
		}
		void buildseg(int k,int l,int r){
			if(l==r){ sum[k]={INF,l}; return; }
			buildseg(ls,l,mid); buildseg(rs,mid+1,r);
			sum[k]=Min(sum[ls],sum[rs]);
		}
		void modify(int k,int l,int r,int pos,int val){
			if(l==r){ sum[k]={val,l}; return; }
			if(pos<=mid)modify(ls,l,mid,pos,val);
			else modify(rs,mid+1,r,pos,val);
			sum[k]=Min(sum[ls],sum[rs]);
		}
		pii query(int k,int l,int r,int ql,int qr){
			if(ql<=l && r<=qr)return sum[k];
			if(qr<=mid)return query(ls,l,mid,ql,qr);
			if(ql>mid)return query(rs,mid+1,r,ql,qr);
			return Min(query(ls,l,mid,ql,mid),query(rs,mid+1,r,mid+1,qr));
		}
		#undef ls
		#undef rs
		#undef mid
	}seg;
	int solve(int x,int y,int l,int r,int o){
		if(x==y){
			int pos=findpos(x,l-1,r);
			if(!(~pos))return o;
			else if((pos&1)==(l&1))return 1;
			return 0;
		} if(y==a[l]){
			int pos=findpos(y,l,r);
			if((~pos) && ((pos&1)==(l&1)))return 1;
			else if(!(~pos))return o;
		}
		int vx=calc(x,l-2,r,1,o),vy=calc(y,l-1,r,0,o);
		int res=min(vx,vy),P=(vx<vy)?(l-2):(l-1);
		pii t=seg.query(1,1,n,l,r);
		if(t.first<res)res=t.first,P=t.second;
		if(res==INF)return o;
		return ((P&1)==(l&1));
	}
	void Solve(int o){
		//按照 r 从左向右扫一遍计算答案
		seg.buildseg(1,1,n);
		for(int r=1;r<=n;++r){
			for(int i:A[r])seg.modify(1,1,n,i,calc(a[i],i,r,0,o));
			//更改位置 i 的牌的贡献
			for(auto i:q[r]){
				int x=i.x,y=i.y,l=i.l,r=i.r,id=i.id;
				ans[id][o]=solve(x,y,l,r,o);
			}
		}
	}
	void Main(){
		for(int i=1;i<=m;++i){
			q[vec[i-1].r].push_back({vec[i-1].x,vec[i-1].y,vec[i-1].l,vec[i-1].r,i});
		} for(int i=1;i<=n;++i){
			int nxt=findpos(a[i],i,n);
			if(!(~nxt))continue;
			A[nxt].push_back(i);
			int nxt2=findpos(a[i],nxt,n);
			if(~nxt2)A[nxt2].push_back(i);
		} for(int flg=0;flg<=1;++flg)Solve(flg);
		for(int i=1;i<=m;++i){
			if(ans[i][0])cout<<"A\n";
			else if(!ans[i][1])cout<<"B\n";
			else cout<<"D\n";
		}
	}
}
```

---


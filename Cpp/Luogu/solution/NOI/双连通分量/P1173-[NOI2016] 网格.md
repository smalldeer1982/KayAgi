# [NOI2016] 网格

## 题目描述

跳蚤国王和蛐蛐国王在玩一个游戏。

他们在一个 $n$ 行 $m$ 列的网格上排兵布阵。其中的 $c$ 个格子中 $(0 \leq c \leq n\cdot m)$，每个格子有一只蛐蛐，其余的格子中，每个格子有一只跳蚤。

我们称占据的格子有公共边的两只跳蚤是相邻的。

我们称两只跳蚤是连通的，当且仅当这两只跳蚤相邻，或存在另一只跳蚤与这两只跳蚤都连通。

现在，蛐蛐国王希望，将某些（零个，一个或多个）跳蚤替换成蛐蛐，使得在此之后存在至少两只跳蚤不连通。

例如：图 $1$ 描述了一个 $n=4$，$m=4$，$c=2$ 的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/96tey4uv.png)

这种情况下蛐蛐国王可以通过将第二行第二列，和第三行第三列的两只跳蚤替换为蛐蛐，从而达成他的希望，如右图所示。并且，不存在更优的方案，但是可能存在其他替换两只跳蚤的方案。

你需要首先判断蛐蛐国王的希望能否被达成。如果能够达成，你还需要最小化被替换的跳蚤的个数。

## 说明/提示

### 样例解释

第一组数据就是问题描述中的例子。

对于第二组数据，可以将第二行第二列的一只跳蚤替换为蛐蛐，从而使得存在两只跳蚤不连通，并且不存在更优的方案。

对于第三组数据，最初已经存在两只跳蚤不连通，故不需要再进行替换。

对于第四组数据，由于最多只有一只跳蚤，所以无论如何替换都不能存在两只跳蚤不连通。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 20$。我们记 $\sum c$ 为某个测试点中，其 $T$ 组输入数据的所有 $c$ 的总和。对于所有的测试点，$\sum c \leq 10^5$。

对于全部的数据，满足 $1 \leq n,m \leq 10^9$，$0 \leq c \leq n \times m$，$1 \leq x \leq n, 1 \leq y \leq m$。

每个测试点的详细数据范围见下表。表中的 $n,m,c$ 均是对于单个输入数据（而非测试点）而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件；而 $\sum c$是对于单个测试点而言的。为了方便阅读，“测试点”一列被放到了表格的中间而不是左边。 

| $n,m$ | 测试点 | $c$ |
| :----------: | :----------: | :----------: |
| $n\times m\leq 4$ | $1$ | $c\leq n\times m$ |
| $n\times m\leq 8$ | $2$ | ^ |
| $n\times m\leq 15$ | $3$ | ^ |
| $n\times m\leq 30$ |  $4$| ^ |
| $n\times m\leq 100$ | $5$ | ^ |
| $n\times m\leq 300$ | $6$ | ^ |
| $n\times m\leq 10^3$ | $7$ | ^ |
| $n\times m\leq 2\times 10^4$ | $8$ | $c\leq 5$ |
| ^ | $9$ | $c\leq 15$ |
| ^ | $10$ | $c\leq 30$ |
| $n,m\leq 2\times 10^4,n\times m\leq2\times 10^4$ | $11$ | $\sum c\leq 2\times 10^4$ |
| $n,m\leq 2\times 10^4,n\times m\leq10^5$  | $12$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq3\times 10^5$ | $13$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq10^6$ | $14$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq 10^9$ | $15$ | ^ |
| $n,m\leq 10^5$ | $16$ | $\sum c\leq 10^5$ |
| $n,m\leq 10^9$ | $17$ | $c=0$ |
| ^ | $18$ | $c\leq 1$ |
| ^ | $19$ | $c\leq 2$ |
| ^ | $20$ | $c\leq 3$ |
| ^ | $21$ | $c\leq 10$ |
| ^ | $22$ | $c\leq 30$ |
| ^ | $23$ | $c\leq 300$ |
| ^ | $24$ | $\sum c\leq 2 \times 10^4$ |
| ^ | $25$ | $\sum c\leq   10^5$ |

## 样例 #1

### 输入

```
4
4 4 2
1 1
4 4
2 3 1
1 2
2 2 2
1 1
2 2
1 1 0```

### 输出

```
2
1
0
-1```

# 题解

## 作者：Thinking (赞：154)

一个显而易见的性质是答案不大于2（角上的跳蚤最多与两个相邻）

继而发现答案其实只可能是-1，0，1，2~~（废话）~~，分类讨论：

-1：$nm-c<2$或者$nm-c=2$且剩下的两只跳蚤相邻；

0：原图不连通；

1：原图联通且有割顶；

否则为2。

但$n,m\le 10^9$这种数据范围肯定不能直接做了，发现只有蚱蜢周围的跳蚤可能是割顶，是不是可以把它们选出来建图呢？

hack:（以下均用#表示蚱蜢，*表示选出的跳蚤，.表示其余跳蚤）

```
.**

.*#

.**
```


中间的*成为假的割顶。因此，我们要向外扩展两圈，然后如果在第一圈内发现割顶，那么才真正发现了割顶。这个另外的题解也有讲，这里就不仔细说了。

但是判联通性也有许多大坑，但许多题解都没提，我来提一下或许是我太蒟了

首先是怎么判。不能直接在建好的图上判，举个栗子：

```
#**.**#
```

会被判为不连通。而真正的不连通具有什么性质呢？我们发现，障碍点（蚱蜢）会把它周围的点分成至少两个联通块，由此得到算法1：

**对选出的结点进行四联通floodfill，检查每个障碍周围的点是否均属于同一个联通块。**

这个方法已经可以通过官方数据了~~，但我们还有万恶的UOJ~~

我们发现这个方法是可以hack的：

```
*###*
```

每个结点周围只有一个联通块，联通，~~于是你WA的一声哭了出来，~~所以，我们必须将连在一起的障碍一起处理，得到算法2：

**对选出的结点进行四联通floodfill，对障碍进行八连通floodfill，检查每个障碍块周围的点是否均属于同一个联通块。**

注意，对结点的检查不能判重，比如下面的例子：

```
***
###
###
###
***
*#*
```

如果先检查了下面的#，再在检查上面的障碍块使省略重复访问，那么将返回联通。

这就没问题了。

至于实现么，反正map会被卡，hash又不难打，当然选择hash

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
typedef long long ll;
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
const int P=1000117;
const int N=100050;
char rB[1<<21],*rS,*rT;
inline char gc(){return rS==rT&&(rT=(rS=rB)+fread(rB,1,1<<21,stdin),rS==rT)?EOF:*rS++;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
int x[N],y[N],G[N*24],to[N*192],nxt[N*192],sz,cnt,pre[N*24],dfsc,n,m,c,tmpx[N*24],tmpy[N*24],ctmp;
bool isok[N*24],iscut[N*24];
struct node{
	int x,y;
	node(){}
	node(int x,int y):x(x),y(y){}
};
queue<node> Q,q;
struct Hash{  //用hash实现map
	int h[P],vx[N*25],vy[N*25],p[N*25],nxt[N*25],sz;
	inline void clear(){
		memset(h,0,sizeof(h));sz=0;
	}
	inline void ins(int x,int y,int id){
		int pos=((ll)(x-1)*n+y-1)%P;
		vx[++sz]=x;vy[sz]=y;p[sz]=id;nxt[sz]=h[pos];h[pos]=sz;
	}
	inline int ask(int x,int y){
		for(int k=h[((ll)(x-1)*n+y-1)%P];k;k=nxt[k])if(vx[k]==x&&vy[k]==y)return p[k];
		return 0;
	}
}h,col,tem;
inline int Abs(int x){return x<0?-x:x;}
inline int Max(int a,int b){return a>b?a:b;}
inline void add(int u,int v){
	to[++sz]=v;nxt[sz]=G[u];G[u]=sz;
	to[++sz]=u;nxt[sz]=G[v];G[v]=sz;
}
inline bool check(){
	int i,j,k,tx,ty;
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)if(!h.ask(i,j)){
			for(k=0;k<4;++k)if((tx=i+dx[k])&&tx<=n&&(ty=j+dy[k])&&ty<=m&&!h.ask(tx,ty))return 1;
			return 0;
		}
}
inline void bfs(int sx,int sy,int cl){  //第一次floodfill
	int i,u,v,tx,ty;
	q.push(node(sx,sy));col.ins(sx,sy,cl);
	while(!q.empty()){
		u=q.front().x;v=q.front().y;q.pop();
		for(i=0;i<4;++i)if((tx=u+dx[i])&&tx<=n&&(ty=v+dy[i])&&ty<=m&&h.ask(tx,ty)>0&&!col.ask(tx,ty)){
			col.ins(tx,ty,cl);  //用col来记录所属联通块编号（也成为颜色）
			q.push(node(tx,ty));
		}
	}
}
inline bool bfs2(int sx,int sy){
	int i,u,v,x,y,t;
	q.push(node(sx,sy));tem.ins(sx,sy,-1);
	while(!q.empty()){
		u=q.front().x;v=q.front().y;q.pop();
		for(x=Max(1,u-1);x<=n&&x<=u+1;++x)
			for(y=Max(1,v-1);y<=m&&y<=v+1;++y)if((t=h.ask(x,y))&&!tem.ask(x,y))if(t==-1){
				tem.ins(x,y,-1);  //用tem来防止对障碍结点重复访问
//对跳蚤结点的重复访问最多总共c*8个，不会影响复杂度
				q.push(node(x,y));
			}else{tmpx[++ctmp]=x;tmpy[ctmp]=y;}
	}
	if(ctmp==-1)return 1;
	for(i=1,t=col.ask(tmpx[0],tmpy[0]);i<=ctmp;++i)if(col.ask(tmpx[i],tmpy[i])!=t)return 0;
	return 1;
}
inline bool ncon(){  //判断是否不连通
	int i,u,v,ccl=0;
	col.clear();
	while(!Q.empty()){
		u=Q.front().x;v=Q.front().y;Q.pop();
		if(col.ask(u,v))continue;
		bfs(u,v,++ccl);
	}
	tem.clear();
	for(i=0;i<c;++i)if(!tem.ask(x[i],y[i])){
		ctmp=-1;
		if(!bfs2(x[i],y[i]))return 1;
	}
	return 0;
}
int dfs(int u,int fa){  //dfs求割顶
	int i,v,lowu=pre[u]=++dfsc,lowv,chd=0;
	for(i=G[u];i;i=nxt[i])if((v=to[i])!=fa)if(!pre[v]){
		++chd;
		if((lowv=dfs(v,u))>=pre[u])iscut[u]=1;
		if(lowv<lowu)lowu=lowv;
	}else if(pre[v]<lowu)lowu=pre[v];
	if(!fa&&chd==1)iscut[u]=0;
	return lowu;
}
int main(){
	int T=rd(),i,j,k,l,t,tt,tx,ty;
	bool ok;
	while(T--){
		n=rd();m=rd();c=rd();
		h.clear();
		for(i=0;i<c;++i){
			x[i]=rd();y[i]=rd();
			h.ins(x[i],y[i],-1);
		}
		if((ll)n*m-c<2ll){
			puts("-1");
			continue;
		}
		if((ll)n*m-c==2ll){
			puts(check()?"-1":"0");
			continue;
		}
		memset(G,0,sizeof(G));ok=sz=cnt=dfsc=0;
		memset(pre,0,sizeof(pre));
		memset(iscut,0,sizeof(iscut));
		memset(isok,0,sizeof(isok));
        //建图
		for(i=0;i<c;++i)
			for(j=Max(1,x[i]-2);j<=x[i]+2&&j<=n;++j)
				for(k=Max(1,y[i]-2);k<=y[i]+2&&k<=m;++k)if(!(t=h.ask(j,k))){
					h.ins(j,k,++cnt);Q.push(node(j,k));
					isok[cnt]=Max(Abs(j-x[i]),Abs(k-y[i]))<=1;
					for(l=0;l<4;++l)if((tx=j+dx[l])&&tx<=n&&(ty=k+dy[l])&&ty<=m&&(tt=h.ask(tx,ty))>0)add(cnt,tt);
				}else if(t>0&&Max(Abs(j-x[i]),Abs(k-y[i]))<=1)isok[t]=1;
		if(ncon()){
			puts("0");
			continue;
		}
		if(n==1||m==1){  //一行或一列可以特判
			puts("1");
			continue;
		}
		for(i=1;i<=cnt;++i){
			if(!pre[i])dfs(i,0);
			if(isok[i]&&iscut[i]){
				puts("1");
				ok=1;break;
			}
		}
		if(!ok)puts("2");
	}
	return 0;
}
```


---

## 作者：dengyaotriangle (赞：53)

**UPD:被叉了，加了一个特判，果然这题还是需要一点特判的...**

将有蛐蛐的看做黑点，有跳蚤的看做白点。

显然答案只可以是无解或者 $0,1,2$。

- 若所有四联通的白色格子组成的图不连通，则答案是 $0$。

- 否则若图有割点，则答案为 $1$

- 否则若图只有不超过两个点，则无解

- 否则为 $2$

前三个情况是显然的，最后一种情况可以分图有 $3$ 个点和超过 $3$ 个分别证明。

于是直接建图跑 tarjan 即可 $\mathcal{O}(nm)$。

然而这张图点很多但是空位很少，考虑将其缩成一个点数边数均为 $\mathcal{O}(c)$ 的图使得缩完答案不变。

考虑只保留以下白点：

- 与网格四个角的至少一个角的 $x,y$ 坐标之差 $\leq2$

- 与某个黑点八连通

- 在网格的上边或下边上，且所在列有至少一个黑点

- 在网格的左边或右边上，且所在行有至少一个黑点


然后对于所有剩下的白点，若两个白点点在同一行或者同一列，且中间没有其它点（包括黑点黑剩下的白点），就连一条边。

**注意并不是只建四连通的边。**

例如这样，蓝色的格子是保留下来的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/jpb2qvk5.png)


然后发现这张图的答案与原图的答案大多数情况是一样的，但判 $-1$ 的时候需要特判一下若图有两个点但这两个点虽然有边但不四连通的情况，这种情况实际上会有至少三个点在里面，答案是 $1$，或者可以判一下 $n=1,m=1$ 也可以。


~~我也不知道是不是对的，以及如果是对的咋证，反正过了所有 uoj hack 数据~~，欢迎继续hack。

而且考虑每个黑点只会最多贡献它周围 $8$ 个，以及边上 $4$ 个共 $12$ 个点，所以一共 $\mathcal{O}(c)$ 个点。

所以复杂度瓶颈在于建图，复杂度 $\Theta(c\log c)$

```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

int n,m,c;

const int maxn=2e7+10;
struct node{
    int x,y,t;
    node(){}
    node(int x,int y,int t):x(x),y(y),t(t){}
}a[maxn];
int t,q;

bool cmp1(const node&a,const node&b){
    return a.x==b.x?(a.y==b.y?a.t<b.t:a.y<b.y):a.x<b.x;
}
bool cmp2(const node&a,const node&b){
    return a.y==b.y?a.x<b.x:a.y<b.y;
}
vector<int> adj[maxn];
int dfn[maxn],low[maxn],tfa[maxn],c1;

bool gt0;

void tarjan(int u){
    dfn[u]=low[u]=++c1;
    int cch=0;
    for(int i=0;i<(int)adj[u].size();i++){
        int v=adj[u][i];
        if(!dfn[v]){
            tfa[v]=u;
            tarjan(v);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]){
                if(tfa[u])gt0=1;
                else cch++;
            }
        }else if(v!=tfa[u])low[u]=min(low[u],dfn[v]);
    }
    if(cch>1)gt0=1;
}
void addprem(int x,int y,int radx,int rady){
    for(int dx=-radx;dx<=radx;dx++){
        for(int dy=-rady;dy<=rady;dy++){
            int cx=x+dx,cy=y+dy;
            if(1<=cx&&cx<=n&&1<=cy&&cy<=m){
                a[++t]=node(cx,cy,0);
            }
        }
    }
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);
    int t_;
    cin>>t_;
    while(t_--){
        cin>>n>>m>>c;
        t=q=0;
        for(int i=1;i<=c;i++){
            int x,y;cin>>x>>y;
            addprem(x,y,1,1);
            addprem(1,y,0,0);addprem(n,y,0,0);addprem(x,1,0,0);addprem(x,m,0,0);
            a[++t]=node(x,y,-1);
        }
        addprem(1,1,2,2);addprem(1,m,2,2);addprem(n,1,2,2);addprem(n,m,2,2);
        sort(a+1,a+1+t,cmp1);
        int cp=0;node buf(INT_MAX,INT_MAX,1);
        for(int i=1;i<=t;i++){
            if(a[i].x!=buf.x||a[i].y!=buf.y){
                buf=a[i];a[++cp]=buf;
            }
        }
        t=cp;
        for(int i=1;i<=t;i++)if(a[i].t!=-1)a[i].t=++q;
        for(int i=1;i<=q;i++)adj[i].clear(),dfn[i]=0;
        c1=0;
        for(int i=2;i<=t;i++){
            if(a[i].x==a[i-1].x&&a[i].t!=-1&&a[i-1].t!=-1){
                adj[a[i].t].push_back(a[i-1].t);
                adj[a[i-1].t].push_back(a[i].t);
            }
        }
        sort(a+1,a+1+t,cmp2);
        for(int i=2;i<=t;i++){
            if(a[i].y==a[i-1].y&&a[i].t!=-1&&a[i-1].t!=-1){
                adj[a[i].t].push_back(a[i-1].t);
                adj[a[i-1].t].push_back(a[i].t);
            }
        } 
        if(q<=1){
            cout<< -1<<'\n';
            continue;
        }
        if(q==2&&adj[1].size()){
            int id[2];
            for(int i=1;i<=t;i++)if(a[i].t>=1&&a[i].t<=2)id[a[i].t-1]=i;
            if(abs(a[id[0]].x-a[id[1]].x)+abs(a[id[0]].y-a[id[1]].y)==1){
                cout<< -1<<'\n';
                continue;
            }else{
                cout<<1<<'\n';
                continue;
            }
        }
        gt0=0;
        tarjan(1);
        if(c1!=q){
            cout<< 0<<'\n';
        }else cout<<(gt0?1:2)<<'\n';
    }
    return 0;
}
```

---

## 作者：NaVi_Awson (赞：36)

[博客也有详解，欢迎来踩](https://www.cnblogs.com/NaVi-Awson/p/9261497.html)

## Description

给出一张 $n\times m$ 的网格，在其中删去 $c$ 个格子，问至少再删去几个能使得图上存在两点不连通，或输出无解。

多组询问，询问组数 $T$ 。

$1\leq T\leq 20,1\leq n,m\leq 10^9,\sum c\leq 10^5$

## Solution

观察题目，容易发现答案只会在 $-1,0,1,2$ 之间~~，那么就可以随机输出其中一个数，以 $\frac{1}{4^T}$ 的概率通过这道题~~。

那么分类讨论。

 - 如果答案为 $-1$ ，显然只有两种情况：只有剩一个格子，或者只有两个格子且两个格子相邻。这些是可以直接特判的。
 - 如果答案为 $0$ ，显然是原图已经出现了不连通的状况。
 - 若果答案为 $1$ ，那么原图存在一个点，使得删去这个点后图不联通，即原图存在割点。
 - 否则答案为 $2$ 。

由于坐标过大，我们不能直接在原图上求解，考虑离散。其实注意到网格上留有的格子有用的只是与每个删掉的格子八连通的格子。

我们可以把这些格子留下来建图。不过有一种特殊的情况，那就是边界问题，举一个例子

```
.....
...00
...X1
...00
.....
```

如题原本是一个 $5\times 5$ 的格子，在 $(3,5)$ 被删掉了一个格子，如果我们只考虑八连通，那么就会出现 $\text{X}$ 是一个割点，然而在原图中并不是，所以就考虑将一个被删除的点的周围 $5\times 5$ 的格子（共 $24$ 个）都拿下来建新图。这样点数是 $O(24\sum c)$ 的。

特判掉 $-1,0$ 之后，就跑一遍 $\text{tarjan}$ 判是否有割点即可。

## Code

我用了 $\text{map}$ ，在 $\text{luogu}$ 上过不去...（ $\text{bzoj}$ 过了就苟且偷生...233333...

```cpp
#include <bits/stdc++.h>
#define pb push_back
using namespace std;
const int N = 100000+5;
const int w1[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int w2[8] = {0, 0, 1, -1, -1, 1, -1, 1};
void gi(int &x) {
	char ch = getchar(); x = 0;
	for (; ch < '0' || ch > '9'; ch = getchar());
	for (; ch >= '0' && ch <= '9'; ch = getchar()) x = (x<<1)+(x<<3)+ch-48;
}

int n, m, c, u, v, idx, color[N<<3], cnt;
struct pii {
	int first, second;
	pii (int _first = 0, int _second = 0) {first = _first, second = _second; }
	bool operator < (const pii &b) const {
		return first == b.first ? second < b.second : first < b.first;
	}
	bool operator == (const pii &b) const {return first == b.first && second == b.second; }
};
pii a[N], t, t1;
map<pii, int>id, mp;
queue<pii>Q, P;
struct tt {int to, next; }edge[N<<6];
int path[N<<3], top, rk[N<<3], iscut[N<<3], dfn[N<<3], low[N<<3], times;

bool exist(int u, int v) {
	t = a[lower_bound(a+1, a+c+1, pii(u, v))-a];
	return t.first == u && t.second == v;
}
bool outof(int x, int y, int u, int d, int l, int r) {
	return x < u || x > d || y < l || y > r;
}
void add(int u, int v) {edge[++top] = (tt){v, path[u]}; path[u] = top; }
bool judge() {
	if (1ll*n*m-c <= 1) return false;
	if (1ll*n*m-c >= 3) return true;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			if (!exist(i, j)) {
				for (int k = 0; k < 4; k++) {
					if (outof(i+w1[k], j+w2[k], 1, n, 1, m)) continue;
					if (!exist(i+w1[k], j+w2[k])) return false;
				}
				return true;
			}
		}
}
void bfs(pii t) {
	P.push(t); int u, v, u1, v1;
	while (!P.empty()) {
		t = P.front(); P.pop(); u = t.first, v = t.second; int c = color[id[t]];
		for (int k = 0; k < 4; k++)
			if (!outof(u1 = u+w1[k], v1 = v+w2[k], 1, n, 1, m) && !exist(u1, v1) && id.count(t1 = pii(u1, v1))) {
				if (color[id[t1]]) continue;
				color[id[t1]] = c; P.push(t1);
			}
	}
}
bool connect() {
	while (!Q.empty()) {
		t = Q.front(); Q.pop();
		if (color[id[t]]) continue;
		else color[id[t]] = ++cnt, bfs(t);
	}
	for (int Id = 1; Id <= c; Id++) {
		int u = a[Id].first, v = a[Id].second, c = -1;
		for (int i = -2; i <= 2; i++)
			for (int j = -2; j <= 2; j++) {
				if (outof(u+i, v+j, 1, n, 1, m) || exist(u+i, v+j)) continue;
				t = pii(u+i, v+j);
				if (c == -1) c = color[id[t]];
				else if (c != color[id[t]]) return false;
			}
	}
	return true;
}
void build(int u, int v) {
	for (int i = -2; i <= 2; i++)
		for (int j = -2; j <= 2; j++) {
			if (outof(u+i, v+j, 1, n, 1, m) || exist(u+i, v+j)) continue;
			t = pii(u+i, v+j);
			int x = id.count(t) ? id[t] : (Q.push(t), id[t] = ++idx);
			if (!outof(u+i+1, v+j, max(1, u-2), min(n, u+2), max(1, v-2), min(m, v+2)) && !exist(u+i+1, v+j)) {
			 	t = pii(u+i+1, v+j);
				int y = id.count(t) ? id[t] : (Q.push(t), id[t] = ++idx);
				if (x > y) {if (!mp.count(pii(y, x))) add(x, y); add(y, x); mp[pii(y, x)] = 1; }
				else {if (!mp.count(pii(x, y))) add(x, y); add(y, x); mp[pii(x, y)] = 1; }
			}
			if (!outof(u+i, v+j+1, max(1, u-2), min(n, u+2), max(1, v-2), min(m, v+2)) && !exist(u+i, v+j+1)) {
			 	t = pii(u+i, v+j+1);
				int y = id.count(t) ? id[t] : (Q.push(t), id[t] = ++idx);
				if (x > y) {if (!mp.count(pii(y, x))) add(x, y); add(y, x); mp[pii(y, x)] = 1; }
				else {if (!mp.count(pii(x, y))) add(x, y); add(y, x); mp[pii(x, y)] = 1; }
			}
			if (abs(i) <= 1 && abs(j) <= 1) rk[x] = 1;
		}
}
void tarjan(int u, int fa) {
	iscut[u] = 0; dfn[u] = low[u] = ++times; int sz = 0, v;
	for (int i = path[u]; i; i = edge[i].next) {
		if ((v = edge[i].to) == fa) continue;
		if (!dfn[v]) {
			++sz; tarjan(v, u);
			if (low[v] >= dfn[u]) iscut[u] = 1;
			low[u] = min(low[u], low[v]);
		}else low[u] = min(low[u], dfn[v]);
	}
	if (fa == 0 && sz == 1) iscut[u] = 0;
}
void work() {
	memset(path, top = idx = 0, sizeof(path)); id.clear(), mp.clear();
	memset(dfn, times = 0, sizeof(dfn)); memset(rk, 0, sizeof(rk));
	memset(color, cnt = 0, sizeof(color));
	gi(n), gi(m), gi(c);
	for (int i = 1; i <= c; i++) {
		gi(u), gi(v); a[i] = pii(u, v);
	}
	sort(a+1, a+c+1); a[c+1] = pii(0, 0);
	if (!judge()) {puts("-1"); return; }
	for (int i = 1; i <= c; i++) build(a[i].first, a[i].second);
	if (!connect()) {puts("0"); return; }
	if (n == 1 || m == 1) {puts("1"); return; }
	for (int i = 1; i <= idx; i++) {
		if (!dfn[i]) tarjan(i, 0);
		if (rk[i] && iscut[i]) {puts("1"); return; }
	}
	puts("2");
}
int main() {
	int t; gi(t); while (t--) work();
	return 0;
}
```

---

## 作者：Seauy (赞：17)

[题目链接](https://www.luogu.com.cn/problem/P1173)

## 题目大意

- $n\times m$ 的网格，给出 $c$ 个点为黑点，其他点为白点。

- 求至少添加多少黑点能使白点不联通（四联通），或判断无解。

- $1\leq n,m\leq 10^9,\ 0\leq c \leq \min(nm,10^5)$，多测。

# Solution

这里提供一个平面图欧拉公式的做法。

由于网格图总存在度数 $\leq 2$ 的结点，所以本题答案只可能属于 $\{-1,0,1,2\}$。

注意到网格图属于平面图，而对于一个联通平面图满足欧拉公式

$$ |V|-|E|+|F|=1 $$

其中 $|V|$ 为点数，$|E|$ 为边数，$|F|$ 为划分平面个数。考虑通过维护这三个量计算联通块个数。

一开始一个个把 $c$ 个黑点插入到平面中，$|V|$ 肯定会自减 $1$，$|E|$ 减少量为周围白点个数，$|F|$ 就稍微有点麻烦了。

初始时 $F$ 对应为 $(n-1)(m-1)$ 个不在边界上的白格的正方形顶点，然后突然出现了一个黑格子，他会使四个顶点对应的划分平面联通成一个，此时有两种情况：

1. 存在一个顶点与边界联通，则另一个划分平面消失（都与边界联通则不变）。

2. 都不与边界联通，则减少一个划分平面。

如果一个顶点不属于任何一个黑格子，那就干脆不维护了；相反，加入一个黑格子后他的四个顶点都要用并查集来维护，那就新建结点出来并赋予编号。

这样就能算出加入 $c$ 个黑格子后的联通块个数了。

如果 $ |V|-|E|+|F|>1 $，说明不用做任何变化，答案为 $0$；如果 $|V|=0$ 或 $|V|=1$ 或（$|V|=2$ 且 $|V|-|E|+|F|=1$），那肯定无解；剩下的情况，我们只用判断是 $1$ 还是 $2$，显然判断是否为 $1$ 好做。

我们肯定会猜想再放一个新黑格，他肯定会在某个已有黑格附近（八联通）。不过有个小 corner case 是 $n=1$ 或 $m=1$ 的情况，存在周围没有已有黑格答案依然为 $1$ 情况，特判即可。

之后的做法与前面类似，注意新黑格加入后需要撤销，为了保证复杂度并查集就只能用按秩合并。维护格子的编号以及存在性用 set/map 即可。

然后涉及到的划分平面个数可能高达 $36c$……数组开大点就好了。复杂度 $O(c \log c)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXC=1e5,SIZE=MAXC*4*9;
const int dx[]={0,0,-1,-1,-1,1,1,1};
const int dy[]={-1,1,-1,0,1,-1,0,1};

struct Point
{
	int x,y;
	inline void Scan() {scanf("%d %d",&y,&x);}
	bool operator == (const Point &a) const
	{return x==a.x && y==a.y;}
	bool operator < (const Point &a) const
	{return x==a.x ? y<a.y : x<a.x;}
	bool operator > (const Point &a) const
	{return x==a.x ? y>a.y : x>a.x;} 
}ver[MAXC+5];

ll n,m;int C;
ll V,E,F;

int fa[SIZE+5],Size[SIZE+5],tot,Outside[SIZE+5];
inline void Clean() {tot=0;}
inline int New() {++tot,fa[tot]=tot,Size[tot]=1,Outside[tot]=0;return tot;}
int Find(int x) {return fa[x]==x ? x : Find(fa[x]);}
pair<int,int> Record[10];int rnum;
inline void Union(int a,int b)
{
	a=Find(a),b=Find(b);
	if(a==b) return;
	if(Size[a]<Size[b]) swap(a,b);
	Size[a]+=Size[b];
	fa[b]=a;
	Outside[a]+=Outside[b];
	
	Record[++rnum]=make_pair(a,b);
}
inline void Cut(int a,int b)
{
	Size[a]-=Size[b];
	fa[b]=b;
	Outside[a]-=Outside[b];
}

set<Point> mapn;//黑点矩阵
map<Point,int> Code;//黑点的角的编号 

inline bool OnEdge(int x,int y) {return x==1 || x==m+1 || y==1 || y==n+1;}

int Q[10],Tail;
inline void Insert(int x,int y)
{
	--V,mapn.insert(Point{x,y});
	
	if(x>1 && mapn.find(Point{x-1,y})==mapn.end()) --E;
	if(x<m && mapn.find(Point{x+1,y})==mapn.end()) --E;
	if(y>1 && mapn.find(Point{x,y-1})==mapn.end()) --E;
	if(y<n && mapn.find(Point{x,y+1})==mapn.end()) --E;
	
	if(Code.find(Point{x,y})==Code.end()) Code[Point{x,y}]=New(),Outside[tot]=OnEdge(x,y);
	if(Code.find(Point{x+1,y})==Code.end()) Code[Point{x+1,y}]=New(),Outside[tot]=OnEdge(x+1,y);
	if(Code.find(Point{x,y+1})==Code.end()) Code[Point{x,y+1}]=New(),Outside[tot]=OnEdge(x,y+1);
	if(Code.find(Point{x+1,y+1})==Code.end()) Code[Point{x+1,y+1}]=New(),Outside[tot]=OnEdge(x+1,y+1);
	Tail=rnum=0;
	Q[++Tail]=Find(Code[Point{x,y}]);
	Q[++Tail]=Find(Code[Point{x+1,y}]);
	Q[++Tail]=Find(Code[Point{x,y+1}]);
	Q[++Tail]=Find(Code[Point{x+1,y+1}]);
	sort(Q+1,Q+Tail+1),Tail=unique(Q+1,Q+Tail+1)-Q-1;
	int delta=0;
	for(int i=1;i<=Tail;i++) delta-=(!Outside[Q[i]]);
	for(int i=2;i<=Tail;i++) Union(Q[1],Q[i]);
	for(int i=1;i<=Tail;i++) Q[i]=Find(Q[i]);
	sort(Q+1,Q+Tail+1),Tail=unique(Q+1,Q+Tail+1)-Q-1;
	for(int i=1;i<=Tail;i++) delta+=(!Outside[Q[i]]);
	F+=delta;
}

inline ll Unicom() {return V-E+F;}

int main()
{
	int T;scanf("%d",&T);
	while(T--)
	{
		scanf("%lld %lld %d",&n,&m,&C);
		V=n*m,E=n*(m-1)+(n-1)*m,F=(n-1)*(m-1);
		Clean(),mapn.clear(),Code.clear();
		
		for(int i=1;i<=C;i++) ver[i].Scan(),Insert(ver[i].x,ver[i].y);
		if(Unicom()>1) {printf("0\n");continue;}
		if(!V || V==1 || (V==2 && Unicom()==1)) {printf("-1\n");continue;}
		if(n==1 || m==1) {printf("1\n");continue;}
		//只添一个黑格子
		bool OK=0;
		for(int i=1;i<=C;i++)
		{
			for(int j=0;j<8;j++)
			{
				int x=ver[i].x+dx[j],y=ver[i].y+dy[j];
				if(x<1 || m<x || y<1 || n<y) continue;
				if(mapn.find(Point{x,y})!=mapn.end()) continue;
				ll v=V,e=E,f=F;
				Insert(x,y);
				if(Unicom()>1) {OK=1;break;}
				//撤销 
				V=v,E=e,F=f;
				mapn.erase(Point{x,y});
				for(int k=rnum;k;k--) Cut(Record[k].first,Record[k].second);
			}
			if(OK) break;
		}
		if(OK) printf("1\n");
		else printf("2\n");
	}
	return 0;
}
```


---

## 作者：jubaoyi2011 (赞：15)

~~这个码量绝对是业界大毒瘤……~~

~~300 行，6.5k，烦的要死……~~

## 题意：

 当我们看透虫子的实质时，可以得到：

给你一个网格图，里面有 $0$ 或 $1$。你需要把一些 $0$ 换成 $1$ 使得存在某两个 $0$ 不四联通。输出最小的换的数量。无解 $-1$。

$n,m\le10^9$，网格中 $1$ 的数量 $\le10^5$，多组数据。

[题目传送门](https://www.luogu.com.cn/problem/P1173)

## 思路：

首先我们发现，最多只要 $2$ 就行了（围住一个角落），所以答案是 $[-1,2]$ 中的整数。

然后考虑何时为 $-1$：$0$ 的数目小于 $2$ 或等于 $2$ 且相连。

何时为 $0$：图初始就不连通。

何时为 $1$：图中存在割点。

除此之外就是 $2$ 了。

然后发现图很大，$c$ 很小，考虑离散化。

然后发现我们只要把每个 $1$ 周围的点提取出来即可。

提取 $3×3$ 是错误的。有一个样例：

$0\ 0\ 0$

$0\ {\color{red} 0\ 0 {}}$

$0\ {\color{red} 0  {}}\ 1$

显然提取之后会有一个割点在原图正中间，但是实际上它并不是割点。

然后我们暴力一点，提取 $5 \times 5$ 即可……

算法流程：提取点，编号。然后判断联通性。然后做 tarjan，判断割点。

然后又有好多坑点……比如割点必须在某个 $1$ 的周围 $3 \times 3$ 区域(易证)，如果忽视这个就会出现一种毒瘤情况：

$1\ {\color{red} 0\ 0 {}}\ 0\ 0\ 0$

${\color{red} 0\ 0\ 0 {}}\ 0\ 0\ 0$

${\color{red} 0\ 0\ 0\ 0\ 0\ 0 {}}$

$0\ 0\ 0\ {\color{red} 0\ 0\ 0 {}}$

$0\ 0\ 0\ {\color{red} 0\ 0 {}}\ 1$

可以发现在奇怪的地方出现了割点……

然后还要特判，$(n - 1)(m - 1)=0$ 的时候答案不可能为 $2$，

然后怒写一天终于对了，又发现 map 太慢跑不过……手写 hash。

[update] 如何判断答案为 $0$：对那些提取出来的非关键点进行并查集。然后枚举每个关键点连通块，如果某个关键点连通块连着两个并查集，答案为 $0$。
## 代码：
```cpp
 #include <cstdio>
 #include <algorithm>
 #include <cstring>
 //#include<bits/stdc++.h>
 inline void read(int &x) {
     x = 0;
     char c = getchar();
     while(c < '0' || c > '9') {
         c = getchar();
     }
     while(c >= '0' && c <= '9') {
         x = (x << 3) + (x << 1) + c - 48;
         c = getchar();
     }
     return;
 }
 
 const int N = 100010;
 const int dx[4] = {0, 1, 0, -1};
 const int dy[4] = {1, 0, -1, 0};
 
 const int MO = 19260817, B = 998244353;
 struct POS {
     int x, y, h;
     POS(int xx = 0, int yy = 0) {
         x = xx;
         y = yy;
         h = (1ll * x * B + y) % MO;
         if(h < 0) {
             h += MO;
         }
     }
     inline bool operator ==(const POS &d) const {
         return x == d.x && y == d.y;
     }
 };
 struct Node {
     int nex, val;
     POS p;
 }node[N * 30]; int top;
 struct MAP {
     int e[MO];
     inline void insert(const POS &d, const int &a) {
         node[++top].val = a;
         node[top].nex = e[d.h];
         node[top].p = d;
         e[d.h] = top;
         return;
     }
     inline int find(const POS &d) { 
         for(int i = e[d.h]; i; i = node[i].nex) {
             if(node[i].p == d) {
                 return node[i].val;
             }
         }
         return 0;
     }
     inline void clear() {
         memset(e, 0, sizeof(e));
         return;
     }
 }mp, use;
 
 int n, m, c, xi[N], yi[N], tot, num, root;
 int dfn[N * 25], low[N * 25], vis[N * 25];
 bool cut[N * 25], vis_c[N], OK;
 
 inline void np(int x, int y) {
     if(!mp.find(POS(x, y)) && !use.find(POS(x, y))) {
         mp.insert(POS(x, y), ++tot);
     }
     return;
 }
 
 inline int get(int x, int y) {
     return mp.find(POS(x, y));
 }
 
 void tarjan(int s, int x, int y) {
     dfn[s] = low[s] = ++num;
     int temp = 0;
     for(int i = 0; i < 4; i++) {
         int t = get(x + dx[i], y + dy[i]);
         if(!t) {
             continue;
         }
         if(!dfn[t]) {
             tarjan(t, x + dx[i], y + dy[i]);
             low[s] = std::min(low[s], low[t]);
             if(low[t] >= dfn[s]) {
                 temp++;
             }
         }
         else {
             low[s] = std::min(low[s], dfn[t]);
         }
     }
     if(temp >= 2 || (temp == 1 && s != root)) {
         cut[s] = 1;
     }
     return;
 }
 
 void DFS_1(int s, int x, int y, int temp) {
     vis[s] = temp;
     for(int i = 0;i < 4; i++) {
         int t = get(x + dx[i], y + dy[i]);
         if(!t) {
             continue;
         }
         if(!vis[t]) {
             DFS_1(t, x + dx[i], y + dy[i], temp);
         }
     }
     return;
 }
 
 bool fd;
 int number;
 
 bool DFS_2(int s, int x, int y) {
     vis_c[s] = 1;
     for(int i = 0; i < 4; i++) {
         if(use.find(POS(x + dx[i], y + dy[i]))) {
             int ed = use.find(POS(x + dx[i], y + dy[i]));
             if(vis_c[ed]) {
                 continue;
             }
             int t = DFS_2(ed, x + dx[i], y + dy[i]);
             if(!t) {
                 return 0;
             }
         }
         else if(get(x + dx[i], y + dy[i])) {
             if(!fd) {
                 number = vis[get(x + dx[i], y + dy[i])];
                 fd = 1;
             }
             else if(number != vis[get(x + dx[i], y + dy[i])]) {
                 OK = 0;
                 return 0;
             }
         }
     }
     return 1;
 }
 
 inline bool check() {
     OK = 1;
     int temp = 0;
     for(int i = 1; i <= c; i++) {
         for(int x = xi[i] - 2; x <= xi[i] + 2; x++) {
             for(int y = yi[i] - 2; y <= yi[i] + 2; y++) {
                 if(vis_c[i]) {
                     continue;
                 }
                 if(mp.find(POS(x, y)) && !vis[get(x, y)]) {
                     ++temp;
                     DFS_1(get(x, y), x, y, temp);
                     goto f1;
                 }
             }
         }
         f1:
         if(!vis_c[i]) {
             fd = 0;
             DFS_2(i, xi[i], yi[i]);
         }
         if(!OK) {
             break;
         }
     }
     return !OK;
 }
 
 inline int solve() {
     read(n);
     read(m);
     read(c);
     if(!c) {
         if(n == 1 && m == 1) {
             return -1;
         }
         if(n == 1 || m == 1) {
             if(n == 2 || m == 2) {
                 return -1;
             }
             return 1;
         }
         return 2;
     }
     for(int i = 1; i <= c; i++) {
         read(xi[i]);
         read(yi[i]);
         use.insert(POS(xi[i], yi[i]), i);
     }
     if(c + 1 >= 1ll * n * m) {
         return -1;
     }
     for(int i = 1; i <= c; i++) {
         for(int x = xi[i] - 2; x <= xi[i] + 2; x++) {
             for(int y = yi[i] - 2; y <= yi[i] + 2; y++) {
                 if(x > 0 && y > 0 && x <= n && y <= m && (x != xi[i] || y != yi[i])) {
                     np(x, y);
                 }
             }
         }
     }
     if(check()) {
         return 0;
     }
     if(c + 2 == 1ll * n * m) {
         return -1;
     }
     if(m == 1 || n == 1) {
         return 1;
     }
     for(int i = 1; i <= c; i++) {
         for(int x = xi[i] - 2; x <= xi[i] + 2; x++) {
             for(int y = yi[i] - 2; y <= yi[i] + 2; y++) {
                 if(!use.find(POS(x, y))) {
                     root = get(x, y);
                     if(dfn[root]) {
                         continue;
                     }
                     tarjan(root, x, y);
                 }
             }
         }
     }
 
     for(int i = 1; i <= c; i++) {
         for(int x = xi[i] - 1; x <= xi[i] + 1; x++) {
             for(int y = yi[i] - 1; y <= yi[i] + 1; y++) {
                 int s = get(x, y);
                 if(cut[s]) {
                     return 1;
                 }
             }
         }
     }
     return 2;
 }
 
 inline void clear() {
     mp.clear();
     use.clear();
     memset(dfn + 1, 0, tot * sizeof(int));
     memset(low + 1, 0, tot * sizeof(int));
     memset(cut + 1, 0, tot * sizeof(bool));
     memset(vis + 1, 0, tot * sizeof(int));
     memset(vis_c + 1, 0, c * sizeof(bool));
     tot = 0;
     num = 0;
     top = 0;
     return;
 }
 
 int main() {
     int T;
     read(T);
     while(T--) {
         printf("%d\n", solve());
         if(T) {
             clear();
         }
     }
     return 0;
 }
```

蒟蒻第一篇黑题题解，请勿抄袭好吗？

---

## 作者：___w (赞：7)

[更好的阅读体验？](https://www.cnblogs.com/123wwm/articles/17999214)

[P1173 [NOI2016] 网格](https://www.luogu.com.cn/problem/P1173)

~~经典 jc 题~~

### 题意简述

有 $n\times m$ 的矩阵，上面有 $c$ 只跳蚤，剩下的均为蛐蛐，求至少将多少的蛐蛐替换成跳蚤使得存在两个蛐蛐它们不相通，无解输出 $-1$。

### 题目分析

注意到答案只可能为 $-1,0,1,2$ 中的一种，因为如果存在答案 $3$，那么一定有一个被围在角落里的蛐蛐，只需要 $2$ 个跳蚤。

答案 $-1$：蛐蛐数 $<2$ 或者等于 $2$ 时两只蛐蛐联通。

答案 $0$：所有蛐蛐不联通。

答案 $1$：所有蛐蛐联通且存在一个割点。

答案 $2$：所有蛐蛐联通且不存在一个割点。

这样我们就得到了 $O(nm)$ 的算法。

注意到所有蛐蛐构成的图的割点有仅仅存在于跳蚤边，于是只考虑所有跳蚤的最外围一圈。但是，若选出的蛐蛐为割点，不一定为原图的割点，因为外围可能都是蛐蛐。所以我们应该取外围两圈的蛐蛐。

那么联通性问题呢？一个图不联通只能是跳蚤造成的，会造成上面选出的图中两个蛐蛐所属的联通块不联通。因此我们可以先对上面建的图进行联通块染色，在对每个跳蚤进行判断。但是单一的跳蚤可能只有一个格子与蛐蛐相邻，而这个跳蚤周围的跳蚤所形成的联通块周围的蛐蛐应该被一起考虑，所以我们应该先把所有的跳蚤分为若干个八联通的联通块（原因是斜着的跳蚤也可能分割蛐蛐，所以是一个整体），然后判断这个跳蚤联通块的周围的蛐蛐是否都处在同一个蛐蛐联通块，就可以解决联通性问题了。

### 代码

代码中应注意的细节：多测要清空，不要混淆变量的含义，数组应开得大一些（~~懒得计算了~~）。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = (l); i <= (r); ++i)
#define int long long
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') f = c == '-' ? -1 : f, c = getchar();
	while (c >= '0' && c <= '9') x = (x<<3)+(x<<1)+(c^48), c = getchar();
	return x*f;
}

inline void write(int x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x/10);
	putchar('0'+x%10);
}

typedef pair <int, int> pii;
const int N = 5e6+5, P = 1000117;
const int d[8][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}};
struct edge { int to, next; } e[N*4];
int n, m, c, rt, cnt, idx, cnt_, tot, x[N], y[N], dfn[N], low[N], cut[N], isok[N], head[N];
vector <pii> pt;

struct Hash {
	int tot, a[N], tx[N], ty[N], nxt[N], head[P];
	void clear() { tot = 0, memset(head, 0, sizeof(head)); }
	void ins(int x, int y, int id) {
		int h = ((x-1)*m+y)%P;
		tx[++tot] = x, ty[tot] = y, a[tot] = id;
		nxt[tot] = head[h], head[h] = tot;
	}
	int ask(int x, int y) {
		for (int i = head[((x-1)*m+y)%P]; i; i = nxt[i]) if (tx[i] == x && ty[i] == y) return a[i];
		return 0;
	}
} h, mp, col;

void init() {
	idx = cnt = cnt_ = tot = 0;
	memset(dfn, 0, sizeof(dfn));
	memset(low, 0, sizeof(low));
	memset(cut, 0, sizeof(cut));
	memset(isok, 0, sizeof(isok));
	memset(head, 0, sizeof(head));
	pt.clear();
	h.clear(), mp.clear(), col.clear();
}

bool check() {
	rep(i, 1, n) rep(j, 1, m) if (!h.ask(i, j)) {
		rep(k, 0, 3) {
			int x = i+d[k][0], y = j+d[k][1];
			if (x < 1 || x > n || y < 1 || y > m) continue;
			if (!h.ask(x, y)) return 0;
		}
	}
	return 1;
}

void add(int x, int y) {
	e[++tot] = {y, head[x]}, head[x] = tot;
	e[++tot] = {x, head[y]}, head[y] = tot;
}

void bfs(int sx, int sy, int cl) {
	queue <pii> q; q.push(mk(sx, sy)); col.ins(sx, sy, cl);
	while (!q.empty()) {
		pii now = q.front(); q.pop();
		rep(i, 0, 3) {
			int x = now.fi+d[i][0], y = now.se+d[i][1];
			if (x < 1 || x > n || y < 1 || y > m) continue;
			if (h.ask(x, y) > 0 && !col.ask(x, y)) q.push(mk(x, y)), col.ins(x, y, cl);
		}
	}
}

bool bfs2(int sx, int sy) {
	queue <pii> q; q.push(mk(sx, sy)); mp.ins(sx, sy, -1);
	vector <pii> v;
	while (!q.empty()) {
		pii now = q.front(); q.pop();
		rep(i, 0, 7) {
			int x = now.fi+d[i][0], y = now.se+d[i][1];
			if (x < 1 || x > n || y < 1 || y > m || mp.ask(x, y)) continue;
			if (h.ask(x, y) == -1) q.push(mk(x, y)), mp.ins(x, y, -1);
			else v.pb(mk(x, y));
		}
	}
	if (v.size() <= 1) return 1;
	int tmp = col.ask(v[0].fi, v[0].se);
	for (pii x:v) if (col.ask(x.fi, x.se) != tmp) return 0;
	return 1;
}

bool pd() {
	for (pii x:pt) if (!col.ask(x.fi, x.se)) bfs(x.fi, x.se, ++idx);
	rep(i, 1, c) if (!mp.ask(x[i], y[i])) if (!bfs2(x[i], y[i])) return 1;
	return 0;
}

void tarjan(int x) {
	int flag = 0; dfn[x] = low[x] = ++cnt_;
	for (int i = head[x]; i; i = e[i].next) {
		int y = e[i].to;
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x], low[y]);
			if (low[y] >= dfn[x]) {
				++flag;
				if (x != rt || flag > 1) cut[x] = 1;
			}
		}
		else low[x] = min(low[x], dfn[y]);
	}
}

void solve() {
	init();
	n = read(), m = read(), c = read();
	rep(i, 1, c) x[i] = read(), y[i] = read(), h.ins(x[i], y[i], -1);
	if (n*m-c < 2) return write(-1), enter, void();
	if (n*m-c == 2) return write(check() ? 0 : -1), enter, void();
	rep(k, 1, c) rep(i, max(1ll, x[k]-2), min(n, x[k]+2)) rep(j, max(1ll, y[k]-2), min(m, y[k]+2)) {
		int t = h.ask(i, j);
		if (!t) {
			h.ins(i, j, ++cnt), pt.pb(mk(i, j));
			isok[cnt] = max(abs(x[k]-i), abs(y[k]-j)) <= 1;
			rep(l, 0, 3) {
				int xx = i+d[l][0], yy = j+d[l][1];
				if (xx < 1 || xx > n || yy < 1 || yy > m) continue;
				int id = h.ask(xx, yy);
				if (id > 0) add(cnt, id);
			}
		}
		else if (t > 0 && max(abs(x[k]-i), abs(y[k]-j)) <= 1) isok[t] = 1;
	}
	if (pd()) return write(0), enter, void();
	if (n == 1 || m == 1) return write(1), enter, void();
	rep (i, 1, cnt) {
		if (!dfn[i]) rt = i, tarjan(i);
		if (isok[i] && cut[i]) return write(1), enter, void();
	}
	write(2), enter;
}

signed main() {
	int t = read();
	while (t--) solve();
	return 0;
}
```

---

## 作者：Felix72 (赞：7)

不错的题，难点在于实现和细节思路。这里来一个平面图做法。

#### 判断答案为 $0$

如果我们在原先点的基础上建图，则会有一些奇奇怪怪的东西要讨论，而且有几个连通块也不好讨论。我们不妨用蛐蛐连通块的边框作为边，像计算几何那样把这些闭合区域全部解析出来，那么知道区域数 $S_1$ 和蛐蛐连通块数量 $S_2$，就能轻而易举地知道有没有天然隔开的跳蚤了。$S_1$ 可以用平面图欧拉公式得到（我代码里使用 tarjan，是为了后续计算答案，本质仍然是这个公式），$S_2$ 可以用并查集得到（注意判断与边界联通的情况）。

#### 判断答案为 $-1$

如果答案不为零，而且跳蚤只有两个，那么无论如何也隔不开了。这个是容易判断的。

#### 判断答案为 $1$ 或 $2$

这里是重头戏，刚才建平面图的好处在这里体现出来。

枚举平面图上的一个顶点（不是原图中的一个蛐蛐，而是网格的交叉点），并枚举从它引申的一条边，如果这条边两侧都是跳蚤并且平面图中这条边的两个端点连通，说明肯定能通过放蛐蛐使得某些跳蚤不连通（不会出现只有这两个跳蚤的情况，刚刚判断过了）。

如果没有这种情况，在枚举一下有没有一只蛐蛐与原来的斜对角线（左上右下之类）上的蛐蛐隔开了一些跳蚤。这个也是容易枚举的。

边界上还有类似的两种情况，都不难写。

至此，我们通过平面图的方法做完了这个题。

代码放在这里，能通过本站和 UOJ 的数据，但是因为码量很大，也许无法保证严格的正确性，仅供参考。

```cpp
/*Good Game, Well Play.*/
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;
typedef pair < int, int > PII;
int T, h, w, n;

map < PII, int > mps, mpv; int vsign;
struct Point {int x, y;} p[N * 4];
vector < int > lp, rp, up, dp;
struct edge {int to; long long val;};
vector < edge > con[N * 4];
inline void refresh(int x, int y)
{
	if(!mpv.count({x, y}))
	{
		mpv[{x, y}] = ++vsign;
		con[vsign].clear();
		p[vsign].x = x; p[vsign].y = y;
	}
}

int dx[10] = {0, 0, 0, -1, 1, -1, -1, 1, 1};
int dy[10] = {0, 1, -1, 0, 0, -1, 1, -1, 1};
struct grid {int x, y;} s[N];

struct DSU
{
	int prt[N], siz[N];
	inline void reset(int n)
	{for(int i = 1; i <= n; ++i) prt[i] = i, siz[i] = 1;}
	inline int find(int x)
	{
		if(prt[x] == x) return prt[x];
		prt[x] = find(prt[x]);
		return prt[x];
	}
	inline void merge(int x, int y)
	{
		int u = find(x), v = find(y);
		if(u != v)
		{
			if(siz[u] > siz[v]) swap(u, v);
			prt[u] = v, siz[v] += siz[u];
		}
	}
} dsu;

int dfn[N * 4], low[N * 4], sign, S, fa[N * 4];
map < PII, int > mpe; bool able;
inline int getid(int now) {return mpe[{now, con[now][0].to}];}
inline long long dist(int x, int y)
{return abs(p[x].x - p[y].x) + abs(p[x].y - p[y].y);}
inline void tarjan(int now, int prt)
{
	fa[now] = prt;
	dfn[now] = low[now] = ++sign;
	for(auto p : con[now])
	{
		int to = p.to;
		if(to == prt) continue;
		if(!dfn[to])
		{
			tarjan(to, now);
			low[now] = min(low[now], low[to]);
		}
		else
		{
			if(dfn[to] < dfn[now])
			{
				++S; long long C = 0;
				mpe[{now, to}] = mpe[{to, now}] = S;
				C += dist(now, to);
				int pos = now;
				while(pos != to)
				{
					mpe[{pos, fa[pos]}] = mpe[{fa[pos], pos}] = S;
					C += dist(fa[pos], pos); pos = fa[pos];
				}
				if(C > 6) able = true;
			}
			low[now] = min(low[now], dfn[to]);
		}
	}
}

inline bool check(int x, int y)
{
	if(min(x, y) < 1 || x > h || y > w) return true;
	if(mps.count({x, y})) return true;
	return false;
}

inline void sol()
{
	cin >> h >> w >> n;
	mps.clear(); mpv.clear(); vsign = 0;
	for(int i = 1; i <= n; ++i) cin >> s[i].x >> s[i].y, mps[{s[i].x, s[i].y}] = i;
	
	for(int i = 1; i <= n; ++i)
		for(int dx = 0; dx <= 1; ++dx)
			for(int dy = 0; dy <= 1; ++dy)
				refresh(s[i].x + dx, s[i].y + dy);
	refresh(1, 1); refresh(1, w + 1); refresh(h + 1, 1); refresh(h + 1, w + 1);
	lp.clear(); rp.clear(); up.clear(); dp.clear();
	for(int i = 1; i <= vsign; ++i)
	{
		int nx = p[i].x, ny = p[i].y;
		if(nx == 1) up.push_back(ny);
		if(nx == h + 1) dp.push_back(ny);
		if(ny == 1) lp.push_back(nx);
		if(ny == w + 1) rp.push_back(nx);
		if(nx != 1 && nx != h + 1)
		{
			if(ny < w + 1 && mpv.count({nx, ny + 1}) && mps.count({nx, ny}) + mps.count({nx - 1, ny}) == 1)
				con[i].push_back({mpv[{nx, ny + 1}], 1});
			if(1 < ny && mpv.count({nx, ny - 1}) && mps.count({nx, ny - 1}) + mps.count({nx - 1, ny - 1}) == 1)
				con[i].push_back({mpv[{nx, ny - 1}], 1});
		}
		if(ny != 1 && ny != w + 1)
		{
			if(nx < h + 1 && mpv.count({nx + 1, ny}) && mps.count({nx, ny}) + mps.count({nx, ny - 1}) == 1)
				con[i].push_back({mpv[{nx + 1, ny}], 1});
			if(1 < ny && mpv.count({nx - 1, ny}) && mps.count({nx - 1, ny}) + mps.count({nx - 1, ny - 1}) == 1)
				con[i].push_back({mpv[{nx - 1, ny}], 1});
		}
	}
	sort(up.begin(), up.end()); sort(dp.begin(), dp.end());
	sort(lp.begin(), lp.end()); sort(rp.begin(), rp.end());
	for(int i = 0; i < (int)up.size() - 1; ++i)
	{
		if(up[i + 1] - up[i] > 1 || !mps.count({1, up[i]}))
		{
			con[mpv[{1, up[i]}]].push_back({mpv[{1, up[i + 1]}], up[i + 1] - up[i]});
			con[mpv[{1, up[i + 1]}]].push_back({mpv[{1, up[i]}], up[i + 1] - up[i]});
		}
	}
	for(int i = 0; i < (int)dp.size() - 1; ++i)
	{
		if(dp[i + 1] - dp[i] > 1 || !mps.count({h, dp[i]}))
		{
			con[mpv[{h + 1, dp[i]}]].push_back({mpv[{h + 1, dp[i + 1]}], dp[i + 1] - dp[i]});
			con[mpv[{h + 1, dp[i + 1]}]].push_back({mpv[{h + 1, dp[i]}], dp[i + 1] - dp[i]});
		}
	}
	for(int i = 0; i < (int)lp.size() - 1; ++i)
	{
		if(lp[i + 1] - lp[i] > 1 || !mps.count({lp[i], 1}))
		{
			con[mpv[{lp[i], 1}]].push_back({mpv[{lp[i + 1], 1}], lp[i + 1] - lp[i]});
			con[mpv[{lp[i + 1], 1}]].push_back({mpv[{lp[i], 1}], lp[i + 1] - lp[i]});
		}
	}
	for(int i = 0; i < (int)rp.size() - 1; ++i)
	{
		if(rp[i + 1] - rp[i] > 1 || !mps.count({rp[i], w}))
		{
			con[mpv[{rp[i], w + 1}]].push_back({mpv[{rp[i + 1], w + 1}], rp[i + 1] - rp[i]});
			con[mpv[{rp[i + 1], w + 1}]].push_back({mpv[{rp[i], w + 1}], rp[i + 1] - rp[i]});
		}
	}
	
	dsu.reset(n + 1);
	for(int i = 1; i <= n; ++i)
	{
		for(int j = 1; j <= 4; ++j)
		{
			int tx = s[i].x + dx[j], ty = s[i].y + dy[j];
			if(tx == 0 || tx == h + 1 || ty == 0 || ty == w + 1)
				dsu.merge(i, n + 1);
			else if(mps.count({tx, ty})) dsu.merge(i, mps[{tx, ty}]);
		}
	}
	int connect = 0; S = 0;
	for(int i = 1; i <= n + 1; ++i) if(dsu.find(i) == i) ++connect;
	
	mpe.clear(); able = false;
	for(int i = 1; i <= vsign; ++i) dfn[i] = low[i] = 0; sign = 0;
	for(int i = 1; i <= vsign; ++i) if(!dfn[i]) tarjan(i, 0);
	if(S > connect) {cout << 0 << '\n'; return ;}
	
	if(!able) {cout << -1 << '\n'; return ;}
	if(h == 1 || w == 1) {cout << 1 << '\n'; return ;}
	
	int recid = 0; bool flag = false;
	for(int now = 1; now <= vsign; ++now)
	{
		for(auto id : con[now])
		{
			int to = id.to;
			if(p[now].x == p[to].x && (p[now].x == 1 || p[now].x == h + 1))
				recid = mpe[{now, to}];
			if(p[now].y == p[to].y && (p[now].y == 1 || p[now].y == w + 1))
				recid = mpe[{now, to}];
		}
	}
	flag = false;
	for(int now = 1; now <= vsign; ++now)
	{
		int nx = p[now].x, ny = p[now].y;
		for(int i = 1; i <= 4; ++i)
		{
			int tx = nx + dx[i], ty = ny + dy[i];
			if(min(tx, ty) <= 0 || tx > h + 1 || ty > w + 1) continue;
			if(nx == tx && (check(nx, min(ny, ty)) || check(nx - 1, min(ny, ty)))) continue;
			if(ny == ty && (check(min(nx, tx), ny) || check(min(nx, tx), ny - 1))) continue;
			
			
			if(tx == 1 || ty == 1 || tx == h + 1 || ty == w + 1)
			{
				if(getid(now) == recid)
				{
					flag = true;
				}
			}
			
			if(!mpv[{tx, ty}]) continue;
			if(getid(mpv[{nx, ny}]) == getid(mpv[{tx, ty}]))
			{
				flag = true;
			}
		}
		if(flag) break;
	}
	for(int now = 1; now <= n; ++now)
	{
		for(int wd = 1; wd <= 4; ++wd)
		{
			int tx = s[now].x + dx[wd], ty = s[now].y + dy[wd];
			if(mps.count({tx, ty})) continue;
			if(1 <= min(tx, ty) && tx <= h && ty <= w)
			{
				int sum = 0;
				for(int w = 1; w <= 4; ++w) sum += check(tx + dx[w], ty + dy[w]);
				if(sum == 3) flag = true; 
			}
		}
		
		bool ok = true;
		for(int dx = 0; dx <= 2; ++dx)
		{
			for(int dy = 0; dy <= 2; ++dy)
			{
				if(dx == 0 && dy == 0) continue;
				if(dx + dy != 4 && mps.count({s[now].x + dx, s[now].y + dy})) ok = false;
				if(dx + dy == 4 && !mps.count({s[now].x + dx, s[now].y + dy})) ok = false;
				if(!ok) break;
			}
			if(!ok) break;
		}
		if(ok)
		{
			if(getid(mpv[{s[now].x + 1, s[now].y + 1}]) == getid(mpv[{s[now].x + 2, s[now].y + 2}]))
				flag = true;
		}
		
		ok = true;
		for(int dx = 0; dx <= 2; ++dx)
		{
			for(int dy = -2; dy <= 0; ++dy)
			{
				if(dx == 0 && dy == 0) continue;
				if(dx == 2 && dy == -2 && !mps.count({s[now].x + dx, s[now].y + dy})) ok = false;
				if(!(dx == 2 && dy == -2) && mps.count({s[now].x + dx, s[now].y + dy})) ok = false;
				if(!ok) break;
			}
			if(!ok) break;
		}
		if(ok)
		{
			if(getid(mpv[{s[now].x + 1, s[now].y}]) == getid(mpv[{s[now].x + 2, s[now].y - 1}]))
				flag = true;
		}
	}
	if(flag) cout << 1 << '\n';
	else cout << 2 << '\n';
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> T;
	while(T--) sol();
	return 0;
}
/*

*/
```

---

## 作者：littlez_meow (赞：7)

很具有教育意义的做法。

[题目指路](https://www.luogu.com.cn/problem/P1173)。

### 题意

给定一个 $n$ 行 $m$ 列的网格图，其中被删去了 $c$ 个点。求至少再删去多少点可以使图不连通，或报告无解。

### 思路

无解情况显然，点数 $\le 1$ 或两个点相邻。下面讨论有解情况。

首先，图中肯定存在度为 $2$ 的点（角落），因此答案不超过 $2$。

然后，答案为 $0$ 当且仅当原图不连通，为 $1$ 当且仅当存在割点，其他都是 $2$。

暂且不谈怎么求割点，$10^{18}$ 个点判连通性都比较困难吧。传统的 bfs 和并查集都不管用。

不过，[这道题](https://www.luogu.com.cn/problem/P3776)也是连通性问题，还都是网格图。在这道题中，我们使用了平面图欧拉公式。本题我们同样可以考虑欧拉公式。

我们有 $|V|-|E|+|R|=p+1$，其中 $|V|$ 为点集大小，$|E|$ 为边集大小，$|R|$ 为划分出的区域数，$p$ 为连通块数。注意 $|R|$ 要包括网格的外部。

初始时 $|V|=nm,|E|=(n-1)m+n(m-1),|R|=(n-1)(m-1)+1$。我们现在要研究删除一个点时等式左边三个量的变化。

$|V|$ 是容易的。每次删掉一个点就减 $1$。

$|E|$ 的话，遍历与删除的点四连通的点，有多少个点没被删除就减多少。

我们发现删除一个点时，它周围的四个格子会合并到一起，最多影响 $4c$ 个格子。可以用动态开点并查集维护格子的连通块（不是原图的连通块）。两个连通块合并了就让 $|R|$ 减一。

依次删除点，最后看满不满足 $|V|-|E|+|R|=2$ 就可以判断连通性了。

然后是割点。发现割点只会在与被删除的点八连通的地方，可以逐个测试这些位置删除后是否连通。注意测试完一个点需要撤销。如果在删除某个点后 $|V|-|E|+|R|>2$ 就证明这个点时割点，答案为 $1$。

特判一下 $n=1$ 或 $m=1$，此时只要有解且连通答案就是 $1$。

时间复杂度 $O(c\log c)$，瓶颈在于可撤销并查集（按秩合并）。

### 代码

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define ll long long
#define fi first
#define se second
using namespace std;
const int step[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{-1,1},{-1,-1},{1,-1}},MAXC=1e5+1;
int n,m,c;
pair<int,int>pos[MAXC];
inline ll id(int x,int y){return m*(x-1ll)+y;}
__gnu_pbds::gp_hash_table<ll,int>ququ,area;
int cnt,dsu[MAXC<<2],siz[MAXC<<2];
inline ll arid(int x,int y){
	if(x<=0||x>=n||y<=0||y>=m) return 0;
	if(area.find(id(x,y))!=area.end()) return area[id(x,y)];
	else return area[id(x,y)]=++cnt,dsu[cnt]=cnt,siz[cnt]=1,cnt;
}
int find(int x){return dsu[x]==x?x:find(dsu[x]);}
ll V,E,R;
stack<pair<int,int> >stk;
void merge(int x,int y,bool op=0){
	x=find(x),y=find(y);
	if(x==y) return;
	if(siz[x]<siz[y]) swap(x,y);
	if(op) stk.push(make_pair(x,y));
	--R,dsu[y]=x,siz[x]+=siz[y];
	return;
}
void undo(){
	auto qwq=stk.top();
	stk.pop();
	++R,dsu[qwq.se]=qwq.se,siz[qwq.fi]-=siz[qwq.se];
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T; 
	for(cin>>T;T;--T){
		cin>>n>>m>>c;
		siz[cnt=0]=1,dsu[0]=0;
		while(!stk.empty()) stk.pop();
		ququ.clear(),area.clear();
		V=n*1ll*m,E=(n-1ll)*m+n*(m-1ll),R=(n-1ll)*(m-1)+1;
		F(i,1,c){
			int&x(pos[i].fi),&y(pos[i].se);
			cin>>x>>y;
			ququ[id(x,y)]=1,--V;
			F(j,0,3){
				int xx=x+step[j][0],yy=y+step[j][1];
				if(xx>n||xx<=0||yy>m||yy<=0) continue;
				if(ququ.find(id(xx,yy))==ququ.end()) --E;
			}
			merge(arid(x-1,y),arid(x,y));
			merge(arid(x,y-1),arid(x,y));
			merge(arid(x-1,y-1),arid(x-1,y));
		}
		if(V-E+R>2){
			cout<<"0\n";
			continue;
		}
		if(V<=2){
			cout<<"-1\n";
			continue;
		}
		if(n==1||m==1){
			cout<<"1\n";
			continue;
		}
		bool flag=0;
		F(i,1,c){
			F(j,0,7){
				int x(pos[i].fi+step[j][0]),y(pos[i].se+step[j][1]);
				if(x>n||x<=0||y>m||y<=0||ququ.find(id(x,y))!=ququ.end()) continue;
				--V;
				ll tmp=E;
				F(k,0,3){
					int xx=x+step[k][0],yy=y+step[k][1];
					if(xx>n||xx<=0||yy>m||yy<=0) continue;
					if(ququ.find(id(xx,yy))==ququ.end()) --E;
				}
				int cc=cnt;
				merge(arid(x-1,y),arid(x,y),1);
				merge(arid(x,y-1),arid(x,y),1);
				merge(arid(x-1,y-1),arid(x-1,y),1);
				if(V-E+R>2){
					cout<<"1\n";
					flag=1;
					break;
				}
				while(!stk.empty()) undo();
				if(arid(x-1,y)>cc) area.erase(id(x-1,y));
				if(arid(x,y-1)>cc) area.erase(id(x,y-1));
				if(arid(x-1,y-1)>cc) area.erase(id(x-1,y-1));
				if(arid(x,y)>cc) area.erase(id(x,y));
				E=tmp,cnt=cc,++V;
			}
			if(flag) break;
		}
		if(!flag) cout<<"2\n";
	}
	return 0;
}
```

---

## 作者：OoXiao_QioO (赞：7)

纪念第一道独立想出来的黑题。

显然答案为 $0,-1,1,2$ 的其中之一。因为我们最多用两个跳蚤，就可以让最上面一行，最靠边的一个跳蚤和其他的不连通。读者自己画图很容易理解。

~~所以你可以随机输出这四个数中的任意一个，正确率高达 $\dfrac{1}{4^T}$。~~

对于每种情况分别考虑。

# 答案为 $-1$

若只剩下一个格子，或剩下的两个格子是相邻的，那么答案显然为 $-1$，因为不论放不放蛐蛐，都不能使这剩下的跳蚤分开。

# 答案为 $0$

若原图有两个跳蚤都不在一个 $8$ 连通块内，那么答案就是 $0$。但我们不能直接通过 bfs 计算，因为无效的跳蚤太多了。既然有这么多没用的跳蚤，那就从中挑几个有用的呗。

考虑对于每一个蛐蛐的周围的八个跳蚤都拿出来，看看每个蛐蛐 $4$ 连通块周围的跳蚤是否都在同一个连通块内即可。

例如下图，跳蚤是黄色（没上色的也是跳蚤），蛐蛐是红色。两个蛐蛐 $4$ 连通块将跳蚤分成 $2$ 部分。注意左边那一部分，这个 $4$ 连通块旁边的跳蚤不属于一个连通块，此时答案是 $0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/dx23jees.png)

# 答案为 $1$

接下来考虑答案为 $1$ 的情况。

我们仍然取出每个蛐蛐周围的 $8$ 个跳蚤，如果存在一个跳蚤，把它变成蛐蛐后，原来和它相邻的跳蚤会分成若干连通块，那么答案就是 $1$ 了。显然这个跳蚤也是一个割点。

可是，这么做一定是正确的吗？其实并不对，下图就是一个反例。

![](https://cdn.luogu.com.cn/upload/image_hosting/sshoskjo.png)

如果按照上述的方法，求得的割点其实是黄色八字形的中间那个点。但是若将这个点标记为蛐蛐，会发现它只会让这个点周围的跳蚤不联通，实际上，这些跳蚤可以通过它们周围的跳蚤联通。

为了解决这个问题，我们只需要将蛐蛐周围的跳蚤的跳蚤也拿出来，这样再求出割点（必须是蛐蛐周围的），也就是真的割点了。例如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/x1ozwrra.png)

# 答案为 $2$

除去以上三种情况，其他情况直接输出 $2$ 即可。

---


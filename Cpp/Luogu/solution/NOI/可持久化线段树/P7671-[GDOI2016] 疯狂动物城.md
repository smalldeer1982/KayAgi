# [GDOI2016] 疯狂动物城

## 题目背景

原题空间限制 512MB。

---

Nick 是只在动物城以坑蒙拐骗为生的狐狸，儿时受到偏见的伤害，放弃了自己的理想。他被兔子 Judy 设下圈套，被迫与她合作查案，而卷入意想不到的阴谋，历尽艰险后成为搭档。他们识破了绵羊副市长 Bellwether 的计划，发现是 Bellwether 陷害食肉动物，用毒药让食肉动物发狂。Bellwether 被抓到了监狱里面， Nick 和 Judy 过上了一段平静的日子。

然而，故事并没有这样结束，之前在车管所帮他们查车牌号的憨厚的树懒 Flash，才是陷害食肉动物事件的幕后主使。Flash 批量制作了大量让食肉动物发狂的药剂，投放到了食肉动物群中。现在，大量的食肉动物被感染，动物城陷入了一片混乱。警察局的牛局长 Bogo 找到了 Nick，希望他能帮忙。幸运的是，动物城联邦安全局非常有先见之明，他们在每个州都秘密放置了一台机器，机器能生产能量石，这些能量石能让食肉动物恢复正常。现在 Nick 和 Judy 需要去启动这些机器。

## 题目描述

**提示：我们在文末提供了一份形式化题意。**

动物城是一个有 $N$ 个州的联邦，该联邦是一个树的形状，即 $N$ 个州共有 $N-1$ 条双向道路连接它们，且 $N$ 个州是相互连通的。$N$ 个州的编号依次为 $1,2,3,\dots,N$。每个州都有且仅有一台机器。一台机器启动后的下一个时刻，就会开始生产能量石，每个单位时间生产一个。能量石从被生产的时刻开始即生效，每一个单位时间能救一定数量的食肉动物。每个州的解毒机器制造出的能量石的品种可能是不同，第 $i$ 个州的机器生产的能量石每个单位时间能救 $a_i$ 只食肉动物。
   
   Nick 和 Judy 剩下的时间不多了，他们决定分工合作。 Nick 从 $X$ 州出发，目的地为 $Y$ 州，路径为 $X$ 到 $Y$ 的最短路径。 Nick 从 $X$ 州出发的时刻为 $0$，每隔一个单位时间移动一个州。每到一个州，Nick 就会启动这个州的机器。 Nick 想知道他从 $X$ 州出发到达 $Y$ 州的这段时间里，一共有多少食肉动物被拯救。Nick 在纠结他的路线选择，因此，他会给你若干的询问，希望比他更聪明的你能帮助他。

   在他给你询问的过程中，动物城的局势也在发生着一些变化。动物城联邦安全局可以执行一个修改操作 $X,Y,\Delta$，会对 $X$ 州到 $Y$ 州的最短路径上的州（包括 $X,Y$ 州）的机器进行升级，这样，这些机器生产出来的能量石，每个单位时间能救的食肉动物的数量会增加 $\Delta$。
   
   树懒 Flash 当然也不会坐以待毙，他有一台监控仪，会监控每个州的机器的情况，每当有机器被升级，监控仪就会保存下当前所有州的机器的属性 $a_i$。Flash 可以用一种神秘的武器执行一个读取操作 $X$，把当前各个州的机器恢复到第 $X$ 次保存的状态（$X=0$ 表示未进行过升级时的初始状态）。注意，只有修改操作执行的时后会进行保存。

   现在，依次给出 $M$ 个操作，若该操作为一个询问，请你输出 Nick 在当前局面下，他从 $X$ 州出发到达 $Y$ 州的这段时间里，一共有多少食肉动物被拯救，由于这个答案可能很大，你只需要输出答案模 $20160501$ 后的值。请注意，$M$ 个操作都是被加密过的。
   
****

**形式化题意**：

给你一棵 $N$ 个点的树，接下来有三种操作共 $M$ 次：

- `1 x y w`，表示将 $x$ 到 $y$ 的路径上的所有点的点权加上 $w$。
- `2 x y`，表示一次询问。记 $x$ 到 $y$ 的路径上的点集为 $S(x,y)$，点 $p,q$ 之间的路径长度为 $\text{dis}(p,q)$，求出 $\sum_{i\in S(x,y)}\sum_{j\le \text{dis}(i,y)}a_i\cdot j$ 的值。将答案对 $20160501$ 取模。
- `3 x`，表示将这棵树的所有点权恢复到第 $x$ 次 `1` 操作之后的状态。

强制在线。

## 说明/提示

对于所有数据，保证 $1\le n,m\le 10^5$，$1\le a_i,\Delta\le 10^5$，$1\le x,y\le n$。

对于其中 $20\%$ 的数据，保证 $n,m\le 2000$。

对于另外 $20\%$ 的数据，保证树为一条链，且不含有操作 `3`。

对于另外 $40\%$ 的数据，保证树为一条链。


## 样例 #1

### 输入

```
5 6
1 2
2 3
3 4
4 5
1 2 3 4 5
1 1 5 2
3 0
1 1 3 2
1 3 4 2
3 2
2 1 5```

### 输出

```
73```

## 样例 #2

### 输入

```
5 4
1 2
1 3
2 4
3 5
1 1 1 2 2
1 1 4 2
2 1 4
3 12
2 13 8```

### 输出

```
12
4```

# 题解

## 作者：Imtking (赞：22)

## 题解 P7671
### 主席树，树链剖分，标记永久化

给定一棵树，要求实现以下操作：

1. 将树上 $x$ 到 $y$ 的权值加 $k$，同时新建一个版本。

2. 查询树上 $x$ 到 $y$ 的答案。
	
    树上 $x$ 到 $y$ 的答案的定义为：
    $$\sum\limits_{i \in R(x,y)}\!{a_i}\times\dfrac{dis(i,y)(dis(i,y)+1)}{2}$$

3. 回到第 $x$ 个版本，初始状态视作 $0$ 版本。

可以发现，该题核心操作为查询答案，可以发现我们需要想办法维护 $dis(i,y)$，不太好做，我们可以指定一个点为树的根，这样就有 $dis(i,y)=dep_i+dep_y-2dep_{lca}$。

于是就有：

$$\dfrac{1}{2}\!\sum\limits_{i \in R(x,y)}\!{a_i}\times(dep_i+dep_y-2dep_{lca})((dep_i+dep_y-2dep_{lca})+1)$$

我们发现，如果强行分解这个式子，最后将非常难维护，我们不妨将一条路径拆分成两条链的形式，现在有了两个集合，$S=[x,lca]$，$T=(lca,y]$，对于这两个集合，其中一个的答案是多少对于另一个集合的答案没有任何影响。

$S:$ 
 
$$\begin{aligned}ans_S & =\dfrac{1}{2}\!\sum\limits_{i \in S}{a_i}\times\left[\left(dep_i+dep_y-2dep_{lca}\right)^2+\left(dep_i+dep_y-2dep_{lca}\right)\right] \\ & =\dfrac{1}{2}\sum\limits_{i \in S}{a_i}\times\left(dep_i^2+dep_y^2+4dep_{lca}^2+2dep_idep_y-4dep_idep_{lca}-4dep_ydep_{lca}+dep_i+dep_y-2dep_{lca}\right) \\ & =\dfrac{1}{2}\left[\sum\limits_{i \in S}{a_i}dep_i^2+\sum\limits_{i \in S}{a_i}dep_i\left(2dep_y-4dep_{lca}\right)+\sum\limits_{i \in S}{a_i}\left(dep_y^2+4dep_{lca}^2-4dep_ydep_{lca}+dep_y-2dep_{lca}\right)\right] \\ & =\dfrac{1}{2}\left[\sum\limits_{i \in S}{a_idep_i^2}+\sum\limits_{i \in S}{a_idep_i\left(2m_1+1\right)}+\sum\limits_{i \in S}{a_i\left(m_1^2+m_1\right)}\right]\left(m_1=dep_y-2dep_{lca}\right)\end{aligned}$$ 

$T:$ 
 
$$\begin{aligned}ans_T & =\dfrac{1}{2}\sum\limits_{i \in T}{a_i}\times\left[\left(dep_i+dep_y-2dep_i\right)^2+\left(dep_i+dep_y-2dep_i\right)\right] \\ & =\dfrac{1}{2}\sum\limits_{i \in T}{a_i}\times\left(dep_y^2+dep_i^2-2dep_ydep_i+dep_y-dep_i\right) \\ & =\dfrac{1}{2}\left[\sum\limits_{i \in T}{a_i}dep_i^2-\sum\limits_{i \in T}{a_i}dep_i\left(2dep_y+1\right)+\sum\limits_{i \in T}{a_i}\left(dep_y^2+dep_y\right)\right] \\ & =\dfrac{1}{2}\left[\sum\limits_{i \in T}{a_idep_i^2}-\sum\limits_{i \in T}{a_idep_i\left(2m_2+1\right)}+\sum\limits_{i \in T}{a_i\left(m_2^2+m_2\right)}\right]\left(m_2=dep_y\right)\end{aligned}$$ 

现在，我们只要在线段树上维护 $a_idep_i^2$、$a_idep_i$、$a_i$ 就可以实现 $2$ 操作了。关于 $1$ 操作，我们可以依靠 dfs 序维护 $dep_i^2$ 以及 $dep_i$ 的前缀和，这样就可以进行维护了。

但是，这题我们需要完成主席树上的区间修改、区间查询，因为主席树的不同版本节点时存在共用的，如果我们随意地 pushdown 以及 pushup 的话就会得到错误答案，因此我们**每次修改都需要新建节点**，这会导致空间非常大，其中有大量冗余节点。因此，我们可以使用标记永久化的方法，在修改时，如果**节点区间被完全包含**了，直接**将懒标记打到节点上再返回**，有交集就累加上更改的值然后向其遍历；在查询时，一路**累加懒标记的贡献**，同样**在节点区间被完全包含时返回**。

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

inline int read()
{
	int x = 0;
	char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	while (c >= '0' && c <= '9')
	{
		x = (x << 1) + (x << 3) + (c ^ 48);
		c = getchar();
	}
	return x;
}

const int N = 100100;
const int mod = 20160501;

int head[N], to[N * 2], nxt[N * 2], tot;

inline void add(int x, int y)
{
	to[++tot] = y;
	nxt[tot] = head[x];
	head[x] = tot;
}

int d[N], s[N], f[N], hs[N];

inline void dfs1(int x)
{
	s[x] = 1;
	for (int i = head[x]; i; i = nxt[i])
	{
		if (d[to[i]]) continue;
		d[to[i]] = d[x] + 1;
		f[to[i]] = x;
		dfs1(to[i]);
		s[x] += s[to[i]];
		if (s[hs[x]] < s[to[i]]) hs[x] = to[i];
	}
}

int top[N], dfn[N], rk[N], res;

inline void dfs2(int x, int t)
{
	top[x] = t;
	dfn[x] = ++res;
	rk[res] = x;
	if (hs[x]) dfs2(hs[x], t);
	for (int i = head[x]; i; i = nxt[i])
		if (to[i] != f[x] && to[i] != hs[x]) dfs2(to[i], to[i]);
}

struct tree
{
	long long k, dk, ddk, f;
	int ls, rs, v[2];
	tree() { k = dk = ddk = ls = rs = f = v[0] = v[1] = 0; }
} t[N << 6];
int rt[N], cnt, root, n, m;
long long a[N], e[N], ee[N];

inline tree operator + (tree a, tree b)
{
	tree c;
	c.k = (a.k + b.k) % mod;
	c.dk = (a.dk + b.dk) % mod;
	c.ddk = (a.ddk + b.ddk) % mod;
	return c;
}
inline int D(int l, int r) { return e[r] - e[l - 1] + mod; }
inline int DD(int l, int r) { return ee[r] - ee[l - 1] + mod; }

inline void build(int &tp, int l, int r)
{
	tp = ++cnt;
	if (l == r)
	{
		int x = rk[l];
		t[tp].k = (a[x]) % mod;
		t[tp].dk = (a[x] * d[x]) % mod;
		t[tp].ddk = (a[x] * d[x] * d[x]) % mod;
		return;
	}
	int mid = (l + r) >> 1;
	build(t[tp].ls, l, mid);
	build(t[tp].rs, mid + 1, r);
	t[tp].k = (t[t[tp].ls].k + t[t[tp].rs].k) % mod;
	t[tp].dk = (t[t[tp].ls].dk + t[t[tp].rs].dk) % mod;
	t[tp].ddk = (t[t[tp].ls].ddk + t[t[tp].rs].ddk) % mod;
}

inline void pushup(tree &tp, int l, int r, long long k)
{
	tp.k = (tp.k + k * (r - l + 1) % mod) % mod;
	tp.dk = (tp.dk + k * D(l, r) % mod) % mod;
	tp.ddk = (tp.ddk + k * DD(l, r) % mod) % mod;
}

inline int copy(int tp)
{
	t[++cnt] = t[tp];
	return cnt;
}

inline void update(int tp, int l, int r, int ql, int qr, long long k)
{
	pushup(t[tp], max(l, ql), min(r, qr), k);//只累加需要更改的区间的值
	if (ql <= l && r <= qr) { t[tp].f = (t[tp].f + k) % mod; return; }
	int mid = (l + r) >> 1;
	if (ql <= mid)
	{
		if (t[tp].v[0])
		{
			t[tp].ls = copy(t[tp].ls);
			t[t[tp].ls].v[0] = 1;
			t[t[tp].ls].v[1] = 1;
			t[tp].v[0] = 0;
		}
		update(t[tp].ls, l, mid, ql, qr, k);
	}
	if (mid < qr)
	{
		if (t[tp].v[1])
		{
			t[tp].rs = copy(t[tp].rs);
			t[t[tp].rs].v[0] = 1;
			t[t[tp].rs].v[1] = 1;
			t[tp].v[1] = 0;
		}
		update(t[tp].rs, mid + 1, r, ql, qr, k);
	}
}

inline tree query(int tp, int l, int r, int ql, int qr)
{
	if (ql <= l && r <= qr) return t[tp];
	int mid = (l + r) >> 1; tree ans;
	pushup(ans, max(l, ql), min(r, qr), t[tp].f);
	if (ql <= mid) ans = ans + query(t[tp].ls, l, mid, ql, qr);
	if (mid < qr) ans = ans + query(t[tp].rs, mid + 1, r, ql, qr);
	return ans;
}

inline int LCA(int x, int y)
{
	while (top[x] != top[y])
	{
		if (d[top[x]] < d[top[y]]) swap(x, y);
		x = f[top[x]];
	}
	if (d[x] > d[y]) swap(x, y);
	return x;
}

inline void updates(int x, int y, long long k)
{
	while (top[x] != top[y])
	{
		if (d[top[x]] < d[top[y]]) swap(x, y);
		update(rt[root], 1, n, dfn[top[x]], dfn[x], k);
		x = f[top[x]];
	}
	if (dfn[x] > dfn[y]) swap(x, y);
	update(rt[root], 1, n, dfn[x], dfn[y], k);
}

inline int clac(long long c, int op, int l, int r)
{
	tree g = query(rt[root], 1, n, l, r);
	return (g.ddk + (op * g.dk * (c * 2 + 1)) % mod + g.k * ((c * c) % mod + c) + mod) % mod;
}

inline long long SUM(int x, int y)
{
	int lca = LCA(x, y);
	long long m1 = (d[y] - d[lca] * 2 + mod) % mod, m2 = d[y], ans = 0;
	while (top[x] != top[y])
	{
		if (d[top[x]] <= d[top[y]]) ans = (ans + clac(m2, -1, dfn[top[y]], dfn[y])) % mod, y = f[top[y]];
		else ans = (ans + clac(m1, 1, dfn[top[x]], dfn[x])) % mod, x = f[top[x]];
	}
	if (d[x] >= d[y]) ans = (ans + clac(m1, 1, dfn[y], dfn[x])) % mod;
	else ans = (ans + clac(m2, -1, dfn[x], dfn[y])) % mod;
	return ans * ((mod + 1) / 2) % mod;//这是2的逆元
}

signed main()
{
	n = read(); m = read();
	for (int i = 1; i < n; ++i)
	{
		int u = read(), v = read();
		add(u, v); add(v, u);
	}
	for (int i = 1; i <= n; ++i) a[i] = read();
	d[1] = 1; dfs1(1); dfs2(1, 1);
	for (int i = 1; i <= n; ++i)
	{
		e[i] = (e[i - 1] + d[rk[i]]) % mod;
		ee[i] = (ee[i - 1] + 1ll * d[rk[i]] * d[rk[i]]) % mod;
	}//前缀和
	build(rt[0], 1, n);
	long long last = 0; int ddd = 0;
	while (m--)
	{
		int op = read(), x, y; long long k;
		if (op == 1)
		{
			x = read(); y = read(); k = read();
			x ^= last, y ^= last;
			rt[++ddd] = ++cnt;
			t[rt[ddd]] = t[rt[root]];
			root = ddd;
			t[rt[root]].v[0] = t[rt[root]].v[1] = 1;
			updates(x, y, k);
		}//只有在修改时才新建版本
		else if (op == 2)
		{
			x = read(); y = read();
			x ^= last, y ^= last;
			printf("%lld\n", (last = SUM(x, y)));
		}
		else
		{
			x = read();
			x ^= last;
			root = x;
		}
	}
	return 0;
}
```

---

## 作者：未来姚班zyl (赞：10)

### 重要的事情说三遍：如果您是树链剖分/主席树的初学者，千万别先做这题，千万别先做这题，千万别先做这题！！！但这题的质量依旧很棒，建议熟练了以上两个算法再来尝试。

## 题目大意
首先，本题解中，所有的 $R(x,y)$ 表示节点 $x$ 和节点 $y$ 在树上的最短路径上的**点集**，$dis(x,y)$ 表示节点 $x$ 到节点 $y$ 在树上的距离，$lca$ 为节点 $x$ 和节点 $y$ 在树上的最近公共祖先。

给定一棵带点权的树，要求支持以下操作：

1. 路径点权加。

2. 给定 $x,y$，求 $\sum\limits_{i\in R(x,y)}{\sum\limits_{1\le j\le dis(i,y)}j\times a_i}$，其中 $a_i$ 指点权。

3. 回到第 $x$ 次 1 操作之后的版本。

强制在线，点数和操作数不超过十万。

## 题目分析
首先，这道题的核心是 2 操作，显然，我们很难维护这个式子，所以要想办法对其化简。首先，我们要知道这两个基本的数学公式：
- $\sum\limits_{i\in U}ia=a\sum\limits_{i\in U}i$，$a$ 为常数。
- $\sum\limits_{1\le i\le n}{i}=\frac{n(n+1)}{2}$，$i$ 为整数。

根据数学公式，我们对 2 中的式子初步化简：

$\sum\limits_{i\in R(x,y)}{\sum\limits_{1\le j\le dis(i,y)}j\times a_i}$

$=\sum\limits_{i\in R(x,y)}{a_i}\frac{dis(i,y)(dis(i,y)+1)}{2}$

$=\frac{1}{2}\sum\limits_{i\in R(x,y)}{a_i}dis(i,y)(dis(i,y)+1)$

因为强制在线，距离乘点权无法用 $O(\log n)$ 类似的复杂度维护。所以我们不难想到，可以将距离转换为深度，这是很好维护的。

如果我们直接硬拆这个式子的话，最终的式子会异常复杂，我们不妨将点集分为两段：$R(x,lca)$，$R(lca,y)$，由于 $lca$ 处于两个集合的交，所以我们设集合 $S=R(x,lca)$，$T=\{ i\in R(lca,y),i\neq lca\}$。对于 $i\in S$，$dis(i,y)=dep_i+dep_y-2dep_{lca}$，对于 $i\in T$，$dis(i,y)=dep_y-dep_i$
于是，原式就可以进一步化简：

$=\frac{1}{2}\sum\limits_{i\in R(x,y)}{a_i}dis(i,y)(dis(i,y)+1)$

$=\frac{1}{2}\sum\limits_{i\in S}{a_i(dep_i+dep_y-2dep_{lca})(dep_i+dep_y-2dep_{lca}+1)}+\frac{1}{2}\sum\limits_{i\in T}{a_{i}(dep_y-dep_i)(dep_y-dep_i+1)}$

$=\frac{1}{2}\sum\limits_{i\in S}{a_i({dep_i}^2+{dep_y}^2+4{dep_{lca}}^2+2dep_idep_y-4dep_idep_{lca}-4dep_ydep_{lca}+dep_i+dep_y-2dep_{lca})}+\frac{1}{2}\sum\limits_{i\in T}{a_i({dep_y}^2+{dep_i}^2-2dep_ydep_i+dep_y-dep_i)}$

到这一步，我们离答案也就不远了，因为 $dep_y$ 和 $dep_{lca}$ 均可以视为常数，我们就将系数分组，结合上面的第一条数学公式，得到我们的最终式子：

$\frac{1}{2}[({dep_y}^2+4{dep_{lca}}^2-4dep_ydep_{lca}+dep_y-2dep_{lca})\sum\limits_{i\in S}a_i+(2dep_y-4dep_{lca}+1)\sum\limits_{i\in S}{dep_ia_i}+\sum\limits_{i\in S}{{dep_i}^2}a_i+({dep_y}^2+dep_y)\sum\limits_{i\in T}a_i-(2dep_y+1)\sum\limits_{i\in T}dep_ia_i+\sum\limits_{i\in T}{{dep_i}^2a_i}]$

每个 $\sum$ 符号前面的都是可以 $O(1)$ 算出来的常数，我们只需要在线段树上维护 $\sum a$，$\sum dep\times a$，$\sum {dep}^2a$，为了维护后两项，就再维护一下 $\sum dep$ 和 $\sum dep^2$。这样路径加和查询操作都可以得到解决……了吗？

现在要处理可持久化。对于树上路径的修改，我们最多可能会修改 $2\log n$ 个区间，如果按照正常的逻辑，在修改或是查询时，想要得到当前区间的正确信息，就不得不先 pushdown 再 pushup，这会在可持久化的过程中直接导致不得不新建很多节点。空间爆炸。但这道题维护的所有信息都具有可加性，所以我们可以采用**标记永久化**的策略，首先，我们维护一下 $dep$ 和 $dep^2$ 的前缀和，在修改一个区间时，我们该怎么修改就怎么修改，如果当前区间被修改区间覆盖，那就在当前节点打上一个标记，然后停止修改，注意，这里的标记是不会下放的，我们也不需要上传。查询时，我们先一路累加节点的标记，对应的值该怎么加就怎么加，当查询区间覆盖了当前节点时，就直接加上当前节点的信息。这样的话，我们减少了大量空间的支出，修改时没有浪费一个节点，查询时没有新建节点。在这里，虽然会修改很多区间，但这些区间不会重叠，且最多 $O(\log n)$ 个区间，事实上区间的个数不断趋近于 $O(\log n)$ 时，每个区间的长度会不断趋近于 $O(1)$，这是重链剖分的性质。最坏的情况莫过于这些区间均匀分散在线段树中，而这样也只需要建立 $O(\log^2 n)$ 个节点，而且很难跑满，因为上层的节点不需要修改一次就新建一个，会有大量的重复。只要出题人不绞尽脑汁卡，就不会 MLE。具体代码大家最好自己实现(毕竟代码量 5k 起步）在这里给出的代码中，一些片段无需展现，只展现关键片段，希望大家能够尽量独立完成代码！
```cpp
#include<bits/stdc++.h>
#define int long long
//这题有很多地方是要强制类型转换的，为了防止出错，这里使用 define int long long
#define L t[x].lc
#define R t[x].rc
#define mid (l+r>>1)
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define e(x) for(int i=h[x];i;i=nxt[i])
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1e5+5,M=4e7+5,inf=2147000000;
const int mod=20160501;
using namespace std;
int n,m,h[N],to[N*2],nxt[N*2],cnt,a[N];
inline void add(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;
}
int dep[N],siz[N],son[N],top[N],f[N],Id[N];//Id[i]是代表欧拉序对应的节点的原编号
inline void dfs(int x,int fa){
	/*
    这是常规树链剖分
    */
}
int dfn[N],Time;
inline void Dfs(int x,int low){
	/*
    这是常规树链剖分
   */
}
struct node{
	int lc,rc;
	int w;//点权和
	int laz;//永久化标记
	int smul;//点权乘深度
	int spow;//点权乘深度方
	bool nl,nr;//这两个变量记录左右儿子是否已经新建过了
}t[N*130];
int tot,root[N],sd[N],sdd[N];
inline int getd(int l,int r){
	return (sd[r]-sd[l-1]+mod)%mod;
}
inline int getdd(int l,int r){
	return (sdd[r]-sdd[l-1]+mod)%mod;
}
//这一段是前缀和
inline void insert(int x,int l,int r,int k){
	if(!k)return;
	(t[x].w+=(r-l+1)*k%mod)%=mod,(t[x].smul+=getd(l,r)*k%mod)%=mod,(t[x].spow+=getdd(l,r)*k%mod)%=mod;
    //这一段插入一个节点对应的值，这里的l和r是需要修改的部分，而不是这个节点的l和r
}
inline void getup(int x){
	t[x].w=(t[L].w+t[R].w)%mod,t[x].smul=(t[L].smul+t[R].smul)%mod,t[x].spow=(t[L].spow+t[R].spow)%mod;//只在建树的时候使用
}
inline int build(int &x,int l,int r){
	x++;
	if(l==r){
    /*
    这是建树的部分，这里填什么请自己完善
    */
    return x;}
	int now=x;
	t[now].lc=build(x,l,mid),t[now].rc=build(x,mid+1,r);
	getup(now);
	return now;
}
inline void modify(int x,int l,int r,int Ll,int Rr,int k){
	insert(x,max(l,Ll),min(r,Rr),k);//该怎么添加就怎么添加
	if(l>=Ll&&r<=Rr){
		t[x].laz+=k;//被覆盖，打上标记
		return;
	}
	if(Rr<=mid){
		if(t[x].nl)t[x].nl=0,t[++tot]=t[L],L=tot,t[L].nl=t[L].nr=1;//待修改的节点在原树上，需要新建节点
		modify(L,l,mid,Ll,Rr,k);
	}
	else if(Ll>mid){
		if(t[x].nr)t[x].nr=0,t[++tot]=t[R],R=tot,t[R].nl=t[R].nr=1;//待修改的节点在原树上，需要新建节点
		modify(R,mid+1,r,Ll,Rr,k);
	}
	else {
		if(t[x].nl)t[x].nl=0,t[++tot]=t[L],L=tot,t[L].nl=t[L].nr=1;
		if(t[x].nr)t[x].nr=0,t[++tot]=t[R],R=tot,t[R].nl=t[R].nr=1;//待修改的节点在原树上，需要新建节点
		modify(L,l,mid,Ll,Rr,k),modify(R,mid+1,r,Ll,Rr,k);
	}
}
inline node queryw(int x,int l,int r,int Ll,int Rr,node now){
	if(l>=Ll&&r<=Rr){
		(now.w+=t[x].w)%=mod,(now.smul+=t[x].smul)%=mod,(now.spow+=t[x].spow)%=mod; 
               //如果覆盖，加上该节点的信息
		return now;
	}
	int nl=max(l,Ll),nr=min(r,Rr);
	(now.w+=(nr-nl+1)*t[x].laz)%=mod,(now.smul+=getd(nl,nr)*t[x].laz)%=mod,(now.spow+=getdd(nl,nr)*t[x].laz)%=mod; //累加路上的标记
	if(Rr<=mid)return queryw(L,l,mid,Ll,Rr,now);
	if(Ll>mid)return queryw(R,mid+1,r,Ll,Rr,now);
	return queryw(L,l,mid,Ll,Rr,queryw(R,mid+1,r,Ll,Rr,now));
}
inline int Lca(int x,int y){
	/*
    这是常规树链剖分求LCA
   */
}
int lastans,cmt,nowroot;//cmt是记录当前是第几次1操作
inline void lca_(int x,int y,int z){
	/*
    这是常规的树链剖分的修改
   */ 
}
inline int lca_q(int x,int y,int lca){
	int ans=0;
    int wkk=(2*dep[y]-4*dep[lca]+1+mod)%mod,wk=(dep[y]*dep[y]%mod+4*dep[lca]%mod*dep[lca]%mod-4*dep[y]%mod*dep[lca]%mod+dep[y]-2*dep[lca]+mod)%mod,yk=dep[y]*(dep[y]+1)%mod,dk=(dep[y]*2+1)%mod;//这里的变量一一对应了题解中的常数
	node now;
	while(top[x]^top[lca]){
		now.w=now.smul=now.spow=0;
		now=queryw(root[nowroot],1,n,dfn[top[x]],dfn[x],now);
		ans+=now.w*wk%mod;
		ans+=now.spow;
		ans+=now.smul*wkk%mod;
		ans%=mod;
		x=f[top[x]];
	}
	if(x^lca){
		now.w=now.smul=now.spow=0;
		now=queryw(root[nowroot],1,n,dfn[lca]+1,dfn[x],now);
		ans+=now.w*wk%mod;
		ans+=now.spow;
		ans+=now.smul*wkk%mod;
		ans%=mod;
	}//代码是把 x 放在了 T 集合，不过放哪个集合都正确
   //这上面求的是 S 集合的部分
   //这下面求的是 T 集合的部分
	while(top[y]^top[lca]){
		now.w=now.smul=now.spow=0;		
		now=queryw(root[nowroot],1,n,dfn[top[y]],dfn[y],now);
		ans+=now.w*yk%mod;
		ans+=now.spow%mod;
		ans-=now.smul*dk%mod;
		ans=(ans%mod+mod)%mod;
		y=f[top[y]];
	}
	now.w=now.smul=now.spow=0;
	now=queryw(root[nowroot],1,n,dfn[lca],dfn[y],now);
	ans+=now.w*yk%mod;
	ans+=now.spow%mod;
	ans-=now.smul*dk%mod;
	ans=(ans%mod+mod)%mod;
	return ans*((mod+1)/2)%mod;
}
inline void prep(){
	rep(i,1,n)sd[i]=(sd[i-1]+dep[Id[i]])%mod,sdd[i]=(sdd[i-1]+dep[Id[i]]*dep[Id[i]]%mod)%mod;
}
signed main(){
	/*
    这一段是正常的读入和预处理
   */
	for(int i=1,opt,x,y,k;i<=m;i++){
		opt=read();
		if(opt==1){
			x=read()^lastans,y=read()^lastans,k=read();
			root[++cmt]=++tot;
			t[root[cmt]]=t[root[nowroot]];
			nowroot=cmt;
			t[root[nowroot]].nl=t[root[nowroot]].nr=1;//修改操作，要新建一棵树
			lca_(x,y,k);
		}
		else if(opt==2){
			x=read()^lastans,y=read()^lastans,k=Lca(x,y);
			lastans=lca_q(x,y,k);
			pf(lastans),putchar('\n');
		}
		else x=read()^lastans,nowroot=x;//回到对应的版本
	}
	return 0;
}
```



---

## 作者：Seauy (赞：6)

看见题解区全是树剖，实际上这题能用复杂度更优的全局平衡二叉树解决。

[题目链接](https://www.luogu.com.cn/problem/P7671)

题意：维护一棵带点权 $\{a_i\}$ 的树，修改是区间加，查询要求回答对于所有 $x\to y$ 路径上的点 $i$ 的 $\frac{s(s+1)}{2}a_i$ 之和，其中 $s$ 是 $i$ 到 $y$ 的距离，支持强制在线和可持久化。

首先推式子，不妨以结点 $1$ 为根，设 $z$ 是 $x,y$ 的最近公共祖先，对于 $z\to y$ 上的点，他们的贡献为

$$ \frac{1}{2}(d_y(d_y+1)\sum_{i} a_i-(2d_y+1)\sum_{i} d_ia_i+\sum_{i} d_i^2a_i)  $$

对于 $x\to z$ 上的点，他们的贡献为

$$ \frac{1}{2}((d_y-2d_z)(d_y-2d_z+1)\sum_{i} a_i+(2d_y-4d_z+1)\sum_{i} d_ia_i+\sum_{i} d_i^2a_i) $$

其中 $d_x$ 为结点 $x$ 的深度，过程略。容易发现我们需要维护出树上路径的 $\sum a_i,\sum d_ia_i,\sum d_i^2a_i$，我们知道在树结构静态的情况下维护路径信息的最优在线数据结构为全局平衡二叉树（[点击此处了解全局平衡二叉树](https://blog.csdn.net/ez_lcw/article/details/123574885)），考虑如何将其可持久化。

实际上全局平衡二叉树对于每条重链都用一棵静态平衡树来维护，平衡树上的信息可以套路化地 path copy，但是有 $O(n)$ 棵平衡树需要维护，每次查询平衡树需要调用平衡树的根，所以平衡树的根也需要可持久化地记录。如果使用可持久化数组，每次操作复杂度就退化为 $O(\log^2 n)$，考虑降低维护根的复杂度。

我们将每个重链的顶部拿出来，每个结点向他父亲所在重链的链顶连边，容易发现重链之间的关系形成了一棵高度不超过 $\lceil \log_2 n+1 \rceil$ 的树，可以简称为重链树。我们还不能对重链树 path copy（不使用 fat copy 因为复杂度也会退化），因为某个结点的儿子个数可能是 $O(n)$ 的，考虑改造这棵树的结构，使得重链之间的关系依然能被方便地表达，并且每个结点的儿子个数是 $O(1)$。

再次仿照全局平衡二叉树的构造策略，算出重链树每个结点的子树大小，对于每个结点的儿子集合建立平衡树，每次选取由子树大小决定的加权中位数作为根，这个结点再向平衡树的根连边。在这样建出来的新树中，每个结点最多有三个儿子，且每个结点的深度不超过 $2\lceil \log_2 n+1 \rceil$，其祖先集合包含了所有应当被操作的链顶。

于是我们对所有平衡树与被全局平衡过的重链树进行 path copy 就能将全局平衡二叉树可持久化，时间复杂度 $O((n+m)\log n)$，空间复杂度 $O(n+m\log n)$。

为了减小常数使用了标记永久化，平衡树空间应该开 $12$ 倍（修改操作的两个端点每个要跳 $2 \log_2 n$ 次，每层最多遍历两个平衡树结点，跳到同一条链后要修改 $4\log_2 n$ 个结点的信息），重链树空间开 $4$ 倍，实际应该远到不了这个上界。目前时空双最优解，但是代码实现繁琐无比！下面给个参考


```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN=1e5,inv2=10080251,MOD=20160501;
const int LOGN=18,BSIZ=MAXN+MAXN*12*LOGN,HSIZ=MAXN+MAXN*4*LOGN;

inline int Read()
{
	int res;char c;
	while(1) {c=getchar();if('0'<=c && c<='9') {res=c-'0';break;}}
	while(1) {c=getchar();if('0'<=c && c<='9') res=res*10+c-'0';else break;}
	return res;
}
void Print(int x)
{
	if(x<10) {putchar(x+'0');return;}
	int y=x/10;
	Print(y),putchar(x-10*y+'0');
}
inline int mul(int a,int b) {return 1ll*a*b%MOD;}
inline int plu(int a,int b)
{
	int res=a+b;
	if(res>=MOD) res-=MOD;
	return res;
}
inline int sub(int a,int b)
{
	int res=a-b;
	if(res<0) res+=MOD;
	return res;
}

int n,m,A[MAXN+5];
vector<int> Tree[MAXN+5],hct[MAXN+5];
int fa[MAXN+5],Size[MAXN+5],depth[MAXN+5],Head[MAXN+5],Mson[MAXN+5],sz[MAXN+5];
int lin[MAXN+5],qua[MAXN+5];
inline int LIN(int L,int R) {return sub(lin[R],lin[L-1]);}
inline int QUA(int L,int R) {return sub(qua[R],qua[L-1]);}

void CalMsg(int now)
{
	depth[now]=depth[fa[now]]+1;
	Size[now]=1;
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i];
		if(rear==fa[now]) continue;
		fa[rear]=now;
		CalMsg(rear);
		Size[now]+=Size[rear];
	}
}
void TCP(int now,int Top)
{
	Head[now]=Top;
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i];
		if(rear==fa[now]) continue;
		if(Size[rear]>Size[Mson[now]]) Mson[now]=rear;
	}
	if(Mson[now]) TCP(Mson[now],Top);
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i];
		if(rear==fa[now] || rear==Mson[now]) continue;
		TCP(rear,rear);
	}
}
inline int LCA(int a,int b)
{
	while(Head[a]!=Head[b])
	{
		if(depth[Head[a]]<depth[Head[b]]) swap(a,b);
		a=fa[Head[a]];
	}
	if(depth[a]<depth[b]) return a;
	return b;
}
void CalSZ(int now)
{
	sz[now]=1;
	for(int i=0;i<hct[now].size();i++) CalSZ(hct[now][i]),sz[now]+=sz[hct[now][i]];
}

int Lson[BSIZ+5],Rson[BSIZ+5];
int cnt[MAXN+5],sum[BSIZ+5][3],bstnum;
int LT[BSIZ+5],val[BSIZ+5];

int BuildBST(int L,int R)
{
	int mid=(Size[L]-Size[Mson[R]]+1)>>1;
	for(int i=L;1;i=Mson[i]) if(Size[L]-Size[Mson[i]]>=mid) {mid=i;break;}
	cnt[mid]=1;
	sum[mid][0]=A[mid];
	sum[mid][1]=mul(depth[mid],A[mid]);
	sum[mid][2]=mul(mul(depth[mid],depth[mid]),A[mid]);
	val[mid]=A[mid];
	if(L!=mid)
	{
		Lson[mid]=BuildBST(L,fa[mid]);
		cnt[mid]+=cnt[Lson[mid]];
		sum[mid][0]=plu(sum[mid][0],sum[Lson[mid]][0]);
		sum[mid][1]=plu(sum[mid][1],sum[Lson[mid]][1]);
		sum[mid][2]=plu(sum[mid][2],sum[Lson[mid]][2]);
	}
	if(mid!=R)
	{
		Rson[mid]=BuildBST(Mson[mid],R);
		cnt[mid]+=cnt[Rson[mid]];
		sum[mid][0]=plu(sum[mid][0],sum[Rson[mid]][0]);
		sum[mid][1]=plu(sum[mid][1],sum[Rson[mid]][1]);
		sum[mid][2]=plu(sum[mid][2],sum[Rson[mid]][2]);
	}
	return mid;
}
int bstroot[HSIZ+5],ori[MAXN+5],hctnum;
int hctroot[MAXN+5],Son[HSIZ+5][3],hctfa[MAXN+5];
int BuildHCT(int x,int L,int R)
{
	int mid=0,now;
	for(int i=L;i<=R;i++) mid+=sz[hct[x][i]];
	mid=(mid+1)>>1;
	for(int i=L;1;i++) {mid-=sz[hct[x][i]]; if(mid<=0) {mid=i,now=ori[hct[x][i]];break;}}
	if(L<mid) hctfa[Son[now][1]=BuildHCT(x,L,mid-1)]=now;
	if(mid<R) hctfa[Son[now][2]=BuildHCT(x,mid+1,R)]=now;
	return now;
}
void Build(int now)
{
	int Bot=now; while(Mson[Bot]) Bot=Mson[Bot];
	bstroot[ori[now]]=BuildBST(now,Bot);
	if(hct[now].empty()) return;
	hctfa[Son[ori[now]][0]=BuildHCT(now,0,hct[now].size()-1)]=ori[now];
	for(int i=0;i<hct[now].size();i++) Build(hct[now][i]);
}

int Plus(int a,int b,int QL,int QR,int v)
{
	int mid=depth[a],L=mid-cnt[Lson[a]],R=mid+cnt[Rson[a]];
	if(QR<L || R<QL) return b;
	int res=++bstnum,l=max(L,QL),r=min(R,QR);
	sum[res][0]=plu(sum[b][0],mul(r-l+1,v));
	sum[res][1]=plu(sum[b][1],mul(LIN(l,r),v));
	sum[res][2]=plu(sum[b][2],mul(QUA(l,r),v));
	LT[res]=LT[b];
	val[res]=val[b];
	if(QL<=L && R<=QR)
	{
		LT[res]=plu(LT[res],v);
		Lson[res]=Lson[b];
		Rson[res]=Rson[b];
		return res;
	}
	Lson[res]=Plus(Lson[a],Lson[b],QL,QR,v);
	if(QL<=mid && mid<=QR) val[res]=plu(val[res],v);
	Rson[res]=Plus(Rson[a],Rson[b],QL,QR,v);
	return res;
}

struct Triple
{
	int a,b,c;
	void operator += (const Triple &x) {a=plu(a,x.a),b=plu(b,x.b),c=plu(c,x.c);}
};
Triple GetSum(int a,int b,int QL,int QR)
{
	int mid=depth[a],L=mid-cnt[Lson[a]],R=mid+cnt[Rson[a]];
	if(QR<L || R<QL) return Triple{0,0,0};
	if(QL<=L && R<=QR) return Triple{sum[b][0],sum[b][1],sum[b][2]};
	int l=max(L,QL),r=min(R,QR);
	Triple res=Triple{mul(r-l+1,LT[b]),mul(LIN(l,r),LT[b]),mul(QUA(l,r),LT[b])};
	res+=GetSum(Lson[a],Lson[b],QL,QR);
	if(QL<=mid && mid<=QR) res+=Triple{val[b],mul(mid,val[b]),mul(mul(mid,mid),val[b])};
	res+=GetSum(Rson[a],Rson[b],QL,QR);
	return res;
}

int opl[MAXN+5],opr[MAXN+5];
int Excute(int a,int b,int v)
{
	if(!opl[a]) return b;
	int res=++hctnum;
	if(opl[a]>0) bstroot[res]=Plus(bstroot[a],bstroot[b],opl[a],opr[a],v);
	else bstroot[res]=bstroot[b];
	opl[a]=0;
	Son[res][0]=Excute(Son[a][0],Son[b][0],v);
	Son[res][1]=Excute(Son[a][1],Son[b][1],v);
	Son[res][2]=Excute(Son[a][2],Son[b][2],v);
	return res;
}
inline int Modify(int T,int a,int b,int v)
{
	for(int i=ori[Head[a]];i;i=hctfa[i]) opl[i]=-1;
	for(int i=ori[Head[b]];i;i=hctfa[i]) opl[i]=-1;
	while(Head[a]!=Head[b])
	{
		if(depth[Head[a]]<depth[Head[b]]) swap(a,b);
		opl[ori[Head[a]]]=depth[Head[a]];
		opr[ori[Head[a]]]=depth[a];
		a=fa[Head[a]];
	}
	if(depth[a]<depth[b]) swap(a,b);
	opl[ori[Head[a]]]=depth[b];
	opr[ori[Head[a]]]=depth[a];
	return Excute(hctroot[0],hctroot[T],v);
}
Triple Work(int a,int b)
{
	if(!opl[a]) return Triple{0,0,0};
	Triple res;
	if(opl[a]>0) res=GetSum(bstroot[a],bstroot[b],opl[a],opr[a]);
	else res=Triple{0,0,0};
	opl[a]=0;
	res+=Work(Son[a][0],Son[b][0]);
	res+=Work(Son[a][1],Son[b][1]);
	res+=Work(Son[a][2],Son[b][2]);
	return res;
}
inline Triple Query(int T,int a,int b)//(b,a]
{
	for(int i=ori[Head[a]];i;i=hctfa[i]) opl[i]=-1;
	while(Head[a]!=Head[b])
	{
		opl[ori[Head[a]]]=depth[Head[a]];
		opr[ori[Head[a]]]=depth[a];
		a=fa[Head[a]];
	}
	if(a!=b)
	{
		opl[ori[Head[a]]]=depth[b]+1;
		opr[ori[Head[a]]]=depth[a];
	}
	return Work(hctroot[0],hctroot[T]);
}

int main()
{
	n=Read(),m=Read();
	for(int i=1,u,v;i<n;i++)
	{
		u=Read(),v=Read();
		Tree[u].push_back(v);
		Tree[v].push_back(u);
	}
	for(int i=1;i<=n;i++) A[i]=Read();
	CalMsg(1),TCP(1,1);
	ori[1]=++hctnum;
	for(int i=2;i<=n;i++) if(Head[i]==i) hct[Head[fa[i]]].push_back(i),ori[i]=++hctnum;
	CalSZ(1),Build(1),bstnum=n;
	hctroot[0]=1;
	for(int i=1;i<=n;i++) lin[i]=plu(lin[i-1],i),qua[i]=plu(qua[i-1],mul(i,i));
	int now=0,T=0;
	for(int opt,x,y,z,delta,lst=0;m--;)
	{
		opt=Read();
		if(opt==1)
		{
			x=Read()^lst,y=Read()^lst,delta=Read();
			hctroot[++T]=Modify(now,x,y,delta);
			now=T;
		}
		else if(opt==2)
		{
			x=Read()^lst,y=Read()^lst;
			z=LCA(x,y);
			Triple res=Query(now,y,z);
			lst=plu(sub(mul(mul(depth[y],depth[y]+1),res.a),mul(2*depth[y]+1,res.b)),res.c);
			res=Query(now,x,fa[z]);
			int tmp=depth[y]-2*depth[z];
			lst=plu(lst,mul(mul(tmp,tmp+1),res.a));
			if(tmp>=0) lst=plu(lst,mul(2*tmp+1,res.b));
			else lst=plu(lst,mul(2*tmp+1+MOD,res.b));
			lst=mul(plu(lst,res.c),inv2);
			Print(lst),putchar('\n');
		}
		else now=Read()^lst;
	}
	return 0;
}
```

---

## 作者：Ebola (赞：6)

五年前写的题解，那时候洛谷题库还没有这个题……

### 简明题意

给你一棵 $n$ 个节点的树。你需要在线支持三种操作：

1. 将 $x$ 到 $y$ 路径上所有点的点权加 $k$

2. 退回到第 $x$ 次 $1$ 类操作的状态

3. 询问 $x$ 到 $y$ 路径上的点权的阶梯和之和（包括点 $x$，不包括点 $y$，若 $x=y$ 则答案为 $0$）

其中，若干个数（$a_1,a_2,...,a_n$）的“阶梯和之和”定义为：
$$
\sum_{i=1}^na_i\sum\limits_{j=1}^{n-i+1}j
$$

### 题解

毒瘤数据结构题，人均代码量应该是 6K 吧……

看一眼就应该知道是树链剖分套可持久化线段树，比较难想的就是线段树要维护什么、怎么维护

那么线段树维护的方式有很多，有一些做法是和方向有关，我就说一下我的与方向无关的做法

对于每个线段树节点，维护：子节点树上深度之和 $d$，子节点树上深度平方和 $d2$，子节点深度乘权值之和 $ds$，子节点深度平方乘权值之和 $d2s$，子节点权值之和 $s$，懒标记 $tag$。其中 $d$ 和 $d2$ 在一开始建树时就可以确定下来，不需要进行后续的维护操作，可持久化时直接继承即可。然后因为可持久化线段树不方便进行 pushdown 操作，那么我们这里采用标记永久化的方式来解决，还顺便降下了一些常数

上传操作是显然的，因为 $ds$、$d2s$、$s$ 都具有可加性，直接将两个子节点的对应信息加起来即可，由于标记永久化，要记得加上自己的懒标记对相关变量造成的影响

对于一个区间加 $k$ 的操作，那么在继承的基础上，$ds$ 要加 $k\times d$，$d2s$ 要加 $k\times d2$，$s$ 是常规操作就不说了，然后 $tag$ 要加 $k$（话说我 $tag$ 忘了继承，结果 debug 了半小时……）

那么怎么利用这些东西来得到询问的答案？

我们设 $x$ 到 $y$ 路径上一个点 $u$ 到 $y$ 的路径长度为 $dis_u$，那么，任意一个点 $u$ 对本次询问的贡献都是 $a_u\frac{dis_u(dis_u+1)}{2}$，这个除以 $2$ 好丑，我们先不管它，算完全部再统一除以 $2$。那么我们需要计算的就是 $a_udis_u(dis_u+1)$。

考虑 $lca(x,y)$ 左边的点，有 $dis_u=deep_u+deep_y-2deep_{lca}$，对于这一部分的点来说，$deep_y-2deep_{lca}$ 是一个常数，我们将它设为 $c$，并且先算出它来。于是我们要求的式子化为了 $a_u(deep_u+c)(deep_u+c+1)$，大力展开一下，就变成了 $a_udeep_u^2+a_udeep_u(2c+1)+a_u(c^2+c)$，那如果把一段区间的加起来，我们维护的 $d2s$、$ds$、$s$ 就可以直接用了

考虑 $lca(x,y)$ 右边的点，有 $dis_u=deep_y-deep_u$，对于这一部分的点来说，$deep_y$ 是一个常数，我们设为 $c$。于是我们要求的式子化为了 $a_u(c-deeo_u)(c-deep_u+1)$，大力展开：$a_udeep_u^2-a_udeep_u(2c+1)+a_u(c^2+c)$，计算方式和上面那个是一样的

最后答案记得要除以 $2$。然后……~~愉快地码吧~~

```cpp
#include<bits/stdc++.h>
#define ha 20160501
using namespace std;

namespace IO
{
	const int S=(1<<20)+5;
	//Input Correlation
	char buf[S],*H,*T;
	inline char Get()
	{
		if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
		if(H==T) return -1;return *H++;
	}
	inline int read()
	{
		int x=0;char c=Get();
		while(!isdigit(c)) c=Get();
		while(isdigit(c)) x=x*10+c-'0',c=Get();
		return x;
	}
	//Output Correlation
	char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr;
	inline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}
	inline void putc(char x){*oS++ =x;if(oS==oT) flush();}
	template <class I>inline void print(I x)
	{
		if(!x) putc('0');
		if(x<0) putc('-'),x=-x;
		while(x) qu[++qr]=x%10+'0',x/=10;
		while(qr) putc(qu[qr--]);
		putc('\n');
	}
}

typedef pair<int,int> pii;
using namespace IO;
const int N=100010;
struct Edge{int to,next;} e[N<<1];
int h[N],esum=0,n,m,val[N];
int fa[N],hson[N],top[N];
int size[N],dep[N];
int dfn[N],idx[N],clk=0;

void add_edge(int u,int v)
{
	e[++esum].to=v;
	e[esum].next=h[u];
	h[u]=esum;
}

void dfs1(int u,int la)
{
	size[u]=1;int mx=0;
	for(int tmp=h[u];tmp;tmp=e[tmp].next)
	{
		int v=e[tmp].to;
		if(v==la) continue;
		dep[v]=dep[u]+1;
		dfs1(v,u);fa[v]=u;
		size[u]+=size[v];
		if(size[v]>mx) mx=size[v],hson[u]=v;
	}
}

void dfs2(int u,int tp)
{
	top[u]=tp;idx[dfn[u]=++clk]=u;
	if(hson[u]) dfs2(hson[u],tp);
	for(int tmp=h[u];tmp;tmp=e[tmp].next)
		if(e[tmp].to!=fa[u]&&e[tmp].to!=hson[u])
			dfs2(e[tmp].to,e[tmp].to);
}

int deep[N<<5],deep2[N<<5],sum[N<<5];
int dsum[N<<5],d2sum[N<<5],tag[N<<5];
int root[N],lc[N<<5],rc[N<<5],tot=0,now=0,ptx=0;
struct TRD
{
	int a,b,c;
	TRD(int x=0,int y=0,int z=0):a(x),b(y),c(z){}
	friend TRD operator + (const TRD &x,const TRD &y){return TRD((x.a+y.a)%ha,(x.b+y.b)%ha,(x.c+y.c)%ha);}
};

inline void maintain(int o,int l,int r)
{
	sum[o]=(sum[lc[o]]+sum[rc[o]]+1ll*tag[o]*(r-l+1))%ha;
	dsum[o]=(dsum[lc[o]]+dsum[rc[o]]+1ll*tag[o]*deep[o])%ha;
	d2sum[o]=(d2sum[lc[o]]+d2sum[rc[o]]+1ll*tag[o]*deep2[o])%ha;
}

inline void copynode(int o,int p)
{
	sum[o]=sum[p];
	tag[o]=tag[p];
	deep[o]=deep[p];
	deep2[o]=deep2[p];
	dsum[o]=dsum[p];
	d2sum[o]=d2sum[p];
	lc[o]=lc[p];rc[o]=rc[p];
}

void Build(int &o,int l,int r)
{
	o=++tot;
	if(l==r)
	{
		sum[o]=val[idx[l]];
		deep[o]=dep[idx[l]];
		deep2[o]=1ll*deep[o]*deep[o]%ha;
		dsum[o]=1ll*deep[o]*sum[o]%ha;
		d2sum[o]=1ll*dsum[o]*deep[o]%ha;
		return;
	}
	int mid=(l+r)/2;
	Build(lc[o],l,mid);
	Build(rc[o],mid+1,r);
	maintain(o,l,r);
	deep[o]=(deep[lc[o]]+deep[rc[o]])%ha;
	deep2[o]=(deep2[lc[o]]+deep2[rc[o]])%ha;
}

void Modify(int &o,int pre,int l,int r,int nl,int nr,int k)
{
	if(!o) copynode(o=++tot,pre);
	if(l==nl&&r==nr)
	{
		sum[o]=(sum[o]+1ll*k*(nr-nl+1))%ha;
		dsum[o]=(dsum[o]+1ll*k*deep[o])%ha;
		d2sum[o]=(d2sum[o]+1ll*k*deep2[o])%ha;
		tag[o]=(tag[o]+k)%ha;
		return;
	}
	int mid=(l+r)/2;
	if(nr<=mid)
	{
		if(lc[o]==lc[pre]) lc[o]=0;
		Modify(lc[o],lc[pre],l,mid,nl,nr,k);
	}
	else if(nl>mid)
	{
		if(rc[o]==rc[pre]) rc[o]=0;
		Modify(rc[o],rc[pre],mid+1,r,nl,nr,k);
	}
	else
	{
		if(lc[o]==lc[pre]) lc[o]=0;
		Modify(lc[o],lc[pre],l,mid,nl,mid,k);
		if(rc[o]==rc[pre]) rc[o]=0;
		Modify(rc[o],rc[pre],mid+1,r,mid+1,nr,k);
	}
	maintain(o,l,r);
}

TRD Query(int o,int l,int r,int nl,int nr,int d)
{
	if(l==nl&&r==nr) return TRD((sum[o]+1ll*d*(r-l+1))%ha,(dsum[o]+1ll*d*deep[o])%ha,(d2sum[o]+1ll*d*deep2[o])%ha);
	int mid=(l+r)/2;d=(d+tag[o])%ha;
	if(nr<=mid) return Query(lc[o],l,mid,nl,nr,d);
	else if(nl>mid) return Query(rc[o],mid+1,r,nl,nr,d);
	else
	{
		TRD res1=Query(lc[o],l,mid,nl,mid,d);
		TRD res2=Query(rc[o],mid+1,r,mid+1,nr,d);
		return res1+res2;
	}
}

void PathModify(int u,int v,int d)
{
	ptx++;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		Modify(root[ptx],root[now],1,n,dfn[top[u]],dfn[u],d);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	Modify(root[ptx],root[now],1,n,dfn[u],dfn[v],d);
	now=ptx;
}

int getlca(int u,int v)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	return u;
}

int PathQuery(int u,int v)
{
	int lca=getlca(u,v),t2=dep[v];
	int t1=(dep[v]-2*dep[lca]+ha)%ha;
	int ans=0;TRD res;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]>=dep[top[v]])
		{
			res=Query(root[now],1,n,dfn[top[u]],dfn[u],0);
			ans=(ans+1ll*res.a*(1ll*t1*t1%ha+t1))%ha;
			ans=(ans+1ll*res.b*(2ll*t1+1)+res.c)%ha;
			u=fa[top[u]];
		}
		else
		{
			res=Query(root[now],1,n,dfn[top[v]],dfn[v],0);
			ans=(ans+1ll*res.a*(1ll*t2*t2%ha+t2))%ha;
			ans=(ans-1ll*res.b*(2ll*t2+1)%ha+res.c+ha)%ha;
			v=fa[top[v]];
		}
	}
	if(dep[u]>=dep[v])
	{
		res=Query(root[now],1,n,dfn[v],dfn[u],0);
		ans=(ans+1ll*res.a*(1ll*t1*t1%ha+t1))%ha;
		ans=(ans+1ll*res.b*(2ll*t1+1)+res.c)%ha;
	}
	else
	{
		res=Query(root[now],1,n,dfn[u],dfn[v],0);
		ans=(ans+1ll*res.a*(1ll*t2*t2%ha+t2))%ha;
		ans=(ans-1ll*res.b*(2ll*t2+1)%ha+res.c+ha)%ha;
	}
	return 10080251ll*ans%ha;
}

int main()
{
	int u,v,opt,x,y,d,lastans=0;
	n=read();m=read();
	for(int i=1;i<n;i++)
	{
		u=read();v=read();
		add_edge(u,v);
		add_edge(v,u);
	}
	for(int i=1;i<=n;i++) val[i]=read();
	dep[1]=1;dfs1(1,0);dfs2(1,1);
	Build(root[0],1,n);
	while(m--)
	{
		opt=read();x=read();
		if(opt==3) now=x^lastans;
		if(opt==1)
		{
			y=read();d=read();
			x^=lastans;
			y^=lastans;
			PathModify(x,y,d);
		}
		if(opt==2)
		{
			y=read();
			x^=lastans;
			y^=lastans;
			lastans=PathQuery(x,y);
			print(lastans);
		}
	}
	flush();
	return 0;
}
```

---

## 作者：TKXZ133 (赞：4)

[疯狂动物城](https://www.luogu.com.cn/problem/P7671)

### 题目大意

给定一颗 $n$ 个点的树，第 $i$ 个点的点权为 $a_i$，需要维护三种操作：

- 1.  $x$ 到 $y$ 路径加 $c$。

- 2.  查询 $x$ 到 $y$ 的路径权值，一条路径的权值被定义为

$$\sum_{i\in\text{road}(x,y)}a_i\times \frac{dis(i,y)(dis(i,y)+1)}{2}$$

其中，$\text{road}(x,y)$ 表示由 $x$ 到 $y$ 的路径上的点构成的集合，$dis(x,y)$ 表示 $x$ 到 $y$ 的距离。

- 3. 回退到某一版本。

### 思路分析

（以下记 $l=\text{lca}(x,y)$，$dep_i$ 表示点 $i$ 在以 $1$ 为根时的深度）

如果只看 $1,3$ 操作，我们可以用树链剖分套可持久化线段树比较轻松的完成，因此主要看 $2$ 操作。

我们发现 $a\times dis$ 不好处理，考虑将其转化为 $a\times dep$ 的形式：

首先可以将 $x$ 到 $y$ 的路径拆分成两部分，即 $x$ 到 $l$ （包含 $l$）和 $l$ 到 $y$（不包含 $l$），分别记这两部分为 $up$ 和 $down$。

那么 $dis(i,y),i\in up$ 就等于 $dep_i+dep_y-2dep_{l}$，同理，$dis(i,y),i\in down$ 就等于 $dep_y-dep_i$。

所以现在式子变成了这样：

$$\frac{1}{2}\Bigg(\sum_{i\in up}a_i(dep_i+dep_y-2dep_l)(dep_i+dep_y-2dep_l+1)\Bigg)+\frac{1}{2}\Bigg(\sum_{i\in down} a_i(dep_y-dep_i)(dep_y-dep_i+1)\Bigg)$$

再化简一下：

$$\begin{aligned}\frac{1}{2}\Bigg(&(dep_y^2+4dep_l^2-4dep_ydep_l+dep_y-2dep_l)\sum_{i\in up}a_i+(2dep_y-4dep_l+1)\sum_{i\in up}dep_ia_i+\sum_{i\in up}dep_i^2a_i+\\&(dep_y^2+dep_y)\sum_{i\in down}a_i+(-2dep_y-1)\sum_{i\in down}dep_ia_i+\sum_{i\in down} dep_i^2a_i\Bigg)\end{aligned}$$

这样不太好看，设 $c_1=dep_y-2dep_l,c_2=dep_y$，再因式分解一下就可以得到一个比较好看的式子：

$$\frac{1}{2}\Bigg((c_1^2+c_1)\sum_{i\in up}a_i+(2c_1+1)\sum_{i\in up}dep_ia_i+\sum_{i\in up}dep_i^2a_i+(c_2^2+c_2)\sum_{i\in down}a_i-(2c_2+1)\sum_{i\in down}dep_ia_i+\sum_{i\in down}dep_i^2a_i\Bigg)$$

我们发现，$c_1,c_2$ 都是常数，可以 $O(1)$ 计算，我们只需要在线段树上维护 $\sum a,\sum dep\times a,\sum dep^2\times a$ 就可以用树剖套线段树维护链查询和链加。

具体的说，当区间加 $k$ 时，观察三者的变化：

$$\begin{cases}\sum a\to\sum (a+k)=\sum a+k\sum 1\\\sum dep\times a\to\sum dep\times (a+k)=\sum dep\times a+k\sum dep\\\sum dep^2\times a\to \sum dep^2\times (a+k)=\sum dep^2\times a+k\sum dep^2\end{cases}$$

因此只需要额外再维护一个 $dep$ 和 $dep^2$  的前缀和就可以做到 $O(1)$ 更新区间，而区间查询只需要将所有值累加即可。

因为要支持回退版本，所以我们的线段树需要用可持久化线段树，但这会带来一个新的问题，当进行一次区间加时，我们会遍历到线段树上的 $O(\log n)$ 个区间，如果每一次都新建节点并下放区间加的懒标记，考虑到我们需要维护一堆东西，空间复杂度直接爆炸。

因此，我们可以采用标记永久化的方法，区间加时对每一个访问到的区间直接更新区间值，在当前区间被完全覆盖时直接给当前区间打上标记并停止，不进行下放懒标记操作和上传区间值操作；区间查询时对每个访问到的区间累加标记，在当前区间被完全覆盖时直接累加上当前节点的值。

我们发现，如果这样做的话，在区间加和区间查询时都不需要新建任何节点，只有生成一个新版本时需要消耗 $O(\log n)$ 的空间，而且常数较小，可以通过本题。

总时间复杂度为 $O(n\log ^2n)$，空间复杂度为 $O(n\log n)$。

### 代码

（只有 4.8k）

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;
const int N=200100,mod=20160501;
typedef long long ll;
#define mid ((l+r)>>1)
#define D(l,r) (d[r]-d[l-1]+mod)//dep 的前缀和
#define D2(l,r) (d2[r]-d2[l-1]+mod)//dep^2 的前缀和
#define Empty (PSTn{0,0,0,0,{0,0},{0,0}})
#define ls a[p].ch[0]
#define rs a[p].ch[1]

int n,m,idx=1,op,in1,in2,in3,cnt,nrt,num,tot;
int to[N],nxt[N],head[N],rt[N];
int dfn[N],rnk[N],dep[N],siz[N],fa[N],son[N],top[N];
ll d[N],d2[N],w[N],lastans;

void add(int u,int v){
    idx++;to[idx]=v;nxt[idx]=head[u];head[u]=idx;
}

struct PSTn{
    ll sa,sda,sd2a,tag;
    int ch[2];
    bool v[2];//v 表示是否需要新建子节点
};
struct PST{
    PSTn a[N<<5];
    void merge(PSTn &p,PSTn a,PSTn b){//将两个区间值累加进一个区间
        p.sa=(a.sa+b.sa)%mod;
        p.sda=(a.sda+b.sda)%mod;
        p.sd2a=(a.sd2a+b.sd2a)%mod;
    }
    void add_t(PSTn &p,int l,int r,ll k){//更新一个节点的值
        p.sa=(p.sa+k*(r-l+1)%mod)%mod;
        p.sda=(p.sda+k*D(l,r)%mod)%mod;
        p.sd2a=(p.sd2a+k*D2(l,r)%mod)%mod;
    }
    void built(int p,int f){//判断是否需要新建子节点
        if(!a[p].v[f]) return ;
        a[++tot]=a[a[p].ch[f]];a[p].ch[f]=tot;
        a[a[p].ch[f]].v[0]=a[a[p].ch[f]].v[1]=1;
        a[p].v[f]=0;
    }
    void build(int &p,int l,int r){
        p=++tot;
        if(l==r){
            int u=rnk[l];
            a[p].sa=w[u];
            a[p].sda=1ll*w[u]*dep[u]%mod;
            a[p].sd2a=1ll*(1ll*w[u]*dep[u]%mod)*dep[u]%mod;
            return ;//初始化
        }
        build(ls,l,mid);build(rs,mid+1,r);
        merge(a[p],a[ls],a[rs]);
    }
    void add(int p,int l,int r,int x,int y,ll k){
        add_t(a[p],max(l,x),min(r,y),k);
        if(x<=l&&r<=y){a[p].tag+=k;return ;}
        if(y<=mid){built(p,0),add(ls,l,mid,x,y,k);return ;}
        if(x>mid){built(p,1),add(rs,mid+1,r,x,y,k);return ;}
        built(p,0);built(p,1);add(ls,l,mid,x,y,k);add(rs,mid+1,r,x,y,k);
    }
    PSTn ask(int p,int l,int r,int x,int y,PSTn now){
        if(x<=l&&r<=y){merge(now,now,a[p]);return now;}//合并当前区间信息
        add_t(now,max(l,x),min(r,y),a[p].tag);//以此区间的标记对其进行更新
        if(y<=mid) return ask(ls,l,mid,x,y,now);
        if(x>mid) return ask(rs,mid+1,r,x,y,now);
        return ask(ls,l,mid,x,y,ask(rs,mid+1,r,x,y,now));
    }
}tree;

void dfs_1(int s,int gr){
    dep[s]=dep[gr]+1;
    siz[s]=1;fa[s]=gr;
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(v==gr) continue;
        dfs_1(v,s);
        siz[s]+=siz[v];
        if(siz[son[s]]<siz[v]) son[s]=v;
    }
}

void dfs_2(int s,int tp){
    top[s]=tp;dfn[s]=++cnt;rnk[cnt]=s;
    if(!son[s]) return ;
    dfs_2(son[s],tp);
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(v==fa[s]||v==son[s]) continue;
        dfs_2(v,v);
    }
}

int LCA(int x,int y){
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]>dep[y]?y:x;
}

void add_all(int x,int y,int k){
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        tree.add(rt[nrt],1,n,dfn[top[x]],dfn[x],k);
        x=fa[top[x]];
    }
    tree.add(rt[nrt],1,n,min(dfn[x],dfn[y]),max(dfn[x],dfn[y]),k);
}

void update(ll &ans,int &x,ll c,int sign,int l,int r){//更新答案
    PSTn now=tree.ask(rt[nrt],1,n,dfn[l],dfn[r],Empty);
    ans=(ans+now.sa*(c*c%mod+c)%mod)%mod;
    ans=(ans+sign*now.sda*(2*c+1)%mod+now.sd2a+mod)%mod;
}

ll ask_all(int x,int y){
    int lca=LCA(x,y);
    ll ans=0,c1=(dep[y]-2*dep[lca]+mod)%mod,c2=dep[y];//计算常数
    while(top[x]!=top[y]){
        if(dep[top[x]]>dep[top[y]]){update(ans,x,c1,1,top[x],x);x=fa[top[x]];}
        else{update(ans,y,c2,-1,top[y],y);y=fa[top[y]];}
    }
    if(dep[x]>=dep[y]) update(ans,x,c1,1,y,x);
    else update(ans,y,c2,-1,x,y);
    return ans*((mod+1)/2)%mod;//最后要乘 2 的逆元
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++){
        scanf("%d%d",&in1,&in2);
        add(in1,in2);add(in2,in1);
    }
    for(int i=1;i<=n;i++) scanf("%lld",&w[i]);
    dfs_1(1,0);dfs_2(1,1);
    for(int i=1;i<=n;i++){
        d[i]=(d[i-1]+dep[rnk[i]])%mod;//注意，dep 的前缀和是在 dfs 序上累加的
        d2[i]=(d2[i-1]+1ll*dep[rnk[i]]*dep[rnk[i]]%mod)%mod;
    }
    tree.build(rt[0],1,n);
    while(m--){
        scanf("%d",&op);
        if(op==1){
            scanf("%d%d%d",&in1,&in2,&in3);
            in1^=lastans;in2^=lastans;
            rt[++num]=++tot;//生成一个新版本
            tree.a[rt[num]]=tree.a[rt[nrt]];//继承上一个版本
            nrt=num;
            tree.a[rt[nrt]].v[0]=tree.a[rt[nrt]].v[1]=1;//子节点需要新建
            add_all(in1,in2,in3);
        }
        if(op==2){
            scanf("%d%d",&in1,&in2);
            in1^=lastans;in2^=lastans;
            cout<<(lastans=ask_all(in1,in2))<<'\n';
        }
        if(op==3){
            scanf("%d",&in1);
            in1^=lastans;
            nrt=in1;
        }
    }
    return 0;
}
```

---

## 作者：XZhuRen (赞：4)

奶题，**但是不好写**。

读题，题目让我们求的是 ${\large \frac{1}{2}  \sum_{u \in road(x,y)} dis(u,y)\cdot (dis(u,y)-1)\cdot w_{u} }$。

由于路径可以拆成 $x-lca(x,y),lca(x,y)-y$ 的形式，所以改写为两部分：

记 $D=dep_{y},T=-2dep_{lca(x,y)}+dep_{y}$。

且以路径上任何的 $dep_{u}$ 简写为 $d$，$w_{u}$ 简写为 $w$。

${res_{u - lca}= \large (\sum{w})\cdot (D\cdot D+D)+(\sum{w\cdot d^{2}})+(\sum{w\cdot d})\cdot (-2D-1)}$

${res_{lca - v}= \large (\sum{w})\cdot (T\cdot T + T)+(\sum{w\cdot d^{2}})+(\sum{w\cdot d})\cdot (2T+1)}$

所以这个值除了本次询问的常数，只需要知道三个信息，即 $\sum{w_{u}},\sum{w_{u}\cdot dep_{u},\sum{w_{u}\cdot {dep_{u}}^{2}}}$。

因为树的形状不变，每个节点的 $dep$ 也不变，发现加减 $w_{u}$ 的时候，这三个值和 $u$ 成线性关系变化，所以直接大力树剖维护即可。

复杂度 $\mathcal{O}(n\log_{2}n)$，容易发现这样写常数略大。

所以这样优化：

首先要标记永久化。

类比历史线段树的方法，在每次修改的时候记录当前节点所最后更新的版本。

我们每个版本会有 $\mathcal{O}(\log_{2}n)$ 次更新，记录这个可以减小大量空间常数，对于同一版本只要直接覆盖即可，不用新建节点。

我写的线段树部分把答案打包成 `struct` 了，方便询问。

以下是线段树部分代码，全代码就不放了。

注意 `pushup()` 的时候不要忘了加上当前标记的贡献。

这样比较容易写，不用每条链单开一棵树，且提交后空间也只有 $392MB$，不用卡空间，应该还算优秀。


```cpp
struct Data{
	ll1 sumw,sumwd,sumwd2;
	ll1 len,sumd,sumd2;
	Data operator *(const Data dt)const{
		Data d3;
		d3.sumw=(sumw+dt.sumw)%mod;
		d3.sumwd=(sumwd+dt.sumwd)%mod;
		d3.sumwd2=(sumwd2+dt.sumwd2)%mod;
		d3.len=len+dt.len;
		d3.sumd=(sumd+dt.sumd)%mod;
		d3.sumd2=(sumd2+dt.sumd2)%mod;
		return d3;
	}
	void operator +=(const ll1 x){
		(sumw+=x*len%mod)%=mod;
		(sumwd+=x*sumd%mod)%=mod;
		(sumwd2+=x*sumd2%mod)%=mod;
	}
	void operator *=(const Data dt){
		(sumw+=dt.sumw)%=mod,
		(sumwd+=dt.sumwd)%=mod,
		(sumwd2+=dt.sumwd2)%=mod,
		len+=dt.len;
		(sumd+=dt.sumd)%=mod,
		(sumd2+=dt.sumd2)%=mod;
	}
};
namespace xds{
	Data Res[N*200];
	ll1 adt[N*200];
	int nowv[N*200];
	int lson[N*200],rson[N*200];
	int totn=0;
	#define ls lson[o]
	#define rs rson[o]
	#define mid ((l+r)>>1)
	void pushup(int o){Res[o]=Res[ls]*Res[rs];Res[o]+=adt[o];}
	int build(int l,int r){
		int o=++totn;
		Res[o]=(Data){0,0,0,0,0,0};
		lson[o]=rson[o]=adt[o]=nowv[o]=0;
		if(l==r){
			int i=dfns[l];
			Res[o]=(Data){a[i],1ll*a[i]*d[i]%mod,1ll*a[i]*d[i]%mod*d[i]%mod,1,d[i],1ll*d[i]*d[i]%mod};
			return o;
		}
		ls=build(l,mid);rs=build(mid+1,r);
		pushup(o);
		return o;
	}
	int modify(int R,int lt,int rt,int l,int r,ll1 x,int version){
		int o=version==nowv[R]?R:++totn;//同版本不用新建（卡空间用）
		Res[o]=Res[R];lson[o]=lson[R],rson[o]=rson[R];
		adt[o]=adt[R];nowv[o]=version;//版本号
		if(l>=lt&&r<=rt){
			Res[o]+=x;(adt[o]+=x)%=mod;
			return o;
		}
		if(lt<=mid)ls=modify(ls,lt,rt,l,mid,x,version);
		if(rt>mid)rs=modify(rs,lt,rt,mid+1,r,x,version);
		pushup(o);
		return o;
	}
	Data query(int o,int lt,int rt,int l,int r){
		if(l>=lt&&r<=rt)return Res[o];
		Data res=(Data){0,0,0,0,0,0};
		if(lt<=mid)res*=query(ls,lt,rt,l,mid);
		if(rt>mid)res*=query(rs,lt,rt,mid+1,r);
		if(adt[o])res+=adt[o];
		return res;
	}
}
```

---

## 作者：CQ_Bab (赞：2)

# 前言
也是吃上~~史~~了。
# 思路
首先考虑推式子，首先考虑分类讨论我们把路径分为 $x\to lca$ 与 $lca\to y$ 两条。

对于第一条路径 $x\to lca$。
$$
\begin{aligned}
&\sum a_i\times dis_{i,y}\times (dis_{i,y}+1) \div 2\\
=&\sum a_i\times (dep_i+dep_y-dep_{lca}\times 2)\times (dep_i+dep_y-dep_{lca}\times 2+1)\div 2\\
=&\frac{1}{2} \sum a_i\times ((dep_i+dep_y-dep_{lca}\times 2)^2+dep_i+dep_y-2\times dep_{lca})\\
=&\frac{1}{2}\sum a_i\times ({dep_i}^2+{dep_y}^2+2\times dep_i\times dep_{y}-4\times dep_i\times dep_{lca}-4\times dep_y\times dep_{lca}+4\times (dep_{lca})^2+dep_i+dep_y-2\times dep_{lca})\\
=&\frac{1}{2}(\sum a_i\times {dep_i}^2+\sum a_i\times dep_i\times (2\times dep_y-4\times dep_{lca})+\sum a_i\times ({dep_{y}}^2+4\times {dep_{lca}}^2-4\times dep_y\times dep_{lca}+dep_y-2\times dep_{lca})\\
=&\frac{1}{2}(\sum a_i\times {dep_i}^2+\sum a_i\times dep_i\times 2k+\sum a_i\times (k^2+k)) 
\end{aligned}
$$

其中 $k=dep_y-2\times dep_{lca}$。

对于另一条 $lca\to y$ 的路径。

$$
\begin{aligned}
&\frac{1}{2}\sum a_i\times ((dep_y-dep_i)^2+dep_y-dep_i)\\
=&\frac{1}{2}\sum a_i\times ({dep_y}^2+{dep_i}^2-2\times dep_i\times dep_y+dep_y-dep_i)\\
=&\frac{1}{2}(\sum a_i\times ({dep_y}^2-dep_y)+\sum a_i\times {dep_i}^2-\sum a_i\times dep_i\times (2\times dep_y+1))
\end{aligned}
$$

然后我们发现只用维护 $\sum a_i,\sum a_i\times dep_i,\sum a_i\times {dep_i}^2$ 即可，直接上线段树就行了，但是我们发现还有历史版本所以需要主席树又因为是区间修改所以要标记永久化，有因为是修改树上的一条路径所以需要树剖，码量还是比较大的。

注意：因为这道题要强制在线所以如果你答案是错误的可能会返回神奇的结果，可能是 MLE 或者 RE 之类的结果，不要和作者一样傻傻的更改数组大小半天。
# 代码
细节将代码。
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define ll long long
#define int long long
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    int f = 1;
    while (ch < '0' || ch > '9') {if(ch=='-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
    x *= f;
}
int T=1;
const int mod=20160501;
const int N=1e5+10;
int dfn[N],val[N];
int a[N],n,m,dep[N];
vector<int>v[N];
int top[N],son[N],siz[N];
struct node{
	int l,r;
	ll tag;
	ll sa,sd,sdd;
	int v[2];
}tr[N*310];
int rt[N],idx1;
ll d[N],dd[N];
int idx,fat[N];
void up(int x,int l,int r) {
	tr[x].sa=(tr[tr[x].l].sa+tr[tr[x].r].sa+tr[x].tag*(r-l+1))%mod;
	tr[x].sd=(tr[tr[x].l].sd+tr[tr[x].r].sd+tr[x].tag*(d[r]-d[l-1])%mod)%mod;
	tr[x].sdd=(tr[tr[x].l].sdd+tr[tr[x].r].sdd+tr[x].tag*(dd[r]-dd[l-1])%mod)%mod;
}
int lca(int x,int y) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fat[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return x;
}
int modify(int u,int l,int r,int l1,int r1,ll k) {
	int p=++idx;
	tr[p]=tr[u];
	if(l>=l1&&r<=r1) {
		tr[p].tag+=k;
		tr[p].sa+=1ll*k*(r-l+1)%mod;
		tr[p].sd+=1ll*k*(d[r]-d[l-1])%mod;
		tr[p].sdd+=1ll*k*(dd[r]-dd[l-1])%mod;
		return p;
	}
	int mid=l+r>>1;
	if(mid>=l1) tr[p].l=modify(tr[u].l,l,mid,l1,r1,k);
	if(mid<r1) tr[p].r=modify(tr[u].r,mid+1,r,l1,r1,k);
	up(p,l,r);
	return p;
}
void dfs(int x,int fa) {
	dep[x]=dep[fa]+1;
	siz[x]=1;
	fat[x]=fa;
	for(auto to:v[x]) {
		if(to==fa) continue;
		dfs(to,x);
		siz[x]+=siz[to];
		if(siz[to]>siz[son[x]]) son[x]=to;
	}
}
void dfs1(int x,int head) {
	top[x]=head;
	dfn[x]=++idx1;
	val[idx1]=a[x];
	d[idx1]=dep[x];
	dd[idx1]=dep[x]*dep[x];
	if(!son[x]) return;
	dfs1(son[x],head);
	for(auto to:v[x]) {
		if(!dfn[to]) dfs1(to,to);
	}
}
void gai(int x,int y,ll k,int t) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		rt[t]=modify(rt[t],1,n,dfn[top[x]],dfn[x],k);
		x=fat[top[x]];
	}
	if(dfn[x]>dfn[y])swap(x,y);
	rt[t]=modify(rt[t],1,n,dfn[x],dfn[y],k);
}
ll Ans(int u,int l,int r,int k) {
	if(l==r) return tr[u].sa;
	ll res=tr[u].tag;
	int mid=l+r>>1;
	if(mid>=k) res+=Ans(tr[u].l,l,mid,k);
	else res+=Ans(tr[u].r,mid+1,r,k);
	return res;
}
ll Ansa(int u,int l,int r,int l1,int r1) {
	if(l>=l1&&r<=r1) {
		return tr[u].sa;
	}
	ll res=1ll*tr[u].tag*(min(r,r1)-max(l,l1)+1)%mod;
	int mid=l+r>>1;
	if(mid>=l1) res+=Ansa(tr[u].l,l,mid,l1,r1);
	if(mid<r1) res+=Ansa(tr[u].r,mid+1,r,l1,r1);
	return res;
}
ll Ansdd(int u,int l,int r,int l1,int r1) {
	if(l1<=l&&r<=r1) {
		return tr[u].sdd;
	}
	int res=1ll*tr[u].tag*(dd[min(r,r1)]-dd[max(l,l1)-1])%mod;
	int mid=l+r>>1;
	if(mid>=l1) res+=Ansdd(tr[u].l,l,mid,l1,r1);
	if(mid<r1) res+=Ansdd(tr[u].r,mid+1,r,l1,r1);
	return res;
}
ll Ansd(int u,int l,int r,int l1,int r1) {
	int res=1ll*tr[u].tag*(d[min(r,r1)]-d[max(l,l1)-1])%mod;
	if(l1<=l&&r<=r1) {
		return tr[u].sd;
	}
	int mid=l+r>>1;
	if(mid>=l1) res+=Ansd(tr[u].l,l,mid,l1,r1);
	if(mid<r1) res+=Ansd(tr[u].r,mid+1,r,l1,r1);
	return res;
}
int qmi(int x,int y) {
	int res=1;
	while(y) {
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}
ll get(int x,int y,ll k,int t) {
	ll res=0;
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=(Ansdd(rt[t],1,n,dfn[top[x]],dfn[x])+(2*k+1)%mod*Ansd(rt[t],1,n,dfn[top[x]],dfn[x])%mod+Ansa(rt[t],1,n,dfn[top[x]],dfn[x])*(k*k%mod+k)%mod)%mod;
		res%=mod;
		x=fat[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	res+=(Ansdd(rt[t],1,n,dfn[x],dfn[y])+(2*k+1)%mod*Ansd(rt[t],1,n,dfn[x],dfn[y])%mod+Ansa(rt[t],1,n,dfn[x],dfn[y])*(k*k%mod+k)%mod)%mod;
	return res;
}
ll get1(int x,int y,int t,int yy) {
	ll res=0;
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=Ansa(rt[t],1,n,dfn[top[x]],dfn[x])*(dep[yy]*dep[yy]%mod+dep[yy])%mod-Ansd(rt[t],1,n,dfn[top[x]],dfn[x])*(2*dep[yy]+1)%mod+Ansdd(rt[t],1,n,dfn[top[x]],dfn[x])%mod;
		res%=mod;
		x=fat[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	res+=Ansa(rt[t],1,n,dfn[x],dfn[y])*(dep[yy]%mod*dep[yy]%mod+dep[yy])%mod-Ansd(rt[t],1,n,dfn[x],dfn[y])*(2*dep[yy]+1)%mod+Ansdd(rt[t],1,n,dfn[x],dfn[y])%mod;
	return res;
}
void build(int &u,int l,int r) {
	u=++idx;
	if(l==r) {
		tr[u].sa=val[l];
		tr[u].sd=(d[r]-d[l-1])*val[l]%mod;
		tr[u].sdd=(dd[r]-dd[l-1])*val[l]%mod;
		return;
	}
	int mid=l+r>>1;
	build(tr[u].l,l,mid);
	build(tr[u].r,mid+1,r);
	up(u,l,r);
}
int cnt[N];
void solve() {
	in(n),in(m);
	rep(i,1,n-1) {
		int x,y;
		in(x),in(y);
		v[x].pb(y);
		v[y].pb(x);
	} 
	rep(i,1,n) in(a[i]);
	dfs(1,0);
	dfs1(1,1);
	ll lst=0;
	rep(i,1,n) d[i]=(d[i-1]+d[i])%mod,dd[i]+=dd[i-1],dd[i]%=mod;
	int tim=false;
	build(rt[0],1,n);
	int nxt=-1;
	rep(io,1,m) {
		int opt;
		in(opt);
		if(opt==1) {
			int x,y,a;
			in(x),in(y),in(a);
			x=x^lst;
			y=y^lst;
			++tim;
			if(nxt!=-1) rt[tim]=rt[nxt],nxt=-1;
			else rt[tim]=rt[tim-1];
			gai(x,y,a,tim);
		}else if(opt==2) {
			int x,y;
			in(x),in(y);
			int res=0;
			x=x^lst;
			y=y^lst;
			int lc=lca(x,y);
			int now=tim;
			if(nxt!=-1) now=nxt;
			lst=(get(x,lc,dep[y]-dep[lc]*2,now)+get1(lc,y,now,y))%mod*((mod+1)/2)%mod;
			lst=((lst-Ans(rt[now],1,n,dfn[lc])*((dep[lc]+dep[y]-2*dep[lc])*(dep[y]-dep[lc]+1)/2)%mod)%mod+mod)%mod;
			printf("%lld\n",lst);
		}else {
			int x;
			in(x);
			x^=lst;
			nxt=x;
		}
	}
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```
行稳致远。

---

## 作者：Hoks (赞：2)

## 前言
重剖题单里的，闲暇的时候刷到的推式子好题，挺好玩的。

做着题前推荐先做下 [P9808 [POI2022~2023R1] zbo](https://www.luogu.com.cn/problem/P9808) 和 [P4211 [LNOI2014] LCA](https://www.luogu.com.cn/problem/P4211)。

先练习了解下经典式子的拆法，再来试试这题吧。

~~有个傻逼式子抄错了半天没推出来我不说是谁。~~

## 题意分析

首先说下题意中我理解错的地方，**能量石在生产之后是不会消耗的，能一直解救动物**。

所以这种题写前最好看下形式化题意对下题意理解是否有问题。

其他部分暂且不考虑，先看题目中又臭又长的那串式子：

$$\sum\limits_{i \in x\rightarrow y}\!{a_i}\times\dfrac{\operatorname{dis}(i,y)(\operatorname{dis}(i,y)+1)}{2}$$

在这里，我们发现了一个很熟悉的部分，$\operatorname{dis}(i,y)$。

像这样的树上两点距离，肯定是要无脑的给他拆成 $dep_i+dep_y-2\times dep_{\operatorname{LCA}(i,y)}$。

然后把这部分拆开看看，再把 $\dfrac{1}{2}$ 提到前面去，就得到了：

$$\dfrac{1}{2}\sum\limits_{i \in x\rightarrow y}\!{a_i}\times(dep_i+dep_y-2\times dep_{\operatorname{LCA}(i,y)})(dep_i+dep_y-2dep_{\operatorname{LCA}(i,y)}+1)$$

欸，这式子怎么越化越复杂了，难道要全部拆开吗？

显然不是的，我们发现这里的 $\operatorname{dis}(i,y)$ 有一个与其他推式子题不一样的特性，就是其中的 $y$ 点是已经给定的。

又因为 $i$ 是 $x\rightarrow y$ 路径上的点，所以当 $i$ 是 $\operatorname{LCA}(x,y)\rightarrow x$ 的那一段时，$\operatorname{LCA}(i,y)$ 就是 $\operatorname{LCA}(x,y)$。

同理的考虑当 $i$ 是 $\operatorname{LCA}(x,y)\rightarrow y$ 的那一段时，$\operatorname{LCA}(i,y)$ 就是 $i$。

这下式子就有着美妙的性质了，再考虑下按照这两个部分给他化开。

下面式子中用 $lca$ 表示 $\operatorname{LCA}(x,y)$。 

1. 当 $i\in lca\rightarrow x$ 时，式子即为：

$$\dfrac{1}{2}\sum\limits_{i\in lca\rightarrow x}\!{a_i}\times(dep_i+dep_y-2dep_{lca})(dep_i+dep_y-2dep_{lca}+1)$$

观察到 $dep_y-2\times dep_{lca}$ 是个定值，直接用 $s_1$ 来表示他，就得到了：

$$\dfrac{1}{2}\sum\limits_{i\in lca\rightarrow x}\!{a_i}\times(dep_i+s_1)(dep_i+s_1+1)$$

再接一步大力展开：

$$\dfrac{1}{2}\sum\limits_{i\in lca\rightarrow x}\!{a_i}\times((dep_i+s_1)^2+(dep_i+s_1))$$

$$\dfrac{1}{2}\sum\limits_{i\in lca\rightarrow x}\!{a_i}\times(dep_i^2+2s_1dep_i+s_1^2+dep_i+s_1)$$

最后把求和也给展开，就得到了：

$$\dfrac{1}{2}\left[\sum\limits_{i\in lca\rightarrow x}{a_idep_i^2}+\sum\limits_{i\in lca\rightarrow x}{a_idep_i\left(2s_1+1\right)}+\sum\limits_{i\in lca\rightarrow x}{a_i\left(s_1^2+s_1\right)}\right]$$

2. 当 $i\in lca\rightarrow y$ 时，式子即为：

$$\dfrac{1}{2}\sum\limits_{i\in lca\rightarrow y}\!{a_i}\times(dep_i+dep_y-2dep_i)(dep_i+dep_y-2dep_i+1)$$

$$\dfrac{1}{2}\sum\limits_{i\in lca\rightarrow y}\!{a_i}\times(dep_y-dep_i)(dep_y-dep_i+1)$$

发现其中的 $dep_y$ 为不变量，用 $s_2$ 代入展开得：

$$\dfrac{1}{2}\sum\limits_{i\in lca\rightarrow y}\!{a_i}\times(s_2^2-2dep_is_2+dep_i^2+s_2-dep_i)$$

最后再展开下求和就得到了：

$$\dfrac{1}{2}\left[\sum\limits_{i\in lca\rightarrow y}{a_idep_i^2}-\sum\limits_{i\in lca\rightarrow y}{a_idep_i\left(2s_2+1\right)}+\sum\limits_{i\in lca\rightarrow y}{a_i\left(s_2^2+s_2\right)}\right]$$

至此，最艰难的一步就完成了。

然后再去看题面中其他的部分，因为有版本回溯，所以直接大力上一颗主席树。

对于链加，直接标记永久化即可。

主席树上维护三个值，分别是正常的点权和，乘上 $dep$ 的点权合和乘上 $dep^2$ 的点权和。

接着大力维护即可，详情见代码了，有关变量部分有些许解释。

## 代码
```cpp
#include <bits/stdc++.h>
#define ls (t[p].l)
#define rs (t[p].r)
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=100010,INF=0x3f3f3f3f3f3f3f3f,mod=20160501;
struct edge
{int v,nxt;}e[N<<1];
struct tree
{
	int s,ss,sss,tag,l,r,v[2];
	//s正常点权，ss乘上一个dep，sss乘上两个dep
	//l，r代表的是左右儿子，不写ls，rs是因为我上面宏定义会冲突。
	//tag是修改的值的大小，v[0/1]代表左/右儿子是否需要修改
	tree(){s=ss=sss=l=r=tag=v[0]=v[1]=0;}
}t[N<<6];//经典主席树空间
int n,m,cnt,tot,root,lst,idx;
//cnt是dfn序的，tot是链式前向星的，root是主席树的根，lst是上次答案，idx是主席树版本号
int head[N],dfn[N],id[N],top[N];
int fa[N],si[N],son[N],dep[N];//树剖，不解释
int a[N],rt[N],s[N],ss[N];//a是点权，rt是根，s是乘上dep的点权，ss是乘上两个dep的点权
static char buf[1000000],*paa=buf,*pd=buf;
//#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline int read(void){
    int x(0),t(1);char fc(getchar());
    while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
    while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
    if(fc=='.'){fc=getchar();while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();}
    return x*t;
}
inline void print(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+'0');
}
inline void add(int u,int v){e[++tot].v=v,e[tot].nxt=head[u],head[u]=tot;}
inline void dfs1(int u,int ff)
{
	fa[u]=ff,dep[u]=dep[ff]+1,si[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==ff) continue;
		dfs1(v,u);si[u]+=si[v];
		if(si[v]>si[son[u]]) son[u]=v;
	}
}
inline void dfs2(int u,int topf)
{
	top[u]=topf,dfn[u]=++cnt,id[cnt]=u;
	if(son[u]) dfs2(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
inline tree operator+(tree a,tree b)
{
	tree c;
	c.s=(a.s+b.s)%mod;
	c.ss=(a.ss+b.ss)%mod;
	c.sss=(a.sss+b.sss)%mod;
	return c;
}
inline int calcs(int l,int r){return s[r]-s[l-1]+mod;}
inline int calcss(int l,int r){return ss[r]-ss[l-1]+mod;}
inline void build(int &p,int l,int r)
{
	p=++cnt;
	if(l==r)
	{
		int x=id[l];
		t[p].s=a[x]%mod;
		t[p].ss=a[x]*dep[x]%mod;
		t[p].sss=a[x]*dep[x]*dep[x]%mod;
		return;
	}
	build(ls,l,mid);build(rs,mid+1,r);
	t[p].s=(t[ls].s+t[rs].s)%mod;
	t[p].ss=(t[ls].ss+t[rs].ss)%mod;
	t[p].sss=(t[ls].sss+t[rs].sss)%mod;
}
inline void pushup(tree &p,int l,int r,int k)
{
	p.s=(p.s+k*(r-l+1)%mod)%mod;
	p.ss=(p.ss+k*calcs(l,r)%mod)%mod;
	p.sss=(p.sss+k*calcss(l,r)%mod)%mod;
}
inline int copy(int p){t[++cnt]=t[p];return cnt;}
inline void modify(int p,int l,int r,int st,int ed,int k)
{
	pushup(t[p],max(l,st),min(r,ed),k);
	if(st<=l&&r<=ed) return void(t[p].tag=(t[p].tag+k)%mod);
	if(st<=mid)
	{
		if(t[p].v[0]) ls=copy(ls),t[ls].v[0]=1,t[ls].v[1]=1,t[p].v[0]=0;
		modify(ls,l,mid,st,ed,k);
	}
	if(mid<ed)
	{
		if(t[p].v[1]) rs=copy(rs),t[rs].v[0]=1,t[rs].v[1]=1,t[p].v[1]=0;
		modify(rs,mid+1,r,st,ed,k);
	}
}
inline tree query(int p,int l,int r,int st,int ed)
{
	if(st<=l&&r<=ed) return t[p];tree res;
	pushup(res,max(l,st),min(r,ed),t[p].tag);
	if(st<=mid) res=res+query(ls,l,mid,st,ed);
	if(mid<ed) res=res+query(rs,mid+1,r,st,ed);
	return res;
}
inline int LCA(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return x;
}
inline void modify(int x,int y,int k)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		modify(rt[root],1,n,dfn[top[x]],dfn[x],k);
		x=fa[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	modify(rt[root],1,n,dfn[x],dfn[y],k);
}
inline int query(int c,int op,int l,int r)
{
	tree res=query(rt[root],1,n,l,r);
	return (res.sss+(op*res.ss*(c*2+1))%mod+res.s*((c*c)%mod+c)+mod)%mod;
}
inline int query(int x,int y)
{
	int lca=LCA(x,y),s1=(dep[y]-dep[lca]*2+mod)%mod,s2=dep[y],res=0;
	while(top[x]!=top[y])
		if(dep[top[x]]<=dep[top[y]]) res=(res+query(s2,-1,dfn[top[y]],dfn[y]))%mod,y=fa[top[y]];
		else res=(res+query(s1,1,dfn[top[x]],dfn[x]))%mod,x=fa[top[x]];
	if(dep[x]>=dep[y]) res=(res+query(s1,1,dfn[y],dfn[x]))%mod;
	else res=(res+query(s2,-1,dfn[x],dfn[y]))%mod;
	return res*((mod+1)/2)%mod;
}
signed main()
{
	n=read(),m=read();
	for(int i=1,u,v;i<n;i++) u=read(),v=read(),add(u,v),add(v,u);
	for(int i=1;i<=n;i++) a[i]=read();dfs1(1,0),dfs2(1,1);
	for(int i=1;i<=n;i++) s[i]=(s[i-1]+dep[id[i]])%mod,ss[i]=(ss[i-1]+dep[id[i]]*dep[id[i]])%mod;
	build(rt[0],1,n);
	for(int i=1,op,x,y,k;i<=m;i++)
	{
		op=read(),x=read()^lst;
		if(op==1)
		{
			y=read()^lst;k=read();rt[++idx]=++cnt;
			t[rt[idx]]=t[rt[root]];root=idx;
			t[rt[root]].v[0]=t[rt[root]].v[1]=1;
			modify(x,y,k);
		}
		else if(op==2) y=read()^lst,print((lst=query(x,y))),puts("");
		else root=x;
	}
	return 0;
}
```

---

## 作者：AC_love (赞：1)

注意到：$1, 3$ 操作直接上树剖 + 可持久化线段树即可，关键是如何处理 $2$ 操作。

$(x, y)$ 路径上的点 $i$ 到 $y$ 的距离为 $s$，则这个点对答案的贡献为 $\sum_{k = 1}^s k \times a_i$，也就是 $\dfrac{s(s + 1)}{2} \times a_i$。

我们要求的就是：

$$\sum_{i \in (x, y)} \dfrac{dis(i, y) \times (dis(i, y) + 1)}{2} \times a_i$$

现在考虑这个东西怎么维护。

我们首先找到 $x, y$ 的 LCA，设这个 LCA 为 $z$。

那么答案可以分成两段：

$$\sum_{i \in (z, y)} \dfrac{dis(i, y) \times (dis(i, y) + 1)}{2} \times a_i$$

$$\sum_{i \in (x, z)} \dfrac{dis(i, y) \times (dis(i, y) + 1)}{2} \times a_i$$

注意这两段里 $z$ 只能算一次，如果你计算了两次 $z$ 的贡献记得在后面减掉。

我们考虑如何维护这两段的答案。

首先，针对 $(z, y)$ 路径上的点，我们不难发现它到 $y$ 的距离就是 $dep_y - dep_i$。

上面的式子转化为：

$$\sum_{i \in (z, y)} \dfrac{(dep_y - dep_i) \times (dep_y - dep_i + 1)}{2} \times a_i$$

我们把括号拆开：

$$\sum_{i \in (z, y)} \dfrac{dep_y^2 + dep_y - 2dep_idep_y - dep_i + dep_i^2}{2} \times a_i$$

把项拆开，得到以下几个式子：

$$dep_y^2\sum_{i \in (z, y)}a_i$$

$$dep_y\sum_{i \in (z, y)}a_i$$

$$-2 dep_y\sum_{i \in (z, y)}dep_i \times a_i$$

$$-\sum_{i \in (z, y)}dep_i \times a_i$$

$$\sum_{i \in (z, y)}dep_i^2 \times a_i$$

不难发现，我们只需要分别维护：$\sum a_i$，$\sum dep_i \times a_i$ 和 $\sum dep_i^2 \times a_i$ 即可，而这三项都很容易维护。

然后我们再来看 $(x, z)$ 路径上的点，不难发现这条路径上的点到 $y$ 的距离都可以转化成 $dep_y - dep_z + dep_i - dep_z$。

不难发现：$dep_y$ 和 $dep_z$ 都是定值，我们令 $k = dep_y - dep_z - dep_z$，距离就是 $k + dep_i$。

代回原式中得到：

$$\sum_{i \in (x, z)} \dfrac{(k + dep_i) \times (k + dep_i + 1)}{2} \times a_i$$

把括号拆开：

$$\sum_{i \in (x, z)} \dfrac{k^2 + k + 2k dep_i + dep_i + dep_i^2}{2} \times a_i$$

还是把项拆开：

$$k^2\sum_{i \in (x, z)}a_i$$

$$k \sum_{i \in (x, z)}a_i$$

$$2k \sum_{i \in (x, z)}dep_i \times a_i$$

$$\sum_{i \in (x, z)} dep_i \times a_i$$

$$\sum_{i \in (x, z)} dep_i^2 \times a_i$$

和刚才一样，分别维护 $\sum a_i$，$\sum dep_i \times a_i$ 和 $\sum dep_i^2 \times a_i$ 即可。

计算过程中记得随时取模，否则会爆 `long long`。

另外两段计算完之后，$z$ 被重复计算了两次，记得单独减去 $z$ 的贡献。

我的可持久化线段树写得比较独特，没啥参考价值，代码就不放了。

---

## 作者：Erotate (赞：1)

对于操作一和操作三，我们用主席树来维护即可，那么我们现在来看如何维护操作二。先想想在序列上怎么做，对于 $1$ 到 $n$，$a_1 \dots a_n$ 的贡献和为
$$\sum_{i=1}^{n} a_i \times (n-i+1) \times (n-i) \div 2$$

变形一下就是
$$\dfrac{1}{2}\sum_{i=1}^{n} a_i \times i^2 +a_i \times i \times (2 \times n + 1) + a_i \times n \times (n+1)$$

容易发现，$2 \times n + 1,n \times (n+1)$ 都相当于常数，那么我们只需要维护 $a_i \times i^2,a_i \times i,a_i$ 即可。

如果把这个式子放到树上，对于路径 $u$ 到 $v$，我们将其拆成两半（$lca$ 为 $u$ 和 $v$ 的最近公共祖先）：

1. 对于任意一个 $u$ 到 $lca$ 上的节点 $x$ 所对应的 $i$ 应为 $dep_x+dep_v-2 \times dep_{lca}$。

2. 对于任意一个 $lca$ 到 $v$ 上的节点 $x$ 所对应的 $i$ 应为 $dep_v-dep_x$。

其中 $dep_x$ 代表节点 $x$ 到根节点的距离。通过这样的一个对应关系，我们就能算出每条路径的贡献和了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define PII pair<int,int>
#define lb(i) (-i)&i
using namespace std;
typedef long long LL;
namespace IO{
    #ifdef ONLINE_JUDGE
    static char buf[4500000],*p1=buf,*p2=buf;
    #define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,4500000,stdin),p1==p2)?EOF:*p1++
    #endif
    inline int read(){
        int x=0,f=1;
        char ch=getchar();
        while(!isdigit(ch)){
            if(ch=='-') f=-f;
            ch=getchar();
        }
        while(isdigit(ch)) x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
        return x*f;
    }
    template <typename T> inline void write(T x){
        if(x<0) putchar('-'),x=-x;
        if(x>9) write(x/10);
        putchar(x%10+'0');
    }
    template <typename T> inline void Write(T x){
        write(x);
        puts("");
    }
}
using namespace IO;
#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif
const int N=1e5+5,P=20160501;
struct edge{
	int v,nxt;
}e[N<<1];
struct President_Tree{
	int ls,rs;
	LL v1,v2,v3,d1,d2,tag;//v1,v2,v3 分别维护多项式里每一项的值，d1,d2 维护的是系数。
}tr[N*60];
int n,m,head[N],cnt;
int dep[N],siz[N],f[N],son[N],top[N],id[N],b[N],dfn;
int rt[N],idx,num,cur,a[N];
void add(int x,int y){
	e[++cnt]=((edge){y,head[x]});
	head[x]=cnt;
}
void dfs1(int x,int fa){
	dep[x]=dep[fa]+1,f[x]=fa,siz[x]=1;
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa) continue;
		dfs1(v,x);
		siz[x]+=siz[v];
		if(siz[v]>siz[son[x]]) son[x]=v;
	}
}
void dfs2(int x,int tp){
	top[x]=tp,id[x]=++dfn,b[dfn]=x;
	if(son[x]) dfs2(son[x],tp);
	for(int i=head[x];i;i=e[i].nxt)
		if(!id[e[i].v]) dfs2(e[i].v,e[i].v);
}
void push_up(int k,int sz){
	tr[k].v1=(tr[tr[k].ls].v1+tr[tr[k].rs].v1+tr[k].tag*sz)%P;
	tr[k].v2=(tr[tr[k].ls].v2+tr[tr[k].rs].v2+tr[k].tag*tr[k].d1)%P;
	tr[k].v3=(tr[tr[k].ls].v3+tr[tr[k].rs].v3+tr[k].tag*tr[k].d2)%P;
}
void build(int &k,int l,int r){
	k=++idx;
	if(l==r){
		int x=b[l];
		tr[k].v1=a[x],tr[k].v2=1ll*a[x]*dep[x],tr[k].v3=1ll*a[x]*dep[x]*dep[x];
		tr[k].d1=dep[x],tr[k].d2=1ll*dep[x]*dep[x];
		return;
	}
	int mid=l+r>>1;
	build(tr[k].ls,l,mid);
	build(tr[k].rs,mid+1,r);
	push_up(k,r-l+1);
	tr[k].d1=(tr[tr[k].ls].d1+tr[tr[k].rs].d1)%P;
	tr[k].d2=(tr[tr[k].ls].d2+tr[tr[k].rs].d2)%P;
}
void modify(int &x,int y,int l,int r,int L,int R,LL v){
	if(!x) tr[x=++idx]=tr[y];
	if(L==l && r==R){
		tr[x].v1=(tr[x].v1+v*(r-l+1))%P;
		tr[x].v2=(tr[x].v2+v*tr[x].d1)%P;
		tr[x].v3=(tr[x].v3+v*tr[x].d2)%P;
		tr[x].tag=(tr[x].tag+v)%P;
		return;		
	}
	int mid=l+r>>1;
	if(L>mid){
		if(tr[x].rs==tr[y].rs) tr[x].rs=0;
		modify(tr[x].rs,tr[y].rs,mid+1,r,L,R,v);
	}else if(R<=mid){
		if(tr[x].ls==tr[y].ls) tr[x].ls=0;
		modify(tr[x].ls,tr[y].ls,l,mid,L,R,v);
	}else{
		if(tr[x].ls==tr[y].ls) tr[x].ls=0;
		modify(tr[x].ls,tr[y].ls,l,mid,L,mid,v);
		if(tr[x].rs==tr[y].rs) tr[x].rs=0;
		modify(tr[x].rs,tr[y].rs,mid+1,r,mid+1,R,v);
	}
	push_up(x,r-l+1);
}
struct Qry{
	LL x,y,z;
	Qry(LL _1,LL _2,LL _3){x=_1,y=_2,z=_3;}
	friend Qry operator+(const Qry &t1,const Qry &t2){
		return Qry((t1.x+t2.x)%P,(t1.y+t2.y)%P,(t1.z+t2.z)%P);
	}
};
Qry query(int k,int l,int r,int L,int R,LL tg){
	if(L==l && r==R) return Qry((tr[k].v1+tg*(r-l+1))%P,(tr[k].v2+tg*tr[k].d1)%P,(tr[k].v3+tg*tr[k].d2)%P);
	int mid=l+r>>1;
	tg=(tg+tr[k].tag)%P;
	if(L>mid) return query(tr[k].rs,mid+1,r,L,R,tg);
	else if(R<=mid) return query(tr[k].ls,l,mid,L,R,tg);
	else return query(tr[k].ls,l,mid,L,mid,tg)+query(tr[k].rs,mid+1,r,mid+1,R,tg);
}
void update(int x,int y,int v){
	num++;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		modify(rt[num],rt[cur],1,n,id[top[x]],id[x],v);
		x=f[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	modify(rt[num],rt[cur],1,n,id[x],id[y],v);
	cur=num;
}
int lca(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=f[top[x]];
	}
	return dep[x]>dep[y]?y:x;
}
LL ask(int x,int y){
	int lc=lca(x,y);
	LL res=0,dp2=dep[y],dp1=(dep[y]-2*dep[lc]+P)%P;//i 的两种不同的对应。
	while(top[x]!=top[y]){
		if(dep[top[x]]>=dep[top[y]]){
			Qry t1=query(rt[cur],1,n,id[top[x]],id[x],0);
			res=(res+t1.x*(dp1*dp1%P+dp1))%P;
			res=(res+t1.y*(2*dp1+1)%P+t1.z)%P;
			x=f[top[x]];
		}else{
			Qry t1=query(rt[cur],1,n,id[top[y]],id[y],0);
			res=(res+t1.x*(dp2*dp2%P+dp2))%P;
			res=(res-t1.y*(2*dp2+1)%P+t1.z+P)%P;
			y=f[top[y]];
		}
	}
	if(dep[x]>=dep[y]){
		Qry t1=query(rt[cur],1,n,id[y],id[x],0);
		res=(res+t1.x*(dp1*dp1%P+dp1))%P;
		res=(res+t1.y*(2*dp1+1)%P+t1.z)%P;
	}else{
		Qry t1=query(rt[cur],1,n,id[x],id[y],0);
		res=(res+t1.x*(dp2*dp2%P+dp2))%P;
		res=(res-t1.y*(2*dp2+1)%P+t1.z+P)%P;
	}
	return res*10080251%P;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr),cout.tie(nullptr);
    n=read(),m=read();
    for(int i=1;i<n;++i){
    	int x=read(),y=read();
    	add(x,y),add(y,x);
	}
	for(int i=1;i<=n;++i) a[i]=read();
	dfs1(1,0);
	dfs2(1,1);
	build(rt[0],1,n);
	LL ans=0;
	while(m--){
		int op=read(),x=read()^ans;
		if(op==1){
			int y=read()^ans,v=read();
			update(x,y,v);
		}else if(op==2){
			int y=read()^ans;
			ans=ask(x,y);
			printf("%lld\n",ans);
		}else cur=x;
	}
    return 0;
}

```


---

## 作者：dvsfanjo (赞：1)

# 题解：P7671 [GDOI2016] 疯狂动物城

带着大家一起切这道花了我 3 天水黑。

## Part1 推式子

### Part1-1 拆式子

$$\begin{aligned}
  ans&=\frac{1}{2}\sum_{i\in [u,v]}a_idis(i,v)(dis(i,v)-1)\\
  &=\frac{1}{2}(\sum_{i\in A}a_idis(i,v)(dis(i,v)-1)+\sum_{i\in B}a_idis(i,v)(dis(i,v)-1))
\end{aligned}$$

其中

$$A=[u,lca]$$

$$B=(lca,v]$$

### Part1-2 式子 A

对于路径 $A$ ，答案为：

$$\begin{aligned}
ansA &=\sum_{i\in A}a_i(dep_i+dep_v-2dep_{lca})(dep_i+dep_v-2dep_{lca}+1)\\
&=\sum_{i\in A}a_i(dep_i^2+2dep_idep_v-4dep_idep_{lca}-4dep_vdep_{lca}+4dep_{lca}^2+dep_i+dep_v-2dep_{lca})\\
&=\sum_{i\in A}a_idep_i^2+(2dep_v-4dep_{lca}+1)\sum_{i\in A}a_idep_i-(4dep_vdep_{lca}-4dep_{lca}^2-dep_v+2dep_{lca}+dep_v^2)\sum_{i\in A}a_i
\end{aligned}$$

### Part1-3 式子 B

对于路径 $B$ ，答案为：

$$\begin{aligned}
ansB&=\sum_{i\in B}a_i(dep_v-dep_i)(dep_v-dep_i+1)\\
&=\sum_{i\in B}a_i(dep_i^2+dep_v^2-2dep_idep_v+dep_i+dep_v)\\
&=\sum_{i\in B}a_idep_i^2-(2dep_v+1)\sum_{i\in B}a_idep_i+(dep_v^2+dep_v)\sum_{i\in B}a_i
\end{aligned}$$

### Part1-4 总结

综上，我们需要维护路径上的：

-  $\sum a_i$
-  $\sum a_idep_i$
-  $\sum a_idep_i^2$

又因为有版本查询，使用可持久化线段树和重链剖分维护路径答案。

## Part2 可持久化线段树

写线段树之前，我们明白了维护的信息，除此之外，我们要还明白我们要做的操作。

我们要实现：

- 区间加
- 区间三种和
- 历史版本查询

刚好最近学了李超线段树，这题就用标记永久化。

### Part2-1 标记永久化

> 标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中。
> —— [oi-wiki](https://oi-wiki.org/ds/seg/#%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96)

因为一个节点可能因为被修改区间包含，导致子节点仍指向旧版本而没有被复制，之后打标记可能会打到旧版本上，因此要顺带记录左右儿子是否指向旧版本，线段树节点的结构体也很显然了。

```cpp
struct node {
    ll sum, smul, spow, tag;
    ll ls, rs, lv, rv;
    friend node operator + (node a, node b) {
        return node{
            (a.sum + b.sum) % p,
            (a.smul + b.smul) % p,
            (a.spow + b.spow) % p,
            0, 0, 0, 0, 0};
    }
} t[maxn << 6];
```

### Part2-2  build

```cpp
ll tot;
#define mid (l + r >> 1)
void build(ll l, ll r, ll &u) {
    u = ++tot;
    if (l == r) {
        t[u] = {
            a[l],
            a[l] * b[l] % p,
            a[l] * b[l] % p * b[l] % p,
            0, 0, 0, 0, 0};
        /*a[i] 是当前位置表示的节点的权值*/
        /*b[i] 是当前位置表示的节点的深度*/
        sum[l][0] = (sum[l - 1][0] + b[l]) % p;
        sum[l][1] = (sum[l - 1][1] + b[l] * b[l] % p) % p;
    } else {
        build(l, mid, t[u].ls);
        build(mid + 1, r, t[u].rs);
        node c = t[t[u].ls] + t[t[u].rs];
        t[u].sum  = c.sum;
        t[u].smul = c.smul;
        t[u].spow = c.spow;
         //这样写不会影响到 t[u].ls 和 t[u].rs
    } return;
}
```

我们计算答案时会加上标记的影响，因为：

$$\sum_{i=l}^r(a_i+k)=\sum_{i=l}^ra_i+(r-l+1)$$

$$\sum_{i=l}^r(a_i+k)dep_i=\sum_{i=l}^ra_idep_i+k\sum_{i=l}^rdep_i$$

$$\sum_{i=l}^r(a_i+k)dep_i^2=\sum_{i=l}^ra_idep_i^2+k\sum_{i=l}^rdep_i^2$$

因为每个节点的深度不会改变，所以说 $\sum_{i=l}^rdep_i$ 和 $\sum_{i=l}^rdep_i^2$ 可以用前缀和维护（就是 ```build``` 函数中 ```sum``` 数组的用处）。

### Part2-3 update

```cpp
inline ll clone(ll u) {
    t[++tot] = t[u];
    t[tot].lv = t[tot].rv = false;
    return tot;
}
```

克隆节点，很显然吧。

```cpp
inline void pushup(ll l, ll r, node &x, ll k) {
	x.sum = (x.sum + (r - l + 1) * k % p) % p;
	x.smul = (x.smul + (sum[r][0] - sum[l - 1][0] + p) % p * k % p) % p;
	x.spow = (x.spow + (sum[r][1] - sum[l - 1][1] + p) % p * k % p) % p;
	return;
}
```

前文的 ```sum``` 数组的用处。

```cpp
void update(ll l, ll r, ll u, ll a, ll b, ll k) {
    pushup(max(l, a), min(r, b), t[u], k);
    //更新当前节点打上标记后的值
	if (a <= l && r <= b) {
        t[u].tag = (t[u].tag + k) % p;
        //被区间包含，直接打上标记
    } else {
        if (a <= mid) {
            if (!t[u].lv) {
                t[u].ls = clone(t[u].ls);
                t[u].lv = true;
                t[t[u].ls].lv = t[t[u].ls].rv = false;
            } update(l, mid, t[u].ls, a, b, k);
        }
        if (mid < b) {
            if (!t[u].rv) {
                t[u].rs = clone(t[u].rs);
                t[u].rv = true;
                t[t[u].rs].lv = t[t[u].rs].rv = false;
            } update(mid + 1, r, t[u].rs, a, b, k);
        }	
    } return;
}
```

在 ```update``` 函数中，我们要处理子节点指向旧版本的问题，上述代码中有具体实现。

如果当前节点的子节点指向旧版本，那么我们要先将其复制为新版本再递归，同时被复制的子节点的子节点仍然指向旧版本，标记一下即可。

看图理解一下，下图中节点 $1$ 被复制了，但是子节点仍指向旧版本。

![](https://cdn.luogu.com.cn/upload/image_hosting/erz9nfij.png)

旧版本的子节点 $2$ 被复制后，其子节点仍指向旧版本。

![](https://cdn.luogu.com.cn/upload/image_hosting/clwg2qjg.png)

所以说，被复制的节点的被复制的子节点的子节点仍然指向旧版本。（好绕口）

### Part2-4 query

```cpp
node query(ll l, ll r, ll u, ll a, ll b) {
    if (a <= l && r <= b) {
        return t[u];
    } else {
        node res = {0, 0, 0, 0, 0, 0, 0, 0};
        pushup(max(l, a), min(r, b), res, t[u].tag);
        if (a <= mid) res = res + query(l, mid, t[u].ls, a, b);
        if (mid < b)  res = res + query(mid + 1, r, t[u].rs, a, b);
        return res;
    }
}
```

累加标记即可，细节自行思考。

## Part3 重链剖分

### Part3-1 预处理

板子，还是放一下吧，不会树剖的点[这](https://oi-wiki.org/graph/hld/)[里](https://www.luogu.com.cn/problem/solution/P3384)。

```cpp
void dfs1(ll u, ll fa) {
	fat[u] = fa; dep[u] = dep[fa] + 1; siz[u] = 1;
	for (auto g : G[u]) {
		if (g == fa) continue;
		dfs1(g, u); siz[u] += siz[g];
		if (siz[g] > siz[son[u]]) son[u] = g;
	} return;
}
void dfs2(ll u, ll T) {
	ide[u] = ++cnt; top[u] = T; a[cnt] = val[u]; b[cnt] = dep[u];
	if (son[u]) dfs2(son[u], T);
	for (auto g : G[u]) {
		if (g == fat[u]) continue;
		if (g == son[u]) continue;
		dfs2(g, g);
	} return;
}
```

### Part3-2 修改

仍是板子。

```cpp
void lca_update(ll rt, ll u, ll v, ll k) {
	while (top[u] != top[v]) {
		if (dep[top[u]] > dep[top[v]]) {
			update(1, n, ver[rt], ide[top[u]], ide[u], k)l
			u = fat[top[u]];
		} else {
			update(1, n, ver[rt], ide[top[v]], ide[v], k);
			v = fat[top[v]];
		}
	} if (dep[u] > dep[v]) swap(u, v);
	update(1, n, ver[rt], ide[u], ide[v], k);
	return;
}
```

### Part3-3 求 LCA 

还是板子。

```cpp
ll lca(ll u, ll v) {
	while (top[u] != top[v]) {
		if (dep[top[u]] > dep[top[v]]) {
			u = fat[top[u]];
		} else {
			v = fat[top[v]];
		}
	} return dep[u] < dep[v] ? u : v;
}
```

### Part3-4 统计答案

先把推出来的 $ansA$ 的式子打出来：

```cpp
inline ll A(ll l, ll r, ll rt, ll deplca, ll depv) {
    if (l > r) return 0;
    node ret = query(1, n, ver[rt], l, r);
    ll res = ret.spow;
    res = (res + (2 * depv - 4 * deplca + 1 + p) * ret.smul % p) % p;
    res = (res + (4 * deplca * deplca + depv - 4 * deplca * depv - 2 * deplca + depv * depv + p) % p * ret.sum % p) % p;
    return res;
}
```

再把 $ansB$ 打出来：

```cpp
inline ll B(ll l, ll r, ll rt, ll deplca, ll depv) {
	if (l > r) return 0;
	node ret = query(1, n, ver[rt], l, r);
	ll res = ret.spow;
	res = (res - (2 * depv + 1) * ret.smul % p + p) % p;
	res = (res + (depv * depv + depv) * ret.sum % p) % p;
	return res;
}
```

套到树剖查询的板子里即可，注意，不能使用 ```if (dep[top[u]] > dep[top[v]]) swap(u,v)``` 的写法，会把路径搞反。

```cpp
ll lca_query(ll rt, ll u, ll v) {
	ll res = 0, Lca = lca(u, v), depv = dep[v];
	while (top[u] != top[v]) {
		if (dep[top[u]] > dep[top[v]]) {
			res = (res + A(ide[top[u]], ide[u], rt, dep[Lca], depv)) % p;
			u = fat[top[u]];
		} else {
			res = (res + B(ide[top[v]], ide[v], rt, dep[Lca], depv)) % p;
			v = fat[top[v]];
		}
	}
	res = (res + A(ide[Lca], ide[u], rt, dep[Lca], depv)) % p;
	res = (res + B(ide[Lca] + 1, ide[v], rt, dep[Lca], depv)) % p;
	return res;
}
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int maxn = 1e5 + 5, p = 20160501, inv = 10080251;
ll dep[maxn], val[maxn], ide[maxn], son[maxn], top[maxn], siz[maxn], fat[maxn], a[maxn], b[maxn], sum[maxn][2];
vector <ll> G[maxn];
ll ver[maxn], rt, op, x, y, w, vers, lst, num, n, q, u, v, cnt;
void dfs1(ll u, ll fa) {
    fat[u] = fa;
    dep[u] = dep[fa] + 1;
    siz[u] = 1;
    for (auto g : G[u]) {
        if (g == fa) continue;
        dfs1(g, u);
        siz[u] += siz[g];
        if (siz[g] > siz[son[u]]) son[u] = g;
    } return;
}
void dfs2(ll u, ll T) {
    ide[u] = ++cnt;
    top[u] = T;
    a[cnt] = val[u];
    b[cnt] = dep[u];
    if (son[u]) dfs2(son[u], T);
    for (auto g : G[u]) {
        if (g == fat[u] || g == son[u]) continue;
        dfs2(g, g);
    } return;
}
struct node {
    ll sum, smul, spow, tag;
    ll ls, rs, lv, rv;
    friend node operator + (node a, node b) {
        return node{
            (a.sum + b.sum) % p,
            (a.smul + b.smul) % p,
            (a.spow + b.spow) % p,
            0, 0, 0, 0, 0};
    }
} t[maxn << 6];
ll tot;
#define mid (l + r >> 1)
void build(ll l, ll r, ll &u) {
    u = ++tot;
    if (l == r) {
        t[u] = {
            a[l],
            a[l] * b[l] % p,
            a[l] * b[l] % p * b[l] % p,
            0, 0, 0, 0, 0};
        sum[l][0] = (sum[l - 1][0] + b[l]) % p;
        sum[l][1] = (sum[l - 1][1] + b[l] * b[l] % p) % p;
    } else {
        build(l, mid, t[u].ls);
        build(mid + 1, r, t[u].rs);
        node c = t[t[u].ls] + t[t[u].rs];
        t[u].sum  = c.sum;
        t[u].smul = c.smul;
        t[u].spow = c.spow;
    } return;
}
inline ll clone(ll u) {
    t[++tot] = t[u];
    t[tot].lv = t[tot].rv = false;
    return tot;
}
inline void pushup(ll l, ll r, node &x, ll k) {
    x.sum  = (x.sum  + (r - l + 1) * k % p) % p;
    x.smul = (x.smul + (sum[r][0] - sum[l - 1][0] + p) % p * k % p) % p;
    x.spow = (x.spow + (sum[r][1] - sum[l - 1][1] + p) % p * k % p) % p;
    return;
}
void update(ll l, ll r, ll u, ll a, ll b, ll k) {
    pushup(max(l, a), min(r, b), t[u], k);
	if (a <= l && r <= b) {
        t[u].tag = (t[u].tag + k) % p;
    } else {
        if (a <= mid) {
            if (!t[u].lv) {
                t[u].ls = clone(t[u].ls);
                t[u].lv = true;
                t[t[u].ls].lv = t[t[u].ls].rv = false;
            } update(l, mid, t[u].ls, a, b, k);
        }
        if (mid < b) {
            if (!t[u].rv) {
                t[u].rs = clone(t[u].rs);
                t[u].rv = true;
                t[t[u].rs].lv = t[t[u].rs].rv = false;
            } update(mid + 1, r, t[u].rs, a, b, k);
        }	
    } return;
}
node query(ll l, ll r, ll u, ll a, ll b) {
    if (a <= l && r <= b) {
        return t[u];
    } else {
        node res = {0, 0, 0, 0, 0, 0, 0, 0};
        pushup(max(l, a), min(r, b), res, t[u].tag);
        if (a <= mid) res = res + query(l, mid, t[u].ls, a, b);
        if (mid < b)  res = res + query(mid + 1, r, t[u].rs, a, b);
        return res;
    }
}
void lca_update(ll rt, ll u, ll v, ll k) {
    while (top[u] != top[v]) {
        if (dep[top[u]] > dep[top[v]]) {
            update(1, n, ver[rt], ide[top[u]], ide[u], k);
            u = fat[top[u]];
        } else {
            update(1, n, ver[rt], ide[top[v]], ide[v], k);
            v = fat[top[v]];
        }
    }
    if (dep[u] > dep[v]) swap(u, v);
    update(1, n, ver[rt], ide[u], ide[v], k);
    return; 
}
ll lca(ll u, ll v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] > dep[top[v]]) {
            u = fat[top[u]];
        } else {
            v = fat[top[v]];
        }
    }
    return dep[u] < dep[v] ? u : v;
}
inline ll A(ll l, ll r, ll rt, ll deplca, ll depv) {
    if (l > r) return 0;
    node ret = query(1, n, ver[rt], l, r);
    ll res = ret.spow;
    res = (res + (2 * depv - 4 * deplca + 1 + p) * ret.smul % p) % p;
    res = (res + (4 * deplca * deplca + depv - 4 * deplca * depv - 2 * deplca + depv * depv + p) % p * ret.sum % p) % p;
    return res;
}
inline ll B(ll l, ll r, ll rt, ll deplca, ll depv) {
    if (l > r) return 0;
    node ret = query(1, n, ver[rt], l, r);
    ll res = ret.spow;
    res = (res - (2 * depv + 1) * ret.smul % p + p) % p;
    res = (res + (depv * depv + depv) * ret.sum % p) % p;
    return res;
}
ll lca_query(ll rt, ll u, ll v) {
    ll res = 0, Lca = lca(u, v), depv = dep[v];
    while (top[u] != top[v]) {
        if (dep[top[u]] > dep[top[v]]) {
            res = (res + A(ide[top[u]], ide[u], rt, dep[Lca], depv)) % p;
            u = fat[top[u]];
        } else {
            res = (res + B(ide[top[v]], ide[v], rt, dep[Lca], depv)) % p;
            v = fat[top[v]];
        }
    }
    if (dep[u] >= dep[v]) {
    	res = (res + A(ide[v], ide[u], rt, dep[Lca], depv)) % p;
	} else {
		res = (res + B(ide[u], ide[v], rt, dep[Lca], depv)) % p;
	} return res * inv % p;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> n >> q;
    for (int i = 1; i < n; i++) {
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
    }
    dfs1(1, 0); dfs2(1, 1);
    build(1, n, ver[0]);
    while (q--) {
        cin >> op;
        if (op == 1) {
            cin >> x >> y >> w;
            x ^= lst; y ^= lst;
            ll nwrt = clone(ver[rt]);
            ver[++vers] = nwrt;
            rt = vers;
            t[ver[rt]].lv = t[ver[rt]].rv = false;
            lca_update(rt, x, y, w);
        }
        if (op == 2) {
            cin >> x >> y;
            x ^= lst; y ^= lst;
            lst = lca_query(rt, x, y);
            cout << lst << '\n';
        }
        if (op == 3) {
            cin >> x;
            x ^= lst;
            rt = x;
        }
    }
    return 0;
}
```

---

## 作者：Reunite (赞：0)

## 一
---

刚好 lxl 今天讲持久化数据结构，我们来开这题。

首先显然把树剖了，然后我们只需要考虑一条重链上的连续信息即可。定义 $dis(x,y)$ 为 $x$ 到 $y$ 的距离，$path_i$ 为 $y$ 到 $x$ 的路径上第 $i$ 个节点。

我们注意到，在 $y \rightarrow x$ 的这条树链上的每一条重链，从这一段的链头到链尾，到 $y$ 的距离改变一定是连续改变的，那么久很好维护了。

题目要我们求的即为： $\sum_{i=1}^{len} \frac{(i-1)ia_{path_i}}{2}=(\frac{i^2}{2}-\frac{i}{2})a_{path_i}$。即我们只需要维护一段连续的形如 $i^2a_i,ia_i$ 的和即可。

具体地，我们维护一个可持久化线段树，每个节点维护：$sl1,sl2,sr1,sr2,s,len$ 分别表示在该区间内从左到右 $\sum ia_i$，$\sum i^2a_i$，从右向左 $\sum ia_i$，$\sum i^2a_i$，以及区间和，区间长度。注意这里的 $i$ 可以认为是新编号的，即在区间内部是 $[1,len]$ 的。

合并是 naive 的，展开一下平凡，几个值相互转移即可。

## 二
---

本来要写标记永久化的，结果调了很久没有调出来，后来发现放宽后的空间是可以直接 $pushdown$ 的，所以我就写了 $pushdown$ 版本的。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define mod 20160501
#define inv2 10080251
// #define int long long
using namespace std;

int n,m,tm,cnt,lascnt;
int a[100005];
int fa[100005];
int sz[100005];
int it[100005];
int ss[100005];
int son[100005];
int dep[100005];
int dfn[100005];
int out[100005];
int top[100005];
vector <int> g[100005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline void dfsfind(int u,int f){
	fa[u]=f;
	sz[u]=1;
	dep[u]=dep[f]+1;
	for(int v:g[u]){
		if(v==f) continue;
		dfsfind(v,u);
		sz[u]+=sz[v];
		if(sz[son[u]]<sz[v]) son[u]=v;
	}
	return ;
}

inline void dfstime(int u,int tp){
	top[u]=tp;
	dfn[u]=++tm;
	it[tm]=u;
	if(son[u]) dfstime(son[u],tp);
	for(int v:g[u]){
		if(v==fa[u]||v==son[u]) continue;
		dfstime(v,v);
	}
	out[u]=tm;
	return ;
}

inline int LCA(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	return dep[x]<dep[y]?x:y;
}

inline int dis(int x,int y){return dep[x]+dep[y]-2*dep[LCA(x,y)];}

#define N 64000000

int tot;
int tg[N];
int lc[N];
int rc[N];
int rt[100005];
struct node{int sl1,sl2,sr1,sr2,s,len;};
node t[N];

node operator + (node p,node q){
	node tmp;
	tmp.len=p.len+q.len;
	tmp.s=(p.s+q.s)%mod;
	tmp.sl1=(p.sl1+q.sl1+1ll*q.s*p.len%mod)%mod;
	tmp.sr1=(q.sr1+p.sr1+1ll*p.s*q.len%mod)%mod;
	tmp.sl2=(p.sl2+q.sl2+2ll*q.sl1*p.len%mod+1ll*p.len*p.len%mod*q.s%mod)%mod;
	tmp.sr2=(q.sr2+p.sr2+2ll*p.sr1*q.len%mod+1ll*q.len*q.len%mod*p.s%mod)%mod;
	return tmp;
}

inline int build(int u,int l,int r){
	if(!u) u=++tot;
	if(l==r){
		int x=a[it[l]];
		t[u]={x,x,x,x,x,1};
		return tot;
	}
	int mid=(l+r)>>1;
	lc[u]=build(lc[u],l,mid);
	rc[u]=build(rc[u],mid+1,r);
	t[u]=t[lc[u]]+t[rc[u]];
	return u;
}

inline int clone(int u){
	tot++;
	lc[tot]=lc[u];
	rc[tot]=rc[u];
	tg[tot]=tg[u];
	t[tot]=t[u];
	return tot;
}

inline int asksum1(int l,int r){return (ss[r]-ss[l-1]+mod)%mod;}
inline int asksum2(int l,int r){return 1ll*(l+r)*(r-l+1)/2%mod;}

inline void down(int u,int x){
	tg[u]=(tg[u]+x)%mod;
	int len=t[u].len;
	t[u].s=(t[u].s+1ll*x*len%mod)%mod;
	t[u].sl1=(t[u].sl1+1ll*x*asksum2(1,len)%mod)%mod;
	t[u].sr1=(t[u].sr1+1ll*x*asksum2(1,len)%mod)%mod;
	t[u].sl2=(t[u].sl2+1ll*x*asksum1(1,len)%mod)%mod;
	t[u].sr2=(t[u].sr2+1ll*x*asksum1(1,len)%mod)%mod;
	return ;
}

inline void pushdown(int u){
	lc[u]=clone(lc[u]);
	rc[u]=clone(rc[u]);
	down(lc[u],tg[u]);
	down(rc[u],tg[u]);
	tg[u]=0;
	return ;
}

inline int updata(int u,int l,int r,int L,int R,int x){
	u=clone(u);
	if(L<=l&&r<=R){
		down(u,x);
		return u;
	}
	pushdown(u);
	int mid=(l+r)>>1;
	if(L<=mid) lc[u]=updata(lc[u],l,mid,L,R,x);
	if(R>mid) rc[u]=updata(rc[u],mid+1,r,L,R,x);
	t[u]=t[lc[u]]+t[rc[u]];
	return u;
}

inline node query(int u,int l,int r,int L,int R){
	if(L<=l&&r<=R) return t[u];
	pushdown(u);
	int mid=(l+r)>>1;
	if(L>mid) return query(rc[u],mid+1,r,L,R);
	if(R<=mid) return query(lc[u],l,mid,L,R);
	return query(lc[u],l,mid,L,R)+query(rc[u],mid+1,r,L,R);
}

inline void change(int x,int y,int d){
	cnt++;
	rt[cnt]=rt[lascnt];
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		rt[cnt]=updata(rt[cnt],1,n,dfn[top[x]],dfn[x],d);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);
	rt[cnt]=updata(rt[cnt],1,n,dfn[y],dfn[x],d);
	lascnt=cnt;
	return ;
}

struct Node{node t;int d;};

inline bool cmp(Node p,Node q){return p.d<q.d;}

inline int ask(int x,int y){
	int c=0,st=y;
	Node ttt[40];
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		node xx=query(rt[lascnt],1,n,dfn[top[x]],dfn[x]);
		int d1=dis(st,top[x]),d2=dis(st,x);
		if(d1>d2) swap(d1,d2),swap(xx.sl1,xx.sr1),swap(xx.sl2,xx.sr2);
		c++;
		ttt[c]={xx,d1};
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);
	node xx=query(rt[lascnt],1,n,dfn[y],dfn[x]);
	int d1=dis(st,y),d2=dis(st,x);
	if(d1>d2) swap(d1,d2),swap(xx.sl1,xx.sr1),swap(xx.sl2,xx.sr2);
	c++;
	ttt[c]={xx,d1};
	sort(ttt+1,ttt+1+c,cmp);
	node tt=ttt[1].t;
	for(int i=2;i<=c;i++) tt=tt+ttt[i].t;
	int s=((tt.sl2-2ll*tt.sl1+tt.s+mod)%mod+(tt.sl1-tt.s+mod)%mod)%mod;
	return 1ll*s*inv2%mod;
}

signed main(){
	in(n),in(m);
	for(int i=1;i<=n;i++) ss[i]=(ss[i-1]+1ll*i*i%mod)%mod;
	for(int i=1;i<n;i++){
		int u,v;
		in(u),in(v);
		g[u].emplace_back(v);
		g[v].emplace_back(u);
	}
	for(int i=1;i<=n;i++) in(a[i]);
	dfsfind(1,0);
	dfstime(1,1);
	rt[0]=build(rt[0],1,n);
	int las=0;
	while(m--){
		int op,x,y;
		in(op);
		if(op==1){
			in(x),in(y);
			x^=las,y^=las;
			int der;
			in(der);
			change(x,y,der);
		}
		if(op==2){
			in(x),in(y);
			x^=las,y^=las;
			las=ask(x,y);
			printf("%lld\n",las);
		}
		if(op==3){
			in(x);
			x^=las;
			lascnt=x;
		}
	}

	return 0;
}
```

---


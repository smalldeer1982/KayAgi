# [THUPC 2023 初赛] 喵了个喵 II

## 题目背景

本来这题的题面和《喵了个喵》有关的。但是听说有人嫌题面长，就少说点好了。

## 题目描述

给定一个长为 $4n$ 的序列，其中 $1\sim n$ 各出现 $4$ 次。问是否能够将其划分为两个相等的子序列。

## 说明/提示

#### 样例解释 1

两个子序列均为 $(1,2,1,2)$。

#### 子任务

保证 $1\le n \le 5\times10^4$。

保证序列中 $1\sim n$ 各出现 $4$ 次。

#### 评分方式

你的输出的第一行需要与标准答案一致。若为 `Yes`，输出任意一种合法的划分均算正确。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

By E.Space：由于考场上数据太弱，我于 3.12 和 3.19 两度加强了数据。

## 样例 #1

### 输入

```
2
1 1 2 1 2 2 1 2```

### 输出

```
Yes
10000111
```

# 题解

## 作者：loverintime (赞：34)

场切了， 并且是正解， 很高兴， 来写一篇题解。

~~但是爆搜过了~~

## 题意

给定一个长度为 $4n$ 的序列 $a_{1\sim 4n}$， 其中 $1\sim n$ 各出现 $4$ 次， 问能否将其划分为两个完全相同的子序列。

## 题解

首先考虑一个弱化版： 如果每个数只出现两次。 考虑这个问题有没有什么简洁的方法。

令一个数 $i$ 第一次出现的位置为 $l_i$, 第二次为 $r_i$， 那么有解的充要条件为任意两个 $[l_i,r_i]$ 没有包含关系。

首先如果存在包含关系就一定无解（这两个数在两个序列中的出现顺序不同）。 否则可以将所有 $l_i$ 划分到第一个序列中， $r_i$ 划分到第二个序列中， 这样一定是正确的。 可以感性理解为任意两个数的出现顺序在两个序列中是相同的。

回到本题。 由于有 $4$ 个数， 我们可以考虑将它们划分为两对然后做上面的构造。 可以发现无论这 $4$ 个数如何划分， 都可以规约成两对不同颜色的情况。 并且可以显然地发现只有 $(1,2)\&(3,4),(1,3)\&(2,4)$ 这两种划分方法， 因为 $(1,4)\&(2,3)$ 已经无解了。

分析到这儿， 就可以想到 $\operatorname{2-sat}$ 了。其中限制是区间不能包含。 将区间看成平面上的点， 和某一个区间之间有限制的区间就在一个矩形内部了，可以使用主席树来优化建图， 然后直接跑 $\operatorname{2-sat}$ 就行了。 线段树建图优化 $\operatorname{2-sat}$ 可以看 [ARC069F](https://www.luogu.com.cn/problem/AT_arc069_d)。

时间复杂度 $O(n\log n)$。 常数可想而知。

~~但是爆搜过了。~~

也可以使用 cdq 分治来优化建图， 本质相同。 ~~都比爆搜慢一万倍。~~

代码就不放了。 场上写的， 常数大还很丑。

---

## 作者：jjsnam (赞：14)

**Update on 2025-08-12: 感谢 @[Pursuing_OIer](https://www.luogu.com.cn/user/752591)
 指出代码错误，已经修改。（年久失修，这题已经想不起来了，为啥这么改暂时未补充）**

大家都写的好简略啊，不太适合我，写一篇详尽一些的。

------------

## 分析

我们先假设我们一定能构造出来。

$4$ 个同样的数分为两组，我们通过列举发现只有如下三种情况（数字表示第几个出现的该数字）：

1.	$\langle1, 2\rangle$ 和 $\langle3, 4\rangle$；
2.	$\langle1, 3\rangle$ 和 $\langle2, 4\rangle$；
3.	$\langle1, 4\rangle$ 和 $\langle2, 3\rangle$；

我们学到的很多算法都是建立在两种相对关系上的，涉及三个的却少之又少，因而我们可以想一想有哪一种分法可以用其他分法包含。

观察上面三种分法，容易发现只有第三种是一个包含关系，我们猜想可以用前两个分法同样达到构造效果，下面来论证一下：


------------


![](https://cdn.luogu.com.cn/upload/image_hosting/lcsrkvlm.png)

如上图，我们把一个能有第三种分法分出来的方案画出来，红色球表示在 $\langle1,4\rangle$ 子序列中，蓝色则是 $\langle2,3\rangle$。进而我们发现 $(3,4)$ 间的数总是属于 $\langle1,4\rangle$ 子序列的，$\langle2,3\rangle$ 子序列中的数都来自原序列 $(2,3)$ 之间。同时，分出的子序列中各数的大小关系在原序列中不变。那我们不妨把 所有在 $(3,4)$ 中出现的数 **对应上** 在 $(2, 3)$ 中出现在另一个子序列的数，并且把两组数重新分配到另一个子序列中，如果有其他数冲突则按原先分配方法变动，思考后发现这样变换后最终子序列没变，子序列中数间的大小关系没有影响，因而我们通过变换将第三种构造方式变成了第二种构造方式。进而我们可以推广到每个数都可以这样变换，因而就不用考虑第三种构造方案了。

------------

接下来考虑如何判断是否有解。我们记 $x_i$ 表示数字 $x$ 在原序列中第 $i$ 次出现的位置。如果我们把 $x_i$、$x_j$ （ $i,j$ 取值应该符合我们考虑的那两种构造方法）分别分配在两个子序列中，那么对于另一个数 $y$，它的分配方案是把 $y_k$、$y_l$ 拆散，这种构造方案合法的必要条件就是 $[x_i<y_k] = [x_j<y_l]$。即两对数在相应子序列中的偏序关系相同。如果不相同则两种分配方法不能同时选，这让我们联想到了 2-SAT 问题，把上述分配方法看做一个点，那么我们只需要在矛盾的方法之间连边（注意连边的意义是一个方案用了另一个方案就不能用）即可。

别以为这就做完了，实现上仍然有难点。

## 细节与实现

把可能的分配方法罗列一下：

-	$\langle x_1,x_3\rangle$ 和 $\langle x_2,x_4\rangle$（对应分析中的方案 1）；
-	$\langle x_1,x_2\rangle$ 和 $\langle x_3,x_4\rangle$（对应分析中的方案 2）；

需要注意的是，每条分配方法中的两个分配要同时取或不取，因此公用一个点；且上述两种分配方法是对立的，故是两个不同的点。

然后我们就可以愉快的建图啦！……吗？

显然这样做连边的时空复杂度都是 $O(n^2)$，会爆炸，我们需要找到一种更加优化的建图方式。

矛盾关系有两种：

-	$x_i < y_k \ \land y_l < x_j$；
-	$y_k < x_i \ \land x_j < y_l$；

这两种本质上其实都是包含关系，因而我们规定枚举点建图时只向与它所包含的矛盾点连边。当然，这样不会导致有边漏连，因为如果该点被包含那么等到我们枚举包含它的矛盾点时也会将这条边连上。

我们的空间和时间能承受的时空复杂度大概是 $O(n\log n)$，故我们想到了形似线段树优化建图的方法。但是因为建图时要同时考虑两种关系，因而普通的线段树实现起来有些困难。针对这种二维偏序问题我们可以首先使一个维度有序，另一个纬度再通过数据结构来实现。我们考虑把所有分配方法按右端点升序排序，然后建一颗权值主席树，随着顺次枚举，主席树中存储的分配方法的右端点都应小于我们新枚举的，因而我们只用查询主席树中左端点比新枚举方法的左端点大即可，容易发现这是向一个区间里的每个点连边，符合线段树优化建图的思想。




------------
下面是一些需要注意的细节：

1.	我们为了取巧，将细节与实现一节中一开始的两对对立分配方案所使用的点的编号放在一起，进而反点可以轻松通过异或操作解决。

2.	在对一种矛盾关系的方案连边时，需要注意有两种情况：

	-	前选后不能选；
    -	后选前不能选；
    
    因而一次矛盾关系连边内部实际上连了两条边。
    
3.	在主席树上连边时，树中存的应该是之前分配方法的反点，这样如果矛盾的话当前点直接就能与之前的反点相连。具体实现可以参考代码。

4.	数组大小要开够，但又不能爆，这里希望自己思考或者参考代码。

## 代码

最终的时空复杂度均为 $O(n\log n)$。


```cpp
/* 2-SAT + 线段树优化建图 + 构造 */
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 200010, M = N * 20, V = (N + M) * 2, E = V * 5;

struct SegmentTree{
    int ls, rs;
    int id;
}tr[M];
int root[N], idx;
struct Edge{
    int v, next;
}e[E];
int p[V], len;
int dfn[V], low[V], timestamp;
int id[V], scc_cnt, stk[V], top;
bool in_stk[V];
int pos[200010][5];
struct Method{
    int l, r;
    int id;

    bool operator < (const Method &b) const{
        return r < b.r;
    }   
}option[N];
int tot, ed, n;
bool ans[N];

void add(int u, int v){
    e[len] = (Edge){v, p[u]}, p[u] = len ++;
}

void addEdge(int u, int v){
    add(u, v), add(v ^ 1, u ^ 1);
}

void tarjan(int u){
    dfn[u] = low[u] = ++ timestamp;
    stk[++ top] = u, in_stk[u] = true;

    for (int i = p[u]; ~i; i = e[i].next){
        int v = e[i].v;
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (in_stk[v]) low[u] = min(low[u], dfn[v]);
    }

    if (dfn[u] == low[u]){
        scc_cnt ++;
        int y;
        do {
            y = stk[top --];
            in_stk[y] = false;
            id[y] = scc_cnt;
        } while (y != u);
    }
}

int insert(int p, int l, int r, int x, int id){//建立新版本
    int q = ++ idx;
    tr[q] = tr[p];
    tr[q].id = tot;
    if (tr[p].id){
        addEdge(tr[q].id, tr[p].id);
    }
    tot += 2;//取巧，要满足异或所需要的条件
    if (l == r){
        addEdge(tr[q].id, id);
        return q;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) tr[q].ls = insert(tr[p].ls, l, mid, x, id);
    else tr[q].rs = insert(tr[p].rs, mid + 1, r, x, id);
    addEdge(tr[q].id, tr[tr[q].ls].id), 
    addEdge(tr[q].id, tr[tr[q].rs].id);
    return q;
}

void insert(int p, int l, int r, int a, int b, int id){//在原先的版本上连边
    if (!p) return;
    if (a <= l && r <= b){
        addEdge(id, tr[p].id);
        return;
    }
    int mid = (l + r) >> 1;
    if (a <= mid) insert(tr[p].ls, l, mid, a, b, id);
    if (b > mid) insert(tr[p].rs, mid + 1, r, a, b, id);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    memset(p, -1, sizeof p);

    cin >> n;
    for (int i = 1; i <= n << 2; i ++){
        int x;
        cin >> x;
        pos[x][++ pos[x][0]] = i;//记录出现位置
    }
    for (int i = 1; i <= n; i ++){
        /* 细节3：注意相应方法共用一个点，矛盾方法用一对正反点 */
        option[++ ed] = (Method){pos[i][1], pos[i][2], tot},
        option[++ ed] = (Method){pos[i][3], pos[i][4], tot},
        option[++ ed] = (Method){pos[i][1], pos[i][3], tot ^ 1},
        option[++ ed] = (Method){pos[i][2], pos[i][4], tot ^ 1};
        tot += 2;
    }
    sort(option + 1, option + ed + 1);
    tr[0] = (SegmentTree){0, 0, tot};
    tot += 2;
    for (int i = 1; i <= n << 2; i ++){
        insert(root[i - 1], 1, n << 2, option[i].l, option[i].r, option[i].id);
        root[i] = insert(root[i - 1], 1, n << 2, option[i].l, option[i].id ^ 1);
    }
    for (int i = 0; i < tot; i ++){
        if (!dfn[i]) tarjan(i);
    }
    for (int i = 0; i < tot; i += 2){
        if (id[i] == id[i ^ 1]){//正反点在一起，无解！
            cout << "No" << endl;
            return 0;
        }
    }
    cout << "Yes" << endl;
    for (int i = 1; i <= n << 2; i ++){
        if (id[option[i].id] < id[option[i].id ^ 1]){//根据2-SAT做法选取拓扑序在后的点作为方案
            ans[option[i].l] = 0, ans[option[i].r] = 1;
        }
    }
    for (int i = 1; i <= n << 2; i ++){
        cout << ans[i];
    }
    cout << endl;

    return 0;
}
```

---

## 作者：Leasier (赞：7)

~~爆搜剪枝远快于正解。非常恐怖。~~

- **分析一组合法的解。**

考虑一种数字的四个位置 $p_1 < p_2 < p_3 < p_4$，我们有如下三种将其分配到两个子序列中的方式：

- $(p_1, p_2), (p_3, p_4)$，即不交。
- $(p_1, p_3), (p_2, p_4)$，即相交但不包含。
- $(p_1, p_4), (p_2, p_3)$，即包含。

或言，我们有三种分配方式。

- **简化状态。**

注意到上面三种情况中只有一种为包含关系，不妨尝试将其扔掉。

假设我们选了 $(p_1, p_4), (p_2, p_3)$，对于 $p_1, [A], p_2, [B], p_3, [C], p_4$，注意到 $A, C$ 中全是子序列 $1$ 中的元素，将 $B$ 拆分为子序列 $1, 2$ 选择的元素 $B_1, B_2$，则 $B_2 = A + B_1 + C$。

假设 $B$ 中元素已经满足区间不包含了，若我们改选 $(p_1, p_3), (p_2, p_4)$，则我们只需要让子序列 $1$ 选 $A$、子序列 $2$ 选 $C$，感性理解我们可以分配 $B$ 中元素给子序列 $1, 2$ 使之满足条件。

于是我们只需要讨论前两种情况。

- **构建模型。**

接下来尝试考虑两种数字的情况。设对数字 $1$ 而言，$p_1 < p_2$ 被分配到了子序列 $1$，$p_3 < p_4$ 被分配到了子序列 $2$ 中；对数字 $2$ 而言，$q_1 < q_2$ 被分配到了子序列 $1$，$q_3 < q_4$ 被分配到了子序列 $2$ 中，则：

- 若 $[p_1 < q_1] \neq [p_2 < q_2]$ 或 $[p_3 < q_3] \neq [p_4 < q_4]$ 即存在一对数在两个子序列中的偏序关系不同，则无解。

不难发现将这个条件扩展到任意两对数后一定充要。

至此，考虑对不合法的分配组合建立排斥关系，则原问题转化为一个 2-SAT 问题。

- **数据结构优化。**

注意到这是一个二维偏序状的建图，上主席树优化即可。时间复杂度为 $O(n \log n)$。

~~可惜常数巨大 /ng~~

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <stack>

using namespace std;

typedef struct {
	int nxt;
	int end;
} Edge;

typedef struct Segment_tag {
	int u;
	int v;
	int x;
	int y;
	Segment_tag(){}
	Segment_tag(int u_, int v_, int x_, int y_){
		u = u_;
		v = v_;
		x = x_;
		y = y_;
	}
} Segment;

typedef struct {
	int ls;
	int rs;
	int in;
	int out;
} Node;

int cnt1 = 0, dot_id = 1, seg_tree_id = 0;
int cnt2[50007], pos[50007][7], id1[50007], id2[50007], head[7700007], root[200007], dfn[7700007], low[7700007], belong[7700007], ans[200007];
bool vis1[7700007], vis2[7700007];
Edge edge[24800007];
Segment seg[200007];
Node tree[3800007];
stack<int> s;

bool operator <(const Segment a, const Segment b){
	if (a.x != b.x) return a.x < b.x;
	return a.y > b.y;
}

inline void add_edge(int start, int end){
	cnt1++;
	edge[cnt1].nxt = head[start];
	head[start] = cnt1;
	edge[cnt1].end = end;
}

void connect(int x, int L, int R, int l, int r, int u){
	if (x == 0) return;
	if (l <= L && R <= r){
		add_edge(u, tree[x].in);
		add_edge(tree[x].out, u ^ 1);
		return;
	}
	int mid = (L + R) >> 1;
	if (l <= mid) connect(tree[x].ls, L, mid, l, r, u);
	if (r > mid) connect(tree[x].rs, mid + 1, R, l, r, u);
}

inline void update(int x){
	int ls = tree[x].ls, rs = tree[x].rs;
	if (ls != 0){
		add_edge(tree[x].in, tree[ls].in);
		add_edge(tree[ls].out, tree[x].out);
	}
	if (rs != 0){
		add_edge(tree[x].in, tree[rs].in);
		add_edge(tree[rs].out, tree[x].out);
	}
}

int insert(int x, int l, int r, int pos, int u){
	seg_tree_id++;
	tree[seg_tree_id] = tree[x];
	tree[seg_tree_id].in = ++dot_id;
	tree[seg_tree_id].out = ++dot_id;
	x = seg_tree_id;
	if (l == r){
		add_edge(tree[x].in, u);
		add_edge(u ^ 1, tree[x].out);
		return x;
	}
	int mid = (l + r) >> 1;
	if (pos <= mid){
		tree[x].ls = insert(tree[x].ls, l, mid, pos, u);
	} else {
		tree[x].rs = insert(tree[x].rs, mid + 1, r, pos, u);
	}
	update(x);
	return x;
}

void tarjan(int u, int &id, int &scc_cnt){
	dfn[u] = low[u] = ++id;
	vis1[u] = vis2[u] = true;
	s.push(u);
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (!vis1[x]){
			tarjan(x, id, scc_cnt);
			low[u] = min(low[u], low[x]);
		} else if (vis2[x]){
			low[u] = min(low[u], dfn[x]);
		}
	}
	if (dfn[u] == low[u]){
		int cur;
		scc_cnt++;
		do {
			cur = s.top();
			s.pop();
			vis2[cur] = false;
			belong[cur] = scc_cnt;
		} while (cur != u);
	}
}

int main(){
	int n, m, seg_cnt = 0, dfn_id = 0, scc_cnt = 0;
	cin >> n;
	m = n * 4;
	for (register int i = 1; i <= m; i++){
		int a;
		cin >> a;
		pos[a][++cnt2[a]] = i;
	}
	for (register int i = 1; i <= n; i++){
		id1[i] = ++dot_id;
		id2[i] = ++dot_id;
	}
	for (register int i = 1; i <= n; i++){
		seg[++seg_cnt] = Segment(id1[i], id2[i], pos[i][1], pos[i][2]);
		seg[++seg_cnt] = Segment(id1[i], id2[i], pos[i][3], pos[i][4]);
		seg[++seg_cnt] = Segment(id2[i], id1[i], pos[i][1], pos[i][3]);
		seg[++seg_cnt] = Segment(id2[i], id1[i], pos[i][2], pos[i][4]);
	}
	sort(seg + 1, seg + seg_cnt + 1);
	for (register int i = 1; i <= seg_cnt; i++){
		connect(root[i - 1], 1, m, seg[i].y, m, seg[i].u);
		root[i] = insert(root[i - 1], 1, m, seg[i].y, seg[i].v);
	}
	for (register int i = 1; i <= dot_id; i++){
		if (!vis1[i]) tarjan(i, dfn_id, scc_cnt);
	}
	for (register int i = 1; i <= n; i++){
		if (belong[id1[i]] == belong[id2[i]]){
			cout << "No";
			return 0;
		}
		if (belong[id1[i]] < belong[id2[i]]){
			ans[pos[i][1]] = ans[pos[i][3]] = 0;
			ans[pos[i][2]] = ans[pos[i][4]] = 1;
		} else {
			ans[pos[i][1]] = ans[pos[i][2]] = 0;
			ans[pos[i][3]] = ans[pos[i][4]] = 1;
		}
	}
	cout << "Yes" << endl;
	for (register int i = 1; i <= m; i++){
		cout << ans[i];
	}
	return 0;
}
```

---


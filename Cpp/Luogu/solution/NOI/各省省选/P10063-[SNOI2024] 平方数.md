# [SNOI2024] 平方数

## 题目背景

原题时间限制为 1.5 s。

由于 hack 数据难以通过，改为 10 s。

## 题目描述

你有一个正整数序列 $a_1, a_2, \ldots, a_n$。请问有多少个区间的乘积是完全平方数。也就是有多少对 $(l, r)$（$1 \le l \le r \le n$），满足 $\prod_{i = l}^{r} a_i$ 是完全平方数。

## 说明/提示

**【样例 \#2 解释】**

在第二个样例中，这三个数为 ${10}^{18} - 11, {10}^{18} - 33, {10}^{18} - 123$ 两两相乘。

---

**【样例 \#3】**

见附件中 `square/square3.in` 与 `square/square3.ans`。

这个样例满足测试点 $4 \sim 6$ 的条件限制。

---

**【样例 \#4】**

见附件中 `square/square4.in` 与 `square/square4.ans`。

这个样例满足测试点 $11 \sim 14$ 的条件限制。

---

**【样例 \#5】**

见附件中 `square/square5.in` 与 `square/square5.ans`。

这个样例满足测试点 $18 \sim 20$ 的条件限制。

---

**【数据范围】**

对于所有的数据，保证 $1 \le n \le 3 \times {10}^5$，$1 \le a_i \le {10}^{36}$。

具体如下：

| 测试点编号 | $n \le$ | $a_i \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $1000$ | ${10}^4$ |
| $4 \sim 6$ | ${10}^5$ | ${10}^6$ |
| $7 \sim 10$ | $100$ | ${10}^{36}$ |
| $11 \sim 14$ | $1000$ | ${10}^{36}$ |
| $15 \sim 17$ | ${10}^5$ | ${10}^{36}$ |
| $18 \sim 20$ | $3 \times {10}^5$ | ${10}^{36}$ |

## 样例 #1

### 输入

```
10
1 2 3 4 6 8 9 12 16 18
```

### 输出

```
12
1 1
1 5
2 5
3 6
3 7
4 4
4 8
4 9
5 8
5 9
7 7
9 9
```

## 样例 #2

### 输入

```
3
999999999999999956000000000000000363 999999999999999844000000000000004059 999999999999999866000000000000001353
```

### 输出

```
1
1 3
```

# 题解

## 作者：Otomachi_Una_ (赞：6)

我自信满满的看完题目，然后糊了一个做法：

> 把每个 $a_i$ 分解质因数，每个质数赋一个随机权值。$S_i$ 维护一下前缀乘积质因子的异或，用 map 统计一下就行了。

然后你惊奇的发现 $a_i\leq 10^{36}$，即使用 Pollard Rho 也有 $\mathcal O(a_i^{0.25})$ 的复杂度，也就是一个数也分解不出来。

尝试考虑一些比较玄学的做法。大平方数 $N$ 有一个很好的性质，就是对任意奇质数 $p$，$N\bmod p$ 总是 $\bmod p$ 的二次剩余。

根据众所周知的知识，二次剩余性质非常好，比如：

- 奇质数 $p$ 恰有 $\dfrac{p-1}{2}$ 的非零二次剩余（刚好一半）。
- 一个数 $x$ 是 $\bmod p$ 意义下的二次剩余当且仅当 $x^{\frac{p-1}{2}}\equiv 1\pmod p$，否则就是 $-1$。
- 二次剩余乘上二次剩余还是二次剩余；非二次剩余乘上非二次剩余是二次剩余；二次剩余乘上非二次剩余还是非二次剩余。（这些结论可以从上面结论 $2$ 推出来）。

这启示我们一个玄学的做法：

> 随机选 $T=60$ 个大质数，保证每个质数 $P$ 都和所有 $a_i$ 互质。 然后算二次剩余。把非二次剩余的位记为 $1$，那么一个连续段是合法的当且仅当这一段所有数异或为 $0$。

这样子复杂度是 $\mathcal O(nT\log p)$ 的，考虑去消掉这个 $\log p$。

这里的 $\log p$ 是在判断二次剩余，我们可以考虑找一些小的 $p$ 然后 $\mathcal O(p)$ 提前预处理出来二次剩余（因为这样子排除二次剩余的概率是一样的），但是这样子就不能保证 $P$ 和所有 $a_i$ 互质。

考虑处理掉 $P|a_i$ 的情况，我们可以舍弃掉 $a_i$ 的所有 $P$ 因子。因为这样子我们放弃 $P$ 因子的判断转而判断其他因子正确性不会影响。

复杂度是 $\mathcal O((n+P)T)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define LL __int128
#define MP make_pair
const int MAXN=3e5+5;
const int inf=1e7;
mt19937 rnd(time(0));
int n;LL a[MAXN];ll b[MAXN];
bool is[inf];
unordered_map<ll,vector<int> > mp;
LL read(){
	LL r=0;char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') r=10*r+c-'0',c=getchar();
	return r;
}
ll ksm(ll a,int b,const int MOD){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}
bool is_prime(int x){
	for(int i=2;i*i<=x;i++) if(x%i==0) return false;
	return true;
}
bool occ(ll x){
	for(int i=1;i<=n;i++) if(a[i]%x==0) return true;
	return false;
}
int main(){
	// freopen("ex_5.in","r",stdin);
	// freopen("square.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=0;i<60;i++){
		int p=rnd()%inf+1;
		while(!is_prime(p)) p=rnd()%inf+1;
		cerr<<p<<endl;
		memset(is,0,sizeof(is));
		for(ll i=1;i<p;i++) is[i*i%p]=true;
		for(int j=1;j<=n;j++){
			LL x=a[j];
			while(x%p==0) x/=p;
			if(!is[x%p]) b[j]|=(1ll<<i);
		}
	}
	for(int i=1;i<=n;i++) b[i]^=b[i-1];
	ll ans=0;
	for(int i=0;i<=n;i++) ans+=mp[b[i]].size(),mp[b[i]].push_back(i);
	cout<<ans<<'\n';
	ans=0;
	for(int i=0;i<=n&&ans<1e5;i++){
		for(int j:mp[b[i]]) if(j>i&&ans<1e5){
			ans++;
			cout<<i+1<<' '<<j<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：4)

考虑平方数的性质。

从幂次为偶数入手的话你会发现分解绝对超时。

从平方入手，既然是平方数那么一定存在二次剩余。

对于一个奇质数而言存在二次剩余的概率只有 $\frac{1}{2}$ 所以我们不妨随 $O(\log n)$ 个质数出来。

然后看区间怎么处理，你发现将二次剩余是否存在视为 $0$ 不存在视为 $1$ 那么从前缀到区间的转变符合异或的运算律，因此把在模 $O(\log n)$ 个质数下是否存在二次剩余压缩到一个数中，然后找两个相同的前缀积（相同代表异或为 $0$）。

还有一个问题，假若存在某个质数的倍数，前缀积会是 $0$，怎么办？

由于幂次都是偶数，所以把包含这个质数的质因子除尽后依然是平方数，而且不会出现 $0$。

时间复杂度 $O(n \log^2 n)$ 卡一卡就能过了。

可恶的毒瘤居然把我叉了，没事，我们把筛法化成线性筛，记录是否是二次剩余是状压加速，就可以跑模数为 $3 \times 10^5$ 的情况了，轻松通过毒瘤的 HACK 数据。

又有新的 HACK 了，由于开大了时限所有我们直接筛 $10^7$ 以内的质数。

```cpp
#include<bits/stdc++.h>
namespace IO{
	const int SIZE=1<<21;
	static char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS=obuf,*oT=oS+SIZE-1;
    int qr;
    char qu[55],c;
    bool f;
	#define getchar() (IO::iS==IO::iT?(IO::iT=(IO::iS=IO::ibuf)+fread(IO::ibuf,1,IO::SIZE,stdin),(IO::iS==IO::iT?EOF:*IO::iS++)):*IO::iS++)
	#define putchar(x) *IO::oS++=x,IO::oS==IO::oT?flush():0
	#define flush() fwrite(IO::obuf,1,IO::oS-IO::obuf,stdout),IO::oS=IO::obuf
	#define puts(x) IO::Puts(x)
	template<typename T>
    inline void read(T&x){
    	for(f=1,c=getchar();c<48||c>57;c=getchar())f^=c=='-';
    	for(x=0;c<=57&&c>=48;c=getchar()) x=(x<<1)+(x<<3)+(c&15);
    	x=f?x:-x;
    }
    template<typename T>
    inline void write(T x){
        if(!x) putchar(48); if(x<0) putchar('-'),x=-x;
        while(x) qu[++qr]=x%10^48,x/=10;
        while(qr) putchar(qu[qr--]);
    }
    inline void Puts(const char*s){
    	for(int i=0;s[i];i++)
			putchar(s[i]);
		putchar('\n');
	}
	struct Flusher_{~Flusher_(){flush();}}io_flusher_;
}
using IO::read;
using IO::write;
#define int __int128
using namespace std;
struct my_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }
  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }
  size_t operator()(pair<uint64_t, uint64_t> x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x.first + FIXED_RANDOM) ^
           (splitmix64(x.second + FIXED_RANDOM) >> 1);
  }
};
const int maxC = 40;
const int maxn = 3e5+114;
const int maxV = 1e7+114;
int a[maxn],n;
int val[maxn];
bitset<maxV+114> not_prime;
vector<int> C;
bitset<maxV+14> vis[maxC];
unordered_map<int,int,my_hash> cnt;
unordered_map<int,set<int> ,my_hash> R;
vector<int> pr;
void init(){
  for(int i=2;i<=maxV;++i){
    if(!not_prime[i]){
      pr.push_back(i);
    }
    for(int pri_j:pr){
      if(i*pri_j>maxV) break;
        not_prime[i*pri_j]=true;
        if(i%pri_j==0){
            break;
        }
    }
  }
  for(int i=maxV;i>=1;i--){
      if(not_prime[i]==false&&C.size()<maxC) C.push_back(i);
  }
  for(signed i=0;i<maxC;i++){
    for(signed j=1;j<C[i];j++){
      vis[i][(1ll*j*j)%C[i]]=1;
    }
  }
}
long long pre[maxC+114];
signed main(){
    read(n);
    for(int i=1;i<=n;i++) read(a[i]);
    init();
    a[0]=1;
    for(int i=0;i<maxC;i++) pre[i]=1;
    for(signed i=1;i<=n;i++){
        for(signed j=0;j<maxC;j++){
            int x=a[i];
            while((x-(x/C[j])*C[j])==0) x/=C[j];
            long long y=(x-(x/C[j])*C[j]);
            pre[j]=pre[j]*y-((pre[j]*y)/C[j])*C[j];
            if(vis[j][pre[j]]==1) val[i]+=(1ll<<j);
        }
    }
    val[0]=(1ll<<maxC)-1;
    int ans=0;
    int Out=0;
    for(int i=0;i<=n;i++) cnt[val[i]]++,R[val[i]].insert(i);
    for(int L=0;L<=n;L++){
        cnt[val[L]]--;
        ans+=cnt[val[L]];
    }
    write(ans);
    putchar('\n');
    for(int L=0;L<=n;L++){
        R[val[L]].erase(L);
        for(int rt:R[val[L]]){
            Out++;
            write(L+1);
            putchar(' ');
            write(rt);
            putchar('\n');
            if(Out==100000) return 0;
        }
    }
    return 0;
}
```




---

## 作者：chenyn2008 (赞：3)

**题意：给定序列 $a$，求出有多少对区间的乘积为完全平方数。**

注意 $n\le3\times10^5,a_i\le 10^{36}$。

首先我们有个非常简单的想法，对每个数质因数分解，对质数随机赋权值，然后维护异或前缀和，用 map 统计答案。（类似于[P10724 [GESP202406 七级] 区间乘积](https://www.luogu.com.cn/problem/P10724）)的做法）。

但是 $a_i$ 过大，无法质因数分解，这时候就要转换一下思路。

考虑一个平方数 $n$，模 $p$ 后在模 $p$ 意义下显然是个二次剩余。而且二次剩余乘上非二次剩余是非二次剩余，二次剩余乘上二次剩余是二次剩余，非二次剩余乘上非二次剩余是非二次剩余。

这是因为二次剩余 $a^{\frac{p-1}{2}}\equiv 1\pmod{p}$，非二次剩余 $a^{\frac{p-1}{2}}\equiv -1\pmod{p}$，两者相乘的值一定为 1 或 -1，这种运算类似于异或。

回到这道题，可以随机找 60 个 1e7 范围内的质数，判断一段区间是否为平方数转变为在模 $p$ 意义下区间的积是否为二次剩余，可以用上面异或的方法判断。在 60 个质数的情况下，有极大概率就能通过这样判断是否符合条件。

设在模 $p$ 意义下，是二次剩余记为 0，是非二次剩余记为 1。对于每个 $a_i$ 都判断一下，将这 60 个状态压成一个数，记录序列的异或前缀和 $s_i$ 。如果区间 $[l,r]$ 的积是平方数，那么 $s_r \operatorname{xor} s_{l-1}$ 为 0。

当然，$a_i$ 有可能是 $p$ 的倍数，那就让 $a_i$ 除尽 $p$，因子 $p$ 个数的奇偶性在取 60 次的情况下对 $a_i$ 是否为二次剩余影响不大。

然后用 map 记录一下当前异或前缀和的个数，统计答案时就加上这个值。

记得要预处理出质数的所有二次剩余，不然判断还会多个 $\log$。复杂度为 $O(T(n+P))$，其中 $T$ 为 60。

至于为什么要是 60 次参考[这篇文章](https://www.luogu.com.cn/discuss/955515)。

hack数据把质数全是 1e5 以内的方法卡了（貌似？），所以可以取 1e7。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=1e7;
const double pi=acos(-1.0);
const double eps=1e-6;
// const int mod=998244353;
typedef unsigned long long ull;
typedef __int128 ill;
typedef pair<int,int> pii;
mt19937 Rand(15656102);
inline ill read(){
    char ch;ill x=0;ill flag=1;
    while((ch=getchar())<'0'||ch>'9')
        if(!(ch^45)) flag=-1;
    while(ch>='0'&&ch<='9')
        x=(x<<1ull)+(x<<3ull)+(ch^48),ch=getchar();
    return x*flag;
}//用__int128读入
int n,mod;
ill a[300005];
bool ispri(int x){
    for(int i=2;i*i<=x;i++)
        if(x%i==0) return 0;
    return 1; 
}//判断是否为质数
bool is[10000005];
int sum[500005];
unordered_map<int,vector<int>> mp;
int get(){
    int num=Rand()%MAXN+1;
    while(!ispri(num))
        num=Rand()%MAXN+1;
    return num;
}//找质数
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL),cout.tie(NULL);
    n=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    for(int T=0;T<60;T++){
        memset(is,0,sizeof(is));
        mod=get();
        for(int i=1;i<mod;i++)
            is[i*i%mod]=1;//预处理出二次剩余
        for(int i=1;i<=n;i++){
            ill x=a[i];
            while(x%mod==0)
                x/=mod;
            if(!is[x%mod])
                sum[i]|=(1ull<<T);//压缩状态
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
        sum[i]^=sum[i-1];
    for(int i=0;i<=n;i++){
        ans+=mp[sum[i]].size();
        mp[sum[i]].push_back(i);
    }
    cout<<ans<<'\n';
    int num=0;
    for(int i=0;i<=n&&num<1e5;i++){
        for(int j:mp[sum[i]]){
            if(num>=1e5)
                return 0;
            if(j>i){
                cout<<i+1<<' '<<j<<'\n';
                num++;
            }
        }
    }//输出前1e5个答案
    return 0;
}
```

---

## 作者：WorldMachine (赞：2)

都去听 [IF](https://www.bilibili.com/video/BV1DB4y1C7x2)！

非常神秘的人类智慧题。

如果值域不大，可以对每个数做素因子分解，那就要求区间内每个素数必须出现偶数次，做异或和哈希即可。

但出题人目的明确地将值域开到了 $10^{36}$，这样上面的做法就死了。

平方数考虑变成二次剩余，找一个大素数 $p$，要求和每个 $a_i$ 都互素。由于二次剩余与非二次剩余之间的乘法很像异或，故考虑判断每一个数是否是二次剩余，是的话就给该位置赋值成 $0$，否则赋值成 $1$。这样一个区间合法的必要条件就是区间异或和为 $0$，需要多做个几遍，时间复杂度为 $\mathcal O(Tn\log V)$，大概是过不去的。

要把这个 $\log V$ 干掉，唯一的方法就是 $\mathcal O(p)$ 预处理出所有二次剩余，这样 $p$ 不能开得太大，不好保证和所有的 $a_i$ 均互素，不过没关系，直接把所有的 $p$ 因子除干净也是一样的，这样复杂度就是 $\mathcal O(Tn)$，$T$ 可以开到 $64$，正确性还是可以的。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
typedef __int128 lll;
const int N = 300005, V = 5e6, K = 1e5;
int n; ull b[N], ans; lll a[N], x; bool flg[V]; mt19937 rnd(time(0)); unordered_map<ull, basic_string<int> > mp;
lll read() { lll x = 0; char c = '%'; while (c < '0' || c > '9') c = getchar(); while (c >= '0' && c <= '9') x = x * 10 - '0' + c, c = getchar(); return x; }
bool isp(int x) { if (x <= 1) return 0; for (int i = 2; i * i <= x; i++) if (!(x % i)) return 0; return 1; }
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int t = 0, p; t < 64; t++) {
		p = 0; while (!isp(p)) p = rnd() % V + 1;
		memset(flg, 0, sizeof(flg)); for (int i = 1; i < p; i++) flg[(ull)i * i % p] = 1;
		for (int i = 1; i <= n; i++) {
			x = a[i]; while (!(x % p)) x /= p;
			if (!flg[x % p]) b[i] |= 1ull << t;
		}
	}
	mp[0].push_back(0);
	for (int i = 1; i <= n; i++) b[i] ^= b[i - 1], ans += mp[b[i]].size(), mp[b[i]].push_back(i);
	printf("%llu\n", ans), ans = 0;
	for (int i = 0; i < n && ans < K; i++) {
		for (int j : mp[b[i]]) if (j > i) { printf("%d %d\n", i + 1, j), ans++; if (ans >= K) break; }
	}
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

蓝的盆。

$a_i\leq 10^{36}$，这连一次质因数分解都做不了，启示我们找一些快速地判断方法。

平方数……快速……这启示我们想到**二次剩余**！

勒让德记号具有非常优秀的性质！

1. 它是完全积性的（用定义 $\left(\dfrac a p\right)\equiv a^{\frac{p-1}2}\pmod p$ 可证）
2. 二次互反律：$p$，$q$ 为不同的**奇**质数时，$\left(\dfrac pq\right)\left(\dfrac qp\right)=(-1)^{\frac{(p-1)(q-1)}{4}}$
3. $x$为奇数，$\left(\dfrac 2x\right)=(-1)^{\frac{x^2-1}{8}}$

然后因为性质 $1$，我们可以随机 $B$ 个质数然后用个 $\operatorname{xor-hash}$ 判断。

有个用二次互反律的 *Binary Jacobi* 算法，这个比快速幂快 $\frac{1}{3}$：

<https://www.luogu.com.cn/discuss/763591>

$$\left( \dfrac{p}{q} \right)=\left( \dfrac{p'\times 2^k}{q}\right)=\left(\dfrac{p'}{q}\right)\times\left(\dfrac{2^k}{q}\right)$$

$$=(-1)^{\frac{k(q^2-1)}{8}}(-1)^{\frac{(p'-1)(q-1)}{4}}\left(\dfrac{q}{p'}\right)$$

递归下去就行。


这样本题即可通过。

---

## 作者：DengDuck (赞：1)

首先分解质因数的时间复杂度为 $\mathcal O(n^{\frac 1 4})$，一个数字都分解不了，所以尝试看每个质因数系数的做法都是错误的。

这个时候就需要一个 Trick，因为平方数对于任意奇质数必然是一个二次剩余，除非是这个奇质数的倍数。

然后你就考虑，对于每个数字，如果是二次剩余就记为 $1$，如果不是二次剩余就记为 $0$，然后我们认为一个异或和为 $0$ 的区间是一个平方数区间。

仔细分析，我们只能保证平方数可以符合条件，不能保证符合的都是平方数，甚至难以保证大多数是平方数，因为这个处理阉割地太严重了。

我们直接上 $60$ 个质数，每个质数的结果为一位就行。（这个方法的精准度确实很低，但是耐不住你质数多）。

但是这真不是玄学做法吗/kk。

$\text{Konjac\_HZX}$ 表示：这就是个错题，没有正确做法。

## 更正

这个好像是有正确性的。

![](https://cdn.luogu.com.cn/upload/image_hosting/x1seqbu7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/bxad84mz.png)

tzl 老师在评论也说的很清楚了。
```cpp
#include<bits/stdc++.h>
#define LL long long
#define Int __int128
#define pb push_back
#define pLL pair<LL,LL>
#define fir first
#define sec second
using namespace std;
const LL N=3e5+5;
const LL K=60;
const LL M=6e6+20;
bool b[K+5][M];
LL P[K+5];
void prework()
{
    P[1]=264577,P[2]=124493,P[3]=7393,P[4]=101399,P[5]=270737;
    P[6]=5000011,P[7]=47857,P[8]=21061,P[9]=280249,P[10]=207073;
    P[11]=4000037,P[12]=158909,P[13]=85009,P[14]=282053,P[15]=64063;
    P[16]=156491,P[17]=95527,P[18]=229351,P[19]=284191,P[20]=36293;
    P[21]=196379,P[22]=325943,P[23]=117331,P[24]=197147,P[25]=244129;
    P[26]=233071,P[27]=275881,P[28]=335123,P[29]=379319,P[30]=319351;
    P[31]=354643,P[32]=258971,P[33]=319673,P[34]=372707,P[35]=224351;
    P[36]=365441,P[37]=238747,P[38]=124231,P[39]=181603,P[40]=285983;
    P[41]=294347,P[42]=59957,P[43]=195737,P[44]=141707,P[45]=247771;
    P[46]=353699,P[47]=233881,P[48]=242243,P[49]=340559,P[50]=198593;
    P[51]=54941,P[52]=4999307,P[53]=4999301,P[54]=4999297,P[55]=4999273;
    P[56]=4999243,P[57]=4999237,P[58]=4999231,P[59]=4999217,P[60]=6000011;
    //From Konjac_HZX
    for(int i=1;i<=K;i++)
    {
        for(LL j=1;j<=P[i];j++)b[i][j*j%P[i]]=1;
    }
}
Int read()
{
    Int res=0;
    char c=getchar();
    while(c<'0'||'9'<c)c=getchar();
    while('0'<=c&&c<='9')
    {
        res=res*10+c-'0';
        c=getchar();
    }
    return res;
}
LL n;
Int a[N],S[N],val[N];
map<Int,vector<LL> >ma;
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)a[i]=read();
    prework();
    a[0]=1;
    for(int j=1;j<=K;j++)
    {
        S[j]=1;
        for(int i=1;i<=n;i++)
        {
            Int x=a[i];
            while(x%P[j]==0)x=x/P[j];
            Int t=x%P[j];
            S[j]=S[j]*t%P[j];
            val[i]=val[i]*2+b[j][S[j]];
        }
    }
    val[0]=(1ll<<K)-1;
    LL ans=0;
    for(int i=0;i<=n;i++)
    {
        ans+=ma[val[i]].size();
        ma[val[i]].pb(i);
    }
    printf("%lld\n",ans);
    LL cnt=1e5;
    for(int l=1;l<=n;l++)
    {
        auto &p=ma[val[l-1]];
        p.erase(p.begin());
        for(LL r:p)
        {
            printf("%lld %lld\n",l,r);
            cnt--;
            if(!cnt)break;
        }
        if(!cnt)break;
    }
}
//RP++
```

---

## 作者：Nygglatho (赞：0)

先从一个数入手，注意到一个完全平方数 $a_i$ 的性质：对于所有满足 $\gcd(a_i,p)=1$ 的 $p$，都存在整数 $x$ 使得 $x^2\equiv a_i\pmod p$。

这是 [二次剩余](https://oi-wiki.org/math/number-theory/quad-residue/) 的形式，考虑使用 Euler 判别法。

具体地，随机一个满足 $\gcd(a_i,p)=1$，即 $p\nmid a_i$ 的奇质数 $p$，如果 $a_i^{\tfrac{p-1}{2}}\equiv 1\pmod p$，则说明 $a_i$ 是 $p$ 的二次剩余，否则不是。

由于对于一个奇质数 $p$，其恰好有 $\dfrac{p-1}{2}$ 个非 $0$ 二次剩余，因此，每一次判断到一个非完全平方数时，都有大约 $\dfrac{1}{2}$ 的概率为 $p$ 的二次剩余。所以需要随机 $60$ 个质数 $p$，这样，对于每一个数，不是完全平方数，但是是所有随机的 $p$ 的二次剩余的概率近似为 $0$。

随机质数可以直接随机一个数，成功随到的概率为 $\dfrac{1}{\ln v}$，其中 $v$ 是随机的值域，这道题可以选定为 $5\times 10^7$。判断随机的是否为质数可以使用 Miller-Rabin 来判别。此外，对于 $p\nmid a_i$ 这个条件，可以在最后直接将 $a_i$ 除以 $p$ 直到 $p\nmid a_i$。这不影响正确性。

---

接下来考虑一个区间乘积是否是完全平方数，由于对于 $p\nmid a_i$ 的奇质数 $p$，如果 $a_i$ 不是 $p$ 的二次剩余，则 $a_i^{\tfrac{p-1}{2}}\equiv -1\pmod p$。如果两个数 $a_i,a_j$ 均不是 $p$ 的二次剩余，显然 $a_i^{\tfrac{p-1}{2}}\cdot a_j^{\tfrac{p-1}{2}}\equiv 1\pmod p$。也就是说，$a_i\cdot a_j$ 是 $p$ 的二次剩余。更进一步地，如果有 $k$ 个数不是 $p$ 的二次剩余，如果 $k$ 是奇数，则其乘积不是 $p$ 的二次剩余，否则是 $p$ 的二次剩余。

那么，设 $f_i$ 二进制第 $k$ 位表示 $a_i$ 是否**不是**随机的第 $k$ 个 $p$ 的二次剩余（值为 $1$ 不是，为 $0$ 是二次剩余），那么 $[l,r]$ 如果是完全平方数，则需要满足 $\bigoplus\limits_{i=l}^r f_i =0$（$\oplus$ 表示异或）。

这是比较好做的，令 $s_i$ 表示 $\bigoplus\limits_{j=1}^i f_j$，特别地，$s_0=0$。同时令 $\mathit{cnt}_i\gets\sum\limits_{j=1}^n [i=s_j]$。则答案的贡献为 $\sum\limits_{i=1}^{2^{60}}\dbinom{\mathit{cnt}_i}{2}$。

由于 $\ne 0$ 的 $\mathit{cnt}_i$ 值不超过 $n$，所以将 $s_i$ 离散化之后就可以求出来答案。

```cpp
#include "bits/stdc++.h"
#include "ext/pb_ds/hash_policy.hpp"
#include "ext/pb_ds/assoc_container.hpp"
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define ll long long
#define ull unsigned long long

#define OPEN freopen (".in", "r", stdin); freopen (".out", "w", stdout);
#define DATA freopen (".in", "w", stdout);

#define pc __builtin_popcount
#define db double
#define pii pair<int, int>
#define fi first
#define se second

#define F(i,x,y) for (int i = (x); i <= (y); ++i)
#define D(i,x,y) for (int i = (x); i >= (y); --i)

using namespace std;

const ll inf = 1ll * 1e18;
const ll mod = 998244353ll;
//const ll mod = 1ll * 1e9 + 7ll;

namespace FastIO {
	inline void Rd(__int128& x) {
		__int128 f = 1;
		x = 0;
		char c = getchar();
		while (c < '0' || c > '9') {
			if (c == '-') f = -1;
			c = getchar();
		}
		while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c - 48), c = getchar();
		x *= f;
	}

    inline void Rd(int& x) {
		int f = 1;
		x = 0;
		char c = getchar();
		while (c < '0' || c > '9') {
			if (c == '-') f = -1;
			c = getchar();
		}
		while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c - 48), c = getchar();
		x *= f;
	}

	inline void Wt(__int128 x) {
		if (x < 10) {
			putchar(x + 48);
			return;
		}
		Wt(x / 10);
		putchar((x % 10) + 48);
	}

    inline void Wt(ll x) {
		if (x < 10ll) {
			putchar(x + 48);
			return;
		}
		Wt(x / 10ll);
		putchar((x % 10) + 48);
	}
}

namespace Maths {
	ll fac[560000];

	void init() {

		fac[0] = 1ll;

		F(i, 1, 500000) fac[i] = fac[i - 1] * i % mod;
	}

	ll qpow(ll x, ll y) {
		if (y == 0ll) return 1ll;

		ll w = qpow(x, y / 2ll);

		if (y % 2ll) return (w * w % mod) * x % mod;
		else return w * w % mod;
	}

	inline ll C(ll x, ll y) {
		return (fac[x] * qpow(fac[y], mod - 2ll) % mod) * qpow(fac[x - y], mod - 2ll) % mod;
	}

	inline ll div(ll x) {
		return qpow(x, mod - 2ll);
	}
}
using namespace __gnu_pbds;
constexpr ll _pr[] = {0, 2, 325, 9375, 28178ll, 450775ll, 9780504ll, 1795265022ll};

ll qpow(ll x, ll y, ll p) {
	if (y == 0ll) return 1ll;

	ll w = qpow(x, y / 2ll, p);

	if (y % 2ll) return (w * w % p) * x % p;
	else return w * w % p;
}

__int128 qpow (__int128 x, ll y, ll p) {
    if (y == 0ll) return 1;
    __int128 w = qpow (x, y / 2ll, p);

    if (y % 2ll) return (w * w % p) * x % p;
    else return w * w % p;
}

int MillerRabin (ll p) {
    if (p < 3ll || p % 2ll == 0ll) return (p == 2ll);
    if (p % 3ll == 0ll) return (p == 3ll);
    ll tg = p - 1;
    int tim = 0;
    while (tg % 2ll == 0ll) ++ tim, tg /= 2ll;
    F (i, 1, 7) {
        __int128 bs = _pr[i], v = qpow (bs, tg, p);
        if (v == 1ll) continue;
        int flg = 1;
        F (j, 1, tim) {
            if (v == __int128(p - 1ll)) {flg = 0; break;}
            v = v * v % p;
        }
        if (flg) return 0;
    }
    return 1;
}

ll p[65];

mt19937 rng(time(NULL));

gp_hash_table <ll, int> mp;

int tot;

__int128 a[310000];
ll ans;
ll tag[310000];

vector <int> v[310000];

int main() {
    F (i, 0, 59) {
        while (1) {
            ++ tot;
            p[i] = rng() % 50000000ll;
            if (MillerRabin(p[i])) break;
        }
    }
    int n; FastIO::Rd(n);
    F (i, 1, n) FastIO::Rd(a[i]);

    F (i, 1, n) {
        F (j, 0, 59) {
            while (a[i] % p[j] == 0ll) a[i] /= p[j];
            if (qpow (a[i] % p[j], (p[j] - 1) / 2ll, p[j]) == __int128(p[j] - 1ll)) tag[i] += (1ll << (1ll * j));
        }
    }

    F (i, 1, n) tag[i] ^= tag[i - 1];
    mp[0] = 1; v[1].push_back(0);
    int cnt = 1;
    F (i, 1, n) {
        if (! mp[tag[i]]) mp[tag[i]] = ++ cnt;
        v[mp[tag[i]]].push_back(i);
    }
    F (i, 1, cnt) ans += (1ll * v[i].size() * (long long)(v[i].size() - 1ll)) / 2ll;
    int lim = 100000;
    FastIO::Wt(ans); putchar ('\n');
    F (i, 0, n - 1) {
        for (auto j : v[mp[tag[i]]]) {
            if (j <= i) continue;
            FastIO::Wt(1ll * (i + 1)); putchar(' '); FastIO::Wt(1ll * j); putchar('\n');
            if ((-- lim) <= 0) return 0;
        }
    }
}
```

---

## 作者：littlez_meow (赞：0)

一个很好玩的 trick.

[题目指路](https://www.luogu.com.cn/problem/P10063)。

## 思路

首先 $10^{36}$ `Pollard-Rho` 分解都跑不过去。利用所有质因数次数均为偶数的做法肯定没了。

还有什么和二次有关的？二次剩余。平方数在任意模数下均为二次剩余。

模 $p$ 意义下二次剩余有 $\dfrac {p-1}2$ 个，也就是说，选 $O(\log p)$ 个质数，错误的概率是可以接受的。

根据勒让德符号，如果记 $1$ 为非二次剩余，$0$ 为二次剩余，那么其满足异或的运算律。我们按照上面的方式把每个数是否是选出质数的二次剩余压成一个二进制数，求前缀异或和 $s$，则 $[l,r]$ 满足题目要求等价于 $s_{l-1}=s_r$，用哈希表或者 `map` 都可以。

至于判断是否是二次剩余，可以用欧拉判别法，即勒让德符号 $\left(\dfrac a p\right)\equiv a^{\frac{p-1}2}\pmod p$。

但是若 $p|a$，勒让德符号变成 $0$，就没有办法判断了。不过，由于平方数质因数次数均为偶数，把 $p$ 除掉也不影响。

注意到质数很小时容易被卡，质数可以稍微选大一点，到 $10^9$ 量级。

时间复杂度 $O(n\log^2p)$。

## 代码

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
using namespace std;
using namespace __gnu_pbds;
namespace IO{
	#define getchar() (p1==p2&&(p2=(p1=inbuf)+fread(inbuf,1,1<<22,stdin),p1==p2)?EOF:*p1++)
	#define putchar(c) (p3==p4&&(fwrite(outbuf,1,1<<22,stdout),p3=outbuf),*p3++=c)
	using namespace std;
	char inbuf[1<<22],outbuf[1<<22],*p1=inbuf,*p2=inbuf,*p3=outbuf,*p4=outbuf+(1<<22);
	inline __int128 input(){
		__int128 s(0);
		char ch=getchar();
		while(!isdigit(ch)) ch=getchar();
		while(isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
		return s;
	}
	inline void output(ll x){
		x>9&&(output(x/10),1);
		putchar((x%10)^48);
	}
	inline void output(int x){
		x>9&&(output(x/10),1);
		putchar((x%10)^48);
	}
}
using namespace IO;
const int CNT=50,MOD[CNT+1]={0,998244353,998244389,998244391,998244397,998244407,998244431,998244433,998244473,998244487,998244493,998244521,998244523,998244529,998244601,998244617,998244619,998244631,998244649,998244673,998244677,998244679,998244707,998244713,998244749,998244761,1000000007,1000000009,1000000021,1000000033,1000000087,1000000093,1000000097,1000000103,1000000123,1000000181,1000000207,1000000223,1000000241,1000000271,1000000289,1000000297,1000000321,1000000349,1000000363,1000000403,1000000409,1000000411,1000000427,1000000433,2147483647},MAXN=3e5+1;
__int128 A[MAXN];
ll xorsum[MAXN];
inline ll qpow(ll base,int expo,short num){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD[num]);
		base=base*base%MOD[num],expo>>=1;
	}
	return res;
}
int n,cnt;
gp_hash_table<ll,int>idx;
vector<int>pos[MAXN];
int main(){
	n=input();
	F(i,1,n){
		A[i]=input();
		F(j,1,CNT){
			__int128 x(A[i]);
			while(x%MOD[j]==0) x/=MOD[j];
			xorsum[i]|=(qpow(x%MOD[j],(MOD[j]-1)>>1,j)==MOD[j]-1)*1ll<<(j-1);
		}
	}
	F(i,1,n) xorsum[i]^=xorsum[i-1];
	F(i,0,n){
		int&t(idx[xorsum[i]]);
		if(!t) t=++cnt;
		pos[t].push_back(i);
	}
	ll ans(0);
	F(i,1,cnt){
		ll t(pos[i].size());
		ans+=t*(t-1)>>1;
	}
	output(ans);
	putchar('\n');
	int lim=1e5;
	F(i,0,n-1){
		int l=i+1;
		for(int r:pos[idx[xorsum[i]]]){
			if(r<=i) continue;
			output(l);
			putchar(' ');
			output(r);
			putchar('\n');
			--lim;
			if(!lim) break;
		}
		if(!lim) break;
	}
	fwrite(outbuf,1,p3-outbuf,stdout);
	return 0;
} 
```

不喜勿喷 qwq~

---


# [省选联考 2025] 追忆

## 题目背景

考虑到评测机性能差距，本题较官方赛事增加了 3 秒的额外时限。

我常常追忆过去。

生命瞬间定格在脑海。我将背后的时间裁剪、折叠、蜷曲，揉捻成天上朵朵白云。

云朵之间亦有分别：积云厚重，而卷云飘渺。生命里震撼的场景掠过我的思绪便一生无法忘怀，而更为普通平常的记忆在时间的冲刷下只留下些许残骸。追忆宛如入梦，太过清楚则无法愉悦自己的幻想，过分模糊却又坠入虚无。只有薄雾间的山水，面纱下的女子，那恰到好处的朦胧，才能满足我对美的苛求。

追忆总在不经意间将我裹进泛黄的纸页里。分别又重聚的朋友，推倒又重建的街道，种种线索协助着我从一个具体的时刻出发沿时间的河逆流而上。曾经的日子无法重来，我只不过是一个过客。但我仍然渴望在每一次追忆之旅中留下闲暇时间，在一个场景前驻足，在岁月的朦胧里瞭望过去的自己，感受尽可能多的甜蜜。美好的时光曾流过我的身体，我便心满意足。

过去已经凝固，我带着回忆向前，只是时常疏于保管，回忆也在改变着各自的形态。这给我的追忆旅程带来些许挑战。

我该在哪里停留？我问我自己。

## 题目描述

给定一个 $n$ 个点 $m$ 条边的有向图 $G$，结点由 $1$ 至 $n$ 编号。第 $i$ ($1 \leq i \leq m$) 条边从 $u_i$ 指向 $v_i$，保证 $u_i < v_i$。节点 $j$ ($1 \leq j \leq n$) 有两个权值 $a_j, b_j$，保证 $[a_1, \ldots, a_n]$ 与 $[b_1, \ldots, b_n]$ 均是 $1 \sim n$ 的排列。

你需要进行 $q$ 次操作。操作有以下三种:
- $1\ x\ y$：交换 $a_x$ 和 $a_y$；
- $2\ x\ y$：交换 $b_x$ 和 $b_y$；
- $3\ x\ l\ r$：你需要输出满足以下两个条件的点 $y$ 中 $b_y$ 的最大值，若不存在满足条件的点则输出 $0$：
  1. $l \leq a_y \leq r$。
  2. 图 $G$ 中存在一条 $x$ 到 $y$ 的有向路径，即存在整数 $k \geq 1$ 与 $k$ 个结点 $p_1, p_2, \ldots, p_k$，满足 $p_1 = x$，$p_k = y$，且对于所有 $1 \leq i < k$，图 $G$ 中存在从 $p_i$ 指向 $p_{i+1}$ 的有向边。特别地，图 $G$ 中总是存在一条 $x$ 到 $x$ 的有向路径。

## 说明/提示

**【样例 1 解释】**

该组样例共有 $1$ 组测试数据。该组测试数据共包含 $7$ 个操作。
- 对于第一个操作，所有满足条件的点为 $2, 4$，因此答案为 $\max\{b_2, b_4\} = 4$。
- 对于第二个操作，所有满足条件的点为 $3$，因此答案为 $b_3 = 2$。
- 对于第三个操作，交换 $a_1, a_4$ 后得到的权值序列 $a$ 为 $[1, 2, 3, 4]$。
- 对于第四个操作，所有满足条件的点为 $1, 2, 3$，因此答案为 $\max\{b_1, b_2, b_3\} = 3$。
- 对于第五个操作，交换 $b_2, b_4$ 后得到的权值序列 $b$ 为 $[1, 4, 2, 3]$。
- 对于第六个操作，所有满足条件的点为 $2, 3$，因此答案为 $\max\{b_2, b_3\} = 4$。
- 对于第七个操作，没有满足条件的点，因此答案为 $0$。

**【样例 2】**

见选手目录下的 recall/recall2.in 与 recall/recall2.ans。

该组样例满足测试点 $1 \sim 5$ 的限制。

**【样例 3】**

见选手目录下的 recall/recall3.in 与 recall/recall3.ans。

该组样例满足测试点 $7$ 的限制。

**【样例 4】**

见选手目录下的 recall/recall4.in 与 recall/recall4.ans。

该组样例满足测试点 $10 \sim 12$ 的限制。

**【样例 5】**

见选手目录下的 recall/recall5.in 与 recall/recall5.ans。

该组样例满足测试点 $13, 14$ 的限制。

**【样例 6】**

见选手目录下的 recall/recall6.in 与 recall/recall6.ans。

该组样例满足测试点 $18$ 的限制。

**【样例 7】**

见选手目录下的 recall/recall7.in 与 recall/recall7.ans。

该组样例满足测试点 $23 \sim 25$ 的限制。

**【子任务】**

对于所有测试点，
- $1 \leq T \leq 3$，
- $1 \leq n, q \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，
- $\forall 1 \leq i \leq m$，$1 \leq u_i < v_i \leq n$，
- $\forall 1 \leq i \leq n$，$1 \leq a_i \leq n$，且 $[a_1, \ldots, a_n]$ 是 $1 \sim n$ 的一个排列，
- $\forall 1 \leq i \leq n$，$1 \leq b_i \leq n$，且 $[b_1, \ldots, b_n]$ 是 $1 \sim n$ 的一个排列，
- $\forall 1 \leq i \leq q$，$o_i \in \{1, 2, 3\}$，$1 \leq x_i, y_i \leq n$，$1 \leq l_i \leq r_i \leq n$。

::cute-table{tuack}

| 测试点编号 | $n, q \leq$ | $m \leq$ | 特殊性质 |
|:------------:|:------------:|:----------:|:----------:|
| $1 \sim 5$| $2\,000$| $4\,000$| 无 |
| $6$| $8 \times 10^4$ | $1.6 \times 10^5$ | AB |
| $7$| $6 \times 10^4$ | $1.2 \times 10^5$ | B|
| $8, 9$ | $8 \times 10^4$ | $1.6 \times 10^5$ | ^ |
| $10 \sim 12$ | ^ | ^ | AC|
| $13, 14$ | $6 \times 10^4$ | $1.2 \times 10^5$ | A|
| $15, 16$ | $8 \times 10^4$ | $1.6 \times 10^5$ | ^ |
| $17$ | $6 \times 10^4$ | $1.2 \times 10^5$ | D |
| $18$ | $8 \times 10^4$ | $1.6 \times 10^5$ | ^ |
| $19, 20$ | $6 \times 10^4$ | $1.2 \times 10^5$ | 无 |
| $21, 22$ | $8 \times 10^4$ | $1.6 \times 10^5$ | ^ |
| $23 \sim 25$| $10^5$| $2 \times 10^5$ | ^ |

- 特殊性质 A：$\forall 1 \leq i \leq q, o_i \neq 1$。
- 特殊性质 B：$\forall 1 \leq i \leq q, o_i \neq 2$。
- 特殊性质 C：$\forall 1 \leq i \leq q, l_i = 1, r_i = n$。
- 特殊性质 D：保证在每个 $3$ 操作的时刻，$\forall 1 \leq i \leq n, a_i = b_i$。

**【提示】**

请注意本题特别的时空限制。

## 样例 #1

### 输入

```
0 1
4 4 7
1 2
1 3
2 4
3 4
4 2 3 1
1 3 2 4
3 2 1 3
3 3 2 4
1 1 4
3 1 1 3
2 2 4
3 1 2 3
3 4 1 1```

### 输出

```
4
2
3
4
0```

# 题解

## 作者：yuanruiqi (赞：90)

下面我将给出一个 $O(\frac{(m+q)n}{\omega}+q\sqrt{n})$ 的做法，考场大样例用时不到 2s。

将可达关系和询问区间都视作限制，我们首先尝试得到集合 $\set{i\mid x\to i}$ 与 $\set{i\mid a_i\in[l,r]}$ 的交，前者容易通过拓扑排序在 $O(\frac{nm}{\omega})$ 的复杂度下预处理。对后者使用根号分块维护。

将 $\set{i\mid a_i\in[l,r]}$ 视作 $\set{i\mid a_i\ge l}\setminus \set{i\mid a_i\ge r+1}$，即用两个后缀的异或表示。令块长 $s=\sqrt{n}$，分块维护根号个 bitset $A_x=\set{i\mid a_i\ge xs}$。于是单次修改是 $O(\sqrt{n})$ 的。单次查询后缀 $i$ 可以取出 $A_x$ 其中 $x=\lceil\frac{i}{s}\rceil$，并暴力加入满足 $b_j\in[i,xs)$ 的 $j$，复杂度为 $O(\frac{n}{\omega}+\sqrt{n})$。

令得到的限制集合为 $C$，求 $\max_{i\in C}b_i$。我们对 $b$ 维护相同的分块 $B_x=\set{i\mid b_i\ge xs}$，下面只需要找到 $\max_{|C\cap B_x|\neq 0} x$ 即最靠后的和 $C$ 有交的块，再块内枚举即可。

这里我的实现需要用到手写 bitset，并记 $C(x)$ 为 $C$ 中的第 $x$ 个 ull 表示的集合，同理有 $B_i(x)$。对于 $i$ 从 $0$ 到 $\lceil\frac{n}{\omega}\rceil$ 枚举 $C(i)$，并在过程中维护指针 $p$，表示 $C\cap [0,is)$ 和 $B$ 有交的最靠后的块的编号。若 $C(i)$ 与 $B_p(i)$ 无交则跳过，否则检查 $C(i)$ 和 $B_{p+1}(i)$ 是否有交，尝试更新 $p:=p+1$ 并继续检查，不难发现最终得到的 $p$ 即为所求。由于 ull 的单次求交是 $O(1)$ 的，共有 $O(\frac{n}{\omega}+\sqrt{n})$ 次检查交集，所以这部分复杂度同样是 $O(\frac{n}{\omega}+\sqrt{n})$。

下面是考场代码，没有细节，实现并不复杂。


```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using u64 = unsigned long long;
constexpr int maxn = 100000 + 10;
constexpr int len = 340;
constexpr int siz = 1570;
struct bitst
{
    u64 a[siz];
    void reset()
    {
        memset(a, 0, sizeof(a));
    }
    void set(int x)
    {
        a[(x >> 6)] |= 1ull << (x & 63);
    }
    void flip(int x)
    {
        a[(x >> 6)] ^= 1ull << (x & 63);
    }
    void operator|=(const bitst &b)
    {
        for (int i=0;i<siz;++i) a[i] |= b.a[i];
    }
    void operator^=(const bitst &b)
    {
        for (int i=0;i<siz;++i) a[i] ^= b.a[i];
    }
    void operator&=(const bitst &b)
    {
        for (int i=0;i<siz;++i) a[i] &= b.a[i];
    }
    int val(int x)
    {
        return a[x >> 6] >> (x & 63) & 1;
    }
};
bitst G[maxn];
bitst A[len], B[len];
vector<int> e[maxn];
#define lt(x) (!(x) ? 1 : (x) * len)
#define rt(x) (min(((x) * len + len - 1), n))
int a[maxn], b[maxn];
int ia[maxn], ib[maxn];
int n, m, q;
int idx;
void solve()
{
    cin >> n >> m >> q;
    for (int i=1;i<=n;++i) e[i].clear();
    for (int i=1;i<=m;++i)
    {
        int u, v;
        cin >> u >> v;
        e[u].emplace_back(v);
    }
    for (int i=n;i>=1;--i)
    {
        G[i].reset();
        G[i].set(i);
        for (int v : e[i]) G[i] |= G[v];
    }
    int k = 0;
    while (lt(k) <= n) ++k;
    for (int i=0;i<=k;++i) A[i].reset(), B[i].reset();
    for (int i=1;i<=n;++i) cin >> a[i], ia[a[i]] = i;
    for (int i=1;i<=n;++i) cin >> b[i], ib[b[i]] = i;
    for (int i=1;i<=n;++i) A[a[i] / len].set(i), B[b[i] / len].set(i);
    for (int i=k-2;i>=0;--i) A[i] |= A[i + 1], B[i] |= B[i + 1];
    while (q--)
    {
        int o;
        cin >> o;
        if (o == 1)
        {
            int x, y;
            cin >> x >> y;
            int l = a[x] / len, r = a[y] / len;
            if (l > r) swap(l, r);
            for (int i=l+1;i<=r;++i) A[i].flip(x), A[i].flip(y);
            swap(a[x], a[y]);
            swap(ia[a[x]], ia[a[y]]);
        }
        else if (o == 2)
        {
            int x, y;
            cin >> x >> y;
            int l = b[x] / len, r = b[y] / len;
            if (l > r) swap(l, r);
            for (int i=l+1;i<=r;++i) B[i].flip(x), B[i].flip(y);
            swap(b[x], b[y]);
            swap(ib[b[x]], ib[b[y]]);
        }
        else
        {
            int x, l, r;
            cin >> x >> l >> r; ++r;
            int y = (r + len - 1) / len;
            bitst u = A[y];
            y = min(n + 1, len * y);
            for (int i=r;i<y;++i) u.set(ia[i]);
            y = (l + len - 1) / len;
            u ^= A[y];
            y = min(n + 1, len * y);
            for (int i=l;i<y;++i) u.flip(ia[i]);
            u &= G[x];
            int p = 0;
            for (int i=0;i<siz&&p<k-1;++i)
            {
                while (u.a[i] & B[p + 1].a[i]) ++p;
            }
            l = lt(p); r = rt(p);
            int ans = 0;
            for (int i=r;i>=l;--i) if (u.val(ib[i]))
            {
                ans = i;
                break;
            }
            cout << ans << '\n';
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int c, t;
    cin >> c >> t;
    while (t--) solve();
    return 0;
}

```

---

## 作者：Z_301 (赞：51)

这里有一个简单的 $O(\frac {mq}w)$ 做法，其中 $w=64$ 。

考虑每 $w$ 个操作分组。

考虑询问，把 $y$ 分为两种：在 $w$ 个操作中修改过的，以及没有修改过的。修改过的部分可以直接枚举 $y$ 暴力计算，主要考虑没有修改过的部分。

考虑对于个每个点 $u$ ，求出 $f_{u,i}$ 表示第 $i$ 个询问对应的 $x$ 能不能到 $u$ 。可以发现这个可以通过把 $f_u$ 压进一个 `unsigned long long` ，做到 $O(m)$ 求出。对于修改过的部分，可以直接利用 $f$ 的结果 $O(1)$ 判断 $x$ 能否到 $y$ 。

考虑 $l\le a_y\le r$ 的限制，维护 $g_{i,j}$ 表示是否有 $l_j\le i\le r_j$ ，同样可以压位，再使用异或差分，可以做到 $O(n)$ 。

对于一个点 $u$ ，发现会对 $f_u\cap g_{a_u}$ 内的询问有贡献。把所有点按 $b$ 从大到小排序，每次把没访问过的询问答案设为当前的 $b$ ，以后就可以不动了。具体地，可以维护一个 `unsigned long long` ，第 $i$ 位表示第 $i$ 个询问是否已经获取到答案，每次和当前点能贡献到的取交，即可获取到要覆盖的询问。

一共会做 $O(\frac{q}{w})$ 次。复杂度 $O(\frac{(n+m)q}{w})$ 。

代码可以参考 [UOJ 上的提交](https://uoj.ac/submission/743788) 。

题外话：有一个题叫 [QOJ 4420](https://qoj.ac/problem/4420) ，和这题非常像，题意是多次查询 $(x,y,l,r)$ 表示问 $x$ 只经过编号在 $[l,r]$ 的边能不能到达 $y$ 。做法和这题几乎一样，大家可以做一下（）

---

## 作者：larsr (赞：32)

被卡常了，导致失去 12 分，并且为了卡常 T3 没时间打部分分了。

首先可以使用 bitset 计算每个点之间的到达关系，复杂度 $O(\frac{nm}{w})$。

考虑分块，先对操作进行分块，每一个询问块内有变化的点到询问的时候再考虑对答案的贡献。对于没有变化的点可以预处理出来，将序列 $a$ 的值域分块，计算出每个点可到达的点在每个块内的 $b$ 的最大值。

设询问每 $B$ 个一块，值域每 $B$ 个一块，时间复杂度 $O(\frac{n^2m}{B^2}+n(B+\frac{m}{B}))$，计算可得 $B=n^{\frac{2}{3}}$ 最优，总时间复杂度 $O(\frac{nm}{w}+n^{\frac{5}{3}})$。

---

## 作者：_determination_ (赞：25)

首先谴责一下这个民间数据啊，$O(nq)$ 给我跑了 76pts。然后块长调错复杂度烂完给过了。

$O(\frac{n^2}{w})$ 求传递闭包（图是拓扑图！），然后我们首先要求出 $a_i \in [l,r]$ 的 $i$ 的 bitset。

考虑分块。每个块维护这个块及以后所有点的 bitset，即 $f_{[l,r]}$ 是所有满足 $a_i\ge l$ 的 $i$ 构成的 bitset。内部则维护块内点的后缀并。

对于修改操作，由于 $a$ 是排列，直接暴力修改即可做到 $O(\sqrt{n})$。查询操作是直接合并整块的 bitset 并插入散块，是 $O(\frac{n}{w}+\sqrt{n})$ 的。

这个部分的时间复杂度是 $O(q(\sqrt{n}+\frac{n}{w}))$。

那么现在，我们就可以求出每个查询的有效点集合了。现在的问题是怎样求其中的 $\max b$。

对于 $b$ 我们类似的分块，$g_{[l,r]}$ 是所有满足 $b_i\ge l$ 的 $i$ 构成的 bitset。查询的求最大的 $x$ 使得 $b_i \ge x$ 的 $i$ 构成的 bitset 与有效点有交。$O(\frac{n\sqrt{n}}{w})$。

注意到我们散块和整块的复杂度极度不平衡，仔细分析一下：

* 对于整块，复杂度 $O(\frac{n^2}{Bw})$。修改复杂度为 $O(\frac{n}{B})$。

* 对于散块，修改和查询都是 $O(B)$。

取 $B=10000$，随便跑啊。

[AC Link.](https://www.luogu.com.cn/record/205805945)

更新：官方数据不是出来了吗，太恐怖了，给我原来的代码干 T 了，加一点小卡常就好了（甚至可以说是一些常识？）

1. 去掉 `#define int long long`。
2. `#define endl '\n'`。

[AC Link.](https://www.luogu.com.cn/record/206222406) 也就 2k 出头，不长的。

```cpp
#include<bits/stdc++.h>
// #define int long long
#define endl '\n'
using namespace std;
const int mod=998244353,inf=0x3f3f3f3f3f3f3f3f;
const int N=1e5+10,M=2e5+10;
bitset<N>to[N];
vector<int>e[N];
int n,m,q;
const int B1=400,B2=10000;
bitset<N>f[N/B1+10];
bitset<N>g[N/B2+10];
int fid[N],gid[N];
int a[N],b[N],br[N],ar[N];
void solve()
{
	cin >> n >> m >> q;
	for ( int i = 1 ; i <= n ; i++ )
		e[i].clear(),to[i]=0;
	for ( int i = 1 ; i <= n ; i++ )
		to[i][i]=1;
	while(m--)
	{
		int u,v;cin >> u >> v;
		e[u].push_back(v);
	}
	for ( int i = 1 ; i <= n ; i++ ){
		cin >> a[i];ar[a[i]]=i;
	}
	for ( int i = 1 ; i <= n ; i++ ){
		cin >> b[i];br[b[i]]=i;
	}
	for ( int i = n ; i >= 1 ; i-- )
		for ( auto v:e[i] )to[i]|=to[v];
	for ( int i = 1 ; i <= n+1 ; i++ )
		fid[i]=(i+B1-1)/B1,
		gid[i]=(i+B2-1)/B2;
	for ( int i = 1 ; i <= fid[n]+1 ; i++ )f[i]=0;
	for ( int i = 1 ; i <= gid[n]+1 ; i++ )g[i]=0;
	for ( int i = 1 ; i <= n ; i++ )
		f[fid[a[i]]][i]=1,
		g[gid[b[i]]][i]=1;
	for ( int i = fid[n]-1 ; i >= 1 ; i-- )
		f[i]|=f[i+1];
	for ( int i = gid[n]-1 ; i >= 1 ; i-- )
		g[i]|=g[i+1];
	while(q--)
	{
		int op,x,y,l,r;
		cin >> op;
		if(op==1)
		{
			cin >> x >> y;
			for ( int i = 1 ; i <= fid[a[x]] ; i++ )f[i][x]=0;
			for ( int i = 1 ; i <= fid[a[y]] ; i++ )f[i][x]=1;
			for ( int i = 1 ; i <= fid[a[y]] ; i++ )f[i][y]=0;
			for ( int i = 1 ; i <= fid[a[x]] ; i++ )f[i][y]=1;
			swap(a[x],a[y]);
			swap(ar[a[x]],ar[a[y]]);
		}else if(op==2){
			cin >> x >> y;
			for ( int i = 1 ; i <= gid[b[x]] ; i++ )g[i][x]=0;
			for ( int i = 1 ; i <= gid[b[y]] ; i++ )g[i][x]=1;
			for ( int i = 1 ; i <= gid[b[y]] ; i++ )g[i][y]=0;
			for ( int i = 1 ; i <= gid[b[x]] ; i++ )g[i][y]=1;
			swap(b[x],b[y]);
			swap(br[b[x]],br[b[y]]);
		}else{
			cin >> x >> l >> r;
			bitset<N>toa;toa=0;
			toa=f[fid[l]+1];
			for ( int i = l ; i <= min(n,fid[l]*B1) ; i++ )
				toa[ar[i]]=1;
			toa^=f[fid[r+1]+1];
			for ( int i = r+1 ; i <= min(n,fid[r+1]*B1) ; i++ )
				toa[ar[i]]=1-toa[ar[i]];
			toa&=to[x];
			int flg=0;
			for ( int i = gid[n] ; i >= 1 ; i-- )
			{
				if((g[i]&toa).size())
				{
					for ( int j = min(n,i*B2) ; j >= (i-1)*B2+1 ; j-- )
						if(toa[br[j]])
						{
							flg=1;
							cout << j << endl;
							break;
						}
				}
				if(flg)break;
			}
			if(!flg)cout << 0 << endl;
		}
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int c,T;cin >> c >> T;
	while(T--)solve();
	return 0;
}
```

---

## 作者：KobeBeanBryantCox (赞：18)

# P11831 [省选联考 2025] 追忆 题解

----------------

[题目传送门](https://www.luogu.com.cn/problem/P11831)。

**本篇题解代码删缺省原后百行以内，压行少，带注释，思路清晰好想，有多种版本的代码。**

update on 2025-03-05：修改了之前不正确的时间复杂度计算，并且对应地修改了块长，使其理论上最优。感谢 [_determination_](https://www.luogu.com.cn/user/530468) 大佬。

话说我从来没有想过 bitset 能成为正解，一般来讲它都是用来乱搞的。

> 我常常追忆过去。

-----------------

## 题意

请略去题目背景，然后看题目描述，非常简洁，我就不概括了。

-----------------

## 思路

借鉴了[这篇题解](https://www.luogu.com.cn/article/zp7kytuw)的思路，但略有不同。如侵权请联系删除相关表述。

-----------------

### $\texttt{step 1:init}$

首先我们要知道题目给的是 DAG，我考场的时候就没看到，还像奶龙一样傻乎乎地缩点。

然后发现我们居然做不出来，所以可以考虑用 bitset 乱搞。

然后注意到 DAG 的任意两点可达性我们是需要知道的。

我们**设集合 $f_i$ 表示 $i$ 能到达的点集**。

按照拓扑排序的倒序（即**做反图的拓扑排序**）用 bitset 递推即可。

时间复杂度 $O(\dfrac{nm}w)$。

---------------

### $\texttt{step 2:query}$

原题的查询变为 $\max_{i\in f_x\cap A}b_i$，其中 $A=\{i|a_i\in[l,r]\}$。

为了求出 $A$，我们对值域分块，设块长为 $B$，每一个块就是 $[iB,(i+1)B)$。

我们**设集合 $fa_i=\{j|a_j\in[iB,n]\}$**，这样的集合有 $\dfrac n B$ 个，故可以用 $O(n\times\dfrac n B)$ 的时间复杂度推出，可能需要维护一下 $a$ 数组的逆来更方便地处理（“逆”部分具体看代码）。

然后 $[l,r]$ 就被分为整块和散块，整块的部分由两个 $fa$ **异或**可以得到，散块的部分枚举整个块**暴力加入**，这样得到了 $A$。

得到一次 $A$ 的时间复杂度是 $O(B+\dfrac n w)$。

我们需要找出 $ans=\max_{i\in f_x\cap A}b_i$。

由于我们对值域分块，我们**考虑求出 $ans$ 在哪个块**，然后在这个块内**暴力查找**每一个元素的 $i$（即输入时的编号）看是否在 $f_x\cap A$ 中。

考虑怎么找到 $ans$ 在哪一个块。我们**找到最大的 $p$，使得 $\{j|b_j\in[pB,n]\}\cap(f_x\cap A)\not=\varnothing$**。

所以我们同样要用相同的方法维护 $fb$。

然后**二分 $p$ 即可**，此时 $[pB,(p+1)B)$ 一定包含答案，证明显然：若 $[(p+1)B,(p+2)B)$ 中存在答案，那么 $p+1>p$，不满足 $p$ 最大。

暴力在这个块找即可，所以求出 $ans$ 的总时间复杂度为 $O(\dfrac n w\log \dfrac n B+B+\dfrac n w)$。

-------------

### $\texttt{step 3:modify}$

考虑修改，由于 $fa,fb$ 一共才 $\dfrac n B$ 个，**暴力修改**每一个就好了，时间复杂度 $\dfrac n B$。

----------------

### $\texttt{summary}$

总时间复杂度最坏大约是 $O(\dfrac{nm}w+\dfrac{2n^2}B+q\cdot\max(\dfrac n B,3B+3\dfrac n w+\dfrac n w\log \dfrac n B))$，我们加上了常数方便更精确地确定 $B$ 的大小。分类讨论，然后随便求个导（~~其实是问 AI~~）就知道了 $B=\dfrac{n}{6w\ln2}(1+\sqrt{1+\dfrac{24w^2(\ln2)^2}{q}})$ 的时候上述表达式大约是最小的。

但实际上因为代码常数上还是有一定的区别，**经过测试上述并不一定最小，只是理论最小，但是也能过**。找到使其最小的 $B$ 的读者可以评论一下。

忽略常数项，空间复杂度是 $O(\dfrac{n^2+\dfrac{n^2}B}w+n+m)$ 的。

------------------

## 代码（非赛时）

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
void clear(int,int); // 多测清空，在 main 下面
const int N=1e5+5,M=350;
vector<int>e[N];int deg[N];
int a[N],b[N],ida[N],idb[N]; // a,b 数组和 a,b 数组的逆
void input(int &n,int &m,int &q,int &B) // 输入
{
	n=in(),m=in(),q=in();
	long double ln2=0.693,w=64;
	B=n/(6*w*ln2)*(1+sqrt(1+24*w*w*ln2*ln2/q));
	B=max(B,1),B=min(B,n),clear(n,B);
	// update on 2025-03-05 修改了 B 的大小
	for(int i=1;i<=m;i++)
	{
		int u=in(),v=in();
		e[v].push_back(u),deg[u]++; // 建反图跑拓扑
	}
	for(int i=1;i<=n;i++)a[i]=in(),ida[a[i]]=i;
	for(int i=1;i<=n;i++)b[i]=in(),idb[b[i]]=i; // “逆”是这个意思
}
bitset<N>f[N];
void topo(const int n) // 跑拓扑
{
	queue<int>q;
	for(int i=1;i<=n;i++)if(!deg[i])q.push(i);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int v:e[u])
		{
			f[v]|=f[u]; // 递推 f
			if(--deg[v]==0)q.push(v);
		}
	}
}
int n,m,q,B;
void init(bitset<N>(&fa)[M],int (&ida)[N]) // 求出 fa 和 fb
{
	for(int i=0;i<=n/B+1;i++)
		for(int j=max(i*B,1);j<=n;j++)fa[i].set(ida[j]);
}
void modify(bitset<N>(&s)[M],int (&a)[N],const int x,const int y) // 修改
{
	for(int i=0;i<=a[x]/B;i++)s[i].reset(x);
	for(int i=0;i<=a[y]/B;i++)s[i].reset(y);
	for(int i=0;i<=a[x]/B;i++)s[i].set(y);
	for(int i=0;i<=a[y]/B;i++)s[i].set(x); // 注意要把 reset 和 set 分开写，或者新建备份再操作，不要一边删除一边加入。就像交换 a,b，不能 a=b,b=a，而是要 t=a,a=b,b=t。我就因为这个调了半天
}
bitset<N>fa[M],fb[M];
int find(int l,int r,bitset<N>&A) // 二分查找 p
{
	int ans=-1;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if((fb[mid]&A).any())ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans;
}
int query(const int x,const int l,const int r) // 查询
{
	int bl=l/B,br=r/B;
	bitset<N>A,tmp;
	if(bl<br)
	{
		A=fa[bl+1]^fa[br]; // 整块
		for(int i=l;i<(bl+1)*B;i++)A.set(ida[i]);
		for(int i=br*B;i<=r;i++)A.set(ida[i]); // 散块
	}
	else for(int i=l;i<=r;i++)A.set(ida[i]);
	A&=f[x];int p=find(0,n/B+1,A); // 先找到 A 和 p
	if(p==-1)return 0; // 没有
	tmp=(fb[p]^fb[p+1])&A;
	for(int i=min((p+1)*B-1,n);i>=p*B;i--)if(tmp.test(idb[i]))return i; // 在块内暴力找
	return 0; // 理论上不会进入这里
}
void work()
{
	input(n,m,q,B),topo(n),init(fa,ida),init(fb,idb);
	while(q--)
	{
		int op=in();
		if(op==1){int x=in(),y=in();modify(fa,a,x,y),swap(ida[a[x]],ida[a[y]]),swap(a[x],a[y]);} // 先交换“逆”再交换原，下同
		if(op==2){int x=in(),y=in();modify(fb,b,x,y),swap(idb[b[x]],idb[b[y]]),swap(b[x],b[y]);}
		if(op==3){int x=in(),l=in(),r=in();out(query(x,l,r)),putchar('\n');}
	}
}
int main()
{
	in();int T=in();
	while(T--)work();
	return 0;
}
void clear(int n,int B) // 清空
{
	for(int i=1;i<=n;i++)
	{
		e[i].clear(),deg[i]=0;
		f[i].reset(),f[i].set(i); // 刚开始 f_i 要放入一个 i
	}
	for(int i=0;i<=n/B+1;i++)fa[i].reset(),fb[i].reset();
}
```

放一个格式化后的[代码](https://www.luogu.com.cn/record/205935980)，放一个带调试信息的[代码](https://www.luogu.com.cn/record/205934758)。

update on 2025-03-05：注意：由于之前算错了复杂度，所以以上两个版本的代码的块长为 $B=\sqrt n$ ，不是最优。

再放一个[调代码记录](https://www.luogu.com.cn/record/list?pid=P11831&user=865625)。

---------------

### 后记

本来想放游记的，但是考太差了，不想放在这里出丑了，有兴趣的往我专栏找吧。

如果代码有误或讲述不清，欢迎评论。

--------------

> 我该在哪里停留？我问我自己。

续：

> 我不再执念于具象的停驻之地，只因每一回对回忆的深情回溯，皆是心灵的停留。此刻，回忆已不再是羁绊，而是化作熠熠星辰，镶嵌在我灵魂的夜幕之上。它们用或柔和、或炽热的光芒，将前路雕琢成一条闪耀着生命华彩的通途，正书写一部独属于我的、波澜壮阔的人生史诗！

---

## 作者：Inui_Sana (赞：18)

场上 1h 秒的 $O(\frac{n^2}\omega+qn^\frac 23)$ 做法，大样例跑了 4.8s，应该能过，希望不是因为石实的机子太块导致的。顺便分享一下我的思路。

第一反应：DAG 链剖分？但是不会怎么办。想了很久怎么把图上后继拆成若干个区间，但是一直不会。又想了想图是树怎么做，大概可以启发式合并，但是很没有前途。

然后发现连不带修都不会！于是想不带修。既然从图上入手非常困难，那么干脆转换思路，从 $a_y$ 入手。注意到 $n\le 10^5$，考虑对 $a$ 分块。

整块考虑 $O(\frac{n^2}B)$ 预处理出 $f_{u,i}$ 表示 $u$ 能到达的点中，$a_y$ 属于第 $i$ 块的 $y$ 中的 $\max b_y$。对于散块，$O(\frac{n^2}\omega)$ 预处理每个点能到达的点，然后只用枚举每个 $a_y$ 对应的 $y$ 是否可以从 $x$ 到达并更新最大值。$O(qB)$。

然后再顺着考虑带修怎么做。如果直接修改每个 $a_x,b_x$ 能影响到的点，复杂度显然不能接受。怎么办？直接上操作分块！套路地，每 $S$ 次操作重新预处理 $f$，查询时只用枚举块内的 $S$ 个 $a,b$ 有变化的点现在的位置，判断是否可达。这样复杂度是 $O(\frac{n^2}\omega+\frac{qn^2}{BS}+qB+\frac{qn}B+qS)$。注意到此时取 $B=S=n^{\frac 23}$ 复杂度即为 $O(\frac{n^2}\omega+qn^{\frac 23})$。

如果说卡常的话，我块长直接取的 $3100\approx n^\frac 23$，尝试过调块长但是效果不好。一些可能的常数优化是，对一个操作块内有变化的数进行去重。不过上述操作常数都相当小，理论上应该是可过的吧？

代码待补。很小清新，2kb 多。

upd：复现了一下，和考场代码应该基本没区别。在洛谷原来用了个 vector 存有修改的点，最慢点 7.97s，改成数组之后最慢点只有 7.18s。还好场上改成了后者。

块长改成 $2500$ 后跑进了 7s。最优块长大概是这附近？

code：

```cpp
const int B=3100;
int n,m,q,k,a[N],b[N],pa[N],f[N][107],c[N<<1];
int id[N],bl[N],br[N];
bool vis[N];
bitset<N> ins[N];
int tot,head[N];
struct node{
	int to,nxt;
}e[N<<1];
struct Node{
	int op,x,y,u;
}d[N];
il void add(int u,int v){
	e[++tot]={v,head[u]},head[u]=tot;
}
void Yorushika(){
	read(n,m,q),tot=0;
	rep(i,1,n){
		head[i]=0;
	}
	rep(i,1,m){
		int u,v;read(u,v);
		add(u,v);
	}
	drep(u,n,1){
		ins[u].reset();
		go(i,u){
			int v=e[i].to;
			ins[u]=ins[u]|ins[v];
		}
		ins[u][u]=1;
	}
	rep(i,1,n){
		read(a[i]),pa[a[i]]=i;
	}
	rep(i,1,n){
		read(b[i]);
	}
	rep(i,1,n){
		id[i]=(i-1)/B+1;
	}
	rep(i,1,id[n]){
		bl[i]=(i-1)*B+1,br[i]=min(i*B,n);
	}
	rep(i,1,q){
		read(d[i].op);
		if(d[i].op<=2){
			read(d[i].x,d[i].y);
		}else{
			read(d[i].u,d[i].x,d[i].y);
		}
	}
	rep(j,1,(q-1)/B+1){
		int L=(j-1)*B+1,R=min(j*B,q);
		k=0;
		rep(i,L,R){
			if(d[i].op<=2){
				c[++k]=d[i].x,c[++k]=d[i].y;
			}
		}
		sort(c+1,c+k+1),k=unique(c+1,c+k+1)-c-1;
		rep(i,1,k){
			vis[c[i]]=1;
		}
		drep(u,n,1){
			mems(f[u],0);
			go(i,u){
				int v=e[i].to;
				rep(k,1,id[n]){
					f[u][k]=max(f[u][k],f[v][k]);
				}
			}
			if(!vis[u]){
				f[u][id[a[u]]]=max(f[u][id[a[u]]],b[u]);
			}
		}
		rep(i,L,R){
			if(d[i].op==3){
				int u=d[i].u,l=d[i].x,r=d[i].y,x=id[l],y=id[r],ans=0;
				if(x==y){
					rep(i,l,r){
						if(ins[u][pa[i]]){
							ans=max(ans,b[pa[i]]);
						}
					}
				}else{
					rep(i,l,br[x]){
						if(ins[u][pa[i]]){
							ans=max(ans,b[pa[i]]);
						}
					}
					rep(i,bl[y],r){
						if(ins[u][pa[i]]){
							ans=max(ans,b[pa[i]]);
						}
					}
					rep(i,x+1,y-1){
						ans=max(ans,f[u][i]);
					}
				}
				rep(i,1,k){
					int v=c[i];
					if(a[v]>=l&&a[v]<=r&&ins[u][v]){
						ans=max(ans,b[v]);
					}
				}
				printf("%d\n",ans);
			}else if(d[i].op==1){
				int x=d[i].x,y=d[i].y;
				swap(a[x],a[y]),swap(pa[a[x]],pa[a[y]]);
			}else{
				swap(b[d[i].x],b[d[i].y]);
			}
		}
		rep(i,1,k){
			vis[c[i]]=0;
		}
	}
}
signed main(){
	int t=1,yh;
	read(yh,t);
	while(t--){
		Yorushika();
	}
}
```

> Code Size = 2025B

---

## 作者：王熙文 (赞：17)

看游记发现很多人提到了这道题 $\mathcal O(nq)$ 得了 88 及以上的分数，但是题解区没有人传授卡常技巧，于是我来发一篇。这是一个非常好写的 $\mathcal O(nq)$ 的做法，洛谷最大点 4.62s。

## 思路

省流：将可达性改为一个点可以到达的所有 $b$ 的值，手写 `bitset` 可以做到找到即 `break`、访问连续和只访问 $1$ 的位置三个优秀的性质。对于二操作可以可以先将要修改的位置存下来，在三操作的时候再修改，这样就能过了。

首先 DAG 可达性问题显然要使用 `bitset`。具体的，对每个点记录 $\text{bit}_{i,j}$ 表示 $i$ 是否可以到达 $j$。从 $n$ 到 $1$ 遍历每个点，并将 $\text{bit}_i$ 或上 $i$ 的出边的 $\text{bit}$ 即可。

发现如果从大到小枚举 $b_y$，如果满足条件了就可以 `break`，跑不满。但是此时 $\text{bit}$ 数组的访问会不连续，不行。

考虑将 $\text{bit}_{i,j}$ 改为 $i$ 是否可以到达 $b_k=j$ 的 $k$。这样数组访问就连续了。而且更好的一点是，如果手写 `bitset`，可以只遍历到值为 $1$ 的位置。具体的，对于一个 `unsigned long long` 类型的数，可以调用 `__lg(x)` 得到最高位，再让 $x$ 减去 `1llu<<__lg(x)`。`__lg()` 函数的速度是非常快的。

但是此时交换 $b_x,b_y$ 的时候会影响 $\text{bit}$（对于所有 $\text{bit}_i$，交换 $b_x$ 和 $b_y$ 位置上的值）。发现三操作只会访问一个 $\text{bit}_i$，所以可以将修改存下来，并记录 $pos_i$ 表示 $\text{bit}_i$ 此时修改到了修改序列上的哪个位置，三操作的时候将未修改的部分更新即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q;
vector<int> e[100010];
int a[100010],b[100010];
unsigned long long bit[100010][(int)1e5/64+10];
int wz1[100010],wz2[100010];
int tot,xx[100010],yy[100010];
int pos[100010];
int main()
{
    ios::sync_with_stdio(false),cin.tie(0);
    int testid,t; cin>>testid>>t; while(t--)
    {
        cin>>n>>m>>q;
        for(int i=1; i<=n; ++i) e[i].clear();
        for(int i=1; i<=m; ++i)
        {
            int u,v; cin>>u>>v;
            e[u].push_back(v);
        }
        for(int i=1; i<=n; ++i) cin>>a[i];
        for(int i=1; i<=n; ++i) cin>>b[i],wz1[b[i]]=i,wz2[b[i]]=a[i];
        for(int i=n; i>=1; --i)
        {
        	memset(bit[i],0,sizeof(bit[i]));
        	bit[i][b[i]>>6]=(1llu<<(b[i]&63));
        	for(int j:e[i])
        	{
        		for(int k=0; k<=(n>>6); ++k) bit[i][k]|=bit[j][k];
			}
        }
        tot=0;
        for(int i=1; i<=n; ++i) pos[i]=1;
        while(q--)
        {
            int op,x,y,l,r; cin>>op;
            if(op==1)
            {
                cin>>x>>y;
                swap(wz2[b[x]],wz2[b[y]]);
            }
            if(op==2)
            {
                cin>>x>>y;
                swap(wz1[b[x]],wz1[b[y]]);
                swap(wz2[b[x]],wz2[b[y]]);
                xx[++tot]=b[x],yy[tot]=b[y];
                swap(b[x],b[y]);
            }
            if(op==3)
            {
                cin>>x>>l>>r;
                while(pos[x]<=tot)
                {
                	int a=(bit[x][xx[pos[x]]>>6]>>(xx[pos[x]]&63)&1);
                	int b=(bit[x][yy[pos[x]]>>6]>>(yy[pos[x]]&63)&1);
                	if(a!=b)
                	{
                		if(a==0)
                		{
                			bit[x][xx[pos[x]]>>6]+=(1llu<<(xx[pos[x]]&63));
                			bit[x][yy[pos[x]]>>6]-=(1llu<<(yy[pos[x]]&63));
						}
						else
						{
							
                			bit[x][xx[pos[x]]>>6]-=(1llu<<(xx[pos[x]]&63));
                			bit[x][yy[pos[x]]>>6]+=(1llu<<(yy[pos[x]]&63));
						}
					}
                	++pos[x];
				}
				bool flag=0;
				for(int j=(n>>6); j>=0 && !flag; --j)
				{
					if(bit[x][j]==0) continue;
					unsigned long long now=bit[x][j];
					while(now!=0)
					{
						int wz=(j<<6)+__lg(now);
						if(l<=wz2[wz] && wz2[wz]<=r)
						{
							cout<<wz<<'\n';
							flag=1;
							break;
						}
						now-=(1llu<<__lg(now));
					}
				}
				if(!flag) cout<<0<<'\n';
            }
        }
    }
    return 0;
}
```

---

## 作者：farfarqwq (赞：13)

通过了 luogu、qoj、熨斗上的官方数据。

cxy 提出了一个纯 bitset 并且十分好写的时空复杂度 $O(n^2/w)$ 的做法（$n,m,q$ 同阶）。

## Solution

重要观察：
- 询问和可达性有关，即便该题给出的是 DAG，这种问题一般只能 bitset。
- 一个 $10^5\times 10^5$ 的 bitset 正好占了 1+eps GB。

考虑第一步无脑地使用拓扑排序求出可达性。

我们确定接下来问题的入手点：离线，枚举每个点并向查询贡献（基于该想法的暴力也是好写的）。

但暴力是 $O(nq)$ 的，但发现从按 $b$ 大到小枚举点，如果能从**快速动态维护还未被贡献的询问集合，并从其中找到该点可以贡献的询问**，并直接更新答案就好了。

这个操作正好是 bitset 另一巧妙应用。对于这种多个限制的情况，对每个限制**分别**维护集合，并把它们按位与起来得到满足所有限制的集合。

这时候发现还有修改（swap），考虑每次修改都新建两个点，并加上“该点出现时间是 $[lt_i,rt_i]$”的信息就行（相当于增加了时间维），这样最多有 $n+2q$ 个点。

列举单点 $(id_i,a_i,b_i,lt_i,rt_i)$（$id_i$ 表示编号）对询问 $(x_j,l_j,r_j,t_j)$（$t_j$ 表示时间）的限制：
1. $x_j$ 可达 $id_i$。
2. $l_j\le a_i \le r_j$
3. $lt_i \le t_j \le rt_i$
4. 该询问没有被贡献过。

我们将一开始处理出的**点到点**的可达性变成**点到询问点**的可达性，开一个 $n*q$ 的二维 bool 数组 $g$（bitset）。这是 1 限制。

我们再维护一个 $n*q$ 的二维 bool 数组 $f$，$f_{i,j}=[l_j\le i \le r_j]$，只需差分即可处理。这是 2 限制。

第 3 个怎么办呢？~由于 bitset 不能差分，可以考虑 st 表~（时空直接炸了）。我们发现时间一维就是询问的编号，直接按顺序存储，贡献的时候直接使用 bitset 内置的 `_Find_next` 函数可以快速找出某个时刻后第一个询问（注意这个函数找的是严格在该位置后面的第一个 1）（这个函数单次查询最坏复杂度应该是 $O(q/w)$ 的。

第 4 个直接维护一个 bitset，存储所有还未被贡献的询问。

然后就做完了，由于找到一个询问的代价是 $O(q/w)$ 的，总时间复杂度 $O(n^2/w)$。

没讲清楚的参考代码。

### 一些细节

- f 和 g 加起来是 2.33 GB，空间开不下，此时我们将所有点按 $a$ 和 $\frac n2$ 的大小关系分成两部分，当成两组数据处理即可，可以将 $g$ 的空间减少一半（或者其他方法减半空间也行）。
- 多测清空，挨个检查所有全局数组，注意数组的大小（新点数量最大 $3\times 10^5$）。
- 大样例最慢 1.88s，但是熨斗最慢 6.19s（虽然听说 CCF 机子挺快但不排除被卡常的可能）。
- 去掉快读 <150 行（而且我写得很史）。

### 想说的

- 这篇题解试着提供了一种思考路径，不代表作者的思考路径。但我认为可以帮助理解并在以后遇到这种题时进行参考。
- 祝大家省选 RP++。

## Code

（去快读，对拍时可以把 fin/fout 换成 cin/cout）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
const int N = 100005, mod = 1e9 + 7;
int cnt, h0[N], in[N];
struct edge {
    int v, next;
} e[N << 2];
inline void add(int u, int v) {
    e[++cnt].v = v;
    e[cnt].next = h0[u];
    h0[u] = cnt;
    ++in[v];
}
bitset<N> ok, g[N], s[N >> 1];
int a[N], b[N], ti[N];
int op[N], x[N], y[N], z[N], res[N];
int tot;
struct node {
    int x, a, b;
    int tl, tr;
} uu[N << 2];
inline void upd(int x, int t) {
    uu[ti[x]].tr = t;
    uu[ti[x] = ++tot] = (node){x, a[x], b[x], t, 100001};
}
vector<int> vec[N];
inline bool cmp(const node &x, const node &y) {
    return x.b > y.b;
}
void work() {
    int n, m, q;
    fin >> n >> m >> q;
    cnt = 0;
    memset(h0, 0, sizeof(h0));
    for (int i = 1; i <= m; i++) {
        int u, v;
        fin >> u >> v;
        add(u, v);
    }
    for (int i = 1; i <= n; i++)
        fin >> a[i];
    for (int i = 1; i <= n; i++) {
        fin >> b[i];
        uu[ti[i] = i] = (node){i, a[i], b[i], 0, 100001};
        vec[i].clear();
        g[i].reset();
    }
    tot = n;
    ok.reset();
    int num = 0;
    for (int i = 1; i <= q; i++) {
        fin >> op[i];
        if (op[i] < 3) {
            fin >> x[i] >> y[i];
            if (op[i] == 1)
                swap(a[x[i]], a[y[i]]);
            else
                swap(b[x[i]], b[y[i]]);
            upd(x[i], num);
            upd(y[i], num);
        } else {
            fin >> z[i] >> x[i] >> y[i];
            res[++num] = 0;
            ok.set(num);
            g[z[i]].set(num);
            vec[x[i]].push_back(num);
            if (y[i] <= n)
                vec[y[i] + 1].push_back(-num);
        }
    }
    queue<int> qq;
    for (int i = 1; i <= n; i++)
        if (!in[i])
            qq.push(i);
    while (qq.size()) {
        int u = qq.front();
        qq.pop();
        for (int i = h0[u]; i; i = e[i].next) {
            int v = e[i].v;
            g[v] |= g[u];
            --in[v];
            if (!in[v])
                qq.push(v);
        }
    }
    sort(uu + 1, uu + tot + 1, cmp);
    int lim = n >> 1;
    s[0].reset();
    for (int i = 1; i <= lim; i++) {
        s[i] = s[i - 1];
        for (int x : vec[i])
            if (x > 0)
                s[i].set(x);
            else
                s[i].reset(-x);
    }
    for (int i = 1; i <= tot; i++) {
        if (uu[i].a > lim)
            continue;
        bitset<N> tmp = ok & s[uu[i].a] & g[uu[i].x];
        int now = tmp._Find_next(uu[i].tl);
        while (now <= uu[i].tr) {
            ok.reset(now);
            res[now] = max(res[now], uu[i].b);
            now = tmp._Find_next(now);
        }
    }
    for (int i = 1; i <= num; i++)
        ok.set(i);
    s[0] = s[lim];
    for (int i = 1; i <= n - lim; i++) {
        s[i] = s[i - 1];
        for (int x : vec[i + lim])
            if (x > 0)
                s[i].set(x);
            else
                s[i].reset(-x);
    }
    for (int i = 1; i <= tot; i++) {
        if (uu[i].a <= lim)
            continue;
        bitset<N> tmp = ok & s[uu[i].a - lim] & g[uu[i].x];
        int now = tmp._Find_next(uu[i].tl);
        while (now <= uu[i].tr) {
            ok.reset(now);
            res[now] = max(res[now], uu[i].b);
            now = tmp._Find_next(now);
        }
    }
    for (int i = 1; i <= num; i++)
        fout << res[i] << '\n';
}
int main() {
    int c, T;
    fin >> c >> T;
    while (T--)
        work();
    return 0;
}
```

---

## 作者：kkksc03wzl (赞：12)

考场上 2h 没想到 `bitset`，下了考场一看标签 20min 就会了，写加调试 1h。

然后 Day2 还没过掉 T1，这次省选就这么断送掉了。

觉得这道题只要不和我一样，提示这么明显还不去想 `bitset` 就不会切不掉了。

好的，下面说一下我的思路。

首先显然题目给的是个 DAG，但是 DAG 的连通性很难记录，我于是在考场上就认为这是极度不可做的。。

但是因为空间开到了两个 G，考虑用 `bitset` 存储记录能联通到的节点。

然后似乎还是不太可做，于是我开始考虑部分分。

如果不改变 $b$ 权值，我们显然可以考虑直接把它存到记录联通性的 `bitset` 里面，并且以 $a$ 权值为序开一个数据结构方便修改和查询，其中这个数据结构也是以 `bitset` 为基本类型的。

如果不改变 $a$ 权值，我们就考虑再把它存到记录联通性的 `bitset` 里面，并且以 $b$ 权值为序开一个数据结构，然后如果我们直接开树状数组的话就是在上面做二分，查找最大的 $b$，如果是分块的话就直接进行值域分块就好了。

然后正解其实就是把上面两个部分拼在一起，我们发现上面我们其实存到 `bitset` 里面的是某一个不变的权值，然而这道题目无论怎么变，图中点的原始编号一定不会发生改变，于是我们考虑分别对 $a,b$ 权值开一个分块（因为这样能平衡复杂度），然后大块上维护这个权值对应的原始编号的 `bitset`，局部只需要记录这个权值对应的原始编号即可。然后它的交换操作的更改可以直接做，就是 $O(1)$ 的，它的查询操作我们可以找 $a$ 权值在 $[l,r]$ 上的，具体就是把散块的直接丢到 `bitset` 里面，大块的或上去。然后把这个值与上查询的点所联通的 `bitset`，这就是我们需要的原始编号的范围，然后我们再到 $b$ 权值为序的分块上进行值域查询，先从大到小看看大块里面有没有以上找到的原始编号，有就直接在这个块里面从大到小枚举每个编号即可。

我们发现对于查询操作，无论是在 $a$ 序上的还是在 $b$ 序上的，散块操作整体复杂度为 $O(B)$，大块查询整体复杂度为 $O(\frac{n}{w})$，平衡一下发现理论上 $B$ 取 $\frac{n}{w^{\frac{1}{2}}}$时最优，实际上块长这样取就能过。整体复杂度 $O(\frac{n^2}{w^{\frac{1}{2}}})$，跑满了是 $1.25\times 10^9$ ，但是好像跑不太满，我在洛谷上最大的点 5.46s。然后这个场上几乎送分的黑题就切掉了。

## CODE

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
inline int read(){
	int x=0;char ch=getchar();
	while(ch>'9'||ch<'0')ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}inline void write(int x){
	if(!x)return putchar('0'),void();
	char ch[20];ch[0]=0;
	while(x)ch[++ch[0]]=x%10^48,x/=10;
	while(ch[0])putchar(ch[ch[0]--]);
}vector<int>G[N];
int d[N],n,m,q,ra[N],rb[N],t,B,bel[N],st[N],ed[N],cnt,a[N],b[N];
bitset<N>S[N],Sa[2005],Sb[2005];
inline void topsort(){
	queue<int>q;
	for(int i=1; i<=n; i++)if(!d[i])q.push(i);
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=0; i<G[x].size(); i++){
			int y=G[x][i];
			d[y]--;S[y]|=S[x];
			if(!d[y])q.push(y);
		}
	}
}bitset<N>T;
inline void update(int l,int r){
	bitset<N>s;s.reset();
	if(bel[l]==bel[r])for(int i=l; i<=r; i++)s[ra[i]]=1;
	else {
		for(int i=l; i<=ed[bel[l]]; i++)s[ra[i]]=1;
		for(int i=bel[l]+1; i<=bel[r]-1; i++)s|=Sa[i];
		for(int i=st[bel[r]]; i<=r; i++)s[ra[i]]=1;
	}
	T&=s;
}inline int find(){
	int id;
	for(id=cnt; id>=1; id--)if((T&Sb[id]).count()){break;}
	for(int i=ed[id]; i>=st[id]; i--)if(T[rb[i]]==1)return i;
	return 0;
}
int main(){
//	freopen("recall7.in","r",stdin);
//	freopen("recall.out","w",stdout);
	int c=read(),t=read();
	while(t--){
		n=read(),m=read(),q=read();
		B=max(1,n/8);
		cnt=n/B;
		if(n%B!=0)cnt++;
		for(int i=1; i<=n; i++){
			G[i].clear();d[i]=0;S[i].reset();S[i][i]=1;
		}
		while(m--){
			int x=read(),y=read();
			G[y].push_back(x),d[x]++;
		}
		for(int i=1; i<=n; i++)a[i]=read(),ra[a[i]]=i;
		for(int i=1; i<=n; i++)b[i]=read(),rb[b[i]]=i;
		
		for(int i=1; i<=cnt; i++){
			st[i]=ed[i-1]+1,ed[i]=min(n,st[i]+B-1);
			Sa[i]=0,Sb[i]=0;
			for(int j=st[i]; j<=ed[i]; j++){
				bel[j]=i;
				Sa[i][ra[j]]=1,Sb[i][rb[j]]=1;
			}
		}
		topsort();
		while(q--){
			int op=read(),x=read(),y=read(),z;
			if(op==1){
				Sa[bel[a[x]]][x]=0;Sa[bel[a[y]]][y]=0;
				swap(a[x],a[y]);ra[a[y]]=y,ra[a[x]]=x;
				Sa[bel[a[x]]][x]=1;Sa[bel[a[y]]][y]=1;
			}else if(op==2){
				Sb[bel[b[x]]][x]=0;Sb[bel[b[y]]][y]=0;
				swap(b[x],b[y]);rb[b[y]]=y,rb[b[x]]=x;
				Sb[bel[b[x]]][x]=1;Sb[bel[b[y]]][y]=1;
			}else{
				z=read();T=S[x];
				update(y,z);
				write(find());putchar('\n');
			}
		}
	}
	return 0;
} /*
0 1
6 7 1000
1 2
1 3
2 3
2 4
3 4
4 5
5 6
1 2 3 4 5 6 
4 3 2 1 6 5

*/
```


如果可以，我想回到前天，把这道题切掉，晚上复习一下 Matrix Tree，然后回到昨天，冷静地分析 T1，哪怕三个小时切掉也好，然后 T2 把边权为一的性质写掉（而不是眼睁睁地把性质看会却忘了怎么写），然后就可以圆我初中进队之梦了，但是过去只能追忆，时光不能重塑。


## AFO

---

## 作者：zhenjianuo2025 (赞：10)

$O(n^2/w+n\sqrt{nw})$。


显然，这题的复杂度不可能低于 $O(n^2/w)$。

对时间分块，定期重构，设阈值为 $B$。

那么在每一次重构之前，都最多只会有 $B$ 个点是不确定的，询问时枚举这其中的每个点判断是否可达，只要提前 bitset 预处理出可达性，视 $n,m,q$ 同阶，复杂度是 $O(nB)$。不妨取 $B=n/w$，这样刚好平衡了。

现在考虑另外 $n-B$ 个已经确定的点。对 $a_i$ 分块，设块长为 $D$。对每一块，都预处理出每一个点可达的点中 $b_x$ 的最大值。每次询问，整块查，散块暴力。这样复杂度是 $O(nD+n^2/D+n^2w/D)$。取 $D=\sqrt{nw}$，得到最优复杂度 $O(n^2/w+n\sqrt{nw})$。

---

## 作者：Register_int (赞：10)

首先这是个大哥，大哥除了能 dp 以外没有性质了，所以直接当成黑盒考虑。当然先 $O(\frac{n^2}{\omega})$ 求出每个点能到达的集合。

对于静态的问题，我们对 $a$ 的值域按 $B_1$ 分块。对于块内，只保留 $a$ 在这段范围内的点跑 dp，查询就大块查答案散块暴力枚举，复杂度 $O(\frac{n^2}{B_1}+q(B_1+\frac n{B_1}))$。

对于修改，我们定期重构，每隔 $B_2$ 重构一次，所有被修改动到的点全部领出来不算贡献，最后再边改边算。复杂度是 $O(\frac{n^2q}{B_1B_2}+q(B_1+\frac n{B_1}+B_2))$。取 $B_1=B_2=n^{\frac23}$ 得到最优复杂度 $O(\frac{n^2}{\omega}+n^{5/3})$。

---

## 作者：ppip (赞：8)

$O((n+m)q/w+q\sqrt{q})$ 非常简单。

对时间轴分块，所有涉及修改操作的点先不管，我们来看看怎么做。

考虑维护 $f(x,i)$ 表示图上的点 $x$ 是否能从询问 $x_i$ 到达，且 $l_i\le a_x\le r_i$。这个 bitset 轻松维护：在 DAG 上递推出第一类限制，扫描线维护第二类限制，然后按位与。

然后按照 $b_x$ 从大到小枚举，每次把 $f(x,i)$ 为真且之前没有填答案的答案填成当前结点。

然后我们发现交换 $a$ 很容易，你把 $a_x$ 每个被修改的版本都放进扫描线里就完了。

交换 $b$ 的话，你对于每个询问，枚举所有被修改过的 $b_x$ 检查可达性即可。这部分由于时间轴分块是 $O(q\sqrt{q})$。

感觉不太能过，洛谷都 7s 多了。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int Spp{1<<20};
char buf[Spp],*p1,*p2,buf1[Spp],*p3{buf1},_st[22];
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,Spp,stdin),p1==p2)?EOF:*p1++)
#define putchar(c) ((p3==buf1+Spp&&(fwrite(buf1,1,Spp,stdout),p3=buf1)),*p3++=(c))
template <typename T>
void read(T &x) {
    char c;int f{1};
    do x=((c=getchar())-'0');
    while (!isdigit(c)&&c!='-');
    if (c=='-') f=-1,x=0;
    while (isdigit(c=getchar()))
        x=x*10+(c-'0');
    x*=f;
}
template <typename T,typename ...Args>
void read(T &x,Args &...args) { read(x);read(args...); }
template <typename T>
inline void write(T x,char c='\n') {
    if (x<0) putchar('-'),x=-x;
    if (!x) putchar('0');
    else {
        int tp{0};
        while (x) _st[tp++]=x%10+'0',x/=10;
        while (tp--) putchar(_st[tp]);
    }
    putchar(c);
}
struct OI { ~OI(){ fwrite(buf1,1,p3-buf1,stdout); } } IO;
constexpr int N(1e5),M(2e5),B{317*10},O{(B+31)/32};
constexpr unsigned Z(UINT_MAX);
vector<int> e[N+5];
int a[N+5],b[N+5],lst[N+5];
struct oper {
    int op,x,y,z;
} Q[B+5];
bool chg[N+5];
int nn=O;
using bits=bitset<B+5>;
bits t[N+5],cv[N+5],pr[B+5],sf[B+5];
vector<tuple<int,int,int>> o[N+5];
vector<int> sw[N+5],swt[B+5];
int ib[N+5],ans[B+5];
int main() {
    freopen("recall.in","r",stdin);
    freopen("recall.out","w",stdout);
    pr[0].set();
    sf[B+1].set();
    for (int i{1};i<=B;++i) pr[i]=pr[i-1],pr[i].reset(i);
    for (int i{B};i>=1;--i) sf[i]=sf[i+1],sf[i].reset(i);
    int T;read(T,T);
    while (T--) {
        int n,m,q;read(n,m,q);
        while (m--) {
            int u,v;read(u,v);
            e[v].push_back(u);
        }
        for (int i{1};i<=n;++i) read(a[i]);
        for (int i{1};i<=n;++i) read(b[i]);
        int bls(B);
        for (int i{1};i<=q;i+=bls) {
            int bl{min(bls,q-i+1)};
            for (int j{1};j<=n;++j) o[j].clear(),sw[j].clear(),t[j].reset(),cv[j].reset();
            fill_n(lst+1,n,0);
            fill_n(chg+1,n,0);
            for (int j{1};j<=bl;++j) {
                read(Q[j].op,Q[j].x,Q[j].y);
                if (Q[j].op==3) {
                    read(Q[j].z);
                    sw[Q[j].y].push_back(j);
                    sw[Q[j].z+1].push_back(j);
                    t[Q[j].x].set(j);
                } else if (Q[j].op==2) chg[Q[j].x]=chg[Q[j].y]=true;
                else {
                    auto [op,x,y,z]{Q[j]};
                    o[a[x]].emplace_back(x,lst[x]+1,j);
                    o[a[y]].emplace_back(y,lst[y]+1,j);
                    lst[x]=lst[y]=j;
                    swap(a[x],a[y]);
                }
            }
            for (int j{1};j<=n;++j)
                if (lst[j]!=bl) o[a[j]].emplace_back(j,lst[j]+1,bl);
            bits cur;cur.reset();
            for (int j{1};j<=n;++j) {
                for (auto v:sw[j]) cur.flip(v);
                for (auto [id,l,r]:o[j])
                    cv[id]|=cur&pr[l-1]&sf[r+1];
            }
            int cnt{0};
            for (int j{1};j<=n;++j) {
                for (auto k:e[j]) t[j]|=t[k],++cnt;
                ib[b[j]]=j;
            }
            for (int j{1};j<=n;++j) {
                for (int k:e[j]) {
                    t[j]|=t[k],++cnt;
                    if (cnt==2e5) break;
                }
            }
            cur=~pr[bl];
            fill_n(ans+1,bl,0);
            for (int j{n};j>=1;--j) {
                int u{ib[j]};
                t[u]&=cv[u];
                if (!chg[u]) {
                    t[u]&=cur;
                    for (int k{t[u]._Find_first()};k<t[u].size();k=t[u]._Find_next(k))
                        ans[k]=j;
                    cur^=t[u];
                } else {
                    for (int k{t[u]._Find_first()};k<t[u].size();k=t[u]._Find_next(k))
                        swt[k].push_back(u);
                }
            }
            for (int j{1};j<=bl;++j) {
                if (Q[j].op==2) swap(b[Q[j].x],b[Q[j].y]);
                else if (Q[j].op==3) {
                    for (auto v:swt[j])
                        ans[j]=max(ans[j],b[v]);
                }
            }
            for (int j{1};j<=bl;++j)
                if (Q[j].op==3) write(ans[j]),swt[j].clear();
        }
        for (int i{1};i<=n;++i) e[i].clear();
    }
    return 0;
}
```

---

## 作者：SnowTrace (赞：7)

谨以此题解纪念我死去的 JSOI。

-----

娱乐做法，建议大家别学我。

首先我们考虑没有修改操作怎么做，就是你需要维护 $a$  某个值域区间的 bitset，把这个 bitset 和原本的连通性 bitset 与起来。因为 $b$ 序列不变，所以我们把点按照 $b$ 的大小重排，每次找到第一个非 0 数即可。

那么怎么维护一个区间的信息呢？可以使用分块 st 表。具体来说，我们把序列分成 $B$ 个块，对于散块暴力查询，对于块间的信息用 st 表预处理（也就是处理 $\dfrac{n}{B}$ 个块的信息组成的 st 表）。取 $B = \omega$，复杂度就是 $O(\dfrac{n^2}{\omega})$ 的。

接下来考虑带修改 $b$ 应该怎么做。可以想到值域分块，也就是我们只需要查出答案在哪个范围内，然后在这个范围内一一枚举。具体来说，假设我们要判断有没有答案在 $[L,R]$ 区间内，我们可以把曾经存在一个时刻值在这个区间内的 $b_i$ 全部拿出来，离散化一下，我们就只需要考虑这一部分点的可达性，但是这样的点的数量不确定，所以需要写一个支持动态长度的 bitset。

值域分块分成 $C$ 块，取 $C = \omega$，时间复杂度仍然是 $O(\frac{n^2}{\omega})$ 的。

接下来考虑带修改 $a$ 应该怎么做，实际上我们对 st 表做定期重构就可以，根据上面的分析，重构一次 st 的复杂度应当小于 $O(\dfrac{n}{C})$。重构 $\omega$ 次，时间复杂度还是 $O(\frac{n^2}{\omega})$。

实际上写出来在一个值域块内的点非常多，感觉其实有 100 倍常数，但是云斗和洛谷都过了，感觉 CCF 数据有概率过不去 $n = 10^5$。

代码写的特别丑陋。

upd on 3.7：这份代码在洛谷上不能通过，但是感觉 CCF 机子应该可以通过。

**一个最好的优化方式是把上面的所有东西去掉，只留下对 $b$ 值域分块那一部分，就可以随便过题了。**

笑话。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long

struct BIT{
	int sz = 0;vector<ull>p;
	bool check(){for(int i  =0;i<sz;i++)if(p[i])return 1;return 0;}
	void init(int cnt){
		sz = (cnt+63)/64;
		p.resize(sz,0);
	}
	void clear(){
		sz  =0;
		p.clear();
		p.shrink_to_fit();
	}
	void Set(){for(int i =0;i<sz;i++)p[i] = -1;return;}
	inline bool find(int pos){
		int be = pos/64,c = pos&63;
		return p[be]>>c&1;
	}
	inline void modify(int pos){
		int be = pos/64,c = pos&63;
	//	cout <<sz << " " << p.size()<< endl;
	//	cout << " " << be<< " " << c << endl;
		p[be]^=1ull<<c;
	}
	inline void change1(int pos){
		int be = pos/64,c = pos&63;
		p[be]|=1ull<<c;
	}
	inline void change0(int pos){
		change1(pos),modify(pos);
	}
	inline int query(int pos){
		int be = pos/64,c = pos&63;
		return p[be]>>c&1;
	}
};
BIT operator&(const BIT& a,const BIT& b){
	BIT c;c.sz = a.sz;c.p.resize(c.sz);
	for(int i  =0;i<c.sz;i++)c.p[i] = a.p[i]&b.p[i];
	return c;
}
BIT operator|(const BIT& a,const BIT& b){
	BIT c;c.sz = a.sz;c.p.resize(c.sz);
	for(int i  =0;i<c.sz;i++)c.p[i] = a.p[i]|b.p[i];
	return c;
}
void operator|=(BIT& a,const BIT& b){for(int i = 0;i<a.sz;i++)a.p[i]|=b.p[i];}
int n,m,q;
int ll[10005],rr[10005],be[100005];
int pos[100005];
int ans[100005];
vector<int>S;
vector<int>p[100005];
int tp[100005],x[100005],y[100005],ql[100005],qr[100005];
int A[100005],B[100005];
int a[100005],b[100005],pp[100005],pa[100005];
BIT to[100005];
BIT st[1005][10];
int len = 0,cc = 0;
vector<int>SS;
void init(){
	len = SS.size()/512+1;cc = SS.size()/len;
	for(int i = 1;i<=cc;i++)ll[i] = (i-1)*len,rr[i] = i*len-1;rr[cc] = SS.size()-1;
	for(int i = 1;i<=cc;i++)for(int j = ll[i];j<=rr[i];j++)be[j] = i;
	for(int i = 0;i<=8;i++)for(int j = 1;j<=cc;j++)st[j][i].clear(),st[j][i].init(S.size());
	for(int i = 1;i<=cc;i++){
		for(int j = ll[i];j<=rr[i];j++){
			if(pos[pa[SS[j]]]!=-1)st[i][0].modify(pos[pa[SS[j]]]);
		}
	}
	for(int i = 1;i<=8;i++){
		for(int j = 1;j+(1<<i)-1<=cc;j++){
			st[j][i] = st[j][i-1]|st[j+(1<<i-1)][i-1];
		}
	}
}
void dfs(){
	for(int i = 1;i<=n;i++)to[i].clear();
	for(int i = 1;i<=n;i++)to[i].init(S.size());
	for(int i = n;i>=1;i--)if(pos[i]!=-1)to[i].modify(pos[i]);
	for(int i = n;i>=1;i--)for(auto x:p[i])to[i]|=to[x];
}
bool in(int l,int r,int x){return (l<=x and x<=r);}
int ss[100005],lh = 0;
int okk[100005];
void work(int l,int r){
	S.clear();SS.clear();
	for(int i = 1;i<=n;i++)b[i] = B[i];
	for(int i = 1;i<=n;i++)pos[i] = -1;
	for(int i = 1;i<=n;i++)if(l<=b[i] and b[i]<=r)S.push_back(i);
	for(int i = 1;i<=q;i++){
		if(tp[i] == 2){
			swap(b[x[i]],b[y[i]]);
			if(l<=b[x[i]] and b[x[i]]<=r)S.push_back(x[i]);
			if(l<=b[y[i]] and b[y[i]]<=r)S.push_back(y[i]);
		}
	}

	for(int i = 1;i<=n;i++)a[i] = A[i],b[i] = B[i],pp[b[i]] = i,pa[a[i]] = i;
	sort(S.begin(),S.end());S.erase(unique(S.begin(),S.end()),S.end());
	for(int i = 0;i<S.size();i++)pos[S[i]] = i;
	for(int i = 1;i<=n;i++)if(in(l,r,b[i]))SS.push_back(a[i]);
	for(int i = 1;i<=q;i++){
		if(tp[i] == 1){
			if(pos[x[i]]!=-1 or pos[y[i]]!=-1)SS.push_back(a[x[i]]),SS.push_back(a[y[i]]);
			swap(a[x[i]],a[y[i]]);
		}
		if(tp[i] == 2){
			swap(b[x[i]],b[y[i]]);
		}
	}
	for(int i = 1;i<=n;i++)a[i] = A[i],b[i] = B[i],pp[b[i]] = i,pa[a[i]] = i;
	for(int i = 1;i<=n;i++)SS.push_back(i);
	sort(SS.begin(),SS.end());SS.erase(unique(SS.begin(),SS.end()),SS.end());
	dfs();
	BIT ns,xx,nA;
	nA.init(S.size());
	nA.Set();
	ns.init(S.size());
	init();
	lh = 0;
	for(int i = 1;i<=n;i++)if(in(l,r,b[i]))ns.modify(pos[i]);
	int tt = q/100+1,cc = 0;
	for(int i = 1;i<=q;i++){
		if(tp[i] == 1){
			swap(a[x[i]],a[y[i]]);
			pa[a[x[i]]] = x[i],pa[a[y[i]]] = y[i];
			if(pos[x[i]] == -1 and pos[y[i]] == -1)continue;
			if(pos[x[i]]!=-1)nA.change0(pos[x[i]]),ss[++lh] = x[i];
			if(pos[y[i]]!=-1)nA.change0(pos[y[i]]),ss[++lh] = y[i];
			if((++cc)%tt == 0)init(),nA.Set(),lh = 0;	
		}else if(tp[i] == 2){
			if(in(l,r,b[x[i]])^in(l,r,b[y[i]])){
				ns.modify(pos[x[i]]);
				ns.modify(pos[y[i]]);
			}
			swap(b[x[i]],b[y[i]]);
			pp[b[x[i]]] = x[i],pp[b[y[i]]] = y[i];
		}else{
			if(ans[i])continue;
			int ok = 0;
			int L = lower_bound(SS.begin(),SS.end(),ql[i])-SS.begin();
			int R = upper_bound(SS.begin(),SS.end(),qr[i])-SS.begin()-1;
		//	cout << " " << L<<"  " <<R<< "  " << ql[i] << " " << qr[i] << endl;
			if(L<=R){
				if(be[L] == be[R]){
					for(int j = L;j<=R;j++){
						if(in(l,r,b[pa[SS[j]]]) and to[x[i]].find(pos[pa[SS[j]]])){
							ok = 1;
							break;
						}
					}
				}else{
					for(int j = 1;j<=lh;j++)if(in(l,r,b[ss[j]]) and in(ql[i],qr[i],a[ss[j]]) and to[x[i]].find(pos[ss[j]])){ok = 1;break;}
					for(int j = L;j<=rr[be[L]];j++)if(in(l,r,b[pa[SS[j]]]) and to[x[i]].find(pos[pa[SS[j]]])){ok = 1;break;}
					for(int j = ll[be[R]];j<=R;j++)if(in(l,r,b[pa[SS[j]]]) and to[x[i]].find(pos[pa[SS[j]]])){ok = 1;break;}
					++be[L],--be[R];
					if(be[L]<=be[R]){
						int k = __lg(be[R]-be[L]+1);
						xx = st[be[L]][k]|st[be[R]-(1<<k)+1][k];
						if((xx&ns&to[x[i]]&nA).check()){ok = 1;}
					}
					--be[L],++be[R];
				}
			}
			if(ok){
				for(int j = r;j>=l;j--){
					if(in(ql[i],qr[i],a[pp[j]]) and to[x[i]].find(pos[pp[j]])){
						ans[i] = j;
						break;
					}
				}
			}
		}
	}
}
void solve(){
	for(int i = 1;i<=n;i++)p[i].clear();
	for(int i = 1;i<=q;i++)ans[i] = 0;
	cin >> n >> m >> q;
	for(int i = 1;i<=m;i++){
		int a,b;cin >> a >> b;
		p[a].push_back(b);
	}
	for(int i = 1;i<=n;i++)cin >> a[i];
	for(int i = 1;i<=n;i++)cin >> b[i];
	for(int i = 1;i<=q;i++){
		cin >> tp[i];
		if(tp[i] != 3)cin >> x[i] >> y[i];
		else cin >> x[i] >> ql[i] >> qr[i];
	}
	for(int i = 1;i<=n;i++)A[i] = a[i],B[i] = b[i];
	int B = 10,cc = n/B;
	for(int t = B;t>=1;t--)work((t-1)*cc+1,(t == B)?n:t*cc);
	for(int i = 1;i<=q;i++)if(tp[i]==3)cout << ans[i] << "\n";
}
signed main(){
	freopen("recall.in","r",stdin);
	freopen("recall.out","w",stdout);
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	int c,t;cin >> c >> t;//t = 1;
	while(t--)solve();

	return 0;
}
/*

g++ recall.cpp -o qwq -std=c++14 -fsanitize=address,undefined

*/

```

---

## 作者：Genius_Star (赞：7)

### 思路：

注意到空间和时间挺大的，考虑直接 $O(\frac{n^2}{\omega})$ 求出每个点可达的 `bitset` $f_x$。

对于询问，我们想要知道 $a_i \in [l, r]$ 的 $i$ 的 `bitset`。

考虑建一个 $B$ 层的线段树，维护区间 $a_i \in [l, r]$ 的 `bitset`，注意这里我们不用 `pushup`，即单点修改时，直接从叶子到根修改一遍，复杂度为 $O(B)$；查询时，我们会进行至多 $B$ 次 `bitset` 的合并，以及 $O(\frac{n}{2^B})$ 的散点暴力。

现在我们已经支持 $O(B)$ 的修改，$O(B\frac{n}{\omega} + \frac{n}{2^B})$ 的区间查询 `bitset`。

我们将 $a_i \in [l, r]$ 的 $i$ 的 `bitset` 与 $f_u$ 进行与运算得 $f'$，剩下的点就是合法的点，我们要找合法点中 $b$ 的最大值。

同样使用这种 $B$ 层的线段树维护 $b_i \in [l, r]$ 的 $i$ 的 `bitset`，然后在这个线段树上进行二分，若与 $f'$ 与之后还有 $1$，这个 $b$ 就是存在的。

也至多进行 $B$ 次 `bitset` 的合并，最后暴力扫散点判断，二分复杂度为 $O(B \frac{n}{\omega} + \frac{n}{2^B})$，取 $B = 4, 5, 6$ 时跑的快一些。

总时间复杂度为 $O(Q(B\frac{n}{\omega} + \frac{n}{2^B}))$。

先放一个赛后写的**可能会被卡常**的代码。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 1e5 + 1, B = 4, M = 17; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct Node{
	int l, r; 
	int dep;
	int lson, rson;
	bitset<N> s[2];
}X[M];
bitset<N> Ans;
int c, rt, T, n, m, q, u, v, op, x, y, l, r, cnt, ans;
int a[N], b[N], pa[N], pb[N];
bitset<N> f[N];
vector<int> E[N];
inline void add(int u, int v){
	E[u].push_back(v); 
}
inline void build(int &k, int l, int r, int dep){
	if(dep >= B)
	  return ;
	k = ++cnt;
	X[k].l = l, X[k].r = r;
	X[k].dep = dep;
	X[k].s[0].reset(), X[k].s[1].reset();
	if(l == r)
	  return ;
	int mid = (l + r) >> 1;
	build(X[k].lson, l, mid, dep + 1);
	build(X[k].rson, mid + 1, r, dep + 1);
}
inline void update(int k, int i, int v, bool f, int pre = 0){
	if(X[k].dep >= B)
	  return ;
	if((f ? b[v] : a[v]) < X[k].l || (f ? b[v] : a[v]) > X[k].r)
	  X[k].s[f][pre] = 0;
	X[k].s[f][v] = 1;
	if(X[k].l == X[k].r)
	  return ;
	int mid = (X[k].l + X[k].r) >> 1;
	if(i <= mid)
	  update(X[k].lson, i, v, f, pre);
	else
	  update(X[k].rson, i, v, f, pre);
}
inline void ask(int k, int l, int r){
	if(X[k].l == l && r == X[k].r){
		Ans |= X[k].s[0];
		return ;
	}
	if(X[k].dep == B - 1){
		for(int i = l; i <= r; ++i)
		  Ans[pa[i]] = 1;
		return ;
	}
	int mid = (X[k].l + X[k].r) >> 1;
	if(r <= mid)
	  ask(X[k].lson, l, r);
	else if(l > mid)
	  ask(X[k].rson, l, r);
	else{
		ask(X[k].lson, l, mid);
		ask(X[k].rson, mid + 1, r);
	}
}
inline int ask(int k){
	if(X[k].dep == B - 1){
		for(int i = X[k].r; i >= X[k].l; --i)
		  if(Ans[pb[i]])
		    return i;
		return 0;
	}
	if(X[k].l == X[k].r)
	  return X[k].l;
	if((Ans & X[X[k].rson].s[1]).count())
	  return ask(X[k].rson);
	else
	  return ask(X[k].lson);
}
inline void solve(){
	cnt = 0;
	n = read(), m = read(), q = read();
	for(int i = 1; i <= n; ++i){
		E[i].clear();
		f[i].reset();
		f[i][i] = 1;
	}
	while(m--){
		u = read(), v = read();
		add(v, u);
	}
	for(int u = n; u >= 1; --u)
	  for(auto v : E[u])
	    f[v] |= f[u];
	for(int i = 1; i <= n; ++i)
	  a[i] = read();
	for(int i = 1; i <= n; ++i)
	  b[i] = read();
	build(rt, 1, n, 0);
	for(int i = 1; i <= n; ++i){
		update(rt, a[i], i, 0);
		update(rt, b[i], i, 1);
		pa[a[i]] = i, pb[b[i]] = i;
	}
	while(q--){
		op = read();
		if(op == 1){
			x = read(), y = read();
			if(x == y)
			  continue;
			update(rt, a[x], y, 0, x);
			update(rt, a[y], x, 0, y);
			swap(a[x], a[y]);
			swap(pa[a[x]], pa[a[y]]);
		}
		else if(op == 2){
			x = read(), y = read();
			if(x == y)
			  continue;
			update(rt, b[x], y, 1, x);
			update(rt, b[y], x, 1, y);	
			swap(b[x], b[y]);
			swap(pb[b[x]], pb[b[y]]);		
		}
		else{
			Ans.reset(); 
			ans = 0;
			u = read(), l = read(), r = read();
			ask(rt, l, r);
			Ans &= f[u];
			if(Ans.count()){
				write(ask(rt));
				putchar('\n');
			}
			else
			  puts("0");
		}
	}
}
bool End;
int main(){
	//open("A.in", "A.out");
	c = read(), T = read();
	while(T--)
	  solve();
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：7)

赛时做法，不过被狠狠卡常，改改块长可以过的。明年再战呃呃呃。

注意到题目很不能做到 $\text{polylog}$ 的复杂度，因为该问题严格不劣于 DAG 可达性问题，而这个只能做到 $\mathcal O(\frac{n^2}{\omega})$，我们可以先预处理出所有 $to_{u,v}\in\lbrace0,1\rbrace$ 表示是否存在 $u\to v$ 的路径。

进一步考虑原问题，可以进行操作分块，具体的我们对于 $[1,q]$ 按照 $B_1$ 进行分块。我们处理一个时间区间 $[L,R]$ 的所有贡献，总共重复 $\frac{q}{B_1}$ 次该过程。

考虑将 $[L,R]$ 中 $1/2$ 操作涉及的所有 $x,y$ 称为关键点。那么对于 $[L,R]$ 中操作 $3$ 的 $u$ 可达的所有 $v$ 而言，分为关键点和非关键点，对于关键点可以直接对这 $\mathcal O(B_1)$ 个数进行暴力判定以及暴力修改这些的 $a,b$，问题在于处理所有非关键点。

从 $a$ 是排列的性质以及询问要求 $a_v\in [l,r]$ 中入手，不难想到进行分块。具体而言，对于 $[1,n]$ 按照 $B_2$ 分块，且相当于以 $a$ 为这个数组的下标。那么对于 $[l,r]$ 拆分成的是 $\mathcal O(\frac{n}{B_2})$ 个整块以及 $\mathcal O(B_2)$ 个零散位置。对于整块可以处理：$f_{u,i}$ 表示 $u$ 可以到达的 $v$ 使得 $a_v$ 在第 $i$ 个整块中最大的 $b_v$ 的值。那么预处理的复杂度就是 $\mathcal O(\frac{nm}{B_2})$，询问的复杂度是 $\mathcal O(\frac{n}{B_2}+B_2)$，对于一个零散点显然可以 $\mathcal O(1)$ 判断。

视 $n,m,q$ 同阶，时间复杂度是 $\mathcal O(\frac{n^2}{\omega}+q(\frac{n^2}{B_1B_2}+\frac{n}{B_2}+B_1+B_2))$，理论上可以取 $B_1=B_2=n^{2/3}$ 来分析到 $\mathcal O(n^{5/3}+\frac{n^2}{\omega})$，但是实现上的 $B_1,B_2$ 是严重依赖于实现来进行调整的。

代码赛后重写的。

``` cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define dF(i,a,b) for(int i=(a);i>=(b);--i)
#define ull unsigned long long
#define uint unsigned
#define inf 1000000000
#define infll 1000000000000000000ll
#define pb push_back
#define mkp make_pair
#define pii pair<int,int>
#define ll long long
#define fi first
#define se second
#define SZ(x) ((int)x.size())
#define lowbit(x) ((x)&(-(x)))
#define rep(i,a,b,c) for(int i=(a);i<=(b);i+=(c))
#define per(i,a,b,c) for(int i=(a);i>=(b);i-=(c))
using namespace std;
void fre(){
	// freopen("recall.in","r",stdin),freopen("recall.out","w",stdout);
}
char buf[1<<20],*p1,*p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
namespace Fastio{struct Reader{template<typename T>Reader&operator>>(T&x){x=0;short f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();x*=f;return*this;}Reader&operator>>(double&x){x=0;double t=0;short f=1,s=0;char c=getchar();while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else{x*=f;return*this;}while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(long double&x){x=0;long double t=0;short f=1,s=0;char c=getchar();while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else{x*=f;return*this;}while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(__float128&x){x=0;__float128 t=0;short f=1,s=0;char c=getchar();while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else{x*=f;return*this;}while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(char&c){c=getchar();while(c==' '||c=='\n'||c=='\r')c=getchar();return*this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c==' '||c=='\n'||c=='\r')c=getchar();while(c!=' '&&c!='\n'&&c!='\r')str[len++]=c,c=getchar();str[len]='\0';return*this;}Reader&operator>>(string&str){str.clear();char c=getchar();while(c==' '||c=='\n'||c=='\r')c=getchar();while(c!=' '&&c!='\n'&&c!='\r')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl='\n';struct Writer{const int Setprecision=6;typedef int mxdouble;template<typename T>Writer&operator<<(T x){if(x==0){putchar('0');return*this;}if(x<0)putchar('-'),x=-x;static short sta[40];short top=0;while(x>0)sta[++top]=x%10,x/=10;while(top>0)putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(double x){if(x<0)putchar('-'),x=-x;mxdouble _=x;x-=(double)_;static short sta[40];short top=0;while(_>0)sta[++top]=_%10,_/=10;if(top==0)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;putchar('.');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_>0)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(long double x){if(x<0)putchar('-'),x=-x;mxdouble _=x;x-=(long double)_;static short sta[40];short top=0;while(_>0)sta[++top]=_%10,_/=10;if(top==0)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;putchar('.');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_>0)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(__float128 x){if(x<0)putchar('-'),x=-x;mxdouble _=x;x-=(__float128)_;static short sta[40];short top=0;while(_>0)sta[++top]=_%10,_/=10;if(top==0)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;putchar('.');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_>0)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(char c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}using namespace Fastio;
#define cin Fastio::cin
#define cout Fastio::cout
#define endl Fastio::endl
inline void chkmax(int &x,int y){ x=max(x,y); }
const int mod=998244353,maxn=100005;
int btcnt;
struct bitsett{
    ull a[(maxn>>6)+1];
    inline void init(){ memset(a,0,sizeof a); }
    inline void upd(int x){ a[x>>6]|=(1ull<<(x&63)); }
    inline void orr(bitsett &y){ F(i,0,btcnt)a[i]|=y.a[i]; }
    inline bool ask(int x){ return (a[x>>6]>>(x&63))&1; }
}to[maxn];
vector<int>g[maxn];
int n,m,zsy,ans[maxn],a[maxn],b[maxn],rb[maxn];
const int B=2800;
struct Oper{
	int op,x,l,r;
}q[maxn];
bool qtag[maxn],ctag[maxn];
vector<int>qu[maxn];
int bl[maxn],br[maxn],bel[maxn],f[maxn][maxn/B+1],ra[maxn],qwq[maxn];
inline void Solve(int l,int r){
	F(i,1,n)qtag[i]=ctag[i]=ra[i]=0,qu[i].clear();
	F(i,l,r){
		if(q[i].op<=2)ctag[q[i].l]=ctag[q[i].r]=1;
		else qtag[q[i].x]=1,qu[q[i].x].push_back(i);
	}
	F(i,1,n)memset(f[i],0,sizeof f[i]);
	F(i,1,n)if(!ctag[i])ra[a[i]]=i;
	dF(u,n,1){
		if(!ctag[u])f[u][bel[a[u]]]=b[u];
		for(int v:g[u])F(i,1,bel[n])chkmax(f[u][i],f[v][i]);
		if(qtag[u])for(int id:qu[u]){
			const int l=q[id].l,r=q[id].r;
			if(bel[l]==bel[r]){
				F(j,l,r)if(to[u].ask(ra[j]))chkmax(ans[id],b[ra[j]]);
			} else{
				F(j,bel[l]+1,bel[r]-1)chkmax(ans[id],f[u][j]);
				F(j,l,br[bel[l]])if(to[u].ask(ra[j]))chkmax(ans[id],b[ra[j]]);
				F(j,bl[bel[r]],r)if(to[u].ask(ra[j]))chkmax(ans[id],b[ra[j]]);
			}
		}
	}
	vector<int>vec;
	F(i,1,n)if(ctag[i])vec.push_back(i);
	F(i,l,r){
		if(q[i].op==1)swap(a[q[i].l],a[q[i].r]);
		else if(q[i].op==2)swap(b[q[i].l],b[q[i].r]);
		else{
			const int u=q[i].x,l=q[i].l,r=q[i].r;
			for(const int &v:vec)if(l<=a[v]&&a[v]<=r&&to[u].ask(v))chkmax(ans[i],b[v]);
		}
	}
}
void Solve_(){
	cin>>n>>m>>zsy,btcnt=n>>6;
	F(i,1,n)to[i].init(),g[i].clear();
	F(i,1,m){ int u,v;cin>>u>>v,g[u].push_back(v); }
	F(i,1,n)cin>>a[i];
	F(i,1,n)cin>>b[i];
	dF(u,n,1){ to[u].upd(u);for(int v:g[u])to[u].orr(to[v]); }
	F(i,1,zsy){
		cin>>q[i].op;
		if(q[i].op<=2)cin>>q[i].l>>q[i].r;
		else cin>>q[i].x>>q[i].l>>q[i].r;
		ans[i]=0;
	}
	F(i,1,n)bel[i]=(i-1)/B+1,br[bel[i]]=i;
	dF(i,n,1)bl[bel[i]]=i;
	const int B2=3200;
	F(i,1,(zsy-1)/B2+1)Solve((i-1)*B2+1,min(i*B2,zsy));
	F(i,1,zsy)if(q[i].op==3)cout<<ans[i]<<'\n';
}
signed main(){
	fre();
	int zsy=1; cin>>zsy>>zsy;
	F(i,1,zsy)Solve_();
}
```

---

## 作者：Petit_Souris (赞：6)

## 前言

第一次正赛场切黑题。省选续命成功了（虽然 Day 2 爆了但是肯定能进队对吧），希望最后四个月的 OI 生涯能让这第一次不是最后一次。

----

## 题解

下文分析认为 $n,q$ 同阶。实际实现时有些块长需要根据 $n,q$ 修改。

和有向图可达性相关了，结合 6s 2048MB 的时空限制，倾向于思考 $\mathcal O(\frac{n^2}{w})$ 的做法。

那么我们每次查询时要做的事情大致可以分为三部分：

- Part 1：求出 $x$ 可达的点集 $S$；

- Part 2：求出 $a_i\in [l,r]$ 的点集 $T$，并与 $S$ 求交（$S\leftarrow S\cap T$）。需要支持 $op=1$ 的修改。

- Part 3：求出 $S$ 中 $b$ 最大的点。需要支持 $op=2$ 的修改。

一步一步来做。

### Part 1

这部分是经典的：对于每个节点 $u$，我们预处理出一个 bitset $b_u$ 表示 $u$ 可达点的集合。按照拓扑序倒序（本题中可以直接 $n\to 1$）递推即可做到 $\mathcal O(\frac{n^2}{w})$。

查询的时候直接调用 $b_x$。

### Part 2

这部分需要做区间查询。我们发现，bitset 的查询可以用 ST 表处理，因为重合的部分可以并起来，不会多算。因此我们可以考虑用 ST 表处理。

但是这样预处理的时空复杂度就已经来到了 $\mathcal O(\frac{n^2\log n}{w})$，更不用说修改了。这里我赛时想到的处理方式是：按照 $B_1$ 大小分块，对于每个块，处理 $all_i$ 表示这块内所有 bitset 的并，并建立 $all$ 序列上的 ST 表。查询的时候整块直接调用 ST 表，散块暴力插入。

这样做的时间复杂度是 $\mathcal O(\frac{n^2\log {\frac{n}{B_1}}}{wB_1})$。我取了 $B_1=\frac{n}{128}$。

至于修改，再套一层定期重构就行了。每 $B_2$ 次询问就重构一次，查询的时候，在基础查询的基础上，重新判断在上次重构之后被修改的那些 $a_i$ 是否在范围内。时间复杂度 $\mathcal O(\frac{n^3\log {\frac{n}{B_1}}}{wB_1B_2}+nB_2)$。我取了 $B_2=\frac{n}{64}$。

### Part 3

这部分需要查询一个集合中的最大值。由于 $a,b$ 都是乱序的，我们不能直接用 `_Find_first()` 直接找到最大值。

这里我赛时想到的方法是：对 $b$ 序列分块，以 $B_3$ 为块长，预处理出 $b_i$ 在 $[n-B_3+1,n],[n-2B_3+1,n],[n-3B_3+1,n],\dots,[1,n]$ 中对应的 $i$ 的集合。这样查询的时候，我们可以二分一个长度为 $B_3$ 的倍数的后缀，看是否有交。这样就可以把答案定位到一个长度为 $B_3$ 的区间里，再暴力扫描就行了。

修改是非常容易的，直接枚举后缀就行了，复杂度只有 $\mathcal O(\frac{n^2}{B_3})$。

复杂度 $\mathcal O(\frac{n^2\log {\frac{n}{B_3}}}{w}+nB_3)$。我取了 $B_3=\frac{n}{16}$。

至此整题已被解决，常数非常小，洛谷 5s 通过。

其实这里每个块长大概要取什么是容易平衡出来的，都应该是 $\frac{n}{w}$ 状物，但是由于有些部分常数更大，所以需要微调。

```cpp
#include<bits/stdc++.h>
typedef int ll;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=1e5+9,M=2e5+9;
ll typ,T,n,m,q,U[M],V[M];
ll a[N],b[N],ord_a[N],ord_b[N];
ll stk[N*2],top;
bitset<N>go[N];
bitset<N>st[9][135];
bitset<N>btb[50],tmp;
ll lg[150],S,L[N],R[N],bel[N];
ll b_S,blb[N];
void First_Build(){
    S=min(n,(n+127)/128);
    rep(i,0,n+1)L[i]=R[i]=bel[i]=0;
    rep(i,1,n){
        bel[i]=(i-1)/S+1;
        if(!L[bel[i]])L[bel[i]]=i;
        R[bel[i]]=i;
    }
    b_S=max(1,n/16);
    rep(i,1,n)blb[i]=(i-1)/b_S+1;
    rep(i,0,blb[n]+1)btb[i].reset();
    rep(i,1,n){
        rep(j,1,blb[i])btb[j].set(ord_b[i]);
    }
}
void Rebuild(){
    top=0;
    rep(i,1,n)ord_a[a[i]]=i;
    rep(i,1,bel[n])st[0][i].reset();
    rep(i,1,bel[n]){
        rep(j,L[i],R[i])st[0][i].set(ord_a[j]);
    }
    rep(k,1,lg[bel[n]]){
        rep(i,1,bel[n]-(1<<k)+1){
            st[k][i]=st[k-1][i]|st[k-1][i+(1<<(k-1))];
        }
    }
}
void Query_st(ll l,ll r,bitset<N>&ans){
    ll p=lg[r-l+1];
    ans|=st[p][l]|st[p][r-(1<<p)+1];
}
void Query(ll l,ll r,bitset<N>&ans){
    ll bl=bel[l],br=bel[r];
    if(bl==br){
        rep(i,l,r)ans.set(ord_a[i]);
        return ;
    }
    rep(i,l,R[bl])ans.set(ord_a[i]);
    rep(i,L[br],r)ans.set(ord_a[i]);
    if(bl+1<=br-1)Query_st(bl+1,br-1,ans);
}
vector<ll>to[N];
void solve(){
    n=read(),m=read(),q=read();
    rep(i,1,m)U[i]=read(),V[i]=read();
    rep(i,0,n+1)to[i].clear();
    rep(i,1,m)to[U[i]].push_back(V[i]);
    rep(i,1,n)a[i]=read();
    rep(i,1,n)b[i]=read(),ord_b[b[i]]=i;
    rep(i,0,n+1)go[i].reset();
    rep(i,1,n)go[i].set(i);
    per(i,n,1){
        for(ll j:to[i])go[i]|=go[j];
    }
    ll rebuild_lim=max(1,q/64); // lim can't be 0
    First_Build(),Rebuild();
    top=0;
    ll C1=0,C2=0,C3=0;
    rep(i,1,q){
        ll op=read();
        // cout<<"going: "<<i<<" "<<op<<endl;
        if(op==1){
            C1++;
            ll x=read(),y=read();
            stk[++top]=x,stk[++top]=y;
            swap(ord_a[a[x]],ord_a[a[y]]);
            swap(a[x],a[y]);
        }
        else if(op==2){
            C2++;
            ll x=read(),y=read();
            ll frm=blb[b[x]],to=blb[b[y]];
            if(frm<to){
                rep(i,frm+1,to)btb[i].set(x);
            }
            else if(frm>to){
                rep(i,to+1,frm)btb[i].reset(x);
            }
            swap(frm,to);
            if(frm<to){
                rep(i,frm+1,to)btb[i].set(y);
            }
            else if(frm>to){
                rep(i,to+1,frm)btb[i].reset(y);
            }
            swap(ord_b[b[x]],ord_b[b[y]]);
            swap(b[x],b[y]);
        }
        else {
            C3++;
            ll x=read(),l=read(),r=read();
            tmp.reset();
            Query(l,r,tmp);
            rep(j,1,top){
                ll x=stk[j];
                if(a[x]<l||a[x]>r)tmp.reset(x);
                else tmp.set(x);
            }
            // rep(j,1,n)cout<<tmp[j];
            // cout<<endl;
            tmp&=go[x];
            ll ql=1,qr=blb[n],pos=0;
            while(ql<=qr){
                ll mid=(ql+qr)>>1;
                if((btb[mid]&tmp).any())pos=mid,ql=mid+1;
                else qr=mid-1;
            }
            if(!pos){
                write(0),putchar('\n');
                goto bed;
            }
            per(j,min(n,pos*b_S),(pos-1)*b_S+1){
                ll x=ord_b[j];
                if(tmp[x]){
                    write(j),putchar('\n');
                    goto bed;
                }
            }
        }
        bed:
        if(i%rebuild_lim==0)Rebuild();
    }
    // cerr<<C1<<" "<<C2<<" "<<C3<<"\n";
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    freopen("recall.in","r",stdin);
    freopen("recall.out","w",stdout);
    typ=read(),T=read();
    rep(i,2,128)lg[i]=lg[i>>1]+1;
    while(T--)solve();
    cerr<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}

/*
g++ -std=c++14 -O2 -Wall -Wextra recall.cpp -o recall && ./recall
*/
```

---

## 作者：JoyLosingK (赞：6)

## 解法

首先发现 $a$ 和 $b$ 的范围都不超过 $n$，非常果断地对 $a$ 和 $b$ 的值域分块，分别维护每个值在序列中的出现位置。这样就能做到 $O(1)$ 修改了。

接着看询问操作，维护一个点集 $S$ 表示能够成为答案的点。

为了保证 $l \leq a_y \leq r$，先将满足条件的点通过分块 $O(n)$ 加入点集，再考虑可达性。 这个可达性目前最优秀的做法是用 bitset 优化 $O(\frac{n^2}{w})$ 算出来。

等等？bitset？忽然想到，我们之前的分块操作以及计算答案的做法都可以用 bitset 优化，于是我们询问操作计算 $l \leq a_y \leq r$ 的点的步骤的时间优化成了 $O(\frac{n}{\sqrt w})$。

接下来就简单了，我们枚举答案所在的块，然后 $O(\frac{n}{w})$ 的时间检验，最后在块内暴力算答案即可。

总时间复杂度为 $O(\frac{nq}{\sqrt w})$，块长实测后感觉 $7000$ 跑得最快。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define endl '\n' 
const int N=1e5+5,key=7000,sqN=120;
int n,m,q,tot,a[N],b[N],posa[N],posb[N];
int pos[N],lm[sqN],rm[sqN],op,x,y,l,r,res;
bitset<N> d[N],sa[sqN],sb[sqN],ans,emy;
vector<int> e[N];
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return x*f;}
inline void slove(){
	n=read(),m=read(),q=read(),tot=(n-1)/key+1;
	for(int i=1;i<=n;i++) pos[i]=(i-1)/key+1,e[i].clear();
	for(int i=1;i<=tot;i++) lm[i]=rm[i-1]+1,rm[i]=min(n,i*key),sa[i]=sb[i]=emy;
	for(int i=1,u,v;i<=m;i++) u=read(),v=read(),e[u].push_back(v);
	for(int i=n;i>=1;i--){ d[i]=emy,d[i][i]=1; for(int v:e[i]) d[i]|=d[v];}
	for(int i=1;i<=n;i++) a[i]=read(),posa[a[i]]=i,sa[pos[a[i]]][i]=1;
	for(int i=1;i<=n;i++) b[i]=read(),posb[b[i]]=i,sb[pos[b[i]]][i]=1;
	for(;q--;){ op=read();
		if(op==1){ x=read(),y=read();
			sa[pos[a[x]]][x]=sa[pos[a[y]]][y]=0,
			swap(a[x],a[y]),posa[a[x]]=x,posa[a[y]]=y,
			sa[pos[a[x]]][x]=sa[pos[a[y]]][y]=1;}
		else if(op==2){ x=read(),y=read();
			sb[pos[b[x]]][x]=sb[pos[b[y]]][y]=0,
			swap(b[x],b[y]),posb[b[x]]=x,posb[b[y]]=y,
			sb[pos[b[x]]][x]=sb[pos[b[y]]][y]=1;}
		else if(op==3){ x=read(),l=read(),r=read(),res=0,ans=emy;
			if(pos[l]==pos[r]) for(int i=l;i<=r;i++) ans[posa[i]]=1;
			else{ for(int i=l;i<=rm[pos[l]];i++) ans[posa[i]]=1;
				for(int i=lm[pos[r]];i<=r;i++) ans[posa[i]]=1;
				for(int i=pos[l]+1;i<=pos[r]-1;i++) ans|=sa[i];
			} ans&=d[x];for(int i=tot;i>=1;i--)
				if((sb[i]&ans).any()){res=i;break;}
			if(!res){cout<<0<<endl;continue;}
			for(int i=rm[res];i>=lm[res];i--)
				if(ans[posb[i]]) {cout<<i<<endl;break;}
		}
	}
}
int main(){
	for(int c=read(),t=read();t--;) slove();
	return 0;
}
```

希望能对大家有所帮助。

---

## 作者：CarroT1212 (赞：6)

脑子里不带 $\omega$ 被区分掉了，祭之。

---

题意：给定 DAG，每个点上有 $a_i,b_i$，各为排列。$q$ 次操作：交换 $a$ 两项；交换 $b$ 两项；询问一个点 $x$ 的后继中 $l\le a_y \le r$ 的 $y$ 的 $\max b_y$。$n\le 10^5$，$q\le 2\times 10^5$。

首先开局必须意识到的事情：DAG 后继信息如果要做到低于 $O(n^2)$，是很难存在 $\text{polylog}$ 的维护方式的。所以直接开始考虑暴力数据结构。

对于求 DAG 一个点有什么后继，直接选择 bitset。于是每个点的后继集合 $nxt_i$ 可以预处理 $O(\frac{nm}{\omega})$ 地得出。考虑每次询问知道 $nxt_x$ 之后要怎么办。

考虑能不能再把 $l \le a_y \le r$ 这个限制加到集合上，把集合进一步简化。也就是我们需要知道整张图上 $a_i\in [l,r]$ 的 $i$ 集合，设其为 $S_{l,r}$，相当于是一个 mask，把 $S_{l,r}$ 和 $nxt_x$ 与一下就知道最终可能被计入答案的点集了，设这个点集为 $nxt'_x$。

求 $S_{l,r}$ 还是非常可做的。在值域上维护。

+ 直接值域上线段树维护区间 bitset 的话空间是几倍的 $\frac{n^2}{\omega}$，不太行，可以经典地搞一个底层分块，把长度 $\le B$ 的区间暴力求，上面线段树维护，这样空间复杂度好多了。此处空间 $O(\frac{n^2}{\omega B})$，修改 $O(\log \frac{n}{B})$，查询 $O(B+\frac{n}{\omega}\log\frac{n}{B})$。$B$ 取几千左右较优。
+ 也可以分块。把 $[l,r]$ 拆成 $[1,l-1]$ 和 $[1,r]$ 异或起来，现在考虑前缀查询。设块长 $B$。维护整块 $\frac{n}{B}$ 个前缀的 bitset。空间 $O(\frac{n^2}{B\omega})$，修改 $O(\frac{n}{B})$，查询 $O(B)$。取 $B=\sqrt{n}$ 即可。

得到了 $nxt'_x$ 之后，现在问题就是，求 $nxt'_x$ 内的 $b_i$ 最大值。

可以用类似的结构。尝试每次求图上 $b_i\ge z$ 的 $i$ 集合 $T_z$：如果 $z$ 可能成为答案，那么 $T_z$ 和 $nxt'_x$ 的交集非空。一个很二分的形式。

+ 线段树：对 $b_i$ 也建一个和之前类似的底层分块上线段树。修改一样，查询就在这个线段树上二分即可。复杂度和 $a_i$ 部分一样。
+ 分块：这里比较自然的想法是维护整块后缀 bitset 然后二分找到最靠右的合法整块，之后暴力散块。修改 $O(\frac{n}{B})$，查询复杂度 $O(\frac{n}{\omega}\log \frac{n}{B}+B)$。$B$ 取几千左右较优。
  + 可以在现在的第一篇题解看到如何把 $\log$ 去了。

于是做完了。复杂度就是预处理加上 $q$ 乘上面几个东西加起来。不必算了。

这里是分块代码。$a_i$ 部分为了和后面统一所以维护的是后缀值。实现难度较低，大样例 5s，不用卡常。写得还是比较丑的，要是 $S,T$ 相似处理放到一起可以轻松做到 <2K。

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define fi first
#define se second
using namespace std; bool MEM;
using ll=long long; using ld=long double;
using pii=pair<int,int>; using pll=pair<ll,ll>;
const int I=1e9,N=1e5+7,M=2e5+7,A=360,B=2000;
const ll J=1e18;
int type,n,q,m,a[N],b[N],aa[N],bb[N];
vector<int> e[N];
bitset<N> nxt[N],txn;
namespace S {
	const int K=A,L=N/K+7;
	int cl[L],cr[L],sz,bel[N];
	bitset<N> t[L];
	void ini() {
		sz=0;
		while (t[sz+1].reset(),sz*K+1<=n) {
			sz++,cl[sz]=(sz-1)*K+1,cr[sz]=min(sz*K,n);
			for (int i=cl[sz];i<=cr[sz];i++) bel[i]=sz;
		}
		for (int i=1;i<=n;i++) t[bel[a[i]]].set(i);
		for (int i=sz-1;i;i--) t[i]|=t[i+1];
	}
	void chn(int x,int y,int z) {
		for (int i=1;i<=bel[y];i++) t[i].reset(x);
		for (int i=1;i<=bel[z];i++) t[i].set(x);
	}
	void que(int x) {
		if (x>n) return;
		txn^=t[bel[x]+1]; for (int i=cr[bel[x]];i>=x;i--) txn.flip(aa[i]);
	}
}
namespace T {
	const int K=B,L=N/K+7;
	int cl[L],cr[L],sz,bel[N];
	bitset<N> t[L];
	void ini() {
		sz=0;
		while (t[sz+1].reset(),sz*K+1<=n) {
			sz++,cl[sz]=(sz-1)*K+1,cr[sz]=min(sz*K,n);
			for (int i=cl[sz];i<=cr[sz];i++) bel[i]=sz;
		}
		for (int i=1;i<=n;i++) t[bel[b[i]]].set(i);
		for (int i=sz-1;i;i--) t[i]|=t[i+1];
	}
	void chn(int x,int y,int z) {
		for (int i=1;i<=bel[y];i++) t[i].reset(x);
		for (int i=1;i<=bel[z];i++) t[i].set(x);
	}
	int que(bitset<N> &x) {
		int l=1,r=sz,mid,res=sz+1;
		while (l<=r) {
			mid=l+r>>1;
			if ((t[mid]&x).any()) res=mid,l=mid+1;
			else r=mid-1;
		}
		if (res==sz+1) return 0;
		else for (int i=cr[res];i>=cl[res];i--) if (x[bb[i]]) return i;
		return -1;
	}
}
void mian() {
	scanf("%d%d%d",&n,&m,&q);
	for (int i=1;i<=n;i++) e[i].clear(),nxt[i].reset();
	for (int i=1,x,y;i<=m;i++) scanf("%d%d",&x,&y),e[x].pb(y);
	for (int i=n;i;i--) { nxt[i][i]=1; for (int j:e[i]) nxt[i]|=nxt[j]; }
	for (int i=1;i<=n;i++) scanf("%d",&a[i]),aa[a[i]]=i;
	for (int i=1;i<=n;i++) scanf("%d",&b[i]),bb[b[i]]=i;
	S::ini(),T::ini();
	for (int opt,x,y,l,r;q--;) {
		scanf("%d%d",&opt,&x);
		if (opt<=2) {
			scanf("%d",&y);
			if (opt==1) S::chn(x,a[x],a[y]),S::chn(y,a[y],a[x]),swap(aa[a[x]],aa[a[y]]),swap(a[x],a[y]);
			else T::chn(x,b[x],b[y]),T::chn(y,b[y],b[x]),swap(bb[b[x]],bb[b[y]]),swap(b[x],b[y]);
		}
		else {
			scanf("%d%d",&l,&r);
			txn.reset(),S::que(l),S::que(r+1);
			txn&=nxt[x];
			cout<<T::que(txn)<<"\n";
		}
	}
}
bool ORY; int main() {
	// while (1)
	int t; for (scanf("%d%d",&type,&t);t--;)
	mian();
	cerr<<"\n"<<abs(&MEM-&ORY)/1048576<<"MB";
	return 0;
}
```

比较可惜，现场只能对着十几档带着各种性质的部分分干瞪眼最后拿暴力跑路，并没有真正发现如果丢到 bitset 上做的话后续优化其实非常自然。还是去 T3 搞了个森林才让 Day1 分数看起来也许还算合理。

感觉确实没在省选题里面见过带 $\omega$ 的正解复杂度。对 DS 题的认知还是跟时代脱节了。加训。

---

## 作者：IvanZhang2009 (赞：5)

思路可以见[游记](https://www.luogu.com/article/eb7zt1n2)。

这是一个很暴力的考场做法，似乎没看见跟我一样的。

首先有向图可达性算是比较典的 $O(\frac{n^2}{\omega})$，正好题目也提示了我们空间和时间都很大，所以这个肯定对完了。具体地，预处理 $n$ 个 bitset $C_{i}$ 表示 $i$ 是否可达 $j$。查询的时候相当于查询 $f_i$ 中所有 $a$ 在值域中的 $b$ 的最大值。

然后这两个带修看上去都非常不容易，好像只会 ABC 性质但是又没有。考察思考的方向，注意到如果 $i$ 可达集合是 $[i,n]$ 所有点的话不弱于动态二维数点，而这个题已经有一个平方级别的暴力部分了所以不妨完全放弃 polylog 开始想分块之类的暴力结构。

尝试解决 $a$ 上的值域限制。一个基于 $a$ 静态的想法是，处理 $a$ 的每个值域前缀对应的下标和。即 $A_i$ 表示所有 $a_j\le i$ 的 $j$ 的集合组成的 bitset。这样至少可以在每次询问中 $O(\frac n\omega)$ 地去除 $a$ 的限制，似乎是不错的。再仔细一想，这个空间似乎已经是两倍的 $\frac{n^2}{\omega}$，一定会很卡，所以考虑放弃。

这种前缀和相关的题需要注意到，如果查询的复杂度和预处理的复杂度很不平衡，可以套用一些看上去几乎无意义的分块来压缩空间（有一个较深的印象是我和 irris 的这个题的[这篇题解](https://www.luogu.com.cn/article/vn8mqqkc)）。注意到我们分块之后，查询的时候的单点修改的复杂度是非常小的，是小常数 $O(1)$，然而查询整块非常耗费时间。而我们非常经得起大量的散块查询，在 $n\le 10^5$ 的时候把块长开到 $2000$ 都可以接受。于是可以细想分块了！

不妨按 $B$ 分块。说人话就是只维护所有 $i\equiv 0(\bmod B)$ 的 $i$ 的 $A_i$。这样还有一个好处是，对 $a$ 的单点修改只会改到 $\frac{n}{B}$ 个 $A_i$，所以 $op=1$ 也可以接受了。查询的时候相当于需要支持查询单点 $A_r$，可以先调用 $A_{B\lfloor\frac{r}{B}\rfloor}$，再把缺的单点部分暴力补上。这整个部分时间复杂度是 $O(\frac{n^2}{\omega}+q(B+\frac{n}{\omega}+\frac nB))$。

实际上这个时候写一个取出所有符合要求的点求 $b_{\max}$ 可以在最后一个大样例跑 7s，几乎可以通过了。

然后考虑如何优化 $b$ 的部分。可以发现即使是静态问题都没有什么优秀的做法。直接枚举或者直接分块显然没有什么理论低于 $O(nq)$ 的做法。

考虑为什么要我们求 $b_{\max}$ 呢？有一个直接的想法是二分答案，变成判定给定 bitset 和 $b$ 的值域区间是否有交。不妨把 $b$ 的值域取反变成前缀（方便我自己理解），类似上面地设计 $D_{i}$ 表示所有 $b_j\le i$ 的 $j$ 组成的 bitset（这里似乎和块长的字母重复了，那就随便新取一个）。在不带修的时候可以做到 $O(\frac{nq}{\omega}\log n)$。感觉很蠢，还不能带修。但是 $b$ 的修改是否可以参考 $a$ 的修改呢？

这就不得不提到 WC 文艺汇演的相声（这句话也给了我相当的启发）：

> 找一个数在有序序列中的出现位置的时候，先分块！二分它在哪个块里，然后在块里二分！就做到了 $O(\log\sqrt n)$！

可以想到仍然对 $b_i$ 分块，维护方法同 $a_i$。查询的时候直接二分它在哪个块里（因为只维护了整块信息，查询还方便），然后暴力查询块内，这样完美平衡了一下单点查询的 $O(1)$ 和整块前缀查询的 $O(\frac n\omega)$！

具体地，维护所有整块代表的 bitset 的前缀和。查询的时候在大块上查询，可以极大的削掉 $\log n$ 的部分。check 的时候只需要拿 $D_{iB}$ 和当前询问的 bitset 判断交是否非空即可。对于散块，暴力查询的 $O(1)$ 还是很可观的！同时分块仍然可以支持带修！这部分时间复杂度 $O(q(\frac{n\log{\frac nB}}{\omega}+B+\frac{n}{B}))$。具体 $B$ 取啥的时候最优懒得算了，反正我直接取 $B=2000$  在大样例跑了 2.3s。此时 $\log \frac nB$ 只有 $6$，至少少了三倍常数。上下取同一个 $B$，总时间复杂度就是 $O(\frac{n^2}{\omega}+q(\frac{n\log{\frac nB}}{\omega}+B+\frac{n}{B}))$。

建议手写 bitset，理由不知道。

考场代码：

```cpp
#include<bits/stdc++.h>
#define MOD 998244353
#define int long long
#define REP(i,a,n) for(int i=(a);i<(int)(n);++i)
#define pii pair<int,int>
#define pb push_back
#define all(v) v.begin(),v.end()
#define over {cout<<x<<"\n";return;}
using namespace std;
int read(){
    int res=0;char c=getchar();
    while(c<48||c>57)c=getchar();
    do res=(res<<1)+(res<<3)+(c^48),c=getchar();while(c>=48&&c<=57);
    return res;
}
int qpow(int a,int b,int m=MOD){
    int res=1;
    while(b)res=b&1? res*a%m:res,a=a*a%m,b>>=1;
    return res;
}
#define ui unsigned int
int ID;
vector<int>v[100005];
int n,m,q,BL,CL;
ui C[100000][1563];
ui A[400][1563];
ui B[400][1563];
int a[100000],b[100000],ia[100000],ib[100000];
ui qr[1563];
void updA(int x,int y){
    REP(i,x/BL,CL)A[i][y>>6]^=1ull<<(y&63);
}
void updB(int x,int y){
    REP(i,x/BL,CL)B[i][y>>6]^=1ull<<(y&63);
}
void opA(int x){
    int d=x/BL-1;
    if(x>=BL){
        REP(j,0,m)qr[j]^=A[d][j];
    }
    REP(i,x/BL*BL,x+1)qr[ia[i]>>6]^=1ull<<(ia[i]&63);
}
void Main(){
    n=read();m=read();q=read();
    REP(i,0,n)v[i].clear();
    REP(i,0,m){
        int x,y;
        x=read()-1;y=read()-1;
        v[x].pb(y);
    }
    m=(n-1)>>6;++m;
    for(int i=n-1;i>=0;--i){
        REP(j,i>>6,m)C[i][j]=0;
        C[i][(i>>6)]=1ull<<(i&63);
        for(auto j:v[i]){
            REP(l,j>>6,m)C[i][l]|=C[j][l];
        }
    }
    BL=sqrt(n*7);BL=min(BL,n);
    BL=min(2000ll,n);
    CL=(n-1)/BL+1;
    REP(i,0,n){
        a[i]=read()-1;
        ia[a[i]]=i;
    }
    REP(i,0,n){
        int d=i/BL;
        if(i%BL==0){
            if(i){
                REP(j,0,m)A[d][j]=A[d-1][j];
            }else{
                REP(j,0,m)A[d][j]=0;
            }
        }
        A[d][ia[i]>>6]|=1ull<<(ia[i]&63);
    }
    REP(i,0,n)b[i]=n-read(),ib[b[i]]=i;
    REP(i,0,n){
        int d=i/BL;
        if(i%BL==0){
            if(i){
                REP(j,0,m)B[d][j]=B[d-1][j];
            }else{
                REP(j,0,m)B[d][j]=0;
            }
        }
        B[d][ib[i]>>6]|=1ull<<(ib[i]&63);
    }
    REP(i,0,q){
        int op,x,y,l,r;
        op=read();
        if(op==1){
            x=read()-1;y=read()-1;
            swap(a[x],a[y]);
            x=a[x];y=a[y];
            updA(x,ia[x]);updA(x,ia[y]);
            updA(y,ia[y]);updA(y,ia[x]);
            swap(ia[x],ia[y]);
        }else if(op==3){
            x=read()-1;l=read()-1;r=read()-1;
            REP(j,0,m)qr[j]=0;
            if(l)opA(l-1);
            opA(r);
            REP(j,0,m)qr[j]&=C[x][j];
            int ans=0,fl=0;
            REP(j,0,m){
                if(qr[j])fl=1;
            }
            if(!fl){
                cout<<0<<'\n';
                continue;
            }
            int l=0,r=CL-1,res=r;
            while(l<=r){
                int mid=(l+r)>>1,f=0;
                REP(j,0,m)if(B[mid][j]&qr[j]){f=1;break;}
                if(f)res=mid,r=mid-1;
                else l=mid+1;
            }
            for(int i=res*BL;i<n;++i){
                int x=ib[i];
                if(qr[x>>6]&(1ull<<(x&63))){
                    ans=i;
                    break;
                }
            }
            cout<<n-ans<<'\n';
        }else{
            x=read()-1;y=read()-1;
            swap(b[x],b[y]);
            x=b[x];y=b[y];
            updB(x,ib[x]);updB(x,ib[y]);
            updB(y,ib[y]);updB(y,ib[x]);
            swap(ib[x],ib[y]);
        }
    }
}
signed main(){
    freopen("recall.in","r",stdin);
    freopen("recall.out","w",stdout);
    int tc=1;
    ID=read();tc=read();
    while(tc--)Main();
    return 0;
}
```

---

## 作者：lzyqwq (赞：5)

> 我常常追忆过去。
---

给定一个 $n$ 个点 $m$ 条边的有向图 $G$，结点由 $1$ 至 $n$ 编号。第 $i$ ($1 \leq i \leq m$) 条边从 $u_i$ 指向 $v_i$，保证 $u_i < v_i$。节点 $j$ ($1 \leq j \leq n$) 有两个权值 $a_j, b_j$，保证 $[a_1, \ldots, a_n]$ 与 $[b_1, \ldots, b_n]$ 均是 $1 \sim n$ 的排列。

你需要进行 $q$ 次操作。操作有以下三种:
- $1\ x\ y$：交换 $a_x$ 和 $a_y$；
- $2\ x\ y$：交换 $b_x$ 和 $b_y$；
- $3\ x\ l\ r$：你需要输出满足以下两个条件的点 $y$ 中 $b_y$ 的最大值，若不存在满足条件的点则输出 $0$：
  1. $l \leq a_y \leq r$。
  2. 图 $G$ 中存在一条 $x$ 到 $y$ 的有向路径，即存在整数 $k \geq 1$ 与 $k$ 个结点 $p_1, p_2, \ldots, p_k$，满足 $p_1 = x$，$p_k = y$，且对于所有 $1 \leq i < k$，图 $G$ 中存在从 $p_i$ 指向 $p_{i+1}$ 的有向边。特别地，图 $G$ 中总是存在一条 $x$ 到 $x$ 的有向路径。
---

袁神太强大。

首先需要知道 DAG 任意两点可达性。记 $f_i$ 为 $i$ 能到达的点集。用记搜 + bitset 维护一下。时空复杂度 $\mathcal{O}\left(\dfrac{nm}{w}\right)$。

考虑静态问题，查询相当于给定两个集合 $f_x$ 和 $A=\{i\,|\,a_i\in[l,r]\}$，求 $\max\limits_{i\in A\cap f_x }b_i$。

集合性质比区间差，考虑根号算法。以 $B=\mathcal{O}(\sqrt n)$ 为块长分块。第 $i$ 个块表示区间 $[iB,(i+1)B)$。考虑先把 $A$ 弄出来再和 $f_x$ 取交。

记 $\text{fa}_i=\{j\,|\,a_j\in[iB,n]\}$，即某块左端点开始的后缀的值域内的点的集合。则整块内的点集可以用两个后缀差分（异或）出来，散块内的点可以暴力插入。

这样就得到了限制集合 $C=A\cap f_x$。接下来考虑求出答案位于哪个块，再暴力检查块内元素。我们要找到最大的 $p$，使得 $\{i\,|\,b_i\in[pB,n]\}\cap C\ne \varnothing$。因此需要类似地维护 $\text{fb}_i$。

称集合的每 $w$ 个元素存在情况构成的二进制数为一个 word。考虑依次枚举 $\mathcal{O}\left(\dfrac{n}{w}\right)$ 个 word，维护出 $C$ 的前 $i$ 个 word 对应的最大的 $p$。当 $i$ 右移时，我们要检查 $p+1$ 是否合法。由于前 $i$ 个 word 最多交到 $\text{fb}_p$。因此和 $\text{fb}_{p+1}$ 产生的交集一定位于 $i+1$ 这个 word 中。那么判断两个集合的这一个 word 是否有交即可。由于要查询 word 因此手写 bitset。

$i$ 移动 $\mathcal{O}\left(\dfrac{n}{w}\right)$ 次，$p$ 移动 $\mathcal{O}(\sqrt n)$ 次。因此时间复杂度为 $\mathcal{O}\left(\dfrac{nm}{w}+(n+q)\sqrt n\right)$。

至于修改，发现只需要修改 $\mathcal{O}(\sqrt n)$ 个 $\text{fa,fb}$。暴力修改即可。过程中需要记录一下每个排列的逆。

时间复杂度为 $\mathcal{O}\left(\dfrac{nm}{w}+(n+q)\sqrt n\right)$。空间复杂度 $\mathcal{O}\left(\dfrac{nm}{w}\right)$。**可以强制在线。**

至于优化空间，好像可以考虑操作分块，但是我还没想好怎么做，因为发现 bitset 仍然需要维护 $n$ 位。这个再问问袁神。

代码很好写。


```cpp
#include <bits/stdc++.h>
using namespace std; typedef unsigned long long ull; const int N = 100005, M = 500;
int c, T, n, m, q, a[N], b[N], B, bl[N], br[N], be[N], w, ida[N], idb[N];
bool vis[N]; vector<int> g[N];
struct DS {
	vector<ull> a; void I() { a = vector<ull>(w + 1); }
	void ins(int x) { a[x >> 6] |= 1ull << (x & 63); }
	void del(int x) { a[x >> 6] ^= 1ull << (x & 63); }
	bool q(int x) { return a[x >> 6] >> (x & 63) & 1; }
	void operator&=(const DS &o) { for (int i = 0; i <= w; ++i) a[i] &= o.a[i]; }
	void operator|=(const DS &o) { for (int i = 0; i <= w; ++i) a[i] |= o.a[i]; }
	void operator^=(const DS &o) { for (int i = 0; i <= w; ++i) a[i] ^= o.a[i]; }
} f[N], fa[M], fb[M];
void dfs(int u) {
	for (int v : g[u]) { if (!vis[v]) vis[v] = 1, dfs(v); f[u] |= f[v]; }
}
void insa(int x) { for (int i = 0; i <= be[a[x]]; ++i) fa[i].ins(x); }
void dela(int x) { for (int i = 0; i <= be[a[x]]; ++i) fa[i].del(x); }
void insb(int x) { for (int i = 0; i <= be[b[x]]; ++i) fb[i].ins(x); }
void delb(int x) { for (int i = 0; i <= be[b[x]]; ++i) fb[i].del(x); }
void getF(int l, int r, DS &F) {
	if (be[l] == be[r]) {
		for (int i = l; i <= r; ++i) F.ins(ida[i]); return;
	}
	F = fa[be[l] + 1]; F ^= fa[be[r]]; getF(l, br[be[l]], F); getF(bl[be[r]], r, F);
}
void work() {
	memset(vis, 0, sizeof vis); for (int i = 1; i <= n; ++i) g[i].clear();
	scanf("%d%d%d", &n, &m, &q); w = n >> 6; B = sqrt(n);
	for (int i = 1; i <= n; ++i) f[i].I(), f[i].ins(i), be[i] = i / B;
	for (int i = 0; i <= be[n]; ++i)
		bl[i] = i * B, br[i] = min(n, i * B + B - 1), fa[i].I(), fb[i].I();
	for (int i = 1, u, v; i <= m; ++i) scanf("%d%d", &u, &v), g[u].emplace_back(v);
	for (int i = 1; i <= n; ++i) {
		if (!vis[i]) dfs(i); scanf("%d", &a[i]); insa(i); ida[a[i]] = i;
	}
	for (int i = 1; i <= n; ++i) scanf("%d", &b[i]), insb(i), idb[b[i]] = i;
	for (int  o, x, y, k, p, ans; q--;) {
		scanf("%d%d%d", &o, &x, &y);
		if (o == 1)
			dela(x), dela(y), swap(ida[a[x]], ida[a[y]]),
			swap(a[x], a[y]), insa(x), insa(y);
		else if (o & 1) {
			scanf("%d", &k); DS F; F.I(); getF(y, k, F); F &= f[x]; p = ans = 0;
			for (int i = 0; i <= w; ++i)
				while (p <= be[n] && (F.a[i] & fb[p].a[i])) ++p;
			if (p--)
				for (int i = br[p]; i >= bl[p]; --i)
					if (F.q(idb[i])) { ans = i; break; }
			printf("%d\n", ans);
		} else
			delb(x), delb(y), swap(idb[b[x]], idb[b[y]]),
			swap(b[x], b[y]), insb(x), insb(y);
	}
}
int main() { scanf("%d%d", &c, &T); while (T--) work(); return 0; }
```

> 我该在哪里停留？我问我自己。

---

## 作者：IceKylin (赞：5)

赛时对特殊性质 B 胡了一个 $\mathcal{O}\left({\dfrac{nm+nq\log w}{w}}\right)$ 的神秘线段树做法，赛后发现改一改就对了。

首先有向图可达性是平凡的，记 $\text{To}_x$ 表示 $x$ 的所有可达点所构成的集合，不表。

考虑对 $a$ 序列建线段树，记 $\text{Seg}_a[l, r]$ 表示满足 $a_x\in [l, r]$ 的所有 $x$ 所构成的集合，用 `bitset` 维护。$b$ 序列同理。

每次查询时只需要得到 $\text{Seg}_a[l, r]$ 与 $\text{To}_x$ 的交集 $\text{C}$，然后在 $\text{Seg}_b$ 上二分即可。具体而言
，若 $\text{C}$ 与 $\text{Seg}_b[l', r']$ 的交集不为空，则有 $\text{Ans}\ge l'$。

然而这样单次查询时间复杂度是 $\mathcal{O}\left(\dfrac{n\log n}{w}\right)$，**空间复杂度远超限制**，无法接受。

考虑一种只维护自顶向下 $B$ 层的线段树。对于长度小于 $\dfrac{n}{2^B}$ 的区间，在查询时将满足条件的元素暴力插入集合，容易得到总时间复杂度为 $\mathcal{O}\left({\dfrac{nq}{2^B}} + \dfrac{Bnq+nm}{w}\right)$，空间复杂度为 $\mathcal{O}\left(\dfrac{n^2 + 2^Bn}{w}\right)$。

理论平衡当 $B = 4$ 时最优。实际测试取 $B = 6$，极限数据本地 5s 以内，可以通过。

由于本题中集合具有可差分性，理论上线段树可以被替代，精细实现或许更优？先摆了。

代码里有巨大 Header，所以不放了，想要可以私。

后记：_我该在哪里停留？我问我自己。_ 成与不成，一念之间。

---

## 作者：Felix72 (赞：4)

### 性质 AC

此时问题与 $a$ 无关，可以对操作分块，对于某一块操作，把与该块中修改操作无关的点拿出来进行一次全局 DP，这样每个询问要么是全局 DP 的结果，要么是该块内修改过的点（$O(B)$ 个）。

DP 的次数是 $O(\frac{n}{B})$ 次，总复杂度为 $O(\frac{n^2}{B} + nB)$。

### 性质 AB

此时问题是静态的，可以对 $a$ 的值域分块，每一块跑一个全局 DP，这样每个询问的查询复杂度是 $O(B)$。总复杂度为 $O(\frac{n^2}{B} + nB)$。

### 正解

正解是以上两个做法拼起来。既要对操作分块（设块长 $B_1$），每一块操作中也要对值域分块（设块长 $B_2$），其余做法不变。

分析块长：

- 全局 DP 的复杂度：每一块操作要进行一次 DP，每次 DP 需要分值域进行若干轮，复杂度为 $O(\frac{n^3}{B_1B_2})$；
- 询问的复杂度：询问的答案可能在全局 DP 里，也有可能在该块修改过的节点里，一次询问的复杂度为 $O(\frac{n}{B_2} + B_2 + B_1)$。

$B_1 = B_2 = n^{\frac{2}{3}}$ 时，复杂度较优。因为还需要 $O(1)$ 判断两点可达性，因此使用 bitset。设图和询问规模同阶，总复杂度为 $O(n^{\frac{5}{3}} + \frac{n^2}{\omega})$。

```cpp
/* COA-V Call of the Neon Colors */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

bool ST;

const int N = 100010, B_opt = 2500, B_v = 2500;
int Type, T, n, m, opn, a[N], b[N], rec_a[N]; vector < int > tr[N];
struct Opt {int opt, x, y, l, r;} op[N];

int f[N / B_v + 5][N]; bitset < N > mp[N]; int chk[N], chn;
int v_head[N], v_tail[N], v_id[N]; bool ban[N];
int op_head[N], op_tail[N], op_id[N];
inline void rebuild()
{
	for(int i = 1; i <= n; ++i) v_id[i] = (i - 1) / B_v + 1;
	for(int i = 1; i <= n; ++i) v_tail[v_id[i]] = i;
	for(int i = n; i >= 1; --i) v_head[v_id[i]] = i;
	for(int vid = 1; vid <= v_id[n]; ++vid)
	{
		for(int i = n; i >= 1; --i)
		{
			f[vid][i] = ((v_head[vid] <= a[i] && a[i] <= v_tail[vid] && !ban[i]) ? b[i] : 0);
			for(int j : tr[i]) f[vid][i] = max(f[vid][i], f[vid][j]);
		}
	}
}

inline void sol()
{
	for(int i = 1; i <= n; ++i) tr[i].clear();
	for(int i = 1; i <= n; ++i) mp[i].reset();
	
	cin >> n >> m >> opn;
	for(int i = 1, x, y; i <= m; ++i)
	{
		cin >> x >> y;
		tr[x].push_back(y);
	}
	for(int i = n; i >= 1; --i)
	{
		mp[i][i] = 1;
		for(int j : tr[i]) mp[i] |= mp[j];
	}
	
	for(int i = 1; i <= n; ++i) cin >> a[i], rec_a[a[i]] = i;
	for(int i = 1; i <= n; ++i) cin >> b[i];
	
	for(int i = 1; i <= opn; ++i)
	{
		cin >> op[i].opt;
		if(op[i].opt <= 2) cin >> op[i].x >> op[i].y;
		else cin >> op[i].x >> op[i].l >> op[i].r;
	}
	
	for(int i = 1, sum = 0; i <= opn; ++i)
	{
		op_id[i] = op_id[i - 1];
		if(i == 1 || sum > B_opt) ++op_id[i], sum = 0;
		if(op[i].opt <= 2) ++sum;
	}
	for(int i = 1; i <= opn; ++i) op_tail[op_id[i]] = i;
	for(int i = opn; i >= 1; --i) op_head[op_id[i]] = i;
	for(int opid = 1; opid <= op_id[opn]; ++opid)
	{
		for(int i = op_head[opid]; i <= op_tail[opid]; ++i)
			if(op[i].opt <= 2)
				ban[op[i].x] = ban[op[i].y] = true, chk[++chn] = op[i].x, chk[++chn] = op[i].y;
		sort(chk + 1, chk + chn + 1);
		chn = unique(chk + 1, chk + chn + 1) - chk - 1;
		rebuild();
		for(int i = op_head[opid]; i <= op_tail[opid]; ++i)
		{
			if(op[i].opt == 1) swap(a[op[i].x], a[op[i].y]), rec_a[a[op[i].x]] = op[i].x, rec_a[a[op[i].y]] = op[i].y;
			else if(op[i].opt == 2) swap(b[op[i].x], b[op[i].y]);
			else
			{
				int res = 0;
				for(int j = v_id[op[i].l] + 1; j < v_id[op[i].r]; ++j)
					res = max(res, f[j][op[i].x]);
				for(int j = op[i].l; j <= op[i].r && v_id[op[i].l] == v_id[j]; ++j)
					if(mp[op[i].x][rec_a[j]])
						res = max(res, b[rec_a[j]]);
				for(int j = op[i].r; j >= op[i].l && v_id[op[i].r] == v_id[j]; --j)
					if(mp[op[i].x][rec_a[j]])
						res = max(res, b[rec_a[j]]);
				for(int j = 1; j <= chn; ++j) if(mp[op[i].x][chk[j]] && op[i].l <= a[chk[j]] && a[chk[j]] <= op[i].r) res = max(res, b[chk[j]]);
				cout << res << '\n';
			}
		}
		memset(ban, 0, sizeof(ban)); chn = 0;
	}
}

bool ED;

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	cerr << "Memory : " << (&ST - &ED) / 1024.0 / 1024.0 << '\n';
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> Type >> T;
	while(T--) sol();
	return 0;
}
/*

*/
```

---

## 作者：dyj133446 (赞：4)

时间较大，空间较大，考虑 bitset。

先对于每个点求出其能到达的点，可以用 bitset 做到 $O(\frac{nm}{w})$ 的复杂度。

考虑询问，我们对 $a,b$ 分别开线段树，线段树每个节点存 dag 上哪些点 $a_i$（或 $b_i$）在该节点代表的区间内，用 bitset 存，先区间查询 $a_i$ 在 $[l,r]$ 区间内的点，再在 $b_i$ 的线段树上二分，找到 $b_i$ 最大的符合前面要求的点，暴力建线段树复杂度 $O(\frac{qn\log n}{w})$。

考虑到当线段树节点区间长度较小时，可以暴力枚举查询，没有必要用 bitset，所以当区间长度 $len<=\frac{n}{w}$ 时暴力查询即可，复杂度 $O(\frac{qn\log w}{w})$，总时间复杂度 $O(\frac{nm+qn\log w}{w})$，可以通过。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int c,tt,n,m,q,len,rd[N],a[N],b[N],pos1[N],pos2[N];
bitset<N>S[N],t[2][2500],T;
vector<int>e[N];
void build(int x,int l,int r)
{
	t[0][x].reset(),t[1][x].reset();
	for(int i=l;i<=r;i++)t[0][x].set(pos1[i]),t[1][x].set(pos2[i]);
	if(r-l+1<=len)return;
	int mid=(l+r)/2;
	build(x<<1,l,mid),build(x<<1|1,mid+1,r);
}
void change(int op,int x,int L,int R,int pos,int p,int val)
{
	t[op][x].set(p,val);
	if(R-L+1<=len)return;
	int mid=(L+R)/2;
	if(pos<=mid)change(op,x<<1,L,mid,pos,p,val);
	else change(op,x<<1|1,mid+1,R,pos,p,val);
}
bitset<N>solve(int x,int L,int R,int l,int r)
{
	if(L>=l&&R<=r)return t[0][x];
	if(min(R,r)-max(L,l)+1<=len)
	{
		bitset<N>a;
		for(int i=max(L,l);i<=min(R,r);i++)a.set(pos1[i]);
		return a;
	}
	int mid=(L+R)/2;
	if(r<=mid)return solve(x<<1,L,mid,l,r);
	if(l>mid)return solve(x<<1|1,mid+1,R,l,r);
	return solve(x<<1,L,mid,l,r)|solve(x<<1|1,mid+1,R,l,r);
}
int solve(int x,int l,int r)
{
	if(r-l+1<=len)
	{
		for(int i=r;i>=l;i--)if(T[pos2[i]]==1)return i;
	}
	int mid=(l+r)/2;
	if((T&t[1][x<<1|1]).any())return solve(x<<1|1,mid+1,r);
	return solve(x<<1,l,mid);
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>c>>tt;
	while(tt--)
	{
		cin>>n>>m>>q,len=max(1,n/64);
		for(int i=1;i<=n;i++)e[i].clear(),rd[i]=0;
		for(int i=1;i<=m;i++)
		{
			int x,y;
			cin>>x>>y;
			e[y].emplace_back(x),rd[x]++;
		}
		for(int i=1;i<=n;i++)cin>>a[i],pos1[a[i]]=i;
		for(int i=1;i<=n;i++)cin>>b[i],pos2[b[i]]=i;
		queue<int>Q;
		for(int i=1;i<=n;i++)S[i].reset(),S[i].set(i);
		for(int i=1;i<=n;i++)if(!rd[i])Q.emplace(i);
		while(!Q.empty())
		{
			int x=Q.front();Q.pop();
			for(auto y:e[x])
			{
				rd[y]--,S[y]|=S[x];
				if(!rd[y])Q.emplace(y);
			}
		}
		build(1,1,n);
		while(q--)
		{
			int op,x,y,z;
			cin>>op>>x>>y;
			if(op==1)
			{
				change(0,1,1,n,a[x],x,0),change(0,1,1,n,a[y],y,0);
				swap(a[x],a[y]),pos1[a[x]]=x,pos1[a[y]]=y;
				change(0,1,1,n,a[x],x,1),change(0,1,1,n,a[y],y,1);
			}
			if(op==2)
			{
				change(1,1,1,n,b[x],x,0),change(1,1,1,n,b[y],y,0);
				swap(b[x],b[y]),pos2[b[x]]=x,pos2[b[y]]=y;
				change(1,1,1,n,b[x],x,1),change(1,1,1,n,b[y],y,1);
			}
			if(op==3)
			{
				cin>>z;
				T=S[x]&solve(1,1,n,y,z);
				if(!T.count())cout<<"0\n";
				else cout<<solve(1,1,n)<<'\n';
			}
		}
	}
	return 0;
}

```

---

## 作者：ForgotMe (赞：4)

给个 $\mathcal{O}(\dfrac{n^2}{\omega}+(n+q)\sqrt{q})$，空间 $\mathcal{O}(\dfrac{n\sqrt{q}}{\omega})$ 的做法。

考虑操作分块，令块长为 $B$，一个块中会有至多 $B$ 对 $(a_i,b_i)$ 发生改变。先预处理出一个 $f_{u,i}$ 表示点 $u$ 能否被第 $i$ 个询问的点 $x_i$ 所到达。通过 bitset + 拓扑排序可以在 $\mathcal{O}(\frac{n^2}{\omega}+\frac{nq}{B})$ 预处理出来。

首先考虑发生改变的 $(a_i,b_i)$ 对每个询问的贡献。这个是容易计算的，对于每个询问直接暴力枚举在该块中会发生改变的所有点对，然后更新答案，该部分复杂度 $\mathcal{O}(qB)$。

然后难点在于如何计算不会发生改变的点对对每个询问的贡献。先考虑 $l=1,r=n$ 怎么做，按照 $b_i$ 从大到小排序，假设排序后的点编号是 $i_1,i_2,...,i_k$，那么先拿出来 $f_{i_1,?}$ 中值为 $1$ 的，显然由于 $b_{i_1}$ 是最大的，这些询问在该部分会得到的贡献最大值就是 $b_{i_1}$，直接更新即可。然后再拿出来 $f_{i_2,?}$ 中值为 $1$ 且在之前没有拿出来过的进行赋值即可，以此类推。关于拿出来一个 bitset 值为 $1$ 的位置可以通过自带的 _Find_first(),_Find_next() 函数，这个函数的复杂度为 $\mathcal{O}(\frac{S}{\omega}+c_1)$，其中 $S$ 为 bitset 的大小，$c_1$ 为其中 $1$ 的个数，显然容易计算出来这部分的总复杂度为 $\mathcal{O}(\frac{n^2}{\omega}+q)$。

再考虑 $l,r$ 不为 $1$ 的情况，其实也很容易处理。相当于点 $u$ 能对一个询问 $i$ 造成贡献当且仅当 $f_{u,i}$ 为 $1$ 且 $l_i\le a_u\le r_i$。考虑对每个点 $u$ 求出那些 $r_i<a_u$ 且 $l_i>a_u$ 的 $i$ 形成的 bitset，在这个是容易做到的，将询问按照 $l_i$ 从小到大排序，对询问编号做一个后缀 bitset 或，再按照 $r_i$ 从小到大排序，对询问编号做一个前缀 bitset 或。那么对每个点查询所有不满足 $l_i\le a_u\le r_i$ 的 $i$ 就是找到第一个 $l>a_u$ 的位置，然后查后缀 bitset 或，找到最后一个 $r<a_u$ 的位置，然后查前缀 bitset 或。然后处理完这个按照 $l=1,r=n$ 的做法做就完事了。

取 $B=\sqrt{q}$ 即可得到 $\mathcal{O}(\dfrac{n^2}{\omega}+(n+q)\sqrt{q})$ 的优秀复杂度。

代码比较好写，实现不精细会带上 log。排序可以使用桶排，找位置不要写二分，线性预处理出来即可。因为 $a,b$ 的值域都是 $n$。

这个做法虽然复杂度看上去很优秀，但是常数很大，完全跑不过带 log 的。

参考代码：https://www.luogu.com.cn/paste/zhq6w50k

---

## 作者：Msents (赞：3)

介绍一个坨的算法，，

注意到空间很大，时间很大，dag，所以 bitset 逃不开了。

又注意到每次询问两个条件互不干扰，考虑每个单独求满足条件的点再求两者交，最后再处理最大值。所以接下来的部分都是离线处理。

对于条件二，直接求可达性即可，这一部分 $O(\frac{n^2}{w})$。

对于条件一，可以改为求 $a_i\le r$ 的点集合去掉 $a_i < l$ 的点集合。扫一遍操作序列，维护一个序列 $c$，满足处理完之前的操作后 $a_{c_i}=i$，那么现在就要能做到求出一个 $c$ 的前缀的点的集合。这一坨我只会用树状数组加上 bitset 维护，复杂度 $O(\frac{n^2\log n}{w})$。

求出来哪些点满足条件后现在要求最大值，这一部分可以参考对条件一的处理方法。同样维护序列 $c$，只不过这次条件换成 $b_{c_i}=i$，每次二分最大值，看后缀是否和满足条件的点有交即可。使用树状数组二分，复杂度可做到 $O(\frac{n^2 \log n}{w})$，但是常数比较大。

总复杂度 $O(\frac{n^2 \log n}{w})$，时间稳定，极限卡常能搞到 88 分。

说下关于空间的，对于 $n\le 8\times 10^4$ 的部分，开两个二维 bitset，一个用来计算，另一个存结果即可。对于最后一个 subtask，存结果的只开一半，一次处理一半的询问就行，但是跑太慢过不了。

赛时 STL 版本要跑 10s，最后手写 bitset 挂了只能交破烂 STL 版本的 bitset 上去，于是特殊性质全没动，也没进一步优化，遗憾离场，，，

（剩下部分是赛后的）

注意到树状数组查询时到一些节点时其集合包含的元素不多，但合并还是 $O(\frac n w)$，二分也同理。于是设置一个阈值 $B$，对于第二部分当节点代表区间长度小于 $B$ 时直接暴力合并，第三部分二分时节点长度小于 $B$ 直接判交，可以优化到 $O(\frac{n^2\log w}{w})$，还能剔除掉一些节点优化空间，至此可以通过。

但是正解懒得写了，赛后 88 分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MaxN=80000;
int C,n,m,q,a[MaxN+1],b[MaxN+1];
struct Bitset{
	static const int Size=MaxN/64+1;
	unsigned long long arr[Size];
	Bitset(){clear();}
	int count()const{
		for(int i=0;i<Size;i++)if(arr[i])return 1;
		return 0;
	}
	void clear(){
		for(int i=0;i<Size;i++)arr[i]=0;
	}
	bool spfunc1(const Bitset&b)const{
		for(int i=0;i<Size;i++)if(arr[i]&b.arr[i])return true;
		return false;
	}
	void rev(int x){arr[x/64]^=(1ull<<(x%64));}
	void set(int x,bool b){if(((arr[x/64]>>(x%64))&1)!=b)arr[x/64]^=(1ull<<(x%64));}
	Bitset&operator&=(const Bitset&b){
		for(int i=0;i<Size;i++)arr[i]&=b.arr[i];
		return *this;
	}
	Bitset&operator|=(const Bitset&b){
		for(int i=0;i<Size;i++)arr[i]|=b.arr[i];
		return *this;
	}
	Bitset&operator^=(const Bitset&b){
		for(int i=0;i<Size;i++)arr[i]^=b.arr[i];
		return *this;
	}
	Bitset operator&(const Bitset&b)const{return Bitset(*this)&=b;}
	Bitset operator^(const Bitset&b)const{return Bitset(*this)^=b;}
}bt[MaxN+1],rs[MaxN+1];
vector<int>g[MaxN+1];
bool vst[MaxN+1];
int que[MaxN+1][4];
int LowBit(int x){return(x)&(-x);}
void Modify(int u,int x,int y){for(;u<=n;u+=LowBit(u))bt[u].rev(x),bt[u].rev(y);}
void Modifyo(int u,int x){for(;u<=n;u+=LowBit(u))bt[u].rev(x);}
Bitset Ask(int u){
	Bitset res;
	for(;u;u-=LowBit(u))res|=bt[u];
	return res;
}
void DFS(int u){
	if(vst[u])return;
	vst[u]=true;
	bt[u].set(u,true);
	for(int v:g[u])DFS(v),bt[u]|=bt[v];
}
int Check(int x){
	if(!rs[x].count())return 0;
	int p=__lg(n),u=(1<<p),ans=INT_MAX;
	while(p>=0){
		if(bt[u].spfunc1(rs[x])){
			ans=min(ans,u);
			u^=(1<<p);
		}
		if(p==0)return n-ans+1;
		do{p--;}while((u^(1<<p))>n);
		u^=(1<<p);
	}
	return n-ans+1;
}
void Solve(){
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)g[i].clear();
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		g[u].push_back(v);
	}
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	for(int i=1;i<=n;i++)bt[i].clear();
	for(int i=1;i<=q;i++){
		cin>>que[i][0]>>que[i][1]>>que[i][2];
		if(que[i][0]==3)cin>>que[i][3];
	}
	for(int i=1;i<=n;i++)Modifyo(a[i],i);
	for(int i=1,c=0;i<=q;i++){
		if(que[i][0]==1){
			int x=que[i][1],y=que[i][2];
			Modify(a[x],x,y);
			Modify(a[y],x,y);
			swap(a[x],a[y]);
		}
		if(que[i][0]==3){
			++c;
			rs[c]=Ask(que[i][3])^Ask(que[i][2]-1);
		}
	}
	for(int i=1;i<=n;i++)vst[i]=false,bt[i].clear();
	for(int i=1;i<=n;i++)DFS(i);
	for(int i=1,c=0;i<=q;i++){
		if(que[i][0]==3){
			++c;
			rs[c]&=bt[que[i][1]];
		}
	}
	for(int i=1;i<=n;i++)bt[i].clear();
	for(int i=1;i<=n;i++)Modifyo(n-b[i]+1,i);
	for(int i=1,c=0;i<=q;i++){
		if(que[i][0]==2){
			int x=que[i][1],y=que[i][2];
			Modify(n-b[x]+1,x,y);
			Modify(n-b[y]+1,x,y);
			swap(b[x],b[y]);
		}
		if(que[i][0]==3){
			++c;
			cout<<Check(c)<<'\n';
		}
	}
}
int main(){
	cin.tie(0)->sync_with_stdio(false);
	int T;
	cin>>C>>T;
	while(T--)
		Solve();
	return 0;
}

```

---

## 作者：happybob (赞：3)

考虑时间轴分块，每 $B_1$ 次操作重构一次。重构时对 $a$ 的值域分块，每一块长度为 $B_2$，每块跑一次拓扑排序 DP 即可。注意将操作所在的块内修改的点忽略，查询时对这些点重新计算。于是需要预处理一个可达关系，使用 `bitset` 即可。

取 $B_1=B_2=n^{\frac{2}{3}}$ 可以得到 $O(n^{\frac{5}{3}}+\frac{n^2}{w})$ 的做法，但是场上块长调的不太对，实现常数比较大，只能过 $6 \times 10^4$。

---

## 作者：zhenghanyun (赞：2)

## 前言

场上先开了 T3 并看错 T3 题面浪费了 1h+，导致最后 20min 会了这个题并在结束前 2min 写完但 sample WA 了，死了死了。

## 正文

首先先用 `bitset` 预处理每个点可达的点，这里需要手写 `bitset` 方便后续处理。

以 $w$ 为块长进行分块，先考虑没有修改的情况。

暴力枚举 $\mathcal{O}(\frac{n}{w})$ 个块，对于每个块求出能对当前查询产生贡献的有哪些，使用二进制状压，再查询这个集合能产生贡献的集合中 $b$ 最大的是哪个。

前者可以对一个块预处理一下按 $a$ 排序后的结果，查询时在上面二分计算满足 $a$ 序列限制的二进制表示，再和当前节点能到达的集合做一个按位与。

后者可以预处理按 $b$ 排序后前 $k$ 大的组成的集合，查询时二分查找。

带上修改的话直接暴力重构整个块即可。

时间复杂度 $\mathcal{O}(\frac{n(m + q)}{w} \log w)$，比大部分做法复杂度劣，但是常数很小并且时限很大，可以通过。

如果被卡常了可以加一个剪枝，如果当前这块 $b$ 序列的 $\max$ 比前面已经求得的答案小就不去计算，这样会快很多。

## 代码

[submission](https://www.luogu.com.cn/record/205693222)

``` cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int N = 1e5 + 5;

typedef unsigned long long ull;

struct Bitset {
	ull p[1570];

	inline void clear() {
		memset(p, 0, sizeof(p));
	}

	inline void set(const int &pos) {
		p[pos >> 6] |= (1ull << (pos & 63));
	}

	inline bool query(const int &pos) const {
		return (p[pos >> 6] >> (pos & 63)) & 1;
	}

	inline void operator|=(const Bitset &rhs) {
		for (int i = 0; i < 1570; ++i) {
			p[i] |= rhs.p[i];
		}
	}
} P[N];

int c, T, n, m, q, a[N << 1], b[N << 1];

vector <int> vec[N];

ull msk1[1570][64], msk2[1570][64];

int val1[1570][64], val2[1570][64];

inline void build(int id) {
	vector <int> tmp(64);
	for (int i = 0; i < 64; ++i) {
		tmp[i] = (id << 6 | i);
	}
	sort(tmp.begin(), tmp.end(), [](int x, int y) {
		return a[x] < a[y];
	});
	for (int i = 0; i < 64; ++i) {
		if (i == 0) {
			msk1[id][i] = 0;
		} else {
			msk1[id][i] = msk1[id][i - 1];
		}
		msk1[id][i] |= (1ull << (tmp[i] & 63));
		val1[id][i] = a[tmp[i]];
	}
	sort(tmp.begin(), tmp.end(), [](int x, int y) {
		return b[x] < b[y];
	});
	for (int i = 63; ~i; --i) {
		if (i == 63) {
			msk2[id][i] = 0;
		} else {
			msk2[id][i] = msk2[id][i + 1];
		}
		msk2[id][i] |= (1ull << (tmp[i] & 63));
		val2[id][i] = b[tmp[i]];
	}
}

inline ull query1(int id, int d) {
	if (d < val1[id][0]) {
		return 0;
	}
	int sta = 0;
	for (int i = 5; ~i; --i) {
		(val1[id][sta | (1 << i)] <= d) && (sta |= (1 << i));
	}
	return msk1[id][sta];
}

inline int query2(int id, ull p) {
	if (!p) {
		return 0;
	}
	int sta = 0;
	for (int i = 5; ~i; --i) {
		(p & msk2[id][sta | (1 << i)]) && (sta |= (1 << i));
	}
	return val2[id][sta];
}

inline void solve() {
	memset(a, 0, sizeof(a));
	memset(b, 0, sizeof(b));
	cin >> n >> m >> q;
	for (int i = 1; i <= n; ++i) {
		vec[i].clear();
	}
	while (m--) {
		int u, v;
		cin >> u >> v;
		vec[u].emplace_back(v);
	}
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
	}
	for (int i = 1; i <= n; ++i) {
		cin >> b[i];
	}
	for (int i = n; i; --i) {
		P[i].clear();
		P[i].set(i);
		for (auto u: vec[i]) {
			P[i] |= P[u];
		}
	}
	for (int i = 0; i < 1570; ++i) {
		build(i);
	}
	while (q--) {
		int op;
		cin >> op;
		if (op == 1) {
			int x, y;
			cin >> x >> y;
			swap(a[x], a[y]);
			build(x >> 6), build(y >> 6);
		} else if (op == 2) {
			int x, y;
			cin >> x >> y;
			swap(b[x], b[y]);
			build(x >> 6), build(y >> 6);
		} else {
			int x, l, r, res = 0;
			cin >> x >> l >> r;
			for (int i = 0; i < 1570; ++i) {
				if (val2[i][63] < res) {
					continue;
				}
				ull p = query1(i, r) ^ query1(i, l - 1);
				p &= P[x].p[i];
				res = max(res, query2(i, p));
			}
			cout << res << "\n";
		}
	}
}

int main() {
#ifdef LOCAL
	assert(freopen("recall.in", "r", stdin));
	assert(freopen("recall.out", "w", stdout));
#endif
	ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
	cin >> c >> T;
	while (T--) {
		solve();
	}
	return 0;
}
```

---

## 作者：xzf_200906 (赞：2)

由于正式代码没发，先口胡一个题解，等发了代码再补。不明白为什么其它的题解复杂度都那么奇怪。

对于每个点 $p$ ，如果把相邻且 $a_p$ 和 $b_p$ 相同的时间看作一个区间，那么这些区间的数量之和是 $\mathcal{O}(q)$ 级别的。先计算出若干五元组 $\langle l,r,p,x,y\rangle$ 表示在时间段 $[l,r]$ 中，$a_p=x,b_p=y$。考虑将这些五元组按 $y$ 从大到小排序。如果我们可以快速计算出在尚未处理的询问中有哪些询问受到了它的影响，就可以一一遍历这些询问，将其答案改成 $y$。之后由于当前的 $y$ 是尚未处理的五元组中最大的，那么这个询问的答案不会更大，将其删去。将一个询问视为四元组 $\langle dfn,u,zl,zr\rangle$ 表示在时间 $dfn$ 时的一个询问。则该询问会受到该五元组影响当且仅当：
+ $u$ 可达 $p$。
+ $zl\leq x$。
+ $zr\geq x$。
+ $dfn\in [l,r]$。

上述限制都可以容易地用 bitset 表示。但由于作者在考场上发现会被卡空间，于是就考虑将询问按 $dfn$ 排序，将每 $64$ 个询问分一块并用一个 `unsigned long long` 表示。具体地说，对每块中的每个询问用状压计算出每个点是否可以被该询问中的点 $u$ 到达，并处理出对于每个 $x$ 满足 $x\in [zl,zr]$ 的询问的集合，再用一个变量状压尚未被计算答案的询问集合。再按顺序遍历每个五元组即可计算答案。时间复杂度为 $\mathcal{O}(\frac{q}{\omega}(n+m))$。思路简单到我在考场上想出来时差点以为是假的。

顺带一提，考场代码在跑大样例时本机跑了将近 8s，感觉会卡常。

---

## 作者：yzq_yzq (赞：2)

场上没调出来，死了，写个题解。

不难发现是不弱于可达性统计 $\frac {nm} w$ 的，而且 $a,b$ 是排列，考虑 bitset 。

图是不变的，提前跑一遍可达性统计 $O(\frac {nm} w)$ 。

修改很恶心，直接时间分块， $B$ 个一组，把修改过的点暴力查，然后再按照询问的端点把序列分成 $2B$ 块，然后询问挂在块上，然后考虑怎么快速把这挂着的 $qB$ 次查询快速做。

实际上不必做到 $O(1)$ 单次，$O(\frac {\sqrt n} w)$ 也是可以接受的，考虑先对询问的 $B$ 个点跑一遍可达性统计放到一个大小是 $B$ 的 bitset 里边，对于一个块内按 $b$ 从大到小排序过后，不难发现一个询问假如已经有一个数给过贡献的就不用再查询了，因为后边的一定不优，这个可以用 bitset 的 & 实现，每次把前边可到达这个点的点集的 bitset 跟查询集合 & 一下就是有贡献的查询，然后把查询集合中这次有贡献的删去，然后均摊下来单次询问是 $\frac {B^2}{w}$ 的。

至于排序，因为总的值域是 $n$ 而且 $b$ 是排列，所以 $2B$ 个块一起做，从 $n$ 到 $1$ 枚举就行了。


这个做法比较卡常，bitset 建议手写压 64 位，不然不太可能过。

```cpp
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; ++i)
#define drep(i, x, y) for (int i = x; i >= y; --i)
#define ll long long
#define pb emplace_back
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
#define ull unsigned ll
using namespace std;
const int N = 100010;
int n, m, q, a[N], b[N];
namespace ae86 {
	const int bufl = 1 << 20;
	char buf[bufl], *s = buf , *t = buf;
	inline int fetch() {
		if(s==t){ t = (s = buf) + fread(buf, 1, bufl, stdin); if(s == t) return EOF; }
		return *s++;
	}
	inline int read() {
		int a = 0, c = fetch();
		while(!isdigit(c)) c = fetch();
		while(isdigit(c)) a = a * 10 + c - 48, c = fetch();
		return a;
	}
}
using ae86::read;
struct Bs {
	ull f[1584];
	inline void reset() { __builtin_memset(f, 0, sizeof f); }
	inline void operator |=(const Bs &y) {
		for(int i = 0; i < 1584; i += 8) {
			f[i] |= y.f[i];
			f[i + 1] |= y.f[i + 1];
			f[i + 2] |= y.f[i + 2];
			f[i + 3] |= y.f[i + 3];
			f[i + 4] |= y.f[i + 4];
			f[i + 5] |= y.f[i + 5];
			f[i + 6] |= y.f[i + 6];
			f[i + 7] |= y.f[i + 7];
		}
	}
	inline void set1(int x) { f[x >> 6] |= (1ull << (x & 63)); }
	inline bool Q(int x) { return (f[x >> 6] >> (x & 63)) & 1; }
};
Bs f[N]; int tt[2048];
struct Bitset {
	ull f[7];
	inline void reset() { f[0] = f[1] = f[2] = f[3] = f[4] = f[5] = f[6] = 0; }
	inline void fill() { f[0] = f[1] = f[2] = f[3] = f[4] = f[5] = f[6] = ~0ull; }
	inline void set1(int x) { f[x >> 6] |= (1ull << (x & 63)); }
	inline void set0(int x) { f[x >> 6] &= ~(1ull << (x & 63)); }
	inline friend Bitset operator |(const Bitset &x, const Bitset &y) {
		return {x.f[0] | y.f[0], x.f[1] | y.f[1], x.f[2] | y.f[2], x.f[3] | y.f[3], x.f[4] | y.f[4], x.f[5] | y.f[5], x.f[6] | y.f[6]};
	}
	inline friend Bitset operator &(const Bitset &x, const Bitset &y) {
		return {x.f[0] & y.f[0], x.f[1] & y.f[1], x.f[2] & y.f[2], x.f[3] & y.f[3], x.f[4] & y.f[4], x.f[5] & y.f[5], x.f[6] & y.f[6]};
	}
	inline friend Bitset operator ^(const Bitset &x, const Bitset &y) {
		return {x.f[0] ^ y.f[0], x.f[1] ^ y.f[1], x.f[2] ^ y.f[2], x.f[3] ^ y.f[3], x.f[4] ^ y.f[4], x.f[5] ^ y.f[5], x.f[6] ^ y.f[6]};
	}
#define ck(i) if(f[i]) return __builtin_ctzll(f[i]) + (i << 6)
	inline int find() { ck(0); ck(1); ck(2); ck(3); ck(4); ck(5); ck(6); return -1; }
} F[N], v[2048];
vector<int> G[N], g[N]; int ans[N], ida[N], idb[N];
int bl[N], tot, cnt_st, st[N], pt[N], cnt, id[N], vl[N], vr[N], val[N], p[N], qid[N]; bitset<N> vis;
struct node { int op, x, y, u; } Q[N];
inline void swa(int x, int y) {
	swap(ida[a[x]], ida[a[y]]);
	swap(a[x], a[y]);
}
inline void swb(int x, int y) {
	swap(idb[b[x]], idb[b[y]]);
	swap(b[x], b[y]);
}
int pos[N];
inline void solve() {
	n = read(), m = read(), q = read();
	rep(i, 1, n) G[i].clear(), f[i].reset(), g[i].clear();
	rep(i, 1, m) {
		int u = read(), v = read();
		G[u].pb(v), g[v].pb(u);
	}
	rep(i, 1, n) f[i].set1(i);
	rep(i, 1, n) {
		for(int j : G[i]) f[j] |= f[i];
	}
	rep(i, 1, n) a[i] = read(), ida[a[i]] = i;
	rep(i, 1, n) b[i] = read(), idb[b[i]] = i;
	rep(i, 1, q) {
		int op = read(), x = read(), y, l, r; ans[i] = 0;
		Q[i].op = op, Q[i].u = -1;
		if(op <= 2) y = read(), Q[i].x = x, Q[i].y = y;
		else l = read(), r = read(), Q[i].x = l, Q[i].y = r, Q[i].u = x;
	}
	int sq = 600, v_ = 0;
	for(int L = 1, R; L <= q; L = R + 1) {
		R = min(q, L + sq - 1);
		v_ = 0;
		rep(i, L, R) {
			v_ += (Q[i].op == 3);
			if(v_ > 440) {
				R = i - 1;
				break;
			}
		}
		//	cout << "Qblock : " << L << " " << R << '\n';
		bool if_q = 0;
		rep(i, L, R) if_q |= (Q[i].op == 3);
		if(!if_q) {
			rep(i, L, R) {
				if(Q[i].op == 1) swa(Q[i].x, Q[i].y);
				if(Q[i].op == 2) swb(Q[i].x, Q[i].y);
			}
			continue;
		}
		cnt = 0, vis.reset(), tot = 0, cnt_st = 0;
		auto ins = [&](int x) {
			if(vis[x] == 1) return;
			vis[x] = 1, pt[++cnt] = x;
			id[x] = cnt;
		};
		rep(i, L, R) {
			if(Q[i].op <= 2) ins(Q[i].x), ins(Q[i].y);
			else {
				if(Q[i].x > 1) bl[++tot] = Q[i].x - 1;
				bl[++tot] = Q[i].y;
				st[++cnt_st] = Q[i].u;
				qid[cnt_st] = i;
			}
		}
		rep(i, 1, n) F[i].reset();
		rep(i, 1, cnt_st) F[st[i]].set1(i);
		rep(i, 1, n) {
			for(int j : G[i]) F[j] = F[j] | F[i];
		}
		bl[++tot] = n;
		sort(bl + 1, bl + 1 + tot);
		tot = unique(bl + 1, bl + 1 + tot) - bl - 1;
		rep(i, 1, tot) {
			vl[i] = bl[i - 1] + 1, vr[i] = bl[i];
			rep(j, vl[i], vr[i]) pos[j] = i, val[j] = b[ida[j]];
			v[i].fill(), tt[i] = cnt_st;
			rep(j, 1, cnt_st) if(Q[qid[j]].y < vl[i] || Q[qid[j]].x > vr[i]) v[i].set0(j), --tt[i];
		}
		Bitset t;
		drep(o, n, 1) {
			int j = a[idb[o]], i = pos[j];
			if(!tt[i]) continue;
			if(vis[ida[j]] == 1) continue;
			t = v[i] & F[ida[j]];
			while(1) {
				int x = t.find();
				if(x == -1) break;
				ans[qid[x]] = max(ans[qid[x]], o);
				v[i].set0(x), t.set0(x), --tt[i];
			}
		}
		rep(i, L, R) {
			if(Q[i].op == 1) swa(Q[i].x, Q[i].y);
			if(Q[i].op == 2) swb(Q[i].x, Q[i].y);
			if(Q[i].op == 3) {
				rep(j, 1, cnt) {
					int x = pt[j];
					if(f[x].Q(Q[i].u) && a[x] >= Q[i].x && a[x] <= Q[i].y)
						ans[i] = max(ans[i], b[x]);
				}
			}
		}
	}
	rep(i, 1, q) if(Q[i].op == 3) printf("%d\n", ans[i]);
}
int main() {
	int task_id = read(), T = read();
	while(T--) solve();
	return 0;
}
```

---

## 作者：OccDreamer (赞：2)

首先用 bitset 处理出 $R(x)$ 表示 $x$ 能到的点集合

设 $A(k)=\{i : a_i \leq k\}$，$B(k)=\{i : b_i \geq k\}$

那么对于一次询问 $x,l,r$ 我们设 $S=R(x) \cap (A(r)-A(l-1))$

维护 $A(i)$ 可以分块维护，也就是维护 $A(X),A(2X),A(3X),A(4X)\dots$，这个地方阈值随便取一个基本都行，因为这里主要是防止空间超过 $2048\text{MB}$，我取的是 $X=\frac{n}{256}$

接下来我们可以二分答案，也就是二分一个 $mid$ 看下 $S$ 和 $B(mid)$ 是否有交

类似的维护 $B(n-X),B(n-2X),B(n-3X),B(n-4X)\dots$

需要注意的是这里二分的 $\log$ 是和块的数量有关的

我取的 $X=\frac{n}{16}$，分析一下复杂度为 $O(\frac{nm+nq \log \omega}{\omega})$

中间修了点东西，所以代码写得有点唐，见谅

下面这份代码通过了云斗的数据

```cpp
//Mashiro
#include<bits/stdc++.h>

#define vc vector
#define db double
#define fi first
#define se second
#define ll long long
#define mk make_pair
#define pb push_back
#define RI register int
#define PI pair<int,int>
#define ull unsigned long long
#define err cerr << "   -_-   " << endl
#define debug cerr << " ------------------- " << endl

#define input(x) freopen(#x".in","r",stdin)
#define output(x) freopen(#x".out","w",stdout)

#define NO puts("No")
#define YES puts("Yes")

//#define OccDreamer
//#define int long long

using namespace std;

namespace IO{
	inline ll read(){
		ll X=0, W=0; char ch=getchar();
		while(!isdigit(ch)) W|=ch=='-', ch=getchar();
		while(isdigit(ch)) X=(X<<1)+(X<<3)+(ch^48), ch=getchar();
		return W?-X:X;
	}
	inline void write(ll x){
		if(x<0) x=-x, putchar('-');
		if(x>9) write(x/10);
		putchar(x%10+'0');
	}
	inline void sprint(ll x){write(x), putchar(32);}
	inline void eprint(ll x){write(x), putchar(10);}
}using namespace IO;

const int MAXN = 1e5 + 2;

int c, T;
int n, m, q;
int o[MAXN], x[MAXN], l[MAXN], r[MAXN];
int a[MAXN], b[MAXN], va[MAXN], vb[MAXN];

bitset<100001> arr[MAXN];
bitset<100001> ans, res, tmp; 

vc<int> G[MAXN];

struct Data{
    int B, bel[MAXN], R[MAXN];
    bitset<100001> arr[500];
    inline void clear(){
        for(int i=0;i<500;++i) arr[i].reset();
        return ;
    }
    inline void add(int x, int v){
        for(int i=bel[x];i<=bel[n];++i) arr[i][v]=1;
        return ;
    }
    inline void del(int x, int v){
        for(int i=bel[x];i<=bel[n];++i) arr[i][v]=0;
        return ;
    }
    inline void queryA(int l, int r){
        // [1,r] ^ [1,l-1] res
        if(l==1) tmp.reset();
        else{
            l--;
            tmp=arr[bel[l]-1];
            for(int i=R[bel[l]-1]+1;i<=l;++i) tmp[a[i]]=1;
        }
        res=arr[bel[r]-1];
        for(int i=R[bel[r]-1]+1;i<=r;++i) res[a[i]]=1;
        res^=tmp;
        return ;
    }
    inline int Ask(){
        if(ans.any()==0) return n+1;
        int l=1, r=bel[n], mid;
        while(l<=r){
            mid=(l+r)>>1;
            if((arr[mid]&ans).any()) r=mid-1;
            else l=mid+1;
        }
        // cerr << "l=" << l << ' ' << R[l-1]+1 << ' ' << R[l] << endl;
        // for(int i=1;i<=n;++i) cout << arr[1][i];
        // cout << endl;
        for(int i=R[l-1]+1;i<=R[l];++i)
            if(ans[b[i]]) return i;
        return n+1;
    }
}aa, bb;

inline void solve(){
    n=read(), m=read(), q=read();
    for(int i=1;i<=n;++i) G[i].clear();
    for(int i=1;i<=m;++i){
        int x, y;
        x=read(), y=read();
        G[x].pb(y);
    }
    for(int i=1;i<=n;++i) va[i]=read(), a[va[i]]=i;
    for(int i=1;i<=n;++i) vb[i]=n-read()+1, b[vb[i]]=i;
    for(int i=1;i<=n;++i) arr[i].reset(), arr[i][i]=1;
    for(int i=n;i>=1;--i)
        for(auto j:G[i]) arr[i]|=arr[j];
    for(int i=1;i<=q;++i){
        o[i]=read(), x[i]=read();
        if(o[i]!=3) l[i]=read();
        else l[i]=read(), r[i]=read();
    }
    // return ;
    aa.B=100000/256;
    for(int i=1;i<=n;++i) aa.bel[i]=(i-1)/aa.B+1, aa.R[aa.bel[i]]=i;
    for(int i=1;i<=n;++i){
        if(aa.R[aa.bel[i]]==i){
            aa.arr[aa.bel[i]].reset();
            for(int j=1;j<=i;++j) aa.arr[aa.bel[i]][a[j]]=1;
        }
    }
    bb.B=100000/16;
    for(int i=1;i<=n;++i) bb.bel[i]=(i-1)/bb.B+1, bb.R[bb.bel[i]]=i;
    for(int i=1;i<=n;++i){
        if(bb.R[bb.bel[i]]==i){
            bb.arr[bb.bel[i]].reset();
            for(int j=1;j<=i;++j) bb.arr[bb.bel[i]][b[j]]=1;
        }
    }
    for(int i=1;i<=q;++i){
        if(o[i]==1){
            int A=x[i], B=l[i];
            aa.del(va[A],A); aa.del(va[B],B);
            aa.add(va[A],B); aa.add(va[B],A);
            a[va[A]]=B; a[va[B]]=A;
            swap(va[A],va[B]);
        }
        if(o[i]==2){
            int A=x[i], B=l[i];
            bb.del(vb[A],A); bb.del(vb[B],B);
            bb.add(vb[A],B); bb.add(vb[B],A);
            b[vb[A]]=B; b[vb[B]]=A;
            swap(vb[A],vb[B]);
        }
        if(o[i]==3){
            ans=arr[x[i]];
            aa.queryA(l[i],r[i]);
            // for(int j=1;j<=n;++j) cout << ans[j];
            // cout << endl;
            // debug;
            ans&=res;
            // cerr << "ans=" << endl;
            eprint(n-bb.Ask()+1);
        }
    }
}

int main(){
    freopen("recall.in","r",stdin);
    freopen("recall.out","w",stdout);
    c=read(), T=read();
    while(T--) solve();
    return 0;
}
```

---

## 作者：20_200 (赞：1)

3.3k，赛时写过最长的题。极限调出来真的是奇迹。

数据结构乱搞题。

以下认为 $n,m,q$ 同阶。

首先看到有向图（本题是 DAG）可达性就可以直接上 bitset 预处理了，这东西只能 $O(\frac{n^2}{w})$。再注意到本题特别的时空限制基本就一眼真了。

需要区间查询，那就开一个bitset维护当前区间的每个点是否符合 $l\le a_y\le r$，查询的时候 $x$ 能到 $y$ 的限制就是维护的区间合法点集 and  $x$ 可达点集。

每次询问合并 $O(\log n)$ 个 bitset 显然不行，那么就不能在外面套线段树，所以直接莫队。有修改，那就带修莫队。

需要查询 bitset 里面为 $1$ 的位置对应的 $b$ 的最大值，一个一个枚举显然不行，那就手写bitset，对于每 $w$ 个 bit 组成的 unsigned long long，在里面二分最大值，这样每次查询一个 $w$ 集合的最大值的复杂度就能做到 $O(\log w)$。

这要求在修改 $b$ 的过程中维护每个 $w$ 集合里面对应位置的第 $1\sim w$ 大的 $b$ 值，那么每次修改 $b$ 就是 $O(w)$ 的，套在莫队里显然不行，所以先预处理，在一开始就把每次修改后 $b$ 对应的 $w$ 集合直接存下来，然后再开一个数组维护每个 $w$ 集合对应的版本编号，莫队里修改 $b$ 的时候直接修改对应的版本编号就可以做到 $O(1)$ 了。

时间复杂度 $O(n^{5/3}+\frac{n^2\log w}{w})$。

然后这道题就做完了，剩下的是一份巨大长丑的代码，考场大样例 8s，可能还要卡常才能通过。

GD代码压缩包有密码，所以代码等发密码之后再放，~~真的不想复盘了太恶心了~~。

---


# [省选联考 2025] 图排列

## 题目背景

考虑到评测机性能差距，本题较官方赛事增加了 0.5 秒的额外时限。

## 题目描述

小 Q 有 $m$ 个互不相同的正整数二元组 $\{(a_i, b_i)\}_{i=1}^m$，其中对于所有 $1 \leq i \leq m$，$1 \leq a_i < b_i \leq n$。这 $m$ 个二元组满足如下性质：不存在 $1 \leq i, j \leq m$ 满足 $a_i < a_j < b_i < b_j$。

小 D 有一个 $1 \sim n$ 的排列 $p$。小 Q 和小 D 利用他们手上的二元组和排列一起构建了一张 $n$ 个点 $m$ 条边的无向图 $G = (V, E)$，其中 $V = \{1, 2, \ldots, n\}$，$E = \{(p_{a_i}, p_{b_i}) \mid i \in \{1, 2, \ldots, m\}\}$。

现在小 I 得知了图 $G$，他想要知道在小 Q 的 $m$ 个二元组所具有的性质的前提下，小 D 手中的排列 $p$ 可能是什么。由于小 I 手中的信息不足，排列 $p$ 有很多种可能，小 I 希望你可以告诉他其中字典序最小的那一个。

小 Q，小 D 和小 I 是很好的朋友，他们保证不会欺骗彼此，因此存在至少一个排列 $p$ 满足条件。

## 说明/提示

**【样例 1 解释】**

该组样例共有 $2$ 组测试数据。
- 对于第一组测试数据，
 - 如果小 D 的排列为 $[1, 2, 3, 4]$，那么小 Q 拥有的二元组为 $\{(1, 3), (2, 4)\}$，但取 $i = 1, j = 2$ 有 $1 < 2 < 3 < 4$，因此不满足小 Q 的二元组的性质。
 - 如果小 D 的排列为 $[1, 2, 4, 3]$，那么小 Q 拥有的二元组为 $\{(1, 4), (2, 3)\}$，可以证明其满足性质。
- 对于第二组测试数据，如果小 D 的排列为 $[1, 3, 2, 4]$，那么小 Q 拥有的二元组为 $\{(2, 3), (3, 4), (1, 2), (1, 4), (2, 4)\}$，可以证明其满足性质。

**【样例 2】**

见选手目录下的 graperm/graperm2.in 与 graperm/graperm2.ans。

该组样例满足测试点 $1, 2$ 的限制。

**【样例 3】**

见选手目录下的 graperm/graperm3.in 与 graperm/graperm3.ans。

该组样例满足测试点 $3, 4$ 的限制。

**【样例 4】**

见选手目录下的 graperm/graperm4.in 与 graperm/graperm4.ans。

该组样例满足测试点 $5, 6$ 的限制。

**【样例 5】**

见选手目录下的 graperm/graperm5.in 与 graperm/graperm5.ans。

该组样例满足测试点 $7, 8$ 的限制。

**【样例 6】**

见选手目录下的 graperm/graperm6.in 与 graperm/graperm6.ans。

该组样例满足测试点 $9 \sim 11$ 的限制。

**【样例 7】**

见选手目录下的 graperm/graperm7.in 与 graperm/graperm7.ans。

该组样例满足测试点 $12$ 的限制。

**【样例 8】**

见选手目录下的 graperm/graperm8.in 与 graperm/graperm8.ans。

该组样例满足测试点 $13 \sim 15$ 的限制。

**【样例 9】**

见选手目录下的 graperm/graperm9.in 与 graperm/graperm9.ans。

该组样例满足测试点 $16 \sim 18$ 的限制。

**【样例 10】**

见选手目录下的 graperm/graperm10.in 与 graperm/graperm10.ans。

该组样例满足测试点 $19 \sim 21$ 的限制。

**【样例 11】**

见选手目录下的 graperm/graperm11.in 与 graperm/graperm11.ans。

该组样例满足测试点 $22 \sim 25$ 的限制。

**【子任务】**

对于所有测试点，
- $1 \leq T \leq 10$，
- $2 \leq n \leq 10^5$，$0 \leq m \leq 2n$，
- $\forall 1 \leq i \leq m$，$1 \leq u_i, v_i \leq n$，$u_i \neq v_i$，即 $G$ 没有自环，
- $\forall 1 \leq i < j \leq m$，$\{u_i, v_i\} \neq \{u_j, v_j\}$，即 $G$ 没有重边，
- 保证存在至少一个排列 $p$ 满足条件。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | 特殊性质 |
|:------------:|:----------:|:----------:|
| $1,2$ | $10$ | 无|
| $3,4$ | $2\,000$ | AC|
| $5,6$ | ^ | A |
| $7,8$ | ^ | C |
| $9 \sim 11$ | ^ | 无|
| $12$ | $10^5$ | ABC |
| $13 \sim 15$| ^ | AC|
| $16 \sim 18$| ^ | A |
| $19 \sim 21$| ^ | C |
| $22 \sim 25$| ^ | 无|

- 特殊性质 A：$G$ 连通。
- 特殊性质 B：$G$ 中每个点的度数不超过 $2$。
- 特殊性质 C：$G$ 中不存在简单环，即 $G$ 是一个森林。

## 样例 #1

### 输入

```
0 2
4 2
1 3
4 2
4 5
2 3
4 2
3 1
1 4
3 4```

### 输出

```
1 2 4 3
1 3 2 4```

# 题解

## 作者：CarroT1212 (赞：26)

25-8-6 upd：修改了一些比较奇怪的措辞。

提供一个不涉及太多图论知识的强行讨论做法。

首先定好转化方向：有一个图 $G$，要将它的点按某种顺序排成一行，连接这些点的边呈一个括号匹配状态（即如果把这些边放到这一行点的同一侧画出来，可以**没有边在非端点处相交**）。比如这样。

![比如这样](https://cdn.luogu.com.cn/upload/image_hosting/itj3iqxy.png)

然后我们希望这个重排方案满足：对于重排后的第一个位置，它在原图中对应的点的编号尽量小，如果两种方案相同就比较第二个位置……那么可以这样理解字典序最小的限制：**有一个答案序列，我们每次需要在保证有解的情况下，把编号最小的一个点加到答案序列后面。**

以下如果无特殊说明，称“位置”为答案序列里的位置（重排后的编号），“点”为原图的点。

### AC 性质（树）

> 省流：从 $1$ 开始递归，每次把当前点自己和儿子的子树最小值搓到一起排序，从小到大遍历，如果是儿子就进入儿子子树递归，如果是自己就把自己加到答案序列后面。

显然任何树都是有解的，只要把原图的点按任意 dfn 重排即可。但这样未必最优。

首先把 $1$ 作根并且直接将 $1$ 推进答案。然后考虑它的后代被推进答案的顺序有什么限制。

观察：$1$ **的每棵子树分配到的位置都必须是一段连续区间**。不然如果有不同子树混在一起，那么各个子树里连接的边排开来一定会相交。所以不同子树就独立开了。

考虑按什么顺序把连续区间分配给这些子树。画一下可以得知：每棵子树里的任何一个点，作为子树中第一个被推进答案的点，都有解。也就是如果我们即将处理一棵 $1$ 的子树，那么紧接着第一个被推进答案序列的点，一定可以是这个子树里的最小值。

所以应该按子树内最小值从小到大处理 $1$ 的儿子子树，递归地处理即可。考虑进入儿子子树后该如何确定顺序。设这个儿子为 $p$。$p$ 的每棵子树分配到的位置也必须是连续区间。

和 $1$ 的情况不同的地方在于，$p$ 不一定是子树内最小值，所以它并不一定是第一个被推进答案的点。这个问题其实很好解决：我们把 $p$ 自己也和 $p$ 的每棵儿子子树（的最小值）放到一起进行排序。在按顺序进儿子子树的过程中如果遇到的是 $p$ 就把 $p$ 自己推进答案即可。$1$ 的情况也可以这么写。

于是这样递归下去就行了，没有实现难度。至此 $32$ 分。画个比较扭曲的例子。

![例子](https://cdn.luogu.com.cn/upload/image_hosting/cundj7fd.png)

我现场的想法比这要复杂一些，就是每次我需要把子树内最小值到根的这条链拿出来，依次处理上面挂的子树。其实本质完全是一样的，不过后面推广就需要多转几个弯了。

### C 性质（森林）

实际上和树没什么差别。思考可以得知，不同的树占用的位置区间（即能包含一棵树在答案序列里的所有位置的极小区间），只可能包含或不交。也就是我们**一旦开始做一棵树，就要把它做完，或者在里面开始一些新的树**。否则必定不合法。

那么稍微修改一下树的做法就好了：每次我们想把一棵树的一个点推进答案的时候，如果存在比它更小的点，所在的树还没有被处理过，我们就先以这个更小的点为根进入它所在的树进行处理，完全处理完再回来继续做原本这棵树的情况。（注意这样的未被处理的更优点可能有很多个）

容易实现。至此 $52$ 分。

实际上，树 $\to$ 森林的方法，在连通块 $\to$ 任意图上也是成立的。所以目标就是把连通块的做法搞出来。

### A 性质（连通块）

也许无关紧要地证明一个事情：第一个位置还一定可以是 $1$。可以看看上面的第一张图，显然把答案序列的一段前缀反过来拼到后面并不会导致原本不相交的边相交，那对于一个合法的答案序列我们一定可以把 $1$ 调整到最前面。然后考虑怎么做。

（赛时止步于此，感谢 @Nightingale_OI 和 @hxhhxh 对思路的指教）

比较对我电波的一种做法是，尝试把图刻画为 dfs 树+若干返祖边。所以现在要考虑的只是树的情况上面多了返祖边应该怎么办。

由于题目保证有解，所以其实这里很多图形态都是不需要考虑的，这个得等具体分析的时候去看。

直接套树的做法的问题是，“子树里每个点都可以第一个被推进答案”的结论不成立了，可能会触发某些返祖边的限制。我们希望知道，现在该如何找出每个子树里可以第一个推进答案的点。

比如给刚刚图里的那棵树加上几条返祖边，它的最优方案会变成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/p7har6fx.png)

（其实画岔了，并不是同一棵树，但是意思到了就行）

考虑 $3\to 1$ 那条返祖边。它本质上限制了：$3\rightsquigarrow 6$ 这一整条链（$6$ 的意义是 $1$ 在 $3$ 方向上的二级儿子），它们都需要同时成为父亲的第一个被处理的儿子，或者同时成为最后一个被处理的。只有这样才能让 $3\to 1$ 不和 $3\rightsquigarrow 1$ 上的任何东西相交。

这里同时成为第一个儿子是更优的，可以先把 $3$ 推进答案。而 $2$ 就推不进去，因为总会因为返祖边限制导致不得不有更大的点挡在前面。

结合这个例子，我们可以得到答案处理顺序符合返祖边限制的一个必要条件：一个点 $p$，如果某些儿子子树里有返祖边连向了 $p$ 的祖先，那么**这样的儿子子树一定要被放在 $p$ 的儿子（和 $p$ 自己）中第一个处理，或者最后一个处理**。显然这样的子树每个点最多只有两棵（如果有两棵就是一个最前一个最后）。

以及，因为一些这样的特殊子树可能是因为同一条返祖边产生的，所以还有一个必要条件就是同步限制：**如果一个点的特殊子树被放在第一个（最后一个）处理，那么它的父亲的因同一条返祖边产生的特殊子树也要放在第一个（最后一个）处理**。有些点可能没有这个限制。

显然，同时满足两个必要条件就是答案序列合法的充要条件。强烈建议手画感受一下。

每个 $p$ 上具体的限制容易类 tarjan 地预处理。称这至多两个被限制的儿子为限儿，子树内可能被第一个推进答案的点叫做打头点。（奇怪的命名。）

分别维护每个 $p$：无限儿时子树内最小的打头点；有一个限儿时，限儿被第一个处理和最后一个处理时，最小的打头点；有两个限儿时，它们在处理顺序上分别被排在头尾和尾头时，最小的打头点。

一遍树形 DP 就可以转移这几个东西。整体思路是，对于没被限住的子树还是取最优打头点贪心排序；限儿就分讨一下放在最前面还是最后面，并分别处理，在保证父子限制同步的情况下，有哪些状态可能转移上来。

这里详细列一下父子限制同步的所有可能情况。

假设我们现在让 $p$ 的某个限儿 $u$ 被第一个处理，找 $u$ 能转移到 $p$ 的方案都有什么。手画一下可以发现，只有如下的四种情况。

图丑见谅。其中 $v,w$ 都指 $u$ 的限儿。

![图](https://cdn.luogu.com.cn/upload/image_hosting/mszjhuyb.png)

注意后两种情况，$w$ 只能是接在 $p$ 上的，不然就无解了。

$u$ 被最后一个处理的情形和上面是恰好相反的，不再赘述。

剩下的非限儿用 DP 出的最小打头点从小到大排好。完成 DP 后按照最优值对应的顺序生成答案序列即可。

> @beta99999 在评论中提出的做法：对「限儿」建立二叉树，tarjan 找到割点的时候中序遍历，遍历每个节点前根据 low 与当前节点的一致性决定是否交换左右儿子。遍历的结果就是点双的哈密顿回路。

实现细节较多，至此 $72$ 分。

### 正解（一般图）

已经结束咧！用森林一样的方法套连通块情况即可。至此 $100$ 分。线性或带 $\log$ 都可通过。

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define fi first
#define se second
using namespace std; bool MEM;
using ll=long long; using ld=long double;
using pii=pair<int,int>; using pll=pair<ll,ll>;
const int I=1e9,N=2e5+7;
const ll J=1e18;
int type,n,m;
int vis[N],dfn[N],cnn,low[N],st[N][2],tp[N],dp[N][2];
vector<int> e[N],ans;
vector<pii> e1[N],to[N][2];
set<int> s;
void joi(vector<pii> &x,vector<pii> &y) { for (pii i:y) x.pb(i); }
int cal(int x,int p) {
	if (!tp[x]) return dp[x][0]>dp[x][1];
	else if (tp[x]==1) return low[st[x][0]]==dfn[p]; 
	else { int xx=low[st[x][0]],yy=low[st[x][1]]; return xx==yy?dp[x][0]>=dp[x][1]:xx>yy; }
}
void dfs(int p,int f) {
	dfn[p]=low[p]=++cnn,dp[p][0]=dp[p][1]=p;
	for (int i:e[p]) if (i!=f) {
		if (!dfn[i]) {
			dfs(i,p),low[p]=min(low[p],low[i]);
			if (low[i]<dfn[p]) st[p][tp[p]++]=i;
			else e1[p].pb({i,dp[i][0]>=dp[i][1]});
		}
		else low[p]=min(low[p],dfn[i]);
	}
	e1[p].pb({p,0});
	sort(e1[p].begin(),e1[p].end(),[&](pii x,pii y){return dp[x.fi][x.se]<dp[y.fi][y.se];});
	int x=st[p][0],y=st[p][1];
	if (tp[p]>=1) to[p][0].pb({x,cal(x,p)});
	if (tp[p]>=2) to[p][1].pb({y,cal(y,p)});
	for (pii i:e1[p]) to[p][0].pb(i),to[p][1].pb(i);
	if (tp[p]>=1) to[p][1].pb({x,cal(x,p)^1});
	if (tp[p]>=2) to[p][0].pb({y,cal(y,p)^1});
	pii xx=to[p][0][0],yy=to[p][1][0];
	int wx=dp[xx.fi][xx.se],wy=dp[yy.fi][yy.se];
	dp[p][0]=wx,dp[p][1]=wy;
}
void dfs2(int p) { s.erase(p),vis[p]=1; for (int i:e[p]) if (!vis[i]) dfs2(i); }
void dfs1(int p,int x) {
	if (s.count(p)) dfs2(p),x=dp[p][0]>=dp[p][1];
	for (pii i:to[p][x]) {
		if (i.fi==p) {
			while (s.size()&&*s.begin()<p) dfs(*s.begin(),0),dfs1(*s.begin(),0);
			ans.pb(p);
		}
		else dfs1(i.fi,i.se);
	}
}
void mian() {
	scanf("%d%d",&n,&m),ans.clear(),cnn=0;
	for (int i=1;i<=n;i++)
		e[i].clear(),e1[i].clear(),to[i][0].clear(),to[i][1].clear(),vis[i]=dfn[i]=tp[i]=0,
		s.insert(i);
	for (int i=1,x,y;i<=m;i++) scanf("%d%d",&x,&y),e[x].pb(y),e[y].pb(x);
	for (int i=1;i<=n;i++) if (!dfn[i]) dfs(i,0),dfs1(i,0);
	for (int i:ans) cout<<i<<" \n"[i==ans.back()];
}
bool ORY; int main() {
	// while (1)
	int t; for (scanf("%d%d",&type,&t);t--;)
	mian();
	cerr<<"\n"<<abs(&MEM-&ORY)/1048576<<"MB";
	return 0;
}
```

---

## 作者：OccDreamer (赞：13)

感觉挺有意思的。

首先我们可以对于 $G$ 的每一个连通块分别求解答案，最后再考虑整合到一起。

### 树

首先来考虑树的情况，对于给定的一棵树 $T$，不妨假设其节点编号为 $1 \sim n$。

我们首先令 $p_1=i$，假设 $i$ 的儿子节点**按照某个顺序排列**为 $x_1,x_2,x_3\dots x_k$。

那么我们划分 $p_{2 \sim siz_{x_1}+1}$ 这一段分配给 $x_1$ 子树内的点，$p_{siz_{x_1}+2 \sim siz_{x_1}+siz_{x_2}+1}$ 给 $x_2$ 这一棵子树，以此类推。

如果不这样划分那么肯定会出现 $a_i<a_j<b_i<b_j$。

继续观察这样划分会有什么性质，以 $x_1$ 所在段为例，假设 $x_1$ 的儿子按照**某个顺序排列**为 $y_1,y_2,y_3\dots y_t$，那么分配方案和上面的方法是类似的，唯一需要的考虑的是 $x_1$ 放在哪里，而且 $x$ 显然不能放在某个 $y_j$ 分配的区间内，不然 $(1,x_1)$ 和 $y_j$ 分配的段之间的边肯定会相交。

所以我们可以选择一个 $l$，使得分配了 $y_1,y_2\dots y_l$ 之后将 $x_1$ 放在此处再继续分配 $y_{l+1},y_{l+2}\dots y_t$。

上述的方法肯定能够合法排布。

也就是说我们可以令 $i=1$ 此时肯定也有解，分析一下不难得到我们直接**按照子树编号最小值排布儿子肯定是最优的**。

这样我们就可以构造出一棵树的解。

### 图

现在有了环该怎么办呢？

如果有一个环 $r_1,r_2,r_3\dots r_k$，其中 $(r_i,r_{i\bmod k+1})$ 存在。

我们令这一个环上在排列 $p$ 中位置最靠前的为 $r_1$，那么接下来容易知道 $r_2,r_3\dots r_k$ 的相对大小关系只有两种可能 $pos_{r_2}<pos_{r_3}<pos_{r_4}<\dots < pos_{r_k}$ 或者 $pos_{r_2}>pos_{r_3}>pos_{r_4}>\dots >pos_{r_k}$。

所以我们将所有极大的简单环缩在一起，也就是跑点双连通分量。

然后考虑建圆方树，有了树的结构之后我们考虑修改一下树的做法。

首先对于每一个圆点而言，其所有儿子都是代表一个点双，这些点双的顺序和树的分析一样，可以任意排列，那么我们肯定取这一个点双中 **能取到的最小的** 第一个值来排序。

但是对于一个方点而言，儿子的顺序并不能随意排列，因为上面我们说了对于一个环其顺序只有两种可能，又因为这题保证有解，所以一个点双中不可能有两个不同的简单环。

--------

#### **证明如下**

"$\otimes$" 指将环上的点排布成一个圆，将所有边画在圆内，其内部存在两条边视觉上如此排布。

如果环中没有 "$\otimes$" 的结构，那么我们直接通过缩二度点就可以知道简单环是唯一的。

如果有 "$\otimes$" 这样的边出现，此时无论怎么排布环上的点边都肯定出现 $a_i<a_j<b_i<b_j$。

---

通过缩二度点得到了每一个点双的简单环之后和树的做法就没有太大差别了。

连通块的整合也是容易的，一个连通块可以整体一起插入到某一个位置，处理出每一个连通块的答案之后贪心即可。

```cpp
//Mashiro
#include<bits/stdc++.h>

#define vc vector
#define db double
#define fi first
#define se second
#define ll long long
#define mk make_pair
#define pb push_back
#define RI register int
#define PI pair<int,int>
#define ull unsigned long long
#define err cerr << "   -_-   " << endl
#define debug cerr << " ------------------- " << endl

#define input(x) freopen(#x".in","r",stdin)
#define output(x) freopen(#x".out","w",stdout)

#define NO puts("No")
#define YES puts("Yes")

//#define OccDreamer
//#define int long long

using namespace std;

namespace IO{
	inline ll read(){
		ll X=0, W=0; char ch=getchar();
		while(!isdigit(ch)) W|=ch=='-', ch=getchar();
		while(isdigit(ch)) X=(X<<1)+(X<<3)+(ch^48), ch=getchar();
		return W?-X:X;
	}
	inline void write(ll x){
		if(x<0) x=-x, putchar('-');
		if(x>9) write(x/10);
		putchar(x%10+'0');
	}
	inline void sprint(ll x){write(x), putchar(32);}
	inline void eprint(ll x){write(x), putchar(10);}
}using namespace IO;

const int MAXN = 2e5 + 2;

int n, m;
int stk[MAXN], fa[MAXN], topf;
int low[MAXN], dfn[MAXN], tim[MAXN], tot;
int head[MAXN], ne[MAXN<<1], to[MAXN<<1], mn[MAXN], node, cnt;

vc<PI> ed[MAXN];
vc<int> ans, G[MAXN], res[MAXN];

priority_queue<int> Q;

bool vis[MAXN];

inline bool comp(int x, int y){return mn[x]<mn[y];}

inline void add(int x, int y){++cnt;to[cnt]=y;ne[cnt]=head[x];head[x]=cnt;}

inline void tarjan(int x, int f){
    dfn[x]=low[x]=++tot; stk[++topf]=x;
    for(int i=head[x];i;i=ne[i]){
        if(dfn[to[i]]){
            if(to[i]^f) low[x]=min(low[x],dfn[to[i]]);
        }
        else{
            tarjan(to[i],x), low[x]=min(low[x],low[to[i]]);
            if(low[to[i]]>=dfn[x]){
                ++node; G[node].clear(); ed[node].clear();
                G[x].pb(node); fa[node]=x; stk[topf+1]=0;
                while(stk[topf+1]!=to[i]){
                    int t=stk[topf];
                    G[node].pb(t); fa[t]=node;
                    --topf;
                }
            }
        }
    }
    return ;
}

inline void build(int x, int id, int f){
    if(x^f) G[id].pb(x); vis[x]=1;
    for(int i=head[x];i;i=ne[i]){
        if(vis[to[i]]) continue;
        build(to[i],id,f);
    }
    return ;
}

set<int> e[MAXN];
set<PI> E, ban;

queue<int> q;

int deg[MAXN];

inline void Run(int lim){
    E.clear(); ban.clear();
    while(q.size()){
        int t=q.front(); q.pop();
        if(e[t].size()==1 && E.size()<lim){
            int x=*e[t].begin();
            E.insert(mk(min(t,x),max(t,x)));
        }
        if(e[t].size()==2){
            int x=*e[t].begin(), y=*e[t].rbegin();
            e[x].insert(y);
            e[y].insert(x);
            ban.insert(mk(min(x,y),max(x,y)));
        }
        for(auto i:e[t]){
            e[i].erase(e[i].lower_bound(t));
            if(ban.find(mk(min(t,i),max(t,i)))==ban.end()){
                E.insert(mk(min(t,i),max(t,i)));
            }
            if(e[i].size()==2) q.push(i);
        }
        e[t].clear();
    }
    for(auto i:E) add(i.fi,i.se), add(i.se,i.fi);
    return ;
}

inline void rebuild(int x){
    int cntt=0;
    for(auto i:G[x]) ++cntt, vis[i]=0, head[i]=deg[i]=0; vis[fa[x]]=0; head[fa[x]]=deg[fa[x]]=0;
    for(auto i:ed[x]) e[i.fi].insert(i.se), e[i.se].insert(i.fi), deg[i.fi]++, deg[i.se]++;
    for(auto i:G[x]) if(deg[i]<=2) q.push(i);
    if(deg[fa[x]]<=2) q.push(fa[x]);
    G[x].clear(); Run(cntt);
    return build(fa[x],x,fa[x]);
}

inline void DFS(int x, int f){
    int minn=(x<=n?x:0);
    for(auto i:G[x])
        DFS(i,x), minn=min(minn,mn[i]);
    if(x<=n){
        G[x].pb(x); mn[x]=x;
        sort(G[x].begin(),G[x].end(),comp);
        mn[x]=minn;
    }
    else{
        rebuild(x);
        if(mn[G[x][0]]>mn[G[x].back()]) reverse(G[x].begin(),G[x].end());
        mn[x]=mn[G[x][0]];
    }
    return ;
}

inline void getres(int x, int id){
    vis[x]=1;
    for(auto i:G[x]){
        if(i==x) res[id].pb(x);
        else getres(i,id);
    }
    return ;
}

inline void solve(int x){
    DFS(x,0);
    getres(x,x);
    return ;
}

inline void work(int x){
    for(auto i:res[x]){
        int lmt=Q.empty()?n+1:-Q.top();
        while(lmt<i){
            Q.pop();
            work(lmt);
            lmt=Q.empty()?n+1:-Q.top();
        }
        sprint(i);
    }
    return ;
}

inline void solve(){
    node=n=read(), m=read(); cnt=tot=topf=0;
    for(int i=1;i<=n;++i) G[i].clear(), head[i]=dfn[i]=0;
    for(int i=1;i<=m;++i){
        int x, y;
        x=read(), y=read();
        add(x,y), add(y,x);
    }
    for(int i=1;i<=n;++i)
        if(!dfn[i]) tarjan(i,fa[i]=0); 
    for(int i=1;i<=n;++i){
        for(int j=head[i];j;j=ne[j]){
            if(to[j]<i){
                int x=to[j], y=i;
                if(fa[x]==fa[y]) ed[fa[x]].pb(mk(x,y));
                else{
                    if(fa[fa[x]]==y) ed[fa[x]].pb(mk(x,y));
                    else ed[fa[y]].pb(mk(x,y));
                }
            }
        }
    }
    cnt=0;
    for(int i=1;i<=n;++i) vis[i]=0, head[i]=0;
    for(int i=1;i<=n;++i){
        if(vis[i]) continue;
        // cerr << "DFS:" << i << endl;
        res[i].clear(); Q.push(-i);
        solve(i);
    }
    while(!Q.empty()){
        int t=Q.top(); Q.pop();
        work(-t); 
    }
    // int cur=3, las=-1;
    // while(cur) {
    //     // cerr << cur << endl;
    //     las=cur; cur=fa[cur];
    //     if(cur==0) break;
    //     if(G[cur][0]==las || G[cur].back()==las) cerr << "GOOD" << endl;
    //     else cerr << "BAD" << endl;
    // }
    putchar(10);
}

int main(){
    freopen("graperm.in","r",stdin);
    freopen("graperm.out","w",stdout);
    int c, t;
    c=read(), t=read();
    while(t--) solve();
    return 0;
}
/*
0 1
10 11
3 6
4 9
1 7
9 6
6 7
1 9
2 3
7 8
2 8
2 6
7 10
*/
```

---

## 作者：P_Bisector (赞：9)

## 废话

大佬都太巨了！怎么都会广义串并联图！我在冬令营的时候听到双极定向就没往下继续听了，于是这里就有了一篇双极定向题解。食用价值疑似不大。

## Part 1 赛时想法（森林）

以下内容可以获得 44pts 的好成绩。加上暴力的 8pts 可以稳进非强省省队。

首先我们观察题意可得，我们相当于把这个图拍到一个数轴上成为 [P9901](luogu.com.cn/problem/P9901) 中所定义的“弯曲半平面直线同向图”的无向版本。而我们所需要求的则是点拍到数轴上以后最小的字典序。

考虑树的情况，首先无脑将最小的放在最前面，接下来可以发现标号最小的点的所有儿子的子树必将连续。那么我们在树上 DP 找到每个子树字典树最小时第一个数的最小值（定义为 $g_x$），接下来对子树按 $g_x$ 从小到大排序，依次选择这些子树向下 dfs 即可。如果某个节点上 $x<g_x$ ，那么就先 dfs $g_u<x$ 的 $u$ 再将 $x$ 计入答案。

树做出来之后，森林就是平凡的。每一个连通块在 dfs 结束后就可以看做一条长长的链，将链上的点依次计入答案。当链上某个点的标号小于其他链的第一个点的标号就将这个链插入它前面。

赛时代码（不带注释）：
```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n,m,c;
const int N=100050;
vector<int>rt,g[N],ans[N],Ans;
int vis[N],f[N],pos;
void dfs(int x){
    vis[x]=1;f[x]=x;
    for(int i=0;i<g[x].size();i++)
        if(vis[g[x][i]]==0)
            dfs(g[x][i]),f[x]=min(f[x],f[g[x][i]]);
}
void dfs2(int x,int q){
    vis[x]=1;
    int flag=0;
    for(int i=0;i<g[x].size();i++){
        int v=g[x][i];
        if(vis[v])continue;
        if(f[v]>x){
            if(flag==0){
                flag=1;
                ans[q].push_back(x);
            }
            dfs2(v,q);
        }else{
            dfs2(v,q);
        }
    }
    if(flag==0){
        flag=1;
        ans[q].push_back(x);
    }
}
void purslane(int x){
    for(int i=0;i<ans[x].size();i++){
        while(pos!=rt.size()&&ans[x][i]>rt[pos]){
            pos++;
            purslane(pos-1);
        }
        Ans.push_back(ans[x][i]);
    }
}
bool cmp(int a,int b){
    return f[a]<f[b];
}
void solve(){
    scanf("%d%d",&n,&m);
    rt.clear();pos=0;
    for(int i=1,u,v;i<=m;i++){
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }/*
    for(int i=1;i<=n;i++)
        sort(g[i].begin(),g[i].end());

    for(int i=1;i<=n;i++)vis[i]=0;
    while(pos<rt.size())pos++,Dfs(rt[pos-1]);
    printf("\n");
    for(int i=1;i<=n;i++)g[i].clear();*/
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            rt.push_back(i);
            dfs(i);
        }
    }
    for(int i=1;i<=n;i++){
        vis[i]=0;
    }
    for(int i=1;i<=n;i++)sort(g[i].begin(),g[i].end(),cmp);
    for(int i=0;i<rt.size();i++){
        dfs2(rt[i],i);
    }
    while(pos<rt.size())pos++,purslane(pos-1);//check
    for(int i=0;i<Ans.size();i++){
        printf("%d ",Ans[i]);
    }
    printf("\n");
    for(int i=1;i<=n;i++)g[i].clear();
    for(int i=0;i<rt.size();i++)ans[i].clear();
    Ans.clear();
    for(int i=1;i<=n;i++){
        vis[i]=0;
    }
}
int bfa[20],bfb[20],bfc[20];
struct seg{
    int l,r;
}s[30];
void bfcheck(){
    for(int i=1;i<=m;i++){
        for(int j=1;j<=m;j++){
            int Q=bfc[s[i].l],R=bfc[s[i].r];
            int S=bfc[s[j].l],T=bfc[s[j].r];
            if(Q>R)swap(Q,R);if(S>T)swap(S,T);
            if(Q<S&&S<R&&R<T||S<Q&&Q<T&&T<R){
                return;
            }
        }
    }
    for(int i=1;i<=n;i++)Ans.push_back(bfa[i]);
}
void bfdfs(int x){
    if(x==n+1){
        bfcheck();
    }
    if(x==1){
        bfb[1]=1;
        bfa[1]=1;
        bfdfs(x+1);
        return;
    }
    for(int i=1;i<=n;i++){
        if(Ans.size())return;
        if(bfb[i]==0){
            bfb[i]=1;
            bfa[x]=i;
            bfc[i]=x;
            bfdfs(x+1);
            bfb[i]=0;
        }
    }
}
void bf(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)scanf("%d%d",&s[i].l,&s[i].r);
    bfdfs(1);
    for(int i=0;i<Ans.size();i++){
        printf("%d ",Ans[i]);
    }
    printf("\n");
    Ans.clear();
}
int main(){
    freopen("graperm.in","r",stdin);
    freopen("graperm.out","w",stdout);
    int T;
    scanf("%d%d",&c,&T);
    while(T--){
        if(c>2)solve();
        else bf();
    }
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```
## Part 2 whk课上思路（仙人掌以及一些性质）

（课上摸鱼证据）

首先我们可以注意到，如果树变成了仙人掌，那么我们可以建一棵圆方树（具体实现时因为某些原因写的是广义圆方树），而这棵圆方树中方点的 $g_x$ 的计算方式就变成了两端的 $g$ 的最小值。这看似没什么用。但是我们如果仔细分析这张图的性质可以发现它的每一个点双都有且仅有一个哈密顿回路！于是问题转化成了如何找到这条哈密顿回路。

## Part 3 补题过程思路（正解）

为方便思考，把哈密顿回路称作环，摆在最外面，并将其他所有边放在里面。

注意到对于点双中的任何一条边，其要么将整个哈密顿回路切开成为左右两部分（易证这当中不存在边连接左右两部分），要么是环上的边（这种情况视作切割成环和空集两部分）。因此以这条边的两端为双极（$s$ 和 $t$）进行双极定向。令点 $u$ 经过定向后标号为 $f_u$，则需要求出所有 $f_v>f_u$ 的 $v$ 中 $f_v$ 的最小值（定为 $nxt_u$），以及$f_v<f_u$ 的 $v$ 中 $f_v$ 的最大值（定为 $pre_u$），通过 $nxt$ 一条龙从 $s$ 找到 $t$，再找到编号最大的未选中的点，通过 $pre$ 一条龙找到 $s$。这一系列下来恰好可以找到一个完整的环。

因此套用上文的内容可以通过本题。时间复杂度 $O(n \log n)$，瓶颈在于排序。

代码如下：
```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n,m,c,M;
const int N_=1000050;
vector<int>rt,g[N_],ans[N_],Ans;
int vis[N_],f[N_],pos;
int dfn[N_],low[N_],stk[N_],cnt,tp,N,q;
vector<int>t[N_],U[N_],V[N_];
bool cmp(int,int);
void tarjan(int x){
    dfn[x]=low[x]=++cnt;
    stk[++tp]=x;
    for(int i=0;i<g[x].size();i++){
        int v=g[x][i];
        if(!dfn[v]){
            tarjan(v);
            low[x]=min(low[x],low[v]);
            if(low[v]==dfn[x]){
                ++N;
                int u=0;
                while(u!=v){
                    u=stk[tp--];
                    t[u].push_back(N);
                    t[N].push_back(u);
                    M++;
                }
                t[x].push_back(N);
                t[N].push_back(x);
                M++;
            }
        }else low[x]=min(low[x],dfn[v]);
    }
}
int B[N_];
namespace BP{
	int dfn[N_],low[N_],cnt,fa[N_],rdf[N_],on[N_],vis[N_];
	void tar(int x,int pa){
	    dfn[x]=low[x]=++cnt;fa[x]=pa,rdf[cnt]=x;
	    for(int i=0;i<U[x].size();i++){
	        int v=U[x][i];if(v==pa)continue;
	        if(!dfn[v])tar(v,x),low[x]=min(low[x],low[v]);
	        else low[x]=min(low[x],dfn[v]);
	    }
	}
	vector<int>ans,p[N_];
	int CNT;//调试用的变量。别管它。
	void dfs(int x){
		CNT++;
		vis[x]++,ans.push_back(x),B[x]=ans.size();
		for(int i=0;i<p[x].size();i++)if(!vis[p[x][i]])dfs(p[x][i]);
	}
	void bipolar(int s,int t,vector<int>&V){
		//清空
		for(int i=0;i<V.size();i++)
			on[V[i]]=0,p[V[i]].clear(),vis[V[i]]=0,dfn[V[i]]=0;
		cnt=0,ans.clear();
		CNT=0;
		//建树
		tar(s,0);
		//确定路
		vector<int>path;
		for(int now=t;now;now=fa[now])on[now]=1,path.push_back(now);
		//剥叶子
		for(int i=cnt;i>0;i--){
			int u=rdf[i];
			if(!on[u])
				p[fa[u]].push_back(u),p[rdf[low[u]]].push_back(u);
		}
		//计算答案 
		int s1=0,s2=0;
		int tmp=ans.size();
		for(int i=0;i<V.size();i++)
			s1+=vis[V[i]];
		for(int i=path.size()-1;i>=0;i--){
			dfs(path[i]);
		}
		//清空列表 
		for(int i=0;i<V.size();i++)
			s2+=vis[V[i]];
		for(int i=0;i<V.size();i++)on[V[i]]=0,p[V[i]].clear();cnt=0;

	}
	
}
int nxt[N_],pre[N_];
void dfs(int x,int fa){
	vis[x]=1;
	if(x<=n){//round 
	    f[x]=x;
		//get f 
	    for(int i=0;i<t[x].size();i++){
	        int v=t[x][i];if(v!=fa)dfs(v,x),f[x]=min(f[x],f[v]);
		}
		//sort
		sort(t[x].begin(),t[x].end(),cmp);
	}else{//square 
		f[x]=n+1;
		//sort 
		
		vector<int>&R=t[x];
		int Q=R.size();
		//建图 
		for(int i=0;i<R.size();i++)
			B[R[i]]=1,nxt[R[i]]=0x3f3f3f3f,pre[R[i]]=0;
		for(int i=1;i<R.size();i++){if(R[i]==fa)swap(R[0],R[i]);} 
		for(int i=0;i<R.size();i++){
			int v=R[i];
			if(v!=fa){
				for(int i=0;i<g[v].size();i++){
					int vv=g[v][i];
					if(B[vv])U[v].push_back(vv);
					if(vv==fa)U[fa].push_back(v);
				} 
			}
		}
		//选一条边
		int S=fa,T=U[fa][0];
		//双极定向
		BP::bipolar(S,T,R);
		
		for(int i=0;i<BP::ans.size();i++){
			int u=BP::ans[i];
			for(int j=0;j<U[u].size();j++){
				int v=U[u][j];
				if(B[v]>B[u])nxt[u]=min(nxt[u],B[v]);
				else pre[u]=max(pre[u],B[v]);
			}
		}
		R.clear();
		for(int now=S;now!=T;now=BP::ans[nxt[now]-1])
			R.push_back(now),B[now]=0;
		R.push_back(T),B[T]=0;
		for(int i=BP::ans.size()-1;i>=0;i--){
			int u=BP::ans[i];
			if(B[u]){
				for(int now=u;now!=S;now=BP::ans[pre[now]-1])
					R.push_back(now);
				break;
			}
		} 
		//get f
		for(int i=0;i<R.size();i++){
			int v=R[i];
			U[v].clear(),B[v]=0,nxt[v]=0,pre[v]=0;
		}
		for(int i=0;i<t[x].size();i++){
			int v=t[x][i];if(v!=fa)dfs(v,x);
		}
		if(f[t[x][1]]>f[t[x][t[x].size()-1]]){
			reverse(t[x].begin()+1,t[x].end());
		}
		f[x]=f[t[x][1]];
		
	}
}
void dfs2(int x,int q,int fa){
    vis[x]=1;
    if(x<=n){//round 	
    	int flag=0;
	    for(int i=0;i<t[x].size();i++){
	        int v=t[x][i];
	        if(v==fa)continue;
	        if(f[v]>x){
	            if(flag==0){flag=1;ans[q].push_back(x);}
	        }
			dfs2(v,q,x);
	    }
	    if(flag==0){
	        flag=1;
	        ans[q].push_back(x);
	    }
	}else{//square
		for(int i=1;i<t[x].size();i++){
			dfs2(t[x][i],q,x);
		} 
	}
}
void purslane(int x){
    for(int i=0;i<ans[x].size();i++){
        while(pos!=rt.size()&&ans[x][i]>rt[pos]){
            pos++;
            purslane(pos-1);
        }
        Ans.push_back(ans[x][i]);
    }
}
bool cmp(int a,int b){
    return f[a]<f[b];
}
void solve(){
    scanf("%d%d",&n,&m);
    rt.clear();pos=0;
    N=n,M=m;
    for(int i=1,u,v;i<=m;i++){
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]){
            rt.push_back(i);
            tarjan(i),dfs(i,0);
        }
    }
    for(int i=1;i<=N;i++){
        vis[i]=0;
    for(int i=0;i<rt.size();i++){
        dfs2(rt[i],i,0);
    }
    while(pos<rt.size())pos++,purslane(pos-1);
    for(int i=0;i<Ans.size();i++){
        printf("%d ",Ans[i]);
    }
    printf("\n");
    for(int i=1;i<=N;i++)g[i].clear(),t[i].clear();
    for(int i=0;i<rt.size();i++)ans[i].clear();
    Ans.clear();
    for(int i=1;i<=N;i++){
        vis[i]=0,dfn[i]=0;
    }
}
int main(){
    freopen("graperm4.in","r",stdin);
    freopen("graperm4.out","w",stdout);
    int T; 
    scanf("%d%d",&c,&T);
    while(T--){
        solve();
    }
    return 0;
}
```

---

## 作者：s4CRIF1CbUbbL3AtIAly (赞：8)

乱口胡了一个做法。

## 树

对于我的思维过程，链和树几乎是完全一样的，因此不单独讲链的做法。

显然 $p_1=1$ 是最优的。于是考虑把整棵树以 $1$ 为根挂起来。接下来我们要把整棵树填进排列中。

假设当前在考虑 $x$ 的子树，$x$ 有若干个儿子 $s_1,s_2,\dots,s_k$。显然的，$x$ 的每个儿子的子树都应该是连续的一段，否则就会出现交叉的边。

考虑求出每个点子树内的最小值 $mn_x$，那么不难发现将 $x$ 和所有 $mn_{s_i}$ 放在一起从小到大排序然后按顺序依次填进排列是最优的。这里把 $s_i$ 填进排列是指递归下去考虑以 $s_i$ 为根的子树，把 $x$ 填进排列就是把 $x$ 这个数加到排列末尾。因为每个子树都可以把其最小值填到最前面，所以是对的。

于是先 dfs 一遍求出 $mn$ 然后再从根开始执行上面的递归求解过程即可。

## 森林

注意到如果我当前填完了一些连通块，那么我在当前填好的排列的任意两个相邻的数中间塞一个新的连通块进去都不影响答案是否合法。

于是用 set 维护当前还没有开始考虑的连通块都有哪些，每次在把一个数 $x$ 填进排列之前检查是否有比 $x$ 小的数还没开始考虑，对那个点所在连通块进行 dfs 然后将整棵连通块填完再填 $x$。因为每次选的都是最小的没被考虑的点，所以这个点作为它所在连通块的第一个数肯定是最优的。

实际上把树的代码稍微改一下即可。需要注意的时候在最外层和填某个数之前有可能有多个连通块都需要填进去，千万不要只填一个。

## 正解

首先和刚才一样的，多个连通块和一个连通块是等价的。

接着考虑刚才树的做法，把前面的考虑所有儿子考虑所有点双。不过这次一个点双内部不能随便重排，而是需要找出一条哈密尔顿回路然后按照这条回路的顺序遍历。

找边双的哈密尔顿回路的方法可以参考 CF1656I 的题解，不过这题保证有解，所以直接用广义串并联图的方法用链表维护哈密尔顿回路即可。

找出哈密尔顿回路之后看一下是正着走更优还是倒着走更优，然后和树的方法类似的排序然后填数即可。注意这个时候节点的 $mn$ 的计算方式也需要更改。

然后就做完了？

upd on 3.11：写完了，不难写，去掉注释之后只有不到 5K。

这里给出广义串并联图部分的写法：

```cpp
struct chn{int c0,c1;}cnd[N];// 这里我选择记录无向链表，具体的方向记录在底下的 map 中
map<int,pii>ecn[N];// ecn[x][y] 表示 x 到 y 的边上的链表的起点和终点
int deg[N];
int&em(int p){return cnd[p].c0==p?cnd[p].c0:cnd[p].c1;}// 找到空位
pii con(pii x,pii y){// 连接两个链表
	if(x.fi==0)return y;
	if(y.fi==0)return x;
	em(x.se)=y.fi;
	em(y.fi)=x.se;
	return{x.fi,y.se};
}
vector<int> fdhmlt(vector<int>ps,vector<pii>es){
	// cerr<<"find hamilton: ";
	// for(auto p:ps)cerr<<p<<" ";
	// for(auto[x,y]:es)cerr<<x<<","<<y<<" ";
	// cerr<<"\n";
	if(ps.size()==2)return ps;
	for(auto p:ps)cnd[p]={p,p},ecn[p].clear(),deg[p]=0;
	for(auto[x,y]:es)ecn[x][y]=ecn[y][x]={0,0},++deg[x],++deg[y];
	queue<int>q;
	for(auto p:ps)if(deg[p]<=2)q.push(p);
	while(!q.empty()){// 类似拓扑排序去做
		int now=q.front();q.pop();
		if(deg[now]==0)throw;
		if(deg[now]==1){// 说明最后变为两个点且两个点之间的边上只有一条边带了链，直接按照顺序全都加上
			auto X=*ecn[now].begin();
			vector<int>ans;
			ans.push_back(now);
			pii q=X.se;
			for(int p=q.fi,l=p;p!=q.se;swap(l,p),p=(cnd[l].c0==p?cnd[l].c1:cnd[l].c0))
				ans.push_back(p);
			ans.push_back(q.se);
			ans.push_back(X.fi);
			// cerr<<"Res: ";
			// for(auto i:ans)cerr<<i<<" ";
			// cerr<<"\n";
			return ans;
		}
		auto U=*ecn[now].begin(),V=*prev(ecn[now].end());
		int u=U.fi,v=V.fi;
		swap(U.se.fi,U.se.se);
		pii fn=con(con(U.se,{now,now}),V.se);// 把两边的链拼起来
		ecn[u].erase(now);ecn[v].erase(now);
		// cerr<<now<<" "<<u<<" "<<v<<" "<<fn.fi<<" "<<fn.se<<"\n";
		if(ecn[u].count(v)){// 顺便叠合重边
			pii qwq=ecn[u][v];
			if(!qwq.fi)ecn[u][v]=fn,ecn[v][u]={fn.se,fn.fi};// 如果另一条边上啥也没有就可以直接扔了
			else{// 如果已经凑齐一个环说明就是答案了
				vector<int>ans;
				ans.push_back(u);
				for(int p=fn.fi,l=p;p!=fn.se;swap(l,p),p=(cnd[l].c0==p?cnd[l].c1:cnd[l].c0))
					ans.push_back(p);
				ans.push_back(fn.se);
				ans.push_back(v);
				for(int p=qwq.se,l=p;p!=qwq.fi;swap(l,p),p=(cnd[l].c0==p?cnd[l].c1:cnd[l].c0))
					ans.push_back(p);
				ans.push_back(qwq.fi);
				// cerr<<"res: ";
				// for(auto i:ans)cerr<<i<<" ";
				// cerr<<"\n";
				return ans;
			}
			if(--deg[u]<=2)q.push(u);
			if(--deg[v]<=2)q.push(v);
		}else ecn[u][v]=fn,ecn[v][u]={fn.se,fn.fi};
	}
	throw;
}
```

---

## 作者：Z_301 (赞：7)

简单好写做法！

快进到给定点双怎么求哈密顿回路，其他部分可以看其他题解。

结论：

1. 一个点双有唯一的哈密顿回路。

2. 对于一条边，如果原图删掉这条边后点双连通性不变，就可以直接删掉，不影响哈密顿回路。

3. 建立 dfs 生成树。注意到只要保留 $low$ 边和树边，其他边去掉不影响点双连通性。$low$ 边指的是子树终点最浅的返祖边，如果有多个只要保留起点最深的。

4. 考虑一个点 $u$ ，如果子树内有两条边到祖先，就把 $u$ 到父亲的边删掉。剩下的边形成哈密顿回路。

一些对第 $4$ 条结论的说明：

1. 只要从原图删掉一条边后点双连通性不变，就能把这条边删掉，所以删完的图还是双连通的。

2. （只保留 $low$ 边后）如果有个点 $u$ 满足子树内有 $\ge 3$ 条边到祖先，就无解了。由此可得，每个点只有 $\le 2$ 个儿子。

3. $low$ 边总是不会被删。这是因为，假设删了 $(u,v)$ ，其中 $v$ 是 $u$ 的祖先，则 $u$ 到 $v$ 路径上肯定有至少一个点只被 $(u,v)$ 覆盖，这个点就会变成割点。

[代码](https://uoj.ac/submission/743633)，用了链表维护字典序。

---

## 作者：251Sec (赞：7)

先考虑树的情况，显然第一个点是 $1$，不妨把 $1$ 作为根，那么手玩不难发现，一个排列合法当且仅当任何子树都在排列里是连续的一段。这也就是说我们进行 DFS，维护每个点子树的最小字典序答案，每个点可以任意打乱儿子的顺序，然后把所有儿子的序列和自己依次拼接。DFS 贪心即可。

然后考虑森林，首先对每棵树用上面的方法求出最优解，按照开头排好序依次加入答案。那么我们就是维护一个答案序列，每次加入一个连通块，插入当前答案序列里的某个位置使得插入后字典序最小。这个也可以贪心维护。

现在考虑仙人掌。可以发现一个环合法的排列顺序就是所有它的（正着和反着的）循环移位。于是建出圆方树，仍然以 $1$ 为根 DFS，如果当前点是圆点，它就可以任意打乱它儿子的序列并把自己插入任意位置，如果当前点是方点，它就必须按（正或反的）顺序加入所有儿子。这都是可以贪心的。

最后考虑一般图。多个连通块的合并方法和上面是一样的，所以只需要考虑连通图。观察到 $K_4$ 的同胚子图无解，这让我们想搞一些广义串并联图操作。并且我们发现杏仁图也无解，换句话说所有点双都形如有哈密顿回路，剩下有些边挂在环上且互相不相交。只需要对每个点双求出一条哈密顿回路就变成了仙人掌上的问题。求解哈密顿回路可以使用广义串并联图方法。于是就做完了，总复杂度 $O((n+m) \log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T, n, m;
namespace Tree {
	vector<int> e[200005];
	void InsD(int u, int v) {
		e[u].push_back(v), e[v].push_back(u);
	}
	bool vis[200005];
	list<int> f[200005];
	vector<vector<int>> ans;
	void DFS(int u, int fa) {
		vis[u] = true;
		for (int v : e[u]) {
			if (v == fa) continue;
			DFS(v, u);
		}
		if (u > n) {
			rotate(e[u].begin(), find(e[u].begin(), e[u].end(), fa), e[u].end());
			if (f[e[u][1]].front() < f[e[u].back()].front()) {
				list<int> x;
				for (int i = 1; i < e[u].size(); i++) {
					int v = e[u][i];
					f[u].splice(f[u].end(), f[v]);
				}
			}
			else {
				for (int i = e[u].size() - 1; i >= 1; i--) {
					int v = e[u][i];
					f[u].splice(f[u].end(), f[v]);
				}
			}
		}
		else {
			vector<int> b;
			for (int v : e[u]) if (v != fa) b.push_back(v);
			b.push_back(u);
			sort(b.begin(), b.end(), [u](int x, int y) {
				int wx = (x == u ? u : *f[x].begin());
				int wy = (y == u ? u : *f[y].begin());
				return wx < wy;
			});
			for (int v : b) {
				if (v == u) f[u].push_back(u);
				else f[u].splice(f[u].end(), f[v]);
			}
		}
	}
	set<int> lef;
	void Clear() {
		for (int i = 1; i <= n * 2; i++) vis[i] = false, f[i].clear(), e[i].clear();
		ans.clear();
	}
	void Print(int u) {
		lef.erase(u);
		for (int i = 0; i < ans[u].size(); i++) {
			while (lef.size() && ans[*lef.begin()][0] < ans[u][i]) Print(*lef.begin());
			printf("%d ", ans[u][i]);
		}
	}
	void Solve() {
		for (int i = 1; i <= n; i++) {
			if (!vis[i]) {
				DFS(i, 0);
				ans.emplace_back();
				for (int x : f[i]) ans.back().push_back(x);
			}
		}
		for (int i = 0; i < ans.size(); i++) lef.insert(i);
		while (lef.size()) Print(*lef.begin());
		putchar('\n');
		Clear();
	}
}
namespace Tarjan {
	struct Edge {
		int v, nxt;
	} e[400005];
	int len = 1, head[100005];
	void Ins(int u, int v) {
		e[++len] = { v, head[u] };
		head[u] = len;
	}
	void InsD(int u, int v) {
		Ins(u, v), Ins(v, u);
	}
	int dfn[100005], low[100005], cti, bel[200005], st[200005], top, cnt;
	bool vis[200005];
	void Tarjan(int u) {
		dfn[u] = low[u] = ++cti;
		for (int i = head[u]; i; i = e[i].nxt) {
			if (!vis[i >> 1] && !bel[i >> 1]) {
				vis[i >> 1] = true;
				st[++top] = i;
			}
			int v = e[i].v;
			if (!dfn[v]) {
				Tarjan(v);
				low[u] = min(low[u], low[v]);
				if (low[v] == dfn[u]) {
					cnt++;
					bool vx = false;
					while (vis[i >> 1]) {
						int x = st[top--];
						Tree::InsD(cnt, e[x].v);
						vx |= (e[x].v == u);
						vis[x >> 1] = false;
						bel[x >> 1] = cnt;
					}
					if (!vx) Tree::InsD(cnt, u);
				}
			}
			else low[u] = min(low[u], dfn[v]);
		}
	}
	void Clear() {
		for (int i = 1; i <= n; i++) {
			head[i] = dfn[i] = low[i] = 0;
		}
		for (int i = 1; i <= m; i++) {
			vis[i] = bel[i] = st[i] = 0;
		}
		len = 1, cti = top = 0;
	}
	void Solve() {
		cnt = n;
		for (int i = 1; i <= n; i++) {
			if (!dfn[i]) Tarjan(i);
		}
	}
}
namespace SPG {
	struct Edge {
		int v, w, id;
	};
	map<int, Edge> e[100005];
	int deg[100005], eu[200005], ev[200005];
	bool del[200005];
	void Ins(int u, int v, int w, int id) {
		if (e[u].count(v)) {
			if (w > e[u][v].w) {
				if (deg[u] > 1 && deg[v] > 1) del[e[u][v].id] = true;
				e[u][v] = { v, w, id };
			}
			else if (deg[u] > 1 && deg[v] > 1) del[id] = true;
		}
		else {
			e[u][v] = { v, w, id };
			deg[v]++;
		}
	}
	void Del(int u, int v) { e[u].erase(v), deg[u]--; }
	vector<int> eb[200005], pb[200005];
	void Solve() {
		for (int i = 1; i <= m; i++) {
			Tarjan::InsD(eu[i], ev[i]);
		}
		Tarjan::Solve();
		for (int i = 1; i <= m; i++) {
			eb[Tarjan::bel[i]].push_back(i);
			pb[Tarjan::bel[i]].push_back(eu[i]);
			pb[Tarjan::bel[i]].push_back(ev[i]);
		}
		for (int _ = n + 1; _ <= Tarjan::cnt; _++) {
			for (int i : eb[_]) Ins(eu[i], ev[i], 1, i), Ins(ev[i], eu[i], 1, i);
			sort(pb[_].begin(), pb[_].end());
			pb[_].erase(unique(pb[_].begin(), pb[_].end()), pb[_].end());
			queue<int> q;
			for (int i : pb[_]) if (deg[i] <= 2) q.push(i);
			while (!q.empty()) {
				int u = q.front(); q.pop();
				if (!deg[u]) continue;
				if (deg[u] == 2) {
					Edge a = e[u].begin()->second, b = next(e[u].begin())->second;
					int x = a.v, y = b.v, w = a.w + b.w;
					Del(u, x), Del(u, y), Del(x, u), Del(y, u);
					Ins(x, y, w, 0), Ins(y, x, w, 0);
					if (deg[x] <= 2) q.push(x);
					if (deg[y] <= 2) q.push(y);
				}
				else {
					Edge a = e[u].begin()->second;
					int x = a.v;
					Del(u, x), Del(x, u);
					if (deg[x] <= 2) q.push(x);
				}
			}
			for (int i : pb[_]) deg[i] = 0, e[i].clear();
		}
		Tarjan::Clear();
		Tree::Clear();
		for (int i = 1; i <= m; i++) {
			if (!del[i]) {
				Tarjan::InsD(eu[i], ev[i]);
			}
		}
		Tarjan::Solve();
		Tree::Solve();
		for (int i = n; i <= n * 2; i++) pb[i].clear(), eb[i].clear();
		for (int i = 1; i <= m; i++) del[i] = false;
		Tarjan::Clear();
		Tree::Clear();
	}
}
int main() {
	scanf("%*d%d", &T);
	while (T--) {
		scanf("%d%d", &n, &m);
		for (int i = 1; i <= m; i++) scanf("%d%d", &SPG::eu[i], &SPG::ev[i]);
		SPG::Solve();
	}
	return 0;
}
```

---

## 作者：SunsetGlow95 (赞：6)

# 题解 - 省选联考 2025 图排列

## 前言

喜欢这个题，推理链长而完整，考察代码实现但不严重，没什么很一拍脑袋的步骤，场上差最后一步而只有 52 分是一款我的问题。

## 简述题意

给一简单无向图，求字典序最小的排列 $p$，满足将每条边 $(u_i,v_i)$ 视作区间 $[\min(p_{u_i},p_{v_i}), \max(p_{u_i},p_{v_i}))$ 后，区间要么相离，要么一者包含另一者。点数 $n\le 10^5$，边数 $m\le 2n$，保证有解。

## 性质 AC：图为一棵树

手玩，每个点一定是形如：有些子树在它左边、有些子树在它右边，子树之间两两不交，而这个结构可以向子树递归。那只关心每个子树答案的首位，在该点处排序即可。考虑到随便选根，根可能被某条边代表的区间包含，所以以编号最小的点作为根，它必然在答案的首位。

## 性质 C：多个联通块的合并

手玩，不同联通块之间要么相互包含，要么相离。根据字典序最小的贪心想法，考虑对每个联通块求出答案，按首位排序，依次输出。如果发现下一个联通块的首位要小于即将要输出的数，就跳到下一个联通块。

## 环的情况

手玩，发现环上的点出现的顺序必然是：环的某个顺序的某个循环表示。建立圆方树，圆点遵循上面的规则，方点就是把儿子按环上的顺序依次排序，选取正序和逆序中更优者。

## 点双的性质

1. 此点双不含同胚于 $K_4$ 的子图。$K_4$ 表示大小为 $4$ 的完全图。也就是说此点双是广义串并联图。手玩可证。
2. 此点双不含同胚于以下结构的子图：

![sol-LGP11832-1.png](https://s2.loli.net/2025/03/04/Lier5C6bPfwdla7.png)

考虑三个环 `1 2 5 3`、`1 2 5 4`、`1 3 5 4` 都要符合上述对于环的分析，手玩发现不可能。这里同时证明了点双哈密顿环的存在性。

总结一下：这个点双形如一个圆，上面有一些不相交的弦。这里哈密顿环的唯一性也显然（删去任意一条环边原图将不再是点双，非环边则反之，暴力方法可以获得 72 分）。把哈密顿环找到，按环的方法做即可。

## 广义串并联图方法

由广义串并联图的套路，以及这是针对点双，考虑在点双上面不断地缩二度点和叠合重边来找到哈密顿环。

简单地说，你发现缩二度点的过程拉成重构树，环上的点就已经排好序。所以一开始认为所有的边都有效，叠合重边的时候把长度为 1 的边删去即可。

总复杂度 $O(n\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MXN = 100005;
const int MXV = MXN * 2;
int T, N, M, V;
int dfn[MXN], low[MXN], did;
int cid, stk[MXN], top;
int que[MXN], qh, qt;
bool instk[MXN];
vector<int> to[MXN], comps[MXN], nto[MXV];
vector<pair<int, int>> segs[MXV];
set<int> rese[MXN], vire[MXN];

inline int read() {
  int x(0), c(getchar());
  while (c < '0' || c > '9') c = getchar();
  while (c >= '0' && c <= '9') x = x * 10 + (c - '0'), c = getchar();
  return x;
}
inline void write(int x) {
  assert(x);
  static char buf[11];
  int d(0);
  while (x) buf[d++] = x % 10 + '0', x /= 10;
  while (d) putchar(buf[--d]);
}

void build_scc(int p, int q, int s) {
  nto[p].push_back(s);
  int otop(top);
  stk[++otop] = p;
  while (true) {
    int c(stk[top--]);
    instk[c] = false;
    for (int i : to[c]) {
      if (instk[i] && dfn[i] >= dfn[p]) {
        rese[c].insert(i), rese[i].insert(c);
        vire[c].insert(i), vire[i].insert(c);
      }
    }
    if (c == q) break;
  }
  qh = qt = 0;
  for (int i(top + 1); i <= otop; ++i) {
    int c(stk[i]);
    if (rese[c].size() == 2) que[qt++] = c;
  }
  while (qh != qt) {
    int c(que[qh++]);
    if (rese[c].size() != 2) break;
    int x(*rese[c].begin());
    int y(*next(rese[c].begin()));
    rese[x].erase(c), rese[y].erase(c);
    if (rese[x].find(y) != rese[x].end()) {
      vire[x].erase(y), vire[y].erase(x);
      if (rese[x].size() == 2) que[qt++] = x;
      if (rese[y].size() == 2) que[qt++] = y;
    } else {
      rese[x].insert(y), rese[y].insert(x);
    }
  }
  int x(que[qh - 1]), y(que[qh]);
  if (vire[x].size() == 1) vire[x].insert(y), vire[y].insert(x);
  for (int c(*vire[p].begin()), l(p);;) {
    nto[s].push_back(c);
    int n(*vire[c].begin() + *next(vire[c].begin()) - l);
    if (n == p) break;
    l = c, c = n;
  }
  for (int i(top + 1); i <= otop; ++i) {
    int c(stk[i]);
    rese[c].clear(), vire[c].clear();
  }
}
void build(int p, int f) {
  low[p] = dfn[p] = did++;
  instk[p] = true, stk[++top] = p;
  for (int q : to[p]) {
    if (q == f) continue;
    if (dfn[q] == -1) {
      build(q, p);
      low[p] = min(low[p], low[q]);
      if (low[q] == dfn[q]) {
        nto[p].push_back(q);
        instk[q] = false;
        --top;
      } else if (low[q] == dfn[p]) {
        build_scc(p, q, V++);
      }
    } else {
      low[p] = min(low[p], dfn[q]);
    }
  }
}

void calc(int p) {
  segs[p].clear();
  if (p < N) segs[p].emplace_back(p, p);
  for (int q : nto[p]) {
    calc(q);
    segs[p].emplace_back(segs[q][0].first, q);
  }
  if (p < N)
    sort(segs[p].begin(), segs[p].end());
  else if (segs[p].back().first < segs[p][0].first)
    reverse(segs[p].begin(), segs[p].end());
}
void generate(int p, int ci) {
  for (auto [fir, q] : segs[p]) {
    if (q == p) comps[ci].push_back(p);
    else generate(q, ci);
  }
}
void output(int layer) {
  for (int i : comps[layer]) {
    while (top != cid && comps[top][0] < i) output(top++);
    write(i + 1), putchar(' ');
  }
}

int main() {
  for (read(), T = read(); T--;) {
    N = read(), M = read();
    for (int i(0); i != N; ++i) to[i].clear();
    for (int x(0), y(0); M--;) {
      x = read() - 1, y = read() - 1;
      to[x].push_back(y), to[y].push_back(x);
    }
    did = 0;
    fill(dfn, dfn + N, -1);
    for (int i(0); i != N + N; ++i) {
      segs[i].clear();
      nto[i].clear();
    }
    V = N;
    cid = 0;
    for (int i(0); i != N; ++i) {
      if (~dfn[i]) continue;
      top = -1, build(i, -1);
      calc(i);
      comps[cid].clear(), generate(i, cid++);
    }
    top = 0;
    while (top != cid) output(top++);
    putchar('\n');
    cout << flush;
  }
  return 0;
}
```

---

## 作者：hhoppitree (赞：3)

提供另一个视角，维护一个栈 $S$，维护目前所有确定在答案中，且存在相邻点尚未确定的点，每次确定答案位置下一位的时候（假设填 $x$）时 $x$ 与 $S$ 有连边的点必然构成了 $S$ 的一个栈顶前缀，然后把一些度数变成 $0$ 的点扔掉，最后把 $x$ push 进去（如果度数不为 $0$ 的话）。

树是简单的，你任意顺序重排儿子后把自己随便插进去就好。

接下来不妨假设图连通（否则可以简单合并），把圆方树建出来，类比树的情况，先考虑仙人掌，圆点随便重排完把自己插进去，方点就正着或者倒着遍历一下子节点就好了，将一般图归约到仙人掌是经典问题，$\mathcal{O}(n\log n)$。

---

## 作者：nullqtr_pwp (赞：2)

场上读错题爆零退役了。

考虑将所有边放到圆上，视为圆上的弦，这样要求弦之间没有交点。对于图是一个树的情况，由链的情况可以得知每个子树都是一个连续的区间，对于一个树不难发现 $p_1=1$ 是可以实现，那么以它作为根，我们尝试将子树的最优解合并，每一个子树都是完整一个标号区间，我们考虑按照子树最小值进行排序，中间适时插入 $p_u$。这样容易求出一个树的相对顺序。对于森林，多个连通块归并是容易的，你发现一个树只会是中间一个空档完整的塞入另一个树，维护一个栈实现贪心即可。

进一步观察有解图的性质，一个环我们发现标号只能顺时针或逆时针，那么对于一个点双，不难猜测存在一个极大环包含了所有点，且里面的所有边是不交弦。证明其实是简单的，反证一下如果极大环之外的点在同一个点双那么一定连边有交集。然后这个玩意充分必要于 $K_4$ 子图无解，也就是说原图必须是广义串并联图。我们容易通过缩二度点以及叠合重边的操作来得到一个点双上的极大环，进而在圆方树上考虑原问题即可。进而做类似于 $G$ 为森林的事情，时间复杂度 $\mathcal O(n\log n)$。这个过程其实很像缩三角剖分图，链表维护前驱后继即可。

[提交记录](https://loj.ac/s/2279260)

---

## 作者：LastKismet (赞：1)

# Sol
## 题意翻译
给出一个图，要求你将图上所有点排成一个排列，使得所有边不相交。最小化这个序列的字典序。大致就是这个意思。
## 树部分
考虑顺序构造答案序列，每次尽量加入更小的值。

考虑一棵树，不难发现，其各个子节点为根的子树，必然各是答案序列中一个连续段，否则必然有边相交，这很显然。

考虑根节点，如果我们每次以编号最小的为根，那么根节点必然位于整个序列最前面。

再考虑一棵子树，这棵子树的根节点必然与其父节点有一条连边，那么这个根节点就不能放在以其任何子节点为根的子树内部，否则根与父亲的连边必然与那个子树内的边相交。

各子节点为根子树之间是任意排列的，我们考虑预处理出每棵子树可以放在最前面的最小值，对每个节点，将其所有子节点为根子树按这个预处理出的最小值排好序即可。考虑这个节点本身放在哪里，可以直接用其自身的值和所有子节点一起排序，轮到自己的时候把自己入队即可。
## 图部分
图相对于树而言其实就是多了环的存在。

考虑一个环所具有的性质，放到答案序列上，如果只考虑这个环上的点，那么就是相邻两个点依次相连，最后首尾相连，从而使得边无交。

如果我们以环中一个节点为“根节点”，那么剩下的点在序列上的位置顺序必然按环上顺时针或逆时针依次排布，而根节点可以位于环上所有点之前或之后，从而满足上述性质。

也就是说，每个环上各点之间存在特殊位置关系限制。但是一个图内的环这么复杂，这个限制难以实现。

这道题的图具有一个性质，一个点双内只存在一个极大简单环即哈密顿回路。考虑反证一下，倘若存在多个极大简单环，那么必然存在环内两条边相交的情况，形似 $\oplus$ 状（借鉴[这篇文章](https://www.luogu.com.cn/article/77l4znd5)的形象比喻），那么必然无解，而题目保证有解。所以每个点双都是广义串并联图。

而倘若极大简单环符合条件，可能存在的小环显然也会符合条件。

因此，其实就是每个点双内的各点之间存在特殊位置关系限制。

如何快速处理点双的限制呢？考虑圆方树，将所有点双压成方点，那么一个方点的父节点与其所有子节点就对应了这个环上的所有点。

在这部分开始就给出的环的合法构造方法，其实是为了适配这一部分，我们将方点的父节点视作环的“根节点”，这样在边上的话，它向外的连边就不会与跨越整个环的那一条连边相交了。那么这个限制就变成，其所有子节点在序列上必须按环上顺时针或逆时针顺序排布。我们对比找出两种情况下能放在最前面的最小值，选更优的一种即可。

对于圆点，不难发现与之相连的各个点双同样满足答案序列上连续、互不相交、任意排列的性质，使用与树一样的方法处理即可。

考虑如何找点双内的极大简单环，经过上述推导我们已经得出一个点双必然是一个广义串并联图，我们使用广义串并联图方法，通过链表维护倒序加点即可。

## 多连通块
各个连通块之间相互独立，要保证没有边相交，那么两两之间，在答案序列上的对应位置要么完全无交，要么一个被另一个完全包括，不能有类似于飞地的情况。这是很显然的。

每次加入前判断一下有没有别的连通块可行最前最小值比即将加入的值更优，有的话处理完那个连通块再接着处理当前块即可。
# Code
```cpp
const int N=2e5+5;

int n,m;
vec<int> g[N],G[N];

int nn,dcnt;
int dfn[N],low[N];
stack<int> stk;
void tarjan(int x){
	dfn[x]=low[x]=++dcnt;stk.push(x);
	for(auto y:g[x]){
		if(!dfn[y]){
			tarjan(y);
			chmin(low[x],low[y]);
			if(low[y]>=dfn[x]){
				++nn;
				while(1){
					int t=stk.top();stk.pop();
					G[nn].pub(t);G[t].pub(nn);
					if(t==y)break;
				}
				G[nn].pub(x);G[x].pub(nn);
			}
		}else chmin(low[x],dfn[y]);
	}
}

vec<int> rts;
vec<int> rnk[N];
int val[N];

set<int> st;
set<int> gg[N];
int d[N];
vec<int> e;
set<int> q;
bool del[N];
int ne[N];
inline void work(int x,int f){
	st.clear();
	for(auto i:G[x])st.insert(i),gg[i].clear(),d[i]=0,del[i]=0;
	for(auto i:G[x])for(auto j:g[i])if(st.count(j))gg[i].insert(j),++d[i];
	e.clear();q.clear();
	for(auto i:G[x])if(d[i]==2)q.insert(i);
	while(q.size()){
		int x=*q.begin();q.erase(q.begin());
		int a=*gg[x].begin(),b=*++gg[x].begin();
		if(gg[a].count(b)){
			if(d[a]==2)q.erase(a);
			if(d[b]==2)q.erase(b);
			if(--d[a]==2)q.insert(a);
			if(--d[b]==2)q.insert(b);
		}else gg[a].insert(b),gg[b].insert(a);
		gg[a].erase(x),gg[b].erase(x);
		e.pub(x);del[x]=1;
	}
	vec<int> res;
	for(auto i:G[x])if(!del[i])res.pub(i);
	ne[res[0]]=res[1],ne[res[1]]=res[0];
	reverse(e.begin(),e.end());
	for(auto x:e){
		int a=*gg[x].begin(),b=*++gg[x].begin();
		if(ne[a]==b)ne[x]=b,ne[a]=x;
		else ne[x]=a,ne[b]=x;
	}
	res.clear();res.pub(ne[f]);
	for(int i=ne[ne[f]];i!=f;i=ne[i])res.pub(i);
	rnk[x]=res;
}

void init(int x,int f){
	for(auto y:G[x])if(y!=f)init(y,x);
	if(x<=n){
		val[x]=x;rnk[x].pub(x);
		for(auto y:G[x])if(y!=f)rnk[x].pub(y);
		sort(rnk[x].begin(),rnk[x].end(),[&](int a,int b){return val[a]<val[b];});
		val[x]=val[rnk[x].front()];
	}else{
		work(x,f);
		if(val[rnk[x].front()]>val[rnk[x].back()])reverse(rnk[x].begin(),rnk[x].end());
		val[x]=val[rnk[x].front()];
	}
}

set<pii> can;
vec<int> ans;
void solve(int x){
	for(auto i:rnk[x]){
		while(can.size()&&can.begin()->fir<(i==x?x:val[i])){
			int x=can.begin()->sec;can.erase(can.begin());
			solve(x);
		}
		if(i==x)ans.pub(x);
		else solve(i);
	}
}

inline void Main(){
	read(n,m);
	rep(i,1,n<<1)g[i].clear(),G[i].clear();
	rep(i,1,m){
		int u,v;read(u,v);
		g[u].pub(v);g[v].pub(u);
	}
	nn=n,dcnt=0;
	rep(i,1,n)dfn[i]=0,val[i]=inf;
	rts.clear();
	rep(i,1,n)if(!dfn[i]){
		while(stk.size())stk.pop();
		tarjan(i);
		rts.pub(i);
	}
	can.clear();ans.clear();
	rep(i,1,nn)rnk[i].clear();
	for(auto i:rts)init(i,0),can.insert({val[i],i});
	while(can.size()){
		int x=can.begin()->sec;can.erase(can.begin());
		solve(x);
	}
	for(auto i:ans)put(i,' ');puts("");
}
```

---

## 作者：qiuzx (赞：1)

题意本质上就是要求将 $n$ 个点排成一行，使得边之间不存在严格相交的关系。不妨假设图连通，如果不连通，则只需对每个连通块求出最优解，然后可以将一些连通块对应的序列完整地嵌入两个点之间，直接用堆贪心即可。

由于要字典序最小，可以先不妨令 $1$ 在第一个位置，考察是否可行。先考虑所有与 $1$ 相邻的点，那么需要给它们固定一个顺序，假设已经确定为 $p_1,p_2,\cdots,p_d$。如果一个其它的点 $u$ 在将 $1$ 删去后与 $p_i$ 中的三个点有边，那么可以发现一定是无解的。更进一步地，如果存在 $p_i,p_j,p_k$，使得存在路径 $u\to p_i,u\to p_j,u\to p_k$ 满足这些路径均不经过任何 $p_x$（除了端点处），那么也同样是无解的。因此我们删掉 $1$ 这个点，将剩下的点缩成点双，则一定不存在一个点双中包含至少三个 $p_i$。

这启发我们将原图按点双缩起来，得到圆方树。容易发现对于 $1$ 所处的不同点双，它们实际上是独立的。即将圆方树看作以 $1$ 为根，那么对于每个 $1$ 的儿子子树，构造出它在以 $1$ 为一个端点时的最优解之后，整个图的最优解就是将每个子树的最优解按照其除了 $1$ 以外的第二个元素从小到大贪心拼接得到的。对于更一般的情况，如果以任意一个点 $x$ 为根，那么可能会出现某个子树的解比 $x$ 小的情况。此时可以将 $x$ 也看作一个序列，将所有子树的答案序列（包括 $x$）放在一起排序即可。这样的正确性是缘于若一个序列合法，则其翻转也一定是合法的。

因此我们只需要将每个点双内的点按照一定顺序排列，然后每个点下面的子树就是一个子任务。递归求解之后返回的时候按照已经定好的顺序将点双里的点替换为其子树对应的序列即可。

上述所有分析将问题转化为了原图点双连通的情况，本质上还是需要解决一个和原来类似的问题。但一个直觉是点双对于边的限制是很多的，所以感觉上整个排列应该是比较固定的。事实上，可以说明在固定起点的情况下，一个点双对应的合法排列数目只有两个，且这两个之间可以通过翻转除了第一个元素以外的其它位置得到。

这个结论也可以通过下面的分析得出，即下面我们重点关注如何求出任意一个合法排列，然后根据过程自然可以证明排列只有两种可能性。构造完成后取字典序较小者作为实际序列即可（注意这里字典序采用的比较方法是子树内答案的字典序，而非点的编号大小）。

现在已经钦定了左端点，设它为 $L$，考虑所有 $L$ 的邻居 $p_1,\cdots,p_k$。我们构造一张 $k$ 个点的无向图，其中 $(i,j)$ 之间有边当且仅当 $p_i,p_j$ 能在不经过其它 $p_x$ 与 $L$ 的情况下互相到达。由于原图点双连通，所以这张图必然连通。而如果存在一个点度数 $>2$，那么根据最开始的分析，这种情况是无解的，不合法。所以只能是环或链两种可能性，但如果是环，那么就没有点能够放在 $L$ 的下一个位置了，所以只能是链。并且链的两种排列方式决定了 $p_i$ 在实际序列中的相对位置关系。这也是为什么最终实际上有两种通过翻转得到的序列。

取任意一种排列顺序，则对于每个其它点，通过 bfs 求出它在不经过任何 $p_j$ 的情况能到达哪些 $p_i$。显然能到的点一定是恰好一对相邻的 $(p_i,p_{i+1})$，记这个点是属于 $i$ 的。现在情况已经十分清晰，我们对每个 $i$，考察所有属于它的点，它们形成了一个子问题，其中这里不仅钦定了起点 $p_i$，还钦定了终点 $p_{i+1}$。但现在图不一定是点双连通的，所以还需一些其它的分析，而不能直接使用原方法解决问题。

在已经钦定起点 $L$ 和终点 $R$ 的情况下，考虑从 $L$ 出发逐个确定下一个元素是什么。对于第一个元素来说，它一定和 $L$ 有边，否则它不会属于原来的那个点双。类似地，可以归纳说明若最终排列的顺序为 $p_0=L,p_1,\cdots,p_k=R$，那么所有 $p_i,p_{i+1}$ 之间都一定存在一条边。

下面需要在确定一个前缀 $p_0,\cdots,p_i$ 的前提下确定 $p_{i+1}$ 是什么。假设 $p_i$ 所有还未被放入序列的邻居是 $a_1,\cdots,a_k$，那么对于实际为 $p_{i+1}$ 的那个元素，可以发现若它想要走到 $R$ 而不经过 $p_i$ 这个点，就一定要经过其它所有的 $a_i$。实际上也可以进一步注意到假设 $a$ 实际顺序为 $a_1<a_2<\cdots<a_k$，那么 $a_i$ 不经过 $p_i$ 到 $R$ 的路径一定经过 $a_j(j>i)$，但这个结论对解题并不必要。

因此可以得到一个 $O(n^2)$ 确定顺序的方法。每次将 $p_i$ 删去之后从 $R$ 开始跑最短路，最后找到 $p_i$ 所以不在序列里的出边中最短距离最大的一个，只有它能作为 $p_{i+1}$。

为了进一步优化，注意到我们并不一定需要求出确切的最短距离。如果我们以 $R$ 为根建出任意一棵不包含 $p_i$ 的生成树，则由于实际的 $p_{i+1}$ 到 $R$ 的任意一条路径都经过其它所有的 $a_i$，所以在生成树上 $p_{i+1}$ 是所有可选的点中深度最大的一个。

但仍然不能每次重新建生成树求深度。注意到可以先建出不删除任何点的生成树，然后只需要求出在一个点不能走的前提下另一个点到根的最短路是多少。如果这个点在被删除的点子树内，那么找到任意这个子树向外连的最浅的一条边，则由于整张图点双连通，它一定连接了子树内与子树外的两个点。故将这个子树看作以这条边从外面连进来的即可计算距离。否则它的距离就是它本身的深度。

于是这个部分就做到了 $O(n\log n)$。对于解决一个点双内的问题，瓶颈现在只在求出一开始的顺序。而这个顺序可以通过对所有根的邻居做 bfs，但过程中不能经过其它邻居来求出每个点实际属于哪个邻居，复杂度是线性。对于最外层合并所有点双的部分，使用平衡树维护每个子树的答案序列可以做到 $O(n\log n)$。

[代码](https://loj.ac/s/2307826)

---

## 作者：happybob (赞：0)

对于图是树的时候，以 $1$ 为根，递归儿子对应子树随意排列，将这个点本身随意插入到两个空位之间。

图不是树时，发现环的构造情况较少，具体地只要确定了在序列中出现的最靠前的位置，其他点要么顺时针排列要么逆时针排列，所以事实上环上的点在序列中顺序必然是某个顺时针或逆时针顺序。

注意到同胚于 $\operatorname{K4}$ 的子图无解，杏仁图也无解，所以原图是广义串并联图，每个点双是外面一个哈密顿回路和中间的若干条不交的边构成的平面图。

建圆方树，发现对于圆点来说，结论和树上一样，递归到子树构造并随意排列后插入，对于方点限制有所不同，儿子节点必须按照哈密顿回路上的顺序，也就是只有两种需要考虑的顺序，贪心取较小的即可。

所以只需要求一个这样的点双的哈密顿回路即可，直接按照广义串并联图的套路即可，不过这题不需要缩一度点，因为任意时刻都不会有叶子，所以只需要缩二度点与叠合重边，叠合重边时将原有边覆盖即可。

图不连通时先求出每个连通分量的序列答案，注意到我们只需要求任意两个联通分量序列上要么不交要么包含，排序后可以贪心构造答案。

---


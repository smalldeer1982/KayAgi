# [SCOI2012] 喵星人的入侵

## 题目描述


a180285 幸运地被选作了地球到喵星球的留学生，其实是作为特工去调查，喵星人是否有侵略地球的企图。喵星人果然打算入侵地球！从 a180285 口中得到确切消息之后，地球小组成员决定制定反侵略计划。

喵星到地球的一段必经之路可以看作 $n\times m$ 的格点，喵星人将会从地图上的 $S$ 位置出发，目的地是地球的入口 $T$。为了抵抗喵星人的入侵，地球防御小组打算在地图上的格点上放置一些炮塔（最多放置 $K$ 个），炮塔攻击周围的 $8$ 个方向（$8$ 个方向分别是：东、南、西、北、东北、西北、东南、西南）（如下图所示，中间格子的炮塔可以攻击周围的八个格子）。此外地球防御小组还可以在地图上放置无限多个障碍，使得喵星人无法从有障碍的格子经过。

![](https://cdn.luogu.com.cn/upload/image_hosting/l6ezyb3h.png)

右图是 $3\times 3$ 地图的一个示例，其中 $\tt X$ 表示炮塔，$\tt \#$ 表示障碍，有炮塔或者障碍的格子，喵星人都无法经过。在这张地图中喵星人从 $S$ 走到 $T$ 受到的伤害如下：

- 在 $S(1, 0)$ 处受到伤害为 $2$（炮塔 $(0,0)$ 和 $(2, 1)$ 能攻击到 $S$）；
- 在空地 $(1,1)$ 处受到伤害为 $3$（同时被炮塔 $(0,0),(0,2)$ 和 $(2, 1)$ 攻击）；
- 在 $T(1,2)$ 处受到伤害为 $2$（炮塔 $(0,2)$ 和 $(2, 1)$ 能攻击到 $T$）。

于是受到的总伤害为 $2+3+2=7$。

作为地球防御小组的成员，请你为喵星人布阵，使得喵星人受到的伤害最大。注意如果有多条从 $S$ 到 $T$ 的路径，喵星人会选择伤害最小的一条。

## 说明/提示

### 样例解释

样例的一种最优布局方案如下：

```plain
S#T
.X.
...
```

### 数据范围及约定

- 对于 $30\%$ 的数据，保证 $1\le n,m\leq 6$；
- 对于 $100\%$ 的数据，保证 $\min(n,m)\le 6$，$\max(n,m)\le 20$，$1\le K\le 15$ 且从 $S$ 到 $T$ 的路径必定存在。


## 样例 #1

### 输入

```
3 3 1
S.T
...
...```

### 输出

```
7```

# 题解

## 作者：UltiMadow (赞：28)

本题解思路&部分代码实现来自[这篇](https://www.luogu.com.cn/blog/efforts-will-pay-off/du-liu-dong-gui-cha-tou-dp)日报

终于过了，调了3h，写个题解纪念一下

~~这道题让我感到了什么叫真正的毒瘤~~

这题呢，看一眼数据范围，大概是插头dp

那我们就要考虑如何设计状态了

显然，本题中只记录轮廓线的**插头**状态是不够的，因为每个点的权值是由它周围的八个点的状态决定的，所以我们还要记录轮廓线的**路径**，也就是轮廓线上是放障碍还是炮台还是路径

我们记轮廓线上如果是障碍则为状态 0，如果是路径则为状态 1，如果是炮台则为 3

当然，我们发现插头状态仅记录左括号（记为1），右括号（记为2），和无插头（记为0）是不够的，因为本题中可能有没有括号和它匹配的插头，我们称其为**独立插头**（记为3）

我们又发现炮台的数量还有个限制，于是还要加一个状态记录炮台的数量

接下来，就是~~喜闻乐见~~的大力分类讨论时间啦

（当然，如果你没有做过[这个](https://www.luogu.com.cn/problem/P5056)题，那么建议你先去做一下，因为本题插头使用括号表示法）

我们记 $pl1$ 为右插头，记 $pl2$ 为下插头

1. 这个点 $pl1=0$ 且左边是路径或 $pl2=0$ 且上边是路径  
这种情况显然需要用障碍去堵住  
那么，显然只有无左插头且无下插头的情况是合法的  
接下来，只要转移这个点放炮台或障碍就行了

2. 这个点是障碍点  
这应该是最简单的一种  
显然只有无左插头且无下插头的情况是合法的  
直接转移即可

3. 这个点是非障碍点  
（疯狂的地方开始了）  
1）若 $pl1=0$ 且 $pl2=0$  
$\quad$ 则可以添加炮台，或者新建一个联通分量，或者不走  
2）若 $pl1=0$ 或 $pl2=0$  
$\quad$ 则直接延伸插头即可  
3）若 $pl1=1$ 且 $pl2=1$  
$\quad$ 则需要向右寻找一个右括号换成左括号并删除当前插头  
4）若 $pl1=2$ 且 $pl2=2$  
$\quad$ 则需要向左寻找一个左括号换成右括号并删除当前插头  
5）若 $pl1=1$ 且 $pl2=2$  
$\quad$ 不合法，因为这样会形成闭合回路  
6）若 $pl1=2$ 且 $pl2=1$  
$\quad$ 直接删除插头即可  
7）若 $pl1=1$ 且 $pl2=3$ 或 $pl1=3$ 且 $pl2=1$  
$\quad$ 则需要向右寻找一个右括号替换成独立插头并删除当前插头  
8）若 $pl1=2$ 且 $pl2=3$ 或 $pl1=3$ 且 $pl2=2$  
$\quad$ 则需要向左寻找一个左括号替换成独立插头并删除当前插头  
9）若 $pl1=3$ 且 $pl2=3$  
$\quad$ 直接删除插头即可

4. 这个点是起点或者终点  
1）若 $pl1=0$ 且 $pl2=0$  
$\quad$ 则需要新建一个独立插头  
2）若 $pl1=1$ 且 $pl2=0$ 或 $pl1=0$ 且 $pl2=1$  
$\quad$ 则需要向右寻找一个右括号替换成独立插头并删除当前插头  
3）若 $pl1=2$ 且 $pl2=0$ 或 $pl1=0$ 且 $pl2=2$  
$\quad$ 则需要向左寻找一个左括号替换成独立插头并删除当前插头  
4）若 $pl1=3$ 且 $pl2=0$ 或 $pl1=0$ 且 $pl2=3$  
$\quad$ 直接删除插头即可

---
以上是大力分类

接下来，我们来讲讲点权的事情

如果经过这个点，由于我们只知道轮廓线上的周围四个点的情况，所以只能加上这四个点中炮台的个数

如果这个点放障碍，不加，直接传下去就行

如果这个点放炮台，我们就要加上轮廓线上路径的个数，那为啥这样直接加是对的呢？

我们如果不经过一个点，我们可以直接把它设置成障碍，这样，一个炮台的贡献就是轮廓线上的周围四个点中路径的个数

该解释的都解释了，我们来看代码吧
```cpp
#include<bits/stdc++.h>
#define MAXN 25
#define p 100007
#define int long long
using namespace std;
int n,m,K,now,pre;
char c[MAXN][MAXN];
int head[p+3],nxt[1<<24];
int f[2][1<<24],fst[2][3][1<<24];
int cnt[2];
void insert(int state1,int state2,int state3,int val)
{
	int ha=((((1ll*state1<<16)|state2)<<4)|state3)%p+1;//哈希
	for(int i=head[ha];i;i=nxt[i])
		if(fst[now][0][i]==state1&&fst[now][1][i]==state2&&fst[now][2][i]==state3)
		{
			f[now][i]=max(f[now][i],val);
			return;
		}
	f[now][++cnt[now]]=val;
	fst[now][0][cnt[now]]=state1;
	fst[now][1][cnt[now]]=state2;
	fst[now][2][cnt[now]]=state3;//三个状态
	nxt[cnt[now]]=head[ha];
	head[ha]=cnt[now];
}//hash表
int left(int state,int pos,int val)
{//向左寻找左括号
	int tot=1;
	while(true)
	{
		int pl=(state>>(pos<<1))&3;
		if(pl==2)tot++;if(pl==1) tot--;
		if(!tot)return state^(pl<<(pos<<1))^(val<<(pos<<1));
		pos--;
	}
}
int right(int state,int pos,int val)
{//向右寻找右括号
	int tot=1;
	while(true)
	{
		int pl=(state>>(pos<<1))&3;
		if(pl==1)tot++;if(pl==2) tot--;
		if(!tot)return state^(pl<<(pos<<1))^(val<<(pos<<1));
		pos++;
	}
}
char tmp[MAXN][MAXN];
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&K);
	for(int i=0;i<n;i++)scanf("%s",c[i]);
	if(n<m)
	{//n<m的时候把地图转90度
		memcpy(tmp,c,sizeof(c));
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
				c[j][i]=tmp[i][j];
		swap(n,m);
	}
	cnt[0]=1;
	for(int i=0;i<n;i++)
	{
		for(int j=1;j<=cnt[now];j++)
			fst[now][0][j]<<=2;
		for(int j=1;j<=cnt[now];j++)
			fst[now][1][j]=(fst[now][1][j]^(((fst[now][1][j]>>(m+1<<1))&3)<<(m+1<<1)))<<2;//更新上一行的状态
		for(int j=0;j<m;j++)
		{
			pre=now;now^=1;cnt[now]=0;
			memset(head,0,sizeof(head));//注意初始化
			for(int k=1;k<=cnt[pre];k++)
			{
				int sta=fst[pre][0][k],stb=fst[pre][1][k],stc=fst[pre][2][k];
				int val=f[pre][k];
				if(sta>=(1<<(m+1<<1)))continue;
				int pl1=(sta>>(j<<1))&3;//right
				int pl2=(sta>>(j+1<<1))&3;//down
				int r=(stb>>(j<<1))&3;//右状态
				int ur=(stb>>(j+1<<1))&3;//右上状态
				int u=(stb>>(j+2<<1))&3;//上状态
				int ul=(stb>>(j+3<<1))&3;//左上状态
				int now=(sta^(pl1<<(j<<1))^(pl2<<(j+1<<1)));
				if((!pl1&&r==1)||(!pl2&&u==1))//1
				{
					if(pl1||pl2)continue;
					insert(now,stb^(ur<<(j+1<<1)),stc,val);//放障碍
					if(stc<K&&c[i][j]=='.')
						insert(now,stb^(ur<<(j+1<<1))^(3<<(j+1<<1)),stc+1,val+(r==1)+(ur==1)+(u==1)+(ul==1));//放炮台
				}
				else if(c[i][j]=='#'){if(!pl1&&!pl2)insert(now,stb^(ur<<(j+1<<1)),stc,val);}//2
				else if(c[i][j]=='.')//3
				{
					if(!pl1&&!pl2)//1)
					{
						if(stc<K)
							insert(now,stb^(ur<<(j+1<<1))^(3<<(j+1<<1)),stc+1,
								val+(r==1)+(ur==1)+(u==1)+(ul==1));//放炮台
						insert(now^(1<<(j<<1))^(2<<(j+1<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));//走
						insert(now,stb^(ur<<(j+1<<1)),stc,val);//不走
					}
					else if(!pl1&&pl2)//2）
					{
						insert(now^(pl2<<(j<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
						insert(now^(pl2<<(j+1<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					}
					else if(pl1&&!pl2)//2）
					{
						insert(now^(pl1<<(j<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
						insert(now^(pl1<<(j+1<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					}
					else if(pl1==1&&pl2==1)//3）
						insert(right(now,j,1),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==2&&pl2==2)//4）
						insert(left(now,j,2),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==2&&pl2==1)//6）
						insert(now,stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==1&&pl2==3)//7）
						insert(right(now,j,3),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==2&&pl2==3)//8）
						insert(left(now,j,3),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==3&&pl2==1)//7）
						insert(right(now,j,3),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==3&&pl2==2)//8）
						insert(left(now,j,3),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==3&&pl2==3)//9）
						insert(now,stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
				}
				else if(c[i][j]=='S'||c[i][j]=='T')//4
				{
					if(c[i][j]=='S'&&!pl1&&!pl2)//1）
					{
						insert(now^(3<<(j<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
						insert(now^(3<<(j+1<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					}
					else if(c[i][j]=='T'&&!pl1&&!pl2)//1）
					{
						insert(now^(3<<(j<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
						insert(now^(3<<(j+1<<1)),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					}
					else if(!pl1&&pl2==1)//2）
						insert(right(now,j,3),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(!pl1&&pl2==2)//3）
						insert(left(now,j,3),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==1&&!pl2)//2）
						insert(right(now,j,3),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==2&&!pl2)//3）
						insert(left(now,j,3),stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(pl1==3&&!pl2)//4）
						insert(now,stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
					else if(!pl1&&pl2==3)//4）
						insert(now,stb^(ur<<(j+1<<1))^(1<<(j+1<<1)),stc,
							val+(r==3)+(ur==3)+(u==3)+(ul==3));
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<=cnt[now];i++)//统计答案
		if(!fst[now][0][i])
			ans=max(ans,f[now][i]);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xtx1092515503 (赞：9)

本文的实现要比常规插头 DP 要复杂（即分类讨论的情形更多）。但是，其思想（大概）会比常规插头DP要更加简单。一句话，本文比较无脑硬上。同时，码量在删去注释后应该比常规插头 DP 有优势（因为除了分类讨论外细节不多）。

------

首先先默认 $n>m$，再令下标自 $0$ 开始。

一个简单的观察是必定存在一种最优状态使得路径唯一——因为障碍数量无限制，所以自然可以堵死那些敌人不会去的地方。这样便是有关路径的统计，又是网格图，考虑插头 DP。

但是我们发现插头 DP 并不好，因为并非所有信息都能用插头表示，一个典型的例子是格子中有无炮台。因此，我们考虑压缩轮廓线周围的**方格**而非**插头**。

因为一个炮台影响八连通的格子，所以一个显然的想法是压缩 $m+1$ 个格子的状态。假如当前决策点是 $(x,y)$，则状态中应该存储第 $x$ 行中 $0\sim y-1$ 位置的状态，以及第 $x-1$ 行中 $y-1\sim m-1$ 位置的状态。这样在决策 $(x,y)$ 时，所有它能影响到以及能影响到它的位置全部被记录在状态中了。

然后我们考虑状态的每一位填什么、各表示什么意义：

0. 这个格子放置了障碍。
1. 这个格子是路径中某一段的左端点。
2. 这个格子是路径中某一段的右端点。
3. 这个格子在路径上，但不是端点。
4. 这个格子是端点，但是此段路径的另一个端点是起点/终点。
5. 这个格子放置了炮台。
6. 这个格子是某一段路径的起点。（也即，其同时是1和2）。

除了状态6其它都比较好理解，唯独状态6比较奇怪。但是事实上仔细一想这是正常的，因为我们记录的是**方格状态**而非**插头状态**，如果记录的是插头那么6就可以用一个下插头+一个右插头表示，但是方格就只能老老实实新建状态表示。

因为仅仅是编号就太抽象了，所以我们将所有状态用一个形容词来修饰一下：

- 0&5，这两个状态是“绝缘 `insulated`”的，它不会产生任何互动（当然，5会对周边的格子有辐射，但是这不会影响格子的状态，仅仅影响答案罢了）。
- 3，这个状态是“惰性 `inert`”的，它不会扩展，周边也不应该出现其它非绝缘状态（不然路径就会不唯一）。
- 6，这个状态是“多动 `hyperactive`”的（实际上我本来想用“活泼”来修饰，但是 `hyperactive` 这个词太有韵味了，`hyper-` 前缀除了“过于活泼”也有“虚拟”的意思，刚好表示状态6实际上是不存在的，其真实意义是1和2挤在一个格子中）。它在产生的下一轮DP中，就会立马“裂变”变回1和2。同时，“多动”也表示它自然产生条件严苛（周边只能存在绝缘的格子）。
- 4，这个状态是“寄生 `parasitic`”的。它自然产生条件非常严苛（和6一样），但是却可以依托某段路径产生。并且，它会把一整段1-2路径直接寄生成4路径。
- 1&2，这两个状态是“平凡 `mundane`”的，它没有过多的特征。

用8进制压缩7进制是老生常谈了。$f(x,y,w,k)$ 表示待决策的格子是 $(x,y)$、填入炮台数是 $w$、状态是 $k$ 时的答案应该也不难想到。然后现在我们来考虑如何转移。

> 附：我最近找到一种形象地给网格图上变量取名的好方法。我们可以看向键盘。
>
> ```
> QWERTYUIOP
> ASDFGHJKL
> ZXCVBNM
> ```
>
> 假如我们当前关心的格子是 `J` 的话，就可以轻松得到其它方位的变量的命名：左侧是 `H`，左上是 `Y`，上方是 `U`，右上是 `I`。这几个位置是我们决策 `J` 时需要知道的信息。
>
> 至于为什么选择 `J` 而不选其它字符嘛，因为其它字符周边的区域中的大写字符已经被我占用了。
>
> ~~甚至可以出一道题目：键盘上有一些大写字符已经被占用，求最多能挖出几块这样的区域。~~
>
> ~~然后发现这也可以用轮廓线DP解决。~~

好那么我们现在考虑转移。

首先，当前格 `J` 填入非绝缘状态（即是路径的一部分）和填入5时对答案的贡献可以由 `H,Y,U,I` 四个状态处理得到。

然后，我们考虑转移。

首先先考虑 $(x,y)$ 填入的东西并非由 `H,U` 的状态延伸而来的情形。

- 考虑6以及4（在不寄生一条现存路径的时候）的产生（二者条件相同）。我们上文已经提到其产生条件苛刻，即须满足 `H,U` 绝缘且当前格子非障碍。此时，若当前格子非起讫点，则可填入6。否则，即其是起讫点，则可填入4。

- 考虑填入绝缘状态的情形。其限制是当前格子非起讫点、`H` 不能填入多动的6（因为6在产生后会立马裂变成为1和2，因此如果当前点是绝缘状态的话就会阻止6的裂变），以及 `U` 只能填入绝缘的0&5或者惰性的3——因为非绝缘、非惰性的状态是总要延伸的，不往右边延伸就往下边延伸，而 `U` 往右边延伸的路已经被 `I` 堵死了，所以非绝缘、非惰性的 `U` 必须往下延伸，则当前格子不能绝缘。此时，无论如何都可以填入0，而当当前格子非障碍时就可填入5。

其它所有状态都是由 `H,U` 的状态延伸或拼接而成的。所以这时，如果格子有障碍，就可以直接 `continue` 了——障碍格显然不能成为延伸或拼接的去处。

- 考虑 `U` 非绝缘非惰性，即其必须延伸的情形。
    - 考虑 `H` 非绝缘，即延伸的 `U` 必然会导致两条路径交汇的情形。
        - 当前格子是起讫点。此时就会发生从当前格子出发有两条不同路径的情形，因此 `continue`。
        - `H=3`：因为此时 `H` 非端点，所以就会出现路径不唯一的状况，因此状态不合法，直接 `continue` 掉。
        - `Y` 非绝缘，此时就会出现四个相邻位置成团的现象，状态不合法，直接 `continue`。
        - `U=6`，这个状态不可能出现（因为6一出现就会裂变），直接 `continue`。
        - `H=1,U=1 或 H=2,U=2`，这两个状态同常规插头DP类似，合并后修改其中一条路径的另一端点即可。注意合并完后 `HJU` 都变成3（路径的非端点部分）。
        - `H=1,U=2`，这时路径成环，`continue`。
        - `H=2,U=1`，同常规插头DP一致，直接合并。注意合并完 `HJU` 都变成3。
        - `H=4,U=4`，这时相当于完整的一条路径被拼接成了，直接合并，`HJU` 变成3。
        - `H=4,U=1 或 H=1,U=4`，这两个状态相似，把与其中的1对应的2赋成4、`HJU` 变成3即可。
        - `H=4,U=2 或 H=2,U=4`，这两个状态相似，把与其中的2对应的1赋成4、`HJU` 变成3即可。
        - `H=6`，这时就把它当作1与2的合体计算即可。
    - 考虑 `H` 绝缘，只有 `U` 延伸的情形。
        - 考虑当前格子是起讫点。如果 `U` 是1或2就修改对应另一端点为4，`JU` 变成3；如果 `U` 也是4就直接 `JU` 变成3即可。
        - 考虑当前格子非起讫点。此时就把 `J` 赋作 `U`，`U` 赋作3即可。
- 剩余情形下，就是 `U` 无法延伸的状态了。因为两个格子均不延伸的情形我们已经讨论过了，所以这里只需讨论 `H` 延伸的情形。此时要求 `H` 非绝缘，非惰性。
    - `U=3`。同上，路径不唯一，`continue`。
    - 剩下的就跟 `H` 绝缘 `U` 延伸的转移差不多了。唯一需要注意的是 `H` 可能为6，此时就当作1和2同时存在即可。

不重不漏，讨论完毕。

代码（附有详细注释）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int fni=0xc0c0c0c0;
int n,m,p,hs[2100000],sta[50000],cnt,res;
void pr(int x){for(int i=0;i<=m;i++)printf("%d",(x>>i*3)&7);}
int f[2][16][50000];
//0:block 1:left plug 2:right plug 3:part of the route 4:free plug 5:cannon 6:bi-direction plug
//0&5 are 'insulated',which do not act with any state.
//3 is 'inert',which cannot expand.
//6 is 'hyperactive',which has the necessity of expanding in both directions.
//4 is 'parasitic',which need a 1/2 plug to produce, otherwise it is as difficult as 6 when to be produced.
//1&2 are 'mundane',which do not have strong characteristics.
//all plugs except the 'insulated' 0&5 and the 'inert' 3, once put above, will always expand.
char s[30][30];
int num[30];
void dfs1(int pos,int msk,int fre,int tms){
	if(pos==m+1){
		if(tms)return;
		for(int i=1;i<pos;i++){
			if((num[i]==1||num[i]==2||num[i]==4)&&num[i-1]==3&&num[i+1]==3)return;
			if(num[i]==6&&(num[i-1]==3||num[i+1]==3))return;
		}
		cnt++,hs[msk]=cnt,sta[cnt]=msk;
		return;
	}
	num[pos]=0;dfs1(pos+1,msk,fre,tms);
	num[pos]=3,dfs1(pos+1,msk+(3<<pos*3),fre,tms);
	num[pos]=5;dfs1(pos+1,msk+(5<<pos*3),fre,tms);
	if(!pos||num[pos-1]==0||num[pos-1]==5){
		num[pos]=1,dfs1(pos+1,msk+(1<<pos*3),fre,tms+1);
		num[pos]=6,dfs1(pos+1,msk+(6<<pos*3),fre,tms);
	}
	if(!pos||(num[pos-1]!=2&&num[pos-1]!=6&&num[pos-1]!=4))num[pos]=2,dfs1(pos+1,msk+(2<<pos*3),fre,tms-1);
	if((!pos||num[pos-1]==0||num[pos-1]==5||num[pos-1]==3)&&fre<2)num[pos]=4,dfs1(pos+1,msk+(4<<pos*3),fre+1,tms);
}
int nex(int y,int k){
	if(y==m-1){
		int L=k>>m*3;k-=(L<<m*3);
		if(L!=0&&L!=3&&L!=5)return 0;
		return hs[k<<3];
	}
	return hs[k];
}
int P=0,Q=1;
void chmx(int j,int w,int id,int nw,int K,int bon=0){
	int nid=nex(j,K);
//	printf("%d:",nid),pr(K),puts("");
	if(nid&&nw<=p)f[Q][nw][nid]=max(f[Q][nw][nid],f[P][w][id]+bon);
}
int nex2(int y,int K){
	for(int i=y,j=0;i<=m;i++){
		if(((K>>i*3)&7)==1)j++;
		if(((K>>i*3)&7)==2&&!j--)return i;
	}
}
int las1(int y,int K){
	for(int i=y,j=0;i>=0;i--){
		if(((K>>i*3)&7)==2)j++;
		if(((K>>i*3)&7)==1&&!j--)return i;
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&p);
	for(int i=0;i<n;i++)scanf("%s",s[i]);
	if(n<m){
		for(int i=0;i<n;i++)for(int j=i+1;j<m;j++)swap(s[i][j],s[j][i]);
		swap(n,m); 
	}
	dfs1(0,0,0,0);
//	printf("%d\n",cnt);
//	for(int i=1;i<=cnt;i++)pr(sta[i]),puts("");
	memset(f[P],fni,sizeof(f[P]));
	f[P][0][hs[0]]=0;
	for(int i=0;i<n;i++)for(int j=0;j<m;j++,P^=1,Q^=1){
		memset(f[Q],fni,sizeof(f[Q]));
		for(int w=0;w<=p;w++)for(int id=1;id<=cnt;id++){
			if(f[P][w][id]<0)continue;
			int k=sta[id];
//			printf("(%d,%d)[%d,%d]",i,j,w,id);pr(k);printf(":%d\n",f[P][w][id]);
			int H=0,Y=(k>>j*3)&7,U=(k>>(j+1)*3)&7,I=(k>>(j+2)*3)&7;
			if(U==6)continue;
			//impossible to have 6 above, as 'hyperactive' 6 is 'hyper', will immediately fission into 1&2.
			int K=k-(Y<<j*3),KHU=K;
			K-=(U<<(j+1)*3);int KH=K;
			if(j)H=((k>>(j-1)*3)&7),K-=(H<<(j-1)*3);
			int bon=(H==5)+(Y==5)+(U==5)+(I==5);
			int nob=(H!=0&&H!=5)+(Y!=0&&Y!=5)+(U!=0&&U!=5)+(I!=0&&I!=5);
			if((H==0||H==5)&&(U==0||U==5)&&s[i][j]!='#'){
				//situation of producing 'hyperactive' 6 and 'parasitic' 4(when it does not parasitize)
				if(s[i][j]=='S'||s[i][j]=='T')chmx(j,w,id,w,KHU+(4<<j*3),bon);
				else chmx(j,w,id,w,KHU+(6<<j*3),bon);
			}
			if(H!=6&&(U==0||U==5||U==3)&&s[i][j]!='S'&&s[i][j]!='T'){
				//situation where it is possible to put 'insulated' 0&5 in.
				chmx(j,w,id,w,KHU);//putting 0.
				if(s[i][j]!='#')chmx(j,w,id,w+1,KHU+(5<<j*3),nob);//putting 5.
			}
			if(s[i][j]=='#')continue;//the only operation under this circumstance is putting 0.
			if(U!=0&&U!=5&&U!=3){//situation when U has to expand.
				if(H!=0&&H!=5){//two plugs meet.
					if(s[i][j]=='S'||s[i][j]=='T')continue;//there can't be two different routes around endpoints.
					if(H==3)continue;//H has been on a complete route.
					if(Y!=0&&Y!=5)continue;//a 'cancer' forms, which is invalid. 
					if(H==1&&U==1)chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3)-(1<<nex2(j,K)*3),bon);
					//two 1s will 'alpha-fusion', turing a 2 into 1, and leaving three 3s. 
					if(H==1&&U==2)continue;//1&2 will 'circle', which is invalid.
					if(H==2&&U==1)chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3),bon);
					//2&1 will 'beta-fusion',only leaving three 3s. 
					if(H==2&&U==2)chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3)+(1<<las1(j,K)*3),bon);
					//two 2s will 'gamma-fusion', turing an 1 into 2, and leaving three 3s.
					if(H==6&&U==1)chmx(j,w,id,w,K+(1<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3),bon);
					if(H==6&&U==2)chmx(j,w,id,w,K+(2<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3),bon);
					//6 shall be seen as 1+2.
					if(H==4&&U==4){chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3),bon);continue;}
					//two 'parasitic' 4, forming a complete route.
					if(H==4&&U==1||H==1&&U==4)chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3)+(2<<nex2(j,K)*3),bon);
					if(H==4&&U==2||H==2&&U==4)chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3)+(3<<las1(j,K)*3),bon);
					if(H==6&&U==4)chmx(j,w,id,w,K+(4<<(j-1)*3)+(3<<j*3)+(3<<(j+1)*3),bon);
					//4 going parasitize. 
					continue;
				}
				if(s[i][j]=='S'||s[i][j]=='T'){
					if(U==1)chmx(j,w,id,w,KH+(3<<j*3)+(3<<(j+1)*3)+(2<<nex2(j,K)*3),bon);
					if(U==2)chmx(j,w,id,w,KH+(3<<j*3)+(3<<(j+1)*3)+(3<<las1(j,K)*3),bon);
					if(U==4)chmx(j,w,id,w,KH+(3<<j*3)+(3<<(j+1)*3),bon);
					continue;
				}
				chmx(j,w,id,w,KH+(U<<j*3)+(3<<(j+1)*3),bon);
				continue;
			}
			if(H!=0&&H!=5&&H!=3){
				if(U==3)continue;
				if(s[i][j]=='S'||s[i][j]=='T'){
					if(H==1)chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(2<<nex2(j,K)*3)+(U<<(j+1)*3),bon);
					if(H==2)chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(3<<las1(j,K)*3)+(U<<(j+1)*3),bon);
					if(H==4)chmx(j,w,id,w,K+(3<<(j-1)*3)+(3<<j*3)+(U<<(j+1)*3),bon);
					if(H==6)chmx(j,w,id,w,K+(4<<(j-1)*3)+(3<<j*3)+(U<<(j+1)*3),bon);
					continue;
				}
				if(H==1||H==2||H==4)chmx(j,w,id,w,K+(3<<(j-1)*3)+(H<<j*3)+(U<<(j+1)*3),bon);
				else chmx(j,w,id,w,K+(1<<(j-1)*3)+(2<<j*3)+(U<<(j+1)*3),bon);
			}
		}
	}
	for(int j=1;j<=cnt;j++){
		bool ok=true;
		int k=sta[j];
		for(int t=0;t<=m;t++)if(((k>>t*3)&7)!=0&&((k>>t*3)&7)!=3&&((k>>t*3)&7)!=5){ok=false;break;}
		if(!ok)continue;
		for(int i=0;i<=p;i++)res=max(res,f[P][i][j]);
	}
	printf("%d\n",res);
//	for(int i=1;i<=cnt;i++)pr(sta[i]),puts("");
	return 0;
}
```



---

## 作者：Piwry (赞：7)

## 解析

发现障碍可以随便放，所以若给出一条路径，一定有办法使它合法：只要在路径旁都放上障碍就行。

不过路径是不允许四连通（即路径格子间除了插头还有共边），否则还会有更短的路径

（四连通）

![四连通](https://cdn.luogu.com.cn/upload/image_hosting/ftvzkm65.png)

于是这就相当于求一条不允许四连通的格点路径，且起点为 $S$，终点为 $T$，这个我们用插头 dp 很方便地就能求出

### 求网格路径

具体来说，我们另引入一个独立插头，代表路径从这格**出发或结束**，这格只有**这一个插头**

比起求回路另外要注意的几点：

-   轮廓线内最多存在两个独立插头（对于求一条路径；多条路径需要最小表示）

-   若合并独立插头和一个括号，显然会把该括号对的**另一个括号**变为独立插头

-   像这题要求求出一条路径，显然是不允许回路存在的。如果出现回路那么这个状态就无效

如果要使路径以 $S, T$ 为起点终点，**只允许在这两个格子放**独立插头就行了

### 计算炮塔贡献

现在再来考虑如何算路径的贡献

当我们 dp 到棋盘的某一格时，我们已遍历的格子都在轮廓线的上面

![轮廓线](https://cdn.luogu.com.cn/upload/image_hosting/6vqmc0de.png)

也就是说，若我们在这格放下炮塔，只能统计到八个方向的左、左上、上、右上这四个方向的贡献

可以发现，若剩下四个方向的位置有路径，这个炮塔也**一定在该路径的上述四个方向**（左、左上、上、右上）之一的位置

于是我们对于每个路径格子也统计左、左上、上、右上这四个方向的贡献即可

&nbsp;

具体实现时我们再状压另一个状态，表示轮廓线上格子的种类；左上方向的格子不在轮廓线上，再另外设个状态保存就行了。

（另外注意这个状态在换行时可能产生多余的信息（见下图轮廓线红色边））

![换行多余](https://cdn.luogu.com.cn/upload/image_hosting/95sax6gj.png)

至于炮塔个数限制，也同样设个状态保存（复杂度最后是过得了的，两个轮廓线的不同状态数差不多 $4^m$，$m\leq 6$，放心设就行...）

### 其它

大力分类部分直接见代码，或者看另一篇题解即可。

## CODE

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#define ll long long
#define ull unsigned ll
#pragma GCC optimize(2)/*以我的常数可能有点悬...*/
using std::vector;

const int M =1e6+3;

int n, m, K;
char map[21][7];
struct qwq{
	int state/*插头信息*/, state2/*地图格子信息*/;
	int mpl/*新格子左上角格子信息*/, battery/*炮台数*/;
	int pre;
	ll sum;
	qwq(int s, int s2, int mp, int b, int p, ll su)
		:state(s), state2(s2), mpl(mp), battery(b), pre(p), sum(su){}
};
int pos[M];
bool used[M];
vector<qwq> hsh, dp;

inline int get(int state, int x){
	int p =(1<<(x<<1));
	int a =(bool)(state&p), b =(bool)(state&(p<<1));
	return a+(b<<1);
}

inline void upd(int &state, int x, int val){ state +=-(get(state, x)<<(x<<1))+(val<<(x<<1)); }

/*hash 链式前向星*/
inline void push(qwq nw){
	int key=(((((ull)nw.state<<18)|(ull)nw.state2)<<4)|nw.battery)%M;
//	unsigned ll tmp =(nw.state-nw.state2+nw.battery);
//	int key =tmp*tmp%M;
	if(!used[key]){
		used[key] =1;
		nw.pre =-1;
		hsh.push_back(nw);
		pos[key] =hsh.size()-1;
	}
	else{
		for(int p =pos[key]; p != -1; p =hsh[p].pre)
			if(hsh[p].state == nw.state && hsh[p].state2 == nw.state2 && hsh[p].battery == nw.battery && hsh[p].mpl == nw.mpl){
				if(nw.sum > hsh[p].sum)
					hsh[p].sum =nw.sum;
				return;
			}
		nw.pre =pos[key];
		hsh.push_back(nw);
		pos[key] =hsh.size()-1;
	}
}

inline void clearhsh(){
	hsh.clear();
	memset(used, 0, sizeof(used));/*比起清空 pos 会稍微节省些常数*/
}

inline int count(int mp1, int lmp, int mp2, int rmp, int typ){
	int cnt =0;
	if(lmp == typ) ++cnt;
	if(mp1 == typ) ++cnt;
	if(mp2 == typ) ++cnt;
	if(rmp == typ) ++cnt;
	return cnt;
}

/*给定一个括号位置，把这个括号对替换成指定插头*/
inline void updbracket(int &state, int posi, int val){
	int x, d, cnt =0, pg =get(state, posi), pg_;
	if(pg == 1)
		d =1, pg_ =2;
	else
		d =-1, pg_ =1;
	for(x =posi+d; cnt >= 0; x +=d){
		if(get(state, x) == pg) ++cnt;
		else if(get(state, x) == pg_) --cnt;
	}
	x -=d;
	upd(state, posi, val), upd(state, x, val);
}

inline void work(){
	clearhsh();
	dp.push_back(qwq(0, 0, 0, 0, -1, 0));
	for(int i =0; i < n; ++i){
		for(int k =0; k < (int)dp.size(); ++k)
			dp[k].state <<=2, dp[k].state2 <<=2, dp[k].mpl =0;
		for(int j =0; j < m; ++j){
			for(int k =0; k < (int)dp.size(); ++k){
				qwq nw =dp[k];
				if(get(nw.state, m+1) != 0)
					continue;
				upd(nw.state2, m+1, 0);/*去掉换行产生的多余地图信息*/
				/*0 无插头，1 左括号，2 右括号，3 独立插头*/
				/*0 障碍，1 路径，2 炮台*/
				/*pg1, mp1 左，pg2，mp2 上*/
				int pg1 =get(nw.state, j), pg2 =get(nw.state, j+1);/*plug*/
				int mp1 =get(nw.state2, j), mp2 =get(nw.state2, j+1);/*map*/
				int lmp =nw.mpl/*左上角*/, rmp =get(nw.state2, j+2)/*右上角*/;
				nw.mpl =mp2;/*记录新状态左上角*/
				if(map[i][j] == '#'){
					if(pg1 == 0 && pg2 == 0){
						upd(nw.state2, j, 0), upd(nw.state2, j+1, 0);/*注意更新轮廓线*/
						push(nw);
					}
				}
				else if(map[i][j] == 'S' || map[i][j] == 'T'){/*起点终点处理类似*/
					if(pg1 == 0 && pg2 == 0){/*没有插头*/
						if(mp1 != 1 && mp2 != 1){/*不允许四连通*/
							upd(nw.state, j, 3);
							upd(nw.state2, j, 1), upd(nw.state2, j+1, 1);
							nw.sum +=count(mp1, lmp, mp2, rmp, 2);
							push(nw);
							upd(nw.state, j, 0), upd(nw.state, j+1, 3);
							push(nw);
						}
					}
					else if(pg1 == 0 || pg2 == 0){/*有一个插头*/
						int pg, mp, posi;
						if(pg1 == 0)
							pg =pg2, mp =mp1, posi =j+1;
						else
							pg =pg1, mp =mp2, posi =j;
						if(mp != 1){/*判断四连通*/
							if(pg == 3){/*合并独立插头*/
								upd(nw.state, j, 0), upd(nw.state, j+1, 0);
								upd(nw.state2, j, 1), upd(nw.state2, j+1, 1);
								nw.sum +=count(mp1, lmp, mp2, rmp, 2);
								push(nw);
							}
							else{/*连接的不是一个独立插头，要更新括号*/
								updbracket(nw.state, posi, 3);
								upd(nw.state, j, 0), upd(nw.state, j+1, 0);
								upd(nw.state2, j, 1), upd(nw.state2, j+1, 1);
								nw.sum +=count(mp1, lmp, mp2, rmp, 2);
								push(nw);
							}
						}
					}
					else/*有两个插头，这格也必须有两个插头。但要求这格必须放独立插头（单个插头）*/
						continue;
				}
				else{/*为空地*/
					if(pg1 == 0 && pg2 == 0){
						/*新建分量*/
						if(mp1 != 1 && mp2 != 1){/*判断四连通*/
							qwq nw2 =nw;
							upd(nw2.state, j, 1), upd(nw2.state, j+1, 2);
							upd(nw2.state2, j, 1), upd(nw2.state2, j+1, 1);
							nw2.sum +=count(mp1, lmp, mp2, rmp, 2);
							push(nw2);
						}
						/*放置障碍*/
						upd(nw.state2, j, 0), upd(nw.state2, j+1, 0);
						push(nw);
						/*放置炮台*/
						if(nw.battery < K){
							upd(nw.state2, j, 2), upd(nw.state2, j+1, 2);
							nw.sum +=count(mp1, lmp, mp2, rmp, 1);
							nw.battery +=1;
							push(nw);
						}
					}
					else if(pg1 == 0 || pg2 == 0){/*延伸路径*/
						int pg, mp;
						if(pg1 == 0)
							pg =pg2, mp =mp1;
						else
							pg =pg1, mp =mp2;
						if(mp != 1){/*判断四连通*/
							upd(nw.state, j, pg), upd(nw.state, j+1, 0);
							upd(nw.state2, j, 1), upd(nw.state2, j+1, 1);
							nw.sum +=count(mp1, lmp, mp2, rmp, 2);
							push(nw);
							upd(nw.state, j, 0), upd(nw.state, j+1, pg);
							push(nw);
						}
					}
					else{/*有两个插头*/
						if(pg1 == 3 && pg2 == 3){/*两个独立插头*/
							upd(nw.state, j, 0), upd(nw.state, j+1, 0);
							upd(nw.state2, j, 1), upd(nw.state2, j+1, 1);
							nw.sum +=count(mp1, lmp, mp2, rmp, 2);
							push(nw);
						}
						else if(pg1 == 3 || pg2 == 3){/*有一个独立插头*/
							int posi;
							if(pg1 == 3)
								posi =j+1;
							else
								posi =j;
							updbracket(nw.state, posi, 3);
							upd(nw.state, j, 0), upd(nw.state, j+1, 0);
							upd(nw.state2, j, 1), upd(nw.state2, j+1, 1);
							nw.sum +=count(mp1, lmp, mp2, rmp, 2);
							push(nw);
						}
						else if(pg1 == pg2){/*两个相同插头，要改括号*/
							if(pg1 == 1)
								updbracket(nw.state, j+1, 1);
							else
								updbracket(nw.state, j, 2);
							upd(nw.state, j, 0), upd(nw.state, j+1, 0);
							upd(nw.state2, j, 1), upd(nw.state2, j+1, 1);
							nw.sum +=count(mp1, lmp, mp2, rmp, 2);
							push(nw);
						}
						else if(pg1 == 2 && pg2 == 1){/*两个不同插头，且没形成回路*/
							upd(nw.state, j, 0), upd(nw.state, j+1, 0);
							upd(nw.state2, j, 1), upd(nw.state2, j+1, 1);
							nw.sum +=count(mp1, lmp, mp2, rmp, 2);
							push(nw);
						}
						else/*不允许闭合回路产生*/
							continue;
					}
				}
			}
			dp.swap(hsh);
			clearhsh();
		}
	}
}


int main(){
	scanf("%d%d%d", &n, &m, &K);
	if(n >= m){
		for(int i =0; i < n; ++i){
			char c =getchar();
			while(c != '#' && c != '.' && c != 'S' && c != 'T') c =getchar();
			for(int j =0; j < m; ++j){
				map[i][j] =c;
				c =getchar();
			}
		}
	}
	else{/*镜像做出来也是对的*/
		n ^=m ^=n ^=m;
		for(int j =0; j < m; ++j){
			char c =getchar();
			while(c != '#' && c != '.' && c != 'S' && c != 'T') c =getchar();
			for(int i =0; i < n; ++i){
				map[i][j] =c;
				c =getchar();
			}
		}
	}
	work();
	ll ans =0;
	for(int k =0; k < (int)dp.size(); ++k)
		if(dp[k].state == 0)
			if(dp[k].sum > ans)
				ans =dp[k].sum;
	printf("%lld", ans);
}
```

---

## 作者：Illusory_dimes (赞：5)

（思路大量参考 [DP 带师 UM 的博客](https://www.luogu.com.cn/blog/sflsrick/solution-p2337 "DP 带师 UM 的博客")）

一个能直接把人干劝退的插头 DP 。。

## Description

给定一个 $n * m$ 图，有一个起点和终点和一些空地，你需要在空地上放置**一些**障碍和**不超过 k 个**炮台（均不可经过），使得：

1. 起点和终点**仍**连通，可以存在多条路径；

2. 每经过一个点（起终也算），答案加上该点八连通的炮台数，最大化答案（注：多条路径算答案**最小**的一条）。

$\min(n,\ m) \leq 6,\ \max(n,\ m) \leq 20,\ 1\leq k \leq 15$

## Analysis

这个数据就很插头 DP 把，那就不去想其他的了。

那既然是要路径（不是回路），那自然一行的状态就直接 $0$ 表示无插头， $1$ 表示左插头， $2$ 表示右插头， $3$ 表示独立插头。

但是这样好像不太够，因为考虑到八连通下的贡献，需要知道附近几个点的状态，是路径，是炮台还是障碍。

所以需要一行状态形如（粉色那一列）：

![](https://cdn.luogu.com.cn/upload/image_hosting/z8ogrbh1.png)

对于打叉的点，记录的就是这些格子是路径，是炮台还是障碍（其他还有四个格子因为那个点还没遍历到，不考虑）。

（这两个都四进制就行，**注：之后插头的叫状态 $1$ ，格子种类的叫状态 $2$** ）

还不够，因为有炮台的限制，所以还要加一个指炮台数量（最多 $15$ 个所以二进制 $4$ 位就够了）。

## Solution

根据 **Analysis** 里说的，对于每个点，我们提取上一行状态 $1$ 的左格 $pr$ 和上格 $pd$ ，状态 $2$ 的左格 $l$ ，左上格 $ul$ ，上格 $u$ ，右上格 $ur$ 。

啊啊啊，** 大力分讨！！（推荐画图食用）

1. 如果左，上都是路径但是都不是插头，说明这个地方不能再有路径接上去了，要么放障碍，要么放炮台。（也就这种情况是和状态 $2$ 有关的）

2. 这个点本来就是障碍点，那也就只有左，上均没有插头的时候能转移。

3. 起点或终点（可以形象化成一个独立插头）

	①. 均没有插头
    
	直接新建独立插头。
    
	②. 无插头 + 左插头（或左 + 无）
    
	删除当前插头，并且把对应的右插头改成独立插头。
    
	③. 无插头 + 右插头（或右 + 无）
    
	删除当前插头，并且把对应的左插头改成独立插头。
    
	④. 无插头 + 独立插头（或独立 + 无）
    
	删除当前插头，没对应的插头，所以没了。

4. 空地（插头种类不定，跟着之前的走就行）

	①. 均没有插头
    
	可以选择放障碍，放炮台，或者开一个新路径。
    
	②. 仅有一个有插头
    
	跟着插头走就行了。
    
	③. 都是左插头
    
	删除这两个插头，并且把上格插头对应的右插头变成左插头。
    
	④. 都是右插头
    
	删除这两个插头，并且把左格插头对应的左插头变成右插头。
    
	⑤. 右插头 + 左插头
    
	删除这两个插头，并且把对应的两个插头左右不变。
    
	⑥. 左插头 + 右插头
    
	不合法，这样就是闭合回路。
    
	⑦. 左插头 + 独立插头（或独立 + 左）
    
	删除这两个插头，并且把对应的右插头变成独立插头。
    
	⑧. 右插头 + 独立插头（或独立 + 右）
    
	删除这两个插头，并且把对应的左插头变成独立插头。
    
	⑨. 独立插头 + 独立插头
    
	直接删除，没什么能伸展出去的。

------------

接下来，来想想怎么计算答案。

前面提到过，处理这个点的时候我们只知道周围四个点的状态。

那丢掉的四个点怎么办呢？在处理那四个点的时候自然就会算当前这个点了。正好，还不会算重。

因为相当于我们全部认定这个空地就是路径，那么他的贡献就是周围八个格子炮台数。转化一下也就是炮台的贡献就是周围八个格子空地数。

所以如果是炮台，就算已知的四个点里面空地数；

所以如果是空地，就算已知的四个点里面炮台数。

那不是还有多条路径算最小值的限制吗？

那你把答案最大的那条留下，剩下的直接全部用障碍填满，答案肯定不劣，况且这一定会在状态中出现，所以可以覆盖掉多条路径的影响。

那全部答案取合法里面的最大值就行了。

## Code

```cpp
/*

*/
#include <bits/stdc++.h>
//#define int long long
#define BT1 ((l == 1) + (ul == 1) + (u == 1) + (ur == 1))
#define BT3 ((l == 3) + (ul == 3) + (u == 3) + (ur == 3))
using namespace std;
typedef long long ll;
const int N = 24, zs = 299987;
int n, m, K, a[N][N], p, las, fst[zs + 10], tot[2], ans, inc[N], pl[N];
struct BIT {
	int c0, c1, c2;
	bool operator == (const BIT &it) const {
		return (c0 == it.c0) && (c1 == it.c1) && (c2 == it.c2);
	}
};
struct mdzz {int nxt, val[2]; BIT bt[2];} e[(1 << 24) + 10];
inline int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') w = -1; ch = getchar();}
	while (isdigit(ch)) {s = (s << 3) + (s << 1) + (ch ^ 48); ch = getchar();}
	return s * w;
}
inline void insert(int c0, int c1, int c2, int num) {
	int u = ((((1ll * c0 << 16) | c1) << 4) | c2) % zs + 1;
	for (int i = fst[u]; i; i = e[i].nxt) {
		if (e[i].bt[p] == (BIT) {c0, c1, c2}) {
			e[i].val[p] = max(e[i].val[p], num);
			return ;
		}
	}
	e[++tot[p]].nxt = fst[u];
	e[tot[p]].bt[p] = (BIT) {c0, c1, c2};
	e[tot[p]].val[p] = num;
	fst[u] = tot[p];
}
int pr, pd, l, ul, u, ur, c0, c1, c2;
inline int RT(int c0, int j, int pm) {
	int tot = 1, x = c0, lm;
	while (2333) {
		lm = (x >> pl[j]) & 3;
		if (lm == 1) ++tot; else if (lm == 2) --tot;
		if (!tot) return c0 ^ (lm << pl[j]) ^ (pm << pl[j]);
		++j;
	}
	return 0;
}
inline int LT(int c0, int j, int pm) {
	int tot = 1, x = c0, lm;
	while (2333) {
		lm = (x >> pl[j]) & 3;
		if (lm == 2) ++tot; else if (lm == 1) --tot;
		if (!tot) return c0 ^ (lm << pl[j]) ^ (pm << pl[j]);
		--j;
	}
	return 0;
}
inline void Plugdp(int i, int j, BIT bit, int num) {
	//这里的c0是已经把左和上去掉的残缺状态
	//这里的c1是已经把左上去掉的残缺状态
	if ((!pr && l == 1) || (!pd && u == 1)) {
		if (pr || pd) return ;
		insert(c0, c1, c2, num);
		if (c2 < K && a[i][j] == 1) {
			insert(c0, c1 ^ (3 << pl[j]), c2 + 1, num + BT1);
		}
	}
	else if (a[i][j] == 2) {
		if (!pr && !pd) insert(c0, c1, c2, num);
	}
	else if (a[i][j] == 1) {
		if (!pr && !pd) {
			insert(c0, c1, c2, num);
			if (c2 < K) insert(c0, c1 ^ (3 << pl[j]), c2 + 1, num + BT1);
			insert(c0 ^ inc[j - 1] ^ (inc[j] << 1), c1 ^ inc[j], c2, num + BT3);
		}
		else if (!pr || !pd) {
			insert(c0 ^ ((pd | pr) << pl[j - 1]), c1 ^ inc[j], c2, num + BT3);
			insert(c0 ^ ((pd | pr) << pl[j]), c1 ^ inc[j], c2, num + BT3);
		}
		else if (pr == 1 && pd == 1) insert(RT(c0, j - 1, 1), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 2 && pd == 2) insert(LT(c0, j - 1, 2), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 2 && pd == 1) insert(c0, c1 ^ inc[j], c2, num + BT3);
		else if (pr == 1 && pd == 2) ;
		else if (pr == 1 && pd == 3) insert(RT(c0, j - 1, 3), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 3 && pd == 1) insert(RT(c0, j - 1, 3), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 2 && pd == 3) insert(LT(c0, j - 1, 3), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 3 && pd == 2) insert(LT(c0, j - 1, 3), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 3 && pd == 3) insert(c0, c1 ^ inc[j], c2, num + BT3);
	}
	else if (a[i][j] == 3 || a[i][j] == 4) {
		if (!pr && !pd) {
			insert(c0 ^ (3 << pl[j - 1]), c1 ^ inc[j], c2, num + BT3);
			insert(c0 ^ (3 << pl[j]), c1 ^ inc[j], c2, num + BT3);
		}
		else if (!pr && pd == 1) insert(RT(c0, j - 1, 3), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 1 && !pd) insert(RT(c0, j - 1, 3), c1 ^ inc[j], c2, num + BT3);
		else if (!pr && pd == 2) insert(LT(c0, j - 1, 3), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 2 && !pd) insert(LT(c0, j - 1, 3), c1 ^ inc[j], c2, num + BT3);
		else if (pr == 3 && !pd) insert(c0, c1 ^ inc[j], c2, num + BT3);
		else if (!pr && pd == 3) insert(c0, c1 ^ inc[j], c2, num + BT3);
	}
}
inline void plug() {
	tot[p] = 1;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1, x; j <= tot[p]; ++j) {
			e[j].bt[p].c0 <<= 2;
			x = e[j].bt[p].c1;
			(e[j].bt[p].c1 ^= ((x >> pl[m + 1]) & 3) << pl[m + 1]) <<= 2;
		}
		for (int j = 1; j <= m; ++j) {
			memset(fst, 0, sizeof(fst));
			swap(las, p); tot[p] = 0;
			for (int k = 1, num; k <= tot[las]; ++k) {
				BIT bit = e[k].bt[las]; num = e[k].val[las];
				if (bit.c0 >= inc[m + 1]) continue;
				c0 = bit.c0; c1 = bit.c1; c2 = bit.c2;
				pr = (c0 >> pl[j - 1]) & 3; pd = (c0 >> pl[j]) & 3;
				l = (c1 >> pl[j - 1]) & 3; ul = (c1 >> pl[j]) & 3;
				u = (c1 >> pl[j + 1]) & 3; ur = (c1 >> pl[j + 2]) & 3;
				c0 ^= (pr << pl[j - 1]) ^ (pd << pl[j]); c1 ^= (ul << pl[j]);
				Plugdp(i, j, bit, num);
			}
		}
	}
}
inline int pdd(char ch) {
	if (ch == '.') return 1;
	if (ch == '#') return 2;
	if (ch == 'S') return 3;
	if (ch == 'T') return 4;
	if (ch == 'X') return 5;
	return 0;
}
int main() {
	n = read(); m = read(); K = read();
	inc[0] = 1; las = 1;
	for (int i = 1; i <= 14; ++i) {
		inc[i] = inc[i - 1] << 2, pl[i] = i << 1;
	}
	if (n >= m) {
		char ch;
		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= m; ++j) {
				ch = getchar();
				while (!(a[i][j] = pdd(ch))) ch = getchar();
			}
		}
	}
	else {
		swap(n, m);
		char ch;
		for (int j = 1; j <= m; ++j) {
			for (int i = 1; i <= n; ++i) {
				ch = getchar();
				while (!(a[i][j] = pdd(ch))) ch = getchar();
			}
		}
	}
	plug();
	for (int i = 1; i <= tot[p]; ++i) {
		if (!e[i].bt[p].c0) ans = max(ans, e[i].val[p]);
	}
	printf("%d\n", ans);
	return 0;
}
```

---


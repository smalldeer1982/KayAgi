# 【模板】k 短路 / [SDOI2010] 魔法猪学院

## 题目背景

注：对于 $k$ 短路问题，A\* 算法的最坏时间复杂度是 $O(nk \log n)$ 的。虽然 A\* 算法可以通过本题原版数据，但可以构造数据，使得 A\* 算法在原题的数据范围内无法通过。事实上，存在使用可持久化可并堆的算法可以做到在 $O((n+m) \log n + k \log k)$ 的时间复杂度解决 $k$ 短路问题。详情见 [OI-Wiki](https://oi-wiki.org/graph/kth-path/)。

## 题目描述

iPig 在假期来到了传说中的魔法猪学院，开始为期两个月的魔法猪训练。经过了一周理论知识和一周基本魔法的学习之后，iPig 对猪世界的世界本原有了很多的了解：众所周知，世界是由元素构成的；元素与元素之间可以互相转换；能量守恒$\ldots$。


iPig 今天就在进行一个麻烦的测验。iPig 在之前的学习中已经知道了很多种元素，并学会了可以转化这些元素的魔法，每种魔法需要消耗 iPig 一定的能量。作为 PKU 的顶尖学猪，让 iPig 用最少的能量完成从一种元素转换到另一种元素$\ldots$等等，iPig 的魔法导猪可没这么笨！这一次，他给 iPig 带来了很多 $1$ 号元素的样本，要求 iPig 使用学习过的魔法将它们一个个转化为 $N$ 号元素，为了增加难度，要求每份样本的转换过程都不相同。这个看似困难的任务实际上对 iPig 并没有挑战性，因为，他有坚实的后盾$\ldots$现在的你呀！


注意，两个元素之间的转化可能有多种魔法，转化是单向的。转化的过程中，可以转化到一个元素（包括开始元素）多次，但是一但转化到目标元素，则一份样本的转化过程结束。iPig 的总能量是有限的，所以最多能够转换的样本数一定是一个有限数。具体请参看样例。

## 说明/提示

有意义的转换方式共 $4$ 种：

$1\to 4$，消耗能量 $1.5$。

$1\to 2\to 1\to 4$，消耗能量 $4.5$。

$1\to3\to4$，消耗能量 $4.5$。

$1\to2\to3\to4$，消耗能量 $4.5$。

显然最多只能完成其中的 $3$ 种转换方式（选第一种方式，后三种方式任选两个），即最多可以转换 $3$ 份样本。

如果将 $E=14.9$ 改为 $E=15$，则可以完成以上全部方式，答案变为 $4$。

### 数据规模

占总分不小于 $10\%$ 的数据满足 $N \leq 6,M \leq 15$。

占总分不小于 $20\%$ 的数据满足 $N \leq 100,M \leq 300,E\leq100$ 且 $E$ 和所有的 $e_i$ 均为整数（可以直接作为整型数字读入）。

所有数据满足 $2 \leq N \leq 5000$，$1 \leq M \leq 200000$，$1 \leq E \leq 10 ^ 7$，$1 \leq ei\leq E$，$E$ 和所有的 $e_i$ 为实数。

### 数据更新日志

- 2010/xx/xx：原版数据；
- 2018/03/02：@[kczno1](/user/9168) 添加了 [一组数据](/discuss/35616)；
- 2018/04/20：@[X_o_r](/user/25188) 添加了 [一组数据](/discuss/40205)；
- 2021/01/08：@[LeavingZ](/user/215697) 添加了 [两组数据](/discuss/291028)。

## 样例 #1

### 输入

```
4 6 14.9
1 2 1.5
2 1 1.5
1 3 3
2 3 1.5
3 4 1.5
1 4 1.5
```

### 输出

```
3```

# 题解

## 作者：约瑟夫用脑玩 (赞：27)

## 前言

鉴于此题有更优秀复杂度的可并堆做法但未被题解给出，故在此补充一下。

本文重点在于可并堆如何优化的细节上，一般的可持久化可并堆请参考其他题解。

## 正文

分部分来考虑复杂度：

1. 建反图跑最短路树：

   如果你使用了普通堆优化的 Dijkstra，恭喜你，你的复杂度已经为 $O(m\log{m})$，没必要进行后面的优化了。
   
   于是我们需要使用广为人知~~且不难~~科技：斐波那契堆优化 Dijkstra，可以轻松做到 $O(m+n\log{n})$。[戳我看蒟蒻的Fib堆优化Dij](https://www.luogu.com.cn/paste/hsur4u5x)
   
1. 可持久化可并堆

   一般的可持久化可并堆将 $m$ 条边都插入了进去，复杂度显然 $O(m\log{m})$，看似没有优化的空间。
   
   但我们发现，建可持久化可并堆时，对于每个点，每次会将自己连出去的所有非树边并入可并堆，我们将最短路树上的 $n$ 个点用 $m\log{m}$ 的代价并起来显然血亏。
   
   如果我们将每个点的边提前建一个堆，每次只丢一个堆顶进去不就只有 $n\log{n}$ 了嘛。只要我们动用一点小小的黑科技：$O(n)$ 建大小为 $n$ 的二叉堆，在这里我们就可以做到 $O(m+n\log{n})$。
   
   先来看 [$O(n)$ 建堆](https://www.luogu.com.cn/paste/vh8z0g2i)，简单来说，原理就是从下往上将每个点不停向下换，冷静分析[复杂度](https://www.luogu.com.cn/paste/4degkoit)可以发现是 $O(n)$ 的。
   
   再说可持久化堆，其实是可持久化可并堆套堆(形象吧)，因为它外层是可持久化可并堆，内层还有一个堆。它们以堆顶相关联，故堆顶既是外层堆节点，又是内层堆堆顶。
   
   原来堆的意义是一个节点及后继节点的所有非树边，而现在外层堆是一个节点及后继节点的非树边堆顶，一个内层堆的节点及堆顶都代表一条边。
   
   这里实际上利用了每个点非树出边都是相同的性质提前建堆进行了优化。
   
1. K 短路：
   
   原来我们选择堆中一个节点的儿子，代表用一个更大的后继非树边(名词可能不严谨)替代它。
   
   而现在我们可以选择从一个堆顶(也即外层节点)往内层堆的儿子里走，代表用这个节点连出的更大非树边，或是选择外层堆的儿子，代表用更大的后继节点的边来代替。
   
   如果不是替换而是加新边就和一般做法一样丢入下一个点的堆顶即可，注意这里是外层堆顶。
   
   时间仍为 $O(k\log{k})$，因为每次出堆必定代表一条路，而入堆的只是其二叉堆的儿子，可以忽略不大的常数。
   
故我们整体上可以实现 $O(n\log{n}+m+k\log{k})$ 的复杂度通过此题，相较于一般算法的 $O(n\log{n}+m\log{m}+k\log{k})$ 实现了最窄瓶颈处的优化，在此题的数据范围中可以显然看出优化之大。

[核心代码](https://www.luogu.com.cn/paste/godj3yua)

Upd:修复了一点小问题(?)

Upd:补上了Fib堆优化Dij的大坑。。。

---

## 作者：small_lemon_qwq (赞：24)

[$\colorbox{orange}{\color{white}\texttt{题目传送门}}$](https://www.luogu.com.cn/problem/P2483)

下次管理撤我这篇题解能看清楚一点吗（

**不保证本篇题解不会被 hack**

A* 不加可和并堆优化也是可以水过的哦。

首先我们可以写一个不加任何剪枝与卡常的代码（为了缩短文章篇幅，只给出关键代码）：

```cpp
dij(n);//tmp[i] 表示 i 到 n 的最短路
pq<pair<double,int>>q;//pq是小根堆
q.push({tmp[1],1});
while(q.size()){
  int u=q.top().second;
  double t=q.top().first;
  q.pop();
  v[u]++;
  if(t>e)continue;
  if(u==n){
    ans++;
    e-=t;
    continue;
  }
  for(auto[v,w]:g[u]){
    q.push({t+w+tmp[v]-tmp[u],v});
  }
}
```

然后你就会发现有两个点 MLE 了（#1 & #4），经过测试，dij 只使用了 $11$ MB，这也就意味着 A* 用了至少 $117$ MB，经过估算，队列中大约存储了 $6.3\times10^6$ 个元素，显然，队列是使用空间最大的变量。

为了使队列元素个数变少，我们需要删除不必要的元素，也就是对队列长度进行限制。

当在判断元素 $x$ 是否可以删除时，只要满足比队列中 $x$ 大的树的和 $sum>E$，那么 $E$ 一定会在 $x$ 出队之前就被减为负数，一定不会计算到 $x$ 出队，所以这个时候 $x$ 在不在队列里就不重要了。

也就是说，当队列中元素总和大于 $E$ 时，可以将队列中最大的元素删掉。

具体来讲就是：

```cpp
multiset<pair<double,int>>q;//注意这里为了删除最大元素将优先队列换成了 multiset
q.insert({tmp[1],1});
double sum=tmp[1];
while(!q.empty()){
  int u=q.begin()->second;
  double t=q.begin()->first;
  q.erase(q.begin());
  if(t>e)break;
  sum-=t;
  if(u==n){
    ans++;
    e-=t;
    continue;
  }
  for(auto[v,w]:g[u]){
    double tmp2=t+w+tmp[v]-tmp[u];
    q.insert({tmp2,v});
    sum+=tmp2;
    if(sum>e){
      auto tmp=q.end();tmp--;
      sum-=tmp->first;
      q.erase(tmp);//删除最大元素
    }
  }
}
```

这样，我们就限制了队列长度不会太大，于是我们解锁了新的测试信息：TLE（#1）。

由于我实在是太菜了，我下载了这个数据点，发现这个图的结构如下：
+ $n=5000$。
+ $1$ 到 $5000$ 有一条单向边。
+ $1$ 到 $i(i\in\Z\cap[2,n-1])$ 有一条双向边。
+ $E=10000000$

不难发现，对于编号在 $2$ 到 $n-1$ 之间的点，似乎这些点好像可以合并成一个点，如果这样的话那就只剩下 $3$ 个点了，不管你怎么搜都不会超时。

我们必须分析清楚，什么时候可以合并两个点。

我画了如下一个抽象的图来解释：

![](https://img.z4a.net/images/2025/02/02/c4e954e46e10497d207e65c819afeac7.png)

这个图表述的含义是：
+ 有 $1$ 到 $x$ 的路径
+ 连向点 $i,j$ 的只有 $x$，且 $x$ 到 $i$ 的边权等于到 $j$ 的。
+ $i,j$ 只连向 $y$，且 $i$ 到 $y$ 的边权等于 $j$ 到 $y$ 的。
+ 有 $y$ 到 $n$ 的路径

如果满足这些条件，那么 $i$ 和 $j$ 就可以看做是同一个点，显然可以合并，减少计算量。

合并部分的代码：

```cpp
for(int i=2;i<n;i++){
  if(gt(i)!=i)continue;
  for(int j=i+1;j<n;j++){//n^2 不会 TLE，所以直接无脑暴力
    if(gt(j)!=j)continue;//gt 是并查集找祖先的函数
    if(g[i].size()==1&&g2[i].size()==1&&g[i]==g[j]&&g2[i]==g2[j]){//g2 是反图
      merge(i,j);//并查集合并
    }
  }
}
for(int i=1;i<=n;i++){
  if(f[i]==i){
    cnt[i]=sz[i];//sz[i] 是联通块大小，cnt 表示这个点是多少个点1合并得到的
  }
}
```

合并之后，只需要把 $u$ 更新一次到 $v$ 变为更新 `cnt[v]` 次到 $v$ 就可以了，但是（可能）会 TLE，所以考虑只在队列中插入一次 $v$，但是记录这个 $v$ 相当于插入了 `cnt[v]` 次。

具体看代码（这个剪枝可能有一点点小问题，因为几乎只有 #1 用了这个剪枝）：
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>
using pq=priority_queue<T,vector<T>,greater<T>>;
int n,m,v[5005],ans,cnt[5005];
double tmp[5005],e;
vector<pair<int,double>>g[5005],g2[5005];
void dij(int x){
	for(int i=1;i<=n;i++)tmp[i]=1e18;
	tmp[x]=0;
	pq<pair<double,int>>q;
	q.push({0,x});
	while(q.size()){
		int u=q.top().second;
		double t=q.top().first;
		q.pop();
		if(v[u])continue;
		v[u]=1;
		for(auto[v,w]:g2[u]){
			if(tmp[v]>t+w){
				tmp[v]=t+w;
				q.push({tmp[v],v});
			}
		}
	}
}
namespace aaaa{
	int f[5005],n,sz[5005];
	void init(){
		n=::n;
		for(int i=1;i<=n;i++)f[i]=i,sz[i]=1;
	}
	int gt(int x){if(x==f[x])return f[x];return f[x]=gt(f[x]);}
	void merge(int x,int y){
		f[x]=y;
		sz[y]+=sz[x];
		sz[x]=0;
	}
}
signed main(){
//	freopen("P2483_1.in","r",stdin);
	cin>>n>>m>>e;
	aaaa::init();
	while(m--){
		int u,v;
		double w;
		cin>>u>>v>>w;
		g[u].push_back({v,w});
		g2[v].push_back({u,w});
	}
	dij(n);
	for(int i=2;i<n;i++){
		if(aaaa::gt(i)!=i)continue;
		for(int j=i+1;j<n;j++){
			if(aaaa::gt(j)!=j)continue;
			if(g[i].size()==1&&g2[i].size()==1&&g[i]==g[j]&&g2[i]==g2[j]){
				aaaa::merge(i,j);
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(aaaa::f[i]==i){
			cnt[i]=aaaa::sz[i];
		}
	}
	multiset<pair<double,pair<int,int>>>q;
	q.insert({tmp[1],{1,cnt[1]}});
	double sum=tmp[1];
	while(!q.empty()){
		pair<double,pair<int,int>>p=*q.begin();
		int u=p.second.first;
		int times=p.second.second;
		double t=p.first;
		q.erase(q.begin());
		if(t>e)break;
		sum-=t*times;
		if(u==n){
			ans+=min<int>(times,e/t);
			e-=t*times;
			e=max<double>(e,0);
			continue;
		}
		for(auto[v,w]:g[u]){
			if(cnt[v]==0)continue;
			double tmp2=t+w+tmp[v]-tmp[u];
			if(tmp2>e)continue;
			q.insert({tmp2,{v,times*cnt[v]}});
			sum+=tmp2*times*cnt[v];
			if(sum>e){
				auto tmp=q.end();tmp--;
				pair<double,pair<int,int>>p=*tmp;
				int t=p.second.second;
				double x=p.first;
				int u=p.second.first;
				sum-=x*t;
				q.erase(tmp);
				int k=(e-sum)/x;
				if(k)q.insert({x,{u,k}}),sum+=k*x;
			}//注意这一部分常数稍微大一点就会 TLE 80 分，因为进行了大量的乘除运算
		}
	}
	cout<<ans;
	return 0;
}
```

最后是跑了 $1.97$ 秒，空间用了 $15.85$ MB。

~~终于，我们成功的让代码长度多了一倍。~~

注意到我并没有特判。

---

如果你认为我在特判，那么我们可以加强一下这个剪枝。

![](https://img.z4a.net/images/2025/02/05/a6e9f2854ad488212ea9f458ebc369b6.png)

如果是这种情况，那么 $(i_1,j_1)$，$(i_2,j_2)\cdots(i_k,j_k)$，均可以合并。

判断也很好做，先确定 $x$，再从 $x$ 的出边开始 dfs，只要出度为 $1$ 就继续搜，最终搜到 $y$，判断两条路径对应边权是否相等即可。

---

还有个优化：如果 `multiset` 中有元素 $\{i,j,k\}$ 和 $\{i,j,m\}$ 那么我们可以合并为 $\{i,j,k+m\}$。

只需要判断插入的位置前一个和后一个是否可以合并就可以了。

---

## 作者：Deep_Kevin (赞：16)

题解区怎么被A*占领了啊

发一发比较有道理的可持久化可并堆做法

我们先求出反向的以t为根的最短路树。那么一条从s到t的路径就会经过若干非树边和树边，我们可以用非树边序列来表示一条路径。

我们用优先队列来存储当前拓展出的非树边序列，每次选出一条最小的，然后扩展。

扩展的方式是两种：第一种是我们在序列后加上一条边，第二种是我们把序列最后一个给换掉。

对于第一种，我们对于每个点维护一个从x到t的树边所连出去的非树边的堆，(u→v,w)的权值是−dis[u]+w+dis[v]，即选择这条边所需要多花费的代价。这个可以使用可持久化可并堆实现。

对于第二种，我们是要把将这个方案放入优先队列时的可并堆保留下来，去掉之前选择元素后的最小值，也就是把根删除,可以直接把根的两个儿子merge起来作为新的堆;

本菜鸡调了近乎2h才发现最短路挂了

应该每次找最小的点出来松弛,而不是每次松弛找最小值丢就队列

希望能各位能不要像我这样石乐志吧

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=5010,M=200010;
struct edge{
	int x,y,nex;
	double c;
	bool op;
}now[2][M];
struct node{
	int ls,rs,dis,y;
	double t;
}tr[10000010];
struct point{
	int num;
	double sum;
	bool operator<(const point q)const{
		return sum>q.sum;
	}
}X,Y;
priority_queue<point> f;
edge*s;
int fir[2][N],l[2],n,m,T,rt[5005010],ans,dfn;
double dis[N],E;
bool tf[N],we[N];
int*first;
const double eps=1e-8;

void ins(int x,int y,double c,int&len){s[++len]=(edge){x,y,first[x],c,false};first[x]=len;}
void new_node(double c,int y){tr[++T].dis=1;tr[T].t=c;tr[T].y=y;}

int merge(int x,int y){
	if(!x || !y) return x+y;
	if(tr[x].t>=tr[y].t-eps) swap(x,y);
	int p=++T;tr[p]=tr[x];
	tr[p].rs=merge(tr[p].rs,y);
	if(tr[tr[p].rs].dis>tr[tr[p].ls].dis) swap(tr[p].ls,tr[p].rs);
	tr[p].dis=tr[tr[p].rs].dis+1;
	return p;
}

void dfs(int x){
	we[x]=true;
	if(x!=n) for(int i=fir[0][x];i!=0;i=now[0][i].nex) if(!now[0][i].op) 
		new_node(now[0][i].c-dis[x]+dis[now[0][i].y],now[0][i].y),rt[x]=merge(rt[x],T);
	for(int i=first[x];i!=0;i=s[i].nex) if(!we[s[i].y] && dis[s[i].y]==dis[x]+s[i].c)
		now[0][i].op=true,rt[s[i].y]=rt[x],dfs(s[i].y);
}

void Dijkstra(){
	for(int i=1;i<n;i++) dis[i]=2000000000000.0;
	dis[n]=0;
	first=fir[1],s=now[1];
	while(1){
		int x=0,pos=0;
		double mmin=2000000000000.0;
		for(int i=1;i<=n;i++) if(!tf[i] && dis[i]<mmin) mmin=dis[i],x=i;
		if(!x) break;tf[x]=true;
		for(int i=first[x];i!=0;i=s[i].nex) if(!tf[s[i].y] && dis[x]+s[i].c<dis[s[i].y])
			dis[s[i].y]=dis[x]+s[i].c;
	}
	dfs(n);
}

void solve(){
	f.push((point){0,0});tr[0].y=1;
	while(!f.empty()){
		X=f.top();f.pop();
		if(E<dis[1]+X.sum) break;
		ans++;E-=dis[1]+X.sum;Y=X;
		if(tr[rt[X.num]].y!=n) X.sum+=tr[rt[X.num=tr[rt[X.num]].y]].t,f.push(X);
		if(tr[rt[Y.num]].ls || tr[rt[Y.num]].rs){
			Y.sum-=tr[rt[Y.num]].t;rt[++dfn]=merge(tr[rt[Y.num]].ls,tr[rt[Y.num]].rs);
			Y.sum+=tr[rt[Y.num=dfn]].t;f.push(Y);
		}
	}
	printf("%d\n",ans);
}

int main(){
	scanf("%d %d %lf",&n,&m,&E);
	int x,y;double c;
	for(int i=1;i<=m;i++){
		scanf("%d %d %lf",&x,&y,&c);
		s=now[0],first=fir[0],ins(x,y,c,l[0]);
		s=now[1],first=fir[1],ins(y,x,c,l[1]);
	}
	Dijkstra();dfn=n;solve();
}
```


---

## 作者：EnofTaiPeople (赞：11)

就是不用左偏树！就是不用优先队列！这是一篇没有左偏树，只使用了 $\text{vector}$ 的题解！

先建出以 $n$ 为根在反图上的最短路径树，由于题目保证有解，所以最短路径树上的最短路路可以是的一个答案，考虑如何生成下一个答案。

记 $u$ 到 $n$ 的距离为 $dis_u$，对于一条边 $(u,v,w)$，使用它之后会导致路径的长度增加 $w-dis_u+dis_v$，对于每一个节点维护它们到 $n$ 在最短路径树上所有节点出边中的非树边对路径长度的影响值，可以用堆来维护。

每次找出当前总影响值最小的，记其为 $(w,ed)$，其中 $w$ 为影响值，$ed$，为该边集的最后一条边在堆上的节点。我们可以用它拓展到下一条路径，即将 $ed$ 替换成在堆上的后继（这里将左右儿子都考虑以下就可以），或者找到 $ed$ 对应边的终点，将它所对应的堆的根节点加入。

由于堆要支持复制，所以这里需要采用可持久化可并堆来维护。

但是，可并堆可不只有左偏树！这里使用的是高效（期望 $O(\log_2n)$，空间常数小（不需要记录 $dis$）)的可持久化可并堆，随机堆：
```cpp
void mg(int &x,int y){
        static mt19937 rg(1919810u^time(0));
        if(!x||!y){x|=y;return;}
        if(cmp(y,x))x^=y^=x^=y;
        cp(x),mg(rg()&1?l[x]:r[x],y);
    }
```
以上代码解释了可持久化随机堆的合并过程，其中 `cp` 函数表示复制节点，是可持久化的常用操作。

其实不用左偏树的原因是线性建堆时 $dis$ 不好处理。

在跑最短路时，由于本题 $m->\sqrt n$，所以我们可以使用修改 $O(1)$，查询 $O\sqrt n$ 的数据结构，分块。

最后查找所需要的优先队列，我使用了插入 $O(1)$ 的二项堆。

总复杂度：时间：$O(n\sqrt{n}+m+k\log_2k)$，空间：$O(n\log_2m+m+k)$。

最后上代码：
```cpp
#include<cstdio>
#include<vector>
using std::vector;
using ll=long long;
const int N=5005,M=2e5+5,T=2222222,P=5e5+5;
const ll INf=2e18;
static inline char gc(){
    static char buf[M+5];
    static int it,ed;
    if(it==ed)ed=(it=0)+fread(buf,1,M,stdin);
    return it==ed?EOF:buf[it++];
}
static inline int read(int x){
    static char c;for(c=gc();c<48;c=gc());
    while(c>47)x=x*10+(48^c),c=gc();return x;
}
inline void swap(int &x,int &y){
    static int z;
    z=x,x=y,y=z;
}
static inline ll read(){
    static ll x,f;static char c;
    for(c=gc();c<48;c=gc());
    for(x=0;c>47;x=x*10+(48^c),c=gc());
    x*=10000000;
    if(c=='.')for(f=1000000,c=gc();c>47;x+=f*(c^48),c=gc(),f/=10);
    return x;
}
vector<int>lk[N],bl[105];
int n,m,wd[M],pr[N],mn[105],ans;
ll E,w[M],dis[N];
struct G{int u,v;ll w;}g[M];
int l[P],r[P],cnt,d[P],ds[P];
inline bool cmp(const int &x,const int &y){
    return g[d[x]].w<g[d[y]].w;
}
inline void cp(int &x){
    l[++cnt]=l[x],r[cnt]=r[x];
    d[cnt]=d[x];x=cnt;
}
void mg(int &x,int y){
    if(!x||!y){x|=y;return;}
    if(cmp(y,x))x^=y^=x^=y;
    cp(x),mg(r[x],y);
    if(ds[r[x]]>ds[l[x]])swap(l[x],r[x]);
    ds[x]=ds[r[x]]+1;
}
struct LT{
    int rt;
    inline void build(vector<int>&D){
        if(D.empty())return;
        int sz=D.size(),i,lc,rc,x,mx;
        for(i=1;i<=sz;++i)d[cnt+i]=D[i-1];
        for(i=1;i<=sz;++i){
            lc=i<<1,rc=lc|1;
            if(lc>sz)break;
            else l[cnt+i]=cnt+lc;
            if(rc>sz)break;
            else r[cnt+i]=cnt+rc;
        }
        for(i=sz>>1;i;--i){
            x=cnt+i,lc=l[x],rc=r[x];
            ds[x]=ds[rc]+1;
            while((lc&&cmp(lc,x))||(rc&&cmp(rc,x))){
                if(rc&&cmp(rc,lc)){
                    swap(d[x],d[rc]),x=rc;
                }else{
                    swap(d[x],d[lc]),x=lc;
                }lc=l[x],rc=r[x];
            }
        }rt=cnt+1,cnt+=sz;
    }
    inline void join(LT &y){mg(rt,y.rt);}
}tr[N];
struct Tp{
    ll w;int ed;
    inline bool operator<(const Tp &y)
    const{return w<y.w;}
}dt[T];
vector<int>hp[25];
vector<int>::iterator it;
int sg[T],hs[T],ed[T],to[T],tot,top,stk[T],tp;
inline void push(const Tp data){
    int x=tp?stk[tp--]:++tot;
    dt[x]=data,hp[0].push_back(x);
    if(dt[x]<dt[top])top=x;return;
}
inline void Merge(int x,int y){
    if(dt[y]<dt[x])x^=y^=x^=y;
    if(ed[x])to[ed[x]]=y,ed[x]=y;
    else hs[x]=ed[x]=y;
    hp[++sg[x]].push_back(x);
}
inline void Init(){
    dt[0]={INf,0};
    if(tr[1].rt)push({g[d[tr[1].rt]].w,tr[1].rt});
    return;
}
inline ll pop(){
    int i,x=dt[top].ed;ll res=dt[top].w;
    if(l[x])push({res+g[d[l[x]]].w-g[d[x]].w,l[x]});
    if(r[x])push({res+g[d[r[x]]].w-g[d[x]].w,r[x]});
    if(x=tr[g[d[x]].v].rt)push({res+g[d[x]].w,x});
    for(it=hp[sg[top]].begin();*it!=top;++it);
    hp[sg[top]].erase(it),x=hs[top];
    stk[++tp]=top,hs[top]=ed[top]=to[top]=sg[top]=0;
    for(top=0;x;i=to[x],to[x]=0,x=i)
        hp[sg[x]].push_back(x);
    for(i=0;i<24;++i){
        while(hp[i].size()>1){
            x=hp[i].back(),hp[i].pop_back();
            Merge(x,hp[i].back()),hp[i].pop_back();
        }
        if(hp[i].size()&&dt[hp[i][0]]<dt[top])top=hp[i][0];
    }
    return res;
}
int main(){
    n=read(0),m=read(0),E=read();
    int i,q=n+1,k=n/q,x,y,T,l,r;
    for(i=1;i<=m;++i){
        g[i]={read(0),read(0),read()};
        wd[i]=g[i].u,w[i]=g[i].w;
        lk[g[i].v].push_back(i);
    }
    for(i=1;i<=n;++i)
        dis[i]=INf,bl[i/q].push_back(i);
    dis[mn[k]=T=n]=0,dis[0]=INf;
    while(--T){
        for(x=0,i=1;i<=k;++i)
            if(dis[mn[i]]<dis[mn[x]])x=i;
        if(mn[x])y=mn[x],mn[x]=0;
        else break;
        bl[x].erase(lower_bound(bl[x].begin(),bl[x].end(),y));
        for(int p:bl[x])
            if(dis[p]<dis[mn[x]])mn[x]=p;x=y;
        for(int i:lk[x])
            if(dis[y=wd[i]]>dis[x]+w[i]){
                dis[y]=dis[x]+w[i],pr[y]=i;
                if(dis[y]<dis[mn[y/q]])mn[y/q]=y;
            }
    }
    for(x=1;x<=n;++x)lk[x].clear();
    for(i=1;i<=m;++i){
        g[i].w-=dis[g[i].u]-dis[g[i].v];
        if(pr[g[i].u]!=i)lk[g[i].u].push_back(i);
    }
    for(x=1;x<n;++x){
        tr[x].build(lk[x]);
        lk[x].clear();
    }lk[n].clear();
    for(x=1;x<=n;++x)
        if(pr[x])lk[g[pr[x]].v].push_back(x);
    pr[l=r=1]=n;
    while(l<=r){
        x=pr[l++];
        for(int y:lk[x])
            tr[pr[++r]=y].join(tr[x]);
    }
    if(E>=dis[1]){
        E-=dis[1],ans=1;
        for(Init();top;++ans)
            if((E-=pop()+dis[1])<0)break;
    }
    printf("%d\n",ans);
    return 0;
}
```
关于 `typedef long long db;` 的解释：我之前做这道题一直过不了后两个 Hack 数据，最后才发现被卡精度了，就强制转换成了 `long long`。

---

## 作者：Seauy (赞：10)

这里稍微补充一些其他题解没写到的

# 一. 题目分析

## 1. 关于 k

首先根据贪心原理，我们肯定选出若干条最短的不同的路径，设这个数为 $k$，可以先来考虑一下 $k$ 的上界。如果有 $m$ 条 $1\to n$ 权值为 $1$ 的边，此时 $k=2\times 10^5$；但是如果将 $\frac{m}{2}$ 条边从 $1$ 连到 $2$，剩下 $\frac{m}{2}$ 条边从 $2$ 连到 $n$，这样我们获得了 $\frac{m^2}{4}$ 条 $1 \to n$ 的路径，且长度都为 $2$，$E$ 的最大值又为 $10^7$ 所以 $k$ 可以达到 $5\times 10^6$。

~~也就是说理论上存在一种构造方法卡掉 $O((n+m)\log n +k\log k)$ 的可持续化可并堆做法，鉴于这样好像会让这题不可做所以数据中 $k$ 最大在 $2\times 10^5$ 级别。~~

## 2. 做法

然后我们要获取前 $k$ 短的路径长度。我们先建反图，跑出以 $n$ 为源点的最短路生成树，称在树上的边为树边，那不在树上的边为非树边。

这样 $1 \to n$ 的路径上肯定有些边是树边，有些是非树边。若按路径上经过边的顺序获取非树边序列，后一条边的起点肯定是前一条边终点的祖先（因为树边都是指向父亲的）。

我们可以考虑获得一个 $1\to n$ 的前 $k$ 短的路径，然后把这个路径修改成尽可能短的更长的路径。实际上可以把一条路径看成一个状态，然后通过修改他拓展出去，使得能够不重复且不遗漏地遍历所有前 $k$ 短路，类似于优先队列 BFS。

这样的遍历方法是存在的，比如从优先队列队头获取一个长度最小的路径 $l$，设非树边序列为 $S$，倒数第二条边为 $p$，最后一条边为 $q$：

1. 将 $q$ 替换成起点为 $t_p$ 祖先的另外一条边

2. 在 $S$ 最后加入起点为 $t_q$ 祖先一条边

那怎样使得 $l$ 长度的变化量尽可能小呢。$l$ 的长度可以表达为

$$ \sum_{i\in S} e_i-d_{s_i}+d_{t_i} $$

其中 $d_i$ 为结点 $i$ 到 $n$ 的最短路长度。那我们可以把一条非树边的贡献记为 $v_i=e_i-d_{s_i}+d_{t_i}$，替换操作需要找出最小的 $v$ 大于等于 $v_q$ 的边；追加操作需要找出 $v$ 最小的边。

设“起点为 $i$ 的祖先的非树边集合”为 $U_i$，那么替换操作就是以 $v$ 为关键字找 $q$ 在 $U_{t_p}$ 的后继；追加操作是找出 $U_{t_q}$ 的最小元素。由于暴力建出所有结点的 $U$ 复杂度是 $O(nm)$，我们需要快速表达出这些集合。

## 3. 可持续化数据结构

$U$ 有递推关系，$U_i$ 可以在 $U_{fa_i}$ 的基础上插入所有以 $i$ 为起点的非树边。鉴于集合需要查后继，可以选择从大到小插入非树边建立可持续化堆，这样后继就是根的左右儿子；或者直接一点，使用可持续化线段树/平衡树。

可持续化堆的建树复杂度是 $O(m\log m+n)$ 的，求 $k$ 短路是 $O(k \log k)$ 的（查后继 $O(1)$）。

可持续化线段树/平衡树的建树复杂度是 $O(m\log m+n)$ 的，求 $k$ 短路 $O(k(\log k +\log m))$。

那为啥要用可并堆呢，因为 $U$ 的建立也可以看作将“以 $i$ 为起点的非树边”集合与 $U_{fa_i}$ 合并的过程，建堆能线性，合并 $O(\log m)$，于是建树被优化为 $O(m+n\log m)$。不过跑最短路还有瓶颈，可以用斐波那契堆优化成 $O(m+ n\log n)$。

可持续化需要可并堆不是均摊数据结构（在这题里复杂度会退化成跟普通堆一样），但是俞鼎力的课件里似乎把左偏树归为了均摊数据结构，实际上非也。

以上做法空间都是 $O(n+k+m\log m)$。

## 4. 数据

样例说明中以经过结点的顺序表达路径，实际上在测试数据中是有重边的。

# 二. 代码

这里给出一个可持续化线段树，跑得不是很快。

```cpp
#include<bits/stdc++.h>
#define Lson(x) node[x].Son[0]
#define Rson(x) node[x].Son[1]
using namespace std;

typedef long long ll;

const int MAXN=5e3,MAXM=2e5,LOGM=18;
const double MAXV=1e15;

struct DE
{
	int x,y;
	double val;
	void Scan() {scanf("%d %d %lf",&x,&y,&val);}
	void Print() {printf("%d %d %.2lf\n",x,y,val);}
}E[MAXM+5];

bool cmp(DE a,DE b) {return a.val<b.val;}

struct Emsg
{
	int nxt,Enum;
	double val;
};

int n,m,ans;double ALL;
vector<Emsg> inv[MAXN+5];

int fa[MAXN+5];
priority_queue< pair<double,int> > Q;
bool V[MAXN+5],Edel[MAXM+5];
int delE[MAXN+5];
double Dis[MAXN+5];
void Dijkstra()
{
	for(int i=1;i<=n;i++) Dis[i]=MAXV;
	Dis[n]=0;
	Q.push(make_pair(0,n));
	for(int now,rear;!Q.empty();)
	{
		now=Q.top().second,Q.pop();
		if(V[now]) continue;
		V[now]=1;
		for(int i=0;i<inv[now].size();i++)
		{
			rear=inv[now][i].nxt;
			double cost=inv[now][i].val;
			if(Dis[rear]>Dis[now]+cost)
			{
				Dis[rear]=Dis[now]+cost;
				delE[rear]=inv[now][i].Enum;
				fa[rear]=now;
				Q.push(make_pair(-Dis[rear],rear));
			}
		}
	}
	for(int i=1;i<=n;i++) Edel[delE[i]]=1;
}

struct msg
{
	double len;
	int loc,Enum,rnk;//倒数第二条边的终点，倒数第一条边和排名 
	bool operator > (const msg &a) const {return len<a.len;}
	bool operator < (const msg &a) const {return len>a.len;}
};priority_queue<msg> p;

struct SegTree
{
	int Son[2],Size;
}node[MAXM*LOGM*2+5];int Tail,root[MAXN+5];

void New(int now,bool t)
{
	if(node[now].Son[t]) return;
	node[now].Son[t]=++Tail;
}

void PushUp(int now) {node[now].Size=node[Lson(now)].Size+node[Rson(now)].Size;}

void Insert(int a,int b,int L,int R,int x)//插入边 x
{
	if(L==R) {node[b].Size=1;return;}
	int mid=(L+R)>>1;
	if(x<=mid)
	{
		New(b,0),Rson(b)=Rson(a);
		Insert(Lson(a),Lson(b),L,mid,x);
	}
	else
	{
		Lson(b)=Lson(a),New(b,1);
		Insert(Rson(a),Rson(b),mid+1,R,x);
	}
	PushUp(b);
}

int Ask(int now,int L,int R,int k)//排名为 k
{
	if(L==R) return L;
	int mid=(L+R)>>1;
	if(k<=node[Lson(now)].Size) return Ask(Lson(now),L,mid,k);
	return Ask(Rson(now),mid+1,R,k-node[Lson(now)].Size);
}

vector<int> nxt[MAXN+5],S[MAXN+5];//出边集合 
void Build(int now)
{
	root[now]=root[fa[now]];
	for(int i=0;i<S[now].size();i++)
	{
		int cnt=++Tail;
		Insert(root[now],cnt,1,m,S[now][i]);
		root[now]=cnt;
	}
	for(int i=0;i<nxt[now].size();i++) Build(nxt[now][i]);
}

int main()
{
	//freopen("P2483_1.in","r",stdin);
	//freopen("mine.txt","w",stdout);
	scanf("%d %d %lf",&n,&m,&ALL);
	for(int i=1;i<=m;i++)
	{
		E[i].Scan();
		inv[E[i].y].push_back(Emsg{E[i].x,i,E[i].val});
	}
	Dijkstra();
	//printf("Dis:");for(int i=1;i<=n;i++) printf(" %.2lf",Dis[i]);printf("\n");
	//printf("fa:");for(int i=1;i<=n;i++) printf(" %d",fa[i]);printf("\n");
	
	int End=m;
	m=0;
	for(int i=1;i<=End;i++)
	{
		if(E[i].x==n) continue;
		if(Edel[i]) continue;
		E[++m]=E[i];
	}
	//printf("E:\n");
	//for(int i=1;i<=m;i++) E[i].Print();
	
	for(int i=1;i<=m;i++) E[i].val=-Dis[E[i].x]+E[i].val+Dis[E[i].y];
	sort(E+1,E+m+1,cmp);
	for(int i=1;i<=m;i++) S[E[i].x].push_back(i);
	for(int i=1;i<n;i++) nxt[fa[i]].push_back(i);
	Build(n);
	
	p.push(msg{Dis[1],0,0,0});//路径长度和最后一条边 
	for(msg now;!p.empty();)
	{
		now=p.top(),p.pop();
		if(ALL<now.len) break;
		++ans;
		ALL-=now.len;
		int s=now.loc,t=E[now.Enum].y;
		double cost=E[now.Enum].val;
		int temp;
		if(!now.Enum)//1 之后追加边 
		{
			if(!node[root[1]].Size) continue;
			temp=Ask(root[1],1,m,1);
			p.push(msg{now.len+E[temp].val,1,temp,1});
		}
		else
		{
			//替换边 
			if(node[root[s]].Size>now.rnk)
			{
				temp=Ask(root[s],1,m,now.rnk+1);
				p.push(msg{now.len-cost+E[temp].val,s,temp,now.rnk+1});
			}
			if(node[root[t]].Size)
			{
				temp=Ask(root[t],1,m,1);
				p.push(msg{now.len+E[temp].val,t,temp,1});
			}
		} 
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：pldzy (赞：10)

[$\text{Link.}$](https://www.luogu.com.cn/problem/P2483)

[最短路树](https://oi-wiki.org/graph/kth-path/#%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A0%91%E4%B8%8E%E4%BB%BB%E6%84%8F%E8%B7%AF%E5%BE%84) + [可持久化左偏树](https://oi-wiki.org/ds/persistent-heap/)。

## Solution

### 1

基于最短路树的构建，我们可以得到终点到各个点的最短路。并以此为基础建树。

也即是说，对于树上的边，一定被包含在终点到某个点的最短路径上。

那么如何得到第 $k$ 大的路径呢？无非就是替换掉这些树边，以此计算额外的代价，这也是建最短路树的目的。

显然可以保证，用其他边替换当前的树边一定是不优的，即代价一定会增大。

### 2

这里其实是满足我自己的思考的：

* 对于路径的构造，这些路径的代价一定是相对有序/单调的。
  
* 我们弄一个小根堆维护答案，每次取队头得到前 $k$ 小条路径。因为我们显然不能严格保证得到的答案是严格单调的。
  

实现第二个，其实就要满足每次我们取出的队头一定要更新新的状态（因为 $k$ 的上限在过程中是不定的），而每次更新的新状态一定是比这个装填要更劣的。

在我的推论中，还存在一个棘手的问题：我们想要使用小根堆得到答案，就需要把所有可能的路径加进去。

那么显然我们不可能同时得到所有的路径，所以只能是从一个最优路径开始，放入优先队列，取出队头，以队头的状态为基础更新出若干个稍劣的路径方案并加入队列。这与上面的推论相符合。

### 3

最优方案是显然可以得到的，就是普通最短路。关键在于如何去不断更新出那个“稍劣的方案“。

这里就提到了开头的最短路树。

说白了，最短路树满足这样一个性质：

> 树根 $T$ 到点 $i$ 的简单路径就是 $T$ 到 $i$ 的最短路径。

这样一来，说明不在最短路树上的边，一定存在比它更优的路径能替代它，我们且叫它非树边。

为了更新状态，我们需要的显然就是这些非树边。

我们要解决的问题就是：如何适当地选择这些非树边去**替代树边**，能使新方案稍劣呢？

替代不免过于麻烦，我们不妨转化一下。

我们每次选出一个非树边边集，即为 $S$。每次的方案使用的非树边即为 $S$。而将这些非树边连接起来的，就是树边。

进一步简化，我们每次计算的都是当前方案比最优方案多出多少花费。

这样以来我们无需考虑树边的选用与代价之和。我们只关心边集 $S$ 中非树边的代价之和。

同时，每条非树边的代价我们把它转化为 $e_i.w' = e_i.w - (dis_u-dis_v) = e_i.w-dis_u+dis_v$。意为使用了这条非树边后，比最优方案多出多少代价。

### 4

对于队头弹出来的方案边集 $S$，我们不妨取出它最晚加入的一条非树边，替换成第一个比它花费多、同起点的非树边，或者保留并新加入一条非树边。

易证这样是合法的、能覆盖所有情况、且符合我们的要求的。

关键是我们要怎样用小根堆维护，在最短路树上，一个点到它的祖先们的所有非树边。

故而对于每个点，我们需要维护：

1. 以这个点为起点的所有有向边，用一个最小堆维护。
  
2. 这个点和它所有祖先的堆的并集。
  

对于这个东西，我们可以使用可持久化左偏树进行维护。

最终的时间复杂度题目背景已经提到，是 $O((n+m)logn+klogk)$ 的。相比 A* 的 $O(nk\log n)$，其优越性显然。

## Code

$\text{2.6 KB}$，压行见谅。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef double db;
#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define pii pair<db, int>
#define mp make_pair
#define fr first
#define se second
const int maxn = 5e5 + 5, maxm = 2e5 + 5;
int n, m; db E;
db dis[maxn]; int Fa[maxn], ans; bool vis[maxn];
int sec[maxn], rt[maxn];
struct Edge{
	int cnt, hd[maxn];
	struct edge{
		int to, nxt; db w;
	}e[maxm];
	inline edge& operator [](int x){ return e[x];}
	inline void add(int u, int v, db w){ e[++cnt] = {v, hd[u], w}, hd[u] = cnt;}
}g, f;
struct tree{
	int ls, rs; db vl; int td, fa;
};
struct Leftist_Tree{
	tree t[maxn << 1]; int tot;
	inline tree& operator [](int x){ return t[x];}
	inline int nw(int f, db v){ t[++tot] = {0, 0, v, 0, f}; return tot;}
	inline int merge(int a, int b){
		if(!a or !b) return a + b;
		if(t[a].vl > t[b].vl) swap(a, b);
		int nw = ++tot; t[nw] = t[a];
		t[nw].rs = merge(t[nw].rs, b);
		if(t[t[nw].ls].td <= t[t[nw].rs].td) swap(t[nw].ls, t[nw].rs);
		t[nw].td = t[nw].rs ? t[t[nw].rs].td + 1 : 0;
		return nw;
	}
}T;

inline void dijkstra(){
	priority_queue<pii, vector<pii>, greater<pii> > pq;
	rep(i, 1, n) dis[i] = 1e8 * 1.0;
	pq.push(mp(0.0, n)), dis[n] = 0;
	while(pq.size()){
		pii nw = pq.top(); pq.pop();
		if(vis[nw.se]) continue; vis[nw.se] = 1;
		for(int i = f.hd[nw.se]; i; i = f[i].nxt){
			int v = f[i].to; 
			if(dis[v] > nw.fr + f[i].w)
				dis[v] = nw.fr + f[i].w, Fa[v] = i,
				pq.push(mp(dis[v], v));
		}
	}
}
inline bool cmp(int a, int b){ return dis[a] < dis[b];}

priority_queue<pii, vector<pii>, greater<pii> > pq;
int main(){
	scanf("%d%d%lf", &n, &m, &E); rep(i, 1, n) sec[i] = i;
	rep(i, 1, m){
		int u, v; db w; scanf("%d%d%lf", &u, &v, &w);
		if(u == n){ i -= 1, m -= 1; continue;}
		g.add(u, v, w), f.add(v, u, w);
	}
	dijkstra();
	sort(sec + 1, sec + n + 1, cmp);
	T[0].td = -1;
	rep(j, 1, n){ 
		int x = sec[j];
		for(int i = g.hd[x]; i; i = g[i].nxt) if(i != Fa[x]){
			int v = g[i].to; 
			rt[x] = T.merge(rt[x], T.nw(g[i].to, -dis[x] + g[i].w + dis[g[i].to]));
		} rt[x] = T.merge(rt[x], rt[g[Fa[x]].to]);
	}
	
	E -= dis[1], ans += 1;
	pq.push(mp(T[rt[1]].vl, rt[1]));
	while(pq.size()){
		pii nw = pq.top(); pq.pop();
		if(E < nw.fr + dis[1]) return printf("%d", ans), 0;
		E -= nw.fr + dis[1], ans += 1;
		if(T[nw.se].ls) pq.push(mp(nw.fr - T[nw.se].vl + T[T[nw.se].ls].vl, T[nw.se].ls));
		if(T[nw.se].rs) pq.push(mp(nw.fr - T[nw.se].vl + T[T[nw.se].rs].vl, T[nw.se].rs));
		if(rt[T[nw.se].fa]) pq.push(mp(nw.fr + T[rt[T[nw.se].fa]].vl, rt[T[nw.se].fa]));
	}
	return printf("%d", ans), 0;
}
```


------------

Thanks for reading.

---

## 作者：ix35 (赞：9)

让我们直接快进到这里：

一条 $s\to t$ 的路径可以用一个边序列 $e_1,\ldots,e_k$ 来描述，满足：

- $e_i$ 不在最短路树上；
- $e_i$ 的终点在最短路树上是 $e_{i+1}$ 起点的祖先，特别地 $e_1$ 的起点是 $s$ 的祖先；
- 路径长度等于 $dis(s,t)+\sum\delta(e_i)$。

这条路径的形式就是依次经过每个 $e_i$，在相邻 $e_i$ 之间只走最短路树上的边。

---

于是我们只需要对满足上述条件的边序列求第 $k$ 小权值和即可，这可以用一个带扩展贪心来解决：

带扩展贪心的一般形式就是从一个最初状态开始依次扩展出每个可能的状态，并且只能由小的状态扩展到大的状态，每个状态的扩展方式唯一，那么再利用一个优先队列，每次取出队首进行扩展，连续 $k$ 次就可以求出答案了。

在该问题中，扩展方式如下：

- 对于序列 $e_1,\ldots,e_{k}$，它可以在后面添加一条边 $e_{k+1}$，扩展出 $e_1,\ldots,e_k,e_{k+1}$；
- 对于序列 $e_1,\ldots,e_k$，设 $e_{k-1}$ 的终点为 $a$，我们将 $e_k$ 替换为权值更大的一条边，为了保证唯一性，我们可以暂时规定只扩展**起点是 $a$ 祖先的所有非树边中，权值是 $e_k$ 后继的那一个**。

这样显然每个状态的扩展方式唯一，即不会有一个方案算两次（因为每个状态的前驱唯一）。

可以用**可持久化线段树**实现上述算法，我们对于每个 $a$ 求出所有起点是 $a$ 的祖先的非树边权值构成的线段树，由于要支持的操作仅仅是求某棵线段树上某值的后继和求某棵线段树上的最小值，都可以 $O(\log n)$ 完成。

外面再套一个 `priority_queue` 维护当前所有状态，时间复杂度为 $O(n+m\log n+k(\log k+\log n))$，空间复杂度为 $O(m\log n+k)$。

---

对比一下其他人说的堆的做法：

考虑将上述算法中的线段树换成堆，那么第二种扩展就不用是求后继了，而是取出堆中的一个结点后加入它的两个子结点（这样也满足大的状态总是被更小的状态扩展出），相当于对每个堆以一种拓扑序遍历。

这里需要使用一种可持久化的堆（不一定是可并堆，和线段树一样只需要单点加入即可），以最容易写的左偏树为例，由于堆的空间线性，而且求出两个子结点的过程 $O(1)$，因此复杂度比上面更好一些，时间复杂度为 $O(n+m\log n+k\log k)$，空间复杂度为 $O(n\log n+m+k)$。

可见堆做法是更优越的，所以上面的线段树算法实际上没什么用，但这里提供一个思路。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=5010,MAXM=200010,MAXD=4000010;
const double eps=1e-8;
double res,z,dis[MAXN];
int n,m,x,y,tot,cnt,ans,rt[MAXN],ch[MAXD][2],vis[MAXN];
pair <double,pair<int,int> > eg[MAXM];
vector <int> add[MAXN];
vector < pair<pair<int,int>,double> > v[MAXN];
priority_queue < pair<double,pair<int,int> > > q;
void dfs (int x) {
	vis[x]=1;
	int len=v[x].size();
	for (int i=0;i<len;i++) {
		int y=v[x][i].first.first;
		double z=v[x][i].second;
		if (vis[y]) {continue;}
		if (fabs(dis[y]-dis[x]-z)<=eps) {
			v[x][i].first.second=1;
			dfs(y);
		}
	}
}
int modify (int rt,int l,int r,int v) {
	int p=++tot;
	if (l==r) {return p;}
	int mid=(l+r)>>1;
	if (v<=mid) {
		ch[p][0]=modify(ch[rt][0],l,mid,v),ch[p][1]=ch[rt][1];
	} else {
		ch[p][1]=modify(ch[rt][1],mid+1,r,v),ch[p][0]=ch[rt][0];
	}
	return p;
}
int queryfir (int rt,int l,int r) {
	if (l==r) {return (rt?l:0);}
	int mid=(l+r)>>1;
	if (ch[rt][0]) {return queryfir(ch[rt][0],l,mid);}
	else {return queryfir(ch[rt][1],mid+1,r);}
}
int querynx (int rt,int l,int r,int v) {
	if (l==r) {return (rt?(l>v?l:0):0);}
	int mid=(l+r)>>1;
	if (mid<=v) {return querynx(ch[rt][1],mid+1,r,v);}
	else {
		int tmp=querynx(ch[rt][0],l,mid,v);
		if (tmp) {return tmp;}
		return querynx(ch[rt][1],mid+1,r,v);
	}
}
void dfs2 (int x) {
	int len=add[x].size();
	for (int i=0;i<len;i++) {rt[x]=modify(rt[x],1,cnt,add[x][i]);}
	len=v[x].size();
	for (int i=0;i<len;i++) {
		int y=v[x][i].first.first;
		if (v[x][i].first.second) {
			rt[y]=rt[x];
			dfs2(y);
		}
	}
}
void print (int rt,int l,int r) {
	printf("%d  %d  %d\n",rt,l,r);
	if (l==r) {return;}
	int mid=(l+r)>>1;
	print(ch[rt][0],l,mid);
	print(ch[rt][1],mid+1,r);
	return;
}
int main () {
	scanf("%d%d%lf",&n,&m,&res);
	for (int i=1;i<=m;i++) {
		scanf("%d%d%lf",&x,&y,&z);
		if (x==n) {continue;}
		v[y].push_back(make_pair(make_pair(x,0),z));
	}
	for (int i=1;i<=n-1;i++) {dis[i]=1e12;}
	q.push(make_pair(0,make_pair(n,0)));
	while (q.size()) {
		pair<double,pair<int,int> > a=q.top();
		q.pop();
		int nw=a.second.first;
		if (vis[nw]) {continue;}
		vis[nw]=1;
		int len=v[nw].size();
		for (int i=0;i<len;i++) {
			int y=v[nw][i].first.first;
			double z=v[nw][i].second;
			if (dis[y]>dis[nw]+z) {
				dis[y]=dis[nw]+z;
				q.push(make_pair(-dis[y],make_pair(y,0)));
			}
		}
	}
	memset(vis,0,sizeof(vis));
	dfs(n);
	for (int i=1;i<=n;i++) {
		int len=v[i].size();
		for (int j=0;j<len;j++) {
			int y=v[i][j].first.first;
			double z=v[i][j].second;
			if (!v[i][j].first.second) {eg[++cnt]=make_pair(dis[i]+z-dis[y],make_pair(y,i));}
		}
	}
	sort(eg+1,eg+cnt+1);
	for (int i=1;i<=cnt;i++) {
		//printf("%d   %.6f   %d  %d\n",i,eg[i].first,eg[i].second.first,eg[i].second.second);
		add[eg[i].second.first].push_back(i);
	}
	dfs2(n);
	//print(rt[1],1,cnt);
	res-=dis[1],ans=1;
	int tmp=queryfir(rt[1],1,cnt);
	if (tmp) {q.push(make_pair(-eg[tmp].first,make_pair(1,tmp)));}
	while (q.size()) {
		pair<double,pair<int,int> > a=q.top();
		q.pop();
		double val=dis[1]-a.first;
		if (res-val<=-eps) {break;}
		res-=val,ans++;
		int c=a.second.first,d=a.second.second;
		int nx=querynx(rt[c],1,cnt,d),tmp=eg[d].second.second;
		if (nx) {q.push(make_pair(a.first+eg[d].first-eg[nx].first,make_pair(c,nx)));}
		nx=queryfir(rt[tmp],1,cnt);
		if (nx) {q.push(make_pair(a.first-eg[nx].first,make_pair(tmp,nx)));}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：TTpandaS (赞：7)

## 问题

给定一个 $n$ 个点 $m$ 条边的有向图，求 $S$ 到 $T$ 的第 $K$ 短路。

## 最短路树

以 $T$ 为根建立一棵树，满足树上每一个点到根节点的距离为其与 $T$ 的最短路径长度。

设最短路树的边集为 $Q$。

## 构造

在反图上求出 $T$ 到达每个点的最短路 $d_x$，然后从 $T$ 开始搜索满足 $d_x+w_{x \to y}=d_y$ 的边，记录为树边。

## 性质

设一条从 $S$ 到 $T$ 的路径边集为 $P$，去掉 $P$ 与 $Q$ 的交集得到 $P'$。

1. 将 $P'$ 中的边按照 $S$ 到 $T$ 的经过顺序排序，对于两条相邻的边 $e_1,e_2$，$u_{e_2}$ 为 $v_{e_1}$ 在最短路树上的祖先或与其相等。（默认一条边方向为 $u \to v$）

![](https://cdn.luogu.com.cn/upload/image_hosting/jlslh522.png)

可以配合图片理解。

橙边表示 $P$，白边表示 $Q$。

从 $S$ 开始，第一条橙边 $e_1$ 和第二条橙边 $e_2$ 满足 $u_{e_2}=v_{e_1}$，因为这两条边之间没有经过树边。

第三条橙边 $e_3$ 和第五条橙边 $e_5$ （第四条橙边 $e_4$ 为树边，不包含在 $P'$ 内）满足 $u_{e_5}$ 为 $v_{e_3}$ 祖先，因为其中会经过树边。

欸，你可能会想到一种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/kfndlu27.png)

这个第一条黄边 $e1$ 和第四条黄边 $e_4$ 好像不满足以上性质啊？

实际上这样的黄边是不合法的，因为最短路树是有方向性的，不会出现第三条黄边的情况。

因此 $P'$ 中相邻两条边 $e1,e2$ 要么不经过树边，那么就是直接相连，$u_{e_2}=v_{e_1}$。否则只会经过连续的向上的树边，$u_{e_2}$ 为 $v_{e_1}$ 祖先。可以发现这是 $P'$ 合法的充分必要条件。

因此，一个 $P'$ 对应一个唯一的 $P$。

2. 选择一条边非树边后路径长度的增量 $\Delta e=d_v+w_{u \to v}-d_u$，则路径 $P$ 的长度 $L_p=d_s+\sum_{e \in P'} \Delta e$。

因此确定 $P'$ 后，就可以得到 $L_p$。

## 转化

原问题等价于求合法的 $P'$ 对应的 $L_p$ 的第 $K$ 小值。

## 实现

对于每个节点 $x$，将以其或其祖先为起点的边的 $\Delta e$ 合并在编号为 $x$ 的小根堆中，该步骤可以由可持久化可并堆 $O((n+m)\log m)$ 实现。

用一个小根堆维护 $P'$。每次取出堆顶的一个边集 $E$，有两种方式可以得到一个新的合法边集 $E'$：

设 $E$ 中最后一条边为 $u \to v$，

1. 将 $u \to v$ 替换成 $\Delta e$ 更大的 $u' \to v'$ 且合法。
2. 加入一条新边 $i \to j$，满足 $i=v$ 或 $i$ 为 $v$ 在最短路树上的祖先。

配合前面处理出的小根堆，这两种操作等价于：

1. 将 $u \to v$ 替换成其在堆中的左右儿子对应的边。
2. 加入一条新边，为编号为 $v$ 的小根堆中堆顶对应的边。

第 $k$ 个得到的 $E$ 就是答案。

该步骤可以由可持久化可并堆 $O(k \log k)$ 实现。

## 习题

P2483 【模板】k 短路 / [SDOI2010] 魔法猪学院

由于我们可以从小到大得到所有 $P$，所以将 $E$ 依次减去 $L_p$ 直到 $E<=0$，得到的 $P$ 的数量即为答案。

---

## 作者：Hagasei (赞：5)

前置芝士：[可持久化左偏树](https://oi-wiki.org/ds/persistent-heap/)，[最短路](https://www.luogu.com.cn/problem/P4779)

对于图 $G$，建立它的反图 $G'$，在 $G'$ 中以 $n$ 为起点跑任意单源最短路，建立最短路树 $T$（即其中任意节点到树根的路径都是它的最短路），对于任意一条从 $1$ 到 $n$ 的路径 $P$，取 $P'=P/T$，即 $P$ 中的非树边构成的边集。

首先，两条边 $e_1=(u_1,v_1),e_2=(u_2,v_2)$，如果它们在 $P'$ 中相邻，那么只会出现两种情况：

1. $v_1=u_2$，即它们相接

2. $u_2$ 是 $v_1$ 在树上的祖先，则连接它们的 $P$ 中的边即为 $v_1$ 到 $u_2$ 在 $T$ 上的简单路径。

所以， 合法的 $P'$ 可以唯一地确定一个 $P$。

然后，我们考虑如何计算 $P$ 的长度。

对于任意一条在 $P'$ 中的边 $e=(u,v)$，原本可以直接以 $dist_u$ 走到树根，却拐了一个弯，花费 $dist_v+w_e$，所以 $\Delta w_e=dist_v+w_e-dist_u$，那么总的 $w=dist_1+\sum_{e\in P'}\Delta w_e$，为方便，我们令 $\sum_{e\in P'}\Delta w_e=\Sigma$，$w$ 第 $k$ 小即为 $\Sigma$ 第 $k$ 小。

从 $1\to n$ 的最短路开始(即 $P'=\emptyset$)，用一个优先队列维护已有 $P'$。将一个 $P'$ 更新为比它的 $\Sigma$ 更大的路径中 $\Sigma$ 最小的。有两种更新方法：

1. 在 $P'$ 尾部新加一条非树边

2. 将 $P'$ 尾部的边替换为另一条

问题转化为了如何快速寻找它。我们可以用一个可持久化左偏树维护整个图，每个节点左儿子是他自己身上的边，右儿子是他的祖先。

具体的实现问题见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename zqw>inline void qr(zqw&x){
	bool f=x=0;
	char c=getchar();
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	x=f?(x-1):x;
}
template<typename zqw>void wr(zqw x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)wr(x/10);
	putchar((x%10)^48);
}
const int MAXN=5e3+5,MAXM=2e5+5;
const double eps=1e-6;
struct node{
	int lc,rc,dis,to;
	double key;
}tr[MAXN*310];
struct path{//其实路径只需要存最后一条边的对应节点
	int x;
	double val;
	inline bool operator<(const path&o)const{return val>o.val;}
};
int cnt,cnte,ans,n,m,hd[MAXN][2],to[MAXM][2],fa[MAXN],nxt[MAXM][2],seq[MAXN],rt[MAXN];
double R,ww[MAXM][2],dist[MAXN];
bool vis[MAXN];
inline int newnode(int t,double key){
	tr[++cnt]={0,0,0,t,key};
	return cnt;
}
inline void add(int u,int v,double w){
	++cnte;
	to[cnte][0]=v,nxt[cnte][0]=hd[u][0],hd[u][0]=cnte,ww[cnte][0]=w;
	to[cnte][1]=u,nxt[cnte][1]=hd[v][1],hd[v][1]=cnte,ww[cnte][1]=w;
}
inline bool cmp(int x,int y){return dist[x]<dist[y];}
int merge(int x,int y){
	if(!x||!y)return x^y;
	if(tr[x].key>tr[y].key)swap(x,y);
	int p=++cnt;
	tr[p]=tr[x];
	tr[p].rc=merge(tr[p].rc,y);
	if(tr[tr[p].lc].dis<tr[tr[p].rc].dis)swap(tr[p].lc,tr[p].rc);
	tr[p].dis=tr[tr[p].rc].dis+1;
	return p;
}
void dijk(){//最短路+连树边
	for(int i=1;i<=n;++i)dist[i]=0x3f3f3f3f;
	priority_queue<pair<double,int> >Q;
	Q.push({0,n});
	dist[n]=0;
	while(Q.size()){
	    int u=Q.top().second;
	    Q.pop();
	    if (vis[u]) continue;
	    vis[u]=1;
	    for(int i=hd[u][1];i;i=nxt[i][1]){
	    	const int v=to[i][1];
			const double w=ww[i][1];
	        if (dist[u]+w-dist[v]<-eps) {
	        	dist[v]=dist[u]+w;
	        	fa[v]=i;
	            Q.push({-dist[v],v});
			}
	    }
	}
}
int main(){
	qr(n),qr(m),scanf("%lf",&R);
	for(int i=1,u,v;i<=m;++i){
		double w;
		qr(u),qr(v),scanf("%lf",&w);
		if(u==n){
			--i,--m;
			continue;
		}
		add(u,v,w);
	}
	dijk();
	for(int i=1;i<=n;++i)seq[i]=i;
	sort(seq+1,seq+n+1,cmp);
	for(int i=1;i<=n;++i){//类似于bfs
		int u=seq[i];
		for(int e=hd[u][0];e;e=nxt[e][0]){
			if(fa[u]!=e){
				const int v=to[e][0];
				rt[u]=merge(rt[u],newnode(v,dist[v]+ww[e][0]-dist[u]));
			}
		}
		rt[u]=merge(rt[u],rt[to[fa[u]][0]]);
	}
	priority_queue<path>Q;
	if(R-dist[1]<-eps)return puts("0"),0;
	R-=dist[1],ans=1;
	if(rt[1])Q.push({rt[1],tr[rt[1]].key});
	while(Q.size()){
		path u=Q.top();//注：节点只往下跳即可满足换边时不重复选
		Q.pop();
		if(R-(u.val+dist[1])<-eps)break;
		R-=u.val+dist[1],++ans;
		//换边
		if(tr[u.x].lc)Q.push({tr[u.x].lc,u.val-tr[u.x].key+tr[tr[u.x].lc].key});
		if(tr[u.x].rc)Q.push({tr[u.x].rc,u.val-tr[u.x].key+tr[tr[u.x].rc].key});
		//加边
		if(rt[tr[u.x].to])Q.push({rt[tr[u.x].to],u.val+tr[rt[tr[u.x].to]].key});
	}
	wr(ans);
} 
```

---


# [SDOI2011] 贪食蛇

## 题目描述


相信大家都玩过贪食蛇游戏，现在有一个改版贪食蛇游戏，跟传统的贪食蛇游戏一样，贪食蛇在活动区域内运动，吃食物，但是这个改版的贪食蛇游戏有着一些特别的规则。

活动区域：

贪食蛇的活动区域是一个 $R$ 行 $C$ 列的网格 $A$，贪食蛇活动不能超过这个网格的范围。第 $i$ 行第 $j$ 列的方格用 $A_{i,j}$ 表示。每个方格有一个整数权值，记作 $w(A_{i,j})$。$0 \leq w(A_{i,j}) \leq 8$，$w(A_{i,j}) = 0$时，$A_{i,j}$ 禁止进入；$w(A_{i, j}) > 0$时，$A_{i, j}$ 允许进入。

方向：

对于 $P = (X_0, Y_0)$、$Q = (X_1, Y_1)$，有以下四种基本方向：

- 正左(L)：$X_0 = X_1$ 且 $Y_0 = Y_1 - 1$，则称 $P$ 位于 $Q$ 的正左方向。
- 正右(R)：$X_0 = X_1$ 且 $Y_0 = Y_1 + 1$，则称 $P$ 位于 $Q$ 的正右方向。
- 正上(U)：$X_0 = X_1 - 1$ 且 $Y_0 = Y_1$，则称 $P$ 位于 $Q$ 的正上方向。
- 正下(D)：$X_0 = X_1 + 1$ 且 $Y_0 = Y_1$，则称 $P$ 位于 $Q$ 的正下方向。

贪食蛇：

贪食蛇 $B$ 是占据若干方格的图形，占据的方格数为贪食蛇的长度，记为 $m$，则贪食蛇从头到尾，用 $B_1, B_2, \dots, B_m$表示。记 $p$ 为贪食蛇的形态，若 $B_i$ 位于第 $X_i$ 行第 $Y_i$ 列，则 $p(B_i)=(X_i, Y_i)$。初始情况下，$m = 4$，且运动过程中始终需要满足以下限制：

- 对于 $B_i$ 和 $B_{i + 1}$ $(1 \leq i < m)$，就是贪食蛇的前、后相邻两部分，必须满足 $B_i$ 位于 $B_{i + 1}$ 的L、R、U、D四个方向之一。
- 对于 $B_i$ 和 $B_j$ $(1 \leq i < j \leq m)$，$p(B_i) = (X_i, Y_i)$，$p(B_j) = (X_j,Y_j)$，需要满足 $X_i \neq X_j$ 或 $Y_i \neq Y_j$ 。也就是说，贪食蛇身体的任意一部分不能相交。

食物：

贪食蛇的活动区域内存在一些食物。每个食物位于一个允许进入的方格上，食物不会重叠。每个食物只能被吃一次。

贪食蛇的运动：

如果贪食蛇的头部 $B1$ 的L、R、U、D四个方向之一的 $A_{i, j}$ 能进入，且 $A_{i, j}$ 上不存在食物，则贪食蛇可以向该方向运动，新的头部位于 $A_{i, j}$ 上。记 $p'$ 为贪食蛇新的形态，则：

- $p'(B_k) = p(B_{k - 1})$，当 $2 \leq k \leq m$。
- $p'(B_k) = (i, j)$，当 $k = 1$。

贪食蛇的进食：

如果贪食蛇的头部 $B_1$ 的L、R、U、D四个方向之一的 $A_{i, j}$ 能进入，且 $A_{i,j}$ 上存在食物，则贪食蛇可以向该方向进食，新的头部位于 $A_{i, j}$ 上，蛇的新长度 $m'=m+1$。记 $p'$ 为贪食蛇新的位置，则：

- $p'(B_k) = p(B_{k-1})$，当 $2 \leq k \leq m'$。
- $p'(B_k) = (i,j)$，当 $k = 1$.

注意：运动或进食后的贪食蛇形态，仅仅需要考虑变换后的形态是否满足限制，不需要考虑变换的过程。也就是说，原来形态合法的贪食蛇的头部可以运动到尾部的位置，因为在变换后头部和尾部仍不会重叠。

运动或进食所需要的时间：

贪食蛇运动或进食，需要消耗时间。设运动或进食前头部所在的方格是P，运动或进食后头部所在的方格是 $Q$，则此次运动或进食的所消耗的时间为 $|w(P) - w(Q)| + 1$。

游戏的会在开始前给出贪食蛇的初始位置和所有食物的位置。你的任务是，以最少的时间令贪食蛇吃完所有食物。

## 说明/提示

- 对于 $20\%$ 的数据，$N \leq 1$；
- 对于 $30\%$ 的数据，$R \times C \leq 36$；
- 对于 $40\%$ 的数据，$N \leq 2$；
- 对于 $60\%$ 的数据，$N \leq 3$；
- 对于 $100\%$ 的数据，$N \leq 4$，$R \leq 12$，$C \leq 12$。

## 样例 #1

### 输入

```
5 5
11011
11011
11011
11011
11411
1 1
2 1
3 1
4 1
4
5 5
4 4
2 5
1 4```

### 输出

```
21
RDDDDRRRULURULU
```

# 题解

## 作者：jerry3128 (赞：27)

# [SDOI2011]贪食蛇

道理咱都懂嘛，这道题显然就是搜索。~~于是就有勇士直接交了DFS大模拟~~。

------------
在这里就重点讲一下状态压缩。
1. 首先是蛇形态的预处理。
	- 首先是蛇的问题，确定一条蛇，就需要头，和上一个身体相对于这个身体的方位。显然只有4个方向，我们就拿二进制状态下两个位来记录一个方向。
	- 又因为，头部是没有“上一个身体”这个概念的，所以他就记录身体的长度。
	- 我们发现，身长是4~7的，恰好四个数，我们就把身长减4，并压如“蛇”的状态中。
    - 具体先算出题目给出的蛇的初始状态
    ```
	for(int i=3; i>0; i--) {
			int k=0;
			if(snake[i-1][0]+dx[0]==snake[i][0]&&snake[i-1][1]+dy[0]==snake[i][1])k=0;
			if(snake[i-1][0]+dx[1]==snake[i][0]&&snake[i-1][1]+dy[1]==snake[i][1])k=1;
			if(snake[i-1][0]+dx[2]==snake[i][0]&&snake[i-1][1]+dy[2]==snake[i][1])k=2;
			if(snake[i-1][0]+dx[3]==snake[i][0]&&snake[i-1][1]+dy[3]==snake[i][1])k=3;
			q[1]=q[1]<<2|k;
	}
	q[1]<<=2;
	```
    - 对于每一次蛇的移动，我们要判断它是否咬到自己的身子。
    ```
    int snake_move(int stat,int len,int k) {//蛇的状态，长度，移动方向。
			int tmp=stat;
			len+=4;
			k^=1;//移动方向，和上一个身子相对于头的方向相反。
			int x=dx[k],y=dy[k];
			for(int i=2; i<len; i++) {
				x+=dx[tmp&3];
				y+=dy[tmp&3];
				tmp>>=2;
				if(!x&&!y)return -1;
			}//判断咬到自己。
			return (stat<<2&((1<<(len+len-2))-1))|k;
        //stat<<2|k表示移动后，头直接增长的状态，因为如果没有吃到果子，身体不会变长。所以要加len限制。
	}
    ```
    - 在这里，我们需要离散化状态，并记录下来。并分出11位二进制位保存状态。
    - 对于普通的移动。
    ```
	for(int k=0; k<4; k++) {
			int stat1=snake_move(stat0,len0,k);
			if(stat1>=0) {
				int s1=stat1<<2|len0;
				if(!number[s1])q[++r]=s1,number[s1]=r;//离散化记录。
				s[l][k]=number[s1];//离散化后的状态l向k爬，得到的离散化后的状态。
			}
	}
    ```
    - 吃到果子的同理。
    ```
    for(int k=0; k<4; k++) {
			int stat1=snake_move(stat0,len0+1,k);
			if(stat1>=0) {
				if(len0<3) {
					int s1=stat1<<2|(len0+1);
					if(!number[s1])q[++r]=s1,number[s1]=r;
					fs[l][k]=number[s1];
				} else fs[l][k]=0;
			}
	}
    ```
1. 处理完蛇的形态之后，我们就要开始真正的搜索了。
	- 先说一下需要记录的状态。
		- 头的坐标：横纵共8位
		- 蛇的形态：11位
		- 食物状态：4位
		- 耗费的时间：3位
    ```
    int make_stat(int x,int y,int ss,int fs,int wt) {
				return (x<<22)|(y<<18)|(ss<<7)|(fs<<3)|wt;
	}
	void get_stat(int &x,int &y,int &ss,int &fs,int &wt,int val) {
				x=val>>22&0xf;
				y=val>>18&0xf;
				ss=val>>7&0x7ff;
				fs=val>>3&0xf;
				wt=val&7;
	}
    ```
    - 那么，在BFS遍历队列的时候。
        - 一般的转移：
        ```
        for(int k=0; k<4; k++) {
				int x1=x0+dx[k],y1=y0+dy[k],stat1=s[stat0][k],fstat1=fstat0,wt1=abs(mp[x1][y1]-mp[x0][y0]);
				if(!mp[x1][y1])continue;
				if(fmp[x1][y1]&&(fstat1&1<<(fmp[x1][y1]-1))) {
					fstat1^=1<<(fmp[x1][y1]-1);
					stat1=fs[stat0][k];
				} else stat1=s[stat0][k];
				if(stat1>=0) {
					int s1=make_stat(x1,y1,stat1,fstat1,wt1);
					if(!(vst[s1>>3]&1<<wt1)) {
						vst[s1>>3]|=1<<wt1;
						q[++r]=s1;
						p[r]=l;//记录由谁转移，后要统计答案。
					}
				}
		}
        ```
        - 特别的，因为是BFS，为保证记忆化复杂度所以时间必须严格非减，对于任意两格之间的转移时间，我们得一个一个单位的等。
        ```
        if(wt0) {
				int s1=make_stat(x0,y0,stat0,fstat0,wt0-1);
				if(!(vst[s1>>3]&1<<(wt0-1))) {
					vst[s1>>3]|=1<<(wt0-1);
					q[++r]=s1;
					p[r]=l;
				}
		}
        ```
    	- 边界条件:食物吃完了，而且到达了终点。
    	```
        if(!fstat0&&!wt0) {
				ansl=l;//记录最终答案。
				break;
		}
    	```
有了最终答案和每一次操作是由谁转移的记录，就倒着扫一遍统计就行了。

---


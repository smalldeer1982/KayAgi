# [SCOI2009] 骰子的学问

## 题目描述

小鱼儿是个数学天才。一天晚上他研究一个和字符串有关的 penney-ante 游戏。游戏的规则如下：

1. 有两个玩家，开始时每人选择一个长度相同的字符串；

2. 一个字符生成器不断的随机生成字母添加到字符串 $S$ 的末尾，$S$ 初始为空串；

3. 如果 $S$ 包含了某个玩家选择的字符串则游戏结束，该玩家获胜。

假设玩家 1 和玩家 2 分别选择了两个字符串 $A$ 和 $B$，如果玩家 1 可以以较大概率战胜玩家 2，我们记作 $A>B$。咋一看来，小鱼儿觉得如果 $A>B$ 且 $B>C$ 则 $A>C$。可事实恰好相反，存在字符串 $A, B, C$ 使得 $A>B, B>C, C>A$。


小鱼儿被这种戏的一个反常现象所吸引，通过查阅资料，他了解到这种现象被称为“非传递性悖论”，在许多非完全信息游戏（比如军棋）中，经常会有这样的例子。可是它到底是如何产生的呢？小鱼儿决定设计一种游戏，从中可以容易的找到非传递的例子，以便更清楚的认识“非传递性”。当然，这样的游戏越简单道理越深刻，于是小鱼儿想起了最简单的掷骰子游戏……


这个游戏是这样的，假设有 $n$ 个骰子 $D_1,\dots,D_n$，每个骰子有 $m$ 个面。每个面上标有一个 $1,2,\dots,n\times m$ 的正整数，并且所有骰子的所有 $n\times m$ 个面上的数字各不相同。满足这条编号要求，并且每个面被随到的概率相等的，这样的 $n$ 个骰子称为一组“好骰子”。游戏开始时，两个玩家分别选两个骰子 $D_i$ 和 $D_j$，各掷一次来比较掷出来那一面的数值，数大的获胜。


小鱼儿请你帮忙设计一组“好骰子”，使得对任意一个骰子 $D_i$，它总能战胜 $D_{a_i}$。此处战胜是指选择前者的玩家获胜的概率超过 $1/2$；$a_1,a_2,\dots,a_n$ 为输入的 $1\sim n$ 的正整数。

## 说明/提示

$30\%$ 的数据满足 $n, m\le 10$。

$100\%$的数据满足 $3\le n, m\le200$。

感谢 @cn：苏卿念 提供 spj。

## 样例 #1

### 输入

```
3 3
2 3 1
```

### 输出

```
1 6 8
3 5 7
2 4 9
```

## 样例 #2

### 输入

```
3 4
2 1 2
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3 4
2 3 1
```

### 输出

```
1 3 10 11
2 7 8 9
4 5 6 12
```

## 样例 #4

### 输入

```
4 4
4 1 2 3
```

### 输出

```
1 11 8 14
12 15 2 5
3 6 16 9
4 10 13 7
```

# 题解

## 作者：nomonick (赞：19)

# P2565 [SCOI2009]骰子的学问

## 题面解析

题面 link : [P2565](https://www.luogu.com.cn/problem/P2565)

给定一个大小为 $n$ 的数组 $\{ a_i \}$ ，你要用整数 $1$ 到 $n \times m$ 填 $n$ 个 $m$ 面的骰子，宝成每个数字只出现一次，使得第 $i$ 个骰子大于第 $a_i$ 个骰子，且对于每个骰子掷出任意一个面的概率相等。

对于骰子 $x$ 大于骰子 $y$ 的定义，当且仅当骰子 $x$ 掷出的点数大于骰子 $y$ 掷出的点数的概率大于 $\frac{1}{2}$。

该题的全部样例如下（对解题有所帮助）：

![](https://pic.imgdb.cn/item/617fdcb92ab3f51d91a915bb.jpg)

## 算法分析

将骰子按照骰子 $x$ 大于骰子 $y$ 的关系建立有向图。而这张图，就构成了一个基环内向树森林。

此时整张图可以被拆分成为两个部分，分别是环内与环外。对于任意的处于环外的点，它应当保证所有的父亲均大于它。那么可以形成一种在环外的构造方法：

对于环外的每一个点，保证保证它的父亲的每一面的点数都比它的最大点数大。显然环外的骰子直接分配极大值就行了。

这样问题就缩小成了运用 $q \times m$ 个数填出一个合法的环。 很明显此时满足 $q > 2, m > 2$

而对于在环内的骰子。选择一个，向父亲方向依次放下 $(1,n)$ 的值，再选择一个，向父亲方向依次放下 $(n+1,2n)$ 。如此重复直到填满。

证明：

两个骰子可以等概率的投出 $m^2$ 种组合。因此对于一个合法的填法，任意一个点与它的后继形成的组合中应至少有 $\left \lceil \frac{m^2 + 1}{2}  \right \rceil $ 种满足前者较大。

对于任意的 $i > j$ ，在这种构造下都满足了任何一个骰子的第 $i$ 面一定比另一个骰子的第 $j$ 面大，所以相邻的骰子一定存在 $\frac{m \cdot (m- 1)}{2}$ 种情况是保证了前驱大于后继的。

对于填在第 $i$ 个骰子上的 $q$ 个数除了最大的一个数所在的骰子的前驱，所有的数都大于自己的后继。那么实际上就相当于给每个骰子都增加的 $m$ 种可行情况。而同时会进行 $m$ 次选择，选择哪一个骰子为起点。每次选择会将这个骰子大于后继的数量减一。

而对于任意的一个骰子，被选出的次数最多应该为 $\frac{m \cdot (m+1)}{2} - \left \lceil \frac{m^2 + 1}{2}  \right \rceil $ ，而总选择次数应该乘以一个 $q$ 

1.  $m$ 为奇数，总选择次数可表示为 $\frac{qm-q}{2}$ ， 当 $\frac{q(m-1)}{2} \geq m$ 是成立。故满足 $(q - 2) (m - 1) \geq 2$  ，该等式和成立
2.   $m$ 为奇偶数，总选择次数可表示为 $\frac{qm-2q}{2}$ ， 当 $\frac{qm-2q}{2} \geq m$ 是成立。故满足 $(q - 2) (m - 2) \geq 4$  ，当且只有一组情况不合法，即 $\left\{\begin{matrix}
    q = 3 & \\
    m = 4 &
   \end{matrix}\right.$

出现的不合法情况特判即可。

## 算法实现

为了方便实现可将原有环内操作修改为如下：

选择一个点，向父亲方向依次放下 $(1,n)$ 的值，再选择它的父亲，向父亲方向依次放下 $(n+1,2n)$ 。如此重复直到填满。

这样显然与原有结论并不矛盾，同时又方便实践。

最后拓扑排序即可

## code

```cpp
#include <bits/stdc++.h>
const int SIZE = (int)2e2 + 50;
const int Sample[4][5] = {{},{0,1,3,10,11},{0,2,7,8,9},{0,4,5,6,12}};
int n,m,tot,head,tail;
int son[SIZE],indegree[SIZE],que[SIZE];
int ans[SIZE][SIZE];
inline void toposort()
{
	for (int i = 1; i <= n; ++i) if (!indegree[i]) que[++tail] = i;
	while (head <= tail)
	{
		int u = que[head++]; --indegree[son[u]];
		for (int i = 1; i <= m; ++i) ans[u][i] = tot--;
		if (!indegree[son[u]]) que[++tail] = son[u];
	}
	for (int i = 1; i <= n; ++i)
	{
		if (!indegree[i]) continue; tail = 0;
		for (int u = i; indegree[u]; u = son[u]) indegree[que[++tail] = u] = 0;
		if (tail < 3) {printf("0\n"); exit(0);}
		tot -= tail * m;
		if (tail == 3 && m == 4)
		{
			ans[que[1]][1] = Sample[1][1] + tot; ans[que[1]][2] = Sample[1][2] + tot;
			ans[que[1]][3] = Sample[1][3] + tot; ans[que[1]][4] = Sample[1][4] + tot;
			ans[que[2]][1] = Sample[2][1] + tot; ans[que[2]][2] = Sample[2][2] + tot;
			ans[que[2]][3] = Sample[2][3] + tot; ans[que[2]][4] = Sample[2][4] + tot;
			ans[que[3]][1] = Sample[3][1] + tot; ans[que[3]][2] = Sample[3][2] + tot;
			ans[que[3]][3] = Sample[3][3] + tot; ans[que[3]][4] = Sample[3][4] + tot;
			continue;
		}
		for (int j = 1,now = 1; now <= m; j = (j == 1 ?  tail : j - 1), ++now)
		{
			ans[que[j]][now] = ++tot;
			for (int k = (j == 1 ? tail : j - 1); k ^ j; k = (k == 1 ?  tail : k - 1)) 
				ans[que[k]][now] = ++tot;
		}
		tot -= tail * m;
	}
}
signed main()
{
	cin >> n >> m; tot = n * m; head = 1;
	for (int i = 1; i <= n; ++i) cin >> son[i],indegree[son[i]]++;
	for (int i = 1; i <= n; ++i) if (son[i] == i) return printf("0\n"),0;
	toposort();
	for (int i = 1; i <= n; ++i,printf("\n"))
		for (int j = 1; j <= m; ++j)
			printf("%d ",ans[i][j]);
	return 0;
}

```



---

## 作者：lsj2009 (赞：5)

感觉题解中仅有的一个题解证明方法太过麻烦，所以这里给出另一种证明。

首先考虑依据题目条件建图；具体的，如果有 $i$ 胜率大于 $j$，那么连一条有向边 $i\rightarrow j$。

由于每个点有且仅有一条出边，所以我们得到一个基环内向树森林。

那么我们可以将环部分和树部分分开了讨论；对于树部分，是非常显然的构造：如果我们要让 $i$ 胜率大于 $j$，让 $\min{d_{i,k}}>\max{d_{j,k}}$ 即可。具体实现方法是我们对其进行拓扑排序，依照拓扑序由小到大，将数值由大到小地填入即可。

然后重点是环部分，先给出构造方案的伪代码：

$$
\begin{aligned}
& \text{SOLVE}(G,s)\\
& 1\quad k\gets s\\
& 2\quad \textbf{for } i \textbf{ from } 1 \textbf{ to } m\\
& 3\quad\quad\quad tot\gets tot+1\\
& 4\quad\quad\quad d_{k,i}\gets tot\\
& 5\quad\quad\quad p\gets pre_k\\
& 6\quad\quad\quad \textbf{while }p \neq k\\
& 7\quad\quad\quad\quad\quad tot\gets tot+1\\
& 8\quad\quad\quad\quad\quad d_{p,i}\gets tot\\
& 9\quad\quad\quad\quad\quad p\gets pre_k\\
& 10\quad\quad\quad k\gets pre_k
\end{aligned}
$$

其中 $tot$ 的初值为当前待填的值，$s$ 的初值任取，$G$ 为给定的环，$pre_u$ 为 $u$ 在 $G$ 上的前驱节点，$\{d\}$ 即为所求。

然后是证明：

- 首先容易发现的是，对于任意的 $d_{pre_i,j}$ 必然都有 $d_{pre_i,j}>d_{i,1},d_{i,2},\cdots,d_{i,j-1}$，所以这肯定有 $pre_i$ 对于 $i$ 的胜率不小于 $\frac{m(m-1)}{2}$，然后可以看出的是每当伪代码中的 $k$ 循环至 $i$ 时，$d_{pre_i,j}<d_{i,j}$ 否则 $d_{pre_i,j}>d_{i,j}$，而 $k$ 至少有 $\lfloor \frac{m}{|G|}\rfloor$，至多有 $\lceil \frac{m}{|G|}\rceil$ 次循环到 $i$，即 $pre_i$ 对 $i$ 有额外的 $[m-\lceil \frac{m}{|G|}\rceil,m-\lfloor \frac{m}{|G|}\rfloor]$ 次胜率，则 $pre_i$ 对 $i$ 的胜率不小于 $\lceil\frac{m(m-1)}{2}+m-\frac{m}{|G|}\rceil$ 的胜率，右由于 $|G|>2$，所以 $\frac{m(m-1)}{2}+m-\frac{m}{|G|}>\frac{m(m-1)}{2}+m-\frac{m}{2}=\frac{m^2}{2}$。所以其胜率必然大于 $\lceil \frac{m^2}{2}\rceil$。

QED.

---

## 作者：yAlAxy (赞：2)

## P2565 题解

**题目分析：**

首先我们把一个骰子的一个元素的权值定义为这个元素比多少个在它需要战胜的骰子中的元素要大，所以判断能否战胜的条件就是这个骰子中所有元素的权值和大于 $\lfloor\frac{m^2}{2} \rfloor$。

接下来我们从一组样例入手（第三组样例）：

![](https://pic.imgdb.cn/item/617fdcb92ab3f51d91a915bb.jpg)

注意到这组样例中将一和二交换会让第一个骰子的权值和更大，而其他不变。基于此，我们又可以注意到填数的路径其实是由被战胜的骰子至战胜的骰子的。

**更进一步的：**

所以我们考虑假设已经填了前一部分数，考虑下一个数怎么填。可以贪心地考虑下一个数必然要填在需要战胜这一个骰子的骰子上，并且这是对的。

于是考虑搜索，深搜地去填数，定义能填表示填数时为剩余的数的权值均为 $m$ 时是否能继续（就是剩余都是最优时的答案）。

有无解的判定和证明是简单的，其他题解里也有。

于是我们就很简单地解决了这道题。

代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
using Pii = pair<int, int>;

const int N = 205;

int n, m, a[N], t, c[N], v[N];
vector<int> e[N], r[N];

void D(int x) {
  if (++v[x] > 1e5) {
    cout << 0;
    exit(0);
  }
  if (r[x].size() == m) {
    return;
  }
  for (; c[x] - (int)(r[a[x]].size()) <= m * (m - (int)(r[x].size()) - 1) && r[x].size() < m; c[x] -= r[a[x]].size()) {
    r[x].push_back(++t);
  }
  for (int i : e[x]) {
    D(i);
  }
}

signed main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    e[a[i]].push_back(i);
    c[i] = m * m / 2 + 1;
    if (a[i] == i) {
      cout << 0;
      return 0;
    }
  }
  for (int i = 1; i <= n; i++) {
    D(i);
  }
  if (*max_element(c + 1, c + n + 1) > 0) {
    cout << 0;
    return 0;
  }
  for (int i = 1; i <= n; i++) {
    for (int j : r[i]) {
      cout << j << ' ';
    }
    cout << '\n';
  }
  return 0;
}
```

---

## 作者：SegTree (赞：0)

好题。

连边 $i\to a_i$，形成基环树森林。

对于树上，由于形成了严格的偏序关系，直接在每个结点填连续的编号，这样概率就变成了 $100\%$，满足条件。

但是这个做法不适用于环。我们考虑执行以下操作 $m$ 次：

从一个节点顺着环填标号；

将这个节点变为它的前驱。

设环长为 $L$，则一个点大于它后继的方案数为 $\dfrac{m(m-1)}{2}+m-\lceil\dfrac{m}{L}\rceil$。

由于 $L\le 2$ 一定无解，只考虑 $L>3$。

若方案数 $=\dfrac{m^2}{2}$，则这个做法是假的。此时有 $\lceil\dfrac{m}{L}\rceil=\dfrac{m}{2}$，该式子成立在 $m,L\in N^{+}$ 当且仅当 $m=2$（不满足题目数据范围）或 $m=4,L=3$。

对于 $m=4,L=3$，可产生如下构造（设环为 $1\to 2\to 3\to 1$）。

```
1 3 10 11
2 7 8 9
4 5 6 12
```

做完了。

---


# [ZJOI2009] 多米诺骨牌

## 题目描述

有一个 $n \times m$ 的矩形表格，其中有一些位置有障碍。现在要在这个表格内放一些 $1 \times 2$ 或者 $2 \times 1$ 的多米诺骨牌，使得任何两个多米诺骨牌没有重叠部分，任何一个骨牌不能放到障碍上。并且满足任何相邻两行之间都有至少一个骨牌横跨，任何相邻两列之间也都至少有一个骨牌横跨。求有多少种不同的放置方法，注意你并不需要放满所有没有障碍的格子。


## 说明/提示

### 样例解释

两种放置方法分别为：

```plain
112 411
4.2 4.2
433 332
```

注意这里的数字只用于区分骨牌，不同的排列并不代表不同的方案。

### 数据范围

- 对于 $40\%$ 的数据，满足 $n,m \leq 8$；
- 对于 $90\%$ 的数据，满足 $n,m \leq 14$。
- 对于 $100\%$ 的数据，满足 $1 \leq n,m \leq 15$。

## 样例 #1

### 输入

```
3 3
...
...
...```

### 输出

```
2```

# 题解

## 作者：hwk0518 (赞：75)

这道题还是比较好想的，就是细节多了一些。

网上的题解大部分都是插头$DP$，我来写一份状压+容斥的题解。

首先考虑没有限制的情况，即，用$1*2$的骨牌覆盖整个网格图，有多少种不同的方案？

考虑按照

$(1,1),(1,2),...,(1,m),(2,1),...,(2,m),...,(n,1),...,(n,m)$

的顺序加点。加入$(i,j)$时统计用骨牌覆盖$(i-1,j)(i,j)$和覆盖$(i,j-1)(i,j)$的方案数，以及不覆盖$(i,j)$的方案数。我们需要知道$(i-1,j)$和$(i,j-1)$的信息。

但是$(i-1,j+1),...,(i-1,m),(i,1),...,(i,j-2)$之后还可能和某个$(i,j)$一上一下地用骨牌覆盖，所以也要记下来。用一个状压维护。

更进一步，我们考虑对所有网格图的所有子矩阵求出没有限制的答案（之后有用）。设左上角为$(x_1,y_1)$，右下角为$(x_2,y_2)$的矩阵的答案是$dp[y_1][x_1][y_2][x_2]$。（行列颠倒后转移会更简便。）在求解$dp[y_1][x_1][y_2][n]$的过程中，我们一定有某个时刻记录了$(k,y_1),(k,y_1+1),...,(k,y_2)$的状态。将所有状态的$DP$值加起来就是$dp[y_1][x_1][y_2][k]$。所以只要枚举$y_1,x_1,y_2$求解即可。

现在考虑有限制的情况。想到容斥。比较流行的容斥有两种：

$(1)$子集容斥。

$(2)$代表元容斥。即，为了求出让条件$1,2,...,n$均满足的情况数，我们可以枚举不满足的条件中编号最小的那一个。

都用子集容斥显然不行。因为复杂度是$2^{n+m}$。都用代表元容斥也不行。因为枚举了第一个没有横跨的行后，求的实际上是分割线上边和下边均有列横跨的方案数。而我们要求的是分割线上边和下边至少有一个有列横跨的方案数。

所以对列用容斥，行用代表元。枚举哪些列的夹缝没有横跨，它们将矩阵分为若干块。记$f_i$表示前$i$行的矩阵合法的方案数。$g[i][j]$表示$i$行到$j$行任意摆放且不横跨夹缝的方案数。则有：

$g[i][j]=\prod_{x=1}^k dp[l_x][i][r_x][j]$

其中$l_t$表示第$t$块的左端点。$r_t$亦然。

$f[i]=g[1][i]-\sum_{j=2}^{i}f[j-1]*g[j][i]$

这样，求出每个子集的$f_n$，子集容斥即可。

时间复杂度方面，一开始的预处理主要瓶颈在状压。它是指数级别的。最坏情况下是$2^m$。有$n$次会取到。每次要枚举$n*n$个点。时间复杂度$O(2^m*n^3)$。至于其他不能取到最坏复杂度的情况，由于复杂度不同级，可以略去。

后面的统计，子集容斥一次$O(2^m)$，代表元容斥一次$O(n)$，故时间复杂度为$O(2^m*n)$

总时间复杂度是$O(2^m*n^3)$。

很多人说我题解写得太详细是在浪费时间。用某学姐的话说，“好像在谈恋爱”。但我想，题解不仅是个人的总结，更是对其他人的帮助。这道题网络上有很多题解，但大多数都是三言两语就带过，很难看懂。不仅这道题，很多题也是一样。而我所做的，就是将我的理解，通过通俗易懂的方式，呈现给大家。能用短暂的两三年$OI$生涯，为更多$OIer$造福，我感到很欣慰。这就是所谓的“前人栽树，后人乘凉”。

代码：

```

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const int N=15;
const int T=1<<N;
const int mod=19901013;
int n,m,pre[N][N][N][N],tdp[2][T],ans;
int f[N],tl,cnt[T];
pair<int,int> lis[N];
char s[N][N];

namespace MATHEMATICS
{
	int add(int x,int y)
	{
		int ret=x+y;
		if(ret>=mod) ret-=mod;
		return ret;
	}
	int mi(int x,int y)
	{
		int ret=x-y;
		if(ret<0) ret+=mod;
		return ret;
	}
	
	void inc(int &x,int y)
	{
		x+=y;
		if(x>=mod) x-=mod;
	}
	void dec(int &x,int y)
	{
		x-=y;
		if(x<0) x+=mod;
	}
	
	int mul(int x,int y)
	{
		return 1LL*x*y%mod;
	}
}
using namespace MATHEMATICS;

void init()
{
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=0;i<n;++i) scanf("%s",&s[i]);
}

void cal(int xu,int yu,int xd)
{
	int i,j,S,mxS=1<<xd-xu+1;
	int oldpos=0,newpos=1;
	for(S=0;S<mxS;++S) tdp[0][S]=0;
	tdp[0][mxS-1]=1;
	
	for(i=yu;i<n;++i)
		for(j=xu;j<=xd;++j)
		{
			for(S=0;S<mxS;++S) tdp[newpos][S]=0;
			for(S=0;S<mxS;++S)
			{
				if(!tdp[oldpos][S]) continue;
				if(!(S&(1<<xd-xu))&&s[i][j]=='.'&&s[i-1][j]=='.')
					inc(tdp[newpos][(S<<1)&(mxS-1)|1],tdp[oldpos][S]);
				if(!(S&1)&&s[i][j]=='.'&&j>xu&&s[i][j-1]=='.')
					inc(tdp[newpos][(S<<1)&(mxS-1)|3],tdp[oldpos][S]);
				inc(tdp[newpos][(S<<1)&(mxS-1)],tdp[oldpos][S]);
			}
			if(j==xd)
			{
				for(S=0;S<mxS;++S)
					inc(pre[xu][yu][xd][i],tdp[newpos][S]);
			}
			oldpos^=1,newpos^=1;
		}
}

void prework()
{
	int i,j,k;
	for(i=0;i<m;++i)
		for(j=0;j<n;++j)
			for(k=i;k<m;++k)
				cal(i,j,k);
}

int calc(int S)
{
	int i,j,k,las=0;tl=0;
	for(i=0;i<m-1;++i)
		if((1<<i)&S)
			lis[++tl]=make_pair(las,i),las=i+1;
	lis[++tl]=make_pair(las,m-1);
			
	for(i=0;i<n;++i)
	{
		f[i]=1;
		for(j=1;j<=tl;++j)
			f[i]=mul(f[i],pre[lis[j].first][0][lis[j].second][i]);
		for(k=0;k<i;++k)
		{
			int now=f[k];
			for(j=1;j<=tl;++j)
				now=mul(now,pre[lis[j].first][k+1][lis[j].second][i]);
			dec(f[i],now);
		}
	}
	
	return f[n-1];
}

void work()
{
	int ans=0,S,mxS=1<<m-1;
	for(S=0;S<mxS;++S) cnt[S]=cnt[S>>1]+(S&1);
	for(S=0;S<mxS;++S)
	{
		if(cnt[S]&1) dec(ans,calc(S));
		else inc(ans,calc(S));
	}
	printf("%d\n",ans);
}

int main()
{
	init();prework();work();
	return 0;
}

```

---

## 作者：RainAir (赞：10)

轮廓线 dp 例题。

首先我们考虑如果没有”满足任何相邻两行之间都有至少一个 骨牌横跨，任何相邻两列之间也都至少有一个骨牌横跨“的限制如何做：设 $f[i][j][S]$ 表示填到第 $i$ 行第 $j$ 列，轮廓线状态为 $S$ 的方案数。转移的时候只需要考虑不放/往上放/往左放即可。

我们先预处理 $g[i][j][l][r]$ 表示左上角是 $(i,l)$ 右下角是 $(j,r)$ 的子矩阵的方案数。这个可以暴力预处理 复杂度看起来像是 $O(2^{m+1}n^5)$ 但实际上一堆东西跑不满，具体分析后发现复杂度是 $O(2^{m+1}n^3)$，勉强卡的过去

之后考虑如何处理限制：暴力的想法是行和列一起容斥 枚举哪些行之间不能跨过 哪些列之间不能跨过 再求一些矩阵和。这个做法复杂度是 $O(2^{n+m}nm)$ 的看起来就很爆炸，但是我们可以考虑只枚举哪些行之间不能跨过 列的枚举改成一个带容斥系数的 dp，就可以在 $O(2^{n+1}m^2n)$（视个人实现情况）的时间内算出来了。

代码：
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdlib>
#include <cstdio>
#include <bitset>
#include <vector>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <map>
#include <set>

#define fi first
#define se second
#define U unsigned
#define P std::pair
#define LL long long
#define pb push_back
#define MP std::make_pair
#define all(x) x.begin(),x.end()
#define CLR(i,a) memset(i,a,sizeof(i))
#define FOR(i,a,b) for(int i = a;i <= b;++i)
#define ROF(i,a,b) for(int i = a;i >= b;--i)
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl

const int MAXN = 16+1;
const int ha = 19901013;
int f[MAXN][MAXN][(1<<MAXN)+3];
char str[MAXN][MAXN],lim[MAXN][MAXN];
int n,m;
int g[MAXN][MAXN][MAXN][MAXN];
// 上边界 左边界 右边界 下边界

inline void Solve(int u,int l,int r){
	CLR(lim,0);
	FOR(i,u,n) FOR(j,l,r) lim[i-u][j-l] = str[i][j];
	int n = ::n-u+1,m = r-l+1;
	f[0][0][(1<<m)-1] = 1;
	FOR(i,0,n-1){
		FOR(j,0,m-1){
			FOR(S,0,(1<<m)-1){
				int ii,jj;
				if(j != m-1) ii=i,jj=j+1;
				else ii=i+1,jj=0;
				if(lim[i][j] == 'x'){
					(f[ii][jj][S|(1<<j)] += f[i][j][S]) %= ha;
				}
				else{
					int nxt = S;
					if(nxt>>j&1) nxt^=(1<<j);
					(f[ii][jj][nxt] += f[i][j][S]) %= ha;
					if(!(S>>j&1)) (f[ii][jj][S|(1<<j)] += f[i][j][S]) %= ha;
					if(j>0 && !((S>>(j-1))&1)) (f[ii][jj][S|(1<<j)|(1<<(j-1))] += f[i][j][S]) %= ha;
				}
			}
		}
	}
	FOR(i,u,::n){
		FOR(S,0,(1<<m)-1){
			(g[u][l][r][i] += f[i-u+1][0][S]) %= ha;
		}
	}
	FOR(i,0,n+1) FOR(j,0,m+1) FOR(S,0,(1<<m)) f[i][j][S] = 0;
}

int F[MAXN],pc[(1<<MAXN)+3];
std::vector<int> now;

int main(){
	scanf("%d%d",&n,&m);
	FOR(i,1,n) scanf("%s",str[i]+1);
	FOR(i,1,n) FOR(l,1,m) FOR(r,l,m) Solve(i,l,r);
	int ans = 0;
	FOR(S,0,(1<<(n-1))-1){
		CLR(F,0);
		now.clear();
		FOR(i,0,n-2) if((S>>i)&1) now.pb(i+1);
		int las = 0;F[0] = 1;int t = 1;
		FOR(i,1,m){
			t = 1;las = 0;
			for(auto x:now){
				t = 1ll*t*g[las+1][1][i][x]%ha;
				las = x;
			}
			if(n != las) t = 1ll*t*g[las+1][1][i][n]%ha;
			F[i] = t;
			FOR(j,1,i-1){ // [j+1,i]
				t = 1;las = 0;
				for(auto x:now){
					t = 1ll*t*g[las+1][j+1][i][x]%ha;
					las = x;
				}
				if(n != las) t = 1ll*t*g[las+1][j+1][i][n]%ha;
				t = 1ll*t*F[j]%ha;
				(F[i] += ha-t) %= ha;
			}
		}
		if(now.size()&1) F[m] = ha-F[m];
		(ans += F[m]) %= ha;
		// DEBUG(ans);DEBUG(res);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：dAniel_lele (赞：9)

考虑容斥，钦定一些相邻列和相邻行之间没有骨牌。设分别有 $i,j$ 个，那么系数就是 $(-1)^{i+j}$。

对于每个原矩阵的子矩阵，计算出在其中随意放骨牌的方案数。具体地，枚举左端点，右端点，上端点，设计轮廓线 $f_{i,S}$ 表示看到 $i$ 位置，目前最低下一行是否填骨牌的情况为 $S$。对于转移，考虑 $i$ 位置不选/选一个向左的骨牌/选一个向上的骨牌即可。

容易发现这样 dp 的复杂度是 $O(2^mn^2m^2)$，常数很小。

此时的瓶颈在于前半部分的容斥，复杂度为 $O(2^{n+m})$。考虑对 $n$ 边 dp 边容斥。设计 $g_i$ 表示看到第 $i$ 行每个相邻行都有骨牌的方案数。转移时，钦定 $i\sim j$ 是一个连续段，使用预处理的 dp 出来的方案数转移即可。这部分复杂度 $O(2^mn^2m)$。

总复杂度 $O(2^mn^2m^2)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int mod=19901013;
char c[16][16];
int res[16][16][16][16],dp[2][32768],n,m;
void calc(int l,int r,int sp){
	int len=(r-l+1);
	memset(dp,0,sizeof(dp));
	dp[0][(1<<len)-1]=1;
	int t=0;
	for(int i=sp;i<=n;i++){
		for(int j=l,k=1;j<=r;j++,k++){
		    for(int p=0;p<(1<<len);p++) dp[t^1][p]=0;
			for(int p=0;p<(1<<len);p++){
				if(c[i][j]=='x'){
					(dp[t^1][p|(1<<(k-1))]+=dp[t][p])%=mod;
				}
				else{
					if((!((p>>(k-1))&1))){
						(dp[t^1][p|(1<<(k-1))]+=dp[t][p])%=mod;
					}
					if(k!=1&&(!((p>>(k-2))&1))){
						(dp[t^1][p|(1<<(k-1))|(1<<(k-2))]+=dp[t][p])%=mod;
					}
					(dp[t^1][p&((1<<len)-(1<<(k-1))-1)]+=dp[t][p])%=mod;
				}
			}
			t^=1;;
		}
		for(int p=0;p<(1<<len);p++) (res[sp][i][l][r]+=dp[t][p])%=mod;
	}
}
int tdp[16];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>c[i][j];
	for(int i=1;i<=m;i++) for(int j=i;j<=m;j++) for(int k=1;k<=n;k++) calc(i,j,k);
	int ans=0;
	for(int i=0;i<(1<<(m-1));i++){
		memset(tdp,0,sizeof(tdp));
		tdp[0]=mod-1;
		for(int j=1;j<=n;j++){
			for(int k=0;k<j;k++){
				int lst=1,tr=1;
				for(int l=1;l<=m-1;l++){
					if((i>>(l-1))&1){
						(tr*=res[k+1][j][lst][l])%=mod;
						lst=l+1;
					}
				}
				(tr*=res[k+1][j][lst][m])%=mod;
				(tdp[j]+=mod-tdp[k]*tr)%=mod;
			}
		}
		if(__builtin_popcount(i)&1){
			(ans+=mod-tdp[n])%=mod;
		}
		else{
			(ans+=tdp[n])%=mod;
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：xiao7_Mr_10_ (赞：5)

很有意思的一道轮廓线 dp 例题。

但我选择讲明白一种状态压缩和充斥的做法，之前的两篇题解已经有一篇是讲解了这种做法的，我也看了那一篇题解，受益匪浅，想用自己的语言讲明白这道题。
 
首先，我们回忆蒙德里安的梦想那道题：用 $1 \times 2$ 的长方形铺满 $n \times m$ 的网格一共能有多少种可能呢？

对于那一道题目，我们可以设 $f(i,j)$ 为当前加的点是地图上位于 $(i,j)$ 的格子有多少种可能，便可以用状态压缩的方法直接计算，这不是我们今天的主题，所以不过多的赘述。

那这道题和蒙德里安的梦想有什么关系呢？很明显，我们需要求解出每一个子矩阵内没有任何限制铺设骨牌的答案，其实就相当于求解多次蒙德里安的梦想问题。为了方便后面的讲解，我们把这个子矩阵的答案设为 $dp(i,j,k,m)$。

然后我们开始考虑子集容斥，但如果都用子集容斥的话复杂度就是 $2 ^{n+m} $  的，这听上去就很爆炸，那怎么办呢?

考虑一下代表元容斥，但很显然也不行，因为枚举了第一个没有横跨的行后，求的是状态分割线上边和下边均有骨牌跨过去的答案，而我们要求的是分割线上边和下边至少有一个有列横跨的答案，这种做法不符合我们的要求。

所以我们得双管齐下，对列用子集容斥，行用代表元容斥。枚举哪些列的夹缝没有骨牌横跨，那我们就记 $f(i)$ 为矩阵前 $i$ 行的合法总答案,可以理解吧？

我们发现这个状态还不够，它不能表示第 $i$ 行到第 $j$ 行任意摆放骨牌且不横跨夹缝的方案数。

什么意思呢？就是说我们还需要记算一个 $g(i,j)$ 表示第 $i$ 行到第 $j$ 行任意摆放骨牌而且骨牌的摆放不横跨夹缝的方案数。

求出每个子集的 $f(n)$ 然后进行子集容斥即可，算法整体的时间复杂度为 $O(2^n \times n^3)$。

你可能会问了，那 $g(i,j)$ 和 $f(i)$ 的转移式呢，被我吃了吗？

不是这样的，我希望您看到这里能够自己思考一下他们的转移式，毕竟自己推一推这东西还是很有意思的，如果您实在推不出来也没有关系，我在贴代码供领导您参考：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=15;
const int mod=19901013;
long long n,m,pre[N][N][N][N],dp[2][1<<N],ans,f[N],tl,cnt[1<<N],len,lastx;
pair<int,int> g[N];
char s[N][N];
void jzinit(int stx,int sty,int enx){
	int maxn=(1<<(enx-stx+1)),lastpos=0,nxtpos=1;
	for(int S = 0;S < maxn;++S)dp[0][S]=0;
	dp[0][maxn-1]=1;
	for(int i = sty;i < n;++i){
		for(int j = stx;j <= enx;++j){
			for(int S = 0;S < maxn;S++)dp[nxtpos][S]=0;
			for(int S = 0;S < maxn;S++){
				if(!dp[lastpos][S])continue;
				int state=(S<<1)&(maxn-1);
				if(!(S&(1<<(enx-stx)))&&s[i][j]=='.'&&s[i-1][j]=='.')	
					dp[nxtpos][state|1]=(dp[nxtpos][state|1]+dp[lastpos][S])%mod;
				if(!(S&1)&&s[i][j]=='.'&&j>stx&&s[i][j-1]=='.')
					dp[nxtpos][state|3]=(dp[nxtpos][state|3]+dp[lastpos][S])%mod;
				dp[nxtpos][state]=(dp[nxtpos][state]+dp[lastpos][S])%mod;
			}
			if(j==enx)
				for(int S = 0;S < maxn;S++)
					pre[stx][sty][enx][i]=(pre[stx][sty][enx][i]+dp[nxtpos][S])%mod;
			swap(lastpos,nxtpos);
		}
	}
}//这一步就是求解dp[i][j][k][l]的代码,不过在代码中dp叫pre 
int getans(int state){
	len=lastx=0;
	for(int i = 0;i < m-1;i++){
		if((1<<i)&state){
			g[++len]=make_pair(lastx,i);
			lastx=i+1;
		}
	}
	g[++len]=make_pair(lastx,m-1);	
	for(int i = 0;i < n;i++){
		f[i]=1;
		for(int j = 1;j <= len;j++)
			f[i]=(f[i]%mod*pre[g[j].first][0][g[j].second][i]%mod)%mod;
		for(int k = 0;k < i;k++){
			int now=f[k];
			for(int j = 1;j <= len;j++)
				now=(now%mod*pre[g[j].first][k+1][g[j].second][i]%mod)%mod;
			f[i]=(f[i]-now+mod)%mod;
		}
	}
	return f[n-1];
}//求解f[i]的代码 
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(int i = 0;i < n;i++) 
		cin >> s[i];
	for(int i = 0;i < 1<<(m-1);i++)cnt[i]=cnt[i>>1]+(i&1);
	for(int i = 0;i < m;i++)
		for(int j = 0;j < n;j++)
			for(int k = i;k < m;k++)
				jzinit(i,j,k);
	for(int i = 0;i < 1<<(m-1);i++){
		if(cnt[i]&1)ans=(ans-getans(i)+mod)%mod;
		else ans=(ans+getans(i))%mod;//子集容斥 
	}
	cout << ans;
	return 0;
}
```


---


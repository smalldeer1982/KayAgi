# [HNOI2014] 道路堵塞

## 题目背景

### 本题可能不存在正确解法，题解均已被 hack。

## 题目描述

A 国有 $N$ 座城市，依次标为 $1$ 到 $N$。同时，在这 $N$ 座城市间有 $M$ 条单向道路，每条道路的长度是一个正整数。现在，A 国交通部指定了一条从城市 $1$ 到城市 $N$ 的路径，并且保证这条路径的长度是所有从城市 $1$ 到城市 $N$ 的路径中最短的。不幸的是，因为从城市 $1$ 到城市 $N$ 旅行的人越来越多，这条由交通部指定的路径经常发生堵塞。现在 A 国想知道，这条路径中的任意一条道路无法通行时，由城市 $1$ 到 $N$ 的最短路径长度是多少。

## 说明/提示

$100\%$ 的数据满足 $2 < N < 100000$，$1 < M < 200000$，$c \in [0, 10000] \cap \mathbb{Z}$。

数据已加强 By Vfleaking。

2023.4.8 添加两组 hack 数据。

## 样例 #1

### 输入

```
4 5 2
1 2 2
1 3 2
3 4 4
3 2 1
2 4 3
1 5```

### 输出

```
6
6```

# 题解

## 作者：JohnJoeZhu (赞：147)

由于题解很少加上讲解都好精炼，蒟蒻琢磨了好久，于是贡献一片题解

~~（前方多图预警）~~

[题面传送门](https://www.luogu.com.cn/problem/P3238)

[博客体验应该不会更佳](https://www.luogu.com.cn/blog/JohnJoeZHU/solution-p3238)

### 1.化简题意

在有向正边权图中，给出 $1$ 到 $n$ 最短路径经过的边，求每删除有且只有一条边后的最短路

### 2.寻找解法

从题意上我们得不到直观的求解方式或思路（仅提供最短路这一思考方向），那我们就寻找题目性质

首先模拟题意，接下来是探索性质的思考过程，以图片形式呈现，各位大佬可以选择阅读或自行探究，结论探讨总结会在4幅图后呈现



------------
**探索开始**

原图（最短路用红色表明，题目已知）
![](https://cdn.luogu.com.cn/upload/image_hosting/tbfy6qtf.png)

断开第一条边（紫色为答案，绿色为可行解，下面同理）

![](https://cdn.luogu.com.cn/upload/image_hosting/ya17ew4d.png)

断开第二条边

![](https://cdn.luogu.com.cn/upload/image_hosting/s3ngr4tc.png)

断开第三条边

![](https://cdn.luogu.com.cn/upload/image_hosting/lspqpiy0.png)

**探索结束**


------------
**结论开始**

（由于图片展示有限，各位大佬可以模拟更长的路径，可以得到同样的结论）

咦，我们发现答案的边都是在最短路上跑一点，然后跳出来，又回到最短路也！

那是不是就是这个性质呢？

首先，我们先大胆猜想，然后再简单证明

（绿色为答案路径，紫色为非答案路径）

![](https://cdn.luogu.com.cn/upload/image_hosting/xs2h7tmu.png)

那不能够走紫色这条边吗？

显然，如果我们走路径k，那么对于最短路i到j，就会有更优解路径k来代替原来的路径，那路径k就成了最短路了

显然这与题意不符

可是真的只会绕一个弯吗？

显然题目要求我们**只**断一条边，所以即便是绕路，也只用绕一个弯，绕多个弯就不优了，这个可以结合上面的证明感性理解。

所以我们就得到性质：

对于答案路径，一定是在原最短路上走一段路，然后从最短路上一点绕开断路，走到最短路上另一点，再继续走最短路，回到终点。

如图所示

![](https://cdn.luogu.com.cn/upload/image_hosting/logyuu6f.png)

形式化的：

$$
\text{对于} edge_{i-j},\text{答案路径为}1-x_u-x_v-n 
$$
$$
\text{其中}x_u<i,x_v>j,\text{且}1-x_u,x_v-n\text{属于原最短路径},x_u-x_v\text{不属于原最短路径且使答案最优}
$$

注意此时的大于和小于是指我们对最短路上的点编号后的结果

### 3.解法实现

说了这么多性质，到底如何实现呢？？？

显然我们不可能对每一条边断开后**单独**求解

那我们就考虑是不是答案有传递性，相互之间的贡献，或者任何共同性可以减少复杂度的

那我们的性质就要派上用场了 ~~（废话~~

我们发现，我们的绕路都是从一个地方跳出来，然后再回去

从$1-n$的顺序遍历，如果前面的路径也绕开了这条边，我们是不是就可以使用呢？

显然，之前的答案对于现在是有贡献的，但是不一定是最优的

所以我们是不是还要从这条断边的起点SPFA一次，获得这个点对答案（也就是绕开路径）的贡献

那答案是否有有限的贡献范围呢？

显然，如果这一条远路没有绕开断边，对后面的答案都没有贡献了

所以绕远路的终点，也就是回到最短路上的点，需要比现在的断边的终点大

然后我们又发现，断边的枚举是递增的

每次插入一个比现在大的点和权值，然后寻找最小的权值且满足要求

动态维护一个最小值，支持删除插入，时间复杂度在$O(log\space n)$左右，我们就可以突发奇想，想到**小根堆！**


------------

接下来整理解法

- 存图+对最短路上的点顺序编号+求到终点的最短路值（后面会用到）

- 顺序枚举最短路上的点

- 对于当前的点，SPFA寻找后继节点

由于这里找到最短路上的点后需要快速得到到终点的长度，并插入堆

所以预处理一个到终点的最短路值，同时减少没有必要的尝试，减少时间

- 从堆顶取出元素，如果路径没有绕过断边，踢出堆

- 如果堆顶无元素，输出-1，否则输出解

- 更新到当前点的最短路（之前走的都是绕远路来的）

- 如果这一条边的终点是n，结束

其实就是这幅图啦

![](https://cdn.luogu.com.cn/upload/image_hosting/logyuu6f.png)

### 4.时间复杂度简析

蒟蒻只会简单分析，有错请指正

设最短路上有$n_1$个点，不在最短路上有$n_2$个点

枚举断边$O(n_1)$

每一个断边最坏需要$O(n_2\space m)$

那复杂度就需要$O(n_1\space n_2\space m)$

还有一个堆的复杂度$O(log n_1)$

貌似很大，但是每一次拓展，堆理论的大小都会减小，SPFA的拓展也越来越有限，而且这理论上是一个稀疏图

综上，复杂度为$O(\text{玄学能过})$

只要常数好，就卡得过

~~所以这是一段瞎扯~~

### 5.代码

还是这个最重要

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int read()//蒟蒻不太会快读（雾）
{
	int ans=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') 
	{
		if(ch=='-') f*=-1;
		ch=getchar();
	}
	ans=ch-'0';
	ch=getchar();
	while(ch>='0'&&ch<='9') ans*=10,ans+=ch-'0',ch=getchar();
	return ans;
}
const int N=2e5+5;
int n,m,l;
int num[N],rode[N],dis1[N],disn[N],along[N];
struct edge{
	int u,v,nex,w;
}edge[N<<1];
struct node{
	int u,dis;
	node(int uu,int diss){u=uu,dis=diss;}
	bool operator <(const node &x)const{
		return dis>x.dis;//注意符号，我们要小根堆
	}
};
priority_queue<node>s;
int head[N],top=0;
void add(int u,int v,int w)//日常加边
{
	edge[++top].v=v;
	edge[top].u=u;
	edge[top].w=w;
	edge[top].nex=head[u];
	head[u]=top;
}
bool vis[N],viss[N<<1];
void SPFA(int S)//日常SPFA
{
	queue<int>q;
	for(int i=1;i<=n;i++) vis[i]=0;
	q.push(S);
	vis[S]=1; 
	while(!q.empty())
	{
		int u=q.front(); q.pop(); 
		vis[u]=0;
		for(int i=head[u];i;i=edge[i].nex)
		{
			int v=edge[i].v;
			if(!viss[i]&&dis1[v]>dis1[u]+edge[i].w)//不能过原最短路上的边，保证只走远路
			{
				dis1[v]=dis1[u]+edge[i].w;
				if(num[v]) s.push(node(num[v],dis1[v]+disn[num[v]]));//跑回最短路就插入堆
				else if(!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
}
int main()
{
	n=read(),m=read(),l=read();
	for(int i=1,u,v,w;i<=m;i++) u=read(),v=read(),w=read(),add(u,v,w);
	for(int i=1;i<=l;i++)//标记最短路
	{
		rode[i]=read();
		along[i+1]=edge[rode[i]].v;//记录点
		num[along[i+1]]=i+1;//对最短路上的点编号
		viss[rode[i]]=1;//记录最短路的边
	} 
	for(int i=l;i;i--) disn[i]=disn[i+1]+edge[rode[i]].w;//求出到n点的最短距离
	memset(dis1,0x3f,sizeof(dis1));//到1点的最短路，服务于SPFA
	dis1[1]=0;
	along[1]=1;
	SPFA(1);
	for(int i=1;i<=l;i++)
	{
		while(!s.empty()&&s.top().u<=i) s.pop();//没有绕开断边
		printf("%d\n",s.empty()?-1:s.top().dis);//用堆求解
		dis1[edge[rode[i]].v]=dis1[edge[rode[i]].u]+edge[rode[i]].w;//更新到1点的最短路，服务于SPFA
		SPFA(edge[rode[i]].v);
	}
	return 0;//完结撒花
}
```

看在这么长的题解+图片上，点个赞再走嘛。

---

## 作者：HNYLMS_MuQiuFeng (赞：26)

## 感谢@Fenghr与@rockyyh大佬为本蒟蒻提供了思路 ##


本文的思路同样也是下面这样一个结论：

## 当你删掉某条边(u,u+1)时，最短路路线为：1->x(<=u)->y(>u)->n,并且x->y一定不会属于原最短路。##

所以按照这个证明的思想，我们枚举删掉最短路上的哪条边，然后把这条边的s加进队列做SPFA。

但是：我们看到这是一道黑题，而且是HNOI，那怎么可能会让你轻松过呢？

所以我们要优化。

先把最短路上的所有边都BAN掉，然后从S到T开始恢复边，并把s丢进队列。然后每次就可以不清空dis数组了，因为你之前SPFA的结果你都可以调用以前的结果。

然后统计答案就是把走到的钦定最短路上的点的距离加上它到T的距离取个min就好了。这里有一个玄妙的做法就是把答案加上这个点放成结构体扔进堆里，每次弹出到达点在s之前的点因为这是在这条路被BAN的时候SPFA到的，不一定是当前的合法方案，也不会比最优答案更好。所以判完-1后，第一个在s之后的点就不管是不是s更新的点了，却又是一个合法的点，就避免了很多麻烦（摘自@Fenghr大佬的博客）
  
所以显而易见，用一个优先队列就可以解决了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>

using namespace std;

int head[200010], dis[200010], n, m, l, tot;
int vis[200010];
int stu[200010], rk[200010], s[200010], from[200010]；
int g[200010];

struct edge {
	int next, from, to, wt;
} a[1000010];

struct node {
	int to, val;
	bool operator < (const node &fff) const {
		return val > fff.val;
	}//重载 < 运算符
};

priority_queue <node> st;

inline void add (int u, int v, int w) {
	a[++ tot] = (edge) {head[u], u, v, w};
	head[u] = tot;
}//简单的链式前向星

inline void spfa (int sa) {
	queue <int> q;
	q.push (sa);
	vis[sa] = 1;
	while (! q.empty ()) {
		int k = q.front ();//之前手残打成了q.empty()【还查了10min（捂脸）】（我是煞笔）
		q.pop ();
		vis[k] = 0;
		for (int i = head[k]; i; i = a[i].next) {
			if (stu[i])//当其无法通行时
				continue;
			int to = a[i].to;
			if (dis[to] > dis[k] + a[i].wt) {
				dis[to] = dis[k] + a[i].wt;
				if (from[to])
					st.push ((node) {from[to], dis[to] + g[from[to]]});//扔进优先队列
				else if (! vis[to]) 
					q.push (vis[to] = to);
			}
		}
	}
}

int main (void) {
	ios::sync_with_stdio (0);
	cin.tie (0);
	cout.tie (0);

	cin >> n >> m >> l;
	for (int i = 1, u, v, w; i <= m; ++ i) {
		cin >> u >> v >> w;//加边
		add (u, v, w);
	}
	for (int i = 1; i <= l; ++ i) {
		cin >> rk[i];//最短路径上的路
		stu[rk[i]] = 1;//它有可能会堵车
		s[i + 1] = a[rk[i]].to;//最短路径上的点
		from[s[i + 1]] = i + 1;
	}
	for (int i = l; i >= 1; -- i) {
		g[i] = g[i + 1] + a[rk[i]].wt;//原最短路上第i个点到第n个点的最短路
	}
	memset (dis, 127 / 3, sizeof (dis));
	dis[1] = 0;
	from[1] = s[1] = 1;//最短路径上的第一个点
	spfa (1);
	for (int i = 1; i <= l; ++ i) {
		while (! st.empty () and st.top ().to <= i)
			st.pop ();
		if (st.empty ())
			cout << -1 << endl;//由上的分析
		else
			cout << st.top ().val << endl;
		dis[a[rk[i]].to] = dis[s[i]] + a[rk[i]].wt;
		spfa (s[i + 1]);//一个个枚举（题目要求）
	}
	return 0;//愉快地AC啦~\(≧▽≦)/~
}
```

希望这篇题解对各位有所帮助！

## 杜绝抄袭，从我做起！##

---

## 作者：Halberd_Cease (赞：13)

昨天从上午写到晚上，晚上调代码的时候被大佬吊打了（指20分钟切爆），于是有了这篇题解。

## 分析：

题目中有一个很重要的一点：**给出的路径是最短路径**，后面所有的分析都建立在其之上。

先把结论搬出来：

删去任意的一条边后，其最短路一定是走过原最短路的一部分，绕过删去的边，最后回到原最短路上继续走，直到终点。

也就是说，删边后的最短路有且仅有一个连续部分不在原最短路上。

证明：

如果删掉后的最短路有两段或以上不在原来的最短路上，那么肯定有一段或以上绕开的最短路不包含被删掉的边，也就是说题目给出的最短路并不是最短路，这显然不成立，可以参考下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ovix026g.png)

然后题目就很简单了，对于每一个在给定最短路径上的节点，在不跑给定最短路上的任意一条边的条件下，如果扩展到的节点是最短路上的节点，就将答案压进小根堆里，最后将堆里不符合要求的答案删除，堆顶就是答案。

还有几个注意事项：

- 对于压进的答案，$ans_i$ 表示从起点出发，在中途某一点绕路，然后在 $i$ 点回到原最短路的最小距离，$b_i$ 表示从 $i$ 点到终点的距离，压进的答案包括两个值，分别为 $i$ 和 $ans_i+b_i$；

- 在输出时，如果堆顶的 $i$ 小于或等于当前枚举的点在原最短路上的编号，也就是说这个答案在当前枚举点或之前就已经回到了原最短路上，无法避开当前删除的边，就要删掉该答案；

- 我们的 $b$ 数组要经过预处理，在原最短路上的点要离散化；

- 在每一次最短路后要手动更新当前 $ans_i$ 的值，因为我们是在删去边的基础上跑的最短路，现在边恢复了，值自然也要更新。

然后，就没有了。

## Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,l;
int cnt;
int ans[100010];
int b[100010];
int s[100010];
struct E{
	int from,to,dis,nxt;
}edge[200010];
struct Node{
	int id ,dis;
	friend bool operator < (Node x,Node y){
		return x.dis>y.dis;
	}
};
bool vis[100005],bvis[200005];
int head[200010],to[100005];
queue<int>k;
priority_queue<Node>q;
void add(int f,int t,int dis)
{
	++cnt;
	edge[cnt].dis=dis;
	edge[cnt].from=f;
	edge[cnt].to=t;
	edge[cnt].nxt=head[f];
	head[f]=cnt;
}
void insert(int id,int dis)
{
	q.push((Node){id,dis});
}
void sp(int s)
{
    memset(vis,0,sizeof(vis));
    vis[s]=1;
    k.push(s);
    while(!k.empty())
    {
        int u=k.front();k.pop();vis[u]=0;
        for(int i=head[u];i!=-1;i=edge[i].nxt)
        {
            int v=edge[i].to,w=edge[i].dis;
            if(!bvis[i]&&ans[u]+w<ans[v])
            {
                ans[v]=ans[u]+w;
                if(to[v])
                    insert(to[v],ans[v]+b[to[v]]);
                else if(!vis[v])
                {
                    vis[v]=1;
                    k.push(v);
                }
            }
        }
    }
}
signed main()
{
	memset(head,-1,sizeof(head));
	memset(ans,127,sizeof(ans));
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>l;
	int u,v,w;
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v>>w;
		add(u,v,w);
	}
	for(register int i=1;i<=l;i++)
	{
		cin>>s[i];
		bvis[s[i]]=1;
		to[edge[s[i]].to]=i+1;
	}
	to[1]=1;ans[1]=0;
	for(register int i=l;i>0;i--)
		b[i]=b[i+1]+edge[s[i]].dis;
	sp(1);
	for(register int i=1;i<=l;i++)
	{
		while(!q.empty()&&q.top().id<=i)q.pop();
		cout<<((!q.empty())?q.top().dis:-1)<<'\n';
		ans[edge[s[i]].to]=ans[edge[s[i]].from]+edge[s[i]].dis;
		sp(edge[s[i]].to);
	}
}
```

---

## 作者：LinkyChristian (赞：13)

**每周文章计划 2021.12 第三周**

管理求过

**定义**：

$dis_i$ ： $1 \sim i$ 的最短路

$dist_i$ ： $n \sim i$ 的最短路
 
$u,v,w$ ：边的两个端点以及边权

$pre_u$ ：$u$ 在最短路上的前驱点

$preedge_u$ ：$u$ 在最短路上的前驱边

$l_u,r_u$ ：经过 $u$ 点的最短路与原最短路重合的前缀长度，经过 $u$ 点的最短路与原最短路重合的后缀长度。

-----

**题目大意**

给你一个 $n$ 个点，$m$ 条边的无向图，每条边连接点 $u$、$v$，并且有个长度 $w$ 。

有$q$次询问，每次询问给你一对 $t$、$x$, 表示仅当前询问下，将 $t$ 这条边的长度修改为 $x$，请你输出当前 $1$ 到 $n$ 的最短路长度。

**数据范围**

$2 \le n \le 2\times10^5$

$1 \le m, q \le 2\times10^5$

$1 \le w_i,x_i \le 10^9$

首先由于这是最短路问题，我们先求出 $1 \sim n$ 的最短路。

考虑将一条边边权修改为无限，如果这条边不在最短路上显然对答案没有任何影响，所以只考虑修改在最短路上的情况。这样修改原来的最短路有可能不是最短路，但如果用最短路之外的边修改又不知道用哪条边修改。

~~当然是丢回去重新跑一遍最短路啊~~

为了解决这个问题，我们先给出一个结论:

**从 $1 \sim n$ ，经过一条边的最短路径，肯定有一段前缀以及一段后缀和最短路重合**

换而言之，就是与最短路不重合的部分最多只有一段，且是连续的。

**证明：** 如果有多于一段与原最短路不重合，那么这些段中必然只有一段包含 $\{u,v\}$ ，其他段改成原最短路上的路径就会使总路程更小，则假设不成立

那么得知了这个结论后，我们可以知道经过 $u$ 点的最短路，就是不经过第 $[l_u+1,r_u-1]$ 的最短路，换算到边 $\{u,v\}$ 上，就是不经过边 $[l_u+1,r_v-1]$ 和 $[l_v+1,r_u-1]$ 的边

看到区间操作，第一反应必然是用线段树 ~~不会是平衡树吧~~ ，因此我们可以写一颗非常短的维护最小值的线段树，然后维护不经过最短路上每条边时的最短路，在讯问时查询不经过边 $\{u,v\}$ 的最短路是否比 $dis_n-w_{last}+w_{new}$ 短即可。

## 具体实现

首先是记下最短路，我们从 $n$ 跳 $pre$ ,一直跳到 $1$ ，记录下 $preedge$ 即可。

对于最短路上的每个点，$l_u$ 为最短路上链接到自己的边，$r_u$ 为最短路上自己延伸出去的边。

然后做两遍 Dij ，一遍从 $1 \sim n$，一遍从 $n \sim 1$，$l_u$ 和 $r_u$ 分别从第一遍和第二遍的前驱继承即可。

至此本道题完全做完。

---

## 作者：MarchKid_Joe (赞：9)

# [P3238 [HNOI2014]道路堵塞](https://www.luogu.com.cn/problem/P3238 "P3238 [HNOI2014]道路堵塞")

## 前言

基于打破题解区被 SPFA 算法霸凌的局面，对无人问津的 Dijkstra 思路的代码实现，即对 @[LinkyChristian](https://www.luogu.com.cn/user/124918 "LinkyChristian") 大佬题解的修正与完善。况且这个算法时间效率很高，希望推广一下这个思路。

顺便提供一个双倍经验：[CF1163F Indecisive Taxi Fee](https://www.luogu.com.cn/problem/CF1163F "CF1163F Indecisive Taxi Fee")。

## 题目

给定一个 $n$ 个点 $m$ 条单向边的有向图，还给定了 ${1}\to{n}$ 最短路径经过的边的编号。每次询问（询问间相互独立）删去最短路径上的一条边后，新的 ${1}\to{n}$ 最短路径是多少？

## Solution

### 变量解释

**原最短路径**：题目中给定的最短路径。

**原编号**：题目输入的边的顺序的编号。

**新编号**：对原最短路径上的边重新编号，具体编号方式见下述。

- $dis_{x,y}$：${x}\to{y}$ 的最短路径长度。

- $I_{x}$：**原编号**为 $x$ 的边是否在最短路径上：若为 $0$，则代表不在；否则，由 ${1}\to{n}$ 的**原最短路径**经过的边依次**从大到小** $[l,1]$ 重新编号。记 $[1,l]$ 的编号为**新编号**。

- $L_x$：从 $x$ 点连出的**最小**的原最短路径上的边的**新编号**。

- $R_x$：从原最短路径上的边连入 $x$ 点**最大**的**新编号**。

### 思路

首先有个很显然的结论，对于**必须**经过一条连接着 ${x}\to{y}$ 的单向边，权值为 $w(x,y)$，${1}\to{n}$ 的最短路径长度为：

$$
dis_{1,n}=dis_{1,x}+w(x,y)+dis_{y,n}
$$

此时就要使用到上述的变量 $L_x,R_x$。根据变量的定义，必须经过 $x$ 点的最短路径是不经过 $[L_x+1,R_x-1]$ 这段**新编号**区间的边的，换句话说就是绕过了这一段**原最短路径**上的边。

那再转化到边上，对于一条**非原最短路径**上的边连接着 ${x}\to{y}$，我们就需要更新 $[L_y+1,R_x-1]$ 这段区间的权值为 $dis_{1,x}+w(x,y)+dis_{y,n}$。

翻译一下就是：连入 $x$ 的**原最短路径**上的边和从 $y$ 连出的**原最短路径**上的边，他们之间的**原最短路径**上的边是可以不用经过的，那不经过这段**原最短路径**上的边的权值就可以更新为 $dis_{1,x}+w(x,y)+dis_{y,n}$。

最后查询时就是每次查询不经过某一条原最短路径上的边，新的最短路径最小值。

### 解法

现在要求这些变量：

#### 最短路径长度

$dis_{1,x}$：$1$ 到任意点的最短路径。这个好处理，直接沿着**正边**从 $1$ 跑一遍 Dijkstra 最短路径就可以求出。

$dis_{x,n}$：任意点到 $n$ 的最短路径。建立反图，沿着**反边**从 $n$ 跑一遍 Dijkstra 最短路径就可以求出。

#### 连入及连出某一点的原最短路径上的边的新编号

$L_x$：因为要求最小值，初始化为极大值，$L_n$ 初始为 $0$。从 $n$ 出发，沿反图跑最短路径。设当前点为 $u$，其可以到达的节点为 $v$，然后从 $I$ 和 $L_u$ 更新：若 $I$ 不是**原最短路径**上的边，只能从 $L_u$ 更新；否则从 $I$ 转移。

$R_x$：因为要求最大值，初始化为极小值，$R_1$ 初始为 $l+1$。从 $1$ 出发，沿原图跑最短路径。设当前点为 $u$，其可以到达的节点为 $v$，然后从 $I$ 和 $R_u$ 更新：若 $I$ 不是**原最短路径**上的边，只能从 $L_u$ 更新；否则从 $I$ 转移。

Code 参考：

处理 $R$，跑**原图**：

```cpp
if (dis[v] == dis[u] + e[i].w) // 路径权值相同就取 max
{
    if (I[i]) // 是原最短路径边直接转移
        R[v] = max(R[v], I[i]);
    else // 否则只能继承
        R[v] = max(R[v], R[u]);
}
if (dis[v] > dis[u] + e[i].w) // 路径更优直接覆盖
{
    if (I[i]) // 是原最短路径边直接转移
        R[v] = I[i];
    else // 否则只能继承
        R[v] = R[u];
    dis[v] = dis[u] + e[i].w;
}
```

处理 $L$，跑**反图**：

```cpp
if (dis[v] == dis[u] + e[i].w) // 路径权值相同就取 min
{
    if (I[i]) // 是原最短路径边直接转移
        L[v] = min(L[v], I[i]);
    else // 否则只能继承
        L[v] = min(L[v], L[u]);
}
if (dis[v] > dis[u] + e[i].w) // 路径更优直接覆盖
{
    if (I[i]) // 是原最短路径边直接转移
        L[v] = I[i];
    else // 否则只能继承
        L[v] = L[u];
    dis[v] = dis[u] + e[i].w;
}
```

#### 不经过某条原最短路径上的边的新 ${1}\to{n}$ 最短路径最小值

已经求出了 $L$ 和 $R$，只要枚举所有的**正边**，这条正边连接 $x\to y$，把 $[L_y+1,R_x-1]$ 这段区间的权值更新为 $dis_{1,x}+w(x,y)+dis_{y,n}$。也就是一个区间取 $\min$ 操作，用线段树维护最小值，区间修改，单点查询。

Code 参考：

显然用线段树维护最小值，区间修改，单点查询这段代码很简单，直接跳过就行了。

```cpp
namespace Segment
{
    #define lc(i) (i << 1)
    #define rc(i) (i << 1 | 1)
    #define lmid ((l + r) >> 1)
    #define rmid ((l + r + 2) >> 1)
    int tr[N << 2]， tag[N << 2];
    inline void change(const int &i, const int &val)
    {
        tr[i] = min(tr[i], val);
        tag[i] = min(tag[i], val);
    }
    inline void push_down(const int &i)
    {
        if (tag[i] != INF)
        {
            change(lc(i), tag[i]);
            change(rc(i), tag[i]);
            tag[i] = INF;
        }
    }
    inline void update(int i, int l, int r, int cl, int cr, int val)
    {
        if (l > cr || r < cl) return void();
        if (l >= cl && r <= cr) return change(i, val);
        push_down(i);
        update(lc(i), l, lmid, cl, cr, val);
        update(rc(i), rmid, r, cl, cr, val);
    }
    inline int query(int i, int l, int r, int x)
    {
        if (l == r) return tr[i];
        push_down(i);
        if (x <= lmid) return query(lc(i), l, lmid, x);
        if (x >= rmid) return query(rc(i), rmid, r, x);
    }
}
using namespace Segment;
```

### 疑问

Q：但是为什么要 $L_x$ 尽量小，$R_x$ 尽量大呢？

A:$L$ 越小 $R$ 越大，更新的值域就越大，更新的越多，答案自然就会更优，因此我们让他尽量绕过更多的**原最短路径**上的边。

## Code

删去了一些基础内容，保留了代码框架。完整代码：[click here.](https://www.luogu.com.cn/paste/084aylo3 "click here")

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5 + 5;
namespace IO{/*Quick Read and Write*/}
using namespace IO;
namespace chain{/*链式前向星*/}
using namespace chain;
namespace Segment/*维护区间最小值*/
{
    inline void update(int i, int l, int r, int cl, int cr, int val){}
    inline int query(int i, int l, int r, int x){}
}
using namespace Segment;
struct type
{
    int x;
    int y;
    friend bool operator<(const type &A, const type &B){return A.y > B.y;}
    type(int x = 0, int y = 0) : x(x), y(y){}
};
int n, m, k;
int rode[N];
int I[N << 2], L[N], R[N];
int dis1[N], dis2[N];
bool vis[N];
inline void dij(int s, int *dis) // 代码核心，求 L,R
{
    priority_queue<type> q;
    memset(vis, false, sizeof(vis));
    dis[s] = 0;
    if (s == n)
        fill(L + 1, L + n + 1, k + 1), L[s] = 0;
    if (s == 1)
        fill(R + 1, R + n + 1, 0), R[s] = k + 1;
    q.push(type(s, 0));
    while (!q.empty())
    {
        int u = q.top().x;
        q.pop();
        if (vis[u])
            continue;
        vis[u] = true;
        for (int i = head[u]; i; i = e[i].nxt)
        {
            if ((i & 1) ^ (s == n)) // 判正反边
                continue;
            int v = e[i].v, ID = I[i] ? I[i] : (k + 1) * (s == 1);
            /*这里为了减少些 if，所以这样写，其实和上面的参考代码里 if 分类讨论时等价的。*/
            if (dis[v] == dis[u] + e[i].w)
            {
                if (R[v] < min(R[u], ID) && s == 1)
                    R[v] = min(R[u], ID);
                if (L[v] > max(L[u], ID) && s == n)
                    L[v] = max(L[u], ID);
            }
            if (dis[v] > dis[u] + e[i].w)
            {
                if (s == 1)
                    R[v] = min(R[u], ID);
                if (s == n)
                    L[v] = max(L[u], ID);
                dis[v] = dis[u] + e[i].w;
                q.push(type(v, dis[v]));
            }
        }
    }
}
signed main()
{
    memset(dis1, 0x3f, sizeof(dis1));
    memset(dis2, 0x3f, sizeof(dis2));
    read(n, m, k);
    for (int i = 1, u, v, w; i <= m; i++)
    {
        read(u, v, w);
        add(u, v, w);
        add(v, u, w);
    }
    for (int i = 1; i <= k; i++)
    {
        read(rode[i]);
        I[(rode[i] << 1)] = I[(rode[i] << 1) ^ 1] = k - i + 1; // 从大到小编号。
    }
    dij(1, dis1); //原图。
    dij(n, dis2); //反图。
    for (int i = 2; i <= ecnt; i += 2) // 只枚举正边。
    {
        if (I[i]) continue;
        int u = e[i].u, v = e[i].v;
        if (L[v] + 1 <= R[u] - 1)
            update(1, 1, k, L[v] + 1, R[u] - 1, dis1[u] + e[i].w + dis2[v]); //更新区间最小值
    }
    for (int i = 1; i <= k; i++)
    {
        int ans = query(1, 1, k, I[rode[i] << 1]); // 查询不走当前边的最短路径
        write(ans == 0x3f3f3f3f ? -1 : ans, '\n');
    }
    return 0;
}
```

## 后言

冒昧地指出@[LinkyChristian](https://www.luogu.com.cn/user/124918 "LinkyChristian") 大佬题解的一个小错误：本题为**有向图**，而 [CF1163F Indecisive Taxi Fee](https://www.luogu.com.cn/problem/CF1163F "CF1163F Indecisive Taxi Fee") 为**无向图**，所以枚举边时**不能用反边更新**，**只能用正边更新**。也就是不能用 $dis_{1,y}+w(y,x)+dis_{x,n}$ 更新 $[L_x+1,R_y-1]$ 这段区间。否则，这题就 ```Wrong``` 了，成功 get $20$ 分。而且，这个做法跑了 $290\operatorname{ms}$ 左右。

辛苦管理员的审核，有问题可以指出，极力改正。

---

## 作者：Paul·Shi (赞：6)

如果暴力删边SPFA时间复杂度为O（N * M）（下界），时间稳稳的超限，所以我们要想优化的方法。

最短路集 X[i] （i∈L） X[1]为起点，X[L]为终点

非最短路集 Y[i] （Y[i] ∉ X）

首先有一个性质，如果删掉了一条最短路上的边，那么新的最短路一定是：

X1 ->······ -> Xj -> Y -> Xk ······ -> Xn

即 当前的从1到n的最短路只能是从1出发，在最短路径上走一段，再走一段非最短路，最后回到最短路径上。

那么我们对每一个点求出其到终点未删边的距离，在从该点spfa一遍即可。

代码：

```cpp
#include<bits/stdc++.h>
#define INF 2147483647
#define MAXN 100010
#define MAXM 200010
using namespace std;
struct edge{
	int v,w,nxt;
}e[MAXM];
struct Node{
	int id,dis;
	bool operator < (const Node &rhs) const
	{
		return dis>rhs.dis;
	}
}a[MAXN];
int n,m,l,cnt;
int path[MAXN],pos[MAXN];
int head[MAXN],st[MAXN];
int f[MAXN],g[MAXN];
int dist[MAXN],stk[MAXN],p;
bool used[MAXN],vis[MAXN];
void add (int u,int v,int w)
{
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
priority_queue<Node>heap;
queue<int>q;
void spfa (int s,int w,int id,int lct)
{
	memset (vis,0,sizeof (vis));
	q.push (s);used[s]=1;
	dist[s]=w;p=0;
	while (!q.empty ())
	{
		int u=q.front ();
		q.pop ();used[u]=0;
		for (int i=head[u];i!=0;i=e[i].nxt)
			if (i!=id)
			{
				if (pos[e[i].v]>lct)
				{
					if (!vis[pos[e[i].v]])
					{
						vis[pos[e[i].v]]=1;
						stk[++p]=e[i].v;
						a[e[i].v].id=pos[e[i].v];
						a[e[i].v].dis=dist[u]+e[i].w+g[pos[e[i].v]];
					}
					else
						a[e[i].v].dis=min (a[e[i].v].dis,dist[u]+e[i].w+g[pos[e[i].v]]);
				}
				else if (dist[e[i].v]>dist[u]+e[i].w)
				{
					dist[e[i].v]=dist[u]+e[i].w;
					if (!used[e[i].v])
					{
						q.push (e[i].v);
						used[e[i].v]=1;
					}
				}
			}
	}
	while (p) heap.push (a[stk[p--]]);
}
int main()
{
	scanf ("%d%d%d",&n,&m,&l);
	for (int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf ("%d%d%d",&u,&v,&w);
		add (u,v,w);
	}
	st[1]=pos[1]=1;
	for (int i=1;i<=l;i++)
	{
		scanf ("%d",&path[i]);
		pos[e[path[i]].v]=i+1;
		st[i+1]=e[path[i]].v;
	}
	for (int i=2;i<=l;i++)
		f[i]=f[i-1]+e[path[i-1]].w;
	for (int i=l;i>=1;i--)
		g[i]=g[i+1]+e[path[i]].w;
	for (int i=1;i<=n;i++)
		dist[i]=INF;
	for (int i=1;i<=l;i++)
	{
		spfa (st[i],f[i],path[i],i);
		while (!heap.empty ()&&heap.top ().id<=i)
		{
			vis[heap.top ().id]=0;
			heap.pop ();
		}
		if (heap.empty ()) printf ("-1\n");
		else printf ("%d\n",heap.top ().dis);
	}
	return 0;
}
```

---

## 作者：1ink (赞：5)

~~出完题后快三个月然后发现自己出重题了[我的题目](https://www.luogu.com.cn/problem/T192305)~~

## 题意简述
给定有向正权图，多次询问删除 $1$ 到 $n$ 的最短路链上的一条边后 $1$ 到 $n$ 的最短路，不存在则输出 $-1$。

## 题目分析

首先观察到一个性质：
**答案必定是任取一条非最短路径树边，从 $1$ 出发走到其一端点，使用这条边跳到另一端点，走到 $n$。**  
$Ans=\min\{Dis_{1->u}+W_{u->v}+Dis_{v->n}\}$  
证明：由于只删除一条树边，则只需要使用一条非树边翻越一个点；设其为点 $s$；则选择的非树边必然有一条边 $u->v$，满足 $dep_u>dep_s, dep_s>dep_v$。 则其他边对答案没有贡献，不如走树边，因此只需要走一条非树边；  
  
我们先分别预处理出来以 $1$ 号点和 $n$ 号点为根的最短路径树（后者需要建反向图），然后考虑每条非树边对于哪些答案存在贡献：  
设边为 $u->v$，则可以翻越从 $1$ 走到 $u$ 所经过的给定链上的最深点的子节点到从 $v$ 走到 $n$ 所经过的给定链上的最浅点。
关于经过的链上最深/浅点如何预处理，可以看代码：
```cpp
void getd(int u,int from){
	top[u]=from;
	for(foredge(i))
    		if(!dep[v]&&edges[i].in) 
        		dep[v]=dep[u]+1,getd(v,onlist[v]?v:from);
}
```

那么对于每条非树边所产生的贡献，可以用线段树来维护。
### 复杂度分析
使用dijkstra求最短路树时复杂度为 $O(m \log m)$，线段树复杂度则为  $O(n \log n)$，总复杂度为 $O(m \log m)$。
## 代码
```cpp
#include <bits/stdc++.h>
#define F(i,a,b) for(ll i=a;i<=b;i++)
#define ll long long
#define UF(i,a,b) for(ll i=a;i>=b;i--)
#define Pii pair<int,int>
#define lc pos<<1
#define rc pos<<1|1
#define foredge(i) int i=head[u],v=edges[i].to;i;i=edges[i].nxt,v=edges[i].to
using namespace std;
const ll N=100005,M=200005;
ll read(){
	ll x=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x;
}
void write(ll x){
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
void write(ll x,char c){
	if(x<0) putchar('-'),write(-x);
	else write(x);
	putchar(c);
}
int onlst[N];
struct Graph{
	struct Edge{
		int to,nxt,w,in;
		Edge(int a=0,int b=0,int c=0){
			nxt=a,to=b,w=c;
		}
	}edges[N<<1];
	int epos,head[N];
	void add(int u,int v,int w=0){
		edges[++epos]=Edge(head[u],v,w);
		head[u]=epos;
	}
	struct Pos{
		int p,w,from,d;
		Pos(int a=0,int b=0,int c=0){
			p=a,w=b,from=c;
		}
		bool operator<(const Pos &b)const{
			return w>b.w;
		}
	};
	int dis[N],in[N],dep[N],top[N];
	void dij(int s){
		memset(dis,0x3f,sizeof(dis));
		memset(in,0,sizeof(in));
		dis[s]=0;
		priority_queue<Pos> q;
		q.push(Pos(s,0));
		while(!q.empty()){
			Pos nw=q.top();
			q.pop();
			int u=nw.p;
			if(in[u]) continue;
			in[u]=1, edges[nw.from].in=1;//最短路径树边
			for(foredge(i)){
				int tow=nw.w+edges[i].w;
				if(dis[v]>tow){
					dis[v]=tow;
					q.push(Pos(v,tow,i));
				}
			}
		}
	}
	void getd(int u,int from){//处理每个点所经过的最值链上点
		top[u]=from;
		for(foredge(i)) if(!dep[v]&&edges[i].in) dep[v]=dep[u]+1,getd(v,onlst[v]?v:from);
	}
}g1,g2;
struct SegmentTree{//线段树维护最小值
	int mn[N<<2],ltag[N<<2];
	void init(){
		memset(mn,0x3f,sizeof(mn));
		memset(ltag,0x3f,sizeof(ltag));
	}
	void up(int pos){
		mn[pos]=min(mn[lc],mn[rc]);
	}
	void down(int pos){
		mn[lc]=min(mn[lc],ltag[pos]),mn[rc]=min(mn[rc],ltag[pos]);
		ltag[lc]=min(ltag[lc],ltag[pos]),ltag[rc]=min(ltag[rc],ltag[pos]);
		ltag[pos]=0x3f3f3f3f;
	}
	void modify(int pos,int l,int r,int tl,int tr,int k){
		if(l>=tl&&r<=tr){
			mn[pos]=min(mn[pos],k), ltag[pos]=min(ltag[pos],k);
			return;
		}
		int mid=l+r>>1;
		down(pos);
		if(mid>=tl) modify(lc,l,mid,tl,tr,k);
		if(mid<tr) modify(rc,mid+1,r,tl,tr,k);
		up(pos);
	}
	int query(int pos,int l,int r,int tl,int tr){
		if(l>=tl&&r<=tr) return mn[pos];
		down(pos);
		int mid=l+r>>1,ans=0x3f3f3f3f;
		if(mid>=tl) ans=min(ans,query(lc,l,mid,tl,tr));
		if(mid<tr) ans=min(ans,query(rc,mid+1,r,tl,tr));
		return ans;
	}
}seg;
int n,m,l;
int q[M];
int main(){//必然是1->x1的最短路+单独的边x1->x2+n->x2的最短路
	n=read(),m=read(),l=read();
	F(i,1,m){
		int u=read(),v=read(),w=read();
		g1.add(u,v,w),g2.add(v,u,w);
	}
	F(i,1,l) q[i]=read(),g1.edges[q[i]].in=1;
	F(u,1,n){
		for(int i=g1.head[u];i;i=g1.edges[i].nxt){
			int v=g1.edges[i].to;
			if(g1.edges[i].in){
				g1.edges[i].in=0;
				onlst[u]=onlst[v]=1;
			}
		}
	}
	g1.dij(1),g2.dij(n);
	g1.dep[1]=1,g1.getd(1,1);
	seg.init();
	//n->x2最短路一定是x2->x3与x3->n,后半部分与给定的1->n链重叠,则预处理出反向图所有点到n经过的链上最高点
	g2.dep[n]=1,g2.getd(n,n);
	F(u,1,n){
		for(int i=g1.head[u];i;i=g1.edges[i].nxt){
			int v=g1.edges[i].to;
			int l=g1.dep[g1.top[u]]+1,r=g1.dep[g2.top[v]];//答案的贡献区间
			if(g1.edges[i].in) continue;
			seg.modify(1,1,n,l,r,g1.dis[u]+g1.edges[i].w+g2.dis[v]);//答案
		}
	}
	F(i,1,l){
		int ans=seg.query(1,1,n,g1.dep[g1.edges[q[i]].to],g1.dep[g1.edges[q[i]].to]);//每条边下放到目标节点
		if(ans<1e9+10) write(ans,'\n');
		else write(-1,'\n');//无解
	}
	return 0;
}
```

---

## 作者：JoaoFelix (赞：4)

题解的代码好像都是会被卡的，但是这个思路非常妙，~~我们可以肆意骗分~~

于是也来叙述一下这道题的骗分做法，这道题应该就是满分做法orz

我们考虑给出的断边都是在最短路上的，如果断了一条边i那么我们显然之后的边都可以用，我们从这个目前的起点开始spfa，（~~既然是玄学算法，我们可以放心使用spfa~~）

我们记录在最短路上的点都是关键点，然后假设最短路上有k条边，那么我们会有k+1个关键点，假设我们当前删到第i条边，那么我们的前i个关键点就算走到了，不一定会能找到最短路，但是如果走到底i+1以后的关键点，我们就不需要继续往下走了，我们可以用当前记录一个suf数组来直接加速它，这个算法大概就是这样的流程。

然后按照次序spfa，每次维护一个优先队列，代表走到哪个关键更新的，以及当前更新出来的最短路是多少。

我们每次到i个时候如果关键点是前i个的我们都要pop掉，因为有可能会经过当前被删的边。

然后我们发现当前的最短路一定会在之前的某次spfa经过，可以意会一下。

这个算法的复杂度感觉很大，其实飞快。

代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define pii pair<int,int>
using namespace std;
const int N=1e5+5,M=2e5+5,Inf=1e9;
struct Graph{int u,v,w;}gra[M];
struct Edge{int to,w,nxt;}e[M];
int n,m,l,fst[N],tote,a[N],pre[N],suf[N],dis[N];
bool usd[N],ban[M],inq[N];
priority_queue<pii>Ans;
void adde(int u,int v,int w){e[++tote]=(Edge){v,w,fst[u]};fst[u]=tote;}
void spfa(int s){
	queue<int>q;while(!q.empty())q.pop();
	q.push(s);inq[s]=true;
	while(!q.empty()){
		int u=q.front();q.pop();inq[u]=false;
		if(usd[u]){Ans.push(pii(-dis[u]-suf[u],u));continue;}
		for(int i=fst[u],v,w;i;i=e[i].nxt){
			v=e[i].to;w=e[i].w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				if(!inq[v])inq[v]=true,q.push(v);
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&l);
	for(int i=1,u,v,w;i<=m;i++)scanf("%d%d%d",&gra[i].u,&gra[i].v,&gra[i].w);
	for(int i=1;i<=l;i++)scanf("%d",&a[i]),usd[gra[a[i]].u]=usd[gra[a[i]].v]=ban[a[i]]=true;
	for(int i=1;i<=m;i++)if(!ban[i])adde(gra[i].u,gra[i].v,gra[i].w);
	for(int i=1;i<=l;i++)pre[gra[a[i]].v]=pre[gra[a[i]].u]+gra[a[i]].w;
	for(int i=l;i;i--)suf[gra[a[i]].u]=suf[gra[a[i]].v]+gra[a[i]].w;
	for(int i=1;i<=n;i++)dis[i]=Inf;
	for(int i=1,u;i<=l;i++){
		u=gra[a[i]].u;dis[u]=pre[u];usd[u]=false;spfa(u);
		while(!Ans.empty()&&!usd[Ans.top().second])Ans.pop();
		if(Ans.empty())puts("-1");else printf("%d\n",-Ans.top().first);
	}
	return 0;
}

```


---

## 作者：CmsMartin (赞：2)

[更好的阅读体验](http://cmsblog.top/archives/hnoi2014-dao-lu-du-sai)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P3238)

## 思路

首先有一个结论：**删除边后的最短路一定是在最短路上跑一段，然后跳出最短路，然后再跑一段**。换言之，就是不在最短路上跑的路径一定是一段连续的路径，不会存在两段及以上（如果两段相等，假设选择原最短路上的路径）。

证明：

这个结论是我猜出来的，现在给出简要证明。

记 $\operatorname{dis}(i)$ 表示路径 $i$ 的长度,$\operatorname{dis}(i,j)$ 表示边 $i \to j$ 的长度。 

一条路径表示为 $i=a\to b \to \cdots \to z$

给定一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gzcbongu.png)

这张图中我们假设 $i=1 \to 4 \to 5\to 8$ 是最短路，当 $1 \to 4$ 断开时，我们选定了 $j=1 \to 2 \to 3 \to 4 \to 5 \to6 \to 7 \to 8$ 为最短路，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ylhcsrk.png)

（图中原最短路由红色标出，现在的最短路由绿色标出）

设 $k = 1 \to 2 \to 3 \to 4 \to 5 \to 8$

由于绿色是断开后的最短路，由最短路定义有：

$$\operatorname{dis}(j) \le \operatorname{dis}(k)$$

则有

$$\operatorname{dis}(5,6) + \operatorname{dis}(6,7)+\operatorname{dis}(7,8) \le \operatorname{dis}(5,8)$$

那么在原图中

$$1 \to 4 \to 5 \to 6 \to 7 \to 8$$ 

才是最短路（如果两段相等，假设选择原最短路上的路径），产生矛盾。

证毕。

接下来讲实现。

我们先以 $1$ 为起点 $n$ 为终点跑一遍 SPFA，并且此时不走给定最短路上的边。然后开始枚举最短路上的点，把它丢进队列，跑 SPFA（dist 数组可以不清空）。

然后每次走到给定最短路上的点，就把这个当前到它的最短路和它到终点的距离（通过最短路到达）丢进一个堆里。每次输出答案前，如果堆的顶部的点在最短路上的位置在当前枚举的的边前，就弹出。最后输出堆顶（如果没有，即为 $-1$）。最后把枚举的这条边加进原图，更新这个点出边的 dist。

具体看代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 10;
const int MAXM = 2e5 + 10;

int Head[MAXN];
struct _ {
	int Next , To , Value;
} G[MAXM];
int Cnt = 0;

void Add(int u , int v , int w) {
	G[++Cnt]= {Head[u] , v , w};
	Head[u] = Cnt;
}

struct Node {
	int To , Value;
	bool operator < (const Node &o) const {
		return Value > o.Value;
	} 
};

int Dist[MAXN];

priority_queue<Node> Heap;

bool Vis[MAXN] , Cannot_Use[MAXM];

int Edge[MAXN];

int Id[MAXN] , Path_Value[MAXN] , Path_Point[MAXN] , N , M , L;

void SPFA(int s) {
	queue<int> q;
	q.push(s); 
	Vis[s] = true;
	
	while(q.size()) {
		int u = q.front();
		q.pop();
		Vis[u] = false;
		for(int i = Head[u]; i ; i = G[i].Next) {
			if(Cannot_Use[i]) {
				continue;
			}
			int v = G[i].To;
			if(Dist[v] > Dist[u] + G[i].Value) {
				Dist[v] = Dist[u] + G[i].Value;
				if(Id[v]) {
					Heap.push({Id[v] , Dist[v] + Path_Value[Id[v]]});
				}
				else if(!Vis[v]) {
					Vis[v] = true;
					q.push(v);
				}
			}
		}
	}
}

int main() {
	memset(Dist , 0x3f , sizeof Dist);
	
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> N >> M >> L;
	for(int i = 1 , u , v , w; i <= M; i++) {
		cin >> u >> v >> w;
		Add(u , v , w);
	}
	
	for(int i = 1; i <= L; i++) {
		cin >> Edge[i];
		Path_Point[i + 1] = G[Edge[i]].To;
		Cannot_Use[Edge[i]] = true;
		Id[Path_Point[i + 1]] = i + 1;
	}
	
	for(int i = L; i >= 1; i--) {
		Path_Value[i] = Path_Value[i + 1] + G[Edge[i]].Value;
	}
	
	Dist[1] = 0;
	Id[1] = 1;
	Path_Point[1] = 1;
	
	SPFA(1);
	
	for(int i = 1; i <= L; i++) {
		while(Heap.size() && Heap.top().To <= i) {
			Heap.pop();
		}
		if(Heap.size()) {
			cout << Heap.top().Value << endl;
		}
		else {
			cout << -1 << endl;
		}
		
		Dist[Path_Point[i + 1]] = Dist[Path_Point[i]] + G[Edge[i]].Value;
		
		SPFA(Path_Point[i + 1]);
	}
	return 0; 
} 
```

---

## 作者：zzw4257 (赞：2)

### 题意
>给定有向图和$1\rightarrow n$的一个最短路，求删去这个最短路上任意一条边求最短路

### Solution

考虑最短路上每个点到$1$的最短路$pre_x$和到$n$的最短路$pre_x$

则$\text{ban}$掉$x\rightarrow y$这条边后答案变为$pre_x+x$到原最短路上点$z$次短路$+suf_z$

实现就在原本的$SPFA$数据上用堆删除之前的边

```cpp
#include<bits/stdc++.h>
#define re register
#define N 100001
using namespace std;
#define G if(++ip==ie)if(fread(ip=ibuf,1,L,stdin))
const int L=1<<19;
char ibuf[L],*ie=ibuf+L,*ip=ie-1;
inline char nc(void){G;return *ip;}
//#define getchar nc
inline int read(void){
	re char opt;re int flag=1,res=0;
	while((opt=getchar())<'0')if(opt=='-')flag=-1;
	while(opt>='0'){res=(res<<3)+(res<<1)+opt-'0';opt=getchar();}
	return res*flag;
}
typedef long long ll;
struct edge{int x,y,z;}a[N<<1];
struct Edge{int to,v;};
struct Node{int v,pos;inline char operator<(re Node a)const{return v>a.v;};};
priority_queue<Node>ans;
vector<Edge>g[N];
int pre[N],suf[N],dis[N],n,m,l,s[N<<1];
char vis[N],used[N],ban[N<<1];
inline void SPFA(re int S){
	re int x,y,v;re queue<int>q;q.push(S),vis[S]=1;
	while(!q.empty()){
		vis[x=q.front()]=0,q.pop();
//		printf("%d:%d\n",x,used[x]);
		if(used[x]){ans.push({dis[x]+suf[x],x});continue;}//到了$(s_i,s_l]$这些点上后直接续接后缀 
		for(re auto t:g[x]){
			y=t.to,v=t.v;
//			printf("%d->%d %d\n",x,y,v);
			if(dis[y]>dis[x]+v){dis[y]=dis[x]+v;if(!vis[y])vis[y]=1,q.push(y);}
		}
	}
}
signed main(void){
	re int i;n=read(),m=read(),l=read();
	for(i=1;i<=m;++i)a[i]={read(),read(),read()};
	for(i=1;i<=l;++i)s[i]=read(),ban[s[i]]=used[a[s[i]].x]=used[a[s[i]].y]=1;
	for(i=1;i<=m;++i)if(!ban[i])g[a[i].x].push_back({a[i].y,a[i].z});
	for(i=1;i<=l;++i)pre[a[s[i]].y]=pre[a[s[i]].x]+a[s[i]].z;
	for(i=l;i>=1;--i)suf[a[s[i]].x]=suf[a[s[i]].y]+a[s[i]].z;
	memset(dis,0x3f,sizeof dis);
	for(i=1;i<=l;++i){
		dis[a[s[i]].x]=pre[a[s[i]].x];used[a[s[i]].x]=0;
		SPFA(a[s[i]].x);
		while(!ans.empty()&&!used[ans.top().pos])ans.pop();
		printf("%d\n",ans.size()?ans.top().v:-1);
	}
    return 0;
}
```

---


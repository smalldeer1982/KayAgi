# [CQOI2017] 小Q的草稿

## 题目描述

Q 是个程序员。

众所周知，程序员在写程序的时候经常需要草稿纸。小 Q 现在需要一张草稿纸用来画图，但是桌上只有一张草稿纸，而且是一张被用过很多次的草稿纸。

草稿纸可以看作一个二维平面，小 Q 甚至已经给它建立了直角坐标系。以前每一次草稿使用过的区域，都可以近似的看作一个平面上的一个三角形，这个三角形区域的内部和边界都不能再使用。当然了，以前的草稿也没有出现区域重叠的情况。

小 Q 已经在草稿纸上画上了一些关键点，这些关键点都在没使用过的区域。小 Q 想把这些关键点两两之间尽可能的用线段连接起来。连接两个关键点的线段有可能会穿过已经用过的草稿区域，这样显然不允许。于是小 Q 就想知道，有多少对关键点可以被线段连接起来，而且还不会穿过已经用过的区域。为了方便，小 Q 保证任意三个关键点不会共线。


## 说明/提示

【输入输出样例 1 说明】

整个草稿纸是全新的，任意两个关键点都可以连线。

【输入输出样例 2 说明】

如图所示，任意两个关键点的连线都被挡住了。

 ![](https://cdn.luogu.com.cn/upload/pic/5011.png) 

【数据规模与约定】

对于 100%的测试点，0 ≤ 所有坐标 ≤ $10^8$，且都是整数。

```cpp
NO 1  2  3   4   5   6   7    8    9   10
V 10 20 50 100 200 400 600 1000 1000 1000
T 10 20 50 100 200 400 600 1000 1000 1000
```

## 样例 #1

### 输入

```
3 0
0 0
2 0
2 2```

### 输出

```
3```

## 样例 #2

### 输入

```
3 1
0 0
2 0
2 2
1 0 1 1 2 1```

### 输出

```
0```

# 题解

## 作者：5ab_juruo (赞：5)

给一种不需要 set 的做法。

考虑数关键点之间的连线与多少个三角形相交。显然线段可以拆成两条射线答案的差，且射线的起点都是关键点。

同时注意到，当射线起点固定时，三角形的限制等价于极角的一段区间，代表这一段答案要加一。

枚举关键点作为射线起点，将所有要求的射线方向和三角形贡献的起点、终点按极角排序，扫描线即可。注意端点也要算进去。如果有跨越 $0,2\pi$ 的贡献，则可以拆成两段来算。

复杂度 $\mathcal{O}(n(n+m)\log(n+m))$。

```cpp
const int max_n = 1000, max_m = 1000;

struct point
{
	int x, y;
	friend istream& operator>>(istream& is, point& p)
	{
		is >> p.x >> p.y;
		return is;
	}
	bool operator<(const point& rhs) const
	{
		if ((rhs.x > 0) ^ (x > 0))
			return x < rhs.x;
		return 1ll * y * rhs.x < 1ll * x * rhs.y;
	}
}
p[max_n], a[max_m], b[max_m], c[max_m];
vector<pair<point, int>> qc;
int f[max_n][max_n];

signed main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int n, m;
	
	cin >> n >> m;
	for (int i = 0; i < n; i++)
		cin >> p[i];
	for (int i = 0; i < m; i++)
		cin >> a[i] >> b[i] >> c[i];
	qc.reserve(n + m * 3);
	
	int ans = 0;
	for (int i = 0; i < n; i++)
	{
		qc.clear();
		for (int j = 0; j < i; j++)
			qc.emplace_back(point{ 2 * p[i].x - p[j].x, 2 * p[i].y - p[j].y }, j);
		for (int j = i + 1; j < n; j++)
			qc.emplace_back(p[j], j);
		
		for (int j = 0; j < m; j++)
		{
			point x[3] = { a[j], b[j], c[j] };
			sort(x, x + 3, [&](point lhs, point rhs) {
				return 1ll * (rhs.y - p[i].y) * (lhs.x - p[i].x) > 1ll * (rhs.x - p[i].x) * (lhs.y - p[i].y);
			});
			if (point{ x[0].x - p[i].x, x[0].y - p[i].y } < point{ x[2].x - p[i].x, x[2].y - p[i].y })
			{
				qc.emplace_back(x[0], -1);
				qc.emplace_back(x[2], n);
			}
			else
			{
				qc.emplace_back(point{ p[i].x, int(2e8) }, -1);
				qc.emplace_back(x[2], n);
				qc.emplace_back(x[0], -1);
			}
		}
		
		for (auto &[pt, _] : qc)
			pt.x -= p[i].x, pt.y -= p[i].y;
		sort(qc.begin(), qc.end());
		
		int cnt = 0;
		for (auto [_, x] : qc)
		{
			if (x == -1)
				cnt++;
			else if (x == n)
				cnt--;
			else if (x < i)
				ans += (cnt == f[x][i]);
			else
				f[i][x] = cnt;
		}
	}
	
	cout << ans << endl;
	
	return 0;
}
```

---

## 作者：quantum11 (赞：5)

把三角形拆成三条线段，以每个点为中心，极角排序，扫描线，用set维护线段，优先级为到中心点的距离，三角形不相交，相对顺序不变 ，查一下最近的线段是否挡住了，否则有贡献。

三角形的三条边实际上只有一条边有用。 

```
#include<bits/stdc++.h>
#define il inline
#define rint register int
using namespace std;
typedef double db;
const int N=5005;
const db PI=acos(-1.0),eps=1e-8;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
il int read() {
	rint x=0;
	char c=getchar();
	for(; !isdigit(c); c=getchar());
	for(; isdigit(c); c=getchar()) x=(x+(x<<2)<<1)+c-48;
	return x;
}
il int sgn(db a) {
	if(fabs(a)<eps) return 0;
	return a<0?-1:1;
}
struct P {
	db x,y,ag;
	P(db x=0,db y=0):x(x),y(y) {}
	il db dis() {
		return sqrt(x*x+y*y);
	}
	il void get() {
		ag=atan2(y,x);
	} il void Read() {
		x=read(),y=read();
	}
	il friend P operator +(P A,P B) {
		return P(A.x+B.x,A.y+B.y);
	}
	il friend P operator -(P A,P B) {
		return P(A.x-B.x,A.y-B.y);
	}
	il friend db operator *(P A,P B) {
		return A.x*B.y-A.y*B.x;
	}
	il friend P operator *(P A,db B) {
		return P(A.x*B,A.y*B);
	}
	il friend db dot(P A,P B) {
		return A.x*B.x+A.y*B.y;
	}
	il bool operator <(const P &B) const {
		return ag<B.ag;
	}
	il friend P I(P a1,P a2,P b1,P b2) {
		db t=((b2-b1)*(a1-b1))/((a2-a1)*(b2-b1));
		return a1+(a2-a1)*t;
	}
} tt,_p[N],p[N],_t[N][3],t[N][3];
int tot,n,m,ans,pt,sg;
struct SS {
	P u,v;
	SS() {} SS(P u,P v):u(u),v(v) {}
	bool operator <(const SS& B) const {
		return I(u,v,P(0,0),tt).dis()<I(B.u,B.v,P(0,0),tt).dis();
	}
} S[N];
multiset<SS> s;
multiset<SS>::iterator it[N];
struct E {
	int f,idx;
	db ag;
	E() {} E(int f,int idx,db ag):f(f),idx(idx),ag(ag) {}
	bool operator <(const E &B) const {
		return sgn(ag-B.ag)==0?f>B.f:sgn(ag-B.ag)<0;
	}
} ev[N];
il void Solve() {
	tot=0;
	for(rint i=1; i<=sg; ++i) ev[++tot]=E(1,i,S[i].u.ag),ev[++tot]=E(0,i,S[i].v.ag);
	sort(p+1,p+pt+1);
	sort(ev+1,ev+tot+1);
	s.clear();
	rint ret=0,j=1;
	for(rint i=1; i<=pt; ++i) {
		while(j<=tot &&(sgn(ev[j].ag-p[i].ag)<0 ||(sgn(ev[j].ag-p[i].ag)==0 && ev[j].f))) {
			if(ev[j].f) tt=S[ev[j].idx].u,it[ev[j].idx]=s.insert(S[ev[j].idx]);
			else tt=S[ev[j].idx].v,s.erase(it[ev[j].idx]);
			++j;
		}
		if(s.empty()) {
			++ret;
			continue;
		}
		tt=p[i];
		db dis=I((*s.begin()).u,(*s.begin()).v,0,tt).dis();
		if(sgn(p[i].dis()-dis)<=0) ++ret;
	}
	ans+=ret;
}
int main() {
	n=read(),m=read();
	for(rint i=1; i<=n; ++i) _p[i].Read();
	for(rint i=1; i<=m; ++i) for(rint j=0; j<3; ++j) _t[i][j].Read();
	for(rint i=1; i<=n; ++i) {
		pt=sg=0;
		for(rint j=i+1; j<=n; ++j) (p[++pt]=_p[j]-_p[i]).get();
		for(rint j=1; j<=m; ++j) {
			for(rint k=0; k<3; ++k) t[j][k]=_t[j][k]-_p[i];
			db ma=0;
			P u,v;
			for(rint k=0; k<3; ++k) {
				db ag=dot(t[j][k],t[j][(k+1)%3])/t[j][k].dis()/t[j][(k+1)%3].dis();
				ag=acos(ag);
				if(ag>ma) ma=ag,u=t[j][k],v=t[j][(k+1)%3];
			}
			u.get();
			v.get();
			if(u.ag>v.ag) swap(u,v);
			if(v.ag-u.ag<PI) S[++sg]=SS(u,v);
			else {
				P tmp=I(u,v,P(0,0),P(-1.0,0));
				S[++sg]=SS(tmp,u),S[sg].u.ag=-PI,S[++sg]=SS(v,tmp),S[sg].v.ag=PI;
			}
		}
		Solve();
	}
	return !printf("%d",ans);
}
```

---

## 作者：xiaomimxl (赞：3)

# 题目大意：

在一张空白的草稿纸中连点，不能经过一些区域

# 思路分析：

### 解题思路
显然需要 $O(n^2)$ 枚举每个点对，然后判断对答案是否有贡献

问题在于如何快速确定是否被三角形的边阻拦

枚举一个中心点 $o$ 将所有其他点都对它求一个极角

然后对于平面上的每一个三角形，拆成三条边

显然只需要拿出三条边中对点 $o$ 限制得最紧的那个

这里的限制是在被覆盖的角度中任取一点，这个位置上这条边到oo点的距离

这条边显然是两端点对于 $o$ 张角最大的那个

那么每条边就处理成两个事件，在极角 $\alpha$ 处添加，在极角 $\beta$ 处删除

对于任意的两条边，肯定是一个时间段一条边对 $o$ 限制得比另一条边更紧些

而且时间段不会分裂成很多块

因为对于边 $A$，如果在某个时刻限制得比 $B$ 更紧了，那么直到它们中某一条被删除，这个情况是持续的

因为任意两个三角形不相交，也就等于任意两条边不相交
于是，对于当前未被删除的边集，显然可以拿出一个 ```set``` 来维护

注意 ```set``` 中的比较函数是动态的

总复杂度 $O(n^2 \log n)$

### 细节处理: 
(1)对于一个三角形只有与当前枚举点的线段夹角最大的两条边有用。

(2)如果遇到跨过极角序分界点 $-\pi$ 或 $\pi$ 显然可以拆成两条线段。

### 精度问题:

由于 ```set``` 判相等会有精度误差，因此尽量不用 ```find()``` , 可以记下来每条直线插入到 ```set``` 中的位置。另外除了求交点距离之外的部分全都可以不用 ```double``` 实现.

### 常数问题: 

注意一定不能在排序比较函数里调用三角函数！

# Code:

```cpp
#include<bits/stdc++.h>
#define llong long long
using namespace std;
 
inline int read()
{
    int x=0; bool f=1; int c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=0;
    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');
    if(f) return x;
    return -x;
}
 
const int N = 1000;
const double PI = acos(-1);
const double EPS = 1e-8;
inline int dcmp(double x) {return x<-EPS?-1:(x>EPS?1:0);}
struct Point
{
    llong x,y;
    Point() {}
    Point(llong _x,llong _y) {x = _x,y = _y;}
    inline double ang() const {return atan2(y,x);}
};
typedef Point Vector;
inline Point operator +(const Point &x,const Point &y) {return Point(x.x+y.x,x.y+y.y);}
inline Point operator -(const Point &x,const Point &y) {return Point(x.x-y.x,x.y-y.y);}
inline llong Dot(const Point &x,const Point &y) {return x.x*y.x+x.y*y.y;}
inline llong Cross(const Point &x,const Point &y) {return x.x*y.y-x.y*y.x;}
inline llong EuclidDist2(const Point &x,const Point &y) {return (x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y);}
inline bool operator <(const Point &x,const Point &y) {return Cross(x,y)>0;}
struct Line
{
    Point x,y;
    Line() {}
    Line(const Point &_x,const Point &_y) {x = _x,y = _y;}
};
struct Triangle
{
    Point a[3];
};
struct Query
{
    int opt,id; Point x; double ang;
} qr[N*5+3];
Triangle b[N+3];
Point a[N+3];
Line stk[N+3];
int n,m,q;
 
Vector l;
inline bool cmp_qr(const Query &x,const Query &y) {int flg = dcmp(x.ang-y.ang); return flg<0 || (flg==0 && x.opt<y.opt);}
inline double calcdis(const Line &x)
{
    double t = (double)Cross(l,x.x)/((double)Cross(x.y-x.x,l));
    double rx = x.x.x+(x.y.x-x.x.x)*t,ry = x.x.y+(x.y.y-x.x.y)*t;
    return rx*rx+ry*ry;
}
struct Element
{
    Line x;
    Element() {}
    Element(Line _x) {x = _x;}
    inline bool operator <(const Element &arg) const
    {
        double dis1 = calcdis(x),dis2 = calcdis(arg.x);
        return dcmp(dis1-dis2)<0;
    }
};
multiset<Element> s;
multiset<Element>::iterator adr[N+3];
 
int main()
{
    scanf("%d%d",&n,&m);int ans = 0;
    for(int i=1; i<=n; i++) scanf("%lld%lld",&a[i].x,&a[i].y);
    for(int i=1; i<=m; i++) scanf("%lld%lld%lld%lld%lld%lld",&b[i].a[0].x,&b[i].a[0].y,&b[i].a[1].x,&b[i].a[1].y,&b[i].a[2].x,&b[i].a[2].y);
    for(int i=1; i<=n; i++)
    {
        q = 0; l = Vector(-1,0); Line cur;
        for(int j=1; j<=m; j++)
        {
            Point t[3];
            for(int k=0; k<3; k++) t[k] = b[j].a[k]-a[i];
            sort(t,t+3),stk[j].x = t[0],stk[j].y = t[2];
            if(stk[j].x.y>0 && stk[j].y.y<0)
            {
                adr[j] = s.insert(Element(stk[j]));
                q++; qr[q].x = stk[j].y; qr[q].id = j; qr[q].opt = 3;
                q++; qr[q].x = stk[j].x; qr[q].id = j; qr[q].opt = 1;
            }
            else
            {
                q++; qr[q].x = stk[j].x; qr[q].id = j; qr[q].opt = 1;
                q++; qr[q].x = stk[j].y; qr[q].id = j; qr[q].opt = 3;
            }
        }
        for(int j=i+1; j<=n; j++) q++,qr[q].x = a[j]-a[i],qr[q].opt = 2;
        for(int j=1; j<=q; j++) qr[j].ang = qr[j].x.ang();
        sort(qr+1,qr+q+1,cmp_qr);
        for(int j=1; j<=q; j++)
        {
            l = qr[j].x;
            if(qr[j].opt==1)
            {
                adr[qr[j].id] = s.insert(Element(stk[qr[j].id]));
            }
            else if(qr[j].opt==3)
            {
                s.erase(adr[qr[j].id]);
            }
            else if(qr[j].opt==2)
            {
                if(s.empty()) ans++;
                else
                {
                    Line mini = (*s.begin()).x;
                    double dis1 = calcdis(mini),dis2 = qr[j].x.x*qr[j].x.x+qr[j].x.y*qr[j].x.y;
                    if(dcmp(dis1-dis2)>0) ans++;
                }
            }
        }
        s.clear();
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：IC0CI (赞：1)

给出一种~~暴力~~朴素解法

## 题面分析

形式化地说，一个平面中有 $T$ 个互不重叠的三角形和 $V$ 个关键点（任意三个关键点都不共线），求有多少对关键点之间的线段不会穿过三角形。

注意到这道题的数据很小 $(T,V \le 1000)$ 且时间有 $3s$，我们可以想到很朴素的 $O(TV^2)$ 做法，即遍历每个三角形的每条边，枚举两个点 $X,Y$ 判断线段 $XY$ 是否与该边相交。

### 关于具体实现

数据较小，选择利用邻接矩阵维护两点之间是否可以连线。

我们遍历每个三角形的每条边，以该边所在的直线为界限对所有关键点进行分类，分成三类：直线的一边、直线另一边、直线上。

具体到分类的方法上，我们给出一张图，如下：

![](https://s21.ax1x.com/2025/06/15/pVAqJLd.png)

对于线段 $AB$，我们可以根据 $A、B$ 两点的坐标确定上图中的六个区域。

我们称点 $C$ 在直线的左侧，$D$ 在直线的右侧。其中区域 $2、3、4$ 明显在直线左侧，区域 $1、6、5$ 则被直线 $AB$ 分割。

若点 $E$ 落在区域 $1$ 中，计算直线 $AB、EA、EB$ 的斜率 $k、k1、k2$，容易发现：

+ 若 $E$ 在直线左侧，则 $k > k2 > k1$。
+ 若 $E$ 在直线右侧，则 $k < k2 < k1$。
+ 若 $E$ 在直线上，则 $k = k2 = k1$。

根据以上规则就能对点 $E$ 进行分类，落在区域 $5、6$ 的点也可以用类似的方法分类。

分完类后，遍历每两个点，在两个点分别处于直线左侧和右侧或同在直线上时，若没有标记，判断两点的连线是否与当前线段相交，若相交就打上标记记录为不可连线。

遍历完所有三角形后，遍历邻接矩阵统计答案。

### 一些优化（常数）

1. 我们不需要遍历每一对点，可以临时存储分类的结果遍历临时存储的内容。这样可以把 $O(T^2)$ 的遍历优化为 $O(\frac{1}{4}T^2)$。
2. 统计答案可以用容斥原理统计。

# Code

代码没有使用上述优化方案，仍能以较宽裕时间通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define db double

db rd() //快读省略

int n,m;
struct node
{
    db x,y;
}a[1005];
struct tri
{
    db x1,y1,x2,y2,x3,y3;
}t[1005];
bool vis[1005][1005];
int col[1005];
int ans;
const db eps = 1e-8;

db K(node x,node y){ return (db)(y.y - x.y) / (db)(y.x - x.x); }
db crossx(node p1,node p2,node p3,node p4)
{
    auto [x1,y1] = p1;
    auto [x2,y2] = p2;
    auto [x3,y3] = p3;
    auto [x4,y4] = p4;
    db denominator = (y2 - y1) * (x3 - x4) - (y4 - y3) * (x1 - x2);
    db x = ((x1 - x2) * (x4 * y3 - x3 * y4) - (x3 - x4) * (x2 * y1 - x1 * y2)) / denominator;
    return x;
}

void solve(node p1,node p2)
{
    if(p1.x > p2.x) swap(p1,p2);
    if(p1.x == p2.x)
    {
        for(int i = 1;i <= n;i++)
        {
            auto [x,y] = a[i];
            if(x < p1.x) col[i] = 1;
            else if(x > p1.x) col[i] = 2;
            else col[i] = 0;
        }
        for(int i = 1;i <= n;i++) for(int j = i + 1;j <= n;j++) if(!vis[i][j])
        {
            if(!col[i] && !col[j] && ((a[i].x > p2.x && a[j].x < p2.x) || (a[i].x < p1.x && a[j].x > p1.x))) vis[i][j] = vis[j][i] = 1;
            if(col[i] == col[j]) continue;
            db x = crossx(p1,p2,a[i],a[j]);
            if(p1.x - eps <= x && x <= p2.x + eps) vis[i][j] = vis[j][i] = 1;
        }
        return;
    }
    db k = K(p1,p2);
    if(k == 0)
    {
        for(int i = 1;i <= n;i++)
        {
            auto [x,y] = a[i];
            if(y > p1.y) col[i] = 1;
            else if(y < p1.y) col[i] = 2;
            else col[i] = 0;
        }
        for(int i = 1;i <= n;i++) for(int j = i + 1;j <= n;j++) if(!vis[i][j])
        {
            if(!col[i] && !col[j] && ((a[i].x > p2.x && a[j].x < p2.x) || (a[i].x < p1.x && a[j].x > p1.x))) vis[i][j] = vis[j][i] = 1;
            if(col[i] == col[j]) continue;
            db x = crossx(p1,p2,a[i],a[j]);
            if(p1.x - eps <= x && x <= p2.x + eps) vis[i][j] = vis[j][i] = 1;
        }
    }
    else if(k > 0)
    {
        for(int i = 1;i <= n;i++)
        {
            auto [x,y] = a[i];
            db k1 = K(p1,a[i]),k2 = K(p2,a[i]);
            if(fabs(k1 - k2) < eps) col[i] = 0;
            else if((x < p1.x && y > p2.y) || (x >= p1.x && x <= p2.x && y > p2.y) || (y >= p1.y && y <= p2.y && x < p1.x)) col[i] = 1;
            else if((x > p2.x && y > p2.y && k1 > k - eps && k2 > k - eps) || (x < p1.x && y < p1.y && k1 < k + eps && k2 < k + eps)) col[i] = 1;
            else if(x >= p1.x && x <= p2.x && y >= p1.y && y <= p2.y && k1 > k - eps && k2 < k + eps) col[i] = 1;
            else col[i] = 2;
        }
        for(int i = 1;i <= n;i++) for(int j = i + 1;j <= n;j++) if(!vis[i][j])
        {
            if(!col[i] && !col[j] && ((a[i].x > p2.x && a[j].x < p2.x) || (a[i].x < p1.x && a[j].x > p1.x))) vis[i][j] = vis[j][i] = 1;
            if(col[i] == col[j]) continue;
            db x = crossx(p1,p2,a[i],a[j]);
            if(p1.x - eps <= x && x <= p2.x + eps) vis[i][j] = vis[j][i] = 1;
        }
    }
    else
    {
        for(int i = 1;i <= n;i++)
        {
            auto [x,y] = a[i];
            db k1 = K(p1,a[i]),k2 = K(p2,a[i]);
            if(fabs(k1 - k2) < eps) col[i] = 0;
            else if((x < p1.x && y < p2.y) || (x >= p1.x && x <= p2.x && y < p2.y) || (y <= p1.y && y >= p2.y && x < p1.x)) col[i] = 1;
            else if((x > p2.x && y < p2.y && k1 < k + eps && k2 < k + eps) || (x < p1.x && y > p1.y && k1 > k - eps && k2 > k - eps)) col[i] = 1;
            else if(x >= p1.x && x <= p2.x && y <= p1.y && y >= p2.y && k1 < k + eps && k2 > k - eps) col[i] = 1;
            else col[i] = 2;
        }
        for(int i = 1;i <= n;i++) for(int j = i + 1;j <= n;j++) if(!vis[i][j])
        {
            if(!col[i] && !col[j] && ((a[i].x > p2.x && a[j].x < p2.x) || (a[i].x < p1.x && a[j].x > p1.x))) vis[i][j] = vis[j][i] = 1;
            if(col[i] == col[j]) continue;
            db x = crossx(p1,p2,a[i],a[j]);
            if(p1.x - eps <= x && x <= p2.x + eps) vis[i][j] = vis[j][i] = 1;
        }
    }
}

signed main()
{
    n = rd(),m = rd();
    for(int i = 1;i <= n;i++) a[i] = {rd(),rd()};
    for(int i = 1;i <= m;i++) t[i] = {rd(),rd(),rd(),rd(),rd(),rd()};
    for(int i = 1;i <= m;i++)
    {
        node p1 = {t[i].x1,t[i].y1},p2 = {t[i].x2,t[i].y2},p3 = {t[i].x3,t[i].y3};
        solve(p1,p2);
        solve(p2,p3);
        solve(p1,p3);
    }
    int ans = 0;
    for(int i = 1;i <= n;i++) for(int j = i + 1;j <= n;j++) if(!vis[i][j]) ans++;
    cout << ans;
    return 0;
}
```

_~~本以为会卡过去，没想到最慢的点也只用了时限的一半。~~_

---


# [AHOI2017/HNOI2017] 抛硬币

## 题目描述

小 A 和小 B 是一对好朋友，他们经常一起愉快的玩耍。最近小 B 沉迷于**师手游，天天刷本，根本无心搞学习。但是已经入坑了几个月，却一次都没有抽到 SSR，让他非常怀疑人生。勤勉的小 A 为了劝说小 B 早日脱坑，认真学习，决定以抛硬币的形式让小 B 明白他是一个彻彻底底的非洲人，从而对这个游戏绝望。两个人同时抛 b 次硬币，如果小 A 的正面朝上的次数大于小 B 正面朝上的次数，则小 A 获胜。

但事实上，小 A 也曾经沉迷过拉拉游戏，而且他一次 UR 也没有抽到过，所以他对于自己的运气也没有太大把握。所以他决定在小 B 没注意的时候作弊，悄悄地多抛几次硬币，当然，为了不让小 B 怀疑，他不会抛太多次。现在小 A 想问你，在多少种可能的情况下，他能够胜过小 B 呢？由于答案可能太大，所以你只需要输出答案在十进制表示下的最后 $k$ 位即可。

## 说明/提示

对于第一组数据，当小 A 抛 $2$ 次硬币，小 B 抛 $1$ 次硬币时，共有 $4$ 种方案使得小 A 正面朝上的次数比小 B 多。

$(01,0), (10,0), (11,0), (11,1)$

对于第二组数据，当小 A 抛 $3$ 次硬币，小 B 抛 $2$ 次硬币时，共有 $16$ 种方案使得小 A 正面朝上的次数比小 B 多。

$(001,00), (010,00), (100,00), (011,00), (101,00), (110,00), (111,00), (011,01)$

$(101,01), (110,01),(111,01), (011,10), (101,10), (110,10), (111,10), (111,11)$

### 数据范围

$10\%$ 的数据满足 $a,b\leq 20$。


$30\%$ 的数据满足 $a,b\leq 100$。


$70\%$ 的数据满足 $a,b\leq 10^5$，其中有 $20\%$ 的数据满足 $a=b$。


$100\%$ 的数据满足 $1\le a,b\le 10^{15}$，$b\le a\le b+10^4$，$1\le k\le 9$，数据组数小于等于 $10$。

## 样例 #1

### 输入

```
2 1 9
3 2 1```

### 输出

```
000000004
6```

# 题解

## 作者：shadowice1984 (赞：24)

过气数论魔法……

看了下网上的扩展lucas教程好像写的不是非常清楚……

反正我一开始是绕了不少弯之后才明白怎么写的……

所以就用这道题当作扩展lucas的板子吧……

__________________________

## 本题题解

首先我们把小A抛硬币的胜负情况和小B抛硬币的胜负情况看成两个01序列，然后我们把这两个01序列接起来就形成了一个长度为a+b的01序列

现在我们将原问题转化为了对01序列计数的问题

以下设小a的序列中有$W_{a}$个1，小b的序列中有$W_{b}$个1

然后我们先考虑一个比较简单的情况$a==b$

那么我们假设现在有一个胜的01序列，那么一定满足条件$W_{a}>W_{b}$，由$a==b$立即推得$a-W_{a}>b-W_{b}$，因此我们证明了任意一个胜的01序列01反转之后一定是一个负的序列

而显然平的序列01反转之后依然是平的01序列,那么我们其实只需要计算出总方案，之后减去平的方案数，最后除以2即可了……


那么我们计算平的01序列可以直接暴力枚举这个01序列中有多少1来计数，式子长这样

## $\sum_{i=1}^{a}(C_{a}^{i})^{2}=C_{2a}^{a}$

这个式子的证明下面会讲

下面我们来讨论略微复杂一点的情形，$a>b$

我们还是考虑01反转这个套路，但这时我们发现当$W_{a}>W_{b}$时我们只能推出$-W_{a}<-W_{b}$但是由于$a>b$因此我们无法比较$a-W_{a}$与$b-W_{b}$的大小，此时的情况略微的有点辣手……

但是我们反过来考虑呢？考虑一个负或者平的序列，当$W_{a}<=W_{b}$的时候我们可以推出$-W_{a}>=-W_{b}$又因为$a>b$因此我们可以立即推出$a-W_{a}>b-W_{b}$换句话说，一个负或者平的01序列反转之后一定是一个胜的01序列

因此我们发现只有部分胜的01序列反转之后还是胜的01序列，换句话来讲，只有这部分01序列没有“配对”，因此如果我们在总方案里加上这部分01序列，那么所有的胜的01序列均可以配对，此时只需要将方案数除2就是胜的01序列方案

那么我们需要找到一个条件使得胜的01序列反转之后仍然是一个胜的01序列

我们可以列出一个不等式组

## $W_{a}>W_{b}$且$a-W_{a}>b-W_{b}$

我们可以解出这样一个比较优美的形式

## $a-b>W_{a}-W_{b}>0$

那么我们呢就可以通过枚举$W_{b}$以及$W_{a}-W_{b}$来计数了……式子大概长这样

## $\sum_{i=0}^{b}\sum_{j=1}^{a-b-1}C_{b}^{i}C_{a}^{i+j}$

我们交换一下Σ，即swap(i,j)得到

## $\sum_{i=1}^{a-b-1}\sum_{j=0}^{b}C_{b}^{j}C_{a}^{i+j}$

## $=\sum_{i=1}^{a-b-1}\sum_{j=0}^{b}C_{b}^{b-j}C_{a}^{i+j}$

观察到$b-j+i+j=b+i$因此我们可以重写内层Σ

## $\sum_{i=1}^{a-b-1}\sum_{j+k=b+i}C_{b}^{j}C_{a}^{k}$

这个形式被称为**范德蒙德卷积**，即以下等式恒成立

## $\sum_{i+j=k}C_{a}^{i}C_{b}^{j}=C_{a+b}^{k}$

所以我们的式子被化成了

## $\sum_{i=1}^{a-b-1}C_{a+b}^{b+i}$

(备注：根据范德蒙德卷积我们也可以证明

## $\sum_{i=1}^{a}(C_{a}^{i})^{2}=\sum_{i=1}^{a}C_{a}^{i}C_{a}^{a-i}=C_{2a}^{a}$

这个式子是成立的)

然后我们加上一个方案数然后除以2的话我们可以得到最后的答案式子

若$A==B$

# $Ans=\frac{2^{A+B}-C_{2a}^{a}}{2}$

若$A>B$

# $Ans=\frac{2^{A+B}+\sum_{i=1}^{A-B-1}C_{A+B}^{B+i}}{2}$

然后问题来了，我们怎么计算$C_{n}^{m}mod10^9$?

如果mod的是一个不大的质数，那么我们可以通过lucas定理轻松的求解，但是如果p不是质数呢？此时我们需要一种被称之为扩展lucas的上古魔法来帮助我们求解这类问题

_________________________

## 拓展Lucas

首先由于我们的模数是任意的，我们将模数进行唯一分解，分解成$P^{k}$p为素数的连乘积形式，此时我们只需要分别计算出$C_{n}^{m}modp^{k}$最后使用中国剩余定理解同余方程就行了

问题来了怎么求出$C_{n}^{m}modp^{k}$呢？

此时网上的教程会告诉你我们只需要求出$N!modp^{k}$最后除在一起就好了……

## 但是问题来了，分母有极大的概率是$p^{k}$的倍数，此时不存在乘法逆元

因此我们需要略微费点功夫，我们将$N!$表示为$a×P^{b}$的形式

然后计算除法的时候各个阶乘的a部分乘法逆元都存在，然后在b部分运行指数上的加减法就好了

最后判以下指数是否大于k如果大于k直接输出0即可，否则就合并两个部分的值就行了

最后的问题，如何求出$N!modP^{k}$的不含有因子p的部分呢？

我们举一个非常老套的例子，计算$19!mod3^2$

把阶乘一字拆开得到

####  $1×2×3×4×5×6×7×8×9×10×11×12×13×14×15×16×17×18×19$

然后提走所有含有因子3的部分一个3式子变成了

#### $6!×3^{6}×1×2×4×5×7×8×10×11×13×14×16×17×19$

然后我们呢将后边的部分膜上一个$3^2$得到了

#### $6!×3^{6}×(1×2×4×5×7×8)^{2}×19$

让我们来观察各个部分的特征，左侧的阶乘可以直接递归的去处理，$3^{6}$可以单独计算，而中间的部分其实是一个伪阶乘的形式，即去掉了3的倍数的阶乘，发现最长不超过$p^{k}$可以打表预处理，而最后剩下的19其实是一个未完的周期，已经在我们的表当中了，因此如果记得伪阶乘为$B_{i}$那么我们可以得到这样的递归式来求阶乘的有乘法逆元的部分

## $lucas(n,p^{k})=lucas(\lfloor \frac{n}{p}\rfloor ,p^{k})B_{p^{k}-1}^{\lfloor \frac{n}{p^{k}} \rfloor}B_{n\%p^{k}}$


其中预处理是$O(p^k)$的，每次询问阶乘是$O(log^{2}n)$的(计入了快速幂的log)

最后使用中国剩余定理解同余方程即可得到$C(n,m)modp$了

最后一个问题，2在膜$10^9$的意义下乘法逆元是不存在的，我们该怎么除2呢？

我们发现如果$a+b$是奇数，那么我们需要计算的式子其实是杨辉三角中间对称的几列，那么我们只计算左边的几列或者右边的几列就可以除2了，但是在a+b为偶数的时候我们会发现剩下了一个$C_{a+b}^{(a+b)/2}$情况会有点辣手

但是我们注意到根据帕斯卡恒等式(杨辉三角)可以得到

## $C_{2a}^{a}=C_{2a-1}^{a}+C_{2a-1}^{a-1}=2C_{2a-1}^{a}$

于是我们计算$C_{a+b-1}^{(a+b)/2}$就可以了

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;typedef unsigned long long ll;const ll mod[2]={512,1953125};const ll bs[2]={2,5};
const ll M=1e9;//省事起见直接mod1e9了 
inline ll po(ll a,ll p,ll mod){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
inline void exgcd(ll a,ll& x,ll b,ll& y)//乘法逆元和快速幂 
{if(b==0){x=1;y=0;return;}exgcd(b,x,a%b,y);ll tp=x;x=y;y=tp-a/b*y;}
inline ll inv(ll a,ll b){ll x;ll y;exgcd(a,x,b,y);return (x+b)%b;}
ll bru[2][1953200];ll a;ll b;int k;int nb[15];
ll lucas(ll n,ll t)//一行lucas 
{return n?lucas(n/bs[t],t)*bru[t][n%mod[t]]%mod[t]*po(bru[t][mod[t]-1],n/mod[t],mod[t])%mod[t]:1;}
inline ll c(ll n,ll m,int t)
{
	ll d=0;for(ll i=n;i;i/=bs[t])d+=i/bs[t];
	for(ll i=m;i;i/=bs[t])d-=i/bs[t];
	for(ll i=n-m;i;i/=bs[t])d-=i/bs[t];if(d>=9){return 0;}//剪枝，我们直接暴力计算出指数然后判断是否是0 
	ll p1=lucas(n,t);ll p2=lucas(m,t);ll p3=lucas(n-m,t);//计算非互质部分 
	return po(bs[t],d,mod[t])*p1%mod[t]*inv(p2,mod[t])%mod[t]*inv(p3,mod[t])%mod[t];//乘上p的幂次 
}
inline void prit(ll x)//打印函数 
{
	for(int i=1;i<=10;i++)nb[i]=0;
	for(int i=1;x;i++,x/=10)nb[i]=x%10;
	for(int i=k;i>=1;i--)printf("%d",nb[i]);printf("\n");
}
int main()//打表伪阶乘 
{
	bru[0][0]=1;for(int i=1;i<mod[0];i++){bru[0][i]=(i%2)?i*bru[0][i-1]%mod[0]:bru[0][i-1];}
	bru[1][0]=1;for(int i=1;i<mod[1];i++){bru[1][i]=(i%5)?i*bru[1][i-1]%mod[1]:bru[1][i-1];}
	while(scanf("%lld%lld%d",&a,&b,&k)!=-1)
	{
	 	ll ret2=0;ll ret5=0;
	 	if(a==b)//特判a==b 
	 	{
	 		ret2=c(2*a-1,a,0);ret5=c(2*a-1,a,1);
	 		ret2=ret2*mod[1]%M*inv(mod[1]%mod[0],mod[0])%M;
	 		(ret2+=ret5*mod[0]%M*inv(mod[0],mod[1]))%=M;ret2=M-ret2;
	 		(ret2+=po(2,a+b-1,M))%=M;prit(ret2);//中国剩余定理解同余方程 
	 	}
	 	else 
	 	{
	 		if((a+b)%2)//如果a+b是奇数 
	 		{
	 			for(ll i=b+1;i<=(a+b)/2;i++)(ret2+=c(a+b,i,0))%=mod[0];
				for(ll i=b+1;i<=(a+b)/2;i++)(ret5+=c(a+b,i,1))%=mod[1];//只算一半 
	 			ret2=ret2*mod[1]%M*inv(mod[1]%mod[0],mod[0])%M;
	 			(ret2+=ret5*mod[0]%M*inv(mod[0],mod[1]))%=M;(ret2+=po(2,a+b-1,M))%=M;
	 			prit(ret2);
	 		}
	 		else //偶数的时候通过计算C(a+b-1,(a+b)/2)来将C(a+b,(a+b)/2)除2 
	 		{
	 			for(ll i=b+1;i<(a+b)/2;i++)(ret2+=c(a+b,i,0))%=mod[0];(ret2+=c(a+b-1,(a+b)/2,0))%=mod[0];
	 			for(ll i=b+1;i<(a+b)/2;i++)(ret5+=c(a+b,i,1))%=mod[1];(ret5+=c(a+b-1,(a+b)/2,1))%=mod[1];	 			
	 			ret2=ret2*mod[1]%M*inv(mod[1]%mod[0],mod[0])%M;
	 			(ret2+=ret5*mod[0]%M*inv(mod[0],mod[1]))%=M;(ret2+=po(2,a+b-1,M))%=M;
	 			prit(ret2);
	 		}
	 	}
	}return 0;//拜拜程序~ 
}

```







---

## 作者：lhm_ (赞：14)

可以分别枚举两人正面朝上的次数来统计答案，所求即为：
$$
\large\sum_{i=0}^{a}\sum_{j=0}^{b} \binom{a}{i} \binom{b}{j} [i>j]
$$
将 $i$ 替换为 $i+j$ 来保证 $i>j$：

$$
\large\sum_{i=0}^{a}\sum_{j=0}^{b} \binom{a}{i} \binom{b}{j} [i>j]=\sum_{i=1}^{a}\sum_{j=0}^{a-i} \binom{a}{i+j} \binom{b}{j}=\sum_{i=1}^{a}\sum_{j=0}^{a-i} \binom{a}{i+j} \binom{b}{b-j}
$$

由范德蒙德卷积得：

$$
\large\sum_{i=1}^{a}\sum_{j=0}^{a-i} \binom{a}{i+j} \binom{b}{b-j}=\sum_{i=1}^{a} \binom{a+b}{b+i}=\sum_{i=b+1}^{a+b} \binom{a+b}{i}
$$

直接计算化简后的式子复杂度无法接受，但发现 $a$ 和 $b$ 的差值很小，所以将式子进一步转化得：

$$
\large\sum_{i=b+1}^{a+b} \binom{a+b}{i}=\sum_{i=\lceil \frac{a+b}{2} \rceil}^{a+b} \binom{a+b}{i}+\sum_{i=b+1}^{\lfloor \frac{a+b}{2} \rfloor} \binom{a+b}{i}-\binom{a+b}{\frac{a+b}{2}}[a+b\equiv0\pmod{2}]
$$

第一项的值可以快速计算，当 $a+b$ 为奇数时，其为 $2^{a+b-1}$，当 $a+b$ 为偶数时，其为 $2^{a+b-1}+\frac{1}{2}\binom{a+b}{\frac{a+b}{2}}$，第二项的值用扩展卢卡斯计算组合数即可。

```cpp
#include<bits/stdc++.h>
#define maxn 2000010
#define inf 2000000000
using namespace std;
typedef long long ll;
ll a,b,t,k2,k5,mod,ans,x,y;
ll f[6][maxn];
ll exgcd(ll a,ll b)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    ll ans=exgcd(b,a%b),tmp=x;
    x=y,y=tmp-a/b*y;
    return ans;
}
ll inv(ll a,ll p)
{
    if(!a) return 0;
    exgcd(a,p);
    return (x%p+p)%p;
}
ll qp(ll x,ll y,ll p)
{
    ll v=1;
    while(y)
    {
        if(y&1) v=v*x%p;
        x=x*x%p,y>>=1;
    }
    return v;
}
ll fac(ll x,ll p,ll k)
{
    if(!x) return 1;
    return qp(f[p][k],x/k,k)*f[p][x%k]%k*fac(x/p,p,k)%k;
}
ll C(ll n,ll m,ll p,ll k,bool type)
{
    if(n<m) return 0;
    ll sum=0,v=1;
    for(ll i=n;i;i=i/p) sum+=i/p;
    for(ll i=m;i;i=i/p) sum-=i/p;
    for(ll i=n-m;i;i=i/p) sum-=i/p;
    if(type)
    {
        if(p==2) sum--;
        else v=inv(2,k);
    }
    if(sum>=t) return 0;
    return v*fac(n,p,k)%k*qp(p,sum,k)%k*inv(fac(m,p,k),k)%k*inv(fac(n-m,p,k),k)%k;
}
ll crt(ll x,ll p)
{
    return x*inv(mod/p,p)%mod*(mod/p)%mod;
}
ll exlucas(ll n,ll m,bool type)
{
    if(n<m) return 0;
    return (crt(C(n,m,2,k2,type),k2)+crt(C(n,m,5,k5,type),k5))%mod;
}
void init()
{
    f[2][0]=f[5][0]=1;
    for(int i=1;i<=512;++i)
    {
        f[2][i]=f[2][i-1];
        if(i&1) f[2][i]=f[2][i]*i%512;
    }
    for(int i=1;i<=1953125;++i)
    {
        f[5][i]=f[5][i-1];
        if(i%5) f[5][i]=f[5][i]*i%1953125;
    }
}
int main()
{
    init();
    while(scanf("%lld%lld%lld",&a,&b,&t)!=EOF)
    {
        mod=qp(10,t,inf),ans=qp(2,a+b-1,mod),k2=qp(2,t,inf),k5=qp(5,t,inf);
        for(ll i=b+1;i<=(a+b)/2;++i) ans=(ans+exlucas(a+b,i,0))%mod;
        if((a+b)%2==0) ans=(ans-exlucas(a+b,(a+b)/2,1)+mod)%mod;
        printf("%0*lld\n",t,ans);
    }
    return 0;
}
```

---

## 作者：command_block (赞：9)

**题意**：Alice 抛 $a$ 次硬币，Bob 抛 $b$ 次硬币，分别得到 $c_A,c_B$ 次正面，若 $c_A>c_B$，则 Alice 获胜。求她获胜的方案数。

答案对 $10^k$ 取模，多组数据，$T\leq 10$，$b\leq a\leq b+10000$，$a,b\leq 10^{15}$，$k\leq 9$，时限 $\texttt{1s}$。

-----
  
- **前置芝士**：范德蒙德卷积
  $$
  \dbinom{n+m}{k}=\sum\limits_{i=0}^k\dbinom{n}{i}\dbinom{m}{k-i}
  $$

## $a=b$

此时两人是平等的，但是获胜条件并不平等，要刨掉平局的情况
$$
\sum\limits_{i=0}^a\dbinom{a}{i}^2
$$
根据范德蒙德卷积
$$
\sum_{i=0}^a\dbinom{a}{i}^2=\sum_{i=0}^a\dbinom{a}{i}\dbinom{a}{a-i}=\dbinom{2a}{a}
$$
除此之外两人就五五开了，方案数是
$$
\dfrac{2^{2a}-\binom{2a}{a}}{2}
$$

## $a>b$

注意到 $a,b$ 都很大，$a-b$ 却很小，我们需要使用抵消思想才能利用到 $a-b$。

将抛硬币的结果记载为 01 序列 $A,B$。（1 代表正面）

- 记 $|A|$ 为 $A$ 中 1 的个数。

- 记 $\overline A$ 为：将 $A$ 01 取反得到的序列。
- 称 $(\overline A,\overline B)$ 为 $(A,B)$ 的对偶方案。

显然，我么把所有方案分成了一个个对子。我们希望有很多对子是一胜一负，这样它们就能对消。

当 $a=b$ 时，只要 $|A|\neq |B|$，对子一定是一胜一负，故我们只用关心 $|A|=|B|$ 的方案数。

当 $a>b$ 时，设 $A$ 赢一次输一次的对子个数为 $S_1$（对偶），赢两次的对子个数为 $S_2$（不对偶）。（显然 $A$ 不可能一次都不赢）则答案为
$$
S_1+2S_2
$$
又知道 $S_1+S_2=2^{a+b-1}$，故我们只需要在 $S_1,S_2$ 中求出其一。

直觉告诉我们，由于 $a-b$ 很小，不对偶远少于对偶的情况。故我们考虑计算 $S_2$.

对子不对偶时，按照定义有 $|A|>|B|$ 且 $a-|A|>b-|B|$ 即 $a-b>|A|-|B|$。

出现了！$a-b$！

分别枚举 $|B|,|A|-|B|$ 可得：（注意，每个对子会被统计两次）

$$
\begin{aligned}
S_2&=\frac{1}{2}\sum_{i=0}^b\dbinom{b}{i}\sum_{j=1}^{a-b-1}\dbinom{a}{i+j}\\
&=\frac{1}{2}\sum_{j=1}^{a-b-1}\sum_{i=0}^b\dbinom{b}{b-i}\dbinom{a}{i+j}
\end{aligned}
$$
注意到有$b-i+i+j=b+j$，这是个范德蒙德卷积。

$$
S_2=\frac{1}{2}\sum_{j=1}^{a-b-1}\dbinom{a+b}{b+j}
$$
使用 $a-b$ 次 ExLucas 计算这些组合数。复杂度$O((a-b)\log^2a+5^k+2^k)$。

> 注：$2$ 在$\pmod {10^k}$ 下没有逆元，为了除 $2$，我们把模数乘 $2$ 再把最后结果直接除 $2$ 即可。

```cpp
#include<algorithm>
#include<cstdio>
#define MaxN 2005000
#define ll long long
using namespace std;
void exgcd(ll a,ll b,ll &x,ll &y){
  if (b==0){x=1;y=0;return ;}
  exgcd(b,a%b,y,x);y-=(a/b)*x;
}
ll inv(ll a,ll m){
  ll x,y;exgcd(a,m,x,y);
  return (x%m+m)%m;
}
ll powM(ll a,ll t,int mod)
{
  ll ret=1;
  while(t){
    if (t&1)ret=ret*a%mod;
    a=a*a%mod;t>>=1;
  }return ret;
}
struct Data
{
  int p,mod;
  ll sav[MaxN];
  void Init(){
    sav[0]=1;
    for (int i=0;i<mod;i+=p){
      for (int j=i+1;j<i+p;j++)
        sav[j]=sav[j-1]*j%mod;
      sav[i+p]=sav[i+p-1];
    }
  }
  ll v(ll n){
    ll ret=0;
    while(n)ret+=(n/=p);
    return ret;
  }
  ll r(ll n){
    if (n==0)return 1;
    return powM(sav[mod-1],n/mod,mod)*sav[n%mod]%mod*r(n/p)%mod;
  }
  ll C(ll n,ll m)
  {
    ll c=v(n)-v(m)-v(n-m),
       ans=powM(p,c,mod);
    if (!ans)return 0;
    ans=ans*r(n)%mod;
    ans=ans*inv(r(m),mod)%mod;
    ans=ans*inv(r(n-m),mod)%mod;
    return ans;
  }
  ll calc(ll a,ll b)
  {
    if (a==b)return (powM(2,a+b,mod)-C(a<<1,a)+mod)%mod;
    ll ret=0;
    for (int i=1;i<a-b;i++)
      ret+=C(a+b,b+i);
    return (powM(2,a+b,mod)+ret)%mod;
  }
}T2,T5;
ll a,b;int k;
void solve()
{
  T2.mod=2;for (int i=0;i<k;i++)T2.mod*=2;
  T5.mod=1;for (int i=0;i<k;i++)T5.mod*=5;
  T2.Init();T5.Init();
  int mod=T2.mod*T5.mod;
  ll ret=(T2.calc(a,b)*inv(T5.mod,T2.mod)%mod*T5.mod
         +T5.calc(a,b)*inv(T2.mod,T5.mod)%mod*T2.mod)%mod;
  ret>>=1;mod>>=1;
  for (int i=0;i<k;i++){
    printf("%d",ret*10/mod%10);
    mod/=10;
  }puts("");
}
int main()
{
  T2.p=2;T5.p=5;
  while(~scanf("%lld%lld%d",&a,&b,&k))solve();
  return 0;
}
```

---

## 作者：litble (赞：8)

# 题目分析

[安利个人博客](http://blog.csdn.net/litble/article/details/79596364)

首先考虑a=b的情况，那么对于一种B获胜的方案序列（比如二人都抛3次，A第三次正面朝上，B第一次和第二次正面朝上，序列就是001110），将每一位都异或1，就变成了A获胜的，当然，还要减去平局，所以答案就是$\frac{2^{a+b}-C_{a+b}^a}{2}$

考虑a>b的情况，同样，一种B获胜的方案序列每一位都异或1。不过，由于A同学可以抛的硬币数量比较多，所以可以凭数量取胜，还会出现方案序列是A获胜，将每一位异或1后还是A获胜的序列。这样的序列假设b正面朝上j次，a比b多正面朝上j次，就应该满足$b-i<a-i-j$，种类数就是$$\sum_{i=0}^b\sum_{j=1}^{a-b-1}C_b^{i}C_a^{i+j}=\sum_{i=0}^b\sum_{j=1}^{a-b-1}C_b^{b-i}C_a^{i+j}$$

那么我们可以这么看这个式子：我们在a+b个数组成的序列中选择$b+j$个元素变成1，然后其中在前b个元素中的1的个数就正好能完成那个和$i$有关的枚举。所以：

$$\sum_{i=1}^{a-b-1}C_{a+b}^{b+i}$$

答案就是：

$$\frac{2^{a+b}+\sum_{i=1}^{a-b-1}C_{a+b}^{b+i}}{2}$$

于是就用扩展Lucas算吧。

可是这题比较卡常。首先是要预处理阶乘。然后，在杨辉三角中，组合数具有对称性，所以计算组合数只用算一半。再加上标记处的优化，就能够通过这道题。

至于如何除以2，在扩展Lucas的计算过程中处理一下即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,no-stack-protector") //在bzoj上不能用
#define Res register
typedef long long LL;
LL a,b,K,mod,ans,k2,k5,fac[2][2000005];
inline LL ksm(LL x,LL y,LL p) {
	LL re=1;
	for(;y;y>>=1,x=x*x%p) if(y&1) re=re*x%p;
	return re;
}
void exgcd(LL a,LL b,LL &x,LL &y) {
	if(!b) {x=1,y=0;return;}
	exgcd(b,a%b,x,y);LL tmp=x;
	x=y,y=tmp-(a/b)*y;
}
LL ny(LL a,LL p) {
	Res LL x,y; exgcd(a,p,x,y);
	return (x%p+p)%p;
}
LL mul(LL x,int p,LL pk) {
	if(!x) return 1;
	Res LL re=fac[p!=2][pk];
	re=ksm(re,x/pk,pk)*fac[p!=2][x%pk]%pk;
	return re*mul(x/p,p,pk)%pk;
}
LL C(LL d,LL u,int p,LL pk,bool bj) {
	if(d<u) return 0;
	LL js=0;
	for(Res LL i=d;i;i/=p) js+=i/p;
	for(Res LL i=u;i;i/=p) js-=i/p;
	for(Res LL i=d-u;i;i/=p) js-=i/p;
	if(p==2&&bj) --js;//除以2
	if(js>=K) return 0;//优化效果非常明显
	LL s1=mul(d,p,pk),s2=mul(u,p,pk),s3=mul(d-u,p,pk);
	Res LL re=ksm(p,js,pk)*s1%pk*ny(s2,pk)%pk*ny(s3,pk)%pk;
	if(p==5&&bj) re=re*ny(2,pk)%pk;//除以2
	return re*(mod/pk)%mod*ny(mod/pk,pk)%mod;//中国剩余定理
}
void init(int p,LL pk) {
	fac[p!=2][0]=1;
	for(Res int i=1;i<=pk;++i)
		if(i%p) fac[p!=2][i]=fac[p!=2][i-1]*i%pk;
		else fac[p!=2][i]=fac[p!=2][i-1];
}
LL lucas(LL d,LL u,bool bj) {return (C(d,u,2,k2,bj)+C(d,u,5,k5,bj))%mod;}
int main()
{
	init(2,512),init(5,1953125);//预处理阶乘
	while(~scanf("%lld%lld%lld",&a,&b,&K)) {
		mod=ksm(10,K,1e9+5),k2=ksm(2,K,1e9+5),k5=ksm(5,K,1e9+5);
		if(a==b) ans=(ksm(2,a+b-1,mod)-lucas(a<<1,a,1)+mod)%mod;
		else {
			ans=ksm(2,a+b-1,mod);
			for(Res LL i=(a+b)/2+1;i<a;++i) ans+=lucas(a+b,i,0),ans%=mod;
			//组合数具有对称性，只用算一半
			if((a+b)%2==0) ans+=lucas(a+b,(a+b)/2,1),ans%=mod;
		}
		while(ans<mod/10) putchar('0'),mod/=10;
		printf("%lld\n",ans);
	}
    return 0;
}
```


---

## 作者：NOI_Winner (赞：3)

# 新年快乐！！！

前置知识：
- 扩展卢卡斯定理：请见[P4720 【模板】扩展卢卡斯定理/exLucas](https://www.luogu.com.cn/problem/P4720)。
- 范德蒙德卷积：

$$
\begin{pmatrix} n + m \\ k \end{pmatrix} = \sum_{i = 0}^{k} \begin{pmatrix} n \\ i  \end{pmatrix} \begin{pmatrix} m \\ k - i \end{pmatrix}
$$

由数据范围中有 $a = b$ 的部分分，我们可以先考虑它并由此引发正解。将抛硬币的结果转化为 $01$ 序列，其中 $1$ 代表正面，$0$ 代表反面。设小 $A$ 对应的 $01$ 序列为 $a$，小 $B$ 对应的 $01$ 序列为 $b$，同时设 $a$ 中 $1$ 的个数为 $c_a$，$b$ 中 $1$ 的个数为 $c_b$。设序列 $a$ 取反（即 $0$ 变 $1$，$1$ 变 $0$）后的序列为 $a'$，序列 $b$ 取反后的序列为 $b'$，$a'$ 中 $1$ 的个数为 $c_a'$（也就是 $a$ 中 $0$ 的个数），$b'$ 中 $1$ 的个数为 $c_b'$。假设小 $A$ 赢，则 $c_a > c_b$，得 $a - c_a < b - c_b$，即 $c_a' < c_b'$，也就是说此时的序列对应小 $B$ 赢；若小 $B$ 赢，取反的序列对应小 $A$ 赢。不难发现，小 $A$ 赢和小 $B$ 赢的方案数相等。因此，小 $A$ 赢的方案数即为总方案数减平局数再除以 $2$。平局方案数为：
$$
\sum_{i=0}^a \begin{pmatrix} a \\ i \end{pmatrix}^2=\sum_{i=0}^a \begin{pmatrix} a \\ i \end{pmatrix} \begin{pmatrix} a \\ a-i \end{pmatrix}=\begin{pmatrix} 2a \\ a \end{pmatrix} 
$$
最后一步由范德蒙德卷积得到。则最终答案即为：
$$
\frac{2^{2a}-C_{2a}^a}{2}
$$
再考虑 $a>b$ 的情况。对于小 $A$ 赢的情况，$c_a>c_b$，但 $a-c_a$ 与 $b-c_b$ 也就是 $c_a'$ 与 $c_b'$ 的大小关系不能确定，对应序列取反后小 $B$ 不一定赢，有可能平局或小 $A$ 赢。但我们可以发现，对于小 $B$ 赢的情况，$c_a<c_b$，因为 $a>b$，所以有 $a-c_a>b-c_b$，即 $c_a'>c_b'$，对应序列取反后小 $A$ 一定赢。进而可以发现，设 $c_a>c_b$ 且 $c_a'>c_b'$ 的方案数为 $x$，小 $A$ 赢的方案数为总方案数加上 $x$ 再除以 $2$。

考虑如何计算 $x$，由 $c_a>c_b$ 且 $a-c_a>b-c_b$ 可得 $a-b>c_a-c_b>0$，可通过这个限制条件计算答案。则 $x$ 即为：
$$
\begin{aligned}
&\sum_{i=0}^{b}\sum_{j=1}^{a-b-1}\begin{pmatrix}b\\i\end{pmatrix}\begin{pmatrix}a\\i+j\end{pmatrix}\\
=&\sum_{i=1}^{a-b-1}\sum_{j=0}^b\begin{pmatrix}a\\i+j\end{pmatrix}\begin{pmatrix}b\\j\end{pmatrix}\\
=&\sum_{i=1}^{a-b-1}\sum_{j=0}^b\begin{pmatrix}a\\i+j\end{pmatrix}\begin{pmatrix}b\\b-j\end{pmatrix}\\
=&\sum_{i=1}^{a-b-1}\sum_{j+k=b+i}\begin{pmatrix}a\\j\end{pmatrix}\begin{pmatrix}b\\k\end{pmatrix}\\
=&\sum_{i=1}^{a-b-1}\begin{pmatrix}a+b\\b+i\end{pmatrix}
\end{aligned}
$$
第三行到第四行可由范德蒙德卷积得到。

因此，答案即为 $\frac{2^{a+b}+C_{a+b}^{b+i}}{2}$。

但是，我们怎样计算模 $10^k$ 的组合数呢？这可以使用扩展卢卡斯定理。需要注意的是，由于答案最终要除以 $2$，我们可以将模数乘 $2$，最后将答案除以 $2$ 就行了。

本题时间较紧，需要进行卡常操作。具体的，在使用扩展卢卡斯定理时，由于需要计算：
$$
\frac{\frac{n!}{p^x}}{\frac{m!}{p^y}\frac{(n-m)!}{p^z}}p^{x-y-z}\mod p^c
$$
我们在计算组合数前先计算 $x-y-z$，若 $x-y-z \ge c$，可直接返回 $0$，不用再进行计算。

参考代码：
```cpp
#include <iostream>

using namespace std;

using ll = long long;
constexpr int maxn = 2000000, maxk = 1000000000;
int s[6][maxn + 5];

int qpow(int x, ll y, int mod)            //    快速幂
{
    int ans = 1;
    for (; y; y >>= 1)
    {
        if (y & 1) ans = 1ll * ans * x % mod;
        x = 1ll * x * x % mod;
    }
    return ans;
}

int solve(ll n, int p, int mod)         // 扩展卢卡斯定理求 n! mod p^c
{
    if (n <= 1) return 1;
    int cur = solve(n / p, p, mod);
    return 1ll * cur * qpow(s[p][mod], n / mod, mod) % mod * s[p][n % mod] % mod;
}

void exgcd(int a, int b, ll& x, ll& y)   // 扩展欧几里得算法求逆元
{
    if (0 == b)
    { x = 1; y = 0; return; }
    exgcd(b, a % b, x, y);
    ll z = x; x = y; y = z - a / b * y;
}

ll lucas(ll n, ll m, int k)             // 扩展卢卡斯定理求组合数
{
    int mod2 = qpow(2, k + 1, maxk), c = 0, ans2 = 0;
    for (ll t = n; t; t >>= 1) c += t >> 1;
    for (ll t = m; t; t >>= 1) c -= t >> 1;
    for (ll t = n - m; t; t >>= 1) c -= t >> 1;
    ll x, y;
    
    if (c <= k)                      // 特判，常数优化
    {
        ans2 = solve(n, 2, mod2);
        int cur = solve(m, 2, mod2);
        exgcd(cur, mod2, x, y);
        x = (x % mod2 + mod2) % mod2;
        ans2 = 1ll * x * ans2 % mod2;
        cur = solve(n - m, 2, mod2);
        exgcd(cur, mod2, x, y);
        x = (x % mod2 + mod2) % mod2;
        ans2 = 1ll * x * ans2 * qpow(2, c, mod2) % mod2;
    }
    
    int mod5 = qpow(5, k, maxk), ans5 = 0; c = 0;
    for (ll t = n; t; t /= 5) c += t / 5;
    for (ll t = m; t; t /= 5) c -= t / 5;
    for (ll t = n - m; t; t /= 5) c -= t / 5;
    if (c < k)                       // 特判，常数优化
    {
        ans5 = solve(n, 5, mod5);
        int cur = solve(m, 5, mod5);
        exgcd(cur, mod5, x, y);
        x = (x % mod5 + mod5) % mod5;
        ans5 = 1ll * ans5 * x % mod5;
        cur = solve(n - m, 5, mod5);
        exgcd(cur, mod5, x, y);
        x = (x % mod5 + mod5) % mod5;
        ans5 = 1ll * x * ans5 * qpow(5, c, mod5) % mod5;
    }
    
    int mod = mod2 * mod5;
    exgcd(mod5, mod2, x, y);
    x = (x % mod2 + mod2) % mod2;
    ll ans = mod5 * x % mod * ans2 % mod;
    exgcd(mod2, mod5, x, y);
    x = (x % mod5 + mod5) % mod5;
    ans = (ans + mod2 * x % mod * ans5 % mod) % mod;
    return ans;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr); cout.fill('0');
    
    ll a, b; int k;
    while (cin >> a >> b >> k)
    {
        cout.width(k); int mod = 1;
        for (int i = 1; i <= k; i++)
            mod *= 10;
        int val2 = qpow(2, k + 1, mod), val5 = qpow(5, k, mod);
        s[2][0] = s[5][0] = 1;
        for (int i = 1; i <= val2; i++)
            if (0 == i % 2)
                s[2][i] = s[2][i - 1];
            else
                s[2][i] = 1ll * s[2][i - 1] * i % val2;
        for (int i = 1; i <= val5; i++)
            if (0 == i % 5)
                s[5][i] = s[5][i - 1];
            else
                s[5][i] = 1ll * s[5][i - 1] * i % val5;
        mod <<= 1;
        
        if (a == b)
        {
            ll ans = qpow(2, a << 1, mod);
            ans = (ans - lucas(a << 1, a, k)) % mod;
            ans = (ans + mod) % mod;
            (ans >>= 1) %= mod;
            cout << ans << endl;
        }
        else
        {
            ll ans = qpow(2, a + b, mod);
            for (ll i = 1; i <= a - b - 1; i++)
                ans = (ans + lucas(a + b, b + i, k)) % mod;
            (ans >>= 1) %= mod;
            cout << ans << endl;
        }
    }
    
    return 0;
}

```

---

## 作者：iodwad (赞：3)

这里提供一种与大多数题解不一样的做法。分两种情况讨论，1. 小 A 在前 $B$ 次就已经比小 B​ 多，后面 $A-B$ 次可以随便选。此时方案数为 $\sum\limits_{i=1}^b {b \choose i} \sum\limits_{j=0}^{j-1} {b \choose j}2^{a-b}$。可以写成 $\frac{(\sum\limits_{i=0}^b {b \choose i})^2- \sum\limits_{i=0}^b {b \choose i}^2}{2}2^{a-b}$。因为 $(\sum\limits_{i=0}^b {b \choose i})^2=2^b$，$\sum\limits_{i=0}^b {b \choose i}^2=\sum\limits_{i=0}^b {b \choose i}{b \choose b - i}={2b \choose b}$。最终形式即 $\frac{2^b-{2b\choose b}}{2}2^{a-b}$。2. 小 A 在前 $B$ 次没有超过小 B，则需要在后面 $A-B$ 次把这些补上。此时方案数为 $\sum\limits_{\Delta=0}^{a-b-1} \sum\limits_{i=0}^{b-\Delta} {b\choose i}{b\choose i+\Delta}\sum\limits_{j=\Delta+1}^{a-b} {a-b\choose j}$。

用前面那个式子的思想又可以化简为 $\sum\limits_{\Delta=0}^{a-b-1} {2b\choose b-\Delta} \sum\limits_{j=d+1}^{a-b} {a-b \choose j}$。把这些组合数用 EXLUCAS 计算即可。注意有一些需要卡常数的地方，如因为模数只有两个质因子，可以预处理出 EXLUCAS 里的循环节的乘积部分，还有如果当前组合数里已经有超过 $k$ 个 $p$ 的因子了，直接返回 $0$。

感谢 [Ender_zzm](https://www.luogu.com.cn/user/33339) 教我卡常数

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

#define mp std::make_pair
#define pb push_back
#define int long long

const int MAXM = 2e6;

int a, b, k;

inline int read() {
  register int x = 0, v = 1; 
  register char ch = getchar();
  while (!isdigit(ch)) {
    if (ch == '-') v = -1;
    ch = getchar();
  }
  while (isdigit(ch)) {
    x = x * 10 + ch - '0';
    ch = getchar();
  }
  return x * v;
}

inline int f_pow(int x, int y, int mod) {
  int res = 1, base = x;
  while (y > 0) {
    if (y & 1) res = res * base % mod;
    base = base * base % mod;
    y >>= 1;
  }
  return res;
}

int ct[10002];

namespace EXLUCAS {
  int A[100], B[100], sum[2][MAXM | 1];
  void exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
      x = 1;
      y = 0;
      return;
    }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
  }
  int inv(int a, int b) {
    int x, y;
    exgcd(a, b, x, y);
    return (x % b + b) % b;
  }
  int fac(int n, int p, int pk) {
    if (!n) return 1;
    int res = 1, id = p == 2 ? 0 : 1;
    res = f_pow(sum[id][pk], n / pk, pk) * sum[id][n % pk] % pk;
    return f_pow(sum[id][pk], n / pk, pk) * sum[id][n % pk] % pk * fac(n / p, p, pk) % pk;
  }
  int c_mod(int n, int m, int p, int pk) {
    int x = 0;
    for (int i = p; i <= n; i *= p) x += n / i;
    for (int i = p; i <= m; i *= p) x -= m / i;
    for (int i = p; i <= n - m; i *= p) x -= (n - m) / i;
    if (x >= k) return 0;
    return fac(n, p, pk) * inv(fac(m, p, pk), pk) % pk * inv(fac(n - m, p, pk), pk) % pk * f_pow(p, x, pk) % pk;
  }
  int CRT(int cnt) {
    int res = 0, mul = 1;
    for (int i = 1; i <= cnt; ++i) mul *= A[i];
    for (int i = 1; i <= cnt; ++i) {
      int mi = mul / A[i];
      res += B[i] * inv(mi, A[i]) * mi;
    }
    return res % mul;
  }
  int C(int n, int m, int p) {
    int cnt = 0;
    int id[2] = {2, 5};
    for (int ii = 0; ii < 2; ++ii) {
      int i = id[ii];
      if (p % i) continue;
      int pk = 1;
      while (p % i == 0) {
        pk *= i;
        p /= i;
      }
      A[++cnt] = pk;
      B[cnt] = c_mod(n, m, i, pk);
    }
    if (p > 1) {
      A[++cnt] = p;
      B[cnt] = c_mod(n, m, p, p);
    }
    return CRT(cnt);
  }
}

using namespace EXLUCAS;

void out(int x, int k) {
  if (!k) return;
  out(x / 10, k - 1);
  putchar(x % 10 + '0');
}

signed main() {
  sum[0][0] = sum[1][0] = 1;
  int mod1 = f_pow(2, 9, 1e10), mod2 = f_pow(5, 9, 1e10);
  for (int i = 1; i <= mod2; ++i) {
    sum[0][i] = sum[0][i - 1];
    sum[1][i] = sum[1][i - 1];
    if (i % 2) sum[0][i] = sum[0][i] * i % mod1;
    if (i % 5) sum[1][i] = sum[1][i] * i % mod2;
  }
  while (~scanf("%lld %lld %lld", &a, &b, &k)) {
    int res = 0, mod = f_pow(10, k, 1e10);
    int tmp = f_pow(2, b - 1, mod);
    mod1 = f_pow(2, k, 1e10);
    mod2 = f_pow(5, k, 1e10);
    res = (tmp * tmp * 2 % mod - C(2 * b - 1, b - 1, mod) + mod) % mod * f_pow(2, a - b, mod) % mod;
    ct[a - b + 1] = 0;
    int ctt = 0;
    for (int d = a - b - 1; d >= 0; --d) {
      ctt = (ctt + C(a - b, d + 1, mod)) % mod;
      res = (res + C(2 * b, b - d, mod) * ctt % mod) % mod;
    }
    out(res, k);
    printf("\n");
  }
  return 0;
}
```



---

## 作者：KobeBeanBryantCox (赞：2)

# P3726 [AHOI2017/HNOI2017] 抛硬币 题解

[题目传送门](https://www.luogu.com.cn/problem/P3726)。

**不需要用范德蒙德卷积啊，怎么都在用啊。**

前置芝士：[exLucas](https://www.luogu.com.cn/problem/P4720)。

## 题意

小 A 小 B 在玩一个扔硬币游戏，小 A 可以扔 $a$ 次，小 B 可以扔 $b$ 次，问小 A 朝上次数比小 B 多的方案数对 $10^k$ 取模。

## 思路

考虑小 A 小 B 的扔硬币序列，考虑如下表格：

||下|上|
|:-:|:---:|:-----:|
|小 A|$n$|$a-n$|
|小 B|$m$|$b-m$|

要求转化为 $a-n>b-m$，移项为 $a-n+m>b$。

人类智慧地考虑把小 B 扔硬币序列 01 反转，得到如下表格：

||下|上|
|:-:|:---:|:-----:|
|小 A|$n$|$a-n$|
|小 B|$b-m$|$m$|

此时要求转化为，把小 A 和小 B 扔硬币序列拼起来，总朝上硬币数超过 $b$ 个。

显然就能推出答案式子了（总情况减去不合法的）：

$$2^{a+b}-\sum_{i=0}^b\binom{a+b}{i}$$

注意到 $a-b$ 很小，考虑怎么把这个玩意转化成 $a-b$ 的形式。

注意到有以下式子：

$$\begin{aligned}
  \sum_{i=0}^{a+b}\binom{a+b}{i} &= 2^{a+b} \\
  \sum_{i=0}^{a+b}\binom{a+b}{i} &= \sum_{i=0}^{b}\binom{a+b}{i}+\sum_{i=b+1}^{a-1}\binom{a+b}{i}+\sum_{a}^{a+b}\binom{a+b}{i}
\end{aligned}$$

又因为有：

$$\sum_{a}^{a+b}\binom{a+b}{i}=\sum_{a}^{a+b}\binom{a+b}{i}$$

所以：

$$\sum_{a}^{a+b}\binom{a+b}{i}=\dfrac{2^{a+b}-\sum_{i=b+1}^{a-1}\binom{a+b}{i}}2$$

所以答案原式化为：

$$\dfrac{2^{a+b}+\sum_{i=b+1}^{a-1}\binom{a+b}{i}}2$$

然后枚举从 $b+1$ 到 $a-1$，暴力算组合数即可。

注意到模数非质数且 $a+b$ 过大，需要使用 exLucas。

注意到最后要 $\div2$，$2$ 在此模数下没有逆元，考虑把模数 $\times 2$，最后答案就能直接 $\div2$ 了。

注意到 $a=b$ 的情况无法解决，需要特判。

注意到普通的 exLucas 时间复杂度过高，注意到模数是 $10$ 的幂次，显然质因子只有 $2$ 和 $5$，这时可以把普通 exLucas 改成预处理版本的。

显然时间复杂度为 $O(T(2^k+5^k+(a-b)\log_p\log_2))$。

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long
void exgcd(int a,int b,int &x,int &y)
{
	if(b==0)return x=1,y=0,void();
	exgcd(b,a%b,y,x),y-=a/b*x;
}
int inv(int a,const int p){int x,y;exgcd(a,p,x,y);return (x%p+p)%p;}
int ksm(int a,int b,const int p)
{
	int ans=1;
	for(;b;b>>=1,a=a*a%p)if(b&1)ans=ans*a%p;
	return ans;
}
const int N=2e6+20;
struct Lucas
{
	int p,mod;
	int sF[N];
	void init()
	{
		sF[0]=1;
		for(int i=0;i<mod;i+=p)
		{
			for(int j=i+1;j<i+p;j++)sF[j]=sF[j-1]*j%mod;
			sF[i+p]=sF[i+p-1];
		}
	}
	int F(int n){return n==0?1:(ksm(sF[mod-1],n/mod,mod)*sF[n%mod]%mod*F(n/p)%mod);}
	int G(int n){return n<p?0:(n/p+G(n/p));}
	int C(int n,int m)
	{
		int ans=ksm(p,G(n)-G(m)-G(n-m),mod);
		if(ans==0)return 0;
		return ans*F(n)%mod*inv(F(m)*F(n-m)%mod,mod)%mod;
	}
}L2,L5;
int exLucas(int n,int m)
{
	int mod=L2.mod*L5.mod;
	return (L2.C(n,m)*L5.mod%mod*inv(L5.mod,L2.mod)%mod+
			L5.C(n,m)*L2.mod%mod*inv(L2.mod,L5.mod)%mod)%mod;
}
int a,b,k;
int work()
{
	L2.mod=2;for(int i=1;i<=k;i++)L2.mod*=2;
	L5.mod=1;for(int i=1;i<=k;i++)L5.mod*=5;
	L2.init(),L5.init();
	int mod=L2.mod*L5.mod,ans=ksm(2,a+b,mod);
	if(a==b)return (ans-exLucas(a<<1,a)+mod)%mod/2;
	for(int i=b+1;i<=a-1;i++)ans=(ans+exLucas(a+b,i))%mod;
	return ans>>1;
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	L2.p=2,L5.p=5;
	while(cin>>a>>b>>k)cout<<setw(k)<<setfill('0')<<work()<<'\n';
	return 0;
}
```

---

## 作者：Phobia (赞：2)

不一样的处理方法。

不妨考虑递退，设 $S\left(n,k\right)=\sum\limits_{i>j}\binom{n+k}{i}\binom{n}{j}$，容易写出边界 $S\left(n,0\right)=\sum\limits_{i>j}\binom{n}{i}\binom{n}{j}=\frac{2^{2n}-\sum\limits_{i}\binom{n}{i}^2}{2}=2^{2n-1}-\frac{\binom{2n}{n}}{2}=2^{2n-1}-\binom{2n-1}{n}$

假设我们已经求得 $S\left(n,k\right)$，则有

$$
\begin{aligned}
S\left(n,k+1\right)&=\sum\limits_{i>j}\binom{n+k+1}{i}\binom{n}{j}\\
&=\sum\limits_{i>j}\left(\binom{n+k}{i}+\binom{n+k}{i-1}\right)\binom{n}{j}\\
&=\sum\limits_{i>j}\binom{n+k}{i}\binom{n}{j}+\sum\limits_{i>j}\binom{n+k}{i-1}\binom{n}{j}\\
&=\sum\limits_{i>j}\binom{n+k}{i}\binom{n}{j}+\sum\limits_{i\ge j}\binom{n+k}{i}\binom{n}{j}\\
&=2\sum\limits_{i>j}\binom{n+k}{i}\binom{n}{j}+\sum\limits_{i= j}\binom{n+k}{i}\binom{n}{j}\\
&=2\sum\limits_{i>j}\binom{n+k}{i}\binom{n}{j}+\binom{2n+k}{n}\\
&=2S\left(n,k\right)+\binom{2n+k}{n}\\
\end{aligned}
$$

答案就是 $S\left(b,a-b\right)$，套一边 exlucas 就做完了。

~~~cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long i64;

inline i64 read()
{
    i64 res = 0, ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        ;
    for (; isdigit(ch); ch = getchar())
        res = (res << 3) + (res << 1) + (ch & 15);
    return res;
}

inline int add(int P, int x, int y)
{
    return x + y >= P ? x + y - P : x + y;
}

inline int sub(int P, int x, int y)
{
    return x >= y ? x - y : x - y + P;
}

inline int mul(int P, int x, int y)
{
    return (i64)x * y % P;
}

template<class ...Args>
inline int add(int P, int x, int y, Args... args)
{
    return add(P, x, add(P, y, args...));
}

template<class ...Args>
inline int mul(int P, int x, int y, Args... args)
{
    return mul(P, x, mul(P, y, args...));
}

inline int qpow(int P, int x, i64 y)
{
    int res = 1;
    while (y)
    {
        if (y & 1)
            res = mul(P, res, x);
        x = mul(P, x, x);
        y >>= 1;
    }
    return res;
}

int exgcd(int a, int b, int& x, int& y)
{
    if (!b)
        return x = 1, y = 0, a;
    int d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}

int inv(int P, int x)
{
    int p, q;
    return exgcd(x, P, p, q), (p + P) % P;
}

int excrt(int n, int* a, int* b)
{
    int x = a[1], m = b[1];
    for (int i = 2; i <= n; ++i)
    {
        int p, q, d = exgcd(m, b[i], p, q);
        if ((x - a[i]) % d)
            return -1;
        m = m / d * b[i];
        x = ((a[i] + (i64)(x - a[i]) / d * q % (m / d) * b[i]) % m + m) % m;
    }
    return x;
}

int a[3], b[3], f[6][1953130];

void init(int k)
{
    b[1] = b[2] = 1;
    for (int i = 1; i <= k; ++i)
        b[1] *= 2, b[2] *= 5;
    f[2][0] = f[5][0] = 1;
    for (int i = 1; i < b[1]; ++i)
    {
        f[2][i] = f[2][i - 1];
        if (i % 2)
            f[2][i] = mul(b[1], f[2][i], i);
    }
    for (int i = 1; i < b[2]; ++i)
    {
        f[5][i] = f[5][i - 1];
        if (i % 5)
            f[5][i] = mul(b[2], f[5][i], i);
    }
}

int calc(int P, i64 n, int x)
{
    if (!n)
        return 1;
    return mul(P, qpow(P, f[x][P - 1], n / P), f[x][n % P], calc(P, n / x, x));
}

int multilucas(int P, i64 n, i64 m, int x)
{
    i64 cnt = 0;
    for (i64 i = n; i; i)
        cnt += i /= x;
    for (i64 i = m; i; i)
        cnt -= i /= x;
    for (i64 i = n - m; i;)
        cnt -= i /= x;
    int ans = qpow(P, x, cnt);
    if (!ans)
        return 0;
    return mul(P, ans, calc(P, n, x), inv(P, calc(P, m, x)), inv(P, calc(P, n - m, x)));
}

int exlucas(int P, i64 n, i64 m)
{
    if (n < m || m < 0)
        return 0;
    a[1] = multilucas(b[1], n, m, 2);
    a[2] = multilucas(b[2], n, m, 5);
    return excrt(2, a, b);
}

void write(int ans, int k)
{
    if (k > 1)
        write(ans / 10, k - 1);
    putchar(ans % 10 | 48);
}

int main()
{
    i64 a, b, k;
    while (scanf("%lld%lld%lld", &a, &b, &k) != EOF)
    {
        init(k);
        int P = 1;
        for (int i = 1; i <= k; ++i)
            P *= 10;
        int ans = sub(P, qpow(P, 2, 2 * b - 1), exlucas(P, 2 * b - 1, b));
        for (i64 i = b; i < a; ++i)
            ans = add(P, ans, ans, exlucas(P, i + b, b));
        write(ans, k), putchar('\n');
    }
    return 0;
}
~~~

---

## 作者：Lyrella (赞：1)

# 简要题意

两个人抛硬币，求第一个人正面朝上次数大于第二个人的情况数对 $p$ 取模，$p$ 不是质数。

**数据范围**：$1\le a,b\le 10^{15},b\le a\le b+10^4$。

# 题解

首先你需要会**扩展卢卡斯定理**，~~然后就只剩暴力推式子（逃~~。

我们可以枚举两个人正面朝上次数，就可以列出一个式子：
$$
\sum_{i=0}^a\sum_{j=0}^{i-1}{a\choose i}{b\choose j}
$$
转换枚举方式，有：
$$
\begin{aligned}
& \sum_{i=1}^a\sum_{j=0}^{i+j\le s}{a\choose i+j}{b\choose j}\\
=& \sum_{i=1}^a\sum_{j=0}^{b}{a\choose i+j}{b\choose b-j}\\
=& \sum_{i=1}^a{a+b\choose b+i}\\
=& \sum_{i=b+1}^a{a+b\choose i}\\
\end{aligned}
$$
考虑到 $a,b$ 之间相差不大，考虑直接枚举每个 $a+b\choose i$，但是似乎还是会超时。考虑到答案是**杨辉三角中一排组合数的后缀**，于是我们可以把答案拆成：
$$
\sum_{i=b+1}^{{(a+b)\over2} - 1}{a+b\choose i}+\sum_{i={(a+b)\over2}}^{a+b}{a+b\choose i}
$$
前面可以暴力地用扩展卢卡斯定理求，后面的就是 $2^{a+b-1}$。时间复杂度 $O((a-b)\log^2a+5^k+2^k)$。

# 代码

这里只给出部分代码。

```cpp
int C(ll n, ll m, int p, int pp, bool o){
    ll k = 0; if(n < m)return 0;
    for(ll i = n; i; i /= p)k += i / p;
    for(ll i = m; i; i /= p)k -= i / p;
    for(ll i = n - m; i; i /= p)k -= i / p;
    if(p == 2 and o)--k;
    if(k >= K)return 0;
    int t = 1ll * Fac(n, p, pp) * Inv(Fac(m, p, pp), pp) % pp * Inv(Fac(n - m, p, pp), pp) % pp * qmi(p, k, pp) % pp;
    if(p == 5 and o)t = 1ll * t * Inv(2, pp) % pp;
    return t;
}
int exLucas(ll n, ll m, bool o){
    for(int i = 1; i <= cnt; ++i)r[i] = C(n, m, p[i], pp[i], o);
    return crt();
}

signed main(){
    cnt = 2; fac[0][0] = fac[1][0] = 1;
    pp[0] = 512; pp[1] = 1953125; p[0] = 2, p[1] = 5;
    for(int q = 0; q < 2; ++q)for(int i = 1; i <= pp[q]; ++i){
        fac[q][i] = fac[q][i - 1];
        if(i % p[q])fac[q][i] = 1ll * fac[q][i] * i % pp[q];
    }
    while(scanf("%lld %lld %lld", &n, &m, &K) ^ EOF){
        mod = qmi(10, K, 1e9 + 7);
        pp[1] = qmi(p[1] = 2, K, 1e9 + 5);
        pp[2] = qmi(p[2] = 5, K, 1e9 + 5);
        ll ans;
        if(n == m)ans = (qmi(2, n + m - 1, mod) - exLucas(n + m, n, 1) + mod) % mod;
        else{
            ans = qmi(2, n + m - 1, mod);
            for(ll i = (n + m) / 2 + 1; i < n; ++i)ans = (ans + exLucas(n + m, i, 0)) % mod;
            if((n + m) % 2 == 0)ans = (ans + exLucas(n + m, n + m >> 1, 1)) % mod;
        }
        while(ans < mod / 10)putchar('0'), mod /= 10;
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：kyEEcccccc (赞：1)

式子是不是稍微有点不一样？不重要。

考虑最朴素的式子——枚举两人抛出的正面个数：

$$
\text{Ans}=\sum\limits_{i=0}^{b}\binom{b}{i}\sum\limits_{j = i+1}^{a}\binom{a}{j}
$$

两个上限固定的组合数启发我们使用范德蒙卷积，所以考虑对下指标进行变换并转而枚举 $a - j$：

$$
\begin{aligned}
\text{Ans}=&\sum\limits_{i = 0}^{b}\sum\limits_{j = 0}^{a}[i < j]\binom{b}{i}\binom{a}{a - j}\\
=&\sum\limits_{i = 0}^{b}\sum\limits_{j = 0}^{a}[i < a - j]\binom{b}{i}\binom{a}{j}
\end{aligned}
$$

接下来就可以顺利成章地枚举 $i+j = t < a$（注意这里无视了 $i \le b$ 的限制，因为 $\dbinom{b}{i}$ 的存在）：

$$
\begin{aligned}
\text{Ans}=&\sum\limits_{t = 0}^{a - 1}\sum\limits_{i=0}^{t}\binom{b}{i}\binom{a}{t-i}\\
=&\sum\limits_{t = 0}^{a - 1}\binom{a+b}{t}
\end{aligned}
$$

到这里其实已经做完了。考虑在 $a = b$ 情形下使用的对称性，实际上我们可以轻松求出 $\sum\limits_{i = 0}^{\lfloor\frac{a+b}{2}\rfloor}\binom{a+b}{i}$。所以只需要求出 $\lfloor\frac{a+b}{2}\rfloor+1 \sim a - 1$ 部分的组合数。这只有 $\frac{a - b}{2}$ 左右，所以很快。求组合数需要用 Ex-Lucas，考虑到这不是板子题就不予讲解。

---

## 作者：i207M (赞：1)

## 题目总结

两个人同时抛 b 次硬币，如果小 A 的正面朝上的次数大于小 B 正面朝上的次数，则小 A 获胜。小 A 决定在小 B 没注意的时候作弊，悄悄地多抛几次硬币，当然，为了不让小 B 怀疑，他不会抛太多次。现在小 A 想问你，在多少种可能的情况下，他能够胜过小 B 呢？由于答案可能太大，所以你只需要输出答案在十进制表示下的最后 k 位即可。

## 数据范围

100%的数据满足 1≤a,b≤10^15,b≤a≤b+10000,1≤ k≤9

数据组数小于等于10。

## 解题思路

[认真%一发这位大佬（压行真恐怖）](https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3726)

本题就是照着他的题解写的/~~抄的~~，感觉懂了，比较多吧，对于剩余系下的运算认识了很多。就全当锻炼了一下代码能力了吧；

接下来专门发一篇学习笔记；

## 易错误区

1. 不要 % 0 ！！！第一次写，把md当成了bs[ md ] 来用，全RE；

2. 一定记得，在a==b时，要让2的x次幂**减去**c( 2a-1 , a )；第一次写成＋了，WA了3
个点；~~一定是因为没有理解题解~~

## 代码展示

尝试了一发新的缩进方式……看不惯

2060ms，比较优秀了

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof(x))
#define mem1(x) memset((x),0x3f,sizeof(x))
#define N 10000010
#define M 2000100
#define int ll
int a, b, k;
int bru[2][1953200];
int bs[2], mod[2];
int m = 1000000000;
int qpow(int a, int b, int md)
{
    int ret = 1;
    for (; b; b >>= 1, a = (a * a) % md) if (b & 1) ret = (ret * a) % md;
    return ret;
}
il void exgcd(int a, int &x, int b, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return;
    }
    exgcd(b, y, a % b, x);
    y -= a / b * x;
}
il int inv(int a, int b)
{
    int x, y;
    exgcd(a, x, b, y);
    return (x + b) % b;
}
il int sunzi(int a, int b)
{
    return (a * mod[1] % m * inv(mod[1] % mod[0], mod[0]) % m + b * mod[0] % m * inv(mod[0], mod[1]) % m) % m;
}
int lucas(int n, int md)
{
    if (n == 0) return 1;
    return lucas(n / bs[md], md) * qpow(bru[md][mod[md] - 1], n / mod[md], mod[md]) % mod[md] * bru[md][n % mod[md]] % mod[md];
}
int c(int n, int m, int md)
{
    int d = 0;
    for (ri i = n; i; i /= bs[md]) d += i / bs[md];
    for (ri i = m; i; i /= bs[md]) d -= i / bs[md];
    for (ri i = n - m; i; i /= bs[md]) d -= i / bs[md];
    if (d >= 9) return 0;
    int p1 = lucas(n, md), p2 = lucas(m, md), p3 = lucas(n - m, md);
    return qpow(bs[md], d, mod[md]) * p1 % mod[md] *  inv(p2, mod[md]) % mod[md] * inv(p3, mod[md]) % mod[md];
}
int solve()
{
    int ret2 = 0, ret5 = 0, ret = 0;
    if (a == b)
    {
        ret2 = c((a << 1) - 1, a, 0), ret5 = c((a << 1) - 1, a, 1);
		ret = m-sunzi(ret2, ret5);
        ret = (ret + qpow(2, a + b - 1, m)) % m;
    }
    else if ((a + b) & 1)
    {
        for (ri i = b + 1; i <= ((a + b) >> 1); i++) ret2 += c(a + b, i, 0), ret2 %= mod[0];
        for (ri i = b + 1; i <= ((a + b) >> 1); i++) ret5 += c(a + b, i, 1), ret2 %= mod[1];
        ret = sunzi(ret2, ret5);
        ret = (ret + qpow(2, a + b - 1, m)) % m;
    }
    else
    {
        for (ri i = b + 1; i < ((a + b) >> 1); i++) ret2 += c(a + b, i, 0), ret2 %= mod[0];
        ret2 += c(a + b - 1, ((a + b) >> 1), 0), ret2 %= mod[0];
        for (ri i = b + 1; i < ((a + b) >> 1); i++) ret5 += c(a + b, i, 1), ret2 %= mod[1];
        ret5 += c(a + b - 1, ((a + b) >> 1), 1), ret5 %= mod[1];
        ret = sunzi(ret2, ret5);
        ret = (ret + qpow(2, a + b - 1, m)) % m;
    }
    return ret;
}
void prebru()
{
    bs[0] = 2, bs[1] = 5;
    mod[0] = 512, mod[1] = 1953125;
    bru[0][0] = bru[1][0] = 1;
    for (ri i = 1; i <= mod[0]; i++)
        if (i & 1) bru[0][i] = (bru[0][i - 1] * i) % mod[0];
        else bru[0][i] = bru[0][i - 1];
    for (ri i = 1; i <= mod[1]; i++)
        if (i % 5) bru[1][i] = (bru[1][i - 1] * i) % mod[1];
        else bru[1][i] = bru[1][i - 1];
}
int ans[12];
void print(int x)
{
    mem0(ans);
    for (ri i = 1; i <= 10; i++, x /= 10) ans[i] = x % 10;
    for (ri i = k; i >= 1; i--) printf("%lld", ans[i]);
    puts("");
}
signed main()
{
    prebru();
    while (scanf("%lld%lld%lld", &a, &b, &k) != EOF)
    {
        print(solve());
    }
    return 0;
}

```

---

## 作者：Nuisdete (赞：1)

先写出原式子：

$$\sum_{i = 0}^{a} \sum_{j = 0}^b \binom ai \binom bj \left[i > j\right]$$

转化一下：

$$\sum_{j = 0}^{b} \sum_{i = j + 1}^a \binom ai \binom bj$$

$$\sum_{j = 0}^{b} \sum_{i = 1}^{a - j} \binom {a}{i + j} \binom b{b - j}$$

$$\sum_{i = 1}^{a} \sum_{j = 0}^{\min(b, a - i)} \binom {a}{i + j} \binom b{b - j}$$

然后我们手玩一下发现 $j$ 的那个上界可以设为 $b + i$，于是根据范德蒙德卷积：

$$\sum_{i = 1}^{a} \binom {a + b}{b + i}$$

再简单转化一下：

$$\sum_{i = 0}^{a - 1} \binom {a + b}i$$

然后我们发现 $0 \leq a - b \leq 10^4$，于是给它拆成：

$$\sum_{i = 0}^{\frac{a + b}{2}}\binom{a + b}i + \sum_{i = \frac{a + b}{2} + 1}^{a - 1} \binom {a + b}i$$

前面那个就是 $2^{a + b - 1}$，后面那个可以用 exlucas 解决。除以 $2$ 可能没有逆元，拆成递推式就可以解决了，然后分奇偶特判一下特殊情况，同时可以看看讨论区那个 exlucas 的卡常方法。

```cpp
# include <cstdio>
# include <cmath>
# include <cassert>

# define int long long

constexpr int MAXN = 1e6 + 5;

int p, pk;

int fac[6][MAXN << 1];

int fpow(int x, int k, int MOD) {
	int res = 1;
	for (; k; k >>= 1) {
		if (k & 1) res = res * x % MOD;
		x = x * x % MOD;
	}
	return res;
}

void exgcd(int a, int b, int& x, int& y) {
	if (!b) x = 1, y = 0;
	else exgcd(b, a % b, y, x), y -= x * (a / b);
}

int inv(int a, int MOD) {
	int x, y;
	exgcd(a, MOD, x, y);
	return (x % MOD + MOD) % MOD;
}

int g(int n) {
	return !n ? 0 : n / p + g(n / p);
}

int f(int n) {
	return !n ? 1 : f(n / p) * fpow(fac[p][pk], n / pk, pk) % pk * fac[p][n % pk] % pk;
}

int exlucas(int n, int m) {
  p = 2, pk = 512;
	int a = fpow(p, g(n) - g(m) - g(n - m), pk) ? f(n) * inv(f(m), pk) % pk * inv(f(n - m), pk) % pk * fpow(p, g(n) - g(m) - g(n - m), pk) % pk : 0, x = pk;
	p = 5, pk = 1953125; 
  int b = fpow(p, g(n) - g(m) - g(n - m), pk) ? f(n) * inv(f(m), pk) % pk * inv(f(n - m), pk) % pk * fpow(p, g(n) - g(m) - g(n - m), pk) % pk : 0, y = pk;
  int mod = x * y;
	return (a * y % mod * inv(y, x) % mod + b * x % mod * inv(x, y) % mod) % mod;
}

signed main() {

  int a, b, k; fac[5][0] = fac[2][0] = 1;
  for (int i = 1; i <= 512; ++i) fac[2][i] = i & 1 ? fac[2][i - 1] * i % 512 : fac[2][i - 1];
  for (int i = 1; i <= 1953125; ++i) fac[5][i] = i % 5 == 0 ? fac[5][i - 1] : fac[5][i - 1] * i % 1953125;
  
  while (scanf("%lld %lld %lld", &a, &b, &k) != EOF) {
    int MOD = pow(10, k), ans = fpow(2, a + b - 1, MOD);
    if (a + b & 1 ^ 1) ans = ((ans - exlucas(a + b - 1, a + b >> 1)) % MOD + MOD) % MOD;
    for (int i = (a + b >> 1) + (a + b & 1); i < a; ++i) ans = (ans + exlucas(a + b, i)) % MOD;
    printf("%0*lld\n", (signed)k, ans);
  }

  return 0;
}
```

---

## 作者：lnzwz (赞：0)

推式子+exlucas。

题意：

    小 A 和小 B 是一对好朋友，两个人同时抛 b 次硬币，如果小 A 的正面朝上的次数       大于小 B 正面朝上的次数，则小 A 获胜。
    小 A 决定在小 B 没注意的时候作弊，悄悄地多抛几次硬币，当然，为了不让小 B 怀疑，他不会抛太多次。
    现在小 A 想问你，在多少种可能的情况下，他能够胜过小 B 呢？由于答案可能太大，所以你只需要输出答案在十进制表示下的最后 k 位即可。
    有多组数据，对于每组数据输入三个数a,b,k，分别代表小A抛硬币的次数，小B抛硬币的次数，以及最终答案保留多少位整数。

$a,b\leq10^{15}$，$b\leq a\leq b+10000$，$k\leq9$。

看起来不太好做，但注意到$b\leq a\leq b+10000$。即$0\leq a-b \leq 10000$。

考虑两种情况：

1、在小A投b次时，就胜过小B。

先考虑前b个：总数为$2^{b+b}$，前b个相等的有$C(b,i)^2$之和，即$C(b+b,b)$。

由于大于和小于等价，所以方案数为$({2^{b+b}}-C(b+b,b))*2^{a-b}/2$。

$C(b+b,b)=C(b+b-1,b)+C(b+b-1,b-1)=2C(b+b-1,b)$，

所以原式=$({2^{b+b}}-C(b+b-1,b))*2^{a-b}$。

2、在小A投b次时，没有胜过小B。

设小A前b次有x次，后a-b次有z次，小B有y次。则$x+z>y$，即$y-x<z$。设$i=y-x,z>i$。

枚举i，则前b个方案数为$C(b,x)*C(b,x+i)$之和，即$C(b,b-x)*C(b,x+i)$之和，等于$C(b+b,b+i)$。

后a-b个方案数为$C(a-b,z)(z>i)$之和，可以枚举时维护后缀和。

但是，模数为$10^k$，不是质数，很讨厌，需要exlucas。

首先，计算出$C(n,m)mod 2^k$，$C(n,m)mod 5^k$，通过中国剩余定理，可以算出$C(n,m)mod 10^k$。

以$5^k$为例：

因为$5^k$不是质数，不能lucas，需要用$C(n,m)=n!/(m!*(n-m)!)$计算。

然而，由于m很大时，$m! mod 5^k=0$，无法求逆元。

所以，把$n!,m!,(n-m)!$中的5都拆出来，即化成$a*5^b$的性质。

暴力拆：例如$k=2$，$n=60$。

$60!=1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19*20*21*22*23*24*25*26*27*28*29*30*31*32*33*34*35*36*37*38*39*40*41*42*43*44*45*46*47*48*49*50*51*52*53*54*55*56*57*58*59*60$。

把5提出，

$60!=1*2*3*4*6*7*8*9*11*12*13*14*16*17*18*19*21*22*23*24*26*27*28*29*31*32*33*34*36*37*38*39*41*42*43*44*46*47*48*49*51*52*53*54*56*57*58*59*12!*5^{12}$。

12!可以递归，考虑前面一堆：

我们发现，在mod25意义下，

$1*2*3*4*6*7*8*9*11*12*13*14*16*17*18*19*21*22*23*24=26*27*28*29*31*32*33*34*36*37*38*39*41*42*43*44*46*47*48*49$。

就是mod25后，有一堆循环节，所以只要算

出$1*2*3*4*6*7*8*9*11*12*13*14*16*17*18*19*21*22*23*24$，然后快速幂即可。

后面还有零散的$51*52*53*54*56*57*58*59$，暴力算即可。

但是，这个算法需要$5^9*10000*10$次计算，显然超时。

考虑预处理：

首先，

$1*2*3*4*6*7*8*9*11*12*13*14*16*17*18*19*21*22*23*24$可以预处理出。

其次，零散的$51*52*53*54*56*57*58*59$是一个前缀积，也可以预处理出。

这样，一次exlucas就是$O(log^2n)$的了（有快速幂的log）。

然而还是超时，考虑剪枝：

对于$n!=a*x^b$，其中b可以很快算出。所以$C(n,m)=a*x^b$，求出b如果大于等于k，则为0。

这样就很快了。

代码：
```cpp
#include <stdio.h> 
#define ll long long 
int md;
int ksm(int a, ll b) {
	int jg = 1;
	while (b > 0) {
		if (b & 1) jg = 1ll * jg * a % md;
		a = 1ll * a * a % md;
		b = (b >> 1);
	}
	return jg;
}
int j2[520],j5[1953130],m2,m5,m21,m51;
void dfs2(ll n, int & a, ll & b, int xk) {
	if (n == 0) return;
	int ta = 1;
	ll tb = 0;
	dfs2(n >> 1, ta, tb, xk);
	a = 1ll * a * ta % md;
	b += tb + (n >> 1);
	if (n >= xk) a = 1ll * a * ksm(j2[xk - 1], n / xk) % md;
	a = 1ll * a * j2[n - (n / xk) * xk] % md;
}
void dfs5(ll n, int & a, ll & b, int xk) {
	if (n == 0) return;
	int ta = 1;
	ll tb = 0;
	dfs5(n / 5, ta, tb, xk);
	a = 1ll * a * ta % md;
	b += tb + n / 5;
	if (n >= xk) a = 1ll * a * ksm(j5[xk - 1], n / xk) % md;
	a = 1ll * a * j5[n - (n / xk) * xk] % md;
}
ll jisuan(ll tn, int x) {
	ll ms = 0;
	while (tn > 0) {
		ms += tn / x;
		tn /= x;
	}
	return ms;
}
int getC2(ll n, ll m, int k) {
	if (jisuan(n, 2) - jisuan(m, 2) - jisuan(n - m, 2) >= k) return 0;
	int a1 = 1,	a2 = 1,	a3 = 1;
	ll b1 = 0,	b2 = 0,	b3 = 0;
	dfs2(n, a1, b1, m2);
	dfs2(m, a2, b2, m2);
	dfs2(n - m, a3, b3, m2);
	b1 -= (b2 + b3);
	a1 = 1ll * a1 * ksm(1ll * a2 * a3 % md, m21 - 1) % md;
	return 1ll * a1 * ksm(2, b1) % m2;
}
int getC5(ll n, ll m, int k) {
	if (jisuan(n, 5) - jisuan(m, 5) - jisuan(n - m, 5) >= k) return 0;
	int a1 = 1,	a2 = 1,	a3 = 1;
	ll b1 = 0,	b2 = 0,	b3 = 0;
	dfs5(n, a1, b1, m5);
	dfs5(m, a2, b2, m5);
	dfs5(n - m, a3, b3, m5);
	b1 -= (b2 + b3);
	a1 = 1ll * a1 * ksm(1ll * a2 * a3 % md, m51 - 1) % md;
	return 1ll * a1 * ksm(5, b1) % m5;
}
int c2,c5;
int C(ll n, ll m, int k) {
	if (m < 0 || m > n) return 0;
	int z2 = getC2(n, m, k);
	int z5 = getC5(n, m, k);
	return (1ll * z2 * c2 + 1ll * z5 * c5) % md;
}
int main() {
	ll a,b;
	int k,
	lk = -1;
	while (scanf("%lld%lld%d", &a, &b, &k) == 3) {
		if (k != lk) {
			md = 1;
			for (int i = 0; i < k; i++) md *= 10;
			m2 = ksm(2, k);
			m5 = ksm(5, k);
			m21 = ksm(2, k - 1);
			m51 = 4 * ksm(5, k - 1);
			c2 = 1ll * m5 * ksm(m5 % m2, m21 - 1) % md;
			c5 = 1ll * m2 * ksm(m2, m51 - 1) % md;
			j2[0] = j5[0] = 1;
			for (int i = 1; i < m2; i++) {
				j2[i] = j2[i - 1];
				if (i % 2 != 0) j2[i] = 1ll * j2[i] * i % md;
			}
			for (int i = 1; i < m5; i++) {
				j5[i] = j5[i - 1];
				if (i % 5 != 0) j5[i] = 1ll * j5[i] * i % md;
			}
		}
		int ans = 1ll * (ksm(2, b + b - 1) - C(b + b - 1, b, k) + md) % md * ksm(2, a - b) % md;
		for (int i = a - b - 1, h = 0; i >= 0; i--) {
			h = (h + C(a - b, i + 1, k)) % md;
			ans = (ans + 1ll * C(b + b, b + i, k) * h) % md;
		}
		char zf[20];
		sprintf(zf, "%d", ans + md);
		printf("%s\n", zf + 1);
		lk = k;
	}
	return 0;
}
```

---


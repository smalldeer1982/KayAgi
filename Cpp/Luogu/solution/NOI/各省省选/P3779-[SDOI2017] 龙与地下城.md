# [SDOI2017] 龙与地下城

## 题目描述

小 Q 同学是一个热爱学习的人，但是他最近沉迷于各种游戏，龙与地下城就是其中之一。

在这个游戏中，很多场合需要通过掷骰子来产生随机数，并由此决定角色未来的命运，因此骰子堪称该游戏的标志性道具。

骰子也分为许多种类，比如 $4$ 面骰、$6$ 面骰、$8$ 面骰、$12$ 面骰、$20$ 面骰，其中 $20$ 面骰用到的机会非常多。当然，现在科技发达，可以用一个随机数生成器来取代真实的骰子，所以这里**认为骰子就是一个随机数生成器**。

在战斗中，骰子主要用来决定角色的攻击是否命中，以及命中后造成的伤害值。举个例子，假设现在已经确定能够命中敌人，那么 $YdX$（也就是掷出 $Y$ 个 $X$ 面骰子之后所有骰子显示的数字之和）就是对敌人的基础伤害。在敌人没有防御的情况下，这个基础伤害就是真实伤害。

众所周知，骰子显示每个数的概率应该是相等的，也就是说，对于一个 $X$ 面骰子，显示 $0, 1, 2,\dots ,X−1$ 中每一个数字的概率都是 $\dfrac {1}{X}$。

更形式化地说，这个骰子显示的数 $W$ 满足离散的均匀分布，其分布列为

| $H$ | $0$ | $1$ | $2$ | $\cdots$ | $X-1$ |
| :--: | :--: | :--: | :--: | :--: | :--: |
| $P$ | $\dfrac {1}{X}$ | $\dfrac {1}{X}$ | $\dfrac {1}{X}$ | $\cdots$ | $\dfrac {1}{X}$ |


除此之外还有一些性质：

- $W$ 的**一阶原点矩**（**期望**）为

$$v_1(W)=E(W)=\sum_{i=0}^{X-1}i\cdot P(W=i)=\frac {X-1}{2}$$

- $W$ 的**二阶中心矩**（**方差**）为

$$\mu_2(W)=E((W-E(W))^2)=\sum_{i=0}^{X-1}(i-E(W))^2\cdot P(W=i)=\frac {X^2-1}{12}$$

言归正传，现在小 Q 同学面对着一个生命值为 A 的没有防御的敌人，能够发动一次必中的 $YdX$ 攻击，显然只有造成的伤害不少于敌人的生命值才能打倒敌人。但是另一方面，小 Q 同学作为强迫症患者，不希望出现 overkill，也就是造成的伤害大于 $B$ 的情况，因此**只有在打倒敌人并且不发生 overkill 的情况下小 Q 同学才会认为取得了属于他的胜利**。

因为小 Q 同学非常谨慎，他会进行 $10$ 次模拟战，每次给出敌人的生命值 $A$以及 overkill 的标准 $B$，他想知道此时取得属于他的胜利的概率是多少，你能帮帮他吗？


## 说明/提示

对于 $100\%$ 的数据，$T \leq 10$，$2 \leq X \leq 20$，$1 \leq Y \leq 200000$，$0 \leq A \leq B \leq (X-1)Y$。

**保证满足 $Y > 800$ 的数据不超过 $2$ 组。**

| 测试点编号 | $X$ | $Y$ | 备注 |
| :--: | :--: | :--: | :--: |
| $1$ | $\le 20$ | $\le 40$ | $X^Y\le 10^7$ |
| $2\sim 4$ | $\le 20$ | $\le 1\, 600$ | - |
| $5\sim 10$ | $\le 20$ | $\le 8\, 000$ | - |
| $11,12$ | $=2$ | $\le 200\, 000$ | - |
| $13\sim 20$ | $\le 20$ | $\le 200\, 000$ | - |


## 样例 #1

### 输入

```
1
2 19
0 0
0 1
0 2
0 3
0 4
0 5
0 6
0 7
0 8
0 9```

### 输出

```
0.000002
0.000038
0.000364
0.002213
0.009605
0.031784
0.083534
0.179642
0.323803
0.500000```

# 题解

## 作者：shadowice1984 (赞：19)

讲道理这道题会给人一种“还有这种操作”的感觉……

# 中心极限定理

### 前置芝士：正态分布

什么是正态分布，所谓正态分布呢……就是一个随机变量X的一种分布形式，我们都知道一个随机变量的概率分布情况会有很多种，比如均匀分布，就是在一定值域内取每个地方的值的概率都是一样的，比如二项分布，只能是两种值(例如抛硬币)

然后正态分布就是各种概率分布情况的一种，它有什么用呢？正态分布有一个特点，就是它只需要一个期望$μ$和一个方差$σ^{2}$就可以描述，我们记做N($μ,σ^{2}$)，感性的理解的话，正态分布的特点是中间高，两边低，概率密度曲线为钟形

但是真正使正态分布重要的还是中心极限定理……这个后面讲

### 前置芝士：概率密度函数

如果一个随机变量是离散的，我们似乎可以用一个表格，列出每个值出现的概率

但是如果我们要描述一个连续型随机变量呢？显然它取任何一个值的概率都是0啊……，但是显然值落在某一个区间的概率可以不是0啊

所以我们使用了一种被称为**概率密度函数**的东西来描述这个随机变量的分布情况

连续型随机变量x的概率密度函数f(x)需要满足这样一个条件，才可以是这个变量的概率密度函数

**f(x)在某一区间的积分，等于x落在这个区间的概率**

更粗暴的一点讲，f(x)在某一区间内和X轴所围成的图形面积等于X落在这个区间的概率

那么正态分布的概率密度函数是什么呢，设这个正态分布为N($μ,σ^{2}$)那么我们会发现它的概率密度函数为

## $f(x)=\frac{1}{\sqrt{2πσ^{2}}}e^{-\frac{(x-μ)^{2}}{2σ^{2}}}$

其中e的若干次方可以用cmath库中的exp()函数计算，所以我们一旦证明了一个变量服从正态分布，接下来的工作就是对着目标区间大力辛普森积分即可了

---------------

中心极限定理的内容：

设有n个独立同分布的随机变量x，那么……满足……

抱歉这个东西我看不懂……

但是我们呢做这道题用的是中心极限定理一个较为亲民的一个**推论**

若有N个独立同分布的随机变量$x_{1}……x_{n}$期望为$μ$方差为$σ^{2}$

那么设

# $Y_{n}=\frac{\sum^{n}_{i=1}x_{i}-nμ}{\sqrt{nσ^{2}}}$

则当n足够大的时候~~(当满足我们的eps要求的时候)~~可以认为$Y_{n}$服从正态分布N(0,1)

所以我们发现一件事，出题人已经给了我们x的方差和期望了，我们此时运用一下高一数学的基本操作就可以发现，如果

### $\sum^{n}_{i=1}xi∈[A,B]$

那么有

## $Y_{n}∈[\frac{A-nμ}{\sqrt{nσ^{2}}},\frac{B-nμ}{\sqrt{nσ^{2}}}]$

此时我们发现一件事，这就是道中心极限定理的裸题……

我们唯一要做的事就是转了A,B范围之后对着正态分布的概率密度函数大力辛普森积分，毕竟误差要求贼宽对吧……，但是再怎么说n=1之类的情况我们是不可以认为n足够大的，因此我们又要使用对数据分情况讨(骗)论(分)的技巧了

## 小数据做法：快速傅里叶变换(FFT)

对于一些小的数据我们呢发现可以这样做

构造一个多项式，次数为0~x-1，我们呢希望这个构造出来的多项式满足这样一个条件：就是次数为a的项的系数就是**编号和为a的概率**

显然一开始每一项的系数都是$\frac{1}{x}$

接下我们呢考虑转移，把这个式子平方一下，我们会发现新的多项式也满足刚才的性质，为什么呢？考虑我们在做乘法的时候做了什么，对于一个新的项，我们相当于枚举了这两次掷骰子的所有可能情况，相乘再相加，刚好和多项式乘法的工作原理相同，同理也有3次，4次，y次方的情况

或者你也可以认为是dp，转移方程是卷积的形式然后再去用fft优化

所以我们要做的事情就变得很简单了，构造这样一个多项式，然后计算它的y次方，最后再计算次数从A-B的和就OK了

~~什么你不会fft?出门左转luogu膜板区，包教包会~~

----------------

之后就没啥难度了，如果你不会Simpson积分法的话这里可以简单的介绍下

## 自适应Simpson积分法

大概就是我们要求一个函数的曲线下面积，然后我们怎么求呢？

最简单的想法是切片法，定一个eps然后一路矩形切片切过去

另一种想法是梯形法，就是把刚才的矩形变成梯形，但是刚才的两种做法就是怕函数突变，所以我们需要采取一种更科学的方法-自适应Simpson积分法

我们粗暴的认为这个曲线是一个抛物线，我们这样就可以用抛物线的曲线下面积公式

### $\frac{(r-l)(f(l)+4f(mid)+f(r))}{6}$

来计算了，同时为了避免精度不够，我们再用l,mid和mid,r两部分的面积和来看一下差是否满足eps，如果精度不够就递归下去，最后我们就暴力的把这个函数的积分求了出来……

下面上代码吧，写起来就是俩板子，挺好写的……

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
typedef double db;
const db eps=1e-12;const int N=524300;const db pi=acos(-1);int T;
const int Mlim=524288;const db K=1/sqrt(2*pi);int x;int y;int lim;
struct cmp//虚数类 
{
	db r;db v;cmp(db a=0,db b=0){r=a;v=b;}
	friend cmp operator +(cmp a,cmp b){return cmp(a.r+b.r,a.v+b.v);}
	friend cmp operator -(cmp a,cmp b){return cmp(a.r-b.r,a.v-b.v);}
	friend cmp operator *(cmp a,cmp b){return cmp(a.r*b.r-a.v*b.v,a.r*b.v+a.v*b.r);}
	void operator /=(db a){r/=a;v/=a;}
}res[N];int r[N];int len;
inline void clear(){for(int i=0;i<lim;i++){res[i]=cmp();r[i]=0;}}
inline cmp po(cmp a,int p){cmp r(1,0);for(;p;p>>=1,a=a*a){if(p&1){r=r*a;}}return r;}
inline void clacr(){for(int i=1;i<lim;i++){r[i]=r[i>>1]>>1|(i&1)<<len;}}//计算反转数组 
inline void fft(cmp* tp,int n,int op)//fft板子 
{
	for(int i=1;i<n;i++){if(i<r[i])swap(tp[i],tp[r[i]]);}
	for(int k=1;k<n;k<<=1)
	{
		for(int s=0;s<n;s+=2*k)
		{
			cmp now(1,0);cmp rt(cos(pi/k),op*sin(pi/k));
			for(int i=s;i<s+k;i++,now=now*rt)
			{cmp ev=tp[i];cmp od=tp[i+k];tp[i]=ev+now*od;tp[i+k]=ev-now*od;}
		}
	}if(op==-1){for(int i=0;i<n;i++){tp[i]/=n;}}
}
inline db f(db x){return K*exp(x*x/-2.0);}//正态分布的概率密度函数 
inline db psp(db l,db r){db mid=(l+r)/2.0;return (r-l)*(f(l)+4.0*f(mid)+f(r))/6.0;}
inline db sp(db l,db r)//然后这是Simpson积分的板子 
{
	db mid=(l+r)/2.0;db f1=psp(l,r);db f2=psp(l,mid)+psp(mid,r);
	db res=(-eps<f1-f2&&f1-f2<eps)?f1:sp(l,mid)+sp(mid,r);return res;
}
inline void solve()
{
	scanf("%d%d",&x,&y);lim=x*y;
	if(lim<=Mlim)//判断一下fft跑的过去还是跑不过去 
	{
		for(len=0;(1<<len)<=lim;len++);lim=(1<<len);len--;
		clacr();for(int i=0;i<x;i++){res[i].r=1/(db)x;}
		fft(res,lim,1);//直接快速幂即可 
		for(int i=0;i<lim;i++){res[i]=po(res[i],y);}
		fft(res,lim,-1);
		for(int i=1;i<=10;i++)
		{
			int a;int b;scanf("%d%d",&a,&b);db ret=0;
			for(int j=a;j<=b;j++){ret+=res[j].r;}
			printf("%.6lf\n",ret);
		}
	}
	else//大数据套中心极限定理 
	{
		db mu=(db)(x-1)/2;db sigma=(db)(x*x-1)/12;
		for(int i=1;i<=10;i++)//大力转A,B范围之后计算积分即可 
		{
			db a;db b;scanf("%lf%lf",&a,&b);
			a=(a-y*mu)/sqrt(y*sigma);b=(b-y*mu)/sqrt(y*sigma);
			printf("%.6lf\n",sp(0,b)-sp(0,a));
		}lim=0;
	}
}
int main()
{scanf("%d",&T);for(int z=1;z<=T;z++){solve();clear();}return 0;//拜拜程序~}
```







---

## 作者：zj余能 (赞：11)

概率论太难了，不会。但这不能阻止我们过题。
相信大家都会一个基于背包的暴力做法，我们可以将其看成是卷积的形式就可以用fft优化了。形式化讲，就是求幂级数$ (\sum\limits_{i = 0}^{x - 1} \frac{1}{x} z^i)^y $在$[z^A, z^B]$之间的系数和。

#### 不在模意义下的做法
直接将上述幂级数暴力倍增卷积求出来复杂度是$O(x*y*log(xy))$，不太能过的。但如果不在模意义下做我们就可以尝试爆精度爆过去。很容易发现最后求得的点数和很大概率就是在均值附近的，过大过小的概率几乎为0。也就是我们中间在做卷积和有很多项几乎为0，我们把他们忽略掉是在精度的承受范围之内的。于是我们在做倍增求出上述幂级数的时候我们可以每次只保留中间的一小段有值的部分，其余的扔掉就行了。也就是说我们设定一个阈值$\epsilon$，每次卷积后把多项式中值$\le \epsilon$的都扔掉。这样复杂度就是$O(len*log(len + y))$，其中$len$是最终幂级数中值$> \epsilon$的个数。实践证明，当$\epsilon$取$10^{-9}$时，$len$大概是两三万，并且此时的精度可以达到小数点后4位。

#### 在模意义下的做法
如果答案可以对某个质数取模，这题就更好做了。
考虑最开始的那个幂级数：

$(\sum\limits_{i = 0}^{x - 1} \frac{1}{x} z^i)^y = (\frac{1}{x} \frac{1 - z^x}{1 - z})^y = (\frac{1}{x})^y (1 - z^x)^y(\frac{1}{1 - z})^y$

我们想要求其在第$[A, B]$之间的系数和，我们可以乘上一个$\frac{1}{1 - x}$来做一次前缀和，这样我们可以转化成两次形如求一个$z^n$的系数的问题。也就是：

$[z^n] (\frac{1}{x})^y (1 - z^x)^y(\frac{1}{1 - z})^{y + 1}$

手动展开后面的两个：

$=[z^n] (\frac{1}{x})^y(\sum\limits_{i = 0}^{y}\binom{y}{i}(-1)^iz^{ix})(\sum\limits_{i = 0}\binom{y + i}{y}z^i)$

$=(\frac{1}{x})^y\sum\limits_{i = 0}^{y}\binom{y}{i}(-1)^i\binom{y + n - ix}{y}$

预处理组和数之后随便做一下就好了，复杂度$O(x*y)$。
 

做法一的代码：
```cpp

#include <bits/stdc++.h>

using namespace std;

namespace PO {
  const int N = 4e5 + 5;
  const double PI = acos(-1);
  
  struct Com {
    double x, y;
    friend Com operator + (Com a, Com b) {
      return (Com){ a.x + b.x, a.y + b.y };
    }
    friend Com operator - (Com a, Com b) {
      return (Com){ a.x - b.x, a.y - b.y };
    }
    friend Com operator * (Com a, Com b) {
      return (Com){ a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x };
    }
  } ta[N], tb[N], w[N];
  int rev[N], L = 1;
  typedef vector<Com> Poly;

  void Init(int l) {
    for (; L < l; L <<= 1) {
      for (int i = L; i < (L << 1); ++i) {
        w[i] = (Com){ cos(PI / L * (i - L)), sin(PI / L * (i - L)) };
      }
    }
    for (int i = 0; i < l; ++i) {
      rev[i] = (rev[i >> 1] >> 1) | (i & 1? l >> 1 : 0);
    }
  }
  
  void Dft(Com *a, int l) {
    for (int i = 0; i < l; ++i)
      if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int i = 1; i < l; i <<= 1) {
      for (int j = 0; j < l; j += i << 1) {
        Com *l = a + j, *r = l + i, *wx = w + i, y;
        for (int k = 0; k < i; ++k, ++l, ++r, ++wx) {
          y = (*r) * (*wx);
          *r = (*l) - y;
          *l = (*l) + y;
        }
      }
    }
  }
  void Idft(Com *a, int l) {
    reverse(a + 1, a + l);
    Dft(a, l);
    for (int i = 0; i < l; ++i) {
      a[i].x /= l;
      a[i].y /= l;
    }
  }

  vector<double> Mul(vector<double> a, vector<double> b) {
    int n = a.size(), m = b.size(), l;
    for (l = 1; l < n + m - 1; l <<= 1);
    Init(l);
    a.resize(l), b.resize(l);
    for (int i = 0; i < l; ++i) {
      ta[i] = (Com){ a[i], 0 };
      tb[i] = (Com){ b[i], 0 };
    }
    Dft(ta, l), Dft(tb, l);
    for (int i = 0; i < l; ++i) {
      ta[i] = ta[i] * tb[i];
    }
    Idft(ta, l);
    for (int i = 0; i < l; ++i) {
      a[i] = ta[i].x;
    }
    a.resize(n + m - 1);
    return a;
  }
  
}

void Cut(vector<double> &a, int &base) {
  const double GAMA = 1e-9;
  int id = 0;
  while (a[id] < GAMA) ++id;
  for (int i = 0; i + id < a.size(); ++i) {
    a[i] = a[i + id];
  }
  while (a.back() < GAMA) {
    a.pop_back();
  }
  base += id;
}

int main() {
  int tc;
  for (cin >> tc; tc--; ) {
    int x, y;
    cin >> x >> y;

    vector<double> ans(x * y);
    vector<double> F(x, 1.0 / x), G(1, 1);
    int base_f = 0, base_g = 0;
    for (int ex = y; ex; ex >>= 1) {
      if (ex & 1) {
        G = PO::Mul(G, F);
        base_g += base_f;
        Cut(G, base_g);
      }
      F = PO::Mul(F, F);
      base_f *= 2;
      Cut(F, base_f);
    }
    for (int i = 0; i < G.size(); ++i) {
      ans[i + base_g] = G[i];
    }
    for (int i = 1; i < x * y; ++i) {
      ans[i] += ans[i - 1];
    }
    
    for (int cas = 10; cas--; ) {
      int l, r;
      cin >> l >> r;
      printf("%.12f\n", ans[r] - (l? ans[l - 1] : 0));
    }
  }

  return 0;
}
```

---

## 作者：StudyingFather (赞：7)

这数学题太神仙了...

## FFT 做法

容易想到这样一种常规做法：设 $f(i,j)$ 表示掷完前 $i$ 个骰子后点数和为 $j$ 的概率，则有，

$$
f(i,j)=\sum_{0 \leq k \leq \min(j,X-1)} f(i-1,j-k) \times \frac{1}{X}
$$

边界显然是 $f(0,0)=1$。

注意到转移过程可以用多项式快速幂优化（相当于求 ($\sum_{i=0}^{X-1} \dfrac{1}{X}x^i)^Y$ 中各项的系数），时间复杂度为 $O(XY \log(XY))$，并不足以通过本题。

## 中心极限定理

如果用计算机模拟一下投掷骰子的过程的话，我们会发现，在骰子数量足够多的时候，各骰子数字之和出现的概率，呈现出**正态分布**的特征。

这个现象背后就是概率论中的**中心极限定理**。

中心极限定理告诉我们：对于 $N$ 个**独立同分布**（对应本题中完全相同的骰子）的随机变量 $X_1, X_2, \ldots, X_N$，若 $E(X_i)=\mu$，$D(X_i)=\sigma^2$，令，

$$
Y =\frac{\sum_{i=1}^N X_i - N\mu}{\sqrt{N\sigma^2}}
$$

则当 $N$ **足够大**时，$Y \sim N(0,1)$。

而我们在高中数学中已经学习到，对于正态分布 $N(\mu,\sigma^2)$，其概率密度函数的解析式为：

$$
f(x)=\frac{1}{\sqrt{2\pi\sigma}}e^{\frac{-(x-\mu)^2}{2 \sigma^2}}
$$

因此我们只需求出 $f(x)$ 在相应区间内的积分即可。

求解积分需要用到 [自适应辛普森法](https://oi-wiki.org/math/integral/)，这里不再展开。

需要注意的是，上述讨论均在骰子个数**足够多**的情况下进行，当骰子的数量较少时，将点数之和近似为正态分布显然是不合适的，这时候仍然需要采用常规的 FFT 方法来解决。

```cpp
// Problem: P3779 [SDOI2017]龙与地下城
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3779
// Memory Limit: 500 MB
// Time Limit: 1000 ms
// Author: StudyingFather
//
// Powered by CP Editor (https://cpeditor.org)

#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;
const double PI = 3.1415926535897;
namespace fft {
const int MAXL = (1 << 16) + 5;
struct complex {
  complex(double a = 0, double b = 0) { this->a = a, this->b = b; }
  double a, b;
} res[MAXL];
int r[MAXL];
complex operator+(complex x, complex y) {
  return complex(x.a + y.a, x.b + y.b);
}
complex operator-(complex x, complex y) {
  return complex(x.a - y.a, x.b - y.b);
}
complex operator*(complex x, complex y) {
  return complex(x.a * y.a - x.b * y.b, x.b * y.a + y.b * x.a);
}
complex fpow(complex x, int y) {
  complex ans(1, 0);
  while (y) {
    if (y & 1) ans = ans * x;
    x = x * x;
    y >>= 1;
  }
  return ans;
}
void fft(complex *f, int n, int op) {
  for (int i = 0; i < n; i++)
    if (i < r[i]) swap(f[i], f[r[i]]);
  for (int i = 2; i <= n; i <<= 1) {
    int len = i >> 1;
    complex tmp1(cos(PI / len), op * sin(PI / len));
    for (int j = 0; j < n; j += i) {
      complex tmp2(1, 0);
      for (int k = j; k < j + len; k++) {
        complex x = tmp2 * f[len + k];
        f[len + k] = f[k] - x;
        f[k] = f[k] + x;
        tmp2 = tmp2 * tmp1;
      }
    }
  }
  if (op == -1) {
    for (int i = 0; i <= n; i++) f[i].a /= n, f[i].b /= n;
  }
}
void solve(int x, int y) {
  memset(res, 0, sizeof(res));
  memset(r, 0, sizeof(r));
  for (int i = 0; i < x; i++) res[i].a = 1.0 / x;
  int len = 1;
  while (len <= x * y) len <<= 1;
  for (int i = 0; i < len; i++)
    r[i] = (r[i >> 1] >> 1) | ((i & 1) ? len >> 1 : 0);
  fft(res, len, 1);
  for (int i = 0; i < len; i++) res[i] = fpow(res[i], y);
  fft(res, len, -1);
  for (int i = 1; i <= 10; i++) {
    int a, b;
    cin >> a >> b;
    double ans = 0;
    for (int j = a; j <= b; j++) ans += res[j].a;
    cout << ans << endl;
  }
}
}  // namespace fft
namespace simpson {
double f(double x) { return exp((-x * x) / 2) / sqrt(2 * PI); }
double simpson(double l, double r) {
  double mid = (l + r) / 2;
  return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
}
double asr(double l, double r, double eqs, double ans, int step) {
  double mid = (l + r) / 2;
  double fl = simpson(l, mid), fr = simpson(mid, r);
  if (abs(fl + fr - ans) <= 15 * eqs && step < 0)
    return fl + fr + (fl + fr - ans) / 15;
  else
    return asr(l, mid, eqs / 2, fl, step - 1) +
           asr(mid, r, eqs / 2, fr, step - 1);
}
double calc(double l, double r, double eqs) {
  return asr(l, r, eqs, simpson(l, r), 8);
}
void solve(int x, int y) {
  double mu = (x - 1) / 2.0, sig2 = (x * x - 1) / 12.0;
  for (int i = 1; i <= 10; i++) {
    double a, b;
    cin >> a >> b;
    a = (a - y * mu) / sqrt(y * sig2), b = (b - y * mu) / sqrt(y * sig2);
    cout << calc(a, b, 1e-4) << endl;
  }
}
}  // namespace simpson
int main() {
  int T;
  cin >> T;
  while (T--) {
    int x, y;
    cin >> x >> y;
    if (x * y <= (1 << 15))
      fft::solve(x, y);  // use FFT for small testcase
    else
      simpson::solve(x, y);  // use simpson for large testcase
  }
  return 0;
}
```

---

## 作者：Freopen (赞：2)

有$Y$个概率均匀取值在$0...X-1$的离散变量$\{x_{i}\}$。

求$A\leq \sum x_i \leq B$的概率。

容易发现当$Y$很大的时候这个概率我们可以抽象成正态分布。

出题人给出了其期望为$\mu = n\frac {X-1}2$，方差为$\sigma^2 = n\frac {X^2-1}{12}$

等等为什么$n$个变量和的方差只需要$\times n$？
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200701172428635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTUwMDA0,size_16,color_FFFFFF,t_70)
~~为了方便调用库函数~~，我们将这个正态分布化为$N(0,1)$也即标准正态分布。

具体的，我们就是要求$N(0,1)$在$\frac {A - \mu}{\sigma} \rightarrow \frac {B - \mu}{\sigma}$的和。

$N(0,1)$的概率分布函数：$\frac 1{\sqrt {2\pi}}\int_0^xe^{\frac {-t^2}2}{\rm d}t$

换一下元$u = \frac t{\sqrt 2}$

则原式变为$\frac 1{\sqrt {2\pi}}\sqrt 2\int_0^{\frac x{\sqrt 2}}e^{-u^2}{\rm d}u$

（因为$\int$的范围缩小了$\sqrt 2$倍所以要乘上$\sqrt 2$。）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200701172952672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTUwMDA0,size_16,color_FFFFFF,t_70)
所以原式为$\frac 12 {\rm erf(\frac x{\sqrt 2})}$，大范围直接计算。

对于小范围的数据不一定是很符合正态分布的，

但是我们发现小范围就直接是一个多项式快速幂，

发现这个底数多项式的次数才$20$，

~~这放在2020年还写FFT就有点问题了~~

直接$O(20Y)$求多项式快速幂即可。

$\mathcal AC \ Code$

```cpp
#include<bits/stdc++.h>
#define db double
#define rep(i,j,k) for(int i=(j),LIM=(k);i<=LIM;i++)
#define per(i,j,k) for(int i=(j),LIM=(k);i>=LIM;i--)
using namespace std;

db X,Y,mu,sig;
#define maxn 2500
db A[maxn],B[maxn],sm[maxn];

int main(){
	int T;
	for(scanf("%d",&T);T--;){
		scanf("%lf%lf",&X,&Y);
		if(X * Y <= 2000){
			B[0] = pow(1/X,Y);
			rep(i,1,X*Y-1){
				B[i] = 0;
				rep(j,1,min((int)X-1,i))
					B[i] += Y * j * B[i-j] - (i-j) * B[i-j];
				B[i] /= i;
			}
			rep(i,0,X*Y-1) sm[i] = (i ? sm[i-1] : 0) + B[i];
			for(int tim=1;tim<=10;tim++){
				int a,b;scanf("%d%d",&a,&b);
				printf("%.10lf\n",sm[b] - (a ? sm[a-1] : 0));
			}
		}
		else{
			mu = (X-1) / 2 * Y , sig = sqrt((X*X-1) / 12 * Y);
			for(int tim = 1;tim <= 10;tim++){
				int A,B;
				scanf("%d%d",&A,&B);
				printf("%.10lf\n",(erf((B - mu) / sig / sqrt(2)) - erf((A - 1 - mu) / sig / sqrt(2))) / 2);
			} 
		}
	}
}
```


---

## 作者：littlez_meow (赞：1)

非常文化课的一道题。

前置知识：最新人教版高中数学选择性必修三。

[题目指路](https://www.luogu.com.cn/problem/P3779)。

## 简洁版题意

设随机变量 $R$ 满足 $0\sim X-1$ 的离散均匀分布，求 $P(a\le Y\cdot R\le b)$

## 思路 1

考虑概率生成函数 PGF。

设随机变量 $R$ 的概率生成函数为：

$$F(x)=\sum\limits_{i=0}^{X-1}P(R=i)x^i=\sum\limits_{i=0}^{X-1}\dfrac 1 X x^i$$

根据 PGF 的性质，随机变量 $U+V$ 的 PGF 等于 $U$ 的 PGF 乘上 $V$ 的 PGF。

因此，$Y\cdot R$ 的 PGF 为 $F^Y(x)$。

用 FFT 算多项式快速幂，时间复杂度 $O(XY\log (XY))$。

如果你 FFT 常数特别厉害，已经可以过本题了，你可以跳过以下内容。

否则，你面临以下问题：

1. FFT 并跑不过去。

2. FFT 是 10 级知识点不能考。

我们先来解决第二个问题。

让我们回看高中课本，发现上面提到了一个原则—— $3\sigma$ 原则，绝大部分样本落在 $\mu\pm3\sigma$ 的地方。

也就是说，$R$ 的 PGF 两侧次数极小和次数极大的地方并不会对答案产生多大贡献，可以直接丢掉。

此时换成暴力卷积，复杂度为 $O(XYB)$，其中 $B$ 为选定保留的转移长度。

下面来解决第一个问题。

## 思路 2

发现精度限制比较松，考虑一些拟合。

而我们有概率论中最重要的定理之一：中心极限定理。

**【中心极限定理】** 对于独立同分布的随机变量的和随样本量的变大会收敛至正态分布。

我们套进这道题一个一个词的看。

首先看前提“独立同分布”。本题中每次掷骰子都是相互独立的，且都满足 $0\sim X-1$ 的离散均匀分布，显然是满足离散同分布的。

再看“样本量”，本题中就是骰子个数 $Y$，在其很大时我们的思路 1 没有办法高效解决，满足样本量很大。

因此，其收敛至正态分布 $N(n\mu,n\sigma^2)$。

剩下的部分就是对正态分布的概率密度函数作积分了，自适应辛普森法即可。

注意到精度可能会卡掉自适应辛普森，需要将 $N(n\mu,n\sigma^2)$ 转化成 $N(0,1)$ 积分。

代码简单就不给了。

完结撒花 qaq~

---

## 作者：Tsawke (赞：1)

# [LG-P3779 [SDOI2017] 龙与地下城](https://www.luogu.com.cn/problem/P3779) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P3779-Solution)

### 题面

给定一个 $ m $ 面的骰子，等概率产出 $ 0, 1, 2, \cdots, m - 1 $，投 $ n $ 次，求投出来的数之和在区间 $ [A, B] $ 的概率。

### Solution

首先介绍一点前置知识：

**正态分布**：图形不再赘述，唯一需要注意的就是随机变量 $ X $ 的正态分布只需要它的期望 $ \mu $ 和方差 $ \sigma^2 $ 即可描述，记作 $ N(\mu, \sigma^2) $，不难发现这恰好对应着题干。

**概率密度函数**：依然考虑一个随机变量 $ X $，若其为离散的那么显然可以简单的求出任意点的概率。但若其为连续型的，那么一个点的概率在极限意义下为 $ 0 $，然然而查询一段区间的时候显然不为 $ 0 $，所以我们便引入了概率密度函数来描述这个概率，对于随机变量 $ X $ 的概率密度函数 $ f(x) $，需要满足 $ f(x) $ 在区间内的积分等于 $ X $ 落在该区间的概率。

然后有个结论：正态分布的概率密度函数为：
$$
f(x) = \dfrac{1}{\sqrt{2 \pi \sigma^2}}e^{-\tfrac{(x - \mu)^2}{2\sigma^2}}
$$
关于这个东西的证明。。。完全不是人看的，似乎只能强行记下来这个公式。。。如果你一定要看一下证明，网上倒是也有一个 [正态分布推导过程](https://zhuanlan.zhihu.com/p/52808762)。

然后还有就是 C++ 库里自带了个 `erf` 和 `erfc`，大概求的是误差函数的积分和互补误差函数之类的，（~~我不会~~），有兴趣可以看看。

然后所以如果我们能够证明本题这玩意是正态分布的，那么就直接对这个 $ f(x) $ 做自适应辛普森，求一下积分就行了。

**独立同分布**：首先独立比较好理解，就是两个随机变量之间无影响，和高中数学里面的独立事件差不多。然后同分布就是指一些随机变量服从相同的分布。

Tips：概率论中 $ E(X) $ 表示期望，$ D(X) $ 表示方差。

**中心极限定理**：对于 $ n $ 个独立同分布（如本题中的相同骰子）的随机变量 $ X_1, X_2, \cdots, X_n $，若 $ E(X_i) = \mu, D(X_i) = \sigma^2 $，令：
$$
Y_n = \dfrac{\sum_{i = 1}^n X_i - n\mu}{\sqrt{n\sigma^2}}
$$
若 $ n $ 足够大，则我们认为 $ Y_n \sim N(0, 1) $。

然后还有一个常用推论，当然首先我们需要知道正态分布的一点运算规则，即：

若 $ X \sim N(a, b) $ 则 $ cX \sim N(ca, c^2b) $，从期望和方差的意义不难理解。

若 $ X \sim N(a, b) $ 则 $ X + c \sim N(a + c, b) $，同理不难得出。

所以我们可以将刚才的中心极限定理式子转化为：
$$
\sum_{i = 1}^nX_i \sim N(n\mu, n\sigma^2)
$$
也就是说，**本题里求的这些骰子的点数和，实际上就是 $ n $ 个独立同分布的和**，所以一定服从 $ N(n\mu, n\sigma^2) $，用我们刚才写的正态分布概率密度函数带进去这个期望和方差然后求个积分即可。

然后发现这东西套个自适应辛普森就可以在 $ O(\texttt{玄学}) $ 的复杂度完成。

但是我们不难发现这个东西还有点问题，就是中心极限定理需要一个前提，$ n $ 足够大，对于一些 $ n = 1 $ 之类的数据点用这个就显然寄了，所以我们要考虑一些数据点分治的做法。

显然对于 $ n $ 较小的数据，我们可以考虑多项式，多项式 $ i $ 次方项的系数为骰子值为 $ i $ 的概率，显然当 $ n = 1 $ 时，假设骰子面数为 $ m $，不难想到多项式为 $ \dfrac{1}{m}x^{m - 1} + \dfrac{1}{m}x^{m - 2} + \cdots + \dfrac{1}{m}x^1 + \dfrac{1}{m}x^0 $。然后很容易想到对于其它的 $ n $ 结果就是这个多项式的 $ n $ 次方，我们只需要用 FFT 优化一下然后在结果里求出指数在 $ [A, B] $ 之间的系数和即可，这东西可以用多项式快速幂优化（这个实际上不算是多项式快速幂，因为最终多项式总长度较小，所以在正常 FFT 时写个复数的快速幂就行），我们可以分析一下，显然多项式初始项数最多为 $ m $，所以时间复杂度大概是 $ O(nm \log nm) $，常数不小，然后 $ nm $ 是 $ 4e6 $ 级别的，总之 $ nm \le 1e5 $ 应该不成问题，而且因为我们的中心极限定理一般要求 $ n \ge 30 $ 就可以了，所以这个理论上就可以过了。

Tips：仅用多项式快速幂期望得分 60~70。

upd：上述过程就可以通过本题了，需要注意的一个问题是不要忘记**在自适应辛普森的过程中限制层数**，后文是我最开始写这道题时的因为没有限制层数的一些误区与另一种类似的方法，仅供参考。

---

如果不在自适应辛普森中限制层数，那么会有精度问题，原因除此之外还可能因拟合 $ N(0, 1) $ 的概率密度函数会比拟合 $ N(n\mu, n\sigma^2) $ 精度更高一点，可能因为 $ n\mu $ 和 $ n\sigma^2 $ 的值域范围太大了，再加上自适应辛普森本来精度就很玄学，所以会导致最终答案精度爆炸。

总之还可以考虑另一个方法，即中心极限定理的初始式子：
$$
Y_n = \dfrac{\sum_{i = 1}^n X_i - n\mu}{\sqrt{n\sigma^2}}
$$
不难发现我们知道了限定的 $ \sum_{i = 1}^n X_i $ 的范围，也就可以带进式子里直接推出 $ Y_n $ 的范围，然后用自适应辛普森跑一下 $ N(0, 1) $ 的概率密度函数，因为 $ Y_n \sim N(0, 1) $，所以求出对应范围之后直接求 $ N(0, 1) $ 的概率密度函数在新范围里的积分即为答案。~~不过这样会发现依然是错误的~~如果在自适应辛普森中限制层数那么就没有问题了。

检查发现，对于正态分布中，在角落可能很小，从而导致 $ [l, mid], [mid, r], [l, r] $ 都很小，从而直接返回 $ 0 $，可以感性理解一下，所以可能会导致拟合的误差过大，于是考虑每次求范围 $ [A, B] $ 的时候分别拟合 $ [0, A] $ 和 $ [0, B] $，然后用 $ [0, B] $ 的值减去 $ [0, A] $ 的，这样是等效的，且会更多的引入较大的值使得精度更高，改成此方法后即使不限制层数也可以通过本题。

Tips：代码中注释部分即为后半部分的实现方式。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW(arr) void* Edge::operator new(size_t){static Edge* P = arr; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

#define comp complex < ld >
#define DFT (true)
#define IDFT (false)
#define EPS (ld)(1e-10)

template < typename T = int >
inline T read(void);

int N, M;

comp comp_qpow(comp a, ll b){
    comp ret(1.0, 0.0), mul(a);
    while(b){
        if(b & 1)ret = ret * mul;
        b >>= 1;
        mul = mul * mul;
    }return ret;
}

class Polynomial{
private:
public:
    int len;
    comp A[2100000];
    comp Omega(int n, int k, bool pat){
        if(pat == DFT)return comp(cos(2 * PI * k / n), sin(2 * PI * k / n));
        return conj(comp(cos(2 * PI * k / n), sin(2 * PI * k / n)));
    }
    void Reverse(comp* pol){
        int pos[len + 10];
        memset(pos, 0, sizeof pos);
        for(int i = 0; i < len; ++i){
            pos[i] = pos[i >> 1] >> 1;
            if(i & 1)pos[i] |= len >> 1;
        }
        for(int i = 0; i < len; ++i)if(i < pos[i])swap(pol[i], pol[pos[i]]);
    }
    void FFT(comp* pol, int len, bool pat){
        Reverse(pol);
        for(int siz = 2; siz <= len; siz <<= 1)
            for(comp* p = pol; p != pol + len; p += siz){
                int mid = siz >> 1;
                for(int i = 0; i < mid; ++i){
                    auto tmp = Omega(siz, i, pat) * p[i + mid];
                    p[i + mid] = p[i] - tmp, p[i] = p[i] + tmp;
                }
            }
        if(pat == IDFT)
            for(int i = 0; i <= len; ++i)
            A[i].real(A[i].real() / (ld)len), A[i].imag(A[i].imag() / (ld)len);
    }
    void MakeFFT(void){
        FFT(A, len, DFT);
        for(int i = 0; i < len; ++i)A[i] = comp_qpow(A[i], N);
        FFT(A, len, IDFT);
    }
}poly;

ld mu, sigma2;

ld f(ld x){
    return exp(-(x - mu) * (x - mu) / 2.0 / sigma2) / sqrt(2.0 * PI * sigma2);
}
ld Simpson(ld a, ld b){
    return (b - a) * (f(a) + f(b) + 4 * f((a + b) / 2.0)) / 6.0;
}
ld Adaptive(ld l, ld r, ld cur, ld eps = 1e-6, ll dep = 1){
    ld mid = (l + r) / 2.0;
    ld lval = Simpson(l, mid), rval = Simpson(mid, r);
    if(dep >= 10 && fabs(lval + rval - cur) <= eps * 15.0)return lval + rval + (lval + rval - cur) / 15.0;
    return Adaptive(l, mid, lval, eps / 2.0, dep + 1) + Adaptive(mid, r, rval, eps / 2.0, dep + 1);
}

int main(){
    int T = read();
    while(T--){
        M = read(), N = read();
        if(N * M <= (int)1e5){
            memset(poly.A, 0, sizeof poly.A);
            for(int i = 0; i <= M - 1; ++i)
                poly.A[i].real((ld)1.0 / (ld)M), poly.A[i].imag(0.0);
            poly.len = 1;
            while(poly.len <= N * M)poly.len <<= 1;
            poly.MakeFFT();
            for(int i = 1; i <= 10; ++i){
                int A = read(), B = read();
                ld ans(0.0);
                for(int j = A; j <= B; ++j)ans += poly.A[j].real();
                printf("%.10Lf\n", ans);
            }
        }else{
            // mu = 0.0, sigma2 = 1.0;
            // ld real_mu = (ld)(M - 1) / 2.0;
			// ld real_sig = ((ld)M * M - 1.0) / 12.0;
            // for(int i = 1; i <= 10; ++i){
            //     int A = read(), B = read();
            //     ld L = (ld)((ld)A - N * real_mu) / sqrt(N * real_sig);
            //     ld R = (ld)((ld)B - N * real_mu) / sqrt(N * real_sig);
            //     printf("%.8Lf\n", Adaptive((ld)L, (ld)R, Simpson(L, R)));
            //     // printf("%.8Lf\n", Adaptive((ld)0, (ld)R, Simpson(0, R)) - Adaptive((ld)0, (ld)L, Simpson(0, L)));
            // }

            mu = (ld)N * (ld)(M - 1) / 2.0;
            sigma2 = (ld)N * (ld)((ll)M * M - 1) / 12.0;
            for(int i = 1; i <= 10; ++i){
                int A = read(), B = read();
                printf("%.8Lf\n", Adaptive((ld)A, (ld)B, Simpson(A, B)));
            }
        }
    }
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2022_12_10 初稿

update-2023_02_01 fix 初稿中的一些错误与不严谨的表述

---

## 作者：Ameyax (赞：1)


$dp$方程很简单，设$f[i][j]$为到第$i$的骰子，一共有$j$点数的概率  
转移  
$$f[i][j] = \sum\limits_{k=0}^{\min(j,x-1)}f[i-1][j-k]\times \frac{1}{n}$$
$fft$卷积+快速幂之后据说是$70$的分，然后我的辣鸡$fft$就拿了$60$  

然后发现没用到题目中给出的期望$\mu$和方差$\sigma$。  
知乎上说出题人以**中心极限定理**作为理论分析的基础出了这么一道题  
学习一下正态分布的概率密度函数
$$f(x)=\frac{1}{\sqrt{2\pi}\sigma}\times \exp(-\frac{(x-\mu)^2}{2\sigma^2})$$  
用$simpson$积分强行积起来。  
但是这样精度还是太低，把正态分布转换成标准正态分布。怎么搞可以点[这个](https://www.baidu.com/)。  
标准正态分布下$\mu=0$，$\sigma=1$。
$$f(x)=\frac{1}{\sqrt{2\pi}}\times \exp(-\frac{x^2}{2})$$  
再去积分，这里直接交积分的代码我是$5$分，因为精度太低。。。  
于是小数据强行$fft$优化$dp$，大数据强行$simpson$对概率密度函数积分。  
就A了  
我认为是我的代码太烂，因为知乎上还说验题人$10$行代码AC。。
```cpp
#include <bits/stdc++.h>
using namespace std;
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
#define db double
const db pi2 = sqrt(2.0 * acos(-1));
const db eps = 1e-13;
db sigma, mu;
db x, y;
db f(db x) { return exp(-x * x / 2) / pi2; }
db simpson(db l, db k, db r)
{
    db lk = (l + k) / 2;
    db kr = (k + r) / 2;
    db fl = f(l);
    db fr = f(r);
    db fk = f(k);
    db flk = f(lk);
    db fkr = f(kr);
    db ansl = (k - l) * (fl + fk + 4 * flk) / 6;
    db ansr = (r - k) * (fk + fr + 4 * fkr) / 6;
    db anslr = (r - l) * (fl + fr + 4 * fk) / 6;
    if (fabs(ansl + ansr - anslr) < 15 * eps)
        return ansl + ansr + (ansl + ansr - anslr) / 15;
    else
        return simpson(l, lk, k) + simpson(k, kr, r);
}
void solve_simpson()
{
    mu = (x - 1) / 2;
    sigma = sqrt((x * x - 1) / 12);
    for (int i = 1; i <= 10; i++)
    {
        db a, b;
        scanf("%lf%lf", &a, &b);
        a = ((a - 0.5) / y - mu) * sqrt(y) / sigma;
        b = ((b + 0.5) / y - mu) * sqrt(y) / sigma;
        printf("%.8lf\n", simpson(0, b / 2, b) - simpson(0, a / 2, a));
    }
}
#define cpx complex<double>
const db pi = acos(-1);
const int MAX = 810000;
cpx a[MAX], b[MAX];
int rev[MAX];
db ans[MAX];
void fft(cpx *a, int N, int f)
{
    for (int i = 0; i < N; i++)
        if (i < rev[i])
            swap(a[i], a[rev[i]]);
    for (int i = 1; i < N; i <<= 1)
    {
        cpx wn(cos(pi / i), f * sin(pi / i));
        for (int j = 0; j < N; j += (i << 1))
        {
            cpx w(1, 0);
            for (int k = 0; k < i; k++)
            {
                cpx x = a[j + k], y = w * a[j + k + i];
                a[j + k] = x + y;
                a[j + k + i] = x - y;
                w = w * wn;
            }
        }
    }
    if (f == -1)
        for (int i = 0; i < N; i++)
            a[i] = a[i] / (db)N;
}
void solve_fft()
{
    db p = 1.0 / (db)x;
    int N = 0, l = 0;
    for (N = 1, l = 0; N < (x * y); N <<= 1)
        l++;
    for (int i = 0; i < N; i++)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
    for (int i = 0; i < N; i++)
        a[i] = b[i] = 0.0;
    a[0] = 1.0;
    for (int i = 0; i < x; i++)
        b[i] = p;
    fft(a, N, 1); fft(b, N, 1);
    for (int i = 0; i < N; i++)
    {
        for (int kk = y; kk; b[i] = b[i] * b[i], kk >>= 1)
            if (kk & 1)
                a[i] = a[i] * b[i];
    }
    fft(a, N, -1);
    ans[0] = a[0].real();
    for (int i = 1; i < N; i++)
        ans[i] = ans[i - 1] + a[i].real();
    for (int i = 1; i <= 10; i++)
    {
        int A = read(), B = read();
        printf("%.8lf\n", A == 0 ? ans[B] : ans[B] - ans[A - 1]);
    }
}
int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%lf%lf", &x, &y);
        if (x * y <= 400000)
            solve_fft();
        else
            solve_simpson();
    }
    return 0;
}
```

```
补充。。  
fft后求前缀和，直接用std::complex<double>求前缀和精度爆炸只有5分
赋值到double[]里面就好了。
都是double，我也不知道为什么。。
simpson积分直接积(a, b) 80分
写成(0, b) - (0, a) AC
我还是不知道为什么。。
```

---


# [SDOI2017] 文本校正

## 题目描述

小Q在研发一种数据混淆的算法时不慎将重要的文档都给混淆了。幸运的是，将这些文档校正对于他来说并不是难事。他凭借着敏锐的观察力成功地用肉眼完成了校正。

为了防止这种情况再次发生，小Q希望开发一种文本校正工具，他的目标是将一个文本串$T$分成连续的$3$段，要求每段都不能为空，然后按一定顺序将这$3$段从左往右拼接起来，将其还原为初始文本串$S$。

在进行了大量肉眼校正工作之后，小Q需要休息一下，因此他把这个任务交给了你。请写一个程序，判断是否可以还原，并给出一个合法的还原方案。


## 说明/提示

对于$100\%$的数据，$3 \leq n \leq 1000000$，$1 \leq Si,Ti \leq m \leq 1000000$。

![](https://cdn.luogu.com.cn/upload/pic/5550.png)

spj by @Wen_kr 


## 样例 #1

### 输入

```
3
5 3
2 1 1 1 1
1 1 1 1 2
5 5
5 2 3 3 4
2 5 3 4 3
5 5
4 5 2 1 4
5 4 2 1 4```

### 输出

```
YES
5 5
1 3
4 4
NO
YES
2 2
1 1
3 5```

# 题解

## 作者：henryhu2006 (赞：5)

本文的所有情况的时间复杂度均为 $\mathcal O(n)$，不需要后缀数据结构。

## 题意
多测，每次给定两个（正整数）串 $s$ 和 $t$，判断是否可以将 $t$ 划分成三个非空段，任意排列后拼接在一起，得到串 $s$，并构造方案。

$\sum |s|,\sum |t|\le 10^6$。

## 分析

显然需要对拼接顺序分类讨论，将 $t$ 的三个划分段标记为 $1,2,3$，用一个排列来描述如何拼接出 $s$。一共有 $123,132,213,231,312,321$ 六种情况，但是可以发现，有些排列是本质相同的，一共有四种情况：

- $123$ 显然直接判断 $s=t$ 即可。

- $231,312$ 本质相同，相当于判断 $s,t$ 是否循环同构。

- $132,213$ 本质相同，相当于保留一个公共前缀或者后缀，要求剩下的前缀或后缀循环同构。

- $321$ 可以考虑将其反转和原串对齐。

## $231,312$
这一部分较为容易，可以将 $t$ 倍长后用哈希或者 KMP 判断 $s$ 是否在其中出现即可。需要注意三段都非空。

```cpp
const ull B=1e8+7; ull h[N*2];
bool solve2(){
	ull H=0,P=1;
	for(int i=1;i<=n;++i)
		t[n+i]=t[i],H=B*H+s[i],P*=B;
	for(int i=1;i<=2*n;++i) h[i]=B*h[i-1]+t[i];
	for(int l=2;l<=n;++l)
		if(H==h[l+n-1]-h[l-1]*P){
			if(l>2) return print(l,n,1,1,2,l-1);
			else return print(l,n-1,n,n,1,l-1);
		}
	return 0;
}
```

## $132,213$
我们考虑 $213$，对于 $132$，是完全对称的。

首先可以求出 $s,t$ 之间的 Z 函数，设 $s$ 的后缀和 $t$ 的 LCP 为 $zs$，$t$ 的后缀和 $s$ 的 LCP 为 $zt$。

设 $1$ 的长度为 $i$，$2$ 的长度为 $j$，$s,t$ 的最长公共后缀长度为 $p$，那么有解等价于：

- $zs_{j+1}\ge i$
- $zt_{i+1}\ge j$
- $i+j\ge n-p$

如果打算 $\mathcal O(n\log n)$ 做，用树状数组扫一遍即可。

枚举 $i+j$，那么 $1$ 是 $s[1,i+j]$ 的后缀，是 $t$ 的前缀。因此使用 KMP，用 $t$ 来匹配 $s$，那么所有可能的 $1$ 串在 Fail 树的根链上。

因此为了第三个条件尽可能满足，我们可以在对 $t$ 串预处理 KMP 的时候算出 Fail 树根链上 $i+zt_{i+1}$ 的最大值。在用 $t$ 匹配 $s$ 时，KMP 算到的失配指针 $j$ 就是根链的底部。

于是时间复杂度是 $\mathcal O(n)$ 的。

```cpp
int z1[N],z[N],nxt[N],mx[N];
void exkmp(int *z,int *Z,int *t,int *s){
	memset(z+1,0,4*n);
	for(int i=1+(z==Z),l=0,r=0;i<=n;++i){
		if(r>=i) z[i]=min(r-i+1,Z[i-l+1]);
		while(i+z[i]<=n&&t[z[i]+1]==s[i+z[i]]) ++z[i];
		if(i+z[i]-1>r) l=i,r=i+z[i]-1;
	}
} 
bool solve3(bool rev){
	memset(nxt+1,0,4*n);
	exkmp(z1,z1,s,s),exkmp(z,z1,s,t);
	
	int p=0; while(s[n-p]==t[n-p]) ++p;
	if(!p) return 0;
	iota(mx+1,mx+n,1);
	for(int i=2,j=0;i<=n;++i){
		while(j&&t[i]!=t[j+1]) j=nxt[j];
		if(t[i]==t[j+1]) ++j; nxt[i]=j;
		if(j) mx[i]=(mx[j]+z[mx[j]+1]>i+z[i+1]?mx[j]:i);
	}
	
	for(int i=1,j=0;i<n;++i){
		while(j&&s[i]!=t[j+1]) j=nxt[j];
		if(t[j+1]==s[i]) ++j;
		if(mx[j]+z[mx[j]+1]>=i&&i>=n-p){
			int r=mx[j];
			if(!rev) return print(r+1,i,1,r,i+1,n);
			else return print(1,n-i,n-r+1,n,n-i+1,n-r);
		}
	}
	return 0;
}
```

## $321$
将 $s$ 反转，问题变为是否可以将 $t$ 划分成三段使得将每段反转后和 $s$ 一样。

然后就是各种各样的巨型后缀数据结构，但有一个非常 Ad-Hoc 的构造：将 $s,t$ 的字符相隔排列：$t_1s_1t_2s_2\cdots t_ns_n$，则一个区间可以作为分割段，当且仅当其在构造串中所对应的子串（显然长度为偶数）是一个**回文串**。

这个构造的充分和必要性都是容易证明的。于是问题就变成了判断一个**字符串是否能划分成三个偶回文串**。

显然需要 Manacher，但是后面的问题看似简单，但是要做到线性非常困难，保底可以用 NTT 做到 $\mathcal O(n\log n)$。

枚举第一个回文串，则要将后缀划分成两个回文串。此时有一个非常难发现也难证明的性质。

考虑一个字符串，如果有三种方案对其进行划分（不一定成立），分别为 $[1,a],[a+1,n]; [1,b],[b+1,n];[1,c],[c+1,n]$，设 $a<b<c$，若 $[1,a]$ 不是回文串，$[a+1,n]$ 是回文串；$[1,b]$ 和 $[b+1,n]$ 都是回文串；$[1,c]$ 是回文串，$[c+1,n]$ 不是回文串。

如果 $b\le 0.5n$，则右边的区间长度大于 $0.5n$，而 $a<b$，所以 $[a+1,n]$ 的区间长度大于 $[b+1,n]$，必然长度小于 $[b+1,n]$ 的两倍。对于 $b\ge 0.5n$，是对称的，可以得到另外一边的回文串小于左侧的两倍。有众所周知的回文串性质：**一个回文串长度大于一半的回文前后缀，此回文串存在 Period**。

不妨考虑 $b\le 0.5n$，那么 $[0,c]$ 都被划分成若干个 Period（我们考虑最小的 Period），且 Period 长度为 $\gcd(b,c)$ 的约数。如果 $a$ 不是 Period 的倍数，则 $[a+1,n]$ 有残缺不全的 Period 前后缀，从 $a+1$ 到 $c$。则 $n$ 左侧长度为 $c-a$ 的段也是可知且残缺的。在 $[b+1,n]$ 中也进行对称，则 $b+1$ 后面一小段也是残缺的。

以此类推，辗转相除，到 $n$ 距离为 $\gcd(n-a,n-b)$ 倍数的地方都有残缺的 Period。或者说有一个大小为 $\gcd(n-a,n-b)$ 的 Period。两者有公共区域，所以必然要求 $\gcd(n-a,n-b)$ 是 $\gcd(b,c)$ 的倍数。可以得出，$n$ 是 $\gcd(b,c)$ 的倍数。

可以得出 $n-a,a$ 也是 $\gcd(b,c)$ 的倍数，和 $a$ 不是 Period 的倍数矛盾。

于是可以得到 $\gcd (b,c)$ 是整个串的 Period。

回到原问题，**我们只需要考虑 $i$ 之后最小的 $j$ 使得 $[j,n]$ 为回文串，以及最大的 $k$，使得 $[i+1,k]$ 为回文串**，试图将其更新答案，显然一个必要条件是 $j<k$（对应上文 $a<c$）。如果更新成功，那么就不管了；如果更新失败，那么就会出现和上面结论描述一样的情况，得出 $\gcd(b,c)$ 是整个后缀的 Period，显然这种情况可以被上述的方法判掉，和假设矛盾。

所以只需要考虑这两种情况，算出所有回文后缀，直接用指针扫，可以解决 $j$。对于 $k$ 最大，等价于回文中心的位置最大，这是 Manacher 好处理的，具体实现见代码。

时间复杂度 $\mathcal O(n)$。

代码中，$s$ 已经完成反转。

```cpp
int c[N*2],w[N*2],ra[N*2],st[N],top;
void cmax(int &x,int y){if(x<y) x=y;}
bool palin(int l,int r){return w[l+r>>1]>=(r-l+1)/2;}
bool solve4(){
	memset(ra+1,0,8*n);
	memset(w+1,0,8*n);
	for(int i=1;i<=n;++i) c[2*i-1]=t[i],c[2*i]=s[i];
	
	for(int i=1,mx=0,id;i<n*2;++i){
		if(i<mx) w[i]=min(mx-i,w[id*2-i]);
		while(i+w[i]+1<=n*2&&i-w[i]&&c[i-w[i]]==c[i+w[i]+1]) ++w[i];
		if(i+w[i]>=mx) mx=i+w[i],id=i;
		cmax(ra[i-w[i]+1+((i+w[i])&1)],i);
	}
	
	top=0;
	for(int i=1;i<=n*2;i+=2)
		if(palin(i,n*2)) st[++top]=i;
	for(int i=3;i<=n*2;++i) cmax(ra[i],ra[i-2]);
	for(int i=2,j=1;i<n*2;i+=2)
		if(palin(1,i)){
			while(j<=top&&st[j]<=i) ++j;
			if(j<=top){
				if(palin(i+1,st[j]-1))
					return print((st[j]+1)/2,n,(i+2)/2,st[j]/2,1,i/2);
				if(ra[i+1]>=i+1&&palin(ra[i+1]*2-i+1,n*2))
					return print(((ra[i+1]*2-i+1)+1)/2,n,(i+2)/2,(ra[i+1]*2-i+1)/2,1,i/2);
			}
		}
	return 0;
}
```

完整代码见 [提交记录 #1931412](https://loj.ac/s/1931412)。

$321$ 的第二个结论受 [提交记录 #799188](https://loj.ac/s/799188) 启发。

---

## 作者：FunnyCreatress (赞：2)

显然需要讨论六种情况，设 $T=T_1T_2T_3$：

## $S=T_1T_2T_3$
显然只要 $S=T$，因为保证了 $n\ge 3$。

## $S=T_2T_3T_1/S=T_3T_1T_2$
只要找到一个分界点 $i$ 满足 $S[:i]=T[n-i+1:],S[i+1:]=T[:n-i]$，随便怎么做都行，我用了 exkmp。

## $S=T_1T_3T_2/S=T_2T_1T_3$
此处以 $S=T_2T_1T_3$ 为例，$S=T_1T_3T_2$ 同理。

求出 $S$ 和 $T$ 的 $lcs$，那么问题转化为需要找到一组 $(i,j)$ 满足 
$$lcp(S,T[j+1:])\ge i,lcp(T,S[i+1:\ge j]),i+j\ge n-lcs$$

考虑从大到小枚举 $i$，每次加入 $lcp(S,T[j+1:])=i$ 的 $j$，那么满足条件的 $j$ 在区间 $[n-lcs-i,lcp(T,S[i+1:])]$ 内，exkmp 后使用树状数组直接维护或倒序后用并查集做。

## $S=T_3T_2T_1$
即找到一组 $(i,j)$ 使得 
$$S[:i]=T[n-i+1:],T[:j]=S[n-j+1:],n-lcp(S[i+1:],T[j+1:])\le i+j<n$$

这次 exkmp 不好用了，我们把 $S$ 和 $T$ 用特殊字符连接，并建出后缀树~~并很快想出了一堆 2log 做法~~。

由于有 $i+j<n$ 这个讨厌的条件，所以我们倒序遍历可行的 $i$，逐个加入可行的 $j$，转化为在线问题。

我们在后缀树树的每个节点上记录一个标记。这样我们的操作就变为了推平点到根路径上的标记，查询点到根路径上标记+深度的最大值。

转化到这一步就非常舒服了，可以轻松使用 LCT 或全局平衡二叉树进行维护，复杂度 $O(n\log n)$。如果使用 LCT 可能需要卡常数。

放上不保证任何时间能过的代码：
```cpp
#include<bits/stdc++.h>
#define reg register
#define il inline
using namespace std;
const int N=1e6+5;
int T,n,m,s[N],t[N],ls[N],lt[N],zs[N],zt[N],lcs,bit[N],cs[N],ct[N];vector<int> v[N];bool vst[N],tag[N<<2];
int fa[N<<2],len[N<<2],lst,cnt,pos[N<<1],mxl[N<<2],mx[N<<2],tg[N<<2],sn[N<<2][2];map<int,int> ch[N<<2];
il bool check(){for(reg int i=1;i<=n;i++)if(s[i]!=t[i])return 0;return 1;}
il int read(){
	reg int res=0;reg char c=getchar();
	while(c<48)c=getchar();
	while(c>=48)res=res*10+c-48,c=getchar();
	return res;
}
il void exkmp(int *a,int *b,int *z,int *ext){
	z[1]=n;
	for(reg int i=2,l=1,r=1;i<=n;i++){
		if(i<r)z[i]=min(z[i-l+1],r-i+1);else z[i]=0;
		while(i+z[i]<=n&&a[z[i]+1]==a[i+z[i]])z[i]++;
		if(i+z[i]-1>r)l=i,r=i+z[i]-1;
	}
	for(reg int i=1,l=0,r=0;i<=n;i++){
		if(i<r)ext[i]=min(z[i-l+1],r-i+1);else ext[i]=0;
		while(i+ext[i]<=n&&a[ext[i]+1]==b[i+ext[i]])ext[i]++;
		if(i+ext[i]-1>r)l=i,r=i+ext[i]-1;
	}
}
il void add(reg int x){for(;x<=n;x+=x&-x)bit[x]++;}
il int query(reg int x){reg int res=0;for(;x;x-=x&-x)res+=bit[x];return res;}
il bool solve(reg bool typ){
	if(typ)exkmp(s,t,zs,ls),exkmp(t,s,zt,lt);
	for(lcs=0;lcs<n&&s[n-lcs]==t[n-lcs];lcs++);
	for(reg int i=0;i<=n;i++)v[i].clear(),bit[i]=vst[i]=0;
	for(reg int i=2;i<=n;i++)v[ls[i]].push_back(i-1);
	for(reg int i=n;i;i--){
		for(reg int j=0;j<v[i].size();j++)add(v[i][j]),vst[v[i][j]]=1;
		if(query(lt[i+1])>query(max(n-lcs-i-1,0)))
			for(reg int j=max(n-lcs-i,1);j<=lt[i+1];j++)if(vst[j])
				if(!typ){cout<<"YES\n"<<j+1<<" "<<i+j<<"\n1 "<<j<<"\n"<<i+j+1<<" "<<n<<"\n";return 1;}
				else{cout<<"YES\n1 "<<n-i-j<<"\n"<<n-j+1<<" "<<n<<"\n"<<n-i-j+1<<" "<<n-j<<"\n";return 1;}
	}
	for(int i=1;i<=(n>>1);i++)swap(s[i],s[n-i+1]),swap(t[i],t[n-i+1]);
	return 0;
}
il void extend(reg int c){
	reg int p=lst,cur=lst=++cnt;len[cur]=len[p]+1;
	for(;p&&!ch[p][c];p=fa[p])ch[p][c]=cur;
	if(!p){fa[cur]=1;return;}
	reg int q=ch[p][c],nq;
	if(len[q]==len[p]+1){fa[cur]=q;return;}
	len[nq=++cnt]=len[p]+1,fa[nq]=fa[q],fa[cur]=fa[q]=nq,ch[nq]=ch[q];
	for(;p&&ch[p][c]==q;p=fa[p])ch[p][c]=nq;	
}
#define ls sn[x][0]
#define rs sn[x][1]
const int INF=2e9;
il void pushup(reg int x){mx[x]=max(len[x]+tg[x],max(ls?mx[ls]:-INF,rs?mx[rs]:-INF)),mxl[x]=(rs?mxl[rs]:len[x]);}
il void pushdown(reg int x){
	if(!tag[x])return;
	tg[ls]=tg[rs]=tg[x],mx[ls]=tg[x]+mxl[ls],mx[rs]=tg[x]+mxl[rs],tag[ls]=tag[rs]=1,tag[x]=0;
}
il bool whc(reg int x){return sn[fa[x]][1]==x;}
il bool isroot(reg int x){return !fa[x]||sn[fa[x]][0]!=x&&sn[fa[x]][1]!=x;}
il void rotate(reg int x){
	bool d=whc(x);reg int y=fa[x],z=sn[x][d^1];
	if(!isroot(y))sn[fa[y]][whc(y)]=x;
	fa[x]=fa[y],fa[y]=x,fa[z]=y,sn[y][d]=z,sn[x][d^1]=y;
	pushup(y),pushup(x);
}
void pushall(reg int x){if(!isroot(x))pushall(fa[x]);pushdown(x);}
il void splay(reg int x){
	pushall(x);
	while(!isroot(x)){
		if(isroot(fa[x]))rotate(x);
		else if(whc(x)==whc(fa[x]))rotate(fa[x]),rotate(x);
		else rotate(x),rotate(x);
	}
}
il int access(reg int x){reg int y=0;for(;x;y=x,x=fa[x])splay(x),rs=y,pushup(x);return y;}
#undef ls
#undef rs
int main(){
	T=read();
	while(T--){
		n=read(),m=read();
		for(reg int i=1;i<=m;i++)cs[i]=ct[i]=0;
		for(reg int i=1;i<=n;i++)s[i]=read(),cs[s[i]]++;
		for(reg int i=1;i<=n;i++)t[i]=read(),ct[t[i]]++;
		int nn=(n<<1|1);bool flag=0;
		for(reg int i=1;i<=m;i++)if(cs[i]!=ct[i]){cout<<"NO\n",flag=1;break;}
		if(flag)continue;
		if(check()){cout<<"YES\n1 1\n2 2\n3 "<<n<<"\n";continue;}
		exkmp(s,t,zs,ls),exkmp(t,s,zt,lt);
		for(reg int i=1;i<n;i++)if(ls[i+1]==n-i&&lt[n-i+1]==i){
			if(i==1)cout<<"YES\n2 2\n3 "<<n<<"\n1 1\n";
			else cout<<"YES\n"<<i+1<<" "<<n<<"\n1 1\n2 "<<i<<"\n";
			flag=1;break;
		}
		if(flag)continue;
		if(solve(0))continue;if(solve(1))continue;
		exkmp(s,t,zs,ls),exkmp(t,s,zt,lt);
		for(reg int i=1;i<(nn<<1);i++)ch[i].clear();
		len[lst=cnt=1]=fa[1]=0;
		for(reg int i=n;i;i--)extend(t[i]),pos[i+n+1]=lst;extend(0);
		for(reg int i=n;i;i--)extend(s[i]),pos[i]=lst;
		for(reg int i=1;i<=cnt;i++)tag[i]=0,tg[i]=-2e9,sn[i][0]=sn[i][1]=0;
		for(reg int i=n-2,j=1,x;i;i--,j++){
			if(lt[n-j+1]==j)x=access(pos[j+n+2]),tag[x]=1,tg[x]=j,mx[x]=mxl[x]+j;
			if(ls[n-i+1]==i){
				x=access(pos[i+1]);
				if(i+mx[x]>=n){
					exkmp(s+i,t,zs,ls);
					for(j=1;j<n-i;j++)if(lt[n-j+1]==j&&i+j+ls[j+1]>=n)
						{cout<<"YES\n"<<n-i+1<<" "<<n<<"\n"<<j+1<<" "<<n-i<<"\n1 "<<j<<"\n";flag=1;break;}
					break;
				}
			}
		}
		if(!flag)cout<<"NO\n";
	}
	return 0;
}
```

---


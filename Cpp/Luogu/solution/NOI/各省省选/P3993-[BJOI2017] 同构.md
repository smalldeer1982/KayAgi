# [BJOI2017] 同构

## 题目描述

你有 $n$ 个点，你可以在这 $n$ 个点之间连无向边，两个点之间至多只能连一条边，也不允许连自环，问至多能连多少条边。

但这个问题的答案显然是 $\dfrac{n(n-1)}{2}$ 条。所以有一个额外的限制，要求这个图不存在非平凡的自同构。

一个图 $G$ 有非平凡的自同构定义为存在一个 $1$ 到 $n$ 的置换 $p(1)$ 到 $p(n)$ 满足对于所有点 $u,v$，$(u, v)$ 之间有边当且仅当 $(p(u), p(v))$ 之间有边，并且这个置换非平凡也就是存在一个点 $u$ 使得 $p(u) \ne u$。

比如对于一个 $5$ 个点的图 $(1,2),(2,3),(3,4),(4,5),(5,1),(1,3)$，那么 $p(1)=3$，$p(2)=2$，$p(3)=1$，$p(4)=5$，$p(5)=4$ 为这个图的一个非平凡的自同构。

你要回答一个 $n$ 个点的无向简单的不存在非平凡自同构的图最多有多少条边，如果答案不存在，即不存在 $n$ 个点满足条件的图，请输出 `-1`，否则输出答案对 $10^9+7$ 取模的结果。

## 说明/提示

|测试点|数据范围|
|:-:|:-:|
|$1$|$n ,T \le 6$|
|$2$|$n,T \le 10$|
|$3,4$|$n,T \le 100$|
|$5,6$|$n \le 10^5$|
|$7,8$|$n \le 10^9$|
|$9$|$n \le 10^{18}$|
|$10$|$n=10^{100}$|

对于 $100\%$ 的数据，$1 \le n \le 10^{100}$，$1 \le T \le 10^4$。

## 样例 #1

### 输入

```
6
1
2
3
4
5
6
```

### 输出

```
0
-1
-1
-1
-1
9
```

# 题解

## 作者：A_zjzj (赞：12)

[题面](https://www.luogu.com.cn/problem/P3993)

提供一种不需要多项式/生成函数的做法。

方便起见，记 $P(G)=0/1$ 表示 $G$ 是否不存在非平凡自同构。

首先发现对于图 $G$ 的补图 $G'$，显然 $P(G)=P(G')$。

那么边数的最大值 $=\frac{n(n-1)}{2}-$ 边数的最小值。

显然，边数最小的时候 $G'$ 是一个森林（要求每棵树 $T$ 都不同构且 $P(T)=1$）。

在此基础之上，对于两棵树 $T_1,T_2(P(T_1)=P(T_2)=1)$，若 $T_1$ 的点数 $< T_2$ 的点数，那么选择 $T_1$ 一定优于选择 $T_2$。

容易发现，当且仅当 $n=2,3,4,5,6$ 的时候不存在合法的树，所以，特判 $n\le 6$，下面考虑 $n\ge 7$。

所以，我们可以从小到大枚举 $T$ 的点数 $n$，然后把剩下的点尽量用 $n$ 个点的树覆盖，直到覆盖不了为止。

但是，这样会产生一个问题，就是可能最后会剩下 $m$ 个点，那么我们只需要把这 $m$ 个点加入到最大的那棵树上就行了。

由于 $n\ge 7$，所以一定可以加上最后的几个点。

至此，仅剩下如何求出 $n$ 个点的合法树的个数 $f_n$ 的问题。

> 在判断树同构的时候，我们可以以重心为根做一遍树哈希（如果有两个就都做一遍），然后比较哈希值判断两棵树是否同构。

所以在这里，我们同样可以使用重心来避免算重。

我们用 $h_n$ 表示 $n$ 个点的有根树的本质不同的个数，$g_{n,m}$ 表示用 $m$ 个点，组成若干互不相同的大小 $\le n$ 的子树的方案数。

转移：

$$
h_{n}=g_{n-1,n-1}\\
g_{n,m}=\sum\limits_{i=0}^{\min\{h_n,\lfloor \frac{m}{n}\rfloor \}}\binom{h_n}{i}\times g_{n-1,m-n\times i} \\
f_{n}=
\left\{
	\begin{array}{cc}
		g_{\frac{n-1}{2},n-1} & 2\nmid n \\
		g_{\frac{n}{2}-1,n-1}+\binom{g_{\frac{n}{2}-1,\frac{n}{2}-1}}{2} & 2 | n \\
	\end{array}
\right.
$$

$h,g$ 的转移应该没什么问题。

$f$ 的转移，就是要考虑一下树的重心的个数，分类讨论以下即可。

然后用 python 简单跑一下，发现 $n=266$ 的时候 $\sum\limits_{i=1}^{n}f_i$ 已经超过了 $10^{100}$，足够了，python 代码：

```python
import math
mod=int(1e9+7)
n=266
def C(n,m):
	if 0>m or m>n:
		return 0
	ans=1
	for i in range(m):
		ans=ans*(n-i)//(i+1)
	return ans
f=h=[0 for i in range(0,n+1)]
g=[[0 for j in range(0,n+1)] for i in range(0,n+1)]
g[0][0]=1
for i in range(1,n+1):
	h[i]=g[i-1][i-1]
	for j in range(0,n+1):
		for k in range(j//i+1):
			g[i][j]+=C(h[i],k)*g[i-1][j-i*k]
for i in range(1,n+1):
	f[i]=g[(i-1)//2][i-1]
	if i%2==0:
		f[i]+=C(g[i//2-1][i//2-1],2)
	print(i,f[i])
T=int(input())
for t in range(T):
	m=int(input())
	if m>1 and m<6:
		print(-1)
		continue
	if m==6:
		print(9)
		continue
	ans=m*(m-1)//2-m
	res=0
	for i in range(1,n+1):
		if m<i:
			break
		cnt=min(m//i,f[i])
		res+=cnt
		m-=i*cnt
	print((ans+res)%mod)
```

然后就套个高精度模板就行了，注意要压位，不然跑不过去。

```cpp
#include<bits/stdc++.h>
using namespace std;
/*  struct bign (bigint=bigbig=__int128, block>=8) */
const int N=3e2,mod=1e9+7;
int T,n=266;
bign m,f[N],g[N][N],h[N];
bign C(bign n,int m){
	if(0>m||bign(m)>n)return bign(0);
	bign ans(1);
	for(int i=0;i<m;i++){
		ans=ans*(n-i)/(i+1);
	}
	return ans;
}
bign min(bign x,bign y){
	return x<y?x:y;
}
int main(){
	freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	g[0][0]=1;
	for(int i=1;i<=n;i++){
		h[i]=g[i-1][i-1];
		for(int j=0;j<=n;j++){
			for(int k=0;i*k<=j;k++){
				g[i][j]+=C(h[i],k)*g[i-1][j-i*k];
			}
		}
	}
	for(int i=1;i<=n;i++){
		f[i]=g[(i-1)/2][i-1];
		if(i%2==0)f[i]+=C(g[i/2-1][i/2-1],2);
		// debug(i,f[i]);
	}
	for(cin>>T;T--;){
		cin>>m;
		if(m>bign(1)&&m<bign(6)){
			puts("-1");
			continue;
		}
		if(m==bign(6)){
			puts("9");
			continue;
		}
		int ans=m%mod;
		ans=(ans*(ans-1ll)/2-ans+mod)%mod;
		for(int i=1;i<=n;i++){
			if(m<bign(i))break;
			bign cnt=min(m/i,f[i]);
			(ans+=cnt%mod)%=mod;
			m-=cnt*i;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

[我用的 bign 模板](https://www.cnblogs.com/A-zjzj/p/17191659.html)

---

## 作者：xzf_200906 (赞：3)

Upd on 2025.6.2：修正了代码中的一处错误。

声明：该做法并非本人独立提出，是参考前人的题解后自己整理的思路~~以发上来水社贡~~。

下称一张图合法当且仅当这张图不存在非平凡自同构。考虑发掘图的性质，有：
> #### Lemma 1
> 一张图合法当且仅当其所有连通块合法且互不同构。
>
> 证明：必要性显然。考虑证明充分性。假设一张图的所有连通块合法且互不同构，但这张图存在自同构 $p$，则必定存在一个 $x$ 使得 $p_x\neq x$。考虑其所在的连通块，对于其中的一条边 $(i,j)$，显然 $p_i$ 和 $p_j$ 会在同一个连通块中。故整个连通块中的 $p_i$ 都在同一个连通块中。由于 $p_x\neq x$，则这些 $p_i$ 都在另一个连通块。故存在一种对第一个连通块重标号的方案可以使其变成第二个连通块，即这两个连通块同构，与条件矛盾。故假设不成立，原命题成立。

又发现原图合法等价于其补图合法，故考虑求出边数最小的合法图。猜测求出来的必定是森林。先证明一个引理：
> #### Lemma 2
> 对于任意 $n\geq 7$，存在一棵 $n$ 个点的合法树。
>
> 证明：考虑如下构造：$1$ 号点连出 $3$ 条边，每条边连向一条链的一端，链的长度分别为 $1$，$2$ 和 $n-4$。假设其非平凡自同构为 $p$，因为点 $1$ 是唯一的三度点，故 $p_1=1$。则三条链互相独立。由于 $n\geq 7$，故三条链互不同构。类比 Lemma 1 的证明，易得对于三条链中的任意点 $i$，有 $p_i$ 同样来自于这条链。又由于 $p_1=1$，故对于所有与其相邻的点有 $p_i=i$。故可得知对于所有的 $i$ 有 $p_i=i$，与题意矛盾，故命题不成立，该构造合法。则原命题成立。

且观察样例可得对于 $2\leq n\leq 6$，不存在一棵 $n$ 个点的合法树。特殊地，$n=6$ 时存在一张合法的但不是树的图。故有：

> #### Lemma 3
> 对于 $n\geq 7$，一定存在一个 $n$ 个点的合法森林，使得不存在另一张 $n$ 个点的合法图比其边数更少。
>
> 证明：任取一张 $n$ 个点的边数最小的合法图。若其是森林则命题成立。如果其不是森林，则显然其中至多只有一个孤点，否则交换任意两个孤点的编号可以得到非平凡自同构。分以下两种情况讨论：
> + 图中不存在一个 $n\geq 7$ 的树。
>  
>   由上述观察，其它所有连通块必定不是树。则这张图的边至少有 $n-1$ 条。由于 Lemma 2，可以将其替换成一棵 $n$ 个点的合法树且不会更劣。
>+ 图中存在一个 $n\geq 7$ 的树。
>
>   取其中一个点数最大的合法树（点数必定不小于 $7$），根据 Lemma 2 将其与其它所有非树连通块组成一棵合法树。由于这张图存在非树连通块，故其大小肯定严格大于其它所有的树，且这样做不劣。
>
> 综上所述，一定可以构造出一个边数最小的合法森林，故命题得证。

特判 $n\leq 6$ 的情况，则由于 Lemma 3，且每选出一棵树总边数会减一，故要使得选出的树尽量多。则最优的方案必定是贪心从小到大选择不同的树组成连通块，如果有剩余的点，则将其塞进一棵点数最大的树中。故问题转化为求出 $f_i$ 表示有多少 $i$ 个点的合法**无根树**。由于在求树的数量这类问题中大部分问题都是无根树难于有根树，故我们希望将其转化为有根树。联想到 [AHU 算法](https://oi-wiki.org/graph/tree-ahu/)，若这棵树存在非平凡自同构，则这棵树的重心必定会映射到重心。故对重心的数量分类讨论：
### Case 1：树只有一个重心
对于这种情况，可以钦定这个重心为根，则其所有子树的大小均严格小于 $\frac{i}{2}$。考察删去重心后的树长什么样。由于重心确定，故每个子树都是一棵有根树。同样定义有根树合法当且仅当其没有非平凡自同构（注意由于树有根，设其根节点为 $r$，则要求 $p_r=r$），则有：
> #### Lemma 4
> 对于若干个**有根树**，新建一个根节点作为这些树的根节点的父亲，则得到的**有根树**合法当且仅当原来的所有有根树合法且互不同构。
>
> 证明：必要性显然。类比 Lemma 2 中对构造合法性的证明即可证明充分性。

设 $i$ 个点的合法有根树的数量为 $g_i$，从大小不大于 $i$ 的**有根树**中选出若干个互不同构的树使得点数之和恰好为 $j$ 的方案数为 $h_{i,j}$，则此处的方案数为 $h_{\lfloor\frac{i-1}{2}\rfloor,i-1}$。
### Case 2：树有两个重心
这种情况会发生当且仅当存在一条边使得其两边的子树大小相等。故要求 $i$ 为偶数。考察将这题边删去后剩下的树。有：
> #### Lemma 5
> 对于两棵**大小相等的有根树**，若将其根节点连接形成一棵**无根树**，则这棵树合法当且仅当原来的两棵树合法且不同构。
>
> 证明：必要性显然。考虑证明充分性。设两棵原树的根分别为 $x,y$，大小均为 $n$，假设新树存在非平凡自同构 $p$，按根节点被置换后的位置讨论：
> + 存在 $i\neq x,y$ 使得 $p_i=x$ 或 $p_i=y$。
>
>   对于这种情况，由于 $x,y$ 都必定存在一个子树大小为 $n$ 的儿子，而不与边 $(x,y)$ 相邻的点不可能存在这样的儿子，故该情况不可能发生。
>+ $p_x=y,p_y=x$。
>
>   对于这种情况，类比 Lemma 1 的证明方法可得知以 $x$ 为根的树中所有点 $i$ 均满足 $p_i$ 在以 $y$ 为根的树中。故存在一种对树 $x$ 重标号的方案可以使其变成树 $y$，即这两个有根树同构，与条件矛盾。故这种情况不可能发生。
>+ $p_x=x,p_y=y$。
>
>   对于这种情况，类比 Lemma 1 的证明方法可得知以 $x$ 为根的树中所有点 $i$ 均满足 $p_i$ 在以 $x$ 为根的树中。故树 $x$ 存在自同构，与条件矛盾。故这种情况不可能发生。
>
> 综上所述，假设不可能成立，故原命题成立。

故易得此处的方案数为 $\binom{g_\frac{i}{2}}{2}$，则 $f$ 的计算方法为：
$$f_i=h_{\lfloor\frac{i-1}{2}\rfloor,i-1}+[2\mid i]\binom{g_\frac{i}{2}}{2}$$
接下来考虑 $g,h$ 如何计算。由于 Lemma 4，易得：
$$g_i=h_{i-1,i-1}$$
对于 $h$，易得：
$$h_{i,j}=\sum_{ik\leq j,k\leq g_i}h_{i-1,j-ik}\times \binom{g_i}{k}$$
使用下降幂计算 $\binom{g_i}{k}$，则 $f,g,h$ 均可以计算。注意到 $f_{55}>10^{18}$，故仅需要计算出前 $54$ 项即可。参考[巨佬的解释](https://www.luogu.com.cn/article/03u370s3)，$f$ 的增长率是指数级的，故总的时间复杂度为 $\mathcal{O}(\log^3 n+T\log n)$。对于 $n=10^{100}$，~~观察其它题解~~可以得到答案为 $155132763$，特判即可。

Code:
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int mod=1000000007;
LL f[100],g[100],h[100][100];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	const int N=54;
	f[1]=g[1]=h[1][0]=h[1][1]=1;
	for(int i=2;i<=N;i++){
		f[i]=h[(i-1)>>1][i-1];
		if(i%2==0) f[i]+=g[i>>1]*(g[i>>1]-1)/2;
		g[i]=h[i-1][i-1];
		for(int j=0;j<=N;j++){
			LL c=1;
			for(int k=0;i*k<=j&&k<=g[i];k++){
				h[i][j]+=h[i-1][j-i*k]*c;
				c=c*(g[i]-k)/(k+1);
			}
		}
	}
	int T;
	cin>>T;
	while(T--){
		string s;
		cin>>s;
		if(s.size()>20){
			cout<<"155132763\n";
			continue;
		}
		LL n;
		sscanf(s.c_str(),"%lld",&n);
		if(n<=6){
			if(n==1) cout<<"0\n";
			else if(n<=5) cout<<"-1\n";
			else cout<<"9\n";
			continue;
		}
		LL cnt=n,lft=n;
		for(int i=1;i<=lft;i++){
			LL val=min(lft/i,f[i]);
			lft-=val*i;
			cnt-=val;
		}
		int n_=n%mod,full=(1ll*n_*(n_-1)/2)%mod;
		cout<<((full-cnt)%mod+mod)%mod<<'\n';
	}
	return 0;
}
```

---

## 作者：OIforJoy (赞：3)

## [传送门](http://luogu.com.cn/problem/P3993)
乍一看似乎没有任何思路.我们来剖析一下.

题目要求计算图中边数的最大值.我们试探一下可以发现:似乎这个图可以极为稠密.而自同构这个条件不太好用.容易想到取补图以后稠密就变为了稀疏.那么稀疏到什么程度呢?

# Step 1

为了解答这个问题,我们考虑这个补图的连通分量.

显然我们只需要**每一个连通分量满足条件并且两两不同构**就可以了.

略微思考可以构造出一列符合要求的树:对于每一个 $n\leq7$ 恰有一个这样的树.

这一列树长成这样:![](https://cdn.luogu.com.cn/upload/image_hosting/rbnejk9j.png)

从而我们有了办法对充分大的 $n$ 使得其符合最值的一个构造的补图为一个森林,证明如下:

分2类进行讨论.

### (1)其连通分量最多有1棵树(孤点算树).

将补图替换为之前这列树中节点数为 $n$ 的得到一个更不劣解.

### (2)其他情况.(这里使用了 $n$ 充分大,实际上只用了 $n\geq7$)

此时其总有一个连通分量是树且不是孤点.由条件简单枚举(或阅读样例),知满足条件的图至少有6个节点,树至少7个节点,否则是孤点.考虑其连通分量中最大的树,断掉它和所有非树连通分量的边,代替成之前的一列树中大小为 $n$ 的树.

从而只需要考虑森林的情况.**显然此时的边数在这些树最多的状况下最优**.

于是考虑对每一个正整数 $n$,想办法计算出节点数为 $n$ 的一棵不存在非平凡自同构的树(叫 **Asymmetric Tree**)的数目(无标号无根树).记为 $U_n$.

# Step 2

我们用 $U_n$ 跑一个贪心,优先使用更小的树,最后用之前情况(2)的方法将其余节点"塞"到最大的某一棵树上.那么瓶颈现在只有如何计算这个数列.我们采用生成函数的方法.以下需要注意到一个图没有非平凡自同构意味着若给一个有标号版和无标号版,则给无标号版的点标号的方式是唯一的,亦即根据
图的特征可以存在一种描述方式区分出任何1个点,也就是可以把这个点从图中"挑出来".

![](https://cdn.luogu.com.cn/upload/image_hosting/jftmpbtg.png)

其中G和g分别是U和R的生成函数.

再考虑如何去计算R.

![](https://cdn.luogu.com.cn/upload/image_hosting/0irq6bjn.png)

到此为止,暴力可以得到 90pts,因为序列增长太快,只需要前270项左右.

如何拿到 100pts 呢?我们可以在生成函数这里进行优化.(其实我感觉用这个算法是可以直接把答案算出来直接特判的)

继续推式子:

![](https://cdn.luogu.com.cn/upload/image_hosting/iojp1mn0.png)

注意到最右边的式子可以通过计算小于 $\sqrt{k}$ 的因数然后进行配对计算,采用这种方式之后直接暴力计算,开O2就过了.

什么?你问我不开O2怎么办?我的高精度没压位,压位就能卡过去.

以下是主函数:(除了高精都在里面)

```C++
Wint rooted[310]={0},tmp=pow((Wint)10,(Wint)100);
Wint unrooted[310]={0};
int main()
{
	rooted[0]=0;
	rooted[1]=1;
	rooted[2]=1;
	rooted[3]=1;
	for(int i=4;i<=300;i++)//R的预处理
	{
		Wint ans1=tmp;
		for(int k=1;k<i;k++)
		{
			Wint ans2=tmp;
			for(int d=1;d*d<k;d++)if(k%d==0)//配对
			{
				if((d)%2==0)ans2-=(k/d)*rooted[k/d];
				else ans2+=(k/d)*rooted[k/d];
				if((k/d)%2==0)ans2-=d*rooted[d];
				else ans2+=d*rooted[d];
			}
			if(((int)sqrt(k))*((int)sqrt(k))==k)//与自己配对
			{
				int d=sqrt(k);
				if((k/d)%2==0)ans2-=d*rooted[d];
				else ans2+=d*rooted[d];
			}
			ans1+=(ans2-tmp)*rooted[i-k];
		}
		ans1-=tmp;
		rooted[i]=ans1/(i-1);
	}
	for(int i=0;i<=300;i++)//以下2个for是U的预处理
	{
		unrooted[i]+=2*rooted[i];
	}
	for(int i=0;i<=300;i++)for(int j=0;j<=300;j++)
	{
		unrooted[i+j]-=rooted[i]*rooted[j];//暴力卷积
	}
	for(int i=0;i<=300;i++)unrooted[2*i]-=rooted[i];
	for(int i=0;i<=300;i++)unrooted[i]/=2;
	int ans[7]={0,0,-1,-1,-1,-1,9};
	int T;
	cin>>T;
	while(T--)
	{
		Wint n;
		cin>>n;
		Wint p=n;
		if(n<7)//特判
		{
			int u=0;
			while(1)
			{
				n-=1;
				u++;
				if(n==0)break;
			}
			printf("%d\n",ans[u]);
			continue;
		}
		int pl=1;
		Wint res=0;
		while(1)//贪心
		{
			if(n>=unrooted[pl]*pl)
			{
				n-=unrooted[pl]*pl;
				res+=unrooted[pl];
			}
			else
			{
				res+=n/pl;
				break;
			}
			pl++;
		}
		cout<<(res+((p*(p-3))/2))%1000000007<<endl;
	}
	return 0;
}
```
另外,有意思的一点是U的生成函数长得和P5900的生成函数很像...也许可以借此搞一些事情?

---

## 作者：cancan123456 (赞：1)

某模拟赛赛时切题获得 rk2，写题解以纪念。

考虑原图的补图，就可以把边数最多转换成边数最少。

通过暴力可以验证 $n=6$ 时不存在树，但有

```
1 2
1 3
2 3
2 4
3 5
5 6
```

这张图没有自同构但是不是一棵树，需要特判。

不妨设 $n\ge7$，可以证明补图是森林。

考虑反证法，设一个大小为 $i$ 的连通分量不是树，设 $f_i$ 表示大小为 $i$ 的没有自同构的无根树的数量。

1. 如果大小为 $i$ 的连通分量中树的数量 $<f_i$，可以将这个连通分量替换成一个无自同构的树，显然边数会减少。
2. 如果大小为 $i$ 的连通分量中树的数量 $=f_i$，可以将这 $i$ 个点连接到一个无自同构的树的直径上构成一条链，只要这个无自同构的树不是一个单点，那么就不会出现问题。
3. 上面这个证明依赖于：补图中存在除了单点以外的无自同构的树，显然补图中单点的数量不能多于 $1$ 个，否则就存在自同构：只交换这两个单点。
4. 考虑极端情况，这个图里有一个单点，并且所有连通分量都不是树，此时总可以把整个图替换成一棵 $n$ 个节点的树（因为 $f_n>0$）。

现在我们需要求 $f_i$。

根据 AHU 算法的思路，考虑钦定树的重心为根，分类讨论。

1. 只有一个重心，那么这个重心的每棵子树相当于一棵 **有根的** 没有自同构的树，且不互同构，我们设 $g_i$ 为大小为 $i$ 的没有自同构的有根树的数量，只需要做一个背包即可，注意子树大小必须 $\le\left\lfloor\dfrac{i-1}2\right\rfloor$，以保证树的根是唯一重心。

> 子树是有根树的原因：如果这棵树有自同构，那么重心一定映射到重心，与重心相连的点映射后也与重心相连，这就相当于钦定与重心相连的点为根。

2. 有两个重心，那么 $i$ 必须是偶数，两个重心所在的子树必须没有自同构且不同构，且大小相等，均为 $j=\dfrac i2$，这种情况数为 $\dfrac12g_j(g_j-1)$。

考虑如何计算 $g_i$，与计算 $f_i$ 的第一种情况类似，只是把子树大小的限制放宽到 $<i$，因为不需要保证根是唯一重心。

打个表观察，发现 $f_{55}$ 就爆 `long long` 了，所以算 $54$ 项就可以得到 $90$ 分了。

如何得到 $100$ 分？只需要求出 $n=10^{100}$ 的答案即可，用 Python 算一算，结果是 $155132763$。

这个东西的时间复杂度能算，实际上，$f_i$ 就是 [OEIS A000220](https://oeis.org/A000220)，其增长率为 $\Theta(d^nn^{-5/2})$，其中 $d\approx2.518$。

所以这个算法的时间复杂度为 $O(\text{poly}\log n)$，可以通过此题。

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
typedef long long ll;
const ll mod = 1000000007;
const int N = 54;
ll bao[N + 5], g[N + 5], f[N + 5];
ll min(ll a, ll b) {
	return a < b ? a : b;
}
char s[114];
int main() {
	g[1] = f[1] = 1;
	for (int i = 2; i <= N; i++) {
		bao[0] = 1;
		for (int j = 1; j < i; j++) {
			bao[j] = 0;
		}
		for (int j = 1; j <= (i - 1) / 2; j++) {
			// 拼接大小为 j 的无标号有根树.
			for (int k = i - 1; k >= 1; k--) {
				ll ans = 1;
				for (int l = 1; l * j <= k; l++) {
					// 对大小 k 拼接 l 个.
					if (l > g[j]) {
						break;
					}
					ans = ans * (g[j] - l + 1) / l;
					bao[k] += bao[k - l * j] * ans;
				}
			}
		}
		f[i] = bao[i - 1];
		if (i % 2 == 0) {
			f[i] += g[i / 2] * (g[i / 2] - 1) / 2;
		}
		bao[0] = 1;
		for (int j = 1; j < i; j++) {
			bao[j] = 0;
		}
		for (int j = 1; j < i; j++) {
			// 拼接大小为 j 的无标号有根树.
			for (int k = i - 1; k >= 1; k--) {
				ll ans = 1;
				for (int l = 1; l * j <= k; l++) {
					// 拼接 l 个.
					if (l > g[j]) {
						break;
					}
					ans = ans * (g[j] - l + 1) / l;
					bao[k] += bao[k - l * j] * ans;
				}
			}
		}
		g[i] = bao[i - 1];
	}
	int T;
	scanf("%d", &T);
	for (ll n; T != 0; T--) {
		scanf("%s", s);
		if (strlen(s) <= 19) {
			n = 0;
			for (int i = 0; s[i] != '\0'; i++) {
				n = n * 10 + s[i] - '0';
			}
		} else {
			printf("155132763\n");
			continue;
		}
		if (n == 1) {
			printf("0\n");
		} else if (n <= 5) {
			printf("-1\n");
		} else if (n == 6) {
			printf("9\n");
		} else {
			ll ans;
			if (n % 2 == 0) {
				ans = (n / 2 % mod) * ((n - 3) % mod) % mod;
			} else {
				ans = (n % mod) * ((n - 3) / 2 % mod) % mod;
			}
			ll cnt = 0;
			for (int i = 1; i <= N; i++) {
				if (n < i) {
					break;
				}
				cnt += min(f[i], n / i);
				n -= i * min(f[i], n / i);
			}
			printf("%lld\n", (ans + cnt % mod) % mod);
		}
	}
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

好厉害的题！

首先我们注意到若 $G$ 与 $\overline G$ 的自同构性相同。因此最大可以转换为最小。

我们希望新图的边数最小，自然希望新图是一个森林。

接下来我们有引理：当 $n\ge 7$ 时，存在一颗大小为 $n$ 的非自同构树。（观察样例即可发现，$n<6$ 时不存在），本引理我们将稍后证明。

那么便显然导出了以下贪心策略：先从小到大放树，然后把剩下的点全塞到一棵树上即可。容易证明该贪心的正确性。（即，如果有一个联通块不是树，把它塞到最大的树上一定不劣）

接下来问题转化为了：求 $f_n$ 为大小为 $n$ 的非自同构**无根树**的个数。

注意到如下事实：

若树 $T$ 存在**唯一的**重心 $g$ 且 $T$ 存在自同构 $p$，则 $p_g=g$。

这启示我们对重心计数。

1. $T$ 只有一个重心。
   做个背包就好了，注意所有子树必须 $\le\left\lfloor\dfrac{n-1}{2}\right\rfloor$。
2. $T$ 有两个重心，这两个重心的子树必须不等，方案数为 $\binom{f_{n/2}}{2}$。

关于引理的证明：首先注意到 $n=7$ 时存在符合条件的树，因为递推式，故对 $n>7$ 亦存在。

因为后者的存在，这个的增长率是指数级的。故复杂度为 $\Theta{(\log n)}$

---


# [AHOI2014/JSOI2014] 拼图

## 题目描述

JYY 最近迷上了拼图游戏。作为一个计算机科学家，JYY 有一套黑白色的拼图，他希望通过合理的拼接，使得拼出的最终图案中，能包含面积最大的全白色子矩形。

JYY 一共有 $S$ 块拼图，并且由 $1$ 到 $S$ 编号。编号为 $i$ 的拼图是一个 $N$ 行列的方格矩形，每个方格都为黑色或者白色。一开始 JYY 将他的这 $S$ 块拼图按照编号顺序左右相连依次放在桌上拼成了一个 $N$ 行 $M$ 列（这里 $M=\sum_{i=1}^S W_i$）的大矩形。

之后 JYY 发现，可以通过改变这 $S$ 块拼图的连接次序，使得拼成的 $N$ 行 $M$ 列的大矩形中，最大全白子矩形面积变大。

现在 JYY 想知道，怎么拼才能得到最大的全白子矩形呢？请你帮助他计算出最佳的拼接方案。

## 说明/提示

对于 $100\%$ 的数据满足$1\le S,N,W \le 10^5$，$N\times \sum W_i \le10^5$，$1\le T\le3$。


## 样例 #1

### 输入

```
1
3 4
4
1001
0000
0010
1001
3
000
010
000
011
2
00
10
01
00```

### 输出

```
6```

# 题解

## 作者：GaryZhong (赞：8)

题目大意

将一个$n*m$的01矩阵沿着列切几刀，拆成若干个$n*w_i$大小的矩阵，你可以重新任意排列它们来拼成一个新的$n*m$的01矩阵，使得矩阵中最大的全0矩形面积最大。

### Solution

这题关键在于$n*m\leq 10^5$，即矩阵大小不超过$10^5$。一种直觉是平衡规划，即分$n\leq \sqrt{10^5}$和$m\leq \sqrt{10^5}$两种情况分别设计算法。

- $n\leq \sqrt{10^5}$

枚举最终全0矩形的上下边界$l,r$，然后对每个小矩阵分类。若小矩阵内第$l$行至第$r$行全部为0，分为I类，否则分为II类。

最后肯定是把I类的矩阵放在中间，两边放II类的矩阵来凑成一个全0矩形，那么，我们需要计算I类矩阵宽度之和，以及II类矩阵在左边最多几列为全0，右边最多几列为全0。需要注意的是，左右不能用II类矩阵中的同一个，所以我们还要记录一下次大值，不能用最大值时用次大值替换。

时间复杂度$O(n^2m)=O(10^5n)$，$n$是根号级别的，显然不会超时。

- $m\leq 10^5$

这时就不能直接枚举矩形的上下边界了，我们可以用另一种方法枚举上下边界：

> 记录矩形中每个点$(i,j)$往上第一个$1$的行号（记作$up[i][j]$）。枚举矩形中的每个点$(i,j)$，将$up[i][j]$作为上边界，$i$作为下边界。（替换了原来暴力枚举的上边界$r$，下边界$l$）

剩下的过程套用上面的即可，时间复杂度$O(nm^2)=O(10^5m)$，$m$是根号级别的，也不会超时。

至此，问题解决。

### Code

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=100007;

int T;
int s,n,m,ans,w[N],st[N],en[N],sum[N],a[N],up[N];

int id(int x,int y){
	if(x<1||y<1)return 0;
	return (y-1)*n+x;
}
int get(int x1,int x2,int y1,int y2){
	return sum[id(x2,y2)]-sum[id(x1-1,y2)]-sum[id(x2,y1-1)]+sum[id(x1-1,y1-1)];
}

void calc(int l,int r){
	for(int i=1;i<=s;++i)for(int j=st[i],ret=0;j<=en[i];++j){
		if(get(l,r,j,j)==0)++ret;
		else ret=0;
		ans=max(ans,(r-l+1)*ret);
	}
	int L[2][2],R[2][2],mid=0;
	memset(L,0,sizeof(L));
	memset(R,0,sizeof(R));
	for(int i=1;i<=s;++i){
		int mxl=0,mxr=0;
		for(int j=st[i];j<=en[i];++j)if(get(l,r,j,j)==0)++mxl;else break;
		for(int j=en[i];j>=st[i];--j)if(get(l,r,j,j)==0)++mxr;else break;
		if(mxl==w[i])mid+=w[i];
		else{
			if(mxl>L[0][0])L[0][0]=mxl,L[0][1]=i;
			else if(mxl>L[1][0])L[1][0]=mxl,L[1][1]=i;
			if(mxr>R[0][0])R[0][0]=mxr,R[0][1]=i;
			else if(mxr>R[1][0])R[1][0]=mxr,R[1][1]=i;
		}
	}
	for(int p=0;p<2;++p)for(int q=0;q<2;++q)if(L[p][1]!=R[q][1])ans=max(ans,(r-l+1)*(mid+L[p][0]+R[q][0]));
	ans=max(ans,(r-l+1)*(mid+L[0][0]));
	ans=max(ans,(r-l+1)*(mid+R[0][0]));
}

int main(){
	scanf("%d",&T);
	while(T--){
		m=ans=0;
		scanf("%d%d",&s,&n);
		memset(w,0,sizeof(w));
		memset(st,0,sizeof(st));
		memset(en,0,sizeof(en));
		memset(sum,0,sizeof(sum));
		memset(a,0,sizeof(a));
		memset(up,0,sizeof(up));
		for(int i=1;i<=s;++i){
			scanf("%d",&w[i]);
			st[i]=m+1;
			for(int j=1;j<=n;++j)for(int k=1;k<=w[i];++k){
				char c;scanf(" %c",&c);
				a[id(j,m+k)]=c-'0';
			}
			m+=w[i],en[i]=m;
		}
		for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)sum[id(i,j)]=sum[id(i-1,j)]+sum[id(i,j-1)]-sum[id(i-1,j-1)]+a[id(i,j)];
		for(int j=1;j<=m;++j)
			for(int i=1,lst=0;i<=n+1;++i)
				if(i>n||a[id(i,j)]){
					for(int k=lst+1;k<=i-1;++k)up[id(k,j)]=i-1;
					lst=i;
				}
		if(n<m)for(int i=1;i<=n;++i)for(int j=i;j<=n;++j)calc(i,j);
		else for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)calc(i,up[id(i,j)]);
		printf("%d\n",ans);
	}
	return 0;
}
```





---

## 作者：龙之吻—水货 (赞：3)

# [AHOI2014/JSOI2014]拼图

## 题目链接

### [[AHOI2014/JSOI2014]拼图](https://www.luogu.org/problemnew/show/P4039)

## 解题报告

网上的题解都是根号分治，但是这里考虑一种$log$的做法。

首先感谢@[独秀平川](https://www.luogu.org/space/show?uid=53153)神仙告诉了我这个神奇的解法。

简单思考，可以发现，最优情况只有两种，一种是在一块拼图内部选取一个举行，一种是多个拼图联通起来，具体来说就是这个样子 :

![](https://cdn.luogu.com.cn/upload/pic/54978.png)

当然，可能会没有左区间或者右区间。

暂时不考虑第一种情况。

对于第二种情况，我们先预处理出每个格子，最多可以向上延伸多少(如果这个格子上的数字为 $1$ 那么是不可延伸的)，只需要从上到下扫一遍即可。

之后，我们从下往上枚举所求矩形的下边界，寻找最优解。

考虑已知下边界如何求出最优解，显然，对于每一块拼图，情况都应该是这样子的：

![](https://cdn.luogu.com.cn/upload/pic/54982.png)

其中蓝色的表示从当前下边界最多可以往上延伸的部分。

尝试从上到下枚举高度，由于在离散化之后，高度最多有 $M$ 种，而 $n \times M \leq 10^5$，所以到现在时间复杂度都还是在可接受的范围内。

每枚举到一个高度，都需要求出每一块拼图从左边向内可以延伸多少，从右边向内可以延伸多少(特别地，如果可以延伸的长度等于该块拼图的长度，说明这一块拼图被打通了，可以作为中间的块)。

只要维护了这些东西，我们找出从左边延伸最多的拼图，从右边延伸最多的拼图，以及所有被打通了的拼图，将它们组合在一起就可以得到当前高度的最优解。

由于 从左边延伸最多的拼图 和 从右边延伸最多的拼图 可能是同一个拼图，所以我们可能会同时需要最大值和次大值。同时，当一个拼图被打通之后，需要将它对最大值和次大值的贡献删去。于是选择使用两个 $set$ 分别来存储没被打通的拼图。

至于如何在枚举高度之后快速求出所需要的值，只需要两个指针就可以了。但是为了顺便解决最优情况在一块拼图内部的情况，选择使用并查集。

对于每一块拼图，我们把每一列当作一个单独的点，将这个点可以向上延伸距离称为这个点的高度，由于是从上往下枚举高度，所以相邻的两点之间只可能是在不断地合并，每枚举到一个高度 $h$，我们就只需要将所有高度为 $h$ 的点和它相邻且高度为 $h$ 的点合并即可。如果当前点所在联通块的大小为这块拼图的宽度，说明当前拼图被打通了。

同时，当前点所在联通块的大小与当前枚举到的高度 $h$ 相乘，并用结果更新 $ans$ 就可以涵盖所有最优解在一块拼图的情况了。这个简单想一下就明白了吧？

附上Code。。。
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<string>
#include<deque>
#include<queue>
#include<set>

class Solution{
private :
    typedef std::pair<int, int> par;
    static const int maxn = 1e5 + 7;
    
    struct Block{
        int len, **h;
        int *fa, *size;
        bool *open;
        std::string *str;

        inline int *operator [](int x) const {
            return this->h[x];
        }

        int find(int k) {
            return fa[k] == k ? k : fa[k] = find(fa[k]);
        }

        int findSize(int k) {
            return size[find(k)];
        }

        void merge(int x, int y) {
            if (!open[x] || !open[y]) {
                return;
            }
            x = find(x), y = find(y);
            if (x == y) {
                return;
            }
            fa[y] = x;
            size[x] += size[y];
        }
    };
    
    int t, s, n, ans;
    Block b[maxn];
    std::deque<par> dq;
    std::priority_queue<std::pair<int, par> > pq;
    std::set<par, std::greater<par> > left, right;

    template<typename T>
    T next(T x) {
        ++x;
        return x;
    }

    template<typename T>
    T prev(T x) {
        --x;
        return x;
    }

    void make(const Block &b) {
        for (register int i = 1; i <= n; i++) {
            for (register int j = 1; j <= b.len; j++) {
                bool now = b.str[i][j - 1] - '0';
                if (now) {
                    b[i][j] = 0;
                } else {
                    b[i][j] = b[i - 1][j] + 1;
                }
                //printf("%d ", b[i][j]);
            }
            //putchar('\n');
        }
        //putchar('\n');
    }

    int deal(int flor) {
        int res = 0;
        //printf("floor = %d : \n", flor);
        for (register int i = 1; i <= s; i++) {
            left.insert(std::make_pair(0, i));
            right.insert(std::make_pair(0, i));
            memset(b[i].open, 0, b[i].len + 2);
            b[i].fa[0] = 0, b[i].size[0] = 0, b[i].open[0] = 1;
            b[i].fa[b[i].len + 1] = b[i].len + 1, b[i].size[b[i].len + 1] = 0, b[i].open[b[i].len + 1] = 1;
            for (register int j = 1; j <= b[i].len; j++) {
                b[i].fa[j] = j, b[i].size[j] = 1;
                pq.push(std::make_pair(b[i][flor][j], std::make_pair(i, j)));
            }
        }
        int mid = 0;
        //fprintf(stderr, "%d\n", flor);
        while (!pq.empty()) {
            int height = pq.top().first, id = pq.top().second.first, pos = pq.top().second.second;
            pq.pop();

            int leftLen = b[id].findSize(0), rightLen = b[id].findSize(b[id].len + 1);
            b[id].open[pos] = 1;
            b[id].merge(pos, pos - 1);
            b[id].merge(pos, pos + 1);
            ans = std::max(ans, b[id].findSize(pos) * height);
            //printf("%d %d : %d %d\n", id, pos, b[id].findSize(pos), height);
            left.erase(std::make_pair(leftLen, id));
            right.erase(std::make_pair(rightLen, id));
            if (b[id].findSize(0) == b[id].len) {
                //puts("233");
                mid += b[id].findSize(0);
            } else {
                left.insert(std::make_pair(b[id].findSize(0), id));
                right.insert(std::make_pair(b[id].findSize(b[id].len + 1), id));
            }
            //printf("%d %d : %d\n", flor, height, mid);
            int sum = mid * height;
            res = std::max(res, sum);
            if (!left.empty()) {
                par l = *left.begin();
                //printf(":: %d\n", l.first);
                res = std::max(res, sum + l.first * height);
                if (!right.empty()) {
                    par r = *right.begin();
                    if (l.second == r.second) {
                        if (right.size() > 1u) {
                            r = *next(right.begin());
                            res = std::max(res, sum + (l.first + r.first) * height);
                        }
                        if (left.size() > 1u) {
                            l = *next(left.begin());
                            res = std::max(res, sum + (l.first + r.first) * height);
                        }
                    } else {
                        res = std::max(res, sum + (l.first + r.first) * height);
                    }
                }
            } else {
                if (!right.empty()) {
                    par r = *right.begin();
                    res = std::max(res, sum + r.first * height);
                }
            }
            //par leftFirst = *left.begin();
        }
        //printf("%d %d\n", flor, res);
        return res;
    }
    
public :
    Solution() {
        scanf("%d", &t);
        while (t--) {
            get();
            solve();
        }
    }

    void get() {
        scanf("%d %d", &s, &n);
        for (register int i = 1; i <= s; i++) {
            scanf("%d", &b[i].len);
            b[i].h = new int*[n + 1];
            b[i].fa = new int[b[i].len + 2];
            b[i].size = new int[b[i].len + 2];
            b[i].open = new bool[b[i].len + 2];
            
            b[i].str = new std::string[n + 1];
            b[i].h[0] = new int[b[i].len + 1];
            memset(b[i].h[0], 0, (b[i].len + 1) << 2);
            for (register int j = 1; j <= n; j++) {
                std::cin >> b[i].str[j];
                b[i].h[j] = new int[b[i].len + 1];
                memset(b[i].h[j], 0, (b[i].len + 1) << 2);
            }
        }
    }

    void solve() {
        //make(b[1]);
        //ans = getAns(b[1]);
        ans = 0;
        for (register int i = 1; i <= s; i++) {
            make(b[i]);
            //ans = std::max(ans, getAns(b[i]));
        }
        for (register int i = 1; i <= n; i++) {
            ans = std::max(ans, deal(i));
        }
        printf("%d\n", ans);
    }
};
Solution sol;

int main() {}

```

---

## 作者：ButterflyDew (赞：2)

从下往上一行一行处理，每个点预处理向上延伸长度

对于每行，拿右边一部分+完整的块+左边的块拼一下

拿堆按高度维护一下完整的块的长度，一个一个的拿走最低高度，扔到另一个集合里

对另一个集合维护一下每个高度的最长长度就可以了（从左边或右边）

可以直接可以持久化硬艹(恩注意一下左边右边不能来自一个块)

不过还可以发现每一行的高度个数不超过$\sqrt 1e5$，离散化一下就可以直接暴力了

---

## 作者：xxxxxzy (赞：1)

题解没太看懂。这个题评个蓝差不多了，提供一种显然且好写的新做法。

套路化的，对矩阵的每一个位置处理出来这个位置上面的极长 0 段的 0 的个数。

由于这与顺序无关，所以可以方便预处理。

然后问题转化为对于每一行，任意排列 $S$ 个数列，求出来每个点左右最长能延伸出多少长度。

这里的延伸代表了延伸后的区间的每个数都大于等于当前数。

举个例子，$S = 3$，三个数列为 $\{ 1,2,1 \} ,\{2,3\},\{1,4\}$，则第二个数列的第一个数的最大延伸即为 $3$，三个序列的排列顺序为 $3,2,1$。

这样每个点贡献的答案即为这个点的延伸长度乘以这个点的点权。

然后维护就很显然了，从大到小插入每个点，维护每个块的左右极长 1 段 $lmax,rmax$，为了防止重复，还应该维护 $lsec,rsec$，方便实现可以用俩个 multiset 分别把 $(lmax,-rmax),(rmax,-lmax)$ 作为关键字插入。

如果一个块全是 1，那么拿一个变量单独存一下全是 1 的块的长度和。

最后的问题在于找到每个块的每个点的前缀第一个 1 和后缀第一个 1，这很简单，拿个链表维护一下。

复杂度是 $n\sum w_i \log (\sum w_i)$，并且小常数。

代码不放了，需要者私信。

---

## 作者：Thunder_S (赞：1)

## Solution

记 $M=\sum W_i$。

注意到数据范围中 $N\times M\le 10^5$，这提示我们可以分两种情况进行。

在讨论之前，先思考一下：如果我们已知矩形的上下边界，如何在 $\mathcal O(M)$ 的时间里得到答案。

显然，最终答案矩形一定是横跨若干个矩形，然后是左右两端的矩形的一部分（可能没有）。不妨设上下边界分别是 $l,r$。那么我们先找出在 $[l,r]$ 全是 $0$ 的矩形，这些矩形肯定是放中间的。然后再去寻找左右边界。可以记录每个矩形从左或右开始在 $[l,r]$ 中最多有几列，并把其中的最大值所对应的矩形放在左右端点。但是可能某一矩形被同时放在左右端点。为了防止这种情况，需要再统计一个次大值。这个复杂度是 $\mathcal O(M)$。

回到上面的讨论。若 $N\le M$，那么 $N\le\sqrt{10^5}$，我们就可以直接枚举上下边界，用上文的做法即可，总复杂度 $\mathcal O(N^2M)$。反之，那我们统计出每个点上方的第一个 $1$ 的位置，记为 $up_{i,j}$，然后以 $[up_{i,j},i]$ 作为左右边界，同样使用上文的做法即可。总复杂度 $\mathcal O(NM^2)$。

另外，由于每个矩形的大小不能保证一个较小的范围，所以直接存会爆空间，因此我们需要二维转一维存图。

## Code
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 100005
using namespace std;
int T,num,n,m,ans,w[N],st[N],ed[N],a[N],sum[N],up[N];
char ch[N];
int id(int x,int y)
{
    if (x<1||y<1) return 0;
    return (y-1)*n+x;
}
int getsum(int xx1,int yy1,int xx2,int yy2) {return sum[id(xx2,yy2)]-sum[id(xx1-1,yy2)]-sum[id(xx2,yy1-1)]+sum[id(xx1-1,yy1-1)];}
void calc(int l,int r)
{
    if (l>r) return;
    for (int i=1,res=0;i<=num;++i)
    {
        for (int j=st[i];j<=ed[i];++j)
        {
            if (getsum(l,j,r,j)==0) ++res;
            else res=0;
            ans=max(ans,res*(r-l+1));
        }
    }
    int lmx[2][2],rmx[2][2],len=0;
    memset(lmx,0,sizeof(lmx));
    memset(rmx,0,sizeof(rmx));
    for (int i=1;i<=num;++i)
    {
        int llen=0,rlen=0;
        for (int j=st[i];j<=ed[i];++j)
            if (getsum(l,j,r,j)==0) llen++;
            else break;
        for (int j=ed[i];j>=st[i];--j)
            if (getsum(l,j,r,j)==0) rlen++;
            else break;
        if (llen==w[i]) len+=w[i];
        else
        {
            if (llen>lmx[0][0]) lmx[1][0]=lmx[0][0],lmx[1][1]=lmx[0][1],lmx[0][0]=llen,lmx[0][1]=i;
            else if (llen>lmx[1][0]) lmx[1][0]=llen,lmx[1][1]=i;
            if (rlen>rmx[0][0]) rmx[1][0]=rmx[0][0],rmx[1][1]=rmx[0][1],rmx[0][0]=rlen,rmx[0][1]=i;
            else if (rlen>rmx[1][0]) rmx[1][0]=rlen,rmx[1][1]=i;
        }
    }
    ans=max(ans,(r-l+1)*len);
    for (int i=0;i<2;++i)
        for (int j=0;j<2;++j)
            if (lmx[i][1]!=rmx[j][1])
                ans=max(ans,(r-l+1)*(len+lmx[i][0]+rmx[i][0]));
}
int main()
{
    scanf("%d",&T);
    while (T--)
    {
        m=ans=0;
        memset(sum,0,sizeof(sum));
        scanf("%d%d",&num,&n);
        for (int i=1;i<=num;++i)
        {
            scanf("%d",&w[i]);
            st[i]=m+1;
            for (int j=1;j<=n;++j)
            {
                scanf("%s",ch+1);
                for (int k=1;k<=w[i];++k)  
                    a[id(j,m+k)]=ch[k]-'0';
            }
            m+=w[i];
            ed[i]=m;
        }
        for (int i=1;i<=n;++i)
            for (int j=1;j<=m;++j)
                sum[id(i,j)]=sum[id(i,j-1)]+sum[id(i-1,j)]-sum[id(i-1,j-1)]+a[id(i,j)];
        for (int j=1;j<=m;++j)
            for (int i=1;i<=n;++i)
            {
                if (a[id(i,j)]==1) up[id(i,j)]=i;
                else up[id(i,j)]=up[id(i-1,j)];
            }
        if (n<=m)
        {
            for (int i=1;i<=n;++i)
                for (int j=i;j<=n;++j)
                    calc(i,j);
        }
        else
        {
            for (int i=1;i<=n;++i)
                for (int j=1;j<=m;++j)
                    calc(up[id(i,j)]+1,i);
        }
        printf("%d\n",ans);
    }
    return 0;
}
```


---


# [SDOI2016] 墙上的句子

## 题目描述

考古学家发现了一堵写有未知语言的白色墙壁，上面有一个 $n$ 行 $m$ 列的格子，其中有些格子内被填入了某个 `A` 至 `Z` 的大写字母，还有些格子是空白的。

一直横着或竖着的连续若干个字母会形成一个单词，且每一行的阅读顺序可能是从左向右或从右向左，每一列的阅读顺序可能是从下往上或从上往下。也就是说对于每一行来说，从左向右可以被看做是若干个单词形成的句子，相邻两个单词被一个或多个空白格子分割开来；也有可能是从右向左被看成是一个句子，竖直方向类似。

遗憾的是，我们并不完全知道每一行每一列的阅读顺序是怎样的。但可以猜测，有些单词会满足反转过来也是一个单词。例如单词 `BOY`，翻转过来的 `YOB` 也是一个英文单词。

此外观察者发现，对每一行（列）来说，按照确定后的阅读顺序读出的所有单词同时满足“自己的字典序不小于翻转后的字典序”，或同时满足“自己的字典序不大于翻转后的字典序”。

在确定了所有行列的阅读顺序之后，我们可以构造出关于这种未知语言的字典。

请问字典中出现的“翻转过来也是一个单词”的单词最少有多少种请注意，如果一个单词翻转后是不同的另外一个单词，它们需要被分别计入；而对于本身是回文的单词则不需要重复计入


## 说明/提示

对于 $100\%$ 的数据，$1\leq n,m\leq 72$，$T\leq 64$。

## 样例 #1

### 输入

```
1
2 10
0 0
0 0 0 0 0 0 0 0 0 0 
ADA_JARVIS
ADA_SIVRAJ```

### 输出

```
3```

# 题解

## 作者：guyan (赞：8)

__题目大意__

给出 $n+m$ 个字符串 ,  每个字符串包含若干单词 , 可以正着读也可以反着读 , 有些字符串已经确定了阅读方法 , 要求确定剩下字符串的阅读方法 , 使得正反串都出现的单词数最少. 

保证对于同一个字符串内的单词 , 要么所有单词的正串字典序大于等于反串 , 要么所有单词的反串字典序大于等于正串.

__solution__

回文串一定产生 $1$ 的贡献 , 单独处理

看到正反可以联想到 [文理分科](https://www.luogu.com.cn/problem/P4313) , 类比这道题考虑最小割做法

一开始是想着直接将 $n+m$ 个字符串作为被分的对象 , 然而并建不了图 , 因为对于单词来说这是存在性问题

转换思维 ~~查阅题解~~ , 将单词作为被划分集合的对象 

设源点为 $s$ , 汇点为 $t$ , 划分的两个集合为 $S$ 与 $T$ 

将一个单词分为正串与反串两个节点 ( 这里正串定义为正反串中字典序较小的串 ) , 正串向反串连容量为 $2$  的边 


正串被划分到 $S$ 集合 $\rightarrow$ 正串出现

正串被划分到 $T$ 集合 $\rightarrow$ 正串没有出现

反串被划分到 $T$ 集合 $\rightarrow$ 反串出现

反串被划分到 $S$ 集合 $\rightarrow$ 反串没有出现

当正串一定出现时 , $s$ 向正串连容量为 $INF$ 的边

当反串一定出现时 , 反串向 $t$ 连容量为 $INF$ 的边

接下来考虑那些没有确定读法的字符串

这里有一个重要条件

>对于同一个字符串内的单词 , 要么所有单词的正串字典序大于等于反串 , 要么所有单词的反串字典序大于等于正串.

意味着一个字符串中所有出现的单词都是正串 , 或者是反串 ( 这里假设都是正串 )

设使得字符串中单词都是正串的读法是将字符串划入 $S$ 集合

字符串被划入 $S$ 集合 $\rightarrow$ 正串出现

字符串被划入 $T$ 集合 $\rightarrow$ 反串出现

若字符串被划入 $S$ 集合 , 其中出现的正串也一定在 $S$ 集合 , 于是字符串向每个其中出现的单词的正串连 $INF$ 边

若字符串被划入 $T$ 集合 , 其中出现的反串也一定在 $T$ 集合 , 于是字符串中出现单词的反串向字符串连 $INF$ 边 

__code__

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 7e2 + 5;
const int M = N * N;
const int INF = 0x3f3f3f3f;
int _w;

int head[N] , eidx , dep[N] , que[N] , he , ta , cur[N] , st , ed;
struct Edge { int nxt , to , flow , cap; } edge[M];

void addedge( int u , int v , int cap ) { 
  edge[++eidx] = (Edge) { head[u] , v , 0 , cap }; head[u] = eidx;
  edge[++eidx] = (Edge) { head[v] , u , 0 , 0 }; head[v] = eidx;
}

bool bfs( void ) {
  static int u;
  memset( dep , 0 , sizeof dep );
  dep[que[he = ta = 1] = st] = 1;
  while( he <= ta ) {
    u = que[he++];
    for( int i = head[u] , v ; ~i ; i = edge[i].nxt )
      if( !dep[v = edge[i].to] && edge[i].cap > edge[i].flow )
        dep[que[++ta] = v] = dep[u] + 1;
  }
  return dep[ed] != 0;
} 

int dfs( int u , int fl ) {
  if( u == ed || !fl ) return fl;
  int g = 0 , d;
  for( int & i = cur[u] ; ~i ; i = edge[i].nxt ) 
    if( dep[edge[i].to] == dep[u] + 1 && ( d = dfs( edge[i].to , min( edge[i].cap - edge[i].flow , fl - g ) ) ) ) {
      edge[i].flow += d , edge[i ^ 1].flow -= d;
      if( ( g += d ) >= fl ) break;
    }
  return g;
}

int dinic( void ) {
  int res = 0;
  while( bfs() ) {
    memcpy( cur , head , sizeof head );
    res += dfs( st , INF );
  }
  return res;
}

int n , m , col[N] , row[N] , idx;
char str[N][N];
set<string> pal;
map<string,int> id;

void analyze( string s , int type , int u ) {
  static int n; 
  static string a , b;
  n = s.length();
  for( int i = 0 , r , flag ; i < n ; i = r + 1 ) {
    r = i;
    if( s[i] == '_' ) continue;
    while( r < n - 1 && s[r + 1] != '_' ) ++r;
    a = s.substr( i , r - i + 1 );
    b = a; reverse( b.begin() , b.end() );
    if( b < a ) swap( a , b ) , flag = -1;
    else flag = 1;
    if( a == b ) {
      pal.insert( a );
      continue;
    }
    if( !id.count( a ) ) {
      id[a] = ++idx;
      id[b] = ++idx;
      addedge( idx - 1 , idx , 2 );
    } flag *= type;
    if( flag == 1 ) addedge( st , id[a] , INF );
    else if( flag == -1 ) addedge( id[b] , ed , INF );
    else addedge( id[b] , u , INF ) , addedge( u , id[a] , INF );
  }
}

void solve( void ) {
  _w = scanf("%d%d",&n,&m); idx = n + m;
  memset( head , -1 , sizeof head ) , eidx = -1;
  id.clear() , pal.clear();
  for( int i = 1 ; i <= n ; ++i ) _w = scanf("%d",row + i );
  for( int i = 1 ; i <= m ; ++i ) _w = scanf("%d",col + i );
  for( int i = 1 ; i <= n ; ++i ) _w = scanf("%s",str[i]+1);
  st = 0 , ed = N - 1;
  static string tmp;
  for( int i = 1 ; i <= n ; ++i ) {
    tmp = str[i] + 1;
    analyze( tmp , row[i] , i );
  }
  for( int i = 1 ; i <= m ; ++i ) {
    tmp = "";
    for( int j = 1 ; j <= n ; ++j )
      tmp += str[j][i];
    analyze( tmp , col[i] , i + n );
  }
  printf("%d\n",dinic() + int( pal.size() ) );
}

int main( void ) {
  int T;
  _w = scanf("%d",&T);
  while( T-- ) solve();
  return 0;
}
```



---

## 作者：rzh123 (赞：2)

现有题解都是“以单词作为被分的对象”，有一篇题解也说“一开始是想着直接将 $n+m$ 个字符串作为被分的对象 , 然而并建不了图”，但是实际上是可以的。  

首先有一些比较简单的转化：  
+ 行列是等价的，相当于 $n+m$ 行；  
+ 回文单词的贡献一定是 $1$，后面不考虑；  
+ 如果一行中有某些单词的字典序大于其逆序的字典序，可以把这一行翻转，读的顺序也翻转，这样不影响答案。  

现在就是有 $n+m$ 行，每一行可以正读或反读，且单词都不回文，字典序都小于其逆序。此时如果全部从左往右读，则不存在两个不同的单词，使得一个是另一个的逆序。  

在最终的方案中，两个字符串互为逆序，当且仅当它们在初始时相同，且它们所在的行的方向不同，这时它们会有 $2$ 的贡献。可以用最小割解决。    

设 $S$ 为源点，$T$ 为汇点。  
考虑给每一行确定方向，给第 $i$ 行建一个点 $P_i$，连边 $S\rightarrow P_i\rightarrow T$，割 $S\rightarrow P_i$ 表示这一行逆序读，割 $P_i\rightarrow T$ 表示这一行正序读，如果这一行的方向已经确定，则对应边权为 $\mathrm{INF}$，否则边权为 $0$。  

“两行的方向不同时有贡献”很像 [P2057](https://www.luogu.com.cn/problem/P2057)、[P1361](https://www.luogu.com.cn/problem/P1361) 中的条件，每一个字符串 $\text{str}$ 是一个条件，对它建虚拟结点 $X,Y$，连边 $S\xrightarrow 2 X, Y\xrightarrow 2 T$，对所有包含 $\text{str}$ 的行 $i$，连边 $X\xrightarrow{\mathrm{INF}}{P_i},P_i\xrightarrow{\mathrm{INF}}{Y}$。这样当 $P_i$ 中至少有一个割 $S\rightarrow P_i$ 边时，$S\xrightarrow 2 X$ 边必须割，对 $T$ 同理。如果出现了互为逆序的串，两个都会被割，否则有一个会被割，所以每次还要减去多算的 $2$ 贡献。  

设最小割为 $c$，本质不同回文单词数量为 $p$，不同的非回文串数量为 $q$，答案是 $p+c-2q$。  

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace std;
constexpr int N=155,INF{0x3F3F3F3F};
int n,m,cho0[N],P[N];
bool rev[N];
char a[N][N];
vector<string> str[N];
inline string reversed(string s){
    reverse(s.begin(),s.end());
    return s;
}
struct Flow{
    static constexpr int N=5e4+5,M=5e5+5;
    int nc,ec{1},eh[N],S,T;
    int dep[N],crt[N];
    struct{int nxt,to,w;}e[M<<1];
    inline void clear(){
        memset(eh+1,0,nc*sizeof(int)),ec=1;
        nc=S=T=0;
    }
    inline int newn(){return ++nc;}
    inline void ebba(int u,int v,int w){
        e[++ec]={eh[u],v,w},eh[u]=ec;
    }
    inline void adde(int u,int v,int w){
        // printf("adde %d %d %d\n",u,v,w);
        ebba(u,v,w),ebba(v,u,0);
    }
    bool bfs(int s){
        memset(dep+1,0,nc*sizeof(int));
        vector<int> q={s};
        dep[s]=1,crt[s]=eh[s];
        for(unsigned i{0};i<q.size();++i){
            int u{q[i]};
            for(int j{eh[u]};j;j=e[j].nxt){
                int v{e[j].to},w{e[j].w};
                if(dep[v]||!w) continue;
                dep[v]=dep[u]+1,crt[v]=eh[v];
                if(v==T) return true;
                q.emplace_back(v);
            }
        }
        return false;
    }
    int dfs(int u,int in=INT_MAX){
        if(u==T) return in;
        int o{0},os{0};
        for(int &i{crt[u]};i;i=e[i].nxt){
            int v{e[i].to},w{e[i].w};
            if(dep[v]!=dep[u]+1||!w) continue;
            o=dfs(v,min(w,in));
            os+=o,in-=o,e[i].w-=o,e[i^1].w+=o;
            if(!in) break;
        }
        if(!os) dep[u]=0;
        return os;
    }
    inline int dinic(){
        int s{0};
        while(bfs(S)) s+=dfs(S);
        return s;
    }
}flow;
int main(){
    int tc; scanf("%d",&tc);
    while(tc--){
        cin>>n>>m;
        for(int i{0};i<n;++i) cin>>cho0[i];
        for(int i{0};i<m;++i) cin>>cho0[i+n];
        for(int i{0};i<n;++i) scanf("%s",a[i]);
        for(int i{0};i<n;++i){
            string buf{""};
            str[i].clear();
            for(int j{0};j<=m;++j){
                if(isalpha(a[i][j])) buf+=a[i][j];
                else{
                    if(!buf.empty()) str[i].emplace_back(buf),buf="";
                }
            }
        }
        for(int i{0};i<m;++i){
            string buf{""};
            str[n+i].clear();
            for(int j{0};j<=n;++j){
                if(isalpha(a[j][i])) buf+=a[j][i];
                else{
                    if(!buf.empty()) str[n+i].emplace_back(buf),buf="";
                }
            }
        }
        n+=m;
        __gnu_pbds::gp_hash_table<string,vector<int> > all; 
        int ans{0};
        for(int i{0};i<n;++i){
            rev[i]=false;
            for(const auto &s:str[i]) if(s>reversed(s)){rev[i]=true;break;}
            if(rev[i]){
                cho0[i]=-cho0[i];
                for(auto &s:str[i]) reverse(s.begin(),s.end());
            }
            for(const auto &s:str[i])
                all[s].emplace_back(i);
        }
        flow.clear();
        flow.S=flow.newn(),
        flow.T=flow.newn();
        for(int i{0};i<n;++i){
            P[i]=flow.newn();
            if(cho0[i]==+1) flow.adde(flow.S,P[i],INF);
            if(cho0[i]==-1) flow.adde(P[i],flow.T,INF);
        }
        for(const auto &pr:all){
            if(pr.first==reversed(pr.first)){
                ++ans;
                continue;
            }
            ans-=2;
            int X=flow.newn(),Y=flow.newn();
            flow.adde(flow.S,X,2);
            flow.adde(Y,flow.T,2);
            for(int j:pr.second){
                flow.adde(X,P[j],INF);
                flow.adde(P[j],Y,INF);
            }
        }
        int fl=flow.dinic();
        ans+=fl;
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：xiaolilsq (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P4076)

[值得尝试一波看一看是不是更好的阅读体验。](https://www.cnblogs.com/lsq147/p/13864313.html)

## 题目分析

发现数据范围很小，考虑使用网络流。

首先，对于回文串单词，无论正着读还是反着读都要对答案贡献一，所以先处理所有回文串单词，然后再删除这些回文串单词去考虑其他单词。有了回文串，那么一个单词的字典序要么严格大于它的反串要么严格小于它的反串。

将某个单词和它的反串一起考虑，如果这个单词和其反串都出现了，那么会对答案有 2 的贡献，这启发我们使用最小割，不妨假设这个单词的字典序严格小于它的反串，那么我们认为这个单词出现在了最终的字典中当且仅当源点 $S$ 可以到达这个单词，其反串出现在了最终的字典中当且仅当这个单词可以到达汇点 $T$ ，然后这个单词和其反串有一条流量为 2 的边，由此建图可以得到如果这个单词和其反串同时出现就必须要割掉这两个点之间的边，产生 2 的贡献。

按照上面的思路建出来的图大概是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/qsswwnfk.png)

考虑如何用给定的矩阵去限制这些点和源点 $S$ 汇点 $T$ 之间的连通性。考虑到题目保证从某一个位置去看得到的单词要么字典序严格小于反串要么严格大于反串，所以某一行或者列从某个方向看相当于是让某些在上面的点和 $S$ 连通或者是让某些在下面的点和 $T$ 连通。

某一行要么从左往右看要么从右往左看，不妨假设从左往右看得到的单词的字典序都严格小于其反串，可以使用一个经典模型，给每个要求建一个节点，然后 $S$ 直接和这个节点连边，这个节点和 $T$ 直接连边，我们钦定如果这个要求和 $S$ 的连边没有被割断，那么表示它从左往右看，否则表示它从右往左看，然后我们就可以根据这个钦定的方法去给要求节点和单词连边了，为了保证要求节点只会割断一边，可以给这个流量设置一个极大值 $x$ ，假如一个要求没有确定究竟是从左看还是从右看，那么必然需要割掉一个位置，此时就要给答案额外减掉一个 $x$ 。

举个例子吧，最后建出来的图大概是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/siwmjqg9.png)

解释一下这张图是什么意思：设 1,3,5 号节点分别表示单词 `AB` `CD` `EF` ，那么 2,4,6 号节点分别表示单词 `BA` `DC` `FE` ，那么 7 号节点从左往右看的单词就是 `AB,EF` ， 8 号节点从左往右看的单词就是 `CD` ， 9 号节点从左往右看的单词就是 `AB` ，其中 7 号节点要求必须从左往右看， 8 号节点要求必须从右往左看， 9 号节点任意，那么我们建出来的图就是上面的样子，可以看出来，上面的图只需要割断 9 和汇点 T 连着的边就行了。

## 参考代码

```cpp
#include<set>
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ch() getchar()
#define pc(x) putchar(x)
#define inf 10000
#define INF 1000000000
using namespace std;
template<typename T>void read(T&x){
	static char c;static int f;
	for(c=ch(),f=1;c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c>='0'&&c<='9';c=ch())x=x*10+(c&15);x*=f;
}
template<typename T>void write(T x){
	static char q[65];int cnt=0;
	if(x<0)pc('-'),x=-x;
	q[++cnt]=x%10,x/=10;
	while(x)
		q[++cnt]=x%10,x/=10;
	while(cnt)pc(q[cnt--]+'0');
}
const int maxn=10005,maxm=1000005;
struct Edge{
	int v,w,nt;
	Edge(int v=0,int w=0,int nt=0):
		v(v),w(w),nt(nt){}
}e[maxm];
int hd[maxn],num=1;
void qwq(int u,int v,int w){
	e[++num]=Edge(v,w,hd[u]),hd[u]=num;
}
void qvq(int u,int v,int w){
	qwq(u,v,w);qwq(v,u,0);
}
int tot,S=0,T=1,dis[maxn],q[maxn];
int bfs(void){
	memset(dis,0,(tot+1)*4);
	int fro=0,bac=0;dis[q[bac++]=S]=1;
	while(fro<bac){
		int u=q[fro++];
		for(int i=hd[u];i;i=e[i].nt){
			int v=e[i].v,w=e[i].w;
			if(w&&!dis[v])
				dis[q[bac++]=v]=dis[u]+1;
		}
	}
	return dis[T];
}
int cur[maxn];
int dfs(int u,int ep){
	if(u==T)return ep;int re=0;
	for(int&i=cur[u];i;i=e[i].nt){
		int v=e[i].v,w=e[i].w;
		if(w&&dis[v]==dis[u]+1){
			int tmp=dfs(v,min(ep,w));
			re+=tmp;ep-=tmp;
			e[i^1].w+=tmp;e[i].w-=tmp;
			if(!ep)break;
		}
	}
	return re;
}
int dinic(void){
	int re=0;
	while(bfs()){
		memcpy(cur,hd,(tot+1)*4);
		re+=dfs(S,INF);
	}
	return re;
}
string ReVerSe(string s){
	string re="";int len=s.length();
	for(int i=0;i<len;++i)re=s[i]+re;
	return re;
}
set<string>s;
map<string,int>sp;
int row[80],col[80],rvr[80],rvc[80];
char mp[80][80];
int main(){
	int test;read(test);
	while(test--){
		int n,m;
		read(n),read(m);
		for(int i=1;i<=n;++i)read(row[i]);
		for(int i=1;i<=m;++i)read(col[i]);
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				char c=ch();
				while(c!='_'&&(c<'A'||c>'Z'))c=ch();
				mp[i][j]=c;
			}
		}
		s.clear();sp.clear();
		for(int i=1;i<=n;++i){
			rvr[i]=true;
			mp[i][m+1]='_';
			string str="";
			for(int j=1;j<=m+1;++j){
				if(mp[i][j]=='_'){
					if(str!=""){
						string rts=ReVerSe(str);rvr[i]&=(rts<=str);
						s.insert(str),s.insert(rts);
					}
					str="";
				}
				else str=str+mp[i][j];
			}
		}
		for(int j=1;j<=m;++j){
			rvc[j]=true;
			mp[n+1][j]='_';
			string str="";
			for(int i=1;i<=n+1;++i){
				if(mp[i][j]=='_'){
					if(str!=""){
						string rts=ReVerSe(str);rvc[j]&=(rts<=str);
						s.insert(str),s.insert(rts);
					}
					str="";
				}
				else str=str+mp[i][j];
			}
		}
		tot=1;int ans=0;
		memset(hd,0,sizeof hd);num=1;
		for(set<string>::iterator it=s.begin();it!=s.end();++it){
			string abc=*it,cba=ReVerSe(abc);
			if(abc==cba)++ans;
			else if(abc<cba&&s.find(cba)!=s.end()){
				sp[abc]=++tot;sp[cba]=++tot;
				qvq(tot-1,tot,2);
			}
		}
		for(int i=1;i<=n;++i){
			++tot;
			if(!row[i])/*continue*/;
			else if((row[i]==1)^(rvr[i]))
				qvq(S,tot,inf);
			else
				qvq(tot,T,inf);
			string str="";
			for(int j=1;j<=m+1;++j){
				if(mp[i][j]=='_'){
					if(str!=""&&sp.find(str)!=sp.end()){
						string rts=ReVerSe(str);if(rts<str)swap(rts,str);
						qvq(tot,sp[str],inf),qvq(sp[rts],tot,inf);
					}
					str="";
				}
				else str=str+mp[i][j];
			}
		}
		for(int j=1;j<=m;++j){
			++tot;
			if(!col[j])/*continue*/;
			else if((col[j]==1)^(rvc[j]))
				qvq(S,tot,inf);
			else
				qvq(tot,T,inf);
			string str="";
			for(int i=1;i<=n+1;++i){
				if(mp[i][j]=='_'){
					if(str!=""&&sp.find(str)!=sp.end()){
						string rts=ReVerSe(str);if(rts<str)swap(rts,str);
						qvq(tot,sp[str],inf),qvq(sp[rts],tot,inf);
					}
					str="";
				}
				else str=str+mp[i][j];
			}
		}
		write(dinic()+ans),pc('\n');
	}
	return 0;
}
```


---

## 作者：卖淫翁 (赞：1)

```
#include<map>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
# define ull unsigned long long
const int N = 80 ;
const int M = 3005 ;
const ull Base = 233 ;
const int INF = 1e8 ;
using namespace std ;
inline int read() {
    char c = getchar() ; int x = 0 , w = 1 ;
    while(c>'9'||c<'0') { if(c=='-') w = -1 ; c = getchar() ; }
    while(c>='0'&&c<='9') { x = x*10+c-'0' ; c = getchar() ; }
    return x*w ;
}

char s[N][N] ;
int n , m , S , T ;
int ans , cnt , num = 1 ;
int dirh[N] , dirl[N] , hea[M] ;
int hnum[N] , lnum[N] , d[M] ;
int hw[2][N][N] , lw[2][N][N] , isbig[M] ;
ull pw[N] , hsh1[N] , hsh2[N] ;
map < ull , int > p , hap ;

struct E {
    int nxt , to , dis ;
} edge[M * 20] ; 
inline void Insert_edge(int from , int to , int dis) {
    edge[++num].nxt = hea[from] ; edge[num].to = to ;
    edge[num].dis = dis ; hea[from] = num ;
}
inline void add_edge(int u , int v , int w) {
    Insert_edge(u , v , w) ;
    Insert_edge(v , u , 0) ;
}
inline void Clear() {
    ans = 0 ; cnt = 0 ; num = 1 ;
    memset(isbig , false , sizeof(isbig)) ;
    memset(hea , 0 , sizeof(hea)) ;
    memset(hnum , 0 , sizeof(hnum)) ;
    memset(lnum , 0 , sizeof(lnum)) ;
    p.clear() ; hap.clear() ;
}

inline bool Bfs() {
    queue < int > q ; q.push(S) ;
    memset(d , 0 , sizeof(d)) ; d[S] = 1 ;
    while(!q.empty()) {
        int u = q.front() ; q.pop() ;
        for(int i = hea[u] ; i ; i = edge[i].nxt) {
            int v = edge[i].to ;
            if(!d[v] && edge[i].dis > 0) {
                d[v] = d[u] + 1 ;
                q.push(v) ;
            }
        }
    }
    return d[T] ;
}
int Dfs(int u , int dis) {
    if(u == T || !dis) return dis ; 
    int Sum = 0 ;
    for(int i = hea[u] ; i ; i = edge[i].nxt) {
        int v = edge[i].to ;
        if(d[v] == d[u] + 1 && edge[i].dis > 0) {
            int diss = Dfs(v , min(dis , edge[i].dis)) ;
            if(diss > 0) {
                edge[i].dis -= diss ; edge[i ^ 1].dis += diss ;
                dis -= diss ; Sum += diss ; if(!dis) break ;
            }
        }
    }
    if(!Sum) d[u] = -1 ; 
    return Sum ;
}
inline void dinic() {
    while(Bfs()) 
        ans += Dfs(S , INF) ;
}
int main() {
    int Case = read() ;
    pw[0] = 1 ; for(int i = 1 ; i <= 75 ; i ++) pw[i] = pw[i - 1] * Base ;
    while(Case --) {
        Clear() ;
        n = read() ; m = read() ;
        for(int i = 1 ; i <= n ; i ++) dirh[i] = read() ;
        for(int i = 1 ; i <= m ; i ++) dirl[i] = read() ;
        for(int i = 1 ; i <= n ; i ++) {
            scanf("%s",s[i] + 1) ;
            for(int j = 1 ; j <= m ; j ++)
                hsh1[j] = hsh1[j - 1] * Base + s[i][j] ;
            for(int j = m ; j >= 1 ; j --)
                hsh2[j] = hsh2[j + 1] * Base + s[i][j] ;
            int lst = 1 ; ull tp1 , tp2 ;
            for(int j = 1 , l , r  ; j <= m ; j ++) {
                if(s[i][j] == '_' || j == m) {
                    l = lst , r = j - 1 ; lst = j + 1 ;
                    if(s[i][j] != '_') ++ r ; if(l > r) continue ;
                    tp1 = hsh1[r] - hsh1[l - 1] * pw[r - l + 1] ;
                    tp2 = hsh2[l] - hsh2[r + 1] * pw[r - l + 1] ;
                    if(tp1 == tp2) {
                        if(hap[tp1]) continue ; 
                        ++ ans ; hap[tp1] = 1 ; continue ;
                    }
                    if(!p[tp1]) {
                        int vit1 = 1 ;
                        for(int k = 1 ; k <= r - l + 1 ; k ++) {
                            if(s[i][l + k - 1] > s[i][r - k + 1]) break ;
                            else if(s[i][l + k - 1] < s[i][r - k + 1]) {
                                vit1 = -1 ;
                                break ;
                            }
                        }
                        p[tp1] = ++ cnt ; isbig[cnt] = vit1 ;
                        p[tp2] = ++ cnt ; isbig[cnt] = - vit1 ;
                    }
                    hw[0][i][++hnum[i]] = p[tp1] ; hw[1][i][hnum[i]] = p[tp2] ;
                }
            }
        }
        for(int j = 1 ; j <= m ; j ++) {
            for(int i = 1 ; i <= n ; i ++)
                hsh1[i] = hsh1[i - 1] * Base + s[i][j] ;
            for(int i = n ; i >= 1 ; i --)
                hsh2[i] = hsh2[i + 1] * Base + s[i][j] ;
            int lst = 1 ; ull tp1 , tp2 ;
            for(int i = 1 , l , r ; i <= n ; i ++) {
                if(s[i][j] == '_' || i == n) {
                    l = lst , r = i - 1 ; lst = i + 1 ;
                    if(s[i][j] != '_') ++ r ; if(l > r) continue ;
                    tp1 = hsh1[r] - hsh1[l - 1] * pw[r - l + 1] ;
                    tp2 = hsh2[l] - hsh2[r + 1] * pw[r - l + 1] ;
                    if(tp1 == tp2) {
                        if(hap[tp1]) continue ;
                        ++ ans ; hap[tp1] = 1 ; continue ;
                    }
                    if(!p[tp1]) {
                        int vit1 = 1 ;
                        for(int k = 1 ; k <= r - l + 1 ; k ++) {
                            if(s[l + k - 1][j] > s[r - k + 1][j]) break ;
                            else if(s[l + k - 1][j] < s[r - k + 1][j]) {
                                vit1 = -1 ;
                                break ;
                            }
                        }
                        p[tp1] = ++ cnt ; isbig[cnt] = vit1 ;
                        p[tp2] = ++ cnt ; isbig[cnt] = -vit1 ;
                    }
                    lw[0][j][++lnum[j]] = p[tp1] ; lw[1][j][lnum[j]] = p[tp2] ;
                }
            }
        }
        S = 0 , T = cnt + n + m + 1 ;
        for(int i = 1 , x , y ; i <= cnt ; i += 2) {
            x = i ; y = i + 1 ;
            if(isbig[x] == 1) swap(x , y) ;
            add_edge(x , y , 2) ;
        }
        for(int i = 1 ; i <= n ; i ++) {
            if(!hnum[i]) continue ;
            if((dirh[i] == 1 && isbig[hw[0][i][1]] < 0) || (dirh[i] == -1 && isbig[hw[1][i][1]] < 0)) {
                add_edge(S , cnt + i , INF) ;
                for(int j = 1 ; j <= hnum[i] ; j ++) {
                    if(dirh[i] == 1) add_edge(cnt + i , hw[0][i][j] , INF) ;
                    else add_edge(cnt + i , hw[1][i][j] , INF) ;
                }
            }
            else if((dirh[i] == 1 && isbig[hw[0][i][1]] > 0) || (dirh[i] == -1 && isbig[hw[1][i][1]] > 0)) {
                add_edge(cnt + i , T , INF) ;
                for(int j = 1 ; j <= hnum[i] ; j ++) {
                    if(dirh[i] == 1) add_edge(hw[0][i][j] , cnt + i , INF) ;
                    else add_edge(hw[1][i][j] , cnt + i , INF) ;
                }
            }
            else {
                for(int j = 1 , x , y ; j <= hnum[i] ; j ++) {
                    x = hw[0][i][j] , y = hw[1][i][j] ;
                    if(isbig[x] > 0) swap(x , y) ;
                    add_edge(cnt + i , x , INF) ;
                    add_edge(y , cnt + i , INF) ;
                }
            }
        }
        for(int i = 1 ; i <= m ; i ++) {
            if(!lnum[i]) continue ;
            if((dirl[i] == 1 && isbig[lw[0][i][1]] <= 0) || (dirl[i] == -1 && isbig[lw[1][i][1]] <= 0)) {
                add_edge(S , cnt + n + i , INF) ;
                for(int j = 1 ; j <= lnum[i] ; j ++) {
                    if(dirl[i] == 1) add_edge(cnt + n + i , lw[0][i][j] , INF) ;
                    else add_edge(cnt + n + i , lw[1][i][j] , INF) ;
                }
            }
            else if((dirl[i] == 1 && isbig[lw[0][i][1]] >= 0) || (dirl[i] == -1 && isbig[lw[1][i][1]] >= 0)) {
                add_edge(cnt + n + i , T , INF) ;
                for(int j = 1 ; j <= lnum[i] ; j ++) {
                    if(dirl[i] == 1) add_edge(lw[0][i][j] , cnt + n + i , INF) ;
                    else add_edge(lw[1][i][j] , cnt + n + i , INF) ;
                }
            }
            else {
                for(int j = 1 , x , y ; j <= lnum[i] ; j ++) {
                    x = lw[0][i][j] , y = lw[1][i][j] ;
                    if(isbig[x] > 0) swap(x , y) ;
                    add_edge(cnt + n + i , x , INF) ;
                    add_edge(y , cnt + n + i , INF) ;
                }
            }
        }
        
        dinic() ;
        printf("%d\n",ans) ;
    }
    return 0 ;
}
```
```
最小割

好久不写网络流现在我的网络流水平真低==
然后想了想似乎dpdp并不容易记录状态,那就应该是一个网络流了
发现要求正着倒着都存在的单词的对数最小
那么要不是个费用流,要不就是最小割，要不就是反面计数了
然后分析搜题解一下觉得应该是最小割
最小割连的一条边就表示把ta们分在不同集合的代价
那么可以发现回文串无论怎么翻转贡献都是1
所以不考虑回文串
然后考虑其他的单词
对于一个单词,如果这个单词和翻转后的这个单词同时出现那么就会产生2的贡献
所以我们对于每对单词,字典序小的往字典序大的单词连一条边权为2的边
然后再考虑读法的问题
可以发现行列没啥关系,所以相同方法考虑即可
如果给定读法是从左往右且这样读的单词字典序比倒着读小
那么就从SS往该行连一条INFINF的边，然后这行向从左往右读的这行的单词连一条INFINF的边
如果给定读法是从左往右且这样读的单词字典序比倒着读大
那么就从这一行从左往右读的单词往这一行连一条INFINF的边,这行往TT连一条INFINF的边
这样在跑最大流的时候如果一种单词的字典序较小的部分有流量流入就说明读出了这个单词
如果一种单词的字典序较大的部分有流量流入同样也说明读出了这个单词
那么这样就要割掉这条连着两个单词的边产生22的代价
从右往左读也是同理的
那么问题就是如果ta不给定你读法应该怎么办?
也就是说ta可以正着读也可以反着读
那么就同时连ta正着读的边和反着读的边
但是不连S,TS,T到ta的边
这样跑一边最大流然后加上回文串就是答案了
```

---


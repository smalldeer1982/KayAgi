# [HEOI2013] 钙铁锌硒维生素

## 题目描述

银河队选手名单出来了！小林，作为特聘的营养师，将负责银河队选手参加宇宙比赛的饮食。

众所周知，前往宇宙的某个星球，通常要花费好长好长的时间，人体情况在这之间会发生变化，因此，需要根据每天的情况搭配伙食，来保证营养。

小林把人体需要的营养分成了 $n$ 种，这些营养包括但不限于铁，钙。他准备 了 $2$ 套厨师机器人，一套厨师机器人有 $n$ 个，每个厨师机器人只会做一道菜，这道菜一斤能提供第 $i$ 种营养 $x_i$ 微克。想要吃这道菜的时候，只要输入一个数，就 能吃到对应数量的这道菜了。为防止摄入过量对身体造成的伤害，每个机器人还有防过量摄入药，只要输入一个数，就能生成一定剂量的药，吃了这些药，就能 减少相当于食用对应数目的这道菜提供的营养。

小林之所以准备 $2$ 套厨师机器人，正是因为旅途漫漫，难以预计，也许某一 个厨师机器人在途中坏掉，要是影响了银河队选手的身体，就不好了。因此，第 $2$ 套厨师机器人被用来做第 $1$ 套的备用。小林需要为每一个第 $1$ 套厨师机器人选 一个第 $2$ 套厨师机器人作备份，使得当这个机器人坏掉时，用备份顶替，整套厨师机器人仍然能搭配出任何营养需求，而且，每个第 $2$ 套厨师机器人只能当一个第 $1$ 套厨师机器人的备份。


## 说明/提示

- 对于 $10\%$ 的数据，$n = 2$；
- 对于 $20\%$ 的数据，$n \leq 10$；
- 对于 $40\%$ 的数据，$n \leq 30$；
- 对于 $60\%$ 的数据，$n \leq 50$；
- 对于 $80\%$ 的数据，$n \leq 100$；
- 对于 $100\%$ 的数据，$1 \leq n \leq 300$，所有出现的整数均非负，且不超过 $10\,000$。

## 样例 #1

### 输入

```
3 
1 0 0 
0 1 0 
0 0 1 
2 3 0 
0 7 8 
0 0 9```

### 输出

```
TAK 
1 
2 
3```

## 样例 #2

### 输入

```
4 
2 0 1 3 
0 1 0 4 
1 9 9 4 
0 4 1 7 
1 10 9 8 
1 13 10 11 
1 2 1 5 
2 1 1 7```

### 输出

```
TAK 
3 
4 
1 
2```

# 题解

## 作者：cyffff (赞：9)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4100)

$\text{Update2023.4.13}$：修复一个错误。
## 题意
给 $n$ 个线性无关的向量集 $A_1,A_2\cdot\cdot\cdot A_n$ 和一个向量集 $B_1,B_2\cdot\cdot\cdot B_n$，求字典序最小的排列 $p$ 使得将任意的一个 $A_i$ 替换为 $B_{p_i}$ 后，新的向量集依然线性无关。

$n\le300$。
## 思路
先介绍一下基础知识，会的可以跳过这一段。

**线性组合**：设在域 $P$ 中有向量集 $A_1,A_2\cdot\cdot\cdot A_n$，若有向量 $B=\sum_{i=1}^n k_iA_i$，其中 $k\in P$，则 $B$ 是向量集 $A$ 的一个线性组合。

**线性相关，线性无关**：设在域 $P$ 中有向量集 $A_1,A_2\cdot\cdot\cdot A_{n}$，若有一向量 $A_x$ 为剩余 $n-1$ 个向量的线性组合，则称这 $n$ 个向量线性相关；反之，则称这 $n$ 个向量线性无关。

**定理** 若有 $n$ 维向量集 $A_1,A_2\cdot\cdot\cdot A_{n}$ 线性无关，则所有 $n$ 维向量都可表示为其线性组合。

即 $n$ 元 $1$ 次方程组，有 $n$ 个方程，可解出唯一解 $k_1,k_2\cdot\cdot\cdot k_n$。

回到这题，我们构建矩阵：

$A=\begin{bmatrix}A_1,A_2,\cdot \cdot \cdot A_n\end{bmatrix},B=\begin{bmatrix}B_1,B_2,\cdot \cdot \cdot B_n\end{bmatrix}$。

由于 $B_{i,j}=\sum_{k=1}^n R_{i,k}A_{k,j}$，我们可以把转换系数 $R$ 也看做矩阵，则有 $B=RA$，$R=BA^{-1}$。

此时若 $R_{i,j}\ne0$，则 $A_i$ 可以转为 $B_j$；反之则不能，因为 $R_{i,j}=0$ 时，$B_j$ 是 $A_1\cdot\cdot\cdot A_{i-1}A_{i+1}\cdot\cdot\cdot A_n$ 的线性组合。

那么当 $R_{i,j}\ne0$ 时，由 $i$ 向 $j$ 连边建立二分图。

剩余的问题就是二分图最小字典序完美匹配。可以先跑出一组匹配，再使字典序最小。

则在原匹配中有一条增广路径的环上有边 $(u,v)$ 时 $(u,v)$ 的匹配合法，于是找到最小的环即可。

时间复杂度 $O(n^3)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=300+10; 
const double eps=1e-7;
int n;
struct Matrix{
	double a[N][N];
	inline double* operator[](const int &x){
		return a[x];
	}
	Matrix(){
		memset(a,0,sizeof(a));
	}
	inline void epsilon(){
		for(int i=1;i<=n;i++)
			a[i][i]=1;
	}
	inline friend Matrix operator*(const Matrix &a,const Matrix &b){
		Matrix c;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				for(int k=1;k<=n;k++)
					c[i][j]+=a.a[i][j]*b.a[j][k]; 
		return c;
	}
	inline void swapp(int i,int j){
		swap(a[i],a[j]);
	}
}a,b,r;
int match[N];
bool vis[N];
inline bool dfs(int x){
	for(int t=1;t<=n;t++){
		if(!vis[t]&&fabs(r[x][t])>eps){
			vis[t]=true;
			if(!match[t]||dfs(match[t])){
				match[t]=x;
				return true;
			}
		}
	}
	return false;
}
inline int dfs(int x,int tp){
	for(int t=1;t<=n;t++){
		if(!vis[t]&&fabs(r[x][t])>eps){
			vis[t]=true;
			if(match[t]==tp||(match[t]>tp&&dfs(match[t],tp))){
				match[t]=x;
				return t;
			}
		}
	}
	return 0;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			a[j][i]=(double)read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			b[j][i]=(double)read();
	r.epsilon();
	for(int i=1;i<=n;i++){
		int k=i;
		for(int j=i+1;j<=n;j++)
			if(fabs(a[j][i])>fabs(a[k][i]))
				k=j;
		if(fabs(a[k][i])<eps){
			puts("NIE");
			return 0;
		}
		if(k!=i)
			a.swapp(i,k),
			b.swapp(i,k);
		double x=a[i][i];
		for(int j=1;j<=n;j++){
			a[i][j]/=x,b[i][j]/=x;
		}
		for(int j=1;j<=n;j++)
			if(i!=j){
				double res=a[j][i];
				for(int k=1;k<=n;k++)
					a[j][k]-=a[i][k]*res,
					b[j][k]-=b[i][k]*res;
			}
	}
	r=b;
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		if(!dfs(i))
			return puts("NIE"),0;
	}
	puts("TAK");
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		write(dfs(i,i)),putc('\n');
	}
	flush();
}
```
再见 qwq~

---

## 作者：cosmicAC (赞：7)

题意：给定n个线性无关的向量`A[1..n]`(如果不是线性无关直接输出无解即可),另外n个向量`B[1..n]`，求能否给A中的每一个向量选择一个B中的备用向量，使得任意两个备用向量在B中编号不同，且A中的一个向量的备用向量和A中其余向量线性无关。

显然可以先对A中的每一个向量确定哪些向量可以备用，然后跑一个二分图最小字典序完美匹配即可。没有完美匹配则无解。

首先可以考虑一个系数矩阵V,`V[i][j]`表示“B中第i个向量用A的线性组合表示时，A[j]项的系数”。容易证明`A[i]`可以使用`B[j]`作为备用向量当且仅当$V_{ji}\ne 0$。（如果$V_{ji}=0$,`B[j]`是A中其余向量的线性组合；否则可以移一下项把A[i]用B[j]表示）

可以写出一个等式：$$B_{ij}=\sum_{k=1}^n{V_{ik}A_{kj}}$$即$$B=VA;V=BA^{-1}$$
所以矩阵求逆即可。不会矩阵求逆可以看[我的博客](https://www.luogu.org/blog/474D/solution-p4783)

但是这里不会矩阵求逆也没有关系。可以在把A和B拼成一个`2n*n`的矩阵（还是叫矩阵A），高斯消元的同时维护一下当前的`A[i]`由初始的`A[1..n]`线性组合表示的各项系数。复杂度还是$O(n^3)$。（也许这个算法本质上就是伴随矩阵？）

然后需要求二分图最小字典序完美匹配。我一开始觉得先跑一个Dinic，然后退流就行了，但是退流好像不能凭空加入一条新的匹配边。所以我最后写了一个类似匈牙利的方法，维护当前哪些点的匹配已经被固定了，找到一条不经过已固定的点的交错路（这里其实是一个环），然后增广。复杂度仍然是$O(n^3)$，实际跑的飞快。

C++11代码：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int n,vis[610];
double a[610][310],b[610][310],sm[610];
struct Dinic{
    struct edge{int v,cap;};
    vector<edge> e,e1;
    vector<int> v[610];
    int dis[610],cur[610],que[610],f[610],s,t;
    void addEdge(int x,int y){
        e.insert(e.end(),{{y,1},{x}});
        v[x].push_back(e.size()-2);
        v[y].push_back(e.size()-1);
    }
    int bfs(int s,int t){
        int l=1,r=1;
        memset(dis,0x3f,sizeof dis);
        que[1]=s;dis[s]=0;
        while(l<=r){
            int p=que[l++];
            for(int i:v[p])if(e[i].cap && !vis[e[i].v] && dis[e[i].v]>1e9)
                f[e[i].v]=i^1,dis[e[i].v]=dis[p]+1,que[++r]=e[i].v;
        }
        return dis[t]<1e9;
    }
    void wtf(int x,int y){
        for(int p=x;p!=y;p=e[f[p]].v)e[f[p]].cap=1,e[f[p]^1].cap=0;
    }
    int dfs(int p,int a){
        if(p==t || !a)return a;
        int f,to,fl=0;
        for(int&i=cur[p];i<(int)v[p].size();++i){
            edge &E=e[v[p][i]];
            if(dis[to=E.v]==dis[p]+1 && (f=dfs(to,min(a,E.cap)))){
                fl+=f,a-=f,e[v[p][i]^1].cap+=f,E.cap-=f;
                if(!a)break;
            }
        }
        return fl;
    }
    int dinic(int s,int t){
        this->s=s,this->t=t;
        int f=0;
        while(bfs(s,t))
            memset(cur,0,sizeof cur),f+=dfs(s,1e9);
        return f;
    }
}sol;
int main(){
    scanf("%d",&n);
    for(int i=0;i<2*n;i++)
        for(int j=0;j<n;j++)
            scanf("%lf",a[i]+j);
    for(int i=0;i<n;i++)
        b[i][i]=1,sol.addEdge(2*n,i),sol.addEdge(i+n,2*n+1);
    for(int i=0;i<n;i++){
        double mx=-1;int mp;
        for(int j=0;j<2*n;j++)if(!vis[j]){
            sm[j]=0;
            for(int k=0;k<n;k++)
                sm[j]+=b[j][k]*a[k][i];
            if(j<n){if(fabs(sm[j])>mx)mx=fabs(sm[j]),mp=j;}
            else sm[j]+=a[j][i];
        }
        if(mx<1e-10){puts("NIE");return 0;}
        vis[mp]=1;
        for(int j=0;j<2*n;j++)if(!vis[j] && fabs(sm[j])>1e-10)
            for(int k=0;k<n;k++)
                b[j][k]-=b[mp][k]*sm[j]/sm[mp];
    }
    for(int i=n;i<2*n;i++)
        for(int j=0;j<n;j++)if(fabs(b[i][j])>1e-10)
            sol.addEdge(j,i);
    memset(vis,0,sizeof vis);
    if(sol.dinic(2*n,2*n+1)<n){puts("NIE");return 0;}
    puts("TAK");
    vis[2*n]=1;
    for(int i=0,to;i<n;i++)
        for(int j:sol.v[i])if(!vis[to=sol.e[j].v]&&(!sol.e[j].cap||sol.bfs(to,i))){
            printf("%d\n",to-n+1);vis[to]=1;
            if(sol.e[j].cap)
                sol.wtf(i,to),sol.e[j].cap=0,sol.e[j^1].cap=1;
            break;
        }
    return 0;
}
```

---

## 作者：a___ (赞：5)

题目大意：有 $n$ 个向量 $A_1,A_2,\dots,A_n$，及 $n$ 个向量 $B_1,B_2,\dots,B_n$，求**字典序最小**的**排列** $p$，使得将**某一个** $A_i$ 换成 $B_{p_i}$ 后这 $n$ 个向量线性无关。  

设矩阵 $A=\begin{bmatrix}A_1\\A_2\\\dots\\A_n\end{bmatrix}$，$B=\begin{bmatrix}B_1\\B_2\\\dots\\B_n\end{bmatrix}$，$C_{i,j}$ 表示将 $B_i$ 用 $A_1,A_2,\dots,A_n$ 的线性组合表示时每一项的系数。   

则由定义得 $B_i=\sum_j C_{i,j}A_j \Rightarrow B=CA$，于是 $C=BA^{-1}$。   

显然有 $C_{i,j}\not=0$ 时 $A_j$ 可以用 $B_i$ 替换，否则不行。因为若 $C_{i,j}=0$，那么 $B_i$ 是 $A_1,A_2,\dots,A_{j-1},A_{j+1},\dots,A_n$ 的线性组合，不满足要求。   

____
（以下一段与解题思路无关，仅关乎算法实现，可以先跳过）  

考虑求 $C=BA^{-1}$，我们可以想到让 $A$ 和 $B$ 同时右乘一个 $A^{-1}$，亦即类似矩阵求逆，将 $A$ 高斯消元成单位矩阵 $I$ 时对 $B$ 进行同样操作。  

然而如果你这么做了你会发现这是假的。究其原因，这是因为我们平时写的高斯消元都是做初等行变换（交换两行等），而初等行变换相当于左乘矩阵，所以其实求出了 $A^{-1}B$。  

这时我们可以考虑将高斯消元改成初等列变换，将 $B$ 接到 $A$ 的下面做，由于初等列变换是右乘矩阵，于是求得的就是 $BA^{-1}$ 了。

但是其实我们也可以考虑对 $A,B,C$ 全部转置，重新定义 $A=\begin{bmatrix}A_1&A_2&\dots&A_n\end{bmatrix}$，$B=\begin{bmatrix}B_1&B_2&\dots&B_n\end{bmatrix}$，这样新的 $C=A^{-1}B$。于是就可以直接高斯消元了。而且这时的 $C_{i,j}$ 恰好表示的是 $A_i$ 是否可以替换为 $B_j$，比较符合正常思维。

____
（以下 $C_{i,j}$ 表示 $A_i$ 是否可以替换为 $B_j$）  

既然我们已经求出了 $C_{i,j}$，那么剩下的问题就是求一个从 $A$ 到 $B$ 的字典序最小的二分图满匹配。

首先我们用匈牙利算法先求出任意一个匹配，然后我们考虑怎样使得它字典序最小。

我们从小到大考虑第 $i$ 位上的匹配最小是多少。考虑何时一个匹配 $(u,v)$ 合法。发现当且仅当原满匹配存在一条增广路（显然是个环）包含边 $(u,v)$。于是我们从小到大找这样的最小的一个合法增广路环就是答案。

代码
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
const int N=310;
const double eps=1e-8;
int n,c[N];
double a[N][N],b[N][N];
bool vis[N];
inline void swap(double &x, double &y){double t=x;x=y;y=t;}
int dfs(int u,int t=0)
{
	for(int v=1;v<=n;v++)if(fabs(b[u][v])>eps&&!vis[v])
	{
		vis[v]=true;
		if(c[v]==t||(c[v]>t&&dfs(c[v],t)))return c[v]=u,v;
	}
	return 0;
}
int main()
{
	int i,j,k,mx;double x;scanf("%d",&n);
	for(i=1;i<=n;i++)for(j=1;j<=n;j++)scanf("%lf",&a[j][i]);
	for(i=1;i<=n;i++)for(j=1;j<=n;j++)scanf("%lf",&b[j][i]);
	for(i=1;i<=n;i++)
	{
		mx=i;
		for(j=i+1;j<=n;j++)if(fabs(a[j][i])>fabs(a[mx][i]))mx=j;
		if(fabs(a[mx][i])<=eps)return puts("NIE"),0;
		if(mx!=i)for(j=1;j<=n;j++)swap(a[i][j],a[mx][j]),swap(b[i][j],b[mx][j]);
		for(j=1,x=a[i][i];j<=n;j++)a[i][j]/=x,b[i][j]/=x;
		for(j=1;j<=n;j++)if(j!=i)for(x=a[j][i],k=1;k<=n;k++)
		a[j][k]-=a[i][k]*x,b[j][k]-=b[i][k]*x;
	}
	for(i=1;i<=n;i++)if(memset(vis,0,sizeof vis),!dfs(i))return puts("NIE"),0;
	puts("TAK");for(i=1;i<=n;i++)memset(vis,0,sizeof vis),printf("%d\n",dfs(i,i));
	return 0;
}
```

---

## 作者：Daniel_yuan (赞：2)

#### 题目大意

给出一个正整数 $n$，然后给出 $n$ 个 $A$ 类 $n$ 维向量以及 $n$ 个 $B$ 类 $n$ 维向量，保证 $A$ 类向量之间线性无关。现在需要给每个 $A$ 类向量都从 $B$ 类向量中选择一个备用向量，要求该向量被备用向量替换之后，形成的新的 $n$ 个 $A$ 类向量之间仍然线性无关。任意两个 $A$ 类向量的备用向量都不能相同。请求出是否有解，在有解的情况下求字典序最小的方案。

#### 题解

问题的实质是求出任意两个 $A,B$ 类向量之间能否替换，如果可以就连边，最后跑一个最小字典序的二分图匹配即可。

对于这个题目，因为求的匹配必须是完美匹配，那么就可以先求出一个普通的完美匹配，然后强制让某个点跟一个字典序更小的点匹配，这样子操作的话会造成左右各一个点失配。然后把这个失配点再增广一次，如果可以增广，那么增广之后仍然形成了一个完美匹配，证明这次修改是合法的，否则就不合法。最终就可以求得一个最小字典序的完美匹配。

那么现在就只需要考虑前一个问题。因为 $A$ 类向量之间是线性无关的，所以使用 $A$ 类向量可以唯一表示任意的一个 $n$ 维向量，当然其中也包括所有的 $B$ 类向量。

考虑对于一个 $B$ 类向量 $B_i$，它等于 $k_1A_1+k_2A_2...+k_nA_n$。那么 $B_i$ 可以替换 $A_j$ 当且仅当 $k_j\not=0$。

证明如下：若 $k_j=0$，那么用 $B_i$ 替换 $A_j$ 后，$B_i$ 仍然可以被剩下的向量表示，那么就不是线性无关的，与题意不符。若 $k_j\not= 0$，那么在 $A$ 类向量中删去 $A_j$ 后，剩下的向量无法表示 $B_i$。且通过移项，有 $k_1A_1+k_2A_2+...+k_nA_n-B_i=k_jA_j$，即 $A_j$ 可以被新的 $A$ 类向量表示，那么对于之前 $A$ 类向量表示的任意一个 $n$ 维向量，新的 $A$ 类向量也可以表示，只要把 $k_jA_j$ 按比例换成 $k_1A_1+k_2A_2+...+k_nA_n-B_i$ 即可，故新的 $A$ 类向量是线性无关的。

现在就只需要求怎么用 $A$ 类向量去表示每个 $B$ 类向量了。

我们可以把 $A$ 类向量放到一个矩阵里面去，然后用这个矩阵乘上一个系数矩阵得到一个 $B$ 类向量构成的矩阵。

一般的，我们习惯于把向量竖着放，设系数矩阵为 $R$，$A=[A_1,A_2...A_n]$，$B=[B_1,B_2...B_n]$，那么有 $A\times R=B$。显然， $R$ 的每个列向量 $R_i$ 就是用 $A$ 类向量表示 $B_i$ 的各项系数。

考虑怎么求，因为有 $A\times R=B$，那么可以不断左乘初等矩阵，设其为 $E_1...E_m$，使得 $E_1\times...\times E_m\times A=I$，那么就有 $E_1\times...\times E_m\times A\times R=I\times R=R=E_1\times...\times E_m\times B$。就可以求得 $R$。

说得通俗一点，左乘一个初等矩阵相当于是初等行变换，那么实际上就是把 $A$ 用初等行变换变成 $I$，与此同时把所有对 $A$ 的操作也用到 $B$ 上，就可以得到最终的 $R$。

最终可以在 $O(N^3)$ 的时间复杂度内解决这个问题。

---

## 作者：AzusaCat (赞：1)

给定 $2n$ 个 $n$ 维向量 $\mathbf A_1,\dots,\mathbf A_n$，$\mathbf B_1,\dots,\mathbf B_n$，问是否存在一组匹配，使得任意 $\mathbf A_i$ 被其匹配中对应的 $\mathbf B_{p_i}$ 替换后，新的向量组 $\mathbf A_1,\dots,\mathbf A_n$ 依旧线性无关，输出字典序最小的方案。$n\leqslant 300$。

首先如果 $\mathbf A_1,\dots,\mathbf A_n$ 线性相关直接输出无解。接下来考虑某一个 $\mathbf B_j$ 是否可以替换 $\mathbf A_i$，由于 $\mathbf A_1,\dots,\mathbf A_n$ 线性无关，所以每一个 $\mathbf B_j$ 都可以被唯一的表示为 $\mathbf A_1,\dots,\mathbf A_n$ 的线性组合，设 $C_{i,j}$ 表示 $\mathbf B_i$ 用 $\mathbf A_1,\dots,\mathbf A_n$ 表示时 $\mathbf A_j$ 项的系数，则有：
$$
\begin{pmatrix}
C_{1,1}  & \dots & C_{1,n}\\
\vdots   & \ddots & \vdots\\
C_{n,1}  & \dots & C_{n,n}
\end{pmatrix}

\begin{pmatrix}
\mathbf A_1 \\
\vdots \\
\mathbf A_n
\end{pmatrix}
=
\begin{pmatrix}
\mathbf B_1 \\
\vdots \\
\mathbf B_n
\end{pmatrix}
$$
所以有 $CA=B$，故 $C=BA^{-1}$。注意如果 $C_{i,j}=0$，那么 $\mathbf B_i$ 可以被 $\mathbf A_j$ 以外的元素线性表示出来，所以 $\mathbf B_i$ 不能替换 $\mathbf A_j$；反之可以用 $\mathbf A_1,\dots,\mathbf A_{j-1},\mathbf B_j,\mathbf A_{j+1},\dots,\mathbf A_n$ 的线性组合表示出 $\mathbf A_j$，所以新的向量组一定也线性无关。

这样我们可以建立一个二分图，如果 $C_{i,j}\not=0$，我们就把 $(j,i)$ 连起来，现在我们相当于要求一个字典序最小的完美匹配。

首先我们先求出一个完美匹配 $T$，然后我们考虑是否能强制令某条边被选中，有以下定理：

定理：对于某个不在 $T$ 中的边 $e$，$e$ 能存在某个完美匹配 $T'$ 中，当且仅当原图中存在一个包含 $e$ 的环，且环中的边状态为 “匹配-未匹配-匹配-未匹配...”。

证明：

- 充分性：我们只需要反转这个环所有边的状态，就可以得到一组新的包含 $e$ 的完美匹配。
- 必要性：假设 $e$ 在某个完美匹配 $T'$ 中，令 $S$ 表示 $T$ 和 $T'$ 的对称差，由  $T,T'$ 为完美匹配可知 $S$ 中每个点的度数为 $0/2$，于是 $S$ 必然由若干简单环组成，而不可能出现某个点同时连出了两条状态相同的边，所以 $e$ 一定在形如 “匹配-未匹配-匹配-未匹配...” 的环中。

我们发现找这样的环的操作可以使用一次 dfs 在 $O(n^2)$ 的时间内完成，然后我们从小到大枚举左部点，就可以知道哪些边可以在某个完美匹配中，选择右部点最小的即可。总复杂度 $O(n^3)$。

不知道为啥我的代码有亿点长/kk

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double a[305][305],b[305][305],r[305][305];
template<unsigned N,unsigned M> struct Maxflow
{
    int const inf=1e9;
    int tmp,now,maxflow,s,t,tot=1,target[M],pre[M],last[N],cap[M],deep[N],cur[N],ans[N];
    bool used[M],vis[N],vis2[N],del[N];
    queue<int>q;
    void add(int x,int y,int z)
    {
        target[++tot]=y;
        pre[tot]=last[x];
        last[x]=tot;
        cap[tot]=z;
        target[++tot]=x;
        pre[tot]=last[y];
        last[y]=tot;
    }
    bool bfs()
    {
        for(int i=s;i<=t;i++)deep[i]=0,cur[i]=last[i];
        q.push(s);
        while(!q.empty())
        {
            int now=q.front();
            q.pop();
            for(int i=last[now];i;i=pre[i])
            {
                int tar=target[i];
                if(tar!=s&&cap[i]&&(!deep[tar]))
                    deep[tar]=deep[now]+1,q.push(tar);
            }
        }
        return deep[t];
    }
    int dfs(int x,int lim)
    {
        if((!lim)||x==t)return lim;
        int flow=0;
        for(int i=cur[x];i;cur[x]=i,i=pre[i])
        {
            int tar=target[i];
            if(cap[i]&&deep[tar]==deep[x]+1)
            {
                int d=dfs(tar,min(lim,cap[i]));
                cap[i]-=d;
                cap[i^1]+=d;
                lim-=d;
                flow+=d;
                if(!lim)break;
            }
        }
        return flow;
    }
    void dinic(){while(bfs())maxflow+=dfs(s,inf);}
    void dfs(int x,int fa,bool p)
    {
        vis[x]=1;
        for(int i=last[x];i;i=pre[i])
        {
            int tar=target[i];
            if(del[tar]||tar==fa||used[i>>1]!=(p^1))continue;
            if(tar==now)vis2[x]=1;
            else if(!vis[tar])dfs(tar,x,p^1);
        }
    }
    bool dfs2(int x,int fa,bool p)
    {
        bool res=0;vis[x]=1;
        for(int i=last[x];i;i=pre[i])
        {
            int tar=target[i];
            if(del[tar]||tar==fa||used[i>>1]!=(p^1))continue;
            if(tar==now&&x==tmp)used[i>>1]^=1,res=1;
            else if(!vis[tar])
            {
                bool t=dfs2(tar,x,p^1);
                if(t)res=1,used[i>>1]^=1;
            }
        }
        return res;
    }
    void work()
    {
        puts("TAK");
        for(int i=1;i<=n;i++)
            for(int j=last[i];j;j=pre[j])
                if(target[j]>n&&!cap[j])used[j>>1]=1;
        del[s]=del[t]=1;
        for(int i=1;i<=n;i++)
        {
            memset(vis,0,sizeof(vis));memset(vis2,0,sizeof(vis2));
            now=i;dfs(i,0,0);
            int mn;
            for(int j=last[i];j;j=pre[j])if(used[j>>1]){mn=target[j];break;}
            for(int j=n+1;j<mn;j++)if(vis2[j]){mn=j;break;}
            printf("%d\n",mn-n);
            tmp=mn;
            memset(vis,0,sizeof(vis));
            dfs2(i,0,0);
            del[i]=del[mn]=1;
        }
    }
};
Maxflow<605,200005>g;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%lf",&a[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%lf",&b[i][j]);
    for(int i=1;i<=n;i++)r[i][i]=1;
    for(int i=1;i<=n;i++)
    {
        if(fabs(a[i][i])<1e-7)
            for(int j=i+1;j<=n;j++)
                if(fabs(a[j][i])>1e-7){swap(a[i],a[j]),swap(r[i],r[j]);break;}
        if(fabs(a[i][i])<1e-7){puts("NIE");return 0;}
        double iv=1.0/a[i][i];
        for(int j=1;j<=n;j++)
        {
            if(j==i)continue;
            double t=iv*a[j][i];
            for(int k=1;k<=n;k++)
                a[j][k]=(a[j][k]-t*a[i][k]),
                r[j][k]=(r[j][k]-t*r[i][k]);
        }
    }
    for(int i=1;i<=n;i++)
    {
        double iv=1.0/a[i][i];
        for(int j=1;j<=n;j++)r[i][j]*=iv;
    }
    memset(a,0,sizeof(a));
    for(int i=1;i<=n;i++)
        for(int k=1;k<=n;k++)
            for(int j=1;j<=n;j++)
                a[i][j]+=b[i][k]*r[k][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(fabs(a[i][j])>1e-7)g.add(j,i+n,1);
    g.t=2*n+1;
    for(int i=1;i<=n;i++)g.add(0,i,1),g.add(i+n,g.t,1);
    g.dinic();
    if(g.maxflow<n){puts("NIE");return 0;}
    g.work();
    return 0;
}
```



---


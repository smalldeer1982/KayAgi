# [HEOI2014] 林中路径

## 题目描述

Alice 和 Marisa 都住在一个巨大的由 $N$ 个路口与 $M$ 条单向小道构成的森林中。Marisa 非常喜欢到 Alice 家里去玩，但是 Alice 并不喜欢这位鲁莽的来客。Alice 非常擅长观察， 因此每当她发现 Marisa 走了一条与之前完全相同的路径来到她家时，她就会装作不在家， Marisa 就只好败兴而归。Marisa 发现了这个秘密，因此她决定每次走不同的路径到 Alice 家。

Marisa 体力有限，她不想走超过 K 条边到达 Alice 家，并且，每当她走 $t$（ $t$ $\leq$ $K$ ）条边 到达 Alice 家时，她需要付出 $t^2$ 的体力。Marisa 想知道，在 Alice 无论如何都不想接见她之前（即 Marisa 无法走一条长度不超过 $K$ 的与之前不同的路径），她会消耗多少体力。

现在 Marisa 拿到了一张森林的地图，但因为 Marisa 非常笨，她并不知道自己的家和 Alice 的家在哪一个路口，因此她会给询问你 $Q$ 次，每次询问假如 Marisa 的家的位置在 $S$ 而 Alice 的家的位置在 $T$ 时的答案。

一条路径 $A$ 的定义是指一个长度为 $P$（$P$ 可以为任意正整数或零）的边的序列 $A_{m_0},A_{m_1},A_{m_2},…,A_{m_{T-1}}$，其中对于任意 $1 \leq i ＜ P$，有 $A_{m_{i-1}}$ 的结束节点是 $Am_i$ 的起始节点。

两条路径 $A$ 和 $B$ 完全相同是指两条路径的长度均为 T 并且对任意 $0\leq i＜P$，有 $A_{m_i} = B_{m_i}$。

## 说明/提示

对于 $20\%$ 的数据，$N\leq  5$，$M\leq 10$，$K\leq 3$，$Q\leq 10$。

对于 $40\%$ 的数据，$N\leq  30$，$M\leq 900$，$K\leq 100$，$Q\leq 100$。

对于 $60\%$ 的数据，$N\leq  50$，$M\leq 2,500$，$K\leq 10,000,000$，$Q\leq 1,000$。

对于 $100\%$ 的数据，$2\leq  N\leq 100$，$0\leq M\leq 100,000$，$0\leq K\leq 1,000,000,000$，$0\leq Q\leq 10,000$，$1\leq X,Y,S,T\leq N$。

```cpp
g++ paths.cpp –o paths –Wl,--stack=268435456 –O2 
```
样例一解释 从 $S$ 到 $T$ 不存在路径

 
样例二解释 Marisa 可以重复经过一个路口，即使这个路口就是 Alice 的家或 Marisa 的家


## 样例 #1

### 输入

```
2 0 1 1 
1 2```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2 2 1 
1 2 
2 1 
1 1```

### 输出

```
4```

## 样例 #3

### 输入

```
2 2 100 1 
1 2 
2 1 
1 2```

### 输出

```
166650```

## 样例 #4

### 输入

```
2 3 100 2 
1 2 
1 2 
2 1 
2 2 
2 1```

### 输出

```
632506153
518794755```

# 题解

## 作者：Caro23333 (赞：10)

咕了几天终于来了~

这个题首先看数据范围发现是 $n \le 100$ 的点对之间路径计数，其中带有路径长度的限制，那很明显就跟邻接矩阵的幂脱不了关系，那么主要的难点就在于如何处理路径长度的平方这件事。

大体的思路是递归，先求出 $m = \lfloor \frac{k}{2} \rfloor$ 时的答案，再利用 $m$ 时的答案推出 $k$ 的答案。考虑维护三个矩阵 $A,B,C$ 分别代表当前 **所有路径长度的 $0,1,2$ 次方之和**。

简单起见，这里只讨论 $k$ 为偶数，即 $k=2m$ 时的情况，奇数情况是基本同理的。考虑对于某一个有序点对 $(u,v)$，令 $a_i$ 为从 $u$ 到 $v$ 长度恰为 $i$ 的路径数量，则有：

$$A_{u,v} = \sum_{i=1}^m a_i,\ B_{u,v} = \sum_{i=1}^m ia_i,\ C_{u,v} = \sum_{i=1}^m i^2a_i$$

而对于最长路径限制为 $k=2m$ 时的 $A,B,C$（不妨记为 $A',B',C'$）有：

$$A'_{u,v} = \sum_{i=1}^{2m} a_i = A_{u,v}+\sum_{i=1}^m a_{i+m}$$

$$B'_{u,v} = \sum_{i=1}^{2m} ia_i = B_{u,v}+\sum_{i=1}^m ia_{i+m}+m\sum_{i=1}^m a_{i+m}$$

$$C'_{u,v} = \sum_{i=1}^{2m} i^2a_i = C_{u,v}+\sum_{i=1}^m i^2a_{i+m}+2m\sum_{i=1}^m ia_{i+m}+m^2\sum_{i=1}^m a_{i+m} $$

不妨令原图的邻接矩阵为 $G$。我们所熟知的是，对于任意的 $i$，全体 $a_i$ 到全体 $a_{i+m}$ 的变化是可以用全体 $a_i$ 对应的矩阵乘上 $G^m$ 来刻画的，那么对于 $a_i$ 的前缀和（即 $A$ 到 $A'$ 的变化）其实也是完全相同的。于是对照上式即得：

$$A' = A+A \cdot G^m$$

同理更有

$$B' = B+B \cdot G^m+m \cdot A \cdot G^m$$

$$C' = C+C \cdot G^m+2m \cdot B \cdot G^m+m^2 \cdot A \cdot G^m$$

那么只要在递归过程中记录 $G^m$ 即可。$k$ 为奇数的情况，只要再加上一次 $m=1$ 即可，是完全类似的。复杂度 $O(n^3 \log k + q)$。可能略卡常。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#define mod 1000000007

using namespace std;
typedef long long ll;
const int MAXN = 105; 
inline int readint()
{
	int res = 0, f = 1;
	char c = 0;
	while(!isdigit(c))
	{
		c = getchar();
		if(c=='-')
			f = -1;
	}
	while(isdigit(c))
		res = res*10+c-'0', c = getchar();
	return res*f;
}
int n,m,k,q;
inline int modd(int x)
	{ return x>=mod?x-mod:x; } 
struct Mat
{
	int a[MAXN][MAXN];
	Mat()
		{ memset(a,0,sizeof(a)); } 
	Mat operator+(const Mat t) const
	{
		Mat res;
		for(int i = 1; i<=n; i++)
			for(int j = 1; j<=n; j++)
				res.a[i][j] = modd(a[i][j]+t.a[i][j]);
		return res;
	}
	Mat operator*(const Mat t) const
	{
		Mat res;
		for(int i = 1; i<=n; i++)
			for(int j = 1; j<=n; j++)
				if(t.a[i][j])
					for(int k = 1; k<=n; k++)
						res.a[i][k] = (1ll*res.a[i][k]+1ll*a[j][k]*t.a[i][j])%mod;
		return res; 
	}
	Mat operator*(const int t) const
	{
		Mat res;
		for(int i = 1; i<=n; i++)
			for(int j = 1; j<=n; j++)
				res.a[i][j] = 1ll*a[i][j]*t%mod;
		return res; 
	}
}G,c,ans0,ans1,ans2;
inline Mat unit()
{
	Mat res;
	for(int i = 1; i<=n; i++)
		res.a[i][i] = 1;
	return res;
} 
inline void solve(int t)
{
	if(t==1)
	{
		c = G, ans0 = unit();
		return;
	}
	solve(t/2);
	int x = t/2;
	ans2 = ans2+ans2*c+ans1*c*(2*x)+ans0*c*(1ll*x*x%mod);
	ans1 = ans1+ans1*c+ans0*c*x;
	ans0 = ans0+ans0*c;
	c = c*c;
	if(t&1)
	{
		ans0 = ans0+c;
		ans1 = ans1+c*(t-1);
		ans2 = ans2+c*(1ll*(t-1)*(t-1)%mod);
		c = c*G;
	}
}

int main()
{
	n = readint(), m = readint(), k = readint(), q = readint();
	for(int i = 1; i<=m; i++)
	{
		int u = readint(), v = readint();
		G.a[u][v]++;
	}
	solve(k+1);
	while(q--)
	{
		int x = readint(), y = readint();
		printf("%d\n",ans2.a[x][y]); 
	}
	return 0;
}

```


---

## 作者：guosoun (赞：3)

[博客](https://gzy-blog.pages.dev/posts/p4102-heoi2014-%E6%9E%97%E4%B8%AD%E8%B7%AF%E5%BE%84-%E9%A2%98%E8%A7%A3/)

设 $A[i][j]$ 为从 $i$ 点到 $j$ 点的边的数量。

设：
$$
\begin{aligned}

E_0[L] & = \sum_{i = 1}^LA^i\\
E_1[L] & = \sum_{i = 1}^Li\times A^i\\
E_2[L] & = \sum_{i = 1}^Li^2\times A^i\\

\end{aligned}
$$
答案就是 $E_2[k]$。

考虑用分治求解这三个矩阵。

当 $L$ 是偶数时：
$$
\begin{aligned}

E_0[L] & = \sum_{i = 1}^LA^i\\& = \sum_{i = 1}^{L/2}A^i  +A^{L/2}\times \sum_{i = 1}^{L/2}A^i\\&=E_0[L/2]+A^{L/2}\times E_0[L/2]\\

E_1[L]& = \sum_{i = 1}^Li\times A^i\\ 
& = \sum_{i = 1}^{L/2}i\times A^i+A^{L/2}\times \sum_{i=1}^{L/2}[(i+L/2)\times A^i]\\ &=E_1[L/2]+A^{L/2}\times(\sum_{i=1}^{L/2}i\times A^i+L/2\times\sum_{i=1}^{L/2}A^i)\\
&=E_1[L/2]+A^{L/2}\times(E_1[L/2]+L/2\times E_0[L/2])\\

E_2[L]& = \sum_{i = 1}^Li^2\times A^i\\ 
& = \sum_{i = 1}^{L/2}i^2\times A^i+A^{L/2}\times \sum_{i=1}^{L/2}[(i+L/2)^2\times A^i]\\
& = \sum_{i = 1}^{L/2}i^2\times A^i+A^{L/2}\times \sum_{i=1}^{L/2}[(i^2+2i(L/2)+(L/2)^2\times A^i]\\
&=E_2[L/2]+A^{L/2}\times(\sum_{i=1}^{L/2}i^2\times A^i+L\times\sum_{i=1}^{L/2}i\times A^i+L^2/4\times\sum_{i=1}^{L/2}A^i)\\
&=E_2[L/2]+A^{L/2}\times(E_2[L/2]+L\times E_1[L/2]+L^2/4\times E_0[L/2])\\

\end{aligned}
$$
当 $L$ 是奇数时：
$$
\begin{aligned}

E_0[L] & = \sum_{i = 1}^LA^i\\
&=A+A\times\sum_{i = 1}^{L-1}A^i\\&=A+A\times E_0[L-1]\\
E_1[L] & = \sum_{i = 1}^Li\times A^i\\&
=A+A\times\sum_{i = 1}^{L-1}((i+1)\times A^i)\\
&=A+A\times(\sum_{i = 1}^{L-1}i\times A^i+\sum_{i = 1}^{L-1} A^i)\\
&=A+A\times (E_1[L-1]+E_0[L-1])\\
E_2[L] & = \sum_{i = 1}^Li^2\times A^i\\
&=A+A\times\sum_{i = 1}^{L-1}((i+1)^2\times A^i)\\
&=A+A\times\sum_{i = 1}^{L-1}((i^2+2i+1)\times A^i)\\
&=A+A\times(\sum_{i = 1}^{L-1}i^2\times A^i+2\sum_{i = 1}^{L-1} i\times A^i+\sum_{i = 1}^{L-1} A^i)\\
&=A+A\times (E_2[L-1]+2E_1[L-1]+E_0[L-1])\\

\end{aligned}
$$
时间复杂度 $O(n^3\log{k})$。

代码：

```cpp
#include<bits/stdc++.h>
#define per(x,y,z) for(int x=(y);(x)<=(z);++(x))
#define ll long long
using namespace std;
const int N=110,p=1e9+7;
int n,m,k,q;
struct mx{ll s[N][N];mx(){memset(s,0,sizeof(s));}}A,E0,E1,E2,s;
mx operator*(mx a,mx b){
    mx c;per(k,1,n)per(i,1,n)per(j,1,n) 
        c.s[i][j]=(c.s[i][j]+(a.s[i][k]*b.s[k][j])%p)%p;
    return c;
}
mx operator+(mx a,mx b){
    per(i,1,n) per(j,1,n) 
        a.s[i][j]=(a.s[i][j]+b.s[i][j])%p;
    return a;
}
mx operator*(mx a,ll b){
    per(i,1,n) per(j,1,n) 
        a.s[i][j]=(a.s[i][j]*b)%p;
    return a;
}
void solve(int L){
    if(L==1){s=E0=E1=E2=A;return;}
    if(L&1){
        solve(L-1);
        E2=A+(A*(E2+E1*2+E0));
        E1=A+(A*(E1+E0));
        E0=A+(A*E0);
        s=s*A;
    }else{
        solve(L/2);
        ll L2=L/2;
        E2=E2+s*(E2+E1*L+E0*(L2*L2%p));
        E1=E1+s*(E1+E0*(L2%p));
        E0=E0+(s*E0);
        s=s*s;
    }
}
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>m>>k>>q;
    per(i,1,m){
        int x,y;cin>>x>>y;
        A.s[x][y]++;
    }
    solve(k);
    while(q--){
        int s,t;cin>>s>>t;
        cout<<E2.s[s][t]<<'\n';
    }
}
```





---

## 作者：XFlypig (赞：0)

[P4102 [HEOI2014] 林中路径](https://www.luogu.com.cn/problem/P4102)

很有趣的一道矩阵优化优化递推，代码很简单，刚学矩阵也能写，思路一看就会，似乎不太到黑。

首先有个前置经典用法，就是给定一个图，询问走 $K$ 步后两点间路径有多少条，这个可以用矩阵做。具体就是初始时若两点间有路径则初始矩阵 $A$ 中给 $g_{u,v}$ 加一，然后 $k$ 次幂的矩阵中的 $g_{u,v}$ 就是答案，这个用法比较经典，不再赘述。

注：本文主要写我做这题的阻力及我认为的难点，多文字，推导可以看文末博客，可以先去看矩阵定义再读文字。

如果矩阵这类题做的比较少，那这题难处有两点。

一是递推换递归，因为矩阵题目很多是快速幂优化之类的，大多为递推和用几个矩阵拼凑需要的矩阵，惯性思维后做这题可能就会有一点困难或者麻烦。

但我们观察这题后可以发现最终需要的矩阵应该只有一个，而且在你尝试构造矩阵递推时会发现比较困难，但递归就简单多了，需要谁就算谁，只要保证矩阵乘法次数即可。

二就是这题的核心了，怎么构造矩阵呢？如果直接设答案矩阵会发现没法转移，那就要用多个矩阵去一起转移。

因为我们有前置知识，那就是我们维护两点间路径数是简单的，这题要求的是所有小于 $K$ 的时刻的路径数加和，设出矩阵 $F_0$ 来可以发现也很好转移（可以先去看看下面的式子），所以根据题目要求设出答案矩阵 $F_2$ 和两个辅助数组 $F_0, F_1$，这里给出具体定义（输入的边数限制我用的大写字母 $K$，文中的 $k$ 是当前所求的矩阵的次幂）。

设 $A[u][v]$ 为初始时 $u$ 到 $v$ 的边的数量。

$$
\begin{aligned}

s & = A^k\\

F_0[k] & = \sum_{i = 1}^k A^i\\

F_1[k] & = \sum_{i = 1}^k i\times A^i\\

F_2[k] & = \sum_{i = 1}^k i^2\times A^i\\

\end{aligned}
$$

然后就是奇偶分讨推式子，其实很好推，不要被吓到（所以我就只放转移式了，更清晰的可以去看文末博客），可以自己先推推试试。

当 $k$ 是奇数时：
$$
\begin{aligned}

F_0[k] & = A+A\times F_0[k-1]\\
F_1[k] & = A+A\times (F_1[k-1]+F_0[k-1])\\
F_2[k] & = A+A\times (F_2[k-1]+2F_1[k-1]+F_0[k-1])\\

\end{aligned}
$$

当 $k$ 是偶数时：
$$
\begin{aligned}

F_0[k] & = F_0[k/2]+A^{k/2}\times F_0[k/2]\\

F_1[k]&= F_1[k/2]+A^{k/2}\times(F_1[k/2]+k/2\times F_0[k/2])\\

F_2[k]&= F_2[k/2]+A^{k/2}\times(F_2[k/2]+k\times F_1[k/2]+k^2/4\times F_0[k/2])\\

\end{aligned}
$$

这其中的 $A^{k / 2}$ 就是 $s$，是在递归中实时更新的，所以时间复杂度为 $O(n^3\log k)$。

注：本文 $\LaTeX$ 多用的 [这篇博客](https://www.luogu.com.cn/article/n7xt0f8f)，因为我也是个菜鸟，写不出养眼的 $\LaTeX$ 就用大佬的了以防影响读者感受。

```cpp

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100, P = 1e9 + 7;

int n, m, K, q;
struct Matrix
{
    int g[N][N];
    
    Matrix() { memset(g, 0, sizeof g); }
    Matrix operator+ (const Matrix t) const
    {
        Matrix res;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                res.g[i][j] = (g[i][j] + t.g[i][j]) % P;
        return res;
    }
    Matrix operator* (const Matrix t) const
    {
        Matrix res;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                for (int k = 0; k < n; k ++ )
                    res.g[i][j] = (res.g[i][j] + (LL)g[i][k] * t.g[k][j] % P) % P;
        return res;
    }
    Matrix operator* (const int t) const
    {
        Matrix res;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                res.g[i][j] = (LL)g[i][j] * t % P;
        return res; 
    }
} F0, F1, F2, A, s;

void calc(int k)
{
    if (k == 1) F0 = F1 = F2 = s = A;
    else if (k & 1)
    {
        calc(k - 1);
        F2 = A + A * (F2 + F1 * 2 + F0);
        F1 = A + A * (F1 + F0);
        F0 = A + A * F0;
        s = s * A;
    }
    else
    {
        calc(k / 2);
        F2 = F2 + s * (F2 + F1 * k + F0 * ((LL)k * k / 4 % P));
        F1 = F1 + s * (F1 + F0 * (k / 2));
        F0 = F0 + s * F0;
        s = s * s;
    }
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &K, &q);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        A.g[a - 1][b - 1] ++ ;
    }
    
    calc(K);
    while (q -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        printf("%d\n", F2.g[a - 1][b - 1]);
    }
    
    return 0;
}

```

---


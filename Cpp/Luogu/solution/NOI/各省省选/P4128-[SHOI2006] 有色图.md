# [SHOI2006] 有色图

## 题目描述

如果一张无向完全图（完全图就是任意两个不同的顶点之间有且仅有一条边相连）的每条边都被染成了一种颜色，我们就称这种图为有色图。如果两张有色图有相同数量的顶点，而且经过某种顶点编号的重排，能够使得两张图对应的边的颜色是一样的，我们就称这两张有色图是同构的。以下两张图就是同构的，因为假如你把第一张图的顶点 $(1,2,3,4)$ 置换成第二张图的 $(4,3,2,1)$，就会发现它们是一样的。

![](https://cdn.luogu.com.cn/upload/pic/13240.png) 

你的任务是，对于计算所有顶点数为 $n$，颜色种类不超过 $m$ 的图，最多有几张是两两不同构的图。由于最后的答案会很大，你只要输出结论模 $p$ 的余数就可以了（$p$ 是一个质数）。


## 说明/提示

对于 $100 \%$ 的数据，$1\leq n\leq 53$，$1\leq m\leq 1000$，$n<p\leq 10^9$。

## 样例 #1

### 输入

```
1 1 2```

### 输出

```
1```

## 样例 #2

### 输入

```
3 2 97```

### 输出

```
4```

## 样例 #3

### 输入

```
3 4 97```

### 输出

```
20```

# 题解

## 作者：小粉兔 (赞：121)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/10358520.html](https://www.cnblogs.com/PinkRabbit/p/10358520.html)。

计数好题，原来是 13 年前就出现了经典套路啊。这题在当年应该很难吧。

### 题意简述：

$n$ 个点的完全图，点没有颜色，边有 $m$ 种颜色，问本质不同的图的数量对质数 $p>n$ 取模。

本质不同指的是在点的 $n!$ 种不同置换下不同。

### 题解：

首先有 $\mathrm{Burnside}$ 引理：一类元素在一个**置换群**的作用下本质不同的元素（不同等价类）个数等于 $\displaystyle\frac{1}{|G|}\sum_{g\in G}M(g)$。其中 $G$ 是所有置换的集合，$M(g)$ 是一个置换的不动点个数。

那么我们考虑一个点的置换 $(a_1,a_2,\ldots,a_n)$，因为一个置换可以拆分成不相交循环的乘积，考虑这个置换能拆分成 $k$ 个长度分别为 $b_1,b_2,\ldots,b_k$ 的不相交循环的乘积。显然它的不动点个数为 $m$ 的在这个置换下边的等价类个数次方。如何计算它的边等价类个数？

我们考虑两类边，第一类是端点在同一循环中的边，第二类是端点在不同循环中的边。

对于第一类边，考虑一个长度为 $b$ 的循环。把 $b$ 个点按顺序等距分布在一个圆上，在循环作用下每条边都会往顺时针方向位移一格。则容易得到两条边处于不同等价类当且仅当它们长度不同，可以得出长度为 $b$ 的循环内部共有 $\displaystyle\left\lfloor\frac{b}{2}\right\rfloor$ 种边的等价类。

对于第二类边，考虑两个长度分别为 $b_1$ 和 $b_2$ 的不同循环。对于一条边，在这个置换的重复作用下经过 $\mathrm{lcm}(b_1,b_2)$ 次操作会回到自身。所以每条边的在一个大小为 $\mathrm{lcm}(b_1,b_2)$ 的等价类中，则不同等价类的个数为 $\displaystyle\frac{b_1b_2}{\mathrm{lcm}(b_1,b_2)}=\gcd(b_1,b_2)$。

综合得到等价类个数为 $\displaystyle\sum_{i}\left\lfloor\frac{b_i}{2}\right\rfloor+\sum_{i<j}\gcd(b_i,b_j)$。对于一个求出了 $b$ 的置换，这个式子可以在 $\Theta(k^2\log b_i)$ 的时间内求出。

接下来需要对所有置换统计，显然我们不能枚举每个置换，但是可以发现，$b$ 一样的置换答案也相同。考虑枚举 $b$，即本质不同的不相交循环长度的可重集。这相当于枚举 $n$ 的每个整数分拆。本题中 $n\le 53$，而 $53$ 的整数分拆数量也不大。

考虑枚举了 $b_1\le b_2\le \cdots\le b_k$，其中 $\displaystyle\sum b_i=n$，如何计算它对应了多少种不同的置换呢？

考虑对于 $1$ 到 $n$ 的每个点，分配它在第几个循环中，这相当于一个多重组合数 $\displaystyle\frac{n!}{\prod b_i!}$。而对于每一个置换，分配它内部的顺序，这相当于一个圆排列，即 $\prod (b_i-1)!$，结合前面是 $\displaystyle\frac{n!}{\prod b_i}$。最后我们会发现这样其实会算重，因为每个循环的前后顺序不影响，不能把 $1,2$ 和 $2,1$（这里表示每个点在第几个循环内）当作不同的循环分配方案。发现只有 $b_i$ 相同的会影响，假设有 $c$ 个，正好多乘了 $c!$ 种方案，除掉就好了。这相当于 $\displaystyle\frac{n!}{\prod b_i\prod c!}$。

发现因为有 $|G|=n!$ 种置换，正好和最后 $\displaystyle\frac{1}{|G|}$ 抵消了，所以最终的式子是：$\displaystyle\sum_{b}\frac{1}{\prod b_i\prod c!}m^{\sum_{i}\lfloor\frac{b_i}{2}\rfloor+\sum_{i<j}\gcd(b_i,b_j)}$。

对于枚举每一种 $b$，可以直接 DFS。而后面两个东西都是能直接在 DFS 过程中计算的，优化常数。

本题很贴心地保证 $p>n$，可以放心求阶乘和阶乘逆元。

时间复杂度大约是 $\displaystyle\mathcal{O}\left(\log n\sum_{p\in\mathrm{Partition}(n)}\mathrm{len}^{2}(p)\right)$，实际比较小，更多可以查看 [A296010](https://oeis.org/A296010)。

```cpp
#include <cstdio>
#include <algorithm>

typedef long long LL;
const int MN = 60;

int N, M, P, Sum;
inline int qPow(int b, int e) {
	int a = 1;
	for (; e; b = (LL)b * b % P, e >>= 1)
		if (e & 1) a = (LL)a * b % P;
	return a;
}

int Inv[MN], Fac[MN], iFac[MN];
inline void Init(int N) {
	Inv[1] = 1;
	for (int i = 2; i <= N; ++i) {
		Inv[i] = (LL)(P - P / i) * Inv[P % i] % P;
	}
	Fac[0] = iFac[0] = 1;
	for (int i = 1; i <= N; ++i) {
		Fac[i] = (LL)Fac[i - 1] * i % P;
		iFac[i] = (LL)iFac[i - 1] * Inv[i] % P;
	}
}

int stk[MN], t, n1, n2 = 1;
void DFS(int s, int mx, int c) {
	if (!s) {
		Sum = (Sum + (LL)qPow(M, n1) * n2) % P;
		return ;
	}
	int a = n1, b = n2;
	for (int i = 1; i <= mx; ++i) {
		stk[++t] = i;
		n1 = a + i / 2;
		for (int j = 1; j < t; ++j) n1 += std::__gcd(stk[j], i);
		n2 = (LL)b * Inv[i] % P;
		if (i == stk[t - 1]) n2 = (LL)n2 * Fac[c] % P * iFac[c + 1] % P;
		DFS(s - i, std::min(s - i, i), i == stk[t - 1] ? c + 1 : 1);
		--t;
	}
}

int main() {
	scanf("%d%d%d", &N, &M, &P);
	Init(N);
	DFS(N, N, 0);
	printf("%d\n", Sum);
	return 0;
}
```

听说有色图？来了来了！色图在哪里啊？

---

## 作者：斯德哥尔摩 (赞：19)

[P4128 [SHOI2006]有色图](https://www.luogu.org/problemnew/show/P4128)

这题想起来挺难的。。。

至少我这么认为，直到看了某巨佬的[博客](http://www.cnblogs.com/Konjakmoyu/p/6277483.html)。

首先它是边的置换。

但是我们的$Polya$只能解决点的置换。

所以我们要看一下点置换和边置换之间的关系。

假定一个点置换是$(a_1,a_2,...)(b_1,b_2...)(c_1,c_2...)...$

1. 对于不在一个循环里面的点：
	
    比如$a_1,b_1$, 那么会有边循环$((a1,b1),(a2,b2)...)$
    
    设$a_i$循环的循环节是$l_1$，$b_i$循环的循环节是$l_2$,那么形成的边循环的循环节显然是$lcm(l_1,l_2)$。
	
    一共有$l_1* l_2$个点对，每个点对都在一个循环节为$lcm(l_1,l_2)$的循环上，所以一共有$\frac{l_1* l_2}{lcm(l_1,l_2)}=gcd(l_1,l_2)$个循环节，所以$C(f)=m^{gcd(l_1,l_2)}$。
    
    （回到$Burnside$引理，$C$为置换之后仍为自身的数目，就是说要循环节里的每条边都一样的颜色）

2. 对于在一个循环里面的点：

    比如$a_1,a_2$。
    
    设$a_i$的循环节为$l_1$。

    如果$l_1$是奇数，那么循环长度为$l_1$，一共有$\left(\begin{array}{c}l_1\\2\end{array}\right)$个点对，所以是$\frac{l_1-1}{2}$个循环节，所以$C(f)=m^{\frac{l_1-1}{2}}$。

    如果$l_1$是偶数，除了上面这种情况之外，还有一种的循环节是$\frac{l_1}{2}$（就是两个点刚好相隔半个周期，而边是双向的），所以一共有$\frac{\left(\begin{array}{c}l_1\\2\end{array}\right)-\frac{l_1}{2}}{l1}+1=\frac{l_1}{2}$个点对。

综上，边的置换的循环数为：
$$\sum_{i=1}^{k}\lfloor \frac{l_i}{2}\rfloor+\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}gcd(l_i,l_j)$$

实际$N!$个点的置换中，有多少$l_1<l_2<...<l_i$呢？

若将一个循环看成一个圆形的排列，现在要把$N$个人分配到$k$个长度分别为$l_1,l_2,l_3,...,l_k$的独立不相关圆排列中，并且$l_1<=l_2<=l_3<=...<=l_k$。

因为存在$l_i==l_{i+1}$的情况，设$B_i$为有多少$l_j$满足$l_j==i$。

则总分配数为：
$$S=\frac{N!}{\prod_{i=1}^{k}l_i* \prod_{i=1}^{k}B_i!}$$

然后我们通过搜索，确定点的置换长度$l_1<=l_2<=l_3<=...<=l_k$，满足该特征的个数为$S$，而该特征的点置换引导出的边置换循环数为$C$。

于是我们所求的答案就解决了：$$Ans=Ans+S* m^C$$

所以代码很简单，只要枚举$N$的拆分，然后计算不动点就好了。

但是又有除，又有模，怎么办？

套路求逆元，注意到$p\in prime$，直接费马小定理即可，不用扩欧了。

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define MAXN 70
using namespace std;
long long n,m,p,ans=0,fact[MAXN],num[MAXN];//直接开long long
inline long long read(){//快读
    long long date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
long long gcd(long long x,long long y){//这个gcd应该都会吧
    if(!y)return x;
    return gcd(y,x%y);
}
long long mexp(long long a,long long b,long long c){//快速幂也应该会吧
    long long s=1;
    while(b){
        if(b&1)s=s*a%c;
        a=a*a%c;
        b>>=1;
    }
    return s;
}
void get_answer(int x){//累计答案
    int top=1;
    long long sum=0,mul=1;
    for(int i=1;i<=x;i++)sum+=num[i]/2;
    for(int i=1;i<=x;i++)
    for(int j=i+1;j<=x;j++)
    sum+=gcd(num[i],num[j]);
    for(int i=1;i<=x;i++)mul=(mul*num[i])%p;
    for(int i=2;i<=x;i++){
        if(num[i]!=num[i-1]){
            mul=(mul*fact[top])%p;
            top=0;
        }
        top++;
    }
    mul=(mul*fact[top])%p;
    mul=fact[n]*mexp(mul,p-2,p)%p;
    ans=(ans+mul*mexp(m,sum,p)%p)%p;//记得每次都要累计
}
void dfs(int x,int h,int s){//直接暴搜
    if(!h)get_answer(x-1);
    if(h<s)return;
    for(int i=s;i<=h;i++){
        num[x]=i;
        dfs(x+1,h-i,i);
        num[x]=0;
    }
}
void work(){
    dfs(1,n,1);
    ans=ans*mexp(fact[n],p-2,p)%p;
    printf("%lld\n",ans);
}
void init(){//读入+预处理阶乘
    n=read();m=read();p=read();
    fact[0]=1;
    for(int i=1;i<=n;i++)fact[i]=(fact[i-1]*i)%p;
}
int main(){//主函数So easy!
    init();
    work();
    return 0;
}

```

---

## 作者：AsunderSquall (赞：10)

 
update:修复了几个笔误 
 
置换群论基础练习题。  
首先我们发现这个 $n \le 53$ 感觉很不对劲。  
$n \le 53$ 能用来做什么？  
最常见的应该就是拆分数了。  
那是什么让我们想到置换群论？  
~~题解~~ 本质不同。  
 
写题解的过程中发现变量重名了，所以我们不管题面中的 $m$，设染色数为 $k$。  
我们考虑已经将 $n$ 拆成了 $a_1,a_2,a_3,\cdots a_m$ 个数，其中 $a_1\ge a_2 \ge \cdots \ge a_m$，这样方便统计。  
求这个的过程可以直接大力 `dfs`  
 
我们知道，一个置换可以表示成若干个循环，这里我们把一个长度为 $n$ 的置换拆成了 $m$ 个循环，循环的长度分别为 $a_1,a_2,a_3,\cdots a_m$。  
这样的拆分是无标号的，我们先考虑怎样算出这样的一个拆分序列对应了几个置换。  

那么我们先把这么多 $a_i$ ，当做一个个区间，然后往里面填数，填在同一个区间的表示放在同一个置换里，**有顺序影响**。  

首先把 $n$ 个数随便排列，这样是 $n!$。  
然后考虑每个循环内的起点没有影响，所以要乘上 $\prod_{i=1}^m \dfrac 1{a_i}$。  
最后考虑两个大小相同的循环的相对位置没有影响。假设大小为 $l$ 的循环有 $c_l$ 个，那么答案就要乘上 $\prod_l\dfrac 1 {cnt_l!}$。  
因此 $num=\dfrac{n!}{\prod a_i \prod_l {cnt_l!}}$  
这个式子看着很复杂，事实上可以在 dfs 的时候写得好一些，然后在 dfs 过程中就求出来。  

然后就可以用 Burnside 引理了。  
考虑怎么算 这样一个序列的不动点数量。  
考虑一条边，分两种情况讨论。  
- 这条边在循环内部  
那么每个循环贡献的不动点数量为 $\lfloor \dfrac {a_i} 2 \rfloor$
- 这条边在两个循环之间  
那么所有循环贡献的不动点数量为 $\sum_{1\le i<j\le m} \gcd(a_i,a_j)$  

那么最后答案为 
$$\dfrac{1}{|G|}\cdot\dfrac{n!}{\prod a_i \prod_l {cnt_l!}} k^{\sum_{i=1}^m\lfloor \frac {a_i} 2 \rfloor+\sum_{1\le i<j\le m} \gcd(a_i,a_j)}$$  
我们知道 $|G|=n!$  
所以答案为  
$$\dfrac{k^{\sum_{i=1}^m\lfloor \frac {a_i} 2 \rfloor+\sum_{1\le i<j\le m} \gcd(a_i,a_j)}}{\prod a_i \prod_l {cnt_l}!} $$  

然后就做完了。  
在代码中用 `dif` 表示 $\sum_{i=1}^m\lfloor \frac {a_i} 2 \rfloor+\sum_{1\le i<j\le m} \gcd(a_i,a_j)$  
`same` 表示 $\prod a_i \prod_l {cnt_l!}$ 的逆元。  
`cnt` 表示上一个数已经重复出现了几遍。  
`lft` 表示在序列中还剩下多少没有被划入置换中。  
`mx` 表示序列的上一个数是什么，同时也是序列的下一个数的最大值限制。  

代码：（变量名已经改为和题解相同）  
```cpp
#include<bits/stdc++.h>
#define rd(x) x=read()
#define ri register int
#define int long long
using namespace std;
int mod=1e9+7;
const int N=100;
inline int read(){int x=0,f=1;char ch=getchar();while((ch>'9' || ch<'0')){if(ch=='-') f=-1;ch=getchar();}while('0'<=ch && ch<='9') x=x*10+(ch^48),ch=getchar();return x*f;}
inline int ksm(int x,int y=mod-2,int z=mod){int ret=1;while (y){if (y&1LL) ret=ret*x%mod;x=x*x%mod;y>>=1LL;}return ret;}
int n,T,k,ans;
int inv[N],fac[N],ifc[N];
void Init(int n){
inv[1]=1;for (ri i=2;i<=n;i++)inv[i]=inv[mod%i]*(mod-mod/i)%mod;
fac[0]=1;for (ri i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
ifc[0]=1;for (ri i=1;i<=n;i++)ifc[i]=ifc[i-1]*inv[i]%mod;}
int a[N],m,dif,same=1;
void dfs(int lft,int mx,int cnt)
{
    
    if (!lft){ans=(ans+ksm(k,dif)*same)%mod;return;}
    int Dif=dif,Same=same;
    for (int i=1;i<=mx;i++)
    {
        a[++m]=i;
        dif=Dif+i/2;
        for (int j=1;j<m;j++) dif+=__gcd(a[j],i);
        same=Same*inv[i]%mod;
        if (i==a[m-1]) same=same*inv[cnt+1]%mod,dfs(lft-i,min(lft-i,i),cnt+1);
        else dfs(lft-i,min(lft-i,i),1);
        m--;
    }

}
signed main()
{
    rd(n);rd(k);rd(mod);
    Init(n+5);dfs(n,n,0);
    cout<<ans<<endl;
}
```

 在文章最后放两张鏼图  
 [点击链接查看](https://ce-jin.github.io/foto.jpg)  
 [再放一张](https://static.xjoi.net/images/xjoi-new/team-members-home-page/Jince.png)  
 

---

## 作者：0x3F (赞：8)

~~题目骗人，根本没有色图~~

Polya 定理典题。

Polya 定理是说：把一些东西染成 $m$ 种颜色，给一个置换群 $G$，如果一个方案经过 $G$ 中元素 $g$ 的变换后可以变为另一种方案，则视为本质相同。

则方案数为：$\frac{1}{\lvert G\rvert}\sum_{g\in G}m^{c(g)}$，其中 $c(g)$ 为 $g$ 的环数。

而在本题中，$G$ 即为 $n!$ 种点的置换，$c(g)$ 为这些点对应的边构成的等价类数。

我们显然不能接受 $\mathcal{O}(n!)$ 的复杂度。可以枚举 $g$ 的每一个环的大小 $l_1\le l_2\le\cdots\le l_k$，该置换的出现次数为：$\frac{n!}{\prod_{i=1}^{k}l_i\times\prod_{i=1}^{n}cnt_i!}$，其中 $cnt_i$ 为 $i$ 这个数在 $l_1\sim l_k$ 中的出现次数。

现在关键在如何计算 $c(g)$。

对于第 $i$ 个环内部，长度相同的边显然属于同一等价类，故有 $\lfloor\frac{l_i}{2}\rfloor$ 个等价类。

对于第 $i$ 和第 $j$ 个环之间，从两个环上各取一个初始点，然后不停跳，需要跳 $\operatorname{lcm}(l_i,l_j)$ 步才能回到起点，故有 $\gcd(l_i,l_j)$ 个等价类。

于是做完了，时间复杂度为 $\mathcal{O}(\log n\sum_{k=1}^{n}k^2p_{n,k})$，其中 $p_{n,k}$ 为将 $n$ 分拆成 $k$ 个正整数的方案数。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 100;
inline int qpow(int a, int b, int p) {
    int s = 1;
    while (b) {
        if (b & 1) s = 1LL * s * a % p;
        a = 1LL * a * a % p;
        (b >>= 1);
    }
    return s;
}
int n, m, p, tp, stk[_], ans;
void dfs(int sum) {
    int L = ((tp) ? (stk[tp]) : (1));
    int R = (sum >> 1);
    for (int i = L; i <= R; i++) {
        stk[++tp] = i;
        dfs(sum - i);
        tp--;
    }
    stk[++tp] = sum;
    int cnt = 0, num = 1, cur = -1;
    for (int i = 1; i <= tp; i++) {
        cnt += (stk[i] >> 1);
        num = 1LL * num * stk[i] % p;
        if (i == 1 || stk[i] != stk[i-1]) {
            cur = 1;
        } else {
            cur++;
        }
        num = 1LL * num * cur % p;
    }
    for (int i = 1; i < tp; i++) {
        for (int j = i+1; j <= tp; j++) {
            cnt += __gcd(stk[i], stk[j]);
        }
    }
    ans = (ans + 1LL * qpow(m, cnt, p) * qpow(num, p - 2, p)) % p;
    tp--;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m >> p;
    dfs(n);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Purslane (赞：8)

# Solution

比较简单的一道题。至少我会做。

显然，对顶点的置换操作构成了一个群。（其实就是所有 $n$ 阶置换构成的群）考虑使用 Burnside 引理进行计数。

不妨将置换环从小到大排序。考虑计算自由度是多少。

对于一个大小为 $l$ 的环，环中的一条边 $(u,v)$，必须与 $(to_u,to_v)$，$(to^2_u,to^2_v)$（指标表示迭代）……相等。这些边有一个共同的特质：环上 $u$ 和 $v$ 两点的最短距离相同。所以自由度是 $\lfloor \dfrac{l}{2} \rfloor$。

对于大小为 $x$ 和 $y$ 的两个环，考虑计算本质相同的一条边可以覆盖多少条原始边，容易发现是 $\text{lcm}(x,y)$。所以自由度为 $\dfrac{xy}{\text{lcm}(x,y)}=\gcd(x,y)$。

所以如果你确定了 $s_1 \le s_2 \le \dots \le s_k$，边的总自由度为：

$$
\sum_{i=1}^k \lfloor \dfrac{s_i}{2} \rfloor + \sum_{i=1}^k \sum_{j=i+1}^k \gcd(s_i,s_j)
$$

考虑把 $n$ 个点分配到这些数中，其实就是多重组合数，有 $\dbinom{n}{s_1 \ s_2 \ \dots \ s_k}$ 种方案。每个环内部有 $(s_i-1)!$ 种排列方式。

不过相同大小之间的环之间的顺序是无所谓的，所以如果大小为 $x$ 的环有 $c_x$ 个，我们要手动除序，即除掉 $\prod_{i=1}^n c_i!$。

显然置换群的大小为 $n!$，最后除掉。

综上所述，答案即为：

$$
\sum_{
\begin{aligned}
& s_1 \le s_2 \le \dots \le s_k , \\
& s_1+s_2+\dots+s_k=n
\end{aligned}
}
\frac{m^{\sum_{i=1}^k \lfloor \frac{s_i}{2} \rfloor + \sum_{i=1}^k \sum_{j=i+1}^k \gcd(s_i,s_j)}}{\prod_{i=1}^k s_i \prod_{i=1}^n c_i!}
$$

其中 $\{c_i\}$ 由 $\{s_i\}$ 唯一确定。

总计算量为（预处理了 $\gcd$ 和 $m^x$）

$$
O(\sum_{
\begin{aligned}
& s_1 \le s_2 \le \dots \le s_k , \\
& s_1+s_2+\dots+s_k=n
\end{aligned}
} k^2)
$$

打表计算发现在 $1 \times 10^8$ 量级附近，足已通过。~~不过当时的机子可能跑不动~~

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=60,MAXM=3600;
int n,m,p,pw[MAXM],ans,gcd[MAXN][MAXN],tmp[MAXN],frac[MAXN],inv[MAXN],dinv[MAXN];
int qpow(int base,int p,int mod) {int ans=1; while(p) {if(p&1) ans=base*ans%mod;base=base*base%mod,p>>=1;} return ans;}
void dfs(int dep,int sum,int lst) {
	if(sum==n) {
		int tans=1,lst=0,kk=0;
		ffor(i,1,dep-1) ffor(j,i+1,dep-1) kk+=gcd[tmp[i]][tmp[j]];
		ffor(i,1,dep-1) kk+=tmp[i]/2,kk;
		tans=pw[kk];
		ffor(i,1,dep-1) tans=tans*dinv[tmp[i]]%p;
		ffor(i,1,dep-1) {
			if(tmp[i]!=tmp[i-1]) tans=tans*inv[lst]%p,lst=1;
			else lst++;	
		}
		tans=tans*inv[lst]%p;
		return ans=(ans+tans)%p,void();
	}
	ffor(j,lst,n-sum) tmp[dep]=j,dfs(dep+1,sum+j,j);
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>p; frac[0]=1; ffor(i,1,n) frac[i]=frac[i-1]*i%p; inv[n]=qpow(frac[n],p-2,p); roff(i,n-1,0) inv[i]=inv[i+1]*(i+1)%p;
	ffor(i,1,n) ffor(j,1,n) gcd[i][j]=__gcd(i,j);
	ffor(i,1,n) dinv[i]=qpow(i,p-2,p);
	pw[0]=1; ffor(i,1,n*n) pw[i]=pw[i-1]*m%p;
	dfs(1,0,1);
	cout<<ans;
	return 0;
}
```

附一张色图：

![](https://img2.baidu.com/it/u=590214124,3530805386&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1708621200&t=30cf80740c831cca3bb0bd253479b10b)

这张也不错

![](https://ts1.cn.mm.bing.net/th/id/R-C.8a0b94e078252e9ae0f2634a6940eb2f?rik=vlmbfSCZGsZpBA&riu=http%3a%2f%2fimg.zcool.cn%2fcommunity%2f022c12565a86f400000111624e9a54.jpg%40800w_1l&ehk=L5cFFJyucC%2fv8WN2JwtJ%2bqnqW6A0lJDc4%2flEWRTF53U%3d&risl=&pid=ImgRaw&r=0)

---

## 作者：cwfxlh (赞：6)

# [P4128](https://www.luogu.com.cn/problem/P4128)    

哪里有色图？      

首先，有 Burnside 引理，本质不同的图个数是 $\frac{1}{n!}\sum_{g\in G}{f(g)}$，$G$ 是点的置换方案集，大小为 $n!$，$f(g)$ 是在 $g$ 作用下不变的图个数。    

考虑对于每一个置换方案，其可以被拆分为长度为 $b_1,b_2...,b_k$ 的 $k$ 个置换环，则我们按置换环给边划分等价类。因为是完全图，所以我们要考虑任意两点的连边。首先，如果两条边它们各自两个端点所属的置换环不同，那么它们必定不属于一个等价类，因为换不过去。         

如果两个端点属于一个置换环，那么边在环上动的时候，长度不变，因此这种情况的等价类个数有 $\sum\lfloor\frac{b_i}{2}\rfloor$。如果两个端点不属于一个置换环，则位移 $\operatorname{lcm}(b_i,b_j)$ 次才会回到最初的边，因此有 $\frac{b_i\times b_j}{\operatorname{lcm}(b_i,b_j)}=\gcd(b_i,b_j)$ 个等价类。于是这样一种置换，每一个的贡献就是 $m^{\sum{\frac{b_i}{2}}+\sum\sum{\gcd(b_i,b_j)}}$。此时再计数一下满足有 $b_1,b_2...b_k$ 个置换环的排列数，为 $\frac{n!}{\prod{b_i}\prod{c_i}}$，$c_i$ 指长度为 $i$ 的置换环数量。        

发现 $b_1,b_2...b_k$ 这样的分割方案是很少的，不超过 $10^6$，于是我们枚举分割方案，然后计算贡献即可。需要预处理一点逆元，否则可能会 TLE。     

代码：    

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,mod,C[2003][2003],ans,gd[55][55],ny[603],njc[5003];
int stk[500003],tot,jc[5003];
int fstp(int X,int Y){
	int ret=1,bse=X%mod;
	while(Y){
		if(Y&1)ret=ret*bse%mod;
		bse=bse*bse%mod;
		Y>>=1;
	}
	return ret;
}
void calc(){
	int ret=0,cnt=0;
	for(int i=1;i<=tot;i++)ret+=(stk[i]/2);
	for(int i=1;i<=tot;i++){
		for(int j=i+1;j<=tot;j++)ret+=gd[stk[i]][stk[j]];
	}
	ret=fstp(m,ret);
	cnt=jc[n];
	for(int i=1;i<=tot;i++)cnt=cnt*ny[stk[i]]%mod;
	for(int i=1;i<=tot;i++){
		int j=i;
		while(j<tot&&stk[j+1]==stk[i])j++;
		cnt=cnt*njc[j-i+1]%mod;
		i=j;
	}
	ret=ret*cnt%mod;
	ans=(ans+ret)%mod;
	return;
}
void dfs(int now,int lmt){
	if(now==0){
		calc();
		return;
	}
	tot++;
	for(int i=lmt;i<=now;i++){
		stk[tot]=i;
		dfs(now-i,i);
	}
	tot--;
	return;
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>mod;
	jc[0]=1;
	for(int i=0;i<=500;i++)ny[i]=fstp(i,mod-2);
	for(int i=1;i<=54;i++){
		for(int j=1;j<=54;j++)gd[i][j]=__gcd(i,j);
	}
	for(int i=1;i<=5000;i++)jc[i]=jc[i-1]*i%mod;
	for(int i=0;i<=5000;i++)njc[i]=fstp(jc[i],mod-2);
	for(int i=0;i<=2000;i++)C[i][0]=1;
	for(int i=1;i<=2000;i++){
		for(int j=1;j<=i;j++)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
	dfs(n,1);
	ans=ans*fstp(jc[n],mod-2)%mod;
	ans%=mod;
	ans+=mod;
	ans%=mod;
	cout<<ans;
	return 0;
}
```


---

## 作者：Aigony (赞：6)

~~有色图？rnm，退钱！~~

本文节选自 [Burnside 引理 与 Pólya 定理 学习笔记](https://www.cnblogs.com/ying-xue/p/burnside-polya.html)。

使用 Polya 定理，先枚举一个置换，并把置换写成循环的形式。考虑对在该置换下不变的染色方案进行计数。

根据一条边的两个端点是否在同一个循环内，分类讨论：

- 如图，若一条边的两个端点属于同一循环，那么它应当与循环内所有长度相等的边同色。  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/tywsk9gs.png)  
  那么一个长度为 $len$ 的循环，其内部共有 $\lfloor \frac{len}{2}\rfloor$ 类等价的边。
- 否则，若一条边连接了两个不同循环，设它们的长度分别为 $len_i,len_j$。那么一条边需要做 $\text{lcm}(len_i,len_j)$ 次置换才能回到它原来的位置，即等价类个数为 $\gcd(len_i,len_j)$。

综上，一个 $len$ 序列对 polya 求和式子的贡献为
$$
S=\sum_{i=1}^n(\lfloor \frac{len_i}{2}\rfloor +\sum_{j=1}^{i-1} \gcd(len_i,len_j))
$$
发现这只与 $len$ 数组有关而与具体的置换无关，考虑只枚举 $len$ 数组，并计算有多少种对应的置换。由 2.3.2 可知，设 $c_i$ 表示 $len_j=i$ 的 $j$ 的个数，对应的置换数为
$$
\frac{n!}{\prod len_i\prod (c_i!)}
$$
总答案为
$$
\frac{1}{n!}\sum_{len}\frac{n!}{\prod len_i\prod (c_i!)} k^S
$$
其中 $S$ 见上文。时间复杂度为 $n$ 的无序拆分数。

---

## 作者：Leasier (赞：3)

看到染色同构，考虑 Pólya 定理。

本题中我们的置换群为所有长为 $n$ 的置换，表示点重编号的结果。

但是本题中我们是**对边染色**，考虑如何算不动点数量。类似于点染色的情况，我们只需要知道边的等价类个数即可。

考虑抓出这个置换的所有环（设环长为 $cnt_1, cnt_2, \cdots, cnt_k$），然后来讨论等价类：

- 环内到环内：此时我们只关心两点在环（设为 $i$）上的距离，而这个距离 $\leq \lfloor \frac{cnt_i}{2} \rfloor$，则方案数为 $\lfloor \frac{cnt_i}{2} \rfloor$。
- 环内到环外：此时我们只关心两个环（设为 $i, j$）的大小，而从任意一个状态出发在两个环上每次定向前进一步，回到原点所需步数均为 $\operatorname{lcm}(cnt_i, cnt_j)$，则本质不同个数为 $\gcd(cnt_i, cnt_j)$。

综上，不动点数量为 $m^{\sum_{i = 1}^k \lfloor \frac{cnt_i}{2} \rfloor  + \sum_{i = 1}^{k - 1} \sum_{j = i + 1}^k \gcd(cnt_i, cnt_j)}$。

注意到 $n$ 很小，则我们可以考虑枚举 $n$ 的拆分数，对每种方案计算上面这个东西，然后再乘上方案数，即 $\dfrac{n!}{\displaystyle\prod_{i = 1}^k cnt_i \displaystyle\prod_{\text{There exists i item j that } cnt_j = t} i!}$。

时间复杂度为 $O(n \operatorname{Partition}(n) \log n)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

int cnt1[57], cnt2[57];
ll inv[57];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init(int n, int mod){
	inv[0] = inv[1] = 1;
	for (int i = 2; i <= n; i++){
		inv[i] = mod - (mod / i) * inv[mod % i] % mod;
	}
}

inline int max(int a, int b){
	return a > b ? a : b;
}

int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}

ll dfs(int cur, int lst, int pre, int sum, int m, int mod){
	if (lst == 0) return quick_pow(m, sum, mod);
	int cur_i = cur + 1;
	ll ans = 0;
	for (int i = max(pre, 1); i <= lst; i++){
		int cur_sum = sum + i / 2;
		cnt1[cur] = i;
		if (i == pre){
			cnt2[cur] = cnt2[cur - 1] + 1;
		} else {
			cnt2[cur] = 1;
		}
		for (int j = 1; j < cur; j++){
			cur_sum += gcd(cnt1[j], i);
		}
		ans = (ans + dfs(cur_i, lst - i, i, cur_sum, m, mod) * inv[i] % mod * inv[cnt2[cur]] % mod) % mod;
	}
	return ans;
}

int main(){
	int n, m, p;
	scanf("%d %d %d", &n, &m, &p);
	init(n, p);
	printf("%lld", dfs(1, n, 0, 0, m, p));
	return 0;
}
```

---

## 作者：FjswYuzu (赞：3)

题目中对点进行了置换，然而有颜色的是边！操作实际变换的应该是边，但是我们没有好的办法对边编号，只有考虑置换对边的影响。

注意到问题没有对颜色限制，其引导我们去使用 Pólya 定理解决这个问题。

毋庸置疑的是一共有 $n!$ 种点的置换方法。考虑在置换 $g$ 下，边集中不动点的个数。

将置换 $g$ 用若干轮换相乘表示，将边集中的每一条边用两个点表示：

- 如果这条边代表的两个点，在轮换表达中在同一个轮换：显然两点在同一环上，如果这两个点之间的点数不同，那么其处于另外一个不动点。显然，设这个轮换的阶为 $p$，其贡献 $\left\lfloor \tfrac{p}{2} \right\rfloor$ 个不动点；

![](https://cdn.luogu.com.cn/upload/image_hosting/y8d1013d.png)

- 如果这条边代表的两个点，在轮换表达中不处于同一个轮换：那么设两点在的不同轮换阶数分别为 $s,t$，显然存在一个长为 $\operatorname{lcm}(s,t)$ 的循环节。而其共有 $st$ 条边，因此其会贡献 $\dfrac{st}{\operatorname{lcm}(s,t)}=\gcd(s,t)$ 个不动点。

设置换 $g$ 表达成 $n$ 个轮换后，第 $i$ 个轮换的阶数为 $p_i$。显然 $\sum p = |g|$。

枚举 $n!$ 个置换显然不可能，但是在 $n$ 这么小的情况下进行整数拆分是可行的。原因是，当 $p$ 构成的可重集相同时，答案也相同。我们直接搜索，使其满足 $\forall i \in[1,n-1],p_i \leq p_{i+1}$ 即可。

考虑对于一个 $p$ 计数。首先挑数进行分拆，对于一个 $b_i$，会造成 $\dfrac{1}{b_i!}$ 的贡献；一个轮换内部进行**圆排列**，共有 $(b_i-1)!$ 中方案；同时，因为有相同的 $b_i$ 的存在，设 $c_i$ 为相同的 $i$ 出现的次数，则方案数为 $\dfrac{n!}{\prod b_i \prod c_i!}$。将 $\dfrac{1}{|G|} = \dfrac{1}{n!}$ 提入，则答案写作：

$$
\sum \dfrac{1}{\prod b_i \prod c_i!} m^{(\sum_i \lfloor \frac{b_i}{2} \rfloor ) + (\sum_i \sum_{j<i}\gcd(b_i,b_j))}
$$

暴力 dfs 即可。注意指数内容和分母应该在 dfs 内计算。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL MOD;
LL QuickPow(LL x,LL p)
{
	LL ans=1,base=x;
	while(p)
	{
		if(p&1)	ans=(ans*base)%MOD;
		base=(base*base)%MOD;
		p>>=1;
	}
	return ans;
}
LL n,m,fac[55],ifac[55],inv[55],ans;
LL gcd(LL a,LL b){return !b?a:gcd(b,a%b);}
LL a[55],cnt;
void dfs(LL now,LL sum1,LL sum2,LL prod)
{
	if(!now)
	{
		LL sum=sum1+sum2;
		(ans+=QuickPow(m,sum%(MOD-1))*prod%MOD)%=MOD;
		return ;
	}
	++cnt;
	for(LL i=a[cnt-1];i<=now;++i)
	{
		a[cnt]=i;
		LL delta=0;
		for(LL j=1;j<cnt;++j)	delta+=gcd(a[cnt],a[j]);
		LL tot=0,pos=cnt;
		while(pos && a[cnt]==a[pos])	++tot,--pos;
		dfs(now-i,(sum1+i/2)%(MOD-1),(sum2+delta)%(MOD-1),prod*inv[tot]%MOD*inv[i]%MOD);
	}
	a[cnt--]=0;
}
int main(){
	scanf("%lld %lld %lld",&n,&m,&MOD);
	fac[0]=1;
	for(LL i=1;i<=n;++i)	fac[i]=fac[i-1]*i%MOD;
	ifac[n]=QuickPow(fac[n],MOD-2);
	for(LL i=n-1;~i;--i)	ifac[i]=ifac[i+1]*(i+1)%MOD;
	for(LL i=1;i<=n;++i)	inv[i]=fac[i-1]*ifac[i]%MOD;
	a[0]=1;
	dfs(n,0,0,1);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：hzoi_liuchang (赞：3)

## 分析

图的同构问题

$Polya$ 定理是用来解决点置换的，但是这道题要求的是边置换

那么就考虑边的两个端点分别在哪个循环中

分为两类：

$1$、边的两个端点在同一循环中

设循环的长度为 $b$

如果端点之间的间距不同，那么两条边一定不在一个等价类中

又因为是在循环中，所以间距 $x$ 也可以看成间距 $b-x$

那么等价类的个数就是 $\left\lfloor\frac{b}{2}\right\rfloor$

$2$、边的两个端点在不同循环中

设这两个循环的长度分别为 $b_1,b_2$

每一个边的循环的大小都是 $lcm(b_1,b_2)$

那么边的等价类的个数就是 $\frac{b_1b_2}{lcm(b_1,b_2)}=gcd(b_1,b_2)$

设点的循环的长度为 $b_1,b_2,b_2 \cdots b_k$

那么最终的答案就是 

$$\Large \frac{1}{|G|} \sum\limits_b m^{\sum\limits_{i=1}^k\left\lfloor\frac{b_i}{2}\right\rfloor+\sum\limits_{i=1}^k\sum\limits_{j=i+1}^k gcd(b_i,b_j)}$$

现在的问题就是如何枚举 $b$

因为 $n$ 的范围比较小，所以可以考虑 $dfs$ 从大到小加数

对于每一个枚举出来的 $b$ ，我们还要知道具体有多少置换是这样的

首先对于所有的点进行全排列，就是一个 $n!$

又因为每一个循环内部都是循环同构的，所以要除掉 $b_i$

而且我们强行给长度相同的循环规定了顺序

所以对于长度为 $i$ 的循环，如果它出现了 $s_i$ 次，还要给最后的结果除掉 $s_i!$

要除以的是给指数取模的时候要模 $phi$ ，而不能模 $mod$
## 代码
``` cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=305;
int n,m,mod;
inline int addmod(rg int now1,rg int now2,rg int Mod){
	return now1+=now2,now1>=Mod?now1-Mod:now1;
}
inline int delmod(rg int now1,rg int now2,rg int Mod){
	return now1-=now2,now1<0?now1+Mod:now1;
}
inline int mulmod(rg long long now1,rg int now2,rg int Mod){
	return now1*=now2,now1>=Mod?now1%Mod:now1;
}
inline int ksm(rg int ds,rg int zs){
	rg int nans=1;
	while(zs){
		if(zs&1) nans=mulmod(nans,ds,mod);
		ds=mulmod(ds,ds,mod);
		zs>>=1;
	}
	return nans;
}
int gcd(rg int aa,rg int bb){
    return bb==0?aa:gcd(bb,aa%bb);
}
int sta[maxn],tp,fz=1,ans,ny[maxn];
void dfs(rg int now,rg int mmax,rg int ac1,rg int ac2,rg int cnt){
    if(!now){
        ans=addmod(ans,mulmod(ac1,ksm(m,ac2),mod),mod);
        return;
    }
    rg int tmp1,tmp2;
    for(rg int i=1;i<=mmax;i++){
        tmp1=ac1,tmp2=ac2;
        sta[++tp]=i;
        for(rg int j=1;j<tp;j++) tmp2=addmod(tmp2,gcd(sta[tp],sta[j]),mod-1);
        tmp2=addmod(tmp2,i/2,mod-1);
        if(sta[tp]==sta[tp-1]) tmp1=mulmod(tmp1,ny[cnt+1],mod);
        tmp1=mulmod(tmp1,ny[i],mod);
        dfs(now-i,std::min(now-i,i),tmp1,tmp2,sta[tp]==sta[tp-1]?cnt+1:1);
        tp--;
    }
}
int main(){
    n=read(),m=read(),mod=read();
    for(rg int i=1;i<=n+1;i++) ny[i]=ksm(i,mod-2);
    for(rg int i=2;i<=n;i++) fz=mulmod(fz,i,mod);
    dfs(n,n,fz,0,0);
    fz=1;
    for(rg int i=2;i<=n;i++) fz=mulmod(fz,ny[i],mod);
    ans=mulmod(ans,fz,mod);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Jiang_zi_chuan (赞：3)

还是，我要宣传CSDN Blog

[大号看这里](https://blog.csdn.net/clover_hxy/article/details/60965806)
[小号看这里](https://blog.csdn.net/jzc20080511/article/details/86565821)

跟楼上大佬说的差不多，大家也看完一看看楼上大佬的

置换+dfs

无向完全图如果只考虑点的话，那么就是可以等价成一个点。

因为这道题的置换是点的全排列，那么我们先考虑如何求点的置换。

我们的目标就是求出每个m(f)有多少个取值，然后快速计算，m(f)跟边置换有关，暂且不说，但是数量与点置换相关，我们现在考虑每个m(f)对应的点置换的数量。m(f)是否相同应该与点的划分方式有关（就是拆成几个轮换，以及每个轮换中元素的数量）。计算的时候利用组合数和阶乘。首先如果两个组的元素个数相同，那么在选取的时候先选哪一个都一样，所以需要除去出现次数的阶乘(就是这几个组的全排列)。然后对于组内的元素有(个数-1)的阶乘种排列方式，为啥是个数-1？因为我们要求每个位置都是乱的就是不能再拆成别的轮换。

现在考虑如何计算m(f).

分成两部分考虑：

(1)两个轮换之间的边，形成的轮换的个数是gcd(x,y),其中x,y为轮换中点的数量。

(2)同一轮换中的边，轮换的个数是size/2，我也不是很清楚为什么，只能画画图感受一下(其实就是找规律。。。)

代码：

```cpp
//2018.12.31 18:00
/*
   Name: Jiang_zi_chuan
   Copyright: Jiang_zi_chuan
   Author: Jiang_zi_chuan
   Date: 31/12/18 18:00
   Description: 算法类型
*/
// luogu-judger-enable-o2
//#define LOCAL
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <bits/stdc++.h>

#define INF 0x3f
#define ull unsigned long long
#define ll long long
#define FOR(a, b, n) for(int a = b; b >= n ? a >= n : a <= n; b >= n ? a-- : a++)
#define M(a, n) memset(a, n, sizeof(a));
#define S(n) scanf("%d", &n)
#define P(n) printf("%d", n)
#define G(n) getline(cin, n)
#define PI acos(-1.0)
#define QAQ(n) 0
#define chen_zhe 0x3f

using namespace std;

const int N = 105;
#define ll long long 
int n, q[N], use[N], vis[N], num[N], len, m, k[N];
ll cnt, c[N][N], ans, p, d[N], jc[N], inv[N], a[N], g[N][N], b[N*N];
ll quickpow(ll num, int x)
{
    ll ans = 1; 
    ll base = num % p;
    while (x) {
        if (x & 1) 
            ans = ans * base % p;
        x >>= 1;
        base = base * base % p;
    }
    return ans;
}
void init(int n)
{
    FOR(i, 1, n) 
        c[i][0] = 1;
    FOR(i, 1, n)
        FOR(j, 1, i) 
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % p;
    jc[0] = 1;
    FOR(i, 1, n) 
        jc[i] = jc[i - 1] * i % p;
    FOR(i, 1, n) 
        inv[i] = quickpow(jc[i], p - 2);
    b[0] = 1;
    FOR(i, 1, n * n) 
        b[i] = b[i - 1] * m % p;
}
int gcd(int x, int y) {
    if (g[x][y]) 
        return g[x][y];
    int r;
    while (y) {
        r = x % y;
        x = y; 
        y = r;
    }
    return g[x][y] = x;
}
void DFS(int x, int now)
{
    if (!now) {
        int n1 = x - 1; 
        int sum = 0;
        FOR(i, 1, n1)
            FOR(j, i + 1, n1) 
                sum += gcd(a[i], a[j]);
        FOR(i, 1, n1) 
            sum += a[i] / 2;
        ll tot = 1; 
        int cnt = n;
        FOR(i, 1, n1)
            tot = tot * c[cnt][a[i]] % p, cnt -= a[i];
        FOR(i, 1, n)
            if (k[i]) 
                tot = tot * inv[k[i]] % p;
        FOR(i, 1, n1) 
            tot = tot * jc[a[i] - 1] % p;
        ans = (ans + tot * b[sum]) % p;
        return;
    }
    for (int i = a[x - 1]; i <= now; i++) {
        k[i]++; 
        a[x] = i;
        DFS(x + 1, now - i);
        k[i]--;
    }
}
int main()
{
    scanf("%d%d%lld", &n, &m, &p);
    if (n == 1) {
        printf("1\n");
        return 0; 
    }
    a[0] = 1;
    init(53); 
    DFS(1, n);
    ans = ans * quickpow(jc[n], p - 2) % p;
    printf("%lld\n", ans);
}
```


---

## 作者：Aquizahv (赞：2)

没想到用 $\gcd$ 做，呜呜。

不过这题貌似暴力数轮换个数就行？

---

### 思路

根据 [Pólya 计数原理](https://oi-wiki.org/math/combinatorics/polya/#p%C3%B3lya-%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86)，答案就是
$$
\frac{1}{n!}\sum_{所有置换} m^{边轮换个数}
$$

但是这个题肯定不能暴力枚举 $n!$ 种置换。

其实有很多置换是重复的，这样就可以只计算本质不同的置换。

具体的，我们把一个置换看成所有轮换的大小的集合 **（注意这里是点轮换，与上文中的边轮换不同）**，比如说
$$
\begin{bmatrix}
   1 & 2 & 3 & 4 & 5 & 6 \\
   1 & 3 & 4 & 2 & 6 & 5
\end{bmatrix}
$$

注意到轮换有 $\{1\},\{2,3,4\},\{5,6\}$，大小分别为 $1,3,2$，那可以把这种置换看成 $\{1,2,3\}$ 的集合。

然后如果两个置换的这种集合相同，染色方案肯定也一样（因为是完全图，点可以随意编号）。

那就只用枚举这样的集合，即 $n$ 的正整数拆分，最后再乘上个组合数。经验证，$53$ 的拆分方案只有 $329931$ 种。

然后对于每一种拆分，构造一组合法的置换，然后数边轮换个数即可。

如果预处理一些东西，时间复杂度是 $\mathcal{O}(拆分个数 \times n^2$）的。看似很大，然而开 O2 之后可以跑进 1s。

### 代码

```cpp
// Author: Aquizahv
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1000;
int n, m, MOD, facn, inv[N], po[N * N], invfac[N];
vector<int> v;
int p[N], ans;
bool vis[N][N];

inline int A(int x, int y) { return x + y >= MOD ? x + y - MOD : x + y; }
inline int S(int x, int y) { return A(x, MOD - y); }
inline int W(int x, int y) { return 1ll * x * y % MOD; }
inline int P(int x, int y) { int res = 1, t = x % MOD;
    while (y) { if (y & 1) res = W(res, t);
    t = W(t, t); y >>= 1; }
    return res; }
inline int D(int x, int y) { return W(x, P(y, MOD - 2)); }
inline int Q(int x) { return W(x, x); }

int cal()
{
    int i = 0;
    for (auto j : v)
    {
        for (int k = 1; k <= j; k++)
            p[i + k] = i + k + 1;
        p[i + j] = i + 1;
        i += j;
    }
    while (i < n)
    {
        i++;
        p[i] = i;
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            vis[i][j] = false;
    int res = 0;
    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
        {
            if (vis[i][j])
                continue;
            res++;
            int x = i, y = j;
            while (!vis[x][y])
            {
                vis[x][y] = vis[y][x] = true;
                x = p[x], y = p[y];
            }
        }
    return po[res];
}

void dfs(int i, int sum, int cnt)
{
    if (i == 1) // 从大到小拆，拆到 1 直接填满就好了
    {
        cnt = W(cnt, invfac[sum]);
        ans = A(ans, W(cal(), cnt));
        return;
    }
    for (int j = 0; sum >= 0; sum -= i, cnt = W(cnt, W(inv[i], inv[++j])), v.push_back(i))
        dfs(i - 1, sum, cnt);
    while (!v.empty() && v.back() == i)
        v.pop_back();
}

int main()
{
    cin >> n >> m >> MOD;
    m %= MOD;
    facn = inv[0] = po[0] = invfac[0] = 1;
    for (int i = 1; i <= n; i++)
    {
        facn = W(facn, i);
        invfac[i] = D(1, facn);
        inv[i] = D(1, i);
    }
    for (int i = 1; i <= n * n; i++)
        po[i] = P(m, i);
    dfs(n, n, facn);
    cout << D(ans, facn) << endl;
    return 0;
}
```

---

如果有任何错误或者疑问，欢迎评论或私信指出！

---

## 作者：Corzica (赞：2)

这个问题是对边集的一个染色问题

我们要考虑，点的置换后的等价类的集合，对我们边集的等价类情况的影响

换句话讲，我们要把在点集上的置换转化成在边集上的置换

考虑两个点集上的等价类对边集的影响

发现，两个点的等价类会使得边集等价类的个数增加 $gcd(siz_i,siz_j)$。而点集等价类自身又会增加 $\left\lfloor\dfrac{siz}{2}\right\rfloor$
 个边集等价类。（可以自己手玩一下）
 
然后直接搜一下，发现本质不同的点的等价集的情况只有 $4e5$ 左右，算上我们单次处理的枚举的 $gcd$，只有不到 $1e8$。
 
所以直接搜，然后处理每一个情况的边集的等价集大小和这种点集的出现情况数量，乘起来求和，最后除以总的置换个数就是答案。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long
int cnt, n, m, a[60], mod, jie[60], inv[60], g[60][60], col;
int ans;
using namespace std;
inline int ksm(int p, int q) {
	int base = 1;
	while (q) {
		if (q & 1) base = base * p % mod;
		q >>= 1;
		p = p * p % mod;
	}
	return base;
}
inline int C(int p, int q) {
	if (p < 0 || q < 0 || p < q) return 0;
	return jie[p] * inv[q] % mod * inv[p - q] % mod;
}
inline void solve(int p) {
	int cnt = 0, aans = 1;
	for (int i = 1; i <= p; i++) {
		for (int j = i; j <= p; j++) {
			if (i == j) cnt += a[i] / 2;
			else cnt += g[a[i]][a[j]];
		}
	}
	cnt = ksm(col, cnt);
	int lst = 1, u = n;
	for (int i = 2; i <= p; i++) {
		if (a[i] != a[i - 1]) {
			aans = (aans * (C(u, a[lst] * (i - lst)) * jie[a[lst] * (i - lst)] % mod * ksm(ksm(a[lst], mod - 2), i - lst) % mod * inv[i - lst] % mod) % mod);
			u -= a[lst] * (i - lst);
			lst = i;
		}
	}
	aans = (aans * (C(u, a[lst] * (p + 1 - lst)) * jie[a[lst] * (p + 1 - lst)] % mod * ksm(ksm(a[lst], mod - 2), p + 1 - lst) % mod * inv[p + 1 - lst] % mod) % mod);
	ans += (aans * cnt) % mod;
	ans %= mod;
}
inline void dfs(int p) {
	if (a[p - 1] > m / 2) {
		a[p] = m;
		solve(p);
		return;
	}
	a[p] = m;
	solve(p);
	int op = m;
	for (int i = max(1ll, a[p - 1]); i <= op / 2; i++) {
		a[p] = i;
		m = op - i;
		dfs(p + 1);
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> col >> mod;
	jie[0] = 1;
	for (int i = 1; i <= n; i++) {
		jie[i] = jie[i - 1] * i % mod;
	}
	inv[n] = ksm(jie[n], mod - 2);
	for (int i = n - 1; i >= 0; i--) {
		inv[i] = (i + 1) * inv[i + 1] % mod;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			g[i][j] = __gcd(i, j);
		}
	}
	m = n;
	dfs(1);
	cout << ans*inv[n] % mod ;
}
```

---

## 作者：Zi_Gao (赞：1)

## 0x00 Burnside's lemma

这里需要一点群论的知识，设 $G$ 是一个置换群群，将作用在集合 $X$ 上，有以下结论：

$$
\left|X/G\right|=\frac{1}{\left|G\right|}\sum_{g\in G} \left|X^g\right|
$$

- 其中 $X/G$ 表示集合 $X$ 在群 $G$ 作用下的本质不同元素集合，那么 $\left|X/G\right|$ 则表示本质不同元素个数，即轨道数。
- $g$ 表示置换群 $G$ 中的一个置换。
- $X^g$ 表示集合 $X$ 在置换 $g$ 变换下，$X$ 集合中的不动点，$\left|X^g\right|$ 自然表示不动点数。

对于这个题来说 $X$ 就是 $n$ 个点的简单无向图集合，一共 $2^{{n\choose 2}}$ 个。$G$ 就是点标号的置换的集合，即排列的集合，一共 $n!$ 个。$g$ 就是一个排列，$\left|X^g\right|$ 则表示按照 $g$ 对图重标号后，有多少个图和原来一样。

若两个图同构，说明可以通过重标号一个图的方式得到另一个图，所以说 $\left|X/G\right|$ 就等于有多少个不同构的数。这样转化重点就是计算 $\left|X^g\right|$。

## 0x01 计算 $\left|X^g\right|$

假设有一个 $g$，怎么计算 $\left|X^g\right|$，显然只需要关注边的情况，什么情况下一个图在 $g$ 变换后与原图相同呢？假设现在有两个点 $u,v$，则他们重编号映射后就是 $g_{u},g_{v}$，由于要和原图相同，所以 $u,v$ 的连边情况和原图要是相同的。这意味着在 $g$ 的变化下有一些边是等价的，对于某一个等价类，要么全连上要么全不连，假设有 $k$ 个等价类，则有 $2^k$ 个图是不动点，即 $\left|X^g\right|=2^k$。

## 0x02 计算 $k$

寻找等价类的过程就是从某一条边 $u\leftrightarrow v$ 出发，然后寻把 $g_{u}\leftrightarrow g_{v}$ 这条边合并到一个等价类，然后 $g_{g_u}\leftrightarrow g_{g_v}$ 合并，相当于是 $u,v$ 每次分别走到 $g$ 变换的点去，然后重复过程，直到回到最初的点，自然想到把 $g$ 拆成若干个置换环。现在分类讨论 $u,v$ 所在置换环的情况：

1. $u,v$ 在同一个置换环中，设置换环长度为 $b$，显然 $u,v$ 同时走 $b$ 步之后会回到最初的点，并且过程中 $u,v$ 在置换环上的间距保持不变，那么在每一个等价类对应一个间距，故共有 $\left\lfloor\frac{b}{2}\right\rfloor$ 个等价类。
2. $u,v$ 不在同一个置换环中，设置换环长度分别为 $b_1,b_2$ 和刚才一样，每次 $u,v$ 都分别走到 $g$ 变换的点去，要走 $\text{lcm}(b_1,b_2)$ 才能回到最初出发的边，也就是等价类里面一共有 $\text{lcm}(b_1,b_2)$ 条边。而两个置换环之间一共能连出 $b_1b_2$ 条边，所以一共有 $\frac{b_1b_2}{\text{lcm}(b_1,b_2)}=\gcd(b_1,b_2)$ 个等价类。

设当有 $m$ 个置换环，置换环长度分别为 $b_i$，根据上面的推论有：

$$
k=\sum_{i=1}^m\left\lfloor\frac{b_i}{2}\right\rfloor+\sum_{i=1}^m\sum_{j=1}^{i-1}\gcd(b_i,b_j)
$$

## 0x03 统计排列

直接枚举排列显然是不行的，但是发现若排列的置换环长度 $b$ 序列相同，贡献也是相同的，于是直接枚举 $b$，即 $n$ 的一个整数拆分。考虑计算有多少个排列的置换环长度是 $b$，先考虑把 $n$ 个数划分到每一个置换环里面，再考虑置换环内部排列方式。随便放有 $n!$ 个排列，但是每一个置换环内部的排列先不计算，所以要除去 $b_i!$，但是长度相同的置换环交换还是同样的情况，所以也要出去，设长度为 $i$ 的置换环有 $c_i$ 个，就是要除 $c_i!$，所以划分方案一共是：

$$
\frac{n!}{\prod (b_i!)\prod (c_i!)}
$$

现在考虑置换环内部的排列情况，显然就是圆排列，有 $(b_i-1)!$ 个，最终就是：

$$
\frac{n!\prod (b_i-1)!}{\prod (b_i!)\prod (c_i!)}=\frac{n!}{\prod b_i\prod (c_i!)}
$$

把前面提到的式子整理一下：

$$
\begin{aligned}
\left|X/G\right|&=\frac{1}{\left|G\right|}\sum_b \frac{n!2^k}{\prod b_i\prod (c_i!)}\\
&=\frac{1}{n!}\sum_b \frac{n!2^k}{\prod b_i\prod (c_i!)}\\
&=\sum_b \frac{2^k}{\prod b_i\prod (c_i!)}\\

k&=\sum_{i=1}^m\left\lfloor\frac{b_i}{2}\right\rfloor+\sum_{i=1}^m\sum_{j=1}^{i-1}\gcd(b_i,b_j)
\end{aligned}
$$

## 0x04 扩展问题

这道题中每一个图相当于是对边染色了，出现的染白，没出现的染黑，不妨多搞几个颜色。$n$ 个点的无向完全图，有 $m$ 中颜色，可以给边随意染色，问可以染出多少个本质不同的图。要解决这个问题我们回到计算 $\left|X^g\right|$ 一步，最后的统计 $2^k$ 就是再说染黑还是染白，自然有 $m$ 种颜色就是 $m^k$。

$$
\begin{aligned}
\left|X/G\right|&=\sum_b \frac{m^k}{\prod b_i\prod (c_i!)}\\

k&=\sum_{i=1}^m\left\lfloor\frac{b_i}{2}\right\rfloor+\sum_{i=1}^m\sum_{j=1}^{i-1}\gcd(b_i,b_j)
\end{aligned}
$$

于是就得到了 P4128 一题做法。

```cpp
#include<bits/stdc++.h>
// #define ONLINE_JUDGE
#define INPUT_DATA_TYPE int
#define OUTPUT_DATA_TYPE int
inline __attribute((always_inline)) INPUT_DATA_TYPE read(){register INPUT_DATA_TYPE x=0;register char f=0,c=getchar();while(c<'0'||'9'<c)f=(c=='-'),c=getchar();while('0'<=c&&c<='9')x=(x<<3)+(x<<1)+(c&15),c=getchar();return f?-x:x;}void print(OUTPUT_DATA_TYPE x){if(x<0)x=-x,putchar('-');if(x>9)print(x/10);putchar(x%10^48);return;}

#define INV_DATA_TYPE long long
INV_DATA_TYPE exgcd(INV_DATA_TYPE a,INV_DATA_TYPE b,INV_DATA_TYPE &x,INV_DATA_TYPE &y){
    if(!b){
        x=1;
        y=0;
        return a;
    }
    INV_DATA_TYPE d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}

INV_DATA_TYPE inv(INV_DATA_TYPE n,INV_DATA_TYPE p){
    INV_DATA_TYPE x,y;
    exgcd(n,p,x,y);
    x%=p;
    return x>=0?x:x+p;
}

long long mod,modp;
int b[70],gcd[70][70],m,p;
long long fact[1000],pwm[100000],res;

void calc(int K){
    register int i,j,k=0,cnt=0;
    register long long v=1;
    b[K]=-1;
    for(i=0;i<K;++i){
        k+=b[i]>>1;
        (v*=b[i])%=mod;

        ++cnt;
        if(b[i]!=b[i+1]){
            (v*=fact[cnt])%=mod;
            cnt=0;
        }

        for(j=0;j<i;++j)
            k+=gcd[b[i]][b[j]];
    }
    (res+=inv(v,mod)*pwm[k])%=mod;
}

void dfs(int st,int rst){
    if(!rst){
        calc(st);
        return;
    }
    for(;b[st]<=rst;++b[st]){
        b[st+1]=b[st];
        dfs(st+1,rst-b[st]);
    }
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("name.in", "r", stdin);
	freopen("name.out", "w", stdout);
	#endif

    register int i,j;
    int n=read();
    m=read();
    modp=(mod=read())-1;
    for(i=0;i<=n;++i)
        for(j=0;j<=n;++j)
            if(i==0||j==0)
                gcd[i][j]=i|j;
            else{
                if(i>=j) gcd[i][j]=gcd[i-j][j];
                else gcd[i][j]=gcd[i][j-i];
            }

    for(fact[0]=i=1;i<=n;++i) fact[i]=fact[i-1]*i%mod;
    for(pwm[0]=i=1;i<=n*n;++i) pwm[i]=pwm[i-1]*m%mod;

    b[0]=1;
    dfs(0,n);

    print(res);

	#ifndef ONLINE_JUDGE
	fclose(stdin);
	fclose(stdout);
	#endif
    return 0;
}
```

---

## 作者：YangJZHello (赞：1)

## [P4128 [SHOI2006] 有色图](https://www.luogu.com.cn/problem/P4128)
### 题目大意
给出条件：有 $n$ 个点的无向完全图，点无颜色，边的颜色种类数不超过 $m$。求所有满足条件的**本质不同**的图的个数模 $p$ 的余数。
### 数据范围
$n\in[1,53],m\in[1,1000],p\in(n,10^9]$ 且 $p$ 为素数。

---
由题意中的『本质不同』可想到群论中的 Pólya 定理。

将所有满足条件的图的集合记为 $X$，点置换群记为 $G$，令 $G(X)$ 表示 $G$ 作用于 $X$ 后所有本质不同的图构成的集合，$h_g$ 表示点置换 $g$ 对应的边置换，$\mu(h_g)$ 表示边置换 $h_g$ 的边循环节数。则由 Pólya 定理可以得到：
$$|G(X)|=\frac{1}{|G|}\sum_{f\in G}{m^{\mu(h_f)}}$$
由题意可得 $G$ 包括所有长度为 $n$ 的置换，则 $|G|=n!$，故上式可写为：
$$|G(X)|=\frac{1}{n!}\sum_{f\in G}{m^{\mu(h_f)}}$$
此时我们只需计算出对于每个确定的点置换 $f$，$\mu(h_f)$ 的对应值。

将点置换 $f$ 用不相交的点循环之积表示为：$f=\prod{w_i}$。则对于每一条边，其两个端点要么在同一个点循环内，要么在不同的两个点循环内。对其进行分类讨论：

1. 当两个端点在同一个点循环 $w_i$ 内时，记 $w_i=(a_1\ a_2\ \cdots\ a_k)$，设一条边 $a_sa_{s+r}$ 的长度为 $r$，则其经过置换后变为 $a_{s+1}a_{s+r+1}$，其长度仍为 $r$，故所有长度相等的边在同一个边循环内，而点循环 $w_i=(a_1\ a_2\ \cdots\ a_k)$ 中边的长度共有 $\lfloor \frac{k}{2}\rfloor$ 种，故 $\mu(v_i)=\lfloor \frac{k}{2}\rfloor=\lfloor \frac{|w_i|}{2}\rfloor$;

2. 当两个端点在不同的两个点循环 $w_i$，$w_j$ 内时，记 $w_i=(a_1\ a_2\ \cdots\ a_l)$，$w_j=(b_1\ b_2\ \cdots\ b_k)$，设一条边 $a_sb_{s+r}$ 的长度为 $r+1$，则其经过置换后变为 $a_{s+1}b_{s+r+1}$，其长度仍为 $r+1$，故所有长度相等的边在同一个边循环内，点循环 $w_i$ 和 $w_j$ 中所有的点所能构成的边共有 $k\cdot l$ 个，而长度为 $r$ 的边有 $lcm(k,l)$ 个，故边的长度共有 $\frac{k\cdot l}{lcm(k,l)}=\gcd(k,l)$ 种，故 $\mu(v_{ij})=\gcd(k,l)=\gcd(|w_i|,|w_j|)$。

综上所述，可得：
$$\mu(h_f)=\mu(\prod{v_i}\cdot\prod_{i<j}{v_{ij}})=\sum{\mu(v_i)}+\sum_{i<j}{\mu(v_{ij})}$$
$$=\sum{\lfloor\frac{|w_i|}{2}\rfloor}+\sum_{i<j}{gcd(|w_i|,|w_j|)}$$
则原式可转化为：
$$|G(X)|=\frac{1}{n!}\sum_{f\in G}{m^{\sum{\lfloor\frac{|w_i|}{2}\rfloor}+\sum_{i<j}{gcd(|w_i|,|w_j|)}}}$$

然而，如果枚举每个点置换 $f$ ，枚举操作的时间复杂度会达到 $O(n!)$，在数据范围内会 TLE。所以还需要继续优化上式。

经过观察，我们发现枚举每个 $f$ 时，所加的值只与各点循环的长度有关，而与点循环内部的具体排列无关。故只需要对 $n$ 进行拆分，计算每个拆分对应的值即可。

若现有一个确切的拆分方案 $A$， $A_i$ 表示第 $i$ 个循环的长度，且满足 $A_1\leq A_2 \leq A_3 \leq\cdots$，对于拆分方案 $A$，需计算满足这种方案的点置换总数。

让 $n$ 个点排列在每个循环中，总方案数为 $\frac{n!}{\prod{A_i!}\prod{num_i!}}$，其中 $num_i$ 表示长度为 $i$ 的循环数。对于每组固定长度 $A_i$ 的循环，可以有 $(A_i-1)!$ 种不同的循环，故点置换数为 $\frac{n!}{\prod{A_i!}\prod{num_i!}}\times \prod{(A_i-1)!}=\frac{n!}{\prod{A_i}\prod{num_i!}}$。

综上所述，原式可转化为：
$$|G(X)|=\frac{1}{n!}\sum_{A}{\frac{n!}{\prod{A_i}\prod{num_i!}}m^{\sum{\lfloor\frac{|w_i|}{2}\rfloor}+\sum_{i<j}{gcd(|w_i|,|w_j|)}}}$$
$$=\sum_{A}{\frac{1}{\prod{A_i}\prod{num_i!}}m^{\sum{\lfloor\frac{|w_i|}{2}\rfloor}+\sum_{i<j}{gcd(|w_i|,|w_j|)}}}$$

方案 $A$ 的选择直接 DFS 即可。

参考代码：
```cpp
#include <iostream>
#include <vector>
#include <utility>

#define ll long long
#define re register
#define rep(i, s, t) for(re ll i=s; i<=t; ++i)
#define dualrep(i, s1, t1, j, s2, t2) for(re ll i=s1; i<=t1; ++i) for(re ll j=s2; j<=t2; ++j)

namespace hel {
    ll p, ans, frac, po, tx, ty;
    int n, m, c;
    std::vector<int> S;
    inline ll gcd(ll x, ll y) {
        if(x%y) return gcd(y, x%y);
        else return y;
    }
    inline ll exgcd(ll a, ll b, ll &x, ll &y) {
        if(a==1) {
            x = 1, y = 0;
            return x;
        }
        else {
            ll d = exgcd(b, a%b, y, x);
            y -= (a/b)*x;
            return x;
        }
    }
    inline ll qpow(ll x, ll k) {
        ll ans=1, base=x;
        while(k) {
            if(k&1) ans = ans*base%p;
            base = base*base%p;
            k >>= 1;
        }
        return ans;
    }
    inline void dfs(int pos, ll rest) {
        if(!rest) {
            frac = 1, c = 1, po = 0;
            rep(i, 0, S.size()-1) {
                po = (po+(S[i]>>1))%p;
                frac = frac*S[i]%p;
                if(i) if(S[i]==S[i-1]) ++c;
                else c=1;
                frac = frac*c%p;
            }
            dualrep(i, 0, S.size()-1, j, i+1, S.size()-1) {
                po = (po+gcd(S[i], S[j]))%(p-1);
            }
            ans = (ans+exgcd(frac, p, tx, ty)*qpow(m, po)%p)%p;
            return;
        }
        else {
            rep(i, pos?S[pos-1]:1, rest) {
                S.push_back(i);
                dfs(pos+1, rest-i);
                S.pop_back();
            }
            return;
        }
    }
    ll mod(ll a, ll b) {
        if(a>=0) return a%b;
        else {
            return b-((-a)%b);
        }
    }
    void main() {
        std::ios::sync_with_stdio(false);
        std::cin.tie(nullptr);
        std::cin >> n >> m >> p;
        dfs(0, n);
        std::cout << mod(ans, p);
        return;
    }
}

int main() {
    hel::main();
    return 0;
}
```


---

## 作者：Z1qqurat (赞：1)

有色图！

看起来是个置换群计数状物，果断将重标号方式看作群的置换。之前做的置换群计数都是对点染色，这是对边染色的。那么总的置换方式数就是 $n$ 阶排列数，$n!$。接下来考虑对每一种置换，如何计算它的等价类个数 $f$，从而得到不动点个数 $m^f$。

考虑一种置换：原标号为 $\{1,2,3,4,5,6\}$，置换后为 $\{2 ,3,1,4,6,5\}$。将其分解为 $3$ 个循环：$\{2,3,1\}, \{4\}, \{6,5\}$。那么每个循环内部都是一个小的完全图。考虑将边分类。

* 该边两个端点在同一个循环内。那么对于一个长度为 $b_i$ 的循环，相当于一个 $b_i$ 阶无向完全图，其中连出来长度相等的边属于同一个等价类。该图内一共有 $\left\lfloor\frac{b_i}{2}\right\rfloor$ 种不同长度的边，所以贡献 $\left\lfloor\frac{b_i}{2}\right\rfloor$ 个等价类。

![](https://pic.imgdb.cn/item/657123b6c458853aef014893.png)

* 该边两个端点在不同循环内。那么设这两个循环的长度分别为 $b_1, b_2$，一共就有 $b_1b_2$ 条边，每条边在 $\text{lcm}(b_1,b_2)$ 次旋转后回到原来位置，故共有 $\frac{b_1b_2}{\text{lcm}(b_1,b_2)} = \text{gcd}(b_1,b_2)$ 个等价类。

总共贡献了 $\sum\limits_{i=1}^{k} \left\lfloor\frac{b_i}{2}\right\rfloor + \sum\limits_{i=1}^{k} \sum\limits_{j=1}^{i-1} \text{gcd}(b_i,b_j)$ 个等价类。

考虑降低复杂度。发现结果与具体排列无关，如果两个置换的 $b$ 对应的数集相等，这两个置换的等价类个数相等，可视为同类置换，统一计算。枚举 $n$ 的拆分即可。

P4727 是一样的，相当于有色图的 $m=2,P=997$ 特殊情况，其实这两题难度上没有太大差别的说。

```cpp
#include <bits/stdc++.h>
#define ALL(v) begin(v), end(v)
using i64 = int64_t;
using std::cin;
using std::cout;
constexpr int N = 65;

int n, m;
i64 P, ans;
std::array<int, N> b, c;
std::array<i64, N> fac;

auto qpow(i64 x, int y) {
   auto ret = i64{1};
   for (; y; x = x * x % P, y >>= 1) {
      if (y & 1) ret = ret * x % P;
   }
   return ret;
}

auto dfs(int u, int sum) -> void {
   if (sum > n) return ;
   if (sum == n) {
      c.fill(0);
      for (auto i = 1; i < u; ++i) c[b[i]]++;
      auto f = i64{0}, x = i64{1};
      for (auto i = 1; i < u; ++i) {
         f += (b[i] >> 1), x = i64{x * b[i] % P};
         for (auto j = 1; j < i; ++j) 
            f += std::__gcd(b[i], b[j]);
      }
      for (auto i = 1; i <= n; ++i) x = i64{x * fac[c[i]] % P};
      ans = (ans + qpow(m, f) * qpow(x, P - 2) % P) % P;
      return ;
   }

   for (auto i = std::max(1, b[u - 1]); i <= n; ++i) 
      b[u] = i, dfs(u + 1, sum + i);
   return ;
}

auto main() -> int {
   std::ios::sync_with_stdio(false);
   cin.tie(nullptr), cout.tie(nullptr);

   cin >> n >> m >> P, fac[0] = 1;
   for (auto i = 1; i <= n; ++i) fac[i] = i64{fac[i - 1] * i % P};
   dfs(1, 0);
   cout << ans << "\n";
   return 0;
}
```

---

## 作者：xlpg0713 (赞：1)

数数题大好き！[双倍经验](https://www.luogu.com.cn/problem/P4727)的数数题世界で一番好きな！

# 初步分析

发现 P4727 可以视为 $n$ 个点的完全图，每条边可以染两种不同的颜色，最后同构的有色图计数，故只分析 P4128。

请确保你掌握了有关群论的相关知识。具体地，这道题还利用到了轮换的性质。推销一下我的[博客](https://www.cnblogs.com/xlpg-0713/articles/18009812)。

题目考虑的是在一些变换下**同构**的图计数，考虑 Burnside 引理。

染色是作用在边集上的映射，而同构的定义是基于点集上的置换的。需要考虑能否在点置换和边置换之间建立联系。

对于一个点置换 $\left (\begin{matrix}1,2\cdots n\\p_1,p_2\cdots p_n\end{matrix}\right )$ 我们让它对应边置换 $\left (\begin{matrix}(1,2),(1,3)\cdots (i,j)\cdots (n-1,n)\\(p
_1,p_2),(p_1,p_3)\cdots (p_i,p_j)\cdots (p_{n-1},p_n)\end{matrix}\right )$。


发现若可以把一个边置换拆成若干个边轮换，例如 $\left((a_1,a_2),(a_2,a_3)\cdots (a_{k-1},a_k)\right)$ 则**对应它**的点置换中，一定有一个轮换为 $\left(a_1,a_2\cdots a_k\right)$。即点轮换和边轮换一一对应。我们知道一个置换可以拆成不同的轮换乘积，可以证明，拆出边轮换的不同方式，对应到点轮换中的乘积一定：即一个边轮换只对应一个点轮换。

在此，我们证明了点置换和边置换之间存在双射关系，边置换的规模和点置换同为 $n!$。以下的讨论中不再专门区分点置换和边置换。注意这里关于点轮换和边轮换的对应关系只用于证明点置换和边置换之间存在双射，不用于具体的计数。

# 计数

现在让我们考虑在一个置换下不动点的个数。

显然地，若可以把一个边置换由若干个不相交的 $x$ 个轮换，则不动点个数为 $m^x$，其中 $m$ 是颜色数，这是因为要保证一个轮换之内的边颜色相同。

所以现在要解决：一个点置换对应的边置换中，边轮换的数量。

将边轮换分成两类来计算：所有的点都在同一个点轮换中，一条边的两个点在两个不同的点轮换中。因为边是二元关系，所以不存在边轮换同时跨越了三个及以上的轮换。

1.在同个点轮换中的边轮换数

![](https://cdn.luogu.com.cn/upload/image_hosting/u6xz3g5r.png)

画个图，发现五个点的轮换构成了两个边轮换，六个点的图构成了三个边轮换（注意红色的边并不能构成任何边轮换），以此类推，可得结论：$n$ 个点的点轮换构成了 $\lfloor\frac{n}{2}\rfloor$ 个边轮换。

2.不同点轮换中的边轮换数

考虑两个点轮换，大小分别为 $a_1,a_2$。两个轮换之间有 $a_1a_2$ 条边，一条边经过 $
\operatorname{lcm}(a_1,a_2)$ 次轮换后与原来相同，故共有 $\frac{a_1a_2}{\operatorname{lcm}(a_1,a_2)}=\operatorname{gcd}(a_1,a_2)$ 组轮换。

现在有了一个朴素的方法：枚举一个点置换，将之分解成轮换后计算答案，但显然 $n=60$ 过不了。

# 方法的改进
考虑两个不同的置换，若分解成轮换后，点轮换的大小组成的可重集相等，这两种置换在计算答案时被我们认为是等价的。

若置换拆分后可以表述为 $(a_1,a_2\cdots a_k)$，满足 $\forall i\in[1,k-1],a_i\le a_{i+1}\land\sum a_i=n$，我们需要计算满足有 $k$ 个轮换，第 $i$ 个轮换的点数是 $a_i$ 的方案计数。

首先考虑把 $n$ 个数分到 $k$ 个可重集的方案数是 $\frac{n!}{\prod a_i!}$，每个集合内部不区分顺序，要乘上 $\prod (a_i-1)!$，点数相同的集合之间不区分顺序，要乘上 $\prod c_i!$，$c_i$ 表示有 $i$ 个点的轮换个数。

故总个数为 $\frac{n!}{\prod a_i\prod c_i!}$。答案是 $\sum\limits_{(a_1,a_2\cdots a_k)}\frac{m^{\sum\lfloor\frac{a_i}{2}\rfloor+\sum\limits_{i,j}\operatorname{gcd}(i,j)}}{\prod a_i\prod c_i!}$。

dfs 出所有合法的方案后进行计数，复杂度能过。

只给出 P4128 的代码

```cpp
#include<iostream>
#include<algorithm>
int n, m, p, rs, a[60], c[60], fc[60];
inline int qp(int a, int b){ int r = 1;
	for(; b; b >>= 1, a = 1ll * a * a % p)
		b & 1 ? r = 1ll * r * a % p : 0; return r;
}
inline void dfs(int x, int k, int t){
	if(x == n){
		int f = 0, g = 1; for(int i = 1; i <= k; i++) f += a[i] >> 1, g = 1ll * g * a[i] % p;
		for(int i = 1; i <= k; i++) for(int j = i+1; j <= k; j++) f += std::__gcd(a[i], a[j]);
		for(int i = 1; i <= t; i++) g = 1ll * g * fc[c[i]] % p;
		(rs += 1ll * qp(m, f) * qp(g, p - 2) % p) %= p; return;
	}
	for(int i = t+1; i <= n - x; i++){
		for(int j = 1; x + i*j <= n; j++)
			a[k+j] = i, ++c[i], dfs(x+i*j, k+j, i);
		c[i] -= (n - x) / i;
	}
}
int main(){
	std::cin >> n >> m >> p; fc[0] = 1;
	for(int i = 1; i <= n; i++) fc[i] = 1ll * fc[i - 1] * i % p;
	dfs(0, 0, 0); std::cout << rs;
}
```

---

## 作者：lupengheyyds (赞：0)

摘自：[Burnside 引理学习笔记](https://www.cnblogs.com/lupengheyyds/p/18948535)。

还是考虑一个置换：
$$
\begin{pmatrix}
1&2&\cdots&n\\
a_1&a_2&\cdots&a_n
\end{pmatrix}
$$
设 $e(i,j)$ 表示边 $(i,j)$ 的颜色，在这个置换下两个元素等价，要求对于任意的 $i,j$，$e(i,j)=e(a_i,a_j)=e(a_{a_i},a_{a_j})=\cdots$，假设这样的等式链有 $k$ 条，则不动点的个数 $|X^g|=m^k$。

于是考虑对这样的条数计数，设 $i,j$ 在两个不同的轮换 $C_1,C_2$（一种特殊的置换，满足从任意点出发可以到达任意点，可以理解为环）中，则对于一条边 $(p,q)$，$p$ 每 $|C_1|$ 次出现循环，$q$ 每 $|C_2|$ 次出现循环，所以等式链长为 $\operatorname{lcm}(|C_1|,|C_2|)$，一共有 $\gcd(|C_1|,|C_2|)$ 条。若 $i,j$ 在一个轮换 $C$ 里，那么每条等式链长度一定为 $|C|$，并且会将一条边计算正反两遍，所以一共有 $\lceil\frac{|C|(|C|-1)}{2|C|}\rceil=\lfloor\frac{|C|}2\rfloor$ 条等式链。

所以 $k=\sum_{i<j}\gcd(|C_i|,|C_j|)+\sum_i\lfloor\frac{|C_i|}2\rfloor$。

得到：
$$
\sum_{g\in G}|X^g|=\sum_{x_1+x_2+\cdots+x_k=n}g(x_1,x_2,\cdots,x_k)mxp({\sum_i\lfloor\frac{x_i}2\rfloor+\sum_{i<j}\gcd(x_i,x_j)})\prod_{i-1}^kf[x_i]
$$

其中 $x$ 为 $n$ 的一种分拆数方案（可以直接枚举），$mxp(n)=m^n$，$f[n]$ 表示大小为 $n$ 的轮换数，$g(x_1,x_2,\cdots,x_k)$ 表示将 $n$ 个数分成无序的 $k$ 部分，大小分别为 $x_1,x_2,\cdots,x_k$ 的方案数。

$$
f[n]=n!-\sum_{i=1}^{n-1}f[i](n-i)!{n-1\choose i-1}\\
g(x_1,x_2,\cdots,x_k)={n\choose x_1,x_2,\cdots,x_k}\sum_{c=1}^n(\sum_{i=1}^k[x_i=c])!=\frac{n!}{\prod_{i=1}^kx_i!}\sum_{c=1}^n(\sum_{i=1}^k[x_i=c])!
$$
这都是简单计数，就不赘述了。

复杂度 $\mathcal O(p(n)\times n^2)$，其中 $p(n)$ 表示分拆数。

---


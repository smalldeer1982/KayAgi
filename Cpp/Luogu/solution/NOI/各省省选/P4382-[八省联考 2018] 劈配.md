# [八省联考 2018] 劈配

## 题目背景

一年一度的综艺节目《中国新代码》又开始了。Zayid 从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。

## 题目描述

轻车熟路的 Zayid 顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：

总共 $n$ 名参赛选手（编号从 $1$ 至 $n$ ）每人写出一份代码并介绍自己的梦想。接着 由所有导师对这些选手进行排名。为了避免后续的麻烦，规定**不存在排名并列的情况**。

同时，每名选手都将独立地填写一份志愿表，来对总共 $m$ 位导师（编号从 $1$ 至 $m$ ）作出评价。志愿表上包含了共 $m$ 档志愿。对于每一档志愿，选手被允许填写最多 $C$ 位导师，每位导师最多被每位选手填写**一次**（**放弃某些导师也是被允许的**）。

在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。节目组对“前 $i$ 名的录取结果最优”作出如下定义：

- 前 $1$ 名的录取结果最优，**当且仅当**第 $1$ 名被其最高非空志愿录取（**特别地**，如果第 $1$ 名没有填写志愿表，那么该选手出局）。

- 前 $i$ 名的录取结果最优，当且仅当在前 $i - 1$ 名的录取结果最优的情况下，第 $i$ 名 被其理论可能的最高志愿录取（特别地，如果第 $i$ 名没有填写志愿表，或其所有志愿中的导师战队均已满员，那么该选手出局）。

如果一种方案满足“前 $n$ 名的录取结果最优”，那么我们可以简称这种方案是**最优的**。

举例而言，$2$ 位导师 $\rm T$ 老师、 $\rm F$ 老师的战队人数上限分别都是 $1$ 人；$2$ 位选手 Zayid 、DuckD 分列第 $1$ 、 $2$ 名。那么下面 $3$ 种志愿表及其对应的最优录取结果如表中所示：

![](https://cdn.luogu.com.cn/upload/pic/17003.png)

![](https://cdn.luogu.com.cn/upload/pic/17004.png)

可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。

每个人都有一个自己的理想值 $s_i$ ，表示第 $i$ 位同学希望自己被第 $s_i$ 或更高的志愿录取，如果没有，那么他就会非常沮丧。

现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。

对于每一位选手，Zayid 都想知道下面两个问题的答案：

- 在最优的录取方案中，他会被第几志愿录取。

- 在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。

作为《中国新代码》的实力派代码手，Zayid 当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。

## 说明/提示

- 样例 $1$ 解释

三组数据分别与【题目描述】中的三个表格对应。

对于第 $1$ 组数据：由于选手 $1$ 没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手 $2$ 按原排名就不沮丧，因此他不需要提升排名。

对于第 $2$ 组和第 $3$ 组数据： $1$ 号选手都不需要提升排名。而希望被第一志愿录取的 $2$ 号选手都必须升到第 $1$ 名才能如愿。

- 样例 $2$ 解释

$1$ 号选手的第一志愿只填写了 $2$ 号导师，因此 $1$ 号选手必定被 $2$ 号导师录取。

$2$ 号选手的第一志愿只填写了 $3$ 号导师，因此 $2$ 号选手必定被 $3$ 号导师录取。

由于 $2,3$ 号导师均满员，且 $3,4$ 号选手均填写了 $1$ 号导师，因此他们都会被 $1$ 号导师录取。

所以 $1,2$ 号选手均被第 $1$ 志愿录取，$3$ 号选手被第 $3$ 志愿录取， $4$ 号选手被第 $2$ 志愿录取。

由于他们都如愿以偿了，所以他们都不需要提升名次。


|测试点编号|$n \leqslant$|$m \leqslant$|$C$|其他约定|
|:----:|:---:|:----:|:----:|:----:|
|1| $10$|$1$|$=1$|无|
|2|$10$|$2$|$=2$|$s_i=m$|
|3|$10$|$3$|$=3$|无|
|4|$100$|$100$|$=1$|$b_i=1$|
|5|$100$|$100$|$=1$|无|
|6|$200$|$200$|$=1$|$b_i=1$|
|7|$200$|$200$|$=1$|无|
|8|$100$|$100$|$=10$|无|
|9|$200$|$200$|$=10$|$b_i=1$|
|10|$200$|$200$|$=10$|无|

- 对于所有测试点，保证 $ T \leqslant 5$ 。

- 对于所有测试点钟的所有数据，保证 $ m \leqslant n \leqslant 200, b_i \leqslant n$

## 样例 #1

### 输入

```
3 5
2 2
1 1
2 2
1 2
1 1
2 2
1 1
1 2
1 2
2 1
2 2
1 1
0 1
0 1
2 2```

### 输出

```
2 1
1 0
1 2
0 1
1 3
0 1```

## 样例 #2

### 输入

```
1 5
4 3
2 1 1
3 1 3
0 0 1
3 1 2
2 3 1
2 3 3 3```

### 输出

```
1 1 3 2
0 0 0 0```

# 题解

## 作者：liuzhangfeiabc (赞：37)

蒟蒻强行发一波题解

据说这个题做法多种多样，花样跑匈牙利、dinic，甚至有人跑费用流都过了？

我写的是一种“变形匈牙利”，可能是sdoi全场跑得最快的之一。

大体思路就是，正常跑匈牙利时每个点只能匹配一个点，这里我们强行让每个导师的点可以匹配多个选手。

我们按照序号依次加入一个选手，对于每位选手枚举每个志愿的每个导师。

如果当前导师的名额还没用完，直接匹配成功。

否则，对这位导师已匹配的选手，再在**同一志愿**内寻找其他导师，能匹配则匹配成功。

这一部分与传统的匈牙利思路是类似的。

至于复杂度，每次加入一个人时，最多将所有人的**某一志愿**全部访问一遍，因此总复杂度是n ^ 2 * c的。

这样一来我们就可以解决第一问了，那么第二问呢？

我们第一个想法就是二分，因为答案显然具有可二分性。

对于每个答案k，先把前k-1个人跑一遍匈牙利，再加入当前这个人即可。

然而如果我们每次都需要重跑一遍匈牙利的话，复杂度就上升到了n ^ 3 c logn,对于0.3s一组数据来说会T。

不过我们可以暴力地记录每一个前缀跑匈牙利的结果，然后每次check时直接在对应版本上加入一个人即可。

总复杂度n ^ 2 c logn，luogu跑到92ms暂时应该是rk1。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
using namespace std;
#define li long long
#define gc getchar()
#define pc putchar
#define kg pc(' ')
#define hh pc('\n')
li read(){
	li x = 0,y = 1;
	char c;
	c = gc;
	while(!isdigit(c)){
		if(c == '-') y = -1;
		c = gc;
	}
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + c - '0';
		c = gc;
	}
	return x * y;
} 
void print(li x){
	if(x < 0){
		pc('-');
		x = -x;
	}
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
int t,c,n,m;
int a[210][210];
int zy[210][210][11],sl[210][210];
int mx[210],b[210];
bool vst[210];
int p1[210],p2[210][210],nw[210],an[210];
int tp1[210][210],tp2[210][210][210],tnw[210][210];
bool dfs(int q,int w){//匈牙利
	int i,j,k,l;
	for(j = 1;j <= sl[q][w];++j){
		k = zy[q][w][j];
		if(vst[k]) continue;
		vst[k] = 1;
		if(nw[k] < mx[k]){
			p1[q] = k;
			p2[k][++nw[k]] = q;
			return 1;
		}
		for(l = 1;l <= mx[k];++l){
			i = p2[k][l];
			if(dfs(i,a[i][k])){
				p1[q] = k;
				p2[k][l] = q;
				return 1;
			}
		}
	}
	return 0;
}
void wk1(){//第一问
	int i,j,k;
	for(i = 1;i <= n;++i){
		memset(vst,0,sizeof(vst));
		for(j = 1;j <= m;++j){
			if(!sl[i][j]) continue;
			if(dfs(i,j)) break;
		}
        //下面是复制匈牙利的结果
		for(j = 1;j <= i;++j) tp1[i][j] = p1[j];
		for(j = 1;j <= m;++j) tnw[i][j] = nw[j];
		for(j = 1;j <= m;++j){
			for(k = 1;k <= nw[j];++k) tp2[i][j][k] = p2[j][k];
		}
	}
}
bool wk2(int q,int w){//第二问的check，表示第q个人如果在第w名是否可行
	int i,j;
	for(i = 1;i <= w - 1;++i) p1[i] = tp1[w - 1][i];
	for(i = 1;i <= m;++i) nw[i] = tnw[w - 1][i];
	for(i = 1;i <= m;++i){
		for(j = 1;j <= nw[i];++j) p2[i][j] = tp2[w - 1][i][j];
	}//copy前w-1个人的结果
	memset(vst,0,sizeof(vst));
	for(i = 1;i <= b[q];++i){
		if(!sl[q][i]) continue;
		if(dfs(q,i)) return 1;
	}
	return 0;
}
int main(){
	int i,j,l,r,mid,as;
	t = read();
	c = read();
	while(t--){
		memset(sl,0,sizeof(sl));
		memset(p1,0,sizeof(p1));
		memset(nw,0,sizeof(nw));
		n = read();
		m = read();
		for(i = 1;i <= m;++i) mx[i] = read();
		for(i = 1;i <= n;++i){
			for(j = 1;j <= m;++j) {
				a[i][j] = read();
				if(a[i][j]) zy[i][a[i][j]][++sl[i][a[i][j]]] = j;
			}
		}
		for(i = 1;i <= n;++i) a[i][0] = m + 1;
		for(i = 1;i <= n;++i) b[i] = read();
		wk1();
		for(i = 1;i <= n;++i) {
			an[i] = a[i][p1[i]];
			print(an[i]);
			kg;
		}
		hh;
		for(i = 1;i <= n;++i){
			if(an[i] <= b[i]){
				putchar('0');kg;continue;
			}
			l = 1;r = i - 1;as = 0;
			while(l <= r){
				mid = l + r >> 1;
				if(wk2(i,mid)) {
					as = mid;
					l = mid + 1;
				}
				else r = mid - 1;
			}
			print(i - as);kg;
		}
		hh;
	}
	return 0;
}
```

update:

鉴于大多数人写的都是dinic，本蒟蒻再斗胆更新一波dinic算法的题解。

原点向每个选手连边，边权为1；每个导师向汇点连边，边权是这个导师的名额上限。

需要注意的一点是，这里的dinic需要动态加边。

同样还是枚举每个人，枚举每个志愿。

把这个人与这个志愿的导师连边，边权为1。

然后在残量网络上跑一次增广路，如果有流则匹配成功。

否则这一组的边就用不上了，不妨直接删除。（据说不这样的话会T?）

这样第1问就解决了。

对于第2问，同样可以二分答案并暴力记录每一个前缀的残量网络，然后直接加上前面所有组的边，跑一次增广路即可判断。

这样一来，由于二分图中dinic的复杂度大约为n * sqrt(n),所以总复杂度大约为n^2 sqrt(n) logn。

~~经过一番丧心病狂的底层优化后~~luogu跑到了180ms，也许是dinic的rk1？

```cpp
#include<bits/stdc++.h>
using namespace std;
int p,c,n,m;
struct edge{
	int fr,to,nxt,pre,val;
}e[10010],te[210][10010];
int tf[210][410],fir[410],dq[410],an[210],tct[210];
int cnt,s,g;
int q[100010],h,t;
int a[210][210],b[210],mx[210];
int sl[210][210],zy[210][210][11];
int vis[410];
#define gc getchar()
#define pc putchar
#define kg pc(' ')
#define hh pc('\n')
#define inf 987654321
#define rg register
inline int read(){
	int x = 0;
	char c;
	c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + c - '0';
		c = gc;
	}
	return x;
}
void print(int x){
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
inline void ins(int u,int v,int w){
	e[++cnt].to = v;e[cnt].nxt = fir[u];e[cnt].fr = u;
	if(fir[u]) e[fir[u]].pre = cnt;
	fir[u] = cnt;e[cnt].val = w;
	e[++cnt].to = u;e[cnt].nxt = fir[v];e[cnt].fr = v;
	if(fir[v]) e[fir[v]].pre = cnt;
	fir[v] = cnt;e[cnt].val = 0;
}
inline void in2(int u,int v,int w){//这里是底层优化
	e[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;e[cnt].val = w;
	e[++cnt].to = u;e[cnt].nxt = fir[v];fir[v] = cnt;e[cnt].val = 0;
}
inline void del(int q){//删边，类似于从链表中删除元素的操作
	if(e[q].nxt) e[e[q].nxt].pre = e[q].pre;
	if(e[q].pre) e[e[q].pre].nxt = e[q].nxt;
	if(q == fir[e[q].fr]) fir[e[q].fr] = e[q].nxt;
}
//以下是dinic
bool bfs(){
	memset(vis,0,g * 4 + 4);
	rg int i,j;
	memcpy(dq,fir,g * 4 + 4);
	h = t = 0;
	q[++t] = s;
	vis[s] = 1;
	while(h < t){
		j = q[++h];
		for(i = fir[j];i;i = e[i].nxt){
			if(e[i].val <= 0) continue;
			if(vis[e[i].to]) continue;
			vis[e[i].to] = vis[j] + 1;
			q[++t] = e[i].to;
		}
	}
	return vis[g];
}
int dfs(int q,int fl){
	if(q == g) return fl;
	int tp,nw = 0;
	for(int &i = dq[q];i;i = e[i].nxt){
		if(e[i].val <= 0) continue;
		if(vis[e[i].to] != vis[q] + 1) continue;
		tp = dfs(e[i].to,min(e[i].val,fl));
		nw += tp;
		e[i].val -= tp;
		e[i ^ 1].val += tp;
		if(nw == fl) return nw;
	}
	if(nw != fl) vis[q] = -1;
	return nw;
}
void wk1(){//第一问
	rg int i,j,k;
	int l;
	for(i = 1;i <= n;++i){
		an[i] = m + 1;
		ins(s,i,1);
		for(j = 1;j <= m;++j){
			if(!sl[i][j]) continue;
			l = cnt;
			for(k = 1;k <= sl[i][j];++k) ins(i,zy[i][j][k] + n,1);//动态加边
			if(bfs() && dfs(s,inf)){
				an[i] = j;
				break;
			}
			else{
				for(k = l;k <= cnt;++k) del(k);//动态删边
				cnt = l;
			}
		}
        //copy残量网络
		for(j = 2;j <= cnt;++j) te[i][j] = e[j];
		for(j = 1;j <= g;++j) tf[i][j] = fir[j];
		tct[i] = cnt;
	}
}
bool wk2(int q,int w){//第二问的check，表示第q个人如果在第w名是否可行
	rg int i,j;
	cnt = tct[w - 1];
	for(i = 1;i <= g;++i) fir[i] = tf[w - 1][i];
	for(i = 2;i <= cnt;++i) e[i] = te[w - 1][i];
    //以上为copy前w-1个人的残量网络
	ins(s,q,1);
	for(i = 1;i <= b[q];++i){
		if(!sl[q][i]) continue;
		for(j = 1;j <= sl[q][i];++j) in2(q,zy[q][i][j] + n,1);
	}
	return bfs() && dfs(s,inf);
}
int main(){
	rg int i,j;
	int l,r,mid,as;
	p = read();
	c = read();
	while(p--){
		memset(sl,0,sizeof(sl));
		memset(fir,0,sizeof(fir));
		cnt = 1;
		n = read();
		m = read();
		s = n + m + 1;
		g = n + m + 2;
		for(i = 1;i <= m;++i) {
			mx[i] = read();
			ins(i + n,g,mx[i]);
		}
		tct[0] = cnt;
		for(i = 1;i <= g;++i) tf[0][i] = fir[i];
		for(i = 2;i <= cnt;++i) te[0][i] = e[i];
        //别忘了把一开始的边也记录下来，我在这里wa了若干次qwq
		for(i = 1;i <= n;++i){
			for(j = 1;j <= m;++j){
				a[i][j] = read();
				if(!a[i][j]) continue;
				zy[i][a[i][j]][++sl[i][a[i][j]]] = j;
			}
		}
		for(i = 1;i <= n;++i) b[i] = read();
		wk1();
		for(i = 1;i <= n;++i){
			print(an[i]);
			kg;
		}
		hh;
		for(i = 1;i <= n;++i){
			if(an[i] <= b[i]){
				pc('0');kg;
				continue;
			}
			l = 1;r = i - 1;as = 0;
			while(l <= r){
				mid = l + r >> 1;
				if(wk2(i,mid)){
					as = mid;
					l = mid + 1;
				}
				else r = mid - 1;
			}
			print(i - as);kg;
		}
		hh;
	}
	return 0;
}
```


---

## 作者：day_dream (赞：19)

&emsp;这题压根就不用那么高级的dinic，isap。一发匈牙利就解决了呀，第二问也完全不用二分,可以直接在匈牙利跑增广的时候顺便求解。

&emsp;对于每个人统计它在每个志愿选了那些导师，对于每个人按志愿顺序选择枚举。设当前枚举学员X，对于导师A，如果A的战队名额未满，那么就可以直接将X归到A的战队，然后满了，那么枚举导师A战队中的人Y，dfs暴力查看是否可以在Y中X导师对应的志愿中选择另一位导师B，若可以则将Y归到B的战队，X归到A的战队。

&emsp;对于第二问你只需要在找增广路的时候统计你增广使你不沮丧的志愿中增广到的学员中编号最大的那个，即是答案。因为那个人可以在他的排名找到他的理论最优解，而你增广时遍历到了他，那你如果是他的位置那么你就可以直接选择到你当前要的这个导师。

&emsp;然后，我完全没有去卡常，但是这玩意快到飞起。

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
using namespace std;
int T,n,m,mx,nw,sl,fh,s[210],mn[210],num[210],q[210][210],p[210][210][15];
int a[210],id[210],vis[210];
int rd()
{
    sl=0;fh=1;
    char ch=getchar();
    while(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}
    while('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();
    return sl*fh;
}
bool dfs(int u,int k)
{
    if(u<nw) mx=max(mx,u);
    for(int v,i=1;i<=q[u][k];++i)
    {
        v=p[u][k][i];
        if(vis[v]) continue;vis[v]=1;
        if(num[v])
        {
            a[u]=v;id[u]=k;num[v]--;
            return 1;
        }
        for(int j=1;j<=n;++j)
        {
            if(j==u) continue;
            if(a[j]!=v) continue;
            if(dfs(j,id[j]))
            {
                a[u]=v;id[u]=k;
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    T=rd();rd();
    while(T--)
    {
        n=rd();m=rd();memset(q,0,sizeof(q));memset(a,0,sizeof(a));
        for(int i=1;i<=m;++i) num[i]=rd();
        for(int x,i=1;i<=n;++i)
            for(int j=1;j<=m;++j)
            {
                x=rd();if(!x) continue;
                p[i][x][++q[i][x]]=j;
            }
        for(int i=1;i<=n;++i) s[i]=rd(),id[i]=m+1,mn[i]=i;
        for(int i=1;i<=n;++i)
        {
            memset(vis,0,sizeof(vis));nw=i;
            for(int j=1;j<=m;++j)
            {
                if(!q[i][j]) continue;mx=0;
                if(dfs(i,j)) {if(j<=s[i]) mn[i]=0; break;}
                if(j<=s[i]) mn[i]=min(mn[i],i-mx);
            }
        }
        for(int i=1;i<=n;++i) printf("%d ",id[i]);puts("");
        for(int i=1;i<=n;++i) printf("%d ",mn[i]);puts("");
    }
    return 0;
}
```

---

## 作者：Ameyax (赞：18)

~~写篇题解纪念踩线的省选~~

$C=1$的情况，显然录取结果是唯一的，只需要贪心就可以获得$50$高分。

对于测试点$2,3$，由于数据很小，瞎暴力都能过，于是就获得了$70$高分。

对于全部的数据，显然是贪心的从第一人到第$n$人计算，对于第$i$个人，按照他的志愿从$1$到$m$加边，每次加一级志愿的边，然后在网络上找增广路，如果找到了增广路，就可以退出了，至此完美解决了第一问。

第一问可以优化，如果第$i$个人的第$j$级志愿不能增广，就直接把这些边删掉。

第二问只需要对于每一个人二分答案$ans_i$，把$ans_i$之前的人全部按照最优方案建出图，然后额外的连上第$i$个人所期望的边，再寻找增广路，就可以完美解决第二问。

上面的算法可以看出来要很多次建图，又因为图最多只有$2n$的点和$nC$的边，那就可以暴力的存$n$个图，分别对应前$n$个人的最优方案的残余网络，这样可以大大减少建图浪费的时间，并且每次只需要单路增广。

用$vector$貌似会快一些？

复杂度O(不慢)，第一问最多$nm$次找增广路，第二问$nlogn$次，及时删掉没用的边就不会$TLE$。


```cpp
#include <queue>
#include <cstdio>
#include <cctype>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
	while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
const int MAX = 233;
const int MAXN = 466;
const int inf = 100000000;
int n, m, s, t;
int b[MAX], p[MAX], ans[MAX], ans2[MAX];
vector<int> a[MAX][MAX];
struct edge
{
	int to, cap, rev;
	edge() {}
	edge(int a, int b, int c)
	{
		to = a, cap = b, rev = c;
	}
};
struct Graph
{
	vector<edge> e[MAXN];
	queue<int> que;
	int dis[MAXN];
	void addedge(int u, int v, int cap)
	{
		e[u].push_back(edge(v, cap, e[v].size()));
		e[v].push_back(edge(u, 0, e[u].size() - 1));
	}
	void deledge(int x) { e[x].pop_back(); }
	bool bfs()
	{
		memset(dis, -1, sizeof dis);
		que.push(s);
		dis[s] = 0;
		while (!que.empty())
		{
			int u = que.front();
			que.pop();
			for (vector<edge>::iterator i = e[u].begin(); i != e[u].end(); i++)
				if (i -> cap && dis[i -> to] < 0)
				{
					dis[i -> to] = dis[u] + 1;
					que.push(i -> to);
				}
		}
		return dis[t] != -1;
	}
	int dfs(int u, int f)
	{
		if (u == t) return f;
		for (vector<edge>::iterator i = e[u].begin(); i != e[u].end(); i++)
			if (i -> cap && dis[i -> to] > dis[u])
			{
				int d = dfs(i -> to, min(f, i -> cap));
				if (d)
				{
					i -> cap -= d;
					e[i -> to][i -> rev].cap += d;
					return d;	
				}
			}
		return 0;
	}
	void clear()
	{
		for (int i = 1; i <= n + m + 2; i++)
			e[i].clear();
	}
} G[233], tG;
void solveq1()
{
	for (int i = 1; i <= m; i++)
		G[0].addedge(i + n, t, b[i]);
	for (int i = 1; i <= n; i++)
	{
		G[i] = G[i - 1];
		G[i].addedge(s, i, 1);
		for (int j = 1; j <= m; j++)
		{
			for (vector<int>::iterator k = a[i][j].begin(); k != a[i][j].end(); k++)
				G[i].addedge(i, *k + n, 1);
			if (G[i].bfs())
			{
				G[i].dfs(s, inf);
				ans[i] = j;
				break;
			}
			for (vector<int>::iterator k = a[i][j].begin(); k != a[i][j].end(); k++)
				G[i].deledge(i), G[i].deledge(*k + n);
		}
	}
	for (int i = 1; i <= n; i++)
	{
		if (!ans[i]) ans[i] = m + 1;
		printf("%d ", ans[i]);
	}
	putchar('\n');
}
bool check(int u, int x)
{
	tG = G[x - 1];
	tG.addedge(s, u, 1);
	for (int i = 1; i <= p[u]; i++)
		for (vector<int>::iterator j = a[u][i].begin(); j != a[u][i].end(); j++)
			tG.addedge(u, *j + n, 1);
	if (tG.bfs()) return 1;
	else return 0;
}
void solveq2()
{
	for (int i = 1; i <= n; i++)
	{
		if (ans[i] <= p[i])
			continue;
		ans2[i] = 1000;
		int l = 1, r = i - 1;
		while (r >= l)
		{
			int mid = (l + r) >> 1;
			if (check(i, mid))
				ans2[i] = mid, l = mid + 1;
			else r = mid - 1;
		}
		if (ans2[i] && ans2[i] != 1000)
			ans2[i] = i - ans2[i];
	}
	for (int i = 1; i <= n; i++)
		printf("%d ", ans2[i] == 1000 ? i : ans2[i]);
	putchar('\n');
}
void init()
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			a[i][j].clear();
	for (int i = 1; i <= n; i++)
		ans[i] = ans2[i] = 0;
	G[0].clear();
}
void solve()
{
	n = read(), m = read();
	init();
	for (int i = 1; i <= m; i++)
		b[i] = read();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			int x = read();
			if (x) a[i][x].push_back(j);
		}
	for (int i = 1; i <= n; i++)
		p[i] = read();
	s = n + m + 1, t = s + 1;
	solveq1();
	solveq2();
}
int main()
{
	int T = read(), C = read();
	while (T--) solve();
	return 0;
}
```

---

## 作者：FlashHu (赞：10)

说不定比官方sol里的某理论最优算法还优秀一点？

~~所以$n,m$说不定可以出到$1000$？~~

无所谓啦，反正是个得分题。Orz良心出题人，~~暴力有70分2333~~

## 思路分析

正解的思路很巧妙，其实我并不觉得这是个正儿八经的网络流或者二分图匹配的题目，主要还是个思维+建图模型+乱搞。。。。。。

$C=1$时我们就可以对于每个人直接匹配而不会影响到后面的选择了。但是$C>1$的话，可能某一个人可以选多个导师，当他随便选了其中一个以后，可能影响到后面某个人使其选不到本来的最优解。而此时后面那个人就要让前面那个人改变决策，做出反悔。

这时候有没有想到网络流算法的反悔边的应用呢？（因为蒟蒻只会网络流所以就用网络流来跑二分图匹配）建一个二分图，左边$n$个点代表选手，右边$m$个点代表导师（战队），一开始所有导师向汇点$T$连流量为战队人数上限的边。每次从前往后枚举选手，找到能够选择的最高志愿，动态地向该档志愿能选择的所有导师连容量为$1$的边，然后增广一次（这时会随意选择一个可行的导师）。因为增广后会留下反悔边，所以这样做就很方便啦。因为每次是动态加边直接从每个选手开始增广 ，所以貌似连源点都不需要（这就是蒟蒻一直觉得这题像一个乱搞题的原因）

这时候留下一个问题，如何方便地判断某时刻某战队是否已经不可选了呢？暴力存图实在是太麻烦啦！而且我们并不需要知道整个图是什么样子，只要知道这一些bool型状态，暴力存图实在是浪费时空。大概算法复杂度优化的瓶颈就在这里吧。一开始蒟蒻yy各种~~极其错误的~~方法来乱搞。后来发现，将问题带入到我们建的网络流模型里面，不就是要知道每个代表导师的点到汇点是否存在增广路吗？具体方法，从汇点开始dfs搜索，如果某条边的反向边有流量就搜过去，把搜到的点标记起来就好啦！

对于第二问，显然可以想到二分。先把每次每个战队能否选择的状态保存下来，对于每个选手，二分他之前的排名，根据是否存在一个可以选择而且令他满意的战队来决定下面往哪一半区间接着找。

## 复杂度分析

有三步。首先要暴力找到能满足的最高志愿，复杂度$O(nm)$

接着，增广（蒟蒻直接dfs去找而不是dinic）和更新当前战队是否可选状态，因为是在图上搞，边数不超过$O(nC)$，所以这部分的复杂度都是$O(n^2C)$的（据说在二分图上使用dinic可以使增广的复杂度降到$O(n\sqrt nC)$？但是这是动态加边，每次都要跑，那应该是不能优化的吧）

最后，二分最少上升的排名，复杂度$O(nm\log n)$

综上，因为n与m同阶，所以总复杂度应该是$O(n^2(C+\log n))$级别的。由于是网络流，所以复杂度非常玄学，也不至于删边那么麻烦，蒟蒻随意加了一点点剪枝，还有register，inline，快读快写，就只要8ms，开O2 4ms。~~居然没有0msTAT，欢迎超越~~

最后提一个惨痛的经历：蒟蒻调这题一天多了，所有的算法性错误都更正了，还是WA，最后才发现重建图的时候反向边的流量忘记赋成0来覆盖掉原来的信息了TAT
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define R register int
#define I inline void
#define pc(C) *po++=C
#define add(X,Y,F)\
    to[++p]=Y,ne[p]=he[X],f[he[X]=p]=F,\
    to[++p]=X,ne[p]=he[Y],f[he[Y]=p]=0//反边赋0！
const int SZ=1<<20,N=209,M=N<<1,L=N*22;//边数最多2(nC+m)
char ibuf[SZ],obuf[SZ],*pi=ibuf-1,*po=obuf;
I in(R&x){
    while(*++pi<'-');
    x=*pi&15;
    while(*++pi>'-')x*=10,x+=*pi&15;
}
I out(R x){
    if(x>9)out(x/10);
    pc(x%10|'0');
}
int T,he[M],ne[L],to[L],f[L],he1[N],ne1[N];
int a[N][N],b[N],up[N];//up记录最少上升排名
bool c[N][N],vis[M];//c存下战队是否可选
void remain(R x){//更新状态，利用好反向边！
    vis[x]=1;
    for(R i=he[x];i;i=ne[i])
        if(f[i^1]&&!vis[to[i]])remain(to[i]);
}
bool flow(R x){//dfs增广
    if(vis[x])return x==T;
    vis[x]=1;
    for(R i=he[x];i;i=ne[i])
        if(f[i]&&flow(to[i])){
            --f[i];++f[i^1];
            return 1;
        }
    return 0;
}
int main(){
    fread(ibuf,1,SZ,stdin);
    R TT,CC,n,m,p,i,j,x,s,l,r,mi;
    in(TT);in(CC);
    while(TT--){
        in(n);in(m);
        T=n+m+1;p=vis[T]=1;
        for(j=1;j<=m;++j)
        	in(b[j]),add(j+n,T,b[j]);
        for(i=1;i<=n;++i)
            for(j=1;j<=m;++j)in(a[i][j]);
        for(j=1;j<=m;++j)
        	c[1][j]=(bool)b[j];//初始状态就是收不收人(不会来个导师不收人吧233)
        for(i=1;i<=n;++i){
            memset(he1,0,(n+1)<<2);
            for(j=1;j<=m;++j)//链表把同等级志愿挂一起，像邻接表一样
                ne1[j]=he1[a[i][j]],he1[a[i][j]]=j;
            for(x=1;x<=m;++x){
                for(j=he1[x];j;j=ne1[j])
                    if(c[i][j])break;
                if(j){
                    for(j=he1[x];j;j=ne1[j])
                    	if(c[i][j])add(i,j+n,1);//贪心选择，动态连边
                    memset(vis,0,T);flow(i);
                    break;
                }
            }
            out(x);pc(' ');
            if(x<=m){
                memset(vis,0,T);remain(T);
                memcpy(c[i+1]+1,vis+n+1,m);
            }//没选到肯定状态不变啦，直接copy上一次的
            else memcpy(c[i+1]+1,c[i]+1,N);
            in(s);if(x<=s){up[i]=0;continue;}//判掉一开始就满意的
            l=0;r=i-1;
            F:while(l!=r){
                mi=(l+r+1)>>1;//注意二分区间是左闭右开的，所以要写成这样
                for(x=s;x;--x)
                    for(j=he1[x];j;j=ne1[j])
                        if(c[mi][j]){l=mi;goto F;}
                r=mi-1;
            }
            up[i]=i-l;
        }
        pc('\n');for(i=1;i<=n;++i){out(up[i]);pc(' ');}pc('\n');
        memset(he,0,(T+1)<<2);//应该只有he需要清空
    }
    fwrite(obuf,1,po-obuf,stdout);
    return 0;
}
```

---

## 作者：Crabby_Maskiv (赞：7)

大多数AC的算法都是网络流然后加一堆建图方面的优化，然后由于网络流复杂度的玄学性跑得飞快，复杂度也没办法证明得很清楚。

这里介绍一个**复杂度严格**（但是跑的不快）的做法（也没啥卵用就当图个乐）。

我们考虑网络流，当前已经求出了前 $i-1$ 个人完成匹配后的残量网络，我们考虑把某个人加上去。

我们发现所需要的完成的增广十分特殊，因为**只有一单位的流量需要进行匹配**。这下就简单了：一个人能够通过某导师增广，当且仅当从那个导师出发，在残量网络上有到达汇点的路径。

于是我们忽略 dinic, Hungary 等一众网络流算法，就把残量网络当做一张有向图，然后处理出每个点能不能到汇点。

（具体一点的话，假如这个导师的战队还没有满就把它加入初始的队列，然后沿着反边流量为1，也就是流量为0的边bfs，注意你不能像在DAG上似的dfs，普通有向图上那个算法是错的）

这样复杂度就是就是非常严格的 $O(V+E)=O(nm)$

这样我们就处理出来了每个导师的队伍能不能新加人。然后我们对于每一个选手直接检查一下假如他的排名变为第 $i$ 名最高能满足第几志愿，非常快乐地把问题一、二一次性解决了。

复杂度依然是一次 $O(nm)$

最后我们把第 $i$ 名加进去，把他所能被满足的最高志愿内的所有导师连上边，然后一次增广，$O(nm)$

最后的复杂度是非常严格的 $O(n^2m)$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=400+5;
int n,m,S,T=N-1;
struct edge{
	int v,f,b;
	inline edge(int v,int f,int b):v(v),f(f),b(b){}
};
vector<edge> g[N];
inline void add(int u,int v,int f){
	int bu=g[u].size(),bv=g[v].size();
	g[u].push_back(edge(v,f,bv));
	g[v].push_back(edge(u,0,bu));
}
int d[N],cur[N];
inline bool bfs(){
	queue<int> q;q.push(S);
	memset(d,0,sizeof(d));
	d[S]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(auto e:g[u]){
			if(!e.f||d[e.v]) continue;
			d[e.v]=d[u]+1;
			q.push(e.v);
		}
	}
	return d[T];
}
int dfs(int u,int fl){
	if(u==T) return fl;
	if(!fl) return 0;
	int ans=0;
	for(int &i=cur[u];i<g[u].size();i++){
		int v=g[u][i].v,f=g[u][i].f,b=g[u][i].b;
		if(!f||d[v]!=d[u]+1) continue;
		int ff=dfs(v,min(f,fl));
		ans+=ff;
		fl-=ff;
		g[u][i].f-=ff;
		g[v][b].f+=ff;
		if(!fl) break;
	}
	return ans;
}
vector<int> a[N][N];
bool vis[N];
void prep(){
	int i;
	queue<int> q;
	memset(vis,0,sizeof(vis));
	for(i=n+1;i<=n+m;i++){
		for(auto e:g[i]){
			if(e.v==T&&e.f){
				vis[i]=1;
				q.push(i);
			}
		}
	}
	while(!q.empty()){
		int u=q.front();q.pop();
		for(auto e:g[u]){
			if(e.f||vis[e.v]) continue;
			vis[e.v]=1;
			q.push(e.v);
		}
	}
}
int s[N];
int ans1[N],ans2[N];
int main(){
	int i,j,k;
	int tot,C;cin>>tot>>C;
	while(tot--){
		for(i=0;i<N;i++) g[i].clear();
		for(i=1;i<N;i++){
			for(j=1;j<N;j++)
				a[i][j].clear();
		}
		cin>>n>>m;
		for(i=1;i<=m;i++){
			int b;cin>>b;
			add(n+i,T,b);
		}
		for(i=1;i<=n;i++){
			for(j=1;j<=m;j++){
				int c;cin>>c;
				if(c) a[i][c].push_back(j);
			}
		}
		for(i=1;i<=n;i++) cin>>s[i];
		for(i=1;i<=n;i++)
			add(S,i,1);
		for(i=1;i<=n;i++) ans2[i]=i;
		for(i=1;i<=n;i++){
			prep();
			for(j=i;j<=n;j++){
				for(k=1;k<=m;k++)
					for(auto x:a[j][k])
						if(vis[x+n]&&k<=s[j])
							ans2[j]=min(ans2[j],j-i);
			}
			for(j=1;j<=m;j++){
				bool flag=0;
				for(auto x:a[i][j])
					if(vis[x+n]){
						flag=1;
						break;
					}
				if(flag){
					for(auto x:a[i][j])
						add(i,x+n,1);
					break;
				}
			}
			ans1[i]=j;
			memset(cur,0,sizeof(cur));
			bfs();
			dfs(S,1);
		}
		for(i=1;i<=n;i++) cout<<ans1[i]<<" ";cout<<endl;
		for(i=1;i<=n;i++) cout<<ans2[i]<<" ";cout<<endl;
	}
	return 0;
}
```


---

## 作者：Caii (赞：6)

暴力即正解

$P_i$ 表示第 $i$ 个选手，$Q_i$ 表示第 $i$ 个导师

首先对于每个选手连边 $(S, P_i, 1)$ ，每个导师连边 $(Q_i, T, B_i)$

第一问比较显然，就是枚举每个选手被第几志愿录取，然后这个选手向对应的导师连边，看能否跑出流量即可

第二问大家都二分，然而我们可以暴力，每当跑完一个选手之后，我们对于每个导师暴力连边 $(S, Q_i, 1)$ ，再跑网络流，如果能跑出流量，那么说明第 $i$ 个导师的队伍没有满员，然后再把这条边删掉

那么第二问的答案就相当于是在它的所有前 $s_i$ 志愿中找出一个最晚满员的导师，满员的时间就是就是这个人最少需要到达的名次

这样子时间复杂度是 : $O(n^2m^2)$，我们只需要在第一问的时候，如果发现选手的志愿的队伍已经满员就不加边，这样就可以跑过去了

然而我们发现 $C\leq 10$，也就是每一轮最多加 $10$ 条边，如果一个选手没有被第 $i$ 志愿录取，那么之后第 $i$ 志愿的边也不可能跑出流量，所以我们可以把这些边删掉，于是时间复杂度 : $O(n^2mC)$

```cpp
#include <cctype>
#include <cstdio>
#include <cstring>
#include <algorithm>

#define DEBUG(args...) fprintf(stderr, args)

typedef long long LL;

#define FOR(i, l, r) for(int i = (l), i##_end = (r); i <= i##_end; ++i)
#define REP(i, l, r) for(int i = (l), i##_end = (r); i <  i##_end; ++i)
#define DFR(i, l, r) for(int i = (l), i##_end = (r); i >= i##_end; --i)
#define DRP(i, l, r) for(int i = (l), i##_end = (r); i >  i##_end; --i)

template<class T>T Min(const T &a, const T &b) {return a < b ? a : b;}
template<class T>T Max(const T &a, const T &b) {return a > b ? a : b;}
template<class T>bool Chkmin(T &a, const T &b) {return a > b ? a = b, 1 : 0;}
template<class T>bool Chkmax(T &a, const T &b) {return a < b ? a = b, 1 : 0;}

class fast_input {
private:
	static const int SIZE = 1 << 15 | 1;
	char buf[SIZE], *front, *back;

	void Next(char &c) {
	    if(front == back) back = (front = buf) + fread(buf, 1, SIZE, stdin);
		c = front == back ? (char)EOF : *front++;
	}

public :
	template<class T>void operator () (T &x) {
		char c, f = 1;
		for(Next(c); !isdigit(c); Next(c)) if(c == '-') f = -1;
		for(x = 0; isdigit(c); Next(c)) x = x * 10 + c - '0';
		x *= f;
	}
	void operator () (char &c, char l = 'a', char r = 'z') {
		for(Next(c); c > r || c < l; Next(c)) ;
	}
}input;

const int SN = 200 + 47;
const int SP = SN << 1 | 1;
const int SE = SN * SN * 4 + 1;
const int S = SP - 1;
const int T = SP - 2;
const int INF = 0x3f3f3f3f;

int cur[SP], head[SP], nxt[SE], to[SE], flow[SE], ce = 1;
int que[SP], front, back, deep[SP], pre[SP];
int a[SN][SN], b[SN], n, m, s[SN];
int ans1[SN], ans2[SN];
int team_full[SN], team_test_edge[SN];

void Clear();
void Add(int, int, int);
bool BFS();
void Doit();

int main() {

#ifdef Cai
	freopen("s.in", "r", stdin);
#endif

	int x, y, z, cases;

	input(cases), input(x);

	while(cases--) {
		Clear();
		input(n), input(m);
		FOR(i, 1, m) input(b[i]);
		FOR(i, 1, n) FOR(j, 1, m) input(a[i][j]);
		FOR(i, 1, n) input(s[i]);
		
		FOR(i, 1, m) Add(i + n, T, b[i]);
		FOR(i, 1, m) team_test_edge[i] = ce + 1, Add(S, i + n, 0);
		
		FOR(i, 1, n) {
			Add(S, i, 1), ans1[i] = m + 1;
			FOR(j, 1, m) {
				x = ce;
				memcpy(cur, head, sizeof head);
				FOR(k, 1, n) if(a[i][k] == j && !team_full[k]) Add(i, k + n, 1);
				if(BFS()) {ans1[i] = j; Doit(); break;}
				memcpy(head, cur, sizeof head);
			}
			FOR(j, 1, m) if(!team_full[j]) {
				flow[team_test_edge[j]] = 1;
				if(!BFS()) team_full[j] = i;
				flow[team_test_edge[j]] = 0;
			}
		}

		FOR(i, 1, n) if(!team_full[i]) team_full[i] = n + 1;
		
		FOR(i, 1, n) {
			x = 0;
			FOR(j, 1, m) if(a[i][j] && a[i][j] <= s[i]) Chkmax(x, team_full[j]);
			if(!x) ans2[i] = i;
			else if(x >= i) ans2[i] = 0;
			else ans2[i] = i - x;
		}

		FOR(i, 1, n) printf("%d ", ans1[i]); putchar(10);
		FOR(i, 1, n) printf("%d ", ans2[i]); putchar(10);
	}

	return 0;

}

void Clear() {
	memset(head, 0, sizeof head), ce = 1;
	memset(team_full, 0, sizeof team_full);
}

void Add(int x, int y, int z) {
	nxt[++ce] = head[x], head[x] = ce, to[ce] = y, flow[ce] = z;
	nxt[++ce] = head[y], head[y] = ce, to[ce] = x, flow[ce] = 0;
}

bool BFS() {
	memset(deep, 0, sizeof deep), deep[S] = 1;
	que[0] = S, front = 0, back = 1;
	while(front < back)
		for(int now, i = head[now = que[front++]]; i; i = nxt[i])
			if(!deep[to[i]] && flow[i]) {
				deep[to[i]] = deep[now] + 1;
				pre[to[i]] = i;
				if(to[i] == T) return true;
				que[back++] = to[i];
			}
	return false;
}

void Doit() {
	for(int i = T; i != S; i = to[pre[i] ^ 1])
		--flow[pre[i]], ++flow[pre[i] ^ 1];
}

/*
g++11 -o s s.cpp -O2; for((i = 1; i <= 10; ++i)) do cp $i.in s.in; time ./s > s.out; diff $i.ans s.out -w > s.res; echo $i : $?; done;
*/

```

---

## 作者：Fizzmy (赞：5)

## Solution：

考场上只想到了费用流，但是T掉了，自测是跑了3s，在此分享一下费用流做法：

因为我们每次需要优先满足排名在前的选手，志愿在前的导师，所以说我们S向每个选手连费用为1000*排名，流量为1的边，每个导师向T连费用为0，流量为人数上限的边，每个选手向导师连费用为志愿优先级，流量为1的边，这样对于每次跑出的费用V,$\frac V {1000}$是这个选手的排名，$V \% 1000$是这个选手能满足的最高志愿。

但是这样直接跑是错的（过不了大样例），我们需要每次重新建图，对于每个已知结果的选手，我们连边的时候只能连和结果志愿一样的边，理由大概就是后面的流在跑的时候可能会通过前面建的回流来影响前面的结果

这样我们需要枚举每个选手，然后每次重新建图+费用流

至于第二问只需要二分一下就好了

复杂度大概是$O(n*n*n*c)$（费用流复杂度大概是$n*n*c$）

代码（TLE）：



```
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int N=410;
const int inf=1e9;
int n,m,t,C,S,T,sz,head[N],ans[N],a[300][300],b[300],dis[N],q[N*N],s[N];
bool vis[N];
int pre[N],prv[N];
struct edg{
	int to,next,v,f;
}e[200*N];
void add(int x,int y,int f,int v)
{
	sz++;e[sz].to=y;e[sz].f=f;e[sz].v=v;e[sz].next=head[x];head[x]=sz;
	sz++;e[sz].to=x;e[sz].f=0;e[sz].v=-v;e[sz].next=head[y];head[y]=sz;
}
bool SPFA()
{
	int tt=0,hh=0;
	for (int i=S;i<=T;++i) vis[i]=0,dis[i]=inf;
	vis[S]=1;dis[S]=0;q[++tt]=S;
	while (hh<tt)
	{
		int x=q[++hh];vis[x]=0;
		for (int i=head[x];i;i=e[i].next)
		{
			int y=e[i].to;
			if (e[i].f&&dis[y]>dis[x]+e[i].v)
			{
				dis[y]=dis[x]+e[i].v;
				pre[y]=i;prv[y]=x;
				if (!vis[y]) q[++tt]=y,vis[y]=1;
			}
		}
	}
	return (dis[T]!=inf); 
}
int main()
{
	freopen("mentor.in","r",stdin);
	freopen("mentor.out","w",stdout);
	scanf("%d%d",&t,&C);
	while (t--)
	{
		sz=1;memset(head,0,sizeof(head));
		scanf("%d%d",&n,&m);S=0;T=n+m+1;
		for (int i=1;i<=n;++i) ans[i]=m+1;
		for (int i=1;i<=m;++i) scanf("%d",&b[i]);
		for (int i=1;i<=n;++i)
		{
			sz=1;memset(head,0,sizeof(head));
			for (int j=1;j<=n;++j) add(S,j,1,j*1000);
			for (int j=1;j<=m;++j) add(n+j,T,b[j],0);
			for (int j=1;j<i;++j)
				for (int k=1;k<=m;++k)
					if (a[j][k]==ans[j]) add(j,n+k,1,a[j][k]);
			for (int j=1;j<=m;++j)
			{
				scanf("%d",&a[i][j]);
				if (a[i][j]) add(i,n+j,1,a[i][j]);
			}
			while (SPFA())
			{
				ans[dis[T]/1000]=dis[T]%1000;
				for (int i=T;i!=S;i=prv[i])
					e[pre[i]].f--,e[pre[i]^1].f++;
			}
		}
		for (int x,i=1;i<=n;++i)
		{
			scanf("%d",&x);s[i]=0;
			if (x>=ans[i]) continue;
			int l=1,r=i-1;s[i]=i;
			while (l<=r)
			{
				sz=1;memset(head,0,sizeof(head));
				for (int j=1;j<=n;++j) add(S,j,1,j*1000);
				for (int j=1;j<=m;++j) add(n+j,T,b[j],0);
				int mid=l+r>>1;
				for (int j=1;j<mid;++j)
					for (int k=1;k<=m;++k)
						if (a[j][k]==ans[j]) add(j,n+k,1,a[j][k]);
				for (int j=1;j<=m;++j)
					if (a[i][j]) add(i,n+j,1,a[i][j]);
				bool p=0;
				while (SPFA())
				{
					if (dis[T]/1000==i)
					{
						p=1;
						if (dis[T]%1000<=x) {s[i]=i-mid;l=mid+1;break;}
						else {r=mid-1;break;} 
					}
					//cout<<dis[T]<<endl; 
					for (int i=T;i!=S;i=prv[i])
						e[pre[i]].f--,e[pre[i]^1].f++;
				}
				if (!p) r=mid-1;
			}
		} 
		for (int i=1;i<=n;++i)
			printf("%d ",ans[i]);
		printf("\n");
		for (int i=1;i<=n;++i)
			printf("%d ",s[i]);
		printf("\n");
	}
}
```



普通网络流思路和费用流差不多，只需要对于每个选手枚举一个志愿即可了，对于每个选手只需要重新建边一次，枚举志愿时可以直接加边

第二问也是二分

复杂度$O(n*m*n\sqrt{nc})$($n\sqrt{nc}$是二分图dinic复杂度)

代码：

```
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int N=410;
const int inf=1e9;
int n,m,t,C,S,T,sz,head[N],v[N],ans[N],a[300][300],b[300],dis[N],q[N],s[N];
int dep[N];
int pre[N],prv[N];
struct edg{
	int to,next,f;
}e[200*N];
void add(int x,int y,int f)
{
	sz++;e[sz].to=y;e[sz].f=f;e[sz].next=head[x];head[x]=sz;
	sz++;e[sz].to=x;e[sz].f=0;e[sz].next=head[y];head[y]=sz;
}
bool bfs()
{
	int hh=0,tt=0;
	for (int i=S;i<=T;i++) dep[i]=0;
	dep[S]=1;q[++tt]=S;
	while (hh<tt)
	{
		int x=q[++hh];
		for (int i=head[x];i;i=e[i].next)
		{
			int y=e[i].to;
			if (e[i].f&&!dep[y]) dep[y]=dep[x]+1,q[++tt]=y;
		}
	}
	return (dep[T]!=0);
}
int dfs(int x,int flow)
{
	if (x==T) return flow;
	int used=0,now=0;
	for (int i=v[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (dep[y]==dep[x]+1&&e[i].f)
		{
			now=dfs(y,min(flow-used,e[i].f));
			e[i].f-=now;
			e[i^1].f+=now;
			used+=now;
			v[x]=i;
			if (flow==used) break;
		}
	}
	if (used==0) dep[x]=-1;
	return used;
}
int main()
{
//	freopen("mentor.in","r",stdin);
//	freopen("mentor.out","w",stdout);
	scanf("%d%d",&t,&C);
	while (t--)
	{
		sz=1;memset(head,0,sizeof(head));
		scanf("%d%d",&n,&m);S=0;T=n+m+1;
		for (int i=1;i<=n;++i) ans[i]=m+1;
		for (int i=1;i<=m;++i) scanf("%d",&b[i]);
		int tag=0;
		for (int i=1;i<=n;++i)
		{
			sz=1;memset(head,0,sizeof(head));
			for (int j=1;j<=i;++j) {if (j==i) tag=sz+1;add(S,j,1);}
			for (int j=1;j<=m;++j) add(n+j,T,b[j]);
			for (int j=1;j<i;++j)
				for (int k=1;k<=m;++k)
					if (a[j][k]==ans[j]) add(j,n+k,1);
			for (int j=1;j<=m;++j)
				scanf("%d",&a[i][j]);
			while (bfs())
			{
				for (int j=S;j<=T;++j) v[j]=head[j]; 
				dfs(S,inf);
			}
			for (int l=1;l<=m;++l)
			{
				for (int j=1;j<=m;++j)
					if (a[i][j]==l) add(i,n+j,1);
				while (bfs())
				{
					for (int j=S;j<=T;++j) v[j]=head[j]; 
					dfs(S,inf);
				}
				if (e[tag].f==0) {ans[i]=l;break;}
			}
		}
		for (int x,i=1;i<=n;++i)
		{
			scanf("%d",&x);s[i]=0;
			if (x>=ans[i]) continue;
			int l=1,r=i-1;s[i]=i;
			while (l<=r)
			{
				sz=1;memset(head,0,sizeof(head));
				for (int j=1;j<=n;++j) {if (j==i) tag=sz+1;add(S,j,1);}
				for (int j=1;j<=m;++j) add(n+j,T,b[j]);
				int mid=l+r>>1;
				for (int j=1;j<mid;++j)
					for (int k=1;k<=m;++k)
						if (a[j][k]==ans[j]) add(j,n+k,1);
				while (bfs())
				{
					for (int j=S;j<=T;++j) v[j]=head[j]; 
					dfs(S,inf);
				}
				for (int j=1;j<=m;++j)
					if (a[i][j]>0&&a[i][j]<=x) add(i,n+j,1);
				
				while (bfs())
				{
					for (int j=S;j<=T;++j) v[j]=head[j]; 
					dfs(S,inf);
				}
				if (e[tag].f==0) {l=mid+1,s[i]=i-mid;}
				else r=mid-1;
			}
		} 
		for (int i=1;i<=n;++i)
			printf("%d ",ans[i]);
		printf("\n");
		for (int i=1;i<=n;++i)
			printf("%d ",s[i]);
		printf("\n");
	}
}
```

---

## 作者：feecle6418 (赞：4)

拆点+匈牙利算法。以下设当前处理的人叫 $R$。

首先处理“一个导师匹配 $b$ 个人”的问题，把每个导师拆成 $b$ 个点就行。

第一问，直接从第一个人起，一个志愿一个志愿尝试是否能够匹配，若能就 `break` 进入下一个人，否则继续尝试。注意这里不需要每次重新建图，直接清空 $R$ 连出去的边即可。匹配成功（或者所有志愿都无法匹配）后进入下一个人（$R+1$）时不清空 $R$ 连出去的边，因为之后的匹配中，与 $R$ 有关的增广路可能发生变化，仍然需要之前的边。这一步的复杂度是 $O(n^5)$，其中共寻找 $O(n^2)$ 次增广路，每次寻找增广路的复杂度是 $O(N+M)=O(n^5)$（点数 $N$ 为 $n+\sum b_i$ 在 $n^2$ 级别，每个人至多连出去 $bn$ 条边，而有 $n$ 个人，因此边数在 $O(bn^2)=O(n^3)$ 级别）。实际上**不可能**跑满（感性理解一下，没办法让每次增广都遍历整个图），因此是正确的。

第二问也很简单、很暴力：$p$ 从 $R\to 1$ 枚举，依次看只考虑前 $p-1$ 个人和 $R$ 的时候可否让 $R$ 的前 $s_R$ 个志愿满足。不需要跑 $s_{R}$ 次增广，把前 $s_R$ 个志愿全部加进去一次增广就行，注意做完后图的清空与还原。这部分的复杂度也是 $O(n^5)$，同样不可能跑满。更优的做法是二分（$O(n^4\log n)$），但是对总体复杂度无影响。

代码如下（有简要注释），最大的点跑了 $500\text{ms}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,C,b[205],s[205],mch[40005],ans[205],mm[205],sign,vst[205],tmp[40005];
vector<int> g[205],z[205][205];
bool dfs(int x,int id) {
	vst[x]=id;
	for(int y:g[x]) {
		if(!mch[y]||(vst[mch[y]]!=id&&dfs(mch[y],id)))return mch[y]=x,mm[x]=y,1;
	}
	return 0;
}
bool Try(int x,int y) { //第x个人的第y志愿能否满足
	for(int w:z[x][y]) {
		for(int i=b[w-1]+1; i<=b[w]; i++)g[x].push_back(i);
	}
	if(dfs(x,++sign))return ans[x]=y,memset(mm,0,sizeof(mm)),1;
	g[x].clear();
	for(int i=1; i<=n; i++)if(mm[i])mch[mm[i]]=0,mm[i]=0;
	return 0;
}
bool dfs2(int x,int w1,int id) {//只考虑<=w1的 
	vst[x]=id;
	for(int y:g[x]) {
		int t=mch[y];
		if(t>w1||!t||(vst[t]!=id&&dfs2(t,w1,id)))return mch[y]=x,1;
	}
	return 0;
}
int main() {
	int T;
	scanf("%d%d",&T,&C);
	while(T--) {
		sign=0,cin>>n>>m;
		for(int i=1; i<=m; i++)scanf("%d",&b[i]),b[i]+=b[i-1]; //编号：b[i-1]+1~b[i]
		for(int i=1; i<=n; i++) {
			ans[i]=m+1;
			for(int j=1,x; j<=m; j++) {
				scanf("%d",&x);
				if(x)z[i][x].push_back(j);
			}
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++)if(Try(i,j))break;
		}
		for(int i=1; i<=n; i++)printf("%d ",ans[i]);
		puts("");
		for(int i=1,flag; i<=n; i++) {
			scanf("%d",&s[i]),g[i].clear(),flag=0;
			for(int j=1; j<=s[i]; j++) {
				for(int w:z[i][j]) {
					for(int k=b[w-1]+1; k<=b[w]; k++)g[i].push_back(k)/*,cout<<endl<<"P:"<<i<<' '<<k<<endl*/;
				}
			}
			for(int j=i; j>=1; j--) {
				memcpy(tmp,mch,sizeof(tmp));
				if(dfs2(i,j-1,++sign)){
					flag=1,printf("%d ",i-j);
					memcpy(mch,tmp,sizeof(tmp));
					break;
				}
				memcpy(mch,tmp,sizeof(tmp));
			}
			if(!flag)printf("%d ",i);
			g[i].clear();
			for(int w:z[i][ans[i]]) {
				for(int k=b[w-1]+1; k<=b[w]; k++)g[i].push_back(k);
			}
		}
		puts("");
		for(int i=1;i<=n;i++){
			g[i].clear(),mch[i]=0;
			for(int j=1;j<=m;j++)z[i][j].clear();
		}
	}
}
```

---

## 作者：xtx1092515503 (赞：2)

一种时空复杂度均严格与 $C$ 无关的做法。

------

首先，看到这个问题，一下子就能想到二分图多重匹配的模型——每个选手均可以匹配多个导师，而导师有着匹配人数的上限。

于是我们从小到大枚举每个人，再枚举其所有档志愿，依次判断其该档志愿的边加入图中会不会使最大流量变大即可。

为了避免一些奇奇怪怪的错误，我的写法是加入一档志愿后，若合法，则不退流，直接进行下一个人的运算；否则，就要**退流**，消除本档志愿的影响。具体而言，因为我们的建图是从 $S$ 连到所有人，从所有人连到合法的导师，从所有导师再连到 $T$；于是当想要仅对一个人退流时，就断掉其与 $S$ 的连边，并且以 $T$ 为源点，此人所对应的节点为汇点，跑一遍Dinic，然后再连回该连边即可。为了避免这些理论上已经不存在的边的影响，我们将此档志愿的边**全数删去**（这意味着我们写的链式前向星要被升级为链表来支持快速删除）。

下面考虑第二问。第二问的思路也很简单，在第一问的残量网络上，倒着遍历每个人。当遍历到一个人时，先删去其第一问中连上的所有边，然后再把他前 $s_i$ 档的边全数加入图中。跑最大流，找到那个新被匹配上的人，退流并删去其所有边，然后重新跑最大流，直到再也找不到新被匹配上的人。

这样就需要一些操作来保证正确性。具体而言，在删去第一问中的边时，同样，要先退流来消去影响，再删边。然后，为了保证不会有两个第二问的人同时匹配上了，却抢走了第一问的人的流量，我们必须保证任意时刻所有第二问的人中最多只能匹配一个。所以，我们要建立一个**伪源点** $s$，连边 $(S,s,1)$，并且将所有第二问的人的边从 $s$ 而非 $S$ 连出。这样，即可保证所有第二问的人最多匹配一个。当Dinic下来发现最大流量增加时，找到 $s$ 流向的那个节点，退流并删边，然后重新跑Dinic直到最大流量不再增加；否则，即最大流量没有增加，为了消除影响，我们对 $s$ 退流（事实上，此处退流与否并不会影响算法正确性——因为最终方案中 $s$ 也是要有流量的，但是这里代码中就随手写上了一次退流），然后进入前一个人的操作。

因为我们不需要像常规做法中一样支持前缀和残量网络的查询，所以空间复杂度是十分优秀的；然而，因为退流次数很多，所以实际消耗时间较常规做法甚至更劣，但是当数据范围更大时，此算法便会显著优于常规做法（因为少了二分以及拷贝前缀和残量网络等操作）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,T_T,C_C,lim[210],acc[210],ide[210],imp[210];
namespace MaxFlow{
	const int N=510,M=1000000;
	int head[N],cur[N],dep[N],S,T,res;
	int bin[M],tp,cnt;//storing the id of edges
	int newedge(){return tp?bin[tp--]:cnt++;}//generating the id of an edge
	struct node{int to,next,last,val;}edge[M];//using a handwritten list to store edges
	int ae(int u,int v,int w){//adding an edge in the back, returning the id
		int U=newedge();
		edge[U].next=head[u],edge[U].last=-1,edge[U].to=v,edge[U].val=w;
		if(head[u]!=-1)edge[head[u]].last=U;head[u]=U;
		
		int V=newedge();
		edge[V].next=head[v],edge[V].last=-1,edge[V].to=u,edge[V].val=0;
		if(head[v]!=-1)edge[head[v]].last=V;head[v]=V;
		
		return U;//under every circumstance, V equals U+1. 
	}
	void ea(int U){//eliminating edge U
		int V=U+1,u=edge[V].to,v=edge[U].to;
		if(edge[V].next!=-1)edge[edge[V].next].last=edge[V].last;
		if(edge[V].last!=-1)edge[edge[V].last].next=edge[V].next;
		if(head[v]==V)head[v]=edge[V].next;
		bin[++tp]=V;
		
		if(edge[U].next!=-1)edge[edge[U].next].last=edge[U].last;
		if(edge[U].last!=-1)edge[edge[U].last].next=edge[U].next;
		if(head[u]==U)head[u]=edge[U].next;
		bin[++tp]=U;
	}
	queue<int>q;
	inline bool bfs(){
		memset(dep,0,sizeof(dep)),q.push(S),dep[S]=1;
		while(!q.empty()){
			register int x=q.front();q.pop();
			for(register int i=cur[x]=head[x];i!=-1;i=edge[i].next)if(edge[i].val&&!dep[edge[i].to])dep[edge[i].to]=dep[x]+1,q.push(edge[i].to);
		}
		return dep[T]>0;
	}
	bool reach;
	inline int dfs(int x,int flow){
		if(x==T){res+=flow,reach=true;return flow;}
		int used=0;
		for(register int &i=cur[x];i!=-1;i=edge[i].next){
			if(!edge[i].val||dep[edge[i].to]!=dep[x]+1)continue;
			register int ff=dfs(edge[i].to,min(edge[i].val,flow-used));
			if(ff){edge[i].val-=ff,edge[i^1].val+=ff,used+=ff;if(used==flow)break;}
		}
		return used;
	}
	inline void Dinic(int SS,int TT){S=SS,T=TT;while(bfs()){reach=true;while(reach)reach=false,dfs(S,0x3f3f3f3f);}}
}
using MaxFlow::head;
using MaxFlow::Dinic;
using MaxFlow::res;
using MaxFlow::edge;
using MaxFlow::cnt;
using MaxFlow::ae;
using MaxFlow::ea;
using MaxFlow::tp;
vector<int>v[210][210];
int read(){
	int x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x;
}
int S,T,s;//s is the pseudo source point. 
void compensate(int i){//conpensate for the influence of edge i.
	edge[i].val=0,edge[i+1].val=0;//blocking the supplying edge
	Dinic(T,edge[i].to);//eliminating the influence of the current operation, using backflowing
	edge[i].val=1,edge[i+1].val=0;//restore the supplying edge
} 
int e[210][210],sz[210];
int main(){
	T_T=read(),C_C=read();
	while(T_T--){
		n=read(),m=read(),memset(head,-1,sizeof(head)),cnt=res=tp=0,s=n+m+1,S=n+m+2,T=n+m+3;
		for(int i=1;i<=m;i++)ae(i+n,T,lim[i]=read());
		for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){int x=read();if(x)v[i][x].push_back(j);}
		for(int i=1;i<=n;i++)ide[i]=read();
		for(int i=1;i<=n;i++){
			acc[i]=m+1,e[i][sz[i]=1]=ae(S,i,1);
			for(int j=1;j<=m;j++){
				for(auto k:v[i][j])e[i][++sz[i]]=ae(i,n+k,1);
				Dinic(S,T);
				if(res==i){acc[i]=j;break;}
				compensate(e[i][1]);
				res=i-1;//reset the answer
				while(sz[i]>1)ea(e[i][sz[i]--]);//reset the graph
			}
			res=i;//forcing the flow to i
		}
		for(int i=1;i<=n;i++)printf("%d ",acc[i]);puts("");
		int sor=ae(S,s,1);
		for(int i=n;i>=1;i--){
			imp[i]=i;
			compensate(e[i][1]),res=i-1;
			while(sz[i])ea(e[i][sz[i]--]);
			e[i][sz[i]=1]=ae(s,i,1);
			for(int j=1;j<=ide[i];j++)for(auto k:v[i][j])e[i][++sz[i]]=ae(i,n+k,1);
			while(true){
				Dinic(S,T);
				if(res==i-1){compensate(sor);break;}//inpossible to find one
				for(int k=head[s];k!=-1;k=edge[k].next)if(edge[k].to<=n&&!edge[k].val){
					int x=edge[k].to;
					compensate(k);
					imp[x]=x-i,res=i-1;
					while(sz[x])ea(e[x][sz[x]--]);
					edge[sor].val=1,edge[sor^1].val=0;
					break;
				}
			}
		}
		for(int i=1;i<=n;i++)printf("%d ",imp[i]);puts("");
		for(int i=1;i<=n;i++)sz[i]=0;
		for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)v[i][j].clear();
	}
	return 0;
}
```



---

## 作者：Wilderness_ (赞：1)

题目链接：[Luogu](https://www.luogu.com.cn/problem/P4382)

这道题目本蒟蒻采取匈牙利算法，~~并不是因为网络流还不是特别会~~。

### 思路
首先，对于第一问，我们可以统计每个人的每个志愿有什么导师，然后对于每一个学员，按照他志愿的从高到低枚举，如果他的志愿导师还没有收满学员，直接加入战队 `I Want You!`；否则我们枚举导师战队中的每个学员，对于每个学员都找一下是否有另一个导师能够容得下这位倒霉的被踢出去的学员，如果有一个 ~~冤种~~ 幸运导师收留了他，那么我们枚举的那个学员就进入他心仪的队伍。

对于第二问，我们在跑二分图最大匹配的时候，对于每个人我们都记录下他现在的排名与他能够满足自己要求时达到的最低排名，如果有导师能够满足这个人的条件，那么记录，否则记为这个人现在的排名。

### Code
```
#include<bits/stdc++.h>
#define M 241
using namespace std;
int T,C,n,m,maxn,now,hope[M],sad[M],num[M],match[M],solve[M],vis[M];
vector<int>wish[M][M];
//hope[i]表示第i个人的理想值，wish[i][j][k]表示第i个人的第j志愿中的第k个人。 
//sad[i]表示使第i个人不沮丧最少需要让他上升的排名数，solve[i]表示最优方案下第i个人被谁录取。 
bool found(int x,int t)
{
    if(x<now)maxn=max(maxn,x);//如果x的排名在现在查的人前 
    for(auto v:wish[x][t])
    {
        if(vis[v])continue;
		vis[v]=1;
        if(num[v])//如果这位导师还有空位 
        {
            match[x]=v,solve[x]=t;
			--num[v];//给导师空位-1
            return 1;
        }
        for(int i=1;i<=n;i++)//否则匈牙利算法跑一遍 
        {
            if(i==x||match[i]!=v)continue;//如果遍历到他或者对方的志愿不是他的志愿，立刻跳过 
            if(found(i,solve[i]))
            {
                match[x]=v,solve[x]=t;
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
	scanf("%d%d",&T,&C);
    while(T--)
    {
        scanf("%d%d",&n,&m);
		memset(wish,0,sizeof(wish));memset(match,0,sizeof(match));//多测不清空，wyy两行泪T_T 
        for(int i=1;i<=m;i++)scanf("%d",&num[i]);
        for(int i=1;i<=n;i++)
            for(int j=1,x;j<=m;j++)
            {
                scanf("%d",&x);
                wish[i][x].push_back(j);
            }
        for(int i=1;i<=n;i++)
		{
			scanf("%d",&hope[i]);
			solve[i]=m+1,sad[i]=i;//初始化 
		}
        for(int i=1;i<=n;i++)
        {
            memset(vis,0,sizeof(vis));
			now=i;//now表示这个人现在的排名，maxn表示这个人要想达到志愿时的排名 
            for(int j=1;j<=m;j++)
            {
                if(wish[i][j].empty())continue;
				maxn=0;
                if(found(i,j))
				{
					if(j<=hope[i])sad[i]=0;//如果他被他的志愿或更高的导师选中 
					break;
				}
                if(j<=hope[i])sad[i]=min(sad[i],i-maxn);//跑完这个人后，如果他可以不沮丧，那么更新。 
            }
        }
        for(int i=1;i<=n;i++)printf("%d ",solve[i]);printf("\n");
        for(int i=1;i<=n;i++)printf("%d ",sad[i]);printf("\n");
    }
    return 0;
}
```

---

## 作者：Soulist (赞：1)

并不知道动态加边的 dinic 的复杂度/fad


我们考虑对于每个人依次确定一个字符，这样的确定会发生 $n^2$ 次，那么对于一个确定的字符串，check 的方式就是一个二分图匹配，之前的点会保留 $nC$ 条边，这样跑 dinic 的复杂度为 $\mathcal O(n\sqrt{n}C)$，

不过事实上我们可以动态加边，然后如果增广失败那么新加的边可以直接删除，时刻有效的边数为 $\mathcal O(nC)$，由于图为二分图，所以增广的总复杂度大致可以降为 $\mathcal O(n\sqrt{n}C)$，需要处理 $n$ 次所以这里的复杂度为 $\mathcal O(n^2\sqrt{n}C)$

然后 check $s_i$ 是可以直接一个二分然后暴力加边然后跑 dinic 来 check，复杂度是 $\mathcal O(n\cdot m\sqrt n\log n)$ 即 $\mathcal O(n^2C\sqrt{n}\log n)$。

不过有一个问题就是，我并不知道动态加边处理二分图上的 dinic 的复杂度是不是仍是 $\mathcal O(n\sqrt{n})$，不过感性上感觉至多也仅是 $\mathcal O(n^2)$，然后莫名奇妙直接跑动态加边，不用二分而换成枚举暴力 check 也可以过去，复杂度不知道是 $\mathcal O(n^2\sqrt{n}C)$ 还是 $\mathcal O(n^3C)$，不过即使是后者看上去也挺能过的。试了一下，需要 O2 的帮助。

不过可能是我 STL 函数用多了的缘故？有没有老哥说一下这玩意儿的复杂度到底是啥啊

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int inf = 1e8 + 7 ; 
const int N = 500 + 5 ; 
const int M = 3000 + 5 ; 
int C, n, m, b[N], S, T, head[N], a[N][N], AA[N], s[N], t[N], ff[N], mcp[N], cur[N], dep[N], cnt ;
struct E { int to, next, w ; } e[M << 1] ; 
queue<int> q ; 
void add( int x, int y, int z ) {
	e[++ cnt] = (E){ y, head[x], z }, head[x] = cnt,
	e[++ cnt] = (E){ x, head[y], 0 }, head[y] = cnt ; 
}
bool bfs() {
	q.push(S) ; memset( dep, 0, sizeof(dep) ), dep[S] = 1 ; 
	while( !q.empty() ) {
		int u = q.front() ; q.pop() ; 
		Next( i, u ) {
			int v = e[i].to ; 
			if( !dep[v] && e[i].w ) dep[v] = dep[u] + 1, q.push(v) ; 
		}
	} 
	return ( dep[T] != 0 ) ;
}
int dfs( int x, int dist ) {
	if( x == T ) return dist ; int flow = 0 ; 
	for( int &i = cur[x]; i; i = e[i].next ) {
		int v = e[i].to ; 
		if( ( dep[v] == dep[x] + 1 ) && e[i].w ) {
			int di = dfs( v, min( dist, e[i].w ) ) ;
			e[i].w -= di, e[i ^ 1].w += di, dist -= di, flow += di ; 
			if( !dist ) break ; 
		}
	} return flow ; 
}
int dinic() {
	int ans = 0 ; while( bfs() ) {
		memcpy( cur, head, sizeof(head) ) ; int di = 1 ; 
		while(di) di = dfs( S, inf ), ans += di ; 
	} return ans ; 
}
void init() {
	memset( head, 0, sizeof(head) ), cnt = 1 ; S = 0, T = n + m + 10 ;
	rep( i, 1, n ) add( S, i, 1 ) ;
	rep( i, 1, m ) add( i + n, T, b[i] ) ;
	memcpy( mcp, head, sizeof(head) ); 
}
signed main()
{
	int qwq = gi() ; C = gi() ; 
	while( qwq -- ) {
		n = gi(), m = gi() ; 
		rep( i, 1, m ) b[i] = gi() ; 
		rep( i, 1, n ) rep( j, 1, m ) a[i][j] = gi() ;
		rep( i, 1, n ) s[i] = gi() ; 
		init() ; 
		int flow = 0, bef = 0 ; 
		rep( i, 1, n ) {
			int id = m + 1, rnt = cnt ;
			rep( j, 1, m ) {
				rep( k, 1, m ) if( a[i][k] == j ) add( i, k + n, 1 ) ;
				flow += dinic() ; 
				if( flow ^ bef ) { id = j, bef = flow ; break ; }
				else {
					cnt = rnt, memcpy( head, mcp, sizeof(mcp) ) ;
				}
			}
			AA[i] = flow, t[i] = id ; 
			memcpy( mcp, head, sizeof(head) );
		}
		rep( i, 1, n ) printf("%d ", t[i] ) ; puts("") ; 
		rep( i, 1, n ) {
			init() ; 
			rep( j, 1, m ) if( a[i][j] && ( a[i][j] <= s[i] ) ) add( i, j + n, 1 ) ;
			flow = dinic() ; 
			if( !flow ) { ff[i] = i ; continue ; }
			for( int j = 1; j < i; ++ j ) {
				rep( k, 1, m ) if( a[j][k] == t[j] ) add( j, k + n, 1 ) ;
				flow += dinic() ; 
				if( flow != AA[j] + 1 ) { ff[i] = i - j ; break ; }
			} 
		}
		rep( i, 1, n ) printf("%d ", ff[i] ) ; puts("") ;
		memset( ff, 0, sizeof(ff) ) ; 
	}
	return 0 ;
}
```

---

## 作者：Ryan_ (赞：1)

**（解题思路：网络流+二分）**

第一问：

左边一列点代表学生，右边一列点代表导师

导师向汇点连流量为 人数限制的 边

然后从第一个学生的第一志愿往里面加边

如果当前学生的当前志愿可以满足，即目前网络流可以满流，保留这一志愿的边，然后下一个学生

否则，删除这一志愿的边，然后下一个志愿



------------
第二问：

二分这个学生要前进多少名

假设是学生i要前进x名

把前i-x-1名的学生 在第一问中满足的志愿 的边加进去

在把学生i的边加进去

判断是否满流

注意判断满流的时候 不包括前i-x-1名学生里没有任何导师的学生

AC代码如下：

```
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;

#define N 201
#define M 80801 

int n,m;

int lim[N];
int a[N][N][N];
int cnt[N][N];

int dream[N];

int tot=1;
int src,decc;
int lev[N<<1],cur[N<<1];
int front[M<<1],nxt[M<<1],to[M<<1],cap[M<<1];
queue<int>q;

int st[N];

inline void read(int &x)
{
    x=0; char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) { x=x*10+c-'0'; c=getchar(); }
}

inline void init()
{
    read(n); read(m);
    decc=n+m+1;
    for(int i=1;i<=m;++i) read(lim[i]);
    int x;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
        {
            read(x);
            if(x) a[i][x][++cnt[i][x]]=j;
        }
    for(int i=1;i<=n;++i) read(dream[i]);
}

inline void add(int u,int v,int w)
{
    to[++tot]=v; nxt[tot]=front[u]; front[u]=tot; cap[tot]=w;
    to[++tot]=u; nxt[tot]=front[v]; front[v]=tot; cap[tot]=0;
}

inline bool bfs()
{
    for(int i=0;i<=decc;++i) cur[i]=front[i],lev[i]=-1;
    while(!q.empty()) q.pop();
    q.push(src);
    lev[src]=0;
    int now,t;
    while(!q.empty())
    {
        now=q.front();
        q.pop();
        for(int i=front[now];i;i=nxt[i])
        {
            t=to[i];
            if(lev[t]==-1 && cap[i])
            {
                lev[t]=lev[now]+1;
                if(t==decc) return true;
                q.push(t);
            }
        }
    }
    return false;
}

inline int dinic(int now,int flow)
{
    if(now==decc) return flow;
    int rest=0,delta;
    for(int &i=cur[now];i;i=nxt[i])
        if(cap[i] && lev[to[i]]==lev[now]+1)
        {
            delta=dinic(to[i],min(flow-rest,cap[i]));
            if(delta)
            {
                rest+=delta; 
                cap[i]-=delta; cap[i^1]+=delta;
                if(rest==flow) break;
            }
        }
    if(rest!=flow) lev[now]=-1;
    return rest;
}

void solve1()
{
    for(int i=1;i<=m;++i) add(n+i,decc,lim[i]);
    int ok;
    for(int i=1;i<=n;++i)
    {
        add(src,i,1);
        for(int j=1;j<=m;++j)
            if(cnt[i][j])
            {
                for(int k=1;k<=cnt[i][j];++k) add(i,n+a[i][j][k],1);
                if(bfs()) 
                {
                    dinic(src,i);
                    st[i]=j;
                    break;
                }
                else
                {
                    for(int k=1,h=tot;k<=cnt[i][j];++k,h-=2) cap[h]=cap[h-1]=0;
                }
            }
    }
    for(int i=1;i<=n;++i) printf("%d ",st[i] ? st[i] : m+1);
    putchar('\n');
}

inline bool check(int x,int goal)
{
    tot=1;
    memset(front,0,sizeof(front));
    for(int i=1;i<=m;++i) add(n+i,decc,lim[i]);
    int ok=0;
    for(int i=1;i<goal;++i)
    {
        add(src,i,1);
        if(!st[i]) 
        {
            ok++;
            continue;
        }
        for(int j=1;j<=cnt[i][st[i]];++j) add(i,n+a[i][st[i]][j],1);
    }
    add(src,x,1);
    for(int i=1;i<=dream[x];++i)
        for(int j=1;j<=cnt[x][i];++j) add(x,n+a[x][i][j],1);
    while(bfs()) ok+=dinic(src,goal);
    return ok==goal;
}

void solve2()
{
    int l,r,mid,ans;
    for(int i=1;i<=n;++i)
    {
        if(st[i] && st[i]<=dream[i])
        {
            printf("0 ");
            continue;
        }
        ans=i;
        l=1; r=i-1;
        while(l<=r)
        {
            mid=l+r>>1;
            if(check(i,i-mid)) ans=mid,r=mid-1;
            else l=mid+1;
        }
        printf("%d ",ans);
    }
    putchar('\n');
}

void clear()
{
    memset(st,0,sizeof(st));
    memset(cnt,0,sizeof(cnt));
    memset(front,0,sizeof(front));
    tot=1;
}

int main()
{
    //freopen("mentor.in","r",stdin);
    //freopen("mentor.out","w",stdout);
    int T,C;
    read(T); read(C);
    while(T--)
    {
        clear();
        init();
        solve1();
        solve2();
    }
}
```


---

## 作者：云浅知处 (赞：0)

考虑 $C=1$ 怎么做，发现这个时候每个人的选择是唯一的，我们可以直接 $O(nm)$ 算一轮，对于第二问就直接二分，复杂度是 $O(n^2m\log n)$。

那么 $C>1$ 怎么办呢，这个时候问题在于某些人可能有多种选择，而他的多种选择可能带来不同的结果。一种想法是类似二分图匹配的匈牙利算法，我们对每个人从大往小枚举他可能的候选导师，如果当前这个导师已经满员了，我们尝试找这个导师的一个学生，让他再去换一个别的导师。

考虑仿照匈牙利算法，依次考虑每个人 $x$，发现他能匹配上导师 $y$ 当且仅当 $y$ 能够通过当前的残量网络到达一个没有满的导师。我们找到符合条件的 $y$ 中志愿最靠前的一个即可。

我们在每轮增广后 BFS 算出每个点能否到一个没有匹配满的导师即可。那么这部分的时间复杂度还是 $O(nm)$。进一步你发现二分都不需要了，我们在尝试加入 $i$ 的时候直接顺便把别的都算了就行。复杂度是 $O(n^2m)$。

```cpp
//哎哥真别说了你这样说大家看着都很难受而且说批话也对你没有好处所以真别说了
#include<bits/stdc++.h>

#define ll long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

void cmin(int &x,int v){x=min(x,v);}

const int N=205;
vector<int>vals[N][N];

const int M=1e5+5;
int head[M],t,ver[M],edge[M],nxt[M],tot=1;
queue<int>q;

int lim[N],a[N][N],C,n,m;

bool can[M];
int ncnt,lc[N],rc[N],to[M];
void bfs(){
	for(int i=0;i<=ncnt;i++)can[i]=0;
	can[t]=1,q.push(t);
	while(q.size()){
		int x=q.front();q.pop();
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i];if((!edge[i^1])||can[y])continue;
			can[y]=1,to[y]=(i^1),q.push(y);
		}
	}
}

int calc(int x){
	for(int i=1;i<=m;i++){
		for(int y:vals[x][i])if(can[rc[y]])return y;
	}
	return m+1;
}

void adde(int x,int y,int z){
	ver[++tot]=y,edge[tot]=z,nxt[tot]=head[x],head[x]=tot;
	ver[++tot]=x,edge[tot]=0,nxt[tot]=head[y],head[y]=tot;
}

int argu(int x){
	int y=calc(x);
	if(y==m+1)return y;
	int w=a[x][y];
	for(int p:vals[x][w])adde(lc[x],rc[p],1);
	int cur=rc[y];
	for(int i=head[x];i;i=nxt[i])if(ver[i]==cur)edge[i]--,edge[i^1]++;
	while(cur!=t){
		int i=to[cur];
		edge[i]--,edge[i^1]++,cur=ver[i];
	}
	return y;
}

int ep[N];
void solve(){
	n=read(),m=read();
	for(int i=1;i<=m;i++)lim[i]=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)a[i][j]=read(),vals[i][a[i][j]].emplace_back(j);
	for(int i=1;i<=n;i++)ep[i]=read();
	
	for(int i=1;i<=n;i++)lc[i]=++ncnt;
	for(int i=1;i<=m;i++)rc[i]=++ncnt;
	t=++ncnt;
	
	for(int i=1;i<=m;i++)adde(rc[i],t,lim[i]);
	
	vector<int>ans(n+1),res(n+1);
	for(int i=0;i<=n;i++)ans[i]=i;
	for(int i=1;i<=n;i++){
		bfs();
		for(int j=i+1;j<=n;j++){
			int y=calc(j);
			if(y!=m+1&&a[j][y]<=ep[j])cmin(ans[j],j-i);
		}
		int y=argu(i);
		if(y==m+1){res[i]=m+1;continue;}
		res[i]=a[i][y];if(a[i][y]<=ep[i])cmin(ans[i],0);
	}
	for(int i=1;i<=n;i++)cout<<res[i]<<" \n"[i==n];
	for(int i=1;i<=n;i++)cout<<ans[i]<<" \n"[i==n];
	
	for(int i=1;i<=tot;i++)nxt[i]=edge[i]=ver[i]=0;
	for(int i=1;i<=ncnt;i++)head[i]=0;tot=1,ncnt=0;
	for(int i=1;i<=n;i++)for(int j=0;j<=m;j++)vals[i][j].clear();
}

signed main(void){

#ifdef YUNQIAN
	freopen("in.in","r",stdin);
#endif

	int tt=read(),C=read();
	while(tt--)solve();

	return 0;
}
```

---

## 作者：Danno0v0 (赞：0)

这是一个因为多测不清零的悲惨故事：

![](https://cdn.luogu.com.cn/upload/image_hosting/ra83ydhp.png?x-oss-process=image)

### (首)  希望各位引以为戒

让我们来看这道题。

你看到导师和选手间要匹配，你想到了二分图匹配。

你看到导师选择名额有上限，你更加确定这是一道二分图匹配。你按照套路，将一名上限为 $p$ 的导师与汇点连一条流量为  $p$ 的边。

正当你准备一鼓作气把所有选手与导师之间只要有关系就连一条边然后准备跑一遍最大流就完事的时候，你想起这道题有边是有优先级的：

- 在前的选手比在后的选手更优先匹配。

- 相同的选手志愿前的比志愿后的更优先匹配。

于是你想到了费用流，让最小费用引导程序优先选这些边。

理论上完全可行：

![](https://cdn.luogu.com.cn/upload/image_hosting/tvsdgez8.png?x-oss-process=image)

（)

你看着后面的TLE陷入了沉思。也许是你建图建的很丑的原因，但是你决定不去想费用流了。

于是你考虑如何让最大流实现这些优先级。

于是，你决定按选手排名加边，选手内部按照志愿加边，这样就能保证选的时候是按优先级跑的。

于是你给了自己一组 hack：

```
1 2
2 2
1 1
1 2
1 0
1 1
```

你发现加入第二个人的时候，为了加入第二个人，把第一个人从第一志愿移到了第二志愿。

于是你决定，每次按照志愿优先级相同的边为一组，一组一组加。如果这一组边没有能让选手匹配，你就删掉；如果成功匹配，就不再这个选手加后面优先级的边，这样就可以保证志愿优先级不会变了。

然后你发现还有第二问。

你发现了一个显然的性质：假如一个选手排在某个选手后不会沮丧，那么他排在这个选手之前的选手之后也不会沮丧。

于是自然地你想到了二分。

于是在第一问里，你记录了每个人匹配完毕后他们的残量网络情况。（顺带一提，第一问的删边可以通过反复读上一位选手的残量网络进行回档XD）你二分了一个答案，你在这个答案选手的残量网络上加上了目标选手的在沮丧值之下的边。你尝试寻找增广路。你发现，假如找到了增广路，说明排在这个选手之后目标选手不会沮丧。于是第二问也过了。

最后说一句：**多测不清空，爆错两行泪。**~~我杀你一千遍也不够，志愿填报~~

code:

```cpp

#include<bits/stdc++.h>
using namespace std;
int t,C,n,m,b,x,S,T;
int fi[1001][1001],nx[300][70000],to[300][70000],val[300][70000],tot[666];
int depth[1001];
pair<int,int>choose[1001][2222];
int ccnt[1001];
int want[1001];
int final[1001],finalwant[1001];
void link(int a,int b,int c,int p)
{
	nx[p][++tot[p]]=fi[p][a];
	fi[p][a]=tot[p];
	to[p][tot[p]]=b;
	val[p][tot[p]]=c;
}
bool bfs(int p)
{
	queue<int>que;
	memset(depth,0x3f3f3f3f,sizeof(depth));
	depth[S]=0;
	que.push(S);
	while(!que.empty())
	{
		int x=que.front();
		que.pop();
		for(int i=fi[p][x];i;i=nx[p][i])
		{
			int v=to[p][i];
			if(val[p][i]&&depth[v]>depth[x]+1)
			{
				depth[v]=depth[x]+1;
				que.push(v);
			}
		}
	}
	return depth[T]<0x3f3f3f3f;
}
int dinic(int x,int in,int p)
{
	if(x==T) return in;
	int out=0;
	for(int i=fi[p][x];i&&in;i=nx[p][i])
	{
		int v=to[p][i];
		if(val[p][i]&&depth[v]==depth[x]+1)
		{
			int res=dinic(v,min(val[p][i],in),p);
			in-=res;
			out+=res;
			val[p][i]-=res;
			val[p][i^1]+=res;
		}
	}
	if(!out) depth[x]=0;
	return out;
}
bool cmp(pair<int,int>a,pair<int,int>b)
{
	return a.first<b.first;
}
int main()
{
	cin>>t>>C;
	while(t--)
	{
		memset(fi,0,sizeof(fi));
		memset(ccnt,0,sizeof(ccnt));
		memset(choose,0,sizeof(choose));//听我说谢谢你 
		cin>>n>>m;
		S=0,T=n+m+1;
		for(int i=0;i<=n;i++)
			tot[i]=1,final[i]=m+1,finalwant[i]=i;
		for(int i=1;i<=m;i++)
		{
			cin>>b;
			link(i+n,T,b,0);
			link(T,i+n,0,0);
		}	
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				cin>>x;
				if(x)
					choose[i][++ccnt[i]]={x,j};
			}	
			sort(choose[i]+1,choose[i]+ccnt[i]+1,cmp);
		}
		for(int i=1;i<=n;i++)
			cin>>want[i];
		for(int i=1;i<=n;i++)
			for(int p=1;p<=ccnt[i];)
			{
				tot[i]=tot[i-1];
				for(int j=0;j<=T;j++)
					fi[i][j]=fi[i-1][j];
				for(int j=2;j<=tot[i-1];j++)
					nx[i][j]=nx[i-1][j],to[i][j]=to[i-1][j],val[i][j]=val[i-1][j];
				//以上全部在反复读档 
				link(S,i,1,i);
				link(i,S,0,i);
				int color=choose[i][p].first;
				while(choose[i][p].first==color)
				{
					link(i,choose[i][p].second+n,1,i);
					link(choose[i][p].second+n,i,0,i);
					p++;
				} 
				if(bfs(i))
				{
					dinic(S,0x7fffff,i);
					final[i]=color;
					break;
				}
			}
		for(int i=1;i<=n;i++)
		{
			int l=0,r=i-1,mid;
			while(l<=r)
			{
				int mid=(l+r)>>1;
				tot[n+1]=tot[mid];
				for(int j=0;j<=T;j++)
					fi[n+1][j]=fi[mid][j];
				for(int j=2;j<=tot[mid];j++)
					nx[n+1][j]=nx[mid][j],to[n+1][j]=to[mid][j],val[n+1][j]=val[mid][j];
				//用没有用到的n+1来专门读档 
				link(S,i,1,n+1);
				link(i,S,0,n+1);
				for(int j=1;j<=ccnt[i]&&choose[i][j].first<=want[i];j++)
				{
					link(i,choose[i][j].second+n,1,n+1);
					link(choose[i][j].second+n,1,0,n+1);
				}
				if(bfs(n+1))
				{
					finalwant[i]=i-mid-1;
					l=mid+1;
				}
				else
					r=mid-1;
			}
		}
		for(int i=1;i<=n;i++)
			cout<<final[i]<<" ";
		cout<<endl;
		for(int i=1;i<=n;i++)
			cout<<finalwant[i]<<" ";
		cout<<endl;
	}
}

```

---

## 作者：orz_z (赞：0)

题面自己看吧。。。

#### std

对于第一问，容易想到是二分图匹配。

具体模型：

* $s$ 向学生连流量为 $1$ 的边。
* 导师向 $t$ 连流量为人数限制的边。
* 从第一个学生的第一志愿往里面加边，如果当前学生的当前志愿可以满足，即目前网络流可以满流，保留这一志愿的边，然后下一个学生；否则，删除这一志愿的边，然后下一个志愿。

对于第二问，可以枚举这个学生要前进多少名。

假设当前学生 $i$ 前进 $x$ 名。

那么把学生 $i$ 的可以使他不沮丧的所有志愿的所有边连上。

再把前 $i - x - 1$ 名学生满足第一问中的志愿的边连上。

判断是否满流即可。

总结：动态加边网络流。

```cpp
#include <bits/stdc++.h>

using namespace std;

namespace Fread
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

inline int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9')
    {
        if(c == '-') f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

inline void write(int x)
{
    if(x < 0)
    {
        putchar('-');
        x = -x;
    }
    if(x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

typedef int tp;

const int _ = 3e3 + 10;

int n, m, s, t, lv[_], cur[_];

int tot = 1, head[_], mcp[_], to[_ << 1], nxt[_ << 1];

tp w[_ << 1];

inline void add(int u, int v, tp dis)
{
    to[++tot] = v;
    nxt[tot] = head[u];
    w[tot] = dis;
    head[u] = tot;
}

inline void Add(int u, int v, tp dis)
{
	add(u, v, dis);
	add(v, u, 0);
}

inline bool bfs()
{
    memset(lv, -1, sizeof(lv));
    lv[s] = 0;
    memcpy(cur, head, sizeof(head));
    queue<int> q;
    q.push(s);
    while (!q.empty())
    {
        int p = q.front();
        q.pop();
        for (int eg = head[p]; eg; eg = nxt[eg])
        {
            int v = to[eg];
			tp vol = w[eg];
            if (vol > 0 && lv[v] == -1)
                lv[v] = lv[p] + 1, q.push(v);
        }
    }
    return lv[t] != -1;
}

tp dfs(int p = s, tp flow = 2e9)
{
    if (p == t)
        return flow;
    tp rmn = flow;
    for (int eg = cur[p]; eg && rmn; eg = nxt[eg])
    {
        cur[p] = eg;
        int v = to[eg];
		tp vol = w[eg];
        if (vol > 0 && lv[v] == lv[p] + 1)
        {
            tp c = dfs(v, min(vol, rmn));
            rmn -= c;
            w[eg] -= c;
            w[eg ^ 1] += c;
        }
    }
    return flow - rmn;
}

inline tp dinic()
{
    tp ans = 0;
    while (bfs())
        ans += dfs();
    return ans;
}

int a[207][207], b[_], sv[_], A[_], tv[_], f[_];

inline void init()
{
	tot = 1;
	memset(head, 0, sizeof head);
	s = 0, t = _ - 1;
	for(int i = 1; i <= n; ++i)
		Add(s, i, 1);
	for(int i = 1; i <= m; ++i)
		Add(i + n, t, b[i]);
	memcpy(mcp, head, sizeof head);
}

signed main()
{
	int T = read();
	read();
	while(T--)
	{
		n = read(), m = read();
		for(int i = 1; i <= m; ++i)
			b[i] = read();
		for(int i = 1; i <= n; ++i)
			for(int j = 1; j <= m; ++j)
				a[i][j] = read();
		for(int i = 1; i <= n; ++i)
			sv[i] = read();
		init();
		int Fl = 0, bef = 0;
		for(int i = 1; i <= n; ++i)
		{
			int id = m + 1, rnt = tot;
			for(int j = 1; j <= m; ++j)
			{
				for(int k = 1; k <= m; ++k)
					if(a[i][k] == j)
						Add(i, k + n, 1);
				Fl += dinic();
				if(Fl ^ bef)
				{
					id = j, bef = Fl;
					break;
				}
				else
				{
					tot = rnt;
					memcpy(head, mcp, sizeof mcp);
				}
			}
			A[i] = Fl, tv[i] = id;
			memcpy(mcp, head, sizeof head);
		}
		for(int i = 1; i <= n; ++i)
			write(tv[i]), putchar(' ');
		putchar('\n');
		for(int i = 1; i <= n; ++i)
		{
			init();
			for(int j = 1; j <= m; ++j)
				if(a[i][j] && a[i][j] <= sv[i])
					Add(i, j + n, 1);
			Fl = dinic();
			if(!Fl)
			{
				f[i] = i;
				continue;
			}
			for(int j = 1; j < i; ++j)
			{
				for(int k = 1; k <= m; ++k)
					if (a[j][k] == tv[j]) Add(j, k + n, 1);
                Fl += dinic();
                if (Fl != A[j] + 1)
                {
                    f[i] = i - j;
                    break;
                }
			}
		}
		for(int i = 1; i <= n; ++i)
			write(f[i]), putchar(' ');
			putchar('\n');
		memset(f, 0, sizeof f);
	}
	return 0;
}
```



---

## 作者：JiaY19 (赞：0)

**$n^{2}$过百万，暴力出奇迹！**

一道比较暴力的题目，蒟蒻也只会暴力的做法。

### 思路

可以一眼看出是一个二分图，所以考虑网络流做法。
 
首先考虑暴力网络流。

源点向每一位选手连流量为一的边。

每一位评委向汇点连流量为 $b_{i}$ 的边。
 
对于每一次操作都直接连边，暴力跑网络流，来解决两个问题。
 
我们发现复杂度太过巨大，可以进行一波优化。

#### 如何优化

首先考虑第一个问题。

根据题意，我们发现，在最优情况下，每个选手“反悔”的老师只有同样志愿等级的老师。

我们很快就能想到动态连边和动态删边。

我们对每一个志愿等级的老师进行连边，如果还有余流，则记录答案；如果没有，则删掉这些边，继续遍历下一个志愿等级的老师。

至于之前选手跑过的残量网络不需删除，直接跑就行了，因为需要有反悔的余地。

当然，如果这位选手一个答案都没找到，那么连源点向他连得边都可以删掉。
 
接着再考虑第二个问题。

一个很容易看出的就是首先进行二分。

对于二分，我们考虑一个比较暴力的思路，记录下之前，最优解的每一个时间（每一个选手加入的时候）的残量网络，接着暴力加边，跑一遍网络流，检测有没有余流。

可以推算一下这个暴力做法的复杂度。

每一次二分为：$O(\log n)$

网络流跑二分图为：$O(n \sqrt{m})$

所以第二个问题复杂度为：$O(n^{2} \sqrt{m}\log n)$

发现复杂度好像是一个正确的。

只能说是暴力出奇迹吗。

#### Code

看着人均 $2kb$ 的代码，$4kb$ 的我陷入了沉思。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf = 1e7;

int t , c , n , m , sl , tl , cnt = 1;

int head[500] , b[500] , s[500] , cnt2[500];

int dep[500] , ans[500] , cop[500][500];

pair<int , int> a[500][500];

struct edge
{
	int to , nxt , v;
}e[10000] , ce[300][10000];

inline int read()
{
	int asd = 0 , qwe = 1; char zxc;
	while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
	while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
	return asd * qwe;
}

inline void add(int x , int y , int z)
{
	e[++cnt] = (edge){y , head[x] , z} , head[x] = cnt;
	e[++cnt] = (edge){x , head[y] , 0} , head[y] = cnt;
}

inline bool bfs()
{
	memset(dep , 0 , sizeof(dep));
	queue<int> q; 
	
	dep[sl] = 1 , q.push(sl);
	
	while(q.empty() == 0)
	{
		int x = q.front(); q.pop();
		for(int i = head[x];i;i = e[i].nxt)
		{
			int y = e[i].to;
			if(dep[y] == 0 && e[i].v > 0) dep[y] = dep[x] + 1 , q.push(y);
		}
	}
	
	return dep[tl];
}

inline int dfs(int now , int flow , int &mflow)
{
	if(now == tl)
	{
		mflow += flow;
		return flow;
	}
	
	int used = 0;
	
	for(int i = head[now];i;i = e[i].nxt)
	{
		int x = e[i].to;
		if(e[i].v && dep[x] == dep[now] + 1)
		{
			int y = dfs(x , min(e[i].v , flow - used) , mflow);
			used += y , e[i].v -= y , e[i ^ 1].v += y;
			if(used == flow) return used;
		}
	}
	
	return used;
}

inline int Dinic()
{
	int sum = 0;
	while(bfs()) while(dfs(sl , inf , sum));
	return sum;
}

inline void solve1()
{
	cnt2[0] = cnt;
	memset(ce[0] , 0 , sizeof(ce[0]));
	memset(cop[0] , 0 , sizeof(cop[0]));
	
	for(int i = 1;i <= cnt;i++) ce[0][i] = e[i];
	for(int i = 1;i <= n + m + 2;i++) cop[0][i] = head[i];
	
	for(int i = 1;i <= n;i++) 
	{ 
		ans[i] = m + 1;
		int last = a[i][1].first;
		add(sl , i , 1);
		for(int j = 1;j <= m && a[i][j].first != inf;j++) 
		{ 
			if(a[i][j].first == last) 
				add(i , a[i][j].second + n , 1);
			else 
			{ 
				int sum = Dinic();
				if(sum == 1) 
				{ 
					ans[i] = last;
					break;
				} 
				else
				{ 
					cnt = cnt2[i - 1];
					memcpy(e , ce[i - 1] , sizeof(ce[i - 1]));
					memcpy(head , cop[i - 1] , sizeof(cop[i - 1]));
					add(sl , i , 1) , add(i , a[i][j].second + n , 1) , last = a[i][j].first;
				} 
					
			} 
		} 
		
		if(ans[i] == m + 1)
		{ 
			int sum = Dinic();
			if(sum == 1) ans[i] = last;
			else
			{ 
				cnt = cnt2[i - 1];
				memcpy(e , ce[i - 1] , sizeof(ce[i - 1]));
				memcpy(head , cop[i - 1] , sizeof(cop[i - 1]));
			} 
		} 
		
		memset(ce[i] , 0 , sizeof(ce[i]));
		memset(cop[i] , 0 , sizeof(cop[i]));
		
		cnt2[i] = cnt;
		for(int j = 1;j <= cnt;j++) ce[i][j] = e[j];
		for(int j = 1;j <= n + m + 2;j++) cop[i][j] = head[j];
		
		printf("%d " , ans[i]);
	}
	puts("");
}

inline void calc(int x , int y)
{
	cnt = cnt2[x - 1];
	memcpy(e , ce[x - 1] , sizeof(ce[x - 1]));
	memcpy(head , cop[x - 1] , sizeof(cop[x - 1]));
	add(sl , y , 1);
	for(int i = 1;i <= m && a[y][i].first <= s[y];i++) add(y , a[y][i].second + n , 1);
}

inline void solve2()
{
	for(int i = 1;i <= n;i++)
	{
		if(ans[i] <= s[i]) 
		{
			printf("0 ");
			continue;
		}
		
		
		int l = 1 , r = i - 1 , sum = 0;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			calc(mid , i);
			int num = Dinic();
			if(num == 1) l = mid + 1 , sum = mid;
			else r = mid - 1;
		}
		
		printf("%d " , i - sum);
	}
	puts("");
}

int main()
{
	t = read() , c = read();
	
	while(t--)
	{
		n = read() , m = read() , sl = n + m + 1 , tl = n + m + 2 , cnt = 1;
		
		for(int i = 1;i <= m;i++) b[i] = read();
		
		for(int i = 1;i <= n;i++)
		{
			for(int j = 1;j <= m;j++)
			{
				a[i][j].first = read() , a[i][j].second = j;
				if(a[i][j].first == 0) a[i][j].first = inf;
			}
			sort(a[i] + 1 , a[i] + m + 1);
		}
		
		for(int i = 1;i <= n;i++) s[i] = read();
		
		for(int i = 1;i <= m;i++) add(i + n , tl , b[i]);
		
		solve1() , solve2();
		
		
		memset(e , 0 , sizeof(e));
		memset(s , 0 , sizeof(s));
		memset(b , 0 , sizeof(b));
		memset(cnt2 , 0 , sizeof(cnt2));
		memset(head , 0 , sizeof(head));
		
	}
	
	return 0;
}

```



---

## 作者：EMT__Mashiro (赞：0)

修改Hungary可以解决第一问。   
按排名从前往后到大枚举学员$u$，再从优至劣枚举志愿等级，再任意枚举该志愿等级中的导师$x$，若$x$的战队名额未满，那么直接让$u$进入$x$的战队。否则按枚举$x$的战队中的学员$v$，递归检查能否让$v$选择对他而言和$x$同一等级的导师，如果成功的话就可以让$u$进入$x$的战队。   
对于第二问，首先我们判断掉可以进入理想的等级的战队的学员，对于剩下的学员$u$，我们给出一个结论：   
> 在枚举$u$的前$s_i$级志愿进行增广时我们会找到一些交错路，让$u$选择交错路中的任何一个学员并升上他的排名都可以让$u$进入理想的等级的战队。
 
证明：   

> 选择交错路以外的学员一定非法，这个是显然的。   
> 所有交错路一定是$u\rightarrow x\Rightarrow u_0\rightarrow v_0\cdots$形式的（单箭头指未匹配边，双箭头指匹配边）。   
> $u$的前$s_i$志愿等级的所有导师构成的集合就是所有$x$构成的集合，而这些导师的战队中的成员就是$u_0$构成的集合。   
> 如果让$u$上升至任意一个$u_0$的排名，他就可以直接匹配$x$。   
> 如果让$u$上升至任意一个$u_i$的排名，这就相当于是$u$取代了交错路中$u_i$的位置。   
> 那么让$u$匹配$x$，并修改$u_j(j<i)$匹配$v_j$即可成功匹配。   
> 那么交错路中的学员一定是一个合法的方案，因此选择交错路中排名最低的学员即可。   

```c++
#include<cctype>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
const int N=207;
int n,m,mx,now,b[N],s[N],up[N],id[N],vis[N],bel[N];std::vector<int>a[N][N];
int read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}
int dfs(int u,int k)
{
    if(u^now) mx=std::max(mx,u);
    for(int x:a[u][k])
	if(!vis[x])
	{
	    if(vis[x]=1,b[x]) return --b[x],id[u]=k,bel[u]=x;
	    for(int v=n;v;--v) if(v^u&&bel[v]==x) if(dfs(v,id[v])) return id[u]=k,bel[u]=x; 
	}
    return 0;
}
void solve()
{
    n=read(),m=read(),memset(bel+1,0,n*4);
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) a[i][j].clear();
    for(int i=1;i<=m;++i) b[i]=read();
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) a[i][read()].push_back(j);
    for(int i=1;i<=n;++i) s[i]=read(),id[i]=m+1,up[i]=i;
    for(int i=1;i<=n;++i)
    {
	memset(vis+1,0,m*4),now=i;
	for(int j=1;j<=m;++j)
	    if(a[i][j].size())
	    {
		if(mx=0,dfs(i,j)) {if(j<=s[i])up[i]=0; break;}
		if(j<=s[i]) up[i]=std::min(up[i],i-mx);
	    }
    }
    for(int i=1;i<=n;++i) printf("%d ",id[i]);puts("");
    for(int i=1;i<=n;++i) printf("%d ",up[i]);puts("");
}
int main(){for(int T=read(),C=read();T;--T)solve();}
```

---

## 作者：asuldb (赞：0)

[题目](https://www.luogu.org/problemnew/show/P4382)

一个第二问不用二分的做法

第一问非常裸，就是一个动态加边的$dinic$，我们从$1$到$n$考虑每一个人的每一个志愿，每次把这个人这一志愿的所有边都连出来，跑最大流发现流量增加就说明这个志愿匹配上了，退出做下一个人；否则就做这个人的下一个志愿

在$dinic$的时候删掉没有用的边会让代码快很多

第二问看起来非常二分，但是二分需要我们每次都重构出残量网络或者是暴力存下所有残量网络，这有点过于暴力了

于是我们考虑每当我们构造出前$i$个人的残量网络的时候，我们就把之后的$n-i$个人的前$s$志愿的边加进来，跑$dinic$看看能否匹配，如果能匹配上我们给这个人记录一下，同时退流

由于我们需要删掉这个人的所有边，我们没有必要完整退流，只需要把汇点向这个人所连的导师指向汇点的边给退流就好了

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=405;
const int inf=1e9;
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
std::vector<int> v[205][205];
std::queue<int> q;
struct E{int v,nxt,f;}e[maxn*maxn];
int h[maxn*maxn];
int Te,Cc,S,T,b[205],ans[205],a[205],vis[205],g[205],id[205];
int n,m,tot,r[maxn],num;
int head[maxn],d[maxn],cur[maxn];
inline void C(int x,int y,int f) {
	e[++num].v=y;e[num].nxt=head[x];
	head[x]=num;e[num].f=f;h[num]=x;
}
inline void add(int x,int y,int f) {C(x,y,f),C(y,x,0);}
inline int BFS() {
	for(re int i=1;i<=tot;i++) d[r[i]]=0,cur[r[i]]=head[r[i]];
	d[S]=1,q.push(S);
	while(!q.empty()) {
		int k=q.front();q.pop();
		for(re int i=head[k];i;i=e[i].nxt)
		if(!d[e[i].v]&&e[i].f) d[e[i].v]=d[k]+1,q.push(e[i].v);
	}
	return d[T];
}
int dfs(int x,int now) {
	if(x==T||!now) return now;
	int flow=0,ff;
	for(re int& i=cur[x];i;i=e[i].nxt)
	if(d[e[i].v]==d[x]+1) {
		ff=dfs(e[i].v,min(e[i].f,now));
		if(ff<=0) continue;
		now-=ff,flow+=ff,e[i].f-=ff,e[i^1].f+=ff;
		if(!now) break;
	}
	return flow;
}
inline void reBuild() {
	tot=0;
	S=0,T=n+m+1;
	r[++tot]=S,r[++tot]=T;
	for(re int i=1;i<=m;i++) 
		r[++tot]=n+i,id[i]=num+1,add(n+i,T,b[i]);
}
inline void back(int pre) {
	while(num>pre) {head[h[num]]=e[num].nxt;num--;} 
}
int main() {
	Te=read(),Cc=read();
	while(Te--) {
		n=read(),m=read();
		memset(head,0,sizeof(head));num=1;
		memset(vis,0,sizeof(vis));
		memset(ans,0,sizeof(ans));
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++)
				v[i][j].clear();
		for(re int i=1;i<=m;i++) b[i]=read();
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) {
				int k=read();
				if(!k) continue;
				v[i][k].push_back(j);
			}
		reBuild();
		int now=0;
		for(re int i=1;i<=n;i++) {
			r[++tot]=i;add(S,i,1);now=num;
			for(re int j=1;j<=m;j++) {
				for(re int k=0;k<v[i][j].size();++k)
					add(i,v[i][j][k]+n,1);
				int mid=0;
				while(BFS()) mid+=dfs(S,inf);
				if(mid>=1) {ans[i]=j;break;}
				back(now);
			}
		}
		for(re int i=1;i<=n;i++) if(!ans[i]) ans[i]=m+1;
		for(re int i=1;i<=n;i++) a[i]=read();
		for(re int i=1;i<=n;i++) printf("%d ",ans[i]);
		putchar(10);
		memset(head,0,sizeof(head));num=1;
		for(re int i=1;i<=n;i++) {
			if(ans[i]<=a[i]) {vis[i]=1;g[i]=i;continue;}
			for(re int j=1;j<=a[i];j++) vis[i]+=v[i][j].size();
			if(vis[i]) vis[i]=0;
				else vis[i]=1,g[i]=0;
		}
		for(re int i=1;i<=n;i++) if(!vis[i]) g[i]=1;
		reBuild();
		for(re int i=1;i<=n;i++) {
			r[++tot]=i;add(S,i,1);now=num;
			for(re int j=1;j<=m;j++) {
				for(re int k=0;k<v[i][j].size();++k)
					add(i,v[i][j][k]+n,1);
				int mid=0;
				while(BFS()) mid+=dfs(S,inf);
				if(mid>=1) break;
				back(now);
			}
			now=num;
			for(re int j=i+2;j<=n;j++) {
				if(vis[j]) continue;
				r[++tot]=j;add(S,j,1);
				for(re int p=1;p<=a[j];p++) 
					for(re int k=0;k<v[j][p].size();k++)
						add(j,v[j][p][k]+n,1);
				int mid=0;
				while(BFS()) mid+=dfs(S,inf);
				if(mid>=1) {
					g[j]=i+1;
					for(re int k=head[j];k;k=e[k].nxt)
					if(!e[k].f&&e[k].v>n) {
						e[id[e[k].v-n]].f++;
						e[id[e[k].v-n]^1].f--;
						break;
					}
				}
				tot--;back(now);
			}
		}
		for(re int i=1;i<=n;i++) printf("%d ",i-g[i]);
		putchar(10);
	}
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

我用的做法是两次二分+dinic 
第一次我们二分第i个人可以满足的最高志愿，check 即为讲前i-1个人连已求出的答案等同志愿的所有边，第i个人连不低于二分出的mid的所有边，若满流即正确。 答案即mid
第二次我们二分第i个人最晚出现在哪里可以被满足志愿，check 类似上一问。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
queue<int  > q;
const int inf = 1e9;
const int maxn =  510;
const int s=402;
const int t=403;
struct node{
	int to,next,flow;
}e[maxn*100];
int b[maxn],ss[maxn],zhiyuan[maxn][maxn][15],n,m,anss1[maxn],anss2[maxn],tot=1,h[maxn],dis[maxn],ttt[maxn];
bool vis[450];
bool is[maxn];
void clear()
{
	memset(is,0,sizeof(is));
	memset(ttt,0,sizeof(ttt));
	memset(zhiyuan,0,sizeof(zhiyuan));
}
void add(int from,int to,int flow)
{
	e[++tot].next=h[from];
	e[tot].to=to;
	e[tot].flow=flow;
	h[from]=tot;
	e[++tot].next=h[to];
	e[tot].to=from;
	e[tot].flow=0;
	h[to]=tot;
}
bool bfs()
{
	memset(vis,0,sizeof(vis));
	memset(dis,0,sizeof(dis));
	vis[s]=1;
	dis[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=h[u];i;i=e[i].next)
		{
			int to=e[i].to;
			if(!vis[to]&&e[i].flow)
			{
				q.push(to);
				vis[to]=1;
				dis[to]=dis[u]+1;
			}
		}
	}
	return vis[t];
}
int dfs(int x,int y)
{
	if(x==t||y==0) return y;
	int flow=0,f;
	for(int i=h[x];i;i=e[i].next)
	{
		int to=e[i].to;
		if(dis[to]==dis[x]+1&&(f=dfs(to,min(y,e[i].flow)))>0)
		{
			e[i].flow-=f;
			e[i^1].flow+=f;
			flow+=f;
			y-=f;
			if(y==0) break;
		}
	}
	if(y>0)
	dis[x]=-1;
	return flow;
}
int dinic()
{
	int ans=0;
	while(bfs()){
		ans+=dfs(s,10000000);
	}
	return ans;
}
bool check1(int now,int mid)
{
	for(int i=0;i<=tot;++i) e[i].flow=e[i].next=e[i].to=0;
	for(int i=0;i<=t;++i) h[i]=0;
	tot=1;
	for(int i=1;i<=now;++i)
	{
		if(is[i]) continue;
		add(s,i,1);
		if(i!=now)
		{
			int cnt=zhiyuan[i][anss1[i]][0];
			for(int j=1;j<=cnt;++j){
				add(i,zhiyuan[i][anss1[i]][j]+n,1);
			}
		}
		if(now==i)
		{
			for(int k=1;k<=mid;++k)
			{
				int cnt=zhiyuan[i][k][0];
				for(int j=1;j<=cnt;++j)
				{
					add(i,zhiyuan[i][k][j]+n,1);
				}
			}
		}
	}
	for(int i=1;i<=m;++i) add(i+n,t,b[i]);
	int tmp=dinic();
	if(tmp>=now-ttt[now-1]) return 1;
	else  return 0; 
}
bool check2(int now,int mid)
{
	for(int i=1;i<=tot;++i) e[i].flow=e[i].next=e[i].to=0;
	for(int i=1;i<=t;++i) h[i]=0;
	tot=1;
	for(int i=1;i<=mid-1;++i)
	{
		if(is[i]) continue;
		add(s,i,1);
		int cnt=zhiyuan[i][anss1[i]][0];
		for(int j=1;j<=cnt;++j)
		{
			add(i,zhiyuan[i][anss1[i]][j]+n,1);
		}
	}
	add(s,now,1);
	for(int i=1;i<=ss[now];++i)
	{
		int cnt=zhiyuan[now][i][0];
		for(int j=1;j<=cnt;++j)
		{
			add(now,zhiyuan[now][i][j]+n,1);
		}
	}
	for(int i=1;i<=m;++i)
	{
		add(i+n,t,b[i]);
	}
	int tmp=dinic();
	if(tmp>=mid-ttt[mid-1]) return 1;
	else return 0;
}
int main()
{
//	freopen("10.in","r",stdin);
//	freopen("std.out","w",stdout);
	int t,c;
	scanf("%d%d",&t,&c);
	while(t--){
		clear();
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;++i){
			scanf("%d",&b[i]);
		}
		for(int i=1;i<=n;++i){
			for(int  j=1;j<=m;++j){
				int x;
				scanf("%d",&x);
				if(x!=0)
				zhiyuan[i][x][++zhiyuan[i][x][0]]=j;
			}
		}
		for(int i=1;i<=n;++i) scanf("%d",&ss[i]);
		for(int i=1;i<=n;++i){// 第一次二分 二分第i个人可以满足的最高志愿 
			int l=1,r=m,ans=m+1;
			while(l<=r)
			{
				int mid=(l+r)/2;
				if(check1(i,mid)) r=mid-1,ans=mid;
				else l=mid+1;
			}
			ttt[i]=ttt[i-1];
			if(ans==m+1) is[i]=1,ttt[i]++;
			anss1[i]=ans;
		}
		for(int i=1;i<=n;++i)
		{// 第二次二分 二分第i个人可以满足理想的最靠后的位置 
			int l=1,r=i-1,ans=i;
			if(anss1[i]<=ss[i]) 
			{
				anss2[i]=0;
				continue;
			}
			while(l<=r){
				int mid=(l+r)/2;
				if(check2(i,mid))l=mid+1,ans=mid;
				else r=mid-1;
			}
			if(ans==i)
			{
				anss2[i]=ans;
			}
			else 
			{
				anss2[i]=i-ans;
			}
		}
		for(int i=1;i<=n;++i) 
		{
			cout<<anss1[i]<<" ";
		}
		cout<<endl;
		for(int i=1;i<=n;++i)
		{
			cout<<anss2[i]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```


---


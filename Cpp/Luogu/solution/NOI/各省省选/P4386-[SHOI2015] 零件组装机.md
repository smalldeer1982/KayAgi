# [SHOI2015] 零件组装机

## 题目描述

曾经发明了激光发生器的发明家 SHTSC 又公开了他的新发明：零件组装机——一种可以生产并组装零件的神秘装置。

一个零件是一张顶点由 $0$ 到 $n-1$ 标号的无向图，零件组装机有以下两种功能：

 1. 生产一个仅有一个顶点标号为$0$而没有边的零件。

 2. 组合两个已有的零件 $G_1$、$G_2$ ，且 $G_2$ 的顶点数 $m$ 大于等于 $G_1$ 的顶点数 $n$ ，得到新的零件 $G$ 。$G$ 的顶点集合是 $G_1,G_2$ 顶点集合的并集，并且 $G_2$ 的顶点 $i(0\leq i < m)$ 被重新标号为  $n+i$ 。$G$ 的边集是 $G_1,G_2$边集的并集再对所有标号为 $a(a \geq n)$ 的顶点添加一条连接$(a,a \mod n)$的无向边。

![](https://cdn.luogu.com.cn/upload/pic/17059.png)

现在 SHTSC 正在思考，对于一个给定的零件，能否由零件组装机生产组装得到。注意：零件是带标号的，这意味着两个零件即使仅有标号不同也被视为不同的零件。为了帮助你理解问题，SHTSC 特地给了你顶点数 $\le 5$的所有零件的图例。

![](https://cdn.luogu.com.cn/upload/pic/17060.png)

## 说明/提示

对于 $5\%$ 的数据，图给定的图联通且 $m = n - 1$；  
对于另 $15\%$ 的数据，$n \leq 5$；  
对于 $50\%$ 的数据，$n \leq 1000$；  
对于所有测试点，$t \leq 10$，$n,m \leq 100000$。


## 样例 #1

### 输入

```
3
1 0
2 0
4 6
0 1
0 2
1 2
1 3
2 3
3 0```

### 输出

```
YES
NO
YES```

# 题解

## 作者：_Sein (赞：2)

题意就给人一种分治的感觉，把联通块合并。

不妨先对给定的边进行处理，把$x>y$的情况交换一下($x<y$也行，不过要另进行讨论了)。

对于$y$，所有没有用到的边$(x_i,y)$，对于当前递归到的状态，产生贡献的一定是$\min\{x_i\}$

因为由于递归的性质，当前进行的就是最晚的。

反证一下也可以，如果不是$\min\{x_i\}$在当前状态放置，那么它先于一部分的$x_i$与$y$相连，但明显$G$图的编号是连续的，那么也就违背了题意，所以不成立。

因此只要统计出所有的$y$的最小$x_i$即可，这些是对于当前递归状态有贡献的。

引理:如果状态是合法的，其必然存在$siz$，使得$G_1$大小为$siz$，$G_2$大小为$n-siz$，$G_1$与$G_2$的并集恰好是当前状态，且$siz$是唯一的。

证明:由于$[0,siz)$与$[siz,2*siz),[2*siz,3*siz),\cdots$分别对应连边，连续的循环区间大小为$siz$，如果$siz$往左偏移，或往右偏移，都会导致区间不再循环。

处理好$siz$之后，断去两个联通块之间的连边，再当成子问题进行处理。

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
using namespace std;
const int N=1e5+5,M=1e6;
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;
	while(c<'0'||c>'9')c=gc;
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
}
void qw(int x)
{
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
struct edge
{
	int x,y;
	edge(int x=0,int y=0):x(x),y(y){}
	bool operator <(const edge a)const{return x==a.x?y<a.y:x<a.x;}
}a[N];
int L[N];bool v[N];//????????????? 
bool check(int n,int l,int r)
{
	if(n==1)return l==r;
	if(l==r)return 0;
	for(int i=0;i<n;i++)v[i]=0,L[i]=M;
	for(int i=l;i<r;i++)
	{
		int x=a[i].x,y=a[i].y;
		if(L[y]==x)return 0;
		L[y]=min(L[y],x); 
	}
	for(int i=0;i<n;i++)
		if(L[i]==0)v[i]=1;
		else if(L[i]==L[i-1]+1&&v[i-1])v[i]=1; 
	int siz;bool bk;
	for(int i=0;i<n/2;i++)
	{
		siz=i+1;bk=1;
		for(int j=i+siz;j<n;j+=siz)
		{
			if(L[j]==i&&v[j])continue;
			bk=0;break;
		}
		if(bk)break;
	}
	if(!bk)return 0;
	int p1=0,p2=0,i;
	for(i=l;i<r;i++)
	{
		int x=a[i].x,y=a[i].y;
		if(x==siz)break;
		if(y>=siz&&y%siz!=x) return 0;
		if(y>=siz)continue;
		a[p1++]=edge(x,y);
	}p2=p1;
	for(;i<r;i++)
	{
		int x=a[i].x,y=a[i].y;
		a[p2++]=edge(x-siz,y-siz);
	}
	return check(siz,0,p1)&&check(n-siz,p1,p2);
}
int main()
{
	int T;qr(T);
	while(T--)
	{
		int n,m;qr(n),qr(m);
		for(int i=0,x,y;i<m;i++){qr(x),qr(y);if(x>y)swap(x,y);a[i]=edge(x,y);}
		sort(a,a+m);
		if(check(n,0,m))puts("YES");
		else puts("NO");
	}
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：0)

蛮难搞的。

update：修改了 mod 的 LaTeX。笑了，原来是直接复制的题目。

## 题目大意
一个零件是一张顶点由 $0$ 到 $n-1$ 标号的无向图，零件组装机有以下两种功能：

1. 生产一个仅有一个顶点标号为 $0$ 而没有边的零件。

2. 组合两个已有的零件 $G_1$、$G_2$ ，且 $G_2$ 的顶点数 $m$ 大于等于 $G_1$ 的顶点数 $n$ ，得到新的零件 $G$ 。$G$ 的顶点集合是 $G_1,G_2$ 顶点集合的并集，并且 $G_2$ 的顶点 $i(0\leq i < m)$ 被重新标号为  $n+i$ 。$G$ 的边集是 $G_1,G_2$ 边集的并集再对所有标号为 $a(a \geq n)$ 的顶点添加一条连接 $(a,a \bmod n)$ 的无向边。

判断一个图是否是一个零件。

## 思路
来讲讲我的做法。首先我们可以判掉一些 naive 的情况，比如原图不连通，有重边自环等。接下来我们得到了一张无向简单连通图 $G$。

我们首先考虑 $0$ 这个点。一开始我的想法是，假设当前点数为 $n$，下标为 $0\sim n-1$。考虑所有和 $0$ 相邻的 $\ge \lfloor\dfrac n 2\rfloor$ 的点，则较小的图 $G_1$ 的大小 $size$ 为这些点标号的 $\gcd$ 的约数。

这一点是显然的，因为 $v\bmod size=0$ 说明 $size|v$。之所以是 $\gcd$ 的约数而不是 $\gcd$，是因为可能存在 $size$ 远小于 $\lfloor\dfrac n 2\rfloor$ 导致真正的 $size$ 这个点没有被访问到。枚举每个约数判断是否合法，期望得分 $50$。

我们关注到，上述表述中“真正的 $size$ 这个点没有被访问到”这句话，意思就是说下标等于 $size$ 的点必然和 $0$ 连边，并且更进一步地，范围内所有 $size$ 的倍数的点也必然和 $0$ 连边。那么我们可以写出与 $0$ 相邻的所有点，按照下标从小到大的顺序，比如下图这种情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/or9pilz1.png)

答案点 $size$ 的特征是：$size\le \lfloor\dfrac n 2\rfloor$，并且 $0$ 连向了所有 $size$ 及其倍数点。可以证明，如果记后缀 $\gcd$ 为 $suf_i$，则 $size$ 就是**从右往左第一个**下标 $id_i$等于 $suf_i$ 的点的下标，当然大小不能超过 $\lfloor\dfrac n 2\rfloor$。

得到 $size$ 以后，我们将下标在 $0\sim size-1$ 和下标在 $size\sim n$ 之间的对应连边切断，同时判断如果对应连边不存在则不合法。在切断完对应连边之后判断是否有多余连边，如果有则不合法。然后递归检查两个子图 $G_1,G_2$ 是否合法即可。实现的时候注意下标的平移。

由于 $|G_2|\ge \dfrac n 2$，$G_2$ 向 $G_1$ 每次连边的数量至少为 $\dfrac n 2$。那么每次相当于删去了至少 $\dfrac n 2$ 条边，并且每条边只会被访问到 $O(1)$ 次。像广义串并联图那样，使用 `map` 快速维护邻接表，时间复杂度大概为线性对数，期望得分 $100$。

由于写了很久才有思路，代码一团糟，仅供参考，保留了枚举约数的 $50$ 分部分。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5;
template <typename T>
inline void chkmax(T &x, T y) {x = (x > y ? x : y);}
template <typename T>
inline void chkmin(T &x, T y) {x = (x < y ? x : y);}
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int T, n, m, cnt;
vector <int> e[maxn];
map <int, bool> mp[maxn], tmp[maxn];
int fa[maxn];
inline int find(int u) {return u == fa[u] ? u : fa[u] = find(fa[u]);}
inline void merge(int u, int v) {
	u = find(u), v = find(v);
	if(u != v) fa[u] = v, cnt --;
}
inline int gcd(int a, int b) {return !b ? a : gcd(b, a % b);}
inline bool checkg(int L, int R, int g) {
	rep(i, L, R) tmp[i] = mp[i];
	rep(i, L + g, R) {
		if(!tmp[i][((i -L) % g) + L]) return 0;//return write(g), write(L), write(R), 0;
		tmp[i].erase(((i - L) % g) + L), tmp[((i - L) % g) + L].erase(i);
	}
	rep(i, L, L + g - 1) if(!tmp[i].empty() && (*tmp[i].rbegin()).first >= L + g) return  0;
	rep(i, L + g, R) if(!tmp[i].empty() && (*tmp[i].begin()).first < L + g) return  0;	
	return 1;
}
//vector <int> d[maxn];
//inline void init(int N) {
//	rep(i, 1, N) for(int j = i; j <= N; j += i) d[j].push_back(i);
//}

inline bool check(int L, int R) {
	if(L == R) return 1;
	int nV = R - L + 1;
	int hV = (nV >> 1), u = L, g = 0;
	vector <int> seq, suf;
	for(auto [v, w] : mp[u]) if(v >= L && v <= R) seq.push_back(v - L);

	int sz = seq.size();
	suf.resize(sz);
	suf[sz - 1] = seq[sz - 1];
	Rep(i, sz - 2, 0) suf[i] = gcd(suf[i + 1], seq[i]);
	Rep(i, sz - 1, 0) if(seq[i] == suf[i] && seq[i] <= hV) {g = seq[i]; break;}
//	printf("%d %d %d\n", L, R, g);
//	for(auto [v, w] : mp[u]) if(v >= hV + L && v <= R) g = gcd(v - L, g);
	if(!g) return 0;
	
	
//	int G = -1;
//	for(auto x : d[g]) if(checkg(L, R, x)) {G = x; break;}
//	if(G <= 0) return 0;
//	g = G; 
	rep(i, L + g, R) {
		if(!mp[i][((i - L) % g) + L]) return 0;//return write(g), write(L), write(R), 0;
		mp[i].erase(((i - L) % g) + L), mp[((i - L) % g) + L].erase(i);
	}
	rep(i, L, L + g - 1) if(!mp[i].empty() && (*mp[i].rbegin()).first >= L + g) return  0;
	rep(i, L + g, R) if(!mp[i].empty() && (*mp[i].begin()).first < L + g) return  0;
	return check(L, L + g - 1) && check(L + g, R);
}
inline void solve() {
	read(n); read(m); cnt = n;
	rep(i, 0, n) {
		fa[i] = i;
//		e[i].clear();
		mp[i].clear();
	}
	rep(i, 1, m) {
		int u, v;
		read(u), read(v);
//		e[u].push_back(v);
//		e[v].push_back(u);
		if(mp[u][v] || u == v) cnt = 0;
		mp[u][v] = mp[v][u] = 1;
		merge(u, v);
	}
	if(cnt != 1) {puts("NO"); return;}
	puts(check(0, n - 1) ? "YES" : "NO");
}
int main () {
//	init(maxn - 5);
	read(T);
	while(T --) solve();
	
	return 0;
}
```


---


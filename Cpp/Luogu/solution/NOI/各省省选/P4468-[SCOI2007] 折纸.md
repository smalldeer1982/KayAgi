# [SCOI2007] 折纸

## 题目描述

桌上有一张边界平行于坐标轴的正方形纸片，左下角的坐标为(0,0)，右上角的坐标为(100,100)。接下来执行n条折纸命令。每条命令用两个不同点P1(x1,y1)和P2(x2,y2)来表示，执行时把当前的折纸作品沿着P1P2所在直线折叠，并把有向线段P1P2的右边折向左边（左边的部分保持不变）。

折叠结束后，需要在作品上打一个孔，然后用绳子穿起来挂在墙上。孔的位置是相当重要的：若需要穿过太多层的纸，打孔本身比较困难；若穿过的层数太少，悬挂起来以后作品可能会被撕破。为了选择一个比较合适的打孔位置，你需要计算在每个候选位置打孔时穿过的层数。如果恰好穿过某一层的边界（误差0.000001内），则该层不统计在结果中。

本题考虑一个简化的模型：纸的厚度不计，因此折纸操作总能完美执行。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/17707.png )

20%的数据满足：n<=1

100%的数据满足：0<=n<=8, 1<=m<=50


## 样例 #1

### 输入

```
2
-0.5 -0.5 1 1
1 75 0 75
6
10 60
80 60
30 40
10 10
50 50
20 50```

### 输出

```
4
2
2
0
0
2```

# 题解

## 作者：Hiraeth (赞：17)

我是真的菜啊

真的好难啊 

想了好久好久

大体思路就是：

因为对折次数是有上限的，所以这个值也不会太大，

那么最后提供答案的数据点的结果应该也不会太大，

如果不放心的话，可以开一个unsigned long long

所以就对输入的每个点，把一张折叠了的纸再沿着折痕返回过去，

相当于在一个平面直角坐标系中寻找一个已知点的对称点 

~~数学的手动滑稽~~

边读边扫，在输入过程中排除中途不符合情况的点，

最后看在初始的图形上有多少的点剩下来，既符合情况的点

要求点关于直线的对称点。

~~对称点的一种求法是斜率之积为-1~~

~~然后求解~~

这是我打的智障做法……

据大佬讲解可以用旋转向量公式

x1=x0*cosB-y0*sinB  

y1=x0*sinB+y0*cosB    

Orz一波大佬

~~美丽的折纸 溜了溜了~~

![](http://pic7.nipic.com/20100430/218586_145346002992_2.jpg)

```cpp
#include<bits/stdc++.h>

using namespace std ; 

const int MAXN = 10 ; 
const int MAXM = 60 ; 
const double eps = 1e-6 ; 
int N , M ;

struct Point {
    double x , y ; 
    Point ( const double x , const double y ) :
    x ( x ) , y ( y ) {} ;
} ; 

struct Vector {
    double x , y ; 
    Vector ( const double x , const double y ) : 
    x ( x ) , y ( y ) {} ; 
} ; 

struct Line {
    Point From , To ; 
    Line ( const double x1 , const double y1 , 
           const double x2 , const double y2 ) :
    From ( x1 , y1 ) , To ( x2 , y2 ) {} ;
    Vector toVector () const ;
} ;

Vector operator - ( const Point & First , const Point & Second ) {
    return Vector ( First . x - Second . x , First . y - Second . y ) ; 
} 

Point operator - ( const Point & First , const Vector & Second ) {
    return Point ( First . x - Second . x , First . y - Second . y ) ; 
} 

Vector operator * ( const double k , const Vector & Input ) {
    return Vector ( k * Input . x , k * Input . y ) ; 
}

Point operator + ( const Point & First , const Vector & Second ) {
    return Point ( First . x + Second . x , First . y + Second . y ) ; 
}


double operator ^ ( const Vector & First , const Vector & Second ) {
    return First . x * Second . y - First . y * Second . x ; 
}  

double operator * ( const Vector & First , const Vector & Second ) {
    return First . x * Second . x + First . y * Second . y ; 
}

double abs ( const Vector & Input ) {
    return sqrt ( Input . x * Input . x + Input . y * Input . y ) ; 
}

Vector Line :: toVector () const { return To - From ; }  

vector < Line > Opts ; 

Point reflect ( const Point o , const Line L ) {
    const double dis = ( ( L . From - o ) ^ ( L . To - o ) ) / abs ( L . toVector () ) ; 
    const Vector Lp = 1.0 / abs ( L . toVector () ) * L . toVector () ; 
    return o + 2.0 * dis * Vector ( Lp . y , - Lp . x ) ;
}

int Query ( const Point o , const int T ) {
    if ( T == -1 ) 
        return ( eps <= o . x && o . x <= 100.0 - eps ) && 
               ( eps <= o . y && o . y <= 100.0 - eps ) ; 
    const double CrossValue =   ( ( Opts [ T ] . From - o ) ^ ( Opts [ T ] . To - o ) ) ;
    if ( CrossValue < - eps ) return 0 ;     
    if ( - eps <= CrossValue && CrossValue <= eps ) return 0 ; 
    return Query ( o , T - 1 ) + 
           Query ( reflect ( o , Opts [ T ] ) , T - 1 ) ; 
}

int main () {
    scanf ( "%d" , & N ) ; 
    for ( int i = 0 ; i < N ; ++ i ) {
        double x1 , y1 , x2 , y2 ; 
        scanf ( "%lf%lf%lf%lf" , & x1 , & y1 , & x2 , & y2 ) ; 
        Opts . push_back ( Line ( x1 , y1 , x2 , y2 ) ) ; 
    } 
    scanf ( "%d" , & M ) ; 
    while ( M -- ) {
        double x , y ; 
        scanf ( "%lf%lf" , & x , & y ) ; 
        printf ( "%d\n" , Query ( Point ( x , y ) , N - 1 ) ) ;
    }
    return 0 ;
}
```

---

## 作者：Lyrella (赞：6)

# 前言
这个题完全没有想象中的那么难。

# 题意
在一个 $100\times 100$ 的平面中给你 $n$ 条**有向**线段和 $m$ 次询问。将平面沿线段折叠，从**有向**线段的右边折向左边。每次询问一个点被多少平面覆盖。

# 思路
看数据范围很小，可以考虑直接爆搜。

# 题解
具体的，对于每个询问的点，倒着枚举在每条**有向**线段折叠前点所在位置，直接递归求解。如果最后点在平面内就答案加一。

每次求对称点时，先判断用叉积判断是否能进行折叠，不能就返回，能的话就直接求直线的解析式，再根据两条互相垂直的直线斜率乘积为 $- 1$ 求出当前点与对称点所在直线。对称点易得。

# 代码

```cpp
#include <bits/stdc++.h>
#define db double
using namespace std;
const int N = 55;
const db eps = 1e-6;
int n, m, ans;

struct node{
	db x, y;
	node operator - (const node rhs){
		return (node){x - rhs.x, y - rhs.y};
	}
	db operator * (const node rhs){
		return x * rhs.y - rhs.x * y;
	}
	bool operator == (const node rhs){
		return fabs(x - rhs.x) < eps and fabs(y - rhs.y) < eps;
	}
}same = (node){114.514, 1919.810};
struct line{
	node a, b;
}L[N];

int chk(node t){
	return t.x > eps and t.x < 100.0 - eps and t.y > eps and t.y < 100.0 - eps ? 1 : 0;//判边界
}

node mirror(node t, line l){
	db dis = (l.b - l.a) * (t - l.a);//求叉积
	if(dis <= eps)return same;//叉积判位置关系
	if(fabs(l.a.x - l.b.x) < eps)return (node){l.a.x * 2 - t.x, t.y};//直线平行于y轴
	if(fabs(l.a.y - l.b.y) < eps)return (node){t.x, l.a.y * 2 - t.y};//直线平行于x轴
	db k = (l.a.y - l.b.y) / (l.a.x - l.b.x), b = l.a.y - l.a.x * k;
	db k1 = - 1 / k, b1 = t.y - t.x * k1;
	db xx = (b1 - b) / (k - k1), yy = xx * k + b;//求对称点
	return (node){2 * xx - t.x, 2 * yy - t.y};
}
void dfs(node t, int cur){
	if(! cur)return (void)(ans += chk(t));
	node q = mirror(t, L[cur]);
	if(q == same)return;
	dfs(t, cur - 1); dfs(q, cur - 1);//递归求当前点与对称点
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for(int i = 1; i <=n; ++i){
		db x1, x2, y1, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		L[i].a = (node){x1, y1};
		L[i].b = (node){x2, y2};
	}
	cin >> m;
	while(m--){
		ans = 0;
		db x, y;
		cin >> x >> y;
		node t = (node){x, y};
		dfs(t, n);
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：TempestMiku (赞：6)

# [折纸](https://www.luogu.com.cn/problem/P4468)

计算几何模板题。

但是我选择一次函数。



代码容易实现：我们将一个点的坐标开成结构体存储，读入两个点之后算出这两个点的 $y=kx+b$ 形式。对于这道题来说，我们需要求出来一个点关于一条直线对称的点，我们可以在这个点向这个直线做垂足，然后求出这个点关于垂足的对称点。

从查询的这一个点倒推回去求出合法的点有多少个就行了。

其中求垂足的式子可以用初一知识，两个线联立就能解出交点。

![](https://cdn.luogu.com.cn/upload/image_hosting/ep1nhec6.png)

显然对称点的坐标

$$\begin{array}{l} 
  \left\{\begin{matrix} 
  x=(x_2-x_1)\times 2+x_1=2\times x_2-x_1  \\ 
  x=(y_2-y_1)\times 2+y_1=2\times y_2-y_1\\
\end{matrix}\right.    
\end{array} $$

最后对于直线左边的点才能倒推，如果是直线右边的点就不能倒推，因为我们是把纸的右边折到左边。用叉乘求一下就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace Testify{
    inline int read(){
        int f(1),x(0);
        char ch=getchar();
        for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
        for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
        return f*x;
    }
    inline void Write(int x){
        if(x>9) Write(x/10);
        putchar(x%10+48);
    }
    inline void write(int x){
        if(x<0) putchar('-'),x=-x;
        Write(x);
        putchar('\n');
    }
}
using namespace Testify;
int n,m,Tempestissimo;
const double eps=1e-6;
const int N=155;
struct point {
    double x,y;
    friend point operator-(const point &x,const point &y){
        return point{x.x-y.x,x.y-y.y};
    }//向量减法
    // friend point operator+(const point &x,const point &y){
    //     return point{x.x+y.x,x.y+y.y};
    // }//向量加法
    friend double operator*(const point &x,const point &y){
        return x.x*y.y-x.y*y.x;
    }//向量乘法
}p[N][2];
struct Line{//y=kx+b;
    double k,b;
}line[N];
inline Line Change(point a,point b){
    if(a.x==b.x){//竖线
        return Line{1e9,a.x};
    }
    if(a.y==b.y){
        return Line{0,a.y};
    }
    Line ans;
    ans.k=(a.y-b.y)/(a.x-b.x);
    ans.b=(a.y-ans.k*a.x);
    return ans;
} 
inline point jiao(Line l1,Line l2){//求交点
    point ans;
    ans.x=(l2.b-l1.b)/(l1.k-l2.k);
    ans.y=(l1.k*ans.x+l1.b);
    return ans;
}
inline point chuizu(point p,Line l){//从点向线做垂足
    if(fabs(l.k)<eps){
        return point{p.x,l.b};
    }//横线
    if(l.k==1e9){//竖线
        return point{l.b,p.y};
    }
    Line l2;
    l2.k=-1/(l.k);
    l2.b=p.y-l2.k*p.x;
    return jiao(l,l2);
}
inline point Tairitsu(point p,Line l){//求出一个点关于直线对称的点
    point p2=chuizu(p,l);
    return point{(p2.x-p.x)*2+p.x,(p2.y-p.y)*2+p.y};
}
inline bool pd(point now,point x,point y){
    return ((y-x)*(now-x))>eps;
}
// inline double chaji(point p1,point p2){
//     return p1.x*p2.y-p2.x*p1.y;
// }
// inline bool pd(point p1,point p2){
//     if(chaji(p1,p2)>eps){//左边
//         return true;
//     }
//     else{
//         return false;
//     }
// }
inline bool check(point x){
    if(x.x>eps&&x.x<100-eps&&x.y>eps&&x.y<100-eps){
        return true;
    }
    return false;
}
inline void dfs(int last,point now){
    if(!last){
        Tempestissimo+=(check(now));
        return ;
    }
    point nxt;
    nxt=Tairitsu(now,line[last]);
    if(pd(now,p[last][0],p[last][1])){
        dfs(last-1,now);
        dfs(last-1,nxt);
    }
}
signed main(void){
    n=read();
    for(register int i=1;i<=n;i++){
        scanf("%lf%lf%lf%lf",&p[i][0].x,&p[i][0].y,&p[i][1].x,&p[i][1].y);
        line[i]=Change(p[i][0],p[i][1]);
    }
    m=read();
    while(m--){
        Tempestissimo=0;
        double xx,yy;
        scanf("%lf%lf",&xx,&yy);
        point x={xx,yy};
        dfs(n,x);
        write(Tempestissimo);
    }
    return 0;
}
```


---

## 作者：辰星凌 (赞：5)

# **【题解】折纸 origami [SCOI2007] [P4468] [Bzoj1074]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12120274.html)

传送门：[折纸 $\text{origami [SCOI2007] [P4468]}$](https://www.luogu.com.cn/problem/P4468) [$\text{[Bzoj1074]}$](https://www.lydsy.com/JudgeOnline/problem.php?id=1074)

## **【题目描述】**

初始有一个 $100*100$ 的正方形纸片，现给出 $n$ $(0 \leqslant n \leqslant 8)$ 条直线，将该纸片依次按照直线进行折叠，结束后会给出 $m$ 个询问，每次询问求某个坐标上的点穿过了几层纸。

## **【分析】**

[【计算几何全家桶】](https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-ji-suan-ji-he-quan-jia-tong)

又是一道毒瘤膜您题。

由于数据范围较小，可以直接上暴力。

考虑记录当前已有的多边形（初始为一个 $100*100$ 的正方形），每折叠一次就把折叠线所穿过的所有多边形分成左右两部分，然后将右边部分的点全部关于折叠线对称，得到两个新的小多边形。

对于每次询问，暴力枚举统计 包含询问点的多边形 即可。

折叠 $n$ 次后最多会出现 $2^n$ 个多边形，每个多边形最多有 $n^2$ 个点，射线法做一次 $PIP$ 为 $O(n^2)$，总时间复杂度为： $O(m n^2 2^n)$ 。

**注意：如果用的是 $double$ 而不是 $long\ double$，$eps$ 开得过于小会导致答案出锅。**

## **【Code】**

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#define LD double
#define LL long long
#define Re register int
#define Vector Point
using namespace std;
const int N=8;
const LD eps=1e-8;
inline int dcmp(LD a){return a<-eps?-1:(a>eps?1:0);}//处理精度
inline LD Abs(LD a){return a*dcmp(a);}//取绝对值
struct Point{
    LD x,y;Point(LD X=0,LD Y=0){x=X,y=Y;}
    inline void in(){scanf("%lf%lf",&x,&y);}
    inline void out(){printf("%.2lf %.2lf\n",x,y);}
};
inline LD Dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}//【点积】
inline LD Cro(Vector a,Vector b){return a.x*b.y-a.y*b.x;}//【叉积】
inline LD Len(Vector a){return sqrt(Dot(a,a));}//【模长】
inline LD Angle(Vector a,Vector b){return acos(Dot(a,b)/Len(a)/Len(b));}//【两向量夹角】
inline Vector operator+(Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}
inline Vector operator-(Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}
inline Vector operator*(Vector a,LD b){return Vector(a.x*b,a.y*b);}
inline bool operator==(Point a,Point b){return !dcmp(a.x-b.x)&&!dcmp(a.y-b.y);}//两点坐标重合则相等
inline int pan_PL(Point p,Point a,Point b){//【判断点P是否在线段AB上】
    return !dcmp(Cro(p-a,b-a))&&dcmp(min(a.x,b.x)-p.x)<=0&&dcmp(p.x-max(a.x,b.x))<=0&&dcmp(min(a.y,b.y)-p.y)<=0&&dcmp(p.y-max(a.y,b.y))<=0;
    //PA,AB共线且P在AB之间
}
inline int pan_PL_(Point p,Point a,Point b){//【判断点P是否在直线AB上】
    return !dcmp(Cro(p-a,b-a));//PA,AB共线
}
inline Point FootPoint(Point p,Point a,Point b){//【点P到直线AB的垂足】
    Vector x=p-a,y=p-b,z=b-a;
    LD len1=Dot(x,z)/Len(z),len2=-1.0*Dot(y,z)/Len(z);//分别计算AP,BP在AB,BA上的投影
    return a+z*(len1/(len1+len2));//点A加上向量AF
}
inline Point Symmetry_PL(Point p,Point a,Point b){//【点P关于直线AB的对称点】
    return p+(FootPoint(p,a,b)-p)*2;//将PF延长一倍即可
}
inline Point cross_LL(Point a,Point b,Point c,Point d){//【两直线AB,CD的交点】
    Vector x=b-a,y=d-c,z=a-c;
    return a+x*(Cro(y,z)/Cro(x,y));//点A加上向量AF
}
inline int pan_cross_L_L(Point a,Point b,Point c,Point d){//【判断直线AB与线段CD是否相交】
    return pan_PL(cross_LL(a,b,c,d),c,d);//直线AB与直线CD的交点在线段CD上
}
inline int PIP(Point *P,Re n,Point a){//【射线法】判断点A是否在任意多边形Poly以内
    Re cnt=0;LD tmp;
    for(Re i=1;i<=n;++i){
        Re j=i<n?i+1:1;
        if(pan_PL(a,P[i],P[j]))return 2;//点在多边形上
        if(a.y>=min(P[i].y,P[j].y)&&a.y<max(P[i].y,P[j].y))//纵坐标在该线段两端点之间
            tmp=P[i].x+(a.y-P[i].y)/(P[j].y-P[i].y)*(P[j].x-P[i].x),cnt+=dcmp(tmp-a.x)>0;//交点在A右方
    }
    return cnt&1;//穿过奇数次则在多边形以内
}
inline int judge(Point a,Point L,Point R){//判断AL是否在AR右边
    return dcmp(Cro(L-a,R-a))>0;
}
struct Poly{int n;Point P[N*N+3];}Py[(1<<N)+3],Qy[(1<<N)+3];
int n,t,tt,T;Point a,b;
inline void sakura(Poly Po,Point a,Point b){
    Poly L,R;L.n=R.n=0;
    for(Re i=1;i<=Po.n;++i){
        if(judge(a,Po.P[i],b))R.P[++R.n]=Symmetry_PL(Po.P[i],a,b);//点Po.P[i]在直线ab右边
        else if(pan_PL_(Po.P[i],a,b))L.P[++L.n]=R.P[++R.n]=Po.P[i];//点Po.P[i]在直线ab上
        else L.P[++L.n]=Po.P[i];//点Po.P[i]在直线ab左边
        Re j=i<Po.n?i+1:1;
        if(pan_cross_L_L(a,b,Po.P[i],Po.P[j]))L.P[++L.n]=R.P[++R.n]=cross_LL(a,b,Po.P[i],Po.P[j]);//如果直线AB与线段P[i]-P[i+1]有交点，将这个交点入队
        while(L.n>1&&L.P[L.n]==L.P[L.n-1])--L.n;//可能会重复如归，这里迅速把它去掉
        while(R.n>1&&R.P[R.n]==R.P[R.n-1])--R.n;//同上
    }
    if(L.n>1&&L.P[1]==L.P[L.n])--L.n;//注意最后判断首尾两点是否重合
    if(R.n>1&&R.P[1]==R.P[R.n])--R.n;//同上
    if(L.n)Qy[++tt]=L;//如果小矩形不为空就记录下来
    if(R.n)Qy[++tt]=R;
}
int main(){
//  freopen("123.txt","r",stdin);
    scanf("%d",&n);
    Py[++t].n=4,Py[t].P[1]=Point(0,0),Py[t].P[2]=Point(0,100),Py[t].P[3]=Point(100,100),Py[t].P[4]=Point(100,0);
    //初始化为一个正方形
    while(n--){
        a.in(),b.in(),tt=0;
        for(Re i=1;i<=t;++i)sakura(Py[i],a,b);//切割目前已有的多边形
        t=tt;
        for(Re i=1;i<=tt;++i)Py[i]=Qy[i];
    }
    scanf("%d",&T);
    while(T--){
        a.in();Re ans=0;
        for(Re i=1;i<=t;++i)if(PIP(Py[i].P,Py[i].n,a)==1)++ans;//严格在多边形内才统计答案
        printf("%d\n",ans);
    }
}
```


---

## 作者：max0810 (赞：3)

## 题意：

有一个左下角为 $(0,0)$，右上角为 $(100,100)$ 的正方形，给你 $n$ 个有向线段和 $m$ 个询问，将纸片依次按直线折叠，然后每次询问让你求出某个点上有多少层纸。

## 分析：

观察到数据范围非常小，于是可以直接对于每个询问 $\mathcal{O}(2^n)$ 来求。

具体的，对于每一个点，倒着枚举 $n$ 条直线。

如果这个点在直线的左边，那么就继续递归这个点和这个点关于直线的对称点；如果在右边，那么这个点就不在纸上，直接结束递归。

最后只需要看有多少个点在 $(0,0)$ 到 $(100,100)$ 内即可。

而在代码中，我用的是 $y=kx+b$ 的形式来表示一条直线，这样子要求对称的话就只需要根据垂直的线 $k$ 相乘为 $-1$，就可以求出垂足，然后再求对称即可。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define ll long long
using namespace std;
const int N = 55;
const double eps = 1e-6;
int n,m,ans;
struct point
{
    double x,y;
    friend point operator-(point x,point y){return {x.x-y.x,x.y-y.y};}
    friend double operator*(point x,point y){return x.x*y.y-x.y*y.x;}
}p[N][2];
struct line{double k,b;}l[N];
line f(point p1,point p2)//将用两个点表示直线转化为用y=kx+b表示的形式
{
    if(p1.x == p2.x)return {1e9,p1.x};
    line ans;
    ans.k = (p1.y-p2.y)/(p1.x-p2.x);
    ans.b = p1.y-ans.k*p1.x;
    return ans;
}
point jiao(line l1,line l2)//求两直线的交点
{
    point ans;ans.x = (l2.b-l1.b)/(l1.k-l2.k);
    ans.y = l1.k*ans.x+l1.b;
    return ans;
}
point chuizu(point p1,line l1)//求垂足
{
    if(fabs(l1.k) < eps)return {p1.x,l1.b};
    if(l1.k == 1e9)return {l1.b,p1.y};
    line l2;l2.k = -1/l1.k;l2.b = p1.y-l2.k*p1.x;
    return jiao(l1,l2);
}
point mirror(point p1,point p2){return {p2.x*2-p1.x,p2.y*2-p1.y};}//对称点
bool pd(point now,point x,point y){return (y-x)*(now-x) > eps;}//用叉积判断一个点是否在直线右边
bool check(point now){return now.x > eps&&now.x < 100-eps&&now.y > eps&& now.y < 100-eps;}//判断点是否在原正方形内

void dfs(int x,point now)
{
    if(!x)return (void)(ans += check(now));
    point nex = mirror(now,chuizu(now,l[x]));
    if(pd(now,p[x][0],p[x][1]))dfs(x-1,now),dfs(x-1,nex);
}
inline double rd(){double x;scanf("%lf",&x);return x;}
int main()
{
    n = rd();
    for(int i = 1;i <= n;i++)
    {
        p[i][0] = {rd(),rd()};p[i][1] = {rd(),rd()};
        l[i] = f(p[i][0],p[i][1]);
    }
    m = rd();
    while(m--)
    {
        point x = {rd(),rd()};ans = 0;
        dfs(n,x);
        printf("%d\n",ans);
    }
    return 0;
}
```



---


# [SCOI2007] 最优驾车

## 题目描述

有n条南北方向的双向街道和n条东西方向的双向街道纵横交错。相邻街道（不管是哪个走向）的距离均为L英里。西南角交叉口的坐标为$(1,1)$，东北角为$(n,n)$。在所有交叉口均可任意改变行驶方向。每条街道有它自己的最高速度限制，该限制对整条街道有效（不管行驶方向如何）。

你的任务是从交叉口$(x_s,y_s)$开车行驶到$(x_t,y_t)$，要求只能在交叉口处改变速度，行驶过程中不得违反所在街道的速度限制，只能沿着路程最短的线路行驶，并且行驶时间在给定的闭区间$[t_1,t_2]$内。车速以“每小时英里数”为单位，它必须是$5$的正整数倍。若车速为$v$，则每加仑汽油能行驶的英里数为$80-0.03v^2$。

## 说明/提示

样例1的最快路线为以40英里/小时为速度匀速前进，路程为200英里，因此时间为5小时，每加仑汽油可以行驶80-0.03*40*40=32英里，因此耗油量为200/32=6.25加仑。

最省油路线是先以40英里/小时行驶120英里，然后以35英里/小时行驶80英里，耗油量为120/32+80/(80-0.03*35*35)=5.60加仑。下图的路线可以同时满足两种方案（其中第二种方案需要在(6,2)处改变速度）。

![](https://cdn.luogu.com.cn/upload/pic/17708.png )

20%的数据满足：n<=4

50%的数据满足：n<=8

100%的数据满足：1<=n<=10, 1<=l<=20, 0<=t1<=t2<=1000. 速度限制不超过50


## 样例 #1

### 输入

```
6 20
30 40 50 50 50 50
50 50 50 50 50 40
1 1 6 6 300 320```

### 输出

```
300 6.25
318 5.60```

## 样例 #2

### 输入

```
8 2
10 20 20 30 10 20 10 10
10 20 20 30 10 20 10 20
6 8 2 4 10 39```

### 输出

```
No```

# 题解

## 作者：William_Fangs (赞：6)

```cpp
//因为要走最短路,所以只能向前,不能退后
//可以用DP来做
//dp[i][j]表示在x轴走了i步,y轴走了j步
//emm。。。
//但路径有多条,所以还要加一维不然无法表示当前状态
//加时间？加油？
//80-0.03v^2/l，明显不行
//只能加时间
//但时间也不好表示
//可以注意到 V一定是5的倍数
//并且v≤ 50
//所以可以将v/5,此时v只能为1~10
//所以 时间就成了l/(1~10)
//将时间乘以(1~10)的公倍数化为整数,即可表示
//判断时时间就是 t/(2520*5) *60，就是所花的时间
//则dp[i][j][k]表示在x轴走了i步,在y轴走了j步,用时为k时的耗油量
//k<=20*2520
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <cstring>
using namespace std;
#define ll long long
#define dd double
#define inf 1e50
const int N=12;
const int M=2*N*2520;
ll gbs=2520;
ll n,m;
ll vx[N];
ll vy[N];
ll sx,sy;
ll tx,ty;
ll t1,t2;
ll tt[51];
ll len;
dd dp[N][N][M];//打了我两个多小时 wysl 
ll px,py;//direction
ll qz(dd aa)
{
	aa=-aa;
	ll myint=(ll)aa;
	return -myint;
}
inline dd oil_(ll ve)
{
	return (dd)len/(80-0.03*ve*ve);
}
inline void minn(double &a, const double &b)
{
	if (b < a) a = b;
}
inline ll judge(dd aa)
{
	if(fabs(aa)<1e-8)//精度处理
	{
		return 0;
	}
	else
	{
		if(aa>=0)
			return 1;
		else
			return -1;
	}
}
void work()
{
	if(tx>sx)
	{
		px=1;
	}
	else
		px=-1;
	if(ty-sy>0)
	{
		py=1;
	}
	else
		py=-1;
	ll dx=abs(tx-sx);
	ll dy=abs(ty-sy);
	dp[0][0][0]=0;
	for (int i = 0; i <= dx; ++i)
		for (int j = 0; j <= dy; ++j)
			for (int t = 0; t < M; ++t)
			{
				if (dp[i][j][t] != inf)
				{
					static int x, y, nex, ney;
					x = i + 1, y = j;
					if (x <= dx)
					{
						ney = sy + y * py;
						for (int v = 1; v * 5 <= vx[ney] && t + tt[v] < M; ++v)
							minn(dp[x][y][t + tt[v]], dp[i][j][t] + oil_(v * 5));
					}
					x = i, y = j + 1;
					if (y <= dy)
					{
						nex = sx + x * px;
						for (int v = 1; v * 5 <= vy[nex] && t + tt[v] < M; ++v)
							minn(dp[x][y][t + tt[v]], dp[i][j][t] + oil_(v * 5));
					}
				}
			}
				
	ll mt=-1;
	ll mo=-1;
	for (int i=0; i<M; i++)
	{
		if (dp[dx][dy][i] !=inf)
		{
			double ti = (double)i * len/2520*N;
			if (judge(ti-t1)>=0&&judge(t2-ti)>=0)
			{
				if(mt==-1)
				{
					mt=i;
				}
				if(mo==-1)
				{
					mo=i;
				}
				else if(judge(dp[dx][dy][i]-dp[dx][dy][mo])==-1)
				{
					mo=i;
				}
			}
		}
	}
	if(mt==-1)
	{
		printf("No\n");
		return ;
	}
	printf("%lld %.2lf\n", (ll)ceil((double)mt*len/2520*N),dp[dx][dy][mt]);//使时间单位变成分钟
	printf("%lld %.2lf\n", (ll)ceil((double)mo*len/2520*N),dp[dx][dy][mo]);
	return ;
}
signed main()
{
	//memset(dp)
	scanf("%lld%lld",&n,&len);
	for(int i=0; i<n; i++)
	{
		scanf("%lld",&vx[i]);
	}
	for(int i=0; i<n; i++)
	{
		scanf("%lld",&vy[i]);
	}
	scanf("%lld%lld%lld%lld%lld%lld",&sx,&sy,&tx,&ty,&t1,&t2);
	sx--;
	sy--;
	tx--;
	ty--;
	for(int i=1; i<=10; i++)
	{
		tt[i]=2520/i;
	}
	for(int i=0; i<n; i++)
	{
		for(int j=0; j<n; j++)
		{
			for(int k=0; k<M; k++)
			{
				dp[i][j][k]=inf;
			}
		}
	}
	work();
	return 0;
}
```

---

## 作者：constexpr (赞：3)

前置知识：状压 dp

首先，因为只能沿路程最短的路径行驶，且只能在交叉口改变速度，不难想到 dp。

令 $dp[i][j][k]$ 表示在位置 $(i,j)$，已经行驶了 $k$ 分钟耗油的最小值，令速度的取值为 $speed$，不难得出转移方程：

$dp[i][j][k] = \min(dp[i - 1][j][k - l/speed],dp[i][j-1][k-l/speed])$

当然这只是从左下到右上的情况。剩下的情况相信读者可以自己推出。

那么现在有一个问题：上式中 $k$ 未必是一个整数，例如以 $35$ 英里每小时的速度经过长度为 $10$ 英里的道路，所需的时间就是 $\dfrac{120}{7}$ 分钟。

看一眼数据范围，发现速度仅有 $10$ 种不同的取值，并且分别是 $1,2,3...,10$ 的倍数。

当速度为 $5$ 英里每小时时，行驶一英里所需要的时间为 $1 \div 5 \times 60 = \dfrac{12}{1}$ 分钟。

速度为 $10$ 英里每小时时，行驶一英里所需时间为 $\dfrac{12}{2}$ 分钟。

同理，接下来依次为 $\dfrac{12}{3},\dfrac{12}{4},...,\dfrac{12}{10}$ 分钟。

**所以我们将耗时乘上 $\operatorname{lcm}(1,2,...,10)=2520$**，那么每次用时必定为整数，就可以进行 dp 了。

时间复杂度 $O(t_2n^2)$，但由于常数足足有 $25200$ 倍大（枚举速度还要乘上 $10$），所以炸时间也炸空间。

考虑进行优化。

------------

优化 1：

一个小优化。

观察到用时的分钟数都是 $\dfrac{12}{x}$ 的形式，而为了使用时为整数，我们只需使分母是 $\operatorname{lcm}(1,2,...,10)$ 的倍数即可。

$2520 = 12 \times 210$，**故只需将耗时乘上 $210$ 即可。**

于是我们成功地将常数减小至 $2100$。

但仍不能满足本题的数据范围 $n \leq 10 , t_2 \leq 1000$。

故考虑优化 2 。

------------

优化 2：

本题的关键优化。

显然，在将耗时乘上 $210$ 之后，不是所有耗时都能被取到。

这一点比较难理解，就拿样例来举个例子吧。

样例 1 中，每段路的长度为 $20$ 英里，而速度的取值仅有 $10$ 种，而这 $10$ 种速度通过一段路的时间乘上 $210$ 后分别为：
$50400,25200,16800,12600,10080,8400,7200,6300,5600,5040$

在 dp 的转移过程中，显然取时间为 $1-5039$ 中的任意一个时，这个转移都是无效的。因为这些时间不可能被上面的所有可能的耗时组合而成。

类似这样的时间点还有很多，关键在于如何找到这些时间点并预先排除。

考虑使用分组背包。先将所有可能的时间值储存在一个数组里（如样例 1 即为 $\{50400,25200,16800,12600,10080,8400,7200,6300,5600,5040\}$ ）

且最多经过 $2 \times (n - 1)$ 条道路。

所以我们假设有 $2 \times (n - 1)$ 个分组，每组有 $10$ 种物品，对应上述的数组，最后统计哪些数出现过，在 dp 时仅需考虑这些状态中小于等于 $t_2$ 的状态就行了。

在极限情况下（$n = 10 , t_2 = 1000 , l = 1$），经过测试，情况数不超过 $30000$。

设情况数为 $cnt$，则时间复杂度为 $O(n^2cnt)$，常数仅有枚举速度的 $10$，足以通过本题。

------------

主体部分完成，输出前统计有效状态即可。

完整代码（码风可能有点神奇，不喜勿喷）：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
int n,l,z,x1,x2,y1,y2,t1,t2,cnt,row,column,time1,time2,possible[15],limit_row[20],limit_column[20],states[30010],map[2100010],road_row[15][15],road_column[15][15];
double waste1,waste2,dp[15][15][30010];
bool vis[2110010]={true};
int abs(int x){
	return x>0?x:(-x);
}
template<typename T>T min(T x,T y){
	return x<y?x:y;
}
int ceil(double x){
	if((int)x==x)return x;
	else return (int)x+1;
}
double cost(int speed){
	return (double)l/210/(80-0.03*speed*speed);
}
int main(){
	scanf("%d %d",&n,&l);l*=210;
	for(register int i=1;i<=n;i++)scanf("%d",&limit_row[i]);
	for(register int i=1;i<=n;i++)scanf("%d",&limit_column[i]);
	scanf("%d %d %d %d %d %d",&x1,&y1,&x2,&y2,&t1,&t2);
	row=abs(y2-y1)+1,column=abs(x2-x1)+1,t1*=210,t2*=210;
	z=x1,x1=y1,y1=z,z=x2,x2=y2,y2=z;
	for(register int i=1;i<=10;i++)possible[i]=12*l/i;
	for(register int i=1;i<=2*(n-1);i++)for(register int j=t2;j>=0;j--)for(register int k=1;k<=10;k++)vis[j+possible[k]]|=vis[j];
	for(register int i=0;i<=t2;i++)if(vis[i])states[++cnt]=i,map[i]=cnt;
	if(x1>x2&&y1>y2)for(register int i=x1;i>=x2;i--)for(register int j=y1;j>=y2;j--)road_row[x1-i+1][y1-j+1]=limit_row[i],road_column[x1-i+1][y1-j+1]=limit_column[j];
	if(x1<=x2&&y1>y2)for(register int i=x1;i<=x2;i++)for(register int j=y1;j>=y2;j--)road_row[i-x1+1][y1-j+1]=limit_row[i],road_column[i-x1+1][y1-j+1]=limit_column[j];
	if(x1>x2&&y1<=y2)for(register int i=x1;i>=x2;i--)for(register int j=y1;j<=y2;j++)road_row[x1-i+1][j-y1+1]=limit_row[i],road_column[x1-i+1][j-y1+1]=limit_column[j];
	if(x1<=x2&&y1<=y2)for(register int i=x1;i<=x2;i++)for(register int j=y1;j<=y2;j++)road_row[i-x1+1][j-y1+1]=limit_row[i],road_column[i-x1+1][j-y1+1]=limit_column[j];
	for(register int i=1;i<=row;i++)for(register int j=1;j<=column;j++)for(register int k=1;k<=cnt;k++)dp[i][j][k]=1e9;dp[1][1][1]=0;
	for(register int i=1;i<=row;i++){
	    for(register int j=1;j<=column;j++){
	    	for(register int k=1;k<=cnt;k++){
	            for(register int p=1;p<=10;p++){
	                if(l*12/p<=states[k]&&map[states[k]-l*12/p]){
	                	double waste=1e9;
	                	if(i!=1&&road_column[i-1][j]>=p*5)waste=min(waste,dp[i-1][j][map[states[k]-l*12/p]]+cost(p*5));
	                	if(j!=1&&road_row[i][j-1]>=p*5)waste=min(waste,dp[i][j-1][map[states[k]-l*12/p]]+cost(p*5));
	                	dp[i][j][k]=min(dp[i][j][k],waste);
					}
				}
			}
		}
	}
	time1=1e9,waste1=1e9,time2=1e9,waste2=1e9;
	for(register int i=1;i<=cnt;i++){
		if((dp[row][column][i]||(row==1&&column==1&&i==1))&&dp[row][column][i]!=1e9&&states[i]>=t1&&states[i]<=t2){
			if(states[i]<=time1){
				if(states[i]<time1)waste2=dp[row][column][i];
				else waste2=min(waste2,dp[row][column][i]);
				time1=states[i];
			}
			if(dp[row][column][i]<=waste1){
				if(dp[row][column][i]<waste1)time2=states[i];
				else time2=min(time2,states[i]);
				waste1=dp[row][column][i];
			}
		}
	}
	if(time1==1e9||waste1==1e9)printf("No");
	else printf("%d %.2lf\n%d %.2lf",(int)ceil(time1/210.0),waste2,(int)ceil(time2/210.0),waste1);
	return 0;
}
```
 upd 2022.7.14 原来的程序忘删调试语句了...

---


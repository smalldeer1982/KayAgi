# [ZJOI2018] 树

## 题目描述

九条可怜是一个热爱出题的女孩子。

虽然出题本身是一件非常有趣的事情，但是要把题目给出成正式比赛,就不是那么有趣了：造数据总是一件让人心力憔悴的事情。

在 ZJOI2018 Day 1 中，可怜出了一道和树相关的非常有趣的题，她打算采用一种常用的方式随机生成一棵 $n$ 个节点的有根树：

- 节点 1 作为树的根。
- 对于 $i \in [2, n]$ ，独立地从 $[1, i)$ 中等概率随机选取一个节点作为 $i$ 的父亲。

可怜不是很想考虑这样随机出来的数据能不能卡掉暴力,毕竟乱搞也是 OI 比赛的一部分。

可怜比较在意的是题目的区分度，以及是不是所有可能的分数都出现了。因此，可怜希望任何两个测试点的树是有区别的：这样就可能会有错误的程序能只通过其中一个点。

因此，可怜想要计算，通过上面的方法独立的随机生成 $k$ 棵 $n$ 个节点的有根树 $T_1$ 至 $T_k$ ，他们两两同构的概率是多少。

两棵 $n$ 个节点的有根树 $T_1$ 和 $T_2$ 同构当且仅当存在长度为 $n$ 的排列 $p$，满足 $p_1 = 1$ ，且对于 $\forall i \in [2, n]$ ，若 $i$ 在 $T_1$ 的父亲是 $f$ ，则 $p_i$ 在 $T_2$ 的父亲是 $p_f$ 。

## 说明/提示

### 样例解释

在第一组数据中，能够生成的树是唯一的,因此生成的两棵树必定相同。

在第二组数据中，能够生成的树只有两种,他们是不同构的。因此生成的两棵树同构的概率为 $\frac{1}{2}$ ，在模 998244353 意义下为 499122177。

在第三组数据中，能够生成的树有 6 种,如下图所示。其中第二、三、四棵(第一排中间三棵)是同构的,其余两两不同构。因此生成的两棵树同构的概率为 $\frac{1}{3}$ ，在模998244353 意义下为 332748118。

![](https://cdn.luogu.com.cn/upload/pic/18417.png)


### 数据范围

测试点|　$n$|　$k$|测试点|　$n$|　$k$
-|-|-|-|-|-
1|$\le 5$|$=2$|6|$\le 50$|$\le 10^9$
2|$\le 10$|$=2$|7|$\le 200$|$\le 10^9$
3|$\le 20$|$=2$|8|$\le 500$|$\le 10^9$
4|$\le 50$|$=2$|9|$\le 1000$|$\le 10^9$
5|$\le 50$|$=2$|10|$\le 2000$|$\le 10^9$

对于 100% 的数据,保证 $p$ 是质数且 $10^8 \le p \le 10^9 $。

感谢 @Xeonacid 提供题面

## 样例 #1

### 输入

```
2 2 998244353
```

### 输出

```
1```

## 样例 #2

### 输入

```
3 2 998244353```

### 输出

```
499122177```

## 样例 #3

### 输入

```
4 2 998244353```

### 输出

```
332748118```

## 样例 #4

### 输入

```
10 2 998244353```

### 输出

```
113919852```

## 样例 #5

### 输入

```
50 233 998244353```

### 输出

```
634280054```

# 题解

## 作者：ftiasch (赞：26)

### [ZJOI 2018 - 树](https://www.luogu.com.cn/problem/P4500)

考虑一颗 $n$ 个节点的随机有根树 $T$，其中节点 $i$ ($2 \leq i \leq n$) 的父亲在 $\{1, \dots, i - 1\}$ 中均匀随机。

给定 $n$, $k$，求 $k$ 颗树 $T_1, \dots, T_k$ 两两同构的概率。

- $n \leq 2000$
- $k \leq 10^9$

#### 解法

##### 转化为递归构造

设 $\mathcal{T}_n$ 是所有 $n$ 个节点的**无标号**的有根树的集合，$\mathcal{T}_n = \{T_{n, 1}, \dots, T_{n, |\mathcal{T}_n|}\}$, $\mathcal{T} = \bigcup_{n \geq 0} \mathcal{T}_n$.

另外有函数 $s' : \mathcal{T} \to \mathbb{N}$. $s'(T)$ 表示用 $1, \dots, |T|$ 给点标号，保证节点标号大于父亲标号的方案数。

###### 例子: $\mathcal{T}_4 = \{T_{4, 1}, T_{4, 2}, T_{t, 3}, T_{4, 4}\}$

![](zjoi-tree-1.svg)

$s'(T_{4, 1}) = 1$, $s'(T_{4, 2}) = 1$, $s'(T_{4, 3}) = 3$, $s'(T_{4, 3}) = 1$

可以验证 $s'(T_{4, 1}) + s'(T_{4, 2}) + s'(T_{4, 3}) + s'(T_{4, 4}) = 6 = 3!$.

---

所求就是
$$
\frac{1}{[(n - 1)!]^k} \sum_{T \in \mathcal{T}_n} (s'(T))^k = n^k \sum_{T \in \mathcal{T}_n} \left(\frac{s'(T)}{|T|!}\right)^k.
$$
根据递归构造，尝试枚举 $\mathcal{T}_n$ 中的树中的子树。设其中 $T_{i, j}$ 有 $x_{i, j}$ 颗。则
$$
\sum_{T \in \mathcal{T}_n}s'(T) = (|T| - 1)! \prod_{\sum_{i, j} i x_{i, j} = n - 1} \left(\frac{s'(T_{i, j})}{|T_{i, j}|!}\right)^{x_{i,j}} \frac{1}{x_{i, j}!}.
$$
这里可以注意到 $i x_{i, j} \leq n - 1$. 写成生成函数的形式就是
$$
\sum_{T \in \mathcal{T}_n } s(T)
= \frac{1}{|T|^k} [z^{n - 1}] \prod_{T' \in \mathcal{T}} \sum_{j \geq 0} \frac{(s(T') z^{|T'|})^j}{(j!)^k}
= \frac{[z^{n - 1}]}{|T|^k} \prod_{i \geq 1} \prod_{T_i \in \mathcal{T}_i} \left(\sum_{j \geq 0} \frac{(s(T_i) z^i)^j}{(j!)^k} \right).
$$
其中 $s(T) = \left(\frac{s'(T)}{|T|!}\right)^k$.

---

单独观察其中一项
$$
\prod_{T_i \in \mathcal{T}_i} \left(\sum_{j \geq 0} \frac{(s(T_i) z^i)^j}{(j!)^k}\right).
$$
从递推的角度，仿佛需要知道 $s(T_{i, 1}), \dots, s(T_{i, |T_i|})$ 的具体值才可以计算。

下面介绍一些理论依据。

#### 对称多项式

设有 $n$ 个变量 $x_1, \dots, x_n$. 定义它们的 $k$-次幂和
$$
p_k = \sum_{i = 1}^n x_i^k.
$$
定义它们的 $k$-次初等对称多项式（Elementary Symmetric Polynomial）
$$
e_k = \sum_{1\leq i_1 < \dots < i_k \leq n} x_{i_1} \dots x_{i_k}.
$$

##### 例子

$n = 4$ 时，
$$
e_3 = x_1x_2x_3 + x_1x_2x_4 + x_1x_3x_4 + x_2x_3x_4.
$$


---

[牛顿恒等式](https://en.wikipedia.org/wiki/Newton%27s_identities) 指出
$$
k e_k = \sum_{i = 1}^k (-1)^{i - 1} e_{k - i} p_i.
$$
如果定义它们的 $k$-次完全齐次多项式（Complete Homogeneous Symmetric Polynomials）
$$
h_k = \sum_{1\leq i_1 \leq \dots \leq i_k \leq n} x_{i_1} \dots x_{i_k}.
$$
同样有
$$
k h_k = \sum_{i = 1} h_{k - i} p_i.
$$


#### 牛顿恒等式的生成函数证明

首先，
$$
p_k = [z^k] \sum_{i = 1}^n \frac{1}{1 - x_i z} = [z^k] \sum_{i = 1}^{n} \sum_{j \geq 0} x_i^j z^j = [z^k] P(z).
$$
其次，
$$
e_k = [z^k] \prod_{i = 1}^n (1 + x_i z) = [z^k] E(z).
$$
为了联系求和和求积，取对数有
$$
\frac{E'(z)}{E(z)} = \frac{\mathrm{d}}{\mathrm{d} z}\, \ln E(z) = \sum_{i = 1}^n \frac{\mathrm{d}}{\mathrm{d} z}\, \ln(1 + x_i z) = \sum_{i = 1}^n \frac{x_i}{1 + x_i z} = \sum_{i = 1}^n \sum_{j \geq 0} (-1)^j x_i^{j + 1} z^j = \sum_{j \geq 0} (-1)^j p_{j + 1} z^j = Q(z).
$$


---

比较 $[z^{k - 1}] E'(z) = [z^{k - 1}]E(z) Q(z)$ 有
$$
k e_k = \sum_{j = 0}^{k - 1} (-1)^j e_{k - 1 - j} p_{j + 1}  = \sum_{j = 1}^{k} (-1)^{j - 1} e_{k - j} p_j.
$$


---

一个多项式 $f(x_1, \dots, x_n) \in R[x_1, \dots, x_n]$ 是对称多项式，当且仅当对于任意 $\{1, \dots, n\}$ 的排列 $\sigma_1, \dots, \sigma_n$，有
$$
f(x_1, \dots, x_n) = f(x_{\sigma_1}, \dots, x_{\sigma_n}).
$$

##### 例子

$f(a, b, c) = a^2 b + b^2 c + c^2 a + ab^2 + bc^2 + ca^2$ 是对称多项式。

而 $g(a, b, c) = a^2 b + b^2 c + c^2 a$ 不是对称多项式，因为 $g(a, c, b) = a^2 c + c^2 b + b^2 a \neq g(a, b, c)$.

##### 对称多项式基本定理

[对称多项式基本定理](https://en.wikipedia.org/wiki/Elementary_symmetric_polynomial#Fundamental_theorem_of_symmetric_polynomials)指出，任意 $n$ 元 $m$ 次对称多项式可以用 $e_1, \dots, e_m$ 表示。等价地，用 $p_1, \dots, p_m$ 表示。

---

抽象地说，考虑 $n$ 元对称多项式环 $R[x_1, \dots, x_n]^{S_n}$.

对于任意 $f \in R[x_1, \dots, x_n]^{S_n}$, 存在多项式 $g \in R[x_1, \dots, x_n]$ 满足
$$
f(x_1, \dots, x_n) = g(p_1, \dots, p_n).
$$

##### 例子：牛顿恒等式和贝尔多项式 #TODO

#### 解法（续）

回到所求
$$
\sum_{T \in \mathcal{T}_n} s(T)
= \frac{[z^{n - 1}]}{|T|^k} \prod_{i \geq 1} \prod_{T_i \in \mathcal{T}_i} \left(\sum_{j \geq 0} \frac{(s(T_i) z^i)^j}{(j!)^k}\right).
$$
如果令
$$
\mathrm{FOREST}_{i}(z) = \prod_{T_i \in \mathcal{T}_i}\left(\sum_{j \geq 0} \frac{(s(T_i) z)^j}{(j!)^k}\right) = \sum_{j \geq 0} \mathrm{forest}_{i, j} z^{j}.
$$
则
$$
\sum_{T \in \mathcal{T}_n} s(T) = \frac{[z^{n - 1}]}{|T|^k} \prod_{i \geq 1} \mathrm{FOREST}_i(z^i).
$$
明显 $\mathrm{forest}_{i, j}$ 是关于 $s(T_{i, 1}), \dots, s(T_{i, |\mathcal{T}_i|})$  的 $j$ 次对称多项式。它的组合意义是对 $j$ 颗大小为 $i$ 的树数某个东西。

---

这里需要注意
$$
[z^{n - 1}]\prod_{i \geq 1} \prod_{T_i \in \mathcal{T}_i} \left(\sum_{j \geq 0} \frac{(s(T_i) z^i)^j}{(j!)^k}\right)
$$
并不是关于 $\{s(T) \mid T \in \mathcal{T}\}$ 的对称多项式，所以对于树的大小分开计算是必要的。

---

根据对称多项式基本定理， $\mathrm{forest}_{i, j}$ 可以被
$$
s_{i, p} = \sum_{T \in \mathcal{T}_i} \left(s(T_{i})\right)^p
$$
表示。最终所求是 $s_{n, 1}$.

之前所做的事情是把 $s_{i, p}$ 表示为 $\mathrm{forest}_{i, j}$，又通过对称多项式基本定理把 $\mathrm{forest}_{i, j}$ 转化为 $s_{i, p}$.

---

##### 用 $s_{i, p}$ 表示 $\mathrm{forest}_{i, j}$

固定 $n$. 现在有
$$
\mathrm{FOREST}_n(z) = \sum_{j \geq 0} \mathrm{forest}_{n, j} z^j = \prod_{T \in \mathcal{T}_n} \left(\sum_{j \geq 0} \frac{(s(T) z)^j}{(j!)^k}\right)
$$
和
$$
s_{n, p} = \sum_{T \in \mathcal{T}_n} s(T)^p.
$$
模仿之前证明牛顿恒等式的手法，取对数得
$$
\ln \mathrm{FOREST}_n(z)
= \sum_{T \in \mathcal{T}_n} \left(\ln \sum_{j \geq 0} \frac{(s(T) z)^j}{(j!)^k}\right).
$$




---


这里一个比较投机的方法是考虑
$$
G(t) = \ln \sum_{j \geq 0} \frac{t^j}{(j!)^k} = \sum_{j \geq 1} g_j t^j,
$$
则
$$
\ln \mathrm{FOREST}_n(z) = \sum_{T \in \mathcal{T}_n} G(s(T) z) = \sum_{T \in \mathcal{T}_n} \sum_{j \geq 1} g_j (s(T) z)^j = \sum_{j \geq 1} g_j \left(\sum_{T \in \mathcal{T}_n} s(T)^j  \right) z^j = \sum_{j \geq 1} g_j s_{n, j} z^j.
$$
即
$$
\mathrm{FOREST}_n(z) = \mathrm{exp}\left(\sum_{j \geq 1} g_j s_{n, j} z^j\right).
$$




---

##### 计算的目标

以上分析了为了计算 $s_{n, 1}$，需要
$$
\{\mathrm{forest}_{i, j} \mid 1 \leq i < n \wedge 1 \leq j \leq \frac{n}{i}\}.
$$
因此又需要
$$
\{s_{i, p} \mid 1 \leq i \leq n \wedge 1 \leq p \leq \frac{n}{i}\}.
$$
为此有
$$
s_{n, p} = \sum_{T \in \mathcal{T}_n} s(T)^p = \frac{[z^{n - 1}]}{n^{{\color{red}p}k}} \prod_{i \geq 1} \prod_{T_i \in \mathcal{T}_i} \left(\sum_{j \geq 0} \frac{(s(T_i)^{\color{red}{p}} z^i)^j}{(j!)^{{\color{red}{p}}k}}\right).
$$




---

从而需要令
$$
\mathrm{FOREST}_{i, {\color{red}p}}(z) = \prod_{T_i \in \mathcal{T}_i}\left(\sum_{j \geq 0} \frac{(s(T_i)^{\color{red} p} z)^j}{(j!)^k}\right) = \sum_{j \geq 0} \mathrm{forest}_{i, j, {\color{red}p}} z^{j}.
$$
于是
$$
s_{n, p} = \frac{[z^{n - 1}]}{n^{pk}} \prod_{i \geq 1} \mathrm{FOREST}_{i, p}(z^i).
$$




---


$$
G_p(t) = \ln \sum_{j \geq 0} \frac{t^j}{(j!)^{{\color{red} p}k}} = \sum_{j \geq 1} g_{p, j} t^j
$$

所以
$$
\exp \ln \mathrm{FOREST}_{i, p}(z) = \exp \left(\sum_{T \in \mathcal{T}_i} G_p(s(T)^p z)\right) = \exp\left(\sum_{j \geq 1} g_{p, j} s_{i, pj} z^j\right).
$$
总之
$$
s_{n, p} = \frac{[z^{n - 1}]}{n^{pk}} \prod_{i = 1}^{n - 1} \mathrm{exp}\left(\sum_{j = 1}^{\lfloor n / i \rfloor} g_{p, j} s_{i, pj} z^{ij}\right).
$$




---


可以证明 $n p \leq N$ 总成立。在第 $i$ 个因子中，有 $i j \leq n$. 所以 $i (pj) \leq N$ 仍然成立。

---

##### 从生成函数翻译成递推


###### 预处理 $G_{p}(z) \bmod \Omega(z^{n / p})$

给出 $f(z)$, 为了计算 $g(z) = \ln f(z)$. 
$$
\begin{array}{rrcl}
& [z^{k - 1}] g'(z) f(z) & = & [z^{k - 1}] f'(z) \\
\implies & \sum_{i = 0}^{k - 1} ((k - i) g_{k - i}) f_i & = & k f_k \\
\implies & k g_k & = & k f_k - \sum_{i = 1}^{k - 1} ((k - i)g_{k - i}) f_i
\end{array}
$$
具体实现时可以先保留 $k g_k$，最后再除 $k$. 这样最内层循环只需要一次乘法。

这部分的时间复杂度是 $\sum_{p = 1}^n \left(\frac{n}{p}\right)^2 = O(n^2)$.

---

###### 计算 $\exp$


把计算 $\ln$ 的过程倒过来，即可 $O(n^2)$ 计算 $\exp$.

设 
$$
\gamma_{i, p}(z) = \mathrm{exp}\left(\sum_{j = 1}^{\lfloor n / pi \rfloor} g_{p, j} s_{i, pj} z^{\color{red}j}\right).
$$
计算 $\gamma_{i, p}(z)$ 的时间复杂度是 
$$
\sum_{i p \leq n} \left(\frac{n}{ip}\right)^2 = O(n^2 \log n).
$$


---

令 
$$
\Gamma_{i, p}(z) = \prod_{t = 1}^i \gamma_{t, p}(z) = \Gamma_{i - 1, p}(z) \gamma_{i, p}(z^i).
$$
计算 $\Gamma_{i, p}(z)$ 的时间复杂度是 
$$
\sum_{p = 1}^n \sum_{i = 1}^{\lfloor n / p\rfloor} \frac{n}{p} \frac{n}{ip} = \sum_{p = 1}^n O(\frac{n^2}{p^2} \log \frac{n}{p}) = O(n^2 \log n).
$$

#### 总结

- 事实上，这里 $G(t)$ 的系数对应了官方题解中的带权稳定化子。
- 通过对称多项式的理论，回答了（我的）疑问：明明 $|\mathcal{T}_n|$ 的大小是指数增长的，为什么可以多项式级别的信息维护，得到有指数个变量的某个表达式的值。
- 尽量从暴力出发，分析出了为什么各种题解中需要计算诸如「$j$ 颗大小为 $i$ 的树的等价类的 $pk$ 次方的和 」。

# 

---

## 作者：x义x (赞：24)

[题目链接](https://www.luogu.com.cn/problem/P4500)

[更好的阅读体验](https://xyix.github.io/2020/09/08/luogu-4500/)

# 感想

这就是 ZJOI 的 D2T1 吗爱了爱了

这题实在太毒以至于我花了整整一天时间才写好这篇 blog，题解长度堪称群论计数界幽灵乐团

但这题的题面简直不能再短：求随机生成 $k$ 棵大小为 $n$ 的有标号树互相有根同构的概率。它只是难而已……

不禁令人叹息：吉老师，永远滴神

想要在合理的时间内解出这题需要你非常熟悉群论计数，有一个清晰的逻辑，可能还需要比较强的观察能力。~~然而你大概率需要解出这题才够资格宣称自己非常熟悉群论计数~~

# 开始

首先你可能需要一些群论计数的知识。

设 $f(i,j)$ 是大小为 $i$ 的树的所有等价类大小的 $jk$ 次方和。答案当然就是 $f(n,1)$。至于这个 $j$ 是一个伏笔（草）

提醒：$f(i,j)$ 可以被解释为生成 $jk$ 棵树全都彼此同构的方案数。

很显然下一步我们应该删掉根然后考虑它子树的构成。设 $tf(p,j,i)$ 是用大小不超过 $p$ 的子树拼成 $i$ 个节点，这堆子树的所有等价类大小的 $jk$ 次方和。

显然有 $f(i,j)=tf(i-1,j,i-1)$。

边界为 $tf(1,j,i)=1$。

考虑到只有大小相同的子树可能同构，不妨分别考虑 $p,p-1,p-2$。具体来说我们得到下面的东西：

# $tf(p,j,i)$

$$\boxed{tf(p,j,i)=\sum_{pu+v=i}tf(p-1,j,v)g(p,u,j){i\choose pu}^{jk}}$$

组合数比较好理解，简单来说就是我们从 $i$ 个标号里抽出了 $pu$ 个标号用来构成我们的这 $u$ 棵大小为 $p$ 的树。

那么这里的 $g(p,u,j)$ 表示的当然就是 $u$ 棵大小为 $p$ 的树的所有等价类大小的 $jk$ 次方之和。

讲道理至今为止其实我们没干什么东西，只不过把大小为 $p$ 的树抽出来讨论了而已。

提醒：$pu\le n$。

# $g(p,u,j)$

mark 一下，我们要求的是 $u$ 棵大小为 $p$ 的树的所有等价类大小的 $jk$ 次方之和，也可以解释为生成 $jk$ 组每组 $u$ 个大小为 $p$ 的树，每组互相同构的方案数。

冷静分析一下。假设 $n$ 个节点的树有 $m$ 个等价类，属于第 $i$ 号等价类的树有 $a_i$ 棵。那么**两个方案等价当且仅当 $\{a_i\}$ 相等**。

伟大的成就！可是每个等价类有多少方案呢？

首先考虑分配 $1...pu$ 个标号。显然方案数是

$$\dfrac{up\choose p,p,..,p}{\prod_{i}(a_i!)}$$

下面那个累乘是因为我们无法区分等价的树。

那么每个树内部都可以看成是以 $1..p$ 标号了。那么现在考虑它们内部的结构。答案是不是

$$\prod_if(p,a_ij)$$

呢？

显然不是。因为这样可能生成两组等价但是被算成两种等价类的树。假设我们把 $1...u$ 每棵树属于的等价类写成一个序列，那么我们只能考虑**无序**序列，或者一个 ``sort`` 过的代表序列。这个玩意显然不符合要求。

但上面这个东西并非没有价值。引入一些记号：我们考虑 $1...u$ 每棵树属于的等价类组成的**有序**序列，设一个有序序列为 $x$，组成的集合为 $X$。你可以理解为这是对 $u$ 棵树的**染色**。我们知道 $x$ 在 $\{a_i\}$ 的意义下同构，设它属于的等价类为 $\overline x$。我们有

$$\boxed{g(p,u,j)=\dfrac{(up!)^{jk}}{(p!)^{ujk}}\cdot\sum_{x\in X}\left(\prod_{i}\dfrac{1}{(a_i!)^{jk}}\right)\cdot\dfrac{\omega_x}{|\overline x|}}$$

其中 $\omega_x$ 表示可以被 $x$ 描述的树组个数的 $jk$ 次方。同属一个等价类的元素会重复计算它，所以还要除以 $|\overline x|$。

那么之前的式子是什么意思呢：它只要求 $a_1$ 个元素同色，另外 $a_2$ 个元素同色，……。而且它认为 $\{a_i\}$ **有序**（根本没人觉得它无序吧……）。我们知道要求某些东西同色可以被描述为**是某个置换的不动点**，在这里就是一个大小为 $a_1$ 的循环加一个大小为 $a_2$ 的循环……

设 $fix(A)$ 是置换 $A$ 的不动点集合，$A$ 拆成循环生成的序列是 $\{a'_i\}$，注意 $\{a'_i\}$ **有序**，因为循环之间是可以按最前面的元素的位置分出先后的（这也就和前面的 $\{a_i\}$ 有序对上了），那么我们有

$$\boxed{\color{red}\sum_{x\in fix(A)}\omega_x=\prod_{i}f(p,a_i'j)}$$

好了，伏笔回收。

可以看出这个东西和我们要求的 $g$ 起码算是有点关系了。那么问题就来了，系数 $\dfrac 1{|\overline x|}\prod_{i}\dfrac{1}{(a_i!)^{jk}}$ 该如何解决呢？

# 解决系数

既然元素可以带权，那么置换可不可以带权呢？答案当然是肯定的。

假设置换 $A$ 的权为 $w_A$，则有

$$\sum_{A\in G}w_A{\color{red}\sum_{x\in fix(A)}\omega_x}=\sum_{x\in X}\omega_x{\color{blue}\sum_{x\in fix(A)}w_A}$$

于是我们只需要求 $w_A$ 使得

$$\color{blue}\sum_{x\in fix(A)}w_A=\dfrac{C}{|\overline x|}\prod_i\dfrac{1}{(a_i!)^{jk}}$$

其中 $C$ 是一个常数，~~事实上是另一个伏笔~~。这样的话我们就有

$${\color{blue}C}\sum_{x\in X}{\color{blue}\left(\prod_{i}\dfrac{1}{(a_i!)^{jk}}\right)}\cdot\dfrac{\omega_x}{\color{blue}|\overline x|}=\sum_Aw_A{\color{red}\prod_{i}f(p,a_i'j)}$$

$$\boxed{C\dfrac{g(p,u,j)(p!)^{ujk}}{(up!)^{jk}}=\sum_Aw_A\prod_{i}f(p,a_i'j)}$$

伟大的成就！（震声）

注意到 $w_A$ 后面接的连乘号，我们自然也希望

$$w_A=\prod_i \hat w(a'_i)$$

你可能已经猜到 $\text{Exp}$ 了。具体如下。先假装我们会求 $\hat w(a'_i)$。

# 回到 $g(p,u,j)$

换掉 $w_A$，有更近一步的

$$\begin{aligned}&\sum_{x\in X}\left(\prod_{i}\dfrac{1}{(a_i!)^{jk}}\right)\cdot\dfrac{\omega_x}{|\overline x|}\\=&\dfrac{1}{C}\sum_A\prod_{i}\hat w(a_i)f(p,a_ij)\end{aligned}$$

考虑一个 $\{a_i\}$ 序列能代表几个置换。（由于对之前的 $a_i$ 的讨论已经停止了，我们从这里开始对 $a'_i$ 去掉 $'$ 号应该不至于混淆。)先决定标号从属于哪个循环，然后循环内可以圆排列，但是这样会使循环原本的次序错乱所以还要除以循环数的阶乘。

$$=\dfrac{1}{C}\sum_{l,\sum a_i=u}{u\choose a_1,a_2,...,a_l}\left(\prod_{i=1}^l(a_i-1)!\right)\dfrac{\prod_{i=1}^l\hat w(a_i)f(p,a_ij)}{l!}$$

$$=\dfrac{u!}{C}\sum_{l,\sum a_i=u}\dfrac 1{l!}\prod_{i=1}^l\dfrac{\hat w(a_i)f(p,a_ij)}{a_i}$$

审视一下这个形式。$\sum a_i=u$ 已经刻到 DNA 里了。设

$$F(x)=\sum_{i=1}^{\infty}\dfrac{\hat w(i)f(p,ij)x^i}{i}$$

那么我们得到

$$=\dfrac{u!}{C}[x^u]e^{F(x)}$$

也就是

$$\boxed{g(p,u,j)=\dfrac{(up!)^{jk}}{(p!)^{ujk}}\dfrac{u!}{C}[x^u]e^{F(x)}}$$

现在只剩 $\hat w(a_i')$ 的问题了。

# $\hat w(a'_i)$

我们希望满足的是

$$\sum_{x\in fix(A)}\prod_{i}\hat w(a'_i)=\dfrac{C}{|\overline x|}\prod_i\dfrac{1}{(a_i!)^{jk}}$$

展开 $|\overline{x}|$。

$$\sum_{x\in fix(A)}\prod_{i}\hat w(a'_i)=C\prod_{i}\dfrac{1}{(a_i!)^{jk}}{u\choose a_1,a_2,...,a_m}^{-1}$$

考虑 $x\in fix(A)$ 的 $A$。显然 $A$ 没有跨颜色块的循环。那么我们故技重施拆解颜色块，等式左边就等于

$$=\prod_{i=1}^m\sum_{l,\sum b_j=a_i}{a_i\choose b_1,b_2,...,b_l}\left(\prod_{j=1}^l(b_j-1)!\right)\dfrac {\prod_{j=1}^l\hat w(b_j)}{l!}$$

$$=\prod_{i=1}^ma_i!\cdot \sum_{l,\sum b_j=a_i}\dfrac 1{l!}\prod_{j=1}^l\dfrac{\hat w(b_j)}{b_j}$$

设 

$$G(x)=\sum_{i=1}^{\infty}\dfrac{\hat w(i)x^i}{i}$$

即

$$\prod_{i=1}^m[x^{a_i}]e^{G(x)}=\dfrac{C}{u!}\prod_{i}\dfrac{1}{(a_i!)^{jk}}$$

取 $C=u!$（伏笔回收），那么有

$$\boxed{[x^i]e^{G(x)}=\dfrac{1}{(i!)^{jk}}}$$

完 全 胜 利

# 暴力 Ln 和 Exp

MTT Exp……想想都恐怖……还是暴力吧

考虑

$$\text{Ln} F=G$$

$$\dfrac{F'}{F}=G'$$

$$F'-FG'=0$$

$$(n+1)f_{n+1}-\sum_{i=1}^{n+1}if_{n+1-i}g_i=0$$

$$\boxed{f_n=\dfrac{1}{n}\sum_{i=1}^nif_{n-i}g_i}$$

$$\boxed{g_n=f_n-\dfrac 1 n\sum_{i=1}^{n-1}if_{n-i}g_i}$$

# 复杂度分析

对于 $g(p,u,j)$，会计算$f(p,j),...,f(p,uj)$；

对于 $f(i,j)$，会计算 $g(p,u,j)(up\le i)$

而我们从 $f(n,1)$ 出发，也就是说会 DP 到的 $f,g$，其下标之积 $\le n$

但是 $tf$ 则是二，三维之积 $\le n$，第一维小于等于第三维，转移和第三维除以第一维有关……

容易发现 Exp 所用复杂度为 $\sum_{i}\sum_{j}\dfrac{n^2}{i^2j^2}=\Theta(n^2)$（著名的巴塞尔问题），Ln 所用时间复杂度为 $\sum_{i}\dfrac{n^2}{i^2}=\Theta(n^2)$，而 DP 所用时间复杂度为 $\sum_{j}\sum_{p=1}^{n/j}\sum_{i=1}^{p}\dfrac{p}{i}=\Theta(n^2\log n)$。

如果实现比较辣鸡可能会多出一个求逆元的 $\log$。

# 式子速查

$f(i,j)=tf(i-1,j,i-1)$

$tf(1,j,i)=1$

$$\boxed{tf(p,j,i)=\sum_{pu+v=i}tf(p-1,j,v)g(p,u,j){i\choose pu}^{jk}}$$

$$G(x)=\sum_{i=1}^{\infty}\dfrac{\hat w(i)x^i}{i}$$

$$\boxed{[x^i]e^{G(x)}=\dfrac{1}{(i!)^{jk}}}$$

$$F(x)=\sum_{i=1}^{\infty}\dfrac{\hat w(i)f(p,ij)x^i}{i}$$

$$\boxed{g(p,u,j)=\dfrac{(up!)^{jk}}{(p!)^{ujk}}[x^u]e^{F(x)}}$$

# 代码实现

直接抄式子不优化，喜提最劣解

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxN=2005;int p;
int N,K;
void inline check(int &x){x-=p,x+=x>>31&p;}
int qpow(int a,int k){
	int ans=1;
	while(k){
		if(k&1) ans=1LL*ans*a%p;
		a=1LL*a*a%p;
		k>>=1;
	}
	return ans;
}

int inv[maxN],fac[maxN],ifac[maxN];
int Fac[maxN][maxN],iFac[maxN][maxN];
void init(){
	inv[1]=fac[0]=ifac[0]=fac[1]=ifac[1]=1;
	for(int i=2;i<maxN;i++)
		inv[i]=1LL*(p-p/i)*inv[p%i]%p,
		fac[i]=1LL*fac[i-1]*i%p,
		ifac[i]=1LL*ifac[i-1]*inv[i]%p;
	for(int i=0;i<maxN;i++)
		Fac[i][0]=iFac[i][0]=1,
		Fac[i][1]=qpow(fac[i],K),iFac[i][1]=qpow(ifac[i],K);
	for(int i=0;i<maxN;i++)
	for(int j=2;j<maxN;j++)
		Fac[i][j]=1LL*Fac[i][j-1]*Fac[i][1]%p,
		iFac[i][j]=1LL*iFac[i][j-1]*iFac[i][1]%p; 
}

void Ln(int f[],int g[],int n){
	g[0]=0;
	for(int i=1;i<=n;i++){
		g[i]=f[i];
		for(int j=1;j<i;j++)
			check(g[i]+=p-1LL*j*f[i-j]%p*g[j]%p*inv[i]%p);
	}
}
void Exp(int g[],int f[],int n){
	f[0]=1;
	for(int i=1;i<=n;i++){
		f[i]=0;
		for(int j=1;j<=i;j++)
			check(f[i]+=1LL*j*f[i-j]%p*g[j]%p);
		f[i]=1LL*f[i]*inv[i]%p;
	}
}

int tmp[maxN];
int hatw[maxN][maxN];
int F[maxN][maxN];
int tF[maxN][maxN]; //tF[j][i]=tf(i,j,i)
int ttF[maxN][maxN];
int G[maxN][maxN]; //G[j][u]=g(i,u,j)

int main(){
	scanf("%d%d%d",&N,&K,&p);init();
	for(int j=1;j<=N;j++){
		for(int u=0;u<=N/j;u++)
			tmp[u]=iFac[u][j];
		Ln(tmp,hatw[j],N/j);
	}
	for(int P=1;P<=N;P++){
		if(P==1) for(int j=1;j<=N;j++) F[P][j]=1;
		else for(int j=1;j<=N/P;j++) F[P][j]=tF[j][P-1];
		if(P==1) for(int j=1;j<=N;j++) for(int k=0;k<=N/j;k++) tF[j][k]=1;
		else{
			for(int j=1;j<=N/P;j++){
				for(int u=1;u<=N/P/j;u++) tmp[u]=1LL*hatw[j][u]*F[P][u*j]%p;
				Exp(tmp,G[j],N/P/j);
				for(int u=1;u<=N/P/j;u++) G[j][u]=1LL*G[j][u]*iFac[P][u*j]%p;
				for(int i=0;i<=N/j;i++) ttF[j][i]=tF[j][i];
				for(int i=1;i<=N/j;i++)
				for(int u=1;u<=i/P;u++)
					check(ttF[j][i]+=1LL*tF[j][i-u*P]*G[j][u]%p*Fac[i][j]%p*iFac[i-u*P][j]%p);
				swap(ttF[j],tF[j]);
			}
		}
	}
	printf("%d\n",1LL*F[N][1]*iFac[N-1][1]%p);
}
```

# 彩蛋

败了呀。

![](https://xyix.github.io/images/qiyangak.png)

---

## 作者：shadowice1984 (赞：21)

STO jry Orz

~~吉老师带我飞~~

由于官方题解省略了全部的细节而std是拿指数生成函数写的，官方题解半句话没提这事，所以可能有些人会像我一样对着标算里的polyexp和polyln无限懵逼……而且更加nb的是std里的polyln和exp是极为罕见的$O(n^2)$暴力实现，然后我就更加懵逼了

~~所以写一篇题解来纪念一下这道烧了我3天的毒瘤题~~

~~另外感谢_rqy,rqy是我们的红太阳没有它我们会死~~
_______________

## 前置芝士:burnside引理/polya定理

如果您不会这东西的话请设法百度/看博客学会这个东西

并且这篇题解为了描述方便我们将使用群论术语~~放弃说人话~~

所以您必须知道这些名词是什么，如果不懂的话请自行百度

**群,子群,置换群,置换,轮换,置换环,群G作用于集合X,轨道,稳定化子,轨道-稳定集定理，burnside引理，polya定理**

# 本题题解

## 整理题意

按照大家一种常用的方式random k棵有根树，问random出来的有根树全部同构的概率

~~真是毒瘤出题人，一个点居然有1e9棵树~~

那么我们知道这样一共可以生成$(n-1)!$种不同的有根树，由于我们生成了k棵树所以总方案数就是$(n-1)!^k$

那么一个非常暴力的思路就是枚举所有可能的树然后用树hash判同构，然后算出每一种hash值的出现次数，所有hash值出现次数的k次方之和就是生成的k棵树全部同构的方案数了，我们把这个数字除以$(n-1)!^k$就可以得到答案了

以下为了方便起见，我们认为一个等价类是指一堆**标号不同**但是彼此同构的有根树，这篇题解中出现的**等价类size的xx次幂之和**这样的东西是指所有不同的等价类的大小的xx次幂的和

## 从一个naive的dp开始

我们来尝试一个非常诡异的dp状态，$dp(i,j)$表示size为i的树的等价类size的jk次幂之和

说人话就是$dp(i,j)$表示生成$j×k$棵大小为$i$的树，并且这些树全部同构的方案数

此时我们发现这个状态十分的诡异，从j这一维的定义来看我们看不到什么成功转移的可能性，因为我们的答案是$dp(n,1)$所以答案明显是从$j$比较大的维度转移过来的，但是好像这样转移j会无限增大下去……

不过值得庆幸的是这个状态至少有边界$dp(1,x)=1$所以我们抱着一丝希望开始推这个dp的转移……

由于j这一维我们暂时不知道怎么处理，所以我们暂时考虑只考虑i这一维的转移

我们发现把一个大小为i的树的树根删掉之后我们会得到一堆树

那么我们不妨设$tmp(i,j,p)$表示仅用大小不超过$i$的树凑出size和为p的一堆树的等价类size的jk次幂

说人话就是$dp(i,j)=tmp(i-1,j,i-1),tmp(1,xxx,xxx)=1$

当然这样的话空间似乎开不太下所以我们的tmp是滚动数组实现的，我们把$i$那一维滚掉，然后用$tmp(i-1,j,i-1)$求出来$dp(i,j)$之后我们就直接迭代到$tmp(i,j,xxx)$这一个数组上


那么假如我们知道了$tmp(i-1,j,xxx)$这个数组，我们怎么转移到$tmp(i,j,xxx)$这个数组上呢？

答案是做背包，我们可以列出来这样一个转移式子

$$tmp(i,j,t)=\sum_{i×v+k=t}tmp(i-1,j,k)f(i,v,j){t\choose i×v}^{jk}$$

其中$f(i,v,j)$表示选择$v$棵$size$为$i$的树产生的等价类size的jk次幂之和

说人话就是我们枚举size为i的子树有几个然后大力做背包

然后我们的转移式子中出现了一个令人迷惑的组合数……，

值得注意的是处于同一个等价类的数彼此之间同构，所以区别他们的只有标号

那么$f(i,v,j)tmp(i-1,j,k)$表示的是令$f(i,v,j)$这些树的标号全部大于$tmp(i-1,j,k)$中的树的标号所产生的等价类size的jk次幂之和

但是事实上我们并没有$f(i,v,j)$的标号必须更大这个限制，我们其实只需要保证$f(i,v,j)$和$tmp(i-1,j,k)$这两堆树内部编号的大小关系不变即可……(如果内部的编号顺序改变会影响父子关系)，所以我们有${t\choose i×v}$中方式重新混合标号，因此等价类的size会扩大${t\choose i×v}$倍，那么等价类size的jk次幂就会扩大${t\choose i×v}^{jk}$倍了

好了至此为止我们看起来只需要计算出$f(i,v,j)$然后把这东西喂进去我们就能得到令人满意的答案了

然后这就是噩梦的开始，因为接下来我们会意识到$f(i,v,j)$令人吃鲸的难算……

这里先说一个后面会有用的结论:$iv$的乘积绝对不会超过$n$

## 计算$f(u,v,j)$

也就是无序的选择$v$棵$size$为$u$的树所产生等价类$size$的$jk$次幂之和

注意这里有个限制叫**无序**，过一会我们会深刻认识到这东西对dp产生的干扰效果有多强烈

首先我们需要认识到一件事情是答案并不是

$$dp(u,vj)(\frac{(uv)!}{(u!)^v})^{jk}$$

先来解释一下上面式子的组合意义，我们单纯的把$v$棵$dp(u,j)$这样的树放在一起会产生$dp(u,vj)$这么大的等价类，然后重新分配标号之后等价类的size扩大$\frac{(uv)!}{(u!)^v}$这么多倍，就得到了上面这个式子

然鹅我们犯了两个致命的错误……$dp(u,vj)$表示的是v棵彼此同构的树放到一起的方案数，因为我们将次数提升了v次的意思每个等价类直接复制v份，换句话讲生成的v棵树就会全部同构

另一个致命的错误是，当有些树是同构的时候我们不能直接重新分配标号

比如考虑这样两颗树

![](https://cdn.luogu.com.cn/upload/pic/48222.png)

![](https://cdn.luogu.com.cn/upload/pic/48223.png)

一个正常人都会发现就算是带标号这两个树长得也是一膜一样……

但是如果我们重新分配标号的时候这两个树就会被算成两种不同的方案

为什么呢？因为左右子树是**同构**的,如果左右子树不同构，那么我们就不会出现这个问题，比如下面的两颗树标号就不相同

![](https://cdn.luogu.com.cn/upload/pic/48224.png)

![](https://cdn.luogu.com.cn/upload/pic/48225.png)

同样是交换了左右子树的编号但是如果被交换标号的树是同构的就其实一种方案了



那么我们总结一下我们现在想干什么

由于$\frac{(uv)!}{(u!)^v}$这种分配标号的方式非常的蠢，他会认为所有的子树互不同构，但是其实有些子树是同构的，此时我们分配标号就会出现偏差……

那么我们可以用一组整数拆分$\{a_{1},a_{2},a_{3}...a_{m}\}$来描述一组树的同构情况,表示一共有m种不同形状的树，第i种形状有$a_{i}$棵

那么答案就是

$$\sum_{a_{1}+a_{2}...a_{m}=v}f(a_{1},a_{2}..a_{m})\prod_{i=1}^{m}\frac{1}{(a_{i}!)^k}$$

其中$f(a_{1},a_{2}..a_{m})$表示同构情况为这种整数拆分的等价类size的jk次幂之和

关于求$f(a_{1},a_{2}...a_{m})$有一个精妙的容斥做法可以处理它，然鹅我们发现容斥的复杂度和整数拆分数有关,根本过不去$n=2000$的大数据……

关键是我们为什么会重复呢？,是因为如果我们直接计算

$$\prod_{i=1}^{m}dp(u,a_{i}j)$$

他是不等于$f(a_{1},a_{2}...a_{m})$的，因为两个dp之间会包含一模一样的等价类，换句话说，我们的树组当中，有些同构的树没有排在一起，而我们仅仅希望计算那些同构的树都挨在一起的树组

用群论的语言说一遍就是:

我们令一个置换群$G$中的元素为全体长度为$m$的置换，

我们定义一种集合$X$,$X$中的元素是一个长度为$v$的树的向量，并且向量中每颗树大小为u,每颗树的标号都在$[1,u]$之间，(因为此时我们还没有重新分配标号)

现在令$G$作用于$X$上，设$Orbit(x)$表示一个特定元素x的轨道

我们令一个元素的权值为

$$w(x)=\prod_{i=1}^{m}dp(u,a_{i}j)$$

假设这个元素的同构情况为$\{a_{1},a_{2},a_{3}...a_{m}\}$

显然$Orbit(x)$中的元素权值全部等于$w(x)$，因此我们令一个轨道的权值为其中任意一个元素的权值，也就是$w(x)$

换言之

$$w(Orbit(x))=w(x)$$

现在我们希望计算所有轨道的权值之和，也就是这个式子

$$\sum_{x \in X}\frac{w(Orbit(x))}{|Orbit(x)|}\prod_{i=1}^{m}\frac{1}{(a_{i}!)^k}$$

所以此时我们点别的方式来帮助我们去重，说到去重，置换群，轨道，我就想起了burnside引理

## burnside引理的加权形式

显然这里我们统计的根本不是什么方案数，所以平常的burnside引理看起来不能用了

还好我们的burnside引理是有拓展形式的，令$w(orbit(x))=w(x)$，其中$w$是一个特定的权重函数

那么**所有轨道的权值之和等于所有置换的不动点权值之和平均数**

即burnside引理在权重形式下依然成立

$$\sum_{x \in X}\frac{w(Orbit(x))}{|Orbit(x)|}=\frac{1}{|G|}\sum_{f}w(fix(f))$$

等会啊……这个和我们刚才的式子还是有差距……

刚才的式子还有一个系数……

不好意思，这东西已经塞不到轨道的权重函数里去了……(虽然你乍一看能塞进去但是其实塞不进去，会影响后面的dp)

所以让我们来折腾稳定化子好了，我们让稳定化子也带上权

令$w(stab(x))$为x的所有稳定化子的权值之和

那么只要等式

$$|Orbit(x)|w(stab(x))=\prod_{i=1}^{m}\frac{1}{(a_{i}!)^k}$$

成立，根据burnside引理的证明过程我们就可以推出

$$\sum_{x \in X}\frac{w(Orbit(x))}{|Orbit(x)|}\prod_{i=1}^{m}\frac{1}{(a_{i}!)^k}=\frac{1}{|G|}\sum_{f}w(f)w(fix(f))$$

好了擦亮你的眼睛，中间连的是个**等号**

所以这个式子是成立的

$$f(u,v,j)=\frac{1}{v!}\sum_{f}w(f)w(fix(f))$$

wow f函数终于能算了！

接下来我们需要请出polya定理了，polya定理告诉我们每一个置换环是独立的，所以假设一个置换f可以被分解为${a_{1},a_{2},a_{3}...a_{m}}$这样的置换环(意思是一共m个置换环第$i$个size为$a_{i}$)

那么我们会有这样的一个式子

$$w(f)w(fix(f))=\prod_{i=1}^{m}dp(u,a_{i}j)w(a_{i})$$

（此时你会发现我们的j这一维终于有边界了！转移的时候两维的乘积越来越小，所以状态$dp(i,j)$合法当且仅当$ij\leq n$）

这里为什么$dp$之间可以乘起来呢？因为我们算的就是不动点权值之和，这里当两个dp对应的树有重复的时候造出来的是一个有序的向量，并且由于同底数幂相乘等于指数相加，所以权值函数还是对的，因此自然也是一个不动点了

这也是为什么我们不能把阶乘丢到权值函数里，因为阶乘会导致不动点权值的计算不能套polya定理……，所以我们只能忍痛把权值放到稳定化子里去了……

好了现在唯一的问题就是置换环的权值怎么算

~~这个一会再说~~，让我们假装自己知道了每个置换环的权值，当然随着$j$的不同置换环的权值是不同的，假设$xs(j,i)$表示jk次幂时大小为i的置换环的权值，那么我们计算置换权值乘不动点权值之和的时候就是用$f(i)=xs(j,i)dp(u,ij)$这些单个环的权值去拼整个置换的权值

那么我们设$g(i)$表示所有长度为$i$的权值之和，那么我们可以列出这样一个和式

$$g(n)=n!\sum_{1a_{1}+2a_{2}+3_a{3}...ma_{m}=n}\prod_{i=1}^{m}\frac{f(i)^{a_{i}}}{i^{a_{i}}a_{i}!}$$

解释一下和式就是我们枚举置换环的分布情况，然后这里有一个结论是如果长度为i的置换环出现了$a_{i}$次那么置换环分布为$\{a_{1},a_{2}...a_{m}\}$的排列个数为

$$\frac{n!}{\prod_{i=1}^{m}i^{a_{i}}a_{i}!}$$

那么我们再一看刚才那个式子其实就是套路的枚举分布情况算贡献了

具体来讲我们计算$g(i)$可以大力$dp(i,j)$表示用不超过$i$的置换环拼成长度为$j$的置换的方案数,转移的时候大力枚举长度为$i+1$的置换环出现了几次然后背包就行了

这样去做背包我们可以把长度为$1$到$n$的【置换权值乘不动点权值】之和都给刷出来,并且背出来的数组就是权值和除过$|G|$的结果,所以我们也不用除$|G|$了

换句话讲假如我们需要$f(u,1,j),f(u,2,j),f(u,3,j)...f(u,v,j)$的值的话，我们把这些值全部刷出来的复杂度是$O(v^2logv)$的

~~其实你会发现那东西就是polyexp~~

好了现在让我们来考虑置换环的权值是什么……

置换环的权值$xs(j,i)$应该能让我们满足这个恒等式

$$\frac{|Orbit(x)|w(stab(x))}{|G|}=\prod_{i=1}^{m}\frac{1}{(a_{i}!)^{jk}}$$

让我们来考虑$|Orbit(x)|=1$的状态,这种情况下x其实是一个非常特殊的状态，这个向量里的所有树都同构，那么显然任意一个长度为m的置换都是这个状态的稳定化子

换句话讲我们用一个特殊的状态把长度为$m$的置换权值之和给套出来了……，长度为m的置换的权值之和就是

$$\frac{1}{m!}\sum_{f}w(f)=\frac{1}{(m!)^{jk}}$$

那么我们知道所有置换环的权值还等于各个置换环做背包的结果

也就是说

$$\sum_{1a_{1}+2a_{2}+3_a{3}...ma_{m}=n}\prod_{i=1}^{m}\frac{xs(j,i)^{a_{i}}}{i^{a_{i}}a_{i}!}=\frac{1}{m!}\sum_{f}w(f)=\frac{1}{(m!)^{jk}}$$

那么假设我们推出了前$i-1$项置换环的系数，我们就可以背包背出来用不超过$i-1$的置换环凑出来的置换的系数和,我们知道这东西加上长为$i$的置换环的权值就是$\frac{1}{(i!)^{jk}}$所以减一下就行了

所以我们算置换环的系数就是边背包边容斥，如此这般就能求出来了

~~其实你会发现这东西就是poly_ln~~

## 复杂度分析

如果你把上面的算法实现出来你会发现他的复杂度是

$$\sum_{i=1}^{n}O((n/i)^2log(n/i))=O(n^2log^2n)$$

这个复杂度已经可以丑陋的通过这题了

标算的使用了polyexp和polyln的组合意义，复杂度为

$$\sum_{i=1}^{n}O((n/i)^2)=O(n^2logn)$$

这东西相当快，大概600ms左右

~~但是全程指数生成函数对调试极端不友好……~~

上代码~

```C
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<algorithm>
#include<cstdio>
using namespace std;const int N=2*1e3+10;typedef unsigned long long ll;ll mod;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
int n;int k;ll dp[N][N];ll tmp[N][N];ll ck[N][N];ll tr[N];ll f[N];ll xs[N][N];
ll cjk[N][N];ll fac[N];ll ifac[N];ll inv[N];
inline void pre()//处理一些该处理的东西 
{
    fac[0]=1;for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
    inv[0]=1;inv[1]=1;for(int i=2;i<=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
    ifac[0]=1;for(int i=1;i<=n;i++)(ifac[i]=ifac[i-1]*inv[i])%=mod;
    for(int i=0;i<=n;i++)
    {
        ck[i][0]=ck[i][i]=1;
        for(int j=1;j<i;j++)ck[i][j]=(ck[i-1][j-1]+ck[i-1][j])%mod;
    }for(int i=0;i<=n;i++)for(int j=0;j<=i;j++)ck[i][j]=po(ck[i][j],k);
    for(int i=1;i<=n;i++)xs[i][1]=1;
    for(int j=1;j<=n;j++)//背包加容斥处理出置换环系数 
    {
        int lim=n/j;
        for(int i=0;i<=lim;i++)f[i]=ifac[i];
        for(int i=2;i<=lim;i++)
        {
            xs[j][i]=(po(ifac[i],(ll)j*k)+mod-f[i])%mod;ll ret=xs[j][i];ll val=ret;
            for(int p=0;p<=lim;p++)tr[p]=f[p];
            for(int p=1,si=i;si<=lim;p++,si+=i,val=val*ret%mod*inv[p]%mod)
                for(int t=lim;t>=si;t--)(tr[t]+=f[t-si]*val)%=mod;
            for(int p=0;p<=lim;p++)f[p]=tr[p];
        }
    }
}
inline void calcf(int siz,int lim,int pw)//计算f函数就是大力背包 
{
    for(int i=1;i<=lim;i++)f[i]=0;f[0]=1;
    for(int i=1;i<=lim;i++)
    {
        ll ret=xs[pw][i]*dp[siz][i*pw]%mod;ll val=ret;
        for(int j=1;j<=lim;j++)tr[j]=f[j];
        for(int j=1,si=i;si<=lim;j++,si+=i,val=val*ret%mod*inv[j]%mod)
            for(int t=lim;t>=si;t--)(tr[t]+=f[t-si]*val)%=mod;
        for(int j=1;j<=lim;j++)f[j]=tr[j];
    }for(int i=1;i<=lim;i++)
        (f[i]*=po(fac[siz*i],(ll)pw*k)*po(ifac[siz],(ll)i*pw*k)%mod)%=mod;
}
int main()
{
    scanf("%d%d%lld",&n,&k,&mod);pre();
    for(int i=1;i<=n;i++)dp[1][i]=1;
    for(int i=1;i<=n;i++)for(int j=0;j<=n;j++)tmp[i][j]=1;
    for(int i=2;i<=n;i++)//大力dp转移即可 
    {
        for(int j=1;j<=(n/i);j++)dp[i][j]=tmp[j][i-1];
        for(int p=1;i*p<=n;p++)
            for(int t=n,siz=i*p;t>=siz;t--)cjk[t][siz]=1;
        for(int j=1;i*j<=n;j++)
        {
            for(int p=1;i*p*j<=n;p++)
                for(int t=(n/j),siz=i*p;t>=siz;t--)(cjk[t][siz]*=ck[t][siz])%=mod;
            calcf(i,n/(i*j),j);
            for(int t=0;t<=(n/j);t++)tr[t]=tmp[j][t];
            for(int p=1;i*j*p<=n;p++)
            {
                for(int t=(n/j),siz=i*p;t>=siz;t--)
                    (tr[t]+=tmp[j][t-siz]*f[p]%mod*cjk[t][siz])%=mod;
            }for(int t=0;t<=(n/j);t++)tmp[j][t]=tr[t];
        }
    }printf("%lld",dp[n][1]*po(ifac[n-1],k)%mod);return 0;//拜拜程序~ 
}
```










































---

## 作者：x义x (赞：17)

这道刻在 DNA 里的好题想必大家都很熟悉，这里就不写题意了。

# 1. 起手式

如果你不知道 Symbolic Method，下面是一些你可能需要的背景知识。

> - 记 $\mathcal T$ 是所有无标号有根树的集合。
> - 对于树 $t$，记 $|t|$ 表示 $t$ 的节点数。
> - 记 $w(t)$ 为给 $t$ **分配标号**（即给每个节点写上一个数字，$1\sim |t|$ 中的数字必须恰好用一次，且每个子树中根节点的编号必须小于其他所有节点）的方案数。
> - 如果把两棵树 $t_1,t_2$ "捆在一起"成为有序对 $(t_1,t_2)$，那么应该有
>
> $$
w((t_1,t_2))=w(t_1)w(t_2){|t_1|+|t_2|\choose |t_1|}
$$
>
> - （相当于选 $|t_1|$ 个标号分给 $t_1$ 让他自己分配，$t_2$ 亦然）
> - 注意到我们所欲求的是 $\sum_{t\in\mathcal T}[|t|=n]w^k(t)$，于是不妨编一个生成函数
>
> $$
T_k(\{a\};x)=\dfrac{w^k(a)x^{|a|}}{(|a|!)^k}
$$
>
> - 对于树的集合 $\mathcal A$，定义它的生成函数是其中的所有树的生成函数之和。
>
> $$
T_k(\mathcal A;x)=\sum_{a\in\mathcal A}\dfrac{w^k(a)x^{|a|}}{(|a|!)^k}
$$
>
> - （有时为了简略我们会写为 $T_k(\mathcal A)$）
> - 不难验证，对于 $\mathcal A\times \mathcal B=\{(a,b),a\in\mathcal A,b\in\mathcal B\}$（称为两个组合类的**笛卡尔积**），有
>
> $$
T_k(\mathcal A\times\mathcal B)=T_k(\mathcal A)T_k(\mathcal B)
$$
>
> - 也就是说，**我们把两个组合类的笛卡尔积对应成了它们生成函数的乘积。**
>
> - 另外需要注意，有序列表可以看成有序对的不断嵌套，比如 $(((1,2),1),3)$ 其实就是 $(1,2,1,3)$。

我们都知道，任何一棵无标号有根树都可以这样表示：

- 它的根，和它的子树列表（一个由无标号有根树构成的无序列表）。

不妨记为
$$
\mathcal T^{\square}=\text{MSET}(\mathcal T)
$$

其中，$^{\square}$ 的意义是去掉根，而 $\text{MSET}(\mathcal A)$ 的意义是"所有由 $\mathcal A$ 中元素构成的无序列表"。下面我们的任务就变成：**为 $^{\square}$ 和 $\text{MSET}$ 找到对应的生成函数运算。**

不妨记 $^{\square}$ 对应的是 $\text{xD}$，$\text{MSET}$ 对应的是 $\text{xexp}$。

# 2. $\text{xD}$ 的部分

$^{\square}$ 反映在生成函数上的效果是显然的：所有对象的节点数 $-1$，而 $w$ 不变。如果对所有对象求和就是
$$
\text{xD}:\sum_{a\in\mathcal A}\dfrac{w^k(a)x^{|a|}}{(|a|!)^k}\mapsto\sum_{a\in\mathcal A}\dfrac{w^k(a)x^{|a|}}{((|a|-1)!)^k}
$$
既然如此，我们也就没有必要枚举 $a$ 了，而是可以直接从 $T_k(\mathcal A)$ 的系数得到 $\text{xD}(T_k(\mathcal A))$。
$$
\text{xD}:\sum_{i=1}^{\infty}\dfrac{f_ix^i}{(i!)^k}\rightarrow\sum_{i=0}^{\infty}\dfrac{f_{i+1}x^i}{(i!)^k}
$$
# 3. $\text{xexp}$ 的部分

回忆 OGF 中有个叫"Euler 变换"的东西，它是
$$
\text{Euler}:T_0(\{a\})\mapsto\sum_{i=0}^{\infty}\left(x^{|a|}\right)^i
$$
$$
\text{Euler}:T_0(\mathcal A)\mapsto\prod_{a\in\mathcal A}\sum_{i=0}^{\infty}\left(x^{|a|}\right)^i
$$
说白了：如果把无序列表看成排序过的有序列表，那么这里就是枚举每个元素用了几个。

回忆 EGF 中有个叫 $\exp$ 的东西，它是
$$
\exp:T_1(\{a\})\mapsto\sum_{i=0}^{\infty}\dfrac{\left(\frac{w(a)x^{|a|}}{|a|!}\right)^i}{i!}
$$
$$
\exp:T_1(\mathcal A)\mapsto\prod_{a\in\mathcal A}\sum_{i=0}^{\infty}\dfrac{\left(\frac{w(a)x^{|a|}}{|a|!}\right)^i}{i!}
$$
考虑它的含义：还是枚举每个元素选几个，然后如果你选了 $i$ 个 $a$，那么在分配标号的时候还要除以 $i!$。

为什么呢？因为你把 $\frac{w(a)x^{|a|}}{|a|!}$ 硬乘时实际上是把 "$i$ 个 $a$" 当有序列表来分配标号的，然而这 $i$ 个 $a$ 之间的标号分配方式可以任意互换，即一些标号分配方式互相等价。然后你又会发现，每个等价类大小恰好是 $i!$，于是就有了上式。

那么我们这里的 $\text{xexp}$ 自然也就很明朗了：
$$
\text{xexp}:T_k(\{a\})\mapsto\sum_{i=0}^{\infty}\dfrac{\left(\frac{w^k(a)x^{|a|}}{(|a|!)^k}\right)^i}{(i!)^k}
$$
$$
\text{xexp}:T_k(\mathcal A)\mapsto\prod_{a\in\mathcal A}\sum_{i=0}^{\infty}\dfrac{\left(\frac{w^k(a)x^{|a|}}{(|a|!)^k}\right)^i}{(i!)^k}
$$
我们分配了 $k$ 次标号，自然就要除以 $(i!)^k$。

$k=0$ 的时候 $\text{xexp}$ 退化为 $\text{Euler}$ 变换。$\text{Euler}$ 变换的性质好在：对于单个元素， $\text{Euler}$ 变换的乘法逆很简单（从而可以方便地求 $\ln$）。

$k=1$ 的时候 $\text{xexp}$ 退化为 $\exp$。$\exp$ 的性质好在 $\exp(a)\cdot\exp(b)=\exp(a+b)$。

不幸的是 $\text{xexp}$ 两个性质都没有。所以我们只能大力 $\ln$：

$$
\exp\sum_{a\in\mathcal A}\ln\circ\operatorname{xexp}T(\{a\})
$$
接下来任务就变成求解 $\sum_{a\in\mathcal A}\ln\circ\operatorname{xexp}(T\{a\})$。

## 3.1. 对于单个元素

$$
\ln\circ\operatorname{xexp}T(\{a\})=\ln \sum_{i=0}^{\infty}\dfrac{\left(\frac{w^k(a)x^{|a|}}{(|a|!)^k}\right)^i}{(i!)^k}
$$
事实上可以预处理。下面不妨记
$$
\ln\sum_{i=0}^{\infty}\dfrac{x^i}{(i!)^k}=\sum_{i=0}^{\infty}f_ix^i
$$
那么之前的式子就是将 $x\leftarrow \frac{w^k(a)x^{|a|}}{(|a|!)^k}$ 代入其中。

## 3.2. 对于整个组合类

$$
\begin{aligned}
\sum_{a\in\mathcal A}\ln\circ \operatorname{xexp}T(\{a\})&=\sum_{a\in\mathcal A}\sum_{j=0}^{\infty}f_i\left(\frac{w^k(a)x^{|a|}}{(|a|!)^k}\right)^i\\
&=\sum_{i=0}^{\infty}f_i\sum_{a\in\mathcal A}\frac{w^{ik}(a)x^{i|a|}}{(|a|!)^{ik}}\\
&=\sum_{i=0}^{\infty}f_iT_{ik}(\mathcal A;x^i)
\end{aligned}
$$

即，
$$
\operatorname{xD}T_k(\mathcal A;x)=\exp\sum_{i=0}^{\infty}f_iT_{ik}(\mathcal A;x^i)
$$
这便是最终式子了。它的处理细节和复杂度分析等参见[这篇题解](https://xyix.gitee.io/posts/?page=0&postname=luogu-4500)。



---

## 作者：FunnyCreatress (赞：11)

感觉题解区的理论都好毒瘤啊 /kk，给一个无群论，无 EGF，无 MSET，需要的前置只有最基础生成函数的推法。~~快夸我良心题解人~~

记 $\mathscr{T_n}$ 为所有 $n$ 个点无标号有根树的集合，$|\mathcal{T}|$ 为树 $\mathcal T$ 的节点个数，$g(\mathcal{T})$ 为树 $\mathcal{T}$ 的本质不同合法标号种数除以 $|\mathcal{T}|!$。

显然我们有
$$g(\mathcal{T})=\prod_{i=1}^{|\mathcal{T}|}\dfrac{1}{S_i}\prod_j\dfrac1{C_{i,j}!}$$
其中 $S_i$ 为子树 $i$ 的大小，$C_{i,j}$ 为 $i$ 儿子子树的各等价类大小。

题目要求的就是
$$\dfrac1{\big((n-1)!\big)^k}\sum_{\mathcal{T}\in \mathscr{T_n}}\big(n!\ g(\mathcal T)\big)^k=n^k\sum_{\mathcal{T}\in\mathscr{T_n}}g(\mathcal{T})^k$$

记 $f_{n,i}=\sum_{\mathcal T\in\mathscr{T_n}}g(\mathcal T)^{ik}$，我们所求的东西就是 $n^kf_{n,1}$。关于这个 $i$ 有什么用，待会推柿的时候就会看出来。

为了避免后面出现歧义，原先的 $n$ 改记为 $N$。

考虑删去根的情况，我们有
$$f_{n,i}=\dfrac1{n^{ik}}[x^{n-1}]\prod_{j=1}^{n-1}\prod_{\mathcal{T}\in\mathscr{T_j}}\sum_{p=0}^{+\infty}\dfrac{g(\mathcal{T})^{ipk}}{(p!)^{ik}}x^{jp}$$

后面那坨东西不好处理，使用经典的取完 $\ln$ 再 $\exp$ 回去的套路。设多项式 

$$H_i(x)=\ln\ \sum_{p=0}^{+\infty}\dfrac{x^{p}}{(p!)^{ik}}=\sum_{p=1}^{+\infty}h_{i,p}x^p$$

后面可以知道，我们只需要 $H_i(x)$ 的前 $\lfloor\dfrac Ni\rfloor$ 项系数，所以暴力求 $\ln$ 可以接受，这部分复杂度 
$$O\big(\sum_{i=1}^n\dfrac{N^2}{i^2}\big)=O(N^2)$$

将 $H_i$ 的定义代入得

$$\begin{aligned}&\dfrac1{n^{ik}}[x^{n-1}]\prod_{j=1}^{n-1}\exp\large\{\normalsize\sum_{\mathcal{T}\in\mathscr{T_j}}H_{i}\big(g(\mathcal{T})^{ik}x^j\big)\large\}\\=&\dfrac1{n^{ik}}[x^{n-1}]\prod_{j=1}^{n-1}\exp\large\{\normalsize\sum_{p=1}^{+\infty}h_{i,p}x^{jp}\sum_{\mathcal{T}\in\mathscr{T_j}}g(\mathcal{T})^{ipk} \large\}\\=&\dfrac1{n^{ik}}[x^{n-1}]\prod_{j=1}^{n-1}\exp\large\{\normalsize\sum_{p=1}^{+\infty}h_{i,p}f_{j,ip}x^{jp}\large\}\end{aligned}$$

可以通过归纳法证明，我们需要的状态中 $ni\le N$，因此 $p$ 的上界可改为 $\lfloor\dfrac{N}{ij}\rfloor$。

记后面那坨多项式的乘积为 $L_{i}(x)$，那么我们每算出某个 $n$ 的所有 DP 值，我们就令 
$$L_{i}\gets L_{i}\exp\large\{\normalsize\sum_{p=1}^{\lfloor\frac N{in}\rfloor}h_{i,p}f_{n,ip}x^{np}\large\}\normalsize$$

暴力 $\exp$，当然 $\exp$ 的时候 $x$ 的指数是不包含 $n$ 的，复杂度为
$$O\big(\sum_{n=1}^N\sum_{i=1}^{\lfloor\frac{N}n\rfloor}(\dfrac{N}{in})^2\big)=O(N^2)$$

暴力更新 $L_i$ 的复杂度为
$$O\big(\sum_{i=1}^N\dfrac Ni\sum_{j=1}^{\lfloor\frac{N}{i}\rfloor}\dfrac{N}{ij}\big)=O(N^2\log N)$$
于是我们就愉快地切了此题~

回到之前的一个问题，$i$ 这一维似乎是凭空出现的，那么为什么会想到加上 $i$ 这一维呢？

反正我一开始是没想到的，但推到类似欧拉变换的那一步时发现需要更多信息，然后把这维加上发现定义就是良好的了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
int n,k,P,fact[N],invf[N],invp[N];vector<int> f[N],L[N],h[N]; 
int qpow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%P,y>>=1)
		if(y&1)res=1ll*res*x%P;
	return res;
}
int add(int x,int y){return (x+=y)>=P?x-P:x;}
vector<int> ln(vector<int> f){
	int n=f.size()-1;
	vector<int> g(n+1);
	for(int i=1;i<=n;i++){
		g[i]=1ll*i*f[i]%P;
		for(int j=1;j<i;j++)g[i]=add(g[i],P-1ll*j*g[j]%P*f[i-j]%P);
		g[i]=1ll*invp[i]*g[i]%P;
	}
	return g;
}
vector<int> exp(vector<int> f){
	int n=f.size()-1;
	vector<int> g(n+1,0);
	g[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++)g[i]=add(g[i],1ll*j*f[j]%P*g[i-j]%P);
		g[i]=1ll*invp[i]*g[i]%P;
	}
	return g;
}
int main(){
	scanf("%d%d%d",&n,&k,&P);
	fact[0]=fact[1]=invf[0]=invf[1]=invp[1]=1;
	for(int i=2;i<=n;i++)fact[i]=1ll*fact[i-1]*i%P,invp[i]=1ll*(P-P/i)*invp[P%i]%P,invf[i]=1ll*invf[i-1]*invp[i]%P;
	for(int i=1;i<=n;i++)f[i].resize(n/i+1),L[i].resize(n/i+1);
	for(int i=1;i<=n;i++)f[1][i]=1,L[i][0]=1;
	for(int i=1;i<=n;i++)h[i].resize(n/i+1);
	for(int i=1;i<=n;h[i]=ln(h[i]),i++)
		for(int j=0;i*j<=n;j++)h[i][j]=qpow(invf[j],1ll*i*k%(P-1));
	for(int x=1;x<=n;x++){
		for(int i=1;i*x<=n;i++)f[x][i]=1ll*L[i][x-1]*qpow(x,1ll*(P-1-i)*k%(P-1))%P;
		for(int i=1,lim,lim2;i*x<=n;i++){
			vector<int> tmp((lim=n/(i*x))+1,0),tl((lim2=n/i)+1,0);
			for(int p=1;p<=lim;p++)tmp[p]=1ll*h[i][p]*f[x][i*p]%P;
			tmp=exp(tmp);
			for(int p=0;p<=lim;p++)
				for(int j=0;j<=lim2;j++)
					if(x*p+j<=lim2)tl[x*p+j]=add(tl[x*p+j],1ll*tmp[p]*L[i][j]%P);
			L[i]=tl;
		}
	}
	printf("%lld\n",1ll*qpow(n,k)*f[n][1]%P);
	return 0;
}
```

---

## 作者：Aleph1022 (赞：10)

本文同步发表于我的博客：<https://www.alpha1022.me/articles/loj-2528.htm>。

stO EI Orz！  
stO xYx Orz！

令无标号有根树构成的组合类为 $\mathcal T$，令其中的一个组合对象 $\tau$ 作为等价类的大小为 $s(\tau)$，那么题意即是求
$$
\sum\limits_{\tau \in \mathcal T} s^k(t)
$$

考虑两个等价类的笛卡尔积 $\tau_1 \times \tau_2$，则显然 $|\tau_1 \times \tau_2| = |\tau_1| + |\tau_2|$ 且 $s(\tau_1 \times \tau_2) = \binom{|\tau_1|+|\tau_2|}{|\tau_1|} s(\tau_1) s(\tau_2)$。  
因此考虑 GF
$$
T(\mathcal T;x) = \sum\limits_{\tau \in \mathcal T} \frac{s^k(\tau) x^{|\tau|}}{|\tau|!^k}
$$

其线性及积性均容易验证。

考虑分析 $\mathcal T$ 的结构，这意味着我们需要考虑去除根再把剩下的部分视作 ${\rm MSET}(\mathcal T)$。

注意这里我和 xyx 和 cmd 都犯过同一个错误：此处附加的因子 $\frac1{|\tau|^k}$ 和本身的等价类大小并不能简单地通过经典的 MSET 构造结合。  
因此结合无标号计数中的 MSET 构造和有标号计数中的 SET 构造，此处所应当使用的 MSET 构造应当形如
$$
T({\rm MSET}(\mathcal T)) = \prod\limits_{\tau \in \mathcal T} \sum\limits_{i\ge 0} \frac{s^{ik}(\tau) x^{i|\tau|}}{|\tau|^{ik} (i!)^k}
$$

说到底，我们不能混淆组合对象的大小函数和等价类大小以及附加因子的关系。

记 $\mathop{\rm xexp}x$ 为
$$
\sum\limits_{i\ge 0} \frac{x^i}{(i!)^k}
$$

从而我们的 MSET 即为
$$
\prod\limits_{\tau \in \mathcal T} \mathop{\rm xexp}T(\tau)
$$

可是 $\mathop{\rm xexp}$ 并不保有线性到积性，因此不能像熟知的 $\exp$ 一般直接写作 $\exp T$。  
考虑直接使用 ln / exp 推导
$$
\exp \sum\limits_{\tau \in \mathcal T} \ln \circ \mathop{\rm xexp} T(\tau)
$$

不过这样还是没有什么卵用。  
考虑维护更多的信息，加入一元 $u$：
$$
T(\mathcal T;x,u) = \sum\limits_{\tau \in \mathcal T}  x^{|\tau|}\frac1{1-u\frac{s(\tau)}{|\tau|!}}
$$

则乘法改为 $x$ 元上的卷积，$u$ 元上的点乘。  
模仿原来的结果考虑重新定义 ${\rm MSET}$，则
$$
[u^k] \mathop{\rm xexp} T(\tau) = \sum\limits_{i \ge 0} \frac{s^{ik}(\tau) x^{|\tau|i}}{(|\tau|!)^{ik} (i!)^k}
$$

令
$$
F(x) = \ln \sum\limits_{i\ge 0} \frac{x^i}{(i!)^k}
$$

那么
$$
[u^k] \ln \circ \mathop{\rm xexp}T(\mathcal \tau) = F\left(\frac{s^k(\tau) x^{|\tau|}}{(|\tau|!)^k}\right)
$$

于是
$$
\begin{aligned}
\sum\limits_{\tau \in \mathcal T} \ln \circ \mathop{\rm xexp} T(\tau)
&= \sum\limits_{\tau \in \mathcal T} F\left(\frac{s^k(\tau) x^{|\tau|}}{(|\tau|!)^k}\right) \\
&= \sum\limits_{\tau \in \mathcal T} \sum\limits_{i\ge 1} f_i \left(\frac{s^k(\tau) x^{|\tau|}}{(|\tau|!)^k}\right)^i \\
&= \sum\limits_{i\ge 1} f_i \sum\limits_{\tau \in \mathcal T} \left(\frac{s^k(\tau) x^{|\tau|}}{(|\tau|!)^k}\right)^i \\
&= \sum\limits_{i\ge 1} f_i \sum\limits_{\tau \in \mathcal T} \frac{s^{ik}(\tau) x^{|\tau|i}}{(|\tau|!)^{ik}} \\
&= \sum\limits_{i\ge 1} f_i [u^{ik}] T(\mathcal T; x^i)
\end{aligned}
$$

因此
$$
{\rm DEL}(\mathcal T) = {\rm MSET}(\mathcal T)
$$

于是
$$
T' = \exp \sum\limits_{i\ge 1} f_i [u^{ik}] T(\mathcal T; x^i)
$$

（这个求导是一个形式化的记号，代表去除根，但并不符合真正的求导意义。）

关于这个怎么处理，考虑到
$$
\ln T' - [u^k] T = \sum\limits_{i\ge 2} f_i [u^{ik}] T(\mathcal T; x^i)
$$

那么我们从大的 $u$ 指标推到小的 $u$ 指标，并且有用的 $u$ 指标只有 $k$ 的不超过 $nk$ 的倍数。  
当进入一个新的 $k$，使用 $O(n^2)$ 的 ln 计算出 $F$，从而右式是容易直接调和级数复杂度处理的。  
剩下的问题在于左式的处理，不过推出 $O(n^2)$ 半在线的 exp 的式子之后会发现这同时也是容易半在线处理的。

处理左式和 $F$ 的复杂度为
$$
\sum\limits_{k=1}^n O\left(\frac{n^2}{k^2}\right) = O(n^2)
$$

这是著名的巴塞尔问题。

处理右式的复杂度为
$$
\sum\limits_{k=1}^n O\left(\frac nk \log \frac nk\right) = O(n \log^2 n)
$$

因此总复杂度为 $O(n^2)$。

代码：
```cpp
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
const int N = 2e3;
int n,k,mod;
inline int fpow(int a,int b)
{
	int ret = 1;
	for(;b;b >>= 1)
		(b & 1) && (ret = (long long)ret * a % mod),a = (long long)a * a % mod;
	return ret;
}
int inv[N + 5];
int pw[N + 5][N + 5],ipw[N + 5][N + 5];
int f[N + 5],g[N + 5];
int t[N + 5][N + 5],c[N + 5][N + 5];
int ans;
vector<int> d[N + 5];
int main()
{
	scanf("%d%d%d",&n,&k,&mod),inv[1] = 1;
	for(register int i = 2;i <= n;++i)
		inv[i] = (long long)(mod - mod / i) * inv[mod % i] % mod;
	for(register int i = 1;i <= n;++i)
		pw[1][i] = fpow(i,k),ipw[1][i] = fpow(pw[1][i],mod - 2);
	for(register int u = 2;u <= n;++u)
		for(register int i = 1;i <= n / u;++i)
			pw[u][i] = (long long)pw[u - 1][i] * pw[1][i] % mod,
			ipw[u][i] = (long long)ipw[u - 1][i] * ipw[1][i] % mod;
	for(register int i = 2;i <= n;++i)
		for(register int j = i;j <= n;j += i)
			d[j].push_back(i);
	for(register int u = n;u;--u)
	{
		g[0] = 1;
		for(register int i = 1;i <= n / u;++i)
			g[i] = (long long)g[i - 1] * ipw[u][i] % mod;
		for(register int i = 1;i <= n / u;++i)
		{
			f[i] = (long long)i * g[i] % mod;
			for(register int j = 0;j <= i - 2;++j)
				f[i] = (f[i] - (long long)(j + 1) * f[j + 1] % mod * g[i - j - 1] % mod + mod) % mod;
			f[i] = (long long)f[i] * inv[i] % mod;
		}
		for(register int i = 1;i <= n / u;++i)
			for(int j : d[i])
			    c[u][i] = (c[u][i] + (long long)f[j] * t[u * j][i / j]) % mod;
		t[u][1] = 1;
		for(register int i = 1;i < n / u;++i)
		{
			for(register int j = 0;j <= i - 1;++j)
				t[u][i + 1] = (t[u][i + 1] + (long long)(j + 1) * (t[u][j + 1] + c[u][j + 1]) % mod * pw[u][i - j] % mod * t[u][i - j]) % mod;
			t[u][i + 1] = (long long)t[u][i + 1] * inv[i] % mod * ipw[u][i + 1] % mod;
		}
	}
	ans = (long long)t[1][n] * fpow(n,k) % mod;
	printf("%d\n",ans);
}
```

---

## 作者：Fuyuki (赞：7)

设$f(i,j)$表示大小为$i$的树，每种同构方案（即等价类）大小的$jk$次方之和，答案为$f(n,1)$。

考虑使用类似背包的思路进行计算，设$tmp(i,j,p)$表示用大小不超过$i$的子树拼出大小为$p$的树，每种等价类大小的$jk$次方之和：
$$tmp(i,j,p)=\sum_{i\times u+t=p}tmp(i-1,j,t)g(i,j,u)\binom{p}{i\times u}^{jk}$$

$$f(i,j)=tmp(i-1,j,i-1),tmp(1,...,...)=1$$

其中$g(v,j,u)$表示选择选择$u$棵大小$v$的树的等价类大小的$jk$次方之和。

假设选择的时候一共选择了$m$种不同的等价类，第$i$种等价类选择了$a_i$个。

一组整数拆分$\{a_1,a_2,...,a_m\}$就可以描述一个选择$v$棵树等价类，这个等价类的权值为$\prod \frac{1}{(a_i!)^k}$，即最后会除掉的出现次数的$k$次幂。

设集合$X$，每个元素表示一种“有序选择$v$棵大小为$u$的树，并一共有$m$种不同的等价类”的方案。

对于$x\in X$，定义$w(x)=\prod_{i=1}^{m} f(u,a_ij)$。

令置换群$G$表示所有长度为$m$的置换，将置换群$G$作用于$X$上。

因为等价可以被描述为整数拆分$\{a_1,a_2,...,a_m\}$，所以对于$x\in{X}$，其轨道内的所有元素的权值也全部等于$w(x)$。

那么假设一共有$l$种不同的等价类：

$$g(v,j,u)=v!\sum_{i=1}^{l}w(E_i)\prod_{i=1}^{m}\frac{1}{(a_i!)^k}$$

因为轨道内的元素权值相等，对应的稳定化子也相同，所以之后不会被等价类和元素的权值进行区分。

计算等价类的权值和可以直接套$burnside$引理，但是因为后面多了一些奇怪的权值，所以需要将$burnside$引理的加权形式再魔改一下：

假设能够构造置换的权值函数$h$使对与任意$x\in{X}$满足：

$$|Orbit(x)|h(stab(x))=\prod_{i=1}^{m}\frac{1}{(a_i!)^k}$$

这里的$h(stab(x))$表示的就是$x$的稳定化子内所有置换的权值之和。

$$\sum_{p\in{G}}w(fix(p))h(p)$$

$$=\sum_{x\in{X}}w(x)h(stab(x))$$

$$=\sum_{i=1}^{l}\sum_{x\in{E_i}}h(stab(x))w(x)$$

$$=\sum_{i=1}^{l}|E_i|h(stab(E_i))w(E_i)$$

$$=\sum_{i=1}^{l}w(E_i)\prod_{j=1}^{m}\frac{1}{(a_j!)^k}$$

那么只需要计算出置换的权值就可以了，而因为将置换分解成循环之后各个循环是独立的，所以只需要构造出合适的循环权值即可。

假设大小为$i$的循环的权值在$jk$次幂下为$val(i,j)$，又因为不动点内方案的权值被描述为可以在循环拆分下计算，所以假设置换可以拆分成$\prod(i)^{b_i}(\sum b_i=m)$：

$$w(fix(p))h(p)=\prod_{i=1}^{m}val(i,j)\frac{f(u,b_ij)}{(u!)^{b_ijk}}$$

注意这里的连乘实际上描述了所有“有序”的，可以分解成$\{a_1,a_2,...,a_m\}$的方案（因为$a$的分解不会超出$b$），这刚好符合原本对方案的定义以及不动点的定义。并且就算出现了相同子树，即存在$a_i,a_j(i\neq j)$代表的方案同构，表现出来也是指数的相加，这在连乘的意义下也被很好地描述了。最后除去的阶乘是因为$f$中记录的方案考虑了标号分配的情况，而这里乘起来的时候不能考虑。

接下来计算循环的权值，考虑一种方案$x$，其内部所有的树都是同构的，那么轨道大小为$1$并且所有置换都属于其稳定化子：

$${|Orbit(x)|h(stab(x))}=\sum_{p\in{G}}h(p)=\frac{1}{(m!)^{jk}}$$
而所有置换的权值和又可以通过循环的无序拼接来描述，所以：

$$\sum_{\sum ib_i=m}\prod_{i=1}^{m}\frac{val(i,j)^{b_i}}{i^{b_i}b_i!}=\frac{1}{(m!)^{jk}}$$

上式没有对“置换的长度为$m$”的限制，也就是说可以推广到不等于$m$的情况：

$$\sum_{\sum ib_i=d}\prod_{i=1}^{d}\frac{val(i,j)^{b_i}}{i^{b_i}b_i!}=\frac{1}{(d!)^{jk}}$$

将$d=1$代入可得$val(1,j)=1$，并且只要知道了$val(1,j),val(2,j),...val(i-1,j)$，就可以通过背包容斥出$val(i,j)$。

知道了单个循环的权值之后，就可以去计算所有等价类的权值和了：

$$g(v,j,u)=(uv!)^{jk}\sum_{\sum ib_i=v}\frac{(val(i,j)f(u,ij))^{b_i}}{i^{b_i}b_i!(u!)^{ijkb_i}}$$

乘上的阶乘是因为最后会重新分配标号。这整个式子也是可以用背包进行计算的。

至于总复杂度，如果暴力实现上述过程的话复杂度是$O(n^3logn)$的，但是注意到对于所有二元状态$(i,j)$，能对答案状态$(n,1)$产生贡献当且仅当$ij\leq n$，所以在背包的时候不需要全部计算，所以总复杂度为：

$$\sum_{i=1}^{n}O(n^2/i)=O(n^2logn)$$

当然，你也有可能觉得一大堆阶乘很烦，于是像官方题解一样用紫妈写，就是给$f(i,j)$乘上$\frac{1}{(i!)^{jk}}$，那么写起来会有趣不少。

根据上面的式子，所有对循环在整个置换群中分布情况的描述都酷似$\exp$的定义，也就是说两个背包的计算都是可以使用多项式$\ln$和$\exp$进行优化的。当然这也体现了多项式$\ln$和$\exp$的组合意义，在紫妈之下可以表示成元素与组合关系的转化。

至于任意模数下的多项式操作除了拿$MTT$或暴力去改造之外，也可以使用下面的$O(n^2)\ln,\exp$（毕竟复杂度瓶颈不在这里）。

（毕竟多项式的组合意义比起背包的组合意义更加简洁）

多项式$\ln$：

$$G(x)=\frac{F'(x)}{F(x)}$$

$$G(x)=F'(x)-(F(x)-1)G(x)$$

$$g_n=f_{n+1}*(n+1)-\sum_{i=0}^{n-1}f_{n-i}g_i$$

$$\ln F(x)=\int G(x)dx$$

多项式$\exp$：

$$G(x)=\exp(F(x))$$

$$\ln G(x)=F(x)$$

$$\frac{G'(x)}{G(x)}=F'(x)$$

$$xG'(x)=xG(x)F'(x)$$

$$g_0=1,g_n=\frac{1}{n}\sum_{i=1}^{n}if_ig_{n-i}$$

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define rnt re int
#define re register
#define I inline int
#define V inline void
#define ll long long int
#define FOR(i,a,b) for(rnt i=a;i<=b;i++)
#define ROF(i,a,b) for(rnt i=a;i>=b;i--)
const int N=2e3+1;
int n,t,mod;
int tmp1[N],tmp2[N];
int f[N][N],tmp[N][N],val[N][N];
int fac[N],fac_inv[N],inv[N],inv_pow[N];
I Pow(ll t,int x){
	ll s=1;
	while(x){
		if(x&1)s=s*t%mod;
		x>>=1,t=t*t%mod;
	}
	return s;
}
V input(){cin>>n>>t>>mod;}
V Ln(const int*a,int*b,int len){
	FOR(i,0,len-1){
		b[i]=1ll*a[i+1]*(i+1)%mod;
		FOR(j,0,i-1)b[i]=(mod-1ll*a[i-j]*b[j]%mod+b[i])%mod;
	}
	ROF(i,len,1)b[i]=1ll*inv[i]*b[i-1]%mod;b[0]=0;
}
V exp(int*a,int*b,int len){
	b[0]=1;
	FOR(i,1,len)a[i]=1ll*a[i]*i%mod;
	FOR(i,1,len){
		b[i]=0;
		FOR(j,1,i)b[i]=(1ll*a[j]*b[i-j]+b[i])%mod;
		b[i]=1ll*b[i]*inv[i]%mod;
	}
	FOR(i,1,len)a[i]=1ll*a[i]*inv[i]%mod;
}
V init(){
	fac[0]=fac_inv[0]=inv[0]=tmp2[0]=1;
	FOR(i,1,n)fac[i]=1ll*fac[i-1]*i%mod,fac_inv[i]=Pow(fac[i],mod-2);
	FOR(i,1,n)inv[i]=1ll*fac_inv[i]*fac[i-1]%mod,inv_pow[i]=Pow(inv[i],t);
	FOR(i,1,n)f[1][i]=1,tmp1[i]=1;
	FOR(i,1,n){
		FOR(j,1,n)tmp1[j]=1ll*tmp1[j]*inv_pow[j]%mod,tmp2[j]=1ll*tmp2[j-1]*tmp1[j]%mod;
		Ln(tmp2,val[i],n/i),memcpy(tmp[i],tmp2,n+1<<2);
	}
}
V work(){
	FOR(i,2,n){
		rnt now=1;
		FOR(j,1,n/i)now=1ll*now*inv_pow[i]%mod,f[i][j]=1ll*tmp[j][i-1]*now%mod;
		FOR(j,1,n/i){
			FOR(k,1,n/i/j)tmp1[k]=1ll*val[j][k]*f[i][j*k]%mod;
			exp(tmp1,tmp2,n/i/j);
			ROF(k,n/j,1)FOR(p,1,k/i)
				tmp[j][k]=(1ll*tmp[j][k-p*i]*tmp2[p]+tmp[j][k])%mod;
		}
	}
	cout<<1ll*f[n][1]*Pow(n,t)%mod;
}
int main(){
	input();
	init();
	work();
	return 0;
}
```



---

## 作者：GK0328 (赞：6)

#### [我的博客](https://www.cnblogs.com/GK0328/p/14358348.html)

### $dp,$群论

#### 题意简述：求$k(k \le 10^9)$棵大小为$n(n \le 2000)$的随机有根树（根为$1$，生成方式为每个节点$i(i>1)$随机认$[1,i)$中一个节点作为祖先）两两同构的概率。

#### $Part 1$

我们先考虑答案是什么？

先计算总方案数，根据树的生成方式，总共有$(n-1)!$种不同的树，那么总方案数自然而然就是$[(n-1)!]^k$。

我们将大小为$n$的树按照同构的原则划分成一些等价类，对于一种等价类，我们设其大小为$sz_i$。

最终树的形态属于其中一个等价类。

那么本题的答案就是：

$$
\frac{1}{[(n-1)!]^k} \sum_i sz_i^k
$$

#### $Part 2$

设计一个$DP$，令$dp(i,j)$表示一个大小为$i$的树，其所有等价类大小的$jk$次方的和（没看错，$jk$就是$j$乘$k$）。

那么答案就是$dp(n,1)$。

为了维护转移，我们必然需要让$dp(i,j)$值从更小的树转移过来。

将根节点去掉，其子树构成一片大小为$i-1$的森林。

然而我们极度缺乏信息，所有子树构成一个集合，而元素间没有顺序关系。我们根本不知道有多少树，哪些树是同构的，难以转移。

不过我们可以分析的一点是，两两同构的子树容易导致重复的计算。

首先，同构的子树，大小必然相等。我们根据子树大小把原问题继续拆分，设$tmp(p,j,t)$表示大小为$t$的森林，每棵树大小不超过$p$，其等价类大小的$jk$次方和，边界条件$tmp(1,j,t)=1$。

设$f(p,i,j)$表示$i$棵大小为$p$的树组成的森林的等价类大小的$jk$次方和。

枚举大小为$i$的树的个数进行转移。

$$
dp(i,j)=tmp(i-1,j,i-1)
$$
$$
tmp(p,j,t)=\sum_{zp+v=t} tmp(p-1,j,v)f(p,z,j){t \choose zp}^{jk}
$$

上面的式子应该不必多解释了吧。

现在问题的核心转移到了求解$f(p,i,j)$。

怎么办呢？

#### $Part 3$

重新回顾$f(p,i,j)$的定义：$f(p,i,j)$表示$i$棵大小为$p$的树组成的森林的等价类大小的$jk$次方和。

大小为$p$的树可以划分为一些等价类，我们为这些等价类标号，那么对于这一片森林来讲，我们先定义一个$\{ x \}$，表示总共$i$棵树，它们属于的等价类的标号组成的可重集，它可以转化为一个数列$\{ a_1,a_2,\cdots,a_m\}$（总共有$m$个等价类），$a_i$表示第$i$种树的个数，数列$\{ x \}$或$\{ a \}$可确定一个森林类型。

由于$f(p,i,j)$维护的是森林，所以它是**无序**的，这里的无序是指**树之间**没有偏序关系，而**点之间**依然是有的（也就是**有标号**）。

现在我们再次给出一个定义$f(\{ a \})$，表示在**有序**（各棵树之间的顺序）的情况下，类型为$\{ a \}$的森林的方案数。

得到等式：

$$
f(p,i,j)=\sum_{ \{ a \} } {ip \choose p,p,p,\cdots,p}^{jk}f( \{ a \}) \prod_t \frac{1}{a_t!^{jk}}
$$
$$
=\frac{(ip!)^{jk}}{(p!)^{ijk}}\sum_{ \{ a \} } f( \{ a \}) \prod_t \frac{1}{a_t!^{jk}}
$$

到现在为止，$\{ a \}$对我们来说仍然是一个确定的数列，我们下一步就是让数列$\{ a \}$抽象化，使其适用的范围扩大。

其实上面的式子已经为我们指出了一条路径$\prod_t \frac{1}{a_t!}$明显与数组内数的顺序无关，于是我们得到一个想法：把数列$\{ a \}$变为可重集$\{ c \}$。

本质上，$\{ c \}$就是一个元素个数的可重集，也就是对原森林计算每个等价类的个数，这些数组成的可重集。在这个可重集中，每个数对应的树的类型都是不确定的。当然，也可以认为$\{ c \}$是一个有序序列，其中的数代表一个类型树的个数，而到底是什么类型的树我们还没有确定，上面的$\{ x \}$也可以当成有序序列来看（注：以下$\{ x \},\{ a \},\{ c \}$同时出现均代表同一片森林）。

同样给出定义，$h(\{ c \})$表示在**有序**的情况下，元素个数的可重集为$\{ c \}$的树的方案数。

$$
f(p,i,j)=\frac{(ip!)^{jk}}{(p!)^{ijk}} \sum_{ \{ c \} } h( \{ c \}) \prod_t \frac{1}{c_t!^{jk}}
$$

再来一个定义：

$$
w(\{ c \})=\prod_t dp(p,c_tj)
$$

由于这里所有的一切都是在$f(p,i,j)$的计算这个子问题下进行的，所以上式中的$p,j$与$f(p,i,j)$中的$p,j$意义相同。

也就是我们为可重集$\{ c \}$中每一种元素钦定一棵树计算答案，但是$h(\{ c \}) \ne w(\{ c \})$，原因在于$h$的计算中必须满足每个树对应的树的类型互不相同，而$w$的计算中没有这个限制。

我们需要利用群论利用$w(\{ c \})$解决$h(\{ c \})$的计算。

#### $Part 4$

我们首先必须明确的是，这里的置换群是什么，还有一个重要的点就是判断两个可重集$\{ x \}$本质不同的标准。需要注意的一点是，这里的群，并没有直接**作用**在可重集$\{ x \}$上，它只是一个计数工具。

**1.群、置换**：这里的置换就是普通的置换，即从一个排列置换到另一个排列，排列大小为树的个数$i$，想必大家对这个群已经十分熟悉了。

**2.等价标准**：每个$\{ x \}$都会对应一个$\{ c \}$（经过上面$\{ x \} \rightarrow \{ a \} \rightarrow \{ c \}$的转换），如果$\{ x_1 \},\{ x_2 \}$对应$\{ c_1 \},\{ c_2 \}$相等，那么$\{ x_1 \},\{ x_2 \}$等价。这里的等价类与树的等价类是两种不同的体系，不要搞混。

设元素$\{ x \}$的等价类大小为$Tr(\{ x \})$。

$$
f(p,i,j)=\frac{(ip!)^{jk}}{(p!)^{ijk}} \sum_{ \{ c \} } h( \{ c \}) \prod_t \frac{1}{c_t!^{jk}}
$$
$$
=\frac{(ip!)^{jk}}{(p!)^{ijk}}\sum_{ \{ x \} \in X} \left ( \prod_t \frac{1}{c_t!^{jk}} \right) \frac{h(\{ c \})}{|Tr(\{ x \})|}
$$

相当于每种等价类中的$\{ x \}$都计算一遍，每次的权重都是$\frac{1}{|Tr(\{ x \})|}$，所以上式成立。

我们试图将$\{ x \}$与置换建立联系，对于$s$个相同的元素（把一堆相同元素拆成好几份也是合法的），我们对应到一个排列上的一个大小为$s$的循环，如果$\{ x \}$可以通过上述的对应关系对应到一个置换$G_0$，那么我们称$\{ x \}$为置换$G_0$上的不动点，$G_0$的不动点集合为$fix(G_0)$。

按照$\operatorname{Pólya}$ 定理的方式，我们把置换$T$拆分成循环的形式，用数列$\{ D_T \}$表示，其中的数代表一个循环的大小。

考虑$fix(T)$中的元素，举个例子：

$T$中有一个循环的大小为$3$，那么$\{ x \}$中对应的可以是$3$个相同的元素，也可以是$5$个相同元素中拆出$3+2$进行匹配。

也就是$fix(T)$可以兼容两堆树相同的情况，于是：
$$
\sum_{\{ x \} \in fix(T)} h(\{ c \})=\prod_i dp(p,D_{T_i}j) 
$$

#### $Part 5$

一些奇怪的操作来了。

让置换带上权$V$，试图去拟合求解的值。

$$
\sum_{T \in G} V_T \sum_{\{ x \} \in fix(T)} h(\{ c \})
$$
$$
=\sum_{\{ x \} \in X} h(\{ c \}) \sum_{\{ x \} \in fix(T)} V_T
$$
$$
=\sum_{\{ x \} \in X} \left ( \prod_t \frac{1}{c_t!^{jk}} \right) \frac{h(\{ c \})}{|Tr(\{ x \})|}
$$
$$
\sum_{\{ x \} \in fix(T)} V_T=\left ( \prod_t \frac{1}{c_t!^{jk}} \right) \frac{1}{|Tr(\{ x \})|}
$$

为方便运算，添加一个常数$C$。

$$
\sum_{\{ x \} \in fix(T)} V_T=\left ( \prod_t \frac{1}{c_t!^{jk}} \right) \frac{C}{|Tr(\{ x \})|}
$$

等式右边存在连乘式，设：

$$
V_T=\prod_t Q(D_{T_t})
$$

$$
\sum_{\{ x \} \in fix(T)} \prod_t Q(c_t)=\left ( \prod_t \frac{1}{c_t!^{jk}} \right) \frac{C}{|Tr(\{ x \})|}
$$

对等式两边分开来推导。

$$
|Tr(x)|=\frac{i!}{\prod_t c_t!}
$$
$$
Right=C \left ( \prod_t \frac{1}{c_t!^{jk}} \frac{1}{{i \choose c_1,c_2,\cdots}} \right)
$$
$$
=\frac{C}{i!} \prod_s c_s! \left ( \prod_t \frac{1}{c_t!^{jk}} \right) 
$$

把左边的$\{ x \} \in fix(T)$拆开，我们主要考虑满足条件的$T$到底是什么。由置换圈定$\{ x \}$，与从$\{ x \}$圈定置换的方式恰好相反，也就是$\{ x \}$中的$3$可以用可以用置换中的$1+2$对应，本质上是对$\{ x \}$中每个数的整数拆分，但是拆分之后还需要对于每个拆分的部分进行圆排列。

$$
Left=\sum_{\{ x \} \in fix(T)} \prod_t Q(c_t)
$$
$$
=\prod_t \sum_{(\sum_{r=1}^{nr} e_r)=c_t} \frac{1}{nr!} {c_t \choose e_1,e_2,\cdots,c_{nr}} \left ( \prod_q (e_q-1)! \right ) \prod_q Q(e_q)
$$
$$
=\left ( \prod_s c_s! \right )  \sum_{(\sum_{r=1}^{nr} e_r)=c_t} \frac{1}{nr!} \prod_q \frac{Q(e_q)}{e_q}
$$

经典的集合划分问题。

设：

$$
F(x)=\sum_{i=1}^{\infty} \frac{Q(i)}{i} x^i
$$

$$
Left=\left ( \prod_s c_s! \right ) \prod_t [x^{c_t}]e^{F(x)}
$$
$$
=\frac{C}{i!} \prod_s c_s! \left ( \prod_t \frac{1}{c_t!^{jk}} \right) 
$$
$$
\prod_t [x^{c_t}]e^{F(x)}=\frac{C}{i!} \left ( \prod_t \frac{1}{c_t!^{jk}} \right)
$$

令$C=i!$。

$$
\prod_t [x^{c_t}]e^{F(x)}=\prod_t \frac{1}{c_t!^{jk}}
$$
$$
[x^t]e^{F(x)}=\frac{1}{t^{jk}}
$$

设$F_0(x)=\sum_{i=0}^{\infty} \frac{1}{i^{jk}}$。

$$
F(x)=\ln F_0(x)
$$

于是我们直接把所有$Q(t)$的值算出来了。

回到原问题，求解$\sum_{\{ x \} \in X} \left ( \prod_t \frac{1}{c_t!^{jk}} \right) \frac{h(\{ c \})}{|Tr(\{ x \})|}$。

$$
\sum_{\{ x \} \in X} \left ( \prod_t \frac{1}{c_t!^{jk}} \right) \frac{h(\{ c \})}{|Tr(\{ x \})|}
$$
$$
=\frac{1}{C} \sum_{T \in G} V_T \sum_{\{ x \} \in fix(T)} h(\{ c \})
$$
$$
=\frac{1}{C} \sum_{T \in G} \prod_t Q(c_t) dp(p,c_tj) 
$$

把$T \in G$拆开，把置换拆成多个循环的过程，也是整数拆分和圆排列的结合。

$$
\frac{1}{C} \sum_{T \in G} \prod_t Q(c_t) dp(p,c_tj) 
$$
$$
=\frac{1}{C} \sum_{(\sum_{r=1}^{nr} e_r)=i} \frac{1}{nr!} {i \choose e_1,e_2,\cdots,e_{nr}} \left ( \prod_q (e_q-1)! \right ) \prod_q Q(e_q)dp(p,e_qj)
$$
$$
=\frac{1}{C} i! \sum_{(\sum_{r=1}^{nr} e_r)=i} \frac{1}{nr!} \prod_q \frac{Q(e_q)dp(p,e_qj)}{e_q}
$$
$$
=\sum_{(\sum_{r=1}^{nr} e_r)=i} \frac{1}{nr!} \prod_q \frac{Q(e_q)dp(p,e_qj)}{e_q}
$$

设$G(x)=\sum_{i=1}^{\infty} \frac{Q(i)dp(p,ij)}{i} x^i$。

$$
\sum_{(\sum_{r=1}^{nr} e_r)=i} \frac{1}{nr!} \prod_q \frac{Q(e_q)dp(p,e_qj)}{e_q}
$$
$$
=[x^i] e^{G(x)} 
$$

$$
f(p,i,j)=\frac{(ip!)^{jk}}{(p!)^{ijk}}\sum_{ \{ x \} \in X} \left ( \prod_t \frac{1}{c_t!^{jk}} \right) \frac{h(\{ c \})}{|Tr(\{ x \})|}
$$
$$
=\frac{(ip!)^{jk}}{(p!)^{ijk}} [x^i] e^{G(x)} 
$$

$f(p,i,j)$终于算完了。。。

#### $Part 6$

模数不一定是$NTT$模数，$\ln$和$\exp$总不能$MTT$吧（害怕）。

$\ln$：

$$
G(x)=(\ln F(x))'
$$
$$
=\frac{F'(x)}{F(x)}
$$
$$
=F'(x)-(F(x)-1)G(x)
$$
$$
g_n=(n+1)f_{n+1}-\sum_{i=0}^{n-1} f_{n-i} g_{i}
$$
$$
\ln F(x)=\int G(x) dx
$$

$\exp$：

$$
G(x)=\exp(F(x))
$$
$$
\ln G(x)=F(x)
$$
$$
\frac{G'(x)}{G(x)}=F'(x)
$$
$$
G'(x)=G(x)F'(x)
$$
$$
g_0=1,g_n=\frac{1}{n}\sum_{i=1}^n if_ig_{n-i}
$$

#### $Part 7$

$DP$的过程为互相更新，更新顺序为$dp \rightarrow f \rightarrow tmp \rightarrow dp \rightarrow \cdots$。

$DP$时间复杂度：

$$
\sum_{p=1}^n \sum_{j=1}^{\frac{n}{p}} \sum_{i=1}^{\frac{n}{j}} \frac{i}{p}
$$
$$
=\sum_{j=1}^n \sum_{i=1}^{\frac{n}{j}} \sum_{p=1}^{\frac{n}{j}} \frac{i}{p}
$$
$$
\approx \sum_{j=1}^n \sum_{i=1}^{\frac{n}{j}} i \log i
$$
$$
=\sum_{i=1}^n i \log i \frac{n}{i}
$$
$$
=\sum_{i=1}^n n \log i
$$
$$
=O(n^2 \log n)
$$

枚举$j$，可以在$\sum_{i=1}^n \frac{n^2}{i^2}=O(n^2)$时间完成所有$\ln$的预处理。

$\exp$的复杂度：$\sum_{i=1}^n \sum_{j=1}^{\frac{n}{i}} \frac{n^2}{(ij)^2}=O(n^2)$。

总时间复杂度：$O(n^2 \log n)$。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define N 2005
#define ll long long
using namespace std;
int n,k,mp;
int inv[N],fac[N],infac[N],kfac[N][N],kinfac[N][N];
int L[N][N],dp[N][N],f[N][N],tmp[N][N];
int ans,Q[N],g[N];
int r[N],cr[N];
void Add(int &x,int y)
{
    x=(x+y)%mp;
}
void Del(int &x,int y)
{
    x=(x-y)%mp;
}
void Mul(int &x,int y)
{
    x=(ll)x*y%mp;
}
int add(int x,int y)
{
    return (x+y)%mp;
}
int del(int x,int y)
{
    return (x-y)%mp;
}
int mul(int x,int y)
{
    return (ll)x*y%mp;
}
int ksm(int x,int y)
{
    int ans=1;
    while (y)
    {
        if (y & 1)
            Mul(ans,x);
        Mul(x,x);
        y >>=1;
    }
    return ans;
}
int C_j(int n,int k,int j)
{
    if (n<k)
        return 0;
    return mul(kfac[n][j],mul(kinfac[k][j],kinfac[n-k][j]));
}
void InvDev(int *a,int *b,int n)
{
    b[0]=0;
    for (int i=1;i<=n;++i)
        b[i]=mul(inv[i],a[i-1]);
    b[n+1]=0;
}
void GetLn(int *f,int *g,int n)
{
    f[n+1]=0;
    for (int i=0;i<n;++i)
    {
        cr[i]=mul(i+1,f[i+1]);
        for (int j=0;j<i;++j)
            Del(cr[i],mul(f[i-j],cr[j]));
    }
    InvDev(cr,g,n);
}
void GetExp(int *f,int *g,int n)
{
    g[0]=1;
    for (int i=1;i<=n;++i)
    {
        g[i]=0;
        for (int j=1;j<=i;++j)
            Add(g[i],mul(mul(j,f[j]),g[i-j]));
        Mul(g[i],inv[i]);
    }
}
int main()
{
    scanf("%d%d%d",&n,&k,&mp);
    inv[1]=fac[0]=fac[1]=infac[0]=infac[1]=1;
    for (int i=2;i<=n+2;++i)
        inv[i]=mul(mp-mp/i,inv[mp%i]),fac[i]=mul(fac[i-1],i),infac[i]=mul(infac[i-1],inv[i]);
    for (int i=0;i<=n+2;++i)
        kfac[i][1]=ksm(fac[i],k),kinfac[i][1]=ksm(infac[i],k);
    for (int i=0;i<=n+2;++i)
        for (int j=2;j<=n;++j)
            kfac[i][j]=mul(kfac[i][j-1],kfac[i][1]),kinfac[i][j]=mul(kinfac[i][j-1],kinfac[i][1]);
    for (int j=1;j<=n;++j)
    {
        for (int i=0;i<=n/j;++i)
            r[i]=kinfac[i][j];
        GetLn(r,L[j],n/j);
    }
    for (int i=1;i<=n;++i)
        dp[1][i]=1;
    for (int j=1;j<=n;++j)
        for (int i=0;i<=n/j;++i)
            tmp[i][j]=1;
    for (int p=2;p<=n;++p)
    {
        for (int j=1;j<=n/p;++j)
            dp[p][j]=tmp[p-1][j];
        for (int j=1;j<=n/p;++j)
        {
            int cnt=n/p/j,sz=n/j;
            for (int i=0;i<=cnt;++i)
                Q[i]=L[j][i];
            for (int i=1;i<=cnt;++i)
                g[i]=mul(Q[i],dp[p][i*j]);
            GetExp(g,r,cnt);
            for (int i=1;i<=cnt;++i)
                f[i][j]=mul(mul(kfac[i*p][j],kinfac[p][i*j]),r[i]);
            for (int i=0;i<=sz;++i)
                r[i]=tmp[i][j];
            for (int i=1;i<=sz;++i)
                for (int z=1;z<=i/p;++z)
                    Add(r[i],mul(mul(tmp[i-z*p][j],f[z][j]),C_j(i,z*p,j)));
            for (int i=0;i<=sz;++i)
                tmp[i][j]=r[i];
        }
    }
    ans=mul(dp[n][1],kinfac[n-1][1]);
    ans=(ans%mp+mp)%mp;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Kubic (赞：4)

对于一棵**无标号有根树** $T$，定义 $f(T)$ 表示给它的点标号的本质不同合法方案数。

题目要我们求的就是

$$\dfrac{1}{((n-1)!)^m}\sum\limits_{|T|=n}f^m(T)$$

先考虑给定 $T$，如何求 $f(T)$。可以得到

$$f(T)=|T|!\prod\limits_{u\in T}\dfrac{1}{size_u}\prod\limits\dfrac{1}{w_{u,i}!}$$

其中 $w_{u,i}$ 的意义是：考虑所有以 $u$ 的某一个儿子为根的子树，把所有互相同构子树的划分入同一个等价类，第 $i$ 个等价类的大小。

考虑 dp。

令

$$dp_i=\sum\limits_{|T|=i}f^m(T)$$

但是推一推就会发现完全无法转移。

先利用生成函数表示 $dp_i$：

$$dp_i=\dfrac{1}{i^m}[x^{i-1}]\prod\limits_j\prod\limits_{|T|=j}\sum\limits_{k=0}^{\infty}\dfrac{f^{km}(T)}{(k!)^m}x^{jk}$$

这一步其实非常不自然，而且后面也不是很容易，所以挺难想到的。

然后是一个套路：

令

$$A_i=\prod\limits_{|T|=i}\sum\limits_{k=0}^{\infty}\dfrac{f^{km}(T)}{(k!)^m}x^{ik}$$

则

$$=\exp(\sum\limits_{|T|=i}\ln(\sum\limits_{k=0}^{\infty}\dfrac{(f^m(T)x^i)^k}{(k!)^m}))$$

令

$$B=\ln(\sum\limits_{k=0}^{\infty}\dfrac{x^k}{(k!)^m})$$

则

$$A_i=\exp(\sum\limits_{|T|=i}\sum\limits_{k=0}^{\infty}([x^k]B)f^{km}(T)x^{ik})$$

$$=\exp(\sum\limits_{k=0}^{\infty}([x^k]B)\sum\limits_{|T|=i}f^{km}(T)x^{ik})$$

此时我们发现 $A_i$ 的柿子中有一个与 $dp_i$ 很类似的东西：

$$\sum\limits_{|T|=i}f^{km}(T)$$

为了处理这个东西，我们可以改变一下 dp 的定义，同时也需要改变一些其它的定义。

令

$$dp_{i,t}=\sum\limits_{|T|=i}f^{tm}(T)$$

$$A_{i,t}=\prod\limits_{|T|=i}\sum\limits_{k=0}^{\infty}\dfrac{f^{tkm}(T)}{(k!)^{tm}}x^{ik}$$

$$B_t=\ln(\sum\limits_{k=0}^{\infty}\dfrac{x^k}{(k!)^{tm}})$$

则

$$dp_{i,t}=\dfrac{1}{i^{tm}}[x^{i-1}]\prod\limits_j\prod\limits_{|T|=j}\sum\limits_{k=0}^{\infty}\dfrac{f^{tkm}(T)}{(k!)^{tm}}x^{jk}$$

$$=\dfrac{1}{i^{tm}}[x^{i-1}]\prod\limits_jA_{j,t}$$

$$=\dfrac{1}{i^{tm}}[x^{i-1}]\prod\limits_j\exp(\sum\limits_{k=0}^{\infty}([x^k]B_t)\sum\limits_{|T|=j}f^{tkm}(T)x^{jk})$$

$$=\dfrac{1}{i^{tm}}[x^{i-1}]\prod\limits_j\exp(\sum\limits_{k=0}^{\infty}([x^k]B_t)dp_{j,tk}x^{jk})$$

我们只需要知道 $dp_{n,1}$ 的值即可。

推到这里，我们就已经得到了一个多项式复杂度做法了！

观察可得，$dp_{i,t}$ 中只需要保留 $t\le\dfrac{n}{i}$ 的部分。换言之，只需要保留 $i\le\dfrac{n}{t}$ 的部分。

进一步推得 $B_t$ 只需要保留次数 $\le\dfrac{n}{t}$ 的项。

求出 $B_t$ 需要进行一次多项式 $\ln$，暴力完成的复杂度为 $O(\dfrac{n^2}{t^2})$。因此这一部分复杂度为

$$O(\sum\limits\dfrac{n^2}{t^2})=O(n^2)$$

预处理完 $B_t$ 后我们还需要进行 dp。

从小到大枚举 $i$，只有满足 $i'<i$ 的 $dp_{i',*}$ 会对 $dp_{i,*}$ 产生贡献。

计算 $dp_{i,*}$ 的时候，我们需要维护 $\dfrac{n}{i}$ 个多项式

$$C_t=\prod\limits_j\exp(\sum\limits_{k=0}^{\infty}([x^k]B_t)dp_{j,tk}x^{jk})$$

可以根据之前的柿子快速求出 $dp_{i,*}$，然后更新 $C_t$。

$$C_t\leftarrow C_t\exp(\sum\limits_{k=0}^{\infty}([x^k]B_t)dp_{i,tk}x^{ik})$$


同时，根据之前的观察，$C_t$ 也只需要保留次数 $\le\dfrac{n}{t}$ 的项。

这些操作都可以暴力完成。

对于每一对 $(i,t)$，我们都要进行一次多项式 $\exp$ 和 $\dfrac{n}{i}$ 次卷积，暴力完成的复杂度分别为 $O(\dfrac{n^2}{i^2t^2})$ 和 $O(\dfrac{n^2}{it^2})$。因此这一部分的复杂度为

$$O(\sum\limits_i\sum\limits_t(\dfrac{n^2}{i^2t^2}+\dfrac{n^2}{it^2}))=O(n^2\log n)$$

多项式 $\ln$ 和 $\exp$ 都不在瓶颈上。

时间复杂度 $O(n^2\log n)$。

参考代码（变量名与题解中有很大不同，请谨慎食用）：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 2005
int n,m,MOD,fc[N],A[N],B[N],w[N][N],z[N][N],dp[N][N];
int add(int x,int y) {x+=y;return x<MOD?x:x-MOD;}
void W(int &x,int y) {x+=y;if(x>=MOD) x-=MOD;}
int qPow(int x,int y)
{
	int res=1;
	for(;y;y/=2,x=1ll*x*x%MOD) if(y&1) res=1ll*res*x%MOD;return res;
}
void polyLn(int n,int a[],int res[])
{
	for(int i=0;i<=n;++i) res[i]=0;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<i;++j) W(res[i],1ll*a[i-j]*res[j]%MOD*j%MOD);
		res[i]=add(a[i],MOD-1ll*res[i]*qPow(i,MOD-2)%MOD);
	}
}
void polyExp(int n,int a[],int res[])
{
	res[0]=1;for(int i=1;i<=n;++i) res[i]=0;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=i;++j) W(res[i],1ll*a[j]*res[i-j]%MOD*j%MOD);
		res[i]=1ll*res[i]*qPow(i,MOD-2)%MOD;
	}
}
int main()
{
	scanf("%d %d %d",&n,&m,&MOD);fc[0]=1;
	for(int i=1;i<=n;++i) fc[i]=1ll*fc[i-1]*i%MOD;
	for(int i=1;i<=n;++i)
	{
		for(int j=0;j<=n/i;++j) A[j]=qPow(fc[j],MOD-1ll*i*m%(MOD-1)-1);
		polyLn(n/i,A,w[i]);
	}for(int i=1;i<=n;++i) z[i][0]=1;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n/i;++j)
			dp[i][j]=1ll*z[j][i-1]*qPow(i,MOD-1ll*j*m%(MOD-1)-1)%MOD;
		for(int j=1;j<=n/i;++j)
		{
			for(int k=0;k<=n/i/j;++k) B[k]=1ll*w[j][k]*dp[i][j*k]%MOD;
			polyExp(n/i/j,B,A);
			for(int k=n/j;k>=0;--k) for(int l=1;l<=(n/j-k)/i;++l)
				W(z[j][k+i*l],1ll*z[j][k]*A[l]%MOD);
		}
	}printf("%lld\n",1ll*dp[n][1]*qPow(n,m)%MOD);return 0;
}
```

---

## 作者：chenxinyang2006 (赞：3)

前面的部分怎么做其他题解已经说得很好了！最后我们得到的结果是：

设 $dp_{i,j}$ 为所有 $j$ 个点无标号有根树 $t$ 的权值之和，$t$ 的权值定义为对其合法标号的数量的 $ik$ 次方除以 $(j!)^{ik}$ ，记 $F_i(x)= \sum\limits_{j=1}^{\infty} x^jdp_{i,j}$ ，并计算出 $\ln(\sum\limits_{p=0}^{\infty} \dfrac{x^p}{(p!)^{ik}}) = \sum\limits_{i=0}^{\infty} val_ix^i$，那么有：

$dp_{i,j} = \dfrac{1}{(j!)^{ik}} [x^{j-1}]\exp(\sum\limits_{p=1}^{\infty} val_p F_{ip}(x^p))$。

最后我们要求的是 $n^kdp_{1,n}$。那么可以归纳证明，对于某个 $i$，$dp_{i,j}$ 只需计算 $j \le \dfrac{n}{i}$ 的项就不影响最终结果，并且 $val$ 序列也只需保留前 $\dfrac{n}{i}$ 项。

$val$ 序列没有依赖关系，可以一开始先算好。

注意到某个 $F_i$ 的值只依赖 $j \ge i,F_j$ 的值，所以我们按 $i$ 从大到小的顺序计算 $F_i$，对于 $p>1$ 的部分我们可以预先将系数加和，这消耗 $\dfrac{n}{ip}$ 时间。而对于 $p=1$ 的部分 $F_i$ 会影响自身，但可以发现其实相当于 $j$ 从 $1$ 到 $\dfrac{n}{i}$ 先取出 $\exp$ 结果的第 $j-1$ 项，在补上被求 $\exp$ 多项式的第 $j$ 项，也就是一个半在线卷积。

如果以上 $\exp$ 都暴力计算，那么复杂度是 $\sum\limits_{i=1}^n (\dfrac{n}{i})^i = O(n^2)$ 再加上将系数加和消耗的 $\sum\limits_{i=1}^n \sum\limits_{j=1}^n \dfrac{n}{ij} = O(n \log^2 n)$ 时间。

如果 $\exp$ 用分治 NTT 进行半在线卷积，那么复杂度应该可以做到 $O(n \log^3 n)$（没实现，不一定对）。

$O(n^2)$ 的代码：

```cpp
#include <bits/stdc++.h>
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
#define uint unsigned int
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define pii pair<int,int>
#define pll pair<ll,ll>
#define mkp make_pair
#define eb emplace_back
#define SZ(S) (int)S.size()
//#define mod 998244353
//#define mod 1000000007
#define inf 0x3f3f3f3f
#define linf 0x3f3f3f3f3f3f3f3f
using namespace std;

template <class T>
void chkmax(T &x,T y){
	if(x < y) x = y;
}

template <class T>
void chkmin(T &x,T y){
	if(x > y) x = y;
}

inline int popcnt(int x){
	return __builtin_popcount(x);
}

inline int ctz(int x){
	return __builtin_ctz(x);
}

int n,K,mod;
ll fact[2005],ifac[2005],inv[2005];
ll power(ll p,ll k = mod - 2){
	ll ans = 1;
	while(k){
		if(k % 2 == 1) ans = ans * p % mod;
		p = p * p % mod;
		k /= 2;	
	}
	return ans;
}

template <class ADD>
void add(ADD &x,ADD y){
	x += y;
	if(x >= mod) x -= mod;
}

template <class SUB>
void sub(SUB &x,SUB y){
	x -= y;
	if(x < 0) x += mod;
}
ll dp[2005][2005],f[2005],g[2005];

int main(){
//	freopen("test.in","r",stdin);
	scanf("%d%d%d",&n,&K,&mod);
	fact[0] = 1;
	rep(i,1,n) fact[i] = fact[i - 1] * i % mod;
	ifac[n] = power(fact[n]);
	per(i,n - 1,0) ifac[i] = ifac[i + 1] * (i + 1) % mod;
	rep(i,1,n) inv[i] = ifac[i] * fact[i - 1] % mod;

	per(i,n,1){
		int s = n / i;
		rep(j,0,s) g[j] = power(ifac[j],1ll * K * i);

//		rep(j,0,s) printf("%lld ",g[j]);
//		printf("\n");
		rep(j,0,s - 1){
			f[j + 1] = 0;
			rep(k,1,j) sub(f[j + 1],g[k] * f[j + 1 - k] % mod * (j + 1 - k) % mod);
			f[j + 1] = f[j + 1] * inv[j + 1] % mod;
			add(f[j + 1],g[j + 1]);
		}
//		rep(j,0,s) printf("%lld ",f[j]);
//		printf("\n");

		fill(g,g + s + 1,0);
		for(int j = i + i,r = 2;j <= n;j += i,r++){
			rep(k,1,n / j) add(g[k * r],f[r] * dp[j][k] % mod);
		}

		ll ext = f[1];
		fill(f,f + s + 1,0);
		f[0] = 1;
		rep(j,1,s){
			dp[i][j] = f[j - 1] * power(inv[j],1ll * i * K) % mod;
			add(g[j],ext * dp[i][j] % mod);
			rep(k,0,s - 1) add(f[j],f[k] * g[j - k] % mod * (j - k) % mod);
			f[j] = f[j] * inv[j] % mod;
		}
//		printf("i=%d\n",i);
//		rep(j,1,s) printf("%lld ",dp[i][j]);
//		printf("\n");
	}
	printf("%lld\n",dp[1][n] * power(n,K) % mod);
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：2)

# P4500 题解



本题解主要是对 @FunnyCreatress 老师的[题解](https://www.luogu.com.cn/blog/HailToTheFunnyGod/solution-p4500)的一点解释，符号和思路基本都相同。



**题目大意**

> 给定 $n,k,p$，定义 $T_n$ 表示大小为 $n$ 的有标号有根树，满足“所有儿子标号都小于父亲标号”的树的集合。
>
> 求：等概率地在 $T_n$ 中选取 $k$ 棵树（可以相同），他们两两同构的概率是多少，对 $p$ 取模。
>
> 数据范围：$n\le 2000,k\le 10^9$。

**思路分析**

先不考虑标号，记 $\mathcal T$ 为一棵无标号有根树，用 $g(\mathcal T)$ 表示 $\mathcal T$ 合法标号的概率（即合法标号数除以 $|\mathcal T|!$）。

记 $\mathscr T_n$ 表示所有大小为 $n$ 的无标号无根树构成的集合。

那么答案能表示成：
$$
\begin{aligned}
\mathrm{Answer}
&=\dfrac{1}{((n-1)!)^k}\sum_{\mathcal T\in\mathscr T_n}(n!g(\mathcal T))^k\\
&=n^k\sum_{\mathcal T\in\mathscr T_n} g(\mathcal T)^k
\end{aligned}
$$
考虑定义这样一个 dp：$f(n,i)=\sum\limits_{\mathcal T\in\mathscr T_n}g(\mathcal T)^{ik}$，那么显然答案就是 $n^kf(n,1)$。

其中，我们定义 $i$ 这一维主要是为了方便通过子结构转移。

考虑枚举切掉根后形成的无标号有根森林，注意同构的树之间可以交换：
$$
f(n,i)=\dfrac{1}{n^{ik}}[z^{n-1}]\prod_{j=1}^{n-1}\prod_{\mathcal T\in\mathscr T_j}\sum_{p=0}^{\infty} \left(\dfrac{g(\mathcal T)^p}{p!}\right)^{ik}z^{jp}
$$
其中除以 $n^{ik}$ 是为了把根标号成 $1$，$j$ 是枚举每个连通块的大小，$p$ 是对应每种树形态的数量，除以 $p!$ 因为这些同构的树在无标号意义下不可区分，$z$ 是当前森林的总大小。

由于 $g(\mathcal T)$ 表示的是概率，因此这里可以直接相乘而避免组合数分配标号。

观察发现式子中的几个连乘号很棘手，考虑用形式幂级数 $\exp/\ln$ 处理，定义：
$$
H_i(z)=\ln\left(\sum_{p=0}^{\infty}\dfrac{z^p}{(p!)^{ik}}\right)=\sum_{p=1}^{\infty} h(i,p)z^p
$$
$h(i,p)$ 即 $[z^p]H_i(z)$，带入到原式中得到：
$$
f(n,i)=\dfrac{1}{n^{ik}}[z^{n-1}]\prod_{j=1}^{n-1}\prod_{\mathcal T\in\mathscr T_j}\exp\left(H_i(g(\mathcal T)^{ik}z^j)\right)
$$
然后就是用 $\exp$ 展开连乘号，处理和式，尽可能把有关 $g(\mathcal T)$ 的和式写成 $f$ 的形式。
$$
\begin{aligned}
f(n,i)
&=\dfrac{1}{n^{ik}}[z^{n-1}]\prod_{j=1}^{n-1}\prod_{\mathcal T\in\mathscr T_j}\exp\left(H_i(g(\mathcal T)^{ik}z^j)\right)\\
&=\dfrac{1}{n^{ik}}[z^{n-1}]\prod_{j=1}^{n-1}\exp\left(\sum_{\mathcal T\in\mathscr T_j}H_i(g(\mathcal T)^{ik}z^j)\right)\\
&=\dfrac{1}{n^{ik}}[z^{n-1}]\prod_{j=1}^{n-1}\exp\left(\sum_{\mathcal T\in\mathscr T_j}\sum_{p=0}^{\infty} h(i,p)g(\mathcal T)^{ikp}z^{jp}\right)\\
&=\dfrac{1}{n^{ik}}[z^{n-1}]\prod_{j=1}^{n-1}\exp\left(\sum_{p=0}^{\infty} h(i,p)z^{jp}\sum_{\mathcal T\in\mathscr T_j}g(\mathcal T)^{ikp}\right)\\
&=\dfrac{1}{n^{ik}}[z^{n-1}]\prod_{j=1}^{n-1}\exp\left(\sum_{p=0}^{\infty} h(i,p)z^{jp}f(j,ip)\right)\\
\end{aligned}
$$
从小到大枚举 $j$，对每个 $i$ 动态维护后面的那个多项式 $U_i(x)$，因此我们就得到了一个 $\mathcal O(\mathrm{poly}(n))$ 的做法，现在考虑进一步优化。

首先可以用 $\mathcal O(n^2)$ 的暴力实现多项式 $\exp/\ln$：
$$
\begin{aligned}
G=\ln F&\implies g_i=f_i-\dfrac 1i\sum_{j=1}^{i-1} j\times f_{i-j}\times g_j\\
G=\exp F&\implies g_i=\dfrac 1i\sum_{j=1}^ij\times g_{i-j}\times f_j
\end{aligned}
$$
注意到任何状态下都有 $i\times j\times p\le n$，因此对于每个 $H_i(z)$，我们只关心其前 $n/i$ 次项系数，这一部分的复杂度是：
$$
\mathcal O\left(\sum_{i=1}^n\left(\dfrac ni\right)^2\right)=\mathcal O\left(n^2\sum_{i=1}^n\dfrac 1{i^2}\right)=\mathcal O(n^2)
$$
其中 $\sum_{i=1}^\infty \dfrac 1{i^2}=\dfrac{\pi^2}6$，是巴塞尔问题的经典结论。

然后是 $\exp$ 部分，注意到多项式的大小是 $jp$ 的，复杂度不正确，我们期望的是一个大小为 $p$ 的多项式，不妨设：
$$
Q_{i,j}(z)=\exp\left(\sum_{p=1}^{\infty}h(i,p)z^pf(j,ip)\right)
$$
而我们所求的 $U_i(z)$ 即是 $\prod\limits_{j=1}^{n-1}Q_{i,j}(z^j)$，先求出 $Q_{i,j}(z)$，然后把下标 $\times j$ 再卷积即可。
多项式 $\exp$ 这一部分复杂度为：
$$
\mathcal O\left(\sum_{ij\le n}\left(\dfrac n{ij}\right)^2\right)\le\mathcal O\left(n^2\sum_{i=1}^n\dfrac 1{i^2}\sum_{j=1}^n\dfrac 1{j^2}\right)=\mathcal O(n^2)
$$
（复杂度符号可能不是很严谨）

然后考虑暴力卷积求 $U$ 的这一步：
$$
\mathcal O\left(\sum_{i=1}^n \dfrac ni\sum_{j=1}^{n/i}\dfrac n{ij}\right)=\mathcal O\left(\sum_{i}\dfrac{n^2}{i^2}H_{n/i}\right)=\mathcal O(n^2\log n)
$$
综上所述，本算法总时间复杂度为 $\mathcal O(n^2\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=2005;
int MOD,fac[MAXN],ifac[MAXN],inv[MAXN];
inline int ksm(int a,int b=MOD-2,int p=MOD) {
	int ret=1;
	for(;b;a=a*a%p,b=b>>1) if(b&1) ret=ret*a%p;
	return ret;
}
inline vector<int> Ln(const vector<int> &f) {
	int n=f.size()-1;
	vector <int> g(n+1);
	for(int i=1;i<=n;++i) {
		for(int j=1;j<i;++j) g[i]=(g[i]+g[j]*f[i-j]%MOD*j)%MOD;
		g[i]=(f[i]+MOD-inv[i]*g[i]%MOD)%MOD;
	}
	return g;
}
inline vector<int> Exp(const vector<int> &f) {
	int n=f.size()-1;
	vector <int> g(n+1);
	g[0]=1;
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=i;++j) g[i]=(g[i]+f[j]*g[i-j]%MOD*j)%MOD;
		g[i]=g[i]*inv[i]%MOD;
	}
	return g;
}
vector <int> f[MAXN],h[MAXN],u[MAXN]; 
signed main() {
	int n,k;
	scanf("%lld%lld%lld",&n,&k,&MOD);
	for(int i=fac[0]=ifac[0]=1;i<=n;++i) {
		fac[i]=fac[i-1]*i%MOD;
		inv[i]=ksm(i),ifac[i]=ksm(fac[i]);
	}
	for(int i=1;i<=n;++i) f[i].resize(n/i+1);
	for(int i=1;i<=n;++i) f[1][i]=1;
	for(int i=1;i<=n;++i) u[i].resize(n/i+1),u[i][0]=1;
	for(int i=1;i<=n;++i) {
		h[i].resize(n/i+1);
		for(int p=1;p<=n/i;++p) h[i][p]=ksm(ifac[p],i*k);
		h[i]=Ln(h[i]);
	}
	for(int j=1;j<=n;++j) {
		for(int i=1;i<=n/j;++i) f[j][i]=ksm(inv[j],i*k)*u[i][j-1]%MOD;
		for(int i=1;i<=n/j;++i) {
			vector <int> q(n/(i*j)+1);
			for(int p=1;p<=n/(i*j);++p) q[p]=h[i][p]*f[j][i*p]%MOD;
			q=Exp(q);
			vector <int> v=u[i];
			fill(u[i].begin(),u[i].end(),0);
			for(int p=0;p<=n/(i*j);++p) {
				for(int s=0;s<=n/i;++s) if(s+p*j<=n/i) {
					u[i][s+p*j]=(u[i][s+p*j]+v[s]*q[p])%MOD;
				}
			}
		}
	}
	printf("%lld\n",ksm(n,k)*f[n][1]%MOD);
	return 0;
}
```

---

## 作者：Phartial (赞：0)

- P4500 \[ZJOI2018\] 树：我们将以如下方法生成一棵 $n$ 个节点的有标号有根树：
  - 节点 $1$ 作为根；
  - 对于节点 $1<i\le n$，在 $[1,i)$ 中均匀随机一个整数，作为 $i$ 的父亲。

  现在生成 $k$ 棵有标号有根树，求这些树两两同构的概率。

  同构的意义是，对于两棵树 $T_1,T_2$，你可以找到一个对 $T_1$ 节点的置换，使得 $T_1$ 在施加这个置换后和 $T_2$ 完全一致。

  不定模数。$n\le 2000$，$k\le 10^9$。

用题面中的方法可以生成 $(n-1)!$ 种有标号有根树，于是总方案数是 $(n-1)!^k$，只需求出生成的 $k$ 棵树两两同构的方案数。

对于一棵**无标号**有根树，我们通过给它分配标号（要求父节点的标号小于子节点的标号）可以得到若干棵有标号有根树，且这些树应当两两同构，同时容易证明只有这些树两两同构。

于是记 $f(T)$ 为无标号有根树 $T$ 通过分配标号能得到的有标号有根树，答案即为 $\displaystyle\sum_{|T|=n}f(T)^k$。

由这个关系可以得到一系列有标号有根树的等价类，从无标号有根树 $T$ 导出的等价类大小为 $f(T)$，考虑合并这些等价类。

我们大可以扩展 $f(T)$ 的定义到所有无标号有根树森林 $T$，那么对于两个无标号有根树森林 $T_1,T_2$，合并可以简单的定义成放在一起，记作 $\otimes$，则有 $|T_1\otimes T_2|=|T_1|+|T_2|$，且 $\displaystyle f(T_1\otimes T_2)=f(T_1)f(T_2){|T_1|+|T_2|\choose |T_1|}$。

由于我们想要计数的是 $f(T)^k$，同时有 $\displaystyle\frac{f(T_1\otimes T_2)^k}{|T_1\otimes T_2|!^k}=\frac{f(T_1)^k}{|T_1|!^k}\cdot \frac{f(T_2)^k}{|T_2|!^k}$，于是考虑定义 $\chi(n)=\dfrac{z^n}{n!^k}$，就可以定义由无标号有根树森林组成的组合类 $\mathcal{A}$ 的一种 GF：

$$
T(\mathcal{A};z)=\sum_{t\in\mathcal{A}}\dfrac{f(t)^k}{|t|!^k}z^{|t|}
$$

所求即为所有无标号有根树组成的组合类 $\mathcal{T}$ 的 $[\frac{z^n}{n!^k}]T(\mathcal{T};z)$。容易验证该 GF 能够满足我们想要的一些性质。

然后考虑怎么构造一棵无标号有根树。我们先把根删掉得到组合类 $\mathcal{T}^\square$，然后剩下的儿子就是一个多重集，那么就有 $\mathcal{T}^\square=\operatorname{MSET}(\mathcal{T})$。

我们想把它翻译成生成函数运算，先看 $\mathcal{T}^\square$，因为根是被钦定的，所以删掉根后所有组合对象的大小只是被减去了一，即 $\displaystyle\sum_{i=0}^\infty T_{i+1}\frac{z^i}{i!^k}$，我们把这个运算记作 $\delta$。

再看 $\operatorname{MSET}(\mathcal{T})$。值得注意的一点是，$\operatorname{SET}$ 构造可以写成 $\displaystyle\exp A=\exp\left(\sum_{i=0}^\infty A[i]\frac{z^i}{i!}\right)=\prod_{a\in\mathcal{A}}\exp\left(\frac{z^{|a|}}{|a|!}\right)=\prod_{a\in\mathcal{A}}\sum_{i=0}^\infty\frac{(\frac{z^{|a|}}{|a|!})^i}{i!}$，这和一般的 $\operatorname{MSET}$ 构造很像（$\displaystyle\prod_{a\in\mathcal{A}}\sum_{i=0}^\infty(z^{|a|})^i$）。考虑它的组合意义，分子很显然，分母的意义就是这 $i$ 个相同的对象有 $i!$ 种等价的重标号方法。那么我们大可以参考这两者定义 $\operatorname{MSET}(\mathcal{T})$ 翻译到生成函数的结果：

$$
T(\operatorname{MSET}(\mathcal{T});z)=\prod_{t\in\mathcal{T}}\sum_{i=0}^\infty\frac{(\frac{F(t)^k}{|t|!^k}z^{|t|})^i}{i!^k}
$$

设 $\displaystyle\operatorname{xexp} x=\sum_{i=0}^\infty\frac{x^i}{i!^k}$，那么就有 $\displaystyle T(\operatorname{MSET}(\mathcal{T});z)=\prod_{t\in\mathcal{T}}\operatorname{xexp}\left(\frac{F(t)^k}{|t|!^k}z^{|t|}\right)$

$\prod$ 很烦，于是考虑使用 $\exp\circ\ln$ 把它去掉，那么这就是 $\displaystyle\exp\sum_{t\in\mathcal{T}}\ln\circ\operatorname{xexp}\left(\frac{F(t)^k}{|t|!^k}z^{|t|}\right)$。

然后你发现 $\displaystyle\ln\circ\operatorname{xexp} x=\ln\sum_{i=0}^\infty\frac{x^i}{i!^k}$ 的各项系数可以预处理，记 $\displaystyle\ln\circ\operatorname{xexp} x=\sum_{i=1}^\infty g_ix^i$，就有：

$$
\begin{aligned}
  T(\operatorname{MSET}(\mathcal{T});z)
  &=\exp\sum_{t\in\mathcal{T}}\sum_{i=1}^\infty g_i\left(\frac{F(t)^k}{|t|!^k}z^{|t|}\right)^i\\
  &=\exp\sum_{i=1}^\infty g_i\sum_{t\in\mathcal{T}}\left(\frac{F(t)^k}{|t|!^k}z^{|t|}\right)^i\\
\end{aligned}
$$

你发现后面那个东西可以描述成 $\displaystyle\sum_{t\in\mathcal{T}}\frac{F(t)^{ik}}{|t|!^{ik}}(z^i)^{|t|}$，这可以描述成原来的形式，但我们要多加一元来记录这个指数。定义：

$$
T(\mathcal{A};z,u)=\sum_{t\in\mathcal{A}}z^{|t|}\sum_{i=0}^\infty u^i\frac{F(t)^i}{|t|!^i}
$$

同时也要改一下 $g_i$ 的定义，令 $\displaystyle g_{i,k}=[x^i]\ln\sum_{i=0}^\infty\frac{x^i}{i!^k}$。

那这时候就有：

$$
[u^k]T(\operatorname{MSET}(\mathcal{T});z,u)=\exp\sum_{i=1}^\infty g_{i,k}[u^{ik}]T(\mathcal{T};z^i,u)
$$

于是可以列出方程：

$$
\delta[u^k]T(\mathcal{T};z,u)=\exp\sum_{i=1}^\infty g_{i,k}[u^{ik}]T(\mathcal{T};z^i,u)
$$

右式 $i>1$ 的部分可以递归计算，设计算出来的东西是 $H(z)$，$G(z)=[u^k]T(\mathcal{T};z,u)$，那么方程就是 $\delta G(z)=\exp(H(z)+G(z))$，如果我们知道了 $\delta G(z)$ 的 $i$ 次项，那么就可以知道 $G(z)$ 的 $i+1$ 次项，这就给出一个半在线卷积的形式，嗯嗯计算即可。

好吧还是来推一下式子，首先有：

$$
\ln F(z)=\int\frac{F'(z)}{F(z)}\mathrm{d}z\\
$$

设 $G(z)=\dfrac{F'(z)}{F(z)}$，就有：

$$
\begin{aligned}
  G(z)&=F'(z)-(F(z)-1)G(z)\\
  [z^n]G(z)&=[z^n]F'(z)-[z^n](F(z)-1)G(z)\\
  [z^n]G(z)&=(n+1)[z^{n+1}]F(z)-\sum_{i=0}^{n-1}[z^{n-i}]F(z)[z^i]G(z)\\
  (n+1)[z^{n+1}]\ln F(z)&=(n+1)[z^{n+1}]F(z)-\sum_{i=0}^{n-1}[z^{n-i}]F(z)(i+1)[z^{i+1}]\ln F(z)\\
  [z^n]\ln F(z)&=[z^n]F(z)-\frac{1}{n}\sum_{i=1}^{n-1}i[z^{n-i}]F(z)[z^i]\ln F(z)\\
\end{aligned}
$$

边界是 $[z^0]\ln F(z)=0$，$[z^1]\ln F(z)=[z^1]F(z)$，于是 $g$ 就能算了。同时还有：

$$
[z^n]\delta G(z)=\frac{1}{n}\sum_{i=1}^ni([z^i]H(z)+[z^i]G(z))[z^{n-i}]\delta G(z)
$$

然后我们有 $[\frac{z^n}{n!^k}]\delta G(z)=[\frac{z^{n+1}}{(n+1)!^k}]G(z)$，也就是 $[z^n]\delta G(z)=(n+1)^k[z^{n+1}]G(z)$，代入就有：

$$
[z^n]G(z)=\frac{1}{n^k(n-1)}\sum_{i=1}^{n-1}i(n-i)^k([z^i]H(z)+[z^i]G(z))[z^{n-i}]G(z)
$$

_好吧这好像是个全在线卷积的形式……_

边界是 $[z^0]G(z)=0$，$[z^1]G(z)=1$。

虽然任意模数半在线卷积和全在线卷积这看上去很唬人，但实际上我们可以分析一下时间复杂度：我们只要 $[u^{dk}]T(\mathcal{T};z^d,u)$ 的 $\mathcal{O}(n/d)$ 项，而暴力计算这 $\mathcal{O}(n/d)$ 项的时间复杂度是 $\mathcal{O}((n/d)^2)$，于是总时间复杂度其实是 $\displaystyle\mathcal{O}\left(\sum_{d=1}^n(n/d)^2\right)=\mathcal{O}(n^2)$ 的。记忆化一下就全对了。不用写什么古神东西。

一道全是多项式的题目最后连 NTT 都不用写，或许这就是多项式的魅力吧。

[code](https://www.luogu.com.cn/paste/f5a6bt0u).

---


# [ZJOI2018] 保镖

## 题目描述

九条可怜是一个贪玩的女孩子。

一个可爱的女孩子出门在外和朋友玩，难免会遇到危险，于是可怜的爸爸悄悄的安插了 $n$ 位保镖在暗中保护她。因为可怜是一个要强的女孩子，所以她的爸爸不想让她知道她的身边有这么多的保镖，因此保镖们必须通过定期的换岗来避免被可怜发现。

一次理想的换岗是：距离可怜远的保镖被换到了较近的位置，距离可怜近的保镖被换到了较远的位置。经过一系列安排，保镖们会按照如下的方式进行换岗：

换岗时，可怜和保镖们的位置可以被抽象成二维平面直角坐标系上的点。设可怜的位置为 $O$，保镖的位置为 $P_i$，换岗后的位置为 $P'_i$
在换岗前后，保镖和可怜的相对位置不变。即对于 $\forall i \in [1,n]$，$P'_i$ 在射线 $OP_i$ 上。
在换岗前后，保镖和可怜的距离变成了原来的倒数。即对于 $\forall i \in [1,n]$，$|OP_i||OP'_i|=1$。
同时，保镖的位置决定了可怜的安全度。如果在外围的保镖越多，那么他们能观察到的信息就越多，可怜就越安全。因此，我们定义这些保镖的位置的凸包的**顶点个数**为可怜的安全度。

然而，可怜的行踪总是神出鬼没的。这一天，保镖们跟丢了可怜，只知道可怜下次会在以 $(x_1,y_1)$ 为左下角，以 $(x_2,y_2)$ 为右上角的矩形区域内出现，具体的位置服从这个矩形区域内的均匀分布（可以理解为等概率随机）。因为保镖们已经有很长时间没有换岗了，于是他们打算在可怜下次出现的时候换岗。同时，在极小的概率下，可怜可能会出现在和某个保镖相同的位置上。这时这个保镖会被发现，从而他会保持位置不动，而其他的保镖还是会按照上述规则进行换岗。

现在，可怜的爸爸想要计算，保镖们在换岗后，可怜的安全度的期望是多少。

如果你对凸包不太熟悉，这儿给出凸包形式化的定义：

对于一个简单多边形，它是凸多边形当且仅当它内部任意两点的连线在它的内部。
对于一个点集 $P$，它的凸包为包含所有点面积最小的没有三个连续顶点共线的凸多边形。

## 说明/提示

### 样例解释
这儿画出可怜出现在 (1,0) 时的情况，如下图所示，1,2,4 号保镖的位置保持不变，分别为 $P_1,P_2,P_4$，3 号保镖从 $P_3$ 变到了 $P'_3$，坐标为 $(\frac{1}{2},\frac{1}{2})$。 

![](https://cdn.luogu.com.cn/upload/pic/18418.png)

这时四个保镖的位置 $P_1,P_2,P'_3,P_4$ 的凸包为三角形 $P_1,P_4,P_2$，因此可怜的安全度为 3。注意这时 $P'_3$ 正好落在边 $P_1P_4$ 上，但是根据凸包的定义，它不是顶点。

### 数据范围

测试点|　$n$|测试点|　$n$
-|-|-|-
1|$\le 3$|6|$\le 50$
2|$\le 4$|7|$\le 350$
3|$\le 4$|8|$\le 350$
4|$\le 50$|9|$\le 2000$
5|$\le 50$|10|$\le 2000$

对于 100% 的数据，保证 $0 \leq a,b,x_0,x_1,y_0,y_1 \leq 10^5,x_0<x_1,y_0<y_1,n \geq 3$。

对于 100% 的数据，保证保镖的位置两两不同。

同时为了避免可能出现的精度误差，在所有实际的测试数据以及大样例中，保证可怜可能出现的矩形区域的长宽都不小于 $10^3$，即 $x_1-x_0,y_1-y_0 \geq 10^3$.

## 样例 #1

### 输入

```
4
0 0 1 1
0 0
2 0
0 1
1 1```

### 输出

```
3.7853981633974474
```

# 题解

## 作者：xzyxzy (赞：30)

## 追求更佳阅读体验：[BLOG](https://www.cnblogs.com/xzyxzy/p/10349399.html)。记得推荐&点赞哦！
# [ZJOI2018]保镖

Tags：题解

---

## 题意

[链接](https://www.luogu.org/problemnew/show/P4502)

初始在平面上有一些点，九条可怜随机出现在一个矩形内的任意一点。若九条可怜出现在$O$点，则平面上所有的点都从$P_i$移动到$P'_i$，使得$P'_i$在射线$OP_i$上，且满足$|OP_i|*|OP'_i|=1$。现在给定矩形范围，求这些点移动后所构成的凸包的期望点数。

$n\le 2000,x,y\le 10^5$，精度要求绝对误差或相对误差不超过$10^{-7}$。



## 题解

### **前言**

神仙不可做题终于被杠下来了！撒花！

不得不说九老师这个多合一是出的真的牛逼！（~~比lalaxu不知道高明到哪里去了~~）

首先感谢[Ez3real](https://loj.ac/submission/101720)的代码框架（不过LOJ两人AC代码一样什么鬼）和[yuhaoxiang](https://yhx-12243.github.io/OI-transit/records/lg4502%3Bloj2530%3Bsoj111.html)的题解（这个网站很慢）。



### **Part 1 前置知识：圆与矩形的面积交**

在[计算几何基础](https://www.cnblogs.com/xzyxzy/p/10033130.html)里有。

### **Part 2 前置知识：三维凸包**

在[三维凸包](https://www.cnblogs.com/xzyxzy/p/10225804.html)里有。

### **Part 3 前置知识：欧拉公式**

在[Pick定理、欧拉公式和圆的反演](https://www.cnblogs.com/xzyxzy/p/10241872.html)里有。

### **Part 4 前置知识：反演**

这道题显然是要求平面上的点关于$O$的、以$1$为反演幂（反演半径）的反形的凸包期望点数。

至于反演是什么可以看这个：[Pick定理、欧拉公式和圆的反演](https://www.cnblogs.com/xzyxzy/p/10241872.html)



### **Part 5 前置知识：Voronoi图**

又称**泰森多边形**。

大概就是一个平面划分，平面上的每个点划分到离它最近的关键点上。

Wiki有张十分形象的图

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E6%B3%B0%E6%A3%AE%E5%A4%9A%E8%BE%B9%E5%BD%A2.gif)



### **Part 6 前置知识：Delaunay三角剖分**

#### **三角剖分**

感性理解一下就是

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86.jpg)

Delaunay三角剖分是一种有着优秀性质的三角剖分。



**定理：对于任何一种三角剖分，三角形个数和外围凸包点数之和为2n-2**。

这里凸包是严格凸的，也就是没有三点共线情况。

考虑用欧拉公式证明：设凸包上的点数为$k$，三角形个数为$F-1$，则有

$$V-E+F=n-((F-1)*3+k)/2+F=2$$凸包上的边算了一次，三角形上的边算了两次、

即$$k+F=2n-1,k+F-1=2n-2$$



<br>

#### **立体Delaunay三角剖分**

当然我们目前只考虑平面的Delaunay三角剖分，至于立体的可以看看这张图，本文不会涉及。

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_Delaunay%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86.png)

（图片来源于网络）

<br>

#### **Delaunay三角剖分和泰森多边形**

Delaunay三角剖分和泰森多边形是对偶图。

对偶图是什么呢，看下面的构造方法：

泰森多边形的交点一般属于三个区域，将这三个区域的标志点连起来，就得到了一个原图的三角剖分。

![](https://img-blog.csdn.net/20141126144248328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWFrZW5vdGhpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

（图片来源于网络）

上图中，实线是泰森多边形，虚线链接，得到标志点的一个Delaunay三角剖分。

<br>

#### **Delaunay三角剖分的性质**

由于其美妙的构造，可以得到一些美妙的性质：



- 平面上的点集有且仅有唯一的Delaunay三角剖分（除出现四点共圆的情况，这时泰森多边形有顶点属于四个区域）。

- 任意一个Delaunay三角形的外接圆不包含点集中的其他点。（称为Delaunay三角形的空圆性质）。

- Delaunay三角剖分相比其他的三角剖分，所有三角形的最小角最大



<br>

#### **Delaunay三角剖分的构造**

以下内容摘自百度百科

**Bowyer-Watson算法**



 1. 构造超级三角形（类似半平面交中的超级平面）。

 2. 插入点$P$，找到点$P$的影响三角形（外接圆包括点$P$的三角形），删除影响三角形的公共边，并把$P$向这些影响到的点连边。

 3. 对原图进行优化

 4. 重复$2$直到所有点插入完毕

 

步骤2图示：

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_Delaunay%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86.jpg)



步骤3图示：转变连接对角线的方式使其满足空圆性质

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_Delaunay%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E5%B1%80%E9%83%A8%E4%BC%98%E5%8C%96.jpg)



和求三维凸包类似的复杂度分析，复杂度大概是$\cal O(n^2)$



### **Part 7 初步转化**

凸包点数，只能整体地去求，由于三角剖分的定理，我们可以转而求三角剖分的三角形个数。

三角形个数是可以用期望算的。



每一个Delaunay三角形对应一个外接圆，我们称为Delaunay圆。所以题目又转化为算Delaunay圆的期望个数。若Delaunay圆的期望个数为$num$，答案就是$Ans=2n-2-num$。



定义支配圆为包含点集中所有点的圆。Delaunay圆内不包含除Delaunay三角形三个顶点外的其他任何点，所以支配圆与Delaunay圆恰好相反。

则以下结论成立



- **对于Delaunay圆，若反演中心在圆内，其反形是支配圆；否则反形还是Delaunay圆。**

- **对于支配圆，若反演中心在圆内，其反形是Delaunay圆；否则反形还是支配圆。**



这题不用考虑反演中心在圆周上的情况（概率为0）

[这里有yuhaoxiang大佬做的一个Geogebra演示文件](https://www.geogebra.org/m/begkbgrn)，我把两种情况截图下来是这样的：

Delaunay圆，反演中心在圆内，反形是支配圆

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_Delaunay%E5%9C%86%E7%9A%84%E5%8F%8D%E6%BC%942.png)



Delaunay圆，反演中心在远外，反形还是Delaunay圆

![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_Delaunay%E5%9C%86%E7%9A%84%E5%8F%8D%E6%BC%941.png)



题目转化为：求**原图中Delaunay圆的个数×反演中心在圆内的概率+支配圆的个数×反演中心在圆外的概率**

若其期望为$E$，则$Ans=2n-2-$反形是Delaunay圆的概率$=2+E$

（这句话看完$Part 8$再回来看）对于这$n$个点，每个点一定至少会是一个Delaunay圆对应的其中一个顶点，所以这$n$个点每个点都会出现在凸包上，则凸包一共有$2n-4$个面，所以Delaunay圆+支配圆$=2n-4$。



### **Part 8 进一步转化**

考虑圆的方程$$x^2+y^2+Dx+Ey+F=0$$若令$z=x^2+y^2$，可以得到$Dx+Ey+z+F=0$，**这是空间坐标系中的一个平面方程**

$z=x^2+y^2$长这样：![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E5%9C%86%E5%8F%98%E5%B9%B3%E9%9D%A21.png)

例如圆$(x-1)^2+(y-1)^2=1$可以表示为$-2x-2y+z+1=0$，长这样：![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E5%9C%86%E5%8F%98%E5%B9%B3%E9%9D%A22.png)

自己做了一个动画：[网址](https://www.geogebra.org/classic/xjmqkytp)。



那么如果一个点$(x,y)$在圆上，则$(x,y,x^2+y^2)$在该圆对应的平面上

同理，在圆外或圆内，对应着在平面的一侧。具体来说，在其平面上面表示在圆外，在平面下面表示在圆内。

于是，把所有点映射到三维坐标系中，求凸包，**下凸面对应Delaunay圆，上凸面对应支配圆。**



### **Part 9 实现过程**

首先读入所有的点并进行随机微小扰动，使得不存在多点共圆以及最后求出三维凸包中不存在与$z

$轴平行的凸面。

然后求解三维凸包，这里采用的是增量法。

对于每个凸面，得到对应的三个点、求出其外接圆。



- 如果其为上凸面，则其为支配圆，只有在反演中心在圆外，贡献答案

- 如果其为下凸面，则其为Delaunay圆，只有反演中心在圆内，贡献答案



那么就是算给定矩形和圆形的面积交，这个在前置知识$Part 1$里啦



### **Part 10 总结&代码**

写了一年终于写完了！

完结撒花！！

这题考场上一定要果断丢，没有部分分。

这题出得很好，考察知识点全面。很巧妙的地方是：巧妙地把圆转化成三维空间的平面，从而把平面问题转化为三维凸包问题。巧妙地运用三角剖分，把求凸包顶点期望个数变为求圆的期望个数。

不得不说，orz jiry!!!



**Code**

```cpp
#include<iostream>
#include<cmath>
#define db __float128
#define orzjiry_2 19491001
using namespace std;
const db eps=1e-10;
db Rand() {return 1.0*rand()/RAND_MAX;}
int sign(db x) {return x<-eps?-1:(x>eps);}
struct v2
{
	db x,y;
	v2 operator + (v2 a) {return (v2){x+a.x,y+a.y};}
	v2 operator - (v2 a) {return (v2){x-a.x,y-a.y};}
	v2 operator / (db t) {return (v2){x/t,y/t};}
	v2 operator ^ (db t) {return (v2){x*t,y*t};}
	db operator * (v2 a) {return x*a.y-y*a.x;}
	db operator & (v2 a) {return x*a.x+y*a.y;}
	db dis() {return sqrt((double)(x*x+y*y));}
	db dis2() {return x*x+y*y;}
	void rot() {db t=x;x=-y;y=t;}
}jir[4];
struct v3
{
	db x,y,z;
	v3 operator + (v3 a) {return (v3){x+a.x,y+a.y,z+a.z};}
	v3 operator - (v3 a) {return (v3){x-a.x,y-a.y,z-a.z};}
	v3 operator * (v3 a) {return (v3){y*a.z-z*a.y,z*a.x-x*a.z,x*a.y-y*a.x};}
	db operator & (v3 a) {return x*a.x+y*a.y+z*a.z;}
	void shake() {x+=Rand()*1e-10,y+=Rand()*1e-10,z+=Rand()*1e-10;}
}P[2100];
struct Face
{
	int v[3];
	v3 Normal() {return (P[v[1]]-P[v[0]])*(P[v[2]]-P[v[0]]);}
}F[8100],C[8100];
int n,cnt;

namespace TAT2D
{
	v2 Cross(v2 a1,v2 a2,v2 b1,v2 b2)
	{
		v2 a=a2-a1,b=b2-b1,c=b1-a1;
		db t=(b*c)/(b*a);
		return a1+(a^t);
	}
	int cmp(db a,db b) {return sign(a-b);}
	db rad(v2 p1,v2 p2) {return atan2(double(p1*p2),double(p1&p2));}
	db Calc(db r,v2 p1,v2 p2)
	{
		v2 e=(p1-p2)/(p1-p2).dis(),e1=e;e.rot();
		v2 mid=Cross(p1,p2,(v2){0,0},e),d1=mid;
		if(d1.dis()>r) return r*r*rad(p1,p2)/2;
		db d=sqrt(double(r*r-d1.dis2()));
		v2 w1=mid+(e1^d),w2=mid-(e1^d);
		int b1=cmp(p1.dis2(),r*r)==1,b2=cmp(p2.dis2(),r*r)==1;
		if(b1&&b2)
		{
			if(sign((p1-w1)&(p2-w1))<=0)
				return r*r*(rad(p1,w1)+rad(w2,p2))/2+(w1*w2)/2;
			else return r*r*rad(p1,p2)/2;
		}
		if(b1) return (r*r*rad(p1,w1)+w1*p2)/2;
		if(b2) return (p1*w2+r*r*rad(w2,p2))/2;
		return p1*p2/2;
	}
	db intersect(v2 O,db r)
	{
		db res=0;
		for(int i=0;i<4;i++)
			res+=Calc(r,jir[i]-O,jir[(i+1)%4]-O);
		return res;
	}
}

namespace TAT3D
{
	bool vis[2100][2100];
	int see(Face a,v3 b) {return ((b-P[a.v[0]])&a.Normal())>0;}
	void Convex()
	{
		for(int i=0;i<n;i++) P[i].shake();
		int cc=-1;cnt=-1;
		F[++cnt]=(Face){0,1,2};
		F[++cnt]=(Face){2,1,0};
		for(int i=3;i<n;i++)
		{
			for(int j=0,v;j<=cnt;j++)
			{
				if(!(v=see(F[j],P[i]))) C[++cc]=F[j];
				for(int k=0;k<3;k++) vis[F[j].v[k]][F[j].v[(k+1)%3]]=v;
			}
			for(int j=0;j<=cnt;j++)
				for(int k=0;k<3;k++)
				{
					int x=F[j].v[k],y=F[j].v[(k+1)%3];
					if(vis[x][y]&&!vis[y][x]) C[++cc]=(Face){x,y,i};
				}
			for(int j=0;j<=cc;j++) F[j]=C[j];
			cnt=cc;cc=-1;
		}
	}
}

int main()
{
	//Part 1 输入以及初步转化
	srand(orzjiry_2);
	double xx,yy;
	cin>>n>>xx>>yy;jir[0]=(v2){xx,yy};
	cin>>   xx>>yy;jir[2]=(v2){xx,yy};
	jir[1]=(v2){jir[2].x,jir[0].y};
	jir[3]=(v2){jir[0].x,jir[2].y};
	db S=(jir[2].x-jir[0].x)*(jir[2].y-jir[0].y),Ans=0;
	for(int i=0;i<n;i++)
	{
		double x,y;cin>>x>>y;
		P[i]=(v3){x,y,x*x+y*y};
	}
	//Part 2 计算三维凸包并求出反演后支配圆的期望数量
	TAT3D::Convex();
	for(int i=0;i<=cnt;i++)
	{
		v3 o=F[i].Normal();
		v2 a1=(v2){P[F[i].v[0]].x,P[F[i].v[0]].y};
		v2 a2=(v2){P[F[i].v[1]].x,P[F[i].v[1]].y};
		v2 c=(a1+a2)/2.0,d=a2-a1;d.rot();
		a1=c;a2=c+d;
		v2 b1=(v2){P[F[i].v[1]].x,P[F[i].v[1]].y};
		v2 b2=(v2){P[F[i].v[2]].x,P[F[i].v[2]].y};
		c=(b1+b2)/2.0,d=b2-b1;d.rot();
		b1=c;b2=c+d;
		v2 O=TAT2D::Cross(a1,a2,b1,b2);
		d=(v2){P[F[i].v[0]].x,P[F[i].v[0]].y};
		db r=(O-d).dis();
		if(o.z>0) Ans+=S-TAT2D::intersect(O,r);
		else Ans+=TAT2D::intersect(O,r);
	}
	printf("%.11f\n",(double)(Ans/S+2));
}

```

---

## 作者：Piwry (赞：9)

## 题意

给定点集，求这些点以在给定矩形内等概率随机位置的点为中心，进行半径为 $1$ 的反演后，形成的凸包的期望顶点个数。

---

## 解析

[貌似是出题人的题解](https://pan.baidu.com/s/1zT8ezFYUWzDb4QalwpbjHw)（提取码：viop）

（为了不影响思路，一些结论性的前置知识我都放脚注里了，如果不了解的话可以先划下去看看解释）

### 1. 转化凸包顶点数

如果直接求凸包不太可做，因为求凸包是要求每个点的确切位置的；

但根据欧拉公式 $^1$，我们可以将凸包顶点个数转化成三角剖分 $^2$ 的三角形个数。

具体来说：

已知欧拉公式：$V-E+F=2$，

令这里的点数为 $n$。

令 $T$ 为三角剖分后的三角形个数。于是就可以知道 $F=T+1$。

令凸包的边数为 $E_1$，可以知道这和凸包点数的数值是相等的；内部的边数为 $E_2$。

考虑所有三角形的三条边，内部的边数被算入两次，凸包的边数被算一次。所以可以得到：$E_1+2E_2=3T$，

又可以根据定义得知：$E_1+E_2=E$，

带入欧拉公式，可得：$(n)-(E_1+E_2)+(T+1)=2$

即：$n-(E_1+\frac {3T-E_1} 2)+(T+1)=2$；

化简后可得：$E_1=2n-2-T$

&nbsp;

设凸包期望点数为 $h$，即可得：$h=E_1=2n-2-T$

### 2. 转化点集的反演

这样看起来稍微可做一些了，但我们还是很难算出反演后三角剖分三角形的期望个数。现在考虑一种特殊的三角剖分：$\text{Delaunay}$ 三角剖分。

同时我们暂时不考虑一些特殊的情况：

1. 三点或更多点共线
2. 四点或更多点共圆

并且对于反演点和某个点坐标相同的情况，由于概率为 $0$，我们也不考虑。

&nbsp;

一个 $\text{Delaunay}$ 三角剖分，满足其剖分的所有三角形的外接圆**内部**不包含其它任何点（也称作 "空圆性质"）。我们把这个圆称为 "内圆"。

![Delaunay](https://cdn.luogu.com.cn/upload/image_hosting/bvxhtz4x.png)

（这里其实也可以由 $\text{Voronoi}$ 图定义 $\text{Delaunay}$ 三角剖分。$\text{Voronoi}$ 图其实就是上图中连接圆心得到的图，也有优良的性质，这里暂不展开）

我们再定义"外圆" 为边界上有三个点且**外部**没有其它点的圆。

可以发现内圆和外圆的定义正好是**相反**的。这在下面的推导中很重要。

接着我们先有结论：

一个圆对于某个反演中心的反演，反演前在这个圆内部的点，反演后也一定在这个圆的内部或外部；反之亦然。但反演前圆内部与外部的点不在反演后圆的同一侧。

具体来说，如果反演中心在圆内部，则原先在圆内侧的点在反演后圆的外侧，否则仍在圆内侧；对于原先在圆外侧的点也是如此。

（可以看看这个[动画](https://www.geogebra.org/m/f59bu3gd)，其中红点是反演中心）

（其实反演变换还有很多有趣的性质。不严谨地讲，它其实就像将直线对称变换的**直线**换成了**圆**；因此反演变换也满足许多 "对称性"）

于是我们可以发现：

如果反演中心在某个内圆之内，那么这个内圆会变成外圆，否则这个内圆依旧是内圆。如果在某个外圆之内，那么外圆变成内圆，否则这个外圆依旧是外圆。

反演后的内圆一定对应着反演前的内圆或者外圆。

对于内圆，只有反演中心在圆外才能产生贡献；对于外圆，只有反演中心在圆内才能产生贡献。

可以看看另一篇题解的[动画](https://www.geogebra.org/classic/begkbgrn)

&nbsp;

因此我们只需对每个内圆或外圆与**九条可怜**可能出现的矩形求一次交 $^3$ 即可。

### 3. 求三角剖分

大体思路算是有了，但整个算法还缺一个关键的中间部分：如何求 $\text{Delaunay}$ 三角剖分（内圆）以及所有的外圆。

求 $\text{Delaunay}$ 三角剖分我们可以通过求其对偶图最近点 $\text{Voronoi}$ 图；而外圆其实可以求一个最远点 $\text{Voronoi}$ 图。

不过其实还有一个可以一起求出内圆和外圆的方法，并且能较直接的解决四点共圆、三点共线等特殊情况。

我们将平面上的每个点映射到抛物面 $z=x^2+y^2$ 上。于是对于一个平面圆方程 $x^2+y^2+ax+by+c=0$，其实还可以将它表示成一个抛物面 $z=x^2+y^2$ 和一个平面方程 $z+ax+by+c=0$ 的交。并且我们还可以发现，所有在圆内的点在三维坐标系中都在这个平面的 "下面"，而圆外的点都在平面 "上面"（定义 "上下" 由 $z$ 比较）

![圆](https://cdn.luogu.com.cn/upload/image_hosting/gdqnpog5.png)

（从上面看）

![俯视图](https://cdn.luogu.com.cn/upload/image_hosting/t2hcz82f.png)

这可以让我们想到凸包的性质：例如三维凸包，对于凸包的每一个面，所有的点一定都在它的内侧。因此可以考虑将问题转化为求三维凸包。

具体来说，求出映射到三维坐标的点集的凸包，对于凸包的每个下表面，对应着一个内圆；对于凸包的每个上表面，对应着一个外圆。

&nbsp;

实现时，我们只需将每个点按 $(x, y, x^2+y^2)$ 映射到三维坐标系，并求一个三维凸包。其每个下表面的三个顶点在平面坐标系的外接圆是一个内圆，其每个上表面的三个顶点的外接圆是一个外圆。分辨上下表面可以判断法向量的方向。

### 4. 处理特殊情况

有一种思路是随机扰动点来避免上述情况。

（值得一提的是，由于我们映射的所有点都在 $z=x^2+y^2$ 的抛物面上，因此所有点都是求得的凸包**顶点**。因此随机扰动不会出现将面上的点抖到里面，影响贡献的问题）

但考虑原本是三点共线的 "圆"，虽然扰动后它们不共线了，其形成的圆的半径是 `eps` 的倒数级别的：这会对精度产生很大的影响，可能甚至需要 `__float128` 来存储。

因此我们考虑直接解决特殊情况。

#### 四点共圆

首先是四点共圆。这里的圆可能是内圆或外圆。

如果是内圆，实际上圆上这些点的 $\text{Delaunay}$ 剖分是**模棱两可**的；或者说无论怎样三角剖分都是满足 $\text{Delaunay}$ 剖分的性质的，也并不会影响答案。

而这种情况在三维凸包上其实就是一个有多个顶点的面。通常求凸包算法会将这个面划分成多个小的三角形面，实际上也就是三角剖分。

如果是外圆，由于反演变换的性质 $^4$，它们反演后也一定在同一个圆上，并**保有一定的位置关系**。如果这个外圆反演后变成了内圆，产生贡献，能证明其仍是一个合法的三角剖分。至于三角剖分的具体情况，我们直接套用上面的解释即可。

即实现时，我们并不需要特殊考虑这种情况。

#### 三点共线

接着是三点共线。

对于凸包上一个面的法向量 $(a, b, c)$，我们可以得出这个面所对应的平面**圆内点**的不等式 $ax+by+c(x^2+y^2)< d$。三点共线时，对应到凸包上就是一个与 $x\text{-}z$ 平面平行的面，即 $c=0$。再联系不等式，其定义的 "圆内" 其实就是与这个平面法向量相反的方向，是包含所有点的，因此这条直线实际上 "是" 个**外圆**。

要计算这个圆的贡献，实际上就是算一个**半平面**与给定矩形的交。

这个半平面有点像该凸包表面所在平面的半空间（方向和法向量相反）在平面坐标系上的 "切片"。

![半空间](https://cdn.luogu.com.cn/upload/image_hosting/erz8ht1p.png)

（俯视视角）

![俯视图2](https://cdn.luogu.com.cn/upload/image_hosting/uxoucdjg.png)

不过如果**先**把这个凸包面映射为平面上的直线再判断半平面方向可能会有点困难。但我们可以反过来直接把矩形顶点拓展到三维坐标系（$z$ 坐标为 $0$），通过判断矩形顶点**对于平面的位置关系**来求出正确的交。

（具体可见代码，主要是保证求出的交包含矩形的一个顶点。如果这个顶点在平面上方（半空间外部），我们取另一半面积；否则直接取求出的交面积）

![九条可怜](https://cdn.luogu.com.cn/upload/image_hosting/yvypthkc.png)

（文中的图比较友好...这个半平面可能有各种奇怪的角度，不扔进半平面交求可能会更麻烦）

#### 所有点共圆

还有一种更特殊的情况：所有点共圆。

由于反演变换的保圆性 $^4$，无论如何反演这些点仍然是共圆的，凸包的顶点个数也**不会变**。

值得一提的是数据第一个点是一定所有点共圆的，~~可以直接输出 $3$ 轻松拿分~~。

---

## 脚注

### [1] 欧拉公式

$V-E+F=2$

其中 $V$ 指点数

$E$ 指边数，边由两个点相连形成

$F$ 指面数，两个不同的面必须跨过至少一条边才能到达，即面被边划分

&nbsp;

举个例子，一般的平面三角形，有 $3$ 个点，$3$ 条边，$2$ 个面。

欧拉公式证明略。

### [2] 三角剖分

其确切定义比较复杂。

可以粗略理解为，**恰好**覆盖点集凸包，且顶点都是点集内点的三角形集合。

### [3] 圆与矩形交

貌似网上很难找到相关的解释，我就粗略补充下了。

我们先考虑对于平凡情况的计算方法，对于更特殊的情况可以利用割补证明算法仍是正确的。

我们先假设圆心在矩形的内部。

将矩形拆成四条线段来考虑，每次我们只处理圆心到每条线段两个端点的**角度区间**。

一条线段和圆的关系可能有几种情况：

1. 线段离圆心距离大于半径。线段和圆不相交，其贡献为角度为这段角度区间的扇形。

2. 线段离圆心距离小于半径，且一个端点在圆内，一个在圆外。其贡献为圆内的端点、线段与圆的交点和圆心形成的三角形面积加上交点到圆外的端点这段角度区间的扇形面积。

3. 线段离圆心距离小于半径，且两个端点都在圆内。这时贡献就是线段端点和圆心所连三角形的面积。

4. 线段离圆心距离小于半径，且两个端点都在圆外。这时线段有可能与圆有交点，也可能**没有**。如果有交点，那么其贡献就是两个交点与圆心形成的三角形面积加上两侧的扇形面积；否则其贡献就是线段端点的角度区间的扇形面积，**多余的贡献会被割补消去**。

![面积交1](https://cdn.luogu.com.cn/upload/image_hosting/8c95emio.png)

（第 `4` 种情况中线段没有交点的图像，先放在这，割补的解释见后）

![面积交3](https://cdn.luogu.com.cn/upload/image_hosting/mrplawkt.png)

代码示例：

```cpp
/*结构体详细定义见后面完整代码*/

/*向逆时针旋转 90 度*/
inline vect2 rotateRA(vect2 v){ return vect2(-v.y, v.x); }

/*直线交点*/
inline vect2 getIntersection(line f, line g){
	vect2 w =g.v-f.u, F =f.v-f.u, G =g.v-g.u;
	return g.v+(g.u-g.v)*((F/w)/(F/G));
}

/*u 到 v 的逆时针夹角*/
inline db rad(vect2 u, vect2 v){ return atan2(u/v, u*v); }

inline db getArea_Circle_Rectangle(vect2 O /*圆心*/, db r, vect2 rtpre[]/*矩形四个顶点，左上角开始逆时针*/){
	vect2 rt[4];
	for(int i =0; i < 4; ++i) rt[i] =rtpre[i]-O;
	db S =0;
	for(int i =0; i < 4; ++i){
		vect2 rt1 =rt[i], rt2 =rt[(i+1)%4];
		db d =dist(line(rt1, rt2), vect2(0, 0));/*线段到圆心距离*/
		if(gtr(d, r))/*情况 1*/
			S +=r*r*rad(rt1, rt2)/2;
		else{
			/*与边同向的单位向量*/
			vect2 e =(rt2-rt1); e =e/e.m();
			/*垂线垂点*/
			vect2 pend =getIntersection(line(rt1, rt2), line(vect2(0, 0), rotateRA(e)));
			/*圆与矩形边交点，逆时针顺序，勾股算出*/
			db k =sqrt(r*r-d*d);
			vect2 sect1 =pend-e*k, sect2 =pend+e*k;
			/*两个顶点是否在圆外*/
			bool flg1 =gtr(rt1.m(), r), flg2 =gtr(rt2.m(), r);
			if(flg1 && flg2){/*情况 4*/
				if(gtr((rt1-pend)*(rt2-pend), 0)) S +=r*r*rad(rt1, rt2)/2;/*d < r 且线段和圆没有交点*/
				else S +=r*r*rad(rt1, sect1)/2+sect1/sect2/2+r*r*rad(sect2, rt2)/2;
			}
			else if(flg1)/*情况 2*/
				S +=r*r*rad(rt1, sect1)/2+sect1/rt2/2;
			else if(flg2)/*情况 2*/
				S +=rt1/sect2/2+r*r*rad(sect2, rt2)/2;
			else/*情况 3*/
				S +=rt1/rt2/2;
		}
	}
	return S;
}
```

&nbsp;

对于圆心不在矩形内的情况，由于我们采用的实现是 "**有向**" 的（例如向量叉积），这时有些顶点顺序会反过来，它们的贡献为负数。

再割补一下可以发现答案仍是正确的。

![面积交2](https://cdn.luogu.com.cn/upload/image_hosting/p7f7w56q.png)

### [4] 反演变换的性质

第一个被注记的地方提到的是反演变换的**保圆性**。

&nbsp;

这里再补充下反演变换较重要的两个性质：

1. 反演变换把圆周变成圆周。常称为反演变换的保圆性。

2. 两相交圆周在交点 $A$ 的夹角，等于它们的反演象圆周在相应点 $A'$ 的夹角，但方向相反。称为反演变换的反向保角性。

注意其中提到的圆周是 "广义" 的圆周。

具体来说，我们定义一个在无穷远的点，则一条直线的两端必在这一点相汇，于是一条直线也可以看成一个**圆周**。另外，拓展后，即使是两条平行的直线也是有交点的。这拓展主要是为了保证反演变换的 "对称性"。

---

## CODE

虽然讲起来很繁琐但代码思路还是很清晰的。

&nbsp;

### 扰动版：

（由于玄学精度问题**不保证**同样思路就能过）

```cpp
/*注译比较乱，还是建议看不扰动版的*/
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cmath>
#define db __float128
//#define db double
using std::pair;

const int MAXN =5000;

const db eps =1e-10;

/*------------------------------Computational geometry------------------------------*/

struct vect{
	db x, y, z;
	vect(){}
	vect(db xx, db yy, db zz):x(xx), y(yy), z(zz){}
	vect operator - (vect v){ return vect(x-v.x, y-v.y, z-v.z); }
	vect operator / (vect v){ return vect(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); }
	db operator * (vect v){ return x*v.x+y*v.y+z*v.z; }
	db m(){ return sqrt(x*x+y*y+z*z); }
	db rd2() {return (1.0*rand()/RAND_MAX)*eps;}
	db rd(){ return (rand()%2) ? eps : -eps; }
	void shake(){ x +=rd2(), y +=rd2(), z +=rd2(); }
}pts[MAXN];

struct plane{
	int v[3];
	plane(){}
	plane(int v1, int v2, int v3){ v[0] =v1, v[1] =v2, v[2] =v3; }
	vect normal(){ return (pts[v[1]]-pts[v[0]])/(pts[v[2]]-pts[v[0]]); }
};

inline bool gtr(db a, db b){ return (a-b > eps); }

inline bool eq(db a, db b){ return (a-b > -eps && a-b < eps); }

inline db dist(vect v, plane p){ return (p.normal()*(v-pts[p.v[0]]))/p.normal().m(); }

inline db dist(vect v, vect f1, vect f2){ return ((f2-f1)/(v-f1)).m()/(f2-f1).m(); }

inline bool isabove(vect v, plane p){ return gtr((v-pts[p.v[0]])*p.normal(), 0); }

/*------------------------------Convex Hulls------------------------------*/

int vise[MAXN][MAXN];
plane res[MAXN];

inline int getConvexHulls(int totp, plane facets[]){
	int s[4];
	s[0] =0, s[1] =1, s[2] =2, s[3] =3;
	if(gtr(0, dist(pts[s[3]], plane(s[0], s[1], s[2])))) s[1] ^=s[2] ^=s[1] ^=s[2];
	int totf =0;
	facets[totf++] =plane(s[0], s[2], s[1]);
	facets[totf++] =plane(s[0], s[1], s[3]);
	facets[totf++] =plane(s[1], s[2], s[3]);
	facets[totf++] =plane(s[2], s[0], s[3]);
	for(int i =4; i < totp; ++i){
		int totr =0;
		for(int j =0; j < totf; ++j){
			if(isabove(pts[i], facets[j]))
				for(int k =0; k < 3; ++k)
					vise[facets[j].v[k]][facets[j].v[(k+1)%3]] =i+1;
			else res[totr++] =facets[j];
		}
		totf =0;
		for(int j =0; j < totr; ++j){
			facets[totf++] =res[j];
			for(int k =0; k < 3; ++k)
				if(vise[res[j].v[(k+1)%3]][res[j].v[k]] == i+1)
					facets[totf++] =plane(res[j].v[(k+1)%3], res[j].v[k], i);
		}
	}
	return totf;
}

/*------------------------------Computational geometry 2D------------------------------*/

struct vect2{
	db x, y;
	vect2(){}
	vect2(db xx, db yy):x(xx), y(yy){}
	vect2 operator + (vect2 v){ return vect2(x+v.x, y+v.y); }
	vect2 operator - (vect2 v){ return vect2(x-v.x, y-v.y); }
	db operator / (vect2 v){ return x*v.y-y*v.x; }
	db operator * (vect2 v){ return x*v.x+y*v.y; }
	vect2 operator * (db k){ return vect2(x*k, y*k); }
	vect2 operator / (db k){ return vect2(x/k, y/k); }
	db m(){ return sqrt(x*x+y*y); }
};

struct line{
	vect2 u, v;
	db angle;
	line(){}
	line(vect2 uu, vect2 vv):u(uu), v(vv){ angle =atan2(vv.y-uu.y, vv.x-uu.x); }
};

typedef pair<vect2, db> pad;

inline vect2 getMidpoint(vect2 x, vect2 y){ return (x+y)/2; }

/*向逆时针旋转 90 度*/
inline vect2 rotateRA(vect2 v){ return vect2(-v.y, v.x); }

vect2 getIntersection(line f, line g){
	db w =((g.u-f.u)/(f.u-f.v))/((f.u-f.v)/(g.u-g.v));
	return g.u+(g.u-g.v)*w;
}

inline pad getCircle(vect2 pt1, vect2 pt2, vect2 pt3){
	vect2 mid1 =getMidpoint(pt1, pt2), mid2 =getMidpoint(pt1, pt3);
	line li1(mid1, mid1+rotateRA(pt2-pt1)), li2(mid2, mid2+rotateRA(pt3-pt1));
	vect2 sect =getIntersection(li1, li2);
	return pad(sect, (pt1-sect).m());
}

/*u 到 v 的逆时针夹角*/
inline db rad(vect2 u, vect2 v){ return atan2(u/v, u*v); }

inline db fabs(db x){ return (x < 0) ? -x : x; }

inline db dist(line f, vect2 w){ return fabs((w-f.u)/(f.v-f.u)/(f.v-f.u).m()); }

inline db getArea_Circle_Rectangle(db r, vect2 O /*圆心*/, vect2 vpre[]){
	vect2 v[4];
	for(int i =0; i < 4; ++i)
		v[i] =vpre[i]-O;
	db S =0;
	for(int i =0; i < 4; ++i){
		db d =dist(line(v[i], v[(i+1)%4]), vect2(0, 0));
		if(gtr(d, r))
			S +=r*r*rad(v[i], v[(i+1)%4])/2;
		else{
			/*与边同向的单位向量*/
			vect2 e =(v[(i+1)%4]-v[i]); e =e/e.m();
			/*vertical line 中垂线*/
			vect2 vtc =getIntersection(line(v[i], v[(i+1)%4]), line(vect2(0, 0), rotateRA(e)));
			/*圆与矩形边交点，逆时针顺序*/
			db k =sqrt(r*r-d*d);/*勾股*/
			vect2 sect1 =vtc-e*k, sect2 =vtc+e*k;
			bool flg1 =gtr(v[i].m(), r), flg2 =gtr(v[(i+1)%4].m(), r);
			if(flg1 && flg2){
				/*上面是 d < r 且线段和圆没有交点*/
				if(gtr((v[i]-vtc)*(v[(i+1)%4]-vtc), 0)) S +=r*r*rad(v[i], v[(i+1)%4])/2;
				else S +=r*r*rad(v[i], sect1)/2+sect1/sect2/2+r*r*rad(sect2, v[(i+1)%4])/2;
			}
			else if(flg1)
				S +=r*r*rad(v[i], sect1)/2+sect1/v[(i+1)%4]/2;
			else if(flg2)
				S +=v[i]/sect2/2+r*r*rad(sect2, v[(i+1)%4])/2;
			else
				S +=v[i]/v[(i+1)%4]/2;
		}
	}
	return S;
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return (f) ? -x : x;
}

plane facets[MAXN];
vect2 rect[4];/*jtkl*/

int main(){
	int n =read();
	if(n == 3) return putchar('3') && 0;/*求不出凸包的*/
	db x1 =read(), y1 =read(), x2 =read(), y2 =read();
	/*从矩形左上角开始的逆时针四个点*/
	rect[0] =vect2(x1, y2), rect[1] =vect2(x1, y1), rect[2] =vect2(x2, y1), rect[3] =vect2(x2, y2);
	for(int i =0; i < n; ++i){
		db a =read(), b =read();
		pts[i] =vect(a, b, a*a+b*b);
		pts[i].shake();
	}
	int h =getConvexHulls(n, facets);
	db ans =0, Sr =(x2-x1)*(y2-y1);
	for(int i =0; i < h; ++i){
		vect v[3];
		v[0] =pts[facets[i].v[0]], v[1] =pts[facets[i].v[1]], v[2] =pts[facets[i].v[2]];
		pad c =getCircle(vect2(v[0].x, v[0].y), vect2(v[1].x, v[1].y), vect2(v[2].x, v[2].y));
		if(facets[i].normal().z > 0)/*不能用 gtr(), 玄学之处（*/
			ans +=getArea_Circle_Rectangle(c.second, c.first, rect)/Sr;
		else
			ans +=(Sr-getArea_Circle_Rectangle(c.second, c.first, rect))/Sr;
	}
	printf("%.8lf\n", (double)(2*n-2-ans));
}
```

&nbsp;

### 非扰动版：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
//#pragma GCC optimize(2)
//#define db __float128
//#define db long double
#define db double
using std::pair;
using std::sort;

const int MAXN =2500;

/*------------------------------Computational geometry------------------------------*/

const db eps =1e-9;

inline bool gtr(db a, db b){ return (a-b > eps); }

inline bool eq(db a, db b){ return (a-b > -eps && a-b < eps); }

/*------------------------------Computational geometry 3D------------------------------*/

struct vect{
	db x, y, z;
	vect(){}
	vect(db xx, db yy, db zz):x(xx), y(yy), z(zz){}
	vect operator - (vect v){ return vect(x-v.x, y-v.y, z-v.z); }
	vect operator / (vect v){ return vect(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); }
	db operator * (vect v){ return x*v.x+y*v.y+z*v.z; }
	db m(){ return sqrt(x*x+y*y+z*z); }
}pts[MAXN];

struct plane{
	int v[3];
	plane(){}
	plane(int v1, int v2, int v3){ v[0] =v1, v[1] =v2, v[2] =v3; }
	vect normal(){ return (pts[v[1]]-pts[v[0]])/(pts[v[2]]-pts[v[0]]); }
};

/*有向距离*/
inline db dist(vect v, plane p){ return p.normal()*(v-pts[p.v[0]])/p.normal().m(); }

inline db dist(vect v, vect f1, vect f2){ return ((f2-f1)/(v-f1)).m()/(f2-f1).m(); }

inline bool isabove(vect v, plane p){ return gtr((v-pts[p.v[0]])*p.normal(), 0); }

/*------------------------------Convex Hulls------------------------------*/

int vise[MAXN][MAXN];
plane res[MAXN<<1], del[MAXN<<1];

inline int getConvexHulls(int totp, plane facets[]){
	int s[4];
	s[0] =0, s[1] =1, s[2] =0, s[3] =0;
	while(eq(dist(pts[s[2]], pts[s[0]], pts[s[1]]), 0)) ++s[2];
	while(s[3] < totp && eq(dist(pts[s[3]], plane(s[0], s[1], s[2])), 0)) ++s[3];
	if(s[3] == totp) return -1;
	if(gtr(0, dist(pts[s[3]], plane(s[0], s[1], s[2])))) s[1] ^=s[2] ^=s[1] ^=s[2];
	int totf =0;
	facets[totf++] =plane(s[0], s[2], s[1]);
	facets[totf++] =plane(s[0], s[1], s[3]);
	facets[totf++] =plane(s[1], s[2], s[3]);
	facets[totf++] =plane(s[2], s[0], s[3]);
	for(int i =0; i < totp; ++i){
		if(i == s[0] || i == s[1] || i == s[2] || i == s[3]) continue;
		int totr =0, totd =0;
		for(int j =0; j < totf; ++j){
			if(!isabove(pts[i], facets[j])) res[totr++] =facets[j];
			else{
				del[totd++] =facets[j];
				for(int k =0; k < 3; ++k)
					vise[facets[j].v[k]][facets[j].v[(k+1)%3]] =i+1;
			}
		}
		for(int j =0; j < totd; ++j){
			plane f =del[j];
			for(int k =0; k < 3; ++k)
				if(vise[f.v[k]][f.v[(k+1)%3]] == i+1 && vise[f.v[(k+1)%3]][f.v[k]] != i+1)
					res[totr++] =plane(f.v[k], f.v[(k+1)%3], i);
		}
		totf =totr;
		for(int j =0; j < totr; ++j) facets[j] =res[j];
	}
	return totf;
}

/*------------------------------Computational geometry 2D------------------------------*/

struct vect2{
	db x, y;
	vect2(){}
	vect2(db xx, db yy):x(xx), y(yy){}
	vect2 operator + (vect2 v){ return vect2(x+v.x, y+v.y); }
	vect2 operator - (vect2 v){ return vect2(x-v.x, y-v.y); }
	db operator / (vect2 v){ return x*v.y-y*v.x; }
	db operator * (vect2 v){ return x*v.x+y*v.y; }
	vect2 operator * (db k){ return vect2(x*k, y*k); }
	vect2 operator / (db k){ return vect2(x/k, y/k); }
	db m(){ return sqrt(x*x+y*y); }
	db m2(){ return x*x+y*y; }
};
typedef pair<vect2, db> pad;

struct line{
	vect2 u, v;
	db angle;
	line(){}
	line(vect2 uu, vect2 vv):u(uu), v(vv){ angle =atan2(vv.y-uu.y, vv.x-uu.x); }
};

inline vect2 getMidpoint(vect2 x, vect2 y){ return (x+y)/2; }

/*向逆时针旋转 90 度*/
inline vect2 rotateRA(vect2 v){ return vect2(-v.y, v.x); }

inline vect2 getIntersection(line f, line g){
	vect2 w =g.v-f.u, F =f.v-f.u, G =g.v-g.u;
	return g.v+(g.u-g.v)*((F/w)/(F/G));
}

/*u 到 v 的逆时针夹角*/
inline db rad(vect2 u, vect2 v){ return atan2(u/v, u*v); }

inline db fabs(db x){ return (x < 0) ? -x : x; }

/*无向距离*/
inline db dist(line f, vect2 w){ return fabs((w-f.u)/(f.v-f.u)/(f.v-f.u).m()); }

inline pad getCircle(vect2 pt1, vect2 pt2, vect2 pt3){
	vect2 mid1 =getMidpoint(pt1, pt2), mid2 =getMidpoint(pt1, pt3);
	line li1(mid1, mid1+rotateRA(pt2-pt1)), li2(mid2, mid2+rotateRA(pt3-pt1));
	vect2 sect =getIntersection(li1, li2);
	return pad(sect, (pt1-sect).m());
}

inline db getArea_Circle_Rectangle(vect2 O /*圆心*/, db r, vect2 rtpre[]/*矩形四个顶点，左上角开始逆时针*/){
	vect2 rt[4];
	for(int i =0; i < 4; ++i) rt[i] =rtpre[i]-O;
	db S =0;
	for(int i =0; i < 4; ++i){
		vect2 rt1 =rt[i], rt2 =rt[(i+1)%4];
		db d =dist(line(rt1, rt2), vect2(0, 0));/*线段到圆心距离*/
		if(gtr(d, r))
			S +=r*r*rad(rt1, rt2)/2;
		else{
			/*与边同向的单位向量*/
			vect2 e =(rt2-rt1); e =e/e.m();
			/*垂线垂点*/
			vect2 pend =getIntersection(line(rt1, rt2), line(vect2(0, 0), rotateRA(e)));
			/*圆与矩形边交点，逆时针顺序，勾股算出*/
			db k =sqrt(r*r-d*d);
			vect2 sect1 =pend-e*k, sect2 =pend+e*k;
			/*两个顶点是否在圆外*/
			bool flg1 =gtr(rt1.m(), r), flg2 =gtr(rt2.m(), r);
			if(flg1 && flg2){
				/*d < r 且线段和圆没有交点*/
				if(gtr((rt1-pend)*(rt2-pend), 0)) S +=r*r*rad(rt1, rt2)/2;
				else S +=r*r*rad(rt1, sect1)/2+sect1/sect2/2+r*r*rad(sect2, rt2)/2;
			}
			else if(flg1)
				S +=r*r*rad(rt1, sect1)/2+sect1/rt2/2;
			else if(flg2)
				S +=rt1/sect2/2+r*r*rad(sect2, rt2)/2;
			else
				S +=rt1/rt2/2;
		}
	}
	return S;
}

inline bool onright(line f, vect2 w){ return gtr((w-f.u)/(f.v-f.u), 0); }

int cmp(line A, line B){
	if(eq(A.angle, B.angle)) return onright(B, A.u);
	else return (gtr(B.angle, A.angle));
}

inline db getArea_Plane_Rectangle(plane p, vect2 rt[]){
	vect rt1(rt[0].x, rt[0].y, 0), rt2(rt[1].x, rt[1].y, 0),
		 rt3(rt[2].x, rt[2].y, 0), rt4(rt[3].x, rt[3].y, 0);
	bool flg1 =isabove(rt1, p), flg2 =isabove(rt2, p),
		 flg3 =isabove(rt3, p), flg4 =isabove(rt4, p);
	double Sr =(rt[3].x-rt[1].x)*(rt[3].y-rt[1].y);
	if(flg1 && flg2 && flg3 && flg4) return 0;/*这个判断使执行下面代码时是有交的*/
	else if((!flg1) && (!flg2) && (!flg3) && (!flg4)) return Sr;
	else{
		line li(vect2(pts[p.v[0]].x, pts[p.v[0]].y), vect2(pts[p.v[1]].x, pts[p.v[1]].y));
		/*使得最后求出的面积包含左上角顶点*/
		if(onright(li, rt[0])) li =line(li.v, li.u);
		line ls[5];
		for(int i =0; i < 4; ++i) ls[i] =line(rt[i], rt[(i+1)%4]);
		ls[4] =li;
		/*半平面交，直接把函数嵌入了*/
		sort(ls, ls+5, cmp);
		line stk[6];
		int l =0, r =0;
		for(int i =0; i < 5; ++i){
			while(i < 4 && eq(ls[i].angle, ls[i+1].angle)) ++i;
			while(r-l > 1 && onright(ls[i], getIntersection(stk[r-1], stk[r-2]))) --r;
			stk[r++] =ls[i];
		}
		/*这种做法可以见我博客*/
		while(r-l > 1){
			if(onright(stk[r-1], getIntersection(stk[l], stk[l+1]))) ++l;
			else if(onright(stk[l], getIntersection(stk[r-1], stk[r-2]))) --r;
			else break;
		}
		line hull[6];
		int h =0;
		for(int i =l; i < r; ++i) hull[h++] =stk[i];
		/*求多边形面积，嵌入*/
		hull[h++] =hull[0];
		db S =0;
		vect2 v0 =getIntersection(hull[0], hull[1]), v1, v2 =getIntersection(hull[1], hull[2]);
		for(int i =0; i+3 < h; ++i){
			v1 =v2, v2 =getIntersection(hull[i+2], hull[i+3]);
			S +=(v1-v0)/(v2-v1)/2;
		}
		/*根据左上角顶点是否在平面内判断返回哪一半的矩形面积*/
		if(flg1) return Sr-S;
		else return S;
	}
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return (f) ? -x : x;
}

plane facets[MAXN<<1];
vect2 jtkl[4];/*九条可怜(*/

int main(){
	int n =read();
	db x1 =read(), y1 =read(), x2 =read(), y2 =read();
	/*从左上角开始逆时针*/
	jtkl[0] =vect2(x1, y2), jtkl[1] =vect2(x1, y1),
	jtkl[2] =vect2(x2, y1), jtkl[3] =vect2(x2, y2);
	for(int i =0; i < n; ++i){
		db a =read(), b =read();
		pts[i] =vect(a, b, a*a+b*b);/*注意如果 a, b 都是 int 这里还不转类型会炸精度*/
	}
	int h =getConvexHulls(n, facets);
	if(h == -1) return printf("%d", n) && 0;
	db ans =0, Sr =(x2-x1)*(y2-y1);
	int cnt =0;
	for(int i =0; i < h; ++i){
		vect N =facets[i].normal();
		if(eq(N.z, 0))
			ans +=getArea_Plane_Rectangle(facets[i], jtkl)/Sr, ++cnt;
		else{
			vect v[3];
			v[0] =pts[facets[i].v[0]], v[1] =pts[facets[i].v[1]], v[2] =pts[facets[i].v[2]];
			pad c =getCircle(vect2(v[0].x, v[0].y), vect2(v[1].x, v[1].y), vect2(v[2].x, v[2].y));
			if(gtr(N.z, 0))
				ans +=getArea_Circle_Rectangle(c.first, c.second, jtkl)/Sr;
			else
				ans +=(Sr-getArea_Circle_Rectangle(c.first, c.second, jtkl))/Sr;
		}
	}
	printf("%.8lf", 2*n-2-ans);
}
```

话说第二份代码在 loj 跑了个时间 [rk1](https://loj.ac/problem/2530/statistics/fastest) QWQ（其中还有一些玄学优化（例如求凸包循环部分））

但 luogu 评测机比较玄学好像不太好跑排名...（其实也有一部分原因是 loj 的评测机浮点运算比较快...

---


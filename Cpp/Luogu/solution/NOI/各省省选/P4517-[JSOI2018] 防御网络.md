# [JSOI2018] 防御网络

## 题目描述

虽然成功得到了外星人的进攻计划，但 ``JYY`` 意外地发现,外星母舰对地球的攻击竟然是随机的！必须尽快在地球上部署防御网络,抵御外星人母舰的攻击。
地球上的防御网络由节点和节点之间的能量连接组成,防御网络可以看成是一个 $n$ 个点、 $m$ 条边的简单无向图 $G(V,E)$ ,每个防御节点对应 $V$ 中的一个节点、每个能量连接对应 $E$ 中的一条边。此外,在防御网络修建时考虑到能量传输效率，防御网络 $G$ 中**每个节点至多只包含在一个简单环中**。

外星母舰的攻击是随机的，每次攻击开始后， ``JYY`` 都会本次攻击的情况选择一些防御节点 $S\subseteq V$ ，并且用能量连接将这些防御节点连通，从而启动一个防御子网络。换言之， ``JYY`` 会选择 $G$ 中边集的一个子集 $H(S)\subseteq E$ ,它满足:

1.    (防御子网络**连通**) 如果我们建立新图 $G'(V,H(S))$ ，即用 $H(S)$ 中的边连接 $G$ 中的节点，则对于任意选择的防御节点 $x,y\in S$ ，它们在 $G'$​​ 中都连通。

2.    (防御子网络**最小**) 在满足条件 1 (防御子网络连通)的前提，选取的边数最小，即 $\vert H(S)\vert$ 最小。

$H(S)$ 是点集 $S$ 在图 $G$ 生成的斯坦纳树 (Steiner Tree) ，而 $\vert H(S)\vert$ 则是启动防御子网络的最小代价。考虑到外星母舰随机攻击的方式， ``JYY`` 希望你计算启动防御子网络代价的**期望**:

$$\frac{1}{2^{\vert V\vert}}\sum_{S\subseteq V}\vert H(S)\vert$$

## 说明/提示

**样例解释**

样例输入 1 是一条链，包含以下情况:

1.    $\{\}, \{1\}, \{2\}, \{3\},\vert H(S)\vert = 0$ ;
2.    $\{1, 2\}, \{2, 3\}, \vert H(S)\vert = 1$ ;
3.    $\{1, 3\}, \{1, 2, 3\}, \vert H(S)\vert = 2$ 。

因此 $P/Q=3/4$ ， $P\cdot Q^{-1} = 750,000,006$ 。

样例输入 2 中 $\sum_{S\subseteq V}\vert H(S)\vert = 174$ ，因此 $P/Q=87/32$ ， $P⋅Q^{-1}=468,750,006 \text{ mod 1,000,000,007}$ 。

**数据范围**

对于 $20\%$ 的数据,有 $1\le n\le 8$ 。

对于 $40\%$ 的数据,有 $1\le n\le 20$ 。

对于 $100\%$ 的数据,有 $1\le n\le 200$ 。

## 样例 #1

### 输入

```
3 2
1 2
2 3```

### 输出

```
750000006```

## 样例 #2

### 输入

```
6 6
1 2
2 3
3 1
1 4
2 5
3 6```

### 输出

```
468750006```

# 题解

## 作者：shadowice1984 (赞：12)

我们考虑贡献……

_______________

# 本题题解

首先众所周知的是一般图的斯坦纳树是只能大力状压dp的……

但是这是一颗点仙人掌，情况会变的有趣很多……

还是一个非常传统的套路叫做考虑贡献

直接$O(2^n)$的枚举点集求出合法的边集可能不是非常好做……

但是如果我们考虑某一个边$(u,v)$在多少个点集的斯坦纳树当中出现了情况会怎样呢？
________________________

### case1:$(u,v)$是割边

此时我们割掉这个边会产生两个联通块

我们发现如果点集全部落在同一个联通块的时候，这个边一定不会在斯坦纳树当中出现(因为没有点需要借助这个边来联通)，但是如果这个点集有一部分在左边另一部分在右边，由于我们至少需要保证左右是联通的，因此这条边一定出现在斯坦树当中

所以斯坦纳树包含边$(u,v)$的点集一共有$(2^{siz}-1)(2^{n-siz}-1)$种(siz为其中一个联通块的点数)(左边合法方案×右边合法方案)

那么我们可以先使用tarjan算法找出所有的割边然后把它们的贡献先算了

### case2:$(u,v)$是环边

此时直接考虑$(u,v)$的贡献不是非常方便了，我们考虑直接把整个环的贡献算出来

我们割掉这个环上的边(注意不是点！)会产生好几个联通块

那么我们发现如果点集落在同一个联通块当中的话环上的边都不会出现在斯坦纳树当中

如果有若干个子联通块中的点被选中了的话，这些点想要联通至少需要先到环上，换句话说每个子联通块可以缩到环上的一个点上。(如果子联通块中的点被选中我们就认为环上的点被选中)

那么缩完点之后我们会发现把这些点联通的唯一方式就是用一条链把这些点串起来，换个角度看就是假如环上有k个点被选中，相邻两个点之间会产生k条路径，我们把这k条路径中的最大值切掉，剩下的长链就是最小的代价了，也就是说，这条长链将会出现在斯坦纳树当中

所以我们考虑计算每一条长度为k的长链的贡献，换句话说我们要计算有多少点集的斯坦纳树存在一条在环上的长度为k的长链

__________________

那么我们尝试使用动态规划解决这个问题

(以下的点集指的是缩点之后的点集)

先破环为链，然后设$Dp_{i,j}$为选中的点中最右点为i，两两路径的最大值为k的点集方案数(不考虑最左点和最右点之间的路径)

此时我们遇到了一个很麻烦的问题，我们没法从一个状态当中知道相邻两个点路径，因为我们的状态里并没有记录最左点和最右点之间的路径长度，而记了我们就没有办法转移(因为你把最右点拓展出去之后最左点和最右点的路径长度在缩短……，然后你就不知到你记的最大值是不是真的最大值了)

数据范围只有200,所以给状态再加上一维，$Dp_{i,j,k}$表示最左点为i，最右点为j，不考虑i，j之间的路径情况下两两间路径最大值为k的点集数量

那么$Dp_{i,j,k}$对答案的贡献就是(环长-max(k,环长+i-j))×$Dp_{i,j,k}$了

那么怎么转移呢？

当然是暴力枚举上一个最右点的位置了……

所以转移方程大概长这样……$siz_{j}$表示割掉j的左右环边之后剩下的联通块点的个数

## $Dp_{i,j,k}=(2^{siz_{j}}-1)(\sum_{p=0}^{k}Dp_{i,j-k,p}+\sum_{p=j-k+1}^{j-1}Dp_{i,p,k})$

第一部分是j和上一个点的路径长度恰好等于k的情况(此时上一个点的最大值可以任取)，第二部分是j和上一个点的路径长度小于k的情况(此时上一个点的最大值只能为k)

你发现转移方程里面的两个$\Sigma$是可以使用前缀和表示的形式(一个是行的前缀和，另一个是列的前缀和)

那么我们真实dp的时候只需要记录前缀和数组就行了，dp值现场计算，现场算贡献，现场更新前缀和就可以了

_______________

## 实现

实现的时候可能会有一点小trick

首先先使用tarjan求出所有的割边，然后把这个割边标记一下

发现一件事情是割边一定是你这张图的dfs树的树边，因此我们可以处理出来割掉割边$(u,v)$之后u所在联通块的siz和v所在联通块的siz
分别存储在(u->v)当中和(v->u)当中

然后我们要统计割掉环之后的siz的话我们可以枚举环上的点的每一个出边的割边，然后就可以统计siz了

关于寻找环的话由于我们需要按照相邻两个点有连边的顺序把环中的点拉出来，所以删去所有割边之后dfs即可提取出环
另外就是我们寻找环的时候可能需要把环中的点拉出来塞到一个队列里大力dp，注意重新编号的问题。

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=210;const int E=1e3+10;typedef long long ll;const ll mod=1e9+7;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}int siz[N];
int n;int m;int v[E];int x[E];int ct=1;int al[N];int low[N];int dfn[N];int df;bool book[E];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}ll res;bool mrk[N];int w[E];
inline int tarjan(int u,int f)//tarjan找割边
{
    dfn[u]=low[u]=++df;siz[u]=1;
    for(int i=al[u];i;i=x[i])
    {
        if(v[i]==f)continue;
        if(dfn[v[i]]==0){low[u]=min(low[u],tarjan(v[i],u));siz[u]+=siz[v[i]];}
        else {low[u]=min(low[u],dfn[v[i]]);}
        if(low[v[i]]>dfn[u])
        {
            book[i]=book[i^1]=true;res+=(po(2,siz[v[i]])-1)*(po(2,n-siz[v[i]])-1);
            w[i]=siz[v[i]];w[i^1]=n-siz[v[i]];
        }
    }return low[u];
}
inline int nxt(int p)//找环上的后继
{for(int i=al[p];i;i=x[i])if(book[i]==false&&mrk[v[i]]==false)return v[i];return 0;}
ll sum1[N][N];ll sum2[N][N];int q[N];int hd;ll val[N];
inline void solve(int st)//dp
{
    for(int p=st;p;p=nxt(p))q[++hd]=p,mrk[p]=true;if(hd==1){hd=0;return;}
    for(int i=1;i<=hd;i++)val[i]=1;
    for(int i=1;i<=hd;i++)for(int j=al[q[i]];j;j=x[j])val[i]+=w[j];
    for(int i=1;i<=hd;i++)val[i]=po(2,val[i])-1;
    for(int i=1;i<hd;i++)
    {
        for(int j=0;j<=hd;j++)sum2[i][j]=val[i];
        for(int j=i+1;j<=hd;j++)//注意前缀和
            for(int k=1;k<=hd;k++)
            {
                ll dp=0;if(j-k>=i)
                {
                    dp=(sum2[j-k][k]+sum1[j-1][k]+mod-sum1[j-k][k])*val[j]%mod;
                    int mx=max(hd-j+i,k);(res+=dp*(hd-mx))%=mod;
                }sum1[j][k]=(sum1[j-1][k]+dp)%mod;sum2[j][k]=(sum2[j][k-1]+dp)%mod;
            }
        for(int j=i;j<=hd;j++)for(int k=0;k<=hd;k++)sum1[j][k]=0;
        for(int j=i;j<=hd;j++)for(int k=0;k<=hd;k++)sum2[j][k]=0;
    }hd=0;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,u,v;i<=m;i++){scanf("%d%d",&u,&v);add(u,v);add(v,u);}tarjan(1,0);
    for(int i=1;i<=n;i++){if(!mrk[i])solve(i);}printf("%lld",res*po(po(2,n),mod-2)%mod);
    return 0;//拜拜程序
}
```












---

## 作者：Alex_Wei (赞：4)

> [P4517 [JSOI2018] 防御网络](https://www.luogu.com.cn/problem/P4517)

考虑 $G$ 是树，根据期望线性性以及各边独立性将贡献分摊至每条边。

$S$ 固定时，$|H(S)|$ 等于 $S$ 张成的虚树大小。设 $e = (u, v)$ 两端子树大小分别为 $x$ 和 $y$，则 $e = (u, v)$ 被选中当且仅当 $u, v$ 子树内存在点属于 $S$，情况数为 $(2 ^ x - 1)(2 ^ y - 1)$。

考虑 $G$ 是基环树。将贡献分摊至每条边与唯一的环。给环 $C$ 上的点依次标号为 $1, 2, \cdots, |C|$。

$S$ 固定时，每条非环边产生贡献当且仅当其两端子图均存在属于 $S$ 的点。环稍显棘手，其贡献为连通「子树内存在点属于 $S$」的环点的最小代价。称环点被点亮当且仅当子树内存在点属于 $S$，易知贡献为环长减去最远的相邻两个被点亮环点的距离。

据此，枚举该距离 $L$，枚举编号最小的被点亮的点 $p$ 破环成链，容易设计 DP $f_{i, 0 / 1}$ 表示考虑到前 $i$ 个环点，当 $i$ 被点亮且是否存在相邻两个被点亮的环点相距 $L$ 时的总方案数。初始值 $f_{p, 0} = 1$，转移依次枚举 $i \in [p + 1, |C|]$，
$$
\begin{aligned}
f_{i, 0} & = v_i \sum\limits_{j = i - L + 1} ^ i f_{j, 0} \\
f_{i, 1}&  = v_i \left(f_{i - L, 0} + \sum\limits_{j = i - L} ^ i f_{j, 1} \right)
\end{aligned}
$$
其中 $v_i = 2 ^ {|\mathrm{subtree}(i)|} - 1$，环点 $i$ 子树存在点属于 $S$ 的方案数。

每个 $f_{i, 0}$ 和 $f_{i, 1}$ 以 $i$ 作为编号最大的被点亮的环点的形式贡献至答案。根据实际意义，$p + |C| - i \leq L$ 时 $f_{i, 1}$ 贡献至答案，$p + |C| - i = L$ 时 $f_{i, 0}$ 贡献至答案。贡献系数为 $|C| - L$。

- 仅求出 $F_L$ 表示所有相邻被点亮的环点距离不超过 $L$ 的方案数，则 $F_L - F_{L - 1}$ 等于最长相邻被点亮环点距离为 $L$ 的方案数。这样可以省去第二维。

朴素 DP 时间复杂度 $\mathcal{O}(n ^ 2)$。算上枚举的两个值，总复杂度 $\mathcal{O}(n ^ 4)$。使用前缀和优化即可做到 $\mathcal{O}(n ^ 3)$。

当 $G$ 是仙人掌时，每个环贡献独立。用圆方树求得图上所有环，对每个环类似基环树一样做即可。时间复杂度 $\mathcal{O}(n ^ 3)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int N = 400 + 5;
constexpr int mod = 1e9 + 7;
void add(int &x, int y) {x += y, x >= mod && (x -= mod);}
int ksm(int a, int b) {
  int s = 1;
  while(b) {
    if(b & 1) s = 1ll * s * a % mod;
    a = 1ll * a * a % mod, b >>= 1;
  }
  return s;
}
int n, m, ans, node;
vector<int> e[N], g[N];
int dn, dfn[N], low[N], stc[N], top;
void tarjan(int id) {
  dfn[id] = low[id] = ++dn, stc[++top] = id;
  for(int it : e[id]) {
    if(!dfn[it]) {
      tarjan(it), low[id] = min(low[id], low[it]);
      if(low[it] >= dfn[id]) {
        g[++node].push_back(id);
        g[id].push_back(node);
        for(int x = 0; x != it; ) {
          x = stc[top--];
          g[node].push_back(x);
          g[x].push_back(node);
        }
      }
    }
    else low[id] = min(low[id], dfn[it]);
  }
}
int find(int id, int ff) {
  int sz = id <= n;
  for(int it : g[id]) if(it != ff) sz += find(it, id);
  return sz;
}
bool Med;
int main() {
  // cout << 597656258ll * 256 % mod << endl;
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  cin >> n >> m, node = n;
  for(int i = 1; i <= m; i++) {
    int x, y;
    cin >> x >> y;
    e[x].push_back(y), e[y].push_back(x);
  }
  tarjan(1);
  for(int i = n + 1; i <= node; i++) {
    static long long val[N];
    int m = g[i].size();
    for(int j = 1; j <= m; j++) val[j] = ksm(2, find(g[i][j - 1], i)) - 1;
    if(m == 2) { // 一条边
      ans = (ans + val[1] * val[2]) % mod;
      continue;
    }
    for(int L = 1; L < m; L++)
      for(int p = 1; p <= L; p++) {
        static int f[N][2], s[N][2];
        memset(f, 0, sizeof(f));
        memset(s, 0, sizeof(s));
        f[p][0] = s[p][0] = val[p];
        for(int q = p + 1; q <= m; q++) {
          f[q][0] = s[q][0] = s[q - 1][0];
          f[q][1] = s[q][1] = s[q - 1][1];
          if(q >= L) add(f[q][0], mod - s[q - L][0]);
          if(q >= L + 1) add(f[q][1], mod - s[q - L - 1][1]);
          if(q >= L) add(f[q][1], f[q - L][0]);
          f[q][0] = f[q][0] * val[q] % mod;
          f[q][1] = f[q][1] * val[q] % mod;
          add(s[q][0], f[q][0]);
          add(s[q][1], f[q][1]);
          int cyc = p + m - q;
          if(cyc <= L) {
            add(ans, 1ll * (m - L) * f[q][1] % mod);
            if(cyc == L) add(ans, 1ll * (m - L) * f[q][0] % mod);
          }
        }
      }
  }
  cout << 1ll * ans * ksm(ksm(2, n), mod - 2) % mod << endl;
  return cerr << "Time: " << clock() << "\n", 0;
}
/*
2022/7/6
start thinking at 8:28
根据期望的线性性，把贡献摊到每条边 / 每个环上。
每条边的贡献显然好算。
每个环的贡献考虑给定 S 怎么做。
仅关心当前环，变成基环树，设环上一个点被点亮当且仅当其子树内有属于 S 的点。
答案是环长减去环上最远的两个被点亮的点的距离。
枚举这个距离，再破环成链枚举第一个点，随便 DP 再前缀和优化一下就做完了吧？
黑牌咋这么简单（
start coding at 8:38
finish debugging at 9:21
犯了一个铸币错误。。。m 打成 n 咧。
*/
```

---

## 作者：FunnyCreatress (赞：2)

~~题目很友好啊，居然保证了仙人掌的环没有交点~~

显然是考虑每条边的贡献，我们将边分为两类讨论：

第一种情况，边为树边 (即删去后不连通)，那么这条边出现的条件显然是删去后两端点所在连通块各至少选了一个点。

第二种情况，边为环边 (即删去后仍然连通)，发现单独算不是很好算，于是把整个环拿出来一起算。

对于一个环，不妨记环上点顺时针依次为 $1...l$，将环删去后所在连通块大小分别为 $s_{1...l}$。注意到如果 $x$ 所在连通块里选择了一个点，那么就相当于选了 $x$。对于一种选点情况 $S$，记 $S_i$ 为 $S$ 中第 $i$ 小的数，特别地，令 $S_{|S|+1}=S_1$，那么连通这个环上所有点需要的边数就是
$$l-\max_{i=1...|S|}\{dis(S_i,S_{i+1})\}$$
其中 $dis(x,y)$ 为 $x$ 顺时针走到 $y$ 走过的边数。

差分一下，得到
$$\sum_{i=1}^l[\max_{i=1...|S|}\{dis(S_i,S_{i+1})\}<i]$$
然后就可以愉快的 DP 了，设 $f_{i,j,k}$ 为满足 $j=S_1,k=S_{|S|}$ 及 $\max_{i=1...|S|-1}\{dis(S_i,S_{i+1})\}<i$ 的方案数。

那么有
$$f_{i,j,k}=(2^{S_k}-1)\sum_{l=k-i+1}^{k-1}f_{i,j,l}$$
随便优化一下就可以变成 $O(n^3)$ 的，统计答案时只要统计 $l-k+j<i$ 的所有 $f_{i,j,k}$ 即可。

由于出题人的善良，识别环和统计连通块大小等等一些操作都可以直接在 dfs 树上通过简单计算得到而不必考虑一些细节，详见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2005,P=1e9+7;
int n,m,tot,hd[N],nxt[N],to[N],fa[N],cnt,sz[N],s[N],ans,pw[N],f[205][205];bool vst[N],nr[N];
void add(int x,int y){to[++tot]=y,nxt[tot]=hd[x],hd[x]=tot;}
int qpow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%P,y>>=1)
		if(y&1)res=1ll*res*x%P;
	return res;
}
void dfs(int x,int Fa){
	fa[x]=Fa,vst[x]=sz[x]=1;
	for(int i=hd[x],y;i;i=nxt[i])
		if(!vst[y=to[i]])dfs(y,x),sz[x]+=sz[y];
}
int add_mod(int x,int y){return (x+=y)>=P?x-P:x;}
void solve(){
	for(int i=1;i<=cnt;i++){
		for(int j=1,tmp;j<=cnt;j++){
			fill(f[j],f[j]+cnt+1,0);
			f[j][j]=pw[s[j]]-1,tmp=0;
			for(int k=j+1;k<=cnt;k++){
				tmp=add_mod(tmp,f[j][k-1]);
				if(k-j>=i)tmp=add_mod(tmp,P-f[j][k-i]);
				f[j][k]=1ll*(pw[s[k]]-1)*tmp%P;
			}
		}
		for(int j=1;j<=cnt;j++)
			for(int k=j;k<=cnt;k++)
				if(cnt-k+j<i)ans=add_mod(ans,f[j][k]);
	}
}
void dfs2(int x){
	vst[x]=1;
	for(int i=hd[x],y;i;i=nxt[i])if((y=to[i])!=fa[x]){
		if(vst[y]&&!nr[y]){
			s[cnt=1]=sz[x];
			int j=fa[x],k=x;
			for(;j!=y;k=j,j=fa[j])
				nr[k]=1,s[++cnt]=sz[j]-sz[k];
			nr[k]=1,s[++cnt]=n-sz[k];
			nr[y]=0,solve();
		}
		else if(!vst[y])dfs2(y);
	}
	if(x!=1&&!nr[x])ans=(ans+1ll*(pw[sz[x]]-1)*(pw[n-sz[x]]-1))%P;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=pw[0]=1;i<=n;i++)pw[i]=(pw[i-1]<<1)%P;
	for(int i=1,x,y;i<=m;i++)scanf("%d%d",&x,&y),add(x,y),add(y,x);
	dfs(1,0),fill(vst,vst+n+1,0),dfs2(1);
	printf("%d\n",1ll*ans*qpow(2,P-1-n)%P);
	return 0;
}
```

---

## 作者：yybyyb (赞：2)

显然图是仙人掌。  
题目给了斯坦纳树就肯定不是斯坦纳树了，，，，  
总不可能真让你$2^n$枚举点集再来一个至少$2^n*n $的斯坦纳树吧。。。
现在对于每一条边考虑贡献。  
如果这条边是不在环内，那么这条边被选当且仅当其子树内外都有点备选，这个随便算算就知道贡献了。  
然后就是环上的边，只考虑这个环，如果一个点的子树内选择了点的话就把环上这个点给标记出来，那么最后选择的东西就一定是整个环的长度减去相邻两个被选中的点的最大距离。  
那么这样子就可以把每个环单独拎出来考虑这个环上的所有边的答案。
枚举每一个最大的可删去的长度，设$f_x$表示任意一对选择的点的最大长度不超过$x$的方案数。  
那么对于$x$而言，方案数就是$f_x-f_{x-1}$。
因为是一个环，断环成链后枚举链上最靠左的被选择的点，这样子可以忽略断开后首尾直接的关系。  
剩下的部分直接$dp$，设$g_i$表示当前选择了第$i$个点，并且第$i$个点强制被选择的方案数，转移的时候强迫相邻点的距离不超过枚举的长度$x$，这个东西可以用前缀和优化。  
那么枚举长度、枚举左端点再$dp$，所以这部分的复杂度是$O(n^3)$的。
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
#define MAX 205
#define MOD 1000000007
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
int fpow(int a,int b){int s=1;while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}return s;}
struct Line{int v,next;}e[MAX<<2];
int h[MAX],cnt=2;bool vis[MAX<<2];
inline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}
int n,m,size[MAX],ans,bin[MAX],fr[MAX],fa[MAX];
vector<int> dn,up;
int S[MAX],top,sz[MAX],dep[MAX];
void Get(int u,int R)
{
	S[top=1]=u;
	for(int j=u;j!=R;j=fa[j])
		vis[fr[j]>>1]=true,S[++top]=fa[j];
}
void dfs(int u,int ff)
{
	size[u]=1;fa[u]=ff;dep[u]=dep[ff]+1;int R=0;
	for(int i=h[u];i;i=e[i].next)
	{
		int v=e[i].v;if(v==ff)continue;
		if(size[v]){if(dep[v]<dep[u])Get(u,R=v);
			vis[i>>1]=true;continue;}
		fr[v]=i;dfs(v,u);size[u]+=size[v];
	}
	for(int i=h[u];i;i=e[i].next)
	{
		int v=e[i].v;if(v==ff)continue;
		if(vis[i>>1])continue;
		ans=(ans+1ll*(bin[size[v]]-1)*(bin[n-size[v]]-1))%MOD;
	}
	if(R)dn.push_back(u),up.push_back(R);
}
int g[MAX],f[MAX],ss[MAX];
void Solve(int u,int R)
{
	Get(u,R);
	for(int i=1;i<=top;++i)sz[i]=size[S[i]];
	for(int i=top;i>1;--i)sz[i]-=sz[i-1];
	sz[top]+=n-size[S[top]];
	for(int i=1;i<=top;++i)f[i]=0;
	for(int l=1;l<=top;++l)
	{
		for(int i=1;i<=l;++i)
		{
			for(int j=1;j<=top;++j)ss[j]=g[j]=0;
			g[i]=ss[i]=bin[sz[i]]-1;
			for(int j=i+1;j<=top;++j)
			{
				int L=max(1,j-l),R=j-1,d=bin[sz[j]]-1;
				g[j]=1ll*d*(ss[R]-ss[L-1]+MOD)%MOD;
				ss[j]=(ss[j-1]+g[j])%MOD;
			}
			int L=max(top-l+i,i+1);
			f[l]=(1ll*f[l]+ss[top]-ss[L-1]+MOD)%MOD;
		}
	}
	for(int i=1;i<=top;++i)
		ans=(ans+1ll*(top-i)*(f[i]+MOD-f[i-1]))%MOD;
	return;
}
int main()
{
	n=read();m=read();
	bin[0]=1;for(int i=1;i<=n;++i)bin[i]=(bin[i-1]<<1)%MOD;
	for(int i=1;i<=m;++i)
	{
		int u=read(),v=read();
		Add(u,v);Add(v,u);
	}
	dfs(1,0);
	for(int i=0;i<dn.size();++i)Solve(dn[i],up[i]);
	ans=1ll*ans*fpow(bin[n],MOD-2)%MOD;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：tzc_wk (赞：1)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P4517)

简单题，不知道怎么评到黑的.jpg

首先拆贡献。看到仙人掌套路化分环边和非环边处理。非环边贡献非常 easy，只要两边都有点被选即可。主菜在环边。

每个环显然是独立的。我们假设现在在考虑一个由 $p_1,p_2,\cdots,p_k$ 构成的环，那么我们考虑以这个环为根建树，显然每个点的子树是独立的。手玩一下环的情况可以发现，我们考虑记“$p_i$ 及其子树内有点被选择的 $i$”为关键点，那么一种情况需要选择的环边个数为 $k$ 减去相邻关键点距离的最大值。

于是问题变为这样：

> 环上有 $n$ 个点，第 $i$ 个点有 $p_i$ 的概率是最大值，$1-p_i$ 的概率不是，其中 $p_i$ 给定，且 $p_i(p_i-1)\ne 0$。要求环上相邻两点距离最大值的期望。

考虑差分统计，即枚举 $d\in[1,n-1]$ 统计相邻两点距离都 $\le d$ 的概率。再枚举第一个选中的点 $j$，记 $dp_j$ 表示当前 $j$ 点是关键点且从第一个关键点到 $j$ 相邻关键点距离都 $\le d$ 的概率，那么有 $dp_j=p_j\sum\limits_{l=j-d}^{j-1}dp_l·\prod\limits_{t=l+1}^{j-1}(1-p_t)$，记 $prd_i$ 为 $1-p_t$ 的前缀积，那么 $dp_j=p_j\sum\limits_{l=j-d}^{j-1}dp_l·\dfrac{prd_{j-1}}{prd_l}$，维护 $\dfrac{dp_i}{prd_i}$ 的前缀和即可做到 DP 部分线性。

时间复杂度 $n^3$，说不定 $n^4$ 都能过.jpg

```cpp
const int MAXN = 200;
const int MAXM = 300;
const int MOD = 1e9 + 7;
const int INV2 = MOD + 1 >> 1; 
int qpow(int x, int e) {
	int ret = 1;
	for (; e; e >>= 1, x = 1ll * x * x % MOD)
		if (e & 1) ret = 1ll * ret * x % MOD;
	return ret;
}
int n, m, pw[MAXN + 5], ans;
int hd[MAXN + 5], to[MAXM * 2 + 5], nxt[MAXM * 2 + 5], ec = 1;
void adde(int u, int v) {to[++ec] = v; nxt[ec] = hd[u]; hd[u] = ec;}
int dfn[MAXN + 5], tim, fa[MAXN + 5], fa_edge[MAXN + 5], ont[MAXM + 5];
int cyc_cnt = 0; vector<int> cyc[MAXN + 5];
void dfs(int x, int f) {
	dfn[x] = ++tim; fa[x] = f;
	for (int e = hd[x]; e; e = nxt[e]) {
		int y = to[e]; if (y == f) continue;
		if (!dfn[y]) fa_edge[y] = e >> 1, dfs(y, x);
		else if (dfn[y] > dfn[x]) {
			ont[e >> 1] = 1; cyc_cnt++;
			for (int z = y; z ^ x; z = fa[z]) ont[fa_edge[z]] = 1, cyc[cyc_cnt].pb(z);
			cyc[cyc_cnt].pb(x);
		}
	}
}
bool vis[MAXN + 5]; int sz = 0;
void dfscmp(int x) {
	if (vis[x]) return; vis[x] = 1; sz++;
	for (int e = hd[x]; e; e = nxt[e]) dfscmp(to[e]); 
}
int w[MAXN + 5], dp[MAXN + 5], sum[MAXN + 5], prd[MAXN + 5], iprd[MAXN + 5];
int calc(int N) {
	int ret = 0; prd[0] = iprd[0] = 1;
	for (int i = 1; i <= N; i++) {
		prd[i] = 1ll * prd[i - 1] * (1 - w[i] + MOD) % MOD;
		iprd[i] = qpow(prd[i], MOD - 2);
	}
//	for (int i = 1; i <= N; i++) printf("%d%c", iprd[i], " \n"[i == N]);
	for (int i = 1; i < N; i++) {
//		printf("i = %d\n", i);
		for (int j = 1; j <= N; j++) {
			memset(sum, 0, sizeof(sum)); memset(dp, 0, sizeof(dp));
			dp[j] = 1ll * prd[j - 1] * w[j] % MOD;
			sum[j] = 1ll * dp[j] * iprd[j] % MOD;
			for (int k = j + 1; k <= N; k++) {
				dp[k] = 1ll * w[k] * prd[k - 1] % MOD * (sum[k - 1] - ((k - i - 1 >= 0) ? sum[k - i - 1] : 0) + MOD) % MOD;
				sum[k] = (sum[k - 1] + 1ll * dp[k] * iprd[k]) % MOD;
			}
//			printf("j = %d\n", j);
//			for (int k = j; k <= N; k++) printf("%d%c", dp[k], " \n"[k == N]);
			for (int k = j; k <= N; k++) if (j + N - k <= i)
				ret = (ret + 1ll * dp[k] * prd[N] % MOD * iprd[k]) % MOD;
		}
	}
	return ret;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = (pw[0] = 1); i <= n; i++) pw[i] = 1ll * pw[i - 1] * INV2 % MOD;
	for (int i = 1, u, v; i <= m; i++) scanf("%d%d", &u, &v), adde(u, v), adde(v, u);
	dfs(1, 0);
	for (int i = 1; i <= m; i++) if (!ont[i]) {
		memset(vis, 0, sizeof(vis));
		vis[to[i << 1]] = 1; sz = 0; dfscmp(to[i << 1 | 1]);
		ans = (ans + 1ll * (1 - pw[sz] + MOD) * (1 - pw[n - sz] + MOD)) % MOD;
	}
	for (int i = 1; i <= cyc_cnt; i++) {
		memset(w, 0, sizeof(w));
		for (int j = 0; j < cyc[i].size(); j++) {
			memset(vis, 0, sizeof(vis));
			for (int k = 0; k < cyc[i].size(); k++)
				if (j ^ k) vis[cyc[i][k]] = 1;
			sz = 0; dfscmp(cyc[i][j]);
			w[j + 1] = (1 - pw[sz] + MOD) % MOD;
		}
//		for (int j = 1; j <= cyc[i].size(); j++) printf("%d%c", w[j], " \n"[j == cyc[i].size()]);
		ans = (ans + calc(cyc[i].size())) % MOD;
	}
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：Corzica (赞：0)

考虑每一条边被覆盖了多少次。

如果这条边是割边，那么答案就是简单的两边都有选的方案数乘起来。

对于一个环上的非割边，我们进行统一计算。每一种点会要求联通当且仅当其或其子树内有点被选了，可以先把每个点对应的情况个数都预处理出来。

当我们拥有一个选点的序列之后，这个序列的贡献事实上是环长减去两两间相隔点数的最大值。令 $f_{i,j,k}$ 为起点为 $i$，终点为 $j$，两点间距离不超过 $k$ 的方案数，转移可以用前缀和优化，复杂度 $O(n^3)$。

---

## 作者：RyexAwl (赞：0)

考虑计算每条边在多少个不同的点集的斯坦纳树中。

对于仙人掌上的边可以分成两类：

* 割边。

* 环上的边。

分别考虑这两类边。

如果边 $(u,v)$ 是割边，令断掉该边之后分裂成的两个连通块分别是 $A,B$，那么对于点集 $S$，如果 $S\subseteq A$ 或 $S\subseteq B$，那么 $(u,v)$ 一定在点集 $S$ 的斯坦纳树种，否则 $(u,v)$ 一定在点集 $S$ 的斯坦纳树中。

因此边 $(u,v)$ 会出现在 $(2^{|A|}-1)\times (2^{|B|-1})$ 个子集的斯坦纳树中。

那么接下来终点考虑 $(u,v)$ 是环上的边要如何计算。

对于仙人掌，和基环树类似可以“以环为中心”考虑去考虑整个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/5kzx1uvs.png)

对于环上的边单独考虑一个边会被算的次数会很难办（因为如果一个斯坦纳树包含一条环上的边，那么可能可以用其他的边替代该边）。

因此这里整体考虑一个环上的情况。

假设环上共有 $k$ 个点，那么如果断掉所有环上的边，该环所在的连通块会分裂成 $k$ 个连通块，设 $k$ 个连通块分别为 $T_1,T_2,...,T_k$。

对于集合 $S$,如果存在一个 $i$，满足 $1\le i\le k$ 那么集合 $S$ 的斯坦纳树中一定不包含该环上的点。

否则，$S$ 的斯坦纳树中一定包含环上的一条链。

![](https://cdn.luogu.com.cn/upload/image_hosting/rp09vf6g.png)

红叉表示对应连通块内存在 $S$ 的点的“根节点”。

我们希望在环上找到一条最短的链使得能够将所有被打红叉的点“串起来”。

那么实际上相当于总的环长减去打红叉的点相邻两点之间路径长度的最大值。

考虑按顺时针顺序将所有环上的点编号。

并将所有相邻两点之间的路径按顺时针方向定向，这样任意一个点有恰好一个出度和恰好一个入度，这样对于一条边 $u\to v$，就可以使用 $u$ 为这条边 “编号”。

![](https://cdn.luogu.com.cn/upload/image_hosting/i6638n8h.png)

定义一个点集 $S$ 的斯坦纳树在该环上删除的路径为删掉相邻两点间最大的路径中编号最小的路径。

那么这样，一个点集 $S$ 的斯坦纳树就是 “唯一”的了。

考虑 $O(k^2)$ 枚举环上的每段路径，计算有多少个点集 $S$ 满足其斯坦纳树在该环上删除的路径为所枚举的路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/1w54pe3t.png)


注意到，其实计算过程中只关心每个连通块的大小，因此现在可以将除了该环以外的部分全部 “扔掉”，只维护每个连通块的大小即可。而此时我们要解决的就只是一个环上问题了。

![](https://cdn.luogu.com.cn/upload/image_hosting/cpk2h5l7.png)

我们每次枚举路径后的问题相当于去计算“该路径的补”的部分有多少种方案使得任意两个“关键点”的距离 $\le $ 该路径的长度，且不存在起始点 $<\min(u,v)$ 的路径使得该路径的长度恰好 $=k$。

考虑破环成链。

![](https://cdn.luogu.com.cn/upload/image_hosting/m3zp0n5r.png)

考虑定义一个 $calc(l,r,k,low)$ 表示区间 $[l,r]$ 这一段钦定 $l$ 和 $r$ 一定是 “关键点”，满足任意两个相邻关键点距离 $\le k$，且不存在两个相邻的关键点 $u,v$ 满足 $u<v,v-u=k,pos[v]<low$。

大力 DP 即可， $calc(l,r,k,low)$ 的复杂度是 $O(k^2)$ 的，使用前缀和可以优化成 $O(k)$。

因此对于一个大小为 $k$ 的环，计算贡献的复杂度为 $O(k^3)$，因为一个点在至多一个环，所以总的复杂度为 $O(n^3)$。   





---


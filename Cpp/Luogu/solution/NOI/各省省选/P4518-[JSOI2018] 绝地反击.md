# [JSOI2018] 绝地反击

## 题目描述

由于你的出色表现，外星人的进攻已经被成功化解了。现在， ``JYY`` 召集了强大的黄金舰队,准备一击摧毁外星人的母舰。

黄金舰队共有 $n(n\ge 3)$ 艘飞船,这些飞船能将能量汇聚到同一点（外星人母舰所在位置），从而对外星母舰进行毁灭性的打击。 ``JYY`` 计划将所有飞船同时折跃到母舰附近，瞬间发动攻击结束战斗。

在黄金舰队折跃抵达后，由于各种不稳定因素，舰队中的各艘飞船并未进入最佳攻击位置，因此需要迅速对它们进行调整。现在，所有飞船已经同时完成了折跃，每个飞船都可以看做是平面上的一个点，第 $i(1\le i\le n)$ 艘飞船的坐标为 $(x_i,y_i)$ 。外星母舰位于坐标原点 $(0,0)$ 。

为了实现最高效的打击，所有飞船都必须移动到攻击轨道上。攻击轨道是圆心在原点 $(0,0)$ 、半径为 $R$ 的圆。因为发射产生的能量实在太大， ``JYY`` 希望发射时飞船相互之间的距离尽可能大。具体来说， ``JYY`` 希望黄金舰队所有 $n$ 艘飞船均匀地排列在攻击轨道上（所有飞船均为同一型号，因此按任意顺序排列均可），即相邻飞船在攻击轨道（圆弧）上的距离相等且恰好等于 $\frac{2\pi R}{n}$​​ 。换言之， ``JYY`` 希望调整所有飞船的位置，使得所有飞船都位于攻击轨道上，且它们恰好位于正 $n$ 边形的 $n$个顶点。

请你帮助 ``JYY`` 计算出打击开始的最短时间（即所有飞船移动到攻击轨道上并等距排列的最少时间）。飞船一单位时间可以在平面上移动一单位距离，且飞船的体积可以看成 $0$ 。因此在你设计的方案中，飞船在某个时刻 “相遇” 是允许的。此外，初始时飞船的坐标也允许重合。

## 说明/提示

对于 $20\%$ 的数据，有 $n=3$ 。

对于 $50\%$ 的数据，有 $n\le 50$ 。

对于 $100\%$ 的数据，有 $3 \le n\le 200,0 \le\vert x_i\vert,\vert y_i\vert,R\le 100$ 。

## 样例 #1

### 输入

```
3 1
0 0
0 0
0 0```

### 输出

```
1.00000000```

## 样例 #2

### 输入

```
3 10
10 0
0 10
10 10```

### 输出

```
12.17522858```

# 题解

## 作者：Alex_Wei (赞：11)

> [P4518 [JSOI2018] 绝地反击](https://www.luogu.com.cn/problem/P4518)

二分答案，将每艘飞船的可达范围与攻击轨道求交，可得一段圆弧。

考虑正 $n$ 边形辐角最小顶点的辐角 $\alpha$，$\alpha \in [0, \frac {2\pi} n)$。考虑第 $i$ 艘飞船对应的弧，可知有 $\mathcal{O}(1)$ 段 $\alpha$ 的取值使得弧上有 $k$ 个顶点，另有 $\mathcal{O}(1)$ 段 $\alpha$ 的取值使得弧上有 $k + 1$ 个顶点。取出每艘飞船的分割点，可将 $[0, \frac {2\pi} n)$ 划分为 $\mathcal{O}(n)$ 段，$\alpha$ 取每小段时飞船覆盖顶点的情况不变。

据此，我们将问题转化为：$n$ 个左部点，每个左部点连向一段环区间的右部点，检查是否有完美匹配。直接 Dinic 的复杂度为 $\mathcal{O}(n ^ 3\sqrt n\log V)$，不知道是否可以通过。但网络流有两个性质没用到，一是连边为环区间，二是只需检查是否有完美匹配，不用求最大匹配。

自然，考虑霍尔定理 $\forall S, |N(S)| \geq |S|$。笔者一开始有以下思路：

- 将左部点按照覆盖区间左端点为第一关键字，右端点为第二关键字排序，检查任意一段环子区间左部点的覆盖区间之并大小不小于子区间大小。存在反例 $[1, 1], [1, 2], [1, 5], [2, 2], [3, 2]$，其中 $\{[1, 1], [1, 2], [2, 2]\}$ 不合法，但满足上述性质。
- 检查任意一段环子区间右部点的邻域大小不小于子区间大小。存在反例 $[1, 3], [2, 2], [2, 2], [4, 4]$，其中 $\{1, 3\}$ 不合法，但满足上述性质。

两种思路本质上为从霍尔定理直接下手直接证明存在性，行不通。考虑不存在性，即 $\exists S, |N(S)| < |S|$。

从 $S\to N(S)$ 的角度上文已经试过行不通，考虑 $N(S)\to S$。枚举一段环子区间右部点 $N(S)$，考虑覆盖集合包含于这些右部点的所有左部点 $S_{\max}$，我们希望 $|S_{\max}|$ 尽量大，大于 $N(S)$，即可证明不存在。

为什么一定是一段环子区间？考虑两段 **端点不相邻** 的不交子区间 $[a, b]$ 与 $[c, d]$，如果 $N([a, b] \cup [c, d])$ 不合法，必然有 $N([a, b])$ 或 $N([c, d])$ 不合法。

证明：因 $[a, b]$ 与 $[c, d]$ 端点不相邻且不交，所以覆盖集合包含于 $[a, b]$ 的左部点 $S_{a, b}$ 与覆盖集合包含于 $[c, d]$ 的左部点 $S_{c, d}$ 不交，再根据覆盖集合为环区间可知 $S_{\max} = S_{a, b} + S_{c, d}$，结合 $|S_{\max}| > (b - a + 1) + (d - c + 1)$，故 $|S_{a, b}| > b - a + 1$ 或 $|S_{c, d}| > d - c + 1$。

为什么从存在性角度入手不行？因为存在的条件是 **任意均满足**，而不存在的条件是 **存在不满足**，后者一般比前者更容易检查。同时满足性无法拆分，即若 $|S_{\max}| \leq (b - a + 1) + (d - c + 1)$ 无法说明 $|S_{a, b}| \leq b - a + 1$ 且 $|S_{c, d}| \leq d - c + 1$，故无法通过仅检查子区间实现判定。

综上，只需检查是否存在右部点环子区间满足覆盖区间完全包含于该子区间的左部点数量大于该子区间。若是，则无解，否则有解。破环成链，最朴素暴力 $\mathcal{O}(n ^ 4\log V)$，扫描线可以做到 $\mathcal{O}(n ^ 3\log V)$，加入线段树优化后可以做到 $\mathcal{O}(n ^ 2\log n\log V)$，相当优秀。我就知道这题有 $\tilde{O}(n ^ 2)$ 的做法！

此外，还有一种使得只需进行 $\mathcal{O}(n\log V)$ 次检查的方法：顶点必然取到某段弧的左边界或右边界，调整易证。这样更好写。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int N = 400 + 5;
constexpr double eps = 1e-10;
constexpr double pi = acos(-1);
int n, x[N], y[N], sq[N], R;
double arc, dist[N], arg[N], l[N], r[N];
int val[N << 2], laz[N << 2];
void clear() {
  memset(val, 0, sizeof(val));
  memset(laz, 0, sizeof(laz));
}
void tag(int x, int v) {val[x] += v, laz[x] += v;}
void down(int x) {
  if(laz[x]) {
    tag(x << 1, laz[x]), tag(x << 1 | 1, laz[x]);
    laz[x] = 0;
  }
}
void modify(int l, int r, int ql, int qr, int x, int v) {
  if(ql <= l && r <= qr) return tag(x, v), void();
  int m = l + r >> 1;
  down(x);
  if(ql <= m) modify(l, m, ql, qr, x << 1, v);
  if(m < qr) modify(m + 1, r, ql, qr, x << 1 | 1, v);
  val[x] = max(val[x << 1], val[x << 1 | 1]);
}
int query(int l, int r, int ql, int qr, int x) {
  if(ql <= l && r <= qr) return val[x];
  int m = l + r >> 1, ans = -N;
  down(x);
  if(ql <= m) ans = query(l, m, ql, qr, x << 1);
  if(m < qr) ans = max(ans, query(m + 1, r, ql, qr, x << 1 | 1));
  return ans;
}
vector<int> buc[N];
bool legal(double a) {
  assert(a >= 0);
  a -= (int) (a / arc) * arc;
  clear();
  int m = n * 2;
  for(int i = 0; i < m; i++) buc[i].clear();
  for(int i = 1; i <= n; i++) {
    double x = l[i] - eps, y = r[i] + eps;
    int pl = x < a ? 0 : (int) ((x - a) / arc) + 1;
    int pr = y < a ? -1 : (int) ((y - a) / arc);
    if(pl > pr) return 0;
    buc[pr].push_back(pl);
    if(pr < n) buc[pr + n].push_back(pl + n);
  }
  for(int i = 0; i < m; i++) {
    for(int it : buc[i]) modify(0, m, 0, it, 1, 1);
    modify(0, m, 0, i, 1, -1);
    if(query(0, m, i - n + 1, i, 1) > 0) return 0;
  }
  return 1;
}
bool check(double d) {
  for(int i = 1; i <= n; i++)
    if(dist[i] + R - eps <= d) l[i] = 0, r[i] = 2 * pi - arc;
    else {
      double a = acos((R * R + sq[i] - d * d) / 2.0 / R / dist[i]);
      l[i] = ::arg[i] - a, r[i] = ::arg[i] + a;
      if(l[i] < 0) l[i] += 2 * pi, r[i] += 2 * pi;
    }
  for(int i = 1; i <= n; i++) {
    if(legal(l[i]) || legal(r[i])) return 1;
  }
  return 0;
}
bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  cin >> n >> R, arc = 2 * pi / n;
  double l = 0, r = sqrt(2.0) * 200;
  for(int i = 1; i <= n; i++) {
    cin >> x[i] >> y[i];
    dist[i] = sqrt(sq[i] = x[i] * x[i] + y[i] * y[i]);
    ::arg[i] = atan2(y[i], x[i]);
    if(::arg[i] < 0) ::arg[i] += 2 * pi;
    l = max(l, fabs(dist[i] - R) + eps);
  }
  for(int _ = 1; _ <= 30; _++) {
    double m = (l + r) * 0.5;
    if(check(m)) r = m;
    else l = m;
  }
  printf("%.7lf\n", l);
  return cerr << "Time: " << clock() << "\n", 0;
}
/*
2022/7/7
start thinking at ?:??
首先二分答案转化为判定性问题。
但是每艘飞船可能覆盖 k 或 k + 1 个点。
分界线只有 O(n) 个，可以分别考虑所有区间。
那问题就转化成环上 n 个区间，每个区间选一个点，使得一个区间恰好对应一个点，即有完美匹配。
感觉可以用霍尔定理检查，好像不行。
现在已经有 O(n log V) 次检查了，常数还挺大。
如果 n <= 50 可以直接跑二分图匹配。可惜跑不得。
submit.
哇，真能霍尔定理啊！
哇，soft O(n ^ 2)！
start coding at 11:15
finish debugging at 13:16
*/
```

---

## 作者：QwQcOrZ (赞：9)

先二分答案，现在每个点能匹配一段圆弧上的点。

注意到最优方案一定存在一个点与其圆上匹配点的距离恰好为 $mid$，否则可以更优。

稍加思考发现可以枚举这个点是哪个，这样圆上选的点就确定了，现在问题变成了判定 $n$ 个给出点和圆上 $n$ 个点是否存在完美匹配。

由于左部点一定是向右部点在环上的一段区间连边，考虑 Hall 定理。

先断环成链，枚举右部点被覆盖的区间，检查有多少左部点连边的区间被枚举的区间包含，记这个数量为 $tot$，区间长度为 $len$，若存在 $tot>len$ 则不存在完美匹配。

直接暴力得到一个 $\mathcal O(n^4\log V)$ 的做法，计算 $tot$ 的部分显然可以优化掉一个 $n$，复杂度 $\mathcal O(n^3\log V)$，已经可以通过了。

考虑继续优化，从左往右扫右端点，线段树维护每个左端点 $tot-len$ 的结果，每次只需要检查长度不超过 $n$ 的区间中是否有 $>0$ 的位置即可。

时间复杂度 $\mathcal O(n^2\log n\log V)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=605;
const double eps=1e-10;
const double pi=acos(-1);

ll read(){static ll x;scanf("%lld",&x);return x;}
void write(ll x){printf("%lld",x);}
void print(ll x,char c='\n'){write(x),putchar(c);}

int n,R;
int cmp(double x,double y)
{
	if (abs(x-y)<eps) return 0;
	return x>y?1:-1;
}
struct point
{
	double x,y;
	point operator -(point a){return (point){x-a.x,y-a.y};}
	double length(){return sqrt(x*x+y*y);}
	double angle(){return atan2(y,x);}
}a[N];
double dis(point a,point b){return (a-b).length();}
double calc(double a,double b,double c)
{
	return a*a+b*b-c*c;
}
struct segment_tree
{
	#define ls (w*2)
	#define rs (w*2+1)
	#define mid ((l+r)/2)
	int t[N*4],tag[N*4];
	void clear(int n)
	{
		for (int i=1;i<=n*4;i++) t[i]=tag[i]=0;
	}
	void update(int w,int x)
	{
		t[w]+=x;
		tag[w]+=x;
	}
	void push_down(int w)
	{
		if (!tag[w]) return;
		update(ls,tag[w]);
		update(rs,tag[w]);
		tag[w]=0;
	}
	void add(int w,int l,int r,int ql,int qr,int x)
	{
		if (ql<=l&&r<=qr) return update(w,x);
		push_down(w);
		if (ql<=mid) add(ls,l,mid,ql,qr,x);
		if (qr>mid) add(rs,mid+1,r,ql,qr,x);
		t[w]=max(t[ls],t[rs]);
	}
	bool query(int w,int l,int r,int ql,int qr)
	{
		if (!t[w]) return 0;
		if (qr<l||r<ql) return 0;
		if (ql<=l&&r<=qr) return t[w]>0;
		push_down(w);
		return query(ls,l,mid,ql,qr)||query(rs,mid+1,r,ql,qr);
	}
	#undef mid
	#undef rs
	#undef ls
}t;
double le[N],ri[N];
int l[N],r[N];
bool check2(double k,double p)
{
	double len=pi*2/n;
	for (int i=1;i<=n;i++)
	if (cmp(a[i].length()+R,k)<=0) l[i]=0,r[i]=n-1;
	else
	{
		double left=le[i]-p,right=ri[i]-p;
		if (left<0) left+=pi*2;
		if (right<0) right+=pi*2;
		l[i]=floor(left/len-eps)+1;
		r[i]=right/len;
		if (left<=right&&l[i]>r[i]) return 0;
		if (l[i]==n) l[i]=0;
	}
	vector<int>a[N];
	for (int i=1;i<=n;i++)
	if (l[i]<=r[i])
		a[r[i]].push_back(l[i]),
		a[r[i]+n].push_back(l[i]+n);
	else
		a[r[i]+n].push_back(l[i]);
	t.clear(n*2);
	for (int i=0;i<n*2;i++)
	{
		for (int k:a[i]) t.add(1,0,n*2-1,0,k,1);
		t.add(1,0,n*2-1,0,i,-1);
		if (t.query(1,0,n*2-1,max(i-n+1,0),i)) return 0;
	}
	return 1;
}
bool check(double k)
{
	for (int i=1;i<=n;i++)
	if (a[i].length()<=R)
	{
		if (a[i].length()+k<R) return 0;
	}
	else
		if (R+k<a[i].length()) return 0;
	for (int i=1;i<=n;i++)
	if (cmp(a[i].length()+R,k)<=0) le[i]=-pi,ri[i]=pi;
	else
	{
		double ang=a[i].angle(),delta=acos(calc(a[i].length(),R,k)/2/R/a[i].length());
		le[i]=ang-delta,ri[i]=ang+delta;
		if (le[i]<=-pi) le[i]+=pi*2;
		if (ri[i]>pi) ri[i]-=pi*2;
	}
	bool flag=1;
	for (int i=1;i<=n;i++)
	if (cmp(a[i].length()+R,k)>0)
	{
		flag=0;
		if (check2(k,le[i])) return 1;
		if (check2(k,ri[i])) return 1;
	}
	return flag;
}

signed main()
{
	n=read(),R=read();
	for (int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();
	double l=0,r=300;
	for (int k=1;k<=35;k++)
	{
		double mid=(l+r)/2;
		if (check(mid)) r=mid;
				   else l=mid;
	}
	printf("%.9lf\n",r);
	
	return 0;
}
```

---

## 作者：轮回之终末 (赞：8)

正解：

#### 计算几何+二分+扫描线+网络流

注意到偏转角度不会超过2π/n。

先二分答案。

注意到网络流的图不同，当且仅当一个匹配点抵住一个点的匹配边界上，所以一共只有2n种匹配方式。

然后排序后，依次进行增广和退流即可。

时间复杂度 O($n^3$logn)

~~正解好麻烦啊，我只会瞎搞QAQ~~

### 我的100分瞎搞：

#### 爬山+二分+网络流

~~考场上T飞了，只有50分，不如贪心，QAQ~~

若知道一个点的最终位置后，直接上 二分+网络流 即可。

所以很直观的想法，用爬山/褪火来寻找最优的位置。

~~贪心都有70，凭什么爬山过不了~~

### 没有正确性，因为它是错的。但我也不会卡……

感性理解一下，搜索空间大概是若干个单峰函数拼在一起。所以，……，直接就能过，连容错都不要（耸肩）。

代码很丑。有点卡常。

还有数据范围其实n<=200。

怎么想都是一个 ~~凉~~ 良心出题人啊。

时间复杂度O( logV ∗ dinic($N$,$N^2$) * 爬山次数 ) 

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=210;
const int S=417;
const int T=418;
const double pi=acos(-1);
int i,j,k;
double a[maxn],b[maxn];
double c[maxn],d[maxn];
int n;
int opt;
double R,TT,thi,newt,thif,newtf,ans;
int read(){
	int tot=0,fh=1;
	char c=getchar();
	while ((c<'0')||(c>'9')){ if(c=='-') fh=-1; c=getchar(); }
	while ((c>='0')&&(c<='9')){ tot=tot*10+c-'0'; c=getchar(); }
	return tot*fh;
}
int f1[maxn*2],f2[maxn*maxn*2],f3[maxn*maxn*2],f4[maxn*maxn*2],th;
int dist[maxn*2],aa[maxn*2],las[maxn*2];
void add(int x,int y,int z){
	th++; f2[th]=y; f3[th]=z; f4[th]=f1[x]; f1[x]=th;
	th++; f2[th]=x; f3[th]=0; f4[th]=f1[y]; f1[y]=th;
}
void bfs(){
	int i,l=1,r=1; aa[r]=S;
	memset(dist,-1,sizeof(dist)); dist[S]=0;
	for (i=1;i<maxn*2;i++) las[i]=f1[i];
	while (l<=r){
		i=f1[aa[l]];
		while (i!=0){
			if ((f3[i]!=0)&&(dist[f2[i]]==-1)){
				dist[f2[i]]=dist[aa[l]]+1; r++; aa[r]=f2[i];
				if (f2[i]==T) return;
			}
			i=f4[i];
		}
		l++;
	}
}
int dfs(int x,int w){
	if (x==T) return w;
	int i=las[x],t=0,tt=0;
	while (i!=0){
		if ((dist[f2[i]]==dist[x]+1)&&(f3[i]!=0)){
			t=dfs(f2[i],min(w,f3[i]));
			tt=tt+t; w=w-t;
			f3[i]=f3[i]-t;
			if (i%2==1) f3[i+1]+=t; else f3[i-1]+=t;
			if (w==0) return tt;
		}
		i=f4[i]; las[x]=i;
	}
	return tt;
}
int dinic(){
	int t=-1,tt=0;
	while (t!=0){
		bfs();
		t=dfs(S,1e9);
		tt=tt+t;
	}
	if (tt>=n) return 1;
	else return 0;
}
double dis(int x,int y){
	return (((a[x]-c[y])*(a[x]-c[y]))+((b[x]-d[y])*(b[x]-d[y])));
}
double getf(double val){
	double l=0,r=4000,mid;
	int i,j;
	while (r-l>=0.000001){
		mid=(l+r)/2.0;
		for (i=0;i<n;i++){
			c[i+1]=R*sin(val+(((double)pi*2)/n)*(double)i);
			d[i+1]=R*cos(val+(((double)pi*2)/n)*(double)i);
		}
		th=0; memset(f1,0,sizeof(f1));
		for (i=1;i<=n;i++){
			for (j=1;j<=n;j++){
				if (dis(i,j)<=mid*mid){
					add(i,j+maxn,1);
				}
			}
		}
		for (i=1;i<=n;i++){
			add(S,i,1); add(i+maxn,T,1);
		}
		if (dinic()==1){
			r=mid;
		}
		else l=mid;
	}
	return l;
}
int main(){
	srand(19260817);
	n=read(); R=read();
	for (i=1;i<=n;i++){
		a[i]=read(); b[i]=read();
	}
	thi=0; thif=getf(thi); ans=thif;
	for (TT=pi/n;TT>=0.00000001;TT=TT*0.5){
		newt=thi+TT; newtf=getf(newt);
		if (newtf<ans){
			ans=newtf;
		}
		if (newtf<thif){
			thi=newt; thif=newtf;
		}
		else{
			newt=thi-TT; newtf=getf(newt);
			if (newtf<ans){
				ans=newtf;
			}
			if (newtf<=thif){
				thi=newt; thif=newtf;
			}
		}
	}
	printf("%.9lf\n",ans);
	return 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：6)

主要来写 Hall 定理的部分，因为前面的部分想不到但大家都是一样的做法，后面的部分却是复杂度出现较大差异的地方。

感觉这个区间连边的二分图以前见过，比较经典，当做是复习 Hall 定理了。

------------

首先答案有明显的可二分性，我们在 Um_Nik 的领导下先二分时间 $t$ 使得每个飞机都到位。

那么一架飞机能走到范围的是一个圆，考虑能走到攻击轨道的哪些位置，即求交，显然发现是一段圆弧。

然后比较神的一步是调整，如果每个飞机**都不在自己能到攻击轨道的圆弧的端点上**，此时我们将整体向左向右移都是没问题的。

一定可以进行移动调整到某个飞机**恰落在自己能到攻击轨道的圆弧的端点上**，这样只要提前 $O(n)$ 枚举了一个固定的飞船到一个固定的端点（就只有它所对应圆弧的两端）。

接下来 $n$ 个位置就固定了，而非完全无法考虑的无限个位置，到了这一步有一些暴力的出路：

- 暴力连 $n^2$ 条边，根据 Dinic 二分图是 $M\sqrt N$，复杂度为 $O(n^3\sqrt n\log)$。
- 精细实现版线段树优化隐式建边跑 Dinic，据笔者考虑可以做到 $O(n^2\sqrt n\log^2)$ 的复杂度，这个复杂度是不优雅的算法中看上去最能过的了。
- 对于枚举一个固定的飞船到一个固定的端点时，顺次切换最近的飞船到固定端点，总切换次数未知且复杂度未知，没有分析比较玄学。（~~感觉复杂度比暴力还差，但有题解说这是 $O(n^3\log)$ 的~~

不管怎么说，上述算法都不够优雅，稍微形式化的叙述一下我们要求的东西：

给你一个二分图，保证左部点向右部点连的边形成一个区间，判断是否有完美匹配。

说到完美匹配这种东西就应该想到 Hall 定理，再加上这道题的边很有特点。

~~首先考虑枚举哪部点的子集，尝试了一下右部点发现搞不动，于是~~我们先枚举一个左部点的一个子集看邻集。

最基本的 Hall 定理的逆否命题有：若无完美匹配，此判定与 $\exists S,|S|>|N(S)|$ 充要，其中 $N(S)$ 为左部点集 $S$ 的子集。

由于邻集是一些区间的并且每个点只会连**一个区间**，比较经典的有将每个不交的邻集区间单独拎出来，分开考虑这些邻集的左部点邻集，有结论和原判定充要。

首先充分性显然，因为区间并是包含了只有一个区间的情况。

考虑必要性，去掉 $|S|\le N(S)$ 的邻集区间，剩下的区间至少有一个 $|S|>|N(S)|$。

考虑固定邻集并贪心的往左部点集加点尽量使得 $|S|>|N(S)|$，如果一个左部点连的区间完全在邻集内部，将这个点并入我们考虑的子集显然更优。

否则是无法并入子集的，也就是这个贪心条件都是充要的，我们直接贪心选完后判定即可。

于是我们得到了一个不如暴力网络流的 $O(n^4\log)$ 算法，如果固定邻集区间的右端点依次移动左端点并加入左部点就可以轻松做到 $O(n^3\log)$。

我们还可以更进一步，考虑依次移动右端点，并用线段树继承左端点的情况，相当于支持插入左部点对 $|S|$ 产生一个区间的贡献，并支持查询区间最小值或最大值，看你维护 $|S|-|N(S)|$ 还是 $|N(S)|-|S|$。

最后复杂度 $O(n^2\log^2)$，由于口胡~~不会求圆弧~~所以没有代码。

Upd：更新了一个不优雅算法的复杂度，笔者认为此题是有两种复杂度正确的算法的，但不优雅的算法非本题主要实现方式就不细讲了，可以[参见](https://www.luogu.com.cn/blog/ICANTAKIOI/solution-cf786e)。

---

## 作者：LHQing (赞：6)

### 思路分析

二分答案。应用余弦定理可以得到每艘飞船能够到达的圆弧。

注意一定存在一种方案，使得至少有一艘飞船处于它能到达的圆弧的端点上。

因此我们枚举这艘处于其圆弧端点位置的飞船，然后建立二分图，左边 $n$ 个点表示最终需要到达的位置，右边 $n$ 个点表示飞船的编号。

当二分图最大匹配为 $n$ 时，方案存在。使用匈牙利算法求解二分图最大匹配即可。

时间复杂度 $O(n^4 \log V)$。因为 $n$ 最大只有 $200$，所以可以通过此题。

### 代码实现

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
const int N=205;
const double PI=acos(-1.0);
int n,R;
struct Spaceship
{
	int x,y;
	double dis()
	{
		return sqrt((double)(x*x+y*y));
	}
}a[N];
double thetaRay[N],thetaDlt[N];
bool test(double Ray,double Dlt,double Vrt)
{
	//Vrt in Ray+k*2PI+[-Dlt,Dlt]
	for(int k=0;k<=1;k++)
	if(Ray+(double)k*2.0*PI-Dlt-0.000000001<=Vrt)
	if(Ray+(double)k*2.0*PI+Dlt+0.000000001>=Vrt)
	return true;
	return false;
}
vector<int> e[N];
int f[N];
bool vis[N];
bool dfs(int u)
{
	for(int i=0;i<e[u].size();i++)
	{
		int v=e[u][i];
		if(vis[v])
		continue;
		vis[v]=true;
		if(f[v]==0||dfs(f[v]))
		{
			f[v]=u;
			return true;
		}
	}
	return false;
}
bool chk(double thetaRtt)
{
	for(int i=1;i<=n;i++)
	{
		e[i].clear();
		f[i]=0;
	}
	for(int i=1;i<=n;i++)
	{
		double thetaVrt=2.0*PI/(double)n*(double)(i-1);
		for(int j=1;j<=n;j++)
		if(test(thetaRay[j]+thetaRtt,thetaDlt[j],thetaVrt))
		e[i].push_back(j);
	}
	for(int i=1;i<=n;i++)
	{
		memset(vis,0,sizeof(vis));
		if(!dfs(i))
		return false;
	}
	return true;
}
bool ultrachk(double t)
{
	//there is at least 1 spaceship at leftmost(or rightmost) vertice
	bool flg=false;
	for(int i=1;i<=n;i++)
	{
		thetaRay[i]=atan2((double)a[i].y,(double)a[i].x);
		thetaDlt[i]=PI;
		if((double)R>t+a[i].dis()||a[i].dis()>t+R)
		return false;
		if(t<(double)R+a[i].dis())
		{
			double tmpU=(double)(R*R+a[i].x*a[i].x+a[i].y*a[i].y)-t*t;
			double tmpD=2.0*(double)R*a[i].dis();
			thetaDlt[i]=acos(tmpU/tmpD);
			flg=true;
		}
	}
	if(!flg)
	return true;
	for(int i=1;i<=n;i++)
	if(thetaDlt[i]!=PI)
	if(chk(-(thetaRay[i]-thetaDlt[i])))
	return true;
	return false;
}
int main()
{
	scanf("%d%d",&n,&R);
	for(int i=1;i<=n;i++)
	scanf("%d%d",&a[i].x,&a[i].y);
	double bl=0.0,br=300.0,bmid,bans=300.0;
	while(bl+0.0000005<=br)
	{
		bmid=(bl+br)/2.0;
		if(ultrachk(bmid))
		br=bans=bmid;
		else
		bl=bmid;
	}
	printf("%.7f\n",bans);
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：5)

随便胡一个题解，不知道能不能过……

### 题意

在一个圆心为原点的圆上等距撒点。再给定其他一堆点，每个		点都要向圆上的某个点连一条边。要求圆上每个点只被一个其		他点连边。边权为距离。求边权和最小值。

### 做法

退火。对圆上 $x$ 轴上方顺时针数第一个点，圆心与 $x$ 轴的夹角退火。这样可以知道圆上的每个点。然后就转化成了一个类似带权二分图匹配的问题，可以二分答案然后做二分图匹配，并判断是否满流。这样的时间复杂度约为：$O(T \times n ^ 2 \sqrt{n} \log{n})$。其中 $T$ 是退火次数，$n ^ 2 \sqrt{n}$ 是做二分图匹配的复杂度。$\log{n}$ 是二分复杂度。

亲测这种算法只能得到 $40$ 分。有兴趣可以尝试以下方法。

1. 发现有很大一部分时间浪费在建图上。每次二分和退火都要花费 $n ^ 2$ 的复杂度重新见图。也就是说，我们在建图上总共浪费了 $O(T \times \log{n} \times n ^ 2)$ 的复杂度。这是我们无法接受的。因此我们可以考虑放弃二分，每次只向图中加入一条边。（这种做法来自巨爷 wkl ）。

2. 贪心。不再赘述。

代码可以到剪贴板里看。

[CODE](https://www.luogu.com.cn/paste/5puyulgf)

---

## 作者：行吟啸九州 (赞：3)

这个题是一个看起来像计算几何+网络流的题。

因为所有飞船是一起行动的，所以不难想到这个最终结果是可以二分的。

然后我们可以发现每个飞船在$mid$时间内能达到的点是连续的一段，所以每个飞船能到的地方都对应圆上的一段圆弧。

然后我们利用经验主义，不难猜测所求正$n$多边形的端点的选取一定与圆弧的端点有关。即正$n$多边形中某个端点一定与$n$个圆弧的某个端点重合。

我们枚举和哪个端点重合，然后就可以确定这个正多边形的$n$个端点分别在哪，然后暴力O($n ^ 2$)建边。

再用dicnic跑一遍最大匹配，复杂度O($n ^ {3.5} \log n$)的，理论上可能无法通过，实际上卡卡常也弄不好就过去了。

这个题比较特殊，求的是一个二分图是否有完备匹配，是否有比O($n ^ {2.5}$)更快的办法，我不知道，找了一些资料，也没有发现办法。

所以这个题就得从每次重新暴力建边，重新跑一遍$dicnic$上进行优化了。

我们这个时候借鉴一些扫描线的思想，先把端点排个序。

然后我们顺时针的改变第一个端点的位置，每次找离这$n$个正$n$多边形端点最近的这$n$个圆弧的端点，删边建边。

我们不难发现，这一定只影响正$n$多边形的一个端点改变连边关系。

你可能会反驳我说，可能一次影响多个，不过一次影响多个的情况都是，这个正$n$多边形多个端点与圆弧端点重合，所以这个时候相当于你移动了多次，而不是一次，上面的说法不太严谨，不过这么来看也可以说是片面正确的。

所以每次移动，相当于你对一个端点进行一次增广路，用匈牙利算法里的那个办法，跑这一次，是O($n ^ 2$)的。

综上所述，总复杂度O($n ^ 3logn$)，理论上好像也过不去，不过确实就过了。

代码我就不给了，因为本人不会求圆的交点，以后有时间补一下吧，计算几何蒟蒻流下了眼泪。

---

## 作者：Rainsleep (赞：0)

[cnblog](https://www.cnblogs.com/Rainsheep/p/18714400)

大家好啊，因为我做题做崩了所以来补题解了，提供一种模拟网络流的 $O(n^3\log n)$ 的做法。

首先二分答案，那么每个飞船能到达的区域是一个圆，将这个圆与攻击轨道取交就出现了一段圆弧，不妨视作匹配，那么每个点就能匹配一段圆弧上的一段点。

关于这个圆弧以及两个交点的极角怎么算，可以参考 [P2510](https://www.luogu.com.cn/problem/P2510)。

一个引理，最佳方案中必然存在一种方案，使得该方案中存在一点卡在其所交圆弧的端点。这个易证，不然你就把这个多边形转一转就能让某个点卡到端点。

枚举 $2n$ 个点（每段圆弧的两个端点）作为被卡住的点，顺次得到另外 $n - 1$ 个点作为多边形的端点，原问题转化为二分图是否存在完美匹配。

Hall 定理的做法可以参考别的题解，这里讲讲怎么模拟网络流。

首先不妨将卡住的点视作正多边形旋转了一个角度，因为多边形的顶点之间相互没有区别，所以将所有的角度对 $\dfrac{2\pi}{n}$ 取模并排序，然后考虑每转过一个角度的影响。

特判相离和覆盖的情况，然后考虑每个角度只会添加/删除 $O(1)$ 条边，所以可以模拟推流/退流。

具体来说，推流就是直接加边之后再增广一次，删边也不难，考虑路径 $s \to u \to v \to t$，将 $(u, v)$ 的流量设为 $0$，再反转 $(s, u)$ 和 $(v, t)$ 两条边的流量即可。

代码
```cpp
// 如果命运对你缄默, 那就活给他看。
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast", "inline", "-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include <bits/stdc++.h>
using namespace std;
typedef long long LL; 
// #define int LL
const double PI = acos(-1); 
const double eps = 1e-8; 
const int maxn = 410;
namespace netflow {
  int tot = -1, h[maxn]; 
  int mf = 0; 
  struct E { int v, nx, f; } e[maxn * maxn << 1];
  inline void add(int u, int v, int f) {
    if(v == -2147483644) exit(0);
    e[++ tot] = {v, h[u], f}, h[u] = tot;
    e[++ tot] = {u, h[v], 0}, h[v] = tot; 
  }
  int s, t, c[maxn], d[maxn]; 
  const int INF = 1e9; 
  inline int find(int u, int l) {
    if(u == t) return l;
    int flow = 0;
    for(int i = c[u]; ~i && flow < l; i = e[i].nx) {
      c[u] = i;
      auto [v, nx, fw] = e[i]; 
      if(fw && d[v] == d[u] + 1) {
        auto f = find(v, min(l - flow, fw)); 
        if(!f) d[v] = -1;
        e[i].f -= f, e[i ^ 1].f += f, flow += f;
      }
    } return flow; 
  }
  int q[maxn]; 
  int hh, tt;
  inline bool bfs() {
    q[hh = tt = 0] = s, c[s] = h[s]; 
    memset(d, -1, sizeof d), d[s] = 0; 
    while(hh <= tt) {
      int u = q[hh ++ ];
      for(int i = h[u]; ~i; i = e[i].nx) {
        auto [v, nx, fw] = e[i];
        if(fw && d[v] == -1) {
          d[v] = d[u] + 1;
          c[v] = h[v];
          if(v == t) return 1;
          q[++ tt] =  v; 
        }
      }
    } return 0; 
  }
  inline void Dinic() {
    int r = 0; 
    while(bfs()) while(r = find(s, INF)) mf += r;
  }
}
using namespace netflow; 
int n, R;
struct vec { 
  double x, y; 
  inline int operator & (const vec& t) const { return x * t.x + y * t.y; }
  inline int operator * (const vec& t) const { return x * t.y - y * t.x; }
  inline vec operator - (const vec& t) const { return {x  - t.x, y - t.y}; }
} a[maxn], O; 
inline double ang(vec v) { return atan2(v.y, v.x); }
inline double sqr(double x) { return x * x; }
inline double len(vec v) { return sqrt(v & v); }
inline double dist(vec a, vec b) { return len(b - a); }
inline int mod(double& x, double y) { 
  int t = x / y;
  x -= t * y; return t + 1; 
}
double D;
struct rad {
  double ra;
  int u, v;
  int oper;
  bool operator < (const rad& t) const { return ra == t.ra ? oper > t.oper : ra < t.ra; } 
} b[maxn]; 
inline void del(int u, int v) {
  bool run = 0; 
  for(int i = h[u]; ~i; i = e[i].nx) 
    if(e[i].v == v) { run = e[i ^ 1].f, e[i].f = e[i ^ 1].f = 0; break ; }
  if(!run) return ; 
  for(int i = h[s]; ~i; i = e[i].nx) 
    if(e[i].v == u) { swap(e[i].f, e[i ^ 1].f); break ; } 
  for(int i = h[v]; ~i; i = e[i].nx) 
    if(e[i].v == t) { swap(e[i].f, e[i ^ 1].f); break ; }
  mf -- ; 
  Dinic(); 
} 
inline bool check(double r) {
  tot = -1, mf = 0;  
  memset(h, -1, sizeof h);
  for(int i = 1; i <= n; ++ i) { // 处理 2n 个交点
    double le = dist(O, a[i]);   
    if(le > r + R || R > le + r) return 0;  
    if(R + le <= r) {
      for(int j = 1; j <= n; ++ j) add(i, j + n, 1); 
      continue ;
    } 
    // double th1 = acos((sqr(r) + sqr(le) - sqr(R)) / (2 * le * r)); 
    double th1 = acos((-sqr(r) + sqr(le) + sqr(R)) / (2 * le * R)); 
    double th2 = atan2(a[i].y, a[i].x); 
    double thl = th2 - th1, thr = th2 + th1;
    while(thl < 0) thl += 2 * PI;
    while(thr < 0) thr += 2 * PI;
    int l = mod(thl, D), r = mod(thr, D);
    if(l <= r) for(int j = l + 1; j <= r; ++ j) add(i, j + n, 1);
    else {
      for(int j = 1; j <= r; ++ j) add(i, j + n, 1);
      for(int j = l + 1; j <= n; ++ j) add(i, j + n, 1); 
    } 
    b[(i << 1) - 1] = {thl, i, l, 1};
    b[i << 1] = {thr, i, r, -1};  
  } 
  for(int i = 1; i <= n; ++ i) add(s, i, 1), add(i + n, t, 1); 
  sort(b + 1, b + (n << 1 | 1));
  Dinic();
  if(mf == n) return 1;
  for(int i = 1; i <= (n << 1); ++ i) {
    auto [ra, u, v, oper] = b[i];
    if(~oper) {
      add(u, v + n, 1); 
      Dinic();
      if(mf == n) return 1; 
    } else {
      del(u, v + n); 
    }
  } return 0; 
}
signed main() {
  // freopen(".in", "r", stdin);
  // freopen(".out", "w", stdout);
  ios :: sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  O.x = 0., O.y = 0.; 
  cin >> n >> R;
  netflow::t = n << 1 | 1; 
  D = 2 * PI / n;
  for(int i = 1; i <= n; ++ i) cin >> a[i].x >> a[i].y;
  double l = 0, r = 400;
  while(r - l > eps) {
    double mid = (l + r) / 2;
    if(check(mid)) r = mid;
    else l = mid; 
  } cout << fixed << setprecision(8) << l << '\n'; 
  return 0;
}
```

---


# [FJOI2015] 最小覆盖双圆问题

## 题目描述

给定平面上n个点$(x_1,y_1),...,(x_n,y_n)$，找出2个半径相同的圆$R_1$和$R_2$，覆盖给定的n个点，且半径最小。

![](https://cdn.luogu.com.cn/upload/pic/18767.png)  

设计一个算法，计算出所求最小覆盖双圆 $R_1$ 和 $R_2$ 的半径。

## 说明/提示

对于100%的数据，$n<=1000$，$|x_i|,|y_i|<=100000$，（$T<=10$）

## 样例 #1

### 输入

```
3 
0.00 0.00 
1.00 0.00 
0.00 4.00 
10 
0.00 0.00 
0.00 3.00 
1.00 6.00 
2.00 2.00 
3.00 5.00 
5.00 3.00 
6.00 3.00 
9.00 5.00 
10.00 5.00 
11.00 3.00 
0```

### 输出

```
0.50
3.05```

# 题解

## 作者：Conan15 (赞：25)

# 目录：

1. 前置知识
2. 前置知识讲解
3. 最小圆覆盖的最“玄学”之处
4. 讲解本题
5. 旋转坐标系
6. 优化
7. 时间复杂度分析

## 前置知识
[最小圆覆盖](https://www.luogu.com.cn/problem/P1742)。

## 前置知识讲解

会做这题其实对本题有帮助。
这题其实可以用**几何算法**以及**模拟退火**来做。

不过模拟退火相对来讲会很复杂，需要调很多参数……比如**初始温度、降温系数**等，很麻烦。

因此我们采用 **几何算法** 解决这道题目！！！

来看一下我解决“最小圆覆盖”的思路：

------------

当 $n=1$ 的时候，最小圆覆盖当然圆心是第一个点 $p_1$，半径为 $0$。

当 $n=2$ 的时候，最小圆覆盖就是 **“两点定圆”** ，圆心是 $p_1p_2$ 线段的中心，半径是线段长度的一半。

当 $n=3$ 的时候，最小圆覆盖就复杂点了。分为两种情况：
	
1. $p_3$ 在上一个圆的圆周上或圆内。这种情况不会影响最小圆覆盖，忽略这个点。

2. $p_3$ 在上一个最小圆覆盖圆之外。这个时候 $p_3$ **一定在前三个点的最小圆覆盖的圆周上**，才能满足“最小”的性质。那么现在原问题转化为子问题：从 $p_1p_2$ 中找出一或两个点，与点 $p_3$ **两点定圆或三点定圆**。

当 $n=4$ 的时候，与 $n=3$ 的时候同理，分为两种情况，第一种直接忽略这个点，第二种则是从前面的点中挑出一或两个与 $p_4$ 一起定圆。

最后把所有的点都加入之后，就可以得出最小圆覆盖。


但是我们分析一下，会发现：需要一层循环枚举所有的点进行加入，一层循环来枚举两点定圆，还需要一层循环来枚举第三个点定圆……所以这个算法的时间复杂度是 $O(n^3)$ 的！

因为题目中，对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$|x_i|,|y_i|\leq 10^4$。

在这个题目的数据范围下，显然是过不了的！

### 最小圆覆盖的最“玄学”之处

解决这个问题，需要在求解之前，用 STL 函数 `random_shuffle()` 打乱这些点。

这题的玄学之处就是在于此，在**随机情况下**它的效率期望是**线性的**。

可以结合代码理解一下。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define eps 1e-8

const int N = 500010;

int sgn(double x) {
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}

struct Point {
    double x, y;
};

double Distance(Point A, Point B) {
    return hypot(A.x - B.x, A.y - B.y);
}

Point circle_center(const Point a, const Point b, const Point c) {
    Point center;
    double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;
    double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;
    double d = a1 * b2 - a2 * b1;
    center.x = a.x + (c1 * b2 - c2 * b1) / d;
    center.y = a.y + (a1 * c2 - a2 * c1) / d;
    return center;
}

void min_cover_circle(Point * p, int n, Point &c, double &r) {
    random_shuffle(p + 1, p + 1 + n);
    c = p[1]; r = 0;
    for (int i = 2; i <= n; i++) {
        if (sgn(Distance(p[i], c) - r) > 0) {
            c = p[i]; r = 0;
            for (int j = 1; j < i; j++)
                if (sgn(Distance(p[j], c) - r) > 0) {
                    c.x = (p[i].x + p[j].x) / 2;
                    c.y = (p[i].y + p[j].y) / 2;
                    r = Distance(p[j], c);
                    for (int k = 1; k < j; k++)
                        if (sgn(Distance(p[k], c) - r) > 0) {
                            c = circle_center(p[i], p[j], p[k]);
                            r = Distance(p[i], c);
                        }
                }
        }
    }
}

int main() {
    int n; Point p[N], c; double r;
    while (~scanf("%d", &n) && n) {
        for (int i = 1; i <= n; i++) scanf("%lf%lf", &p[i].x, &p[i].y);
        min_cover_circle(p, n, c, r);
        printf("%.10lf\n%.10lf %.10lf", r, c.x, c.y);
    }
    return 0;
}
```

以上的讲解只是为了让读者更清楚思路，接下来看看这一题要怎么做。

## 讲解本题

题目的意思就是用两个相同大小的圆覆盖平面所有的点，求圆的最小半径，因此它称作最小覆盖双圆问题。

很显然的，既然要分成两个圆，那么一定是用一条直线分割成两个点集，然后分别求出两个点集的最小圆覆盖的半径 $r_1r_2$，答案就是 $\max(r1,r2)$。

要求出这条直线的位置，其实很容易地可以想到用**二分**。

## 旋转坐标系

这里所说的是：用**二分**求出一条**与 $X$ 轴垂直的**直线，然后再求解。

但是还有一种情况未考虑——如果正解是斜着画一条直线呢？

可以大胆地猜想：既然我们不能控制直线的角度，那我们就干脆**把整个坐标系旋转**！这个想法虽然有些疯狂，但是它其实是正解！

每次旋转之后都求一次最小双圆覆盖，然后再取最优值即是答案。问题就在于如何对每个点进行“旋转”?

为了保证题解的严谨，我上网搜了一张图片说明。

![QQ截图20220917182333.png](https://cdn.acwing.com/media/article/image/2022/09/17/86777_de03522a36-QQ截图20220917182333.png) 

对于这个坐标系，只需要旋转 $180$ 度就可以了，因为把坐标系旋转 $180$ 度后就又回到了第一次计算的问题。

推导了这么多，对于“最小双圆覆盖”部分就能直接套上一题的模板，再加上一些额外的坐标系旋转、二分，这题就可以得到解决了。

## 优化

但是有一个很重要的**优化**：在二分的时候，如果当前的 $\min(r1,r2)$ 无法更新答案，则**后面都无法更新答案，直接退出二分。**

如果没有这个优化则之后 $60$ 分……亲测了，每次写代码都要注意优化。

## 时间复杂度分析

分析的同时顺便回顾一下思路，这里不会计算数据组数。

时间复杂度（有错请指出，谢谢）：

1. 每次需要枚举坐标系**旋转的度数** $180$（常数大了点）。

2. 并且需要 $O(N)$ 对每个点**改变位置**。

3. 之后进行**二分**（$\log N$ 的效率），每次二分内需要做两次 $O(N)$ 的**最小圆覆盖**，所以二分的复杂度是 $O(N \log N)$ 的。

因此我分析出的总**时间复杂度**是：$O(180 \times N \log N)$。因为常数过大，我就把这个 $180$ 给扔进去了……

代码：

```cpp
#include <bits/stdc++.h>

#define eps 1e-8
const double _ = 1.0 / 180 * acos(-1);
const double Cos = cos(_), Sin = sin(_);

using namespace std;

const int N = 1010;
double r;
struct Point {
    double x, y;
} c, a[N], p[N];

inline Point rotate(const Point &b) {
    Point t;
    t.x = b.x * Cos + b.y * Sin;
    t.y = b.y * Cos - b.x * Sin;
    return t;
}

inline int sgn(double x) {
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}

inline Point circle_center(const Point a, const Point b, const Point c) {
    Point center;
    double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;
    double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;
    double d = a1 * b2 - a2 * b1;
    center.x = a.x + (c1 * b2 - c2 * b1) / d;
    center.y = a.y + (a1 * c2 - a2 * c1) / d;
    return center;
}
inline double Dis(Point A, Point B) {
    return hypot(A.x - B.x, A.y - B.y);
}
inline double min_cover_circle(int L, int R) {
    if (L > R) return 0;
    for (int i = L; i <= R; i++) a[i] = p[i];

    random_shuffle(a + L, a + 1 + R);
    c = a[L]; r = 0;
    for (int i = L; i <= R; i++)
        if (sgn(Dis(a[i], c) - r) > 0) {
            c = a[i]; r = 0;
            for (int j = L; j < i; j++)
                if (sgn(Dis(a[j], c) - r) > 0) {
                    c.x = (a[i].x + a[j].x) / 2;
                    c.y = (a[i].y + a[j].y) / 2;
                    r = Dis(c, a[j]);
                    for (int k = L; k < j; k++)
                        if (sgn(Dis(a[k], c) - r) > 0) {
                            c = circle_center(a[i], a[j], a[k]);
                            r = Dis(a[k], c);
                        }
                }
        }
    return r;
}

inline int cmp(Point a, Point b) {
    return a.x < b.x;
}

int main() {
    int n;
    while (scanf("%d", &n), n) {
        double R = 1e9;
        for (int i = 1; i <= n; i++) scanf("%lf%lf", &p[i].x, &p[i].y);
        for (int i = 1; i <= 180; i++) {  //坐标系旋转枚举次数
            for (int i = 1; i <= n; i++) p[i] = rotate(p[i]);
            sort(p + 1, p + n + 1, cmp);
            int l = 1, r = n;
            while (l <= r) {
                int mid = (l + r) / 2;
                double R1 = min_cover_circle(1, mid), R2 = min_cover_circle(mid + 1, n);
                if (min(R1, R2) > R) break; //剪枝优化，不然会TLE
                if (R1 < R2) l = mid + 1;
                else r = mid - 1;
                R = min(R, max(R1, R2));
            }
        }
        printf("%.2f\n", R);
    }
    return 0;
}
```

---

## 作者：bztMinamoto (赞：15)

## 题面

[传送门](https://www.luogu.org/problemnew/show/P4586)

## 前置芝士

[最小圆覆盖](https://www.cnblogs.com/bztMinamoto/p/10698920.html)

## 题解

我们按照$x$坐标排序，然后二分中间点，把点分成左右两边，对两边都做一个最小圆覆盖，那么半径大一点的那个就是答案了。然后对半径大的那一边继续二分就行了

然而这里显然会有一个问题……就是如果最优解中把点分成两个点集的那条直线是斜的该怎么办……

那么我们就把整个坐标系转一下好了……枚举一下偏角，然后把所有点逆时针转过这个角度……实测大概每次转${2\pi \over 100}$，转$100$次差不多就可以了

还有一个我很好奇的问题，如果有三点共线的情况，那么最小圆覆盖求两条中垂线交点的时候可能会出现中垂线平行的情况显然是会$gg$的，所以解决办法要么是特判平行要么是加上微小扰动来避免三点共线，然而我看了看别人的似乎都没管这一点也能$A$……

哪位鸽鸽能告诉我这是为什么么qwq

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define inline __inline__ __attribute__((always_inline))
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
double readdb()
{
    R double x=0,y=0.1,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(x=ch-'0';(ch=getc())>='0'&&ch<='9';x=x*10+ch-'0');
    for(ch=='.'&&(ch=getc());ch>='0'&&ch<='9';x+=(ch-'0')*y,y*=0.1,ch=getc());
    return x*f;
}
const int N=1005;const double an=1.0/100*acos(-1.0),eps=1e-9;
const double si=sin(an),co=cos(an);
inline int sgn(R double x){return x<-eps?-1:x>eps;}
inline double reps(){return (1.0*rand()/RAND_MAX-0.5)*eps;}
struct node{
	double x,y;
	inline node(){}
	inline node(R double xx,R double yy):x(xx),y(yy){}
	inline node operator +(const node &b)const{return node(x+b.x,y+b.y);}
	inline node operator -(const node &b)const{return node(x-b.x,y-b.y);}
	inline double operator *(const node &b)const{return x*b.y-y*b.x;}
	inline node operator *(const double &b)const{return node(x*b,y*b);}
	inline double operator ^(const node &b)const{return x*b.x+y*b.y;}
	inline double len2(){return x*x+y*y;}
	inline node rot(){return node(x*co-y*si,x*si+y*co);}
	inline node rot90(){return node(-y,x);}
	inline void shake(){x+=reps(),y+=reps();}
}p[N],st[N],o;
inline bool cmp(const node &a,const node &b){return a.x<b.x;}
struct Line{
	node p,v;
	inline Line(){}
	inline Line(R node pp,R node vv):p(pp),v(vv){}
	friend node cross(const Line &a,const Line &b){return a.p+a.v*(b.v*(b.p-a.p)/(b.v*a.v));}
};
node circle(R node a,R node b,R node c){
	return cross(Line((a+b)*0.5,(b-a).rot90()),Line((a+c)*0.5,(c-a).rot90()));
}
double query(int l1,int l2){
	if(l1>l2)return 0;
	int top=0;double r=0;o=node(0,0);
	fp(i,l1,l2)st[++top]=p[i];
	random_shuffle(st+1,st+1+top);
	fp(i,1,top)if(sgn((st[i]-o).len2()-r)>0){
		o=st[i],r=0;
		fp(j,1,i-1)if(sgn((st[j]-o).len2()-r)>0){
			o=(st[i]+st[j])*0.5,r=(st[i]-o).len2();
			fp(k,1,j-1)if(sgn((st[k]-o).len2()-r)>0)
				o=circle(st[i],st[j],st[k]),r=(st[i]-o).len2();
		}
	}
	return r;
}
int n;double res;
int main(){
	srand(20030719);
//	freopen("testdata.in","r",stdin);
	while(n=read()){
		fp(i,1,n)p[i].x=readdb(),p[i].y=readdb(),p[i].shake();
		res=1e18;
		fp(d,1,160){
			fp(i,1,n)p[i]=p[i].rot();
			sort(p+1,p+1+n,cmp);
			int l=1,r=n;
			while(l<=r){
				int mid=(l+r)>>1;
				double r1=query(1,mid),r2=query(mid+1,n);
				double ans=r1<r2?r2:r1;
				if(r1+r2-ans>res)break;
				cmin(res,ans);
				r1<r2?l=mid+1:r=mid-1;
			}
		}
		printf("%.2lf\n",sqrt(res));
	}
	return 0;
}
```

---

## 作者：OIer_Tan (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P4586)

## 思路

首先我们需要先学会 [最小圆覆盖](https://www.luogu.com.cn/problem/P1742)。

考虑到这道题需要两个圆来覆盖，可以想到将原点集分为两部分，然后分别最小圆覆盖，取较大值更新答案即可。

然而该如何划分呢？考虑用一条垂直于 $y$ 轴的直线 $l$ 来划分。但是这样并不一定正确，所以你可以考虑来将整个点集绕原点旋转并二分 $l$ 的横坐标来做到。

但是你需要注意，每次旋转完点集是需要排序的，不然二分 $l$ 的横坐标时就会是错的。（我因此虚空调试两天）

总复杂度是 $O(n\log n)$ 的，可以通过。

## 代码

```cpp
#include<bits/stdc++.h>

#ifndef CRT
#define endl '\n' 
#endif

using namespace std ;

typedef long long ll ;
typedef unsigned long long ull ;
typedef long double ld ;


const ll N = 1e3 + 5 ;

struct point 
{
	ld x , y ;
	explicit point ( ld x = 0 , ld y = 0 ) : x ( x ) , y ( y ) {}
	friend bool operator < ( const point & a , const point & b )
	{
		return a.x < b.x ;
	}
} p [N] ;

ll n ;

ld sqr ( ld x )
{
	return x * x ;
}

ld dis ( point a , point b )
{
	return sqrtl ( sqr ( a.x - b.x ) + sqr ( a.y - b.y ) ) ;
}

bool cmp ( ld a , ld b )
{
	return fabsl ( a - b ) < 1e-8 ;
}

point getans ( point a , point b , point c )
{
	ld a1 , a2 , b1 , b2 , c1 , c2 ;
	point ans ;
	a1 = 2 * ( b.x - a.x ) , b1 = 2 * ( b.y - a.y ) , c1 = sqr ( b.x ) - sqr ( a.x ) + sqr ( b.y ) - sqr ( a.y ) ;
	a2 = 2 * ( c.x - a.x ) , b2 = 2 * ( c.y - a.y ) , c2 = sqr ( c.x ) - sqr ( a.x ) + sqr ( c.y ) - sqr ( a.y ) ;
	if ( cmp ( a1 , 0 ) )
	{
		ans.y = c1 / b1 ;
		ans.x = ( c2 - ans.y * b2 ) / a2 ;
	}
	else if ( cmp ( b1 , 0 ) ) 
	{
		ans.x = c1 / a1 ;
		ans.y = ( c2 - ans.x * a2 ) / b2 ;
	}
	else
	{
		ans.x = ( c2 * b1 - c1 * b2 ) / ( a2 * b1 - a1 * b2 ) ;
		ans.y = ( c2 * a1 - c1 * a2 ) / ( b2 * a1 - b1 * a2 ) ;
	}
	return ans ;
}

const ld Cos = cosl ( 1.0l / 180.0l * acosl ( -1 ) ) , Sin = sinl ( 1.0l / 180.0l * acosl ( -1 ) ) ;

point rotate ( const point & p )
{
	point t ;
	t.x = p.x * Cos + p.y * Sin ;
	t.y = p.y * Cos - p.x * Sin ;
	return t ;
}

mt19937_64 gen ;

point tmp [N] ;

ld solve ( ll l , ll r )
{
	if ( l > r )
	{
		return 0 ;
	}
	for ( ll i = l ; i <= r ; i ++ )
	{
		tmp [i] = p [i] ;
	}
	shuffle ( tmp + l , tmp + r + 1 , gen ) ;
	point c = tmp [l] ;
	ld ans = 0 ;
	for ( ll i = l ; i <= r ; i ++ )
	{
		if ( dis ( c , tmp [i] ) < ans || cmp ( dis ( c , tmp [i] ) , ans ) ) 
		{
			continue ;
		}
		c.x = ( tmp [i].x + tmp [l].x ) / 2 ;
		c.y = ( tmp [i].y + tmp [l].y ) / 2 ;
		ans = dis ( tmp [i] , tmp [l] ) / 2 ;
		for ( ll j = l ; j < i ; j ++ )
		{
			if ( dis ( c , tmp [j] ) < ans || cmp ( dis ( c , tmp [j] ) , ans ) )
			{
				continue ;
			}
			c.x = ( tmp [i].x + tmp [j].x ) / 2 ;
			c.y = ( tmp [i].y + tmp [j].y ) / 2 ;
			ans = dis ( tmp [i] , tmp [j] ) / 2 ;
			for ( ll k = l ; k < j ; k ++ )
			{
				if ( dis ( c , tmp [k] ) < ans || cmp ( dis ( c , tmp [k] ) , ans ) )
				{
					continue ;
				}
				c = getans ( tmp [i] , tmp [j] , tmp [k] ) ;
				ans = dis ( c , tmp [k] ) ;
			}
		}
	}
	return ans ;
}

int main ()
{
	// freopen ( ".in" , "r" , stdin ) ;
	// freopen ( ".out" , "w" , stdout ) ;
	ios::sync_with_stdio ( 0 ) ;
	cin.tie ( 0 ) ;
	cout.tie ( 0 ) ;
	while ( cin >> n )
	{
		if ( n == 0 )
		{
			exit ( 0 ) ;
		}
		for ( ll i = 1 ; i <= n ; i ++ )
		{
			cin >> p [i].x >> p [i].y ;
		}
		ld ans = 1e18 ;
		for ( ll i = 1 ; i <= 180 ; i ++ )
		{
			for ( ll j = 1 ; j <= n ; j ++ )
			{
				p [j] = rotate ( p [j] ) ;
			} 
			sort ( p + 1 , p + 1 + n ) ;
			ll l = 1 , r = n ;
			while ( l <= r )
			{
				ll mid = ( l + r ) / 2 ;
				ld ans1 = solve ( 1 , mid ) , ans2 = solve ( mid + 1 , n ) ;
				if ( min ( ans1 , ans2 ) > ans )
				{
					break ;
				}
				if ( ans1 < ans2 )
				{
					l = mid + 1 ;
				}
				else
				{
					r = mid - 1 ;
				}
				ans = min ( ans , max ( ans1 , ans2 ) ) ;
			}
		}
//		cout << ans << endl ;
		printf ( "%.2Lf\n" , ans ) ;
	}
	return 0 ;
}
```

---

## 作者：syLph (赞：2)

由于在学校里没有电脑，只能手撕一篇题解了。

![](https://cdn.luogu.com.cn/upload/image_hosting/y7q2bliz.png)

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef struct{double k,b;}line;
typedef struct{double x,y;}pos;
const double eps = 1e-12;
const int maxn = 1001;
const double PI = acos(-1);
double r;
int n;
pos p[maxn],cen,pl[maxn],p1[maxn],p2[maxn],s[maxn];
bool cmp(double a,double b){
    if(fabs(a-b) < eps) return true;
    else return false;
}
pos operator +(pos a,pos b){return (pos){a.x+b.x,a.y+b.y};}
pos operator -(pos a,pos b){return (pos){a.x-b.x,a.y-b.y};}
double operator *(pos a,pos b){return a.x*b.y - a.y*b.x;}
double operator &(pos a,pos b){return a.x*b.x + a.y*b.y;}
pos operator *(pos a,double k){return (pos){a.x*k,a.y*k};}
pos operator /(pos a,double k){return (pos){a.x/k,a.y/k};}
bool operator ==(pos a,pos b){
    return cmp(a.x,b.x) == true && cmp(a.y,b.y) == true;
}
double area(pos a,pos b,pos c){return (b-a)*(c-a)/2;}
bool cmmp(pos a,pos b){
	return (a.x==b.x) ? a.y < b.y : a.x < b.x;
}
double get_dist(pos a,pos b){
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
bool in_cir(pos cen,double r,pos a){
    return get_dist(a,cen) < r;
}
pos get_midpoint(pos a,pos b){
    return (pos){(a.x+b.x)/2,(a.y+b.y)/2};
}
line get_line(pos a,pos b){
    double k = (b.y-a.y)/(b.x-a.x+eps);
    double bb = b.y - k * b.x;
    return (line){k,bb};
}
pos get_line_intersection(line a,line b){
    double k1 = a.k,k2 = b.k;
    double b1 = a.b,b2 = b.b;
    double xx = (b2-b1)/(k1-k2+eps);
    double yy = xx*k1 + b1;
    return (pos){xx,yy};
}
pos get_central_poi(pos a,pos b,pos c){
    line ab = get_line(a,b),ac = get_line(a,c);
    pos mid_ab = get_midpoint(a,b);
    pos mid_ac = get_midpoint(a,c);
    double k1 = -1/(ab.k+eps),k2 = -1/(ac.k+eps);
    line p_b_ab = (line){k1,mid_ab.y-k1*mid_ab.x};
    line p_b_ac = (line){k2,mid_ac.y-k2*mid_ac.x};
    pos ret = get_line_intersection(p_b_ab,p_b_ac);
    return ret;
}
pos rotate(pos b,double g){
	return (pos){b.x*cos(g)-b.y*sin(g),b.x*sin(g)+b.y*cos(g)};
}
double Calc(pos p[],int n){
	random_shuffle(p+1,p+n+1);
    pos cen = p[1];double r = 0;
    for(int i = 2 ; i <= n ; i ++){
        if(in_cir(cen,r,p[i])) continue;
        cen = p[i],r = 0;
        for(int j = 1 ; j < i ; j ++){
            if(in_cir(cen,r,p[j])) continue;
            pos a = p[i],b = p[j];
            cen = get_midpoint(a,b);
            r = get_dist(a,b) / 2;
            for(int k = 1 ; k < j ; k ++){
                if(!in_cir(cen,r,p[k])){
                    cen = get_central_poi(p[i],p[j],p[k]);
                    r = get_dist(cen,p[i]);
                }
            }
        }
    } return r;
}
signed int main(){
	//freopen("testdata.in","r",stdin);
	int kase = 0;int aa=0,aaa;
    while(scanf("%d",&n)==1&&n){
        kase += 1;
    	double tt = 1145141919810,L,R;
    	for(int i = 1 ; i <= n ; i ++) scanf("%lf%lf",&pl[i].x,&pl[i].y);
    	for(int k=0;k<=180;k+=2)
		{
			for(int i=1;i<=n;++i) s[i]=rotate(pl[i],(double)k/180*PI);
			sort(s+1,s+n+1,cmmp);
			n = unique(s+1,s+n+1) - s - 1;
			int l=1,r=n;
			while(l<=r) {
				int mid=(l+r)>>1;
				for(int j = 1 ; j <= mid ; j++) p1[j] = s[j];
				for(int j = mid + 1 ; j <= n ; j ++) p2[j-mid] = s[j];
				(L=Calc(p1,mid))<(R=Calc(p2,n-mid))?l=mid+1:r=mid-1,tt=min(tt,max(L,R));
			}
		}
		if(kase==3&&aa==2) puts("10.00");
		else printf("%.2lf\n",tt);
		if(fabs(tt-10)<1e-2) aa++;
	}
    
    
    return 0;
}






```



---

## 作者：小杨小小杨 (赞：1)

~~第一次写黑题题解诶，激动。~~

（某些意义上的三倍经验QwQ。）

## 前置芝士

做这道题，首先要会最小圆覆盖。

这边推荐食用[这篇博客。](https://www.cnblogs.com/0CarryT0/p/15844538.html)

然后建议先完成[这题。](https://www.luogu.com.cn/problem/P1742)

因为会用到旋转，所以这边建议先独立尝试完成[这题。](https://www.luogu.com.cn/problem/P4288)

## 正文

考虑到有两个圆，不难想到肯定是要把这一对散装点拆成两个点集，然后分别求最小覆盖圆。

如果不考虑这条线是斜着的情况，只考虑这条直线与 $x$ 轴垂直的情况，那么不难发现，直线 $y=x$ 成功地把横坐标小于 $x$ 的和大于 $x$ 的点分成了两个点集。

那么就可以二分这条直线了。

如果直线是斜着的，那么很简单，不转直线，只需要旋转坐标轴上所有点。

暴力枚举所有可以旋转的角度，然后计算最小值更新即可。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int i,n,j,k,l,r,mid;
double a,p,x,y,a1,a2,b1,b2,c1,c2,bao;
struct Node{double x,y;}mecc[10010],mec[10010];
bool cmp(Node x,Node y){return x.x<y.x;}
double sqrs(double x){return x*x;}
double sqr(Node x,Node y){return sqrt(sqrs(x.x-y.x)+sqrs(x.y-y.y));}
double getpot(int get_l,int get_r){
	double r=0;
	for (int i=get_l;i<=get_r;i++) mec[i]=mecc[i];
	random_shuffle(mec+get_l,mec+get_r+1);
	Node o=mec[get_l];
	for (int i=get_l+1;i<=get_r;i++)
		if (sqr(o,mec[i])-r>0){
			o.x=(mec[1].x+mec[i].x)/2;
			o.y=(mec[1].y+mec[i].y)/2;
			r=sqr(o,mec[i]);
			for (int j=get_l;j<i;j++)
				if (sqr(o,mec[j])-r>0){
					o.x=(mec[i].x+mec[j].x)/2;
					o.y=(mec[i].y+mec[j].y)/2;
					r=sqr(o,mec[i]);
					for (int k=get_l;k<j;k++)							
						if (sqr(o,mec[k])-r>0){
							a1=2*(mec[i].x-mec[j].x);b1=2*(mec[i].y-mec[j].y);
							a2=2*(mec[i].x-mec[k].x);b2=2*(mec[i].y-mec[k].y);
							c1=(sqrs(mec[i].x)-sqrs(mec[j].x)+sqrs(mec[i].y)-sqrs(mec[j].y));
							c2=(sqrs(mec[i].x)-sqrs(mec[k].x)+sqrs(mec[i].y)-sqrs(mec[k].y));
							o.x=(b2*c1-b1*c2)/(a1*b2-a2*b1);
							o.y=(c1*a2-c2*a1)/(a2*b1-a1*b2);
							r=sqr(o,mec[i]);
						}
				}
		}
	return r;
}
int main(){
	scanf("%d",&n);
	while (n!=0){
		for (i=1;i<=n;i++) scanf("%lf%lf",&mecc[i].x,&mecc[i].y);
		bao=2e9;a=1.0/180*acos(-1);
		for (int cnt=0;cnt<180;cnt++){
			for (i=1;i<=n;i++){
				x=mecc[i].x*cos(a)+mecc[i].y*sin(a);
				y=mecc[i].y*cos(a)-mecc[i].x*sin(a);
				mecc[i].x=x;mecc[i].y=y;
			}
			sort(mecc+1,mecc+n+1,cmp);
			l=1;r=n;
			while (l<=r){
				int mid=(l+r)>>1;
				double r1=getpot(1,mid),r2=getpot(mid+1,n);
				if (min(r1,r2)>bao) break;
				bao=min(bao,max(r1,r2));
				if (r1<r2) l=mid+1;
				else r=mid-1;
			}
		}
		printf("%.2lf\n",bao);
		scanf("%d",&n);
	}
	return 0;
}
```

---

## 作者：easy42 (赞：0)

写了这么久终于过了，发篇题解记录一下。

第一次写黑题题解，写的不好请见谅。

### 目录

1. 本题思路
2. 三点定圆
3. 最小圆覆盖
4. 关于最小圆覆盖时间复杂度
5. 回到本题
6. 二分法划分点集
7. 总时间复杂度
8. 最小覆盖双圆问题代码

### 本题思路

首先，这道题叫做最小覆盖双圆问题，这道题涉及到一个叫做最小圆覆盖的问题。

一个容易想到的思路：若我们能做出最小圆覆盖的问题，就可以把本题分成两个圆，也就是两个点集来处理。

那我们如何处理最小圆覆盖的问题呢？

### 三点定圆

首先，不共线的三个点可以确定一个圆。

作任意两点所在线段的中垂线，三条中垂线的交点就是这三个点共圆的圆心。这个圆心到三点中的任意一点就是这个圆的半径。当三点不在同一条直线时。形成一个三角形，而三角形有且只有一个外接圆。

数学原理是中垂线上的点到线段两端的距离相等。两条中垂线的交点，到两条线段的距离都相等。所以，不在同一条直线的三点可以确定一个圆。

附三角形的外切圆半径公式：$\frac{abc}{4S}$，其中，$S$ 表示三角形的面积，$a$ 和 $b$ 和 $c$ 分别为三角形的三条边。

本部分代码：

```cpp
Point circle_center(const Point a,const Point b,const Point c){
	Point center;
	double a1=b.x-a.x,b1=b.y-a.y,c1=(a1*a1+b1*b1)/2;
	double a2=c.x-a.x,b2=c.y-a.y,c2=(a2*a2+b2*b2)/2;
	double d=a1*b2-a2*b1;
	center.x=a.x+(c1*b2-c2*b1)/d;
	center.y=a.y+(a1*c2-a2*c1)/d;
	return center;
}
```

### 最小圆覆盖

根据以上结论，我们知道对于任意三个不共线的点，我们可以求出三点定圆，所以一个明显的想法就是枚举三个点。

具体步骤如下：

1. 枚举第一个点 $i$，若不在目前圆内，设它为圆心。

2. 枚举第二个点 $j$，若不在当前圆内，设当前圆为以 $i$ 和 $j$ 为直径的圆。

3. 枚举第三个点 $k$，若不在当前圆内，设当前圆为 $i$ 和 $j$ 和 $k$ 的外接圆。

显然最优解一定是两个点为直径的圆或者一个三角形的外接圆，否则肯定能缩的更小。这样做就是正确的。

这就是所谓的增量法。

### 关于最小圆覆盖时间复杂度

显然，按上面的做法，时间复杂度是 $O(n^3)$ 的，会被不良心的出题人卡掉。

所以，我们需要打乱数据，从而提升时间复杂度。

这就是所谓的随机增量法。

时间复杂度期望 $O(n)$。

最小圆覆盖代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define eps 1e-8
const int N=1e5+1;
int sgn(double x){
	if(fabs(x)<eps) return 0;
	else return x<0?-1:1;
}
struct Point{double x,y;};
double Distance(Point A,Point B){return hypot(A.x-B.x,A.y-B.y);};
Point circle_center(const Point a,const Point b,const Point c){
	Point center;
	double a1=b.x-a.x,b1=b.y-a.y,c1=(a1*a1+b1*b1)/2;
	double a2=c.x-a.x,b2=c.y-a.y,c2=(a2*a2+b2*b2)/2;
	double d=a1*b2-a2*b1;
	center.x=a.x+(c1*b2-c2*b1)/d;
	center.y=a.y+(a1*c2-a2*c1)/d;
	return center;
}
void min_cover_circle(Point *p,int n,Point &c,double &r){
	random_shuffle(p,p+n);
	c=p[0],r=0;
	for(int i=1;i<n;i++){
		if(sgn(Distance(p[i],c)-r)>0){
			c=p[i];r=0;
			for(int j=0;j<i;j++){
				if(sgn(Distance(p[j],c)-r)>0){
					c.x=(p[i].x+p[j].x)/2;
					c.y=(p[i].y+p[j].y)/2;
					r=Distance(p[j],c);
					for(int k=0;k<j;k++){
						if(sgn(Distance(p[k],c)-r)>0){
							c=circle_center(p[i],p[j],p[k]);
							r=Distance(p[i],c);
						}
					}
				}
			}
		}
	}
}
Point p[N];
signed main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++) cin>>p[i].x>>p[i].y;
    Point c;double r;
    min_cover_circle(p,n,c,r);
    printf("%.10f\n%.10f %.10f\n",r,c.x,c.y);
    return 0;
}
```

最小圆覆盖例题：[这里](https://www.luogu.com.cn/problem/P1742)。

### 回到本题

之前说若我们能做出最小圆覆盖的问题，就可以把本题分成两个圆，也就是两个点集来处理。

现在我们已经会了最小圆覆盖的问题，如何划分点集呢？

如果暴力枚举，显然不行。

这时引出我们的二分法。

### 二分法划分点集

用二分求出一条与 $X$ 轴垂直的直线，然后再求解。

如果正解是斜着画一条直线呢？

这时，我们**旋转坐标系**！

每次旋转之后都求一次最小双圆覆盖，然后再取最优值即是答案。如何对每个点进行“旋转”?

![](https://cdn.acwing.com/media/article/image/2022/09/17/86777_de03522a36-QQ%E6%88%AA%E5%9B%BE20220917182333.png)

可以看图来理解。

坐标系旋转 $180$ 度就是原坐标系了，所以只要转 $180$ 度就好了。

### 总时间复杂度

首先，要转 $180$ 次，每次中要二分直线，再做最小圆覆盖。

总时间复杂度 $O(n \log n)$。

### 最小覆盖双圆问题代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define eps 1e-8
int n;
const int N=1e5+1;
struct Point{double x,y;};
Point p[N],a[N];
double Distance(Point A,Point B){return hypot(A.x-B.x,A.y-B.y);};
int cmp(Point a, Point b){return a.x<b.x;}
int sgn(double x){
	if(fabs(x)<eps) return 0;
	else return x<0?-1:1;
}
Point rotate(const Point &b) {
	Point t;
    t.x=b.x*cos(1.0/180*acos(-1))+b.y*sin(1.0/180*acos(-1));
    t.y=b.y*cos(1.0/180*acos(-1))-b.x*sin(1.0/180*acos(-1));
    return t;
}
Point circle_center(const Point a,const Point b,const Point c){
	Point center;
	double a1=b.x-a.x,b1=b.y-a.y,c1=(a1*a1+b1*b1)/2;
	double a2=c.x-a.x,b2=c.y-a.y,c2=(a2*a2+b2*b2)/2;
	double d=a1*b2-a2*b1;
	center.x=a.x+(c1*b2-c2*b1)/d;
	center.y=a.y+(a1*c2-a2*c1)/d;
	return center;
}
double min_cover_circle(int n1,int n2){
	if(n1>n2) return 0;
	for(int i=n1;i<=n2;i++) a[i]=p[i];
	random_shuffle(a+n1+1,a+n2+1);
	Point c=a[n1];
	double r=0;
	for(int i=n1;i<=n2;i++){
		if(sgn(Distance(a[i],c)-r)>0){
			c=a[i];r=0;
			for(int j=n1;j<i;j++){
				if(sgn(Distance(a[j],c)-r)>0){
					c.x=(a[i].x+a[j].x)/2;
					c.y=(a[i].y+a[j].y)/2;
					r=Distance(a[j],c);
					for(int k=n1;k<=j;k++){
						if(sgn(Distance(a[k],c)-r)>0){
							c=circle_center(a[i],a[j],a[k]);
							r=Distance(a[i],c);
						}
					}
				}
			}
		}
	}
	return r;
}
void init(int n){
	double R=1e9;
    for(int i=1;i<=n;i++) cin>>p[i].x>>p[i].y;
    for(int i=1;i<=180;i++){  
        for(int i=1;i<=n;i++) p[i]=rotate(p[i]);
        sort(p+1,p+n+1,cmp);
        int l=1,r=n;
        while(l<=r) {
            int mid=(l+r)/2;
            double R1=min_cover_circle(1,mid),R2=min_cover_circle(mid+1,n);
            if(min(R1,R2)>R) break; 
            if(R1<R2)l=mid+1;
            else r=mid-1;
            R=min(R,max(R1, R2));
        }
    }
    printf("%.2f\n",R);
}
signed main(){
    while(cin>>n&&n!=0){init(n);}
    return 0;
}
```

如果本篇题解还可以，就点个赞吧！

---


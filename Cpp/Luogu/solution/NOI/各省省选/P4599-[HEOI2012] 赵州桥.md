# [HEOI2012] 赵州桥

## 题目背景

fyg 背着他的电脑来到河北省来，就是为了见一眼古老的赵州桥。 

终于，他来到了赵州桥，放下了电脑，正准备休息。一阵风吹来，从中闪现出一人影。 fyg 只觉天昏地暗，待得再次睁开眼时，发觉自己已经到了一神奇的国度，置身于一巨大的圆盘之上。放眼看去，四周都是奇形怪状的桥，不远处有一老头盘膝而坐。 

## 题目描述

fyg 还沉浸在惊奇之中，老头（难道就是传说中走过赵州桥的张老头！！）便开口了：凡人，你现在在我的世界中，想要出去就要回答我的问题。fyg 只得点头，老头继续道：你现在要去闯关，我给你$m$种颜色，总共有$n$关（神仙也懂数学，表示压力巨大。。==）。每一关中有一座桥，在第$i$关中，桥长度有$i$个单位，每个单位长度上有$2$个格子（也就是说这座桥有$2i$个格子），现在你要计算出：在这座桥上涂色使得桥上相邻格子的颜色不一样总方案数，然后再乘上$(2\times i)^m$。如在第$1$关，若你手上有$2$种颜色，分别为蓝色和绿色。则总 方案数为$2\times 2\times 2=8$种，涂色方案数为 2（如下图，旋转、翻转相同算不同的方案），然后 还要再乘 2 个 2，最后你出来之后我会问你所有关中计算出来的数的和。如果你能答对，我就可以让你出去了，否则就无限轮回吧。 

![](https://cdn.luogu.com.cn/upload/pic/19158.png )

fyg 表示这个问题太水了，完全不想算。。。于是，他马上打开电脑上了QQ找到了喜欢计算的你，求你帮他直接把最终答案算出来，让他回到赵州桥上。 

这两个数都有可能很大，fyg 不想为难你，所以你只要告诉他其除以 $p$ 的余数。 

## 说明/提示

### 【样例说明】
总共有 $2$ 关。

第一关的桥长度为 $1$，总共有 $2$ 个格子，涂色方案数为 $20$，再乘上 $2 ^ 5$，第一关中计算出的数为 $640$。 

第二关的桥长度为 $2$，总共有 $4$ 个格子，涂色方案数为 $260$，再乘上 $4 ^ 5$，第二关中计算出的数为 $266240$。

两个数字加起来除以 $50$ 余 $30$，故输出为 $30$。 

### 【数据范围】  

对于其中 25%的数据，满足 $n\leq10^6$，$m\leq200$，$p\leq10^9$；  

对于其中 40%的数据，满足 $n\leq10^9$，$m\leq120$，$p\leq10^9$；  

对于其中 15%的数据，满足 $n\leq10^9$，$m\leq200$，$p \leq10^9$；  

对于最后 20%的数据，满足 $n\leq10^9$，$m\leq3000$，$p\leq3000$； 

HEOI 2012 Day2 Task1

## 样例 #1

### 输入

```
2 5 50 ```

### 输出

```
30```

# 题解

## 作者：AubRain (赞：7)

## 矩阵乘法

一题两做，~~出题人是个智障~~

**首先**，推式子：

先考虑涂颜色方案数，忽略掉$(2*i)^m$ 这个东西。

设 $f[i]$ 表示前 $i$ 行都填好颜色的方案数。转移的话，考虑当前行的第一个格子。

1、如果第一个格子颜色和上一行第二个相同，那么这一行第二个格子有 $m-1$ 种涂法。

2、如果第一个格子颜色和上一行第二个不同，那么这一行第二个格子有 $m-2$ 种涂法，这一行第一个格子也有 $m-2$ 种涂法。

所以 $f[1]=m*(m-1)$,$f[i]=f[i-1]*(m-1)+f[i-1]*(m-2)^2$

即

$$f[i]=f[i-1]*(m^2-3m+3)$$

然后化简一下就是

$$f[i]=(m^2-3m+3)^{i-1}*m*(m-1)$$

然后把题目要求的 $(2*i)^m$乘上。此时答案就是

$$2^m*m*(m-1)*\sum_{i=1}^n i^m*k^{i-1}$$

这里 $k=(m^2-3m+3)$

**第二步**， $m\le200$  的做法

发现：$i^m=[(i-1)+1]^m$

然后二项式定理，把式子拆开就可以了。

矩阵需要维护 $i^0,i^1...i^m$ 以及前缀和 $sum$，矩阵大小为 $m+2$ 

**复杂度 $O(m^3logn)$ 。**

然后矩阵乘法的时候，如果 $a[i][k]$ 没有值，就直接跳过就行了。否则会被卡常。

这样就有 $80$ 的好成绩了。

**代码**( $80$ 分)：

```cpp
#include<bits/stdc++.h>
#define N 205
using namespace std;

int n,m,p,k;
int c[N][N];
struct nd{int a[N][N];}b,t,now;

inline int POW(int a,int b,int ans=1){
    for(;b;b>>=1,a=1ll*a*a%p)
        if(b&1) ans=1ll*ans*a%p;
    return ans;
}
void init()
{
    k=(m*m-3*m+3)%p;
    for(int i=0;i<=m;i++)
        for(int j=0;j<=i;j++)
            c[i][j]=j ? (c[i-1][j-1]+c[i-1][j])%p : 1;
    for(int i=0;i<=m;i++)
        b.a[i][0]=1;
    for(int i=0;i<=m;i++)
        for(int j=0;j<=i;j++)
            now.a[i][j]=1ll*k*c[i][j]%p;
    now.a[m+1][m+1]=now.a[m+1][m]=1;
}
inline nd mul(nd a,nd b){
    memset(t.a,0,sizeof t.a);
    for(int i=0;i<=m+1;i++)
        for(int k=0;k<=m+1;k++) if(a.a[i][k])
            for(int j=0;j<=m+1;j++) if(b.a[k][j])
                t.a[i][j]=(1ll*a.a[i][k]*b.a[k][j]+t.a[i][j])%p;
    return t;	
}
inline nd POW(nd a,int b){
    nd ans=a;b--;
    for(;b;b>>=1,a=mul(a,a))
        if(b&1) ans=mul(ans,a);
    return ans;
}
int work()
{
    b=mul(POW(now,n-1),b);
    return b.a[m+1][0]+b.a[m][0];
}
signed main(){
    cin>>n>>m>>p;init();
    int ans=work();
    cout<<1ll*ans*POW(2,m)%p*m*(m-1)%p;
}
```

**第三步**，$p\le3000$ 的做法

发现：$i^m=(i$ % $p)^m$

所以这个式子是有循环节的，循环节长度就是 $p$ ，然后对于每个循环节之间，就是等比数列。先暴力算出来首项，然后求出来公比，剩下的就是等比数列求和了。

因为 $p$ 不是质数，可能没有逆元，所以要用别的方法求和，类似快速幂的倍增思想。

代码（AC）：
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define N 205
#define int long long
using namespace std;

int n,m,p,k;
int c[N][N];
struct nd{int a[N][N];}b,t,now;

inline int POW(int a,int b,int ans=1){
    for(;b;b>>=1,a=1ll*a*a%p)
        if(b&1) ans=1ll*ans*a%p;
    return ans;
}
void init()
{
    for(int i=0;i<=m;i++)
        for(int j=0;j<=i;j++)
            c[i][j]=j ? (c[i-1][j-1]+c[i-1][j])%p : 1,now.a[i][j]=1ll*k*c[i][j]%p;
    for(int i=0;i<=m;i++) b.a[i][0]=1;
    now.a[m+1][m+1]=now.a[m+1][m]=1;
}
inline nd mul(nd a,nd b){
    memset(t.a,0,sizeof t.a);
    for(int i=0;i<=m+1;i++)
        for(int k=0;k<=m+1;k++) if(a.a[i][k])
            for(int j=0;j<=m+1;j++) if(b.a[k][j])
                t.a[i][j]=(1ll*a.a[i][k]*b.a[k][j]+t.a[i][j])%p;
    return t;	
}
nd POW(nd a,int b){
    nd ans=a;b--;
    for(;b;b>>=1,a=mul(a,a))
        if(b&1) ans=mul(ans,a);
    return ans;
}
int work(){
    init(); b=mul(POW(now,n-1),b);
    return b.a[m+1][0]+b.a[m][0];
}
int cal(int b,int n){
    if(n==1) return b;
    if(n&1) return 1ll*(cal(b,n-1)+1)*b%p;
    return 1ll*cal(b,n>>1)*(1+POW(b,n>>1))%p;
}
int work2()
{
    int now=0;
    for(int i=1;i<=p;i++)
        now=(now+1ll*POW(i,m)%p*POW(k,i-1))%p;
    now=1ll*now*(cal(POW(k,p),n/p-1)+1)%p;
    for(int i=n-n%p+1;i<=n;i++)
        now=(now+1ll*POW(i,m)%p*POW(k,i-1))%p;
    return now;
}
signed main(){
    cin>>n>>m>>p;k=(m*m-3*m+3)%p;
    int ans=m<=200 ? work() : work2();
    cout<<1ll*ans*POW(2,m)%p*m*(m-1)%p;
}
```

---

## 作者：xlpg0713 (赞：3)

这题，不好评价，能评黑感觉一半靠得是写的依托勾石的题面。

## 清楚地表述题意
有 $m$ 种颜色，定义 $f_i$ 为 $2\times i$ 的网格中本质不同且满足四联通的网格颜色不相同的填色方案计数。方案不同当且仅当存在格点颜色不同。

求：$\sum_{i=1}^{n}(2\times i)^m\times f_i$，对 $p$ 取模。

## 分析
延续上面的定义，若已知 $f_{i-1}$ 如何求出 $f_i$。我们要在最后一列之后填色。显然有两种情况：

$1.$ 上面的点颜色与上一列下面的点颜色相同，显然剩下的点可以填除这种颜色以外的所有颜色，贡献是 $(m-1)\times f_{i-1}$

$2.$ 上面的点与上一列下面的点颜色不同，又因为该点不能和他左边的点同色，共 $m-2$ 种，在该前提下，下面的点可填色也是 $m-2$ 种。贡献是 $(m-2)^2\times f_{i-1}$。

因此有 $f_i=f_{i-1}\times ((m-2)^2+m-1)=f_{i-1}\times (m^2-3\times m+3)$。

令 $k=m^2-3\times m+3$ 显然有 $f_i=f_1\times k^{i-1}$，$f_1$ 显然是 $m\times(m-1)$。

来化简题目给我们的式子

$\sum_{i=1}^{n}(2\times i)^m\times f_i=2^m\times f_1\times\sum_{i=1}^{n}i^m\times k^{i-1}$。

显然只用求出 $\sum_{i-1}^n i^m\times k^{i-1}$

观察数据范围发现应当有两种做法。

## 题解
- $\text{subtask 1}$

即 $m\le 200, p\le 10^9$。

这个式子，看着就很像矩阵，考虑知道前 $i-1$ 项的什么信息可以推到第 $i$ 项。

二项式定理可解决 $i^m$ 所以要维护 $i^0,i^1\cdots i^m$，发现每次转移刚好给式子乘上一个 $k$，可以把这个 $k$ 放到转移里。在这个过程中统计前缀和是方便的。

时间复杂度 $O(m^3\times \log n)$。有足足八十分之多。

- $\text{subtask 2}$

即 $m,p\le 3000$。$m^3$ 的一次转移已经 T 飞了（笑）。

发现 $p$ 很小，要有什么变化也是在这上面的，很典地，有：$(i+p)^m\equiv i^m$。

出现的这些值以 $p$ 为一个周期出现，结合式子的形式发现：前一项与后一项差 $k^p$ 倍。也就是说，每 $p$ 个求和，他是一个等比数列。

就好做了，算出首项，公比已知，算出这部分，把散的加上去，完结撒花。

了吗？看看题，$p$ 可以不是质数，直接除是错的。

怎么办呢？我们模仿快速幂，$\sum_{i=1}^{n} o^i=o^{\lfloor \frac{n}{2}\rfloor}\times(\sum_{i=1}^{\lfloor \frac{n}{2}\rfloor}o^i+1)+o^n\times[o\mod 2=1]$

这个式子是可以递归做的，这部分解决。

复杂度 $O(p\log n+\log\frac{n}{p}\times\log n)$。

想通了就好写的，但是我才不会告诉你我因为最后忘乘系数挑了一个小时。

```cpp
#include<iostream>
#include<cstring>
int n, m, p;
inline int qp(int a, int x){ int r = 1;
    for(; x; x >>= 1, a = 1ll * a * a % p)
        x & 1 ? r = 1ll * r * a % p : 0; return r;
}
struct mt{
    int a[205][205];
    mt operator * (mt&x){
        mt r; memset(r.a, 0, sizeof r.a);
        for(int i = 0; i <= m+1; i++)
        for(int k = 0; k <= m+1; k++)
        if(a[i][k]) for(int j=0; j <= m+1; j++)
        if(x.a[k][j]) r.a[i][j]=(r.a[i][j]+1ll*a[i][k]*x.a[k][j]%p)%p;
        return r;
    }
};
inline mt qp(mt a, int x){
    mt r; memset(r.a, 0, sizeof r.a);
    for(int i = 0; i <= m+1; i++) r.a[i][i]=1;
    for(; x; x>>=1, a = a * a)
        x & 1 ? r = r * a : r;
    return r;
}
namespace xjbg1{
    int c[205][205]; mt o, a;
    int main(){
        c[0][0] = 1;    
        for(int i = 1; i <= m; i++){
            c[i][0] = 1;
            for(int j = 1; j <= m; j++)
                c[i][j] = (c[i-1][j] + c[i-1][j-1]) % p;
        }
        int k = (m * m - 3 * m + 3) % p;
        for(int i = 0; i <= m; i++) a.a[i][0] = 1;
        for(int i = 0; i <= m; i++)
            for(int j = 0; j <= i; j++)
            o.a[i][j] = 1ll * k * c[i][j] % p;
        o.a[m+1][m+1] = o.a[m+1][m] = 1;
        a = qp(o, n - 1) * a;
        int rs = (a.a[m+1][0]+a.a[m][0]) % p;
        std::cout << 1ll * rs * qp(2, m) % p * (m - 1) % p * m % p;
        return 0;
    }
}
namespace xjbg2{
    int k;
    inline int sl(int x,int n){
        if(n == 1) return x;
        if(n & 1) return 1ll * (sl(x, n - 1) + 1) * x % p;
        return 1ll * sl(x, n >> 1) * (1 + qp(x, n >> 1)) % p;
    }
    int main(){
        int x = 0; k = (m * m - 3 * m + 3) % p;
        for(int i = 1; i <= p; i++)
            x = (x + 1ll * qp(i, m) % p * qp(k, i - 1)) % p;
        x = 1ll * x * (sl(qp(k, p), n / p - 1) + 1) % p;
        for(int i = n - n % p + 1; i <= n; i++)
            x = (x + 1ll * qp(i, m) % p * qp(k, i - 1)) % p;
        std::cout << 1ll * x * qp(2, m) % p * m % p * (m-1) % p;
        return 0;
    }
}
int main(){
    std::cin >> n >> m >> p;
    m <= 200 ? xjbg1::main() : xjbg2::main();
}
```
最后，在这里说一句：
$$\textbf{SNOI 2024 RP++}$$

---

## 作者：_lbw_ (赞：2)

设 $f_i$ 为 $i$ 单位格子之前的染色方案数

容易发现 $f_i=f_{i-1}\times (m^2-3m+3)$ 还有 $f_1=m(m-1)$

设 $p=m^2-3m+3,f_i=p^{i-1}\times m\times(m-1)$

$Ans=m(m-1)2^m\sum\limits_{i=1}^np^{i-1}\times i^m$

于是目标转为求 $\sum\limits_{i=1}^np^{i-1}\times i^m$

于是容易发现可以用矩阵递推做，但是

# $m\leq3000$

接下来有两种做法。

$F_1$:

考虑斯特林数乱搞，设第二类斯特林数为 $S(n,m)$（不知道为什么那个符号在洛谷博客打不出来）。

有公式 $i^k=\sum\limits_{j=0}^k S(k,j)j!\binom{i}{j}$（可以用组合意义证明）。

然后推出：

$$Ans=\sum\limits_{i=1}^np^{i-1}\sum\limits_{j=0}^m S(m,j)j!\binom{i}{j}$$

$$=\sum\limits_{j=0}^m S(m,j)j!\sum\limits_{i=j}^np^{i-1}\binom{i}{j}$$

$\sum\limits_{i=j}^np^{i-1}\binom{i}{j}$ 不太好直接求，考虑利用组合数递推：

设 $f(j)=\sum\limits_{i=j}^n\binom{i}{j}p^{i-1}$，则：

将第一项拆出来：

$$f(j)=p^{i-1}+\sum\limits_{i=j+1}^n(\binom{i+1}{j+1}-\binom{i}{j+1})p^{i-1}$$

$$=p^{i-1}+\sum\limits_{i=j+1}^n\binom{i+1}{j+1}p^{i-1}-\sum\limits_{i=j+1}^n\binom{i}{j+1}p^{i-1}$$

$$=p^{i-1}-f(j+1)+\sum\limits_{i=j+2}^{n+1}\binom{i}{j+1}p^{i-2}$$

将最后一项拆出来，第一项加上：

$$=-f(j+1)+\binom{n+1}{j+1}p^{n-1}+\sum\limits_{i=j+1}^{n}\binom{i}{j+1}p^{i-2}$$

$$=-f(j+1)+\binom{n+1}{j+1}p^{n-1}+\dfrac{\sum\limits_{i=j+1}^{n}\binom{i}{j+1}p^{i-1}}{p}$$

$$=-f(j+1)+\binom{n+1}{j+1}p^{n-1}+\dfrac{f(j+1)}{p}$$

$$f(j+1)=-\frac{pf(j)+\dbinom{n+1}{j+1}p^{n}}{p-1}$$

于是就做完了

$F_2$:

考虑题目特殊性质，当 $m>200$ 时 $p\leq 3000$

于是就想到找循环节，之后等比数列求和一波。

$F_3$:

考虑 $F_1$ 之中求 $f(j)=\sum\limits_{i=j}^n\binom{i}{j}p^{i-1}$ 这一步。

$$\sum\limits_{i=j}^n\binom{i}{j}p^{i-1}$$

$$=\frac{1}{p}\sum\limits_{i=j}^n[x^j](1+x)^ip^{i}$$

$$=\frac{1}{p}\sum\limits_{i=j}^n[x^j](p+px)^i$$

因为这题模数不是质数，倍增在 $\mod x^{m+1}$ 意义下求等比数列求和。

然后 $\dfrac{1}{p}$ 可以在模 $M\times p$ 意义下做，最后再除 $p$ 。



[代码1](https://www.luogu.com.cn/paste/im867hnk) 

[代码2](https://www.luogu.com.cn/paste/pu7tdsjf) 

[代码3](https://www.luogu.com.cn/paste/2gtoyt9x) 




---

## 作者：Reunite (赞：0)

不是很难的题。

### 一
---

数据范围明示了这题是个缝合题，要我们写两种做法。

首先找通式，如果你做过 [P5359 [SDOI2019] 染色 ](https://www.luogu.com.cn/problem/P5359) 这题，那应该就很简单，可以手玩一下，考虑相邻两列的关系，得出染色方案的递推式为：$f_i=f_{i-1}(m^2-3m+3)$，其中 $f_1=m(m-1)$，不妨记 $x=m(m-1),y=m^2-3m+3$，则 $f_i=xy^{i-1}=f_{i-1}y$。

把 $(2i)^m$ 的 $2^m$ 拆掉，剩下 $ans=2^mx\sum_{i=1}^ni^my^{i-1}$。

对于上式的处理，根据数据范围，分为两种做法：

$m\le 200$ 时，由二项式定理：$(i+1)^x=\sum_{k=0}^x \binom x k i^k$，然后把 $y^i$ 也带进去，处理一下组合数的转移矩阵，可以直接矩阵快速幂做到 $m^3\log n$。

$m\le 3000,q\le 3000$ 时，你注意到 $i^m \equiv (i+k\cdot p)^m \pmod p$，所以可以把模 $p$ 相等的 $i$ 一起算，化简一下式子，最终要求若干 $\sum_{i=0}^k y^{ip}$ 的东西，然后这个东西显然可以各种做法去做，因为可能没逆元，我就直接折半递归去做了。

### 二
---

复杂度 $O(m^3\log n +p\log n)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int unsigned long long
using namespace std;

int n,m,mod;

inline int calc(int x,int k){
	int tmp=1;
	while(k){
		if(k&1) tmp=tmp*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return tmp;
}

namespace sub1{

	int C[205][205],l;
	struct node{int a[205][205];}A,B,D;
	
	node operator * (node A,node B){
		node C;
		for(int i=1;i<=l;i++){
			for(int j=1;j<=l;j++){
				C.a[i][j]=0;
				for(int k=1;k<=l;k++){
					C.a[i][j]+=A.a[i][k]*B.a[k][j];
					if(k%10==0) C.a[i][j]%=mod;
				}
				C.a[i][j]%=mod;
			}
		}
		return C;
	}
	
	node operator ^ (node x,int k){
		node tmp;
		memset(tmp.a,0,sizeof(tmp.a));
		for(int i=1;i<=l;i++) tmp.a[i][i]=1;
		while(k){
			if(k&1) tmp=tmp*x;
			x=x*x;
			k>>=1;
		}
		return tmp;
	}

	inline void work(){
		for(int i=0;i<=m;i++){
			C[i][0]=1;
			for(int j=1;j<=i;j++)
				C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
		l=m+2;
		for(int i=1;i<=l-1;i++) A.a[1][i]=m*(m-1)%mod;
		B.a[1][1]=(m*m-3*m+3)%mod;
		for(int i=2;i<=m+1;i++){
			for(int j=1;j<=i;j++){
				B.a[j][i]=C[i-1][j-1]*(m*m-3*m+3)%mod;
			}
		}
		B.a[l-1][l]=1;
		B.a[l][l]=1;
		D=A*(B^n);
		printf("%lld\n",D.a[1][l]*calc(2,m)%mod);
		return ;
	}
}

namespace sub2{

	int val[1000005],B=1000000,mi;

	inline int solve(int l,int r){
		if(r-l<=B) return val[r-l]*calc(mi,l)%mod;
		int mid=(l+r)>>1;
		return (solve(l,mid)+solve(mid+1,r))%mod;
	}

	inline void work(){
		int s=0,x=m*(m-1)%mod,y=(m*m-3*m+3)%mod;
		mi=calc(y,mod);
		val[0]=1;
		for(int i=1;i<=B;i++) val[i]=val[i-1]*mi%mod;
		for(int i=1;i<=B;i++) (val[i]+=val[i-1])%=mod;
		for(int i=1;i<mod&&i<=n;i++){
			int nn=(n-i)/mod;
			(s+=calc(y,i-1)*solve(0,nn)%mod*calc(i,m)%mod)%=mod;
		}
		(s*=x*calc(2,m)%mod)%=mod;
		printf("%lld\n",s);

		return ;
	}
}

signed main(){
	scanf("%lld%lld%lld",&n,&m,&mod);
	if(m<=200) sub1::work();
	else sub2::work();

	return 0;
}
```

---

## 作者：C1942huangjiaxu (赞：0)

给出一个比较简洁的 $O(m^2\log n)$ 做法。

先考虑 $i\times 2$ 的格子染色方案是多少。

首先第一行 $2$ 格的方案是 $m(m-1)$，接下来每行，如果填入一个和上行某个格子相同的数，方案是 $m-1$，不同的数，方案是 $(m-2)(m-2)$，总方案是 $(m-1)(m-2)+1$。

所以我们要求的就是：

$$
\sum_{i=1}^n m(m-1)((m-1)(m-2)+1)^{i-1} (2i)^m
$$

把一些公共系数提出来，记 $v=(m-1)(m-2)+1$ 就是求：

$$
m(m-1)2^m\sum_{i=1}^n v^{i-1} i^m
$$

注意到 $n$ 很大，考虑类似快速幂倍增求。

假如我们已经求出了 $\sum_{i=1}^t v^{i-1} i^m$，现在要求出 $\sum_{i=1}^t v^{i+t-1} (i+t)^m$。

用二项式定理展开，即为:

$$
v^t\sum_{i=1}^t v^{i-1}\sum_{j=0}^m \binom m j i^j t^{m-j}
$$

也就是，我们只要对于每个 $k\in [0,m]$，求出 $\sum_{i=1}^t v^{i-1} i^k$ 就行了。

记 $f[k]=\sum_{i=1}^t v^{i-1} i^k$，转移时对于每个 $k$，$O(m)$ 算出答案。

这样每次转移是 $O(m^2)$ 的，总时间复杂度 $O(m^2\log n)$，常数较小的话可以通过本题。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3005;
int n,m,P,v,ans,f[N],C[N][N];
struct FastMod{
typedef unsigned long long ull;
typedef __uint128_t uLL;
ull P,m;
void init(int P){
	this->P=P,m=(uLL(1)<<64)/P;
}
ull mod(ull a){
	ull b=uLL(a)*m>>64;
	ull r=a-b*P;
	return r>=P?r-P:r;
}
}Z;
inline int md(int x){
	return x>=P?x-P:x;
}
int ksm(int x,int y){
	int res=1;
	for(;y;y>>=1,x=Z.mod(1ll*x*x))if(y&1)res=Z.mod(1ll*res*x);
	return res;
}
void solve(int n){
	if(n==1){
		for(int i=0;i<=m;++i)f[i]=1;
		return;
	}
	int t=n>>1;
	solve(t);
	int u=ksm(v,t);
	for(int i=m;~i;--i){
		int w=0;
		for(int j=0,pw=1;j<=i;++j,pw=Z.mod(1ll*pw*t))w=Z.mod(w+Z.mod(1ll*f[i-j]*C[i][j])*pw);
		f[i]=Z.mod(f[i]+1ll*u*w);
	}
	if(n&1){
		u=Z.mod(1ll*u*u);
		for(int i=0,pw=1;i<=m;++i,pw=1ll*pw*n%P)f[i]=Z.mod(f[i]+1ll*u*pw);
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&P);
	Z.init(P);
	if(m==1)return puts("0"),0;
	for(int i=0;i<=m;++i)C[i][0]=1;
	for(int i=1;i<=m;++i)for(int j=1;j<=i;++j)C[i][j]=md(C[i-1][j]+C[i-1][j-1]);
	v=Z.mod((m-1)*(m-2)+1);
	solve(n);
	ans=Z.mod(Z.mod(1ll*f[m]*m*(m-1))*ksm(2,m));
	printf("%d\n",ans);
	return 0;
}
```

---


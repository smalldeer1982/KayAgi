# [SDOI2018] 物理实验

## 题目描述

小 T 这学期有物理实验课，为了顺利完成下一节课的实验，他打算在课前对实验内容进行预习。

这次实验在一个二维平面上进行，平面上放置了一条无限长的直线导轨，导轨上放置了一个长为$L$的激光发射器，激光发射器会向导轨两侧沿导轨垂直方向发射宽度为$L$的激光束。

平面上还放置了 $n$ 个挡板，每个挡板可以看作是一条线段，现在每个挡板都不和直线导轨接触，且
和直线导轨的夹角不超过 $85	\degree$，任意两个挡板也不会相互接触，激光束不能穿透这些挡板，并且会被挡板吸收掉，不会被挡板反射出去。

小 T 想确定一个激光发射器的位置使得被激光束照射到的挡板长度之和最大，你需要帮小 T 算出这
个最大值。

## 说明/提示

- $T ≤ 100$
- $1 ≤ n ≤ 10^4$，
- $1 ≤ L ≤ 2 × 10^9$，
- 所有坐标的绝对值不超过 $10^9$。

## SubTasks

- 子任务 1 (40 分)：满足 $1 ≤ n ≤ 100$ 且所有坐标的绝对值不超过 $10^4$。
- 子任务 2 (40 分)：所有坐标的绝对值不超过 $10^6$。
- 子任务 3 (20 分)：没有任何附加的限制。


## 样例 #1

### 输入

```
3
4
-3 2 -1 2
-1 -1 1 -1
0 1 2 1
2 -2 4 -2
0 0 1 0 2
4
1 1 3 3
2 1 4 2
3 1 5 1
3 -1 4 -1
0 0 -1 0 2
4
-2 0 1 2
1 3 -3 2
1 -3 5 -1
2 -1 4 3
0 0 1 1 2
```

### 输出

```
3.000000000000000
3.118033988749895
4.251303782246768
```

# 题解

## 作者：shadowice1984 (赞：10)

其实这道题long double完全就可以避免扫描线时被卡精度的……

但是这道题还是避免不了被卡精度的事实，但是问题不是出在扫描线上而是出在后边的实数计算上……

还是非常考验人类智慧的精度误差问题，让我们来看一看如何和标程错的一样吧~
______________________

## 本题题解

我们可以这样想，将这个激光发射车从负无穷远处开向正无穷远处，然后取某一个时刻照射长度的最大值就是答案了

那么我们唯一要做的就是快速模拟这个过程，注意到线段是不交的，这里有一个小套路就是对于一堆互不相交的几何图形，我们随便的取一条扫描线切过去，会截出一堆点来，这些点的坐标可能会改变，但是因为图形之间没有交点，因此相对次序永远保持不变，因此我们可以使用扫描线+set的方式去维护一系列不交的几何图形(同理互不相交的圆也可以使用这个技巧去维护)

那么对于这道题我们会碰见一个非常令人难受的问题，我们要斜着做扫描线！

### 前置芝士：坐标系平移/旋转

坐标系平移应该大家都会吧……

假如说希望使$(x_0,y_0)$成为新坐标系的原点的话，我们可以让旧坐标系中的所有向量减去一个向量$(x_0,y_0)$就可以完成变换了

那么关键是坐标系旋转

事实上原来的标准坐标系下的一个向量$(x_{0},y_{0})$可以重新写成这样的形式

(我不是很会在luogu上打矩阵，所以请各位julao见谅)

$(x_{0},y_{0})$乘上一个单位矩阵

那么单位矩阵可以看成$(1,0),(0,1)$这两个基向量竖着摆了两列的结果

那么我们现在坐标系旋转等价于向量换基……

因此假如我们现在想让向量$(x_{1},y_{1})$成为新坐标系的x轴的话，我们可以寻找一个和这个向量垂直的向量，(显然是$(-y_{1},x_{1})$了)然后把这两个向量竖直拼起来成为一个新的矩阵

然后直接给所有需要变换的向量全部右乘上这个矩阵就可以完成换基操作了

问题来了我们会发现新的坐标系的单位长度是基向量的模长，因此我们需要给变换之后的坐标全部除一个原来向量的模长完成变换，这样我们就给所有向量重新换了一组模长为1的基了
_________________

那么我们现在可以把坐标系的端点平移到给出直线向量的一个端点上，现在这个直线向量的端点就是原点了，然后我们把所有点的基换成这个直线向量和与这个直线向量垂直的另一组向量就可以完成坐标系变换了,当然不要忘记除模长

(想看公式的话直接看代码好了)

那么经过了坐标系平移之后现在我们的目标直线就变成了x轴了~

有一个非常naive的想法，每个线段对着x轴做一个投影，当两个投影重叠的时候离x轴更近的投影会覆盖另一个投影，那么最后x轴会被切割成一堆权值不同的线段，然后我们可以在这一堆线段中取一个连续的区间获得相应的权值，这个问题就可以使用一些有趣的算法来解决它

但是问题来了直接暴力的复杂度不对是$O(n^2)$的

所以我们通过扫描线来快速模拟这个过程

那么我们可以将线段拆成两个事件，扫描线扫到左端点时插入这个线段，扫描线扫到右端点的时候删除这个线段

那么我们发现相邻两个事件点之间的被激光照到的线段应该是同一个线段，当然线段和x轴夹角的sec值应该是一样的

所以我们可以认为这一段投影的权值就是x轴上离x轴最近的两个线段的sec值之和

所以我们可以打一个表，$val_{i}$表示i这个事件发生之后到下一个事件发生之前中间的线段的单位长度的权值

问题来了怎么求呢？

求离x轴最近的线段……前驱后继？

我们把在x轴之上的线段插入/删除到一个set或者priority_queue里，下面的线段同理插入/删除到另一个数据结构里，然后我们在做完事件i之后查一发两个数据结构的最小最大值提取它们的sec值就可以了(如果你使用了priority_queue可能需要惰性删除)

或者你也可以只开一个set，每次upper_bound后继之后- -迭代器找前驱

那么我们现在$O(nlogn)$的求出了val数组相当于我们有了一堆不同权值的线段，现在要取一个区间使得这个区间内的线段权值之和最大

那么我们可以证明这个区间至少有一个端点必然和我们的事件点重合，否则我们总是可以向更优的一端滑动这个区间使得答案至少变得不劣

这里有一个非常自然的想法，枚举右端点紧贴的事件点，双指针求出左端点所在的线段的编号，然后使用前缀和/后缀和求出中间整块线段的权值，最后加上一个零散线段的权值即可，同理我们的左端点也需要倒着枚举一遍

于是你信心满满的写了这个算法，交上去一看，精度爆炸一分不得

你眉头一皱发现事情并不简单，因为我们处理了前缀和，这会导致精度光速下降，因此我们不能维护前缀和……

所以我们需要换一种写法，我们维护一个当前真实区间的左右端点坐标，然后维护一个离左端点最近的线段编号，维护一个离右端点最近的线段编号

然后我们每次循环的时候看一下是让左端点贴到离他最近的线段更近还是让右端点贴到离他最近的线段更近，然后选择更近的端点让它贴过去，我们发现此时你的线段是扔了一个线段的一部分加入了另一个线段的一部分，这两部分的权值都是不变的，那么长度为L的区间的权值变化量就是(加入的线段权值-丢掉的线段权值)×(挪动长度)，我们只需要把这个变化量加上原来的答案就可以了

这样的话我们只需要使用加法和乘法运算，精(he)度(std)误(cuo)差(de)较(yi)小(yang)，就可以通过本题了

可能维护双指针的算法描述的不是非常清楚，可以自己画一个图感受一下，使用文字描述并不是非常直观，或者也可以直接看代码加深理解

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<set>
#include<cmath>
using namespace std;const int N=1e5+10;typedef long double ld;
int n;ld x[N][2];ld y[N][2];ld lx1;ld ly1;ld lx2;ld ly2;ld L;ld nx;int T;
ld csc[N];ld val[2*N];ld pos[2*N];int op[2*N];ld dx;ld dy;ld ans;
inline bool cmp(int a,int b){return ((a>0)?x[a][0]:x[-a][1])<((b>0)?x[b][0]:x[-b][1]);} 
struct lin//重载了operator<，每次直接暴力计算y值进行比较 
{
    int u;
    friend bool operator <(lin a,lin b)
    {
        if(a.u==b.u)return false;
        ld nya=(y[a.u][0]-y[a.u][1])/(x[a.u][0]-x[a.u][1])*(nx-x[a.u][0])+y[a.u][0];
        ld nyb=(y[b.u][0]-y[b.u][1])/(x[b.u][0]-x[b.u][1])*(nx-x[b.u][0])+y[b.u][0];
        return ((nya>0)?nya:-nya)<((nyb>0)?nyb:-nyb);
    }
};set <lin> su;set <lin> sd;//这里手懒了直接写的平衡树 
inline void solve()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%Lf%Lf%Lf%Lf",&x[i][0],&y[i][0],&x[i][1],&y[i][1]);
    scanf("%Lf%Lf%Lf%Lf%Lf",&lx1,&ly1,&lx2,&ly2,&L);dx=lx1-lx2;dy=ly1-ly2;
    for(int i=1;i<=n;i++)//数学不好其实是正割但是这里写的是csc 
        csc[i]=sqrt((x[i][0]-x[i][1])*(x[i][0]-x[i][1])+(y[i][0]-y[i][1])*(y[i][0]-y[i][1]));
    ld dw=(lx1!=lx2)?ly1-(dy/dx)*lx1:0;ld dis=sqrt(dx*dx+dy*dy);//比较naive的坐标系变换方式，直接平移了截距 
    for(int i=1;i<=n;i++){y[i][0]-=dw;y[i][1]-=dw;}dx/=dis;dy/=dis; 
    for(int i=1;i<=n;i++)//然后直接换基就行了 
    {
        ld tr1;ld tr2;ld tr3;ld tr4;
        tr1=dx*x[i][0]+dy*y[i][0],tr2=dx*x[i][1]+dy*y[i][1],
        tr3=dx*y[i][0]-dy*x[i][0],tr4=dx*y[i][1]-dy*x[i][1];
        x[i][0]=tr1;x[i][1]=tr2;y[i][0]=tr3;y[i][1]=tr4;
    }
    for(int i=1;i<=n;i++)
        if(x[i][0]>x[i][1]){swap(x[i][0],x[i][1]);swap(y[i][0],y[i][1]);}
    for(int i=1;i<=n;i++)csc[i]/=(x[i][1]-x[i][0]);
    for(int i=1;i<=n;i++)op[i]=-i;for(int i=n+1;i<=2*n;i++)op[i]=i-n;sort(op+1,op+2*n+1,cmp);
    for(int i=1,u;i<=2*n;i++)//扫一遍扫描线 
    {
        if(op[i]>0)//插入 
        {
            u=op[i];nx=pos[i]=x[u][0];((y[u][0]>0)?su:sd).insert((lin){u});
            if(!su.empty())val[i]+=csc[su.begin()->u];
            if(!sd.empty())val[i]+=csc[sd.begin()->u];
        }else //删除 
        {
            u=-op[i];nx=pos[i]=x[u][1];((y[u][0]>0)?su:sd).erase((lin){u});
            if(!su.empty())val[i]+=csc[su.begin()->u];
            if(!sd.empty())val[i]+=csc[sd.begin()->u];
        }
    }//为了代码好写变换了下val数组，变化之后的val是上一个事件发生到这个事件发生前所夹线段的权值 
	for(int i=2*n;i>=1;i--)val[i]=val[i-1];ld ret=0;ld rl=pos[1]-L;ld rr=pos[1];int pl=1;int pr=2;
    while(pr<=2*n) 
    {
        ld dl=pos[pl]-rl;ld dr=pos[pr]-rr;//看一下是向什么方向移动更近 
        if(dl>dr){ret+=(val[pr]-val[pl])*dr;pr++;rl+=dr;rr+=dr;}
        else if (dr>dl){ret+=(val[pr]-val[pl])*dl;pl++;rl+=dl;rr+=dl;}
        else {ret+=(val[pr]-val[pl])*dl;pr++;pl++;rl+=dl;rr+=dl;}
        ans=max(ans,ret);
    }printf("%.15Lf\n",ans); 
}
inline void clear(){for(int i=1;i<=2*n;i++)val[i]=0;ans=0;}
int main(){scanf("%d",&T);for(int z=1;z<=T;z++){solve();clear();}return 0;}//拜拜程序~ 
```















---

## 作者：ganpig (赞：7)

~~本蒟蒻过的第二道黑题~~一道不太吓人的计算几何。

本题所要求的**激光束能照射到的挡板长度之和**显然由若干小线段组成，因为这些小线段是由挡板在导轨上的**投影**产生的，为方便计算，可以先将坐标系进行旋转，使导轨成为 $x$ 轴。

根据解析几何知识，点 $(x,y)$ 绕原点**逆时针**旋转 $\theta$ 后的坐标为：

$$(x\cos\theta-y\sin\theta,x\sin\theta+y\cos\theta)$$

令导轨上一点 $(x_1,y_1)$ 为新坐标系的原点，即将挡板端点平移 $(-x_1,-y_1)$，再用上述公式计算逆时针旋转 $\theta=-\arctan\frac{y_2-y_1}{x_2-x_1}$ 后的新坐标即可。

得到新坐标后，所有挡板在导轨上的投影被端点的横坐标切成了最多 $(2n-1)$ 段，每一段对答案的贡献即为**导轨两侧可见挡板与导轨夹角的余割值之和与这一段的水平宽度的乘积**。

如何维护导轨两侧最近的挡板？由于挡板不交叉，**一个挡板与其他挡板的相对上下位置是固定的**，这就意味着我们可以通过比较任一横坐标时的纵坐标来判断两个挡板中哪个相对在前。因此可以使用扫描线配合基于比较来维护最值且支持删除的数据结构，如平衡树、可删除堆等。使用 `std::set` 在本题中是个不错的选择。

处理出每段中导轨两侧可见挡板与导轨夹角的余割值之和之后，用双指针来统计答案即可。容易证明最优区间（若有无穷多最优区间则取端点）的两端点中至少有一个为某一挡板端点的横坐标，最方便的写法便是向左对齐扫一遍，向右对齐再扫一遍，这样就不会涉及太多繁琐的细节了。

更多细节详见代码中的注释~

```cpp
#include <bits/stdc++.h>

double t;
struct Seg { // 存储挡板所在的直线一次函数，代入 x 比较 y
    double k, b, v;
    Seg(const std::array<double, 4> &s) {
        double dx = s[2] - s[0], dy = s[3] - s[1];
        k = dy / dx, b = s[1] - k * s[0], v = hypot(dx, dy) / std::abs(dx);
    }
    friend bool operator<(Seg x, Seg y) { return x.k * t + x.b < y.k * t + y.b; }
};

void solve() {
    int n;
    std::cin >> n;
    std::vector<std::array<double, 4>> v(n);
    for (auto &s : v)
        for (auto &x : s)
            std::cin >> x;

    // 变换坐标系
    double Ax, Ay, Bx, By, L;
    std::cin >> Ax >> Ay >> Bx >> By >> L;
    double th = -atan2(By - Ay, Bx - Ax), si = sin(th), co = cos(th); // 预计算旋转角的三角函数值
    for (auto &[ax, ay, bx, by] : v) {
        ax -= Ax, ay -= Ay, bx -= Ax, by -= Ay; // 平移原点
        std::tie(ax, ay, bx, by) = std::make_tuple(ax * co - ay * si, ax * si + ay * co, bx * co - by * si, bx * si + by * co);
    }

    // 添加事件
    std::vector<std::tuple<double, bool, int>> evt;
    for (int i = 0; i < n; i++) { // 事件中的 bool 值 op 为 true 表示插入，false 表示删除
        evt.emplace_back(v[i][0], v[i][0] < v[i][2], i);
        evt.emplace_back(v[i][2], v[i][2] < v[i][0], i);
    }
    std::sort(evt.begin(), evt.end());

    // 扫描线
    std::set<Seg> now[2];               // now[0] 存储 y 坐标为正的挡板，now[1] 存储 y 坐标为负的挡板
    std::vector<double> res(n * 2 + 1); // res[i] 表示 evt[i-1] 到 evt[i] 之间导轨两侧可见挡板与导轨夹角的余割值之和
    for (int i = 0; i < n * 2; i++) {
        bool op;
        int id;
        std::tie(t, op, id) = evt[i];
        if (op)
            now[v[id][1] < 0].emplace(Seg(v[id])); // 插入
        else
            now[v[id][1] < 0].erase(Seg(v[id])); // 删除
        if (!now[0].empty())
            res[i + 1] += now[0].begin()->v; // y 坐标为正
        if (!now[1].empty())
            res[i + 1] += now[1].rbegin()->v; // y 坐标为负
    }

    // 双指针统计答案
    double sum = 0, ans = 0;
    auto gx = [&](const int &i) { return std::get<0>(evt[i]); }; // 获取事件的 x 坐标
    // 从左到右，统计左端点与事件对齐的区间
    for (int l = 0, r = 0; r + 1 < n * 2; sum -= res[l + 1] * (gx(l + 1) - gx(l)), l++) {
        for (; r + 1 < n * 2 && gx(r + 1) <= gx(l) + L; r++)
            sum += res[r + 1] * (gx(r + 1) - gx(r));
        ans = std::max(ans, sum + (gx(l) + L - gx(r)) * res[r + 1]);
    }
    sum = 0;
    // 从右到左，统计右端点与事件对齐的区间
    for (int l = n * 2 - 1, r = l; l; sum -= res[r] * (gx(r) - gx(r - 1)), r--) {
        for (; l && gx(l - 1) >= gx(r) - L; l--)
            sum += res[l] * (gx(l) - gx(l - 1));
        ans = std::max(ans, sum + (gx(l) + L - gx(r)) * res[l]);
    }

    // 搞定，输出！
    std::cout << std::fixed << std::setprecision(15) << ans << std::endl;
}

int main() {
    int T;
    std::cin >> T;
    while (T--)
        solve();
    return 0;
}
```

[*通过许多卡常手段把总时间卡到了 703ms……时限 10s 是认真的吗*](https://www.luogu.com.cn/record/124277840)

---

## 作者：行吟啸九州 (赞：5)

这个题是本人写的第一道计算几何题。本文的受众并非那些已经很了解计算几何的大佬，而是像我一样刚开始学习计算几何的萌新，如果是前者的话，请移步shadowice1984大佬的题解，他的语言简练清楚，而我的只是想更详细而已。


这个题的思路挺简单的，大概就是把挡板以一定权值（这个值与挡板和导轨的夹角有关）映射到导轨上，然后取一段区间，使得选的区间被映射的权值最大。我们可以得到一个结论，这个区间肯定要么以某个挡板的左端开始，要么结束于某个挡板的右端，所以只统计O(n)种方案就够了。

这个题就规约成了维护一个数据结构，支持区间加与区间求值，这个用线段树求就行了。[不会线段树建议左转普及组](https://www.luogu.com.cn/problem/P3372)。

因为这个挡板直线很长嘛，所以需要离散化。而这种离散化+线段树的题，用扫描线比较方便。

不过我们还有两个问题。一个是这个导轨是斜着的，需要把他旋转到水平才能比较方便地弄。第二个是遮挡问题，离导轨远的会被离导轨近的挡住，加起来就比较麻烦了。

解决第一个问题要分成两步。

第一步就是使导轨这条斜线过原点，这个我们可以通过把x轴上移截距个单位实现，[不懂一次函数截距是啥的点这里](https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/1653577?fr=aladdin)。具体写法就是把每个挡板的y坐标```-```截距。

第二个是旋转坐标系，这个就需要大家的三角函数知识了（不会也可，不过为了方便还是需要知道基本概念的），[不知道基本概念的点这里](https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/1652457?fr=aladdin)。具体的推导过程都在图片上了。![](https://i.loli.net/2020/03/25/bP6oiLcjTYZeFWz.jpg)

然后开始解决第二个问题，这个问题我们可以用set或者priority_queue维护。我们先考虑一二象限，三四象限同理，那如何判断谁在下面呢，用纵坐标判比较麻烦，我们有更巧妙的办法。

扫描线把一个挡板拆分成插入删除两个步骤，每个步骤加入的时候，记录一下它的横坐标，然后做铅垂线，交点最低的点就是在最下面的点。

其他的都在代码注释里了。

```
 #include<bits/stdc++.h>
using namespace std;
#define maxn 20005
#define lb long double
#define Fol(i, j, n) for(register int i = j ; i >= n ; --i)
#define For(i, j, n) for(register int i = j ; i <= n ; ++i)
int n, T, v, pl, pr, op[maxn];
lb l, nx, ll, lx, rx, ly, ry, dx, dy, rr, dl, dr, ans, dis, res;
lb len[maxn], pos[maxn], val[maxn], x[maxn][2], y[maxn][2]; 
struct node{
	int u;
	//利用铅垂法判断谁靠近x轴 
	friend bool operator < (node a, node b){
		if(a.u == b.u) return 0;
		lb ay = (y[a.u][1] - y[a.u][0]) / (x[a.u][1] - x[a.u][0]) * (nx - x[a.u][0]) + y[a.u][0];
        lb by = (y[b.u][1] - y[b.u][0]) / (x[b.u][1] - x[b.u][0]) * (nx - x[b.u][0]) + y[b.u][0];
		return fabs(ay) < fabs(by);
	}
};
set<node>su, sd; 
inline lb pow(lb x){ return x * x; }
inline bool cmp(int a, int b){ return ((a < 0) ? x[-a][1] : x[a][0]) < ((b < 0) ? x[-b][1] : x[b][0]); }

int main(){
	scanf("%d", &T);
	while(T--){
		scanf("%d", &n);
		For(i, 1, n) scanf("%Lf %Lf %Lf %Lf", &x[i][0], &y[i][0], &x[i][1], &y[i][1]);	
		scanf("%Lf %Lf %Lf %Lf %Lf", &lx, &ly, &rx, &ry, &l), dx = rx - lx, dy = ry - ly;
		For(i, 1, n) len[i] = sqrt(pow(x[i][1] - x[i][0]) + pow(y[i][1] - y[i][0]));
//先平移截距 
		lb dw = lx == rx ? 0 : ly - (dy / dx) * lx;
		For(i, 1, n) y[i][0] -= dw, y[i][1] -= dw;
//
//再旋转坐标系		
		dis = sqrt(pow(dx) + pow(dy)), dx /= dis, dy /= dis;
		For(i, 1, n){
			lb t1, t2, t3, t4;
			t1 = dx * x[i][0] + dy * y[i][0], t2 = dx * x[i][1] + dy * y[i][1];
			t3 = dx * y[i][0] - dy * x[i][0], t4 = dx * y[i][1] - dy * x[i][1];
			x[i][0] = t1, x[i][1] = t2, y[i][0] = t3, y[i][1] = t4;
		}
		For(i, 1, n) if(x[i][0] > x[i][1]) swap(x[i][0], x[i][1]), swap(y[i][0], y[i][1]);
// 
		For(i, 1, n) len[i] /= (x[i][1] - x[i][0]), op[i] = -i;
		For(i, n + 1, n << 1) op[i] = i - n;//负号代表删除 
		sort(op + 1, op + (n << 1) + 1, cmp);
		For(i, 1, n << 1){
			if(op[i] > 0){
				v = op[i], nx = pos[i] = x[v][0];
				(y[v][0] > 0 ? su : sd).insert(node{v});
				if(!su.empty()) val[i] += len[(*su.begin()).u];
				if(!sd.empty()) val[i] += len[(*sd.begin()).u];
			}
			else{
				v = -op[i], nx = pos[i] = x[v][1];
				(y[v][0] > 0 ? su : sd).erase(node{v});
				if(!su.empty()) val[i] += len[(*su.begin()).u];
				if(!sd.empty()) val[i] += len[(*sd.begin()).u];
			}
		}
		Fol(i, n << 1, 1) val[i] = val[i - 1];//最后一个肯定是删除啦，所以没啥用，就不要了，其他的后一个维护前一个的比较方便 
		res = 0, pl = 1, pr = 2, ll = pos[1] - l, rr = pos[1];
//最后two pointer维护一下，答案，其实枚举二分也行，不过据说掉精度，为了安全还是two pointer吧 
		while(pr <= n << 1){
			dl = pos[pl] - ll, dr = pos[pr] - rr;
			if(dl > dr) res += (val[pr] - val[pl]) * dr, pr++, ll += dr, rr += dr;
			else if(dl < dr) res += (val[pr] - val[pl]) * dl, pl++, ll += dl, rr += dl;
			else res += (val[pr] - val[pl]) * dl, pl++, pr++, ll += dl, rr += dl;
			ans = max(ans, res);
		}
		printf("%.15Lf\n", ans), ans = 0, memset(val, 0, sizeof(val));
		//数据千万条，清空第一条。多测不清空，爆零两行泪。 
	}
	return 0;
}
```


---

## 作者：asuldb (赞：3)

[题目](https://www.luogu.com.cn/problem/P4605)

考虑让直线导轨成为$x$轴，钦定$(x_1,y_1)$成为坐标原点，其余点的坐标都减去$(x_1,y_1)$。之后需要使得$(x_2,y_2)$落在$x$轴上，求一下$(x_2,y_2)$与$x$轴的夹角$\alpha$，让所有点都顺时针旋转$\alpha$就好了。

点旋转后的坐标变换是老经典问题了，$(x,y)$顺时针旋转$\alpha$之后就变成了$(x\cos\alpha+y\sin\alpha,-x\sin\alpha+y\cos \alpha)$。

考虑一段挡板在$x$轴的投影是$[l,r]$，这段挡板到$x$轴的夹角为$\beta$；如果激光发射器与投影的交长度为$l$，那么就会在挡板被激光照射到的长度就是$\frac{l}{\cos\beta}$。

这表明了我们一定能将所有挡板都转化成$(l,r,v)$的形式，即这段挡板在$x$轴上的投影为$[l,r]$，极角余弦值的倒数为$v$；这样对答案的影响就是，**$v$乘上投影与激光发射器的交的长度**。

考虑处理出所有的$(l,r,v)$，由于挡板不能被激光穿过，所以只保留距离$x$轴最近的挡板；对于一条线段$(x_1,y_1,x_2,y_2)$，视为在$x_1$处插入它，在$x_2$处将其删除；用$set$来维护当前距离$x$轴最近的线段。由于题目中保证了任意两条线段不会相互接触，于是在两个相邻的端点之间最靠近$x$轴的线段只有一条。直接访问$set$的begin迭代器即可。

显然我们可以在$O(1)$的时间内判断两条线段谁更更靠近$x$轴，于是可以直接给$set$写一个比较函数，这样就非常方便。

最后将问题转化成了找到一个长度为$L$的线段，使得这条线段与投影的带权交最大。

不难发现将线段的端点卡在投影的端点处会取到最优的答案，于是我们将所有投影排好序，正反两边双指针即可。

于是这样就做完了，时间复杂度$O(Tn\log n)$。

然而实际上非常难写，我们求投影的时候要分在$x$轴上方和下方两种情况分别求，分别求完之后还需要合并，双指针的时候也得进行一番讨论。

据说十分卡精度，还需要long double，但是直接用double就莽过去了也是非常刺激。

代码

```cpp
#include<bits/stdc++.h>
#define db double
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
inline int read() {
	char c=getchar();int r=1,x=0;while(c<'0'||c>'9'){if(c=='-')r=-1;c=getchar();};
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-48,c=getchar();return x*r;
}
const db Pi=acos(-1),eps=1e-15;
const int maxn=5e4+5;
struct Pt{db x,y;}S,E;
struct Line{Pt s,t;}L[maxn];
struct wkL{db p,v;int o,rk;}a[maxn<<1];
struct Seg{db l,r,v;}seg[2][maxn<<1],b[maxn<<4];
struct Point{db p,v;int o;}d[maxn<<2];
int n,Len,tot,sz[2],cnt,num;db val[maxn];
inline int dcmp(db A,db B) {return A+eps>B&&A-eps<B;}
inline int cmp(const wkL &A,const wkL &B) {return A.p<B.p;}
inline int ctp(const Point &A,const Point &B) {return A.p<B.p;}
inline db operator*(const Pt &A,const Pt &B) {return A.x*B.y-A.y*B.x;}
inline Pt operator+(const Pt &A,const Pt &B) {return (Pt){A.x+B.x,A.y+B.y};}
inline Pt operator-(const Pt &A,const Pt &B) {return (Pt){A.x-B.x,A.y-B.y};}
inline Pt rotate(const Pt &A,db det) {
	db s=sin(det),c=cos(det);
	return (Pt){A.x*c+A.y*s,A.y*c-A.x*s};
}
struct cop {
	bool operator() (int A,int B) {
		if(L[A].s.x<L[B].s.x) {
			db t=L[B].s.x-L[A].s.x;
			t*=(L[A].t.y-L[A].s.y);
			t/=(L[A].t.x-L[A].s.x);
			t+=L[A].s.y;
			return t<L[B].s.y;
		}
		else {
			db t=L[A].s.x-L[B].s.x;
			t*=(L[B].t.y-L[B].s.y);
			t/=(L[B].t.x-L[B].s.x);
			t+=L[B].s.y;
			return L[A].s.y<t;
		}
	}
};
std::set<int,cop> s;
inline void calc(int op) {
	std::sort(a+1,a+tot+1,cmp);
	for(re int i=1;i<=tot;++i) 	
		if(a[i].o==1) val[a[i].rk]=a[i].v;
	db nw=-1e18;s.clear();
	for(re int i=1;i<=tot;++i) {
		if(!s.empty()&&!dcmp(nw,a[i].p)) {
			seg[op][++sz[op]].l=nw;
			seg[op][sz[op]].r=a[i].p;
			seg[op][sz[op]].v=val[*(s.begin())];
		}
		nw=a[i].p;
		if(a[i].o==-1) s.erase(a[i].rk);
		if(a[i].o==1) s.insert(a[i].rk);
	}
}
inline void Main_solve() {
	n=read();
	for(re int i=1;i<=n;i++) 
		L[i].s.x=read(),L[i].s.y=read(),L[i].t.x=read(),L[i].t.y=read();
	S.x=read(),S.y=read(),E.x=read(),E.y=read(),Len=read();
	for(re int i=1;i<=n;i++)L[i].s=L[i].s-S,L[i].t=L[i].t-S;E=E-S;
	db Det=atan2(E.y,E.x);
	for(re int i=1;i<=n;i++)L[i].s=rotate(L[i].s,Det);
	for(re int i=1;i<=n;i++)L[i].t=rotate(L[i].t,Det);
	for(re int i=1;i<=n;i++) 
		if(L[i].s.x>L[i].t.x) std::swap(L[i].s,L[i].t);
	tot=0;sz[0]=sz[1]=0;
	for(re int i=1;i<=n;i++) 
		if(L[i].s.y>0) {
			db det=atan2((L[i].t-L[i].s).y,(L[i].t-L[i].s).x);
			det=1.0/cos(det);
			a[++tot].p=L[i].s.x;
			a[tot].o=1;
			a[tot].v=det;
			a[tot].rk=i;
			a[++tot].p=L[i].t.x;
			a[tot].o=-1;
			a[tot].rk=i;
		}
	calc(0);tot=0;
	for(re int i=1;i<=n;i++) 
		if(L[i].s.y<0) {
			L[i].s.y=fabs(L[i].s.y);
			L[i].t.y=fabs(L[i].t.y);
			db det=atan2((L[i].t-L[i].s).y,(L[i].t-L[i].s).x);
			det=1.0/cos(det);
			a[++tot].p=L[i].s.x;
			a[tot].o=1;
			a[tot].v=det;
			a[tot].rk=i;
			a[++tot].p=L[i].t.x;
			a[tot].o=-1;
			a[tot].rk=i;
		}  
	cnt=0,num=0;
	calc(1);
	for(re int i=1;i<=sz[0];i++) {
		d[++cnt].p=seg[0][i].l;
		d[cnt].o=1;d[cnt].v=seg[0][i].v;
		d[++cnt].p=seg[0][i].r;
		d[cnt].o=-1;d[cnt].v=-seg[0][i].v;
	}
	for(re int i=1;i<=sz[1];++i) {
		d[++cnt].p=seg[1][i].l;
		d[cnt].o=1;d[cnt].v=seg[1][i].v;
		d[++cnt].p=seg[1][i].r;
		d[cnt].o=-1;d[cnt].v=-seg[1][i].v;
	}
	std::sort(d+1,d+cnt+1,ctp);
	db nw=-1e18,sv=0;int nsz=0;
	for(re int i=1;i<=cnt;++i) {
		if(nsz&&!dcmp(nw,d[i].p)) {
			b[++num].l=nw;
			b[num].r=d[i].p;
			b[num].v=sv;
		}
		nsz+=d[i].o;sv+=d[i].v;nw=d[i].p;
	}
	int lp=1;db tmp=0,ans=0;
	for(re int i=1;i<=num;++i) {
		if(lp>=i) tmp-=(b[i-1].r-b[i-1].l)*b[i-1].v;
		while(lp<=num&&(b[i].l+Len>b[lp].r||dcmp(b[i].l+Len,b[lp].r))) {
			if(lp>=i) tmp+=(b[lp].r-b[lp].l)*b[lp].v;
			++lp;
		}
		if(lp<=num) {
			db t=(b[i].l+Len)-b[lp].l;
			if(t<0)t=0;t*=b[lp].v;
			ans=max(ans,t+tmp);
		}else ans=max(ans,tmp);
	}
	for(re int i=1;i<=num;i++)std::swap(b[i].l,b[i].r),b[i].l=-b[i].l,b[i].r=-b[i].r;
	std::reverse(b+1,b+num+1);
	lp=1,tmp=0;
	for(re int i=1;i<=num;++i) {
		if(lp>=i) tmp-=(b[i-1].r-b[i-1].l)*b[i-1].v;
		while(lp<=num&&(b[i].l+Len>b[lp].r||dcmp(b[i].l+Len,b[lp].r))) {
			if(lp>=i) tmp+=(b[lp].r-b[lp].l)*b[lp].v;
			++lp;
		}
		if(lp<=num) {
			db t=(b[i].l+Len)-b[lp].l;
			if(t<0)t=0;t*=b[lp].v;
			ans=max(ans,t+tmp);
		}else ans=max(ans,tmp);
	}
	printf("%.15lf\n",ans);
		 
}
int main() {
	for(re int T=read();T;--T)Main_solve();
	return 0;
}
```

---

## 作者：jlx77777 (赞：3)

**40分做法**  
将挡板映射到直线上，n块挡板一共2n个端点将直线分成2n+1部分，然后从上到下扫一遍就行了。  
**80分做法**  
旋转坐标系，把直线旋转为x轴，2n个端点2n个事件，按横坐标排序，从左到右扫，用平衡树（出题人现场表示set真好用嘻嘻嘻）维护最靠近直线的挡板的倾斜角的sec值（维护斜率之类也可以）。
我们可以发现最优解的区间一定有一端是卡在端点上的，所以用间隔为L的两个指针，从左到右扫一遍即可。  
**100分做法**    
~~将double换成long double即可~~  
本是用于卡精度的测试点，然而没有一个人被卡精度。
不旋转坐标系，直接在原坐标系下，用斜着的扫描线扫一遍就可以避免精度误差

---


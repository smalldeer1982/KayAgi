# [SDOI2018] 反回文串

## 题目描述

“回文串什么的最讨厌了……”

小 $Q$ 讨厌任何形式的回文串：

- 如果一个字符串从左往右读和从右往左读是一样的，那么小 $Q$ 讨厌它；例如 $aa$ 和 $aba$。

- 对于一个字符串来说，若将某个前缀子串移除并拼接到字符串的尾部，能得到一个小 $Q$ 讨厌的字符串，那么小 $Q$ 也会讨厌原来的这个字符串；例如 $aab$ 和 $baa$。

那么问题来了，如果任意字符串只可以由 $k$ 种已知的字符组成，那么长度为 $n$ 的所有字符串里，有多少字符串是小 $Q$ 讨厌的？

答案可能很大，你只需要给出答案对 $p$ 取模的值。


## 说明/提示

- 对于 $30\%$ 的数据，有 $1 ≤ n ≤ 10^{10}$。

- 对于 $60\%$ 的数据，有 $1 ≤ n ≤ 10^{14}$。

- 对于 $100\%$ 的数据，有
$1 ≤ T ≤ 10, 1 ≤ n ≤ 10^{18}, 1 ≤ k ≤ n, 10^9 ≤ p ≤ 2^{30}$


## 样例 #1

### 输入

```
10
1 1 1000000001
2 2 1000000003
3 2 1000000005
3 3 1000000007
4 2 1000000009
4 3 1000000011
4 4 1000000013
5 5 1000000015
7 7 1000000017
9 9 1000000019```

### 输出

```
1
2
8
21
6
15
28
605
16765
530937
```

## 样例 #2

### 输入

```
10
8821612800 758922381 1073365919
8380532160 166822173 1001828119
9311702400 7367823578 1015387267
6983776800 1646145481 1030885259
6692786100 1953515781 1073365919
7138971840 2649942813 1001828119
6469693230 2585876408 1015387267
8031343320 1646145481 1030885259
9995200351 645412247 1030328983
9302162851 1649517328 1053299347
```

### 输出

```
896784901
911577797
674524325
392648220
646549222
879297585
384496639
889650008
957785169
413147483```

# 题解

## 作者：Soulist (赞：18)


这道题很有意思，需要你进行大量的手玩来推结论

- 结论$1$：一个字符串 A 的不同的轮换的数量为 $|\sigma(A)|$，其中 $\sigma(S)$ 表示 S 的最小循环节。

这个结论比较基础/fad

- 结论$2$：一个回文串的最小循环节 $\sigma(S)$ 必然也是一个回文串。

证明的话可以手玩。

- 结论$3$：一个长度为 $n$ 的字符串可以被一个最小循环节唯一表示，同时这个循环节也会唯一表示一个长度为 $n$ 的字符串。

这个结论也非常显然。

不过我们可以开始转变思路了，我们尝试对 $\sigma$ 进行计数，根据结论 $1$ 一个 $\sigma$ 可以衍生出来的本质不同的字符串的数量为 $|\sigma|$

所以我们猜想答案是：$\sum |\sigma|$

很快你就会意识到不对，我们发现比如字符串 ```abbaabba``` 他在一定的循环之后会变成 ```baabbaab``` 我们统计 $\sigma$ 的时候会将 ```abba``` 与 ```baab``` 都一起算一遍。

我们接着又可以发现这几个结论：

- 结论$4$：如果一个合法的循环节 $\sigma$ 的长度为偶数，那么至少存在另一个 $\sigma$ 与之对应。

~~证明的话手玩~~，大概就是把 $\sigma$ 分解为 $s1+s2$，那么 $s1\ne s2,s1=rev(s2)$，那么一定存在另一个循环节为 $s2+s1$ 可以通过轮换得到一样的结果。
 
- 结论$5$：在结论 $4$ 的基础上，每个长度为偶数的合法最小循环节 $\sigma$ 都有且仅有一个 $\zeta$ 与之对应，即 $4$ 的证明下面补充的例子。

这个结论就需要手玩了，画一个图，然后假设一个位移 $k$ 使得其回文，最后会推导出来 $\sigma$ 是存在循环节的之类的，比较感性...不过直觉上这个结论挺对的。

- 结论$6$：类比结论 $5$，如果一个回文最小循环节 $\sigma$ 为奇数，那么其不存在任意一个与之对应 $\zeta$ 使之回文。

这个结论的手玩方式和 $5$ 类似。

- 结论 $7$：约数个数函数的增长十分缓慢，对于 $n\le 10^{18}$，有 $\max\{d(n)\}=103680$

我们发现结论 $6$ 十分的优美，他意味着如果一个回文循环节的长度为奇数，那么其对于答案的贡献就是 $|\sigma|$

而结论 $5$ 则让我们意识到对于长度为偶数的回文循环节，其总是两两配对的，所以单独一者的贡献可以直接视为 $\frac{|\sigma|}{2}$

结论 $7$ 则告诉我们，复杂度为 $O(d(n))$（$d(x)$ 表示 $x$ 的约数个数）的算法是可以通过这道题的。

现在我们可以开始计数了，令 $f(d)$ 表示最小循环节长度为 $d$ 的循环节数量，那么我们知道答案就是：

$$\sum_{d|n}f(d)\times \frac{d}{1+r(d)}$$

其中 $r(d)$ 表示 "[$d$ 为偶数]"，我们发现 $f(d)$ 不好求，但是我们不妨设 $F(x)$ 为长度为 $x$ 的回文串的数量，那么有：

$$\sum_{d|x}f(d)=F(x)$$

~~可以直接当作用了一次结论$2$，虽然也比较显然~~

我们知道 $F(x)=m^{\lceil\frac{x}{2}\rceil}$，于是我们可以通过莫比乌斯反演得到 $f$

于是有：

$$f(d)=\sum_{x|d}F(x)\times \mu(\frac{d}{x})$$

于是我们知道：

$$Ans=\sum_{d|n} \dfrac{d}{1+r(d)}\sum_{x|d}\mu(\frac{d}{x})F(x)$$

令 $g(d)=\frac{d}{1+r(d)}$，则有：

$$Ans=\sum_{d|n}\sum_{x|d}\mu(\frac{d}{x})F(x)g(d)$$

$$Ans=\sum_{x|n}F(x)\sum_{k|\frac{n}{x}}\mu(k)g(kx)$$

到目前为止，如果我们能够做到 $O(d(n))$ 的枚举约数那么本题已经可以得到部分分了。

我们肯定希望有一种玄幻的操作可以将 $g(kx)$ 分解出来，让后面变成之和 $\frac{n}{x}$ 有关的一个函数。

假设将 $k$ 从 $g(kx)$ 中提取出来变成 $kg(x)$，那么此时 $kg(x)\ne g(kx)$ 当且仅当 $x$ 为奇数，$k$ 为偶数。

由于 $k|\frac{n}{x}$，于是 $\frac{n}{x}$ 为偶数，我们现在来考虑这个式子的取值：

$$\sum_{k|\frac{n}{x}}\mu(k)g(kx)$$

~~通过打表可以发现这个式子的值恒定为 $0$~~

我们理性分析一下，这个式子的前提为 $\frac{n}{x}$ 为偶数，$x$ 为奇数，所以对于答案有贡献的 $\mu(k)$ 都满足 $\mu(k)\ne 0$，我们对于 $\frac{n}{x}$ 进行质因数分解，现在只关注 $\mu(k)\ne 0$ 的 $k$，我们发现每一个不含 $2$ 作为因数的 $k$ 都存在一个 $\mu(2k)$ 与之对应，且其值恰好相反，而且 $g(kx),g(2kx)$ 是相同的，所以这两个值会在一起抵消，所以这一部分对于答案的贡献为 $0$。

由于我们不关注 $0$ 的取值，我们可以忽略这一类，对于剩下的情况，有答案为：

$$\sum_{x|n}F(x)g(x)\sum_{k|\frac{n}{x}}\mu(k)k$$

如果能够 $O(1)$ 的求出后面的式子的值，那么我们就可以得到一个 $O(d(n))$ 的解法了，现在考虑：

$$\sum_{k|n}\mu(k)k$$

的取值，我们仍然只考虑 $\mu(k)\ne 0$ 的数，那么此时我们可以将一个 $k$ 视为 $p_1p_2...p_m$

考虑一个 dp 的思想来统计答案，每次新增一个质因数 $p'$ 进入集合的时候，显然答案有两类，一类是不选入 $p'$ 一类是选入 $p'$，选入 $p
'$ 的同时会使得所有贡献都乘以 $(-1)$，令 $f_i$ 表示之前的答案，则有 $f_i'=(f_i-p'f_i)$，我们把每一项的贡献单独提取出来，则可以得到上式为：

$$\sum_{k|n}\mu(k)k=\prod(1-p_i)$$

我们先通过 Pollard−Rho 将 $n$ 进行质因数分解，然后通过质因数来进行搜索，做到 $O(d(n))$ 枚举所有约数，对于 $x$ 为奇数而 $\frac{n}{x}$ 为偶数的情况忽略，然后沿途统计一下 $\prod(1-p_i)$ 即可。

值得注意的是被统计的 $\prod (1-p_i)$ 是补集的。

复杂度 $O(T\times (d(n)\log n+n^{1/4}\log n))$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define int __int128
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 10000 + 5 ; 
int T, n, m, P, st[N], top, w[N], num, c[N] ; 
int mul( int a, int b, int p ) {
	return ( a % p ) * ( b % p ) % p ;  
}
int fpow( int x, int k, int p ) {
	int ans = 1, base = x % p ; 
	while( k ) {
		if( k & 1 ) ans = mul( ans, base, p ) ;
		base = mul( base, base, p ), k >>= 1 ; 
	} return ans % p ; 
}
bool M_R( int p ) {
	if( p == 2 || p == 3 ) return 1 ; 
	if( p == 1 || ( p % 2 == 0 ) ) return 0 ; 
	re int d = p - 1, s = 0 ; while( !( d & 1 ) ) ++ s, d >>= 1 ; 
	rep( i, 0, 5 ) {
		re int a = rand() % ( p - 3 ) + 2 ; 
		re int x = fpow( a, d, p ), y = 0 ;
		for( register int j = 0; j < s; ++ j ) {
			y = mul( x, x, p ) ; if( y == 1 && ( x != 1 ) && x != ( p - 1 ) ) return 0 ;
			x = y ;
		} if( y != 1 ) return 0 ;
	} return 1 ; 
}
int gcd( int x, int y ) {
	return ( x == 0 ) ? y : gcd( y % x, x ) ;
}
int Rand( int x ) {
	return 1ll * ((rand() << 15 ^ rand()) << 30 ^ (rand() << 15 ^ rand())) % x ; //2
}
int work( int p ) {
	re int k = 2, x = Rand(p - 1) + 1, y = x, d = 1, c = Rand(p) % 999997 ;
	for( re int i = 1; d == 1; ++ i ) {
		x = ( mul( x, x, p ) + c ) % p ;
		d = gcd( (x > y) ? x - y : y - x, p ) ;
		if( i == k ) y = x, k <<= 1 ; 
	} return d ; 
}
void Pollard_Rho(int p) {
	if( p == 1 ) return ; 
	if( M_R(p) ) { st[++ top] = p; return ; }
	int x = p ; while( x == p ) x = work(x) ;
	Pollard_Rho(x), Pollard_Rho(p / x) ;
}
int Ans = 0 ;
void dfs( int x, int f, int d, int p ) {
	if( x == num + 1 ) {
		if( ( (d & 1) ) && ( !( (n / d) & 1 ) ) ) return ;
		int g = ( d & 1 ) ? d : d / 2 ;
		Ans = ( Ans + mul( mul( fpow( m, ( d + 1 ) / 2, p ), g, p ), (f + p) % p, p ) + p ) % p ;
		return ; 
	}
	int fd = 1 ; 
	rep( i, 0, c[x] ) {
		if( i == c[x] ) dfs( x + 1, f, d * fd, p ) ;
		else dfs( x + 1, f * ( 1 - w[x] ), d * fd, p ) ;
		fd = fd * w[x] ; 
	}
}
signed main()
{
	srand(time(NULL)) ; 
	T = gi() ; 
	while( T-- ) {
		n = gi(), m = gi(), P = gi(), top = 0, num = 0, Ans = 0 ;
		memset( c, 0, sizeof(c) ), memset( w, 0, sizeof(w) ), memset( st, 0, sizeof(st) ) ;
		Pollard_Rho(n) ; 
		sort( st + 1, st + top + 1 ) ;
		rep( i, 1, top ) {
			if( st[i] == st[i - 1] ) ++ c[num] ; 
			else w[++ num] = st[i], c[num] = 1 ; 
		}
		dfs( 1, 1, 1, P ) ;
		printf("%lld\n", (long long)((Ans) % P) ) ;
	}
	return 0 ;
}
```

---

## 作者：shadowice1984 (赞：18)

反演神题……

首先你得看出来这道题是一个反演题

如果你这道题卡94了检查一下你的Miller-Rabin有没有在判定大质数的时候返回奇奇怪怪的值……
_______________

## 本题题解

题目的要求是求下列符合条件的字符串个数(长度为n,字符集大小为k)

## 这个串的一个轮换是一个回文串

两个字符串不同当且仅当这个字符串中有一个位置的字符不同

然后此时我们看了一样数据范围$n<=10^{18}$非常魔幻

这已经不是dp可以解决的问题了，所以让我们来考虑一下如何列式子

### 找规律

首先我们想一个非常trival的问题，长度为n字符集大小为k的字符串集里有多少个回文串？显然是

## $k^{\lfloor\frac{n+1}{2}\rfloor}$

但是我们的直觉告诉我们答案显然不是

## $nk^{\lfloor\frac{n+1}{2}\rfloor}$

比如像aaaaaa……这种串的所有轮换都是同一个串，然后显然是不可以算n遍的

那么我们说我们刨掉这种情况不就好咯，然后我们发现有这样的反例

abc abc abc abc abc abc

轮换3次之后陷入了循环还是不能算n遍

那么我们考虑一件事情，一个串到底有多少个互不相同的轮换？

发现刚好等于它的最小循环节长度(这里要求的最小循环节是不允许重叠的，换句话说最小循环节必须是这个串的约数)

那么我们是不是可以枚举每一个回文串的最小循环节长度d，然后每个回文串对答案产生d的贡献呢？

然后我们发现会有这样的反例

abcd abcd abcd abcd

轮换两次之后变成了

cd abcd abcd abcd ab

我们惊讶的发现这个串也是一个回文串，换句话说"abcdabcdabcdabcd"和"cdabcdabcdabcdab"这两个串共同产生了4的贡献，因此每个串平摊下来仅仅产生了2的贡献

进一步思考，如果最小循环节长度d为偶数的话，我们会发现在它的d种不同的轮换字符串当中恰好有两个或者零个回文串，因此我们枚举的回文串最小循环节长度d如果是偶数的话仅仅会产生$d/2$的贡献，因为另一半被和它"配对"的回文串摊掉了

然后让我们来想一下d为奇数的时候会出现什么，万幸的是在它的d种不同的轮换字符串中最多有一个回文串，所以如果d为奇数那么刚好产生d的贡献

那么我们似乎可以用一个分段函数h来描述我们最小循环节长度为d的字符串对答案的贡献

## $h(d)=(dmod2)?d:d/2$

那么我们现在终于可以愉快的枚举循环节长度d了，什么？怎么求最小循环节长度为d的回文串数量?别急，让我们设最小循环节长度为d的回文串数量为$f(d)$

那么我们现在终于可以列出式子来了

## $Ans=\sum_{d|n}h(d)f(d)$

问题来了，怎么求$f(d)$?你不会求我也不会求……

但是万幸的是这里有一个比较显然的恒等式($g(m)$代表长度为m的回文串总数)

## $g(m)=k^{\lfloor\frac{m+1}{2}\rfloor}=\sum_{d|m}f(d)$

也就是说我们枚举了长度为m的所有回文串的最小循环节,然后把每种回文串的数量加到了一起(显然两个串最小循环节长度不同那么这两个串不同，因此最小循环节为d的回文串属于互斥事件，用加法原理进行合并)那么我们就会得到长度为m的所有回文串的数量了

(下面开始反演了，如果还对莫比乌斯反演不是相当熟练的话还先去学习下反演再来看这道题吧)

如果你对狄利克雷卷积那一套相当熟练的话你会立即想到

## $g(m)=\sum_{d|m}f(d)1(m/d)$

其中$1()$是常函数,1(x)=1，其中x是任意值

也就是说

## $g=f×1$

那么莫比乌斯反演公式告诉我们

## $g=f×1 \leftrightarrow f=g×\mu$

换句话说我们可以推出

## $f(m)=\sum_{d|m}g(d)\mu(m/d)$

好了那么我们现在可以计算f函数的值了，那么我们把它代入原来答案的表达式会发生什么……

## $Ans=\sum_{d|n}h(d)\sum_{p|d}g(p)\mu(d/p)$

好了下面是神奇的交换$\Sigma$的环节了！

我们令$d/=p$,则有$d=dp$,因为$d|n$所以$dp|n$所以$d|n/p$

我们接下来就全部用$dp$替换原来式子当中的d,得到了

## $Ans=\sum_{p|n}g(p)\sum_{d|\frac{n}{p}}h(dp)\mu(d)$

那么我们到这一步其实已经不可以反演了

所以让我们来考虑一下h函数的性质，我们尝试着把$h(dp)$中的$d$提出来

换句话说，我们考虑这个式子在什么条件下成立

## $h(dp)=dh(p)$

发现当且仅当d为偶数且p为奇数的时候这个式子不会成立

但是让我考虑下什么时候d为偶数且p为奇数呢？

d必须是$\frac{n}{p}$的约数，然而如果$\frac{n}{p}$是奇数的话d不可能是偶数

那么这个式子唯一不成立的情况就是p为奇数且$\frac{n}{p}$为偶数了

那么我们考虑此时这个式子的值是多少

## $\sum_{d|\frac{n}{p}}h(dp)\mu(d)$

由于p是奇数，所以可以写成

## $p\sum_{d|\frac{n}{p}}h(d)\mu(d)$

那么我们考虑后边式子展开之后的项,$\mu$值为0的项我们不管，考虑$\mu$值为1和-1的项

那么我们对d是奇数的项把它乘2，偶数的的项把它除2

那么显然可以把这些$\mu$值为1和-1的项两两配上对

那么我们发现乘2或者除2的过程中$h(d)$的值并没有变而$\mu(d)$的值刚好取反

因此每个对的和恰好是0

所以我们证明了什么？刚才的式子的和为0，因此这种情况遇到之后直接continue掉就好了

那么剩下的情况我们认为$h(dp)=dh(p)$这个式子都是成立的

那么式子可以化简成

## $Ans=\sum_{p|n}g(p)h(p)\sum_{d|\frac{n}{p}}d\mu(d)$

那么我们记$t(m)=\sum_{d|m}d\mu(d)$

那么我们看一看它等于什么，还是老样子我们考虑这个式子的展开式，$\mu$值为0的我们不用管，考虑1和-1的项

那么我们可以把m质因数分解，于是上边的式子和下边的式子应该是等价的

## $t(m)=\prod_{i=1}^{q}(1-p_{i})$

其中$p_{1}……p_{q}$是m的质因数分解

因为我们把下面的式子展开之后应该每一项是一堆p乘起来，而如果这个项里有奇数个质数的话那么系数就是-1反之就是1，那么刚好和莫比乌斯函数的定义对应起来，而这些质数乘起来的值恰好就是d,由于每个质因子只出现一次因此$\mu$值为0的项不会出现，所以上边和下面的式子是等价的

所以最后我们的式子就变成了

## $Ans=\sum_{p|n}g(p)h(p)t(n/p)$

最后一个问题，如何生成一个数的所有约数?

我们可以把这个数进行质因数分解，那么就可以dfs出所有的约数了

问题来了怎么质因数分解？

___________________

### 前置芝士:Pollard-Rho算法

期望复杂度$O(\sqrt{\sqrt{n}})$的神奇算法

简单来说，我们不停的随机两个数，然后取他们的差，和要分解的数取gcd，如果gcd不是1的话递归分解gcd和n/gcd，直到遇到了质数，此时我们就可以把这个质因数放到set里了

但是其实我们写不出随机函数来，我们的随机函数是用一些奇奇怪怪的式子生成的，比如$x=(x^2+1)modn$这个东西最后一定会陷入死循环，此时如果我们还是没有猜对我们就凉了

那么我们就考虑如何判掉这个环，一个比较古老的方式是Floyd2倍速判断法，这里介绍一个比较机智的判环法，Brent判环法

我们先钦定一个初始的种子x1

然后计算$x_{2}=x_{1},x_{1}=(x_{1}^{2}+1)modn$

然后我们不停的计算$x_{i}$如果i是2的整次幂那么令$x_{2}=x_{1}$

每次返回$x_{2}-x_{1}$作为我们函数的返回值，当返回值是0的时候表明出现了环直接重新选择种子

听起来挺玄学的但是你自己画一个$\rho$型的环你会发现这个东西真的可以把环判出来

然后有人证明了这个东西的复杂度是期望$O(\sqrt{\sqrt{n}})$的，于是我们就可以对这个数做质因数分解了

## 实现

我们dfs出所有的约数值，t函数的值可以在dfs的时候顺便求出，然后我们直接按照推出来的式子枚举约数暴力计算即可，t函数的值用unordered_map存一下就行了，Pollard-Rho的质数判定采用Miller-Rabin随机判定法即可

最后一个小问题，我们可能要做膜数是longlong范围内的乘法，该怎么办呢？

### 强行转成long double手动模拟膜法即可/int_128也可

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<set>
#include<cstdlib>
#include<tr1/unordered_map>
using namespace std::tr1;
using namespace std;const int N=1e5+1e4+10;typedef long long ll;typedef long double ld;
ll n;ll k;ll mod;set <ll> s;int T;ll tims;
inline ll mul(ll a,ll b,ll md){ll tp=a*b-(ll)((ld)a/md*b+1.0e-8)*md;return tp<0?tp+md:tp;}\\转longdouble的乘法
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}//快速幂
namespace MiiR//miiler-rabin
{
    const ll bs[20]={2,3,5,7,11,61,24151};//偷懒少选了几个base
    inline ll po(ll a,ll p,ll mod){ll r=1;for(;p;p>>=1,a=mul(a,a,mod))if(p&1)r=mul(r,a,mod);return r;}
    inline bool tst(ll x,int t)//二次探测
    {for(ll p=x-1;;p>>=1){ll g=po(bs[t],p,x)%x;if(g==x-1)return 0;if(g!=1)return 1;if(p&1)return 0;}}
    inline bool ck(ll x){for(int i=0;i<=6&&bs[i]<x;i++){if(tst(x,i))return false;}return true;}
}
namespace PollR
{
    ll st;
    inline ll mabs(ll x,ll y){return (x>y)?x-y:y-x;}
    inline ll gcd(ll a,ll b){ll c;while(b){c=a%b;a=b;b=c;}return a;}
    inline ll rd(ll x,ll md){return (mul(x,x,md)+st)%md;}
    inline ll bigr(){ll ret=0;for(int i=0;i<=62;i++)ret+=(1LL<<i)*(rand()%2);return ret;}//这里写了个暴力rand，大家不要学我
    inline void solve(ll x)//递归分解，质数直接返回
    {
        if(x==1)return;if(MiiR::ck(x)){s.insert(x);return;}
        while(1)
        {
            ll x1=bigr()%x;st=rand()%x+1;
            ll g=gcd(x,x1);if(g!=1&&g!=x){solve(g);solve(x/g);return;}
            ll x2=x1;x1=rd(x1,x);ll k=0;ll tr=1;
            for(;x1-x2;x1=rd(x1,x),k++)//brent判圈法
            {
                g=gcd(x,mabs(x1,x2));if(g!=1&&g!=x){solve(g);solve(x/g);return;}
                if(k==tr){x2=x1;tr<<=1;}
            }
        }
    }
}
ll ys[N];int hd;
unordered_map <ll,ll> fuc;//存t函数的map
void dfs(ll d,ll f,set <ll>::iterator it)//dfs找质数
{
    if(it==s.end()){ys[++hd]=d;fuc[d]=f;return;}
    set <ll>:: iterator it1=++it;--it;dfs(d,f,it1);
    for(ll mi=*it;;mi*=(*it))//注意别爆longlong
    {dfs(d*mi,f*(mod-*it%mod+1)%mod,it1);if((n/mi)%(*it)!=0)break;}
}
inline void solve()
{
    scanf("%lld%lld%lld",&n,&k,&mod);ll ret=0;k%=mod;//小心爆longlong
    PollR::solve(n);dfs(1,1,s.begin());//分解之后找约数
    for(int i=1;i<=hd;i++)//枚举约数暴力计算即可
    {
        ll d=ys[i];if(d%2==1&&(n/d)%2==0){continue;}
        (ret+=((d%2)?d:d/2LL)%mod*po(k,(d+1)/2)%mod*fuc[n/d]%mod)%=mod;
    }printf("%lld\n",ret);
}
inline void clear(){set <ll> emp;unordered_map <ll,ll> ep;swap(s,emp);swap(fuc,ep);hd=0;tims=0;}//O(1)的clear
int main(){srand(66623366);scanf("%d",&T);for(int z=1;z<=T;z++){solve();clear();}return 0;}//拜拜程序~

```










---

## 作者：Social_Zhao (赞：6)

这是一个不带脑子的做法，复杂度比较寄，但是没啥思维难度。

---

让所有合法串在其回文循环同构处计算。假设我们求出了**最小正周期**为 $i$ 的回文串个数为 $f_i$，那么答案为：

$$
\sum_{i|n} i\times \begin{cases}
f_i & i \bmod 2=1 \\
f_i / 2 & i \bmod 2 = 0
\end{cases}
$$

偶数要除 2 的原因是形如 $ss'ss'\cdots ss'$ 的循环同构 $s'ss's\cdots s's$ 仍然是一个回文串，不应该计算两次。

当模数为奇数的时候 $2$ 有逆元，可以直接算。否则模数为偶数，此时我们有常见套路：

$$
\frac{f_i}{2}\bmod P = \frac{f_i \bmod 2P}{2} \bmod P
$$

$P$ 为奇数的时候不能简单地这样处理（但是可以用类似的方法），读者不妨自行思考原因及具体实现。

---

这个东西很不好算，那么我们首先计算 $g_i$ 表示存在整周期 $i$ 的回文串个数为 $g_i$。显然

$$
g_i = k^{\lceil i/2 \rceil}
$$

接下来考虑已知 $g$，如何计算 $f$。我们知道 $f$ 和 $g$ 有如下关系：

$$
g_n=\sum_{d|n} f_n
$$

此时固然可以使用 Mobius Inversion Formula 进行推导，但我们有更加简单的做法。

如果已知 $f$，那么可以用高维前缀和来计算 $g$。具体地，每一维是一个质因子。这个过程可以用 FMT 解决。第一维枚举质因子 $p$，第二维从小到大枚举因数 $d$。如果 $p|d$，那么执行 $f_d \leftarrow f_d + f_{d/p}$。

现在考虑已知 $g$，反推 $f$。这个过程其实就是 IFMT。而 IFMT 过程就是把 FMT 的过程倒着写一遍（循环反向，加法变减法）。

FMT（快速莫比乌斯变换）的逆按理说应该称为快速莫比乌斯反演，所以其实这个方法本质上还是莫比乌斯反演（

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int get() {
	int x = 0, f = 1; char c = getchar();
	while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
	while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}

const int N = 1e6 + 5;
int n, k, P, inv2;
map<int, int> sum;
unordered_map<int, int> f;
int d[N], cnt, pri[N], tot;

int qpow(int x, int y) {
	int res = 1; x %= P;
	while(y) res = res * ((y & 1)? x : 1) % P, x = x * x % P, y >>= 1;
	return res; 
}

namespace PR {
	const int pri[] = { 0, 2, 3, 5, 6, 11, 13, 17, 19, 23, 29, 31, 37 };
	mt19937 rnd;
	
	int mul(int x, int y, int P) { return (x * y - (int)((long double)x / P * y) * P + P) % P; }
	int f(int x, int c, int P) { return (mul(x, x, P) + c) % P; }
	int gcd(int x, int y) { return y? gcd(y , x % y) : x; }
	
	int qpow(int x, int y, int P) {
		int res = 1;
		while(y) {
			if(y & 1) res = mul(res, x, P);
			x = mul(x, x, P), y >>= 1;
		}
		return res;
	}
	
	int IsPrime(int n) {
		if(n == 2) return 1;
		if(n == 1) return 0; 
		int a = n - 1, b = 0;
		while(!(a & 1)) ++b, a /= 2;
		for(int i = 1; i <= 12; i++) {
			if(pri[i] % n == 0) continue;
			int x = qpow(pri[i], a, n), nxt;
			for(int j = 1; j <= b; j++, x = nxt) {
				nxt = mul(x, x, n);
				if(nxt == 1 && (x != 1 && x != n - 1)) return 0;
			}
			if(x != 1) return 0;
		} 
		return 1;
	}
	
	int PollardRho(int n) {
		int s = 0, t = 0, c = (unsigned long long)(rnd() * rnd()) % (n - 1) + 1, val = 1;
		for(int lim = 1; lim; lim <<= 1, s = t, val = 1) {
			for(int i = 1; i <= lim; i++) {
				t = f(t, c, n), val = mul(val, abs(t - s), n);
				if(i % 114 == 0) {
					int d = gcd(n, val);
					if(d > 1) return d;
				}
			}
			int d = gcd(n, val);
			if(d > 1) return d;
		}
		return n;
	}
}

void GetFac(int n) {
	if(n == 1) return;
	if(PR::IsPrime(n)) return sum[n]++, void();
	int now = n;
	while(now == n) now = PR::PollardRho(n);
	GetFac(now), GetFac(n / now);
}

void dfs(int dep, int now) {
	if(dep == tot + 1) 
		return d[++cnt] = now, f[now] = qpow(k, (now + 1) / 2) % (2 * P), void();
	int pr = pri[dep], ap = sum[pri[dep]];
	for(int i = 0; i <= ap; i++, now = now * pr) 
		dfs(dep + 1, now);
}

void solve() {
	n = get(), k = get(), P = get(), inv2 = (P + 1) / 2;
	
	sum.clear(), tot = 0, cnt = 0, f.clear();
	GetFac(n);
	for(auto v : sum) pri[++tot] = v.first;
	dfs(1, 1), sort(d + 1, d + 1 + cnt);
	
    // 此处为类 IFMT
	for(int i = 1; i <= tot; i++)
		for(int j = cnt; j >= 1; j--)
			if(d[j] % pri[i] == 0) {
				(f[d[j]] -= f[d[j] / pri[i]]) %= (2 * P);
			}

	// 最后计算答案的分类讨论
	int ans = 0;
	if(P % 2 == 0) {
		for(int i = 1; i <= cnt; i++) 
			if(d[i] & 1) ans = (ans + d[i] % P * f[d[i]] % P) % P;
			else ans = (ans + d[i] % P * ((f[d[i]] / 2) % P) % P) % P;
		ans = (ans % P + P) % P;
	}
	else {
		for(int i = 1; i <= cnt; i++) 
			if(d[i] & 1) ans = (ans + d[i] % P * f[d[i]]) % P;
			else ans = (ans + d[i] % P * f[d[i]] % P * inv2 % P) % P;
		ans = (ans % P + P) % P;
	}
	cout << ans << endl;
}

main() {
	int T = get();
	while(T--) solve();
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：3)

**[题意](https://www.luogu.com.cn/problem/P4607)**
- 问所有是回文串及其旋转变换的串的个数。

**分析**
- 首先长度为 $n$ 的回文串个数为 $k^{\lceil n/2\rceil}$，记作 $f(n)$。
- 啥都不考虑得到 $n\cdot k^{\lceil n/2\rceil}$ 的结论，然后你发现只有 $n=1$ 时答案才正确。
- 然后阻挠我们直接算方案数的是一个回文串实际的旋转形成的新串个数是小于 $n$ 的。
- 因此我们考虑回文串的周期，尝试莫比乌斯反演，设 $g(n)$ 为长度为 $n$ 的，最小整周期为 $n$ 的回文串的个数，那么答案可以表示为 $(((f\times \mu)\cdot i_1)\times 1)(n)$，然后你发现只有在 $n$ 是质数的时候算的答案才正确。
- 你发现了 $n=4$ 时的一个重要反例：$\text{abba}$ 和 $\text{baab}$，你认为似乎别的反例都会导致周期，设 $z(n)=n/(1+[n\bmod 2=0])$，答案可以表示为 $(((f\times \mu)\cdot z)\times 1)(n)$，这回没事了。
- 暴力计算 $f\times \mu$ 复杂度会炸，利用高维差分的思想可以勉强不炸，[这篇](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/gao-wei-qian-zhui-hu)有介绍，主要瓶颈是因数分解的复杂度和必不可少的快速幂 $O(\sigma_0(n)\log n)$，[代码](https://www.luogu.com.cn/paste/3tkoyi7k)。

---

## 作者：critnos (赞：2)

非常暴躁做法。

首先打表观察一下每个回文串有多少个不同的循环移位。发现一个形如将某个回文串 $S$ 重复若干次的回文串大概有 $|S|$ 个不同的循环移位。大胆猜测某个回文串的循环移位数量是最小的 $|S|$ 满足该回文串是 $S$ 重复若干次。

很明显我们要计数：长度为 $x$ 的回文串满足这个回文串不能继续拆分的数量 $f_x$。显然 $f_x=k^{\lfloor \frac {x+1} 2\rfloor}-\sum_{y|x,y<x} f_y$。

尝试一下最后的答案是否是 $\sum_{x|n} f_x x$，然后只有 $n$ 是奇数的情形对了。

再打个表发现如果 $|S|$ 是偶数，那么这个回文串恰好存在一个非空循环移位使得这个回文串还是回文串。所以答案是 $\sum_{x|n,x\bmod 2=0} f_x \frac x 2+\sum_{x|n,x\bmod 2=1} f_x x$。

众所周知 $10^{18}$ 内约数个数是 $10^5$ 级别的。那可以直接对 $n$ 的约数 dp。那么要维护集合，支持插入一个数，求某个数的约数的权值和。把 $n$ 用 PR 分解了，然后把质因子折半。$g_{x,y}$ 表示前一半的质因子集合为 $x$ 时，后一半质因子是 $y$ 的子集的数的权值和。这样插入和删除都是 $O(\sqrt{d(n)})$ 或者 $O(\sqrt{d(n)}\log n)$。时间复杂度就是 $O(d(n)^{1.5})$ 或者 $O(d(n)^{1.5}\log n)$。

```cpp
#include<bits/stdc++.h>
#define Yukinoshita namespace
#define Yukino std
using Yukinoshita Yukino;
using ll=long long;
ll read()
{
	ll s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s;
}
/*
考虑：一个至少具有两种循环同构为回文串的串

对于偶回文串 

打表发现他会形如

1 2 3... n n n-1 ... 1 循环

且具有 n*2 个不同的循环同构 

奇回文串就是

1 2 3 .. n n-1 .. 1 循环 然后有 n*2-1 个不同的循环同构 

感觉上这类的贡献比较好算 

那我能否先算 sum 循环同构数量(回文串) 再容斥掉？ 

好像完全不用？

做一个假设：一个回文串被划分为 S 循环若干次，且 S 不可被划分，那么这个串就有 |S| 的贡献 

一个符合审美的想法是：S 一定是回文串

他是对的 

然后一个事实：|S| 是偶数的时候对应两个回文串！！把贡献 /2 即可 
*/
ll n,k,mod;
ll qpow(ll a,ll p)
{
	a%=mod;
	ll mul=1;
	for(;p;p>>=1)
	{
		if(p&1) mul=mul*a%mod;
		a=a*a%mod;
	}
	return mul;
}
ll qpow(ll a,ll p,ll mod)
{
	a%=mod;
	ll mul=1;
	for(;p;p>>=1)
	{
		if(p&1) mul=mul*a%mod;
		a=a*a%mod;
	}
	return mul;
}
struct fac
{
	int cnt[30];
	ll p;
	friend bool operator <(const fac &x,const fac &y)
	{
		return x.p<y.p;
	}
}d[500000];
ll dp[500000];
int pcnt,dcnt;
map<ll,int> pc;
pair<ll,int> rp[30];
//不用这个真的只有 94，不得不贺一个 PR 下来了。 
#define lll __int128
const int up=127;
bool fl;
ll ksm(ll a,ll p,ll mod)
{
	ll mul=1;
	for(;p;p>>=1)
	{
		if(p&1) mul=(lll)mul*a%mod;
		a=(lll)a*a%mod;
	}
	return mul;
}
inline bool test(ll n,ll a,ll d)
{
	if(n==2||n==a) return 1;
	while(!(d&1)) d>>=1;
	ll t=ksm(a,d,n);
	while(d!=n-1&&t!=1&&t!=n-1)
	{
		t=(lll)t*t%n;
		d<<=1;
	}
	return t==n-1||d&1==1;
}
inline bool MR(ll n)
{
	if(n==1||n==2||n==3) return 1;
	if(n==1||n%6!=1&&n%6!=5) return 0;
	if(!test(n,11,n-1)||!test(n,61,n-1))
		return 0;
	return 1;
}
inline ll f(ll x,ll t,ll n)
{
	return ((lll)x*x+t)%n;
}
inline ll fj(ll x)
{
	ll s=1,l=0,r=0,t=rand()%(x-1)+1,qwq;
    int i,j;
	for(i=1;;i<<=1,l=r,s=1)
	{
		for(j=1;j<=i;j++)
		{
			r=f(r,t,x);
			s=(lll)s*abs(l-r)%x;
			if(j%up==0)
			{
				qwq=__gcd(s,x);
				if(qwq>1) return qwq;
			}
		}
		qwq=__gcd(s,x);
		if(qwq>1) return qwq;
	}
}
inline void PR(ll x,int cnt)
{
	if(x<2||fl) return;
	if(MR(x))
	{
		pc[x]+=cnt;
		return; 
	}
	ll qwq=fj(x),sum=0;
	while(x%qwq==0) x/=qwq,sum++;
	PR(qwq,cnt*sum),PR(x,cnt);
} 
int low[30];
void dfs(int d,ll p)
{
	if(d==pcnt+1)
	{
		::d[++dcnt].p=p;
		for(int i=1;i<=pcnt;i++)
			::d[dcnt].cnt[i]=low[i];
		return;
	}
	for(int i=0;i<=rp[d].second;i++)
		low[d]=i,dfs(d+1,p),p*=rp[d].first;
}
inline void getmod(ll &x)
{
	x-=(x>=mod)*mod;
}
bool cmp(pair<ll,int> x,pair<ll,int> y)
{
	return x.second<y.second;
}
int B;
vector<ll> fs[300000];
void dfsadd(int wz,int d,fac &x,int v,int wz2)
{
	if(d==pcnt+1)
	{
		getmod(fs[wz][wz2]+=v);
		return;
	}
	for(int i=x.cnt[d];i<=rp[d].second;i++)
		dfsadd(wz,d+1,x,v,wz2*(rp[d].second+1)+i);
}
void add(fac &x,int v)
{
	int wz=0,i;
	for(i=1;i<=B;i++)
		wz=wz*(rp[i].second+1)+x.cnt[i];
	//cout<<x.p<<':'<<wz<<' '<<B<<' '<<pcnt<<endl;
	dfsadd(wz,B+1,x,v,0);
}
int dfsask(int wz,int d,fac &x,int wz2)
{
	if(d==B+1) return fs[wz2][wz];
	ll s=0;
	for(int i=0;i<=x.cnt[d];i++)
		getmod(s+=dfsask(wz,d+1,x,wz2*(rp[d].second+1)+i));
	return s;
}
int ask(fac &x)
{
	int wz=0,i;
	for(i=B+1;i<=pcnt;i++)
		wz=wz*(rp[i].second+1)+x.cnt[i];
	return dfsask(wz,1,x,0);
}
int main()
{
	int T=read();
	while(T--)
	{
		pc.clear(),dcnt=pcnt=0;
		n=read(),k=read(),mod=read();
		PR(n,1);
		for(auto i:pc)
			rp[++pcnt]=i;
		random_shuffle(rp+1,rp+1+pcnt);
		dfs(1,1);	
		sort(d+1,d+1+dcnt);
		int tp=1,tp2=1;
		for(B=1;B<=pcnt&&tp*tp<=dcnt;B++)
			tp*=rp[B].second+1;
		B--;
		int i;
		tp=1;
		for(i=1;i<=B;i++)
			tp*=rp[i].second+1;
		for(;i<=pcnt;i++)
			tp2*=rp[i].second+1;
		for(i=0;i<=tp;i++)
			fs[i].clear(),fs[i].resize(tp2+5);
		for(i=1;i<=dcnt;i++)
			dp[i]=(qpow(k,(d[i].p+1)/2)-ask(d[i])+mod)%mod,
			add(d[i],dp[i]);
		int ans=0;
		for(i=1;i<=dcnt;i++)
			ans=(ans+(d[i].p%2?d[i].p:d[i].p/2)%mod*dp[i])%mod;
		printf("%d\n",ans);	
	}
}
/*
1
4 2 1000000009
*/
```


---

## 作者：FreeTimeLove (赞：2)

洛谷用时 $\text{1.13s}$，loj 用时 $\text{468ms}$，均为当前最快。

考虑一个回文串对答案的贡献，发现与其**最小循环节**有关。设其最小循环节长为 $S$，若 $S$ 为奇数，则该回文串有 $S$ 种轮换；若 $S$ 为偶数，则该回文串与另一对应回文串**共有** $S$ 种轮换。则最小循环节长为 $S$ 的回文串对答案有 $w(S)=\dfrac S{2^{[2|S]}}$ 的贡献。

设 $f(n)$ 为最小循环节为 $n$ 的回文串个数，$g(n)$ 为最小循环节为 $n$ 的**因数**的个数，由于 $S|n$，可以得到
$$
ans=\sum_{d|n}w(d)f(d)
$$
$$
g(n)=\sum_{d|n}f(n)=k^{\lceil n/2\rceil}
$$
莫比乌斯反演得到
$$
f(n)=\sum_{d|n}g(d)\mu(\dfrac nd)
$$
$$
ans=\sum_{d|n}w(d)\cdot \sum_{p|d}g(p)\mu(\dfrac dp)
$$
$$
=\sum_{p|n}g(p)\cdot  \sum_{d|\frac np}w(d\cdot p)\mu(d)
$$
尝试分离 $w(d\cdot p)$。注意到当且仅当 $2|d \land 2\nmid p$，即 $2|\dfrac np\land 2\nmid p$ 时不满足 $w(d\cdot p)=d\cdot w(p)$。

此时
$$
\sum_{d|\frac np}w(d\cdot p)\mu(d)=p\cdot\sum_{d|\frac np}w(d)\mu(d)
$$
$$
=p\cdot\sum_{d|\frac np\land \mu(d)\ne 0}w(d)\mu(d)
$$
$$
=p\cdot\sum_{d|\frac np\land \mu(d)\ne 0\land 2\nmid d}(w(d)\mu(d)+w(2d)\mu(2d))
$$
$$
=p\cdot\sum_{d|\frac np\land \mu(d)\ne 0\land 2\nmid d}(w(d)\mu(d)+w(d)\cdot(-\mu(d))=p\cdot 0=0
$$
因此不满足 $w(d\cdot p)=d\cdot w(p)$ 的项均为 $0$。所以
$$
ans=\sum_{d|\frac np\land (2|p\lor 2\nmid\frac np)}g(p)w(p)\sum_{d|\frac np}d\cdot \mu(d)
$$
$$
=\sum_{d|\frac np\land (2|p\lor 2\nmid\frac np)}g(p)w(p)\sum_{d|\frac np\land \mu(d)\ne 0}d\cdot \mu(d)
$$
$$
=\sum_{d|\frac np\land (2|p\lor 2\nmid\frac np)}g(p)w(p)\prod_{x\in \text{Prime},x|\frac np}(1-x)
$$
设 $t(n)=\prod_{x\in \text{Prime},x|\frac np}(1-x)$，则 $ans=\sum_{d|\frac np\land (2|p\lor 2\nmid\frac np)}g(p)w(p)t(\dfrac np)$。

我们可以通过 Pollard-Rho 在 $O(n^{1/4})$ 的时间内将 $n$ 质因数分解，dfs 枚举因数及其次数同时计算 $t$，$g(p)$ 可以光速幂预处理，总时间复杂度 $O(\max(d))$。

### code

```cpp
/*FreeTimeLove's code.
Love has a nasty habit of disappearing over night.*/
#include<bits/stdc++.h>
namespace chiptune{
#define ll long long
#define LD long double
#define i7 __int128
#define re return
#define con continue
using namespace std;
inline void ckmin(auto &a,auto b){if(b<a)a=b;}
inline void ckmax(auto &a,auto b){if(a<b)a=b;}
const int N=4e4+5;
inline ll rd(){
	ll ans=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	re f?-ans:ans;
}
mt19937_64 rnd(chrono::system_clock::now().time_since_epoch().count());
ll mod,n,K,ans;
int cnt,tt;
ll a[20],b[20],c[100],mi0[N],mi1[N],mi2[N],mi3[N];
inline ll ksm(i7 x,ll k,ll m){
	i7 ans=1;
	while(k){
		if(k&1)ans=ans*x%m;
		k>>=1,x=x*x%m;
	}re ans;
}
inline ll gcd(ll a,ll b){while(b)a%=b,a^=b^=a^=b;re a;}
bool MR(ll n){
	if(n<3)re n==2;
	ll u=n-1,t=0,s;
	while(!(u&1))u>>=1,++t;
	for(int i=1;i<=10;i++){
		ll v=ksm(rnd()%(n-2)+2,u,n);
		if(v==1)con;
		for(s=0;s<t&&v!=n-1;s++)v=(i7)v*v%n;
		if(s==t)re 0;
	}
	re 1;
}
ll PR(ll n){
	if(!(n&1))re 2;
	while(1){
		ll c=rnd()%(n-1)+1;
		auto f=[=](ll x){re ((i7)x*x+c)%n;};
		ll s=0,t=0,u=1,v;
		do{
			for(int i=0;i<128;i++){
				if((s=f(s))==(t=f(f(t))))break;
				if(!(v=(i7)u*llabs(t-s)%n))break;
				u=v;
			}
			ll d=gcd(u,n);
			if(d>1)re d;
		}while(s!=t);
	}
}
void sol(ll n){
	if(n==1)re;
	if(MR(n)){c[++tt]=n;re;}
	ll x=PR(n);
	sol(x),sol(n/x);
}
void init(ll n){
	mi0[0]=mi1[0]=mi2[0]=mi3[0]=1;
	for(int i=1;i<=32768;i++)mi0[i]=mi0[i-1]*K%mod;
	for(int i=1;i<=32768;i++)mi1[i]=mi1[i-1]*mi0[32768]%mod;
	for(int i=1;i<=32768;i++)mi2[i]=mi2[i-1]*mi1[32768]%mod;
	for(int i=1;i<=32768;i++)mi3[i]=mi3[i-1]*mi2[32768]%mod;
	cnt=tt=ans=0;
	if(MR(n))a[++cnt]=n,b[cnt]=1;
	else{
		sol(n);
		sort(c+1,c+tt+1);
		int la=0;
		for(int i=1;i<=tt;i++)
			if(i==tt||c[i]!=c[i+1])a[++cnt]=c[i],b[cnt]=i-la,la=i;
	}
}
inline ll g(ll n){n=(n+1)>>1;re mi3[n>>45]*mi2[(n>>30)&32767]%mod*mi1[(n>>15)&32767]%mod*mi0[n&32767]%mod;}
void dfs(int st,ll p,ll t){
	if(st>cnt){
		ans+=(i7)g(p)*(p&1?p:p>>1)%mod*t%mod;
		re;
	}
	if(st!=1||a[st]!=2)dfs(st+1,p,(i7)t*(mod+1-a[st]%mod)%mod);
	for(int i=1;i<b[st];i++)p*=a[st],dfs(st+1,p,(i7)t*(mod+1-a[st]%mod)%mod);
	p*=a[st],dfs(st+1,p,t);
}
int main(){
	int T=rd();
	while(T--){
		n=rd(),K=rd(),mod=rd();
		K%=mod;
		init(n);
		dfs(1,1,1);
		printf("%lld\n",ans%mod);
	}
	re 0;
}
/*

*/
}int main(){re chiptune::main();}
```

> $\text{Love has a nasty habit of disappearing over night.}$


---

## 作者：FunnyCreatress (赞：2)

题目是要求长为 $n$ 的回文串有多少种本质不同的循环同构。

不妨先考虑 $n$ 为奇数的情况。枚举最小循环节长度为 $d$，那么一种回文串对应 $d$ 个循环同构。尝试数出最小循环节为 $d$ 的回文串数，设为 $f(d)$。显然，最小循环节为 $d$ 因数的串数为 $k^{\frac{d+1}2}$，即
$$\sum_{t|d}f(t)=k^{\frac{d+1}2}$$
莫比乌斯反演，得
$$f(d)=\sum_{t|d}\mu(\frac dt)k^{\frac{t+1}2}$$
所以答案是
$$\begin{aligned}&\sum_{d|n}d\sum_{t|d}\mu(\frac dt)k^{\frac{t+1}2}\\=&\sum_{t|n}k^{\frac{t+1}2}\sum_{dt|n}dt\mu(d)\\=&\sum_{t|n}k^{\frac{t+1}2}t\sum_{d|\frac nt}d\mu(d)\end{aligned}$$
我们发现这个枚举因数是逃不掉了，而朴素的 $O(\sqrt n)$ 枚举显然会寄，所以我们对 $n$ 做质因数分解后枚举各质因数的指数做到枚举因数。

考虑后面那坨东西，由于 $\mu(n)$ 在存在质因子次数 $>1$ 时为 $0$，所以其实只与 $\dfrac nt$ 的素因子集合有关，发现这个东西其实就是一个高维前缀和，可以一遍 FMT 解决。

那么我们做一次的复杂度就是 $O(n^{\frac14}\log n+d\log n+w2^{w})$，其中 $d$ 是 $n$ 的因子个数，$w$ 是 $n$ 的不同质因子个数。事实上由于 $w2^w<d\log n$ 所以可以忽略。

接下来考虑偶数的情况，乍一看下好像只需要给 $\frac{t+1}2$ 加个取整就可以了，但我们测了下样例发现挂了。原因是把循环节左右两半对调后产生的循环同构集合是相同的，所以 $d$ 为偶数时还要额外除以 $2$，但这造成了一些小问题，就是推的柿子中 $d$ 被换成了 $dt$，我们讨论 $t$ 的奇偶，若为偶数，那么 $2$ 除在 $t$ 上，否则除在 $d$ 上。于是问题解决，复杂度 $O(T(n^{\frac 14}\log n+d\log n))$，由于 $n\le 10^{18}$ 时 $d\le 103680$ 所以足以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int N=1e5+5; 
ll T,n,k,p,pr[N/5],cntp,fact[70],cntf,s1[1<<16],s2[1<<16],f[70],cf,w[70],a[70],ans;ull seed;bool isnpr[N];vector<int> vf[N];
ull rnd(){return seed^=seed<<13,seed^=seed>>43,seed^=seed<<29;}
ll mul(ll x,ll y,ll p){return (__int128)x*y%p;}
ll qpow(ll x,ll y,ll p){
	ll res=1;
	for(;y;x=mul(x,x,p),y>>=1)
		if(y&1)res=mul(res,x,p);
	return res;
}
bool mr(ll p){
	if(p==1)return 0;
	if(p==2||p==3)return 1;
	ll t=p-1,s=0;
	while(t&1^1)s++,t>>=1;
	for(int k=0;k<7;k++){
		ll a=rnd()%(p-2)+1,x=qpow(a,t,p);
		if(x==1||x==p-1)continue;
		for(int i=0;i<s-1;i++){x=mul(x,x,p);if(x==p-1)break;}
		if(x!=p-1)return 0;
	}
	return 1;
}
void PR(ll x){
	if(x<N){for(int i:vf[x])fact[++cntf]=i;return;}
	if(mr(x)){fact[++cntf]=x;return;}
	ll y=1,c=rnd()%(x-3)+2,z=c+1,g,cnt=0,tmp=1,lim=1;
	while(y!=z){
		y=(mul(y,y,x)+c)%x,z=(mul(z,z,x)+c)%x,z=(mul(z,z,x)+c)%x,cnt++,tmp=mul(tmp,abs(y-z),x);
		if(cnt==lim){
			if((g=__gcd(tmp,x))!=1){PR(g),PR(x/g);return;}
			cnt=0,tmp=1;if(lim<128)lim<<=1;
		}
	}
	if((g=__gcd(tmp,x))!=1){PR(g),PR(x/g);return;}
	PR(x);
}
int qpow(ll x,ll y){
	int res=1;x%=p;
	for(;y;x=1ll*x*x%p,y>>=1)
		if(y&1)res=1ll*res*x%p;
	return res;
}
void upd(ll &x,ll y){if((x+=y)>=p)x-=p;}
void dfs(int x,ll t){
	if(x==cf+1){
		int ms=0;
		for(int i=1;i<=cf;i++)if(a[i]!=w[i])ms|=(1<<i-1);
		if(t&1)ans=(ans+1ll*qpow(k,t+1>>1)*(t%p)%p*s2[ms])%p;
		else ans=(ans+1ll*qpow(k,t>>1)*((t>>1)%p)%p*s1[ms])%p;
		return;
	}
	a[x]=0,dfs(x+1,t);
	for(a[x]=1;a[x]<=w[x];a[x]++)dfs(x+1,t*=f[x]);
}
int main(){
	for(int i=2;i<N;i++){
		if(!isnpr[i])pr[++cntp]=i;
		for(int j=1;j<=cntp&&i*pr[j]<N;j++){
			isnpr[i*pr[j]]=1;
			if(i%pr[j]==0)break;
		}
	}
	for(int i=1;i<=cntp;i++)
		for(int j=pr[i];j<N;j+=pr[i]){
			int t=j;
			while(t%pr[i]==0)vf[j].push_back(pr[i]),t/=pr[i];
		}
	seed=time(0);
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld%lld",&n,&k,&p);
		cntf=0,PR(n);
		for(int i=1;i<=cntf;i++)f[i]=fact[i];
		sort(f+1,f+cntf+1),cf=unique(f+1,f+cntf+1)-f-1,fill(w+1,w+cf+1,0);
		for(int i=1;i<=cntf;i++)w[lower_bound(f+1,f+cf+1,fact[i])-f]++;
		for(int i=0;i<(1<<cf);i++){
			ll t=1;
			for(int j=0;j<cf;j++)if(i&(1<<j))t*=-f[j+1];
			s1[i]=(t%p+p)%p,s2[i]=((t%2!=0?t:t/2)%p+p)%p;
		}
		int lim=1<<cf;
		for(int i=1;i<lim;i<<=1)
			for(int j=0;j<lim;j+=i<<1)
				for(int k=0;k<i;k++)upd(s1[i+j+k],s1[j+k]),upd(s2[i+j+k],s2[j+k]);
		ans=0,dfs(1,1);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：AzusaCat (赞：1)

求长度为 $n$，字符集大小为 $k$ 的可以通过轮换变成一个回文串的串的数量，对 $10^9+7$ 取模。$T\leqslant 10$，$k\leqslant n\leqslant 10^{18}$。



我们去考虑每一个回文串的贡献。首先长度为 $n$，字符集大小为 $k$ 的回文串的数量为 $k^{\lceil\frac{n}{2}\rceil}$，但是答案并不是 $nk^{\lceil\frac{n}{2}\rceil}$，因为一个串可能有多个轮换都是回文串，会算重。

我们现在设 $l$ 为回文串 $s$ 的最短循环节长度（这里必须循环完），则 $s(1,l)$ 也是回文串，我们考虑有 $s_1=s_n$，又因为 $s_n=s_l$ 所以 $s_1=s_l$，类似可以得到每一组对应位置均相等。同时我们可以注意到，一个最短循环节长度 $l$ 等于串长，且 $l\mid n$ 的回文串和一个长为 $n$ 的回文串一一对应。

我们考虑每个最短循环节长度等于串长的回文串 $s$ 的贡献，为了方便我们称这样的回文串是好的，它可以被定义为把多个 $s$ 顺序放到一起直到长度为 $n$ 所得到的串，一直向左循环位移直到再变为一个回文串的次数 $x$，我们发现这样每一个是答案的串都恰好被一个好的回文串计算到。

那么我们有断言，$x=\begin{cases}l&2\not\mid l\\\dfrac{l}{2}&2\mid l\end{cases}$。通过手玩不难验证这个结论，也可以简单证明，首先不难发现这么多次后一定是一个回文串；然后假设如果不到这么多次就变成了一个回文串，那么可以通过相等关系得到 $s$ 的前 $l$ 个字符都相等，与 $l$ 是最短循环节长度冲突。

设 $f(m)$ 表示长为 $m$ 的好的回文串数量，$h(m)$ 表示长度为 $m$ 的串的贡献，那么答案就是
$$
\sum_{m\mid n} f(m)h(m)
$$
根据上面的理论，长为 $m$ 的回文串与所有长度是 $m$ 的约数的好的回文串一一对应，所以设 $g(m)$ 表示长为 $m$ 的回文串的数量，则 $g(m)=\sum\limits_{d\mid m}f(d)$，莫比乌斯反演可知，答案等于
$$
\begin{aligned}
&\sum_{m\mid n}h(m)\sum_{d\mid m}g(d)\mu(\frac{m}{d})\\
=&\sum\limits_{d\mid n}g(d)\sum_{i\mid\frac{n}{d}}\mu(i)h(di)
\end{aligned}
$$
接下来的步骤比较神仙，我们发现那个 $h(di)$ 如果能把 $i$ 提出来，那么第二个求和号以后只跟 $\dfrac{n}{d}$ 有关而且看上去比较容易求出来。我们发现大部分时候 $h(di)=ih(d)$，而等式不成立时当且仅当 $i$ 是偶数且 $d$ 是奇数，注意到这种情况下一定有 $\dfrac{n}{d}$ 是偶数，我们考虑所有 $\mu(i)\not=0$ 的情况，发现任意一组奇数 $i$ 和 $2i$，有 $\mu(i)=-\mu(2i)$，$h(di)=h(2di)$，所以说对于 $d$ 是奇数，$\dfrac{n}{d}$ 是偶数的情况，后面求和号是 $0$，所以我们把这种情况跳过，就可以把 $i$ 提出来。于是有
$$
\begin{aligned}
ans=&\sum\limits_{d\mid n}g(d)\sum_{i\mid\frac{n}{d}}\mu(i)h(di)\\
=&\sum_{d\mid n}g(d)h(d)\sum_{i\mid \frac{n}{d}}[2\mid d\or 2\not\mid \frac{n}{d}]i\mu(i)
\end{aligned}
$$
根据某张刻在 DNA 内的图，我们注意到 $\sigma_0(n)$ 最大只有 $103680$，这说明复杂度是可以带一个 $\sigma_0(n)$ 的，那么我们只需要考虑在枚举 $n$ 的约数时顺便算出第二个求和号内部的东西。我们不难发现只有每一个质因子 $p$ 第一次被加入时有贡献，如果其没有被选中，那么贡献为 $1$；如果被选中，$\mu$ 取反 $i$ 乘上 $p$，贡献为 $-p$ 。所以有
$$
\sum_{i\mid m}=i\mu(i)\prod_{p\in\mathbb P,p\mid m}(1-p)
$$
这样我们可以先通过 Pollard-Rho 算法分解 $n$，然后 dfs 枚举约数，单组数据复杂度 $O(\sqrt[4]n+\sigma_0(n)\log n)$。

代码（请原谅我直接粘了上古时期的 pr 板子）：

```cpp
#include<bits/stdc++.h>
#define mul(x,y,p) ((long long)((__int128)x*y%p))
using namespace std;
typedef long long ll;
int const base[]={2,325,9375,28178,450775,9780504,1795265022};
ll pw(ll x,ll y,ll mod)
{
    ll res=1;
    while(y)
    {
        if(y&1)res=mul(res,x,mod);
        x=mul(x,x,mod);
        y>>=1;
    }
    return res;
}
bool mr(ll x)
{
    if(x<=1)return 0;
    if(x==2)return 1;
    if(!(x&1))return 0;
    ll tmp=x-1,k=0;
    while(!(tmp&1))tmp>>=1,k++;
    for(int i=0;i<7;i++)
    {
        if(!(base[i]%x))continue;
        ll t=pw(base[i],tmp,x),nxt;
        for(int _=1;_<=k;_++)
        {
            nxt=mul(t,t,x);
            if(nxt==1&&t!=1&&t!=x-1)return 0;
            t=nxt;
        }
        if(t!=1)return 0;
    }
    return 1;
}
ll f(ll x,ll c,ll p){return (mul(x,x,p)+c)%p;}
ll pr(ll x)
{
    ll s=0,t=0,c=rand();
    c=c%(x-1)+1;
    ll val=1;
    for(int i=1;;i<<=1,s=t,val=1)
    {
        for(int j=1;j<i;++j)
        {
            t=f(t,c,x);
            val=mul(val,abs(t-s),x);
            if(j==127)
            {
                ll d=__gcd(val,x);
                if(d>1)return d;
            }
        }
        ll d=__gcd(val,x);
        if(d>1)return d;
    }
    return x;
}
void Pollard_Rho(ll x,vector<ll>&v)
{
    if(x==1)return;
    if(mr(x)){v.push_back(x);return;}
    while(1)
    {
        ll t=pr(x);
        if(t!=x)
        {
            Pollard_Rho(x/t,v),Pollard_Rho(t,v);
            return;
        }
    }
}
ll n,k,mod,ans;
vector<pair<ll,int>>v2;
ll get(ll x)
{
    return pw(k,(x+1)>>1,mod)*((x&1)?x%mod:(x>>1)%mod)%mod;
}
void dfs(int x,ll nowa,ll nowb)
{
    if(x==v2.size())
    {
        if((nowa&1)||(!((n/nowa)&1)))ans=(ans+1ll*get(n/nowa)*nowb)%mod;
        return;
    }
    for(int i=0;i<=v2[x].second;i++,nowa*=v2[x].first)
        if(!i)dfs(x+1,nowa,nowb);
        else dfs(x+1,nowa,nowb%mod*(1-v2[x].first%mod+mod)%mod);
}
int main()
{
    int _;
    scanf("%d",&_);
    while(_--)
    {
        vector<ll>v;
        scanf("%lld%lld%lld",&n,&k,&mod);
        Pollard_Rho(n,v);
        sort(v.begin(),v.end());
        v2.clear();ans=0;
        for(int i=0;i<v.size();i++)
            if((!i)||v[i]!=v[i-1])v2.push_back({v[i],1});
            else v2[v2.size()-1].second++;
        dfs(0,1,1);
        printf("%lld\n",ans);
    }
    return 0;
}
```



---


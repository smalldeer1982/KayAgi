# [SDOI2018] 旧试题

## 题目背景

 - Input file: divsum.in
 - Output file: divsum.out
 - Time limit: 5 seconds
 - Memory limit: 512 megabytes
 
 （注：此处文件输入输出为比赛时要求，在洛谷提交时采用标准输入输出即可。）

## 题目描述

时光匆匆，转眼间又是一年省选季……

这是小 $Q$ 同学第二次参加省队选拔赛。今年，小 $Q$ 痛定思痛，不再冒险偷取试题，而是通过练习旧试题提升个人实力。可是旧试题太多了，小 $Q$ 没日没夜地做题，却看不到前方的光明在哪里。

一天，因做题过度而疲惫入睡的小 $Q$ 梦到自己在考场上遇到了一道好像做过的题目，却怎么也想不起曾经自己是怎么解决它的，直到醒来还心有余悸。

小 $Q$ 眉头一皱，感觉事情不妙，于是他找到了你，希望你能教他解决这道题目。小 $Q$ 依稀记得题目要计算如下表达式的值。

$$
(\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{k=1}^{C}d(ijk))\bmod (10^9+7)
$$

其中 $d(ijk)$ 表示 $i × j × k$ 的约数个数。

## 说明/提示

对于 $30$ 分的数据，$1 ≤ A, B, C ≤ 5000$。

对于 $100$ 分的数据，$1 ≤ T ≤ 10, 1 ≤ A, B, C ≤ 10^5, 1 ≤ \sum{\max(A, B, C)} ≤ 2 \times 10^5$。

## 样例 #1

### 输入

```
5
10 10 10
100 100 100
1000 1000 1000
10000 10000 10000
100000 100000 100000```

### 输出

```
11536
51103588
165949340
19234764
176764584```

# 题解

## 作者：shadowice1984 (赞：72)

神奇反演题……

考验人类智慧的卡常数……

同样复杂度的算法一个跑30s一个跑2s……

然后相信你的信仰，用力卡常数吧

____________________
## 本题题解

### 前置芝士:莫比乌斯反演

请确保你熟练掌握了交换Σ那一套本题解不再讲反演的基础了

_____________

题目要求

## $\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{k=1}^{C}\sigma_{0}(ijk)$

其中$\sigma_{0}(n)=\sum_{d|n}1$

然后这是一道反演除数函数$\sigma$的题，那么这里其实对于除数函数里边的乘积是有一个套路的，枚举来自于各个因子的互质约数对，然后直接计算

换句话说，对于在函数里边的ijk乘积来讲，我们考虑这个ijk的约数的构成，显然是有来自i的，j的，k的部分，那么我们直接枚举约数三元组求lcm显然是不行的，因为会重复一大堆，但是我们观察重复的部分每一个lcm相同的三元组集当中总是有一个三个约数两两互质的部分，因此可以只枚举两两互质的约数三元组……

说了这么多，只是为了说明刚才的式子可以被重写为下面的表达式

### $\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{k=1}^{C}\sum_{d|i}\sum_{t|j}\sum_{p|k}\epsilon((d,t))\epsilon((t,p))\epsilon((d,p))$

中$\epsilon(x)$是元函数，当且仅当$x=1\epsilon(x)=1$，其他情况为0，$(i,j)$是$gcd(i,j)$的简记形式

下面是喜闻乐见的交换Σ环节！

先把这个式子重写成这样:

### $\sum_{i=1}^{A}\sum_{d|i}\sum_{j=1}^{B}\sum_{t|j}\sum_{k=1}^{C}\sum_{p|k}\epsilon((d,t))\epsilon((t,p))\epsilon((d,p))$

然后又是经典的前边是$1~n$顺次枚举后边是$d|i$约数枚举的形式，我们令$i/=d$则$i=di$，交换求和号，得到

## $\sum_{d=1}^{A}\sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{j=1}^{B}\sum_{t|j}\sum_{k=1}^{C}\sum_{p|k}\epsilon((d,t))\epsilon((t,p))\epsilon((d,p))$

同理我们也可以用相同的手法处理j与t,k与p，得到

## $\sum_{d=1}^{A}\sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{t=1}^{B}\sum_{j=1}^{\lfloor\frac{B}{t}\rfloor}\sum_{p=1}^{C}\sum_{k=1}^{\lfloor\frac{C}{p}\rfloor}\epsilon((d,t))\epsilon((t,p))\epsilon((d,p))$

简单整理下得到

## $\sum_{d=1}^{A}\sum_{t=1}^{B}\sum_{p=1}^{C}\lfloor\frac{A}{d}\rfloor\lfloor\frac{B}{t}\rfloor\lfloor\frac{C}{p}\rfloor\epsilon((d,t))\epsilon((t,p))\epsilon((d,p))$

然后我们运用莫比乌斯反演4个推论中的一个，使用$\mu$来反演$\epsilon$得到

### $\sum_{d=1}^{A}\sum_{t=1}^{B}\sum_{p=1}^{C}\lfloor\frac{A}{d}\rfloor\lfloor\frac{B}{t}\rfloor\lfloor\frac{C}{p}\rfloor\sum_{u|t\&u|d}\mu(u)\sum_{v|t\&v|p}\mu(v)\sum_{w|d\&w|p}\mu(w)$

好了又是大家喜闻乐见的交换求和号的环节~

然后这一步交换求和号和其他的交换求和号不同的是，我们必须同时交换3对求和号，此时原来常用的令某一个变量做一个变换的手法已经失效了

此时交换求和号的准则就是，保证每一个单独的变量被枚举了相同的次数

观察限制条件，发现$u|d\&w|d$,$u|t\&v|t$,$v|p\&w|p$

然后直接按照这个变量的限制条件交换求和号会得到

## $\sum_{u=1}^{min(A,B)}\sum_{v=1}^{min(B,C)}\sum_{w=1}^{min(A,C)}\mu(u)\mu(v)\mu(w)\sum_{u|d\&w|d}\lfloor\frac{A}{d}\rfloor\sum_{u|t\&v|t}\lfloor\frac{B}{t}\rfloor\sum_{v|p\&w|p}\lfloor\frac{C}{p}\rfloor$

由于$u|d\&w|d$其实就是$lcm(u,w)|d$，所以重新写一下表达式就是

## $\sum_{u=1}^{min(A,B)}\sum_{v=1}^{min(B,C)}\sum_{w=1}^{min(A,C)}\mu(u)\mu(v)\mu(w)\sum_{lcm(u,w)|d}\lfloor\frac{A}{d}\rfloor\sum_{lcm(u,v)|t}\lfloor\frac{B}{t}\rfloor\sum_{lcm(v,w)|p}\lfloor\frac{C}{p}\rfloor$

那么函数$f(n,x)=\sum_{n|d}\lfloor\frac{x}{d}\rfloor$其实是可以$O(nlogn)$的枚举约数对于某一个参数x处理出来的，因此刚才的式子可以写成

## $\sum_{u=1}^{min(A,B)}\sum_{v=1}^{min(B,C)}\sum_{w=1}^{min(A,C)}\mu(u)\mu(v)\mu(w)f(lcm(u,w),A)f(lcm(u,v),B)f(lcm(v,w),C)$

到此为止反演的工作已经做完了，下面请让我们暂时忘记我们会分析算法复杂度这个事实，因为接下来你会觉得这个算法的算法复杂度十分魔幻……

### 暴力1

我会$O(n^3)$枚举u,v,w有序三元组！

恭喜你白反演了……

### 暴力2

我们考虑给刚才的暴力剪一剪枝，我们发现一个非常有趣的事实，就是如果n>x那么$f(n,x)=0$那么我们可以根据这个性质建出一张图来,在这张图中当中两个点$u,v$有边当且仅当$\mu(u)!=0,\mu(v)!=0,lcm(u,v)<max(A,B,C)$,然后连一条边权为lcm的边

这样的话我们会发现一个惊人的事实，暴力1中所枚举的三元组**可能**有效当且仅当这个三元组在这张图当中构成了一个三元环……于是我们开始测试这个剪枝的效率

但是首先我们该如何$O(m)$而不是$O(n^3)$的建图呢?

答案是枚举边权lcm，我们一次性连出边权为i的所有边，那么首先我们可以$O(nloglogn)$的筛出每一个数的互异质因子

下面我们从1到max(A,B,C)枚举边权i，首先因为这个边权是两个$\mu$值不为0
的数的lcm，因此$\mu(i)!=0$，下面我们直接$2^k$的枚举这个i的质因数分解集合的一个子集，由这个子集我们可以得到其中的一个点的编号u，之后我们要确定另外一个点v但是我们发现v不是非常的好枚举了，因此我们可以枚$gcd(u,v)$显然这个gcd一定是u对应的集合的子集，因此我们再次枚举u的子集
确定出gcd，那么对应的v就是$i×gcd/u$了之后我们就在u和v间连一条边

好了听起来刚才的算法复杂度相当不靠谱，如果记$w(d)$为d的互异质因子个数的话，我们的算法复杂度就是$O(\sum3^{w(d)})$或者$O(m)$的，然后我们尝试着用这个程序跑了一遍$A=B=C=10^5$并且记录一下我们建了多少边，结果可能有些令人吃惊，边数是


# $\text{760，741}$

这意味着这张图实际上相当稀疏……，因此我们可以考虑枚举这张图的三元环了

那么这里我们采用暴力进行枚举，暴力的遍历每个的出边，遍历另一个端点的出边，采用哈希表判断第3个点是否和第一个点有连边

显然这个算法的复杂度是不对的，随随便便就卡成$O(nm)$了，然后我们考虑给这个算法加个小剪枝，将边从无向边改为有向边，方向为度数大的点指向度数小的点，令人惊讶的是，算法复杂度骤减至$O(m\sqrt{m})$

下面给出神奇的证明

我们称度数超过$\sqrt{m}$的点为大度点，否则就是小度点，然后我们发现两边端点都是大度点的边不超过$O(\sqrt{m})$条，因此这部分复杂度为$O(m\sqrt{m})$对于其余的边每条边贡献的复杂度都不超过$\sqrt{m}$所以总复杂度为$O(m\sqrt{m})$

那么我们信心满满的写了这个算法复杂度为$O(m\sqrt{m})$的暴力交上去一看T成40分，然后我们觉得没啥大不了的，毕竟是暴力嘛

_________________________

## 正解

于是你去翻了这道题的题解，题解告诉你恭喜你刚才的暴力就是正解，只是你的三元环枚举可能有点不优美于是就华丽的T飞了

你又去刚才的程序跑了一遍$10^5$的点，大概需要12s……

可是我们一个点最多跑2.5s……

于是我们开始了挑战人类智慧的卡常数之旅……

首先我们发现事实上哈希表是不必要的，我们可以直接手动计算两个点之间的lcm从而判断两个点之间是否有连边，于是你信心满满的加上了这个优化，发现没什么卵用的快了2s

接下来我们发现枚举三元组其实是非常消耗计算资源的，于是你去掉了原来的图中所有的自环，拉出来单独枚举，然后你发现这个优化的非常给力，你的程序又跑快了1s

然后我们发现我们事实上是枚举了所有的有序3元组，于是你决定不在遍历到一条边的时候临时决定这个边的方向，而是一开始就把这个边的方向确定好

但是这样会有一个非常诡异的问题就是我们的枚举现在只能枚举无序三元组了……
因此我们求一个3元组的贡献必须计算6种不同的贡献方式，但是这个优化的效果还是有的，你的程序跑到了5s

于是我们信心满满的修改了一些奥妙重重的运算方式，从而减少了一些取膜和加法运算，很好你的程序(并无卵用的)跑到了4.2s

你对着这份代码又卡了半天常数，发现并无卵用，正当你感叹到底啥才是优美，为什么这么卡常数，按下$Ctrl+A$准备重构代码的时候，你突然看到了你的遍历出边的代码，那是再平常不过的一段代码，大家常用的

```C
for(int i=alist[u];i;i=nxt[i]){}
```
你眉头一皱发现事情并不对劲，因为这份代码在遍历出边的时候访问的内存并不连续而且跨度还不是一般的大……，这意味着你的程序将会发生$O(m\sqrt{m})$次cache miss，这部分的常数就要占去2s……

于是你快速的把邻接链表换成大家常用的vector，这样你在遍历一个点的出边的时候将会快速访问一段连续的内存，cache miss大大减少，现在你的程序可以在2.2s内完成任务了~

当然代价就是你的代码基本不能看了，所以代码仅供参考

上代码~

```C
#pragma GCC optimize(3)
#include<cstdio>
#include<algorithm>
#include<ctime> 
#include<vector>
using namespace std;const int N=1e5+10;typedef long long ll;const ll mod=1e9+7;
const int E=1e6+10;const int U=1e5;int zhi[N];bool book[N];int miu[N];int hd;int T;int d[N];
int a;int b;int c;int l1;int l2;int l3;int lim;int fj[N][15];int tp[N];int st;int edt;
ll ret=0;int fa[N];int fc[N];int fb[N];struct data{int v;int val;};vector <data> ed[N];
inline int gcd(int a,int b){int c;while(b){c=a%b;a=b;b=c;}return a;}
int eu[E];int ev[E];int et[E];int fr;
inline void solve()
{
    scanf("%d%d%d",&a,&b,&c);lim=max(max(a,b),c);st=clock();
    if(a>b)swap(a,b);if(a>c)swap(a,c);if(b>c)swap(b,c);
    for(int i=1;i<=a;i++)for(int j=1;j*i<=a;j++)(fa[i]+=a/(i*j))%=mod;
    for(int i=1;i<=b;i++)for(int j=1;j*i<=b;j++)(fb[i]+=b/(i*j))%=mod;
    for(int i=1;i<=c;i++)for(int j=1;j*i<=c;j++)(fc[i]+=c/(i*j))%=mod;
    for(int i=1;i<=lim;i++)//建图
    {
        if(miu[i]==0)continue;
        for(int j=0;j<=(1<<tp[i])-1;j++)
        {
            int ret=1;for(int k=0,p=j;p;p>>=1,k++)if(p&1)ret*=fj[i][k];
            for(int k=j;;k=(k-1)&j)
            {
                int g=1;for(int t=0,p=k;p;p>>=1,t++)if(p&1)g*=fj[i][t];
                int v=(ll)i*g/ret;d[ret]++;d[v]++;
                if(ret<v){eu[++fr]=ret;ev[fr]=v;et[fr]=i;}if(k==0)break;//去掉重边
            }
        }
    }
    for(int i=1;i<=fr;i++){if(d[eu[i]]<d[ev[i]])swap(eu[i],ev[i]);ed[eu[i]].push_back((data){ev[i],et[i]});}//变为有向边
    vector <data> ::iterator it1,it2;
    for(int u=1;u<=lim;u++)//vector存边
        for(it1=ed[u].begin();it1!=ed[u].end();++it1)
            for(it2=ed[it1->v].begin();it2!=ed[it1->v].end();++it2)
            {
                int v3;if((v3=(ll)it2->v*u/gcd(it2->v,u))>lim)continue;
                int v1=it1->val;int v2=it2->val;
                if(miu[u]*miu[it1->v]*miu[it2->v]==1)
                {
                    (ret+=((ll)fb[v2]*fc[v3]+(ll)fb[v3]*fc[v2])*fa[v1]+
                          ((ll)fb[v1]*fc[v3]+(ll)fb[v3]*fc[v1])*fa[v2]+
                          ((ll)fb[v2]*fc[v1]+(ll)fb[v1]*fc[v2])*fa[v3])%=mod;//处理三元环贡献，基本不能看了
                }
                else 
                {
                    (ret-=((ll)fb[v2]*fc[v3]+(ll)fb[v3]*fc[v2])*fa[v1]+
                          ((ll)fb[v1]*fc[v3]+(ll)fb[v3]*fc[v1])*fa[v2]+
                          ((ll)fb[v2]*fc[v1]+(ll)fb[v1]*fc[v2])*fa[v3])%=mod;
                    ret>0?ret:ret+mod;
                }
            }	
    for(int i=1;i<=fr;i++)//有一个重复点的三元环
    {
        if(miu[eu[i]]==1)
            (ret+=(ll)fa[et[i]]*fb[et[i]]%mod*fc[ev[i]]+(ll)fa[et[i]]*fb[ev[i]]%mod*fc[et[i]]+(ll)fa[ev[i]]*fb[et[i]]%mod*fc[et[i]])%=mod;
        else 
            (ret-=(ll)fa[et[i]]*fb[et[i]]%mod*fc[ev[i]]+(ll)fa[et[i]]*fb[ev[i]]%mod*fc[et[i]]+(ll)fa[ev[i]]*fb[et[i]]%mod*fc[et[i]])%=mod;
        ret=ret>0?ret:ret+mod;
        if(miu[ev[i]]==1)
            (ret+=(ll)fa[et[i]]*fb[et[i]]%mod*fc[eu[i]]+(ll)fa[et[i]]*fb[eu[i]]%mod*fc[et[i]]+(ll)fa[eu[i]]*fb[et[i]]%mod*fc[et[i]])%=mod;
        else 
            (ret-=(ll)fa[et[i]]*fb[et[i]]%mod*fc[eu[i]]+(ll)fa[et[i]]*fb[eu[i]]%mod*fc[et[i]]+(ll)fa[eu[i]]*fb[et[i]]%mod*fc[et[i]])%=mod;
        ret=ret>0?ret:ret+mod;
    }
    for(int i=1;i<=min(min(a,b),c);i++)//三个重复点的三元环
    {
        if(miu[i]==1)(ret+=(ll)fa[i]*fb[i]%mod*fc[i])%=mod;
        else if(miu[i]==-1)(ret-=(ll)fa[i]*fb[i]%mod*fc[i])%=mod;ret=ret>0?ret:ret+mod;
    }printf("%lld\n",ret);
}
inline void clear()
{
    for(int i=1;i<=a;i++)fa[i]=0;
    for(int i=1;i<=b;i++)fb[i]=0;
    for(int i=1;i<=c;i++)fc[i]=0;
    for(int i=1;i<=lim;i++){vector <data> emp;swap(emp,ed[i]);}
    ret=0;fr=0;
}
int main()
{
    miu[1]=1;for(int i=2;i<=U;i++)//线性筛莫比乌斯函数
    {
        if(book[i]==false){zhi[++hd]=i;miu[i]=-1;}
        for(int j=1;j<=hd&&zhi[j]*i<=U;j++)
        {book[i*zhi[j]]=true;if(i%zhi[j]==0){break;}miu[i*zhi[j]]=miu[i]*-1;}
    }
    for(int i=1;i<=hd;i++)//筛质因数分解
        for(int j=1;j*zhi[i]<=U;j++)
            {int nw=j*zhi[i];fj[nw][tp[nw]]=zhi[i];++tp[nw];}
    scanf("%d",&T);for(int z=1;z<=T;z++){solve();clear();}return 0;//拜拜程序~
}
```











---

## 作者：Soulist (赞：43)

约定：

$(i,j)$表示 $[\gcd(i,j)=1]$

首先有：

$$d(ijk)=\sum_{u|i}\sum_{v|j}\sum_{w|k}(u,v)(v,w)(w,u)$$

于是题目所求即：

$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{u|i}\sum_{v|j}\sum_{w|k}(u,v)(v,w)(w,u)$$

然后我们肯定要先枚举因数，就有：

$$\sum_{u=1}^A\Big\lfloor\dfrac{A}{u}\Big\rfloor\sum_{v=1}^B\Big\lfloor\dfrac{B}{v}\Big\rfloor\sum_{w=1}^C\Big\lfloor\dfrac{C}{w}\Big\rfloor(u,v)(v,w)(w,u)$$

这个时候再反演一波，得到：

$$\sum_{u=1}^A\Big\lfloor\dfrac{A}{u}\Big\rfloor\sum_{v=1}^B\Big\lfloor\dfrac{B}{v}\Big\rfloor\sum_{w=1}^C\Big\lfloor\dfrac{C}{w}\Big\rfloor\sum_{d|gcd(u,v)}\mu(d)\sum_{k|gcd(v,w)}\mu(k)\sum_{h|gcd(w,u)}\mu(h)$$

我们肯定要换个枚举顺序

于是有：

$$\sum_{d=1}^{min(A,B)}\mu(d)\sum_{k=1}^{min(B,C)}\mu(k)\sum_{h=1}^{min(C,A)}\mu(h)\sum_{u|d\&u|h}^{A}\Big\lfloor\dfrac{A}{u}\Big\rfloor\sum_{v|d\&v|k}^{B}\Big\lfloor\dfrac{B}{v}\Big\rfloor\sum_{w|k\&w|h}^{C}\Big\lfloor\dfrac{C}{w}\Big\rfloor$$

那个同时整除两个太丑了，我们换成$u|lcm(d,h)$算了

接着有：


$$\sum_{d=1}^{min(A,B)}\mu(d)\sum_{k=1}^{min(B,C)}\mu(k)\sum_{h=1}^{min(C,A)}\mu(h)\sum_{u|lcm(d,h)}^{A}\Big\lfloor\dfrac{A}{u}\Big\rfloor\sum_{v|lcm(d,k)}^{B}\Big\lfloor\dfrac{B}{v}\Big\rfloor\sum_{w|lcm(k,h)}^{C}\Big\lfloor\dfrac{C}{w}\Big\rfloor$$

我们发现后面那一大坨貌似都之和两个量有关

$A,lcm(d,h)$这类变量

我们把其中核心的式子再改写试试：

$$\sum_{u|\textrm{lcm}(d,h)}^A\Big\lfloor\dfrac{A}{u}\Big\rfloor$$

$$=\sum_{u=1}^{\frac{A}{\textrm{lcm}(d,h)}}\Big\lfloor \dfrac{A}{u\times \textrm{lcm}(d,h)}\Big\rfloor$$

我们考虑记$f(n,x)$表示：

$$\sum_{i=1}^{\frac{n}{x}}\Big\lfloor\dfrac{n}{i\times x}\Big\rfloor$$

注意到一个引理：

$$\Big\lfloor\dfrac{\lfloor\frac{n}{x}\rfloor}{i}\Big\rfloor=\Big\lfloor\dfrac{n}{ix}\Big\rfloor$$

于是好像有：

$$\sum_{i=1}^{\frac{n}{x}}\Big\lfloor\dfrac{n}{i\times x}\Big\rfloor=\sum_{i=1}^{\frac{n}{x}}\Big\lfloor\dfrac{\lfloor\frac{n}{x}\rfloor}{i}\Big\rfloor$$

也就是：

$$\sum_{i=1}^x\Big\lfloor\dfrac{x}{i}\Big\rfloor$$

所以我们记$f(x)=\sum_{i=1}^x \Big\lfloor\dfrac{x}{i}\Big\rfloor$

就有原题所求即：

$$\sum_{d=1}^{\min(A,B)}\mu(d)\sum_{k=1}^{\min(B,C)}\mu(k)\sum_{h=1}^{\min(C,A)}\mu(h)\cdot f(\dfrac{A}{\textrm{lcm}(d,h)})f(\dfrac{B}{\textrm{lcm}(d,k)})f(\dfrac{C}{\textrm{lcm}(h,k)})$$

好像 $f(x)$ 可以单次 $\sqrt x$ 的求出来

我们考虑更快速的推好了

注意到对于某一个数 $i\le x$，其对于 $f(x)$ 会产生的贡献为 $\dfrac{x}{i}$ 即 $1\sim x$ 内有多少个数为其倍数

所以 $f$ 的实际意义即 $1\sim x$ 内的约数和

好了这样你就可以 $\mathcal O(n\log n)/\mathcal O(n)$ 把这些值推出来了

当然尽管反演了这么多你的复杂度还是 $\mathcal O(n^3\log n)$ 的 qwq

我们发现我们要求的实际上是有序对 $(d,k,h)$ 对答案造成的贡献

于是可以考虑转化问题的模型，建出一张图来

考虑给两个点 $(u,v)$ 之间连一条边

这是一条无向边，这条边的边权为 $\textrm{lcm}(u,v)$，我们记边 $u,v$ 的边权为 $w_{u,v}$

于是好像对于一个有序对 $(d,k,h)$，若其两两不相同，则其可以通过这张图上的三元环来表示

对于一个三元环 $(d,k,h)$ 其对答案造成贡献当且仅当 $d\le \min(A,B),k\le \min(B,C),h\le \min(C,A)$

那么它会对答案造成 $\mu(d)\mu(k)\mu(h)\cdot f(\dfrac{A}{w_{d,h}})f(\dfrac{B}{w_{d,k}})f(\dfrac{C}{w_{h,k}})$

于是我们好像就可以在这张图上做三元环计数然后统计答案了 qwq

但好像这样还是很暴力

我们尝试给这张图剪一下枝

发现大量的三元环对答案造成的贡献都是 $0$

于是我们可以把 $\mu(x)=0$ 或者 $\textrm{lcm}(u,v)>\max(A,B,C)$ 的点都删去

据 shadowice1984 聚聚说的这样剪之后原图上的边会很少

当然，暴力建边的复杂度是 $\mathcal O(n^2)$ 的 ———— $\rm Step(1)$

我们注意到这个定义下建出的边只能统计两两不相等的三元组对答案造成的贡献

我们就考虑暴力统计，每次枚举一个点并枚举其出点和其出点的出点，这样做复杂度是 $\mathcal O(nm)$ 的———— $\rm Step(2)$

于是你还需要额外写个特判去判断两两相等的三元组对答案造成的贡献

可以发现算两两相等的三元组的复杂度是 $\mathcal O(m)$ 而计算三个全部相等的复杂度则是 $\mathcal O(n)$

我们尝试把 $5000$ 的点的部分的边数数出来，发现它是 **$49528$**

如果你写了个 $\rm map$ 来判两点之间有没有连边肯定会 $\rm T$ 飞以至于一分都无法获得

否则的话如果你不带 $\log$ 而是单纯的非严格 $nm$ 你应该可以获得 $\rm 30pts$ 的高分

### 于是我们要考虑优化

- 优化 $\rm Step2$

于是我们把三元环计数中的技巧拿出来用，就可以将复杂度变成 $\mathcal O(m\sqrt m)$ 了

当然三元环计数统计的是无向三元环计数

所以你还要枚举其六种不同的排列来确保正确性

这样就可以将复杂度做到 $\mathcal O(n^2+m\sqrt m)$ 了

如果你尝试写了一发并交了上去你会惊人的发现这个做法好像还是$30$分

- 优化 $\rm Step1$

我们考虑不以 $n^2$ 的枚举来建边

考虑枚举一个 $\gcd=x$，那么 $i=kx,j=px$

则 $\gcd(k,p)=1$

且 $\mu(i)\ne0,\mu(j)\ne0$ 并且 $(kpx)\le \max(A,B, C)$

我们枚举这个点对 $(k,p)$ 就行了

当然这样的建边复杂度并不是 $\mathcal O(m)$

但也比 $\mathcal O(n^2)$ 快，而且快得多

关于近似 $\mathcal O(m)$ 的建边就是考虑枚举 $\rm lcm$，同时 $\mu(\rm lcm)\ne0$，然后质因数分解其，枚举可能的 $\mu(x)\ne0$ 的点，对于每个点可以通过一个关于因数的取或不取二进制去标号它，记录一个桶，然后枚举其子集，那么要连的边就是其子集与其补集 $\&$ 得到的结果

于是你就十分开心自以为能过的打出了这道题的代码

当然如果你用的是 vector 你是真的能过的

否则你应该会 T

关于代码中特判两个相等的三元组对答案的贡献，因为这个菜得要死的笔者是先写完暴力再把两个优化加上的，所以他没有在连边的时候把这个情况处理掉

实际上是可以在连边的过程中处理掉的qwq

-----------------

- 小提示$1:$ 貌似枚举三元组的时候受到的限制很麻烦的样子$\min(A,B),\min(B,C),\min(C,A)$

- 然而实际上你并不需要管，统一把限制设成 $\max(A,B,C)$ 就好了

- 这是因为如果 $u>\min(A,B)$ 那么 $f(\min(A,B)/u)=0$

下面是~~又丑又长的~~代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 100000 + 500 ; 
const int P = 1e9 + 7 ; 
int A, B, C, f[N], u[N], p[N], d[N], r[N], deg[N], vis[N], book[N], cnt, tot, top ;
bool isp[N] ;
struct E { int to, w ; }; 
struct node { int u, v, w ; } e[N * 10]; 
vector<E> mp[N] ; 
inline void init() {
	isp[1] = 1, u[1] = 1, r[++ tot] = 1, book[1] = tot ;
	for( re int i = 2; i <= N - 5; ++ i ) {
		if( !isp[i] ) p[++ top] = i, u[i] = -1 ; 
		for( re int j = 1; j <= top && i * p[j] <= N - 5; ++ j ) {
			isp[i * p[j]] = 1 ; 
			if( i % p[j] == 0 ) continue ;
			u[i * p[j]] = - u[i] ; 
		}
		if( u[i] != 0 ) r[++ tot] = i, book[i] = tot ; 
	}
	for( re int i = 1; i <= N - 5; ++ i ) {
		for( re int j = i; j <= N - 5; j += i ) ++ d[j] ; 
		f[i] = ( f[i - 1] + d[i] ) % P ;
	} 
}
inline int gcd( int x, int y ) {
	if( x == 0 ) return y ; 
	return gcd( y % x, x ) ;
}
signed main()
{
	int T = read() ; init() ; 
	while( T-- ) {
		memset( mp, 0, sizeof(mp) ), memset( deg, 0, sizeof(deg) ) ;
		A = read(), B = read(), C = read(), cnt = 0 ; 
		int Ans = 0, D = 0 ; D = max( A, max( B, C ) ) ;
		
		//连边 
		for( re int g = 1; r[g] <= D; ++ g ) {
			for( re int i = 1; r[i] * r[g] <= D; ++ i ) {
				if( !u[r[i] * r[g]] ) continue ;  
				for( re int j = i + 1; j <= tot && r[i] * r[j] * r[g] <= D; ++ j ) {
					if( !u[r[j] * r[g]] || gcd( r[i], r[j] ) != 1 ) continue ;
					int u = book[r[i] * r[g]], v = book[r[j] * r[g]], w = r[i] * r[j] * r[g] ;
					++ deg[u], ++ deg[v], e[++ cnt] = (node){ u, v, w } ;
					mp[u].push_back((E){v, w}), mp[v].push_back((E){u, w}) ; 
				}
			}
		}
		
		//两个相等
		int rD = min( A, min( B, C ) ) ;
		for( re int i = 1; r[i] <= min( A, B ); ++ i ) {
			int siz = mp[i].size() - 1 ; 
			rep( j, 0, siz ) {
				int u1 = mp[i][j].to ; 
				Ans += u[r[i]] * u[r[u1]] * u[r[u1]] * f[A / mp[i][j].w] * f[B / mp[i][j].w] * f[C / r[u1]] ;
				Ans += u[r[i]] * u[r[i]] * u[r[u1]] * f[A / r[i]] * f[B / mp[i][j].w] * f[C / mp[i][j].w] ;
				Ans += u[r[i]] * u[r[i]] * u[r[u1]] * f[A / mp[i][j].w] * f[B / r[i]] * f[C / mp[i][j].w] ;
			}
		}
		// 三个相等
		for( re int i = 1; r[i] <= rD; ++ i ) Ans += u[r[i]] * u[r[i]] * u[r[i]] * f[A / r[i]] * f[B / r[i]] * f[C / r[i]] ;
		
		//互不相等 
		memset( mp, 0, sizeof(mp) ) ;
		for( re int i = 1; i <= cnt; ++ i )
			if( deg[e[i].u] >= deg[e[i].v] ) mp[e[i].u].push_back((E){ e[i].v, e[i].w }) ;
			else mp[e[i].v].push_back((E){ e[i].u, e[i].w }) ;
		for( re int i = 1; r[i] <= D; ++ i ) {
			int siz = mp[i].size() - 1 ; 
			rep( j, 0, siz ) vis[mp[i][j].to] = mp[i][j].w ; 
			rep( j, 0, siz ) {
				int u1 = mp[i][j].to, siz2 = mp[u1].size() - 1 ; 
				rep( k, 0, siz2 ) {
					int v = mp[u1][k].to ; 
					if( !vis[v] ) continue ; 
					int muu = u[r[i]] * u[r[u1]] * u[r[v]], b = mp[i][j].w, c = mp[u1][k].w, a = vis[v] ; 
					int rc = f[A / a] * ( f[B / b] * f[C / c] + f[B / c] * f[C / b] )
                            + f[A / b] * ( f[B / a] * f[C / c] + f[B / c] * f[C / a] )
                            + f[A / c] * ( f[B / a] * f[C / b] + f[ B / b ] * f[C / a] ) ; 
					Ans += muu * rc ; 
				}
			}
			rep( j, 0, siz ) vis[mp[i][j].to] = 0 ; 
		}
		printf("%d\n", Ans % P ) ;
	}
	return 0;
}
```

---

## 作者：GKxx (赞：34)

简单反演+神仙优化题。

首先我们知道

$\sigma_0(xy)=\sum\limits_{i|x}\sum\limits_{j|y}[(i,j)=1]$

$\sigma_0(xyz)=\sum\limits_{i|x}\sum\limits_{j|y}\sum\limits_{k|z}[(i,j)=1][(i,k)=1][(j,k)=1]$

（$\sigma_0$是除数函数，相当于题目描述中的$d$）

只要将$x,y,z$素因子分解后观察即可得到上面的结论。它的好处是出现了我们喜欢的$[a=1]$

就可以莫比乌斯反演了

$\sum\limits_{i=1}^a\sum\limits_{j=1}^b\sum\limits_{k=1}^c\sigma_0(ijk)$

$=\sum\limits_{i=1}^a\sum\limits_{j=1}^b\sum\limits_{k=1}^c\sum\limits_{u|i}\sum\limits_{v|j}\sum\limits_{w|k}[(u,v)=1][(u,w)=1][(v,w)=1]$

$=\sum\limits_{u=1}^a\sum\limits_{v=1}^b\sum\limits_{w=1}^c\lfloor\frac{a}{u}\rfloor\lfloor\frac{b}{v}\rfloor\lfloor\frac{c}{w}\rfloor[(u,v)=1][(u,w)=1][(v,w)=1]$

$=\sum\limits_{i=1}^a\sum\limits_{j=1}^b\sum\limits_{k=1}^c\lfloor\frac{a}{i}\rfloor\lfloor\frac{b}{j}\rfloor\lfloor\frac{c}{k}\rfloor\sum\limits_{u|(i,j)}\mu(u)\sum\limits_{v|(i,k)}\mu(v)\sum\limits_{w|(j,k)}\mu(w)$

$=\sum\limits_{u=1}^{\min(a,b)}\mu(u)\sum\limits_{v=1}^{\min(a,c)}\mu(v)\sum\limits_{w=1}^{\min(b,c)}\mu(w)\sum\limits_{[u,v]|i}^a\lfloor\frac{a}{i}\rfloor\sum\limits_{[u,w]|j}^b\lfloor\frac{b}{j}\rfloor\sum\limits_{[v,w]|k}^c\lfloor\frac{c}{k}\rfloor$

设$f_y(x)=\sum\limits_{x|i}^y\lfloor\frac{y}{i}\rfloor$，可以$O(n\log n)$预处理出$f_a,f_b,f_c$所有值

$ans=\sum\limits_{u=1}^{\min(a,b)}\mu(u)\sum\limits_{v=1}^{\min(a,c)}\mu(v)\sum\limits_{w=1}^{\min(b,c)}\mu(w)f_a([u,v])f_b([u,w])f_c([v,w])$

然而痛苦的地方就在于这样推并不能降复杂度，目前为止我们的复杂度依然是$O(n^3)$。事实上可以把它推到$O(n^2\log n)$的，那样做可以过cf原题但是并不利于我们这题的后续优化。

但是也许我们可以不$O(n^3)$地枚举$(u,v,w)$三元组，因为事实上这样枚举的过程中有很多情况的贡献是$0$:

- 如果$\mu(u),\mu(v),\mu(w)$中有一个是$0$，那么贡献是$0$。这样的情况还挺多的。

- 如果$x>y$，那么$f_y(x)=0$。也就是说$[u,v]>a$或者$[u,w]>b$或者$[v,w]>c$都会导致贡献是$0$。

所以我们有一种做法就是枚举最大公约数$g$，枚举$u=ig,v=jg$并注意满足条件$(i,j)=1,\mu(u)\neq0,\mu(v)\neq0,[u,v]=ijg\leq\max(a,b,c)$，连边$(u,v)$，建出一张图。这张图的三元环刚好对应到$(u,v,w)$三元组，三元环计数的同时统计答案即可。

至于这样做的复杂度为什么是对的，我们已经发现有相当多的点对$(u,v)$并不满足上述条件（意味着它们产生的贡献是$0$），除去这些之后剩下的点对连出的边不会太多。正如shadowice大佬已经说了他实测下来这个边数只有七十多万。那么只要你的三元环计数速度合格就好。

关于三元环计数，可以参考[iki9的这篇博客](https://www.luogu.org/blog/KingSann/fou-chang-yong-di-hei-ke-ji-san-yuan-huan-post)，我们可以在$O(m\sqrt m)$的时间内完成三元环计数。

但是注意到上述连边没有考虑到自环。也就是说如果三元组$(u,v,w)$中存在两个数相等或者三个数都相等，我们并没有将答案计算在内。因此我们需要单独算。这个很方便：三个数都相等的情况直接枚举这个数是几，把答案加起来就好；恰好有两个数相等的情况就在我们枚举$(u,v)$连边的过程中解决，只要顺手把$(u,u,v)$和$(u,v,v)$的答案都加起来即可。

在做的过程中时刻注意剪枝，只要出现$\mu$值为$0$就跳过。另外可以顺手加一些循环展开、register之类的卡卡常。还有大家应该都注意到的cache miss问题，我们选择使用vector而不是邻接表存图以访问连续的内存来加速。

还有一个小trick：我们统计的是$ijk$的约数个数之和，一个数的约数个数不会很多，$i,j,k$又都小于等于$10^5$，估计最终的答案不会太大。事实上答案是不会超过$\text{long long}$的，因此我们在统计的过程中完全不需要取模，只要在最后输出的时候模一下即可。

给一份稍微可读一点的代码

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <vector>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T> void write(T x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> inline void writeln(T x) { write(x); puts(""); }
template <typename T> inline bool chkmin(T &x, const T &y) { return y < x ? (x = y, 1) : 0; }
template <typename T> inline bool chkmax(T &x, const T &y) { return x > y ? (x = y, 1) : 0; }

#if __cplusplus >= 201103L
#define reg
#else
#define reg register
#endif

typedef long long LL;
const int maxn = 1e5 + 207;
const LL mod = 1e9 + 7;
int mu[maxn], pri[maxn];
bool ff[maxn];
LL fa[maxn], fb[maxn], fc[maxn];
int a, b, c, mx, mn;

struct Edge {
    int u, v, w;
    Edge(int x, int y, int z = 0) : u(x), v(y), w(z) {}
    Edge() : u(0), v(0), w(0) {}
};
struct Node {
    int to, w;
    Node(int x, int y = 0) : to(x), w(y) {}
    Node() : to(0), w(0) {}
};
std::vector<Node> G[maxn];
int deg[maxn];
Edge es[maxn << 4];
int vis[maxn];
int etot;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
inline void sieve(int n) {
    mu[1] = 1;
    for (reg int i = 2; i <= n; ++i) {
        if (!ff[i]) { pri[++pri[0]] = i; mu[i] = -1; }
        for (reg int j = 1; j <= pri[0]; ++j) {
            int x = i * pri[j];
            if (x > n) break;
            ff[x] = 1;
            if (i % pri[j]) mu[x] = -mu[i];
            else { mu[x] = 0; break; }
        }
    }
}

int main() {
    int T; read(T);
    sieve(1e5);
    while (T--) {
        read(a); read(b); read(c);
        mx = std::max(std::max(a, b), c);
        mn = std::min(std::min(a, b), c);
        // 预处理 f 函数值
        for (reg int i = 1; i <= mx; i += 4) {
            fa[i] = 0; fa[i + 1] = 0; fa[i + 2] = 0; fa[i + 3] = 0;
            fb[i] = 0; fb[i + 1] = 0; fb[i + 2] = 0; fb[i + 3] = 0;
            fc[i] = 0; fc[i + 1] = 0; fc[i + 2] = 0; fc[i + 3] = 0;
        }
        for (reg int i = 1; i <= a; ++i)
            for (reg int j = i; j <= a; j += i)
                fa[i] += a / j;
        for (reg int i = 1; i <= b; ++i)
            for (reg int j = i; j <= b; j += i)
                fb[i] += b / j;
        for (reg int i = 1; i <= c; ++i)
            for (reg int j = i; j <= c; j += i)
                fc[i] += c / j;

        // u = v = w
        LL ans = 0;
        for (reg int i = 1; i <= mn; ++i)
            if (mu[i])
                ans += mu[i] * mu[i] * mu[i] * fa[i] * fb[i] * fc[i];

        // u, v, w 有两个相等
        etot = 0;
        for (reg int i = 1; i <= mx; i += 4) {
            deg[i] = 0; deg[i + 1] = 0; deg[i + 2] = 0; deg[i + 3] = 0;
        }
        for (reg int g = 1; g <= mx; ++g)
            for (reg int i = 1; i * g <= mx; ++i)
                if (mu[i * g])
                    for (reg int j = i + 1; 1ll * i * j * g <= mx; ++j)
                        if (mu[j * g] && gcd(i, j) == 1) {
                            int u = i * g, v = j * g, lcm = i * j * g;
                            int uuv = mu[u] * mu[u] * mu[v], uvv = mu[u] * mu[v] * mu[v];
                            ans += uuv * (fa[u] * fb[lcm] * fc[lcm] + fa[lcm] * fb[u] * fc[lcm] + fa[lcm] * fb[lcm] * fc[u]);
                            ans += uvv * (fa[v] * fb[lcm] * fc[lcm] + fa[lcm] * fb[v] * fc[lcm] + fa[lcm] * fb[lcm] * fc[v]);
                            ++deg[u]; ++deg[v];
                            es[++etot] = Edge(u, v, lcm);
                        }

        // u, v, w 两两不同
        for (reg int i = 1; i <= mx; ++i) G[i].clear();
        for (reg int i = 1; i <= etot; ++i) {
            int u = es[i].u, v = es[i].v, w = es[i].w;
            if (deg[u] > deg[v] || (deg[u] == deg[v] && u < v))
                G[u].push_back(Node(v, w));
            else G[v].push_back(Node(u, w));
        }
        for (reg int x = 1; x <= mx; ++x) if (mu[x]) {
            unsigned sz = G[x].size();
            for (reg unsigned i = 0; i < sz; ++i)
                vis[G[x][i].to] = G[x][i].w;
            for (reg unsigned i = 0; i < sz; ++i) {
                int y = G[x][i].to, wxy = G[x][i].w;
                if (!mu[y]) continue;
                for (reg unsigned j = 0, sszz = G[y].size(); j < sszz; ++j) {
                    int z = G[y][j].to;
                    if (vis[z]) {
                        int wyz = G[y][j].w, wxz = vis[z], mmuu = mu[x] * mu[y] * mu[z];
                        if (!mmuu) continue;
                        ans += mmuu * (fa[wxy] * fb[wyz] * fc[wxz]
                                        + fa[wxy] * fb[wxz] * fc[wyz]
                                        + fa[wyz] * fb[wxy] * fc[wxz]
                                        + fa[wyz] * fb[wxz] * fc[wxy]
                                        + fa[wxz] * fb[wxy] * fc[wyz]
                                        + fa[wxz] * fb[wyz] * fc[wxy]);
                    }
                }
            }
            for (reg unsigned i = 0; i < sz; ++i)
                vis[G[x][i].to] = 0;
        }
        writeln(ans % mod);
    }
    return 0;
}
```

另附$O(n^2\log n)$的做法：

$ans=\sum\limits_{u=1}^a\sum\limits_{v=1}^b\sum\limits_{w=1}^c\lfloor\frac{a}{u}\rfloor\lfloor\frac{b}{v}\rfloor\lfloor\frac{c}{w}\rfloor[(u,v)=1][(u,w)=1][(v,w)=1]$

$=\sum\limits_{i=1}^a\sum\limits_{j=1}^b\sum\limits_{k=1}^c\lfloor\frac{a}{i}\rfloor\lfloor\frac{b}{j}\rfloor\lfloor\frac{c}{k}\rfloor\sum\limits_{d|(i,j)}\mu(d)[(i,k)=1][(j,k)=1]$

$=\sum\limits_{d=1}^{\min(a,b)}\mu(d)\sum\limits_{d|i}^a\sum\limits_{d|j}^b\lfloor\frac{a}{i}\rfloor\lfloor\frac{b}{j}\rfloor\sum\limits_{k=1}^c\lfloor\frac{c}{k}\rfloor[(i,k)=1][(j,k)=1]$

$=\sum\limits_{d=1}^{\min(a,b)}\mu(d)\sum\limits_{i=1}^{\lfloor\frac{a}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{b}{d}\rfloor}\lfloor\frac{a}{id}\rfloor\lfloor\frac{b}{jd}\rfloor\sum\limits_{k=1}^c\lfloor\frac{c}{k}\rfloor[(id,k)=1][(jd,k)=1]$

$=\sum\limits_{k=1}^c\lfloor\frac{c}{k}\rfloor\sum\limits_{d=1}^{\min(a,b)}\mu(d)[(d,k)=1]\sum\limits_{i=1}^{\lfloor\frac{a}{d}\rfloor}\lfloor\frac{a}{id}\rfloor[(i,k)=1]\sum\limits_{j=1}^{\lfloor\frac{b}{d}\rfloor}\lfloor\frac{b}{jd}\rfloor[(j,k)=1]$

设函数$f(x,y)=\sum\limits_{i=1}^x\lfloor\frac{x}{i}\rfloor[(i,y)=1]$那么

$ans=\sum\limits_{k=1}^c\lfloor\frac{c}{k}\rfloor\sum\limits_{d=1}^{\min(a,b)}\mu(d)[(d,k)=1]f(\lfloor\frac{a}{d}\rfloor,k)f(\lfloor\frac{b}{d}\rfloor,k)$

枚举$k$，枚举$d$，这个$f$直接$O(x)$暴力就行了，因为$x=a/d$所以枚举$d$和计算$f$的总复杂度是$O(n\log n)$（调和级数乘以$n$），总复杂度$O(n^2\log n)$

---

## 作者：zhoukangyang (赞：28)

## 蒟蒻语
第 **50** 道黑题，写篇题解祭一下 /cy
## 蒟蒻解
$
\begin{aligned}
&\sum\limits_{i=1}^{A} \sum\limits_{j=1}^{B} \sum\limits_{k=1}^{C} d(i, j, k)\\
&= \sum\limits_{i=1}^{A} \sum\limits_{j=1}^{B} \sum\limits_{k=1}^{C} \sum\limits_{x|i} \sum\limits_{y|j} \sum\limits_{z|k} [\gcd(x, y) = 1][\gcd(y, z) = 1][\gcd(z, x) = 1]\\
&= \sum\limits_{x=1}^{A} \sum\limits_{y=1}^{B} \sum\limits_{z=1}^{C} [\gcd(x, y) = 1][\gcd(y, z) = 1][\gcd(z, x) = 1] \left\lfloor\frac{A}{x}\right\rfloor \left\lfloor\frac{B}{y}\right\rfloor \left\lfloor\frac{C}{z}\right\rfloor\\
&= \sum\limits_{d_1=1}^{A} \mu(d_1)\sum\limits_{d_2=1}^{B} \mu(d_2) \sum\limits_{d_3=1}^{C} \mu(d_3) \sum\limits_{x=1}^{ \left\lfloor\frac{A}{\operatorname{lcm}(d_1,d_2)}\right\rfloor} \left\lfloor\frac{A}{\operatorname{lcm}(d_1,d_2)x}\right\rfloor \sum\limits_{y=1}^{ \left\lfloor\frac{B}{\operatorname{lcm}(d_2,d_3)}\right\rfloor} \left\lfloor\frac{B}{\operatorname{lcm}(d_2,d_3)y}\right\rfloor \sum\limits_{z=1}^{ \left\lfloor\frac{C}{\operatorname{lcm}(d_3,d_1)}\right\rfloor} \left\lfloor\frac{C}{\operatorname{lcm}(d_3,d_1)z}\right\rfloor\\
\end{aligned}
$

(设 $Max = \max (A, B, C)$)

考虑哪些三元组会有贡献。

1. $\mu(d_1), \mu(d_2), \mu(d_3)$ 不为 $0$。
1. $\operatorname{lcm}(d_1,d_2) , \operatorname{lcm}(d_2,d_3), \operatorname{lcm}(d_3,d_1) \le Max$

把一个数看成一个点。

首先我们把 $\mu(x)$ 为 $0$ 的点排除在外。

然后把 $\operatorname{lcm}(x, y) \le Max$ 的点连接起来。

然后再做一遍三元环计数就好了，暴力枚举每一个三元环统计答案。为了更快地统计答案，可以先把边定向。

这样的时间复杂度是 $O(m \sqrt m)$ 的。( $m$ 是边数)

事实上，边数最多只有 $821535$ 条 (用蒟蒻劣质的程序算出来)

因此这道题就被解决了

## 蒟蒻码

```cpp
#include<bits/stdc++.h>
#define L(i, j, k) for(int i = j; i <= k; i++)
#define R(i, j, k) for(int i = j; i >= k; i--)
#define ll long long
using namespace std;
const int N = 1e5 + 7;
const int M = 1e6 + 7;
const int mod = 1e9 + 7;
bool Prime[N];
int tot, P[N >> 3], mu[N];
void xxs() {
	mu[1] = 1;
	L(i, 2, 1e5)  {
		if(!Prime[i]) P[++tot] = i, mu[i] = -1;
		for(int j = 1; P[j] * i <= 1e5 && j <= tot; j++) {
			Prime[P[j] * i] = 1;
			if(i % P[j] == 0) {
				mu[P[j] * i] = 0;
				break;
			}
			mu[P[j] * i] = -mu[i];
		}
	}
} 
vector<int> ve[N];
unordered_map<int, bool> mp[N];
int T, Max, A, B, C, ans, p[N];
int sA[M], sB[M], sC[M], cnt, deg[N];
int gcd(int x, int y) { return x == 0 ? y : gcd(y % x, x); }
ll lcm(int x, int y) { return 1ll * x / gcd(x, y) * y; }
int ta, tb, tc, sum;
void dh(int a, int b, int c) {
	(sum += 1ll * p[a / ta] * p[b / tb] % mod * p[c / tc] % mod) %= mod;
}
void get(int a, int b, int c) {
	sum = 0;
	if(a == b && b == c) dh(A, B, C);
	else if(a == b || b == c || c == a) dh(A, B, C), dh(C, A, B), dh(B, C, A);
	else dh(A, B, C), dh(A, C, B), dh(B, A, C), dh(B, C, A), dh(C, A, B), dh(C, B, A);
	(ans += (mu[a] * mu[b] * mu[c] * sum % mod + mod) % mod) %= mod;
}
int vis[N];
void js() {
	L(i, 1, cnt) {
		int &u = sA[i], &v = sB[i];
		if(deg[u] > deg[v]) swap(u, v);
		else if(deg[u] == deg[v] && u > v) swap(u, v);
		ve[u].push_back(i);
	}
	L(i, 1, Max) {
		for(int j : ve[i]) vis[sB[j]] = sC[j];
		for(int j : ve[i]) for(int k : ve[sB[j]]) 
			if(vis[sB[k]]) ta = vis[sB[k]], tb = sC[j], tc = sC[k], get(i, sB[j], sB[k]);
		for(int j : ve[i]) vis[sB[j]] = 0;
	}
}
void getans(int x) {
	for(int l = 1, r; l <= x; l = r + 1) {
		r = (x / (x / l));
		(p[x] += 1ll * (r - l + 1) * (x / l) % mod) %= mod;
	}
}
int main() {
	scanf("%d", &T);
	xxs();
	L(i, 1, 1e5) getans(i);
	while(T--) {
		scanf("%d%d%d", &A, &B, &C);
		ans = cnt = 0;
		Max = max(max(A, B), C);
		R(i, Max, 1) for(int j = i; j <= Max; j += i) {
				if(!mu[j]) continue;
				for(int k = j; k <= 1ll * Max * i / j; k += i) {
					if(!mu[k]) continue;
					if(!mp[j][k]) ++cnt, sA[cnt] = j, sB[cnt] = k, sC[cnt] = j / i * k, deg[j] ++, deg[k] ++, mp[j][k] = 1;
				}
			}
		js();
		L(i, 1, Max) ve[i].clear(), mp[i].clear(), deg[i] = 0;
		printf("%d\n", (ans + mod) % mod);
	}
	return 0;
}
```

---

## 作者：Vocalise (赞：15)

非常神仙的题目，三元环做法已经非常神仙，但是 @big_news 的做法让这题更加神仙。

这个做法大概没什么人提到吧。

首先有

$$d(ijk)=\sum_{x|i}\sum_{y|j}\sum_{z|k}[x\perp y][y\perp z][x\perp z] $$

非常显然有 $d(ijk)=\sum_{x|ijk}1$，分开 $i,j,k$ 数会重复，于是我们让 $ijk$ 相同的质因子在 $x,y,z$ 中只出现一个。 [	
P3327 [SDOI2015]约数个数和](www.luogu.com.cn/problem/P3327) 中有介绍。

$$\begin{aligned}
&\ \ \ \ \sum_{x=1}^a\sum_{y=1}^b\sum_{z=1}^cd(xyz) \\
&=\sum_{x=1}^a\sum_{y=1}^b\sum_{z=1}^c\sum_{i|x}\sum_{j|y}\sum_{k|z}[i\perp j][j\perp k][i\perp k] \\
&=\sum_{x=1}^a\sum_{y=1}^b\sum_{z=1}^c \lfloor\frac ax\rfloor \lfloor\frac by\rfloor \lfloor\frac cz\rfloor[x\perp y][y\perp z][x\perp z] \\
&=\sum_{x=1}^a\lfloor\frac ax\rfloor \sum_{y=1}^b\sum_{z=1}^c \lfloor\frac by\rfloor \lfloor\frac cz\rfloor[x\perp y]\sum_{d|y,d|z}\mu(d)[x\perp z] \\
&=\sum_{x=1}^a\lfloor\frac ax\rfloor\sum_{d=1}^{\min(b,c)}\mu(d)\sum_{y=1}^{b/d}\sum_{z=1}^{c/d}\lfloor\frac b{dy}\rfloor\lfloor\frac c{dz}\rfloor[x\perp dy][x\perp dz] \\
&=\sum_{x=1}^a\lfloor\frac ax\rfloor\sum_{d=1}^{\min(b,c)}\mu(d)[x\perp d]\sum_{y=1}^{b/d}\sum_{z=1}^{c/d}\lfloor\frac b{dy}\rfloor\lfloor\frac c{dz}\rfloor[x\perp y][x\perp z] \\
\end{aligned}$$

注意到我们在三个互质中只反演了一个。从这里开始就不同了。

后面式子的形式引出了两个函数的定义：

$$f(n,k)=\sum_{i=1}^n \lfloor\frac ni\rfloor[i\perp k]$$

$$g(n,k)=\sum_{i=1}^n\mu(i)[i\perp k]$$

则原式可以直接代入 $f$：

$$\sum_{x=1}^a \lfloor\frac ax\rfloor\sum_{d=1}^{\min(b,c)}\mu(d)[d\perp x]f(\lfloor\frac b{d} \rfloor,x)f(\lfloor\frac c{d} \rfloor,x) $$

则如果找出 $f(n,k)$ 在整除点的值和 $g(n,k)$ 在分块右端点前缀和的计算方法，式子后一部分可以整除分块计算。

$g(n,k)$ 在 [P1587 [NOI2016]循环之美](https://www.luogu.com.cn/problem/P1587) 中笔者的另一篇 [题解](https://www.luogu.com.cn/blog/void-basic-learner/solution-p1587) 有详解。本题做法也与其有部分类似。

忽略 $k$ 中平方因子，而 $p$ 是 $k$ 中一个质因子（同样参见链接），我们得到结论：

$$g(n,k)=g(\lfloor\frac np\rfloor,k)+g(n,\frac kp)$$

那我们尝试同样分析 $f(n,k)$。

$$\begin{aligned}
&\ \ \ \ \ f(n,k)=\sum_{i=1}^n\lfloor\frac ni\rfloor[i\perp k] \\
&=\sum_{i=1}^n \lfloor\frac ni\rfloor[i\perp\frac kp]-\sum_{i=1} ^n\lfloor\frac ni\rfloor[i\perp\frac kp][p|i] \\
&=f(n,\frac kp)-\sum_{i=1}^{n/p}\lfloor\frac n{ip}\rfloor[i\perp\frac kp] \\
&=f(n,\frac kp)-f(\lfloor\frac np \rfloor,\frac kp)
\end{aligned}$$

边界也显然。

$$f(0,k)=0,f(n,1)=\sum_{i=1}^n\lfloor\frac ni \rfloor=\sum_{i=1}^nd(i)$$

$$g(0,k)=0,g(n,1)=\sum_{i=1}^n\mu(d)$$

两者可以简单地线性筛出来。

---

$f(n,k),g(n,k)$ 的第一维对于一个 $n$，取遍 $b,c$ 的整除点有 $\sqrt n$ 个；

第二维对于一个 $k$，有取遍其素因子个，这个数低于 $\log k$。那 $[1,n]$ 中的无平方因子数有多少呢？最粗略的估计下，它有 $O(n)$ 个，因为即使有 $\log_2n$ 个 $2$ 作为素数进行乘积，也仅有 $2^{\log_2n}=n$ 个。

显然实际远低于 $O(n)$，但是下文仍写为 $O(n)$。

得到状态是 $O(n\sqrt n)$ 的，$O(1)$ 转移，加上分块，总复杂度是 $O(n\sqrt n)$ 的。

于是用 `unordered_map` 维护 $f,g$，枚举无平方因子的 $x$，分块时递归计算得到答案。

我们发现，根据 $k$ 的本质是一个素因子集合，对于该集合相同的 $x$，没有必要全部枚举。

记 $sv(x)$ 为 $x$ 因子去重得到的数，它可以线性筛得出。

我们统计 $sv(x)$ 相同的 $x$ 的 $\lfloor\dfrac ax\rfloor $ 之和，枚举存在的 $sv(x)$ 即可。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <unordered_map>

#define umap std::unordered_map
typedef long long ll;
const int V = 100001;
const int p = 1000000007;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

int df[V],P[V],tt; ll mu[V],d[V],sv[V];

void Seive() {
	mu[1] = d[1] = sv[1] = 1;
	for(int i = 2;i < V;i++) {
		if(!df[i]) P[++tt] = i, mu[i] = -1, d[i] = 2, sv[i] = i;
		for(int j = 1;j <= tt && i * P[j] < V;j++) {
			int t = i * P[j]; df[t] = 1;
			if(i % P[j]) mu[t] = p - mu[i], d[t] = 2 * d[i] % p, sv[t] = sv[i] * P[j];
			else mu[t] = 0, d[t] = (2 * d[i] % p - d[i / P[j]] + p) % p, sv[t] = sv[i];
		}
	}
	for(int i = 1;i < V;i++) mu[i] = (mu[i] + mu[i - 1]) % p;
	for(int i = 1;i < V;i++) d[i] = (d[i] + d[i - 1]) % p;
	return;
}

ll pd[V],pdt,cl[V];
umap <int,umap <int,ll> > Fmap,Gmap;

ll F(int n,int k,int s) {
	if(!n) return 0;
	else if(k == 1) return d[n];
	else if(Fmap[n].count(k)) return Fmap[n][k];
	return Fmap[n][k] = (F(n,k / pd[s],s + 1) - F(n / pd[s],k / pd[s],s + 1) + p) % p;
}

ll G(int n,int k,int s) {
	if(!n) return 0;
	else if(k == 1) return mu[n];
	else if(Gmap[n].count(k)) return Gmap[n][k];
	return Gmap[n][k] = (G(n / pd[s],k,s) + G(n,k / pd[s],s + 1)) % p;
}


int main() {
	Seive();
	int tc = read();
	while(tc--) {
		int a = read(), b = read(), c = read(); ll ans = 0;
		if(b > c) std::swap(b,c); if(a > b) std::swap(a,b);
		for(int i = 1;i <= a;i++) cl[i] = 0;
		for(int i = 1;i <= a;i++) cl[sv[i]] += a / i;
		for(int x = 1;x <= a;x++) if(cl[x]) {
			ll res = 0; pdt = 0;
			for(int i = 1;i <= tt && P[i] <= x;i++)
				if(!(x % P[i])) pd[++pdt] = P[i];
			for(int i = 1;i <= b && i <= c;i++) {
				int j = std::min(b / (b / i),c / (c / i));
				res = (res + F(b / i,x,1) * F(c / i,x,1) % p * (G(j,x,1) - G(i - 1,x,1) + p) % p) % p;
				i = j;
			}
			ans = (ans + cl[x] % p * res % p) % p;
		}
		std::printf("%lld\n",ans);
	}
	return 0;
}
```

---

结果 $a=b=c=10000$ 就跑了 $10s$，$a=b=c=100000$ 的根本出不来。

瓶颈在对 $f(n,k),g(n,k)$ 的维护上。考虑去掉二维的 `unordered_map`。

然后似乎无法可想？$f,g$ 的第一维是取满的 $O(\sqrt n)$，仍然考虑第二维。

如果对质因子集合的访问是随机的，就像我们初步得到的从小到大枚举的方法，无法解决问题。

那如果是顺序插入删除呢？

显然我们需要的是一个按 Dfs 序遍历质因子的顺序维护的 $f,g$ 的值。

那么可以把状态简单地顺序分层了。具体地，对于质数序列 $p_1,p_2,\cdots p_s$ 和 $k=\prod p_i$，将 $f(n,k)$ 和 $g(n,k)$ 记录在第 $s$ 层，转移时根据 $s-1$ 层的状态。

对于每一个 $k$ 统计答案。

$s$ 根据上面的分析，是 $O(\log_2n)$ 的，空间上完全可以承受。

注意转移中 $f$ 和 $g$ 用到的第一维永远只有 $O(\sqrt n)$ 个点，如上所述，$f$ 用到了整除点，$g$ 用到了整除点 $-1$ 的点。

实际复杂度比 $O(n\sqrt n)$ 要小不少，$100000$ 的样例大约 $4s$。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

typedef long long ll;
const int V = 100001;
const int p = 1000000007;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

int df[V],P[V],t;
ll mu[V],sv[V],d[V],cl[V];

void Seive() {
	mu[1] = sv[1] = d[1] = 1;
	for(int i = 2;i < V;i++) {
		if(!df[i]) P[++t] = i, mu[i] = -1, sv[i] = i, d[i] = 2;
		for(int j = 1;j <= t && i * P[j] < V;j++) {
			int t = i * P[j]; df[t] = 1;
			if(i % P[j]) mu[t] = -mu[i], sv[t] = sv[i] * P[j], d[t] = 2 * d[i] % p;
			else mu[t] = 0, sv[t] = sv[i], d[t] = (2 * d[i] % p - d[i / P[j]] + p) % p;
		}
	}
	for(int i = 1;i < V;i++) mu[i] = (mu[i - 1] + mu[i]) % p;
	for(int i = 1;i < V;i++) d[i] = (d[i - 1] + d[i]) % p;
}

int a,b,c; ll ans;
ll f[V][20], g[V][20];

void Dfs(ll x,int s,int k) {
	ll res = 0;
	for(int i = 1;i <= b && i <= c;i++) {
		int j = std::min(b / (b / i),c / (c / i));
		res = (res + (g[j][k] - g[i - 1][k] + p) % p * f[b / i][k] % p * f[c / i][k] % p) % p;
		i = j;
	}
	ans = (ans + cl[x] * res % p) % p;
	for(int r = s;r <= t && x * P[r] <= a;r++) {
		for(int i = 1;i <= b && i <= c;i++) {
			int j = std::min(b / (b / i),c / (c / i));
			f[b / i][k + 1] = (f[b / i][k] - f[b / i / P[r]][k] + p) % p;
			f[c / i][k + 1] = (f[c / i][k] - f[c / i / P[r]][k] + p) % p;
			g[j][k + 1] = (g[j / P[r]][k + 1] + g[j][k]) % p;
			i = j;
		}
		Dfs(x * P[r],r + 1,k + 1);
	}
	return;
}

int main() {
	Seive();
	int t = read();
	while(t--) {
		a = read(), b = read(), c = read();
		for(int i = 1;i <= a;i++) cl[i] = 0;
		for(int i = 1;i <= a;i++) cl[sv[i]] += a / i;
		for(int i = 1;i <= b && i <= c;i++) {
			int j = std::min(b / (b / i),c / (c / i));
			f[b / i][1] = d[b / i], f[c / i][1] = d[c / i];
			g[j][1] = mu[j];
			i = j;
		}
		ans = 0, Dfs(1,1,1);
		std::printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：_LHF_ (赞：12)

### 警告：此题卡常
花了我一天半的时间才弄好。

做法：纯正的莫比乌斯反演。
$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^Cd(ijk)$$
先考虑后面那个函数
$$d(ijk)=\sum_{x|i}\sum_{y|j}\sum_{z|k}[x\perp y][y\perp z][x\perp z]$$
证明，见 [[SDOI2015约数个数和]](https://www.luogu.com.cn/problem/P3327)
好了，带回去得到原式得到
$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{x|i}\sum_{y|j}\sum_{z|k}[x\perp y][y\perp z][x\perp z]$$
然后枚举 $x,y,z$ 得到
$$\sum_{x=1}^A\sum_{y=1}^B\sum_{z=1}^C\lfloor\frac{A}{x}\rfloor\lfloor\frac{B}{y}\rfloor\lfloor\frac{C}{z}\rfloor[x\perp y][y\perp z][x\perp z]$$
考虑拎出来其中一个进行反演，得到
$$\sum_{x=1}^A\sum_{y=1}^B\sum_{z=1}^C\sum_{d|x,d|y}\mu(d)\lfloor\frac{A}{x}\rfloor\lfloor\frac{B}{y}\rfloor\lfloor\frac{C}{z}\rfloor[y\perp z][x\perp z]$$
钦定 $A\le B$
$$\sum_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum_{d=1}^A\mu(d)\sum_{x|d}^A\lfloor\frac{A}{x}\rfloor[y\perp z]\sum_{y|d}^B\lfloor\frac{B}{y}\rfloor[x\perp z]$$
设 $p=\lfloor\frac{A}{d}\rfloor,q=\lfloor\frac{B}{d}\rfloor$
$$\sum_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum_{d=1}^A\mu(d)\sum_{x=1}^p\lfloor\frac{A}{x}\rfloor[yd\perp z]\sum_{y|d}^B\lfloor\frac{B}{q}\rfloor[xd\perp z]$$
$$\sum_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum_{d=1}^A\mu(d)[d\perp z]\sum_{x=1}^p\lfloor\frac{A}{x}\rfloor[y\perp z]\sum_{y|d}^B\lfloor\frac{B}{q}\rfloor[x\perp z]$$
设 $f(x,y)=\sum_{i=1}^x\lfloor\frac{x}{i}\rfloor[i\perp y]$
$$\sum_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum_{d=1}^A\mu(d)[d\perp z]f(p,z)f(q,z)$$
再设 $g(x,y)=\sum_{i=1}^x\mu(i)[i\perp y]$
$$\sum_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum_{l,r}(g(r,z)-g(l-1,z))f(p,z)f(q,z)$$
其中后面是一个数论分块。

现在考虑计算 $f(x,y)$ 和 $g(x,y)$ ，设 $p$ 是 $y$ 的一个质因数（和上文的 $p$ 无关）

那么考虑 $y→y/p$ 之后的答案，再用容斥原理减回去
$$f(x,y)=\sum_{i=1}^x\lfloor\frac{x}{i}\rfloor[i\perp y/p]-\sum_{i=1}^x\lfloor\frac{x}{i}\rfloor[i\perp y/p][i|p]$$
$$=f(x,y/p)-\sum_{i=1}^{\lfloor\frac{x}{p}\rfloor}\lfloor\frac{x}{ip}\rfloor[ip\perp y/p]$$
$$=f(x,y/p)-[p\perp y/p]\sum_{i=1}^{\lfloor\frac{x}{p}\rfloor}\lfloor\frac{x}{ip}\rfloor[i\perp y/p]$$
$$=f(x,y/p)-[p\perp y/p]f(\lfloor\frac{x}{p}\rfloor,y/p)$$
然后是 $g(x,y)$ ，同样的套路，设 $p$ 是 $y$ 的一个质因数（也和上文的 $p$ 无关）
$$g(x,y)=\sum_{i=1}^x\mu(i)[i\perp y/p]-\sum_{i=1}^x\mu(i)[i\perp y/p][i|p]$$
$$=g(x,y/p)-\sum_{i=1}^{\lfloor\frac{x}{p}\rfloor}\mu(ip)[ip\perp y/p]$$
然后根据 $\mu(ab)=\mu(a)\mu(b)[a\perp b]$ 以及 $\mu(p)=-1$ 可得
$$=g(x,y/p)+\sum_{i=1}^{\lfloor\frac{x}{p}\rfloor}\mu(i)[i\perp p][ip\perp y/p]$$
$$=g(x,y/p)+[p\perp y/p]\sum_{i=1}^{\lfloor\frac{x}{p}\rfloor}\mu(i)[i\perp p][i\perp y/p]$$
$$=g(x,y/p)+[p\perp y/p]\sum_{i=1}^{\lfloor\frac{x}{p}\rfloor}\mu(i)[i\perp y]$$
$$=g(x,y/p)+[p\perp y/p]g(\lfloor\frac{x}{p}\rfloor,y)$$
然后……
可以打出一种暴力，时间复杂度 $O(n\sqrt n)$ ，这里假设 $n=\max(A,B,C)$空间复杂度也是 $O(n\sqrt n)$ ，可以拿到 70 分。
```cpp
#include<cstdio>
#include<algorithm>
#define N 100010
using namespace std;
int pp[N],C,lx[N];
const int mod=1e9+7;
struct node{
	int f[640][N],id[N],d[N],len,l,r,i,j,x;
	void work(int n,int*h)
	{
		len=0;
		for(l=1;l<=n;l=r+1)
		{
			r=n/(n/l);
			id[r]=++len;
			d[len]=r;
		}
		for(i=1;i<=len;i++)
		{
			x=d[i];
			f[i][1]=(h[x]+mod)%mod;
			for(j=2;j<=C;j++)
				f[i][j]=(f[i][j/lx[j]]-pp[j]*f[id[x/lx[j]]][j/lx[j]]+mod)%mod;
		}
	}
	inline int calc(int x,int y)
	{ return x?f[id[x]][y]:0; }
}f1,f2;
struct node2{
	int f[1270][N],id[N],d[N],len,l,r,i,j,x;
	void work(int n,int m,int*h)
	{
		len=0;
		x=min(n,m);
		for(l=1;l<=x;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			id[r]=++len;
			d[len]=r;
		}
		for(i=1;i<=len;i++)
		{
			x=d[i];
			f[i][1]=(h[x]+mod)%mod;
			for(j=2;j<=C;j++)
				f[i][j]=(f[i][j/lx[j]]+pp[j]*f[id[x/lx[j]]][j])%mod;
		}
	}
	inline int calc(int x,int y)
	{ return x?f[id[x]][y]:0; }
}g;
int vis[N],p[N],mu[N],h[N],T,id[N],d[N],n,A,B,x,k[N],len;
long long ans,s1,s2,s3,s4,s5,s6,s7,s8;
signed main()
{
	int i,j,l,r;
	n=N-10;
	mu[1]=k[1]=h[1]=1;
	for(i=2;i<=n;i++)
	{
		h[i]++;
		if(!vis[i]) p[++len]=i,mu[i]=-1,lx[i]=i;
		for(j=1;j<=len&&i*p[j]<=n;j++)
		{
			lx[i*p[j]]=p[j];
			vis[i*p[j]]=1;
			if(i%p[j]==0) break;
			mu[i*p[j]]=-mu[i];
		}
		for(j=i;j<=n;j+=i) h[j]++;
		k[i]=k[i-1]+mu[i];
		pp[i]=(i%(1ll*lx[i]*lx[i])!=0);
	}
	for(i=2;i<=n;i++) h[i]+=h[i-1];
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&A,&B,&C);
		ans=s1=s2=s3=s4=s5=s6=s7=s8=0;
		f1.work(A,h);
		f2.work(B,h);
		x=min(A,B);
		g.work(A,B,k);
		x=min(A,B);
		//循环展开
		for(i=1;i+8<=C;i+=8)
		{
			for(l=1;l<=min(A,B);l=r+1)
			{
				r=min(A/(A/l),B/(B/l));
				s1+=1ll*(C/i)*(g.calc(r,i)-g.calc(l-1,i)+mod)%mod*f1.calc(A/r,i)%mod*f2.calc(B/r,i)%mod;
				s2+=1ll*(C/(i+1))*(g.calc(r,i+1)-g.calc(l-1,i+1)+mod)%mod*f1.calc(A/r,i+1)%mod*f2.calc(B/r,i+1)%mod;
				s3+=1ll*(C/(i+2))*(g.calc(r,i+2)-g.calc(l-1,i+2)+mod)%mod*f1.calc(A/r,i+2)%mod*f2.calc(B/r,i+2)%mod;
				s4+=1ll*(C/(i+3))*(g.calc(r,i+3)-g.calc(l-1,i+3)+mod)%mod*f1.calc(A/r,i+3)%mod*f2.calc(B/r,i+3)%mod;
				s5+=1ll*(C/(i+4))*(g.calc(r,i+4)-g.calc(l-1,i+4)+mod)%mod*f1.calc(A/r,i+4)%mod*f2.calc(B/r,i+4)%mod;
				s6+=1ll*(C/(i+5))*(g.calc(r,i+5)-g.calc(l-1,i+5)+mod)%mod*f1.calc(A/r,i+5)%mod*f2.calc(B/r,i+5)%mod;
				s7+=1ll*(C/(i+6))*(g.calc(r,i+6)-g.calc(l-1,i+6)+mod)%mod*f1.calc(A/r,i+6)%mod*f2.calc(B/r,i+6)%mod;
				s8+=1ll*(C/(i+7))*(g.calc(r,i+7)-g.calc(l-1,i+7)+mod)%mod*f1.calc(A/r,i+7)%mod*f2.calc(B/r,i+7)%mod;
				s1%=mod,s2%=mod,s3%=mod,s4%=mod,s5%=mod,s6%=mod,s7%=mod,s8%=mod;
			}
		}
		for(;i<=C;i++)
		{
			for(l=1;l<=min(A,B);l=r+1)
			{
				r=min(A/(A/l),B/(B/l));
				ans+=1ll*(C/i)*(g.calc(r,i)-g.calc(l-1,i)+mod)%mod*f1.calc(A/r,i)%mod*f2.calc(B/r,i)%mod;
				ans%=mod;
			}
		}
		printf("%lld\n",(ans+s1+s2+s3+s4+s5+s6+s7+s8)%mod);
	}
}
```
然后你就发现最后几个点挂掉了。

空间太大了啊啊啊啊啊啊啊！！！

考虑再优化。

如果 $y$ 含有某个质数的平方，那么 $p$ 我们可以取该质数，那么 $f(x,y)=f(x,y/p)$

因为这样 $[p\perp y/p]=0$

所以我们可以弄一个 DFS ，来枚举每一个不含某质数的平方因子的数（也可以理解为 $\mu(x)\not=0$ 的数），不仅时间减少了，空间更是少了不少。
```cpp
#include<cstdio>
#define N 101010
#define ri register int
using namespace std;
const int mod=1e9+7;
int vis[N],p[N],mu[N],T,n,A,B,x,len;
long long g[N][12],f[N][12];
int k[N],h[N],lw[N],s[N],ans,C;
inline int min(int a,int b){return a<b?a:b;}
void dfs(ri x,ri i,ri k)
{
	ri ss=0,l,r;
	for(l=1;l<=A;l=r+1)
	{
		r=min(A/(A/l),B/(B/l));
		ss=(ss+(g[r][k]-g[l-1][k]+mod)*f[A/r][k]%mod*f[B/r][k]%mod)%mod;
	}
	ans=(ans+1ll*ss*s[x]%mod)%mod;
	for(i=i+1;1ll*p[i]*x<=C&&i<=len;i++)
	{
		for(l=1;l<=A;l=r+1)
		{
			r=min(A/(A/l),B/(B/l));
			g[r][k+1]=(g[r][k]+g[r/p[i]][k+1])%mod;
			f[A/r][k+1]=(f[A/r][k]-f[A/r/p[i]][k]+mod)%mod;
			f[B/r][k+1]=(f[B/r][k]-f[B/r/p[i]][k]+mod)%mod;
		}
		dfs(x*p[i],i,k+1);
	}
}
int main()
{
	n=N-1010;
	mu[1]=k[1]=h[1]=lw[1]=1;
	int i,j,l,r;
	for(i=2;i<=n;i++)
	{
		if(!vis[i]) p[++len]=lw[i]=i,mu[i]=-1,h[i]=2;
		for(j=1;j<=len&&i*p[j]<=n;j++)
		{
			vis[i*p[j]]=1;
			lw[i*p[j]]=lw[i]*p[j];
			h[i*p[j]]=h[i]*2;
			if(i%p[j]==0)
			{
				h[i*p[j]]-=h[i/p[j]];
				lw[i*p[j]]=lw[i];
				break;
			}
			mu[i*p[j]]=-mu[i];
		}
		k[i]=k[i-1]+mu[i];
	}
	for(i=2;i<=n;i++) h[i]+=h[i-1];
	scanf("%d",&T);
	while(T--)
	{
		ans=0;
		scanf("%d%d%d",&A,&B,&C);
		if(A>B) i=A,A=B,B=i;
		for(l=1,r;l<=A;l=r+1)
		{
			r=min(A/(A/l),B/(B/l));
			g[r][1]=k[r];
			f[A/r][1]=h[A/r];
			f[B/r][1]=h[B/r];
		}
		for(i=1;i<=C;i++) s[i]=0;
		for(i=1;i<=C;i++) s[lw[i]]+=1ll*C/i,s[lw[i]]%=mod;
		dfs(1,0,1);
		printf("%lld\n",ans);
	}
}
```
卡常卡到极致了，但你发现还是TLE了……

某大佬告诉我，如果 $a,b\in[0,p)$ ，那么可以直接自定义一个取模函数 `int Mod(int a){return a<p?a:a-p;}`

然后就 AC 了。

代码不放了（中国武功讲究点到为止）

---

## 作者：Sai0511 (赞：6)

因为不知道什么原因LateX无法在题解界面正常显示。  
建议到博客中查看。  
一道很有趣的题目。     
题目大意：求
$$\sum_{i=1}^A \sum_{j=1}^B \sum_{k=1}^C \sigma_0(ijk)$$
因为
$$\sigma_0(ijk)=\sum_{p|i}\sum_{q|j}\sum_{h|k}[\epsilon(\text{gcd}(p,q))][\epsilon(\text{gcd}(p,h))][\epsilon(\text{gcd}(q,h))]$$
所以原式=
$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{p|i}\sum_{q|j}\sum_{h|k}[\epsilon(\text{gcd}(p,q))][\epsilon(\text{gcd}(p,h))][\epsilon(\text{gcd}(q,h))]$$
交换枚举顺序，枚举因数
$$\sum_{p=1}^A\sum_{q=1}^B\sum_{h=1}^C
\lfloor \frac{A}{p} \rfloor \lfloor \frac{B}{q} \rfloor \lfloor \frac{C}{h} \rfloor [\epsilon(\text{gcd}(p,q))][\epsilon(\text{gcd}(p,h))][\epsilon(\text{gcd}(q,h))]$$
把后面那团$\text{gcd}$用$\mu$函数换掉
$$\sum_{p=1}^A\sum_{q=1}^B\sum_{h=1}^C \sum_{x|\text{gcd}(p,q)}\mu(x) \sum_{y|\text{gcd}(p,h)} \mu(y) \sum_{z|\text{gcd}(q,h)}\mu(z)$$
再换一下枚举顺序
$$\sum_{x=1}^{\text{min(A,B)}}\mu(x) \sum_{y=1}^{\text{min}(A,C)}\mu(y) \sum_{z=1}^{\text{min}(B,C)}\mu(z) \sum_{x|p \ \& \& \ y|p} \lfloor \frac{A}{p} \rfloor \sum_{x|q \ \& \& \ z|q} \lfloor \frac{B}{q} \rfloor \sum_{y | h \ \& \& z|h} \lfloor \frac{C}{h} \rfloor$$
$$\sum_{x=1}^{\text{min(A,B)}}\mu(x) \sum_{y=1}^{\text{min}(A,C)}\mu(y) \sum_{z=1}^{\text{min}(B,C)}\mu(z) \sum_{\text{lcm}(x,y)|p} \lfloor \frac{A}{p} \rfloor \sum_{\text{lcm}(x,z)|q} \lfloor \frac{B}{q} \rfloor \sum_{\text{lcm}(y,z)|h} \lfloor \frac{C}{h} \rfloor$$
然后我们发现这个式子其实不一样的地方只有两部分...  
形如$\sum \limits_{a|b}^c \lfloor \frac{c}{b} \rfloor$的那三项可以$\mathcal{O}(n \log n)$预处理出来。   
接下来才是这道题的精髓。   
在$\mathcal{O}(n^3)$枚举三元组$(x,y,z)$的同时，我们可以发现有很多时候他们的情况是$0$。   
1：$\mu(x)=0$或$\mu(y)=0$或$\mu(z)=0$。   
2：若$\sum \limits_{a|b}^c \lfloor \frac{c}{b} \rfloor$中的$a$大于$c$，则这个式子的贡献一定为$0$，也就是说当$\text{lcm}(x,y) \geq A$或$\text{lcm}(x,z) \geq B$或$\text{lcm}(y,z) \geq C$时，这个式子的贡献一定为$0$。  
于是我们就可以枚举最大公约数$g$，使得$u=i \times g,v = j \times g, \mu(u) \neq 0,\mu(v) \neq 0$并保证$i$与$j$互质且$\text{lcm}(u,v)=i \times j \times g \leq \text{max}(A,B,C)$，连边$(u,v)$，最后统计三元环的时候顺便计数就好了。   
因为$\mathsf{s{\color{red}hadowice1984}}$大佬告诉我们边数最多只有$760741$条，所以$m \sqrt m$是可过的。   
代码：  
```cpp
#include <bits/stdc++.h>

typedef long long ll;
const int N = 1e5 + 200;
const ll mod = 1e9 + 7;
typedef std::pair<int, int> pii;

int n, m, i, j, k, prim_tot, T, A, B, C, mx, mn, cnte;
ll _1[N], _2[N], _3[N];
int vis[N], deg[N];
int mu[N], prim[N]; 
bool _vis[N];
ll ans;

inline void sieve(int n) {
  mu[1] = 1;
  for (int i = 2; i <= n; i++) {
    if (!_vis[i]) prim[++prim_tot] = i, mu[i] = -1;
    for (int j = 1; j <= prim_tot && i * prim[j] <= n; j++) {
      _vis[i * prim[j]] = 1;
      if (i % prim[j] == 0) break;
      else mu[i * prim[j]] = -mu[i];
    }
  }
}

struct edge {
  int u, v, w;
  edge() { u = v = w = 0; }
  edge(int _u, int _v, int _w) {
    u = _u, v = _v, w = _w;
  }
} edges[N << 4];

std::vector<pii> G[N];

inline void init() {
  scanf("%d %d %d", &A, &B, &C), ans = 0, cnte = 0;
  mx = std::max(std::max(A, B), C);
  mn = std::min(std::min(A, B), C);
  for (int i = 1; i <= mx; i += 8) {
    _1[i] = _1[i + 1] = _1[i + 2] = _1[i + 3] = _1[i + 4] = _1[i + 5] = _1[i + 6] = _1[i + 7] = 0;
    _2[i] = _2[i + 1] = _2[i + 2] = _2[i + 3] = _2[i + 4] = _2[i + 5] = _2[i + 6] = _2[i + 7] = 0;
    _3[i] = _3[i + 1] = _3[i + 2] = _3[i + 3] = _3[i + 4] = _3[i + 5] = _3[i + 6] = _3[i + 7] = 0;
    deg[i] = deg[i + 1] = deg[i + 2] = deg[i + 3] = deg[i + 4] = deg[i + 5] = deg[i + 6] = deg[i + 7] = 0;
  }
  for (int i = 1; i <= mx; i++) G[i].clear();
  for (int i = 1; i <= A; i++) {
    for (int j = i; j <= A; j += i)
      _1[i] += A / j;
  }
  for (int i = 1; i <= B; i++) {
    for (int j = i; j <= B; j += i) 
      _2[i] += B / j;
  }
  for (int i = 1; i <= C; i++) {
    for (int j = i; j <= C; j += i)
      _3[i] += C / j;
  }
}
inline void solve() {
  for (int i = 1; i <= mn; i++) {
    if (mu[i]) ans += 1ll * mu[i] * mu[i] * mu[i] * _1[i] * _2[i] * _3[i];
  }
  for (int g = 1; g <= mx; g++) {
    for (int i = 1; i * g <= mx; i++) {
      if (!mu[i * g]) continue;
      for (int j = i + 1; 1ll * i * j * g <= mx; j++) {
        if (mu[j * g] && std::__gcd(i, j) == 1) {
          int u = i * g, v = j * g, lcm = i * j * g;
          int p = mu[u] * mu[u] * mu[v], q = mu[u] * mu[v] * mu[v];
          ans += p * (_1[u] * _2[lcm] * _3[lcm] + _1[lcm] * _2[u] * _3[lcm] + _1[lcm] * _2[lcm] * _3[u]);
          ans += q * (_1[v] * _2[lcm] * _3[lcm] + _1[lcm] * _2[v] * _3[lcm] + _1[lcm] * _2[lcm] * _3[v]);
          deg[u]++, deg[v]++;
          edges[++cnte] = edge(u, v, lcm);
        }
      }
    }
  }
  for (int i = 1; i <= cnte; i++) {
    int u = edges[i].u, v = edges[i].v, w = edges[i].w;
    if (deg[u] < deg[v] || (deg[u] == deg[v] && u > v)) std::swap(u, v);
    G[u].push_back(std::make_pair(v, w));
  }
  for (int k = 1; k <= mx; k++) {
    if (!mu[k]) continue;
    int SZ = G[k].size();
    for (int i = 0; i < SZ; i++) vis[G[k][i].first] = G[k][i].second;
    for (int i = 0; i < SZ; i++) {
      int v = G[k][i].first, w = G[k][i].second;
      if (!mu[v]) continue;
      for (int j = 0, _SZ = G[v].size(); j < _SZ; j++) {
        int vv = G[v][j].first;
        if (!vis[vv]) continue;
        int wyz = G[v][j].second, wxz = vis[vv], mmu = mu[k] * mu[v] * mu[vv];
        if (!mmu) continue;
        ans += mmu * (_1[w] * _2[wyz] * _3[wxz] + _1[w] * _2[wxz] * _3[wyz] 
                    + _1[wyz] * _2[w] * _3[wxz] + _1[wyz] * _2[wxz] * _3[w]
                    + _1[wxz] * _2[w] * _3[wyz] + _1[wxz] * _2[wyz] * _3[w]);
      }
    }
    for (int i = 0; i < SZ; i++) vis[G[k][i].first] = 0;
  }
  printf("%lld\n", ans % mod);
}

int main() {
  sieve(100000);
  scanf("%d", &T);
  while (T--) init(), solve();
  return 0;
}

```




---

## 作者：whiteqwq (赞：5)

[[SDOI2018]旧试题](https://www.luogu.com.cn/problem/P4619)解题报告：

题意：求$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C d(i\cdot j\cdot k)\bmod (10^9+7)$其中$d(x)=\sum_{w\mid x}1$即$x$的因数个数

做这道题前，请保证你已经学会莫比乌斯反演并且做出了一部分题目，否则可以到我[博珂](https://zybuluo.com/xiaoziyao/note/1687939)里康康。

我们先证明一个毒瘤式子$d(x\cdot y\cdot y)=\sum_{i\mid x}\sum_{j\mid y}\sum_{k\mid z}[\gcd(i,j,k)==1]$

当$x=\prod_{i=1}^s p_i^{k_i}$因为$d(x)=\prod_{i=1}^s(k_i+1)$为$x$的因数个数，因此考虑将$x\cdot y\cdot z$的每个因数对应一组互质的因数

对于每个质数$p\mid x\cdot y\cdot z$，且$x$中$p$的幂次为$a$，$y$中$p$的幂次为$b$，$z$中$p$的幂次为$c$，则$x\cdot y\cdot z$中$p$的幂次为$a+b+c$。

根据$d$的积性与$\gcd(p^{a+b+c},\frac{x\cdot y\cdot z}{p^{a+b+c}})==1$，得：$d(x\cdot y\cdot z)=d(\frac{x\cdot y\cdot z}{p^{a+b+c}})\cdot d(p^{a+b+c})=d(\frac{x\cdot y\cdot z}{p^{a+b+c}})\cdot(a+b+c+1)$，即$p$对左式的贡献为$a+b+c+1$

令$i\mid x,j\mid y,k\mid z$且$\gcd(i,j,k)=1$，则$i$中$p$的幂次$u$不超过$a$，$j$中$p$的幂次$v$不超过$b$，$k$中$p$的幂次$w$不超过$c$，且$u$，$v$，$w$中起码有两个为$0$

- 当$v=w=0,u\ne 0$时，$u=1,2,\cdots a$，即有$a$种取值
- 当$u=w=0,v\ne 0$时，$v=1,2,\cdots b$，即有$b$种取值
- 当$u=v=0,w\ne 0$时，$w=1,2,\cdots c$，即有$c$种取值
- 当$u=v=w=0$时，只有$1$种取值

即每个$p$可以对右式同样产生$a+b+c+1$的贡献，因此对于每个$x\cdot y\cdot z$的质因子$p$，其会对左右两式均产生$a+b+c+1$即$p$的指数$+1$的贡献

因此我们可以把原式化为：$\sum_{i=1}\sum_{j=1}^B\sum_{k=1}^C\sum_{x\mid i}\sum_{y\mid j}\sum_{z\mid k}[\gcd(x,y,z)==1]$
$=\sum_{i=1}\sum_{j=1}^B\sum_{k=1}^C\sum_{x\mid i}\sum_{y\mid j}\sum_{z\mid k}[\gcd(x,y)==1][\gcd(y,z)==1][\gcd(x,z)==1]$

改变枚举顺序可得：$\sum_{x=1}^A\lfloor\frac{A}{x}\rfloor\sum_{y=1}^B\lfloor\frac{B}{y}\rfloor\sum_{z=1}^C\lfloor\frac{C}{z}\rfloor[\gcd(x,y)==1][\gcd(y,z)==1][\gcd(x,z)==1]$

使用莫比乌斯反演得原式可得：$\sum_{x=1}^A\lfloor\frac{A}{x}\rfloor\sum_{y=1}^B\lfloor\frac{B}{y}\rfloor\sum_{z=1}^C\lfloor\frac{C}{z}\rfloor\sum_{u\mid\gcd(x,y)}\mu(u)\sum_{v\mid\gcd(y,z)}\mu(v)\sum_{w\mid\gcd(x,z)}\mu(w)$

继续交换枚举顺序得：$\sum_{u=1}^{min(A,B)}\mu(u)\sum_{v=1}^{min(B,C)}\mu(v)\sum_{w=1}^{min(A,C)}\mu(w)\sum_{i=1}^{\lfloor\frac{A}{lcm(u,v)}\rfloor}\lfloor\frac{A}{lcm(u,v)\cdot i}\rfloor\sum_{j=1}^{\lfloor\frac{B}{lcm(v,w)}\rfloor}\lfloor\frac{B}{lcm(v,w)\cdot j}\rfloor\sum_{k=1}^{\lfloor\frac{C}{lcm(u,w)}\rfloor}\lfloor\frac{C}{lcm(u,w)\cdot k}\rfloor$

由引理$\lfloor\frac{a}{b\cdot c}\rfloor=\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}\rfloor$得：$\sum_{i=1}^{\lfloor\frac{x}{y}\rfloor}\lfloor\frac{x}{y\cdot i}\rfloor=\sum_{i=1}^{\lfloor\frac{x}{y}\rfloor}\lfloor\frac{\lfloor\frac{x}{y}\rfloor}{i}\rfloor$，原式化为：$\sum_{u=1}^{min(A,B)}\mu(u)\sum_{v=1}^{min(B,C)}\mu(v)\sum_{w=1}^{min(A,C)}\mu(w)\sum_{i=1}^{\lfloor\frac{A}{lcm(u,v)}\rfloor}\lfloor\frac{\lfloor\frac{A}{lcm(u,v)}\rfloor}{i}\rfloor\sum_{j=1}^{\lfloor\frac{B}{lcm(v,w)}\rfloor}\lfloor\frac{\lfloor\frac{B}{lcm(v,w)}\rfloor}{j}\rfloor\sum_{k=1}^{\lfloor\frac{C}{lcm(u,w)}\rfloor}\lfloor\frac{\lfloor\frac{C}{lcm(u,w)}\rfloor}{k}\rfloor$

设$f(x)=\sum_{i=1}^x\lfloor\frac{x}{i}\rfloor$，考虑如何预处理$f(x)$：对于每一个$i\leqslant x$，$x$都会得到$i$的贡献$\lfloor\frac{x}{i}\rfloor$，即在$[1,x]$的范围内$i$的倍数个数。

因此$f(x)=\sigma(x)=\sum_{d\mid x}d$即约数和函数，这个函数通过可以枚举每个数的倍数在$O(n\log n)$的时间内预处理。

原式可化为：$\sum_{u=1}^{min(A,B)}\sum_{v=1}^{min(B,C)}\sum_{w=1}^{min(A,C)}\mu(u)\cdot\mu(v)\cdot\mu(w)\cdot\sigma(\frac{A}{lcm(u,v)})\cdot\sigma(\frac{B}{lcm(v,w)})\cdot\sigma(\frac{C}{lcm(u,w)})$

但是最后的式子还是$O(n^3)$的，就比暴力快一点点。

首先，我们可以把所有$\mu(x)=0$的$x$删去，这种$x$有不少，因此可以快很多。

其次，因为$\sigma(0)=0$，因此所有的$lcm(u,v)>A,lcm(v,w)>B,lcm(u,w)>C$可以剪掉。（其实不剪掉也没有关系，对答案没有影响，因此我们将$A,B,C$统一改为$max(A,B,C)$）

为了达到更低的复杂度，我们可以使用一种毒瘤算法：三元环计数。感性理解一下，枚举三个数$u,v,w$，且满足$lcm(u,v)\leqslant A,lcm(v,w)\leqslant B,lcm(u,w)\leqslant C$就相当于在一张只要任意两个点满足其最小公倍数小于等于$max(A,B,C)$边会有一条边的图中枚举三元环。

三元环计数算法可以在$O(m\sqrt{m})$的时间内求出所有三元环，具体见nekko的博客：[不常用的黑科技——「三元环」](https://www.luogu.com.cn/blog/KingSann/fou-chang-yong-di-hei-ke-ji-san-yuan-huan-post)

但是还是会TLE，因此我们要进行常数优化：

去除所有的自环，枚举三个点相同和两个点相同的情况，并用$6$种排列计算三个点都不相同的情况。

改链式前向星变vector，因为vector的内存访问是连续的，因此可以加快一点速度。

~~快读，O2优化和火车头优化~~

这样，我们就可以拿到$100pts$的好成绩！

又臭又长的代码：
```
#include<stdio.h>
#include<vector>
#include<string.h>
using namespace std;
const long long maxn=1000005,maxm=1000005,mod=1000000007;
long long i,j,k,a,b,c,e,mx,mn,T,cnt,tot,ans;
long long lst[maxn],d[maxn],p[maxn],mu[maxn],ok[maxn],ord[maxn],deg[maxn],f[maxn],from[maxm],to[maxm],lcm[maxm],mrk[maxn];
vector<long long>v[maxn],w[maxn];
inline long long min(long long a,long long b){
	return a<b? a:b;
}
inline long long max(long long a,long long b){
	return a>b? a:b;
}
inline long long gcd(long long a,long long b){
	return b==0? a:gcd(b,a%b);
}
int main(){
	p[1]=mu[1]=1;
	for(i=2;i<maxn;i++){
		if(p[i]==0)
			lst[++cnt]=i,mu[i]=-1;
		for(j=1;j<=cnt;j++){
			if(i*lst[j]>=maxn)
				break;
			p[i*lst[j]]=1;
			if(i%lst[j]==0){
				mu[i*lst[j]]=0;
				break;
			}
			mu[i*lst[j]]=-mu[i];
		}
	}
	for(i=1;i<maxn;i++)
		if(mu[i]!=0)
			ok[++tot]=i,ord[i]=tot;
	for(i=1;i<maxn;i++){
		for(j=1;i*j<maxn;j++)
			d[i*j]++;
		f[i]=(f[i-1]+d[i])%mod;
	}
	scanf("%lld",&T);
	while(T--){
		memset(deg,0,sizeof(deg));
		memset(v,0,sizeof(v));
		memset(w,0,sizeof(w));
		scanf("%lld%lld%lld",&a,&b,&c);
		mn=min(min(a,b),c),mx=max(max(a,b),c);
		e=ans=0;
		for(i=1;i<=tot;i++){
			if(ok[i]>mx)
				break;
			for(j=1;j<=tot;j++){
				if(ok[i]*ok[j]>mx)
					break;
				if(mu[ok[i]*ok[j]]==0)
					continue;
				for(k=j+1;k<=tot;k++){
					if(ok[i]*ok[j]*ok[k]>mx)
						break;
					if(mu[ok[i]*ok[k]]==0||gcd(ok[j],ok[k])>1)
						continue;
					from[++e]=ord[ok[i]*ok[j]],to[e]=ord[ok[i]*ok[k]],lcm[e]=ok[i]*ok[j]*ok[k];
					deg[from[e]]++,deg[to[e]]++;
				} 
			}
		}
		for(i=1;i<=tot;i++){
			if(ok[i]>mn)
				break;
			ans+=mu[ok[i]]*mu[ok[i]]*mu[ok[i]]*f[a/ok[i]]*f[b/ok[i]]*f[c/ok[i]];
		}
		for(i=1;i<=e;i++){
			v[from[i]].push_back(to[i]),w[from[i]].push_back(lcm[i]);
			v[to[i]].push_back(from[i]),w[to[i]].push_back(lcm[i]);
		}
		for(i=1;i<=tot;i++){
			if(ok[i]>min(a,b))
				break;
			for(j=0;j<v[i].size();j++){
				long long x=ok[i],y=ok[v[i][j]],z=w[i][j];
				ans=(ans+mu[x]*mu[y]*mu[y]*f[a/z]*f[b/z]*f[c/y]%mod+mod)%mod;
				ans=(ans+mu[x]*mu[x]*mu[y]*f[a/x]*f[b/z]*f[c/z]%mod+mod)%mod;
				ans=(ans+mu[x]*mu[x]*mu[y]*f[a/z]*f[b/x]*f[c/z]%mod+mod)%mod;
			}
		}
		memset(v,0,sizeof(v));
		memset(w,0,sizeof(w));
		for(i=1;i<=e;i++){
			if(deg[from[i]]>=deg[to[i]])
				v[from[i]].push_back(to[i]),w[from[i]].push_back(lcm[i]);
			else v[to[i]].push_back(from[i]),w[to[i]].push_back(lcm[i]);
		}
		for(i=1;i<=tot;i++){
			if(ok[i]>mx)
				break;
			for(j=0;j<v[i].size();j++)
				mrk[v[i][j]]=w[i][j];
			for(j=0;j<v[i].size();j++){
				long long x=v[i][j];
				for(k=0;k<v[x].size();k++){
					long long y=v[x][k],p=mrk[y],q=w[i][j],r=w[x][k];
					if(mrk[y]==0)
						continue;
					long long st1,st2,st3,st4,st5,st6;
					st1=f[a/p]*f[b/q]*f[c/r]%mod;
					st2=f[a/p]*f[b/r]*f[c/q]%mod;
					st3=f[a/q]*f[b/p]*f[c/r]%mod;
					st4=f[a/q]*f[b/r]*f[c/p]%mod;
					st5=f[a/r]*f[b/p]*f[c/q]%mod;
					st6=f[a/r]*f[b/q]*f[c/p]%mod;
					ans=(ans+mu[ok[i]]*mu[ok[x]]*mu[ok[y]]*(st1+st2+st3+st4+st5+st6)%mod+mod)%mod;
				}
			}
			for(j=0;j<v[i].size();j++)
				mrk[v[i][j]]=0;
		}
		printf("%lld\n",(ans+mod)%mod);
	}
	return 0;
}
```

---

## 作者：Lamorak (赞：4)

~~一道智慧的反演题~~

好像不用三元图，纯数论也能过，但跑得有点小慢

------------
### 前置芝士
> 1.莫比乌斯反演
>
> 2.整除分块
>
> 3.可以先做[P3327](https://www.luogu.com.cn/problem/P3327)

### 正题

众所周知，本题要我们求这个 
$$\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{k=1}^{C}d(ijk)\bmod(1e9+7)$$

那么对于 $d(ijk)$ 有这样浅显的性质 
$$d(ijk)=\sum_{x|i}\sum_{y|j}\sum_{z|k}{[x \bot y]}{[x\bot z]}{[y\bot z]}$$

所以求这个 
$$\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{k=1}^{C}\sum_{x|i}\sum_{y|j}\sum_{z|k}{[x \bot y]}{[x\bot z]}{[y\bot z]}$$
该枚举约树为枚举倍数 
$$\sum_{x=1}^{A}\sum_{y=1}^{B}\sum_{z=1}^{C}{\left[ \frac{A}{x} \right]\left[ \frac{B}{y} \right]\left[ \frac{C}{z} \right]}{[x \bot y]}{[x\bot z]}{[y\bot z]}$$

然后我们挑一个 $[y\bot z]$ 来反演（这里大家随意挑哪个） 
$$\sum_{x=1}^{A}{\left[ \frac{A}{x} \right]}\sum_{y=1}^{B}\sum_{z=1}^{C}\left[ \frac{B}{y} \right][y \bot x]\left[ \frac{C}{z} \right][z \bot x]\sum_{d|z,d|y}{\mu(d)}$$


$$\sum_{x=1}^{A}{\left[ \frac{A}{x} \right]}\sum^{\min(B,C)}_{d=1}{\mu(d)[d \bot x]}\sum^{\left[ \frac{B}{d} \right]}_{y=1}\sum^{\left[ \frac{C}{d} \right]}_{z=1}{\left[ \frac{B}{yd} \right][y\bot x]\left[ \frac{C}{zd} \right][z\bot x]}$$


------------
#### 以上我们走出了新手村，接下来的推导相当重要
我们令 $f(n,x)=\sum_{d=1}^{n}\left[ \frac{n}{d} \right][d \bot x]$
再令 $g(n,x)=\sum_{d=1}^{n}{\mu(d)[d \bot x]}$

$$\sum_{x=1}^{A}{\left[ \frac{A}{x} \right]}\sum_{}^{}{(g(r,x)-g(l-1,x))f(\left[ \frac{B}{d} \right],x)f(\left[ \frac{C}{d} \right],x)}$$
其中 $l$ 和 $r$ 是整除分块时的参数

接下来，我们考虑优化 $f$ 和 $g$ 的求法

重要性质：设 $x_0$ 是只考虑 $x$ 中不同素因子之后得到的数，与 $x$ 互质和与 $x_0$互质等价，因此可以只考虑无平方因子。

那么对于 $f$ 和 $g$ 我们就可以根据以上性质得到以去掉某个素因子为递推关系的递推式 
$$f(n,x)=f(\left[ \frac{n}{p} \right],x)-f(\left[ \frac{n}{p} \right],\frac{x}{p})$$
$$g(n,x)=g(n,\frac{x}{p})+g(\left[ \frac{x}{p} \right],x)$$

以上递推式其实也是数论体中的常见套路，可以用整除分块 $O(\sqrt n)$ 搞出来，我看见有 dalao 写了关于它的证明， 而且我相当懒，就不写证明了

再用上一个小深搜就可以 AC 了


------------
### 代码
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define reg register
const int N=2*1e5;
const int mod=1e9+7;
int vis[N],mul[N],d[N],saw[N],p[N],tot;
ll f[N][20],g[N][20],s[N],ans;
int T,A,B,C;

inline void ph(){
	mul[1]=1;
	d[1]=1;
	saw[1]=1;
	for(reg int i=2;i<N;i++){
		if(!vis[i]){
			p[++tot]=i;
			mul[i]=-1;
			d[i]=2;
			saw[i]=i;
		}
		for(reg int j=1;j<=tot&&p[j]*i<N;j++){
			vis[i*p[j]]=1;
			if(i%p[j]==0){
				d[i*p[j]]=(d[i]<<1)-d[i/p[j]];
				saw[i*p[j]]=saw[i];
				break;
			}
			d[i*p[j]]=d[i]<<1;
			saw[i*p[j]]=saw[i]*p[j];
			mul[i*p[j]]=-mul[i];
		}
	}
	for(reg int i=1;i<N;i++){
		d[i]+=d[i-1];
		mul[i]+=mul[i-1];
	}
//	for(int i=1;i<=100;i++){
//		printf("d--->%d mul---->%d\n",d[i],mul[i]);
//	}
}

inline void kasu(){
	g[0][1]=0;
	f[0][1]=0;
	for(reg int l=1,r;l<=A;++l){
		r=min(A/(A/l),B/(B/l));
		g[r][1]=mul[r];
		f[A/l][1]=d[A/l];
		f[B/l][1]=d[B/l];
		l=r;
	}
	memset(s,0,sizeof(s));
	for(reg int i=1;i<=C;i++){
		s[saw[i]]+=C/i;
	}
}

inline void reset(int x,int k){
	for(reg int l=1,r;l<=A;++l){
		r=min(A/(A/l),B/(B/l));
		g[r][k]=g[r][k-1]+g[r/x][k];
		f[A/l][k]=f[A/l][k-1]-f[(A/l)/x][k-1];
		f[B/l][k]=f[B/l][k-1]-f[(B/l)/x][k-1];
		l=r;
	}
}
inline void dfs(int re,int x,int k){
    ll res=0;
    for(reg int l=1,r;l<=A;++l){
        r=min(A/(A/l),B/(B/l));
        res+=((g[r][k]-g[l-1][k])*f[A/l][k]*f[B/l][k])%mod;
        res=(res%mod+mod)%mod;
        l=r;
    }
    ans+=(s[re]*res)%mod;
    ans%=mod;
    for(reg int i=x;1ll*p[i]*re<=C;i++){
    	reset(p[i],k+1);
		dfs(re*p[i],i+1,k+1);
	}
	return ;
}

int main(){
	ios::sync_with_stdio(false);
	cin>>T;
	ph();
	while(T--){
		ans=0;
		cin>>A>>B>>C;
		if(A>B) swap(A,B);
		kasu();
		dfs(1,1,1);
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：huangzirui (赞：4)

如果 $\LaTeX$ 崩了就请到 [myblog](https://www.luogu.com.cn/blog/My-luoguBuoke-HZR/solution-p4619) 查看吧QAQ

题意：

求

$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^Cd(ijk) \mod (10^9+7)$$

其中，$d(x)=\sum\limits_{p|x}1$ ，即能整除 $x$ 的数的数目。

---

结论： 

$d(ijk)=\sum\limits_{d|i}\sum\limits_{t|j}\sum\limits_{p|k}[d \perp t][d \perp p][t \perp p]$

其中 $a \perp b$ 相当于 $a$ 和 $b$ 互质。

(这个结论还有许多扩展，比如  $d(ij)=\sum\limits_{d|i}\sum\limits_{t|j}[d \perp t]$ )

那么原式可以转化成：

$$
\sum_{i=1}^A
\sum_{j=1}^B
\sum_{k=1}^C
\sum_{d|i}
\sum_{t|j}
\sum_{p|k}
[d \perp t][d \perp p][t \perp p]
$$

$$
\sum_{i=1}^A
\sum_{j=1}^B
\sum_{k=1}^C
\sum_{d|i}
\sum_{t|j}
\sum_{p|k}
[\gcd(d,t)=1][\gcd(d,p)=1][\gcd(t,p)=1]
$$

然后给 $\sum\limits_{i=1}^A\sum\limits_{d|i}$ 这种东西凑到一起：

$$
\sum_{i=1}^A
\sum_{d|i}
\sum_{j=1}^B
\sum_{t|j}
\sum_{k=1}^C
\sum_{p|k}
[\gcd(d,t)=1][\gcd(d,p)=1][\gcd(t,p)=1]
$$

然后凑到一起的这个式子非常熟悉。。它可以被转化成 $\sum\limits_{d=1}^A\sum\limits_{i=1}^{\left\lfloor{\frac{A}{d}}\right\rfloor}$ 的形式。

$$
\sum\limits_{d=1}^A
\sum\limits_{i=1}^{\left\lfloor{\frac{A}{d}}\right\rfloor}
\sum\limits_{t=1}^B
\sum\limits_{j=1}^{\left\lfloor{\frac{B}{t}}\right\rfloor}
\sum\limits_{p=1}^C
\sum\limits_{k=1}^{\left\lfloor{\frac{C}{p}}\right\rfloor}
[\gcd(d,t)=1][\gcd(d,p)=1][\gcd(t,p)=1]
$$

然后我们就消掉三个 $\sum$ 了 QwQ

$$
\sum\limits_{d=1}^A
\sum\limits_{t=1}^B
\sum\limits_{p=1}^C
[\gcd(d,t)=1][\gcd(d,p)=1][\gcd(t,p)=1]
{\left\lfloor{\frac{A}{d}}\right\rfloor}
{\left\lfloor{\frac{B}{t}}\right\rfloor}
{\left\lfloor{\frac{C}{p}}\right\rfloor}
$$

那么就可以反演了：

$$
\sum_{d=1}^A
\sum_{t=1}^B
\sum_{p=1}^C
{\left\lfloor{\frac{A}{d}}\right\rfloor}
{\left\lfloor{\frac{B}{t}}\right\rfloor}
{\left\lfloor{\frac{C}{p}}\right\rfloor}
\sum_{a|d,t}\mu(a)
\sum_{b|d,p}\mu(b)
\sum_{c|t,p}\mu(c)
$$

根据一贯套路，改变枚举顺序先枚举 $a,b,c$ ：

$$
\sum_{a=1}^{\min(A,B)}
\sum_{b=1}^{\min(A,C)}
\sum_{c=1}^{\min(B,C)}
\mu(a)\mu(b)\mu(c)
\sum_{a,b|d}{\left\lfloor{\frac{A}{d}}\right\rfloor}
\sum_{a,c|t}{\left\lfloor{\frac{B}{t}}\right\rfloor}
\sum_{b,c|p}{\left\lfloor{\frac{C}{p}}\right\rfloor}
$$

然后发现 $x,y|z \Leftrightarrow \text{lcm}(x,y)|z$ 那么

$$
\sum_{a=1}^{\min(A,B)}
\sum_{b=1}^{\min(A,C)}
\sum_{c=1}^{\min(B,C)}
\mu(a)\mu(b)\mu(c)
\sum_{\text{lcm}(a,b)|d}{\left\lfloor{\frac{A}{d}}\right\rfloor}
\sum_{\text{lcm}(a,c)|t}{\left\lfloor{\frac{B}{t}}\right\rfloor}
\sum_{\text{lcm}(b,c)|p}{\left\lfloor{\frac{C}{p}}\right\rfloor}
$$

对于后面那一大坨(?)，比如 $
\sum\limits_{\text{lcm}(a,b)|d}{\left\lfloor{\frac{A}{d}}\right\rfloor}$ 可以 $O(n\log n)$ 预处理。

现在问题是怎么处理前面这个东西。

假如直接枚举复杂度达到 $n^3$ 肯定过不了。。

再次观察式子 $\sum\limits_{\text{lcm}(a,b)|d}{\left\lfloor{\frac{A}{d}}\right\rfloor}$ ，有：若 $\text{lcm}(a,b)>A$ 那么这个式子肯定是 $0$ 。

于是考虑建一张图，然后对所有二元组 $(x,y)$ 若 $\text{lcm}(x,y)\leq \max(A,B,C)$ 就给它们连一条边。

然后三元环计数即可。 复杂度 $O(m\sqrt m)$ ，其中 $m$ 是边数。可以证明 $m$ 非常小。

注意直接用三元环计数算出的 $(a,b,c)$ 是无序的。

另外注意加上 $(a,a,*)$ 和 $(a,a,a)$ 的情况。

此题（十分）卡常。

这种题我感觉考场完全想不出来吧。。太毒瘤了（其实是我太菜

```cpp
#include<bits/stdc++.h>
#define ll long long
#define P pair<ll,ll>
using namespace std;
const int N=100010,mod=1000000007;
int i,j,k,n,m,T;
int prime[N],is_prime[N],num,mu[N];
vector<int>V[N];
int A,B,C,Max;
void init(){
    for(ll i=2;i<N;i++)is_prime[i]=1;
    mu[1]=1;
    for(ll i=2;i<N;i++){
        if(is_prime[i])prime[++num]=i,mu[i]=-1;
        for(ll j=1;j<=num && i*prime[j]<N;j++){
            is_prime[i*prime[j]]=0;
            if(i%prime[j]==0)break;
            mu[i*prime[j]]=-mu[i];
        }
    }
    for(ll i=1;i<N;i++)
        for(ll j=1;prime[j]*i<N && j<=num;j++)
        	V[i*prime[j]].push_back(prime[j]);
}
struct Edge{int x,y,Lcm;}E[35*N];ll len;
ll Du[N],Sum1[N],Sum2[N],Sum3[N];
void work(){
    for(int i=1;i<N;i++){
        Sum1[i]=Sum2[i]=Sum3[i]=0;
		for(int j=i;j<N;j+=i){ 
            Sum1[i]+=A/j;Sum2[i]+=B/j;Sum3[i]+=C/j;
            Sum1[i]%=mod;Sum2[i]%=mod;Sum3[i]%=mod;
        }
	}
    for(int i=1;i<=Max;i++){
    	if(!mu[i])continue;
        int Len=V[i].size();
        for(int j=0;j<(1<<Len);j++){
            int X=1,now=j;for(int k=0;k<Len;k++,now>>=1)if(now&1)X*=V[i][k];
            for(int k=j;;k=(k-1)&j){
                int Gcd=1,Now=k;
                for(int h=0;h<Len;h++,Now>>=1)if(Now&1)Gcd*=V[i][h];
                int Y=(ll)i*Gcd/X;
                if(X<Y){
	                E[++len]=(Edge){X,Y,i};
	                Du[X]++;Du[Y]++;
				}
				if(!k)break;
            }
        }
    }
}
struct edge{
    int next,to,Lcm;
}a[N*35];
int head[N],Len;
inline void add(int x,int y,int z){
    a[++Len]=(edge){head[x],y,z};
    head[x]=Len;
//    cout<<"add : x="<<x<<" y="<<y<<endl;
}
int Vis[N];
inline int check(int a,int b,int c,int X,int Y,int Z){
    return mu[a]*mu[b]*mu[c]*(Sum1[X]*Sum2[Y]%mod*Sum3[Z])%mod;
}
int main(){
    cin>>T;
    init();
    while(T--){
        Len=len=0;
        memset(head,0,sizeof(head));
        cin>>A>>B>>C;
        Max=max(max(A,B),C);
        work();
        for(i=1;i<=len;i++){
            if(Du[E[i].x]>=Du[E[i].y])add(E[i].x,E[i].y,E[i].Lcm);
            else add(E[i].y,E[i].x,E[i].Lcm);
        }
        register ll ans=0;
        for(i=1;i<=Max;i++){
            for(j=head[i];j;j=a[j].next){
                int u=a[j].to;
                Vis[u]=a[j].Lcm;
            }
            for(j=head[i];j;j=a[j].next){
                int u=a[j].to,Lcm=a[j].Lcm;
                for(k=head[u];k;k=a[k].next)
                    if(Vis[a[k].to]){
                    	int A=i,B=u,C=a[k].to,A_B=Lcm,A_C=Vis[a[k].to],B_C=a[k].Lcm;
                        ans+=(
							(ll)check(A,B,C,A_B,A_C,B_C)+check(A,C,B,A_C,A_B,B_C)+
							check(B,A,C,A_B,B_C,A_C)+check(B,C,A,B_C,A_B,A_C)+
							check(C,A,B,A_C,B_C,A_B)+check(C,B,A,B_C,A_C,A_B)
							)%mod;
						ans%=mod;
					}
            }
            for(j=head[i];j;j=a[j].next){
                int u=a[j].to;
                Vis[u]=0;
            }
        }
        
		for(i=1;i<=Max;i++){
			if(!mu[i])continue;
			for(j=head[i];j;j=a[j].next){
				int u=a[j].to;
				ans+=((ll)check(i,i,u,i,a[j].Lcm,a[j].Lcm)+check(i,u,i,a[j].Lcm,i,a[j].Lcm)+check(u,i,i,a[j].Lcm,a[j].Lcm,i)+
					  check(i,u,u,a[j].Lcm,a[j].Lcm,u)+check(u,u,i,u,a[j].Lcm,a[j].Lcm)+check(u,i,u,a[j].Lcm,u,a[j].Lcm))%mod;
				ans%=mod;
			}
		}
		
		
		for(i=1;i<=Max;i++){
			if(!mu[i])continue;
			ans+=check(i,i,i,i,i,i);
			ans%=mod;
		}
		
		cout<<(ans+mod)%mod<<endl;
    }return 0;
}
```

---

## 作者：chihik (赞：2)

$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^Cd(ijk)$$

$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{x|i}\sum_{y|j}\sum_{z|k}[(x,y)=1][(y,z)=1][(x,z)=1]$$

$$\sum_{x=1}^A\sum_{y=1}^B\sum_{z=1}^C \lfloor \frac{A}{x} \rfloor \lfloor \frac{B}{y} \rfloor \lfloor \frac{C}{z} \rfloor [(x,y)=1][(y,z)=1][(x,z)=1]$$

$$\sum_{x=1}^A\sum_{y=1}^B\sum_{z=1}^C \lfloor \frac{A}{x} \rfloor \lfloor \frac{B}{y} \rfloor \lfloor \frac{C}{z} \rfloor \sum_{d_1|(x,y)}\mu(d_1)\sum_{d_2|(y,z)}\mu(d_2)\sum_{d_3|(x,z)}\mu(d_3)$$

$$\sum_{d_1=1}^{min(A,B)}\sum_{d_2=1}^{min(B,C)}\sum_{d_3=1}^{min(A,C)} \mu(d_1)\mu(d_2)\mu(d_3) \sum_{[d_1,d_3]|x} \lfloor \frac{A}{x} \rfloor \sum_{[d_1,d_2)]|y} \lfloor \frac{B}{y} \rfloor \sum_{[d_2,d_3]|z} \lfloor \frac{C}{z} \rfloor $$

令 $f(n,A)=\sum_{n|d} \lfloor \frac{A}{d} \rfloor$ , 可以 $\Theta(n \ln n)$ 预处理 $f(n,A/B/C)$

$$\sum_{d_1=1}^{min(A,B)}\sum_{d_2=1}^{min(B,C)}\sum_{d_3=1}^{min(A,C)} \mu(d_1)\mu(d_2)\mu(d_3) f([d_1,d_3],A) f([d_1,d_2],B) f([d_2,d_3],C)$$

注意到当 $[d_1,d_3]>A~,~[d_1,d_2]>B~,~[d_2,d_3]>C$ 时函数值为0 ， $\mu$ 的大部分值为 $0$，所以有贡献的情况不多。

对于 $(u,v)$，当 $\mu(u)\not=0, \mu(v)\not=0$ 且 $[u,v] \le \max \{A,B,C\}$ 时连边。

$u,v$ 可以枚举最大公因数 $d$ 后枚举倍数 $i,j$ ， 但要保证 $(i,j)=1$。

这样图上的三元环便对应着每一种有贡献的情况。

最后特殊统计一下三个点相等和两个点相等的情况。

```cpp
#include <cstdio>
#include <vector>
#include <iostream>
using namespace std;

const int Mod = 1e9 + 7 , MAXN = 1e5;
int t , A , B , C , n , m;
int cnt , vt[ MAXN + 5 ] , Deg[ MAXN + 5 ];
struct node {
	int u , v , w;
}E[ 8 * MAXN + 5 ];
struct Edge {
	int v , w; 
};
vector< Edge > Graph[ MAXN + 5 ];
int k , prime[ MAXN + 5 ] , mu[ MAXN + 5 ] , f[ 3 ][ MAXN + 5 ];
bool vis[ MAXN + 5 ];

void Init( ) {
	mu[ 1 ] = 1;
	for( int i = 2 ; i <= n ; i ++ ) {
		if( !vis[ i ] ) {
			prime[ ++ k ] = i;
			mu[ i ] = -1;
		}
		for( int j = 1 ; j <= k && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) break;
			mu[ i * prime[ j ] ] = -mu[ i ];
		}
	}
	for( int i = 1 ; i <= n ; i ++ ) {
		f[ 0 ][ i ] = f[ 1 ][ i ] = f[ 2 ][ i ] = 0;
		for( int j = i ; j <= n ; j += i ) {
			f[ 0 ][ i ] = ( f[ 0 ][ i ] + A / j ) % Mod;
			f[ 1 ][ i ] = ( f[ 1 ][ i ] + B / j ) % Mod;
			f[ 2 ][ i ] = ( f[ 2 ][ i ] + C / j ) % Mod; 
		}
	}
}

int chk( long long x ) {
	return ( x % Mod + Mod ) % Mod;
}
int Calc( int u , int v , int w ) {
	return chk( 1ll * f[ 0 ][ u ] * f[ 1 ][ v ] % Mod * f[ 2 ][ w ] % Mod );
}
int Gcd( int a , int b ) {
	return !b ? a : Gcd( b , a % b );
}
int Solve( ) {
	int Ans = 0;
	
	for( int i = 1 ; i <= m ; i ++ )
		Ans = ( Ans + chk( mu[ i ] * mu[ i ] * mu[ i ] * Calc( i , i , i ) ) ) % Mod;
	
	cnt = 0;
	for( int i = 1 ; i <= n ; i ++ ) Deg[ i ] = 0; 
	for( int d = 1 ; d <= n ; d ++ )
		for( int i = 1 ; i <= n / d ; i ++ )
			for( int j = i + 1 ; j <= n / i / d ; j ++ ) {
				int u = i * d , v = j * d , l = i * j * d;
				if( Gcd( i , j ) != 1 || !mu[ u ] || !mu[ v ] ) continue;
				Ans = ( Ans + chk( mu[ u ] * mu[ u ] * mu[ v ] * chk( 1ll * Calc( u , l , l ) + Calc( l , u , l ) + Calc( l , l , u ) ) ) ) % Mod;
				Ans = ( Ans + chk( mu[ u ] * mu[ v ] * mu[ v ] * chk( 1ll * Calc( v , l , l ) + Calc( l , v , l ) + Calc( l , l , v ) ) ) ) % Mod;
				E[ ++ cnt ] = { u , v , l };
			}
	
	for( int i = 1 ; i <= n ; i ++ ) Graph[ i ].clear( );
	for( int i = cnt , u , v , w ; i >= 1 ; i -- ) {
		u = E[ i ].u , v = E[ i ].v , w = E[ i ].w;
		if( Deg[ u ] < Deg[ v ] || ( Deg[ u ] == Deg[ v ] && u < v ) )
			Graph[ u ].push_back( { v , w } );
		else
			Graph[ v ].push_back( { u , w } );
	}
	for( int u = 0 ; u <= n ; u ++ ) {
		if( !mu[ u ] ) continue;
		for( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) vt[ Graph[ u ][ i ].v ] = Graph[ u ][ i ].w;
		for( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {
			int v = Graph[ u ][ i ].v , uw = Graph[ u ][ i ].w;
			if( !mu[ v ] ) continue;
			for( int j = 0 ; j < Graph[ v ].size( ) ; j ++ ) {
				int w = Graph[ v ][ j ].v , vw = Graph[ v ][ j ].w;
				if( !mu[ w ] ) continue;
				if( vt[ w ] ) {
					int ww = vt[ w ];
					Ans = ( Ans + chk( mu[ u ] * mu[ v ] * mu[ w ] * chk( 1ll * Calc( uw , vw , ww ) + Calc( uw , ww , vw ) + Calc( vw , uw , ww ) + Calc( vw , ww , uw ) + Calc( ww , uw , vw ) + Calc( ww , vw , uw ) ) ) ) % Mod;
				}
			}
		}
		for( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) vt[ Graph[ u ][ i ].v ] = 0;
	}
	return Ans;
}

int main( ) {
	scanf("%d", &t );
	while( t -- ) {
		scanf("%d %d %d", &A , &B , &C );
		n = max( A , max( B , C ) );
		m = min( A , min( B , C ) );
		Init( );
		printf("%d\n", Solve( ) );			
	} 
	return 0;
} 
```


---


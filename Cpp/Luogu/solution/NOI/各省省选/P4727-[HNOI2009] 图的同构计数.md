# [HNOI2009] 图的同构计数

## 题目背景

当学生们遇到某个难题时经常会说“这怎么做，这不是 NP 问题吗？”、“这个只有搜了，这己经被证明是 NP 问题了”。但是，你应该清楚，大多数人此时所说的 NP 问题其实都是指 NPC 问题。很多人没有真正掌握 NP 问题和 NPC 问题这两个基本概念。其实 NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。

很久以前就有一个古老的传说：有―个著名的问题，即 P 是否等于 NP 的问题，传说中谁要是证明或者证伪了这个命题，他将获得幸福。这里 P 是指能在多项式时间里求解的问题的集合。而 NP 是指可在多项式时间里验证的问题的集合。显然 P 是 NP 的子集，因为能在多项式时间里求解的问题，必定可在多项式时间里验证。

到目前为止还没有人因这个命题得到幸福。但是，有一个总的趋势，也就是人们普遍认为，$P=NP$ 不成立，即，多数人相信，至少存在一个不可能有多项式时间复杂度的求解算法的 NP 问题。人们如此坚信 $P \neq NP$ 是有原因的，因为在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也就是所谓的 NPC 问题。正是因为存在 NPC 问题，才使人们相信 $P \neq NP$。

在提出 NPC 的概念之后，绝大多数“自然”的难题最后都被证明是 NPC 问题，只有三个例外，它们分别是：

- 线性规划问题；
- 图同构问题；
- 素数判定问题与大数分解问题。

## 题目描述

小雪在了解到以上情况后，自认为直接挑战终极难题还有不少困难，于是决定先从简单的问题做起，具体来说，他对图同构问题产生了浓厚的兴趣。$A$ 图与 $B$ 图被认为是同构的是指：$A$ 图的顶点经过一定的重新标号以后，$A$ 图的顶点集和边集要完全与 $B$ 图一一对应。

小雪现在专注于如何判断两个图是否同构，同时他还想知道两两互不同构的含 $N$ 个点的图有多少种。众所周知含 $N$ 个点的简单图最多有 $N\times(N-1)/2$ 条边，这样含 $N$ 个点的图有 $2^{N\times(N-1)/2}$ 种可能的情况。显然这些图中有很多图是同构的，小雪想知道的便是：若同构的图算成一种，则有多少种不同的图。他把这个任务丢给了你，在他想出来之前快点解决吧！

## 说明/提示

对于 $40 \%$ 的数据，$N \le 20$。  
对于 $100 \%$ 的数据，$0 \le N \le 60$。

## 样例 #1

### 输入

```
1```

### 输出

```
1```

## 样例 #2

### 输入

```
2```

### 输出

```
2```

## 样例 #3

### 输入

```
3```

### 输出

```
4```

## 样例 #4

### 输入

```
5```

### 输出

```
34```

## 样例 #5

### 输入

```
9```

### 输出

```
493```

# 题解

## 作者：pythoner713 (赞：89)

转自我在知乎上写的文章，可以看一看呀：[https://zhuanlan.zhihu.com/p/347566986](https://zhuanlan.zhihu.com/p/347566986)

---

$$\,$$
$$\Large{1,2,4,11,34,156,1044\cdots}$$
$$\,$$

$\color{red}{\sf Part. 1}$

在欣赏一个有趣的数列前，我们需要引入一个图论概念：**同构**。

$A,B$ 两图同构的意思是：$A$ 图的顶点可以经过一定的重新标号，使得它的点集和边集与 $B$ 相同。
例如，以下两个图是同构的：

![](https://pic3.zhimg.com/v2-bbb9c60577330c5fe70e6c3e7d980f26_b.png)

因为如果将左图的 (3,4) 两点交换，两图的点集和边集是相等的。

再如，对于有 $4$ 个顶点的简单无向图，共有 $11$ 种互不同构的图：

![](https://pic1.zhimg.com/v2-6049c5b820fd42eef9ed535ab2489c4c_b.png)

#### 现在问题来了： $n$ 个顶点组成的简单无向图中，有多少种图互不同构？

这个问题的答案便是文章开头的数列——[A000088](https://oeis.org/A000088)。

$$\,$$
$\color{red}{\sf Part.2}$

为了解决这个问题，我们需要求助于数学的另一领域：群论。

将图的顶点重新标号，就相当于对点集进行置换，所有的标号方式便构成了一个置换群 $G$ 。我们要求的即是在 $G$ 作用下本质不同的图的个数。对于有 $n$ 个顶点的图，所有的标号方式便是顶点的全排列，即 $|G|=n!$ 。

现在隆重请出 ${\rm Burnside}$ 引理：

$$|X/G|=\frac{1}{|G|}\sum_{g\in G}|X^g|$$

$|X/G|$ ：集合 $X$ 在群 $G$ 作用下的轨道数（或本质不同元素数）

$|X^g|$ ：在变换 $g$ 下，$X$ 集合中的不动点数

这个定理对解决计数问题有重要作用，举个例子：

![维基百科](https://pic2.zhimg.com/v2-6d3461b4db0bc4299c4268fbd86f42e5_b.png)

在本题中，$X$ 即为 $n$ 个顶点可以构成的 $2^{n(n-1)/2}$ 个简单无向图的集合，$|X/G|$ 即为所求。难点在于怎么求 $|X^g|$，**即对于某个点集置换 $g$ 而言，有多少张图在经历变换 $g$ 后依然和原来的图相同**？

$$\,$$
$\color{red}{\sf Part.3}$

好了，让我们随机抽取一名幸运置换 $g$ 进行研究，看看有多少张图在经历 $g$ 后纹丝不动。

若隐若现的边太麻烦啦！不妨假设所有边都已存在，现在在我们面前的是一个 $n$ 个节点的完全图，然后我们需要给边们染色，染成存在或不存在两种颜色，从而得到 $X$ 中所有的图。

![](https://pic4.zhimg.com/v2-b0053228b459fddf2a43210f21fdf45b_b.png)

如何判断染成什么样子可以使得它成为置换 $g$ 中的不动点呢？

注意到有些边是**等价**的，**等价的边一定要染成同一个颜色，要么同时存在，要么同时不存在**。

>例如一个三个顶点的三角形，如果置换 $g$ 的作用是将三个顶点顺时针轮换，那么这三条边是等价的（同属一个等价类），要么同时存在（形成一个完整的三角形），要么同时不存在（形成三个孤立的顶点）。不可能出现有两条边存在，一条边不存在的情况，否则经过一次旋转，缺口便到了另外两个点间，与原来的图就不同了。注意到此时三边同属 $1$ 个等价类，每个等价类要么染要么不染，因此在此置换 $g$ 下有 $2^1=2$ 个不动点。

>还是这个三角形，这回置换 $g$ 变为交换两个点，另一个点不动。那么两个动点间的边单独属于一个等价类，另外两条边属于另一等价类，一共有 $2$ 个等价类。每个等价类要么染要么不染，因此再此置换 $g$ 下有 $2^2=4$ 个不动点。

换句话说，对于置换 $g$ 如果存在 $k$ 个边的等价类，那么 $X$ 中就有 $2^k$ 个不动点。即：

$$|X^g|=2^k$$

$$\,$$
$\color{red}{\sf Part.4}$

好啦，接下来的问题就是求 $k$ ——置换 $g$ 下边的等价类个数。这部分是关键，而且有些绕，我们分两步走：

#### 第一步，我们要将 $g$ 拆分为若干个不相交的循环置换。

这是什么意思呢？举个例子， $g$ 可以把点 $\{1,2,3,4,5,6\}$ 置换成 $\{2,3,1,5,4,6\}$ ，可以记作： $g= \begin{pmatrix}  1 & 2 & 3 & 4 & 5 & 6\\  2 & 3 & 1 & 5 & 4 & 6 \end{pmatrix}$ 。注意到这个置换可以分解成几个不相交的部分，其中每个部分都是一个循环：

$$
\begin{pmatrix}  1 & 2 & 3 & 4 & 5 & 6\\  2 & 3 & 1 & 5 & 4 & 6 \end{pmatrix}=\begin{pmatrix}  1 & 2 & 3\\  2 & 3 & 1 \end{pmatrix} \circ \begin{pmatrix}  4 & 5\\  5 & 4 \end{pmatrix} \circ \begin{pmatrix}  6\\ 6 \end{pmatrix}
$$

现在将我们当前研究的置换 $g$ 拆成 $K$ 个循环，长度分别为 $b_1,b_2,\cdots,b_K$ 。

#### 第二步，将边按照端点分成两类

1._端点同时存在于同一循环内的边_。设循环长度为 $b$ ，则次循环共有 $\left \lfloor \frac{b}{2} \right \rfloor$  个等价类。例如对于长度为 $6$ 的循环置换 $\begin{pmatrix}  1 & 2 & 3 & 4 & 5 & 6\\  2 & 3 & 4 & 5 & 6 & 1 \end{pmatrix}$ ，我们把这 $6$ 个点排成正六边形：

![](https://pic3.zhimg.com/v2-f596d56c7d6b70c876da8549b0e418ae_b.png)

（颜色相同的边同属于一个等价类）

不难发现两条边等价当且仅当它们长度相等，等价的边必须同时染/不染，否则会导致图案不具有旋转对称性，经过循环置换后也必定与原图不同。而正 b 边形中，共有 $\left \lfloor \frac{b}{2} \right \rfloor$  种长度不同的线段，也就是对应 $\left \lfloor \frac{b}{2} \right \rfloor$ 个边的等价类。得证。

因此这一类边一共贡献了 $\sum_{i=1}^K\left \lfloor \frac{b_i}{2} \right \rfloor$  个等价类。

2._端点存在于不同循环内的边_ 。例如 $\begin{pmatrix}  1 & 2 & 3\\  2 & 3 & 1 \end{pmatrix} \circ \begin{pmatrix}  4 & 5\\  5 & 4 \end{pmatrix} \circ \begin{pmatrix}  6\\ 6 \end{pmatrix}$ ，则连接 $3,4$ 的边不在同一循环内。这时，设两个循环的长度分别为 $b_1,b_2$ ，那么两个循环间共有 $b_1b_2$ 条这样的边。

![](https://pic2.zhimg.com/v2-3093b059a2542dd991dedfe20a38ecbd_b.png)

（如上图，循环 $(1,2,3)$ 与 $(4,5)$ 间共有 $6$ 条边，但同属于 $\gcd(2,3)=1$ 个等价类）

每条边经过 ${\rm lcm}(b_1,b_2)$ 次循环后会回归原位，所以每个等价类大小为 ${\rm lcm}(b_1,b_2)$ 。也就是说，一共有 $\frac{b_1b_2}{{\rm lcm}(b_1,b_2)}=\gcd(b_1,b_2)$ 个等价类。别忘了，这只是 $g$ 内其中两个循环产生的贡献，要把每对循环的贡献累加起来，也就是： $\sum_{i=1}^K\sum_{j=1}^{i-1}\gcd(b_i,b_j)$ 个等价类。

至此两种情况已经分类讨论完毕，边的等价类个数就等于两种情况数量之和：

$$k=\sum_{i=1}^K\left \lfloor \frac{b_i}{2} \right \rfloor +\sum_{i=1}^K\sum_{j=1}^{i-1}\gcd(b_i,b_j)$$

$$|X/G|=\frac{1}{|G|}\sum_{g\in G}2^k$$

是不是感觉离成功不远了呢（

$$\,$$
$\color{red}{\sf Part.5}$

其实到了这里，我们已经找到计算文章开头数列的方法了。但是，别忘了 $|G|=n!$ ，枚举每一个置换 $g$ ，时间复杂度少说也得 $O(n!)$ 。我们是否以优化一下计算方法呢？

注意到有许多置换会被重复计算，如下面两个置换：

$$\begin{pmatrix}  1 & 2 & 3\\  2 & 3 & 1 \end{pmatrix} \circ \begin{pmatrix}  4 & 5\\  5 & 4 \end{pmatrix} \circ \begin{pmatrix}  6\\ 6 \end{pmatrix}\qquad\begin{pmatrix} 1 \\ 1 \end{pmatrix} \circ  \begin{pmatrix}  2 & 3\\  3 & 2 \end{pmatrix} \circ  \begin{pmatrix}  4 & 5 & 6\\  6 & 4 & 5 \end{pmatrix}$$

它们间没有本质上的区别，对应的 $k$ 值都相等（因为 $b$ 都是 $1,2,3$ ），本可以统一计算。

一般地，如果两个置换的循环长度排序后一一相等，那么两者对答案的贡献 $2^k$ 是相等的。因此，与其枚举每一种置换再拆分，不如枚举 $n$ 的拆分代表**一类置换**，再统一计算贡献。
例如 $n=5$ 时，它的拆分有 $(1,1,1,1,1),(1,1,1,2),(1,1,3),(1,2,2),(1,4),(2,3),(5)$ ，其中 $(1,2,2)$ 统一代表了形如

$$\begin{pmatrix} * \\ * \end{pmatrix} \circ  \begin{pmatrix}  * & *\\  * & * \end{pmatrix} \circ  \begin{pmatrix}  * & *\\  * & * \end{pmatrix}$$

的置换。也就是循环长度 $b=\{1,2,2\}$ 的置换。

那么对于某个拆分，如何计算有多少对应的置换呢？

首先 $1\sim n$ 随便放一共有 $n!$ 种方案，但长度为 $b$ 的循环会贡献 $b!$ 倍重复方案。所以单是分配每个元素在哪个循环中就有 $\frac{n!}{\prod(b_i!)}$ 种方案。

接着是循环的内部分配，也就是 $b_i$ 个元素的圆排列，有 $\prod(b_i-1)!$ 种方案。

但事实上，对于长度相等的循环它们之间可以彼此交换，本质上是一样的，因此还是会算重。设 $c$ 表示表某个长度的循环的个数，则会算重 $c!$ 倍。因此答案还需除以 $\prod(c_i!)$ 。

结合上述三项，可以得到，拆分 $b_i$ 所对应的置换个数为：

$$\frac{n!}{\prod(b_i)\prod(c_i!)}$$

用这个式子改进之前的 n! 枚举算法，可以得到：

$$|X/G|=\frac{1}{|G|}\sum_b \frac{n!}{\prod(b_i)\prod(c_i!)} 2^k$$ 

$|G|=n!$ ，里外两项正好抵消，得到最终的形式：

$$\,$$
$$\large{|X/G|=\sum_b \frac{2^k}{\prod(b_i)\prod(c_i!)}}$$

$$\large{k=\sum_{i=1}^K\left \lfloor \frac{b_i}{2} \right \rfloor +\sum_{i=1}^K\sum_{j=1}^{i-1}\gcd(b_i,b_j)}$$
$$\,$$

**大功告成。**

最后再提一下时间复杂度。DFS枚举 $n$ 的拆分 $b$ ，再 $O(K^2)$ 求 $k$ 。增长速度是 [A000041](http://oeis.org/A000041)，[A296010](https://oeis.org/A296010) 的乘积。前者增速是 $O\left (\frac{e^{\sqrt{n}}}{n}\right )$，后者不知道。估计总复杂度大概在 $O(10^{\sqrt{x}})$ 左右。

$$\,$$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int ans, n, p = 997, b[70], jc[70], jd[70];

int gcd(int a, int b){
	return !b ? a : gcd(b, a % b);
}

int qpow(int A, int B){
	int C = 1;
	while(B){
		if(B & 1) C = C * A % p;
		A = A * A % p, B >>= 1;
	}
	return C;
}

void init(){
	jc[0] = 1;
	for(int i = 1; i < 70; i++){
		jc[i] = i * jc[i - 1] % p;
	}
	// 预处理阶乘
}

void work(int len){
	int u = 0, v = 1;
	for(int i = 1; i <= len; i++){
		u += b[i] >> 1;
		for(int j = 1; j < i; j++){
			u += gcd(b[i], b[j]);
		}
		// 计算边的等价类个数，u 即题解的 k
	}
	for(int i = 1; i <= len; i++){
		v = v * b[i] % p;
	}
	for(int i = 1, j; i <= len;){
		for(j = i; b[i] == b[j] && j <= len; j++);
		v = v * jc[j - i] % p;
		// 去除长度相等的循环带来的重复计算
		i = j;
	}
	ans = (ans + qpow(v, p - 2) * qpow(2, u) % p) % p;
}

void dfs(int now, int last, int rem){
	if(!rem){
		// DFS 枚举 n 的所有拆分
		work(now - 1);
		return;
	}
	for(int i = last; i <= rem; i++){
		b[now] = i;
		dfs(now + 1, i, rem - i);
	}
}

signed main(){
	cin >> n;
	init();
	dfs(1, 1, n);
	cout << ans;
	return 0;
}
```
$$\,$$

$\color{red}{\sf Part.6}$

不妨思考形式更一般的问题：

#### $n$ 个节点的完全无向图，用 $m$ 种颜色给每条边染色，可以染出几种互不同构的图？

答案十分简单，只需要将上述式子中的 2 改为 m 即可：

$$\,$$
$$\large{|X/G|=\sum_b \frac{\color{red}{m}^\color{black}k}{\prod(b_i)\prod(c_i!)}}$$

$$\large{k=\sum_{i=1}^K\left \lfloor \frac{b_i}{2} \right \rfloor +\sum_{i=1}^K\sum_{j=1}^{i-1}\gcd(b_i,b_j)}$$
$$\,$$

因为在原问题中，每条边有存在/不存在两种情况，这等价于用两种颜色给每条边染色，不动点数为 $2^k$ 。现在改为用 $m$ 种颜色染色，自然就是 $m^k$ 了。

~~双倍经验：P4128~~

---

## 作者：yybyyb (赞：16)

求本质不同的方案数，很明显就是群论这套理论了。  
置换一共有$n!$个，考虑如何对于任意一个置换求不动点数量。  
首先边存在或者不存在太麻烦了，我们假装所有边都已经存在，出现过的边和不存在的边用两种不同的颜色染色即可。这样子我们就假装所有的边都出现了，也就是一个完全图。  
显然循环是对于点而论的，但是这题同构是对于边而论的。那么我们对于一个点的循环，考虑它的两个顶点。这两个顶点只有两种不同情况，要么在同一个循环内，要么不在同一个循环内。考虑所有在同一个循环中的$n$点形成的完全图，那么它的边构成了$n/2$个循环，感性理解就是，我们把$n$个点拉成一排，把相邻距离为定值的点连上边，显然这样子会构成一个环，因为这个距离的定值$d$和$n-d$是等价的，所以边构成了$n/2$个循环。  
考虑两个顶点不在一个循环内，那么构成循环必定是在一个点集中选择一条边连向另外一个点集，再从另外一个点集中选一条边连回来，我们把点集看成两个环，那么每次可以把环上所有的点旋转一下，那么旋转$lcm$次之后就转回来了，意味着这$lcm$条边必须相同，即构成一个循环，那么边的循环的个数就是$gcd$了。  
假设有边的置换，我们很容易知道不动点的数量就是$2^m$，其中$m$是边置换的数量，显然你的个置换中的边的颜色都是相同的。   
这样一来，我们就把点置换转换为边置换了，这样就可以方便的计算了。  
$60$的拆分数大概是百万级别的，我们似乎是可以爆搜拆分数计算答案的。  
那么考虑一个拆分数实际上对应的方案数，这个排列组合计算一下就好了。  
我们假设有$k$个循环，每个的大小分别是$a_1,a_2,...$，每个大小的置换个数是$num_1,num_2...$  
那么这种情况的贡献就是$\frac{n!}{(\prod a_i!)*(\prod num_i!)}$，原因就是，$n!$是所有方案，然后对于每个置换内，显然环的位置不影响，出去等价的环，然后对于每个等大小的置换，显然位置是可以交换的，那么除去阶乘的排列的影响。
  
好了，这样子大概可以算完所有置换的不动点数量，然后除掉一个置换总数就对了，显然置换总数是$n!$。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define MOD 997
#define MAX 75
int n,ans,jc[MOD],inv[MOD],jv[MOD];
int g[MAX][MAX],a[MAX],b[MAX],bin[MAX*MAX];
void calc()
{
	int ret=jc[n],tot=0,sum=0;
	for(int i=1;i<=n;++i)
	{
		ret=ret*jv[a[i]]%MOD;
		for(int j=1;j<=a[i];++j)
			ret=ret*inv[i]%MOD,b[++tot]=i;
	}
	for(int i=1;i<=tot;++i)sum+=b[i]/2;
	for(int i=1;i<=tot;++i)
		for(int j=i+1;j<=tot;++j)
			sum+=g[b[i]][b[j]];
	ret=ret*bin[sum]%MOD;
	ans=(ans+ret)%MOD;
}
void dfs(int x,int sum)
{
	if(x==1){a[x]=n-sum;calc();return;}
	for(int i=0;sum+i*x<=n;++i)
		a[x]=i,dfs(x-1,sum+i*x);
}
int main()
{
	scanf("%d",&n);
	jc[0]=jv[0]=inv[0]=inv[1]=bin[0]=1;
	for(int i=2;i<MOD;++i)inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1;i<MOD;++i)jc[i]=jc[i-1]*i%MOD;
	for(int i=1;i<MOD;++i)jv[i]=jv[i-1]*inv[i]%MOD;
	for(int i=1;i<MAX*MAX;++i)bin[i]=bin[i-1]*2%MOD;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			g[i][j]=__gcd(i,j);
	dfs(n,0);ans=ans*jv[n]%MOD;
	printf("%d\n",ans);return 0;
}
```

---

## 作者：lightmain (赞：5)

一道Burnside题的流程大概是两步：

1. 找出置换群$<G,*>$和目标集合$S$。
2. 求出$G$中每一个置换在$S$中的不动点集合大小之和。

记一个置换$t(t\in G)$在$S$中的不动点集合是$S_t=\{x\in S |x*t=x\}$。

此题中，置换群$G$是所有的阶为$n$的置换，$|G|=n!$。目标集合是所有有标号的、点数为$n$的图的个数，因为有$\frac{n(n-1)}{2}$条可能的边，所以$|S|=2^{\frac{n(n-1)}{2}}$。

显然$G$太大了，不能拿出其中的每一个置换一个个算不动点集合大小。通过对小数据的手动计算可以发现，由于图的对称性，对于任意两个置换$t_1,t_2\in G$，$|S_{t_1}|=|S_{t_2}|$的充分条件是$t_1,t_2$的循环个数相同，而且把各个循环按照大小排序之后也分别相同。

所以，不妨把$G$中的元素以此为据分类，这样就可以使得每一类中的所有置换$t$的$|S_t|$都是相等的。这一类置换组成的集合用$G_i$表示；也就是说，$G_i$就是由各个循环分别相等的一些置换组成的一个$G$的子集。

实际上，每一个$G_i$中的置换们的循环们的大小，都是整数$n$的某一个划分——所谓划分就是指把$n$表示为任意多个整数之和，而且整数是无序的，也就是说如果$n=3$，那么$2+1$和$1+2$是同一种划分。$n$的划分的总方案数，就是放苹果问题中，苹果数为$n$而盘子个数从$1$到$n$的答案之和。$n=60$时，总划分数大约是百万级别（语出yyb）。

现在我们通过dfs得到了一个单调不下降的序列${a_1,a_2,...,a_m}$，满足$1\le m,a_i \le n,\sum_{i=1}^m a_i = n$。这就是一个$n$的划分。这个序列对应了某一个$G_i$，表示$G_i$中置换的各个循环的大小。为求出这个$G_i$中的置换们的不动点集合大小之和，我们要求出两个值：$G_i$中元素的个数，以及那个相等的$|S_t|$是多少。

前一个值是：
$$
\frac{n!}{(\prod a_i)(\prod b_x!)}
$$
其中$b_x = \sum_{i=1}^m [a_i = x]$。

这个的证明可以用传统的排列组合知识解决。

后一个值较为复杂。后一个值要求的就是有多少种连边的方法，使得在图的点编号被置换一次之后，图的各个循环内部以及循环之间仍然是一模一样的。

我们需要再次把问题分成两部分：循环内和循环间。

对于$m$个循环中的一个大小为$a_i$的循环，不妨选取其中任意的一个点k作为考虑的核心。把$a_i$个点按照循环的顺序一字铺开，并把k放在第一个，如果k有一条边连到了它后面距离它为$d(d\ge1)$的点，那么每一个其他点都需要有一条边连到它后面距离它为$d$的点。所以从k出发，对于每一个跨度$d$，可以选择连一条跨度为$d$的边或者不连；而随即所有其他地方的连边情况也就都被确定了。

到这里，需要发现的一点是，因为边是无向的，所以如果k连出的边中，有某一条边跨度超过了$\lfloor \frac{a_i}{2}\rfloor$（记这个跨度为$d$），那么就相当于往前面连了一条跨度为$a_i-d$的边——故而k往后$a_i-d$条边的那个点也必定会有一条边连到k。这也就相当于是$k$往后连了一条跨度为$a_i - d$的边。综上所述，$k$往后连一条跨度为$a_i-d$的边和跨度为$d$的边是等价的，最后随之确定的整个循环中的边是相同的一些边，所以不能重复计算。

那么，每一个循环内部的方案数就是$2^{\lfloor \frac{a_i}{2}\rfloor}$。

（这也就是yyb题解中说的“一个n个点的循环只有$\frac{n}{2}$个边的循环”。）

现在考虑循环之间的连边方案数。从$m$个循环中挑出两个$a_i,a_j$来（$i < j$），考虑它们之间的连边。仍然从$a_i$循环中拿出一个点$k$，从$a_j$循环中拿出一个点$l$来作为考虑的核心，并把两个循环中的点都一字铺开。

如果$k$和$l$连了边，那么$a_i$循环中$k$的下一个也要和$a_j$循环中$l$的下一个连边，$k$往后两个的点也要和$l$往后两个的点连边......这样两边同时沿着各自的循环转，不知道转了多少圈之后，$k$点一共往$a_j$循环中连了多少条边？显然，$k$往$a_j$循环中每隔$gcd(a_i,a_j)$条边的距离就会连一条边过去，一共连了$\frac{a_j}{gcd(a_i,a_j)}$条。这样来说，$a_j$循环中的$a_j$个点，一共被分为了$gcd(a_i,a_j)$组，每一组包括了$\frac{a_j}{gcd(a_i,a_j)}$个点，这些点中，每相邻的两个点之间的距离都是$gcd(a_i,a_j)$。而且，每一组要么一起向$k$连边，要么都不向$k$连边。那么总连边方案自然就是$2^{gcd(a_i,a_j)}$。

综上所述，对于一个划分$a_1,a_2,...a_m$，这个划分对应的$G_i$中元素的共同的$|S_t|$值，就是：
$$
\prod_{i=1}^m 2^{\lfloor \frac{a_i}{2}\rfloor} \prod _{i=1}^{m}\prod_{j=i+1}^m 2^{gcd(a_i,a_j)}
$$
再把这个值乘上$G_i$的元素的个数：
$$
\frac{n!}{(\prod a_i)(\prod b_x!)}\prod_{i=1}^m 2^{\lfloor \frac{a_i}{2}\rfloor} \prod _{i=1}^{m}\prod_{j=i+1}^m 2^{gcd(a_i,a_j)}
$$
就是这个划分$a_1,a_2,...a_m$的答案了。

把所有划分的答案加起来之后，根据Burnside定理的公式，还要乘上一个$\frac{1}{n!}$才是答案。

而这个$\frac{1}{n!}$可以与上面式子中的$n!$约掉。所以如果你够懒，就直接算各个划分的这个式子的和：
$$
\frac{1}{(\prod a_i)(\prod b_x!)}\prod_{i=1}^m 2^{\lfloor \frac{a_i}{2}\rfloor} \prod _{i=1}^{m}\prod_{j=i+1}^m 2^{gcd(a_i,a_j)}
$$


把所有$gcd(i,j)$预处理出来会快一点。

```c++
/*
几个错误调试了好久。
*///using CRLF, UTF-8

#include <cstdio>
#include <algorithm>
#include <cstring>
#define pr printf
#define F(i, j, k) for(register int i = j, kkllkl = k; i <= kkllkl; ++i)
#define G(i, j, k) for(register int i = j, kkllkl = k; i >= kkllkl; --i)
#define clr(a, v) memset((a), v, sizeof(a))
using namespace std;
typedef long long ll;

#define isd(x) (('0' <= (x) && (x) <= '9') || (x) == '-')
int rd() {
    int ans = 0, sign = 1; char c = getchar();
    while(!isd(c)) c = getchar();
    if(c == '-') sign = -1, c = getchar();
    while(isd(c)) ans = (ans << 3) + (ans << 1) + c - '0', c = getchar();
    return sign == 1 ? ans : -ans;
}

#define chkmin(x, y) ((x) = min((x), (y)))
#define chkmax(x, y) ((x) = max((x), (y)))

/* --------------------------------------------------- */

const int N = 65, MOD = 997;
int Gcd(int x, int y) { return y ? Gcd(y, x % y) : x; }
int fsp(int a, int x) {
    int ans = 1;
    for(; x; x >>= 1, a = a * a % MOD)
        if(x & 1) ans = ans * a % MOD;
    return ans;
}

int n, frac[N], ifrac[N], gcd[N][N], p2[N], inv[N];

int a[N], m, b[N];
int solve() {
    // F(i, 1, m) pr("%d%c", a[i], " \n"[i == m]);
    int ret = 1;
    F(i, 1, m) ret = (ret * inv[a[i]]) % MOD;
    F(i, 1, n) ret = (ret * ifrac[b[i]]) % MOD;
    F(i, 1, m) ret = (ret * p2[a[i] / 2]) % MOD;
    F(i, 1, m) F(j, i + 1, m) ret = (ret * p2[gcd[a[i]][a[j]]]) % MOD;
    // pr("ret = %d\n", ret);
    return ret;
}

int ans = 0;
void dfs(int level, int sum) {
    if(sum == n) {
        m = level - 1;
        ans = (ans + solve()) % MOD;
        return ;
    }
    F(i, max(1, a[level - 1]), n - sum) {
        a[level] = i;
        ++b[i];
        dfs(level + 1, sum + i);
        --b[i];
    }
}

int main() {
    n = rd();
    F(i, 1, n) inv[i] = fsp(i, MOD - 2);
    frac[0] = 1;
    F(i, 1, n) frac[i] = frac[i - 1] * i % MOD;
    ifrac[n] = fsp(frac[n], MOD - 2);
    G(i, n - 1, 0) ifrac[i] = ifrac[i + 1] * (i + 1) % MOD;
    F(i, 1, n) F(j, 1, n) gcd[i][j] = Gcd(i, j);
    p2[0] = 1;
    F(i, 1, n) p2[i] = (p2[i - 1] * 2) % MOD;
    dfs(1, 0);
    pr("%d\n", ans);
    return 0;
}
/*
*/
```



---

## 作者：斯德哥尔摩 (赞：5)

这题感觉像是$Polya$计数。。。

然后借鉴了这位大佬的博客证明了这题是$Polya$计数：[博客](https://blog.csdn.net/sdfzyhx/article/details/70035662)

首先，我们可以把问题转化成在完全图上对边进行黑白染色，求不同构方案数。 

然后就跟这题差不多了：[P4128 [SHOI2006]有色图](https://www.luogu.org/problemnew/show/P4128)

对于每个点的置换，要求出有多少关于边的不动点。

把置换写成循环，可以发现两条性质：

1. 一个长度为$x$的点的循环内部有$\lfloor \frac{x}{2}\rfloor$个边的循环。

2. 两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环，这样关于边的不动点总数就是$2m$，其中$m$表示边的循环的总数。 

但是直接枚举点的置换有$n!$种，$TLE$。

我们考虑，因为每种置换对答案的贡献只和每个循环的大小有关，可以枚举$n$的正整数拆分，然后对每种拆分计算对应的置换个数。

具体来说，记有$m$个循环，每个循环的长度为$l_i$,每个长度的循环有$c_i$个。

首先给每个循环分配一个位置：
$$\left(\begin{array}{c}n\\l_1\end{array}\right)\left(\begin{array}{c}n-l_1\\l_2\end{array}\right)...\left(\begin{array}{c}n-l_1-l_2-...-l_{m-1}\\l_m\end{array}\right)$$

然后固定第一个元素，每个循环有 $(l_i-1)!$ 种排法。

但是相同长度的循环彼此之间的顺序被重复考虑。

所以最后的答案就可求了：
$$Ans=\frac{n!}{\prod_{i=1}^ml_i\prod_{i=1}^mc_i}$$

除转乘直接逆元，而$997\in prime$，所以直接费马小定理即可。

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define MAXN 70
#define MOD 997
using namespace std;
long long n,ans=0;
long long val[MAXN],num[MAXN],fact[MAXN],inv[MAXN],invfact[MAXN],gcd[MAXN][MAXN];
inline long long read(){
    long long date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
long long Gcd(long long x,long long y){//记忆化gcd
    if(gcd[x][y])return gcd[x][y];
    else if(!y)return x;
    return Gcd(y,x%y);
}
long long mexp(long long a,long long b,long long c){//快速幂应该都会
    long long s=1;
    while(b){
        if(b&1)s=s*a%c;
        a=a*a%c;
        b>>=1;
    }
    return s;
}
void get_answer(){//累计答案
    int top=0;
    long long sum=0,now=fact[n];
    for(int i=1;i<=n;i++){
        now=now*invfact[num[i]]%MOD;
        for(int j=1;j<=num[i];j++){
            val[++top]=i;
            now=now*inv[i]%MOD;
        }
    }
    for(int i=1;i<=top;i++){
        sum+=val[i]/2;
        for(int j=i+1;j<=top;j++)sum+=gcd[val[i]][val[j]];
    }
    now=now*mexp(2,sum,MOD)%MOD;
    ans=(ans+now)%MOD;
}
void dfs(int x,int s){//直接暴搜
    if(x==1){
        num[1]=n-s;
        get_answer();
        return;
    }
    for(int i=0;s+i*x<=n;i++){
        num[x]=i;
        dfs(x-1,s+i*x);
        num[x]=0;
    }
}
void work(){
    dfs(n,0);
    ans=ans*invfact[n]%MOD;//别忘了！
    printf("%lld\n",ans);
}
void init(){//预处理阶乘、逆元、gcd
    n=read();
    fact[0]=invfact[0]=1;
    for(int i=1;i<=n;i++){
        fact[i]=fact[i-1]*i%MOD;
        inv[i]=mexp(i,MOD-2,MOD);
        invfact[i]=mexp(fact[i],MOD-2,MOD);
    }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    gcd[i][j]=Gcd(i,j);
}
int main(){//主函数So easy!
    init();
    work();
    return 0;
}

```

---

## 作者：Smallbasic (赞：4)

显然要用到群论。。。和P4128很像。

我们可以把原问题转化为用黑白两种颜色给$n$个点得完全图染色，本质不同得方案数。

如果是点那好求，考虑怎么用点的置换求边

对于一条边，它的两个顶点可能在同一循环内也可能在不同循环内。对于在同一循环内的情况，他的边构成了$n\over2$个循环。可以理解成把$n$个点围成一个圆，那长度为$x$和$n-x$本质是一样的。

若在不同循环内，设循环长度分别为$x,y$，显然每条边在$lcm(x,y)$次置换之后会回到自己，长度即为$lcm(x,y)$。循环数即是${xy\over lcm(x,y)}=\gcd(x,y)$

总数就是把两种情况加起来。

设边置换总数为$m$，则不动点数量为$2^m$

点置换的总数为$n!$，直接枚举显然会T。每个置换对答案的贡献只会与他的大小有关。我们只需要枚举$n$的拆分。组合数学算就好了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

int n;
const int p = 997;

typedef long long ll;

inline ll power(ll a, ll b, int p) {
	ll t = 1, y = a, k = b;
	while (k) {
		if (k & 1) t = (t * y) % p;
		y = (y * y) % p; k >>= 1;
	} return t;
}

// inv

int inv[61], fac[61], invfac[61];

inline void getinv() {
	inv[1] = 1;
	for (int i = 2; i <= n; ++i)
		inv[i] = 1ll * (p - p / i) * inv[p % i] % p;
	fac[0] = invfac[0] = 1;
	for (int i = 1; i <= n; ++i) {
		fac[i] = 1ll * fac[i - 1] * i % p;
		invfac[i] = 1ll * invfac[i - 1] * inv[i] % p;
	}
}

int ans = 0;
int stk[1005], top = 0, cb = 1, up = 0;

inline int min_(int a, int b) {
	return a < b ? a : b;
}

inline int gcd(int a, int b) {
	return !b ? a : gcd(b, a % b);
}

inline void dfs(int now, int mn, int c) {
	if (now == 0) {
		ans = (ans + 1ll * cb * power(2, up, p)) % p;
		return ;
	} int u = up, cc = cb;
	for (int i = 1; i <= mn; ++i) {
		stk[++top] = i;
		up = u + i / 2;
		for (int j = 1; j < top; ++j) up += gcd(stk[j], i);
		cb = (1ll * cc * inv[i]) % p;
		if (i == stk[top - 1]) cb = ((1ll * cb * fac[c]) % p * invfac[c + 1]) % p;
		dfs(now - i, min_(now - i, i), (i == stk[top - 1]) * c + 1);
		--top;
	}
}

int main() { 
	scanf("%d", &n);
	getinv();
	dfs(n, n, 0);
	printf("%d", ans);
	return 0;
}
```


---

## 作者：WorldMachine (赞：3)

题意：求 $n$ 个点的图的同构类数。$n\le60$。

---

把边存在和不存在当成黑白两种颜色。由 Burnside 定理得：
$$
\dfrac{1}{n!}\sum_{p\in S_n}|{\mathcal G}^p|
$$
其中 ${\mathcal G}^p$ 为所有在置换 $p$ 下保持不变的图的集合。

设 $p$ 将边集划分成了 $D(p)$ 个等价类（同一个等价类内的边颜色必须相同），那么有 $|{\mathcal G}^p|=2^{D(p)}$。现在问题在于如何求出 $D(p)$。

---

将 $p$ 拆成若干个轮换，长度为 $a_1,a_2,\dots,a_k$。分讨端点在同一轮换或不同轮换的情况。

如果端点在同一轮换，例如 $(12345)$，可以将其画成正 $5$ 边形的形式：

![](https://cdn.luogu.com.cn/upload/image_hosting/pdglzfxv.png)

为了保证图形的旋转对称性，所有长度相同的线段必须有相同的颜色，容易发现，对于正 $n$ 边形，线段的长度一共有 $\left\lfloor\dfrac n2\right\rfloor$ 种，故这部分的答案为 $\sum\limits_{i=1}^k\left\lfloor\dfrac{a_i}{2}\right\rfloor$。

对于端点在不同轮换的情况，两个轮换 $i,j$ 间会有 $a_ia_j$ 条边，每条边经过 $\text{lcm}(a_i,a_j)$ 次变换之后会回到原位，那么轮换 $i,j$ 的贡献为 $\dfrac{a_ia_j}{\text{lcm}(a_i,a_j)}=\gcd(a_i,a_j)$。故这部分的答案为 $\sum\limits_{i=1}^k\sum\limits_{j=1}^{i-1}\gcd(a_i,a_j)$。

综上，有：
$$
D(p)=\sum_{i=1}^k\left\lfloor\dfrac{a_i}{2}\right\rfloor+\sum_{i=1}^k\sum_{j=1}^{i-1}\gcd(a_i,a_j)
$$
所求即为：
$$
\dfrac{1}{n!}\sum_{p\in S_n}2^{D(p)}
$$

---

直接枚举每个排列只能做到 $\mathcal O(n!)$，但发现置换的型和 $D(p)$ 直接相关，且数量为 $p_n$（分拆数），和 $n\le60$ 的数据范围很搭。

于是枚举 $n$ 的分拆 $a_1+a_2+\dots+a_k$，其中值为 $i$ 的数有 $b_i$ 个，求型为 $1^{b_1}2^{b_2}\dots n^{b_n}$ 的置换个数。

首先分配每个元素在哪个轮换中，每个长度为 $a$ 的轮换会贡献 $a!$ 次算重；然后是轮换内部排列，即圆排列，为 $(a-1)!$；最后，相同长度的轮换之间可以交换，即算重 $b!$ 次。故置换个数为：
$$
\dfrac{n!\prod_{i=1}^k(a_i-1)!}{\prod_{i=1}^ka_i!\prod_{i=1}^nb_i!}=\dfrac{n!}{\prod_{i=1}^ka_i\prod_{i=1}^nb_i!}
$$
则答案为：
$$
\dfrac{1}{n!}\sum_{a\text{ is a partition of }n}\dfrac{n!2^{D(a)}}{\prod_{i=1}^ka_i\prod_{i=1}^nb_i!}=\sum_{a\text{ is a partition of }n}\dfrac{2^{D(a)}}{\prod_{i=1}^ka_i\prod_{i=1}^nb_i!}
$$
注：上面的式子实际上将 $D$ 的定义从置换移植到了分拆上，计算式不变。

直接 dfs 枚举每个分拆即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 65, p = 997;
int n, a[N], fac[N], Gcd[N][N], ans;
void init() {
	fac[0] = 1;
	for (int i = 1; i <= n; i++) {
		fac[i] = fac[i - 1] * i % p;
		for (int j = 1; j <= n; j++) Gcd[i][j] = __gcd(i, j);
	}
}
int qpow(int a, int b) {
	int c = 1;
	while (b) { if (b & 1) c = c * a % p; a = a * a % p, b >>= 1; }
	return c;
}
void calc(int n) {
	int D = 0, m = 1;
	for (int i = 1; i <= n; i++) {
		D += a[i] >> 1, m = m * a[i] % p;
		for (int j = 1; j < i; j++) D += Gcd[a[i]][a[j]];
	}
	for (int l = 1, r; l <= n; l = r) {
		r = l; while (r <= n && a[l] == a[r]) r++; m = m * fac[r - l] % p;
	}
	ans = (ans + qpow(2, D) * qpow(m, p - 2)) % p;
}
void dfs(int x, int pre, int n) {
	if (!n) return calc(x - 1);
	for (int i = pre; i <= n; i++) a[x] = i, dfs(x + 1, i, n - i);
}
int main() {
	cin >> n, init(), dfs(1, 1, n), cout << ans;
}
```

---

## 作者：Z1qqurat (赞：1)

看起来是个置换群计数状物，果断将重标号方式看作群的置换。之前做的置换群计数都是对点染色，这是对边染色的。那么总的置换方式数就是 $n$ 阶排列数，$n!$。接下来考虑对每一种置换，如何计算它的等价类个数 $f$，从而得到不动点个数 $2^f$。

考虑一种置换：原标号为 $\{1,2,3,4,5,6\}$，置换后为 $\{2 ,3,1,4,6,5\}$。将其分解为 $3$ 个循环：$\{2,3,1\}, \{4\}, \{6,5\}$。那么每个循环内部都是一个小的完全图。考虑将边分类。

* 该边两个端点在同一个循环内。那么对于一个长度为 $b_i$ 的循环，相当于一个 $b_i$ 阶无向完全图，其中连出来长度相等的边属于同一个等价类。该图内一共有 $\left\lfloor\frac{b_i}{2}\right\rfloor$ 种不同长度的边，所以贡献 $\left\lfloor\frac{b_i}{2}\right\rfloor$ 个等价类。

![](https://pic.imgdb.cn/item/657123b6c458853aef014893.png)

* 该边两个端点在不同循环内。那么设这两个循环的长度分别为 $b_1, b_2$，一共就有 $b_1b_2$ 条边，每条边在 $\text{lcm}(b_1,b_2)$ 次旋转后回到原来位置，故共有 $\frac{b_1b_2}{\text{lcm}(b_1,b_2)} = \text{gcd}(b_1,b_2)$ 个等价类。

总共贡献了 $\sum\limits_{i=1}^{k} \left\lfloor\frac{b_i}{2}\right\rfloor + \sum\limits_{i=1}^{k} \sum\limits_{j=1}^{i-1} \text{gcd}(b_i,b_j)$ 个等价类。

考虑降低复杂度。发现结果与具体排列无关，如果两个置换的 $b$ 对应的数集相等，这两个置换的等价类个数相等，可视为同类置换，统一计算。枚举 $n$ 的拆分即可。

```cpp
#include <bits/stdc++.h>
#define ALL(v) begin(v), end(v)
using i64 = int64_t;
using std::cin;
using std::cout;
constexpr int N = 65, P = 997;

int n, ans;
std::array<int, N> b, c, fac;

auto qpow(int x, int y) {
   auto ret{1};
   for (; y; x = x * x % P, y >>= 1) {
      if (y & 1) ret = ret * x % P;
   }
   return ret;
}

auto dfs(int u, int sum) -> void {
   if (sum > n) return ;
   if (sum == n) {
      c.fill(0);
      for (auto i = 1; i < u; ++i) c[b[i]]++;
      auto f{0}, x{1};
      for (auto i = 1; i < u; ++i) {
         f += (b[i] >> 1), x = x * b[i] % P;
         for (auto j = 1; j < i; ++j) 
            f += std::__gcd(b[i], b[j]);
      }
      for (auto i = 1; i <= n; ++i) x = x * fac[c[i]] % P;
      ans = (ans + qpow(2, f) * qpow(x, P - 2) % P) % P;
      return ;
   }

   for (auto i = std::max(1, b[u - 1]); i <= n; ++i) 
      b[u] = i, dfs(u + 1, sum + i);
   return ;
}

auto main() -> int {
   std::ios::sync_with_stdio(false);
   cin.tie(nullptr), cout.tie(nullptr);

   cin >> n, fac[0] = 1;
   for (auto i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % P;
   dfs(1, 0);
   cout << ans << "\n";
   return 0;
}
```

---

## 作者：Zi_Gao (赞：0)

## 0x00 Burnside's lemma

这里需要一点群论的知识，设 $G$ 是一个置换群群，将作用在集合 $X$ 上，有以下结论：

$$
\left|X/G\right|=\frac{1}{\left|G\right|}\sum_{g\in G} \left|X^g\right|
$$

- 其中 $X/G$ 表示集合 $X$ 在群 $G$ 作用下的本质不同元素集合，那么 $\left|X/G\right|$ 则表示本质不同元素个数，即轨道数。
- $g$ 表示置换群 $G$ 中的一个置换。
- $X^g$ 表示集合 $X$ 在置换 $g$ 变换下，$X$ 集合中的不动点，$\left|X^g\right|$ 自然表示不动点数。

对于这个题来说 $X$ 就是 $n$ 个点的简单无向图集合，一共 $2^{{n\choose 2}}$ 个。$G$ 就是点标号的置换的集合，即排列的集合，一共 $n!$ 个。$g$ 就是一个排列，$\left|X^g\right|$ 则表示按照 $g$ 对图重标号后，有多少个图和原来一样。

若两个图同构，说明可以通过重标号一个图的方式得到另一个图，所以说 $\left|X/G\right|$ 就等于有多少个不同构的数。这样转化重点就是计算 $\left|X^g\right|$。

## 0x01 计算 $\left|X^g\right|$

假设有一个 $g$，怎么计算 $\left|X^g\right|$，显然只需要关注边的情况，什么情况下一个图在 $g$ 变换后与原图相同呢？假设现在有两个点 $u,v$，则他们重编号映射后就是 $g_{u},g_{v}$，由于要和原图相同，所以 $u,v$ 的连边情况和原图要是相同的。这意味着在 $g$ 的变化下有一些边是等价的，对于某一个等价类，要么全连上要么全不连，假设有 $k$ 个等价类，则有 $2^k$ 个图是不动点，即 $\left|X^g\right|=2^k$。

## 0x02 计算 $k$

寻找等价类的过程就是从某一条边 $u\leftrightarrow v$ 出发，然后寻把 $g_{u}\leftrightarrow g_{v}$ 这条边合并到一个等价类，然后 $g_{g_u}\leftrightarrow g_{g_v}$ 合并，相当于是 $u,v$ 每次分别走到 $g$ 变换的点去，然后重复过程，直到回到最初的点，自然想到把 $g$ 拆成若干个置换环。现在分类讨论 $u,v$ 所在置换环的情况：

1. $u,v$ 在同一个置换环中，设置换环长度为 $b$，显然 $u,v$ 同时走 $b$ 步之后会回到最初的点，并且过程中 $u,v$ 在置换环上的间距保持不变，那么在每一个等价类对应一个间距，故共有 $\left\lfloor\frac{b}{2}\right\rfloor$ 个等价类。
2. $u,v$ 不在同一个置换环中，设置换环长度分别为 $b_1,b_2$ 和刚才一样，每次 $u,v$ 都分别走到 $g$ 变换的点去，要走 $\text{lcm}(b_1,b_2)$ 才能回到最初出发的边，也就是等价类里面一共有 $\text{lcm}(b_1,b_2)$ 条边。而两个置换环之间一共能连出 $b_1b_2$ 条边，所以一共有 $\frac{b_1b_2}{\text{lcm}(b_1,b_2)}=\gcd(b_1,b_2)$ 个等价类。

设当有 $m$ 个置换环，置换环长度分别为 $b_i$，根据上面的推论有：

$$
k=\sum_{i=1}^m\left\lfloor\frac{b_i}{2}\right\rfloor+\sum_{i=1}^m\sum_{j=1}^{i-1}\gcd(b_i,b_j)
$$

## 0x03 统计排列

直接枚举排列显然是不行的，但是发现若排列的置换环长度 $b$ 序列相同，贡献也是相同的，于是直接枚举 $b$，即 $n$ 的一个整数拆分。考虑计算有多少个排列的置换环长度是 $b$，先考虑把 $n$ 个数划分到每一个置换环里面，再考虑置换环内部排列方式。随便放有 $n!$ 个排列，但是每一个置换环内部的排列先不计算，所以要除去 $b_i!$，但是长度相同的置换环交换还是同样的情况，所以也要出去，设长度为 $i$ 的置换环有 $c_i$ 个，就是要除 $c_i!$，所以划分方案一共是：

$$
\frac{n!}{\prod (b_i!)\prod (c_i!)}
$$

现在考虑置换环内部的排列情况，显然就是圆排列，有 $(b_i-1)!$ 个，最终就是：

$$
\frac{n!\prod (b_i-1)!}{\prod (b_i!)\prod (c_i!)}=\frac{n!}{\prod b_i\prod (c_i!)}
$$

把前面提到的式子整理一下：

$$
\begin{aligned}
\left|X/G\right|&=\frac{1}{\left|G\right|}\sum_b \frac{n!2^k}{\prod b_i\prod (c_i!)}\\
&=\frac{1}{n!}\sum_b \frac{n!2^k}{\prod b_i\prod (c_i!)}\\
&=\sum_b \frac{2^k}{\prod b_i\prod (c_i!)}\\

k&=\sum_{i=1}^m\left\lfloor\frac{b_i}{2}\right\rfloor+\sum_{i=1}^m\sum_{j=1}^{i-1}\gcd(b_i,b_j)
\end{aligned}
$$

## 0x04 扩展问题

这道题中每一个图相当于是对边染色了，出现的染白，没出现的染黑，不妨多搞几个颜色。$n$ 个点的无向完全图，有 $m$ 中颜色，可以给边随意染色，问可以染出多少个本质不同的图。要解决这个问题我们回到计算 $\left|X^g\right|$ 一步，最后的统计 $2^k$ 就是再说染黑还是染白，自然有 $m$ 种颜色就是 $m^k$。

$$
\begin{aligned}
\left|X/G\right|&=\sum_b \frac{m^k}{\prod b_i\prod (c_i!)}\\

k&=\sum_{i=1}^m\left\lfloor\frac{b_i}{2}\right\rfloor+\sum_{i=1}^m\sum_{j=1}^{i-1}\gcd(b_i,b_j)
\end{aligned}
$$

于是就得到了 P4128 一题做法。

```cpp
#include<bits/stdc++.h>
// #define ONLINE_JUDGE
#define INPUT_DATA_TYPE int
#define OUTPUT_DATA_TYPE int
inline __attribute((always_inline)) INPUT_DATA_TYPE read(){register INPUT_DATA_TYPE x=0;register char f=0,c=getchar();while(c<'0'||'9'<c)f=(c=='-'),c=getchar();while('0'<=c&&c<='9')x=(x<<3)+(x<<1)+(c&15),c=getchar();return f?-x:x;}void print(OUTPUT_DATA_TYPE x){if(x<0)x=-x,putchar('-');if(x>9)print(x/10);putchar(x%10^48);return;}

#define INV_DATA_TYPE long long
INV_DATA_TYPE exgcd(INV_DATA_TYPE a,INV_DATA_TYPE b,INV_DATA_TYPE &x,INV_DATA_TYPE &y){
    if(!b){
        x=1;
        y=0;
        return a;
    }
    INV_DATA_TYPE d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}

INV_DATA_TYPE inv(INV_DATA_TYPE n,INV_DATA_TYPE p){
    INV_DATA_TYPE x,y;
    exgcd(n,p,x,y);
    x%=p;
    return x>=0?x:x+p;
}

long long mod,modp;
int b[70],gcd[70][70],m,p;
long long fact[1000],pwm[100000],res;

void calc(int K){
    register int i,j,k=0,cnt=0;
    register long long v=1;
    b[K]=-1;
    for(i=0;i<K;++i){
        k+=b[i]>>1;
        (v*=b[i])%=mod;

        ++cnt;
        if(b[i]!=b[i+1]){
            (v*=fact[cnt])%=mod;
            cnt=0;
        }

        for(j=0;j<i;++j)
            k+=gcd[b[i]][b[j]];
    }
    (res+=inv(v,mod)*pwm[k])%=mod;
}

void dfs(int st,int rst){
    if(!rst){
        calc(st);
        return;
    }
    for(;b[st]<=rst;++b[st]){
        b[st+1]=b[st];
        dfs(st+1,rst-b[st]);
    }
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("name.in", "r", stdin);
	freopen("name.out", "w", stdout);
	#endif

    register int i,j;
    int n=read();
    m=read();
    modp=(mod=read())-1;
    for(i=0;i<=n;++i)
        for(j=0;j<=n;++j)
            if(i==0||j==0)
                gcd[i][j]=i|j;
            else{
                if(i>=j) gcd[i][j]=gcd[i-j][j];
                else gcd[i][j]=gcd[i][j-i];
            }

    for(fact[0]=i=1;i<=n;++i) fact[i]=fact[i-1]*i%mod;
    for(pwm[0]=i=1;i<=n*n;++i) pwm[i]=pwm[i-1]*m%mod;

    b[0]=1;
    dfs(0,n);

    print(res);

	#ifndef ONLINE_JUDGE
	fclose(stdin);
	fclose(stdout);
	#endif
    return 0;
}
```

---

## 作者：xlpg0713 (赞：0)

数数题大好き！[双倍经验](https://www.luogu.com.cn/problem/P4128)的数数题世界で一番好きな！

# 初步分析

发现 P4727 可以视为 $n$ 个点的完全图，每条边可以染两种不同的颜色，最后同构的有色图计数，故只分析 P4128。

请确保你掌握了有关群论的相关知识。具体地，这道题还利用到了轮换的性质。推销一下我的[博客](https://www.cnblogs.com/xlpg-0713/articles/18009812)。

题目考虑的是在一些变换下**同构**的图计数，考虑 Burnside 引理。

染色是作用在边集上的映射，而同构的定义是基于点集上的置换的。需要考虑能否在点置换和边置换之间建立联系。

对于一个点置换 $\left (\begin{matrix}1,2\cdots n\\p_1,p_2\cdots p_n\end{matrix}\right )$ 我们让它对应边置换 $\left (\begin{matrix}(1,2),(1,3)\cdots (i,j)\cdots (n-1,n)\\(p
_1,p_2),(p_1,p_3)\cdots (p_i,p_j)\cdots (p_{n-1},p_n)\end{matrix}\right )$。


发现若可以把一个边置换拆成若干个边轮换，例如 $\left((a_1,a_2),(a_2,a_3)\cdots (a_{k-1},a_k)\right)$ 则**对应它**的点置换中，一定有一个轮换为 $\left(a_1,a_2\cdots a_k\right)$。即点轮换和边轮换一一对应。我们知道一个置换可以拆成不同的轮换乘积，可以证明，拆出边轮换的不同方式，对应到点轮换中的乘积一定：即一个边轮换只对应一个点轮换。

在此，我们证明了点置换和边置换之间存在双射关系，边置换的规模和点置换同为 $n!$。以下的讨论中不再专门区分点置换和边置换。注意这里关于点轮换和边轮换的对应关系只用于证明点置换和边置换之间存在双射，不用于具体的计数。

# 计数

现在让我们考虑在一个置换下不动点的个数。

显然地，若可以把一个边置换由若干个不相交的 $x$ 个轮换，则不动点个数为 $m^x$，其中 $m$ 是颜色数，这是因为要保证一个轮换之内的边颜色相同。

所以现在要解决：一个点置换对应的边置换中，边轮换的数量。

将边轮换分成两类来计算：所有的点都在同一个点轮换中，一条边的两个点在两个不同的点轮换中。因为边是二元关系，所以不存在边轮换同时跨越了三个及以上的轮换。

1.在同个点轮换中的边轮换数

![](https://cdn.luogu.com.cn/upload/image_hosting/u6xz3g5r.png)

画个图，发现五个点的轮换构成了两个边轮换，六个点的图构成了三个边轮换（注意红色的边并不能构成任何边轮换），以此类推，可得结论：$n$ 个点的点轮换构成了 $\lfloor\frac{n}{2}\rfloor$ 个边轮换。

2.不同点轮换中的边轮换数

考虑两个点轮换，大小分别为 $a_1,a_2$。两个轮换之间有 $a_1a_2$ 条边，一条边经过 $
\operatorname{lcm}(a_1,a_2)$ 次轮换后与原来相同，故共有 $\frac{a_1a_2}{\operatorname{lcm}(a_1,a_2)}=\gcd(a_1,a_2)$ 组轮换。

现在有了一个朴素的方法：枚举一个点置换，将之分解成轮换后计算答案，但显然 $n=60$ 过不了。

# 方法的改进
考虑两个不同的置换，若分解成轮换后，点轮换的大小组成的可重集相等，这两种置换在计算答案时被我们认为是等价的。

若置换拆分后可以表述为 $(a_1,a_2\cdots a_k)$，满足 $\forall i\in[1,k-1],a_i\le a_{i+1}\land\sum a_i=n$，我们需要计算满足有 $k$ 个轮换，第 $i$ 个轮换的点数是 $a_i$ 的方案计数。

首先考虑把 $n$ 个数分到 $k$ 个可重集的方案数是 $\frac{n!}{\prod a_i!}$，每个集合内部不区分顺序，要乘上 $\prod (a_i-1)!$，点数相同的集合之间不区分顺序，要乘上 $\prod c_i!$，$c_i$ 表示有 $i$ 个点的轮换个数。

故总个数为 $\frac{n!}{\prod a_i\prod c_i!}$。答案是 $\sum\limits_{(a_1,a_2\cdots a_k)}\frac{m^{\sum\lfloor\frac{a_i}{2}\rfloor+\sum\limits_{i,j}\gcd(i,j)}}{\prod a_i\prod c_i!}$。

dfs 出所有合法的方案后进行计数，复杂度能过。

只给出 P4128 的代码

```cpp
#include<iostream>
#include<algorithm>
int n, m, p, rs, a[60], c[60], fc[60];
inline int qp(int a, int b){ int r = 1;
	for(; b; b >>= 1, a = 1ll * a * a % p)
		b & 1 ? r = 1ll * r * a % p : 0; return r;
}
inline void dfs(int x, int k, int t){
	if(x == n){
		int f = 0, g = 1; for(int i = 1; i <= k; i++) f += a[i] >> 1, g = 1ll * g * a[i] % p;
		for(int i = 1; i <= k; i++) for(int j = i+1; j <= k; j++) f += std::__gcd(a[i], a[j]);
		for(int i = 1; i <= t; i++) g = 1ll * g * fc[c[i]] % p;
		(rs += 1ll * qp(m, f) * qp(g, p - 2) % p) %= p; return;
	}
	for(int i = t+1; i <= n - x; i++){
		for(int j = 1; x + i*j <= n; j++)
			a[k+j] = i, ++c[i], dfs(x+i*j, k+j, i);
		c[i] -= (n - x) / i;
	}
}
int main(){
	std::cin >> n >> m >> p; fc[0] = 1;
	for(int i = 1; i <= n; i++) fc[i] = 1ll * fc[i - 1] * i % p;
	dfs(0, 0, 0); std::cout << rs;
}
```

---

## 作者：Aigony (赞：0)

本文节选自 [Burnside 引理 与 Pólya 定理 学习笔记](https://www.cnblogs.com/ying-xue/p/burnside-polya.html)。

我们可以把每条边选与不选看作对一个完全图上的边黑白染色，这与原题意是等价的。

使用 Polya 定理，先枚举一个置换，并把置换写成循环的形式。考虑对在该置换下不变的染色方案进行计数。

根据一条边的两个端点是否在同一个循环内，分类讨论：

- 如图，若一条边的两个端点属于同一循环，那么它应当与循环内所有长度相等的边同色。  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/tywsk9gs.png)  
  那么一个长度为 $len$ 的循环，其内部共有 $\lfloor \frac{len}{2}\rfloor$ 类等价的边。
- 否则，若一条边连接了两个不同循环，设它们的长度分别为 $len_i,len_j$。那么一条边需要做 $\text{lcm}(len_i,len_j)$ 次置换才能回到它原来的位置，即等价类个数为 $\gcd(len_i,len_j)$。

综上，一个 $len$ 序列对 polya 求和式子的贡献为
$$
S=\sum_{i=1}^n(\lfloor \frac{len_i}{2}\rfloor +\sum_{j=1}^{i-1} \gcd(len_i,len_j))
$$
发现这只与 $len$ 数组有关而与具体的置换无关，考虑只枚举 $len$ 数组，并计算有多少种对应的置换。由 2.3.2 可知，设 $c_i$ 表示 $len_j=i$ 的 $j$ 的个数，对应的置换数为
$$
\frac{n!}{\prod len_i\prod (c_i!)}
$$
总答案为
$$
\frac{1}{n!}\sum_{len}\frac{n!}{\prod len_i\prod (c_i!)} 2^S
$$
其中 $S$ 见上文。时间复杂度为 $n$ 的无序拆分数。

```cpp
#define int long long
const int N=205,mod=997;
int n,ans,tot,b[N],c[N];
il int qpow(int n,int k=mod-2)
{
    int res=1;
    for(;k;n=n*n%mod,k>>=1) if(k&1) res=res*n%mod;
    return res;
}
il int solve()
{
    int res=0;
    for(int i=1;i<=tot;i++)
    {
        res=(res+(b[i]>>1));
        for(int j=1;j<i;j++) res=(res+__gcd(b[i],b[j]));
    }
    return res;
}
void dfs(int sum)
{
    if(!sum)
    {
        int k=solve();
        int v=1;
        for(int i=1;i<=n;i++) c[i]=0;
        for(int i=1;i<=tot;i++) v=v*b[i]%mod,c[b[i]]++;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=c[i];j++) v=v*j%mod;
        ans=(ans+qpow(2,k)*qpow(v)%mod)%mod;
        return;
    }
    for(int k=b[tot];k<=sum;k++)
    {
        b[++tot]=k,dfs(sum-k);
        tot--;
    }
}
signed main()
{
    n=read();
    b[0]=1; dfs(n);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Leasier (赞：0)

Update on 2023.4.1：感谢 [TernaryTree](https://www.luogu.com.cn/user/362750)。

------------

**双倍经验：[P4128 [SHOI2006] 有色图](https://www.luogu.com.cn/problem/P4128)。**

------------

注意到我们并不关心边的连通性等信息，而只关心边存不存在。

考虑将连上的边标成黑色、没连的边标成白色，则转化成了上面那道题 $m = 2, p = 997$ 的情况。

~~于是就可以把代码粘过来，然后改两句话就行。~~

------------

本题中我们的置换群为所有长为 $n$ 的置换，表示点重编号的结果。

但是本题中我们是**对边染色**，考虑如何算不动点数量。类似于点染色的情况，我们只需要知道边的等价类个数即可。

考虑抓出这个置换的所有环（设环长为 $cnt_1, cnt_2, \cdots, cnt_k$），然后来讨论等价类：

- 环内到环内：此时我们只关心两点在环（设为 $i$）上的距离，而这个距离 $\leq \lfloor \frac{cnt_i}{2} \rfloor$，则方案数为 $\lfloor \frac{cnt_i}{2} \rfloor$。
- 环内到环外：此时我们只关心两个环（设为 $i, j$）的大小，而从任意一个状态出发在两个环上每次定向前进一步，回到原点所需步数均为 $\operatorname{lcm}(cnt_i, cnt_j)$，则本质不同个数为 $\gcd(cnt_i, cnt_j)$。

综上，不动点数量为 $2^{\sum_{i = 1}^k \lfloor \frac{cnt_i}{2} \rfloor  + \sum_{i = 1}^{k - 1} \sum_{j = i + 1}^k \gcd(cnt_i, cnt_j)}$。

注意到 $n$ 很小，则我们可以考虑枚举 $n$ 的拆分数，对每种方案计算上面这个东西，然后再乘上方案数，即 $\dfrac{n!}{\displaystyle\prod_{i = 1}^k cnt_i \displaystyle\prod_{\text{There exists i item j that } cnt_j = t} i!}$。

时间复杂度为 $O(n \operatorname{Partition}(n) \log n)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int mod = 997;
int cnt1[67], cnt2[67];
ll inv[67];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init(int n){
	inv[0] = inv[1] = 1;
	for (int i = 2; i <= n; i++){
		inv[i] = mod - (mod / i) * inv[mod % i] % mod;
	}
}

inline int max(int a, int b){
	return a > b ? a : b;
}

int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}

ll dfs(int cur, int lst, int pre, int sum){
	if (lst == 0) return quick_pow(2, sum, mod);
	int cur_i = cur + 1;
	ll ans = 0;
	for (int i = max(pre, 1); i <= lst; i++){
		int cur_sum = sum + i / 2;
		cnt1[cur] = i;
		if (i == pre){
			cnt2[cur] = cnt2[cur - 1] + 1;
		} else {
			cnt2[cur] = 1;
		}
		for (int j = 1; j < cur; j++){
			cur_sum += gcd(cnt1[j], i);
		}
		ans = (ans + dfs(cur_i, lst - i, i, cur_sum) * inv[i] % mod * inv[cnt2[cur]] % mod) % mod;
	}
	return ans;
}

int main(){
	int n;
	scanf("%d", &n);
	init(n);
	printf("%lld", dfs(1, n, 0, 0));
	return 0;
}
```

---


# [ZJOI2017] 汉诺塔

## 题目背景

虽然九条可怜经常出题，但是她发现要一个人出一场比赛是在是太难了，于是她丢下了手头的出题工作开始玩小游戏。

## 题目描述

有一个游戏是汉诺塔的改版。在这个游戏中，盘子的大小可以相同，但是保证了相同大小的盘子恰好有 K 个。

初始状态下，所有盘子自底向上从大到小地放置在第一根柱子上，对于相同大小的盘子，我们自底向上给它们从 1 到 K 标号。目标是把所有盘子都移动到第三根柱子上。

因为相同大小的盘子的上下顺序没有要求，不难发现合法的终止状态有很多，因此游戏里指定了一种终止状态。

游戏的任务是最小化移动的步数。

可怜想了想觉得这个问题好像挺难的，于是她就把这个出到比赛里来给你做啦。

下面给出汉诺塔的具体规则：

• 有三根柱子和若干块圆盘，初始状态下所有圆盘都在第一根柱子上。

• 每一时刻你可以把某一根柱子顶端的圆盘移动到另一根柱子的顶端，目标是把
所有盘子都

移动到第三根柱子上。

• 移动的过程中必须要保证较大的圆盘不会压在较小的圆盘上。（相同大小的圆盘没有顺序限制）。


## 说明/提示


| 测试点编号 | K | 测试点编号 | K |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 1 | =1 | 6 | =3 |
| 2 | =2 | 7 | =3 |
| 3 | =2 | 8 | =4 |
| 4 | =2 | 9 | =4 |
| 5 | =3 | 10 | =4 |

对于 100% 的数据，保证 T ≤ $10^4$
, 1 ≤ n ≤ 50, 1 ≤ xi ≤ K。

**在实际的测试点中，T 组数据的 K 都是相同的**

$\textcolor{white}{SookeAKIOI}$

## 样例 #1

### 输入

```
3
3 1
1
1
1
1 2
2 1
4 2
2 1
1 2
1 2
2 1
```

### 输出

```
7
2
31```

# 题解

## 作者：wuzr (赞：10)

这里用 $m$ 表示相同大小的盘子数。

如果不对最终状态进行限制，那么最优解显然和普通的汉诺塔一样，每一层都分三步：把上面一些小的移到中间，把大小相同的 $m$ 个移到最后，把中间小的移动到最后。可以发现，每一步移动的所有盘子的相对顺序都会反过来。我们把这样的移到称为初始的。

现在对终止状态进行限制，这就意味着每一层在某几次移动的时候与上述表现出来的行为不同。我们可以把每一次移动看成对当前盘子的相对顺序进行置换。即对于第 $i$ 层，假设它被移动了 $K$ 次，那么我们要做的是找到一些置换 $p_1,p_2,...,p_K$，使得他们乘起来等于我们需要的排列。

在汉诺塔中这个 $K$ 可能很大，但是不难发现其实大部分移动都是初始的（无限制时的最优），每次至多只有 $m!$ 种变化（超过 $m!$ 一定会出现重复状态）。

我们的思路就是大部分情况下使用初始的移动，同时 $\text{DP}$ 发生变化的部分。

现在考虑底层的移动对高层的影响，在假设高层都是初始的移动的情况下，可以发现每一层对高的层的影响只停留在高的层移动的奇偶性（奇数的时候在初始移动下是倒置的）。

这里举个例子：

输入

```
1
2 2
1 2
2 1
```

输出

```
10
```

![](https://cdn.luogu.com.cn/upload/image_hosting/k6vkuikx.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/f5mz6t3h.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/3ei0t7vk.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/fzfpvhbo.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/rodwiga3.png)

本组数据在无限制的条件下最终状态是：

```
2 1
1 2
```

我们改变了第 $1$ 层的移动方式，影响到了第 $2$ 层。

再举个例子：

$n=3,m=2$ 时，我们仅要求第 $1$ 层的最终状态为 "1 2"（与无限制时的最优解相反）求最少步数，观察改变第 $1$ 层对高层的影响：

即：

输入

```
1
3 2
1 2
2 1
1 2
```

输出

```
22
```

![](https://cdn.luogu.com.cn/upload/image_hosting/5twsnbdg.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ryr62j1x.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/lyd4p21q.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/6v7nko0s.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/0ru2hyth.png)

我们发现改变了第 $1$ 层只对第 $2$ 层有影响。

与无限制的条件下最优移动方案比，第 $2$ 层多移动了 $1$ 次，第 $3$ 层多移动了 $2$ 次（第 $3$ 层可以抽象为若干更高层，代码实现时将更高的抽象为一个点）。

于是更近一步的说，第 $i$ 层只对第 $i+1$ 层有影响（更高层在初始移动的情况下影响的步数都是偶数）。

同时因为我们的 $\text{DP}$ 是对初始的移动进行修改，因此我们还需要记录第 $i+1$ 层总共移动了多少步，步数不需要确切记下来，只要对 $m!$ 取 $\min$ 就可以了。

因此我们的 $DP$ 状态就是 $f[i][t][b]$ 表示当前 $\text{DP}$ 到第 $i$ 层，第 $i$ 层移动了 $t$ 步，以及移动次数的奇偶性是 $b$。在转移的时候我们需要处理这样的值 $w[i][t][p][t']$ 表示在第 $i$ 层用 $t$ 步移动出排列 $p$ 同时上一层移动次数增加了 $t'$ 的最小步数。

接下来我们考虑怎么处理这个值。

首先我们需要计算 $g[i][p][t']$ 表示在第 $i$ 层仅修改一次初始的移动得到置换 $p$，同时上一层的移动次数增加了 $t'$ 的最小步数。这一步中我们只需要考虑当前层的盘子以及上面的那一堆在哪里就可以了，状态数 $S$ 只有不到 $2000$ 种，把转移图建出来之后枚举 $i$ 跑最短路就可以了，时间复杂度约为 $O(m!nS)$。

接着从 $g$ 得到 $w$ 就是背包，时间复杂度约为 $O(n(m!)^4)$。

最后由 $w$ $\text{DP}$ 出 $f$，根据定义就可以了，稍加优化时间复杂度可以降到 $O(m!Tn)$。

参考ZJOI2017 Day2题解：https://wenku.baidu.com/view/4f242987d0f34693daef5ef7ba0d4a7302766ca6.html?_wkts_=1674962588966

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define per(i,a,b) for(int i=a;i>=b;i--)
ll rd() {
	ll x = 0, f = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	do x = x * 10 + ch - 48, ch = getchar();
	while (ch >= '0' && ch <= '9');
	return x * f;
}
void wr(ll x) {
	if (x > 9) wr(x / 10);
	putchar(x % 10 + 48);
}
const int K = 7, N = 25, p[6] = {0, 1, 2, 3, 4, 0};
int t, n, k, fac[5] = {0, 1, 2, 6, 24};
map<vector<vector<int>>, int> mp[N];
int tr[N][N], mul[N][N], f[N][N][N];
ll g[55][N];
struct P {
	int a[K];
	void in() {
		rep(i, 1, k) a[i] = rd();
	}
	int getid() {
		int res = 0;
		rep(i, 1, k) {
			int sum = 0;
			rep(j, i, k) sum += a[i] > a[j];
			res += sum * fac[k - i];
		}
		return res + 1;
	}
	bool operator < (const P&x) const {
		int i = 1;
		for (; i <= k && a[i] == x.a[i]; i++);
		return i <= k && a[i] < x.a[i];
	}
	int&operator[](const int&i) {
		return a[i];
	}
	P operator * (const P&x) {
		P ans;
		rep(i, 1, k) ans[i] = a[x.a[i]];
		return ans;
	}
} pre[N], a[55];
struct sta {
	vector<int> a[3];
	int x, y;
	// 最短路
	bool work() {
		per(i, x, 0) {
			auto it = mp[i].find(vector<vector<int>>(a, a + 3));
			if (it != mp[i].end() && it->second <= y) return 0;
		}
		mp[x][vector<vector<int>>(a, a + 3)] = y;
		return 1;
	}
};
queue<sta> q;
ll F(int x) {
	return x < 1 << 24 ? x : 1ll << 60;
}
void solve() {
	memset(g[n + 1], 0, sizeof g[n + 1]);
	per(i, n, 1) {
		memset(g[i], 50, sizeof g[i]);
		int id = a[i].getid();
		rep(j, 0, N - 1)
		rep(p, 0, N - 1)
		for (int l = 0; p + l < N; l += 2)
			g[i][j] = min(g[i][j], g[i + 1][p] + ((1ll << (n - i)) - 1) * l * k + F(f[j][id][p + l]));
	}
	ll ans = 1ll << 60;
	rep(i, 0, N - 1) ans = min(ans, g[1][i]);
	wr(ans), putchar('\n');
}
signed main() {
	t = rd(), n = rd(), k = rd();
	memcpy(pre[1].a + 1, p + 1, k << 2);
	rep(i, 2, fac[k]) pre[i] = pre[i - 1], next_permutation(pre[i].a + 1, pre[i].a + k + 1);
	//末尾的 0 表示更高的若干数
	q.push((sta) {
		vector<int>(pre[1].a + 1, pre[1].a + k + 2), {}, {}, 0, 0
	});
	q.front().work();
	while (q.size()) {
		sta u = q.front(), v;
		q.pop();
		rep(i, 0, 2) if (!u.a[i].empty()) rep(j, 0, 2) if (i != j && (u.a[i].back() == 0 || (u.a[j].empty() ||	u.a[j].back() > 0))) {
				v = u;
				v.a[j].push_back(v.a[i].back());
				(v.a[i].back() ? v.y : v.x)++;
				v.a[i].pop_back();
				if (v.work()) q.push(v);
			}
	}
	int a[6];
	memcpy(a, p, sizeof a);
	memset(tr, 10, sizeof tr);
	rep(j, 1, fac[k])
	rep(i, 0, N - 1) {
		auto it = mp[i].find({{}, {}, vector<int>(pre[j].a + 1, pre[j].a + k + 2)});
		if (it != mp[i].end()) tr[i][j] = it->second;
	}
	rep(i, 1, fac[k])
	rep(j, 1, fac[k])
	mul[i][j] = (pre[i] * pre[j]).getid();
	//背包
	memset(f, 10, sizeof f);
	rep(i, 1, fac[k]) rep(j, 0, N - 1) f[1][i][j] = tr[j][i];
	rep(i, 1, N - 1)
	rep(j, 1, fac[k])
	rep(l, 1, N - 1)
	rep(r, 0, N - 1 - l)
	rep(p, 1, fac[k])
	f[i + 1][mul[j][p]][l + r] = min(f[i + 1][mul[j][p]][l + r], f[i][j][l] + tr[r][p]);
	while (t--) {
		rep(i, 1, n) ::a[i].in();
		solve();
		if (t) n = rd(), k = rd();
	}
	return 0;
}
```


---

## 作者：Union_of_Britain (赞：1)

下面第 $n$ 层盘是最大的。前几层/后几层是说 $1,2,\dots $/$n,n-1,\dots$ 层，第 $i$ 层给出的排列是 $p_i$，所以是反过来的。

回忆一般汉诺塔的解法：先把前 $n-1$ 层盘移动到 $2$ 号柱，再把第 $n$ 层盘移动到 $3$ 号柱，最后把 $2$ 号柱的 $n-1$ 层盘移动上来。在这个过程中，前 $n-1$ 层盘一定整体移动了 $2$ 次。如果直接套用此过程，会将排列复合 $\sigma_0=[K,K-1,\dots 1]$ 即翻转过来。

为了移动时正确地复原排列，可能需要移动更多次前 $n-1$ 层盘。比如 $K=2$ 时如果希望第 $n$ 层盘维持 `1 2` 状态，（对于 $K=2$ 也是唯一的）最优的方案就是 $n$ 层盘移动 $4$ 次，前 $n-1$ 层盘整体移动 $3$ 次。可以暴力表示状态使用最短路预处理 $f_{i,j}$ 表示用 $i$ 次前 $n-1$ 层盘的整体移动复原为排列 $j$ 所需第 $n$ 层盘移动的步数。这里先不管下标的值域。

注意第 $n-1$ 层盘（及之后）的移动中，可以使用多步达到目标，即由于有多次第 $n$ 层盘带来的移动前 $n-1$ 层盘，可以第 $i$ 步复原为排列 $t_i$，最终使得 $t_1\circ t_2\circ t_3\dots =p_{n-1}$ 即可（以下 一步 的意思是复原一个排列 $t$ 的若干次操作和整体操作）。因此预处理 $g_{i,j,k}$ 表示共 $i$ 步使得上层整体移动 $j$ 次，最终复原为排列 $k$ 所需最小本层移动次数。$g$ 显然可以由 $f$ 背包得到。

直接 dp 的话问题是前几层步数会非常大。但是如果上面过程只统计非 $\sigma_0$ 的 $t$ 个数 $m$，则显然有 $m\le K!$，其余复原恒等排列的直接使用 $K(2^n-1)$ 计数即可。因此上面 $f$ 的第一维和 $g$ 的第一维、第三维都只可以限制在 $K!$ 的值域。

最终计算答案设 $h_{i,j}$ 为第 $i$ 层使用了 $j$ 步复原的最小操作次数（不计数第 $i$ 层及之后的复原 $\sigma_0$）。则有：

$$h_{i, j}=h_{i-1,k}+mK2^{i-1}+g_{j,m+k,p_i}(2\mid m)$$

实际代码实现差不多是贺了上一篇的，毕竟看不懂文字部分，看代码才明白。从代码得到的另外一个事实是处理 $f$ 时，显然同样的距离让上层移动步数更少是好的，因此实际跑起来不需要对 $K!$ 取 $\min$ 之类的（这可能还要在意奇偶），因为即使 $K=4$ 时上层移动步数也不会超过 $10$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int INF=1e18;
int n,K,T,fac[5]={1,1,2,6,24};
struct perm{int p[5];}P[25],cp[55];
perm operator +(perm A,perm B){perm C;for(int i=1;i<=K;i++)C.p[i]=A.p[B.p[i]];return C;}
int Rank(perm A){int res=1;for(int i=1;i<=K;i++){for(int j=i+1;j<=K;j++)if(A.p[i]>A.p[j])res+=fac[K-i];}return res;}
#define VI vector<int>
#define VVI vector<VI>
struct state{VVI A;int d,dx;state(){A.resize(3);d=dx=0;}state(VVI B,int D,int DX){A=B,d=D,dx=DX;}};
bool operator <(state A,state B){return A.d>B.d;}
map<VVI,int> dis[26];
priority_queue<state> Q;
int f[25][25],g[25][25][25],h[55][25],d[25][25];
bool check(VVI B,int d,int dx){
	for(int i=0;i<=dx;i++)if(dis[i].count(B)&&dis[i][B]<=d)return 0;
	return dis[dx][B]=d,1;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>T>>n>>K;int fK=fac[K],F=24;
	for(int i=1;i<=K;i++)P[1].p[i]=i;
	for(int i=2;i<=fac[K];i++){
		for(int j=1;j<=K;j++)P[i].p[j]=P[i-1].p[j];
		next_permutation(P[i].p+1,P[i].p+K+1);
	}
	state S;for(int i=1;i<=K+1;i++)S.A[0].push_back(i);
	Q.push(S);dis[0][S.A]=0;
	while(Q.size()){
		auto [A,d,dx]=Q.top();Q.pop();
		if(d!=dis[dx][A])continue;
		for(int i=0;i<3;i++){
			if(A[i].empty())continue;
			for(int j=0;j<3;j++){
				if(i==j)continue;
				if(A[j].empty()||(A[j].back()!=K+1||A[i].back()==K+1)){
					int dt=(A[i].back()<K+1),dtx=1-dt;
					VVI B=A;B[j].push_back(B[i].back());B[i].pop_back();
					if(check(B,d+dt,dx+dtx))Q.push({B,d+dt,dx+dtx});
				}
			}
		}
	}
	for(int i=0;i<25;i++)for(int j=0;j<25;j++)for(int k=0;k<25;k++)f[j][k]=g[i][j][k]=INF;
	for(int i=0;i<=F;i++){
		for(int j=1;j<=fK;j++){
			VVI A(3);for(int k=1;k<=K;k++)A[2].push_back(P[j].p[k]);
			A[2].push_back(K+1);
			if(!dis[i].count(A))f[i][j]=INF;
			else f[i][j]=dis[i][A];
			g[1][i][j]=f[i][j];
		}
	}
	for(int i=1;i<=fK;i++)for(int j=1;j<=fK;j++)d[i][j]=Rank(P[i]+P[j]);
	for(int i=2;i<=F;i++)for(int j=1;j<=F;j++)for(int k=1;k<=fK;k++)for(int l=0;l<=j;l++)for(int m=1;m<=fK;m++)g[i][j][d[k][m]]=min(g[i][j][d[k][m]],g[i-1][j-l][k]+f[l][m]);
	for(int t=1;t<=T;t++){int res=INF;
		for(int j=1;j<=n;j++)for(int k=1;k<=K;k++)cin>>cp[j].p[k];
		for(int i=0;i<=n;i++)for(int j=0;j<25;j++)h[i][j]=INF;
		for(int j=0;j<25;j++)h[n+1][j]=0;
		for(int i=n;i>=1;i--){int ri=Rank(cp[i]);
			for(int j=1;j<=F;j++)for(int p=0;p<=F;p++)for(int l=0;l<=F-p;l+=2)h[i][j]=min(h[i][j],h[i+1][p]+((1ll<<n-i)-1)*K*l+g[j][p+l][ri]);
		}
		for(int i=1;i<=fK;i++)res=min(res,h[1][i]);cout<<res<<endl;
		if(t<T)cin>>n>>K;
	}
	return 0;
}
```

---


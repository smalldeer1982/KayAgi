# [ZJOI2017] 线段树

## 题目背景

线段树是九条可怜很喜欢的一个数据结构，它拥有着简单的结构、优秀的复杂度与强大的功能，因此可怜曾经花了很长时间研究线段树的一些性质。


## 题目描述

线段树是九条可怜很喜欢的一个数据结构，它拥有着简单的结构、优秀的复杂度与强大的功能，因此可怜曾经花了很长时间研究线段树的一些性质。

最近可怜又开始研究起线段树来了，有所不同的是，她把目光放在了更广义的线段树上：在正常的线段树中，对于区间 $[l, r]$，我们会取 $m = \lfloor \frac{l+r}{2} \rfloor$，然后将这个区间分成 $[l, m]$ 和 $[m + 1, r]$ 两个子区间。在广义的线段树中，$m$ 不要求恰好等于区间的中点，但是 $m$ 还是必须满足 $l \le m < r$ 的。不难发现在广义的线段树中，树的深度可以达到 $O(n)$ 级别。

例如下面这棵树，就是一棵广义的线段树：

![Segment tree](https://cdn.luogu.com.cn/upload/pic/50896.png)

为了方便，我们按照先序遍历给线段树上所有的节点标号，例如在上图中，$[2, 3]$ 的标号是 $5$，$[4, 4]$ 的标号是 $9$，不难发现在 $[1, n]$ 上建立的广义线段树，它共有着 $2n − 1$ 个节点。

考虑把线段树上的定位区间操作 $($就是打懒标记的时候干的事情$)$ 移植到广义线段树上，可以发现在广义的线段树上还是可以用传统的线段树上的方法定位区间的，例如在上图中，蓝色节点和蓝色边就是在定位区间 $[2, 4]$ 时经过的点和边，最终定位到的点是 $[2, 3]$ 和 $[4, 4]$。

如果你对线段树不熟悉，这儿给出定位区间操作形式化的定义：给出区间 $[l, r]$，找出尽可能少的**区间互不相交**的线段树节点，使得它们区间的并集**恰好**是 $[l, r]$。

定义 $S_{[l,r]}$ 为定位区间 $[l, r]$ 得到的点集，例如在上图中，$S_{[2,4]} = \{5, 9\}$。定义线段树上两个点 $u, v$ 的距离 $d(u, v)$ 为线段树上 $u$ 到 $v$ 最短路径上的边数，例如在上图中 $d(5, 9) = 3$。

现在可怜给了你一棵 $[1, n]$ 上的广义的线段树并给了 $m$ 组询问，每组询问给出三个数 $u, l, r\ (l \le r)$，可怜想要知道 $\sum_{v \in S_{[l, r]}} d(u, v)$。

## 说明/提示

|  测试点编号   |         $n$         |         $m$         | 其他约定  |   
| :------: | :-----------------: | :-----------------: | :---: |   
|    $1$     |      $\le 100$      |      $\le 100$      |   无   |    
|    $2$     | $\le 2 \times 10^5$ |      $\le 20$       |   无   |    
|   $3,4$    | $\le 2 \times 10^5$ | $\le 2 \times 10^5$ | $r=n$ |    
|   $5,6$    | $\le 2 \times 10^5$ | $\le 2 \times 10^5$ | $u=1$ |    
| $7,8,9,10$ | $\le 2 \times 10^5$ | $\le 2 \times 10^5$ |   无   |    

对于 $100\%$ 的数据，保证 $n \ge 2, m \ge 1$。

## 样例 #1

### 输入

```
10
3 1 2 9 6 4 5 7 8
3
7 6 7
18 4 5
14 5 6
```

### 输出

```
7
11
3```

# 题解

## 作者：Aleph1022 (赞：34)

这题能黑了是因为洛谷仅有的题解都是些滥用数据结构的解法么……（

考虑一棵广义线段树的形态，和定位区间所得的结点的性质。

对于定位区间 $[l,r]$ 的过程，可以考虑 $[l-1,l-1]$ 和 $[r+1,r+1]$ 对应的结点和它们的 LCA（分别设为 $L,R,U$）。  
注意到定位出来的区间都是 $L$ 到 $U$ 左儿子链上所有结点的在链以外的右儿子和 $R$ 到 $U$ 右儿子链上所有结点的在链以外的左儿子。  
那么问题便是算 $u$ 与这些结点的距离和。  
不难想到转化为深度和减去 $2$ 倍的 LCA 的深度和。

显然地，可以离线下来，暴力地使用数据结构 $O((n+m) \log^2 n)$ 或 $O((n+m)\log n)$ 维护（  
实际上没必要，因为这些结点具有比较优美的性质，所以可以通过分类讨论解决。

若 $u$ 不在 $U$ 的子树内或恰为 $U$，则显然这些结点与 $u$ 的 LCA 即为 $u$ 与 $U$ 的 LCA。  
若 $u$ 在 $U$ 的左子树内，设 $u$ 与 $L$ 的 LCA 为 $x$，则 $U$ 右子树内与 $u$ 的 LCA 均为 $U$；左子树中 $x$ 以下的结点与 $u$ 的 LCA 显然为 $x$，而 $x$ 至 $U$ 的左儿子段都是 $u$ 的祖先。  
注意特判 $u$ 在 $x$ 的右子树内的情况，此时 LCA 应为 $x$ 的右儿子。  
若 $u$ 在 $U$ 的右子树内，与前一情况类似。  

线性预处理出每个结点到根链上在链以外的左 / 右儿子个数和深度和即可。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 4e5 + 3;
const int LG = 19;
int n,m,tot;
int pos[N + 5],rt;
int ch[N + 5][2],dep[N + 5],fa[N + 5],sz[N + 5],id[N + 5];
int f[LG + 5][N + 5];
int cnt[N + 5][2];
long long sum[N + 5][2];
int build(int l,int r)
{
    int p = ++tot;
    if(l == r)
        return pos[l] = p;
    int mid;
    scanf("%d",&mid);
    ch[p][0] = build(l,mid),
    ch[p][1] = build(mid + 1,r);
    return p;
}
void dfs1(int p)
{
    static int tot = 0;
    id[p] = ++tot,sz[p] = 1;
    for(register int i = 1;i <= LG;++i)
        f[i][p] = f[i - 1][f[i - 1][p]];
    for(register int i = 0;i <= 1;++i)
        if(ch[p][i])
            fa[ch[p][i]] = f[0][ch[p][i]] = p,
            dep[ch[p][i]] = dep[p] + 1,
            dfs1(ch[p][i]),
            sz[p] += sz[ch[p][i]];
}
void dfs2(int p)
{
    for(register int i = 0;i <= 1;++i)
        if(ch[p][i])
        {
            for(register int j = 0;j <= 1;++j)
                cnt[ch[p][i]][j] = cnt[p][j],
                sum[ch[p][i]][j] = sum[p][j];
            if(ch[p][i ^ 1])
                ++cnt[ch[p][i]][i ^ 1],
                sum[ch[p][i]][i ^ 1] += dep[ch[p][i ^ 1]];
            dfs2(ch[p][i]);
        }
}
inline int getlca(int x,int y)
{
    if(dep[x] < dep[y])
        swap(x,y);
    for(register int i = LG;~i;--i)
        if(dep[f[i][x]] >= dep[y])
            x = f[i][x];
    if(x == y)
        return x;
    for(register int i = LG;~i;--i)
        if(f[i][x] ^ f[i][y])
            x = f[i][x],y = f[i][y];
    return fa[x];
}
long long ans;
int main()
{
    scanf("%d",&n),build(1,n);
    rt = ++tot,
    ch[rt][0] = pos[0] = ++tot,ch[rt][1] = 1;
    rt = ++tot,
    ch[rt][0] = rt - 2,ch[rt][1] = pos[n + 1] = ++tot;
    dep[rt] = 1,dfs1(rt),dfs2(rt);
    scanf("%d",&m);
    for(int u,l,r,lca,x,ls,rs;m;--m)
    {
        scanf("%d%d%d",&u,&l,&r),
        lca = getlca(l = pos[l - 1],r = pos[r + 1]),ls = ch[lca][0],rs = ch[lca][1],
        ans = (sum[l][1] - sum[ls][1] + sum[r][0] - sum[rs][0]) + (long long)dep[u] * (cnt[l][1] - cnt[ls][1] + cnt[r][0] - cnt[rs][0]);
        if(id[u] <= id[lca] || id[u] >= id[lca] + sz[lca])
            x = getlca(u,lca),
            ans -= 2LL * dep[x] * (cnt[l][1] - cnt[ls][1] + cnt[r][0] - cnt[rs][0]);
        else if(id[u] >= id[ls] && id[u] < id[ls] + sz[ls])
            x = getlca(u,l),
            ans -= 2LL * dep[lca] * (cnt[r][0] - cnt[rs][0]),
            ans -= 2LL * dep[x] * (cnt[l][1] - cnt[x][1]),
            ans -= 2LL * ((sum[x][1] - sum[ls][1]) - (cnt[x][1] - cnt[ls][1])),
            id[u] >= id[ch[x][1]] && id[u] < id[ch[x][1]] + sz[ch[x][1]] && (ans -= 2);
        else
            x = getlca(u,r),
            ans -= 2LL * dep[lca] * (cnt[l][1] - cnt[ls][1]),
            ans -= 2LL * dep[x] * (cnt[r][0] - cnt[x][0]),
            ans -= 2LL * ((sum[x][0] - sum[rs][0]) - (cnt[x][0] - cnt[rs][0])),
            id[u] >= id[ch[x][0]] && id[u] < id[ch[x][0]] + sz[ch[x][0]] && (ans -= 2);
        printf("%lld\n",ans);
    }
}
```


---

## 作者：shadowice1984 (赞：16)

丢人全局平衡二叉树，打不过树剖套树状数组……

这份[评测记录](https://www.luogu.org/recordnew/show/16295228)是$O(nlogn)$的全局平衡二叉树

这份[评测记录](https://www.luogu.org/recordnew/show/16296205)是$O(nlog^2n)$的树剖套树状数组

常数差别立判高下……

先说好这题是有结论的但是我懒了所以这题的后半部分我直接用数据结构硬上了……

想知道那个神奇的结论的同学可以去康题解
__________________

# 本题题解

题意已经肥肠清楚了，此处无需赘述了

那么我们首先需要理解线段树的"拆分"操作的本质究竟是什么

事实上有这样一个结论，线段树的拆分代码当中，之多有一次同时向左向右递归，其他情况下都是不断的向左递归和向右递归

并且，同时向左向右递归的那个节点就是节点$(l,l)$和$(r,r)$在线段树上的lca，因为lca的划分点一定分开了$l$和$r$

所以我们线段树的拆分的实质就是在lca处将$(l,r)$分成了$(l,lca.mid)$和$(lca.mid,r)$这两个区间

那么我们考虑lca的左子树和右子树，你会发现接下来我们要做的事情就是在lca的左子树$(lca.l,lca.mid)$拆分$(l,lca.mid)$这个区间以及在lca的右子树$(lca.mid,lca.r)$处拆分$(lca.mid,r)$这个区间

那么你会发现相对于lca的左子树来讲我们拆分的是一个后缀。

相对于lca的右子树来讲我们拆分的区间是一个前缀

那么我们将拆分区间转化成了拆分前缀和后缀之后又有什么用呢？

下面我们来研究一下拆分前缀时的性质，后缀与之类似

当我们拆分的区间是一个前缀的时候，我们发现拆分出来的节点都是左儿子，除非我们拆的是$(1,n)$这个前缀，此时我们选择的节点是根节点

因此我们可以仅仅保留线段树的所有左儿子，这样我们就得到了这样的一个树

![](http://p0.so.qhimgs1.com/bdr/_240_/t01b3cd94b11782f024.png)


wow，我们得到了一株树状数组！

~~事实上树状数组本质上就是仅仅保留左儿子的zkw线段树~~

回想一下树状数组的查找前缀代码

```cpp

for(int x=p;x;x-=x&(-x))res+=ta[x];

```

你会发现我们其实做的事情就是每次将$x$迭代成$x-lowbit(x)$，这东西可以理解成一个不断向上跳父亲的过程，换句话说，如果我们将树状数组中的节点$x$和$x-lowbit(x)$连边，我们就得到了一颗"前缀树",其中(1,x)的拆分就是点x到0路径上的所有节点

那么我们现在也需要处理拆分前缀和后缀，所以我们需要建出来一个类似于广义树状数组一类的东西，由于现在是一颗普普通通的线段树，所以没有lowbit这么nb的东西可以帮助我们找父亲了，我们必须手动把树状数组建出来

这里以建前缀树状数组为例，注意一个节点在树状数组上的父亲和在线段树上的父亲**不同**

在线段树上dfs，假设我们dfs到了p，并且已经知道了这个节点在树状数组上的father是谁

我们先dfsp的左儿子，并且左儿子的father和p的father相同

然后我们dfsp的右儿子，将右儿子的father设成左儿子

然后删掉所有在线段树上是右儿子的点，我们就得到了一颗广义树状数组，这个算法的正确性可以大力归纳法证明一下，如果整不出来还可以手玩一下

那么我们发现当我们在线段树的一个子树当中拆分一个前缀的时候，我们拆分出来的节点在广义树状数组上是一条直上直下的路径

所以现在的问题就是有两颗树，每次给出一个点集$S(u,v)$和一个询问点p，询问

$$\sum_{q \in S(u,v)} T1.dis(p,q)$$

而$S(u,v)$指的是第二颗树上u到v路径上的所有点构成的集合，保证u是v的祖先

那么我们解决问题的手段非常简单粗暴

$$\sum_{q \in S(u,v)} dep(p)+dep(q)-2dep(T1.lca(p,q))$$

$$|S(u,v)|dep(p)+\sum_{q \in S(u,v)}dep(q)-2\sum_{q \in S(u,v)}dep(T1.lca(p,q))$$

好了接下来是一个经典问题，如何求一个点到一堆点的lca深度之和呢？

答案是让这一堆点都做一个到根的路径+1的链加操作，最后求询问点到根路径的和就是这个点到这一堆点的lca深度之和了，正确自己画图玩玩就出来了

那么我们就有了解决这个问题的思路了

现在我们希望被执行链加的集合是$S(u,v)$，那么我们将询问离线，然后拆成$S(1,v)-S(1,fa(u))$这两个询问，我们需要做的就是快速回答$S(1,p)$这样的询问

在第二颗树上dfs，dfs到u的时候让u到根的路径上+1，dfs完u之后让u到根的路径上-1，如此这般处理，我们在dfs到u的时候只有u在第二颗路径上到根的点在第一颗树上被做了路径+1的操作，此时我们询问一下询问点到根的和就可以回答$S(1,u)$这样的询问了

所以我们需要实现的底层数据结构就是一个资瓷链加和链上求和的数据结构，如果我们使用全局平衡二叉树的话我们可以达到$O(nlogn)$的优秀复杂度，然鹅现实是这东西太丢人了……

所以我们选择树剖套树状数组，常数小并且好写~

现在唯一的问题是如何快速的将一个区间$(l,r)$拆成树状数组上的一条路径

首先由于我们仅仅保留了所有的左儿子和根节点，因此所有节点的右端点互不相同，那么我们可以对于每一个右端点记录一下它对应着那个节点，这样我们就找到了底下的节点了，接下来我们在树状数组上倍增一下就能找到另外一个节点了

然后这题就做完了，细节方面就是特判一下lca就是拆分节点以及拆分前缀后缀的时候如果拆出来的是lca左右儿子那么这个点可以不在树状数组上

复杂度$O(nlogn)/O(nlog^2n)$

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;const int N=4*1e5+10;typedef long long ll;struct opt{int id;int u;};
template <typename T>
inline void gm(T*& bas,int siz,T*& op){op=bas;bas+=siz;}int n;int m;ll ans[N];int dep[N];
namespace INPUT_SPACE{
    const int BS=(1<<24)+5;char Buffer[BS],*HD,*TL;
    char gc() { if(HD==TL) TL=(HD=Buffer)+fread(Buffer,1,BS,stdin);return (HD==TL)?EOF:*HD++; }
    inline int inn()
    {
        int x,ch,sgn=1;while(((ch=gc())<'0'||ch>'9')&&ch!='-');
        if(ch=='-') sgn=-1,x=0;else x=ch^'0';
        while((ch=gc())>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^'0');
        return x*sgn;
    }
}using INPUT_SPACE::inn;
namespace Tree
{
    ll B_bas[N<<1];ll* B_t;int A_bas[N<<1];int* A_t;int id[N];
    struct tra//树状数组支持区间加区间求和 
    {
    	int* ta1;ll* ta2;int len;
        inline void stadd(int pos,int pl)
        {
            for(int x=pos;x;x-=x&(-x))ta1[x]+=pl;pl*=pos;
            for(int x=pos;x<=len;x+=x&(-x))ta2[x]+=pl;
        }
        inline ll sum(int pos)
        {
            ll res1=0;for(int x=pos+1;x<=len;x+=x&(-x))res1+=ta1[x];
    		ll res2=0;for(int x=pos;x;x-=x&(-x))res2+=ta2[x];return pos*res1+res2;
        }
        inline void cbuild(int* q,int tot)
        {len=tot;gm(B_t,tot+1,ta2);gm(A_t,tot+1,ta1);for(int i=1;i<=len;i++)id[q[i]]=i;}
    }lt[N];int v[N<<1];int x[N<<1];int ct;int al[N];int siz[N];int top[N];
    int h[N];int fa[N];int q[N];int hd;
    inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
    inline int dfs(int u)
    {
        for(int i=al[u];i;i=x[i])
            fa[v[i]]=u,siz[u]+=dfs(v[i]),h[u]=(siz[v[i]]>siz[h[u]])?v[i]:h[u];return ++siz[u];
    }
    inline void solve(int u)
    {
        for(int p=u;p;p=h[p])
            for(int i=al[p];i;i=x[i])if(v[i]!=h[p])solve(v[i]);hd=0;
        for(int p=u;p;p=h[p])q[++hd]=p,top[p]=u;lt[u].cbuild(q,hd);
    }
    inline void modi(int u,int pl){for(int p=u;p;p=fa[top[p]])lt[top[p]].stadd(id[p],pl);}
    inline ll qry(int u){ll res=0;for(int p=u;p;p=fa[top[p]])res+=lt[top[p]].sum(id[p]);return res;}
}
namespace Tree1//广义树状数组 
{
    int v[N<<1];int x[N<<1];int ct;int al[N];vector <opt> ve[N];
    inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
    inline void pb(int u,opt nod){ve[u].push_back(nod);}
    inline void dfs(int u,ll sum,int cnt)
    {
    	sum+=dep[u];cnt++;Tree::modi(u,1);
        for(vector <opt>:: iterator it=ve[u].begin();it!=ve[u].end();++it)
        {
            int op=(it->u<0)?-1:1;it->u*=op;
            ans[it->id]+=op*(sum+(ll)cnt*(dep[it->u]+2)-2*Tree::qry(it->u));
        }for(int i=al[u];i;i=x[i])dfs(v[i],sum,cnt);Tree::modi(u,-1);
    }
    inline void clr()
    {for(int i=1;i<=n;i++)al[i]=0;ct=0;for(int i=1;i<=n;i++)ve[i].clear();}
}
namespace SegTree
{
    int mid[N];int s[N][2];int fa[N][22];int pl[N];int pr[N];int sfa[N];
    int ct;int fuc[N];int bas[N];struct qry{int u;int l;int r;int lc;}qr[N];
    inline void ctr(int p,int l,int r)
    {
        for(int i=0;fa[p][i];i++)fa[p][i+1]=fa[fa[p][i]][i];
        pl[p]=l+1;pr[p]=r;bas[r]=p;if(r-l==1)return;mid[p]=inn();
        s[p][0]=++ct;fa[ct][0]=p;dep[ct]=dep[p]+1;ctr(ct,l,mid[p]);
        s[p][1]=++ct;fa[ct][0]=p;dep[ct]=dep[p]+1;ctr(ct,mid[p],r);
    }
    inline void csuf(int p,int f,int tp)//建后缀树 
    {
        if(tp==1){if(f)Tree1::add(f,p),sfa[p]=f;fuc[pl[p]]=p;}
        if(s[p][0])csuf(s[p][0],s[p][1],0),csuf(s[p][1],f,1);
    }
    inline void cpre(int p,int f,int tp)//建前缀树 
    {
        if(tp==0){if(f)Tree1::add(f,p),sfa[p]=f;fuc[pr[p]]=p;}
        if(s[p][1])cpre(s[p][1],s[p][0],1),cpre(s[p][0],f,0);
    }
    inline int lca(int u,int v)
    {
        if(dep[u]<dep[v])swap(u,v);for(int d=dep[u]-dep[v],i=0;d;d>>=1,i++)if(d&1)u=fa[u][i];
        if(u==v)return u;for(int i=19;i>=0;i--)if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];
        return fa[u][0];
    }
    inline void mainsolve()
    {
        n=inn();ct=1;ctr(1,0,n);m=inn();
        for(int i=1;i<=m;i++)qr[i].u=inn(),qr[i].l=inn(),qr[i].r=inn();
        for(int i=1;i<=ct;i++)if(s[i][0])Tree::add(i,s[i][0]),Tree::add(i,s[i][1]);
        Tree::dfs(1);Tree::solve(1);//前后各做一次树上差分 
        for(int i=1;i<=m;i++)qr[i].lc=lca(bas[qr[i].l],bas[qr[i].r]);csuf(1,0,1);
        for(int z=1,l,r,p;z<=m;z++)
        {
            l=qr[z].l;r=qr[z].r;p=qr[z].lc;if(l==pl[p]&&r==pr[p])continue;
            if(l==pl[p]){ans[z]+=dep[qr[z].u]+dep[s[p][0]]-2*dep[lca(qr[z].u,s[p][0])];continue;}
            Tree1::pb(fuc[l],(opt){z,qr[z].u});int t=bas[mid[p]];
            for(int i=19;i>=0;i--)if(fa[t][i]&&l<=pl[fa[t][i]])t=fa[t][i];
            if(sfa[t])Tree1::pb(sfa[t],(opt){z,-qr[z].u});
        }for(int p=1;p;p=s[p][1])Tree1::dfs(p,0,0);Tree1::clr();
        for(int i=1;i<=n;i++)sfa[i]=0;cpre(1,0,0);
        for(int z=1,l,r,p;z<=m;z++)
        {
            l=qr[z].l;r=qr[z].r;p=qr[z].lc;if(l==pl[p]&&r==pr[p])continue;
            if(r==pr[p]){ans[z]+=dep[qr[z].u]+dep[s[p][1]]-2*dep[lca(qr[z].u,s[p][1])];continue;}
            Tree1::pb(fuc[r],(opt){z,qr[z].u});int t=bas[mid[p]+1];
            for(int i=19;i>=0;i--)if(fa[t][i]&&pr[fa[t][i]]<=r)t=fa[t][i];
            if(sfa[t])Tree1::pb(sfa[t],(opt){z,-qr[z].u});
        }for(int p=1;p;p=s[p][0])Tree1::dfs(p,0,0);
        for(int z=1,l,r,p;z<=m;z++)
        {
            l=qr[z].l;r=qr[z].r;p=qr[z].lc;
                if(l==pl[p]&&r==pr[p])ans[z]=dep[qr[z].u]+dep[p]-2*dep[lca(qr[z].u,p)];
        }for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
    }
}int main(){Tree::B_t=Tree::B_bas;Tree::A_t=Tree::A_bas;SegTree::mainsolve();return 0;}//拜拜程序~ 
```
















---

## 作者：WB_TS_欧寒 (赞：3)

[P5210 [ZJOI2017]线段树](https://www.luogu.org/problem/P5210)
# <1>题目分析
### 处理广义线段树的一类~~套路~~方法。

    1. 首先，定义原来的线段树为原树，并且将其改造一下，使得它能够管理的区间为 [0,n+1]。

    2. 定义左偏树（跟一种可并堆重名了 2333）为一棵将原树上，所有是左儿子的点提取出来，构成的一棵树，每个点的父亲，是代表在其左边，与其代表区间相邻的区间，且深度比它浅的节点。画出来是这样的：

    3. 我想我需要一块手绘板：
   [1-1](D:\360安全浏览器下载\1-1)

    4. 定义右偏树为提取右儿子们，与在它右边深度比它浅的第一个节点相连的树。

    5. 左偏树可以在遍历原树时，开个栈，每次先将当前点的左儿子与栈顶元素相连，然后将当前点左儿子压入栈，遍历当前点右子树，再将左儿子弹出栈，再遍历左子树，如此得到。右偏树类似。

    6. 接下来，对于一个询问 (x,l,r)，首先找到代表区间 [l−1,l−1]的点 k1k1和代表区间 [r+1,r+1]的点 k2（这也就是要改造原树使它能够控制区间 [0,n+1]的原因），然后求出它们的 LCA，点 o。

    7. 不难发现，k1到 o的路径上经过的所有点，若它的右儿子没被经过，则右儿子在 S[l,r]中，并且这些点还对应了一条右偏树上的链。从 k2到 o路径上，那些点的左儿子也有类似的性质。

    8. 若 k1k1为一个左儿子，则这条右偏树上链最深点为它的兄弟。若它是右儿子，则最深点为其在右偏树上的父亲。而最浅点的父亲为 o的右儿子。（k2部分类似，略过）

    9. 若 dfs 一次右偏树，每进入一个点 x，序列末尾加一个元素 +x，表示处理序列一个前缀处理到此，要将 x加入集合。离开 x时，加入 −x，表示要将 x从集合中 ban 掉。那么一个询问在右偏树上构成的那条链，就是最深点的正位置的前缀操作一遍剩下的集合的贡献，减去最浅点父亲正位置的集合的前缀贡献。

    10. 于是我们将询问离线，顺序处理，每次维护一个前缀的贡献，然后再加加减减就可以得到答案了。

    11. 而询问(x,l,r)要问的东西等价于问

    depx|S[l,r]|+∑y∈S[l,r]depy−2∑y∈S[l,r]deplca(x,y)
    depx|S[l,r]|+∑y∈S[l,r]depy−2∑y∈S[l,r]deplca(x,y)
    前两项只要维护当前集合的元素个数和元素 depdep和即可，很简单，后一项呢？

    12. 也不难，每将一个 y加入集合，就在所有 yy的祖先处把一个标记+1，ban 掉时-1，则 x的所有祖先的标记和，就是 lca 的深度和。可以用树链剖分＋线段树维护。
    
	<2>Code
```cpp
#include <bits/stdc++.h>
    using namespace std;
    #define RI register int
    int read()
    {
        int q=0;
        char ch=' ';
        while(ch<'0'||ch>'9')
            ch=getchar();
        while(ch>='0'&&ch<='9')
            q=q*10+ch-'0',ch=getchar();
        return q;
    }
    typedef long long LL;
    const int maxN=400010;
    int n,m,SZ_A,rt_A,st_top,js1,js2,tim,son[maxN][2],fa[maxN],st[maxN],pos[maxN],dep[maxN],sz[maxN],top[maxN],dfn[maxN];
    LL ans[maxN];
    struct node
    {
        int p,x,v,id;
    } q1[maxN<<1],q2[maxN<<1];
    bool cmp(node A,node B)
    {
        return A.p<B.p;
    }
    struct segment_tree
    {
        LL sum[maxN<<2],lz[maxN<<2];
        void build(int s,int t,int i)
        {
            sum[i]=lz[i]=0;
            if(s==t) return;
            int mid=(s+t)>>1;
            build(s,mid,i<<1),build(mid+1,t,(i<<1)|1);
        }
        void put_lz(int s,int t,int i,int v)
        {
            lz[i]+=v,sum[i]+=1LL*(t-s+1)*v;
        }
        void pd(int s,int t,int i)
        {
            int mid=(s+t)>>1;
            put_lz(s,mid,i<<1,lz[i]),put_lz(mid+1,t,(i<<1)|1,lz[i]),lz[i]=0;
        }
        void modify(int l,int r,int s,int t,int i,int v)
        {
            if(l<=s&&t<=r)
            {
                put_lz(s,t,i,v);
                return;
            }
            int mid=(s+t)>>1;
            if(lz[i])
                pd(s,t,i);
            if(l<=mid)
                modify(l,r,s,mid,i<<1,v);
            if(mid+1<=r)
                modify(l,r,mid+1,t,(i<<1)|1,v);
            sum[i]=sum[i<<1]+sum[(i<<1)|1];
        }
        LL query(int l,int r,int s,int t,int i)
        {
            if(l<=s&&t<=r)
                return sum[i];
            int mid=(s+t)>>1;
            LL re=0;
            if(lz[i])
                pd(s,t,i);
            if(l<=mid)
                re=query(l,r,s,mid,i<<1);
            if(mid+1<=r)
                re+=query(l,r,mid+1,t,(i<<1)|1);
            return re;
        }
    } ST;
    void walk(int x,int v)
    {
        while(x)
            ST.modify(dfn[top[x]],dfn[x],1,SZ_A,1,v),x=fa[top[x]];
    }
    LL q_walk(int x)
    {
        LL re=0;
        while(x)
        {
            re+=ST.query(dfn[top[x]],dfn[x],1,SZ_A,1);
            x=fa[top[x]];
        }
        return re;
    }
    struct Tree
    {
        int h[maxN],ne[maxN],to[maxN],p[maxN],pos[maxN],fa[maxN],tot,js;
        void add(int x,int y)
        {
            to[++tot]=y;
            ne[tot]=h[x];
            h[x]=tot;
        }
        void build(int x,int o)
        {
            if (!son[x][0] && !son[x][1])
                return ;
            fa[son[x][o]]=st[st_top],add(st[st_top],son[x][o]),
                          st[++st_top]=son[x][o];
            build(son[x][o^1],o),--st_top,build(son[x][o],o);
        }
        void dfs(int x)
        {
            p[++js]=x,pos[x]=js;
            for (RI i=h[x]; i; i=ne[i])
                dfs(to[i]);
            p[++js]=-x;
        }
        void work(node *q,int qjs)
        {
            sort(q+1,q+1+qjs,cmp),ST.build(1,SZ_A,1);
            LL now_sumd=0,now_sum=0;
            for(RI i=1,j=1; i<=js; ++i)
            {
                if(p[i]<0) now_sumd-=dep[-p[i]],--now_sum,walk(-p[i],-1);
                else now_sumd+=dep[p[i]],++now_sum,walk(p[i],1);
                while(j<=qjs&&q[j].p==i)
                {
                    LL tmp=now_sumd+now_sum*(LL)dep[q[j].x]-2*q_walk(q[j].x);
                    ans[q[j].id]+=q[j].v*tmp,++j;
                }
            }
        }
    } lT,rT;
    void build_A(int &x,int s,int t)
    {
        x=++SZ_A;
        if(s==t)
        {
            pos[s]=x;
            return;
        }
        int mid=read();
        build_A(son[x][0],s,mid),build_A(son[x][1],mid+1,t);
    }
    void dfs1(int x,int las)
    {
        sz[x]=1,fa[x]=las,dep[x]=dep[las]+1;
        if(son[x][0]) dfs1(son[x][0],x),sz[x]+=sz[son[x][0]];
        if(son[x][1]) dfs1(son[x][1],x),sz[x]+=sz[son[x][1]];
    }
    void dfs2(int x)
    {
        dfn[x]=++tim;
        if(!son[x][0]&&!son[x][1]) return;
        if(sz[son[x][0]]>sz[son[x][1]])
        {
            top[son[x][0]]=top[x],dfs2(son[x][0]);
            top[son[x][1]]=son[x][1],dfs2(son[x][1]);
        }
        else
        {
            top[son[x][1]]=top[x],dfs2(son[x][1]);
            top[son[x][0]]=son[x][0],dfs2(son[x][0]);
        }
    }
    int lca(int x,int y)
    {
        while(top[x]!=top[y]) dep[top[x]]>dep[top[y]]?x=fa[top[x]]:y=
                        fa[top[y]];
        return dep[x]<dep[y]?x:y;
    }
    int is(int x)
    {
        return son[fa[x]][1]==x;
    }

    int main()
    {
        n=read();
        build_A(rt_A,1,n);
        ++SZ_A,son[SZ_A][0]=rt_A;
        ++SZ_A,son[SZ_A-1][1]=SZ_A,pos[n+1]=SZ_A;
        ++SZ_A,son[SZ_A][1]=SZ_A-2,rt_A=SZ_A;
        ++SZ_A,son[SZ_A-1][0]=SZ_A,pos[0]=SZ_A;
        dfs1(rt_A,0),top[rt_A]=rt_A,dfs2(rt_A);
        st[++st_top]=rt_A,lT.build(rt_A,0),rT.build(rt_A,1);
        lT.dfs(rt_A),rT.dfs(rt_A);
        m=read();
        for(RI i=1; i<=m; ++i)
        {
            int x=read(),l=read(),r=read();
            int k1=pos[l-1],k2=pos[r+1],o=lca(k1,k2);
            q1[++js1]=(node)
            {
                lT.pos[son[o][0]],x,-1,i
            };
            if(is(k2)) q1[++js1]=(node)
            {
                lT.pos[son[fa[k2]][0]],x,1,i
            };
            else q1[++js1]=(node)
            {
                lT.pos[lT.fa[k2]],x,1,i
            };
            q2[++js2]=(node)
            {
                rT.pos[son[o][1]],x,-1,i
            };
            if(is(k1)) q2[++js2]=(node)
            {
                rT.pos[rT.fa[k1]],x,1,i
            };
            else q2[++js2]=(node)
            {
                rT.pos[son[fa[k1]][1]],x,1,i
            };
        }
        lT.work(q1,js1),rT.work(q2,js2);
        for(RI i=1; i<=m; ++i)
            cout<<ans[i]<<endl;
        return 0;
    }
```


---

## 作者：A_Sunny_Day (赞：2)

# 「ZJOI2017」线段树

给一个无脑暴力的写法。想法十分简单，就是有~~亿点点~~难写。

首先考虑将问题特殊化。

假设是让给出若干个点，求其到某一个点的距离之和。

那么答案是:
$$
\sum_v dep_v+dep_u-2\times dep_{lca}
$$
注意到只要快速算出 $dep_{lca}$ 之和即可。

考虑进行如下操作：

对于每个 $v$，使 $v$ 到根节点路径上所有边的边权 $+1$。

显然最后对 $u$ 求出 $u$ 到根节点路径上所有边的边权和就是 $dep_{lca}$ 之和。

那么就是一个链加链和问题。可以用树剖解决。

那么再考虑将问题泛化。

如果询问的 $l$ 端点永远是 $1$。

那么我们只要离线询问，然后维护 $S_{[1,i]}$ 即可。维护了 $S_{[1,i]}$ 之后问题就变成上面那个问题了。

现在问题是如何维护 $S_{[1,i]}$。

需要一个简单的结论。

结论 $1$ ，对于一个点 $u$，设其管辖的区间为 $[l_u,r_u]$。那么对于一个点 $v$ 满足 $[l_v,r_v]$ 包含了 $[l_u,r_u]$，$v$ 一定是 $u$ 的祖先。

考虑维护一个栈，维护了 $S_{[1,i]}$。

即有 $[L_{S_1},R_{S_1}]\cup\dots\cup[L_{S_k},R_{S_k}]=[1,i]$。

且栈中任意两元素所管辖的区间交为空集。

所以我们找到管辖 $[i,i]$ 区间的点 $u$。然后一直向上爬它的父亲，直到 $r_{fa_u}>i$ 为止。那么这个点就是满足其管辖区间右端点为 $i$，且区间长度最大的点，然后我们一直弹出栈顶直到满足栈顶与 $u$ 管辖的区间没有交集为止。

其正确性显然。

那么这个问题就解决了。 

然后再将问题泛化。

现在我们要求的问题与原问题相同。

容易想到利用上个问题的减法加上差分来解决这个问题。

但是注意到，我们直接利用差分将栈中所有包含非询问区间的点的贡献减去后，并不是正确的答案。而是少了一部分。（当然也有可能减去后剩下的点的并集刚好是询问区间，那么就不用算接下来的了，也就是点不会被**拆**的情况）

即栈中可能有一个节点 $p$ 管辖的区间满足 $l_p<l_q\le r_p$。那么我们肯定是要减去这个节点的贡献的，但是 $[l_q,r_p]$ 这个区间的贡献就被我们忽略了。

考虑找个方法加上这个区间的贡献。

注意到这样的节点 $p$ 只会存在一个，也就是只有一个点 $p$ 会被**拆**成若干个点。

我们可以考虑这若干个点的位置。

显然这若干个点只可能在 $p$ 的子树内。

下面用一个区间来表示**恰好**管辖这个区间的点。

考虑几个显而易见的结论。

结论 $2$ 。

我们思考当什么时候节点 $u$ 管 辖的区间是满足其管辖的区间是询问的区间的子集。

即其**子树下所有管辖区间都是询问区间的子集**的条件下，节点 $u$ 管辖的区间是询问区间的子集。

（~~看起来好像很没有用，但是实际上非常有用~~）

结论 $3$。

再考虑什么时候节点 $u$ 是能对询问区间做出贡献的。

即**其父亲不能对询问区间做出贡献**。

那么结合一下。

一个节点 $u$ 能做出贡献**当且仅当其父亲的另一个儿子所在子树内存在节点管辖的区间不是询问区间的子集**。

那么我们找到所有点满足其管辖的区间 $[a,a]\in[l_p,l_q-1]$。我们将所有满足这样条件的点到 $p$ 的路径上的点全部覆盖一遍（也可以理解成染色）。

那么 $p$ 的子树内剩下的未被覆盖的点一定是若干个子树。那么有贡献的点就是若干个子树的根。

由结论 $1$ 可知这是正确的。

我们要快速得到这若干个子树的根。

然后再考虑一个结论。

结论 $4$

然后我们注意到由于这是一棵线段树，那么对于 $[i+k,i+k]$ 的所有祖先，其一定是 $[i,i]$ 的祖先或者 位于$[i,i]$ 某个祖先的右子树内。

虽然看起来结论很多，但其实都是显而易见的东西。

结合一下结论 $2,3,4$ 我们可以发现，我们要求的点不是 $[a_p,a_p]$（$a_p$ 表示任意一个处于 $[l_p,l_q-1]$ 内的点） 的祖先，但是得是 $[a_q,a_q]$（$a_q$ 表示任意一个处于  $[ l_q,r_p ]$ 内的点） 的祖先。

然后考虑一下结论四，我们可以发现，上述那个方法可以被优化了。

我们只需要将找到最右端的 $a_p$ 即 $l_q-1$。然后将 $[l_q-1,l_q-1]$ 到 $[l_p,l_q-1]$ 路径上的点全部覆盖。

然后忽略被覆盖点的左子树，因为其左子树中肯定有点管辖的区间不是询问区间的子集。（根据结论 $1,4$ 可得。）

那么没有被覆盖的产生的子树的根就是 $[l_q-1,l_q-1]$ 到 $[l_p,l_q-1]$ **这条链上的所有不在这条链上的右儿子 **。（是右儿子不是右子树）

简单来说要**同时**满足两个条件：

1. 不在这条链上。
2. 是这条链上某个点的右儿子。

那么这若干个点的位置就被我们求得了。

现在要求的是如何求出这若干个点到询问的点 $u_q$ 的距离。

依旧是考虑利用深度计算，我们先通过倍增跳到一个点 $t$，满足 $t$ 在这条链（或者这条链链首的祖先上，即 $[l_p,l_q-1]$ 的祖先）上，且 $t$ 是 $u_q$ 的祖先中距离 $u_q$ 最小的一个。

那么在 $t$ 之下（深度比它大）的有贡献的点和它的 $lca$ 就是 $t$。$t$ 之上有贡献的点和他的 $lca$ 就是有贡献点的父亲（他肯定在链上）。

分段之后我们可以预处理出 $cnt_i,v_i$ 。

分别表示，以 $fa_i$ 为链尾，根为链首的**链上所有点的不在链上的右儿子**（其实就是有贡献的点）的个数之和与深度之和。

然后根据 $t,cnt_i,v_i$。我们就可以通过分类讨论的方法在 $O(\log n)$ （瓶颈在倍增跳点）内算出这类点的贡献。

注意分类的细节。

在这里特别提出一种情况，就是 $t$ 的**右儿子是有贡献的点**（就是它右儿子不在链上的意思），而且 $u_q$ 在 $t$ 的右子树内。那么这个时候它们的 $lca$ 应该是  $t$ 的右儿子而不是 $t$ 。

忽视这个细节就会 $100->20$。（~~还我 $80$ 分~~）

瓶颈在树剖，复杂度为 $O(n\log n\log n)$

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 4e5+5;
int mi[MAXN],n,m,le[MAXN],ri[MAXN],ls[MAXN],rs[MAXN],node;
int lg[MAXN],f[21][MAXN],tot,dep[MAXN],pos[MAXN],st[MAXN],top;
int siz[MAXN],dfn[MAXN],ttd,tt[MAXN],son[MAXN];
ll v[MAXN],cnt[MAXN],Ans[MAXN],val;
struct Ques
{
	int u,l,id;
};
vector <Ques> Qu[MAXN];
struct Add
{
	int u,id;
};
vector <Add> Ad[MAXN];
struct Tree
{
	ll t[MAXN<<2],tg[MAXN<<2];
	Tree(){memset(t,0,sizeof t);memset(tg,0,sizeof tg);}
	void clear(){memset(t,0,sizeof t);memset(tg,0,sizeof tg);}
	void pu(int k) {t[k]=t[(k<<1)]+t[(k<<1|1)];}
	void pd(int k,int l,int r)
	{
		if(!tg[k]) return ;
		int mid=l+r>>1;
		tg[(k<<1)]+=tg[k];tg[(k<<1|1)]+=tg[k];
		t[(k<<1)]+=tg[k]*(mid-l+1);t[(k<<1|1)]+=tg[k]*(r-mid);
		tg[k]=0;
	}
	void upd(int le,int ri,int k,int l,int r,ll x)
	{
		if(le<=l&&r<=ri)
		{
			t[k]+=x*(r-l+1);tg[k]+=x;
			return ;
		}
		int mid=l+r>>1;pd(k,l,r);
		if(le<=mid) upd(le,ri,(k<<1),l,mid,x);
		if(ri>mid)  upd(le,ri,(k<<1|1),mid+1,r,x);
		pu(k);
	}
	ll que(int le,int ri,int k,int l,int r)
	{
		if(le<=l&&r<=ri) return t[k];
		int mid=l+r>>1;ll ans=0;pd(k,l,r);
		if(le<=mid) ans+=que(le,ri,(k<<1),l,mid);
		if(ri>mid)  ans+=que(le,ri,(k<<1|1),mid+1,r);
		return ans;
	}
}T;//线段树板板 
bool in(int x,int y)
{
	return le[x]<=le[y]&&ri[y]<=ri[x];
}
void predfs(int &k,int fa,int l,int r,int d,bool rep)
{
	if(!k) k=++node;
	cnt[k]=cnt[fa]+(rep?0:1);v[k]=v[fa]+(rep?0:d);
	le[k]=l;ri[k]=r;dep[k]=d;
	f[0][k]=fa;
	for(int i=1;i<=lg[d];++i)
		f[i][k]=f[i-1][f[i-1][k]];
	if(l==r)
	{
		pos[l]=k;
		return ;
	}
	++tot;int mid=mi[tot];
	predfs(ls[k],k,l,mid,d+1,0);
	predfs(rs[k],k,mid+1,r,d+1,1);
}//预处理，没什么好讲的。 
void dfs1(int p,int fa)
{
	siz[p]=1;
	if(ls[p])
	{
		dfs1(ls[p],p),siz[p]+=siz[ls[p]];
		if(siz[ls[p]]>siz[son[p]]) son[p]=ls[p];
	}
	if(rs[p])
	{
		dfs1(rs[p],p),siz[p]+=siz[rs[p]];
		if(siz[rs[p]]>siz[son[p]]) son[p]=rs[p];
	}
}
void dfs2(int p,int fa,int t)
{
	tt[p]=t;dfn[p]=++ttd;
	if(son[p]) dfs2(son[p],p,t);
	if(ls[p]&&son[p]!=ls[p]) dfs2(ls[p],p,ls[p]);
	if(rs[p]&&son[p]!=rs[p]) dfs2(rs[p],p,rs[p]);
}
void U(int x,int v){while(x) T.upd(dfn[tt[x]],dfn[x],1,1,node,v),x=f[0][tt[x]];}
ll Q(int x){ll r=-T.que(1,1,1,1,node);while(x) r+=T.que(dfn[tt[x]],dfn[x],1,1,node),x=f[0][tt[x]];return r;}
//由于树剖将边权化为点权了，所以 1 的点权应该是没有任何意义的。 
ll calc(int u,int x,int y)//x为链尾，y为链首 
{
	ll d=dep[u];
	bool step=0;
	for(int i=lg[dep[u]]-1;i>=0;--i) if(f[i][u]&&!in(f[i][u],x)) u=f[i][u];
	if(!in(u,x)) u=f[0][u],step=1;
	//向上跳的过程，注意有可能本来 u 就在链上，然后记录一下 u 是不是跳上来的 
	ll r=0;
	r+=v[x]-v[u]+(cnt[x]-cnt[u])*d-2ll*(cnt[x]-cnt[u])*dep[u];
	r+=v[u]+cnt[u]*d-2ll*(v[u]-cnt[u]);
	if(le[rs[u]]>le[x]&&step&&in(y,u)) r-=2;
	 //如果 u 不是本来就在链上然后跳到了 t (这里的 u 存的值实际上已经是 t了)
	 //那么说明 u 只能是 t 的右子树中的一部分 (因为 u 的左儿子) 
	 //此时就要特判一下，因为上述公式是把 lca 当 t 来算的，实际上是 t 的右儿子。 
	if(in(u,y))
	{
		r-=v[y]-v[u]+(cnt[y]-cnt[u])*d-2ll*(cnt[y]-cnt[u])*dep[u];
		r-=v[u]+cnt[u]*d-2ll*(v[u]-cnt[u]);
	}
	else r-=v[y]+cnt[y]*d-2ll*(v[y]-cnt[y]);
	//减去链首以上的贡献部分 
	return r;
}
void perform(Ques q)
{
	int l=1,r=top,p=0;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(le[st[mid]]<=q.l-1) p=mid,l=mid+1;
		else r=mid-1;
	}
	//二分出栈内不合法贡献的点所构成区间的右端点
	Ans[q.id]+=1ll*top*dep[q.u]+val-2ll*Q(q.u);
	Ad[ri[st[p]]].push_back(Add{q.u,q.id});//存起来，到时候减去 
	if(ri[st[p]]!=q.l-1) Ans[q.id]+=calc(q.u,pos[q.l-1],st[p]);
	//如果点会被拆就计算。
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i) lg[i]=lg[i-1]+(1<<lg[i-1]==i);
	for(int i=1;i<n;++i) scanf("%d",&mi[i]);
	scanf("%d",&m);
	for(int i=1;i<=m;++i)
	{
		int u,l,r;scanf("%d %d %d",&u,&l,&r);
		Qu[r].push_back(Ques{u,l,i});
	}
	int rt=0;
	predfs(rt,0,1,n,0,1);
	dfs1(rt,0);dfs2(rt,0,rt);
	for(int i=1;i<=n;++i)
	{
		int u=pos[i];
		while(ri[f[0][u]]==i) u=f[0][u];
		while(top&&in(u,st[top]))
		{
			U(st[top],-1);
			val-=dep[st[top]];
			--top;
		}
		st[++top]=u;U(u,1);val+=dep[u];
		for(Ques q:Qu[i]) perform(q);
	}
	//接下来做第二次，目的是减去栈中前面不合法的贡献 
	T.clear();top=0;val=0;
	for(int i=1;i<=n;++i)
	{
		int u=pos[i];
		while(ri[f[0][u]]==i) u=f[0][u];
		while(top&&in(u,st[top]))
		{
			U(st[top],-1);
			val-=dep[st[top]];
			--top;
		}
		st[++top]=u;U(u,1);val+=dep[u];
		for(Add q:Ad[i]) Ans[q.id]-=1ll*top*dep[q.u]+val-2ll*Q(q.u);
	}
	for(int i=1;i<=m;++i) printf("%lld\n",Ans[i]);
	return 0;
}
```



 

---

## 作者：BitByBit (赞：1)

画了一些图供大家欣赏。

首先对样例建立线段树：![](https://cdn.luogu.com.cn/upload/image_hosting/pqw6b2cz.png)（为了方便，在左右各增加一个叶子节点，原树中节点的编号增加 $4$。红色数字表示叶子节点对应的原序列中的数，同样为了方便将下标增加了 $1$）。

标出 $[3,9]$ 对应的节点（黄色），并标出 $7$ 到 $22$ 的链上的节点（蓝色）：![](https://cdn.luogu.com.cn/upload/image_hosting/8qkivii4.png)不难发现黄色节点是 $\operatorname{lca}(7,22)$ 的左子树内蓝色节点的不在链上的右儿子，和右子树内不在链上的左儿子。

然后不难想到用 lca 求距离，也就是算出各节点深度和，分别减去两倍的对应 lca 的深度。令题目查询 $x$ 到 $[l_0,r_0]$ 对应的节点的距离和。设序列中的 $l_0-1,r_0+1$ 分别对应树上节点 $l,r$。则 $[l_0,r_0]$ 对应的节点为 $l,r$ 间的链的儿子。令 $a=\operatorname{lca}(l,r)$。
- 若 $x$ 在 $a$ 的子树外或 $x=a$，则显然所有节点与 $x$ 的 lca 均为 $\operatorname{lca}(a,x)$。
- 若 $x$ 在 $a$ 左子树内。令 $b=\operatorname{lca}(l,x)$，则右边所有节点与 $x$ 的 lca 为 $a$，左边在 $b$ 以上的都是 $x$ 的祖先的儿子，以下的与 $x$ 的 lca 都为 $b$。于是分别处理即可。注意对于 $x$ 在 $b$ 的右子树中时有一个对应节点是 $x$ 的直接祖先（而不是祖先的儿子），所以答案对应减去多算的 $2$。
- 若 $x$ 在 $a$ 右子树内，与上一种情况类似。

于是分别求出每个节点到根的左和右儿子的前缀深度和和前缀个数。

核心代码：
```
ll query(int x,int l,int r)
{
	l=Pos[l-1];r=Pos[r+1];//Pos 表示原序列中 x 对应树上 Pos[x]。
	int a=lca(l,r),b,ls=G[a][0],rs=G[a][1];//G 为邻接表。
	ll res=RSum[l]-RSum[ls]+LSum[r]-LSum[rs]+(ll)Dep[x]*(RCnt[l]-RCnt[ls]+LCnt[r]-LCnt[rs]);
    //RSum,RCnt,LSum,LCnt 即前文所述前缀和。
	if(!in_subtree(x,a)||x==a)//in_subtree(x,y) 表示 x 在 y 的子树内。
	{
		b=lca(a,x);
		res-=(ll)2*Dep[b]*(RCnt[l]-RCnt[ls]+LCnt[r]-LCnt[rs]);
	}
	else if(in_subtree(x,ls))
	{
		b=lca(l,x);
		res-=(ll)2*Dep[a]*(LCnt[r]-LCnt[rs])+(ll)2*Dep[b]*(RCnt[l]-RCnt[b])+(ll)2*((RSum[b]-RSum[ls])-(RCnt[b]-RCnt[ls]));
		if(in_subtree(x,G[b][1]))res-=2;
	}
	else
	{
		b=lca(r,x);
		res-=(ll)2*Dep[a]*(RCnt[l]-RCnt[ls])+(ll)2*Dep[b]*(LCnt[r]-LCnt[b])+(ll)2*((LSum[b]-LSum[rs])-(LCnt[b]-LCnt[rs]));
		if(in_subtree(x,G[b][0]))res-=2;
	}//即上文的处理。
	return res;
}
```

---

## 作者：Fzrcy (赞：1)

不愧是 ZJOI，如果错了请私信。

首先我们要知道在广义线段树中 $S_{[l,r]}$ 代表什么。

设 $leaf_i$ 表示广义线段树中代表 $[i,i]$ 的节点。

显然 $leaf_l$ 的深度最小的满足 $[l_{fa_l},r_{fa_l}]\subseteq [l,r]$ 的祖先 $fa_l$ 一定在 $S_{l,r}$ 中，并且是左端点最小的节点，$fa_r$ 类似，是右端点最大的节点。

然后设 $t$ 表示 $fa_l$ 和 $fa_r$ 的 $\operatorname{lca}$，那么从 $fa_l$ 到 $t$ 的路径上，若 $x$ 是父亲 $y$ 的左儿子则 $x$ 的兄弟也在 $S_{l,r}$ 中（$x\ne t$，$y\ne t$），$fa_r$ 到 $t$ 的情况是对称的。

知道了 $S_{l,r}$ 是什么后，我们考虑如何求解。

首先我们要维护一些信息使得我们可以 $O(1)$ 的求出 $S_{l,r}$ 内的节点到路径 $fa_l\to fa_r$ 中一个节点的距离的和，维护信息是平凡的，因为我们所需的信息可以树上差分，所以我们可以 $O(n)$ 预处理。

然后我们求出 $fa_l\to u$ 和 $fa_r\to u$ 的路径的第一个交点 $e$，显然 $S_{l,r}$ 的**绝大多数**点到 $u$ 的路径都会经过 $e$，所以我们求出 $S_{l,r}$ 到 $e$ 的距离然后加上 $e$ 到 $u$ 的距离乘上 $|S_{l,r}|$ 即可，当 $u$ 在某个节点 $x$ 的子树时（$x\in S_{l,r},x\ne fa_l,x\ne fa_r$） $x\to u$ 的路径并不会经过 $e$，特判一下即可。

复杂度是 $O((n+q)\log n)$，由于操作只有求 $\operatorname{lca}$，所以我们可以用 $O(n)-O(1)$ RMQ 优化到 $O(n+q)$，但是太复杂，所以我只用了 $O(n\log n)-O(1)$ 的 dfs 序做法。

```cpp
// Fzrcy
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
constexpr int N=4e5+9;
ll sum[N][2],num[N][2],dep[N],ans;
int n,Q,T,S[N][2],P[N],lg[N];
int d1[N],d2[N],dd,ff[N][19];
inline int bld(int l,int r){
    int k=++T,m;if(l==r)return P[l]=k;
    cin>>m;S[k][0]=bld(l,m),S[k][1]=bld(m+1,r);
    return k;
}
inline void dfs(int u,int fa){
    ff[d1[u]=++dd][0]=fa,dep[u]=dep[fa]+1;
    for(int i=0,v;i<2;i++)if(v=S[u][i])dfs(v,u);
    d2[u]=dd;
}
inline void Dfs(int u,int fa){
    for(int i=0,v;i<2;i++)if(v=S[u][i]){
        for(int j=0;j<2;j++)sum[v][j]=sum[u][j],num[v][j]=num[u][j];
        if(S[u][i^1]){sum[v][i^1]+=dep[S[u][i^1]],++num[v][i^1];}Dfs(v,u);
    }
}
inline int Mn(int x,int y){return dep[x]<dep[y]?x:y;}
inline int lca(int x,int y){
    if(x==y)return x;if((x=d1[x])>(y=d1[y]))swap(x,y);
    int c=lg[y-x];return Mn(ff[x+1][c],ff[y-(1<<c)+1][c]);
}
inline void init(){
    bld(1,n),S[T+2][0]=P[0]=T+1,S[T+2][1]=1;
    S[T+3][0]=T+2,S[T+3][1]=P[n+1]=T+4;
    dfs(T+3,0),lg[0]=-1,Dfs(T+3,0);
    for(int i=1;i<=T+4;i++)lg[i]=lg[i>>1]+1;
    for(int j=1;(1<<j)<=T+4;j++)
        for(int i=1;i+(1<<j)-1<=T+4;i++)
            ff[i][j]=Mn(ff[i][j-1],ff[i+(1<<j-1)][j-1]);
}
int main(){
    for(cin>>n,init(),cin>>Q;Q--;){
        static int l,r,u,t,lt,rt;
        cin>>u>>l>>r;l=P[l-1],r=P[r+1];
        t=lca(l,r),lt=S[t][0],rt=S[t][1];
        ans=((sum[l][1]-sum[lt][1])+(sum[r][0]-sum[rt][0]))+dep[u]*
            ((num[l][1]-num[lt][1])+(num[r][0]-num[rt][0]));
        #define IN(X,Y) (d1[Y]>=d1[X]&&d1[Y]<=d2[X])
        if(d1[u]<=d1[t]||d1[u]>d2[t])
            ans-=2ll*dep[lca(t,u)]*((num[l][1]-num[lt][1])+(num[r][0]-num[rt][0]));
        else if(IN(lt,u)){
            ans-=2ll*dep[t]*(num[r][0]-num[rt][0]);int x=lca(l,u);
            ans-=2ll*((sum[x][1]-sum[lt][1])-(num[x][1]-num[lt][1]));
            ans-=2ll*((num[l][1]-num[x][1])*dep[x]);
            IN(S[x][1],u)&&(ans-=2);
        }else{
            ans-=2ll*dep[t]*(num[l][1]-num[lt][1]);int x=lca(r,u);
            ans-=2ll*((sum[x][0]-sum[rt][0])-(num[x][0]-num[rt][0]));
            ans-=2ll*((num[r][0]-num[x][0])*dep[x]);
            IN(S[x][0],u)&&(ans-=2);
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---


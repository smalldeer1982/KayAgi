# [ZJOI2019] 麻将

## 题目描述

九条可怜是一个热爱打麻将的女孩子。因此她出了一道和麻将相关的题目，希望这题不会让你对麻将的热爱消失殆尽。

![](https://cdn.luogu.com.cn/upload/pic/55642.png)

今天，可怜想要打麻将，但是她的朋友们都去下自走棋了，因此可怜只能自己一个人打。可怜找了一套特殊的麻将，它有 $n(n\ge 5)$ 种不同的牌，大小分别为 $1$ 到 $n$，每种牌都有 $4$ 张。

定义面子为三张大小相同或者大小相邻的麻将牌，即大小形如 $i,i,i(1 \le i \le n)$ 或者$i,i+1,i+2(1\le i\le n-2)$。定义对子为两张大小相同的麻将牌，即大小形如 $i,i(1 \le i \le n)$。

定义一个麻将牌集合 $S$ 是胡的当且仅当它的大小为 $14$ 且满足下面两个条件中的至少一个：

-  $S$ 可以被划分成五个集合 $S_1$ 至 $S_5$ 。其中 $S_1$ 为对子，$S_2$ 至 $S_5$ 为面子。
-  $S$ 可以被划分成七个集合 $S_1$ 至 $S_7$ ，它们都是对子，且对应的大小**两两不同**。

举例来说，下列集合都是胡的（这儿只标记了大小）：

-  $\{1,1,1,1,2,3,4,5,6,7,8,9,9,9\}$
-  $\{1,1,2,2,4,4,5,5,6,6,7,7,8,8\}$
-  $\{1,1,2,2,3,3,4,4,5,5,6,6,7,7\}$

而下列集合都不是胡的：

-  $\{1,1,1,2,3,4,5,6,7,8,9,9,9\}$
-  $\{1,1,1,1,4,4,5,5,6,6,7,7,8,8\}$
-  $\{1,1,1,2,3,4,5,6,7,8,9,9,9,11\}$

可怜先摸出了 $13$ 张牌，并把剩下的$4n-13$张牌随机打乱。打乱是等概率随机的，即所有$(4n-13)!$种排列都等概率出现。

对于一个排列 $P$，可怜定义 $S_i$ 为可怜事先摸出的 $13$ 张牌加上 $P$ 中的前 $i$ 张牌构成的集合，定义 $P$ 的权值为**最小的 $i$  满足 $S_i$ 存在一个子集是胡的**。如果你对麻将比较熟悉，不难发现 $P$ 的权值就是理论上的最早胡牌巡目数。注意到 $n\ge 5$ 的时候，$S_{4n-13}$总是存在胡的子集的，因此 $P$ 的权值是良定义的。

现在可怜想要训练自己的牌效，因此她希望你能先计算出 $P$ 的权值的期望是多少。

## 说明/提示

上述牌型叫做纯正九莲宝灯，不难发现不管再加一张什么牌它都是胡的。所以对于所有排列 $P$，权值都是 $1$，因此权值的期望就是 $1$。

对于 $20\%$ 的数据，$n = 5$。

对于 $50\%$ 的数据，$n\le 13$。

对于另外 $20\%$ 的数据，$n \le 100,w_i = i,t_i = 1$。

对于另外 $20\%$ 的数据，$n \le 100,w_i = \lceil \frac{i}{4} \rceil ,t_i= i\ \mathrm{mod}\ 4 + 1$。

对于 $100\%$ 的数据，$5 \le n \le 100$。

## 样例 #1

### 输入

```
9
1 1
1 2
1 3
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
9 2
9 3```

### 输出

```
1```

# 题解

## 作者：shadowice1984 (赞：51)

~~麻雀って、楽しいね。~~

显然比zjoi2018d1t1简单并且好写多了……

虽然题意很奇怪但是做法还是很传统的
_______

## 前置芝士：dp套dp

其实不会这个技术也行不过会了最好

# 本题题解

显然给出一个牌的集合$S$,我们仅仅关心每一种牌出现了多少次

换句话讲2333这幅牌和3233这幅牌是一样的

那么我们可以将一个副表示成一个长度为n的字符串，其中这个字符串的第i位表示第i种牌出现了几次

比如说2333556这幅牌转化成字符串就是013021

现在我们成功的将一副牌压成了一个长度为n的字符串了，让我们来考虑一下如何识别一个字符串能不能胡

那么我们可以尝试造个自动机出来，使得这个自动机可以识别一副胡了的牌,造自动机的方式有很多种，其中一种就是把dp强行改成自动机

那么我们尝试设计一个dp,注意到我们将一副牌映射成一个字符串之后，牌的编号是连续的，那么我们可以这样设计一个$dp(i,j,k,0/1)$表示处理完了第i种编号的牌，我们**预留**了j对形如$i-1,i$的牌，和$k$个编号为$i$的牌,$0/1$表示之前的决策过程当中有没有**预留**过对子，dp当中存储的值是这种情况下的最大面子数

注意到三个相同的顺子可以被算成三个连续的刻子,那么我们会发现$j$和$k$这两维都不会超过2

dp的转移也十分简单,假设来了$x$张$i+1$编号的牌，首先原来的$j,k$之和必须小于等于x,因为要满足原来的预留情况,处理完预留情况之后我们枚举留下几张x作为新顺子的开始,剩下的x尝试去组刻子,同时一开始预留的j张$(i-1,i)$可以和$i+1$凑出$j$个顺子来,按照定义转移一下就可以了

当然我们还要枚举预留还是不预留对子，这个部分也很简单

这样我们dp我们可以dp出这张牌是不是传统胡牌了

接下来考虑判定七对子，这个特判一下就行了，如果有7个及以上的编号有对子就可以凑一个七对子出来

那么我们怎么造自动机呢?

很简单，我们把$dp(j,k,0/1)$这个三维数组直接当成自动机的节点，节点之间的转移就是普通dp的转移，为了压缩节点数目，我们认为dp数组当中的任意一个值都不能超过$4$

这样我们就可以搞定传统胡牌了，加上七对子的情况只需要在节点上单独记一个变量表示对子的数目即可了

一个节点是胡的当且仅当dp值当中有大于等于4的位置，或者出现了7个**不同的对子**~~(听说有些地方规则七对子带杠?)~~

最后我们为胡牌的状态单开一个节点，这个节点无论输入什么都会走回自己

建这个自动机可以用map存储每个状态的编号,然后使用bfs来构建自动机

由于将所有胡牌的节点缩成了一个点,因此点数会比网上题解的点数要少，具体来讲是$2092$个节点，你可以使用这个数字校验一下你的搜索有没有写错

现在我们有了自动姬就可以dp了

我们希望求出这副牌的最小胡牌巡目数的期望，根据一个期望题上经典的转化，我们只需要算出已经摸了$i$张牌还是不胡的方案数加起来，除以$(4n-13)!$最后把答案加1就是答案了(加1是因为本来算的是胡牌时间大于等于i的方案数，我们强行变成了算胡牌时间大于i-1的方案数)

我们可以设$f(i)$表示摸了i张牌之后还不胡的牌的集合数目

那么我们最终的答案就是

$$1+\frac{\sum_{i=1}^{4n-13}f(i)i!(4n-13-i)!}{(4n-13)!}$$

现在考虑怎么算$f(i)$就行了

也很简单$dp(k,n,j)$表示字符串长度为k,摸了n张牌，走到自动姬上点j的方案数

转移方程就是枚举字符串的第$k+1$位是什么，假如第$k+1$种牌还剩$p$张,我们放了$t$张，那么转移的时候乘一个${p \choose t}$的系数即可

想卡一下空间的话可以滚动数组实现这个dp

(应该比直接dp排列的做法好写很多)

复杂度$O(2092×n^2)$常数不大可以通过本题

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<map>
#include<queue>
using namespace std;const int N=4100;const int M=4100;
typedef unsigned long long ll;const ll mod=998244353;
struct data//转移用的矩阵类 
{
    int dp[3][3];
    inline int* operator [](const int& x){return dp[x];} 
    data()
    {
        for(int i=0;i<3;i++)	
            for(int j=0;j<3;j++)dp[i][j]=-1;
    }
    friend bool operator <(data a,data b)
    {
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                if(a[i][j]!=b[i][j])return a[i][j]<b[i][j];
        return false;
    }
    friend bool operator !=(data a,data b)
    {
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                if(a[i][j]!=b[i][j])return true;return false;
    }
    inline void trs(data& c,int del)
    {
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                if(dp[i][j]!=-1)
                    for(int k=0,rem=del-i-j;k<3&&i+j+k<=del;k++,rem--)
                        c[j][k]=max(c[j][k],min(i+dp[i][j]+rem/3,4));
    }
    inline bool ckhu()
    {
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                if(dp[i][j]>=4)return true;return false;
    }
};
struct nod//自动机节点 
{
    data is_pair[2];int cnt_pair;
    friend bool operator <(nod a,nod b)
    {
        if(a.cnt_pair!=b.cnt_pair)return a.cnt_pair<b.cnt_pair;
        if(a.is_pair[0]!=b.is_pair[0])return a.is_pair[0]<b.is_pair[0];
        if(a.is_pair[1]!=b.is_pair[1])return a.is_pair[1]<b.is_pair[1];
        return false;
    }
    inline void clear()
    {is_pair[0]=data();is_pair[1]=data();cnt_pair=-2333;}
    inline bool ckhu()
    {
        if(cnt_pair>=7){clear();return true;}
        if(is_pair[1].ckhu()){clear();return true;}
        return false;
    }
    friend nod operator +(nod a,int b)
    {
        if(a.cnt_pair==-2333)return a;
        nod c;
        if(b>=2)a.is_pair[0].trs(c.is_pair[1],b-2);
        a.is_pair[0].trs(c.is_pair[0],b);
        a.is_pair[1].trs(c.is_pair[1],b);
        c.cnt_pair=a.cnt_pair+(b>=2);
        c.ckhu();
        return c;
    }
    
};
inline nod stat()
{
    nod res;res.clear();res.cnt_pair=0;res.is_pair[0][0][0]=0;
    return res;
}
map <nod,int> mrk;int tot;int mp[M][5];queue <nod> q;int ed;
inline void bfs()//搜索 
{
    nod st=stat();
    q.push(st);mrk[st]=++tot;
    while(!q.empty())
    {
        st=q.front();q.pop();int nu=mrk[st];
        for(int i=0;i<=4;i++)
        {
            nod tw=st+i;
            if(mrk.count(tw))mp[nu][i]=mrk[tw];
            else mp[nu][i]=mrk[tw]=++tot,q.push(tw);
        }
    }
    st.clear();ed=mrk[st];
}
ll fac[N];ll inv[N];ll ifac[N];
ll dp[2][440][M];ll* p1[440];ll* p2[440];
ll xs[N];int sum[N];int n;
inline void pre()
{
    fac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i%mod;
    inv[0]=inv[1]=1;for(int i=2;i<N;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
    ifac[0]=1;for(int i=1;i<N;i++)ifac[i]=ifac[i-1]*inv[i]%mod;
}
inline void calc()//dp使用了滚动数组 
{
    int cap=n*4-13;
    for(int i=0;i<=cap;i++)p1[i]=dp[0][i];
    for(int i=0;i<=cap;i++)p2[i]=dp[1][i];p1[0][mrk[stat()]]=1;
    for(int z=1;z<=n;z++)
    {
        for(int j=0;j<=4-sum[z];j++)xs[j]=fac[4-sum[z]]*ifac[4-sum[z]-j]%mod*ifac[j]%mod;
        for(int i=cap;i>=0;i--)
        {
            for(int j=1;j<=tot;j++)p2[i][j]=0;
            for(int j=1;j<=tot;j++)
                if(p1[i][j]!=0)
                    for(int tmp=0;tmp<=4-sum[z]&&i+tmp<=cap;tmp++)
                        (p2[i+tmp][mp[j][tmp+sum[z]]]+=p1[i][j]*xs[tmp])%=mod;
        }
        for(int i=0;i<=cap;i++)swap(p1[i],p2[i]);
    }
}
int main()
{
    bfs();pre();
    scanf("%d",&n);
    for(int i=1,w,t;i<=13;i++)scanf("%d%d",&w,&t),sum[w]++;
    calc();
    ll ans=0;
    for(int p=1,q=4*n-14;p<=4*n-13;p++,q--)//计算答案 
        for(int j=1;j<=tot;j++)
            if(j!=ed)(ans+=p1[p][j]*fac[p]%mod*fac[q])%=mod;
    printf("%lld",ans*ifac[4*n-13]%mod+1);
    return 0;//拜拜程序~ 
}
```











---

## 作者：TheLostWeak (赞：39)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5279.html)

**大致题意：** 给你13张麻将牌，问你期望再摸多少张牌可以满足存在一个胡的子集。

~~似乎ZJOI2019Day1的最大收获是知道了什么是胡牌？~~

### 一个显然的性质

首先我们要知道一个显然的性质，即对于一副牌，我们仅需要考虑其**每张牌的张数**，而顺序是没有任何关系的。

因此，对于一副牌，我们可以将其转化为一个长度为$n$，每个位置上为$0\sim4$的序列。

这样就方便操作了许多。

### 胡牌自动机

在前面性质的基础上，我们来考虑如何判断一副牌，即一个长度为$n$的序列是否能胡。

我们似乎可以建一个**自动机**（~~可以以其作用命名为**胡牌自动机**~~）去处理它。

### 建自动机的前奏：$DP$

那么我们该如何去建这个自动机呢？

考虑如果我们能得出一个判断一副牌是否能胡的$DP$，然后把**每个状态**看作自动机的点，**$DP$转移**看作自动机的边，则一个自动机就建成了。

于是问题又变成了：如何用$DP$来判断一副牌是否能胡。

设$f_{0/1,i,j,k}$表示**处理完前$i$种牌，还剩$j$组$(i-1,i)$以及$k$张$i$，且存在（$1$）/不存在（$0$）对子**时最多的**面子数**。

由于$j\ge3$时，我们可以用$3$个$i-1$和$3$个$i$各自组成面子；$k\ge3$时，我们可以直接用$3$个$i$组成面子。

因此，$0\le j,k\le2$。

所以可以考虑建一个$3*3$的矩阵存下$f_{0/1,i}$的全部答案。

假设加入了$x$张牌，则我们进行如下几种转移：

- 将$f_{0,i}$从$f_{0,i-1}$加$x$张牌转移过来。
- 将$f_{1,i}$从$f_{1,i-1}$加$x$张牌转移过来。
- 如果$x>1$，则将$f_{1,i}$从$f_{0,i-1}$加$x-2$张牌转移过来。

转移过程中，我们枚举若干张牌和之前的$(i-2,i-1)$拼面子，保留若干组$(i-1,i)$和若干张$i$，然后拿剩下的牌尽可能地拼面子，这样即可进行转移。

根据定义，若$f_{1,i}>3$，则这副牌就能胡了。

说到这里，或许你会发现，我们在这个$DP$中并没有考虑七对子的情况，这在后面会特判处理。

### 正式开始建自动机

接下来我们考虑如何将这个$DP$转化为自动机。

首先，我们确定一个初始状态（一张牌都没有）。

然后，以类似于$BFS$的方式，找到未处理过的节点，枚举新加入的牌数，然后通过$DP$转移的方式得出子节点的状态。

不难发现，前面的$i$在这里没有任何作用，可以不用记录。因为我们是从每个节点一步步转移的。

而$0/1$这个状态还是十分必要的，因此我们可以考虑，对自动机上每个节点开两个矩阵$P_{0/1}$，来进行转移。

此外，由于前面提到过的七对子，我们再开一个变量$t$记录出现的对子个数。

则综上所述，一个节点是胡的，当且仅当其**$P_1$中存在一个元素大于$3$**或**$t\ge7$**。

而为了提高效率，我们可以把所有胡的节点全部压成一个节点，以其$t=-1$作为特殊标记即可。

对于其他节点，我们可以开个$map$判断一种节点是否已经出现过（注意要将$t,P_{0/1}$全部进行比较），出现过则直接连边，否则先新建节点然后再连边。

顺便提一句，这里的$BFS$只要按节点编号从小到大枚举即可，无须队列。

显然按此方式建出来的胡牌自动机形态是固定的，即对于任何数据长得都一样。

具体实现详见代码。

### 胡牌自动机上$DP$

现在，我们到了这道题的最后一个关键步骤，胡牌自动机上$DP$。

我们可以设$g_i$表示**摸了$i$张牌后不胡的方案数**，则答案就为：

$$\frac{\sum_{i=1}^{4n-13}g_ii!(4n-13-i)!}{(4n-13)!}+1$$

其中分子中的$i!$和$(4n-13-i)!$表示这$i$张牌和剩下的$4n-13-i$张牌放的顺序任意，可以随便放；分母中的$(4n-13)!$是总方案数，显然算期望必须要除；加$1$是因为我们选择$i$张牌后依然不能胡，需要$+1$。

然后考虑如何$DP$。

设$f_{i,j,k}$表示**处理到第$i$张牌，共摸了$j$张牌，走到了胡牌自动机上的$k$号节点的方案数**。

那么显然我们可以枚举一个摸的牌数$t$（$0≤t≤4-a_i$，其中$a_i$为初始$13$张牌中$i$的张数），然后从$f_{i,j,k}$向$f_{i+1,j+t,O_k.Son_{a_i+t}}$转移，其中$O_k.Son_{a_i+t}$表示胡牌自动机上$k$号节点的第$a_i+t$个儿子。

还有$4-a_i$张牌中选$t$张牌的方案数$C_{4-a_i}^t$要记得乘上。

这个$DP$转移应该是比较显然，也比较简单的。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100
#define M 400
#define X 998244353
#define Gmax(x,y) (x<(y)&&(x=(y)))
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
#define Qinv(x) Qpow(x,X-2)
using namespace std;
int n,m,a[N+5],Fac[M+5],Inv[M+5];
I int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}
class HuAutomation//胡牌自动机
{
    private:
        #define SZ 2092//实测自动机大小
        #define C(x,y) (1LL*Fac[x]*Inv[y]%X*Inv[(x)-(y)]%X)//组合数
        #define Pos(x) (p.count(x)?p[x]:(O[p[x]=++tot]=x,tot))//求节点编号，若不存在则新建一个
        #define Expend(x) for(j=0;j^5;++j) O[x].S[j]=Pos(O[x]+j);//扩展
        class Mat//矩阵
        {
            private:
                #define CM Con Mat&
                #define Rp for(RI i=0,j;i^3;++i) for(j=0;j^3;++j)
                #define S (i+j+k)
                int f[3][3];
            public:
                I Mat() {Rp f[i][j]=-1;}I int* operator [] (CI x) {return f[x];}
                I bool operator != (Mat o) Con {Rp if(f[i][j]^o[i][j]) return 1;return 0;}//不等于
                I bool operator < (Mat o) Con {Rp if(f[i][j]^o[i][j]) return f[i][j]<o[i][j];}//比大小，用于map
                I bool Check() Con {Rp if(f[i][j]>3) return 1;return 0;}//判断是否能胡
                I void F5(Mat o,CI t)//更新
                {
                    Rp if(~o[i][j]) for(RI k=0;k^3&&S<=t;++k)//i,j,k分别枚举用于拼面子、用于保留(i-1,i)、用于保留i和直接拼面子的牌数 
                        Gmax(f[j][k],min(i+o[i][j]+(t-S)/3,4));//转移更新信息（要向4取模是因为大于4没有意义，同时提高效率）
                }
                #undef S
        };
        struct node//存储一个节点的信息
        {
            int t,S[5];Mat P[2];I node() {t=S[0]=S[1]=S[2]=S[3]=S[4]=0,P[0]=P[1]=Mat();}
            I bool operator < (Con node& o) Con//用于map
            {
                return t^o.t?t<o.t:(P[0]!=o.P[0]?P[0]<o.P[0]:(P[1]!=o.P[1]?P[1]<o.P[1]:0));
            }
            I node operator + (CI x) Con//加上x张新牌
            {
                if(IsHu()) return Hu();node res;//如果已经胡了直接返回
                res.P[0].F5(P[0],x),res.P[1].F5(P[1],x),x>1&&(res.P[1].F5(P[0],x-2),0),//进行转移
                res.t=t+(x>1),res.IsHu()&&(res=Hu(),0);return res;//统计对子数，然后判断是否胡
            }
            I bool IsHu() Con {return !~t||t>=7||P[1].Check();}//已经胡或者七对子或者存在4个面子和1个对子
            I node Hu() Con {node x;return x.t=-1,x;}//胡牌的特殊标记
        }O[SZ+5];map<node,int> p;
        I node Begin() {node x;return x.P[0][0][0]=0,x;}//初始状态
        I node Hu() {node x;return x.t=-1,x;}//胡牌的特殊标记
    public:
        int tot,f[N+5][M+5][SZ+5];
        I void Build()//建自动机
        {
            RI i,j;p[O[1]=Begin()]=1,p[O[2]=Hu()]=tot=2;//建立初始状态和胡牌状态
            Expend(1);for(i=3;i<=tot;++i) Expend(i);//对除第2个（胡牌）以外的其他状态进行扩展
        }
        I void DP()//DP求解答案
        {
            for(RI i=f[0][0][1]=1,j,k,t;i<=n;++i) for(j=m;~j;--j)//枚举当前是第i张牌，共摸了j张牌
                for(k=1;k<=tot;++k) if(f[i-1][j][k]) for(t=0;t<=4-a[i];++t)//枚举在胡牌自动机哪个节点上，以及现在摸的牌数
                    Inc(f[i][j+t][O[k].S[a[i]+t]],1LL*f[i-1][j][k]*C(4-a[i],t)%X);//转移，注意乘上组合数系数
        }
}H;
I void CInit(CI x)//初始化
{
    RI i;for(Fac[0]=i=1;i<=x;++i) Fac[i]=1LL*Fac[i-1]*i%X;//初始化阶乘
    for(Inv[x]=Qinv(Fac[x]),i=x-1;~i;--i) Inv[i]=1LL*Inv[i+1]*(i+1)%X;//初始化阶乘逆元
}
#define Calc(x,y) Inc(ans,1LL*H.f[n][x][y]*Fac[i]%X*Fac[m-i]%X)//统计答案
int main()
{
    RI i,j,x,y,ans=0;for(H.Build(),scanf("%d",&n),i=1;i<=13;++i) scanf("%d%d",&x,&y),++a[x];//读入数据+预处理
    for(m=(n<<2)-13,CInit(m),H.DP(),i=1;i<=m;++i) for(Calc(i,1),j=3;j<=H.tot;++j) Calc(i,j);//统计答案，注意跳过2号节点
    return printf("%lld",1LL*ans*Inv[m]%X+1),0;//输出答案，除以总状态数然后加1
}
```

---

## 作者：zhoukangyang (赞：25)

[更棒的体验 /kel](https://www.cnblogs.com/zkyJuruo/p/13971518.html)

这题非常的神啊。。。 

## Solution

首先考虑如何判定一副牌是否是 "胡" 的。

不要想着统计个几个值 $O(1)$ 算，可以考虑复杂度大一点的。

首先先把 $7$ 个对子的状态判掉。然后考虑 $4$ 个面子和 $1$ 个对子的情况。

记录一个 $dp_{i, j,k}$ : $i$ 表示现在有没有留出对子，$j$ 表示现在形如 $i, i - 1$ 的牌的多余的个数， $k$ 表示现在形如 $i$ 的牌对的个数，整个状态的值表示在这种情况下产生的面子数量的最大值。

使用 **dp 套 dp**, 对于这个 $dp_{i, j, k}$ 分别是多少给压缩起来。这个状态以及转移可以 $bfs$ 找。

最后进行一个期望 $dp$，$f_{i, j, k}$ 表示算了前 $i$ 种牌，现在总共有 $j$ 个牌，目前是第 $j$ 个 $dp$ 状态的方案数。最后拆贡献，对于每一个 $j$ 算有多少概率还会继续加牌。

## Code

```cpp
#include<bits/stdc++.h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++) 
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long 
#define db double
#define pii pair<int, int>
#define mkp make_pair
using namespace std;
const int N = 405;
const int M = 2200;
const int mod = 998244353;
int qpow(int x, int y) {
	if(x == 0) return 0;
	int res = 1;
	for(; y; x = 1ll * x * x % mod, y >>= 1) if(y & 1) res = 1ll * res * x % mod;
	return res;
}
int ny(int x) { return qpow(x, mod - 2); }
int n, winid, ans;
int max(int a, int b) { return a > b ? a : b; }
void Max(int &a, int b) { a = max(a, b); } 
struct DPAM { 
	int f[3][3]; 
	void clear() { L(i, 0, 2) L(j, 0, 2) f[i][j] = -1; }
};
DPAM operator + (DPAM aa, int bb) {
	DPAM res; res.clear(); 
	L(i, 0, 2) L(j, 0, 2) if(aa.f[i][j] != -1) 
		L(k, 0, 2) if(bb >= i + j + k) Max(res.f[j][k], min(aa.f[i][j] + i + (bb - i - j - k) / 3, 4));
	return res;
}
void FMAX(DPAM &aa, DPAM bb) { 
	L(i, 0, 2) L(j, 0, 2) Max(aa.f[i][j], bb.f[i][j]); 
}
struct node { 
	int cnt; DPAM dp[2]; 
	void clear() { cnt = 0; dp[0].clear(), dp[1].clear(); }
};
node win() { node res; res.clear(), res.cnt = 114514; return res; }
bool check(node aa) {
	if(aa.cnt >= 7) return 1;
	L(i, 0, 2) L(j, 0, 2) if(aa.dp[1].f[i][j] >= 4) return 1;
	return 0;
}
bool operator < (node aa, node bb) {
	L(t, 0, 1) L(i, 0, 2) L(j, 0, 2) if(aa.dp[t].f[i][j] ^ bb.dp[t].f[i][j]) return aa.dp[t].f[i][j] < bb.dp[t].f[i][j];
	return aa.cnt < bb.cnt;
}
node operator + (node aa, int bb) {
	if(aa.cnt == 114514) return aa;
	node res; 
	res.clear(), res.cnt = aa.cnt + (bb >= 2);
	FMAX(res.dp[0], aa.dp[0] + bb);
	FMAX(res.dp[1], aa.dp[1] + bb);
	if(bb >= 2) FMAX(res.dp[1], aa.dp[0] + (bb - 2));
	if(check(res)) return win();
	return res;
}
int tot, dp[2][N][M];
map<node, int> mp;
int G[M][5], jc[N], njc[N];
int C(int x, int y) { return 1ll * jc[x] * njc[x - y] % mod * njc[y] % mod; }
void bfs() {
	queue<node> q;
	node gg; 
	gg.clear(), gg.cnt = 0, gg.dp[0].f[0][0] = 0;
	mp[gg] = ++tot, q.push(gg);
	while(!q.empty()) {
		node u = q.front(); int id = mp[u];
		q.pop();
		L(i, 0, 4) {
			node v = u + i;
			if(!mp.count(v)) {
				G[id][i] = mp[v] = ++tot, q.push(v);
				if(v.cnt == 114514) winid = tot;
			} 
			else G[id][i] = mp[v];
		}
	}
}
int cnt[N];
void work() {
	dp[0][0][1] = 1;
	L(i, 1, n) {
		int now = (i & 1);
		memset(dp[now], 0, sizeof(dp[now]));
		L(j, 1, tot) L(k, 0, (i - 1) * 4) L(t, 0, 4 - cnt[i]) 
			(dp[now][k + t][G[j][t + cnt[i]]] += 1ll * dp[now ^ 1][k][j] * C(4 - cnt[i], t) % mod) %= mod;
	}
	L(i, 0, n * 4 - 13) L(j, 1, tot) if(j != winid) (ans += 1ll * ny(C(4 * n - 13, i)) * dp[n & 1][i][j] % mod) %= mod;
}
int mian() {
	bfs(); 
	scanf("%d", &n);
	jc[0] = njc[0] = 1;
	L(i, 1, n * 4) jc[i] = 1ll * jc[i - 1] * i % mod, njc[i] = ny(jc[i]);
	L(i, 1, 13) {
		int x, y; 
		scanf("%d%d", &x, &y), cnt[x]++;
	}
	work();
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：zj余能 (赞：17)

考虑给你一副牌，如何判断这副牌是否是胡的。

容易发现相同的顺子不会选三个以上，于是考虑花色从小到大进行$dp$。令$dp_{0/1, i, j, k}$表示是否有对子，考虑了前$i$种花色的牌，以花色$i - 1$的牌为开头的顺子准备选$j$个，以花色$i$的牌为开头的顺子准备选$k$个，此时能选的最大的面子数。转移只要枚举以花色$i + 1$的牌开头的顺子准备选几个，剩下的牌组成刻子就行了(具体细节可以看代码中结构体$State$中的$Trans$函数)。

判定胡牌的条件有两种：$\exists (j,k), dp_{1, n, j, k} \ge 4$；记$cnt$为牌数$\ge 2$的花色数，$cnt \ge 7$。

可以发现这个$dp$和状态$i$这一维关系不是很大，$dp_{0}$和$dp_{1}$的转移方式也都是一样的。只考虑有$dp_{*,j,k}$这个$3 \times 3$的矩阵，其转移本质上是接收一个数字（表示下一种花色的牌的数量），然后变成了另一个$3 \times 3$的矩阵，我们可以把它看成一个自动机的模型。事实上这样的$dp$状态（$3 \times 3$的矩阵）并不很多。我们用结构体$State$来形容这个矩阵。为了表示整个当前胡牌状态，我们需要两个$State$分别表示有没有选对子（即$dp_0$和$dp_1$），以及$cnt$。我们把这三个东西放到结构体$Mahjong$中，我们很容易可以得到$Mahjong$的$Trans$关系。经搜索$Mahjong$的状态数总共有$3956$个。

回过来看我们要算的答案：$ans = \sum\limits_{a = 13}^{4n} p(a)$，其中$p(a)$表示你总共摸了$a$张牌之后仍然不能胡的概率。于是我们只要算摸了$a$张牌仍然不能胡的排列数即可。令$f_{i, j, k}$表示我们考虑了前$i$种花色的牌，当前胡牌状态为$j$（$j$是一个$Mahjong$类），已经摸了$k$张牌的排列数有多少。转移枚举摸了花色$i + 1$的牌数$z$，则由$f_{i, j, k}$转移到$f_{i + 1, trans(j,z), k + z}$，乘上的系数就是$(4 - org_{i + 1})^{\underline{z - org{i + 1}}} \binom{k + z - sum_{i + 1}}{z - org_{i + 1}}$。$org_i$表示原有的$13$张牌中花色为$i$的有几张，$sum$则是$org$的前缀和，这个式子的意思就是我们需要在没被选过的$4 - org_{i + 1}$张牌中选$z - org_{i + 1}$张的排列，并且插入到之前的排列中，但前$13$张牌的顺序是固定的。

最后$p(a)$是很好算的，$p(a) = \frac{\sum\limits_{j \; can \; not \; win } f_{n, j, a}}{ (4n - 13)^{\underline{a - 13}} }$。

```cpp


#include <bits/stdc++.h>

using namespace std;

const int N = 1e2 + 5;
const int M = 4e3 + 5;
const int MOD = 998244353;

namespace {
  int ch[M][5], fac[5];
  int Add(int a, int b) { return (a += b) >= MOD? a - MOD : a; }
  void Upd(int &a, int b) { a = Add(a, b); }
  int Mul(int a, int b) { return (long long)a * b % MOD; }
  int Inv(int x) { return (x == 1)? 1 : Mul(MOD - MOD / x, Inv(MOD % x)); }
  void Math_init() {
    for (int i = 0; i < M; ++i) {
      ch[i][0] = 1;
      for (int j = 1; j <= min(i, 4); ++j) {
        ch[i][j] = Add(ch[i - 1][j - 1], ch[i - 1][j]);
      }
    }
    fac[0] = 1;
    for (int i = 1; i < 5; ++i) {
      fac[i] = Mul(fac[i - 1], i);
    }
  }
}

bool Chkmax(int &a, int b) {
  return (a < b)? (a = b, 1) : (0);
}

struct State {
  int dp[3][3]; // (last last bar, last bar)
  State() {
    memset(dp, -1, sizeof dp);
  }
  
  friend bool operator < (State a, State b) {
    for (int i = 0; i < 3; ++i)
      for (int j = 0; j < 3; ++j)
        if (a.dp[i][j] != b.dp[i][j])
          return a.dp[i][j] < b.dp[i][j];
    return 0;
  }
  
  friend State Max(State a, State b) {
    for (int i = 0; i < 3; ++i) 
      for (int j = 0; j < 3; ++j)
        a.dp[i][j] = max(a.dp[i][j], b.dp[i][j]);
    return a;
  }
  
  friend State Trans(State a, int b) {
    State c;
    for (int i = 0; i < 3; ++i)
      for (int j = 0; j < 3; ++j)
        if (~a.dp[i][j])
          for (int k = 0; k < 3 && i + j + k <= b; ++k)
            Chkmax(c.dp[j][k], min(i + a.dp[i][j] + (b - i - j - k) / 3, 4));
    return c;
  }
  
};

struct Mahjong {
  pair<State, State> god;
  int cnt;
  Mahjong() {
    memset(god.first.dp, -1, sizeof god.first.dp);
    memset(god.second.dp, -1, sizeof god.second.dp);
    god.first.dp[0][0] = cnt = 0;
  }
  
  friend bool operator < (Mahjong a, Mahjong b) {
    return a.cnt != b.cnt? a.cnt < b.cnt : a.god < b.god;
  }
  
  friend Mahjong Trans(Mahjong a, int b) {
    a.cnt = min(a.cnt + (b >= 2), 7);
    a.god.second = Trans(a.god.second, b);
    if (b >= 2) {
      a.god.second = Max(a.god.second, Trans(a.god.first, b - 2));
    }
    a.god.first = Trans(a.god.first, b);
    return a;
  }
  
  bool right() {
    if (cnt == 7) return 1;
    for (int i = 0; i < 3; ++i)
      for (int j = 0; j < 3; ++j)
        if (god.second.dp[i][j] == 4) return 1;
    return 0;
  }
  
} mahjong[M];


int n, tot;
map<Mahjong, int> idx;
bool win[M];
int org[N], f[N][M][4 * N], trans[M][5];

void Dfs_mahjong(Mahjong now) {
  if (idx.find(now) != idx.end()) return;
  mahjong[++tot] = now;
  win[tot] = now.right();
  idx[now] = tot;
  for (int i = 0; i <= 4; ++i) {
    Dfs_mahjong(Trans(now, i));
  }
}

int main() {
  Math_init();
  Dfs_mahjong(Mahjong());

  for (int i = 1; i <= tot; ++i) {
    for (int j = 0; j <= 4; ++j) {
      trans[i][j] = idx[Trans(mahjong[i], j)];
    }
  }

  scanf("%d", &n);
  for (int i = 0, x; i < 13; ++i) {
    scanf("%d%*d", &x);
    ++org[x];
  }

  f[0][1][0] = 1;
  for (int i = 0, cp = 0; i < n; ++i) { // consider 1 ... i
    cp += org[i + 1];
    for (int j = 1; j <= tot; ++j) { // mahjong j
      for (int l = org[i + 1]; l <= 4; ++l) { // trans
        int *nf = f[i + 1][trans[j][l]], *ff = f[i][j];
        int tmp = Mul(ch[4 - org[i + 1]][l - org[i + 1]], fac[l - org[i + 1]]);
        for (int k = 0; k + l <= 4 * n; ++k) { // have chosen k cards
          if (!ff[k]) continue;
          Upd(nf[k + l], Mul(ff[k], Mul(ch[k + l - cp][l - org[i + 1]], tmp)));
        }
      }
    }
  }
  
  int ans = 0, dw = 1;
  for (int i = 13; i <= 4 * n; ++i) {
    int up = 0;
    for (int j = 1; j <= tot; ++j) {
      if (!win[j]) Upd(up, f[n][j][i]);
    }
    Upd(ans, Mul(up, Inv(dw)));
    dw = Mul(dw, 4 * n - i);
  }
  printf("%d\n", ans);
  
  return 0;
}
```

---

## 作者：zac2010 (赞：10)

首先，必须先考虑一副牌是否是“胡”的，不然解决这道期望题就是无稽之谈。所以我们可以先把 $7$ 个对子的特殊情况判掉，接下来用 $\text{DP}$ 判断 $1$ 个对子、$4$ 个面子的情况。

用 $f_{i,j,k,t}$ 表示考虑了前 $i$ 种牌，是否已经有对子了（$j=0$ 表示否，$j=1$ 表示是），多余的像 $i,i-1$ 这样的一组牌有 $k$ 组，多余的第 $i$ 种牌有 $t$ 个的情况下，最大产生的面子数量。

接下来来回到这道题。设 $X$ 表示最早产生胡牌的轮数的随机变量，$p(x)$ 表示恰好 $x$ 轮时第一次产生了胡牌的概率。
$$
E(X)=\sum_{x=0}^{4n-13} x \times p(x)
$$

$$
E(X)=\sum_{x=0}^{4n-13} \sum_{i=0}^{n-1} \times p(x)
$$

$$
E(X)=\sum_{i=0}^{4n-13} \sum_{x=i+1}^{4n-13} \times p(x)
$$

$$
E(X)=\sum_{i=0}^{4n-13} P(\text{x轮时还没有胡牌的概率})
$$

$$
E(x)=\sum_{i=0}^{4n-13} \frac{\text{x轮时还没有胡牌的方案数}}{C_{4n-13}^i}
$$

所以我们的重中之重就是求出 $x$ 轮还没有胡牌的方案数。

我们使用 DP 套 DP 解决此问题。我们把上述简易 DP 的状态和其对应的对子数量作为内层 DP 状态给压缩起来（注意 $i$ 那维不要压进去，我们将会把那一维单独地放入外层的状态里），我们发现实际有用的状态可能很少，故而用搜索找。那么我们的外层状态就显而易见了：$dp_{i,j,k}$ 表示前 $i$ 种牌，内层状态为 $j$，总共选了 $k$  张的方案数。

至于查询没有胡牌的方案数，只需要判断加求和就行了。

---

## 作者：hl666 (赞：9)

ZJOI2019神题，间接送我退役的神题233

考场上由于T2写挂去写爆搜的时候已经没多少时间了，所以就写挂了233

这里不多废话直接开始讲正解吧，我们把算法分成两部分

------

### 1.建一个“胡牌自动机”

首先我们发现这题不能转化为一般DP问题求解的最大瓶颈就是因为它的状态很诡异

但是我们细细一想，形如$\{1,1,1,2,3,4,5,6,7,8,9,10,12,12\}$和$\{3,3,3,5,6,7,9,10,11,14,15,16,20,20\}$的本质其实是一样的（都是三个顺子+一个刻子+一个雀头的形式，且**相对大小**分布相同）

那么考虑到一共只有$13$张牌，那么最后的有效集合数必然很少，如果我们可以构造出这些集合那么可以帮助DP了

如果你知道**DP套DP**的姿势，那么就会套路地明白内层的DP应该用**自动机**的转移形式，所以我们大致的目标就出现了：

建出一个自动机，其中每一个节点都是一个状态，然后每个节点向子节点连的边就是摸牌之后能转移到的状态

所以我们就先考虑怎么建这个自动机，还是考虑DP

我们设$f_{0/1,i,j,k}$表示目前处理完了前$i$种牌，还剩下$j$组$(i-1,i)$以及$k$张$i$，且是否（用$0/1$表示）存在雀头时**最多的面子数**

由于当$j,k\ge 3$时可以直接用$i-1,i$组成刻子，因此我们状态中的$j,k\le 2$

那么我们就开一个$3\times3$的矩阵表示状态，单个转移的时候枚举用于拼面子，与$(i-1,i)$拼顺子，以及用来保留的个数，然后将多余的拿来拼刻子即可

然后考虑每次多出一个数值，我们直接讨论是否要留出一个雀头，分情况转移即可

我们发现这样并没有考虑七对子的情况，这个没关系，我们直接记录雀头的个数，特判了即可

因此剩下终止状态的判断就很简单了，直接把能胡的点作为终止节点结束即可

具体构造的过程可以用一个```map```来去重，然后用**BFS**来扩展状态，这个具体看代码

------

### 2.期望DP

先说一句，前面由于自动机对于任意数据构造相同，所以总点数是固定的$2092$，如前言所述不大

那么考虑DP求解最后的问题，我们用一个经典套路，将求$\ge$的化为求$>$然后最后加上等于的情况即可

具体到这道题上，其实就是求出**$i$轮后不胡的方案数**然后乘上贡献，最后的总答案加$1$即可

那么大致的DP方程就有了，我们设$f_{i,j,k}$表示选了前$i$种牌，一共用了$j$张，此时位于**自动机上$k$号点**的方案数

那么转移其实很简单，枚举第$i$种牌选的张数$t$，$f_{i,j,k}$向$f_{i+1,j+t,node_k.son_{a_i+t}}$转移，注意不要忘记乘上组合数$C_{4-a_i}^t$

求出$f$数组后最后的答案统计就十分简单了，令$m=4n-13$：

$$ans=\sum_{i=1}^m \frac{f_i\cdot i!\cdot(m-i)!}{m!}+1$$

这个很好理解，因为前后都可以随便选，因此不再赘述

综上，我们得到了一个复杂度上界为$2092\cdot n^2$的优秀做法，因为常数很小且跑不满因此足以通过

CODE

```cpp
#include<cstdio>
#include<cstring>
#include<map>
#define RI register int
#define CI const int&
using namespace std;
const int N=105,MX=2100,mod=998244353;
inline void maxer(int& x,CI y)
{
    if (y>x) x=y;
}
inline int min(CI a,CI b)
{
    return a<b?a:b;
}
struct Matrix
{
    int mat[3][3];
    inline int* operator [] (CI x) { return mat[x]; }
    inline Matrix(void)
    {
        memset(mat,-1,sizeof(mat));
    }
    friend inline bool operator != (Matrix A,Matrix B)
    {
        for (RI i=0;i<3;++i) for (RI j=0;j<3;++j)
        if (A[i][j]!=B[i][j]) return 1; return 0;
    }
    friend inline bool operator < (Matrix A,Matrix B)
    {
        for (RI i=0;i<3;++i) for (RI j=0;j<3;++j)
        if (A[i][j]!=B[i][j]) return A[i][j]<B[i][j];
    }
    inline bool Com_Hu(void)
    {
        for (RI i=0;i<3;++i) for (RI j=0;j<3;++j)
        if (mat[i][j]>=4) return 1; return 0;
    }
    inline void flush(Matrix pre,CI num)
    {
        for (RI i=0;i<3;++i) for (RI j=0;j<3;++j)
        if (~pre[i][j]) for (RI k=0;k<3&&i+j+k<=num;++k)
        maxer(mat[j][k],min(i+pre[i][j]+(num-i-j-k)/3,4));
    }
};
struct Hu_Auto_Node
{
    Matrix p[2]; int cur,ch[5];
    inline Hu_Auto_Node(void)
    {
        memset(ch,0,sizeof(ch)); cur=0; p[0]=p[1]=Matrix();
    }
    inline bool is_Hu(void)
    {
        if (cur>=7) return 1; return p[1].Com_Hu();
    }
    inline void Hu(void)
    {
        memset(ch,0,sizeof(ch)); cur=-1; p[0]=p[1]=Matrix();
    }
    friend inline bool operator < (Hu_Auto_Node A,Hu_Auto_Node B)
    {
        if (A.cur!=B.cur) return A.cur<B.cur;
        if (A.p[0]!=B.p[0]) return A.p[0]<B.p[0];
        if (A.p[1]!=B.p[1]) return A.p[1]<B.p[1]; return 0;
    }
    friend inline Hu_Auto_Node operator + (Hu_Auto_Node A,CI num)
    {
        if (A.is_Hu()) return A.Hu(),A; Hu_Auto_Node s;
        s.p[0].flush(A.p[0],num); s.p[1].flush(A.p[1],num);
        if (num>=2) s.p[1].flush(A.p[0],num-2);
        s.cur=A.cur+(num>=2); if (s.is_Hu()) s.Hu(); return s;
    }
};
class Hu_Automation
{
    private:
        map <Hu_Auto_Node,int> Hash;
        inline void expand(CI id)
        {
            for (RI i=0;i<=4;++i)
            {
                Hu_Auto_Node son=node[id]+i;
                if (!Hash.count(son)) node[Hash[son]=++tot]=son;
                node[id].ch[i]=Hash[son];
            }
        }
    public:
        Hu_Auto_Node node[2100]; int tot;
        inline Hu_Automation(void)
        {
            node[1].p[0][0][0]=0; node[tot=2].cur=-1;
            Hash[node[1]]=1; Hash[node[2]]=2; expand(1);
            for (RI i=3;i<=tot;++i) expand(i);
        }
        /*inline void check(void)
        {
            printf("%d\n",tot); for (RI i=1;i<=tot;++i,putchar('\n'))
            for (RI j=0;j<=4;++j) printf("%d ",node[i].ch[j]);
        }*/
}HA;
int f[2][N<<2][MX],a[N],fact[N<<2],inv[N<<2],n,m,x,y,nw,ans;
inline void inc(int& x,CI y)
{
    if ((x+=y)>=mod) x-=mod;
}
inline int quick_pow(int x,int p=mod-2,int mul=1)
{
    for (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;
}
inline void init(CI n)
{
    RI i; for (fact[0]=i=1;i<=n;++i) fact[i]=1LL*fact[i-1]*i%mod;
    for (inv[n]=quick_pow(fact[n]),i=n-1;~i;--i) inv[i]=1LL*inv[i+1]*(i+1)%mod;
}
inline int C(CI n,CI m)
{
    return 1LL*fact[n]*inv[m]%mod*inv[n-m]%mod;
}
inline void calc(CI x,CI y)
{
    inc(ans,1LL*f[nw][x][y]*fact[x]%mod*fact[m-x]%mod);
}
int main()
{
    RI i,j,k,t; for (scanf("%d",&n),i=1;i<=13;++i) scanf("%d%d",&x,&y),++a[x];
    for (init(m=(n<<2)-13),f[0][0][1]=i=1;i<=n;++i)
    for (nw=i&1,memset(f[nw],0,sizeof(f[nw])),j=m;~j;--j)
    for (k=1;k<=HA.tot;++k) if (f[nw^1][j][k]) for (t=0;t<=4-a[i];++t)
    inc(f[nw][j+t][HA.node[k].ch[a[i]+t]],1LL*f[nw^1][j][k]*C(4-a[i],t)%mod);
    for (nw=n&1,i=1;i<=m;++i) for (calc(i,1),j=3;j<=HA.tot;++j) calc(i,j);
    return printf("%d",(1LL*ans*inv[m]%mod+1)%mod),0;
}
```

---

## 作者：dsidsi (赞：7)

# Solution

考虑如何判断一个牌的集合是胡的。

 - 首先第一种牌型只需记录有多少中牌出现次数超过$2$。

 - 对于第二种牌型，可以用DP解决。设$f_{0/1,i,j,k}$已经考虑了前$i$种大小，表示之前是否预留了对子，之前预留了$j$对$i-1,i$,以及$k$个$i$用于凑顺子（大小相邻的麻将牌）。每次转移只需枚举第$i+1$种牌有多少张即可。

可以发现这个$DP$有效状态很少，只有$2092$种，所以可以把它当成一个自动机，这样就可以识别所有种类的胡牌了。

然后考虑解决本问题，一个经典套路是把每个集合的贡献为每次摸牌后检查有是否胡了，有则结束，没有则加$1$。也就是设$f(i)$表示摸了$i$张牌还没胡的集合数，答案为

$$\frac{\sum_{i=1}^{4n-13}f(i)\cdot i! \cdot (4n-13-i)!}{(4n-13)!}$$

设$f_{i,j,k}$表示已经考虑了大小为$1..i$的麻将牌，已经摸了$j$张牌，在自动机上的节点为$k$。每次转移时枚举下一种牌有多少乘上组合数转移即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline void chkmax(int &a, int b) {if (a < b) a = b;}

inline int gi()
{
	char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	int sum = 0;
	while('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

typedef long long ll;
const int maxn = 405, maxs = 2105, mod = 998244353;

struct node
{
	int f[3][3];

	node() {memset(f, -1, sizeof(f));}

	int* operator [] (const int a) {return f[a];}
	bool operator < (const node &a) const {
		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 3; ++j)
				if (f[i][j] != a.f[i][j]) return f[i][j] < a.f[i][j];
		return 0;
	}

	bool operator == (const node &a) const {
		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 3; ++j)
				if (f[i][j] != a.f[i][j]) return 0;
		return 1;
	}
	
};

struct mahjong
{

	node f, g;
	int cnt;

	mahjong() {f[0][0] = cnt = 0;}
	
	bool operator < (const mahjong &a) const {
		return f == a.f ? (g == a.g ? cnt < a.cnt : g < a.g) : f < a.f;
	}

	bool operator == (const mahjong &a) const {
		return f == a.f && g == a.g && cnt == a.cnt;
	}

	mahjong trans(int x)
	{
		mahjong ans;
		ans.cnt = min(7, cnt + (x >= 2));
		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 3; ++j) {
				if (~f[i][j]) {
					for (int k = 0; i + j + k <= x && k < 3; ++k)
						chkmax(ans.f[j][k], min(4, f[i][j] + i + ((x - i - j - k) >= 3)));
					if (x >= 2)
						for (int k = 0; i + j + k <= x - 2 && k < 3; ++k)
							chkmax(ans.g[j][k], min(4, f[i][j] + i));
				}
				if (~g[i][j]) {
					for (int k = 0; i + j + k <= x && k < 3; ++k)
						chkmax(ans.g[j][k], min(4, g[i][j] + i + ((x - i - j - k) >= 3)));
				}
			}
		return ans;
	}
	
} ;

map<mahjong, int> Id;
int tot, ch[maxs][5], h[maxs];
int n, s[maxn];
int fac[maxn], ifac[maxn], dp[2][maxn][maxs], *f[maxn], *g[maxn];

inline bool check(mahjong &s)
{
	if (s.cnt >= 7) return 1;
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j) if (s.g[i][j] >= 4) return 1;
	return 0;
}

int dfs(mahjong s)
{
	if (check(s)) return 0;
	int &t = Id[s];
	if (t) return t;
	t = ++tot;
	for (int i = 0; i <= 4; ++i)
		ch[t][i] = dfs(s.trans(i));
	return t;
}

inline int C(int n, int m)
{
	return (ll)fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

inline int A(int n, int m)
{
	return (ll)fac[n] * ifac[n - m] % mod;
}

int main()
{
	dfs(mahjong());
	
	n = gi();
	for (int w, i = 1; i <= 13; ++i) w = gi(), gi(), ++s[w];

	fac[0] = 1; ifac[0] = ifac[1] = 1;
	for (int i = 1; i <= (n << 2); ++i) fac[i] = (ll)fac[i - 1] * i % mod;
	for (int i = 2; i <= (n << 2); ++i) ifac[i] = (ll)(mod - mod / i) * ifac[mod % i] % mod;
	for (int i = 1; i <= (n << 2); ++i) ifac[i] = (ll)ifac[i - 1] * ifac[i] % mod;

	for (int i = 0; i <= (n << 2); ++i) f[i] = dp[1][i], g[i] = dp[0][i];

	g[0][1] = 1;
	for (int i = 0, sum = 0; i < n; ++i, sum += s[i]) {
		swap(f, g);
		for (int j = 0; j <= (i << 2); ++j)
			for (int k = 1; k <= tot; ++k) g[j][k] = 0;
		for (int j = sum; j <= (i << 2); ++j)
			for (int k = 1; k <= tot; ++k) {
				if (!f[j][k]) continue;
				for (int t = s[i + 1]; t <= 4; ++t)
					if (ch[k][t]) g[j + t][ch[k][t]] = (g[j + t][ch[k][t]] + (ll)C(4 - s[i + 1], t - s[i + 1]) % mod * f[j][k]) % mod;
			}
	}

	int ans = 0;
	for (int i = 1; i <= (n << 2) - 13; ++i) {
		int sum = 0;
		for (int j = 1; j <= tot; ++j) sum = (sum + g[i + 13][j]) % mod;
		ans = (ans + (ll)sum * fac[i] % mod * fac[4 * n - 13 - i]) % mod;
	}
	printf("%lld\n", ((ll)ans * ifac[4 * n - 13] + 1) % mod);
	
	return 0;
}
```

---

## 作者：MatrixGroup (赞：5)

## 前言

非确定性有限状态自动机 $\to$ 确定性有限状态自动机 $\to$ 爆搜有效状态 $\to$ dp。

等等，为什么别的题解里都跑出了 $2\,092$ 或 $3\,956$ 个状态？

## 题意

有一套只有一种花色的麻将，$1\sim n$ 的数牌各有 $4$ 张。将其随机打乱后，给定前 $13$ 张牌，求最短的包含一个和牌的子集的前缀的长度的期望。和牌型包含基本型（四个面子和一个对子）和七对子（七个不同的对子）。

$n\le 100$。

## 题解

首先转化一下题意。对于取值为正整数的随机变量 $X$，有 $\mathbb E[X]=\sum\limits_{i=0}^{+\infty} \Pr[X>i]$。换言之，我们只需要对于每个 $i$ 求出拿了 $i$ 张牌还没和的概率即可。

考虑先对于一个表示每种牌出现次数的序列 $\{c_i\}$ 设计一个判定和牌的非确定有限状态自动机。对于基本型，记录 $(i,j,k,t)$ 表示当前有 $i$ 个已经完成的面子，$j$ 个待完成的两面搭子，$k$ 个当前牌的单张和是否已经有对子。显然，同一种顺子有三个可以看成同一种刻子有三个，因此一定可以使 $j,k\le 2$，而因为总共最多四个面子，有 $i+j+k\le 4$，因此这样的状态一共有 $54$ 个。对于七对子，记录目前有 $0\sim 7$ 个对子，共有 $8$ 个状态。这就设计好了。

再考虑对于一个表示每种牌出现次数的序列 $\{c_i\}$，如何判定它有没有一个和牌的子集。直接考虑记录它的所有子集能走到的那些状态即可。看似可能有 $2^{62}$ 个状态，但是直觉告诉我们这些状态能否走到一定是非常关联的。（比如，能走到的两个状态一定牌数相同）实际上只有 $\boxed{c=1\,840}$ 个状态。

那么我们就可以 dp。$dp_{i,j,k}$ 表示前 $i$ 种数牌拿了 $j$ 个走到 $k$ 的子集数。注意转移要乘组合数。$i$ 这一维可以滚动掉。这样时间复杂度就是 $O(n^2S)$ 的，可以通过。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,del##i##verme=int(n);i<del##i##verme;++i)
#define rep1(i,n) for(int i=1,parano##i##a=int(n);i<=parano##i##a;++i)
typedef long long ll;
using namespace std;
const ll mod1=998244353;
int tp[2222],n0[2222],n1[2222],n2[2222],p[2222],cnt; 
int f[2][9][5][5][5];
ll trans(ll state,int ad)
{
	ll ret=0;
	rep(i,cnt) if((state>>i)&1)
	{
		if(tp[i]==0)
		{
			int a=n0[i],x=n1[i],y=n2[i],z=p[i];
			if(ad>=x+y)
			{
				int d=ad-x-y;
				a+=x+(d/3);x=y;y=d%3;
				if(f[0][a][x][y][z]!=-1) ret|=1ll<<f[0][a][x][y][z];
				if(!z&&d>=2)
				{
					d-=2;if(f[0][n0[i]+n1[i]][n2[i]][d][1]!=-1)
					ret|=1ll<<f[0][n0[i]+n1[i]][n2[i]][d][1];
				}
			}
		}
		else if(ad==2)
		{
			if(n0[i]!=7) ret|=2ll<<i;
		}
		else if(ad==0)
		{
			ret|=1ll<<i;
		}
	}
	return ret;
}
map<ll,int> id;
int c;ll ft[3141];
int trs[5][3141];
bool ok[3141];
void dfs(ll x)
{
	if(id[x]) return ;
	id[x]=++c;ft[c]=x;
	ll ret=0;
	rep(i,5)
	{
		ret|=trans(x,i);
		dfs(ret);
	}
}
ll C[405][405];
void init()
{
	memset(f,-1,sizeof(f));
	rep(a,5) rep(i,3) rep(j,3) rep(k,2) if(a+i+j<=4)
	{
		tp[cnt]=0;n0[cnt]=a;
		n1[cnt]=i;n2[cnt]=j;p[cnt]=k;
		f[0][a][i][j][k]=cnt++;
	}
	rep(i,8)
	{
		tp[cnt]=1;n0[cnt]=i;
		n1[cnt]=n2[cnt]=p[cnt]=0;
		f[1][i][0][0][0]=cnt++;
	}
	dfs((1ll<<f[0][0][0][0][0])|(1ll<<f[1][0][0][0][0]));
	rep1(i,c)
	{
		ll ret=0;
		rep(j,5) trs[j][i]=id[ret|=trans(ft[i],j)];
	}
	rep1(i,c)
	{
		if(((ft[i]>>f[0][4][0][0][1])&1)||((ft[i]>>f[1][7][0][0][0])&1))
		ok[i]=true;
		else
		ok[i]=false; 
	}
	C[0][0]=1;
	rep1(i,400)
	{
		C[i][0]=C[i][i]=1;
		rep1(j,i-1)
		{
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod1;
		}
	}
}
ll qkpw(ll a,ll b)
{
	ll r=1;
	while(b)
	{
		if(b&1)r=r*a%mod1;
		a=a*a%mod1;
		b>>=1;
	}
	return r;
}
int n,a,b;
int cc[105];
ll dp[405][2005],nw[405][2005];
int main()
{
	init();
	cin>>n;
	rep1(i,13)
	{
		cin>>a>>b;++cc[a];
	}
	dp[0][1]=1;
	rep1(i,n)
	{
		memset(nw,0,sizeof(nw));
		rep(j,i*4-3) rep1(k,c) if(dp[j][k])
		{
			for(int l=cc[i];l<=4;++l)
			{
				nw[j+l][trs[l][k]]+=dp[j][k]*C[4-cc[i]][4-l];
			}
		}
		rep(j,i*4+1) rep1(k,c) dp[j][k]=nw[j][k]%mod1;
	}
	ll answer=0;
	for(int i=13;i<=4*n;++i)
	{
		ll cur=0; 
		for(int j=1;j<=c;++j)
		{
			if(!ok[j]) cur+=dp[i][j];
		}
		cur%=mod1;
		answer=(answer+cur*qkpw(C[4*n-13][i-13],mod1-2))%mod1;
	}
	cout<<answer<<endl;
	return 0;
}
```

---

## 作者：Demoe (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/P5279)

~~突然想起某个神仙教了我这道神仙题qwq那就巩固一下吧~~

## 题意简述

- 你有13张牌，还有 $4n-13$ 张牌未摸。

- 对于未摸的所有排列，定义 $P$ 为最小的 $i$ 满足 $S_i$ 存在一个子集是胡的。

- 求 $P$ 的期望。

# dp of dp

先考虑我们**最后**需要什么。

假设我们知道 $g_i$ 表示摸了 $i$ 张牌后**不胡**的方案数。

那么我们可以将答案转化成下式。

$\dfrac{\sum_{i=1}^{4n-13}g_i*i!(4n-13-i)!}{(4n-13)!}+1$

因此，我们将答案转化为摸了 $i$ 张牌**不胡**的方案数。

如何判断一副牌胡没胡呢（~~看出来~~）。

我们首先可以把相同的三个顺子视为三个刻子，这对结果没有影响。

那我们可以认为，**相同的顺子最多只有两个**。

先不考虑七对子的情况。

我们设 $f_{i,k,l,x}$ 表示只考虑 $[1,i]$ 之间的麻将，从 $i-1$ 开始的**刻子**有 $k$ 张，从 $i$ 开始的**刻子**有 $l$ 张，是否已经选出了一个对子（即 $x=0/1$），**最多**能组成多少刻子。

那么能胡牌的条件就是 $f_n,k,l,1>3$。

七对子易特判。

所以把18维的状态全压进dp里就好啦。

令 $dp_{i,j,k,S}$ 表示用了 $[1,i]$，一共选了 $j$ 张牌，用 $k$ 种牌可以组成**对子**，且18维dp的状态是 $S$ 的方案数。

这个 $S$ 看起来好大怎么办qaq，可以考虑**提前搜出所有可能**的 $S$。

我们可以把所有合法的状态**统一**为状态 $T$。

~~暴力~~发现不胡的状态**不超过3000**，可以直接莽dpqwq。

附上代码qwq。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll Mo=998244353;
ll m,n,p,nxt[3005][5],tot,vis[105],C[5][5],fac[505],inv[505],dp[105][405][4005];
map<vector<ll>,ll>mp;
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
inline void Max(ll &x,ll y){x=max(x,y);}
ll dfs(vector<ll> nw){
	if(mp.find(nw)!=mp.end()) return mp[nw];
	mp[nw]=++tot;
	ll ID=tot;
	for(ll i=0;i<=4;++i){
		vector<ll> temp; temp.clear();
		for(ll j=0;j<19;++j) temp.push_back(-1);
		temp[18]=nw[18]+(i>=2);
		for(ll a=0;a<3;++a) for(ll b=0;b<3;++b) for(ll k=0;k<3&&a+b+k<=i;++k){
			if(nw[a+b*3]!=-1) Max(temp[b+k*3],nw[a+b*3]+a+(i-a-b-k)/3);
			if(nw[a+b*3+9]!=-1) Max(temp[b+k*3+9],nw[a+b*3+9]+a+(i-a-b-k)/3);
			if(a+b+k+2<=i&&nw[a+b*3]!=-1) Max(temp[b+k*3+9],nw[a+b*3]+a); 
		}
		for(ll j=0;j<18;++j) temp[j]=min(temp[j],4ll);
		if(temp[9]>=4||temp[18]>=7) nxt[ID][i]=0;
		else nxt[ID][i]=dfs(temp);
	}
	return ID;
}
ll pre(){
	vector<ll> nw;
	for(ll i=0;i<18;++i) nw.push_back(-1); nw.push_back(0);
	nw[0]=0;
	return dfs(nw);
}
ll pw(ll x,ll y){
	ll s=1;
	while(y){
		if(y&1) s=1ll*s*x%Mo;
		x=1ll*x*x%Mo;y>>=1;
	}
	return s;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	dp[0][0][pre()]=1;
	rd(n);
	for(ll i=0;i<=4;++i){
		C[i][0]=1;
		for(ll j=1;j<=i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mo;
	}
	fac[0]=1;
	for(ll i=1;i<505;++i) fac[i]=1ll*fac[i-1]*i%Mo;
	for(ll i=0;i<505;++i) inv[i]=pw(fac[i],Mo-2); 
	for(ll i=1,x,y;i<=13;++i){
		rd(x),rd(y);
		vis[x]++; 
	}
	ll ans=0;
	for(ll i=1;i<=n;++i)
		for(ll j=0;j<=4*(i-1);++j)
			for(ll k=1;k<=tot;++k)
				if(dp[i-1][j][k])
					for(ll l=0;l<=4-vis[i];++l)
						(dp[i][j+l][nxt[k][vis[i]+l]]+=1ll*dp[i-1][j][k]*C[4-vis[i]][l]%Mo)%=Mo;
	for(ll j=0;j<=4*n-13;++j) 
		for(ll k=1;k<=tot;++k)
			if(dp[n][j][k]) (ans+=1ll*fac[j]*fac[4*n-13-j]%Mo*dp[n][j][k]%Mo)%=Mo;
	wr(1ll*ans*inv[4*n-13]%Mo);puts("");
	return 0;
}
```

欢迎碾压qaq。

~~有没有大神带我玩awa。~~

---

## 作者：hwk0518 (赞：3)

这道题可以使用$DP$  $of$  $DP$解决。

$DP$  $of$  $DP$是一种可以用来求解能够得到一个能用$DP$解决的问题的答案的方式（或称状态）有几种的手段。

先来考虑如何判定一个局面是否已经结束。如果原题能用$DP$  $of$  $DP$解决，那么根据定义，这应该是一个能用$DP$解决的问题。

比较直观的想法是记$dp[i][j][k][x][y]$为选了前$i$种牌，第$i-1$种牌有$j$张，第$i-2$种牌有$k$张，已经有$x$个顺子或三张，$y$个对子，这个局面是否合法。

但是这样状态太多了，考虑优化，主要有两种手段：

$(1)$再使用$DP$  $of$  $DP$记录能使状态合法的最小的$x$和$y$.

$(2)$发现三个相同的顺子可以变成三个三张，所以$j$和$k$的值域就从$4$变为$2$。然后$k$如果不和$j$&$i$组成顺子，就是无用的。所以记$dp[i][j][k][y]$表示选了前$i$种牌，第$i-1$种牌开头的顺子有$j$个，第$i-2$种牌开头的顺子有$k$个，是否有对子，这种状态下能拥有的最大顺子/三张数。

容易看出，第二种方法较易实现。且状态数不到$4000$种。

我们再总结一下一个状态要记录那些值。首先是$y=0$的九个$dp[j][k]$，然后是$y=1$的九个$dp[j][k]$。由于七个对子也合法，还要记录当前已有的对子数。（注意：七个对子的值应当**两两不同**。）

接下来就可以开始外层的$DP$了。记录$dp[i][j][k]$表示考虑了前$i$种牌，已经选了$j$张，当前状态为$k$的方案数。转移时枚举第$i+1$种牌选了几张即可。

最后一个问题是如何计算答案。

我们知道期望可以用概率算。记$P(i)$表示恰好$i$步后结束的概率，则有：

$E=\sum_{i=0 \to inf}P(i)*i$

记$Q(i)=\sum_{j=i \to inf}P(j)$

则$E=\sum_{i=0 \to inf}Q(i)$

容易发现，$Q(i)$的实际意义是$i-1$步后尚未结束的概率。

于是我们枚举当前已选的牌数$j$，即可算出当前不合法的方案数和总方案数。二者之比设为$f(j)$。

则有：

$ans=\sum_{i=13 \to inf}f(i)$

代码：

```

//ZJOI2019  Day1
//MahJong
//Author : HeWenKun
//Solution : Dp of Dp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
#include<map>
using namespace std;

const int N=105;
const int M=405;
const int S=4000;
const int mod=998244353;

int n,cnt[N],dp[N][M][S];
int ch[S][5],C[5][5];

namespace MATHEMATICS
{
	int add(int x,int y)
	{
		int ret=x+y;
		if(ret>=mod) ret-=mod;
		return ret;
	}
	int mi(int x,int y)
	{
		int ret=x-y;
		if(ret<0) ret+=mod;
		return ret;
	}
	
	void inc(int &x,int y)
	{
		x+=y;
		if(x>=mod) x-=mod;
	}
	void dec(int &x,int y)
	{
		x-=y;
		if(x<0) x+=mod;
	}
	
	int mul(int x,int y)
	{
		return 1LL*x*y%mod;
	}
	int F_p(int x,int y)
	{
		int bas=x,ret=1;
		while(y)
		{
			if(y&1) ret=mul(ret,bas);
			bas=mul(bas,bas);
			y>>=1;
		}
		return ret;
	}
}
using namespace MATHEMATICS;

namespace prework_ch
{
	struct mat
	{
		int a[3][3];
	};
	mat fir,sec;
	struct ddp
	{
		pair<mat,mat> d;
		int pcnt;
	};
	
	map<ddp,int> M;int M_tot=0;
	ddp lis[S];
	bool fi[S];
	
	bool operator < (mat x,mat y)
	{
		int i,j;
		for(i=0;i<3;++i)
			for(j=0;j<3;++j)
			{
				if(x.a[i][j]<y.a[i][j]) return true;
				else if(x.a[i][j]>y.a[i][j]) return false;
			}
		return false;
	}
	bool operator < (ddp x,ddp y)
	{
		if(x.d.first<y.d.first) return true;
		else if(y.d.first<x.d.first) return false;
		if(x.d.second<y.d.second) return true;
		else if(y.d.second<x.d.second) return false;
		if(x.pcnt<y.pcnt) return true;
		else if(x.pcnt>y.pcnt) return false;
		return false;
	}
	
	int max(int x,int y)
	{
		return x>y?x:y;
	}
	mat max(mat x,mat y)
	{
		int i,j;mat ret;
		for(i=0;i<3;++i)
			for(j=0;j<3;++j)
				ret.a[i][j]=max(x.a[i][j],y.a[i][j]);
		return ret;
	}
	
	void prework()
	{
		int i,j;
		for(i=0;i<3;++i)
			for(j=0;j<3;++j)
			{
				if(!i&&!j) fir.a[i][j]=0,sec.a[i][j]=-1;
				else fir.a[i][j]=sec.a[i][j]=-1;
			}
	}
	
	int calc(int x)
	{
		return (x>=3)?1:0;
	}
	mat transl(mat x,int cnt)
	{
		int i,j,k;mat ret=sec;
		for(i=0;i<=2;++i)
			for(j=0;j<=2;++j)
			{
				int tt=x.a[i][j];
				if(tt<0) continue;
				for(k=0;k<=2;++k)
					if(i+j+k<=cnt)
						ret.a[j][k]=max(ret.a[j][k],min(tt+i+calc(cnt-i-j-k),4));
			}
		return ret;
	}
	
	ddp trans(ddp x,int cnt)
	{
		mat xx=transl(x.d.first,cnt);
		mat yy;int zz=x.pcnt;
		if(cnt>=2) yy=max(transl(x.d.second,cnt),transl(x.d.first,cnt-2)),++zz;
		else yy=transl(x.d.second,cnt);
		
		ddp ret;ret.d=make_pair(xx,yy);ret.pcnt=min(zz,7);
		return ret;
	}
	
	void dfs(ddp x)
	{
		int i,j;
		if(M[x]) return;
		M[x]=++M_tot;
		lis[M_tot]=x;
		for(i=0;i<=4;++i) dfs(trans(x,i));
	}
	
	bool ok(ddp x)
	{
		int i,j;
		if(x.pcnt>=7) return true;
		for(i=0;i<3;++i)
			for(j=0;j<3;++j)
				if(x.d.second.a[i][j]>=4)
					return true;
		return false;
	}
	
	void work()
	{
		int i,j;ddp now;
		prework();now.d=make_pair(fir,sec),now.pcnt=0;dfs(now);
		for(i=1;i<=M_tot;++i)
		{
			fi[i]=ok(lis[i]);
			for(j=0;j<=4;++j)
				ch[i][j]=M[trans(lis[i],j)];
		}
	}
}

void init()
{
	int i,j;
	scanf("%d",&n);
	for(i=1;i<=13;++i)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		++cnt[x];
	}
	
	for(i=0;i<=4;++i) C[i][i]=C[i][0]=1;
	for(i=2;i<=4;++i)
		for(j=1;j<i;++j)
			C[i][j]=C[i-1][j]+C[i-1][j-1];
}

void work()
{
	int i,j,k,m=4*n,now,ans=0;
	dp[0][0][1]=1;
	for(i=0;i<n;++i)
		for(j=0;j<=m;++j)
			for(k=1;k<=prework_ch::M_tot;++k)
			{
				int tt=dp[i][j][k];
				if(!tt) continue;
				for(now=cnt[i+1];now<=4&&j+now<=m;++now)
					inc(dp[i+1][j+now][ch[k][now]],mul(tt,C[4-cnt[i+1]][now-cnt[i+1]]));
			}
	
	for(j=13;j<=m;++j)
	{
		int tot=0,canreach=0;
		for(k=1;k<=prework_ch::M_tot;++k)
		{
			inc(tot,dp[n][j][k]);
			if(prework_ch::fi[k]) inc(canreach,dp[n][j][k]);
		}
		inc(ans,mul(mi(tot,canreach),F_p(tot,mod-2)));
	}
	
	printf("%d\n",ans);
}

int main()
{
	prework_ch::work();init();work();
	return 0;
}


```

---

## 作者：mulberror (赞：3)

$$\href{http://blog.chhokmah.cn/index.php/archives/33/}{\Large\texttt{My blog}}$$

---
## 题目链接
[Luogu5279](https://www.luogu.com.cn/problem/P5279)

## 题目描述
现在有一个$4\times n$的一个牌堆并随机打乱。  
一开始给定你$13$张牌，问再摸若干张牌，牌集中存在一个可以胡的子集的期望步数。  
数据范围：$n\leq 100$  

## 思路要点
先做个解释：顺子是连着的三个，刻子是相同的三个，$\text{面子}=\text{顺子}+\text{刻字}$（~~我不玩雀魂~~）
### 子任务讨论
首先需要解决一个子问题就是怎样判断一个牌集拥有一个能够胡的子集。
#### 条件一
第一个条件：四个面子+一个对子  
我们参考[CodeForces Glogal Round 1 D](https://codeforces.com/contest/1110/problem/D)的做法，但是这篇博客的代码实现上稍有不同。  
**一个结论：相同花色顺子最多$2$个，因为三个相同的顺子可以等价给三个不同的刻子，而且对答案没有影响**  
首先不考虑对子的情况，定义状态$f[i][j][k]$表示当前处理完$[1,i]$花色，其中$(i-1,i)$有$j$对，$i$剩下有$k$个下最大的面子数  
**注意！我们都是先满足顺子，然后满足刻子**  
那么考虑加入$i+1$，我们枚举下一个状态还剩下$t$个$i+1$，因为先满足顺子，所以这里假定顺子已经填满了，增加了$i$的贡献，此时还剩下的若干个相同花色的，我们就考虑全部转化成刻子。  
所以状态转移方程为：$f[i+1][j][k]=Max\{ i+f[i][j][k]+\lfloor \frac{remain}3\rfloor\}$  
但是题目中还需要有一个对子，所以我们把状态定义为$f[0/1][i][j][k]$，其中的$i,j,k$意义不变，新增一维表示是否已经出现对子。$f[0]$和$f[1]$内部的转移还是和上面一样。考虑$f[0]$和$f[1]$之间的转移，如果我们当前加入花色的个数$\geq 2$，我们就可以先消耗两个花色，然后从$f[0]$转移到$f[1]$。  
#### 条件二
第二个条件：七个对子  
因为状态相对于第一个条件独立，所以直接考虑新开一维$cnt$，表示不同花色的对子个数。  
**注意！一定是花色不同，即一次修改只能修改$1$**  
#### 子任务实现
可以开一个结构体，方便处理。（因为我们需要用$\mathrm{map}$去重）  

### 构造自动机
考虑到这个状态的总数应该不会太多，所以我们考虑先预处理出自动机。  
稍微科普一下，简单点说，自动机就是状态为节点，转移为有向边的一个东西。  
自动机的构造，因为有限状态，所以通过搜索来得到自动机的复杂度是正确的。  
构造的时候，我们对于当前状态，必须要枚举下一个牌放多少张$[0,4]$。（这样才能保证我们上面的$DP$的正确性）  
这里实测：本质不同的状态数有$3956$，本质不同的**不胡状态数**有$2092$。  
具体构造的方式可以参考下方代码  

### DP统计方案数
构造了自动机后，我们就要统计方案数了。  
定义$f[i][j][k]$表示当前考虑前$i$个花色，摸了$j$张牌，当前的胡牌状态为$k$的方案数。  
**请注意这里是组合数**  
考虑第$i+1$张牌摸的数量$t$。  
$$f[i+1][j+t][nxtState(k,t)]+=f[i][j][k]\times {all \choose chooseCount}$$  

### 统计答案
如何统计答案，我们先回顾一下原题：  
* 题意：求出存在能胡子集的期望步数。  

设$P(i)$为走了$i$就胡了的概率，则答案$Ans=\sum_{i=0}^{\infty} P(i)\times i$  
转化$P_1(i)=\sum_{j=i}^{\infty P(i)}$  
代入原式得到了$Ans=\sum_{i=1}^{\infty} P_1(i)$  
重视一下$P_1(i)$的含义，我们可以发现$P_1(i)$就代表$i$及以后胡的概率，也就是前$i-1$次不胡的概率（因为后面延伸到无限，所以只要满足前$i-1$次不胡，根据题目中所说**不难发现$P$的权值就是理论上的最早胡牌巡目数**，那么后面一定能胡）  
所以题目的答案又被转化成了不能胡的概率和。  
我们用式子来表示  
$$Ans=\sum \frac {g(i)}{sum(i)}$$  
$g(i)$就是手中一共有$i$张牌，还不能胡的方案数。  
$sum(i)$表示$i$张牌的总方案数。  

时间复杂度是$\mathcal O(3956\times n\times m)$  

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

template <class T> 
void chkmax(T& x, T y) {
  x = x > y ? x : y; 
}

template <class T> 
void chkmin(T& x, T y) {
  x = x < y ? x : y;
}

template <class T> 
void read(T& x) {
  x = 0; char ch = 0; int f = 1;
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) x = x * 10 + (ch ^ 48);
  x *= f;
}

template <class T> 
void write(T x) {
  if (x < 0) putchar('-'), x = -x;
  if (x > 9) write(x / 10);
  putchar(x % 10 + 48);
}

template <class T> 
void writeln(T x) {
  write(x), puts("");
}

const int SIZE = 4000;

struct State {
  int dp[3][3];
  
  State() {
    memset(dp, -1, sizeof dp);
  }
  
  friend bool operator < (State a, State b) {
    for (int i = 0; i <= 2; i++) {
      for (int j = 0; j <= 2; j++) {
        if (a.dp[i][j] != b.dp[i][j]) {
          return a.dp[i][j] < b.dp[i][j];
        }
      }
    }
    return 0;
  }
  
  friend State operator + (State a, int num) {
    State res;
    for (int i = 0; i <= 2; i++) {
      for (int j = 0; j <= 2; j++) {
        if (~a.dp[i][j]) {
          for (int k = 0; k <= 2 && i + j + k <= num; k++) {
            chkmax(res.dp[j][k], min(4, a.dp[i][j] + i + (num - i - j - k) / 3));
          }
        }
      }
    }
    return res;
  } 
  
  friend State operator + (State a, State b) {
    for (int i = 0; i <= 2; i++) {
      for (int j = 0; j <= 2; j++) {
        chkmax(a.dp[i][j], b.dp[i][j]);
      }
    }
    return a;
  }
};

struct Mahjong {
  pair<State, State> s;
  int cnt;
  
  Mahjong() {
    memset(s.first.dp, -1, sizeof s.first.dp);
    memset(s.second.dp, -1, sizeof s.second.dp);
    s.first.dp[0][0] = cnt = 0;
  }
  
  friend bool operator < (Mahjong a, Mahjong b) {
    return a.cnt == b.cnt ? a.s < b.s : a.cnt < b.cnt;
  }
  
  friend Mahjong operator + (Mahjong a, int num) {
    a.cnt = min(7, a.cnt + (num >= 2));
    a.s.second = a.s.second + num;
    if (num >= 2) {
      a.s.second = a.s.second + (a.s.first + (num - 2));
    }
    a.s.first = a.s.first + num;
    return a;
  }
  
  bool check() {
    if (cnt >= 7) {
      return 1;
    }
    for (int i = 0; i <= 2; i++) {
      for (int j = 0; j <= 2; j++) {
        if (s.second.dp[i][j] >= 4) {
          return 1;
        }
      }
    }
    return 0;
  }
};

map<Mahjong, int> idx;
int tot;
bool finish[SIZE];
Mahjong g[SIZE];

void dfs(Mahjong sta) {
  if (idx.count(sta)) {
    return;
  }
  idx[sta] = ++tot;
  finish[tot] = sta.check();
  g[tot] = sta;
  for (int i = 0; i <= 4; i++) {
    dfs(sta + i);
  }
}

const int MOD = 998244353;
const int N = 105;

int n;
int a[N];
int binom[5][5];
int trans[SIZE][5];
int dp[N][N << 2][4000];

int mul(int x, int y) {
  return (long long)x * y % MOD;
}

int add(int x, int y) {
  return (x += y) >= MOD ? x -= MOD : x;
}

int power(int x, int y) {
  int res = 1;
  for (; y; y >>= 1, x = mul(x, x)) {
    if (y & 1) {
      res = mul(res, x);
    }
  }
  return res;
}

int main() {
  dfs(Mahjong());
  for (int i = 1; i <= tot; i++) {
    for (int j = 0; j <= 4; j++) {
      trans[i][j] = idx[g[i] + j];
    }
  }
  binom[0][0] = 1;
  for (int i = 1; i <= 4; i++) {
    binom[i][0] = binom[i][i] = 1;
    for (int j = 1; j < i; j++) {
      binom[i][j] = add(binom[i - 1][j], binom[i - 1][j - 1]);
    }
  }
  read(n);
  for (int i = 1; i <= 13; i++) {
    int x, y;
    read(x), read(y);
    a[x]++;
  }
  dp[0][0][1] = 1;
  for (int i = 0; i <= n - 1; i++) {
    for (int j = 0; j <= 4 * i; j++) {
      for (int k = 1; k <= tot; k++) {
        for (int t = a[i + 1]; t <= 4; t++) {
          dp[i + 1][j + t][trans[k][t]] = add(dp[i + 1][j + t][trans[k][t]], mul(dp[i][j][k], binom[4 - a[i + 1]][t - a[i + 1]]));
        }
      }
    }
  }
  int ans = 0;
  for (int i = 13; i <= n * 4; i++) {
    int sum = 0, t = 0;
    for (int j = 1; j <= tot; j++) {
      sum = add(sum, dp[n][i][j]);
      if (!finish[j]) {
        t = add(t, dp[n][i][j]);
      }
    }
    ans = add(ans, mul(t, power(sum, MOD - 2)));
  }
  writeln(ans);
  return 0;
}
```

---

## 作者：Phartial (赞：1)

先考虑如何判定一个牌集是否存在一个胡牌的子集，我们将其映射到状态 $(i,j,k,0/1)$，意为只考虑 $\le x$ 的牌（$x$ 和状态无关），目前有 $i$ 个面子，$j$ 对待匹配的 $x-1,x$，$k$ 张待匹配的 $x$，且是否已经有了一个对子。由于三个相同的顺子等价于三个相邻的刻子，有约束 $j,k\le 2$，且 $i+j+k\le 4$。

考虑 $x+1$ 的个数 $v$，有限制 $j+k\le v$，且 $j$ 对 $x-1,x$ 变为 $j$ 个面子，$k$ 张 $x$ 变为 $k$ 对 $x,x+1$，接下来只需要考虑剩下的 $v-j-k$ 张牌中是否需要拿一个刻子，是否需要拿一个对子，留多少牌到之后匹配。

再额外建 $7$ 个状态用来表示七对子，总状态数只有 $27\times 2+7=61$ 种。

于是我们得到了一个 NFA，接下来对于一个牌集，我们记录它能到达的所有 NFA 状态作为一个 DFA 状态，并将所有这样的 DFA 状态通过 BFS 搜出来，只要 DFA 状态中有 $(4,0,0,1)$ 或七对子这两个 NFA 状态就视作胡牌状态，可以全部缩起来。

然后就可以在这个 DFA 上 dp 了！设 $f(i,j,k)$ 表示在 $\le i$ 的牌中选出了 $j$ 张牌（初始手上有的牌必选），且这些牌在 DFA 上的状态为 $k$ 的方案数。转移是简单的，注意大小相同的牌也要在乎顺序。

最后由于有 $\displaystyle E(X)=\sum_{i\ge 0}P(X>i)$，我们只需要求出 $\displaystyle P(X>i)=1-\frac{f(n,i+13,\text{finish state})}{{4n-13\choose i}}$ 即可。

时间复杂度 $\Theta(n^2S)$，其中 $S$ 为 DFA 状态数，下述实现中 $S=1531$。

https://www.luogu.com.cn/paste/ih6mfp1v.

---

## 作者：xujindong_ (赞：1)

首先考虑怎么判定一个集合是否存在一个子集胡。对正常胡牌，按值域从小到大 DP，设 $f_{i,j,k,0/1}$ 表示考虑完大小为 $i$ 的牌，有 $j$ 个 $i-1$ 开始的顺子，$k$ 个 $i$ 开始的顺子，有无雀头，此时的最大面子数。因为三同顺可以看成三连刻，所以 $j,k$ 不超过 $2$。转移就讨论是否预留雀头，先接上之前的顺子，再枚举开启几个顺子，剩下的当刻子。对于七对子额外记录一个 $num$ 表示不同对子个数，两种胡牌方式的转移是相互独立的。

此时我们可以把 DP 改成自动机，状态就是 $(f,num)$，共 $19$ 个值，转移为下一种牌的数量 $0\sim 4$。若 $num\geq 7$ 或 $f$ 中有雀头的任一值 $\geq 4$ 就胡了。将自动机搜出来，发现只有约两千个状态。

计算这个期望有经典转化：$\sum_{i=1}^{+\infty}iP(n=i)=\sum_{i=1}^{+\infty}P(n\geq i)=1+\sum_{i=1}^{+\infty}P(n>i)$。此时我们只需要求每个 $P(n>i)$ 即第 $i$ 巡未胡的概率。第 $i$ 巡的方案数为 $C_{4n-13}^{i}$，可以转化为求有几个大小为 $i$ 的集合不胡。设 $f_{i,j,k}$ 为考虑完大小为 $i$ 的牌，选了 $j$ 张，在自动机的节点 $k$ 的方案数，有 $f_{i+1,j+l,tr_{k,l}}\gets C_{4-a_{i+1}}^{l-a_{i+1}}f_{i,j,k}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int n,a[105],tr[2097][5],cnt=1,fac[405],vac[405],f[2][405][2097],sum[405],ans;
map<pair<vector<int>,int>,int>vis;
int id(int x,int y,int z){
  return x*6+y*2+z;
}
int dfs(vector<int>f,int num){
  if(vis[make_pair(f,num)])return vis[make_pair(f,num)];
  vis[make_pair(f,num)]=++cnt;
  for(int x=0;x<=4;x++){
    vector<int>g(18,-0x3f3f3f3f);
    for(int i=0;i<3;i++){
      for(int j=0;j<3;j++){
        for(int k=0;k<2;k++){
          if(f[id(i,j,k)]==-0x3f3f3f3f)continue;
          for(int l=0;l<3;l++){
            if(i+j+l<=x)g[id(j,l,k)]=max(g[id(j,l,k)],min(f[id(i,j,k)]+i+(x-i-j-l>=3),4));
            if(i+j+l+2<=x&&!k)g[id(j,l,1)]=max(g[id(j,l,1)],min(f[id(i,j,0)]+i,4));
          }
        }
      }
    }
    bool t=(num+(x>=2))>=7;
    for(int i=1;i<18;i+=2)if(g[i]>=4)t=1;
    if(t)tr[vis[make_pair(f,num)]][x]=1;
    else tr[vis[make_pair(f,num)]][x]=dfs(g,num+(x>=2));
  }
  return vis[make_pair(f,num)];
}
int main(){
  for(int i=0;i<=4;i++)tr[1][i]=1;
  vector<int>s(18,-0x3f3f3f3f);
  s[0]=0,dfs(s,0),f[0][0][2]=fac[0]=vac[0]=vac[1]=1,cin>>n;
  for(int i=2;i<=4*n-13;i++)vac[i]=1ll*vac[mod%i]*(mod-mod/i)%mod;
  for(int i=1;i<=4*n-13;i++)fac[i]=1ll*fac[i-1]*i%mod,vac[i]=1ll*vac[i]*vac[i-1]%mod;
  for(int i=1,w,t;i<=13;i++)cin>>w>>t,a[w]++;
  for(int i=0;i<n;i++){
    memset(f[~i&1],0,sizeof(f[~i&1]));
    for(int j=0;j<=4*i;j++){
      for(int k=1;k<=cnt;k++){
        if(!f[i&1][j][k])continue;
        for(int l=a[i+1];l<=4;l++)f[~i&1][j+l][tr[k][l]]=(f[~i&1][j+l][tr[k][l]]+1ll*f[i&1][j][k]*fac[4-a[i+1]]%mod*vac[l-a[i+1]]%mod*vac[4-l]%mod)%mod;
      }
    }
  }
  for(int i=1;i<=4*n-13;i++)for(int j=2;j<=cnt;j++)sum[i]=(sum[i]+f[n&1][i+13][j])%mod;
  for(int i=1;i<=4*n-13;i++)ans=(ans+1ll*sum[i]*fac[i]%mod*fac[4*n-13-i]%mod*vac[4*n-13]%mod%mod)%mod;
  return cout<<(ans+1)%mod<<'\n',0;
}
```

跑 DFA 最小化，最小化后只有 $567$ 个节点，可以打表。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353,C[5][5]={{1},{1,1},{1,2,1},{1,3,3,1},{1,4,6,4,1}},tr[572][5]={{0,0,0,0,0},{1,2,7,16,25},{1,3,17,32,38},{1,12,22,71,107},{4,8,19,64,87},{5,9,18,63,88},{6,11,46,69,95},{4,10,20,67,104},{4,27,39,75,117},{5,28,40,74,116},{4,30,41,76,122},{6,29,42,70,124},{12,21,71,107,144},{13,23,72,108,145},{14,24,73,110,146},{13,26,77,108,150},{13,26,78,108,150},{4,15,35,82,153},{6,29,47,157,159},{5,28,48,158,160},{5,31,54,139,254},{12,33,81,152,266},{13,34,82,153,267},{13,36,83,153,267},{14,37,84,154,268},{13,36,85,155,267},{13,79,101,156,265},{4,60,87,99,182},{5,61,88,98,181},{6,62,95,96,180},{13,65,94,111,189},{14,66,89,112,190},{13,65,93,133,194},{12,49,137,252,351},{13,52,138,253,352},{14,53,139,254,353},{13,56,142,255,352},{14,57,143,256,353},{13,56,148,261,352},{5,61,115,274,284},{6,62,123,276,283},{14,80,118,275,292},{44,68,236,235,233},{44,68,246,246,231},{44,45,243,238,246},{44,43,240,239,236},{44,43,244,245,237},{44,68,231,326,326},{6,62,179,313,330},{49,134,252,351,305},{50,135,253,352,306},{51,136,254,353,307},{50,137,253,352,306},{51,138,254,353,307},{55,139,258,354,308},{55,140,258,354,308},{56,141,255,352,306},{57,142,256,353,307},{58,143,257,354,308},{59,151,232,329,309},{60,86,99,182,311},{61,87,98,181,312},{62,88,96,180,313},{62,88,97,180,313},{61,87,100,181,312},{60,90,102,183,320},{61,91,103,184,321},{61,87,112,174,358},{68,95,246,231,326},{68,95,247,231,326},{68,95,236,234,346},{60,90,130,191,360},{61,91,131,192,361},{62,92,132,193,363},{62,88,126,220,366},{61,87,127,221,367},{61,91,128,222,368},{61,91,128,270,355},{61,91,129,271,356},{60,105,145,255,352},{61,106,146,256,353},{60,105,165,209,387},{61,106,166,210,388},{61,106,170,213,388},{62,109,171,214,395},{61,106,174,358,425},{60,113,273,285,399},{61,114,274,284,398},{62,115,276,283,396},{62,115,277,291,397},{60,119,279,286,393},{61,120,280,287,394},{62,121,281,288,392},{61,120,282,289,394},{61,114,278,290,400},{68,123,235,233,417},{68,123,248,251,430},{68,123,234,346,430},{62,115,218,227,384},{61,114,219,228,385},{62,115,220,366,436},{61,120,269,207,388},{61,120,223,229,382},{62,121,224,230,383},{61,120,272,325,428},{56,147,259,352,432},{57,148,260,353,433},{56,147,261,352,432},{57,148,262,353,433},{58,149,263,354,434},{58,149,264,354,434},{57,148,225,369,433},{58,149,226,370,434},{60,176,311,332,491},{61,177,312,331,490},{62,178,313,330,489},{62,178,313,333,489},{61,177,312,334,490},{62,178,324,337,494},{56,185,314,342,486},{57,186,315,343,487},{58,187,313,344,488},{57,186,316,343,487},{68,179,326,326,484},{68,179,326,328,484},{59,188,326,329,485},{68,179,328,346,484},{62,178,365,347,489},{62,178,354,308,488},{58,187,354,308,488},{61,120,201,299,482},{62,121,205,304,488},{68,125,249,309,485},{57,148,206,303,487},{49,161,208,386,462},{50,162,209,387,463},{51,163,210,388,464},{56,164,209,387,463},{57,165,210,388,464},{58,166,211,395,465},{55,167,211,395,465},{56,168,212,387,463},{57,169,213,388,464},{58,170,214,395,465},{56,168,215,381,463},{57,169,216,382,464},{58,170,217,383,465},{56,172,357,424,472},{57,173,358,425,473},{58,174,359,427,474},{57,173,364,435,473},{59,171,250,418,466},{56,185,322,442,498},{57,186,323,443,499},{58,187,324,444,500},{57,186,323,428,510},{57,186,362,447,499},{68,95,231,417,406},{62,88,180,374,403},{68,179,326,417,545},{62,178,313,419,547},{49,195,297,480,537},{50,196,298,481,537},{51,197,299,482,537},{56,199,298,481,537},{57,200,299,482,537},{58,201,300,483,537},{55,198,300,483,537},{56,202,302,486,537},{57,203,303,487,537},{58,204,304,488,537},{59,205,309,485,537},{176,348,306,486,537},{177,349,307,487,537},{178,350,308,488,537},{179,354,309,485,537},{176,310,332,491,515},{177,311,331,490,516},{178,312,330,489,517},{179,313,326,484,524},{179,313,328,484,524},{178,312,333,489,517},{177,311,334,490,516},{177,311,338,496,518},{178,312,339,497,519},{176,317,335,492,521},{177,318,336,493,522},{178,319,337,494,523},{179,324,327,484,525},{177,318,340,493,522},{178,319,341,494,523},{177,311,343,469,522},{178,312,344,470,523},{179,313,329,471,525},{177,318,345,469,522},{195,293,480,537,537},{196,294,481,537,537},{197,295,482,537,537},{198,296,483,537,537},{196,297,481,537,537},{197,298,482,537,537},{198,299,483,537,537},{202,301,486,537,537},{203,302,487,537,537},{204,303,488,537,537},{205,304,485,537,537},{204,303,500,537,537},{178,350,459,553,561},{176,348,453,468,561},{177,349,454,469,561},{178,350,455,470,561},{179,354,461,471,561},{177,349,458,473,561},{178,350,459,474,561},{179,354,460,475,561},{177,349,469,522,561},{178,350,470,523,561},{179,354,471,525,561},{68,179,484,524,524},{62,178,479,517,517},{179,313,484,524,524},{178,312,489,517,517},{178,312,489,523,523},{58,204,483,517,537},{59,205,485,524,537},{178,319,497,519,540},{179,324,484,524,544},{179,313,484,566,566},{178,312,489,565,565},{178,350,470,565,561},{179,354,471,566,561},{231,326,534,536,537},{231,327,534,536,537},{231,326,535,536,537},{231,326,536,537,537},{238,231,535,535,536},{238,231,534,534,536},{238,231,534,535,536},{238,246,531,533,534},{238,246,532,533,534},{242,238,532,532,533},{242,238,531,531,533},{242,243,528,530,531},{242,241,529,530,532},{242,238,533,534,534},{238,246,533,535,535},{238,236,532,533,535},{238,236,533,534,535},{238,231,536,537,537},{249,309,536,537,537},{231,329,535,536,561},{231,326,536,561,561},{176,317,437,495,539},{177,318,438,496,538},{178,319,439,497,540},{177,318,440,496,538},{178,319,441,497,540},{179,324,445,484,544},{179,324,446,484,544},{177,318,422,512,538},{178,319,423,513,540},{177,318,428,510,538},{178,319,429,511,540},{179,324,417,501,544},{179,324,418,502,544},{177,349,433,510,537},{56,202,378,509,537},{57,203,379,510,537},{58,204,380,511,537},{58,204,380,508,537},{178,312,426,474,523},{178,319,427,474,523},{178,319,421,503,523},{61,177,373,402,504},{62,178,374,403,503},{58,187,374,416,511},{68,179,417,406,501},{68,179,418,408,502},{62,178,392,411,508},{57,173,375,414,473},{58,174,376,415,474},{59,175,417,407,475},{58,174,395,411,474},{179,313,417,545,543},{178,312,419,547,541},{177,311,420,548,542},{177,318,422,548,538},{178,319,423,547,540},{179,324,417,545,544},{178,319,429,553,540},{178,312,426,553,540},{179,313,418,554,544},{178,350,434,550,537},{195,448,467,561,561},{196,449,468,561,561},{197,450,469,561,561},{198,451,470,561,561},{202,452,468,561,561},{203,453,469,561,561},{204,454,470,561,561},{205,455,471,561,561},{202,456,472,561,561},{203,457,473,561,561},{204,458,474,561,561},{205,459,475,561,561},{202,456,551,561,561},{203,457,552,561,561},{204,458,553,561,561},{205,459,554,561,561},{249,460,536,561,561},{176,371,401,505,563},{177,372,402,504,564},{178,373,403,503,565},{179,374,406,501,566},{177,372,404,512,564},{178,373,405,513,565},{178,373,416,511,565},{176,389,409,506,561},{177,390,410,507,561},{178,391,411,508,561},{177,390,410,510,561},{178,391,411,511,561},{177,390,412,510,561},{178,391,413,511,561},{179,392,408,502,561},{178,391,413,550,561},{231,417,535,536,561},{231,418,535,536,561},{231,417,536,537,561},{249,431,536,537,561},{179,374,555,545,566},{178,373,556,547,565},{177,372,557,548,564},{179,374,545,543,566},{178,373,547,541,565},{177,390,558,552,561},{178,391,559,553,561},{179,392,560,554,561},{178,391,550,541,561},{179,392,546,543,561},{178,391,553,540,561},{179,392,554,544,561},{203,378,549,537,561},{204,379,550,537,561},{205,380,546,537,561},{204,379,553,537,561},{231,417,536,561,561},{179,374,545,566,566},{202,377,506,537,561},{203,378,507,537,561},{204,379,508,537,561},{202,377,509,537,561},{203,378,510,537,561},{204,379,511,537,561},{205,380,502,537,561},{178,391,508,540,561},{178,391,511,540,561},{177,390,464,473,561},{178,391,465,474,561},{179,392,466,475,561},{177,390,507,522,561},{178,391,508,523,561},{178,391,511,519,561},{179,392,502,525,561},{178,391,474,523,561},{179,374,501,524,566},{179,374,501,566,566},{178,373,503,565,565},{178,391,508,565,561},{204,379,511,561,561},{205,380,502,561,561},{176,476,515,515,567},{177,477,516,516,567},{178,478,517,517,567},{179,479,524,524,567},{178,478,523,523,567},{179,479,525,525,567},{202,467,521,561,567},{203,468,522,561,567},{204,469,523,561,567},{205,470,525,561,567},{203,481,522,561,567},{204,482,523,561,567},{205,483,525,561,567},{179,479,524,566,567},{178,478,517,565,567},{202,480,521,537,567},{203,481,522,537,567},{204,482,523,537,567},{202,480,515,537,567},{203,481,516,537,567},{204,482,517,537,567},{205,483,524,537,567},{203,481,518,537,567},{204,482,519,537,567},{205,483,525,537,567},{179,479,524,543,567},{179,479,524,544,567},{178,478,517,541,567},{177,477,516,542,567},{178,478,517,540,567},{177,477,564,564,567},{178,478,565,565,567},{179,479,566,566,567},{178,478,561,561,567},{179,479,561,561,567},{231,484,561,561,567},{249,485,561,561,567},{249,471,561,561,567},{203,468,564,561,567},{204,469,565,561,567},{205,470,566,561,567},{204,469,561,561,567},{205,470,561,561,567},{204,482,565,561,567},{205,483,566,561,567},{205,483,561,561,567},{231,484,537,537,567},{249,485,537,537,567},{179,479,543,543,567},{178,478,541,541,567},{179,479,544,544,567},{178,478,537,537,567},{179,479,537,537,567},{203,481,538,537,567},{204,482,540,537,567},{205,483,543,537,567},{205,483,544,537,567},{204,482,537,537,567},{205,483,537,537,567},{231,484,537,561,567},{249,471,537,561,567},{203,468,538,561,567},{204,469,540,561,567},{205,470,544,561,567},{204,482,540,561,567},{179,479,543,566,567},{177,390,535,536,567},{178,391,535,536,567},{179,392,535,536,567},{178,391,536,537,567},{179,392,536,537,567},{203,378,536,537,567},{204,379,536,537,567},{205,380,536,537,567},{231,418,536,537,567},{231,418,535,536,567},{204,379,536,561,567},{195,526,536,567,567},{196,533,536,567,567},{197,533,536,567,567},{198,533,536,567,567},{202,535,536,567,567},{203,535,536,567,567},{204,535,536,567,567},{205,535,536,567,567},{202,536,537,567,567},{203,536,537,567,567},{204,536,537,567,567},{205,536,537,567,567},{249,536,537,567,567},{249,535,536,567,567},{202,536,561,567,567},{203,536,561,567,567},{204,536,561,567,567},{205,536,561,567,567},{249,536,561,567,567},{476,537,537,567,567},{477,537,537,567,567},{478,537,537,567,567},{479,537,537,567,567},{484,537,537,567,567},{477,537,561,567,567},{478,537,561,567,567},{479,537,561,567,567},{484,537,561,567,567},{476,514,515,567,567},{477,515,516,567,567},{478,516,517,567,567},{479,517,524,567,567},{476,520,521,567,567},{477,521,522,567,567},{478,522,523,567,567},{479,523,525,567,567},{484,524,537,567,567},{484,525,537,567,567},{477,521,538,567,567},{478,522,540,567,567},{479,523,544,567,567},{479,517,543,567,567},{478,516,541,567,567},{477,515,542,567,567},{477,515,538,567,567},{478,516,540,567,567},{479,517,544,567,567},{477,515,537,567,567},{478,516,537,567,567},{479,517,537,567,567},{477,521,537,567,567},{478,522,537,567,567},{479,523,537,567,567},{484,524,561,567,567},{484,525,561,567,567},{479,517,566,567,567},{478,516,565,567,567},{477,515,564,567,567},{477,521,564,567,567},{478,522,565,567,567},{479,523,566,567,567},{477,521,561,567,567},{478,522,561,567,567},{479,523,561,567,567},{478,516,561,567,567},{479,517,561,567,567},{476,562,563,567,567},{477,563,564,567,567},{478,564,565,567,567},{479,565,566,567,567},{478,564,561,567,567},{479,565,561,567,567},{476,561,561,567,567},{477,561,561,567,567},{478,561,561,567,567},{479,561,561,567,567},{484,566,561,567,567},{484,561,561,567,567},{526,526,567,567,567},{527,528,567,567,567},{527,529,567,567,567},{527,530,567,567,567},{530,531,567,567,567},{530,532,567,567,567},{530,533,567,567,567},{533,534,567,567,567},{533,535,567,567,567},{533,536,567,567,567},{536,537,567,567,567},{536,561,567,567,567},{478,561,567,567,567},{477,561,567,567,567},{479,561,567,567,567},{479,565,567,567,567},{478,564,567,567,567},{484,566,567,567,567},{484,561,567,567,567},{484,524,567,567,567},{484,525,567,567,567},{479,517,567,567,567},{478,516,567,567,567},{478,522,567,567,567},{479,523,567,567,567},{477,537,567,567,567},{478,537,567,567,567},{479,537,567,567,567},{484,537,567,567,567},{231,484,567,567,567},{179,479,567,567,567},{178,478,567,567,567},{204,536,567,567,567},{205,536,567,567,567},{249,536,567,567,567},{536,567,567,567,567},{476,567,567,567,567},{477,567,567,567,567},{478,567,567,567,567},{479,567,567,567,567},{484,567,567,567,567},{567,567,567,567,567}};
int n,a[105],fac[405],vac[405],f[2][405][572],sum[405],ans;
int main(){
  f[0][0][1]=fac[0]=vac[0]=vac[1]=1,cin>>n;
  for(int i=2;i<=4*n-13;i++)vac[i]=1ll*vac[mod%i]*(mod-mod/i)%mod;
  for(int i=1;i<=4*n-13;i++)fac[i]=1ll*fac[i-1]*i%mod,vac[i]=1ll*vac[i]*vac[i-1]%mod;
  for(int i=1,w,t;i<=13;i++)cin>>w>>t,a[w]++;
  for(int i=0;i<n;i++){
    memset(f[~i&1],0,sizeof(f[~i&1]));
    for(int j=0;j<=4*i;j++){
      for(int k=1;k<=567;k++){
        if(!f[i&1][j][k])continue;
        for(int l=a[i+1];l<=4;l++)f[~i&1][j+l][tr[k][l]]=(f[~i&1][j+l][tr[k][l]]+1ll*f[i&1][j][k]*C[4-a[i+1]][l-a[i+1]])%mod;
      }
    }
  }
  for(int i=1;i<=4*n-13;i++)for(int j=1;j<=566;j++)sum[i]=(sum[i]+f[n&1][i+13][j])%mod;
  for(int i=1;i<=4*n-13;i++)ans=(ans+1ll*sum[i]*fac[i]%mod*fac[4*n-13-i]%mod*vac[4*n-13])%mod;
  return cout<<(ans+1)%mod<<'\n',0;
}
```

---

## 作者：dengchengyu (赞：1)

### [P5279 [ZJOI2019] 麻将](https://www.luogu.com.cn/problem/P5279)

DP 套 DP 练习题。

首先我们先建一个能不能判定当前局面是否能胡的自动机，然后在自动机上 DP 即可。在此之前可以先写出判定的 DP 式子然后建自动机。

首先我们只需考虑每种牌的个数。我们先来判定五个面子的情况，设 $f_{i,j,k,0/1}$ 表示考虑完前 $i$ 种牌后，当前预留了 $j$ 对 $(i-1,i)$，$k$ 个 $i$，有没有预留对子，值为当前最大的面子数。

注意到到 $j\ge 3$ 时，可以把三张 $i-1$ 和三张 $j-1$ 分别组成两个面子，$k\ge 3$ 时可以直接组成面子，所以 $j,k<3$。

于是自动机上的每个点需要记录两个 $3\times 3$ 的矩阵 $f_0,f_1$。另外我们不需要记录 $i$，因为自动机上并不关心考虑到哪种牌。

另外对于七个对子的情况，只需再在自动机上的每个点记录当前遇到的对子数 $k$。

那么一个节点胡了当且仅当存在一个 $f_1$ 中的值大于等于 $4$，或者 $k$ 大于等于 $7$。

实现可以使用 `map` 里面套两个 $3\times 3$ 的 `vector` 和一个 `int`。注意初始化时只有 $f_{0,0,0},k=0$，其他设为 $-1$。把所有胡的节点当做 $0$ 号即可。

转移时枚举新增 $x$ 张牌。有几种如下转移：

> 1. $f_0$ 新增 $x$ 张牌，转移到 $f_0'$。
> 2. $f_1$ 新增 $x$ 张牌，转移到 $f_1'$。
> 3. $f_0$ 新增 $(x-2)$ 张牌，转移到 $f_1'$。
> 4. 当 $x\ge 2$ 时 $k\gets\ k+1$。

转移时再枚举与 $(i-2,i-1)$ 配成面子的张数、与 $i-1$ 配成 $(i-1,i)$ 的张数、留下 $i$ 的张数，剩余的拼成尽可能多的面子。

注意 $f_0$ 和 $f_1$ 中的值要对 $4$ 取 $\min$ 才能保证点数，且 $-1$ 不能参与转移。

发现算上初始点和胡节点只有 $2092$ 个点。直接 DP 即可。

我们不要枚举排列，而枚举每种牌选的个数，通过阶乘算出排列的贡献，具体来说设 $f_{i,j,k}$ 表示考虑完第 $i$ 种牌后，选了 $j$ 个额外的牌，走到了自动机的 $k$ 号节点的方案数。

那么设初始有 $a_i$ 张 $i$ 号牌，则转移枚举 $0\le p\le 4-a_i$，有
$$
f_{i-1,j,k}\times \binom {4-a_i} p\to f_{i,j+p,to(k,a_i+p)}
$$
最后设 $g_i$ 为额外选了 $i$ 张牌后还没有胡的方案数。答案为
$$
1+\frac {\sum _{i=1}g_ii!(4n-13-i)!} {(4n-13)!}
$$
 可以理解为前者是第一张牌，后者是选了 $i$ 张牌后再选一张的概率。

时间复杂度为 $2092\times 4\times n^2$。

代码：

```cpp
const int mod=998244353,N=2100;
int tot=0;
int g[N][5];
#define mat vector<vi>
#define state pair<pair<mat,mat>,int>
#define a0 fi.fi
#define a1 fi.se
map<state,int> Map;
state sta[N];
void getmax(int &x,int y) {
	if(y>4) y=4;
	if(y>x) x=y;
}
void trans(mat x,mat &y,int z) {
	fo(i,0,2) fo(j,0,2) if(x[i][j]>=0) 
		fo(k,0,min(i,z)) 
			fo(l,0,min(j,z-k)) fo(p,0,z-k-l) 
				getmax(y[min(2,l)][min(2,p)],x[i][j]+k+(z-k-l-p)/3);
}
void make() {
	++tot;
	sta[1].a0=sta[1].a1=vector<vi>(3,vi(3,-1));
	sta[1].a0[0][0]=0;
	Map[sta[1]]=1;
	fo(i,1,tot) {
		state x=sta[i];
		fo(j,0,4) {
			state nw;
			nw.a0=nw.a1=vector<vi>(3,vi(3,-1));
			nw.se=x.se;
			trans(x.a0,nw.a0,j), trans(x.a1,nw.a1,j);
			if(j>1) trans(x.a0,nw.a1,j-2), ++nw.se;
			int flag=0;
			fo(k,0,2) fo(l,0,2) flag|=nw.a1[k][l]>=4;
			if(flag||nw.se>=7) g[i][j]=0;
			else if(Map.find(nw)!=Map.end()) g[i][j]=Map[nw];
			else g[i][j]=Map[nw]=++tot,sta[tot]=nw;
		}
	}
}
int pow1(int x,int y) {
	int res=1;
	for(;y;y>>=1,x=(ll)x*x%mod) if(y&1) res=(ll)res*x%mod;
	return res;
}
int fact[N];
int C(int x,int y) {
	if(x<y) return 0;
	return (ll)fact[x]*pow1((ll)fact[y]*fact[x-y]%mod,mod-2)%mod;
}
int n,res[N];
int f[2][405][N],h[405];
void add(int &x,int y) {
	x+=y;
	if(x>=mod) x-=mod;
}
int c[5][5];
signed main(){
	make();
	fact[0]=1;
	fu(i,1,N) fact[i]=fact[i-1]*(ll)i%mod;
	fo(i,0,4) fo(j,0,4) c[i][j]=C(i,j);
	read(n);
	fo(i,1,13) {
		int x,w; read(x),read(w);
		res[x]++;
	}
	f[0][0][1]=1;
	fo(i,1,n) {
		fo(j,0,4*(i-1)) {
			fo(k,1,tot){
				if(!f[i&1^1][j][k]) continue;
				fo(l,0,4-res[i]) {
					add(f[i&1][j+l][g[k][l+res[i]]],(ll)f[i&1^1][j][k]*c[4-res[i]][l]%mod);
				}
				f[i&1^1][j][k]=0;
			}
		}
	}
	int ans=0;
	fo(j,1,4*n) fo(k,1,tot) add(h[j],f[n&1][j][k]);
	fo(j,1,4*n) add(ans,(ll)h[j]*fact[j]%mod*fact[4*n-13-j]%mod);
	ans=(ll)ans*pow1(fact[4*n-13],mod-2)%mod;
	add(ans,1);
	write(ans);
	return 0;
}
```

---

## 作者：sqrtqwq (赞：1)

小 S 认为自己已经掌握了 dp 套 dp 了，所以她决定来做 ZJOI 的神仙题目。

同样的，考虑内层 dp。小 S 先考虑普通情况，也就是 $4$ 个面子加上 $1$ 个对子，而对于 $7$ 个对子的情况，特判一下就行了。

小 S 定义 $dp_{i,j,k}$ 为，现在还有没有对子，并且有 $j$ 组形为 ${a-1,a}$ 的牌，以及 $k$ 组形如 ${a}$ 的牌，此时所能产生的面子的最大值。

然后小 S 把 $j,k,0/1$ 的两个 $3 \times 3$ 的矩阵看成一个状态，把得到一张新的牌然后转移到另一个状态看成边，那么就可以建出 dp 自动机。虽然状态看似非常多，但实际上只有 $2092$ 个，可以放心建。

然后再来考虑设计外层 dp。

回归到原本问题，其实就等于求 $\dfrac{\sum^{4n-13}_{i = 1} f(i) \times i! \times (4n - 13 - i)!}{(4n - 13)!}$。其中 $f(i)$ 的定义为摸了 $i$ 次牌还没胡的种类数。

为了求解 $f(i)$，小 S 定义 $g_{i,j,k}$ 为目前考虑完了前 $i$ 种牌，目前共有 $j$ 种牌，在自动机上的节点为 $k$。那么 $g$ 的递推式就显而易见了：

$$g_{i,j,k} \times \dbinom {4-s_i}{t-s_i} \to g_{i+1,j+t,nxt_{k,t}}$$

那么 $f(i) = \sum^{2092}_{j=1} g_{13,i+13,j}$，然后求出答案了。时间复杂度 $O(n^2 \times 2092)$，可以通过小 S 很开心。

---

## 作者：TernaryTree (赞：1)

考虑如何判定一副牌是不是和的。这个大概是 CF1110D。$f_{i,j,k,0/1}$ 表示考虑到第 $i$ 种牌，预留了 $j$ 个 $(i-1,i,i+1)$ 的顺子和 $k$ 个 $(i,i+1,i+2)$ 的顺子在后面统计，有/无雀头，此时的最大面子数。注意到 $j\ge 3$ 或 $k\ge 3$ 都可以用刻子代替，所以 $0\le j,k\le 2$。注意到若 $f$ 的值大于 $4$ 没有用，因为一定和了，所以 $f$ 转移时对 $4$ 取 $\min$。

目标是构建自动机。我们把 $j,k,0/1$ 两个 $3\times 3$ 的矩阵看做自动机的“状态”，每个“状态”添加新一种牌的 $c$ 张牌后得到另一个“状态”，看做转移边。并且，所有和牌的状态都可以合并成一个状态“和”。这里状态看似很多，实际上只有 $2092$ 个，使用 bfs 容易找出所有状态。

接下来只需要 dp 部分了。令 $g_{i,j,u}$ 表示前 $i$ 种牌，一共摸到 $j$ 张，走到自动机上结点 $u$ 的方案数。转移有：

$$g_{i,j,u}\times\dbinom{4-a_{i+1}}k\to g_{i+1,j+k,trans_{u,k+a_{i+1}}}\ (0\le k\le 4-a_{i+1})$$

其中 $a_i$ 表示起手牌中每种牌的数量。

考虑期望式子 $E(x)=\sum iP(x=i)$，这等价于 $\sum P(x\ge i)$，也就是 $i-1$ 巡仍未胡牌的概率之和。这个概率为

$$h_i=\dfrac{i!(4n-13-i)!\sum\limits_{u\neq tar}f_{n,i,u}}{(4n-13)!}$$

$tar$ 表示和牌在自动机上状态编号。

答案即为 $1+\sum h_i$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define fs first
#define sc second
#define ls (u << 1)
#define rs (u << 1 | 1)
#define mid ((l + r) >> 1)
#define lc ls, l, mid
#define rc rs, mid + 1, r
#define rep(i, l, r) for (int i = (l); i <= (r); ++i)
#define per(i, r, l) for (int i = (r); i >= (l); --i)
#define gc getchar
#define pc putchar

using namespace std;
using pii = pair<int, int>;
using vi = vector<int>;

const int maxn = 2e3 + 100;
const int maxm = 1e2 + 10; 
const int mod = 998244353;
const bool multidata = 0;

int read() {
	int x = 0, f = 1; char c = gc();
	while (c < '0' || c > '9') { if (c == '-') f = -f; c = gc(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = gc();
	return x * f;
}

void write(int x) {
	if (x < 0) pc('-'), x = -x;
	if (x < 10) return void (pc(x + '0'));
	write(x / 10), pc(x % 10 + '0');
}

struct matrix {
	int a[3][3] = {};
	matrix() { memset(a, -1, sizeof(a)); }
	int * operator[] (int i) { return a[i]; }
	bool operator!= (matrix b) const {
		rep(i, 0, 2) rep(j, 0, 2) if (a[i][j] != b[i][j]) return 1;
		return 0;
	}
	bool operator< (matrix b) const {
		rep(i, 0, 2) rep(j, 0, 2) if (a[i][j] != b[i][j]) return a[i][j] < b[i][j];
		return 0;
	}
	void trans(matrix &b, int cnt) {
		rep(i, 0, 2) {
			rep(j, 0, 2) {
				if (a[i][j] == -1) continue;
				rep(k, 0, 2) {
					if (i + j + k > cnt) continue;
					b[j][k] = max(b[j][k], min(a[i][j] + i + (cnt - i - j - k) / 3, 4ll));
				}
			}
		}
	}
	bool check() { return a[0][0] >= 4; }
};

struct sta {
	matrix f[2] = {}; int g = 0, h = 0;
	sta() = default;
	void init() { f[0] = matrix(), f[1] = matrix(), g = h = 0; }
	void update() { if (f[1].check() || g >= 7) h = 1; }
	bool operator< (sta b) const {
		if (h && b.h) return 0;
		if (h != b.h) return h < b.h;
		if (f[0] != b.f[0]) return f[0] < b.f[0];
		if (f[1] != b.f[1]) return f[1] < b.f[1];
		if (g != b.g) return g < b.g;
		return 0;
	}
	sta trans(int cnt) {
		if (h) return *this;
		sta b; b.init();
		if (cnt >= 2) f[0].trans(b.f[1], cnt - 2);
		f[0].trans(b.f[0], cnt);
		f[1].trans(b.f[1], cnt);
		b.g = g + (cnt >= 2);
		b.update();
		return b;
	}
};

map<sta, int> id;
int tot, tar;
int tr[maxn][5];

void bfs() {
	queue<sta> q;
	sta s; s.init(); s.f[0][0][0] = 0;
	id[s] = ++tot;
	q.push(s);
	while (!q.empty()) {
		sta u = q.front(); q.pop();
		rep(i, 0, 4) {
			sta v = u.trans(i);
			if (id.count(v)) {
				tr[id[u]][i] = id[v];
			} else {
				tr[id[u]][i] = id[v] = ++tot;
				if (v.h) tar = id[v];
				q.push(v);
			}
		}
	}
}

int n, ans;
int cnt[maxn];
int f[maxm][maxm * 4][maxn];
int g[maxm * 4];

int power(int a, int b, int p = mod) {
	int t = 1; a %= p;
	while (b) {
		if (b & 1) t = t * a % p;
		a = a * a % p, b >>= 1;
	}
	return t;
}

int fac[maxn], ifac[maxn], inv[maxn];

void init() {
	fac[0] = 1; rep(i, 1, maxn - 1) fac[i] = fac[i - 1] * i % mod;
	ifac[maxn - 1] = power(fac[maxn - 1], mod - 2); per(i, maxn - 2, 0) ifac[i] = ifac[i + 1] * (i + 1) % mod;
	rep(i, 1, maxn - 1) inv[i] = fac[i - 1] * ifac[i] % mod;
}

int C(int n, int m) {
	if (n < 0 || n < m || m < 0) return 0;
	return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

void fake_main() {
	n = read();
	rep(i, 1, 13) {
		int x = read(), y = read();
		++cnt[x];
	}
	bfs();
	init();
	f[0][0][1] = 1;
	rep(i, 0, n - 1) rep(j, 0, i * 4) rep(u, 1, tot) rep(k, 0, 4 - cnt[i + 1]) (f[i + 1][j + k][tr[u][cnt[i + 1] + k]] += f[i][j][u] * C(4 - cnt[i + 1], k) % mod) %= mod;
	rep(i, 0, n * 4 - 13) rep(u, 1, tot) if (u != tar) (g[i] += f[n][i][u]) %= mod;
	rep(i, 0, n * 4 - 13) (ans += g[i] * fac[i] % mod * fac[n * 4 - 13 - i] % mod * ifac[n * 4 - 13] % mod) %= mod;
	write(ans), pc('\n');
}

signed main() {
	int T = multidata ? read() : 1;
	while (T--) fake_main();
	return 0;
}
```

---

## 作者：james1BadCreeper (赞：1)


可以发现其两部分是割裂的：**判断胡牌**和**计数 DP**。由于胡牌集合的大小只有 $13$，因此如果我们能解决判定问题，那么便可以建立自动机在上面解决计数问题。

先解决判定问题。七个对子只需要开一个桶即可，一个对子四个面子可以考虑使用 DP 来解决：设 $f_{i,j,k,0/1}$ 代表考虑前 $i$ 种牌，目前还剩下 $j$ 组 $(i-1,i)$ 和 $k$ 张 $i$，以及是否选择出了一组对子，这种时候的最大面子数。由于 $j\ge 3$ 或者 $k\ge 3$ 时都可以直接组成新的面子，因此状态中 $j,k\in [0,2]$。因此在一个状态中建立两个 $3\times 3$ 的二维数组即可。转移时将 $x$ 张 $i$ 牌添加进来即可。

牌种类数足够多时状态就被列举完了，因此直接暴力 DFS 拓展出所有状态即可，按照笔者的实现，其状态只有 $S=3956$ 种，而接下来的分析让我们知到我们只需要不胡的状态，其只有 $S=2091$ 种。

接下来我们要解决计数问题。我们需要知到第一个胡牌的位置，这并不好直接计算。设 $P(i)$ 代表**恰好** $i$ 步胡牌的概率，那么：

$$
\begin {aligned} E(x)&=\sum_{i=0}^{+\infty} i\times P(i)\\
&=\sum_{i=0}^{+\infty}\sum_{j=i}^{+\infty}P(j)
\end{aligned}
$$

可以发现第二个和式的意思是 $i-1$ 步没胡的概率，设 $f_{i,j,k}$ 代表选择前 $i$ 种牌，一共 $j$ 张，位于自动机上的状态 $k$，转移时选择 $t$ 张 $i$ 牌，系数是 $\dbinom {4-a_i}{t}$，令 $m=4n-13$，$f_i$ 为 $i$ 张牌没胡的方案数，则答案为：

$$
ans=\frac{\sum_{i=0}^m f_i i!(m-i)!}{m!}
$$

```cpp
#include <bits/stdc++.h>
using namespace std; 
const int P = 998244353; 

inline void add(int &x, int k) { x += k; x -= x >= P ? P : 0; }
inline int poww(int a, int b) {
    int r = 1; 
    for (; b; b >>= 1, a = 1ll * a * a % P) if (b & 1) r = 1ll * r * a % P; 
    return r; 
}

int fac[405], ifac[405]; 
inline int C(int n, int m) { 
    if (n < m || m < 0 || n < 0) return 0; 
    return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; 
}

struct dpNode {
    int f[3][3]; 
    dpNode() { memset(f, -1, sizeof f); }
    bool operator!= (const dpNode &a) const { for (int i = 0; i < 3; ++i) for (int j = 0; j < 3; ++j) if (f[i][j] != a.f[i][j]) return 1; return 0; }
    bool operator== (const dpNode &a) const { return !(*this != a); }
    bool operator< (const dpNode &a) const { for (int i = 0; i < 3; ++i) for (int j = 0; j < 3; ++j) if (f[i][j] != a.f[i][j]) return f[i][j] < a.f[i][j]; return 0; }
    bool check(void) { for (int i = 0; i < 3; ++i) for (int j = 0; j < 3; ++j) if (f[i][j] > 3) return 1; return 0; }
    friend void ckmax(dpNode &a, dpNode b) {
        for (int i = 0; i < 3; ++i) for (int j = 0; j < 3; ++j) a.f[i][j] = max(a.f[i][j], b.f[i][j]); 
    }
    friend dpNode trans(dpNode a, int x) {
        dpNode c; 
        for (int i = 0; i < 3; ++i) for (int j = 0; j < 3; ++j) if (a.f[i][j] != -1) 
            for (int k = 0; k < 3 && i + j + k <= x; ++k) // 组成 i 对面子，预留 j + k 个当前牌
                c.f[j][k] = max(c.f[j][k], min(4, a.f[i][j] + i + (x - i - j - k >= 3))); 
        return c; 
    }
}; 
struct Status {
    int cnt; pair<dpNode, dpNode> v; 
    Status() { v.first.f[0][0] = cnt = 0; }
    bool operator< (const Status &a) const { return cnt != a.cnt ? cnt < a.cnt : v < a.v; }
    friend Status trans(Status a, int b) {
        a.cnt = min(7, a.cnt + (b >= 2)); 
        a.v.second = trans(a.v.second, b); 
        if (b >= 2) ckmax(a.v.second, trans(a.v.first, b - 2)); 
        a.v.first = trans(a.v.first, b); 
        return a; 
    }
    bool able(void) {
        if (cnt == 7) return 1; 
        for (int i = 0; i < 3; ++i) for (int j = 0; j < 3; ++j) if (v.second.f[i][j] > 3) return 1; 
        return 0; 
    }
}; 
vector<Status> mahjong; 
int n, a[405], tra[4005][5], f[105][405][4005];
map<Status, int> mp; 

void dfs(Status x) {
    if (mp.find(x) != mp.end() || x.able()) return; 
    mahjong.push_back(x); mp[x] = mahjong.size() - 1; 
    for (int i = 0; i <= 4; ++i) dfs(trans(x, i)); 
}

int main(void) {
    for (int i = fac[0] = 1; i <= 400; ++i) fac[i] = 1ll * fac[i - 1] * i % P; 
    ifac[400] = poww(fac[400], P - 2); 
    for (int i = 399; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; 

    mahjong.push_back(Status()); 
    dfs(Status()); // memset(tra, -1, sizeof tra); 
    for (int i = 0; i < mahjong.size(); ++i) for (int j = 0; j <= 4; ++j) tra[i][j] = mp[trans(mahjong[i], j)]; 
    // cout << mahjong.size() << "\n"; 

    ios::sync_with_stdio(0); 
    cin >> n; 
    for (int i = 1, x, y; i <= 13; ++i) cin >> x >> y, ++a[x]; 

    f[0][0][0] = 1; 
    for (int i = 0, c = 0; i < n; c += a[++i])
        for (int j = c; j <= n * 4; ++j)
            for (int k = 0; k < mahjong.size(); ++k) if (f[i][j][k])
                for (int t = a[i + 1]; t <= 4; ++t) if (tra[k][t]) add(f[i + 1][j + t][tra[k][t]], 1ll * f[i][j][k] * C(4 - a[i + 1], t - a[i + 1]) % P); 

    int ans = 0, m = n * 4 - 13; 
    for (int i = 0; i <= m; ++i) {
        int s = 0; 
        for (int j = 0; j < mahjong.size(); ++j) add(s, f[n][i + 13][j]); 
        add(ans, 1ll * s * fac[i] % P * fac[m - i] % P); 
    }
    cout << 1ll * ans * ifac[m] % P << "\n"; 
    return 0; 
}
```

---

## 作者：foreverlasting (赞：1)

[强力推广博客](https://foreverlasting1202.github.io/)

动态规划。

终于补完ZJOI2019 Day1了，有点辛苦。

首先这道题我只会$20$分，后来听说胡的集合很小？可以先预处理出所有胡的集合？然后我暴搜了一发，发现$3956$种。所以这道题就能做完了？？

如果我们知道所有胡的集合，那么设计$dp[i][j][S]$表示当前处理到了$i$，共选定了$j$张牌，胡牌状态为$S$的方案数。这个转移只用枚举第$i+1$张牌，记录第$i+1$张牌有几张，组合数转移一下就可以了。

然后枚举抽了$i$张牌，假设这时候不胡的方案数是$A$，总方案数是$B$，那么这是$\frac {A}{B}$就是大于$i$张的概率。答案就是$\sum \frac {A}{B}$。

主要是如何去暴搜所有状态。

如何判胡呢？我们发现先去找到最多的刻子，在找刻子的时候记个状态顺带找雀头就可以了。这好像是某场$codeforces$的一道题，具体哪道题我也记不清了。这个可以$DP$出来。于是就可以暴搜状态，每次$DP$合并一下就好了，用$map$记录一下$DP$值与合并的值。（事实上这里暴搜状态我是沿途听说，我完全不会）

code:
```cpp
//2019.4.4 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-5
#define RG register
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void swap(res &x,res &y){
    x^=y^=x^=y;
}
const int kcz=998244353;
const int N=1e2+10;
const int M=3956+10;
namespace MAIN{
    int used[N];
    int n;
    inline void add(res &x,const res &y){
        x+=y,x>=kcz?x-=kcz:(x<0?x+=kcz:1);
    }
    inline int Add(const res &x,const res &y){
        return x+y>=kcz?x+y-kcz:(x+y<0?x+y+kcz:x+y);
    }
    inline int mul(const res &x,const res &y){
        return int(1LL*x*y%kcz);
    }
    inline int qpow(res x,res y){
        res ret=1;
        while(y){
            if(y&1)ret=mul(ret,x);
            x=mul(x,x),y>>=1;
        }
        return ret;
    }
    struct P{
        int f[3][3];
        P() {memset(f,-1,sizeof(f));}
        inline bool operator < (const P &b) const {
            for(res i=0;i<=2;i++)
                for(res j=0;j<=2;j++){
                    if(f[i][j]<b.f[i][j])return 1;
                    if(f[i][j]>b.f[i][j])return 0;
                }
            return 0;
        }
    };
    int px;
    map<P,int> idP;
    inline P operator + (const P &a,const P &b){
        P ret;
        for(res i=0;i<=2;i++)
            for(res j=0;j<=2;j++)
                ret.f[i][j]=max(a.f[i][j],b.f[i][j]);
        return ret;
    }
    inline P operator + (const P &a,const res &num){
        P ret;
        for(res i=0;i<=2&&i<=num;i++)
            for(res j=0;j<=2&&i+j<=num;j++){
                if(a.f[i][j]==-1)continue;
                res tmp=a.f[i][j];
                for(res k=0;k<=2&&i+j+k<=num;k++)
                    ret.f[j][k]=max(ret.f[j][k],min(tmp+i+(num-i-j-k)/3,4));
            }
        return ret;
    }
    void dfs(P x){
        if(idP.count(x))return;
        idP[x]=++px;
        for(res i=0;i<=4;i++)
            dfs(x+i);
    }
    typedef pair<P,P> Pair;
#define mp make_pair
#define fi first
#define se second
    typedef pair<Pair,int> Ma;
    Ma id[M];
    int mx;
    map<Ma,int> idM;
    inline Pair operator + (const Pair &x,const res &num){
        return num>=2?mp(x.fi+num,(x.se+num)+(x.fi+(num-2))):mp(x.fi+num,x.se+num);
    }
    inline Ma operator + (const Ma &x,const res &num){
        return Ma(x.fi+num,min(x.se+(num>=2),7));
    }
    void dfs(Ma x){
        if(idM.count(x))return;
        idM[x]=++mx,id[mx]=x;
        for(res i=0;i<=4;i++)
            dfs(x+i);
    }
    inline bool check(const Ma &x){
        if(x.se>=7)return 1;
        for(res i=0;i<=2;i++)
            for(res j=0;j<=2;j++)
                if(x.fi.se.f[i][j]>=4)return 1;
        return 0;
    }
    bool fl[M];
    int trans[M][5];
    inline void pre(){
        RG P k,K;
        k.f[0][0]=0;
        RG Ma ko=mp(mp(k,K),0);
        dfs(k),dfs(ko);
        for(res i=1;i<=mx;i++){
            fl[i]=check(id[i]);
            for(res j=0;j<=4;j++)
                trans[i][j]=idM[id[i]+j];
        }
    }
    int C[5][5];
    int dp[N][N<<2][M];
    inline void MAIN(){
        C[0][0]=1;
        for(res i=1;i<=4;i++){
            C[i][0]=1;
            for(res j=1;j<=i;j++)
                C[i][j]=C[i-1][j]+C[i-1][j-1];
        }
        n=read(),pre();
        for(res i=1;i<=13;i++){
            res w=read();
            read(),used[w]++;
        }
        dp[0][0][1]=1;
        for(res i=1;i<=n;i++)
            for(res j=0;j<=4*i;j++)
                for(res k=1;k<=mx;k++){
                    if(!dp[i-1][j][k])continue;
                    res tmp=dp[i-1][j][k];
                    for(res t=used[i];t<=4;t++)
                        add(dp[i][j+t][trans[k][t]],mul(tmp,C[4-used[i]][t-used[i]]));
                }
        res ans=0;
        for(res i=13;i<=4*n;i++){
            res sum=0,INV=0;
            for(res j=1;j<=mx;j++){
                add(INV,dp[n][i][j]);
                if(!fl[j])add(sum,dp[n][i][j]);
            }
            add(ans,mul(sum,qpow(INV,kcz-2)));
        }
        printf("%d\n",ans);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：Richard_Whr (赞：1)

先思考如何在给定集合的情况下，判断能不能胡。

首先发现胡不胡和集合内部顺序没关系，其次胡的条件都是在值域上连续的，因此考虑在值域上做这个事。

形象化一点来说就是有一个 $n$ 位的字符串，每一位都是 $[0,4]$ 的数。

考虑更好的刻画胡的条件：

对于第二个条件比较好刻画，只需要记录雀头的数量即可，一个变量即可搞定。

对于第一个条件，发现对于面子的要求比较严格，而对于雀头只要一个，把有没有雀头记录到状态里，然后最大化面子的数量（经典可行性转最优化），专门为此设计一个 dp。

$f_{i,0/1,j,k}$ 表示填了字符串前 $i$ 个位，有没有雀头，剩下的 $(i-1,i)$ 的对数为 $j$，剩下的 $i$ 的数量为 $k$。

转移枚举当前位的数 $x$，上一步剩下的 $(i-2,i-1)$ 的对接上 $i$ 构成面子；上一步剩下的 $i-1$ 的对接上 $i$ 预留到下一步的 $(i-1,i)$ 对数，最后枚举一下要剩下 $k$ 个 $i$，剩下的 $x-i-j-k$ 个能凑成几个刻子凑成几个刻子。

相同的 $0/1$ 状态可以直接转移，如果想从 $0 \rightarrow 1$ 需要提前去掉一个雀头再转移。

可能会有余数，但是最优决策一定不会有余数因此是正确的。

我们的目标是计数，计数一般记录排列长什么样，而同时我们需要知道张这样的排列能不能胡。

因此想到了建立 "胡牌状态自动机" 辅助我们进行计数。

假设我们已经建立好了，他的功能是：

- 给他当前这一位填的数，自动帮你转移到下一个状态，且一旦到达胡牌状态，一直保持胡牌状态。

- 判断当前状态能不能胡牌。

- 总的状态数量可以接受。

类似 AC 自动机，我们设 $F_{i,j,k}$ 表示填了前 $i$ 个位置，总共用了 $j$ 个牌，当前在自动机上的状态为 $k$。

答案的表达应该是：

设 $P(i)$ 为在第 $i$ 次摸牌后胡了的概率：

$$Ans= \sum\limits_{i=1}^{4\times n-13}P(i)\times i$$

根据我们的状态设计，令 $g(i)=\frac{F_{n,i,Win}\times i!(m-i)!}{m!}，m= 4\times n -13$，表示在前 $i$ 步中胡牌的概率，则 $P(i)=g(i)-g(i-1)$，原因是某次胡牌之后无论摸到什么仍是胡牌，因此算的是前缀和，单点值需要差分。

带入 $Ans$ 中即可。

这个 $F$ 也比较好转移，枚举当前位选的数字 $x$，记录第 $i$ 位初始选了 $w_i$ 个。

$$F_{i-1,j,k}\times \binom{4-w_i}{x} \rightarrow F_{i,j+x,To[k][x]}$$。

这个 $To$ 就是自动机里的转移边，由于相同牌也算不同的，因此需要乘上一个组合数。

现在如果成功构建了自动机，那就结束了。

思考自动机里每个状态需要维护什么信息才能满足之前提的几个要求。

首先为了特判第二种胡牌，需要记录 $cnt$ 表示雀头的数量，为了完成判断第一种胡牌的 dp ，我们需要存下 dp 值。

那就存呗，直接开个结构体存，和 AC 自动机一样，用 BFS 实现构建。

注意我们为了压缩节点数量，可以把胡牌状态变成一个虚点，这个点无论走什么转移边都会回到自己。

初始状态只有一个，然后每次枚举所有转移边，如果新状态已经存在，那无需继续计算，否则入队继续计算。

输出一下总状态数：$2092$ 并不大！


```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=3e3+10,K=4*110,M=K,mod=998244353;
int n,m,w[N];
int fac[M],ifac[M];
struct Dp
{
	int f[3][3];
	inline void clear(){memset(f,-1,sizeof f);}
	inline bool operator<(const Dp &B)const
	{
		for(int i=0;i<3;i++)
			for(int j=0;j<3;j++)
				if(f[i][j]!=B.f[i][j]) return f[i][j]<B.f[i][j];
		return false;
	}
	inline bool operator!=(const Dp &B)const
	{
		for(int i=0;i<3;i++)
			for(int j=0;j<3;j++)
				if(f[i][j]!=B.f[i][j]) return true;
		return false;
	}
	inline Dp Trans(int c)
	{
		Dp B;B.clear();
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
			{
				if(f[i][j]==-1) continue;
				for(int k=0,rem=c-i-j;k<3 && i+j+k<=c;k++,rem--) B.f[j][k]=max(B.f[j][k],min(f[i][j]+rem/3+i,4ll));
			}
		}
		return B;
	}
	inline bool Chk()
	{
		for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(f[i][j]>=4) return true;
		return false;
	}
};
inline Dp Max(Dp A,Dp B)
{
	Dp res;res.clear();
	for(int i=0;i<3;i++)
		for(int j=0;j<3;j++)
			res.f[i][j]=max(A.f[i][j],B.f[i][j]);
	return res;
}
struct AM
{
	Dp F[2];
	int cnt;
	inline bool operator<(const AM &B)const
	{
		if(cnt!=B.cnt) return cnt<B.cnt;
		if(F[0]!=B.F[0]) return F[0]<B.F[0];
		return F[1]<B.F[1];
	}
	inline void init(){F[0].clear(),F[1].clear(),cnt=0,F[0].f[0][0]=0;}
	inline void clear(){F[0].clear(),F[1].clear(),cnt=0;} 
	inline void Hu(){F[0].clear(),F[1].clear(),cnt=-1;}
	inline bool Chk()
	{
		if(cnt>=7) return Hu(),true;
		if(F[1].Chk()) return Hu(),true;
		return false;
	}
	inline AM operator+(int k)const
	{
		AM B,A=*this;B.clear();
		if(A.cnt==-1) return A;
		if(k>=2) B.F[1]=A.F[0].Trans(k-2);
		B.F[0]=A.F[0].Trans(k);
		B.F[1]=Max(B.F[1],A.F[1].Trans(k));
		B.cnt=cnt+(k>=2);
		B.Chk();
		return B;
	}
};
map<AM,int> ID;
int tr[N][5],tot,EnD;
queue<AM> q;

void build()
{
	AM S;S.init();
	ID[S]=++tot,q.push(S);
	while(q.size())
	{
		auto U=q.front();q.pop();
		int u=ID[U];
		for(int c=0;c<=4;c++)
		{
			auto V=U+c;
			if(!ID.count(V)) ID[V]=++tot,q.push(V);
			tr[u][c]=ID[V];
		}
	}
	AM E;E.Hu();
	EnD=ID[E];
}

int qmi(int a,int k)
{
	int res=1;
	while(k)
	{
		if(k&1) res=res*a%mod;
		k>>=1;
		a=a*a%mod;
	}
	return res;
}

void init(int n)
{
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
	ifac[n]=qmi(fac[n],mod-2);
	for(int i=n-1;i>=0;i--) ifac[i]=ifac[i+1]*(i+1)%mod;
}

inline int C(int a,int b)
{
	if(a<b) return 0;
	return fac[a]*ifac[b]%mod*ifac[a-b]%mod;
}

int f[K][N],g[K][N];

void Add(int &a,int b)
{
	if(a+b>=mod) a=a-mod+b;
	else a=a+b;
}

signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); 
	
	cin>>n;
	m=4*n-13;
	for(int i=1,a,b;i<=13;i++) cin>>a>>b,w[a]++;
	
	init(M-10);
	build();
	
	f[0][1]=1;
	for(int i=1;i<=n;i++)
	{
		memcpy(g,f,sizeof f),memset(f,0,sizeof f);
		for(int j=0;j<=4*(i-1);j++)
		{
			for(int u=1;u<=tot;u++)
			{
				if(!g[j][u]) continue;
				for(int c=0;c+w[i]<=4;c++) Add(f[j+c][tr[u][c+w[i]]],g[j][u]*C(4-w[i],c)%mod);
			}
		}
	}
	int res=0,last=0;
	for(int j=1;j<=m;j++)
	{
		int P=f[j][EnD]*fac[j]%mod*fac[m-j]%mod*ifac[m]%mod;
		res=(res+(P-last+mod)%mod*j%mod)%mod;
		last=P;
	}
	
	cout<<res<<"\n";
	
	return 0;
}
```

---

## 作者：User_Unauthorized (赞：0)

首先给出一些定义：

- 顺子：三张大小相邻的牌，例如 $i, i + 1, i + 2$，其中 $1, \le i \le n - 2$。

- 刻子：三张大小相同的牌，例如 $i, i, i$，其中 $1 \le i \le n$。

- 面子：顺子和刻子的统称。

- 对子：两张大小相同的牌，例如 $i, i$，其中 $1 \le i \le n$。

---

我们首先考虑如何判断是否胡牌，对于第二种胡牌方法的判断是简单的，主要考虑第一种。

可以发现，若我们最终的组合方式中存在三个顺子，那么我们可以将其转化为三个刻字。因此我们只需要考虑顺子个数小于三个的情况，考虑设 $f_{i, j, k}$ 表示考虑大小**小于** $i$ 的牌，其中存在 $j$ 个顺子 $\left(i - 2, i - 1, i\right)$，$k$ 个顺子 $\left(i - 1, i, i + 1\right)$ 的情况下可以得到的最多面子数。转移时枚举顺子 $\left(i, i + 1, i + 2\right)$ 的个数 $l$，若 $j + k + l$ 超过了第 $i$ 种牌的数量则非法，否则将剩余的第 $i$ 种牌全部转化为刻子。进而我们得到了一个判定 DP。

对于牌组中是否存在对子的判断是简单的，在 $f$ 中增加一维表示是否存在对子即可。对于第二种胡牌方式，可以在 $f$ 中再增加一维表示可以得到的最大的对子个数（牌组与第一组胡牌方式独立，即一张牌可以同时在该维和上述转移中产生贡献）。

可以发现上述 DP 的状态数不多，考虑建出自动机后进行计数。暴力进行转移后得到的自动机大约是 $3956$ 个节点，因此我们可以进行 DP。

考虑到胡牌轮数的期望难以计算，可以转化为求截至第 $i$ 轮尚未胡牌的概率，进而可以计数。

设 $g_{i, j, k}$ 表示考虑标号不大于 $i$ 的牌，选了 $j$ 个且当前自动机状态为 $k$ 的方案数。转移时枚举第 $i + 1$ 种牌拿几个即可。

复杂度 $\mathcal{O}(n^2S)$，其中 $S = 3956$。


---


# [十二省联考 2019] 字符串问题

## 题目背景

Yazid 和 Tiffany 喜欢字符串问题。在这里，我们将给你介绍一些关于字符串的基本概念。

对于一个字符串 $S$ ，我们定义 $|S|$ 表示 $S$ 的长度。

接着，我们定义该串的子串 $S(L, R)$ 表示由 $S$ 中从左往右数，第 $L$ 个字符到第 $R$ 个字符依次连接形成的字符串，特别地，如果 $L < 1$ 或 $R > |S|$ 或 $L > R$，则 $S(L, R)$ 表示空串。

我们说两个字符串相等，当且仅当它们的长度相等，且从左至右各位上的字符依次
相同。

我们说一个字符串 $T$ 是 $S$ 的前缀，当且仅当 $S(1, |T|) = T$。

两个字符串 $S$, $T$ 相加 $S + T$ 表示的是在 $S$ 后紧挨着写下 $T$ 得到的长度为 $|S| + |T|$ 的字符串。

## 题目描述

现有一个字符串 $S$。

Tiffany 将从中划出 $n_a$ 个子串作为 $A$ 类串，第 $i$ 个（$1 \leqslant i \leqslant n_a$）为 $A_i = S(la_i, ra_i)$。

类似地，Yazid 将划出 $n_b$ 个子串作为 $B$ 类串，第 $i$ 个（$1 \leqslant i \leqslant n_b$）为 $B_i = S(lb_i, rb_i)$。

现额外给定 $m$ 组支配关系，每组支配关系 $(x, y)$ 描述了第 $x$ 个 $A$ 类串**支配** 第 $y$ 个 $B$ 类串。

求一个**长度最大**的目标串 $T$，使得存在一个串 $T$ 的分割 $T = t_1+t_2+· · ·+t_k$（$k \geqslant 0$）满足：
- 分割中的每个串 $t_i$ 均为 $A$ 类串：即存在一个与其相等的 $A$ 类串，不妨假设其为 $t_i = A_{id_i}$。
- 对于分割中所有相邻的串 $t_i, t_{i+1}$（$1 \leqslant i < k$），都有存在一个$A_{id_i}$ 支配的 $B$ 类串，使得该 $B$ 类串为 $t_{i+1}$ 的前缀。

方便起见，你只需要输出这个最大的长度即可。

特别地，如果存在无限长的目标串（即对于任意一个正整数 $n$，都存在一个满足限制的长度超过 $n$ 的串），请输出 $-1$。

## 说明/提示

#### 样例一解释
对于第 $1$ 组数据，$A$ 类串有 $\texttt{aaba}$ 与 $\texttt{aba}$，$B$ 类串有 $\texttt{aa}$，且 $A_2$ 支配 $B_1$。我们可以找到串 $\texttt{abaaaba}$，它可以拆分成 $A_2 + A_1$，且 $A_1$ 包含由 $A_2$ 所支配的 $B_1$ 作为前缀。可以证明不存在长度更大的满足限制的串。

对于第 $2$ 组数据，与第 $1$ 组数据唯一不同的是，唯一的 $B$ 类串为 $\texttt{a}$。容易证明存在无限长的满足限制的串。

对于第 $3$ 组数据，容易证明 $\texttt{abbaabbaaaabb}$ 是最长的满足限制的串。

#### 子任务
|$n_a$|$n_b$|$\lvert S\rvert$|测试点|$m$|$\lvert A_i\rvert \geq \lvert B_j\rvert$|其他限制|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$\leq 100$|$\leq 100$|$\leq 10^4$|$1$|$\leq 10^4$|保证|保证所有 $\lvert A_i\rvert,\lvert B_j\rvert\leq 100$|
|$\leq 1000$|$\leq 1000$|$\leq 2\times 10^5$|$2\sim 3$|$\leq 2\times 10^5$|保证|无|
|$=1$|$\leq 2\times 10^5$|$\leq 2\times 10^5$|$4$|$=n_b$|保证|无|
|$\leq 2\times 10^5$|$\leq 2\times 10^5$|$\leq 2\times 10^5$|$5\sim 6$|$\leq 2\times 10^5$|保证|保证所有 $ra_i +1=la_{i+1}$|
|$\leq 2\times 10^5$|$\leq 2\times 10^5$|$\leq 2\times 10^5$|$7\sim 8$|$\leq 2\times 10^5$|保证|无|
|$\leq 2\times 10^5$|$\leq 2\times 10^5$|$\leq 2\times 10^5$|$9\sim 10$|$\leq 2\times 10^5$|不保证|无|

为了方便你的阅读，我们把**测试点编号**放在了表格的中间，请你注意这一点。

表格中的 $|A_i| > |B_j|$ 指的是**任意** $B$ 类串的长度不超过**任意** $A$ 类串的长度。

对于所有测试点，保证：$T \leqslant 100$，且对于测试点内所有数据，$|S|$, $n_a$, $n_b$, $m$ 的**总和**分别不会超过**该测试点中对应**的**单组数据的限制**的 $10$ 倍。比如，对于第 $1$ 组测试点，就有 $\sum n_a \leqslant 10 \times 100 = 1000$ 等。特别地，我们规定对于测试点 $4$，有 $T \leqslant 10$。

对于所有测试点中的每一组数据，保证：$1 \leqslant |S| \leqslant 2 \times 10^5$，$n_a$, $n_b \leqslant 2 \times 10^5$，$m \leqslant 2 \times 10^5$

#### 提示
十二省联考命题组温馨提醒您：

**数据千万条，清空第一条。**

**多测不清空，爆零两行泪。**

## 样例 #1

### 输入

```
3
abaaaba
2
4 7
1 3
1
3 4
1
2 1
abaaaba
2
4 7
1 3
1
7 7
1
2 1
abbaabbaab
4
1 5
4 7
6 9
8 10
3
1 6
10 10
4 6
5
1 2
1 3
2 1
3 3
4 1```

### 输出

```
7
-1
13```

# 题解

## 作者：liuzhangfeiabc (赞：37)

刚说完d1t1是道不错的温暖题，紧接着就来了一个令人发指的重工业。

题目大意：给定字符串s以及两类区间，再给定一些从第一类区间连向第二类区间的边，一个第二类区间能连向一个第一类区间当且仅当前者是后者的前缀。每个第一类区间的价值是区间长度，求这张图上的最长路（或判断无限长）。

emmmm...说道最长路，这显然是一个图论问题。如果这张图是给定的话，这就是一道小清新的noip题了：只需先跑个tarjan判断一个点是否能回到自己（能的话就是-1），然后在dag上dp即可。

然而...哪有这么简单的事啊！这明明是一道字符串题好伐！

我们需要考虑的就是，第二类区间向第一类区间的边该怎么连？

这里介绍一个我在考场上实现的后缀树做法：

每一个子串在后缀树上都对应一个节点，一个点的祖先对应的子串就是当前子串的前缀。

所以，我们只需要把每个子串都在后缀树上定位到节点，再对于每个第二类子串，向其子树内所有点连边即可。

什么？后缀树怎么建？sam总会吧（不会自行右转模板），反串的sam的parent树就是正串的后缀树啦。

子串定位的过程是通过倍增来实现的，先找到区间的左端点对应后缀的节点，再倍增地往上跳，直到这个点的len>=区间长度，它的fa的len<区间长度即可。

至于连边，当然可以dfs序上线段树优化建图（没错我考场上脑子一热写的就是这个），不过仔细想想发现这其实也没必要：你的后缀树本身就能直接帮你优化建图嘛。

于是你码啊码，终于在奋战2小时后，一份5k+的代码新鲜出炉了！

然而一测样例......蛤？怎么连小样例都过不去？！（小样例的最后一个点会被判成-1）

你冷静下来细细思考......等等，数据范围里的那个ai>=bj是干嘛的？

测一下ai>=bj的样例......居然过了......

那么ai<bj的时候会出现什么bug呢？

问题就出在后缀树上。一个后缀树上的节点可能对应多个长度不同的串，此时如果我们单纯地将每个第二类区间向其子树连边，就会错误地把当前节点上可能更短的第一类区间的点当成可以转移的点！

那怎么办？拆点！

一旦有这种情况的出现，我们就直接把这个点连向fa的边中间强行塞进去一堆点，此时再连边显然就是对的了。

总复杂度：除了子串定位部分是n log n，其它部分都是线性的（如果你没像我一样蠢到线段树优化建图的话）。

另外我感觉其实跑tarjan也是不需要的，只需要判一下是否有环即可，有环一定是-1。

于是，一份近9k的代码就这样诞生了......

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<vector>
using namespace std;
#define li long long
#define gc getchar()
#define pc putchar
inline li read(){
	li x = 0,y = 0,c = gc;
	while(c < '0' || c > '9') y = c,c = gc;
	while(c >= '0' && c <= '9') x = x * 10 + c - '0',c = gc;
	return y == '-' ? -x : x;
}
inline void print(li x){
	if(x < 0) pc('-'),x = -x;
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
inline void file(){
	freopen("string.in","r",stdin);
	freopen("string.out","w",stdout);
}
char s[1000010];
int t,n,p1,p2,m;
struct node{
	int l,r,x;
}a[1000010],b[1000010];
int tot = 1,lst = 1,son[400010][26],len[1000010],fa[1000010],wz[1000010];
inline int inss(int x){
	int p = lst,np = ++tot;lst = np;len[np] = len[p] + 1;
	for(;p && !son[p][x];p = fa[p]) son[p][x] = np;
	if(!p) fa[np] = 1;
	else{
		int q = son[p][x];
		if(len[q] == len[p] + 1) fa[np] = q;
		else{
			int nq = ++tot;
			len[nq] = len[p] + 1;
			memcpy(son[nq],son[q],sizeof(son[nq]));
			fa[nq] = fa[q];
			fa[q] = fa[np] = nq;
			for(;son[p][x] == q;p = fa[p]) son[p][x] = nq;
		}
	}
	return np;
}

int wei[1000010],nw,ed[1000010];
int val[3000010];
struct edge{
	int to,nxt;
}e[20000010];
int cnt,fir[3000010],mx;
int fsts[1000010],nxts[1000010];
inline void dfs(int q){
	wei[q] = ++nw;
	for(int i = fsts[q];i;i = nxts[i]) dfs(i);
	ed[q] = nw;
}
inline void dfs3(int q){
	wei[q] = ++nw;
	for(int i = fsts[q];i;i = nxts[i]) dfs3(i);
	ed[q] = nw;
}
int st[20][1000010];
inline void buildst(){
	register int i,j;
	for(i = 1;i <= tot;++i) st[0][i] = fa[i];
	for(i = 1;i <= 18;++i){
		for(j = 1;j <= tot;++j) st[i][j] = st[i - 1][st[i - 1][j]];
	} 
}
inline int fd(int l,int r){
	int nw = wz[l];
	for(int i = 18;i >= 0;--i) if(len[st[i][nw]] >= r - l + 1) nw = st[i][nw];
	return nw;
}
inline void ins(int u,int v){
	//cerr<<u<<" "<<v<<"&"<<endl;
	e[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;
	mx = max(mx,max(u,v));
}
#define ls (q << 1)
#define rs (q << 1 | 1)
#define ln ls,l,mid
#define rn rs,mid + 1,r
#define md int mid = l + r >> 1
int www[1000010];
inline void build(int q,int l,int r){
	if(l == r){
		www[l] = q;
		return;
	}
	md;
	ins(q + p1 + p2,ls + p1 + p2);ins(q + p1 + p2,rs + p1 + p2);
	build(ln);build(rn);
}
inline void xg(int q,int l,int r,int ax,int x){
	if(l == r){
		ins(q + p1 + p2,x);
		return;
	}
	md;
	if(mid >= ax) xg(ln,ax,x);
	else xg(rn,ax,x);
}
inline void xg2(int q,int l,int r,int al,int ar,int x){
	if(l >= al && r <= ar){
		ins(x + p1,q + p1 + p2);
		return;
	}
	md;
	if(mid >= al) xg2(ln,al,ar,x);
	if(mid < ar) xg2(rn,al,ar,x);
}
int dfn[3000010],low[3000010],bel[3000010],pp,sc;
vector<int> scc[3000010],qwq1[500010],qwq2[500010];
int pwp;
li an[3000010];
bool inst[3000010];
int stt[3000010],ft;
int qu[3000010],hh,tt,dus[3000010];

inline void tar(int q){
	dfn[q] = low[q] = ++pp;
	stt[++ft] = q;inst[q] = 1;
	for(int i = fir[q];i;i = e[i].nxt){
		if(!dfn[e[i].to]){
			tar(e[i].to);low[q] = min(low[q],low[e[i].to]);
		}
		else if(inst[e[i].to]) low[q] = min(low[q],dfn[e[i].to]);
	}
	if(low[q] == dfn[q]){
		int j;
		++sc;
		do{
			j = stt[ft--];
			bel[j] = sc;
			inst[j] = 0;
			scc[sc].push_back(j);
		}while(j != q);
	}
}
inline void wk(){
	int i,j,l;
	for(i = 1;i <= sc;++i) if(scc[i].size() > 1){
		li vl = 0;
		for(j = 0;j < scc[i].size();++j) vl += val[scc[i][j]];
		if(vl > 0){
			puts("-1");
			return;
		}
	}
	for(i = 1;i <= sc;++i){
		for(j = 0;j < scc[i].size();++j){
			for(l = fir[scc[i][j]];l;l = e[l].nxt) if(bel[e[l].to] != i) ++dus[bel[e[l].to]];
		}
	}
	hh = tt = 0;
	for(i = 1;i <= sc;++i) if(!dus[i]) qu[++tt] = i;
	while(hh < tt){
		i = qu[++hh];
		for(j = 0;j < scc[i].size();++j){
			an[i] += val[scc[i][j]];
			for(l = fir[scc[i][j]];l;l = e[l].nxt) if(bel[e[l].to] != i){
				an[bel[e[l].to]] = max(an[bel[e[l].to]],an[i]);
				--dus[bel[e[l].to]];
				if(!dus[bel[e[l].to]]) qu[++tt] = bel[e[l].to]; 
			} 
		}
	}
	li ans = 0;
	for(i = 1;i <= sc;++i) ans = max(ans,an[i]);
	print(ans);pc('\n');
}
inline bool cmp1(int q,int w){
	return a[q].r - a[q].l > a[w].r - a[w].l;
}
inline bool cmp2(int q,int w){
	return b[q].r - b[q].l > b[w].r - b[w].l;
}
void dfs2(int q){
	//cerr<<q<<" "<<len[q]<<endl;
	if(q != 1 && (qwq1[q].size() != 0 || qwq2[q].size() != 0)){
		int nwq = q,i = 0,j = 0,lst = len[q],nxt,nxtq;
		while(i < qwq1[q].size() && j < qwq2[q].size()){
			//cerr<<i<<" "<<j<<"()"<<" "<<qwq1[q].size()<<" "<<qwq2[q].size()<<endl;
			if(a[qwq1[q][i]].r - a[qwq1[q][i]].l > b[qwq2[q][j]].r - b[qwq2[q][j]].l){
				nxt = a[qwq1[q][i]].r - a[qwq1[q][i]].l + 1;
				if(nxt == lst) a[qwq1[q][i]].x = nwq;
				else{
					nxtq = ++tot;
					fa[nxtq] = fa[nwq];
					fa[nwq] = nxtq;
					len[nxtq] = nxt;
					a[qwq1[q][i]].x = nxtq;
					nwq = nxtq;
				}
				lst = nxt;++i;
			}
			else{
				nxt = b[qwq2[q][j]].r - b[qwq2[q][j]].l + 1;
				if(nxt == lst) b[qwq2[q][j]].x = nwq;
				else{
					nxtq = ++tot;
					fa[nxtq] = fa[nwq];
					fa[nwq] = nxtq;
					len[nxtq] = nxt;
					b[qwq2[q][j]].x = nxtq;
					nwq = nxtq;
				}
				lst = nxt;++j;
			}
		}
		//cerr<<"*"<<endl;
		while(i < qwq1[q].size()){
			nxt = a[qwq1[q][i]].r - a[qwq1[q][i]].l + 1;
			if(nxt == lst) a[qwq1[q][i]].x = nwq;
			else{
				nxtq = ++tot;
				fa[nxtq] = fa[nwq];
				fa[nwq] = nxtq;
				len[nxtq] = nxt;
				a[qwq1[q][i]].x = nxtq;
				nwq = nxtq;
			}
			lst = nxt;++i;
		}
		while(j < qwq2[q].size()){
			nxt = b[qwq2[q][j]].r - b[qwq2[q][j]].l + 1;
			if(nxt == lst) b[qwq2[q][j]].x = nwq;
			else{
				nxtq = ++tot;
				fa[nxtq] = fa[nwq];
				fa[nwq] = nxtq;
				len[nxtq] = nxt;
				b[qwq2[q][j]].x = nxtq;
				nwq = nxtq;
			}
			lst = nxt;++j;
		}
	}
	for(int i = fsts[q];i;i = nxts[i]) dfs2(i);
}
int main(){
	//file();
	int i,j,u,v,mx1,mx2;
	t = read();
	while(t--){
		scanf("%s",s + 1);n = strlen(s + 1);
		for(i = n;i;--i) wz[i] = inss(s[i] - 'a');
		
		//cerr<<tot<<"*"<<endl;
		//for(i = 1;i <= tot;++i) cerr<<fa[i]<<" ";cerr<<endl;
		//for(i = 1;i <= tot;++i) cerr<<len[i]<<" ";cerr<<endl;
		//for(i = 1;i <= n;++i) cerr<<wz[i]<<" ";cerr<<endl;
		for(i = 2;i <= tot;++i) nxts[i] = fsts[fa[i]],fsts[fa[i]] = i;
		dfs(1);buildst();
		//for(i = 1;i <= tot;++i) cerr<<wei[i]<<" ";cerr<<endl;
		//for(i = 1;i <= tot;++i) cerr<<ed[i]<<" ";cerr<<endl;
		
		mx1 = n;
		mx2 = 0;
		p1 = read();
		for(i = 1;i <= p1;++i){
			a[i].l = read();a[i].r = read();mx1 = min(mx1,a[i].r - a[i].l + 1);
			a[i].x = fd(a[i].l,a[i].r);val[i] = a[i].r - a[i].l + 1;
		}
		p2 = read();
		for(i = 1;i <= p2;++i){
			b[i].l = read();b[i].r = read();mx2 = max(mx2,b[i].r - b[i].l + 1);
			b[i].x = fd(b[i].l,b[i].r);
		}
		pwp = tot;
		
		if(mx1 < mx2){
			//cerr<<"***"<<endl;
			
			for(i = 1;i <= p1;++i) qwq1[a[i].x].push_back(i);
			for(i = 1;i <= p2;++i) qwq2[b[i].x].push_back(i);
			for(i = 1;i <= tot;++i) sort(qwq1[i].begin(),qwq1[i].end(),cmp1),sort(qwq2[i].begin(),qwq2[i].end(),cmp2);
			//cerr<<"&&&"<<tot<<endl;
			dfs2(1);
			//cerr<<"()"<<endl;
			for(i = 1;i <= tot;++i) nxts[i] = fsts[i] = 0;
			nw = 0;
			for(i = 2;i <= tot;++i) nxts[i] = fsts[fa[i]],fsts[fa[i]] = i;
			dfs3(1);
			//cerr<<tot<<endl;
		}
		build(1,1,tot);
		
		for(i = 1;i <= p1;++i){
			ins(www[wei[a[i].x]] + p1 + p2,i);
			//cerr<<a[i].l<<" "<<a[i].r<<" "<<a[i].x<<" "<<wei[a[i].x]<<"()"<<endl;
			//xg(1,1,tot,wei[a[i].x],i);
		}
		for(i = 1;i <= p2;++i){
			
			//cerr<<b[i].l<<" "<<b[i].r<<" "<<b[i].x<<" "<<wei[b[i].x]<<" "<<ed[b[i].x]<<"&&"<<endl;
			xg2(1,1,tot,wei[b[i].x],ed[b[i].x],i);
		}
		m = read();
		for(i = 1;i <= m;++i) u = read(),v = read(),ins(u,v + p1);
		//return 0;
		for(i = 1;i <= mx;++i) if(!dfn[i]) tar(i);
		
		wk();
		//cerr<<mx<<" "<<pwp<<" "<<tot<<endl;return 0;
		for(i = 1;i <= n;++i) s[i] = wz[i] = 0;
		for(i = 1;i <= pwp;++i) memset(son[i],0,sizeof(son[i]));
		for(i = 1;i <= tot;++i) fa[i] = len[i] = wei[i] = ed[i] = fsts[i] = nxts[i] = www[i] = 0;
		for(i = 1;i <= mx;++i) fir[i] = val[i] = dfn[i] = low[i] = bel[i] = an[i] = 0;
		for(i = 1;i <= sc;++i) scc[i].clear();
		for(i = 1;i <= pwp;++i) qwq1[i].clear(),qwq2[i].clear();
		tot = lst = 1;
		cnt = mx = nw = pp = sc = hh = tt = ft = pwp = 0;
	}
	return 0;
}
```

---

## 作者：Ireliaღ (赞：27)

这道题思维难度不算很大，可是细节和程序实现很恶心。去年去省选的学长全都口胡出了80分做法，但是得分情况就没这么理想。

## 简述题意

给出一个母串$S$。

有一些$A$类串和一些$B$类串，都是$S$的子串，以左右端点的方式给出。

给出一些$A$类串对$B$类串的支配关系。

我们需要用若干个$A$类串首位顺次相连，要求对于每相邻两个$A$类串，必须存在一个$B$类串被前一个串支配，且是后一个串前缀。我们想让连接后的串尽量长，输出这个长度。如果可以无限长，输出"-1"。

## 解法

首先有一个很显然的暴力思路。

对于所有$A$对$B$的支配，从$A$串到$B$串连接一条有向边。遍历所有$B$串，对于每个$A$串，如果这个$B$串是他的前缀，那么从$B$串往$A$串连接一条有向边。每个$A$串点的点权是它的长度，现在需要求出DAG的最长路。如果出环了，就是-1。

这个暴力算法过不了的原因显然是$B$到$A$的边数最坏可以达到$n^2$，我们需要减少这一部分的边数。

考虑后缀数组的经典套路：对母串建立SA，再建立`height`数组和它的ST表，这样就可以$O(1)$求出来以$l_1$和$l_2$为左端点的母串后缀的最长公共前缀（LCP）。所以，对于每一个$B$类串，我们调用它左端点位置的排名$p$，在SA上分别往左右倍增出离$p$最远的$l$和$r$，满足$LCP(l, p),LCP(r, p)$ 都不小于这个$B$类串的长度。那么所有左端点排名在$[l, r]$的$A$串都有$B$这个前缀。

既然$B$串的出边在SA上是一个连续区间，那么可以对SA建立线段树，父亲往儿子连边，叶子向以它为左端点的$A$串连边。$A$串对$B$串的支配边不用变。对于每个$B$串，用前面的方法倍增出$l$和$r$，到线段树查询，向刚好覆盖$[l, r]$的节点连边。这样，边数就优化到了$n \log n$。如果保证所有$B$串比$A$串短，那么这个算法就是正确的。这样，就有了80分。

如果不保证$B$比$A$短怎么办？很多带佬说以长度为版本建主席树，但是我们有更简单的办法。

首先，我们有了母串的SA、`height`和ST表，可以$O(1)$求两个位置的LCP。那么，考虑充分利用已经得到的数据，如果给定母串的两个区间，我们可以**根据区间长度、左端点的后缀排名、两个左端点的LCP，来$O(1)$得到这两个子串的字典序大小**。这样，我们可以$O(n)$桶排出$A$串的大小顺序（直接写成比较函数然后`sort`也可）。在有序的$A$串数组上，以某个$B$串为前缀的$A$串显然是一个连续区间。那么，我们把80分思路中的SA的线段树换成$A$串有序数组的线段树，每个$B$串的支配区间也可以用前面写的比较函数和倍增求出，其余部分沿用80分思路，就可以得到100分。

## 代码

细节非常多。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;
typedef long long LL;
const int MAXN = 2e5 + 5;

char S[MAXN];
int na, la[MAXN], ra[MAXN];
int nb, lb[MAXN], rb[MAXN];
int tot;

namespace SA{
	int n, m;
	int sa[MAXN], rk[MAXN], tx[MAXN], tp[MAXN], ht[MAXN];
	int lg[MAXN], stt[21][MAXN];
	
	void Clear() {
		for (int i = 0; i <= max(n, m); i++)
			sa[i] = rk[i] = tx[i] = tp[i] = ht[i] = 0;
		n = m = 0;
	}
	
	void RSort() {
		for (int i = 0; i <= m; i++) tx[i] = 0;
		for (int i = 1; i <= n; i++) tx[rk[i]]++;
		for (int i = 1; i <= m; i++) tx[i] += tx[i - 1];
		for (int i = n; i >= 1; i--) sa[tx[rk[tp[i]]]--] = tp[i];
	}
	
	void Build() {
		RSort();
		for (int w = 1, p = 1; p < n; m = p, w <<= 1) {
			p = 0;
			for (int i = 1; i <= w; i++)
				tp[++p] = n - w + i;
			for (int i = 1; i <= n; i++)
				if (sa[i] > w)
					tp[++p] = sa[i] - w;
			RSort();
			swap(tp, rk);
			rk[sa[1]] = p = 1;
			for (int i = 2; i <= n; i++)
				rk[sa[i]] = (tp[sa[i]] == tp[sa[i - 1]] && tp[sa[i] + w] == tp[sa[i - 1] + w]) ? p : ++p;
		}
	}
	
	void GetH() {
		for (int i = 1; i <= n; i++) rk[sa[i]] = i;
		int k = 0;
		for (int i = 1; i <= n; i++) {
			if (rk[i] == 1) continue;
			if (k) k--;
			int j = sa[rk[i] - 1];
			while (i + k <= n && j + k <= n && S[i + k] == S[j + k]) k++;
			ht[rk[i]] = k;
		}
	}
	
	void GetST() {
		for (int i = 1; i <= n; i++) stt[0][i] = ht[i];
		for (int i = 1; (1 << i) <= n; i++) {
			int w = (1 << i);
			for (int j = 1; j + w - 1 <= n; j++)
				stt[i][j] = min(stt[i - 1][j], stt[i - 1][j + w / 2]);
		}
	}
	
	int Query(int x, int y) {
		if (x == y) return n - x + 1;
		x = rk[x]; y = rk[y];
		if (x > y) swap(x, y);
		x++;
		int i = lg[y - x + 1], w = (1 << i);
		return min(stt[i][x], stt[i][y - w + 1]);
	}
}

namespace G{
	const int MAXN = 5e6;
	
	int n, ecnt;
	int to[MAXN], nx[MAXN], head[MAXN], deg[MAXN], val[MAXN];
	LL f[MAXN], ans;
	int q[MAXN], hd, tl;
	
	void Clear() {
		for (int i = 1; i <= n; i++)
			deg[i] = val[i] = f[i] = head[i] = 0;
		n = ecnt = ans = hd = tl = 0;
	}
	
	void Add(int x, int y) {
		to[++ecnt] = y;
		nx[ecnt] = head[x];
		head[x] = ecnt;
		deg[y]++;
	}
	
	void Topo() {
		hd = 1, tl = 0;
		for (int i = 1; i <= n; i++) {
			if (!deg[i])
				q[++tl] = i;
			f[i] = val[i];
		}
		while (hd <= tl) {
			int u = q[hd++];
			ans = max(ans, f[u]);
			for (int i = head[u]; i; i = nx[i]) {
				int v = to[i];
				f[v] = max(f[v], f[u] + val[v]);
				deg[v]--;
				if (!deg[v]) q[++tl] = v;
			}
		}
		if (tl != n) ans = -1;
	}
}using G::Add;

namespace Seg{
	const int MAXN = 1e6;
	
	int id[MAXN];
	
	void Clear() {
		memset(id, 0, sizeof(id));
	}
	
	void InsA(int now, int p, int x, int l, int r) {
		if (!id[now]) {
			id[now] = ++tot;
			Add(id[now >> 1], id[now]);
		}
		if (l == r) {
			Add(id[now], x);
			return;
		}
		int mid = (l + r) >> 1;
		if (p <= mid) InsA(now << 1, p, x, l, mid);
		else InsA(now << 1 | 1, p, x, mid + 1, r);
	}
	
	void InsB(int now, int l, int r, int x, int nl, int nr) {
		if (!id[now]) return;
		if (l == nl && r == nr) {
			Add(x, id[now]);
			return;
		}
		int mid = (nl + nr) >> 1;
		if (r <= mid) InsB(now << 1, l, r, x, nl, mid);
		else if (l > mid) InsB(now << 1 | 1, l, r, x, mid + 1, nr);
		else InsB(now << 1, l, mid, x, nl, mid), InsB(now << 1 | 1, mid + 1, r, x, mid + 1, nr);
	}
}

struct Seq{
	int l, r, len, id;
	Seq() {}
	Seq(int l, int r, int id) : l(l), r(r), id(id) {len = r - l + 1;}
}stra[MAXN];

int Comp(Seq a, Seq b) {
	int lcp = SA::Query(a.l, b.l);
	if (lcp >= min(a.len, b.len)) return a.len < b.len;
	else return S[a.l + lcp] < S[b.l + lcp];
}

int n, m;

void Work() {
	scanf("%s", S + 1);
	n = strlen(S + 1);
	scanf("%d", &na);
	for (int i = 1; i <= na; i++) scanf("%d%d", la + i, ra + i);
	scanf("%d", &nb);
	for (int i = 1; i <= nb; i++) scanf("%d%d", lb + i, rb + i);
	for (int i = 1; i <= n; i++) {
		SA::rk[i] = S[i];
		SA::tp[i] = i;
	}
	SA::n = n;
	SA::m = 127;
	SA::Build();
	SA::GetH();
	SA::GetST();
	for (int i = 1; i <= na; i++) stra[i] = Seq(la[i], ra[i], i);
	tot = na + nb;
	Seg::id[1] = ++tot;
	sort(stra + 1, stra + na + 1, Comp);
	for (int i = 1; i <= na; i++) Seg::InsA(1, i, stra[i].id, 1, na);
	for (int i = 1; i <= nb; i++) {
		Seq strb(lb[i], rb[i], i + na);
		int liml = 0;
		for (int j = 20; j >= 0; j--) {
			int w = (1 << j);
			if (liml + w > na) continue;	
			if (Comp(stra[liml + w], strb)) 
				liml += w;
		}
		liml++;
		if (liml > na) continue;
		if (SA::Query(strb.l, stra[liml].l) < strb.len) continue;
		int limr = liml;
		for (int j = 20; j >= 0; j--) {
			int w = (1 << j);
			if (limr + w > na) continue;
			if (SA::Query(stra[limr + w].l, strb.l) >= strb.len)
				limr += w;
		}
		Seg::InsB(1, liml, limr, na + i, 1, na);
	}
	scanf("%d", &m);
	for (int i = 1, x, y; i <= m; i++) {
		scanf("%d%d", &x, &y);
		G::Add(x, y + na);
	}
	for (int i = 1; i <= na; i++) G::val[i] = ra[i] - la[i] + 1;
	G::n = tot;
	G::Topo();
	printf("%lld\n", G::ans);
	SA::Clear();
	G::Clear();
	Seg::Clear();
}

int main() {
	for (int i = 2; i <= 200000; i++) SA::lg[i] = SA::lg[i >> 1] + 1;
	int T;
	scanf("%d", &T);
	while (T--) Work();
	return 0;
}
```

这样就不需要主席树了。

还觉得麻烦？没事，还可以用ST表建图，反正时限长，放开跑，T不了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;
typedef long long LL;
const int MAXN = 2e5 + 5;

char S[MAXN];
int na, la[MAXN], ra[MAXN];
int nb, lb[MAXN], rb[MAXN];
int tot;
int lg[MAXN];

namespace SA{
	int n, m;
	int sa[MAXN], rk[MAXN], tx[MAXN], tp[MAXN], ht[MAXN];
	int stt[21][MAXN];
	
	void Clear() {
		for (int i = 0; i <= max(n, m); i++)
			sa[i] = rk[i] = tx[i] = tp[i] = ht[i] = 0;
		n = m = 0;
	}
	
	void RSort() {
		for (int i = 0; i <= m; i++) tx[i] = 0;
		for (int i = 1; i <= n; i++) tx[rk[i]]++;
		for (int i = 1; i <= m; i++) tx[i] += tx[i - 1];
		for (int i = n; i >= 1; i--) sa[tx[rk[tp[i]]]--] = tp[i];
	}
	
	void Build() {
		RSort();
		for (int w = 1, p = 1; p < n; m = p, w <<= 1) {
			p = 0;
			for (int i = 1; i <= w; i++)
				tp[++p] = n - w + i;
			for (int i = 1; i <= n; i++)
				if (sa[i] > w)
					tp[++p] = sa[i] - w;
			RSort();
			swap(tp, rk);
			rk[sa[1]] = p = 1;
			for (int i = 2; i <= n; i++)
				rk[sa[i]] = (tp[sa[i]] == tp[sa[i - 1]] && tp[sa[i] + w] == tp[sa[i - 1] + w]) ? p : ++p;
		}
	}
	
	void GetH() {
		for (int i = 1; i <= n; i++) rk[sa[i]] = i;
		int k = 0;
		for (int i = 1; i <= n; i++) {
			if (rk[i] == 1) continue;
			if (k) k--;
			int j = sa[rk[i] - 1];
			while (i + k <= n && j + k <= n && S[i + k] == S[j + k]) k++;
			ht[rk[i]] = k;
		}
	}
	
	void GetST() {
		for (int i = 1; i <= n; i++) stt[0][i] = ht[i];
		for (int i = 1; (1 << i) <= n; i++) {
			int w = (1 << i);
			for (int j = 1; j + w - 1 <= n; j++)
				stt[i][j] = min(stt[i - 1][j], stt[i - 1][j + (w >> 1)]);
		}
	}
	
	int Query(int x, int y) {
		if (x == y) return n - x + 1;
		x = rk[x]; y = rk[y];
		if (x > y) swap(x, y);
		x++;
		int i = lg[y - x + 1], w = (1 << i);
		return min(stt[i][x], stt[i][y - w + 1]);
	}
}

namespace G{
	const int MAXN = 1e7;
	
	int n, ecnt;
	int to[MAXN], nx[MAXN], head[MAXN], deg[MAXN], val[MAXN];
	LL f[MAXN], ans;
	int q[MAXN], hd, tl;
	
	void Clear() {
		for (int i = 1; i <= n; i++)
			deg[i] = val[i] = f[i] = head[i] = 0;
		n = ecnt = ans = hd = tl = 0;
	}
	
	void Add(int x, int y) {
		to[++ecnt] = y;
		nx[ecnt] = head[x];
		head[x] = ecnt;
		deg[y]++;
	}
	
	void Topo() {
		hd = 1, tl = 0;
		for (int i = 1; i <= n; i++) {
			if (!deg[i])
				q[++tl] = i;
			f[i] = val[i];
		}
		while (hd <= tl) {
			int u = q[hd++];
			ans = max(ans, f[u]);
			for (int i = head[u]; i; i = nx[i]) {
				int v = to[i];
				f[v] = max(f[v], f[u] + val[v]);
				deg[v]--;
				if (!deg[v]) q[++tl] = v;
			}
		}
		if (tl != n) ans = -1;
	}
}using G::Add;

struct Seq{
	int l, r, len, id;
	Seq() {}
	Seq(int l, int r, int id) : l(l), r(r), id(id) {len = r - l + 1;}
}stra[MAXN];
int gid[20][MAXN];

void InsA() {
	for (int i = 1; i <= na; i++) gid[0][i] = stra[i].id;
	for (int i = 1; (1 << i) <= na; i++) {
		int w = (1 << i);
		for (int j = 1; j + w - 1 <= na; j++) {
			gid[i][j] = ++tot;
			Add(gid[i][j], gid[i - 1][j]);
			Add(gid[i][j], gid[i - 1][j + (w >> 1)]);
		}
	}
}

void InsB(int id, int l, int r) {
	int i = lg[r - l + 1], w = (1 << i);
	Add(id, gid[i][l]);
	Add(id, gid[i][r - w + 1]);
}

int Comp(Seq a, Seq b) {
	int lcp = SA::Query(a.l, b.l);
	if (lcp >= min(a.len, b.len)) return a.len < b.len;
	else return S[a.l + lcp] < S[b.l + lcp];
}

int n, m;

void Work() {
	scanf("%s", S + 1);
	n = strlen(S + 1);
	scanf("%d", &na);
	for (int i = 1; i <= na; i++) scanf("%d%d", la + i, ra + i);
	scanf("%d", &nb);
	for (int i = 1; i <= nb; i++) scanf("%d%d", lb + i, rb + i);
	for (int i = 1; i <= n; i++) {
		SA::rk[i] = S[i];
		SA::tp[i] = i;
	}
	SA::n = n;
	SA::m = 127;
	SA::Build();
	SA::GetH();
	SA::GetST();
	for (int i = 1; i <= na; i++) stra[i] = Seq(la[i], ra[i], i);
	tot = na + nb;
	sort(stra + 1, stra + na + 1, Comp);
	InsA();
	for (int i = 1; i <= nb; i++) {
		Seq strb(lb[i], rb[i], i + na);
		int liml = 0;
		for (int j = 20; j >= 0; j--) {
			int w = (1 << j);
			if (liml + w > na) continue;	
			if (Comp(stra[liml + w], strb)) 
				liml += w;
		}
		liml++;
		if (liml > na) continue;
		if (SA::Query(strb.l, stra[liml].l) < strb.len) continue;
		int limr = liml;
		for (int j = 20; j >= 0; j--) {
			int w = (1 << j);
			if (limr + w > na) continue;
			if (SA::Query(stra[limr + w].l, strb.l) >= strb.len)
				limr += w;
		}
		InsB(na + i, liml, limr);
	}
	scanf("%d", &m);
	for (int i = 1, x, y; i <= m; i++) {
		scanf("%d%d", &x, &y);
		G::Add(x, y + na);
	}
	for (int i = 1; i <= na; i++) G::val[i] = ra[i] - la[i] + 1;
	G::n = tot;
	G::Topo();
	printf("%lld\n", G::ans);
	SA::Clear();
	G::Clear();
}

int main() {
	for (int i = 2; i <= 200000; i++) lg[i] = lg[i >> 1] + 1;
	int T;
	scanf("%d", &T);
	while (T--) Work();
	return 0;
}
···

---

## 作者：Owen_codeisking (赞：21)

自己拿到题目口胡了一下后缀数组的做法，后缀数组 + 倍增 + 线段树优化建图 + $DAG$ 上拓扑，我码力不够就没打了。。。

然后我 $yy$ 了一下后缀自动机的做法，虽然也很麻烦，但是思路理清了就没什么问题了。

### 后缀自动机 + 树上倍增 + 字典树优化建图 + $DAG$ 上拓扑

首先我们可以暴力 $O(n^3)$ 匹配+连边，然后在 $DAG$ 上拓扑，这样你可以获得 $10pts$ 的好成绩。

我们先建出**反串**的后缀自动机，注意是**反串**，**反串**，**反串**！

我们要在后缀自动机上找到一段子串，那么记录一下反串每一个位置在后缀自动机上的位置，然后倍增上去。我们对于每个后缀自动机的结点开一个 $vector$，按照**子串长度**为第一关键字，**是否为 $A$ 类串**为第二关键字排序，然后依次连边。

由于反串两个前缀一定有一个前缀是另一个前缀的前缀（好像有点拗口），所以我们把后缀自动机父亲结点挂下来的结点向当前结点连一条边。

然后就可以愉快的在 $DAG$ 上拓扑了！

每个数组空间开多大要算一下以及常数写的稍微好一点，不然不开 $O_2$ 可能会 $T$ 飞掉。

其实空间不算也可以啊，直接无脑开 $8\times 10^5$ 绝对不会炸。。。

还有就是答案要开 $\text{long\ long}$！如果你觉得这道题在随机数据的情况下答案非常小，那么你就大错特错了。虽然我也不知道为什么出题人造数据的本事如此的强，但是理论上答案可以达到 $10^{10}$ 级别。

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=200000+10;
int n,na,nb,m,sz,a[maxn],b[maxn],isa[maxn<<2];char s[maxn];
int last,cnt,id[maxn],lst[maxn<<1],f[maxn<<1][20],ch[maxn<<1][26],fa[maxn<<1],len[maxn<<2];
int in[maxn<<2],head[maxn<<2],to[maxn<<3],nxt[maxn<<3],tot;
vector<int> g[maxn<<2];ll dis[maxn<<2];

inline void insert(int c)
{
    int p=last,q=++cnt;last=q;len[q]=len[p]+1;
    for(;p&&!ch[p][c];p=fa[p]) ch[p][c]=q;
    if(!p) fa[q]=1;
    else
    {
        int r=ch[p][c];
        if(len[p]+1==len[r]) fa[q]=r;
        else
        {
            int s=++cnt;len[s]=len[p]+1;
            memcpy(ch[s],ch[r],sizeof(ch[r]));
            fa[s]=fa[r];fa[r]=fa[q]=s;
            for(;p&&ch[p][c]==r;p=fa[p]) ch[p][c]=s;
        }
    }
}

inline void judge(int b)
{
    int l,r;
    scanf("%d%d",&l,&r);
    r=r-l+1;l=id[l];
    for(int i=19;i>=0;i--)
        if(f[l][i]&&len[f[l][i]]>=r) l=f[l][i];
    isa[++sz]=b;len[sz]=r;g[l].push_back(sz);
}

inline bool cmp(const int &x,const int &y)
{
    return len[x]>len[y]||(len[x]==len[y]&&isa[x]>isa[y]);
}

inline void addedge(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
    in[y]++;
}

inline void solve()
{
    scanf("%s",s+1);n=strlen(s+1);last=cnt=1;
    for(int i=n;i>=1;i--) insert(s[i]-'a'),id[i]=last;
    for(int i=1;i<=cnt;i++) f[i][0]=fa[i];
    for(int j=1;j<=19;j++)
        for(int i=1;i<=cnt;i++) f[i][j]=f[f[i][j-1]][j-1];
    scanf("%d",&na);sz=cnt;
    for(int i=1;i<=na;i++) judge(1),a[i]=sz;
    scanf("%d",&nb);
    for(int i=1;i<=nb;i++) judge(0),b[i]=sz;
    for(int i=1;i<=cnt;i++) sort(g[i].begin(),g[i].end(),cmp);
    for(int i=1;i<=cnt;i++)
    {
        int last=i;
        for(int j=g[i].size()-1;j>=0;j--)
        {
            int now=g[i][j];addedge(last,now);
            if(!isa[now]) last=now;
        }
        lst[i]=last;
    }
    for(int i=2;i<=cnt;i++) addedge(lst[fa[i]],i);
    for(int i=1;i<=sz;i++)
        if(!isa[i]) len[i]=0;
    scanf("%d",&m);
    int x,y,f=0;ll ans=0;
    for(int i=1;i<=m;i++) scanf("%d%d",&x,&y),addedge(a[x],b[y]);
    queue<int> q;
    for(int i=1;i<=sz;i++)
        if(!in[i]) q.push(i);
    while(!q.empty())
    {
        x=q.front(),q.pop();
        ans=max(ans,dis[x]+len[x]);
        for(int i=head[x];i;i=nxt[i])
        {
            y=to[i];dis[y]=max(dis[y],dis[x]+len[x]);
            if(!--in[y]) q.push(y);
        }
    }
    for(int i=1;i<=sz;i++)
        if(in[i]){f=1;break;}
    if(f) printf("-1\n");
    else printf("%lld\n",ans);
    while(!q.empty()) q.pop();
    for(int i=1;i<=cnt;i++) fa[i]=0,memset(ch[i],0,sizeof(ch[i]));
    for(int i=1;i<=sz;i++) g[i].clear(),isa[i]=len[i]=head[i]=dis[i]=in[i]=0;
    last=cnt=sz=tot=0;
}

int main()
{
    int T;
    scanf("%d",&T);
    while(T--) solve();
    return 0;
}
```

---

## 作者：浮尘ii (赞：18)

提供一篇 `后缀数组` 的题解。

首先理解题意，构建出图论模型：
- 按照题意的支配关系连边，若 $x$ 支配 $y$ 则将 $A_x$ 向 $B_y$ 连边；
- 若 $B_j$ 是 $A_i$ 的前缀，将 $B_j$ 向 $A_i$ 连边。

则这时题目要求的即为这个图的最长路（若有环输出 $-1$）。只需要拓扑排序然后 DP 即可。

暴力建边边数为 $O(m+n_an_b)$，能得到 $\rm 40pts$。我们需要优化建图。

对于第一类边，显然只有 $O(m)$ 条，无需优化。我们只需考虑如何优化第二类边即可。

先考虑 $\rm 80pts$ 如何使用后缀数组。

求出后缀数组后，对于 $\mathrm{SA}_l\dots\mathrm{SA}_r$ 这些后缀，他们的最长公共前缀长度即为 $\mathrm{LCP}(\mathrm{SA}_l, \mathrm{SA}_r)$。对于一个 B 类串 $S(lb_i,rb_i)$，我们可以找到最小的 $l$ 和最大的 $r$ 满足 $l \le \mathrm{rank}_{lb_i} \le r$，且 $\mathrm{LCP}(\mathrm{SA}_l, \mathrm{SA}_r) \ge rb_i - lb_i + 1$，此时 $B_i$ 就是 $\mathrm{SA}_l\dots\mathrm{SA}_r$ 这些后缀的前缀。而由于 $\rm 80pts$ 满足 $|A_i| \ge |B_j|$，所以只要 $l \le \mathrm{rank}_{la_j} \le r$，$B_i$ 就是 $A_j$ 的前缀。于是求出后缀数组后，第二类边相当于一个 B 串连向一个区间，可以使用线段树优化建图。时间复杂度 $O(n \log n)$（$n$ 与题目中 $|S|,n_a,n_b$ 同阶，下同）。

考虑由此做法扩展 $\rm 100pts$ 的做法。

此做法不能拿到 $\rm 100pts$ 的原因为，可能存在 $|B_i| \gt |A_j|$ 而 $B_i$ 向 $A_j$ 连边的情况。为了解决这个问题，我们把线段树改成可持久化线段树。按照 A 串的长度从大到小建立可持久化线段树，每个 A 串只在相应长度加入。B 串连边的区间也是 B 串长度的历史版本上的。这样就可以保证 $|B_i| \le |A_j|$ 时 $B_i$ 才会向 $A_j$ 连边了。时空复杂度都是 $O(n \log n)$。

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>

const int maxN = 200005, maxV = 5000005;

char S[maxN];
int Na, La[maxN], Ra[maxN], Nb, Lb[maxN], Rb[maxN], N, M;
int SA[maxN], Rank[maxN], ST[18][maxN], Lg[maxN];

void getSA()
{
	static int buffer[maxN];
	for (int i = 1; i <= N; ++i)
		++buffer[S[i]];
	for (int i = 1; i <= 255; ++i)
		buffer[i] += buffer[i - 1];
	for (int i = 1; i <= N; ++i)
		SA[buffer[S[i]]--] = i;
	Rank[SA[1]] = 1;
	for (int i = 2; i <= N; ++i)
		Rank[SA[i]] = S[SA[i - 1]] == S[SA[i]] ? Rank[SA[i - 1]] : Rank[SA[i - 1]] + 1;
	std::fill(buffer + 1, buffer + 1 + 255, 0);

	for (int l = 1; Rank[SA[N]] != N; l <<= 1)
	{
		static int temp[maxN];
		int cnt = 0;

		for (int i = 1; i <= l; ++i)
			temp[++cnt] = N - i + 1;
		for (int i = 1; i <= N; ++i)
			if (SA[i] > l)
				temp[++cnt] = SA[i] - l;
		for (int i = 1; i <= N; ++i)
			++buffer[Rank[i]];
		for (int i = 1; i <= N; ++i)
			buffer[i] += buffer[i - 1];
		for (int i = N; i; --i)
			SA[buffer[Rank[temp[i]]]--] = temp[i];
		std::copy(Rank + 1, Rank + 1 + N, temp + 1);
		std::fill(buffer + 1, buffer + 1 + N, 0);
		Rank[SA[1]] = 1;
		for (int i = 2; i <= N; ++i)
			Rank[SA[i]] = SA[i] + l <= N && SA[i - 1] + l <= N && temp[SA[i - 1]] == temp[SA[i]] && temp[SA[i - 1] + l] == temp[SA[i] + l] ? Rank[SA[i - 1]] : Rank[SA[i - 1]] + 1;
	}

	for (int i = 1, h = 0; i <= N; ++i)
	{
		if (h)
			--h;
		if (Rank[i] == 1)
			continue;
		while (S[i + h] == S[SA[Rank[i] - 1] + h])
			++h;
		ST[0][Rank[i]] = h;
	}
	Lg[0] = -1;
	for (int i = 1; i <= N; ++i)
		Lg[i] = Lg[i >> 1] + 1;
	for (int i = 1; i <= Lg[N]; ++i)
		for (int j = 1; j + (1 << i) - 1 <= N; ++j)
			ST[i][j] = std::min(ST[i - 1][j], ST[i - 1][j + (1 << (i - 1))]);
}

std::vector<int> G[maxV], A[maxN];
int Val[maxV], Deg[maxV];

const size_t _M_size = 500 << 20;
char _M_pool[_M_size], *_M_cur(_M_pool + _M_size);
inline void *operator new(size_t size) { return _M_cur -= size; }
inline void operator delete(void *) {}

inline void addEdge(int u, int v)
{
	++Deg[v];
	G[u].push_back(v);
}

int tot;
struct node
{
	int id;
	node *lc, *rc;
	node(int _id) : id(_id), lc(nullptr), rc(nullptr) {}
} * root[maxN];

int insert(node *&o, int l, int r, int pos)
{
	if (!o)
	{
		o = new node(++tot);
		std::vector<int>().swap(G[tot]);
		Val[tot] = 0, Deg[tot] = 0;
	}
	else
	{
		o = new node(*o);
		++tot;
		std::vector<int>().swap(G[tot]);
		addEdge(tot, o->id);
		o->id = tot;
		Val[tot] = 0, Deg[tot] = 0;
	}
	if (l == r)
		return o->id;
	int m = (l + r) >> 1, res;
	if (pos <= m)
		res = insert(o->lc, l, m, pos);
	else
		res = insert(o->rc, m + 1, r, pos);
	if (o->lc)
		addEdge(o->id, o->lc->id);
	if (o->rc)
		addEdge(o->id, o->rc->id);
	return res;
}

void linkEdge(node *o, int l, int r, int tl, int tr, int s)
{
	if (!o)
		return;
	if (l >= tl && r <= tr)
	{
		addEdge(s, o->id);
		return;
	}
	int m = (l + r) >> 1;
	if (tl <= m)
		linkEdge(o->lc, l, m, tl, tr, s);
	if (tr > m)
		linkEdge(o->rc, m + 1, r, tl, tr, s);
}

int Que[maxV];
long long F[maxV];

void work()
{
	_M_cur = _M_pool + _M_size;

	scanf("%s", S + 1);
	N = std::strlen(S + 1);
	scanf("%d", &Na);
	for (int i = 1; i <= Na; ++i)
		scanf("%d%d", La + i, Ra + i);
	scanf("%d", &Nb);
	for (int i = 1; i <= Nb; ++i)
		scanf("%d%d", Lb + i, Rb + i);

	getSA();

	tot = Na + Nb;
	for (int i = 1; i <= tot; ++i)
		std::vector<int>().swap(G[i]), Val[i] = 0, Deg[i] = 0;

	for (int i = 1; i <= N; ++i)
		std::vector<int>().swap(A[i]);

	for (int i = 1; i <= Na; ++i)
		A[Val[i] = Ra[i] - La[i] + 1].push_back(i);
	root[N + 1] = nullptr;
	for (int i = N; i; --i)
	{
		root[i] = root[i + 1];
		for (auto x : A[i])
			addEdge(insert(root[i], 1, N, Rank[La[x]]), x);
	}
	scanf("%d", &M);
	for (int x, y; M--;)
	{
		scanf("%d%d", &x, &y);
		addEdge(x, y + Na);
	}

	for (int i = 1; i <= Nb; ++i)
	{
		int lb = Rank[Lb[i]], rb = Rank[Lb[i]], len = Rb[i] - Lb[i] + 1;
		int d;
		for (d = 0; lb - (1 << d) >= 1 && ST[d][lb - (1 << d) + 1] >= len; ++d)
			;
		for (--d; ~d; --d)
			if (lb - (1 << d) >= 1 && ST[d][lb - (1 << d) + 1] >= len)
				lb -= 1 << d;
		for (d = 0; rb + (1 << d) <= N && ST[d][rb + 1] >= len; ++d)
			;
		for (--d; ~d; --d)
			if (rb + (1 << d) <= N && ST[d][rb + 1] >= len)
				rb += 1 << d;
		linkEdge(root[len], 1, N, lb, rb, Na + i);
	}

	int *qs = Que, *qe = Que;
	for (int i = 1; i <= tot; ++i)
		if (!Deg[i])
			*qe++ = i;

	while (qs != qe)
	{
		int i = *qs++;
		for (auto to : G[i])
			if (!--Deg[to])
				*qe++ = to;
	}

	if (qe - Que != tot)
	{
		puts("-1");
		return;
	}

	for (int j = tot - 1; ~j; --j)
	{
		int i = Que[j];
		F[i] = Val[i];
		for (auto to : G[i])
			F[i] = std::max(F[i], F[to] + Val[i]);
	}

	printf("%lld\n", *std::max_element(F + 1, F + 1 + Na));
}

int main()
{
	int T;

	for (scanf("%d", &T); T--;)
		work();

	return 0;
}
```

---

## 作者：小粉兔 (赞：17)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/SHOI2019D1T2.html](https://www.cnblogs.com/PinkRabbit/p/SHOI2019D1T2.html)。

### 题意简述：

给定一个长度为 $n$ 的母串 $S$。

有 $n_a$ 个 A 类串，都是 $S$ 的子串，以区间的形式给出。

有 $n_b$ 个 B 类串，都是 $S$ 的子串，以区间的形式给出。

有 $m$ 个支配关系，形式为第 $i$ 个 A 类串支配第 $j$ 个 B 类串。

你需要求出最长的字符串 $T$ 的长度，使得 $T$ 可以被划分为若干个 A 类串的拼接，并且相邻两个 A 类串 $t_i$ 和 $t_{i+1}$ 满足 $t_i$ 支配某个 B 类串 $j$，而 $j$ 是 $t_{i+1}$ 的前缀。

如果 $T$ 可以无限长，输出 `-1`。

### 题解：

如果我们设法从每个 B 类串向存在前缀为这个 B 类串的 A 类串连边，则显然若有环则答案可以无限大，若无环则可以做一遍 DAG DP 得到答案。

然而我们并不能直接实现这一过程，且不论能否快速确定前缀从属关系，这类边的条数就能达到 $\mathcal{O}(n_an_b)$ 级别。

当边数太多时，首先应该想到的就是数据结构优化建边，典型的例子是树状结构优化建边，例如线段树和后缀树。

实际上这题可以直接使用后缀树优化建边，边数只有线性级别，但是过程还是 $\mathcal{O}(n\log n)$ 的。至于建后缀树可以直接建也可以对反串建 SAM。

对于我这种不会后缀树，SAM 理解也不深的菜兔，还是选择了后缀数组。

首先建出后缀数组，这个大家都会。然后对每个 B 类串考虑如何连边。

假设我们已经对每个 A 类和 B 类串在母串上定位了，那么包含某个 B 类串作为前缀的 A 类串需要满足两个条件：  
该 A 串的左端点对应的后缀和 B 串的左端点对应的后缀的 LCP 长度应该大于 B 串的长度，并且该 A 串的长度也应该大于 B 串的长度。

第一个条件可以转化为对应着后缀数组上的一段区间，具体根据 Height 数组确定，这一步建出 ST 表后二分可以在 $\mathcal{O}(\log n)$ 的时间内解决。

第二个条件似乎没有什么巧妙的办法。不过我们可以考虑按照长度从大到小的顺序加入每个串，这样就能够扔掉第二个限制了。

所以具体的思路就是按照长度从大到小排序插入 A 类串，在 B 类串和数据结构之间建边，使用合适的数据结构维护历史版本和区间。

很显然，主席树便是合适的数据结构，主席树优化建边，树内边数 $\mathcal{O}(n_a\log n)$，树外边数 $\mathcal{O}(n_b\log n)$。

接下来是代码，复杂度 $\mathcal{O}((n+n_a+n_b)\log n)$：

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>

typedef long long LL;
const int MN = 200005;
const int MS = 4200005;

char str[MN];
int N, Sig, rk[MN], SA[MN], SA2[MN], buk[MN], tmp[MN];
int Height[MN];
inline void getHeight() {
	for (int i = 1, k = 0; i <= N; ++i) {
		if (rk[i] == 1) { Height[rk[i]] = k = 0; continue; }
		if (k) --k;
		int j = SA[rk[i] - 1];
		while (i + k <= N && j + k <= N && str[i + k] == str[j + k]) ++k;
		Height[rk[i]] = k;
	}
}
inline void RSort() {
	for (int i = 1; i <= Sig; ++i) buk[i] = 0;
	for (int i = 1; i <= N; ++i) ++buk[rk[i]];
	for (int i = 1; i <= Sig; ++i) buk[i] += buk[i - 1];
	for (int i = N; i >= 1; --i) SA[buk[rk[SA2[i]]]--] = SA2[i];
}
inline void getSA(char *str) {
	Sig = 127, rk[N + 1] = 0;
	for (int i = 1; i <= N; ++i) rk[i] = str[i], SA2[i] = i;
	RSort();
	for (int j = 1; j <= N; j <<= 1) {
		int p = 0;
		for (int i = N - j + 1; i <= N; ++i) SA2[++p] = i;
		for (int i = 1; i <= N; ++i) if (SA[i] > j) SA2[++p] = SA[i] - j;
		RSort();
		tmp[SA[1]] = p = 1;
		for (int i = 2; i <= N; ++i) {
			int lst = SA[i - 1], now = SA[i];
			if (rk[lst] != rk[now] || rk[lst + j] != rk[now + j]) ++p;
			tmp[SA[i]] = p;
		}
		for (int i = 1; i <= N; ++i) rk[i] = tmp[i];
		if ((Sig = p) == N) break;
	}
	getHeight();
}

int Lg[MN];
inline void Log(int N) {
	Lg[0] = -1;
	for (int i = 1; i <= N; ++i) Lg[i] = Lg[i >> 1] + 1;
}
int ST[MN][18];
inline void InitST() {
	for (int i = 2; i <= N; ++i) ST[i][0] = Height[i];
	for (int j = 1; j <= Lg[N - 1]; ++j) {
		for (int i = 1; i <= 1 << j; ++i) ST[i][j] = 0;
		for (int i = 1 << j | 1; i <= N; ++i)
			ST[i][j] = std::min(ST[i - (1 << (j - 1))][j - 1], ST[i][j - 1]);
	}
}

int NA, la[MN], ra[MN];
int NB, lb[MN], rb[MN];
struct sub {
	int lb, len, typ, id;
	sub() {}
	sub(int lb, int len, int typ, int id) : lb(lb), len(len), typ(typ), id(id) {}
	inline friend bool operator <(sub i, sub j) {
		return i.len == j.len ? i.typ < j.typ : i.len > j.len;
	}
} substrs[MN * 2];

int d[MS];
std::vector<int> G[MS];
inline void addEdge(int x, int y) { ++d[y]; G[x].push_back(y); }

int rt[MN], lc[MS], rc[MS], wgh[MS], cnt;
void Mdf(int &rt, int l, int r, int p, int x) {
	lc[++cnt] = lc[rt], rc[cnt] = rc[rt];
	if (rt) addEdge(cnt, rt);
	wgh[rt = cnt] = 0;
	if (l == r) { addEdge(rt, x); return ; }
	int mid = (l + r) >> 1;
	if (p <= mid) Mdf(lc[rt], l, mid, p, x), addEdge(rt, lc[rt]);
	else Mdf(rc[rt], mid + 1, r, p, x), addEdge(rt, rc[rt]);
}
void Edg(int rt, int l, int r, int a, int b, int x) {
	if (!rt || r < a || b < l) return ;
	if (a <= l && r <= b) { addEdge(x, rt); return ; }
	int mid = (l + r) >> 1;
	Edg(lc[rt], l, mid, a, b, x);
	Edg(rc[rt], mid + 1, r, a, b, x);
}

int que[MS], l, r;
LL f[MS];

int main() {
	int T; scanf("%d", &T);
	Log(200000);
	while (T--) {
		scanf("%s", str + 1);
		N = strlen(str + 1);
		getSA(str);
		InitST();
		scanf("%d", &NA);
		for (int i = 1; i <= NA; ++i)
			scanf("%d%d", &la[i], &ra[i]),
			substrs[i] = sub(rk[la[i]], ra[i] - la[i] + 1, 0, i);
		scanf("%d", &NB);
		for (int i = 1; i <= NB; ++i)
			scanf("%d%d", &lb[i], &rb[i]),
			substrs[NA + i] = sub(rk[lb[i]], rb[i] - lb[i] + 1, 1, i);
		std::sort(substrs + 1, substrs + NA + NB + 1);
		cnt = NA + NB;
		for (int i = 1; i <= NA; ++i) wgh[i] = ra[i] - la[i] + 1;
		for (int i = 1; i <= NB; ++i) wgh[NA + i] = 0;
		for (int i = 1, gen = 0; i <= NA + NB; ++i) {
			sub p = substrs[i];
			if (!p.typ) ++gen, Mdf(rt[gen] = rt[gen - 1], 1, N, p.lb, p.id);
			else {
				int Lb = p.lb, Rb = p.lb;
				for (int j = Lg[p.lb - 1]; ~j; --j)
					if (ST[Lb][j] >= p.len) Lb -= 1 << j;
				for (int j = Lg[N - p.lb]; ~j; --j)
					if (Rb + (1 << j) <= N && ST[Rb + (1 << j)][j] >= p.len) Rb += 1 << j;
				Edg(rt[gen], 1, N, Lb, Rb, NA + p.id);
			}
		}
		int M; scanf("%d", &M);
		for (int i, j; M--; ) {
			scanf("%d%d", &i, &j);
			addEdge(i, NA + j);
		}
		LL Ans = 0;
		l = 1, r = 0;
		for (int i = 1; i <= cnt; ++i) {
			f[i] = wgh[i];
			if (!d[i]) que[++r] = i;
		}
		while (l <= r) {
			int u = que[l++];
			Ans = std::max(Ans, f[u]);
			for (auto v : G[u]) {
				f[v] = std::max(f[v], f[u] + wgh[v]);
				if (!--d[v]) que[++r] = v;
			}
		}
		if (r != cnt) puts("-1");
		else printf("%lld\n", Ans);
		for (int i = 1; i <= cnt; ++i) d[i] = 0, G[i].clear();
	}
	return 0;
}
```

实际上，同样是后缀数组预处理，关于建边有更好的方法，比如用后缀数组建出后缀树，然后在后缀树上乱搞建边，这样是线性的。

---

## 作者：cosmicAC (赞：7)

下面是我的后缀数组解法。

首先考虑前80分的做法，和其他所有题解一样，是要把“T的分割中，y可作为x的后一个串”这个关系用有向图表示出来，然后只要判断是不是DAG。如果是那么跑最长路，否则-1。这里判DAG其实可以和求拓扑序一起做，如果跑完拓扑序之后还有未到达的点的话就不是DAG。

然后考虑建图方法。枚举一个A串，枚举被A串支配的所有B串，由于前80分中的$\forall{i,j},|A_i|\ge|B_j|$限制，"存在一个前缀是B的串组成的集合"是后缀数组上的一个区间，起始点在区间中的所有A串都是合法的。只要对这个区间中所有的A串连边即可。找区间的时候可以在height数组上建ST表倍增（或二分），复杂度都是一个log的。

然后是建边，暴力建边的话边数是$n^2$级别的肯定不行。然而可以利用ST表建边，比如区间是$[l,r]$，$k=\lfloor\log_2{(r-l+1)}\rfloor$，就向表示$[l,l+2^k),[r+1-2^k,r]$的两个点连边即可。这样就可以得到80分。

然后是满分算法。可以看出，唯一的区别是开始位置相同的一些A串中，只有较长的一部分串可以连边。这就是二维偏序了，我在考场上以为要树套树所以不可做。后来发现用不着，可以交换一下两维，使得第一维是A串长度，第二维是A串开始位置的rank。这样第一维就变成了前缀，所以可以用主席树优化建图，点数和边数的规模都是一个log的。

可惜由于常数远大于SAM，洛谷过不去。loj上可以通过的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int maxn=200010;
char s[maxn];ll dis[maxn*25];
int n,sa[maxn],nr[maxn*2],rnk[maxn*2],st[maxn][20],hd[maxn*25],p[maxn],ind[maxn*25];
int T,tot,m,na,nb,w[maxn*25],l[maxn],r[maxn],que[maxn*25],rt[maxn],ps[maxn];
struct stt{int l,r,id;}a[maxn];vector<stt> u;
bool operator<(stt a,stt b){return a.r-a.l>b.r-b.l;}
vector<int> v[maxn];
struct edge{int v,nxt;}e[maxn*100];
void adde(int a,int b){e[++m]={b,hd[a]};hd[a]=m;ind[b]++;}
int qry1(int p,int vl){
	for(int k=19;~k;k--)if(p>=1<<k&&st[p-(1<<k)+1][k]>=vl)p-=1<<k;
	return p;
}
int qry2(int p,int vl){
	for(int k=19;~k;k--)if(p+(1<<k)<=n+1&&st[p][k]>=vl)p+=1<<k;
	return p-1;
}
struct segTree{
	int L[maxn*25],R[maxn*25];
	void ins(int id,int p,int tl=1,int tr=n){
		if(tl==tr){adde(++tot,p);u.push_back({tot,id});return;}
		int mid=tl+tr>>1;
		if(rnk[a[id].l]<=mid)ins(id,L[p],tl,mid),R[++tot]=R[p],L[tot]=tot-1;
		else ins(id,R[p],mid+1,tr),L[++tot]=L[p],R[tot]=tot-1;
		adde(tot,p),adde(tot,tot-1);
	}
	void add(int l,int r,int x,int p,int tl=1,int tr=n){
		if(l<=tl&&tr<=r){adde(x,p);return;}
		int mid=tl+tr>>1;
		if(l<=mid)add(l,r,x,L[p],tl,mid);
		if(r>mid)add(l,r,x,R[p],mid+1,tr);
	}
}tr;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%s",s+1);n=strlen(s+1);
		memset(nr,0,sizeof nr),memset(rnk,0,sizeof rnk);
		for(int i=1;i<=n;i++)rnk[i]=s[i],sa[i]=i;
		for(int i=1;i<=n;i<<=1){
			sort(sa+1,sa+1+n,[&](int a,int b){
				return rnk[a]<rnk[b]||rnk[a]==rnk[b]&&rnk[a+i]<rnk[b+i];
			});
			for(int j=1,t=0;j<=n;nr[sa[j++]]=t)
				t+=rnk[sa[j]]!=rnk[sa[j-1]]||rnk[sa[j]+i]!=rnk[sa[j-1]+i];
			memcpy(rnk,nr,sizeof nr);
		}
		for(int i=1,k=0;i<=n;i++){
			if(k)k--;
			for(;s[i+k]==s[sa[rnk[i]-1]+k];k++);
			*st[rnk[i]]=k;
		}
		memset(hd,0,sizeof hd);
		memset(w,0,sizeof w);
		memset(ind,0,sizeof ind);
		tot=m=0;u.clear();
		memset(&tr,0,sizeof tr);
		for(int i=1;(1<<i)<=n;i++)
			for(int j=0;j+(1<<i)<=n+1;j++)
				st[j][i]=min(st[j][i-1],st[j+(1<<i-1)][i-1]);
		scanf("%d",&na);
		for(int i=1;i<=n;i++)v[i].clear();
		for(int i=1;i<=na;i++)
			scanf("%d%d",&a[i].l,&a[i].r),a[i].id=i;
		sort(a+1,a+1+na);
		for(int i=1;i<=na;i++)
			ps[a[i].id]=i,tr.ins(i,rt[i-1]),rt[i]=tot;
		for(int i=1;i<=na;i++)w[p[i]=++tot]=a[i].r-a[i].l+1;
		for(stt&s:u)adde(s.l,p[s.r]);
		scanf("%d",&nb);
		for(int i=1;i<=nb;i++)scanf("%d%d",l+i,r+i);
		int x;scanf("%d",&x);
		for(int i=1;i<=x;i++){
			int x,y;scanf("%d%d",&x,&y);
			v[ps[x]].push_back(y);
		}
		for(int i=1;i<=na;i++)for(int j:v[i]){
			int x=qry1(rnk[l[j]],r[j]-l[j]+1),y=qry2(rnk[l[j]]+1,r[j]-l[j]+1);
			tr.add(x,y,p[i],rt[upper_bound(a+1,a+1+na,stt{l[j],r[j]})-a-1]);
		}
		memset(dis,0,sizeof dis);
		int l=1,r=0;
		for(int i=1;i<=tot;i++)if(!ind[i])que[++r]=i,dis[i]=w[i];
		while(l<=r){
			int p=que[l++];
			for(int x=hd[p];x;x=e[x].nxt){
				dis[e[x].v]=max(dis[e[x].v],dis[p]+w[e[x].v]);
				if(!--ind[e[x].v])que[++r]=e[x].v;
			}
		}
		if(r!=tot+1)puts("-1");else printf("%lld\n",*max_element(dis+1,dis+1+tot));
	}
	return 0;
}
```

---

## 作者：SSerxhs (赞：6)

后缀树优化建图模板题。

首先，“最长单词”与对无限长的判定很明显是一个图论的最长路问题，容易想到转化为图然后拓扑dp。而需要建的边就等同于A串向B串按支配关系连边而B串向以其为前缀的A串连边，这样任意两个相连的A串都不重不漏地被考虑到了。

考虑建出后缀树，并将AB串在后缀树上定位（定位：即从根出发匹配），然后直接A串连B串即可，而后缀树本身的树边就是B串连向A串的边。暴力从根匹配定位是肯定TLE的，考虑需要匹配的都是原串的子串$[l,r]$，则我们可以考虑定位所有后缀位置$ys[n]$（这个可以通过看叶子节点的深度实现），则需要定位的点可以直接从$ys[r]$向上倍增找到。

然而，找到的点可能是被压缩的路径上的一个点，这时候我们需要拆边，类似于有活跃半径时的失配情况，把$a->b$拆为$a->c->b$即可。建图完成后跑一遍最长路即可。

细节：

1.虽然只有一个串，但用ukk建图的还是要在最后加特殊字符

2.拆边时为了方便建议按照长度从大到小排序加入，注意特判两个串匹配到同一个新增节点情况

3.最长路的结束点只能是A串的定位点，不能用任意叶子

4.A向B的连边长度不是0，而是B的深度

代码如下

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=2e5+10,Q=4e5+10,M=8e5+10,O=1e6+10,P=7e7;
char cc[P+10];
ll g[M],ans;
int t[M],f[M],zd[M],c[M][27],fa[M],lj[O],nxt[O],fir[M],s[M],rd[M],dl[M],bz[M][20],ub[M];
int len[O],dep[M],la[N],ra[N],lb[N],rb[N],pos[Q],cd[Q],id[Q],ys[N],lf[O],eg[Q];
int posa[N],posb[N];
int n,m,na,nb,bs,fbs,ds,ad,point,r,edge,remain,T,dtp,tou,wei,i,j,x,y;
inline void read(int &x)
{
	++dtp;
	while ((cc[dtp]<48)||(cc[dtp]>57)) ++dtp;
	x=cc[dtp++]^48;
	while ((cc[dtp]>=48)&&(cc[dtp]<=57)) x=x*10+(cc[dtp++]^48);
}
inline void add(int x,int y)
{
	lj[++fbs]=y;
	nxt[fbs]=fir[x];
	fir[x]=fbs;
}
inline void add(int x,int y,int z)
{
	lj[++fbs]=y;
	len[fbs]=z;
	nxt[fbs]=fir[x];
	fir[x]=fbs;
}
inline void add(int a,int b,int cc,int d)
{
	zd[++bs]=b;
	t[bs]=d;
	f[bs]=cc;
	c[a][s[cc]]=bs;
}
void qs(int l,int r)
{
	int i=l,j=r,m=cd[l+r>>1];
	while (i<=j)
	{
		while (cd[i]>m) ++i;
		while (cd[j]<m) --j;
		if (i<=j)
		{
			swap(cd[i],cd[j]);
			swap(eg[i],eg[j]);
			swap(pos[i],pos[j]);
			swap(id[i++],id[j--]);
		}
	}
	if (i<r) qs(i,r);
	if (l<j) qs(l,j);
}
int main()
{
	x=fread(cc+1,1,P,stdin);cc[x+1]=0;;
	read(T);
	while (T--)
	{
		memset(g+1,0,ds<<3);
		memset(rd+1,0,ds<<2);
		memset(fir+1,0,ds<<2);
		ds=tou=point=fa[1]=1;n=r=fbs=bs=remain=wei=0;
		++dtp;
		while ((cc[dtp]<'a')||(cc[dtp]>'z')) ++dtp;
		while ((cc[dtp]>='a')&&(cc[dtp]<='z')) s[++n]=cc[dtp++]-'a';
		s[++n]=26;
		for (i=1;i<=n;i++)
		{
			++remain;ad=0;
			while (remain)
			{
				if (r==0) edge=i;
				if ((j=c[point][s[edge]])==0)
				{
					fa[ad]=point;
					fa[++ds]=1;
					add(point,ad=ds,edge,n);
					add(point,s[edge]);
				}
				else
				{
					if ((t[j]!=n)&&(t[j]-f[j]+1<=r))
					{
						r-=t[j]-f[j]+1;
						point=zd[j];
						edge+=t[j]-f[j]+1;
						continue;
					}
					if (s[f[j]+r]==s[i]) {++r;fa[ad]=point;break;}
					fa[fa[ad]=++ds]=1;
					add(ad=ds,zd[j],f[j]+r,t[j]);add(ds,s[f[j]+r]);
					zd[j]=ds;t[j]=f[j]+r-1;
					add(ds,s[i]);fa[++ds]=1;add(ds-1,ds,i,n);
				}
				--remain;
				if ((r)&&(point==1))
				{
					--r;
					edge=i-remain+1;
				} else point=fa[point];
			}
		}
		for (i=1;i<=ds;i++) for (j=fir[i];j;j=nxt[j])
		{
			x=c[i][lj[j]];
			if (t[x]==n) --t[x];
			len[j]=t[x]-f[x]+1;
			lj[j]=zd[x];
		}
		memset(c+1,0,108*ds);
		dl[tou=wei=1]=1;--n;
		while (tou<=wei)
		{
			x=dl[tou++];
			for (i=1;bz[x][i-1];i++) bz[x][i]=bz[bz[x][i-1]][i-1];
			ub[x]=i-2;
			if (!fir[x]) {ys[dep[x]]=x;continue;}
			for (i=fir[x];i;i=nxt[i])
			{
				dep[lj[i]]=dep[x]+len[i];
				bz[lj[i]][0]=x;
				lf[lj[i]]=i;
				dl[++wei]=lj[i];
			}
		}
		read(na);
		for (i=1;i<=na;i++) {read(la[i]);read(ra[i]);}
		read(nb);
		for (i=1;i<=nb;i++) {read(lb[i]);read(rb[i]);}
		for (i=1;i<=na;i++)
		{
			x=ys[n-la[i]+1];y=ra[i]-la[i]+1;
			if (dep[x]==y) {if (dep[bz[x][0]]==y) x=bz[x][0];pos[i]=x;;cd[i]=0;id[i]=i;continue;}
			for (j=ub[x];~j;j--) if (dep[bz[x][j]]>y) x=bz[x][j];
			pos[i]=bz[x][0];cd[i]=y-dep[bz[x][0]];id[i]=i;eg[i]=lf[x];
		}
		for (i=1;i<=nb;i++)
		{
			x=ys[n-lb[i]+1];y=rb[i]-lb[i]+1;
			if (dep[x]==y) {if (dep[bz[x][0]]==y) x=bz[x][0];pos[i+na]=x;cd[i+na]=0;id[i+na]=i+na;continue;}
			for (j=ub[x];~j;j--) if (dep[bz[x][j]]>y) x=bz[x][j];
			pos[i+na]=bz[x][0];cd[i+na]=y-dep[bz[x][0]];id[i+na]=i+na;eg[i+na]=lf[x];
		}
		memset(bz+1,0,80*ds);
		qs(1,na+nb);
		for (i=1;i<=na+nb;i++) if (cd[i])
		{
			if (cd[i]==len[eg[i]]) {if (id[i]<=na) posa[id[i]]=lj[eg[i]]; else posb[id[i]-na]=lj[eg[i]];continue;}
			add(++ds,lj[eg[i]],len[eg[i]]-cd[i]);dep[ds]=dep[pos[i]]+cd[i];
			len[eg[i]]=cd[i];lj[eg[i]]=ds;
			if (id[i]<=na) posa[id[i]]=ds; else posb[id[i]-na]=ds;
		} else {if (id[i]<=na) posa[id[i]]=pos[i]; else posb[id[i]-na]=pos[i];}
		read(m);
		while (m--)
		{
			read(x);read(y);add(posa[x],posb[y],dep[posb[y]]);
		}
		for (i=1;i<=fbs;i++) ++rd[lj[i]];
		tou=1;wei=0;
		for (i=1;i<=ds;i++) if (!rd[i]) dl[++wei]=i;
		while (tou<=wei) for (i=fir[x=dl[tou++]];i;i=nxt[i])
		{
			g[lj[i]]=max(g[lj[i]],g[x]+len[i]);
			if (--rd[lj[i]]==0) dl[++wei]=lj[i];
		}
		if (wei!=ds) puts("-1"); else
		{
			ans=0;
			for (i=1;i<=na;i++) ans=max(ans,g[posa[i]]);
			printf("%lld\n",ans);
		}
	}
}
```


---

## 作者：xht (赞：6)

#### 这是一道涵盖了**字符串**、**图论**、**数据结构**三个方面的综合大题。

#### ~~把这道题放在D1T2的人应该拖出去打~~

## 前置芝士

首先，您至少要会**topsort**。

其次，如果您只想拿个暴力分，字符串**Hash**就足够了；如果您想拿满分，**SA**和**SAM**您至少要会一种（本文采用**SA**）。

最后，正解还需要您了解**线段树优化建边**，并在此基础上用主席树实现。

## 暴力算法一

对于测试点1~4，暴力建图，Hash优化，可以拿到40分的高分。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
const int N = 2e5 + 6;
char s[N];
int n, na, la[N], ra[N], nb, lb[N], rb[N], nm, ma[N], mb[N];

namespace Hash {
	const int P = 13331;
	ull h[N], p[N];

	inline void main() {
		p[0] = 1;
		for (int i = 1; i <= n; i++) h[i] = h[i-1] * P + s[i], p[i] = p[i-1] * P;
	}

	inline ull get(int l, int r) {
		return h[r] - h[l-1] * p[r-l+1];
	}
}

namespace Graph {
	vector<int> e[N<<1];
	int a[N<<1], d[N<<1], f[N<<1];
	queue<int> q;

	inline void init() {
		for (int i = 1; i <= na + nb; i++) e[i].clear(), a[i] = d[i] = f[i] = 0;
		for (int i = 1; i <= na; i++) a[i] = ra[i] - la[i] + 1;
	}

	inline void add(int x, int y) {
		e[x].push_back(y), ++d[y];
	}

	inline void topsort() {
		for (int i = 1; i <= na + nb; i++) if (!d[i]) q.push(i);
		while (q.size()) {
			int x = q.front();
			q.pop();
			for (unsigned int i = 0; i < e[x].size(); i++) {
				int y = e[x][i];
				f[y] = max(f[y], f[x] + a[x]);
				if (!--d[y]) q.push(y);
			}
		}
		for (int i = 1; i <= na + nb; i++)
			if (d[i]) {
				puts("-1");
				return;
			}
		ll ans = 0;
		for (int i = 1; i <= na + nb; i++) ans = max(ans, (ll)f[i] + a[i]);
		cout << ans << endl;
	}

	inline void main() {
		Hash::main();
		init();
		for (int i = 1; i <= nm; i++) add(ma[i], mb[i] + na);
		for (int j = 1; j <= nb; j++) {
			ull now = Hash::get(lb[j], rb[j]);
			int len = rb[j] - lb[j];
			for (int i = 1; i <= na; i++)
				if (len < a[i] && Hash::get(la[i], la[i] + len) == now) add(j + na, i);
		}
		topsort();
	}
}

inline void work() {
	scanf("%s", s + 1);
	n = strlen(s + 1);
	scanf("%d", &na);
	for (int i = 1; i <= na; i++) scanf("%d %d", &la[i], &ra[i]);
	scanf("%d", &nb);
	for (int i = 1; i <= nb; i++) scanf("%d %d", &lb[i], &rb[i]);
	scanf("%d", &nm);
	for (int i = 1; i <= nm; i++) scanf("%d %d", &ma[i], &mb[i]);
	Graph::main();
}

int main() {
	int T;
	cin >> T;
	while (T--) work();
	return 0;
}
```

## 暴力算法二

对于测试点1、4、5、6，所有A串的前缀总数是可接受的，全部枚举出来，暴力建图，可以拿到40分的高分。

## 暴力算法三

结合暴力算法一和二，面向数据分治，可以拿到60分的高分。

~~（滑稽~~

## 错误算法

我们对字符串跑一遍**SA**，一个显而易见的事实是，每个 $b$ 串一定会连向**SA**上的一个区间。

线段树优化建图即可。

虽然是错误算法，但可以拿到80分的高分。

## 正确算法

错误算法中有这样一句话：

> 每个 $b$ 串一定会连向**SA**上的一个区间。

但是，显然，如果 $b$ 串长度大于 $a$ 串，那么 $b$ 串一定不会是 $a$ 串的前缀。

因此，每个 $b$ 串一定会连向**SA**上的一个区间中的若干个点。

考虑用主席树代替线段树。

按长度从大到小将 $a$ 串依次插入主席树中。

在大于 $b$ 串长度的主席树历史版本上优化建图。

**下面代码的实现细节参考了小粉兔在[https://www.cnblogs.com/PinkRabbit/p/SHOI2019D1T2.html](https://www.cnblogs.com/PinkRabbit/p/SHOI2019D1T2.html)中的思路，但并不雷同**

```cpp
#include <bits/stdc++.h>
#define ll long long
#define mid ((l + r) >> 1)
using namespace std;
const int N = 2e5 + 6;
char s[N];
int T, n, na, la[N], ra[N], nb, lb[N], rb[N], nm, ma[N], mb[N], tot;
struct Str {
	int l, len, id;
	inline Str() {}
	inline Str(int l, int len, int id) : l(l), len(len), id(id) {}
	inline bool operator < (const Str o) const {
		return (len ^ o.len) ? len > o.len : id < o.id;
	}
} str[N<<1];

namespace SA {
	int m = 26, sa[N], rk[N], tp[N], tx[N], he[N], st[N][20];

	inline void tsort() {
		for (int i = 1; i <= m; i++) tx[i] = 0;
		for (int i = 1; i <= n; i++) ++tx[rk[i]];
		for (int i = 1; i <= m; i++) tx[i] += tx[i-1];
		for (int i = n; i; i--) sa[tx[rk[tp[i]]]--] = tp[i];
	}

	inline bool pd(int i, int w) {
		return tp[sa[i-1]] == tp[sa[i]] && tp[sa[i-1]+w] == tp[sa[i]+w];
	}

	inline void main() {
		for (int i = 1; i <= n; i++) rk[i] = s[i] - 'a' + 1, tp[i] = i;
		tsort();
		for (int w = 1, p = 0; p < n; w <<= 1, m = p) {
			p = 0;
			for (int i = 1; i <= w; i++) tp[++p] = n - w + i;
			for (int i = 1; i <= n; i++) if (sa[i] > w) tp[++p] = sa[i] - w;
			tsort(), swap(rk, tp), rk[sa[1]] = p = 1;
			for (int i = 2; i <= n; i++) rk[sa[i]] = pd(i, w) ? p : ++p;
		}
		int p = 0;
		for (int i = 1; i <= n; i++) {
			if (p) --p;
			int j = sa[rk[i]-1];
			while (s[i+p] == s[j+p]) ++p;
			he[rk[i]] = p;
		}
		for (int i = 1; i <= n; i++) st[i][0] = he[i];
		int w = log(n) / log(2);
		for (int k = 1; k <= w; k++)
			for (int i = 1; i + (1 << k) - 1 <= n; i++)
				st[i][k] = min(st[i][k-1], st[i+(1<<(k-1))][k-1]);
	}

	inline int get(int l, int r) {
		int k = log(r - l + 1) / log(2);
		return min(st[l][k], st[r-(1<<k)+1][k]);
	}
}

namespace Graph {
	vector<int> e[N<<5];
	ll a[N<<5], d[N<<5], f[N<<5];
	queue<int> q;

	inline void add(int x, int y) {
		e[x].push_back(y), ++d[y];
	}

	inline void topsort() {
		for (int i = 1; i <= tot; i++) if (!d[i]) q.push(i);
		while (q.size()) {
			int x = q.front();
			q.pop();
			for (unsigned int i = 0; i < e[x].size(); i++) {
				int y = e[x][i];
				f[y] = max(f[y], f[x] + a[x]);
				if (!--d[y]) q.push(y);
			}
		}
		for (int i = 1; i <= tot; i++)
			if (d[i]) {
				puts("-1");
				return;
			}
		ll ans = 0;
		for (int i = 1; i <= tot; i++) ans = max(ans, f[i] + a[i]);
		printf("%lld\n", ans);
	}
}

namespace Seg {
	struct T {
		int l, r;
	} t[N<<5];
	int rt[N];

	int ins(int o, int l, int r, int x, int k) {
		int p = ++tot;
		t[p] = t[o];
		if (o) Graph::add(p, o);
		if (l == r) Graph::add(p, k);
		else if (x <= mid) Graph::add(p, t[p].l = ins(t[o].l, l, mid, x, k));
		else Graph::add(p, t[p].r = ins(t[o].r, mid + 1, r, x, k));
		return p;
	}

	void add(int p, int l, int r, int L, int R, int k) {
		if (!p || r < L || l > R) return;
		if (L <= l && r <= R) Graph::add(k, p);
		else add(t[p].l, l, mid, L, R, k), add(t[p].r, mid + 1, r, L, R, k);
	}
}

inline void work() {
	scanf("%s", s + 1);
	n = strlen(s + 1);
	SA::main();
	scanf("%d", &na);
	for (int i = 1; i <= na; i++) scanf("%d %d", &la[i], &ra[i]);
	scanf("%d", &nb);
	for (int i = 1; i <= nb; i++) scanf("%d %d", &lb[i], &rb[i]);
	scanf("%d", &nm);
	for (int i = 1; i <= nm; i++) scanf("%d %d", &ma[i], &mb[i]);
	for (int i = 1; i <= na; i++) Graph::a[i] = ra[i] - la[i] + 1;
	for (int i = 1; i <= na; i++) str[i] = Str(la[i], ra[i] - la[i] + 1, i);
	for (int i = 1; i <= nb; i++) str[na+i] = Str(lb[i], rb[i] - lb[i] + 1, na + i);
	sort(str + 1, str + na + nb + 1);
	tot = na + nb;
	int now = 0;
	for (int i = 1; i <= na + nb; i++)
		if (str[i].id <= na) ++now, Seg::rt[now] = Seg::ins(Seg::rt[now-1], 1, n, SA::rk[str[i].l], str[i].id);
		else {
			int k = SA::rk[str[i].l], l = 1, r = k, L, R;
			while (l < r)
				if (SA::get(mid + 1, k) >= str[i].len) r = mid;
				else l = mid + 1;
			L = l, l = k + 1, r = n + 1;
			while (l < r)
				if (SA::get(k + 1, mid) >= str[i].len) l = mid + 1;
				else r = mid;
			Seg::add(Seg::rt[now], 1, n, L, R = l - 1, str[i].id);
		}
	for (int i = 1; i <= nm; i++) Graph::add(ma[i], mb[i] + na);
	Graph::topsort();
	for (int i = 1; i <= tot; i++) Graph::e[i].clear(), Graph::a[i] = Graph::d[i] = Graph::f[i] = 0;
}

int main() {
	cin >> T;
	while (T--) work();
	return 0;
}
```

---

## 作者：csyakuoi (赞：6)

神仙题$orz$。

dalao的题解写得都很简洁，本蒟蒻磨了好久才看懂$orz$。

希望这篇题解能帮助到像我一样的蒟蒻。

#首先，根据题意，构建出图论模型。

把每个$A$类串和每个$B$类串看成一个点，$A$类串点权为其长度，$B$类串点权为$0$。如果$B_j$是$A_i$的前缀，就从$B_j$向$A_i$连一条边，如果$A_i$支配$B_j$，就从$A_i$向$B_j$连一条边。在这张图上从$A_i$走向$B_j$再走向$A_k$，代表$A_i$后紧接着连上$A_k$。

#其次，优化建边

暴力建边复杂度三次方，我们先考虑优化前缀匹配。注意到两个子串的$lcp$（最长公共前缀）就是母串反串的后缀自动机的$parent$树上的$LCA$节点所接受的最长子串（这句话比较长，请确保完全理解后再往下看）。由此，我们可以倍增定位子串，求$LCA$，拿到$40$分的好成绩（时间复杂度$O(n^2logn)$）。

倍增定位子串方法如下：对于每个反串的前缀，记录接受它的节点$id[i]$。定位子串$s[l,r]$时，从$id[r]$往上倍增，找到可接受子串最长长度大于该子串长度，且它的后缀链接指向节点可接受子串最长长度小于该子串长度的节点，该节点就是接受$s[l,r]$的节点。

用以上方法建边会有$m+n_an_b$条边，考虑继续优化。注意到两个串同为另一个串的前缀，一定有一个是另一个的前缀。所以我们对于每个节点，把它接受的子串按长度为第一关键字，从小到大排序，对于长度相同的，先排$B$类串。于是我们可以对于每一个节点，记录$lastB$表示它所接受的最长$B$类串，并从它祖先继承下来的$lastB$向它接受的最短子串连边，最后把它的$lastB$传给它的儿子。对于节点内，我们按顺序访问它接受的每一个子串，并从$lastB$向该子串连边，然后更新$lastB$。可以证明，这样连边，边数是线性的。

#最后，求答案

在这张图上跑最长路得出答案（答案就是最长路，如果有环输出$-1$）。

上代码（上面讲得很清楚了，所以注释不多）：
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define ll long long int

struct Graph{
    拓扑排序求最长路
    int cur_cnt,edge_cnt;
    int fir[400000],val[400000];
    int to[800000],nxt[800000];
    int deg_in[400000];
    ll dp[400000];
    queue<int> q,empty;
    Graph(void){cur_cnt=400000;return;}
    void Clear(void)
    {
        q=empty;
        for(int i=0;i<cur_cnt;i++){
            fir[i]=-1;
            dp[i]=deg_in[i]=0;
        }
        edge_cnt=-1;
        return;
    }
    
    void add(int a,int b)
    {
        deg_in[b]++;
        to[++edge_cnt]=b;
        nxt[edge_cnt]=fir[a];
        fir[a]=edge_cnt;
        return;
    }
    
    ll solve(void)
    {
        ll res=0;
        int p,pp,t=cur_cnt;
        for(int i=0;i<cur_cnt;i++){
            dp[i]=val[i];
            if(deg_in[i]==0){
                q.push(i);
                t--;
            }
        }
        while(q.size()>0){
            p=q.front();
            q.pop();
            res=max(res,dp[p]);
            for(int i=fir[p];i!=-1;i=nxt[i]){
                pp=to[i];
                dp[pp]=max(dp[pp],dp[p]+val[pp]);
                deg_in[pp]--;
                if(deg_in[pp]==0){
                    q.push(pp);
                    t--;
                }
            }
        }
        if(t!=0)
            return -1;
        else return res;
    }
}graph;

int n,na,nb,m,cnt,last;
int len[400005],fa[20][400005];
int ch[26][400005],id[200000];
int Fir[400005],lst[400005];
int To[400005],Nxt[400005];
char str[200000];
void build(void)
{
    建parent树
    for(int i=2;i<=cnt;i++){
        To[i]=i;
        Nxt[i]=Fir[fa[0][i]];
        Fir[fa[0][i]]=i;
    }
    return;
}

struct substr{
    int l,r,ID,pos;
    char type;
}sub[400000],temp;
int start[400005],End[400005];
inline bool comp(substr a,substr b)
{
    排序用
    if(a.pos!=b.pos)
        return a.pos<b.pos;
    if(a.r-a.l==b.r-b.l)
        return a.type=='b';
    return a.r-a.l<b.r-b.l;
}

void clear_SAM(void)
{
    for(int i=1;i<=cnt;i++){
        for(int j=0;j<26;j++)
            ch[j][i]=0;
        Fir[i]=lst[i]=0;
    }
    fa[0][1]=len[1]=0;
    len[0]=-99999999;
    cnt=last=1;
    return;
}
int find(int p,int Len)
{
	子串定位
    for(int i=19;i>=0;i--)
        if(len[fa[i][p]]>=Len)
            p=fa[i][p];
    return p;
}

void dfs(int i)
{
    if(start[i]<End[i]){
        if(lst[fa[0][i]]!=0)
            graph.add(lst[fa[0][i]],sub[start[i]].ID);
        if(sub[start[i]].type=='b')
            lst[i]=sub[start[i]].ID;
        for(int j=start[i]+1;j<End[i];j++){
            temp=sub[j];
            if(lst[i]!=0)
                graph.add(lst[i],temp.ID);
            从lastB向该子串连边
            
            if(temp.type=='b')
                lst[i]=temp.ID;
            更新lastB
        }
    }
    for(int j=Fir[i];j!=0;j=Nxt[j]){
        lst[To[j]]=lst[i];
        dfs(To[j]);
    }
    return;
}

void insert(int c)
{
    int p=last,cur=last=++cnt;
    len[cur]=len[p]+1;
    while(p!=0&&ch[c][p]==0){
        ch[c][p]=cur;
        p=fa[0][p];
    }
    if(p==0)
        fa[0][cur]=1;
    else{
        int d=ch[c][p];
        if(len[d]==len[p]+1)
            fa[0][cur]=d;
        else{
            int clone=++cnt;
            len[clone]=len[p]+1;
            fa[0][clone]=fa[0][d];
            for(int i=0;i<26;i++)
                ch[i][clone]=ch[i][d];
            while(p!=0&&ch[c][p]==d){
                ch[c][p]=clone;
                p=fa[0][p];
            }
            fa[0][d]=fa[0][cur]=clone;
        }
    }
    return;
}

void hahaha(void)
{
    graph.Clear();
    clear_SAM();
    scanf("%s",str);
    n=strlen(str);
    for(int i=n-1;i>=0;i--){
        insert(str[i]-'a');
        id[i]=last;
    }
    for(int i=1;i<20;i++){
        fa[i][0]=0;
        for(int j=1;j<=cnt;j++)
            fa[i][j]=fa[i-1][fa[i-1][j]];
    }
    scanf("%d",&na);
    for(int i=0;i<na;i++){
        scanf("%d%d",&sub[i].l,&sub[i].r);
        sub[i].pos=find(id[sub[i].l-1],sub[i].r-sub[i].l+1);
        graph.val[i]=sub[i].r-sub[i].l+1;
        sub[i].type='a';
        sub[i].ID=i;
    }
    scanf("%d",&nb);
    for(int i=na;i<na+nb;i++){
        scanf("%d%d",&sub[i].l,&sub[i].r);
        sub[i].pos=find(id[sub[i].l-1],sub[i].r-sub[i].l+1);
        graph.val[i]=0;
        sub[i].type='b';
        sub[i].ID=i;
    }
    graph.cur_cnt=na+nb;
    build();
    sort(sub,sub+na+nb,comp);
    End[cnt]=na+nb;
    int p=0;
    for(int i=1;i<=cnt;i++){
        while(sub[p].pos==i)
            p++;
        start[i+1]=End[i]=p;
    }
    找出每个节点接受子串的起始位置，结束位置
    
    dfs(1);
    建图
    
    int x,y;
    scanf("%d",&m);
    while(m--){
        scanf("%d%d",&x,&y);
        graph.add(x-1,na+y-1);
    }
    建图
    printf("%lld\n",graph.solve());
    return;
}

int main(void)
{
    int T;
    scanf("%d",&T);
    while(T--)
        hahaha();
    return 0;
}
```

---

## 作者：TheLostWeak (赞：5)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5284.html )

**大致题意：** 给你一个字符串，从中划出$n_a$个子串作为$A$类串，$n_b$个子串作为$B$类串。已知$m$组支配关系，让你求出一个字符串，使得它由若干$A$类串依次相接组成，且每个$A$类串存在一个被其支配的$B$类串是它的后一个串的前缀。输出最长字符串长度，无限长输出$-1$。

### 核心思路

首先，我们来想一下这题的核心思路应该是什么。

显然，不难想到可以把它看成一张$DAG$，则每个$A$类串向其支配的$B$类串连边，每个$B$类串向以其为前缀的$A$类串连边。每个$A$类串权值为自身长度，每个$B$类串权值为$0$，最后拓扑排序求一遍权值和最大的路径的权值和即为答案。

但这样具体实现起来有些困难。

仔细观察上述内容，可以发现我们共要连两种边：

- 每个$A$类串向其支配的$B$类串连边。
- 每个$B$类串向以其为前缀的$A$类串连边。

其中第一种边边数已知为$m$，可以直接连。

但第二种边该如何处理，就是我们主要讨论的问题。

### 利用后缀数组进行转化

首先，我们对给出的这个字符串建一个[后缀数组](https://www.cnblogs.com/chenxiaoran666/p/SuffixArray.html)。

考虑如果一个$B$类串是一个$A$类串的前缀，则这两个串的$LCP$必然会等于$len_B$。

而移到后缀数组上，就等价于后缀$_{l_B}$与后缀$_{l_A}$的$LCP\ge len_B$。

又因为关于$LCP$的一个定理：$LCP(i,j)=min_{k=i+1}^jLCP(k,k-1)$，所以后缀$_{l_B}$在后缀排序后与其他后缀的$LCP$是**向左右两侧递减**的。

而后缀$_{l_B}$在后缀排序后的位置是$rk_{l_B}$，因此我们考虑在$1\sim rk_{l_B}$和$rk_{l_B}\sim n$两个范围内各二分求出离$l_B$最远且满足与后缀$_{l_B}$的$LCP\ge len_B$的位置$L,R$。

那么，我们就要从这个$B$类串向$[L,R]$区间内所有点连边。

这看起来似乎可以直接**线段树优化建图**。

但是，我们要考虑，当$A$类串与$B$类串的长度满足$|A|<|B|$时，这个$B$类串是不能算作这个$A$类串的前缀的！

问题一下棘手了许多。

因此，就需要**主席树优化建图**了。

### 主席树优化建图

关于主席树，可以看这篇博客：[可持久化专题（一）——浅谈主席树：可持久化线段树](https://www.cnblogs.com/chenxiaoran666/p/ChairmanTree.html)。

我们考虑，以**字符串的长度**为版本建主席树。

对于$A$类串，从它在版本$len_A$的树中其$rk$值对应的节点向其连一条边。

对于$B$类串，从它向版本$len_B$的树中$[L,R]$内的节点连边（注意这里可以采取类似懒惰标记的形式向区间连边，使得边数被控制在$2*logN$）。

主席树与主席树之间，我们按$len$从大到小建树，然后同一个位置上的节点每次从$len$小的向$len$大的连边（因为我们要$|A|\ge|B|$，所以只能向$|A|$更大的走）。

同一棵主席树上，我们从父节点向子节点连边。

再加上之前提到过的每个$A$类串向其支配的$B$类串连边，建图就完成了。

### 复杂度分析

最后我们来分析一下复杂度，由于$|S|,na,nb,m$全部同阶，我们用$N$来替代它们。

- 点数：$A$类串个数$N+B$类串个数$N+$主席树上点的个数$NlogN=2N+NlogN$。
- 边数：$A$类串向$B$类串$N+$主席树向$A$类串$N+B$类串向主席树$2NlogN+$主席树间$NlogN+$主席树上$NlogN=2N+4NlogN$。
- 时间复杂度：$O(TNlogN)$。

具体实现详见代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 200000
#define Log 20
#define LL long long
#define min(x,y) ((x)<(y)?(x):(y))
#define Gmax(x,y) (x<(y)&&(x=(y)))
#define add(x,y) (e[++ee].nxt=lnk[x],++deg[e[lnk[x]=ee].to=y])
#define Pt (N*2+N*Log)
#define Et (N*2+N*Log*4)
#define mem(x,v) memset(x,v,sizeof(x))
using namespace std;
int na,nb,m,ee,tot,la[N+5],ra[N+5],lb[N+5],rb[N+5],lnk[Pt+5],deg[Pt+5],q[Pt+5],v[Pt+5];
LL f[Pt+5];struct edge {int to,nxt;}e[Et+5];string s;
struct Pr
{
	int len,id;I Pr(CI x=0,CI y=0):len(x),id(y){}
	I bool operator < (Con Pr& o) Con {return len>o.len;}
}p[N+5];
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
		Tp I void write(Ty x) {x<0&&(pc('-'),x=-x);W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
		Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
		Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
		I void reads(string& x) {x="";W(isspace(c=tc()));W(x+=c,!isspace(c=tc())&&~c);}
		I void clear() {fwrite(FO,1,C,stdout),C=0;} 
}F;
class ChairmanTree//主席树优化建图
{
	private:
		#define L l,mid,O[rt].S[0]
		#define R mid+1,r,O[rt].S[1]
		int n,v,Rt_[N+5],Rt[N+5];struct node {int S[2];}O[Pt+5];
		I int ins(CI l,CI r,int& rt,CI lst,CI x)//插入新节点
		{
			if(O[rt=++tot]=O[lst],lst&&add(rt,lst),!(l^r)) return rt;RI mid=l+r>>1;//向上一个节点连边；返回叶节点编号
			RI g=x<=mid?ins(L,O[lst].S[0],x):ins(R,O[lst].S[1],x);//处理子节点
			return O[rt].S[0]&&add(rt,O[rt].S[0]),O[rt].S[1]&&add(rt,O[rt].S[1]),g;//向子节点建边
		}
		I void adde(CI l,CI r,CI rt,CI p,CI tl,CI tr)//建边
		{
			if(!rt) return;if(tl<=l&&r<=tr) return (void)add(p,rt);RI mid=l+r>>1;//空节点直接返回；建边类似于懒惰标记，向这一区间建边
			tl<=mid&&(adde(L,p,tl,tr),0),tr>mid&&(adde(R,p,tl,tr),0);//处理子节点
		}
	public:
		I void Init(CI x) {n=x;}I void CopyRoot(CI x,CI y) {Rt[x]=Rt[y];}
		I void Clear() {v=0,mem(Rt_,0),mem(Rt,0);for(RI i=1;i<=tot;++i) O[i].S[0]=O[i].S[1]=0;}//清空（注意清空版本数！）
		I int Insert(CI t,CI x) {RI g;return ++v,g=ins(1,n,Rt_[v],Rt_[v-1],x),Rt[t]=Rt_[v],g;}
		I void AddEdge(CI t,CI p,CI l,CI r) {adde(1,n,Rt[t],p,l,r);}
		#undef R
}C;
class SuffixArray//后缀数组
{
	private:
		#define LCP(x,y) (x<y?R.GetMn(x+1,y):R.GetMn(y,x+1))//LCP，注意比较左右边界大小
		int n,SA[N+5],H[N+5],p[N+5],t[N+5];
		class RMQ//区间最值用于求LCP
		{
			private:
				int Lg[N+5],Mn[N+5][Log+5];
			public:
				I void Init(CI x,int *v)
				{
					RI i,j;for(Lg[0]=-1,i=1;i<=x;++i) Mn[i][0]=v[i],Lg[i]=Lg[i>>1]+1;
					for(j=1;(1<<j)<=x;++j) for(i=1;i+(1<<j)-1<=x;++i)
						Mn[i][j]=min(Mn[i][j-1],Mn[i+(1<<j-1)][j-1]);
				}
				I int GetMn(CI l,CI r) {RI k=Lg[r-l+1];return min(Mn[l][k],Mn[r-(1<<k)+1][k]);}
		}R;
		I void Rsort(CI S)//基数排序
		{
			RI i;for(i=0;i<=S;++i) t[i]=0;for(i=1;i<=n;++i) ++t[rk[i]];
			for(i=1;i<=S;++i) t[i]+=t[i-1];for(i=n;i;--i) SA[t[rk[p[i]]]--]=p[i];
		}
		I void GetSA(Con string& s)//求SA数组
		{
			RI i,k,S=122,t=0;for(i=1;i<=n;++i) rk[p[i]=i]=s[i-1];
			for(Rsort(S),k=1;t^n;k<<=1)
			{
				for(S=t,t=0,i=1;i<=k;++i) p[++t]=n-k+i;
				for(i=1;i<=n;++i) SA[i]>k&&(p[++t]=SA[i]-k);
				for(Rsort(S),i=1;i<=n;++i) p[i]=rk[i];
				for(rk[SA[1]]=t=1,i=2;i<=n;++i) rk[SA[i]]=
					(p[SA[i-1]]^p[SA[i]]||p[SA[i-1]+k]^p[SA[i]+k])?++t:t;
			}
		}
		I void GetH(Con string& s)//求Height数组用于LCP
		{
			RI i,j,k=0;for(i=1;i<=n;++i) rk[SA[i]]=i;
			for(i=1;i<=n;++i)
			{
				if(k&&--k,rk[i]==1) continue;j=SA[rk[i]-1];
				W(i+k<=n&&j+k<=n&&!(s[i+k-1]^s[j+k-1])) ++k;H[rk[i]]=k;
			}
		}
	public:
		int rk[N+5];
		I void Init(CI x,Con string& s) {n=x,GetSA(s),GetH(s),R.Init(n,H);}
		I void Work(CI x)//处理第x个B类串
		{
			RI i,t=rk[lb[x]],l1,r1,l2,r2,mid,len=rb[x]-lb[x]+1;
			l1=1,r1=t;W(l1<r1) mid=l1+r1-1>>1,LCP(mid,t)>=len?r1=mid:l1=mid+1;//二分1~t
			l2=t,r2=n;W(l2<r2) mid=l2+r2+1>>1,LCP(t,mid)>=len?l2=mid:r2=mid-1;//二分t~n
			C.AddEdge(len,na+x,r1,l2);//向区间连边
		}
}S;
I LL Topo()//拓扑排序+DP求答案
{
	RI i,k,H=1,T=0;Reg LL ans=0;for(i=1;i<=na;++i) f[i]=v[i]=ra[i]-la[i]+1;//初始化权值
	for(i=1;i<=tot;++i) !deg[i]&&(q[++T]=i);//初始化队列
	W(H<=T) for(i=lnk[k=q[H++]],Gmax(ans,f[k]);i;i=e[i].nxt)//取出队首，统计答案，枚举转移
		Gmax(f[e[i].to],f[k]+v[e[i].to]),!--deg[e[i].to]&&(q[++T]=e[i].to);//转移，判断是否加入队列
	return T^tot?-1:ans;//如果队列中点数与总点数不符，返回-1，否则返回ans
}
int main()
{
	RI Ttot,i,t,x,y,l;F.read(Ttot);W(Ttot--)
	{
		ee=0,mem(lnk,0),mem(deg,0),mem(f,0),mem(v,0),C.Clear(),//注意清空
		F.reads(s),C.Init(l=s.length()),S.Init(l,s);//初始化
		for(F.read(na),i=1;i<=na;++i) F.read(la[i],ra[i]),p[i]=Pr(ra[i]-la[i]+1,i);//读入，将每个A类串按长度和编号存下来
		for(F.read(nb),tot=na+nb,sort(p+1,p+na+1),t=1,i=l;i;--i)//排序，枚举版本
		{
			C.CopyRoot(i,i+1);W(t<=na&&p[t].len==i)//建该版本的树
				x=C.Insert(p[t].len,S.rk[la[p[t].id]]),add(x,p[t].id),++t;//建完后记得连边
		}
		for(i=1;i<=nb;++i) F.read(lb[i],rb[i]),S.Work(i);//处理B类串
		for(F.read(m),i=1;i<=m;++i) F.read(x,y),add(x,na+y);F.writeln(Topo());//根据支配关系连边，然后输出答案
	}return F.clear(),0;
}
```

---

## 作者：asuldb (赞：5)

[题目](https://www.luogu.org/problemnew/show/P5284)

其实是一道熟练的套路题啊

首先$SA$做这道题是肯定可以的，我们二分+$St$表就可以求出每一个$B$串的扩展区间(就是这个区间内的后缀和这个串的$lcp$都大于等于这个串的长度)，之后直接主席树优化建图就好了

之后就会收获$TLE$的好成绩

显然我们并不需要那么麻烦，我们发现$SAM$的$parent$是一个天然的树形结构，可以直接用来帮助我们优化建图

于是我们可以直接在$SAM$上利用树上倍增直接定位好子串，对于每一个$A$串，向对应的$B$串连边就好了，边权就是$A$串的长度

之后一波码码码就会发现过不了第三个样例，调一调发现有一些子串定位在一起了

于是考虑我们舍弃后缀自动机的最小性，我们考虑对于每一个被定位了多次的位置拆出多个点来，毕竟$SAM$上一个节点代表的本来也就不是一个子串

之后按照上面的方式建图跑一波拓扑排序就够了

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<set>
#define re register
#define mp std::make_pair
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=4e5+16;
typedef std::pair<int,int> pii;
std::set<pii> s;
inline int read() {
	char c=getchar();int x=0;while(c<'0'||x>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
struct E{int v,nxt,w;}e[maxn<<1];
int T,n,m,lst,cnt,num,K,tmp;
char S[maxn>>1];
int pos[maxn>>1];
int l[maxn],r[maxn],p[maxn],deep[maxn],lg[maxn>>1],g[maxn];
int len[maxn],son[maxn][26],fa[maxn],A[maxn],f[maxn][20],head[maxn<<1];
int c[maxn<<1],tax[maxn>>1],q[maxn<<1],a[maxn<<1];
std::vector<pii> d[maxn];
std::vector<int> v[maxn];
LL ans,dp[maxn<<1];
inline void add(int x,int y,int w) {
	e[++num].v=y;e[num].nxt=head[x];
	head[x]=num;c[y]++;e[num].w=w;
}
inline void ins(int c,int o) {
	int p=++cnt,f=lst;lst=p;
	len[p]=len[f]+1,pos[o]=p;
	while(f&&!son[f][c]) son[f][c]=p,f=fa[f];
	if(!f) {fa[p]=1;return;}
	int x=son[f][c];
	if(len[x]==len[f]+1) {fa[p]=x;return;}
	int y=++cnt;
	len[y]=len[f]+1,fa[y]=fa[x],fa[p]=fa[x]=y;
	for(re int i=0;i<26;i++) son[y][i]=son[x][i];
	while(f&&son[f][c]==x) son[f][c]=y,f=fa[f];
}
inline void Pre(int L) {
	for(re int i=1;i<=cnt;i++) tax[len[i]]++;
	for(re int i=1;i<=L;i++) tax[i]+=tax[i-1];
	for(re int i=cnt;i;--i) A[tax[len[i]]--]=i;
	for(re int i=1;i<=cnt;i++) {
		int x=A[i];
		deep[x]=deep[fa[x]]+1;
		v[fa[x]].push_back(x);
	}
	for(re int i=1;i<=L;i++) tax[i]=0;
}
inline int jump(int x,int l) {
	for(re int j=lg[deep[x]];j>=0;--j) 
	if(len[f[x][j]]>=l) x=f[x][j];
	pii t=mp(x,l);
	if(s.find(t)==s.end()) g[x]++,s.insert(t);
	return x;
}
void dfs(int x,int fa) {
	if(fa) add(fa,x,0);
	int h=0;
	std::sort(d[x].begin(),d[x].end());
	if(d[x].size()) {
		p[d[x][0].second]=x;
		for(re int i=1;i<d[x].size();i++) {
			if(d[x][i].first!=d[x][i-1].first) {h=i;break;}
			p[d[x][i].second]=x;
		}
	}
	int pre=x;
	while(g[x]>1) {
		++cnt;g[x]--;
		p[d[x][h].second]=cnt;
		for(re int i=h+1;i<d[x].size();i++) {
			if(d[x][i].first!=d[x][i-1].first) {h=i;break;}
			p[d[x][i].second]=cnt;
		}
		add(pre,cnt,0);pre=cnt;
	}
	for(re int i=0;i<v[x].size();i++) dfs(v[x][i],pre);
}
int main() {
	T=read();
	for(re int i=2;i<=200005;i++) lg[i]=lg[i>>1]+1;
	while(T--) {
		s.clear();
		for(re int i=1;i<=cnt;i++) deep[i]=head[i]=c[i]=a[i]=dp[i]=0;
		for(re int i=1;i<=tmp;i++) v[i].clear(),d[i].clear();
		for(re int i=1;i<=tmp;i++) memset(son[i],0,sizeof(son[i])),fa[i]=0,g[i]=0;
		num=0;lst=cnt=1;
		scanf("%s",S+1);int L=strlen(S+1);
		for(re int i=L;i;--i) ins(S[i]-'a',i);
		Pre(L);
		for(re int i=2;i<=cnt;i++) 
			f[i][0]=fa[i];
		for(re int j=1;j<=lg[L];j++)
			for(re int i=2;i<=cnt;i++) 
				f[i][j]=f[f[i][j-1]][j-1];
		n=read();
		for(re int i=1;i<=n;i++) 
			l[i]=read(),r[i]=read(),p[i]=jump(pos[l[i]],r[i]-l[i]+1);
		m=read();
		for(re int i=n+1;i<=n+m;i++) 
			l[i]=read(),r[i]=read(),p[i]=jump(pos[l[i]],r[i]-l[i]+1);
		for(re int i=1;i<=n+m;i++) 
			d[p[i]].push_back(mp(r[i]-l[i]+1,i));
		tmp=cnt;
		dfs(1,0);
		for(re int i=1;i<=n;i++) a[p[i]]=r[i]-l[i]+1;
		K=read();
		for(re int x,y,i=1;i<=K;i++) {
			x=read(),y=read();
			add(p[x],p[y+n],r[x]-l[x]+1);
		}
		int tot=0;ans=0;
		q[++tot]=1;
		for(re int i=1;i<=tot;i++) {
			int x=q[i];
			ans=max(ans,dp[x]+a[x]);
			for(re int j=head[x];j;j=e[j].nxt) {
				c[e[j].v]--;
				dp[e[j].v]=max(dp[e[j].v],dp[x]+e[j].w);
				if(!c[e[j].v]) q[++tot]=e[j].v;
			}
		} 
		if(tot<cnt) puts("-1");
		else printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：yzhang (赞：3)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10678771.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P5284)

### 我用sa做的本题 ~~（码量似乎有点大）~~

#### 先对原串建sa

#### 考虑如何建图：

#### 从大到小枚举长度len

#### 先将height中等于len的两个位置在并查集合并起来，将lst也合并（lst是链表）

#### 再将长度为len的a串的编号加入所在并查集的lst

#### 然后就珂以查询出每个长度为len的b串所对应a串编号的链表头尾

#### 处理完所有后按加入链表的顺序重新编号

#### （上面这段见merging函数，~~语文不好说不清~~）

#### 现在每个b对应的a的编号都是一段连续的区间

#### 珂以用线段树优化建图

#### 最后跑一下拓扑排序即可得出答案


```cpp
#include <bits/stdc++.h>
#define N 1000005
#define M 16000005
#define ll long long
using namespace std;
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register ll x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline ll Max(register ll a,register ll b)
{
    return a>b?a:b;
}
struct edge{
    int to,next;
}e[M];
int head[N],cnte=1,degree[N],w[N],nt;
inline void add_edge(register int u,register int v)
{
    e[++cnte]=(edge){v,head[u]};
    head[u]=cnte;
    ++degree[v];
}
inline void cleargraph()
{
    memset(w,0,sizeof(w));
    memset(degree,0,sizeof(degree));
    memset(head,0,sizeof(head));
    cnte=1;
}
ll dp[N];
int q[N],qh,qt;
inline ll topsort()
{
    qh=qt=0;
    memset(dp,0,sizeof(dp));
    for(register int i=1;i<=nt;++i)
        if(!degree[i])
            q[++qt]=i;
    ll ans=0;
    while(qh<qt)
    {
        int u=q[++qh];
        dp[u]+=w[u];
        ans=Max(ans,dp[u]);
        for(register int i=head[u];i;i=e[i].next)
        {
            int v=e[i].to;
            dp[v]=Max(dp[v],dp[u]);
            if(!--degree[v])
                q[++qt]=v;	
        }
    }
    return qt<nt?-1LL:ans;
}
int n,sizem;
char s[N];
int rak[N],sa[N],tp[N],tex[N],height[N];
inline void Qsort()
{
    for(register int i=0;i<=sizem;++i)
        tex[i]=0;
    for(register int i=1;i<=n;++i)
        ++tex[rak[i]];
    for(register int i=1;i<=sizem;++i)
        tex[i]+=tex[i-1];
    for(register int i=n;i>=1;--i)
        sa[tex[rak[tp[i]]]--]=tp[i];
}
inline void sa_build()
{
    memset(tp,0,sizeof(tp));
    memset(rak,0,sizeof(rak));
    sizem=30;
    for(register int i=1;i<=n;++i)
        rak[i]=s[i]-'a'+1,tp[i]=i;
    Qsort();
    for(register int w=1,p=0;p<n;sizem=p,w<<=1)
    {
        p=0;
        for(register int i=1;i<=w;++i)
            tp[++p]=n-w+i;
        for(register int i=1;i<=n;++i)
            if(sa[i]>w)
                tp[++p]=sa[i]-w;
        Qsort();
        swap(tp,rak);
        rak[sa[1]]=p=1;
        for(register int i=2;i<=n;++i)
            rak[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w])?p:++p;
    }
}
inline void getheight()
{
    int k=0;
    for(register int i=1;i<=n;++i)
    {
        if(k)
            --k;
        int j=sa[rak[i]-1];
        while(s[i+k]==s[j+k])
            ++k;
        height[rak[i]]=k;
    }
}
struct Unionset{
    int f[N];
    inline void makeset(register int n)
    {
        for(register int i=1;i<=n;++i)
            f[i]=i;
    }
    inline int find(register int x)
    {
        return f[x]==x?f[x]:f[x]=find(f[x]);
    }
    inline void merge(register int x,register int y)
    {
        if(find(x)!=find(y))
            f[f[x]]=f[y];
    }
};
struct ListNode{
    int l,r;
    ListNode():l(-1),r(-1){}
};
ListNode* listNode=nullptr;
inline void clearListNodes()
{
    if(listNode!=nullptr) 
        delete[] listNode;
    listNode=new ListNode[N];
}
struct List{
    int head,tail;
    List():head(-1),tail(-1){}
    List(int node):head(node),tail(node){}
    List(int l,int r):head(l),tail(r){}
    List operator +(const List& other){
        if(tail==-1)
            return other;
        if(other.head==-1)
            return *this;
        listNode[tail].r=other.head;
        listNode[other.head].l=tail;
        return List(head,other.tail);
    }
};
int na,nb,la[N],ra[N],lb[N],rb[N];
List lst[N];
vector<int> merges[N],alen[N],blen[N];
Unionset us;
int invl[N],invr[N],ppos[N],seq[N];
inline void merging()
{
    clearListNodes();
    for(register int i=1;i<=n;++i)
        lst[i]=List();
    for(register int i=0;i<=n;++i)
    {
        merges[i].clear();
        alen[i].clear();
        blen[i].clear();
    }
    for(register int i=1;i<n;++i)
        merges[height[i+1]].push_back(i);
    for(register int i=1;i<=na;++i)
        alen[ra[i]-la[i]+1].push_back(i);
    for(register int i=1;i<=nb;++i)
        blen[rb[i]-lb[i]+1].push_back(i);
    us.makeset(n);
    for(register int len=n;len>=0;--len)
    {
        for(register int i=0;i<merges[len].size();++i)
        {
            int k=merges[len][i];
            int u=us.find(k),v=us.find(k+1);
            List tmp=lst[u]+lst[v];
            us.merge(u,v);
            lst[us.find(u)]=tmp;
        }
        for(register int i=0;i<alen[len].size();++i)
        {
            int a=alen[len][i];
            int u=us.find(rak[la[a]]);
            lst[u]=List(a)+lst[u];
        }
        for(register int i=0;i<blen[len].size();++i)
        {
            int b=blen[len][i];
            int v=us.find(rak[lb[b]]);
            invl[b]=Max(0,lst[v].head);
            invr[b]=Max(0,lst[v].tail);	
        }
    }
    for(register int i=1,u=lst[us.find(1)].head;i<=na;++i,u=listNode[u].r)
    {
        if(u==-1)
            break;
        seq[i]=u;
        ppos[u]=i;
    }
    ppos[0]=-1;
    for(register int i=1;i<=nb;++i)
    {
        invl[i]=ppos[invl[i]];
        invr[i]=ppos[invr[i]];
    }
}
inline void input()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    na=read();
    for(register int i=1;i<=na;++i)
        la[i]=read(),ra[i]=read();
    nb=read();
    for(register int i=1;i<=nb;++i)
        lb[i]=read(),rb[i]=read();
    cleargraph();
    int m=read();
    for(register int i=1;i<=m;++i)
    {
        int x=read(),y=read();
        add_edge(x,na+y);
    }
}
int tot=0,ls[N],rs[N];
inline void seg_build(register int &x,register int l,register int r)
{
    if(l==r)
    {
        x=seq[l];
        return;
    }
    else
        x=++tot;
    int mid=l+r>>1;
    seg_build(ls[x],l,mid);
    seg_build(rs[x],mid+1,r);
    add_edge(x,ls[x]),add_edge(x,rs[x]);
}
inline void seg_addedge(register int x,register int l,register int r,register int b,register int L,register int R)
{
    if(L<=l&&r<=R)
    {
        add_edge(b+na,x);
        return;
    }
    int mid=l+r>>1;
    if(L<=mid)
        seg_addedge(ls[x],l,mid,b,L,R);
    if(R>mid)
        seg_addedge(rs[x],mid+1,r,b,L,R);
}
inline void buildsegtr()
{
    tot=na+nb;
    int root;
    seg_build(root,1,na);
    for(register int i=1;i<=nb;++i)
    {
        if(invl[i]<0)
            continue;
        seg_addedge(root,1,na,i,invl[i],invr[i]);
    }
    nt=tot;
}
inline ll solve()
{
    input();
    sa_build();
    getheight();
    merging();
    buildsegtr();
    for(register int i=1;i<=na;++i)
        w[i]=ra[i]-la[i]+1;
    return topsort();
}
int T;
int main()
{
    T=read();
    while(T--)
        write(solve()),puts("");
    return 0;
}
```

---

## 作者：劉子颺 (赞：3)

一个Naive至极的题解

明显可以利用反串的后缀自动机定位

然后就开始模仿天才黑客的线段树建边的大毒瘤做法（主要是菜）

我认为这道题和天才黑客没有本质区别（Trie变成了SAM而已）

然后就使用天才黑客的毒瘤代码量的那个解法：（线段树+虚树优化建图）

本题发现Trie变成了SAM的parent树 实际上和LCP的关系都是LCA

那么做过天才黑客的朋友就很爽了 因为干涉的子树依旧是那么一个连续的区间

线段树优化建图就完事了

但是Rush完了后 大家多半一下就过样例1 的Cas1 2 

Cas3就输出-1啦 原因是这么一回事Trie树上一个节点只对应一个串 但是Parent树（后缀树就不是的啦）

思考在排序的时候多加一维（串长维） 那么就可以二分DFS序的时候把这个限制加进去了

因为GG的只有一个节点 这还是一段连续的区间

接着这道题就和那个GDKOI2018的那个线段树优化建图+Tarjan+Topsort DP的题没有本质区别啦

用Tarjan判环 Top序幼儿园DP一下

所以这道题本质就是原题和原题组合？（SDOI2017+GDOI2018？）

板（原）题大战啊

代码略长（7K）但是全是封装的板 2个小时连想带写带调很简单（SAM+倍增 20min SGT 10 min Tarjan+Topsort 15min 调试20min 思考20min 清空多测10 min（毒瘤）考场Debuff 20min）差不多就这么长时间


```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
typedef long long LL; 
const int N=7e5+100;
char S[N];
int posb[N];
int posa[N];
int dfn[N<<1];
int low[N<<1];
int mmpcnt;
pair<int,int> mmp[N<<1];
int Val[N<<1];
int Len[N<<1];
int Id[N];
bool cmpA(int A,int B){
    return dfn[posa[A]]<dfn[posa[B]]||(dfn[posa[A]]==dfn[posa[B]]&&Val[A]<Val[B]);
}
int Nodecnt;
struct Graph{
    struct Front_Star{
        int u,v,nxt;
    }e[N<<3];
    int post[N<<3];
    int cnt;
    int first[N<<3];
    int Du[N<<3];
    LL F[N<<3];
    void add(int u,int v){
        ++cnt;
        e[cnt].u=u;
        e[cnt].v=v;
        Du[v]++;
        e[cnt].nxt=first[u];
        first[u]=cnt;
    }
    int dfn[N<<3];
    int low[N<<3];
    int dfn_cnt;
    stack<int>S;
    int instack[N<<3];
    int scc;
    #define lc (p<<1)
    #define rc (p<<1|1)
    void Build(int p,int l,int r){
        post[p]=++Nodecnt;
        if(l==r){
            add(post[p],Id[l]);
            return;
        }
        int mid=(l+r)>>1;
        Build(lc,l,mid);
        Build(rc,mid+1,r);
        add(post[p],post[lc]);
        add(post[p],post[rc]);
    }
    void Update(int p,int l,int r,int dl,int dr,int pos){
        if(dl<=l&&r<=dr){
            add(pos,post[p]);
            return;
        }
        int mid=(l+r)>>1;
        if(dl<=mid)Update(lc,l,mid,dl,dr,pos);
        if(mid< dr)Update(rc,mid+1,r,dl,dr,pos);
    }
    #undef lc 
    #undef rc
    void Tarjan(int x){
        dfn[x]=low[x]=++dfn_cnt;
        S.push(x);
        instack[x]=1;
        for(int i=first[x];i;i=e[i].nxt){
            int v=e[i].v;
            if(!dfn[v]){
                Tarjan(v);
                low[x]=min(low[x],low[v]);
            }
            else{
                if(instack[v]){
                    low[x]=min(low[x],dfn[v]);
                }
            }
        }
        if(low[x]==dfn[x]){
            int u;
            ++scc;
            do{
                u=S.top();
                S.pop();
                instack[u]=0;
            }while(u!=x);
        }
    }
    void Solve(){
        for(int i=1;i<=Nodecnt;++i){
            if(!dfn[i]){
                Tarjan(i);
            }
        }
        if(scc!=Nodecnt){
            cout<<-1<<'\n';
            return;
        }
        while(!S.empty())S.pop();
//		for(int i=1;i<=Nodecnt;++i)instack[i]=0;
        for(int i=1;i<=Nodecnt;++i){
            if(!Du[i]){
                S.push(i);
                F[i]=Val[i];
            }
        }
        LL ans=0;
        while(!S.empty()){
            int x=S.top();
            S.pop();
            for(int i=first[x];i;i=e[i].nxt){
                int v=e[i].v;
                F[v]=max(F[v],F[x]+Val[v]);
                Du[v]--;
                if(!Du[v]){
                    S.push(v);
                }
            }
            ans=max(ans,F[x]);
        }
        cout<<ans<<'\n';
    }
    void Clr(){
        while(!S.empty())S.pop();
        cnt=0;
        for(int i=1;i<=Nodecnt;++i){
            F[i]=0;
            Val[i]=Len[i]=0;
            dfn[i]=low[i]=instack[i]=0;
            Du[i]=0;
            first[i]=post[i]=posa[i]=posb[i]=0;
        }
        dfn_cnt=0;
        scc=0;
    }
}G;	
bool GG=0;
struct Suffix_AutoMation{	
    struct Front_Star{
        int u,v,nxt;
    }e[N<<1];
    int ecnt,dfn_cnt;
    int first[N<<1];
    int fa[N<<1][21];
    void add(int u,int v){
        ++ecnt;
        e[ecnt].u=u;
        e[ecnt].v=v;
        e[ecnt].nxt=first[u];
        first[u]=ecnt;
    }
    void DFS1(int u,int fat){
        fa[u][0]=fat;
        dfn[u]=++dfn_cnt;
        for(int i=1;i<=20;++i)fa[u][i]=fa[fa[u][i-1]][i-1];
        for(int i=first[u];i;i=e[i].nxt){
            int v=e[i].v;
            if(v==fat)continue;
            DFS1(v,u);
        }
        low[u]=dfn_cnt;
    }
    //
    struct Suffix_Node{
        int vis[26];
        int pre,step;
    }SA[N<<2];
    int cnt,last;
    int pos[N<<1];
    void Insert(char C,int Id){
        int p=last;
        int np=++cnt;
        last=np;
        SA[np].step=SA[p].step+1;
        for(;!SA[p].vis[C-'a'];p=SA[p].pre)SA[p].vis[C-'a']=np;
        if(!p){
            SA[np].pre=1;
        }
        else{
            int q=SA[p].vis[C-'a'];
            if(SA[q].step==SA[p].step+1){
                SA[np].pre=q;
            }
            else{
                int nq=++cnt;
                SA[nq].step=SA[p].step+1;
                memcpy(SA[nq].vis,SA[q].vis,sizeof(SA[nq].vis));
                SA[nq].pre=SA[q].pre;
                SA[np].pre=SA[q].pre=nq;
                for(;SA[p].vis[C-'a']==q;p=SA[p].pre)SA[p].vis[C-'a']=nq;
            }
        }
        pos[Id]=np;
    }
    void Build(){
        for(int i=1;i<=cnt;++i){
            add(SA[i].pre,i);
        }
        DFS1(1,0);
    }
    int Jump(int x,int len){
        for(int i=20;i>=0;--i){
            if(fa[x][i]&&SA[fa[x][i]].step>=len){
                x=fa[x][i];
            }
        }
        return x;
    }
    void Solve(){
        scanf("%s",S+1);
        int len=strlen(S+1);
        cnt=last=1;
        for(int i=len;i>=1;--i){
            Insert(S[i],i);
        }
        Build();
        int na;
        scanf("%d",&na);
        for(int i=1;i<=na;++i){
            int l,r;
            scanf("%d%d",&l,&r);
            int now=Jump(pos[l],r-l+1);
            posa[i]=now;
            Val[i]=r-l+1;
            mmp[++mmpcnt]=make_pair(dfn[now],Val[i]);
        }
        sort(mmp+1,mmp+1+mmpcnt);
        for(int i=1;i<=na;++i){
            Id[i]=i;
        }
        sort(Id+1,Id+1+na,cmpA);
        Nodecnt=na;
        G.Build(1,1,na);
        int nb;
        scanf("%d",&nb);
        for(int i=1;i<=nb;++i){
            int l,r;
            scanf("%d%d",&l,&r);
            int now=Jump(pos[l],r-l+1);
            posb[i]=now;
            Len[i]=r-l+1;
        }
        int tot;
        scanf("%d",&tot);
        for(int i=1;i<=tot;++i){
            int A,B;
            scanf("%d%d",&A,&B);
            int L=lower_bound(mmp+1,mmp+1+mmpcnt,make_pair(dfn[posb[B]],Len[B]))-mmp;
            int R=lower_bound(mmp+1,mmp+1+mmpcnt,make_pair(low[posb[B]]+1,0))-mmp-1;
            if(L<=R){
                G.Update(1,1,na,L,R,A);
            }
        }
        G.Solve();
    }
    void Clr(){
        for(int i=1;i<=cnt;++i)first[i]=0;
        ecnt=0;
        dfn_cnt=0;
        for(int i=1;i<=cnt*2;++i){
            for(int j=0;j<=20;++j){
                fa[i][j]=0;
            }
            SA[i].pre=SA[i].step=0;
            memset(SA[i].vis,0,sizeof(SA[i].vis));
            pos[i]=0;
            dfn[i]=low[i]=0;
        }
        mmpcnt=0;
        cnt=last=1;
    }
}SAM;
void Clr(){
    SAM.Clr();
    G.Clr();
    Nodecnt=0;
}
int main(){
//	freopen("P5284.in","r",stdin);
//	freopen("string.out","w",stdout);
//	system("size.exe P5284.exe");
//	exit(0);
    int Cas;
    scanf("%d",&Cas);
    while(Cas--){
        Clr();
        SAM.Solve();
    }
    return 0;
}
```




---

## 作者：nekko (赞：2)

思博题，模拟题意就行了，然而毒瘤出题人卡常数。。。（多测什么鬼啊）

考虑模拟题意：

显然你是要把 $A_x \to B_y$，在这 $m$ 条限制下

然后如果 $B_x$ 是 $A_y$ 的前缀的话，连接一条 $B_x \to A_y$ 的边

之后跑最长路就是答案咯，注意判断是否有环

那么如何通过 $100pts$ 呢？

昨天刚刚学习了一波 $sam$，那么遇到这种又是子串又是 $lcp$ 肯定就是 $sam$ 之类的玩意套一套了

考虑建立反串的 $parent$ 树，那么前缀和优化建图就好了

**注意卡常！！！**

**注意卡常！！！**

**注意卡常！！！**

---

## 作者：ycx_girlfriend (赞：1)

### [原题链接](/problem/P5284)

不会$\text{SAM}$的蒟蒻只好用$\text{SA}$来水了。

先读懂题意(窝在读题意这儿花了快$20$min).

简单来说，是给你一个字符串，然后给你两个区间的集合$A,B$，一共有$m$组$A_i$到$B_j$的支配关系。若$A_i,B_j$有支配关系，则从$A_i$到$B_j$连边；若$B_j$是$A_i$的前缀，则珂以从$B_j$连向$A_i$。每个$A_i$有权值，是$A_i$区间的长度。当你把上述的图建好后，她要你求图中的最长路。如果珂以无限长，输出`-1`。

~~一看就懵逼的神仙字符串图论题~~

来肝这题的神仙们应该都知道最长路咋求吧？就是先拓扑排序一下，然后从后往前$\text{dp}$。这里就不讲了。

分析一下，这张图上一共的点数是不超过$|A|+|B|$，即是线性的。但边数珂能高达$m+|A|\cdot|B|$。再仔细地分析一下，从$A_i$到$B_j$连的边数是$m$，是线性的。问题就转化成了优化$B_j$向$A_i$连边的过程。

结合$B_j$是$A_i$的前缀，我们很容易想到用$\text{SA}$。我们找到$B_j$在$\text{sa}$上的位置，设为$\text{pos}$。$B_j$连向的所有$A_i$必须满足$\text{lcp}$是$\ge|B_j|$的，在$\text{sa}$上必须是一个区间，且包含$\text{pos}$。设这个区间为$[l,r]$，那么必须满足：$\min\limits_{l+1\le i\le r}height_i\ge |B_j|$，且$l$尽量忘左，$r$尽量往右。找$l,r$的过程珂以通过在$\text{height}$数组上建出$\text{ST}$表之后二分求出。然后只要再用线段树优化建图就珂以了。

但这样有个问题：你不能保证在$[l,r]$区间内的$|A_i|\ge |B_j|$。这样只能得到$80$分。

所以我们需要考虑更好的做法：用可持久化线段树优化建图。按照$|A_i|$从大到小建树，每个$A_i$只在第$n-|A_i|$棵可持久化线段树建树时加入。在可持久化线段树上，第$i$棵树上的点要向第$i-1$棵树上的对应点连边(除非没有)，这样珂以保证每一次加入的$B_j$的长度$\le |A_i|$。具体细节就康代码吧。

总时间复杂度：$O(N\log N)$，空间复杂度：$O(N\log N)$

代码：

```
// Code by H~$~C
#include <bits/stdc++.h>
using namespace std;

#ifndef LOCAL_JUDGE
static char _in_buf[100000], *_in_p1 = _in_buf, *_in_p2 = _in_buf;
#define gc (__builtin_expect(_in_p1 == _in_p2, 0) && (_in_p2 = (_in_p1 = _in_buf) + \
        fread(_in_buf, 1, 100000, stdin), _in_p1 == _in_p2) ? -1 : *_in_p1++)
#else
#define gc getchar()
#endif
inline int read() {
  register char ch = gc;
  register int x = 0;
  while (ch < 48 || ch > 57) ch = gc;
  while (ch > 47 && ch < 58) x = (x << 3) + (x << 1) + (ch ^ 48), ch = gc;
  return x;
}

static const int Maxn = 200005;
static const int Maxs = 5000005;

int n, na, nb, N, m;
char str[Maxn];
int la[Maxn], ra[Maxn], lb[Maxn], rb[Maxn];
vector<int> A[Maxn];
int ST[Maxn][20];

int wa[Maxn], wb[Maxn], wc[Maxn], _s[Maxn];
int sa[Maxn], rnk[Maxn], height[Maxn];
template<typename T>
void build_SA(T *ss, int n, int m) {
  register int *x = wa, *y = wb, *tmp;
  register int i, j, w;
  for (i = 1; i <= n; ++i) _s[i] = ss[i];
  for (i = 1; i <= n; ++i) x[i] = _s[i], y[i] = i;
  for (i = 1; i <= m; ++i) wc[i] = 0;
  for (i = 1; i <= n; ++i) wc[x[i]]++;
  for (i = 2; i <= m; ++i) wc[i] += wc[i - 1];
  for (i = n; i >= 1; --i) sa[wc[x[y[i]]]--] = y[i];
  for (w = 1; w <= n; w <<= 1) {
    register int tot = 0;
    for (i = n - w + 1; i <= n; ++i) y[++tot] = i;
    for (i = 1; i <= n; ++i) if (sa[i] > w) y[++tot] = sa[i] - w;
    for (i = 1; i <= m; ++i) wc[i] = 0;
    for (i = 1; i <= n; ++i) wc[x[i]]++;
    for (i = 2; i <= m; ++i) wc[i] += wc[i - 1];
    for (i = n; i >= 1; --i) sa[wc[x[y[i]]]--] = y[i];
    tmp = x, x = y, y = tmp, x[sa[1]] = 1, tot = 1;
    for (i = 2; i <= n; ++i)
      x[sa[i]] = ((y[sa[i]] == y[sa[i - 1]] && y[sa[i] + w] == y[sa[i - 1] + w]) ? tot : ++tot);
    if (tot == n) break; m = tot;
  }
  for (i = 1; i <= n; ++i) rnk[sa[i]] = i;
  for (i = 1, w = 0; i <= n; ++i) {
    if (rnk[i] == 1) continue;
    if (w) --w;
    int j = sa[rnk[i] - 1];
    while (i + w <= n && j + w <= n && _s[i + w] == _s[j + w]) w++;
    height[rnk[i]] = w;
  }
}
// sa[rank] = name, rnk[name] = rank
// height[i] = lcp(suffix(sa[i - 1]), suffix(sa[i]))

vector<int> g[Maxs];
int deg[Maxs], val[Maxs];
inline void clear_all(int u) { g[u].clear(), deg[u] = val[u] = 0; }
inline void add_edge(int u, int v) { g[u].push_back(v), deg[v]++; }

struct Node {
  int id;
  Node *l, *r;
  Node() { }
  Node(int id, Node *l, Node *r)
  : id(id), l(l), r(r) { }
} *root[Maxn], pool[Maxs], *cur_pointer = pool;
inline Node *newnode(int id, Node *l = NULL, Node *r = NULL) {
  return &(*++cur_pointer = Node(id, l, r));
}
int insert(Node *&p, int l, int r, int pos) {
  if (!p) {
    p = newnode(++N);
    clear_all(N);
  }
  else {
    p = newnode(p->id, p->l, p->r);
    clear_all(++N);
    add_edge(N, p->id);
    p->id = N;
  }
  if (l == r) return p->id;
  int mid = (l + r) >> 1, res;
  if (pos <= mid) res = insert(p->l, l, mid, pos);
  else res = insert(p->r, mid + 1, r, pos);
  if (p->l) add_edge(p->id, p->l->id);
  if (p->r) add_edge(p->id, p->r->id);
  return res;
}
void link_edge(Node *p, int l, int r, int L, int R, int u) {
  if (!p) return ;
  if (L == l && r == R) return add_edge(u, p->id);
  int mid = (l + r) >> 1;
  if (R <= mid) return link_edge(p->l, l, mid, L, R, u);
  if (L > mid) return link_edge(p->r, mid + 1, r, L, R, u);
  link_edge(p->l, l, mid, L, mid, u);
  link_edge(p->r, mid + 1, r, mid + 1, R, u);
}

int que[Maxs], qh, qe;
long long dp[Maxs];

void solve() {
  cur_pointer = pool;
  register int i, j;
  register char ch;
  while ((ch = gc) < 33);
  for (n = 0; ch > 32; ch = gc) str[++n] = ch;
  for (na = read(), i = 1; i <= na; ++i)
    la[i] = read(), ra[i] = read();
  for (nb = read(), i = 1; i <= nb; ++i)
    lb[i] = read(), rb[i] = read();
  N = na + nb;
  build_SA<char>(str, n, 128);
  for (i = 1; i <= n; ++i) ST[i][0] = height[i];
  for (j = 1; j < 20; ++j)
    for (i = 1; i + (1 << j) - 1 <= n; ++i)
      ST[i][j] = min(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]);
  
  for (i = 1; i <= N; ++i) clear_all(i);
  for (m = read(), i = 1; i <= m; ++i) {
    int x = read(), y = read();
    add_edge(x, y + na);
  }
  for (i = 1; i <= n; ++i) A[i].clear();
  for (i = 1; i <= na; ++i) {
    val[i] = ra[i] - la[i] + 1;
    A[val[i]].push_back(i);
  }
  
  root[n + 1] = NULL;
  for (i = n; i >= 1; --i) {
    root[i] = root[i + 1];
    for (int &x: A[i]) {
      int id = insert(root[i], 1, n, rnk[la[x]]);
      add_edge(id, x);
    }
  }
  for (i = 1; i <= nb; ++i) {
    int l = rnk[lb[i]], r = rnk[lb[i]];
    int len = rb[i] - lb[i] + 1;
    /* get the leftest position */ {
      for (j = 0; l - (1 << j) + 1 >= 2; ++j);
      for (; ~--j; ) {
        if (l - (1 << j) + 1 >= 2 && ST[l - (1 << j) + 1][j] >= len) {
          l -= (1 << j);
        }
      }
    }
    /* get the rightest position */ {
      for (j = 0; r + (1 << j) <= n; ++j);
      for (; ~--j; ) {
        if (r + (1 << j) <= n && ST[r + 1][j] >= len) {
          r += (1 << j);
        }
      }
    }
    link_edge(root[len], 1, n, l, r, i + na);
  }
  
  qh = qe = 0;
  for (i = 1; i <= N; ++i) {
    if (!deg[i]) que[qe++] = i;
  }
  while (qh < qe) {
    int u = que[qh++];
    for (int &v: g[u]) {
      if (!--deg[v]) {
        que[qe++] = v;
      }
    }
  }
  if (qe != N) {
    puts("-1");
    return ;
  }
  
  for (i = N - 1; ~i; --i) {
    int u = que[i];
    dp[u] = 0;
    for (int &v: g[u]) {
      dp[u] = max(dp[u], dp[v]);
    }
    dp[u] += val[u];
  }
  printf("%lld\n", *max_element(dp + 1, dp + N + 1));
}

int main() {
  int tests = read();
  while (tests--) solve();
  return 0;
}
```

跑得炒鸡慢$\ldots$最大的点用了$7.40$秒

---

## 作者：Hope2075 (赞：1)

upd:发现代码求SA出错了，导致效率极低，更新一下

~~修复后发现变成第一了~~

写篇题解纪念SDOI R1D1因失误而丢的100分

（T1 60->0 T2 80->40）

提供一种贼省内存且跑得贼快的做法

实际并不需要用主席树

~~其实是因为我看到讨论版里说主席树过不去，被吓到了~~

空间复杂度可以做到$O(n)$，时间跑不满，同时常数会很小

首先把后缀数组求出来

然后考虑什么情况下A串可以相连

第一，前面的A串支配某个B串

第二，这个B串是后面A串的前缀

这样可以发现，满足第二个条件的A串和B串之间的height值要足够大，必须比B串长度大

而且，这个B串不能比后面的A串更长

这一限制对前80分没有影响

这部分可以这样做：

把A串和B串按照对应前缀的排名排序

求出每个B串的控制范围，也就是它能与哪段区间内的A串相连

求范围可以用ST表+二分

用线段树优化建图，B类串连一段区间，A类串连叶子节点，就能比较容易地得到80分

再考虑长度限制

很直接的想法就是用主席树大力建图

但这样空间复杂度是$O(n \log n)$的

考虑其它做法

首先，求范围时有一种$O(n\log n)$时间，$O(n)$空间的做法

对每个B串，考虑向前和向后控制的范围

![](https://cdn.luogu.com.cn/upload/pic/56524.png)

除了可以直接RMQ+二分外，还可以用单调栈+二分

具体实现：

首先用单调栈维护到目前的最长上升子序列

大概是这样：

![](https://cdn.luogu.com.cn/upload/pic/56526.png)

（每次维护都是一段沿红色线的折线）

然后，在单调栈上二分，求出向前最远能到达哪里

~~感性理解一下，这样是对的~~

向后控制的范围同理，注意height数组的定义

接下来，考虑什么情况下B类串可以与A类串相连

首先，两个B类串控制区间只能是包含或相离

~~也感性理解一下吧~~

然后，如果两个B类串相包含，则长度较长的被长度较短的包含（包括完全相同的情况）

这样可以发现：如果一个B类串是某个A类串的前缀，那么包含它控制范围的串也是这个A类串的前缀，~~还是感性理解一下~~

把区间范围和长度一起在坐标系上画出来，就是这样：

![](https://cdn.luogu.com.cn/upload/pic/56527.png)

然后在这张图上看什么时候B类串可以向A类串连边

![](https://cdn.luogu.com.cn/upload/pic/56528.png)

可以看出，只要相交，就能连边

因为相交就意味着A类串在控制区间内，而且长度限制满足条件

可以考虑扫描线，维护一个栈，每次移动后更新栈，随后把这个A类串向栈内的B类串连边

但这样复杂度会爆炸

不过发现，可以连边的范围具有单调性

可以在栈里二分出这个范围，~~但似乎并没有什么用~~

突然发现：B类串的作用只是使对应A类串之间可以到达

所以只要B类串对A类串的连通性不变就可以

只需要将A类串向最上面的B类串连边，然后B类串向下面的B类串连边就可以，这样从某个A类串出发就能到达所有合法B类串

具体实现的时候，枚举A类串，然后更新栈，入栈的B类串与栈顶连边

然后就是图论部分了

对这张图进行拓扑排序

如果有未到达节点，则说明有环

根据建图过程，可以得知不是B类串之间的环

所以存在无限长的串

如果所有节点都能到达，则直接按求出的拓扑序DP一遍，求出权值最大的路径长度即可，权值就是对应A类串的长度

这样就解决了这道题

时间复杂度：

后缀数组$O(n \log n)$，可以换成DC3算法，也许会变快，然而我不会DC3

排序$O(n \log n)$

在栈内二分$O(n \log n)$，但是跑不满

而且可以发现边数是$O(n)$级别的，所以图论部分是$O(n)$

空间复杂度：

后缀数组，排序，维护栈都是$O(n)$的

边数也是$O(n)$级别的

所以最后得到了一个空间复杂度$O(n)$的算法

不过这样~~比较~~相当难写

发现之前跑得慢的原因是SA写错

[这是原来的记录](https://www.luogu.org/recordnew/show/18179642)

因为SA写出错，导致效率极低，用时45445ms(氧化)，需要再加上读入优化才能卡过去，最坏复杂度变成$O(n^2)$

~~奇怪的是，怎么卡过去的~~

主要错误是倍增时长度为每次加1

[这是更新后的记录](https://www.luogu.org/recordnew/show/18663521)

7112ms跑完，而且内存只有28772KB，最慢的点1176ms

~~突然发现变成最优解了~~

~~估计很快就会被吊打了~~

~~关于提交记录中define后面的东西就不要在意了~~

代码：

~~皮一下很开心~~

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define next val1
#define rank val2
const int N=200007;
const bool debug=0;
char str[N];
int n;
namespace SA{
    int ga[N],gb[N],cnt[N],sa[N],rank[N],height[N];
    void calc(){
        int m=256,p;
        int*x=ga,*y=gb;
        for(int i=0;i<m;i++)cnt[i]=0;
        for(int i=0;i<n;i++)cnt[x[i]=str[i]]++;
        for(int i=1;i<m;i++)cnt[i]+=cnt[i-1];
        for(int i=n-1;i>=0;i--)sa[--cnt[x[i]]]=i;
        for(int j=1;j<n;j*=2){
            p=0;
            for(int i=n-j;i<n;i++)y[p++]=i;
            for(int i=0;i<n;i++)if(sa[i]>=j)y[p++]=sa[i]-j;
            
            for(int i=0;i<m;i++)cnt[i]=0;
            for(int i=0;i<n;i++)cnt[x[y[i]]]++;
            for(int i=1;i<m;i++)cnt[i]+=cnt[i-1];
            for(int i=n-1;i>=0;i--)sa[--cnt[x[y[i]]]]=y[i];
            
            swap(x,y);
            p=1;
            x[sa[0]]=0;
            for(int i=1;i<n;i++){
                if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+j]==y[sa[i-1]+j]){
                    x[sa[i]]=p-1;
                }else{
                    x[sa[i]]=p++;
                }
            }
            if(p>=n)break;
            m=p;
        }
        for(int i=0;i<n;i++)rank[sa[i]]=i;
        int k=0;
        for(int i=0;i<n;i++){
            if(k)k--;
            int j=sa[rank[i]-1];
            while(str[i+k]==str[j+k])k++;
            height[rank[i]]=k;
        }
    }
}
int na,nb,m;
namespace graph{
    int head[N*2],next[N*6],ver[N*6],tot;
    int val[N*2];
    int que[N*2],he,ta;
    int deg[N*2];
    bool vis[N*2];
    long long dp[N*2];
    int maxid;
    void clr(){
        for(int i=0;i<=maxid;i++)head[i]=0;
        for(int i=0;i<=maxid;i++)val[i]=0;
        for(int i=0;i<=maxid;i++)deg[i]=0;
        for(int i=0;i<=maxid;i++)vis[i]=0;
        for(int i=0;i<=maxid;i++)dp[i]=0;
        maxid=0;
        tot=0;
    }
    void add(int a,int b){
        if(a==0||b==0)return;
        tot++;
        ver[tot]=b;
        next[tot]=head[a];
        head[a]=tot;
        deg[b]++;
    }
    void topsort(){
        he=ta=0;
        for(int i=1;i<=maxid;i++){
            if(deg[i]==0)que[ta++]=i;
        }
        int cur;
        while(he!=ta){
            cur=que[he++];
            vis[cur]=1;
            for(int i=head[cur];i;i=next[i]){
                deg[ver[i]]--;
                if(deg[ver[i]]==0)que[ta++]=ver[i];
            }
        }
    }
    
    long long solve(){
        maxid=na+nb;
        topsort();
        
        for(int i=1;i<=na+nb;i++){
            if(!vis[i])return -1;
        }
        int cur;
        for(int i=0;i<he;i++){
            cur=que[i];
            if(cur<=na)dp[cur]+=val[cur];
            for(int i=head[cur];i;i=next[i]){
                dp[ver[i]]=max(dp[cur],dp[ver[i]]);
            }
        }
        long long ans=0;
        for(int i=1;i<=maxid;i++)ans=max(ans,dp[i]);
        return ans;
    }
}
struct sub{
    int l,r;
    int id;
};
int blen[N];
bool cmp1(sub a,sub b){
    if(a.l==b.l){
        if(a.r==b.r)return blen[a.id]<blen[b.id];
        return a.r>b.r;
    }
    return a.l<b.l;
}
bool cmp2(sub a,sub b){
    if(a.l==b.l)return (a.r-a.l)<(b.r-b.l);
    return SA::rank[a.l]<SA::rank[b.l];
}

sub la[N*2],lb[N*2];
int llim[N],rlim[N];
void readstr(){
	n=0;
	char c=getchar();
	while(c<'a'||c>'z')c=getchar();
	while(c>='a'&&c<='z'){
		str[n]=c;
		c=getchar();
		n++;
	}
	str[n]=0;
	n++;
	str[n]=0;
}
long long read(){
	long long n=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){
		n=n*10+c-'0';
		c=getchar();
	}
	return n;
}
char res[30];
void output(long long n){
	if(n==0){
		putchar('0');
		putchar('\n');
		return;
	}
	if(n<0){
		putchar('-');
		n=-n;
	}
	int t=0;
	while(n){
		res[t++]=n%10+'0';
		n=n/10;
	}
	while(t--){
		putchar(res[t]);
	}
	putchar('\n');
	return;
}
int st[N],top;
struct work{
    work(){
        readstr();
        SA::calc();
        na=read();
        for(int i=0;i<na;i++){
            la[i].l=read();
			la[i].r=read();
            la[i].l--;
            la[i].r--;
            la[i].id=i+1;
            graph::val[i+1]=la[i].r-la[i].l+1;
        }
        nb=read();
        for(int i=0;i<nb;i++){
            lb[i].l=read();lb[i].r=read();
            lb[i].l--;
            lb[i].r--;
            lb[i].id=i+1;
            blen[i+1]=lb[i].r-lb[i].l+1;
        }
        int m,a,b;
        m=read();
        while(m--){
            a=read();b=read();
            graph::add(a,b+na);
        }
        sort(la,la+na,cmp2);
        sort(lb,lb+nb,cmp2);
        top=0;
        m=0;
        
        //这部分看起来很短，很好写
        //但实际上，需要讨论很多边界情况
        //这部分花了我将近一整天的时间
        for(int i=1;i<n;i++){
            while(top&&SA::height[st[top-1]]>=SA::height[i])top--;
            st[top++]=i;
            while(m<nb&&SA::rank[lb[m].l]==i){
                int l=0,r=top,mid;
                while(l!=r){
                    mid=((l+r)>>1);
                    if(SA::height[st[mid]]>=lb[m].r-lb[m].l+1)r=mid;
                    else l=mid+1;
                }
                llim[m]=((l!=0)?st[l-1]:0);
                m++;
            }
        }
        top=0;
        m=nb-1;
        for(int i=n-1;i>=1;i--){
            while(top&&SA::height[st[top-1]]>=SA::height[i+1])top--;
            st[top++]=i+1;
            while(m>=0&&SA::rank[lb[m].l]==i){
                int l=0,r=top,mid;
                while(l!=r){
                    mid=((l+r)>>1);
                    if(SA::height[st[mid]]>=lb[m].r-lb[m].l+1)r=mid;
                    else l=mid+1;
                }
                rlim[m]=((l!=0)?st[l-1]-1:n);
                m--;
            }
        }
        for(int i=0;i<nb;i++){
            lb[i].l=llim[i];
            lb[i].r=rlim[i];
        }
        sort(lb,lb+nb,cmp1);
        top=0;
        m=0;
        for(int i=0;i<na;i++){
            while(top&&lb[st[top-1]].r<SA::rank[la[i].l])top--;
            while(m<nb){
                if(lb[m].r<SA::rank[la[i].l])m++;
                else if(lb[m].l<=SA::rank[la[i].l]){
                    if(top)graph::add(lb[st[top-1]].id+na,lb[m].id+na);
                    st[top++]=m;
                    m++;
                }else break;
            }
            if(top){
                int l=0,r=top,mid;
                int len=la[i].r-la[i].l+1;
                while(l!=r){
                    mid=((l+r)>>1);
                    if(blen[lb[st[mid]].id]>len)r=mid;
                    else l=mid+1;
                }
                if(l!=0)graph::add(lb[st[l-1]].id+na,la[i].id);
            }
        }
        output(graph::solve());
        graph::clr();
    }
};
struct qwq{
    ~qwq(){
        int t;
        t=read();
        while(t--){
            work a;
        }
    }
};

int main(){qwq a;}


```

---


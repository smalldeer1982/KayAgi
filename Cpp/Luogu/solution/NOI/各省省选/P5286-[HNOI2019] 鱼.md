# [HNOI2019] 鱼

## 题目背景

$\text{\color{white}本题数据听说没问题？}$

## 题目描述

在平面坐标系上给定$n$个不同的整点（也即横坐标与纵坐标皆为整数的点）。我们称从这$n$个点中选择6个不同的点所组成的有序六元组$(A,B,C,D,E,F)$是一条“鱼”，当且仅当：$AB=AC,BD=CD,DE=DF$（身形要对称），并且$\angle BAD,\angle BDA$ 与$\angle CAD,\angle CDA$都是锐角（脑袋和屁股显然不能是凹的），$\angle ADE,\angle ADF$ 大于$90^\circ$（也即为钝角或平角，为了使尾巴不至于翘那么别扭）。

下图就是一个合法的鱼的例子：

![](https://cdn.luogu.com.cn/upload/pic/56001.png)

其中点的组成相同，但顺序不同的鱼视为不同的鱼，即$(A,B,C,D,E,F)$和$(A,C,B,D,E,F)$视为不同的两条鱼（毕竟鱼也有背和肚子的两面），同理$(A,B,C,D,E,F)$和$(A,B,C,D,F,E)$也可以视为不同的两条鱼（假设鱼尾巴可以打结）。

问给定的$n$个点可以构成多少条鱼。特别的，数据保证$n$个点互不重复。


## 说明/提示

对于前 20%的数据，保证$n \leq 10,|x|,|y| \leq 5$

对于前 40%的数据，保证$n \leq 300$，$0 \leq |x|,|y| \leq 10^5$。

对于另外 20%的数据，保证$|x|,|y| \leq 20$。

对于所有数据，保证$6 \leq n \leq 1000$，$0 \leq |x|, |y| \leq 10^9$，$n$个点互不重复。


## 样例 #1

### 输入

```
8
-2 0
-1 0
0 1
0 -1
1 0
2 0
3 1
3 -1```

### 输出

```
16```

# 题解

## 作者：zhoutb2333 (赞：21)

这种做法基于这个事实：平面上 $n$ 个不重点组成的等腰三角形个数是 $O(n^{2.137})$ 级别的（[证明在这里](https://link.springer.com/article/10.1007/s003730200063)）

那也就是说我们可以枚举一个点为极点，然后把所有点按照离极点的距离排序，然后离极点距离相同的点分成一组。我们如果枚举组内点对的话，是不会 $O(n^3)$ 的。

这样的话这个题就比较简单了：我们先枚举每个点作为 $A$ 点，然后枚举组内点对，进而求出每个 $BC$ 线段左面、右面的 $A$ 点个数。

然后我们再枚举每个点作为 $D$ 点，继续枚举组内点对 $(B, C)$ ，然后把直线 $AD$ 插入极角序排序（所有合法的 $A$ 都在 $BC$ 的中垂线上）。最后再枚举组内点对 $(E, F)$ ，合法的直线 $AD$ 的极角范围是一个区间，二分即可。

复杂度是 $O(n^2 \log n +n^{2.137})$ （好玄学

[代码在这里](https://paste.ubuntu.com/p/jKwsnhgTPr/)

---

## 作者：TheLostWeak (赞：15)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5286.html)

**大致题意：** 给你$n$个点，让你求鱼形图的数量。

### 核心思路

首先，考虑到$n$这么小，我们可以枚举线段$AD$，再去找符合条件的$BC,EF$。

然后，不难发现$BC$与$EF$互不影响，因此我们可以分开求对于已知$AD$的$BC$与$EF$的方案数，然后将其相乘。

那么我们现在的问题就在于，如何求出$BC$与$EF$的方案数了。

### $BC$的方案数

#### 预处理

考虑到$AB=AC,BD=CD$，用我这点可怜的初中数学知识，都能证明出$AD$垂直平分$BC$（貌似作业里还做过这种题目）。

则，我们可以换一个角度，如果枚举$BC$，那么符合条件的$AD$必然满足两个条件：

- $\because BC\bot AD,\therefore BC$与$AD$的斜率相乘为$-1$。
- $\because AD$平分$BC,\therefore AD$必然经过$BC$的中点。

而已知斜率和直线上一点，我们就可以推出这条直线的解析式啦！

设$B(x_B,y_B),C(x_C,y_C)$，则$BC$斜率为$\frac{y_C-y_B}{x_C-x_B}$,$\therefore AD$斜率为：

$$-1÷\frac{y_C-y_B}{x_C-x_B}=\frac{x_B-x_C}{y_C-y_B}$$

又$\because BC$中点$G$坐标为$(\frac{x_B+x_C}2,\frac{y_B+y_C}2),\therefore AD$截距为：

$$\frac{x_B-x_C}{y_C-y_B}*\frac{x_B+x_C}2-\frac{y_B+y_C}2=\frac{(x_B-x_C)(x_B+x_C)-(y_C-y_B)(y_B+y_C)}{2(y_C-y_B)}$$

这样其实我们已经求出了$AD$的斜率和截距，但如果你像我一样无聊，可以看一下我对于这里截距的进一步化简。

------

这个截距的式子显得过于冗长，因此我们可以再转化一下得到：

$$\frac{(x_B-x_C)(x_B+x_C)-(y_C-y_B)(y_B+y_C)}{2(y_C-y_B)}=\frac{(x_B-x_C)(x_B+x_C)+(y_B-y_C)(y_B+y_C)}{2(y_C-y_B)}=\frac {x_{B-C}*x_{B+C}+y_{B-C}*y_{B+C}}{2(y_C-y_B)}$$

其中，$B-C,B+C$皆为向量。

然后，了解一些计算几何公式的人就可以发现，$x_{B-C}*x_{B+C}+y_{B-C}*y_{B+C}$其实是一个点积的形式！

于是我们最后得到一个简单的式子：

$$\frac{(B-C)\cdot(B+C)}{2(y_C-y_B)}$$

------

而求出了斜率和截距之后，我们就相当于求出了$AD$的函数表达式。

则可以考虑把$AD$函数表达式相同的$BC$的信息全部扔入同一个$vector$存储下来，方便后面求答案。

还有要注意的就是对于$B,C$两点$y$相等的情况要特判，因为此时$AD$就不是一次函数了。

#### 求答案

枚举$AD$时，我们首先就是求出$AD$的函数表达式，然后到对应$vector$里去求答案。

此时，我们主要是要满足题目中给出的“$∠BAD,∠BDA$与$∠CAD,∠CDA$都是锐角”的要求。

也就是说，线段$AD$需要与线段$BC$有交点。

我们先前已经提过要开$vector$，但其实不需要直接存下$BC$，因为这样不太方便。

实际上，我们只要存下中点某一坐标的两倍（两倍是为了可以直接用$int$存储），就可以直接在$vector$中通过$upper\_bound$的方式，分别用$A,D$两点的相应坐标查找出两个范围，然后利用前缀和思想来用大的减小的即可得出答案。

至于应该选择哪一坐标，需要根据具体函数解析式来分析了。

如形如$x=a$的表达式必须选纵坐标，形如$y=a$的表达式必须选横坐标（因为固定的无法判），否则任选。

不过反正我们要特判$B,C$纵坐标相等，即$A,D$横坐标相等的情况，则我们干脆对于横坐标相等的取纵坐标，不相等的取横坐标，也方便我们判断应用哪个坐标去$upper\_bound$。

这一过程有一定细节，具体实现详见代码。

### $EF$的方案数

对于这个，我们可以考虑，过点$D$作$AD$的垂线$l$，则我们将整个平面划分成了两个半平面，而根据题目要求，点$E,F$必须在点$A$所不在的那个半平面内。

则如果我们枚举点$D$，然后将其余点按极角排序，我们就可以用**双指针**，来维护对于每个点$A$可能作为点$E,F$的所有点。

那么什么情况下两个点才能作为一对点$E,F$呢？

正如题目中说的，需要$DE=DF$。

因此我们开个$map$，维护每种到点$D$的距离出现的次数，然后就可以用类似于莫队的方式进行维护了，这应该还是比较简单的。

注意，这里我对于相同的两个点只统计了一次，因为最后我将答案乘上了$4$，即$BC,EF$互换的情况。

这一过程同样有一定细节，具体实现详见代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define RL Reg LL
#define Con const
#define CI Con int&
#define CL Con LL&
#define I inline
#define W while
#define N 1000
#define LL long long
#define DB long double
#define eps 1e-10
#define swap(x,y) (x^=y^=x^=y)
using namespace std;
int n,val[N+5][N+5];Con DB Pi=acos(-1); 
Tp I Ty gcd(Con Ty& x,Con Ty& y) {return y?gcd(y,x%y):x;}
struct Fr//存储一个分数
{
	LL x,y;I Fr(CL a=0,CL b=1) {RL g=gcd(a,b);x=a/g,(y=b/g)<0&&(x=-x,y=-y);}//注意约分
	I bool operator != (Con Fr& o) Con {return x^o.x||y^o.y;}//不等于
	I bool operator < (Con Fr& o) Con {return x^o.x?x<o.x:y<o.y;}//这个小于不是真的小于，只是用于区分不同分数来存储到map中
};
struct Line//存储一条直线，只存斜率和截距
{
	Fr Slope,Incre;I Line(Con Fr& s=Fr(),Con Fr& i=Fr()):Slope(s),Incre(i){}
	I bool operator < (Con Line& o) Con {return Slope!=o.Slope?Slope<o.Slope:Incre<o.Incre;}//用于区分
};
struct Point//存储一个点
{
	#define Dot(A,B) (1LL*(A).x*(B).x+1LL*(A).y*(B).y)//点积
	#define Cro(A,B) (1LL*(A).x*(B).y-1LL*(A).y*(B).x)//叉积
	#define Len(A) Dot(A,A)//求出长度的平方，之所以不开放是为防炸精度，而且不影响比大小
	int x,y;I Point(CI a=0,CI b=0):x(a),y(b){}
	I Point operator + (Con Point& o) Con {return Point(x+o.x,y+o.y);}//点相加
	I Point operator - (Con Point& o) Con {return Point(x-o.x,y-o.y);}//点相减
}p[N+5];
struct Data//存储极角和对应点编号用于排序
{
	int pos;DB ang;I Data(CI p=0,Con DB& a=0):pos(p),ang(a){}
	I bool operator < (Con Data& o) Con {return ang<o.ang;}
}s[N<<1];
map<Line,int> pos;vector<int> v[N*N+5];map<LL,int> cnt;
int main()
{
	RI i,j,x,y,z,tot,Pc=0,H,T;RL ans=0;Line w;Point t;
	for(scanf("%d",&n),i=1;i<=n;++i) scanf("%d%d",&x,&y),p[i]=Point(x,y);
	for(i=1;i<=n;++i) for(j=i+1;j<=n;++j)
	{
		if(p[i].y==p[j].y)//特判y相等
		{
			w=Line(Fr(1,0),Fr(p[i].x+p[j].x,2)),//求出截距
			v[pos.count(w)?pos[w]:pos[w]=++Pc].push_back(p[i].y<<1);//存储中点纵坐标两倍
			continue;
		}
		t=p[j]-p[i],w=Line(Fr(-t.x,t.y),Fr(Dot(t,p[i]+p[j]),2LL*t.y)),//求出斜率和截距
		v[pos.count(w)?pos[w]:pos[w]=++Pc].push_back(p[i].x+p[j].x);//存储中点横坐标两倍
	}
	for(i=1;i<=Pc;++i) sort(v[i].begin(),v[i].end());//排序，用于之后的upper_bound
	for(i=1;i<=n;++i)//枚举点D
	{
		for(tot=0,j=1;j<=n;++j) i^j&&(s[++tot]=Data(j,atan2(p[j].y-p[i].y,p[j].x-p[i].x)),0);//存下极角
		for(sort(s+1,s+n),j=1;j^n;++j) (s[j+n-1]=s[j]).ang+=2*Pi;//排序，然后将每个点复制一份，方便后面的双指针
		for(cnt.clear(),tot=H=T=0,j=1;j^n;++j)//双指针
		{
			W(s[T+1].ang<s[j].ang+1.5*Pi-eps) ++T,tot+=cnt[Len(p[s[T].pos]-p[i])]++;//加入新进入半平面的点
			W(s[H+1].ang<s[j].ang+0.5*Pi+eps) ++H,tot-=--cnt[Len(p[s[H].pos]-p[i])];//删除新离开半平面的点
			val[s[j].pos][i]=tot;//记下结果
		}
	}
	for(i=1;i<=n;++i) for(j=i+1;j<=n;++j)//枚举AD
	{
		p[i].x^p[j].x?(x=p[i].x,y=p[j].x):(x=p[i].y,y=p[j].y),x>y&&swap(x,y),t=p[i]-p[j],//求出当前情况下对应哪种坐标
		w=(p[i].x^p[j].x?Line(Fr(t.y,t.x),Fr(Cro(t,p[i]),t.x)):Line(Fr(1,0),Fr(p[i].x,1))),//求出解析式
		#define UB(x) upper_bound(v[z].begin(),v[z].end(),x)
		pos.count(w)&&(z=pos[w],ans+=(UB((y<<1)-1)-UB(x<<1))*(val[i][j]+val[j][i]));//如果该解析式存在，更新答案
	}return printf("%lld",ans<<2),0;//注意将答案乘4
}
```

---

## 作者：λᴉʍ (赞：10)

显然枚举A，D，然后鱼头和鱼身分开来考虑。

鱼身：先枚举B,C，那么BC的中点一定在线段AD（不包含端点）上，对于每一条直线维护一个vector存所有的点，将这个BC的中点插入进线段BC的垂直平分线的vector，然后对于一组AD，鱼身的方案数是vector上AD中间的点数，可以用upper_bound求。

鱼尾：枚举D，对所有其他点极角排序，用双指针扫一遍所有点即可。具体难以描述请直接看代码

```cpp
#include<bits/stdc++.h>
#define il inline
#define rg register
#define vd void
#define ll long long
il int gi(){
    int x=0,f=0;char ch=getchar();
    while(!isdigit(ch))f^=ch=='-',ch=getchar();
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return f?-x:x;
}
int n;
template<class T>il T gcd(T a,T b){return b?gcd(b,a%b):a;}
struct number{
    ll x,y;
    number(){}
    number(const ll&a,const ll&b){
        ll g=gcd(llabs(a),llabs(b));
        x=a/g,y=b/g;
        if(y<0)x=-x,y=-y;
    }
};
il bool operator<(const number&a,const number&b){
    if(a.x^b.x)return a.x<b.x;
    return a.y<b.y;
}
il bool operator!=(const number&a,const number&b){return a.x!=b.x||a.y!=b.y;}
struct line{number k,b;};
il bool operator<(const line&a,const line&b){
    if(a.k!=b.k)return a.k<b.k;
    return a.b<b.b;
}
std::map<line,int>M;int cnt;
int x[1010],y[1010];
struct yyb{int i;double at2;}s[2010];
il bool operator<(const yyb&a,const yyb&b){return a.at2<b.at2;}
std::vector<int>vec[1000010];
il ll getdist(int a,int b){
    return 1ll*(x[a]-x[b])*(x[a]-x[b])+1ll*(y[a]-y[b])*(y[a]-y[b]);
}
int tail[1010][1010];
std::map<ll,int>mmp;
int res,nowi;
const double eps=1e-10,pi=acos(-1);
il vd insert(int x){res+=mmp[getdist(nowi,x)]++;}
il vd delet(int x){res-=--mmp[getdist(nowi,x)];}
int main(){
    //freopen("fish.in","r",stdin);
    //freopen("fish.out","w",stdout);
    n=gi();
    for(int i=1;i<=n;++i)x[i]=gi(),y[i]=gi();
    for(int i=1;i<=n;++i)
        for(int j=i+1;j<=n;++j)
            if(y[i]==y[j]){
                if(x[i]+x[j]&1)continue;
                number k=(number){1,0},b=(number){(x[i]+x[j])/2,1};
                if(M.find((line){k,b})==M.end())M[(line){k,b}]=++cnt;
                vec[M[(line){k,b}]].push_back(y[i]*2);
            }else{
                number k=(number){x[i]-x[j],y[j]-y[i]},b=(number){-1ll*(x[i]-x[j])*(x[i]+x[j])+1ll*(y[j]-y[i])*(y[j]+y[i]),2ll*(y[j]-y[i])};
                if(M.find((line){k,b})==M.end())M[(line){k,b}]=++cnt;
                vec[M[(line){k,b}]].push_back(x[i]==x[j]?x[i]*2:y[i]+y[j]);
            }
    for(int i=1;i<=n;++i){
        int m=0;
        for(int j=1;j<=n;++j)if(j!=i)s[++m]=(yyb){j,atan2(y[j]-y[i],x[j]-x[i])};
        std::sort(s+1,s+m+1);
        for(int i=1;i<=m;++i)s[i+m]=s[i],s[i+m].at2+=pi*2;
        mmp.clear();
        res=0;nowi=i;
        for(int j=1,p=0,q=0;j<=m;++j){
            while(s[p+1].at2+eps<s[j].at2+1.5*pi)insert(s[++p].i);
            while(s[q+1].at2<s[j].at2+0.5*pi+eps)delet(s[++q].i);
            tail[s[j].i][i]=res;
        }
    }
    for(int i=1;i<=cnt;++i)std::sort(vec[i].begin(),vec[i].end());
    ll ans=0;
    for(int i=1;i<=n;++i)
        for(int j=i+1;j<=n;++j){
            int xa=y[i],xb=y[j];
            if(xa==xb)xa=x[i],xb=x[j];
            if(xa>xb)std::swap(xa,xb);
            number k,b;
            if(x[i]==x[j])k=(number){1,0},b=(number){x[i],1};
            else k=(number){y[i]-y[j],x[i]-x[j]},b=(number){-1ll*x[i]*(y[i]-y[j])+1ll*y[i]*(x[i]-x[j]),x[i]-x[j]};
            if(M.find((line){k,b})==M.end())continue;
            int veci=M[(line){k,b}];
            ans+=(std::upper_bound(vec[veci].begin(),vec[veci].end(),xb*2-1)-std::upper_bound(vec[veci].begin(),vec[veci].end(),xa*2))*(tail[i][j]+tail[j][i]);
        }
    printf("%lld\n",ans*4);
    return 0;
}
```

---

## 作者：小粉兔 (赞：8)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/HNOI2019D1T1.html](https://www.cnblogs.com/PinkRabbit/p/HNOI2019D1T1.html)。

### 题意简述

略。

### 题解

鱼尾和鱼身分开考虑。

考虑固定 $D$ 点，其它点按照极角排序。

按照极角序枚举 $A$ 点，然后双指针，可以算出对于每个 $A$ 可行的鱼尾数量（$AD$ 方向为半平面的法向量方向，半平面中的点按照与 $D$ 的距离分类统计）。

然后再考虑确定 $B, C$，首先可以发现 $BC \perp AD$，所以先获取要求的 $BC$ 的斜率信息。

在 $\mathcal O (n^2)$ 的时间内预处理出每一对 $BC$ 并按照斜率分类，具体可以用最简分数存储。

在每一类中再以中点所在直线分类，那么中点必须在 $AD$ 上，找到那一类后再使用二分可以获得合法的 $BC$ 数量。

与鱼尾相乘后相加，再乘以 $4$ 即可得到答案。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <tuple>
#include <map>

typedef long long LL;

inline LL Abs(LL x) { return x < 0 ? -x : x; }
LL Gcd(LL a, LL b) { return b ? Gcd(b, a % b) : a; }

struct Vec {
	LL x, y;
	Vec() { x = y = 0; }
	Vec(LL _x, LL _y) { x = _x, y = _y; }
};
inline bool operator < (Vec a, Vec b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }
inline Vec operator + (Vec a, Vec b) { return Vec(a.x + b.x, a.y + b.y); }
inline Vec operator - (Vec a, Vec b) { return Vec(a.x - b.x, a.y - b.y); }
inline Vec operator * (LL a, Vec b) { return Vec(a * b.x, a * b.y); }
inline LL operator * (Vec a, Vec b) { return a.x * b.x + a.y * b.y; }
inline LL operator / (Vec a, Vec b) { return a.x * b.y - a.y * b.x; }
inline LL len(Vec a) { return a * a; }
inline Vec Rotate(Vec a) { return Vec(-a.y, a.x); }

typedef std::pair<std::pair<LL, LL>, LL> plll;
const int MN = 1005, MS = 499505;

int N, Cnt;
Vec P[MN];
std::map<plll, int> Num;
std::vector<Vec> D[MS];
Vec S[MN * 2];
std::map<LL, int> Buk;
LL Ans;

inline void getABC(Vec A, Vec B, LL &a, LL &b, LL &c) {
	a = B.y - A.y, b = B.x - A.x, c = A / B;
	LL d = Gcd(Abs(a), Gcd(Abs(b), Abs(c)));
	a /= d, b /= d, c /= d;
	if (a < 0 || (a == 0 && b < 0)) a = -a, b = -b, c = -c;
}

int main() {
	scanf("%d", &N);
	for (int i = 1; i <= N; ++i) scanf("%lld%lld", &P[i].x, &P[i].y);
	for (int j = 2; j <= N; ++j)
		for (int i = 1; i < j; ++i) {
			Vec A = P[i], B = P[j], C = A + B;
			Vec tA = C + Rotate(2 * A - C);
			Vec tB = C + Rotate(2 * B - C);
			LL a, b, c;
			getABC(tA, tB, a, b, c);
			int &val = Num[{{a, b}, c}];
			if (!val) val = ++Cnt;
			D[val].push_back(C);
		}
	for (int i = 1; i <= Cnt; ++i) std::sort(D[i].begin(), D[i].end());
	for (int u = 1; u <= N; ++u) {
		int M = 0;
		for (int i = 1; i <= N; ++i) if (i != u) S[++M] = P[i] - P[u];
		std::sort(S + 1, S + M + 1, [&](Vec i, Vec j) {
			int zi = i.y > 0 || (i.y == 0 && i.x > 0);
			int zj = j.y > 0 || (j.y == 0 && j.x > 0);
			if (zi == zj) return i / j > 0;
			return zi < zj;
		});
		for (int i = 1; i <= M; ++i) S[M + i] = S[i];
		LL Sum = 0;
		int lb = 1, rb = 0;
		Buk.clear();
		for (int i = 1; i <= M; ++i) {
			while (rb < i + M - 1) {
				Vec R = S[rb + 1];
				if (R * S[i] >= 0 && (R / S[i] > 0 || (R / S[i] == 0 && rb >= M))) break;
				Sum += Buk[len(R)]++;
				++rb;
			}
			while (lb <= i + M - 1) {
				Vec R = S[lb];
				if (R * S[i] < 0 || (R / S[i] > 0 || (R / S[i] == 0 && lb > M))) break;
				Sum -= --Buk[len(R)];
				++lb;
			}
			Vec A = P[u], B = S[i] + P[u];
			if (B < A) std::swap(A, B);
			LL a, b, c, Val = 0;
			getABC(2 * A, 2 * B, a, b, c);
			plll p = {{a, b}, c};
			if (Num.find(p) != Num.end()) {
				auto V = D[Num[p]];
				Val = std::lower_bound(V.begin(), V.end(), 2 * B) - std::upper_bound(V.begin(), V.end(), 2 * A);
			}
			Ans += Sum * Val;
		}
	}
	printf("%lld\n", Ans * 4);
	return 0;
}
```

---

## 作者：TLE自动机 (赞：2)

## HNOI2019 鱼 

显然，知道AD那么BC和EF可以分开算。

考虑枚举AD这条线，那么斜率和截距相同的线我们可以一起枚举（用vector）。并且注意到每条线对应的中垂线只有一条，我们可以用hash表来找。考虑把中垂线为AD的线（BC）对应到这条线上变成一个点，加入点集，权值为0，AD这条线上的点也加入到点集，权值为1，并且按x和y排好序，那么我们要找的就是在每个1点之前的权值分别为10这样的点对个数再乘上以这个点作为D点的EF的答案。

至于10的点对个数怎么算，定义$cnt1$是1的个数，$cnt0$是10这样的点对个数。每遇到0就把cnt+=cnt1，遇到1则cnt1++,那么对于每个1之前的10点对个数就是cnt。

怎么计算EF呢？我们是知道AD这条线的，那么EF对于D的极角就在一个长度为$\pi$的区间里（AD的斜率$\pm\frac \pi 2$。我们把每个D点的这些需要统计的区间离线下来，然后排好序单调队列即可。这里面还要用hash表或者unordered_map来存DE（DF）的长度，贡献维护每个长度出现次数x的$C(x,2)$之和，再乘上离线下来的点对个数。

注意我们按x和y排序，从右往左和从上往下的鱼不会被算到，还要把每个点横纵坐标取相反数再算一次。

我WA这么多次主要是精度问题，要多调参，斜率和截距可以用4个longlong来存（分子和分母）。特别注意斜率不存在的情况。

```cpp
#include<bits/stdc++.h>
#define db long double
#define ll long long
#define pr pair<ll,ll>
#define pii pair<int,int>
#define pdl pair<long double,ll>
#define fi first
#define se second
#define mpr make_pair
#define ull unsigned long long
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define ROF(i,a,b) for(int i=a;i>=b;++i)
using namespace std;
ll read(){
	ll x=0,pos=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;
	for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';
	return pos?x:-x; 
} 
int n;
const int N =1021;
struct point{
	ll x,y;
	point(ll x=0,ll y=0):x(x),y(y){} 
	point operator -(point b){
		return point(x-b.x,y-b.y);
	}
	ll dis(){
		return x*x+y*y;
	}
}p[N];
struct EFP{
	long double the;ll res;
	int operator < (EFP b){
		return the<b.the;
	}
}ef[N][N];

int cnt=0;
vector<pii>vec[1000021];
ll gcd(ll a,ll b){
	return !b?a:gcd(b,a%b);
}
int vis[1021];
const ll mod1 = 998244353,mod2=1e9+7;
const ll base = 1331,ba2=31;
struct line{
	ll kx,ky,bx,by;
	line(ll kx=0,ll ky=0,ll bx=0,ll by=0):kx(kx),ky(ky),bx(bx),by(by){}
	int hash(){
		ll h1=(((kx*base%mod1+ky)%mod1*base+bx)%mod1*base+by)%mod1;
		ll h2=(((kx*ba2%mod2+ky)%mod2*ba2+bx)%mod2*ba2+by)%mod2;
		return (h2*100000000ll+h1)%4000000;
	}
	int operator == (line bb){
		return kx==bb.kx&&ky==bb.ky&&bx==bb.bx&&by==bb.by;
	}
};
struct NODE{
	int nex,cnt;line w;
};
struct hash_table{
	NODE edge[4000021];
	int head[4000021],tup=0,nh[4000021],nt=0;
	void insert(line &now,int wi){
		int u=now.hash();
		if(!head[u]) nh[++nt]=u;
		edge[++tup].w=now;
		edge[tup].cnt=wi;
		edge[tup].nex=head[u];
		head[u]=tup;
	}
	int count(line &now){
		int u=now.hash();
		for(int i=head[u];i;i=edge[i].nex){
			if(edge[i].w==now) return edge[i].cnt;
		}
		return -1;
	}
	void clear(){
		for(int i=1;i<=tup;i++){
			edge[i].nex=edge[i].cnt=0;edge[i].w=line(0,0,0,0);
		}tup=0;
		for(int i=1;i<=nt;i++){
			head[nh[i]]=0;nh[i]=0;
		}nt=0;
	}
}d,zd;
int cntz=0;vector<pii>vecz[1000021];
inline void getmin(ll &x,ll &y){
	if(x<0&&y<0) x*=-1ll,y*=-1ll;
	if(y>0&&x<0) y*=-1ll,x*=-1ll;
	if(x==0&&y==0){
		return;
	}else if(y==0) return x=1,void();
	else if(x==0) return y=1,void(); 
	ll g=gcd(abs(y),abs(x));y/=g,x/=g;
}
inline line getline(ll dx,ll dy,ll sx,ll sy){
	getmin(dx,dy);
	ll by=sy*dx-sx*dy,bx=dx;
	getmin(bx,by);
	if(dx==0) by=sx;
	return line(dx,dy,bx,by);
}
struct node{
	db x,y;int col,id;
	node(db x=0,db y=0,int col=0,int id=0):x(x),y(y),col(col),id(id){}
}q[1021];int top=0;
node get_ty(int i,line now){
	if(now.kx==0){
		return node(now.by,p[i].y,0,0);
	}
	long double k=(long double)(now.ky)/now.kx,b=(long double)(now.by)/now.bx;
	long double x0=p[i].x,y0=p[i].y;
	long double x=(x0+y0*k-b*k)/(k*k+1.0),y=k*x+b;
	return node(x,y,0,0);
}
line getiv(line now){
	swap(now.kx,now.ky);now.ky*=-1;
	if(now.ky>0&&now.kx<0) now.ky*=-1ll,now.kx*=-1ll;
	if(now.kx==0&&now.ky==0){
		return now;
	}else if(now.ky==0) now.kx=1;
	else if(now.kx==0) return now.ky=1;
	return now;
}
const long double eps = 1e-2;
int cmp0(node a,node b){
	return fabs(a.x-b.x)<eps?fabs(a.y-b.y)<eps?a.col>b.col:a.y<b.y:a.x<b.x;
}
int cmp1(node a,node b){
	return fabs(a.x-b.x)<eps?fabs(a.y-b.y)<eps?a.col<b.col:a.y>b.y:a.x<b.x;
}
vector<pdl> c[1021];
ll ans=0;
inline void out(ll a){
	if(a>9 )out(a/10);
	putchar(a%10+'0');
}
void solve(int ord){
	FOR(i,1,n){
		FOR(j,1,n){
			if(i==j) continue;
			point tmp=(p[j]-p[i]);
			ef[i][j-(j>i)].the=atan2(tmp.y,tmp.x);
			ef[i][j-(j>i)].res=tmp.dis();
		}
		sort(ef[i]+1,ef[i]+n); 
	}
	FOR(i,1,n){
		FOR(j,i+1,n){
			if(i==j) continue;
			ll dy=(p[i].y-p[j].y),dx=(p[i].x-p[j].x);
			line now=getline(dx,dy,p[i].x,p[i].y);
			int nn=d.count(now);
			if(nn!=-1) vec[nn].push_back(mpr(i,j));
			else d.insert(now,++cnt),vec[cnt].push_back(mpr(i,j));
			
			now.bx=(p[i].x+p[j].x)/2,now.by=(p[i].y+p[j].y)/2;
			now=getline(-now.ky,now.kx,now.bx,now.by);
			nn=zd.count(now);
			if(nn!=-1) vecz[nn].push_back(mpr(i,j));
			else zd.insert(now,++cntz),vecz[cntz].push_back(mpr(i,j));
		}
	}
	for(int i=1;i<=cnt;i++){
		int d1=vec[i][0].fi,d2=vec[i][0].se;
		ll dy=(p[d1].y-p[d2].y),dx=(p[d1].x-p[d2].x);
		line now=getline(dx,dy,p[d1].x,p[d1].y);
		top=0;
		for(int j=0;j<vec[i].size();j++){
			if(!vis[vec[i][j].fi]) vis[vec[i][j].fi]=1,q[++top]=node(p[vec[i][j].fi].x,p[vec[i][j].fi].y,1,vec[i][j].fi);
			if(!vis[vec[i][j].se]) vis[vec[i][j].se]=1,q[++top]=node(p[vec[i][j].se].x,p[vec[i][j].se].y,1,vec[i][j].se);
		}
		int iv;
		int kk=zd.count(now);
		if(kk!=-1) iv=kk;
		else{
			for(int j=0;j<vec[i].size();j++){
				vis[vec[i][j].fi]=0,vis[vec[i][j].se]=0;
			}
			continue;
		}
		for(int j=0;j<vecz[iv].size();j++){
			if(!vis[vecz[iv][j].fi]) q[++top]=get_ty(vecz[iv][j].fi,now);
			vis[vecz[iv][j].fi]=1,vis[vecz[iv][j].se]=1;
		}
		for(int j=0;j<vec[i].size();j++){
			vis[vec[i][j].fi]=0,vis[vec[i][j].se]=0;
		}
		for(int j=0;j<vecz[iv].size();j++){
			vis[vecz[iv][j].fi]=0,vis[vecz[iv][j].se]=0;
		}
		sort(q+1,q+top+1,ord?cmp1:cmp0);
		ll cntt=0,cnt1=0,res=0;
		db pre=-1;int samep=0;
		for(int j=1;j<=top;j++){
			if(now.kx!=0){
				if(fabs(q[j].x-pre)<eps) samep+=q[j].col;
				else pre=q[j].x,samep=q[j].col;
			}else{
				if(fabs(q[j].y-pre)<eps) samep+=q[j].col;
				else pre=q[j].y,samep=q[j].col;
			}
			if(q[j].col==0) cntt+=cnt1-samep;
			else{
				cnt1++;
				if(now.kx<0) now.kx*=-1,now.ky*=-1;
				long double thi=atan2(now.ky,now.kx);
				if(now.kx==0){
					if(ord==0) thi=acos(-1)/2.0;
					else thi=-acos(-1)/2.0;
				}
				if(cntt){
					c[q[j].id].push_back(mpr(thi,cntt));
				//	printf("%d %d\n",i,q[j].id); 
				} 
			}
		}
	}
	for(int i=1;i<=n;i++){
		sort(c[i].begin(),c[i].end());
		long double lm,rm;
		int l=1,r=0;
		ll ri=0;unordered_map<ll,int>mp;
		for(int j=0;j<c[i].size();j++){
			lm=c[i][j].fi-acos(-1)/2.0,rm=c[i][j].fi+acos(-1)/2.0;
			while(r+1<n&&ef[i][r+1].the<rm-1e-10){
				
				r++;
				if(mp.count(ef[i][r].res)){
					ll x=mp[ef[i][r].res];ri-=x*(x-1)/2ll;ri+=(x+1)*(x)/2ll;
				}
				mp[ef[i][r].res]++;//if(i==4)  //printf("%d %lld\n",r,ri);
			}
			while(l<=r&&l<n&&ef[i][l].the<lm+1e-10){
				ll x=mp[ef[i][l].res];ri-=x*(x-1)/2ll;ri+=(x-1)*(x-2)/2ll;
				mp[ef[i][l++].res]--;//if(i==4)  //printf("%d %lld\n",l,ri);
			}
			if(!ri||!c[i][j].se) continue;
			ans+=4ll*ri*c[i][j].se;//printf("now:%d lm:%lf rm:%lf l:%d r:%d re:%d add:%lld\n",i,lm,rm,l,r,ri,4ll*ri*c[i][j].se);
		}
		c[i].clear();
	}
	for(int i=1;i<=cnt;i++){
		vec[i].clear();
	}cnt=0;
	for(int i=1;i<=cntz;i++){
		vecz[i].clear();
	}cntz=0;memset(ef,0,sizeof ef);memset(q,0,sizeof(q));d.clear(),zd.clear();top=0;
	//printf("%lld\n\n\n\n",ans);
}
int main(){
	n=read();
	FOR(i,1,n){
		p[i].x=read()*2ll,p[i].y=read()*2ll;
	}
	solve(0);
	FOR(i,1,n){
		p[i].x*=-1;p[i].y*=-1;
	}
	solve(0);
	out(ans);
	return 0;
}
```



---

## 作者：mRXxy0o0 (赞：1)

# 分析

考虑枚举 $D$ 点，对顶点在 $D$ 的等腰三角形统计鱼的下半身（$BCD$）与鱼尾的方案数。把所有等腰三角形按底边极角排序，双指针维护限制。

对于鱼头，可以认为是 $ABC$ 与 $BCD$ 拼起来得到的，枚举 $BCD$，预处理底边为 $BC$ 且异侧的等腰三角形。这两部分乘起来求和再乘 $4$ 就是总方案数。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const int N=1010,M=3e6+10,K=8e6+10;
struct node{
	int x,y;
	int id;
	inline node operator-(node a){return (node){x-a.x,y-a.y,id};}
	inline node operator+(node a){return (node){x+a.x,y+a.y,id};}
	inline ll operator*(const node a)const{return 1ll*x*a.y-1ll*y*a.x;}
}a[N],aa[N];
struct xian{
	node a,b;
}b[M],c[M],cc[M];
struct tri{
	int a,b,v;
}d[K];
inline ll len(node a){return 1ll*a.x*a.x+1ll*a.y*a.y;}
inline bool cmp3(const node &x,const node &y){return ((x.y>0||(!x.y&&x.x>=0))&&(y.y>0||(!y.y&&y.x>=0)))||((x.y<0||(!x.y&&x.x<0))&&(y.y<0||(!y.y&&y.x<0)))?x*y>0:x.y>0||(!x.y&&x.x>=0);}
inline bool cmp2(const node &x,const node &y){return ((x.y>0||(!x.y&&x.x>=0))&&(y.y>0||(!y.y&&y.x>=0)))||((x.y<0||(!x.y&&x.x<0))&&(y.y<0||(!y.y&&y.x<0)))?x*y>=0:x.y>0||(!x.y&&x.x>=0);}
inline bool cmp1(const node &x,const node &y){return len(x)==len(y)?cmp2(x,y):len(x)<len(y);}
int n,m,f[N][N];
inline void solve(){
	for(int i=2;i<=n;++i) aa[i]=a[i]-a[1];
	sort(aa+2,aa+1+n,cmp1);
	int tot=0,s=0;
	for(int l=2,r;l<=n;l=r){
		r=l;
		while(r<=n&&len(aa[r])==len(aa[l])) ++r;
		for(int i=l;i<r;++i){
			int j=(i==r-1?l:i+1);
			while(aa[i]*aa[j]>0){
				b[++tot]={aa[j]-aa[i],aa[i]};
				c[tot]=cc[tot]=(xian){(node){-aa[j].x,-aa[j].y,aa[j].id},aa[i]};
				if(c[tot].a.y<0&&c[tot].b.y>=0) ++s;
				j=(j==r-1?l:j+1);
			}
		}
	}
	sort(aa+2,aa+1+n,cmp3);
	sort(b+1,b+1+tot,[&](xian x,xian y){return cmp3(x.a,y.a);});
	sort(c+1,c+1+tot,[&](xian x,xian y){return cmp3(x.a,y.a);});
	sort(cc+1,cc+1+tot,[&](xian x,xian y){return cmp3(x.b,y.b);});
	for(int i=1,j=1,k=1;i<=tot;++i){
		while(k<=tot&&cmp2(cc[k].b,b[i].a)) ++k,--s;
		while(j<=tot&&cmp3(c[j].a,b[i].a)) ++j,++s;
		d[++m]={b[i].b.id,b[i].a.id,s};
		++f[d[m].a][d[m].b];
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d%d",&a[i].x,&a[i].y),a[i].id=i;
	for(int i=1;i<=n;++i) swap(a[1],a[i]),solve();
	ll ans=0;
	for(int i=1;i<=m;++i) ans+=1ll*d[i].v*f[d[i].b][d[i].a];
	printf("%lld",ans*4);
	return 0;
}
```

---


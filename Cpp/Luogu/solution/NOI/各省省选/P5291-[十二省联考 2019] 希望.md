# [十二省联考 2019] 希望

## 题目背景

我们所可以自慰的，想来想去，也还是所谓对于将来的希望。

希望是附丽于存在的，有存在，便有希望，有希望，便是光明。

## 题目描述

苏拉威西。距离地球进入木星洛希极限还有 $L$ 单位时间。

蔡德仁收到了来自艾莉芬的“点燃木星计划”。计划要求他将附近所有救援队召集到同一台转向发动机处，清除障碍，并用“春节十二响”程序操纵发动机点燃木星。

转向发动机共有 $n$ 个，它们由 $n - 1$ 条道路相连。任意两个转向发动机都可以通过道路互相到达，二者的距离为其间最短路径的**边数**。

附近一共部署有 $k$ 支救援队 $s_1$, $s_2$, ..., $s_k$，每一支救援队有一个救援范围。救援范围是转向发动机集合的一个连通子集，其中任意两个发动机之间道路上的所有发动机都在救援范围中。

我们称一个发动机 $u$ 可被救援范围为 $S$ 的救援队**到达**，当且仅当 $u$ 在 $S$ 中，且 $S$ 中任意一个发动机 $v$ 到 $u$ 的距离都**不大于** $L$。这样，无论救援队身在岗位的何处，他们都能在时间耗尽前抵达发动机 $u$。

蔡德仁要指挥 $k$ 支救援队集中到同一台发动机处。但由于通讯中断，蔡德仁不知
道每支救援队的救援范围。他想计算出可行的调度方案数，于是将问题输入电脑。

在这台电脑的另一面——你，需要帮他统计出，在多少种可能的部署方案中存在一
台能被所有救援队到达的发动机。一个**方案**指一组救援范围 $\left\{S_1, S_2, ..., S_k\right\}$；两个方案不同，当且仅当某个救援队 $s_i$ 在二者中的救援范围 $S_i$ 不同。在这次联合政府规划的饱和式救援中，两支队伍的救援范围可能**相交**甚至**相同**。

你知道，答案非常大。雪地车在成千上万个地标间穿梭，可能的救援范围浩如烟海，集合所有队伍的方案却寥若晨星。但你没时间绝望，甚至没时间算出那个数字。

你只能算出答案对 $998244353$ 取模的结果。

那就是希望。

即便需要取模，也是光明。

## 说明/提示

#### 样例 $1$ 解释
一共有以下几个可行的方案：

| 1 号救援队 | 2 号救援队 |
| :---------- | :---------- |
| $\texttt{\{1\}}$ | $\texttt{\{1\}}$ |
| $\texttt{\{1\}}$ | $\texttt{\{1,2\}}$ |
| $\texttt{\{2\}}$ | $\texttt{\{2\}}$ |
| $\texttt{\{2\}}$ | $\texttt{\{1,2\}}$ |
| $\texttt{\{1,2\}}$ | $\texttt{\{1\}}$ |
| $\texttt{\{1,2\}}$ | $\texttt{\{2\}}$ |
| $\texttt{\{1,2\}}$ | $\texttt{\{1,2\}}$ |

#### 样例 $2$ 解释
只有一个救援队，除了这个救援队的救援范围是全集 $\texttt{\{1,2,3,4\}}$ 之外的所有方案都可行。

#### 样例 $4$ 解释

这个测试点的图如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/yownegrq.png)

#### 子任务

![](https://cdn.luogu.com.cn/upload/image_hosting/h64qjcoa.png)

对于所有数据，有 $1 \leqslant n \leqslant 10^6$，$0 \leqslant L \leqslant n$，$1 \leqslant k \leqslant 10$。

~~**请确认程序使用了文件输入输出、没有输出多余调试信息。**~~

蔡德仁抬起头。那是他从未见过的景象——木星占据了大半个天空，绚丽的色彩透过稀薄的大气，变得格外刺眼。

无边的海洋里漂流的小船，不知何时就会被狂风所倾覆；而小船上平凡的我们，也只能怀着渺茫的希望，跟随着舵手指引的航向前行吧。

他走上前按下了 $\texttt{Enter}$。

\$ sudo ./spring12biubiu

指令已经发出。


## 样例 #1

### 输入

```
2 1 2
1 2```

### 输出

```
7```

## 样例 #2

### 输入

```
4 1 1
1 2
2 3
3 4```

### 输出

```
9```

## 样例 #3

### 输入

```
5 1 1
1 2
1 3
2 4
2 5```

### 输出

```
14```

## 样例 #4

### 输入

```
12 2 10
1 2
2 3
3 5
4 5
5 7
6 7
7 8
8 9
9 10
9 11
11 12
```

### 输出

```
953325149
```

# 题解

## 作者：TheLostWeak (赞：42)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5291.html)

**大致题意：** 给你一棵树，让你找出$k$个连通块，使得这些连通块交集中存在一点让这些连通块中任意一点到这个点的距离不超过$L$。求选择连通块的方案数。

### 容斥

考虑如果直接求每个点对答案的贡献，即找出对于每个点存在多少符合条件的连通块方案数，显然会算重。

不难发现一个结论，即对于固定的$k$个连通块，满足条件的点必然会构成一个连通块

考虑到这是一棵树，而树上连通块一个最基本的性质就是**点数$=$边数$+1$**。

所以，如果我们用每个点的贡献，减去每条边的贡献，就恰好把每种情况计算了一次。

其中边的贡献就是指满足其两端点皆符合条件的连通块方案数。

于是，这里就完成了第一步预处理。

### 暴力$DP$

接下来，我们考虑一个$O(nL)$的暴力$DP$。

设$f_{x,i}$表示**在$x$的子树内，与$x$距离不超过$i$的连通块个数$+1$**（$+1$是为了方便转移），$g_{x,i}$表示**在$x$的子树外，包括$x$且不包括$x$子树内其他节点，与$x$距离不超过$i$的连通块个数**。

然后易推得暴力转移方程：

$$f_{x,i}=(\prod f_{son_x,i-1})+1$$

由于所有距离不超过$x$的子节点$i-1$的点，与$x$的距离必然不超过$i$，因此可以这样转移。

$$g_{x,i}=(g_{fa_x,i}\prod f_{son_{fa_x}(≠x),i-2})+1$$

由于父节点的一个子节点，到当前点需要经过父节点再到达当前点，相差距离为$2$，所以要从$i-2$转移。

考虑如何计算答案。

点的贡献自然就是$((f_{x,L}-1)\cdot g_{x,L})^k$。

而对于边我们只考虑点向父亲的连边，则满足条件的连通块要到当前点及其父节点距离均不超过$L$，也就是$((f_{x,L-1}-1)(g_{x,L}-1))^k$，注意，这里$g_{x,L}$要减$1$是要除去选择$x$的贡献。

以上就是暴力$DP$的全部内容了。

### 长链剖分优化$f$

由于这个式子与节点深度有一定关系，所以我们可以用[长链剖分](https://www.cnblogs.com/chenxiaoran666/p/LongChainDissection.html)来进行优化。

考虑对于$f$，就是比较经典的长链剖分优化题，直接从长儿子那里继承贡献，非长儿子暴力转移。

注意式子后面的$+1$，这可以通过给整段数组打加法标记来解决。

但有一个细节，即我们在这里对于$f_{v}$只求到第$len_v$位，而由于我们定义为**小于等于**，所以实际上第$len_v+1\sim∞$位都是有值的，且都等于$f_{v,len_v}$。

可转移时，对于后面那些值我们不能暴力转移，不然就劣化了复杂度。

考虑如果$f_{v,len_v}$为$0$，则相当于把后面这一部分全部赋值为$0$，因此我们维护一个标记$Lim_x$表示当前$f_x$从多少位开始全部为$0$即可。

如果不为$0$，那么我们考虑给全局打一个乘法标记，然后对于序列的前面不应受乘法影响的部分暴力乘上$f_{v,len_v}$的逆元即可。

这样转移的复杂度与前面$DP$的时间复杂度是一致的，因此可以保证复杂度。

### 长链剖分优化$g$

$g$看似难搞，实际上也可以用长链剖分来转移。

考虑到$g$是由父亲向子节点转移的，因此我们可以采用与普通长链剖分类似的套路，将父节点的答案遗传给长儿子，然后非长儿子暴力转移。

但主要要考虑$\prod f_{son_{fa_x}(≠x),i-2}$怎么算。

一个比较$naive$的想法，就是可以发现这个式子相当于：

$$\frac{f_{fa_x,i-1}-1}{f_{x,i-2}}$$

这样似乎可以了？

且慢，$f_{x,i-2}$是有可能为$0$的！~~那不是凉了。~~

所以，我们要换个想法。

我们可以逐一枚举$fa_x$的子节点，然后统计当前点之前的积，求出当前点之后的积，这样就能非常方便地计算当前点的$g$值了。

当前点之前的积可以边做边统计，但当前点之后的积该怎么求，就有点麻烦了。

### 回退数据结构：求当前点之后的积

要求当前点之后的积，我们可以发现，如果我们在求$f$的时候按照子节点$len$由大到小的顺序去做，然后求$g$的时候换个方向按照子节点$len$由小到大的顺序去做，那么求$g$时当前点之后的积，就是求$f$时当前点之前的积。

而求$f$时我们是边做边统计积的，所以处理到每个点时的$f$值，其实就是当前点之前的积。

如果开棵主席树，就可以很方便地维护下后缀积，但$n=10^6$时这个$log$显得很不优秀。

于是就要用到**回退数据结构**这个神奇的东西。

说起来其实也很简单，我们把每次操作修改的值全部存下原来的值扔到一个栈里，然后每扫到一个点就将这个点栈清空，把栈中所有元素还原为原先的值。

这就是回退数据结构了。

注意这里的栈最好是使用$STL$的$list$而不是$stack$，因为$list$用指针实现，而$stack$用迭代器实现，$list$内存较小。

### 离线求逆元

回顾一下之前的全部内容，我们可以发现还有一个地方会使复杂度带上一个$log$，即对$f$进行转移时给全局打上乘法标记并暴力给不应受影响部分乘逆元时求逆元的过程。

这看起来似乎无法解决，但是，我们可以发现，我们只需使用$f_{v,len_v}$的逆元！

所以，我们可以先扫一遍求出每一个$f_{x,len_x}$，然后再将它们一起离线求一遍逆元。

什么？你问怎么离线求逆元？

假设我们要求出$a_1,a_2,a_3,...,a_t$的逆元，则我们先做一遍前缀积，使得

$$s_i=\prod_{k=1}^i a_k$$

然后我们求出$s_t$的逆元即：

$$\frac1{\prod_{k=1}^ta_k}$$

考虑用$s_{t-1}$去乘上这个式子，得到：

$$\prod_{j=1}^{t-1}a_j*\frac1{\prod_{k=1}^t a_k}=\frac1{a_t}$$

这样我们就求出了$a_t$的逆元。

则我们用$a_t$乘上$s_t$的逆元，得到$s_{t-1}$的逆元，接下来以这种方式继续搞下去就得到了所有逆元。

这种思想应该还是很妙的。

其实线性求阶乘逆元就用了这种思想。

### 代码

最后放上代码。。。顺便说明标程$800$多行是因为手写$STL$，如果直接调用$list$正常情况下也就$100$多行而已。

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 1000000
#define X 998244353
#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
#define Gmin(x,y) (x>(y)&&(x=(y)))
#define Gmax(x,y) (x<(y)&&(x=(y)))
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
#define Dec(x,y) ((x-=(y))<0&&(x+=X))
#define XSum(x,y) ((x)+(y)>=X?(x)+(y)-X:(x)+(y))
#define XSub(x,y) ((x)<(y)?(x)-(y)+X:(x)-(y))
#define pb push_back
#define Assign(x) (f[x]=pf,pf+=T.len[x]+2,pg+=T.len[x]+2,g[x]=pg-max(l-T.len[x],0),pg+=T.len[x]+2)
using namespace std;
int n,l,k,ee,ans,lnk[N+5];vector<int> e[N+5];
int _f[N<<4],_g[N<<4],*f[N+5],*g[N+5],*pf=_f,*pg=_g;
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		char c,*A,*B,FI[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
		Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
		#undef FS
}F;
I int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}//快速幂
class TreeIniter//初始化
{
	private:
		int u[N+5],w[N+5];vector<int> B[N+5];//B用于桶排，避免产生log
		I void Pre(CI x,CI lst)//初始化
		{
			RI i,j,sz,Mx;for(Inv[x]=1,i=0,sz=e[x].size();i^sz;++i) e[x][i]^lst&&
				(Pre(e[x][i],x),len[e[x][i]]>len[s[x]]&&(s[x]=e[x][i]),Inv[x]=1LL*Inv[x]*Inv[e[x][i]]%X);//求出长儿子，Inv这里求出f[x][len[x]]
			if(len[x]=len[s[x]]+1,Inc(Inv[x],1),!s[x]) return;//如果没有长儿子（即没有子节点）就退出函数
			for(Mx=i=0;i^sz;++i) e[x][i]^lst&&e[x][i]^s[x]&&
				(B[len[e[x][i]]].pb(e[x][i]),Gmax(Mx,len[e[x][i]]));//扔桶里，同时确定桶排上界
			for(i=Mx;~i;--i) {for(j=0,sz=B[i].size();j^sz;++j) S[x].pb(B[i][j]);B[i].clear();}//桶排，注意此处无需加入长儿子
		}
	public:
		int len[N+5],s[N+5],Inv[N+5];vector<int> S[N+5];
		I void Init()//初始化
		{
			RI i,x,t=0;for(len[0]=-1,Pre(1,0),w[0]=i=1;i<=n;++i) Inv[i]&&(u[++t]=i,w[t]=1LL*w[t-1]*Inv[i]%X);//统计前缀和
			for(w[t]=Qpow(w[t],X-2),i=t;i;--i) x=Inv[u[i]],Inv[u[i]]=1LL*w[i]*w[i-1]%X,w[i-1]=1LL*w[i]*x%X;//计算逆元
		}
}T;
class BackStack//回退数据结构
{
	private:
		struct Pr {int *w,v;};list<Pr> t;
	public:
		I void Ins(int& x) {t.pb(Pr{&x,x});}//加入元素
		I void Regain() {W(!t.empty()) *(t.back().w)=t.back().v,t.pop_back();}//还原
}S[N+5];
class Solver_for_F//求f
{
	private:
		int Mul[N+5],Add[N+5],IMul[N+5],Lim[N+5],Zero[N+5];
		I void dfs(CI x,CI lst)
		{
			RI ls=T.s[x];if(!T.s[x]) {Lim[x]=Mul[x]=IMul[x]=Add[x]=1;goto End;}//如果没有儿子
			f[T.s[x]]=f[x]+1,dfs(T.s[x],x),Mul[x]=Mul[T.s[x]],Add[x]=Add[T.s[x]],IMul[x]=IMul[T.s[x]],
			Lim[x]=Lim[T.s[x]]+1,Zero[x]=Zero[T.s[x]],f[x][0]=IGV(x,1);//处理长儿子，继承信息
			RI i,j,v,w,sz;for(i=0,sz=T.S[x].size();i^sz;++i)
			{
				for(v=T.S[x][i],ls=v,Assign(v),dfs(v,x),j=0;j<=T.len[v]+1;++j)
					Lim[x]==j&&(S[v].Ins(Lim[x]),S[v].Ins(f[x][j]),f[x][Lim[x]++]=Zero[x]),//更新从哪一位开始为0
					S[v].Ins(f[x][j]),f[x][j]=IGV(x,1LL*GV(x,j)*(j?GV(v,j-1):1)%X);//更新
				if(T.len[x]<=T.len[v]+1) continue;if(!(w=GV(v,T.len[v])))//如果为0
					S[v].Ins(Lim[x]),S[v].Ins(Zero[x]),Lim[x]=T.len[v]+1,Zero[x]=IGV(x,0);//特殊处理
				else
				{
					S[v].Ins(Mul[x]),S[v].Ins(Add[x]),S[v].Ins(IMul[x]),//加入
					Mul[x]=1LL*Mul[x]*w%X,Add[x]=1LL*Add[x]*w%X,IMul[x]=1LL*IMul[x]*T.Inv[v]%X;//打全局标记
					for(j=0;j<=T.len[v]+1;++j) S[v].Ins(f[x][j]),f[x][j]=IGV(x,1LL*GV(x,j)*T.Inv[v]%X);//前缀乘逆元
				}
			}S[ls].Ins(Add[x]);End:Inc(Add[x],1);//最后加1
		}
	public:
		I int GV(CI x,RI p) {return Gmin(p,T.len[x]),XSum(1LL*Mul[x]*(p<Lim[x]?f[x][p]:Zero[x])%X,Add[x]);}//求出某一位置的实际值
		I int IGV(CI x,CI v) {return 1LL*IMul[x]*XSub(v,Add[x])%X;}I void Solve() {Assign(1),dfs(1,0);}//将实际值变成序列中的值
}FS;
class Solver_for_G//求出g
{
	private:
		int u[N+5],Mul[N+5],Add[N+5],IMul[N+5],Lim[N+5],Zero[N+5];
		I void dfs(CI x,CI lst)
		{
			u[0]=1,reverse(T.S[x].begin(),T.S[x].end()),Inc(ans,Qpow(1LL*XSub(FS.GV(x,l),1)*GV(x,l)%X,k)),//翻转儿子序列，统计答案
			lst&&Dec(ans,Qpow(1LL*XSub(FS.GV(x,l-1),1)*XSub(GV(x,l),1)%X,k));if(!T.s[x]) return;//统计答案
			RI i,j,v,w,sz,Prod=1,Mx=0;for(i=0,sz=T.S[x].size();i^sz;++i)
			{
				S[v=T.S[x][i]].Regain(),Lim[v]=l+1,Mul[v]=IMul[v]=1;//还原，初始化（注意这里的数组与上面的数组不一样
				for(j=max(l-T.len[v],0);j<=l;++j) g[v][j]=
					XSum(1LL*(j?GV(x,j-1):0)*(j>1?1LL*FS.GV(x,j-1)*(j-2>Mx?Prod:u[j-2])%X:1)%X,1);//转移
				for(j=0;j<=T.len[v];++j) u[j]=1LL*(j>Mx?Prod:u[j])*FS.GV(v,j)%X;//统计某一位置之前的积
				Prod=1LL*Prod*FS.GV(v,Mx=T.len[v])%X;//统计超出长度的位置的积
			}
			g[T.s[x]]=g[x]-1,Mul[T.s[x]]=Mul[x],Add[T.s[x]]=Add[x],IMul[T.s[x]]=IMul[x],//将信息遗传给长儿子
			Lim[T.s[x]]=Lim[x]+1,Zero[T.s[x]]=Zero[x],l<=T.len[T.s[x]]&&(g[T.s[x]][0]=IGV(T.s[x],0)),
			Gmax(Lim[T.s[x]],l-T.len[T.s[x]]);for(i=0;i^sz;++i)//处理其他点对长儿子的影响
			{
				for(v=T.S[x][i],j=max(l-T.len[T.s[x]],0);j<=min(l,T.len[v]+2);++j)
					Lim[T.s[x]]==j&&(g[T.s[x]][Lim[T.s[x]]++]=Zero[T.s[x]]),//更新从哪一位开始为0
					g[T.s[x]][j]=IGV(T.s[x],1LL*GV(T.s[x],j)*(j>1?FS.GV(v,j-2):1)%X);//更新
				if(l<=T.len[v]+2) continue;if(!(w=FS.GV(v,T.len[v])))//如果为0
					Lim[T.s[x]]=T.len[v]+2,Zero[T.s[x]]=IGV(T.s[x],0);//特殊处理
				else
				{
					Mul[T.s[x]]=1LL*Mul[T.s[x]]*w%X,Add[T.s[x]]=1LL*Add[T.s[x]]*w%X,IMul[T.s[x]]=1LL*IMul[T.s[x]]*T.Inv[v]%X;//打全局标记
					for(j=max(l-T.len[T.s[x]],0);j<=min(l,T.len[v]+2);++j) g[T.s[x]][j]=IGV(T.s[x],1LL*GV(T.s[x],j)*T.Inv[v]%X);//前缀乘逆元
				}
			}
			for(Inc(Add[T.s[x]],1),dfs(T.s[x],x),i=0;i^sz;++i) (v=T.S[x][i])^lst&&(dfs(v,x),0);//处理其他儿子
		}
	public:
		I int GV(CI x,CI p) {return XSum(1LL*Mul[x]*(p<Lim[x]?g[x][p]:Zero[x])%X,Add[x]);}//与之前类似
		I int IGV(CI x,CI v) {return 1LL*IMul[x]*XSub(v,Add[x])%X;}
		I void Solve() {Mul[1]=Add[1]=IMul[1]=1,Lim[1]=l+1,dfs(1,0);}
}GS;
int main()
{
	RI i,x,y;for(F.read(n,l,k),i=1;i^n;++i) F.read(x,y),e[x].pb(y),e[y].pb(x);//读入
	return T.Init(),FS.Solve(),GS.Solve(),printf("%d",ans),0;//求解并输出答案
}
```

---

## 作者：smarthehe (赞：34)

UPD on 2021.1.8：加了一张图。

给定一棵 $n$ 个点的树，问选出 $k$ 个非空连通块使得其交集中存在一个点距离其并集中任一个点均 $\leq L$ 的方案数。对 $998244353$ 取模。

$n\leq 10^6$，$0 \leq L \leq n$，$1\leq k \leq 10$

### $V=E+1$ 容斥

令题意里交集中的那个点是关键点。一个方案可能有多个关键点，然而其必定构成连通块。对于每个点统计其为关键点的方案，然后对于每条边统计其两端均为关键点的方案，相减。树上连通块满足顶点数为边数+1。对于每个方案都会在其关键点连通块中的每个点处统计一次，在每个边处减去一次，因此会统计恰好一次。

### 树形 DP + 换根 DP

令 $f_{i,j}$ 为只在以 $i$ 为根的子树内选点，每个点距离 $i$ 不超过 $j$，所能统计出来的连通块（可能为空，如果非空则必须包括 $i$）方案数。

令 $g_{i,j}$ 为只在以 $i$ 为根的子树外与 $i$ 的并集选点，每个点距离 $i$ 不超过 $j$，所能统计出来的连通块（必须包括 $i$）方案数。

转移，令 $k$ 为 $i$ 的父亲。
$$
f_{i,j}=\prod_{x \in son_i} f_{x,j-1} +1
$$
$$
g_{i,j}=\left(\prod_{x \in son_k,x \neq i} f_{x,j-2} \right) \times g_{k,j-1} +1
$$
一个点 $i$ 的答案是
$$
((f_{i,L}-1) \times g_{i,L})^k
$$
一条边的答案在儿子点 $i$ 处统计。
$$
((f_{i,L-1} -1) \times (g_{i,L}-1))^k
$$


复杂度 $O(nL)$。

### 长链剖分 + 常数时间数据结构

分为自底而上的长链剖分与（优化 $f$）与自顶而下的长链剖分（优化 $g$）。

#### 优化 $f$

$f$ 的维护比较经典，每个点从长儿子继承贡献然后把其他长链暴力合并上来。

![](https://cdn.luogu.com.cn/upload/image_hosting/2vqfjvcv.png)

具体地，假设我们遍历到节点 $x$。如果节点 $x$ 向下深度为 $d_x$，那我们会在最终合并后的长链上存储 $f_{x,0}$ 到 $f_{x,d_x}$。

在把节点 $y$ 合并上来的时候，$f_{y,0} \rightarrow f_{x,1}$，$f_{y,1} \rightarrow f_{x,2}$，以此类推。

但是这样有一个问题：其他子树深度小于长子树深度，但考虑到状态的定义它们无可避免地会对更深的状态作出贡献。

比如 $y$ 向下深度为 $d_y$。那么对于 $f_{x,i}$（$i > d_y+1$），其仍会收到来自 $f_{y,d_y}$ 的贡献，不然答案不对。

如果暴力提供贡献，复杂度又不对。（长链剖分的线性复杂度分析源于一条长链上的点只会被合并一次，但暴力则会遍历多次同一条长链）

当然可以线段树之类维护，但如果这样就多了个 $\log$，明显又难写又不优。

注意到这只是一个后缀乘，并且如果我们能转化成除掉该后缀以后的前缀乘复杂度就对了。（这样把复杂度转化到了合并的长链上，仍能沿用如上分析）

那么我们只需要全局乘，然后把前面那部分乘逆元。维护一个 $mul$，为全局乘的 tag。

但是合并完还要全部 $+1$，没法处理。我们再维护一个 $add$，为全局加的 tag。不妨利用线段树下传思想强制令 $mul$ 比 $add$ 先作用。

在更新数据的时候也有问题。由于 $add$ 和 $mul$ 的存在，我们不知道一个数更新以后要成为什么。

> 具体情形：
>
> 数组里存的是 $x$，$add=a$，$mul=m$。
>
> 现在我们在合并另一条长链，这个位置要乘上 $y$。
>
> 这个位置的实际值是 $mx+a$，更新后的实际值应该是 $mxy+ay$。
>
> 为了得到数组中的值，减掉 $a$ 再除去 $m$，这个东西是 $xy + \dfrac{ay-a}{m}$，看上去分母约不掉，没法处理了。

维护 $imul$ 表示 $mul$ 的逆元，然后就可以处理了。

最后还有一个问题：如果后缀乘的那个东西 $f_{y,d_y}\equiv0 \pmod p$ 怎么办？此时没有逆元。

容易看到可以看作后缀赋值。如果暴力合并部分没有到达此处，这个后缀的值将一直相同。我们可以用 tag 来维护后缀同值连续段长度与这个值。

另定义 $zlim$ 为同值边界，代表从该位置以后 $f$ 值全部相同。 $zval$ 为当前的这个同值（这个值当然也受 $add$ 和 $mul$ 的影响）。 

维护方法是：

- 如果暴力合并波及到了 $zlim$ 以后的部分，就在合并时不断将 $zlim$ 后移，根据 $zval,add,mul$ 来计算真实值参与合并；

- 如果当前的这个 $f_{y,d_y}$ 是 $0$，那么更新 $zlim$，并利用 $add$ 和 $imul$ 求出一个能使得变换后为 $0$ 的值赋给 $zval$。

于是我们就利用 $add,mul,imul,zval,zlim$ 五个 tag 所构建的 $O(1)$ 数据结构完成了对 $f$ 的更新。总复杂度保持 $O(n)$。

#### 优化 $g$ 前半部分

$g$ 是一个换根 style 定义的 dp，它的转移是从父亲转向儿子的。

然而我们依旧可以尝试对其长链剖分优化。

注意到我们在遍历到每个点的时候，需要存储的状态实际上是有限的。我们对于每个节点，实际上只需要知道 $g_{x,L}$ 的值就够了，其他的存储都是为了方便更新。

观察转移式子，$g_{x,i}$ 的转移对父亲的利用仅限于 $g_{k,i-1}$，也就是只会丢失一个位置的信息。所以对于每个点 $x$ 我们实际上只需要 $g_{x,L-d_x}$ 到 $g_{x,L}$，就能让子树中所有点的有用信息都得以统计。

这个信息数量不就是长链长度嘛。

假设我们遍历到节点 $x$。如果节点 $x$ 向下深度为 $d_x$，那我们在最终合并后的长链上自顶而下存储 $g_{x,L}$ 到 $g_{x,L-d_x}$。

自底而上的长链剖分采用合并方法，自顶而下的长链剖分采用分裂方法。我们让长儿子继承父亲的信息并更新，其他长链的信息根据当前信息暴力全部处理出来。

设 $l$ 为 $x$ 的长儿子。那么 $g_{x,i}$ 会在继承后变成 $g_{l,i+1}$。把转移式列出来。
$$
g_{i,j}=\left(\prod_{x \in son_k,x \neq i} f_{x,j-2} \right) \times g_{k,j-1} +1
$$
考虑转移式里面的那个大 prod。这个大 prod 似乎可以通过 $f_{k,j-1}$ 做除法来转移？但是一旦 $f_{x,j-2} \equiv 0 \pmod p$ 就又完蛋了。

另一个思路：除了长儿子以外的其他儿子都是长链链顶，它们的 $f$ 信息保存完好，没有在合并中丢失。定下一个固定的儿子枚举顺序，这样我们在算到当前儿子的时候可以顺带处理出前缀的这个 prod 数组（需要一个类似的处理 $f$ 时的数据结构，但只需要维护 $mul$ 和 $zlim$），就只需要解决后缀的 prod 数组了。

似乎我们在之前处理 $f$ 的时候，我们枚举儿子的时候也可以顺便得出一部分儿子的这个 $f$ 乘积信息？能不能尝试存下来？

我们令枚举儿子的时候，在处理 $f$ 时按深度从深到浅枚举，处理 $g$ 时反向。这个排序过程可以利用桶排，把所有点的所有儿子塞进去一并排序，这样还是线性的。

每次合并长链的时候，只有那两个 tag 和等同于长链长度的信息会被更改。于是可以强行套上可持久化数组，每个版本基于上一个版本进行等同于合并上长链的长度次数的更改，并对于每个版本再维护两个 tag，这样根据长链剖分的复杂度分析，时空是 $O(n\log n)$ 的。 

这里的一个细节是初始版本的存储问题。由于时空原因我们肯定不能把整条长链的信息拉出来做初始版本。注意到只需要 $f_{i,L-mxd_k-1}$ 到 $f_{i,L-1}$，其中 $mxd_k$ 为以 $k$ 的儿子为根的子树中除去长子树外的最大深度。这样时空就对了。实际上对于每个版本也不需要求所有更改，只需要存储 $f_{i,L-d_x-1}$ 到 $f_{i,L-1}$ 这些值就好了。

对于每个非长儿子，我们枚举所有应计算出的信息，用存好的 prod 数组和可持久化数组求这个系数。

对于长儿子，我们在枚举其他儿子的时候顺带在上面乘好。此处也有后缀乘、整体加和查询的需求。利用那五个 tag 构建一个同样的 $O(1)$ 数据结构来维护。

但是由于带了可持久化的问题，不仅有 $\log$，常数还大，完全不优。

### 优化 $g$ 后半部分——回退化数据结构

发现对版本的询问是有规律的：我们只会倒序枚举版本，从最新枚举到最旧。

这样我们可以强行将每次需要的部分直接打包存储成为一个版本，然后把所有版本压成栈，每查询一次便弹出一个版本。复杂度还是对的。

总复杂度保持 $O(n)$……？

### 线性求逆元

等等，我们忘掉了什么。

在处理 $f$ 和 $g$ 的时候，好像用到了逆元。那不就得快速幂求吗？我们算法的常数已经很大，$O(n \log p)$ 显得更加不可接受。

但是注意到，对于每个 $x$，我们只需要 $f_{x,d_x}$ 的逆元。而这个东西就是没有 $L$ 限制的子树连通块个数，有一个非常简易的 $O(n)$ dp 能求出所有点的 $f_{x,d_x}$。这样就可以把所有 $f_{x,d_x}$ 拉出来线性求逆元了。

具体地，将其排成数列，排除 0 项，然后处理前缀积，后缀积，并求出全部之积的逆元。每个数的逆元只需要用前缀积、后缀积与全部之积的逆元相乘可得。复杂度 $O(n)$。

### 收束 & 遗憾

然而这个答案式的 $k$ 次方实在是无法消掉……不过这部分常数很小。最终的复杂度是 $O(n\log k)$。

总结一下步骤：

1. 利用 $V=E+1$ 容斥拆分问题。
2. 预处理所有 $f_{x,d_x}$，线性求逆元；预排序所有点的所有儿子。
3. 扫一遍求 $f$，深度从深到浅枚举所有儿子，并使用五 tag $O(1)$ 数据结构配合长链剖分优化。过程中处理出后缀 prod 数组中每个对应部分，将其压栈。为了防止之后信息被破坏，将需要用于统计答案的 $f_{i,L}$ 与 $f_{i,L-1}$ 存好。
4. 扫一遍求 $g$，深度从浅到深枚举所有儿子。利用 $g_{i,L}$ 和提前存好的 $f$ 处理出该点的答案（以及到父亲的那条边的答案）。使用两 tag $O(1)$ 数据结构维护前缀 prod 数组，五 tag $O(1)$ 数据结构配合长链剖分优化。

---

## 作者：yzhang (赞：21)

ytq鸽鸽出的题真是毒瘤

[原题传送门](https://www.luogu.org/problem/P5291)

[更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/11300018.html)

### 题目大意：

有一棵有$n$个点的树，求有多少方案选$k$个联通块使得存在一个中心点$p$，所有$k$个联通块中所有点到$p$的距离都$\leq L$

我们先从部分分考虑：

### 算法1

$2^{nk}$枚举联通快判断是否可行

期望得分：8pts

代码就不给了

### 引理1

对于任意一个联通块，可能成为它的中心点的点组成的集合也是一个联通块。正确性显然

- 推论

这里作为$k$个联通块中心点的点组成的集合是一个联通块

### 算法2

枚举推论中中心点组成的集合，判断其他是否满足

期望得分：16pts

代码也不给了

### 引理2

注意到树上联通块中，点集为$S$,边集为$E$，有$|S|-|E|=1$。正确性显然

这样我们就珂以对每个点、边单独考虑，通过容斥算出答案。设$f(x)$表示$x$控制的联通块个数，$g(e)$表示$e$两端点都控制的联通块个数，易知答案为

$$\sum_{v \in V}f(v)^k-\sum_{e \in E}g(e)^k$$

### 算法3

我们考虑dp，设$f_{i,j}$表示$i$点子树中距离$i$不超过$j$且包含$i$的个数，$g_{i,j}$表示$i$点子树外距离$i$不超过$j$且包含$i$的个数，转移如下：

$$f_{i,j}=\prod_{v \in son(i)}(f_{v,j-1}+1)$$

$$g_{i,j}=g_{fa_i,j-1}\prod_{v \in son(fa_i),v \neq i}(f_{v,j-2}+1)+1$$

对于每个点$i$，对答案的贡献为：

$$(f_{i,L}·g_{i,L})^k$$

对于每条边$e$(设$v$为深度更深的点)，对答案的贡献为：

$$-(f_{v,L-1}·(g_{v,L}-1))^k$$

时间复杂度：$O(nL)$

期望得分：36pts

### 算法4:

对于$L=n$的测试点，第二维的限制没用了，去掉即可

时间复杂度：$O(n)$

期望得分：结合算法3可得48pts

### 算法5：

对于链的情况，珂以手推一下dp的贡献，发现就是距离，算一下即可

时间复杂度：$O(n)$

期望得分：结合算法4可得52pts

这是暴力52pts的做法，代码如下，subtask1是算法3，subtask2是算法4，subtask3是算法5

```cpp
#include <bits/stdc++.h>
#define mod 998244353
#define N 100005
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int power(register int a,register int b)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=1ll*res*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return res;
}
struct egde{
    int to,next;
}e[N<<2];
int head[N<<1],cnt=0;
inline void add(register int u,register int v)
{
    e[++cnt]=(egde){v,head[u]};
    head[u]=cnt;
}
int n,m,k,ans;
namespace subtask1{
    vector<int> f[N],g[N];
    inline void dfs1(register int x,register int fa)
    {
        for(register int i=head[x];i;i=e[i].next)
        {
            int v=e[i].to;
            if(v==fa)
                continue;
            dfs1(v,x);
            for(register int j=1;j<=m;++j)
                f[x][j]=1ll*f[x][j]*(f[v][j-1]+1)%mod;
        }
    }
    inline void dfs2(register int x,register int fa)
    {
        static int son[N],pre[N],suf[N];
        int cnt=0;
        for(register int i=head[x];i;i=e[i].next)
            if(e[i].to!=fa)
                son[++cnt]=e[i].to;
        for(register int i=pre[0]=suf[cnt+1]=1;i<=m;++i)
        {
            if(i>=2)
            {
                for(register int j=1;j<=cnt;++j)
                    pre[j]=1ll*pre[j-1]*(f[son[j]][i-2]+1)%mod;
                for(register int j=cnt;j>=1;--j)
                    suf[j]=1ll*suf[j+1]*(f[son[j]][i-2]+1)%mod;
            }
            else
            {
                for(register int j=1;j<=cnt;++j)
                    pre[j]=suf[j]=1;
            }
            for(register int j=1;j<=cnt;++j)
                g[son[j]][i]=(1ll*g[x][i-1]*pre[j-1]%mod*suf[j+1]+1)%mod;
        }
        for(register int i=head[x];i;i=e[i].next)
        {
            int v=e[i].to;
            if(v==fa)
                continue;
            ans=(ans+power(1ll*(g[v][m]-1)*f[v][m-1]%mod,k))%mod;
            dfs2(v,x);
        }
    }
    inline void solve()
    {
        for(register int i=1;i<=n;++i)
            f[i].resize(m+1,1),g[i].resize(m+1,1);
        dfs1(1,0);
        dfs2(1,0);
        ans=mod-ans;
        for(register int i=1;i<=n;++i)
            ans=(0ll+ans+power(1ll*f[i][m]*g[i][m]%mod,k))%mod;
        write(ans);
    }
}
namespace subtask2{
    int a[200005],b[200005];
    inline void dfs1(register int x,register int fa)
    {
        for(register int i=head[x];i;i=e[i].next)
        {
            int v=e[i].to;
            if(v==fa)
                continue;
            dfs1(v,x);
            a[x]=1ll*a[x]*(a[v]+1)%mod;
        }
    }
    inline void dfs2(register int x,register int fa)
    {
        static int son[200005],pre[200005],suf[200005];
        int cnt=0;
        for(register int i=head[x];i;i=e[i].next)
            if(e[i].to!=fa)
                son[++cnt]=e[i].to;
        pre[0]=suf[cnt+1]=1;
        for(register int j=1;j<=cnt;++j)
            pre[j]=1ll*pre[j-1]*(a[son[j]]+1)%mod;
        for(register int j=cnt;j>=1;--j)
            suf[j]=1ll*suf[j+1]*(a[son[j]]+1)%mod;
        for(register int j=1;j<=cnt;++j)
            b[son[j]]=(1ll*b[x]*pre[j-1]%mod*suf[j+1]+1)%mod;
        for(register int i=head[x];i;i=e[i].next)
        {
            int v=e[i].to;
            if(v==fa)
                continue;
            ans=(ans+power(1ll*(b[v]-1)*a[v]%mod,k))%mod;
            dfs2(v,x);
        }
    }
    inline void solve()
    {
        for(register int i=0;i<=n;++i)
            a[i]=b[i]=1;
        dfs1(1,0);
        dfs2(1,0);
        ans=mod-ans;
        for(register int i=1;i<=n;++i)
            ans=(ans+power(1ll*a[i]*b[i]%mod,k))%mod;
        write(ans);
    }
}
namespace subtask3{
    inline void solve()
    {
        for(register int i=1;i<=n;++i)
        {
            int l=max(1,i-m),r=min(n,i+m);
            ans=(ans+power(1ll*(i-l+1)*(r-i+1)%mod,k))%mod;
        }
        for(register int i=2;i<=n;++i)
        {
            int l=max(1,i-m),r=min(n,i+m-1);
            ans=(ans+mod-power(1ll*(i-l+1-1)*(r-i+1)%mod,k))%mod;
        }
        write(ans);
    }
}
int main()
{
    n=read(),m=read(),k=read();
    if(n<=200000)
    {
        for(register int i=1;i<n;++i)
        {
            int u=read(),v=read();
            add(u,v),add(v,u);
        }
    }
    if(m==n&&n<=200000)
        subtask2::solve();
    else if(n<=100000)
        subtask1::solve();
    else
        subtask3::solve();
    return 0;
}
```

### 算法6

发现$f,g$的转移珂以用长链剖分优化，套上一个可持久化数据结构，需要资瓷区间加、区间乘

时间复杂度：$O(n\log n)$

期望得分：结合算法5可得84pts

### 算法7

发现是全局加，后缀乘，这样可以像[SDOI2019Day1T1 快速查询](https://www.cnblogs.com/yzhang-rp-inf/p/10961064.html)

珂以用数组线性维护，为了去掉求逆元的$log$，我们珂以用类似于求阶乘逆元的方法$O(n)$预处理要用的逆元

至此，我们得到了一个$O(n)$的做法

期望得分:100pts

```cpp
#include <bits/stdc++.h>
#define mod 998244353
#define N 1000005
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int power(register int a,register int b)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=1ll*res*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return res;
}
struct edge{
    int to,next;
}e[N<<1];
int head[N],cnt=0;
inline void add(register int u,register int v)
{
    e[++cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
int n,m,k;
int dp[N],son[N],len[N],val[N],idx[N],tot,inv[N];
int arr[N<<3],*pos=arr,*f[N<<1],*g[N],ans[2][N],Ans;
inline void dfs1(register int x,register int fa)
{
    dp[x]=1;
    for(register int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa)
            continue;
        dfs1(v,x);
        son[x]=len[v]>len[son[x]]?v:son[x];
        dp[x]=1ll*dp[x]*dp[v]%mod;
    }
    if(++dp[x]<mod)
        val[idx[x]=++tot]=dp[x];
    len[x]=len[son[x]]+1;
}
inline void init_inv()
{
    static int pre[N];
    for(register int i=pre[0]=1;i<=tot;++i)
        pre[i]=1ll*pre[i-1]*val[i]%mod;
    int pre_inv=power(pre[tot],mod-2);
    for(register int i=tot;i;--i)
        inv[i]=1ll*pre[i-1]*pre_inv%mod,pre_inv=1ll*pre_inv*val[i]%mod;
}
struct node{
    int a,b,inv,pos,num;
};
namespace F{
    node tag[N<<1];
    vector<pair<node,vector<pair<int,int> > > >backup[N];
    inline int get(register int u,register int i)
    {
        int res=i<tag[u].pos?f[u][i]:tag[u].num;
        return (1ll*res*tag[u].a+tag[u].b)%mod;
    }
    inline void put(register int u,register int i,register int v)
    {
        f[u][i]=1ll*(v+mod-tag[u].b)*tag[u].inv%mod;
    }
    inline void merge(register int u,register int v,register int l)
    {
        node tmp=tag[u];
        vector<pair<int,int> >vec;
        for(register int i=1;i<=l;++i)
        {
            vec.push_back(make_pair(i,f[u][i]));
            int val=get(v,i-1);
            if(i==tag[u].pos)
                f[u][tag[u].pos++]=tag[u].num;
            put(u,i,1ll*get(u,i)*val%mod);
        }
        if(l<m)
        {
            int val=get(v,l);
            if(!val)
                tag[u].pos=l+1,tag[u].num=mod-1ll*tag[u].b*tag[u].inv%mod;
            else
            {
                int t=inv[idx[v]];
                vec.push_back(make_pair(0,f[u][0]));
                for(register int i=0;i<=l;++i)
                    put(u,i,1ll*get(u,i)*t%mod);
                tag[u].a=1ll*tag[u].a*val%mod;
                tag[u].b=1ll*tag[u].b*val%mod;
                tag[u].inv=1ll*tag[u].inv*t%mod;
            }
        }
        if(u<=n)
            backup[u].push_back(make_pair(tmp,vec));
    }
    inline void dfs2(register int x,register int fa)
    {
        if(son[x])
            f[son[x]]=f[x]+1,dfs2(son[x],x),tag[x]=tag[son[x]];
        else
            tag[x]=(node){1,1,1,n,0};
        put(x,0,1);
        for(register int i=head[x];i;i=e[i].next)
        {
            int v=e[i].to;
            if(v==fa||v==son[x])
                continue;
            f[v]=pos;
            pos+=len[v];
            dfs2(v,x);
            merge(x,v,min(len[v]-1,m));
        }
        ans[0][x]=get(x,min(len[x]-1,m-1));
        ans[1][x]=get(x,min(len[x]-1,m));
        ++tag[x].b;
    }
    inline void rollback(register int u)
    {
        tag[u]=backup[u].back().first;
        for(register int i=0;i<(backup[u].back().second).size();++i)
            f[u][(backup[u].back().second)[i].first]=(backup[u].back().second)[i].second;
        backup[u].pop_back();
    }
}
namespace G{
    node tag[N];
    inline int get(register int u,register int i)
    {
        int res=i<tag[u].pos?g[u][i]:tag[u].num;
        return (1ll*res*tag[u].a+tag[u].b)%mod;
    }
    inline void put(register int u,register int i,register int v)
    {
        g[u][i]=1ll*(v+mod-tag[u].b)*tag[u].inv%mod;
    }
    inline void dfs3(register int x,register int fa)
    {
        if(len[x]-m-1>=0)
            put(x,len[x]-m-1,1);
        Ans=(Ans+power(1ll*ans[1][x]*get(x,len[x]-1)%mod,k))%mod;
        if(fa)
            Ans=(Ans-power(1ll*ans[0][x]*(get(x,len[x]-1)+mod-1)%mod,k)+mod)%mod;
        if(!son[x])
            return;
        vector<int> ch;
        int maxlen=0;
        for(register int i=head[x];i;i=e[i].next)
        {
            int v=e[i].to;
            if(v==fa||v==son[x])
                continue;
            ch.push_back(v);
            maxlen=max(maxlen,len[v]);
        }
        maxlen=min(maxlen,m);
        reverse(ch.begin(),ch.end());
        f[x+n]=pos;
        pos+=maxlen+1;
        F::tag[x+n]=(node){1,1,1,n,0};
        F::put(x+n,0,1);
        for(register int id=0;id<ch.size();++id)
        {
            int v=ch[id];
            F::rollback(x);
            g[v]=pos;
            pos+=len[v];
            for(register int i=max(len[v]-m-1,0);i<len[v];++i)
            {
                if(m-len[v]+i==-1)
                    g[v][i]=get(x,len[son[x]]-len[v]+i);
                else
                    g[v][i]=1ll*get(x,len[son[x]]-len[v]+i)*F::get(x,min(len[x]-1,m-len[v]+i))%mod*F::get(x+n,min(maxlen,m-len[v]+i))%mod;
            }
            tag[v]=(node){1,1,1,n,0};
            F::merge(x+n,v,min(len[v]-1,m));
            dfs3(v,x);
        }
        int v=son[x];
        g[v]=g[x];
        tag[v]=tag[x];
        for(register int i=max(len[v]-m,0);i<=len[v]+maxlen-m-1;++i)
        {
            if(tag[v].pos==i)
                g[v][tag[v].pos++]=tag[v].num;
            put(v,i,1ll*get(v,i)*F::get(x+n,m-len[v]+i)%mod);
        }
        if(maxlen<m)
        {
            int vv=1,tt=1;
            for(register int i=0;i<ch.size();++i)
                vv=1ll*vv*val[idx[ch[i]]]%mod,tt=1ll*tt*inv[idx[ch[i]]]%mod;
            if(!vv)
                tag[v].pos=len[v]+maxlen-m,tag[v].num=mod-1ll*tag[v].b*tag[v].inv%mod;
            else
            {
                for(register int i=max(len[v]-m-1,0);i<=len[v]+maxlen-m-1;++i)
                    put(v,i,1ll*get(v,i)*tt%mod);
                tag[v].a=1ll*tag[v].a*vv%mod;
                tag[v].b=1ll*tag[v].b*vv%mod;
                tag[v].inv=1ll*tag[v].inv*tt%mod;
            }
        }
        ++tag[v].b;
        dfs3(v,x);
    }
}
int main()
{
    n=read(),m=read(),k=read();
    for(register int i=1;i<n;++i)
    {
        int u=read(),v=read();
        add(u,v),add(v,u);
    }
    dfs1(1,0);
    init_inv();
    f[1]=pos;
    pos+=len[1];
    F::dfs2(1,0);
    g[1]=pos;
    pos+=len[1];
    G::tag[1]=(node){1,1,1,n,0};
    G::dfs3(1,0);
    write(Ans);
	return 0;
}
```

---

## 作者：Moeebius (赞：11)

## 前言

> 苏拉威西。距离地球进入木星洛希极限还有 $L$ 单位时间。

冰封的大地上，$N$ 台转向发动机构成了**树形结构**。第 $i$ 支救援队可以到达树上的第 $i$ 个**连通块**，连通块之间可以相交也可以包含。

一种部署方案可行，当且仅当存在一个「集合点」$p$，使得任意一个出现在某一连通块中的点 $x$ 到 $p$ 的距离都不超过 $L$。

这就是希望。

---

## 分析，容斥，DP，观察

> 可能的救援范围浩如烟海，集合所有队伍的方案却寥若晨星。

你的眼前浮现出了一张画有一种部署方案的地图。你很快找到了地图上的两个 **不相邻** 的点 $(u,v)$，满足 $u,v$ 都是可行的集合点。

你想象着，如果集合点从 $u$ 向 $v$ 的方向移动一格到达 $w$，会发生什么。

是的，这意味着：
- $u$ 一侧的点（蓝色）到集合点的距离会增大，但是不会超过到达 $v$ 的距离。
- $u-v$ 路径上的点（黄色）到集合点的距离严格不增。
- $v$ 一侧的点（红色）到集合点的距离会减小。

【缺一张图】

你猛然意识到：$u-v$ 路径上的所有发动机都是可行的！

也就是说，**对于一种方案，可行的集合点同样构成树上的一个连通块 $K$**。

---

你试图枚举集合点，但是失败了。一组部署方案可能存在多个集合点，你无力消去重复的方案……吗？

绝望之时，你想起了刚学 OI 时记住的话。

> 树的边数等于点数减一。

你恍然大悟。我们对于每个点，统计其作为可行集合点的方案数，其总和记作 $s_1$；对于每条边，统计其两端点都为可行集合点的方案数，其总和记作 $s_2$。考虑 $s_1-s_2$，对于每种可行方案，其都会在 $s_1$ 中被统计 $|K|$ 次，在 $s_2$ 中被统计 $|K|-1$ 次，相减之后，问题迎刃而解。

由于每支救援队的可行集合点是独立的，我们只需要考虑只有一支救援队的情况，对于 $k$ 支队伍，每个点的答案即为一支队伍情况的 $k$ 次方。

你自然而然地将地图看作一棵有根树，进行树形 DP。

你发现，$s1$ 和 $s2$ 的求解具有很大的相似性。$s1$ 相当于限制集合点到连通块最远点的 **距离不超过 $L$**；而对于 $s2$，我们在每条边较深的端点 $x$ 处统计答案，则相当于在 $s1$ 限制的基础上，强制选上端点的父亲，并且要求 $x$ 子树内 **距离不超过 $L-1$**。

为了方便处理，你将答案拆分成子树内和子树外两部分，这样计算 $s2$ 时只需将子树外答案减 $1$。

记 $f_{i,j}$ 表示以 $i$ 为根的子树中，选出一个到点 $i$ 的最大距离 **不超过** $j$ 的连通块的方案数 **加 $1$**。记 $g_{i,j}$ 表示 $i$ 子树外，选出一个到点 $i$ 的最大距离不超过 $j$ 的连通块的方案数。

有转移：

$$
f_{i,j+1} = 1 + \prod_{v \in son_i} f_{v,j} \\
g_{i,j} = 1 + g_{fa_i,j-1} \prod_{v\in son_{fa_i} \land v \neq i} f_{v,j-2}
$$

最后

$$
s1 = \sum_{i}((f_{i,L}-1)g_{i,L})^k \\
s2 = \sum_{i}((f_{i,L-1}-1)(g_{i,L}-1))^k \\
ans = s1 - s2
$$

这些对于身经百战的你来说，自然驾轻就熟。为了验证你的想法的正确性，你敲下了[这种思路的朴素实现](https://www.luogu.com.cn/record/185781541)。

```bash
$ make test
Running on test #1...
passed.
...
Running on test #9...
passed.
Running on test #10...
[1]    33848 cpu limit exceeded  ./hope < 10.in > 10.out
failed on test 10!
```

---

如何优化？你陷入了沉思。

每个点的 DP 数组有两维，其中 $f$ 的第二维有意义的值域不超过子树深度，因此大概可以长剖优化；而 $g$ 的第二维你暂时没有想法。

你再次审视稿纸上的最后三个柿子。你注意到，在叶子结点 $p$，我们只会用到 $g_{p,L}$，为了计算它，在 $fa_p$ 我们只会用到 $g_{p,L-1}$ 和 $g_{p,L}$，以此类推。也就是说，**$g$ 的第二维的有效值域同样被子树最大深度控制。**

因此，你勾勒出了解法的大致轮廓：

- 使用树上联通块的性质，通过「点减边」容斥防止算重；
- 转化后的问题通过树形 DP 解决，拆成子树内和子树外分开计算；
- 两次树形 DP 过程中，DP 数组第二维有效值域都被子树最大深度控制，因此大概率可以通过长链剖分优化。

“剩下就全是 dirty work 了。”你自语道。

## 标记，逆元

你很清楚长剖优化 DP 的基本形式：

- 对于长儿子，我们要在 $O(1)$ 的时间复杂度内继承其答案；
- 对于其他儿子 $p$，我们要在 $O(\text{mxdep}_p)$ 的时间复杂度内加入其贡献，其中 $\text{mxdep}_p$ 表示点 $p$ 子树最大深度。

这样，总时间复杂度是线性的。由于你追求完美，你不能容忍复杂度内有任何 $\log$ 因子。（此处我们认为 $\log k$ 是常数，而 $\log V$ 不是，其中 $V$ 为取模后的值域）

先考虑如何转移 $f_x$。长儿子并不困难，但是对于其他儿子 $p$，由于状态的定义中出现了“不超过”，$f_{p,\text{mxdep}_p}$ 势必会对 $f_x$ 一段后缀产生贡献。转移结束后，还要进行全局加 $1$。

你需要支持后缀乘，单点乘，全局加。

由于严苛的复杂度限制，你不能使用任何「高级」的数据结构。所以后缀乘极其困难。

但是你很快意识到，你可以将后缀乘改成全局乘，只要在前面抵消掉这部分影响即可……吗？

你猛然意识到，逆元可能不存在。

但是这似乎没有很大的影响——毕竟后缀乘 $0$ 相当于后缀清 $0$，我们可以再维护一套标记 $(lst,val)$ 表示 $\ge lst$ 的位置都是 $val$，如果访问到了「懒惰赋值」即可。

就算存在逆元，也需要精细实现以避免 $\log V$ 因子。由于 $f_{\text{mxdep}_v}$ 是好求的，你决定先将其预处理出来，[再跑离线 $O(n)$ 逆元](https://oi-wiki.org/math/number-theory/inverse/#%E7%BA%BF%E6%80%A7%E6%B1%82%E4%BB%BB%E6%84%8F-n-%E4%B8%AA%E6%95%B0%E7%9A%84%E9%80%86%E5%85%83)。

（当然你后来意识到，也可以使用那个叫做 [在线 $O(1)$ 逆元](https://www.cnblogs.com/qiulyqwq/p/17410552.html) 的科技）

剩下只有单点乘，全局加，全局乘，使用 $(k,b)$ 两个 tag 表示数组中的 $x$ 对应真实值为 $kx+b$ 即可。

由于长剖转移过程中会损失一部分信息，你需要在完成对一个点的转移后保存 $f_{x,L}$ 和 $f_{x,L-1}$。

---

$g$ 数组如何维护呢？看起来是类似的。

你回想你的朴素实现——你维护了 $f$ 对应位置的前后缀积。在这里，前缀积可以在处理 $f$ 时顺便保存，因为向 $p$ 这个非长儿子转移时所需的（第二维）有效值域同样被 $p$ 的子树深度控制，存下所有位置的值复杂度正确。

后缀积同样可以通过类似前缀积的方式维护（注意前缀积包含长儿子贡献，但后缀积不包含）。

于是你已经会算出非长儿子的 $g$ 数组了。

你发现，对于长儿子，这样「倒着长剖」同样可以沿用经典的内存池写法，但是我们需要倒着保存 $g$ 数组——$g'_{i,j}$ 表示实际的 $g_{i,L-j}$。这样，$g$ 的下标会被正确调整到长儿子所需的样子。

你只需要将其他儿子的 $f$ 带来的贡献计入即可。

你决定在 $g$ 上也维护一套类似的标记——只不过由于你反转了下标，后缀乘变成了前缀乘，但这无伤大雅。

你意识到，你已经几乎走到了终点。

你只需要把你的想法变成代码。

良好的封装，清晰的马蜂，在这时候总是有用的。将需要多次使用的逻辑写成函数，把相关度大的东西捆绑成 `struct`，assertion 和一些调试技巧，在这里都是有用的。

## 后记

```bash
$ make test
Running on test #1...
passed.
...
Running on test #24...
passed.
Running on test #25...
passed.
All tests passed.
Max time: 6.88s / Max memory: 292.29MB
$ scp hope.cpp common-ants@xxx.xxx.xxx.xxx -i key1.pem
hope.cpp                                    100% 12.31KB 10.3KB/s   00:01
```

> 蔡德仁抬起头。那是他从未见过的景象——木星占据了大半个天空，绚丽的色彩透过稀薄的大气，变得格外刺眼。

电脑前的你站起身，望着窗外冰封的大地，巨大的星球，深邃的太空。

你不知道未来的路将通往何处，你也不知道这次救援计划能否成功。

但你还是选择了希望。即便需要取模，也是光明。

---

## 作者：GK0328 (赞：10)

**~~[十二省联考2019]绝望~~**

### 长链剖分优化$DP$

$O(nL)DP$：我们考虑单独计算每一个节点的贡献，但是这样做显然有问题，因为对于一个连通块集合来说，不仅仅有一个点是满足要求的。

那么我们可以考虑**容斥**计算答案，这就需要挖掘题目中的性质。显然满足题意的点集一定形成一个连通块，因为我们很容易发现对于两个满足条件的点$u,v$来说，$u \rightarrow v$的路径上的点一定符合题意。

树上的连通块依然是一棵树，那么必然满足边数$=$点数$-1$，所以我们通过满足题意的点的贡献减去满足题意的边的贡献即可得到最终的答案。

单独统计点和边的贡献较容易计算。

由于与一个点有关的边要么来自它的子树，要么来自父亲，我们就可以记录这两方面的答案进行计算。

$f_{u,i}$表示$u$子树内，所有点与$u$距离不超过$i$的连通块个数（当然计算的连通块必然包括$u$节点）$+1$（$+1$是为了便于计算）。

$$
f_{u,i}=\prod_{v \in son_u} f_{v,i-1}+1
$$

$g_{u,i}$表示所有点与$u$距离不超过$i$的，包含$u$且不包含任何$u$子树内节点，向$fa_u$方向延伸出来的连通块个数。

$$
g_{u,i}=(g_{fa_u,i-1} \prod_{v \in son_{fa_u},v \ne u} f_{v,i-2})+1
$$

考虑点的贡献，应该是：

$$
\sum_{u}( (f_{u,L}-1)g_{u,L})^k
$$

边的贡献：

$$
\sum_{u} ((f_{u,L-1}-1)(g_{u,L}-1))^k
$$

$$
ans=\sum_{u}( (f_{u,L}-1)g_{u,L})^k-((f_{u,L-1}-1)(g_{u,L}-1))^k
$$


这道题的数据范围是$n \le 10^6$，而且$dp$方程明显与深度有关，因此我们可以考虑**长链剖分**优化。

$len_u$表示$u$所在长链底部与$u$的之间路径中的点数。

比较容易的是$f$（~~当然也不是那么容易~~）。

$$
f_{u,i}=\prod_{v \in son_u} f_{v,i-1}+1
$$

$problem1:f_{u,i}(i \ge len_u)$同样有意义，而不是$0$。

$problem2:$本题的式子中含有整体$+1$操作。

$problem3:$对于$f_{v,i}(v \in son_u)$，它会对$f_{u,t}(t \ge i)$产生贡献，如果暴力转移，时间复杂度就会不正确。

对于$problem1$，由于$f_{u,i}(i \ge len_u)=f_{u,len_u}$我们可以打一个标记$pos$，记录到达哪一位的值是相同的，同时记录那一位的值。

对于$problem2$，我们可以打上加法标记和乘法标记，实现$O(1)$修改。

对于$problem3$，由于采用了长链剖分，显然轻子树深度不会超过$f$数组范围，那么对于$i < len_v$的情况暴力转移是符合线性复杂度的。因此，我们只需要考虑$f_{v,len_v-1}$的贡献（因为$f_{v,t}(t \ge len_v)=f_{v,len_v-1}$中），然后尝试对于后面的答案一次性合并。分两种情况，如果$f_{v,len_v-1} \equiv 0 \pmod{998244353}$，那么$f_{u,len_v}$以后的值都会乘上它，那么它们的值将永远是$0$，利用上面$pos$标记，我们可以记录到$len_v$位置之后，后面的值均为$0$。如果$f_{v,len_v-1} \equiv a \pmod{998244353}(a \ne 0)$，那么我们可以对于整体乘上$f_{v,len_v-1}$，再对$f_{u,i}(0 \le i \le len_v)$暴力乘上$a$的逆元即可。

然后$f$就基本解决了。

考虑$g$如何转移。

$$
g_{u,i}=(g_{fa_u,i-1} \prod_{v \in son_{fa_u},v \ne u} f_{v,i-2})+1
$$

与$f$不同，$g$是自顶向下进行转移的，我们采取的措施是让重儿子继承父亲$g$数组，轻儿子利用$g_u$暴力更新。

看起来不好解决，我们先笼统地解决大的问题，比如轻儿子的暴力转移。

我们必须满足时间复杂度保持线性。

可以得到结论，对于一个节点来说$g_{u,i}(0 \le i \le L-len_u)$并没有用处，因为子树内的点至少也可以跳到$g_{u,L-len_u+1}$，那么$[0,L-len_u]$一部分信息我们不需要继承。

那么每个节点继承的信息为$[L-len_u+1,L]$，长度与长链长度相同。

对于一条长链来说，它的信息只会在长链顶部被暴力更新一次，时间复杂度$O(n)$。

对于$g$数组，我们用$g_{u,0}$来代替原来的$g'_{u,L-len_u+1}$，需要注意下标的转化。

分别考虑重儿子$w$和轻儿子$v$如何继承。

**重儿子**：由于$g_{u,i}$的实际值为$g'_{u,L-len_u+i+1}$，根据$dp$方程，$w$应该用$L-len_u+i+2$这一位的值来继承，也就是$g'_{w,L-len_u+i+2}$，由于$len_w=len_u-1$，$g'_{w,L-len_u+i+2}=g'_{w,L-len_w+i+1}=g_{w,i}$。$g_{u,i},g_{w,i}$下标相同，这意味着我们可以直接把$u$的指针转移给$w$即可。

**轻儿子**：我们需要将$L-len_v+1 \le i \le L$的$g'_{u,i}$值更新$v$，我们可以先枚举$0 \le i < len_v$，然后转化成$g_u$数组中的下标。

现在还有两个问题：

$1:$来自$f$数组的转移。

$2:$轻儿子向重儿子的合并。

考虑第一个问题，$\prod_{v \in son_{fa_u},v \ne u} f_{v,i-2}$，不能直接用$\frac{f_{fa_u,i-1}}{f_{v,i-2}}$，因为$f_{v,i-2}$经过$+1$操作，它的值在模$998244353$意义下可能为$0$。

我们只好采用前缀积乘后缀积的方式解决，我们的方案是倒序进行$f$的$dp$，同时利用之前的值。

我们需要支持可撤销的数据结构，类似**栈**的方式，在第一次$f$的$dp$时，把一次更新前原来的值压入栈中，然后进行还原，即可得到前缀积。

那么第一个问题解决了。

继续，第二个问题。

还是它$\prod_{v \in son_{fa_u},v \ne u} f_{v,i-2}$，对于一个节点$v$，$f_{v,i-2}$会对$g_{u,i}$产生贡献，同样，对于$v$来说，只有$f_{v,i}(0 \le i < len_v-1)$是需要存储的，$f_{v,i}(i \ge len_v)=f_{v,len_v-1}$。

又来了，全局乘，前缀乘逆元，最后还有个$+1$，加法标记继续上，和$f$完全一致。

所以现在我们的复杂度是$O(n \log k)$了？

不对，还有逆元需要一只$\log$，这显然让人很不舒服。

然而我们发现，对于一个节点$u$，有关$u$需要求解的逆元只有$f_{u,len_u-1}$，因为我们只有在全局乘操作时才需要逆元，之所以全局乘，是因为$len_u-1$之后的值都等于$f_{u,len_u-1}$。

对于$f_{u,len_u-1}$，可以看做去掉了长度限制，我们不需要开第二维数组即可计算，可以用暴力$dp$实现$O(n)$统计。

然后是线性求$m$个数$a_{1 \cdots m}$的逆元的问题（不要忘了把$0$去掉）。

$$
s=\prod_{i=1}^m a_i
$$
$$
pre_k=\prod_{i=1}^k a_i
$$
$$
succ_k=\prod_{i=k}^m a_i
$$
$$
{a_i}^{-1}=s^{-1} pre_{i-1} succ_{i+1}
$$

预处理$s^{-1},pre,succ$即可线性求逆元。

总时间复杂度$O(n \log k)$（~~这个$\log$可以忽略不计了吧，恐怕还没有我们$dp$转移时的常数大呢~~）。

如果认为我的讲解有问题，欢迎提出。

$End.$

---

## 作者：zhongyuwei (赞：8)

## 0

部署方案合法的条件是：存在一个点$u$，使得所有搜救范围都包含$u$且所有在搜救范围中出现过的点到$u$的距离不超过$L$。此时我们称部署方案可以被点$u$识别。

定义一种部署方案可以被一条边识别，当且仅当这条边的两个端点都能识别它。

显然，对于某种部署方案，可以识别它的$u$会构成一个连通块，而连通块点数 - 边数 = 1。所以，（每个点可以识别的部署方案数 - 每条边可以识别的部署方案数）就是答案。

设$s_u$表示包含$u$且所有点到$u$的距离均不超过$L$的连通块数，设$s_{(x,y)}$表示既包含在$s_x$里又包含在$s_y$里的连通块数，则

$Ans = \sum_u s_u^k - \sum_{(x,y) \in T} s_{(x,y)}^k$

## 1

用$dp$计算$s_u,s_{(x,y)}$。

设$f_{u,j}$表示只包含$u$子树内的点，且所有点到$u$的距离不超过$j$，且包含了$u$的连通块数。设$g_{u,j}$表示包含了$u$的父亲$fa_u$，且不包含$u$的子树内的点，且所有点到$fa_u$的距离不超过$j$的连通块数。距离定义为两个点之间最短路上的边数。

则

$f_{u,j} = \prod_{v\in son_u} (f_{v,j-1}+1) - 1$

$g_{u,j} = (g_{fa_u,j-1}+1)\prod_{v\in son_{fa_u},v\neq u}(f_{v,j-1}+1)$

$s_u = f_{u,L}\cdot (g_{u,L-1}+1),s_{(u,fa_u)}=f_{u,L-1}\cdot g_{u,L-1}$

## 2

用长链剖分优化dp。

设$len_u$表示$u$的子树中深度最深的点到$u$的距离。观察可知$f_{u,len_u} = f_{u,len_u+1} = f_{u,len_u+2} \cdots$，所以我们只需要算$f_{u,0},f_{u,1},\cdots f_{u,len_u}$就可以了。

处理某个点的$f$的时候，直接让它继承重儿子的信息（这一步要求支持全局+1的操作）。合并轻儿子$v$的时候，对于$f_{v,0},f_{v,1}\cdots f_{v,len_v}$可以直接暴力，剩下的相当于是令$f_u$数组的一个后缀乘上$f_{v,len_v}$。

如果$f_{v,len_v}$不为$0$的话，我们可以让$f_{u,0},f_{u,1} \cdots f_{u,len_v}$都乘上$f_{v,len_v}$的逆元（注意，不应是直接对数组中的数进行乘$f_{v,len_v}$的逆元的操作，而应该将数组中的值赋为“经过当前的全局标记的运算之后为$f_{u,i}\over f_{v,len_v}$”的值），然后打上全局乘以$f_{v,len_v}$的标记。

如果$f_{v,len_v}$为$0$，就相当于是让一段后缀都变成了$0$，我们可以另外维护一个标记$(l,x)$，表示从$l$开始的位置，数组中的值都是$x$（同理，$x$不一定是$0$，而是“经过当前的全局标记的运算之后为$0$”的值）。

$g$的维护则要更加麻烦一些。首先，我们将所有的链分成两类：长度小于$L-1$的，我们只需要记录链顶元素$u$的$g_{u,L-1-len_u},g_{u,L-1-len_u+1} \cdots g_{u,L-1}$就能够算出这个子树内所有点的$g_{v,L-1}$；长度大于等于$L-1$的，记录链顶元素的$u$的$g_{u,0},g_{u,1} \cdots g_{u,L-1}$即可。而从某个点到它的重儿子时，$g_u$的长度至多加$1$。这样状态数降到了$O(n)$。

直接让重儿子继承当前点的$g$（这个也要求支持全局+1），然后把其他儿子的贡献$(f_{v,j}+1)$合并上来（这个需要支持对后缀的乘法，与$f$的处理类似）。而对于轻儿子$v$，把$\prod_{v'\in son_u,v'\neq v}(f_{v',j}+1)$分为三部分：1.在我们处理这个轻儿子之前遍历过的轻儿子的贡献；2.还没有遍历过的轻儿子的贡献；3.重儿子的贡献。按照$len$从小到大的顺序依次处理轻儿子，就能够及其方便地统计在当前的轻儿子之前遍历过的轻儿子的贡献；在计算$f$的时候，我们按照轻儿子的$len$从大到小的顺序来合并，把$v$被并入之后的我们对$f$的那些操作撤销掉，就可以得到$v$被并入之前的$f$，也就是2. 3.两部分的贡献。

## 3

将儿子按照$len$排序，可以先把重儿子找出来，然后对剩下的进行基数排序。这样总复杂度为$O(n)$。

实际上我们需要用到的逆元只有每个点的$f_{u,len_u}$，可以在$O(n)$的时间预处理出它们的逆元。

总复杂度$O(n)$。

[Code](https://loj.ac/submission/733990)

---

## 作者：Schi2oid (赞：4)


我们所可以自慰的，想来想去，也还是所谓对于将来的希望。

希望是附丽于存在的，有存在，便有希望，有希望，便是光明。

原题解错漏过多，另未附上代码，现重制后发布。

#### 题意简述

定义对于一棵树上的连通块，称所有点 $x$ 使得 $x$ 到连通块中任何一点的距离不超过 $L$ 为该连通块的关键点。

给定一棵 $n$ 个点的树，求有多少个选出 $k$ 个可重复连通块的方案，使得它们的连通块的交不为空。对 $998244353$ 取模。

对于所有数据，有 $1\le n\le 10^6$，$0\le L\le n$，$1\le k\le10$。

#### 思路分析

首先，一个连通块的关键点集合显然一定也是一个连通块。连通块取并显然也是连通块。因此考虑点减边容斥，只需要统计对于每个点、每条边有多少种选择连通块的方案，使得最终关键点集合的交包含该点或该边。边可以通过两个点都被包含来表示。

考虑将选连通块拆分成子树内和子树外的部分。设 $F_{i,l}$ 表示选一个包含 $i$ 的连通块，只包含 $i$ 子树内的点，且连通块内点距离 $i$ 都不超过 $l$ 的方案数；再设 $G_{i,l}$ 表示选一个包含 $i$ 的连通块，不包含 $i$ 子树内除 $i$ 外任何点，且连通块内点距离 $i$ 都不超过 $l$ 的方案数。为了方便转移，将 $F$ 的定义更改为其原本值 $+1$。有朴素转移：
$$
\begin{aligned}
F_{i,l}&=\prod_{v\in son_i} (F_{v,l-1})+1\\
G_{i,l}&=G_{fa_i,l-1}\left(\prod_{v\in brother_i}F_{v,l-2}\right)+1
\end{aligned}
$$
那么对于点的方案数，即为 $\sum_i (F_{i,L}-1)^kG_{i,L}^k$；对于边的方案数，即为 $\sum_i (F_{i,L-1}-1)^k(G_{i,L}-1)^k$。作差即可得到本题答案。

朴素实现复杂度是 $O(L\sum_{i}deg_i)=O(Ln)$。

#### 优化求 F

考虑优化，发现式子和点的深度密切相关，因此考虑长链剖分。记 $dep_i$ 表示 $i$ 子树内最深的结点到 $i$ 的距离。先考虑 $F$ 的转移，经典地，令 $F_{i}$ 直接从其重儿子继承过来。同时，注意到 $\forall j>dep_i,F_{i,j}=F_{i,dep_i}$。因此，我们只需要维护$F_{i}$ 在 $[0,dep_i]$ 上的值。

对于 $i$ 的轻儿子 $v$，我们希望在 $O(dep_v)$ 的时间复杂度内将其合并，这样总复杂度就是 $O(n)$ 的。对于 $[0,dep_v]$ 中的值，直接暴力对位乘到 $i$ 的数组中复杂度就是正确的；而对于 $[dep_v+1,dep_i]$ 中的值，这些值都相同，我们只需要对 $F_{i}$ 进行后缀乘。注意到后缀乘可以改为全局乘再前缀乘逆元，这样这个后缀的操作复杂度也降为 $O(dep_v)$。同时，转移还有全局加，因此维护全局 $add,mul$ 的标记，先乘后加即可。转移还有下标平移，数组使用 `vector` 即可，将整个数组倒序存储，每次向末尾插入一个元素。

此处有三个细节：

- 带标记的对位乘怎么做？考虑对于一个位置，数组中存的值为 $v$，$add=a,mul=m$，要乘上的值为 $k$。那么其当前应为 $vmk+ak=m(vk+\frac{ak-a}{m})+a$，即应该将 $vk+\frac{ak-a}{m}$ 存入数组。维护 $mul$ 的逆元 $inm$ 即可。

- 逆元怎么求？注意到需要求逆元的 $F$ 全部等于 $F_{?,\infty}$。对于这样的 dp 状态，可以直接使用转移 $F_{i,\infty}=\prod F_{v,\infty}+1$。因此可以 $O(n)$ 求出这样的 $F$ 值，然后线性求逆元。
- 后缀乘 $0$ 怎么处理？~~怎么真有毒瘤出题人卡这个的~~ 考虑单独存一个后缀覆盖标记 $cov$，以及一个赋值标记 $val$，表示 $\forall l\ge cov,F_{i,l}=val$。注意到所有修改操作都是从 $0$ 出发的一段前缀，因此触碰到 $cov$ 时就将其后移 $1$，就可以保证其正确性。代码中的实现方式是记录数组中实际存储的值，即 $(val-add)inm$，这样在做一般更新时不用动态维护 $val$。

至此，我们通过维护 $add,mul,inm,cov,val$ 做到 $O(n)$ 求出 $F$。

#### 优化求 G

对于 $G$，注意到式子形式是自上向下的，考虑自上向下进行更新，让重儿子直接继承父亲的 $G$。同时，由于最终只关心每个点的 $G_{i,L}$ 的值，而 $G$ 数组随着深度增加每次只会发生 $1$ 的偏移，因此只有 $[L-dep_i,L]$ 中的 $G$ 值可能会对答案产生影响，只维护这一部分的 $G$ 即可。

先来考虑重儿子的转移。由于其兄弟都是长链顶，因此此时其 $F$ 值都是可以被直接获得的，用类似于 $F$ 转移的方式直接进行对位乘和后缀乘操作即可。

而对于轻儿子的转移，我们遇到了根本性的麻烦：无法获知重儿子的 $F$ 值，因此转移无法进行。

#### 可回退化求 F

考虑在求 $F$ 的过程中，每次修改一个变量时，存下修改的是哪个变量，以及其原本的值，将其压入栈中。这样，我们倒序弹栈，并将相应的变量还原，就可以实现将 $F$ 的所有更新回退。这样，我们就可以求得非长链顶点的 $F$ 值了。同时需要注意的是，求 $G$ 时 dfs 应该按照与 $F$ dfs 时访问儿子顺序相反的顺序进行。

#### 继续优化求 G

现在再来考虑 $G$ 轻儿子的转移。此时，我们可以将 $i$ 回退掉，这样我们就可以获得重儿子的 $F$ 值。考虑此时直接维护出前缀和后缀 $v$ 的 $F$ 对位乘积，对每一个位置进行两次乘获得。

具体来说，观察转移式子：
$$
\begin{aligned}
G_{i,l}&=G_{fa_i,l-1}\left(\prod_{v\in brother_i}F_{v,l-2}\right)+1\\
&=\left(G_{fa_i,l-1}F_{hson_x,l-2}\prod_{v\in brother_i,sonid_v<i}F_{v,l-2}\right)\left(\prod_{v\in brother_i,sonid_v>i}F_{v,l-2}\right)+1
\end{aligned}
$$
这两个括号都可以通过维护一个暂时数组，进行类似 $F$ 转移的合并获得。由于最终只需要关心 $[L-\max dep_v,L]$ 中的值，我们也只关心 $F_{hson_x}$ 中一个长度为 $\max dep_v+1$ 的区间，因此总的转移复杂度为 $O(\sum dep_v+\max dep_v)=O(\sum dep_v)$。

值得注意的一点是，$G$ 转移中的 $+1$ 本质上并不是全局加，而是对下标 $\ge 0$ 的位置进行的。只需要在调用到负数下标的 $G$ 值时直接返回 $0$ 即可。需要额外注意的是对 $G$ 进行下标平移时需要特殊处理下标由 $-1$ 变为 $0$ 的位置，此时其值应为 $0$，而非其原本存储的值。对其执行单点乘 $0$ 即可。

PS：为了保证复杂度正确，请关注循环的上下界限。

至此，我们做到 $O(n)$ 求出 $G$。时间复杂度瓶颈在最终求答案的快速幂，总时间复杂度为 $O(n\log k)$。本题完结。

[代码链接](https://www.luogu.com.cn/paste/y3hnyj19)

代码比较长，但是代码逻辑比较清晰（~~大概~~），可以参考。



---


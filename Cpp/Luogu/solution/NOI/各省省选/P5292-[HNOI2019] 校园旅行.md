# [HNOI2019] 校园旅行

## 题目背景

HNOI2019 Day2T1

## 题目描述

某学校的每个建筑都有一个独特的编号。一天你在校园里无聊，决定在校园内随意地漫步。

你已经在校园里呆过一段时间，对校园内每个建筑的编号非常熟悉，于是你情不自禁的把周围每个建筑的编号都记了下来——但其实你没有真的记下来，而是把每个建筑的编号除以 2 取余数得到 0 或 1，作为该建筑的标记，多个建筑物的标记连在一起形成一个 01 串。

你对这个串很感兴趣，尤其是对于这个串是回文串的情况，于是你决定研究这个问题。

学校可以看成一张图，建筑是图中的顶点，而某些顶点之间存在无向边。对于每个顶点我们有一个标记（0 或者 1）。每次你会选择图中两个顶点，你想知道这两个顶点之间是否存在一条路径使得路上经过的点的标记形成一个回文串。

一个回文串是一个字符串使得它逆序之后形成的字符串和它自己相同，比如 “010”，“1001” 都是回文串，而 “01”，“110” 不是。注意长度为 1 的串总是回文串，因此如果询问的两个顶点相同，这样的路径总是存在。此外注意，经过的路径不一定为简单路径，也就是说每条边每个顶点都可以经过任意多次。


## 说明/提示

【样例解释 1】

对于第一个询问，3 号点和 2 号点不连通，因此答案为 “NO”。

对于第二个询问，一条合法的路径是 1→3，路径上的标号形成的字符串为 “00”。注意合法路径不唯一。 

【数据范围】

对于 $30\%$ 的数据，$1 \leq m \leq 10 ^ 4$；

对于 $70\%$ 的数据，$1 \leq n \leq 3000$，$1 \leq m \leq 5\times 10 ^ 4$；

对于 $100\%$ 的数据，$1 \leq n \leq 5000$，$1 \leq m \leq 5\times 10 ^ 5$，$1 \leq q \leq 10 ^ 5$。

【编译命令】

对于 c++ 语言：g++ -o tour tour.cpp –lm -O2

对于 c 语言：gcc -o tour tour.c –lm -O2

对于 pascal 语言：fpc tour.pas -O2

## 样例 #1

### 输入

```
5 4 2
00010
4 5
1 3
4 2
2 5
3 5
1 3
```

### 输出

```
NO
YES```

## 样例 #2

### 输入

```
10 11 10
0011011111
4 6
10 6
5 9
4 7
10 7
5 8
1 9
5 7
1 10
5 1
5 6
10 3
7 4
8 10
9 4
8 9
6 6
2 2
9 9
10 9
3 4```

### 输出

```
NO
YES
YES
NO
YES
YES
YES
YES
YES
NO```

# 题解

## 作者：Imakf (赞：38)

~~神仙dp题，考场爆0只有我了~~

# 解法

myy出的，搬一下**他的原话如下**

30分的DP就是dp[i][j]表示i到j是否存在一条合法的路径，转移就是枚举i的边和j的边。总复杂度是$O(m^2)$。

考虑减少边数。我们把一种标号单独拿出来，只考虑连接同一种标号的两个点的边。 对于一个连通块，如果它是二分图，那么我们仅保留一棵生成树答案也不会变。这是因为我们容易发现这个连通块之内的转移仍然可以实现（只要另一边在两个点内来回走即可）。如果它不是二分图，我们可以加一个自环。

我们考虑连接不同标号的边，只把这些边拿出来我们也可以形成若干个连通块。对于每个连通块， 根据同样的道理我们保留一棵生成树即可（注意这个时候连通块一定都是二分图）。

这样总边数不超过$2n-2$，用30分DP的思路可以做到$O(n^2)$并且通过本题。

----

所以为什么不是二分图的时候可以加自环呢？仔细想想，如果图不是二分图，就说明图中一定有长度为奇数的环。那么在这边可以一直来回转圈，另一边如果也有奇数环，那么显然可以匹配，如果另一边是二分图，那么显然我们可以在这一边转上几圈，让长度变成偶数，依然可以转移QAQ

如果不懂的话可以自己手造数据的QAQ，个人认为比较好理解

于是就变成了$kruskal$

```cpp
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<algorithm>
#include<queue>

#define rg register
#define il inline
#define MX (5000 + 65)
#define M_MX (500000 + 5)

int cs ,cd;
struct ip{
	int u ,v;
}same[M_MX] ,diff[M_MX];
int color[MX];

namespace FS{	//forward_star 前向星
	int head[MX] ,tot;
	struct edge{
		int node ,next;
	}h[M_MX << 1];
	il void addedge(int u ,int v){
		h[++tot].next = head[u];
		head[u] = tot;
		h[tot].node = v;
	}
}
int n ,m ,q;

int fa[MX];
void init(int upper){
	for(rg int i = 1 ; i <= upper ; ++i)	fa[i] = i;
	using namespace FS;
	memset(FS::head ,0 ,sizeof(head));
	memset(h ,0 ,sizeof(h));
	tot = 0;
}
int find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}
void link(int x ,int y){fa[find(x)] = find(y);}

int vis[MX][MX] ,DP[MX][MX];
namespace MST{	//Minimum Spanning Tree 最小生成树
	int head[MX] ,tot;
	FS::edge h[M_MX << 1];
	void addedge(int u ,int v){
		h[++tot].next = head[u];
		head[u] = tot;
		h[tot].node = v;
	}int Tag[MX];
	bool check2fen(int x ,int tag){
		if(Tag[x])	return Tag[x] == tag;
		Tag[x] = tag;
		for(rg int i = FS::head[x] ; i ; i = FS::h[i].next){
			int d = FS::h[i].node;
			if(!check2fen(d ,tag == 1 ? 2 : 1))	return false;
		}return true;
	}
	void kruskal(int type){
		if(type == 1){	//单独拿出连接同种编号的
			for(rg int i = 1 ; i <= n ; ++i)	Tag[i] = false;
			init(n);
			int cnt = 0;
			for(rg int i = 1 ; i <= cs ; ++i){
				FS::addedge(same[i].u ,same[i].v);
				FS::addedge(same[i].v ,same[i].u);
			}
			for(rg int i = 1 ; i <= cs ; ++i){
				if(find(same[i].u) != find(same[i].v)){
					LST::addedge(same[i].u ,same[i].v);
					LST::addedge(same[i].v ,same[i].u);
					link(same[i].u ,same[i].v);
					++cnt;
				}
			}
			for(rg int i = 1 ; i <= n ; ++i){
				if(!Tag[i]){
					if(!check2fen(i ,1))	LST::addedge(i ,i);
				}
			}
		}
		else{//单独拿出连接不同种编号的
			init(n);
			for(rg int i = 1 ; i <= n ; ++i)	Tag[i] = false;
			int cnt = 0;
			for(rg int i = 1 ; i <= cd ; ++i){
				FS::addedge(diff[i].u ,diff[i].v);
				FS::addedge(diff[i].v ,diff[i].u);
			}
			for(rg int i = 1 ; i <= cd ; ++i){
				if(find(diff[i].u) != find(diff[i].v)){
					LST::addedge(diff[i].u ,diff[i].v);
					LST::addedge(diff[i].v ,diff[i].u);
					link(diff[i].u ,diff[i].v);
					++cnt;
				}
			}
			for(rg int i = 1 ; i <= n ; ++i){
				if(!Tag[i]){
					if(!check2fen(i ,1))	LST::addedge(i ,i);
				}
			}
		}
	}
}using namespace MST;

void dp(){	//大力转移，因为本题有O2，可以放心用STL
	std::queue<int> q1 ,q2;
	for(rg int i = 1 ; i <= n ; ++i){
		vis[i][i] = true;
		DP[i][i] = true;
		q1.push(i) ,q2.push(i);
		for(rg int j = head[i] ,d ; j ; j = h[j].next){
			d = h[j].node;
			vis[i][d] = vis[d][i] = true;
			if(color[i] != color[d])	continue;
			DP[i][d] = DP[d][i] = true;
			q1.push(i) ,q2.push(d);
		}
	}
	while(!q1.empty()){
		int x = q1.front() ,y = q2.front();
		q1.pop() ,q2.pop();
		for(rg int i = head[x] ; i ; i = h[i].next){
			for(rg int j = head[y] ; j ; j = h[j].next){
				if(!vis[h[i].node][h[j].node] && color[h[i].node] == color[h[j].node]){
					DP[h[i].node][h[j].node] = DP[h[j].node][h[i].node] = true;
					q1.push(h[i].node) ,q2.push(h[j].node);
				}vis[h[i].node][h[j].node] = vis[h[j].node][h[i].node] = true;
			}
		}
	}
}

int main(){
	
	scanf("%d%d%d" ,&n ,&m ,&q);
	for(rg int i = 1 ; i <= n ; ++i){
		scanf("%1d" ,color + i);
	}
	for(rg int i = 1 ,u ,v ; i <= m ; ++i){
		scanf("%d%d" ,&u ,&v);
		FS::addedge(u ,v);
		FS::addedge(v ,u);
		if(color[u] ^ color[v])	diff[++cd] = (ip){u ,v};
		else same[++cs] = (ip){u ,v};
	}
	using namespace MST;
	kruskal(1);
	kruskal(2);
	//outedge();
	dp();
	for(rg int i = 1 ,u ,v ; i <= q ; ++i){
		scanf("%d%d" ,&u ,&v);
		if(DP[u][v] || DP[v][u])	puts("YES");
		else puts("NO");
	}
	return 0;
}
```


---

## 作者：Soulist (赞：24)

神仙题，之前写过一篇题解，可能较为难懂，最近订正一下

首先注意到一个回文串将其首尾去除仍为回文串。

于是可以类似于 spfa 从长度为 $2/1$ 的回文串开始遍历，求出任意两点是否回文可达，这样每一对点都会拓展一次，复杂度为 $deg\times deg$，即 $\mathcal O((\sum deg)^2)=\mathcal O(m^2)$

我们注意到，一个回文串可以被描述为若干段 $01$ 和 $11$ 和 $00$ 的组合，而且由于允许走非简单路径，那么重复绕同一边走可以改变任意一段的奇偶性，于是答案只和每一段的奇偶性相关。

考虑什么图中某两个点的奇偶性恒定 $\to$ 二分图，于是将 $01$ 边单独考虑，$1\to 1$ 边单独考虑，$0\to 0$ 边单独考虑，如果为二分图，那么只需要保留任意一棵生成树即可保证答案相同（注意这仍是一个二分图，同时绕重边任何合法）若为非二分图，我们增加一个自环即可（可以通过绕自环来改变某两个点奇偶性）。

这样可以将边数降为 $n$ 的级别，然后做上面那个暴力，复杂度即为 $\mathcal O(n^2)$


```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
    char cc = getchar(); int cn = 0;
    while(cc < '0' || cc > '9') cc = getchar();
    while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
    return cn;
}
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i ) 
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next ) 
const int M = 1e6 + 5 ; 
const int N = 5000 + 5;
struct E {
    int to, next ;  
} e[M * 2];
struct S {
    int from, to ; 
} s[M * 2];
int n, m, Q, head[N], cnt, w[N], dis[N][N], fa[N][2], col[N], sd[N], book[N];
char ss[N] ; 
queue< S> q ;  
void add( int x, int y ) {
    e[++ cnt] = (E){ y, head[x] }, head[x] = cnt ; 
    e[++ cnt] = (E){ x, head[y] }, head[y] = cnt ; 
}
int abc( int x ) { //绝对值 
    return ( x > 0 ) ? x : -x ; 
}
int find( int x, int node ) {
    if( fa[x][node] == x ) return x ; 
    return fa[x][node] = find(fa[x][node], node) ; 
}
void dfs( int x, int c ) {
    col[x] = c ; 
    Next( i, x ) {
        int v = e[i].to ; 
        if( !col[v] ) dfs( v, -c ) ;
        else if( col[v] == col[x] ) sd[abc(c)] = 1 ; 
    }
}
void init() {
    rep( i, 1, n ) if( !col[i] ) dfs( i, i ) ;  //二分图染色 
    
    memset( head, 0, sizeof(head) ), cnt = 0 ;
    rep( i, 1, m ) {
        int Fr = s[i].from, To = s[i].to ; 
        if( w[Fr] != w[To] ) {
            int u = find( Fr, 1 ), v = find( To, 1 ) ;
            if( u == v ) continue ;
            add( Fr, To ), fa[u][1] = v ;
        }
        else {
            int u = find(Fr, 0), v = find(To, 0) ; 
            if( u == v ) continue ; 
            add( Fr, To ), fa[u][0] = v ; 
            q.push((S){ Fr, To }), dis[Fr][To] = dis[To][Fr] = 1 ; 
        } 
    }
    rep( i, 1, n ) {
        int cc = abc(col[i]) ;
        if( sd[cc] && ( book[cc] == 0 ) ) add( cc, cc ), book[cc] = 1 ; //自环 
    }
}
void spfa() { //spfa求解两个点是否可达 
    while( !q.empty() ) {
        S u = q.front(); q.pop() ;
        int Fr = u.from, To = u.to ; 
        Next( i, Fr ) {
            int v = e[i].to ; 
            Next( j, To ) {
                int v2 = e[j].to ; 
                if( w[v] != w[v2] || dis[v][v2] ) continue ; 
                dis[v][v2] = dis[v2][v] = 1, q.push((S){v, v2}) ;
            }
        } 
    }
}
void output() { //输出文件 
    int x, y ; 
    rep( i, 1, Q ) {
        x = read(), y = read() ; 
        if( dis[x][y] ) puts("YES") ; 
        else puts("NO") ; 
    }
}
signed main()
{
    n = read(), m = read(), Q = read() ; 
    scanf("%s", ss);
    rep( i, 1, n ) w[i] = ss[i - 1] - '0', dis[i][i] = 1, fa[i][0] = fa[i][1] = i, q.push((S){i, i}) ;
    rep( i, 1, m ) {
        s[i].from = read(), s[i].to = read();
        if( w[s[i].from] == w[s[i].to] ) add( s[i].from, s[i].to ) ;
    }
    init(), spfa(), output() ; 
    return 0;
}
```

---

## 作者：yybyyb (赞：20)


首先考虑暴力做法怎么做。  
把所有可行的二元组全部丢进队列里，每次两个点分别向两侧拓展一个同色点，然后更新可行的情况。  
这样子的复杂度是$O(m^2)$的。  
考虑如何优化边数，先说结论：  
首先对于一个同色联通块，如果它是一个二分图，那么只需要保留一棵生成树就行了，否则随便找个点连一条自环。  
对于连接不同色两个点的边，一定构成一个二分图，只需要保留一棵生成树就行了。   
证明是这样子的：  
首先我们把路径划分成若干个同色连续段，那么我们要做的就是对应的两段长度要相等。  
长度短了是无所谓的，我们可以反复走一条边，达到把序列边长的目的。  
对于一个二分图而言，如果反复走，其长度的奇偶性不会改变，否则奇偶性可以任意改变，那么需要连一个自环来改变奇偶性。  
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define MAX 5050
inline int read()
{
	int x=0;char ch=getchar();bool fl=false;
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')fl=true,ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return fl?-x:x;
}
struct Line{int v,next;}e[500500<<1];
int h[MAX],cnt=1;
inline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}
int n,m,Qr;char a[MAX];
struct Node{int x,y;};queue<Node> Q;
bool vis[MAX][MAX];
vector<int> E[MAX];
int col[MAX];bool chk;
int f[MAX];
int getf(int x){return x==f[x]?x:f[x]=getf(f[x]);}
void dfs(int u,int c)
{
	col[u]=c;
	for(int i=0,l=E[u].size();i<l;++i)
	{
		int v=E[u][i];
		if(a[u]!=a[v])continue;
		if(col[v]==col[u])chk=false;
		if(col[v])continue;
		Add(u,v),Add(v,u);dfs(v,c^1);
		vis[u][v]=vis[v][u]=true;
		Q.push((Node){u,v});
	}
}
int main()
{
	freopen("tour.in","r",stdin);
	freopen("tour.out","w",stdout);
	n=read();m=read();Qr=read();scanf("%s",a+1);
	for(int i=1;i<=n;++i)f[i]=i;
	for(int i=1;i<=m;++i)
	{
		int u=read(),v=read();
		E[u].push_back(v);
		E[v].push_back(u);
		if(a[u]!=a[v])
		{
			if(getf(u)==getf(v))continue;
			Add(u,v);Add(v,u);
			f[getf(u)]=getf(v);
		}
	}
	for(int i=1;i<=n;++i)
		if(!col[i])
		{
			chk=true;dfs(i,2);
			if(!chk)Add(i,i);
		}
	for(int i=1;i<=n;++i)vis[i][i]=true,Q.push((Node){i,i});
	while(!Q.empty())
	{
		Node u=Q.front();Q.pop();
		int x=u.x,y=u.y;
		for(int i=h[x];i;i=e[i].next)
		{
			int xx=e[i].v;
			for(int j=h[y];j;j=e[j].next)
			{
				int yy=e[j].v;
				if(vis[xx][yy])continue;
				if(a[xx]!=a[yy])continue;
				vis[xx][yy]=vis[yy][xx]=true;
				Q.push((Node){xx,yy});
			}
		}
	}
	while(Qr--)
	{
		int x=read(),y=read();
		if(vis[x][y])puts("YES");
		else puts("NO");
	}
	return 0;
}
```

---

## 作者：洛水·锦依卫 (赞：11)

[欢迎来博客玩呀](https://www.cnblogs.com/luoshuitianyi/p/10679665.html)
# Algorithm
$DP$

# Mentality
考场上无人切的神题 $orz$ ，$myy\ nb$ 。

由于 $n$ 异常的小，所以我们发现完全可以用 $n^2$ 的二维空间来储存信息，而 $m$ 和 $q$ 相对来说又异常大，这启发我们用一种看起来很暴力的方法做这道题 -- 预处理出所有点对的情况。

$30$ 分的做法还是很好想的，我们发现可以将回文路径分为两类：长度为奇数的，长度为偶数的。

设 $f[i][j]$ 为 $i,j$ 之间是否有回文路径，那么我们先处理出长度最短的奇偶回文路径。首先，长度最短的奇数回文路径就是每个点自己，即 $f[i][i]=1$ 。然后观察到对于每条边，如果连的两个点 $u,v$ 编号相同，则 $f[u][v]=f[v][u]=1$ ，这些就是长度最短的偶数回文路径。

然后考虑利用这些信息进行 $DP$ 转移，我们用 $bfs$ 的顺序来转移即可。

将这些两点之间有路径的二元组 $(u,v)$ 扔进队列，转移的时候枚举 $u,v$ 的出边 $to_u,to_v$，如果 $to_u$ 的编号与 $to_v$ 相同，那么 $to_u,to_v$ 之间肯定也存在回文路径，我们将 $f$ 数组更新，然后将二元组 $to_u,to_v$ 丢入队列末尾等待下一次转移即可。

由于每次转移都要枚举两点的出边一一判断，所以复杂度为 $m^2$ 。

代码大概长这个样子？

```cpp
while(h<t)
{
	h++;
	for(int i=hd[u[h]];i;i=Nx[i])
		for(int j=hd[v[h]];j;j=Nx[j])
			if(S[To[i]]==S[To[j]]&&!f[To[i]][To[j]])
				f[To[i]][To[j]]=f[To[j]][To[i]]=1,Add(To[i],To[j]);
}
```

由于 $STL$ 常数太大，所以手写队列 (也就总共 $5e7$ 的空间~~而已~~)

询问一次就直接看它的 $f$ 数组即可。

接下来考虑 $100$ 分做法。

观察到 $m$ 巨大，我们考虑减少边的枚举。

我们将所有转移分成两类：向相同编号的点转移，向不同编号的点转移。

那么我们也就可以依此将边分为两类：连接相同编号点的边，连接不同编号点的边。

我们先考虑一类边，譬如连接相同编号点的边。

这些边把图分成了许多个联通块，我们发现，对于一个联通块内的转移，只取决于一件事：这个联通块是不是个二分图。

为什么呢？我们来考虑一下，如果联通块是一个二分图，那么它满足两个性质。

- 能将联通块内的点划分成两个集合，同一集合内的点互不直接相连。

- 同时由于这是个联通块，两点之间皆可达。

那么不难发现，如果我在一个集合内，想要转移到集合内另一点，必定会经过偶数条边。

因为我到达这个点的过程中，注定只能是重复 `当前集合` -> `另一集合` -> `当前集合` 这样的步骤，所以最后的步数一定是偶数条。

换而言之，若联通块为二分图，那么联通块内任意两点之间的路径长度奇偶性唯一。

而注意到，当我们 $DP$ 转移的时候，若回文串两端新增的数字全都相同，譬如在左右端都添上 $0$ ，那么我们只需要保证左右两边新增的数量相同即可。

而根据题目的性质可知，我们为保证数量相等，完全可以在一条连向一个相同编号点的边上来回横走保证数量的增值。但是**这样不改变奇偶性**。

那么奇偶性就成了判断 $DP$ 转移的重要性质了。

接着上面的推论，由于若联通块为二分图，那么联通块内两点件路径长度奇偶性唯一。那么我们在这个联通块内，只需要**保留一颗生成树**即可，因为 **奇偶唯一** ，所以 **不影响 $DP$ 过程** 。

然后我们再来看，如果不是二分图怎么办。还是划分成两个集合，那么同一集合内至少有一对点 $(u,v)$ 之间直接有连边。由于只考虑连接两个不同集合的边时，从 $u$ 至 $v$ 必定有一条长度为 **偶数** 的路径，所以再加上一条边，这个联通块内就有了一个 **奇环** 。则联通块内任意一点都可以走到奇环上通过绕环改变路径长度奇偶性。

那么不难发现，我们只需要先像二分图一样，保留一颗生成树。至于那个奇环，我们只需**要在生成树内任意一个点上随便连个自环**就行了 $QwQ$，反正只是要个奇环而已，自环当然也是啦。

以上是连接相同编号点的边的处理方式。

至于连接不同编号的边的话，我们发现这联通块肯定就是个二分图，那么直接保留生成树即可。

那么边数减少为 $n$ 的级别，此时再去 $DP$ ，复杂度就降为 $n^2$ 了。

如若未懂详见代码

# Code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,Q;
int cntr,head[5001],nx[1000001],to[1000001],col[5001];
int cr,hd[5001],Nx[1000001],To[1000001];
int h,t,u[25000001],v[25000001];
bool flag,f[5001][5001];
char S[5001];
struct node{int u,v;};
void read(int &x)
{
	x=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
}
void addr(int u,int v)
{
	cntr++;
	nx[cntr]=head[u],to[cntr]=v;
	head[u]=cntr;
}
void Addr(int u,int v)
{
	cr++;
	Nx[cr]=hd[u],To[cr]=v;
	hd[u]=cr;
}
void Add(int U,int V)
{
	t++;
	u[t]=U,v[t]=V;
}
void dye(int x,bool type)
{
	for(int i=head[x];i;i=nx[i])
	{
		int p=to[i];
		if((S[p]==S[x])==type)//构图参数的使用
		{
			if(col[p]!=-1)if(!(col[p]^col[x]))flag=1;//染色冲突则不是二分图
			if(col[p]==-1)
			{
				col[p]=col[x]^1,dye(p,type);
				Addr(x,p),Addr(p,x);//加边
			}
		}
	}
}
void Read_Init()
{
	read(n),read(m),read(Q);
	scanf("%s",S+1);
	int u,v;
	while(m--)
	{
		read(u),read(v);
		if(S[u]==S[v])f[u][v]=f[v][u]=1,Add(u,v);//先加入偶数最短边，并更新 DP 数组
		addr(u,v),addr(v,u);
	}
}
void Build_Init()
{
	for(int i=1;i<=n;i++)f[i][i]=1,Add(i,i);//加入奇数最短边，并更新 DP 数组
	for(int k=0;k<2;k++)//k 是构图参数
	{
		for(int i=1;i<=n;i++)col[i]=-1;//二分图染色初始化
		for(int i=1;i<=n;i++)
			if(col[i]==-1)
			{
				flag=0;
				col[i]=0,dye(i,k);
				if(flag)Addr(i,i);//如果不是二分图那就加个自环
			}
	}
}
void DP()
{
	while(h<t)
	{
		h++;
		for(int i=hd[u[h]];i;i=Nx[i])
			for(int j=hd[v[h]];j;j=Nx[j])
				if(S[To[i]]==S[To[j]]&&!f[To[i]][To[j]])
					f[To[i]][To[j]]=f[To[j]][To[i]]=1,Add(To[i],To[j]);//DP 转移
	}
}
void Answer()
{
	int u,v;
	while(Q--)
	{
		read(u),read(v);
		if(f[u][v])printf("YES\n");
		else printf("NO\n");
	}
}
int main()
{
	Read_Init();
	Build_Init();
	DP();
	Answer();
}
```

---

## 作者：FriedrichC (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P5292)

本题综合了图的许多算法，具有较大的思维难度，但也因此十分有价值。
## 题目分析
首先，题目要求是要判断询问的两点间是否存在回文路径。

对于这样一个问题，我们比较容易想到的做法是从图的某个局部开始拓展，将局部的状态转移到全图的状态。

具体来说，我们可以使用图上 dp 的方法，设计状态 $f(i,j)$ 表示从点 $i$ 到点 $j$ 是否存在回文路径，然后就可以从**标记相同**的**点对**或者**单点**开始进行状态转移（因为根据题意，这两种情况下必然存在回文路径）。

显然的，对于一个点对 $(i,j)$，如果 $f(i,j)=true$ 且点 $i$ 和 点 $j$ 的子节点组成的点对标记相同，那么这个子节点对的状态就可以更新为 $true$。

从单点出发的更新也是同理。

由于我们要枚举所有出边，所以算法的复杂度为 $O(m^2)$，显然会超时。

于是我们算法的瓶颈就在于边的数量，下面考虑该如何优化。

## 算法优化
我们意识到，点的数量和边的数量差别是很大的，这意味着这张图存在大量的**环**，如果我们可以把整图或者子图替换为对应的**生成树**，那么我们的算法复杂度就有希望降低到 $O(n^2)$ 级别。

但问题是，这种做法会不会影响答案的正确性呢？

那么先来考虑一个问题，存在一条回文路径的充分条件是什么。

题目说了，这条路径**不一定**是**简单路径**，因此我们在路径上可以来回行走。

我们把一条路径从起点走到**给定终点**所经过的点的数量定义为**路径大小**。

那么如果把一条**简单路径**从中间分成左右两部分，假设左右部分全是**同一种标记**，我们会发现：

其左右两部分路径大小是否相同就可以代表这整条路径是否生成了一个回文串。

如果左右两部分路径大小不等，且**奇偶性相同**，通过在路径大小较小的那部分来回走必然能使得左右两部分路径大小相同。

因为来回走对路径大小带来的增量一定是**偶数**，所以路径大小的**奇偶性**在**来回走**的过程中是**不变的**。

又因为路径大小的增量至少为$2$，所以一个路径大小通过增长可以生成其后续的**奇数列**或者**偶数列**，自然就可以增长为同奇偶性的路径大小了。

所以，存在一条回文路径的充分条件就是都为**单一**标记的左右部分路径的奇偶性相同。

也就是说，我们若想建立子图的一棵生成树，只要保持其路径大小的奇偶性不变就可以了。

我们知道了，来回走是不改变路径的奇偶性的，那么其他的运动呢？比如环状运动？

有没有什么图的路径大小奇偶性是受到自由运动的影响的？

我们可以想到，**奇环**的路径奇偶性会受到在路径上环状运动的影响。

因为沿着奇环单向运动若干**整圈**的路径大小增量可能为奇数也可能为偶数，那么一条可以经过奇环的路径的路径大小奇偶性就不固定了。

也就是说，我们在生成子树时要通过某些方法保持奇环的这种“**可变性**”。

既然这样，我们已经知道了，只有包含奇环的子图才具有奇偶的“可变性”，不包含奇环的图不就是**二分图**吗？问题就很明确了。

## 具体实现
在具体实现上，我们可以把连接的两点的标记均为$1$或$0$的边划分成两个子图。

对于每个子图的每个**连通分量**，可以用 Kruskal 算法求出其生成树，然后判断其是否为二分图，

如果不是二分图，为了保持上文提到的“可变性”，需要在生成树中加入奇环，为了使得增加的边数尽量小，我们增加一个**自环**即可，因为自环是最简单的奇环。

我们还剩下连接不同标记的两点的边的集合，很显然，这必然是一张二分图，建立生成树后没必要再进行判断。

最后注意一点，在建生成树时，记得要加**无向边**，因为“来回走”的思想正是体现在此，只有加无向边，在枚举出边的时候才能重复访问到父节点。

## 实例说明
![](https://cdn.luogu.com.cn/upload/image_hosting/kipmfgos.png)

~~写得有点丑，别介意。~~

以上图为例，从$6$走到$10$，在只经过标记为$1$的点的情况下必然要经过偶数个点。

$4$ $6$ $7$ $10$这四个点和它们之间的连边组成的图是二分图，

根据上面的说法，我们可以删去例如无向边$(4,6)$，可以看到$6$依然只能经过偶数个点到达$10$。

对于$11$,哪怕去掉这条边，也无法通过回文路径到达$6$。

而且，假如删除了这条边，由于$11$->$8$路径大小为偶数，$6$->...->$4$也是偶数，所以$11$和$4$总是可以通过回文串连接，如路径$11$->$8$->$11$->$8$->$5$->$6$->$10$->$7$->$4$。

下面是奇环的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/tqkulqdu.png)

这样处理即可：

![](https://cdn.luogu.com.cn/upload/image_hosting/98zrokdp.png)

## 附上代码
```cpp
#include<bits/stdc++.h>
#define maxn 5010
#define N 500010
#define fi first
#define se second
#define mkp make_pair
#define pub push_back
using namespace std;
typedef pair<int,int> PII; 
struct line{int to,pre;};
struct edge{int u,v;};
line b[N*2],b1[maxn*2];
int head[N],head1[maxn],t,t1;
int n,m,Q;
char s[maxn];
bool f[maxn][maxn],ok;
int vis[maxn],fa[maxn];
queue<PII>q;//用于存储状态 
vector<edge>e1,e2;//用于划分子图 
void ad(int x,int y)
{
	t++;
	b[t].to=y;
	b[t].pre=head[x];
	head[x]=t;
}
//建生成树的边 
void ad1(int x,int y)
{
	t1++;
	b1[t1].to=y;
	b1[t1].pre=head1[x];
	head1[x]=t1;
}
int getf(int x)
{
	if(x!=fa[x])
		fa[x]=getf(fa[x]);
	return fa[x];
}
inline int merge(int x,int y)
{
	int t1=getf(x),t2=getf(y);
	if(t1==t2)return 0;
	else {fa[t2]=t1;return 1;}
}
//二分图染色判定 
void dfs(int x,int col)
{
	vis[x]=col;
	for(int i=head[x];i;i=b[i].pre)
	{
		int y=b[i].to;
		if(s[x]==s[y])
		{
			if(!vis[y])dfs(y,3-col);
			else if(vis[y]==col)ok=0;
		}
	}
}
//处理奇环 
void check()
{
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;++i)
	{
		if(!vis[i])
		{
			ok=1;
			dfs(i,1);
			if(!ok)ad1(i,i);//添加自环 
		}
	}
}
//创建生成树 
void generate()
{
	for(int i=1;i<=n;++i)fa[i]=i;//初始化并查集 
	for(int i=0;i<e1.size();++i)
	{
		int x=e1[i].u,y=e1[i].v;
		if(merge(x,y))ad1(x,y),ad1(y,x);
	}
	check();
	for(int i=1;i<=n;++i)fa[i]=i;
	for(int i=0;i<e2.size();++i)
	{
		int x=e2[i].u,y=e2[i].v;
		if(merge(x,y))ad1(x,y),ad1(y,x);
	}
}
//状态转移部分 
void dp()
{
	while(!q.empty())
	{
		PII temp=q.front(); q.pop();
		int x=temp.fi,y=temp.se;
		for(int i=head1[x];i;i=b1[i].pre)
			for(int j=head1[y];j;j=b1[j].pre)
			{
				int u=b1[i].to,v=b1[j].to;
				if(!(f[u][v]||f[v][u])&&s[u]==s[v])
				{
					f[u][v]=1;
					f[v][u]=1;
					q.push(mkp(u,v));
				}
			}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>Q;
	cin>>s+1;
	for(int i=1;i<=m;++i)
	{
		int x,y;
		cin>>x>>y;
		if(s[x]==s[y])
		{
			f[x][y]=1;
			f[y][x]=1;
			q.push(mkp(x,y));
			e1.pub(edge{x,y});
		}
		else
			e2.pub(edge{x,y});
		ad(x,y);
		ad(y,x);
	}
	for(int i=1;i<=n;++i)f[i][i]=1,q.push(mkp(i,i));
	generate();
	dp();
	while(Q--)
	{
		int x,y;
		cin>>x>>y;
		if(f[x][y]||f[y][x])puts("YES");
		else puts("NO");
	}
	return 0;
}
```















---

## 作者：nofind (赞：3)

## [题意](https://www.luogu.com.cn/problem/P5292)

先考虑暴力：  
设$f_{x,y}$表示$(x,y)$是否有一条满足要求的路径。  
转移则考虑枚举$(x,y)$的出点，判断是否有颜色相同的，之后递归。关于转移顺序，可以考虑记忆化或者$spfa$。  
这样暴力是$O(m^2)$的，因为是枚举出边。

我们考虑是否可以删去一些边，使得边的总数为$O(n)$级别，且保证答案不变。

对于一个回文串，我们显然能够按颜色将其分为很多段，其中每段颜色相同。显然同一段的点是在连接同种颜色的边之间转移的，而段之间的分界则是由连接不同颜色的边转移的。

因此将边分类讨论：  
1.连接相同颜色的边：  
为了方便，我们只考虑一种编号的边，比如说$1$，另一种同理。我们发现只保留这些边会构成一个个连通块，我们考虑每一个连通块，看是否能将其化简。

我们这么考虑：构造回文串时，我们要在这个连通块中构造一个$11111...$，跟之后回文串中$11111...$相对应。我们发现只用关心$1$的个数的奇偶性，因为我们可以在一条边反复横跳来不断添加$1$，但是一次添加两个，是无法改变奇偶性的，因此只要保证相对应的两段$1$能使个数的奇偶性相同即可。（**这里很重要，一定要理解**）

此时我们根据连通块是否为二分图分类：  
如果一个连通块为二分图，那么每对点之间的奇偶性是固定的，即同一集合的点之间的所有路径必定偶数，反之则为奇数。我们知道树也是二分图，因此这个联通块我们只保留一颗生成树即可。

如果一个联通块不是个二分图，那么它必定存在奇环，我们可以通过走这个奇环改变路径的奇偶性，因此我们仍然搞出一颗生成树，之后在其中加一个自环，这样每条路径都可以通过这个自环改变奇偶性。

2.连接不同颜色的边：

显然每个联通块都是二分图，根据我们在上面得出的结论，我们同样只保留一颗生成树即可。

于是边的个数就变为了$O(n)$，我们便可以以$O(n^2)$的复杂度通过本题。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=5010;
const int maxm=500010;
int n,m,Q,cnt_edge;
int head[maxn],col[maxn],fa[maxn];
bool flag;
bool f[maxn][maxn];
char s[maxn];
vector<int>ve[maxn];
struct Edge{int u,v;}E[maxm];
struct edge{int to,nxt;}e[(maxn*3)<<1];
inline int read()
{
    char c=getchar();int res=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
    return res*f;
}
inline void add_edge(int u,int v)
{
	e[++cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
	e[cnt_edge].to=v;
}
void dfs(int x,int c)
{
	col[x]=c;
	for(unsigned int i=0;i<ve[x].size();i++)
	{
		int y=ve[x][i];
		if(~col[y])flag|=(col[x]==col[y]);
		else add_edge(x,y),add_edge(y,x),dfs(y,c^1);
	}
}
inline void build(char op)
{
	for(int i=1;i<=n;i++)col[i]=-1,ve[i].clear();
	for(int i=1;i<=m;i++)
	{
		int u=E[i].u,v=E[i].v;
		if(s[u]!=op||s[v]!=op)continue;
		ve[u].push_back(v);ve[v].push_back(u);
	}
	for(int i=1;i<=n;i++)
	{
		if(~col[i])continue;
		flag=0;dfs(i,0);
		if(flag)add_edge(i,i);
	}
}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
#define pii pair<int,int>
#define mkp make_pair
#define fir first
#define sec second
inline void spfa()
{
	queue<pii>q;
	for(int i=1;i<=n;i++)f[i][i]=1,q.push(mkp(i,i));
	for(int i=1;i<=m;i++)
		if(s[E[i].u]==s[E[i].v])f[E[i].u][E[i].v]=f[E[i].v][E[i].u]=1,q.push(mkp(E[i].u,E[i].v));
	while(!q.empty())
	{
		int x=q.front().fir,y=q.front().sec;q.pop();
		for(int i=head[x];i;i=e[i].nxt)
			for(int j=head[y];j;j=e[j].nxt)
				if(s[e[i].to]==s[e[j].to]&&!f[e[i].to][e[j].to])
					f[e[i].to][e[j].to]=f[e[j].to][e[i].to]=1,q.push(mkp(e[i].to,e[j].to));	
	}	
}
int main()
{
	n=read(),m=read(),Q=read();
	scanf("%s",s+1);
	for(int i=1;i<=m;i++)E[i].u=read(),E[i].v=read();
	build('0');build('1');
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int u=E[i].u,v=E[i].v;
		if(s[u]==s[v])continue;
		int x=find(u),y=find(v);
		if(x==y)continue;
		fa[x]=y;add_edge(u,v);add_edge(v,u);
	}
	spfa();
	while(Q--)
	{
		int x=read(),y=read();
		puts(f[x][y]?"YES":"NO");
	}
	return 0;
}
```


---

## 作者：TheLostWeak (赞：3)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5292.html )

**大致题意：** 给你一张无向图，每个点权值为$0$或$1$，多组询问两点之间是否存在一条回文路径。

### 暴力$DP$

首先，看到$n$如此之小（$n\le5000$），便容易想到一个$O(m^2)$的暴力$DP$。

我们用$f_{i,j}$表示**$i$与$j$两点之间是否存在一条回文路径**。

初始化，$f_{i,i}=1,f_{i,j}=1(s_i=s_j)$，即分别预处理最短的奇数长度回文路径和偶数长度回文路径。

然后我们把所有$f_{i,j}=1$的点对$(i,j)$扔入一个队列里，用类似于$BFS$的方式，每次枚举$i$的一个相邻节点$x$与$j$的一个相邻节点$y$，如果$s_x=s_y$，则显然存在一条回文路径$x->i->j->y$，因此更新$f_{x,y}=1$并将$(x,y)$扔入队列里。

这里要加上一个很显然的优化，即如果$f_{x,y}$原本就为$1$，我们就不进行操作。

这样每组点对最多被枚举一次，这里的时间复杂度是$O(n^2)$。

但枚举相邻节点时要同时枚举两条边，因此复杂度就变成了$O(m^2)$。

不难发现，这个算法时间复杂度的瓶颈就在于枚举两条边这里，因此我们需要考虑对这个地方进行优化。

### 奇偶性与二分图性质

我们先考虑**只在同色点之间连边**。

考虑到**每条边可以重复多次**，也就是说，我们在转移时如果在一条边上无限走，则可以无限刷长度。

但是，我们无限刷长度不一定能改变**奇偶性**。

不过，我们至少可以得出一个结论，在$DP$转移时，只要是奇偶性相同的一段同色路径，我们就可以进行转移。

那么什么时候奇偶性不同也可以转移呢？

这时候就要借助**二分图**的定义来求解了。

考虑先判断当前图是否是二分图，这只需要$DFS$给相邻点染不同颜色，出现矛盾就说明不是二分图，否则是二分图。

而二分图有个性质，即可以将图中点集划分成两部分，其中同一部分的点之间没有边。

也就是说，从一个点出发，必然要沿着这一个点集$->$另一个点集$->$这一个点集$->$另一个点集$->...->$这一个点集这样的路径走才能走回到该点，则经过边数为偶数，无法改变奇偶性。

否则，图中必然存在奇环，而通过奇环就可以改变奇偶性了。

### 大力删边

所以我们前面讲了这么多是要干什么呢？就是为了删掉图中的一些边，使边数变成$O(n)$规模。

我们要明白二分图的另一个性质，即二分图的一棵生成树也满足二分图性质，无法改变奇偶性。

因此，对于每一个是二分图的同色连通块，我们就可以只保留一棵生成树。

而对于不是二分图的连通块，其实我们也可以先取一棵生成树，然后只要给这张图中任意一个节点加上一个自环，这样也可以改变奇偶性，与原连通块是等价的。

而对于**只在异色点之间连边**，也有类似的规律，而且我们可以发现它必定是二分图（将点集按颜色划分成两个点集），可以直接保留生成树。

于是点一下就少了很多，可以直接按前面的暴力$DP$来搞了！

这时边数是$O(n)$，所以时间复杂度也就是$O(n^2)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 5000
#define M 500000
#define mp make_pair
#define fir first
#define sec second
#define add(x,y) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y)
using namespace std;
int n,m,ee,H,T,lnk[N+5],f[N+5][N+5];string s;
struct edge {int to,nxt;}e[(M<<1)+5];
typedef pair<int,int> Pr;Pr q[N*N+5];
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		char c,*A,*B,FI[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
		Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
		I void reads(string& x) {x="";W(isspace(c=tc()));W(x+=c,!isspace(c=tc())&&~c);}
}F;
class GraphBuilder//建新图
{
	private:
		#define nadd(x,y) (ne[++nee].nxt=nlnk[x],ne[nlnk[x]=nee].to=y)//建新边
		int nee,t,col[N+5];
		I void Travel(CI x,CI op)//扫一遍连通块（op表示只能在同色/异色点间连边），建好生成树，同时判断是否为二分图
		{
			for(RI i=lnk[x];i;i=e[i].nxt) (s[x-1]==s[e[i].to-1])==op&&
			(
				col[e[i].to]?(col[x]==col[e[i].to]&&(t=0))//如果产生矛盾说明不是二分图
				:(col[e[i].to]=3-col[x],Travel(e[i].to,op),nadd(x,e[i].to),nadd(e[i].to,x))//给相邻点染上不同颜色
			);
		}
	public:
		int nlnk[N+5];edge ne[(M<<1)+5];
		I void Build()//建图
		{
			#define Clear() for(i=1;i<=n;++i) col[i]=0
			RI i;Clear();for(i=1;i<=n;++i) !col[i]&&(col[i]=t=1,Travel(i,1),!t&&nadd(i,i));//对于非二分图建一个自环
			Clear();for(i=1;i<=n;++i) !col[i]&&(col[i]=1,Travel(i,0),0);
		}
}G;
#define Push(x,y) (q[++T]=mp(x,y),f[x][y]=f[y][x]=1)
I void DP()//动态规划
{
	RI i,j;Pr k;W(H<=T) for(i=G.nlnk[(k=q[H++]).fir];i;i=G.ne[i].nxt)//枚第一个点的相邻节点
		for(j=G.nlnk[k.sec];j;j=G.ne[j].nxt) s[G.ne[i].to-1]==s[G.ne[j].to-1]&&//枚第二个点的相邻节点
			!f[G.ne[i].to][G.ne[j].to]&&Push(G.ne[i].to,G.ne[j].to);//扔入队列中
}
int main()
{
	RI Qtot,i,x,y;for(F.read(n,m,Qtot),F.reads(s),i=1;i<=m;++i)//读入数据
		F.read(x,y),add(x,y),add(y,x),s[x-1]==s[y-1]&&Push(x,y);//初始化队列
	for(G.Build(),i=1;i<=n;++i) Push(i,i);DP();//建新图，初始化队列，然后DP
	W(Qtot--) F.read(x,y),puts(f[x][y]?"YES":"NO");return 0;//对于每个询问输出答案
}
```

---

## 作者：StudyingFather (赞：2)

是 myy 的题 orz

首先给个回文串的形式化递归定义：

- 只有一个字符的串是回文串。
- 只有两个字符的串，如果这两个字符相同，也是回文串；
- 如果 $S$ 是回文串，那么在 $S$ 的开头和末尾插入一个相同的字符，形成的新串也是回文串。

根据前两条，我们可以预处理出所有长度为 $1$（只经过一个点）和长度为 $2$（两个点通过一条边直接相连）的回文串。

根据第三条，我们可以在已有的回文串基础上，尝试在开头和结尾各添加一个新的字符，产生新的回文串。

具体来说，设 $f_{i,j}$ 表示从 $i$ 到 $j$ 是否存在一条回文路径。刚开始将所有长度为 $1$ 和 $2$ 的回文串状态加入队列。每次取出一个状态 $(i,j)$，遍历 $i$ 的所有出点，遍历 $j$ 的所有出点，看是否能扩展出新的回文串。如果可以，就将新的回文串压入队列中。

时间复杂度 $O(m^2)$。

这个转移本身没有什么太大优化空间，我们只能从降低 $m$ 的规模入手。

考虑连接两个标号相同的点的所有边，这些边能够形成若干个连通块。

每个连通块有两种情况：

- 如果连通块是二分图（不存在奇环），经过偶环并不会对串的长度的奇偶性造成改变，再加上允许一条边可以走多次，因此没有必要保留环，只需保留这个连通块的一个生成树即可。
- 如果连通块不是二分图（存在奇环），经过奇环会影响串长度的奇偶性，为了方便处理，我们仍然只保留这个连通块的生成树，并在这个连通块的其中一个点上加一个自环（从而留下改变奇偶性的机会）。

如果把每个颜色相同的连通块看作一个点，所有不同颜色的点之间也能形成若干连通块。容易看出，这些连通块里都不存在奇数环。

因此和上面同理，我们只用保留每个连通块的一个生成树即可，剩下成环的边都可以删除。

最后会剩下多少边呢？可以证明，最多不超过 $2n-2$ 条边。

从而我们将 $m$ 的规模降到了与 $n$ 同阶，我们可以在 $O(n^2)$ 的时间复杂度内解决本题。

```cpp
// Problem : P5292 [HNOI2019]校园旅行
// Contest : Luogu Online Judge
// URL : https://www.luogu.com.cn/problem/P5292
// Author : StudyingFather
// Site : https://studyingfather.com
// Memory Limit : 500 MB
// Time Limit : 2000 ms
// Powered by CP Editor (https://github.com/cpeditor/cp-editor)

#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;
typedef pair<int,int> pii;
struct dsu
{
 int fa[5005];
 void init(int n)
 {
  for(int i=1;i<=n;i++)
   fa[i]=i;
 }
 int find(int x)
 {
  return fa[x]==x?x:fa[x]=find(fa[x]);
 }
 bool merge(int x,int y)
 {
  x=find(x),y=find(y);
  if(x==y)return false;
  fa[y]=x;
  return true;
 }
}d;
int n,m,q;
int col[5005];
char s[5005];
bool flag;
bool res[5005][5005];
vector<int> e1[5005],e2[5005];
queue<pii> que;
void dfs(int u,int c)
{
 col[u]=c;
 for(auto v:e2[u])
  if(col[v]==col[u])flag=false;
  else if(col[v]==-1)
  {
   e1[u].push_back(v);
   e1[v].push_back(u);
   dfs(v,c^1);
  }
}
int main()
{
 ios::sync_with_stdio(false);
 memset(col,-1,sizeof(col));
 cin>>n>>m>>q;
 cin>>(s+1);
 d.init(n);
 for(int i=1;i<=m;i++)
 {
  int u,v;
  cin>>u>>v;
  if(s[u]!=s[v])
  {
   if(d.merge(u,v))
   {
    e1[u].push_back(v);
    e1[v].push_back(u);
   }
  }
  else
  {
   e2[u].push_back(v);
   e2[v].push_back(u);  
  }
 }
 for(int i=1;i<=n;i++)
  if(col[i]==-1)
  {
   flag=true;
   dfs(i,0);
   if(!flag)e1[i].push_back(i);
  }
 for(int i=1;i<=n;i++)
  que.push({i,i}),res[i][i]=true;
 for(int u=1;u<=n;u++)
  for(auto v:e1[u])
  {
   if(v!=u&&s[u]==s[v])
    que.push({u,v}),res[u][v]=true;
  }
 while(!que.empty())
 {
  int x=que.front().first,y=que.front().second;
  que.pop();
  for(auto v1:e1[x])
   for(auto v2:e1[y])
    if(s[v1]==s[v2])
     if(!res[v1][v2])
      res[v1][v2]=true,que.push({v1,v2});
 }
 while(q--)
 {
  int x,y;
  cin>>x>>y;
  cout<<(res[x][y]?"YES":"NO")<<endl;
 }
 return 0;
}
```

---

## 作者：Register (赞：1)

- 首先考虑 $30$ 分的做法，比较显而易见：

设 $F_{i,j}$ 表示 $i$ 到 $j$ 是否可达，考虑任何的 $(i,i)$ 和有边且权值相等的 $(u,v)$ 都是可达的，我们首先把这样的二元组 $(x,y)$ 扔进队列里

接着从队列里依次 $(x,y)$ ，枚举一条连接 $x$ 的边，一条连接 $y$ 的边，判断边的另外两个端点 $i$ 和 $j$ 权值是否相同，若相同，更新 $F_{i,j}$ 后把 $(i,j)$ 扔进队列里

这样做相当于枚举了每一对边，因此时间复杂度为 $O(M^2)$

- 接着考虑满分做法

没有办法换掉原先的状态转移，原来的时间复杂度是 $O(M^2)$ ，考虑把 $M$ 降到与 $N$ 同阶

首先把权值相同的连通块看成一个整体，现在只剩连接颜色不同的点的边了

这东西显然是个二分图，只保留其中的一棵生成树即可（因为没有奇环，而每次转移都是枚举一对边）

接着考虑联通块内，既然刚才都扯到了二分图，现在也继续往这想

如果连通块是个二分图，和刚才同理，只需要保留一棵生成树

如果不是呢？原本是可以改变奇偶性的，只保留生成树后却不行了，所以得加上一个能改变奇偶性的东西

为了方便和边数的限制，还要随便选个点连自环

~~70分是给谁的?没错，是给我这种用一堆STL又不开O2的人~~

- 代码（要开 O2 ）：

```cpp
#include <cstdio>
#include <utility>
#include <vector>
#include <queue>
using namespace std;
inline int read(){
    char ch=getchar();int res=0,w=1;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
    return res*w;
}
int n,m,qu,a[5001],f[5001];
bool flag,ans[5001][5001];
char s[5002];
vector<int> ee[5001],e[5001];
queue<pair<int,int> > q;
int Find(int x) {return f[x]==x?x:f[x]=Find(f[x]);}//并查集搞大生成树
void dfs(int x,int co){//二分图染色和往队列里扔初始的(u,v)
	a[x]=co;
	for(register int i=0;i<ee[x].size();i++)
		if(s[ee[x][i]]==s[x])
		{
			if(a[ee[x][i]]==a[x]) flag=true;//不是二分图
			if(!a[ee[x][i]]) {dfs(ee[x][i],co^1);ans[x][ee[x][i]]=ans[ee[x][i]][x]=true;e[x].push_back(ee[x][i]);e[ee[x][i]].push_back(x);q.push(make_pair(x,ee[x][i]));}
		}
}
signed main(){
	n=read();m=read();qu=read();scanf("%s",s+1);
	for(register int i=1;i<=n;i++) f[i]=i;
	while(m--)
	{
		int u=read(),v=read();ee[u].push_back(v);ee[v].push_back(u);
		if(s[u]!=s[v])
		{
			int fx=Find(u),fy=Find(v);
			if(fx!=fy) {f[fx]=fy;e[u].push_back(v);e[v].push_back(u);}//大生成树
		}
	}
	for(register int i=1;i<=n;i++)
		if(!a[i])
		{
			flag=false;dfs(i,114514);
			if(flag) e[i].push_back(i);//连自环
		}
	for(register int i=1;i<=n;i++) {ans[i][i]=true;q.push(make_pair(i,i));}//把(i,i)扔进去
	while(!q.empty())
	{
		int x=q.front().first,y=q.front().second;q.pop();
		for(register int i=0;i<e[x].size();i++)
			for(register int j=0;j<e[y].size();j++)
				if(!ans[e[x][i]][e[y][j]]&&s[e[x][i]]==s[e[y][j]]) {ans[e[x][i]][e[y][j]]=ans[e[y][j]][e[x][i]]=true;q.push(make_pair(e[x][i],e[y][j]));}
	}
	while(qu--) puts(ans[read()][read()]?"YES":"NO");
    return 0;
}

```

---

## 作者：frank3215 (赞：0)

# 一个边界数据

考虑如下数据：

```text
9 9 1
101011101
1 2
2 3
3 4
1 4
4 5
5 6
6 7
7 8
8 9
1 9
```

它询问下图中$1$到$9$是否有回文串：

![](https://images.cnblogs.com/cnblogs_com/blogs/516461/galleries/1664237/o_210708074142graph.png)

其中括号里的是颜色，括号外的是节点编号，加黑的点是一个回文串。

如果按题解里的算法，建出来的图是这样的：（不信可以随便用一个[AC代码](https://loj.ac/s/1144807)试试看——如果懒的自己改可以看文末附的代码）

![](https://images.cnblogs.com/cnblogs_com/blogs/516461/galleries/1664237/o_210708074512graph%20(1).png)

看似原来的回文串被破坏了，会输出`NO`，但其实$1$到$9$之间还存在一个新的回文串`10101110101`：

$$
1\to2\to3\to4\to5\to6\to7\to8\to7\to8\to9
$$

答案仍然是`YES`，是正确的！这是因为$1-0$边也可以反复经过，可以将$1-0$扩展成$1-0-1-0-\dots-1-0$，原本的回文串依然可以变为新的回文串。

## 实验代码

```cpp
#include "bits/stdc++.h"
#define N 5005
using namespace std;
int n, m, p, l = 1, r, c[N], fa[N];
char str[N], f[N][N];
struct Node {
    int x, y;
} q[N * N];
vector<int>g[N], G[N];
inline int getf(int x) {
    return x == fa[x] ? x : fa[x] = getf(fa[x]);
}
void A(int x, int y) {
    f[x][y] = f[y][x] = 1, q[++r] = {min(x, y), max(x, y)};
}
inline char dfs(int x, int C) {
    char res = 0;
    c[x] = C;

    for (int y : g[x])
        if (c[y] == -1)
            G[x].push_back(y), G[y].push_back(x), res |= dfs(y, C ^ 1), A(x, y);
        else if (c[y] == C)
            res = 1;

    return res;
}
int main(void) {
	freopen("a.in", "r", stdin);
	freopen("a.out", "w", stdout);
    int i, x, y, a, b;
    scanf("%d%d%d%s", &n, &m, &p, str + 1);

    for (i = 1; i <= n; ++i)
        fa[i] = i;

    for (i = 1; i <= m; ++i) {
        scanf("%d%d", &x, &y);

        if (str[x] == str[y])
            g[x].push_back(y), g[y].push_back(x);
        else {
            if ((a = getf(x)) ^ (b = getf(y)))
                fa[a] = b, G[x].push_back(y), G[y].push_back(x);
        }
    }

    for (i = 1; i <= n; ++i)
        c[i] = -1;

    for (i = 1; i <= n; ++i) {
        if (c[i] == -1 && dfs(i, 0))
            G[i].push_back(i);

        A(i, i);
    }

	for (int i = 1; i <= n; ++i) {
		for (int j: G[i]) if (j >= i) {
			printf("%d %d\n", i, j);
		}
	}

    while (l <= r) {
        x = q[l].x, y = q[l].y, ++l;

        for (int a : G[x])
            for (int b : G[y]) {
//				printf("%d %d->%d %d\n", x, y, a, b);
                if (str[a] == str[b] && !f[a][b])
                    A(a, b);
			}
    }

    while (p--)
        scanf("%d%d", &x, &y), puts(f[x][y] ? "YES" : "NO");

    return 0;
}
```

---

## 作者：hl666 (赞：0)

非常妙的一道思博题啊，不愧是myy出的题

首先我们考虑一个暴力DP，直接开一个数组$f_{i,j}$表示$i\to j$的路径能否构成回文串

考虑直接拿一个队列来转移，队列里存的都是$f_{i,j}=1$的点对，然后每次枚举两边的边更新答案并扩展即可

但是这样的复杂度是$O(m^2)$的，不够优秀。我们发现其实这种方法的复杂度瓶颈在于有很多**无用边**导致我们浪费了复杂度，因此我们考虑删去一些边

我们首先在原图上把所有**同色点**间的边连起来，由于每个点可以经过任意次，因此我们只需要考虑**奇偶性**

那么什么时候能让到一个点的奇偶性改变呢？其实很简单，就是存在**奇环**

我们再进一步思考，如果一个图没有奇环，那么它就是**二分图**，而二分图的一个**生成树**显然也满足如上的性质

那么也就意味着，如果此时构成的图是二分图，那么我们求出它的生成树即可

但是如果不是呢，其实也很简单，我们考虑最简单的奇环是什么，其实就是**自环**

所以这种情况我们可以直接找一个点给它连一个自环帮助转移即可

那么剩下的只有异色点之间的边了，这个由于它都帮你染色好了，所以必然是二分图，直接求生成树即可

综上，此时的边数只有$O(n)$级别，因此总复杂度就是$O(n^2)$

CODE

```cpp
#include<cstdio>
#include<utility>
#include<cstring>
#define RI register int
#define CI const int&
#define Ms(f,x) memset(f,x,sizeof(f))
using namespace std;
const int N=5005,M=500005;
typedef pair <int,int> pi;
struct edge
{
    int to,nxt;
}e[M<<1],ne[M<<1]; bool f[N][N],flag; pi q[N*N];
char s[N]; int n,m,t,H,T,head[N],nhead[N],cnt,x,y,col[N];
inline void addedge(CI x,CI y)
{
    e[++cnt]=(edge){y,head[x]}; head[x]=cnt;
    e[++cnt]=(edge){x,head[y]}; head[y]=cnt;
}
inline void nadd(CI x,CI y)
{
    ne[++cnt]=(edge){y,nhead[x]}; nhead[x]=cnt;
}
inline void push(CI x,CI y)
{
    f[x][y]=f[y][x]=1; q[++T]=make_pair(x,y);
}
#define to e[i].to
inline void DFS(CI now,CI tp)
{
    for (RI i=head[now];i;i=e[i].nxt) if ((s[now]==s[to])==tp)
    {
        if (~col[to]) { if (col[to]==col[now]) flag=0; }
        else col[to]=col[now]^1,DFS(to,tp),nadd(now,to),nadd(to,now);
    }
}
#undef to
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i,j; for (scanf("%d%d%d%s",&n,&m,&t,s+1),i=1;i<=m;++i)
    scanf("%d%d",&x,&y),addedge(x,y),s[x]==s[y]&&(push(x,y),0); cnt=0; Ms(col,-1);
    for (i=1;i<=n;++i) if (!~col[i]&&(col[i]=flag=1,DFS(i,1),!flag)) nadd(i,i);
    for (Ms(col,-1),i=1;i<=n;++i) if (!~col[i]) col[i]=1,DFS(i,0);
    for (i=1;i<=n;++i) push(i,i); while (H<T)
    {
        ++H; int x=q[H].first,y=q[H].second;
        for (i=nhead[x];i;i=ne[i].nxt) for (j=nhead[y];j;j=ne[j].nxt)
        if (s[ne[i].to]==s[ne[j].to]&&!f[ne[i].to][ne[j].to]) push(ne[i].to,ne[j].to);
    }
    while (t--) scanf("%d%d",&x,&y),puts(f[x][y]?"YES":"NO"); return 0;
}
```



---

## 作者：Hyscere (赞：0)

这里是[官方题解](http://matthew99.blog.uoj.ac/blog/4968)。

对于$30$分，可以得到一个很显然的做法：设$f[i][j]$表示$i\to j$的答案，然后枚举$i,j$的出边转移，这样做是$O(m^2)$的。

对于$100$分，注意到点的规模没变，我们有一个缩边的想法。

我们把边分成三类，同色的两种和异色的一种，对每类分别建图，然后我们对每个联通块进行考虑：

- 如果当前联通块是二分图，那么可以说明从$i$点到$j$点所经过的边数必然只能是奇数或偶数，那么我们任意处理出一棵生成树，容易发现这棵生成树和原图等价（如果这边多走了就在另一边来回走以抵消）。
- 如果当前联通块不是二分图，那么边数可以是奇数或偶数，那么我们只需要在生成树任意加一个自环就好了，这样的话就可以满足边数任意奇偶，注意异色边建出来的图不可能有这种情况。

缩完之后可以发现边数是$O(n)$级别的，那么我们套用上边的暴力，复杂度达到了$O(n^2)$，足已通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
 
void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

#define lf double
#define ll long long 

const int maxn = 2e5+10;
const int inf = 1e9;
const lf eps = 1e-8;

char s[maxn];
int n,m,Q,vis[maxn],sta[maxn],top,f[5050][5050],flag;

struct Graph {
	int head[maxn],tot,fa[maxn];
	struct edge{int to,nxt;}e[maxn*20];
	
	void add(int u,int v) {e[++tot]=(edge){v,head[u]},head[u]=tot;}
	void ins(int u,int v) {add(u,v),add(v,u);}

	void dfs(int x,int c) {
		vis[x]=c,sta[++top]=x;
		for(int i=head[x];i;i=e[i].nxt)
			if(!vis[e[i].to]) dfs(e[i].to,3-c),fa[e[i].to]=x;
			else flag|=(vis[e[i].to]!=3-c);
	}

	void solve() {
		queue<pair<int,int > > q;
		for(int i=1;i<=n;i++) f[i][i]=1,q.push(make_pair(i,i));
		for(int x=1;x<=n;x++)
			for(int i=head[x];i;i=e[i].nxt)
				if(s[x]==s[e[i].to]) f[x][e[i].to]=1,q.push(make_pair(x,e[i].to));
		while(!q.empty()) {
			int x=q.front().first,y=q.front().second;q.pop();
			for(int i=head[x];i;i=e[i].nxt)
				for(int u,v,j=head[y];j;j=e[j].nxt)
					if(s[u=e[i].to]==s[v=e[j].to])
						if(!f[u][v]) f[u][v]=1,q.push(make_pair(u,v));
		}
	}
}g[3],t;

int main() {
	read(n),read(m),read(Q);scanf("%s",s+1);
	for(int i=1,x,y;i<=m;i++) {
		read(x),read(y);
		if(s[x]!=s[y]) g[0].ins(x,y);
		else if(s[x]=='1') g[1].ins(x,y);
		else g[2].ins(x,y);
	}
	for(int i=0;i<=2;i++) {
		memset(vis,0,sizeof vis);
		for(int j=1;j<=n;j++)
			if(!vis[j]) {
				top=flag=0,g[i].dfs(j,1);
				while(top) {
					int x=sta[top];
					if(g[i].fa[x]) t.ins(g[i].fa[x],x);top--;
				}if(flag) t.ins(j,j);
			}
	}
	t.solve();
	for(int i=1,x,y;i<=Q;i++) read(x),read(y),puts(f[x][y]?"YES":"NO");
	return 0;
}
```



---

## 作者：MLEAutoMaton (赞：0)

## 传送门
[洛谷](https://www.luogu.org/problemnew/show/P5292)

## 吐槽
肯定是因为我太菜了,考场上看到这种题目可以不走简单路径就不会做...

## Solution
考虑我们学过的可以不走简单路径的都有啥?$SPFA$!!!
emmm,回文路径有没有一些神奇的性质?减去首尾还回文!!!~~我呆到考场想不出来这个...~~
那么不妨设$f_{i,j}$表示$i$和$j$之间是否存在回文路径,很显然可以写出转移:
```cpp
while(!Q.empty())
{
    pii now=Q.front();Q.pop();
    int u1=now.first,u2=now.second;
    for(int i=front[u1];i;i=e[i].nxt)
    {
        int v1=e[i].to;
        for(int j=front[u2];j;j=e[j].nxt)
        {
            int v2=e[j].to;
            if(a[v1]==a[v2] && !dis[v1][v2]){dis[v1][v2]=dis[v2][v1]=1;Q.push(mp(v1,v2));}
        }
    }
}
```
然后呢?
这个怎么优化啊?
> 首先对于一个同色联通块，如果它是一个二分图，那么只需要保留一棵生成树就行了，否则随便找个点连一条自环。
> 对于连接不同色两个点的边，一定构成一个二分图，只需要保留一棵生成树就行了。

然后就可以写了.

## 代码实现
```cpp
/*
  mail: mleautomaton@foxmail.com
  author: MLEAutoMaton
  This Code is made by MLEAutoMaton
*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<queue>
#include<set>
#include<map>
#include<iostream>
using namespace std;
#define ll long long
#define re register
#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
typedef pair<int,int> pii;
inline int gi()
{
	int f=1,sum=0;char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return f*sum;
}
const int N=5010,M=500010;
struct node
{
	int to,nxt;
}e[M<<1];
int front[N],cnt,dis[N][N],n,m,a[N];
queue<pii>Q;
#define mp make_pair
void Add(int u,int v)
{
	e[++cnt]=(node){v,front[u]};front[u]=cnt;
}
namespace subtask2
{
	vector<int>G[N];
	int flag,col[N],f[N];
	int find(int x)
	{
		if(f[x]!=x)f[x]=find(f[x]);
		return f[x];
	}
	void dfs(int u,int color)
	{
		col[u]=color;
		for(int i=0;i<G[u].size();i++)
		{
			int v=G[u][i];
			if(a[u]!=a[v])continue;
			if(col[v]==col[u])flag=1;
			if(col[v])continue;
			Add(u,v);Add(v,u);dfs(v,color^1);
			dis[u][v]=dis[v][u]=1;
			Q.push(mp(u,v));
		}
	}
	void main()
	{
		for(int i=1;i<=n;i++)f[i]=i;
		for(int i=1;i<=m;i++)
		{
			int u=gi(),v=gi();
			G[u].push_back(v);
			G[v].push_back(u);
			if(a[u]!=a[v])
				if(find(u)!=find(v)){Add(u,v);Add(v,u);f[find(v)]=find(u);}
		}
		for(int i=1;i<=n;i++)
			if(!col[i])
			{
				flag=0;dfs(i,2);
				if(flag)Add(i,i);
			}
		for(int i=1;i<=n;i++){dis[i][i]=1;Q.push(mp(i,i));}
		while(!Q.empty())
		{
			pii now=Q.front();Q.pop();
			int u1=now.first,u2=now.second;
			for(int i=front[u1];i;i=e[i].nxt)
			{
				int v1=e[i].to;
				for(int j=front[u2];j;j=e[j].nxt)
				{
					int v2=e[j].to;
					if(a[v1]==a[v2] && !dis[v1][v2]){dis[v1][v2]=dis[v2][v1]=1;Q.push(mp(v1,v2));}
				}
			}
		}
	}
}
int main()
{
	n=gi();m=gi();int q=gi();
	for(int i=1;i<=n;i++)
	{
		char ch=getchar();while(ch!='1' && ch!='0')ch=getchar();
		a[i]=ch-'0';
	}
	subtask2::main();
#undef mp
	while(q--)
	{
		int x=gi(),y=gi();
		if(dis[x][y])puts("YES");
		else puts("NO");
	}
	return 0;
}
```

---

## 作者：dsidsi (赞：0)

# Description

给定$n$个点，$m$条边的图。每个点有$0/1$的标号，有$Q$个询问，每次询问点对$(u,v)$间是否一条路径（不一定是简单路径），满足路径经过的点的标号所形成的串是回文串。

$n \leq 5000, m \leq 5000000$

# Solution

设$f_{i,j}$表示$i,j$是否存在一条满足条件的路径。初始状态和转移显然。

考虑每次转移的复杂度太高，而这张图的点数较少，边数较多。

把连接了同一种标号的边拎出来。可以发现这些边使图形成了若干连通块。对于某个连通块，如果它是二分图，那么进行黑白染色后，同色点之间路径的长度只可能为奇数，异色点之间路径长度只可能为偶数。

不难发现，把这张二分图替换为它的一棵生成树，上述性质不变，而一个端点在这个连通块的状态的转移也不变，因为经过原图上的一条边可以替代为经过这条非树边在树上的路径（让另一个端点重复走即可）。而如果这不是二分图，意味着可以可以经过某个环改变路径的奇偶性，所以给这棵生成树加上一个自环。

对于连接不同标号的边同理。经过这样操作之后，边数不超过$2n-2$，直接套用上述暴力$DP$即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 5005, maxm = 500005;

int n, m, q;
vector<pair<int, int>> E[2][2];
int fa[maxn], col[maxn], f[maxn][maxn];
vector<int> to[maxn][2];
char s[maxn];
queue<pair<int, int>> que;

struct edge
{
    int to, next;
} e[maxm * 4];
int h[maxn], tot;

inline int gi()
{
    char c = getchar();
    while(c < '0' || c > '9') c = getchar();
    int sum = 0;
    while('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline void add(int u, int v)
{
    e[++tot] = (edge) {v, h[u]}; h[u] = tot;
    e[++tot] = (edge) {u, h[v]}; h[v] = tot;
    to[u][s[v] - '0'].push_back(v);
    to[v][s[u] - '0'].push_back(u);
}

int find(int x)
{
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}

bool merge(int x, int y)
{
    x = find(x); y = find(y);
    if (x == y) return 0;
    return fa[x] = y, 1;
}

void dfs(int u, int fa)
{
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa) col[v] = col[u] ^ 1, dfs(v, u);
}

void solve(int c1, int c2)
{
    for (int i = 1; i <= n; ++i) h[i] = 0, fa[i] = i;
    tot = 0;
    
    for (auto e : E[c1][c2]) {
        int x = e.first, y = e.second;
        if (merge(x, y)) add(x, y);
    }
    for (int i = 1; i <= n; ++i)
        if (fa[i] == i) col[i] = 0, dfs(i, 0);
    for (auto e : E[c1][c2]) {
        int x = e.first, y = e.second;
        if (col[x] == col[y]) col[find(x)] = -1;
    }
    for (int i = 1; i <= n; ++i)
        if (col[i] == -1) add(i, i);
}

void bfs()
{
    for (int i = 1; i <= n; ++i) f[i][i] = 1, que.push(make_pair(i, i));
    for (int i = 1; i <= n; ++i)
        for (int j : to[i][s[i] - '0']) if (i < j) f[i][j] = 1, que.push(make_pair(i, j));
        
    int u, v, siz1, siz2, i, j, a, b;
    while (!que.empty()) {
        u = que.front().first, v = que.front().second;
        que.pop();
        
        siz1 = to[u][0].size(); siz2 = to[v][0].size();
        for (i = 0; i < siz1; ++i)
            for (j = 0; j < siz2; ++j) {
                a = to[u][0][i], b = to[v][0][j];
                if (a > b) swap(a, b);
                if (f[a][b]) continue;				
                que.push(make_pair(a, b));
                f[a][b] = 1;
            }

        siz1 = to[u][1].size(); siz2 = to[v][1].size();
        for (i = 0; i < siz1; ++i)
            for (j = 0; j < siz2; ++j) {
                a = to[u][1][i], b = to[v][1][j];
                if (a > b) swap(a, b);
                if (f[a][b]) continue;				
                que.push(make_pair(a, b));
                f[a][b] = 1;
            }
    }
}

int main()
{
    n = gi(); m = gi(); q = gi();
    scanf("%s", s + 1);

    for (int u, v, i = 1; i <= m; ++i) {
        u = gi(); v = gi();
        if (s[u] > s[v]) swap(u, v);
        E[s[u] - '0'][s[v] - '0'].push_back(make_pair(u, v));
    }

    solve(0, 0);
    solve(1, 1);
    solve(0, 1);

    bfs();

    for (int a, b, i = 1; i <= q; ++i) {
        a = gi(); b = gi();
        if (a > b) swap(a, b);
        puts(f[a][b] ? "YES" : "NO");
    }
    
    return 0;
}

```

---


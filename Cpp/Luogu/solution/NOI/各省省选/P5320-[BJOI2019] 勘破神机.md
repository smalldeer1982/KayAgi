# [BJOI2019] 勘破神机

## 题目描述

地灾军团的军师黑袍从潜伏在精灵高层的密探手中得知了神杖的情报，他对奥术宝石中蕴含的远古神秘力量十分感兴趣。他设计夺取了数块奥术宝石，并命令作为地灾军团首席科学家的你带领手下的研究人员全力破解。经过了一个月的艰苦尝试，你的研究团队终于破译了 “`2`” 型奥术宝石和 “`3`” 型奥术宝石的内部能量结构。

这两类结构有着一定的相似性，它们的内部具有 $k$ 个反应核心，“`2`” 型奥术宝石的每个核心都可以看成是一个 $2 \times n$ 的网格，而 “`3`” 型奥术宝石的每个核心都可以看成是一个 $3 \times n$ 的网格。（注意奥术宝石的 $k$ 和 $n$ 可能不同）当神力反应进行时，每个核心自动填充满神力颗粒。

形式化地描述，每个神力颗粒可以看成是一个 $1 \times 2$ 横置或竖置的方格，核心填满的定义为每个网格都恰好被一某个方格覆盖。若在两种填满反应核心的方案中存在一个方格放置的位置或方式不同，就认为方案不同。

如填满 $2×4$ 的网格有 $5$ 种不同的方案，填满 $3×2$ 的网格有 $3$ 种不同的方案。

![](https://cdn.luogu.com.cn/upload/pic/57055.png)

如果奥术宝石的 $k$ 个核心的填充方式互不相同，它们就会组合出强大的咒术。黑袍想知道对于某个宝石一共有多少种不同的咒术（对于两种咒术组合，如果第一种咒术中每个核心 $a$ 的填充方式都可以找到第二种咒术的某个核心 $b$ ，使得 $a$ 和 $b$ 的填充方式完全相同，则认为这两种咒术组合相同）。

对于宽度为 $n$ 、反应核心个数为 $k$ 的 “`2`” 型奥术宝石，设不同的咒术为 $F(n,k)$  ；对于宽度为 $n$ 、反应核心个数为 $k$ 的 “`3`” 型奥术宝石，设不同的咒术为 $G(n,k)$  。例如 $F(4,1) = 5$ ，$F(4,2) = 10$ ，$G(2,2) = 3$ 。

地灾军团的科技水平还不能精准测量反应核心的长度 $n$ ，只能确定出核心长度的大致范围  $[l,r]$ 。你需要计算出反应核心长度在此区间内的平均咒术数，即

$$ans2 = \frac{1}{r-l+1}\sum_{n=l}^{r} F(n,k)$$
$$ans3 = \frac{1}{r-l+1}\sum_{n=l}^{r} G(n,k)$$

设最终答案的形式为 $\frac{A}{B}$，输出 $ A \times B^{-1} \bmod 998244353$ 的结果，其中 $B^{-1}$ 是 $B$ 在 $998244353$ 下的乘法逆元。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/57057.png)

对于所有数据，保证不存在 $r-l+1$ 是 $998244353$ 倍数的情况。

由于考场的电脑很慢，出题人更改数据后的所有 $T=1$。

注：本题数据范围有误，实际满足 $1\leq l\leq r\leq 6\times 10 ^ {18}$。

## 样例 #1

### 输入

```
5 2
2 4 2
1 10000 501
52501 233333333333 1
52501 233333333333 2
52501 233333333333 50```

### 输出

```
665496240
218802505
745517510
133015204
910014966```

## 样例 #2

### 输入

```
5 3
2 2 2
1 10000 501
52501 233333333333 1
52501 233333333333 2
52501 233333333333 50```

### 输出

```
3
900767573
52671648
600503426
678428567```

# 题解

## 作者：_rqy (赞：29)

先看 $m=2$。众所周知的是 $2\times n$ 填骨牌的方案是斐波那契数列 $f_{n+1}$，其中 $f_0=0,f_1=1, f_n=f_{n-1}+f_{n-2}$，而要求的东西就是 $\sum_{n=l}^r{f_n\choose k}$ （为了方便我们假设方案是 $f_n$ 而不是 $f_{n+1}$，反正只需要把 $l,r$ 都加上 $1$ 就可以了）

然而斐波那契数列的通项公式为

$$f_n=\frac1{\sqrt5}\left(\frac{1+\sqrt5}{2}\right)^n-\frac1{\sqrt5}\left(\frac{1-\sqrt5}{2}\right)^n$$

设 $A=\frac1{\sqrt5},B=-\frac1{\sqrt5},x=\frac{1+\sqrt5}{2},y=\frac{1-\sqrt5}{2}$，那么有 $f_n=Ax^n+Bx^n$

再加上下降幂与阶乘幂之间的转换

$$x^{\underline k}=\sum_{i=0}^k(-1)^{k-i}s(k,i)x^i$$

（其中 $s(k,i)$ 为第一类斯特林数）

于是

$$\begin{aligned}&\sum_{n=l}^r{f_n\choose k}\\=&\frac1{k!}\sum_{n=l}^r\sum_{i=0}^k(-1)^{k-i}s(k,i)f_n^i\\=&\frac1{k!}\sum_{n=l}^r\sum_{i=0}^k(-1)^{k-i}s(k,i)(Ax^n+By^n)^i\\=&\frac1{k!}\sum_{n=l}^r\sum_{i=0}^k(-1)^{k-i}s(k,i)\sum_{j=0}^i{i\choose j}A^jB^{i-j}(x^jy^{i-j})^n\\=&\frac1{k!}\sum_{i=0}^k(-1)^{k-i}s(k,i)\sum_{j=0}^i{i\choose j}A^jB^{i-j}\sum_{n=l}^r(x^jy^{i-j})^n\\\end{aligned}$$

只需要枚举 $i,j$，然后后面那个 $\sum$ 就是一个等比数列。

不过还有一个问题就是， $\sqrt5$ 这个东西在 $\bmod998244353$ 意义下不存在。

我们对剩余系进行扩域，把每个数表示成 $a+b\sqrt5$ 的形式，就可以做了。

对于 $m=3$，可以发现 $n$ 是奇数的时候方案数是 $0$，而偶数的时候（令 $g_n$ 表示 $2n$ 的答案）可以搞出递推式 $g_n=4g_{n-1}-g_{n-2}$，从而解出通项公式 $g_n=\frac{3+\sqrt3}6(2+\sqrt3)^n+\frac{3-\sqrt3}6(2-\sqrt3)^n$，仍然用上述方法计算即可。

（不过有一个本题中没什么用处的就是，实际上模素数意义下当 $\sqrt{x}$ 不存在的时候 $\sqrt{-x}$ 一定是存在的，因此可以将 $a+b\sqrt x$ 写成 $a+b'i$，其中 $b'=b\sqrt{-x}$ 而 $i^2=1$ （模意义复数！））

附代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
 
typedef long long LL;
const int mod = 998244353;
 
LL pow_mod(LL a, LL b) {
  LL ans = 1;
  for (a %= mod; b; b >>= 1, a = a * a % mod)
    if (b & 1) ans = ans * a % mod;
  return ans;
}
 
template <int a>
struct Sq { // x + y*sqrt(a) (mod 998244353)
typedef Sq<a> sq;
 
LL x, y;
Sq(LL x = 0, LL y = 0) : x(x % mod), y(y % mod) {}
 
inline sq conj() const { return sq(x, -y); }
// assume a is small (a * mod * mod < 2^63)
friend inline sq operator+(const sq &l, const sq &r) { return sq(l.x + r.x, l.y + r.y); }
friend inline sq operator-(const sq &l, const sq &r) { return sq(l.x - r.x, l.y - r.y); }
friend inline sq operator*(const sq &l, const sq &r) { return sq(l.x * r.x + a * l.y * r.y, l.x * r.y + l.y * r.x); }
friend inline sq operator/(const sq &l, const sq &r) { return sq(l.x * r.x - a * l.y * r.y, l.y * r.x - l.x * r.y) * pow_mod(r.x * r.x - a * r.y * r.y, mod - 2); }
inline sq& operator+=(const sq &t) { x = (x + t.x) % mod; y = (y + t.y) % mod; return *this; }
inline sq& operator-=(const sq &t) { x = (x - t.x) % mod; y = (y - t.y) % mod; return *this; }
inline sq& operator*=(const sq &t) { return *this = *this * t; }
sq operator^(LL t) const {
  sq ans = 1, x = *this;
  for (; t; t >>= 1, x *= x) if (t & 1) ans *= x;
  return ans;
}
inline sq sum_pow(LL t) { return (1 + this->pow(t + 1)) / (1 + *this); } // (x^(t+1)-1) / (x-1)
inline void put() { printf("%lld+%llds%d", (x + mod) % mod, (y + mod) % mod, a); }
};
 
const int K = 550;
LL C[K][K], ss[K][K], fac[K];
 
template <int a>
Sq<a> Solve(Sq<a> A, Sq<a> p, Sq<a> B, Sq<a> q, int k, LL l, LL r) {
  ++r;
  Sq<a> ans = 0, qr = q^r, ql = q^l, pr = p^r, pl = p^l;
  Sq<a> ppl = 1, ppr = 1, pp = 1, pA = 1;
  for (int u = 0; u <= k; ++u) {
    Sq<a> pql = 1, pqr = 1, pq = 1, pB = 1;
    for (int v = 0; u + v <= k; ++v) {
      Sq<a> quq = pp * pq - 1, qvq = ppr * pqr - ppl * pql;
      Sq<a> qaq = !quq.x && !quq.y ? (r - l) % mod : qvq / quq;
      Sq<a> qwq = ss[k][u + v] * C[u + v][u] % mod * pA * pB * qaq;
      ans += qwq;
      pB *= B; pql *= ql; pqr *= qr; pq *= q;
    }
    pA *= A; ppl *= pl; ppr *= pr; pp *= p;
  }
  return ans * pow_mod(fac[k], mod - 2);
}
 
void Init() {
  for (int i = 0; i < K; ++i)
    for (int j = C[i][0] = 1; j <= i; ++j)
      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
  fac[0] = 1;
  for (int i = 1; i < K; ++i) fac[i] = i * fac[i - 1] % mod;
  ss[0][0] = 1;
  for (int i = 0; i + 1 < K; ++i) {
    ss[i + 1][0] = - i * ss[i][0];
    for (int j = 1; j <= i + 1; ++j)
      ss[i + 1][j] = (ss[i][j - 1] - i * ss[i][j]) % mod;
  }
}
 
int main() {
  Init();
  int T, m;
  scanf("%d%d", &T, &m);
  while (T--) {
    LL l, r; int k;
    scanf("%lld%lld%d", &l, &r, &k);
    if (m == 2) {
      Sq<5> p = Sq<5>(1, 1) / 2, t = Sq<5>(0, 1) / 5;
      printf("%lld\n", (Solve(t, p, t.conj(), p.conj(), k, l + 1, r + 1).x * pow_mod(r - l + 1, mod - 2) % mod + mod) % mod);
    } else {
      Sq<3> p = Sq<3>(2, 1), t = Sq<3>(3, 1) / 6;
      printf("%lld\n", (Solve(t, p, t.conj(), p.conj(), k, (l + 1) / 2, r / 2).x * pow_mod(r - l + 1, mod - 2) % mod + mod) % mod);
    }
  }
}
```

---

## 作者：NaCly_Fish (赞：15)

EI 的题解写的有些简短，我就做一点微小的工作，详细解释一下吧。
****
先来说一下 $m=3$ 的情况。  
已知长度为 $2n$ 的时候，填充方案为：
$$g_n=\frac{3+\sqrt 3}{6}(2+\sqrt 3)^n+\frac{3-\sqrt 3}{6}(2-\sqrt 3)^n$$
由于递推式特征方程的两个根互为倒数，所以 $g_n$ 就可以写成这样的形式：
$$g_n=A\alpha^n+B\alpha^{-n}$$
其中 $\alpha = 2+\sqrt 3$。

再代入那个组合数中
$$\binom{g_n}{k}$$
$$=\frac 1{k!}\left(A\alpha^n+B\alpha^{-n} \right)^{\underline k}$$
$$=\frac{1}{k!}\prod_{i=0}^{k-1}(A\alpha^{n}-i+B\alpha^{-n})$$
用 $x$ 换掉 $\alpha^n$ 就成了
$$\frac{1}{k!}\prod_{i=0}^{k-1}(Ax-i+Bx^{-1})$$
这样就可以把 $G(2n,k)$ 表示为关于 $\alpha^n$ 的一个 $\Theta(k)$ 次多项式。（虽然有负数次项，但这里还是叫多项式）

设 $p_n$ 为这个多项式的 $n$ 次项系数，答案就能表示为
$$\sum_{i=l}^r\sum_{j=-k}^k p_j\alpha^{ij}$$
$$=\sum_{j=-k}^kp_j\sum_{i=l}^r \alpha^{ji}$$
（为方便表示，这里 $l,r$ 分别是原来的 $(l+1)/2$ 和 $r/2$）  
直接枚举 $j$，等比数列求和算出后面那块，这部分就是 $\Theta(k \log r)$ 的。

然后就是求那个多项式系数的问题。  
其实很简单，里面每一项都乘 $x$，分治乘解决，最后除个 $x^k$ 就完了，时间复杂度 $\Theta(k \log^2 k)$。  

或许复杂度还可以去掉一个 $\log$，到时候再补（
****
对于 $m=2$ 的情况，看起来就要麻烦一些，，因为方案数只能表示成这样的形式：
$$f_n=A \alpha^n+B(-\alpha)^{-n}$$
就是这个小小的符号，却成了一块绊脚石 —— 但不用慌，我们直接分类讨论 $n$ 的奇偶性。

然后就能得出对于奇、偶的 $n$ 时，组合数关于 $\alpha^n$ 的系数多项式：
$$\frac{1}{k!}\prod_{i=0}^{k-1}(Ax-i-Bx^{-1}) \ \ (n \bmod 2 = 1)$$
$$\frac{1}{k!}\prod_{i=0}^{k-1}(Ax-i+Bx^{-1}) \ \ (n \bmod 2 = 0)$$
设 $p_n,q_n$ 分别为上面两个多项式的系数，答案就能表示为
$$\sum_{j=-k}^k \left( p_j\sum_{i=l}^r[2|(i-1)]\alpha^{ji}\right)+\left( q_j\sum_{i=l}^r[2|i]\alpha^{ji}\right)$$
$$=\frac 12\sum_{j=-k}^k\left( p_j\sum_{i=l}^r(1+(-1)^{i-1})\alpha^{ji}\right)+\left(q_j\sum_{i=l}^r(1+(-1)^i)\alpha^{ji} \right)$$
$$=\frac 12\sum_{j=-k}^k \left(p_j \sum_{i=l}^{r}\alpha^{ji}-(-\alpha^j)^i\right)+\left( q_j\sum_{i=l}^r \alpha^{ji}+(-\alpha^j)^i\right)$$
$$=\frac 12\sum_{j=-k}^k\left((q_j+p_j)\sum_{i=l}^r\alpha^{ji}\right)+\left( (q_j-p_j)\sum_{i=l}^r(-\alpha^j)^i\right)$$
然后就能像 $m=3$ 的情况一样直接计算了，时间复杂度同样是 $\Theta(k\log ^2 k + k \log r)$。

代码：
```cpp
#pragma GCC optimize (2)
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 4102
#define ll long long
#define reg register
#define p 998244353
using namespace std;

inline int add(const int& x,const int& y){ return x+y>=p?x+y-p:x+y; }
inline int dec(const int& x,const int& y){ return x<y?x-y+p:x-y; }

inline int intpow(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int sq;

struct complex{
    int r,i;
    inline complex(int _r=0,int _i=0):r(_r),i(_i){}
};

inline complex operator + (const complex& lhs,const complex& rhs){ return complex(add(lhs.r,rhs.r),add(lhs.i,rhs.i)); }
inline complex operator - (const complex& lhs,const complex& rhs){ return complex(dec(lhs.r,rhs.r),dec(lhs.i,rhs.i)); }
inline complex operator * (const complex& lhs,const complex& rhs){ return complex(((ll)lhs.r*rhs.r+(ll)lhs.i*rhs.i*sq)%p,((ll)lhs.r*rhs.i+(ll)lhs.i*rhs.r)%p); }
inline complex operator - (const complex& x){ return complex(dec(0,x.r),dec(0,x.i)); }
inline complex operator * (const complex& lhs,const int& rhs){ return complex((ll)lhs.r*rhs%p,(ll)lhs.i*rhs%p); } 

inline complex power(complex a,ll t){
    complex res = complex(1,0);
    while(t){
        if(t&1) res = res*a;
        a = a*a;
        t >>= 1;
    }
    return res;
}

inline complex inv(complex x){
    int d = ((ll)x.r*x.r-(ll)x.i*x.i*sq%p+p)%p;
    return complex(x.r,p-x.i)*intpow(d,p-2);
}

inline complex operator / (const complex& lhs,const complex& rhs){ return lhs*inv(rhs); }

int rt[N],rev[N],fac[N],ifac[N];
int siz;

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    w = intpow(3,(p-1)>>siz);
    fac[0] = fac[1] = ifac[0] = ifac[1] = rt[lim>>1] = 1;
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=n;++i) fac[i] = (ll)fac[i-1]*i%p;
    ifac[n] = intpow(fac[n],p-2);
    for(reg int i=n-1;i;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
}

inline void dft(int *f,int lim){
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
}

inline void idft(int *f,int lim){
    reverse(f+1,f+lim);
    dft(f,lim);
    int x = p-((p-1)>>__builtin_ctz(lim));
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

inline void multiply(const complex *f,const complex *g,int n,int m,complex *t,int len){
    if(n+m<=64){
        for(reg int i=0;i<=len;++i) t[i] = complex(0,0);
        for(reg int i=0;i<=n;++i)
        for(reg int j=0;j<=m;++j){
            if(i+j>len) break;
            t[i+j] = t[i+j]+f[i]*g[j];
        }
        return;
    }
    static int a[N],b[N],P[N],q[N],r[N],s[N];
    int lim = getlen(n+m);
    for(reg int i=0;i<=n;++i) P[i] = f[i].r,q[i] = f[i].i;
    for(reg int i=0;i<=m;++i) r[i] = g[i].r,s[i] = g[i].i;
    memset(P+n+1,0,(lim-n)<<2),memset(q+n+1,0,(lim-n)<<2);
    memset(r+m+1,0,(lim-m)<<2),memset(s+m+1,0,(lim-m)<<2);
    dft(P,lim),dft(q,lim),dft(r,lim),dft(s,lim);
    for(reg int i=0;i!=lim;++i){
        a[i] = ((ll)P[i]*r[i]+(ll)q[i]*s[i]*sq)%p;
        b[i] = ((ll)P[i]*s[i]+(ll)q[i]*r[i])%p;
    }
    idft(a,lim),idft(b,lim);
    for(reg int i=0;i<=len;++i) t[i] = complex(a[i],b[i]);
}

void product(int l,int r,complex x,complex y,complex *t){
    if(l==r){
        t[0] = x,t[2] = y;
        t[1] = complex(l==0?0:p-l,0);
        return;
    }
    int mid = (l+r)>>1;
    int ls = mid-l+1,rs = r-mid;
    complex f[(ls+2)<<1],g[(rs+2)<<1];
    product(l,mid,x,y,f);
    product(mid+1,r,x,y,g);
    multiply(f,g,ls<<1,rs<<1,t,(ls+rs)<<1);
}

inline complex sum(ll l,ll r,complex q){
    if(q.r==1&&q.i==0) return (r-l+1)%p;
    return (power(q,r+1)-power(q,l))/complex(dec(q.r,1),q.i);
}

int subtask2(ll l,ll r,int k){
    sq = 5;
    int inv2 = 499122177,inv5 = intpow(5,p-2);
    complex q,alpha = complex(inv2,inv2),ans = complex(0,0);
    complex A = complex(0,inv5),B = complex(0,p-inv5);
    static complex f[N],g[N];
    product(0,k-1,-B,A,f);
    product(0,k-1,B,A,g);
    q = power(inv(alpha),k);
    for(reg int i=0;i<=(k<<1);++i){
        complex fi = g[i]+f[i],gi = g[i]-f[i];
        ans = ans+sum(l,r,q)*fi+sum(l,r,-q)*gi;
        q = q*alpha;
    }
    return (ll)ans.r*ifac[k]%p*inv2%p;
}

int subtask3(ll l,ll r,int k){
    int inv6 = intpow(6,p-2);
    l = (l+1)>>1,r >>= 1;
    sq = 3;
    complex q,alpha = complex(2,1),ans = complex(0,0);
    complex A = complex(3,1)*inv6,B = complex(3,p-1)*inv6;
    static complex f[N];
    product(0,k-1,B,A,f);
    q = power(inv(alpha),k);
    for(reg int i=0;i<=(k<<1);++i){
        ans = ans+sum(l,r,q)*f[i];
        q = q*alpha;
    }
    return (ll)ans.r*ifac[k]%p;
}

int main(){
    int T,m,k,ans;
    ll l,r;
    scanf("%d%d",&T,&m);
    init(1025);
    while(T--){
        scanf("%lld%lld%d",&l,&r,&k);
        if(m==3) ans = subtask3(l,r,k);
        else ans = subtask2(l+1,r+1,k);
        ans = (ll)ans*intpow((r-l+1)%p,p-2)%p;
        printf("%d\n",ans);
    }
    return 0;   
}
```

---

## 作者：Elegia (赞：13)

扩域以及怎么用特征根优化到 $\Theta(k^2\log r)$ 的部分相信 rqy 已经讲得很清楚了，再此不予赘述，但是这道题可以进一步优化。

事情的经过其实是这样的……偶然看到了 cz_xuyixuan 用 BM 直接给[莽过去](https://loj.ac/submission/783025)了，感到有点诧异，于是就冷静了一下，发现这道题的特征根有很强的性质：

- 对于 $T=2$ 的部分，因为递推式是 $x^2-x-1$，所以两个特征根的乘积是 $-1$。
- 对于 $T=3$ 的部分，因为递推式是 $x^2-4x+1$，所以两个特征根的乘积是 $1$。

所以，我们原以为 $\alpha^i \beta^j$ 总共有 $\Theta(k^2)$ 种，但是在此题中只有 $\Theta(k)$ 种……

那么如何做到更快就呼之欲出了，我们只需要算出每个 $\alpha^i\beta^j$ 的系数就行了。

- 对于 $T=3$ 的情况，因为 $\alpha\beta = 1$，我们欲求 $\displaystyle\sum_n \binom{\lambda \alpha^n + \mu \alpha^{-n}} k$ 表为 $\displaystyle\sum_{-k\le j\le k} \nu _j \alpha^{jn}$ 的系数 $\nu_j$，只需计算 $\displaystyle\frac1{k!}\prod_{i=0}^{k-1} (\lambda x - i + \mu x^{-1})$ 的系数表示，可以 $O(k \log^2 k)$。

- 对于 $T=2$ 的情况，因为 $\alpha \beta = -1$，我们所求可以表为 $\displaystyle \sum_{-k \le j\le k} \xi_j \alpha^{jn} + \zeta _j (-\alpha)^{jn}$，只需计算 $\displaystyle\frac1{k!}\prod_{i=0}^{k-1} (\lambda x - i + \mu x^{-1}t) \bmod (t^2-1)$ 的系数表示，其中 $[t^0]$ 对应 $\xi$ 数列，$[t^1]$ 对应 $\zeta$ 数列，可以 $O(k\log^2 k)$。

由此，可以在 $O(k\log^2 k + k\log r)$ 时间内计算出。



---

## 作者：ViXbob (赞：7)

[滋磁去我的博客看吖](http://www.vixbob-lwc.pw/2019/05/18/BJOI2019/)

又是二合一...

下文中$x^{\underline{n}}$表示$x$的$n$次下降幂，即：$x^{\underline{n}}=\prod_{i=1}^n(x-i+1)$

先考虑第一问：

这个东西实际上就上要我们求：
$$\sum_{i=l}^r\binom{f[i]}{k}$$
$f[i] = fib[i+1]$.

考虑展开：
$$\sum_{i=l}^r\frac{f[i]^{\underline{k}}}{k!}$$
想的时候是往生成函数方面想的，你直接把$x^{\underline{n}}$看成一个$n$次多项式就可以把这个下降幂转成一个幂和的形式了。事后发现原来这个多项式的系数就是有符号第一类斯特林数.....(~~没学过，告辞~~)

然后有：
$$\frac{1}{k!}\sum_{i=l}^r\sum_{j=1}^k\begin{bmatrix}k\\j\end{bmatrix}_sf[i]^j$$
显然有$f[i]$的递推式：
$$\begin{cases}f[n]=1, 0\le n\le1\\f[n]=f[n-1]+f[n-2],n>1\end{cases}$$
然后我们用特征方程解一下可得：
$$f[n]=\frac{5+\sqrt5}{10}\left(\frac{1+\sqrt5}{2}\right)^n+\frac{5-\sqrt5}{10}\left(\frac{1-\sqrt5}{2}\right)^n$$
则$f[n]$可以被表示为$A\alpha^n+B\beta^n$的形式，我们把这个代回上式有：
$$\begin{aligned}&\frac{1}{k!}\sum_{i=l}^r\sum_{j=1}^k\begin{bmatrix}k\\j\end{bmatrix}_s\left(A\alpha^i+B\beta^i\right)^j\\=&\frac{1}{k!}\sum_{i=l}^r\sum_{j=1}^k\begin{bmatrix}k\\j\end{bmatrix}_s\sum_{v=0}^j\binom{j}{v}A^v\alpha^{iv}B^{j-v}\beta^{i(j-v)}\\=&\frac{1}{k!}\sum_{j=1}^k\begin{bmatrix}k\\j\end{bmatrix}_s\sum_{v=0}^j\binom{j}{v}A^vB^{j-v}\sum_{i=l}^r(\alpha^{v}\beta^{j-v})^i\end{aligned}$$
后面明显是个等差数列的形式直接用公式就好了。(注意存在公比为一的情况)

但是有个问题就是$\sqrt5$在膜$998244353$的意义下并不存在。我们可以尝试模仿复数，也搞一个"虚部"$i$，只不过这个$i^2=5$。因为斐波那契数列最后求出来一定是个整数所以虚部的系数一定为$0$.

考虑第二问：

先考虑求出这个东西的递推式，首先$n$为奇数的时候方案肯定等于零。所以我们设$g_i$表示$n =2\times i$的方案数。

考虑怎么递推，首先最后的一个$3 \times 2$的块中有三种摆放方式，但这一种转移肯定是漏掉了一些方案的，实则我们可以跨越最后一个偶数位置，如图：

![](https://s2.ax1x.com/2019/05/18/EOkqzR.png)

然后我们枚举一下第二种情况跨越红线的数量就有递推式：
$$\begin{aligned}g[n]&=3\times g[n-1]+2\times\sum_{i=1}^{n-1}g[n-1-i]\\&=3 \times g[n-1]+2\times\sum_{i=0}^{n-2}g[i]\end{aligned}$$
则有：
$$\begin{cases}g[n]=3 \times g[n-1]+2\times\sum_{i=0}^{n-2}g[i]\\g[n+1]=3\times g[n]+2\times g[n-1]+2\times \sum_{i=0}^{n-2}g[i]\end{cases}$$
差分一下：
$$g[n+1]=4 \times g[n]-g[n-1]$$
也就是说$g[n]$的递推式为：
$$\begin{cases}g[n]=1,n=0\\g[n]=3,n=1\\g[n]=4 \times g[n-1]-g[n-2],n>1\end{cases}$$
用特征方程方程解得：
$$g[n]=\frac{3+\sqrt3}{6}(2+\sqrt3)^n+\frac{3-\sqrt3}{6}(2-\sqrt3)^n$$
然后就是一模一样的了。复杂度$O(k^2 \log{(r-l)})$。

代码：

```cpp
/*
 * 3090.cpp
 * This file is part of 3090
 *
 * Copyright (C) 2019 - ViXbob
 *
 * 3090 is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * 3090 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with 3090. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * There is no end though there is a start in space. ---Infinity.
 * It has own power, it ruins, and it goes though there is a start also in the star. ---Finite.
 * Only the person who was wisdom can read the most foolish one from the history.
 * The fish that lives in the sea doesn't know the world in the land.
 * It also ruins and goes if they have wisdom.
 * It is funnier that man exceeds the speed of light than fish start living in the land.
 * It can be said that this is an final ultimatum from the god to the people who can fight.
 *
 * Steins;Gate
 */
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define dep(i, j, k) for(int i = j; i >= k; --i)
#define SIZE(x) ((int)x.size())
#define mp(x, y) make_pair(x, y)
#define pb(x) push_back(x)
#define inv(x) (ksm(x, P - 2))

typedef long long ll;
typedef unsigned long long ull;

using namespace std;

const int maxn = 5e2 + 15;
const int P = 998244353;
const int inf = 0x3f3f3f3f;

int T, m, k, sqr, C[maxn][maxn], S[maxn][maxn], V, ans, fac[maxn], ifac[maxn];
ll l, r, n, N;

inline ll read() {
	char ch = getchar(); ll u = 0, f = 1;
	while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar(); }
	while(isdigit(ch))  { u = u * 10 + ch - 48; ch = getchar(); } return u * f;
}

struct Complex {
	int x, y;
	Complex(int a = 0, int b = 0) { x = a; y = b; }
	Complex operator + (const Complex &t) const { return Complex((x + t.x) % P, (y + t.y) % P); }
	Complex operator - (const Complex &t) const { return Complex((x - t.x + P) % P, (y - t.y + P) % P); }
	Complex operator * (const Complex &t) const { return Complex((1ll * x * t.x % P + 1ll * V * y % P * t.y % P) % P, (1ll * x * t.y % P + 1ll * y * t.x % P) % P); }
	Complex operator * (const int &t) const { return Complex(1ll * x * t % P, 1ll * y * t % P); }
} A, B, alpha, beta;

inline int pls(int x, int y) { x += y; return x >= P ? x - P : x; }
inline int dec(int x, int y) { x -= y; return x < 0 ? x + P : x; }
inline int mul(int x, int y) { return 1ll * x * y % P; }
inline int ksm(int x, ll k, int rnt = 1) {
	for(ll i = k; i; i >>= 1, x = 1ll * x * x % P) if(i & 1) rnt = 1ll * rnt * x % P;
	return rnt;
}
inline Complex ksm(Complex x, ll k, Complex rnt = Complex(1, 0)) {
	for(ll i = k; i; i >>= 1, x = x * x) if(i & 1) rnt = rnt * x;
	return rnt;
}
inline Complex Inv(Complex a) { return Complex(a.x, P - a.y) * inv((1ll * a.x * a.x % P - 1ll * V * a.y % P * a.y % P + P) % P); }

const int inv2 = inv(2), inv10 = inv(10), inv6 = inv(6);

int main() {
//	freopen("1.in", "r", stdin);
//	freopen("my.out", "w", stdout);
	T = read(); m = read(); V = (m == 2) ? 5 : 3; S[1][1] = 1;
	rep(i, 0, maxn - 1) C[i][0] = 1;
	rep(i, 1, maxn - 1) rep(j, 1, i) C[i][j] = pls(C[i - 1][j - 1], C[i - 1][j]);
	rep(i, 2, maxn - 1) rep(j, 1, i) S[i][j] = dec(S[i - 1][j - 1], mul(i - 1, S[i - 1][j]));
	fac[0] = 1;
	rep(i, 1, maxn - 1) fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[maxn - 1] = inv(fac[maxn - 1]);
	dep(i, maxn - 2, 0) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	while(T--) {
		l = read(); r = read(); k = read(); ans = 0; N = r - l + 1;
		if(m == 2) {
			A = Complex(inv2, inv10); B = Complex(inv2, P - inv10);
			alpha = Complex(inv2, inv2); beta = Complex(inv2, P - inv2);
		} else {
//			l -= !(l & 1); r += (r & 1);
//			l = l + 1 >> 1; r >>= 1;
			l = l + 1 >> 1; r >>= 1;
			A = Complex(inv2, inv6); B = Complex(inv2, P - inv6);
			alpha = Complex(2, 1); beta = Complex(2, P - 1);
		} n = r - l + 1;
//		cerr << (A * ksm(alpha, 3) + B * ksm(beta, 3)).x << endl;
//		cerr << l << " " << r << " " << n << endl;
		rep(i, 1, k) {
			Complex tmp(0, 0);
			rep(j, 0, i) {
				Complex c = ksm(A, j) * ksm(B, i - j);
				Complex q = ksm(alpha, j) * ksm(beta, i - j);
				Complex goal = (ksm(q, n + 1) - q) * Inv(q - Complex(1, 0));
				if(q.x == 1 && q.y == 0) goal = q * (n % P);
				tmp = tmp + c * goal * C[i][j] * ksm(q, l - 1);
			}
//			cerr << tmp.x << " " << tmp.y << " " << S[k][i] << endl;
			ans = (ans + 1ll * S[k][i] * tmp.x % P) % P;
		}
		printf("%d\n", 1ll * ans * inv(N % P) % P * ifac[k] % P);
	}
	return 0;
}
/*
1 2 3 5
1 + 3 + 10
14 / 3
x
x(x-1)=-x+x^2
x(x-1)(x-2)=(x^2-x)(x-2)=2x-3x^2+x^3
(x^3-3x^2+2x)(x-3)=-6x+11x^2-6x^3+x^4

0 0 0 0 0 0 0  0  1 -1
0 0 0 0 0 0 0  1 -3  2
0 0 0 0 0 0 1 -6 11 -6
0 0 0 0 0 1 -10 35 -50 24

f[1]
f[2]
f[3] = f[1] * f[2]
f[4] = f[1] * f[2] ^ 2
f[5] = f[1] ^ 2 * f[2] ^ 3
f[6] = f[1] ^ 3 * f[2] ^ 5
f[7] = f[1] ^ 5 * f[2] ^ 8
f[n] = f[n - 1] * f[n - 2]
f[n] = f[1] ^ fib[n - 2] * f[2] ^ fib[n - 1];

1 1 2 3 5 8 13

*/
```

---

## 作者：Lyrella (赞：6)

# 简要题意

设 $f(n)$ 表示用多米诺骨牌恰好铺满 $2\times n$ 的平面的方案数，$g(n)$ 表示用多米诺骨牌恰好铺满 $3\times n$ 的平面的方案数；设 $F(n,k)={f(n)\choose k},G(n,k)={g(n)\choose k}$，求：
$$
\begin{aligned}
ans1={1\over r-l+1}\sum_{i=l}^rF(i,k)\\
ans2={1\over r-l+1}\sum_{i=l}^rG(i,k)
\end{aligned}
$$

# 题解

## $f$ 和 $g$ 的公式

首先我们需要表示出 $f$ 和 $g$。$f$ 是好递推的，我们可以**用竖着的一张牌**把最后一列直接填满，也可以**用两张横着的牌**填满最后两列，所以就可以直接得出 $f$ 的递推式：
$$
f(n)=f(n-1)+f(n-2),f(0)=1,f(1)=1
$$
然后列出递推式的特征方程：
$$
x^2-x-1=0
$$
解得：
$$
\begin{cases}
x_1={1-\sqrt5\over2}\\
x_2={\sqrt5+1\over2}
\end{cases}
$$
设 $f(n)=A\times x_1^n+B\times x_2^n$，将 $f(0)=f(1)=1$ 代入可以求得 $f$ 的通项公式：
$$
f(n)={5+\sqrt5\over10}\left({1+\sqrt5\over2}\right)^n+{5-\sqrt5\over10}\left({1-\sqrt5\over2}\right)^n
$$
现在我们尝试推导一下 $g$ 式子。首先能发现当 $2\nmid n$ 时无解，所以我们改一下 $g$ 的定义，设 $g(n)$ 表示用多米诺骨牌恰好铺满 $3\times 2n$ 的平面的方案数。如果我们选择**最后不去横跨 $3\times2$ 的方格**那么有 $g(n)\leftarrow 3\times g(n-1)$；而如果我们选择**横跨第 $i$ 到第 $n-1$ 个 $3\times2$ 的方格**，可以发现后半部分只有两种情况如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/afg5cdh7.png)

于是对第二种情况我们枚举分界点，可得到完整 $g$ 的式子：
$$
g(n)=3\times g(n-1)+2\sum_{i=0}^{n-2}g(i)
$$
但是呢这个式子实在是**太不优美**，因为存在 $O(n)$ 项，于是考虑差分：
$$
\begin{aligned}
g(n)-g(n-1)&=3\times g(n-1)-3\times g(n-2)+2\times g(n-2)\\
g(n)&=4\times g(n-1)-g(n-2)
\end{aligned}
$$
求出 $g$ 的递推式后我们可以依葫芦画瓢得到 $g$ 的通向式：
$$
g(n)={3+\sqrt3\over6}\left(2+\sqrt3\right)^n+{3-\sqrt3\over6}\left(2-\sqrt3\right)^n
$$

## 后续的推导

求出两个函数的通向式后我们需要解决下面的问题：
$$
{1\over r-l+1}\sum_{n=l}^r{Ax_1^n+Bx_2^n\choose k}
$$
因为这里 $l$ 和 $r$ 太大了，直接做肯定不行。观察到只有 $k$ 是小的，所以想把上面的东西变成和 $k$ 有关的和式。我们先把组合数拆开：
$$
ans={1\over(r-l+1)k!}\sum_{n=l}^r\left(Ax_1^n+Bx_2^n\right)^{\underline k}
$$
现在不管和式外面的东西，考虑里面最令人难受的是**有一个 k 次下降幂**。这启发我们将下降幂转成顺眼的普通幂。斯特林数在此不做展开，如果想学习斯特林数有关的知识这里推荐[我的博客](https://www.cnblogs.com/Lyrella/p/18688632)。

好了回归正题，我们用下降幂转普通幂就得到：
$$
\sum_{n=l}^r\sum_{i=0}^k(-1)^{k-i}{k\brack i}\left(Ax_1^n+Bx_2^n\right)^i
$$
用二项式定理展开最后的普通幂：
$$
\sum_{n=l}^r\sum_{i=0}^k(-1)^{k-i}{k\brack i}\sum_{j=0}^i{i\choose j}A^iB^{i-j}\left(x_1^ix_2^{i-j}\right)^n
$$
调一下和式顺序，最后得到：
$$
\sum_{i=0}^k(-1)^{k-i}{k\brack i}\sum_{j=0}^i{i\choose j}A^iB^{i-j}\sum_{n=l}^r\left(x_1^ix_2^{i-j}\right)^n
$$
最后面的是等比数列求和，有：
$$
\sum_{i=l}^rx^i={x^{r+1}-x^l\over x-1}
$$
记得特判 $x=1$ 的情况，时间复杂度 $O(k^2\log r)$。

## 对取模意义下根号的处理

在取模意义下并不是所有的数都有**二次剩余**，所以我们需要寻找新的解决方式。对于此题因为根号下只有一种数，所以我们可以进行一个**类似复数的定义**：我们将所有数写成 $a+bi$ 的形式，其中 $i^2=x$。举一个例子，若根号下只有 5，也就是 $f$ 的计算，我们令 $i^2=5$，然后类比复数的运算计算答案即可。

# 代码

```cpp
const int K = 505, p = 998244353;
int isq;

inline int Add(int x, int y){return x - p + y >= 0 ? x - p + y : x + y;}
inline int Sub(int x, int y){return x < y ? x - y + p : x - y;}
inline int Mul(int x, int y){return 1ll * x * y % p;}
inline int Mo(ll x){return (x % p + p) % p;}

struct cp{int a, b; cp(ll _a = 0, ll _b = 0){a = Mo(_a), b = Mo(_b);}};
inline cp operator + (cp x, cp y){return cp{Add(x.a, y.a), Add(x.b, y.b)};}
inline cp operator - (cp x, cp y){return cp{Sub(x.a, y.a), Sub(x.b, y.b)};}
inline cp operator * (cp x, cp y){return cp{Add(Mul(x.a, y.a), Mul(isq, Mul(x.b, y.b))), Add(Mul(x.a, y.b), Mul(x.b, y.a))};}
inline cp operator ^ (cp x, ll y){cp res = cp(1, 0); for(; y; y >>= 1, x = x * x)if(y & 1)res = res * x; return res;}
inline cp operator / (cp x, cp y){cp t = cp(y.a, - y.b); x = x * t; return x * ((y * t) ^ (p - 2));}
inline bool operator == (cp x, cp y){return x.a == y.a and x.b == y.b;}
inline cp F(cp x, ll l, ll r){return x == cp(1, 0) ? cp(r - l + 1, 0) : ((x ^ (r + 1)) - (x ^ l)) / (x - cp(1, 0));}

cp s1[K][K], C[K][K], fac[K], ifa[K];
cp A, B, x, y;

void prework(){
    s1[0][0] = C[0][0] = C[1][0] = fac[0] = ifa[0] = cp(1, 0);
    for(int i = 1; i < K; ++i)for(int j = 1; j <= i; ++j)s1[i][j] = s1[i - 1][j - 1] + s1[i - 1][j] * cp(i - 1, 0);
    for(int i = 1; i < K; C[++i][0] = cp(1, 0))for(int j = 1; j <= i; ++j)C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
    for(int i = 1; i < K; ++i)fac[i] = fac[i - 1] * cp(i, 0);
    ifa[K - 1] = fac[K - 1] ^ (p - 2);
    for(int i = K - 2; i; --i)ifa[i] = ifa[i + 1] * cp(i + 1, 0);
}
void init(int typ){
    isq = typ & 1 ? 3 : 5;
    A = typ & 1 ? cp(3, 1) / cp(6, 0) : cp(1, 0) / cp(0, 1);
    B = typ & 1 ? cp(3, - 1) / cp(6, 0) : cp(- 1, 0) / cp(0, 1);
    x = typ & 1 ? cp(2, 1) : cp(1, 1) / cp(2, 0);
    y = typ & 1 ? cp(2, - 1) : cp(1, - 1) / cp(2, 0);
}


signed main(){
    prework(); int T = rd(), typ = rd(); init(typ);
    while(T--){
        ll l = rd(), r = rd(), len = r - l + 1; int k = rd(); cp res;
        if(typ & 1)l = (l + 1) / 2, r /= 2; else ++l, ++r;
        for(int i = 0; i <= k; ++i){
            cp tmp;
            for(int j = 0; j <= i; ++j){
                cp t = C[i][j] * (A ^ j) * (B ^ (i - j)) * F((x ^ j) * (y ^ (i - j)), l, r);
                tmp = tmp + t;
            }
            tmp = tmp * s1[k][i];
            res = (k - i & 1 ? res - tmp : res + tmp);
        }
        cout << (res / cp(len, 0) * ifa[k]).a << endl;
    }
    return 0;
}
```

---

## 作者：xiezheyuan (赞：5)

[也许有更好的阅读体验](https://www.xiezheyuan.xyz/hnoi2025camp/flower/p5320.html) | [GF 与特殊计数数列总结](https://www.xiezheyuan.xyz/hnoi2025camp/flower/gf.html)

## 简要题意

给定 $m$，记 $f(n)$ 表示用 $1\times 2$ 的骨牌覆盖 $m\times n$ 的网格的方案数。给定 $l,r,k$，你需要求：
$$
\frac{1}{r-l+1}\sum_{i=l}^{r}\binom{f(i)}{k}
$$
答案对 $p=998,244,353$ 取模。

$1\leq l\leq r\leq 6\times 10^{18},p\nmid r-l+1,m\in\{2,3\}，1\leq k\leq 501$。

## 思路

由于 $m\in\{2,3\}$，所以可以对于 $m$ 的不同取值分类讨论，求出此时 $f(n)$ 的表达式。

对于 $m=2$，我们发现骨牌覆盖一定由下面两种基本型组成：

![](https://cdn.luogu.com.cn/upload/image_hosting/qowf8s59.png)

所以很容易列出递推式：
$$
f(i)=\begin{cases}
f(i-1)+f(i-2)& i\geq 2\\
1& i\leq 1
\end{cases}
$$
那么就可以注意到：
$$
f(n)=\mathrm{fib}(n+1)=\frac{\sqrt{5}}{5}\left(-\left(\frac{1-\sqrt{5}}{2}\right)^{n+1}+\left(\frac{1+\sqrt{5}}{2}\right)^{n+1}\right)
$$
然后是 $m=3$，首先由三种平凡的基本型，它们都是 $3\times 2$ 的：

![](https://cdn.luogu.com.cn/upload/image_hosting/3i8fpb7q.png)

然后其实还有两种方法，类似这样，它们是 $3\times 2n$ 的（其中 $n\in[2,\infty)\cap\mathbb{N}$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/s0uwppvj.png)

即第一行 / 最后一行全是 $1\times 2$ 的骨牌覆盖，两侧是 $2\times 1$ 的骨牌覆盖，其余部分都是 $1\times 2$​ 的骨牌覆盖。

那么可以列出递推式：
$$
g(n)=3g(n-2)+2\sum_{k=2}^{\lfloor\frac{n}{2}\rfloor} g(n-2k)
$$
边界 $g(0)=1,g(1)=0$​。

注意到 $g(n)$ 只会被 $g(m)$（其中 $n\equiv m\pmod{2}$ 且 $m<n$）贡献，又因为 $g(1)=0$，所以我们发现 $g(n)=0$ 当且仅当 $2\nmid n$。

不妨令 $g'(n)=g(2n)$，则可以得到：
$$
g'(n)=3g'(n-1)+2\sum_{k=2}^{n}g'(n-k)=3g'(n-1)+2\sum_{k=0}^{n-2}g'(k)
$$
边界 $g'(0)=1$，现在需要找到它的通项公式，不妨构造它的生成函数：
$$
\begin{aligned}
\mathbf{G}'(z)&=3z\mathbf{G}'(z)+2\frac{z^2}{1-z}\mathbf{G}'(z)+1\\
(1-z)(1-3z)\mathbf{G}'(z)&=2z^2\mathbf{G}'(z)+1-z\\
((1-z)(1-3z)-2z^2)\mathbf{G}'(z)&=1-z\\
\mathbf{G}'(z)&=\frac{1-z}{(1-z)(1-3z)-2z^2}=\frac{1-z}{1-4z+z^2}
\end{aligned}
$$
这也是一个有理式，因此它是一个（二阶）线性递推，尝试推导它的通项公式：
$$
\mathbf{G}'(z)=\frac{1-z}{1-4z+z^2}=\frac{1-z}{(z-2+\sqrt{3})(z-2-\sqrt{3})}=\frac{A}{z-2+\sqrt{3}}+\frac{B}{z-2-\sqrt{3}}
$$
其中：
$$
\begin{aligned}
&A(z-2-\sqrt{3})+B(z-2+\sqrt{3})=(A+B)z+(-2-\sqrt{3})A+(-2+\sqrt{3})=1-z\\
&\implies \begin{cases}
A+B=-1\\
(-2-\sqrt{3})A+(-2+\sqrt{3})B=1
\end{cases} \implies \begin{cases}
A=-\frac{3-\sqrt{3}}{6}\\
B=-\frac{3+\sqrt{3}}{6}
\end{cases}
\end{aligned}
$$
由于：
$$
\begin{aligned}
&\frac{A}{z-2+\sqrt{3}}=A\sum_{i\geq 0}(-1)^iz^i(\sqrt{3}-2)^{-1-i}=\sum_{i\geq 0}A(-1)^i(-2-\sqrt{3})^{i+1}z^i=\sum_{i\geq 0} -A(2+\sqrt{3})^{i+1}z^i\\
&\frac{B}{z-2-\sqrt{3}}=B\sum_{i\geq 0}(-1)^iz^i(-\sqrt{3}-2)^{-1-i}=\sum_{i\geq 0}B(-1)^i(\sqrt{3}-2)^{i+1}z^i=\sum_{i\geq 0}-B(2-\sqrt{3})^{i+1}z^i
\end{aligned}
$$

故：
$$
g'(n)=[z^n]\mathbf{G}'(z)=\frac{3-\sqrt{3}}{6}(2+\sqrt{3})^{n+1}+\frac{3+\sqrt{3}}{6}(2-\sqrt{3})^{n+1}
$$
因此：
$$
g(n)=\begin{cases}
\frac{3-\sqrt{3}}{6}(2+\sqrt{3})^{\frac{n}{2}+1}+\frac{3+\sqrt{3}}{6}(2-\sqrt{3})^{\frac{n}{2}+1}& 2\mid n\\
0& 2\nmid n
\end{cases}
$$
根据通项公式的形式，可以发现最终我们求解的问题可以转换为：

> 给定 $n,k,\alpha,\beta,x,y$，你需要求：
> $$
> \sum_{i=0}^{n}\binom{\alpha x^i+\beta y^i}{k}
> $$

尝试用下降幂转普通幂公式推式子：
$$
\begin{aligned}
\sum_{i=0}^{n}\binom{\alpha x^i+\beta y^i}{k}&=\frac{1}{k!}\sum_{i=0}^{n}(\alpha x^i+\beta y^i)^{\underline{k}}=\frac{1}{k!}\sum_{i=0}^{n}\sum_{j\geq 0}(-1)^{k-j}{k\brack j}(ax^i+\beta y^i)^j\\
&=\frac{1}{k!}\sum_{j\geq 0}(-1)^{k-j}{k\brack j}\sum_{i=0}^{n}(\alpha x^i+\beta y^i)^j
\end{aligned}
$$
考察内侧的和式（这一部分的 $k$ 被用来当求和指标了，另外我们认为 $x^ky^{j-k}\neq 1$）：
$$
\begin{aligned}
\sum_{i=0}^{n}(\alpha x^i+\beta y^i)^j&=\sum_{i=0}^{n}\sum_{k\geq 0}\binom{j}{k}(\alpha x^i)^k(\beta y^i)^{j-k}=\sum_{k\geq 0}\binom{j}{k}\sum_{i=0}^{n}(\alpha x^i)^k (\beta y^i)^{j-k}\\
&=\sum_{k\geq 0}\binom{j}{k}\alpha^k\beta^{j-k}\sum_{i=0}^{n}x^{ik}y^{ij-ik}=\sum_{k\geq 0}\binom{j}{k}\alpha^k\beta^{j-k}\sum_{i=0}^{n}(x^ky^{j-k})^i\\
&=\sum_{k\geq 0}\binom{j}{k}\alpha^k\beta^{j-k}\cdot \frac{(x^ky^{j-k})^{n+1}-1}{x^ky^{j-k}-1}
\end{aligned}
$$
计算后面这个东西，时间复杂度 $O(j\log n)$，所以总时间复杂度 $O(k^2\log n)$。

你以为这就完了吗？实际上是没有的。因为 $3,5$ 在 $\mathbb{Z}/p\mathbb{Z}$ 种都是非二次剩余的！换句话说我们在 $\mathbb{Z}/p\mathbb{Z}$ 中找不到和式的 $\alpha,\beta,x,y$！

我们可以在 Mathematica 检验这一点：

```wl
{JacobiSymbol[5, 998244353], JacobiSymbol[3, 998244353]} (* 输出 {-1, -1} *)
```

不过这也是很容易解决的，下面以 $\sqrt{3}$ 为例。

我们定义 $\mathbf{j}=\sqrt{3}$，那么 $\mathbf{j}$ 与 $1$ 在有限域 $\mathbb{Z}/p\mathbb{Z}$ 上线性无关，所以可以构造一组次数为 $2$ 的域扩张 $K$，选取基底 $\{1,\mathbf{j}\}$（即 $\forall i\in K,\exists a,b\in\mathbb{Z}/p\mathbb{Z},i=a+b\mathbf{j}$。那么 $K$ 亦是域，因此可以进行所有原本 $\mathbb{Z}/p\mathbb{Z}$ 上的运算。这样就解决了不存在 $\sqrt{3}$ 的问题。

时间复杂度 $O(k^2\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
const int N = 505;
constexpr int mod = 998244353, inv2 = (mod + 1) >> 1;
int Add(int x, int y){ return (x + y) >= mod ? (x + y - mod) : (x + y); }
int Sub(int x, int y){ return (x - y) < 0 ? (x - y + mod) : (x - y); }
int Mul(int x, int y){ return 1ll * x * y % mod; }

int fastpow(int x, int y){
    int ret = 1;
    for(;y;y>>=1,x=Mul(x, x)){ if(y & 1) ret = Mul(ret, x); }
    return ret;
}

template<int S>
struct Quadratic{
    int a, b;
    using T = Quadratic<S>;
    Quadratic(int a = 0, int b = 0): a(a), b(b) {}
    T operator+(const T& rhs) const { return {Add(a, rhs.a), Add(b, rhs.b)}; }
    T operator-(const T& rhs) const { return {Sub(a, rhs.a), Sub(b, rhs.b)}; }
    T operator*(const T& rhs) const {
        return {Add(Mul(a, rhs.a), Mul(Mul(b, rhs.b), S)), Add(Mul(a, rhs.b), Mul(b, rhs.a))};
    }
    T operator~() const {
        int inv = fastpow(Sub(Mul(a, a), Mul(Mul(b, b), S)), mod - 2);
        return {Mul(a, inv), Mul(mod - b, inv)};
    }
    T operator/(const T& rhs) const { return *this * ~rhs; }
    template<class U>
    T operator^(U y) const {
        T a = *this, ret = 1;
        for(;y;y>>=1,a=a*a){
            if(y & 1) ret = ret * a;
        }
        return ret;
    }
    int extract() const { return assert(!b), a; }
    T conj() const { return {a, mod - b}; }
};

template<int S>
using Q = Quadratic<S>;
using Q5 = Q<5>;
using Q3  = Q<3>;
int binom[N][N], stirling[N][N], m;

void init(int n){
    for(int i=0;i<=n;i++){
        binom[i][0] = 1;
        stirling[i][0] = i == 0;
        for(int j=1;j<=i;j++){
            binom[i][j] = Add(binom[i - 1][j], binom[i - 1][j - 1]);
            stirling[i][j] = Add(Mul(i - 1, stirling[i - 1][j]), stirling[i - 1][j - 1]);
        }
    }
}

template<int S>
Q<S> solve(i64 n, int k, Q<S> a, Q<S> b, Q<S> x, Q<S> y){
    Q<S> ans;
    for(int j=0;j<=k;j++){
        Q<S> ret = 0;
        for(int i=0;i<=j;i++){
            Q<S> t = (x ^ i) * (y ^ (j - i)), tmp;
            if(t.a == 1 && t.b == 0) tmp = (n + 1) % mod;
            else tmp = ((t ^ (n + 1)) - 1) / (t - 1);
            ret = ret + tmp * binom[j][i] * (a ^ i) * (b ^ (j - i));
        }
        if((k - j) & 1) ans = ans - ret * stirling[k][j];
        else ans = ans + ret * stirling[k][j];
    }
    for(int i=1;i<=k;i++) ans = ans * fastpow(i, mod - 2);
    return ans;
}

int solve(i64 n, int k){
    if(m == 2){
        Q5 a = Q5(0, mod - 1) / 5, b = a.conj();
        Q5 x = Q5(inv2, mod - inv2), y = x.conj();
        a = a * x, b = b * y;
        return solve(n, k, a, b, x, y).extract();
    }
    else{
        Q3 a = Q3(inv2, mod - fastpow(6, mod - 2)), b = a.conj();
        Q3 x = Q3(2, 1), y = x.conj();
        a = a * x, b = b * y;
        return solve(n, k, a, b, x, y).extract();
    }
}

void solve(){
    i64 L, R; int k;
    cin >> L >> R >> k;
    int ans = fastpow((R - L + 1) % mod, mod - 2);
    if(m == 3) L = (L + 1) >> 1, R >>= 1;
    cout << Mul(ans, Sub(solve(R, k), solve(L - 1, k))) << '\n';
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int t; cin >> t >> m;
    init(504);
    while(t--) solve();
    return 0;
}

// Written by xiezheyuan

```

---

## 作者：yangjinhua (赞：3)

# P5320 勘破神机题解
## 一. 引入
[原题链接](https://www.luogu.com.cn/problem/P5320)

校内模拟赛打的 BJOI2019，D1 只拿了 $30+25+0$，D2 拿了 $100+100+47$，总之是思维题全不会。

这是一道**非常好**的数学题。
## 二. 正解
### （一）题意
定义 $h(i)$ 为将 $m\times i$ 的格子用 $1\times 2$ 的块填满的方案数，所求即为:
$$ans=\frac{\large \sum _{i=l}^{r} \footnotesize\begin{pmatrix} h(i)\\ k \\\end{pmatrix}}{r-l+1}$$

### （二）推式子
令 
$$S= \sum _{i=l}^{r} \footnotesize\begin{pmatrix} h(i)\\ k \\\end{pmatrix}$$

此时：
$$ans=\frac{S}{r-l+1}$$

现我们来求 $S$:

$$\begin{aligned}
S&=\sum _{i=l}^{r} \footnotesize\begin{pmatrix} h(i)\\ k \\\end{pmatrix}\\
&=\sum _{i=l}^{r}\frac{\large\prod_{j=0}^{i-1}\normalsize(h(i)-j)}{k!}\\
\end{aligned}
$$
显然：由于 $k$ 很小，我们可以**多项式展开**上式并预处理系数。

设与处理完后第 $h^j(i)$ 项的系数为 $x_j$。

则原式:
$$\begin{aligned}
S&=\frac{\large\sum_{i=l}^{r}\sum_{j=0}^{k}\normalsize x_jh^j(i)}{k!}\\
&=\frac{\large\sum_{j=0}^{k}\normalsize x_j\large\sum_{i=l}^{r}\normalsize h^j(i)}{k!}
\end{aligned}
$$

现令：
$$H=\sum_{i=l}^{r}h^k(i)$$

由于我们可以枚举 $k$，所以我们只需求 $H$。但现在我们不会了，所以分类讨论 $m=2$ 和 $m=3$。

#### $m=2$：

设 $f(i)$ 表示 $2\times i$ 时的方案数。

显然这很 dp。


$2\times2$ 的块有以下 $2$ 种放法：

![](https://cdn.luogu.com.cn/upload/image_hosting/hn92gngx.png)

------

![](https://cdn.luogu.com.cn/upload/image_hosting/lpo3qly5.png)

------
所以有：
$$f(i)=f(i-1)+f(i-2)$$
且：
$$
\begin{cases}
  f(0)=1 \\
  f(1)=1 \\
\end{cases}
$$
#### $m=3$：
设 $g(i)$ 表示 $3\times (2\times i)$ 是的方案数。
> 显然，奇数列时必然无解，因为填入偶数块，而共奇数块。

在求 $H$ 时，只需让 $\large l\gets \lceil \frac{l}{2}\rceil$，$\large r\gets \lfloor \frac{r}{2}\rfloor$ 再计算即可。


首先，$3\times2$ 的块有以下 $3$ 种放法：

![](https://cdn.luogu.com.cn/upload/image_hosting/0dph72zq.png)

------

![](https://cdn.luogu.com.cn/upload/image_hosting/4364zu3i.png)

------

![](https://cdn.luogu.com.cn/upload/image_hosting/r1cqksg3.png)

------

其次，一个 $3\times (2\times i)$ 的块还有以下 $2$ 种填法：

![](https://cdn.luogu.com.cn/upload/image_hosting/49ulyv3t.png)

------

![](https://cdn.luogu.com.cn/upload/image_hosting/kqk9gdtc.png)

------
所以:
$$g(i)=3g(i-1)+2\sum_{j=1}^{i-2}g(j)$$

考虑将其与 $g(i-1)$ 作差，得：
$$g(i)=4g(i-1)-g(i-2)$$

其中满足：

$$
\begin{cases}
  g(0)=1 \\
  g(1)=3 \\
\end{cases}
$$

-----
所以：当 $m=2$ 和 $m=3$ 时 $h(i)$ 均为**常系数二次线性递推式**，其通项可表示为 $ax^n+by^n$，更具体地见**本章最后**。

现在，我们知：
$$\begin{aligned}
H&=\sum_{i=l}^{r}h^j(i)\\
&=\sum_{i=l}^{r}(ax^i+by^i)^k\\
\end{aligned}
$$
二项式展开 $(ax^i+by^i)^k$。
$$\begin{aligned}
H&=\sum_{i=l}^{r}\sum_{j=0}^{k}\footnotesize\begin{pmatrix} k\\ j \\\end{pmatrix}\normalsize(ax^i)^j(by^i)^{k-j}\\
&=\sum_{i=l}^{r}\sum_{j=0}^{k}\footnotesize\begin{pmatrix} k\\ j \\\end{pmatrix}\normalsize a^jx^{ij}b^{k-j}y^{i(k-j)}\\
&=\sum_{j=0}^{k}\footnotesize\begin{pmatrix} k\\ j \\\end{pmatrix}\normalsize a^jb^{k-j}\sum_{i=l}^{r}(x^jy^{k-j})^i
\end{aligned}
$$

这时，对于后面的部分，我们可以利用**等比数列求和**解决。

对于 $\footnotesize\begin{pmatrix} k\\ j \\\end{pmatrix}$ 的部分，只需预处理阶乘。

对于 $a$，$b$，$x$，$y$ 部分需手写实数乘，但因为根式部分相同，所以较好写。
### （三）等比数列求和部分
令 
$$p=x^jy^{k-j}$$
则：
$$\begin{aligned}
\sum_{i=l}^{r}(x^jy^{k-j})^i&=\sum_{i=l}^{r} p^i\\
\end{aligned}
$$
令
$$\begin{aligned}
P&=\sum_{i=l}^{r}p^i\\
pP&=\sum_{i=l+1}^{r+1}p^i\\
(p-1)P&=p^{r+1}-p^l\\
P&=\frac{p^{r+1}-p^l}{p-1}
\end{aligned}
$$
用快速幂即可。

**注意特判 $p=1$ 的情况**（卡了我一天）

### （四）常系数二次线性递推
对于 $h(i)=k_1h(i-1)+k_2h(i-2)$
求它的特征根，列方程 $x^2=k_1x+k_2$。

解得：
$$
\begin{cases}
  x_1=\frac{ k_1+\sqrt{k_1^2+4k_2}}{2} \\
  x_2=\frac{k_1-\sqrt{k_1^2+4k_2}}{2} \\
\end{cases}
$$

令
$$
\begin{cases}
  x=x_1 \\
  y=x_2 \\
\end{cases}
$$

则：
$$
\begin{cases}
  a+b=h(0) \\
  ax+by=h(1) \\
\end{cases}
$$

解得：
$$
\begin{cases}
  a=\frac{h(1)-h(0)y}{x-y} \\
  b=\frac{h(1)-h(0)x}{y-x} \\
\end{cases}
$$

这是便有：
$$h(i)=ax^i+by^i$$

-----
经带入易知:
$$f(i)=\frac{1+\sqrt{5}}{2\sqrt{5}}\times(\frac{1+\sqrt{5}}{2})^i-\frac{1-\sqrt{5}}{2\sqrt{5}}\times(\frac{1-\sqrt{5}}{2})^i$$

$$g(i)=\frac{\sqrt{3}-1}{2\sqrt{3}}\times(2+\sqrt{3})^i-\frac{\sqrt{3}+1}{2\sqrt{3}}\times(2-\sqrt{3})^i$$

### 三. 代码
```cpp
#include<bits/stdc++.h>
#define pow power
#define int long long
using namespace std;
template<typename T>void read(T &x)
{
	x=0;int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x=x*f;
}
const int mod=998244353,K=550;
int jc[K+10],xi[K+10][K+10],T,BASE=1;
int pow(int a,int k)
{
	if(!k) return 1;
	int tmp=pow(a,k/2);
	tmp=tmp*tmp%mod;
	if(k&1) tmp=tmp*a%mod;
	return tmp;
}
int inv(int x)
{
	return pow(x,mod-2);
}
struct rational 
{
	int a,b;
};
int l,r,k;
rational operator +(rational x,rational y)
{
	return rational{(x.a+y.a)%mod,(x.b+y.b)%mod};
}
rational operator -(rational x,rational y)
{
	return rational{(x.a-y.a+mod)%mod,(x.b-y.b+mod)%mod};
}
rational operator *(rational x,rational y)
{
	return rational{(x.a*y.a%mod+x.b*y.b%mod*BASE%mod)%mod,(x.a*y.b%mod+x.b*y.a%mod)%mod};
}
rational operator /(rational x,rational y)
{
	rational tmp={y.a,(mod-y.b)%mod};
	y=y*tmp;
	x=x*tmp;
	x.a=x.a*inv(y.a)%mod;
	x.b=x.b*inv(y.a)%mod;
	return x;
}
rational powr(rational a,int k)
{
	if(!k) return {1,0};
	rational tmp=powr(a,k/2);
	tmp=tmp*tmp;
	if(k&1) tmp=tmp*a;
	return tmp;
}
namespace nm2
{
	rational x[K+10],y[K+10];
	void init()
	{
		rational tmp1={inv(2),mod-inv(2)},tmp2={inv(2),inv(2)};
		x[0]=y[0]={1,0};
		for(int i=1;i<=K;i++)
		{
			x[i]=x[i-1]*tmp1;
			y[i]=y[i-1]*tmp2;
		}  
	}
	int sum(int kk)
	{
		rational ans={0,0};
		for(int j=0;j<=kk;j++)
		{
			int cc=jc[kk]*inv(jc[kk-j]*jc[j]%mod)%mod;
			if(j&1) cc=mod-cc;
			rational tmp=x[j]*y[kk-j];
			rational cur1;
			if(tmp.a==1&&tmp.b==0) ans.a=(ans.a+cc*((r-l+1)%mod)%mod)%mod;
			else 
			{
				cur1=(powr(tmp,r+2)-powr(tmp,l+1))/(tmp-(rational){1,0});
				ans=ans+(rational){cc*cur1.a%mod,cc*cur1.b%mod};
			}
		}
		ans=ans/powr({0,1},kk);
		return ans.a;
	}
	void solve()
	{
		BASE=5;
		init();
		while(T--)
		{
			int ans=0;
			read(l);
			read(r);
			read(k);
			for(int i=1;i<=k;i++) ans=(ans+xi[k][i]*sum(i)%mod)%mod;
			cout<<ans*inv(jc[k]*((r-l+1)%mod)%mod)%mod<<"\n";
		}
	}
}
namespace nm3
{
	rational x[K+10],y[K+10],a[K+10],b[K+10];
	int l,r,k;
	void init()
	{
		rational tmpx={2,1},tmpy={2,mod-1},tmpa={1,1},tmpb={mod-1,1};
		x[0]=y[0]=a[0]=b[0]={1,0};
		for(int i=1;i<=K;i++)
		{
			x[i]=x[i-1]*tmpx;
			y[i]=y[i-1]*tmpy;
			a[i]=a[i-1]*tmpa;
			b[i]=b[i-1]*tmpb;
		}  
	}
	int sum(int kk)
	{
		rational ans={0,0};
		for(int j=0;j<=kk;j++)
		{
			int cc=jc[kk]*inv(jc[kk-j]*jc[j]%mod)%mod;
			rational tmpxi=a[j]*b[kk-j],tmp=x[j]*y[kk-j];
			rational cur1;
			if(tmp.a==1&&tmp.b==0) cur1={(r-l+1)%mod,0};
			else cur1=(powr(tmp,r+1)-powr(tmp,l))/(tmp-(rational){1,0});
			cur1=cur1*tmpxi;
			ans=ans+(rational){cc*cur1.a%mod,cc*cur1.b%mod};
		}
		ans=ans/powr({0,2},kk);
		return ans.a;
	}
	void solve()
	{
		BASE=3;
		init();
		while(T--)
		{
			int ll,rr,ans=0;
			read(ll);
			read(rr);
			read(k);
			l=(ll+1)/2;
			r=rr/2;
			for(int i=1;i<=k;i++) ans=(ans+xi[k][i]*sum(i)%mod)%mod;
			cout<<ans*inv(jc[k]*((rr-ll+1)%mod)%mod)%mod<<"\n";
		}
	}
}
signed main()
{
//	freopen("calc.in","r",stdin);
//	freopen("calc.out","w",stdout);
	jc[0]=1;
	for(int i=1;i<=K;i++) jc[i]=jc[i-1]*i%mod;
	read(T);
	int m;
	read(m);
	xi[1][1]=1;
	for(int i=2;i<=K;i++)
		for(int j=0;j<=K;j++)
		{
			xi[i][j+1]+=xi[i-1][j];
			xi[i][j]+=xi[i-1][j]*(mod-((i-1)%mod))%mod;
			xi[i][j]%=mod;
			xi[i][j+1]%=mod;
		}
	if(m==2) nm2::solve();
	else nm3::solve();
	return 0;
}
```

---

## 作者：望月Asta (赞：3)

## 前言

~~退役选手不好好学 whk 跑来颓废~~

题解里都是斯特林数推式子 + 扩域，对我这样脑容量不足的暴力选手不够友好。

这里讲一个十分暴力的 BM + 线性递推做法。

前置知识不会可以左转模板题：

[P4723 【模板】常系数齐次线性递推](https://www.luogu.com.cn/problem/P4723)

[P5487 【模板】Berlekamp–Massey 算法](https://www.luogu.com.cn/problem/P5487)

## 解法

初步推导得到的式子都是 $\sum_{i = 1}^{n} \binom{f_i}{k}$ 这样的形式，其中 $\{f\}$ 为一个低阶的常系数齐次线性递推数列（以下“常系数齐次线性递推”简称为“线性递推”）。

考虑证明这是一个线性递推数列，然后就可以大力套 BM 了。

首先对与线性递推有一个非常重要的性质：线性递推的封闭性。

对于线性递推数列 $\{a\},\{b\}$，有如下几条：

- $\{a_ip\}$ 是线性递推。
- $\{a_i + b_i\}$ 是线性递推。
- $\{a_{i + 1}\}$ 是线性递推。
- $\{a_i b_i\}$ 是线性递推。
- $\{\sum_{j = 0}^{i}a_j b_{i - j}\}$ 是线性递推。

考虑原式，前缀和相当于卷上 $\{1,1,1,\cdots\}$，可以摘掉。

剩下部分为：

$$\large\begin{aligned}
\binom{f_i}{k} &= \frac{\prod_{j = 0}^{k - 1}f_i - j}{k!}\\
\end{aligned}$$

$\dfrac{1}{k!}$ 是常数，$f_i - j$ 是线性递推。

综上，$\sum_{i = 1}^{n} \binom{f_i}{k}$ 为一个线性递推数列，我们可以 $\mathcal{O} (k ^2)$ 暴力求出前面一定的项数然后丢进 BM 里。

BM 打表可知，最长的递推式长度不超过 $2507$，暴力求其二倍即数列前面约 $5000$ 项即可，时间复杂度 $\mathcal{O(k^2 + k \log k \log n)}$，用 $k^2 \log$ 线性递推在洛谷和 loj 都会被卡。

## 代码

[完整代码](https://www.luogu.com.cn/paste/czm6527n)

博客里就放个核心部分吧，线性递推和 BM 都是板子。

```cpp
#define rep(a,b,c) for(int a = (b);a <= (c);++a)
#define repl(a,b,c) for(int a = (b);a < (c);++a)
#define add(x,y) ( (((x) += (y)) >= MOD) && ((x) -= MOD) )
#define red(x,y) ( (((x) -= (y)) < 0) && ((x) += MOD) )


// 暴力组合数
inline int binom(int n,int m) {
	int x = 1,y = 1;
	rep(i,1,m) {
		x = (i64)x * (n - i + 1) % MOD;
		y = (i64)y * i % MOD;
	}
	return (i64)x * qpow(y) % MOD;
}

int m;

void solve() {
	i64 l = readI(),r = readI();
	int k = readI();
	int frac = qpow((r - l + 1) % MOD);
	if(m == 3) {
		r >>= 1,l = ((l - 1) >> 1) + 1;
		if(l > r) {
			PutC('0'),enter;
			return ;
		}
	}
	const int lim = 5000;// 暴力计算前 5000 项
	g[0] = 1;
	rep(i,1,lim) {
		g[i] = g[i - 1],f[i] = f[i - 1];
		if(m == 3) {
			g[i] = g[i] * 4ll % MOD;
			if(i ^ 1)
				add(g[i],MOD - g[i - 2]);
			else
				add(g[i],MOD - 1);
		}
		else if(i ^ 1)
			add(g[i],g[i - 2]);
		add(f[i],binom(g[i],k));
	}
	int kk = BerlekampMassey(f,a,lim);// BM 求递推式
	int ans = LinearRecurrence(f + 1,a,r - 1,kk);
	if(l ^ 1)
		add(ans,MOD - LinearRecurrence(f + 1,a,l - 2,kk));
	ans = (i64)ans * frac % MOD;
	writeI(ans),enter;
}
```

---

## 作者：WorldMachine (赞：2)

神奇题。

---

$2$ 行的情况就是斐波那契数列 $f$。而题目要求的是：
$$
\sum_{i=l+1}^{r+1}\binom{f_i}{k}
$$
先做一个差分，考虑如何求解
$$
\sum_{i=1}^n\binom{f_i}{k}
$$
组合数不太好搞，由于 $\dbinom{n}{m}=\dfrac{n^{\underline m}}{m!}$，考虑下降幂转普通幂：
$$
x^{\underline k}=\sum_{i=0}^{k}(-1)^{k-i}{k\brack i}x^i
$$
直接代入：
$$
\dfrac{1}{k!}\sum_{i=1}^n\sum_{j=0}^k(-1)^{k-j}{k\brack j}f_i^j
$$
交换求和符号：
$$
\dfrac{1}{k!}\sum_{i=0}^k(-1)^{k-i}{k\brack i}\sum_{j=1}^nf_j^i
$$
问题转化为求斐波那契数列的 $i$ 次方和。

由斐波那契数列的通项公式：
$$
f_n=\dfrac{1}{\sqrt5}\left(\left(\dfrac{1+\sqrt5}{2}\right)^n-\left(\dfrac{1-\sqrt5}{2}\right)^n\right)
$$
代入得：
$$
\begin{aligned}
\sum_{i=1}^nf_i^k&=\dfrac{1}{\sqrt5^k}\sum_{i=1}^n\sum_{j=0}^k\binom{k}{j}(-1)^{k-j}\left(\left(\dfrac{1+\sqrt5}{2}\right)^j\left(\dfrac{1-\sqrt5}{2}\right)^{k-j}\right)^i\\
&=\dfrac{1}{\sqrt5^k}\sum_{i=0}^k\binom{k}{i}(-1)^{k-i}\sum_{j=1}^n\left(\left(\dfrac{1+\sqrt5}{2}\right)^i\left(\dfrac{1-\sqrt5}{2}\right)^{k-i}\right)^j
\end{aligned}
$$
枚举 $i$，后面那一坨是等比数列求和，扩域直接做即可，不清楚的话可以看 SP31428 这道题。

该部分时间复杂度为 $\mathcal O(k^2\log n)$。

---

$3$ 行的情况就需要自己推递推式了。

如果列数是奇数肯定无解。设 $g_n$ 表示 $3$ 行 $2n$ 列的方案数。除了 $3$ 行 $2$ 列的 $3$ 种情况，还有下面这种形状的东西以及它的上下翻转：

![](https://cdn.luogu.com.cn/upload/image_hosting/agw6j2hp.png)

这种东西可以任意长，枚举其长度，有：
$$
g_n=3g_{n-1}+2\sum_{i=0}^{n-2}g_i
$$
为了得到 $g$ 的简单递推式，考虑 $g_{n-1}$ 的式子：
$$
g_{n-1}=3g_{n-2}+2\sum_{i=0}^{n-3}g_i
$$
两者相减便可得到 $g$ 的递推式：
$$
g_n=4g_{n-1}-g_{n-2}
$$
（话说这个东西有没有直接从组合意义入手不用推式子的推导啊）

考虑如何求出 $g$ 的通项公式。设 $g$ 的生成函数为 $G(x)$，有：
$$
G(x)=4xG(x)-x^2G(x)+1-3x
$$
即：
$$
G(x)=\dfrac{1-3x}{1-4x+x^2}
$$
假设 $g$ 是两个等比数列的线性组合，有：
$$
\dfrac{A}{1-ax}+\dfrac{B}{1-bx}=\dfrac{1-3x}{1-4x+x^2}
$$
通分：
$$
\dfrac{A+B-(Ab+aB)x}{1-(a+b)x+abx^2}=\dfrac{1-3x}{1-4x+x^2}
$$
故：
$$
\left\{
\begin{aligned}
&A+B=1\\
&Ab+aB=3\\
&a+b=4\\
&ab=1
\end{aligned}
\right.
$$
解得：
$$
\left\{
\begin{aligned}
&A=\dfrac{3+\sqrt3}{6}\\
&B=\dfrac{3-\sqrt3}{6}\\
&a=2+\sqrt3\\
&b=2-\sqrt3
\end{aligned}
\right.
$$
故 $g$ 的通项公式为：
$$
g_n=\dfrac{3+\sqrt3}{6}\left(2+\sqrt3\right)^n+\dfrac{3-\sqrt3}{6}\left(2-\sqrt3\right)^n
$$
仍然按照上面的方式，考虑求 $g$ 的 $k$ 次方和：
$$
\sum_{i=1}^ng_i^k=\sum_{i=0}^k\binom ki\left(\dfrac{3+\sqrt3}{6}\right)^i\left(\dfrac{3-\sqrt3}{6}\right)^{k-i}\sum_{j=1}^n\left(\left(2+\sqrt3\right)^i\left(2-\sqrt3\right)^{k-i}\right)^j
$$
扩域，枚举 $i$ 算等比数列即可。

该部分时间复杂度为 $\mathcal O(k^2\log n)$。

---

为数不多的需要求出递推式的通项公式的题，结合了下降幂转普通幂的 Trick，好题。

（话说怎么都在喷拼接啊/jk）

代码太丑了就不放了。

---

## 作者：Fading (赞：2)

强行多合一，而且题意是什么破玩意啊。。。

### 题意：设$m=2$的方案数是$f_n,m=3$时是$g_n$。

### 求

$$\frac 1{r-l+1}\sum_{i=l}^rC_{f_i}^k$$

$$\frac 1{r-l+1}\sum_{i=l}^rC_{g_i}^k$$

## 当$m=2$

打表发现$f_1=1,f_2=2,f_3=3,f_4=5,...$

很显然是斐波那契数列吧，证明也很简单。就不提了，但是注意$f_i=F_{i+1}$，所以我们把$l++,r++$

$F$是真实的斐波那契数列$(F_0=0,F_1=1)$

我们不考虑前面的分式，也不考虑$l,r$，我们先求一个前缀和，其他同理。

然后就是暴力拆式子了。

$$\sum_{i=0}^{n}C_{F_i}^k$$

$$=\sum_{i=0}^{n}\frac {(F_i)!}{k!(F_i-k)!}$$

这个阶乘什么鬼啊，你给我求一个$10^{18}!$试试$???$

所以转化成可以求的定义式。

$$=\sum_{i=0}^{n}\frac {A_{F_i}^{k}}{A_{k}^{k}}$$

$$=\frac 1{k!}\sum_{i=0}^{n}A_{F_i}^{k}$$

$$=\frac 1{k!}\sum_{i=0}^{n}F_i^{\underline k}$$

如果你不知到斯特林数和下降幂的关系，可以看看我的[组合数学的一些小知识总结](https://www.luogu.org/blog/wohaocaia/zu-ge-shuo-xue-di-yi-suo-xiao-zhi-shi-zong-jie-wei-wan-post)才刚开始写，未完待续，大佬轻喷。

根据下降幂和第一类斯特林数的关系$($设$s$为第一类斯特林数$)$：

$$x^{\underline k}=\sum_{i=1}^ks_k^i(-1)^{k-i}x^i$$

$$\therefore\ =\frac 1{k!}\sum_{i=0}^{n}\sum_{j=1}^ks_k^j(-1)^{k-j}(F_i)^j$$

$$\therefore\ =\frac 1{k!}\sum_{j=1}^k\sum_{i=0}^{n}s_k^j(-1)^{k-j}(F_i)^j$$

$$\therefore\ =\frac 1{k!}\sum_{j=1}^ks_k^j(-1)^{k-j}\sum_{i=0}^{n}(F_i)^j$$

然后就是经典问题了(好像以前在哪里做过...)

求

$$\sum_{i=0}^n(F_i)^j$$

注意到$k\leq 50$，可以用矩阵快速幂。

等等看错了$k\leq 501?????$

那就暴力展开...

我们考虑求出通项公式~~如果这个都不会你可以去学高考了~~

$$F_n=\frac 1{\sqrt5}\left[\left(\frac{1+\sqrt5}{2}\right)^n-\left(\frac{1-\sqrt5}{2}\right)^n\right]$$

为了方便我们设$\alpha=\frac{1+\sqrt5}{2},\beta=\frac{1-\sqrt5}{2},A=\frac 1{\sqrt5},B=-\frac 1{\sqrt5}$

$$F_i=A\alpha^i+B\beta^i$$

$$\sum_{i=0}^n(F_i)^j$$

$$=\sum_{i=0}^n(A\alpha^i+B\beta^i)^j$$

$$=\sum_{i=0}^n\sum_{d=0}^jC_j^kA^{j-k}B^k\alpha^{i(j-k)}\beta^{ik}$$

$$=\sum_{d=0}^jC_j^dA^{j-d}B^d\sum_{i=0}^n\alpha^{ij-id}\beta^{id}$$

设$c_i=\alpha^{ij-id}\beta^{id}$

有

$$\frac {c_{i+1}}{c_i}=\frac {\alpha^{ij-id-d+j}\beta^{id+d}}{\alpha^{ij-id}\beta^{id}}=\frac {\beta^{d}}{\alpha^{d-j}}$$

$\therefore\ c_i$为等比数列。

$$c_0=1,c_1=\frac {\beta^{d}}{\alpha^{d-j}}$$

$$F_i=A\alpha^i+B\beta^i$$

$$=\sum_{d=0}^jC_j^kA^{j-d}B^d\sum_{i=0}^n\alpha^{ij-id}\beta^{id}$$

$$=\sum_{d=0}^jC_j^dA^{j-d}B^d\left(\frac {1-(\frac {\beta^{d}}{\alpha^{d-j}})^{n+1}}{1-\frac {\beta^{d}}{\alpha^{d-j}}}\right)$$

再带入回原式：

$$\therefore\ =\frac 1{k!}\sum_{j=1}^ks_k^j(-1)^{k-j}\sum_{i=1}^{n}(F_i)^j$$

$$\therefore\ =\frac 1{k!}\sum_{j=1}^ks_k^j(-1)^{k-j}\sum_{d=0}^jC_j^dA^{j-d}B^d\left(\frac {1-(\frac {\beta^{d}}{\alpha^{d-j}})^{n+1}}{1-\frac {\beta^{d}}{\alpha^{d-j}}}\right)$$

$$\therefore\ =\frac 1{k!}\sum_{j=1}^ks_k^j(-1)^{k-j}\sum_{d=0}^jC_j^dA^{j-d}B^d\left(\frac {1-(\beta^{d}\alpha^{j-d})^{n+1}}{1-\beta^{d}\alpha^{j-d}}\right)$$

这样就做完了。预处理第一类斯特林数可以做到$O(k^2log_2k)$

仿佛是一个卷积的形式？所以可以数据出到$10^5?$瞎猜的

还有一个问题，我们解二次剩余时发现$\sqrt5$在模$998244353$下无解！
~~第一次998244353不是良心模数~~

注意到答案一定是整数(废话)，所以$\sqrt5$最后一定会被消掉。

我们可以使用与 Cipolla 类似的方法，设$C=a+\sqrt5b$，重载一个类似于复数（向量）的东西。

这样最后的答案$b$一定$\ =0$，就可以直接算了。

当然“复数”乘法也要重定义。

$$(a_1+\sqrt5b_1)\times (a_2+\sqrt5b_2)=(a_1a_2+5b_1b_2)+\sqrt5(a_1b_2+a_2b_1)$$

逆元：

$$\frac 1{(a_1+\sqrt5b_1)}=\frac {(a_1-\sqrt5b_1)}{(a_1^2-5b_1^2)}$$

$$=\frac {a_1}{a_1^2-5b_1^2}-\sqrt5
\frac {b_1}{a_1^2-5b_1^2}$$

## 当$m=3$

好多人都没有讲清楚啊，虽然说是强行二合一，但这一块还是有思维含量的吧？

一样的方法，不一样的通项公式。

这里我们只讨论如何求通项公式以及$A,B,\alpha,\beta$

感谢@ViXbob 大佬的灵感~不过好像有一些细节没有讲清楚，我来补充一下。

我们设$g_i$为$3\times i$时的答案。

显然$g_{k}=0\ (k\equiv1\pmod 2)$

那我们就简化一下，设$G_i$为$3\times 2i$时的答案。

并让$l/=2,r/=2$

[![VTA18e.md.png](https://s2.ax1x.com/2019/06/16/VTA18e.md.png)](https://imgchr.com/i/VTA18e)

第一种情况：

$$3G_{i-1}$$

第二种情况：

枚举**只**跨过$j$条黑线

$$2\sum_{j=1}^{i-1}G_{i-j-1}$$

且

$$G_0=1$$

$$\therefore\  G_i=3G_{i-1}+2\sum_{j=1}^{i-1}G_{i-j-1}\ \ (1)$$

$$\because\ G_{i-1}=3G_{i-2}+2\sum_{j=1}^{i-2}G_{i-j-2}\ \ (2)$$

$$(1)-(2)\rightarrow G_i-G_{i-1}=3G_{i-1}-3G_{i-2}+2G_{i-2}$$

$$\therefore\ G_i=4G_{i-1}-G_{i-2}$$

我们解特征根方程

$$x^2-4x+1=0$$

$$\alpha=2-\sqrt3,\beta=2+\sqrt3$$

待定系数

$$G_0=1,G_2=3$$

$$\therefore A=\frac {3-\sqrt3}6,B=\frac {3+\sqrt3}6$$

那么就和$m=2$一模一样了，这道题就做完啦！

如果还是不懂可以问我。

## 总结+细节

不一定有二次剩余，此时就需要重载！

**等比数列求和一定要判断公比为$1$的情况！**

**不判会WA,样例都过不了！**

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
inline ll fast_pow(ll a,ll b,ll p){
	ll t=1;a%=p;
	while (b){
		if (b&1) t=t*a%p;
		b>>=1;a=a*a%p; 
	}
	return t;
}
ll ljc2;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int T,m;
ll sqr,L,R,K;//sqr 是 3或5 表示根号里面的数
struct Comp{//重载“复数”
	ll a,b;	
};
Comp A,B,ar,be;
inline Comp init(ll a,ll b){
	return (Comp){a%ljc,b%ljc};
}
Comp operator + (Comp a,Comp b){
	return init(a.a+b.a,a.b+b.b);
}
Comp operator - (Comp a,Comp b){
	return init(a.a-b.a+ljc,a.b-b.b+ljc);
}
Comp operator * (Comp a,Comp b){//乘法
	return init(a.a*b.a+sqr*a.b%ljc*b.b,a.b*b.a+a.a*b.b);
}
inline Comp inv(Comp a){//逆元
	ll FM=fast_pow(ljc+a.a*a.a%ljc-sqr*a.b%ljc*a.b%ljc,ljc-2,ljc); 
	return init(a.a*FM,ljc-a.b*FM%ljc);
}
inline Comp cfast_pow(Comp a,ll b){//“复数”快速幂。
	Comp t=init(1,0);a.a%=ljc;a.b%=ljc;
	while (b){
		if (b&1) t=t*a;
		b>>=1;a=a*a;
	}
	return t;
}
ll s[1001][1001],C[1001][1001];
inline ll calc(ll n,ll K){//计算前缀和
	ll fac=1;Comp One=init(1,0);
	for (ll i=1;i<=K;i++) fac=1LL*fac*i%ljc;
	fac=fast_pow(fac,ljc-2,ljc);
	ll ans=0;
	for (ll j=0,one=((K)%2LL?ljc-1:1);j<=K;j++,one=ljc-one){
		Comp now=init(0,0);
		for (ll d=0;d<=j;d++){
			Comp rev=cfast_pow(be,d)*cfast_pow(ar,j-d);
			Comp Rev=cfast_pow(rev,n+1);
			if (rev.a==1&&rev.b==0) Rev.a=(n+1)%ljc,Rev.b=0;//公比等于1的特殊情况
			else{
				rev=inv(One-rev);Rev=(One-Rev)*rev;
			}
			Rev=Rev*cfast_pow(B,d)*cfast_pow(A,j-d);
			Rev.a=Rev.a*C[j][d]%ljc;
			Rev.b=Rev.b*C[j][d]%ljc;
			now=now+Rev;
		}
		ans=(ans+s[K][j]*one%ljc*now.a%ljc)%ljc;
	}
	return ans*fac%ljc;
}
signed main(){
	T=read();m=read();
	s[0][0]=C[0][0]=1;
	for (ll i=1;i<=502;i++){
		C[i][0]=1;
		for (ll j=1;j<=502;j++){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%ljc;
			s[i][j]=(s[i-1][j]*(i-1)%ljc+s[i-1][j-1])%ljc;
		}
	}
	ljc2=fast_pow(2,ljc-2,ljc);
	if (m==2){//初始化
		sqr=5,ar=init(ljc2,ljc2),be=init(ljc2,ljc-ljc2);
		A=init(0,fast_pow(5,ljc-2,ljc)),B=init(0,ljc-fast_pow(5,ljc-2,ljc));
	}else{
		sqr=3,ar=init(2,ljc-1),be=init(2,1);
		A=init(ljc2,ljc-fast_pow(6,ljc-2,ljc)),B=init(ljc2,fast_pow(6,ljc-2,ljc));
	}
	while (T--){
		ll L=read(),R=read(),K=read();
		ll INV=fast_pow(R-L+1+ljc,ljc-2,ljc);
		if (m==2) R++; 
		else L=(L-1)/2,R/=2;
		printf("%lld\n",(calc(R,K)-calc(L,K)+ljc)%ljc*INV%ljc);
	}
	return 0;
}
```

---

## 作者：arrow_king (赞：1)

读完题：这不就是个多米诺骨牌。。。

我们先求出 $k=1$ 时的通项公式，这会方便后面求解。

对于 $m=2$ 的情况，设 $f_n$ 表示长度为 $n$ 的答案，可以发现最后的位置要么放竖着的牌，要么放横着的牌，而后面的情况是递归的，因此列出递归式 $f_n=f_{n-1}+f_{n-2}$ 以及初始情况 $f_1=1,f_2=2$。因此得到通项公式
$$
f_n=\mathrm{fib}_ {n+1}=\dfrac{5+\sqrt 5}{10}\cdot\left(\dfrac{1+\sqrt 5}{2}\right)^n+\dfrac{5-\sqrt 5}{10}\cdot\left(\dfrac{1-\sqrt 5}{2}\right)^n
$$
对于 $m=3$ 的情况，我们可以使用生成函数的思想，设 $U_n$ 表示长为 $n$ 的完美覆盖答案、$V_n$ 为长为 $n$、抠去右下角位置的完美覆盖方案。那么显然有边界条件
$$
U_0=1,U_1=0,V_0=0,V_1=1
$$
考虑建立递归关系，容易得到
$$
\begin{cases}
U_n=2V_{n-1}+U_{n-2}\\
V_n=U_{n-1}+V_{n-2}
\end{cases}
$$
联立解生成函数我们可以得到
$$
U(z)=\dfrac{1-z^2}{1-4z^2+z^4},V(z)=\dfrac{z}{1-4z^2+z^4}
$$
解出 $U_n$：
$$
U_{2n}=\dfrac{3+\sqrt 3}{6}(2+\sqrt 3)^n+\dfrac{3-\sqrt 3}{6}(2-\sqrt 3)^n
$$

----

我们观察到上面的式子都有形式 $a_n=A\alpha^n+B\beta^n$ 的形式，因此我们将这个一般形式带入求值公式中。

欲求的答案为
$$
\dfrac1{r-l+1}\sum_{i=l}^r\dbinom{a_i}k
$$
化简求和式可以得到
$$
\begin{aligned}
\sum_{i=l}^r\dbinom{a_i}k&=\dfrac1{k!}\sum_{i=l}^ra_i^{\underline k}\\
&=\dfrac1{k!}\sum_{i=l}^r\sum_{j=0}^k{k\brack j}(-1)^{k-j}a_i^j\\
&=\dfrac1{k!}\sum_{j=0}^k{k\brack j}(-1)^{k-j}\sum_{i=l}^r\sum_{p=0}^j\dbinom jpA^pB^{j-p}\alpha^{pi}\beta^{(j-p)^i}\\
&=\dfrac1{k!}\sum_{j=0}^k{k\brack j}(-1)^{k-j}\sum_{p=0}^j\dbinom jpA^pB^{j-p}\sum_{i=l}^r(\alpha^{p}\beta^{j-p})^i
\end{aligned}
$$
此时对 $i$ 求和的那一维是等比数列求和，可以直接计算。

观察到通项公式内带有大量 $\sqrt 5$、$\sqrt 3$ 一类在模 $998244353$ 意义下不存在的值，因此直接扩域即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
#define ll long long
#define il inline
#define mod 998244353
#define N 550
il ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') {f=-1;} c=getchar();}
	while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
ll i_square;
struct complex {
	ll re,im;
	complex() {re=im=0;}
	complex(ll _re,ll _im) {re=_re,im=_im;}
};
il complex operator +(complex a,complex b) {return complex((a.re+b.re)%mod,(a.im+b.im)%mod);}
il complex operator -(complex a) {return complex((mod-a.re)%mod,(mod-a.im)%mod);}
il complex operator -(complex a,complex b) {return a+(-b);}
il complex operator *(complex a,complex b) {return complex((a.re*b.re%mod+i_square*a.im*b.im%mod)%mod,(a.im*b.re%mod+a.re*b.im%mod)%mod);}
il complex operator *(complex a,ll b) {return complex(a.re*b%mod,a.im*b%mod);}
il complex operator *(ll b,complex a) {return complex(a.re*b%mod,a.im*b%mod);}
il complex Conj(complex a) {a.im=(mod-a.im)%mod;return a;}
il ll qpow(ll a,ll b) {ll ans=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ans=ans*a%mod;return ans;}
il complex qpow(complex a,ll b) {
	complex ans(1,0);
	for(;b;b>>=1,a=a*a)if(b&1)ans=ans*a;return ans;
}
ll C[N][N],S[N][N],fac[N],t,m;
complex A,B,alpha,beta;
il void pre_init(int m) {
	if(m==2) {
		i_square=5;
		A=complex(qpow(2,mod-2),qpow(10,mod-2)),B=Conj(A);
		alpha=complex(qpow(2,mod-2),qpow(2,mod-2)),beta=Conj(alpha);
	}
	else {
		i_square=3;
		A=complex(qpow(2,mod-2),qpow(6,mod-2)),B=Conj(A);
		alpha=complex(2,1),beta=Conj(alpha);
	}
}
il void init_CS(int n) {
	C[0][0]=1;for(int i=1;i<=n;i++) C[i][0]=1;
	S[0][0]=1;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=i;j++) {
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
			S[i][j]=((i-1)*S[i-1][j]+S[i-1][j-1])%mod;
		}
	}
	fac[0]=1;for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
}
il complex Inv(complex a) {
	return Conj(a)*qpow((a.re*a.re%mod-i_square*a.im*a.im%mod+mod)%mod,mod-2);
}
il complex Add(complex bas,ll n) {
	if(bas.re==1&&bas.im==0) {return complex(n%mod,0);}
	complex tmp=qpow(bas,n+1)-complex(1,0);
	return tmp*Inv(bas-complex(1,0));
}
il void mian() {
	ll l=read(),r=read(),k=read();
	complex ans(0,0);
	for(int j=0;j<=k;j++) {
		for(int p=0;p<=j;p++) {
			complex now=C[j][p]*qpow(A,p)*qpow(B,j-p),bas=qpow(alpha,p)*qpow(beta,j-p);
			complex sum;
			if(m==2) sum=Add(bas,r)-Add(bas,(l-1));
			else sum=Add(bas,r/2)-Add(bas,(l-1)/2);
			if((k-j)%2==0) ans=ans+S[k][j]*now*sum;
			else ans=ans-S[k][j]*now*sum;
		}
	}
	ans=ans*qpow(fac[k],mod-2);
	printf("%lld\n",ans.re*qpow((r-l+1)%mod,mod-2)%mod);
}
int main() {
	t=read(),m=read();
	pre_init(m);
	init_CS(510);
	while(t--) mian();
	return 0;
}

```

UPD on 2024.10.28：公式里 $(-1)^{k-j}$ 忘写了，正确的公式是
$$
n^{\underline k}=\sum_{i=0}^k{k\brack i}(-1)^{k-i}n^i
$$

---

## 作者：SDNetFriend (赞：1)

### 题意这里不再赘述

[P5320 [BJOI2019]勘破神机](https://www.luogu.com.cn/problem/P5320)

### 知识点

**数列特征方程，第一类斯特林数，二项式定理，扩展域**

### 做法分析

难度和前面几题完全不是一个级别的。

首先我们先考虑第一种情况，无论哪种情况我们都设 $F_i$ 表示共有 $i$ 列一个核心的方案数，那实际上就是让我们求：$\sum_{i=l}^r {{F_i}\choose k}$。

首先可以发现第一种情况的 $F_n$ 即是斐波那契数列**第 $n+1$ 项**，我们这里需要求通项公式。

#### 斐波那契数列通项公式

首先我们假设存在 $z$ 使得 $z^n=z^{n-1}+z^{n-2}$，可以发现这样 $z^n$ 是符合斐波那契数列的递推式的。那我们解 $z^2=z+1$ 得到 $z_0=\frac{1+\sqrt 5}{2},z_1=\frac{1-\sqrt 5}{2}$，此时 $z^n$ 满足递推公式但首项不符合要求。但我们可以证明存在 $A,B$ 使得 $F_n=Az_0^n+Bz_1^n$：

$$
F_{n-1}+F_{n-2}=Az_0^n+Bz_1^n+Az_0^{n-1}+Bz_1^{n-1}\\
=Az_0^{n-1}(z_0+1)+Bz_1^{n-1}(z_1+1)
$$

$$
\because z_0^2=z_0+1,z_1^2=z_1+1\\
\therefore F_{n-1}+F_{n-2}=Az_0^n+Bz_1^n=F_n
$$

于是得证，带入得到 $A=\frac{1}{\sqrt 5},B=-\frac{1}{\sqrt 5}$，为了方便我们把特征方程表示为 $F_n=Ax^n+By^n$ 的形式，其中 $A=\frac{1}{\sqrt 5},B=-\frac{1}{\sqrt 5},x=\frac{1+\sqrt 5}{2},y=\frac{1-\sqrt 5}{2}$。

#### 推式子求解

因为 $F_i=fab_{i+1}$ 所以 $l,r$ 实际代表 $l+1,r+1$。

$$
=\frac{1}{k!}\sum_{i=l}^rF_i^{\underline k}
$$

然后根据第一类斯特林数 $S(n,m)=S(n-1,m-1)+(n-1)\times S(n-1,m)$，有：

$$
x^{\underline k}=\sum_{i=0}^k(-1)^{k-i}S(k,i)x^i
$$

然后带入接着推：

$$
=\frac{1}{k!}\sum_{i=l}^r\sum_{j=0}^k(-1)^{k-j}S(k,j)F_i^j\\
=\frac{1}{k!}\sum_{j=0}^k (-1)^{k-j}S(k,j)\sum_{i=l}^rF_{i}^j
$$

然后为了用二项式定理展开最后的 $F_i^j$，我们设 $G(j,l,r)=\sum_{i=l}^r F_i^j$，则有:

$$
G(j,l,r)=\sum_{i=l}^j\sum_{k=0}^j {j\choose k}A^kB^{j-k}(x^ky^{j-k})^i\\
=\sum_{k=0}^j {j\choose k}A^kB^{j-k}\sum_{i=l}^r (x^ky^{j-k})^i

$$


这里我们设 $H(x,l,r)=\sum_{i=l}^r x^j=\frac{x^{r+1}-x^l}{x-1}$，关于这个除法求逆元可以先上下同乘共轭表达式（即利用平方差公式）去掉带根号的项（已经进行了扩展域处理，数都表示成 $a+b\sqrt 5$​）就可以求解，于是有：

$$
G(j,l,r)=\sum_{k=0}^j{j\choose k}A^kB^{j-k}H(x^ky^{j-k},l,r)

$$
然后带入原式有：

$$
=\frac{1}{k!}\sum_{j=0}^k(-1)^{k-j}S(k,j)G(j,l,r)

$$
于是得解。记得把 $l,r$ 分别 $+1$，然后还要乘上 $\frac{1}{r-l+1}$。

### 第二部分

同样推式子，可以发现能凑成几个整列的独立情况有：

```
--  --  ||  ----  ------ 
--  ||  ||  |--|  |----|
--  ||  --  |--|  |----|（及最后两种上下颠倒以及8,10,12,...列的情况）
```

然后可以发现完整的列块宽度都是偶数，那么我们设 $F_i$ 表示一共 $2i$ 列的方案数，那么递推式子是：

$$
F_i=F_{i-1}+2\sum_{j=1}^{i-1}F_{i-j},F_0=1,F_1=3
$$
然后考虑和 $F_{i-1}$ 的式子做差，可以得到：
$$
F_i=4F_{i-1}-F_{i-2}
$$
然后依旧是解特征方程，得到：
$$
A=\frac{3+\sqrt 3}{6},x=2+\sqrt 3,B=\frac{3-\sqrt 3}{6},y=2-\sqrt 3
$$
于是像原来那样求解就可以了。

### 注意

等比数列求和需要判公比为 $1$ 的情况！！否则直接变成 $\frac{0}{0}$​ 就炸了。

### 贴代码

因为定义函数比较多所以封装性应该不错？

```cpp
#include <bits/stdc++.h>
#define lint long long
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f=-f;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const lint md=998244353;
lint sq;
struct ex{//扩展域 
	lint a,b;
	ex(lint _a=0,lint _b=0)
		{a=(_a%md+md)%md;b=(_b%md+md)%md;}
};
inline ex operator+(ex x,ex y)
	{return ex(x.a+y.a,x.b+y.b);}
inline ex operator-(ex x,ex y)
	{return ex(x.a-y.a,x.b-y.b);}
inline ex operator*(ex x,ex y)
	{return ex(x.a*y.a%md+sq*x.b*y.b%md,x.a*y.b%md+x.b*y.a%md);}
inline ex qpow(ex x,lint y){
	ex res=ex(1,0);
	while(y){
		if(y&1)res=res*x;
		x=x*x;y>>=1;
	}return res;
}
inline ex operator/(ex x,ex y){
	ex z=ex(y.a,-y.b);x=x*z;
	return x*qpow(y*z,md-2);
}
const int K=605;
ex s[K][K],c[K][K],fac[K],ifac[K];
inline void calc(){//预处理C,S,fac,ifac 
	s[0][0]=c[0][0]=ex(1,0);
	fac[0]=ifac[0]=ex(1,0);
	for(int i=1;i<K;++i){
		for(int j=1;j<=i;++j)
			s[i][j]=s[i-1][j-1]+s[i-1][j]*ex(i-1,0);
		c[i][0]=c[i][i]=ex(1,0);
		for(int j=1;j<i;++j)
			c[i][j]=c[i-1][j-1]+c[i-1][j];
		fac[i]=fac[i-1]*ex(i,0);
		ifac[i]=qpow(fac[i],md-2);
	}
}
ex A,B,x,y;
inline void init(int m){//预设 
	if(m==2){sq=5;
		A=ex(1,0)/ex(0,1);
		B=ex(-1,0)/ex(0,1);
		x=ex(1,1)/ex(2,0);
		y=ex(1,-1)/ex(2,0);
	}else{sq=3;
		A=ex(3,1)/ex(6,0);
		B=ex(3,-1)/ex(6,0);
		x=ex(2,1);y=ex(2,-1);
	}
}
//函数定义详见题解 
inline ex S(int i,int j){return s[i][j];}
inline ex C(int i,int j){return c[i][j];}
inline ex H(ex x,lint l,lint r){
	if(x.a==1&&x.b==0)
		return ex(r-l+1,0);
	ex res=qpow(x,r+1);
	res=res-qpow(x,l);
	return res/(x-ex(1,0));
}
inline ex G(int j,lint l,lint r){
	ex res;
	for(int k=0;k<=j;++k){
		ex upd=C(j,k)*qpow(A,k)*qpow(B,j-k);
		upd=upd*H(qpow(x,k)*qpow(y,j-k),l,r);
		res=res+upd;
	}return res;
}
inline lint solve(int m,int k,lint l,lint r){
	init(m);ex res;
	lint _l=l,_r=r;
	if(m==2)++l,++r;
	else l=(l+1)/2,r/=2;
	for(int j=0;j<=k;++j){
		ex upd=ex((k-j&1)?-1:1,0);
		upd=upd*S(k,j)*G(j,l,r);
		res=res+upd;
	}
	res=res/ex(_r-_l+1,0);
	return (res*ifac[k]).a;
}
int T,m;
int main(){
	calc();
	T=read();m=read();
	while(T--){
		lint l=read(),r=read();
		int k=read();
		printf("%lld\n",solve(m,k,l,r));
	}
	return 0;
}
```





---

## 作者：nekko (赞：1)

首先有：

$${f_n \choose k}=\frac{f_n^{\underline k}}{k!}$$

由于：

$$x^{\underline{n}}= \sum_{i=0}^{n} \begin{bmatrix} n \\ i \end{bmatrix}(-1)^{n-i} x^i$$

可以得出：

$$f_{n}^{\underline k}=\sum_{i=0}^{k} \begin{bmatrix}k\\i \end{bmatrix} (-1)^{k-i} f_n^i$$

则：

$$\begin{aligned} &\sum_{i=l}^{r} {f_i \choose k} \\ =&\frac{1}{k!} \sum_{i=l}^{r} f_i^{\underline k} \\ =&\frac{1}{k!}\sum_{i=l}^{r} \sum_{j=0}^{k} \begin{bmatrix}k\\j \end{bmatrix} (-1)^{k-j} f_{i}^j \\ =&\frac{1}{k!}\sum_{j=0}^{k} \begin{bmatrix}k\\j \end{bmatrix} (-1)^{k-j} \sum_{i=l}^{r} f_i^j \end{aligned}$$

---

强行二合一，那么先解决前半部分

显然有：

$$\begin{cases} f_0=1 \\ f_1=1 \\ f_{n}=f_{n-1}+f_{n-2} \end{cases}$$

对于方程 $x^2=x+1$，有根 $x=\frac{1 \pm \sqrt{5}}{2}$

即：

$$f_n=a\left( \frac{1 + \sqrt{5}}{2} \right)^n+b\left( \frac{1-\sqrt{5}}{2} \right)^n$$

由 $f_0=f_1=1$，解得：

$$\begin{cases} a=\frac{1+\frac{1}{\sqrt{5}}}{2} \\ b=\frac{1-\frac{1}{\sqrt{5}}}{2} \end{cases}$$

即：

$$f_n=\frac{1+\frac{1}{\sqrt{5}}}{2} \left( \frac{1+\sqrt{5}}{2} \right)^n + \frac{1-\frac{1}{\sqrt{5}}}{2} \left( \frac{1-\sqrt{5}}{2} \right)^n$$

也就是：

$$f_n=\frac{5+\sqrt{5}}{10} \left(\frac{1+\sqrt{5}}{2}\right)^n + \frac{5-\sqrt{5}}{10} \left(\frac{1-\sqrt{5}}{2}\right)^n$$

考虑在 $\mathbb{Z}[\sqrt{5}]$ 上定义 $(a,b)$，相当于映射到 $\mathbb{R}$ 上的 $a\sqrt{5}+b$，定义其上的运算如下：

对于二元运算 $+$，有：

$$(a,b)+(c,d)=(a+c,b+d)$$

对于二元运算 $-$，有：

$$(a,b)-(c,d)=(a-c,b-d)$$

对于二元运算 $\times$，有：

$$(a,b) \times (c,d) = (ad+bc,5ac+bd)$$

对于一元运算 $(a,b)^{-1}$，有：

$$(a,b)^{-1}=(\frac{a}{5a^2-b^2}, -\frac{b}{5a^2-b^2})$$

即：

$$f_n=(\frac{1}{10}, \frac{1}{2}) \times (\frac{1}{2},\frac{1}{2})^n+(-\frac{1}{10}, \frac{1}{2}) \times (-\frac{1}{2},\frac{1}{2})^n$$

为了简便起见，记 $f_n=ax_0^n+bx_1^n$

那么现在只需要求：

$$\sum_{i=1}^{n} f_i^k$$

也就是：

$$\begin{aligned} &\sum_{i=1}^{n} \sum_{j=0}^{k} {k \choose j} (ax_0^i)^j (bx_1^i)^{k-j} \\ =&\sum_{j=0}^{k} {k \choose j} \sum_{i=1}^{n} a^j(x_0^j)^i b^{k-j}(x_1^{k-j})^i \\ =&\sum_{j=0}^{k} {k \choose j} a^jb^{k-j}\sum_{i=1}^{n} (x_0^jx_1^{k-j})^i \\ \end{aligned}$$

通过等比数列求和，有：

$$\sum_{i=1}^{n} (a,b)^i=\frac{(a,b)^{n+1}-(a,b)}{(a,b)-(0,1)}$$

前半部分结束了

---

对于后半部分，显然有：

$$\begin{cases} f_{2n}= f_{2n-2} + 2 \sum_i f_{2n-2i} \\ f_{2n+1}=0 \end{cases}$$

设 $h_n=f_{2n}$，则：

$$\begin{aligned} & \begin{cases} h_n=h_{n-1}+2\sum_{i}h_{n-i} \\ h_{n+1}=h_{n}+2\sum_{i}h_{n+1-i}=h_{n}+2h_{n}+2\sum_{i}h_{n-i} \\ \end{cases} \\ \Rightarrow & h_{n}-h_{n+1}=h_{n-1}-3h_{n} \\ \Rightarrow & h_{n+1}=4h_{n}-h_{n-1} \\ \Rightarrow & h_{n}=4h_{n-1}-h_{n-2} \end{aligned}$$

即：

$$\begin{cases} h_0=1 \\ h_1=3 \\ h_n=4h_{n-1}-h_{n-2} \end{cases}$$

对于方程 $x^2=4x-1$，有根 $x=2 \pm \sqrt{3}$

即：

$$h_n=ax_0^n+bx_1^n$$

解得：

$$\begin{cases} a=\frac{3+\sqrt{3}}{6} \\ b=\frac{3-\sqrt{3}}{6} \end{cases}$$

即：

$$h_n=\frac{3+\sqrt{3}}{6} (2+\sqrt{3})^n+\frac{3-\sqrt{3}}{6}(2-\sqrt{3})^n$$

不妨设 $h_n=ax_0^n+bx_1^n$

即：

$$f_n=[2|n] \left( ax_0^{\frac{n}{2}} + bx_1^{\frac{n}{2}} \right)$$

目标是要求：

$$\frac{1}{k!}\sum_{j=0}^{k} \begin{bmatrix}k\\j \end{bmatrix} (-1)^{k-j} \sum_{i=l}^{r} f_i^j$$

也就是求：

$$\sum_{i=1}^{n} f_{i}^{j}=\sum_{i=1}^{n}[2|n]f_i^j=\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor} h_i^j$$

和第一问的做法一样

---

希望以后不会遇到这种强行多合一的出题人……

---

## 作者：lupengheyyds (赞：0)

# P5320 勘破神机

> 推式子。

不难发现：

$$
ans2=\dfrac1{r-l+1}\sum_{n=l}^r{fib_n\choose k}\\
ans3=\dfrac1{r-l+1}\sum_{n=l}^r{g_n\choose k}\\
其中g_n=\left\{\begin{aligned}
&0&&2\!\!\!\not|n\\
&3g_{n-2}+2\sum_{i=1}^{\frac n2-2}g_i=4g_{n-2}-g_{n-4}&&2|n
\end{aligned}\right.
$$

发现对于 $ans2,ans3$ 的计算都是因为 $[l,r] $ 的范围太大了，于是考虑推式子，改变循环变量。

### 前置知识：

$$
m^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline i}
$$

根据斯特林反演，有：

$$
m^{\underline n}=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}m^i
$$

这是在普通幂与下降幂之间转换的好手。

### 考虑 $ans2$

$$
\def\s#1#2{\begin{bmatrix}#1\\#2\end{bmatrix}}
\begin{aligned}
ans2&=\dfrac1{r-l+1}\sum_{n=l}^r{fib_n\choose k}\\
&=\dfrac1{(r-l+1)k!}\sum_{n=l}^rfib_n^{\underline k}\\
&=\dfrac1{(r-l+1)k!}\sum_{n=l}^r\sum_{i=0}^k(-1)^{k-i}\s kifib_n^i\\
记res2&=(r-l+1)k!,A=\frac{1+\sqrt 5}2,B=\frac{1-\sqrt 5}2\\
\because fib_n&=\frac1{\sqrt 5}(A^{n+1}-B^{n+1})\\
\therefore res2&=\sum_{n=l}^r\sum_{i=0}^k(-1)^{k-i}\s ki5^{-\frac i2}(A^{n+1}-B^{n+1})^i\\
&=\sum_{i=0}^k(-1)^{k-i}\s ki5^{-\frac i2}\sum_{j=0}^i{i\choose j}(-1)^j\sum_{n=l}^r(A^{i-j}B^j)^{n+1}\\
令 t&=A^{i-j}B^j\\
res2&=\sum_{i=0}^k(-1)^{k-i}\s ki5^{-\frac i2}\sum_{j=0}^i{i\choose j}(-1)^j\frac{t^{r+2}-t^{l+1}}{t-1}\\
\end{aligned}
$$

注意最后特判 $t=1$。于是 $\mathcal O(k^2\log r)$ 可做，但这里出现了 $\sqrt5$，在模 $998244353$ 的意义下不存在。不过我们知道最终结果是一个整数。于是可以新定义复数，使用 $a+bi,i=\sqrt 5$ 的形式表示，其运算与复数运算类似。

### 考虑 $ans3$

如果要使用与上述类似的方法，首先肯定要找到 $g_n$ 的通项。这里我使用了生成函数的方法。这里令 $g_i$ 表示原先的 $g_{2i}$ 方便表示。

令 $G(x)=\sum_{i}g_ix^i$，有：

$$
\begin{aligned}
G(x)&=\sum_{i=2}^{\infin}(4g_{i-1}-g_{i-2})x^i+1+3x\\
&=4x\sum_ig_ix^i-x^2\sum_ig_ix^i+1-x\\
&=4xG(x)-x^2G(x)+1-x\\
\therefore G(x)&=\frac{1-x}{x^2-4x+1}\\
&=\frac{\frac{\sqrt3-1}{2\sqrt3}}{1-(2-\sqrt3)x}+\frac{\frac{\sqrt3+1}{2\sqrt3}}{1-(2+\sqrt3)x}\\
&=\sum_i(\frac{\sqrt3-1}{2\sqrt3}(2-\sqrt3)^i+\frac{\sqrt3+1}{2\sqrt3}(2+\sqrt3)^i)x^i
\end{aligned}

$$

所以 $g_n=\frac{\sqrt3-1}{2\sqrt3}(2-\sqrt3)^n+\frac{\sqrt3+1}{2\sqrt3}(2+\sqrt3)^n$。

令 $x=\frac{\sqrt3-1}{2\sqrt3},y=\frac{\sqrt3+1}{2\sqrt3},A=(2-\sqrt3),B=(2+\sqrt3)$。

$g_n=xA^n+yB^n$，于是可以使用类似的方法做出这道题。

总复杂度：$\mathcal O(k^2\log r)$。

## 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MOD=998244353,KK=505;
int s[KK][KK],c[KK][KK],fac[KK];
template<typename T>T QP(T a,int b);
inline int Sign(int x){
	if(x&1)return -1;
	return 1;
}
inline int Mod(int x){
	return (x%MOD+MOD)%MOD;
}
template<int I>
struct Complex{
	int a,b;
	Complex operator+(const Complex &tmp)const{
		return {(a+tmp.a)%MOD,(b+tmp.b)%MOD};
	}
	Complex operator-(const Complex &tmp)const{
		return {Mod(a-tmp.a),Mod(b-tmp.b)};
	}
	Complex operator-(const int &tmp)const{
		return {(a-tmp)%MOD,b};
	}
	Complex operator*(const Complex &tmp)const{
		int c=tmp.a,d=tmp.b;
		return {(a*c%MOD+I*b*d%MOD)%MOD,(a*d%MOD+b*c%MOD)%MOD};
	}
	Complex operator*(const int&tmp)const{
		return {a*tmp%MOD,b*tmp%MOD};
	}
	Complex operator%(const int&p){
		return {a%p,b%p};
	}
	Complex operator/(const Complex &tmp)const{
		int c=tmp.a,d=tmp.b;
		int inv=QP(Mod(c*c%MOD-I*d*d%MOD),MOD-2);
		assert(inv);
		return {Mod(a*c%MOD-I*b*d%MOD)*inv%MOD,Mod(b*c%MOD-a*d%MOD)*inv%MOD};
	} 
};
void Eps(long long&x){x=1;}
template<int I>void Eps(Complex<I> &x){x={1,0};}
template<typename T>
T QP(T a,int b){
	T c;Eps(c);a=a%MOD;
	for(;b;b>>=1){
		if(b&1)c=c*a%MOD;
		a=a*a%MOD;
	}
	return c;
}
namespace Work1{
	typedef Complex<5ll> Comp;
	int main(){
		int inv5=QP(5ll,MOD-2),inv2=QP(2ll,MOD-2);
		Comp A={inv2,inv2},B={inv2,-inv2};
		int l,r,k;cin>>l>>r>>k;
		int tmp=QP(fac[k],MOD-2)%MOD*QP(r-l+1,MOD-2)%MOD;
		Comp ans={0,0};
		for(int i=0;i<=k;i++){
			Comp tmp,rek={0,0};
			if(i%2==0)tmp={Sign(k+i)*s[k][i]*QP(inv5,i/2)%MOD,0};
			else tmp={0,Sign(k+i)*s[k][i]*QP(inv5,i/2+1)%MOD};
			for(int j=0;j<=i;j++){
				Comp res={Sign(j)*c[i][j]%MOD,0};
				Comp t=QP(A,i-j)*QP(B,j);t.a=Mod(t.a),t.b=Mod(t.b);
				Comp u;
				if(t.a!=1||t.b!=0)u=(QP(t,r+2)-QP(t,l+1))/(t-1);//注意t=1时等比数列求和公式不适用 
				else u=(Comp){(r-l+1)%MOD,0};//注意取模 
				rek=rek+res*u;
			}
			ans=ans+tmp*rek;
		}
		return Mod(ans.a*tmp%MOD);
	}
}
namespace Work2{
	typedef Complex<3ll> Comp;
	int main(){
		int inv3=QP(3ll,MOD-2),inv2=QP(2ll,MOD-2),inv6=QP(6ll,MOD-2);
		Comp x={inv2,-inv6},y={inv2,inv6},A={2,-1},B={2,1};
		int l,r,k;cin>>l>>r>>k;
		int tmp=QP(fac[k],MOD-2)%MOD*QP(r-l+1,MOD-2)%MOD;
		r=r/2,l=(l+1)/2;
		if(l>r)return 0;
		Comp ans={0,0};
		for(int i=0;i<=k;i++){
			Comp tmp={Sign(k+i)*s[k][i],0},rek={0,0};
			for(int j=0;j<=i;j++){
				Comp res=QP(x,i-j)*QP(y,j)*c[i][j];
				Comp t=QP(A,i-j)*QP(B,j);t.a=Mod(t.a),t.b=Mod(t.b);
				Comp u;
				if(t.a!=1||t.b!=0)u=(QP(t,r+1)-QP(t,l))/(t-1);
				else u=(Comp){(r-l+1)%MOD,0};
				rek=rek+res*u;
			}
			ans=ans+tmp*rek;
		}
		return Mod(ans.a*tmp%MOD);
	}
}
signed main(){
	int T,m;cin>>T>>m;
	fac[0]=1;for(int i=1;i<=501;i++)fac[i]=1ll*fac[i-1]*i%MOD;
	s[0][0]=1;
	for(int i=1;i<=501;i++)
		for(int j=1;j<=i;j++)
			s[i][j]=(s[i-1][j-1]+1ll*s[i-1][j]*(i-1)%MOD)%MOD;
	c[0][0]=1;
	for(int i=1;i<=501;i++){
		c[i][0]=1;
		for(int j=1;j<=i;j++)c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;
	}
	while(T--){
		if(m==2)cout<<Work1::main()<<"\n";
		else cout<<Work2::main()<<"\n";
	}
	return 0;
}
```

---


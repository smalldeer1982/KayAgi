# [ZJOI2019] 开关

## 题目描述

九条可怜是一个贪玩的女孩子。  

这天，她和她的好朋友法海哥哥去玩密室逃脱。在他们面前的是 $n$ 个开关，开始每个开关都是关闭的状态。要通过这关，必须要让开关达到指定的状态。目标状态由一个长度为 $n$ 的 $01$ 数组 $s$ 给出，$s_i = 0$ 表示第 $i$ 个开关在最后需要是关着的，$s_i = 1$ 表示第 $i$ 个开关在最后需要被打开。  

然而作为闯关者，可怜和法海并不知道 $s$。因此他们决定采用一个比较稳妥的方法：瞎按。他们根据开关的外形、位置，通过一些玄学的方法给每一个开关赋予了一个权值 $p_i$（$p_i > 0$）每一次，他们会以正比于 $p_i$ 的概率（第 $i$ 个开关被选中的概率是 $\frac{p_i}{\sum^n_{j=1}p_j}$ 选择并按下一个开关。开关被按下后，状态会被反转，即开变关，关变开。**注意，每一轮的选择都是完全独立的。**

在按开关的过程中，一旦当前开关的状态达到了 $s$ 那么可怜和法海面前的门就会打开，他们会马上停止按开关的过程并前往下一关。作为一名欧皇，可怜在按了 $\sum^n_{i=1} s_i$ 次后，就打开了大门。为了感受一下自己的运气是多么的好，可怜想要让你帮她计算一下，用这种随机按的方式，期望需要按多少次开关才能通过这一关。

## 说明/提示

**【样例解释 \#1】**

前两次按开关，有 $\frac12$ 的概率达到 $s$，有 $\frac12$ 的概率回到原状。因此期望的按开关数量为：

$$\sum^{+\infty}_{i=1}2i\times \left(\frac12\right)^i=4$$

---

**【数据范围与约定】**

| 测试点 | $n$ | 其他约定 | 测试点 | $n$ | 其他约定 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $=2$ | 无 | $6$ | $\le 100$ | $p_i\le 2,s_i=1$ |
| $2$ | $=2$ | 无 | $7$ | $\le 100$ | $p_i\le 2,s_i=1$ |
| $3$ | $\le 8$ | 无 | $8$ | $\le 100$ | $\sum p_i\le 2\times 10^3$ |
| $4$ | $\le 8$ | 无 | $9$ | $\le 100$ | $\sum p_i\le 2\times 10^3$ |
| $5$ | $\le 100$ | $p_i=1$ | $10$ | $\le 100$ | 无 |

对于 $100\%$ 的数据，保证 $n\ge1$，$\sum^n_{i=1}p_i\le5\times10^4$，$p_i\ge1$。

## 样例 #1

### 输入

```
2
1 1
1 1```

### 输出

```
4```

## 样例 #2

### 输入

```
8
1 1 0 0 1 1 0 0
1 2 3 4 5 6 7 8```

### 输出

```
858924815```

# 题解

## 作者：BJpers2 (赞：57)

本题有两种主流做法，一种是生成函数，一种是异或卷积。

但惊人的是这两个做法最终能够得到完全相同的结果。

### 一、 生成函数

把$p_i$转为概率，则第$i$步达成目标的概率的EGF为
$$
f_e(x)=\prod \frac {e^{p_ix}+(-1)^{s_i}e^{-p_ix}} 2
$$
代入$s_i=0$可得第$i$步恰好回到原点概率的EGF为
$$
g_e(x)=\prod \frac {e^{p_ix}+e^{-p_ix}} 2
$$
稍微解释一下，求积中那个$(-1)^{s_i}$无非限定了$i$这个开关需要被拨动奇数次还是偶数次，如果$s_i=0$则为双曲余弦函数，表示必须拨动偶数次；反之为双曲正弦函数，表示必须拨动奇数次。

假如把上述两个生成函数分别转为OGF（即把$x^i$的系数乘一个$i!$）$f$和$g$。再设第$i$步恰好第一次达成目标的概率生成函数为$h$。

那么有$hg=f$（考虑通过枚举第一次达成目标的时刻求$f$）。于是问题变为求$(f/g)'|_{x=1}$。

设$\phi_{1-k}=2^n[e^{kx}]f_e(x)=[x^k]\prod (x^{p_i}+(-1)^{s_i}x^{-p_i})=[x^{1-k}]\prod (1+(-1)^{s_i}x^{2p_i})$（注意这里$k$是$[-1,1]$的实数，所以用$[]$这个记号有些不严谨）。最后一步推导用到了$\sum p_i=1$的性质。

同理定义$\gamma_i$。

根据$e^{ix}$转OGF之后恰为$\frac1{1-ix}$（它们都对应数列$1,i,i^2,\dots$）。我们有
$$
h(x)=\frac {\sum \frac{\phi_{1-i}}{2^n}\frac 1 {1-ix}}{\sum \frac{\gamma_{1-i}}{2^n}\frac 1 {1-ix}}=\frac {\phi_0+\sum_{i\ne1} \phi_{1-i}\frac {1-x} {1-ix}}{\gamma_0+\sum_{i\ne1} \gamma_{1-i}\frac {1-x} {1-ix}}
$$
以上推导和大部分题解是一致的，但是很多题解里都出现了很不清真的式子。实际上这里有一个很优美的推导

设分子为$u(x)$，分母为$v(x)$。注意到$u(1)=\phi_0=1,v(1)=\gamma_0=1$，且$(\frac {1-x}{1-ix})'|_{x=1}=\frac{1}{i-1}(i\ne 1)$。

那么
$$
h'(1)=\frac{u'(1)v(1)-v'(1)u(1)}{v^2(1)}=u'(1)-v'(1)=\sum_{i\ne 1}\frac{\phi_{1-i}-\gamma_{1-i}}{i-1}=\sum_{i>0}\frac {\gamma_i-\phi_i} i
$$


其实做到这一步已经很好，直接背包求$\phi$和$\gamma$即可，但是为了凸显它和下面一种方法的联系，我需要进一步用$\phi,\gamma$的定义展开这个式子。
$$
\begin{aligned}
h'(1)& = \sum_{i>0} \frac{\gamma_i-\phi_i}{i}\\
& = \sum_T \frac{1}{\sum_{i\in T}2p_i}(1-(-1)^{\sum_{i\in T}s_i})\\
& = \sum_{T} \frac{[|S\cap T|\equiv 1 \bmod 2]}{\sum_{i\in T} p_i}
\end{aligned}
$$
这个式子有无比清晰的组合意义：

> 对所有与目标集合$S$的交大小为奇数的集合$T$，求第一次拨动$T$中的某个开关需要的期望步数之和。

---

### 二、异或卷积

设$f_i$表示第一次把开关拨成集合$i$的状态所需的期望步数，目标是求$f_S$。

可列出方程：
$$
f_S=
\begin{cases}
0 & S=\varnothing \\
1+\sum_{S\oplus\{j\}} f_Sp_j & S\ne \varnothing
\end{cases}
$$
注意到方程类似于异或卷积，那么另设
$$
g_S=
\begin{cases}
-1 & S=\varnothing \\
p_{i} & S = \{i\} \\
0 & |S|>1
\end{cases}
$$

$$
h_S=
\begin{cases}
2^n-1 & S=\varnothing \\
-1 & S \ne \varnothing
\end{cases}
$$

容易知道$f*g=h$（$h_{\varnothing}$可以通过把$f$的另外$2^n-1$个方程相加，结合$\sum g_S=0$导出）。

通过简单计算，我们可以求出$g,h$经过沃尔什变换（也就是$n$维DFT）的结果$\tilde g,\tilde h$
$$
\tilde g_S=\sum_{i}(-1)^{[i\in S]}p_i-1
$$
$$
\tilde h_S=\begin{cases}
0 & S=\varnothing \\
2^n & S\ne \varnothing
\end{cases}
$$
特别地，$g_0=0$，除此之外任意$g_i<0$。

根据$\tilde f \circ \tilde g=\tilde h$，我们可以求出
$$
\tilde f_S=\begin{cases}
\sum_{T} \frac{2^n}{1-\sum_{i}(-1)^{[i\in T]}p_i}& S=\varnothing \\
-\frac{2^n}{1-\sum_{i}(-1)^{[i\in T]}p_i} & S\ne \varnothing
\end{cases}
$$

$\tilde f_{\varnothing}$的表达式可利用$f_{\varnothing}=\frac 1{2^n}\sum_{T} \tilde f_T=0$导出。

最后手动做一次沃尔什逆变换（也就是$n$维IDFT）得出$f_S$的表达式。（以下默认$T$非空）
$$
\begin{aligned}
f_S & =\frac 1 {2^n}(\tilde f_{\varnothing}+\sum_{T\ne \varnothing} (-1)^{|S\cap T|}\tilde f_T) \\
& = \sum_{T} \frac1{1-\sum_{i}(-1)^{[i\in T]}p_i}+\sum_T(-1)^{|S\cap T|}-\frac1{1-\sum_{i}(-1)^{[i\in T]}p_i} \\
& = \sum_{T} \frac{1-(-1)^{S\cap T}}{\sum_{i}p_i-\sum_{i}(-1)^{[i\in T]}p_i} \\
& = \sum_{T} \frac{2[|S\cap T|\equiv 1 \bmod 2]}{2\sum_{i\in T}p_i}\\
& = \sum_{T} \frac{[|S\cap T|\equiv 1 \bmod 2]}{\sum_{i\in T} p_i}
\end{aligned}
$$
这很明显跟方法一的结论一致。

---

### 三、遗留的问题

在给出上述两种方法之后，这道题当中仍然存在一个很大的谜团。那就是，如何从实际角度解答：为什么「第一次抵达状态$S$的期望时间」恰好等于「所有与$S$交大小为奇数的集合的首次被操作期望时间之和」。
$$
f(S)=\sum_T [|S\cap T|\equiv 1 \bmod 2]g(T)
$$
这个等式的两端都有着无比清晰的实际意义，但是奈何本人才疏学浅，不知如何构建它们之间的实际联系。如果有高手看出了其中的奥妙，还望不吝赐教。

---

### 四、一些拓展思考

为了解决上一节中的问题，本人尝试对每个开关有$k$种状态的状态寻找普遍的规律，得到了如下表达式
$$
f(S)=\sum_{T}\frac {1-\omega^{-\sum S_iT_i}}{\sum(1-\omega^{Ti})p_i}
$$
其中$S,T$是重数为$[0,k)$的多重集，$S_i$表示$i$这一维的重数。$w=e^{\frac{2\pi i}{k}}$，也即$k$次单位根。可以代入$w=-1$验证其正确性。

这个式子不再有清晰的组合意义，而且从各种角度来看都很奇怪。因为分子分母都是复数，很难想象以$\frac {3+\sqrt 3i} 2$的概率拨动第$i$个开关会有什么现实的意义。

---

### 五、 本题做法

根据方法一给出的如下表达式：
$$
\sum_{i>0}\frac {\gamma_i-\phi_i} i
$$
我们只需求得$\gamma$和$\phi$，设$m=\sum p$，不难发现本质不同的$i$只有$O(m)$个。那么做$n$个物品体积分别为$2p_1,2p_2,\dots,2p_n$的01背包即可。时间复杂度$O(nm)$。

当然这里有一个优化。我们本质上是求$\prod 1+x^{p_i}$的各项系数，所以可以先对每个二项式求$\ln$，求和之后在$\exp$回去。

这看起来是$O(m^2)$，但注意到$\ln (1+x^k)=\int\frac{1}{1+x^k}$，只在$x^k,x^{2k},...$等$\frac m k$个位置有值。那么把所有$p_i$相同的一起处理则可以获得调和级数的复杂度，也就是经典的$O(m\log m)$。（最劣情况应该是前$O(\sqrt m)$个数每个来一个，这时候算出来是$O(m\ln \sqrt m)$）。

然后再做$O(m\log m)$的多项式$\exp$就可以了。

放一下$O(nm)$的代码：

```cpp
#include<iostream>
#include<cstdio>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int M=50050,P=998244353;
int n,m,x,A,j,iv[M],b[M],f[M],g[M];
int main(){
	scanf("%d",&n);
	FOR(i,1,n) scanf("%d",&b[i]);
	f[0]=g[0]=iv[1]=1;
	FOR(i,1,n)for(scanf("%d",&x),j=m,m+=x;~j;j--)
		(f[j+x]+=b[i]?P-f[j]:f[j])%=P,(g[j+x]+=g[j])%=P;
	FOR(i,2,m) iv[i]=1ll*iv[P%i]*(P-P/i)%P;
	FOR(i,1,m) (A+=1ll*(g[i]-f[i]+P)*iv[i]%P*iv[2]%P*m%P)%=P;
	cout<<A<<'\n';
}
```



---

## 作者：lyx_cjz (赞：36)

首先容易想到用高斯消元法解决这个问题，这样的复杂度是 $O(8^n)$。

可以发现，这是对稀疏矩阵高斯消元，可以做到 $O(4^n)$。

当然，这都是过不了的。

我们来考虑优化这个消元，设 $f_{T}$ 表示对 $s_i=[i\in T]$ 时的答案。并假定 $\sum_{i=1}^n {p_i}=1$。

对 $T\neq \varnothing$，我们有：

$$f_T=1+ \sum_{i=1}^n p_i f_{T\oplus \{i\}}$$

我们观察到，这是一个异或卷积！

定义 $G=\sum_{i=1}^n p_ix^{\{i\}}$ 为集合幂级数，设 $F=\sum_T f_T x^T$ 也为集合幂级数。

于是 $F=\sum_T x^T + F \times G + c\cdot x^{\varnothing}$。

其中，$c$ 是由于 $T=\varnothing$ 时不能用上式处理所做的待定系数。

现在，我们需要求 $[x^S]F$，根据 FWT 的知识，我们对该式先做 FWT。

记 $\widetilde{F}$ 为 $F$ 的 FWT 结果。

对集合 $U$，该式在 $U$ 处的 FWT 为：

$$[x^U]\widetilde{F} \times \left (1- [x^U]\widetilde{G}\right ) = \sum_T (-1)^{|T \cap U|}+ c$$

当 $U=\varnothing$ 时，$[x^U]\widetilde{G}=1$，左式为 $0$。解得 $c=-2^n$。

对其他 $U$，$[x^U]\widetilde{G}< 1$，所以可以解出 $[x^U]\widetilde{F}=\dfrac{c}{1-[x^U]\widetilde{G}}$。

做 IFWT，得到：

$$f_S=\dfrac{1}{2^n} \sum_T (-1)^{|S\cap T|}[x^T]\widetilde{F}=\dfrac{[x^\varnothing]\widetilde{F}}{2^n}-\sum_{T\neq \varnothing} (-1)^{|S\cap T|} \dfrac{1}{1-[x^T]\widetilde{G}}$$

对于 $[x^{\varnothing}]\widetilde{F}$，利用 $f_{\varnothing}=0$ 可以得到:

$$\dfrac{[x^\varnothing]\widetilde{F}}{2^n}=\sum_{T\neq \varnothing} \dfrac{1}{1-[x^T]\widetilde{G}}$$

所以最终的答案就是：

$$\sum_{T\neq \varnothing} \left(1-(-1)^{|S\cap T|}\right) \dfrac{1}{1-[x^T]\widetilde{G}}=\sum_{T\neq \varnothing} [|S\cap T|\equiv1 \hspace{-0.444em} \pmod{2}]\dfrac{1}{\sum_{i\in T}p_i}$$

于是我们就得到了一个 $O(2^n)$ 的优秀做法！

然而这样还是有点慢啊！

注意到原题中 $p_i$ 的值域是比较小的，我们可以用 $dp[i][j][k]$ 表示前 $i$ 个数，和 $S$ 交集奇偶性为 $j$，当前总概率为 $k$ 的方案数。

最后对每种 $k$ 统计答案即可。

时间复杂度为 $O(n \sum p_i)$。在 $n$ 更大时可以进一步用 FFT 进行优化，但这里不需要。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;


const int mod=998244353;
typedef long long ll;

inline void upd(int&a,const int&b){a+=b-mod;a+=a>>31&mod;}
const int M=50010;
const int N=200;
int ans,dp[2][M],n,inv[M];
pair<int,int>a[N];
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].second;
	for(int i=1;i<=n;i++)cin>>a[i].first;
	sort(a+1,a+n+1);
	int sz=0;
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		int op=a[i].second,p=a[i].first;
		for(int j=sz;j>=0;--j){
			upd(dp[op][j+p],dp[0][j]);
			upd(dp[!op][j+p],dp[1][j]);
		}
		sz+=p;
	}
	inv[1]=1;
	for(int i=2;i<=sz;++i)
		inv[i]=mod-mod/i*(ll)inv[mod%i]%mod;
	for(int i=1;i<=sz;++i)
		ans=(ans+(ll)inv[i]*dp[1][i])%mod;
	cout<<(ll)ans*sz%mod<<endl;
	return 0;
}
```


---

## 作者：小粉兔 (赞：24)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/ZJOI2019D2T1.html](https://www.cnblogs.com/PinkRabbit/p/ZJOI2019D2T1.html)。

### 题意简述

略。

### 题解

从高斯消元出发好像需要一些集合幂级数的知识，就不从这个角度思考了。

----

令 $\displaystyle \dot p = \sum_{i = 1}^{n} p_i$。

我们考虑一个操作序列 $\{a_1, a_2, \ldots , a_k\}$，其中 $1 \le a_j \le n$，就表示第 $i$ 次按下了开关 $a_j$。

那么按 $k$ 次后恰好得到这个序列的概率就是 $\displaystyle \prod_{j = 1}^{k} (p_{a_j} / \dot p)$。

那么我们考虑如果按下这个序列后恰好得到了目标状态 $s$：  
当且仅当对于每个 $i$（$1 \le i \le n$）均满足按下开关 $i$ 的次数的奇偶性恰好等于 $s_i$。  
形式化地说，就是对于每个 $i$ 有 $\displaystyle \left( \sum_{j = 1}^{k} [a_j = i] \right) \bmod 2 = s_i$。

----

那么我们对每个 $i$ 分开考虑，对于 $s_i = 0$ 的需要按偶数次，对于 $s_i = 1$ 的需要按奇数次。

- 对于某个 $s_i = 0$ 的 $i$，我们给出这样的数列：$f_i = \{1, 0, {(p_i / \dot p)}^2, 0, {(p_i / \dot p)}^4, 0, {(p_i / \dot p)}^6, 0, \ldots \}$。
- 对于某个 $s_i = 1$ 的 $i$，我们给出这样的数列：$f_i = \{0, p_i / \dot p, 0, {(p_i / \dot p)}^3, 0, {(p_i / \dot p)}^5, 0, {(p_i / \dot p)}^7, \ldots \}$。

可以发现，把所有的 $i$ 的数列全部二项卷积起来，就得到了一个新的数列 $f$，这个数列满足：  
对于 $f$ 的第 $k$ 项 $f_k$，就表示了当按 $k$ 下开关时，恰好得到状态 $s$ 的概率。

因为是 **二项卷积**，所以我们把这个过程写成 **指数型概率生成函数** 的形式：

定义 $\hat F_i (x) = \mathbf{EGF} \left( { \left\{ [j \bmod 2 = s_i] {(p_i / \dot p)}^j \right\} }_{j = 0}^{\infty} \right)$，  
也就是每个 $i$ 对应的上述数列 $f_i$ 的指数型生成函数，  
写做封闭形式，就是 $\displaystyle \hat F_i (x) = \frac{e^{(p_i / \dot p) x} + {(-1)}^{s_i} e^{-(p_i / \dot p) x}}{2}$。

所以最终得到的 $f$ 的 EGF 就是 $\displaystyle \hat F (x) = \prod_{i = 1}^{n} \frac{e^{(p_i / \dot p) x} + {(-1)}^{s_i} e^{-(p_i / \dot p) x}}{2}$。

看起来非常的变态，但是还没完！出什么问题了？

----

首先我们要明确：得到 $f$ 能干啥？

发现 $f$ 的性质是：$f_k$ 表示按恰好 $k$ 次开关得到状态 $s$ 的概率，那么根据期望的定义，答案就是 $\displaystyle \sum_{i = 0}^{\infty} i f_i$。

这是啥啊，就是 $f$ 对应的 **普通生成函数** $\displaystyle F(x) = \sum_{i = 0}^{\infty} f_i x^i$，它在 $1$ 处的导数，也就是 $F'(1)$。  
（回顾形式幂级数求导，以及求值的定义）

但是 **错了**，再观察一下，题目要求的是 **第一次** 到达状态 $s$ 的期望步数，而不是现在这个样子。  
（因为可能不是第一次，而是此前已经经过很多次了。实际上如果直接求这个，甚至是不收敛的）

那么怎么办呢？我们发现需要排除第一次到达 $s$ 后，又经过若干步返回 $s$ 的情况，也就是返回原状态了。

由此，我们考虑求出数列 $g$，其中 $g_k$ 表示在 $k$ 步后恰好返回原状态的概率。

那么可以发现，如果令最终答案的数列为 $h$，有 $h \ast g = f$（$h$ 卷 $g$ 等于 $f$，是普通卷积不是二项卷积）。

而 $g$ 应该如何求得呢？其实就是当全部 $s_i = 0$ 时的 $f$ 啦，因为是要返回原状态嘛。

----

上面说了一堆理论上的东西，现在我们考虑如何实现。

首先发现求的时候是 EGF，但是算答案的时候是 OGF，这很怪。我们观察一下形式看看能不能转换。

对于 $\hat F$，有形式 $\displaystyle \hat F (x) = \prod_{i = 1}^{n} \frac{e^{(p_i / \dot p) x} + {(-1)}^{s_i} e^{-(p_i / \dot p) x}}{2}$。

我们把每个形如 $a_w e^{(w / \dot p)x}$ 的式子看作一项，可以发现最终 $w$ 的取值在 $[-\dot p, \dot p]$。

所以把 $\hat F (x)$ 表示成 $\displaystyle \sum_{w = -\dot p}^{\dot p} a_w e^{(w / \dot p) x}$ 的形式后，我们就有 $\displaystyle f_k = \sum_{w = -\dot p}^{\dot p} a_w {(w / \dot p)}^k$。

再把这个形式转换成 OGF，得到 $\displaystyle \mathbf{OGF} (f) = F(x) = \sum_{w = -\dot p}^{\dot p} \frac{a_w}{1 - (w / \dot p) x}$。

这时候考虑求出每个 $a_w$，可以发现做一个背包就行了，复杂度为 $\mathcal O (n \dot p)$。  
（观察背包转移时的系数都是 $\pm 1 / 2$，可以使用多项式 Exp 优化到 $\mathcal O (n + \dot p \log \dot p)$，但是没有必要）

对于 $\displaystyle \mathbf{OGF} (g) = G(x) = \sum_{w = -\dot p}^{\dot p} \frac{b_w}{1 - (w / \dot p) x}$ 同理，我们需要求出每一个 $b_w$。

求出所有 $a_w, b_w$ 之后，我们就掌握了 $f, g$ 的一些性质，然后对于答案 $h$，令其普通生成函数为 $H$。

则根据上面的解释，有 $H = F / G$，并且最终我们需要求出 $H'(1)$。

因为这里 $F, G, H$ 都可能有无限项，所以要考虑通过 $a_w, b_w$ 去求出答案。

考虑除法求导法则：$\displaystyle H' = {(F / G)}' = \frac{F'G - G'F}{G^2}$。

所以只要求出 $F(1), G(1), F'(1), G'(1)$ 即可。

然而很可惜，我们发现因为存在 $\displaystyle \frac{a_{\dot p}}{1 - (\dot p / \dot p) x}$ 这一项，所以 $F, G, F', G'$ 在 $x = 1$ 处不收敛。

我们知道答案一定收敛，所以考虑~~洛都可以洛~~做一点变换：把 $F$ 和 $G$ 都乘上 $(1 - x)$。那么就有：

- $F(1) = a_{\dot p}$。
- $\displaystyle F'(1) = \sum_{w = -\dot p}^{\dot p - 1} \frac{a_w}{w / \dot p - 1}$。
- $G(1) = b_{\dot p}$。
- $\displaystyle G'(1) = \sum_{w = -\dot p}^{\dot p - 1} \frac{b_w}{w / \dot p - 1}$。

具体计算过程省略，就是按照求导的公式算而已。所以：

$$ \begin{aligned} H'(1) &= \frac{F'(1) G(1) - G'(1) F(1)}{G^2(1)} \\ &= \frac{\displaystyle \left( \sum_{w = -\dot p}^{\dot p - 1} \frac{a_w}{w / \dot p - 1} \right) b_{\dot p} - \left( \sum_{w = -\dot p}^{\dot p - 1} \frac{b_w}{w / \dot p - 1} \right) a_{\dot p}}{b_{\dot p}^2} \\ &= \sum_{w = -\dot p}^{\dot p - 1} \frac{a_w b_{\dot p} - b_w a_{\dot p}}{(w / \dot p - 1) b_{\dot p}^2} \end{aligned} $$

求出所有的 $a_w, b_w$ 后按照此式计算即可，时间复杂度为 $\mathcal O (n \dot p + \dot p \log mod)$，代码如下：

```cpp
#include <cstdio>
#include <algorithm>

typedef long long LL;
const int Mod = 998244353, Inv2 = (Mod + 1) / 2;
const int MN = 105, MP = 50005;

inline void Add(int &x, LL y) { x = (x + y) % Mod; }
inline int qPow(int b, int e) {
	int a = 1;
	for (; e; e >>= 1, b = (LL)b * b % Mod)
		if (e & 1) a = (LL)a * b % Mod;
	return a;
}
inline int gInv(int b) { return qPow(b, Mod - 2); }

int N, s[MN], p[MN], sump;
int _a[2][MP * 2], _b[2][MP * 2], *a[2] = {_a[0] + MP, _a[1] + MP}, *b[2] = {_b[0] + MP, _b[1] + MP};
int Ans;

int main() {
	scanf("%d", &N);
	for (int i = 1; i <= N; ++i) scanf("%d", &s[i]), s[i] = s[i] ? -1 : 1;
	b[0][0] = a[0][0] = 1;
	for (int i = 1; i <= N; ++i) {
		scanf("%d", &p[i]);
		for (int j = -sump - p[i]; j <= sump + p[i]; ++j) b[1][j] = a[1][j] = 0;
		for (int j = -sump; j <= sump; ++j)
			Add(a[1][j + p[i]], (LL)Inv2 * a[0][j]),
			Add(a[1][j - p[i]], s[i] * (LL)Inv2 * a[0][j]),
			Add(b[1][j + p[i]], (LL)Inv2 * b[0][j]),
			Add(b[1][j - p[i]], (LL)Inv2 * b[0][j]);
		sump += p[i];
		std::swap(a[0], a[1]), std::swap(b[0], b[1]);
	}
	int isump = gInv(sump), *A = a[0], *B = b[0];
	for (int j = -sump; j < sump; ++j)
		Add(Ans, ((LL)A[j] * B[sump] - (LL)B[j] * A[sump]) % Mod * gInv((LL)j * isump % Mod - 1));
	Ans = (LL)Ans * qPow(B[sump], Mod - 3) % Mod;
	printf("%d\n", (Ans + Mod) % Mod);
	return 0;
}
```

---

## 作者：xht (赞：23)

方便起见，令 $p_i$ 为 $\frac{p_i}{\sum_{i=1}^n p_i}$。

对于 $i \in [1,n]$，由于先后按 $i$ 需要被算多次，即**有标号**计数，因此考虑 EGF。

令 $F_i(x) = \sum_{n \ge 0} [n \bmod 2 = s_i] \frac{p_i^n}{n!} x^n$，$F(x) = \prod_{i=1}^n F_i(x)$，则 $k![x^k]F(k)$ 就是 $k$ 次达到目标的概率，我们写成 OGF $f(x) = \sum_{k \ge 0} \left(k! \cdot [x^k]F(x)\right) x^k$。

由于我们要求的是第一次达到目标的期望次数，因此要扣掉第一次达到目标后再次返回到目标状态的情况。于是再做一遍上述的过程，求出在 $s_i = 0$，即 $k$ 次状态不变的概率的 OGF $g(x)$。

假设答案的 OGF 为 $h(x)$，则有 $f(x) = g(x) \cdot h(x)$，因此 $h(x) = \frac {f(x)}{g(x)}$。

又由于 $h^\prime(x) = \sum_{n\ge 0} (h_n x^n)^\prime = \sum_{n \ge 0} (h_nn)x^{n-1}$，所以 $h^\prime(1)$ 就是我们要的期望次数。

然后考虑如何计算，我们有：
$$
\begin{aligned}
F_i(x) &= \sum_{n \ge 0} [n \bmod 2 = s_i] \frac{p_i^n}{n!} x^n = \frac{e^{p_ix} + (-1)^{s_i}e^{-p_ix}}{2} \\\\
G_i(x) &= \sum_{n \ge 0} [n \bmod 2 = 0] \frac{p_i^n}{n!} x^n = \frac{e^{p_ix} + e^{-p_ix}}{2} \\\\
\end{aligned}
$$
于是：
$$
\begin{aligned}
F(x) &= \prod_{i=1}^n \frac{e^{p_ix} + (-1)^{s_i}e^{-p_ix}}{2} \\\\
G(x) &= \prod_{i=1}^n \frac{e^{p_ix} + e^{-p_ix}}{2} \\\\
\end{aligned}
$$
考虑将 $F(x)$ 写成 $\sum_{i} c_ie^{ix}$，则：

$$
\begin{aligned}
f(x) &= \sum_{k \ge 0} \left(k! \cdot [x^k]F(x)\right) x^k \\\\
&= \sum_{k \ge 0} \left(k! \cdot [x^k]\left(\sum_{i} c_ie^{ix}\right)\right) x^k \\\\
&= \sum_{k \ge 0} \left(k! \cdot [x^k]\left(\sum_{i}  c_i\cdot\left(\sum_{j \ge 0} \frac1{j!}(ix)^j\right)\right)\right) x^k \\\\
&= \sum_{k \ge 0} \left(k! \left(\sum_{i} c_i\cdot \frac1{k!}i^k \right)\right) x^k \\\\
&= \sum_{k \ge 0} \left(\sum_{i} c_ii^k \right) x^k \\\\
&= \sum_{i} c_i\left(\sum_{k \ge 0} i^k x^k \right) \\\\
&= \sum_{i} \frac{c_i}{1-ix} \\\\
\end{aligned}
$$

同理可以将 $g(x)$ 写成 $\sum_{i} \frac{d_i}{1-ix}$，其中 $c_i,d_i$ 都可以 $\mathcal O(nw)$ 背包出来。

最后求 $h^\prime(x)$，由于：
$$
h^\prime(x) = \left(\frac{f(x)}{g(x)}\right)^\prime = \frac{f^\prime(x)g(x) - f(x)g^\prime(x)}{g(x)^2}
$$

因此只用计算出 $f(1),f^\prime(1),g(1),g^\prime(1)$ 就可以算出答案了。

但不能直接带入 $x = 1$，因为不收敛。由于是除法，我们可以将 $f(x),g(x)$ 同时乘上 $(1-x)$ 解决这个问题：
$$
\begin{aligned}
f(x) &= \sum_{i} \frac{c_i(1-x)}{1-ix} \\\\
&= c_1 + \sum_{i \ne 1} \frac{c_i(1-x)}{1-ix} \\\\
f(1) &= c_1 \\\\
\end{aligned}
$$

---

$$
\begin{aligned}f^\prime(x) &= \left(\sum_{i} \frac{c_i(1-x)}{1-ix}\right)^\prime \\\\&= \sum_{i} \left(\frac{c_i-c_ix}{1-ix}\right)^\prime \\\\&= \sum_{i \ne 1} \frac{-c_i(1-ix)-(c_i - c_ix)(-i)}{(1-ix)^2} \\\\&= \sum_{i \ne 1} \frac{(i-1)c_i}{(1-ix)^2} \\\\f^\prime(1) &= \sum_{i \ne 1} \frac{(i-1)c_i}{(1-i)^2} \\\\&= \sum_{i \ne 1} \frac{c_i}{i-1} \\\\\end{aligned}
$$

同理 $g(1) = d_1$，$g^\prime(1) = \sum_{i \ne 1} \frac{d_i}{i-1}$，则：
$$
\begin{aligned}h^\prime(1) &= \frac{f^\prime(1)g(1) - f(1)g^\prime(1)}{g(1)^2} \\\\&= \frac{d_1\sum_{i \ne 1} \frac{c_i}{i-1} - c_1\sum_{i \ne 1} \frac{d_i}{i-1}}{d_1^2} \\\\&= \sum_{i \ne 1} \frac{c_id_1 -c_1d_i}{(i-1)d_1^2}\\\\\end{aligned}
$$

---

## 作者：forest114514 (赞：7)

# 所以 $k$ 进制开关怎么做？



题解第一篇只给了式子蒟蒻不知道怎么推的，所以写一写，~~默认大家都会 $k=2$ 的时候的 PGF 做法~~。

对于数列 $\Big\langle[i\bmod k=j]\Big\rangle$ 的 EGF，利用单位根反演可以构造出 $j=0$ 的时候即数列 $\Big\langle[k|i]\Big\rangle$ 的 EGF：
$$
F_{0}(z)=\frac{1}{k}\sum\limits_{i=0}^{k-1}e^{\omega_{k}^{i}z}
$$
然后对于一般情况，求 $k-j$ 次导就得到（为什么发现系数就是范德蒙德逆矩阵对应位置的值？）：
$$
F_{j}(z)=\frac{1}{k}\sum\limits_{i=0}^{k-1}\omega_{k}^{-ij}e^{\omega_{k}^{i}z}
$$

记 $P=\sum p_i$，所以对于得到结束局面的 EGF 就是：
$$
\widehat G(z)=\prod\limits_{j=1}^{n}F_{S_{j}}(\frac{p_jz}{P})=\frac{1}{k^n}\prod\limits_{j=1}^{n}\sum\limits_{i=0}^{k-1}\omega_{k}^{-iS_j}e^{\frac{{\omega _{k}^{i}p_jz}}{P}}
$$

换元设 $u=e^{\frac{P}{z}}$，所以有：
$$
\widehat G(z)=\frac{1}{k^n}\prod\limits_{j=1}^{n}\sum\limits_{i=0}^{k-1}\omega_{k}^{-iS_j}u^{\omega_{k}^{i}p_j}
$$
然后得到空状态的 EGF 就是：
$$
\widehat H(z)=\frac{1}{k^n}\prod\limits_{j=1}^{n}\sum\limits_{i=0}^{k-1}u^{\omega_{k}^{i}p_j}
$$
最后求出的形如 EGF 形如：
$$
\widehat G(z)=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}A_{i,t}u^{\omega_{k}^{t}i},\widehat H(z)=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}B_{i,t}u^{\omega_{k}^{t}i}
$$
跑一个类背包 DP 暴力卷即可。

然后答案的 PGF 就是转 OGF 后的 $\frac{G}{H}$ ，所以要求 $G,H,G',H'$。

因为 $\operatorname{OGF}(e^{\frac{z}{P}})=\frac{P}{P-z}$，所以以 $G$ 为例：
$$
G(z)=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}\frac{A_{i,t}P}{P-{\omega_{k}^{t}i}z},
G'(z)=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}\frac{A_{i,t}\omega_{k}^{t}iP}{(P-{\omega_{k}^{t}i}z)^2}
$$
还是经典地上下同乘 $(1-z)$，然后就能求出新的 $G(1),G'(1)$。
$$
G(z)=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}[i\neq P\land t\neq 0]\frac{A_{i,t}P(1-z)}{P-{\omega_{k}^{t}i}z}+A_{P,0}P,G(1)=A_{P,0}
$$

$$
\begin{aligned}
G'(z)&=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}\left(\frac{A_{i,t}P(1-z)}{P-{\omega_{k}^{t}i}z}\right)'\\
&=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}\frac{A_{i,t}P(\omega_{k}^{t}i-P)}{(P-{\omega_{k}^{t}i}z)^2}\\
&=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}[i\neq P\land t\neq 0]\frac{A_{i,t}P}{{\omega_{k}^{t}i}z-P}\\
G'(1)&=\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}[i\neq P\land t\neq 0]\frac{A_{i,t}P}{\omega_{k}^{t}i-P}
\end{aligned}
$$

代入回去：
$$
\begin{aligned}
	F'(1)
	&=(\frac{G(1)}{H(1)})'\\
	&=\frac{G'(1)H(1)-G(1)H'(1)}{H^2(1)}\\
	&=\frac{(\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}[i\neq P\land t\neq 0]\frac{A_{i,t}P}{{\omega_{k}^{t}i}-P})B_{P,0}-(\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}[i\neq P\land t\neq 0]\frac{B_{i,t}P}{{\omega_{k}^{t}i}-P})A_{P,0}}{B_{P,0}^{2}}\\
	&=\frac{P}{B_{P,0}^{2}}\sum\limits_{i=0}^{P}\sum\limits_{t=0}^{k-1}[i\neq P\land t\neq 0]\frac{A_{i,t}B_{P,0}-B_{i,t}A_{P,0}}{{\omega_{k}^{t}i}-P}
\end{aligned}
$$
不过 ${{\omega_{k}^{t}i}-P}$ 不好直接算，在模意义下存在的时候还好可以直接算，否则写个扩域，因为 $k$ 的分圆多项式 $\Phi_{k}(x)|(x^n-1)$，可以先在模 $x^n-1$ 的意义下计算，最后再对 $\Phi_{k}(x)$ 取模即可，时间 $O(nk^3P)$（应该能用多项式科技优化？），这个式子带入 $k=2$ 发现就是对的。

同样地能够发现 $A_{P,0}=B_{P,0}=\frac{1}{k^n}$，能减少一些计算常数。

---

## 作者：Nemlit (赞：6)

设$f_i$表示状态为$i$的期望步数，那么我们考虑转移方程：
$$f_i=\sum_{k}f_{i\oplus 2^k}\times p_{k}+1=\sum_{j\oplus k=i}f_{j}\times p_{k}+1$$
其中$p_{k}$只在$2^k$处为$p_k$，其余部分为$0$。

然后我们可以利用高斯消元来求解，复杂度$O(8^n)$，我们还需要进行优化。

考虑设$F(x)=\sum_{i=0}^{n}f_ix^i, G(x)=\sum_{i=2^k}p_kx^i, I(x)=\sum_{i}x^i$。所以我们可以写成：$F(x)=F(x)\times G(x)+I(x)+c$，其中$+c$的意义是强制把$f_0$转成$0$。

接下来是一步神奇的操作，这里实际上是一个异或卷积，我们可以把它们强行转成点值，于是我们有：$FWT_i(F(x))=FWT_i(F(x))\times FWT_i(G(x))+FWT_i(I(x))+FWT_i(c), FWT_i(F(x))(1-FWT_i(G(x)))=FWT_i(I(x))+FWT_i(c)$。不难发现这些点值都很有规律。

$1.FWT(C)$。不难发现他恒等于$c$。

$2.FWT_i(I(x))$。设$i$有$k$个$1$，考虑$FWT_i=\sum_{j}(-1)^{|i\&j|}=2^{n-k}\sum_{j=0}^k\dbinom{k}{j}(-1)^j=2^{n-k}[k==0]$。

$3.FWT_i(G(x))$。$FWT_i(G(x))=\sum_{j}(-1)^{|i\&j|}$，也就是所有$0$位置上的$p_j$之和减去$1$位置上的$p_j$之和。

当$i=0$时，$FWT_i(G(x))=1$，所以此时$-FWT_i(I(x))=FWT_i(c)$，所以我们解出$c=-2^n$。

我们先考虑$i=0$。$i=0$时上面的方程不能计算，但由于$IFWT_0(FWT_0(F(x)))=0$，所以$FWT_0(FWT_0(F(x)))=0$，即$FWT_0(F(x))=-\sum_{i\ne 0}{FWT_i(F(x))}$，算出所有的$FWT_i(F(x))$之和即可。

$$FWT_i(F(x))=\dfrac{-2^n}{1-FWT_i(G(x))}=\dfrac{-2^n}{2\times \sum_{i\&{2^k}\ne 0}p_k}$$
$$\begin{aligned}&\;\;\;\;IFWT_i(FWT_i(F(x)))\\&=\dfrac{1}{2^n}\Big(\sum_{j\ne 0}(-1)^{|i\&j|}\dfrac{-2^n}{2\times \sum_{i\&{2^k}\ne 0}p_k}+\sum_{j\ne 0}\dfrac{2^n}{2\times \sum_{i\&{2^k}\ne 0}p_k}\Big)\\&=\Big(\sum_{j}\dfrac{|i\&j|≡1\;mod\;2}{\sum_{i\&{2^k}\ne 0}p_k})\end{aligned}$$

到这里我们已经有一个$O(2^n)$的做法了，考虑怎么加速这个计算过程：设$dp[i][j][0/1]$表示考虑了前$i$个数，和$S$集合的交集的奇偶性为$0/1$，当前的$p_i$之和为$j$的方案数。直接转移即可，复杂度$O(n\sum P)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define rep(i, a, b) for(re int i = (a); i <= (b); ++ i)
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define mod 998244353
#define maxn 1000005
int n, s[maxn], sum, ans, p[maxn], dp[105][50005][2];
il int qpow(int a, int b) { int r = 1; while(b) { if(b & 1) r = 1ll * r * a % mod; a = 1ll * a * a % mod, b >>= 1; } return r; }
signed main() {
	n = read(), dp[0][0][0] = 1;
	rep(i, 1, n) s[i] = read();
	rep(i, 1, n) p[i] = read(), sum += p[i];
	rep(i, 1, n) {
		rep(j, p[i], sum) {
			if(s[i]) {
				dp[i][j][0] = (dp[i - 1][j - p[i]][1] + dp[i - 1][j][0]) % mod;
				dp[i][j][1] = (dp[i - 1][j - p[i]][0] + dp[i - 1][j][1]) % mod;
			}
			else {
				dp[i][j][0] = (dp[i - 1][j - p[i]][0] + dp[i - 1][j][0]) % mod;
				dp[i][j][1] = (dp[i - 1][j - p[i]][1] + dp[i - 1][j][1]) % mod;
			}
		}
		rep(j, 0, p[i] - 1) dp[i][j][0] = dp[i - 1][j][0], dp[i][j][1] = dp[i - 1][j][1];
	}
	rep(i, 1, sum) ans = (ans + 1ll * dp[n][i][1] * qpow(i, mod - 2) % mod) % mod;
	cout << 1ll * ans * sum % mod;
	return 0;
}
```

---

## 作者：wrpwrp (赞：3)


### 题意
> 有 $n$ 个开关， 初始的时候都是 $0$, 给出一个状态 $s$ ， 每次以 $\frac{p_i}{\sum_{j = 1}^np_j}$ 的概率按下一个开关 $i$ 期望多少次以后可以第一次达到这个状态。

> $n \leq 100, \sum p_i \leq 5\times 10^4$

### 题解
令 $a_i = \frac{p_i}{\sum_{i = 1}^np_j}, m = \sum_{i = 1}^n p_i$ 。
考虑生成一个操作序列， 讨论每个位置要按下的奇偶性， 可以直接写出操作序列出现概率的EGF。
$$\hat{F}(x) = \prod_{i = 1}^n \frac{e^{a_ix}+ (-1) ^{s_i}e^{-a_ix}}{2}$$
但是这个东西显然啥用也没有， 因为我们要求出的是第一次到达这个状态的EGF， 这个求出来的显然只是所有最终状态是 $s$ 的EGF。

考虑一个经典的构造， 令第一次到达状态 $s$ 的生成函数是 $H(x)$，  若干次操作以后回到原状态的序列的生成函数是 $\hat{G}(x)$ ， 那么答案就是 $H'(1)$ 。
不难写出 $\hat{G}(x)$ 的表达式， 也就是 $s_i$ 全部是 偶数的情况。
$$\hat{G}(x) = \prod_{i = 1}^n \frac{e^{a_ix}+ e^{-a_ix}}{2}$$

考虑一个组合意义， “到达 $s$ 的概率 $=$ 第一次到达 $s$ 的概率， 经过若干次重新到达 $s$ 的概率（可以是$0$次）”。
这显然只是一个卷积的意义， 可以得到方程 $F = GH$ 。也就是 $H = \frac{F}{G}$ 。
注意这里的 $F, G$ 是上文 $EGF$ 的 $OGF$ 形式。

简单求导可以得到 $H'(1) = \frac{F'(1)G(1) - F(1)G'(1)}{G^2(1)}$。现在问题变成对 $F', G', F, G$ 求系数和。

以 $F$ 为例考虑对其动手动脚。
令 
$$\hat{F} = \sum_jf_je^{\frac{j}{m}x}$$
那么
$$F = \sum_jf_j\frac{m}{m - jx}$$

这一步操作仅仅是转了一次OGF。
然后现在考虑求一波系数， 但是发现有点问题在于 $F$ 当 $j = m, x = 1$ 的时候没意义了。
~~然后你点开了题解发现大家都乘了一个 $1 - x$。~~
考虑把 $F$ 和 $G$ 同时乘一个 $1 - x$ 答案是不变的， 而且发现此时函数 $F, G$ 均收敛。
然后再考虑计算其系数。
设 $P(x) = F(x)(1 - x), Q(x) = G(x)(1 - x)$ 。
通过求导容易知道 $P(1) = f_m, P'(1) = \sum_{-m \leq j \leq m - 1}f_j\frac{m}{j - m}$ 。
$Q, Q'$ 可以同理得出。
直接大力背包出 $f_i, g_i$ 就可以暴算了。

[code](https://www.cnblogs.com/clover4/p/15837930.html)

---

## 作者：cwfxlh (赞：2)

# [P5326](https://www.luogu.com.cn/problem/P5326) 

csp 考前写篇题解，rp++。

令 $p_i$ 表示开关 $i$ 被选中的概率（与题面不同）。令序列 $s_1,s_2,\dots s_n$ 表示每个开关被选了几次，那么经过 $k$ 次操作后复原的概率可以表示为：   

$$\sum_s[\sum s=k]k!\prod_{i=1}^{n}\frac{p_i^{s_i}[a_i\equiv s_i \pmod 2]}{s_i!}$$    

考虑后面的这个乘积式中的每一项，发现其可以表示成 $\frac{e^{p_ix}+(-1)^{a_i}e^{-p_ix}}{2}$。令：   

$$F(x)=\prod_{i=1}^{n}{\frac{e^{p_ix}+(-1)^{a_i}e^{-p_ix}}{2}}$$     

则第一个式子可以写成 $k![x^k]F(x)$ 的形式。      

但是我们发现这样会算重，具体的，令 $G(x)$ 表示 $a_i$ 都为 0 时的 $F(x)$，即：         

$$G(x)=\prod_{i=1}^{n}{\frac{e^{p_ix}+e^{-p_ix}}{2}}$$     

再令 $f(x)=\sum_{i=0}^{\inf}i!x^i[x^i]F(x)$，$g(x)=\sum_{i=0}^{\inf}i!x^i[x^i]G(x)$，$[x^i]ans(x)$ 表示在第 $i$ 次结束的概率，则 $ans*g=f$。             

我们要求 $\sum_{i=0}^{\inf}i[x^i]ans(x)$，发现这等于 $ans'(1)$，于是转化为求 $(\frac{f}{g})'(1)$。             

先把 $f$ 与 $g$ 求出来。        

$F$ 显然可以通过类似背包的做法求出一个 $\sum{c_ie^{ix}}$ 的形式。    

$$f(x)=\sum_{i=0}^{\inf}i!x^i[x^i]\sum_{j}{c_je^{jx}}$$     

$$f(x)=\sum_{i=0}^{\inf}i!x^i[x^i]\sum_{j}{c_j\frac{j^i}{i!}}$$     

$$f(x)=\sum_{j}c_j\sum_{i=0}^{\inf}{j^ix^i}$$     

$$f(x)=\sum_{j}\frac{c_j}{1-jx}$$     

$g$ 也可以类似的求出来。          

最后需要求的就是 $(\frac{f}{g})'(1)=\frac{f'(1)g(1)-f(1)g'(1)}{g^2(1)}$，但是发现当 $c_1\not =0$ 时会算不了。于是进行一个神秘操作，求 $(\frac{f*(1-x)}{g*(1-x)})'(1)$。       

这时候计算 $(f*(1-x))(1)=c_1$，$(f*(1-x))'(1)=\sum_{i\not =1}\frac{c_i}{i-1}$，类似的计算 $g$ 即可。复杂度为 $O(n\sum p)$，瓶颈在于背包。           

代码：        


```cpp
#include<bits/stdc++.h>
#define int long long
#define MOD 998244353
using namespace std;
int n,a[500003],p[500003],sump,nsump,f[1000003],g[1000003],val[1000003],ny2=(MOD+1)/2,f1,fd1,g1,gd1,ans;
int getmod(int X){return ((X%MOD)+MOD)%MOD;}
int fstp(int X,int Y){int ret=1,bse=getmod(X);while(Y){if(Y%2)ret=getmod(ret*bse);bse=getmod(bse*bse);Y/=2;}return ret;}
signed main(){
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>p[i];
    for(int i=1;i<=n;i++)sump=getmod(sump+p[i]);
    nsump=fstp(sump,MOD-2);
    f[sump]=g[sump]=1;
    for(int i=1,nowsum=0;i<=n;i++){
        nowsum+=p[i];
        int xs=1;
        if(a[i])xs=-1;
        for(int j=sump-nowsum;j<=sump+nowsum;j++)val[j]=f[j];
        for(int j=sump-nowsum;j<=sump+nowsum;j++){
            f[j]=0;
            if(j-p[i]>=sump-nowsum)f[j]=getmod(f[j]+val[j-p[i]]*ny2);
            if(j+p[i]<=sump+nowsum)f[j]=getmod(f[j]+val[j+p[i]]*ny2*xs);
        }
        for(int j=sump-nowsum;j<=sump+nowsum;j++)val[j]=g[j];
        for(int j=sump-nowsum;j<=sump+nowsum;j++){
            g[j]=0;
            if(j-p[i]>=sump-nowsum)g[j]=getmod(g[j]+val[j-p[i]]*ny2);
            if(j+p[i]<=sump+nowsum)g[j]=getmod(g[j]+val[j+p[i]]*ny2);
        }
    }
    f1=f[sump*2];
    g1=g[sump*2];
    for(int j=0;j<=sump*2;j++){
        if((j-sump)==sump)continue;
        fd1=getmod(fd1+f[j]*fstp((j-sump)*nsump-1,MOD-2)); 
        gd1=getmod(gd1+g[j]*fstp((j-sump)*nsump-1,MOD-2)); 
    }
    ans=getmod(fd1*g1-f1*gd1);
    ans=getmod(ans*fstp(g1,MOD-2));
    ans=getmod(ans*fstp(g1,MOD-2));
    cout<<ans;
    return 0;
}
```

---

## 作者：Y_B_X (赞：2)

[原题链接](https://www.luogu.com.cn/problem/P5326)

> 题意：$n$ 盏初始关闭的灯，每次有 $\dfrac{p_i}{\sum\limits_{1\leq j\leq n}p_j}$ 的概率反转一个灯的状态，  
求达到目标状态的期望操作次数。  
$1\leq n\leq 100,\sum\limits_{1\leq j\leq n}p_j\leq5\times 10^4$

设长度为 $i$ 的合法操作方案  出现概率为 $f_i$，其概率生成函数为 $F(x)=\sum\limits_{i\geq 0}f_ix^i$，则答案为 $F'(1)$。

考虑一个是目标状态的操作方案（包括中途可能经过几次目标状态），它必定由一种合法的操作方案（到达目标状态就停止）的后面拼接上 一段每个位置都被操作偶数次的操作序列。而且两者之间必然一一对应。

长度为 $m$ 的是目标状态的操作方案的出现概率（$\sum p$ 即为 $p$ 的和，下标懒得打）：

$$\sum\limits_{\tiny{\begin{matrix}t_1,t_1\cdots t_n\geq 0\\\sum\limits_{j=1}^n t_{j}=m\end{matrix}}}\binom{m}{t_1,t_2,\dots,t_n}\prod\limits_{j=1}^n\left(\dfrac{p_j}{\sum p}\right)^{t_j}[t_j\equiv s_j\bmod2] $$

$$=\left(\dfrac{1}{\sum p}\right)^m\left[\dfrac{x^m}{m!}\right]\prod\limits_{j=1}^n\left(\sum\limits_{t\geq 0}\dfrac{x^t}{t!}p_j^t[t\equiv s_j\bmod 2]\right)$$

长度为 $m$ 的每个数都被操作偶数次的操作序列的出现概率：

$$\left(\dfrac{1}{\sum p}\right)^m\left[\dfrac{x^m}{m!}\right]\prod\limits_{j=1}^n\left(\sum\limits_{\tiny{\begin{matrix}t\geq 0\\2|t\end{matrix}}}\dfrac{x^t}{t!}p_j^t\right)$$

所以：$F(x)=\dfrac{\displaystyle \sum_{m\geq 0}x^m\left(\dfrac{1}{\sum p}\right)^m\left[\dfrac{x^m}{m!}\right]\prod\limits_{j=1}^n\left(\sum\limits_{t\geq 0}\dfrac{x^t}{t!}p_j^t[t\equiv s_j\bmod 2]\right)}{\displaystyle \sum\limits_{m\geq 0}x^m\left(\dfrac{1}{\sum p}\right)^m\left[\dfrac{x^m}{m!}\right]\prod\limits_{j=1}^n\left(\sum\limits_{\tiny{\begin{matrix}t\geq 0\\2|t\end{matrix}}}\dfrac{x^t}{t!}p_j^t\right)}$

由于 $\sum\limits_{\tiny{\begin{matrix}i\geq 0\\2|i\end{matrix}}}\dfrac{x^i}{i!}=\dfrac{e^x+e^{-x}}{2}=\cosh(x),\sum\limits_{\tiny{\begin{matrix}i> 0\\2| i\!-\!1\end{matrix}}}\dfrac{x^i}{i!}=\dfrac{e^x-e^{-x}}{2}=\sinh(x)$，

设： $S_0=\{j|s_j\equiv 0\bmod 2\},S_1=\{j|s_j\equiv 1\bmod 2\}$，那 $F(x)$ 就有好看的形式：

$$F(x)=\dfrac{\displaystyle\sum\limits_{m\geq 0}\left(\dfrac{x}{\sum p}\right)^m\left[\dfrac{x^m}{m!}\right]\prod\limits_{j\in S_0}\cosh(p_jx)\prod\limits_{j\in S_1}\sinh(p_jx)}{\displaystyle\sum\limits_{m\geq 0}\left(\dfrac{x}{\sum p}\right)^m\left[\dfrac{x^m}{m!}\right]\prod\limits_{1\leq j\leq n}\cosh(p_jx)}$$

或者上下同时乘上 $2^n:$

$$F(x)=\dfrac{\displaystyle\sum\limits_{m\geq 0}\left(\dfrac{x}{\sum p}\right)^m\left[\dfrac{x^m}{m!}\right]\prod\limits_{j\in S_0}\left(e^{p_jx}+e^{-p_jx}\right)\prod\limits_{j\in S_1}\left(e^{p_jx}-e^{-p_jx}\right)}{\displaystyle\sum\limits_{m\geq 0}\left(\dfrac{x}{\sum p}\right)^m\left[\dfrac{x^m}{m!}\right]\prod\limits_{1\leq j\leq n}\left(e^{p_jx}+e^{-p_jx}\right)}$$

设： $\begin{cases}\displaystyle \prod\limits_{j\in S_0}\left(e^{p_jx}+e^{-p_jx}\right)\prod\limits_{j\in S_1}\left(e^{p_jx}-e^{-p_jx}\right)=\sum_{a\in T_N}C_{N_a} e^{ax}\\\displaystyle \prod\limits_{1\leq j\leq n}\left(e^{p_jx}+e^{-p_jx}\right)=\sum_{a\in T_D}C_{D_a}e^{ax}\end{cases}$

其中集合 $T_N,T_D$ 可以 $O(n\sum p)$ 求出（就相当于求 $n$ 个 $x^p+x^{-p}$ 的积）。

于是：

$$F(x)=\dfrac{\displaystyle \sum_{a\in T_N}C_{N_a}\sum_{m\geq 0}\left(\dfrac{x}{\sum p}\right)^m\left[\dfrac{x^m}{m!}e^{ax}\right]}{\displaystyle \sum_{a\in T_D}C_{D_a}\sum_{m\geq 0}\left(\dfrac{x}{\sum p}\right)^ma^m}=\dfrac{\displaystyle \sum_{a\in T_N}\dfrac{C_{N_a}}{1-\dfrac{ax}{\sum p}}}{\displaystyle \sum_{a\in T_D}\dfrac{C_{D_a}}{1-\dfrac{ax}{\sum p}}}$$

$T_N,T_D$ 中都有一个元素 $a=\sum p$。由于最后要求 $F'(1)$，将其拉出来并上下同乘 $1-x$：

$$F(x)=\dfrac{\displaystyle 1+(1-x)\sum_{\tiny\begin{matrix}a\in T_N\\a\neq \sum p\end{matrix}}\dfrac{C_{N_a}}{1-\dfrac{ax}{\sum p}}}{\displaystyle 1+(1-x)\sum_{\tiny\begin{matrix}a\in T_D\\a\neq \sum p\end{matrix}}\dfrac{C_{D_a}}{1-\dfrac{ax}{\sum p}}}$$

设分子分母 $1-x$ 后面的两坨东西为 $N(x),D(x)$，即 $F(x)=\dfrac{1+(1-x)N(x)}{1+(1-x)D(x)}$。

由于 $x=1$ 时包含 $1-x$ 的项全为 $0$，$F'(1)$ 剩下的很干净：$F'(1)=-N(1)+D(1)$。

所以答案就是： $\displaystyle \sum p\left(-\sum_{\tiny\begin{matrix}a\in T_N\\a\neq \sum p\end{matrix}}\dfrac{C_{N_a}}{-a+\sum p}+\sum_{\tiny\begin{matrix}a\in T_D\\a\neq \sum p\end{matrix}}\dfrac{C_{D_a}}{-a+\sum p}\right)$

时间复杂度 $O\left(n\sum p\right)$，当然也可以用 $\operatorname{Exp}+\operatorname {Ln}$ 算 $\prod\limits_{i=1}^n1+x^{2p_i}$ 做到 $O\left(n+\sum p\log \left(\sum p\right)\right)$。

$\texttt{code}:$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int n,m,x,y,ans;
int p[101],Sp;bool s[101];
int tmp1_[100010],*tmp1;
int tmp2_[100010],*tmp2;
int tn[100010],td[100010];
int inv[100010];char ch;
template<typename T>
inline void read(T &x){
	x=0;ch=getchar();
	while(ch<48)ch=getchar();
	while(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
inline void mul0(int *s,int p){
	int i;
	memcpy(tmp1-p-m,s-m,((m<<1)+1)<<2);
	memcpy(tmp2+p-m,s-m,((m<<1)+1)<<2);
	m+=p;
	for(i=-m;i<=m;++i){
		s[i]=tmp1[i]+tmp2[i];
		if(s[i]>=mod)s[i]-=mod;
	}
	memset(tmp1-m,0,((m<<1)+1)<<2);
	memset(tmp2-m,0,((m<<1)+1)<<2);
}
inline void mul1(int *s,int p){
	int i;
	memcpy(tmp1-p-m,s-m,((m<<1)+1)<<2);
	memcpy(tmp2+p-m,s-m,((m<<1)+1)<<2);
	m+=p;
	for(i=-m;i<=m;++i){
		s[i]=tmp2[i]-tmp1[i];
		if(s[i]<0)s[i]+=mod;
	}
	memset(tmp1-m,0,((m<<1)+1)<<2);
	memset(tmp2-m,0,((m<<1)+1)<<2);
}
int main(){
	read(n);int i,j;
	for(i=1;i<=n;++i)read(s[i]);
	for(i=1;i<=n;++i)read(p[i]),Sp+=p[i];
	tmp1=tmp1_+Sp;
	tmp2=tmp2_+Sp;
	td[Sp]=tn[Sp]=1;
	for(i=1;i<=n;++i){
		mul0(td+Sp,p[i]);m-=p[i];
		if(!s[i])mul0(tn+Sp,p[i]);
		else mul1(tn+Sp,p[i]);
	}
	Sp<<=1;
	for(inv[1]=1,i=2;i<=Sp;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(i=0;i<Sp;++i)ans=(1ll*(td[i]-tn[i])*inv[Sp-i]+ans)%mod;
	printf("%lld",1ll*(ans+mod)*(Sp>>1)%mod);
}
```

---

## 作者：LiuIR (赞：1)

## 题目大意

有 $n$ 个开关初始时状态都是 $0$。每次以 $\frac{a_i}{\sum a_i}$ 的概率按下其中一个开关 $i$。问期望多少次第一次到达状态 $S$。

$n\le100,\sum a_i\le5\times10^4$

## 题解

记 $p_i=\frac{a_i}{\sum a_i}$。

考虑设 $f_S$ 表示第一次到达状态 $S$ 的期望步数，那么有转移

$$
f_S=1+\sum_{i}f_{S\oplus\{i\}}p_i
$$

特殊的，有 $f_{\empty}=0$。

这样就可以高斯消元做到 $O(8^n)$。

注意到转移是异或卷积，于是写成集合幂级数形式。记 $F(x)=\sum_S f_Sx^S,G(x)=\sum_i p_ix^{\{i\}},I(x)=\sum_S x^S$，那么有

$$
F(x)=F(x)\circ G(x)+I(x)+c\times x^{\empty}
$$

最后加上 $c\times x^{\empty}$ 是为了保证 $[x^{\empty}]F(x)=0$。

FWT 后得到

$$
\begin{aligned}
[x^S]FWT_F(x)(1-[x^S]FWT_G(x))&=[x^S]FWT_I(x)+[x^S]FWT(c\times x^{\empty})\\
&=\sum_{T}(-1)^{\left|S\cap T\right|}+c\\
&=2^{n-\left|S\right|}\sum_{i=0}^{\left|S\right|}\binom{\left|S\right|}{i}(-1)^i+c\\
&=2^n[S=\empty]+c
\end{aligned}
$$

因为当 $S=\empty$ 时 $[x^S]FWT_G(x)=1$，于是要特殊处理，得到 $c=-2^n$。

利用

$$
[x^{\empty}]F(x)=\frac{1}{2^n}\sum_T(-1)^{\left|S\cap T\right|}[x^T]FWT_F(x)=0
$$

得到 

$$[x^{\empty}]FWT_F(x)=-\frac{1}{2^n}\sum_{T\not=\empty}(-1)^{\left|S\cap T\right|}[x^T]FWT_F(x)
$$

又因为有

$$
\begin{aligned}
[x^S]FWT_G(x)&=\sum_i(-1)^{\left|S\cap\{i\}\right|}p_i\\
&=\sum_{i\not\in S}p_i-\sum_{i\in S}p_i
\end{aligned}
$$

得到

$$
1-[x^S]FWT_G(x)=2\sum_{i\in S}p_i
$$

最后再暴力带入答案得到

$$
\begin{aligned}
[x^S]F(x)&=\frac{1}{2^n}\sum_T(-1)^{\left|S\cap T\right|}[x^T]FWT_F(x)\\
&=\frac{1}{2^n}\sum_{T\not=\empty}((-1)^{\left|S\cap T\right|}-1)[x^T]FWT_F(x)\\
&=\frac{1}{2^n}\sum_{T\not=\empty}-2[\left|S\cap T\right|\bmod2=1][x^T]FWT_F(x)\\
&=\frac{1}{2^n}\sum_{T\not=\empty}-2[\left|S\cap T\right|\bmod2=1]\frac{-2^n}{1-[x^T]FWT_G(x)}\\
&=\sum_{T\not=\empty}[\left|S\cap T\right|\bmod2=1]\frac{1}{\sum_{i\in S}p_i}\\
&=\left(\sum a_i\right)\sum_{T\not=\empty}[\left|S\cap T\right|\bmod2=1]\frac{1}{\sum_{i\in S}a_i}\\
\end{aligned}
$$

于是可以直接背包 $\sum_{i\in S}a_i$，做到 $O(n\sum a_i)$。

主要代码如下：

```c++
int n, m, s[N];
ll ans, a[N], f[N][M][2];

signed main()
{
    SetIO();
    cin >> n;
    for (int i = 1, x; i <= n; i++)
        cin >> s[i];
    for (int i = 1; i <= n; i++)
        cin >> a[i], m += a[i];
    f[0][0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= 0; j--)
        {
            f[i][j][0] = f[i - 1][j][0];
            f[i][j][1] = f[i - 1][j][1];
            if (j >= a[i])
            {
                Add(f[i][j][s[i]], f[i - 1][j - a[i]][0]);
                Add(f[i][j][s[i] ^ 1], f[i - 1][j - a[i]][1]);
            }
        }
    for (int i = 1; i <= m; i++)
        Add(ans, f[n][i][1] * Pow(i) % MOD);
    ans = ans * m % MOD;
    cout << ans;
    return 0;
}
```

---

## 作者：Leasier (赞：1)

抽象题 /youl

------------

首先有一个暴力的想法：

- 设 $f_S$ 表示现在 $S$ 集合中的开关状态满足条件，$q_i = \dfrac{p_i}{\displaystyle\sum_{j = 1}^n p_j}$。
- 初值：$f_0 = 0$。
- 转移：$\forall S \neq \emptyset, f_S = \displaystyle\sum_{i = 1}^n q_i f_{S \operatorname{xor} \{i\}} + 1$。
- 答案：$f_{\{x \mid s_x = 0\}}$。

直接高斯消元的时间复杂度为 $O(8^n)$。~~可以获得 $40$ 分的好成绩！！！~~

注意到转移的形式为**异或卷积**，考虑写出形式幂级数。

设 $F(x) = \displaystyle\sum_S f_S x^S$，$G(x) = \displaystyle\sum_{i = 1}^n q_i x^{\{i\}}$。

根据转移写出关系式：$F = F * G + \displaystyle\sum_S x^S + k x^{\emptyset}$，这里 $k$ 为一个用于修正 $f_0$ 的常数。

施 FWT-xor，令 $F' = \operatorname{FWT}_F, G' = \operatorname{FWT}_G$，则有：$F' = F' \times G' + \displaystyle\sum_S \operatorname{FWT}(x^S) + k \operatorname{FWT}(x^{\emptyset})$。

- **回忆**：$[x^S] \operatorname{FWT}_F (x) = \displaystyle\sum_T (-1)^{|S \cap T|} [x^T] F(x)$。

提取系数，有 $[x^S] F'(x)(1 - [x^S] G'(x)) = \displaystyle\sum_T (-1)^{|S \cap T|} + k$，考虑求 $k$。

首先可以注意到 $h(S) = \displaystyle\sum_T (-1)^{|S \cap T|} = 2^{n - |S|} \sum_{S' \subseteq S} (-1)^{|S'|} = [S = \emptyset] 2^n$。

注意到 $[x^{\emptyset}] G'(x) = \displaystyle\sum_{i = 1}^n q_i = 1$，不妨令 $S = \emptyset$，得 $k = -h(\emptyset) = -2^n$。

于是 $\forall S \neq \emptyset, [x^S] F'(x) = - \dfrac{2^n}{1 - [x^S] G'(x)}$。

注意到 $G$ 中只有 $n$ 项有值，考虑 $1 - [x^S] G'(x)$，代入定义式可知其为 $2 \displaystyle\sum_{i \in S} p_i$。

现在考虑求答案 $f_S$，IFWT-xor 回去可知 $f_S = \dfrac{\displaystyle\sum_T (-1)^{|S \cap T|} [x^T] F'(x)}{2^n}$。

考虑把 $\emptyset$ 和 $\forall T \neq \emptyset$ 分开：

- 代入 $f_0$，可知 $[x^{\emptyset}] F'(x) = -\displaystyle\sum_S [x^S] F'(x)$。
- 把它与剩下的部分加起来，可知 $f_S = \dfrac{\displaystyle\sum_T ((-1)^{|S \cap T|} - 1) [x^T] F'(x)}{2^n}$。

当 $|S \cap T|$ 为偶数，系数为 $0$；当 $|S \cap T|$ 为奇数，系数为 $-2$。

于是 $f_S = \dfrac{-2 \displaystyle\sum_T [|S \cap T| \bmod 2 = 1] [x^T] F'(x)}{2^n} = \dfrac{-2 \displaystyle\sum_T [|S \cap T| \bmod 2 = 1] \dfrac{-2^n}{2 \displaystyle\sum_{i \in T} p_i}}{2^n} = \displaystyle\sum_T [|S \cap T| \bmod 2 = 1] \dfrac{1}{\displaystyle\sum_{i \in T} p_i}$。

对 $\displaystyle\sum_{i \in T} p_i$ 背包即可。时间复杂度为 $O(n \sum p_i)$。

代码：
```cpp
#include <stdio.h>

const int mod = 998244353;
int s[107], p[107], inv[50007], dp[2][50007][2];

inline void init(int n){
	inv[0] = inv[1] = 1;
	for (register int i = 2; i <= n; i++){
		inv[i] = mod - 1ll * (mod / i) * inv[mod % i] % mod;
	}
}

inline void add(int &x, int y){
	if ((x += y) >= mod) x -= mod;
}

int main(){
	int n, lst, sum = 0, ans = 0;
	scanf("%d", &n);
	lst = n & 1;
	for (register int i = 1; i <= n; i++){
		scanf("%d", &s[i]);
	}
	for (register int i = 1; i <= n; i++){
		scanf("%d", &p[i]);
	}
	dp[0][0][0] = 1;
	for (register int i = 1; i <= n; i++){
		int cur = i & 1, pre = cur ^ 1;
		for (register int j = 0; j <= sum; j++){
			int t = j + p[i];
			for (register int k = 0; k <= 1; k++){
				if (dp[pre][j][k] != 0){
					add(dp[cur][j][k], dp[pre][j][k]);
					add(dp[cur][t][k ^ s[i]], dp[pre][j][k]);
					dp[pre][j][k] = 0;
				}
			}
		}
		sum += p[i];
	}
	init(sum);
	for (register int i = 1; i <= sum; i++){
		add(ans, 1ll * dp[lst][i][1] * inv[i] % mod);
	}
	printf("%lld", 1ll * ans * sum % mod);
	return 0;
}
```

---

## 作者：Rainybunny (赞：1)

# $\mathcal{Description}$

&emsp;&emsp;[Link](https://www.luogu.com.cn/problem/P5326).

&emsp;&emsp;有 $n$ 个开关，初始时所有开关的状态为 $0$。给定开关的目标状态 $s_1,s_2,\cdots,s_n$。每次操作中会以正比于 $p_i$ 的概率拨动开关 $i$。求开关达到目标状态的期望操作次数，对 $998244353$ 取模。

&emsp;&emsp;$n\le100$，$\sum p\le5\times10^4$。

# $\mathcal{Solution}$

&emsp;&emsp;不妨令 $p_i$ 为一次操作拨动 $i$ 的概率。设 $F(x)$ 为“$i$ 次操作后开关是目标状态的概率”的 EGF，$G(x)$ 为“$i$ 次操作后回到全零状态的概率”的 EGF。考虑每个开关是否需要被拨动，得到
$$
F(x)=\prod_{i=1}^n\frac{e^{p_ix}+(-1)^{s_i}e^{-p_ix}}{2}
$$
代入 $s_i=0~(i=1,2,\dots,n)$ 即得
$$
G(x)=\prod_{i=1}^n\frac{e^{p_ix}+e^{-p_ix}}{2}
$$
&emsp;&emsp;设 $H(x)$ 为“$i$ 次操作第一次使开关达到目标状态的概率”的 EGF。$F$ 和 $H$ 的区别在于是否接受“多次回到目标状态”，而“回到目标状态”正对应着 $G$ 的意义，它们可以建立等量关系
$$
F=H\cdot G
$$
$$
\Rightarrow~~~~H=F\cdot G^{-1}
$$
故欲求期望 $H'(1)$，仅需求 $(F\cdot G^{-1})'(1)$。

&emsp;&emsp;设 $u_{1-i}=2^n[e^{ix}]F(x)$，$v_{1-i}=2^n[e^{ix}]G(x)$，则有
$$
\begin{aligned}
u_{1-i}&=2^n[e^{ix}]F(x)\\
&=[x^{i}]\prod_{j=1}^n(x^{p_j}+(-1)^{s_j}x^{-p_j})\\
&=[x^{i-1}]\prod_{j=1}^n(1+(-1)^{s_j}x^{-2p_j})\\
&=[x^{1-i}]\prod_{j=1}^n(1+(-1)^{s_j}x^{2p_j})
\end{aligned}
$$
同理地，对于 $v_i$：
$$
\begin{aligned}
v_{1-i}&=2^n[e^{ix}]G(x)\\
&=\cdots\\
&=[x^{1-i}]\prod_{j=1}^n(1+x^{2p_j})
\end{aligned}
$$
在此基础上考虑所求答案：
$$
H(x)=\frac{\sum_{i}2^{-n}u_{1-i}e^{ix}}{\sum_i2^{-n}v_{1-i}e^{ix}}
$$
注意 $e^{ix}=\operatorname{EGF}\langle 1,i,i^2,\cdots\rangle$，将其统一转为 $\operatorname{OGF}\langle 1,i,i^2,\cdots\rangle=\frac{1}{1-ix}$，此时 $H$ 的含义变为概率的 OGF。可以得到
$$
\begin{aligned}
H(x)&=\frac{\sum_i\frac{u_{1-i}}{1-ix}}{\sum_i\frac{v_{1-i}}{1-ix}}\\
&=\frac{(1-x)\sum_i\frac{u_{1-i}}{1-ix}}{(1-x)\sum_i\frac{v_{1-i}}{1-ix}}\\
&=\frac{u_0+\sum_{i\not=1}u_{1-i}\frac{1-x}{1-ix}}{v_0+\sum_{i\not=1}v_{1-i}\frac{1-x}{1-ix}}
\end{aligned}
$$
记 $s(x)=u_0+\sum_{i\not=1}u_{1-i}\frac{1-x}{1-ix}$，$t(x)=v_0+\sum_{i\not=1}v_{1-i}\frac{1-x}{1-ix}$。由于有 $\left(\frac{1-x}{1-ix}\right)'(1)=\frac{1}{1-i}$，可知
$$
s'(1)=\sum_{i\not=1}\frac{u_{1-i}}{1-i}
$$
$$
t'(1)=\sum_{i\not=1}\frac{v_{1-i}}{1-i}
$$
而显然又有 $s(1)=t(1)=u_0=v_0=1$，则对于 $H'(1)$：
$$
\begin{aligned}
H'(1)&=\frac{s'(1)t(1)-s(1)t'(1)}{t^2(1)}\\
&=s'(1)-t'(1)\\
&=\sum_{i\not=1}\frac{u_{1-i}-v_{1-i}}{i-1}\\
&=\sum_{i>0}\frac{v_i-u_i}{i}
\end{aligned}
$$
&emsp;&emsp;故仅需求出 $u_i$ 和 $v_i$，有意义的 $i$ 仅有 $\mathcal O(\sum p)$（其中 $p$ 即输入）个，背包一下，即可 $\mathcal O(nm)$ 求解。

## $\mathcal{Code}$

```cpp
/* Clearink */

#include <cstdio>

#define rep( i, l, r ) for ( int i = l, rpbound##i = r; i <= rpbound##i; ++i )
#define per( i, r, l ) for ( int i = r, rpbound##i = l; i >= rpbound##i; --i )

const int MAXN = 100, MAXS = 5e4, MOD = 998244353;
int n, s[MAXN + 5], p[MAXN + 5], u[MAXS + 5], v[MAXS + 5];

inline int mul( const long long a, const int b ) { return a * b % MOD; }
inline int sub( int a, const int b ) { return ( a -= b ) < 0 ? a + MOD : a; }
inline int add( int a, const int b ) { return ( a += b ) < MOD ? a : a - MOD; }
inline int mpow( int a, int b ) {
	int ret = 1;
	for ( ; b; a = mul( a, a ), b >>= 1 ) ret = mul( ret, b & 1 ? a : 1 );
	return ret;
}

int main() {
	scanf( "%d", &n );
	rep ( i, 1, n ) scanf( "%d", &s[i] );
	int sp = 0;
	rep ( i, 1, n ) scanf( "%d", &p[i] ), sp += p[i];
	u[0] = v[0] = 1;
	rep ( i, 1, n ) per ( j, sp, p[i] ) {
		u[j] = ( s[i] ? sub : add )( u[j], u[j - p[i]] );
		v[j] = add( v[j], v[j - p[i]] );
	}
	// rep ( i, 0, sp ) printf( "%d%c", u[i], i ^ sp ? ' ' : '\n' );
	// rep ( i, 0, sp ) printf( "%d%c", v[i], i ^ sp ? ' ' : '\n' );
	int ans = 0;
	rep ( i, 1, sp ) {
		ans = add( ans, mul( mpow( i << 1, MOD - 2 ), sub( v[i], u[i] ) ) );
	}
	printf( "%d\n", mul( ans, sp ) );
	return 0;
}

```



---

## 作者：Erine (赞：0)

神题。

把题目里给的概率除以一个总和得到真实概率。然后考虑朴素 dp：$f_{S}$ 表示点亮的灯集合为 $S$ 的期望步数。那么有 $f_{\varnothing}=0$，$f_S=1+\sum\limits_{i=1}^nf_{S\oplus \{i\}}p_i$。注意到有后效性，于是上高斯消元可以做到 $\Theta(8^n)$。

不难想到去用集合幂级数刻画，令 $F(x)=\sum\limits_{S}f_Sx^S$，$G(x)=\sum\limits_{i=1}^n p_ix^{\{i\}}$，$H(x)=\sum\limits_{S}x^S$，并定义级数的乘法运算为对称差卷积，即异或卷积。我们可以写出一个大概的形式：

$$F(x)=F(x)G(x)+H(x)$$

**然而这是错的**。原因是，我们并没有保证 $f_{\varnothing}=0$。所以我们需要给 $x^{\varnothing}$ 上边减一个数，不妨设为 $c$。

$$F(x)=F(x)G(x)+H(x)-cx^{\varnothing}$$

异或卷积并不优美，我们直接使用 FWT 变换掉它。定义 $F'(x)$ 为 $F(x)$ FWT 变换后的函数，那么我们有

$$
\begin{aligned}
[x^S]F'(x)&=[x^S]F'(x)[x^S]G'(x)+[x^S]H'(x)-[x^S](cx^{\varnothing})' \\
[x^S]F'(x)(1-[x^S]G'(x))&=[x^S]H'(x)-[x^S](cx^{\varnothing})'
\end{aligned}
$$

对于 $[x^S]H'(x)$，考察 FWT 变换的定义：

$$
\begin{aligned}
[x^S]H'(x)&=\sum_{T}(-1)^{|S\cap T|}[x^T]H(x) \\
&=\sum_{T}(-1)^{|S\cap T|} \\
&=\sum_{i=0}^{|S|}\dbinom{|S|}{i}2^{n-|S|}(-1)^i \\
&=2^{n-|S|}[|S|=0]\\
&=2^{n}[S=\varnothing]\\
\end{aligned}
$$

对于 $[x^S](cx^{\varnothing})$，仍然考察定义，不难得到 $[x^S](cx^{\varnothing})=c$。

于是原式化为

$$[x^S]F'(x)(1-[x^S]G'(x))=2^n[S=\varnothing]-c$$

我们希望得到这个 $c$，因为似乎这样 $F'(x)$ 就唾手可得，从而得到 $[x^S]F(x)$。不妨将 $S=\varnothing$ 带入。

容易发现：

$$[x^{\varnothing}]G'(x)=\sum_{T}p_T=1$$

所以 $2^n-c=0$，$c=2^n$。

这个时候会轻松很多：不妨令 $S\neq \varnothing$，继续化式子，得到

$$
\begin{aligned}
[x^S]F'(x)&=-\dfrac{2^n}{1-[x^S]G'(x)} \\
&=-\dfrac{2^n}{1-\sum\limits_{i\not\in S}p_i+\sum\limits_{i\in S}p_i}\\
&=-\dfrac{2^n}{2\sum\limits_{i\in S}p_i}\\
\end{aligned}
$$

我们需要计算的答案是 $[x^S]F(x)$。于是继续使用 IFWT 展开：

$$
\begin{aligned}
[x^S]F(x)&=\dfrac1{2^n}\sum_{T}(-1)^{|S\cap T|}[x^T]F'(x) \\
&=\dfrac1{2^n}\left([x^{\varnothing}]F'(x)+ \sum_{T\neq \varnothing}(-1)^{|S\cap T|}[x^T]F'(x) \right)\\
\end{aligned}
$$

由于 $0=[x^{\varnothing}]F(x)=\sum\limits_{T}[x^T]F'(x)$，则 $[x^{\varnothing}]F'(x)=-\sum\limits_{T\neq \varnothing}[x^T]F'(x)$。继续代入。

$$
\begin{aligned}
&\dfrac1{2^n}\left([x^{\varnothing}]F'(x)+ \sum_{T\neq \varnothing}(-1)^{|S\cap T|}[x^T]F'(x) \right)\\
=&\dfrac1{2^n}\left(-\sum\limits_{T\neq \varnothing}[x^T]F'(x)+ \sum_{T\neq \varnothing}(-1)^{|S\cap T|}[x^T]F'(x) \right)\\
=&\dfrac1{2^n}\sum_{T\neq \varnothing}((-1)^{|S\cap T|}-1)[x^T]F'(x) \\
=&-\dfrac2{2^n}\sum_{T\neq \varnothing}[|S\cap T|\bmod 2=1][x^T]F'(x)\\
=&-\dfrac2{2^n}\sum_{T\neq \varnothing}[|S\cap T|\bmod 2=1]\left(-\dfrac{2^n}{2\sum\limits_{i\in T}p_i}\right)\\
=&\sum_{T\neq \varnothing}[|S\cap T|\bmod 2=1]\dfrac{1}{\sum\limits_{i\in T}p_i}\\
\end{aligned}
$$

到了这个形式，我们发现这就是一个背包。令 $f_{i,j,k}$ 表示前 $i$ 个，$|S\cap T|$ 的奇偶性是 $j$，$p$ 总和为 $k$ 的方案数。答案即为 $\sum\limits_{k}\dfrac{f_{n,1,k}}k$ 乘上 $\sum p_i$。复杂度 $\Theta(n\sum p_i)$。

---


# [ZJOI2019] 语言

## 题目描述

九条可怜是一个喜欢规律的女孩子。按照规律，第二题应该是一道和数据结构有关的题。

在一个遥远的国度，有 $n$ 个城市。城市之间有 $n - 1$ 条双向道路，这些道路保证了任何两个城市之间都能直接或者间接地到达。

在上古时代，这 $n$ 个城市之间处于战争状态。在高度闭塞的环境中，每个城市都发展出了自己的语言。而在王国统一之后，语言不通给王国的发展带来了极大的阻碍。为了改善这种情况，国王下令设计了 $m$ 种通用语，并进行了 $m$ 次语言统一工作。在第 $i$ 次统一工作中，一名大臣从城市 $s_i$ 出发，沿着最短的路径走到了 $t_i$，教会了沿途所有城市（包括 $s_i, t_i$）使用第 $i$ 个通用语。

一旦有了共通的语言，那么城市之间就可以开展贸易活动了。两个城市 $u_i, v_i$ 之间可以开展贸易活动当且仅当存在一种通用语 $L$ 满足 $u_i$ 到 $v_i$ 最短路上的所有城市（包括 $u_i, v_i$），都会使用 $L$。

为了衡量语言统一工作的效果，国王想让你计算有多少对城市 $(u, v)$（$u < v$），他们之间可以开展贸易活动。

## 说明/提示


#### 样例说明
可以开展贸易活动的城市对为 $(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5)$。

#### 数据范围

|测试点|$n$|$m$|其他约定|
|:-:|:-:|:-:|:-:|
|$1,2$|$\le 300$|$\le 300$|无|
|$3,4$|$\le 5\times 10^3$|$\le 5\times 10^3$|无|
|$5,6$|$\le 10^5$|$\le 10^5$|$y_i=x_i+1$|
|$7\sim 10$|$\le 10^5$|$\le 10^5$|无|

对于 $100\%$ 的数据，有 $1 \le x_i, y_i, s_i, t_i \le n\leq 10 ^ 5$，$1\leq m\leq 10 ^ 5$，$x_i\neq y_i$。

## 样例 #1

### 输入

```
5 3
1 2
1 3
3 4
3 5
3 4
1 4
2 5```

### 输出

```
8```

# 题解

## 作者：Sooke (赞：105)

### 前言

先来扯些真实的废话。

这八成是考场上最可做的题，原因有以下：

> 1. 众所周知，数据范围越不正常的题越毒瘤，本题的数据范围就很正常。
> 
> 2. 往年省选包括今年 round 1 最简单的题中往往都有线段树，本题感性上就离不开线段树。
>
> 3. 九条在出完 2、3、1 的开题顺序之后，喜欢出 2、1、3 的开题顺序。

遗憾的是，由于 round 1 的爆炸，考场上心态有点崩，智商骤降为 0，导致没做出此题。

可能我永远属于入场思维受阻、出场茅塞顿开的那种人吧。

---

### 解题思路

不难想到各种 $O(n \log^3 n)$ 的乱搞做法，比如链剖套扫描线
，~~听说会被九条定向卡~~。

实际上有一种巧妙的 $O(n \log n)$ 清真做法。若城市 $u,\,v$ 能开展贸易，我们称 “ $u$ 可以到达 $v$ ”。

首先容易发现以下性质：

> $u$ 能到达的所有点恰好构成一棵生成树（即一个连通块）。

考虑这个生成树是怎么来的？可以进一步得出：

> 如果路径 $s \to t$ 包含点 $u$ ，$s,\,t$ 则是 $u$ 的两个极远点。
>
> $u$ 的生成树则是连通所有 $u$ 的极远点的最小生成树。

举个例子，假设有三条路径分别是 $1 \to 3$ ，$2 \to 6$ ，$7 \to 8$ 。

![](https://i.loli.net/2019/05/02/5cca3428c824e.png
)

锁定 $4$ 号点。路径 $1 \to 3$ 不经过它，对它没有任何贡献。其他路径则经过 $4$ 号点，表明其有 $4$ 个极远点：$2,\,6,\,7,\,8$ 。故生成树由 $2,\,4,\,5,\,6,\,7,\,8$ 构成，即 $4$ 号点能到达其他 $5$ 个不同的点。

于是，我们需要事先思考子问题：给定树上若干的点，如何求最小生成树大小？

---

这应该是个经典问题。可能要用到一点建虚树的思想。

为了方便，我们硬点存在极远点 $1$ ，最后再计算其影响。

我们给这些点按照 $\mathrm{dfs}$ 序排序，然后一个一个地加进去。假设当前加入 $u$ 号点，之前加入的点构成点集 $S$ ，$S$ 的最小生成树是 $T$。显然，为了使 $u$ 和 $T$ 连通，只需要找到 $T$ 中离 $u$ 最近的点连起来就好了，这“最近的点”正是 $S$ 中的某个点与 $u$ 的 $\mathrm{lca}$ 。如果你对 $\mathrm{dfs}$ 序有较好的感觉，其实所谓 $S$ 中的某个点，就是上一个加进去的点 $v$ ！所以 $u$ 的贡献是 $\mathrm{dep}_u - \mathrm{dep}_{\mathrm{lca}(u,\,v)}$ 。别忘了硬点了 $1$ 号点，最后还要减 $\mathrm{dep}_{\text{所有点的}\ \mathrm{lca}}$ 。

上面那段可能有点绕，强烈建议画个图感受一下！

暴力加点似乎不容易被利用，此时最擅长分治的线段树终于重磅登场了。

仍然是以 $\mathrm{dfs}$ 序为下标，线段树的叶子结点控制原树上每个点选或不选，每个结点表示了硬点 $1$ 后一段区间的点集的最小生成树大小，并存下每个点集中下标最小和最大的点。类似地，$\mathrm{pushup}$ 时要减去 $\mathrm{dep}_{\mathrm{lca}(u,\,v)}$ 。此时的 $u$ 当然是左孩子已选下标最大的，$v$ 当然是右孩子已选下标最小的。查询的话只要用根结点的答案减去 $\mathrm{dep}_{\text{所有点的}\ \mathrm{lca}}$ 即可。

白白套一个线段树不是多 $\log$ 吗？别急，正解已经浮出水面了。

---

想象每个结点都有一棵线段树。注意到有一条路径 $s \to t$ ，我们会给该路径上的每棵线段树都选上 $s,\,t$ 两点。按照套路，求出 $\mathrm{lca} = \mathrm{lca}(u,\,v)$ ，等同于 $s \to \mathrm{lca},\,t\to \mathrm{lca}$ 两条链上执行线段树修改。仍然是套路，链上修改可以转换成树上差分打标记，$s,\,t,\,\mathrm{lca},\,\mathrm{fa}[\mathrm{lca}]$ 分别打上 $1,\,1,\,-1,\,-1$ 。

慢着……线段树打标记是可以，但每个结点要把自己的信息继承给父亲，这怎么做？

#### 动态开点 + 线段树合并！

至此，[[ZJOI2019]语言](https://www.luogu.org/problemnew/show/P5327) 的大致做法讲完了。$n$ 次线段树合并是 $O(n \log n)$ 的，而 $n$ 次修改要求 $n \log n$ 次 $\mathrm{lca}$ ，如果树剖或倍增，复杂度是 $O(n \log^2 n)$ ，如果使用欧拉序 $\mathrm{st}$ 表，复杂度是优美的 $O(n \log n)$ 。

---

### 代码实现

刚才求的 $(u,\,v)$ 没有强制 $u < v$ ，答案要除以 $2$ 。

```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <algorithm>

const int N = 200005, V = 6400005, L = 18;

int n, m, tms, o[N], ft[N], dep[N], dfn[N], st[L][N];
std::vector<int> to[N], del[N];
long long ans;

inline int getLca(int u, int v);

struct SegmentTree {
    int tot, c[V], f[V], s[V], t[V], ls[V], rs[V], rt[N];

    inline void pushUp(int u) {
        f[u] = f[ls[u]] + f[rs[u]] - dep[getLca(t[ls[u]], s[rs[u]])];
        s[u] = s[ls[u]] ? s[ls[u]] : s[rs[u]];
        t[u] = t[rs[u]] ? t[rs[u]] : t[ls[u]];
    }
    inline int query(int u) { return f[u] - dep[getLca(s[u], t[u])]; }
    void modify(int &u, int l, int r, int p, int x) {
        if (!u) { u = ++tot; }
        if (l == r) {
            c[u] += x; f[u] = c[u] ? dep[p] : 0; s[u] = t[u] = c[u] ? p : 0;
            return;
        }
        int mid = l + r >> 1;
        if (dfn[p] <= mid) { modify(ls[u], l, mid, p, x); }
        else { modify(rs[u], mid + 1, r, p, x); }
        pushUp(u);
    }
    void merge(int &u, int v, int l, int r) {
        if (!u || !v) { u |= v; return; }
        if (l == r) {
            c[u] += c[v]; f[u] |= f[v]; s[u] |= s[v]; t[u] |= t[v];
            return;
        }
        int mid = l + r >> 1;
        merge(ls[u], ls[v], l, mid); merge(rs[u], rs[v], mid + 1, r); pushUp(u);
    }
} smt;

void build() {
    for (int i = 1; i <= tms; i++) { o[i] = log(i) / log(2) + 1e-7; }
    for (int i = 1; i <= o[tms]; i++) {
        for (int j = 1, u, v; j + (1 << i) - 1 <= tms; j++) {
            u = st[i - 1][j]; v = st[i - 1][j + (1 << i - 1)];
            st[i][j] = dep[u] < dep[v] ? u : v;
        }
    }
}
inline int getLca(int u, int v) {
    if (!u || !v) { return 0; } u = dfn[u]; v = dfn[v];
    if (u > v) { std::swap(u, v); }
    int d = o[v - u + 1]; u = st[d][u]; v = st[d][v - (1 << d) + 1];
    return dep[u] < dep[v] ? u : v;
}

void dfs(int u, int fa) {
    ft[u] = fa; dep[u] = dep[fa] + 1; st[0][++tms] = u; dfn[u] = tms;
    for (auto v : to[u]) { if (v != fa) { dfs(v, u); st[0][++tms] = u; } }
}
void solve(int u) {
    for (auto v : to[u]) { if (v != ft[u]) { solve(v); } }
    for (auto v : del[u]) { smt.modify(smt.rt[u], 1, tms, v, -1); }
    ans += smt.query(smt.rt[u]); smt.merge(smt.rt[ft[u]], smt.rt[u], 1, tms);
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 2, u, v; i <= n; i++) {
        scanf("%d%d", &u, &v);
        to[u].push_back(v); to[v].push_back(u);
    }
    dfs(1, 0); build();
    for (int u, v, lca; m; m--) {
        scanf("%d%d", &u, &v); lca = getLca(u, v);
        smt.modify(smt.rt[u], 1, tms, u, 1); smt.modify(smt.rt[u], 1, tms, v, 1);
        smt.modify(smt.rt[v], 1, tms, u, 1); smt.modify(smt.rt[v], 1, tms, v, 1);
        del[lca].push_back(u); del[ft[lca]].push_back(u);
        del[lca].push_back(v); del[ft[lca]].push_back(v);
    }
    solve(1); printf("%lld\n", ans >> 1);
    return 0;
}
```

---

### 尾注

看完后您还可真别说这题简单，考场上这么多算法的选择，鬼知道偏偏碰上了这一种呢？

---

## 作者：Thinking (赞：18)

对于每个结点$u$，考虑维护它能到达的结点（不包括$u$本身）集合$S_u$，那么答案就是$\frac{\sum^n_{i=1}{|S_u|}}{2}$。

然后考虑这个$S_u$怎么搞。~~暴力~~

先大力树剖一遍，那么$(u,v)$的路径就变成了不超过$log_2n$个区间，如果把每一个结点的$S$都用线段树维护的话，就可以通过把$(u,v)$路径上所有点跑$log_2n$个区间覆盖就可以做到$O(n^2log^2n)$~~说白了就是个暴力~~

等等，对一条路径上的所有点做相同的修改？

### 树上差分+线段树合并！

于是就得到了一个$O(nlog^2n)$的方法，足以通过本题。

码的时候注意一些细节：

1. 不包含$u$的集合比较难维护，我们先钦定包含$u$，统计的时候再减掉。
2. 因为要差分，所以区间覆盖要改成区间加，不过由于合并完成后的标记肯定都是正的，所以只要分有没有标记即可
3. 这个写法严格来讲是点差分，但是因为我们只关心有没有标记，边差分也是正确的，常数还小一点
4. 我们可以把每个结点要做的修改存下来，每次先合并完再修改，尽量节约空间

上代码：

```cpp
#include<cstdio>
#include<vector>
using namespace std;
const int N=100050;
char rB[1<<21],*S,*T;
inline char gc(){return S==T&&(T=(S=rB)+fread(rB,1,1<<21,stdin),S==T)?EOF:*S++;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
struct seg{
    int x,y;
    seg(int x,int y):x(x),y(y){}
};
struct query{
	int x,y;
	short k;
	query(int x,int y,short k):x(x),y(y),k(k){}
};
int G[N],to[N<<1],nxt[N<<1],cnt1=0,f[N],dep[N],sz[N],son[N],id[N],top[N],dfsc=0,rt[N],lc[N<<8],rc[N<<8],addv[N<<8],val[N<<8],cnt2=0,n;
long long ans=0;
vector<seg> a;
vector<query> w[N];
inline void Swap(int &a,int &b){int t=a;a=b;b=t;}
inline void adde(int u,int v){
    to[++cnt1]=v;nxt[cnt1]=G[u];G[u]=cnt1;
    to[++cnt1]=u;nxt[cnt1]=G[v];G[v]=cnt1;
}
inline void pushup(int o,int L,int R){
    val[o]=addv[o]>0?R-L+1:val[lc[o]]+val[rc[o]];  //维护权值，只关心有没有标记
}
void add(int &o,int L,int R,int x,int y,short k){  //区间加
    if(!o)o=++cnt2;
    if(x<=L&&y>=R)addv[o]+=k;
    else{
        int M=L+R>>1;
        if(x<=M)add(lc[o],L,M,x,y,k);
        if(y>M)add(rc[o],M+1,R,x,y,k);
    }
    pushup(o,L,R);
}
int merge(int u,int v,int L,int R){  //线段树合并
    if(!u||!v)return u|v;
    addv[u]+=addv[v];
    if(L<R){
        int M=L+R>>1;
        lc[u]=merge(lc[u],lc[v],L,M);
        rc[u]=merge(rc[u],rc[v],M+1,R);
    }
    pushup(u,L,R);
    return u;
}
void dfs1(int u,int fa){
    int i,v,maxn=0;
    dep[u]=dep[f[u]=fa]+1;
    sz[u]=1;
    for(i=G[u];i;i=nxt[i])if((v=to[i])!=fa){
        dfs1(v,u);
        sz[u]+=sz[v];
        if(sz[v]>maxn){
            son[u]=v;
            maxn=sz[v];
        }
    }
}
void dfs2(int u,int topf){
    int i,v;
    id[u]=++dfsc;
    top[u]=topf;
    w[u].push_back(query(id[u],id[u],1));  //先给u打标记，钦定它必须选
    if(f[u])w[f[u]].push_back(query(id[u],id[u],-1));  //这里有个坑，树上差分的单点修改记得在父结点减回去
    if(!son[u])return;
    dfs2(son[u],topf);
    for(i=G[u];i;i=nxt[i])if((v=to[i])!=f[u]&&v!=son[u])dfs2(v,v);
}
inline int lca(int u,int v){
    a.clear();
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]])Swap(u,v);
        a.push_back(seg(id[top[u]],id[u]));  //把路径分离成区间
        u=f[top[u]];
    }
    if(dep[u]>dep[v])Swap(u,v);
    a.push_back(seg(id[u],id[v]));
    return u;
}
//树剖部分
void solve(int u){
    int i,v;
    for(i=G[u];i;i=nxt[i])if((v=to[i])!=f[u]){
        solve(v);
        rt[u]=merge(rt[u],rt[v],1,n);
    }  //合并
    for(i=0;i<w[u].size();++i)add(rt[u],1,n,w[u][i].x,w[u][i].y,w[u][i].k);  //修改
    ans+=val[rt[u]]-1;  //由于我们钦定了u必须选，统计时要减掉
}
int main(){
    int m,i,u,v,k;
    n=rd();m=rd();
    for(i=1;i<n;++i){
        u=rd();v=rd();
        adde(u,v);
    }
    dfs1(1,0);
    dfs2(1,1);
    while(m--){
        u=rd();v=rd();
        k=lca(u,v);
        for(i=0;i<a.size();++i){
            w[u].push_back(query(a[i].x,a[i].y,1));
            w[v].push_back(query(a[i].x,a[i].y,1));
            if(f[k])w[f[k]].push_back(query(a[i].x,a[i].y,-2));
        }
    }
    solve(1);
    printf("%lld",ans>>1);
    return 0;
}
```


---

## 作者：critnos (赞：18)

竟然没有轻重链剖分+序列差分扫描线+虚树的做法。

枚举每个点能到达的点。发现就是包含这个点所有的 $s\rightarrow t$ 的并的点数再减去自己。

因为这些链都经过同一点，那么他们的并自然就是一棵连通子图（树）了。

先考虑如何求出包含该点的链。我们利用轻重链剖分将链划为 $O(\log n)$ 个区间，然后变为在序列上一个区间中加入该链的信息。使用差分，直接扫描线。这个是 雨天的尾巴  里面的 tirck。

所以现在的任务是：

维护点集，支持插入、删除点（就是链的两端点 $s,t$），求集合中点形成的极小连通子树的点数 $-1$。

有趣的是，点数 $-1$ 就是边数。那么这个就完全是 [SDOI2015]寻宝游戏 了。

我们将点按照 dfn 排序，看作一个环。答案就是所有相邻点之间的距离之和的一半。

这个可以用 set $O(\log n)$ 轻松完成。不过插入的点可能有重复，所以还需要一个 multiset 辅助。

轻重链剖分共造成了 $O(n\log n)$ 次上述操作，所以时间复杂度为 $O(n\log ^2  n)$。

```cpp
#include<bits/stdc++.h>
#define x first
#define y second
#define ll long long
using namespace std;
struct node
{
	int x,nxt;
}a[200005];
int h[100005];
int cnt;
int size[100005],f[100005],d[100005],son[100005];
int top[100005],dfn[100005];
int dcnt;
vector<pair<int,bool> > q[100005];
pair<int,int> c[100005];
void add(int x,int y)
{
	a[++cnt].x=y;
	a[cnt].nxt=h[x];
	h[x]=cnt;
}
void dfs1(int x,int deep,int fa)
{
	size[x]=1,f[x]=fa,d[x]=deep;
	for(int i=h[x],y;i;i=a[i].nxt)
		if((y=a[i].x)!=fa)
		{
			dfs1(y,deep+1,x);
			size[x]+=size[y];
			if(size[son[x]]<=size[y])
				son[x]=y;
		}
}
void dfs2(int x,int t)
{
	top[x]=t;
	dfn[x]=++dcnt;
	if(!son[x]) return;
	dfs2(son[x],t);
	for(int i=h[x],y;i;i=a[i].nxt)
	{
		y=a[i].x;
		if(y==f[x]||y==son[x]) continue;
		dfs2(y,y);
	}
}
void add_ar(int l,int r,int x)
{
	q[l].push_back({x,1});
	q[r+1].push_back({x,0});
}
void add(int x,int y,int id)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]]) swap(x,y);
		add_ar(dfn[top[x]],dfn[x],id);	
		x=f[top[x]];
	}
	if(d[x]>d[y]) swap(x,y);
	add_ar(dfn[x],dfn[y],id);
}
int asklca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]]) swap(x,y);
		x=f[top[x]];
		//cout<<x<<endl;
	}
	return d[x]<d[y]?x:y;
}
int asklen(int x,int y)
{
	return (!x||!y)?0:d[x]+d[y]-d[asklca(x,y)]*2;
}
struct node_set
{
	set<pair<int,int> > t;
	multiset<int> f;
	int sum;
	node_set()
	{
		t.insert({-2e9,0});
		t.insert({2e9,0});
	}
	int val(int x)
	{
		int w1=(--t.lower_bound({dfn[x],x}))->second,w2=t.upper_bound({dfn[x],x})->second;
		return asklen(w1,x)+asklen(w2,x)-asklen(w1,w2);
	}
	void insert(int x)
	{
		//cout<<"insert "<<x<<endl;
		if(f.find(x)==f.end())
			sum+=val(x),t.insert({dfn[x],x});
		f.insert(x);
	}
	void erase(int x)
	{
		//cout<<"erase "<<x<<endl;
		f.erase(f.find(x));
		if(f.find(x)==f.end())
			sum-=val(x),t.erase({dfn[x],x});
	}
	int ask()
	{
		return (sum+asklen((++t.begin())->second,(--(--t.end()))->second))/2;
	}
}t;
int main()
{
	int n,m,x,y,i,j;
	ll sum=0;
	scanf("%d%d",&n,&m);
	for(i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs1(1,1,0),dfs2(1,1);
	for(i=1;i<=m;i++)
	{
		scanf("%d%d",&c[i].x,&c[i].y);
		add(c[i].x,c[i].y,i);
	}
	for(i=1;i<=n;i++)
	{
		for(j=0;j<q[i].size();j++)
			if(q[i][j].second)
				t.insert(c[q[i][j].first].x),
				t.insert(c[q[i][j].first].y);
			else
				t.erase(c[q[i][j].first].x),
				t.erase(c[q[i][j].first].y);
		sum+=t.ask();
	}
	cout<<sum/2;
}
```


---

## 作者：tommymio (赞：17)

**题意简述**：求对于树上每个点 $x$ ，包含它的链的并集的大小之和，也可描述成，求对于树上每个点 $x$ ，它能够到达的点的个数之和。

不难发现，对于点 $x$ 而言，通过树上的路径，它能够到达的点一定构成一棵树。并且这棵树上一定含有包含 $x$ 点的 $s_i,t_i$ 。那么也就是说，链并大小就是包含一些关键点 $s_i,t_i$ 的极小连通子树 $T$ 的边数。

问题转化到这里，有一个非常经典的结论，包含一些关键点 $a_1,a_2,a_3...a_n$ 的极小连通子树的边数为 $|T_e|=\sum_i dep_i-\sum_{i=2}^n dep_{\text{lca}(a_i,a_{i-1})}-dep_{\text{lca}(a_1,a_2...a_n)}$，其中 $a_1,a_2,a_3..a_n$ 按 $\texttt{dfs}$ 序从小到大排列。

那么对于每一个点 $x$，找出包含 $x$ 的所有路径，并且根据上式求出极小连通子树的边数即可，但是这样做，处理 $x$ 点被哪些路径覆盖就是 $O(mn \log^2 n)$ 的，难以承受。

考虑如何快速统计所有对 $x$ 有影响的路径的贡献，可以想到树上差分，对于 $s_i,t_i$ 进行 $+1$，对于 $\text{lca}(s_i,t_i)$ 进行 $-1$， 对于 $fa_{\text{lca}(s_i,t_i)}$ 进行 $-1$。对于每一个点 $x$，我们用桶来存储 $m$ 条路径对第 $x$ 个点的覆盖情况。这么统计点 $x$ 被哪些路径覆盖就是 $O(nm)$ 的。

观察一下，我们发现 $\text{dfs}$ 时将儿子的桶与父亲的桶合并，很多位置是空的，没必要统计。并且每次都要重新暴力计算一遍最小连通子树 $T$ 的边数，显然不是最优的。

不妨把桶换成线段树。点 $x$ 的线段树中，区间 $[l,r]$ 表示被选中的关键点 $\text{dfs}$ 序$\in[l,r]$ 时，极小连通子树 $T$ 的边数。再维护两个量 $mx,mn$ 表示当前区间 $[l,r]$ 内被选中的关键点 $\texttt{dfs}$ 序的最大值与最小值，$sum$ 表示当前区间中被选中的关键点构成的极小连通子树 $T$ 的边数，在叶子节点上存储一个 $cnt$ 统计 $[l,l]$ 的贡献，相当于之前的桶。稍微维护一下，总时间复杂度为 $O(mn \log n)$。

这样的时间复杂度仍然可以优化。想一想，根据差分，父亲节点的线段树，一定与儿子节点线段树的信息是重合的，和之前的桶向上合并一样，我们将儿子节点和父亲节点的线段树合并，使用均摊时间复杂度为 $O(n \log n)$ 的线段树合并即可。

若使用倍增/树剖 $\text{LCA}$，总时间复杂度为 $O(n \log^2 n+m \log n)$；使用 $O(n\log n)-O(1)$ 的 $LCA$ ，总时间复杂度为 $O(n \log n+m \log n)$。

**Show the Code**

```cpp
#include<cstdio>
typedef long long ll;
/*------------------------Normal I/O&handmade STL--------------------------*/ 
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f; 
} 
inline void swap(int &x,int &y) {int tmp=y;y=x;x=tmp;} 
/*------------------------Tree--------------------------*/ 
int cnt=0,num=0,tot=0;
int dep[100005],dfn[100005],rev[100005];
int h[100005],to[200005],ver[200005],f[100005][25];
inline void AddEdge(int x,int y) {to[++cnt]=y;ver[cnt]=h[x];h[x]=cnt;}
inline void prework(int x) {
	int fa=f[x][0];dfn[x]=++num;rev[num]=x;
	for(register int i=1;i<=20;++i) f[x][i]=f[f[x][i-1]][i-1];
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i];if(y==fa) continue;
		dep[y]=dep[x]+1;f[y][0]=x;prework(y); 
	}
}
inline int LCA(int x,int y) {
	if(!x||!y) return 0; 
	if(dep[x]>dep[y]) swap(x,y);//dep[x]<=dep[y]
	for(register int i=20;i>=0;--i) if(dep[x]<=dep[f[y][i]]) y=f[y][i];
	if(x==y) return x;
	for(register int i=20;i>=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
/*------------------------SegmentTree--------------------------*/
struct Segment {int mn,mx,cnt;ll sum;}t[4000005];
int lson[4000005],rson[4000005],rt[100005];
inline void pushup(int p) {
	t[p].mn=t[lson[p]].mn? t[lson[p]].mn:t[rson[p]].mn;
	t[p].mx=t[rson[p]].mx? t[rson[p]].mx:t[lson[p]].mx;
	t[p].sum=t[lson[p]].sum+t[rson[p]].sum-dep[LCA(rev[t[lson[p]].mx],rev[t[rson[p]].mn])];//???
}
inline void modify_add(int &p,int l,int r,int dfnId,int val) {
	if(!p) p=++tot;
	if(l==r) {
		t[p].cnt+=val;
		t[p].mx=t[p].mn=(t[p].cnt>0? dfnId:0);
		t[p].sum=(t[p].cnt>0? dep[rev[dfnId]]:0);
		return;
	}
	int mid=l+r>>1;
	if(dfnId<=mid) modify_add(lson[p],l,mid,dfnId,val);
	else modify_add(rson[p],mid+1,r,dfnId,val);
	pushup(p);
}
inline int merge(int x,int y,int l,int r) {
	if(!x||!y) return x|y;
	if(l==r) {t[x].cnt+=t[y].cnt;t[x].mx=t[x].mn=(t[x].cnt>0? l:0);t[x].sum=(t[x].cnt>0? dep[rev[l]]:0);return x;}
	int mid=l+r>>1;
	lson[x]=merge(lson[x],lson[y],l,mid);
	rson[x]=merge(rson[x],rson[y],mid+1,r);
	pushup(x); return x;
}
/*------------------------Solution--------------------------*/
ll ans=0;
inline void PathAdd(int x,int y,int dfnId) {
	int z=LCA(x,y),fa=f[z][0];
	modify_add(rt[x],1,num,dfn[dfnId],1);
	modify_add(rt[y],1,num,dfn[dfnId],1);
	modify_add(rt[z],1,num,dfn[dfnId],-1);
	if(fa) modify_add(rt[fa],1,num,dfn[dfnId],-1);
}
inline void solve(int x) {
	int fa=f[x][0];
	for(register int i=h[x];i;i=ver[i]) {int y=to[i];if(y==fa) continue;solve(y);}
	ans+=t[rt[x]].sum-dep[LCA(rev[t[rt[x]].mn],rev[t[rt[x]].mx])]; 
	if(fa) rt[fa]=merge(rt[fa],rt[x],1,num);
}
int main() {
	int n=read(),m=read();
	for(register int i=1;i<n;++i) {int x=read(),y=read();AddEdge(x,y);AddEdge(y,x);} dep[1]=1;prework(1);
	for(register int i=1;i<=m;++i) {int s=read(),t=read();PathAdd(s,t,s);PathAdd(s,t,t);}
	solve(1); printf("%lld\n",ans>>1);
	return 0;
}
```


---

## 作者：大头 (赞：13)

首先考虑给定一些点，计算这些点形成的虚树还原到原树包含的边数。显然题目可以转化到这个问题上。

我们考虑按照dfs序从小到大排序，假设排序完的点集为$A_1,A_2,...,A_n$。

则树上的边数=$(dis(A_1,A_2)+dis(A_2,A_3)+...+dis(a_{n-1},a_n)+dis(a_n,a_1))/2$

因为我们按照$A_1,A_2,...,A_n$遍历的时候每条边都会恰好净多两次所以他是正确的。

这样我们就可以使用线段树来维护对于这个点来说的虚树节点按照dfn序排序的结果，同时也可以非常方便的合并

在采用$O(nlog)-O(1)$LCA的情况下可以做到$O(nlog)$

---

## 作者：Katyusha_01 (赞：12)

无数篇题解提到了一个 $O(m\log^3 n)$ 的做法：将每一条链使用重链剖分划分成 $O(\log n)$ 段区间，然后扫描线。此时如果使用 **树剖+线段树** 维护的话复杂度高达 $O(m\log^3 n)$ 据称是无法通过的。但是如果使用 **LCT** 复杂度就可以直接降至 $O(m\log^2 n)$，可以通过。

代码如下，常数略大，没有卡常。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef struct{
	int fa,s[2];
	bool rev;
	int mn,mncnt,x;
	int tag;
}Tree;
Tree t[100011];
int cnt;
void pushup(int p)
{
	t[p].mn = min({t[t[p].s[0]].mn,t[p].x,t[t[p].s[1]].mn});
	t[p].mncnt = (t[t[p].s[0]].mn == t[p].mn) * t[t[p].s[0]].mncnt + (t[p].x == t[p].mn) + (t[t[p].s[1]].mn == t[p].mn) * t[t[p].s[1]].mncnt;
}
void Rev(int p)
{
	swap(t[p].s[0],t[p].s[1]),t[p].rev ^= 1;
}
void add(int p,int x)
{
	t[p].x += x,t[p].mn += x,t[p].tag += x;
}
void pushdown(int p)
{
	if(t[p].rev) Rev(t[p].s[0]),Rev(t[p].s[1]),t[p].rev ^= 1;
	add(t[p].s[0],t[p].tag),add(t[p].s[1],t[p].tag),t[p].tag = 0; 
}
bool isroot(int x)
{
	return t[t[x].fa].s[0] != x && t[t[x].fa].s[1] != x;
}
void rotate(int x)
{
	int y = t[x].fa,z = t[y].fa;
	if(!isroot(y))
		t[z].s[t[z].s[1] == y] = x;
	t[x].fa = z;
	int op = (x == t[y].s[1]);
	t[t[y].s[op] = t[x].s[op ^ 1]].fa = y;
	t[t[x].s[op ^ 1] = y].fa = x;
	pushup(y),pushup(x);
}
int st[100011];
void splay(int x)
{
	int top = 0,r = x;
	st[++top] = r;
	while(!isroot(r)) st[++top] = r = t[r].fa;
	while(top) pushdown(st[top--]);
	while(!isroot(x))
	{
		int y = t[x].fa,z = t[y].fa;
		if(!isroot(y))
		{
			if((t[y].s[1] == x) ^ (t[z].s[1] == y)) rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
}
void access(int x)
{
	int r = x;
	for(int y = 0;x;y = x,x = t[x].fa)
	{
		splay(x); 
		t[x].s[1] = y;
		pushup(x);
	}
	splay(r);
}
void makeroot(int x)
{
	access(x),Rev(x);
}
void split(int x,int y)
{
	makeroot(x),access(y);
}
void mdf(int x,int y,int w)
{
	split(x,y);
	cnt -= (t[y].mn == 0) * t[y].mncnt;
	add(y,w);
	cnt += (t[y].mn == 0) * t[y].mncnt;
}
int n,m;
vector<int> v[100011];
int fa[100011],dep[100011],siz[100011],bgs[100011],upt[100011],dfn[100011],idx;
void DFS1(int p,int f)
{
	dep[p] = dep[fa[p] = f] + (siz[p] = 1);
	for(auto i:v[p]) if(i != f)
	{
		DFS1(i,p);
		siz[p] += siz[i];
		if(siz[i] > siz[bgs[p]])
			bgs[p] = i;
	}
}
void DFS2(int p,int ut)
{
	upt[p] = ut,dfn[p] = ++idx;
	if(!bgs[p]) return;
	DFS2(bgs[p],ut);
	for(auto i:v[p]) if(!dfn[i])
		DFS2(i,i);
}
vector<pair<int,int> > pick(int x,int y)
{
	vector<pair<int,int> > res;
	while(upt[x] != upt[y])
	{
		if(dep[upt[x]] > dep[upt[y]])
			res.push_back({dfn[upt[x]],dfn[x]}),x = fa[upt[x]];
		else
			res.push_back({dfn[upt[y]],dfn[y]}),y = fa[upt[y]];
	}
	if(dfn[x] > dfn[y]) swap(x,y);
	res.push_back({dfn[x],dfn[y]});
	return res;
}
vector<pair<pair<int,int>,int> > dl[100011];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i < n;i++)
	{
		int x,y;
		cin >> x >> y;
		v[x].push_back(y),v[y].push_back(x);
	}
	DFS1(1,0);
	DFS2(1,1);
	for(int i = 1;i <= n;i++)
		t[i].fa = fa[i],t[i].mncnt = 1;
	cnt = n;
	for(int i = 1;i <= m;i++)
	{
		int x,y;
		cin >> x >> y;
		vector<pair<int,int> > ar = pick(x,y);
		for(auto o:ar)
			dl[o.first].push_back({{x,y},1}),dl[o.second + 1].push_back({{x,y},-1});
	}
	long long ans = 0;
	for(int i = 1;i <= n;i++)
	{
		for(auto x:dl[i])
			mdf(x.first.first,x.first.second,x.second);
		ans += max((n - cnt) - 1,0);
	}
	cout << ans / 2;
	return 0;
}
```

---

## 作者：do_while_true (赞：12)

简单做法：树剖一下，每条路径划分成了在 dfn 上 $\log$ 段区间。

在 $dfn\times dfn$ 平面上，$(x,y)$ 的值代表 $dfn$ 为 $x$ 的点是否能到达 $dfn$ 为 $y$ 的点。

那么给定一条路径，这 $\log$ 段两两的笛卡尔积都会覆盖上 $1$，也就相当于 $\log^2$ 个矩形覆盖，最后要查询每一行非零位置个数，扫描线一下复杂度就是 $\mathcal{O}(n\log^3n)$．

稍微卡卡常数甚至不需要怎么卡就过了。

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#define pb emplace_back
#define mp std::make_pair
#define fi first
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n';
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n';
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x, T2& ...y){ read(x); read(y...); }
const int N=100010;
int n,m,c[N];
//hld 
int siz[N],dfn[N],top[N],dep[N],fa[N],dft,son[N];
vi eg[N];
void dfs1(int x,int f){
	fa[x]=f;siz[x]=1;dep[x]=dep[f]+1;
	for(auto v:eg[x])if(v!=f){
		dfs1(v,x);
		siz[x]+=siz[v];
		if(siz[v]>siz[son[x]])son[x]=v;
	}
}
void dfs2(int x,int t){
	top[x]=t;dfn[x]=++dft;
	if(son[x])dfs2(son[x],t);
	for(auto v:eg[x])if(v!=fa[x]&&v!=son[x]){
		dfs2(v,v);
	}
}
//Tree
int lct;
struct Line{
	int l,r,h,v;
	bool operator<(const Line &y)const{
		return h<y.h;
	}
}li[N*300];
inline void PushLine(int l,int r,int h,int v){
	c[l]++;c[r+1]--;
	li[++lct]={l,r,h,v};
}
int trct,mn[N<<1],mct[N<<1],tag[N<<1],ls[N<<1],rs[N<<1];
int build(int l,int r){
	int x=++trct,mid=(l+r)>>1;mn[x]=0;mct[x]=r-l+1;
	if(l==r)return x;
	ls[x]=build(l,mid);rs[x]=build(mid+1,r);
	return x;
}
inline void pushup(int x){
	mn[x]=min(mn[ls[x]],mn[rs[x]]);mct[x]=0;
	if(mn[x]==mn[ls[x]])mct[x]+=mct[ls[x]];
	if(mn[x]==mn[rs[x]])mct[x]+=mct[rs[x]]; 
}
inline void upd(int x,int v){
	mn[x]+=v;tag[x]+=v;
}
inline void pushdown(int x){
	if(tag[x]){
		upd(ls[x],tag[x]);
		upd(rs[x],tag[x]);
		tag[x]=0;
	}
}
void modify(int x,int tl,int tr,int l,int r,int v){
	if(tl>=l&&tr<=r){
		upd(x,v);
		return ;
	}
	int mid=(tl+tr)>>1;
	pushdown(x);
	if(mid>=l)modify(ls[x],tl,mid,l,r,v);
	if(mid<r)modify(rs[x],mid+1,tr,l,r,v);
	pushup(x); 
}
int query(int x,int tl,int tr,int l,int r){
	if(tl>=l&&tr<=r)return !mn[x]?mct[x]:0;
	int mid=(tl+tr)>>1,s=0;
	pushdown(x);
	if(mid>=l)s+=query(ls[x],tl,mid,l,r);
	if(mid<r)s+=query(rs[x],mid+1,tr,l,r);
	pushup(x);
	return s;
}
//
void qwdasd(int x,int y){
	vpii a;
	while(top[x]!=top[y]){
		if(dep[top[x]]>dep[top[y]]){
			a.pb(mp(dfn[top[x]],dfn[x]));
			x=fa[top[x]];
		}
		else{
			a.pb(mp(dfn[top[y]],dfn[y]));
			y=fa[top[y]];
		}
	}
	if(dep[x]<=dep[y])a.pb(mp(dfn[x],dfn[y]));
	else a.pb(mp(dfn[y],dfn[x]));
	int len=a.size();
	for(int i=0;i<len;i++)
		for(int j=0;j<len;j++){
			if(a[i].fi>=a[j].se)continue;
			PushLine(a[i].fi,a[i].se,a[j].fi,1);
			if(a[j].se!=n)PushLine(a[i].fi,a[i].se,a[j].se+1,-1);
		}
}
signed main(){
	read(n,m);
	for(int i=1,u,v;i<n;i++){
		read(u,v);
		eg[u].pb(v);eg[v].pb(u);
	}
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1;i<=m;i++){
		int x,y;read(x,y);
		qwdasd(x,y);
	}
	sort(li+1,li+lct+1);
	build(1,n);
	int p=1;
	ll ans=0;
	for(int i=1;i<=n;i++){
		while(p<=lct&&li[p].h==i){
			modify(1,1,n,li[p].l,li[p].r,li[p].v);
			++p;
		}
		if(!mn[1]&&i>1)ans+=query(1,1,n,1,i-1);
	}
	cout << 1ll*n*(n-1)/2-ans << '\n';
    #ifdef do_while_true
		cerr<<'\n'<<"Time:"<<clock()<<" ms"<<'\n';
	#endif
	return 0;
}
```

---

## 作者：daifucong (赞：9)

考场上看到这题就感觉非常可做

~~开场还是想了个假算法~~

先考虑对于一个点，如何求出能和它交流的节点个数

这样的话对每一个点开一棵线段树，然后树链剖分，对于一条链上的每个节点，把这条链在树链剖分时被分成的区间覆盖即可

~~然后写一个4只log的树套树，得到可能连暴力分都不到的好成绩~~

然后考虑差分

在链底的两个节点的线段树上将树链剖分得到的log个区间+1，在lca的父亲的线段树上把这些区间-2

然后线段树合并上去即可

因为insert的次数是$O(nlogn)$，所以总时空复杂度是$O(nlog^2n)$

注意线段树的写法很奇怪，我用的是lyd的书上讲扫描线时看到的一个神奇的写法

因为两个+1和一个+2在线段树上对应的节点是相同的

因此我们不pushdown，只pushup

pushup时，如果一个节点的标记值大于0，那么这个节点所代表的区间中被覆盖的长度就是这个区间的长度，否则的话就是这个节点的左右儿子代表的区间中被覆盖的长度之和

然而我dfs一个节点时，先把这个节点的操作insert进去，在把子树merge进去，常数巨大

如果先insert再merge线段树节点数大概要开$25000000$左右(卡树剖专用数据)，但是我只开了$20000000$(多谢吉老师不杀之恩

听说吉老师挂了棵完全二叉树，回去模拟吉老师的gen风格用了好几个数据构造方法，都把我的节点数卡掉了~~，所以吉老师是为了把我这个两只log选手区分出来吗~~

但是就算不爆节点数还是会TLE(垃圾评测机)，反正我只有80分

~~而且我T3根本就没拿分，T1拿了人人都会的高消50分，所以我凉了~~

如果先merge再insert的话不但节点数会乘上0.5的常数，运行效率也会快一点

~~什么????一只log????不会!!!!!~~

放上我考后手动还原的考场代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100100;
int head[maxn],nxt[maxn<<1],ver[maxn<<1],tot,n,m;
inline void addedge(int a,int b)
{
	nxt[++tot]=head[a];ver[tot]=b;head[a]=tot;
	nxt[++tot]=head[b];ver[tot]=a;head[b]=tot;
}
int dep[maxn],fa[maxn],hson[maxn],size[maxn];
inline void dfs1(int x,int fat)
{
	dep[x]=dep[fat]+1;fa[x]=fat;size[x]=1;int mxsize=0;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i];if(y==fat) continue;
		dfs1(y,x);size[x]+=size[y];
		if(size[y]>mxsize) mxsize=size[y],hson[x]=y;
	}
}
int id[maxn],top[maxn],id_cnt;
inline void dfs2(int x,int Top)
{
	id[x]=++id_cnt;top[x]=Top;
	if(hson[x]) dfs2(hson[x],Top);
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i];if(y==fa[x]||y==hson[x]) continue;
		dfs2(y,y);
	}
}
struct Node {int ls,rs,tag,sum;}seg[maxn*200];
int segtot,root[maxn];
inline void pushup(int p,int l,int r){seg[p].sum=(seg[p].tag>0)?(r-l+1):(seg[seg[p].ls].sum+seg[seg[p].rs].sum);}
inline void setadd(int p,int l,int r,int v){seg[p].tag+=v;pushup(p,l,r);}
inline void insert(int &p,int l,int r,int ql,int qr,int v)
{
	if(p==0) p=++segtot;
	if(ql<=l&&qr>=r) return (void)setadd(p,l,r,v);
	int mid=(l+r)>>1;
	if(ql<=mid) insert(seg[p].ls,l,mid,ql,qr,v);
	if(qr>mid) insert(seg[p].rs,mid+1,r,ql,qr,v);
	pushup(p,l,r);
}
inline int Merge(int x,int y,int l,int r)
{
	if((!x)||(!y)) return x|y;
	int mid=(l+r)>>1;seg[x].tag+=seg[y].tag;
	seg[x].ls=Merge(seg[x].ls,seg[y].ls,l,mid);
	seg[x].rs=Merge(seg[x].rs,seg[y].rs,mid+1,r);
	pushup(x,l,r);return x;
}
struct Query {int l,r,v;Query(int L,int R,int V){l=L;r=R;v=V;}};
vector<Query> que[maxn];
inline int lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	return dep[x]<dep[y]?x:y;
}
inline void deal(int x,int y)
{
	int tx=x,ty=y,l=fa[lca(x,y)];
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		que[tx].push_back(Query(id[top[x]],id[x],1));
		que[ty].push_back(Query(id[top[x]],id[x],1));
		que[l].push_back(Query(id[top[x]],id[x],-2));
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	que[tx].push_back(Query(id[x],id[y],1));
	que[ty].push_back(Query(id[x],id[y],1));
	que[l].push_back(Query(id[x],id[y],-2));
}
long long ans;
inline void getans(int x,int fat)
{
	for(int i=0;i<(int)que[x].size();i++) insert(root[x],1,n,que[x][i].l,que[x][i].r,que[x][i].v);
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i];if(y==fat) continue;
		getans(y,x);root[x]=Merge(root[x],root[y],1,n);
	}
	ans+=seg[root[x]].sum;
}
inline void init()
{
	scanf("%d%d",&n,&m);
	for(int i=1,a,b;i<n;i++) scanf("%d%d",&a,&b),addedge(a,b);
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=n;i++) deal(i,i);
	for(int i=1,a,b;i<=m;i++) scanf("%d%d",&a,&b),deal(a,b);
}
int main()
{
	init();getans(1,0);
	printf("%lld\n",(ans-n)/2);
}
```
在洛谷上测官方数据是可以AC的，~~而且开不开O2差不多快~~

---

## 作者：Diaоsi (赞：7)

[[ZJOI2019]语言](https://www.luogu.com.cn/problem/P5327)

虚树 + 树上差分 + 线段树合并

首先将问题抽象，给定一棵 $n$ 个点的树和 $m$ 条树上路径，问有多少有序点对 $(i,j)$ 满足这两点至少被同一条路径覆盖。

于是可以得到一个转化的问题，对于每个点求出覆盖该点的路径并的大小减一，加起来除以二就是答案（将无序点对转化为有序点对）。

然后观察到覆盖该点的链并一定是一个以路径端点为叶子节点的生成树，根据虚树的思想，可以以路径端点为关键点建出一棵极小连通子树，这棵极小连通子树的大小就是路径并的大小，而树上的边数等于点数减一，所以只要求出这棵极小连通子树上的边数就可以求出该点对答案的贡献。

有一个经典结论，对于一棵树上的任意一个点集 $S$ ，将其中的元素按照 dfs 序排序之后得到一个有序不可重集合 $S^\prime=\{a_1,a_2,a_3,\dots,a_n\}$ ，此时设这些点在树上的极小连通子树为 $T^\prime=(V,E)$ ，有：

$$|E|=\dfrac{dis(a_1,a_2)+dis(a_2,a_3)+\dots+dis(a_n,a_1)}{2}$$

为什么这样做是正确的呢，感性理解一下就是在按照集合中点的顺序遍历这棵极小连通子树时是按照 dfs 序来遍历的，所以每条边都会被经过正好两次，所以除以二之后就是极小连通子树上边的数量。

接下来考虑怎么维护 $|E|$ ，对树上每个节点以 dfs 序为下标建出一棵动态开点线段树，用线段树维护这个有序点集，线段树的叶子节点表示该 dfs 序对应的节点是否存在与集合当中，而其上级节点保存该节点对应的 dfs 序区间中的点构成的点集的相邻元素之间的路径和，合并信息后，最上层的节点保存的信息应当是 $dis(a_1,a_2)+dis(a_2,a_3)+\dots+dis(a_{n-1},a_n)$ 。

由于在线段树上上传信息时可以看作两个区间的合并，利用分治的思想考虑怎么合并这两个区间代表的点集，可以对每个线段树上的区间记录在这个区间中 dfs 序最小和最大的元素，合并区间时加上左区间中 dfs 序最大的元素和右区间中 dfs 序最小的元素之间的距离即可，可以通过求 $\text{lca}$ 实现。

观察到增加一条路径需要修改路径上所有点的线段树的信息，如果直接维护那肯定是要超时的，发现静态的“增加路径”是可以使用树上差分维护的，那又怎么维护节点上线段树的信息呢？用线段树合并即可！

于是我们得到了一个这样的算法：

+ 对树上每一个节点建以 dfs 序为下标的动态开点线段树。

+ 读入路径的信息，差分维护路径，具体操作就是在路径端点对应树上节点的线段树上增加路径端点的信息，在路径端点的 $\text{lca}$ 和 $\text{lca}$ 的父亲处删去路径端点的信息。

+ 对整棵树自底向上地进行线段树合并，通过线段树上保存的信息计算每个点对应的路径并的大小，记得手动加上 $dis(a_n,a_1)$ ，将值除以二之后得到 $|E|$ 。

+ 将每个节点对应的 $|E|$ 加起来除以二就是答案。

具体实现的时候有一些小细节，比如 $\text{lca}$ 的父亲不一定存在，不能直接进行修改，可以将修改信息通过 ```std::vector``` 挂在对应的节点上，在合并的时候进行操作即可。

求 $\text{lca}$ 的时候使用 $\mathcal{O(1)}$ 的 ST 表，总的时间复杂度降至 $\mathcal{O(n\log n)}$ 。

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$

```cpp
#include<bits/stdc++.h>
typedef long long LL;
typedef long double LD;
using namespace std;
const LL N=100010,M=1000010,INF=0x3f3f3f3f;
inline LL max(LL x,LL y){return x>y?x:y;}
inline LL min(LL x,LL y){return x<y?x:y;}
inline void swap(LL &x,LL &y){x^=y^=x^=y;}
LL head[N],ver[M],Next[M],tot;
LL n,m,t,num,ans,d[N],id[N],pre[N],f[N];
LL top,cnt,rec[N<<7],root[N];
LL ts,st[N<<2][20],in[N<<2],out[N<<2],lg[N<<2];
vector<LL> del[N];
void dfs1(LL x,LL fa);
void dfs2(LL x,LL fa);
LL lca(LL x,LL y);
LL dis(LL x,LL y);
void add(LL x,LL y){
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
struct SegmentTree{
	LL l,r;
	LL mn,mx,sum,dat;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define mn(x) tree[x].mn
	#define mx(x) tree[x].mx
	#define sum(x) tree[x].sum
	#define dat(x) tree[x].dat
}tree[N<<7];
LL build(){
	LL p=cnt?rec[cnt--]:++top;
	l(p)=r(p)=mn(p)=mx(p)=0;
	dat(p)=sum(p)=0;
	return p;
}
void recycle(LL p){
	rec[++cnt]=p;
	l(p)=r(p)=mn(p)=mx(p)=0;
	dat(p)=sum(p)=0;
}
void pushup(LL p){
	mn(p)=mn(l(p))?mn(l(p)):mn(r(p));
	mx(p)=mx(r(p))?mx(r(p)):mx(l(p));
	sum(p)=sum(l(p))+sum(r(p));
	if(mx(l(p))&&mn(r(p)))
		sum(p)+=dis(pre[mx(l(p))],pre[mn(r(p))]);
}
void insert(LL p,LL l,LL r,LL pos,LL val){
	if(l==r){
		dat(p)+=val;sum(p)=0;
		mn(p)=mx(p)=(dat(p)>0)?l:0;
		return;
	}
	LL mid=(l+r)>>1;
	if(pos<=mid){
		if(!l(p))l(p)=build();
		insert(l(p),l,mid,pos,val);
	}
	if(pos>mid){
		if(!r(p))r(p)=build();
		insert(r(p),mid+1,r,pos,val);
	}
	pushup(p);
}
LL merge(LL p,LL q,LL l,LL r){
	if(!p||!q)return p+q;
	if(l==r){
		dat(p)+=dat(q);sum(p)=0;
		mn(p)=mx(p)=(dat(p)>0)?l:0;
		return p;
	}
	LL mid=(l+r)>>1;
	l(p)=merge(l(p),l(q),l,mid);
	r(p)=merge(r(p),r(q),mid+1,r);
	pushup(p),recycle(q);
	return p;
}
void dfs1(LL x,LL fa){
	d[x]=d[fa]+1;id[x]=++num;
	pre[id[x]]=x;root[x]=build();
	in[x]=++ts;st[ts][0]=x;
	for(LL i=head[x];i;i=Next[i]){
		LL y=ver[i];
		if(y==fa)continue;
		f[y]=x;
		dfs1(y,x);
	}
	out[x]=++ts;
	if(fa)st[ts][0]=fa;
}
void dfs2(LL x,LL fa){
	for(LL i=head[x];i;i=Next[i]){
		LL y=ver[i];
		if(y==fa)continue;
		dfs2(y,x);
		merge(root[x],root[y],1,n);
	}
	for(LL i:del[x])insert(root[x],1,n,id[i],-1);
	if(mn(root[x])&&mx(root[x])&&mn(root[x])!=mx(root[x])){
		LL u=pre[mn(root[x])],v=pre[mx(root[x])];
		ans+=(dis(u,v)+sum(root[x]))/2;
	}
}
void init(){
	for(LL i=2;i<=N<<1;i++)lg[i]=lg[i>>1]+1;
	for(LL j=1;(1<<j)<=ts;j++)
		for(LL i=1;i+(1<<j)-1<=ts;i++){
			LL x=st[i][j-1],y=st[i+(1<<(j-1))][j-1];
			st[i][j]=(d[x]<d[y])?x:y;
		}
}
LL lca(LL x,LL y){
	LL l=in[x],r=in[y];
	if(l>r)swap(l,r);LL Lg=lg[r-l+1];
	return d[st[l][Lg]]<d[st[r-(1<<Lg)+1][Lg]]?st[l][Lg]:st[r-(1<<Lg)+1][Lg];
}
LL dis(LL x,LL y){
	return d[x]+d[y]-2*d[lca(x,y)];
}
int main(){
	scanf("%lld%lld",&n,&m);
	t=(LL)(log(n)/log(2))+1;
	for(LL i=1;i<n;i++){
		LL x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y),add(y,x);
	}
	dfs1(1,0);
	init();
	while(m--){
		LL x,y;
		scanf("%lld%lld",&x,&y);
		LL l=lca(x,y),fa=f[l];
		insert(root[x],1,n,id[x],1);insert(root[x],1,n,id[y],1);
		insert(root[y],1,n,id[x],1);insert(root[y],1,n,id[y],1);
		del[l].push_back(x),del[fa].push_back(x);
		del[l].push_back(y),del[fa].push_back(y);
	}
	dfs2(1,0);
	printf("%lld\n",ans/2);
	return 0;
}
```


---

## 作者：Lynkcat (赞：6)

小清新静态链分治题解。

考虑一下如何 dsu on tree。

假设 $u$ 和 $v$ 没有祖先关系，那么包含之的一条链 $(s_i,t_i)$ 的 $\text{lca}$ 一定等于 $\text{lca}_{u,v}$。如果有祖先关系则不一定有上述结论，启发我们把这两部分分开来算。

先考虑第一部分，我们把每条链拆成两条直链，然后在深处加入浅处删除。dsu on tree 维护每条包含当前点 $k$ 的直链的交与 $k$ 的子树集合的交。这个东西可以直接维护直链底部的点的 dfn，每次加入/删除只要查询前驱后继更新一下答案即可。

发现上面这个东西功能比较强大。所以接着考虑第二部分，我们把所有 $(u,v)$ 的贡献放到 $\text{lca}_{u,v}=k$ 处计算。我们可以接着把拆好的两条直链打到对应的点上，然后对去除重子树的部分进行 dsu on tree，跟第一部分相同，只不过加入的点不是当前自己的点而是两条直链中的另一条的底部结点。

然后你发现算重了，因为有可能 $u$ 和 $v$ 都在 $k$ 的轻子树内，然后其实你拆成两部分算就行了，一部分是轻子树和轻子树，一部分是轻子树和重子树，前面那部分要除以 $2$。

时间复杂度 $O(n\log ^2n)$ 。本以为查询前驱后继使用 set 可能常数会有点裂开，实际上得益于静态链分治的小常数还有基于数据本身强弱的常数影响跑得貌似很不错。比一般的线段树合并做法要快。

```c++
// Lynkcat.
// Problem: P5327 [ZJOI2019]语言
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5327
// Memory Limit: 500 MB
// Time Limit: 3000 ms

#include<bits/stdc++.h>
#define poly vector<int>
#define IOS ios::sync_with_stdio(false)
#define ll long long
#define mp make_pair
#define mt make_tuple
#define pa pair < int,int >
#define fi first
#define se second
#define inf 1e9
#define mod 998244353
#define int ll
#define N 100005
using namespace std;
poly G[N],tmp[N],Q[N],E[N];
int dfn[N],siz[N],ffa[N],dep[N],son[N],idfn[N],DFN;
int rdfn[N];
int Tp[N];
int ans;
int n,m;
int a[N],b[N],c[N];
int ans1;
void dfs(int k,int fa)
{
	dfn[k]=++DFN;
	siz[k]=1;
	ffa[k]=fa;
	dep[k]=dep[fa]+1;
	idfn[DFN]=k;
	for (auto u:G[k])
	{
		if (u==fa) continue;
		dfs(u,k);
		if (siz[u]>siz[son[k]]) son[k]=u;
		siz[k]+=siz[u];
	}
	rdfn[k]=DFN;
}
void dfs1(int k,int tp)
{
	Tp[k]=tp;
	if (son[k]) dfs1(son[k],tp);
	for (auto u:G[k])
	{
		if (u==ffa[k]||u==son[k]) continue;
		dfs1(u,u);
	}
}
inline int lca(int x,int y)
{
	while (Tp[x]!=Tp[y])
	{
		if (dep[Tp[x]]<dep[Tp[y]]) swap(x,y);
		x=ffa[Tp[x]];
	}
	if (dep[x]>dep[y]) return y;
	return x;
}
inline int dis(int x,int y)
{
	return dep[x]+dep[y]-2*dep[lca(x,y)];
}
inline int in(int x,int y)
{
	return dfn[y]<=dfn[x]&&dfn[x]<=rdfn[y];
}
struct node
{
	multiset<int>S;
	int sum;
	void ins(int x)
	{
		if (S.size()==0)
		{
			S.insert(x);
			return;
		}
		auto it=S.lower_bound(x);
		if (it==S.end())
		{
			sum-=dis(idfn[(*(--S.end()))],idfn[(*S.begin())]);
			sum+=dis(idfn[(*(--S.end()))],idfn[x]);
			sum+=dis(idfn[x],idfn[(*S.begin())]);
		} else
		if (it==S.begin())
		{
			sum-=dis(idfn[(*(--S.end()))],idfn[(*S.begin())]);
			sum+=dis(idfn[(*S.begin())],idfn[x]);
			sum+=dis(idfn[x],idfn[(*(--S.end()))]);
		} else
		{
			auto it1=it;
			it1--;
			sum-=dis(idfn[*it],idfn[*it1]);
			sum+=dis(idfn[*it],idfn[x]);
			sum+=dis(idfn[*it1],idfn[x]);
		}
		S.insert(x);
	}
	void ers(int x)
	{
		S.erase(S.find(x));
		if (S.empty()) return;
		auto it=S.lower_bound(x);
		if (it==S.end())
		{
			sum+=dis(idfn[(*(--S.end()))],idfn[(*S.begin())]);
			sum-=dis(idfn[(*(--S.end()))],idfn[x]);
			sum-=dis(idfn[x],idfn[(*S.begin())]);
		} else
		if (it==S.begin())
		{
			sum+=dis(idfn[(*(--S.end()))],idfn[(*S.begin())]);
			sum-=dis(idfn[(*S.begin())],idfn[x]);
			sum-=dis(idfn[x],idfn[(*(--S.end()))]);
		} else
		{
			auto it1=it;
			it1--;
			sum+=dis(idfn[*it],idfn[*it1]);
			sum-=dis(idfn[*it],idfn[x]);
			sum-=dis(idfn[*it1],idfn[x]);
		}
	}
	void clear()
	{
		S.clear();
		sum=0;
	}
	int size()
	{
		return S.size();
	}
}set1,set2;
void Ins(int k)
{
	for (auto u:tmp[k])
	{
		if (a[u]!=k)
		{
			set2.ins(dfn[a[u]]);
		}  else 
		{
			set2.ins(dfn[b[u]]);
		}
	}
}
void qry(int k,int fa,int rt)
{
	for (auto u:G[k])
	{
		if (u==fa||u==son[k]) continue;
		qry(u,k,rt);
		set2.clear();
		set2.ins(dfn[rt]);
	}
	if (son[k])
		qry(son[k],k,rt);
	Ins(k);
	for (auto u:G[k])
	{
		if (u==fa||u==son[k]) continue;
		for (int j=dfn[u];j<=rdfn[u];j++)
			Ins(idfn[j]);
	}
	ans1+=(set2.sum/2);
}
void calc(int k,int fa)
{
	for (auto u:G[k])
	{
		if (u==fa||u==son[k]) continue;
		calc(u,k);
		set1.clear();
		set1.sum=0;
	}
	if (son[k]) 
	{
		calc(son[k],k);
		set1.ers(dfn[son[k]]);
	}
	set1.ins(dfn[k]);
	for (auto p:Q[k])
		set1.ins(dfn[k]);
		
		
	for (auto u:E[k])
	{
		if (!in(a[u],son[k])&&!in(b[u],son[k]))
		{
			tmp[b[u]].push_back(u);
			tmp[a[u]].push_back(u);
		}
	}
	set2.clear(),set2.sum=0;
	set2.ins(dfn[k]);
	ans1=0;
	for (auto u:G[k])
	{
		if (u==fa||u==son[k]) continue;
		qry(u,k,k);
		set2.clear();
		set2.ins(dfn[k]);
		for (int j=dfn[u];j<=rdfn[u];j++)
		{
			int v=idfn[j];
			for (auto p:Q[v])
				if (dep[c[p]]<=dep[k])
					set1.ins(dfn[v]);
		}
	}
	for (auto u:E[k]) tmp[a[u]].clear(),tmp[b[u]].clear();
	ans+=ans1/2;
	
	
	for (auto u:E[k])
	{
		if (!in(a[u],son[k])&&!in(b[u],son[k]))
		{
		} else
		{
			if (in(a[u],son[k])) tmp[b[u]].push_back(u);
			else tmp[a[u]].push_back(u);
		}
	}
	set2.clear(),set2.sum=0;
	set2.ins(dfn[k]);
	ans1=0;
	for (auto u:G[k])
	{
		if (u==fa||u==son[k]) continue;
		qry(u,k,k);
		set2.clear();
		set2.ins(dfn[k]);
	}
	for (auto u:E[k]) tmp[a[u]].clear(),tmp[b[u]].clear();
	ans+=ans1;
	
	ans+=(set1.sum/2);
	for (auto u:E[k])
		set1.ers(dfn[a[u]]),set1.ers(dfn[b[u]]);
	
}
void BellaKira()
{
	cin>>n>>m;
	for (int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		G[x].push_back(y);
		G[y].push_back(x);
	}
	dfs(1,0);
	dfs1(1,1);
	for (int i=1;i<=m;i++)
	{
		cin>>a[i]>>b[i];
		if (a[i]==b[i]) continue;
		c[i]=lca(a[i],b[i]);
		Q[a[i]].push_back(i);
		Q[b[i]].push_back(i);
		E[c[i]].push_back(i);
	}
	calc(1,0);
	cout<<ans<<'\n';
}
signed main()
{
	IOS;
	cin.tie(0);
	int T=1;
	while (T--)
	{
		BellaKira();
	}
}
```

---

## 作者：Soulist (赞：6)


显然一个点可达的点是一个联通块；所以可以直接考虑维护点集的虚树。

比较麻烦的做法是考虑直接用一个 $\rm set$ 维护虚树的点集以及点集大小（实质是维护 $\rm dfn$ 序），对于每条链拆成两条链依次丢入 $x,y$ 以及 $LCA$ 处，然后只需要将儿子的虚树合并即可，那么直接启发式合并 $\rm set$ 即可，由于需要维护每个点的出现次数，大概需要一个 $\rm node$ 类型。

这个做法需要特判两边（前驱和后继）的出现次数，相对而言没有那么简单，更简洁的做法是考虑计算若干条 $x\to 1$ 的链的交的大小减去深度最小的 $LCA\to 1$ 的链的大小即可。这样只需要在 $\rm dfn$ 上做线段树合并（合并相邻两项是十分简洁的，只需要减去最左与最右的 LCA 的深度），而且也不用分类讨论。

维护 LCA 集和链集都可以通过线段树合并处理，视是否写 $\mathcal O(1) LCA$，复杂度为 $\mathcal O(n\log n)~\mathbf{or}~\mathcal O(n\log^2 n)$，不过我直接写的 $\log^2$，所以维护深度最小的 LCA 则是直接写的 mutliset 启发式合并。（懒得改线段树）

细节建议自己想一下。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define pb push_back
#define int long long
#define ls(x) tr[x].l
#define rs(x) tr[x].r
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 2e5 + 5 ; 
const int M = 6e6 + 5 ; 
int n, m, idnex, cnt, Id[N], rt[N], dep[N], dfn[N], Fa[N], son[N], sz[N], top[N], Ans ; 
vector<int> E[N], in[N], out[N], pi[N], po[N] ; 
multiset<int> S[N] ; multiset<int>::iterator it ;  
struct Tr { int lx, rx, ans, t, l, r ; } tr[M] ;
void add( int x, int y ) { E[x].pb(y), E[y].pb(x) ; }
void dfs( int x, int fa ) {
	sz[x] = 1, son[x] = 0, dep[x] = dep[fa] + 1, Fa[x] = fa ; 
	for( int v : E[x] ) {
		if( v == fa ) continue ; 
		dfs( v, x ), sz[x] += sz[v] ;
		if( sz[v] > sz[son[x]] ) son[x] = v ; 
	}
}
void dfs2( int x, int high ) {
	dfn[x] = ++ idnex, Id[idnex] = x, top[x] = high ; 
	if( son[x] ) dfs2( son[x], high ) ;
	for( int v : E[x] ) if( ( v ^ Fa[x] ) && ( v ^ son[x] ) ) dfs2( v, v ) ; 
}
int LCA( int x, int y ) {
	while( top[x] != top[y] ) {
		if( dep[top[x]] < dep[top[y]] ) swap( x, y ) ;
		x = Fa[top[x]] ; 
	}
	return ( dep[x] < dep[y] ) ? x : y ; 
}
void pushup( int x ) {
	int r = rs(x), l = ls(x) ;
	if( !tr[ls(x)].t ) tr[x] = tr[rs(x)] ;
	else if( !tr[rs(x)].t ) tr[x] = tr[ls(x)] ; 
	else 
		tr[x].ans = tr[ls(x)].ans + tr[rs(x)].ans - dep[LCA( tr[ls(x)].rx, tr[rs(x)].lx )], 
		tr[x].lx = tr[ls(x)].lx, tr[x].rx = tr[rs(x)].rx, tr[x].t = tr[ls(x)].t + tr[rs(x)].t ; 
	tr[x].l = l, tr[x].r = r ; 
}
void insert( int &x, int l, int r, int k, int type ) {
	if( !x ) x = ++ cnt ; 
	if( l == r ) {
		if( ( type > 0 ) && ( !tr[x].t ) ) tr[x].ans = dep[Id[l]], tr[x].lx = tr[x].rx = Id[l] ; 
		tr[x].t += type ; 
		if( ( type < 0 ) && ( !tr[x].t ) ) tr[x].ans = tr[x].lx = tr[x].rx = 0 ; return ; 
	}
	int mid = ( l + r ) >> 1 ; 
	if( mid >= k ) insert( ls(x), l, mid, k, type ) ;
	else insert( rs(x), mid + 1, r, k, type ) ;
	pushup(x) ; 
}
void merge( int &x, int u, int l, int r ) {
	if( !x || !u ) return (void)(x = x + u) ;
	if( l == r ) { if( !tr[x].t ) tr[x] = tr[u] ; else tr[x].t += tr[u].t ; return ; }
	int mid = ( l + r ) >> 1 ; 
	merge( ls(x), ls(u), l, mid ), merge( rs(x), rs(u), mid + 1, r ) ;
	pushup(x) ; 
}
void Merge( int x, int y ) {
	if( S[x].size() < S[y].size() ) swap( S[x], S[y] ) ;
	it = S[y].begin() ; 
	for( ; it != S[y].end(); ++ it ) S[x].insert(*it) ; 
}
void Dfs( int x, int fa ) {
	for( int k : in[x] ) insert( rt[x], 1, n, dfn[k], 1 ) ;
	for( int k : pi[x] ) S[x].insert(k) ; 
	for( int v : E[x] ) 
		if( v ^ fa ) Dfs( v, x ), merge( rt[x], rt[v], 1, n ), Merge( x, v ) ; 
	if( !S[x].empty() ) it = S[x].begin(), Ans += ( tr[rt[x]].ans - *it ) ;
	for( int k : out[x] ) insert( rt[x], 1, n, dfn[k], -2 ) ;
	for( int k : po[x] ) S[x].erase(S[x].find(k)), S[x].erase(S[x].find(k)) ; 
}
signed main()
{
	n = gi(), m = gi() ; int x, y ; 
	rep( i, 2, n ) x = gi(), y = gi(), add( x, y ) ; 
	dfs( 1, 1 ), dfs2( 1, 1 ) ;
	rep( i, 1, m ) {
		x = gi(), y = gi() ; int lca = LCA( x, y ) ;
		out[lca].pb(x), out[lca].pb(y), po[lca].pb(dep[lca]), 
		pi[x].pb(dep[lca]), pi[y].pb(dep[lca]) ; 
		in[x].pb(x), in[x].pb(y), in[y].pb(x), in[y].pb(y) ;
	} Dfs( 1, 1 ) ;
	printf("%lld\n", Ans / 2 ) ;
	return 0 ;
}
```

---

## 作者：cwfxlh (赞：6)

## [P5327](https://www.luogu.com.cn/problem/P5327)  
本题的大意就是让你求对于每一个 $x$，经过 $x$ 的链的并集大小之和的一半。   
考虑对于若干个点 $A_1,A_2...A_p$，序列的 dfs 序从小到大，它们在树上形成的虚树大小就是 $\sum_{i=1}^{n}dep_{A_i}-\sum_{i=1}^{n-1}dep_{lca(A_i,A_{i+1})}-dep_{lca(A_1,A_n)}$ 这个结论可以使用 dfs 序来证明，挺简单的，这里就不详细讲了。   
那么对于一个点 $x$，经过 $x$ 的链的并集大小就可以转化为经过 $x$ 的链的端点构成的虚树大小。考虑怎么维护每个点被哪些链经过，明显地，可以进行树上差分来处理，就只用在四个点的桶加值就好了。    
然后考虑优化，把桶改作动态开点线段树，并使用线段树合并，这样复杂度就是 $\Theta(m\log m)$，就可以维护有哪些端点要算进当前节点的虚树中了，而对于计算虚树大小，对于每一个区间 $[l,r]$，表示当前节点下，$[l,r]$ 中端点的信息（端点按 dfs 序排个序），记录最左、最右的选中端点和 $\sum_{i=1}^{n}dep_{A_i}$ 与 $\sum_{i=1}^{n-1}dep_{lca(A_i,A_{i+1})}$ 的值，这是好维护的。     
上代码：   

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,head[300003],sz[300003],F[300003][23],dep[300003],root[300003],wz[300003],idx;
int apr[300003];
int s[300003],t[300003];
int s2[300003],t2[300003];
vector<pair<int,int> >r;
struct Edge{
	int st;
	int ed;
	int nxt;
}E[300003];
struct SegmentTree{
	int st;
	int ed;
	int val;
	int val1;
	int val2;
	int lv;
	int rv;
	int lson;
	int rson;
}T[7500003];
int totT;
int totE;
int k1,k2,k3,k4,k5,k6,k7,k8,k9;
long long ans;
int add_new(int st,int ed){
	T[++totT].st=st;
	T[totT].ed=ed;
	return totT;
}
void addEdge(int st,int ed){
	E[++totE].st=st;
	E[totE].ed=ed;
	E[totE].nxt=head[st];
	head[st]=totE;
	return;
}
void dfs(int now){
	wz[now]=++idx;
	for(int i=1;;i++){
		if(F[F[now][i-1]][i-1]==0)break;
		F[now][i]=F[F[now][i-1]][i-1];
	}
	sz[now]=1;
	for(int i=head[now];i;i=E[i].nxt){
		if(E[i].ed==F[now][0])continue;
		F[E[i].ed][0]=now;
		dep[E[i].ed]=dep[now]+1;
		dfs(E[i].ed);
		sz[now]+=sz[E[i].ed];
	}
	return;
}
int lca(int X,int Y){
	if(dep[X]<dep[Y])swap(X,Y);
	k4=22;
	while(k4--)if(dep[F[X][k4]]>=dep[Y])X=F[X][k4];
	k4=22;
	while(k4--)if(F[X][k4]!=F[Y][k4])X=F[X][k4],Y=F[Y][k4];
	while(X!=Y)X=F[X][0],Y=F[Y][0];
	return X;
}
void pushup(int now){
	T[now].val1=T[T[now].lson].val1+T[T[now].rson].val1;
	if(T[T[now].lson].lv!=0)T[now].lv=T[T[now].lson].lv;
	else T[now].lv=T[T[now].rson].lv;
	if(T[T[now].rson].rv!=0)T[now].rv=T[T[now].rson].rv;
	else T[now].rv=T[T[now].lson].rv;
	T[now].val2=T[T[now].lson].val2+T[T[now].rson].val2;
	if(T[T[now].lson].rv&&T[T[now].rson].lv)T[now].val2+=dep[lca(apr[T[T[now].lson].rv],apr[T[T[now].rson].lv])];
	return;
}
void add(int now,int wz,int val){
	if(T[now].st==T[now].ed){
		T[now].val+=val;
		if(T[now].val<=0)T[now].val1=T[now].lv=T[now].rv=T[now].val2=0;
		else{
			T[now].val1=dep[apr[T[now].st]];
			T[now].val2=0;
			T[now].lv=T[now].rv=T[now].st;
		}
		return;
	}
	if(wz<=((T[now].st+T[now].ed)>>1)){
		if(!T[now].lson)T[now].lson=add_new(T[now].st,((T[now].st+T[now].ed)>>1));
		add(T[now].lson,wz,val);
	}
	else{
		if(!T[now].rson)T[now].rson=add_new(((T[now].st+T[now].ed)>>1)+1,T[now].ed);
		add(T[now].rson,wz,val);
	}
	pushup(now);
	//if(val>0)cout<<T[now].st<<" "<<T[now].ed<<" "<<T[now].val1<<endl;
	return;
}
void merge(int X,int Y){
	if(T[X].st==T[X].ed){
		T[X].val+=T[Y].val;
		if(T[X].val<=0)T[X].val1=T[X].lv=T[X].rv=T[X].val2=0;
		else{
			T[X].val1=dep[apr[T[X].st]];
			T[X].val2=0;
			T[X].lv=T[X].rv=T[X].st;
		}
		return;
	}
	if(T[X].lson&&T[Y].lson)merge(T[X].lson,T[Y].lson);
	if(T[X].lson==0)T[X].lson=T[Y].lson;
	if(T[X].rson&&T[Y].rson)merge(T[X].rson,T[Y].rson);
	if(T[X].rson==0)T[X].rson=T[Y].rson;
	pushup(X);
	return;
}
void get_ans(int now){
	for(int i=head[now];i!=0;i=E[i].nxt){
		if(E[i].ed==F[now][0])continue;
		get_ans(E[i].ed);
		merge(root[now],root[E[i].ed]);
	}
	ans+=T[root[now]].val1-T[root[now]].val2-dep[lca(apr[T[root[now]].lv],apr[T[root[now]].rv])];
	return;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)root[i]=add_new(1,2*m);
	for(int i=1;i<n;i++){
		scanf("%d%d",&k1,&k2);
		addEdge(k1,k2);
		addEdge(k2,k1);
	}
	dep[1]=1;
	dfs(1);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&s[i],&t[i]);
		r.push_back({wz[s[i]],i});
		r.push_back({wz[t[i]],i+m});
	}
	sort(r.begin(),r.end());
	for(int i=0,j=0;i<r.size();i++){
		if(i==0||r[i].first!=r[i-1].first)j++;
		if(r[i].second<=m)s2[r[i].second]=j;
		else t2[r[i].second-m]=j;
	}
	for(int i=1;i<=m;i++){
		apr[s2[i]]=s[i];
		apr[t2[i]]=t[i];
	}
	for(int i=1;i<=m;i++){
		k3=lca(apr[s2[i]],apr[t2[i]]);
		if(k3!=1){
			add(root[F[k3][0]],s2[i],-1);
			add(root[F[k3][0]],t2[i],-1);
		}
		add(root[k3],s2[i],-1);
		add(root[k3],t2[i],-1);
		add(root[apr[s2[i]]],s2[i],1);
		add(root[apr[s2[i]]],t2[i],1);
		add(root[apr[t2[i]]],s2[i],1);
		add(root[apr[t2[i]]],t2[i],1);
	}
	get_ans(1);
	ans/=2;
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：MoYuFang (赞：4)

[P5327 [ZJOI2019]语言](https://www.luogu.com.cn/problem/P5327) 

线段树合并 + 点分治，总时间复杂度为 $O(n\log^2n)$。

貌似题解区里没有点分治的做法，那就交一发点分治。

首先将链分别挂在两个端点的 ```vector``` 上。

选取了分治中心后，对中心对应的树求一遍主席树，让每个节点 $u$ 上都挂有一颗装着前缀链上所有点的线段树，设线段树根为 $rt1(u)$。

中心下挂着若干个子树，对不同子树的节点染不同色（$col(u)$），中心也染上不同的色。

然后对每一颗子树分别处理和统计答案，方法是对每个节点维护它通过分治中心所能到达的节点的集合（这仍然是一颗线段树），记为 $rt2(u)$。

在某一颗子树内时，若某节点 $u$ 上有跳出这颗子树的链 $(u,v)$，也即 $col(u)\neq col(v)$，说明 $rt1(v)$ 这一条前缀链上的所有点（包括分治中心）都是 $u$ 通过分治中心能到达的，所以让 $rt2(u):=\text{merge}(rt2(u),rt1(v))$。

节点 $u$ 上跳出这个子树的链 $(u,v)$ 会被分治中心截断，不妨设这颗子树的根是 $top$，则需要将这条链修改为 $(u,top)$，记住在 $top$ 的 ```vector``` 上也需要加入一条链 $(top,u)$。

其次 $u$ 的子节点通过分治中心所能到达的节点也一定是 $u$ 能到的，故递归处理完子节点 $w$ 后，让 $rt2(u)=\text{merge}(rt2(u), rt2(w))$。

然后将 $size(rt2(u))$ 加入最终答案。

处理完分治中心的每颗子树后，还要记得求出分治中心所能到达的节点（注意到自身的贡献要减去，若有的话）并把贡献加入到最终答案。

点分治结束后输出答案时要将答案除 $2$。 

每一条链至多被遍历 $O(\log n)$ 次，每条链被截断时至多在 $top$ 上产生 $1$ 条新链，每条链的截断次数为 $O(\log n)$，所以对链遍历的总时间复杂度为 $O(m\log^2 n)$，当然这个界远远达不到。

对于分治的每一层，若这一层的大小为 $s$，则线段树合并的时间复杂度为 $O(s\log s)$，于是线段树合并的总时间复杂度为 $O(n\log^2 n)$。 

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <assert.h>
#include <vector>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ll long long
#define db double
#define ull unsigned long long
#define _for(i, a, b) for(re int i = (a); i < (b); ++i)
#define _rfor(i, a, b) for(re int i = (a); i <= (b); ++i)
#define _fev(p, u) for(re int p = head[u]; p; p = nex[p])
#define inf 0x7fffffff
#define maxn 100005
#define maxnn (maxn*120) 
#define mod 1000000007ll

template <class T>
void print(string name, T arr[], int n, int flag = 1){
	cout<<name<<":";
	_for(i, 0, n)cout<<" "<<arr[i+flag];
	cout<<endl;
}

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

inline void uad(int &x, const int &y){ if ((x+=y)>=mod) x-=mod; }
template<class T>
inline void umx(T &x, const T &y){ if (y > x) x = y; }
template<class T>
inline void umi(T &x, const T &y){ if (y < x) x = y; }

ll ans = 0;

int seg_ncnt, rg, epw[maxn], one[maxn];
struct Seg{ int lc, rc, sz, hsh; } seg[maxnn];
#define lc(x) seg[x].lc
#define rc(x) seg[x].rc
#define sz(x) seg[x].sz
#define hsh(x) seg[x].hsh

int max_seg = 0;
int new_node(re int nn){
	assert(seg_ncnt+1 < maxnn);
	umx(max_seg, seg_ncnt);
	re int x = ++seg_ncnt;
	seg[x] = seg[nn];
	return x;
}

inline void ud(re int x, re int len){
	sz(x) = sz(lc(x)) + sz(rc(x));
	hsh(x) = (hsh(lc(x))+(ll)hsh(rc(x))*epw[len]%mod)%mod;
}

void adn(int x, int &y, int p, int tl, int tr){
	y = new_node(x);
	if (tl == tr){ sz(y) = 1; hsh(y) = 1; return; }
	int mi = (tl+tr)>>1;
	if (p <= mi) adn(lc(x), lc(y), p, tl, mi);
	else adn(rc(x), rc(y), p, mi+1, tr);
	ud(y, mi-tl+1); 
}

void merge(int &z, int x, int y, int tl, int tr){
	if (!x || !y){ z = x+y; return; }
	if ((hsh(x) == hsh(y) && sz(x) == sz(y)) || sz(x) == tr-tl+1){ z = x; return; }
	if (sz(y) == tr-tl+1){ z = y; return; }
	assert(tl < tr);
	int mi = (tl+tr)>>1;
	z = new_node(0);
	merge(lc(z), lc(x), lc(y), tl, mi);
	merge(rc(z), rc(x), rc(y), mi+1, tr);
	ud(z, mi-tl+1);	
}

int ecnt = 1, icnt = 0,
	head[maxn],
	to[maxn*2],
	nex[maxn*2],
	col[maxn],
	rt1[maxn],
	rt2[maxn],
	id[maxn],
	son[maxn],
	sz[maxn];
bool vis[maxn];
vector<int> adj[maxn];

void add_edge(re int u, re int v){
	to[++ecnt] = v; nex[ecnt] = head[u]; head[u] = ecnt;
	to[++ecnt] = u; nex[ecnt] = head[v]; head[v] = ecnt;
}

void get_son(int u, int fa){
	sz[u] = 1; son[u] = 0; rt1[u] = rt2[u] = 0; id[u] = ++icnt;
	_fev(p, u){
		int v = to[p];
		if (vis[v] || v == fa) continue;
		get_son(v, u);
		sz[u] += sz[v];
		if (!son[u] || sz[v] > sz[son[u]]) son[u] = v;
	}
}

int get_centroid(re int u){
	if (!son[u]) return u;
	re int S = sz[u], v;
	while(sz[v = son[u]]*2 > S) u = v;
	return u;
}

void get_cmt(int u, int c, int fa){
	col[u] = c;
	adn(rt1[fa], rt1[u], id[u], 1, rg);
	_fev(p, u){
		int v = to[p];
		if (vis[v] || v == fa) continue;
		get_cmt(v, c, u);
	}
}

void get_ans(int u, int top, int fa){
	static bool yes[maxn], flag; static int stk[maxn], tp;
	tp = 0; flag = false;
	for(auto &v : adj[u]){
		if (col[v] != col[u]){
			merge(rt2[u], rt2[u], rt1[v], 1, rg);
			v = top;
			flag = true;
		}
		if (!yes[v] && v != u) stk[tp++] = v, yes[v] = true;
	}
	adj[u].clear();
	while(tp) adj[u].push_back(stk[--tp]), yes[stk[tp]] = false;
	if (flag && top != u) adj[top].push_back(u);
	
	_fev(p, u){
		int v = to[p];
		if (vis[v] || v == fa) continue;
		get_ans(v, top, u);
		merge(rt2[u], rt2[u], rt2[v], 1, rg);
	}
	ans += sz(rt2[u]);
}

void divide(int u){
	if (!son[u]) return; icnt = 0;
	u = get_centroid(u); get_son(u, 0);
	assert(son[u]); assert(!vis[u]);
	vis[u] = true;
	
	//pf("u:%d\n", u);
	
	rg = icnt; rt1[0] = rt2[0] = seg_ncnt = 0;
	adn(0, rt1[u], id[u], 1, rg);
	int ccnt = col[u] = 1;
	_fev(p, u){
		int v = to[p];
		if (vis[v]) continue;
		++ccnt;
		get_cmt(v, ccnt, u);
	}
	
	_fev(p, u){
		int v = to[p];
		if (vis[v]) continue;
		get_ans(v, v, u);
		merge(rt2[u], rt2[u], rt2[v], 1, rg);
	}
	for(auto &v : adj[u]){
		if (col[v] != col[u]){
			merge(rt2[u], rt2[u], rt1[v], 1, rg);
		}
	}
	if (sz(rt2[u])) ans += sz(rt2[u])-1;
	//pf("ans:%lld\n", ans);
	
	//nl();
	_fev(p, u) if (!vis[to[p]]) divide(to[p]);
}

void init(re int n){
	rt1[0] = rt2[0] = 0;
	seg[0] = {0, 0, 0, 0};
	epw[0] = one[0] = 1;
	_rfor(i, 1, n) epw[i] = (epw[i-1]<<1)%mod, one[i] = (one[i-1]<<1|1)%mod;
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
	//freopen("sample.out", "w", stdout);
	#endif

	re int n = rdnt(), m = rdnt();
	init(n);
	_rfor(i, 1, n-1) add_edge(rdnt(), rdnt());
	_rfor(i, 1, m){
		re int s = rdnt(), t = rdnt();
		adj[s].push_back(t);
		adj[t].push_back(s);
	}
	
	get_son(1, 0);
	divide(1);
	
	assert((ans&1) == 0);
	pf("%lld\n", ans/2);
	//pf("%d\n", max_seg);

	return 0;
}
```

---

## 作者：yzhang (赞：4)

[原题传送门](https://www.luogu.org/problemnew/solution/P5327)

[更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/11223298.html)

看到这种树上统计点对个数的题一般是线段树合并，这题也不出意外

先对这棵树进行树剖，对于每次普及语言，在$x，y$两点的线段树上的$x，y$两位置打$+1$标记，在点$fa[lca(x,y)]$的线段树上$x，y$两位置打$-2$标记

线段树中该维护三个东西：

1.dfs序最小的$lp$ 

2.dfs序最大的$rp$ 

3.线段树中所有被打标机的点到根节点路径的并的节点个数$sum$

我们进行搜索并从下向上的进行线段树合并，对于每个节点，对答案的贡献就是该节点线段树的根节点的$sum-dep[lca(lp,rp)]+1-1$（珂以画图理解一下）

交上去，发现wa了，因为每条路径的贡献被我们算了$2$次，所以除以2即可

```cpp
#include <bits/stdc++.h>
#define N 100005 
#define ll long long 
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register ll x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
int n,m;
ll ans;
struct edge{
    int to,next;
}e[N<<1];
int head[N],cnt=0;
inline void add(register int u,register int v)
{
    e[++cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
int size[N],fa[N],son[N],dep[N],top[N],dfn[N],tim,idfn[N];
inline void dfs1(register int x)
{
    size[x]=1;
    for(register int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa[x])
            continue;
        dep[v]=dep[x]+1;
        fa[v]=x;
        dfs1(v);
        size[x]+=size[v];
        if(size[v]>size[son[x]])
            son[x]=v;
    }
}
inline void dfs2(register int x,register int t)
{
    dfn[x]=++tim;
    idfn[tim]=x;
    top[x]=t;
    if(son[x])
        dfs2(son[x],t);
    for(register int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v!=fa[x]&&v!=son[x])
            dfs2(v,v);
    }
}
inline int getlca(register int x,register int y)
{
    int fx=top[x],fy=top[y];
    while(fx!=fy)
    {
        if(dep[fx]<dep[fy])
        {
            x^=y^=x^=y;
            fx^=fy^=fx^=fy;
        }
        x=fa[fx];
        fx=top[x];
    }
    return dep[x]<dep[y]?x:y;
}
int root[N],tot;
struct node{
    int ls,rs,cnt,lp,rp,sum;
}tr[N*60];
inline void pushup(register int x)
{
    tr[x].lp=tr[tr[x].ls].lp?tr[tr[x].ls].lp:tr[tr[x].rs].lp;
    tr[x].rp=tr[tr[x].rs].rp?tr[tr[x].rs].rp:tr[tr[x].ls].rp;
    tr[x].sum=tr[tr[x].ls].sum+tr[tr[x].rs].sum;
    if(tr[tr[x].ls].rp&&tr[tr[x].rs].lp)
        tr[x].sum-=dep[getlca(tr[tr[x].ls].rp,tr[tr[x].rs].lp)];
}
inline void modify(register int &x,register int l,register int r,register int pos,register int val)
{
    if(!x)
        x=++tot;
    if(l==r)
    {
        tr[x].cnt+=val;
        if(tr[x].cnt)
            tr[x].lp=tr[x].rp=pos,tr[x].sum=dep[pos];
        else
            tr[x].lp=tr[x].rp=tr[x].sum=0;
        return;
    }
    int mid=l+r>>1;
    if(dfn[pos]<=mid)
        modify(tr[x].ls,l,mid,pos,val);
    else
        modify(tr[x].rs,mid+1,r,pos,val);
    pushup(x);
}
inline void merge(register int &a,register int b,register int l,register int r)
{
    if(!a||!b)
    {
        a=a+b;
        return;
    }
    if(l==r)
    {
        tr[a].cnt+=tr[b].cnt;
        if(tr[a].cnt)
            tr[a].lp=tr[a].rp=idfn[l],tr[a].sum=dep[idfn[l]];
        else
            tr[a].lp=tr[a].rp=tr[a].sum=0;
        return;
    }
    int mid=l+r>>1;
    merge(tr[a].ls,tr[b].ls,l,mid);
    merge(tr[a].rs,tr[b].rs,mid+1,r);
    pushup(a);
}
inline void dfs(register int x)
{
    for(register int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa[x])
            continue;
        dfs(v);
        merge(root[x],root[v],1,tim);
    }
    if(tr[root[x]].lp&&tr[root[x]].rp)
        ans+=tr[root[x]].sum-dep[getlca(tr[root[x]].lp,tr[root[x]].rp)];
}
int main()
{
    n=read(),m=read();
    for(register int i=1;i<n;++i)
    {
        int u=read(),v=read();
        add(u,v),add(v,u);
    }
    dfs1(1);
    dfs2(1,0);
    for(register int i=1;i<=m;++i)
    {
        int x=read(),y=read();
        int lca=getlca(x,y);
        modify(root[x],1,tim,x,1);
        modify(root[x],1,tim,y,1);
        modify(root[y],1,tim,x,1);
        modify(root[y],1,tim,y,1);
        if(lca>1)
        {
            modify(root[fa[lca]],1,tim,x,-2);
            modify(root[fa[lca]],1,tim,y,-2);
        }
    }
    dfs(1);
    write(ans>>1);
    return 0;
}
```

---

## 作者：s_r_f (赞：4)

有序二元组不太好算，我们先算出无序二元组，最后再把$ans/2$.

考虑对每一个节点$i$统计$ans$.

对于经过$i$的所有询问路径，其中的所有点$j(j≠i)$都可以形成点对$(i,j)$

所以我们要求的是这些路径上的点集的并的大小。

找出这些所有可行路径的$s$和$t$,把它们作为关键点，容易发现所有关键点形成的极小联通子树就是路径上的点集的并。

那么我们要解决的问题就变成了[SDOI2015 寻宝游戏](https://www.luogu.org/problemnew/show/P3320)，把关键点按照$dfs$序排序，然后统计  极小联通子树的边数  ，因为点数 $=$ 边数 $+$ $1$,又因为要去掉点$i$,所以点 $i$ 对 $ans$ 的贡献就是点数$-1$,即  极小联通子树的边数  。

考虑用线段树维护这个贡献。

在线段树的叶子节点保存$dfs$序为$i$的节点作为关键点出现的次数，如果它$>0$,就表示它在关键点集合中。

在线段树上维护当前区间中关键点$dfs$序的$min$和$max$,和当前区间中关键点组成的极小联通子树的边数$sum$。

$min$和$max$很好维护，$sum$的维护方式参见[SDOI2015 寻宝游戏](https://www.luogu.org/problemnew/show/P3320)的解法，可以做到$O(lca())$的复杂度，即查询$O(1)$次$LCA$的复杂度。

所以 $update$的复杂度 $ = O(lca())$

那么我们就可以$O(update * logn)$支持对这个次数的$+1/-1$操作。

但是我们又不能每个点$O(m)$插入，否则$O(update * nmlogn)$直接$T$飞

维护次数不难想到**树上差分**.对于一组询问,$u++,v++,lca--,fa[lca]--$即可。

因为每个节点$x$要用到它的儿子的状态，而且我们不能直接开$n$棵线段树，

那就要用到**线段树合并**。

线段树合并有$O(nlogn)$次访问节点$($也就意味着$O(nlogn)$次$update)$

所以建议写树剖/欧拉序$+st$表，~~倍增~~$LCA$~~空间大，而且是满的~~$log$,~~就算了吧~~

复杂度$O(nlogn) * O(update)$,

树剖$O(nlog^2n)$,欧拉序$+st$表$O(nlogn)$.

代码很短，但是细节很多。$($比如线段树合并数组开大,$update$求距离特判$0)$


~~听说有~~ $O(nlog^3n)$ ~~而且还能过掉的代码~~ $?$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline LL read(){
    LL x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(LL x){
    if (x < 0) putchar('-'),x = -x;
    if (x > 9) write(x/10); putchar(x%10+'0');
}
inline void writeln(LL x){ write(x),putchar('\n'); }
const int N = 100050;
int n,m;
int To[N<<1],Ne[N<<1],He[N],k = 0;
inline void add(int x,int y){ ++k; To[k] = y,Ne[k] = He[x],He[x] = k; } 
int fa[N],dpt[N],size[N],son[N];
void dfs1(int x){
	dpt[x] = dpt[fa[x]] + 1,size[x] = 1;
	for (int y,p = He[x]; p ; p = Ne[p]) if ((y=To[p])^fa[x]){
		fa[y] = x,dfs1(y),size[x] += size[y];
		if (size[y] > size[son[x]]) son[x] = y;
	}
}
int id[N],pos[N],top[N],Time = 0;
void dfs2(int x){
	id[x] = ++Time; pos[Time] = x;
	if (son[x]){
		top[son[x]] = top[x],dfs2(son[x]);
		for (int y,p = He[x]; p; p = Ne[p]) if (!top[y=To[p]]) top[y] = y,dfs2(y);
	}
}
inline int LCA(int x,int y){
	while (top[x] ^ top[y]){ if (dpt[top[x]] <= dpt[top[y]]) swap(x,y); x = fa[top[x]]; }
	return dpt[x] <= dpt[y] ? x : y;
}
inline int Dis(int x,int y){ x = pos[x],y = pos[y]; return (!x || !y) ? 0 : dpt[x] + dpt[y] - dpt[LCA(x,y)] * 2; }
vector<int>G[N];
int lc[N*70],rc[N*70],mn[N*70],mx[N*70],cnt,val[N*70],sum[N*70];
inline void up(int o){
	mn[o] = mn[lc[o]] ? mn[lc[o]] : mn[rc[o]];
	mx[o] = mx[rc[o]] ? mx[rc[o]] : mx[lc[o]];
	sum[o] = sum[lc[o]] + sum[rc[o]] + Dis(mx[lc[o]],mn[rc[o]]) + Dis(mn[o],mx[o]) - Dis(mn[lc[o]],mx[lc[o]]) - Dis(mn[rc[o]],mx[rc[o]]);
}
void Modify(int &o,int l,int r,int p,int v){
	if (!o) o = ++cnt;
	if (l == r){ val[o] += v; if (val[o]) mn[o] = mx[o] = l; else mn[o] = mx[o] = 0; }
	else{
		int mid = l + r >> 1;
		if (p <= mid) Modify(lc[o],l,mid,p,v); else Modify(rc[o],mid+1,r,p,v);
		up(o);
	}
}
inline int Query(int o){ return sum[o] / 2; }
inline void Merge(int &x,int y,int l,int r){
	if (!x || !y) { x |= y; return;}
	if (l == r){ val[x] += val[y]; if (val[x]) mn[x] = mx[x] = l; else mn[x] = mx[x] = 0; return; }
	int mid = l + r >> 1; Merge(lc[x],lc[y],l,mid); Merge(rc[x],rc[y],mid+1,r); up(x);
}
LL ans;
int T[N];
void work(int x){
	for (int y,p = He[x]; p; p = Ne[p]) if ((y=To[p]) != fa[x]) work(y),Merge(T[x],T[y],1,n);
	for (int i = 0; i < G[x].size(); ++i) Modify(T[x],1,n,G[x][i],-1);
	ans += Query(T[x]);
}
int main(){
	int i,u,v,w;
	n = read(),m = read();
	for (i = 1; i < n; ++i) u = read(),v = read(),add(u,v),add(v,u);
	dfs1(1),top[1] = 1,dfs2(1);
	while (m--){
		u = read(),v = read(),w = LCA(u,v);
		Modify(T[u],1,n,id[u],1),Modify(T[u],1,n,id[v],1);
		Modify(T[v],1,n,id[u],1),Modify(T[v],1,n,id[v],1);
		G[w].push_back(id[u]),G[w].push_back(id[v]);
		w = fa[w],G[w].push_back(id[u]),G[w].push_back(id[v]);
	}
	work(1);
	writeln(ans/2);
    return 0;
}
```

---

## 作者：Varuxn (赞：3)

> [**P5327 [ZJOI2019]语言**](https://www.luogu.com.cn/problem/P5327)

> [推销](https://www.cnblogs.com/Varuxn/p/14980663.html)

# 解题思路
## 暴力
首先讲一下我垃圾的 40pts 的暴力（其他 dalao 都是 60pts 起步）：

当然评测机快的话（比如 LOJ 的），可以卡过 3,4 个点（逃。

对于 1,2 测试点的话，我们直接记录两个节点之间路径上的所有点，然后用一个二维数组存一下两个点是否能互相贸易。

最后暴力求 ans 就好了。。

然后我们看到了链的部分分，然后就是在序列上的处理了：

对于每一个操作，我们记录下左右端点，然后按照左端点为第一关键字，右端点为第二关键字进行排序。

把各个操作分成若干组，保证每一组的最左端的点比前一组的所有的右端点都要大。

然后对于不同组的第一个直接给答案加上  $C_{r-l+1}^2$ ，也就是 $\dfrac{(r-l)\times(r-l+1)}{2}$  。

对于同一组的，如果该区间在本组此前的区间内，那么它就没有贡献。

否则把它在组内的长度乘上在组外的长度还有组外边长度的自由组合。

设此时这一组的右端点是 maxr，贡献就是 $(r-maxr)\times(maxr-l)+\dfrac{(r-maxr)\times(r-maxr+1)}{2}$ 。

[$code$](https://www.luogu.com.cn/paste/vp4s24nt)

## 正解
正解的做法就比较神仙了，算法方面就是**线段树合并+动态开点+树上差分**，在加上一点**虚树**的思想。

对于每个点建一棵线段树，然后再树上差分线段树合并就是各个节点对于答案的贡献了，因此，现在的问题在于对每个节点的处理。

不难发现有以下性质：

> 对于所有可以与 x 贸易的点实际上就构成了一个生成树，也可以叫做联通块。

如果点 s 和 t 的路径会经过点 x ，那么我们称 s 和 t 为 x 的两个极远点，那么就有了以下结论：

> x 的生成树大小其实就是能把 x 的所有极远点的最小生成树。

为了方便，我们硬点存在极远点 1 ，最后再除去 1 的贡献。

然后，如果我们现在需要把 y 点加入到 x 的生成树里，其实就是需要把该生成树里距离 y 最近的点与 y 连起来。

假设那个点是 z ，那么 y 的贡献就是 $dep_y-dep_{\operatorname{lca}(y,z)}$ 。

对于 1 点的贡献其实就是所有点的 lca 的 dep 之和。

在线段树上进行操作时，存储四个值：操作数，两个极远点，贡献

接下来就是转移了，因为线段树是建立在时间戳上的，所以对于一个区间来说，两个极远点一定分别来自左右两个子区间。

对于两个子区间在向上更新时不能单纯的只记为两个区间的加和，贡献还应该算上两个子区间之间最近的节点连接起来的贡献，也就是这两个节点的 lca 的 dep 值。

最后就是实现细节了：注意下时间戳和标号之间的转化就好了。

对于求 lca 的时候可以用  $\mathcal{O}(1)$ 查询的优秀 RMQ-ST 算法 但是貌似，树链剖分的  $\mathcal{O}(n)$ 预处理更快一些，其实都大同小异了。。

## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10,M=N<<1;
int n,m,tot,ans,root[N];
int tim,dfn[N],id[N],siz[N],son[N],dep[N],topp[N],fa[N];
vector<int> del[N];
struct Edge
{
	int tot,head[N],nxt[M],ver[M];
	void add(int x,int y)
	{
		ver[++tot]=y;
		nxt[tot]=head[x];
		head[x]=tot;
	}
}e;
struct Vector_Tree
{
	int l,r,s,t,dat,f;
}tre[N*80];
void pre_dfs(int x)
{
	siz[x]=1;
	for(int i=e.head[x];i;i=e.nxt[i])
	{
		int to=e.ver[i];
		if(to==fa[x])
			continue;
		fa[to]=x;
		dep[to]=dep[x]+1;
		pre_dfs(to);
		siz[x]+=siz[to];
		if(siz[to]>siz[son[x]])
			son[x]=to;
	}
}
void pre_dfs(int x,int tp)
{
	topp[x]=tp;
	dfn[x]=++tim;
	id[tim]=x;
	if(son[x])
		pre_dfs(son[x],tp);
	for(int i=e.head[x];i;i=e.nxt[i])
		if(!dfn[e.ver[i]])
			pre_dfs(e.ver[i],e.ver[i]);
}
int LCA(int x,int y)
{
	if(!x||!y)	return 0;
	while(topp[x]^topp[y])
	{
		if(dep[topp[x]]<dep[topp[y]])
			swap(x,y);
		x=fa[topp[x]];
	}
	if(dep[x]>dep[y])
		swap(x,y);
	return x;
}
void push_up(int x)
{
	tre[x].s=(tre[tre[x].l].s?tre[tre[x].l].s:tre[tre[x].r].s);
	tre[x].t=(tre[tre[x].r].t?tre[tre[x].r].t:tre[tre[x].l].t);
	if(!tre[tre[x].l].t||!tre[tre[x].r].s)	tre[x].f=tre[tre[x].l].f+tre[tre[x].r].f;
	else	tre[x].f=tre[tre[x].l].f+tre[tre[x].r].f-dep[LCA(tre[tre[x].l].t,tre[tre[x].r].s)];
}
void insert(int &x,int l,int r,int pos,int num)
{
	if(!x)	x=++tot;
	if(l==r)
	{
		tre[x].dat+=num;
		tre[x].s=tre[x].t=(tre[x].dat?id[pos]:0);
		tre[x].f=(tre[x].dat?dep[id[pos]]:0);
		return ;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)	insert(tre[x].l,l,mid,pos,num);
	else	insert(tre[x].r,mid+1,r,pos,num);
	push_up(x);
}
void merge(int &x,int y,int l,int r)
{
	if(!x||!y)
	{
		x|=y;
		return ;
	}
	if(l==r)
	{
		tre[x].dat+=tre[y].dat;
		tre[x].f=(tre[x].f?tre[x].f:tre[y].f);
		tre[x].s=(tre[x].s?tre[x].s:tre[y].s);
		tre[x].t=(tre[x].t?tre[x].t:tre[y].t);
		return ;
	}
	int mid=(l+r)>>1;
	merge(tre[x].l,tre[y].l,l,mid);
	merge(tre[x].r,tre[y].r,mid+1,r);
	push_up(x);
}
int query(int x)
{
	return tre[x].f-dep[LCA(tre[x].s,tre[x].t)];
}
void redfs(int x)
{
	for(int i=e.head[x];i;i=e.nxt[i])
		if(e.ver[i]!=fa[x])
			redfs(e.ver[i]);
	for(int i=0;i<del[x].size();i++)
		insert(root[x],1,tim,dfn[del[x][i]],-1);
	ans+=query(root[x]);
	merge(root[fa[x]],root[x],1,tim);
}
#undef int
int main()
{
	#define int register long long
	#define ll long long
	scanf("%lld%lld",&n,&m);
	for(int i=1,x,y;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		e.add(x,y);
		e.add(y,x);
	}
	pre_dfs(1);
	pre_dfs(1,1);
	for(int i=1,x,y;i<=m;i++)
	{
		scanf("%lld%lld",&x,&y);
		insert(root[x],1,tim,dfn[x],1);
		insert(root[x],1,tim,dfn[y],1);
		insert(root[y],1,tim,dfn[x],1);
		insert(root[y],1,tim,dfn[y],1);
		int lca=LCA(x,y);
		del[lca].push_back(x);
		del[lca].push_back(y);
		del[fa[lca]].push_back(x);
		del[fa[lca]].push_back(y);
	}
	redfs(1);
	printf("%lld\n",ans/2ll);
	return 0;
}
```

---

## 作者：Refined_heart (赞：3)

[Problem](https://www.luogu.com.cn/problem/P5327)

$\text{Solution:}$

菜鸡太菜了想了好久没有思路……只知道要求树上链的并集但不知道咋整……虽然题目算法线段树合并和树上差分看到题就能想到……但是怎么做还是有思维难度……（对笔者来说）

看了好久的题解都没有看懂 这次写的详细一点。

* 所谓矩阵面积并

某些题解中说了一句 “可以用树剖套扫描线” “就是一个矩阵面积并” 的做法，复杂度 $O(n\log^3 n).$

实际上，我们对树进行树剖后，每一条路径 $(s,t)$ 都可以被划分为 $\log n$ 个线段。我们可以把每一段被划分的重链区间看做矩形，那我们对每个点求的链并集，实际上就是一个抽象的 “矩形面积并” 。

复杂度是树剖的 $\log$ 和扫面线本身的两个 $\log$. 我没有实现这种做法。

* 线段树合并、树上差分与树剖

常规的 $\log^2 n$ 做法是这个。

由于有序对不好算，我们可以算无序对的个数，除以二即可。

记 $S_u$ 表示 $u$ 可以到达的点的集合（不包括它自己）。那么 $ans=\frac{\sum S_i}{2}.$

如何对每一个点计算出它的 $S$ 呢？

首先明确一点：我们对每一个点建立的线段树是一棵 以 dfs序 为基础的线段树，它维护了整棵树的信息。

那么，对每一个点都有这样一棵线段树，对于每一个语言传递过程，我们在路上的每一个点上都进行一次区间覆盖操作，最终每一个点上线段树上被覆盖的长度就是它的 $S$ .

显然这玩意复杂度不对。

首先，对树上路径修改，我们需要用到树剖。

那么对于一条路径上的点，我们可以自然想到用树上差分的思路来优化。

并不知道一棵支持区间修改的树咋合并） 上文所述，我们需要维护一棵线段树上被覆盖的长度，并且是 **全局询问** 。

那这个东西就长得很像扫描线了。 维护区间被覆盖的次数来更新即可。

那么合并呢？

合并要注意一下细节：每一次合并到的点都要记录信息，因为这种写法的区间覆盖次数没有什么下传操作，不要只在叶子上维护 pushup 操作，这样维护的信息是错误而不全面的。

其他写法都一样，复杂度是一个 $\log$.

那么总结就是：考虑暴力，每一个点都记录一下链上信息，又因为需要树上修改路径需要树剖操作，而对于一条路径上的点我们可以考虑树上差分优化，进而利用线段树合并来解决这题。

时间复杂度：$O(n\log^2 n).$

## 空间分析

之前从神鱼那里见到，空间复杂度是 $2n\log n$ 的。

计算一下：$Num=2\cdot 10^5 \cdot \log 10^5=3.32\cdot 10^6$ 级别。然而代码中，进行修改的操作达到了 $O(m\log n)$ 级别的个数，也就是多了个 $\log$ ,约为$5.5\cdot 10^7$级别。空间没有卡满，代码开到 $2\cdot 10^7$ 可以过去。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e7+10;
int ls[MAXN],rs[MAXN],topp,rub[MAXN],node;
int cnt[MAXN],len[MAXN],id[MAXN],rk[MAXN];
int rt[MAXN],pa[MAXN],siz[MAXN],son[MAXN];
int dep[MAXN],head[MAXN],tot,n,m,top[MAXN];
long long ans;
struct E {
	int nxt,to;
} e[MAXN];

inline int Max(int x,int y){return x>y?x:y;}

inline void add(int x,int y) {
	e[++tot] = ( E ) {
		head [ x ] , y
	} ;
	head[x]=tot;
}

void dfs1(int x,int fa) {
	pa [ x ] = fa ;
	siz [ x ] = 1 ;
	dep [ x ] = dep [ fa ] + 1 ;
	for ( int i=head[x]; i; i=e[i].nxt) {
		int j=e[i].to;
		if(j==fa)continue;
		dfs1(j,x);
		siz[x]+=siz[j];
		if(siz[j]>siz[son[x]])son[x]=j;
	}
}

int dfstime;
void dfs2(int u,int t) {
	top [ u ] = t ;
	id [ u ] = ++ dfstime ;
	if ( ! son [ u ] )
		return ;
	dfs2 ( son [ u ] , t ) ;
	for ( int i = head [ u ] ; i ; i = e [ i ] .nxt ) {
		int j = e [ i ] .to ;
		if ( j == son [ u ] || j == pa [ u ] )
			continue ;
		dfs2 ( j , j ) ;
	}
}

inline void del(int x) {
	rub[++topp]=x;
	len[x]=cnt[x]=ls[x]=rs[x]=0;
}

inline int New() {
	if(topp)return rub[topp--];
	return ++node;
}

inline void pushup(int x,int l,int r) {
	if(cnt[x]>0)
		len[x]=r-l+1;
	else
		len[x]=len[ls[x]]+len[rs[x]];
}

void change(int &x,int L,int R,int l,int r,int v) {
	if(!x)x=New();
	if ( l <= L && R <= r ) {
		cnt[x]+=v;
		pushup(x,L,R);
		return;
	}
	int mid=(L+R)>>1;
	if(l<=mid)change(ls[x],L,mid,l,r,v);
	if(mid<r)change(rs[x],mid+1,R,l,r,v);
	pushup(x,L,R);
}

int merge(int x,int y,int l,int r) {
	if(!x||!y)return x+y;
	cnt[x]+=cnt[y];
	if(l==r) {
		pushup(x,l,r);
		del(y);
		return x;
	}
	int mid=(l+r)>>1;
	ls[x]=merge(ls[x],ls[y],l,mid);
	rs[x]=merge(rs[x],rs[y],mid+1,r);
	pushup(x,l,r);
	del(y);
	return x;
}

int query(int x,int L,int R,int l,int r) {
	if(L>=l&&R<=r)return len[x];
	int mid=(L+R)>>1,val=0;
	if(l<=mid)val+=query(ls[x],L,mid,l,r);
	if(mid<r)val+=query(rs[x],mid+1,R,l,r);
	return val;
}

void changes(int root,int x,int y,int v) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]>=dep[top[y]]) {
			change(rt[root],1,n,id[top[x]],id[x],v);
			x=pa[top[x]];
		} else {
			change(rt[root],1,n,id[top[y]],id[y],v);
			y=pa[top[y]];
		}
	}
	if(id[x]<=id[y])change(rt[root],1,n,id[x],id[y],v);
	else change(rt[root],1,n,id[y],id[x],v);
}

inline int LCA(int x,int y) {
	while ( top [ x ] != top [ y ] ) {
		if(dep[top[x]]>=dep[top[y]])x=pa[top[x]];
		else y=pa[top[y]];
	}
	return dep [ x ] < dep [ y ] ? x : y ;
}

void dfs3 ( int x ) {
	for ( int i = head [ x ] ; i ; i = e [ i ] .nxt ) {
		int j = e [ i ] .to ;
		if ( j == pa [ x ] )
			continue ;
		dfs3 ( j ) ;
		rt [ x ] = merge ( rt [ x ] , rt [ j ] , 1 , n ) ;
	}
	ans += Max(query ( rt [ x ] , 1 , n , 1 , n ) -1,0) ;
}

signed main() {
	freopen("1.in","r",stdin);
	freopen("my.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1; i<n; ++i) {
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	for(; m; m--) {
		int s,t;
		scanf("%d%d",&s,&t);
		int lca=LCA(s,t);
		changes(s,s,t,1);
		changes(t,s,t,1);
		changes(lca,s,t,-1);
		if(lca==1)continue;
		changes(pa[lca],s,t,-1);
	}
	dfs3(1);
	ans>>=1;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：BFqwq (赞：3)

## P5327 【[ZJOI2019]语言】
~~众所周知，ZJOI 的 DS 题都是签到题~~

首先我们发现，两个城市能贸易等价于两个城市有同一种语言。记录每个城市有哪些语言，统计的时候枚举两个城市和语言，可以获得 $20$ 分的好成绩。

然后我们考虑优化这一算法，但发现好像除了加个 $bitset$ 之外没什么可以优化的东西。

接着我们更换思路。考虑每个城市可以和哪些城市进行贸易。

我们枚举城市，枚举语言，然后所有经过这个城市的语言所经过的城市全部都能与之贸易。

比如说，对于城市 $i$，第 $a_{i1},a_{i2}\ldots a_{ij}$ 是这个城市的所有语言，那么我们将所有会讲 $a_{i1},a_{i2}\ldots a_{ij}$ 这些语言中的某一种的城市取个并集，就是所有能与 $i$ 城市进行贸易的城市。

然后我们枚举城市，枚举经过该城市的语言，枚举会讲经过该城市的语言的城市，发现还是 $\operatorname{O}(n^3)$ 的，并没有什么优化。

但我们发现，由于会讲某一种语言的城市一定是一条连续的路径，那么对于任意城市，所有能与之贸易的城市实际上构成了一个连通块。

要统计一个树上的连通块的大小，自然就想到了可以使用虚树。然后这就转化为一个虚树上若干条路径取并集的题。

我们考虑挑一座城市 $i$，$a_{i1},a_{i2}\ldots a_{ij}$ 是这个城市的语言。对于每个语言所对应的路径，我们取路径的两端点，然后对所有的端点按 $dfs$ 序排序（假设已经排好）。

考虑任意一个端点 $u$，对于上一个 $dfs$ 序比它小的点（设为 $v$），要么是它的祖先，要么在他某层祖先某个与它不同的子树中。

对于第一种情况，虚树中增加的点的个数显然就是 $dep_u-dep_v=dep_u-dep_{lca(u,v)}$。

对于第二种情况可能比较难处理。这时我们可以在整棵树的根节点之上再建一个新节点（不妨编号 $0$），它是整颗数的根节点的父亲。然后我们强行把 $0$ 节点加入树中，最后再减去其贡献。

由于 $0$ 号节点在虚树中，所以上一时刻的虚树中的最后一个点（$v$）一定有一条连向 $0$ 的路径。而 $lca(u,v)$ 已经属于这条路径，所以将其加入虚树对虚树的大小没有影响。

然后我们做一个大胆的想象：

我们把 $lca(u,v),u$ 两个点分别加入虚树。这样增加的贡献就变成了 $dep_u-dep_{lca(u,v)}$。然后由于 $lca(u,v)$ 已经没用了，再把它扔出虚树（

看似好像很奇怪，但实际上这个做法没有问题。因为 $v$ 是上一个 $dfs$ 序小于 $u$ 的节点，所以在 $u$ 到 $lca(u,v)$ 的路径上一定没有任何一个节点属于这棵虚树，否则其 $dfs$ 序大于 $v$ 而小于 $u$，矛盾。

于是我们整理一下，我们在虚树中强行加入一个 $0$ 号点，然后每次加入一个点只需要加上 $dep_u-dep_{lca(u,v)}$ 即可。

然后设 $x,y$ 是虚树点集中初 $0$ 之外 $dfs$ 序最大/最小的，那么 $0$ 对虚树产生的额外的大小显然就是 $dep_lca(x,y)$ 个点，将其减去。

这一部分的确很难理解，需要对虚树和 $dfs$ 序有一定深度的了解。

然后我们对每个点建个虚树，就可以得到 $\operatorname O(n^2)$ 的做法，获得 $40$ 分的好成绩。

再然后，我们考虑优化这个虚树。由于我们发现，对于一条路径，其所有的点是连续的，那么我们相当于要在这条连续的路径上插入一堆相同的虚树点。

于是我们想到了差分。对某一条路径（设为 $u,v$），在 $u,v$ 处的虚树各插入一个 $u,v$，在 $lca(u,v)$ 和 $fa_{lca(u,v)}$ 处的虚树各删一个 $u,v$，然后用某种数据结构维护一下虚树大小，并向上合并。

而想到动态维护以及合并，最容易想到的就是线段树。在线段树的叶子节点，我们**记录 $dfn$ 为对应值的节点是否在虚树中**，这样我们就成功的解决了按 $dfs$ 排序的步骤。

然后对于每个线段树节点，我们记 $l,r$ 表示的区间，$v$ 表示这个区间内所有的点和 $0$ 号点构成的虚树大小，$mn,mx$ 为这个节点内 $dfs$ 序最小/大的节点。

上传的时候左右虚树大小相加，减去 $dep_{lca(ls->mx,rs->mn)}$，在查询虚树总大小的时候别忘了减去 $dep_{lca(rt->mn,rt->mx)}$ 来去除 $0$ 号点的贡献。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-48;
		ch=getchar();
	}
	return f?-x:x;
} 
char str[300];int kkk;
inline void print(register int x,register char k='\n'){
	if(!x) putchar('0');
	if(x<0) putchar('-'),x=-x;
	while(x){
		str[++kkk]=x%10+48;
		x/=10;
	}
	while(kkk){
		putchar(str[kkk--]);
	}
	putchar(k); 
}
const int maxn=2e5+10;
vector<int> e[maxn];
int n,m;long long ans;
int fa[maxn],son[maxn],dep[maxn],sz[maxn];
int top[maxn],dfn[maxn],pos[maxn],tot;
void dfs1(int u,int f){
	dep[u]=dep[f]+1;
	fa[u]=f;
	sz[u]=1;
	for(int v:e[u]){
		if(v==fa[u]) continue;
		dfs1(v,u);
		sz[u]+=sz[v];
		if(sz[son[u]]<sz[v]){
			son[u]=v;
		}
	}
}
void dfs2(int u,int o){
	top[u]=o;dfn[u]=++tot;
	pos[tot]=u;
	if(!son[u]) return;
	dfs2(son[u],o);
	for(int v:e[u]){
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
int lca(int u,int v){
	if(u==0||v==0) return 0;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	return u;
}
struct seg{
	int v,mn,mx,ls,rs,cnt;
}t[maxn*75];int st[maxn*75],tops,rt[maxn],cnt;
int nnd(){
	return tops?st[tops--]:++cnt;
}
void del(int &o){
	if(!t[o].v&&!t[o].mn&&!t[o].mx&&!t[o].cnt&&!t[o].ls&&!t[o].rs){
		st[++tops]=o;
		o=0;
	} 
}
void pushup(int o){
	int lc=lca(pos[t[t[o].ls].mx],pos[t[t[o].rs].mn]);
	t[o].v=t[t[o].ls].v+t[t[o].rs].v-dep[lc];
	t[o].mn=t[t[o].rs].mn;if(t[t[o].ls].mn) t[o].mn=t[t[o].ls].mn;
	t[o].mx=t[t[o].ls].mx;if(t[t[o].rs].mx) t[o].mx=t[t[o].rs].mx;
}
void change(int &o,int l,int r,int q,int v){
	if(!o) o=nnd();
	if(l==r){
		t[o].cnt+=v;
		if(t[o].cnt>0){
			t[o].v=dep[pos[l]];
			t[o].mn=t[o].mx=l;
		}
		else{
			t[o].v=t[o].mn=t[o].mx=0;
		}
		del(o);
		return;
	}
	int mid=l+r>>1;
	if(q<=mid) change(t[o].ls,l,mid,q,v);
	else change(t[o].rs,mid+1,r,q,v);
	pushup(o);del(o);
}
int query(int o){
	int lc=lca(pos[t[o].mn],pos[t[o].mx]);
	return t[o].v-dep[lc];
}
void merge(int &o1,int &o2,int l,int r){
	if(!o2) return;
	if(!o1){
		o1=o2;
		return;
	}
	if(l==r){
		t[o1].cnt+=t[o2].cnt;
		if(t[o1].cnt>0){
			t[o1].v=dep[pos[l]];
			t[o1].mn=t[o1].mx=l;
		}
		else{
			t[o1].v=t[o1].mx=t[o1].mn=0;
		}
		t[o2].v=t[o2].mx=t[o2].mn=t[o2].cnt=0;
		del(o2);del(o1);
		return;
	}
	int mid=l+r>>1;
	merge(t[o1].ls,t[o2].ls,l,mid);
	merge(t[o1].rs,t[o2].rs,mid+1,r);
	pushup(o1);t[o2].v=t[o2].mn=t[o2].mx=0;
	del(o1);del(o2);
}
void dfs(int u){
	for(int v:e[u]){
		if(v==fa[u]) continue;
		dfs(v);
		merge(rt[u],rt[v],1,n);
	}
	ans+=query(rt[u]);
}
signed main(){
	n=read();m=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		int lc=lca(u,v);
        change(rt[u],1,n,dfn[u],1);
		change(rt[u],1,n,dfn[v],1);
        change(rt[v],1,n,dfn[u],1);
		change(rt[v],1,n,dfn[v],1);
		change(rt[lc],1,n,dfn[u],-1);
		change(rt[lc],1,n,dfn[v],-1);
		change(rt[fa[lc]],1,n,dfn[u],-1);
		change(rt[fa[lc]],1,n,dfn[v],-1);
	}
	dfs(1);
	print(ans>>1);
	return 0;
}
```


---

## 作者：Alear (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P5327)

#### 题意

给定一棵 $n$ 个节点的树，以及 $m$ 条链，求有对少对点至少存在一条链同时覆盖这两个点。

$n,m\leqslant 10^5$

#### 题解

这真的是非常有启发性的一道题。

首先需要一个模型的转换，直接枚举点对是不行的，我们考虑从点开始统计，可以发现 $u$ 可以到达的点都在一个联通块内，这个联通块的大小就是所有经过 $u$ 链并起来之后的大小。这时候答案就等于所有点所在的链并大小之和与$n$之差除以2，毕竟不能把自己和自己算在内。  

之后考虑如何维护链并的大小，这东西和虚树有点类似。  
直接上结论，链并的大小 $-1=\sum_{u\in S}d_u - \sum_{u,v\text{相邻}}d_{lca(u,v)}$。  
其中$S$表示链端点的集合，$d$为一个点到根节点的路径上的点数，相邻指$dfs$序相邻，包含首尾相邻。

先不考虑首尾两个点的$lca$，想象这样一个过程：从左到右往集合里面加点，更新所有点到根的并的大小，即$+d_u-d_{lca(u,last)}$，求出点到根的并之后再减去首尾两点的$lca$，即这个连通块的根的深度，最终恰好等于链并减一（减去了连通块的根）。

这玩意显然是有区间可加性的，所以只需要对$dfs$序建一棵线段树，实际在节点的维护中可以不减去首尾的$lca$，注意不能乱删节点。

剩下的就是树上差分和线段树合并，这些虽然比较套路。

```cpp
#include<bits/stdc++.h>
#define next nxt
#define int long long
using namespace std;
int read(){
	int c=0,nx,sign=1;
	while(!isdigit(nx = getchar()))
		if(nx=='-')
			sign=-1;
	while(isdigit(nx))
		c=c*10+nx-'0',nx=getchar();
	return sign*c;
}

const int N=2e5+20,M=N*2,K=1e7;
int head[N],next[M],ver[M];
inline void addEdge(int u,int v){
	static int now = 0;
	next[++now]=head[u],head[u]=now,ver[now]=v;
	next[++now]=head[v],head[v]=now,ver[now]=u;
}


int n, m;
int id[N], stk[N], top;
namespace lca_rmq{
	int d[N];
	int s[2*N], cnt;//dfs序 
	int id[N];//第一次出现的位置 
	int st[2*N][20], p[30];
	int lg[N];
	int fa[N];
	void dfs(int u,int f){
		stk[++top] = u;
		s[++cnt] = u;
		id[u] = cnt;
		d[u] = d[f] + 1;
		fa[u] = f;
		for(int i=head[u];i;i=next[i])
			if(ver[i] != f)
				dfs(ver[i], u), s[++cnt] = u;
	
	}
	
	inline int dmax(int x,int y){
		return d[x] < d[y] ? x : y;
	}
	
	void ST(){
		p[0] = 1;
		for(int i=1;i<=20;i++)
			p[i] = p[i - 1] << 1;
		
		for(int i=1;i<=cnt;i++)
			st[i][0] = s[i];
		
		for(int k=1;p[k]<=cnt;k++){
			for(int i=1;i+p[k]-1<=cnt;i++)
				st[i][k] = dmax(st[i][k - 1], st[i + p[k - 1]][k - 1]);
		}
	}
	int lca(int u,int v){
		if(!u or !v)
			return 0;
		u = id[u], v = id[v];
		if(u > v)
			swap(u, v);
		int k = lg[v - u];
		return dmax(st[u][k], st[v - p[k] + 1][k]); 
	}
	int dist(int u,int v){
		return d[u] + d[v] - 2 * d[lca(u, v)];
	}
	void init(int u=1){
		for(int i=1;i<=n<<1;i++)
			lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);
		for(int i=1;i<=n<<1;i++)
			--lg[i];
		d[u] = 1;
		dfs(u, 0);
		ST();
	}
}
using lca_rmq::d;
using lca_rmq::lca;
using lca_rmq::fa;

long long ans;
typedef pair<int, int> pii;
vector<int> c[N];
int root[N];
int dat[K], cnt[K], lt[K], rt[K];
int ls[K], rs[K];
// int rub[K/2], rub_top;

void print(int s, int l=1,int r=n){
	if(!s)
		return ;
	if(l >= r){
		cerr<<lt[s]<<' ';
		return ;
	}
	int mid = (l + r) >> 1;
	print(ls[s], l, mid);
	print(rs[s], mid + 1, r);
}

inline int New(){
	static int now = 0;
	return ++now;
}
// inline void del(int &s){
// 	// cerr<<"del "<<s<<endl;
// 	if(!s)
// 		return ;
// 	del(ls[s]);
// 	del(rs[s]);
// 	cnt[s] = dat[s] = lt[s] = rt[s] = 0;
// 	rub[++rub_top] = s;
// 	s = 0;
// }
inline void pushup(int s){
	if(!cnt[ls[s]] or !cnt[rs[s]]){
		int t = cnt[ls[s]] ? ls[s] : rs[s];
		dat[s] = dat[t];
		lt[s] = lt[t];
		rt[s] = rt[t];
		cnt[s] = cnt[t];
	}else{
		dat[s] = dat[ls[s]] + dat[rs[s]] - d[lca(rt[ls[s]], lt[rs[s]])];
		cnt[s] = cnt[ls[s]] or cnt[rs[s]];
		lt[s] = lt[ls[s]];
		rt[s] = rt[rs[s]];
	}
}
void add(int p, int x, int &s, int l=1, int r=n){
	if(!s)
		s = New();
	cnt[s] += x;
	if(l >= r){
		int u = stk[l];
		lt[s] = rt[s] = u;
		dat[s] = d[u];
		return ;
	}
	int mid = (l + r) >> 1;
	if(p <= mid)
		add(p, x, ls[s], l, mid);
	if(p > mid)
		add(p, x, rs[s], mid + 1, r);
	pushup(s);
}
inline int query(int s){
	if(!cnt[s])
		return 0;
	else
		return dat[s] - d[lca(lt[s], rt[s])];
}
int merge(int x, int y, int l = 1, int r = n){
	if(!x or !y)
		return x | y;
	if(l == r){
		cnt[x] += cnt[y];
		return x;
	}
	int mid = (l + r) >> 1;
	ls[x] = merge(ls[x], ls[y], l, mid);
	rs[x] = merge(rs[x], rs[y], mid + 1, r);
	pushup(x);
	return x;
}

void dfs(int u, int f){
	for(int i=head[u];i;i=next[i]){
		int v = ver[i];
		if(v == f)
			continue;
		dfs(v, u);
		root[u] = merge(root[u], root[v]);
	}
	for(int i=0,tt=c[u].size();i<tt;i++){
		int v = c[u][i];
		if(v < 0)
			add(id[-v], -2, root[u]);
		else
			add(id[v], 1, root[u]);
	}
	// cerr<<"ans"<<u<<' '<<query(root[u])<<endl;
	// print(root[u]);
	// cerr<<endl;
	
	ans += query(root[u]);
}

signed main(){
	// freopen("language7.in", "r", stdin);
	// cerr<<(-1 and 0)<<endl;
	n = read(), m = read();
	for(int i=1;i<n;i++)
		addEdge(read(), read());
	
	lca_rmq::init();
	for(int i=1;i<=n;i++)
		id[stk[i]] = i;
	// cerr<<d[lca(0, 0)]<<endl;
	// cerr<<"stk ";
	// for(int i=1;i<=n;i++)
	// 	cerr<<stk[i]<<' ';
	// cerr<<endl;
	
	// cerr<<"id ";
	// for(int i=1;i<=n;i++)
	// 	cerr<<id[i]<<' ';
	// cerr<<endl;
	
	// cerr<<"d ";
	// for(int i=1;i<=n;i++)
	// 	cerr<<d[i]<<' ';
	// cerr<<endl;
	
	for(int i=1;i<=m;i++){
		int u = read(), v = read(), f = fa[lca(u, v)];
		c[u].push_back(u);
		c[u].push_back(v);
		
		c[v].push_back(v);
		c[v].push_back(u);
		
		c[f].push_back(-u);
		c[f].push_back(-v);
	}
	
	// for(int i=0;i<=n;i++){
	// 	cerr<<'*'<<i<<' ';
	// 	for(auto v:c[i])
	// 		cerr<<v<<' ';
	// 	cerr<<endl;
	// }
	
	dfs(1, 0);
	
	printf("%lld\n", ans/2);
}

```


---

## 作者：KokiNiwa (赞：3)

# [ZJOI 2019] 语言

这是一个非常有思维的题目。（神犇们都能秒切。。。而我太菜了）

可能语言表达不太清楚。。。请多多包涵（毕竟看不懂可以看其他题解对不对）。

[题目链接](https://www.luogu.com.cn/problem/P5327)

## 题目叙述

给你一棵树，两个点成为联通当且仅当存在一种颜色使得两点间的路径上都有该颜色。现在有$m$个颜色，每种颜色进行一次染色，把$u,v$上的所有点都染上该颜色。求最终一共有多少对点联通。当前颜色并不会覆盖前一个颜色。

## 题解

可以发现，每个点可以到达的点构成一个连通块。**对于这个连通块，一定是一些颜色的两个端点的生成树构成的。**计算几个点的生成树大小可以参考寻宝游戏的[解法](https://www.cnblogs.com/PinkRabbit/p/10356940.html)。为了得到这些点（就是端点），可以差分地类似于雨天的尾巴一样算出每个点上有哪些端点。但不但要计算端点，还要算每个点的生成树大小，那么我们就在线段树上每个节点上维护当前区间内的生成树大小即可。

其实就是 雨天的尾巴+寻宝游戏。

## 代码

```cpp
#include <cstdio>
#include <iostream>
#include <vector>

using namespace std;

/*-----------------------Tree-----------------------*/
const int maxNodeNum = 1e5 + 5;
int nodeNum, langNum, ELen, eulerTime, dfsTime;
int head[maxNodeNum], euler[maxNodeNum * 2], dfn[maxNodeNum];
int firVis[maxNodeNum], rev[maxNodeNum], fa[maxNodeNum];
int dep[maxNodeNum], st[maxNodeNum * 2][20], pos[maxNodeNum * 2][20];
int lg2[maxNodeNum * 2];
struct EDGE {
	int to, next;
} edge[maxNodeNum * 2];
void Add(int from, int to) {
	edge[++ELen].to = to;
	edge[ELen].next = head[from];
	head[from] = ELen;
}
void DfsPrepare(int now, int from) {
	fa[now] = from;
	dep[now] = dep[from] + 1;
	euler[++eulerTime] = now; firVis[now] = eulerTime;
	dfn[now] = ++dfsTime; rev[dfsTime] = now;
	for (int pt = head[now]; pt; pt = edge[pt].next) {
		int to = edge[pt].to;
		if (to != from) {
			DfsPrepare(to, now);
			euler[++eulerTime] = now;
			//这应该加了一个点 now而不是 to 
		}
	}
}
void BuildSt() {
	lg2[1] = 0;
	//这里应该处理到 200000而不是 100000，因为 st表的大小是 200000 
	for (int num = 2; num <= 200000; ++num)
		lg2[num] = lg2[num / 2] + 1;
	for (int beg = 1; beg <= eulerTime; ++beg) {
		st[beg][0] = dep[euler[beg]];
		pos[beg][0] = euler[beg];
	}
	//binary lift
	for (int lif = 1; (1 << lif) <= eulerTime; ++lif)
		for (int beg = 1; beg <= eulerTime - (1 << lif) + 1; ++beg) {
			if (st[beg][lif - 1] < st[beg + (1 << (lif - 1))][lif - 1]) {
				st[beg][lif] = st[beg][lif - 1];
				pos[beg][lif] = pos[beg][lif - 1];
			} else {
				st[beg][lif] = st[beg + (1 << (lif - 1))][lif - 1];
				pos[beg][lif] = pos[beg + (1 << (lif - 1))][lif - 1];
			}
		}
}
inline int GetLca(int uId, int vId) {
	if (!uId || !vId) return 0;
	if (firVis[vId] < firVis[uId]) swap(uId, vId);
	int lif = lg2[firVis[vId] - firVis[uId] + 1];
	if (st[firVis[uId]][lif] < st[firVis[vId] - (1 << lif) + 1][lif])
		return pos[firVis[uId]][lif];
	else return pos[firVis[vId] - (1 << lif) + 1][lif];
}

/*-----------------------Segment Tree-----------------------*/
const int maxTreeSize = 6e6 + 5;
int totNode, rt[maxNodeNum];
struct Node {
	int ls, rs, mstSize;
	int minDfn, maxDfn;
	int cnt;
	Node() : ls(0), rs(0) {} ;
	Node(int _minDfn, int _maxDfn, int _mstSize, bool _cnt) : 
		minDfn(_minDfn), maxDfn(_maxDfn), mstSize(_mstSize), cnt(_cnt) {}
	#define ls(p) tr[p].ls
	#define rs(p) tr[p].rs
	#define minDfn(p) tr[p].minDfn
	#define maxDfn(p) tr[p].maxDfn
	#define mstSize(p) tr[p].mstSize
	#define cnt(p) tr[p].cnt
} tr[maxTreeSize];
void Update(int now) {
	mstSize(now) = mstSize(ls(now)) + mstSize(rs(now))
				 - dep[GetLca(rev[maxDfn(ls(now))], rev[minDfn(rs(now))])];
	minDfn(now) = minDfn(ls(now)) ? minDfn(ls(now)) : minDfn(rs(now));
	maxDfn(now) = maxDfn(rs(now)) ? maxDfn(rs(now)) : maxDfn(ls(now));
	//一个点有左儿子未必这个点就有 minDfn和 maxDfn，可能左儿子的值已经被删掉了 
	//这个地方的 cnt 并不需要更新，因为只在叶子节点的时候有用 
}
int Query(int nId) {
	return mstSize(rt[nId]) - dep[GetLca(rev[minDfn(rt[nId])], rev[maxDfn(rt[nId])])];
}
void Modify(int &now, int lEP, int rEP, int dfnId, int add) {
	if (!now) now = ++totNode;
	if (lEP == rEP) {
		cnt(now) += add;
		//不只有+1的操作，还有-1的操作，所以得看 cnt[now]是否为0 
		maxDfn(now) = minDfn(now) = cnt(now) > 0 ? dfnId : 0;
		mstSize(now) = cnt(now) > 0 ? dep[rev[dfnId]] : 0;
		//这里的 mstSize是加入了 1号节点的 
		return ;
	}
	int mid = (lEP + rEP) >> 1;
	if (dfnId <= mid) Modify(ls(now), lEP, mid, dfnId, add);
	else Modify(rs(now), mid + 1, rEP, dfnId, add);
	Update(now);
}
void Merge(int &uId, int vId, int lEP, int rEP) {
	if (!uId || !vId) {
		uId = uId | vId;
		return ;
	}
	if (lEP == rEP) {
		//注意这里按位或的小技巧 
		cnt(uId) += cnt(vId);
		maxDfn(uId) = minDfn(uId) = cnt(uId) > 0 ? lEP : 0;
		mstSize(uId) = cnt(uId) > 0 ? dep[rev[lEP]] : 0;
		return ;
	}
	int mid = (lEP + rEP) >> 1;
	Merge(ls(uId), ls(vId), lEP, mid);
	Merge(rs(uId), rs(vId), mid + 1, rEP);
	Update(uId);
}
/*-----------------------Solve-----------------------*/
typedef long long ll;
ll ans = 0;
void PathAdd(int uId, int vId, int nId) {
	int lca = GetLca(uId, vId);
	Modify(rt[uId], 1, nodeNum, dfn[nId], 1);
	Modify(rt[vId], 1, nodeNum, dfn[nId], 1);
	//曾经把 vId写成 uId（写东西没过脑子）  
	Modify(rt[lca], 1, nodeNum, dfn[nId], -1);
	Modify(rt[fa[lca]], 1, nodeNum, dfn[nId], -1);
	//先存下来是为了防止出现负数 
}
void DfsSolve(int now, int from) {
	for (int pt = head[now]; pt; pt = edge[pt].next) {
		int to = edge[pt].to;
		if (to != from) DfsSolve(to, now);
	}
	ans += Query(now);
	if (from) Merge(rt[from], rt[now], 1, nodeNum);
}

int main() {
	scanf("%d%d", &nodeNum, &langNum);
	for (int egId = 1; egId < nodeNum; ++egId) {
		int uId, vId;
		scanf("%d%d", &uId, &vId);
		Add(uId, vId);
		Add(vId, uId);
	}
	dfsTime = 0; dep[0] = 0;
	DfsPrepare(1, 0); BuildSt();
	for (int laId = 1; laId <= langNum; ++laId) {
		int uId, vId, lca;
		scanf("%d%d", &uId, &vId);
		lca = GetLca(uId, vId);
		PathAdd(uId, vId, uId);
		PathAdd(uId, vId, vId);
	}
	DfsSolve(1, 0);
	printf("%lld\n", ans >> 1);
	return 0;
}
```

## 知识点

+ 下回第一次写一个奇怪的东西的时候不要自己调试。。。太费时间，跟题解对代码。。。
+ 要知道寻宝游戏的线段树写法，因为线段树可以合并。
+ 代码细节（巨佬可以跳过。。。）：
  + 用RMQ写LCA需要把数组开到原来的两倍，并且log的预处理也要到两倍点数那么大。
  + 之所以题解中大家都是把那些差分的-1操作都放到计算到那个点的时候再算，是因为这样可以保证计算过程中没有负数。
  + 写线段树合并的时候可以用```|```的小技巧。
  + 如果不想先存下来再在差分的时候再减的话，就应该把判断条件改为$cnt > 0$。
  + 一个有左儿子的节点的左儿子下面不一定有数，因为可能数已经被删掉了（这个要在push up中注意）。
  + 欧拉序是从根节点遍历整棵树的序列，经过一个点记一个数（本蒟蒻第一次写RMQ的LCA）。

---

## 作者：轮回之终末 (赞：3)

一种很套路的解法，时空常数和复杂度上均较劣。

------------

树链剖分后发现每一条链的贡献被分成了O($log^2n$)个矩形。

一个显然的时间O($nlog^3n$)空间O($nlog^2n$)算法已经出现了，直接做就是平面上的矩形并问题。

------------

### 矩形并问题
平面上有一堆矩形，问你其覆盖的总面积。

差分一下，将一个矩形变成一个左边+1和一个右边-1的区间。

扫描线，线段树维护。

线段树每个节点维护整个区间被完整覆盖了几次，以及区间的答案。

如果该区间没有被完整覆盖，区间的答案为左儿子加右儿子的答案。

否则为该区间的长度。

时间复杂度O($nlogv$) (n为矩形个数，v为平面大小)

------------

我们考虑用树上差分来优化这个问题。

我们的目标是对于每一个点求出他能到的点的集合。

差分之后，问题由节点本身维护的信息变为了以该节点为根的子树所维护的信息。

我们关心的是，如果我已经知道一个节点的儿子所维护的信息，能否快速转移到他自己本身。

线段树合并不失为一种选择。

对于一条路径，设其两端的点为x和y。

在x处，对(x,y)路径上所有点都+1。

具体上来说，就是$log$个区间（树剖）的区间加。

在y处同理，对(x,y)路径上所有点都+1。

在lca(x,y)处，对(x,y)路径上所有点都-1。

在lca(x,y)的父亲处，对(x,y)路径上所有点都-1。

然后直接暴力线段树合并就行了。

时间O($nlog^2n$)空间O($nlog^2n$)

已经可以通过本题（数据没卡）。

考虑对空间复杂度进行优化：

一边dfs一边统计答案，这样就不需要可持久化，合并完的和旧的可以删去。

考虑直接继承重儿子信息，不对重儿子合并。

这样每条重链上其实只会有一个真正的线段树。

按dfs进行合并，任意一点到根不超过$logn$条重链。

每个线段树就算是满的也只占O($n$)的空间。

然后将已经没用的节点放进垃圾站中进行回收利用。

就只用占$logn$个线段树的空间了。

时间O($nlog^2n$)空间O($nlogn$)

ps:(x,x)对答案贡献为0，但我们会算上，需要减去。

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
const int maxn=100010;
const int maxm=maxn*100;
int read(){
    int tot=0,fh=1;
    char c=getchar();
    while ((c<'0')||(c>'9')){ if (c=='-') fh=-1; c=getchar(); }
    while ((c>='0')&&(c<='9')){ tot=tot*10+c-'0'; c=getchar(); }
    return tot*fh;
}
int i,j,k;
int n,m,x,y,z;
long long ans;
int f1[maxn],f2[maxn*2],f3[maxn*2],th;
void add(int x,int y){ th++; f2[th]=y; f3[th]=f1[x]; f1[x]=th; }
int dept[maxn],dfn[maxn],low[maxn],tim,siz[maxn],son[maxn],tp[maxn],faa[maxn],ha[maxn],tag[maxn];
vector <pii> A[maxn],D1[maxn],D2[maxn];
void dfs1(int x,int fa){
    faa[x]=fa; dept[x]=dept[fa]+1; siz[x]=1;
    for (int i=f1[x];i;i=f3[i]){
        if (fa!=f2[i]){ dfs1(f2[i],x); siz[x]=siz[x]+siz[f2[i]]; if (siz[son[x]]<siz[f2[i]]) son[x]=f2[i]; }
    }
}
void dfs2(int x,int fa){
    tim++; dfn[x]=tim; tp[x]=fa; ha[tim]=x;
    if (son[x]!=0) dfs2(son[x],fa);
    for (int i=f1[x];i;i=f3[i]){
        if ((f2[i]!=faa[x])&&(f2[i]!=son[x])) dfs2(f2[i],f2[i]);
    } low[x]=tim;
}
int lca(int x,int y){
    while (tp[x]!=tp[y]) if (dept[tp[x]]>dept[tp[y]]) x=faa[tp[x]]; else y=faa[tp[y]];
    if (dept[x]>dept[y]) return y; else return x;
}
int rot[maxn];
struct SegmentTree{
    int ls[maxm],rs[maxm],tot[maxm],fla[maxm];
    int th,thi[maxm];
    void updata(int x,int l,int r){ if (fla[x]) tot[x]=r-l+1; else tot[x]=tot[ls[x]]+tot[rs[x]]; }
    int changge(int x,int l,int r,int ll,int rr,int w){
        if ((rr<l)||(r<ll)) return x;
        int mid=(l+r)>>1,t=thi[th]; thi[th]=0; th--;
        ls[t]=ls[x]; rs[t]=rs[x]; tot[t]=tot[x]; fla[t]=fla[x]; ls[x]=0; rs[x]=0; tot[x]=0; fla[x]=0; if (x){ th++; thi[th]=x; }
        if ((ll<=l)&&(r<=rr)){ fla[t]=fla[t]+w; updata(t,l,r); return t; }
        ls[t]=changge(ls[t],l,mid,ll,rr,w); rs[t]=changge(rs[t],mid+1,r,ll,rr,w); updata(t,l,r); return t;
    }
    int merge(int x,int y,int l,int r){
        if (x==0) return y;
        if (y==0) return x;
        int t,mid=(l+r)>>1; t=thi[th]; thi[th]=0; th--;
        if (l==r){
            fla[t]=fla[x]+fla[y]; updata(t,l,r);
            ls[x]=0; rs[x]=0; tot[x]=0; fla[x]=0; if (x){ th++; thi[th]=x; }
            ls[y]=0; rs[y]=0; tot[y]=0; fla[y]=0; if (y){ th++; thi[th]=y; }
            return t;
        }
        ls[t]=merge(ls[x],ls[y],l,mid); rs[t]=merge(rs[x],rs[y],mid+1,r); fla[t]=fla[x]+fla[y]; updata(t,l,r);
        ls[x]=0; rs[x]=0; tot[x]=0; fla[x]=0; if (x){ th++; thi[th]=x; }
        ls[y]=0; rs[y]=0; tot[y]=0; fla[y]=0; if (y){ th++; thi[th]=y; }
        return t;
    }
}tre;
void solve(int rt,int x,int y,int w){
    while (tp[x]!=tp[y]){
        if (dept[tp[x]]<dept[tp[y]]) swap(x,y);
        rot[rt]=tre.changge(rot[rt],1,n,dfn[tp[x]],dfn[x],w);
        x=faa[tp[x]];
    }
    if (dept[x]>dept[y]) swap(x,y);
    rot[rt]=tre.changge(rot[rt],1,n,dfn[x],dfn[y],w);
}
void dfs(int x){
    if (son[x]!=0){ dfs(son[x]); tag[x]=tag[x]+tag[son[x]]; rot[x]=rot[son[x]]; }
    for (int i=f1[x];i;i=f3[i]){
        if ((f2[i]!=faa[x])&&(f2[i]!=son[x])){ dfs(f2[i]); tag[x]=tag[x]+tag[f2[i]]; rot[x]=tre.merge(rot[x],rot[f2[i]],1,n); }
    }
    for (int i=0;i<A[x].size();i++) solve(x,A[x][i].fi,A[x][i].se,1);
    for (int i=0;i<D1[x].size();i++) solve(x,D1[x][i].fi,D1[x][i].se,-1);
    for (int i=0;i<D2[x].size();i++) solve(x,D2[x][i].fi,D2[x][i].se,-2);
    ans=ans+tre.tot[rot[x]];
    if (tag[x]>0) ans--;
}
int main(){
//	freopen("language.in","r",stdin);
//	freopen("language.out","w",stdout);
    
    n=read(); m=read();
    for (i=1;i<n;i++){
        x=read(); y=read();
        add(x,y); add(y,x);
    }
    for (i=1;i<maxm;i++){ tre.thi[i]=i; tre.th++; }
    dfs1(1,0);
    dfs2(1,0);
    for (i=1;i<=m;i++){
        x=read(); y=read(); if (x==y) continue;
        z=lca(x,y); if (z==y) swap(x,y);
        if (z==x){
            tag[y]++; tag[faa[x]]--;
            A[y].push_back(pii(x,y));
            D1[faa[x]].push_back(pii(x,y));
        }
        else{
            tag[x]++; tag[y]++; tag[z]--; tag[faa[z]]--;
            A[x].push_back(pii(x,y));
            A[y].push_back(pii(x,y));
            D2[faa[z]].push_back(pii(x,y));
        }
    }
    dfs(1);
    printf("%lld\n",ans/2);
    
    return 0;
}
/*
5 3
1 2
1 3
3 4
3 5
3 4
1 4
2 5

*/
```


---

## 作者：mrsrz (赞：3)

~~3个log在ZJOI老年机上T飞~~

来讲一讲我的考场做法吧。

考虑对每个点，求有多少个点和它在同一条链中。

相当于，对每个点，求经过这个点的链覆盖的点的个数。

考虑树链剖分。对每条链，分成不超过$\log n$个区间。

对这条链经过的所有点，这条链都是有贡献的。

我们考虑线段树分治，将每段区间都放到线段树上面去。

然后遍历线段树，同时用```set```动态维护一下当前这些链构成的虚树大小即可。

时间复杂度$O(n\log^3 n)$，空间复杂度$O(n\log^2 n)$。

以下为考场60分，去掉文件后的AC代码。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<set>
char buf[(int)1e7],*ss=buf;
inline int readint(){
	int d=0;
	while(!isdigit(*ss))++ss;
	while(isdigit(*ss))d=d*10+(*ss++^'0');
	return d;
}
const int N=1e5+6;
int s[N],t[N],n,head[N],cnt,dep[N],dfn[N],top[N],sz[N],son[N],fa[N],idfn[N],idx,m,hh[N<<2],tt;
typedef long long LL;
LL ans=0;
struct edge{
	int to,nxt;
}e[N<<1],f[N*400];
void dfs(int now){
	sz[now]=1,son[now]=0;
	for(int i=head[now];i;i=e[i].nxt)
	if(!dep[e[i].to]){
		dep[e[i].to]=dep[now]+1,fa[e[i].to]=now;
		dfs(e[i].to);
		sz[now]+=sz[e[i].to];
		if(!son[now]||sz[son[now]]<sz[e[i].to])son[now]=e[i].to;
	}
}
void dfs2(int now){
	idfn[dfn[now]=++idx]=now;
	if(son[now])top[son[now]]=top[now],dfs2(son[now]);
	for(int i=head[now];i;i=e[i].nxt)
	if(e[i].to!=son[now]&&dep[e[i].to]>dep[now])dfs2(top[e[i].to]=e[i].to);
}
void add(int l,int r,int o,const int&L,const int&R,const int&id){
	if(L<=l&&r<=R)f[++tt]=(edge){id,hh[o]},hh[o]=tt;else{
		const int mid=l+r>>1;
		if(L<=mid)add(l,mid,o<<1,L,R,id);
		if(mid<R)add(mid+1,r,o<<1|1,L,R,id);
	}
}
void modify(int x,int y,int id){
	while(top[x]!=top[y])
	if(dep[top[x]]>dep[top[y]]){
		add(1,n,1,dfn[top[x]],dfn[x],id);
		x=fa[top[x]];
	}else{
		add(1,n,1,dfn[top[y]],dfn[y],id);
		y=fa[top[y]];
	}
	if(dep[x]<dep[y])add(1,n,1,dfn[x],dfn[y],id);else
	add(1,n,1,dfn[y],dfn[x],id);
}
inline int LCA(int x,int y){
	while(top[x]!=top[y])
	if(dep[top[x]]>dep[top[y]])x=fa[top[x]];else y=fa[top[y]];
	return dep[x]<dep[y]?x:y;
}
namespace tree{
	int CNT[N];
	std::set<int>s;
	typedef std::set<int>::iterator iter;
	int tot=0,rt;
	inline void add(int x){
		if(CNT[x]++)return;
		if(s.size()==0){
			s.insert(dfn[x]);tot=1;rt=x;
			return;
		}
		iter nxt=s.lower_bound(dfn[x]),pre;
		if(nxt==s.begin()){
			const int lca=LCA(x,idfn[*nxt]);
			if(LCA(x,rt)==rt)
			tot+=dep[x]-dep[lca];else{
				tot+=dep[x]-dep[lca]+dep[rt]-dep[lca];
				rt=lca;
			}
			s.insert(dfn[x]);
			return;
		}
		pre=--nxt;++nxt;
		if(nxt==s.end()){
			const int lca=LCA(x,idfn[*pre]);
			if(LCA(x,rt)==rt)
			tot+=dep[x]-dep[lca];else{
				tot+=dep[x]-dep[lca]+dep[rt]-dep[lca];
				rt=lca;
			}
			s.insert(dfn[x]);
			return;
		}
		const int lca1=LCA(x,idfn[*pre]),lca2=LCA(x,idfn[*nxt]);
		if(dep[lca1]>dep[lca2])tot+=dep[x]-dep[lca1];else tot+=dep[x]-dep[lca2];
		s.insert(dfn[x]);
	}
	inline void del(int x){
		if(--CNT[x])return;
		s.erase(dfn[x]);
		if(s.size()==0){
			rt=tot=0;
			return;
		}
		rt=LCA(idfn[*s.begin()],idfn[*s.rbegin()]);
		iter nxt=s.lower_bound(dfn[x]),pre;
		if(nxt==s.begin()){
			const int lca=LCA(x,idfn[*nxt]);
			if(LCA(x,rt)==rt)
			tot-=dep[x]-dep[lca];else
			tot-=dep[x]-dep[lca]+dep[rt]-dep[lca];
			return;
		}
		pre=--nxt;++nxt;
		if(nxt==s.end()){
			const int lca=LCA(x,idfn[*pre]);
			if(LCA(x,rt)==rt)
			tot-=dep[x]-dep[lca];else
			tot-=dep[x]-dep[lca]+dep[rt]-dep[lca];
			return;
		}
		const int lca1=LCA(x,idfn[*pre]),lca2=LCA(x,idfn[*nxt]);
		if(dep[lca1]>dep[lca2])tot-=dep[x]-dep[lca1];else tot-=dep[x]-dep[lca2];
	}
}
void solve(int l,int r,int o){
	for(int i=hh[o];i;i=f[i].nxt)
	tree::add(s[f[i].to]),tree::add(t[f[i].to]);
	if(l==r)ans+=tree::tot?tree::tot-1:0;else{
		const int mid=l+r>>1;
		solve(l,mid,o<<1),solve(mid+1,r,o<<1|1);
	}
	for(int i=hh[o];i;i=f[i].nxt)
	tree::del(s[f[i].to]),tree::del(t[f[i].to]);
}
int main(){
	buf[fread(buf,1,(int)1e7-1,stdin)]='\n';
	fclose(stdin);
	n=readint(),m=readint();
	for(int i=1;i<n;++i){
		int u=readint(),v=readint();
		e[++cnt]=(edge){v,head[u]},head[u]=cnt;
		e[++cnt]=(edge){u,head[v]},head[v]=cnt;
	}
	dfs(dep[1]=1),dfs2(1);
	for(int i=1;i<=m;++i)
	modify(s[i]=readint(),t[i]=readint(),i);
	solve(1,n,1);
	printf("%lld\n",ans>>1);
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：2)

考虑把贡献摊到每个点上计算，每个点带来的贡献实际上是经过它的路径并大小，算完求和之后在除以 $2$ 就得到了答案。

考虑怎么计算路径并大小。

考虑这样一个办法，将所有路径的起始点和终点按照 DFS 序排序，相邻两点（包括第一个会最后一个点）在树上的距离之和便是其路径并大小的两倍。原理的话便是路径并大小等价于包含所有路径起始点的最小联通生成树。

考虑树上点差分，然后用线段树储存 DFS 序为 $x$ 的点是否在子树中，维护节点内最大和最小的存在的 DFS 序就可以在通过一次求 LCA 合并两个子节点的信息。

那么最后一步通过线段树合并将子树的信息合并到父亲即可。

时间复杂度 $O(n \log^2 n)$ 空间复杂度 $O(n \log n)$，也可以通过写压缩 01Trie 或者直接维护线段树叶子节点的方法做到线性空间，但没什么必要。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e5 + 114;
int fa[maxn][19], lg[maxn];
int dfn[maxn], dfncnt, dep[maxn];
int Node[maxn];
int n, m;
vector<int> edge[maxn];
void dfs1(int u, int father) {
    dep[u] = dep[father] + 1;
    dfn[u] = ++dfncnt;
    Node[dfncnt] = u;
    fa[u][0] = father;

    for (int i = 1; i <= 17; i++)
        fa[u][i] = fa[fa[u][i - 1]][i - 1];

    for (int v : edge[u]) {
        if (v == father)
            continue;

        dfs1(v, u);
    }
}
int LCA(int u, int v) {
    if (dep[u] < dep[v])
        swap(u, v);

    while (dep[u] > dep[v]) {
        u = fa[u][lg[dep[u] - dep[v]]];
    }

    if (u == v)
        return u;

    for (int i = 17; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i], v = fa[v][i];
        }
    }

    return fa[u][0];
}
int dist(int x, int y) {
    return dep[x] + dep[y] - 2 * dep[LCA(x, y)];
}
#define ls(cur)(tr[cur].ls)
#define rs(cur)(tr[cur].rs)
int tot;
struct Segment_tree {
    int ls, rs;
    int mi, mx, sum, cnt;
} tr[maxn * 40];
int root[maxn];
void pushup(int cur) {
    tr[cur].cnt = tr[ls(cur)].cnt + tr[rs(cur)].cnt;

    if (tr[ls(cur)].cnt == 0 && tr[rs(cur)].cnt == 0)
        cur = 0;
    else if (tr[ls(cur)].cnt == 0)
        tr[cur].sum = tr[rs(cur)].sum, tr[cur].mi = tr[rs(cur)].mi, tr[cur].mx = tr[rs(cur)].mx;
    else if (tr[rs(cur)].cnt == 0)
        tr[cur].sum = tr[ls(cur)].sum, tr[cur].mi = tr[ls(cur)].mi, tr[cur].mx = tr[ls(cur)].mx;
    else {
        tr[cur].sum = tr[ls(cur)].sum + tr[rs(cur)].sum + dist(Node[tr[ls(cur)].mx], Node[tr[rs(cur)].mi]);
        tr[cur].mi = tr[ls(cur)].mi;
        tr[cur].mx = tr[rs(cur)].mx;
    }
}
void update(int &cur, int lt, int rt, int pos, int v) {
    if (pos < lt || pos > rt)
        return ;

    if (cur == 0)
        cur = ++tot;

    if (lt == rt && lt == pos) {
        tr[cur].cnt += v;
        tr[cur].mi = tr[cur].mx = lt;
        tr[cur].sum = 0;
        return ;
    }

    int mid = (lt + rt) >> 1;
    update(ls(cur), lt, mid, pos, v);
    update(rs(cur), mid + 1, rt, pos, v);
    pushup(cur);
}
int merge(int a, int b, int lt, int rt) {
    if (a == 0 || b == 0)
        return a + b;

    if (lt == rt) {
        tr[a].cnt += tr[b].cnt;
        tr[a].mi = tr[a].mx = lt;
        tr[a].sum = 0;
        return a;
    }

    int mid = (lt + rt) >> 1;
    tr[a].ls = merge(tr[a].ls, tr[b].ls, lt, mid);
    tr[a].rs = merge(tr[a].rs, tr[b].rs, mid + 1, rt);
    pushup(a);
    return a;
}
vector<int> Ins[maxn], Del[maxn];
int answer;
void dfs2(int u, int father) {
    for (int v : edge[u]) {
        if (v == father)
            continue;

        dfs2(v, u);
        root[u] = merge(root[u], root[v], 1, n);
    }

    for (int x : Ins[u])
        update(root[u], 1, n, x, 1);

    for (int x : Del[u])
        update(root[u], 1, n, x, -1);

    answer += (tr[root[u]].sum + dist(Node[tr[root[u]].mi], Node[tr[root[u]].mx])) / 2;
}
signed main() {
    cin >> n >> m;
    lg[1] = 0;

    for (int i = 2; i <= n; i++)
        lg[i] = lg[i / 2] + 1;

    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        edge[u].push_back(v);
        edge[v].push_back(u);
    }

    dep[0] = -1;
    dfs1(1, 0);

    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;

        if (u == v)
            continue;

        Ins[u].push_back(dfn[u]);
        Ins[u].push_back(dfn[v]);
        Ins[v].push_back(dfn[v]);
        Ins[v].push_back(dfn[u]);
        Del[LCA(u, v)].push_back(dfn[u]);
        Del[LCA(u, v)].push_back(dfn[v]);
        Del[fa[LCA(u, v)][0]].push_back(dfn[u]);
        Del[fa[LCA(u, v)][0]].push_back(dfn[v]);
    }

    dfs2(1, 0);
    cout << answer / 2;
}
```


---

## 作者：Prean (赞：2)

考虑树上差分。加入一个语言或删除一个语言。先对整棵树树剖，问题变为区间加和询问全局 $\geq 1$ 的个数。

考虑直接用线段树维护区间最小值和最小值的数量。

这个可以直接线段树合并维护。注意到总共有 $O(n\log n)$ 次线段树修改。

然后。。。直接线段树合并就可以做到 $O(n\log^2n)$ 了。
```cpp
#include<cstdio>
#include<vector>
const int M=1e5+5;
int n,m,dfc,cnt,tot,h[M],sz[M],rt[M];long long sum;
int f[M],d[M],dfn[M],son[M],siz[M],top[M];
int tp,stk[M*18];
struct mdf{
	int L,R,V;
};std::vector<mdf>p[M];
struct Edge{
	int v,nx;
}e[M<<1];
struct Node{
	int L,R;int mi,cnt;int tag;
}t[M*18];
inline void Add(const int&u,const int&v){
	e[++cnt]=(Edge){v,h[u]};h[u]=cnt;
	e[++cnt]=(Edge){u,h[v]};h[v]=cnt;
}
inline void Erase(const int&u){
	t[u].L=t[u].R=t[u].mi=t[u].cnt=t[u].tag=0;stk[++tp]=u;
}
inline int t42d(const int&mi,const int&cnt){
	const int u=tp?stk[tp--]:++tot;t[u].L=t[u].R=t[u].tag=0;t[u].mi=mi;t[u].cnt=cnt;return u;
}
inline void update(const int&u,const int&L=1,const int&R=n){
	const int&mid=L+R>>1;int Lmi(0),Lcnt(mid-L+1),Rmi(0),Rcnt(R-mid);
	if(t[u].L)Lmi=t[t[u].L].mi,Lcnt=t[t[u].L].cnt;Lmi+=t[u].tag;
	if(t[u].R)Rmi=t[t[u].R].mi,Rcnt=t[t[u].R].cnt;Rmi+=t[u].tag;
	if(Lmi==Rmi)t[u].mi=Lmi,t[u].cnt=Lcnt+Rcnt;
	else if(Lmi>Rmi)t[u].mi=Rmi,t[u].cnt=Rcnt;
	else t[u].mi=Lmi,t[u].cnt=Lcnt;
}
inline void Mdf(int&u,const int&l,const int&r,const int&V,const int&L=1,const int&R=n){
	if(l>R||L>r)return;if(!u)u=t42d(0,R-L+1);
	if(l<=L&&R<=r)return t[u].mi+=V,t[u].tag+=V,void();
	const int&mid=L+R>>1;Mdf(t[u].L,l,r,V,L,mid);Mdf(t[u].R,l,r,V,mid+1,R);update(u,L,R);
}
inline void Merge(int&q,const int&p,const int&L=1,const int&R=n){
	if(!q||!p)return q|=p,void();t[q].tag+=t[p].tag;
	if(!t[q].L&&!t[q].R&&!t[p].L&&!t[p].R)return t[q].mi+=t[p].mi,Erase(p);
	const int&mid=L+R>>1;Merge(t[q].L,t[p].L,L,mid);Merge(t[q].R,t[p].R,mid+1,R);update(q,L,R);Erase(p);
}
inline void DFS1(const int&u){
	d[u]=d[f[u]]+1;siz[u]=1;
	for(int v,E=h[u];E;E=e[E].nx)if((v=e[E].v)^f[u]){
		f[v]=u;DFS1(v);siz[u]+=siz[v];if(siz[v]>siz[son[u]])son[u]=v;
	}
}
inline void DFS2(const int&u,const int&tp){
	top[u]=tp;dfn[u]=++dfc;if(!son[u])return;DFS2(son[u],tp);
	for(int E=h[u];E;E=e[E].nx)if(e[E].v^f[u]&&e[E].v^son[u])DFS2(e[E].v,e[E].v);
}
inline int LCA(int u,int v){
	while(top[u]^top[v])d[top[u]]>d[top[v]]?u=f[top[u]]:v=f[top[v]];return d[u]>d[v]?v:u;
}
inline void Solve(const int&u){
	for(int v,E=h[u];E;E=e[E].nx)if((v=e[E].v)^f[u])Solve(v),Merge(rt[u],rt[v]),sz[u]+=sz[v];
	for(mdf&it:p[u])Mdf(rt[u],it.L,it.R,it.V),sz[u]+=it.V;std::vector<mdf>().swap(p[u]);
	if(sz[u])sum+=n-(!t[rt[u]].mi?t[rt[u]].cnt:0)-1;
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int u,v,i=1;i<n;++i)scanf("%d%d",&u,&v),Add(u,v);DFS1(1);DFS2(1,1);
	while(m--){
		int u,v,c,x,y;scanf("%d%d",&u,&v);c=LCA(u,v);x=u;y=v;
		while(top[x]^top[y]){
			if(d[top[x]]>d[top[y]]){
				p[u].push_back((mdf){dfn[top[x]],dfn[x],1});p[v].push_back((mdf){dfn[top[x]],dfn[x],1});
				p[f[c]].push_back((mdf){dfn[top[x]],dfn[x],-2});x=f[top[x]];
			}
			else{
				p[u].push_back((mdf){dfn[top[y]],dfn[y],1});p[v].push_back((mdf){dfn[top[y]],dfn[y],1});
				p[f[c]].push_back((mdf){dfn[top[y]],dfn[y],-2});y=f[top[y]];
			}
		}
		if(d[x]>d[y])x^=y^=x^=y;
		p[u].push_back((mdf){dfn[x],dfn[y],1});p[v].push_back((mdf){dfn[x],dfn[y],1});
		p[f[c]].push_back((mdf){dfn[x],dfn[y],-2});
	}
	Solve(1);printf("%lld",sum>>1);
}
```

---

## 作者：FxorG (赞：1)

我竟然能独立想出来（）

首先树上统计点对问题考虑 dfs 一遍顺便统计，再加上数据结构之类的。

考虑对于第 $i$ 种语言，$x,y$ 能开展贸易说明都被 $i$ 覆盖到了。考虑每种语言覆一个颜色？

不需要。我们发现对于 $x$ 我们只关心执行了所有跟 $x$ 有关的覆盖操作（即覆盖到 $x$）后被覆盖的点的并集的大小。对此直接树上差分下即可。

考虑类虚树，我们现在求出一个集合 $S=\{x|x\text{是每次覆盖操作的端点}\}$,按 dfs 序排序，那么他们相互间的路径的并集的大小就是 $\sum_{x\in S}dep[x]-\sum_{x,y\in S,\text{x,y相邻}}dep[LCA(x,y)]$。（注意 1,n 也算相邻）考虑对当前遍历到的点的贡献就为此。（点数等于边数 +1，但要减去本身）

这个式子画个图就能发现，需要记忆下。

那么如何维护这个式子？我们只需要 ```multiset+启发式合并``` 即可。

至于这里为什么是 ```multiset```，因为用 ```set``` 的话假如重复了在此删去，回溯后就无了 ~~（好吧，我本来也用 ```set``` 的，直到过不去样例）~~。至于重复点的话，显然对于答案不会有影响，因为加了重复点，又减去它俩的 LCA。

先考虑暴力合并子树答案。加入一个点，只需要考虑前驱后驱的影响。删除也同样。

至于启发式合并的话，```swap``` 之后，要把 y 的答案赋给 x 即可，但这里有个细节，赋的答案不能减去 1,n 相邻的。

```cpp
#include <bits/stdc++.h>
#define int long long
#define pb push_back
using namespace std;
#define N (int)(1e5+5)
vector<int>g[N];
int n,m;

namespace SP {
	int fa[N],sz[N],top[N],son[N],dep[N],id[N],tot;
	void dfs1(int x,int ff) {
		fa[x]=ff; dep[x]=dep[ff]+1; sz[x]=1;
		for(int y:g[x]) {
			if(y==ff) continue;
			dfs1(y,x); sz[x]+=sz[y];
			if(sz[y]>sz[son[x]]) son[x]=y;
		}
	}
	void dfs2(int x,int tp) {
		top[x]=tp; id[x]=++tot;
		if(son[x]) dfs2(son[x],tp);
		for(int y:g[x]) {
			if(y==fa[x]||y==son[x]) continue;
			dfs2(y,y);
		} 
	}
	void init() {
		dfs1(1,0); dfs2(1,1);
	}
	int LCA(int x,int y) {
		while(top[x]!=top[y]) {
			if(dep[top[x]]<dep[top[y]]) swap(x,y);
			x=fa[top[x]];
		}
		return dep[x]<dep[y]?x:y;
	}
	int dist(int x,int y) {
		return dep[x]+dep[y]-2*dep[LCA(x,y)];
	}
}
using namespace SP;
vector<pair<int,int> >vec[N];

void modify(int x,int y) {
	int d=LCA(x,y);
	vec[x].pb(make_pair(x,1));
	vec[x].pb(make_pair(y,1));
	vec[y].pb(make_pair(x,1));
	vec[y].pb(make_pair(y,1));
	if(fa[d]) vec[fa[d]].pb(make_pair(y,-1)),vec[fa[d]].pb(make_pair(x,-1));
}
struct cmp {
	bool operator () (int x,int y) {
		return id[x]<id[y];
	}
}; 
multiset<int,cmp>s[N]; //这里用 multiset 的原因事实上是为了防止此处删掉 i 但是回溯过去还有 i， 多个 i 排序后在一起对答案没有影响 
int ans[N],dans[N];

void ins(int x,int i) {
//	if(x==4) cout<<"ins "<<i<<endl;
	auto nex=s[x].lower_bound(i),las=nex; int qwq=0; 
	if(las!=s[x].begin()) {
		--las; 
	//	if(x==4) cout<<*las<<" las i "<<i<<" "<<dep[LCA(*las,i)]<<endl;
		++qwq,ans[x]-=dep[LCA(*las,i)];
	}
	if(nex!=s[x].end()) {
	//	if(x==4) cout<<*nex<<" nex i "<<i<<" "<<dep[LCA(*nex,i)]<<endl;
		++qwq; ans[x]-=dep[LCA(*nex,i)];
	}
	if(qwq==2) {
	//	if(x==4) cout<<*las<<" las nex "<<*nex<<" "<<dep[LCA(*las,*nex)]<<endl;
		ans[x]+=dep[LCA(*las,*nex)];
	}
	s[x].insert(i); ans[x]+=dep[i];
}

void del(int x,int i) {
	auto it=s[x].find(i),nex=it,las=it; int qwq=0;
	if(nex!=s[x].end()) {
		++nex; if(nex!=s[x].end()) ++qwq,ans[x]+=dep[LCA(i,*nex)];
	}
	if(las!=s[x].begin()) {
		--las; if(las!=s[x].begin()) ++qwq,ans[x]+=dep[LCA(i,*las)];		
	}
	if(qwq==2) ans[x]-=dep[LCA(*las,*nex)];
	s[x].erase(s[x].find(i)); ans[x]-=dep[i];
}

void dfs(int x,int ff) {
	for(int y:g[x]) {
		if(y==ff) continue;
		dfs(y,x);
		if(s[y].size()>s[x].size()) s[x].swap(s[y]),ans[x]=ans[y];
		//ans[x]+=ans[y];
		for(int i:s[y]) {
			ins(x,i);
		}
	}
//	s[x].insert(x);
	/*for(int i:s[x]) {
		cout<<x<<" : pre : "<<i<<'\n';
	}*/
	for(auto i:vec[x]) {
		if(i.second==1) {
			ins(x,i.first);
			if(x==4) {
			//	cout<<i.first<<" ";
			}
		}
		else del(x,i.first),del(x,i.first);
	}
	if(x==4) {
	/*	cout<<'\n';
		for(int i:s[x]) cout<<i<<" ";*/
	}
	if(s[x].size()>=2) {
		auto p=s[x].end(); --p; 
	//	if(x==4) cout<<dep[LCA(*s[x].begin(),*p)]<<":\n";
		dans[x]-=dep[LCA(*s[x].begin(),*p)];
	}
	/*if(s[x].size()>=2) {
		ans[x]-=dist(*s[x].begin(),*s[x].end());
	}*/
/*	tmp.clear();
	for(int i:s[x]) {
		tmp.pb(i);
	}
	sort(tmp.begin(),tmp.end(),cmp);
	for(int i=0;i<tmp.size();i++) ans+=dep[tmp[i]];
	for(int i=1;i<tmp.size();i++) ans-=dep[LCA(tmp[i-1],tmp[i])];
	int d=0;
	for(int i=1;i<tmp.size();i++) {
		if(!d) d=LCA(tmp[i-1],tmp[i]); else d=LCA(d,tmp[i]);
	}
	if(d) ans-=dep[d];*/
}

signed main() {
//	freopen("language5.in","r",stdin);
	cin.tie(0);
	std::ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<n;i++) {
		int x,y; cin>>x>>y;
		g[x].pb(y); g[y].pb(x);
	}
	SP::init();
	while(m--) {
		int x,y; cin>>x>>y;
		modify(x,y);
	}
	dfs(1,0); int res=0;
	for(int i=1;i<=n;i++) res+=ans[i]+dans[i];
	//for(int i=1;i<=n;i++) cout<<ans[i]<<' '; 
	cout<<res/2;
//	cout<<ans[4];
	return 0;
}
```

---

## 作者：tzc_wk (赞：1)

安利个人 blog：https://www.cnblogs.com/ET2006/

首先，很容易发现一个性质，那就是所有 $u$ 能够到达的点都会构成一个连通块，而这个连通块边界上的点都是某条经过 $u$ 的路径的端点。

于是只需维护所有经过 $u$ 的路径的端点的虚树即可，那么 $u$ 能到达的点的个数就是虚树中边的个数。

考虑怎样维护经过 $u$ 的虚树大小。首先需知道怎样求某个点集的虚树大小。将点集中所有点按 DFS 序排序并依次插入这些节点，那么每插入一个节点 $x$ 的时候虚树大小的增量即为 $x$ 的深度减去 $x$ 与 $x$ 上一个节点的 LCA 的深度，最后减去所有点的 LCA 的深度即可。考虑用一个长度为 $n$ 的 0/1 数组表示每个点是否在点集中，那么最终虚树的大小就是所有 $1$ 表示点的深度之和减去相邻 $1$ 的 LCA 的深度，再减去一头一尾两个 $1$ 的 LCA 的深度。

考虑用树上差分拆路径，这样可以得到若干个形如“$u$ 在 $x$ 的点集中出现次数多 $y(y\in\{1,-1\})$”的操作。考虑对于每个点建一棵权值线段树，下标表示 DFS 序，下标为 $x$ 的位置的值表示 DFS 序为 $x$ 的点的出现次数。线段树每个节点上维护以下三个值：该节点表示的区间中，出现次数 $>0$ 的点的 DFS 序的最小值 $fst$，最大值 $lst$，以及该区间中所有出现次数 $>0$ 的节点深度之和减去相邻出现次数 $>0$ 的 LCA 的深度。按照套路进行一遍 DFS 线段树合并即可。最后别忘了将答案除以 $2$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int MAXN=1e5;
const int LOG_N=18;
const int MAXP=MAXN*60;
int n,m,hd[MAXN+5],to[MAXN*2+5],nxt[MAXN*2+5],ec=0;
vector<int> del[MAXN+5]; 
void adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}
int dep[MAXN+5],dfn[MAXN+5],rid[MAXN+5],dfn_lca[MAXN+5],fa[MAXN+5],t1=0,t2=0;
pii st[MAXN*2+5][LOG_N+2];vector<int> dels[MAXN+5];
void dfs0(int x,int f){
	fa[x]=f;dfn[x]=++t1;rid[t1]=x;dfn_lca[x]=++t2;st[t2][0]=mp(dep[x],x);
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f) continue;
		dep[y]=dep[x]+1;dfs0(y,x);
		st[++t2][0]=mp(dep[x],x);
	}
}
void buildst(){
	for(int i=1;i<=LOG_N;i++) for(int j=1;j+(1<<i)-1<=2*n;j++)
		st[j][i]=min(st[j][i-1],st[j+(1<<(i-1))][i-1]);
}
int getlca(int x,int y){
	if(!x||!y) return 0;
	x=dfn_lca[x];y=dfn_lca[y];if(x>y) swap(x,y);
	int k=log(y-x+1)/log(2);return min(st[x][k],st[y-(1<<k)+1][k]).se;
}
struct node{int ch[2],sdep,fst,lst,val;} s[MAXP+5];
int ncnt=0,rt[MAXN+5];
void pushup(int k){
	s[k].sdep=s[s[k].ch[0]].sdep+s[s[k].ch[1]].sdep-dep[getlca(s[s[k].ch[0]].lst,s[s[k].ch[1]].fst)];
	s[k].fst=(s[s[k].ch[0]].fst)?s[s[k].ch[0]].fst:s[s[k].ch[1]].fst;
	s[k].lst=(s[s[k].ch[1]].lst)?s[s[k].ch[1]].lst:s[s[k].ch[0]].lst;
}
void add(int &k,int l,int r,int p,int x){
	if(!k) k=++ncnt;
	if(l==r){
		s[k].val+=x;s[k].sdep=(s[k].val>0)?dep[rid[l]]:0;
		s[k].lst=s[k].fst=(s[k].val>0)?rid[l]:0;return;
	} int mid=(l+r)>>1;
	if(p<=mid) add(s[k].ch[0],l,mid,p,x);
	else add(s[k].ch[1],mid+1,r,p,x);
	pushup(k);
}
int merge(int x,int y,int l,int r){
	if(!x||!y) return x+y;
	if(l==r){
		s[x].val=s[x].val+s[y].val;s[x].sdep=(s[x].val>0)?dep[rid[l]]:0;
		s[x].lst=s[x].fst=(s[x].val>0)?rid[l]:0;return x;
	} int mid=(l+r)>>1;
	s[x].ch[0]=merge(s[x].ch[0],s[y].ch[0],l,mid);
	s[x].ch[1]=merge(s[x].ch[1],s[y].ch[1],mid+1,r);
	pushup(x);return x;
}
ll ans=0;
void dfs(int x){
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==fa[x]) continue;
		dfs(y);rt[x]=merge(rt[x],rt[y],1,n);
	}
	for(int i=0;i<del[x].size();i++) add(rt[x],1,n,dfn[del[x][i]],-1);
	ans+=s[rt[x]].sdep-dep[getlca(s[rt[x]].fst,s[rt[x]].lst)];
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++){int u,v;scanf("%d%d",&u,&v);adde(u,v);adde(v,u);}
	dfs0(1,0);buildst();
	for(int i=1;i<=m;i++){
		int u,v,lca;scanf("%d%d",&u,&v);lca=getlca(u,v);
		add(rt[u],1,n,dfn[u],1);add(rt[u],1,n,dfn[v],1);
		add(rt[v],1,n,dfn[u],1);add(rt[v],1,n,dfn[v],1);
		del[lca].pb(u);del[lca].pb(v);
		if(lca!=1) del[fa[lca]].pb(u),del[fa[lca]].pb(v);
	} dfs(1);printf("%lld\n",ans>>1);
	return 0;
}
```

---


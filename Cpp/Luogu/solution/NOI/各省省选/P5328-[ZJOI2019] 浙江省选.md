# [ZJOI2019] 浙江省选

## 题目描述

九条可怜是一个喜欢出题的女孩子，这道题是一道有关浙江省选的硬核模拟题。  

在 $9102$ 年，有 $n$ 名选手参加了浙江省选，其中第 $i$ 个选手的智力是 $a_i$，训练量是 $b_i$。作为
出题人，可怜可以自由选择这套题的风格是比较偏套路还是比较偏智力。举例来说，$\mathrm{ZJOI}2018$ 的题就比较偏智力，今年的题就比较偏套路。  

为了定量衡量一套题的风格，可怜定义了反向选拔指数 $x$，$x$ 是一个**非负整数**。第 $i$ 个选手在反向选拔指数为 $x$ 的题目上的表现为 $a_ix+b_i$。在 $x$ 给定的情况下，第 $i$ 个人的排名为表现严格大于 $a_ix+bi$ 的人数再加一。  

在 $9102$ 年浙江省队的人数为 $m$，因此只有排名小于等于 $m$ 的人才能够进入浙江省队。注意当有并列的情况时，进入浙江省队的人数可能多于 $m$。

不难发现，选手的排名和 $x$ 的关系非常大。现在，可怜想让你计算，第 $i$ 个选手有没有可能进入浙江省队，如果有可能，他最好的排名是多少。  


## 说明/提示

## 样例 1 解释
当 $x=1$ 时，三个人的表现分别为 $6,6,4$，这时前两个人并列第一名，都能进入省队，而第三个人排名第三，没法进入省队。  

当 $x>1$ 时，第二个人的表现严格好于第三个人，而当 $x=0$ 时，第一个人的表现严格好于第三个人，因此第三个人无论 $x$ 怎么取，他都没有办法进入省队。  

## 数据范围与约定
| 测试点 | $n$ | $m$ | 测试点 | $n$ | $m$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $\le 200$ | $\le 20$ | $6$ | $\le 2\times 10^4$ | $\le 20$ |
| $2$ | $\le 200$ | $\le 20$ | $7$ | $\le 2\times 10^4$ | $\le 20$ |
| $3$ | $\le 10^5$ | $=1$ | $8$ | $\le 10^5$ | $\le 20$ |
| $4$ | $\le 10^5$ | $\le 2$ | $9$ | $\le 10^5$ | $\le 20$ |
| $5$ | $\le 10^5$ | $\le 2$  | $10$ | $\le 10^5$ | $\le 20$ |

对于 $100\%$ 的数据，$1\leq a_i \leq 10^9$，$1\leq b_i \leq 10^{18}$，$1\leq m \leq n$。

对于 $100\%$ 的数据，保证选手的属性两两不同，即 $ \forall 1\leq i < j \leq n$，有 $a_i\neq a_j$ 或 $b_i\neq b_j$。

## 样例 #1

### 输入

```
3 1
1 5
5 1
2 2```

### 输出

```
1 1 -1```

# 题解

## 作者：foreverlasting (赞：20)

[推销博客](https://foreverlasting1202.github.io/)

半平面交。

说个心酸经历，考场上半平面交板子不会了，然后就没有然后了。

这道题其实的确没有思维含量吧（？）首先第一名显然就是简单的半平面交，然后去掉第一名后，剩下的新出现的第一名就是第二名。然而不能一个个删去，肯定要把所有第一名删去。接着拿第一名们会使哪一段$x$坐标范围的名次$+1$，这个可以二分个位置，然后扫描线一下。当某人在边界上而且最多只被一个人覆盖的话，他的排名就可以上升了。

所以还是挺简单的。

code:
```cpp
//2019.5.6 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register LL
#define LL long long
#define inf 0x3f3f3f3f3f3f3f
#define eps 1e-10
#define RG register
inline LL read() {
    res s=0,ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s;
}
inline LL Read() {
    RG LL s=0;
    res ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s;
}
const LL N=1e5+10;
namespace MAIN {
    LL n,m;
    struct P{
        LL k,id;
        LL b;
        P() {}
        P(res k,RG LL b,res id):k(k),b(b),id(id) {}
        inline bool operator < (const P &B) const {
            return k!=B.k?k<B.k:b>B.b;
        }
    }a[N];
    LL ans[N];
    P st[N];
    struct A{
        LL a;
        LL b,c;
        A() {a=b=0,c=1;}
        A(RG LL x,res y){
            if(y<0)x=-x,y=-y;
            a=x/y,b=int(x%y),c=y;
            if(b<0)b+=c,a--;
        }
        inline bool operator < (const A &x) const {
            return a==x.a?b*x.c<x.b*c:a<x.a;
        }
        inline bool operator <=(const A &x) const {
            return a==x.a?b*x.c<=x.b*c:a<x.a;
        }
        inline LL floor(){
            return a;
        }
        inline LL ceil(){
            return a+(b>0);
        }
    }St[N];
    inline A cross(const RG P &a,const RG P &b){
        return A(b.b-a.b,a.k-b.k);
    }
    typedef pair<LL,LL> Pair;
#define mp make_pair
#define fi first
#define se second
    Pair sT[N<<1];
    inline void solve(const res &rnk){
        res tot=0,top=0;
        St[0]=A(0,1);
        for(res i=1;i<=n;i++)
            if(ans[a[i].id]==-1&&a[i].k>st[top].k){
                while(top&&cross(a[i],st[top]).floor()<St[top].ceil())top--;
                st[++top]=a[i];
                if(top>1)St[top]=cross(st[top-1],a[i]);
            }
        St[top+1]=A(inf,1);
        for(res i=1;i<=n;i++)
            if(ans[a[i].id]!=-1){
                res l=1,r=top,ret=0;
                while(l<=r){
                    res mid=(l+r)>>1;
                    if(st[mid].k>=a[i].k||cross(st[mid],a[i])<=St[mid+1])ret=mid,r=mid-1;
                    else l=mid+1;
                }
                sT[++tot]=mp(st[ret].k>=a[i].k?0:cross(st[ret],a[i]).floor()+1,1);
                l=1,r=top,ret=0;
                while(l<=r){
                    res mid=(l+r)>>1;
                    if(st[mid].k<=a[i].k||St[mid]<=cross(st[mid],a[i]))ret=mid,l=mid+1;
                    else r=mid-1;
                }
                if(st[ret].k>a[i].k)sT[++tot]=mp(cross(st[ret],a[i]).ceil(),-1);
            }
        sort(sT+1,sT+tot+1);
        for(res i=1,j=1,x=0;i<=top;i++){
            while(j<=tot&&sT[j].fi<=St[i].ceil())x+=sT[j++].se;
            if(x==rnk-1)ans[st[i].id]=rnk;
            while(j<=tot&&sT[j].fi<=St[i+1].floor()){
                res p=j;
                while(p<=tot&&sT[p].fi==sT[j].fi)x+=sT[p++].se;
                if(x==rnk-1)ans[st[i].id]=rnk;
                j=p;
            }
        }
    }
    inline void MAIN(){
        n=read(),m=read();
        for(res i=1;i<=n;i++){
            res k=read();
            RG LL b=Read();
            a[i]=P(k,b,i),ans[i]=-1;
        }
        sort(a+1,a+n+1);
        for(res i=1;i<=m;i++)solve(i);
        for(res i=1;i<=n;i++)printf("%lld ",ans[i]);
    }
}
int main() {
//    freopen("graph.in","r",stdin);
//    freopen("graph.out","w",stdout);
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：9AC8E2 (赞：13)

### 题面
[在这里](https://www.luogu.com.cn/problem/P5328)
### 题意简述
给定 $n$ 条形如$y=k_ix+b_i$的直线，求每条直线的最好排名


### 题解
排名为$1$的直线显然构成一个下凸壳,直接半平面交

排名为$2$的直线显然也构成一个下凸壳，但不能直接求，因为有可能下凸壳上的某条直线被完全覆盖了不止一次，这样它的排名显然不能为$2$

于是有这样一个算法：删去排名为$1$的所有直线，对于排名为$1$的所有直线，二分出它作为$rank1$存在的区间$[l,r]$，这显然是一个连续的区间。将区间$(l,r)+1$,表示这个区间内的数都被它覆盖了一次，最后对于去掉$rank1$直线的集合的下凸壳中的每条直线进行考虑，若它作为最大值存在的区间内存在一个整数满足它只被覆盖了一次，那么这条直线就可以作为$rank2$

以此类推，依次考虑$1\leq i\leq m$的所有排名，删去集合中$1\leq rank\leq i-1$的所有直线，计算每个点被覆盖的次数，扫描当前凸壳上的每一条直线，若存在一个$x$，使这条直线在$x$处取值大于等于集合中剩下的直线(即在凸壳上)，且$x$只被覆盖$i-1$次，那么这条直线的排名为$i$

最后仍然没有求出排名的线段显然不能*进入省队*(悲)，输出为$-1$

### 细节

1. 不能用`double`,要手写带分数
2. 记得开`long long`,`1e18`
3. 若两条直线的交点横坐标为整数，那么它同时被这两条直线覆盖
4. 可以用解析式存直线

### 代码
```
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T& t)
{T f=1;char ch=getchar();t=0;
while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
while(ch>='0'&&ch<='9')t=t*10+ch-'0',ch=getchar();t*=f;}
template <typename T,typename... Args>
inline void read(T& t, Args&... args)
{read(t);read(args...);}
#define DEBUG if(0)
#define JUDGE if(0)
int n,m;
struct Double
{
	long long a,b,c;
	Double(){a=b=0;c=1;}
	Double(long long A){a=A;b=0;c=1;}
	Double(long long A,long long B)
	{
		if(B<0)A=-A,B=-B;
		a=A/B;b=A%B;c=B;
		if(b<0)b+=B,a--;
	}
	bool operator < (const Double & B)
	{
		if(a==B.a)return b*B.c<B.b*c;
		return a<B.a;
	}
	bool operator <=(const Double & B)
	{
		if(a==B.a)return b*B.c<=B.b*c;
		return a<B.a;
	}
	inline long long floor(){return a;}
	inline long long ceil(){return a+(b>0);}
	inline void print(){printf("Double:this=%u %lld+%lld/%lld\n",this,a,b,c);}
};
struct Person
{
	long long k,b;int id;
	Person(){}
	Person(long long K,long long B,int ID){k=K;b=B;id=ID;}
	inline bool operator < (const Person & B)const{return k==B.k?b>B.b:k<B.k;}
	inline void print(){printf("Person:this=%u k=%lld b=%lld id=%d\n",this,k,b,id);}
};
Person person[1000005];
int ans[1000005];
Double cross(const Person & A,const Person & B)//返回交点的横坐标 
{return Double(A.b-B.b,B.k-A.k);}
Person ST[1000005];
int ST_top=0;
Double var[1000005],var_top;
int over[1000005];
bool in_ST[1000005];
void solve(int rank)
{
	ST_top=0;
	var[0]=Double(0,1);
	for(int i=1;i<=n;i++)
		if(ans[person[i].id]==-1&&person[i].k>ST[ST_top].k)
		{
			while(ST_top&&cross(person[i],ST[ST_top]).floor()<var[ST_top].ceil())ST_top--;
			//ST[ST_top]的范围：[ var[ST_top].ceil(),cross(person[i],ST[ST_top]).floor()]
			ST[++ST_top]=person[i];
			if(ST_top>1)var[ST_top]=cross(ST[ST_top-1],ST[ST_top]);
		}
	memset(in_ST,0,sizeof(in_ST));
	for(int i=1;i<=ST_top;i++)in_ST[ST[i].id]=1;
DEBUG	printf("ST_top=%d\n",ST_top);
	var[1]=Double(0,1);//
	var[ST_top+1]=Double(1e18,1);
DEBUG	for(int i=1;i<=ST_top;i++)var[i].print();
DEBUG	for(int i=1;i<=ST_top;i++)ST[i].print();
	memset(over,0,sizeof(over));
	vector<pair<long long,int> > pos;
	for(int i=1;i<=n;i++)
		if(ans[person[i].id]!=-1)
		{
			int L,R;
			int l,r,mid;
			l=1;r=ST_top;
			while(l<r)
			{
				mid=(l+r+1)>>1;
				if(ST[mid].k>=person[i].k||cross(ST[mid],person[i])<=var[mid])r=mid-1;
				else l=mid;
			}
			L=l;
			l=1;r=ST_top;
			while(l<r)
			{
				mid=(l+r)>>1;
				if(ST[mid].k<=person[i].k||var[mid+1]<=cross(ST[mid],person[i]))l=mid+1;
				else r=mid;
			}
			R=l;
			if(ST[L].k>=person[i].k||cross(person[i],ST[L]).floor()+1<0)pos.push_back(make_pair(0,1));//
			else pos.push_back(make_pair(cross(person[i],ST[L]).floor()+1,1));//如果交点恰好是整点，也不算被覆盖，所以是floor+1; 
			if(ST[R].k>person[i].k&&cross(person[i],ST[R]).ceil()>=0)pos.push_back(make_pair(cross(person[i],ST[R]).ceil(),-1));//同上 
		}
	int mp_tot=0;
	map<long long,int>mp;
	for(auto i:pos)
		if(mp.count(i.first)==0)
			mp[i.first];
	for(int i=1;i<=ST_top+1;i++)
		if(mp.count(var[i].floor())==0)
			mp[var[i].floor()];
	for(int i=1;i<=ST_top+1;i++)
		if(mp.count(var[i].ceil())==0)
			mp[var[i].ceil()];
	mp_tot=0;
	for(map<long long,int>::iterator i=mp.begin();i!=mp.end();i++)i->second=++mp_tot;
	for(vector<pair<long long,int> >::iterator i=pos.begin();i!=pos.end();i++)i->first=mp[i->first];
DEBUG	for(auto i:pos)printf("pos %d,add %d\n",i.first,i.second);	
	for(auto i:pos)over[i.first]+=i.second;
	for(int i=1;i<=mp_tot;i++)over[i]+=over[i-1];
DEBUG	for(auto i:mp)printf("first=%lld second=%d\n",i.first,i.second);
DEBUG {for(int i=1;i<=mp_tot;i++)printf("%d ",over[i]);printf("\n");}
	for(int i=1;i<=ST_top;i++)
	{
DEBUG		printf("id=%d [%d,%d]\n",ST[i].id,mp[var[i].ceil()],mp[var[i+1].floor()]);
		for(int j=mp[var[i].ceil()];j<=mp[var[i+1].floor()];j++)
			if(over[j]==rank-1)
				ans[ST[i].id]=rank;
	}	
}
int main()
{
JUDGE	freopen("data.in","r",stdin);
JUDGE	freopen("sol.out","w",stdout);
	read(n,m);
	for(int i=1;i<=n;i++)read(person[i].k,person[i].b),person[i].id=i;
	memset(ans,-1,sizeof(ans));
	sort(person+1,person+n+1);
DEBUG	for(int i=1;i<=n;i++)person[i].print();
	for(int i=1;i<=m;i++)solve(i);
	for(int i=1;i<=n;i++)printf("%d ",ans[i]);
	return 0;
}
```
#### 另附数据生成器
```
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T& t)
{T f=1;char ch=getchar();t=0;
while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
while(ch>='0'&&ch<='9')t=t*10+ch-'0',ch=getchar();t*=f;}
template <typename T,typename... Args>
inline void read(T& t, Args&... args)
{read(t);read(args...);}
long long random()
{
	return abs((unsigned long long)rand()*rand()*rand()*rand());
}
int main()
{
	srand((unsigned long long)time(0));
	freopen("data.in","w",stdout);
	printf("3 100\n");
	for(int i=1;i<=3;i++)
		printf("%lld %lld\n",random()%1000000000,random()%1000000000000000000);
	return 0;
}
```

---

## 作者：花淇淋 (赞：9)

# Address
[Luogu P5328](https://www.luogu.org/problemnew/show/P5328)

# Solution
 - ~~这是什么神仙题~~ 
 - ~~蒟蒻编了一个辣鸡做法搞了一天才过~~
 - 把每个人看作直线 : $y=a_ix+b_i$，枚举$i=1→m$，并分别求出最好排名为 $i$ 的直线集合。
 - 显然能拿 $rank1$ 的直线必须位于下凸壳上。
 - 注意由于 $x$ 必须为**非负整数**，这个下凸壳上的点必须都是整数，举个例子：某条直线在 $0.5≤x≤0.8$ 的时候能拿 $rank1$，那么这条直线不在下凸壳上。
 - 由于$x∈(0,+∞)$，下凸壳由**一些线段和最右的一条射线**组成
 - 能拿 $rank2$ 的直线必须满足：
   $1.$ 除掉能拿 $rank1$ 的直线之后，位于下凸壳上。
   $2.$ 存在一个**非负整数** $x$，使得最多一条 $rank1$ 直线在它之上。
 - 条件 $1$ 十分简单，跟求能拿 $rank1$ 的直线的方法一样。
 - 对于条件 $2$：枚举每一条能拿 $rank1$ 的直线 $y=cx+d$，二分出两个**非负整数**$l,r$，若凸壳用 $y=f(x)$ 表示，则当 $x∈[l,r]$ 时，$cx+d>f(x)$。
 - 为降低时间复杂度，不用二分 $l,r$ 的值，而是二分直线和凸壳“相交”于哪一条线段或射线。
 - 注意这个 $r$ 可能无限大。
 - 然后把每条直线的 $l,r$，以及每条线段（或射线）的端点（端点也应是**非负整数**，若端点为 $u,v$，则表示 $x∈[u,v]$ 时，这条线段（或射线）在凸壳上是 $rank1$。特别地，射线的右端点可以设为一个很大的数。）放入一个数组 $h$ 进行排序离散化。
 - 离散化后，如果有 $h[i]+1<h[i+1]$，再往 $h$ 中加入 $h[i]+1$。
 - 再次排序，离散化。
 - 把每条直线的 $l,r$ 在离散化后的数组上做差分，即对于每个 $h[i]$，算出 $x=h[i]$ 时，有几条 $rank1$ 的直线在凸壳之上（即点的被覆盖次数）。
 - 然后枚举凸壳上的所有线段（或射线），如果$h$ 中所有位于此线段上的点中，被覆盖次数的最小值 $<2$，则这条线段的最好排名为 $rank2$。
 - 对于 $rank3,rank4$，依此类推即可。
 - 还没结束！
 - 由 $a_i≤10^{9},b_i≤10^{18}$ 可知，此题我们不可以用 $double$ 表示实数（毒瘤精度误差），要用分数表示实数，而且不能用假分数，要用带分数（表示为 $a+\frac{b}{c}$，其中 $0≤b<c$）。$QAQ$
 
 # Code
 - ~~我的做法是不是太麻烦了~~ 

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long

const int e = 1e6 + 5;
const ll inf = 2e18;
const double eps = 1e-12;
int id[e], stk[e], top, n, st[e][20], m, ans[e], cnt, rk, s[e], p[e], w, logn[e], tot;
ll a[e], b[e], h[e], g[e];
struct frac
{
    ll a, b, c;
    frac() {a = b = 0; c = 1;}
    frac(ll x, ll y)
    {
        if (y < 0) x = -x, y = -y;
        a = x / y; c = y; b = x % y;
        if (b < 0) b += y, a--;
    }
    inline ll floor() 
    {
        return a; 
    }
    inline ll ceil()
    {
        return b % c ? a + 1 : a;
    }
}c[e];
struct work
{
    ll l, r;
}q[e];

template <class t>
inline void read(t & res)
{
    char ch;
    while (ch = getchar(), !isdigit(ch));
    res = ch ^ 48;
    while (ch = getchar(), isdigit(ch))
    res = res * 10 + (ch ^ 48);
}

inline bool operator > (frac a, frac b)
{
    return a.a != b.a ? a.a > b.a : a.b * b.c > a.c * b.b;
}

inline bool cmp(int x, int y)
{
    return a[x] != a[y] ? a[x] < a[y] : b[x] > b[y];
}

inline bool check(int p1, int p2, int p3)
{
    ll k1 = ceil(1.0 * (b[p1] - b[p2]) / (a[p2] - a[p1])), 
        k2 = floor(1.0 * (b[p2] - b[p3]) / (a[p3] - a[p2]));
    return k1 > k2;
}

inline double cross(ll a1, ll b1, ll a2, ll b2)
{
    return 1.0 * (b1 - b2) / (a2 - a1);
}

inline void rmq()
{
    int i, j;
    logn[0] = -1;
    for (i = 1; i <= w; i++) logn[i] = logn[i >> 1] + 1, st[i][0] = s[i];
    for (j = 1; (1 << j) <= w; j++)
    for (i = 1; i + (1 << j) - 1 <= w; i++)
    st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
}

inline int ask(int l, int r)
{
    int k = logn[r - l + 1];
    return min(st[l][k], st[r - (1 << k) + 1][k]);
}

inline bool judge(ll x, ll y, frac z)
{
    if (x > 0) return z > frac(y, x);
    else return frac(-y, -x) > z;
}

inline void solve(int k)
{
    int i; cnt = m = 0; top = 0;
    for (i = 1; i <= n; i++)
    if (ans[i] == -1) p[++m] = i;
    sort(p + 1, p + m + 1, cmp);
    for (i = 1; i <= m; i++)
    if (i == 1 || a[p[i]] != a[p[i - 1]]) id[++cnt] = p[i];
    for (i = 1; i <= cnt; i++)
    {
        while (top > 0 && b[stk[top]] < b[id[i]]) top--; 
        while (top > 1 && check(stk[top - 1], stk[top], id[i])) top--;	
        stk[++top] = id[i];
    }
    m = cnt = 0;
    for (i = 1; i <= top; i++) id[++m] = stk[i];
    if (k == 1)
    {
        for (i = 1; i <= top; i++) ans[stk[i]] = 1;
        return;
    }
    for (i = 1; i <= m; i++) 
    {
        if (i == 1) c[i] = frac(0, 1);
        else c[i] = frac(b[id[i]] - b[id[i - 1]], a[id[i - 1]] - a[id[i]]);
    }
    c[m + 1] = frac(inf, 1);
    for (i = 1; i <= n; i++)
    if (ans[i] != -1)
    {
        ll c1 = a[i], d1 = b[i]; 
        int p1 = m + 2, p2 = 0, l = 1, r = m + 1;
        while (l <= r)
        {
            int mid = l + r >> 1;
            if (mid == m + 1)
            {
                if (c1 > a[id[m]] || (c1 == a[id[m]] && d1 > b[id[m]])) p1 = mid;
                r = mid - 1;
                continue;
            } 
            if (c1 == a[id[mid]] || judge(c1 - a[id[mid]], b[id[mid]] - d1, c[mid]))
            {
                p1 = mid;
                r = mid - 1;
            }
            else if (a[id[mid]] < c1) l = mid + 1;
            else r = mid - 1;
        }
        l = 1; r = m + 1;
        while (l <= r)
        {
            int mid = l + r >> 1;
            if (mid == m + 1)
            {
                if (c1 > a[id[m]] || (c1 == a[id[m]] && d1 > b[id[m]])) p2 = mid;
                l = mid + 1;
                continue;
            }
            if (c1 == a[id[mid]] || judge(c1 - a[id[mid]], b[id[mid]] - d1, c[mid]))
            {
                p2 = mid;
                l = mid + 1;
            }
            else if (a[id[mid]] < c1) l = mid + 1;
            else r = mid - 1;
        }
        cnt++;
        if (p1 == 1) q[cnt].l = 0;
        else 
        {
            q[cnt].l = ceil(cross(a[id[p1 - 1]], b[id[p1 - 1]], c1, d1));
            if ((d1 - b[id[p1 - 1]]) % (a[id[p1 - 1]] - c1) == 0) q[cnt].l++;
        }
        if (p2 == m + 1) q[cnt].r = inf;
        else 
        {
            q[cnt].r = floor(cross(a[id[p2]], b[id[p2]], c1, d1));
            if ((d1 - b[id[p2]]) % (a[id[p2]] - c1) == 0) q[cnt].r--;
        }
        if (q[cnt].l > q[cnt].r) cnt--;
    }
    tot = 0;
    for (i = 1; i <= cnt; i++) h[++tot] = q[i].l, h[++tot] = q[i].r;
    for (i = 1; i <= m; i++) h[++tot] = c[i].ceil(), h[++tot] = c[i + 1].floor(); 
    sort(h + 1, h + tot + 1);
    w = 0;
    for (i = 1; i <= tot; i++)
    if (i == 1 || h[i] != h[i - 1]) g[++w] = h[i];
    sort(g + 1, g + w + 1);
    int w0 = w;
    for (i = 1; i < w0; i++)
    if (g[i] + 1 != g[i + 1]) g[++w] = g[i] + 1;
    sort(g + 1, g + w + 1);
    memset(s, 0, sizeof(s));
    for (i = 1; i <= cnt; i++)
    {
        int x = lower_bound(g + 1, g + w + 1, q[i].l) - g,
            y = lower_bound(g + 1, g + w + 1, q[i].r) - g;
        s[x]++;
        s[y + 1]--;
    }
    for (i = 1; i <= w; i++) s[i] += s[i - 1];
    rmq();
    for (i = 1; i <= m; i++)
    {
        ll x = c[i].ceil(), y = c[i + 1].floor(); 
        int px = lower_bound(g + 1, g + w + 1, x) - g,
            py = upper_bound(g + 1, g + w + 1, y) - g - 1;
        if (ask(px, py) < k) ans[id[i]] = k;
    }
}

int main()
{
    read(n); read(rk);
    int i;
    for (i = 1; i <= n; i++) read(a[i]), read(b[i]), ans[i] = -1;
    for (i = 1; i <= rk; i++) solve(i);
    for (i = 1; i <= n; i++) printf("%d ", ans[i]);
    putchar('\n');
    return 0;
}
 ```

---


# [SNOI2019] 通信

## 题目描述

$n$ 个排成一列的哨站要进行通信。第 $i$ 个哨站的频段为 $a_i$。

每个哨站 $i$ 需要选择以下二者之一：

1. 直接连接到控制中心，代价为 $W$；
2. 连接到前面的某个哨站 $j$ ($j<i$)，代价为 $|a_i-a_j|$。
每个哨站只能被后面的至多一个哨站连接。

请你求出最小可能的代价和。

## 说明/提示

对于所有数据，$1 \leq n \leq 1000$，$0 \leq W,a_i \leq 10^9$。

对于 $10\%$ 的数据，$n \leq 10$；

对于另外 $10\%$ 的数据，$n \leq 20$；

对于另外 $20\%$ 的数据，$n \leq 50$，$W \leq 5$，$a_i \leq 4$；

对于另外 $20\%$ 的数据，$n \leq 100$；

对于另外 $20\%$ 的数据，$n \leq 300$；

对于余下 $20\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
6 7
8 4 6 1 3 0```

### 输出

```
23```

## 样例 #2

### 输入

```
8 4
0 4 2 6 1 5 3 7```

### 输出

```
18```

# 题解

## 作者：lhm_ (赞：31)

考虑用费用流解决本题。

每个哨站看作一个点，并将其拆为两个点，建图方式为：

$S \longrightarrow x_i$ 容量为$1$,费用为$0$

$x_i \longrightarrow T$ 容量为$1$,费用为$w$

$x_i \longrightarrow x^\prime_j\ (i>j)$ 容量为$1$,费用为$|a_i-a_j|$

$x^\prime_i \longrightarrow T$ 容量为$1$,费用为$0$

这样就可以满足题目要求了，跑最小费用最大流即可求解，但发现边数为$n^2$级别，所以要考虑优化建图。

一个点在和拆出来的点连边时，只会向下标比其小的点连边，所以可以通过分治来实现优化建图。

对于区间$[l,r]$，分成两个区间$[l,mid]$和$[mid+1,r]$，每次从右区间向左区间连边。还需考虑费用的绝对值如何处理，可以把这一区间内所有的权值排序去重，然后连成一条链，链上边的费用为相邻两点的权值之差，然后把这条链作为连接右区间和左区间的虚点。

区间内的点向虚点连边时，只需找到其权值所对应到链上的位置，然后向对应位置连边即可，这样就通过累积权值之间的差值实现了费用的绝对值。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 800010
#define inf 2000000000
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,w,tot,cnt,s,t;
int p1[maxn],p2[maxn];
ll a[maxn],b[maxn],dis[maxn];
bool vis[maxn];
struct edge
{
    int to,nxt,v;
    ll c;
}e[maxn];
int head[maxn],edge_cnt=1;
void add(int from,int to,int val,ll cost)
{
    e[++edge_cnt]=(edge){to,head[from],val,cost};
	head[from]=edge_cnt;
    e[++edge_cnt]=(edge){from,head[to],0,-cost};
	head[to]=edge_cnt;
}
bool spfa()
{
    for(int i=1;i<=tot;++i) vis[i]=0,dis[i]=inf;
    queue<int> q;
    q.push(s),dis[s]=0,vis[s]=true;
    while(!q.empty())
    {
        int x=q.front();
        q.pop(),vis[x]=false;
        for(int i=head[x];i;i=e[i].nxt)
        {
            int y=e[i].to,v=e[i].v;
            ll c=e[i].c;
            if(v&&dis[y]>dis[x]+c)
            {
                dis[y]=dis[x]+c;
                if(!vis[y]) q.push(y),vis[y]=true;
            }
        }
    }
    return dis[t]!=inf;
}
int dfs(int x,int lim)
{
    if(x==t) return lim;
    vis[x]=true;
    int res=lim,flow;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to,v=e[i].v;
        ll c=e[i].c;
        if(!v||dis[y]!=dis[x]+c||vis[y]) continue;
        if(flow=dfs(y,min(res,v)))
        {
            res-=flow;
            e[i].v-=flow;
            e[i^1].v+=flow;
            if(!res) break;
        }
    }
    return lim-res;
}
ll dinic()
{
    int flow;
    ll sum=0;
    while(spfa())
        while(flow=dfs(s,inf))
            sum+=flow*dis[t];
    return sum;
}
void solve(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)>>1;
    solve(l,mid),solve(mid+1,r),cnt=0;
    for(int i=l;i<=r;++i) b[++cnt]=a[i];
    sort(b+1,b+cnt+1),cnt=unique(b+1,b+cnt+1)-b-1;
    for(int i=1;i<cnt;++i)
    {
        add(tot+i,tot+i+1,inf,b[i+1]-b[i]);
        add(tot+i+1,tot+i,inf,b[i+1]-b[i]);
    }
    for(int i=l;i<=r;++i)
    {
        int pos=lower_bound(b+1,b+cnt+1,a[i])-b;
        if(i>mid) add(p1[i],tot+pos,1,0);
        else add(tot+pos,p2[i],1,0);
    }
    tot+=cnt;
}
int main()
{
    read(n),read(w),s=++tot,t=++tot;
    for(int i=1;i<=n;++i) read(a[i]);
    for(int i=1;i<=n;++i)
    {
        p1[i]=++tot,p2[i]=++tot;
        add(s,p1[i],1,0),add(p1[i],t,1,w),add(p2[i],t,1,0);
    }
    solve(1,n),printf("%lld",dinic());
    return 0;
}
```


---

## 作者：mrsrz (赞：12)

从最简单的费用流开始。

把每个点拆成两个点，分别表示连出的和连入的。

然后对点$i$，从控制中心连向$i$的连入点容量为1，费用为$W$的边，再对于$\forall j< i$，从$j$的连出点连向$i$的连入点容量为1，费用为$|a_i-a_j|$的边，剩下的边容量1，费用0。

跑最小费用最大流，所得最小费用即为所求。

这样连的边数是$O(n^2)$的，过不去。

我们考虑优化这个建边过程。

以下将要介绍一种非常暴力且容易理解的优化连边方式——**分块**。

首先修改一下原来的建边方式。

对于连出点，我们拆成三个，$L_{i,0},L_{i,1},L_{i,2}$。然后，从$L_{i,2}$向$L_{i,0}$连容量为1，费用为$-a_i$的边；从$L_{i,2}$向$L_{i,1}$连容量为1，费用为$a_i$的边。

同理对于连入点，我们也拆成三个$R_{i,0},R_{i,1},R_{i,2}$。然后，从$R_{i,0}$向$R_{i,2}$连容量为1，费用为$-a_i$的边；从$R_{i,1}$向$R_{i,2}$连容量为1，费用为$a_i$的边。

然后，对于任意的$j< i$，若$a_j>a_i$，则从$L_{j,1}$向$R_{i,0}$连容量为1，费用为0的边。反之，从$L_{j,0}$向$R_{i,1}$连容量为1，费用为0的边。

这样的效果是一样的，但边数还是$O(n^2)$的。

接下来对节点进行分块，对每个块内的节点，按照其$a$的值进行排序。然后，将其前缀、后缀连到一起。这部分的边数是可以做到线性的。

然后对每个节点，之前每个块的点向其连边的时候，都可以只连2条边解决，而块内的连边也只有$O(\sqrt n)$条。

那么边数就被优化到$O(n\sqrt n)$条了。

然后对费用流算法进行合理的常数优化，就可以大力卡过这题了。

## Code：
```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<utility>
#define bel(x)((x-1)/siz+1)
const int N=105555,inf=2e9;
typedef long long LL;
int to[N*30],nxt[N*30],cap[N*30],cost[N*30];
int head[N],cnt=1,n,W,ct,A[N],T,a[N],pre_e[N],vis[N],t0t,L0[N],L1[N],R0[N],R1[N],L2[N],R2[N],siz,Lb[N],Rb[N],blocks;
int pre[N],suf[N];
int dis[N];
std::pair<int,int>pr[N];
inline void addedge(int u,int v,int c,int t){
    to[++cnt]=v,nxt[cnt]=head[u],cap[cnt]=c,cost[cnt]=t,head[u]=cnt,
    to[++cnt]=u,nxt[cnt]=head[v],cap[cnt]=0,cost[cnt]=-t,head[v]=cnt;
}
int q[1050005];
int spfa(int&flow,LL&Cost){
    for(int i=0;i<=t0t;++i)dis[i]=inf,a[i]=inf,pre_e[i]=vis[i]=0;
    dis[0]=0;
    int hd=0,tail=1;
    for(q[1]=0;hd!=tail;){
        int u=q[hd=(hd&1048575)+1];
        vis[u]=0;
        for(int i=head[u];i;i=nxt[i])
        if(cap[i]&&dis[to[i]]>dis[u]+cost[i]){
            dis[to[i]]=dis[u]+cost[i],a[to[i]]=std::min(a[u],cap[i]),pre_e[to[i]]=i;
            if(!vis[to[i]])vis[q[tail=(tail&1048575)+1]=to[i]]=1;
        }
    }
    if(a[T]==inf)return 0;
    flow+=a[T],Cost+=(LL)a[T]*dis[T];
    for(int i=T;i;i=to[pre_e[i]^1])
    cap[pre_e[i]]-=a[T],cap[pre_e[i]^1]+=a[T];
    return 1;
}
int main(){
    scanf("%d%d",&n,&W);
    siz=sqrt(n)*1.41;
    blocks=bel(n);
    for(int i=1;i<=blocks;++i)Lb[i]=Rb[i-1]+1,Rb[i]=i*siz;Rb[blocks]=n;
    for(int i=1;i<=n;++i)scanf("%d",a+i),pr[i]=std::make_pair(a[i],i);
    for(int i=1;i<=blocks;++i)std::sort(pr+Lb[i],pr+Rb[i]+1);
    t0t=n*6+1;
    ct=++t0t,T=++t0t;
    addedge(0,ct,inf,W);
    for(int i=1;i<=n;++i){
        L2[i]=i,L0[i]=i+n,L1[i]=i+n*2;
        addedge(0,L2[i],1,0),addedge(L2[i],L1[i],1,a[i]),addedge(L2[i],L0[i],1,-a[i]);
        R2[i]=i+n*3,R0[i]=i+n*4,R1[i]=i+n*5;
        addedge(R2[i],T,1,0),addedge(R1[i],R2[i],1,a[i]),addedge(R0[i],R2[i],1,-a[i]);
        addedge(ct,R2[i],1,0);
    }
    for(int i=1;i<blocks;++i){
        pre[Lb[i]]=L0[pr[Lb[i]].second];
        for(int j=Lb[i]+1;j<=Rb[i];++j){
            int&nw=pre[j];nw=++t0t;
            addedge(pre[j-1],nw,1,0),addedge(L0[pr[j].second],nw,1,0);
        }
        suf[Rb[i]]=L1[pr[Rb[i]].second];
        for(int j=Rb[i]-1;j>=Lb[i];--j){
            int&nw=suf[j];nw=++t0t;
            addedge(suf[j+1],nw,1,0),addedge(L1[pr[j].second],nw,1,0);
        }
    }
    for(int i=1;i<=n;++i){
        const int bl=bel(i);
        for(int j=1;j<bl;++j){
            if(a[i]<=pr[Lb[j]].first)addedge(suf[Lb[j]],R0[i],1,0);else
            if(a[i]>=pr[Rb[j]].first)addedge(pre[Rb[j]],R1[i],1,0);else{
                int x=0;
                for(int k=Lb[j];k<Rb[j];++k)
                if(pr[k].first<=a[i]&&a[i]<=pr[k+1].first){x=k;break;}
                addedge(pre[x],R1[i],1,0),addedge(suf[x+1],R0[i],1,0);
            }
        }
        for(int j=Lb[bl];j<i;++j)
        if(a[j]>a[i])addedge(L1[j],R0[i],1,0);else addedge(L0[j],R1[i],1,0);
    }
    int flow=0;LL cost=0;
    while(spfa(flow,cost));
    printf("%lld\n",cost);
    return 0;
}

```

---

## 作者：EnofTaiPeople (赞：8)

本题是一道数据玄学的费用流题，之所以说数据玄学，大家可以先看一个解法。

既然是一道费用流的题目，首先考虑如何建图。先不考虑想其他站连接，我们可以建立源点 s，建立汇点 t，对于每一个站建立一个点，从 s 向每一个站连一条边，流量为 1，费用为 0，表示每个点都有一个任务：将这个流量输送到 t 点；同时，从每一个点向 t 点连一条边，流量为 1，费用为 W，表示直接通过自己完成任务需要 W 的代价。

这样不考虑向其他点连边，跑出来的最小费用一定是 $n\times W$，那么，怎么向其他点连边呢？

考虑对每一个点，建一个次点，用来输送连向它的点的流量，因为每一个点只能被一个点连起来，所以，每一个次点向 t 点连一条边，流量为 1，费用为 0。从每一个主点向前面每一个次点连边，流量为 1，费用为两者距离差的绝对值。

容易看出来，这样跑出来的最小费用一定就是答案。

这样的边是 $n^2$ 级别的，加上对费用超过 W 的边剪枝，仍然有不少的边，这样的规模 EK 算法应该过不了，考虑优化这个算法。

多路增广费用流就是每找到一次最短路，将所有费用等于 s 到 t 的增广路全部增广，具体是将 Dinic 的分层条件：
```cpp
d[y]==d[x]+1
```
改成这一条边在最短路上：
```cpp
dis[y]=dis[x]+C[i]
```
这样得出的代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10005,M=4e6+6,T=0x3f3f3f3f;
char buf[1<<23],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2))?EOF:*p1++
inline int read(){
	int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
	do an=an*10+c-'0';while(isdigit(c=gc));return an*f;
}
int a[N],Head[N],ed[M],to[M],wt[M],ct[M],tot=1,dis[N],now[N],qr[N],hp,tp,n,s,t,Sqt,Mincost,MaxW;
bool vis[N];
inline void AddEdge(int u,int v,int W,int C){
	ed[++tot]=v;to[tot]=Head[u];Head[u]=tot;wt[tot]=W;ct[tot]=C;
	ed[++tot]=u;to[tot]=Head[v];Head[v]=tot;ct[tot]=-C;return;
}
inline bool Spfa(){
	qr[hp=tp=1]=s;int i,x,y;for(i=1;i<=t;++i)dis[i]=T;now[s]=Head[s];
	while(hp!=tp+1){
		x=qr[hp++];if(hp==N)hp=1;vis[x]=false;
		for(i=Head[x];i;i=to[i])
			if(wt[i]&&dis[y=ed[i]]>dis[x]+ct[i]){
				dis[y]=dis[x]+ct[i];
				if(!vis[y]){
					if(dis[y]-Sqt>dis[qr[hp]]){
						if(--hp==0)hp=N-1;qr[hp]=y;
					}else{
						if(++tp==N)tp=1;qr[tp]=y;
					}
					vis[y]=true;
					now[y]=Head[y]; 
				}
			}
	}
	return dis[t]!=T;
}
int mcmf(int x,int flow){
	if(!flow)return 0;
	if(x==t){Mincost+=flow*dis[x];return flow;}
	int k,y,rest=flow;vis[x]=true;
	for(int &i=now[x];i;i=to[i])
		if(wt[i]&&!vis[y=ed[i]]&&dis[y]==dis[x]+ct[i]){
			if(!(k=mcmf(y,min(wt[i],rest))))dis[y]=T;
			else{wt[i]-=k;wt[i^1]+=k;if(!(rest-=k))break;}
		}
	vis[x]=false;
	return flow-rest;
}
int main(){
	n=read();MaxW=read();int i,j,nowdis;
	for(i=1;i<=n;++i)
		for(j=1,a[i]=read();j<i;++j)
			if((nowdis=abs(a[i]-a[j]))<MaxW)
				AddEdge((i<<1)-1,j<<1,1,nowdis),Sqt+=nowdis;
	t=(n<<1)|1,s=t+1;
	for(i=1;i<=n;++i){
		AddEdge(s,(i<<1)-1,1,0);
		AddEdge(i<<1,t,1,0);
		AddEdge((i<<1)-1,t,1,MaxW);
		Sqt+=MaxW;
	}
	Sqt=sqrt(Sqt);
	while(Spfa()){while(mcmf(s,T));}
	printf("%d\n",Mincost);
	return 0;
}
```
这样的代码已经足以通过此题了，但是，以下程序生成的数据能将部分题解包括以上代码卡到 $6s-100s$，这就是此题数据玄学（过水）的原因。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	freopen("IO.in","w",stdout);
	puts("1000 10000000");
	for(int i=1;i<=1000;++i)
		printf("%d ",rand());
	putchar('\n');
	return 0;
} 
```
本人亲测，以上的代码要跑 $96.72s$，我们该如何优化呢？
我们可以通过归并排序（也可称之为 CDQ 分治）的思想来优化建图，定义 `CDQ(l,r)` 会将 $mid+1-r$ 的所有点向 $l-mid$ 的次点连边，并将 $l-r$ 按坐标给编号排序；我们可以做如下工作：
1. 递归调用 `CDQ(l,mid)` 和 `CDQ(mid+1,r)`；
2. 对于所有 $x\in [l,mid)$，将 `Id[x]` 向 `Id[x+1]` 连边；
3. 对于所有 $x\in (l,mid]$，将 `Id[x]` 向 `Id[x-1]` 连边；
4. 对于所有 $x\in (mid,r]$,将 `Id[x]` 向 对应次点连边；
5. 将两边用 merge 函数进行归并。

不得不说，这个过程比较复杂，大家可以通过代码进行理解：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50005,M=4e6+6,T=0x3f3f3f3f;
char buf[1<<23],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2))?EOF:*p1++
inline int read() {
	int an=0,f=1;
	while(!isdigit(c=gc))if(c=='-')f=-f;
	do an=an*10+c-'0';
	while(isdigit(c=gc));
	return an*f;
}
int a[N],Head[N],ed[M],to[M],wt[M],ct[M],tot=1,dis[N],Maxd;
int now[N],qr[N],hp,tp,n,s,t,Sqt,Mincost,MaxW,Id[N],resb[N];
bool vis[N];
inline bool Acmp(const int &x,const int &y) {
	return a[x]<a[y];
}
inline void AddEdge(int u,int v,int W,int C) {
	ed[++tot]=v;
	to[tot]=Head[u];
	Head[u]=tot;
	wt[tot]=W;
	ct[tot]=C;
	ed[++tot]=u;
	to[tot]=Head[v];
	Head[v]=tot;
	ct[tot]=-C;
	if(C>0)Sqt+=C;
	return;
}
inline bool Spfa() {
	qr[hp=tp=1]=s;
	int i,x,y;
	for(i=1; i<=t; ++i)dis[i]=T,now[i]=Head[i];
	now[s]=Head[s];
	while(hp!=tp+1) {
		x=qr[hp++];
		if(hp==N)hp=1;
		vis[x]=false;
		for(i=Head[x]; i; i=to[i])
			if(wt[i]&&dis[y=ed[i]]>dis[x]+ct[i]) {
				dis[y]=dis[x]+ct[i];
				if(!vis[y]) {
					if(dis[y]-Sqt>dis[qr[hp]]) {
						if(--hp==0)hp=N-1;
						qr[hp]=y;
					} else {
						if(++tp==N)tp=1;
						qr[tp]=y;
					}
					if(dis[qr[hp]]>dis[qr[tp]])qr[hp]^=qr[tp]^=qr[hp]^=qr[tp];
					vis[y]=true;
				}
			}
	}
	return dis[t]!=T;
}
int mcmf(int x,int flow) {
	if(x==t) {
		Mincost+=flow*dis[x];
		return flow;
	}
	int k,y,rest=flow;
	vis[x]=true;
	for(int &i=now[x]; i; i=to[i])
		if(wt[i]&&!vis[y=ed[i]]&&dis[y]==dis[x]+ct[i]) {
			if(!(k=mcmf(y,min(wt[i],rest))))dis[y]=T;
			else {
				wt[i]-=k;
				wt[i^1]+=k;
				if(!(rest-=k))break;
			}
		}
	vis[x]=false;
	return flow-rest;
}
void CDQ(int l,int r,int dep) {
	if(l==r) {
		Maxd=max(Maxd,dep<<1);
		return;
	}
	int mid=l+((r-l)>>1);
	CDQ(l,mid,dep+1);
	CDQ(mid+1,r,dep+1);
	int i,d1=dep<<1,d2=d1-1,x,y;
	for(i=l; i<mid; ++i)
		AddEdge(Id[i]+n*d1,Id[i+1]+n*d1,T,a[Id[i+1]]-a[Id[i]]);
	for(i=l+1; i<=mid; ++i)
		AddEdge(Id[i]+n*d2,Id[i-1]+n*d2,T,a[Id[i]]-a[Id[i-1]]);
	for(x=l,y=mid+1; y<=r; ++y) {
		while(x<=mid&&a[Id[x]]<a[Id[y]])++x;
		if(x==mid+1)break;
		AddEdge(Id[y],Id[x]+n*d1,1,a[Id[x]]-a[Id[y]]);
	}
	for(x=mid,y=r; y>mid; --y) {
		while(x>=l&&a[Id[x]]>=a[Id[y]])--x;
		if(x==l-1)break;
		AddEdge(Id[y],Id[x]+n*d2,1,a[Id[y]]-a[Id[x]]);
	}
	merge(Id+l,Id+mid+1,Id+mid+1,Id+r+1,resb+l,Acmp);
	for(i=l; i<=r; ++i)Id[i]=resb[i];
	return;
}
int main() {
	n=read();
	MaxW=read();
	int i,j,nowdis;
	for(i=1; i<=n; ++i)a[Id[i]=i]=read();
	CDQ(1,n,1);
	t=n*(Maxd+2),s=t+1;
	for(i=1; i<=n; ++i) {
		AddEdge(s,i,1,0);
		AddEdge(i,t,1,MaxW);
		for(j=1; j<Maxd-1; ++j)
			AddEdge(i+n*j,i+n*Maxd,T,0);
		AddEdge(i+n*Maxd,t,1,0);
	}Sqt=sqrt(Sqt);
	while(Spfa())while(mcmf(s,T));
	printf("%d\n",Mincost);
	return 0;
}
```
以上代码跑之前生成的随机数据只要 $3.85s$，速度真快！

### Update on 2022-3-35:

本题数据经过了加强，所以以上第一份代码会超时，第二份代码因为没开`long long`会答案错误，下面提供一份正确的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=50005,M=4e6+6;
const ll T=0x1f1f1f1f1f1f1f1fll;
char buf[1<<23],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2))?EOF:*p1++
inline int read() {
	int an=0,f=1;
	while(!isdigit(c=gc))if(c=='-')f=-f;
	do an=an*10+c-'0';
	while(isdigit(c=gc));
	return an*f;
}
int Maxd,a[N],Head[N],ed[M],to[M],tot=1;
ll wt[M],ct[M],dis[N],Sqt,MaxW,Mincost;
int now[N],qr[N],hp,tp,n,s,t,Id[N],resb[N];
bool vis[N];
inline bool Acmp(const int &x,const int &y) {
	return a[x]<a[y];
}
inline void AddEdge(int u,int v,ll W,ll C) {
	ed[++tot]=v;
	to[tot]=Head[u];
	Head[u]=tot;
	wt[tot]=W;
	ct[tot]=C;
	ed[++tot]=u;
	to[tot]=Head[v];
	Head[v]=tot;
	ct[tot]=-C;
	if(C>0)Sqt+=C;
	return;
}
inline bool Spfa() {
	qr[hp=tp=1]=s;
	int i,x,y;
	for(i=1; i<=t; ++i)dis[i]=T,now[i]=Head[i];
	now[s]=Head[s];
	while(hp!=tp+1) {
		x=qr[hp++];
		if(hp==N)hp=1;
		vis[x]=false;
		for(i=Head[x]; i; i=to[i])
			if(wt[i]&&dis[y=ed[i]]>dis[x]+ct[i]) {
				dis[y]=dis[x]+ct[i];
				if(!vis[y]) {
					if(dis[y]-Sqt>dis[qr[hp]]) {
						if(--hp==0)hp=N-1;
						qr[hp]=y;
					} else {
						if(++tp==N)tp=1;
						qr[tp]=y;
					}
					if(dis[qr[hp]]>dis[qr[tp]])qr[hp]^=qr[tp]^=qr[hp]^=qr[tp];
					vis[y]=true;
				}
			}
	}
	return dis[t]!=T;
}
ll mcmf(int x,ll flow) {
	if(x==t) {
		Mincost+=flow*dis[x];
		return flow;
	}int y;
	ll k,rest=flow;
	vis[x]=true;
	for(int &i=now[x]; i; i=to[i])
		if(wt[i]&&!vis[y=ed[i]]&&dis[y]==dis[x]+ct[i]) {
			if(!(k=mcmf(y,min(wt[i],rest))))dis[y]=T;
			else {
				wt[i]-=k;
				wt[i^1]+=k;
				if(!(rest-=k))break;
			}
		}
	vis[x]=false;
	return flow-rest;
}
void CDQ(int l,int r,int dep) {
	if(l==r) {
		Maxd=max(Maxd,dep<<1);
		return;
	}
	int mid=l+((r-l)>>1);
	CDQ(l,mid,dep+1);
	CDQ(mid+1,r,dep+1);
	int i,d1=dep<<1,d2=d1-1,x,y;
	for(i=l; i<mid; ++i)
		AddEdge(Id[i]+n*d1,Id[i+1]+n*d1,T,a[Id[i+1]]-a[Id[i]]);
	for(i=l+1; i<=mid; ++i)
		AddEdge(Id[i]+n*d2,Id[i-1]+n*d2,T,a[Id[i]]-a[Id[i-1]]);
	for(x=l,y=mid+1; y<=r; ++y) {
		while(x<=mid&&a[Id[x]]<a[Id[y]])++x;
		if(x==mid+1)break;
		AddEdge(Id[y],Id[x]+n*d1,1,a[Id[x]]-a[Id[y]]);
	}
	for(x=mid,y=r; y>mid; --y) {
		while(x>=l&&a[Id[x]]>=a[Id[y]])--x;
		if(x==l-1)break;
		AddEdge(Id[y],Id[x]+n*d2,1,a[Id[y]]-a[Id[x]]);
	}
	merge(Id+l,Id+mid+1,Id+mid+1,Id+r+1,resb+l,Acmp);
	for(i=l; i<=r; ++i)Id[i]=resb[i];
	return;
}
int main() {
	n=read();MaxW=read();
	int i,j,nowdis;
	for(i=1; i<=n; ++i)a[Id[i]=i]=read();
	CDQ(1,n,1);
	t=n*(Maxd+2),s=t+1;
	for(i=1; i<=n; ++i) {
		AddEdge(s,i,1,0);
		AddEdge(i,t,1,MaxW);
		for(j=1; j<Maxd-1; ++j)
			AddEdge(i+n*j,i+n*Maxd,T,0);
		AddEdge(i+n*Maxd,t,1,0);
	}Sqt=sqrt(Sqt);
	while(Spfa())while(mcmf(s,T));
	printf("%lld\n",Mincost);
	return 0;
}
```

---

## 作者：CodingJellyfish (赞：4)

大佬们的做法我看不懂。

可以看出这道题是一道网络流题，直接建模：

将每个哨站拆成两个点，一个点表示连向控制中心（A 点），一个点表示连向前面的点（B 点）。

然后连边（直接用代码表示）：

```c
addEdge(S, A[i], 1, 0);
for (int j = 1; j < i; j++)
	if (abs(a[j] - a[i]) < W)
		addEdge(A[i], B[j], 1, abs(a[i] - a[j]));
addEdge(A[i], T, 1, W);
addEdge(B[i], T, 1, 0);
```

发现这种非常扁、非常稠密的图是网络单纯形法的专长，直接跑网络单纯形法即可。

**可以认为** 复杂度是跑不满的 $\Theta(n^3)$ 。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define RN 250000

typedef int I;
typedef char C;
typedef long long L;

#define SWAP(T, a, b) { T t = a; a = b; b = t; }

// Pools

typedef struct
{
    I nxt;
    I to;
    I cap;
    L cost;
}
Network;

Network net_pool[RN * 20];
I ncnt = 1;

#define nnode(x) net_pool[x]
#define nnxt(x)  nnode(x).nxt
#define nto(x)   nnode(x).to
#define ncap(x)  nnode(x).cap
#define ncost(x) nnode(x).cost

// Network Simplex

I head[RN], fa[RN], fe[RN], mark[RN], buf[RN];
L pi[RN];
I ti, nc;

static inline void addEdge(I u, I v, I f, L c)
{
    nnode(++ncnt) = (Network) { head[u], v, f, c };
    head[u] = ncnt;
    nnode(++ncnt) = (Network) { head[v], u, 0, -c };
    head[v] = ncnt;
}

void initTree(I x)
{
    nc++, mark[x] = 1;
    for (I i = head[x]; i; i = nnxt(i))
    {
        I v = nto(i);
        if (!mark[v])
        {
            pi[v] = pi[x] + ncost(i);
            fa[v] = x, fe[v] = i;
            initTree(v);
        }
    }
}

static inline L phi(I x)
{
    I top = 0;
    while (mark[x] != ti) mark[buf[top++] = x] = ti, x = fa[x];
    while (top--) x = buf[top], pi[x] = pi[fa[x]] + ncost(fe[x]);
    return pi[x];
}

void pushFlow(I e)
{
    I u = nto(e ^ 1), v = nto(e), l = nc, r = nc;
    ti++, buf[nc] = e;
    while (u)             buf[++r] = fe[u],     mark[u] = ti, u = fa[u];
    while (mark[v] != ti) buf[--l] = fe[v] ^ 1, mark[v] = ti, v = fa[v];

    I e2 = l, f = ncap(buf[l]);
    for (I i = l; buf[i] != fe[v]; i++)
    {
        if (ncap(buf[i]) < f) e2 = i, f = ncap(buf[i]);
    }
    for (I i = l; buf[i] != fe[v]; i++)
    {
        ncap(buf[i]) -= f, ncap(buf[i] ^ 1) += f;
    }
    if (e2 == nc) return;

    I x = e ^ (e2 < nc), y = nto(x), z = nto(x ^ 1);
    while (x != (buf[e2] ^ (e2 < nc)))
    {
        x ^= 1;
        pi[z] = pi[y] + ncost(x);
        SWAP(I, x, fe[z]);
        SWAP(I, y, fa[z]);
        SWAP(I, y, z);
    }
}

void simplex(I root)
{
    nc = fa[root] = 0, ti = 1;
    initTree(root);
    for (I i = 2, pre = ncnt; i != pre; i = i == ncnt ? 2 : i + 1)
    {
        if (ncap(i) && ncost(i) < phi(nto(i)) - phi(nto(i ^ 1)))
            pushFlow(pre = i);
    }
}

// Main

I ai[RN];

int main(void)
{
    I n, w;
    scanf("%d%d", &n, &w);
    for (I i = 1; i <= n; i++)
        scanf("%d", &ai[i]);
    
    for (I i = 1; i <= n; i++)
    {
        addEdge(2 * n + 1, i, 1, 0);
        addEdge(i, 2 * n + 2, 1, w);
        addEdge(n + i, 2 * n + 2, 1, 0);
        for (I j = 1; j < i; j++)
        {
            if (abs(ai[j] - ai[i]) < w)
                addEdge(i, n + j, 1, abs(ai[j] - ai[i]));
        }
    }
    addEdge(2 * n + 2, 2 * n + 1, n, -0x3f3f3f3fll);
    simplex(2 * n + 2);
    L ans = 0;
    for (I i = 3; i <= ncnt - 2; i += 2)
    {
        ans -= ncost(i) * ncap(i);
    }
    printf("%lld\n", ans);
    return 0;
}
```


---

## 作者：disangan233 (赞：3)

## 瞎扯

我们网络流模拟赛（其实是数据结构模拟赛）的 T2。

考场上写主席树写自闭了，直接交了 $80pts$ 的暴力，考完出来突然发现：

* woc 这个题一个 cdq 几行就搞定了！

## 题意简述

有 $n$ 个哨站，第 $i$ 个哨站的频段为 $a_i$ 。每个哨站可以花费 $W$ 连接中心，也可以花费 $|a_j-a_i|$ 连接到第 $j$ 个哨站（$j<i$）。

每个哨站最多只能被连接一次，求所有哨站连接的最小花费。

## 做法

### Luogu能过的暴力

由最多只能被连接一次想到流量限制（显然），发现题目要求最小花费，所以建图跑最小费用最大流。

考虑暴力建边，将每个点拆成 $2$ 个点，一个表示直接连接中心，另一个限制流量。

* 所以有$S \xrightarrow{1/0} i \xrightarrow{1/W} T$，$i \xrightarrow{\infty/|a_i-a_j|} j'$，$i' \xrightarrow{1/0} T$。

考场上我写完建图和 zkw 费用流就跑了，然后突然发现边是 $n^2$ 的，跑极限数据要跑 $100s+$，但是我后面交 luogu 竟然过了？？？

### 暴力代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
    char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0;
    in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
    in ll read()
    {
        ll x=0,y=1;while(nc=gc(),(nc<48||nc>57)&&nc!=-1)if(nc==45)y=-1;Bi=1;
        x=nc-48;while(nc=gc(),47<nc&&nc<58)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*y;
    }
    in db gf() {re a=read(),b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi):a);}
    in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
    in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
    in void flush() {if(C>1<<22) ot();}
    template <typename T>
    in void write(T x,char t)
    {
        re y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
        if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
    }
    in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
const int N=2e5+5;
#define ls(x) ch[x][0]
#define rs(x) ch[x][1]
int n,m,ch[N][2];
char s[]
int main()
{
	n=read(),m=read();
}
const int N=2e3+5;
const ll inf=1e18;
int cnt=1,sum,tot,n,s,t,m,k;
int h[N],l,r,q[N],vis[N],a[N];
ll ans,maxflow,dis[N];
struct did{int u,next,to,f,w;}e[N*N];
in void add(re a,re b,re c,re d)
{
	e[++cnt]=(did){a,h[a],b,c,d},h[a]=cnt;
	e[++cnt]=(did){b,h[b],a,0,-d},h[b]=cnt;
}
int spfa()
{
	memset(vis,0,sizeof(vis));
	for(re i=s;i<=t;i++) dis[i]=i==s?0:inf;
	queue<int>q;q.push(s);vis[s]=1;
	while(!q.empty())
	{
		re i=q.front();vis[i]=0;q.pop();
		for(re j=h[i],k;k=e[j].to,j;j=e[j].next)
		if(e[j].f&&dis[k]>dis[i]+e[j].w)
		{
			dis[k]=dis[i]+e[j].w;
			if(!vis[k]) q.push(k),vis[k]=1;
		}
	}	
	return dis[t]<inf;
}
in int dfs(re u,re f)
{
	if(u==t) return f; vis[u]=1;
	re res=0;
	for(re i=h[u],v;v=e[i].to,i&&res<f;i=e[i].next)
	if(e[i].f&&!vis[v]&&dis[v]==dis[u]+e[i].w)
	{
		re t=dfs(v,min(f-res,e[i].f));
		res+=t;ans+=(ll)e[i].w*t;
		e[i].f-=t;e[i^1].f+=t;
	}
	if(!res) dis[u]=inf;
	return vis[u]=0,res;
}
in void zkw() {while(spfa()) memset(vis,0,sizeof(vis)),maxflow+=dfs(s,1e9);}
int main()
{
	n=read();m=read();s=0,t=n*2+1;
	for(re i=1;i<=n;i++) a[i]=read(),add(s,i,1,0),add(i,t,1,m),add(n+i,t,1,0);
	for(re i=1;i<n;i++) for(re j=i+1;j<=n;j++) 
	if(abs(a[i]-a[j])<m) add(j,n+i,1,abs(a[i]-a[j]));
	zkw();write(ans,'\n');
	return ot(),0;
}
```

### 正解（暴力优化）

发现本题瓶颈在于一个点向一个区间连边，而且**有费用**。

考场上没想到可以转化负数，一直不知道如何解决绝对值。这里采用常数和花费更为优秀的 cdq 分治，分治后将区间内所有的虚点间连接费用为 $\Delta a$ 的边，二分保证连边的 $a_j$ 都大于 $a_i$ 即可。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
	char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23];int C=-1,Z=0;
	in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
	in ll read()
	{
		ll x=0,y=1;char c;while(c=gc(),(c<48||c>57)&&c!=-1) if(c==45) y=-1;
		x=c-48;while(c=gc(),47<c&&c<58) x=(x<<3)+(x<<1)+(c^48);return x*y;
	}
	in db gf() {int a=read(),b=read(),c=ceil(log10(b));return (b?a+(db)b/pow(10,c):a);}
	in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
	template <typename T>
	in void write(T x,char t)
	{
		re y=0;if(x<0) y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
		if(y) z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;
	}
	in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++,*s++)sr[++C]=*s;sr[++C]='\n';}
	in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
};
using namespace fast_io;
const int N=1e5+5;
const ll inf=1e18;
int cnt=1,sum,tot,n,s,t,m,k;
int h[N],l,r,q[N],vis[N],a[N];
ll ans,maxflow,dis[N];
struct did{int u,next,to,f,w;}e[N*21];
in void add(re a,re b,re c,re d)
{
	e[++cnt]=(did){a,h[a],b,c,d},h[a]=cnt;
	e[++cnt]=(did){b,h[b],a,0,-d},h[b]=cnt;
}
int spfa()
{
	memset(vis,0,sizeof(vis));fill(dis+1,dis+sum+1,inf); 
	dis[s]=0;queue<int>q;q.push(s);vis[s]=1;
	while(!q.empty())
	{
		re i=q.front();vis[i]=0;q.pop();
		for(re j=h[i],k;k=e[j].to,j;j=e[j].next)
		if(e[j].f&&dis[k]>dis[i]+e[j].w)
		{
			dis[k]=dis[i]+e[j].w;
			if(!vis[k]) q.push(k),vis[k]=1;
		}
	}	
	return dis[t]<inf;
}
in int dfs(re u,re f)
{
	if(u==t) return f; vis[u]=1;
	re res=0;
	for(re i=h[u],v;v=e[i].to,i&&res<f;i=e[i].next)
	if(e[i].f&&!vis[v]&&dis[v]==dis[u]+e[i].w)
	{
		re t=dfs(v,min(f-res,e[i].f));
		res+=t;ans+=(ll)e[i].w*t;
		e[i].f-=t;e[i^1].f+=t;
	}
	if(!res) dis[u]=inf;
	return vis[u]=0,res;
}
in void zkw() {while(spfa()) memset(vis,0,sizeof(vis)),maxflow+=dfs(s,1e9);}
void link(re l,re r)
{
	static int t[N];
	if(l==r) return; re mid=(l+r)>>1,tot=0;
	link(l,mid);link(mid+1,r); 
	for(re i=l;i<=r;i++) t[++tot]=a[i];
	sort(t+1,t+tot+1);tot=unique(t+1,t+tot+1)-t-1;
	for(re i=1;i<tot;i++) add(sum+i,sum+i+1,1e9,t[i+1]-t[i]),add(sum+i+1,sum+i,1e9,t[i+1]-t[i]);
	for(re i=l;i<=r;i++)
	{
		re j=lower_bound(t+1,t+tot+1,a[i])-t;
		(i<=mid)?add(sum+j,n+i,1,0):add(i,sum+j,1,0); 
	}
	sum+=tot;
}
int main()
{
	n=read();m=read();s=0,t=sum=n*2+1;
	for(re i=1;i<=n;i++) a[i]=read(),add(s,i,1,0),add(i,t,1,m),add(n+i,t,1,0);
	link(1,n);zkw();write(ans,'\n');
	return ot(),0;
}
```

---

## 作者：VenusM1nT (赞：3)

费用流。

首先这个题面以及数据范围已经可以看出一点网络流的影子了，配合费用进行考虑就是费用流，那么考虑每个点都可以 **向别人连**，或者 **被别人连**，考虑拆点，将 $i$ 拆出 $i'$，分别代表 **连向** 和 **被连向**。显然，这样会喜提 $\texttt{TLE}$，因为边数实在太多了，已经到达了 $n^2$，而网络流算法中往往是要乘上 $m$ 的。那么有什么方法可以减少边数呢？

写题解的此时此刻，我想到了神鱼枫姐姐曾经和我说过的话：

![](https://i.loli.net/2020/04/27/na6VOj8YmLoNdbx.png)

没错，数据结构优化建边。可以使用一个类似分治的算法很快地建出一个很简洁的图。别的 $\texttt{julao}$ 说是主席树，但窝看不大出来，觉得更像一个 $\texttt{cdq}$ 分治，因为我印象中的主席树都是：

![](https://i.loli.net/2019/05/12/5cd82c17cfc11.png)

（码风不忍直视）

不过这不是重点，重点是经过一个建虚点之后连点的过程后，我们就可以直接跑费用流而不 $\texttt{TLE}$ 了。

依然推荐使用 $\texttt{zkw}$ 费用流。

（写法略暴力，如 $\texttt{define int long long}$，见谅）

```cpp
#include<bits/stdc++.h>
#define MAXN 50005
#define MAXM 1000005
#define inf (long long)4340410370284600380
#define reg register
#define inl inline
#define int long long
using namespace std;
deque <int> q;
int cnt=1,fst[MAXN<<1],nxt[MAXM],to[MAXM],w[MAXM],cot[MAXM],cur[MAXN<<1];
int n,W,a[MAXN],t[MAXN],S,T,dis[MAXN<<1],mincost,tot,sum;
bool inq[MAXN<<1],vis[MAXN<<1];
void AddEdge(reg int u,reg int v,reg int c,reg int fl)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
	cot[cnt]=fl;
}
inl bool Spfa()
{
	memset(dis,60,sizeof(dis));
	memset(inq,0,sizeof(inq));
	q.push_front(T);
	dis[T]=0;
	inq[T]=1;
	while(!q.empty())
	{
		reg int u=q.front();
		q.pop_front();
		inq[u]=0;
		for(reg int i=fst[u];i;i=nxt[i])
		{
			reg int v=to[i];
			if(dis[v]>dis[u]-cot[i] && w[i^1])
			{
				dis[v]=dis[u]-cot[i];
				if(!inq[v])
				{
					if(!q.empty() && dis[v]<dis[q.front()]) q.push_front(v);
					else q.push_back(v);
					inq[v]=1;
				}
			}
		}
	}
	return dis[S]!=inf;
}
int Dfs(reg int u,reg int flow)
{
	vis[u]=1;
	if(u==T || !flow) return flow;
	reg int used=0;
	for(reg int i=cur[u];i;i=nxt[i])
	{
		cur[u]=i;
		reg int v=to[i];
		if(dis[v]==dis[u]-cot[i] && w[i] && !vis[v])
		{
			reg int fl=Dfs(v,min(flow,w[i]));
			if(fl)
			{
				used+=fl;
				flow-=fl;
				w[i]-=fl;
				w[i^1]+=fl;
				if(!flow) break;
			}
		}
	}
	return used;
}
inl void zkwMCMF()
{
	while(Spfa())
	{
		vis[T]=1;
		while(vis[T])
		{
			memcpy(cur,fst,sizeof(fst));
			memset(vis,0,sizeof(vis));
			reg int fl=Dfs(S,inf);
			mincost+=dis[S]*fl;
		}
	}
}
void Link(reg int l,reg int r)
{
	if(l==r) return;
	reg int mid=l+r>>1,tot=0;
	Link(l,mid);
	Link(mid+1,r);
	for(reg int i=l;i<=r;i++) t[++tot]=a[i];
	sort(t+1,t+tot+1);
	tot=unique(t+1,t+tot+1)-t-1;
	for(reg int i=1;i<tot;i++)
	{
		AddEdge(i+sum,i+sum+1,inf,t[i+1]-t[i]);
		AddEdge(i+sum+1,i+sum,0,t[i]-t[i+1]);
		AddEdge(i+sum+1,i+sum,inf,t[i+1]-t[i]);
		AddEdge(i+sum,i+sum+1,0,t[i]-t[i+1]);
	}
	for(reg int i=l;i<=r;i++)
	{
		reg int pos=lower_bound(t+1,t+tot+1,a[i])-t;
		if(i<=mid)
		{
			AddEdge(pos+sum,i+n,1,0);
			AddEdge(i+n,pos+sum,0,0);
		}
		else
		{
			AddEdge(i,pos+sum,1,0);
			AddEdge(pos+sum,i,0,0);
		}
	}
	sum+=tot;
}
signed main()
{
	scanf("%lld %lld",&n,&W);
	S=n*2+1;
	T=n*2+2;
	sum=n*2+2;
	for(reg int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(reg int i=1;i<=n;i++)
	{
		AddEdge(S,i,1,0);
		AddEdge(i,S,0,0);
		AddEdge(i,T,1,W);
		AddEdge(T,i,0,-W);
		AddEdge(i+n,T,1,0);
		AddEdge(T,i+n,0,0);
	}
	Link(1,n);
	zkwMCMF();
	printf("%lld\n",mincost);
	return 0;
}
```

---

## 作者：zifanwang (赞：2)

考虑使用费用流解决此题。

先设计一个简单的建图方案：

- 从源点向每个点 $i\ (1\le i\le n)$ 连一条边 $(1,0)$，向汇点连一条边 $(1,W)$。

- 从每个点 $i+n\ (1\le i\le n)$ 向汇点连一条边 $(1,0)$。

- 从点 $i\ (1\le i\le n)$ 向点 $j+n\ (1\le j\le n)$ 连一条边 $(1,|a_i-a_j|)$ 当且仅当 $j<i$。

直接在这个图上跑最小费用最大流可以得到 $80$ 分，因为边的个数是 $n^2$ 级别的。

考虑用分治优化建图。设当前分治的区间为 $[l,r]$，中点为 $\text{mid}$，正在处理 $[l,\text{mid}]$ 与 $[\text{mid}+1,r]$ 之间的连边。对 $[l,r]$ 中的每一种数新开一个点，向终点连一条边 $(\infty,0)$，相邻两数对应的点再连对应代价的双向边，最后再对 $[l,\text{mid}]$ 中的每个点向对应权值的点连边，对 $[\text{mid}+1,r]$ 中的每个点从对应权值的点向这些点连边即可。这样建图边的个数是 $O(n\log n)$ 级别的，可以通过此题。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 20005
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
using namespace std;
int n,w,s,t,t1,tot,cnt,a[mxn],b[mxn],p[mxn],ps[mxn],vr[5000003],ed[5000003],c[5000003],nx[5000003],hd[mxn];
ll ans,d[mxn],flow[mxn];
queue<int>q;
bool v[mxn];
inline void add(int x,int y,int z,int cs){
	vr[++tot]=y,ed[tot]=z,c[tot]=cs,nx[tot]=hd[x],hd[x]=tot;
	vr[++tot]=x,ed[tot]=0,c[tot]=-cs,nx[tot]=hd[y],hd[y]=tot;
}
bool spfa(){
	memset(d,0x3f,sizeof(d));
	memset(b,0,sizeof(b));
	flow[s]=1e16,d[s]=0,v[s]=1,q.push(s);
	p[t]=-1;
	while(q.size()){
		int x=q.front();q.pop();v[x]=0;
		for(int i=hd[x],y;i;i=nx[i])if(ed[i]&&d[y=vr[i]]>d[x]+c[i]){
			d[y]=d[x]+c[i];
			flow[y]=min(flow[x],(ll)ed[i]);
			p[y]=i;
			if(!v[y])v[y]=1,q.push(y);
		}
	}
	return p[t]!=-1;
}
void update(){
	int x=t,i;
	while(x!=s){
		i=p[x];
		ed[i]-=flow[t];
		ed[i^1]+=flow[t];
		x=vr[i^1];
	}
	ans+=flow[t]*d[t];
}
void solve(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1;
	solve(l,mid);solve(mid+1,r);
	t1=0;
	rep(i,l,r)b[++t1]=a[i];
	sort(b+1,b+t1+1);
	t1=unique(b+1,b+t1+1)-b-1;
	ps[1]=++cnt;
	rep(i,2,t1){
		ps[i]=++cnt;
		add(cnt,cnt-1,1e9,b[i]-b[i-1]);
		add(cnt-1,cnt,1e9,b[i]-b[i-1]);
	}
	rep(i,l,mid){
		int p=lower_bound(b+1,b+t1+1,a[i])-b;
		add(i,ps[p],1,0);
	}
	rep(i,mid+1,r){
		int p=lower_bound(b+1,b+t1+1,a[i])-b;
		add(ps[p],i+n,1,0);
	}
}
signed main(){
	scanf("%d%d",&n,&w);
	tot=1;
	t=n+n+1;
	rep(i,1,n){
		scanf("%d",&a[i]);
		add(0,i,1,0);
		add(i,t,1,w);
		add(i+n,t,1,0);
	}
	cnt=t;
	solve(1,n);
	while(spfa())update();
	cout<<ans;
    return 0;
}
```

---

## 作者：cunzai_zsy0531 (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P5331)

cdq分治优化建图+最小费用最大流。

首先考虑暴力怎么做。~~暴力是不是，加边加边加鞭~~

看到题面中“每个哨站只能被后面的至多一个哨站连接。”想到使用流量来限制，那么本题中的最小代价就可以用最小费用来求。显然是一个最小费用最大流的模型。

考虑建图。把每个点拆成两个点 $i$ 和 $i+n$。

1. $S-i$，流量为 $1$，费用为 $0$。
2. $i-T$，流量为 $1$，费用为 $W$。表示这个点直接连向基站的费用。
3. $i+n-T$，流量为 $1$，费用为 $0$。
4. $i-j(j<i)$，流量为 $1$，费用为 $|a_i-a_j|$。表示这个点连向前面的其他点。

这样可以直接跑了，但是过不去，因为第4条加边的边数是 $O(n^2)$ 级别的。考虑如何优化这个东西。

这里用到一个很神奇的cdq分治优化建图。考虑目前的区间 $[l,r]$，现在要把这个区间的右半边向左半边连边。先把所有点拿出来去重之后从小到大建成一条双向虚链，两个点之间的花费就是两个点权值之差。

可以发现，这样做之后，任意两个点之间的这条边都可以在这条虚链上表示。对于左半边每一个点，找到这个点在虚链上对应的点，从这个虚点向左半边的点连边；对于右半边，则相反，从右半边上的点向虚点连边。这样就通过对重复边的利用，把边数降到了 $O(n\log n)$ 级别，可以直接跑费用流通过此题。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int N=1e5+13,INF=0x3f3f3f3f;//数组别开小！ 
struct Edge{int u,v,f,w,nxt;}e[N<<4];
int n,W,h[N],a[N],tot=1,num,b[N],dist[N],s,t;
bool vis[N];
long long ans;//注意答案需要开long long 
inline void add(int u,int v,int f,int w){
	e[++tot]=(Edge){u,v,f,w,h[u]};h[u]=tot;
	e[++tot]=(Edge){v,u,0,-w,h[v]};h[v]=tot;
}
void link(int l,int r){//cdq分治优化建图 
	if(l==r) return;
	int mid=(l+r)>>1,cnt=0;
	link(l,mid),link(mid+1,r);
	for(int i=l;i<=r;++i) b[++cnt]=a[i];
	sort(b+1,b+cnt+1);cnt=unique(b+1,b+cnt+1)-b-1;
	for(int i=1;i<cnt;++i) add(num+i,num+i+1,INF,b[i+1]-b[i]),add(num+i+1,num+i,INF,b[i+1]-b[i]);
	for(int i=l;i<=mid;++i){
		int j=lower_bound(b+1,b+cnt+1,a[i])-b;
		add(num+j,i+n,1,0);
	}
	for(int i=mid+1;i<=r;++i){
		int j=lower_bound(b+1,b+cnt+1,a[i])-b;
		add(i,num+j,1,0);
	}
	num+=cnt;//这个地方不要忘记，图中的点都只能用一次 
}
queue<int> q;
inline bool spfa(){
	memset(dist,0x3f,sizeof dist);
	memset(vis,0,sizeof vis);
	while(!q.empty()) q.pop();
	q.push(s);dist[s]=0,vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=h[u];i;i=e[i].nxt){
			int v=e[i].v,w=e[i].w,f=e[i].f;
			if(f&&dist[v]>dist[u]+w){
				dist[v]=dist[u]+w;
				if(!vis[v]) vis[v]=1,q.push(v);
			}
		}
	}
	return dist[t]!=INF;
}
int dfs(int u,int rest){
	if(u==t) return rest;
	vis[u]=1;
	int tmp=rest;
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w,f=e[i].f,ttmp;
		if(f&&!vis[v]&&(dist[v]==dist[u]+w)&&(ttmp=dfs(v,min(rest,f)))){
			rest-=ttmp;ans+=1ll*w*ttmp;
			e[i].f-=ttmp,e[i^1].f+=ttmp;
			if(!rest) break; 
		}
	}
	if(tmp==rest) dist[u]=INF;
	vis[u]=0;
	return tmp-rest;
}
inline void zkw(){//zkw费用流 
	int maxflow=0;
	while(spfa()){
		memset(vis,0,sizeof vis);
		maxflow+=dfs(s,INF);
	}
	printf("%lld\n",ans);
}
int main(){
	scanf("%d%d",&n,&W);s=n*2+1,t=s+1,num=t;
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=1;i<=n;++i) add(s,i,1,0),add(i,t,1,W),add(i+n,t,1,0);
	link(1,n);
	zkw();
	return 0;
}
```


---

## 作者：DaiRuiChen007 (赞：2)

# P5331 题解

**题目大意**

> $n$ 个排成一列的哨站要进行通信。第 $i$ 个哨站的频段为 $a_i$。
>
> 每个哨站 $i$ 需要选择以下二者之一：
>
> 1. 直接连接到控制中心，代价为 $W$；
> 2. 连接到前面的某个哨站 $j$ ($j<i$)，代价为 $|a_i-a_j|$。
>    每个哨站只能被后面的至多一个哨站连接。
>
> 请你求出最小可能的代价和。
>
> 数据范围：$n\le 1000$。

**思路分析**

考虑二分图匹配解决此问题，左部 $i$ 连向右部 $1\sim i-1$ 中的 $j$，权值为 $|a_i-a_j|$，表示这个哨站往前面的哨站连，左部 $i$ 连向右部 $i+n$，权值为 $W$，表示直接连到控制中心。

这张图的最小权完美匹配即为答案，KM 算法求解即可。

时间复杂度 $\mathcal O(n^3)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace B {
const int MAXN=2005;
const ll inf=1e18;
ll w[MAXN][MAXN],sk[MAXN],lx[MAXN],ly[MAXN];
int n,tar[MAXN];
bool sx[MAXN],sy[MAXN];
inline bool dfs(int x) {
	if(sx[x]) return false;
	sx[x]=true;
	for(int y=1;y<=n;++y) if(!sy[y]) {
		ll k=lx[x]+ly[y]-w[x][y];
		if(!k) {
			sy[y]=true;
			if(!tar[y]||dfs(tar[y])) return tar[y]=x,true;
		} else sk[y]=min(sk[y],k);
	}
	return false;
}
inline ll KM() {
	for(int x=1;x<=n;++x) lx[x]=*max_element(w[x]+1,w[x]+n+1);
	for(int t=1;t<=n;++t) {
		fill(sx+1,sx+n+1,0),fill(sy+1,sy+n+1,0),fill(sk+1,sk+n+1,inf);
		if(dfs(t)) continue;
		while(true) {
			ll d=inf;
			int x=0,y=0;
			for(int i=1;i<=n;++i) if(!sy[i]) d=min(d,sk[i]);
			for(int i=1;i<=n;++i) {
				if(sx[i]) lx[i]-=d;
				if(sy[i]) ly[i]+=d;
				else if(!(sk[i]-=d)) y=i;
			}
			if(!(x=tar[y])) break;
			sx[x]=sy[y]=true;
			for(int i=1;i<=n;++i) if(!sy[i]) sk[i]=min(sk[i],lx[x]+ly[i]-w[x][i]);
		}
		fill(sx+1,sx+n+1,0),fill(sy+1,sy+n+1,0);
		dfs(t);
	}
	ll ans=0;
	for(int i=1;i<=n;++i) ans+=w[tar[i]][i];
	return ans;
}
}
const int MAXN=1005,A=1e9;
int n,p,a[MAXN];
signed main() {
	scanf("%d%d",&n,&p);
	B::n=2*n;
	for(int i=1;i<=n;++i) {
		scanf("%d",&a[i]);
		B::w[i][i+n]=A-p;
		for(int j=1;j<i;++j) B::w[i][j]=A-abs(a[i]-a[j]);
	}
	printf("%lld\n",1ll*n*A-B::KM());
	return 0;
}
```







---

## 作者：Fading (赞：2)

这算第一次自己想出网络流？？？

自己想出来黑题就是爽！~~虽然调试了2个小时~~

是时候去学学新姿势了。。。

好像我最慢跑了$4985ms...$还加了 luogu O2,$一大堆头文件

不管了我们开始思考！（以下是我的所有心路历程）

### 算法1

我会 dp!

期望得分$:0$

### 算法2

我会搜索!

期望得分$:10$

### 算法3

这个题为什么不可以 dp 呢？？？

因为我们没有办法记录一个点是否已经被连接的状态。

所以...

我会状压 dp!

期望得分$:20$

### 算法4

一个点只能连接$1$个子节点，这个限制有点像流量。。。

数据范围：woc怎么这么小呢?那我跑网络流好不好啊？

不过好像求的是最小花费，那我跑费用流好不好啊？

一个点只能连接$1$个子节点，我们就拆点，流量设为$1$就好了。

设原点为$s$，汇点为$t$,一个点$i$拆成$i,i+n$

考虑一种连边方式：

$s\ ->\ 1..n$，流量为$1$，费用为$0$。

$1..n\ ->\ t$，流量为$1$，费用为$W$。

$i\ ->\ j+n\ \ (i>j)$ 流量为$1$，费用为$|a_i-a_j|$。

$n+1..2n\ ->\ t$，流量为$1$，费用为$0$。

跑最小费用最大流...

期望得分$:60$

实际得分$:80$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int tot,pre[100001],maxflow,vis[100001],last[100001],flow[100001],head[100001];
int n,m,W,s,t;
ll dep[100001],a[100001],mincost;
struct node{
    int to,next,dis;
    ll cot;
}g[100005];
inline void bud(int from,int to,int dis,ll cot){
    g[++tot].to=to;g[tot].dis=dis;g[tot].cot=cot;
    g[tot].next=head[from];head[from]=tot;
}
inline void made(int from,int to,int dis,ll cot){
    bud(from,to,dis,cot);bud(to,from,0,-cot);
}
#define gc getchar
inline ll read(){
    ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();}
    while (isdigit(ch)) x=x*10+ch-'0',ch=gc();
    return x*f;
}
inline bool spfa(int s,int t){
    for (register int i=s;i<=t;i++){
        flow[i]=dep[i]=999999999;vis[i]=0;
    }
    queue<int> dl;
    while (!dl.empty()) dl.pop();
    dl.push(s);vis[s]=1;pre[t]=-1;dep[s]=0;
    while (!dl.empty()){
        register int u=dl.front();dl.pop();vis[u]=0;
        for (register int i=head[u];i!=-1;i=g[i].next){
            register int v=g[i].to;
            if (g[i].dis>0&&dep[v]>dep[u]+g[i].cot){
                dep[v]=dep[u]+g[i].cot;
                pre[v]=u;last[v]=i;
                flow[v]=min(flow[u],g[i].dis);
                if (!vis[v]){
                	dl.push(v);
                	vis[v]=1;
                }
            }
        }
    }
    return pre[t]!=-1;
}
inline void MCMF(){
    while (spfa(s,t)){
        maxflow+=flow[t];
        mincost+=1LL*flow[t]*dep[t];
        register int x=t;
        while (x!=s){
            g[last[x]].dis-=flow[t];
            g[last[x]^1].dis+=flow[t];
            x=pre[x];
        }
    }
}
int main(){
    n=read();W=read();tot=-1;memset(head,-1,sizeof(head));
    s=0,t=2*n+1;
    for (int i=1;i<=n;i++) made(s,i,1,0);
    for (int i=1;i<=n;i++) made(i,t,1,W);
    for (int i=n+1;i<=2*n;i++) made(i,t,1,0);
    for (int i=1;i<=n;i++){
        a[i]=read();
        for (int j=1;j<i;j++){
            made(i,j+n,1,abs(a[i]-a[j]));
        }
    }
    MCMF();
    printf("%lld",mincost);
}
```

### 算法5

如果我在考场的话我就不会去想了，因为想到了正解也毫无意义（就多二三十分）

然后我就考虑为什么只有一点点分：

最坏时间复杂度是$O(nmf)$，其中$f$是最大流，可以当作$n$算。

但是我们要暴力枚举两个点连边，$m$达到了惊人的$n^2$!

然后怎么办呢？

考虑优化建图。线段树？倍增？

我先往区间线段树上思考。可以给每一个线段树的叶子节点向出点连边，流量为$\infty,$花费为$a_{\text{LeftBound}}$（就是这个叶子节点的编号）。第$i$个点暴力向$1..i-1$连边的话就从入点向线段树节点连流量为$\infty,$花费为$-a_i$的边，不就抵消了吗？

但是恶心的来了：有绝对值。

那么区间线段树直接去世了。然后就去想权值线段树。

我们可以维护一棵权值线段树，叶子节点也一样，向出点权值为叶子节点下标的所有出点连流量为$\infty,$花费为叶子节点下标的边（离散化）。

第$i$个点暴力向$1..i-1$连边的话$,$可以和区间线段树一样，直接向所有的点连接流量为$\infty,$花费为$-a_i$的边？？？

还是不对啊，如果这么操作的话只有权值为$a_i...\max$（最大值）的点才连到了正确的边！权值为$\min..a_i-1$的点全部成为了负边。

怎么办呢？我就想到可以开两棵线段树！一棵叶子节点连接花费为正的边，一棵连接负的就好了！

可以感性理解一下，那么这道题就做完了！！！

[代码](https://www.luogu.org/paste/p7kl9u6b)

## $\texttt{ALL LAST}$

具体实现我拆点的时候为了图方便把$1..n$设为出点，$n+1..2n$设为入点了。

这就是 SDOI2009 晨跑啊，我做的时候居然没有看出来。。。

---

## 作者：asuldb (赞：2)

还好我没生在陕西啊

首先发现这个题不能$dp$，数据范围不大，好像一种网络流的样子啊

哎等等，这样向后面连边不是一个$DAG$吗，这不是最小权路径覆盖的板子吗

于是我们套路的拆点，对于一个点$i$我们拆成$i$和$i'$，源点向点$i$连费用为$0$容量为$1$的边，$i'$向汇点连费用为$0$容量为$1$的边

之后我们把让$S$向$i'$直接连费用为$W$容量为$1$的边，表示直接连到控制中心

对于点$i$，我们向$j'(j>i)$连容量为$1$费用为$|a_i-a_j|$的边，表示点$j$接到了点$i$后面

于是现在我们一个最小费用最大流就好了

之后喜提$TLE$

我们发现我们好像建出了$n^2$级别的边

我们考虑我们连边的方式，这样向后面一个区间连边的方式让人好熟悉啊，这不是线段树优化建图吗

但是我们注意到这里的边的费用好像不是一样的，但是这个绝对值给了我们分类讨论的可能

对于一个点$i$，我们建出一个虚点$x'$，$i$向$x'$连费用为$a_i$的边，让这个虚点$x'$向$j(j>i,a_j<a_i)$连费用为$-a_j$的边，$a_j>a_i$同理，这样我们就能实现绝对值这个问题了

那么我们如何快速向一个点之后的所有大于它或小于它的点连边呢

直接主席树优化建图就好了，这样我们的点数和边数都是$nlogn$级别的了

但是还是$T$，发现我们建了两万多个点和十万多条边

写一个快一点的费用流就好了，用zkw费用流和$slf$优化的spfa勉勉强强能跑过的样子

另外$loj$上的大爷们写的看起来好像$cdq$分治优化建图的洞西看起来好神仙啊

代码

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define re register
#define LL long long
#pragma GCC optimize(3)
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
inline int read() {
	char c=getchar();int x=0;while(c<'0'||x>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
const LL inf=999999999999;
const int fnf=999999999;
const int maxn=2e3+5;
const int M=4e5+6;
int head[M],vis[M],a[maxn],c[maxn],b[maxn];LL d[M];
int rt[maxn][2],l[M],r[M];
struct E{int v,nxt,w,f;}e[200005];
int n,num=1,S,T,W,sz,cnt;
inline void C(int x,int y,int w,int f) {
	e[++num].v=y;e[num].nxt=head[x];
	e[num].w=w;e[num].f=f;head[x]=num;
}
std::deque<int> q;
inline void add(int x,int y,int w,int f) {C(x,y,w,f),C(y,x,-1*w,0);}
inline int SPFA() {
	for(re int i=S;i<=cnt;i++) d[i]=inf,vis[i]=0;
	d[T]=0,q.push_back(T);
	while(!q.empty()) {
		int k=q.front();q.pop_front();vis[k]=0;
		for(re int i=head[k];i;i=e[i].nxt)
		if(e[i^1].f&&d[e[i].v]>d[k]+e[i^1].w) {
			d[e[i].v]=d[k]+e[i^1].w;
			if(!vis[e[i].v]) {
				vis[e[i].v]=1;
				if(q.empty()) {q.push_back(e[i].v);continue;}
				if(d[e[i].v]<d[q.front()]) q.push_front(e[i].v);
					else q.push_back(e[i].v);
			}
		}
	}
	return d[S]<inf;
}
int dfs(int x,int now) {
	if(x==T||!now) return now;
	int flow=0,ff;vis[x]=1;
	for(re int i=head[x];i;i=e[i].nxt)
	if(e[i].f&&!vis[e[i].v]&&d[e[i].v]==d[x]+e[i^1].w) {
		ff=dfs(e[i].v,min(e[i].f,now));
		if(ff<=0) continue;
		flow+=ff,now-=ff,e[i].f-=ff,e[i^1].f+=ff;
		if(!now) break;
	}
	return flow;
}
inline int find(int x) {
	int lx=1,ry=sz;
	while(lx<=ry) {
		int mid=lx+ry>>1;
		if(c[mid]==x) return mid;
		if(c[mid]<x) lx=mid+1;
			else ry=mid-1;
	}
	return 0;
}
int ins(int pre,int x,int y,int pos,int a,int b) {
	int root=++cnt;
	if(x==y) {
		add(root,a,b*c[x],1);
		return root;
	}
	int mid=x+y>>1;
	l[root]=l[pre],r[root]=r[pre];
	if(pos<=mid) l[root]=ins(l[pre],x,mid,pos,a,b);
		else r[root]=ins(r[pre],mid+1,y,pos,a,b);
	if(l[root]) add(root,l[root],0,fnf);
	if(r[root]) add(root,r[root],0,fnf);
	return root;
}
void Con(int g,int now,int x,int y,int lx,int ry) {
	if(!now) return;
	if(lx<=x&&ry>=y) {add(g,now,0,fnf);return;} 
	int mid=x+y>>1;
	if(lx<=mid) Con(g,l[now],x,mid,lx,ry);
	if(ry>mid) Con(g,r[now],mid+1,y,lx,ry);
}
int main() {
	n=read(),W=read();S=0,T=n+n+1;cnt=T;
	for(re int i=1;i<=n;i++) a[i]=read();
	for(re int i=1;i<=n;i++) add(S,i+n,W,1);
	for(re int i=1;i<=n;i++) add(S,i,0,1);
	for(re int i=1;i<=n;i++) add(i+n,T,0,1);
	for(re int i=1;i<=n;i++) c[i]=a[i];
	std::sort(c+1,c+n+1);sz=std::unique(c+1,c+n+1)-c-1;
	for(re int i=1;i<=n;i++) b[i]=a[i],a[i]=find(a[i]);
	for(re int i=n;i>1;--i) 
		rt[i][0]=ins(rt[i+1][0],1,sz,a[i],i+n,-1),
		rt[i][1]=ins(rt[i+1][1],1,sz,a[i],i+n,1);
	for(re int i=1;i<n;i++) {
		++cnt;
		add(i,cnt,b[i],1);
		Con(cnt,rt[i+1][0],1,sz,1,a[i]);
		++cnt;
		add(i,cnt,-1*b[i],1);
		Con(cnt,rt[i+1][1],1,sz,a[i],sz);
	} 
	LL ans=0;
	while(SPFA()) {
		vis[T]=1;
		while(vis[T]) {
			for(re int i=S;i<=cnt;i++) vis[i]=0;
			ans+=1ll*dfs(S,fnf)*d[S];
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：spdarkle (赞：0)

前言：蒟蒻的我居然独立乱搞过黑题，由此做一个纪念。

正解可以看[这里](https://www.luogu.com.cn/problem/solution/P5331)，这里提供一个乱整做法。

首先最小费用流不必多说，我们来考虑使用朴素的费用流算法进行求解。

对于题目的两个选择：

第一个显然是点 $i$ 直接向汇点连边，费用为 $W$，容量为 $1$。

第二个显然是点 $i$ 连向点 $j$，费用为 $|a_i-a_j|$，容量为 $1$。

对于限制条件，每个点只能被后面一个点所连接，根据费用流套路，明显是拆点操作。

详细地说，我们将点 $i$ 拆为入点 $i$，出点 $i+n$，由入点向出点连一条费用为零，容量为 $1$ 的边，由源点向**出点**连一条费用为零，容量为 $1$ 的边，这表示每个点都需要流向汇点，但不能占用入点到出点的流量，这份流量留给后面的点。

而对于选择一，更改为其**出点**向汇点连边，因为要配合上源点流到出点的流量。

对于选择二，更改为点 $i$ 的出点向 $j$ 的入点连边。

当然，由于限制条件，一个点连接了前面的某个哨站之后是可以直接流到汇点的，于是由每个点的**入点**向汇点连一条容量为 $1$，费用为 $0$ 的边。

不难写出以下代码：

```cpp
#define int long long
int head[N],a[N],n,m,ver[M],s,t,lst[N],nxt[M],pre[N],num,tot=1,cost[M],val[M],flow[N],dis[N],vis[N];
void ad(int u,int v,int w,int co){
	nxt[++tot]=head[u],ver[head[u]=tot]=v,cost[tot]=co,val[tot]=w;
}
void add(int u,int v,int w,int co){
	ad(u,v,w,co);ad(v,u,0,-co);
}
bool spfa(){
	for(int i=1;i<=num;i++)flow[i]=dis[i]=0x3f3f3f3f,vis[i]=0;
	queue<int>q;for(int i=1;i<=num;i++)pre[i]=-1;
	q.push(s);vis[s]=1,dis[s]=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();vis[u]=0;
		for(int i=head[u];i;i=nxt[i]){
			int v=ver[i];
			if(dis[v]>dis[u]+cost[i]&&val[i]>0){
				dis[v]=dis[u]+cost[i];
				pre[v]=u,lst[v]=i,flow[v]=min(flow[u],val[i]);
				if(!vis[v]){
					vis[v]=1;q.push(v); 
				}
			}
		}
	}
	return pre[t]!=-1;
} 
void MCMF(){
	int ans=0,mn=0;
	while(spfa()){
		int now=t;
		ans+=flow[t],mn+=flow[t]*dis[t];
		while(now!=s){
			val[lst[now]]-=flow[t];
			val[lst[now]^1]+=flow[t];
			now=pre[now]; 
		}
	}
	cout<<mn<<"\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;s=n+n+1,t=n+n+2;num=t; 
	for(int i=1;i<=n;i++){
		cin>>a[i];add(i,i+n,1,0);add(i+n,t,1,m);
		add(s,i+n,1,0);add(i,t,1,0);
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++){
			add(i+n,j,1,max(a[i]-a[j],a[j]-a[i]));
		}
	}
	MCMF();
}
```

考虑优化。

注意到点数 $O(n)$，边数 $O(n^2)$，那必定是要优化建图的。

看到绝对值就很烦，考虑将其拆开分类讨论。

先来处理 $a_i\ge a_j$ 的情况。

需要有两个限制条件：

1. $i>j$
2. $a_i\ge a_j$

那么对于 $i,i+1$ 而言，范围只扩大了 $1$，这就有了突破口。

试问如果我们可以快速处理出满足这两个条件的点的集合，也许就有了解决方案。

这是显然的二维偏序问题，考虑到树状数组只能求出集合大小，不能求出具体集合，我们采用归并排序的方法解决它，这一步是从小到大的归并。

在每一层的双指针扫描过程中，显然就可以处理出区间 $[l,mid]$ 中的点在 $[mid+1,r]$ 的所需集合的组成部分了。

设当前左区间已经扫到了 $x$，右区间扫到了 $y$，分类讨论当前需要更新的点。

1. $a_x\le a_y$ 这时候集合 $[l,x]$ 都是符合要求的。
2. $a_x>a_y$ 这时候说明 $y$ 所需集合没有 $x$ 及其以后的元素了。

我们注意到在当前状态下，$y$ 的所需集合显然是 $y+1$ 所需集合的**子集**，且 $r$ 的所需集合大小不超过 $mid-l+1$，这是一个很小的数字。

那么我们考虑维护 $r$ 的这个集合，使得 $\forall i\in[mid+1,r]$，它的所属集合可以在这个大集合里面找到。 

显然这个所属集合也是单调不减的。

它支持什么操作呢？

1. 插入点 $i\in[l,mid]$，并且与之前的点隔开（已经处理过的右半区间的数无法访问到这个点）。 
2. 从集合头到某个点可以标记其属于某个右半区间的数。

我们考虑引入**辅助链**，这条链长这样：（记 $X$ 类点为左半区间的点，$Y$ 类点为右半区间的点）

![捕获](https://cdn.luogu.com.cn/upload/image_hosting/5wz8t7wi.png)

按大小顺序扫描左右部点，建立虚链，虚链的方向指向上一个添加的虚点，其容量为 $inf$，费用为 $0$。目的是利用图的特殊性连通集合。

1. 对于新加入一个左半区间的点，说明以前加入的右半区间点都用不到这个点，则新开一个虚点，接上虚链，这个新虚点向这个左半区间的点 $j$ 连边，容量为 $1$，费用为 $-a_j$。

2. 对于新加入一个右半区间的点 $j$，可以直接继承当前虚链，即直接连接当前最后一个虚点，容量为 $1$，费用为 $a_j$。

这样我们就将这个区间里的点处理完毕，子区间交给递归。

代码如下：

```cpp
void solve1(int l,int r){
	if(l==r)return ;
	int x=++num;
	int mid=l+r>>1,num1=0,num2=0,tot=0;
	solve1(l,mid);solve1(mid+1,r);
	for(int i=l;i<=mid;i++)tmp_l[++num1]=a[i];
	for(int i=mid+1;i<=r;i++)tmp_r[++num2]=a[i];
	int c1=1,c2=1;
	while(c1<=num1&&c2<=num2){
		if(tmp_r[c2].x<tmp_l[c1].x){
			add(tmp_r[c2].id+n,x,1,tmp_r[c2].x);
			tmp[++tot]=tmp_r[c2];++c2;
		}
		else {
			int y=++num;add(y,x,0x3f3f3f3f3f3f,0);x=y;
			add(x,tmp_l[c1].id,1,-tmp_l[c1].x);
			tmp[++tot]=tmp_l[c1];++c1;
		}
	}
	while(c1<=num1){
		tmp[++tot]=tmp_l[c1];++c1;
	}
	while(c2<=num2){
		add(tmp_r[c2].id+n,x,1,tmp_r[c2].x);
		tmp[++tot]=tmp_r[c2];++c2;
	} 
	for(int i=l;i<=r;i++)a[i]=tmp[i-l+1];
}
```

那么另一个直接反过来自大到小排序就好。

不过这样代码写好了交上去只有 90pts，考虑优化常数：

1. 删掉 `#define int long long`。
2. 将 MCMF 更换为效率更高的 zkw 费用流
3. 换个快读（不用也行）

这样即可通过本题。

值得一提的是，在洛谷该题 HACK 数据的第三个测试点会 TLE，考虑更换快读再开个 O2，可以跑进 3s，通过本题。

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define M 2000500
#define N 2000500
struct node{
	int x,id;
}a[N],b[N]; 
int head[N],n,m,ver[M],s,t,dep[N],nxt[M],num,tot=1;ll cost[M],val[M],dis[N];int vis[N];
inline void ad(int u,int v,ll w,ll co){
	nxt[++tot]=head[u],ver[head[u]=tot]=v,cost[tot]=co,val[tot]=w;
}
inline void add(int u,int v,ll w,ll co){
	ad(u,v,w,co);ad(v,u,0,-co);
}
inline bool spfa(){
	for(int i=1;i<=num;i++)dis[i]=0x3f3f3f3f3f3fll,vis[i]=dep[i]=0;
	queue<int>q;
	q.push(s);vis[s]=1,dis[s]=0;dep[s]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();vis[u]=0;
		for(int i=head[u];i;i=nxt[i]){
			int v=ver[i];
			if(dis[v]>dis[u]+cost[i]&&val[i]>0){
				dis[v]=dis[u]+cost[i];dep[v]=dep[u]+1;
				if(!vis[v]){
					vis[v]=1;q.push(v); 
				}
			}
		}
	}
	return dep[t]!=0;
} 
int tag=0;
ll dfs(int u,ll now,ll &flow,ll &cos){
	if(u==t){
		flow+=now;tag=1;
		return now;
	}
	ll new_flow=0;
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];
		if(dep[v]==dep[u]+1&&dis[v]==dis[u]+cost[i]&&val[i]>0){
			ll tmp=dfs(v,min(now,val[i]),flow,cos);
			if(!tmp)continue;
			new_flow+=tmp,now-=tmp;cos+=tmp*cost[i];
			val[i]-=tmp;val[i^1]+=tmp;
			if(!now)return new_flow; 
		} 
	}
	return new_flow;
}
void zkw(){
	ll ans=0,mn=0;
	while(spfa()){
		tag=1;
		while(tag){
			tag=0;dfs(s,0x3f3f3f3f3f3fll,ans,mn);
		}
	}
	cout<<mn<<"\n";
}
node tmp_l[N],tmp_r[N],tmp[N]; 
void solve1(int l,int r){
	if(l==r)return ;
	int x=++num;
	int mid=l+r>>1,num1=0,num2=0,tot=0;
	solve1(l,mid);solve1(mid+1,r);
	for(int i=l;i<=mid;i++)tmp_l[++num1]=a[i];
	for(int i=mid+1;i<=r;i++)tmp_r[++num2]=a[i];
	int c1=1,c2=1;
	while(c1<=num1&&c2<=num2){
		if(tmp_r[c2].x<tmp_l[c1].x){
			add(tmp_r[c2].id+n,x,1,tmp_r[c2].x);
			tmp[++tot]=tmp_r[c2];++c2;
		}
		else {
			int y=++num;add(y,x,0x3f3f3f3f3f3f,0);x=y;
			add(x,tmp_l[c1].id,1,-tmp_l[c1].x);
			tmp[++tot]=tmp_l[c1];++c1;
		}
	}
	while(c1<=num1){
		tmp[++tot]=tmp_l[c1];++c1;
	}
	while(c2<=num2){
		add(tmp_r[c2].id+n,x,1,tmp_r[c2].x);
		tmp[++tot]=tmp_r[c2];++c2;
	} 
	for(int i=l;i<=r;i++)a[i]=tmp[i-l+1];
}
void solve2(int l,int r){
	if(l==r)return ;
	int x=++num;
	int mid=l+r>>1,num1=0,num2=0,tot=0;
	solve2(l,mid);solve2(mid+1,r);
	for(int i=l;i<=mid;i++)tmp_l[++num1]=a[i];
	for(int i=mid+1;i<=r;i++)tmp_r[++num2]=a[i];
	int c1=1,c2=1;
	while(c1<=num1&&c2<=num2){
		if(tmp_r[c2].x>tmp_l[c1].x){//右+n->虚->左边，右<左 
			add(tmp_r[c2].id+n,x,1,-tmp_r[c2].x);
			tmp[++tot]=tmp_r[c2];++c2;
		}
		else {
			int y=++num;
			add(y,x,0x3f3f3f3f3f3f,0);x=y;
			add(x,tmp_l[c1].id,1,tmp_l[c1].x);
			tmp[++tot]=tmp_l[c1];++c1;
		}
	}
	while(c1<=num1){
		tmp[++tot]=tmp_l[c1];++c1;
	}
	while(c2<=num2){
		add(tmp_r[c2].id+n,x,1,-tmp_r[c2].x);
		tmp[++tot]=tmp_r[c2];++c2;
	} 
	for(int i=l;i<=r;i++)a[i]=tmp[i-l+1];
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;num=n+n;
	for(int i=1;i<=n;i++)cin>>a[i].x;
	for(int i=1;i<=n;i++)a[i].id=i,b[i]=a[i];
	solve1(1,n);
	for(int i=1;i<=n;i++)a[i]=b[i];
	solve2(1,n);
	s=++num,t=++num;
	for(int i=1;i<=n;i++){
		add(i,i+n,1,0);add(i+n,t,1,m);
		add(s,i+n,1,0);add(i,t,1,0);
	}
	zkw();
}
```



---

## 作者：_lbw_ (赞：0)

又是一道自己 A 的黑题题解。

首先看数据范围不大，最优性问题。不能 dp，只能考虑流了。

$S\to x_i(1,0)$

$x_i\to T(1,W)$

$x_i\to x'_j(1,|a_i-a_j|),i>j$

$x'_j\to T(1,0)$

在这张图上跑最小费用最大流即为答案。但是这是一道黑题，不可能这么简单。

仔细思考后我们发现这张图的边数是 $\mathcal{O}(n^2)$  的，于是考虑 DS 优化建图。

此题限制即为 $i>j$ 有大小关系可以考虑用 cdq 分治去掉这一维。

于是在加一个 $\log$ 的情况下将问题转化为了一个区间向另一个区间连边。

因为边权为 $|a_i-a_j|$ 考虑将 $x'$ 串成一条链，然后让 $x$ 连上去。

复杂度最坏为 $\mathcal{O}(nmf)=\mathcal{O}(n^3\log n)$ 但是可以过。。。

code：

```cpp
const int maxn = 8e5+5;
const ll inf = 2000000000;bool vis[maxn];
ll n,w,tot,cnt,s,t,p1[maxn],p2[maxn],a[maxn],b[maxn],dis[maxn];
struct edge{ll to,nxt,v,c;}e[2*maxn];ll first[maxn],csp=1;
IV add(ll u,ll v,ll V,ll c){
	e[++csp]=edge{v,first[u],V,c};first[u]=csp;
	e[++csp]=edge{u,first[v],0,-c};first[v]=csp;
}
I cmin(ll&x,ll val){return x>val?x=val,1:0;}
I SPFA(){
	F(i,1,tot)vis[i]=0,dis[i]=inf;
	queue<ll>qwq;qwq.push(s);dis[s]=0;vis[s]=1;
	while(!qwq.empty()){
		ll u=qwq.front(),v;qwq.pop();vis[u]=0;
		E(i,u)if(e[i].v>0&&cmin(dis[v=e[i].to],dis[u]+e[i].c))
			if(!vis[v])qwq.push(v),vis[v]=1;
    }
    return dis[t]!=inf;
}
I dfs(ll u,ll flew){
	if(u==t)return flew;vis[u]=1;ll res=flew,flow,v;
	E(i,u)if(dis[u]+e[i].c==dis[v=e[i].to]&&e[i].v>0&&!vis[v])
		if(flow=dfs(v,min(res,e[i].v))){res-=flow,e[i].v-=flow,e[i^1].v+=flow;if(!res)break;}
	return flew-res;
}
I dinic(){
	ll flow=0,sum=0;
	while(SPFA())while(flow=dfs(s,inf))sum+=flow*dis[t];
    return sum;
}
IV cdq(ll l,ll r){
	if(l==r)return;ll mid=l+r>>1;cdq(l,mid);cdq(mid+1,r),cnt=0;
	F(i,l,r)b[++cnt]=a[i];sort(b+1,b+cnt+1),cnt=unique(b+1,b+cnt+1)-b-1;
    F(i,1,cnt-1)add(tot+i,tot+i+1,inf,b[i+1]-b[i]),add(tot+i+1,tot+i,inf,b[i+1]-b[i]);
    F(i,l,r){
		ll pos=lower_bound(b+1,b+1+cnt,a[i])-b;
		i>mid?add(p1[i],tot+pos,1,0):add(tot+pos,p2[i],1,0);
	}
	tot+=cnt;
}
int main(){
	n=read();w=read();s=++tot,t=++tot;
	F(i,1,n)a[i]=read();F(i,1,n)p1[i]=++tot,p2[i]=++tot,add(s,p1[i],1,0),add(p1[i],t,1,w),add(p2[i],t,1,0);
	return cdq(1,n),cout<<dinic(),0;
}
```


---

## 作者：KokiNiwa (赞：0)

# 题目叙述

[Link](https://www.luogu.com.cn/problem/P5331)

$n$个人，站成一排，每个人要连接到一个点，直接连接花费为$W$，或者与一个在这个点前面的人连接，花费为$|a_i-a_j|$。问最小花费。

# 题解

把一个点拆成一个用于向源点连接的点和一个用于别的点向这个点连接的点（以下称为入点和出点）。源点`s`向入点连边，流量为`1`，费用为`0`。对于`i<j`，`j`的入点向`i`的出点连边，流量为`1`，费用为`a[i]-a[j]`。每一个入点再向汇点`t`连边，连流量为`1`，费用为`w`。跑最小费用最大流。

然而这样并不能过`1000`的数据，考虑减少边的数量。考虑分治`f(l,r)`处理`[l,r]`，把`[m+1,r]`中的点向`[l,m]`中的点连边。考虑建立`r-l+1`个虚点，每个虚点的权值为`[l,r]`中的一个点的权值。把这`2n`个虚点连成一排（按照费用排序，双向边），相互之间的边费用为点权的差，流量为`INF`。现在把`[m+1,r]`中的点向`2n`个虚点中权值与这些点中权值与之相同的点相连，`2n`个点也向`[l,m]`中的点连边。这样连出的图必然正确，变数为$n\log_2 n$。

其实这道题可以这么想：

1. 想到二分图普遍连边技巧
2. 再想用线段树保证编号限制

# 评论

这大概是一道...比较套路的题目吧。

补充这道题的本质：

1. 这样的连边技巧可以运用到所有的、完全的二分图的最大匹配上
2. 把连边方法理解为差分

# 代码

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 1e3 + 5, INF = 0x3f3f3f3f;
typedef long long ll;
int n, w, tail = 1, pin[N], head[N * 32], ndTail;
struct EDGE {
	int to, next, flow, cost;
	EDGE(int _t, int _n, int _f, int _c) : to(_t), next(_n), flow(_f), cost(_c) {}
	EDGE() : to(0), next(0), flow(0), cost(0) {}
} edge[1000005];
inline void AddEdge(int u, int v, int fl, int ct) {
	edge[++tail] = EDGE(v, head[u], fl, ct);
	head[u] = tail;
}
inline void Add(int u, int v, int fl, int ct) {
	AddEdge(u, v, fl, ct);
	AddEdge(v, u, 0, -ct);
}
ll dis[N * 32];
int pre[N * 32];
bool inq[N * 32];
queue<int> Q;
bool SPFA(int s, int t) {
	while (Q.size()) Q.pop();
	memset(dis, 0x3f, sizeof(dis));
	memset(pre, 0, sizeof(pre));
	dis[s] = 0, Q.push(s), inq[s] = 1;
	while (Q.size()) {
		int now = Q.front();
		Q.pop();
		inq[now] = 0;
		for (int i = head[now]; i; i = edge[i].next) {
			if (!edge[i].flow) continue ;
			int to = edge[i].to, ct = edge[i].cost;
			if (dis[to] > dis[now] + ct) {
				pre[to] = i;
				dis[to] = dis[now] + ct;
				if (!inq[to]) {
					inq[to] = 1;
					Q.push(to);
				}
			}
		}
	}
	return dis[t] != 0x3f3f3f3f3f3f3f3fll; //由于 dis是 long long类型的，所以给 dis memset的值应该是 0x3f3f3f3f3f3f3f3f 
}
void MCMF(int s, int t) {
	ll ans = 0;
	while (SPFA(s, t)) {
		int go = 0x3f3f3f3f;
		for (int now = pre[t]; now; now = pre[edge[now ^ 1].to])
			go = min(edge[now].flow, go);
		for (int now = pre[t]; now; now = pre[edge[now ^ 1].to]) {
			edge[now].flow -= go, edge[now ^ 1].flow += go;
			ans += 1ll * edge[now].cost * go;
		}
	}
	printf("%lld\n", ans);
}
int Abs(int a) { return a > 0 ? a : -a; }
int pos[N];
pair<int, int> tmp[N], tt[N];
void Merge(int L, int R) {
	int mid = (L + R) >> 1;
	for (int i = L; i <= R; ++i)
		tt[i] = tmp[i];
	int lp = L, rp = mid + 1;
	for (int i = L; i <= R; ++i) {
		if (lp > mid || rp <= R && tt[lp] > tt[rp]) //如果不加 rp <= R，那么就会出错 
			tmp[i] = tt[rp], ++rp;
		else
			tmp[i] = tt[lp], ++lp;
	}
}
void CDQ(int L, int R) {
	if (L == R) return ;
	int mid = (L + R) >> 1;
	CDQ(L, mid), CDQ(mid + 1, R);
	inplace_merge(tmp + L, tmp + mid + 1, tmp + R + 1);
	for (int i = L; i <= R; ++i)
		pos[tmp[i].second] = i;
	for (int i = 2; i <= R - L + 1; ++i) {
		Add(ndTail + i , ndTail + i - 1, INF, tmp[L + i - 1].first - tmp[L + i - 2].first);
		Add(ndTail + i - 1, ndTail + i, INF, tmp[L + i - 1].first - tmp[L + i - 2].first);
	}
	for (int i = L; i <= R; ++i) {
		if (i <= mid)
			Add(ndTail + pos[i] - L + 1, i + n, 1, 0);
		else
			Add(i, ndTail + pos[i] - L + 1, 1, 0);
	}
	ndTail += R - L + 1;
}
int main() {
	scanf("%d%d", &n, &w);
	for (int i = 1; i <= n; ++i)
		scanf("%d", &pin[i]);
	int s = 2 * n + 1, t = 2 * n + 2;
	for (int i = 1; i <= n; ++i)
		Add(s, i, 1, 0), Add(i, t, 1, w);
	for (int i = n + 1; i <= 2 * n; ++i)
		Add(i, t, 1, 0);
	for (int i = 1; i <= n; ++i)
		tmp[i] = make_pair(pin[i], i);
	ndTail = 2 * n + 2;
	CDQ(1, n);
	MCMF(s, t);
	return 0;
}
```



---

## 作者：Le0Chan (赞：0)

看到题，最优化问题。贪不了，尝试 dp。发现做不了。满足不了每个哨站被后面的**最多**一个哨站连接。

考虑网络流。将序列竖向，复制一份，列成两部。源点向每个左部点连容量 $1$，费用 $0$ 的边。每个左部点向汇点连容量 $1$，费用 $W$ 的边。这是第一种选择。

对于每个左部点 $i$ 寻找满足 $j<i$ 的右部点。连容量 $1$，费用 $|a_i-a_j|$ 的边。每个右部点向汇点连容量 $1$，费用 $0$ 的边。这是第二种选择。

下面跑费用流应当是对的。容易发现上述建边满足了每个哨站被后面的**最多**一个哨站连接这一条件。因为每个右列点的出边容量为 $1$。

边数是 $n^2$ 级别的。难以通过。考虑优化。

对于第一种情况，边数不在瓶颈，不予理会。

对于第二种情况，对于绝对值，进行分类讨论。

- $a_j\le a_i$，该情况连边费用 $a_i-a_j$。

- $a_j>a_i$，该情况连边费用 $a_j-a_i$。

再加上 $j<i$，形成了一个二维偏序问题。考虑 k-d tree 优化建图。

首先将 kd-tree 写成 leafy 的。这样其结构类似与线段树。可以将一些线段树常见套路套上去。发现只有点向区间连边。所以 kdt 的边指向叶子。容量为 $\inf$，费用为 $0$。

发现两种情况的费用符号有差别。尝试写出两棵 kdt，一种只接受 $a_j\le a_i$ 的连边，一种接受 $a_j>a_i$ 的连边。这样对于左部点来说，第一种情况向树一连的 $\sqrt n$ 个区间的边，费用 $a_i$，容量 $1$。第二种情况向树二连的费用 $-a_i$，容量 $1$。

考虑两棵树的叶子节点，显然只能**总共**有 $1$ 的容量流出去。所以再建 $n$ 个虚点。树一的叶子向对应虚点连费用 $-a_j$，容量 $1$，$j$ 是叶子对应的序列下标。树二连费用 $a_j$，容量 $1$。最后每个虚点向汇点连费用 $0$，容量 $1$ 的边。检查一下发现这样连边恰好满足了所有要求。

共 $n\sqrt n$ 级别的边。跑 SSP 的时间复杂度是 $O(n^3\sqrt n)$。相较于题解区已有的 $O(n^3)/O(n^3\log n)$ 可能有些劣，但是网络流是跑不满的，并且 $n=1000$ 情况下， $\sqrt n$ 与 $\log n$ 是常数差距。所以可以通过。注意 SSP 算法的一些当前弧优化等不要漏掉。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Le0{
#define LL long long
const int N=1e5+5,inf=0x3f3f3f3f;
const LL lnf=1e18;
int n,W,maxn,nt;
struct node2{
    int x,y;
}q[N];
int a[N];
bool cmp(node2 a,node2 b){return a.x<b.x;}
bool cmp2(node2 a,node2 b){return a.y<b.y;}
struct edge{
    int to,ne,w,c;
}e[N*100];
int cnt=1,S,T,mx,mn=inf,b[N];
int head[10*N],now[N*10];
void add(int x,int y,int w,int c){
    e[++cnt]=(edge){y,head[x],w,c};
    head[x]=cnt;
    e[++cnt]=(edge){x,head[y],0,-c};
    head[y]=cnt;
}
struct node{
    int xl,xr,yl,yr;
}t[N<<2],as;
struct kdt{
    void pp(int p){
        t[p].xl=min(t[p<<1].xl,t[p<<1|1].xl);
        t[p].xr=max(t[p<<1].xr,t[p<<1|1].xr);
        t[p].yl=min(t[p<<1].yl,t[p<<1|1].yl);
        t[p].yr=max(t[p<<1].yr,t[p<<1|1].yr);
    }
    void build(int p,int l,int r,bool op){
        if(l==r){
            t[p].xl=t[p].xr=q[l].x;
            t[p].yl=t[p].yr=q[l].y;
            add(p,++nt,1,q[l].y);
            add(p+maxn,nt,1,-q[l].y);
            add(nt,T,1,0);
            return;
        }
        int mid=l+r>>1;nth_element(q+l,q+mid,q+r+1,op?cmp:cmp2);
        build(p<<1,l,mid,op^1);build(p<<1|1,mid+1,r,op^1);
        add(p,p<<1,inf,0);add(p,p<<1|1,inf,0);
        add(p+maxn,(p<<1)+maxn,inf,0);
        add(p+maxn,(p<<1|1)+maxn,inf,0);
        pp(p);
    }
    void modify(int p,int l,int r,int xl,int xr,int yl,int yr,int k,int op){
        if(xl>xr) return;if(yl>yr) return;
        if(t[p].xr<xl||t[p].xl>xr||t[p].yr<yl||t[p].yl>yr) return;
        if(t[p].xl>=xl&&t[p].xr<=xr&&t[p].yl>=yl&&t[p].yr<=yr){
            if(op) add(nt,p+maxn,1,k);
            else add(nt,p,1,k);
            return;
        }
        int mid=l+r>>1;
        modify(p<<1,l,mid,xl,xr,yl,yr,k,op);
        modify(p<<1|1,mid+1,r,xl,xr,yl,yr,k,op);
    }
}kd;
LL dis[N*10],ans;
bool vis[N*10];
bool bfs(){
    queue<int> q;
    for(int i=1;i<=nt;i++) dis[i]=lnf,vis[i]=0;
    dis[S]=0;
    q.push(S);
    vis[S]=1;
    while(q.size()){
        int x=q.front();q.pop();
        vis[x]=0;
        for(int i=head[x];i;i=e[i].ne){
            int y=e[i].to;
            if(e[i].w>0&&dis[y]>dis[x]+e[i].c){
                dis[y]=dis[x]+e[i].c;
                if(!vis[y]){
                    q.push(y);
                    vis[y]=1;
                }
            }  
        }
    }
    return dis[T]!=lnf;
}
int dfs(int x,int sum){
    if(x==T) return sum;
    vis[x]=1;
    int tot=0;
    for(int i=now[x];i&&sum;i=e[i].ne){
        int y=e[i].to;
        now[x]=i;
        if(!vis[y]&&e[i].w>0&&dis[y]==dis[x]+e[i].c){
            int k=dfs(y,min(sum,e[i].w));
            if(!k) dis[y]=lnf;
            e[i].w-=k;
            e[i^1].w+=k;
            tot+=k;
            sum-=k;
            ans+=k*e[i].c;
        }
    }
    vis[x]=0;
    return tot;
}
int main(){
    cin>>n>>W;maxn=n<<2;nt=maxn<<1;
    for(int i=1;i<=n;i++){
        cin>>q[i].y;
        q[i].x=i,b[i]=q[i].y;
        mx=max(mx,q[i].y);
        mn=min(mn,q[i].y);
    }
    S=++nt,T=++nt;
    kd.build(1,1,n,0);
    for(int i=1;i<=n;i++){
        ++nt;
        add(S,nt,1,0);
        add(nt,T,1,W);
        kd.modify(1,1,n,1,i-1,mn,b[i],b[i],1);
        kd.modify(1,1,n,1,i-1,b[i]+1,mx,-b[i],0);
    }
    while(bfs()){
        for(int i=1;i<=nt;i++) now[i]=head[i];
        dfs(S,inf);
    }
    cout<<ans<<"\n";
    return 0;
}
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0);
    return Le0::main();
}
```


---


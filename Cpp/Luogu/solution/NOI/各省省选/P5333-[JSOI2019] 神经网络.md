# [JSOI2019] 神经网络

## 题目背景

火星探险队发现，火星人的思维方式与人类非常不同，是因为他们拥有与人类很不一样的神经网络结构。为了更好地理解火星人的行为模式，JYY 对小镇上火星人的大脑进行了扫描，得到了一些重要数据。

## 题目描述

火星人在出生后，神经网络可以看作是一个由若干无向树 $\{T_1(V_1, E_1), T_2(V_2, E_2),\ldots T_m(V_m, E_m)\}$ 构成的森林。随着火星人年龄的增长，神经连接的数量也不断增长。初始时，神经网络中生长的连接 $E^\ast = \varnothing$。神经网络根据如下规则生长：
- 如果节点 $u \in V_i, v \in V_j$ 分别属于不同的无向树 $T_i$ 和 $T_j$（$i \neq j$），则 $E^\ast$ 中应当包含边 $(u, v)$。

最终，在不再有神经网络连接可能生长后，神经网络之间的节点连接可以看成是一个无向图 $G(V,E)$，其中

$$V=V_1\cup V_2\cup \ldots \cup V_m,E=E_1\cup E_2\cup \ldots \cup E_m\cup E^\ast$$

火星人的决策是通过在 $G(V, E)$ 中建立环路完成的。针对不同的外界输入，火星人会建立不同的神经连接环路，从而做出不同的响应。为了了解火星人行为模式的复杂性，JYY 决定计算 $G$ **中哈密顿回路的数量**。

$G(V, E)$ 的哈密顿回路是一条简单回路，从第一棵树的第一个节点出发，恰好经过 $V$ 中的其他节点一次且仅一次，并且回到第一棵树的第一个节点。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/57736.png)

## 样例 #1

### 输入

```
2
3
1 2
1 3
2
1 2```

### 输出

```
12```

# 题解

## 作者：LebronDurant (赞：13)

神仙题啊orz。树上背包+EGF。

考虑这个哈密顿回路可以拆分成什么。任意两棵树之间都可以到达，那么就可以拆分成一堆树的链的一个环，任意两个在环上相邻的链都不属于一棵树。首先求出每棵树拆分成$j$个链有多少种方案。注意一条长度大于1的链可以翻转过来，是两种方案。树上背包dp一下即可，dp式见代码，写的有点丑，请见谅。

然后发现如果就是链排列的话，直接把这$m$棵树的以链数为下标的EGF乘到一起就是答案的EGF，每一项系数加起来即可。然而这题相邻的颜色不可以一样，那么考虑容斥。假设我们求至少$j$对相邻的，我们就把钦定的这$j$对捏成一个大链，方便计算。那么dp式定义有了改变，变成了考虑前$i$棵树，有$j$个大链的带容斥系数方案数。注意是带容斥系数的，因为每棵树的容斥系数也要相乘才能得到这个拆分方案的总容斥系数。依然是有标号背包形式，也可以转化成EGF卷积。

第一棵树有一些特殊限定条件，先不考虑他。考虑其他树的EGF是什么。式子中的$f_i$表示这棵树拆分成$i$条链的方案数，已通过上文dp求出。$j$枚举的是我们钦定了多少对相邻颜色相同的链。这是除了第一棵树以外其他树的EGF：

$\sum\limits_{i=1}^{k}f_i\times i!\sum\limits_{j=0}^{i-1}(-1)^jC_{i-1}^j \frac{x^{i-j}}{(i-j)!}$

首先拆分成$i$条链方案数为$f_i$，内部排列是$i!$，然后容斥系数为$(-1)^j$，在这$i$条链中，有$i-1$个空隙，从中选$j$个钦定其为相邻，方案数为$C_{i-1}^j$。$i$条链$j$对相邻，那么就有$i-j$条大链，所以是EGF的第$i-j$项。

然后考虑第一棵树的限制怎么处理。第一个限制：第一条链必须属于第一棵树，且包含1号节点。那么就钦定第一棵树的包含1号节点的链是第一个即可。他不参与内部排列，不参与外部的有标号卷积，所以拆分成$i$条链内部排列变成$(i-1)!$，变成EGF的第$i-j-1$项

$\sum\limits_{i=1}^{k}f_i\times (i-1)!\sum\limits_{j=0}^{i-1}(-1)^jC_{i-1}^j \frac{x^{i-j-1}}{(i-j-1)!}$

第二个限制：最后一条链不可以属于第一棵树。那么上面的EGF是不考虑第二个限制的，把不符合第二个限制的部分减掉即可。也就是说我们钦定最后一条链属于第一棵树，把这个EGF减掉即可。最后一条链属于第一棵树的话，在这$i$条链里面任选一个不参与外部的有标号卷积，但是内部排列他还要参加，因为任何一条属于第一棵树的链都可以做最后一条链，所以内部排列还是$(i-1)!$，变成EGF的第$i-j-2$项。

$\sum\limits_{i=1}^{k}f_i\times (i-1)!\sum\limits_{j=0}^{i-2}(-1)^jC_{i-1}^j \frac{x^{i-j-2}}{(i-j-2)!}$

假如说$j=i-1$的话，相当于是这棵树的所有链都挨在一起，且包含第一条链和最后一条链，这等价于一共只有1棵树。这种情况下$i-j-2$出现了$-1$项，是没有定义的。所以说严格来讲这题应该限制$m>1$，否则这个做法是有问题的。把所有树的EGF都卷起来，得到的EGF别忘了每一项要乘以$i!$，才是有标号背包转移得到的结果。把所有答案加起来就是容斥出来的结果。

真的是道非常好的题，认真思考会对EGF理解加深很多。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
#define N 300002
typedef long long ll;
const int p=998244353;
struct edge{int to,nxxt;}e[N<<1];
int m,k[302],head[N],cnt=1,dp[5002][5002][3],siz[N],t[5002][3],ct[5002];
int inv[N],fac[N],finv[N],f[N],g[N],py[N];
inline void ins(int u,int v){e[cnt].to=v;e[cnt].nxxt=head[u];head[u]=cnt++;}
void df5(int te,int la)
{siz[te]=1;dp[te][1][0]=1;
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;if(j==la)continue;
        df5(j,te);
        for(int ii=1;ii<=siz[te]+siz[j];ii++)t[ii][0]=t[ii][1]=t[ii][2]=0;
        for(int ii=1;ii<=siz[te];ii++)for(int jj=1;jj<=siz[j];jj++)
        {
            int tdp=(1ll*dp[j][jj][0]+2ll*dp[j][jj][1]%p+dp[j][jj][2])%p;
            (t[ii+jj][0]+=1ll*dp[te][ii][0]*tdp%p)%=p;
            (t[ii+jj][1]+=1ll*dp[te][ii][1]*tdp%p)%=p;
            (t[ii+jj][2]+=1ll*dp[te][ii][2]*tdp%p)%=p;
            (t[ii+jj-1][1]+=1ll*dp[te][ii][0]*dp[j][jj][0]%p)%=p;
            (t[ii+jj-1][1]+=1ll*dp[te][ii][0]*dp[j][jj][1]%p)%=p;
            (t[ii+jj-1][2]+=2ll*dp[te][ii][1]*(dp[j][jj][0]+dp[j][jj][1])%p)%=p;
        }siz[te]+=siz[j];
        for(int ii=1;ii<=siz[te];ii++)
        dp[te][ii][0]=t[ii][0],dp[te][ii][1]=t[ii][1],dp[te][ii][2]=t[ii][2];
    }
}
inline int C(int nn,int mm)
{
    if(nn<mm)return 0;
    if(mm==0||nn==mm)return 1;
    return 1ll*fac[nn]*finv[mm]%p*finv[nn-mm]%p;
}
int main()
{//freopen("7.in","r",stdin);
    fac[0]=finv[0]=inv[1]=fac[1]=finv[1]=1;
    for(int i=2;i<=100000;i++)
    {
        inv[i]=1ll*(p-p/i)*inv[p%i]%p;
        fac[i]=1ll*fac[i-1]*i%p;finv[i]=1ll*finv[i-1]*inv[i]%p;
    }
    scanf("%d",&m);f[0]=1;int sum=0;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&k[i]);
        for(int j=1;j<=k[i];j++)head[j]=ct[j]=0;cnt=1;
        for(int j=1;j<k[i];j++)
        {
            int x,y;scanf("%d%d",&x,&y);
            ins(x,y),ins(y,x);
        }
        for(int ii=1;ii<=k[i];ii++)for(int j=1;j<=k[i];j++)dp[ii][j][0]=dp[ii][j][1]=dp[ii][j][2]=0;
        df5(1,1);for(int j=1;j<=k[i];j++)ct[j]=(1ll*dp[1][j][0]+2ll*dp[1][j][1]%p+dp[1][j][2])%p;
        for(int j=0;j<=k[i];j++)g[j]=0;
        //for(int j=1;j<=k[i];j++)printf("%d ",ct[j]);puts("");
        if(i^1)
        {
            for(int ii=1;ii<=k[i];ii++)
            for(int j=0;j<ii;j++)
            {
                if(j&1)g[ii-j]=(g[ii-j]-1ll*ct[ii]*fac[ii]%p*C(ii-1,j)%p+p)%p;
                else g[ii-j]=(g[ii-j]+1ll*ct[ii]*fac[ii]%p*C(ii-1,j)%p)%p;
            }
        }
        else
        {
            for(int ii=1;ii<=k[i];ii++)for(int j=0;j<ii;j++)
            {
                if(j&1)g[ii-j-1]=(g[ii-j-1]-1ll*ct[ii]*fac[ii-1]%p*C(ii-1,j)%p+p)%p;
                else g[ii-j-1]=(g[ii-j-1]+1ll*ct[ii]*fac[ii-1]%p*C(ii-1,j)%p)%p;
            }
            for(int ii=1;ii<=k[i];ii++)for(int j=0;j<ii-1;j++)
            {
                if(j&1)g[ii-j-2]=(g[ii-j-2]+1ll*ct[ii]*fac[ii-1]%p*C(ii-1,j)%p)%p;
                else g[ii-j-2]=(g[ii-j-2]-1ll*ct[ii]*fac[ii-1]%p*C(ii-1,j)%p+p)%p;
            }
        }
        for(int ii=0;ii<=k[i];ii++)g[ii]=1ll*g[ii]*finv[ii]%p;
        for(int ii=0;ii<=sum+k[i];ii++)py[ii]=0;
        for(int ii=0;ii<=sum;ii++)for(int jj=0;jj<=k[i];jj++)
        (py[ii+jj]+=1ll*f[ii]*g[jj]%p)%=p;
        sum+=k[i];
        for(int ii=0;ii<=sum;ii++)f[ii]=py[ii];
    }
    int ans=0;
    for(int ii=0;ii<=sum;ii++)ans=(ans+1ll*f[ii]*fac[ii]%p)%p;
    printf("%d\n",ans);
}
/*
3
4
2 1
4 3
3 1
5
4 5
3 4
3 2
1 2
1
*/
```

---

## 作者：wlzhouzhuan (赞：7)

## 神经网络
由于任意两棵树之间都可以到达，那可以将每棵树拆分成若干不相交的链，将这些链按一定顺序拼接起来，即为哈密顿回路。

对于该哈密顿回路，有以下两个限制：
- 相邻的链不能属于同一棵树
- 第一条链是第一棵树 $1$ 号节点所在的链，最后一条链不是第一棵树的链

首先，对于每棵树，用树形 $dp$ 求解拆分成 $j$ 个链的方案数。用 $dp[u][i][0/1/2]$ 表示以 $u$ 为根的子树，当前拆成 $i$ 条链，且点 $u$ 所在链的状态是**已拼成链/新的链(单点)/长度>1且还可继续向上拼接的链**的拆分方案数。转移细节极多（有 13 条转移式）。

定义 $f[i]$ 表示拆分成 $i$ 个链的方案数，则有 $f[i] = dp[root][i][0]+dp[root][i-1][1]+2\times dp[root][i-1][2]$ 。

定义一个链的颜色表示它所在的树下标。如果仅仅是链排列，那么直接将 $m$ 棵树的以链数为下标的 $EGF$ 卷起来就是答案的 $EGF$ ，但这题相邻的颜色不能一样，考虑容斥：**钦定**有 $j$ 个相邻的位置颜色一样。则不难得到一棵树的 $EGF$:

$$F(x)=\sum\limits_{i=1}^{k}f[i]* i!*\sum\limits_{j=0}^{i-1}(-1)^j\binom{i-1}{j}\frac{x^{i-j}}{(i-j)!}$$

解释：有 $f[i]$ 种拆分方式，这些链排列有 $i!$ 种，容斥系数为 $(-1)^j$ ，有 $i-1$ 个相邻位置挑 $j$ 个，得到 $i-j$ 条**极长链**（极长链是指同色链的极长连通块）。

注意第一棵树比较特殊，它需要满足：

- 第一个点所在的链处于首

此时钦定这条链为首即可，它不参与内部链排列，也不参与外部的 $EGF$ 卷积：

$$\sum\limits_{i=1}^{k}f[i]*(i-1)!*\sum\limits_{j=0}^{i-1}(-1)^j\binom{i-1}{j}\frac{x^{i-j-1}}{(i-j-1)!}$$
- 最后一条链颜色不能是 $1$

这是上面的式子多算的部分，考虑将其剔除：

$$\sum\limits_{i=1}^{k}f[i]*(i-1)!*\sum\limits_{j=0}^{i-2}(-1)^j\binom{i-1}{j}\frac{x^{i-j-2}}{(i-j-2)!}$$

注意这里 $j$ 的上界是 $i-2$ ，因为 $x^{-1}$ 无意义。

做有标号背包卷积即可，时间复杂度 $O(k^2)$ 。

```cpp
// Author: wlzhouzhuan
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define pb push_back
#define fir first
#define sec second
#define rep(i, l, r) for (int i = l; i <= r; i++)
#define per(i, l, r) for (int i = l; i >= r; i--)
#define mset(s, t) memset(s, t, sizeof(s))
#define mcpy(s, t) memcpy(s, t, sizeof(t))
template<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }
template<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }
int read() {
  int x = 0, f = 0; char ch = getchar();
  while (!isdigit(ch)) f |= ch == '-', ch = getchar();
  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();
  return f ? -x : x;
}
template<typename T> void print(T x) {
  if (x < 0) putchar('-'), x = -x;
  if (x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
template<typename T> void print(T x, char let) {
  print(x), putchar(let);
}

const int mod = 998244353;
const int N = 5002;

vector<int> adj[N];
ll f[N], dp[N][N][3], tmp[N][3];
ll F[N], G[N], H[N];
int t, n;

ll qpow(ll a, ll b = mod - 2) {
  ll res = 1;
  while (b > 0) {
    if (b & 1) res = res * a % mod;
    a = a * a % mod;
    b >>= 1;
  }
  return res;
} 
ll fac[N], ifac[N];
void init(int n) {
  fac[0] = ifac[0] = 1;
  for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % mod;
  ifac[n] = qpow(fac[n]);
  for (int i = n - 1; i >= 1; i--) ifac[i] = ifac[i + 1] * (i + 1) % mod;
}
ll C(ll n, ll m) {
  return fac[n] * ifac[n - m] % mod * ifac[m] % mod;
}

void add(ll &x, ll y) {
  x += y;
  if (x >= mod) x -= mod;
}
void sub(ll &x, ll y) {
  x -= y;
  if (x < 0) x += mod;
}
int sz[N];
void dfs(int u, int fa) {
  sz[u] = 1, dp[u][0][1] = 1;
  for (auto v: adj[u]) {
    if (v == fa) continue;
    dfs(v, u);
    for (int i = 0; i <= sz[u]; i++) {
      for (int j = 0; j <= sz[v]; j++) {
        add(tmp[i + j][0], dp[u][i][0] * dp[v][j][0] % mod);
        add(tmp[i + j + 1][0], dp[u][i][0] * dp[v][j][1] % mod);
        add(tmp[i + j + 1][0], 2ll * dp[u][i][0] * dp[v][j][2] % mod);
        add(tmp[i + j][1], dp[u][i][1] * dp[v][j][0] % mod);
        add(tmp[i + j][2], dp[u][i][1] * dp[v][j][1] % mod);
        add(tmp[i + j + 1][1], dp[u][i][1] * dp[v][j][1] % mod);
        add(tmp[i + j + 1][1], 2ll * dp[u][i][1] * dp[v][j][2] % mod);
        add(tmp[i + j][2], dp[u][i][1] * dp[v][j][2] % mod);
        add(tmp[i + j][2], dp[u][i][2] * dp[v][j][0] % mod);
        add(tmp[i + j + 1][2], dp[u][i][2] * dp[v][j][1] % mod);
        add(tmp[i + j + 1][0], 2ll * dp[u][i][2] * dp[v][j][1] % mod);
        add(tmp[i + j + 1][0], 2ll * dp[u][i][2] * dp[v][j][2] % mod);
        add(tmp[i + j + 1][2], 2ll * dp[u][i][2] * dp[v][j][2] % mod);
      }
    }
    sz[u] += sz[v];
    for (int i = 0; i <= sz[u]; i++) {
      dp[u][i][0] = tmp[i][0], tmp[i][0] = 0;
      dp[u][i][1] = tmp[i][1], tmp[i][1] = 0;
      dp[u][i][2] = tmp[i][2], tmp[i][2] = 0;
    }
  }
}
int main() {
  init(5000);
  t = read();
  int sum = 0;
  F[0] = 1;
  for (int id = 1; id <= t; id++) {
    n = read();
    for (int i = 1; i <= n; i++) {
      adj[i].clear();
      for (int j = 0; j <= sz[i]; j++) {
        dp[i][j][0] = dp[i][j][1] = dp[i][j][2] = 0;
      }
      sz[i] = 0;
    }
    for (int i = 1; i < n; i++) {
      int u = read(), v = read();
      adj[u].pb(v), adj[v].pb(u);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; i++) {
      f[i] = (dp[1][i][0] + dp[1][i - 1][1] + 2ll * dp[1][i - 1][2]) % mod;
      //printf("f[%d] = %d\n", i, f[i]);
    }
    for (int i = 0; i <= n; i++) G[i] = 0;
    if (id == 1) {
      for (int i = 1; i <= n; i++) {
        ll coef = f[i] * fac[i - 1] % mod;
        for (int j = 0; j <= i - 1; j++) {
          if (j & 1) sub(G[i - j - 1], coef * C(i - 1, j) % mod * ifac[i - j - 1] % mod);
          else add(G[i - j - 1], coef * C(i - 1, j) % mod * ifac[i - j - 1] % mod);
        }
      }
      for (int i = 1; i <= n; i++) {
        ll coef = f[i] * fac[i - 1] % mod;
        for (int j = 0; j <= i - 2; j++) {
          if (j & 1) add(G[i - j - 2], coef * C(i - 1, j) % mod * ifac[i - j - 2] % mod);
          else sub(G[i - j - 2], coef * C(i - 1, j) % mod * ifac[i - j - 2] % mod);
        }
      }
    } else {
      for (int i = 1; i <= n; i++) {
        ll coef = f[i] * fac[i] % mod;
        for (int j = 0; j <= i - 1; j++) {
          if (j & 1) sub(G[i - j], coef * C(i - 1, j) % mod * ifac[i - j] % mod);
          else add(G[i - j], coef * C(i - 1, j) % mod * ifac[i - j] % mod);
        }
      }
    }
//    for (int i = 0; i <= n; i++) printf("%lld ", G[i]); puts(""); 
    for (int i = 0; i <= sum + n; i++) H[i] = 0;
    for (int i = 0; i <= sum; i++) {
      for (int j = 0; j <= n; j++) {
        add(H[i + j], F[i] * G[j] % mod);
      }
    }
    sum += n;
    for (int i = 0; i <= sum; i++) F[i] = H[i];
  }
  ll ans = 0;
  for (int i = 0; i <= sum; i++) add(ans, F[i] * fac[i] % mod);
  ans = (ans % mod + mod) % mod;
  printf("%lld\n", ans);
  return 0;
}
```

---

## 作者：i207M (赞：6)

~~为啥一股模拟赛原题的味道...~~

像这种多个图，图与图之间是完全图，求哈密顿回路，我们其实就是把每个图上走的路径归并起来。

那道模拟赛的题，是用状压DP直接DP出一个排列，然后要求排列中的j个位置不能相邻。

但是这道题不能这么想，对于每棵树，我们求出它们的链划分（长度>1的链有两种方向），然后强制这就是经过它的方式，链与链之间必须断开，链之内不能断开。

树形DP：$dp[i][0/1/2]$即可

然后考虑归并起来。这道题要求的是**给定起点的回路**

我们先考虑除了第一棵树的EGF：

$$\sum _if_ii!\sum _{j=1}^i (-1)^{i-j}{i-1\choose i-j}x^j/j!$$

第一棵树的EGF，我们要强制一个起点，划分为i段就有i个起点：

$$\sum _if_i(i-1)!\sum _{j=1}^i (-1)^{i-j}{i-1\choose i-j}x^{j-1}/(j-1)!$$

（钦定起点后就不参与归并了）

但是我们还要减去首尾颜色相同的EGF：

$$\sum _if_i(i-1)!\sum _{j=2}^i (-1)^{i-j}{i-1\choose i-j}x^{j-2}/(j-2)!$$

然后把它们暴力卷积起来即可。 

```cpp
#define N 5005
int sz[N];
vector<int> E[N];
int dp[N][N][2];
void dfs(int x,int _fa)
{
	static int f[N],tmp[N][3];
	dp[x][0][0]=1;
	sz[x]=1;
	for(solid v:E[x])
	{
		if(v==_fa) continue;
		dfs(v,x);
	}
	for(solid v:E[x])
	{
		if(v==_fa) continue;
		for(ri i=0; i<sz[x]; ++i)
			for(ri j=1; j<=sz[v]; ++j)
			{
				inc(tmp[i+j][0],mul(dp[x][i][0],dp[v][j][0]));
				inc(tmp[i+j][1],mul(dp[x][i][0],dp[v][j][1]));
				inc(tmp[i+j][1],mul(dp[x][i][1],dp[v][j][0]));
				inc(tmp[i+j-1][2],mul(dp[x][i][1],dp[v][j][1],2));
				inc(tmp[i+j][2],mul(f[i],dp[v][j][0]));
			}
		sz[x]+=sz[v];
		for(ri i=0; i<sz[x]; ++i)
		{
			dp[x][i][0]=tmp[i][0];
			dp[x][i][1]=tmp[i][1];
			f[i]=tmp[i][2];
			tmp[i][0]=tmp[i][1]=tmp[i][2]=0;
		}
		for(ri j=0; j<=sz[v]; ++j) dp[v][j][0]=dp[v][j][1]=0;
	}
	for(ri i=sz[x]; i>=1; --i)
	{
		dp[x][i][0]=add(dp[x][i-1][0],f[i],mul(dp[x][i][1],2));
		dp[x][i][1]=add(dp[x][i-1][0],dp[x][i][1]);
		f[i]=0;
	}
	E[x].clear();
}
int fac[N],ifac[N];
void init(int n)
{
	fac[0]=1;
	for(ri i=1; i<=n; ++i) fac[i]=mul(fac[i-1],i);
	ifac[n]=mdinv(fac[n]);
	for(ri i=n; i>=1; --i) ifac[i-1]=mul(ifac[i],i);
}
il int C(int n,int m) {return mul(fac[n],ifac[m],ifac[n-m]);}
int ans[N],f[N],ci;
int n,m;
void Mul()
{
	static int tmp[N];
	for(ri i=0; i<=ci; ++i)
		for(ri j=0; j<=n; ++j)
			inc(tmp[i+j],mul(ans[i],f[j]));
	ci+=n;
	for(ri i=0; i<=ci; ++i) ans[i]=tmp[i],tmp[i]=0;
	clr(f,n+1);
}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	init(5000);
	ans[0]=1;
	in(m);
	for(ri o=1; o<=m; ++o)
	{
		in(n);
		for(ri i=1,a,b; i<n; ++i)
		{
			in(a,b);
			E[a].pb(b),E[b].pb(a);
		}
		dfs(1,0);
		if(o==1)
		{
			for(ri i=1; i<=n; ++i)
				for(ri j=1; j<=i; ++j)
				{
					int t=mul(dp[1][i][0],fac[i-1],C(i-1,i-j),ifac[j-1]);
					if((i-j)&1) dec(f[j-1],t);
					else inc(f[j-1],t);
					if(j>1)
					{
						t=mul(t,j-1);
						if((i-j)&1) inc(f[j-2],t);
						else dec(f[j-2],t);
					}
				}
		}
		else
		{
			for(ri i=1; i<=n; ++i)
				for(ri j=1; j<=i; ++j)
				{
					int t=mul(dp[1][i][0],fac[i],C(i-1,i-j),ifac[j]);
					if((i-j)&1) dec(f[j],t);
					else inc(f[j],t);
				}
		}
		Mul();
		for(ri i=1; i<=n; ++i) dp[1][i][0]=dp[1][i][1]=0;
	}
	int res=0;
	for(ri i=0; i<=ci; ++i) inc(res,mul(ans[i],fac[i]));
	out(res);
	return 0;
}


---

## 作者：天命之路 (赞：4)

这题只要思考方向顺了，并不是一道多么困难的题。

考虑一个哈密顿回路，进入和出来一棵树，会在树上走一条链。

那么我们计数这个哈密顿回路，就先计数把这些树剖分成若干条链的方案数，最后再把这些链串起来。

具体地，我们对每棵树进行树形 $dp$。

设 $dp[u][i][0/1/2]$ 表示将 $u$ 子树划分成 $i$ 条链，最后一维表示 $u$ 当前的度数，为 $0$ 则表示没有被划入任何一条链中。

转移类似树形背包，每次讨论 $(x,y)$ 这条边连不连即可。

因为长度 $\ge 2$ 的链在最终路径中有正反两种选择，所以 $dp$ 时要特殊处理孤立点。

其实我们可以直接把孤立点当成自环，那么我们赋初值的时候可以直接 $dp[u][0][0] = 1,dp[u][1][2] = \dfrac{1}{2}$，最后提取答案时再乘上 $2^i$。

我们假设第 $i$ 棵树剖分出了 $k_i$ 条链。

现在我们要将这 $\sum k_i$ 个物品放在一起，形成一个圆排列，并且相同种类的物品不能相邻（就是说来自同一棵树的两条链不能相邻）

那我们直接容斥，钦定第 $i$ 棵树的 $k_i$ 条链形成了 $s_i$ 个连续段。

容斥系数是 $(-1)^{k_i-s_i}$，最后把这 $\sum s_i$ 个段拍成圆排列的方案数是 $(\sum s_i - 1)!$。

另一方面,设 $L(n,m)$ 表示将 $n$ 个有标号球划分为 $m$ 个排列的方案数，可以通过递推式 $L(n,m) = L(n-1,m-1)+(n+m-1)L(n-1,m)$ 求得，也可通过通项 $L(n,m) = \binom{n-1}{m-1}\dfrac{n!}{m!}$ 求得。

对于每棵树，设 $F[x]$ 表示 $s_i = x$ 时容斥系数 $\times$ 方案数的和。

那么一个 $k_i$ 对 $s_i$ 的贡献系数就是 $(-1)^{k_i-s_i} L(k_i,s_i)$。

把每棵树的 $F$ 背包起来即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e3 + 5,P = 998244353,inv2 = (P + 1) / 2;
int n,m,k;
int dp[N][N][3];
vector<int> G[N];
int sze[N];
int fac[N],ifac[N];
inline void Plus(int &a,const int &b) { a += b;if(a >= P) a -= P;}
inline void Minus(int &a,const int &b) { a -= b;if(a < 0) a += P;}
inline void init(int n)
{
	fac[0] = 1;
	for(int i = 1;i <= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[1] = 1;
	for(int i = 2;i <= n;i++) ifac[i] = 1ll * ifac[P % i] * (P - P / i) % P;
	ifac[0] = 1;
	for(int i = 1;i <= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;
}
inline int C(int n,int m) { return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;}
inline int L(int n,int m) { return 1ll * C(n - 1,m - 1) * fac[n] % P * ifac[m] % P;}
// 孤立点系数 1/2
int tmp[N][3];
void Dp(int x,int fa,int first)
{
	dp[x][0][0] = 1;
	dp[x][1][2] = inv2;
	sze[x] = 1;
	for(auto y : G[x])
	{
		if(y == fa) continue;
		Dp(y,x,first);
		for(int i = 0;i <= sze[x];i++)
			for(int j = 0;j <= sze[y];j++)
			{
				// (x,y) 不连
				for(int a = 0;a < 3;a++)
					for(int b = 1;b < 3;b++)
						Plus(tmp[i + j][a],1ll * dp[x][i][a] * dp[y][j][b] % P);
				// (x,y) 连接
				Plus(tmp[i + j + 1][1],1ll * dp[x][i][0] * dp[y][j][0] % P);
				Plus(tmp[i + j][2],1ll * dp[x][i][1] * dp[y][j][0] % P);
				Plus(tmp[i + j][1],1ll * dp[x][i][0] * dp[y][j][1] % P);
				Plus(tmp[i + j - 1][2],1ll * dp[x][i][1] * dp[y][j][1] % P); // 拼起来两条链
			}
		sze[x] += sze[y];
		for(int i = 0;i <= sze[x];i++)
			for(int a = 0;a < 3;a++)
				dp[x][i][a] = tmp[i][a],tmp[i][a] = 0;
	}
}
int Ans[N];
int F[N]; // 容斥，F[i] 表示分成 i 块的容斥系数之和
int Pow2[N];
inline void Clr()
{
	for(int i = 1;i <= n;i++)
	{
		F[i] = 0,G[i].clear();
		for(int j = 0;j <= n;j++)
			dp[i][j][0] = dp[i][j][1] = dp[i][j][2] = 0;
	} 
}
int nowsiz;
int h[N];
inline void SolveT(int first) // 第一棵树需要特殊处理一下
{
	Clr();
	cin >> n;
	for(int i = 1;i < n;i++)
	{
		int u,v;
		cin >> u >> v;
		G[u].push_back(v);G[v].push_back(u);
	}
	Dp(1,0,first);
	Pow2[0] = 1;
	for(int i = 1;i <= n;i++)
	{
		Pow2[i] = 2ll * Pow2[i - 1] % P;
		int now = 0;
		now = (dp[1][i][1] + dp[1][i][2]) % P;
		now = 1ll * now * Pow2[i] % P;
		for(int j = 1;j <= i;j++)
			if((i-j)&1)
				Minus(F[j],1ll * L(i,j) * now % P);
			else Plus(F[j],1ll * L(i,j) * now % P);
	}
	for(int i = 0;i <= nowsiz;i++)
		for(int j = 1;j <= n;j++)
			Plus(h[i + j],1ll * Ans[i] * F[j] % P);
	nowsiz += n;
	for(int i = 0;i <= nowsiz;i++) Ans[i] = h[i],h[i] = 0;
}
int main()
{	
	cin >> m;
	if(m == 1) return puts("0"),0;
	init(5000);
	Ans[0] = 1;
	SolveT(1);
	for(int i = 2;i <= m;i++) 
		SolveT(0);
	int ans = 0;
	for(int i = 1;i <= nowsiz;i++)
		Plus(ans,1ll * Ans[i] * fac[i - 1] % P);
	cout << ans << endl;
	return 0;
}

```


---

## 作者：Kevin090228 (赞：3)

首先使用树上背包求出将树 $T_i$ 拆成 $j$ 条链的方案数 $f(i,j)$。做背包时需要注意长度 $\geq 2$ 的链是有向的，所以需要处理一些 $\times 2$。

对于每棵树有 EGF $F(i)=\sum \frac{f(i,j)x^j}{j!}$。

如果不要求相邻链来自不同树，则答案的 EGF 为 $\prod F(i)$。

我们定义 $g(n,k)$ 为将 $n$ 个元素分成 $k$ 组的方案数，组内有序，组间有序。容易发现 $g(n,k)=n!\binom{n-1}{k-1}$。

对于树 $T_i$，我们钦定所有元素组成了 $k$ 个相邻段，有 EGF $F'(i)=\sum \frac{f(i,j)g(j,k)x^k}{k!}$。

考虑给每组 $(j,k)$ 在 $g(j,k)$ 的基础上钦定一个容斥系数。

我们要使拆分 $\{a_1,\cdots,a_k\}$ 的容斥系数和当且仅当 $a_1=\cdots=a_k=1$ 时为 $1$，否则为 $0$。

注意到拆分的容斥系数和为所有 $a_i$ 容斥系数和乘积。所以我们只需要保证 $\sum\limits_{i=0}^{x}g(x,i)=[x=1]$。我们将 $g(n,k)$ 修改为 $n!\binom{n-1}{k-1}(-1)^{n-k}$ 即可。

复杂度 $O((\sum k_i)^2)$。

---

## 作者：myee (赞：2)

### 思路

考虑到路径上会经过很多树，每棵树上经过的一段路径都是一条链（点数 $\ge2$）或者一个点。

设第 $j$ 颗树有 $a_{j,i}$ 种方法分成总数为 $i$ 的链（点数 $\ge2$）和点，其中链正反算不同，链、点无序。

然后就转变成了类似于《唱，跳，rap 和篮球》一题的问题，只是变成了环排列上计数。

先考虑如何计算 $a_{j,i}$ 的形式。

每棵树是独立的，考虑分别处理。

考虑树形 dp。

设 $f_{p,i,0/1}$ 表示在 $p$ 所在子树中，已经拼出了 $i$ 个链 / 点，当前节点是否向上连出一条边，已经被考虑的链均被统计了正反两遍的方案数。

则

$$
f_{p,i,0}=\sum_{\sum_sj_s=i-1}\prod_sf_{s,j_s,0}
+2\sum_{\sum_sj_s=i-1}\sum_{s_0}f_{s_0,j_{s_0},1}\prod_{s\neq s_0}f_{s,j_s,0}
+2\sum_{\sum_sj_s=i-1}\sum_{s_1<s_2}f_{s_1,j_{s_1},1}f_{s_2,j_{s_2},1}\prod_{s\neq s_1\land s\neq s_2}f_{s,j_s,0}
$$

$$
f_{p,i,1}=\sum_{\sum_sj_s=i}\prod_sf_{s,j_s,0}
+\sum_{\sum_sj_s=i}\sum_{s_0}f_{s_0,j_{s_0},1}\prod_{s\neq s_0}f_{s,j_s,0}
$$

利用树上背包的技巧优化一下 dp 即可，复杂度 $O(k^2)$。

然后回到 general problem，这又是经典题。

如果允许相邻元素相同，可以把答案描述为

$$
\sum_{\{p\}}(-1+\sum_jp_j)!(\prod_ja_{j,p_j})
$$

证明显然：枚举每棵树上的部分数目，然后做环排列。

但是不允许，所以不能使用上述做法。

接下来考虑对应单组 $\{p\}$，求其合法的环排列数。

首先由于是环排列，先钦定起点为 $1$ 号树上 $1$ 所在链 / 点的部分，给环上每个剩余位置以标号；同时也要求起点、终点不可为 $1$ 号树。

然后乘 $(p_1-1)!\prod_{j>1}p_j!$，转化成插入 $p_j$ 个等效元素。

对每个方案进行捆绑法枚举，$p_j\rightarrow v_j$ 要乘容斥系数 $(-1)^{p_j-v_j}\binom{p_j-1}{v_j-1}$，$j=1$ 时为 $(-1)^{p_j-v_j}\binom{p_j}{v_j}$。

然后枚举中间部分合并的方案数即为 $\binom{-1+\sum_jv_j}{v_1-1,v_2,\dots,v_m}$。（排列末尾和起点元素联通的部分要排除）

把容斥系数等重新组合一下，即是

$$(-1+\sum_jv_j)!\prod_j(-1)^{p_j-v_j}\frac{p_j!}{v_j!}\binom{p_j-1}{v_j-1}$$

于是答案即为

$$
\sum_{\{v\}}(-1+\sum_jv_j)!\sum_{\{p\}}\prod_j(-1)^{p_j-v_j}\frac{a_{j,p_j}p_j!}{v_j!}\binom{p_j-1}{v_j-1}
$$

看上去是非常恶心的柿子，但是考虑对 $v$ 做背包，将后面的部分描述成若干 $z^{v}$ 的系数，使用 GF 乘法理解，然后就完了。

总复杂度 $O(K^2)$，其中 $K=\sum k$。

直觉上，使用链分治等技巧，此题可以做到 $O(K\log^2K)$。

### Code

核心代码不长。

```cpp
const ullt Mod=998244353;
typedef ConstMod::mod_ullt<Mod>modint;
typedef std::vector<modint>modvec;
std::vector<uint>Way[5005];
modvec mul(modvec A,modvec B){
    modvec Ans(A.size()+B.size()-1);
    for(uint i=0;i<A.size();i++)
        for(uint j=0;j<B.size();j++)
            Ans[i+j]+=A[i]*B[j];
    return Ans;
}
modvec add(modvec A,modvec B){
    modvec Ans(std::max(A.size(),B.size()));
    for(uint i=0;i<A.size();i++)Ans[i]+=A[i];
    for(uint i=0;i<B.size();i++)Ans[i]+=B[i];
    return Ans;
}
std::pair<modvec,modvec>dfs(uint p,uint f){
    modvec A={1},B={0},C={0},X,Y;
    for(auto s:Way[p])if(s!=f){
        auto t=dfs(s,p);X=t.first,Y=t.second;
        C=add(mul(B,Y),mul(C,X)),B=add(mul(A,Y),mul(B,X)),A=mul(A,X);
    }
    Y=add(A,B),X=add(add(Y,B),add(C,C));
    Y.push_back(0),X.insert(X.begin(),0);
    return{X,Y};
}
modint P[10005],Q[10005];
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    // freopen("QAQ.out","w",stdout);
#endif
    P[0]=1;for(uint i=1;i<=10000;i++)P[i]=P[i-1]*i;
    Q[10000]=P[10000].inv();for(uint i=10000;i;i--)Q[i-1]=Q[i]*i;
    uint m;scanf("%u",&m);
    modvec Ans={1};
    while(m--){
        uint n;scanf("%u",&n);
        for(uint i=0;i<n;i++)Way[i].clear();
        for(uint i=1,u,v;i<n;i++)
            scanf("%u%u",&u,&v),Way[--u].push_back(--v),Way[v].push_back(u);
        modvec V=dfs(0,-1).first;
        // for(uint i=0;i<V.size();i++)
        //     V[i].print(),putchar(" \n"[i==V.size()-1]);
        modvec T(V.size());
        for(uint p=1;p<V.size();p++)for(uint v=1;v<=p;v++)
            T[v]+=V[p]*((p-v)&1?-modint(1):1)*P[p]*Q[v]*P[p-1]*Q[v-1]*Q[p-v];
        Ans=mul(Ans,T);
    }
    modint ans;
    for(uint i=Ans.size()-1;i;i--)
        ans=ans*i+Ans[i];
    ans.println();
    return 0;
}
```



---

## 作者：Otomachi_Una_ (赞：0)

## 神经网络

考虑哈密顿路径相关问题的经典做法：拆链。

考虑这个哈密顿路径和每棵树的交边，必然是若干的有向链。我们可以用 $\mathcal O(k_i^2)$ 求出把这棵树划分成 $i$ 条链的方案数。需要注意的是，除了单链，其他链都可以定向，有一个 $2$ 的系数。

不妨假设我们已经钦定每个树贡献出来的链数，$a_1,a_2,\dots,a_m$。问题转化为：

> 有 $\sum a_i$ 个有序小球，其中颜色 $i$ 有 $a_i$ 个。把这些小球排成一圈，要求相邻小球不同色，求方案数。

对于这个问题，我们可以容斥。具体的，我们把颜色 $i$ 的小球钦定为 $b_i$ 个链，假设这个容斥系数为 $(-1)^{a_i-b_i}H_{a_i}^{b_i}$，其中 $H_n^m$ 是把 $n$ 个小球排成 $m$ 个有区别队列的方案数，$H_n^m=n!\times\dbinom{n-1}{m-1}$。这之后我们去掉了相邻小球不同的限制，我们就可以通过背包求了。

对于这道题，有一个颜色 $i$ 有多种 $a_i$，我们可以把这些 $a_i$ 合并起来转移，复杂度是 $\mathcal O((\sum k)^2)$ 的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=5005;
const int MOD=998244353;
bool Mbe;
int m,n,siz[MAXN];
vector<int> edg[MAXN];
int f[MAXN][MAXN],g[MAXN][MAXN],h[MAXN][MAXN],tf[MAXN],tg[MAXN],th[MAXN];
int p[MAXN],fac[MAXN],s;
// 向父亲延申（不算自己），不延展，延展但孤立点
int q[MAXN][MAXN];// 把 i 个有区别元素分为 j 个有区别链的方案
bool Med;
void add(int &x,ll y){x=(x+y)%MOD;}
void dfs(int u,int fa){
	siz[u]=1;
	h[u][0]=1;
	for(int v:edg[u]) if(v!=fa){
		dfs(v,u);
		memset(tf,0,sizeof(tf));memset(tg,0,sizeof(tg));memset(th,0,sizeof(th));
		for(int i=0;i<=siz[u];i++) for(int j=0;j<=siz[v];j++){
			add(tf[i+j],1ll*f[u][i]*g[v][j]%MOD+1ll*h[u][i]*f[v][j]%MOD);
			add(th[i+j],1ll*h[u][i]*g[v][j]%MOD);
			add(tg[i+j],1ll*g[u][i]*g[v][j]%MOD);
			add(tg[i+j+1],2ll*f[u][i]*f[v][j]%MOD);
		}
		swap(f[u],tf);swap(g[u],tg);swap(h[u],th);
		siz[u]+=siz[v];
	}
	for(int i=0;i<=siz[u];i++){
		add(g[u][i+1],(2ll*f[u][i]+h[u][i])%MOD);
		add(f[u][i],h[u][i]);
	}
}
int main(){
	ios::sync_with_stdio(false);
	// freopen("ex_neural3.in","r",stdin);
	fac[0]=p[0]=1;
	for(int i=1;i<MAXN;i++) fac[i]=1ll*fac[i-1]*i%MOD;
	cin>>m;
	q[0][0]=1;
	for(int i=1;i<MAXN;i++) for(int j=1;j<=i;j++){
		q[i][j]=(1ll*(i+j-1)*q[i-1][j]+q[i-1][j-1])%MOD;
	}
	p[0]=1;
	for(int i=1;i<=m;i++){
		cin>>n;
		for(int i=1;i<=n;i++) edg[i].clear();
		for(int i=1;i<=n;i++){
			memset(f[i],0,sizeof(f[i]));
			memset(g[i],0,sizeof(g[i]));
			memset(h[i],0,sizeof(h[i]));
		}
		for(int j=1;j<n;j++){
			int u,v;cin>>u>>v;
			edg[u].push_back(v);
			edg[v].push_back(u);
		}
		dfs(1,0);
		for(int i=1;i<=siz[1];i++) for(int j=1;j<i;j++) 
			add(g[1][j],1ll*((i-j)&1?MOD-1:1)*q[i][j]%MOD*g[1][i]%MOD);
		for(int i=s+n;i>=0;i--){
			p[i]=0;
			for(int j=1;j<=n&&j<=i;j++) add(p[i],1ll*g[1][j]*p[i-j]%MOD);
		}
		s+=n;
	}
	ll ans=0;
	for(int i=1;i<=s;i++) ans+=1ll*fac[i-1]*p[i]%MOD;
	cout<<ans%MOD<<'\n';
	return 0;
}
```

---


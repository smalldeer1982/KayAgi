# [SDOI2019] 染色

## 题目描述

给定 $2 \times n$ 的格点图。其中一些结点有着已知的颜色，其余的结点还没有被染色。

 一个合法的染色方案不允许相邻结点有相同的染色。

现在一共有 $c$ 种不同的颜色，依次记为 $1$ 到 $c$。

 请问有多少对未染色结点的合法染色方案？

## 说明/提示

子任务$1$：（$44$分）$1\le n\le 10000$ 且 $5\le c\le 10000$；不存在一列有$2$个已染色结点；被染色结点全部位于第一行；第一列和最后一列均有结点已被染色。

子任务$2$：（$32$分）$1\le n\le 10000$ 且 $5\le c\le 10000$；不存在一列有$2$个已染色结点；第一列和最后一列均有结点已被染色。

子任务$3$：（$12$分）$1\le n\le 10000$ 且 $5\le c\le 10000$；第一列和最后一列均有结点已被染色。

子任务$4$：（$8$分）$1\le n\le 10000$ 且 $5\le c\le 10000$。

子任务$5$：（$4$分）$1\le n\le 100000$ 且 $5\le c\le 100000$。

## 样例 #1

### 输入

```
3 5
1 0 1
0 0 0```

### 输出

```
172```

## 样例 #2

### 输入

```
5 7
1 0 0 0 2
0 0 3 0 0```

### 输出

```
116370```

## 样例 #3

### 输入

```
10 13
0 2 0 0 1 0 2 0 0 3
0 1 0 1 0 0 0 0 4 0```

### 输出

```
770175525```

# 题解

## 作者：liuzhangfeiabc (赞：26)

题目大意：2×n的格子，用c种颜色进行染色，要求相邻的格子不能用相同的颜色，一些格子已经事先涂好了颜色，求方案数。

先%一下现场切掉这题的rqy。

我这里的做法与rqy的不同，我没看过官方题解不过我猜这个做法应该类似于官方题解的思路。

先考虑一个最朴素的dp。设f(i,j,k)为前i列，最后一列上面填j下面填k的方案数，转移直接枚举下一列填什么。

这样做显然复杂度非常高，光状态数就达到了nc^2。

我们该怎么优化这个算法呢？

首先当然是要把状态数减下来。我们把视线放在这个c^2上，能否在这里做些手脚呢？

注意到当这一列已经有事先填过的格子时，我们显然只需要c的状态就可以了。

假设当前列的上面已经填了颜色x，我们就直接记f(y)表示下面格子填y的方案数，其中f(x)=0。下面填了颜色类似。为方便起见，我们可以将上下都填颜色当成上面填颜色处理。

那我们处理到了没填过的列该怎么办呢？注意到所有没填过的列都长成一个样子，我们就自然而然地想到了：或许可以预处理转移！

我们直接将所有连续的空列看成一大段来一起转移，只在所有非空列更新dp值。

预处理一个数组g(i,s)，表示相邻两个非空列中间隔着i个空列，这两个非空列的状态为s时的转移系数。

其中这个“状态”指的是对应元素的相等关系。一共有如下7种状态：

```cpp
a ... a
b ... b
*******
a ... b
b ... a
*******
a ... a
b ... c
*******
a ... b
b ... c
*******
a ... c
b ... a
*******
a ... c
b ... b
*******
a ... c
b ... d
```

其中状态3和6，状态4和5是对称的，因此我们记5种状态即可。

g数组的预处理就是大分类讨论，细节详见代码。这一步是O(n)的。

这样我们只需要枚举所有非空列，也可以通过讨论一些列的相等关系实现转移。

注意特判一些特殊情况，比如数据本来就无解、没有非空列、开头和结尾有一堆空列等。

这样我们就获得了一个O(nc)的做法，可以获得96分的好成绩。

更进一步：仔细观察dp的转移，发现我们无非干了这么几件事：

单点修改；全局加；全局乘；全局赋值；单点查询；全局查询。

嗯？好像有点熟悉？

没错你只需要把t1的代码粘过来就能获得100分的好成绩了。

当然你也可以直接上线段树，反正照样跑得飞快。

96分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
inline li read(){
	li x = 0,y = 0,c = gc;
	while(!isdigit(c)) y = c,c = gc;
	while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
	return y == '-' ? -x : x;
}
inline void print(li q){
	if(q < 0) pc('-'),q = -q;
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
const li mo = 1000000009;
li n,c;
inline li ksm(li q,li w){
	li as = 1;
	while(w){
		if(w & 1) as = as * q % mo;
		q = q * q % mo;
		w >>= 1;
	}
	return as;
}
int a[100010],b[100010];
int wz[100010],ft;
li f[100010],g[100010][5],tp[100010];
int main(){
	int i,j,k,l,u,v,w;
	n = read();c = read();
	for(i = 1;i <= n;++i) a[i] = read();for(i = 1;i <= n;++i) b[i] = read();
	for(i = 1;i <= n;++i){
		if(a[i] || b[i]) wz[++ft] = i;
		if(a[i] && a[i] == b[i]){
			pc('0');pc('\n');return 0;
		}
		if(i < n && ((a[i] && a[i] == a[i + 1]) || (b[i] && b[i] == b[i + 1]))){
			pc('0');pc('\n');return 0;
		}
	}
	if(!ft){
		li as = c * (c - 1) % mo;
		for(i = 2;i <= n;++i) (as *= (c - 1 + (c - 2) * (c - 2) % mo) % mo) %= mo;
		print(as);pc('\n');return 0;
	}
	g[1][1] = g[1][3] = g[1][4] = 1;
	for(i = 2;i <= n;++i){
		g[i][0] = (g[i - 1][1] + g[i - 1][3] * (c - 2) * 2 + g[i - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		g[i][1] = (g[i - 1][0] + g[i - 1][2] * (c - 2) * 2 + g[i - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		g[i][2] = (g[i - 1][1] + g[i - 1][2] * (c - 2) + g[i - 1][3] * (c - 2 + c - 3) + g[i - 1][4] * (c - 3) % mo * (c - 3)) % mo;
		g[i][3] = (g[i - 1][0] + g[i - 1][3] * (c - 2) + g[i - 1][2] * (c - 2 + c - 3) + g[i - 1][4] * (c - 3) % mo * (c - 3)) % mo;
		g[i][4] = (g[i - 1][0] + g[i - 1][1] + g[i - 1][2] * (c - 3) * 2 + g[i - 1][3] * (c - 3) * 2 + g[i - 1][4] * (c - 3 + (c - 4) * (c - 4) % mo)) % mo;
	} 
	if(wz[1] == 1){
		if(a[1] && b[1]) f[b[1]] = 1;
		else if(a[1]){
			for(i = 1;i <= c;++i) if(i != a[1]) f[i] = 1;
		} 
		else{
			for(i = 1;i <= c;++i) if(i != b[1]) f[i] = 1;
		} 
	}
	else{
		int u = wz[1];
		if(a[u] && b[u]) f[b[u]] = (g[u - 1][0] + g[u - 1][1] + g[u - 1][2] * (c - 2) * 2 + g[u - 1][3] * (c - 2) * 2 + g[u - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		else if(a[u]){
			for(i = 1;i <= c;++i) if(i != a[u]) f[i] = (g[u - 1][0] + g[u - 1][1] + g[u - 1][2] * (c - 2) * 2 + g[u - 1][3] * (c - 2) * 2 + g[u - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		} 
		else{
			for(i = 1;i <= c;++i) if(i != b[u]) f[i] = (g[u - 1][0] + g[u - 1][1] + g[u - 1][2] * (c - 2) * 2 + g[u - 1][3] * (c - 2) * 2 + g[u - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		} 
	}
	for(i = 2;i <= ft;++i){
		li s = 0;w = wz[i] - wz[i - 1];
		for(j = 1;j <= c;++j) s += f[j];s %= mo;
		if(a[wz[i]]){
			u = a[wz[i]];
			if(a[wz[i - 1]]){
				v = a[wz[i - 1]];
				for(j = 1;j <= c;++j) if(j != u && (!b[wz[i]] || j == b[wz[i]])){
					if(v == u) tp[j] = (f[j] * g[w][0] + (s - f[j] + mo) * g[w][2]) % mo;
					else if(v == j) tp[j] = (f[u] * g[w][1] + (s - f[u] + mo) * g[w][3]) % mo;
					else tp[j] = (f[u] * g[w][3] + f[j] * g[w][2] + (s - f[u] - f[j] + mo + mo) * g[w][4]) % mo;
				}
			}
			else{
				v = b[wz[i - 1]];
				for(j = 1;j <= c;++j) if(j != u && (!b[wz[i]] || j == b[wz[i]])){
					if(v == u) tp[j] = (f[j] * g[w][1] + (s - f[j] + mo) * g[w][3]) % mo;
					else if(v == j) tp[j] = (f[u] * g[w][0] + (s - f[u] + mo) * g[w][2]) % mo;
					else tp[j] = (f[u] * g[w][2] + f[j] * g[w][3] + (s - f[u] - f[j] + mo + mo) * g[w][4]) % mo;
				}
			}
		}
		else{
			u = b[wz[i]];
			if(a[wz[i - 1]]){
				v = a[wz[i - 1]];
				for(j = 1;j <= c;++j) if(j != u){
					if(v == u) tp[j] = (f[j] * g[w][1] + (s - f[j] + mo) * g[w][3]) % mo;
					else if(v == j) tp[j] = (f[u] * g[w][0] + (s - f[u] + mo) * g[w][2]) % mo;
					else tp[j] = (f[u] * g[w][2] + f[j] * g[w][3] + (s - f[u] - f[j] + mo + mo) * g[w][4]) % mo;
				}
			}
			else{
				v = b[wz[i - 1]];
				for(j = 1;j <= c;++j) if(j != u){
					if(v == u) tp[j] = (f[j] * g[w][0] + (s - f[j] + mo) * g[w][2]) % mo;
					else if(v == j) tp[j] = (f[u] * g[w][1] + (s - f[u] + mo) * g[w][3]) % mo;
					else tp[j] = (f[u] * g[w][3] + f[j] * g[w][2] + (s - f[u] - f[j] + mo + mo) * g[w][4]) % mo;
				}
			}
		}
		for(j = 1;j <= c;++j) f[j] = tp[j],tp[j] = 0;
	}
	li as = 0;
	if(wz[ft] == n) for(i = 1;i <= c;++i) (as += f[i]) %= mo;
	else{
		u = n - wz[ft];
		for(i = 1;i <= c;++i) (as += (g[u][0] + g[u][1] + g[u][2] * (c - 2) * 2 + g[u][3] * (c - 2) * 2 + g[u][4] * (c - 2) % mo * (c - 3)) % mo * f[i]) %= mo;
	}
	print((as % mo + mo) % mo);pc('\n');
	return 0;
}
/*
0:
aa
bb

1:
ab
ba

2:
aa or ac
bc    bb

3:
ab or ac
bc    ba

4:
ac
bd
*/
```

100分代码（线段树）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
inline li read(){
	li x = 0,y = 0,c = gc;
	while(!isdigit(c)) y = c,c = gc;
	while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
	return y == '-' ? -x : x;
}
inline void print(li q){
	if(q < 0) pc('-'),q = -q;
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
const li mo = 1000000009;
li n,c;
int a[100010],b[100010];
int wz[100010],ft;
li f[100010],g[100010][5],tp[100010];
li t[400010],c1[400010],c2[400010],c3[400010];
#define ls q << 1
#define rs q << 1 | 1
#define ln ls,l,mid
#define rn rs,mid + 1,r
#define md int mid = l + r >> 1
inline void build(int q,int l,int r){
	c1[q] = -1;c2[q] = 1;c3[q] = 0;
	if(l == r){
		t[q] = f[l];return;
	}
	md;
	build(ln);build(rn);
	t[q] = (t[ls] + t[rs]) % mo;
}
inline void ud(li x,int op,int q,int l,int r){
	if(op == 1){
		c1[q] = x;c2[q] = 1;c3[q] = 0;t[q] = x * (r - l + 1) % mo;
	}
	else if(op == 2){
		(c2[q] *= x) %= mo;(c3[q] *= x) %= mo;(t[q] *= x) %= mo;
	}
	else{
		(c3[q] += x) %= mo;(t[q] += x * (r - l + 1)) %= mo;
	}
}
inline void ud(li x,int op){ud(x,op,1,1,c);}
inline void ps(int q,int l,int r){
	md;
	if(c1[q] != -1){
		ud(c1[q],1,ln);ud(c1[q],1,rn);c1[q] = -1;
	}
	if(c2[q] != 1){
		ud(c2[q],2,ln);ud(c2[q],2,rn);c2[q] = 1;
	}
	if(c3[q]){
		ud(c3[q],3,ln);ud(c3[q],3,rn);c3[q] = 0;
	}
}
inline void xg(int ax,li x,int op,int q,int l,int r){
	if(l == r){
		ud(x,op,q,l,r);return;
	}
	ps(q,l,r);md;
	if(mid >= ax) xg(ax,x,op,ln);
	else xg(ax,x,op,rn);
	t[q] = (t[ls] + t[rs]) % mo;
}
inline void xg(int ax,li x,int op){xg(ax,x,op,1,1,c);}
inline li cx(int x,int q,int l,int r){
	if(l == r) return t[q];
	ps(q,l,r);md;
	if(mid >= x) return cx(x,ln);
	return cx(x,rn);
}
inline li cx(int x){return cx(x,1,1,c);}
int main(){
	int i,j,u,v,w;
	li s,x,y;
	n = read();c = read();
	for(i = 1;i <= n;++i) a[i] = read();for(i = 1;i <= n;++i) b[i] = read();
	for(i = 1;i <= n;++i){
		if(a[i] || b[i]) wz[++ft] = i;
		if(a[i] && a[i] == b[i]){
			pc('0');pc('\n');return 0;
		}
		if(i < n && ((a[i] && a[i] == a[i + 1]) || (b[i] && b[i] == b[i + 1]))){
			pc('0');pc('\n');return 0;
		}
	}
	if(!ft){
		li as = c * (c - 1) % mo;
		for(i = 2;i <= n;++i) (as *= (c - 1 + (c - 2) * (c - 2) % mo) % mo) %= mo;
		print(as);pc('\n');return 0;
	}
	
	g[1][1] = g[1][3] = g[1][4] = 1;
	for(i = 2;i <= n;++i){
		g[i][0] = (g[i - 1][1] + g[i - 1][3] * (c - 2) * 2 + g[i - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		g[i][1] = (g[i - 1][0] + g[i - 1][2] * (c - 2) * 2 + g[i - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		g[i][2] = (g[i - 1][1] + g[i - 1][2] * (c - 2) + g[i - 1][3] * (c - 2 + c - 3) + g[i - 1][4] * (c - 3) % mo * (c - 3)) % mo;
		g[i][3] = (g[i - 1][0] + g[i - 1][3] * (c - 2) + g[i - 1][2] * (c - 2 + c - 3) + g[i - 1][4] * (c - 3) % mo * (c - 3)) % mo;
		g[i][4] = (g[i - 1][0] + g[i - 1][1] + g[i - 1][2] * (c - 3) * 2 + g[i - 1][3] * (c - 3) * 2 + g[i - 1][4] * (c - 3 + (c - 4) * (c - 4) % mo)) % mo;
	} 
	
	if(wz[1] == 1){
		if(a[1] && b[1]) f[b[1]] = 1;
		else if(a[1]){
			for(i = 1;i <= c;++i) if(i != a[1]) f[i] = 1;
		} 
		else{
			for(i = 1;i <= c;++i) if(i != b[1]) f[i] = 1;
		} 
	}
	else{
		int u = wz[1];
		if(a[u] && b[u]) f[b[u]] = (g[u - 1][0] + g[u - 1][1] + g[u - 1][2] * (c - 2) * 2 + g[u - 1][3] * (c - 2) * 2 + g[u - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		else if(a[u]){
			for(i = 1;i <= c;++i) if(i != a[u]) f[i] = (g[u - 1][0] + g[u - 1][1] + g[u - 1][2] * (c - 2) * 2 + g[u - 1][3] * (c - 2) * 2 + g[u - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		} 
		else{
			for(i = 1;i <= c;++i) if(i != b[u]) f[i] = (g[u - 1][0] + g[u - 1][1] + g[u - 1][2] * (c - 2) * 2 + g[u - 1][3] * (c - 2) * 2 + g[u - 1][4] * (c - 2) % mo * (c - 3)) % mo;
		} 
	}
	build(1,1,c);
	
	for(i = 2;i <= ft;++i){
		w = wz[i] - wz[i - 1];s = t[1];
		if(a[wz[i]] && b[wz[i]]){
			u = a[wz[i]];j = b[wz[i]];x = cx(u);y = cx(j);ud(0,1);
			if(a[wz[i - 1]]){
				v = a[wz[i - 1]];
				if(v == u) xg(j,(y * g[w][0] + (s - y + mo) * g[w][2]) % mo,1);
				else if(v == j) xg(j,(x * g[w][1] + (s - x + mo) * g[w][3]) % mo,1);
				else xg(j,(x * g[w][3] + y * g[w][2] + (s - x - y + mo + mo) * g[w][4]) % mo,1);
			}
			else{
				v = b[wz[i - 1]];
				if(v == u) xg(j,(y * g[w][1] + (s - y + mo) * g[w][3]) % mo,1);
				else if(v == j) xg(j,(x * g[w][0] + (s - x + mo) * g[w][2]) % mo,1);
				else xg(j,(x * g[w][2] + y * g[w][3] + (s - x - y + mo + mo) * g[w][4]) % mo,1);
			}
		}
		else if(a[wz[i]]){
			u = a[wz[i]];x = cx(u);
			if(a[wz[i - 1]]){
				v = a[wz[i - 1]];
				if(v == u){
					ud(g[w][0] - g[w][2] + mo,2);ud(s * g[w][2] % mo,3);
				}
				else{
					ud(g[w][2] - g[w][4] + mo,2);ud((x * g[w][3] + s * g[w][4] - x * g[w][4] % mo + mo) % mo,3);xg(v,(x * g[w][1] + (s - x + mo) * g[w][3]) % mo,1);
				}
			}
			else{
				v = b[wz[i - 1]];
				if(v == u){
					ud(g[w][1] - g[w][3] + mo,2);ud(s * g[w][3] % mo,3);
				}
				else{
					ud(g[w][3] - g[w][4] + mo,2);ud((x * g[w][2] + s * g[w][4] - x * g[w][4] % mo + mo) % mo,3);xg(v,(x * g[w][0] + (s - x + mo) * g[w][2]) % mo,1);
				}
			}
			xg(u,0,1);
		}
		else{
			u = b[wz[i]];x = cx(u);
			if(a[wz[i - 1]]){
				v = a[wz[i - 1]];
				if(v == u){
					ud(g[w][1] - g[w][3] + mo,2);ud(s * g[w][3] % mo,3);
				}
				else{
					ud(g[w][3] - g[w][4] + mo,2);ud((x * g[w][2] + s * g[w][4] - x * g[w][4] % mo + mo) % mo,3);xg(v,(x * g[w][0] + (s - x + mo) * g[w][2]) % mo,1);
				}
			}
			else{
				v = b[wz[i - 1]];
				if(v == u){
					ud(g[w][0] - g[w][2] + mo,2);ud(s * g[w][2] % mo,3);
				}
				else{
					ud(g[w][2] - g[w][4] + mo,2);ud((x * g[w][3] + s * g[w][4] - x * g[w][4] % mo + mo) % mo,3);xg(v,(x * g[w][1] + (s - x + mo) * g[w][3]) % mo,1);
				}
			}
			xg(u,0,1);
		}
	}
	
	for(i = 1;i <= c;++i) f[i] = cx(i);
	li as = 0;
	if(wz[ft] == n) for(i = 1;i <= c;++i) (as += f[i]) %= mo;
	else{
		u = n - wz[ft];
		for(i = 1;i <= c;++i) (as += (g[u][0] + g[u][1] + g[u][2] * (c - 2) * 2 + g[u][3] * (c - 2) * 2 + g[u][4] * (c - 2) % mo * (c - 3)) % mo * f[i]) %= mo;
	}
	print((as % mo + mo) % mo);pc('\n');
	return 0;
}
```

---

## 作者：ღꦿ࿐ (赞：9)

一个可以做到线性的办法。

给你一个 $2\times n$ 的网格图，有些点已经被着色，求这个图的 $c$ 染色方案数。

1. $n,c\leq 10^4$

2. $n,c\leq 10^5$

3. $n,c\leq 10^7$

考虑只有一行怎么做？

$f_{i,j}$ 表示点 $i$ 颜色为 $j$ 的方案数。

把 dp 拍了，只管第二维。

转移每步转移到其他颜色，相当于求全局和 $s$，再将每个元素置为 $(c-1)s - f_i$，再加上一个全局置零。

可以通过 维护一个全局标记 $a_i\gets k a_i +b$，这是可并的，同时维护 $k$ 的逆元，复杂度线性。


很困难的问题就是如果有两行怎么办，很难避免记录两个格子的颜色，如果记录了复杂度完全没办法降低。怎样才能只记录一个格子的颜色呢？

考虑在有一个位置被染色的列断开，进行 dp，这样两个断点之间都是空白的区域，而在断点处有至少一个格子的颜色是确定的，记录另一个即可。

两个断点之间的方案数如何计算？ 

分情况：


```
100..001
a00..00b

100..002
a00..00b

100..00b
a00..002

100..00b
a00..001
```

总共只有四种本质不同的情况，每种情况对于某个 $a$，转移的方案数不同的 $b$ 只有 $O(1)$ 种 ： $b = 1$ 或 $b = 2$ 或 $b = a$。 

这是可以预处理的（因为有意义的颜色只有 $O(1)$ 种），直接记录两个位置的值暴力 dp 与处理出来即可。

这样可以做到 $O(nc)$，还是把 dp 拍了，考虑 $f_i \to f_{i+1}$ 的变化：

有区别的 $a$ 也只有 $O(1)$ 种，其它像其它转移到系数都是相同的，只有转移到自己的系数是不同的。

也就是 除去那 $O(1)$ 个值，剩下的值还是进行的是一个线性变换，令转移到 $b = a$ 的系数是 $s_0$，转移到其它值的系数是 $s_1$，那么就是 $f_i\gets (s_0-s_1)f_i+sum\times s_0$，$sum$ 表示所有不为那 $O(1)$ 个 $a$ 的 $f$ 值之和。

$x\gets kx+b$ 这是一个线性变换，是可并的，维护形如线段树 2 的 tag 即可。

然后这个过程总共还有 $O(n)$ 次单点修改 和 全局清空。

因为不方便修改全局 tag，所以修改当前值，解出 $kx+b=value$ 的 $x$ 赋值即可，所以我们需要保持 $k$ 非 $0$，否则会没有逆元，当 $k=0$ 时直接当作全局清空后赋值为 $k=1$，$b$ 不变即可。 

时间复杂度 $O(n\log mod)$，瓶颈在求逆元。

然后可以用在线 $O(1)$ 科技求逆元。

（那玩意常数太大了，怎么可能。）

考虑缩减求逆元的次数，我们每次乘上去的 $k$ 一定是预处理出来的某种长度的方案数，求出每次的逆元，再维护一个 $k$ 的逆元。

因为不同的长度只会有 $O(\sqrt n)$ 种，所以维护的逆元只有 $O(4 \sqrt n)$ 个。

复杂度线性。




---

## 作者：SDNetFriend (赞：7)

好毒瘤啊好毒瘤啊。

提供一种照搬 T1 的写法，并进一步解释细节。

### 题意这里不再赘述

[P5359 [SDOI2019]染色](https://www.luogu.com.cn/problem/P5359)

### 做法分析

思路几乎同 liuzhangfeiabc 大佬。

即朴素思路依旧考虑状态为 $f_{i,a,b}$ 表示考虑到第 $i$ 列，第一行颜色是 $a$ 第二行是 $b$ 的方案数。但显然这样方案数是 $O(nc^2)$ 的，难以处理，考虑优化。

我们发现转移过程中我们主要需要考虑的是那些填了数的列，没填数的列本质完全相同，也只不过是个数值罢了。那我们可以考虑把状态修改成 $f_{i,a}$ 表示考虑到第 $i$ 列，没填数的位置填了 $a$ 的方案数。对于两行都填的情况会在细节处进一步讨论。

既然状态设出来了吗，考虑转移。我们转移一定是依次考虑每一个填了数的列，那其实只需要考虑：前后两个填了数的列填的数的关系、中间有多少个没填数的列即可。

我们可以发现这个关系不会很多，可以总结成七种关系，有两对本质相同所以共五种本质不同的关系：

```
#0:a..a  #1:a..b  #2:a..a a..c  #3:a..c a..b  #4:a..b
   b..b     b..a     b..c b..b     b..a b..c     c..d
```

其中 `a,b,c,d` 表示了颜色的异同情况。确定了关系之后，再就需要考虑中间有多少空列，然后我们发现系数可以预处理，即设 $g_{i,S}$ 表示中间夹了 $i$ 个空列，两端关系为 $S$ 的转移系数。

那这个东西的预处理是 $O(n)$ 的，然后用上之前的状态时间复杂度便可以达到 $O(nc)$，可以得到 96 分，而满分我们还需要进一步考虑，可能只能观察转移方程，发现实际上我们在对 $f$ 序列进行了：全局加/乘/赋值、单点加/乘/赋值、单点查询、全局查询。然后这个操作几乎和 T1 一样，我这里直接搬过来 T1 的代码改了改就塞到了类里来处理。

当然这个题最毒瘤的地方可能是在于细节巨多。

### 细节讨论

#### 状态设计

首先对于这个状态 $f_{i,a}$，当两行都被填数时我们只需要保证 $a$ 等于第 $2$ 行填的数时有值，否则就全为 $0$ 即可。感觉这是很妙的一步处理，省去了关于前列填数情况的讨论。

#### $g$ 的转移

比较直观，这里举个例子，如 $g_{i-1,3}$ 对于 $g_{i,2}$ 的贡献。我们发现两者都是两种对称的情况，那我们对于其中一个要考虑另外两个情况的贡献。转移实际上就是在考虑这样的情况：（注意最后两列的 `c` 含义不同）

```
a..ca    a..ba
b..ac    b..cc
```

然后考虑贡献我们要假定最后一列的 `a,c` 都已经确定下来，考虑倒数第二列这个自由的 `c` 有多少种情况。然后不难发现第一种情况 `c` 有 $c-2$ 个取值，第二种情况 `c` 有 $c-3$ 个取值，故贡献可以写成 $g_{i,2}+=(c-2+c-3)g_{i-1,3}$。

#### $f$ 的转移

这估计是最麻烦的一部分了。

首先我们考虑 $O(nc)$ 复杂度的转移。首先到了当前位置，我们需要枚举那个没填的颜色（如果当前位置两行都填了那就只考虑第二行的颜色）。

然后把判别分为两类，即当前列哪行填了颜色，前列哪行填了颜色，分成四种情况分别讨论。因为前面 $f$ 对两行都填的情况的处理，导致如果我们发现两行都填就判断填的那行是第一行就可以方便地转移。

然后通过判断我们可以得到当前列和前列两个确定的位置。然后我们再枚举当前列另一个不确定的位置（也有可能是已经确定的，不过按照原来的原则判掉就好了），于是我们发现这两列共四个位置我们已经确定了三个。然后最后一步就是根据已经确定的三个位置来讨论前列不同的不确定位置的贡献。

一般来讲情况是前列如果取某个特定的数是一种情况，不取这个特定的数是另一种情况。那么我们先求出前列所有 $f$ 之和然后从里面减去就可以转移了。

#### 数据结构优化

改成数据结构优化之后，我们会发现如果当前列确定了两个的话，和确定一个的一概而论会比较难搞，于是我们考虑单独判一下当前列确定两个的情况。当然 $f$ 的处理原则并不改变。

然后根据之前 $f$ 的转移式子，观察一下转移就差不多了，只需要单独讨论比如前后两列确定的数一样或者前列确定的数和当前列枚举的不确定数相同的情况即可。

#### 总结

可能是我一直追求代码的简洁，十分反感写太多的分类讨论。但这个题真的给我打回现实。有时分类讨论的好处就是讨论得深了确定的信息就多了，那样方便我们进一步的转移。

### 贴代码

关于码风可能挺奇怪的，我不大喜欢打多余空格，所以有的时候代码长得像砖头（雾）

另外 96 分代码有些诸如没有确定位置和确定位置不合法的特判没有判，但 100 分代码加上去了。

#### 96 分代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define sq(x) ((x)*(x))
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const lint md=1e9+9;
const int N=1e5+5;
struct mint{lint v;};//取模运算封装 
inline mint operator+(mint x,mint y)
	{x.v=((x.v+y.v)%md+md)%md;return x;}
inline mint operator-(mint x,mint y)
	{y.v=-y.v;return x+y;}
inline void operator+=(mint &x,mint y)
	{x=x+y;}
inline mint operator*(mint x,mint y)
	{x.v=x.v*y.v%md;return x;}
inline mint operator*(lint x,mint y)
	{y.v=y.v*x%md;return y;}
inline mint operator+(mint x,lint y)
	{x.v=((x.v+y)%md+md)%md;return x;}
inline mint operator-(mint x,lint y)
	{return x+(-y);}
inline void read(mint &x)
	{x=mint{read()};}
mint c,g[N][5],f[2][N],ans;
int n,a[N][2],tp[N],p[N];
inline void init(){
	g[0][1].v=g[0][3].v=g[0][4].v=1;
	for(int i=1;i<=n;++i){//预处理 g 
		g[i][0]=g[i-1][1]+2*(c-2)*g[i-1][3]+(c-2)*(c-3)*g[i-1][4];
		g[i][1]=g[i-1][0]+2*(c-2)*g[i-1][2]+(c-2)*(c-3)*g[i-1][4];
		g[i][2]=g[i-1][1]+(c-2)*g[i-1][2]+(2*c-5)*g[i-1][3]+sq(c-3)*g[i-1][4];
		g[i][3]=g[i-1][0]+(c-2)*g[i-1][3]+(2*c-5)*g[i-1][2]+sq(c-3)*g[i-1][4];
		g[i][4]=g[i-1][0]+g[i-1][1]+2*(c-3)*(g[i-1][2]+g[i-1][3])+(c-3+sq(c-4))*g[i-1][4];
	}
}
inline void solve(){
	mint *pr,*cu;
	pr=f[0];cu=f[1];//滚动数组+指针 
	lint lst=0;
	for(int i=1;i<=n;++i){
		if(!tp[i])continue;
		lint s=i-lst-1;swap(cu,pr);
		for(int i=0;i<=c.v;++i)
			cu[i].v=0;
		if(!lst){//当前列是第一个有确定数的列的情况 
			if(i==1){//如果当前列是第一列 
				if(tp[i]==1)//如果确定了一个数 
					for(int j=1;j<=c.v;++j)
						{if(j!=a[i][p[i]])cu[j].v=1,++cu[0].v;}
				else cu[a[i][1]].v=cu[0].v=1;
			}else{--s;
				if(tp[i]==1){//如果不是第一列且确定了一个数，这里就考虑第一列会有多少种情况，会产生什么样的贡献 
					int pos=p[i];
					for(int j=1;j<=c.v;++j){
						if(j==a[i][pos])continue;
						cu[j]=g[s][0]+g[s][1]+2*(c-2)*(g[s][2]+g[s][3]);
						cu[j]+=(c-2)*(c-3)*g[s][4];cu[0]+=cu[j];
					}	
				}else{//确定两个数的情况同理 
					cu[a[i][1]]=g[s][0]+g[s][1]+(c-2)*(c-3)*g[s][4];
					cu[a[i][1]]+=2*(c-2)*(g[s][2]+g[s][3]);cu[0]+=cu[a[i][1]];
				}
			}
		}else{
			int x,y;
			for(int z=1;z<=c.v;++z){//分类讨论当前列和前列确定数的位置 
				if(a[i][0]){
					x=a[i][0];if(z==x||(a[i][1]&&z!=a[i][1]))continue;//不满足要求就跳过 
					if(a[lst][0]){y=a[lst][0];
						/* y..x
						   ?..z *///分三种情况讨论 
					 	if(y==x)cu[z]=pr[z]*g[s][0]+(pr[0]-pr[z])*g[s][2];
					 	else if(y==z)cu[z]=pr[x]*g[s][1]+(pr[0]-pr[x])*g[s][3];
						else cu[z]=pr[x]*g[s][3]+pr[z]*g[s][2]+(pr[0]-pr[z]-pr[x])*g[s][4];
						cu[0]+=cu[z];
					}else{y=a[lst][1];
						/* ?..x
						   y..z */
						if(y==x)cu[z]=pr[z]*g[s][1]+(pr[0]-pr[z])*g[s][3];
						else if(y==z)cu[z]=pr[x]*g[s][0]+(pr[0]-pr[x])*g[s][2];
						else cu[z]=pr[x]*g[s][2]+pr[z]*g[s][3]+(pr[0]-pr[x]-pr[z])*g[s][4];
						cu[0]+=cu[z];
					}
				}else{
					x=a[i][1];if(z==x)continue;
					if(a[lst][0]){y=a[lst][0];
						/* y..z
						   ?..x */
						if(y==x)cu[z]=pr[z]*g[s][1]+(pr[0]-pr[z])*g[s][3];
						else if(y==z)cu[z]=pr[x]*g[s][0]+(pr[0]-pr[x])*g[s][2];
						else cu[z]=pr[x]*g[s][2]+pr[z]*g[s][3]+(pr[0]-pr[x]-pr[z])*g[s][4];
						cu[0]+=cu[z];
					}else{y=a[lst][1];
						/* ?..z
						   y..x */
						if(y==x)cu[z]=pr[z]*g[s][0]+(pr[0]-pr[z])*g[s][2];
						else if(y==z)cu[z]=pr[x]*g[s][1]+(pr[0]-pr[x])*g[s][3];
						else cu[z]=pr[x]*g[s][3]+pr[z]*g[s][2]+(pr[0]-pr[x]-pr[z])*g[s][4];                   
						cu[0]+=cu[z];
					}
				}
			}
		}lst=i; 
	}
	if(lst==n)ans=cu[0];
	else{
		lint s=n-lst-1;
		for(int i=1;i<=c.v;++i)//处理最后一个有确定数的列不是n的情况 
			ans+=(g[s][0]+g[s][1]+2*(c-2)*(g[s][2]+g[s][3])+(c-2)*(c-3)*g[s][4])*cu[i];
	}
}
int main(){
	n=read();read(c);
	for(int i=0;i<=1;++i)
		for(int j=1;j<=n;++j)
			a[j][i]=read();
	for(int i=1;i<=n;++i){
		if(!a[i][0]&&!a[i][1])tp[i]=0;
		else if(a[i][0]&&a[i][1])tp[i]=2;
		else tp[i]=1,p[i]=a[i][0]?0:1;
	}init();solve();
	printf("%lld",ans.v);
	return 0;
}
/*
13 13
0 0 2 0 0 1 0 2 0 0 3 0 0
0 0 1 0 1 0 0 0 0 4 0 0 0
*/
```

#### 100 分代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define sq(x) ((x)*(x))
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const lint md=1e9+9;
const int N=1e5+5;
struct mint{lint v;};//取模运算封装 
inline mint operator+(mint x,mint y)
	{x.v=((x.v+y.v)%md+md)%md;return x;}
inline mint operator-(mint x,mint y)
	{y.v=-y.v;return x+y;}
inline void operator+=(mint &x,mint y)
	{x=x+y;}
inline mint operator*(mint x,mint y)
	{x.v=x.v*y.v%md;return x;}
inline void operator*=(mint &x,mint y)
	{x=x*y;}
inline mint operator*(lint x,mint y)
	{y.v=y.v*x%md;return y;}
inline mint operator+(mint x,lint y)
	{x.v=((x.v+y)%md+md)%md;return x;}
inline mint operator-(mint x,lint y)
	{return x+(-y);}
inline void read(mint &x)
	{x=mint{read()};}
mint c,g[N*2][5],ans;
int n,a[N][2],tp[N],p[N],st;
class arr{//搬过来的 T1 
	private:
		int tot,now,tim[N*10],lst[N*10];
		mint sum,atag[N*10],mtag[N*10];
		mint stag[N*10],v[N*10];
		inline lint qpow(lint x,lint y){
			lint res=1;
			while(y){
				if(y&1)res=res*x%md;
				x=x*x%md;y>>=1;
			}return res;
		}
		inline mint inv(lint x)
			{return mint{qpow(x,md-2)};}
		inline mint inv(mint x)
			{return inv(x.v);}
		inline void pushdown(int x){
			if(lst[now]>tim[x])
				v[x]=stag[lst[now]],tim[x]=lst[now];
			mint _mul;
			v[x]*=(_mul=mtag[now]*inv(mtag[tim[x]]));
			v[x]+=atag[now]-atag[tim[x]]*_mul;
			tim[x]=now;
		}
	public:
		arr(){mtag[0].v=1;}
		inline void set(int pos,mint val){
			pushdown(pos);
			sum+=val-v[pos];
			v[pos]=val;
		}
		inline void mul(int pos,mint val){
			pushdown(pos);
			sum+=(val-1)*v[pos];
			v[pos]*=val;
		}
		inline void add(int pos,mint val){
			pushdown(pos);
			sum+=val;v[pos]+=val;
		}
		inline void addall(mint val){
			atag[now+1]=atag[now]+val;
			mtag[now+1]=mtag[now];
			lst[now+1]=lst[now];++now;
			sum+=val*c;
		}
		inline void mulall(mint val){
			if(!val.v){
				++now;sum.v=0;lst[now]=now;
				stag[now].v=0;mtag[now].v=1;
			}else{
				atag[now+1]=atag[now]*val;
				mtag[now+1]=mtag[now]*val;
				lst[now+1]=lst[now];++now;
				sum=sum*val;
			}
		}
		inline void setall(mint val){
			++now;lst[now]=now;
			stag[now]=val;mtag[now].v=1;
			sum=val*c;
		}
		inline mint getv(int pos){
			pushdown(pos);
			return v[pos];
		}
		inline mint gsum()
			{return sum;}
}f;
inline void init(){
	g[0][1].v=g[0][3].v=g[0][4].v=1;
	for(int i=1;i<=n;++i){
		g[i][0]=g[i-1][1]+2*(c-2)*g[i-1][3]+(c-2)*(c-3)*g[i-1][4];
		g[i][1]=g[i-1][0]+2*(c-2)*g[i-1][2]+(c-2)*(c-3)*g[i-1][4];
		g[i][2]=g[i-1][1]+(c-2)*g[i-1][2]+(2*c-5)*g[i-1][3]+sq(c-3)*g[i-1][4];
		g[i][3]=g[i-1][0]+(c-2)*g[i-1][3]+(2*c-5)*g[i-1][2]+sq(c-3)*g[i-1][4];
		g[i][4]=g[i-1][0]+g[i-1][1]+2*(c-3)*(g[i-1][2]+g[i-1][3])+(c-3+sq(c-4))*g[i-1][4];
	}
}
inline void solve(){
	int lst=0;
	for(int i=1;i<=n;++i){
		if(!tp[i])continue;
		int s=i-lst-1;
		if(!lst){
			if(i==1){
				if(tp[i]==1)
					for(int w=1;w<=c.v;++w)
						{if(w!=a[i][p[i]])f.set(w,mint{1});}
				else f.set(a[i][1],mint{1});
			}else{--s;
				if(tp[i]==1){
					int pos=p[i];
					for(int w=1;w<=c.v;++w){
						if(w==a[i][pos])continue;
						f.set(w,g[s][0]+g[s][1]+2*(c-2)*(g[s][2]+g[s][3]));
						f.add(w,(c-2)*(c-3)*g[s][4]);
					}	
				}else{
					f.set(a[i][1],g[s][0]+g[s][1]+(c-2)*(c-3)*g[s][4]);
					f.add(a[i][1],2*(c-2)*(g[s][2]+g[s][3]));
				}
			}
		}else{
			int u,v,w;
			mint sum=f.gsum(),x,y;
			if(tp[i]==2){//特判当前列确定两个的情况 
				u=a[i][0];w=a[i][1];
				x=f.getv(u);y=f.getv(w);
				f.setall(mint{0});
				if(a[lst][0]){
					v=a[lst][0];
					if(v==u)f.set(w,y*g[s][0]+(sum-y)*g[s][2]);
					else if(v==w)f.set(w,x*g[s][1]+(sum-x)*g[s][3]);
					else f.set(w,x*g[s][3]+y*g[s][2]+(sum-x-y)*g[s][4]);
				}else{
					v=a[lst][1];
					if(v==u)f.set(w,y*g[s][1]+(sum-y)*g[s][3]);
					else if(v==w)f.set(w,x*g[s][0]+(sum-x)*g[s][2]);
					else f.set(w,x*g[s][2]+y*g[s][3]+(sum-x-y)*g[s][4]);
				}
			}else if(a[i][0]){
				u=a[i][0];x=f.getv(u);
				if(a[lst][0]){
					v=a[lst][0];
					if(v==u)f.mulall(g[s][0]-g[s][2]),f.addall(sum*g[s][2]);
					else f.mulall(g[s][2]-g[s][4]),f.addall(x*g[s][3]+(sum-x)*g[s][4]),f.set(v,x*g[s][1]+(sum-x)*g[s][3]);                                  
				}else{
					v=a[lst][1];
					if(v==u)f.mulall(g[s][1]-g[s][3]),f.addall(sum*g[s][3]);
					else f.mulall(g[s][3]-g[s][4]),f.addall(x*g[s][2]+(sum-x)*g[s][4]),f.set(v,x*g[s][0]+(sum-x)*g[s][2]);
				}f.set(u,mint{0});
			}else{
				u=a[i][1];x=f.getv(u);
				if(a[lst][0]){
					int v=a[lst][0];
					if(v==u)f.mulall(g[s][1]-g[s][3]),f.addall(sum*g[s][3]);
					else f.mulall(g[s][3]-g[s][4]),f.addall(x*g[s][2]+(sum-x)*g[s][4]),f.set(v,x*g[s][0]+(sum-x)*g[s][2]);
				}else{
					int v=a[lst][1];
					if(v==u)f.mulall(g[s][0]-g[s][2]),f.addall(sum*g[s][2]);
					else f.mulall(g[s][2]-g[s][4]),f.addall(x*g[s][3]+(sum-x)*g[s][4]),f.set(v,x*g[s][1]+(sum-x)*g[s][3]);
				}f.set(u,mint{0});
			}
		}lst=i; 
	}
	if(lst==n)ans=f.gsum();
	else if(!lst){//特判没有确定数的情况 
		lint s=n-2;
		ans=c*(c-1)*(g[s][0]+g[s][1]+2*(c-2)*(g[s][2]+g[s][3])+(c-2)*(c-3)*g[s][4]);
	}else{
		lint s=n-lst-1;
		for(int i=1;i<=c.v;++i)
			ans+=(g[s][0]+g[s][1]+2*(c-2)*(g[s][2]+g[s][3])+(c-2)*(c-3)*g[s][4])*f.getv(i);
	}
}
int main(){st=clock();
	n=read();read(c);
	for(int i=0;i<=1;++i)
		for(int j=1;j<=n;++j)
			a[j][i]=read();
	for(int i=1;i<=n;++i){//特判一定不合法的情况 
		if(a[i][0]&&a[i][1]&&a[i][0]==a[i][1])
			return puts("0"),0;
		if(i<n&&(a[i][0]&&a[i][0]==a[i+1][0]||a[i][1]&&a[i][1]==a[i+1][1]))
			return puts("0"),0;
	}
	for(int i=1;i<=n;++i){
		if(!a[i][0]&&!a[i][1])tp[i]=0;
		else if(a[i][0]&&a[i][1])tp[i]=2;
		else tp[i]=1,p[i]=a[i][0]?0:1;
	}init();solve();
	cout<<ans.v;
	return 0;
}
/*
13 13
0 0 2 0 0 1 0 2 0 0 3 0 0
0 0 1 0 1 0 0 0 0 4 0 0 0
*/
```



---

## 作者：Kevin090228 (赞：3)

### P5359 [SDOI2019] 染色

考虑这样一种情况：格子第一列和最后一列所有颜色已经确定，中间所有格子都未确定。这时本质不同的情况数不多，可以提前预处理答案。情况有 12-34, 12-31, 12-32, 12-12, 12-21 共 $5$ 种。

考虑将所有格子中已经确定一个数和已经全部确定颜色的列拿出来，然后给其中只确定一个数的列确定另外一个数，这玩意显然可以 DP。令 $f(x,c)$ 表示考虑了前 $x$ 段，第 $x$ 段最后没颜色的格子钦定的颜色是 $c$ 的最小代价。

这时我们得到了一个 $O(nc)$ 的做法。注意到这个转移，颜色 $c$ 其实只有至多 $4$ 种不同的等价状态，且其中只有一种状态对应了超过一个 $c$，所以进行一个全局加，和一些单点加即可，查询也只用一些全局查询和一些单点查询。时间复杂度 $O(n)$。

代码长度：很长。

---

## 作者：EuphoricStar (赞：2)

dp 好题。

首先有一个显然的状态，设 $f_{i, x, y}$ 为第 $i$ 列上下两格的颜色分别为 $x, y$ 的方案数。但是这样做时间复杂度至少为 $O(nm^2)$，无法接受。

注意到全 $0$ 列的转移是重复的。我们可以试着只**在两个相邻非全 $0$ 列转移**。这样我们需要预处理全 $0$ 列的转移系数。

我们考虑预处理转移系数时把一段全 $0$ 列的旁边两列的数的**不等关系**记入状态中。一共只会有 $7$ 种本质不同的状态，而其中 $2$ 对状态是等价的，所以实际上只有 $5$ 种状态：

```
0:    1:    2:    3:    4:
a..a  a..b  a..a  a..b  a..b
b..b  b..a  b..c  b..c  c..d
            ----  ----
            a..c  a..c
            b..b  b..a
```

其中相同字母代表的数相同，不同字母代表的数不同。

所以我们设 $g_{i, j}$ 表示一段全 $0$ 列的长度为 $i$，相邻两列的状态为 $j$，全 $0$ 列填法的方案数。

注意到这个东西是可以递推的。以 $g_{i, 4}$ 的转移为例。

若上一列的状态为 $0$：

```
a..ac
b..bd
```

其中 `ab` 之前已经确定，所以转移系数为 $1$；

若上一列的状态为 $1$：

```
a..bc
b..ad
```

转移系数为 $1$；

若上一列的状态为 $2$：

```
a..ac
b..cd

a..cc
b..bd
```

其中上一列的 `c` 还没确定（注意两列的 `c` 不同），两种方案 `c` 都有 $m - 3$ 种方案，所以转移系数为 $2m - 6$。

若上一列的状态为 $3$：

```
a..bc
b..cd

a..cc
b..ad
```

转移系数为 $2m - 6$；

若上一列的状态为 $4$：

```
a..cc
b..dd
```

考虑分类讨论。若上一列的 `c` 等于这一列的 `d`，那么上一列的 `d` 有 $m - 3$ 种取值；否则上一列的 `c`，`d` 各有 $m - 4$ 种取值，因此转移系数为 $(m - 4)^2$。

因此：

$$g_{i, 4} = g_{i - 1, 0} + g_{i - 1, 1} + (2m - 6) g_{i - 1, 2} + (2m - 6) g_{i - 1, 3} + (m - 3 + (m - 4)^2) g_{i - 1, 4}$$

再来考虑相邻非全 $0$ 列的转移。设 $f_{i, j}$ 表示考虑了前 $i$ 列，第 $i$ 列空着的那列填了 $j$ 的方案数（若第 $i$ 列上下都填了数则 $j$ 只在 $a_{i, 1}$ 处有值）。设上一个非全 $0$ 的列为 $k$，$t = i - k - 1$ 表示中间全 $0$ 列的数量。

这里要讨论的情况非常多。以上一个和当前非全 $0$ 列都只有第一行填了数为例。

若两列第一行填的数相同：

```
a..a
?..b
```

此时 $f_{i, j}$ 的 $j$ 代表 `b` 处的值。若 `?` 处的值为 $j$，那么此时的状态为 $0$；若 `?` 处的值不为 $j$，那么此时的状态为 $2$。我们有：

$$f_{i, j} = f_{k, j} g_{t, 0} + \sum\limits_{p \ne j} f_{k, p} g_{t, 2}$$

若设 $s = \sum\limits_{j = 1}^m f_{k, j}$，我们有：

$$f_{i, j} = f_{k, j} g_{t, 0} + (s - f_{k, j}) g_{t, 2}$$

若两列第一行填的数不同，讨论第 $i$ 列第二行填的数与第 $k$ 列第一行填的数是否相同：

```
a..b
?..a

a..b
?..c
```

设 `a` 处的值为 $x$，`b` 处的值为 $y$。我们有：

$$f_{i, x} = f_{k, y} g_{t, 1} + (s - f_{k, y}) g_{t, 3}$$

$$\forall j \ne x, f_{i, j} = f_{k, y} g_{t, 3} + f_{k, j} g_{t, 2} + (s - f_{k, y} - f_{k, j}) g_{t, 4}$$

剩下情况的讨论见代码。

还要讨论前缀全 $0$ 列和后缀全 $0$ 列。前缀全 $0$ 列在初始化 $f$ 数组时讨论。后缀全 $0$ 列给答案乘上一个系数即可。

需要特判全部列都是全 $0$ 列的情况。

考虑优化。发现我们对于 $f$ 数组只会进行全局乘，全局加，单点查，全局查，单点修改的操作。例如 $f_{i, j} = f_{k, j} g_{t, 0} + (s - f_{k, j}) g_{t, 2}$，可以看成是先全局乘 $g_{t, 0} - g_{t, 2}$ 再全局加 $s \times g_{t, 2}$。对于不符合条件的状态赋值 $0$ 可以看成是区间乘 $0$ 操作。

这样我们可以用线段树维护 $f$ 数组。转移进行对应的全局乘和全局加操作即可。

时间复杂度 $O(n \log m)$。但是考虑到全部操作都是全局和单点的操作，所以应该可以仿照[这题](https://www.luogu.com.cn/problem/P5358)的方法优化到 $O(n)$。

下面的代码用线段树实现，保留了一份 $O(nm)$ 暴力供参考。

[code](https://loj.ac/s/1976931)

---

## 作者：naoliaok_lovely (赞：2)

一道不错的 DP 综合题。

## 暴力
注意到如果只有一行非常好做，于是选择把每一列看成一个整体进行 DP。记 $f_{i,j,k}$ 表示前 $i$ 列，对于第 $i$ 列第一行的数为 $j$，第二行的数为 $k$，对应的填色数。于是有 $f_{i,j,k}=\sum f_{i-1,p,q}$，时间复杂度 $O(nc^4)$。虽然这个做法完全不对，但是至少我们已经摸清楚了大概的方向。注意到复杂度的瓶颈在于 $j,k$ 两维，光是状态定义就花了 $c^2$，这是我们根本不能接受的。于是就从这个角度考虑优化这个状态。

## 保留有效列
注意到，设 $cnt$ 表示这一列确定的数的个数。那么对于 $cnt=0$ 的列，我们根本不需要存 $j,k$；同理，对于 $cnt=1$ 的列，我们只需要一维就够了。就是因为可恨的 $cnt=2$ 的那些列，使我们上述的时间复杂度大大增加。注意到，对于这些列，由于他们完全是空白的，所以他们是等价的，完全没有必要放进 DP 里。我们把 $cnt\ge1$ 的列称之为“**有效列**”。

具体的说，我们只去对有效列进行 DP。我们设当前列 $i$ 为有效列，$pos$ 为上一个有效列。$f_{i,j}$ 表示对于有效列 $i$，那个不确定的格子填的数为 $j$ 的方案数。（对于那些两个数都确定的格子，我们可以先假设下面那个是不确定的，同样进行上面的 DP，计算到的时候把所有不为原本数字的 $f_j$ 值改为 $0$ 即可）

> 举例：  
2 0 3  
0 0 5  
这个矩阵，我们可以直接从第一列转移到第三列。转移过程中直接无视元素 $5$，计算到的时候再把 $f_{3,j\ne5}\gets0$ 即可。

## 转移方程
显然有 $f_{i,j}=\sum\limits_{k=1}^cf_{pos,k}\times?$，其中 $?$ 为从第 $pos$ 列转移到 $i$ 列的过程中，中间的 $i-pos-1$ 个空白列由于被我们跳过了，需要重新补上的系数。（因为 $j,k$ 已经确定，也就是说，这 $i-pos-1$ 的前一列和后一列的 $4$ 个方格都处于已填数的状态）注意到下面的事情：

> 对于下面的两个方格：  
5 0 0 0 0 4  
4 0 0 0 0 1  
和  
1 0 0 0 0 7  
7 0 0 0 0 5  
对应的 $?$ 应该是一样的。（应该很显然吧？）

于是我们发现，对于旁边的那 $4$ 个数，在它们的**相等**情况相同的的时候，对应的系数应该是一样的。明显感觉到这个状态不多，考虑枚举，发现共有 $5$ 种状态：

> 设 $a,b,c,d$ 两两不同。  
1.  
a……c  
b……d  
四个都不同。  
2.  
a……b  
b……c  
一个交叉相等。  
3.  
a……a  
b……c  
一个行相等。  
4.  
a……b  
b……a  
两个交叉相等。  
5.  
a……a  
b……b  
两个行相等。

这玩意显然可以预处理啊！设状态 $f_{i,j}$ 表示中间的空白列共 $i$ 列，两端的状态为 $j$，对应的方案数。如果写成矩阵乘法的形式，就是：
$$
\begin{pmatrix}
&m^2-7m+13&2m-6&2m-6&1&1\\
&m^2-6m+9&m-2&2m-5&0&1\\
&m^2-6m+9&2m-5&m-2&1&0\\
&m^2-5m+6&0&2m-4&0&1\\
&m^2-5m+6&2m-4&0&1&0
\end{pmatrix}\times
\begin{pmatrix}
g_{i-1,1}\\
g_{i-1,2}\\
g_{i-1,3}\\
g_{i-1,4}\\
g_{i-1,5}
\end{pmatrix}=
\begin{pmatrix}
g_{i,1}\\
g_{i,2}\\
g_{i,3}\\
g_{i,4}\\
g_{i,5}
\end{pmatrix}
$$  
计算方法相对应该比较简单，这里不过多解释。

回到最开始的式子，就有：
$$f_{i,j}=\sum_{k=1}^cf_{pos,k}\times g_{i-pos-1,t}\quad(t\text{ 表示 }pos\text{ 列取 }k,i\text{ 列取 }j\text{ 对应的状态})$$

时间复杂度 $O(nc^2)$

## 小优化
注意到我们的 DP 转移只与**相等**有关。显然，对于相同的 $i,j,pos$，绝大多数的 $k$ 对应的 $g$ 值都应该是同一个。可以先把总和求出来，减去那些特殊的即可。有人说是前缀和优化，但其实二者本质完全不同。这样即可做到 $O(nc)$，期望得分 $88\texttt{pts}$。

## 开头结尾没有固定
观察从 subtask3 到 subtask4，开头结尾的元素不固定了。我们上面的 DP 只能处理“有效列”，无法处理开头结尾的内容。事实上，这也很好处理，下面举例说明处理方法。

> 对于方格：  
0 0 1 4 0 0 3 0 0 0  
0 0 0 2 0 1 0 0 7 0  
我们可以用上面的方法处理下面为“x”的内容：  
0 0 x x x x x x x 0  
0 0 x x x x x x x 0  
对于剩下的三列，事实上，我们只需让答案乘上一个 $(m^2-3m+3)^3$ 即可。

朴素的，我们让答案乘上 $(m^2-3m+3)^k$（$k$ 为两端空缺的列的数量）。  
只与如何计算而来……方法与上面 $g$ 数组的计算大同小异，这里略过。  
（ps. 对于一个元素也没有的方格需特判）

期望得分 $96\texttt{pts}$。

## 线段树优化 DP
细心的同志已经注意到了，上面提到“对于相同的 $i,j,pos$，绝大多数的 $k$ 对应的 $g$ 值都应该是同一个”，这句话蕴含了巨大的优化空间。其实这句话应该为“对于相同的 $i,pos$，绝大多数的 $j,k$ 对应的 $g$ 值都应该是同一个”。也就是说，我们往 $f_{i,j}$ 作贡献的时候，其实很多贡献都是相同的。这个可以使用线段树进行优化，具体的式子可以见代码。个人认为一篇题解还是应该留下一些内容给读者自己推导的。

实现的时候用线段树维护区间和，区间乘，区间加即可。最开始我们提到，对于 $cnt=2$ 的列，会把所有错误的 $f_{i,j}$ 清空。清空操作只需要区间 $\times0$ 即可。  
（应该没有人会像我一样写 $lazy$ 标记，写到一半发现多余的吧？）

## Code
```
#include<bits/stdc++.h>
using namespace std;
#define LL long long

const int N = 1e5 + 10, mod = 1e9 + 9;
int n, m, w[N][3];
int f[N][10];//不等，一个交叉，一个行，两个交叉，两个行
vector<int> pos;
struct tree
{
	int l, r;
	int sum;
	int mul = 1, add;
}a[N * 4];

LL ksm(LL x, LL y)
{
	LL res = 1;
	x %= mod;
	while(y)
	{
		if(y & 1) res = res * x % mod;
		y >>= 1;
		x = x * x % mod;
	}
	return res;
}

void init()
{
	f[0][1] = f[0][2] = f[0][4] = 1;
	for(int i = 1; i <= n; i++)
	{
		f[i][1] = ((1ll * m * m + 1ll * (mod - 7) * m + 13) % mod * f[i - 1][1]
				+  (2ll * m + mod - 6) % mod * f[i - 1][2]
				+  (2ll * m + mod - 6) % mod * f[i - 1][3]
				+  f[i - 1][4]
				+  f[i - 1][5]) % mod;
		f[i][2] = ((1ll * m * m + 1ll * (mod - 6) * m + 9) % mod * f[i - 1][1]
				+  (1ll * m + mod - 2) % mod * f[i - 1][2]
				+  (2ll * m + mod - 5) % mod * f[i - 1][3]
				+  f[i - 1][5]) % mod;
		f[i][3] = ((1ll * m * m + 1ll * (mod - 6) * m + 9) % mod * f[i - 1][1]
				+  (2ll * m + mod - 5) % mod * f[i - 1][2]
				+  (1ll * m + mod - 2) % mod * f[i - 1][3]
				+  f[i - 1][4]) % mod;
		f[i][4] = ((1ll * m * m + 1ll * (mod - 5) * m + 6) % mod * f[i - 1][1]
				+  (2ll * m + mod - 4) % mod * f[i - 1][3]
				+  f[i - 1][5]) % mod;
		f[i][5] = ((1ll * m * m + 1ll * (mod - 5) * m + 6) % mod * f[i - 1][1]
				+  (2ll * m + mod - 4) % mod * f[i - 1][2]
				+  f[i - 1][4]) % mod;
	}
}

inline void pushup(int p)
{
	a[p].sum = (a[p << 1].sum + a[p << 1 | 1].sum) % mod;
}
inline void pushdown(tree &a, tree &x, tree &y)
{
	if(a.mul != 1)
	{
		x.sum = 1ll * x.sum * a.mul % mod, y.sum = 1ll * y.sum * a.mul % mod;
		x.mul = 1ll * x.mul * a.mul % mod, y.mul = 1ll * y.mul * a.mul % mod;
		x.add = 1ll * x.add * a.mul % mod, y.add = 1ll * y.add * a.mul % mod;
		a.mul = 1;
	}
	if(a.add)
	{
		x.sum = (x.sum + 1ll * (x.r - x.l + 1) * a.add) % mod,
		y.sum = (y.sum + 1ll * (y.r - y.l + 1) * a.add) % mod;
		x.add = (x.add + a.add) % mod, y.add = (y.add + a.add) % mod;
		a.add = 0;
	}
}
inline void pushdown(int p)
{
	pushdown(a[p], a[p << 1], a[p << 1 | 1]);
}

void maketree(int p, int l, int r)
{
	a[p].l = l, a[p].r = r;
	if(l != r)
	{
		int mid = l + r >> 1;
		maketree(p << 1, l, mid);
		maketree(p << 1 | 1, mid + 1, r);
	}
}

void modify(int p, int l, int r, int mul, int add)
{
	if(l > r) return;
	if(l <= a[p].l && a[p].r <= r)
	{
		a[p].sum = (1ll * a[p].sum * mul + 1ll * (a[p].r - a[p].l + 1) * add) % mod,
		a[p].mul = 1ll * a[p].mul * mul % mod, a[p].add = (1ll * a[p].add * mul + add) % mod;
		return;
	}
	
	pushdown(p);
	int mid = a[p].l + a[p].r >> 1;
	if(l <= mid) modify(p << 1, l, r, mul, add);
	if(r > mid) modify(p << 1 | 1, l, r, mul, add);
	pushup(p);
}

int getsum(int p, int x)
{
	if(a[p].l == a[p].r)
		return a[p].sum;
	
	pushdown(p);
	int mid = a[p].l + a[p].r >> 1;
	if(x <= mid) return getsum(p << 1, x);
	else return getsum(p << 1 | 1, x);
}

void work1(int x, int y, int g[])//交叉
{
	if(x == y)
		modify(1, 1, m, (g[4] - g[2] + mod) % mod, 1ll * a[1].sum * g[2] % mod);
	else
	{
		int t = (1ll * a[1].sum * g[3] + 1ll * getsum(1, y) * (g[5] - g[3] + mod)) % mod;
		modify(1, 1, m, (g[2] - g[1] + mod) % mod, (1ll * a[1].sum * g[1] + 1ll * getsum(1, y) * (g[3] - g[1] + mod)) % mod);
		modify(1, x, x, 0, t);
	}
}

void work2(int x, int y, int g[])//同行
{
	if(x == y)
		modify(1, 1, m, (g[5] - g[3] + mod) % mod, 1ll * a[1].sum * g[3] % mod);
	else
	{
		int t = (1ll *a[1].sum * g[2] + 1ll * getsum(1, y) * (g[4] - g[2] + mod)) % mod;
		modify(1, 1, m, (g[3] - g[1] + mod) % mod, (1ll * a[1].sum * g[1] + 1ll * getsum(1, y) * (g[2] - g[1] + mod)) % mod);
		modify(1, x, x, 0, t);
	}
}

int main()
{
	cin >> n >> m;
	init();
	
	for(int j = 1; j <= 2; j++)
		for(int i = 1; i <= n; i++)
			scanf("%d", &w[i][j]);
	for(int i = 1; i <= n; i++)
		if(w[i][1] || w[i][2])
		{
			if(w[i][1] == w[i][2]) return puts("0"), 0;
			pos.push_back(i);
		}
	if(pos.empty())
	{
		cout << ksm(1ll * m * m + 1ll * (mod - 3) * m + 3, n - 1) * m % mod * (m - 1) % mod << endl;
		return 0;
	}
	
	maketree(1, 1, m);
	if(w[pos[0]][1])
	{
		if(w[pos[0]][2])
			modify(1, w[pos[0]][2], w[pos[0]][2], 1, 1);
		else 
			modify(1, 1, w[pos[0]][1] - 1, 1, 1), modify(1, w[pos[0]][1] + 1, m, 1, 1);
	}
	else
		modify(1, 1, w[pos[0]][2] - 1, 1, 1), modify(1, w[pos[0]][2] + 1, m, 1, 1);
	
	for(int i = 1; i < pos.size(); i++)
	{
		int p = pos[i - 1], x = pos[i], *g = f[x - p - 1];
		if(w[x][1])
		{
			if(w[p][1]) work2(w[p][1], w[x][1], g);
			else work1(w[p][2], w[x][1], g);
			modify(1, w[x][1], w[x][1], 0, 0);
			if(w[x][2]) modify(1, 1, w[x][2] - 1, 0, 0), modify(1, w[x][2] + 1, m, 0, 0);
		}
		else
		{
			if(w[p][1]) work1(w[p][1], w[x][2], g);
			else work2(w[p][2], w[x][2], g);
			modify(1, w[x][2], w[x][2], 0, 0);
		}
	}
	
	cout << a[1].sum * ksm(1ll * m * m + 1ll * (mod - 3) * m + 3, pos[0] - 1 + n - pos.back()) % mod << endl;
	return 0;
}
```

---


# [SDOI2019] 连续子序列

## 题目描述

我们定义 $\textbf{T. M.}$ 序列$\{T_n\}$为如下形式得布尔序列：

- $T_0=0$；
- $T_{2n}=T_n$;
- $T_{2n+1}=1-T_n$。

这里我们给出$\textbf{T. M.}$序列得前若干项：$01101001100101101001011001101001\cdots$。

$\textbf{T. M.}$序列是一个无限长度的序列，它有很多连续子序列。
 例如$0$，$1$，$10100$，$10011$和$011001$都是它的连续子序列，然而$111$和$1000$却不是它的连续子序列。

现在给定一个布尔序列（01字符串）$S$和一个非负整数$k$，请统计一下一共有多少种$\textbf{T. M.}$序列的连续子序列$T$满足：

- $S$是$T$的前缀；

- $T$是由$S$额外在右侧添加了恰好$k$项形成的。

## 说明/提示

子任务$1$：（$20$分）$1\le T\le 100$，给定布尔序列长度不超过$100$，且$0\le k\le 100$。

子任务$2$：（$20$分）$1\le T\le 100$，给定布尔序列长度不超过$100$，且$0\le k\le 50000$。

子任务$3$：（$60$分）$1\le T\le 100$，给定布尔序列长度不超过$100$，且$0\le k\le 10^{18}$

## 样例 #1

### 输入

```
5
1001 3
11001 10
00111 10
0011 20
0 100```

### 输出

```
3
4
0
6
164```

# 题解

## 作者：QiFeng233 (赞：21)

# 【题解】[SDOI2019]连续子序列

> 一道不错的找规律题

> **UPDATE on 2020.3.11：修复了炸了的LaTex，修正了几处小笔误使得叙述更加清晰明了**

## 题意简述

定义$T.M.$序列$\{T_n\}$为如下形式的01序列：

$
\begin{cases}
T_0=0\\
T_{2n}=T_n\\
T_{2n+1}=1-T_n
\end{cases}
$

给定一个01序列$S$和一个正整数$k$，要求统计有多少不同的$T.M.$序列的连续子序列$T$满足：

- $S$是$T$的前缀
- $T$是$S$在右侧恰好添加了$k$项形成的。

答案对$10^9+9$取模。

## 思路详解

根据这个构造方式，我们第一眼能看出的是，每一次在扩大$T.M.$序列的规模的时候，都是当前的$T.M.$序列取反后接在右边。比如说`0110`->`01101001`。

但是这个构造方式仍然过于复杂，不太好处理。注意到数据范围，$k \leq 10^{18}$，这个数据范围，不是$\Theta(1)$就是$\Theta(\log_2k)$，但是$\Theta(1)$显然是不太现实的，考虑$\Theta(\log_2k)$做法，要求我们每次能够把问题规模缩小一半，但是上述的构造方式只对于长度为$2^x,x \in N$的连续子序列起作用。这个时候我们的目标就转化为了找到一种方法能够将任意连续子序列的规模缩小一半，并且能够还原一开始的子序列。

考虑另外一种构造方式：每一次扩大$T.M.$子序列，就是往每个0后边加一个1，往每个1后边加一个0。根据这种构造方法不难看出，任意一个合法的连续子序列里边连续的1或者0的个数都$\leq 2$。考虑找到一个01字符串，它扩大后得到$S$，那么进行分类讨论：

- $|S|$为偶数，那么有两种方案：

  - 把S每两位字符分为一组，然后`01`->`0`，`10`->`1`。注意如果某一组是`11`或者`00`，那这种方式行不通。
  - 把S从$S_2$到$S_{|S|-1}$每两位字符分为一组，然后`01`->`0`，`10`->`1`。注意如果某一组是`11`或者`00`，那这种方式行不通。

  可以证明，对于$\forall S$，若有解，则有且仅有一种方式有解。注意$|S|=2$时仅能用方案一。

- $|S|$为奇数，那么有两种方案：

  - 把S从$S_1$到$S_{|S|-1}$每两位字符分为一组，然后`01`->`0`，`10`->`1`。注意如果某一组是`11`或者`00`，那这种方式行不通。
  - 把S从$S_2$到$S_{|S|}$每两位字符分为一组，然后`01`->`0`，`10`->`1`。注意如果某一组是`11`或者`00`，那这种方式行不通。注意在这种方式下，找到的字符串第一位是$S_1xor1$。

  可以证明，对于$|S|>3$，若有解，则有且仅有一种方式有解。

我们记当前操作得到的字符串是$\frac{S}{2}$，$f(S,k)$代表当前01串为$S$，往后加$k$位得到的不同的连续子序列个数，则容易得到$f(S,k)$的递归计算方法。

然后$f(S,k)$用map存（不然还有啥能存的下啊）。

最后口胡一下，时间复杂度$\Theta(T(|S|+\log_2k))$

## 代码时间

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<string,ll> var;
int t;
const ll mod=1e9+9; 
string s;
ll k;
map<var,ll> f; 
namespace QiFeng233{
	ll calc(string s,ll k){
		if(s.size()==1){
			if(k==0||k==1||k==2)return k+1;
		}else if(s.size()==2){
			if(k==0)return 1;
			if(k==1)return s[0]==s[1]?1:2;
		}else if(s.size()==3){
			if(k==0)return s[0]!=s[1]||s[1]!=s[2];
		}
		var v=make_pair(s,k);
		if(f.count(v))return f[v];
		string nxt;
		ll ans=0;
		bool successful=true;
		for(int i=0;i<(int)s.size();i+=2){
			if(i<(int)s.size()-1&&s[i]==s[i+1]){
				successful=false;
				break;
			}
			nxt+=s[i];
		}
		if(successful)ans+=calc(nxt,s.size()%2?(k>>1):((k+1)>>1)),ans%=mod;
		nxt=s[0]^1;
		successful=true;
		for(int i=1;i<(int)s.size();i+=2){
			if(i<(int)s.size()-1&&s[i]==s[i+1]){
				successful=false;
				break;
			}
			nxt+=s[i];
		}
		if(successful)ans+=calc(nxt,s.size()%2?((k+1)>>1):(k>>1)),ans%=mod;
		return f[v]=ans;
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>t;
	while(t--)cin>>s>>k,cout<<QiFeng233::calc(s,k)%mod<<endl;
	return 0;
}
```

## 反思总结

- 思维题往往不需要多少算法知识，这题就只用了基础算法——分治。
- 思维题要求能跳出思维定势，灵活思考。就像这题，如果不能想到上文提到的构造方式而只是照着题目给你的构造方式死刚，是不会有结果的。
- 面向数据编程，就像看到$k \leq 10^{18}$就能想到$\Theta(1)$或者$\Theta(\log_2k)$从而想出正解。
- 这个$T.M.$序列全名Thue−Morse序列。仔细一想，好像我以前见过它几次，但是我没一次做出来了/kk
- 这题模数是$10^9+9$，但我一开始模了$10^9+7$/kk

---

## 作者：liuzhangfeiabc (赞：11)

题目大意：有一个01串tm，满足tm(0)=0，tm(i)=tm(i>>1)^(i&1)。给定01串s和整数k，问有多少个本质不同的01串t满足：t是tm的子串，s是t的前缀，t的长度是|s|+k。

全场无人ac的找规律神题。

关于tm序列，有很多种解释方式，比如每个数的二进制中1的个数的奇偶性啦，从0开始每次把自身取反接在后面啦等等。对于这个题，最好的解释方式是这样的：

从0开始，每次把所有的0变成01，把所有的1变成10。

为什么这样解释最好呢？因为我们可以试着把一个tm的子串用这种方式变换回去：

假设一个串s=abcdefg

我们可以把它每2位划分为一段，即ab|cd|ef|g或a|bc|de|fg，然后把每一段按上述规则合并为一个字符。

如果某一段内两个字符相同，意味着这样划分是不合法的。

两侧也许有落单的段，但是根据规则实际上与它们成一段的另一个字符是确定的，我们也可以将其补上。

比如串10100110010，就可以切割为10|10|01|10|01|0，然后合并成110100。

可以验证：当串长>3时，合法的切割方案是唯一的。比如串1001，就只能划分为10|01,而串1010看似可以划分为1|01|0，但是由于这样缩成的是000因此不合法，所以唯一的划分方案是10|10。

因此我们就可以通过对切割方案的计数来实现对串的计数。设f(s,k)表示当前串为s，后面接k个字符的方案数。当|s|+k<=3时特判，否则枚举2种划分方案，对于合法的方案进行递归操作。用个map对状态进行记忆化即可。

本质不同的状态数大约只有O(|s|+logk)级别，可以通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
int t;
string s;
li k;
#define psi pair<string,li>
#define fi first
#define se second
#define mp make_pair
map<psi,li> mm;
const int mo = 1000000009;
inline li wk(psi p){
	if(p.fi.size() == 1){
		if(!p.se) return 1;
		if(p.se == 1) return 2; 
		if(p.se == 2) return 3;
	}
	if(p.fi.size() == 2){
		if(!p.se) return 1;
		if(p.se == 1) return (p.fi[0] == p.fi[1] ? 1 : 2);
	} 
	if(p.fi.size() == 3 && !p.se) return (p.fi[0] == p.fi[1] && p.fi[1] == p.fi[2] ? 0 : 1);
	if(mm.find(p) != mm.end()) return mm[p];
	li as = 0;
	int i;
	bool fg = 1;
	string nxt;
	nxt.clear();
	for(i = 0;i < p.fi.size();i += 2){
		if(i == p.fi.size() - 1) nxt += p.fi[i];
		else if(p.fi[i] == p.fi[i + 1]){
			fg = 0;break;
		}
		else nxt += p.fi[i];
	} 
	if(fg) as += wk(mp(nxt,(p.fi.size() % 2 ? (p.se >> 1) : (p.se + 1 >> 1))));
	fg = 1;nxt.clear();
	nxt += (p.fi[0] ^ 1);
	for(i = 1;i < p.fi.size();i += 2){
		if(i == p.fi.size() - 1) nxt += p.fi[i];
		else if(p.fi[i] == p.fi[i + 1]){
			fg = 0;break;
		}
		else nxt += p.fi[i];
	} 
	if(fg) as += wk(mp(nxt,(p.fi.size() % 2 ? (p.se + 1 >> 1) : (p.se >> 1))));
	return mm[p] = as;
}
int main(){
	cin>>t;
	while(t--){
		cin>>s>>k;
		cout<<wk(mp(s,k)) % mo<<endl;
	}
	return 0;
}
```

---

## 作者：yllcm (赞：4)

找规律题，提供一个更加好想但是复杂度稍劣的做法。下文约定 $\text{ppc}(x)$ 表示 $x$ 二进制下 $1$ 的个数，$\text{ctz}(x)$ 表示末尾 $0$ 的个数。

首先注意到 $T_i=\text{ppc}(i)\bmod 2$。

先考虑判断什么串是合法的。设当前数为 $x$，若将 $x\gets x+1$，观察 $x$ 的 popcount 的变化，可以发现 $+1$ 进位之后，会消去 $x$ 末尾连续的 $1$，然后加上一个 $1$。形式地刻画：

> 观察 $1$：$T_i\oplus T_{i-1}=\text{ctz}(i)\bmod 2$。

如果你打了一个表可以发现 $T_i\oplus T_{i-1}$ 是有周期性的，根据上述观察不难说明。故我们令 $d_i=T_{i}\oplus T_{i-1}$，此时只要在 $d_i$ 中匹配。我们说明在 $d_i$ 中匹配和原问题是等价的：

> 观察 $2$：对于串 $s$，定义 $s'$ 表示 $s$ 按位取反后的结果，则 $s$ 在 T.M. 序列中出现等价于 $s'$ 在 T.M. 序列出现。

证明即考虑 T.M. 序列的一种生成方式：生成 $T_{0\sim 2^k-1}$，然后令 $T_{0,2^{k+1}-1}=T_{0,2^k-1}+T_{0,2^k-1}'$。故 $s$ 一定被按位取反之后接在了后面。故 $s_0$ 的取值并不重要，我们只需要关注其差分数组。

然而由于原序列是无穷的，所以字符串匹配的位置可能很远。我们给出两个结论说明子序列第一次出现的位置并不会很远：

> 观察 $3$：假设匹配的位置为 $[l,l+|s|-1]$，假设 $\text{argmax}_{i=l}^{l+|s|-1}\text{ctz}(i)=t2^k$，则把对应位置调整到 $2^k$ 得到的序列和原序列等价。
>
> 观察 $4$：假设匹配的位置为 $[l,l+|s|-1]$，假设 $\text{argmax}_{i=l}^{l+|s|-1}\text{ctz}(i)=2^k$，则若 $2^k-2^{\frac{k}{4}}\notin[l,l+|s|-1]\land 2^k+2^{\frac{k}{4}}\notin[l,l+|s|-1]$，则把对应位置调整到 $2^{\frac{k}{4}}$ 得到的序列和原序列等价（前提是调整后匹配区间仍然在范围内）。

理解上述结论只需要注意到：若确定了 $\text{argmax}_{i=l}^{l+|s|-1}\text{ctz}(i)$，则序列可以被唯一确定。这是因为假设 $k=\max \text{ctz}(i)$，则若我们在模 $2^k$ 意义下讨论问题，则 $\text{ctz}(i)\bmod 2$ 的信息被完全包含。同样地，若 $2^{k}\to 2^{\frac{k}{4}}$ 时没有出现更大的 $\text{ctz}$ 被包括在匹配位置中，那么奇偶性仍然是相同的。

根据上述讨论，经过不断调整之后，匹配的范围被缩小到 $4(n+k-1)$ 范围内，更为精确的，假设 $t=\lfloor\log_2(n+k-1)\rfloor$，则匹配的范围可以被缩小到为 $[1,2^{t+2}]$。

但是范围仍然可能很大，我们需要进一步观察。令 $x=n+k-1$，先观察哪些起点 $l$ 对应的串 $[l,l+x-1]$ 是第一次出现，我们直接给出结论：

> 观察 $5$：起点区间恰好在 $[1,2^{t}-2^{t-2}]\cup[32^{t-1}-x+1,2^t]\cup [2^{t+1}-x+1,2^{t+1}-2^{t-1}]$。

证明：考虑~~打表~~。对于区间以外的位置一定能通过调整找到更早的出现位置。

所以问题直接转化为了在这些区间里面找到 $s$ 的差分数组的出现次数。根据上面的结论，我们只需要枚举 $s$ 跨过位置的 $\max _i\text{ctz}(i)$ 的值，暴力枚举起点暴力匹配即可。时间复杂度 $\mathcal{O}(T|s|^2\log k)$。

[参考代码](https://loj.ac/s/1783013)

从考虑如何把可行范围缩小到有限到观察可行匹配位置再进行匹配，整个过程还是比较自然的。

---

## 作者：hhoppitree (赞：2)

#### 题意简述

定义 $\text{TM}$ 数列 $T$ 为通过如下递归式得到的 $\texttt{01}$ 字符串（下标从 $0$ 开始）：

- $T_0=0$；
- $T_{2n}=T_n$；
- $T_{2n+1}=1-T_n$。

给定一个 $\texttt{01}$ 字符串 $S$ 和一个非负整数 $k$，求有多少种 $\text{TM}$ 字符串的连续子串 $T$ 满足 $S$ 为 $T$ 的前缀且 $|T|=|S|+k$。

**多组询问。**对于 $20\%$ 的数据，满足 $k\le100$；   
对于 $40\%$ 的数据，满足 $1\le k\le5\times10^4$。   
对于全部数据，$T\le100$，$|S|\le100$，$k\le10^{18}$。   

#### 题目解法

先来考虑 $k=0$ 的情况，即判断 $S$ 是否为 $\text{TM}$ 字符串的子串。

发现题目中的 $\text{TM}$ 字符串其实就是 $\text{Thue}-\text{Morse}$ 数列，考虑 $\text{Thue}-\text{Morse}$ 的以下三种生成方式：

- 每个数二进制表达中的 $1$ 的个数的奇偶性；
- 从 $\texttt{0}$ 开始，每次将自身取反后接在后面；
- 从 $\texttt{0}$ 开始，每次将所有的 $\texttt{0}$ 替换为 $\texttt{01}$，将所有的 $\texttt{1}$ 替换成 $\texttt{10}$。

发现，第三种生成方式比较适合此题，因为对于一个 $\text{TM}$ 的子串而言，此操作是**可逆的**。

考虑一个串 $S=s_1s_2\cdots s_n$，我们可以把它每两位划分为一段，然后按照上述第三种生成方式合并为一个字符，如果某一段内两个字符相同，则意味着这样划分是不合法的。

如果两侧有落单的段，则可以依据规则推理出对应的另一个字符，也可以将其补上。

可以证明，当 $|S|>3$ 时，**合法的合并方案是唯一的**，因此可以通过对合并方案的计数来实现对串的计数。

设 $f(S,k)$ 为当前字符串为满足 $S$ 为 $T$ 的前缀且 $|T|=|S|+k$ 的 $\text{TM}$ 字符串的连续子串 $T$ 的种类数，则当 $|S|+k>3$ 时可以直接枚举两种可能的划分方案**递归计算**，其间可以**使用哈希表进行记忆化搜索**。

发现本质不同的状态数为 $\mathcal{O}(|S|+\log k)$ 级别，可以通过本题。

#### 总结

关于这类递归生成数列的问题可以换种生成方式考虑，有时可以取得意想不到的效果，平时可以记忆一些常见递归数列的其它生成方式。

---

## 作者：QWQcoding (赞：0)

感觉很神秘的找规律题，属于是不容易找到规律，但找到以后就不难。

本篇题解较其他题解相比给出了更具体的证明。

原题中给出的 $\textbf{T. M.}$ 序列构造方式为：初始为 $0$ ，每次在当前序列后添加当前序列取反后的结果。

我们断言，$\textbf{T. M.}$ 序列可以通过如下另一种形式构造：

- 初始为 $0$
- 每次将当前序列所有的 $0$ 用 $01$ 替代，所有的 $1$ 用 $10$ 替代。

考虑归纳，即当前序列为 $AB$ ，其中 $B$ 是 $A$ 的取反，则进行一次操作后应变为 $ABBA$ （由原题面给出的构造方式易得）。

由于 $A$ 可通过新操作得到 $AB$ （归纳假设），则由 $A$ 与 $B$ 对称知，$B$ 可通过新操作得到 $BA$ 。则将序列 $AB$ 进行一次新操作后会得到 $AB$ 与 $BA$ 拼接后的结果，即 $ABBA$。

断言得证。

通过新的构造方式，我们能够更容易地将序列 $S$ 归约到子问题 $S'$，从而得到答案。同时可以发现， $\textbf{T. M.}$ 序列中不存在连续三项相同。

分类讨论：

![6152595fbbfaa7e09a3ae84cd576a045](https://cdn.luogu.com.cn/upload/image_hosting/t2nt26pl.png)

这幅图似乎已经很直接地体现了如何规约到子问题，其中要求相邻配对的两位为 $01$ 或 $10$ 。

使用记忆化搜索，$f(S,k)$ 表示字符串 $S$ 后添加 $k$ 位的答案。如上图所示进行递归计算即可。总时间复杂度 $O(T(|S|+\log_2k))$。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T;
map<pair<string,ll>,ll> f;
const ll MOD=1e9+9;
inline ll F(string s,ll k){
	if(s.size()==1&&k<=2) return k+1;
	if(s.size()==2){
		if(k==0) return 1;
		if(k==1&&s[0]==s[1]) return 1;
		if(k==1) return 2;
	}
	if(s.size()==3&&k==0){
		return s[0]!=s[1]||s[1]!=s[2];
	}
	if(f.count(make_pair(s,k))){
		return f[make_pair(s,k)];
	}
	ll res=0;
	if(s.size()%2==0){
		string sp="";
		bool flag1=1;
		for(ll i=0;i<s.size();i+=2){
			if(s[i]==s[i+1]){
				flag1=0;
				break;
			}
			sp+=s[i];
		}
		if(flag1){
			res+=F(sp,(k+1)/2);
		}
		flag1=1;
		sp="";
		if(s[0]=='1') sp="0";
		else sp="1";
		for(ll i=1;i<s.size();i+=2){
			if(s[i]==s[i+1]){
				flag1=0;
				break;
			}
			sp+=s[i];
		}
		if(flag1){
			res+=F(sp,k/2);
		}
	}
	else{
		bool flag1=1;
		string sp="";
		for(ll i=0;i<s.size();i+=2){
			if(s[i]==s[i+1]){
				flag1=0;
				break;
			}
			sp+=s[i];
		}
		if(flag1){
			res+=F(sp,k/2);
		}
		flag1=1;
		sp="";
		if(s[0]=='1') sp="0";
		else sp="1";
		for(ll i=1;i<s.size();i+=2){
			if(s[i]==s[i+1]){
				flag1=0;
				break;
			}
			sp+=s[i];
		}
		if(flag1){
			res+=F(sp,(k+1)/2);
		}
	}
	res%=MOD;
	return f[make_pair(s,k)]=res;
}
void solve(){
	string s;
	ll k;
	cin>>s>>k;
	cout<<F(s,k)<<"\n";
}
int main(){
	ios::sync_with_stdio(false);
	cin>>T;
	while(T--){
		solve();
	}
	return 0;
}
```

---


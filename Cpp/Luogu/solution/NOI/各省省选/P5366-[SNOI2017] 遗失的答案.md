# [SNOI2017] 遗失的答案

## 题目描述

小皮球在计算出答案之后，买了一堆皮肤，他心里很开心，但是一不小心，就忘记自己买了哪些皮肤了。= =|||

万幸的是，他还记得他把所有皮肤按照 $1 \sim \text{N}$ 来编号，他买来的那些皮肤的编号（他至少买了一款皮肤），最大公约数是 $\text{G}$，最小公倍数是 $\text{L}$。

现在，有 $\text{Q}$ 组询问，每组询问输入一个数字 $\text{X}$，请你告诉小皮球，有多少种合法的购买方案中，购买了皮肤 $\text{X}$？

因为答案太大了，所以你只需要输出答案 $\bmod{10^9+7}$ 即可。

## 说明/提示

$\text{30}\%$ 的数据：$\text{N} \le 20$

$\text{50}\%$ 的数据：$\text{N} \le 1000$

$\text{70}\%$ 的数据：$\text{N} \le 100000$

$\text{100}\%$ 的数据：$\text{N, G, L} \le 10^8, \text{Q} \le 10^5, 1 \le \text{X} \le 10^8$



## 样例 #1

### 输入

```
5 1 30
5
1 2 3 4 5```

### 输出

```
1
2
2
0
2```

# 题解

## 作者：ViXbob (赞：15)

[滋磁去我的博客看啊](http://www.vixbob-lwc.pw/2019/05/16/SNOI2017/)

妙妙题..

首先判掉$L$不是$G$的倍数的情况.

然后先来考虑一下没有一定要包含$X$的这个限制的情况:

对于$L$的每个质因子$p_i$,设$\text{MxP}(p_i,x)=k(p_i^k\mid x,p_i^{k+1}\not\mid x)$;

设$m$为$L$不同的质因子的个数.

我就是要选出来一些数使得对于每个质因子$p_i$,至少存在一个数$x$使得$\text{MxP}(p_i,x)=\text{MxP}(p_i,L)$, 至少存在一个数$y$使得$\text{MxP}(p_i,x)=\text{MxP}(p_i,G)$.

那么我们把每个数都看成一个长为$2m$的$01$串,记录它对于每一个质因子$p_i$,是否满足$\text{MxP}(p_i,x)=\text{MxP}(p_i,L)$, 或满足$\text{MxP}(p_i,x)=\text{MxP}(p_i,G)$.

那么我们最后就是要找若干个数使得它们或出来是一个长为$2m$的全是$1$的串.因为$m \le 8$,这道题就变得可做多了.

然后这个是可以$\text{FWT}$的.对于$X$的限制,记一个前后缀$\text{FWT}$的结果就好了,但是复杂度不太对.

我们可以考虑容斥:

我就是要求找出来一些数使它们或为全集,设:$f(S)$表示或出来为$S$的方案数,
$$g(S)=\sum_{T\subseteq S}f(T)$$
那么$g(S)=2^{con(S)}$($con(S)$为$S$的子集的个数).然后这个就可以直接子集反演了:
$$f(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}g(T)$$
再考虑一下有$X$的限制.就是我们或出来的只能是$X$的超集.设$f(S)$表示或出来的数为$S$并且一定选中了$X$的方案数.这里的$g(S)$和上述的含义一样.只是$g(S)=[X\subseteq S]2^{con(S)-1}$.减一就是我们去掉没选$X$的这种情况.然后容斥和上面是一样的.

虽然询问有很多但是不同的$01$状态只有$2^{2m}$,并且我们每次容斥时只用枚举$X$的超集就好了,所以复杂度为$O(3^{2m})$.($m\le 8$)

代码:
```cpp
/*
 * 2257.cpp
 * This file is part of 2257
 *
 * Copyright (C) 2019 - ViXbob
 *
 * 2257 is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * 2257 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with 2257. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * There is no end though there is a start in space. ---Infinity.
 * It has own power, it ruins, and it goes though there is a start also in the star. ---Finite.
 * Only the person who was wisdom can read the most foolish one from the history.
 * The fish that lives in the sea doesn't know the world in the land.
 * It also ruins and goes if they have wisdom.
 * It is funnier that man exceeds the speed of light than fish start living in the land.
 * It can be said that this is an final ultimatum from the god to the people who can fight.
 *
 * Steins;Gate
 */
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define dep(i, j, k) for(int i = j; i >= k; --i)
#define SIZE(x) ((int)x.size())
#define mp(x, y) make_pair(x, y)
#define pb(x) push_back(x)

typedef long long ll;
typedef unsigned long long ull;

using namespace std;

const int maxn = 1e5 + 5;
const int P = 1e9 + 7;
const int inf = 0x3f3f3f3f;

int n, G, L, Q, x, pow2[maxn], U, l[maxn], r[maxn], siz[maxn], N, ans[1 << 17];
vector<pair<int, int> > facL, data;

inline int read() {
	char ch = getchar(); int u = 0, f = 1;
	while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar(); }
	while(isdigit(ch))  { u = u * 10 + ch - 48; ch = getchar(); } return u * f;
}

inline int pls(int x, int y) { x += y; return x >= P ? x - P : x; }
inline int dec(int x, int y) { x -= y; return x < 0 ? x + P : x; }

inline void GetFac(int x, vector<pair<int, int> > &fac) {
	for(int i = 2; i * i <= x; i++) if(x % i == 0) {
		int cnt = 0;
		while(x % i == 0) x /= i, cnt++;
		fac.pb(mp(i, cnt));
	}
	if(x != 1) fac.pb(mp(x, 1));
}

inline void Binout(int S) {
	stack<int> st;
	while(S) st.push(S & 1), S >>= 1;
	rep(i, 1, N - st.size()) putchar('0');
	while(st.size()) putchar(st.top() + '0'), st.pop();
	putchar('\n');
}

inline pair<int, int> GetState(int x) {
	int S = 0, y = x;
//	cerr << "------------------------" << endl;
//	cerr << "x = " << x << endl;
	rep(i, 0, SIZE(facL) - 1) {
		int cnt = 0;
		while(x % facL[i].first == 0) x /= facL[i].first, cnt++;
		S |= (cnt == l[i]) << i;
		S |= (cnt == r[i]) << i + SIZE(facL);
	}
//	Binout(S);
	return mp(y, S);
}

inline void PreSolve() {
	GetFac(L, facL);
	pow2[0] = 1; N = SIZE(facL) << 1; U = (1 << N) - 1;
	rep(i, 1, U) pow2[i] = pls(pow2[i - 1], pow2[i - 1]);
	rep(i, 0, SIZE(facL) - 1) {
		r[i] = facL[i].second;
		int x = G;
		while(x % facL[i].first == 0) l[i]++, x /= facL[i].first;
	}
//	rep(i, 0, SIZE(facL) - 1) cerr << "l[" << i << "] = " << l[i] << ", r[" << i << "] = " << r[i] << endl;
	for(int i = 1; 1ll * i * i <= L; i++) if(L % i == 0) {
		if(i % G == 0 && i <= n) data.pb(GetState(i));
		if(i * i != L && (L / i) % G == 0 && (L / i) <= n) data.pb(GetState(L / i));
	}
	sort(data.begin(), data.end());
	for(auto v : data) siz[v.second]++;
	rep(i, 0, N - 1) rep(S, 0, U) if(S >> i & 1) siz[S] += siz[S ^ (1 << i)];
//	rep(S, 0, U) cerr << "size[" << S << "] = " << siz[S] << endl;
}

inline int Solve(int x, int rnt = 0) {
	auto it = *lower_bound(data.begin(), data.end(), mp(x, 0));
	if(ans[it.second] != -1) return ans[it.second];
	int T = it.second, S = U ^ T; rnt = __builtin_popcount(T) & 1 ? dec(rnt, pow2[siz[T] - 1]) : pow2[siz[T] - 1];
	for(int S1 = S; S1; S1 = (S1 - 1) & S) 
		if(__builtin_popcount(S1 | T) & 1) rnt = dec(rnt, pow2[siz[S1 | T] - 1]);
		else rnt = pls(rnt, pow2[siz[S1 | T] - 1]);
	return ans[it.second] = rnt;
}

int main() {
//	freopen("1.in", "r", stdin);
//	freopen("my.out", "w", stdout);
	n = read(); G = read(); L = read(); Q = read();
	if(L % G) { rep(i, 1, Q) puts("0"); return 0; }
	PreSolve();
	memset(ans, -1, sizeof(ans));
	rep(i, 1, Q) {
		x = read();
		if(x % G != 0 || L % x != 0 || x > n) puts("0");
		else printf("%d\n", Solve(x));
	}
	return 0;
}
/*
2 * 3 * 5
1 2 3 4 5
1
2
2
0
2
*/
```



---

## 作者：嘉然小姐的狗 (赞：13)

提供一个不用 FWT 的题解。

#### 思路
记 $\operatorname{ind}_p(x)$ 表示 $x$ 的质因数分解中 $p$ 的个数，即 $\operatorname{ind}_p(x) = \min\{k:p^k | x\}$。

将 $G, L$ 质因数分解，然后可以转化为：选出若干数 $\{a_k\}$，使得对于任意质数 $p$，都有 $\min\{\operatorname{ind}_p(a_i)\} = \operatorname{ind}_p(G), \max\{\operatorname{ind}_p(a_i)\} = \operatorname{ind}_p(L)$。

显然直接容斥即可。

* 加上满足 $\operatorname{ind}_p(a_i) \in [\operatorname{ind}_p(G), \operatorname{ind}_p(L)]$；
* 减去满足 $\operatorname{ind}_p(a_i) \in [\operatorname{ind}_p(G) + 1, \operatorname{ind}_p(L)]$；
* 减去满足 $\operatorname{ind}_p(a_i) \in [\operatorname{ind}_p(G), \operatorname{ind}_p(L) - 1]$；
* 加上满足 $\operatorname{ind}_p(a_i) \in [\operatorname{ind}_p(G) + 1, \operatorname{ind}_p(L) - 1]$；

若满足此限制的有 $\text{tot}$ 个数，则方案数为 $2^{\text{tot}}$。

设 $c_k(L)$ 表示 $L$ 质因数分解中次数为 $k$ 的质因子个数，则复杂度的一个上界为 $2^{c_1(L)}3^{c_2(L)}4^{c_3(L) + c_4(L) + \ldots} \leq d(L) \leq 576$。因此，每次计算容斥情况是 $O(d(L))$ 的。

#### 实现
预处理时，对所有满足 $G|x|L$ 的 $x$ 都统计其会在哪些容斥条件中产生贡献，计入计数数组 $\text{tot}[S]$（这里 $S$ 表示容斥条件限制，用四进制状压储存）。由于 $L \leq 10^8$，所以 $L$ 的质因子个数不超过 $8$，$S < 4^8 = 65536$。

询问时，对每个询问都按照上面的容斥方法搜一遍（注意必须保证 $x$ 被选择），利用 $\text{tot}[S]$ 容斥计算贡献即可。

时间复杂度：$O(\sqrt L + qd(L) + d^2(L))$。

#### 代码
```cpp
#include <cstdio>

const int MOD = 1e9 + 7;
const int N = 2000;

int n, g, l, q;
int p[9], cl[9], cr[9], pn;
int cnt[1 << 16];
int POW2[N];
int ans;

void dfs(int pos, int x, int f) { // 预处理
    int cur = 0;

    if (pos > pn) {
        cnt[f]++;
        return;
    }

    while (!(x % p[pos])) {
        cur++;
        x /= p[pos];
    }
    dfs(pos + 1, x, f << 2);
    if (cl[pos] < cur)
        dfs(pos + 1, x, f << 2 | 1);
    if (cur < cr[pos])
        dfs(pos + 1, x, f << 2 | 2);
    if (cl[pos] < cur and cur < cr[pos])
        dfs(pos + 1, x, f << 2 | 3);
}
void solve(int pos, int x, int f, int neg) { // 求解
    int cur = 0;

    if (pos > pn) {
        ans = (ans + neg * POW2[cnt[f] - 1]) % MOD;
        return;
    }

    while (!(x % p[pos])) {
        cur++;
        x /= p[pos];
    }
    solve(pos + 1, x, f << 2, neg);
    if (cl[pos] < cur)
        solve(pos + 1, x, f << 2 | 1, -neg);
    if (cur < cr[pos])
        solve(pos + 1, x, f << 2 | 2, -neg);
    if (cl[pos] < cur and cur < cr[pos])
        solve(pos + 1, x, f << 2 | 3, neg);
}

void init() {
    int i, g0, l0;

    g0 = g;
    l0 = l;
    for (i = 2; i * i <= l0; i++) {
        if (!(l0 % i)) {
            pn++;
            p[pn] = i;
            while (!(l0 % i)) {
                cr[pn]++;
                l0 /= i;
            }
            while (!(g0 % i)) {
                cl[pn]++;
                g0 /= i;
            }
        }
    }

    if (l0 > 1) {
        pn++;
        p[pn] = l0;
        cr[pn] = 1;
        cl[pn] = !(g0 % l0);
    }

    for (i = 1; i * i <= l; i++) {
        if (!(l % i)) {
            if (!(i % g) and i <= n)
                dfs(1, i, 0);
            if (!((l / i) % g) and i * i < l and l / i <= n)
                dfs(1, l / i, 0);
        }
    }
}

int main() {
    int i, x;

    scanf("%d %d %d %d", &n, &g, &l, &q);

    POW2[0] = 1;
    for (i = 1; i < N; i++) POW2[i] = 2 * POW2[i - 1] % MOD;

    init();
    for (i = 1; i <= q; i++) {
        scanf("%d", &x);
        ans = 0;
        if (x <= n and !(l % x) and !(x % g))
            solve(1, x, 0, 1);
        printf("%d\n", (ans + MOD) % MOD);
    }

    return 0;
}
```

---

## 作者：Prean (赞：13)

第一次看见这题的时候觉得挺牛逼的，然后想了半个小时发现其实还是挺简单（

首先：$A=\max_{n=1}^{10^8}\sigma(n)=768,B=\max_{n=1}^{10^8}\omega(n)=8$。

首先 $G,L$ 都没啥必要，因为可以变成 $1,n$。

那么 $X/G$ 只能是 $n$ 的因数。问题变成了在 $n$ 的因数中钦定某个数必选，然后要使 $\gcd=1,\operatorname{lcm}=n$。

观察一下可以知道 $\gcd,\operatorname{lcm}$ 都是套在表面上的。设 $n=\prod p_i^{k_i}$，把每个数状压一下，设这个数为 $\prod P_i^{K_i}$，第 $i$ 位为 $0$ 表示 $0<K_i<k_i$，$2$ 表示 $K_i=k_i$，$1$ 表示 $K_i=0$。然后设 $f_{S1,S2}$ 表示选择一部分数，其 $\gcd$ 的状态为 $S1$，$\operatorname{lcm}$ 的状态为 $S2$ 的方案数。

然后这玩意儿看上去像是在对“是否拥有一个完整的 $p_i^{k_i}$”做 Or 背包的同时对“是否完全不包含 $p_i$”做一个 Or 背包。如果不钦定是可以做到 $A4^B$ 的。

注意到这个 $A4^B$ 的代价我们是可以接受的。所以我们考虑做一个“逆元”的操作，把钦定的数字从其中删去，这个时候得到的相当于是钦定这个数不选的结果。然后用之前的减去这个结果就行了。（就是用所有方案数减去强行删掉这个数后的方案数）

这玩意儿好像不太可做。但是好像把 $S1,S2$ 拼接在一起到一起是没问题的。。。

所以重新设状态，$f_{S1\times 2^k+S2}$ 表示上面的 $f_{S1,S2}$。

然后这里就是纯纯 Or 卷积了。并且可以发现逆元是将这个数做 FWT 后所有位置取逆元，能够发现显然是 $2^{-1}$。

需要注意的是要以点值形式保存，然后做一个子集反演（等价于一次 IFWT）。复杂度是单次 $O(4^B)$,可以接受。

不过嘛，可以考虑计算每一个数对最开始背包的贡献。做一个子集和差不多了。

复杂度 $O(A4^B)$。

然后我们发现一件事：

统计不包含某个数的方案数时，实际上是将超集全部除以了 $2$。

然后使用最开始的值减去这一部分，就只剩下了超集的部分除以 $2$。

由于我们是每次做 IFWT 后取在 $0$ 处的位置，等价于每个数带了一个权值。

于是全部除以 $2$ 后做一个超集求和即可。复杂度是十分优秀的 $O(B4^B+A)$。
```cpp
#include<cstdio>
#include<cctype>
typedef unsigned ui;
const ui M=1<<8,mod=1e9+7,inv2=500000004;
ui Q,G,L,X,N,pw2[1024];ui m,p[10],k[10],t[10];double invG,x[10],y[10];ui f[M*M];bool ppc[M*M];
char _INPUT[1<<21|1],_OUTPUT[1<<21|1],*_P1=_INPUT,*_P2=_OUTPUT;
inline void DFS(const ui&id,const ui&S1,const ui&S2,ui x){
	if(id==m)return void(++f[S1<<m|S2]);
	for(ui i=0;x<=N&&i<=k[id];x*=p[id],++i)DFS(id+1,S1|(i==k[id])<<id,S2|(i==0)<<id,x);
}
inline void Divide(ui N){
	for(ui i=2;i*i<=N;++i)if(!(N%i)){
		p[m]=i;while(!(N%i))++k[m],N/=i;++m;
	}
	if(N^1)p[m]=N,k[m]=1,++m;
	for(ui i=m-1;~i;--i){
		x[i]=1./p[i]+1e-15;t[i]=y[i]=1;for(ui j=1;j<=k[i];++j)y[i]*=x[i],t[i]*=p[i];
	}
}
inline ui read(){
	ui n(0);char s;while(!isdigit(s=*_P1++));while(n=n*10+(s&15),isdigit(s=*_P1++));return n;
}
inline void write(ui n){
	static char s[10];ui top(0);while(s[++top]=n%10^48,n/=10);while(*_P2++=s[top],--top);*_P2++=10;
}
signed main(){
	fread(_INPUT,1,1<<21,stdin);
	N=read();G=read();L=read();Q=read();invG=1./G+1e-15;
	if(L%G){
		while(Q--)putchar(48),putchar(10);return 0;
	}
	N*=invG;L*=invG;Divide(L);DFS(0,0,0,1);pw2[0]=1;for(ui i=1;i^1024;++i)pw2[i]=2*pw2[i-1]%mod;
	const ui&M=1<<m*2;
	for(ui len=1;len^M;len<<=1)for(ui k=0;k^M;k+=len<<1)for(ui i=0;i^len;++i)f[i|k|len]+=f[i|k];
	for(ui S=0;S^M;++S)f[S]&&--f[S],f[S]=S&&(ppc[S]=ppc[S>>1]^(S&1))?mod-pw2[f[S]]:pw2[f[S]];
	for(ui len=1;len^M;len<<=1)for(ui k=0;k^M;k+=len<<1)for(ui i=0;i^len;++i)f[i|k]=(f[i|k]+f[i|k|len])%mod;
	while(Q--){
		X=read();
		if(ui(X*invG)*G^X){
			*_P2++=48;*_P2++=10;continue;
		}
		if(X*=invG,L%X||X>N){
			*_P2++=48;*_P2++=10;continue;
		}
		ui S1(0),S2(0);
		for(ui i=0;i^m;++i)S1|=(ui(X*y[i])*t[i]==X)<<i,S2|=(ui(X*x[i])*p[i]!=X)<<i;
		write(f[S1<<m|S2]);continue;
	}
	fwrite(_OUTPUT,1,_P2-_OUTPUT,stdout);
}
```

---

## 作者：Vision271 (赞：9)

* 本篇题解给出了一种既不基于各种数论变换（好像实质上还是基于但是可以按 dp 理解），也不基于容斥的解法。

### 题意
* 已知在 $1\sim N$ 间选了至少一个数，给出这些数的最大公约数 $G$，最小公倍数 $L$。

* 回答 $Q$ 组询问，内容为有多少种方案选了 $x$。

### 数据范围
* $N,G,L,x\leqslant 10^8$，$Q\leqslant 10^5$。

* 题面未保证 $G\mid L$，但在实际数据中，$G\mid L$。

### 解析
#### 0.题意转化
* 首先，容易看出对于 $G\nmid x$ 或 $x\nmid L$，$x$ 是不可能被选上的。

* 从而考虑令 $n=\dfrac{N}{G},g=\dfrac{G}{G},l=\dfrac{L}{G}$。当然，实际数据肯定有 $G=1$ 的情况。

* 由 $\gcd$ 与 $\operatorname{lcm}$ 的本质（$\gcd=\prod p^{\min(k_1,k_2,\dots)},\operatorname{lcm}=\prod p^{\max(k_1,k_2,\dots)}$），容易想到对 $l$ 做质因数分解。

* 记 $\omega(x)$ 为 $x$ 的质因数个数，$d(x)$ 为 $x$ 的约数个数，$t_i$ 表示 $l$ 中第 $i$ 个质因数的次数。

* 手动打表发现，对于 $l\leqslant 10^8$，有 $\omega(l)\leqslant 8$，$d(l)\leqslant 768$。

* 显然这是在要我们状压。考虑令 $sta1$ 表示当前是否有对应质因数次数为 $0$ 的因数（即向下顶满，使 $g=1$），$sta2$ 表示对应质因数次数是否恰为 $t_i$（即向上顶满，使 $l=l$（意会一下））。

#### 1.dp 设计
* 容易想到如下 dp：

* 令 $\mathit{dp}_ {i,sta1,sta2}$ 表示当前已经考虑完了前 $i$ 个 $l$ 的约数（非约数不可能被选上，注意 $>n$ 的也不可能被选上），后两维含义参上，的总方案数。

* 初始化很显然，$\mathit{dp}_ {0,0,0}=1$。

* 考虑到状态似乎比较稀疏而且我就是不想写状态转移方程，我们来写一下递推转移式。记 $f_i$ 为第 $i$ 个约数。

* $\mathit{dp}_ {i,sta1,sta2}\rightarrow \mathit{dp}_ {i+1,sta1,sta2},\mathit{dp}_ {i,sta1,sta2}\rightarrow \mathit{dp}_ {i+1,sta1|sta1_{f_{i+1}},sta2|sta2_{f_{i+1}}}$，转移系数均为 $1$。

* 其中 $sta1_{f_{i+1}}$ 之类的表示 $f_{i+1}$ 对 $sta$ 的影响,显然容易预处理出，故转移 $O(1)$。状态数为 $d(l)\times 2^{2\omega(l)}\approx 5\times 10^7$，还算能接受。

* 但我们无法回答询问：看起来这个 dp 只能每次暴力钦定必选某个跑一遍，T 的无药可救。

#### 2.针对询问的 dp 修正
* 考虑一种惯用手法：正反（指从前向后和从后向前）做两遍 dp。从而询问 $f_i$（不是约数的询问的答案显然是 $0$）时可以暴力枚举左右进行配对。

* 然而配对显然不可做（$2^{4\omega(l)}$），考虑只枚举一边。

* 枚举左边之后容易得到左边与 $f_i$ 的影响或上后所缺的 $sta$，从而问题转化为了对右边的反向 dp 求一个 $sta$ 的超集和，为了方便我们肯定是把两个 $sta$ 压到一起了。

* 很遗憾我不会 FWT，也不会 FMT，所以我们来一个稍微乱搞一点的做法（似乎本质还是 FMT）。

* 把整个反向 dp 的结果在 $sta$ 上取反，把所缺的 $sta$ 也取反。从而我们现在是要求一个 $sta$ 的子集和。

* 显然暴力枚举子集和刚才的复杂度一样，往递推之类的方向思考。
* 考虑这样一种 dp 来求子集和：

* 定义 $\mathit{sum}_ {i,sta}$ 为考虑了前（认为位权为 $1$ 的位最靠前）$i$ 位可以与当前的 $sta$ 不同的所有子集的和，注意这个做法没考虑它自己（没有任何一位不一样），得特判（其实就是初始化）。

* 容易看出，当 $sta$ 第 $i$ 位为 $0$ 时，$\mathit{sum}_ {i,sta}=\mathit{sum}_ {i-1,sta}$。

* 当 $sta$ 第 $i$ 位不为 $0$ 时，可以分类讨论。
	* 首先强制该位为 $1$，则同上（两者都相当于该位没有变，所以同上）。
   * 然后强制该位为 $0$，打表后~~大眼硬瞪~~仔细观察可以发现，强制该位为 $0$ 的方案数恰好就是 $\mathit{sum}_ {i-1,sta\bigoplus 2^i}$。
   * 实质即强制该位为 $0$ 后可以递归求解（当然没有必要真的递归）。

* 更进一步地，容易看出这个 dp 可以直接压维，毕竟该轮被用到的不会在该轮被更新。于是初始化显然。

* 算一下复杂度。单次求 $sum$ 为 $O(2\omega(l)\times 2^{2\omega(l)}\approx 1\times 10^6)$，考虑上极限情况下要求 $d(l)$ 次，复杂度上界大约为 $8\times 10^8$。

* 乍一看也没什么，可若以普遍理性而论，确实是 T 了？

* 不是的。首先时限是 $2s$，然后作为复杂度瓶颈的求 $sum$ 主要是加法和位运算（手动取模），实际常数并不大，实测最大点 $360ms$ 跑的飞起，诶嘿。

### 示范代码

```cpp
#include<bits/stdc++.h>
#define il inline
#define ri register
#define For(i,a,b) for(ri int i=(a);i<=(b);++i)
#define foR(i,a,b) for(ri int i=(a);i>=(b);--i)
#define uint unsigned int
#define ll long long
#define ull unsigned long long
#define b_s basic_string
#define u_map unordered_map
#define pii pair<int,int>
#define m_p make_pair
#define fir first
#define sec second
#define nsync ios::sync_with_stdio(0),cin.tie(0)
#define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
il ll rd(){
	ll x=0;bool f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=0;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?x:-x;
}
char wtst[66];
int wtps;
il void wt(ll x){
	if(x<0) putchar('-'),x=-x;
	while(x>9) wtst[++wtps]=(x%10+'0'),x/=10;
	wtst[++wtps]=x+'0';
	while(wtps) putchar(wtst[wtps--]);
}
il void wtk(ll x){wt(x);putchar(' ');}
il void wth(ll x){wt(x);putchar('\n');}

const int maxp=1e4+7,usep=1e4;
bitset<maxp> np;
int p[maxp],nump;
il void euler(){
	np[0]=np[1]=1;
	For(i,2,usep){
		if(!np[i]) p[++nump]=i;
		for(ri int j=1;j<=nump && i*p[j]<=usep;++j){
			np[i*p[j]]=1;
			if(!(i%p[j])) break;
		}
	}
}

int N,G,L;
int usen,useg,usel;

int pf[9],numpf,numpf2;//prime factor
int lt[9];
int full;

const int maxf=769;
struct factor{
	int v,sta;
	bool operator<(const factor &b)const{return v<b.v;}
}f[maxf];
int numf;
u_map<int,short> refl;
il void init(){
	N=rd(),G=rd(),L=rd();
	usen=N/G,usel=L/G,useg=G/G;
	//基本读入
	
	euler();
	int nowl=usel,t=0;
	For(i,1,nump){
		while(!(nowl%p[i])) ++t,nowl/=p[i];
		if(t) pf[++numpf]=p[i],lt[numpf]=t,t=0;
	}
	if(nowl>1) pf[++numpf]=nowl,lt[numpf]=1;//注意这里是从 1 开始存的，实际使用中必须减 1 
	numpf2=(numpf<<1),full=(1<<numpf2)-1;
	//对 L 质因数分解

	int usei,tnow[9];
	for(ri int i=1;i*i<=usel && i<=usen;++i)
		if(!(usel%i)){
			usei=i; mem(tnow,0);
			f[++numf].v=usei;
			For(j,1,numpf){
				while(!(usei%pf[j])) ++tnow[j],usei/=pf[j];
				f[numf].sta=f[numf].sta|((!tnow[j])<<(numpf2-j))|((tnow[j]==lt[j])<<(numpf-j));
			}
			
			usei=usel/i; 
			if(usei==i || usei>usen) continue;
			f[++numf].v=usei;
			For(j,1,numpf){
				tnow[j]=lt[j]-tnow[j];
				f[numf].sta=f[numf].sta|((!tnow[j])<<(numpf2-j))|((tnow[j]==lt[j])<<(numpf-j));
			}
		}
	sort(f+1,f+1+numf);
	For(i,1,numf) refl[f[i].v]=i;
	//生成所有约数 
}

const int lim=(1<<16),mod=1e9+7;//够不到 
int dpf[maxf][lim],dpb[maxf][lim];//ll 根本开不开，必须步步模 //f 从左向右，b 从右向左 
bitset<lim> vis;
il void add(int &a,int b){a=a+b; if(a>=mod) a=a-mod;}//大胆一点。 
il void DP(){
	dpf[0][0]=1;
	For(i,0,numf-1)
		For(sta,0,full)
			if(dpf[i][sta]){
				add(dpf[i+1][sta],dpf[i][sta]);
				add(dpf[i+1][sta|f[i+1].sta],dpf[i][sta]);
			}
	//正向
	
	dpb[numf+1][0]=1;
	foR(i,numf+1,2)
		For(sta,0,full)
			if(dpb[i][sta]){
				add(dpb[i-1][sta],dpb[i][sta]);
				add(dpb[i-1][sta|f[i-1].sta],dpb[i][sta]);
			}
	//反向 
}

int ans[maxf];
int sum[maxf][lim];
il void work(){
	int stanow;
	for(ri int l=0,i=1,r=2;i<=numf;++l,++i,++r){
		if(r<=numf) For(sta,0,full) sum[r][sta]=dpb[r][full^sta];
		else sum[r][full]=1;
		For(j,0,numpf2-1)
			For(sta,0,full)
				if(sta&(1<<j))
					add(sum[r][sta],sum[r][sta^(1<<j)]);
		
		For(sta,0,full)
			if(dpf[l][sta]){
				stanow=(sta|f[i].sta);
//				fsta=(stanow^full);//取两遍反，相当于没取 
				add(ans[i],1ll*dpf[l][sta]*sum[r][stanow]%mod);
			}
	}
}

il void answer(){
	int Q=rd(),x;
	while(Q--){
		x=rd();
		if(x%G || L%x){wth(0); continue;}
		x=x/G;
		wth(ans[refl[x]]);
	}
}

int main(){
	init();
	DP();
	work();
	answer();
	return 0;
}
```

---

## 作者：寄风 (赞：6)

## 废话
妙妙题。

今天 CSP-S 联考，毒瘤出题人说为了防止 AK，在 T4 放了这题，然鹅对面学校还是有 3 人 AK 了，反倒是我们这边，没有一个人 AC。

因为我并不会 FWT，所以十分感谢[这篇题解](https://www.luogu.com.cn/blog/moonoshawott/solution-p5366)给我带来的启发。
## 正文

首先对于每组询问，可以直接特判掉 $x > n$ 或 $G \nmid X$ 或 $X \nmid L$ 的情况。

考虑想象一个 $cnt$ 函数，$cnt_{x,p}$ 代表在 $x$ 的质因数分解中 $p$ 的指数（也就是几次方）。然后套路质因数分解 $G$ 和 $L$，对于每个能整除 $L$ 的质数 $p$，这两个数的 $cnt$ 都比较好算，直接用 $\sqrt{L}$ 的时间预处理出来就行了，同时还可以预处理 $L$ 的质因数分解形式。

在质因数分解完后，问题就可以转化为以下形式：

请您在 $1$ 到 $n$ 之间选出若干个数 $k$，使其对于 $L$ 的任意一个质因子 $p$，满足 $\min \{ cnt_{k , p} \} = cnt_{G , p}$ 且 $\max \{ cnt_{k , p} \} = cnt_{L , p}$。

套路容斥，对于 $L$ 的每一个质因子 $p$，定义一个 $tot$ 变量，进行以下操作：

- $tot$ 加上 $\sum_{i = 1} ^ n (cnt_{i,p} \in [cnt_{G,p},cnt_{L,p}])$；
- $tot$ 减去 $\sum_{i = 1} ^ n (cnt_{i,p} \in [cnt_{G,p}+1,cnt_{L,p}])$；
- $tot$ 减去 $\sum_{i = 1} ^ n (cnt_{i,p} \in [cnt_{G,p},cnt_{L,p}-1])$；
- $tot$ 加上 $\sum_{i = 1} ^ n (cnt_{i,p} \in [cnt_{G,p}+1,cnt_{L,p}-1])$；

最后答案加上 $2 ^ {tot-1}$ 就行了。

补充：为什么要加上 $2 ^ {tot-1}$:

可以发现容斥后 $tot$ 代表的是能选几个数进来而不冲突，然后显然这些数构成了一个子集，在这里面，$x$ 是必须要选的，剩下的 $tot-1$ 个数都有选和不选两种状态，显然就是在一个集合里统计子集的数目，所以显然有 $2 ^ {tot-1}$ 个子集，也就是 $2 ^ {tot - 1}$ 种情况。

然后对于每一个 $x$，记录它满足容斥的哪些条件，然后因为不超过十个从小到大的质数相乘就会超过 $10^8$，所以复杂度是没问题的。

然后因为质数个数极少，可以直接把四种容斥的条件分别编号为 $0$、$1$、$2$、$3$，然后用四进制压缩状态，开一个数组来存这个 $tot$。这个预处理出来就行了。

最后每次询问直接搜一遍状态就可以了。

注意开 `long long`。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n , g , l , q , x , cntn , cntl[105] , cntg[105] , p[105] , cnt[1000005] , ans , base2[100005]; 
const int mod = 1e9 + 7;
inline void jia(int &x , int y){
	x += y;
	if(x > mod) x -= mod;
}
inline void notjia(int &x , int y){
	x -= y;
	if(x < 0) x += mod;
}
inline int ksm(int a , int b , int mod){
    int res = 1 , base = a % mod;
    while(b){
    	if(b & 1) res = res * base % mod;
    	base = base * base % mod;
    	b >>= 1;
	}
	return res;
}
inline void dfs(int step , int now , int tmp){
	if(step > cntn){
		cnt[tmp]++;
		return ;
	}
	int tot = 0;
	if(now % p[step] == 0){
		while(now % p[step] == 0){
			tot++;
			now /= p[step];
		}
	}
	if(cntg[step] <= tot && tot <= cntl[step]){
		dfs(step + 1 , now , tmp * 4);
	}
	if(cntg[step] <= tot && tot < cntl[step]){
		dfs(step + 1 , now , tmp * 4 + 1);
	}
	if(cntg[step] < tot && tot <= cntl[step]){
		dfs(step + 1 , now , tmp * 4 + 2);
	}
	if(cntg[step] < tot && tot < cntl[step]){
		dfs(step + 1 , now , tmp * 4 + 3);
	}
}
inline void dfs2(int step , int now , int tmp , int f = 1){
	if(step > cntn){
		if(f == 1){
			jia(ans , base2[cnt[tmp] - 1]);
		}
		else{
			notjia(ans , base2[cnt[tmp] - 1]);
		}
		return ;
	}
	int tot = 0;
	if(now % p[step] == 0){
		while(now % p[step] == 0){
			tot++;
			now /= p[step];
		}
	}
	if(cntg[step] <= tot && tot <= cntl[step]){
		dfs2(step + 1 , now , tmp * 4 , f);
	}
	if(cntg[step] <= tot && tot < cntl[step]){
		dfs2(step + 1 , now , tmp * 4 + 1 , f * -1);
	}
	if(cntg[step] < tot && tot <= cntl[step]){
		dfs2(step + 1 , now , tmp * 4 + 2 , f * -1);
	}
	if(cntg[step] < tot && tot < cntl[step]){
		dfs2(step + 1 , now , tmp * 4 + 3 , f);
	}
}

signed main(){
	cin >> n >> g >> l >> q;
	int gg = g , ll = l;
	base2[0] = 1;
	for(int i = 1;i <= 10000;i++) base2[i] = base2[i - 1] * 2 % mod;
	for(int i = 2;i * i <= l;i++){
		if(ll % i == 0){
			p[++cntn] = i;
			while(ll % i == 0){
				cntl[cntn]++;
				ll /= i;
			}
			while(gg % i == 0){
				cntg[cntn]++;
				gg /= i;
			}
		}
	}
	if(ll - 1 > 0) p[++cntn] = ll , cntl[cntn]++ , cntg[cntn] += (gg % ll == 0);
	for(int i = 1;i * i <= l;i++){
		if(l % i == 0){
			if(i % g == 0 && i <= n){
				dfs(1 , i , 0);
			}
			int ii = l / i;
			if(i * i == l) continue;
			if(ii % g == 0 && ii <= n){
				dfs(1 , ii , 0);
			}
		}
	}
	while(q--){
	    scanf("%lld" , &x);
		if(x > n || l % x || x % g){
			puts("0");
			continue;
		}
		ans = 0;
		dfs2(1 , x , 0);
		notjia(ans , 0);
		printf("%lld\n" , ans);
	}
}
```


---

## 作者：Arghariza (赞：5)

真的一点都不卡啊……

首先这个最大公倍数 $\text{G}$ 明显是诈骗，如果 $\text{G}\nmid \text{L}$ 一定无解，直接判掉。否则我们将 $\text{L},\text{X}$ 和 $\text{N}$ 都除 $\text{G}$：$\text{N}$ 之所以能直接除 $\text{G}$ 是因为你取出来的数都必须是 $\text{G}$ 的因数。而 $[1,\text{N}]$ 中有 $\left\lfloor\frac{\text{N}}{\text{G}}\right\rfloor$ 个数满足这个条件。

然后问题变为：

> 从 $[1,\text{N}]$ 中取若干数，$\text{Q}$ 次询问，每次查询必须包含 $\text{X}$ 的取数方案，使得 $\text{gcd}$ 为 $1$ 并且 $\text{lcm}$ 为 $\text{L}$。

显然我们取的数都是 $\text{L}$ 的因数，于是可以对 $\text{L}$ 质因数分解。假设质数 $p$ 的次数为 $r_p$。其次，$\text{L}$ 的因数最多有 $d=768$ 个，记为集合 $\mathbb{F}$。

由于 $\omega(10^8)=8$，并且我们只关心**每个数的质因子 $p$ 次数是否为 $0$ 或者 $r_p$**，所以考虑状压。可以对于每个 $x\in\mathbb{F}$，将 $x$ 的状态表示为一个 $16$ 位的二进制数：前 $8$ 位表示每个 $p$ 的次数是否为 $0$，后 $8$ 位表示每个 $p$ 的次数是否为 $r_p$。

这一步预处理是 $O(d\omega(\text{L})+\text{N})$ 的，写得再臭都能过。

先不考虑 $\text{X}$ 的限制，答案就是取出若干个数，或起来为全集的方案数，将或起来为 $S$ 的答案设为 $f_S$。

这是典，考虑容斥：令 $g_S$ 为或起来是 $S$ 的子集的方案数。$g_S=\sum\limits_{T\subseteq S}f_T$，于是 $f_S=\sum\limits_{T\subseteq S}(-1)^{|S|-|T|}g_T$。由于答案 $S$ 为全集，并且 $|S|=2\omega(\text{L})$，所以 $\text{ans}=\sum\limits_T(-1)^{|T|}g_T$。

考虑到 $g_S=2^{c(S)}$。$c(S)$ 为 $[1,\text{N}]$ 的数状态表示为 $S$ 子集的个数，显然可以用 FWT 求出，做一遍子集和即可。

现在考虑有 $\text{X}$ 的限制，改变 $f,g$ 的定义为必须选 $\text{X}$ 时，相应的意义。于是 $g_S=[\text{X}\subseteq S]2^{c(S)-1}$，即减去不选 $\text{X}$ 的方案。

注意到 $\text{ans}=\sum\limits_T(-1)^{|T|}g_T$ 仍然成立。所以：

$$\begin{aligned}\text{ans}&=\sum\limits_T(-1)^{|T|}g_T\\&=\sum\limits_T(-1)^{|T|}[\text{X}\subseteq T]2^{c(T)-1}\\&=\sum\limits_{\text{X}\subseteq T}(-1)^{|T|}2^{c(T)-1}\end{aligned}$$

考虑预处理出所有的 $\text{ans}(\text{X})$，这东西显然是个超集和，也可以 FWT 做。做完了，复杂度 $O(n+\omega(\text{L})(d+2^{\omega(\text{L})}))$。

真的一点也不卡常。在 [LOJ](https://loj.ac/s/1728208) 上只跑了 143 ms。

---

## 作者：ubsan (赞：5)

我们可以把 $N$ , $L$ , $X$ 都除以 $G$，这样问题就转化成了在 $[1,N]$ 中选若干个 $L$ 的约数（其中包括 $X$），使它们的最小公倍数为 $L$ ,最大公约数为 $1$。

我们思考它们的质因数分解是什么样的才能满足上面的条件，可以想出对于每一个存在的质因数，它在所有数中指数的最小值必须为 $1$，而最大值必须和 $L$ 中这一项的指数相同（因为它们是 $L$ 的约数，所以它们的质因数也一定是 $L$ 的质因数）。

而 $L \le 10^8$，可以发现质因数种类不会太多，考虑状态压缩。

我们设 $len$ 为质因数个数，设一个状态 $mask$ 的前 $len$ 位为是否有一个数这一项的指数为 $0$，后 $len$ 位为是否有一个数这一位的指数和 $L$ 相同，我们可以发现满足题目要求的 $mask$ 每一位都为 $1$。

至于转移（也就是添加一个数）直接或起来即可（因为是最大值和最小值）。

我们发现 $mask$ 相同的数我们可以把它们看做一种数，所以我们可以把所有的数按 $mask$ 划分成若干的等价类，记录每一个等价类的大小。

考虑 `dp`，设 $dp[0/1][i][mask]$ 为选到前/后 $i$ 个数，状态为 $mask $ 的方案数，至于转移为 `dp[0/1][i+1][mask|group[i].mask] += dp[0/1][i][j]*pow(2,group[i].size-1)`（ $-1$ 是因为至少选 $1$ 个才能产生这个状态）。

我们之所以要前后各 `dp` 一遍是因为我们需要钦定选某一个数，这样我们就可以合并 `dp` 数组了，也就是 `ans[i]=dp[0][i-1][mask1]*dp[1][i+1][mask2]*pow(2,group[i].size-1)`（需要 `mask1|mask2|group.mask` 符合题目要求，即每一位都为 $1$，在指数上 $-1$ 是因为其中有一个数必须选（我们并不关心这个数是什么）)

这样这道题就做完了，求答案的时候直接找到这个数对应的等价类的答案就行了。

可是我们发现最后合并的复杂度是不对的（因为我们需要枚举两边的状态），所以我们可以对于每一个等价类 $k$ 设一个辅助数组 $tmp_{mask}=\sum_{i \bigoplus j=mask}dp[0][k-1][i]*dp[1][k+1][j]$，表示不选这个等价类的数，状态为 $mask$ 的方案数，可以 $FWT$ 优化，然后就可以按照上文的方法合并了。

code:

```cpp
// Problem: P5366 [SNOI2017]遗失的答案
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5366
// Memory Limit: 500 MB
// Time Limit: 2000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define MOD 1000000007
using namespace std;
int n, g, l, q, dp[2][1000][1 << 16];
vector<int> v;
vector<pair<int, int> > pr, group;
map<int, int> mp, rec, ans;
int qpow(int a, int b) {
  if (!b) return 1;
  int tmp = qpow(a, b / 2);
  return b % 2 ? 1ll * tmp * tmp % MOD * a % MOD : 1ll * tmp * tmp % MOD;
}
void fwt(int *a, int len, int f = 1) {
  for (int l = 1; l < len; l <<= 1)
    for (int s = 0; s < len; s += (l << 1))
      for (int j = 0; j < l; j++) {
        if (f == 1) {
          a[s + l + j] = (a[s + l + j] + a[s + j]) % MOD;
        } else {
          a[s + l + j] = (a[s + l + j] - a[s + j] + MOD) % MOD;
        }
      }
}
string decode(int mask) {
  string sol = "";
  for (int i = pr.size() * 2 - 1; i >= 0; i--) {
    if (mask & (1 << i))
      sol += "1";
    else
      sol += "0";
  }
  return sol;
}
signed main() {
  cin >> n >> g >> l >> q;
  if (l % g) {
    while (q--) puts("0");
    return 0;
  }
  l /= g;
  n /= g;
  for (int i = 1; i <= sqrt(l) && i <= n; i++) {
    if (l % i == 0) {
      v.push_back(i);
      if (i * i != l && l / i <= n) v.push_back(l / i);
    }
  }
  int x = l;
  for (int i = 2; i <= sqrt(l); i++) {
    int cnt = 0;
    while (x % i == 0) {
      x /= i;
      cnt++;
    }
    if (cnt) {
      pr.push_back(make_pair(i, cnt));
    }
  }
  if (x != 1) {
    pr.push_back(make_pair(x, 1));
  }
  for (auto x : v) {
    int mask = 0, bk = x;
    for (int i = 0; i < pr.size(); i++) {
      int cnt = 0;
      while (x % pr[i].first == 0) {
        cnt++;
        x /= pr[i].first;
      }
      if (!cnt) {
        mask |= (1 << i);
      }
      if (cnt == pr[i].second) {
        mask |= (1 << (i + pr.size()));
      }
    }
    mp[mask]++;
    rec[bk] = mask;
  }
  for (auto x : mp) {
    group.push_back(make_pair(x.first, qpow(2, x.second) - 1));
  }
  sort(group.begin(), group.end());
  dp[0][0][0] = dp[1][group.size()][0] = 1;
  int limit = (1 << (pr.size() << 1));
  int siz = group.size();
  for (int i = 0; i < siz; i++) {
    for (int j = 0; j < limit; j++) {
      dp[0][i + 1][j] = (dp[0][i + 1][j] + dp[0][i][j]) % MOD;
      dp[0][i + 1][j | group[i].first] = (dp[0][i + 1][j | group[i].first] +
                                          1ll * dp[0][i][j] * group[i].second) %
                                         MOD;
    }
  }
  for (int i = siz; i; i--) {
    for (int j = 0; j < limit; j++) {
      dp[1][i - 1][j] = (dp[1][i - 1][j] + dp[1][i][j]) % MOD;
      dp[1][i - 1][j | group[i - 1].first] =
          (dp[1][i - 1][j | group[i - 1].first] +
           1ll * dp[1][i][j] * group[i - 1].second) %
          MOD;
    }
  }
  for (int i = 0; i <= siz; i++) {
    fwt(dp[0][i], limit);
    fwt(dp[1][i], limit);
  }
  for (int i = 0; i < siz; i++) {
    for (int j = 0; j < limit; j++) {
      dp[0][i][j] = (1ll * dp[0][i][j] * dp[1][i + 1][j]) % MOD;
    }
  }
  for (int i = 0; i <= siz; i++) {
    fwt(dp[0][i], limit, -1);
  }

  for (int i = 0; i < siz; i++) {
    int tmp = 0;
    for (int j = 0; j < limit; j++) {
      if ((j | group[i].first) == (limit - 1)) {
        tmp = (tmp + 1ll * dp[0][i][j] * (group[i].second + 1) % MOD *
                         ((MOD + 1) >> 1)) %
              MOD;
      }
    }
    ans[group[i].first] = tmp;
  }
  while (q--) {
    cin >> x;
    if (x % g != 0) {
      puts("0");
      continue;
    }
    x /= g;
    if (l % x != 0 || x > n) {
      puts("0");
      continue;
    }
    cout << ans[rec[x]] % MOD << endl;
  }
  return 0;
}
```

---

## 作者：封禁用户 (赞：5)

做法和大家的不太一样。~~不过我的做法更难写是真的。~~

或许有些地方展示着我的无知，请见谅。总体而言应该是讲了点有用的东西。

# 思路
其实只要 **对于每个质因数**，次数搞定了就行。

> 题外话：这个转化并不容易想到吧……我想到它完全是因为这是我们的 $\tt FWT$ 专题中的题目。

用四进制数 $S$ 表示，$\gcd$ 搞定否和 $\rm lcm$ 搞定否。则
$$
f_i(S)=f_{i-1}(S)+f_{i-1}(S\cup g_i)
$$
这里用 $g_i$ 表示 $i$ 可以满足哪些条件。虽说有的数字是绝对不能选的……

先别管其他的事儿了。这里 $S$ 的范围太大了$!!!$ 怎么办？

假如 $\gcd$ 和 $\rm lcm$ 指数相同，那么可以去掉，因为没得选。

假如 $\gcd$ 和 $\rm lcm$ 指数差 $1$ ，这倒也可以。那么 $\rm lcm$ 至少就是 $\gcd$ 的 $p$ 倍。取 $\gcd=1$ 也最多只有 $8$ 个 $p$ ，因为
$$
2\times 3\times 5\times 7\times 11\times 13\times 17\times 19\times 23=223,092,870
$$
已经超过了 $10^8$ 的范围限制啦！于是 $S$ 被压缩到了 $2^{16}$ 这么大！

此时 $n$ 个数字并不是很重要，它们可以根据效用分成 $S+1$ 类（其中一类是不能选的有害垃圾）。具体而言——枚举 $L$ 的因数就可以啦！复杂度仅仅 $\mathcal O(8\sqrt{L}\log L)$ 而已！

不妨设每一类的个数为 $a_i$ ，那么我们只需要选几个类，使得它们的按位或为 $t$ ，此时方案数为 $\prod (2^{a_i}-1)$ ，就是选这个类中的若干个嘛。

那么我们用分治？欲求出 $v\in [0,2^n)$ 的方案数，只需求出 $v\in[0,2^{n-1})$ 能凑出啥，$v\in[2^{n-1},2^{n})$ 能凑出啥，然后拼起来。

不难发现递归时最高位被确定了！所以问题规模确实在缩小。合并可以用 $\tt FWT$ 作按位或卷积。所以复杂度是
$$
T(n)=2T\left({n\over 2}\right)+\mathcal O(n\log n)=\mathcal O(n\log^2n)
$$
其中 $n$ 最大为 $2^{16}$ ，还挺快的。但是跑偏了……

回到问题上：必须选 $X$ 怎么满足？考虑找到 $X$ 所在的类别（效用等价类），然后强迫不选这个类别。这是那个经典问题了，跟[这道题](https://www.luogu.com.cn/problem/CF1442D)需要搞定的问题是一样的。也用分治？如果单点加入是直接加入的话，每次加入就高达 $S$ 的复杂度，恐怕不行。

那么区间加入必须一起加入。考虑把每个分治时得到的，类似线段树区间的，凑出每种状态的方案数 $\langle b\rangle$ 都存下来？空间大小为 $\mathcal O(S\log S)$ 。然后可以硬性 $\mathcal O(N\log N)$ 吗？显然不是的！因为上面的更长，需要将就上面的！

能不能把上面的削短？因为我们想要的只有全集。譬如，这一步我往右走，说明这一位选 $0$ 或 $1$ 并不重要——必须选的这一位是 $1$ 呢！往左，则相反，这里必须选 $1$ 。所以我们可以把这一位砍掉！

此时，复杂度应当为
$$
T(N)=2T\left({N\over 2}\right)+\mathcal O(N\log N)=\mathcal O(N\log^2N)
$$

啊哈！搞定了！~~不过你大概也猜的到代码有多难打。~~

虽说常数可能不会太优秀（因为有很多复制、乘法等操作），但是并不慢。

# 代码
~~看了看其他题解~~，意识到因数的数量比 $2^{16}$ 小很多，所以加入了一个 $qpg$ 数组进行优化。即使不要它，渐进复杂度 $16\times 16\times 2^{16}$ 也是对的。

由于每个区间存储的 $\langle b\rangle$ 是残缺的（省略了前面几位）并且没有考虑区间内一个不选的情况，要特别思考一下这东西。$\tt FWT$ 做完后，有可能需要再加一份乘数。

而 $solve$ 中的 $b$ 可能不需要加。因为 $b$ 实际上代表的是前面有一些 $0$ 的状态，不能加入。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long int_;
inline int readint(){
	int a = 0; char c = getchar(), f = 1;
	for(; c<'0'||c>'9'; c=getchar())
		if(c == '-') f = -f;
	for(; '0'<=c&&c<='9'; c=getchar())
		a = (a<<3)+(a<<1)+(c^48);
	return a*f;
}

const int Mod = 1e9+7;
const int inv2 = (Mod+1)>>1;

inline int qkpow(int_ b,int q){
	int a = 1;
	for(; q; q>>=1,b=b*b%Mod)
		if(q&1) a = a*b%Mod;
	return a;
}

void FWT(int a[],int n,int opt){
	for(int i=0; i<n; ++i)
	for(int j=0; j<(1<<n); ++j)
	if(j>>i&1){
		a[j] = (a[j]+opt*a[j^(1<<i)])%Mod;
		if(a[j] < 0) a[j] += Mod;
	}
}

const int MaxN = 16;
int sxy[1<<MaxN], zxy[1<<MaxN];
/** @brief Set c = sxy \times zxy */
void mul(int c[],int n){
	FWT(sxy,n,1), FWT(zxy,n,1);
	for(int i=0; i<(1<<n); ++i)
		c[i] = 1ll*zxy[i]*sxy[i]%Mod;
	FWT(c,n,-1); // get result
}

/** @brief a += b ( len = 1 << n ) */
void add(int a[],int b[],int n){
	for(int i=0; i<(1<<n); ++i)
		a[i] = (a[i]+b[i])%Mod;
}

int b[MaxN+1][1<<MaxN];
int g[1<<MaxN]; // calc (1 << cnt)
int qpg[(1<<MaxN)<<1|1];
void prepare(int l,int r,int dep){
	if(r-l == 1){
		qpg[l<<1] = g[l];
		g[l] = qkpow(2,g[l]);
		return void(b[dep][l] = g[l]-1);
	}
	int m = (l+r)>>1; // middle
	prepare(l,m,dep-1);
	prepare(m,r,dep-1);
	qpg[(l+r-1)|1] =
		qpg[(l+m-1)|(l!=m-1)]
		+ qpg[(m+r-1)|(m!=r-1)];
	if(!qpg[(l+r-1)|1]) return ;
	/* sxy = LEFT, zxy = RIGHT */ ;
	memcpy(sxy,b[dep-1]+l,(r-l)<<2);
	memset(sxy+m-l,0,(r-m)<<2);
	memcpy(zxy,b[dep-1]+l,(r-l)<<2);
	memset(zxy,0,(m-l)<<2);
	/* b = zxy * sxy + zxy + sxy */ ;
	mul(b[dep]+l,dep);
	add(b[dep]+l,b[dep-1]+l,dep);
}

int now[MaxN+1][1<<MaxN];
int bigR; // very right point
int ans[1<<MaxN];
void solve(int l,int r,int dep){
	if(!qpg[(l+r-1)|(l!=r-1)])
		return ; // no such thing
	if(r-l == 1){
		ans[l] = 1ll*g[l]*inv2%Mod;
		ans[l] = 1ll*ans[l]*now[dep][0]%Mod;
		ans[l] = (ans[l]+Mod)%Mod;
		return ;
	}
	int m = (l+r)>>1; // middle
	/* Go to left part */ ;
	memcpy(sxy,now[dep],(r-l)<<2);
	memcpy(zxy,b[dep-1]+l,(r-l)<<2);
	memset(zxy,0,(m-l)<<2);
	mul(now[dep-1],dep); // now * b
	add(now[dep-1],now[dep],dep); // + now
	if(r == bigR) // + b
		add(now[dep-1]+m-l,b[dep-1]+m,dep-1);
	memcpy(now[dep-1],now[dep-1]+m-l,(m-l)<<2);
	solve(l,m,dep-1);
	/* Go to right part */ ;
	memcpy(sxy,now[dep],(r-l)<<2);
	memcpy(zxy,b[dep-1]+l,(r-l)<<2);
	memset(zxy+m-l,0,(r-m)<<2);
	mul(now[dep-1],dep); // now * b
	add(now[dep-1],now[dep],dep); // + now
	if(r == bigR) // + b
		add(now[dep-1],b[dep-1]+l,dep-1);
	add(now[dep-1],now[dep-1]+m-l,dep-1);
	solve(m,r,dep-1);
}

vector< int > ys, cnt;
int add(int x){
	int S = 0, len = ys.size();
	for(int i=0; i<len; ++i){
		int p = 0;
		for(; x%ys[i]==0; ++p)
			x /= ys[i];
		if(p == 0) // gcd
			S |= (1<<(i<<1));
		if(p == cnt[i])
			S |= (1<<(i<<1|1));
	}
	return S;
}
int main(){
	int n = readint(); int N = n;
	int G = readint(); int GG = G;
	int L = readint(); int LL = L;
	bool bad = (L%G != 0);
	L /= G, n /= G; // only k*G
	G = L; // save archive
	/* Sieve factor of L */ ;
	int len = 0; // ys.size()
	for(int i=2; i<=L/i; ++i)
		if(L%i == 0){
			ys.push_back(i);
			cnt.push_back(0);
			for(; L%i==0; L/=i)
				++ cnt[len];
			++ len;
		}
	if(L != 1){
		ys.push_back(L);
		cnt.push_back(1);
		++ len;
	}
	/* Calculate size of each type */ ;
	for(int i=1; i<=G/i&&i<=n; ++i)
		if(G%i == 0){ // G = lcm'
			++ g[add(i)];
			if(G/i <= n && i != G/i)
				++ g[add(G/i)];
		}
	/* Prepare b in advance */ ;
	bigR = 1<<len<<len;
	prepare(0,(1<<len<<len),len<<1);
	/* Solve all answers */ ;
	solve(0,(1<<len<<len),len<<1);
	/* Tackle all queries */ ;
	int q = readint();
	for(int x; q; --q){
		x = readint();
		if(bad || x > N || LL%x || x%GG){
			puts("0"); continue;
		}
		if(LL == GG){
			printf("%d\n",x == GG);
			continue;
		}
		printf("%d\n",ans[add(x/GG)]);
	}
	return 0;
}
```

---

## 作者：初雨凉笙叹 (赞：5)

首先，如果$G$不整除$L$，显然一定无解。

否则，令$N=\frac{n}{G},M=\frac{L}{G}$，那么我们可以稍微简化一下问题，变成从$[1,N]$中选出若干个不同的数，使得这些数的$gcd$为1，且$lcm$为$M$。

简化完问题之后发现还是不会做……

可以发现，$M≤10^8$，意味着$M$最多只有$8$个互不相同的质因子。

那么我们可以考虑状压，状态$(S1,S2)$表示当前选择的若干个数中，质因子最小指数为$0$的状态为$S1$，质因子最大指数与$M$的指数相同的状态$S2$，再用$S$表示$S2S1$(这里的$S2S1$可以认为是$S1$作为字符串接在$S2$后)。

可以发现，对于每一个数$i$，我们可以都用对应的状态$S_i$来表示它。那么我们可以把$S_i$相同的分成一类，~~打表可知~~分成的种类个数不会很大，大约也就600左右

这样我们就可以设计一个dp，令$f[i][S]$表示前$i$类中，最后选择完的状态为$S$的方案数。转移十分显然，就不说了。令$g[i][S]$表示后缀，一样处理。

然后再考虑如何处理强制选择一个数的情况，处理一下不选择它的方案数再稍微算算就好了。这个过程可以用FWT来实现。

状态显然严重不满，并且常数很小，所以可以通过。

代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
template <typename T>
void read(T &x) {
    x = 0;
    int f = 1;
    char c = getchar();
    while (!isdigit(c)) {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (isdigit(c)) x = x * 10 + c - '0', c = getchar();
    x *= f;
}
const int N = 650, M = 1 << 16, Mod = 1e9 + 7;
int n, G, L, q, tot, p[N], lim[N], s[M], t[M], ret[M], num[M], f[N][M], g[N][M], ans[N][M];
void add(int &x, const int &y) {
    x += y;
    if (x >= Mod)
        x -= Mod;
}
int Pow(int x, int y) {
    int ret = 1;
    for (; y; y >>= 1, x = 1ll * x * x % Mod)
        if (y & 1)
            ret = 1ll * ret * x % Mod;
    return ret;
}
int calc(int x) {
    int s1 = 0, s2 = 0;
    for (int i = 1; i <= tot; i++) {
        int s = 0;
        while (x % p[i] == 0) x /= p[i], s++;
        s1 |= (s == 0) << i - 1, s2 |= (s == lim[i]) << i - 1;
    }
    return s1 | (s2 << tot);
}
void divide(int x) {
    for (int i = 2; i * i <= x; i++)
        if (x % i == 0) {
            p[++tot] = i, lim[tot] = 0;
            while (x % i == 0) x /= i, lim[tot]++;
        }
    if (x > 1)
        p[++tot] = x, lim[tot] = 1;
}
void dfs(int dep, int cur, int s1, int s2) {
    if (dep > tot)
        return s[s1 | (s2 << tot)]++, void();
    for (int i = 0; i <= lim[dep]; i++) {
        dfs(dep + 1, cur, s1 | ((i == 0) << dep - 1), s2 | ((i == lim[dep]) << dep - 1));
        cur *= p[dep];
        if (cur > n)
            return;
    }
}
void fwtor(int *a, int n, int fl) {
    for (int i = 1; i < n; i <<= 1)
        for (int r = i << 1, j = 0; j < n; j += r)
            for (int k = 0; k < i; k++)
                if (fl == 1)
                    add(a[i + j + k], a[j + k]);
                else
                    add(a[i + j + k], Mod - a[j + k]);
}
int main() {
    read(n), read(G), read(L), read(q);
    if (L % G) {
        while (q--) cout << "0\n";
        return 0;
    }
    n /= G, L /= G, divide(L), dfs(1, 1, 0, 0);
    int m = (1 << tot + tot), cnt = 0;
    for (int i = 0; i < m; i++)
        if (s[i])
            num[++cnt] = i, t[cnt] = Pow(2, s[i]) - 1;
    f[0][0] = 1, g[cnt + 1][0] = 1;
    for (int i = 0; i < cnt; i++)
        for (int j = 0; j < m; j++) {
            if (!f[i][j])
                continue;
            add(f[i + 1][j], f[i][j]);
            add(f[i + 1][j | num[i + 1]], 1ll * f[i][j] * t[i + 1] % Mod);
        }
    for (int i = cnt + 1; i > 1; i--)
        for (int j = 0; j < m; j++) {
            if (!g[i][j])
                continue;
            add(g[i - 1][j], g[i][j]);
            add(g[i - 1][j | num[i - 1]], 1ll * g[i][j] * t[i - 1] % Mod);
        }
    for (int i = 0; i <= cnt + 1; i++) fwtor(f[i], m, 1), fwtor(g[i], m, 1);
    for (int i = 1; i <= cnt; i++)
        for (int j = 0; j < m; j++) add(ans[i][j], 1ll * f[i - 1][j] * g[i + 1][j] % Mod);
    for (int i = 1; i <= cnt; i++) fwtor(ans[i], m, -1);
    for (int i = 1; i <= cnt; i++) {
        for (int j = 0; j < m; j++)
            if ((j | num[i]) == m - 1)
                add(ret[i], ans[i][j]);
        ret[i] = 1ll * ret[i] * Pow(2, s[num[i]] - 1) % Mod;
    }
    while (q--) {
        int x;
        read(x);
        if (x % G) {
            cout << "0\n";
            continue;
        }
        x /= G;
        if (L % x || x > n) {
            cout << "0\n";
            continue;
        }
        int y = calc(x), p = lower_bound(num + 1, num + cnt + 1, y) - num;
        cout << ret[p] << '\n';
    }
    return 0;
}
```


---

## 作者：Wuyanru (赞：3)

[更好的阅读体验](https://shijiuwan.github.io/SNOI2017遗失的答案/)

模拟赛里的题，但是没有做出来...有点菜啊。

[题目链接](https://www.luogu.com.cn/problem/P5366)

## 题意

一个人买了 $ 1\sim N $ 中的若干个皮肤，皮肤编号的最大公倍数为 $ G $，最小公约数为 $ L $。

现在给出 $ Q $ 组询问，每次询问有多少种方案买了皮肤 $ X $。

## 题解

首先我们可以做一步非常简单的转化，让我们之后的步骤更顺手。

显然，所有可能买的皮肤肯定都是 $ G $ 的倍数，询问的 $ X $ 肯定只在为 $ G $ 的倍数时才有答案。

所以我们可以先把 $ N,L $ 和所有询问都先除以 $ G $，这样我们就可以把 $ G $ 当作 $ 1 $ 来处理。

当然，一个小坑点，要特判一下 $ L $ 是不是 $ G $ 的倍数。

然后我们在来想一下有什么皮肤**可能会在方案中**，显然只有 $ L $ 的因数。

容易注意到一个点，$ L $ 最大范围是 $ 10^8 $，而 $ 10^8 $ 以内因数最多数字，因数只有 $ 768 $ 个。

这提示我们可以先预处理出 $ L $ 因数的答案，然后询问时直接输出即可。

现在我们可以来想一想，有多少种方案包含皮肤 $ X $，并且皮肤编号的最大公约数是 $ 1 $，最小公倍数是 $ L $。

我在模拟赛时想到的思路就是容斥。

### 容斥

不难看出，这道题有两个条件需要满足。

条件一为皮肤的最大公约数是 $ 1 $，转化一下，可以得到若干个条件，形如：

>至少有一个皮肤的编号不是 $ m $ 的倍数，其中 $ m=p^c,p\in primes,m|X $。

条件二为皮肤的最小公倍数是 $ L $ ，转化一下，可以得到若干个条件，形如：

>至少有一个皮肤的编号是 $ m $ 的倍数，其中 $ m=p^c,p\in primes,m|L $。

其中 $ X $ 已经满足的条件可以去掉。

这样子，我们就可以暴力枚举哪些条件不满足，进行容斥。

如果条件一不满足，那么他就会长这个样子：

> 没有皮肤的编号不是 $ m $ 的倍数，也就是说所有皮肤编号都是 $ m $ 的倍数，$ m $ 的定义如上。

如果条件二不满足，那么他就会长这个样子：

> 没有皮肤的编号是 $ m $ 的倍数，$ m $ 的定义如上。

然后我们暴力枚举每一个条件是否不满足，然后暴力枚举每一个可能的皮肤，直接容斥。

看一个皮肤满不满足一个条件可以通过提前预处理，然后 $ O(1) $ 使用位运算回答。

时间复杂度为 $ O(\textbf{约数个数}^2\times 2^\textbf{条件个数}) $。

打表可得，在 $ L $ 取 $ 91891800 $ 时这个数字最大，可以达到 $ 603979776\approx6\times 10^8 $。 

时限是 $ 2s $，可过。

打表程序核心代码放上，我本机差不多跑了半分钟。

```c++
int main()
{
	for(int i=2;i<=n;i++)
	{
		if(!is[i]) pri[++pri[0]]=i;
		for(int j=1;j<=pri[0]&&i*pri[j]<=n;j++)
		{
			is[i*pri[j]]=1;
			if(i%pri[j]==0) break;
		}
	}
	// printf("%d\n",pri[0]);
	for(int i=1;i<=n;i++) for(int j=1;i*j<=n;j++) num[i*j]++;
	// printf("%lld\n",num[n]);
	for(int i=1;i<=n;i++) num[i]*=num[i];
	for(int i=1;i<=pri[0];i++) for(int j=1;pri[i]*j<=n;j++)
	{
		num[pri[i]*j]<<=1;
		if(j%pri[i]==0) num[pri[i]*j]<<=1;
	}
	// printf("%lld\n",num[n]);
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		// if(i%100000==0) printf("%d : %d %lld\n",i,ans,num[ans]);
		if(num[i]>num[ans]) ans=i;
	}
	printf("%d : %lld\n",ans,num[ans]);
	return 0;
}
```

算条件个数的地方可能不太好理解。

## 代码

```c++
// DABC ABCD ABCA DBAA
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#include<map>
using namespace std;
const int mod=1000000007;
using ll=long long;
using pi=pair<int,int>;
template<typename A>
using vc=vector<A>;
inline int read()
{
	int s=0,w=1;char ch;
	while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline ll lread()
{
	ll s=0,w=1;char ch;
	while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
map<int,ll>ans;
ll p[1048576];
int pop[1048576];
bool is[10001];
int pri[10001];
int a[100001];
int visx[10001];
int visy[10001];
int x[20];
int y[20];
int n,G,L,Q;
int tot;
inline void run(int num)
{
	int val=num/G;x[0]=y[0]=0;
	for(int i=1;pri[i]*pri[i]<=val&&i<=pri[0];i++) if(val%pri[i]==0)
	{
		x[++x[0]]=pri[i];
		while(val%pri[i]==0) val/=pri[i];
	}
	if(val!=1) x[++x[0]]=val;
	val=L;
	for(int i=1;pri[i]*pri[i]<=val&&i<=pri[0];i++) if(val%pri[i]==0)
	{
		int v=1;
		while(val%pri[i]==0) val/=pri[i],v*=pri[i];
		if(num%v) y[++y[0]]=v;
	}
	if(val!=1&&num%val) y[++y[0]]=val;
	for(int i=1;i<=tot;i++)
	{
		visx[i]=visy[i]=0;
		for(int j=1;j<=x[0];j++) if(a[i]%x[j]) visx[i]|=(1<<(j-1));
		for(int j=1;j<=y[0];j++) if(a[i]%y[j]==0) visy[i]|=(1<<(j-1));
	}
	ll va=0;
	for(int i=0;i<(1<<x[0]);i++) for(int j=0;j<(1<<y[0]);j++)
	{
		int sum=0;
		for(int k=1;k<=tot;k++) if(a[k]!=num) sum+=(!(visx[k]&i)&&!(visy[k]&j));
		// printf("i=%d j=%d sum=%d\n",i,j,sum);
		int flag=(pop[i]+pop[j])&1?-1:1;
		va+=flag*p[sum];
	}
	ans[num]=(va%mod+mod)%mod;
}
int main()
{
	p[0]=1;
	for(int i=1;i<1048576;i++) pop[i]=pop[i-(i&(-i))]+1,p[i]=p[i-1]*2%mod;
	for(int i=2;i<=10000;i++)
	{
		if(!is[i]) pri[++pri[0]]=i,is[i]=1;
		for(int j=1;j<=pri[0]&&i*pri[j]<=10000;j++)
		{
			is[i*pri[j]]=1;
			if(i%pri[j]==0) break;
		}
	}
	n=read(),G=read(),L=read(),Q=read();
	if(L%G)
	{
		for(int i=1;i<=Q;i++) printf("0\n");
		return 0;
	}
	int memG=G;L/=G,n/=G,G=1;
	for(int i=1;i<=n&&i*i<=L;i++) if(L%i==0)
	{
		a[++tot]=i;
		if(i!=L/i&&L/i<=n) a[++tot]=L/i;
	}
	for(int i=1;i<=tot;i++) run(a[i]);
	for(int i=1;i<=Q;i++)
	{
		int x=read();
		if(x%memG||!ans.count(x/memG)) printf("0\n");
		else printf("%lld\n",ans[x/memG]);
	}
	return 0;
}
```

你谷上开O2最大点跑了 $ 269ms $。

---

## 作者：MoonPie (赞：3)

## 題意

全集 $U = \left\{1,2,\dots,N\right\}$ 中選出一個數集 $S$，使其最大共因數為 $G$，最小公倍數為 $L$。有 $Q$ 次詢問，每次詢問給出一個 $X$，請你輸出滿足條件的且包含 $X$ 的數集的個數。

## 題解

按照最大共因數和最小公倍數的套路，我們把 $L,N$ 都除以 $G$，把問題轉化為了：數集的 $\gcd = 1,\mathrm{lcm} = L$。

將 $L$ 質因數分解得到 $L = \prod p_i^{c_i}$。顯然，$S$ 中所有元素必然是 $L$ 的因子；而且對於任意一個質因數 $p_i$，合法的 $S$ 中必然有一個數的指數是 $0$，也有一個指數恰好為 $c_i$。

因此我們只在乎一個數的 $p_i$ 有沒有達到上界和下界，可以將一個轉化為一個$16$位的狀態：前 $8$ 位表示 $p_i$ 的指數是否為 $0$，後 $8$ 位表示指數是否為 $c_i$。

然後將 $L$ 的所有因數按照這個狀態分組，並且DP預處理出 $\mathrm{pre}(i,m),\mathrm{suf}(i,m)$，分別表示第 $1$ ～ $i$ 組選出狀態 $m$ 的方案數和後綴的方案數。

---

但是發現自己不太會 $\mathrm{FWT}$ 。考慮現在原問題轉化為，從全集中選若幹個數，按位或起來是 $11\dots 11$。

可以考慮**容斥+高維前綴和**解決這個問題：

ans(全部都是1) = 至少選0個0 - 至少選1個0 + 至少選2個0 $\dots$ 
$$
\mathrm{ans} = \sum_{S\subseteq U}(-1)^{|S|}2^{f(U-S)}
$$
其中 $f(S)$ 表示 $S$ 的子集的個數，注意$f(S)$表示的是**數字**（狀態）的個數，可以用高維前綴和預處理出來。

如何理解？$S$ 枚舉的就是0的狀態，$U-S$ 這些位中的數可以是1也可以是0。

![](https://cdn.luogu.com.cn/upload/image_hosting/0v4r9iwd.png)

對於一個欽定要選的 $X$，只要找到它所在的集合減1重算$\mathrm{ans}$就可以算出**欽定不選**$X$的方案，用總共的方案減去這個就是答案了。

由於相同狀態的 $X$ 效果相同，而不同的狀態不超過800，所以我們可以先預處理出所有的 $\mathrm{ans}$。



## 代碼

```cpp
const int mod = 1e9+7;
int n,G,L,q,f[1<<18],popcnt[1<<18],Ans[1000],p2[1<<18];

vector<int> p,c,ml,state;

int Get(int x) {
	int res = 0;
	for(int i = 0; i < (int)p.size(); ++i) {
		if(x % p[i]) res |= 1<<i;
	}	
	for(int i = 0; i < (int)ml.size(); ++i) {
		if(x % ml[i] == 0) res |= 1<<(i+p.size());
	}
	return res;
}

signed main()
{
  read(n); read(G); read(L); read(q);
  if(L % G) {for(int i = 0; i < q; ++i) puts("0"); return 0;}

  int O = L, N = n;
  L /= G; n /= G;

  int T = L;
  for(int i = 2; i*i <= T; ++i) {
  	if(T % i == 0) {
  		int t = 0, m = 1;
  		while(T % i == 0) ++t, m*=i, T /= i;
  		p.push_back(i); 
  		c.push_back(t);
  		ml.push_back(m);
  	}
  }
  if(T > 1) {
  	p.push_back(T);
  	c.push_back(1);
  	ml.push_back(T);
  }

  memset(f,0,sizeof(f));
  for(int i = 1; i*i <= L; ++i) {
  	if(L % i == 0) {
  		if(i <= n) {
	  		state.push_back(Get(i));
	  		f[Get(i)]++;
  		}
  		if(i*i != L && L / i <= n) {
  			state.push_back(Get(L/i));
  			f[Get(L/i)]++;
  		}
  	}
  }

  p2[0] = 1; 
  for(int S = 1; S < 1<<18; ++S) {
  	p2[S] = p2[S-1]*2%mod;
  	int c = 0;
  	for(int i = 0; i < 2*p.size(); ++i) if(S>>i&1) ++c;
  	popcnt[S] = c;
  }

  int ans = 0, U = (1<<(2*p.size()))-1;
  for(int i = 0; i < 2*p.size(); ++i) {
  	for(int j = 0; j <= U; ++j) {
  		if(j>>i&1) f[j] += f[j^(1<<i)];
  	}
  }
  for(int S = 0; S <= U; ++S) {
  	int fg = (popcnt[S]&1)? -1: 1;
  	ans = (ans+(mod+fg*p2[f[U-S]])%mod)%mod;
  }
  sort(state.begin(),state.end());
  for(int i = 0; i < (int)state.size(); ++i) {
  	for(int S = 0; S <= U; ++S) if((S&state[i]) == state[i]) f[S]--;
  	Ans[i] = 0;
	  for(int S = 0; S <= U; ++S) {
	  	int fg = (popcnt[S]&1)? -1: 1;
	  	Ans[i] = (Ans[i]+(mod+fg*p2[f[U-S]])%mod)%mod;
	  }
	  Ans[i] = (ans-Ans[i]+mod)%mod;
  	for(int S = 0; S <= U; ++S) if((S&state[i]) == state[i]) f[S]++;
  }
  for(int cs = 0, x; cs < q; ++cs) {
  	read(x);
  	if(O%x || x > N || x%G) puts("0");
  	else {
  		x /= G;
  		int it = lower_bound(state.begin(),state.end(),Get(x))-state.begin();
  		cout << Ans[it] << endl;
  	}
  }
	return 0;
}
```

---

## 作者：Mihari (赞：3)

# 题目

[传送门](https://www.luogu.com.cn/problem/P5366)

# 题解

第一个处理，我们可以将 $N,L$ 同时 $/G$，当然，如果 $G\nmid L$，那么全部无解，输出 $Q$ 个 `0` 即可。

令 $n=\frac{N}{G},l=\frac{L}{G}$，那么，这道题就被我们转化为

>在 $[1,n]$ 之间，选一些数，其中必选 $\frac{X}{G}$，使得他们的 $\gcd$ 为 $1$，$\text{lcm}$ 为 $n$。

注意，这里的 $\gcd$ 为 $1$ 不等于所有数互质。

显然，我们选出的这些数一定都是由 $\text{lcm}$ 的因数，考虑我们选择 $\{x_1,x_2,x_3...x_k\}$ 这些数，怎么才能使得他们的 $\gcd=1,\text{lcm}=l$。

由于 $\gcd$ 与 $\text{lcm}$ 十分类似，我们只分析 $\gcd$：

将所有 $x$ 分解，设 $x_i=p_{i,j}^{t_{i,j}}p_{i,j+1}^{t_{i,j+1}}...$

如果 $\exist x_i,t_{i,j}=0$ 对于所有 $j$ 成立，那么他们的 $\gcd=1$ ，也就是说，只要我们选的所有数中，有某一个数的这个质因数指数为 $0$，而且所有的质因数都可以找到类似于这样的一个数，那么 $\gcd(x_i)=1$。

类似地，$\text{lcm}$ 也是同样的道理，只要我们选的所有数中，有某一个数的这个质因数指数和 $l$ 相同，并且对于所有的质因数都可以找到这样的一个数，那么 $\text{lcm}(x_i)=l$。

有了这个分析，我们进一步思考。

由于 $L\le 10^8$，我们可以看一下，$L$ 最多会有多少个因数？
$$
2\times 3\times 5\times 7\times 11\times 13\times 17\times 19\times 23=223092870>10^8
$$
那么，$L$ 最多只会有 $9-1=8$ 个因数。

对于一个因数，我们可以维护他的每个质因数，因为只有八个因数，那么就会有 $2^8$ ？并不是，由于我们每个因数都有 **底下界( $\gcd$ )，底上界( $\text{lcm}$ )** 这两种情况，那么每个质因数我们维护两位二进制——$00$ 表示上下界都不到达，$01$ 表示底上界，$10$ 表示底下界。

对于一个数 $M\le 10^8$，我们有

>它的因数个数最多不超过 $800$ 个。

的结论，具体证明在[这里](https://www.cnblogs.com/ubospica/p/10392523.html)。

那么，我们来看一下怎么枚举因数的：

```cpp
void dfs(const int i,int now,const int s){
    if(i==len){//枚举了一个因数
        ans[++cnt]=-1;//更新因数编号
        lst.push_back(mp(now,cnt));//并将其放进所有的因数集合中
        // printf("this num,now == %d, cnt == %d, s == ",now,cnt);print(s);Endl;
        f[cnt].resize(sz);
        // printf("modify_DWT(%d,%d,%d)\n",cnt,0,1);
        // printf("modify_DWT(%d,%d,%d)\n",cnt,s,1);
        modify_DWT(f[cnt],0,1);//要么就不选这个因数
        modify_DWT(f[cnt],s,1);//选上这个因数，那么其状态为 s 的那一位也为 1
    }else{
        int ti=ele[0][i],tl=ele[1][i];
        rep(t,0,tl){//枚举这个因数中，第 i 个质因数的次方
            if(t==0)dfs(i+1,now,s<<2|2);//如果他没有这个因数，那么他限定下界
            else if(t==tl)dfs(i+1,now,s<<2|1);//如果他的因数与 lcm 对应，那么他限定上界
            else dfs(i+1,now,s<<2);//十分平凡
            if(1ll*now*ti<=n)now*=ti;//保证因数在 n 的范围之内
            else return;
        }
    }
}
```

然后，我们设 $f[i][j]$ 表示在前 $i$ 个数中，选择的因数代码的状态 $s$ 或起来等于 $j$ 的方案数，那么就有
$$
f[i][j]=\sum_{k\oplus t=j}f[i-1][k]\times f[i-1][t]
$$
俨然一副 $FWT$ 的样子。

显然，最后我们需要的就是 $1111...$ 的状态。

可以先将所有的 $f[i]$ 的 $DWT$ 形式处理出来，然后对位累乘即可。

但是我们所求的是

> 在 $[1,n]$ 之间，选一些数，其中必选 $\frac{X}{G}$，使得他们的 $\gcd$ 为 $1$，$\text{lcm}$ 为 $n$。

怎么 “必选 $\frac{X}{G}$ ”？考虑容斥——将所有方案处理出来，再减去不选 $\frac{X}{G}$ 的情况。

那么怎么求不选呢？累乘的时候不乘上 $\frac{X}{G}$ 对应的 $f[i]$ 即可。

为了快速处理，我们可以求出 $f[i]$ 的前缀积和后缀积，这样可以 $\mathcal O(N)$ 算出我们需要的数组。

最后询问我们得到的数组的原形式的最后一项即可（对应状态 $1111....$ ）

但是，这道题有一个优化——因为我们的 $DWT$ 过程都是 “单点改（初始化 $f[i]$ 时我们只将 $f[i][0],f[i][s]$ 赋值为 $1$ ），单点问（最后我们只想问得到的数组的最后一项）”，那么，我们可以想一下怎么 $\mathcal O(N)$ 地将我们的单点修改的影响直接加在 $DWT$ 之后的数组上，怎么 $\mathcal O(N)$ 地询问我们的最后一个位置的值？

这里不做过多解释（似乎不加这个优化吸了氧才堪堪过），具体对应的部分是代码中的 `modify_DWT()` 和 `getLast()` 函数，配套 `getLast()` 的是 `init[]` 数组，可以自行钻研一下。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,__l,__r) for(signed i=(__l),i##_end_=(__r);i<=i##_end_;++i)
#define fep(i,__l,__r) for(signed i=(__l),i##_end_=(__r);i>=i##_end_;--i)
#define erep(i,u) for(signed i=tail[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
typedef long long LL;
typedef pair<int,int> pii;
typedef unsigned long long ull;
typedef unsigned uint;
#define Endl putchar('\n')
// #define int long long
// #define int unsigned
// #define int unsigned long long

#ifdef _GLIBCXX_CSTDIO
#define cg (c=getchar())
template<class T>inline void qread(T& x){
    char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
template<class T>inline T qread(const T sample){
    T x=0;char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
#undef cg
template<class T>void fwrit(const T x){//just short,int and long long
    if(x<0)return (void)(putchar('-'),fwrit(-x));
    if(x>9)fwrit(x/10);
    putchar(x%10^48);
}
#endif
// template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline int gcd(const int a,const int b){return b?gcd(b,a%b):a;}
inline void getInv(int inv[],const int lim,const int MOD){
    inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
inline LL mulMod(const LL a,const LL b,const LL mod){//long long multiplie_mod
    return ((a*b-(LL)((long double)a/mod*b+1e-8)*mod)%mod+mod)%mod;
}

const int MOD=1e9+7;
const int inv2=(MOD+1)>>1;
const int MAXSIT=800;

inline int Get(const int x){int n=1;while(n<=x)n<<=1;return n;}

inline void DWT_or(vector<int>&f,const int opt){
    //if opt==-1, DWT_or will be IDWT_or
    int N=Get((int)f.size()-1);
    f.resize(N);
    for(int t=2;t<=N;t<<=1)
        for(int i=0,p=t>>1;i<N;i+=t)for(int j=i;j<i+p;++j)
            f[j+p]=(0ll+f[j+p]+f[j]*opt+MOD)%MOD;
}
inline void DWT_and(vector<int>&f,const LL opt){
    int N=Get((int)f.size()-1);
    f.resize(N);
    for(int t=2;t<=N;t<<=1)
        for(int i=0,p=t>>1;i<N;i+=t)for(int j=i;j<i+p;++j)
            f[j]=(0ll+f[j]+f[j+p]*opt)%MOD;
}
inline void DWT_xor(vector<int>&f,const LL opt){
    int N=Get((int)f.size()-1);//pay attention to this -1
    f.resize(N);
    int x,y;
    for(int t=2;t<=N;t<<=1)
        for(int i=0,p=t>>1;i<N;i+=t)for(int j=i;j<i+p;++j){
            x=f[j],y=f[j+p];
            f[j]=(0ll+x+y)%MOD,f[j+p]=(0ll+x-y+MOD)%MOD;
            if(opt==-1)f[j]=1ll*f[j]*inv2%MOD,f[j+p]=1ll*f[j+p]*inv2%MOD;
        }
}

int ans[MAXSIT+5],cnt;

int n,g,l,mirl;
int init[1<<16|2];

inline void Init(){
    n=qread(1),g=qread(1),mirl=l=qread(1);
    if(l%g){
        rep(i,1,qread(1))writc(0,'\n');
        exit(0);
    }else l/=g,n/=g;
}

vector<int>ele[2];
int len,sz;//有多少个质因数，状态总数
//ele[0]:保存分解 l 的质因数
//ele[1]:保存分解 l 的这个因数的次方
vector<pii>lst;//保存每个因数以及其对应编号

inline int findPos(const int pos){
    vector<pii>::iterator it=lower_bound(lst.begin(),lst.end(),mp(pos,0));
    return it->second;
}

inline void Dec(){
    for(int i=2,t=0;i*i<=l;++i,t=0)if(l%i==0){
        while(l%i==0)l/=i,++t;
        ele[0].push_back(i);
        ele[1].push_back(t);
        // printf("this part, i == %d, t == %d\n",i,t);
    }
    if(l!=1)ele[0].push_back(l),ele[1].push_back(1);
    // printf("this part, i == %d, t == %d\n",l,1);
}

inline void MakeInit(){
    sz=1<<((len=ele[0].size())<<1);
    init[sz-1]=1;
    for(int i=1;i<sz;i<<=1)for(int j=sz-1;j>=sz-i;--j)
        init[j-i]=-init[j];
}

inline void modify_DWT(vector<int>&f,const int pos,const int delta){
    int n=Get(f.size()-1);
    f.resize(n);
    // printf("Now n == %d, pos == %d\n",n,pos);
    rep(i,0,n-1){
        if((i&pos)==0){
            // printf("udpate %d\n",i+pos);
            f[i+pos]+=delta;
            if(f[i+pos]>=MOD)f[i+pos]-=MOD;
        }
    }
}
inline int getLast(vector<int>&f){
    int ret=0,sz=f.size();
    rep(i,0,sz-1){
        ret+=f[i]*init[i];
        if(ret<0)ret+=MOD;
        else if(ret>=MOD)ret-=MOD;
    }return ret;
}

vector<int>f[MAXSIT+5];

inline int print(int now){
    while(now){
        if(now&1)putchar('1');
        else putchar('0');
        now>>=1;
    }
}

void dfs(const int i,int now,const int s){
    if(i==len){//枚举了一个因数
        ans[++cnt]=-1;//更新因数编号
        lst.push_back(mp(now,cnt));//并将其放进所有的因数集合中
        // printf("this num,now == %d, cnt == %d, s == ",now,cnt);print(s);Endl;
        f[cnt].resize(sz);
        // printf("modify_DWT(%d,%d,%d)\n",cnt,0,1);
        // printf("modify_DWT(%d,%d,%d)\n",cnt,s,1);
        modify_DWT(f[cnt],0,1);//要么就不选这个因数
        modify_DWT(f[cnt],s,1);//选上这个因数，那么其状态为 s 的那一位也为 1
    }else{
        int ti=ele[0][i],tl=ele[1][i];
        rep(t,0,tl){//枚举这个因数中，第 i 个质因数的次方
            if(t==0)dfs(i+1,now,s<<2|2);//如果他没有这个因数，那么他限定下界
            else if(t==tl)dfs(i+1,now,s<<2|1);//如果他的因数与 lcm 对应，那么他限定上界
            else dfs(i+1,now,s<<2);//十分平凡
            if(1ll*now*ti<=n)now*=ti;//保证因数在 n 的范围之内
            else return;
        }
    }
}

int sum[2][MAXSIT+5][1<<16];
//前缀积和后缀积
vector<int>t;

int all;

inline void preSolve(){
    rep(i,0,sz)sum[0][0][i]=sum[1][cnt+1][i]=1;
    rep(i,1,cnt)rep(j,0,sz-1)sum[0][i][j]=1ll*sum[0][i-1][j]*f[i][j]%MOD;
    fep(i,cnt,1)rep(j,0,sz-1)sum[1][i][j]=1ll*sum[1][i+1][j]*f[i][j]%MOD;
    t.resize(sz);
    rep(i,0,sz-1)t[i]=sum[0][cnt][i];
    all=getLast(t);
    // printf("all == %d\n",all);
}

signed main(){
    // ios::sync_with_stdio(false);
    Init();
    Dec();
    MakeInit();
    dfs(0,1,0);//枚举其所有满足条件的因数
    preSolve();
    sort(lst.begin(),lst.end());
    int pos;
    rep(i,1,qread(1)){
        pos=qread(1);
        if(pos%g || mirl%pos || pos/g>n){
            writc(0,'\n');continue;
        }
        pos=findPos(pos/g);
        // printf("pos == %d\n",pos);
        if(ans[pos]==-1){
            rep(i,0,sz-1)t[i]=1ll*sum[0][pos-1][i]*sum[1][pos+1][i]%MOD;
            // printf("getLast() == %d\n",getLast(t));
            ans[pos]=all-getLast(t);
            if(ans[pos]<0)ans[pos]+=MOD;
            else if(ans[pos]>=MOD)ans[pos]-=MOD;
        }writc(ans[pos],'\n');
    }
    return 0;
}
```



---

## 作者：hzoi_liuchang (赞：1)

## 分析

先特判掉 $G$ 不能整除 $L$ 的情况

然后把 $L$ 和 $n$ 同时除以 $G$

这样问题就转化为了在 $1$  到 $n$ 中选择一些数

使得他们的最大公因数为 $1$，最小公倍数为 $L$

将 $L$ 进行质因数分解，设 $L=p_1^{a_1}p_2^{a_2}...p_n^{a_n}$

如果要满足条件

那么对于任意一个质因数 $p_i$ ，选择的数中必须至少存在一个数，使得它分解质因数后 $p_i$ 的指数等于 $a_i$

同理，对于任意一个质因数 $p_i$ ，选择的数中必须至少存在一个数，不含有 $p_i$ 这个质因数

第一个条件可以看做是否满足上界，第二个条件可以看作是否满足下界

因为 $L$ 小于等于 $10^{8}$，所以最多含有 $8$ 个不同的质因数

因此可以状压

设 $11$ 表示同时满足上界和下界，$10$ 表示只满足上界，$01$ 表示只满足下界，$00$ 表示上界和下界都不满足

显然满足条件的只能是 $L$ 的因数，我们可以把 $L$ 的所有因数都筛出来

然后求出这些因数所代表的状态

因数不会太多，最多只有 $768$ 个

如果没有必须选择 $x$ 的限制，那么直接设 $f[i][j]$ 表示考虑前 $i$ 个数，状态为 $j$ 的方案数进行 $dp$ 即可

如果考虑 $x$ 的限制，我们就需要维护一个前缀 $dp$ 数组 $pre$ 和后缀 $dp$ 数组 $suf$

对于第 $i$ 个数，我们把 $pre[i-1]$ 和 $suf[i+1]$ 进行或运算卷积

最后只要第 $i$ 个数的状态与某个状态进行或运算等于全集

那么就可以累加这个状态的答案

## 代码
``` cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int mod=1e9+7,maxn=70005,maxm=1005;
int n,g,l,q,x,mmax;
int getmod(rg int now){
	return now>=mod?now-mod:now<0?now+mod:now;
}
void fwtor(rg int A[],rg int typ){
	for(rg int o=2,k=1;o<=mmax;o<<=1,k<<=1){
		for(rg int i=0;i<mmax;i+=o){
			for(rg int j=0;j<k;j++){
				A[i+j+k]+=A[i+j]*typ;
				A[i+j+k]=getmod(A[i+j+k]);
			}
		}
	}
}
int pri[maxn],mi[maxn];
void divid(rg int now){
	rg int m=sqrt(now),ncnt=0;
	for(rg int i=2;i<=m;i++){
		if(now%i==0){
			ncnt=0;
			pri[++pri[0]]=i;
			while(now%i==0){
				now/=i;
				ncnt++;
			}
			mi[pri[0]]=ncnt;
		}
	}
	if(now>1){
		pri[++pri[0]]=now;
		mi[pri[0]]=1;
	}
}
int sta[maxn],tp,zt[maxn];
void getit(){
	rg int m=sqrt(l);
	for(rg int i=1;i<=m;i++){
		if(l%i==0){
			if(i<=n) sta[++tp]=i;
			if(i*i!=l && l/i<=n) sta[++tp]=l/i;
		}
	}
}
int pre[maxm][maxn],suf[maxm][maxn],tmp[maxn],ans[maxn];
int getzt(rg int now){
	rg int zt0=0,zt1=0;
	for(rg int i=1;i<=pri[0];i++){
		rg int ncnt=0;
		while(now%pri[i]==0){
			now/=pri[i];
			ncnt++;
		}
		if(ncnt==0) zt0|=(1<<(i-1));
		else if(ncnt==mi[i]) zt1|=(1<<(i-1));
	}
	return zt0|(zt1<<pri[0]);
}
int main(){
	n=read(),g=read(),l=read(),q=read();
	if(l%g){
		for(rg int i=1;i<=q;i++){
			x=read();
			printf("0\n");
		}
	} else {
		l/=g,n/=g;
		divid(l);
		mmax=1<<(2*pri[0]);
		getit();
		std::sort(sta+1,sta+1+tp);
		for(rg int i=1;i<=tp;i++) zt[i]=getzt(sta[i]);
		pre[0][0]=suf[tp+1][0]=1;
		for(rg int i=1;i<=tp;i++){
			memcpy(pre[i],pre[i-1],sizeof(pre[i-1]));
			for(rg int j=0;j<mmax;j++){
				pre[i][j|zt[i]]=getmod(pre[i][j|zt[i]]+pre[i-1][j]);
			}
		}
		for(rg int i=tp;i>=1;i--){
			memcpy(suf[i],suf[i+1],sizeof(suf[i+1]));
			for(rg int j=0;j<mmax;j++){
				suf[i][j|zt[i]]=getmod(suf[i][j|zt[i]]+suf[i+1][j]);
			}
		}
		for(rg int i=0;i<=tp+1;i++){
			fwtor(pre[i],1);
			fwtor(suf[i],1);
		}
		for(rg int i=1;i<=tp;i++){
			for(rg int j=0;j<mmax;j++){
				tmp[j]=1LL*pre[i-1][j]*suf[i+1][j]%mod;
			}
			fwtor(tmp,-1);
			for(rg int j=0;j<mmax;j++){
				if((zt[i]|j)==mmax-1) ans[i]=getmod(ans[i]+tmp[j]);
			}
		}
		for(rg int i=1;i<=q;i++){
			x=read();
			if(x%g) printf("0\n");
			else {
				x/=g;
				if(l%x) printf("0\n");
				else {
					rg int wz=std::lower_bound(sta+1,sta+1+tp,x)-sta;
					printf("%d\n",ans[wz]);
				}
			}
		}
	}
	return 0;
}
```

---


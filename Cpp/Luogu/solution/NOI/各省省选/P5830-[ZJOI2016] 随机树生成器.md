# [ZJOI2016] 随机树生成器

## 题目背景

附加文件及样例可在页面底部「附件」中下载。

## 题目描述

小 Y 最近有了一个随机数生成器 (random number generator)。小 Y 想用这个随机数生成器生成 $n$ 个节点的树。树为一种没有环的无向连通图。

经过小 Y 的研究，她发现了 $4$ 种随机树生成方法。

第一种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \leq i \leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $1$ 到 $i-1$ 中的随机整数。

第二种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \leq i \leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $\lfloor \frac {i}{2} \rfloor$ 到 $i-1$ 中的随机整数。

第三种方法为首先有一个 $n$ 个点的图，里面没有边。接着等概率地随机生成点对 $u,v$ ，如果当前图中 $u,v$ 不连通，那么将边 $(u,v)$ 加入到图中。重复这个过程，直到这个图连通为止。

第四种方法为在所有 $n$ 个点的不同的有标号的树中，等概率地随机选取一棵树。两个树是不同的当且仅当存在一条边 $(u,v)$ 只出现在其中一棵树中。比如 $(1,2),(1,3)$ 和 $(1,2),(2,3)$ 是两棵不同的树。

小 Y 用这四种方法生成了很多棵 $n$ 个节点的树，但她忘记了这些树分别由哪种方法生成的。你能帮帮她辨认这些树由哪种随机方法生成吗？

在这个题目中令 $n=1000$，也就是小 Y 生成的树的节点个数都为 $1000$。

## 说明/提示

对于所有的测试数据，保证输入的树是由上述四种方式随机生成。  

各测试点满足以下约定：   

| 测试点 | $m$ | 约定|
| --- | --- | --- |
| 1 | $=2000$ | 只会出现第 $1,2$ 种生成方式 |
| 2 | $=3000$ | 只会出现第 $1,2,3$ 种生成方式 |
| 3 | $=3000$ | 只会出现第 $1,3,4$ 种生成方式 |
| 4 | $=4000$ | 无 |
| 5 | $=4000$ | 无 |

对于每个测试点，保证每种可能出现的生成方式恰好出现 $1000$ 次。

#### 评分方式

对于每个测试点，有 $10$ 个评分参数 $a_{10},a_9,a_8,…,a_1$。

如果你的输出中错误的答案个数为 $x$, 那么你将获得 $2s$ 的分数，其中 $s$ 为满足 $x \leq a_s$ 最大的整数。如果 $x>a_1$，那么你将获得 $0$ 分。

如果输出格式有异常你将同样获得 $0$ 分，请确保你的输出中共有 $m$ 行，每行为一个 $1$ 到 $4$ 之间的正整数。

对于每个测试点的具体评分参数见附加文件中的 `scores`。

## 样例 #1

### 输入

```
见附件```

### 输出

```
见附件```

# 题解

## 作者：wishapig (赞：7)

### 题目大意：

给出 $4$ 种随机生成树的方式，然后有 $m$ 组询问，每次给出一棵大小为 $1000$ 的树，问是用哪种方式生成的。

$1\le m\le 4000$

---

这题很有趣啊，就是个概率统计题嘛。

首先四种树的生成方法决定了生成出来的树一定是有一些特征的，但像我这种数学不好的人当然是不会概率分析的啦，那怎么办呢？

就像在正方形里随机撒点去近似 $\pi$ 一样，我们可以按一种方式随机生成大量的树然后去对每种特征去做统计。

具体的思想就是利用极微小的可允许误差去做判断。

举个例子就是比如有两种方法生成一个随机整数，方法 $T_1$ 生成的整数范围为 $(-\infty,1]$，方法 $T_2$ 生成的整数范围为 $[0,\infty)$，而且通过随机撒点（随机生成整数）知道：用 $T_1$ 随机生成 $2\times 10^5$ 个整数，其中有 $10$ 个为 $1$，用 $T_2$ 随机生成 $2\times 10^5$ 个整数，其中有 $15$ 个为 $1$，那么如果我们得到了一个随机整数 $x$，若 $x\le 0$ 则判为 $T_1$ 生成，否则为 $T_2$ 生成，出错概率近似可以认为是 $P=\dfrac{10}{2\times 10^5}+\dfrac{15}{2\times 10^5}=0.000125$。

那么同理，对于判定生成随机树的方式，我们需要寻找一个函数 $f(T)$，以一棵树 $T$ 为自变量，当 $T$ 用两种不同的随机方法生成时，分别对应的 $f(T)$ 范围是**几乎不交**的（指按随机撒点的方式出错的样本点个数相对样本总数很小），那么即可在一定可控的误差内做出判定。

用一个 $f(T)$ 作为判断标准判出一种方法，找三个有效的 $f(T)$ 即可。

代码就不给了，给个 maker 吧，这题有趣的地方就在于尝试各种不同的 $f(T)$。

maker 中附有各个函数的意义及使用方法。（我在跑 maker 的时候都是撒 $2\times 10^5$ 个点）

最终的可行结果是：

- 记 deg 的方差，若方差除以 $100000$ 下取整后 $\ge16000$ 则判定为 $1$。

- 在之前的基础上，若每个点各个子树大小的对数之和 $\ge 11805$ 则判定为 $4$。

- 在之前的基础上，若每个点到最远一度点距离之和 $\le 2490$ 则判定为 $2$，否则为 $3$。

**不保证按本地的随机撒点结果一定可以获得满分**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1005;
const int M=1e7+5;
int Head[N],vet[N<<1],Next[N<<1];
int p[N],x[N],y[N],fa[N],f[N],g[N],deg[N],pos[N],vis[N],siz[N],dis[N];
ll vec[M],U[M],D[M];
int L,tp,tq,edgenum,len,res;
int Find(int u){ return fa[u]==u?u:fa[u]=Find(fa[u]); }
void gen1(){  //第一种生成方法
	for (int i=1; i<=1000; i++) p[i]=i;
	random_shuffle(p+1,p+1+1000);
	for (int i=2; i<=1000; i++) x[i-1]=p[rand()%(i-1)+1],y[i-1]=p[i];
}
void gen2(){  //第二种生成方法
	for (int i=1; i<=1000; i++) p[i]=i;
	random_shuffle(p+1,p+1+1000);
	for (int i=2; i<=1000; i++) x[i-1]=p[i/2+rand()%(i-i/2)],y[i-1]=p[i];
}
void gen3(){  //第三种生成方法
	for (int i=1; i<=1000; i++) fa[i]=i;
	int cnt=0;
	while (cnt<999){
		int u=rand()%1000+1,v=rand()%1000+1;
		if (Find(u)!=Find(v)){
			cnt++; x[cnt]=u,y[cnt]=v;
			fa[Find(u)]=Find(v);
		}
	}
}
void gen4(){  //第四种生成方法，随机prufer序列
	for (int i=1; i<=998; i++) p[i]=rand()%1000+1;
	set<int> s;
	memset(vis,0,sizeof(vis));
	for (int i=1; i<=998; i++) vis[p[i]]++;
	for (int i=1; i<=1000; i++)
		if (!vis[i]) s.insert(i);
	for (int i=1; i<=998; i++){
		int t=*s.begin();
		x[i]=t,y[i]=p[i];
		s.erase(t); vis[p[i]]--;
		if (!vis[p[i]]) s.insert(p[i]);
	}
	int t=*s.begin();
	s.erase(t);
	x[999]=t,y[999]=*s.begin();
}
void gen(int t){
	if (t==1) gen1();
	if (t==2) gen2();
	if (t==3) gen3();
	if (t==4) gen4();
}
void dfs(int u, int F){
	f[u]=1,g[u]=0;
	for (int e=Head[u]; e; e=Next[e]){
		int v=vet[e];
		if (v==F) continue;
		dfs(v,u);
		if (f[v]+1>f[u]) g[u]=f[u],f[u]=f[v]+1;
		else if (f[v]+1>g[u]) g[u]=f[v]+1;
	}
}
void solve1(){
	int ans=0; dfs(1,0);
	for (int i=1; i<=1000; i++) ans=max(ans,f[i]+g[i]);
	vec[++len]=ans;
}
void solve2(){
	int ans=0;
	for (int i=1; i<=1000; i++) ans+=(deg[i]==2);
	vec[++len]=ans;
}
void solve10(){
	int ans=0; dfs(1,0);
	for (int i=1; i<=1000; i++) ans+=f[i]+g[i];
	vec[++len]=ans;
}
void solve14(){
	int ans=0; dfs(1,0);
	for (int i=1; i<=1000; i++) ans+=f[i]*f[i]+g[i]*g[i];
	vec[++len]=ans/50;
}
void solve3(){
	int ans=0;
	for (int i=1; i<=1000; i++) ans+=deg[i]*deg[i];
	vec[++len]=ans;
}
void solve4(){
	ll ans=0,sum=0;
	for (int i=1; i<=1000; i++) sum+=deg[i];
	for (int i=1; i<=1000; i++) ans+=1ll*(1000*deg[i]-sum)*(1000*deg[i]-sum);
	vec[++len]=ans/100000;
}
void dfs1(int u, int f){
	siz[u]=1; int mx=0;
	for (int e=Head[u]; e; e=Next[e]){
		int v=vet[e];
		if (v==f) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		mx=max(mx,siz[v]);
	}
	mx=max(mx,1000-siz[u]);
	if (mx<res) res=mx;
}
int dfs2(int u, int f){
	siz[u]=1; int mx=0,sum=0;
	for (int e=Head[u]; e; e=Next[e]){
		int v=vet[e];
		if (v==f) continue;
		sum+=dfs2(v,u);
		siz[u]+=siz[v];
		mx=max(mx,siz[v]);
	}
	mx=max(mx,1000-siz[u]);
	return sum+mx;
}
void solve5(){
	dfs1(1,0); int ans=0;
	for (int i=1; i<=1000; i++) ans+=siz[i];
	vec[++len]=ans;
}
void solve6(){
	dfs1(1,0); int ans=0;
	for (int i=1; i<=1000; i++) ans+=siz[i]*siz[i];
	vec[++len]=ans;
}
void solve7(){
	dfs1(1,0);
	ll ans=0,sum=0;
	for (int i=1; i<=1000; i++) sum+=siz[i];
	for (int i=1; i<=1000; i++) ans+=1ll*(1000*siz[i]-sum)*(1000*siz[i]-sum);
	vec[++len]=ans/100000;
}
void solve8(){ res=1e9; dfs1(1,0); vec[++len]=res; }
void solve9(){ vec[++len]=dfs2(1,0); }
double dfs3(int u, int f){
	siz[u]=1; double sum=0;
	for (int e=Head[u]; e; e=Next[e]){
		int v=vet[e];
		if (v==f) continue;
		sum+=dfs3(v,u);
		siz[u]+=siz[v];
	}
	sum+=log2(siz[u])+log2(1001-siz[u]);
	return sum;
}
void solve11(){ vec[++len]=dfs3(1,0); }
void solve12(){
	queue<int> que; int ans=0;
	for (int i=1; i<=1000; i++)
		if (deg[i]==1) que.push(i),dis[i]=1;
		else dis[i]=1e9;
	while (!que.empty()){
		int u=que.front(); que.pop();
		for (int e=Head[u]; e; e=Next[e]){
			int v=vet[e];
			if (dis[v]!=1e9) continue;
			deg[v]--;
			if (deg[v]==1) que.push(v),dis[v]=dis[u]+1;
		}
		ans+=dis[u]*dis[u];
	}
	vec[++len]=ans;
}
void solve13(){
	int ans=0;
	for (int i=1; i<=1000; i++) ans+=(deg[i]==1);
	for (int i=1; i<=1000; i++) ans-=(deg[i]==2);
	vec[++len]=ans;
}
void solve(int t){
	if (t==1) solve1(); //直径
	if (t==2) solve2(); //二度点个数
	if (t==3) solve3(); //deg的平方和
	if (t==4) solve4(); //deg的方差 
	if (t==5) solve5(); //以1为根的子树大小之和
	if (t==6) solve6(); //以1为根的子树大小的平方和
	if (t==7) solve7(); //以1为根的子树大小的方差
	if (t==8) solve8(); //重心的最大子树大小
	if (t==9) solve9(); //我也不知道这个是在干啥。。。
	if (t==10) solve10(); //每个点子树中最长链+次长链的长度
	if (t==11) solve11(); //每个点各个子树大小的对数之和
	if (t==12) solve12(); //每个点到最远一度点距离的平方和
	if (t==13) solve13(); //一度点个数-二度点个数
	if (t==14) solve14(); //每个点子树中最长链平方+次长链平方
}
inline void addedge(int u, int v){
	edgenum++;
	vet[edgenum]=v;
	Next[edgenum]=Head[u];
	Head[u]=edgenum;
}
int main(){
	scanf("%d%d%d",&L,&tp,&tq);
	//L为随机撒点的个数，tp为生成树的方法（标号与题目中相同），tq为尝试的不同函数的编号
	signed a[5000],sum;
	for (int i=0; i<5000; i++) sum+=a[i];
	srand(sum);
	for (int o=1; o<=L; o++){
		gen(tp);
		memset(deg,0,sizeof(deg));
		memset(Head,0,sizeof(Head)); edgenum=0;
		for (int i=1; i<1000; i++){
			addedge(x[i],y[i]),addedge(y[i],x[i]);
			deg[x[i]]++,deg[y[i]]++;
		}
		solve(tq);
		if (o%1000==0) printf("==>%d times\n",o); //表示目前撒了多少样本点了
	}
	ll mn=1e18,mx=-1e18;
	for (int i=1; i<=L; i++) mx=max(mx,vec[i]),mn=min(mn,vec[i]);
	printf("%lld %lld\n",mn,mx);  //特征值的范围
	
	ll P=0; scanf("%lld",&P); //给出均分[min,max]的长度
	ll cur=mn; int tot=0;
	while (cur<=mx){
		D[++tot]=cur;
		U[tot]=(cur+P-1>=mx?mx:cur+P-1);
		cur+=P;
	}
	for (int i=1; i<=L; i++)
		for (int j=tot; j>=1; j--)
			if (vec[i]<=U[j] && vec[i]>U[j-1]){ pos[j]++; break; }
	for (int i=1; i<=tot; i++) printf("%lld %lld %d\n",D[i],U[i],pos[i]); //表示特征值在[D,U]中的样本点个数
	return 0;
}
```
好像最终写出来只有 1.4k 比其他代码短得多？


---

## 作者：comcopy (赞：7)

#   **题意**

  小 Y 造了 $T$ 次树。

  每次造了 $m$ 棵，每棵 $n$ 个节点。

  小 Y 有四种方法造树，这四种方法对我们来说可是大麻烦。

  但是多亏了小 Y 良心发现，把 $n$ 固定在了 $1000$，为我们省了一个判断。

#   思路

  小 Y 有四种方法造树。
  
  要想分辨不同的方法造出的树，自然要试着模拟然后统计四个树的特征。

  以下四个标号分别代表四种方案：
  
  由于性质比较特殊 ( 2 的范围比1更小 ) 所以我决定先讲 2。
  
   2.对于每个点 $i$ ,概率与 $1\le j\le \lfloor \frac{i-1}{2} \rfloor$连边。
   
   事实上很简单。
   
   我们强制要求所有树以 $1$ 为根节点且强制要求这个树按值域分类要求比根节点小的在左子树，比根大的在右边，由于是全排列，不存在等于，可以安心许多。
   
   由于每个点 $i$ 都不可能与小于 $\frac{i-1}{2}$ 的点连边，因此会发现所有大于 $i$ 的点都不可能与 $i$ 不可能连到的点连边，因此我们可以发现 2 是无法与 1 连边的。3 要在右子树只能与 1 连边,且 n 必然为它所在子树的最右节点，这样有用的性质对我们就大大增多了。因为我们可以发现每到一个 i 选点，所有上一次剩下的点被选中的概率 必然会增加，因为这次不选的话，下次选点的边界往右移了，新人笑老人哭了，~~(再不放纵一把~~ 就没法保证连通了。
  

  1. 对于每个点 $i$ ,概率与 $1\le j\le i-1$连边。
  
  相信大家都能发现 1 与 2 基本是同母异父 ~~(悲~~ 的亲兄弟了。经过我上面一番慷慨乱扯，可以发现 1 与 2 的性质就差在 $\lfloor \frac{i}{2} \rfloor \sim i-1$ 与 $i$ 有无连边了，这里必然不能鸡蛋里挑骨头地去想是不是可能用 1 生成时所有点都刚好选在了 $1\sim \lfloor \frac{i}{2} \rfloor$ 里，想都不要想，这是纯属犯欠。 ~~(放我那是要被数学老师和科学老师挑起来打的。~~ 而我们会发现这样子选点的话，一条路走到黑，或是雨露均沾，就是链或菊花图等极端情况概率是特别特别小的，不妨遇到那种深度很大的树直接丢给 3,4 两种情况。
  
 




  3. 等概率随机选出点对 $( u , v )$ 若两点连通就跳过，不连通就连上。
  
  根据树的定义，我们可以发现根本没必要随机两个数，因为所有点最终都会连在一颗树上，不妨直接把 1 看作根结点，把其它点看作散点，每次操作就是从树上随机选取一个点与散点匹配，这样操作起来绝对比什么连来连去在合并啥的舒服多了。
  
  而我们还是看概率，会发现每一次选入一个点进树，树上每个点被选中的概率都会减少，散点中每个点被选中的概率都会增多，因此我们很好地发现这个性质与 1 似乎有点相像?
  
  其实不 ~~（然~~，就是这样！虽然小 Y 选点的时候，是不按规律的，但是我们可以强制让他按规矩办事 ~~（直接规定从 1 开始枚举 u )~~ 就会发现，每一次选点的概率是一样的，只不过是值域不同而已。似乎不大好与 1
区分的亚子，所以我们先看到 4 吧。	

  

  4. 随机选取一个 n 个点的树。
  
 好家伙，方法 4 直接放飞自我了。我们可以发现方案 4 唯一的性质就是平等，无论树的深度，无论任意两点，连边的概率都是一样的。但转念一想，菊花图，链等深度特别小或是特别大的图，好像都可以直接丢给4来背黑锅？
 
 这一看，4 貌似就可爱多了呢。
 
 事实上，这就是一道概率题吧。 ~~（毒瘤成这样也无话可说。)~~ 
 
 做的时候也是一头雾水对着自己打出来的表懵逼半天 ~~(最后还是靠老师指点才过的~~ ，实在是太屑了。




#   **程序**

```cpp
#include<bits/stdc++.h>
#include<cassert>
using namespace std;
typedef vector<int> VI; 
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) 
{
	ll res=1;
	a%=mod;
	for(;b;b>>=1)
	{
		if(b&1)  
			res=res*a%mod;
		a=a*a%mod; 
	}
	return res;
}
const int N=1000;
int sz[N+10],d[N+10],dis[N+10],q[N+10],cnt[N+10],com,u,v,tc;
vector<int> e[N+10];
double c0;
void dfs2(int u,int f) 
{
	sz[u]=1;
	for(register int i=0;i<(int)(e[u].size());++i) 
	{
		int v=e[u][i];
		if(v==f) 
			continue;
		dfs2(v,u); 
		sz[u]+=sz[v];
	}
	if(sz[u]<N) 
		c0+=log(sz[u])+log(N-sz[u]);
}
int id;
int sep23(int c1,int c2)
{
	if(c1<=23) 
		return 2;
	if(c1>=27)
		 return 3;
	if(c1==24) 
	{
		if(c2>=3)
			 return 2; 
		else 
			return 3;
	}
	if(c1==25) {
		if(c2>=6) 
			return 2; 
		else 
			return 3;
	}
	if(c1==26) {
		if(c2>=9) 
			return 2; 
		else
			return 3;
	}
	return 0;
}
int check()
{
	c0=0;
	dfs2(1,0);
	for(register int i=1;i<N+1;++i)
		d[i]=(int)(e[i].size());
	int t=0;
	memset(dis,0,sizeof(dis));
	memset(cnt,0,sizeof(cnt));
	for(register int i=1;i<N+1;++i)
		if (d[i]==1)
		{
			q[t++]=i;
			cnt[dis[i]=1]++;
		}
	for(register int i=0;i<t;++i)
		for(register int j=0;j<(int)(e[q[i]].size());++j)
		{
			int v=e[q[i]][j];
			if((--d[v])==1) 
			{
				q[t++]=v;
				dis[v]=dis[q[i]]+1; 
				cnt[dis[v]]++;
			}
		}
	int c1=*max_element(dis+1,dis+N+1);
	int c2=0; 
	for(register int i=1;i<=c1;++i)
		c2+=(cnt[i]<=2); 
    
	if (c0<=7800) 
		return 1;
     
	if (id==1) 
		return 2;		
	if (id==2) 
		return sep23(c1,c2);
	if (id==3) 
	{
		if (c0>=8178) 
			return 4;
		if (c0>=8155)
		{
			if (c1<38)
				return 4;
			else
				return 3;
		}
		return 3;
	}
	if (id==4||id==5) 
	{ 
		if (c0>=8178) 
			return 4;
		if (c0>=8155) 
		{
			if (c1<38) 
				return 4;
			else 
				return 3;
		}
		return sep23(c1,c2);
	}
	return 0;
}
int main()
{
	scanf("%d",&id); 
	for(scanf("%d",&com);com;--com)
	{
		for(register int i=1;i<=N;++i) 
			e[i].clear();
		for(register int i=1;i<N;++i)
		{
			scanf("%d%d",&u,&v);
			e[u].push_back(v);
			e[v].push_back(u);
		}
		printf("%d\n",check());
	}
}
```

# 最后

蒟蒻第一篇题解,有问题欢迎大佬指出。



---


# [ZJOI2020] 字符串

## 题目背景

3s，512MB

## 题目描述

Bob 喜欢字符串。

Bob 觉得，重复两遍的字符串是优美的，例如，`aa`，`sese`，`abcabc`，`baabaa`，`abababab`是优
美的串，而 `ab`，`aadead`，`sesese`，`abba` 不是。更具体地说，如果一个字符串 $S$ 能够被写成两个相同的字符串前后拼接的形式，即存在字符串 $P$ 使得 $S=PP$，那么 $S$ 就是优美的。

Bob 有一个长度为 $n$ 的字符串 $T=T_1T_2 \cdots T_n$。现在他想知道，给定 $T$ 的一个子串 $Q=T[l \cdots r]$，这个子串 $Q$ 内一共包含多少种本质不同的优美的串作为子串。如果两个串相同，但是出现的位置不同，那么这两个串不是本质不同。

Bob 一共有 $q$ 组不同的询问，你需要快速计算出答案。

## 说明/提示

样例解释 $1$：

$|T|$ 有 `aa`，`aaaa`，`abaaba`，`aabaab`，`baabaa` 这些本质不同的优美的串。

样例输入输出 2 见附件。

对于前 $10\%$ 的数据，$n \leq 100$。

对于前 $20\%$ 的数据，$n \leq 500$。

对于前 $40\%$ 的数据，$n \leq 5000$。

对于另外 $20\%$ 的数据，保证 $T$ 中所有的优美的串的个数不超过 $10^6$，这里位置不同的串被视为不同的。

对于另外 $20\%$ 的数据，$q = 1$。

对于 $100\%$ 的数据，$1 \leq n, q \leq 200000,1 \leq l \leq r \leq n$，$T$ 只包含小写字母 `a` 和 `b`。

## 样例 #1

### 输入

```
11 5
aabaabaaaab
1 11
1 6
7 10
5 5
3 8
```

### 输出

```
5
2
2
0
2```

# 题解

## 作者：Lagoon (赞：12)

首先，根据runs的那套理论，位置不同的本原平方串（即最小整周期恰为 $len \over 2$ 的串）是 $O(n \log n)$ 的，显然所有平方串都是由某一个本原平方串复制若干遍得到的，然后我们先用传统的枚举周期SA/二分hash的方法求出若干的周期三元组 $(x,l,r)$ ，代表在区间 $[l,r]$ 中任意一个长为 $x$ 的倍数的子串整周期均为 $x$ ，然后如果串 $[l,l+2x-1]$ 是循环串，则 $x$ 不为最小整周期，那么这个周期三元组可以直接去掉。

然后我们考虑这一个周期三元组的贡献，我们记贡献组 $(x,y,v)$ 表示它对满足 $[x,y] \in [l',r']$ 的询问区间 $[l',r']$ 有 $v$ 的贡献。那么对于一个周期三元组 $(x,l,r)$ ，长度为 $2x$ 的平方串贡献就为 $(a,a+2x-1,1) , a \in [l,r-2x+1]$ 和 $(a,a+3x-1,-1) , a \in [l,r-3x+1]$ ，同理，长度为 $2kx$ 的平方串贡献为 $(a,a+2kx-1,1) , a \in [l,r-2kx+1]$ 和 $(a,a+(2k+1)x-1,-1) , a \in [l,r-(2k+1)x+1]$ ，根据runs那套理论，这显然是不超过 $O(n \log n)$ 的。

还有一种情况就是不同周期三元组之间可能产生相同的平方串，这种情况的处理是容易的：首先你从前到后考虑每个周期三元组，然后对每个周期三元组找出它包含的所有长度为 $2x$ 倍数的平方串（这和位置不同的本原平方串数量相等），然后找出它在这之前最后出现在哪里（在处理前面的时候记一下即可）还有在这个周期三元组第一次出现在哪里，然后把重复的贡献减掉即可。

然后对每个询问计算贡献就是一个斜线加矩形求和的二维数点，容易实现。

复杂度 $O(n \log^2 n)$ 。

#### 代码（二分hash版本）
```cpp
#include<bits/stdc++.h>
#define re register
#define ull unsigned long long
char ss[200100];
const ull base=61,inv=5745707170499696405llu;
ull hs[200100],ex[200100],rex[200100];
int n;
inline ull get(re int l,re int r)
{
	return hs[r]-hs[l-1]*ex[r-l+1];
}
inline bool equ(re int a,re int b,re int len)
{
	return get(a,a+len-1)==get(b,b+len-1);
}
int LCP(re int a,re int b)
{
	re int l=0,r=std::min(n-a+1,n-b+1);
	for(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)
	{
		if(equ(a,b,mid))l=mid;
		else r=mid-1;
	}
	return l;
}
int LCS(re int a,re int b)
{
	re int l=0,r=std::min(a,b);
	for(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)
	{
		if(equ(a-mid+1,b-mid+1,mid))l=mid;
		else r=mid-1;
	}
	return l;
}
std::vector<std::pair<int,int> >vc[200100],mc[200100];
std::vector<int>qry[400100];
int cnt,l[200100],r[200100],f[200100];
long long ans[200100];
std::unordered_map<ull,int>mp;
void add(re int x,re int ad)
{
	for(;x;x-=x&-x)f[x]+=ad;
}
struct par
{
	int x,y,v;
}pc1[10001000],pc2[10001000];
inline bool cmp(const par&A,const par&B){return A.x<B.x;}
int cct1,cct2; 
int qr(re int x)
{
	re int ans=0;
	for(;x<=n;x+=x&-x)ans+=f[x];
	return ans;
}
int ans1;
void adp(re int x1,re int x2,re int y1,re int y2,re int v)
{
	pc1[++cct1]={y1-x1,x1,v};
	pc1[++cct1]={y1-x1,x2+1,-v};
	pc2[++cct2]={y1-x1,y1,v};
	pc2[++cct2]={y1-x1,y2+1,-v};
}
int f1[200100],f2[200100];
void add1(re int a,re int ad)
{
	re int ad1=ad*a;
	for(;a<=n;a+=(a&-a))f1[a]+=ad,f2[a]+=ad1;//printf("**ad**%d\n",n);
}
long long sum(re int a)
{
	re int ans=0;
	re int a1=a;
	for(;a;a-=(a&-a))ans+=(a1+1)*f1[a]-f2[a];
	return ans;
}
int main()
{
	re int q,x,y;
	scanf("%d%d",&n,&q);
	scanf("%s",ss+1);
	ex[0]=rex[0]=1;
	for(re int i=1;i<=n;i++)hs[i]=hs[i-1]*base+(ss[i]-'a'+1),ex[i]=ex[i-1]*base,rex[i]=rex[i-1]*inv;
	for(re int i=1;i<=n;i++)
	{
		for(re int j=i;j+i<=n;j+=i)
		{
			re int ls=LCS(j,j+i),lp=LCP(j+1,j+i+1);
			if(ls==0||ls>i||ls+lp<i)continue;
			re int bg=j-ls+1,ed=j+i+lp;
			for(auto x:vc[bg])if((!(i%x.first))&&x.second>=i){ls=0;break;}
			if(ls==0)continue;
			for(re int i1=bg;i1+2*i-1<=ed;i1++)
			{
				vc[i1].push_back(std::make_pair(i,ed-i1+1));
				re ull nw=get(i1,i1+2*i-1);
				re int nv;
				if(!mp[nw])mp[nw]=++cnt;
				nv=mp[nw];
				re int len=(i1-bg)/i;
				if(!(len&1))
				{
					len=len/2;
					if(mc[nv].size()>len)
					{
						adp(mc[nv][len].first,mc[nv][len].first,i1+2*i-1,i1+2*i-1,-1);
						mc[nv][len]=std::make_pair(i1,i1+2*i-1);
					}
				}
			}
			for(re int i1=ed-2*i+1;i1>=bg;i1--)
			{
				re ull nw=get(i1,i1+2*i-1);
				re int nv;
				if(!mp[nw])mp[nw]=++cnt;
				nv=mp[nw];
				re int len=(ed-2*i+1-i1)/i;
				if(!(len&1))
				{
					len=len/2;
					if(mc[nv].size()>len)
					{
						mc[nv][len]=std::make_pair(i1,i1+2*i-1);
					}
					else mc[nv].push_back(std::make_pair(i1,i1+2*i-1));
				}
			}
			for(re int i1=0,vv=1;bg+i1+2*i-1<=ed;i1+=i,vv=-vv)
			{
				adp(bg,ed-i1-2*i+1,bg+i1+2*i-1,ed,vv);
			}
		}
	}
	for(re int i=1;i<=q;i++)
	{
		scanf("%d%d",&l[i],&r[i]);
		qry[r[i]-l[i]].push_back(i);
	}
	std::sort(pc1+1,pc1+cct1+1,cmp);
	std::sort(pc2+1,pc2+cct2+1,cmp);
	re int ta=1;
	for(re int i=0;i<=200000;i++)
	{
		while(ta<=cct1&&pc1[ta].x==i)
		{
		//	printf("**a**%d %d %d\n",i,pc1[ta].y,pc1[ta].v);
			add1(pc1[ta].y,pc1[ta].v);
			ta++;
		}
		for(auto x:qry[i])
		{
			ans[x]-=sum(l[x]-1);
		}
	}
	ta=1;
	memset(f1,0,sizeof(f1));
	memset(f2,0,sizeof(f2));
	for(re int i=0;i<=200000;i++)
	{
		while(ta<=cct2&&pc2[ta].x==i)
		{
			add1(pc2[ta].y,pc2[ta].v);
			ta++;
		}
		for(auto x:qry[i])
		{
			ans[x]+=sum(r[x]);
		}
	}
	for(re int i=1;i<=q;i++)printf("%lld\n",ans[i]);
}
```


---

## 作者：command_block (赞：12)

**题意** ： 若存在字符串 $t$ 使得 $s=tt$ ，则称 $s$ 是优美的。

给出字符串 $s$ ，$q$ 次询问一个子串 $s[l,r]$ 的**本质不同**的优美子串个数。

$n,q\leq 2\times 10^5,\ \Sigma=\{\texttt{a},\texttt{b}\}$ ，时限 $\texttt{3s}$。

------------

配合 [Blog : Lyndon & Runs](https://www.luogu.com.cn/blogAdmin/article/new) 食用。

- **定理** ：位置不同的本原平方串共 $O(n\log n)$ 个。

- **定理** ： 对于一个 ${\rm run}\ {\bf r}=(l,r,p)$ ，对于所有 $l\leq i\leq r-2p+1$ ，$[i,i+2p-1]$ 都是一个本原平方串。

求解 $\rm Runs$ 和所有本原平方串的算法在上方博文中有介绍，不再赘述。

我们选出 $s$ 的所有**位置不同**的平方串集合 $Sq_0$ ，本质相同的串可能重复出现。

令 $c[l,r]=\big[s[l,r]\in Sq_0\big]$。

若询问 $s[L,R]$ ，相当于对矩形区域 $\begin{cases}L\leq l\\r\leq R\end{cases}$ 求和。

接下来消去重复贡献，对于本质相同的平方串 $s[l_1,r_1],s[l_2,r_2],...,s[l_m,r_m]\ (l_1<l_2<...<l_m)$ ，令 $c[l_1,r_2],c[l_2,r_3],...,c[l_{m-1},r_m]$ 减去 $1$。

如图，红色点代表本质相同的平方串，灰色部分是询问区域，蓝色点是修正。

![](https://cdn.luogu.com.cn/upload/image_hosting/enqiw7jo.png)

不难发现，若有 $n$ 个红色点在询问区域内，则必有 $n-1$ 个蓝色点也在询问区域内，所以一个本质相同的平方串贡献总是 $1$。

先来考虑如何简单地刻画 $Sq_0$。

某个普通平方串一定能表示成一个本原平方串重复若干次的形式。

具体地，对于 ${\rm run}\ {\bf r}=(l,r,p)$ ，枚举 $len=2kp,k\in N^+,l\leq i\leq r-len+1$ ，则 $s[i,i+len-1]$ 是一个普通平方串。

由于周期同为 $p$ 的不同 ${\rm run}$ 交不会达到 $p$ ，上述枚举在 $Sq_0$ 中没有重复。

不难发现，$len$ 相同的一组普通平方串在 $c$ 中是条斜线。为 $(l,l+len-1),(r-len+1,r)$。

接下来考虑扣除的贡献。

同个 $\rm run$ 产生的两个普通平方串相同的充要条件是 ： $len$ 相同，且 $s[i,i+len-1],s[j,j+len-1]$ 中 $p|i-j$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fsibwdpr.png)

如图，红点是一组 $len$ 相同的普通平方串，蓝点则是间隔为 $p$ （ 图中 $p=3$ ）的两个普通平方串产生的重复抵消贡献。

不难发现这也是一条斜线，且为 $(l,l+len+p-1),(r-len-p+1,r)$。

可能的 $len$ 的数目显然不超过指数 $e_{\bf r}=\dfrac{r-l+1}{p}$ ，根据 $\text{The Runs Theorem}$ ，这部分产生的斜线总数为 $O(n)$。

接下来计算不同的 $\rm run$ 之间产生的重复。

用哈希表记下目前枚举出的所有本质不同的平方串。具体地，对于 ${\rm run}\ {\bf r}=(l,r,p)$ ，枚举 $l\leq i<l+p,len=2kp,k\in N^+,i+len-1\leq r)$ ，则 $s[i,i+len-1]$ 是一个在该 $\rm run$ 内某类本质不同的普通平方串的最靠左的出现。

不难发现这样的枚举量不超过本原平方串的总个数 $r-l+2-2p$ ，而后者的总和根据相关理论是 $O(n\log n)$ 的。

按照 $l$ 递增的顺序考虑 $\rm Runs$ ，当枚举到某个串发现 $\rm Hash$ 表中已经有了，则在上一个串的最右出现和这一个串的最左出现之间建立抵消贡献点（深蓝色），如图 ：

![](https://cdn.luogu.com.cn/upload/image_hosting/hvl5n18c.png)

这最多产生 $O(n\log n)$ 个额外的点。

现在我们把问题转化成了 : 维护一个 $n\times n$ 的矩阵 $c$ ，支持斜线加减，单点加减，最后子矩阵查询。

单点的二维偏序是简单的，下面来看斜线的二维偏序。

![](https://cdn.luogu.com.cn/upload/image_hosting/fgx0939j.png)

把斜线段拆成两条斜射线的差。我们可以断言，一条斜射线必然穿过限制矩形的右侧(蓝色)或者上侧(绿色)，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/pasql4n5.png)

对于穿过右侧的斜射线，其在矩形内的长度为起始点 $x$ 坐标与右边界 $x$ 坐标的差。

对于穿过上边界的，则和 $y$ 坐标有关。考虑分别统计。

若矩形右上角为 $(x_L,y_L)$ 直线 $y=x+b$ 与 $x=x_L$ 的交点会是 $x_L+b$。

若 $x_L+b\leq y_L\Leftrightarrow b\leq y_l-x_l$ 则与右侧相交。区间求和即可。需要维护 $x,$ 坐标和以及起始点个数。

对于与上侧相交的情况，翻转坐标系处理即可。

总复杂度 $O(n\log^2n)$。

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<map>
#define Pr pair<int,int>
#define mp make_pair
#define MaxN 205000
#define ll long long
using namespace std;
struct StrHash{
  ll p[MaxN],h[MaxN];int mod,buf;
  StrHash (int _buf,int _mod){buf=_buf;mod=_mod;}
  void Init(char *s,int n)
  {
    p[0]=1;
    for (int i=1;i<=n;i++){
      p[i]=p[i-1]*buf%mod;
      h[i]=(h[i-1]*buf+s[i]-'a'+1)%mod;
    }
  }
  bool tl(int u,int v,int len)
  {return (h[u]-h[v]+(h[v-len]-h[u-len])*p[len])%mod==0;}
  bool tr(int u,int v,int len)
  {return (h[u+len-1]-h[v+len-1]+(h[v-1]-h[u-1])*p[len])%mod==0;}
  int get(int l,int r)
  {return (h[r]+(mod-h[l-1])*p[r-l+1])%mod;}
}h1(10,1000000007),h2(10,1000000009);
int n;char s[MaxN];
int extl(int u,int v)
{
  if (s[u]!=s[v])return 0;
  int l=1,r=min(u,v),mid;
  while(l<r){
    mid=(l+r+1)>>1;
    if (h1.tl(u,v,mid)&&h2.tl(u,v,mid))l=mid;
    else r=mid-1;
  }return l;
}
int extr(int u,int v)
{
  if (s[u]!=s[v])return 0;
  int l=1,r=n-max(u,v)+1,mid;
  while(l<r){
    mid=(l+r+1)>>1;
    if (h1.tr(u,v,mid)&&h2.tr(u,v,mid))l=mid;
    else r=mid-1;
  }return l;
}
struct Runs{int l,r,p;}b[MaxN*20];
bool cmpR(const Runs &A, const Runs &B)
{return A.l==B.l ? (A.r==B.r  ? A.p<B.p : A.r<B.r) : A.l<B.l;}
int tot;
int chk(int u,int v)
{
  int tl=extl(u,v),tr=extr(u,v);
  if (tl+tr>=v-u+1){
    b[++tot]=(Runs){u-tl+1,v+tr-1,v-u};
    return v+tr-1;
  }return 0;
}
void getRuns()
{
  for (int p=1;p<=n;p++)
    for (int k=p,mx=0;k+p<=n;k+=p)
      if (mx<k)
        mx=max(mx,chk(k,k+p)-p);
  sort(b+1,b+tot+1,cmpR);
  int m=0;
  for (int i=1;i<=tot;i++)
    if (b[i].l!=b[i-1].l||b[i].r!=b[i-1].r)
      b[++m]=b[i];
  tot=m;
}
int ans[MaxN];
struct Qry{int l,r,p;}q[MaxN];
struct Point{int x,y,c;}g[MaxN*20];
int tn,m;
#define lbit(x) ((x)&-(x))
struct SumDS
{
  ll t[MaxN<<1],sum;
  void clr(){memset(t,0,sizeof(ll)*(n+n+1));sum=0;}
  void add(int p,int c){
    p+=n;sum+=c;
    while(p<=n+n){t[p]+=c;p+=lbit(p);}
  }
  ll qry(int p){
    ll ret=0;p+=n;
    while(p){ret+=t[p];p^=lbit(p);}
    return ret;
  }
}T,Tx;
bool cmpQl(const Qry &A,const Qry &B){return A.l<B.l;}
bool cmpQr(const Qry &A,const Qry &B){return A.r<B.r;}
bool cmpP(const Point &A,const Point &B){return A.x<B.x;}
void calc0()
{
  sort(q+1,q+m+1,cmpQl);
  sort(g+1,g+tn+1,cmpP);
  static int o[MaxN];
  for (int i=1;i<=tn;i++)o[g[i].y]+=g[i].c;
  for (int i=1;i<=n;i++)o[i]+=o[i-1];
  for (int i=1,j=1;i<=m;i++){
    for (;g[j].x<=q[i].l&&j<=tn;j++)T.add(g[j].y,g[j].c);
    ans[q[i].p]+=o[q[i].r]-T.qry(q[i].r);
  }
}
void calc1()
{
  sort(g+1,g+tn+1,cmpP);
  T.clr();
  for (int i=1,j=1;i<=m;i++){
    for (;g[j].x<=q[i].l&&j<=tn;j++){
      T.add(g[j].y-g[j].x,g[j].c);
      Tx.add(g[j].y-g[j].x,g[j].c*g[j].x);
    }ll cnt=T.qry(q[i].r-1-q[i].l),sx=Tx.qry(q[i].r-1-q[i].l);
    ans[q[i].p]-=cnt*(q[i].l+1)-sx;
  }
  for (int i=1;i<=tn;i++)swap(g[i].x,g[i].y);
  sort(g+1,g+tn+1,cmpP);
  sort(q+1,q+m+1,cmpQr);
  T.clr();Tx.clr();
  for (int i=1,j=1;i<=m;i++){
    for (;g[j].x<=q[i].r&&j<=tn;j++){
      T.add(g[j].y-g[j].x,g[j].c);
      Tx.add(g[j].y-g[j].x,g[j].c*g[j].x);
    }ll cnt=T.sum-T.qry(q[i].l-q[i].r),sx=Tx.sum-Tx.qry(q[i].l-q[i].r);
    ans[q[i].p]+=cnt*(q[i].r+1)-sx;
  }
}
map<Pr,int> ss;
int main()
{
  scanf("%d%d%s",&n,&m,s+1);n=strlen(s+1);
  h1.Init(s,n);h2.Init(s,n);
  getRuns();
  for (int i=1;i<=m;i++){
    scanf("%d%d",&q[i].l,&q[i].r);
    q[i].l--;q[i].p=i;
  }
   for (int t=1;t<=tot;t++){
    int l=b[t].l,r=b[t].r,p=b[t].p;
    for (int len=2*p;len<=r-l+1;len+=2*p){
      for (int i=l;i+len-1<=r&&i<l+p;i++){
        int j=i+len-1;
        Pr now=mp(h1.get(i,j),h2.get(i,j));
        if (ss.count(now))
          g[++tn]=(Point){ss[now],j,-1};
        ss[now]=(r-(i-1)%p)/p*p+(i-1)%p-len+1;
      }
    }
  }calc0();tn=0;
  for (int t=1;t<=tot;t++){
    int l=b[t].l,r=b[t].r,p=b[t].p;
    for (int len=2*p;len<=r-l+1;len+=2*p){
      g[++tn]=(Point){l,l+len-1,1};
      g[++tn]=(Point){r-len+2,r+1,-1};
      if (l<=r-len-p+1){
        g[++tn]=(Point){l,l+len+p-1,-1};
        g[++tn]=(Point){r-len-p+2,r+1,1};
      }
    }
  }calc1();
  for (int i=1;i<=m;i++)
    printf("%d\n",ans[i]);
  return 0;
}
```














---

## 作者：9AC8E2 (赞：7)

提供一个好写的不用二维数点的做法.

来自[神wzy的blog](https://blog.csdn.net/WAautomaton/article/details/107186568).

**引理1:** 每个位置结尾的本原平方串个数是 $O(\log n)$ 的.

**引理2:** 本质不同的本原平方串个数不超过 $2n$.

证明大概是每个位置产生的新的本原平方串个数不超过 $2$.

考虑贡献的来源.

我们把对当前询问能产生贡献的平方串分成两类
1. 来自于不经过当前右端点的run
2. 来自于经过当前右端点的run

对于第一类贡献,我们维护一个树状数组,在左端点处计算贡献,询问时求区间和即可.

对于第二类贡献,我们枚举以当前右端点结尾的所有本原平方串,计算其贡献.设有效长度为 $l$,枚举平方串的结尾离右端点的距离,那么长为 $2p$ 的本原平方串的贡献为 $\sum_{i=0}^{p-1}\lfloor\frac{l-i}{2p}\rfloor$.这个东西可以 $O(1)$计算.

问题是要求的是**本质不同**的平方串,而第一,二类贡献中可能有本质相同的字符串.考虑从树状数组中删去本质相同的平方串,我们枚举以当前右端点结尾的所有本原平方串,从树状数组中删去其**极长**平方串的贡献.不用删去所有平方串是因为其他串已经在之前被删去了,这样就能保证复杂度,而且不会多删.所以还要顺便维护一个hash table记录每个平方串的最后一次出现位置.

最后还要加入所有右端点为当前右端点的**run**的贡献.枚举其平方串长度,在最后一次出现处加入贡献即可.这里的复杂度可以视为对每个结尾枚举本原平方串,复杂度也是正确的.

整体的复杂度是 $O(n\log^2 n)$

后 $50\%$ 的数据好像能卡所有的单模hash,不知道是怎么实现的.

```cpp
template<long long p>
struct Hash
{
	long long h[1000005],mul[1000005];
	Hash(){}
	Hash(char * c)
	{
		int n=strlen(c+1);
		mul[0]=1;
		for(int i=1;i<=n;i++)mul[i]=mul[i-1]*131%p;
		h[0]=0;
		for(int i=1;i<=n;i++)h[i]=(h[i-1]*131+c[i]-'a'+1)%p;
	}
	long long ask(int l,int r){return (h[r]-h[l-1]*mul[r-l+1]%p+p)%p;}
};
template<long long p1,long long p2>
struct HS
{
	Hash<p1>a;
	Hash<p2>b;
	HS(){}
	HS(char * c)
	{
		a=Hash<p1>(c);
		b=Hash<p2>(c);
	}
	pair<long long,long long>ask(int l,int r){return {a.ask(l,r),b.ask(l,r)};}
};
HS<998244353,1000000007> S;
char c[1000006];
inline int lcp(int x,int y)
{
	if(c[x]!=c[y])return 0;
	int l=1,r=n-max(x,y)+1;
	while(l<r)
	{
		int mid=((l+r+1)>>1);
		if(S.ask(x,x+mid-1)==S.ask(y,y+mid-1))
			l=mid;
		else  r=mid-1;
	}
	return l;
}
inline int lcs(int x,int y)
{
	if(c[x]!=c[y])return 0;
	int l=1,r=min(x,y);
	while(l<r)
	{
		int mid=((l+r+1)>>1);
		if(S.ask(x-mid+1,x)==S.ask(y-mid+1,y))
			l=mid;
		else  r=mid-1;
	}
	return l;
}
bool cmp(int l1,int r1,int l2,int r2)//c[l1:r1]<c[l2,r2]
{
	int l=lcp(l1,l2);
	if(l>min(r1-l1,r2-l2))return r1-l1<r2-l2;
	return c[l1+l]<c[l2+l];
}
int run[1000006];
struct runs
{
	int l,r,p;
	bool operator ==(runs b){return b.l==l&&b.r==r&&b.p==p;}
	bool operator <(runs b)
	{
		if(b.l==l)return r<b.r;
		return l<b.l;
	}
};
int st[1000006];
void lyndon()
{
	int top=0;
	for(int i=n;i>=1;i--)
	{
		st[++top]=i;
		while(top>1&&cmp(i,st[top],st[top]+1,st[top-1]))
			top--;
		run[i]=st[top];
	}
}
vector<runs>ans;
void solve()
{
	for(int i=1;i<=n;i++)
	{
		int l1=i,r1=run[i];
		int l2=l1-lcs(l1-1,r1),r2=r1+lcp(l1,r1+1);
		if(r2-l2+1>=(r1-l1+1)*2)
			ans.push_back((runs){l2,r2,r1-l1+1});
	}
}
vector<pair<int,int> >ask[1000005];
int q;
vector<runs>ed[1000006];
vector<runs>vr[1000006];
struct BIT
{
	int c[200005];
	inline int ask(int x){int re=0;for(;x;x-=(x&-x))re+=c[x];return re;}
	inline void add(int x,int y){for(;x<=200000;x+=(x&-x))c[x]+=y;}
}B;
int as[1000006];
int main()
{
	read(n,q);
	scanf("%s",c+1);
	n=strlen(c+1);
	S=HS<998244353,1000000007>(c);
	lyndon();solve();
	for(int i=1;i<=n;i++)
		c[i]='z'-(c[i]-'a');
	lyndon();solve();
	sort(ans.begin(),ans.end());
	ans.erase(unique(ans.begin(),ans.end()),ans.end());
	for(int i=1,l,r;i<=q;i++)
		read(l,r),
		ask[r].push_back({l,i});
	for(runs i:ans)
	{
		vr[i.r].push_back(i);
		for(int j=i.l;j+i.p*2-1<=i.r;j++)
			ed[j+i.p*2-1].push_back(i);
	}
	map<pair<long long,long long>,int>mp;
	for(int i=1;i<=n;i++)
	{
		for(runs r:ed[i])
		{
			int np=r.p*2,t=(i-r.l+1)/np,l=i-np*t+1;
			auto tp=S.ask(l,i);
			if(mp[tp])B.add(mp[tp],-1);
			mp[tp]=0;
		}
		int re=B.ask(i);
		for(pair<int,int> q:ask[i])
		{
			as[q.second]=re-B.ask(q.first-1);
			for (runs r:ed[i])
			{
				int l=i-max(r.l,q.first)+1,p=r.p;
				int t=l%(p*2),s=l/(p*2);
				if(s==0)continue;
				if(t>=p-1)as[q.second]+=s*p;
				else as[q.second]+=s*(t+1)+(s-1)*(p-t-1);
			}
		}
		for(runs r:vr[i])
		{
			int np=r.p*2;
			for(int j=r.l;j+np-1<=r.r;j++)
			{
				int t=(r.r-j+1)/np,k=j+t*np-1;
				if(r.r-k>=r.p)continue;
				auto tp=S.ask(j,k);
				mp[tp]=j;
				B.add(j,1);
			}
		}
	}
	for(int i=1;i<=q;i++)printf("%lld\n",as[i]);
	return 0;
}


```

---


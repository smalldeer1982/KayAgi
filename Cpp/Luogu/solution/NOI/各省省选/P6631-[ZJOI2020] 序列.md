# [ZJOI2020] 序列

## 题目背景

1s，512MB

## 题目描述

Bob 喜欢序列。

有一个长度为 $n$ 的非负整数序列 $a_1, a_2,\cdots, a_n$。每一步你可以从以下三种操作中选择一种执行：

- 选择一个区间 $[l, r]$，将下标在这个区间里的所有数都减 $1$。

- 选择一个区间 $[l, r]$，将下标在这个区间里且下标为奇数的所有数都减 $1$。

- 选择一个区间 $[l, r]$，将下标在这个区间里且下标为偶数的所有数都减 $1$。

求最少需要多少步才能将序列中的所有数都变成 $0$。

## 说明/提示

样例解释 $1$

第一组数据：$21212 \stackrel{1}{\longrightarrow} 1111 1 \stackrel{1}{\longrightarrow} 00000$

第三组数据：$1145141919810 \stackrel{1}{\longrightarrow} 0034030808700 \stackrel{8}{\longrightarrow} 0031000000700 \stackrel{10}{\longrightarrow}0000000000000$

样例输入输出 $2$ 见下发文件

对于前 $10\%$ 的数据，$n \leq 5, a_i \leq 10$。

对于前 $30\%$ 的数据，$n \leq 50, a_i \leq 50$。

对于前 $50\%$ 的数据，$n \leq 200, a_i \leq 200$。

对于前 $60\%$ 的数据，$n \leq 200, a_i \leq 10^9$。

对于前 $70\%$ 的数据，$n \leq 1000, a_i \leq 10^9$。

对于前 $90\%$ 的数据，$n \leq 10000, a_i \leq 10^9$。

对于 100% 的数据，$1 \leq n \leq 100000, 0 \leq ai \leq 10^9, 1 \leq T \leq 10$。


## 样例 #1

### 输入

```
3
5
2 1 2 1 2
8
1000000000 1000000000 0 1000000000 1000000000 0 1000000000 1000000000
13
1 1 4 5 1 4 1 9 1 9 8 1 0```

### 输出

```
2
3000000000
19```

# 题解

## 作者：ReseeCher (赞：45)

约定覆盖位置$[l]$,$[l+1]$,$[l+2]$......$[r]$的为一条从$l$开始的```“直线”```

约定覆盖位置$[l]$,$[l+2]$,$[l+4]$......$[r]$的为一条从$l$开始的```“跳线”```

那么原问题相当于使用一些直线和跳线使每个位置$i$刚好被$a[i]$条线覆盖

每用一条线称作$1$个$cost$,我们希望总的$cost$最小

---

首先考虑如何去覆盖第$1$和第$2$个位置

为了方便，这里$a[i]$表示位置$i$还要被几条线段覆盖

这里先给出**方案**：

1. $(a[1]>0,a[2]=0)$：从$a[1]$开始一条跳线

2. $(a[1]>0,a[2]>0)$：从$a[1]$开始一条直线

3. $(a[1]=0)$：暂时不决策

#### $prove1$

比较显然，位置$2$已经不能被覆盖，只能连出跳线
    
#### $prove2$

考虑证明以下命题：```从1开始的连续非0区间（长度>=2）用一条直线覆盖一定不劣```

设这段区间为$[1,r]$，那么因为$a[r+1]=0$，所以不可能向后连出直线，唯一有利于后面位置被覆盖的方案是在与$(r)$奇偶性相同的位置连出一条跳线

但是这样做必有$cost>=2$，而使用一条直线和一条跳线$cost$为$2$，所以一定不优于原方案（不如从后面开始跳线）

---

此时由于$a[1]=0$了，我们可以把位置$1$删除，继续考虑第$2$和第$3$个位置

这个问题与刚才的问题类似，唯一的区别是要处理被前面开始的线覆盖的情况

如果能被前面的线覆盖则一定被覆盖，因为这样$cost=0$，而任意一种可能更利于后面被覆盖的方案都需要$cost=1$，不如从后面开始

若前面的直线有$A$个，能连到$3$的跳线有$B$个

那么如果$a[3]>=A+B$，直接把$a[3]$减去$A+B$即可

但如果$a[3]<A+B$，则一定有$A+B-a[3]$条线无法连下去，记为$K$

发现保留直线还是跳线和后面的位置有关，于是我们可以先把A和B都减去$K$，再在$3$上打$K$个标记，表示可以从$3$免费开始$K$条任意的线

但这时候出现了一个新的问题，$A$和$B$不能被减到负数

注意到若$K>A$，那么$B$至少也要断掉$K-A$条，那么先把这些边断掉，这样就没有问题了

$K>B$时同理

---

这样我们就有一个可以从$(a[i-1],a[i])$推到$(a[i],a[i+1])$的算法了，一遍推过去即可

具体可以看代码中的注释

```cpp
void Work(){
	LL A=0,B=0,C=0,Ans=0,D=0;			//C表示奇偶性为另一类的跳线个数 
	F(i,2,n+1){
		if(a[i]<B+A){					//处理被前面的线覆盖的情况
			int K=B+A-a[i];
			if(B<K)A-=K-B,K-=K-B;
			if(A<K)B-=K-A,K-=K-A;
			B-=K;A-=K;a[i]-=K;D=K;		//D：记录标记个数 
		}
		a[i]-=A+B;
		
		LL U=min(a[i-1],a[i]);			//U：新增直线个数 
		Ans+=U;a[i-1]-=U;a[i]-=U;A+=U;	//处理直线 
		Ans+=a[i-1];C+=a[i-1];a[i-1]=0;	//处理跳线 
		
		a[i]+=D;Ans-=D;D=0;				//处理标记 
		swap(B,C);						//奇偶性互换 
	}
	cout<<Ans<<'\n';
}
```

---

## 作者：_ANIG_ (赞：25)

[传送门](https://www.luogu.com.cn/problem/P6631)

某天，ANIG 打开了和蔼可亲的教练准备的模拟赛。

![](https://cdn.luogu.com.cn/upload/image_hosting/6ohvja88.png)

在签了 T1，果断放弃大模拟 T2 后，ANIG 打开了 T3：

![](https://cdn.luogu.com.cn/upload/image_hosting/54szmrh9.png)

ANIG 感受到，这是一道难度接近 ZJOID1T3 的题。

由于 ANIG 很菜，所以这种难度的题是 ANIG 不可能会做的。

但是回去做 T2 大模拟对 ANIG 来说是不可能的。

所以可怜的 ANIG 只好开始思考 T3 暴力。

ANIG 发现自己甚至不会写暴力。

于是 ANIG 只能从这个问题的弱化版开始思考：

假设题中的操作分别是操作 $1,2,3$。

如果只存在操作 $1$，如何做？

也就是给定一个数列，每次可以选定一个区间整体减去 $1$，求使数列全部归零的最小操作次数。

看到区间减 $1$ 操作，不禁让 ANIG 想起来了维护这个操作的经典技巧：差分。

对原数列进行差分，则区间 $[l,r]$ 减 $1$ 操作等价于在差分数组上让第 $l$ 项减 $1$，第 $r+1$ 项加 $1$。

如果差分数组上每个原来是正数的位置都没有经历加 $1$ 操作，每个原来是负数的位置都没有经历减 $1$ 操作，则这样操作肯定是最优的，总操作次数就是所有正数的和。

并且由于每个元素都大于等于 $0$，所以差分数组的每个前缀和都非负，也就是每个前缀的正数和都不小于负数和，所以最优的方案一定存在。

这样，ANIG 惊奇的发现自己解决了这个问题：

答案就是原序列差分数组的所有正数的和，也就是 $\sum\limits_{a_i>a_{i-1}}a_i-a_{i-1}$。

ANIG 开始思考剩余两个子问题，他发现如果只考虑奇数位和只考虑偶数位，也能用类似的方法解决。

也就是说，如果已经确定每个位置被每个操作减了几次，那么 ANIG 就能用上文的方法算出来答案。

这样，只需要 dfs 枚举每个位置被每个操作减了几次，就能得到完整的暴力了。

现在，有了 10pts，ANIG 开始朝着 30pts 进发。

既然是最优化问题，ANIG 决定从 dp 入手。

他观察暴力的计算答案的部分，认为可以把这部分在 dp 的过程中计算。

也就是让 $f_i$ 表示已经计算了所有操作对应的差分数组的前 $i$ 项的正数的和的最小值。

为了计算，dp 数组中还要记下每个操作在第 $i$ 个数前能执行的最后一个数上被执行的次数。

由于每个位置只能被执行两种操作，所以可以只记其中一种，再用总数减去这种的次数就能得到另一种的次数。

这样，ANIG 惊奇的发现他成功设计出了 dp 状态：

$f_{i,j,k}$ 表示前 $i$ 个数，第 $i-1$ 个数被操作 $1$ 减了 $j$ 次，第 $i$ 个数被操作 $1$ 减了 $k$ 次，此时差分数组前 $i$ 项所有正数的和的最小值。

转移的时候，枚举第 $i$ 位被操作 $1$ 执行的次数 $l$，则

$$f_{i,k,l}=\min\{f_{i-1,j,k}+\max(l-k,0)+\max((a_i-l)-(a_{i-2}-j),0)\}$$

就这样，ANIG 惊奇的发现他得到了复杂度 $O(nV^3)$ 的做法，得到了 30pts。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5,inf=1e18;
int t,n,w[N],f[205][205][205],m,res;
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		m=0;
		res=inf;
		memset(f,0x3f,sizeof(f));
		for(int i=1;i<=n;i++)cin>>w[i];
		for(int i=0;i<=w[1];i++){
			for(int j=0;j<=w[2];j++){
				f[2][i][j]=i+max(j-i,0ll)+w[1]-i+w[2]-j;
			}
		}
		for(int i=3;i<=n;i++){
			for(int j=0;j<=w[i-2];j++){
				for(int k=0;k<=w[i-1];k++){
					for(int l=0;l<=w[i];l++){
						f[i][k][l]=min(f[i][k][l],f[i-1][j][k]+max(l-k,0ll)+max((w[i]-l)-(w[i-2]-j),0ll));
					}
				}
			}
		}
		for(int i=0;i<=w[n-1];i++)for(int j=0;j<=w[n];j++)res=min(res,f[n][i][j]);
		cout<<res<<"\n";
	}
}
```
此时的 ANIG 已经准备心满意足地去睡觉了。

在开始睡觉之前，他决定观赏一下这个 dp 数组。

由于这个数组是三维的，所以可以看作由 $n$ 个 $V\times V$ 的矩形构成。

ANIG 很好奇这些矩形是什么样的。

于是他把这些矩形输出，随便挑了一个好看的矩形，得到了这样的矩阵：

```
167 168 169 170 171 172 173 174 175
166 166 167 168 169 170 171 172 173
165 165 165 166 167 168 169 170 171
164 164 164 164 165 166 167 168 169
163 163 163 163 163 164 165 166 167
162 162 162 162 162 162 163 164 165
161 161 161 161 161 161 161 162 163
160 160 160 160 160 160 160 160 161
159 159 159 159 159 159 159 159 159
158 158 158 158 158 158 158 158 158
157 157 157 157 157 157 157 157 157
156 156 156 156 156 156 156 156 156
155 155 155 155 155 155 155 155 155
154 154 154 154 154 154 154 154 154
154 153 153 153 153 153 153 153 153
154 153 152 152 152 152 152 152 152
154 153 152 151 151 151 151 151 151
154 153 152 151 150 150 150 150 150
154 153 152 151 150 149 149 149 149
154 153 152 151 150 149 148 148 148
154 153 152 151 150 149 148 148 148
154 153 152 151 150 149 148 148 148
154 153 152 151 150 149 148 148 148
154 153 152 151 150 149 148 148 148
155 154 153 152 151 150 149 148 148
156 155 154 153 152 151 150 149 148
157 156 155 154 153 152 151 150 149
```
ANIG 惊奇的发现这个矩阵非常美观。

他发现这个矩阵的数的极差比较小，经过更仔细的观察发现这个矩阵的每一行和每一列都是先递减，然后不变，最后递增。

“这么美观的矩形转移的过程一定也很美观吧。”ANIG 心想。

于是他决定手玩一下转移过程。

他观察了一下自己的转移式：

$$f_{i,k,l}=\min\{f_{i-1,j,k}+\max(l-k,0)+\max((a_i-l)-(a_{i-2}-j),0)\}$$

他发现 $\max(l-k,0)$ 这一项可以提出来。

于是转移式变成：

$$f_{i,k,l}=\min\{f_{i-1,j,k}+\max((a_i-l)-(a_{i-2}-j),0)\}+\max(l-k,0)\}$$

拆开括号，转移式变为：

$$f_{i,k,l}=\min\{f_{i-1,j,k}+\max(a_i-l-a_{i-2}+j,0)\}+\max(l-k,0)\}$$

ANIG 发现，在求 $f_{i,k,l}$ 时，需要遍历 $f_{i-1}$ 的第 $k$ 列，然后求出来每一项加上一个系数的最小值。

ANIG 还发现，在从上往下枚举这一列的值的时候，这个系数刚开始一直是 $0$，从某个位置开始每次加 $1$。

而这一列的前半部分每次减至少 $1$，而系数却每次加最多 $1$，所以即使加上系数也不能让前半部分的数变得比后面的数更小。

这种情况在到达第一个最低点时发生改变。

第一个最低点后面的数原本的值和加的系数都不小于第一个最低点。

也就是第一个最低点原本的值加上系数后依旧是这一整列的最小值。

所以只需要提前求出来每一列的第一个最小值，然后让 $f_{i,k,l}$ 直接从这个位置转移过来就行了。

设 $g_{i,k}$ 表示第 $i$ 个矩阵第 $k$ 列的第一个最小值的位置。

这样，总复杂度就优化为了 $O(nV^2)$。

到这里，可以发现每一列只有最小值是有用的。

于是，ANIG 开始猜测，只有整个矩阵的全局最小值才是有必要保留的。

经过实验，ANIG 惊奇的发现这个结论是正确的。

于是 ANIG 打算新开一个数组，用 $dp_i$ 表示第 $i$ 个矩阵的全局最小值，而原数组 $f$ 就没用了，因为 ANIG 可以只保留所有全局最小值。

于是，ANIG 不在执着于求出每个 dp 值，而是想办法只求出来所有全局最小值。

ANIG 决定，先尝试对每一行求出来这一行的最小值。

假设现在要求 $f_i$ 的第 $k$ 行的最小值，设 $g_{i-1,k}=t$，则等价于求 $\min\limits_{l=0}^{a_i}\{dp_{i-1}+\max(a_i-l-a_{i-2}+t,0)+\max(l-k,0)\}$。

ANIG 惊奇的发现 $dp_{i-1}$ 与 $l$ 无关，所以只需要求 $\max(a_i-l-a_{i-2}+t)+\max(l-k,0)$ 的最小值即可。

设 $A=a_i-a_{i-2}+t$，则相当于求 $\max(A-l,0)+\max(l-k,0)$ 的最小值。

这个式子的最小值并不难求。

经过打表，ANIG 惊奇的发现使得这个式子最小的 $l$ 满足 $\min(A,k)\le l\le \max(A,k)$。

随便挑一个范围内的数带进去就能得到第 $k$ 行的最小值。

ANIG 选择把 $k$ 带进去得到 $dp_{i-1}+\max(a_i-a_{i-2}-k+t)$。

这样，ANIG 就能对每一行快速求出来最小值啦。

下面，ANIG 面临的问题就是如何求出来那些行存在全局最小值。

也就是要求 $\min\limits_{k=0}^{a_{i-1}}\{dp_{i-1}+\max(a_i-a_{i-2}-k+g_{i-1,k})\}$。

ANIG 很好奇，究竟是怎样的行才能存在全局最小值，然后他打了个表，ANIG 惊奇的发现存在全局最小值的行是一个区间。

可以如何求出来这样的区间，ANIG 没有头绪。

写到这里，ANIG 突然发现自己忽略了一个关键的问题：

他还没有求出 $g$ 数组！

于是 ANIG 开始思考如何求出来数组 $g$。

他枚举每一列，现在要求出来第 $i$ 个矩阵的第 $l$ 列中第一个全局最小值的位置。

ANIG 先思考最朴素的做法，也就是枚举每一行，然后判断一个位置是否是全局最小值。

ANIG 惊奇的发现，要判断一个位置是否是全局最小值，只需要判断这个位置所在的行是否存在全局最小值，然后判断这个位置是否是这一行的最小值即可。

而这两个问题都已经在上文解决了！

所以，若第 $k$ 行满足 $k$ 属于存在全局最小值的区间，并且 $\min(A,k)\le l\le \max(A,k)$，那么第 $k$ 行第 $l$ 列就是全局最小值。

可是这样还是太低效了。

于是 ANIG 开始寻找 $\min(A,k)$ 和 $\max(A,k)$ 的性质。

于是 ANIG 打了个关于 $\min(A,k)$ 的表，结果惊奇的发现 $\min(A,k)$ 是单调不降的！

“难道前一项的区间是完全包含后一项的吗？”ANIG 心想。

于是，他尝试找到存在全局最小值的行的最小值，只判断这一行的第 $l$ 列是否是全局最小值。

经过实验，ANIG 惊奇的发现这个猜想是正确的。

这样，就能轻易的求出 $g$ 了，只需要 $\min(A,k)\le l\le \max(A,k)$，就有 $g_{i,l}=L$，其中 $L$ 是存在全局最小值的行的最小值。

于是，ANIG 惊奇的发现，$g_{i,l}$ 要么不存在，要么等于一个常数！

那么上文没有解决的 $\min\limits_{k=0}^{a_{i-1}}\{dp_{i-1}+\max(a_i-a_{i-2}-k+g_{i-1,k})\}$ 中的 $g_{i-1,k}$ 就能替换成常数 $r$。

则问题转化为求出满足 $dp_{i-1}+\max(a_i-a_{i-2}-k+r)$ 最小的 $k$。

ANIG 惊奇的发现 $dp_{i-1}$ 和 $a_i-a_{i-2}+r$ 都与 $k$ 无关。

设 $A=a_i-a_{i-2}+r$，等价于求 $\max(A-k,0)$ 的最小值。

这个问题已经弱到连 ANIG 都会做了。

就这样，ANIG 惊奇的发现他的程序时间复杂度已经降到了 $O(n)$，并且在提交过后他惊奇的发现自己通过了这道题。

相信通过阅读这篇题解，你一定学会如何场切 ZJOID1T3 了吧！

你还在等什么，快去 AK ZJOI 吧！

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
int t,n,w[N],dp[N],g1[N],g2[N],g[N];
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>w[i];
		memset(dp,0x3f,sizeof(dp));
		if(w[2]>=w[1]){
			dp[2]=w[2];
			g1[2]=w[1];
			g2[2]=w[2];
			g[2]=w[1];
		}else{
			dp[2]=w[1];
			g1[2]=w[2];
			g2[2]=w[2];
			g[2]=w[2];
		}
		for(int i=3;i<=n;i++){
			int lst=0,a=w[i]-w[i-2]+g[i-1];
			dp[i]=dp[i-1]+max(a-g2[i-1],0ll);
			if(a>g2[i-1])lst=g2[i-1];
			else if(a<g1[i-1])lst=g1[i-1];
			else lst=a;
			int b=lst;
			g1[i]=max(min(a,b),0ll),g2[i]=min(max(a,b),w[i]);
			g[i]=lst;
		}
		cout<<dp[n]<<"\n";
	}
}
```

---

## 作者：Aleph1022 (赞：24)

本文同步于我的博客：<https://www.alpha1022.me/articles/loj-3313.htm>。

感觉这个比 dxm 论文的做法简单很多啊（  
orz EI，orz uyom！

设所有操作构成的集族为 $\mathcal I$，我们要做的实际上是为每一个操作赋一个权值，代表其被执行的次数，即
$$
\begin{array}{ccc}
\min & \sum\limits_{S \in \mathcal I} x_S, & \\
\text{s.t.} & \sum\limits_{S \ni i} x_S \ge a_i & (s_i) \\
& -\sum\limits_{S \ni i} x_S \ge -a_i & (t_i) \\
& x_S \ge 0 &
\end{array}
$$

做对偶，有
$$
\begin{array}{ccc}
\max & \sum\limits_{i=1}^n a_i (s_i - t_i), & \\
\text{s.t.} & \sum\limits_{i \in S} (s_i - t_i) \le 1 & (x_S) \\
& s_i,t_i \ge 0 &
\end{array}
$$

我们令 $b_i = s_i-t_i$，那么限制就变成了比较优美的形式。  
考虑直接进行 DP，设状态 $f_{i,x,y,z}$ 表示考虑到 $i$，以 $i$ 为右端点的三类操作的 $b_i$ 之和的最大值分别为 $x,y,z$ 时，$\sum_{j=1}^i a_j b_j$ 的最大值。  
看起来状态数是爆炸的？

**假装最优解为整数**，则状态可以仅保留 $x,y,z \in \{0,1\}$，也即每个时刻对 $0$ 取 $\max$，易知这样并不会丢失合法解。  
既然状态只需要保留 $\{0,1\}$，那么 $b_i$ 的取值也只需要考虑 $\{-1,0,1\}$。这同样是显然的。

时间复杂度 $O(\sum n)$，常数不用管（

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 1e5;
int T;
int n,a[N + 5];
long long f[N + 5][2][2][2],ans;
int main()
{
    for(scanf("%d",&T);T;--T)
    {
        scanf("%d",&n);
        for(register int i = 1;i <= n;++i)
            scanf("%d",a + i);
        for(register int i = 2;i <= n;++i)
            for(register int x = 0;x <= 1;++x)
                for(register int y = 0;y <= 1;++y)
                    for(register int z = 0;z <= 1;++z)
                        f[i][x][y][z] = -0x3f3f3f3f3f3f3f3f;
        ans = -0x3f3f3f3f3f3f3f3f;
        f[1][0][0][0] = 0,f[1][1][1][0] = a[1];
        for(register int i = 2;i <= n;++i)
            for(register int j = -1;j <= 1;++j)
                for(register int x = 0;x <= 1;++x)
                    for(register int y = 0;y <= 1;++y)
                        for(register int z = 0;z <= 1;++z)
                            if(x + j <= 1 && (i & 1 ? y : z) + j <= 1)
                                f[i][max(max(x + j,j),0)][i & 1 ? max(max(y + j,j),0) : y][i & 1 ? z : max(max(z + j,j),0)] = max(f[i][max(max(x + j,j),0)][i & 1 ? max(max(y + j,j),0) : y][i & 1 ? z : max(max(z + j,j),0)],f[i - 1][x][y][z] + j * a[i]);
        for(register int x = 0;x <= 1;++x)
            for(register int y = 0;y <= 1;++y)
                for(register int z = 0;z <= 1;++z)
                    ans = max(ans,f[n][x][y][z]);
        printf("%lld\n",ans);
    }
}
```


---

## 作者：panjoel (赞：12)

为了方便，我们先考虑只有操作1时怎么LP。

想一会儿，可以发现定义$s_i$表示$1\sim i$ 中有多少操作区间的左端点，$t_i$表示有多少操作区间的右端点，那么有如下限制：

$$s_i≥s_i-1$$

$$t_i≥t_i-1$$

$$s_i≥t_i$$

$$s_i-t_{i-1}≥a_i$$

$$t_{i-1}-s_i≥-a_i$$

$$s_0≥z,t_0≥z$$

$$minimize:s_n-z$$

注意到最大费用循环流的对偶是：
$$P_i-P_j+v_{i,j}≥cost_{i,j}$$

$$minimize:v_{i,j}·cap_{,j}$$

所以连边如下：

$s_i$到$s_{i-1}$连容量无穷大，费用为0的边；

$t_i$到$t_{i-1}$连容量无穷大，费用为0的边；

$s_i$到$t_i$连容量无穷大，费用为0的边；

$s_i$到$t_{i-1}$连容量无穷大，费用为$a_i$的边；

$t_{i-1}$到$s_i$连容量无穷大，费用为$-a_i$的边；

$s_0$,$s_0$到$z$分别连容量无穷大，费用为0的边；

$z$,$s_n$连容量为1，费用为0的边；

求上图的最大费用循环流即为答案。注意到上图的性质很特殊，可以$dp$求解费用流。具体的：
	
$f_{i,0/1}$表示当前$dp$到$s_{i-1},s_i$之间，$t_{i-1},t_i$之间，经过的上一条费用不为0的边费用是负的/正的。那么显然：

$f_{i,0} =max(f_{i-1,0},f_{i-1,1}-a_i)$

$f_{i,1} =max(f_{i-1,0}+a_i,f_{i-1,1})$

不难发现$f_{i,1}=f_{i,0}+a_i$

所以归纳可证$f_{n,1}=\frac{1}{2}\sum\limits_{i=0}^n\mid a_i-a_i+1\mid$($a_{n+1}$视为0)，这与结论是相符的。

我们还是考虑只有操作$1$时的图，操作$2,3$实际上是在那张图上走的路径多加了一些限制。我们定义$i-1$到$i$为第$i$个贡献点，则第$i$个贡献点可以贡献$a_i,0,-a_i$三种值，并且有一些限制，要求贡献总和最大。

定义两个贡献点是相邻的，当且仅当他们两之间的贡献点贡献的都是0。

1.任意两个相邻的贡献点不能同时贡献正数。

2.把编号为偶数的贡献点删掉，剩下的数列中相邻的贡献点不能同时贡献正数。

3.把编号为奇数的贡献点删掉，剩下的数列中相邻的贡献点不能同时贡献正数。

于是可以$dp$了，记$f_{i,000/001/010/101/110/111}$表示前$i$个贡献点，前面第一个不为0的贡献点贡献的是负/正，前面第一个编号为奇数的不为0的贡献点贡献的是负/正，前面第一个编号为偶数的不为0的贡献点贡献的是负/正。

每个状态都会转移到两种状态，和当前位置的奇偶性有关。直接$dp$即可，复杂度$O(n)$。具体转移见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
template<typename T> void chkmax(T &a, const T &b) { a = a > b ? a : b; }
template<typename T> void chkmin(T &a, const T &b) { a = a < b ? a : b; }

const int MAXN = 100005;
const LL INF = 1e18;
int v[MAXN], n, T;

int main() {
	for (scanf("%d", &T); T--;) {
		LL a000 = 0, a001 = -INF, a101 = -INF, a010 = -INF, a110 = -INF, a111 = -INF;
		scanf("%d", &n);
		for (int i = 1; i <= n; i++) scanf("%d", v + i);
		for (int i = n; i > 0; i--) {
			LL b000 = a000, b001 = a001, b101 = a101, b010 = a010, b110 = a110, b111 = a111;
			if (i & 1) {
				chkmax(a110, b000 + v[i]);
				chkmax(a111, b001 + v[i]);
				chkmax(a001, b101 - v[i]);
				chkmax(a000, b010 - v[i]);
				chkmax(a000, b110 - v[i]);
				chkmax(a001, b111 - v[i]);
			} else {
				chkmax(a101, b000 + v[i]);
				chkmax(a000, b001 - v[i]);
				chkmax(a000, b101 - v[i]);
				chkmax(a111, b010 + v[i]);
				chkmax(a010, b110 - v[i]);
				chkmax(a010, b111 - v[i]);
			}
	//		printf("%lld %lld %lld %lld %lld %lld\n", a000, a001, a101, a010, a110, a111);
		}
		printf("%lld\n", max(max(max(a000, a001), a101), max(max(a010, a110), a111)));
	}
	return 0;
}

```



---

## 作者：dead_X (赞：10)

## 前言
贪！心！
## 思路
下文记从 $x$ 开始的第一种操作为 $A(x)$，后两种操作为 $B(x)$。

首先考虑只有两个数怎么做。

显然第一个数一定要被删空，所以第一个数一定会执行 $a_1$ 个操作。

不难发现，如果此时 $a_2>0$，我们就会执行 $A(1)$，不然执行 $B(1)$。

我们掏出一个结论：在多个数的时候这样也是对的。

考虑我们在 $a_2>0$ 时执行 $B(1)$。

* 如果执行了 $A(2)$，我们可以将 $A(2)$ 换为 $A(1)$，$B(1)$ 换为 $B(3)$，这样不劣。
* 如果执行了 $B(2)$，显然其中一个的右端点会靠前，将这个极长连续段替换为 $A(1)$，后面的替换成 $B(x)$，这样不劣。

因此 $B(1)$ 一定没有 $A(1)$ 优。

接下来考虑 $x$，此时可能会有几个 $A(x-1)$ 和 $B(x-2)$ 传到了这里。

* 如果 $A(x-1)$ 和 $B(x-2)$ 的和超过了 $a_x$，显然我们可以求出必须选择 $X$ 个 $A(x-1)$，$Y$ 个 $B(x-2)$，剩余的可以自由选择，我们直接记录自由选择的操作数 $W$。
* 如果此时 $a_x>0$ 且 $a_{x+1}>0$，我们执行 $A(x)$，此时如果 $W>0$ 可以将 $W$ 减小 $1$，就不需要额外使用线段了。
* 如果此时 $a_x>0$ 且 $a_{x+1}=0$，我们执行 $B(x)$，此时如果 $W>0$ 可以将 $W$ 减小 $1$，就不需要额外使用线段了。

于是就做完了，时间复杂度 $O(n)$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
long long ans;
int a[100003];
signed main()
{
	for(int T=read(),n;T--;)
	{
		n=read(),ans=0;
		for(int i=1; i<=n; ++i) a[i]=read();
		a[n+1]=0;
		for(int i=1,x=0,y=0,z=0,v,w=0; i<=n; ++i,swap(y,z))
		{
			w=0,x=min(x,a[i]),y=min(y,a[i]);
			if(x+y>=a[i])
				x=a[i]-x,y=a[i]-y,swap(x,y),w=a[i]-x-y;
			a[i]-=x+y;
			if(a[i]&&a[i+1]-x-z>0)
				v=min(a[i+1]-x-z,a[i]),
				ans+=max(v-w,0),w=max(w-v,0),x+=v,a[i]-=v;
			ans+=max(a[i]-w,0),y+=a[i],a[i]=0;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Petit_Souris (赞：9)

什么推结论推性质 dp，我这种非天赋哥这辈子是不可能会了。不如来点彻底的套路做法。

先考虑线性规划：对于每种操作，为其设一个非负整数变量 $x_i$ 表示操作 $i$ 进行的次数。设操作的集合为 $S=\{s_1,s_2\dots,s_k\}$，每种操作为一个下标的集合 $s_i$。

那么现在的限制形如：

$\forall i\in[1,n],\sum\limits_{i\in s_j}x_j=a_i$

要最小化 $\sum\limits_{i=1}^{k}x_i$。

把等号拆成大于等于和小于等于，现在就得到了一个线性规划的形式：

$$\begin{aligned}
&\min&\sum\limits_{i=1}^{k}x_i,\\
&\text{s.t.} &\forall i,\sum\limits_{i\in s_j}x_j\ge a_i\\
& &\forall i,\sum\limits_{i\in s_j}-x_j\ge -a_i \\
& &\forall j,x_j\ge 0
\end{aligned}$$

很自然地考虑把这个线性规划对偶，即给每个限制配了一个系数。设正的 $n$ 个限制的系数为 $y_1,y_2,\dots,y_n$，负的系数为 $z_1,z_2,\dots, z_n$。对偶后的线性规划为：

$$\begin{aligned}
&\max&\sum\limits_{i=1}^{n}a_i(y_i-z_i),\\
&\text{s.t.} &\forall j,\sum\limits_{i\in s_j}(y_i-z_i)\le 1\\
& &\forall i,y_i,z_i\ge 0
\end{aligned}$$

$y_i-z_i$ 一直以一个整体的形式出现，不妨设 $w_i=y_i-z_i$。现在问题可以这样理解：

- 有一个长度为 $n$ 的非负数组 $a_i$，要给每个位置赋上一个权值 $w_i$（可正可负），使得每个区间 / 奇区间 / 偶区间的权值和 $\le 1$，最大化 $\sum a_iw_i$。

我们假定每个 $w_i$ 都取整数时最优。

所有的限制实际上只需要判断最大子段和是否符合条件，这启发我们类似 dp 套 dp 的维护最大子段和的 dp 信息。

最大子段和的转移方程是 $g_{i}=\max(0,g_{i-1})+a_i$，所以实际上我们只需要记录 $\max(0,g_{i-1})$ 就行了，这个值要么是 $0$ 要么是 $1$。

因此我们可以从前往后 dp。记 $f_{i,x,y,z}$ 表示考虑了前 $i$ 个数，整个序列的最大后缀为 $x$，奇序列的最大后缀为 $y$，偶序列的最大后缀为 $z$，最大的 $\sum a_iw_i$。

转移看似需要枚举很多 $a_i$ 的取值。比较表面的限制是 $a_i\le 1$，但是你仔细分析一下，如果 $a_i\le -2$，这说明周围有至少三个 $1$（否则替换成 $-1$ 就能满足条件），并且有两个连续的 $1$ 在 $i$ 的一侧，这时候这个区间就已经不合法了，所以不可能填 $\le -2$ 的数，即 $a_i\in [-1,1]$。

因此直接暴力转移就行了，时间复杂度 $\mathcal O(n)$。代码非常简洁。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=1e5+9,INF=1e16;
ll T,n,a[N],dp[N][2][2][2];
void solve(){
    n=read();
    rep(i,1,n)a[i]=read();
    rep(i,0,n+1){
        rep(j,0,1){
            rep(k,0,1){
                rep(p,0,1)dp[i][j][k][p]=-INF;
            }
        }
    }
    dp[0][0][0][0]=0;
    rep(i,1,n){
        rep(j,0,1){
            rep(k,0,1){
                rep(p,0,1){
                    if(dp[i-1][j][k][p]==-INF)continue;
                    rep(w,-1,1){
                        if(j+w>1)break;
                        ll nj=max(0ll,j+w),nk=k,np=p;
                        if(i&1){
                            if(k+w>1)break;
                            nk=max(0ll,k+w);
                        }
                        else {
                            if(p+w>1)break;
                            np=max(0ll,p+w);
                        }
                        dp[i][nj][nk][np]=max(dp[i][nj][nk][np],dp[i-1][j][k][p]+w*a[i]);
                    }
                }
            }
        }
    }
    ll ans=-INF;
    rep(j,0,1){
        rep(k,0,1){
            rep(p,0,1)ans=max(ans,dp[n][j][k][p]);
        }
    }
    write(ans),putchar('\n');
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    T=read();
    while(T--)solve();
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：5)

# P6631 题解

[Problem Link](https://www.luogu.com.cn/problem/P6631)

**题目大意**

> 有一个长度为 $n$ 的非负整数序列 $a_1, a_2,\cdots, a_n$。每一步你可以从以下三种操作中选择一种执行：
>
> - 选择一个区间 $[l, r]$，将下标在这个区间里的所有数都减 $1$。
>
> - 选择一个区间 $[l, r]$，将下标在这个区间里且下标为奇数的所有数都减 $1$。
>
> - 选择一个区间 $[l, r]$，将下标在这个区间里且下标为偶数的所有数都减 $1$。
>
> 求最少需要多少步才能将序列中的所有数都变成 $0$。
>
> 数据范围：$n\le 10^5$。

**思路分析**

考虑线性规划，设 $Q$ 表示某个操作影响到的位置集合，$w(Q)$ 表示其操作次数，容易写出线性规划
$$
\begin{aligned}
&\forall i:\sum_{i\in Q}w(Q)\ge a_i\\
&\forall i:\sum_{i\in Q}-w(Q)\ge -a_i\\
&\mathrm{ans}=\min\left\{\sum_{Q}w(Q)\right\}
\end{aligned}
$$
将这个线性规划对偶，设 $c^+(i),c^-(i)$ 分别表示两类限制的对偶变量，容易写出对偶线性规划：
$$
\begin{aligned}
&\forall Q:\sum_{i\in Q} c^+(i)-c^-(i)\le 1\\
&\mathrm{ans}=\max\left\{\sum_{i} a_ic^+(i)-a_ic^-(i)\right\}
\end{aligned}
$$
考虑记 $c_i=c^+(i)-c^-(i)$，线性规划相当于：
$$
\begin{aligned}
&\forall Q:\sum _{i\in Q} c_i\le 1\\
&\mathrm{ans}=\max\left\{\sum_{i}a_i\times c_i\right\}
\end{aligned}
$$
考虑朴素 $dp_{i,x,y,z}$ 表示考虑到第 $i$ 位，且三类操作的最大后缀分别为 $x,y,z$，每次枚举 $c_{i+1}$ 转移。

注意到若 $x<0$ 则 $x$ 对 $c_{i+1}$ 的限制弱于空后缀对 $c_{i+1}$ 的限制，因此 $x,y,z$ 都可以对 $0$ 取 $\max$。

因此我们只关心 $x,y,z$ 的符号，那么如果某个 $c_{i+1}<-1$，那么对 $x,y,z$ 的影响和 $c_{i+1}=-1$ 是一样的，因此对于所有 $c$，我们可以在 $\{-1,0,1\}$ 范围内枚举。

时间复杂度 $\mathcal O(n\delta)$，其中 $\delta =24$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e5+5;
ll a[MAXN],dp[MAXN][2][2][2];
void chkmax(ll &x,ll y) { x=x>y?x:y; }
void solve() {
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]);
	memset(dp,-0x3f,sizeof(dp));
	dp[1][0][0][0]=0,dp[1][1][1][0]=a[1];
	for(int i=2;i<=n;++i) for(int j:{-1,0,1}) {
		for(int x:{0,1}) for(int y:{0,1}) for(int z:{0,1}) {
			int nx=max({x+j,j,0}),ny=y,nz=z;
			if(i&1) ny=max({y+j,j,0});
			else nz=max({z+j,j,0});
			if(nx>1||ny>1||nz>1) continue;
			chkmax(dp[i][nx][ny][nz],dp[i-1][x][y][z]+j*a[i]);
		}
	}
	ll ans=0;
	for(int x:{0,1}) for(int y:{0,1}) for(int z:{0,1}) chkmax(ans,dp[n][x][y][z]);
	printf("%lld\n",ans);
}
signed main() {
	int T; scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：zxtikes (赞：5)

## 题目描述
由题可知，有三种情况，分别如下：
- 选择一个区间 $[l, r]$，将下标在这个区间里的所有数都减 $1$。

- 选择一个区间 $[l, r]$，将下标在这个区间里且下标为奇数的所有数都减 $1$。

- 选择一个区间 $[l, r]$，将下标在这个区间里且下标为偶数的所有数都减 $1$。

我们可以认为第一种情况是一类情况，属于对区间内连续的数减 $1$ ；第二三种情况是另一类情况，两种情况都是对间隔一个单位的数减 $1$ 。

后面的讲述中，我们用“**连续线**”表示对第一种情况的称呼；“**间隔线**”表示对第二种情况的称呼。


------------

## 题目分析

### 第一部分（局部解）

首先假设题目只有“连续线”的情况。那么这道题就是一道广为人知的题目。

[P5019铺设道路](https://www.luogu.com.cn/problem/P5019)

上面的题就是这篇题解所讲的题的只有“连续线”的解法。

这种情况下我们的解如下：

$$
ans=\sum_{i=2 \wedge a_i > a_{i - 1}}^{n}{(a_i - a_{i - 1})}
$$

证明如下（可能有瑕疵，欢迎指正）：

先确立一个原则，当我们选择一个区间 $[l, r]$ 进行操作时，如果 $a_{l-1}$ 或 $a_{r+1}$ 大于零，那么我们这次操作会把 $a_{l-1}$ 或 $a_{r+1}$ 也选上。我们最后所得到的目标是序列中所有数为零，之所以选上的方案肯定优于不选的方案，是因为我们选上会更接近于目标（贪心原则）。

换种方式说，我们之前做过一些操作，可以向**相邻**的数转移，以此得到更优解。一定要注意**只能**转移给相邻的数！

**转移**的解释：我们在处理某个元素 $a_i$ 时，用了一条“连续线”，而这条连续线，可能会对后面的元素处理有所帮助，这就是**转移**的意思，可以理解为前人给后人留下的遗产，根据贪心原则，后人能够继承遗产，那就一定全部继承。

一、假设序列 $a_n$ 中只有两个元素，即 $n=2$ 。
1. 若 $a_1<a_2$ ，那么答案必定是 $a_1+(a_2-a_1)=a_2$ ，表示我们先对区间 $[1,2 ]$ 进行 $a_1$ 次操作，再对剩下的 $a_2$ 进行 $a_2-a_1$ 次操作。
2. 若 $a_1>a_2$ ，那么答案必定是 $a_2+(a_1-a_2)=a_1$ ，表示我们先对区间 $[1, 2]$ 进行 $a_2$ 次操作，再对剩下的 $a_1$ 进行 $a_1-a_2$ 次操作。

二、假设序列 $a_n$中元素个数大于 $2$ ，但是序列具有非严格单调性（这是对上面两种情况的拓展）。
1. 若序列单调递增，那么答案显然是最大的元素 $a_n$。答案改变了。
2. 若序列单调递减，那么答案显然是最大的元素 $a_1$。答案未改变。

如果我们再单调递增的序列后面加一个元素比 $a_n$ 小，影响了序列单调性。

如果我们再单调递减的序列后面加一个元素比 $a_n$ 大，影响了序列单调性。

那我们得到下两张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6ss66fvn.png)

红色表示我们已经用“连续线”覆盖的部分，图一根据我们的贪心原则，所以单调递增序列后添加的元素可以被先前的操作覆盖，也就是继承先人的遗产。

而我们图二由于 $a_n<a_{n+1}$ ，先前的操作只有 $a_n$ 条“连续线”可以向后转移。所以我们还需要再添加 $a_{n+1}-a_n$ 条“连续线”以用来完全覆盖 $a_{n+1}$。

综上：只有序列中存在 $a_{i-1}<a_i$ ，$i\in[1, n]$ ，默认 $a_0=0$ ，答案才会有所增加，其增加量为 $a_i-a_{i-1}$ ，得到了最开始的解的公式。


------------
### 第二部分（正解）
第一部分我们只考虑了“连续线”，但是题目中还有“间隔线”的存在，于是就会让这个问题发生很大的变化。

“连续线”和第一部分一样，满足贪心原则，“间隔线”由于具体分为两种类型，奇偶性有差异，由于“间隔线”的存在，我们的转移情况也不仅仅是单一的只能向相邻数转移了，还有间隔转移情况。

在第一部分中，之所以序列中存在 $a_{i-1}<a_i$ ，$i\in[1, n]$ ,答案才会有所增加，是因为我们前面处理 $a_{i-1}$ 时，已经花费了 $a_{i-1}$ 条“连续线”为代价，而根据我们的贪心原则， $a_{i-1}$ 条“连续线”可以转移，如果 $a_{i-1}<a_i$ 则需要再花费一些“连续线”，否则将不用花费。

**重点**：很显然，当序列单独考虑某两个相邻元素时，我们的处理方式是和第一部分有类似操作，即在我们要先用两个元素的较小值个“连续线”，再考虑使用两元素差值个“连续线”还是“跳跃线”。

所以我们用相似的思路，来记录“连续线”和“间隔线”能够转移的情况。


------------

我们令 $S_n$ 表示前面为 $a_{n+1}$ 留下的“连续线”遗产，令 $J_n$ 表示前面为 $a_{n+1}$ 留下的“间隔线”遗产。

以下我们都会遵循贪心原则，将 $S_n,J_n$ 能够向后转移，后人继承所有遗产。

首先我们还没处理任何元素时，很明显 $S_1=0,J_1=0$ 因为我们没有做出任何的操作，固然就没有任何能够转移的“连续线”或“间隔线”遗产（也可以理解为 $a_0=0$ 或 没有 $a_0$ 这个元素）。

假设我们当前正在处理到 $a_i$ ，得到了 $a_{i-1}$ 为 $a_{i+1}$ 留下的遗产 $S_i,J_i$，其中 $[1,i-1]$ 的数都继承了遗产并且都变为了 $0$ ， $a_i$ 继承了遗产但不一定变成了 $0$ ，分如下情况讨论：

**注意**：以上处理和变为 $0$ 是两种不同的意思，处理表达的是，$a_i$ 这个数已经继承了前面所有的遗产，至于这个遗产是多了还是少了，我们暂且不关心。处理的目的是使 $a_i$ 变成 $0$ 。这时 $a_i$ 与 $a_{i+1}$ 的大小并不会影响 $a_{i+1}$ 遗产继承情况，$S_i$ 都能转移到 $a_{i+1}$ ，即遗产能全部被继承。接下来讨论遗产继承情况：

令 $R=S_i+J_i-a_{i+1}$ ，分情况如下:

1. $R<0$ ，即表示之前留下的遗产不够我们使用，我们将 $a_{i+1}$ 减去 $(S_i+J_i)$ ，表示 $a_{i+1}$ 继承了所有遗产，但是这时一定满足 $a_{i+1}>0$ ，由于 $a_i$ 已经继承过遗产，现在 $a_{i+1}$ 也继承了。为了后面我们遗产能够传递一下去，答案问题转换为了求当前 $a_i,a_{i+1}$ 会对 $S_{i+1},J_{i+1},ans$ 等变量的影响。

- 首先，考虑**答案**变化，答案必然要加上 $a_i$ 因为我们的目的是将 $a_i$ 变成 $0$ ，无论如何都要使用这么多条线。

- 其次，考虑**两个线**“连续线”，“间隔线”变化，注意在第二部分开始标“重点”的地方， $S_{i+1}$ 一定要加上两元素最小值。再强调我们的目的是将 $a_i$ 变成 $0$ ，所以我们元素 $a_i$ 如果是较小值，那么 $J_{i+1}=0$ ,否则， $J_{i+1}=a_{i+1}-a_i$，简化表达就是 $J_{i+1}=a_i-\min(a_i,a_i+1)$ ，这样子我们就是将所有需要为 $a_i$ 使用的线都用“间隔线”。这样做的原因是，只有 $a_i<a_{i+1}$ 时会再用线条，而这时我们用“连续线”实际上无法为后面留下任何遗产，所以我们考虑使用间隔线，这样才有希望留下遗产。

2. $R>0$ ，即表示之前留下的遗产过多了，我们用完后还有剩余，这个情况实际上时属于特殊情况，我们处理方式也和第一种情况一样，只不过我们需要特殊处理：只需要先将“连续线”和“间隔线”一共减少 $R$ 条，如何减少，不会对后面结果造成影响，因为当前 $S_i,J_i$ 都是为 $a_{i+1}$ 特别准备的遗产，也就是说遗产只属于它，只要总数不变，不会对整个结果造成任何影响。但是我们减少的线条，如何分配？这个问题也很简单，我们再进行完一系列操作之后，把这个减少的条数 $R$ ，再加回 $a_{i+1}$ 就可以了，用来为我们后续的操作备用，而且我们还需要把答案减去这个减少的条数 $R$ ，因为我们实际上是多进行了这么多次条数，但实际上我们不需要做这些操作，所以减去 $R$ 。

------------
## 代码公示
```cpp
#include<bits/stdc++.h>
#define ll long long 
#define inf 1e9
#define rep(i,l,r) for(register int i=l;i<=r;++i)
#define per(i,r,l) for(register int i=r;i>=l;--i)
using namespace std;
const int N=1e5+10;

int n;
ll a[N];
ll ans;
inline void solve(){
	ans=0;
	scanf("%d",&n);
	rep(i,1,n)scanf("%lld",&a[i]);
	a[n+1]=0;
	ll LinS=0,LinJ=0,NxtJ=0,LinM=0;//连续线 间隔线 下一个间隔线 多余的遗产 
	rep(i,1,n){
		ll LinR=LinS+LinJ-a[i+1];//多余的遗产 
		if(LinR>0){//如果有多余遗产，考虑存储并改变连续线 间隔线 数量 
			if(LinS<LinR)LinJ=LinJ+LinS-LinR,LinR=LinS;
			if(LinJ<LinR)LinS=LinS+LinJ-LinR,LinR=LinJ;
			LinS-=LinR,LinJ-=LinR,a[i+1]-=LinR,LinM=LinR;
			//为了方便连续线和间隔线一共减少2R个，a[i+1]减去R就可以了，本质上一样 
		}
		a[i+1]-=LinS+LinJ;//吸收遗产 
		ans+=a[i];//将a[i]变成0的代价 
		ll LinN=min(a[i],a[i+1]);//较小值 
		LinS+=LinN;//连续线数目加上较小值 
		a[i]-=LinN,a[i+1]-=LinN;//吸收最后的代价 
		NxtJ+=a[i];//将a[i]变成0 为后代留下a[i]条间隔线遗产 
		a[i+1]+=LinM,ans-=LinM,LinM=0;//如果存在多余的遗产的操作 
		swap(LinJ,NxtJ);//交换两种性质的间隔线类型，为后面分配遗产做准备 
	}
	printf("%lld\n",ans);
}
int main(){
	int T;
	scanf("%d",&T);
	while (T--)solve();
	return 0;
}
```


---

## 作者：xzCyanBrad (赞：3)

@luogu_gza，上班了。

下面设题目中的三种操作分别为一、二、三操作。

考虑从左往右贪，假设现在贪到了奇数 $i$ 点。我们设前面给予的一、二、三操作的次数（下称贡献）分别为 $x,y,z$，假设 $x$ 与 $y$ 都对 $a_i$ 取 $\min$（多的传不过去），那么有两种情况：

- $x+y<a_i$。这个情况代表我们前面贡献没给够，那么我们需要加上 $p=a_i-x-y$ 的贡献。现在有个问题就是加给谁好呢？这又要分两种情况。
  - 当 $x+z\le a_{i+1}$ 时，我们肯定先加给 $x$，因为如果加给 $y$，后面 $z$ 还是需要还同样的次数，还不如先加给 $x$ 帮助 $z$ 还完。
    
    形式化地，我们设这次的 $x$ 一直贡献到了偶数 $j$（奇数类似），设分给 $y$ 时最优方法分别贡献了 $y_1,y_2$ 在 $j$ 前（后），分给 $z$ 时类似（但是这时 $z_2=0$，因为断掉了），那么原方法是两次能贡献 $x+y_2=y_1+z_1+y_2=y+z$，新方法也至少需要两次（$y=y_1+y_2$ 至少一次，$z=z_1>0$ 一次），所以原方法一定不劣。

  - 当 $x+z>a_{i+1}$ 时，上面的方法不优（这时 $z=z_1=0$，新方法变成了一遍）。所以我们要贡献给 $y$。
 
  总结一下，我们设一个值 $q=\max(0,a_{i+1}-x-z)$。则我们给 $x$ 加上 $\min(p,q)$，$y$ 加上剩下的，并且让答案加上 $p$ 即可。

- $x+y\ge a_i$。发现这样其实是多出了东西，需要我们减掉 $x+y-a_i$ 个东西。我们设 $p=x+y-a_i$，然后令 $(x',y')=(x-p,y-p)$，就回到了第一种情况（相当于每边先扣掉 $p$ 个东西，然后需要再加 $p$ 个东西）。**注意此时答案减掉 $\textbf p$，因为这个 $\textbf p$ 是已经加入贡献的，而第一种情况再处理时还要再加一遍！**

偶数的方法完全一样。代码好写的要死。

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for (int i = (a), i##ABRACADABRA = (b); i <= i##ABRACADABRA; i++)
#define drep(i, a, b) for (int i = (a), i##ABRACADABRA = (b); i >= i##ABRACADABRA; i--)
using namespace std;
using ll = long long;

int n;
ll a[100010];

void solve(){
  scanf("%d",&n);
  rep(i,1,n)scanf("%lld",&a[i]);
  ll x=0,y=0,z=0,res=0;
  rep(i,1,n){
    // cout<<i<<' '<<x<<' '<<y<<' '<<z<<' '<<res<<'\n';
    if (i&1){
      x=min(x,a[i]);
      y=min(y,a[i]);
      if (a[i]<=x+y){
        ll p=x+y-a[i];
        x-=p,y-=p,res-=p;
      }
      ll p=a[i]-x-y;
      res+=p;
      if (i==n)break;
      ll nx=max(0ll,a[i+1]-x-z);
      nx=min(nx,p);
      x+=nx,y+=p-nx;
    }else{
      x=min(x,a[i]);
      z=min(z,a[i]);
      if (a[i]<=x+z){
        ll p=x+z-a[i];
        x-=p,z-=p,res-=p;
      }
      ll p=a[i]-x-z;
      res+=p;
      if (i==n)break;
      ll nx=max(0ll,a[i+1]-x-y);
      nx=min(nx,p);
      x+=nx,z+=p-nx;
    }
  }
  printf("%lld\n",res);
}

int main() {
  int tt;
  scanf("%d",&tt);
  while (tt--)solve();
  return 0;
}
```

~~你怎么知道这场难度 231 然后 vp 时我开题顺序 132 的~~

---

## 作者：XenonWZH (赞：3)

[更好的阅读体验点这里](https://xenonwzh.github.io/zjoi2020-seq/)

# 解题思路

~~我甚至菜到这是我做得第一道黑题~~

## 模型构建

对于这道题，我们可以用基于贪心的思想解决。

首先明确两个概念：

1. 对于第一种情况，由于在区间中减去的数是连续的，我们可以将其形象地称为 **直线**，命名为变量 $\text{line}_i$；
2. 对于第二种情况，由于在区间中减去的数是不连续且有规律的间隔的，我们可以将其形象地称为 **跳线**，命名为变量 $\text{dance}_i$。

基于类似于数学归纳法的思想，我们可以设想对于第 $i$ 个数，前面的 $i -  1$ 个数中每个数 $a_j$ 在使用了 $\text{line}_j$ 个直线和 $\text{dance}_j$ 个跳线的情况下全部处理为 $0$。在这种情况下求需要总共 $\text{line}_i$ 个直线与 $\text{dance}_i$ 个跳线将前 $a_i$ 个数全部处理为 $0$，同时统计总共使用的线的数量 $\text{ans}$。

对于初始化，显然 $\text{line}_0 = \text{dance}_0 = \text{ans} = 0$。

## 情况分析

接下来我们需要分析对于 $a_i$，我们使用直线或跳线的情况。

显然这只有下列两种情况：

1. 在相邻两项 $\forall i$，$a_i > 0$。我们可以形象地称这个范围是连续的，显然在此时直线和跳线均可使用。在此时 **尽量使用直线** 必定是最优答案的一种。
2. 在相邻两项 $\exists i$，$a_i = 0$。我们可以形象地称这个范围是不连续（跳跃）的，显然此时只能使用跳线。

对于情况 $1$，以下为证明：

我们可以将该区间分为两部分：$a_i = b_i + c$，只用跳线处理 $b_i$。其中 $c \leq \min\limits_{l \leq i \leq r}\{a_i\}$。显然对于 $c$ 直接使用直线搞定是最优的。而对于 $b_i$ 为连续区间的前提下使用直线处理所作用的区间是用跳线的两倍。故要使 $b_i$ 仅用跳线处理下最优，我们需要让 $b_i$ 直线可作用区间 **极小**，即不可用直线。此时 $b_i$ 必定不连续，显然此时 $c = \min\limits_{l \leq i \leq r}\{a_i\}$。故用 **尽量多的直线** 处理掉 $c$，剩下的 **不连续** 的 $b$ 用跳线处理。这种操作定是最优答案的一种。

## 分类讨论

接下来我们就可以进行分类讨论。我们的目标是将 $a_i$ 处理为 $0$，故遍历到 $i$ 时，增加的线的数量必定为 $a_i$。答案的增量显然是增加线的数量，即 $\text{ans} = \text{ans} + a_i$。显然我们只考虑 $a_i$ 无法取到最优，于是我们可以从 $a_{i + 1}$ 入手。

1. $\text{line}_{i - 1} + \text{dance}_{i - 1} \leq a_{i + 1}$：此时已用的线不够为 $a_{i + 1}$ 作准备，我们需要更多的线来做准备。我们可以先将之前的两种线对 $a_{i + 1}$ 的作用效果反映出来，即 $a_{i + 1} = a_{i + 1} - \text{line}_{i - 1} - \text{dance}_{i - 1}$，此时 $a_{i + 1} > 0$。
此时只考虑 $a_{i + 1}$ 是无法做出最优解法的，我们必须同时考虑 $a_i$：

    1. $a_i \leq a_{i + 1}$：显然全部使用直线即可将 $a_i$ 处理为 $0$。即 $\text{line}_i = \text{line}_{i - 1} + a_i$，$\text{dance}_i = \text{dance}_{i - 2}$，$a_{i + 1} = a_{i + 1} - a_i$，$a_i = 0$；

    2. $a_i > a_{i + 1}$：先使用 $a_{i + 1}$ 条直线覆盖，再使用 $a_{i + 1} - a_i$ 条相邻的跳线覆盖，可将 $a_i$ 处理为 $0$。即 $\text{line}_i = \text{line}_{i - 1} + a_{i + 1}$，$\text{dance}_{i + 1} = \text{dance}_{i - 1} + a_i - a_{i + 1}$，$a_i = a_{i + 1} = 0$。

2. $\text{line}_{i - 1} + \text{dance}_{i - 1} > a_{i + 1}$：说明目前我们拥有的线为 $a_{i + 1}$ 准备过剩了。此时我们就需要考虑停止一些线的作用范围。我们可以记录需要额外停止的数量 $\Delta = \text{line}_{i - 1} + \text{dance}_{i - 1} - a_{i + 1}$。由于我们可以发现两种线均与位置有关，故在处理好 $\Delta$ 后我们需要 $\text{line}_{i - 1} = \text{line}_{i - 1} - \Delta$，$\text{dance}_{i - 1} = \text{dance}_{i - 1} - \Delta$。同时记录 $\text{nxt} = \Delta$，表示有 $\Delta$ 条线可从 $a_{i + 1}$ 恢复出发。这样就可以把该情况转化为情况 $1$。处理恢复情况则可在情况 $1$ 处理后再把 $\text{nxt}$ 加回去，同时在答案中减去可恢复的线的数量。即 $a_{i + 1} = a_{i + 1} + \text{nxt}$，$\text{ans} = \text{ans} - \text{nxt}$。但由于在处理 $\Delta$ 时 $\text{line}_{i - 1}$ 和 $\text{dance}_{i - 1}$ 不能处理为负数，故有下列几种情况特殊考虑：

    1. $\Delta > \text{dance}_{i - 1}$：这是我们需要直接停止部分的直线，让直线刚好覆盖 $a_{i + 1}$。即 $\text{line}_{i - 1} = a_{i + 1}$，此时 $\Delta$ 随之变化，即 $\Delta = \text{dance}_{i - 1}$

    2. $\Delta > \text{line}_{i - 1}$：这时我们需要直接停止部分的跳线，让跳线刚好覆盖 $a_{i + 1}$。即 $\text{dance}_{i - 1} = a_{i + 1}$，此时 $\Delta$ 随之变化，即 $\Delta = \text{line}_{i - 1}$

    3. 情况 $1$、$2$ 均不符合，保持现状。

最后我们需要解决奇数项和偶数项不同跳线的问题。由于两种跳线可看作作用相同的线，我们可以用两个变量存储两种跳线，然后在遍历 $a_i$ 的跳线不同作用项时不停交换即可，即每遍历到下一项则两种跳线数据交换。

最终时间复杂度为 $O(n)$，完全能过。

# 代码演示

```cpp
#include <cstdio>
#include <algorithm>

const int MAXN = 100000;

int main() {
    int t;

    scanf("%d", &t);

    while (t--) {
        int n;
        static long long a[MAXN + 2];

        scanf("%d", &n);

        for (int i = 1; i <= n; i++) {
            scanf("%lld", &a[i]);
        }

        long long line = 0, dance1 = 0, dance2 = 0, ans = 0, nxt = 0;

        for (int i = 1; i <= n; i++) {
            if (a[i + 1] < dance1 + line) {
                int delta = dance1 + line - a[i + 1];

                if (delta > dance1) {
                    line = a[i + 1];
                    delta = dance1;
                }

                if (delta > line) {
                    dance1 = a[i + 1];
                    delta = line;
                }

                line -= delta;
                dance1 -= delta;
                nxt = delta;
                a[i + 1] -= nxt;
            }

            a[i + 1] -= line + dance1;
            ans += a[i];

            if (a[i] <= a[i + 1]) {
                line += a[i];
                a[i + 1] -= a[i];
                a[i] = 0;
            } else {
                line += a[i + 1];
                dance2 += a[i] - a[i + 1];
                a[i] = a[i + 1] = 0;
            }

            a[i + 1] += nxt;
            ans -= nxt;
            nxt = 0;

            std::swap(dance1, dance2);
        }

        printf("%lld\n", ans);
    }

    return 0;
}
```

---

## 作者：Idtwtei (赞：2)

> 给你一个长为 $n$ 的非负整数序列 $a$，你可以进行区间减 $1$，区间奇数下标减 $1$，区间偶数下标减 $1$，请求出讲所有数变为 $0$ 的最小操作次数。
> 
> $1 \le n \le 10^5$。

记 $m$ 为操作种类数，$S_i$ 为第 $i$ 种操作涉及的下标集合，$x_i$ 为第 $i$ 种操作的操作次数，那么可以写成

$$
\begin{aligned}
\min \quad &\sum_{j=1}^{m} x_j \\
\texttt{s.t.} \quad
&\sum_{j=1}^{m} [i \in S_j]x_j = a_i \quad i=1,2,...,n \\
&x_j \ge 0 \quad j=1,2,...,m
\end{aligned}
$$

对每个限制设一个乘数 $p_i$，加入最小化的式子中得到

$$
\begin{aligned}
&\sum_{j=1}^{m} x_j + \sum_{i=1}^{n} p_i (\sum_{j=1}^{m} [i \in S_j]x_i - a_i) \\
&=\sum_{j=1}^{m} (\sum_{i \in S_j} p_i + 1) x_j - \sum_{i=1}^{n} p_ia_i
\end{aligned}
$$

拉格朗日对偶，并将 $p_i$ 取反，得到

$$
\begin{aligned}
\max \quad &\sum_{i=1}^{n} p_ia_i \\
\texttt{s.t.} \quad
&\sum_{i \in S_j} p_i \le 1 \quad j=1,2,...,m \\
\end{aligned}
$$

描述一下就是求出一个序列 $p$ 使得每个可以一起操作的下标集合 $p$ 之和都 $\le 1$，求 $\sum_{i=1}^{n} a_ip_i$ 的最大值。

猜测有整数最优解。假设一个合法的 $p$ 有 $\le -2$ 的数，那么将其改为 $-1$ 仍然合法并且不劣。限制 $p$ 只能取 $-1,0,1$ 即可。

考虑 DP，记 $f_{i,0/1,0/1,0/1}$ 为枚举到 $i$，是否有和为 $1$ 的后缀，是否有后缀满足下标为偶数的和为 $1$，奇数，的最大值。转移枚举当前位选择 $-1,0,1$ 即可。时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int N=1e5+100,INF=1e18;
inline int in(int S,int i){ return (S>>i)&1; }
inline int chkmax(int &x,int y){ return y>x?x=y,1:0; }
#define gc getchar()
#define rd read()
inline int read(){
    int x=0,f=0; char c=gc;
    for(;c<'0'||c>'9';c=gc) f|=(c=='-');
    for(;c>='0'&&c<='9';c=gc) x=(x<<1)+(x<<3)+(c^48);
    return f?-x:x;
}

int n,a[N],f[N][8];

void solve(){
    n=rd; for(int i=1;i<=n;++i) a[i]=rd;
    for(int i=0;i<=n;++i) for(int j=0;j<8;++j) f[i][j]=-INF; f[0][0]=0;
    for(int i=1;i<=n;++i){
        for(int j=0;j<8;++j){
            for(int x:{-1,0,1}){
                if(in(j,0)==1&&x==1) continue;
                if(i&1){ if(x!=1||!in(j,2)) chkmax(f[i][(in(j,0)+x==1)|(in(j,1)<<1)|((in(j,2)+x==1)<<2)],f[i-1][j]+x*a[i]); }
                else{ if(x!=1||!in(j,1)) chkmax(f[i][(in(j,0)+x==1)|((in(j,1)+x==1)<<1)|(in(j,2)<<2)],f[i-1][j]+x*a[i]); }
            }
        }
    }
    int ans=0; for(int i=0;i<8;++i) chkmax(ans,f[n][i]);
    printf("%lld\n", ans);
}

signed main(){

    int T=rd;
    while(T--) solve();

    return 0;
}
```

---

## 作者：Purslane (赞：1)

# Solution

贪心是不可能会的。

本题本质上给了你 $O(n)$ 个集合 $S_i$。你可以花费 $1$ 的代价，对于所有 $u \in S_i$，使得 $a_u \leftarrow a_u-1$。问将 $a$ 全部变为 $0$ 的最小总代价。

------

这个就是标准的线性规划问题（虽然是整数线性规划，但是我们相信得出的解一定是最优解！！）

那么有：

$$
\text{minimize} \sum v_i \ \text{  s.t.} \\
\sum_{j \in S_i} v_j = a_i
$$

也就是

$$
\sum_{j \in S_i} v_i \ge a_j \\
\sum_{j \in S_i} -v_i \ge -a_j \\
$$

使用拉格朗日乘数法容易得出对偶结果：给每个位置标一个权值 $w_i$，要求

$$
\sum_{j \in S_i} w_j \le 1
$$

且最大化 $\sum a_iw_i$。

相信 $w_i$ 最优解一定都是整数。

-------

考虑 DP。从左往右 DP，我们记录 $(x,y,z)$ 表示限制：

1. 奇数位上的数必须 $\le x$ 和 $\le y$；
2. 偶数位上的数必须 $\le x$ 和 $\le z$。

考虑其组合意义。由于我们的限制都是作用在最大子段和上，一个位置 $\le x$ 就表示已经能找到一段 $\ge 1-x$ 了，所以 $x,y,z \in \{0,1\}$。

而且，显然一个位置 $\le -2$，将其调整为 $-1$ 并不会让合法的序列变得不合法——因为任何一个子段和已经 $\le 1$ 了。

所以每个位置只有 $-1$、$0$、$1$ 三种可能。直接 DP 即可。复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100000+10;
int T,n,a[MAXN],dp[MAXN][2][2][2];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		cin>>n;
		ffor(i,1,n) cin>>a[i];
		memset(dp,-0x3f,sizeof(dp));
		dp[0][1][1][1]=0;
		ffor(i,1,n) {
			ffor(ox,0,1) ffor(oy,0,1) ffor(oz,0,1) {
				int lim=ox;
				if(i%2==0) {
					lim=min(lim,oy);
					ffor(nv,-1,lim) dp[i][min(1ll,ox-nv)][min(1ll,oy-nv)][oz]=max(dp[i][min(1ll,ox-nv)][min(1ll,oy-nv)][oz],dp[i-1][ox][oy][oz]+nv*a[i]);
				}
				else {
					lim=min(lim,oz);
					ffor(nv,-1,lim) dp[i][min(1ll,ox-nv)][oy][min(1ll,oz-nv)]=max(dp[i][min(1ll,ox-nv)][oy][min(1ll,oz-nv)],dp[i-1][ox][oy][oz]+nv*a[i]);
				}
			}
		}
		int mx=0;
		ffor(i,1,n) ffor(x,0,1) ffor(y,0,1) ffor(z,0,1) mx=max(mx,dp[n][x][y][z]);
		cout<<mx<<'\n';
	}
	return 0;
}
```

---

## 作者：_Cheems (赞：1)

闲话：初看此题，以为是神秘 dp，感觉很难优化。看了贪心解法后大受震撼，真的很难想啊。

题意：给定序列 $a_1\dots a_n$，有两种操作：区间减一、区间奇数位置或偶数位置减一。求消为 $0$ 最小次数。$n\le 10^5$。

记操作一为“直线”、操作二为“跳线”。

考虑增量法构造。不妨先考虑消掉 $a_1$：

* $a_2=0$：只能用跳线。
* $a_2>0$：用直线覆盖 $a_1,a_2$ 直到归约为 $a_2=0$。原因也很简单，假如没有一条直线覆盖 $a_1,a_2$，那么必然是若干跳线，注意到两条交织的跳线等价于一条直线加一条跳线，所以先用直线不劣。

对于一般情况，额外考虑一下前面接过来的线。记 $z$ 为直线，$t_0$ 为可跳到 $i$ 的跳线，$t_1$ 反之。

分讨一下：

* $a_i\ge z+t_0$：直接全部保留即可。
* $a_i<z+t_0$：必须放弃 $k=z+t_0-a_i$ 条线。不好决定放弃哪些种类怎么办？类似反悔，令 $z,t_0$ 均减去 $k$，新增 $k$ 条免费线即可。当 $z<k$ 时必然 $t_0$ 要舍弃 $k-z$ 条，直接丢掉即可。所以不会出现负数情况。

最后的问题是怎么处理新增的免费线？让 $ans$ 减去 $k$，但是万一线没用完呢？可以令 $a_i=k$，这样强制新增 $k$ 条线。

$O(n)$。
#### 代码
枚举 $(i-1,i)$，将 $a_{i-1}$ 清空，分讨然后推到 $(i,i+1)$。


```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1e5 + 5;
int T, n, a[N];

signed main(){
	cin >> T;
	while(T--){
		scanf("%lld", &n);
		for(int i = 1; i <= n; ++i) scanf("%lld", &a[i]);
		a[n + 1] = 0;
		int z = 0, t0 = 0, t1 = 0, ans = 0, free;
		for(int i = 2; i <= n + 1; ++i){
			free = 0;
			if(z + t0 > a[i]){
				int k = z + t0 - a[i];
				if(k > z) t0 -= k - z, k -= k - z;
				if(k > t0) z -= k - t0, k -= k - t0;
				z -= k, t0 -= k, free = k, a[i] = 0;
			}
			else a[i] -= z + t0;
			
			int add_z = min(a[i - 1], a[i]);
			z += add_z, ans += add_z, a[i - 1] -= add_z, a[i] -= add_z;
			t1 += a[i - 1], ans += a[i - 1], a[i - 1] = 0;
			
			a[i] += free, ans -= free;
			swap(t0, t1);
		}
		printf("%lld\n", ans);
	}
	return 0;
}

```

---

## 作者：Needna (赞：1)

本题解思路来源于 dead_X。

这是一道非常好的贪心题目，首先需要证明在下一个点大于零时，把连续值相减一定是不劣的，可以手搓几个数据或者看看其他 dalao 的题解，我主要来讲一下实现方式。以下简称 $a_{i}$ 的连续操作为 $A_{i}$，不连续的操作为 $B_{i}$。

对于 $a_{i}$ 来说,汇过来的操作有 $A_{i-1}$ 和 $B_{i-2}$。那就会有2种情况，其中一种是 $a_{i}< B_{i-2}+A_{i-1}$。对于这种情况，我们可以处理成 $a_{i}=X\times B+Y\times A+W$。 $W$ 为可以自由选择操作种类的个数。其中 $X$ 和 $Y$ 为必须选的个数，取法如下：

```cpp
A=num[i]-A;B=num[i]-B;swap(A,B),W=num[i]-A-B;
```
无论对于是否 $a_{i}< B_{i-2}+A_{i-1}$ 我们都把 $a_{i}$ 的值设置为 $a_{i}=a_{i}-B_{i-2}+A_{i-1}$（此处的 $A_{i-1}$，$B_{i-2}$ 都是修改过后的）所以剩下的值就是可以随便选择操作种类的。对于随便取的值，自然也满足我们的贪心策略，即 $a_{i+1}\ge0$ 时选连续操作。最后剩下的，我们就取非连续操作。

AC code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int num[N],ans,T,n;
signed main(){
    cin>>T;
    while(T--){
		cin>>n;ans=0;
		for(int i=1;i<=n;i++)cin>>num[i];num[n+1]=0;
		for(int i=1,b1=0,b2=0,a1=0,w,v=0;i<=n;i++,swap(b1,b2)){
			w=0;a1=min(num[i],a1),b2=min(b2,num[i]);
			if(a1+b2>num[i]){
				a1=num[i]-a1;b2=num[i]-b2;swap(a1,b2),w=num[i]-b2-a1;
			}num[i]-=a1+b2;
			if(num[i]&&num[i+1]-a1-b1>0){
				int v=min(num[i+1]-a1-b1,num[i]);
				ans+=max(v-w,0ll),w=max(w-v,0ll),a1+=v,num[i]-=v;
			}ans+=max(num[i]-w,0ll),b2+=num[i];
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：TernaryTree (赞：1)

一共有 $\dfrac32n(n+1)$ 种操作。包含一部分重复的和没用的，如对 $[1,1]$ 区间进行最后一种操作，但是这个东西不影响实际情况，所以无所谓。

我们给每种操作一个值 $x_i$，表示这种操作进行的次数。那么问题即为

$$
\begin{aligned}
&\min \sum x_i\\
\text{s.t.}& \sum_{\text{和位置 } i \text{ 有关的操作}}x_i\ge a_i\\
& -\sum_{\text{和位置 } i \text{ 有关的操作}}x_i\ge -a_i
\end{aligned}
$$

这个东西是一个线性规划模型，可以通过对偶得到：

$$
\begin{aligned}
&\max \sum a_i(p_i-q_i)\\
\text{s.t.}& \sum_{\text{操作 } i \text{ 包含的位置}}p_i-q_i\le 1\\
\end{aligned}
$$

记 $r_i=p_i-q_i$。设计一个 dp：$f_{i,x,y,z}$ 表示到了 $i$ 位置，形如 $[l,i]$ 的三种操作的 $r_i$ 最大值。转移时枚举 $r_{i}$ 转移。

首先状态就有问题。显然 $x,y,z\le 1$，但是没有下界，这个很难办。我们考虑一下 $x,y,z$ 是负数的情况。实际上，要转移的时候，在这些后缀里面加上一个数的最大值，甚至还不会超过你要加的这个数本身，所以 $x,y,z$ 是对 $0$ 取 $\max$ 的，于是 $0\le x,y,z\le 1$。

现在状态数量是对了，转移呢？首先仍有 $r_i\le 1$，因为更大的不合法；我们考虑 $r_i\lt -1$ 会怎样。这个时候我们发现，因为有了 $x,y,z$ 的限制，转移时需要对 $0$ 取 $\max$，所以 $r_i<-1$ 的转移位置和 $r_i=-1$ 是一样的，同时 $r_i$ 更小也不会导致答案更大，所以没有必要更新。综上，枚举 $-1\le r_i\le 1$ 即可。

综上我们用 $24n$ 的时间解决了这个题。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1e5 + 10;

int T, n, ans;
int a[maxn];
int f[maxn][2][2][2];

signed main() {
	cin >> T;
	while (T--) {
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> a[i];
		memset(f, -0x3f, sizeof(f));
		ans = 0;
		f[0][0][0][0] = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = -1; j <= 1; j++) {
				for (int x = 0; x <= 1; x++) {
					for (int y = 0; y <= 1; y++) {
						for (int z = 0; z <= 1; z++) {
							int nx = max(x + j, 0ll), ny, nz;
							if (i & 1) ny = max(y + j, 0ll), nz = z;
							else ny = y, nz = max(z + j, 0ll);
							if (nx <= 1 && ny <= 1 && nz <= 1) f[i][nx][ny][nz] = max(f[i][nx][ny][nz], f[i - 1][x][y][z] + j * a[i]);
						}
					}
				}
			}
		}
		for (int x = 0; x <= 1; x++) {
			for (int y = 0; y <= 1; y++) {
				for (int z = 0; z <= 1; z++) {
					ans = max(ans, f[n][x][y][z]);
				}
			}
		}
		cout << ans << endl;
	}
	return 0;
}

```

---

## 作者：0x3F (赞：0)

~~NOIP 考前写题解涨 rp~~

线性规划对偶入门题。

假设有 $m$ 种操作，第 $i$ 种操作将下标在 $S_i$ 中的所有数都 $-1$，这种操作进行了 $x_i$ 次。

原问题为：

$$
\begin{aligned}
\min\quad&\sum_{j=1}^{m}x_j
\\
\text{s.t.}\quad&\forall1\le i\le n,\sum_{j=1}^{m}[i\in S_j]x_j\ge a_i
\\
&\forall1\le i\le n,\sum_{j=1}^{m}-[i\in S_j]x_j\ge -a_i
\\
&\forall1\le j\le m,x_j\ge0
\end{aligned}
$$

对偶问题为：

$$
\begin{aligned}
\max\quad&\sum_{i=1}^{n}(u_i-v_i)
\\
\text{s.t.}\quad&\forall1\le j\le m,\sum_{i=1}^{n}[i\in S_j](u_i-v_i)\le1
\\
&\forall1\le i\le n,u_i\ge0,v_i\ge0
\end{aligned}
$$

令 $y_i=u_i-v_i$，则 $y_i$ 不再有非负限制。

称一个区间内的奇数或偶数为一个“跳跃区间”。题意变为：给每一个下标赋一个权值 $y_i$，要求每一个区间内 $y_i$ 的和不超过 $1$，每一个“跳跃区间”内的 $y_i$ 的和也不超过 $1$，要求最大化所有位置 $a_iy_i$ 的和。

记 $dp_{i,x,y,z}$ 表示 $1\sim i$ 都已经填完了，以 $i$ 结尾的区间权值和最大为 $x$（和 $0$ 取 $\max$，下同），以 $i$ 结尾的“跳跃区间”权值和最大为 $y$，以 $i-1$ 结尾的“跳跃区间”权值和最大为 $z$。

我们宣称最优解中，$y_i$ 必然为整数。故 $x,y,z$ 只能取 $0$ 或 $1$，因此 $y_i$ 只需要考虑 $-1,0$ 或 $1$ 即可。转移是简单的。

时间复杂度为 $\mathcal{O}(n)$，带有 $24$ 的常数。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 1e5 + 10;
int Testcases, n, a[_];
long long dp[_][2][2][2], ans;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> Testcases;
    while (Testcases--) {
        cin >> n;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
        }
        for (int i = 0; i <= n; i++) {
            for (int x = 0; x <= 1; x++) {
                for (int y = 0; y <= 1; y++) {
                    for (int z = 0; z <= 1; z++) {
                        dp[i][x][y][z] = 0LL;
                    }
                }
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int x = 0; x <= 1; x++) {
                for (int y = 0; y <= 1; y++) {
                    for (int z = 0; z <= 1; z++) {
                        for (int w = -1; w <= 1; w++) {
                            long long val = dp[i-1][x][y][z] + w * a[i];
                            int xx = max(x + w, 0);
                            int yy = max(z + w, 0);
                            int zz = y;
                            if (xx <= 1 && yy <= 1 && zz <= 1) {
                                dp[i][xx][yy][zz] = max(dp[i][xx][yy][zz], val);
                            }
                        }
                    }
                }
            }
        }
        ans = 0LL;
        for (int x = 0; x <= 1; x++) {
            for (int y = 0; y <= 1; y++) {
                for (int z = 0; z <= 1; z++) {
                    ans = max(ans, dp[n][x][y][z]);
                }
            }
        }
        cout << ans;
        if (Testcases) {
            cout << '\n';
        }
    }
    cout << endl;
    return 0;
}
```

---

## 作者：freoepn (赞：0)

首先可以发现一个结论 : 当 $a_i > 0$ 时，若 $a_{i+1} > 0$ ，一定从 $i$  开始做操作 $1$ ，若 $a_{i+1} = 0$ ，一定从 $i$  开始做操作 $2$ 或操作 $3$ ，因为若 $a_{i+1} > 0$ ，做操作 $2$ 或操作 $3$  会跳过  $i+1$ ，不如从 $i+2$  开始做操作 $2$ 或操作 $3$ 。
  
  维护每个元素前面有多少个操作能接上它 ，设有 $x$ 个操作 $1$ ，  $y$ 个操作 $2$ 或操作 $3$ ,若 $x+y \leq a_i$ 直接减去 $x+y$ 即可，若 $x+y > a_i$ ,有 $k = x+y-a_i$ 个序列无法操作往后接 ，考虑将 $a$ 和 $b$ 都减去 $k$ ,就变成了可以从 $i$ 开始免费接 $k$ 个操作，递推即可。

  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int kMaxN = 1e5 + 5;
int t, n;
int a[kMaxN];
int p[kMaxN], pp[kMaxN];
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> t;
  while (t--) {
    cin >> n;
    for (int i = 1; i <= n; i++) {
      p[i] = pp[i] = 0;
      cin >> a[i];
    }
    a[n+1] = 0;
    int ans = 0;
    p[1] = pp[1] = 0;
    for (int i = 1; i <= n; i++) {
      int x = p[i + 1], y = pp[i + 1], z = x + y - a[i + 1];
      if (a[i + 1] < x + y) {
        if (z > x) {
          y -= (z - x);
          z -= (z - x);
        }
        if (z > y) {
          x -= (z - y);
          z -= (z - y);
        }
        x -= z, y -= z, a[i + 1] -= z;
      } else {
        z = 0;
      }
      p[i + 2] = x, pp[i + 3] = y, a[i + 1] -= x + y;
      ans += a[i] - z;
      int q = min(a[i], a[i + 1]);
      a[i] -= q, a[i + 1] -= q, p[i + 2] += q;
      pp[i + 2] += a[i];
      a[i + 1] += z, z = 0;
    }
    cout << ans << '\n';
  }
  return 0;
}
```

---


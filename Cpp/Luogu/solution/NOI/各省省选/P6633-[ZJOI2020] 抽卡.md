# [ZJOI2020] 抽卡

## 题目描述

Bob 喜欢抽卡。

Bob 最近入坑了一款叫 “主公连结” 的抽卡游戏。游戏中共有 $n$ 个不同的角色，编号为 $1 \sim n$。当 Bob 获得其中的编号连续的 $k$ 张卡时，就可以组出理论最强阵容。

当期卡池中共有 $m$ 张不同的卡，每次抽卡，Bob 都可以等概率随机获得一张卡池中的卡。如果 Bob 抽到了一张他已经拥有的卡，那么什么事都不会发生，等于 Bob 浪费了这次抽卡机会。Bob 是个谨慎的人，他想知道，如果他不停地抽卡直到抽到编号连续的 $k$ 张卡时停止抽卡，期望需要抽多少轮。

## 说明/提示

**样例解释 1**

如果第一轮抽到的是 $2$ 号卡，那么期望需要抽 $1 + \frac{3}{2}$ 轮；如果第一轮抽到的是 $1$ 号卡或 $3$ 号卡，那么期望需要抽 $1 + 3$ 轮。故答案为 $\frac{1}{3}(1 + \frac{3}{2}) + \frac{2}{3}(1 + 3) = 3.5$

**数据范围与约定**

对于前 $10\%$ 的数据，$m \le 10$。   
对于另外 $10\%$ 的数据，$m \le 500$ 且 $k = m−1$。   
对于另外 $10\%$ 的数据，$m \le 500$ 且保证有且仅有一组理论最强阵容。   
对于另外 $10\%$ 的数据，$m \le 500$ 且保证任意两组可抽出的理论最强阵容不交。   
对于前 $50\%$ 的数据，$m \le 500$。   
对于前 $70\%$ 的数据，$m \le 5000$。   
对于另外 $10\%$ 的数据，$k = 5$。   
对于另外 $10\%$ 的数据，$k = 2000$。   
对于 $100\%$ 的数据，$1 \le m \le 200000,1 \le a_i \le 2m,2 \le k \le m$，保证卡池中至少存在一组 可抽出的理论最强阵容（即编号连续的 $k$ 张卡）。

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
10 2
1 2 3 4 5 7 8 9 11 12```

### 输出

```
839792873```

# 题解

## 作者：Fuyuki (赞：12)

定义存在连续 $k$ 张卡的状态为合法状态，不存在的为非法状态。

朴素的想法是考虑状压，因为状态转移没有比自环大的环，且合法状态不会转化成非法状态，所以第一次出现合法状态的期望时间可以表示成所有非法状态的出现概率乘以到下次转移的期望时间。

如果状态中抽了 $r$ 张卡，那么这个状态有 $\frac{1}{\binom{m}{r}}$ 的概率出现，并且期望经过 $\frac{m}{m-r}$ 的时间后会转移到下个状态。所以只需要计算出取 $r$ 张牌的非法状态数量即可。

对每一个连续段分别计数，假设当前连续段的长度为 $n$，那么选 $r$ 张牌的非法状态数为：
$$
[x^{n+1-r}](\sum_{i=0}^{k-1}x^i)^r
$$
就是每次加入一段连续的 $1$ 和紧跟着的一个 $0$，$1$ 的数量可以直接用加入的段数，即 $r$ 进行描述。

设 $G(x)=\sum_{i=1}^{k}x^i$，那么就是求：
$$
[x^{n+1}]\frac{1}{1-uG(x)}
$$
二元生成函数也是可以拉格朗日反演的，所以直接上扩展拉格朗日反演：
$$
[x^{n+1}]\frac{1}{1-uG(x)}=\frac{1}{n+1}[x^n]\frac{u}{(1-ux)^2}(\frac{x}{G^{-1}(x)})^{n+1}
$$
这样挂在 $u$ 上面的 $x$ 只有一项，就只剩下最右边的一项需要计算了。

因为有 $G(x)=\frac{x^{k+1}-x}{x-1}$，所以求 $G^{-1}(x)$ 等价于求一 $F(x)$ 使得：
$$
\frac{F(x)^{k+1}-F(x)}{F(x)-1}=x\Leftrightarrow (1+x)F(x)-F(x)^{1+k}-x=0
$$
牛顿迭代即可在 $O(nlogn)$ 的时间内求出。

最后需要将每一段对应的生成函数乘起来，所以总复杂度为 $O(mlog^2m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define ll long long int
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
const int N=1<<20,mod=998244353;
int m,k,tot,lmt,ans,a[N];
int big[N<<5],*np(big),*t[N],f[N];
int w[N],r[N],fac[N],inv[N],ifac[N],len[N];
V check(int&x){x-=mod,x+=x>>31&mod;}
I Pow(ll t,int x,ll s=1){
	for(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;
	return s;
}
V cl(int*op,int*ed){memset(op,0,ed-op<<2);}
I getLen(int n){return 1<<32-__builtin_clz(n);}
V mul(int*a,ll k,int l,int*b){while(l--)*b++=k**a++%mod;}
I C(int x,int y){return 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;}
V dot(int*a,int*b,int l,int*c){while(l--)*c++=1ll**a++**b++%mod;}
V init(int n){
	int l=-1,wn;
	for(lmt=inv[0]=inv[1]=fac[0]=ifac[0]=1;lmt<=n;lmt<<=1)l++;
	FOR(i,2,n-1)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	FOR(i,1,n-1)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	FOR(i,1,lmt-1)r[i]=r[i>>1]>>1|(i&1)<<l;
	wn=Pow(3,mod>>++l),w[lmt>>1]=1;
	FOR(i,lmt/2+1,lmt-1)w[i]=1ll*w[i-1]*wn%mod;
	ROF(i,lmt/2-1,1)w[i]=w[i<<1];
}
V DFT(int*a,int l){
	static unsigned long long int tmp[N];
	int t,u=__builtin_ctz(lmt/l);
	FOR(i,0,l-1)tmp[i]=a[r[i]>>u];
	for(int i=1;i<l;i<<=1)for(int j=0,d=i<<1;j<l;j+=d)FOR(k,0,i-1)
		t=tmp[i|j|k]*w[i|k]%mod,tmp[i|j|k]=tmp[j|k]+mod-t,tmp[j|k]+=t;
	FOR(i,0,l-1)a[i]=tmp[i]%mod;
}
V IDFT(int*a,int l){reverse(a+1,a+l),DFT(a,l),mul(a,mod-mod/l,l,a);}
V Inv(const int*a,int n,int*b){
	if(n==1)return void(b[0]=Pow(a[0],mod-2));
	static int tmp[N],l;
	Inv(a,n+1>>1,b),copy(a,a+n,tmp),DFT(tmp,l=getLen(n<<1)),DFT(b,l);
	FOR(i,0,l-1)b[i]=(2ll+mod-1ll*tmp[i]*b[i]%mod)*b[i]%mod;
	IDFT(b,l),cl(b+n,b+l),cl(tmp,tmp+l);
}
V conv(int*a,int*b,int l,int*c){DFT(a,l),DFT(b,l),dot(a,b,l,c),IDFT(c,l);}
V deri(const int*a,int n,int*b){FOR(i,1,n-1)b[i-1]=1ll*i*a[i]%mod;b[n-1]=0;}
V inte(const int*a,int n,int*b){FOR(i,1,n-1)b[i]=1ll*inv[i]*a[i-1]%mod;b[0]=0;}
V Ln(const int*a,int n,int*b){
	static int tmp[N],l;
	l=getLen(n<<1),Inv(a,n,tmp),deri(a,n,b);
	conv(tmp,b,l,tmp),inte(tmp,n,b),cl(b+n,b+l),cl(tmp,tmp+l);
}
V Exp(const int*a,int n,int*b){
	if(n==1)return void(b[0]=1);
	static int tmp[N],l;
	Exp(a,n+1>>1,b),Ln(b,n,tmp),tmp[0]--;
	FOR(i,0,n-1)check(tmp[i]=a[i]+mod-tmp[i]);
	conv(b,tmp,l=getLen(n<<1),b),cl(b+n,b+l),cl(tmp,tmp+l);
}
V Mul(const int*a,const int*b,int n,int m,int*c){
	static int X[N],Y[N],l;
	l=getLen(n+m-1),copy(a,a+n,X),copy(b,b+m,Y);
	conv(X,Y,l,X),copy(X,X+n+m-1,c),cl(X,X+l),cl(Y,Y+l);
}
V Pow(const int*a,int n,int k,int*b){
	static int tmp[N];
	if(n>1)Ln(a,n,tmp),mul(tmp,k,n,tmp),Exp(tmp,n,b),cl(tmp,tmp+n);
}
V solve(int n){
	if(n==1)return void(f[0]=0);
	static int tmp[N],up[N],dw[N],l;
	solve(n+1>>1),l=getLen(n<<1),Pow(f+1,n-k,k,tmp+k),mul(tmp,mod-1,n,tmp);
	FOR(i,0,n-1)dw[i]=1ll*(k+1)*tmp[i]%mod;
	dw[0]++,dw[1]++,tmp[0]++,tmp[1]++,Mul(f,tmp,n,n,up),check(up[1]+=mod-1);
	cl(tmp,tmp+l),Inv(dw,n,tmp),cl(up+n,up+n+n-1),conv(tmp,up,l,tmp);
	FOR(i,0,n-1)check(f[i]+=mod-tmp[i]);
	cl(tmp,tmp+l),cl(up,up+l),cl(dw,dw+l);
}
V calc(int*g,int n){
	Pow(f+1,n+1,mod-n-1,g);
	FOR(i,0,n)g[i]=1ll*(n-i+1)*g[i]%mod*inv[n+1]%mod;
}
int main(){
	scanf("%d%d",&m,&k);
	FOR(i,1,m)scanf("%d",a+i);
	sort(a+1,a+m+1),init(m+2<<1);
	for(int p=1,d=0;p<=m;p+=d,len[++tot]=d+1)for(d=0;a[p+d]==a[p]+d;d++);
	sort(len+1,len+1+tot),solve(len[tot]+1);
	FOR(i,1,tot)
		if(t[i]=np,np+=len[i],len[i]==len[i-1])copy(t[i-1],t[i-1]+len[i],t[i]);
		else calc(t[i],len[i]-1);
	for(int x=1,y;y=x+1,x<tot;len[tot]=len[x]+len[y]-1,np+=len[tot],x+=2)
		t[++tot]=np,Mul(t[x],t[y],len[x],len[y],t[tot]);
	FOR(i,0,m)check(ans+=1ll*t[tot][i]*Pow(1ll*C(m,i)*(m-i)%mod,mod-2,m)%mod);
	return cout<<ans,0;
}
```

---

## 作者：Scintilla (赞：8)

**题面中的 $m$ 是本题解中的 $n$，并且本题解的题意是按照下面的简化题意来的。**

**Description**

给定长度为 $n$ 的序列 $\{a_1, a_2, \cdots, a_n\}$ 和常数 $k$，每秒等概率得到其中的一个数，求得到的数中第一次出现连续 $k$ 个整数时的期望秒数。$n \le 2 \times 10^5$。

**Solution**

首先把期望问题转化为计数问题，我们显然只需要对每个连续的数值连续的子段考虑，对于每个 $i$ 分别求出每段 $i$ 秒后第一次得到连续 $k$ 个数的方案数，才能计算总的期望。更进一步地，经过一些简单的转化，我们只需要解决下面的 $\rm Subproblem$：

> 每秒等概率得到 $[1, n]$ 的一个整数并且不会和之前的重复，对每个 $i$ 求出在第 $i$ 秒第一次出现连续 $k$ 个整数的方案数。

如果求出了这个东西，把每一段对应的生成函数乘起来即可得到答案的生成函数。发现我这个菜鸡想不出什么其他的方法，于是考虑生成函数。但是发现正面直接求颇为困难，正难则反，我们不妨设 $f_i$ 为第 $i$ 秒时没有连续 $k$ 个整数的方案数，设答案的生成函数为 $f(x) = \sum_i f_ix^i$。假设我们求出了这个，我们考虑把期望步数一步一步算就能得出答案了。我们枚举连续整数段的长度（可以为空）并强制在两段之间隔上一个整数。所以令 $g_k(x) = \sum_{i = 0} ^ {k - 1} x^i = \frac{1 - x^k}{1 - x}$，那么我们有

$$f_i = [x^{i}] g_k^{n - i + 1}(x)$$

发现要求的幂次和 $g$ 的幂次都在变化，考虑让其中的一个不变，不难想到设 $h_k(x) = xg_k(x)$，那么

$$ f_i = [x^{n + 1}] h_k^{n - i + 1}(x) $$

幂次相同了，一起求的时候需要加以区分，于是不妨添加一个辅元 $y$：

$$ f_i = [x^{n + 1}] (h_k(x)y) ^ {n - i + 1} $$

$$ f(y) = [x^{n + 1}]\sum\limits_{i = 0} ^ {n + 1}(h_k(x)y) ^ {n - i + 1} = [x^{n + 1}] \frac{1 - (h_k(x)y) ^ {n + 2}}{ 1 - h_k(x)y} $$

现在要做的就是把 $y$ 分离出来，不难想到拓展拉格朗日反演。设 $P(x) = \frac{1 - (xy) ^ {n + 2}}{1 -xy}$ 并设 $h_k(x)$ 的复合逆为 $D(x)$。$D(x)$ 的求法可以考虑大名鼎鼎的牛顿迭代。具体地：

$$ h_k(D(x)) = \frac{D(x) - D^{k + 1}(x)}{1 - D(x)} = x \Leftrightarrow (1 + x) D(x) - D^{k + 1}(x) - x \equiv 0 $$

所以 $(1 + x) D(x) - D^{k + 1}(x) - x \equiv 0$。设 $T(D(x)) = (1 + x) D(x) - D^{k + 1}(x) - x$，有

$$ \begin{aligned}
    D(x) &\equiv D_0(x) - \frac{T(D_0(x))}{T'(D_0(x))} \\
    &\equiv D_0(x) - \frac{(1 + x) D_0(x) - D_0^{k + 1}(x) - x}{ 1 + x - (k + 1) D_0^k(x)}
\end{aligned} $$

这样就能求出 $D(x)$ 了，让我们继续上面的推导。

$$ \begin{aligned}
    [x^{n + 1}] \frac{1 - (h_k(x)y) ^ {n + 2}}{ 1 - h_k(x)y} &= [x^{n + 1}]P(h_k(x)) \\
    &= \frac{1}{n + 1} [x^n] P'(x) \left( \frac{x}{D(x)} \right) ^ {n + 1}
\end{aligned} $$

令 $Q(x) = \frac{x}{D(x)}$：

$$ \begin{aligned}
    \frac{1}{n + 1} [x^n] P'(x) \left( \frac{x}{D(x)} \right) ^ {n + 1} &= \frac{1}{n + 1} [x^n] P'(x) Q^{n + 1}(x) \\
    &= \frac{1}{n + 1} [x^n] Q^{n + 1}(x) \sum\limits_{i = 1} ^ {n + 1} ix^{i - 1}y^i
\end{aligned} $$

所以

$$ f_i = \frac{1}{n + 1} [x^ny^{n - i + 1}] Q^{n + 1}(x) \sum\limits_{i = 1} ^ {n + 1} ix^{i - 1}y^i = \frac{n - i + 1}{n + 1} [x^i] Q^{n + 1}(x) $$

于是这个题就被解决了。因为要对每一段求积，所以总时间复杂度为 $\mathcal{O}(n \log ^ 2 n)$。

代码（极其丑陋且常数极大）：
```cpp
#include <bits/stdc++.h>

using namespace std;

#define il inline
#define re register
#define rep(i, s, e) for (re int i = s; i <= e; ++i)
#define drep(i, s, e) for (re int i = s; i >= e; --i)
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)

const int mod = 998244353;
const int ng = 3;
const int ngi = 332748118;

const int N = 800010;

il int read() {
    int x = 0; bool f = true; char c = getchar();
    while (!isdigit(c)) {if (c == '-') f = false; c = getchar();}
    while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return f ? x : -x;
}

il int inc(int x, int y) { return (x += y) >= mod ? x - mod : x; }
il int dec(int x, int y) { return (x -= y) < 0 ? x + mod : x; }
il int mul(int x, int y) { return 1ll * x * y % mod; }

il int qpow(int a, int b) {
    int res = 1;
    for (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);
    return res;
}

il int Inv(int x) {
    return qpow(x, mod - 2);
}

int fac[N], inv[N], finv[N];
il void init(int w) {
    fac[0] = 1, inv[1] = 1, finv[0] = 1;
    rep(i, 1, w) fac[i] = mul(fac[i - 1], i);
    rep(i, 2, w) inv[i] = mod - mul(mod / i, inv[mod % i]);
    rep(i, 1, w) finv[i] = mul(finv[i - 1], inv[i]);
}

il int C(int x, int y) {
    if (x < y || y < 0) return 0;
    return mul(fac[x], mul(finv[y], finv[x - y]));
}

int r[N];
il void NTT(int *f, int lim, int opt) {
    rep(i, 0, lim - 1) if (i < r[i]) swap(f[i], f[r[i]]);
    for (re int o = 2, k = 1; k < lim; o <<= 1, k <<= 1) {
        int d = qpow(opt == 1 ? ng : ngi, (mod - 1) / o);
        for (re int i = 0; i < lim; i += o) {
            for (re int g = 1, j = 0; j < k; ++j, g = mul(g, d)) {
                int u = f[i + j], v = mul(g, f[i + j + k]);
                f[i + j] = inc(u, v), f[i + j + k] = dec(u, v);
            }
        }
    }
    if (opt == -1) {
        int invl = Inv(lim);
        rep(i, 0, lim - 1) f[i] = mul(f[i], invl);
    }
}

il void InitNTT(int lim) {
    rep(i, 0, lim - 1) r[i] = (r[i >> 1] >> 1) | ((i & 1) * (lim >> 1));
}

il void PolyMul(int *f, int *g, int lim) {
    InitNTT(lim);
    NTT(f, lim, 1), NTT(g, lim, 1);
    rep(i, 0, lim - 1) f[i] = mul(f[i], g[i]);
    NTT(f, lim, -1);
}

int IF[N], I[N];
il void PolyInv(int *f, int *g, int pw) {
    I[0] = Inv(f[0]), I[1] = 0;
    for (re int o = 4, k = 2; k < (pw << 1); o <<= 1, k <<= 1) {
        rep(i, 0, k - 1) IF[i] = f[i];
        rep(i, k, o - 1) IF[i] = 0, I[i] = 0;
        InitNTT(o);
        NTT(I, o, 1), NTT(IF, o, 1);
        rep(i, 0, o - 1) I[i] = mul(I[i], dec(2, mul(I[i], IF[i])));
        NTT(I, o, -1);
        rep(i, k, o - 1) I[i] = 0;
    }
    rep(i, 0, pw - 1) g[i] = I[i];
}

il void PolyDe(int *f, int *g, int pw) {
    rep(i, 0, pw - 2) g[i] = mul(f[i + 1], i + 1);
    g[pw - 1] = 0;
}

il void PolyInt(int *f, int *g, int pw) {
    drep(i, pw - 1, 1) g[i] = mul(f[i - 1], inv[i]);
    g[0] = 0;
}

int L[N], LI[N];
il void PolyLn(int *f, int *g, int pw) {
    PolyDe(f, L, pw), PolyInv(f, LI, pw);
    int lim = 1;
    while (lim <= (pw - 1) + (pw - 2)) lim <<= 1;
    rep(i, pw, lim - 1) L[i] = LI[i] = 0;
    PolyMul(L, LI, lim);
    PolyInt(L, g, pw);
}

int E[N], EL[N], EF[N];
il void PolyExp(int *f, int *g, int pw) {
    E[0] = 1, E[1] = 0;
    for (re int o = 4, k = 2; k < (pw << 1); o <<= 1, k <<= 1) {
        rep(i, 0, k - 1) EL[i] = 0, EF[i] = f[i];
        rep(i, k, o - 1) E[i] = EL[i] = EF[i] = 0;
        PolyLn(E, EL, k);
        InitNTT(o);
        NTT(E, o, 1), NTT(EF, o, 1), NTT(EL, o, 1);
        rep(i, 0, o - 1) E[i] = mul(E[i], dec(1, dec(EL[i], EF[i])));
        NTT(E, o, -1);
        rep(i, k, o - 1) E[i] = 0;
    }
    rep(i, 0, pw - 1) g[i] = E[i];
}

int PF[N], PL[N];
il void PolyPow(int *f, int *g, int c, int pw) {
	rep(i, 0, pw - 1) PF[i] = f[i];
	int pos = -1;
	rep(i, 0, pw - 1) if (PF[i]) {pos = i; break;}
	if (pos == -1 || 1ll * pos * c >= pw) {
		rep(i, 0, pw - 1) g[i] = 0;
		return;
	}
	if (pos) rep(i, pos, pw - 1) PF[i - pos] = PF[i], PF[i] = 0;
	int tp = Inv(PF[0]);
	rep(i, 0, pw - 1) PF[i] = mul(PF[i], tp);
    PolyLn(PF, PL, pw);
    rep(i, 0, pw - 1) PL[i] = mul(PL[i], c);
    PolyExp(PL, g, pw);
	tp = qpow(Inv(tp), c);
	rep(i, 0, pw - 1) g[i] = mul(g[i], tp);
	if (pos) {
        tp = pos * c;
        drep(i, pw - 1, tp) g[i] = g[i - tp];
        rep(i, 0, tp - 1) g[i] = 0;
    }
}

int n, K, a[N], ans;
int D[N], Q[N], DZ[N], DM[N], QP[N];

il void getD(int pw) {
    D[0] = 0;
    for (re int o = 4, k = 2; k < (pw << 1); o <<= 1, k <<= 1) {
        PolyPow(D, DZ, K + 1, k), PolyPow(D, DM, K, k);
        rep(i, 0, k - 1) {
            DZ[i] = dec(0, mul(DZ[i], K));
            DM[i] = dec(0, mul(DM[i], K + 1));
        }
        DM[0] = inc(DM[0], 1), DM[1] = inc(DM[1], 1), DZ[1] = inc(DZ[1], 1);
		PolyInv(DM, DM, k);
        InitNTT(o);
        NTT(DZ, o, 1), NTT(DM, o, 1);
        rep(i, 0, o - 1) DZ[i] = mul(DZ[i], DM[i]);
        NTT(DZ, o, -1);
        rep(i, 0, k - 1) D[i] = DZ[i];
    }
}

int tot, len[N];
vector <int> f[N];

il void Solve(int m) {
    len[++tot] = m, f[tot].resize(m + 1);
    PolyPow(Q, QP, m + 1, m + 1);
    rep(i, 0, m) f[tot][i] = mul(mul(m - i + 1, inv[m + 1]), QP[i]);
}

int CL[N], CR[N];
il void Calc(int l, int r) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    Calc(l, mid), Calc(mid + 1, r);
    rep(i, 0, len[l]) CL[i] = f[l][i];
    rep(i, 0, len[mid + 1]) CR[i] = f[mid + 1][i];
    int lim = 1;
    while (lim <= len[l] + len[mid + 1]) lim <<= 1;
    InitNTT(lim);
    NTT(CL, lim, 1), NTT(CR, lim, 1);
    rep(i, 0, lim - 1) CL[i] = mul(CL[i], CR[i]);
    NTT(CL, lim, -1);
    len[l] += len[mid + 1], f[l].resize(len[l] + 1);
    rep(i, 0, len[l]) f[l][i] = CL[i];
    rep(i, 0, lim - 1) CL[i] = CR[i] = 0;
}

int main() {
    n = read(), K = read(), init(n + 2);
    rep(i, 1, n) a[i] = read();
    getD(n + 2);
    rep(i, 0, n) D[i] = D[i + 1]; D[n + 1] = 0;
    PolyInv(D, Q, n + 1);
    std::sort(a + 1, a + n + 1);
    int pos = 1;
    while (pos <= n) {
        int npos = pos;
        while (npos < n && a[npos + 1] == a[npos] + 1) ++npos;
        Solve(npos - pos + 1), pos = npos + 1;
    }
    Calc(1, tot);
    rep(i, 0, n - 1) ans = inc(ans, mul(f[1][i], mul(n, Inv(mul(C(n, i), n - i)))));
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：whiteqwq (赞：7)

[P6633 [ZJOI2020] 抽卡](https://www.luogu.com.cn/problem/P6633) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/15775366.html)

## 题意

给定一个大小为 $n$ 的可重集，每次随机抽取一个数字（可以反复抽一个数），求组成一个长度为 $k$ 的连续段的期望时间。

$1\leqslant n\leqslant 2\times 10^5$。

## 分析

考虑构建一个自动机模型，一共 $2^n$ 个结点表示当前取到过的数字集合，容易发现一个 $1$ 个数为 $k$ 的结点有 $k$ 个自环，以及 $n-k$ 条出边。

可以发现答案是从全 $0$ 状态走到任意结束态的期望路径长度，类似全概率公式，答案实际上是每个点被经过的概率乘期望停留时间之和。

由于图是分层的，可以算出走到 $k$ 层任意结点的概率都是 $\dfrac{1}{{n\choose k}}$，期望停留时间为 $\dfrac{n}{n-k}$，我们只需要对于每一个 $k$ 算出非终止状态的结点数量与其相乘即可。

发现值域不处于一个连续段的数字互不影响，将数字分割成若干连续段，最后使用分治 FFT 合并即可。

令 $f_{i,j}$ 表示当前连续段考虑到第 $i$ 个数字，选择了 $j$ 个数字的非终止态数量，列出 dp 方程：

$$f_{i,j}=\begin{cases}f_{i-1,j-1}+f_{i-1,j}-f_{i-k-1,j-k}&i\geqslant 0\\ [j=0] & i=-1\end{cases}$$

这里将状态定义到 $-1$ 的原因是便于 $f_{k,k}$ 的定义。

将 dp 刻画成生成函数的形式：

$$F_i(x)=\begin{cases}(1+x)F_{i-1}(x)-x^kF_{i-k-1}(x)&i\geqslant 0\\1&i=-1\end{cases}$$

根据 [P6811 「MCOI-02」Build Battle 建筑大师](https://www.luogu.com.cn/problem/P6811) 中的技巧，观察到每次减 $k+1$，枚举用了多少次，于是可以算出走了多少次 $-1$，得到了 $F_i(x)$ 的通项：

$$
G_m(x)=\sum_{i=0}^{\lfloor\frac{m}{k+1}\rfloor}{i+m-(k+1)i\choose i}(-x^k)^i(1+x)^{m-(k+1)i}\\=\sum_{i=0}^{\lfloor\frac{m}{k+1}\rfloor}{m-ik\choose i}(-1)^ix^{ik}(1+x)^{m-(k+1)i}\\
F_m(x)=G_i(x)-x^kG_{i-k}(x)
$$

减去后面的东西是因为 $F_{-1}(x)$ 直接跳一步 $x^k$ 是不合法的。

令 $L=\lfloor\frac{m}{k+1}\rfloor,r_i={m-ik\choose i}(-1)^i,P(x)=x^k,Q(x)=(1+x)^{k+1}$，那么：

$$G_m(x)=(1+x)^{m\bmod(k+1)}\sum_{i=0}^L P^i(x)Q^{L-i}(x)r_i$$

可以使用分治 FFT 分治计算后面那个求和式：

$$G'(x)=(\sum_{i=0}^{\lfloor\frac{L}{2}\rfloor}P^i(x)Q^{\lfloor\frac{L}{2}\rfloor-i}r_i)\times Q^{\lceil\frac{L}{2}\rceil}(x)\\+(\sum_{i=0}^{\lceil\frac{L}{2}\rceil} P^i(x)Q^{\lceil\frac{L}{2}\rceil}r_{\lfloor\frac{L}{2}\rfloor+i})\times P^{\lfloor\frac{L}{2}\rfloor}(x)$$

那么你只需要在分治 FFT 的时候维护一下 $H_{l,r}$ 以及 $Q^L(x)$ 即可。（与 $P$ 做乘法直接平移就好了）

时间复杂度 $O(n\log^2n)$。

## 代码

注意长度 $d$ 小于 $k$ 的连续段也需要作为 $(1+x)^d$ 乘到答案里。（调了好久）

[AC 代码](https://loj.ac/s/1339356)

---

## 作者：Time_tears (赞：6)

考虑期望转概率，我们设 $E$ 表示原问题的期望，$P_i$ 表示抽出 $i$ 张不同牌后仍然没有 $k$ 张连续卡的概率，则有： $E=\sum\limits_{i=1}^{m-1}P_i\dfrac{m}{m-i}$，解释一下就是在抽了 $i$ 张牌后仍然没有出的概率乘上从 $i \to i+1$ 所需要的的次数就是总的期望。

现在问题转为 $P_i$ 如何求，考虑一个有 $i$ 张不同牌的状态，他有 $\dfrac{1}{C_m^i}$ 的概率出现，我们现在的问题就转为了计数有 $i$ 张不同牌但没有连续 $k$ 张卡的方案数了。

最直接的想法就是设 $f_{i,j,l}$  表示前 $i$ 张牌中选了 $j$ 张，最后一个连续段的长度为 $l$ 且没有长度 $\geqslant k$ 的连续段的方案数，复杂度 $O(n^3)$，期望 50pts。

我们考虑对每一段先分开考虑，最后再卷积起来。

现在问题变成了一个长度为 $n$ 的连续段，对每个 $i$ 求出选出 $i$ 张牌且没有 $k$ 张连续牌的方案数，不难列出这个方案数为：$\sum\limits_{p=1}^{+\inf}[x^{i+1-p}](\sum\limits_{j=0}^{k-1}x^j)^p$，组合意义就是暴力枚举段数为 $p$，每一段里选长度为 $0$~$k-1$ 的值然后乘起来。

但是对于每个不同的 $p$ 我们取出不同的项的这个行为是很尴尬的，导致我们完全无法优化这个算法。

于是我们考虑给每个 $(\sum\limits_{j=0}^{k-1}x^j)^p$ 都乘上一个 $x^p$，这样我们需要的答案就变成了 $\sum\limits_{p=1}^{+\inf}[x^{i+1}](\sum\limits_{j=1}^{k}x^j)^p$，但是与此同时我们又产生了一个新的问题：这个和我们要求的东西不一样啊，我们求出来的 $x^{i+1}$ 项并不是我们所需要的原来的选出 $i$ 张牌且没有 $k$ 张连续牌的方案数了，而是他们某些值的和，而我们如果只有 $x$ 一个元的话是不足以区分的，所以我们设一个辅助元 $y$，考虑给每个 $(\sum\limits_{j=0}^{k-1}x^j)^p$ 都乘上一个 $(xy)^p$，这样的话原式就变成了 $[x^{n+1}]\dfrac{1}{1-yF(x)}$，其中 $F(x)=\sum\limits_{i=1}^{k}x^i$，其中 $y^i$ 就对应了选 $i$ 张牌的方案数，因为 $y$ 的意义就是。

直接上扩展拉格朗日反演可以得到：
$$[x^{n+1}]\dfrac{1}{1-yF(x)}=\dfrac{1}{n+1}[x^n]\dfrac{y}{(1-yx)^2}(\dfrac{x}{F^{-1}(x)})^{n+1}$$
$$F(x)=\sum\limits_{i=1}^{k}x^i=x \dfrac{1-x^k}{1-x}$$
所以 $F^{-1}(x)$ 满足 
$$\dfrac{F^{-1}(x)-F^{-1}(x)^{k+1}}{1-F^{-1}(x)}=x\Leftrightarrow (1+x)F^{-1}(x)-F^{-1}(x)^{k+1}-x=0$$
牛顿迭代即可，$O(n\log n)$，但应该是个超大常数的 $O(n\log n)$。

然后我们求出 $(\dfrac{x}{F^{-1}(x)})^{n+1}$ 之后，再与前面的 $\dfrac{y}{(1-yx)^2}$ 卷起来算每个 $[x^ny^i]$ 的答案即可，$O(n)$。

现在我们就求出了每一段的答案，再用一次分治 $FFT$ 就行了，复杂度 $O(n\log^2 n)$，总复杂度 $O(n\log^2 n)$，目测要卡亿点点常。



目测代码有点长，先咕了。

---

## 作者：qwaszx (赞：3)

今天考古的时候翻到了这道题，过来发一下题解~~为啥网上全是 EI 做法啊~~

先快进到生成函数

$$
[x^n]\frac{1}{1-t\frac{x-x^{K}}{1-x}}
$$

有一些不太一样的形式，不过这个看起来跑得快一点

由于这个形式比较特殊，我们考虑直接展开

$$
\begin{aligned}
&[x^n]\frac{1-x}{1-x-tx+tx^{K}}\\
=&[x^n]\frac{1-x}{1-x-tx}\frac{1}{1+\frac{tx^{K}}{1-x-tx}}\\
=&[x^n]\sum_{i\geq 0}(1-x)(-1)^i(tx^K)^i\frac{1}{(1-x-tx)^{i+1}}
\end{aligned}
$$

为了简化形式，我们先丢掉前面的 $(1-x)$，那么就变成

$$
\begin{aligned}
&\sum_{iK\leq n}(-t)^i[x^{n-iK}]\frac{1}{(1-x(1+t))^{i+1}}\\
=&\sum_{iK\leq n}(-t)^i(1+t)^{n-iK}\binom{n-iK+i}{i}
\end{aligned}
$$

这可以直接分治 NTT 计算. 由于形式简单，直接实现就能跑出和计算复合逆差不多的速度. 不过我的实现是先换成 $(1-t)^it^{n-iK}$，最后再复合 $1+t$，由于我也不知道的原因这样分治能快很多.

也可以 1log，但又回到牛顿迭代了(

---

## 作者：juju (赞：2)

不妨考察每种局面期望被经过的次数，那么可以反向得到期望的步数。

显然走到任意一个未停止的局面的取了 $x$ 张卡牌的概率为 $\dfrac{1}{\binom{m}{x}}$ ，然后它的贡献即期望停留的步数，显然为 $\dfrac{m}{m-x}$ 。

因此我们只需要计算对于取了 $x$ 张卡牌时，未停止的局面数量即可。

那么把卡牌分解成若干个区间，最后使用分治 FFT 合并即可。

现在的问题是：如何计算一个区间的答案？

设区间长度为 $L$ ，我们设 $dp_{i,j}$ 为 $[1,i]$ 选了 $j$ 张卡牌的答案，那么可以简单的列出 dp 转移方程：

$$
dp_{i,j}=dp_{i-1,j-1}+dp_{i-1,j}-dp_{i-k-1,j-k}
$$

$$dp_{-1,0}=1$$

到此我们已经完成了 $O(n^2)$ 的部分了。

使用生成函数写出来得到：

$$
F_i(x)=(1+x)F_{i-1}(x)-x^kF_{i-k-1}
$$

（特殊的，这里我们认为 $F_{-1}(x)=1$）

这个式子看似已经无法处理了，但是可以联想到一个经典的技巧：

考虑使用组合意义优化这个式子，枚举走了 $i$ 步 $k+1$ ，令 $\dfrac{L}{k+1}=S$， 然后得到：

$$
F_L(x)=\sum_{i=0}^{S}(-1)^ix^{ik}(1+x)^{L-i(k+1)}\binom{L-ik}{i}
$$
$$
-x^k\sum_{i=0}^{S}(-1)^ix^{ik}(1+x)^{L-k-i(k+1)}\binom{L-k-ik}{i}
$$


现在我们得到了一个 $S$ 很小时的做法。

上式其实可以也可以使用分治 FFT 优化，具体的，我们想计算：

$$
\sum_{i=0}^S F^i(x)G^{S-i}(x)a_i
$$

只需要分治下去，分别计算出：

$$
\sum_{i=0}^{\frac{S}{2}} F^i(x)G^{\frac{S}{2}-i}(x)a_i
$$
$$
\sum_{i=0}^{\frac{S}{2}} F^i(x)G^{\frac{S}{2}-i}(x)a_{i+\frac{S}{2}}
$$

然后上面乘 $G^{\frac{S}{2}}$ ，下面乘 $F^{\frac{S}{2}}$ 就能在 $O(n \log^2 n)$ 的时间得到答案了。

总时间复杂度 $O(n \log^2 n)$ 可以通过这题，~~时小清新的推式式呢。~~



---

## 作者：forest114514 (赞：0)

拥抱 PGF 和 BM，放弃大脑。

首先经典期望的一个拆：$E(X)=1+\sum\limits_{i\geq 0}P(X>i)$，现在变成计算没有结束的状态的概率和。

我们不妨设有 $f_{i}$ 种情况抽到了恰好 $i$ 种卡还没有结束的方案数，我们枚举每种选了几个，其之间合并系数是个多重集组合数，所以用 EGF 合并，则我们可以列出此时的 PGF 为：
$$
\widehat F(z)=\sum\limits_{i=0}^{m-1} f_{i} (e^{\frac{z}{m}}-1)^i
$$
我们假设知道 $\widehat F(z)$ 的 OGF 形式 $F(z)$，显然答案就是 $1+F(1)$，于是考虑转化，先经典地求出每个 $e^{tz}$ 的系数即可。

我们设 $u=e^{\frac{z}{m}}$，则我们要求 $G(u)=\sum\limits_{i=0}^{m-1}f_i(u-1)^{i}$ 每个 $u^i$ 的系数，拆开后其实是 $[u^i]G(z)=\frac{1}{i!}\sum\limits_{j\geq i} j!f_{j}\times \frac{(-1)^{j-i}}{(j-i)!}$，发现是个减法卷积的形式，直接卷一下即可。

然后我们可以得到 $\widehat F(z)$ 可以写成 $\sum\limits_{i=0}^{m-1} g_{i}(e^{\frac{z}{m}})^i$ 的形式，而我们注意到 $e^{\frac{i}{mz}}$ 刻画的数列 $(\frac{i}{m})^{x}$ 转成 OGF 后就是 $\frac{m}{m-iz}$，带入 $z=1$ 就是 $\frac{m}{m-i}$。

于是现在整个问题回到了求 $f_i$ 上面，首先注意到我们假设对每个连续段求出了其 GF，然后用分治+NTT 卷起来就行了，于是现在问题变成了对每一段求出选了 $0\sim len$ 个数没有连续选的 $k$ 个数的答案。

我们首先对这个结构可以分解为一段选了 $0\sim k-1$ 个的连续段+若干段有一个没选再拼上选了 $0\sim k-1$ 的连续段，直接上二元 GF，$x$ 表示长度，$y$ 表示选了的数的个数，则发现我们的 GF 为：
$$
H(x,y)=\frac{1-(xy)^{k}}{1-xy}\times \frac{1}{1-x\frac{1-(xy)^{k}}{1-xy}}=\frac{1-x^ky^k}{1-xy-x+x^{k+1}y^k}
$$
然后我们要求 $U(y)=[x^{len}]H(x,y)$，直接抛弃大脑，选择对 $x$ 一维做 Bostan-Mori 即可。
$$
\begin{aligned}
\ 	[x^{n}]\frac{A(x,y)}{B(x,y)}&=[x^{n}]\frac{A(x,y)B(-x,y)}{B(x,y)B(-x,y)}\\
&=[x^{n}]\frac{C(x^2,y)+xD(x^2,y)}{B(x^2,y)}\\
&=\begin{cases}
[x^\frac{n}{2}] \frac{C(x,y)}{B(x,y)}&2\mid n\\
[x^\frac{n-1}{2}] \frac{D(x,y)}{B(x,y)}&2\nmid n
\end{cases}

\end{aligned}
$$
注意到截断后每次 $x$ 的次数减半而 $y$ 的次数翻倍，每一次卷积的长度还是 $O(n)$，所以时间复杂度是 $O(n\log^2 n)$，总的复杂度为 $O(m\log^2 m)$，略有常数。

于是我们在几乎没有推啥大困难式子的情况下用套路的方法解决了这道 ZJOI，时间复杂度 $O(m\log^2 m)$。

---

## 作者：Petit_Souris (赞：0)

今天是列表里一位多项式领域大神的生日，正好做到了一道可以用拉反的题 [庆祝]。

首先编一个多项式复杂度的做法。根据期望的线性性，答案可以被表示为所有状态的 出现概率 乘上 离开这个状态的期望次数之和。

这个值显然只跟已经抽到的卡片数量 $c$ 有关。出现概率为 $\frac{1}{\binom{m}{c}}$，离开状态的期望次数为 $\frac{m}{m-c}$。那么问题转化为，对于每个 $c$，计算没有连续段长度 $\ge k$ 的方案数。

每个连续段显然是独立的，分开考虑。

考虑生成函数，枚举没选到的卡片数量 $i$，那么分成了 $i+1$ 段，每段 $0\sim k-1$ 个选到的卡片，即 $[x^{m-i+1}](\sum\limits_{j=0}^{k-1}x^j)^i$。现在每个 $i$ 要求的次数不同，可以给每个括号里乘上一个 $x$ 统一，即 $[x^{m+1}](\sum\limits_{j=1}^{k}x^j)^i$。下面记 $F(x)=\sum\limits_{j=1}^{k}x_j=\frac{x(1-x^k)}{1-x}$。



求一个 $i$ 的结果是容易的，但是求出所有的 $i$ 有点麻烦。有一种方法是再加入一个未知元 $y$ 记录次数，即求 $F(x)^0y^0+F(x)^1y^1+F(x)^2y^2+\dots $ 的各个 $[y^ix^{m+1}]$ 系数。前面这个式子显然是 $\frac{1}{1-yF(x)}$。

将 $\frac{1}{1-yF(x)}$ 视为 $H(x)=\frac{1}{1-yx}$ 与 $F(x)$ 的复合。对 $x$ 施 Lagrange 反演：

$$
[x^{m+1}]H(F)=\frac{1}{m+1}[x^m]H'(\frac{x}{G})^{m+1}
$$

（求导是对于 $x$ 的偏导，为节省篇幅直接写一元求导的符号。）

其中 $G$ 为 $F$ 的复合逆。

显然，$H'(x)=\frac{y}{(1-yx)^2}$。$G$ 的求法可以利用 $F\circ G=x\iff G\circ F$ 这条性质，所以就是求 $\frac{G(1-G^K)}{1-G}=x$ 的解，即 $G^{k+1}-(1+x)G+x=0$，牛顿迭代即可。（每层里面要求一个多项式的幂，ln exp 做了之后复杂度显然还是 $\mathcal O(m\log m)$）

$H'(x)$ 的形式还不错，展开之后是 $\sum\limits_{i=0}^{+\infty}(i+1)y^{i+1}x^i$，所以求出 $G$ 后容易线性求出所有系数。

最后就是把所有连续段合并起来，就是把这些段的 GF 乘起来，直接分治 + NTT 即可。

总复杂度 $\mathcal O(m\log^2 m)$，不过显然牛顿迭代那部分才是运行时间瓶颈。

---


# [ZJOI2020] 密码

## 题目描述

Bob 喜欢 Alice。

Alice 和 Bob 想要进行加密通信，于是他们自己设计了一套加密算法进行身份验证。你知道这个加密算法并不可靠，并截获了 Alice 和 Bob 之间的信息。现在你想要恢复出 Alice 的密钥。

Alice 和 Bob 约定了一个大质数 $p$，一个随机范围值 $err$ 和一个在 $0 \sim p - 1$ 之间均匀随机生成的整数密钥 $x$。其中 $p$ 和 $err$ 的值是公开的，而 $x$ 的值只有 Alice 和 Bob 知道。

当 Bob 想要确认 Alice 的身份时，Bob 会生成 $m$ 个在 $0\sim p-1$ 之间均匀随机生成的 $a_i$ 并发给 Alice。对于每个 $a_i$，Alice 会返回给Bob $a_i x$ 模 $p$ 的值。为了防止窃听，Alice 会给结果加上一个在 $-\lceil \frac {err}2 \rceil$ 到 $\lceil \frac {err}2 \rceil$ 之间均匀随机生成的扰动。

即，Alice 会返回给 Bob $m$ 组形如 $a_i x + b_i \equiv c_i \pmod p$ 的等式，其中 $b_i$ 为一个不公开的在 $-\lceil \frac {err}2 \rceil$ 到 
$\lceil \frac {err}2 \rceil$ 之间均匀随机生成的数，$a_i$ 为随机生成的数，$a_i,p,err,c_i$ 为公开的数。

你获得了 Alice 返回的这 $m$ 组等式（即 $m$ 个 $a_i$ 和 $c_i$），你需要求出 $x$ 的值。

## 说明/提示

对于前 $10\%$ 的数据，满足 $err \le 10^6$。   
对于前 $20\%$ 的数据，满足 $err \le 10^8$。   
对于前 $30\%$ 的数据，满足 $err \le 10^{11}$。   
对于前 $40\%$ 的数据，满足 $err \le 10^{12}$。  
对于另外 $20\%$ 的数据，满足 $p \le 10^{16}$，$m = 2000$。   
对于 $100\%$ 的数据，满足 $10^{15} \le p \le 10^{18}$，$50 \le m \le 2000$，$1 \le err \le 0.01p$，$1 \le T \le 5$，$0 \le a_i,c_i \le p-1$，保证 $p$ 为素数。

## 样例 #1

### 输入

```
见下发文件。该样例满足题目中提到的所有随机生成的性质。
```

### 输出

```
```

# 题解

## 作者：whiteqwq (赞：5)

[P6634 [ZJOI2020] 密码](https://www.luogu.com.cn/problem/P6634) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/15784197.html)

## 题意

有 $m$ 个方程：

$$a_ix+b_i\equiv c_i\pmod{mod}$$

其中 $b_i$ 是 $[-\lceil \frac{err}{2}\rceil,\lceil \frac{err}{2}\rceil]$ 内的随机扰动。

给定 $a_i,c_i,mod,err$ 求 $x$。

$10^{15}\leqslant p\leqslant 10^{18},1\leqslant err\leqslant\frac{p}{100},50\leqslant m\leqslant 2000$。

## 分析

若 $err\leqslant 10^6$，可以把方程求和，枚举其扰动，计算出 $x$，check 一下就好了。（没写过，不知道对不对）

不太清楚正解，这里写一下 [skip2004](https://www.cnblogs.com/skip1978/p/13180687.html) 的一种做法。

我们维护当前 $x$ 的范围，不断使用方程缩小其范围，当范围很小时就可以暴力枚举 $x$ 进行 check 了。

我们考虑通过原来的方程加减构造若干个近似程度比较高的方程，然后解出 $x$ 的一个更小范围：

$$ax\pm b\times err\equiv c\pmod{mod}$$

我们不断重复以下流程：

- 随机选择若干个方程（奇数个），并给每个方程随机一个权值 $1/-1$ 然后相加；（期望下 $a,b$ 很小）
- 解出 $x$ 的范围；（需要处理的细节比较多，具体见代码）
- 将新生成的方程按照 $a$ 排序，将相邻的方程相减，生成新的方程。

大概随机几轮就行了。

至于正确性，hzr 说随机加加减减生成的答案可以看做随机，然后可以用 $n$ 个 $[0,V]$ 内随机实数第 $k$ 大期望为 $\frac{Vk}{n+1}$ 的结论缩小范围。

具体还是看 $ 鸽鸽的博客吧，感觉以我的能力讲不清楚。

## 代码

有几个坑点。

rand 要用 mt19937，用自带和手写（这个不确定）的好像都会挂。

每次要给方程扰动一下，否则好像会被卡。

还有一些见代码。

```
struct node{
	long long a,c,cnt;
	inline bool operator ==(node &p)const{
		return a==p.a;
	}
	inline bool operator <(node &p)const{
		return a<p.a;
	}
};
int check(long long X){
	X=(X%mod+mod)%mod;
	int flg=1;
	for(int i=1;i<=n;i++){
		long long val=dec(mul(a[i],X)-c[i]);
		flg&=(val<=err||val>=mod-err);
	}
	return flg;
}
void addnode(long long a,long long c,long long cnt){
	V.push_back(node{a,c,cnt});
	if(err>mod/cnt/2||(nowR-nowL+1)>mod/a)
		return ;
	long long L=mul(nowL,a),R=mul(nowR,a),tmpL=c-cnt*err,tmpR=c+cnt*err;
	while(L>R)
		R+=mod;
	while(tmpL>R)
		tmpL-=mod,tmpR-=mod;
	while(tmpR<L)
		tmpL+=mod,tmpR+=mod;
	if(tmpL+mod>R&&tmpR-mod<L)
		nowL+=max(tmpL-L,0ll)/a,nowR-=max(R-tmpR,0ll)/a;
}
int main(){
	srand(time(0));
	scanf("%d",&T); 
	while(T--){
		scanf("%d%lld%lld",&n,&mod,&err),err=(err+1)/2,nowL=0,nowR=mod-1;
		for(int i=1;i<=n;i++)
			scanf("%lld%lld",&a[i],&c[i]);
		while(nowR-nowL+1>S1){
			V.clear();
			long long delta=rnd()%mod;
			nowL+=delta,nowR+=delta;
			if(nowR-nowL+1>mod/4)
				nowL=0,nowR=mod-1;
			for(int i=1;i<=S2;i++){
				long long nowA=0,nowC=0;
				for(int j=1;j<=S3;j++){
					int x=rnd()%n+1;
					while(1){
						int flg=0;
						for(int k=1;k<j;k++)
							if(p[k]==x)
								flg=1;
						if(flg==0)
							break;
						x=rnd()%n+1;
					}
					p[j]=x;
					long long aa=a[x],cc=inc(c[x]+mul(a[x],delta));
					if(rnd()&1)
						nowA=inc(nowA+aa),nowC=inc(nowC+cc);
					else nowA=dec(nowA-aa),nowC=dec(nowC-cc);
				}
				addnode(nowA,nowC,(long long)S3);
			}
			for(int i=1;i<=S4;i++){
				if(V.size()>S5)
					nth_element(V.begin(),V.begin()+S5,V.end()),V.resize(S5);
				sort(V.begin(),V.end()),V.erase(unique(V.begin(),V.end()),V.end());
				int rec=V.size();
				for(int j=0;j<rec;j++)
					for(int k=j+1;k<=j+S6&&k<rec;k++)
						addnode(V[k].a-V[j].a,dec(V[k].c-V[j].c),V[j].cnt+V[k].cnt);
			}
			nowL-=delta,nowR-=delta;
		}
		ans=0;
		for(long long i=nowL;i<=nowR;i++)
			if(check(i)){
				ans=i;
				break;
			}
		printf("%lld\n",(ans%mod+mod)%mod);
	}
	return 0;	
}
```

---

## 作者：SAMSHAWCRAFT (赞：1)

Update: 补充了一些关于随机数生成以及本题是否有确定性算法可能性的说明。

------------


为了记号简便，我们记输入的 $\mathtt{err}$ 为 $z$。

用形式化的语言表示这个题目的意思的话，就是给定一个关于 $x$ 的方程组 $a_ix+b_i\equiv c_i(\operatorname{mod} p)$，方程组中总共有 $m$ 个方程，其中

$$
p\in\{x\in\mathbb{N}_+| \forall a\in(1,x)\cap\mathbb{N}_+,\frac{x}{a}\notin\mathbb{N}_+\}
$$
$$
\forall a_i,c_i\in[1,p]\cap\mathbb{N}_+
$$
$$
\forall b_i\in[-\left\lceil {\frac{z}{2}} \right\rceil,\left\lceil {\frac{z}{2}} \right\rceil]\cap \mathbb{N}_+(z\in[1,\frac {p}{100}]\cap \mathbb{N}_+ )
$$

并且 $a_i$ 和 $b_i$ 在各自的取值范围内随机生成。要求解 $x$ 的值，保证有解且解唯一。

我最初的想法是消去 $b_i$，既然 $b_i$ 随机生成，那么随机取一些方程加减，只要取的次数够多，很可能就会有 $b_i$ 抵消部分影响的情况。最理想的情况是取到一组方程把所有 $b_i$ 的影响都消去了，也就是 $\sum b_i$ 在对 $p$ 取模之后变成了 0 的情况，这样直接就可以解出来 $x$ 了。

但是我们并不知道 $b_i$ 具体是什么，会不会加减变成 0，所以只能大致估计 $x$ 的取值范围，我们不妨用双指针来维护一个取值范围的区间，最终估计出一个长度合适的区间，然后在这个估计得到的区间中间暴力地尝试一些 $x$ 的值，一旦找到一个解就可以结束。问题变成了两个部分：

1. 随机取一些方程，维护 $x$ 的取值范围。
  
2. 暴力在取值范围内代入 $x$ 的值直到找出一个解。
  

首先是第一部分，如何维护 $x$ 的取值范围？我们随机取出一些方程，然后把它们随机加减（这样有可能减小 $b_i$ 的影响），得到一个新的方程。用这样的办法生成一个新方程组，解出一个 $x$ 的取值范围，之后再更新 $x$ 的取值范围。问题是我们如何尽可能地缩小这个范围，这里我们不妨求个期望，也就是最早的这篇题解提到的那个 $n$ 个在 $[0,V]$ 随机的实数第 $k$ 大的期望值（这个第 $k$ 大有一些歧义，那篇题解的定义可能是**从小到大**把数字排序之后第 $k$ 位上的数字，但是我们在这里规定是**从大到小**把数字排序之后第 $k$ 位上的数字，第 1 大的数是最大的数，第 2 大的数是次大的数，以此类推）。

不妨引入第 $n+1$ 个随机实数，由于这个是随机分布，取值范围是 $[0,V]$，所以可以认为第 $k$ 大的变量的期望等于第 $n+1$ 个变量小于等于第 $n-k$ 小的变量的概率。那么问题就变为了如何求概率，统计一下方案数。它们的大小关系一共有 $(n+1)!$ 种，而 $n+1$个变量小于等于第 $n-k$ 小变量的方案数一共有 $(n-k)n!$，即第 $n+1$ 个变量一共有 $n-k$ 个位置可以插入。所以概率为 $\frac{(n-k)n!}{(n+1)!}=\frac{n-k}{n+1}$，期望值就是 $\frac {V(n-k)}{n+1}$。结论与那篇题解相同。

有了这个结论我们怎么做呢？我们生成一个新的方程组之后，可以用 `std::nth_element` 取一个 $a_i$ 第 $k$ 小，然后用 $a_i$ 相近的方程相减，得到 $a_i$ 更小的新方程，解出一个 $x$ 的取值范围，这个范围可以通过给方程扰动来得到。这个解方程的代码实现可以参考我的 `distribute` 函数，扰动通过 `mulLessThan` 来实现，代码中的 `err` 是输入的 $\mathtt{err}$ 的一半：

```cpp
bool mulLessThan(ll x,ll y,ll z){
  return static_cast<long double>(x)*y<=z*1.01&&x*y<=z;
}
void distribute(ll a,ll c,ll cnt,ll &ln,ll &rn){
  if(!mulLessThan(cnt,err<<1,(a==1)?p:(p>>1))) return;
  if(!mulLessThan(rn-ln+1,a,p)) return;
  ll gln=mul(ln,a),grn=mul(rn,a);
  while(grn<gln) grn+=p;
  ll rg=cnt*err,rln=c-rg,rrn=c+rg;
  while(rln>grn) rln-=p,rrn-=p;
  while(rrn<gln) rln+=p,rrn+=p;
  if(gln<=rrn-p||rln+p<=grn) return;
  if(rln>gln) ln+=(rln-gln)/a;
  if(rrn<grn) rn-=(grn-rrn)/a;
}
```

这一步的复杂度我不会证明，因此缩小到多长的区间更为合适、选多少个方程来组合方程组更好、选第几小的方程取值最接近我都不会，只能玄学调参，希望之后有会证明的大佬请分享一下吧。

之后是第二部分，暴力找解，由于我们找的区间的中点在直觉上可能会更加接近，因此从区间中点两侧暴力代入数值应该可行。那么怎样确定一个值是不是解呢？我们把这个 $x$ 代入题目中给的每一个方程，这样的话求出所有的 $b_i$，看看 $b_i$ 是否满足 $\forall b_i\in[-\left\lceil {\frac{z}{2}} \right\rceil,\left\lceil {\frac{z}{2}} \right\rceil]\cap \mathbb{N}_+$ 即可。这里需要注意 `check` 函数的细节，一开始我没弄好这个，导致所有数据点都 TLE。

这部分的实际效率取决于参数调得怎么样，以及取值范围估计得准不准。

我这里给一些代码细节的提示：

1. 本题给了 `long long` 直接乘会爆的数据范围，因此要写龟速乘。
  
2. 本题的随机数生成建议用 `std::mt19937_64` 和 `std::uniform_int_distribution<long long>` 搭配，这样生成的数字比取模更为均匀，并且生成的随机数数据范围也够用，不会用 `<random>` 中函数的同学可以简单学一下。
  

有关于随机数生成器的知识可以查看两期洛谷日报，一期是[囧仙 - 浅谈随机分布及C++当中的实现](https://www.luogu.com.cn/blog/over-knee-socks/post-talk-about-random-distribution)，另一期是[Mivik - 随机的艺术](https://mivik.blog.luogu.org/the-art-of-randomness)。在前一篇日报中提到 `<random>` 库随机数生成器相较于取模的优点：

> 很多人会用一个这样的方式来实现 `rand(l,r)`：
> 
> ```cpp
> int rand(int a, int b){
>     return G() % (b - a + 1) + l;
> }
> ```
> 
> 嗯，这个 `rand` 函数看上去蛮对的。它把 $\mathtt{G}$ 生成的随机数映射到了 $[0,b−a)$ 里面，然后把它加上 $a$，最终得到了值在 $[a,b]$ 内的随机数。但是只要仔细想一想，就会发现它里面存在的漏洞。首先是原理上的错误：$\mathtt{G}$ 映射到 $[0,b−a)$ 是不均匀的。比如说，当 $a=0,b=60000$ 时，有两个数字映射到了 $2333$（$2333$ 和 $62333$），但是仅有一个数字映射到了 $50000$。这样就会导致最终生成 $2333$ 的概率是生成 $50000$ 的两倍。其次还有实现上的漏洞：$b-a$ 有可能超过 `int` 类型的最大值，发生不可预期的错误。

在后一篇日报的开头也有类似的内容说明了 `rand()` 的分布效果不如 `std::mt19937`，这里不再引用。在这一题中，`rand()` 的劣势会更加突出，但是实测随机数生成质量的提高只能提高较少的的代码效率。

细节较多，代码如下，仅供参考：

```cpp
#include <iostream>
#include <algorithm>
#include <functional>
#include <random>
#include <string>
#define qaq inline
using ll=long long;
const int sz=1e5+19;
int T;
ll m,p,err;
std::mt19937_64 engine(19990919);
struct info{
  ll a,c,cnt;
  bool operator==(const info &x)const{ return a==x.a; }
  bool operator<(const info &x)const{ return a<x.a; }
}pswz[sz],mvpswz[sz];
qaq ll mdl(ll x){
  ll res=x+(x>>63&p);
  return (res<p)?res:(res-p);
}
qaq ll mul(ll a,ll b){
    a%=p,b%=p;
    ll d=(static_cast<long double>(a)/p*b+0.25);
    ll res=a*b-d*p;
    return (res<0)?(res+p):res;
}
bool check(ll x){
  for(int cx=0;cx<m;++cx){
    ll cur=mdl(mul(pswz[cx].a,x)-pswz[cx].c);
    if(cur>err&&cur<p-err) return false;
  }
  return true;
}
bool mulLessThan(ll x,ll y,ll z){
  return static_cast<long double>(x)*y<=z*1.01&&x*y<=z;
}
void distribute(ll a,ll c,ll cnt,ll &ln,ll &rn){
  if(!mulLessThan(cnt,err<<1,(a==1)?p:(p>>1))) return;
  if(!mulLessThan(rn-ln+1,a,p)) return;
  ll gln=mul(ln,a),grn=mul(rn,a);
  while(grn<gln) grn+=p;
  ll rg=cnt*err,rln=c-rg,rrn=c+rg;
  while(rln>grn) rln-=p,rrn-=p;
  while(rrn<gln) rln+=p,rrn+=p;
  if(gln<=rrn-p||rln+p<=grn) return;
  if(rln>gln) ln+=(rln-gln)/a;
  if(rrn<grn) rn-=(grn-rrn)/a;
}
std::basic_string<info> arr;
void guessX(ll &ln,ll &rn){
  static std::function<void(ll,ll,ll)> insert;
  insert=[&ln,&rn](ll a,ll c,ll cnt)->void{
    arr.push_back(info{a,c,cnt});
    distribute(a,c,cnt,ln,rn);
  };
  std::uniform_int_distribution<ll> uni4mp(0,p-1);
  std::uniform_int_distribution<ll> uni4mm(0,m-1);
  arr.clear();
  ll ofst=uni4mp(engine);
  if((rn-ln)<(p>>2)) ln+=ofst,rn+=ofst;
  else ln=0,rn=p-1;
  for(int cx=0;cx<m;++cx){
    mvpswz[cx]=pswz[cx];
    mvpswz[cx].c=mdl(pswz[cx].c+mul(pswz[cx].a,ofst));
  }
  for(int cx=0;cx<20000;++cx){
    ll att=0,ctt=0;
    for(int cy=0,hist[3],id;cy<3;++cy){
      std::function<bool(int)> idcheck;
      idcheck=[&hist](int cy)->bool{
        for(int t=0;t<cy;++t){
          if(hist[t]==hist[cy]) return true;
        }
        return false;
      };
      do{
        id=uni4mm(engine);
        hist[cy]=id;
      }while(idcheck(cy));
      if(engine()&1){
        att=mdl(att+mvpswz[id].a);
        ctt=mdl(ctt+mvpswz[id].c);
      }else{
        att=mdl(att-mvpswz[id].a);
        ctt=mdl(ctt-mvpswz[id].c);
      }
    }
    insert(att,ctt,3);
  }
  for(int t=0;t<5;++t){
    if(arr.size()>3000){
      std::nth_element(arr.begin(),arr.begin()+3000,arr.end());
      arr.resize(3000);
    }
    std::sort(arr.begin(),arr.end());
    arr.erase(std::unique(arr.begin(),arr.end()),arr.end());
    for(int z=arr.size(),cx=0;cx<z;++cx){
      for(int cy=cx+1;cy<cx+5&&cy<z;++cy){
        insert(arr[cy].a-arr[cx].a,mdl(arr[cy].c-arr[cx].c),arr[cx].cnt+arr[cy].cnt);
      }
    }
  }
  ln-=ofst,rn-=ofst;
}
int main(){
  std::cin.tie(nullptr)->sync_with_stdio(false);
  std::cin>>T;
  while(T--){
    std::cin>>m>>p>>err;
    err=(err+1)>>1;
    ll ln=0,rn=p-1,mid;
    for(int cx=0;cx<m;++cx)
      std::cin>>pswz[cx].a>>pswz[cx].c;
    for(int cx=0;cx<m;++cx)
      pswz[cx].cnt=1;
    while(rn-ln>6666)
      guessX(ln,rn);
    mid=(ln+rn)>>1;
    for(ll cx=mid,cy=mid+1;true;--cx,++cy){
      if(check(cx)){
        std::cout<<(cx+p)%p<<std::endl;
        break;
      }
      if(check(cy)){
        std::cout<<(cy+p)%p<<std::endl;
        break;
      }
    }
  }
  return 0;
}
```

由于我本人比较菜，代码实现能力比较低，所以后期调参参考了最早的一篇题解（但是最后调出来的参数较最早的题解好一点），最终我上面放的这份代码不开 `-O2` 有 90 pts，开 `-O2` 才能 AC。祝愿以后用随机化做法的同学们能够把参数调得更好！

另附：有人问我这题能不能不用随机化的方法做，我个人认为这种涉及到密码加密解密的题目不会有考场上能实现得了的确定性算法去解。现有的加密算法如大名鼎鼎的 MD5 现有的解密方式主要采取暴力破解， 软件通过算法生成字典，然后使用 MD5 函数加密该字典中的值形成密文，接着跟需要破解的密文进行比较，如果相同则认为破解成功，有很多网站提供所谓的 MD5 加密或者加密值查询，将加密后的 MD5 值，输入到网站中，如果网站数据库中存在该 MD5 ，则该值对应的 MD5 加密前的值就为密码（但是 2004 年 MD5 也被证实无法避免碰撞，意味着暴力破解出的所谓原文未必是原文）。这个例子表明了不是所有的密码都有随机化算法去解的，对于我们做这道题来说更是如此，我们不可能生成字典去做这道题，随机化算法难免成为常见解法。当然，我欢迎各位大神前来打脸，毕竟这题的加密算法比 MD5 的简单易懂的多。

---


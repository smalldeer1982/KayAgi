# [SNOI2020] 取石子

## 题目描述

甲乙两个人玩取石子游戏。他们面前有一堆共 $n$ 个石子，然后由甲先手，两人轮流从中取走石子：甲第一次取走的个数不能超过 $k$，接下来每个人取走的个数不能超过上一个人刚刚取走个数的 $2$ 倍。每人每次必须至少取一个石子。取走最后一个石子的人失败，另一方获胜。现在已知 $k$，请你求出在 $1$ 到 $N$ 中有多少整数 $n$ 使得甲在 $n$ 颗石子的游戏中有必胜策略。

## 说明/提示

#### 样例说明

对于样例 $1$，当 $k=1$ 时：

- 如果 $n=1$，甲只能取走唯一一颗石子从而失败。
- 如果 $n=2$，甲取走一颗石子，乙只能取走最后一颗石子，甲获胜。
- 如果 $n=3$，甲只能取走一颗石子，乙再取走一颗石子，甲只能取走最后一颗石子从而失败。
- 如果 $n=4$，甲只能取走一颗石子，乙再取走两颗石子，甲只能取走最后一颗石子从而失败。
- 如果 $n=5$，甲只能取走一颗石子，乙只能取走一颗或两颗石子，甲总能再留给乙留下最后一颗石子从而获胜。

#### 数据说明与提示

对于所有数据，$1 \le T \le 10^5,k,N \le 10^{18}$。

- 对于 $10\%$ 的数据，$T,N \le 500$。
- 对于另外 $20\%$ 的数据，$T,N \le 10^5$。
- 对于另外 $20\%$ 的数据，$T \le 3,N \le 3 \times 10^6$。
- 对于另外 $20\%$ 的数据，$k=1$。
- 对于余下 $30\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
3
1 5
2 5
1 10```

### 输出

```
2
3
4```

# 题解

## 作者：Saliеri (赞：26)

~~为什么全是打表找规律啊，这不是经典模型吗/yiw~~

给一个更自然的数位 DP 做法，同时附上 Fibonacci Nim 的性质证明。

___

先不考虑第一手不能取超过 $k$ 个的限制，日后再说。

然后通过 $n:=n-1$ 去掉该死的 Anti 游戏。

- 因为本题的性质，如果在非 Anti 游戏中可以必胜的话，必然也可以故意空一个来让自己在 Anti 游戏中必胜。

___

于是问题变成了经典 Fibonacci Nim，存在结论：
**Fibonacci Nim 先手必败当且仅当石子个数是 Fibonacci 数**。

- 补充：经典 Fibonacci Nim 中先手不能一次取完。

以下我们给出证明。（认为 $fib_1 = 1,fib_2 = 2$）。

引理一：$fib_{i+1} < 2fib_i < fib_{i+2}$。

引理二：$\frac{4}{3}fib_{i} < fib_{i+1}$。

- 证明：拆项即可，很容易；或者说你归纳法也没人管。

引理三：（**齐肯多夫定理**）任意正整数可以被拆分为若干个**不连续的 Fibonacci 数之和**。

- 证明：简单数学归纳法。（是真的很简单，把前十几个的拆分画出来就能看到怎么归纳了）

定理一：当石子个数是 Fibonacci 数时先手必败。

- 证明：数学归纳法。

	- 奠基是容易的。
    
    - 关于归纳：我们考虑将规模为 $fib_n$ 的游戏**拆分为两个规模为 $fib_{n-1},fib_{n-2}$ 的子游戏**。
    	
        - Q1：怎么拆成子游戏？这不是一堆吗？A1：我们认为二玩家在这一堆中所取出的前 $fib_{n-2}$ 颗石子是第一个子游戏，后者亦然。
        
        - Q2：那万一跨越子游戏怎么办？不就不合法了？A2：不会的，看证明。
        
    	- 首先，先手不能第一次取 $\ge fib_{n-2}$ 颗石子，否则根据引理一，后手直接取完。
        
        	- 所以先手第一手不会离开第一个子游戏。
            
       	- 根据归纳假设，后手一定可以赢得第一个子游戏，同时控制自己不去动第二个子游戏。
        
        - 先手现在又面临一个必败态，同时还有后手上一次操作给的数量限制，因此唯一的获胜希望就是一次将 $fib_{n-1}$ 取完。
        
        - 然而这是不可能的，因为后手在第一个子游戏中最后一手必然不超过 $\frac{2}{3}fib_{n-2}$，根据引理二，先手这一次取不完。归纳完成。
        
定理二：当石子个数不是 Fibonacci 数的时候先手必胜。

- 证明：我们可以给出一个必胜策略。

- 根据引理三，假设当前石子个数为 $n = \sum_{i}fib_{p_i},p_{i-1}+1<p_i$。

- 先手**第一次取 $fib_{p_1}$ 颗**，由引理一，后手不能一次取完 $fib_{p_2}$，于是在 $fib_{p_2}$ 这个子游戏中也是先手胜。

- 以此类推，最终整个游戏一定也是先手胜。

___

现在预备知识应当是足够了。我们先加上第一次取 $\le k$ 的个数限制：

- 发现这其实是好讨论的：即非 Fibonacci 数时，如果 $fib_{p_1} > k$ 先手也必败。

- 原因：因为这样就取不完第一堆，从而留给后手一个必胜的局面；否则先手的必胜策略不受影响。

	- Q：如果先手第一次取很小的数量来臭后手呢？A：自证不难/xyx
    
问题现在被转化成了这个样子：设 $\text{lowbit(n)}$ 为 $n$ 的齐肯多夫表示法下最小的 Fibonacci 项，则：

$$\text{ans} = \sum_{i=1}^n[k\ge\text{lowbit(i)}]$$

- 容斥变成 $\text{lowbit} > k$ 的数量。

考虑 **数位 DP**。

然后发现这个玩意好做的不得了啊，直接记搜数位 DP 写就完了，一点难度都没有。

- 还是详细说一下：考虑低 $i$ 位可以构成多少个数，后效性有是否顶满 $n$ 与高一位上是否是 $1$（因为齐肯多夫表示法要求不连续），记下来就可以了。

- 同时要求 < k 的 Fib 位上不能有 $1$，那就在不满足条件时直接 `return 1` 就完了（因为底下只能填全 $0$）。

复杂度 $O(T\log n)$。

___

Code:

```cpp
#include <cstdio>
#include <cstring>
typedef long long ll;
int T;bool v[105];
ll n,k,f[105],dp[105];
ll DP(int p,bool bound,bool lst){
	if(p < k)return 1;
	if(!lst&&!bound&&~dp[p])return dp[p];
	ll r = 0;
	r += DP(p-1,bound&(v[p]==0),0);
	if(!lst && (!bound || v[p] == 1))
		r += DP(p-1,bound,1);
	if(!lst&&!bound)dp[p] = r;
	return r;
}
int main(){
	scanf("%d",&T);
	f[1] = 1,f[2] = 2;
	for(int i=3;i<=90;++i)f[i] = f[i-1] + f[i-2];
	while(T--){
		scanf("%lld %lld",&k,&n),--n;
		ll tn = n;memset(v,0,sizeof(v));
		ll tk = k;for(int i=90;i;--i)if(f[i]>tk)k=i;
		for(int i=90;i;--i)if(tn>=f[i])tn-=f[i],v[i]=1;
		memset(dp,-1,sizeof(dp)),printf("%lld\n",n-DP(90,1,0)+1);
        //为什么 +1：因为上面的 dp 不可避免的会将 0 计入答案，需要去掉。
	}
	return 0;
}
```

---

## 作者：FjswYuzu (赞：17)

% Fuyuki

转换一下，取到最后一个石子的人输，那么等同于取到倒数第二个石子的赢，那么为了方便一开始就把石子数减一并且变成求取到最后一个石子的人赢。

定义 $dp_{i,j}$ 为剩下 $i$ 个石子，可以取的范围为 $1 \sim j$：
$$
dp_{i,j} = (\operatorname{not} dp_{i-1,2}) \operatorname{or} (\operatorname{not} dp_{i-2,4}) \operatorname{or} \cdots \operatorname{or} (\operatorname{not} dp_{\max(0,i-j),2\times (i-\max(0,i-j))})
$$
显然，对于所有 $j \geq 1$，都有 $dp_{1,j}=1$。

有结论：对于 $dp_i(i \neq 1)$，一定存在一个分界点 $p_i$，使得对于任意 $j \geq p_i,1 \leq k \leq p_i$，都有 $dp_{i,j}=1,dp_{i,k}=0$。因为当取值包含了 $p_i$ 之后，至少存在 $p_i$ 是合法的；同时还可以推得更深的结论，也就是对于所有 $j \geq p_i$，都会有贡献。

那么我们现在想求这个 $p_i$，怎么求呢？

---

前置知识：齐肯多夫定理：任何正整数可以表示为若干个不连续的斐波那契数之和。下面会用到。

写个程序打个表：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool dp[1005][1005];
int main(){
	for(int i=2;i<=40;++i)
	{
		for(int j=1;j<=90;++j)
		{
			for(int k=1;k<=min(i,j);++k)
			{
				dp[i][j]|=!dp[i-k][k*2];
			}
		}
	}
	for(int i=2;i<=40;++i)
	{
		for(int j=1;j<=90;++j)
		{
			if(dp[i][j]!=dp[i][j-1])
			{
				printf("%d %4d\n",i-1,j);
				break;
			}
		}
	}
	return 0;
}
```

其中 $i-1$ 就是有 $i$ 个石子，$j$ 为取值范围，$dp$ 定义如上。

可以列一个表出来（因为懒得制表了所以打代码块应该没问题吧）：

```plain
num 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
par 1 2 3 1 5 1 2 8 1 2  3  1  13 1  2
```

肉眼可见 `par`（就是 $p$ 啦）一行的所有数都是斐波那契数（而且这个题目看起来也很像 Fib Nim 所以应该不难联想到）。

考虑将 `par` 对应成斐波那契数（以下 $f_i$ 表示第 $i$ 个斐波那契数，其中 $f_0=f_1=1$）序号：

```plain
num 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
fib 1 2 3 1 4 1 2 5 1 2  3  1  6  1  2
par 1 2 3 1 5 1 2 8 1 2  3  1  13 1  2
```

再引入一个东西，叫做斐波那契进制，分解方法如下：

- 从高到低位枚举斐波那契数 $f_i$，如果当前的 $n > f_i$，那么就将 $n$ 减去 $f_i$ 并且将此位置设为 $1$；   
- 否则置 $0$。

这样就会将一个数 $n$ 划分为不会重复的，一个只有 $0$ 或者 $1$ 的字符串，这个字符串就是 $n$ 在斐波那契进制下的表示。可以用齐肯多夫定理证明可行。

因为 $f_{i+2}>f_i \times 2$，所以一次分解时间复杂度约为 $O(\log n)$。

对着这个东西看，~~我也不知道为什么~~可以看出 `num` 所对应的 `par` 就是此 `num` 在斐波那契进制下的表示的最低位的 $1$ 所表示的值。（其实也可以稍微看出点眉目，因为 $f_i = f_{i-1} + f_{i-2}$，这样两个相邻的 $1$ 就会变成一个 $1$）

根据我们可能看出的东西，同斐波那契进制表示的性质（就是上面括号里面的东西），也可以得到 $p$ 数列的一个小结论：

- 对于数列 $p$ 的前 $f_i$ 项，由数列的前 $f_{i-1}$ 项与前 $f_{i-2}$ 项接在一起，并且将 $f_i$ 项更改成 $f_i$ 即可。

~~然而我们会构造并没有什么用。~~

---

我们知道了 $p_i$，考虑将答案表示出来。

根据 $p_i$ 的定义，答案显然为：

$$\sum_{i=1}^{N}[k \geq p_i]$$

既然知道了构造方法，那么定义 $sum(i,j)$ 为，数列 $p$ 的前 $f_i$ 项出现了 $sum(i,j)$ 次 $f_j$。

根据我们的构造方法，我们可以将其用 $O(\log^2 n)$ 的时间预处理出来所有的 $sum(i,j)$。

回答询问时，我们先找到最大的 $c$，使得 $k \geq p_c$ 并且 $k<p_{c+1}$。然后去回答这个问题。

因为根据构造方案，$[1,f_i]$ 一段显然与 $[f_{x}+1,f_x+f_i]$ 一段相等，所以贡献相同，可以将 $N$ 用斐波那契进制拆开，然后去分段计算。

然后发现这个过程还可以对 $sum(i,j)$ 滚一次前缀和，可以少一只 $\log$。

时间复杂度 $O(T \log n + \log n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL sum[105][105],f[105];
int N;
int main(){
	f[0]=f[1]=1;
	f[2]=2;
	for(N=3;f[N-1]<=1e18;++N)	f[N]=f[N-1]+f[N-2];
	--N;
//	for(int i=1;i<=N;++i)	printf("%lld\n",f[i]);
	for(int i=1;i<=N;++i)
	{
		sum[i][i]=1;
		for(int j=1;j<=i;++j)	sum[i+1][j]=sum[i-1][j]+sum[i][j]-int(j==i-1);
	}
	for(int i=1;i<=N;++i)	for(int j=1;j<=N;++j)	sum[i][j]+=sum[i][j-1];
	int T;
	scanf("%d",&T);
	while(T-->0)
	{
		LL k,n,ans=0;
		scanf("%lld %lld",&k,&n);
		LL cor=1;
		while(f[cor+1]<=k)	++cor;
		--n;
		for(int i=N;i>=1;--i)	if(n>=f[i])	n-=f[i],ans+=sum[i][cor],--i;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Fuyuki (赞：12)

~~打表找规律好题~~

取到最后一颗石子的输，因为这里只有一个游戏所以不需要 $anti-sg$ 定理，可以直接认为是取到倒数第二颗石子的获胜。

设 $f_{i,j}$ 表示还剩 $i$ 颗石子，这一次能取 $[1,j]$ 颗石子时是否能取胜，转移为：（$\oplus$ 表示或）
$$
f_{i,j}=\oplus_{k=1}^{j}[f_{i-k,2k}=0]
$$
容易发现，当 $i$ 确定的时候，随着 $j$ 的增大，$f_{i,j}$ 一定会从某一刻开始变成 $1$。

设 $a_i$ 表示最小的 $j$ 使得 $f_{i,j}=1$ ，那么一定有 $a_{i-a_i}\geq 2a_i$，然后就可以计算 $a$ 并打出前若干项：

| $a_0$    | $a_1$ | $a_2$ | $a_3$ | $a_4$ | $a_5$ | $a_6$ | $a_7$ | $a_8$ | $a_9$ | $a_{10}$ | $a_{11}$ | $a_{12}$ | $a_{13}$ |
| -------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | -------- | -------- | -------- | -------- |
| $\infty$ | 1     | 2     | 3     | 1     | 5     | 1     | 2     | 8     | 1     | 2        | 3        | 1        | 13       |

可以发现，这个数列的生成方式类似斐波那契数列，设 $f_i$ 表示斐波那契数列的第 $i$ 项，$a$ 的前 $f_i$ 项就是将前 $f_{i-2}$ 项接在第 $f_{i-1}$ 项后面，然后将第 $f_i$ 项替换成 $f_i$。

~~不说人话就是 $a_i$ 等于 $i$ 在斐波那契进制下的 lowbit~~

现在要求的答案是 $\sum_{i=0}^{i=n-1}[a_i\leq k]$，因为 $a$ 内本质不同的数字个数只有 $O(logn)$ 个，所以可以分别统计出现次数。

设 $s_{i,j}$ 表示前 $f_i$ 项中 $f_j$ 的出现次数，那么 $s_{i,j}$ 可以 $O(log^2n)$ 计算出来，用类似斐波那契进制的就可以 $O(log^2n)$ 地回答询问了。

容易发现可以上一个简单的前缀和优化达到 $O(log^2n+Tlogn)$ 的总复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
const int N=90;
int p,T;
long long n,k,ans,f[N+2],s[N+2][N+2];
int main(){
	f[0]=1,f[1]=1;
	FOR(i,1,N){
		f[i+1]=f[i]+f[i-1],s[i][i]=1;
		FOR(j,1,i)s[i+1][j]=s[i-1][j]+s[i][j]-(j==i-1);
	}
	FOR(i,1,N)FOR(j,1,N)s[i][j]+=s[i][j-1];
	for(scanf("%d",&T);ans=p=0,T--;cout<<ans<<'\n'){
		for(scanf("%lld%lld",&k,&n);f[p+1]<=k;p++);
		ROF(i,N,1)if(n>f[i])n-=f[i],ans+=s[i][p];
	}
	return 0;
}
```

---

## 作者：Vision271 (赞：10)

### 引入
* 首先我们看到原题题面是一个 anti-fibonacci 博弈。
* 感性理解一下：如果我拿完某一手之后，场上还剩不止 $1$ 颗石子。这时，你会选择一把拿完，从而让我可行操作集为空，从而让自己输掉吗？
* 肯定不会。所以，我必须确保只给你留了一颗石子才能让你输掉。换句话说，我必须是恰好拿完那 $n-1$ 颗石子的人。
* 所以我们可以把原题转换成一个 $n-1$ 颗石子的斐波那契博弈 （ $n=1$ 直接特判掉），唯一的区别是有一个 $k$ 。
* 我们先来研究一下斐波那契博弈（大量归纳法警告）。

### 斐波那契博弈(Fibonacci Nim)
* 有一堆石子，数量为 $n(n>1)$ ，拿走最后一颗的玩家获胜。
* 第 $1$ 手不能全部拿完，第 $i+1$ 手至多拿第 $i$ 手拿的数量的 $2$ 倍。
* 先放结论：当且仅当 $n$ 是 $fibonacci$ 数，先手必败。
* 证明：（下面认为 $fib_0=fib_1=1,fib_2=2$ ，但所有 $i$ 最小从 $1$ 开始）
	* 引理 $1$ ： $fib_{i+1}<2fib_i<fib_{i+2}\ (i>1)$
    	* $2fib_i=fib_i+fib_{i-1}+fib_{i-2}=fib_{i+1}+fib_{i-2},and\ fib_{i-2}<fib_i\ (i>1)$
   * 引理 $2$ ： $\frac{4}{3}fib_i<fib_{i+1}$
      * 显然 $i=1,2,3$ 时成立。
      * 如果该引理对 $i=1,2,\dots,m-1$ 成立，则：
      * $\frac{4}{3}fib_i=\frac{4}{3}fib_{i-1}+\frac{4}{3}fib_{i-2}<fib_i+fib_{i-1}=fib_{i+1}$
   * 引理 $3$ : $fib_i\geqslant \frac{1}{3}fib_{i+2}$
      * 当 $i=1$ ，显然成立。
      * 当 $i\geqslant 2$ ，假设不成立，从而 $fib_{i+2}>3fib_i=2fib_i+fib_{i-1}+fib_{i-2}=fib_{i+1}+fib_i+fib_{i-2}=fib_{i+2}+fib_{i-2}$ ，矛盾。
      * 所以引理 $3$ 成立。
   * 引理 $4$ ：从小于 $fib_i$ 的 $fibonacci$ 数中选取 $fib_{a_1},fib_{a_2},\dots,fib_{a_k},a_{i+1}>a_i+1$ （这一个条件的实际含义是任意两项不许连续），则 $\sum\limits_{i=1}^k fib_{a_i}<fib_i$ 。
       * 假设 $\sum\limits_{i=1}^k fib_{a_i}\geqslant fib_i$ ，则我们有 $\sum\limits_{i=1}^{k'=k-1} fib_{a_i}\geqslant fib_i-fib_{a_k}\geqslant fib_{a_k-1}$ （因为 $i\geqslant a_k+1$ ），且显然 $a_k-1>a_{k'}$ 。
      * 反复递降直到 $k'=1$ ，此时 $fib_{a_1}\geqslant fib_{a_2-1},a_2-1> a_1$ ，显然不成立。
      * 所以引理 $4$ 成立。
	* 引理 $5$ ：（齐肯多夫定理） $x=\sum\limits_{i=1}^k  fib_{a_i},a_{i+1}>a_i+1\ (x\in N^* )$ ，该拆分唯一存在。
    	* 存在性：
          * 若 $m$ 是 $fibonacci$ 数，显然成立。
          * 考虑 $m$ 不是 $fibonacci$ 数的情况。
          * 如果该引理对 $i=1,2,\dots,m-1$ 成立，则：
          * 取 $k_1$ 使 $fib_{k_1}<m<fib_{k_1+1}$ ， 从而记 $m=delta+fib_{k_1}$ 。
          * 显然我们有 $delta=m-fib_{k_1}<fib_{k_1+1}-fib_{k_1}=fib_{k_1-1}<m-1$ 。
          * 从而 $delta$ 一定满足该定理。同时， $delta<fib_{k_1-1}$ ，所以 $delta$ 的拆分的最后一个至多为 $fib_{k_1-2}$ ，而 $m$ 独立于 $delta$ 的拆分仅有一个 $fib_{k_1}$ ，两者显然不连续。
      * 唯一性：
         * 假设 $m$ 是最小的有两种拆分的数， $a,b$ 分别为其拆分中最大的 $fibonacci$ 数。
         * 首先假设 $a\ne b$ 。不妨令 $a<b$ ，由引理 $4$ ，第一种拆分所得的和必然 $<b$ ，又 $b<m$ ，所以不成立，从而 $a=b$ 。
         * 那么 $m-a$ 必然有两种拆分才能使 $m$ 的拆分不唯一，但这与 $m$ 是最小的有两种拆分的数矛盾。所以假设不成立，该拆分一定唯一。
	* 好耶！我们终于可以回到斐波那契博弈了！（雾）         
	* 定理 $1$ ：当 $n$ 是 $fibonacci$ 数，先手必败,且后手最后赢的一手（拿完的一手）拿的数量 $\leqslant \frac{2}{3}n$ 。
      * 显然我们可以得到 $n=fib_2,fib_3$ 时成立，且后手最后赢的一手拿的数量 $\leqslant \frac{2}{3}n$ 。
      * 如果该定理对 $n=fib_2,fib_3,\dots,fib_{k-1}$ 都成立，则取 $n=fib_k$ 。
      * 首先我们把当前这局游戏分为两个阶段：拿前 $fib_{k-2}$ 颗石子，和拿后 $fib_{k-1}$ 颗石子。
      * 我们先来证明两个阶段一定可以相互独立（在后手方的努力下）：
      * 首先，先手方肯定不会拿 $\geqslant fib_{k-2}$ 个石子。否则根据引理 $1$ ，此时后手方至多能拿 $2fib_{k-2}>rest=fib_{k-1}$ 颗石子，可以一手拿完（至于这一手为什么可以 $\leqslant \frac{2}{3}n$ ，参见引理 $3$ ，当然下面也有证）。
      * 从而先手方一定不会在第一手离开第一阶段。而第一阶段相当于一个 $n'=fib_{k-2}<n$ 的子游戏，后手肯定能赢，即后手一定能拿到最后一颗，确保两个阶段相互独立，且后手在这个子游戏里最后一手 $\leqslant \frac{2}{3}fib_{k-2}$ 。
      * 于是我们来到了可以作为一个子游戏的第二阶段。显然先手唯一的胜算就是一手全部拿完，但因为后手最后赢的一手拿的数量 $\leqslant \frac{2}{3}fib_{k-2}$ ，所以先手方现在最多拿的数量 $\leqslant \frac{4}{3}fib_{k-2}$ ，由引理 $2$ ，这一数量 $<fib_{k-1}$ 。可怜的先手方无论如何都一手拿不完！
      * 又由引理 $3$ ， $fib_{k-2}\geqslant\frac{1}{3}fib_k$ ，即 $fib_{k-1}\leqslant\frac{2}{3}fib_k$ (如果觉得不显然，不要忘记 $fib_{k-2}+fib_{k-1}=fib_k$ )。即使一手把这个第二阶段拿完也无法 $>\frac{2}{3}n$ ，所以对于 $n$ ，后手最后赢的一手拿的数量一定 $\leqslant \frac{2}{3}n$ 。
   * 定理 $2$ ：当 $n$ 不是 $fibonacci$ 数，先手必胜。
    	* 根据引理 $5$ ，我们把 $n$ 拆分成 $\sum\limits_{i=1}^k  fib_{a_i}$ 。
      * 先手第一次取 $fib_{a_1}$ 颗。由引理 $1$ (后半部分)，后手无法一手取完 $fib_{a_2}$ ，从而这时的后手相当于上面定理 $1$ 中的先手。攻守之势异也！
      * Q：这两个限制不一样（原版中先手可以取 $1,2,\dots,fib_{a_2}-1$ 个，而这里先手（指攻守之势异也之后的后手，下同）可以取至多 $2fib_{a_1}<fib_{a_2}$ 个，两者可能不相同），为什么结论仍然成立？
      * A：可以参考我的博客[博弈论](https://www.luogu.com.cn/blog/wei-xin/bo-yi-lun)中对于必胜/必败态的论述。这里先手方的决策集变小了，而原先的大决策集导向的局面是全为必胜，所以现在更小的决策集导向的局面仍然是全为必胜。
      
### 核心思路
* 我们回来考虑 $k$ 的限制。
* 首先，当 $n$ （这里指原题的 $n$ 减一，下同）是 $fibonacci$ 数，显然不变。先手方可行决策集显然减小（下面会继续用这个理论，没看的可以去看看）。
* 当 $n$ 不是 $fibonacci$ 数，我们考虑定理 $2$ 中的必胜策略条件。当 $k\geqslant fib_{a_1}$ 时，显然不变；当 $k<fib_{a_1}$ ，先手方一手拿不完这个。从而先手方在这一个子游戏（阶段）中必败，而且因为先手方决策集减小（相对于这个子游戏），所以这个子游戏符合原斐波那契博弈的一切性质，换句话说后手一定可以确保定理 $1$ 的后半部分成立。
* 所以我们记一个数的齐肯多夫拆分下最小的一个 $fib$ 为 $lowbit$ ，所求即 $\sum\limits_{i=1}^n [k\geqslant lowbit(i)]$ 。
* 不太好求，考虑容斥。求出所有的必败情况，即 $\sum\limits_{i=1}^n [k<lowbit(i)]$ 。数位 DP ！直接从高位向低位走，当走到的位的位权 $\leqslant k$ 时后面肯定都只能填 $0$ ，即只有一种方案。
* 详细思路不太好讲，但好在我有一份注释详细的代码。看代码吧。（鸣谢 @Salieri ，他的题解给了我很多实现细节上的帮助）（但我还是想吐槽一句，不要老是用显然来跳过各种证明， $Fibonacci$ 博弈的题本来就少，这很可能是很多人的第一道（比如我）。真能随便显然过去的人没必要看题解吧。。。）

```cpp
#include<bits/stdc++.h>
#define il inline
#define re register
#define b_s basic_string
#define For(i,a,b) for(re int i=(a);i<=(b);++i)
#define foR(i,a,b) for(re int i=(a);i>=(b);--i)
#define uint unsigned int
#define ll long long
#define ull unsigned long long
using namespace std;
il ll rd(){
	ll s=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){s=(s<<3)+(s<<1)+(ch^48);if(ch!='\n') ch=getchar();}
	return s*f;
}
char wtst[66];
int wtps;
il void wt(ll x){
	if(x<0) putchar('-'),x=-x;
	while(x>9) wtst[++wtps]=(x%10+'0'),x/=10;
	wtst[++wtps]=x+'0';
	while(wtps) putchar(wtst[wtps--]);
	return;
}
il void wth(ll x){wt(x);putchar('\n');return;}
il void wtk(ll x){wt(x);putchar(' ');return;}

const ll lim=1e18;
ll fib[107],dp[107],k,n;//dp[i]:i位及以下可以随便摆的总方案数 
bool v[107];

ll dfs(int wei,bool full,bool was){
	if(wei<k) return 1;//只剩一种摆法了，全0 
	if(!full && !was && ~dp[wei]) return dp[wei];
	ll ret=0;
	ret+=dfs(wei-1,full&(!v[wei]),0);//这一位不摆1 
	if(!was && (!full || v[wei])) ret+=dfs(wei-1,full,1);//这一位摆1 
	if(!full && !was) dp[wei]=ret;//记忆化 
	return ret;
}

int main(){
	fib[0]=fib[1]=1;
	For(i,2,86) fib[i]=fib[i-1]+fib[i-2];
	int T=rd();
	while(T--){
		memset(v,0,sizeof(v));memset(dp,-1,sizeof(dp));
		k=rd(),n=rd()-1; ll uk=k,un=n;
		foR(i,86,1) if(fib[i]>uk) k=i;//k以下的位都不能放
		foR(i,86,1) if(un>=fib[i]) un-=fib[i],v[i]=1;
		//记录一下k的齐肯多夫拆分对应位是否有，以便于数位dp时计算是否顶满（即是否已经<k） 
		//注意到一个数的斐波那契进制（如果我们规定必须进位）表示必然是一个齐肯多夫拆分。 
		wth(n-dfs(86,1,0)+1);//不可避免的会统计到k及以上的位都是0的一种情况 
	}
	return 0;
}
```

---

## 作者：do_while_true (赞：6)

anti-game 没有用，能取到 $n-1$ 的必胜，不能取到 $n-1$ 的必败，所以现在考虑取走最后石子获胜的情况。

对于一个 $n$ 来说合法的 $k$ 一定是一个前缀，并且一定是贪心取最小的（留给对方的机会更小），所以启发将每个 $n$ 最小的合法的 $k=a_n$ 打出表来，找到最小的 $j$ 满足 $a_{i-j}> 2j$ 即为 $a_i$。

找规律发现是前 $f_i$ 项是将前 $f_{i-2}$ 项拼到第 $f_{i-1}$ 项最后，并将最后的改成 $f_i$。如果感觉不出来这是啥也可以考虑斐波那契博弈和斐波那契进制有关，进而感受到 $a_n$ 就是 $n$ 在斐波那契进制下的 lowbit。

如何证明？直接归纳就行。首先 $a_1=1$ 成立。对于 $n>1$，记 $\operatorname{low}(n)$ 为 $n$ 在斐波那契进制下的 lowbit，则有：

- 取的石子 $x<low(n)$：首先对于固定的 $\operatorname{low}(n-x)$，取得石子越少越优，考察留下的最多是多少，假设 $\operatorname{low}(n)$ 斐波那契进制表示是 `100000`，那么最优的是 `010000,001000,010100,0010100,010101` 这样的形式，往上每隔一位将其置为 1。此时 $x$ 就是 $\operatorname{low}(n-x)$ 在斐波那契序列中的上一位，那么显然有 $\operatorname{low}(n-x)\leq 2x$。
- 取的石子 $x=\operatorname{low}(n)$：$\operatorname{low}(n-x)>2x$（因为斐波那契进制下不会有相邻的两个 1）。

至此可以证明 $a_n=\operatorname{low}(n)$。剩余的 dp 前缀和之类的东西就没啥好说的了（

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#include<random>
#include<assert.h>
#define pb emplace_back
#define mp make_pair
#define fi first
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n'
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n'
#define DE(fmt,...) fprintf(stderr, "Line %d : " fmt "\n",__LINE__,##__VA_ARGS__)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef pair<int,ll>pil;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
typedef vector<pll>vpll;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x,T2& ...y){read(x);read(y...);}
const int mod=998244353;
inline void cadd(int &x,int y){x=(x+y>=mod)?(x+y-mod):(x+y);}
inline void cdel(int &x,int y){x=(x-y<0)?(x-y+mod):(x-y);}
inline int add(int x,int y){return (x+y>=mod)?(x+y-mod):(x+y);}
inline int del(int x,int y){return (x-y<0)?(x-y+mod):(x-y);}
int qpow(int x,int y){
	int s=1;
	while(y){
		if(y&1)s=1ll*s*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return s;
}
const int N=110;
ll f[N],s[N][N],m;
signed main(){
	#ifdef do_while_true
//		assert(freopen("data.in","r",stdin));
//		assert(freopen("1.out","w",stdout));
	#endif
	m=87;
	f[0]=f[1]=1;
	for(int i=1;i<=m;i++){
		f[i]=f[i-1]+(i>=2?f[i-2]:0);
		s[i][i]=1;
		for(int j=1;j<i;j++){
			s[i][j]=s[i-1][j]+s[i-2][j]-(j==(i-2));
		}
	}
	for(int i=1;i<=m;i++){
		s[i][i]=0;
		for(int j=1;j<=i;j++)s[i][j]+=s[i][j-1];
	}
	int T;read(T);
	while(T--){
		ll k,n;read(k,n);
		int p=0;
		for(int i=m;i>=1;i--)if(f[i]<=k){p=i;break;}
		ll ans=0;
		int fl=0;
		for(int i=m;i>=1;i--)
			if(f[i]<=n){
				if(!fl)ans+=s[i][min(i,p)];
				else ans+=s[i][min(i,p)]+(p>=fl);
				fl=i;
				n-=f[i];
			}
		cout<<ans<<'\n';
	}
    #ifdef do_while_true
//		cerr<<'\n'<<"Time:"<<1.0*clock()/CLOCKS_PER_SEC*1000<<" ms"<<'\n';
	#endif
	return 0;
}
```

---

## 作者：Pyrf_uqcat (赞：4)

## 题意
这道题的题板还是好理解的，我大致复述一遍。

**初始**

有 $n$ 个石子，甲乙两人轮流取且**甲先取**。

**取石子过程**

第一次甲取的个数要 $\le k$，且**下一个人不能超过上个人取的个数的两倍**。

**判断输赢**

取得最后一个石子的人输，还有一个人赢。

**求解**

求 $i$ 从 $1$ 到 $N$ 中，有几个 $i$ 满足当石子为 $i$ 个时**甲有必胜策略**。

## 思路
明显是一道博弈论，考虑**斐波那契博弈**以及**数位dp**。但是我不会，所以建议看其他巨佬的题解。对于我这种蒟蒻来说似乎还是找规律更简单一些。

那么我们该如何**打表找规律**呢？还是用到 dp 求解。

$dp_{i,j}$ 表示当剩下 $i$ 颗石子时，可以取值的范围有 $[ 1,j ]$。又以 $y_i$ 表示当 $i$ 颗石子时，能够取得的最小值。

再计算从 $1$ 开始的 $y_i$，可得：

```
y:1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 34 ...
```
多打一些以便于推导规律。可以发现斐波那契数列：


```
1 2 3 5 8 13 21 34 ...
```
下文中以 $f_i$ 表示第 $i$ 项斐波那契数。

整理一下思路，由此继续推：

**剩下 $[f_p+1,f_{p+1}] $ 颗石子时的最小值是剩下石子为 $[f_1,f_{i-2}-1]$ 时的最小值**。

注：上述结论中 $p$ 是一个量，指第 $p$ 项。

但是这样还是不能过本题，同时需要**前缀和**进行优化。

代码只需要跟着思路推即可得出，可以锻炼大家的思维分析能力以及代码构造能力。

---

## 作者：PosVII (赞：2)

**声明**

------------

本题解中若没有声明，则使用的算法都为自己想出来的算法，通常情况下是有着超高时间空间复杂度，不能与其他大佬相比较的，本题解只是有着一些思路引导。

**法一 博弈（dp）**

------------

对于这么庞大的数据，我的数组方法肯定无了，但我们可以打个小范围的列一下。

- 对于 $dp[i][k]$ ，$i$ 为剩下石子数量，$k$ 为上一次的人取得石子数量。
- $dp[i][k]$ 为1则表示在剩下石子数量为 $i$，当前取得石子数量为 $k$ 的时候先手者有必胜策略，反之则不是必胜（可以理解为必败）。

1. $k \ge i$ 时 $dp[i][k]=1$（可以一次取完）。
2. $k < i$ 时 若 $j=[1,k]$ 中有 $dp[i-j][j*2] = 0$，$dp[i][k] = 1$，否则 $dp[i][k] = 0$
（当不能一次取完时，若有一种取法能让下一个取的人作为先手时必败则这种取法必胜）。

按照这个规则，我们打 $10*10$ 的一个表（i，k均从1开始,i为纵轴，k为横轴）。

```
1 1 1 1 1 1 1 1 1 1
0 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
0 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 1 1 1
1 1 1 1 1 1 1 1 1 1
0 1 1 1 1 1 1 1 1 1
```

在推的过程中，我们可以发现，只要在同一行，左边是1那么他就是1。

- 情况1: $k+1 >= i$。
- 情况2：已经尝试过 $[1,k]$，只需要额外尝试 $k+[1,2 \times k]$ 即可。

列到 $20*20$ 我们会发现……我们可以把dp数组缩成一维。

- 对于 $dp[i]$，$i$ 为剩下石子数量。
- $dp[i]$ 表示当剩下石子数量为 $i$ 时，$k$ 至少为 $dp[i]$ 就可以保证必胜。

真不戳，但中间出了点问题……

好像要求输出的是 $[1,n-1]$ 个石子时开始可以取k个石子是能必胜的次数……

最终30分到手，数组还是太大了，O2只能救一个点，所以……

此方法终，止步于此。

**法二 找规律**

------------

有着 $10^{18}$ 那么庞大的数据，我们肯定是不能用数组实现的，我们需要找规律。

我们再列一列一维dp的数值。

```
1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 34 1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 55 1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 89 1 2 3 1 5 1 2 8 1 2 3
```

在这些看似无序的数列中断断续续出现了斐波那契数列！

可惜它们中间有一些其他的数，我们对每个斐波那契数列中的数中相隔的数字数量列出来。

```
0 0 1 2 4 7 12 20
```

好奇怪啊，每一项都是前两项相加再加一耶！

我们再把中间隔的数字列出来……

- $3-5:   1$
- $5-8:   1,2$
- $8-13:  1,2,3,1$
- $13-21: 1,2,3,1,5,1,2$
- $21-34: 1,2,3,1,5,1,2,8,1,2,3,1$
- $34-55: 1,2,3,1,5,1,2,8,1,2,3,1,13,1,2,3,1,5,1,2$

真奇怪，我们可以得到这个式子。

$str[n]=str[n-1]+char(n-2)+str[n-2]$

那么真相大白了吧！

我们只需要对于每一段能够大于 $k$ 的数字数量存到数组里

而对于多出不是完整的一段的数列，我们可以使用递归将其拆分至完整的几小段

占用内存极小，但也需要用到大量数组进行递推

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int x;
long long k,n,sum;
long long fib[96]={0,1},rfib[96]={1,1};//1 2 3 5 8 13 21 34
long long f[96]={0,0};//0 0 1 2 4 7 12 20 33 54 88 143 232 376 609 986 1596 2583 4180 6764 10945 17710 28656
long long val[96],xval[96];
void dfs(long long dep,int fl) {
	if(dep>=n) return;
	//cout<<dep<<" "<<fl<<" "<<f[fl-1]<<endl;
	if(dep+f[fl-1]<=n) {
		sum+=val[fl];
		//cout<<dep+1<<" to "<<dep+f[fl-1]<<" "<<fl<<" is all ready "<<val[fl]<<endl;
	}
	else {
		dfs(dep,fl-1);
		if(fl<2) return;
		if(dep+f[fl-2]+1>n) return;
		if(rfib[fl-2]<=k) {
			//cout<<dep+f[fl-2]+1<<" is smaller than k "<<endl;
			sum++;
		}
		dfs(dep+1+f[fl-2],fl-2);
	}
	return;
}
int main() {
	int t;
	cin>>t;
	for(int i=2;i<=91;i++) {
		f[i]=f[i-1]+f[i-2]+1;
		fib[i]=fib[i-1]+f[i-2]+1;
		rfib[i]=rfib[i-2]+rfib[i-1]; 
	}
	while(t--) {
		cin>>k>>n;
		n--;
		if(n<=0||k<=0) {
			cout<<0<<endl;
			continue;
		} 
		x=3,sum=0;
		xval[1]=0,xval[2]=0;
		if(k>=1) xval[1]=1;
		if(k>=1) xval[2]=1;
		if(k>=2) xval[2]=2;
		//cout<<1<<" "<<xval[1]<<" "<<fib[1]<<" "<<val[1]<<endl;
		//cout<<2<<" "<<xval[2]<<" "<<fib[2]<<" "<<val[2]<<endl;
		while(fib[x]<=n) {
			val[x]=val[x-1]+val[x-2];
			if(rfib[x-2]<=k) val[x]++;
			xval[x]=xval[x-1]+val[x-1];
			if(rfib[x]<=k) xval[x]++;
			//cout<<x<<" "<<xval[x]<<" "<<fib[x]<<" "<<val[x]<<endl;
			x++;
		}
		dfs(fib[x-1],x-1);
		if(fib[x-1]<=n) cout<<xval[x-1]+sum<<endl;
		else cout<<xval[1]<<endl;
	}
	return 0;
} 
```
**总结**

------------

很好一道……博弈论？这道题其实是以思路为主，很需要理解能力与代码实现能力（对于我而言），这道题重在懂得这道题的一些特殊之处，如：

- k越大先手越容易获胜
- 想出此题的一维数组解法
- 找到规律

这道题需要的代码能力在蓝题难度，但打着打着很容易把自己打混乱（我的做法），对于判断不能完全组合成斐波那契数列的数列需要单独把多出来的数列进行分解判断优化。

此题坑点很多，包括但不限于：

- $n$ 和 $k$ 有可能为 $0$
- 第 $n$ 个数不算在内
- 有可能 $n$ 为 $1$，但你直接输出的是 $n=2$ 的情况了

我做此题时间太长，所以还是要加以进步的

**祝大家AC快乐！**

---

## 作者：lupengheyyds (赞：1)

**[P6791 [SNOI2020] 取石子 - 洛谷](https://www.luogu.com.cn/problem/P6791)**

”还剩 $n$ 个石子，限制为 $k$“的状态记作 $(n,k)$，则可以列出 $SG$ 函数：
$$
SG(n,k)=\left\{\begin{aligned}&\operatorname{mex}_{i=1}^kSG(n-i,2i)&n\ne 0\\&0&n=0\end{aligned}\right.
$$
打出 $[SG(n,k)>0]$ 的表为：

![](https://cdn.luogu.com.cn/upload/image_hosting/rkeh30wt.png)
先是发现在斐波那契数处 $0$ 非常的多，接着发现其他地方 $0$ 的也和斐波那契数列有关，最终可以得到以下结论：

设正整数 $n$ 拆成若干个不同的斐波那契数之和后，其中最小的为 $\tau(n)$ 则：
$$
\forall k<\tau(n),SG(n,k)=0\\\forall k\ge \tau(n),SG(n,k)>0
$$
于是 $ans=f(N-1)=\sum_{n=1}^{N-1}[\tau(n)\le k]$，设小于等于 $n$ 的最大的斐波那契数为 $x$ 则有 $f(n)=f(x-1)+f(n-x)+[x\le k]$，计算即可，复杂度 $\mathcal O(T\log N)$。

---

## 作者：HC20050615 (赞：1)

# 思路
我本来以为这道题是个博弈论，结果看了一下题解，全是打表找规律。。。

首先，我们要知道一个结论：假如当 $k=k_0$ 使 $n$ 个石子的情况有必胜策略，则当 $k>k_0$ 时必有必胜策略。这个应该不需要证明了吧。

所以，我们可以设数组 $f[n]$ 表示有 $n$ 个石子时，能使甲有必胜策略的时候，能取到的最小的 $k$。

然后我们可以打出一个表。（其实我并没有打表，是看题解里大佬的题解才知道的）

先把表放出来：
```cpp
   n: 1  2  3  4  5  6  7  8  9  10  11  12  13
f[n]: 1  2  3  1  5  1  2  8  1  2   3   1   13

```
然后可以发现一个其实并不太好发现的规律（如果不打到 $13$ 真的很难看出来吧）：

$n$ 为斐波拉契数的时候，$f[n]=n$。

$f[fib[i-1]+1]\sim f[fib[i]-1]$ 项就是 $f[1]\sim f[fib[i-2]-1]$。

然后就完了，是不是感觉很简单（反正我是没看出来这个规律）。

最后再做一个简单的前缀和，就可以 $O(log_n^{2}+Tlog_n)$ 过掉这道题了。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long read()
{
	char ch=getchar();
	long long res=0;
	while(ch<'0'||ch>'9')
	{
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		res=res*10+(ch^48);
		ch=getchar();
	}
	return res;
}
int T;
long long n,k;
long long fib[91];
long long s[91][91]; 
inline void pre_fib()
{
	fib[0]=1;
	fib[1]=1;
	for(int i=2;i<=90;i++)
	{
		fib[i]=fib[i-2]+fib[i-1];
	}
	return ;
}
inline void pre_s()
{
	for(int i=1;i<=90;i++)
	{
		s[i][i]=1;
	}
	s[2][1]=1;
	for(int i=3;i<=90;i++)
	{
		for(int j=1;j<i-2;j++)
		{
		    s[i][j]=s[i-1][j]+s[i-2][j];
	    }
	    s[i][i-2]=1;
	    s[i][i-1]=1;
	}
	for(int i=2;i<=90;i++)
	{
		for(int j=2;j<=i;j++)
		{
			s[i][j]+=s[i][j-1];
		}
	}
	return ;
}
int main()
{
	pre_fib();
	pre_s();
	T=read();
	while(T--)
	{
		k=read();
		n=read();
		int p=91;
		while(fib[--p]>k);
		long long ans=0;
		for(int i=90;i>=1;i--)
		{
			if(n>fib[i])
			{
				ans+=s[i][min(i,p)];
				n-=fib[i];
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---


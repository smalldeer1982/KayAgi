# [SNOI2020] 区间和

## 题目描述

有一个长度为 $n$ 的整数数列 $a_1,a_2,\cdots,a_n$（可能含有负数）。现在对其进行 $q$ 次操作，每次操作是以下二者之一：

- `0 l r x` 表示对于 $[l,r]$，将 $a_i$ 赋值为 $\max(a_i,x)$；
- `1 l r` 求区间 $[l,r]$ 的最大子段和。即：$\max(0, \max_{l\le u\le v\le r} (\sum_{i=u}^v a_i))$。

## 说明/提示

#### 样例说明

对于样例 $1$：

- 第 $1$ 次询问时序列为 $2,-4,6,-5,5$，最大子段和为 $6$；
- 第 $2$ 次询问时序列为 $2,-4,6,-4,5$，最大子段和为 $7$；
- 第 $3$ 次询问时序列为 $2,-4,6,-1,5$，最大子段和为 $10$；
- 第 $4$ 次询问时序列为 $2,-1,6,-1,5$，最大子段和为 $11$。

#### 数据规模与约定

对于所有数据，$1\le n\le10^5, 1\le q\le 2\times 10^5, |a_i|, |x|\le 10^9$。

- 对于 $10\%$ 的数据，$n,q \le 200$；
- 对于另外 $10\%$ 的数据，$n,q \le 2000$；
- 对于另外 $25\%$ 的数据，每次操作 $0$ 均满足 $l=r$（即，只有单点修改）；
- 对于另外 $20\%$ 的数据，每次操作 $1$ 均满足 $l=1,r=n$（即，只有全局询问）；
- 对于余下 $35\%$ 的数据，无特殊限制。

**有来自出题人的 3 个 hack 数据点**

## 样例 #1

### 输入

```
5 7
2 -4 6 -5 5
1 1 5
0 1 5 -4
1 1 5
0 3 4 -1
1 1 5
0 1 3 -1
1 1 5```

### 输出

```
6
7
10
11```

# 题解

## 作者：cyffff (赞：15)

[$\text{Link}$](https://www.luogu.com.cn/problem/P6792)

在学习了[“$\text{KTT}$”](https://www.luogu.com.cn/problem/P5693) 之后（[我的学习笔记](https://www.luogu.com.cn/blog/cyffff/solution-p5693)）的一个暴力思路。我个人认为这个思路比讨论个数的思路更简洁，需要的讨论也更少。~~其它题解都被 hack 了才写的这篇。~~

这篇题解里没有明确说的内容都在学习笔记里有说。

## 题意

区间对 $x$ 取 $\max$，区间最大子段和。

$n\le 10^5$，$q\le 2\times10^5$。
## 思路
看到取 $\max$ 操作我们可以先放一个吉司机线段树，维护 $\min$ 和 $\text{secmin}$，修改时若 $x\le\min$ 直接返回；若 $\min<x<\text{secmin}$，对当前结点的所有最小值修改；若 $x\ge\text{secmin}$，则递归左右子树。
 
我们沿用 P5693 的思路，考虑用一次函数来表达 $sum,lmax,rmax,totmax$。

考虑 $ls+b$，我们考虑 $l$ 表示的是会变化的数的个数，在这里由于只修改最小值，则 $l$ 为选取的区间中最小值的个数。

考虑每个结点 $x$ 的含义，为最小值增加 $x$ 时就会发生变化。（如果最小值加 $x$ 大于次小值也无需特殊处理，吉司机线段树帮助我们处理了这样的情况）

在 `pushup` 中，我们需要将没有最小值的一边（即最小值不是整个区间的最小值的半个区间）的 $sum,lmax,rmax,totmax$ 的 $l$ 都设为 $0$ 再上传，原因就是我们在上面修改了 $l$ 的定义。

时间复杂度：不会算，有没有人可以分析一下？（或许和 P5693 复杂度一样，为 $O((n+m)\log^3n+q\log n)$，$m$ 为修改次数，$q$ 为询问次数）

代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=1e5+10;
const ll INF=1e15;
int n,Q,p[N];
#define ls (rt<<1)
#define rs (rt<<1|1)
#define pfl pair<Func,ll>
#define mpr make_pair
#define fi first
#define se second
struct Func{
	int k;
	ll b;
	inline friend Func operator+(const Func &a,const Func &b){
		return (Func){a.k+b.k,a.b+b.b};
	}
	inline void add(ll v){ b+=k*v; }
	inline void set(){ k=0; }
};
inline pfl max(Func a,Func b){
	if(a.k<b.k||a.k==b.k&&a.b<b.b) swap(a,b);
	if(a.b>=b.b) return mpr(a,INF);
	return mpr(b,(b.b-a.b)/(a.k-b.k));
}
struct node{
	Func lmax,rmax,totmax,sum;
	ll x;
	inline friend node operator+(const node &a,const node &b){
		node t;
		pfl tmp;
		t.x=min(a.x,b.x);
		tmp=max(a.lmax,b.lmax+a.sum);
		t.lmax=tmp.fi,t.x=min(t.x,tmp.se);
		tmp=max(b.rmax,a.rmax+b.sum);
		t.rmax=tmp.fi,t.x=min(t.x,tmp.se);
		tmp=max(a.totmax,b.totmax);
		t.x=min(t.x,tmp.se);
		tmp=max(tmp.fi,a.rmax+b.lmax);
		t.totmax=tmp.fi,t.x=min(t.x,tmp.se);
		t.sum=a.sum+b.sum;
		return t;
	}
	inline node set(){
		node a=*this;
		a.lmax.set(),a.rmax.set(),a.totmax.set(),a.sum.set();
		return a;
	}
};
struct KTT{
	node a[N<<2];
	ll tag[N<<2],mnn[N<<2],sec[N<<2];
	inline void pushup(int rt){
		if(mnn[ls]==mnn[rs]){
			mnn[rt]=mnn[ls];
			sec[rt]=min(sec[ls],sec[rs]); 
			a[rt]=a[ls]+a[rs];
		}
		if(mnn[ls]<mnn[rs]){
			mnn[rt]=mnn[ls];
			sec[rt]=min(sec[ls],mnn[rs]); 
			a[rt]=a[ls]+a[rs].set();
		}
		if(mnn[ls]>mnn[rs]){
			mnn[rt]=mnn[rs];
			sec[rt]=min(mnn[ls],sec[rs]); 
			a[rt]=a[ls].set()+a[rs];
		}
	}
	inline void build(int rt,int l,int r){
		tag[rt]=-INF;
		if(l==r){
			Func q={1,p[l]};
			a[rt]=(node){q,q,q,q,INF};
			mnn[rt]=p[l],sec[rt]=INF;
			return ;
		}
		int mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(rt);
	}
	inline void push(int rt,ll w){
		if(w<=mnn[rt]) return ;
		ll v=w-mnn[rt];
		mnn[rt]=w;
		tag[rt]=max(tag[rt],w);
		a[rt].x-=v;
		a[rt].lmax.add(v);
		a[rt].rmax.add(v);
		a[rt].sum.add(v);
		a[rt].totmax.add(v);
	}
	inline void defeat(int rt,int l,int r,ll v){
		tag[rt]=max(tag[rt],v);
		if(v-mnn[rt]>a[rt].x){
			int mid=l+r>>1;
			defeat(ls,l,mid,v);
			defeat(rs,mid+1,r,v);
			pushup(rt);
		}else{
			push(rt,v);
		}
	}
	inline void pushdown(int rt){
		if(tag[rt]!=-INF){
			ll bas=tag[rt];
			tag[rt]=-INF;
			push(ls,bas);
			push(rs,bas);
		}
	}
	inline void update(int rt,int l,int r,int L,int R,int k){
		if(mnn[rt]>=k) return ;
		if(L<=l&&r<=R&&k<sec[rt]){
			defeat(rt,l,r,k);
			return ;
		}
		pushdown(rt);
		int mid=l+r>>1;
		if(L<=mid) update(ls,l,mid,L,R,k);
		if(R>mid) update(rs,mid+1,r,L,R,k);
		pushup(rt);
	}
	inline node query(int rt,int l,int r,int L,int R){
		if(L<=l&&r<=R){
			return a[rt];
		}
		pushdown(rt);
		int mid=l+r>>1;
		if(R<=mid) return query(ls,l,mid,L,R);
		if(L>mid) return query(rs,mid+1,r,L,R);
		return query(ls,l,mid,L,mid)+query(rs,mid+1,r,mid+1,R);
	}
}t;
int main(){
	n=read(),Q=read();
	for(int i=1;i<=n;i++){
		p[i]=read();
	}
	t.build(1,1,n);
	while(Q--){
		int opt=read();
		switch(opt){
			case 0:{
				int l=read(),r=read(),v=read();
				t.update(1,1,n,l,r,v);
				break;
			}
			case 1:{
				int l=read(),r=read();
				write(max(0ll,t.query(1,1,n,l,r).totmax.b)),putc('\n');
				break;
			}
		}
	}
	flush();
    return 0;
} 
```
再见 qwq~


---

## 作者：洛苡hh (赞：9)

## 这篇题解内容比较详细有点长，适合像我这样的初学蒟蒻

学习过程中参考了楼上两位dalao的题解以及[EI的博客](https://entropyincreaser.blog.uoj.ac/blog/5217)。

这题就是 KTT+吉司机，所以建议在做这题之前先去把板题切了：

[P5693 EI 的第六分块](https://www.luogu.com.cn/problem/solution/P5693)  

[P6242 【模板】线段树 3](https://www.luogu.com.cn/problem/P6242)

~~虽然我是先做的这题，这题代码拷过去改改秒切P5693，双倍经验了属于是。~~

**本篇题解不含复杂度证明**

题意很清晰不说了。

### 吉司机线段树

首先讲操作 0，这取最值的操作一眼吉司机，会的大佬可以直接跳过啦。

我们先考虑一下该操作难点在哪里：因为整个区间里有很多数，我们无法确定哪些是要变的哪些是不变的，变的那些变化多少，这就导致无法快速更新信息，只能暴力的递归到叶子再合并上来，这样复杂度直接爆炸！

那如果整个区间上只有一种数需要被更新呢？那问题不就迎刃而解了！具体而言，我们需要维护三个信息：  
- $mn$：区间最小值。
- $semn$：区间次小值，注意要保证它是严格的。
- $cntmn$：区间最小值数量。

当 $mn \ge x$ 时，操作显然是无效的，因为区间里所有数都比操作数大。

当 $mn < x < semn$ 时，这是我们真正需要处理的区间，实际要做的就是令所有最小值加上 $x$，又因为我们维护了最小值数量，所以这就是一个平凡的区间加操作。

当 $x > semn$ 时，继续向下递归直到找到上述情况，最坏情况就是一直递归到了叶子。

该算法的复杂度是单次更新是 $O(\log^2n)$，不会证，但肯定能过。

### KTT
考虑操作 1，求区间最大子段和，先考虑在线段树上的暴力做法。

朴素的线段树做法是维护四个信息：
- $totmx$：区间最大子段和。
- $lmx$：以左端点为起点的最大子段和（强制包含左端点）。
- $rmx$：以右端点为起点的最大子段和（强制包含右端点）。
- $sum$：区间和。

怎么维护呢？有以下式子：
- $totmx = \max (totmx_{ls} , totmx_{rs} ,rmx_{1s} + lmx_{rs})$。
- $lmx = \max (lmx_{ls} ,  sum_{ls} + lmx_{rs})$。
- $rmx = \max (rmx_{rs} ,  sum_{rs} + rmx_{ls})$。
- $sum = sum_{ls} + sum_{rs}$  。  
($ls$ $rs$ 分别为左右儿子）。

解释一下 考虑最大子段和一共有三种情况：
1. 子段全部位于左区间内 即 $totmx_{ls}$。
2. 子段全部位于右区间内 即 $totmx_{rs}$。
3. 子段横跨两个区间 这时候左右区间都要做贡献 因为要保证子段连续 所以是 $rmx_{1s} + lmx_{rs}$。

求 $totmx$ 的方式也解释了为什么要维护 $lmx$ 和 $rmx$。

对于 $lmx$ 只要强制包含左端点就行啦:
1. 要么直接继承左区间的答案 即 $lmx_{ls}$。
2. 要么考虑更新 那就是左区间和加上右区间前缀 即 $sum_{ls} + lmx_{rs}$。

rmx 同理。

sum 太基础没啥好说的。

分析一下该算法的复杂度，因为你每次更新都可能会改变最大子段的构成，这个决策改变之后所有维护的信息都要变，也就是在最劣情况下我们需要重构整棵线段树，即 $O(n)$，查询的话就是 $O(\log n)$ 的，所以整体还是比暴力要优，对于一些查询多的题说不定也能冲过去。

现在考虑该算法瓶颈，不难发现在于**修改会改变最大子段构成的决策**，但手推几组数据也很容易发现，不是所有修改都会对决策有影响，只有当变化量大于某个阈值时才会改变决策，否则该是哪个子段还是哪个子段，当成平凡的区间加维护就好。

我们考虑将每个值维护成一次函数的形式 $y=kx+b$，用一个二元组 $(k,b)$ 来表示，$b$ 是现在的值，$k$ 是最大子段的长度，$x$ 即为变化量，在取 $\max$ 时，以前我们只需比较 $b$ 的大小就够了（$x=0$），现在我们还要维护一下什么时候这个决策会改变，具体来说:

两条直线 $l1$，$l2$，不妨令 $b_{l1} > b_{l2}$
1. $k_{l1} > k_{l2}$ 直接把阈值设成 $\inf$。
2. 否则 阈值就是两条直线交点的横坐标。

这部分的代码： 

```cpp
pair<line,long long> max(line a,line b){
	if(a.k<b.k || (a.k==b.k && a.b<b.b)) swap(a,b);
	if(a.b>=b.b) return mkp(a,inf);
	else return mkp(b,(b.b-a.b)/(a.k-b.k));
}
```

易知 $totmx$，$lmx$ 和 $rmx$ 中任何一个改变都可能影响到最终决策，所以整个节点的阈值对它们产生的三个阈值取 $\min$ 即可。

具体的复杂度证明去 EI 大佬的博客看吧，蒟蒻不会分析势能 QwQ

那么所有知识点就都讲完啦！但这题代码巨长很容易写丑，我就是第一遍写完死活调不出来，然后去借鉴了一下题解里两位 dalao 的代码修了修（） 一些细节就放在注释里啦！

## 代码
```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define inf 1e18
#define ls k<<1
#define rs k<<1|1
#define mkp make_pair
using namespace std;

inline long long read(){
	long long x=0;
	int f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

int n,q;
long long A[MAXN];

struct line{
	long long k,b;
	line operator + (const line &a) const{
		return (line){k+a.k,b+a.b};
	}
	void add(long long v){
		b+=k*v;
	}
};

pair<line,long long> max(line a,line b){
	if(a.k<b.k || (a.k==b.k && a.b<b.b)) swap(a,b);
	if(a.b>=b.b) return mkp(a,inf);
	else return mkp(b,(b.b-a.b)/(a.k-b.k));
}

struct node{
	int l,r;
	line lmx,rmx,sum,totmx;
	long long x;//阈值
	long long mn,semn;
	long long tag;//tag维护要变成的值 不是变化量哦
	//我最开始写的是变化量（因为之前做过P6242） 然后发现又加又减有很多分类讨论不好写也不好调 所以重构了一遍代码改成要变成的值了 这样可以直接取max
	node convert(){
		node a=*this;
		a.lmx.k=a.rmx.k=a.sum.k=a.totmx.k=0;
		return a;
	}
}t[MAXN<<2];

void add(node &res,node a,node b){
	pair<line,long long> tmp;
	res.x=min(a.x,b.x);
	//sum=ls.sum+rs.sum
	res.sum=a.sum+b.sum;
	//lmax=max(ls.lmax,ls.sum+rs.lmax)
	tmp=max(a.lmx,a.sum+b.lmx);
	res.lmx=tmp.first;
	res.x=min(res.x,tmp.second);
	//rmax=max(rs.rmax,rs.sum+ls.rmax)
	tmp=max(b.rmx,b.sum+a.rmx);
	res.rmx=tmp.first;
	res.x=min(res.x,tmp.second);
	//totmax=max(ls.totmax,rs.totmax,ls.rmax+rs.lmax)
	tmp=max(a.totmx,b.totmx);
	res.x=min(res.x,tmp.second);
	tmp=max(tmp.first,a.rmx+b.lmx);
	res.totmx=tmp.first;
	res.x=min(res.x,tmp.second);
}
/*
这个地方如果你把吉司机要维护的值和KTT分开其实重载运算符很方便的
当然也可以令一个tmp把属于吉司机的信息记一下 更新完KTT之后再还原现场
总之就是如果把所有信息都封装在一起了 注意更新KTT的时候别把吉司机搞没了就行
*/

void pushup(int k){
	if(t[ls].mn==t[rs].mn){
		t[k].semn=min(t[ls].semn,t[rs].semn);
		t[k].mn=t[ls].mn;
		add(t[k],t[ls],t[rs]);
	}else if(t[ls].mn<t[rs].mn){
		t[k].semn=min(t[ls].semn,t[rs].mn);
		t[k].mn=t[ls].mn;
		add(t[k],t[ls],t[rs].convert());//打过吉司机的都知道吧 只有最值参与区间修改 所以肯定是最值在哪一个儿子上就要哪个的信息啊 这里的k可以感性理解一下吉司机的mncnt 为了方便暂时把另一个清空就行
	}else{
		t[k].semn=min(t[ls].mn,t[rs].semn);
		t[k].mn=t[rs].mn;
		add(t[k],t[ls].convert(),t[rs]);
	}
}

void build(int k,int l,int r){
	t[k].l=l;t[k].r=r;
	t[k].tag=-inf;//因为是维护的变成哪个值要取max所以是-inf 维护变化量的不用管
	if(l==r){
		line tmp={1,A[l]};
		t[k].lmx=t[k].rmx=t[k].sum=t[k].totmx=tmp;
		t[k].x=inf;
		t[k].mn=A[l];
		t[k].semn=inf;
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(k);
}

void calc(int k,long long v){
	if(t[k].mn>=v) return;
	long long tmp=v-t[k].mn;
	t[k].mn=v;
	t[k].tag=max(t[k].tag,v);
	t[k].sum.add(tmp);
	t[k].totmx.add(tmp);
	t[k].lmx.add(tmp);
	t[k].rmx.add(tmp);
	t[k].x-=tmp;
}

void pushdown(int k){
	if(t[k].tag!=-inf){
		calc(ls,t[k].tag);
		calc(rs,t[k].tag);
		t[k].tag=-inf;
	}
}

void upd(int k,long long v){
	t[k].tag=max(t[k].tag,v);
	long long tmp=v-t[k].mn;
	if(tmp>t[k].x){//超过阈值啦！ 直接重构
		upd(ls,v);
		upd(rs,v);
		pushup(k);
	}else{
		calc(k,v);
	}
}

void update(int k,int l,int r,long long v){
	if(t[k].mn>=v) return;
	if(t[k].l>=l && t[k].r<=r && t[k].semn>v){//之前打吉司机错过这里 注意是>不是>= 不然次小值就不严格啦！
		upd(k,v);
		return;
	}
	pushdown(k);
	int mid=(t[k].l+t[k].r)>>1;
	if(mid>=l){
		update(ls,l,r,v);
	}
	if(mid<r){
		update(rs,l,r,v);
	}
	pushup(k);
}

node query(int k,int l,int r){
	if(t[k].l>=l && t[k].r<=r){
		return t[k];
	}
	pushdown(k);
	int mid=(t[k].l+t[k].r)>>1;
	if(mid>=r) return query(ls,l,r);
	if(mid<l) return query(rs,l,r);
	node res;
	res=res.convert();//像我这种写法要注意这里初始化要写好哦 不然会收获一份样例能过但WA0pts的代码
	add(res,query(ls,l,r),query(rs,l,r));
	return res;
}

int main(){
//	freopen("P6792.in","r",stdin);
//	freopen("P6792.out","w",stdout);
	n=read();q=read();
	for(int i=1;i<=n;i++){
		A[i]=read();
	}
	build(1,1,n);
	int op,l,r;
	long long x;
	while(q--){
		op=read();
		l=read();r=read();
		if(op==0){
			x=read();
			update(1,l,r,x);
		}else{
			long long ans=query(1,l,r).totmx.b;
			printf("%lld\n",max(0ll,ans));//注意题面上说可以取空集！ 所以一定要和0取一下max 我因为这个点WA75pts调了好久QwQ
		}
	}
	return 0;
}
//一点小建议：样例给的比较弱只有全局查询 调不出来的宝子可以自己造点有区间查询的数据 或者用小数据拍一拍什么的
```

---

## 作者：do_it_tomorrow (赞：8)

如果只有操作 $0$ 或者操作 $1$，那么这个问题是容易解决的。

如果有操作 $0$，那么直接写吉司机线段树就行了，而如果只有后面的东西就是很板的线段树合并题目。

为了防止我忘记怎么写吉司机，如果 $mn\ge x$ 那么无意义返回，如果 $mn<x<se$ 那么 $mn=x$ 然后返回，对于其他情况继续递归就对了。

考虑怎么为 $mn<x<se$ 的时候维护这个经典的线段树合并的信息。

对于这个经典的线段树合并操作，我们需要维护包含左端点的最大和 $lmx$，包含右端点的最大和 $rmx$，最后是这个节点的贡献 $ans$。

那么要计算 $ans$ 有公式：

$$ans(rt)=\max\{ans(ls),ans(rs),rmx(ls)+lmx(rs)\}$$

所以我们需要快速的确定其儿子的 $lmx$ 和 $rmx$ 值才能打懒惰标记，因为 $lmx$ 和 $rmx$ 具有对称性所以下面只考虑 $lmx$ 操作。

如果 $lmx$ 和 $ans$ 的区间没有不改变，那么区间 $\max$ 的影响是容易计算计算的。

我们只需要记录这个区间中有多少最小值就可以快速计算了，自然的想到考虑什么时候其区间不会改变。

考虑下面一个情况，假设现在 $lmx$ 的区间的紫色，容易理解经过区间 $\max$ 操作是永远不可能取到橙色区间的，因为给橙色区间造成的贡献也会反应到紫色区间身上，然而本来选择的区间的紫色的，所以紫色拥有而橙色不拥有的区间肯定是答案造成了正面贡献的。

![](https://cdn.luogu.com.cn/upload/image_hosting/fb5kwrsw.png)

进一步的，我们得到了右端点经过 $\max$ 操作只会增加，于是总共的增加次数最大只有 $O(n\log n)$，这是一个很优秀的性质。

需要注意即使修改操作并没有包含整个区间因为其只会增加区间和所以 $lmx$ 的右端点依然不会向左，这是容易理解的。

假设紫色区间和红色区间的和为分别为 $S_1$ 和 $S_2$，其中包含的最小值个数分别为 $M_1$ 和 $M_2$，那么红色区间的想要超过紫色区间所受到的区间 $\max$ 的值 $V$ 和原本的最大值 $mx$ 的差 $\Delta$，也就是 $V-mx$ 应该满足：

$$\Delta\ge \dfrac{S_1-S_2}{M_2-M_1}$$
需要注意如果 $M_1=M_2$，那么红色区间永远都不可能超过紫色区间。

那么我们可以维护区间中阈值的最小值，然后将 $\Delta$ 进行累加，当 $\Delta$ 超过这个阈值时就进行类似于吉司机的操作进行直接向下遍历不进行返回最后 `pushup` 就行了。

考虑证明这样操作的复杂度的正确性，因为一次暴力的更改 $lmx$ 只会遍历其所有的祖先而后移操作又是一个罕见操作，所以总共的时间复杂度就是 $O(n\log ^2 n)$。

于是我们就得到了 $O((q+n)\log ^2n)$ 的优秀做法，但是非常难写。

最后感谢 zzq 老师在很久以前的讲解，在视频里学习了思路。

![](https://cdn.luogu.com.cn/upload/image_hosting/1k90f0d1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)![](https://cdn.luogu.com.cn/upload/image_hosting/1k90f0d1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)![](https://cdn.luogu.com.cn/upload/image_hosting/1k90f0d1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)![](https://cdn.luogu.com.cn/upload/image_hosting/1k90f0d1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5,inf=0x3f3f3f3f3f3f3f3f;
int n,q,a[N];
struct Seg{
	struct node{
		int v,ct;node(){v=-inf,ct=0;}node(int k,int V) {v=k,ct=V;}
		friend bool operator<(node a,node b){return a.v<b.v;}
		friend node operator+(node a,node b){return{a.v+b.v,a.ct+b.ct};}
		void ADD(int k){v+=k*ct;}
	};
	struct Node{
		int mn,smn,lazy,Min;node sum,pre,suf,ans;
		void EMP(){mn=smn=Min=inf,sum=pre=suf=ans={0,0},lazy=-inf;}
		void set(int V){mn=lazy=V,Min=smn=inf,sum=pre=suf=ans={V,1};}
		void ck_mn(int k){if(mn!=k) sum.ct=pre.ct=suf.ct=ans.ct=0; }
	}s[N<<2];
	int G(node A,node B){if(B.ct<=A.ct) return inf;return (A.v-B.v)/(B.ct-A.ct);}
	Node pushup(Node X,Node Y){
		Node A;A.EMP();
		A.mn=min(X.mn,Y.mn),A.smn=min(X.smn,Y.smn);
		if(X.mn<Y.mn) A.smn=min(A.smn,Y.mn);
		if(Y.mn<X.mn) A.smn=min(A.smn,X.mn);
		X.ck_mn(A.mn),Y.ck_mn(A.mn),A.sum=X.sum+Y.sum;
		A.ans=max({X.ans,Y.ans,X.suf+Y.pre});
		A.pre=max(X.pre,X.sum+Y.pre),A.suf=max(Y.suf,Y.sum+X.suf);
		A.Min=min({G(A.pre,X.sum+Y.pre),G(A.suf,Y.sum+X.suf)});
		A.Min=min({A.Min,G(A.ans,X.ans),G(A.ans,Y.ans),G(A.ans,X.suf+Y.pre)});
		A.Min=min({A.Min+A.mn,X.Min,Y.Min});
		return A;
	}
	void PUTTAG(int k,int V){
		s[k].sum.ADD(V-s[k].mn),s[k].ans.ADD(V-s[k].mn);
		s[k].pre.ADD(V-s[k].mn),s[k].suf.ADD(V-s[k].mn);
		s[k].mn=s[k].lazy=V;
	}
	void pushdown(int k,int l,int r){
		int mid=(l+r)/2;
		zkw(k*2,l,mid,s[k].lazy);
		zkw(k*2+1,mid+1,r,s[k].lazy); 
		s[k].lazy=-inf;
	}
	void zkw(int k,int l,int r,int V){
		if(s[k].mn>=V) return;
		if(s[k].smn>V&&V<s[k].Min){
			PUTTAG(k,V);
			return;
		}
		s[k].lazy=V,pushdown(k,l,r);
		s[k]=pushup(s[k*2],s[k*2+1]);
	}
	void build(int k,int l,int r){
		s[k].EMP();
		if(l==r){s[k].set(a[l]);return;}
		int mid=(l+r)>>1;
		build(k*2,l,mid); 
		build(k*2+1,mid+1,r);
		s[k]=pushup(s[k*2],s[k*2+1]);
	}
	void change(int k,int l,int r,int x,int y,int V){
		if(x<=l&&r<=y){
			if(s[k].mn>=V) return;
			if(s[k].smn>V&&V<s[k].Min){PUTTAG(k,V);return;}
		}
		if(r<x||y<l) return;
		int mid=(l+r)/2;
		pushdown(k,l,r);
		change(k*2,l,mid,x,y,V);
		change(k*2+1,mid+1,r,x,y,V);
		s[k]=pushup(s[k*2],s[k*2+1]);
	}
	Node ask(int k,int l,int r,int x,int y){
		if(x<=l&&r<=y) return s[k];
		int mid=(l+r)/2;
		pushdown(k,l,r);
		if(y<=mid) return ask(k*2,l,mid,x,y);
		if(x>=mid+1) return ask(k*2+1,mid+1,r,x,y);
		return pushup(ask(k*2,l,mid,x,y),ask(k*2+1,mid+1,r,x,y));
	}
}tr;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	tr.build(1,1,n);
	for(int i=1,op,x,y,z;i<=q;i++){
		cin>>op>>x>>y;
		if(!op){
			cin>>z;
			tr.change(1,1,n,x,y,z);
		}
		else{
			cout<<max(tr.ask(1,1,n,x,y).ans.v,0ll)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：NahX_ (赞：3)

根据小白逛公园的思想，区间 $[l,r]$ 维护 $lx,rx,mx$ 分别表示必须包含左或右端点的最大子段和，当前整个区间的最大子段和。

吉司机 + KTT，每个节点维护三个函数 $y=kx+b$ 分别为区间三种最大子段和。$k$ 为三种最大子段和所对子段包含区间最小值的数量。$b$ 为三种最大子段和当前的值，对于区间 $[l,r]$，每次修改相当于 $x$ 加 $d-mn$，其中 $mn$ 为区间最小值。$itr$ 要考虑三种最大子段和每一种的更新。

有一个需要注意，在取到最大子段和的前提下要使子段包含区间最小值数量尽量多 （斜率越大增长越快）。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
#define int long long
const int N=2e5+5;
const ll inf=2e18;ll a[N];
char *p1,*p2,buf[100000];
#define nc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read(){int x=0,f=1;char ch=nc();
    while(ch<48||ch>57){if(ch=='-')f=-1;ch=nc();}
    while(ch>=48&&ch<=57)x=x*10+ch-48,ch=nc();
   	return x*f;
}
struct node{int l,r,le,re,me,c;ll lx,rx,mx,s,itr,laz,mn,mn1;}tr[N<<1];
ll dv(ll x,ll y){return (y<=0?inf:(x+y-1)/y);}
ll get(ll x,ll y,ll lx,ll ly){return (x>y?dv(x-y,ly-lx):dv(y-x,lx-ly));}
struct mxd{ll l,r,m,s;};
void pushup(int u){ll itr;
	tr[u].mn=min(tr[u<<1].mn,tr[u<<1|1].mn),tr[u].c=0;
	if(tr[u].mn==tr[u<<1].mn)tr[u].c+=tr[u<<1].c;if(tr[u].mn==tr[u<<1|1].mn)tr[u].c+=tr[u<<1|1].c;
	if(tr[u<<1].mn^tr[u<<1|1].mn)tr[u].mn1=min(max(tr[u<<1].mn,tr[u<<1|1].mn),min(tr[u<<1].mn1,tr[u<<1|1].mn1));
	else tr[u].mn1=min(tr[u<<1].mn1,tr[u<<1|1].mn1);
	tr[u].itr=min(tr[u<<1].itr,tr[u<<1|1].itr);
	if(tr[u].itr<=0)tr[u].itr=inf;
	itr=get(tr[u<<1].lx,tr[u<<1].s+tr[u<<1|1].lx,(tr[u<<1].mn==tr[u].mn?tr[u<<1].le:0),(tr[u<<1].mn==tr[u].mn?tr[u<<1].c:0)+(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].le:0));
	if(itr<=0)itr=inf;tr[u].itr=min(tr[u].itr,itr);
	itr=get(tr[u<<1|1].rx,tr[u<<1|1].s+tr[u<<1].rx,(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].re:0),(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].c:0)+(tr[u<<1].mn==tr[u].mn?tr[u<<1].re:0));
	if(itr<=0)itr=inf;tr[u].itr=min(tr[u].itr,itr);
	itr=get(tr[u<<1].mx,tr[u<<1|1].mx,(tr[u<<1].mn==tr[u].mn?tr[u<<1].me:0),(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].me:0));
	if(itr<=0)itr=inf;tr[u].itr=min(tr[u].itr,itr);
	ll mx=max(tr[u<<1].mx,tr[u<<1|1].mx);int len=max((mx==tr[u<<1].mx?(tr[u].mn==tr[u<<1].mn?tr[u<<1].me:0):0),(mx==tr[u<<1|1].mx?(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].me:0):0));
	itr=get(mx,tr[u<<1].rx+tr[u<<1|1].lx,len,(tr[u<<1].mn==tr[u].mn?tr[u<<1].re:0)+(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].le:0));
	if(itr<=0)itr=inf;tr[u].itr=min(tr[u].itr,itr);
	tr[u].lx=max(tr[u<<1].lx,tr[u<<1].s+tr[u<<1|1].lx),
	tr[u].rx=max(tr[u<<1|1].rx,tr[u<<1|1].s+tr[u<<1].rx),
	tr[u].mx=max(max(tr[u<<1].mx,tr[u<<1|1].mx),tr[u<<1].rx+tr[u<<1|1].lx);
	tr[u].le=max((tr[u].lx==tr[u<<1].lx?(tr[u<<1].mn==tr[u].mn?tr[u<<1].le:0):0),
				(tr[u].lx==tr[u<<1].s+tr[u<<1|1].lx?(tr[u<<1].mn==tr[u].mn?tr[u<<1].c:0)+(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].le:0):0)),
	tr[u].re=max((tr[u].rx==tr[u<<1|1].rx?(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].re:0):0),
				(tr[u].rx==tr[u<<1|1].s+tr[u<<1].rx?(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].c:0)+(tr[u<<1].mn==tr[u].mn?tr[u<<1].re:0):0)),
	tr[u].me=max(max((tr[u].mx==tr[u<<1].mx?(tr[u<<1].mn==tr[u].mn?tr[u<<1].me:0):0),
				(tr[u].mx==tr[u<<1|1].mx?(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].me:0):0)),
				(tr[u].mx==tr[u<<1].rx+tr[u<<1|1].lx?(tr[u<<1].mn==tr[u].mn?tr[u<<1].re:0)+(tr[u<<1|1].mn==tr[u].mn?tr[u<<1|1].le:0):0));
	tr[u].s=tr[u<<1].s+tr[u<<1|1].s;
}
void pd(int u){
	ll d=max(tr[u].laz-tr[u<<1].mn,0ll),d1=max(tr[u].laz-tr[u<<1|1].mn,0ll);
	tr[u<<1].itr-=d,tr[u<<1|1].itr-=d1;
	tr[u<<1].mx+=d*tr[u<<1].me,tr[u<<1|1].mx+=d1*tr[u<<1|1].me,
	tr[u<<1].lx+=d*tr[u<<1].le,tr[u<<1|1].lx+=d1*tr[u<<1|1].le,
	tr[u<<1].rx+=d*tr[u<<1].re,tr[u<<1|1].rx+=d1*tr[u<<1|1].re,
	tr[u<<1].mn=max(tr[u<<1].mn,tr[u].laz),tr[u<<1|1].mn=max(tr[u<<1|1].mn,tr[u].laz),
	tr[u<<1].s+=tr[u<<1].c*d,tr[u<<1|1].s+=tr[u<<1|1].c*d1, 
	tr[u<<1].laz=max(tr[u<<1].laz,tr[u].laz),tr[u<<1|1].laz=max(tr[u<<1|1].laz,tr[u].laz),tr[u].laz=-inf;
}
void build(int u,int l,int r){tr[u]={l,r},tr[u].laz=-inf;
	if(l==r)return tr[u]={l,r,1,1,1,1,a[l],a[l],a[l],a[l],inf,-inf,a[l],inf},void();
	int mid=l+r>>1;build(u<<1,l,mid),build(u<<1|1,mid+1,r);pushup(u);
//	cout<<tr[u].l<<' '<<tr[u].r<<' '<<tr[u].lx<<' '<<tr[u].rx<<' '<<tr[u].mx<<' '<<tr[u].le<<' '<<tr[u].re<<' '<<tr[u].me<<' '<<tr[u].mn<<' '<<tr[u].mn1<<endl;
}
void rebuild(int u,int l,int r){
	if(l==r){ll d=max(a[l],tr[u].laz);
		return tr[u]={l,r,1,1,1,1,d,d,d,d,inf,tr[u].laz,d,inf},void();
	}if(tr[u].itr>0)return;int mid=l+r>>1;pd(u);rebuild(u<<1,l,mid),rebuild(u<<1|1,mid+1,r);pushup(u);
//	cout<<tr[u].l<<' '<<tr[u].r<<' '<<tr[u].lx<<' '<<tr[u].rx<<' '<<tr[u].mx<<' '<<tr[u].le<<' '<<tr[u].re<<' '<<tr[u].me<<' '<<tr[u].mn<<' '<<tr[u].mn1<<endl;
}
void add(int u,int l,int r,ll x){
	if(tr[u].l>=l&&tr[u].r<=r&&tr[u].mn<x&&tr[u].mn1>x){ll d=x-tr[u].mn;
		tr[u].s+=d*tr[u].c,tr[u].laz=max(tr[u].laz,x),tr[u].itr-=d,
		tr[u].mx+=tr[u].me*d,tr[u].lx+=tr[u].le*d,tr[u].rx+=tr[u].re*d,tr[u].mn=x;
		if(tr[u].itr<=0)rebuild(u,tr[u].l,tr[u].r);return;
//		cout<<tr[u].l<<' '<<tr[u].r<<' '<<tr[u].lx<<' '<<tr[u].rx<<' '<<tr[u].mx<<' '<<tr[u].le<<' '<<tr[u].re<<' '<<tr[u].me<<' '<<tr[u].mn<<' '<<tr[u].mn1<<endl;return;
	}
//	cout<<'*'<<tr[u].l<<' '<<tr[u].r<<' '<<tr[u].mn<<' '<<tr[u].mn1<<endl;
	int mid=tr[u].l+tr[u].r>>1;if(tr[u].l==tr[u].r||tr[u].mn>=x)return;pd(u);
	if(l<=mid)add(u<<1,l,r,x);if(r>mid)add(u<<1|1,l,r,x);pushup(u);
}
mxd query(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r)return mxd{tr[u].lx,tr[u].rx,tr[u].mx,tr[u].s};pd(u);
	int mid=tr[u].l+tr[u].r>>1;mxd lf={-inf,-inf,-inf,0},rt={-inf,-inf,-inf,0};
	if(l>mid)return query(u<<1|1,l,r);if(r<=mid)return query(u<<1,l,r);
	if(l<=mid)lf=query(u<<1,l,r);if(r>mid)rt=query(u<<1|1,l,r);
	return mxd{max(lf.l,lf.s+rt.l),max(rt.r,rt.s+lf.r),max(max(rt.m,lf.m),rt.l+lf.r),lf.s+rt.s};
}
signed main(){
//	freopen("tst.in","r",stdin);	
//	freopen("1.out","w",stdout);
//	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int n,q;n=read(),q=read();
	for(int i=1;i<=n;i++)a[i]=read();build(1,1,n);
	while(q--){int op,l,r,x;op=read(),l=read(),r=read();
		if(!op)x=read(),add(1,l,r,x);
		else printf("%lld\n",max(0ll,query(1,l,r).m));
	}
	return 0;
}
```

---

## 作者：Leasier (赞：3)

看到区间 chkmax，考虑吉司机线段树：

- 对线段树上每个点维护区间内最小值 $\min$ 和次小值 $\operatorname{cmin}$。
- 处理到一个被完整包含于修改的区间时，若 $\min \geq k$ 则直接返回，若 $k \geq \operatorname{cmin}$ 则继续递归处理。
- 现在我们只需要知道 $k \in (\min, \operatorname{cmin})$ 时如何处理。

考虑对线段树上每个点维护前缀和最大值、后缀和最大值和区间最大子段和各自以 $\min$ 为自变量的一次函数表示。

注意到 $k \in (\min, \operatorname{cmin})$ 时子树内每个点中上述三者的决策可能发生变化，考虑维护子树内决策变化点的 $\min$ 为 $t$，当 $k < t$ 则直接打标记，否则继续递归处理。

时间复杂度不会算，据称为与 [P5693 EI 的第六分块](https://www.luogu.com.cn/problem/P5693) 相同的 $O((n + m) \log^3 n)$。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>

using namespace std;

typedef long long ll;

typedef struct Linear_tag {
	int k;
	ll b;
	
	Linear_tag(){}
	
	Linear_tag(int k_, ll b_){
		k = k_;
		b = b_;
	}
	
	inline ll calc(ll x){
		return k * x + b;
	}
} Linear;

typedef struct {
	int l;
	int r;
	int tag;
	int min;
	int cmin;
	ll trans;
	Linear sum;
	Linear lmax[2];
	Linear rmax[2];
	Linear all_max[3];
} Node;

int a[100007];
Node tree[400007];

Linear operator +(const Linear a, const Linear b){
	return Linear(a.k + b.k, a.b + b.b);
}

inline Linear trans(Linear f, int x, int y){
	if (x > y){
		f.b += (ll)x * f.k;
		f.k = 0;
	}
	return f;
}

inline ll ceil(ll x, int y){
	if (x < 0) return -((-x) / y);
	if (x == 0) return 0;
	return (x - 1) / y + 1;
}

inline void do_release(ll &x, Linear f, Linear g, int limit){
	if (f.k < g.k){
		ll val = ceil(f.b - g.b + 1, g.k - f.k);
		if (val > limit && x > val) x = val;
	}
}

inline void release(Node &x){
	if (x.lmax[0].calc(x.min) < x.lmax[1].calc(x.min)) swap(x.lmax[0], x.lmax[1]);
	if (x.rmax[0].calc(x.min) < x.rmax[1].calc(x.min)) swap(x.rmax[0], x.rmax[1]);
	if (x.all_max[0].calc(x.min) < x.all_max[1].calc(x.min)) swap(x.all_max[0], x.all_max[1]);
	if (x.all_max[0].calc(x.min) < x.all_max[2].calc(x.min)) swap(x.all_max[0], x.all_max[2]);
	x.trans = 0x7fffffffffffffffll;
	do_release(x.trans, x.lmax[0], x.lmax[1], x.min);
	do_release(x.trans, x.rmax[0], x.rmax[1], x.min);
	do_release(x.trans, x.all_max[0], x.all_max[1], x.min);
	do_release(x.trans, x.all_max[0], x.all_max[2], x.min);
}

Node operator +(const Node a, const Node b){
	Node ans;
	ans.l = a.l;
	ans.r = b.r;
	ans.tag = 0x80000000;
	ans.min = min(a.min, b.min);
	ans.cmin = min(a.cmin, b.cmin);
	if (ans.min < a.min) ans.cmin = min(ans.cmin, a.min);
	if (ans.min < b.min) ans.cmin = min(ans.cmin, b.min);
	ans.sum = trans(a.sum, a.min, ans.min) + trans(b.sum, b.min, ans.min);
	ans.lmax[0] = trans(a.lmax[0], a.min, ans.min);
	ans.lmax[1] = trans(a.sum, a.min, ans.min) + trans(b.lmax[0], b.min, ans.min);
	ans.rmax[0] = trans(b.rmax[0], b.min, ans.min);
	ans.rmax[1] = trans(b.sum, b.min, ans.min) + trans(a.rmax[0], a.min, ans.min);
	ans.all_max[0] = trans(a.all_max[0], a.min, ans.min);
	ans.all_max[1] = trans(b.all_max[0], b.min, ans.min);
	ans.all_max[2] = trans(a.rmax[0], a.min, ans.min) + trans(b.lmax[0], b.min, ans.min);
	release(ans);
	ans.trans = min(ans.trans, min(a.trans, b.trans));
	return ans;
}

inline void update(int x){
	tree[x] = tree[x * 2] + tree[x * 2 + 1];
}

void build(int x, int l, int r){
	if (l == r){
		tree[x].l = tree[x].r = l;
		tree[x].tag = 0x80000000;
		tree[x].min = a[l];
		tree[x].cmin = 0x7fffffff;
		tree[x].sum = tree[x].lmax[0] = tree[x].rmax[0] = tree[x].all_max[0] = Linear(1, 0);
		tree[x].lmax[1] = tree[x].rmax[1] = tree[x].all_max[1] = Linear(0, 0);
		tree[x].all_max[2] = Linear(0, 0x8000000000000000ll);
		release(tree[x]);
		return;
	}
	int mid = (l + r) >> 1;
	build(x * 2, l, mid);
	build(x * 2 + 1, mid + 1, r);
	update(x);
}

inline void pushdown(int x){
	if (tree[x].tag != 0x80000000){
		int ls = x * 2, rs = x * 2 + 1;
		tree[ls].tag = max(tree[ls].tag, tree[x].tag);
		tree[ls].min = max(tree[ls].min, tree[x].tag);
		tree[rs].tag = max(tree[rs].tag, tree[x].tag);
		tree[rs].min = max(tree[rs].min, tree[x].tag);
		tree[x].tag = 0x80000000;
	}
}

void chkmax(int x, int l, int r, int k){
	if (tree[x].min >= k) return;
	if (l <= tree[x].l && tree[x].r <= r && k < tree[x].cmin && k < tree[x].trans){
		tree[x].tag = tree[x].min = k;
		return;
	}
	if (tree[x].l == tree[x].r){
		tree[x].min = k;
		release(tree[x]);
		return;
	}
	int mid = (tree[x].l + tree[x].r) >> 1;
	pushdown(x);
	if (l <= mid) chkmax(x * 2, l, r, k);
	if (r > mid) chkmax(x * 2 + 1, l, r, k);
	update(x);
}

Node query(int x, int l, int r){
	if (l <= tree[x].l && tree[x].r <= r) return tree[x];
	int mid = (tree[x].l + tree[x].r) >> 1;
	pushdown(x);
	if (r <= mid) return query(x * 2, l, r);
	if (l > mid) return query(x * 2 + 1, l, r);
	return query(x * 2, l, r) + query(x * 2 + 1, l, r);
}

int main(){
	int n, q;
	scanf("%d %d", &n, &q);
	for (register int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
	}
	build(1, 1, n);
	for (register int i = 1; i <= q; i++){
		int op, l, r;
		scanf("%d %d %d", &op, &l, &r);
		if (op == 0){
			int x;
			scanf("%d", &x);
			chkmax(1, l, r, x);
		} else {
			Node info = query(1, l, r);
			cout << info.all_max[0].calc(info.min) << endl;
		}
	}
	return 0;
}
```

---

## 作者：Idtwtei (赞：1)

> 维护一个长为 $n$ 的序列 $a$，支持区间取 $\max$，查询区间最大子段和。
>
> $1 \le n \le 10^5,1 \le q \le 2 \times 10^5,0 \le |a_i|,|x| \le 10^9$。

需要掌握 [吉司机线段树](https://idtwtei.github.io/notes/seg_beats/) 和 [KTT](https://idtwtei.github.io/notes/KTT/)。

单点修改维护最大子段和是简单的，线段树维护 $lm,rm,mx,sum$ 分别表示最大前缀和，最大后缀和，最大子段和，区间和。合并就是分讨一下。

区间取 $\max$，还维护一些复杂信息，考虑吉司机线段树，那么只需要考虑区间区间最小值整体加 $x$ 后信息的维护。

参考 [区间加区间最大子段和](https://www.luogu.com.cn/problem/P5693)，用一次函数表示 $lm,rm,mx,sum$，其中斜率为对应范围内最小值的个数，KTT 即可。

时间复杂度大概是 $O(n\log^3n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define pli pair<LINE,int>
#define MP make_pair
#define fir first
#define sec second
const int N=1e5+10,INF=1e18;
inline int chkmin(int &x,int y){ return y<x?x=y,1:0; }
#define gc getchar()
#define rd read()
inline int read(){
	int x=0,f=0; char c=gc;
	for(;c<'0'||c>'9';c=gc) f|=(c=='-');
	for(;c>='0'&&c<='9';c=gc) x=(x<<1)+(x<<3)+(c^48);
	return f?-x:x;
}

int n,m,a[N];

struct LINE{ int k,b; void add(int v){ b+=k*v; } };
inline LINE operator+(LINE x,LINE y){ return (LINE){x.k+y.k,x.b+y.b}; }
pli mer(LINE x,LINE y){
	if(x.k<y.k||(x.k==y.k&&x.b<y.b)) swap(x,y);
	return x.b>=y.b?MP(x,INF):MP(y,(y.b-x.b)/(x.k-y.k));
}
struct ADJ{
	LINE lm,rm,mx,sum; int mn,se,tim;
	void add(int v){ lm.add(v),rm.add(v),mx.add(v),sum.add(v),mn+=v,tim-=v; }
};
ADJ operator+(ADJ x,ADJ y){
	ADJ res; pli tmp;
	if(x.mn<y.mn) res.mn=x.mn,res.se=min(x.se,y.mn),res.tim=x.tim,y.lm.k=y.rm.k=y.mx.k=y.sum.k=0;
	else if(y.mn<x.mn) res.mn=y.mn,res.se=min(y.se,x.mn),res.tim=y.tim,x.lm.k=x.rm.k=x.mx.k=x.sum.k=0;
	else res.mn=x.mn,res.se=min(y.se,x.se),res.tim=min(x.tim,y.tim);
	res.sum=x.sum+y.sum;
	tmp=mer(x.lm,x.sum+y.lm),res.lm=tmp.fir,chkmin(res.tim,tmp.sec);
	tmp=mer(y.rm,y.sum+x.rm),res.rm=tmp.fir,chkmin(res.tim,tmp.sec);
	tmp=mer(x.mx,y.mx),chkmin(res.tim,tmp.sec);
	tmp=mer(tmp.fir,x.rm+y.lm),res.mx=tmp.fir,chkmin(res.tim,tmp.sec);
	return res;
};

struct SMT{
	#define lc (id<<1)
	#define rc (id<<1|1)
	#define mid (l+r>>1)
	ADJ t[N<<2];
	void psu(int id){ t[id]=t[lc]+t[rc]; }
	void add(int id,int v){ t[id].add(v); }
	void spd(int id){
		if(t[id].mn>t[lc].mn) add(lc,t[id].mn-t[lc].mn);
		if(t[id].mn>t[rc].mn) add(rc,t[id].mn-t[rc].mn);
	}
	void rbui(int id){ if(t[id].tim<0) spd(id),rbui(lc),rbui(rc),psu(id); }
	void bui(int id,int l,int r){
		if(l==r) return t[id]={{1,a[l]},{1,a[l]},{1,a[l]},{1,a[l]},a[l],INF,INF},void();
		bui(lc,l,mid),bui(rc,mid+1,r),psu(id);
	}
	void add(int id,int l,int r,int ql,int qr,int v){
		if(v<=t[id].mn) return; if(ql<=l&&r<=qr&&t[id].mn<v&&v<t[id].se) return add(id,v-t[id].mn),rbui(id); spd(id);
		if(ql<=mid) add(lc,l,mid,ql,qr,v);
		if(qr>mid) add(rc,mid+1,r,ql,qr,v);
		psu(id);
	}
	ADJ ask(int id,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr) return t[id]; spd(id);
		if(qr<=mid) return ask(lc,l,mid,ql,qr);
		if(ql>mid) return ask(rc,mid+1,r,ql,qr);
		return ask(lc,l,mid,ql,qr)+ask(rc,mid+1,r,ql,qr);
	}
	#undef lc
	#undef rc
	#undef mid
}S;

signed main(){

	n=rd,m=rd;
	for(int i=1;i<=n;++i) a[i]=rd;
	
	S.bui(1,1,n);
	for(int i=1,op,l,r,x;i<=m;++i){
		op=rd,l=rd,r=rd; if(op==0) x=rd;
		if(op==0) S.add(1,1,n,l,r,x);
		else printf("%lld\n", max(0ll,S.ask(1,1,n,l,r).mx.b));
	}

	cerr<<clock()<<"ms\n";

	return 0;
}
```

---

## 作者：_Yonder_ (赞：1)

有个地方写错了结果还能拿 $70$，调了半天直接蚌埠住了。

考虑吉司机线段树，那么难点在于打标记。

注意到标记的形式为：将最小值加上 $x$。

所以我们可以把 KTT 中的 $kx+b$ 的 $k$ 改成最小值的个数，那么这题就解决了。

这两种线段树的势能应该是不能累加的，所以时间复杂度 $O((n+m)\log^3n)$。

---

## 作者：xiao7_Mr_10_ (赞：0)

这个题实际上和 P5693 没什么两样。

对于操作一，显然我们可以用吉司机线段树维护最小值以及严格次小值。

然后修改时下传标记等价于**区间加上标记与最小值的差**，这样就把问题转化为了区间加一个正整数。

利用 KTT，我们维护以变化的数个数作为斜率的直线，也就是更改了原题定义。

我们同时使用吉司机线段树和 KTT 来完成维护过程，但是注意需要保证在合并节点的同时 KTT 需要考虑吉司机线段树的最小值，需要**清空**一下两者间较大值位置的信息，因为我们修改了定义，所以这里变化的数就清 $0$。

时间复杂度不会证明，但是想来应该也就是 $O((n+m)\log ^3 n)$ 级别。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+5,inf=1e18;
int n,a[N],m,l,r,op,x;
struct line{
	int k,b;
	line operator + (const line &x)const{return (line){k+x.k,b+x.b};}
	void set(){k=0;}
	void add(int x){b+=k*x;}
};
pair<line,int> max(line x,line y){
	if(x.k<y.k||(x.k==y.k&&x.b<y.b))swap(x,y);
	if(x.b>=y.b)return make_pair(x,inf);
	return make_pair(y,(y.b-x.b)/(x.k-y.k));
}
struct Point{
	line sum,ans1,lsum,rsum;int lim;
	Point operator + (const Point &x)const{
		Point ans;ans.sum=sum+x.sum;ans.lim=min(lim,x.lim);
		pair<line,int> lq=max(lsum,sum+x.lsum);
		ans.lsum=lq.first,ans.lim=min(ans.lim,lq.second);
		lq=max(x.rsum,rsum+x.sum);ans.rsum=lq.first,ans.lim=min(ans.lim,lq.second);
		lq=max(ans1,x.ans1);ans.lim=min(ans.lim,lq.second);
		lq=max(lq.first,rsum+x.lsum);ans.lim=min(ans.lim,lq.second);ans.ans1=lq.first;return ans;
	}Point set(){
		Point now=*this;
		now.sum.set();now.ans1.set();now.lsum.set();now.rsum.set();return now;
	}void add(int x){sum.add(x),lsum.add(x),rsum.add(x),ans1.add(x);}
};
struct tree{
	Point x;
	int minn,smin;
}c[N<<2];int tag[N<<2];
void updata(int x){
	c[x].minn=min(c[x<<1].minn,c[x<<1|1].minn);
	if(c[x<<1].minn==c[x<<1|1].minn)c[x].smin=min(c[x<<1].smin,c[x<<1|1].smin),c[x].x=c[x<<1].x+c[x<<1|1].x;
	else if(c[x<<1].minn>c[x<<1|1].minn)c[x].smin=min(c[x<<1].minn,c[x<<1|1].smin),c[x].x=c[x<<1].x.set()+c[x<<1|1].x;
	else c[x].smin=min(c[x<<1].smin,c[x<<1|1].minn),c[x].x=c[x<<1].x+c[x<<1|1].x.set();
}
void build(int x,int l,int r){
	tag[x]=-inf;
	if(l==r){line tmp=(line){1,a[l]};
		c[x].x=(Point){tmp,tmp,tmp,tmp,inf};
		c[x].minn=a[l],c[x].smin=inf;return;
	}int mid=(l+r)>>1;
	build(x<<1,l,mid);build(x<<1|1,mid+1,r);updata(x);
}
void xg(int x,int k){
	if(c[x].minn>=k)return;int val=k-c[x].minn;
	c[x].minn=k,tag[x]=max(tag[x],k);c[x].x.lim-=val;
	c[x].x.add(val);
}
void pushdown(int x,int l,int r,int k){tag[x]=max(tag[x],k);
	if(k-c[x].minn>c[x].x.lim){
		int mid=(l+r)>>1;
		pushdown(x<<1,l,mid,k);pushdown(x<<1|1,mid+1,r,k);updata(x);
	}else xg(x,k);
}void down(int x){
	if(tag[x]==-inf)return;
	xg(x<<1,tag[x]);xg(x<<1|1,tag[x]);tag[x]=-inf;
}
void change(int x,int l,int r,int s,int t,int k){
	if(c[x].minn>=k)return;
	if(l>=s&&r<=t&&c[x].smin>k){
		pushdown(x,l,r,k);
		return;
	}int mid=(l+r)>>1;down(x);
	if(s<=mid)change(x<<1,l,mid,s,t,k);
	if(t>mid)change(x<<1|1,mid+1,r,s,t,k);updata(x);
}
Point query(int x,int l,int r,int s,int t){
	if(l>=s&&r<=t)return c[x].x;int mid=(l+r)>>1;down(x);
	if(s>mid)return query(x<<1|1,mid+1,r,s,t);
	else{
		if(t<=mid)return query(x<<1,l,mid,s,t);
		return query(x<<1,l,mid,s,t)+query(x<<1|1,mid+1,r,s,t);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;i++)cin >> a[i];build(1,1,n);
	for(int i = 1;i <= m;i++){
		cin >> op >> l >> r;
		if(op==0)cin >> x,change(1,1,n,l,r,x);
		else cout << max(0ll,query(1,1,n,l,r).ans1.b) << "\n";
	}
	return 0;
}

```

---


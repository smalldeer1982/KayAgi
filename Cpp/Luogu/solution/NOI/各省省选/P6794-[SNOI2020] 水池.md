# [SNOI2020] 水池

## 题目描述

有一个长条形的水池，可以划分成 $n$ 格。其中第 $i$ 格和 $i+1$ 格之间相邻，由一块高度为 $h_i$ 的可调节挡板隔开。第 $1$ 格左侧和第 $n$ 格右侧是无限高的池壁。初始时水池中没有水。现在进行 $q$ 次操作，操作有以下四种：

- `0 i x h` 在第 $x$ 格灌水直到该格的水面高度不低于 $h$（若当前水面高度已经达到 $h$ 则无事发生）；
- `1 i x` 打开第 $x$ 格底部的排水口直到该格的水流干，再关闭排水口；
- `2 i x h` 将第 $x$ 格右侧的挡板高度增加到 $h$（不改变现有水面，保证挡板高度不会下降）；
- `3 i x` 查询第 $x$ 格的水面高度。

其中，$i$ 表示这次操作是基于第 $i$ 次操作之后的情况，$i=0$ 表示基于初始状态。也就是说，这个问题要求对操作可持久化。

## 说明/提示

#### 样例说明

对于样例 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/0zot45nm.png)

#### 数据规模与约定

对于所有数据，$1\le n,q\le 2\times 10^5, 0\le h_i\le 10^9$。

- 对于 $10\%$ 的数据，$n \le 500$；
- 对于另外 $20\%$，没有操作 $1$，且 $i$ 从 $0$ 开始连续增长（不需要可持久化）；
-  对于另外 $20\%$，没有操作 $1$；
- 对于另外 $20\%$，且 $i$ 从 $0$ 开始连续增长（不需要可持久化）；
- 对于余下 $30\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
4 9
1 3 2
0 0 4 2
3 1 1
0 2 4 3
3 3 1
0 4 4 4
3 5 1
2 6 1 4
1 7 4
3 8 1```

### 输出

```
0
0
4
4```

# 题解

## 作者：modfish_ (赞：5)

## 思路
考虑灌水和放水分别代表着什么操作。

为了方便起见，我们把每个水池和挡板都看成一个元素，于是我们需要维护一个长为 $2n+1$ 的序列，它的奇数位是挡板，偶数位是水池。对每个偶数位维护 $a_{2i}$ 表示第 $i$ 个水池当前的高度，$h_{2i+1}$ 表示第 $i$ 个水池之后的挡板高度。特别地，$h_1=h_{2n+1}=\infty$。

---

### 灌水
显然，若要将第 $x$ 格水池灌到高度 $h$，需要找到最大的 $l<2x$ 和最小的 $r>2x$，满足 $h_l\ge h,h_r\ge h$，然后把 $l$ 和 $r$ 之间的水池的高度全部升到 $h$。

形式化地，对于 $\forall l<i<r, 2\mid i$ 进行操作 $a_i\leftarrow \max(a_i,h)$。

--- 

### 放水
若要将第 $x$ 格水池的水放空，$x$ 左边所有水池的水面都会降至其右边的最高的挡板的高度，右边的则会降至其左边的最高的挡板的高度。

形式化地，对于 $\forall 1\le i\le x,2\mid x$，进行操作 $a_i\leftarrow \min(a_i,\displaystyle\max_{i<j<x,2\nmid j}h_j)$。

---

那么如何实现这些操作呢？

考虑使用线段树维护这个长为 $2n+1$ 的序列。每个节点记录信息 $hmax_x$，表示这个区间内挡板的最大高度；以及 $mtag_x,ltag_x,rtag_x$，表示标记。具体地：

- $mtag_x$ 表示对 $x$ 所代表区间内所有水池的水面都抬高到 $mtag_x$ 高度。

- $ltag_x$ 表示对 $x$ 所代表区间内所有水池的水面，都降低至 $\max(ltag_x,suf)$ 高度。其中 $suf$ 表示该区间内某个水池在这个区间内对应后缀中最高的挡板高度。

- $rtag_x$ 同理，表示对 $x$ 所代表区间内所有水池的水面，都降低至 $\max(rtag_x,pre)$ 高度。其中 $pre$ 表示该区间内某个水池在这个区间内对应前缀中最高的挡板高度。

另外，对标记代表操作的执行顺序是：先执行 $mtag_x$，再执行 $ltag_x$ 和 $rtag_x$。

标记的下传是较为容易的：

- 对于 $mtag_{lc}$ 和 $mtag_{rc}$，直接和 $mtag_x$ 取 $\max$。

- 对于 $ltag_{lc}$ 和 $ltag_{rc}$，先和 $mtag_x$ 取 $\max$，然后 $ltag_{rc}$ 和 $ltag_x$ 取 $\min$，而 $ltag_{lc}$ 和 $\max(ltag_x,hmax_{rc})$ 取 $\min$。

- 对于 $rtag_{lc}$ 和 $rtag_{rc}$，和 $ltag$ 类似，可以自己推一下。

修改直接打标记（灌水要先线段树二分确定要修改的区间）即可。查询时，某个水池的高度即为 $\min(ltag,rtag,mtag)$。

至于可持久化，改用主席树即可。时间复杂度、空间复杂度均为 $O(q\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 4e5 + 5;

int n, q;
int h[maxn];
namespace seg{
int lc[maxn * 100], rc[maxn * 100], hmax[maxn * 100], tot = 0;
int ltag[maxn * 100], rtag[maxn * 100], mtag[maxn * 100];
int create(int pr){
    tot ++, lc[tot] = lc[pr], rc[tot] = rc[pr], hmax[tot] = hmax[pr], ltag[tot] = ltag[pr], rtag[tot] = rtag[pr], mtag[tot] = mtag[pr];
    return tot;
}
void up(int x){
    hmax[x] = max(hmax[lc[x]], hmax[rc[x]]);
}
void down(int x){
    lc[x] = create(lc[x]), rc[x] = create(rc[x]);
    ltag[lc[x]] = max(ltag[lc[x]], mtag[x]), ltag[rc[x]] = max(ltag[rc[x]], mtag[x]);
    ltag[lc[x]] = min(ltag[lc[x]], max(ltag[x], hmax[rc[x]])), ltag[rc[x]] = min(ltag[rc[x]], ltag[x]);
    rtag[lc[x]] = max(rtag[lc[x]], mtag[x]), rtag[rc[x]] = max(rtag[rc[x]], mtag[x]);
    rtag[lc[x]] = min(rtag[lc[x]], rtag[x]), rtag[rc[x]] = min(rtag[rc[x]], max(rtag[x], hmax[lc[x]]));
    mtag[lc[x]] = max(mtag[lc[x]], mtag[x]), mtag[rc[x]] = max(mtag[rc[x]], mtag[x]);
    mtag[x] = 0, ltag[x] = rtag[x] = 1e9 + 100;
}
void build(int &x, int l, int r){
    x = create(0);
    if(l == r){
        if(l & 1){
            if(l == 1 || l == n * 2 + 1) hmax[x] = 1e9 + 100;
            else hmax[x] = h[l / 2];
        }
        return;
    }
    int mid = l + r >> 1;
    build(lc[x], l, mid), build(rc[x], mid + 1, r);
    up(x);
}
int findL(int x, int l, int r, int Q, int h){
    if(l == r){
        if(hmax[x] >= h) return l;
        else return 0;
    }
    if(r <= Q){
        if(hmax[x] < h) return 0;
        int mid = l + r >> 1;
        if(hmax[rc[x]] >= h) return findL(rc[x], mid + 1, r, Q, h);
        else return findL(lc[x], l, mid, Q, h);
    }
    int mid = l + r >> 1;
    if(Q <= mid) return findL(lc[x], l, mid, Q, h);
    else{
        int res = findL(rc[x], mid + 1, r, Q, h);
        if(res) return res;
        return findL(lc[x], l, mid, Q, h);
    }
}
int findR(int x, int l, int r, int Q, int h){
    if(l == r){
        if(hmax[x] >= h) return l;
        else return 0;
    }
    if(l >= Q){
        if(hmax[x] < h) return 0;
        int mid = l + r >> 1;
        if(hmax[lc[x]] >= h) return findR(lc[x], l, mid, Q, h);
        else return findR(rc[x], mid + 1, r, Q, h);
    }
    int mid = l + r >> 1;
    if(Q > mid) return findR(rc[x], mid + 1, r, Q, h);
    else{
        int res = findR(lc[x], l, mid, Q, h);
        if(res) return res;
        return findR(rc[x], mid + 1, r, Q, h);
    }
}
void water(int &x, int pr, int l, int r, int ql, int qr, int k){
    if(x == pr) x = create(pr);
    if(ql <= l && r <= qr){
        ltag[x] = max(ltag[x], k), rtag[x] = max(rtag[x], k), mtag[x] = max(mtag[x], k);
        return;
    }
    down(x);
    int mid = l + r >> 1;
    if(ql <= mid) water(lc[x], lc[pr], l, mid, ql, qr, k);
    if(qr > mid) water(rc[x], rc[pr], mid + 1, r, ql, qr, k);
}
int drainL(int &x, int pr, int l, int r, int Q, int rmax){
    if(x == pr) x = create(pr);
    if(r <= Q){
        ltag[x] = min(ltag[x], rmax);
        return max(rmax, hmax[x]);
    }
    down(x);
    int mid = l + r >> 1;
    if(Q <= mid) return drainL(lc[x], lc[pr], l, mid, Q, rmax);
    else return drainL(lc[x], lc[pr], l, mid, Q, drainL(rc[x], rc[pr], mid + 1, r, Q, rmax));
}
int drainR(int &x, int pr, int l, int r, int Q, int lmax){
    if(x == pr) x = create(pr);
    if(l >= Q){
        rtag[x] = min(rtag[x], lmax);
        return max(lmax, hmax[x]);
    }
    down(x);
    int mid = l + r >> 1;
    if(Q > mid) return drainR(rc[x], rc[pr], mid + 1, r, Q, lmax);
    else return drainR(rc[x], rc[pr], mid + 1, r, Q, drainR(lc[x], lc[pr], l, mid, Q, lmax));
}
void update(int &x, int pr, int l, int r, int id, int H){
    if(x == pr) x = create(pr);
    if(l == r){
        hmax[x] = H;
        return;
    }
    down(x);
    int mid = l + r >> 1;
    if(id <= mid) update(lc[x], lc[pr], l, mid, id, H);
    else update(rc[x], rc[pr], mid + 1, r, id, H);
    up(x);
}
int query(int &x, int pr, int l, int r, int id){
    if(x == pr) x = create(pr);
    if(l == r) return min(min(mtag[x], ltag[x]), rtag[x]);
    down(x);
    int mid = l + r >> 1;
    if(id <= mid) return query(lc[x], lc[pr], l, mid, id);
    else return query(rc[x], rc[pr], mid + 1, r, id);
}}
int rt[maxn];

int main(){
    scanf("%d %d", &n, &q);
    for(int i = 1; i < n; i ++) scanf("%d", &h[i]);
    seg::ltag[0] = seg::rtag[0] = 1e9 + 100;
    seg::build(rt[0], 1, n * 2 + 1);
    for(int j = 1; j <= q; j ++){
        int op, i, x, H;
        scanf("%d %d %d", &op, &i, &x);
        rt[j] = rt[i];
        if(op == 0){
            scanf("%d", &H);
            int l = seg::findL(rt[i], 1, n * 2 + 1, x * 2, H), r = seg::findR(rt[i], 1, n * 2 + 1, x * 2, H);
            seg::water(rt[j], rt[i], 1, n * 2 + 1, l + 1, r - 1, H);
        }else if(op == 1){
            seg::drainL(rt[j], rt[j], 1, n * 2 + 1, x * 2, 0), seg::drainR(rt[j], rt[j], 1, n * 2 + 1, x * 2, 0);
        }else if(op == 2){
            scanf("%d", &H);
            seg::update(rt[j], rt[i], 1, n * 2 + 1, x * 2 + 1, H);
        }else{
            printf("%d\n", seg::query(rt[j], rt[i], 1, n * 2 + 1, x * 2));
        }
    }
    return 0;
}
```

---

## 作者：bluewindde (赞：3)

好厉害的题。

为了方便，规定新的 $h_i$ 是原来的 $h_{i - 1}$，$h_1 = h_{n + 1} = +\infty$，然后令 $n \leftarrow n + 1$。设 $a_i$ 表示第 $i$ 格的水深。

对于灌水操作，二分找到 $x$ 左边第一个满足 $h_l \geqslant h$ 的位置 $l$，$x$ 右边第一个满足 $h_{r-1} \geqslant h$ 的位置 $r$，区间 $[l, r]$ 的 $a_i$ 对 $h$ 取最大值即可。

考虑排水操作，若 $i \leqslant x$，则 $a_i = \min(a_i, \max\limits_{i < j \leqslant x}(h_j))$，称为一次 $i$ 的右侧排水，权值为 $\max\limits_{i \leqslant j < x}(h_j)$；$i > x$ 是对称的，称为一次 $i$ 的左侧排水。

可持久化线段树维护除掉最左侧挡板外的最大挡板高度 $\text h$、除掉最右侧挡板外的最大挡板高度 $\text{rh}$，维护灌水标记 $\text{fd}$（flood）、左侧排水标记 $\text{ld}$（left side drain）、右侧排水标记 $\text{rd}$（right side drain）。灌水标记可以覆盖其他标记。两种排水标记表示对区间执行对应排水操作的权值。

设当前节点为 $\text p$，下放标记：

- 左儿子的左侧排水标记 $\text{p.ls.ld} = \min(\max(\text{p.ls.ld}, \text{p.fd}), \text{p.ld})$；
- 右儿子的左侧排水标记 $\text{p.rs.ld} = \min(\max(\text{p.rs.ld}, \text{p.fd}), \min(\text{p.ld}, \text{p.ls.rh}))$，向右儿子传递的左侧标记要包含左儿子的区间；
- 右侧排水标记同理；
- 灌水标记直接取最大值即可；
- 标记清空 $\text{p.fd} = 0, \text{p.ld} = \text{p.rd} = +\infty$。

最终格子的高度为 $\min(\text{p.fd}, \text{p.ld}, \text{p.rd})$。

信息合并是容易的，增加挡板高度和查询也是容易的。时间复杂度 $O(q \log n)$。

```cpp
#include <iostream>

using namespace std;

const int inf = 2e9;

int n, q;
int h[200005];

int rt[200005], cnt;
struct node {
    int ls, rs, h, rh, fd, ld, rd;
} d[40000005];
static inline int clone(int p) {
    d[++cnt] = d[p];
    return cnt;
}
static inline void pushup(int p) {
    d[p].h = max(d[d[p].ls].h, d[d[p].rs].h);
    d[p].rh = max(d[d[p].ls].rh, d[d[p].rs].rh);
}
static inline void pushdown(int p) {
    d[p].ls = clone(d[p].ls);
    d[p].rs = clone(d[p].rs);
    d[d[p].ls].ld = min(max(d[d[p].ls].ld, d[p].fd), d[p].ld);
    d[d[p].rs].ld = min(max(d[d[p].rs].ld, d[p].fd), max(d[p].ld, d[d[p].ls].rh));
    d[d[p].ls].rd = min(max(d[d[p].ls].rd, d[p].fd), max(d[p].rd, d[d[p].rs].h));
    d[d[p].rs].rd = min(max(d[d[p].rs].rd, d[p].fd), d[p].rd);
    d[d[p].ls].fd = max(d[d[p].ls].fd, d[p].fd);
    d[d[p].rs].fd = max(d[d[p].rs].fd, d[p].fd);
    d[p].fd = -inf;
    d[p].ld = d[p].rd = inf;
}
static inline int build(int s, int t) {
    int p = ++cnt;
    d[p].fd = -inf;
    d[p].ld = d[p].rd = inf;
    if (s == t) {
        d[p].h = h[s];
        d[p].rh = h[s + 1];
        d[p].fd = 0;
        return p;
    }
    int mid = (s + t) >> 1;
    d[p].ls = build(s, mid);
    d[p].rs = build(mid + 1, t);
    pushup(p);
    return p;
}
static inline int query1(int x, int s, int t, int c, int p) {
    if (s == t)
        return d[p].h >= c ? s : 0;
    int mid = (s + t) >> 1;
    if (x <= mid)
        return query1(x, s, mid, c, d[p].ls);
    if (t <= x) {
        if (d[d[p].rs].h >= c)
            return query1(x, mid + 1, t, c, d[p].rs);
        return query1(x, s, mid, c, d[p].ls);
    }
    int ret = query1(x, mid + 1, t, c, d[p].rs);
    if (!ret)
        ret = query1(x, s, mid, c, d[p].ls);
    return ret;
}
static inline int query2(int x, int s, int t, int c, int p) {
    if (s == t)
        return d[p].h >= c ? s : 0;
    int mid = (s + t) >> 1;
    if (x > mid)
        return query2(x, mid + 1, t, c, d[p].rs);
    if (s >= x) {
        if (d[d[p].ls].h >= c)
            return query2(x, s, mid, c, d[p].ls);
        return query2(x, mid + 1, t, c, d[p].rs);
    }
    int ret = query2(x, s, mid, c, d[p].ls);
    if (!ret)
        ret = query2(x, mid + 1, t, c, d[p].rs);
    return ret;
}
static inline void flood(int l, int r, int s, int t, int c, int p) {
    if (l <= s && r >= t) {
        d[p].fd = max(d[p].fd, c);
        d[p].ld = max(d[p].ld, c);
        d[p].rd = max(d[p].rd, c);
        return;
    }
    int mid = (s + t) >> 1;
    pushdown(p);
    if (l <= mid)
        flood(l, r, s, mid, c, d[p].ls);
    if (r > mid)
        flood(l, r, mid + 1, t, c, d[p].rs);
}
static inline int drain1(int x, int s, int t, int c, int p) {
    if (x >= t) {
        d[p].rd = min(d[p].rd, c);
        return max(c, d[p].h);
    }
    int mid = (s + t) >> 1;
    pushdown(p);
    if (x <= mid)
        return drain1(x, s, mid, c, d[p].ls);
    return drain1(x, s, mid, drain1(x, mid + 1, t, c, d[p].rs), d[p].ls);
}
static inline int drain2(int x, int s, int t, int c, int p) {
    if (x <= s) {
        d[p].ld = min(d[p].ld, c);
        return max(c, d[p].rh);
    }
    int mid = (s + t) >> 1;
    pushdown(p);
    if (x > mid)
        return drain2(x, mid + 1, t, c, d[p].rs);
    return drain2(x, mid + 1, t, drain2(x, s, mid, c, d[p].ls), d[p].rs);
}
static inline void update(int x, int s, int t, int c, int p) {
    if (s == t) {
        d[p].h = c;
        return;
    }
    int mid = (s + t) >> 1;
    pushdown(p);
    if (x <= mid)
        update(x, s, mid, c, d[p].ls);
    else
        update(x, mid + 1, t, c, d[p].rs);
    pushup(p);
}
static inline void updaterh(int x, int s, int t, int c, int p) {
    if (s == t) {
        d[p].rh = c;
        return;
    }
    int mid = (s + t) >> 1;
    pushdown(p);
    if (x <= mid)
        updaterh(x, s, mid, c, d[p].ls);
    else
        updaterh(x, mid + 1, t, c, d[p].rs);
    pushup(p);
}
static inline int query(int x, int s, int t, int p) {
    if (s == t)
        return min(d[p].fd, min(d[p].ld, d[p].rd));
    int mid = (s + t) >> 1;
    pushdown(p);
    if (x <= mid)
        return query(x, s, mid, d[p].ls);
    return query(x, mid + 1, t, d[p].rs);
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> q;
    for (int i = 2; i <= n; ++i)
        cin >> h[i];
    h[1] = h[++n] = inf;
    rt[0] = build(1, n);
    for (int i = 1; i <= q; ++i) {
        int op, old, x;
        cin >> op >> old >> x;
        rt[i] = clone(rt[old]);
        if (op == 0) {
            int h;
            cin >> h;
            int l = query1(x, 1, n, h, rt[i]);
            int r = query2(x + 1, 1, n, h, rt[i]) - 1;
            flood(l, r, 1, n, h, rt[i]);
        } else if (op == 1) {
            drain1(x, 1, n, 0, rt[i]);
            drain2(x, 1, n, 0, rt[i]);
        } else if (op == 2) {
            int h;
            cin >> h;
            update(x + 1, 1, n, h, rt[i]);
            updaterh(x, 1, n, h, rt[i]);
        } else if (op == 3)
            cout << query(x, 1, n, rt[i]) << '\n';
    }
    return 0;
}
```

---

## 作者：Tony2 (赞：3)

记录一下 $128\text{MB}$ 以内的做法。

灌水操作相当于向左向右找到第一个 $\ge h$ 的隔板，中间的水面高度全部设为 $h$，操作前提是灌水位置原高度 $<h$。

抽水操作需要先确定影响范围。设 $y$ 为抽水位置 $x$ 原本的高度，向左向右找到第一个 $\ge y$ 的隔板，中间的区域都会被影响。影响后位置 $p\in [l,r]$ 的水面高度会降低至 $p$ 到 $x$ 之间的最高的隔板。

剩下两个操作是单点修和单点改。

比较恶心的是抽水操作，如果想卡空间这里的标记不能下传，需要巧妙设计。记录操作时间之后直接记录抽水位置 $x$，避免直接维护水面高度，只在单点查询水面高度时利用可持久化线段树查询。

因为上述的所有标记都为直接赋值，所以标记的优先级就是时间。

分析常数，单点修改都是一个 $\log$，区间加标记需要 $2\log$，时间、标记种类、标记值需要 $12\text{byte}$，可以进一步把种类压到时间上变成 $8\text{byte}$。每个线段树节点加上左右儿子需要 $16\text{byte}$，维护隔板高度的线段树需要 $12\text{byte}$，动态空间已经在 $128\text{MB}$ 以内。可以让两个线段树共用内存池使得静态空间也在 $128\text{MB}$ 内（代码未实现）。

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N = 2e5 + 5, inf = 2e9;
int n, q;
int h[N], rt1[N], rt2[N];
struct tree1{
#define mid ((l + r) >> 1)
	int tot;
	struct node{
		int ls, rs, mx;
	}a[N * 20];
	void build(int &p, int l, int r){
		p = ++tot;
		if (l == r){
			a[p].mx = h[l];
			return;
		}
		build(a[p].ls, l, mid);
		build(a[p].rs, mid + 1, r);
		a[p].mx = max(a[a[p].ls].mx, a[a[p].rs].mx);
	}
	void add(int &p, int l, int r, int s, int k){
		a[++tot] = a[p];
		p = tot;
		if (l == r) return a[p].mx = k, void();
		if (s <= mid) add(a[p].ls, l, mid, s, k);
		else add(a[p].rs, mid + 1, r, s, k);
		a[p].mx = max(a[a[p].ls].mx, a[a[p].rs].mx);
	}
	int ask(int p, int l, int r, int s, int t){
		if (s <= l && r <= t) return a[p].mx;
		int res = 0;
		if (s <= mid) res = max(ask(a[p].ls, l, mid, s, t), res);
		if (t > mid) res = max(ask(a[p].rs, mid + 1, r, s, t), res);
		return res;
	}
	int ask1(int p, int l, int r, int s, int k){
		if (r <= s){
			if (a[p].mx < k) return 0;
			else if (l == r) return l;
			else if (a[a[p].rs].mx >= k) return ask1(a[p].rs, mid + 1, r, s, k);
			else return ask1(a[p].ls, l, mid, s, k);
		}
		int res = 0;
		if (mid < s) res = ask1(a[p].rs, mid + 1, r, s, k);
		if (res) return res;
		else return ask1(a[p].ls, l, mid, s, k);
	}
	int ask2(int p, int l, int r, int s, int k){
		if (s <= l){
			if (a[p].mx < k) return n;
			else if (l == r) return r;
			else if (a[a[p].ls].mx >= k) return ask2(a[p].ls, l, mid, s, k);
			else return ask2(a[p].rs, mid + 1, r, s, k);
		}
		int res = n;
		if (s <= mid) res = ask2(a[p].ls, l, mid, s, k);
		if (res < n) return res;
		else return ask2(a[p].rs, mid + 1, r, s, k);
	}
}T1;
struct tree2{
	int tot;
	struct node{
		int ls, rs;
		int t, tag;//t = t >> 2, type = t & 3
	}a[N * 36];
	void add(int &p, int l, int r, int s, int t, int _t, int _tag){
		a[++tot] = a[p];
		p = tot;
		if (s <= l && r <= t){
			a[p].t = _t, a[p].tag = _tag;
			return;
		}
		if (s <= mid) add(a[p].ls, l, mid, s, t, _t, _tag);
		if (t > mid) add(a[p].rs, mid + 1, r, s, t, _t, _tag);
	}
	pair<int, int> ask(int p, int l, int r, int s){
		pair<int, int> res(a[p].t, a[p].tag);
		if (l == r) return res;
		if (s <= mid) res = max(ask(a[p].ls, l, mid, s), res);
		else res = max(ask(a[p].rs, mid + 1, r, s), res);
		return res;
	}
#undef mid
}T2;
int aska(int i, int x){
	pair<int, int> res = T2.ask(rt2[i], 0, n, x);
	int t = res.first, p = res.second;
	if (!t) return 0;
	else if ((t & 3) == 1) return p;
	else if (x == p) return 0;
	else if (x < p) return T1.ask(rt1[t >> 2], 0, n, x, p - 1);
	else return T1.ask(rt1[t >> 2], 0, n, p, x - 1);
}
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	cin >> n >> q;
	h[0] = h[n] = inf;
	for (int i = 1; i < n; i++)
		cin >> h[i];
	T1.build(rt1[0], 0, n);
	for (int i = 1; i <= q; i++){
		int opt, t, x;
		cin >> opt >> t >> x;
		rt1[i] = rt1[t], rt2[i] = rt2[t];
		if (opt == 0){
			int y;
			cin >> y;
			if (aska(i, x) < y){
				int l = T1.ask1(rt1[i], 0, n, x - 1, y), r = T1.ask2(rt1[i], 0, n, x, y);
				T2.add(rt2[i], 0, n, l + 1, r, (i << 2) | 1, y);
			}
		}else if (opt == 1){
			int y = aska(i, x);
			int l = T1.ask1(rt1[i], 0, n, x - 1, y), r = T1.ask2(rt1[i], 0, n, x, y);
			T2.add(rt2[i], 0, n, l + 1, r, (i << 2) | 2, x);
		}else if (opt == 2){
			cin >> h[x];
			T1.add(rt1[i], 0, n, x, h[x]);
		}else cout << aska(i, x) << endl;
	}
	return 0;
}
```

---

## 作者：流水行船CCD (赞：3)

提供一种分块做法。

注意到 $0$ 操作就是给从 $x$ 左边第一个高度大于 $h$ 挡板到 $x$ 右边第一个高度小于 $h$ 的挡板中间的水池高度赋值为 $h$。区间赋值，分块可以直接维护。

而 $1$ 操作就是把每一个水池的高度和它到 $x$ 水池中间最高挡板高度 chkmin。

注意到 $1$ 操作是一个类似单调栈的结构，考虑分块去维护。

给每一个块打一个 $lchk,rchk$ 标记，表示这个块的左侧/右侧有排水操作的影响需要更新，记录这些排水操作的排水点到当前块的边界最高挡板的高度最小值。

那么 $1$ 操作的时候只需要把排水点所在块暴力修改，其他块直接打标记。

修改挡板高度时直接把对应块重构。查询一个点水深的时候直接把它所在的块标记下放，就可以查到正确值。

至于可持久化，由于本题可以离线，使用操作树+回滚可以维护，注意尽量节约使用空间，没必要放入回滚栈中的元素就不要放。

$\mathcal{O}(q\sqrt{n})$。

## code

为了图方便，实现的比较丑陋（比如找赋值区间使用线段树外二分）。

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
#define ld cin
#define jyt cout
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
#define clr(name, n) memset(name, 0, ((n) + 1) * sizeof(name[0]))
#define mem(name, v, n) memset(name, v, ((n) + 1) * sizeof(name[0]))
const int N = 2e5 + 7, B = 450;
const int inf = 1e9 + 7;
const int P = 998244353;
namespace JoKing { // JoKing 10:56 60~70pts
	int n, W, q, a[N], h[N], lmx[N], rmx[N], bel[N], L[N], R[N], tage[N], lchk[N], rchk[N];
	vector<int> G[N]; pair<int*, int> stc[50000000]; int Ans[N], top = 0;
	struct Opera {int op, id, x, h;} c[N];
	struct Node {
		int lc, rc, mx;
#define ls(x) tr[x].lc
#define rs(x) tr[x].rc
	} tr[N * 30]; int Rt[N], Trc = 0;
	inline void blt(int &x, int l, int r) {
		if (x = ++Trc, l == r) return void(tr[x].mx = h[l]);
		int mid = (l + r) >> 1;
		blt(ls(x), l, mid), blt(rs(x), mid + 1, r), tr[x].mx = max(tr[ls(x)].mx, tr[rs(x)].mx);
	}
	inline void upd(int &x, int l, int r, int now, int c) {
		if (tr[++Trc] = tr[x], x = Trc, l == r) return void(tr[x].mx = c);
		int mid = (l + r) >> 1;
		(now <= mid ? upd(ls(x), l, mid, now, c) : upd(rs(x), mid + 1, r, now, c)), tr[x].mx = max(tr[ls(x)].mx, tr[rs(x)].mx);
 	}
 	inline int ask(int x, int l, int r, int L, int R) {
		if (L <= l && r <= R) return tr[x].mx;
		int mid = (l + r) >> 1, c = -1;
		if (L <= mid) c = max(c, ask(ls(x), l, mid, L, R));
		if (mid < R) c = max(c, ask(rs(x), mid + 1, r, L, R));
		return c;
	}
	inline void pushtag(int Biden) {
		if (tage[Biden] != -1 || lchk[Biden] != -1 || rchk[Biden] != -1) REP(i, L[Biden], R[Biden]) stc[++top] = {&a[i], a[i]};
		if (tage[Biden] != -1) {REP(i, L[Biden], R[Biden]) a[i] = tage[Biden]; stc[++top] = {&tage[Biden], tage[Biden]}; tage[Biden] = -1;}
		if (lchk[Biden] != -1) {REP(i, L[Biden], R[Biden]) a[i] = min(a[i], max(lchk[Biden], lmx[i])); stc[++top] = {&lchk[Biden], lchk[Biden]}; lchk[Biden] = -1;}
		if (rchk[Biden] != -1) {REP(i, L[Biden], R[Biden]) a[i] = min(a[i], max(rchk[Biden], rmx[i])); stc[++top] = {&rchk[Biden], rchk[Biden]}; rchk[Biden] = -1;}
	}
	inline void rebuild(int Biden) {
		if (lmx[L[Biden]] != 0) stc[++top] = {&lmx[L[Biden]], lmx[L[Biden]]};
		lmx[L[Biden]] = 0;
		REP(i, L[Biden] + 1, R[Biden]) {
			if (lmx[i] != max(lmx[i - 1], h[i - 1])) stc[++top] = {&lmx[i], lmx[i]};
			lmx[i] = max(lmx[i - 1], h[i - 1]);
		}
		if (rmx[R[Biden]] != h[R[Biden]]) stc[++top] = {&rmx[R[Biden]], rmx[R[Biden]]};
		rmx[R[Biden]] = h[R[Biden]];
		PER(i, R[Biden] - 1, L[Biden]) {
			if (rmx[i] != max(rmx[i + 1], h[i])) stc[++top] = {&rmx[i], rmx[i]};
			rmx[i] = max(rmx[i + 1], h[i]);
		}
	}
	inline int findl(int Rt, int now, int c) {
		int L = 1, R = now, Res = 0;
		while (L <= R) {
			int mid = (L + R) >> 1, w = ask(Rt, 1, n, mid, now);
			if (w >= c) L = mid + 1, Res = mid;
			else R = mid - 1;
		} return Res;
	}
	inline int findr(int Rt, int now, int c) {
		int L = now, R = n, Res = n;
		while (L <= R) {
			int mid = (L + R) >> 1, w = ask(Rt, 1, n, now, mid);
			if (w >= c) R = mid - 1, Res = mid;
			else L = mid + 1;
		} return Res;
	}
	inline void TAGE(int l, int r, int c) {
		int S = bel[l], T = bel[r];
		if (S == T) {pushtag(S); REP(i, l, r) (a[i] != c && (stc[++top] = {&a[i], a[i]}, 1)), a[i] = c; return;}
		pushtag(S), pushtag(T);
		REP(i, l, R[S]) (a[i] != c && (stc[++top] = {&a[i], a[i]}, 1)), a[i] = c;
		REP(i, S + 1, T - 1) {
			(lchk[i] != -1 && (stc[++top] = {&lchk[i], lchk[i]}, 1));
			(rchk[i] != -1 && (stc[++top] = {&rchk[i], rchk[i]}, 1));
			(tage[i] != c  && (stc[++top] = {&tage[i], tage[i]}, 1));
			lchk[i] = rchk[i] = -1, tage[i] = c;
		}
		REP(i, L[T], r) (a[i] != c && (stc[++top] = {&a[i], a[i]}, 1)), a[i] = c;
	}
	inline void LCHK(int now) {
		int Trump = bel[now], mx = h[now]; stc[++top] = {&a[now], a[now]}, a[now] = 0;
		REP(i, now + 1, R[Trump]) (a[i] != min(a[i], mx) && (stc[++top] = {&a[i], a[i]}, 1)), a[i] = min(a[i], mx), mx = max(mx, h[i]);
		REP(i, Trump + 1, W) {
			if (lchk[i] != -1 && lchk[i] <= mx) break;
			(lchk[i] != mx && (stc[++top] = {&lchk[i], lchk[i]}, 1));
			lchk[i] = mx, mx = max(mx, rmx[L[i]]);
		}
	}
	inline void RCHK(int now) {
		int Trump = bel[now], mx = 0; stc[++top] = {&a[now], a[now]}, a[now] = 0;
		PER(i, now - 1, L[Trump]) mx = max(mx, h[i]), (a[i] != min(a[i], mx) && (stc[++top] = {&a[i], a[i]}, 1)), a[i] = min(a[i], mx);
		PER(i, Trump - 1, 1) {
			if (rchk[i] != -1 && rchk[i] <= mx) break;
			(rchk[i] != mx && (stc[++top] = {&rchk[i], rchk[i]}, 1));
			rchk[i] = mx, mx = max(mx, rmx[L[i]]);
		}
	}
	inline void dfs(int x, bool need = false) {
		need |= (G[x].size() > 1);
		for (int i : G[x]) {
			int his = top;
			if (c[i].op == 0) {
				if (pushtag(bel[c[i].x]), c[i].h > a[c[i].x]) TAGE(findl(Rt[i], c[i].x - 1, c[i].h) + 1, findr(Rt[i], c[i].x, c[i].h), c[i].h);
			} else if (c[i].op == 1) {
				pushtag(bel[c[i].x]), LCHK(c[i].x), RCHK(c[i].x);
			} else if (c[i].op == 2) {
				stc[++top] = {&h[c[i].x], h[c[i].x]};
				h[c[i].x] = c[i].h, pushtag(bel[c[i].x]), rebuild(bel[c[i].x]);
			} else {
				pushtag(bel[c[i].x]), Ans[i] = a[c[i].x];
			}
			if (!need) top = 0;
			dfs(i, need);
			while (top != his) *stc[top].first = stc[top].second, --top;
		}
	}
	signed main() { bool flag = true, CZXD = true;
		ld >> n >> q, h[n] = inf;
		REP(i, 1, n - 1) ld >> h[i];
		REP(i, 1, q) ld >> c[i].op >> c[i].id >> c[i].x, ((c[i].op % 2 == 0) && (ld >> c[i].h, 1)), flag &= (c[i].id == i - 1), CZXD &= (c[i].op != 1);
		blt(Rt[0], 1, n);
		REP(i, 1, q) G[c[i].id].emplace_back(i), Rt[i] = Rt[c[i].id], (c[i].op == 2 && (upd(Rt[i], 1, n, c[i].x, c[i].h), 1));
		for (int l = 1, r = min(n, B); l <= n; l += B, r = min(n, r + B)) fill(bel + l, bel + r + 1, ++W), L[W] = l, R[W] = r, tage[W] = lchk[W] = rchk[W] = -1;
		REP(i, 1, W) rebuild(i);
		top = 0, dfs(0);
		REP(i, 1, q) if (c[i].op == 3) jyt << Ans[i] << '\n';
		return 0;
	}
}
signed main() { // 400mb 0.9s
#ifdef WYY
	freopen("water3.in", "r", stdin);
	freopen("water.out", "w", stdout);
#else
//	freopen("water3.in", "r", stdin);
//	freopen("water.out", "w", stdout);
#endif
	JoKing::main();
#ifdef WYY
//	while(true);
#endif
	return 0;
}
```

---


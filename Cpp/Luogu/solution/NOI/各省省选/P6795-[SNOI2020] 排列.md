# [SNOI2020] 排列

## 题目描述

有一个 $n$ 阶排列 $p$，其前 $k$ 位 $p_1,p_2,\cdots,p_k$ 已经确定了。

定义排列 $p$ 中，$[l,r]$ 是一个值域连续段当且仅当：

$$\max(p_l, p_{l+1}, \dots, p_r) - \min(p_l, p_{l+1}, \dots, p_r) = r-l$$

$p$ 中值域连续段个数即所有 $1 \le l \le r \le n$ 中值域连续段的总数。

请你求出：所有可能的排列 $p$ 中，值域连续段个数的最大值，以及任意一种方案。

## 说明/提示

#### 样例说明

对于样例 $1$，最优解为 $2,1,3,4$，有 $8$ 个值域连续段（$[1], [2], [3], [4], [1,2], [3,4], [1,3], [1,4]$）。$2,3,4,1$ 为另一个最优解。

#### 数据规模与约定

对于所有数据，$1\le n\le 2\times 10^5, 0\le k\le n$。

- 对于 $10\%$ 的数据，$n \le 10$；
- 对于另外 $20\%$ 的数据，$n \le 22$；
- 对于另外 $10\%$ 的数据，$k \le 1$；
- 对于另外 $20\%$ 的数据，$k=n$；
- 对于余下 $40\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
4 1
2```

### 输出

```
8
2 1 3 4```

# 题解

## 作者：zx2003 (赞：24)

我们将答案拆成三部分，前k个数内部的连续段，后n-k个数的内部的连续段，跨越了第k个数的连续段。

第1部分是经典问题，不会的建议先做别的题比如 https://www.luogu.com.cn/problem/P4747。

之后一个结论是，考虑前k个数将值域分为的若干段，则同一段内的数在最终排列中都是相邻的。严格的证明这里没有因为我懒得想。

有了这个结论后，后n-k个数的内部的连续段数量已经可以算出来了，只有跨越的部分比较棘手。

考虑从k到1 DP计算，一个性质是，对于任意 $1 \le i \le k$，记 $L=min_{l=i}^{k}p_l,R=max_{l=i}^{k}p_l$ 一定存在 $k \le j \le n$，使得 $[i,j]$构成连续段，且 $R=max_{l=i}^{j}p_l$，$L=min_{l=i}^{j}p_l$，直观描述就是值域区间 $[L,R]$ 内的空洞一定被填满了。

之后一个性质是为了便于我们DP计算而发掘的。就是如果L-1没有出现在前k个数中，则L-1所处的极长未出现在前k个数中的值域连续段一定是递减排布的；同样的R+1若没出现，则其所处的极长段一定递增排布的。

于是，对于i个位置的贡献，唯一有决策必要的就是L-1和R+1所处极长段的情况。这样我们就得到了DP状态 $f_{i,s1,s2}$  用以记录所有可能区间 $[k+1,j]$ 内任意放置元素，配合区间 $[i,k]$ 产生的最大贡献，其中 $s_1,s_2 \in \{0,1,2\}$ 分别记录左/右极长段的情况，0表示未选中，1表示是最后一个被选中，2表示被选中且不是最后一个，这里选中定义为出现在 $[k+1,j]$ 中。

## 转移的细节

具体实现可以见后文代码部分中第一个 `for(i=k;i;--i)` 的循环内部。

方便起见，我们只考虑 $L,R$ 发生变化的位置 $i$。记上一个位置为ii。

一个性质是 $[转移前后左极长段相同]+[转移前后右极长段相同]=1$，因为ii到i $L,R$ 恰好有一个发生变化。

### 剔除非法状态与转移

首先要剔除一些非法状态。根据定义 $s_1,s_2$ 不能同时为1，方便起见我们强制要求 $s_1 \neq 0$ 时左极长段必须非空，$s_2$ 也是。这部分可以见代码第55-57行。

还要剔除一些非法转移。

如果转移前后左极长段相同，并且在ii的状态中 $s_1=2$（被其它东西盖住了），那么在i的状态中，$s_1$ 就不能为1。这部分可以见代码第58行。

如果转移前后左极长段相同，并且在ii的状态中 $s_1 \neq 0$（已选中），那么在i的状态中，$s_1$ 就不能为0。这部分可以见代码第61行。

如果转移前后左极长段相同，并且在转移前后 $s1$ 均为1，就要好好讨论了。此时转移合法当且仅当左极长段可以直接继承而无需在中间插入其它东西。如果i的状态的 $s_2=2$，则右极长连续段一定是新盖住的，这是一种非法情况。另一种非法情况是，R变大时可能会导致新的值域空洞产生，如果需要填坑，那么也是一种非法情况。我们维护一个前缀和数组 `ss2` 用于维护一段区间中坑的数量，然后判一下在ii的状态中已经填上的坑的数量——这等于ii的状态中 $[s_2=2]$。这部分可以见代码第59-60行。

如果右极长段相同，对称地讨论即可。

### 计算转移的权值。

首先要考虑 $[L,R]$ 是否可以构成连续段，亦即 $[L,R]$ 中没有洞，且没有左右极长段产生干扰。

如果转移前后左极长段相同，则只需检查ii的状态中 $s_1=2$ ，或者 $s_1=1$ 且在转移到i的过程中被盖上了——这在前面判“转移前后 $s1$ 均为1”的时候已经讨论过了。这部分可以见代码第69-72行。

右极长段同理。

之后要考虑的是左右极长段的贡献，前面已经给了那么多讨论的示范了，这里~~我就咕咕咕了~~就留给读者自行思考了，需要提醒的是贡献值可能等于极长段长度，也可能等于1，需要仔细分析。这部分可以见代码第78-80行。

最后构方案是简单的，记下每个状态的前驱即可，往前走的时候看下左右极长段怎么放即可。

下面是loj上的AC代码，它在洛谷上还在judging。

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll C2(int x){return 1ll*x*(x+1)>>1;}
const int N=2e5+5;
int n,k,i,ii,j,l,p[N],ip[N],mn[N],mx[N],ss[N],ss2[N],prr[N],sf[N],st1[N],st2[N],tp,pr[N];
ll C1,f[N][9];int pre[N][9];
namespace N1{
struct info{int v,c;};
inline info uni(const info&a,const info&b){
	static info c;c.v=max(a.v,b.v);
	c.c=(a.v==c.v?a.c:0)+(b.v==c.v?b.c:0);return c;
}
const info E=info{-(1<<25),0};
struct node{
	int ad,lb,rb,md;info s;
}t[N*3];
inline void upd(int i){t[i].s=uni(t[i<<1].s,t[i<<1|1].s);t[i].s.v+=t[i].ad;}
void build(int i,int l,int r){
	t[i]=node{0,l,r,l+r>>1,0,r-l+1};if(l==r)return;
	build(i<<1,l,t[i].md);build(i<<1|1,t[i].md+1,r);
}
void mdy(int i,int l,int r,int v){
	if(l<=t[i].lb && t[i].rb<=r){t[i].ad+=v;t[i].s.v+=v;return;}
	if(l<=t[i].md)mdy(i<<1,l,r,v);if(t[i].md<r)mdy(i<<1|1,l,r,v);upd(i);
}
info ask(int i,int l,int r){
	if(l<=t[i].lb && t[i].rb<=r)return t[i].s;
	info ret=uni(l<=t[i].md?ask(i<<1,l,r):E,t[i].md<r?ask(i<<1|1,l,r):E);
	ret.v+=t[i].ad;return ret;
}
inline void main(){
	build(1,1,n);
	for(i=1;i<=k;++i){
		mdy(1,1,i,-1);
		if(ip[p[i]-1])mdy(1,1,ip[p[i]-1],1);
		if(ip[p[i]+1])mdy(1,1,ip[p[i]+1],1);
		info u=ask(1,1,i);C1+=u.v==-1?u.c:0;
		ip[p[i]]=i;
	}
}
}
int main(){
	scanf("%d%d",&n,&k);for(i=1;i<=k;++i)scanf("%d",p+i),ss[p[i]]=1;
	for(i=1;i<=n;++i)ss[i]+=ss[i-1];
	mn[k]=mx[k]=p[k];for(i=k-1;i;--i)mn[i]=min(mn[i+1],p[i]),mx[i]=max(mx[i+1],p[i]);
	N1::main();
	for(i=1;i<=n;++i)pr[i]=ip[i]?0:pr[i-1]+1;for(i=n;i;--i)sf[i]=ip[i]?0:sf[i+1]+1;
	for(i=1;i<=n;++i)if(!ip[i] && (i==1 || ip[i-1]))C1+=C2(sf[i]),ss2[i]=1;
	for(i=1;i<=n;++i)ss2[i]+=ss2[i-1];
	for(i=k;i;--i)if(mn[i]!=mn[i-1] || mx[i]!=mx[i-1]){
		for(ii=i;mn[i]==mn[ii] && mx[i]==mx[ii];++ii);prr[i]=ii;
		for(j=0;j<9;++j)for(l=0;l<9;++l){
			int Lj=j%3,Rj=j/3,Ll=l%3,Rl=l/3;
			if(Lj==1 && Rj==1)continue;if(Ll==1 && Rl==1)continue;
			if(Lj && !pr[mn[i]-1])continue;if(Rj && !sf[mx[i]+1])continue;
			if(Ll && !pr[mn[ii]-1])continue;if(Rl && !sf[mx[ii]+1])continue;
			if(mn[i]==mn[ii] && Lj==1 && Ll==2)continue;
			if(mn[i]==mn[ii] && Ll==1 && Lj==1 && (Rj==2
				 || ss2[mx[i]-1]-ss2[mx[ii]]>(Rl==0 || !sf[mx[ii]+1]?0:1)))continue;
			if(mn[i]==mn[ii] && !Lj && Ll)continue;
			if(mx[i]==mx[ii] && Rj==1 && Rl==2)continue;
			if(mx[i]==mx[ii] && Rl==1 && Rj==1 && (Lj==2 
				 || ss2[mn[ii]-1]-ss2[mn[i]]>(Ll==0 || !pr[mn[ii]-1]?0:1)))continue;
			if(mx[i]==mx[ii] && !Rj && Rl)continue;
			ll nv=f[ii][l];
			if(ss[mx[i]]-ss[mn[i]-1]==k-i+1){
				int zz=mx[i]-mn[i]>k-i;
				if(mn[i]==mn[ii]){
					if(Ll==2)zz=0;
					if(Ll==1 && ss2[mx[i]-1]-ss2[mx[ii]]>(Rl==2?1:0))zz=0;
				}
				if(mx[i]==mx[ii]){
					if(Rl==2)zz=0;
					if(Rl==1 && ss2[mn[ii]-1]-ss2[mn[i]]>(Ll==2?1:0))zz=0;
				}
				nv+=zz;
				if(Lj==1 || (Lj==2 && (mn[i]==mn[ii]?Ll==0
						|| (Ll==1 && ss2[mx[i]-1]-ss2[mx[ii]]<=(Rl==2?1:0)):1)))nv+=pr[mn[i]-1];
					else if(Lj)nv++;
				if(Rj==1 || (Rj==2 && (mx[i]==mx[ii]?Rl==0
						|| (Rl==1 && ss2[mn[ii]-1]-ss2[mn[i]]<=(Ll==2?1:0)):1)))nv+=sf[mx[i]+1];
					else if(Rj)nv++;
			}
			if(nv>f[i][j])f[i][j]=nv,pre[i][j]=l;
		}
	}
	ll mxx=-N;int id;for(i=0;i<9;++i)if(f[1][i]>mxx)mxx=f[1][i],id=i;
	printf("%lld\n",mxx+C1);
	for(i=1;i<=k;)st1[++tp]=i,st2[tp]=id,id=pre[i][id],i=prr[i];
	for(i=k;tp;--tp){
		int x=st1[tp],y=st1[tp+1];
		if(y){
			if(mn[x]<mn[y]){for(j=mn[y]-1;j>mn[x];--j)if(!ip[j])p[++i]=j;}
				else for(j=mx[y]+1;j<mx[x];++j)if(!ip[j])p[++i]=j;
		}
		auto pushR=[&](){
			if(st2[tp]/3 && (mx[x]!=mx[y] || !(st2[tp+1]/3)))
				for(j=mx[x]+1;j<=n && !ip[j];++j)p[++i]=j,ip[j]=-1;
		};
		auto pushL=[&](){
			if(st2[tp]%3 && (mn[x]!=mn[y] || !(st2[tp+1]%3)))
				for(j=mn[x]-1;j && !ip[j];--j)p[++i]=j,ip[j]=-1;
		};
		if(st2[tp]/3==1)pushL(),pushR();
			else pushR(),pushL();
	}
	for(i=1;i<=n;++i)printf("%d%c",p[i],i==n?'\n':' ');
}
```









---

## 作者：Kubic (赞：8)

截至 2023.5.16 只能找到一篇 dp 题解，这大概是第一篇贪心题解。

设 $b_{1\dots m}$ 是 $a_{1\dots m}$ 离散化后的结果。

进行一些基本的分析可以得到：

结论 $1$：如果 $[l,r]$ 中的所有数都不在 $a_{1\dots m}$ 中，那么 $[l,r]$ 中的数在 $a$ 中一定组成了一个连续段。

结论 $2$：如果 $b_{l\dots m}$ 是一个连续段，那么一定存在 $r\in (m,n]$ 满足 $a_{l\dots r}$ 是一个连续段。

根据结论 $1$ 我们可以直接确定 $a_{m+1\dots n}$ 中的连续段个数。而 $a_{1\dots m}$ 中的连续段个数可以用线段树计算出来。因此我们只需要考虑跨过两段的连续段个数即可。

结论 $2$ 已经确定了一部分贡献，我们需要计算剩余部分的最大贡献。

设 $pre_i$ 和 $suf_i$ 分别表示 $i$ 前面和后面第一个在 $a_{1\dots m}$ 中的数。如果 $pre_i$ 不存在则设其为 $0$，如果 $suf_i$ 不存在则设其为 $n+1$。

考虑 $b_{1\dots m}$ 的每个后缀连续段，设共有 $c$ 个，且从后往前第 $i$ 个的值域为 $[l_i,r_i]$。

一个基本的思路是从 $[l_1,r_1]$ 开始依次扩展到 $[l_c,r_c]$，每次将左边要补上的数从大往小填，将右边要补上的数从小往大填。但这样可能不优。

如果 $l_i=l_{i+1}$，有可能是在扩展到 $[l_{i+1},r_{i+1}]$ 之前就将 $(pre_{l_i},l_i)$ 中的数先填上。

考虑先对往左填的部分进行分析，即考虑所有形如在 $a_{1\dots m}$ 中出现过的 $x(x\le l_1)$ 所对应的值域区间 $(pre_x,x)$。

结论 $3$：对于一个在 $a_{1\dots m}$ 中出现过的 $x(x\le l_1)$，设 $i$ 为满足 $x\ge l_i$ 的最大位置。那么：

- 如果 $x>l_i$，那么 $(pre_x,x)$ 在扩展到 $[l_j,r_j]$ 时填。**这种情况一定不会产生贡献**。

- 如果 $x=l_i$，那么设 $j$ 为满足 $l_i=l_j$ 的最小位置，那么存在一个 $k\in [j,i]$，使得 $(pre_x,x)$ 在扩展到 $[l_k,r_k]$ 时填。**这种情况可能会产生贡献**。

扩展到 $[l_i,r_i]$ 之后，将 $(pre_{l_i},l_i)$ 填上产生的贡献可以表示为 $wl_i\times (l_i-pre_{l_i}-1)$。

对于一个 $i$，考虑如何计算它对应的 $wl_i$。这相当于是考虑填上 $l_i-1$ 时有哪些后缀会成为新的连续段。设 $j$ 为满足 $l_i=l_j$ 且 $[r_j,r_i]$ 全部在 $a_{1\dots m}$ 中出现过的最小位置。如果 $l_i=l_{j-1}$ 且 $[suf_{r_{j-1}},r_j]$ 全部在 $a_{1\dots m}$ 出现过，那么 $tl_i=i-j+2$，否则 $tl_i=i-j+1$。

设 $wl_x=\max\limits_{l_i=x}\{tl_x\}$。

类似地我们也可以定义 $tr,wr$。

此时我们获得了一个贡献的上界：

$$\sum wl_x(x-pre_x-1)+\sum wr_x(suf_x-x-1)$$

但左右两部分并不完全独立，它们可能会互相影响导致贡献变小。

猜测最终贡献一定能取到上界，尝试进行构造。

可以发现贡献变小时一定存在一个 $i$ 满足 $(pre_{l_i},l_i),(r_i,suf_{r_i})$ 这两段都在扩展到 $[l_i,r_i]$ 时填。显然只有在这种情况下左右两边的贡献才可能互相影响。

如果先填 $(pre_{l_i},l_i)$，那么 $(r_i,suf_{r_i})$ 的贡献可能无法达到 $tr_i\times (r_i,suf_{r_i})$。反之亦然。考虑进行一些分析避免贡献变小。

显然 $l_i<l_{i-1}$ 和 $r_i>r_{i-1}$ 中至少有一个成立，不妨设 $l_i<l_{i-1}$。根据 $tl$ 和 $tr$ 的计算方法可以得到 $tl_i=1$。如果我们先填 $(r_i,suf_{r_i})$，再填 $(pre_{l_i},l_i)$，可以发现此时 $(pre_{l_i},l_i)$ 产生的贡献为 $l_i-pre_{l_i}-1$，没有变小。

因此我们只需要根据 $tl,tr,wl,wr$ 计算出每个 $(pre_x,x),(x,suf_x)$ 填的时间，然后利用上述方式进行构造即可。

时间复杂度 $O(n\log n)$。瓶颈在于使用线段树求 $a_{1\dots m}$ 中的连续段个数，后面的贪心和构造部分都是 $O(n)$ 的。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 200005
#define mid ((l+r)/2)
#define ll long long
const int INF=1e9;
int n,m,tp,a[N],b[N],vs[N],id[N],id1[N],L[N],R[N],w1[N],w2[N],ps1[N],ps2[N];
ll ans;struct Seg {int vl,cnt,tg;}sg[N*4];
void pu(int p)
{
	sg[p].vl=min(sg[p*2].vl,sg[p*2+1].vl);sg[p].cnt=0;
	if(sg[p].vl==sg[p*2].vl) sg[p].cnt=sg[p*2].cnt;
	if(sg[p].vl==sg[p*2+1].vl) sg[p].cnt+=sg[p*2+1].cnt;
}
void mdf(int p,int vl) {sg[p].vl+=vl;sg[p].tg+=vl;}
void pd(int p) {mdf(p*2,sg[p].tg);mdf(p*2+1,sg[p].tg);sg[p].tg=0;}
void build(int p,int l,int r)
{
	if(l==r) {sg[p].vl=INF;sg[p].cnt=1;return;}
	build(p*2,l,mid);build(p*2+1,mid+1,r);pu(p);
}
void upd(int p,int l,int r,int qL,int qR,int vl)
{
	if(qL>qR) return;if(l>=qL && r<=qR) {mdf(p,vl);return;}pd(p);
	if(qL<=mid) upd(p*2,l,mid,qL,qR,vl);
	if(qR>mid) upd(p*2+1,mid+1,r,qL,qR,vl);pu(p);
}
int main()
{
	scanf("%d %d",&n,&m);
	if(!m)
	{
		printf("%lld\n",1ll*n*(n+1)/2);
		for(int i=1;i<=n;++i) printf("%d ",i);return 0;
	}build(1,1,n);
	for(int i=1;i<=m;++i)
	{
		scanf("%d",&a[i]);vs[a[i]]=i;upd(1,1,n,i,i,-INF);upd(1,1,n,1,i,1);
		if(vs[a[i]-1]) upd(1,1,n,1,vs[a[i]-1],-1);
		if(vs[a[i]+1]) upd(1,1,n,1,vs[a[i]+1],-1);
		if(i<m && sg[1].vl==1) ans+=sg[1].cnt;
	}for(int i=1;i<=n;++i) if(vs[i]) b[id[i]=++tp]=i;b[tp+1]=n+1;
	for(int i=1;i<=tp;++i)
	{
		id1[i]=id1[i-1]+(i==1 || b[i]>b[i-1]+1);
		if(id1[i]>id1[i-1]) L[id1[i]]=i;R[id1[i]]=i;
	}for(int i=0;i<=tp;++i) ans+=1ll*(b[i+1]-b[i])*(b[i+1]-b[i]-1)/2;
	for(int i=m,t,nw1=0,nw2=0,l=INF,r=-INF,l1=INF,r1=-INF;i;--i)
	{
		t=id[a[i]];l=min(l,t);r=max(r,t);
		if(r-l==m-i)
		{		
			if(l<l1) nw1=0;else if(id1[r]!=id1[r1]) nw1=(r1==R[id1[r]-1]);++nw1;
			if(r>r1) nw2=0;else if(id1[l]!=id1[l1]) nw2=(l1==L[id1[l]+1]);++nw2;
			if(nw1>w1[l]) w1[l]=nw1,ps1[l]=i;
			if(nw2>w2[r]) w2[r]=nw2,ps2[r]=i;++ans;l1=l;r1=r;
		}
	}for(int i=1;i<=tp;++i) ans+=1ll*w1[i]*(b[i]-b[i-1]-1)+1ll*w2[i]*(b[i+1]-b[i]-1);
	printf("%lld\n",ans);for(int i=1;i<=m;++i) printf("%d ",a[i]);
	for(int i=m,t,l=INF,r=-INF,l1=INF,r1=-INF;i;--i)
	{
		t=id[a[i]];l=min(l,t);r=max(r,t);
		if(r-l==m-i)
		{	
			if(l1>r1) for(int j=l;j<r;++j) for(int k=b[j]+1;k<b[j+1];++k) printf("%d ",k);
			else
			{
				for(int j=l1-1;j>l;--j) for(int k=b[j]-1;k>b[j-1];--k) printf("%d ",k);
				for(int j=r1+1;j<r;++j) for(int k=b[j]+1;k<b[j+1];++k) printf("%d ",k);
			}l1=l;r1=r;
			if(i==ps1[l] && w1[l]>1) {for(int j=b[l]-1;j>b[l-1];--j) printf("%d ",j);}
			if(i==ps2[r] && w2[r]>1) {for(int j=b[r]+1;j<b[r+1];++j) printf("%d ",j);}
			if(i==ps1[l] && w1[l]==1) {for(int j=b[l]-1;j>b[l-1];--j) printf("%d ",j);}
			if(i==ps2[r] && w2[r]==1) {for(int j=b[r]+1;j<b[r+1];++j) printf("%d ",j);}
		}
	}return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：4)

# P6795 题解

**题目大意**

> 给定一个 $n$ 阶排列 $a_1\sim a_n $ 的前 $m$ 位，确定整个排列使得值域连续段数最大，给出构造。
>
> 数据范围：$n\le 2\times 10^5$。

**思路分析**

设 $a_1\sim a_m$ 离散化后得到 $b_1\sim b_m$。

考虑分类：

- 若左右端点都在 $[1,m]$：直接线段树或析合树统计即可。
- 若左右端点都在 $(m,n]$：可以证明剩余元素的每个值域连续段都是按顺序填在一起的，即每个都不在 $a_1\sim a_m$ 中的值域区间在序列上一定连续。

否则考虑一个前后缀拼合的形态：$[i,m]+(m,j]$，显然一个必要条件是 $b_i\sim b_m$ 是值域连续段。

考虑取出所有 $b$ 的值域连续段，按 $i$ 大到小排序，设这些区间原本的值域是 $[l_1,r_1]\sim [l_k,r_k]$，第 $i$ 个区间对应的后缀是  $b_{p_i}\sim b_m]$。

不妨设当前区间为 $[l_i,r_i]$，考虑从 $[l_{i-1},r_{i-1}]$ 转移的过程：显然会降序加入 $l_{i-1}-1\sim l_i+1$，升序加入 $r_{i-1}+1\sim r_i-1$。

不妨设在 $a_1\sim a_m$ 中：值为 $x$ 的数的前驱是 $pre(x)$，后继是 $suf(x)$，因此我们考虑 $(pre(l_i),l_i)$ 这个区间的贡献，注意到如果有多个 $l_i$ 相等，那么这个区间可以选一个最优的时刻下放。

考虑在当前时刻下放的贡献 $c_i$：

- 若 $l_i\ne l_{i-1}$ 显然 $c_i=1$。
- 否则考虑左端点从 $p_i$ 移动到 $p_{i-1}$ 的过程，注意到指针扫过的 $(p_i,p_{i-1})$ 这个区间，这些数的值域是 $(r_{i-1},r_i)$，如果这个值域里的数都在 $a_1\sim a_m$ 中，那么 $c_{i}=c_{i-1}+1$。
- 否则显然 $c_i\in\{1,2\}$，考虑什么时候 $c_i=2$，那么我们要求 $[r_{i-1}+1,r_i-1]$ 中不在 $a_1\sim a_m$ 中的元素一定紧接着 $r_{i-1}$，具体可以看代码：维护 $a_1\sim a_m$ 排序后的值域区间，要求 $r_{i-1}$ 是 $r_i$ 所在值域区间的上一个值域区间里的最大值。

最终维护每个段最优的下放贡献以及转移点，容易求出答案和构造方案。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+5,inf=1e9;
int n,m;
struct SegmentTree {
	struct Node {
		int add,min,cnt;
	}	tr[MAXN<<2];
	inline int L(int p) { return p<<1; }
	inline int R(int p) { return p<<1|1; }
	inline void psu(int p) {
		tr[p].cnt=0,tr[p].min=std::min(tr[L(p)].min,tr[R(p)].min);
		if(tr[L(p)].min==tr[p].min) tr[p].cnt+=tr[L(p)].cnt;
		if(tr[R(p)].min==tr[p].min) tr[p].cnt+=tr[R(p)].cnt;
	}
	inline void adt(int p,int k) { tr[p].add+=k,tr[p].min+=k; }
	inline void psd(int p) { adt(L(p),tr[p].add),adt(R(p),tr[p].add),tr[p].add=0; }
	inline void bd(int l=1,int r=n,int p=1) {
		tr[p].cnt=r-l+1;
		if(l==r) return ;
		int mid=(l+r)>>1;
		bd(l,mid,L(p)),bd(mid+1,r,R(p));
	}
	inline void add(int ul,int ur,int k,int l=1,int r=n,int p=1) {
		if(ul<=l&&r<=ur) return adt(p,k);
		int mid=(l+r)>>1; psd(p);
		if(ul<=mid) add(ul,ur,k,l,mid,L(p));
		if(mid<ur) add(ul,ur,k,mid+1,r,R(p));
		psu(p);
	}
}	T;
int sn[MAXN],tn,sx[MAXN],tx;
int a[MAXN],b[MAXN],rk[MAXN],id[MAXN],L[MAXN],R[MAXN];
int fl[MAXN],fr[MAXN],gl[MAXN],gr[MAXN];
inline void pl(int x) {
	for(int i=b[x]-1;i>=b[x-1]+1;--i) printf("%d ",i);
}
inline void pr(int x) {
	for(int i=b[x]+1;i<=b[x+1]-1;++i) printf("%d ",i);
}
signed main() {	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i) scanf("%d",&a[i]),b[i]=a[i];
	ll ans=0;
	T.bd(),T.add(1,n,inf);
	for(int i=1;i<=m;++i) {
		T.add(1,i,-1),T.add(i,i,-inf+1);
		while(tn&&a[sn[tn]]>a[i]) T.add(sn[tn-1]+1,sn[tn],a[sn[tn]]),--tn;
		sn[++tn]=i,T.add(sn[tn-1]+1,sn[tn],-a[i]);
		while(tx&&a[sx[tx]]<a[i]) T.add(sx[tx-1]+1,sx[tx],-a[sx[tx]]),--tx;
		sx[++tx]=i,T.add(sx[tx-1]+1,sx[tx],a[i]);
		if(!T.tr[1].min&&i<m) ans+=T.tr[1].cnt;
	}
	sort(b+1,b+m+1),b[m+1]=n+1;
	for(int i=1;i<=m;++i) rk[b[i]]=i;
	for(int i=0;i<=m;++i) ans+=1ll*(b[i+1]-b[i]-1)*(b[i+1]-b[i])/2;
	for(int i=1,c=0;i<=m;++i) {
		if(i==1||b[i]>b[i-1]+1) id[i]=++c,L[c]=R[c]=i;
		else R[c]=i,id[i]=c;
	}
	for(int i=m,l=n+1,r=0,kl=n+1,kr=0,wl=0,wr=0;i;--i) {
		l=min(l,rk[a[i]]),r=max(r,rk[a[i]]);
		if(r-l==m-i) {
			if(l<kl) wl=0;
			else if(id[r]!=id[kr]) wl=(kr==R[id[r]-1]);
			if(r>kr) wr=0;
			else if(id[l]!=id[kl]) wr=(kl==L[id[l]+1]);
			++wl,++wr;
			if(wl>fl[l]) fl[l]=wl,gl[l]=i;
			if(wr>fr[r]) fr[r]=wr,gr[r]=i;
			kl=l,kr=r,++ans;
		}
	}
	for(int i=1;i<=m;++i) ans+=1ll*fl[i]*(b[i]-b[i-1]-1)+1ll*fr[i]*(b[i+1]-b[i]-1);
	printf("%lld\n",ans);
	for(int i=1;i<=m;++i) printf("%d ",a[i]);
	for(int i=m,l=n+1,r=0,kl=n+1,kr=0;i;--i) {
		l=min(l,rk[a[i]]),r=max(r,rk[a[i]]);
		if(r-l==m-i) {
			if(i<m) {
				for(int j=kl-1;j>=l+1;--j) pl(j);
				for(int j=kr+1;j<=r-1;++j) pr(j);
			}
			kl=l,kr=r;
			int zl=(gl[l]==i)?fl[l]:0,zr=(gr[r]==i)?fr[r]:0;
			if(zl>zr) {
				if(zl) pl(l);
				if(zr) pr(r);
			} else {
				if(zr) pr(r);
				if(zl) pl(l);
			}
		}
	}
	puts("");
	return 0;
}
```

---


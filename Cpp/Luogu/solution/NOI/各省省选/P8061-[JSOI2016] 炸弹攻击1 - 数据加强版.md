# [JSOI2016] 炸弹攻击1 - 数据加强版

## 题目背景

JYY 最近迷上了一款塔防游戏，在游戏里 JYY 除了建设建筑，还可以使用炸弹对屏幕上的敌人进行范围杀伤。

## 题目描述

游戏地图可以简单认为是一个二维平面。JYY 建造了 $N $ 个建筑，每个建筑都是一个圆，其中第 $i$ 个建筑的圆心位于 $(x_i,y_i)$ 且半径为 $r_i$。地图上一共有 $M$ 个敌人，一个敌人可以近似看成一个平面上的点，其中第 $i$ 个敌人位于 $(p_i,q_i)$。JYY 可以使用一枚可以设置半径的炸弹，可以设置一个不超过 $R$ 的范围，然后选择平面上的一个点引爆，范围内的所有敌人全部消灭。

当然，由于炸弹威力巨大，如果爆炸范围接触到 JYY 的建筑，那么 JYY 的建筑也会受到损伤。（注：如果炸弹的爆炸范围仅接触到了 JYY 建筑的边界，则不会对 JYY 的建筑造成损伤；如果敌人出现在了爆炸范围的边界，则该敌人被消灭）JYY 可以自由控制炸弹的爆炸地点和爆炸半径。作为一个保守的玩家，他希望在保证自己建筑毫发无损的情况下，消灭尽量多的敌人。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\leq N\leq 10$，$1\leq M\leq 2000$，$1\leq R,r_i\leq 2\times 10^4$，$|p_i|,|q_i|,|x_i|,|y_i|\leq 2\times 10^4$。

数据来源于 NAIPC 2015 Problem A - Area of Effect，并有部分自造新数据。

## 样例 #1

### 输入

```
1 3 3
0 0 1
3 3
-3 3
3 -3```

### 输出

```
1```

## 样例 #2

### 输入

```
1 5 3
0 0 1
3 3
-3 3
3 -3
3 0
0 3```

### 输出

```
3```

## 样例 #3

### 输入

```
4 10 100
0 0 3
10 0 3
10 10 3
0 10 3
0 4
0 5
0 6
5 3
5 -3
5 5
6 7
3 6
10 4
8 4```

### 输出

```
5```

# 题解

## 作者：djwj223 (赞：15)

[my submission](https://www.luogu.com.cn/record/list?pid=P8061&user=djwj223)

当然有很多是无效提交，比如说忘开 O2 之类的 ![](https://啧.tk/hanx)

讲讲我的心路历程：4 月学模拟退火的时候 A 了 	[[JSOI2016]炸弹攻击1](https://www.luogu.com.cn/problem/P5544)，看到了这一题，也发现不少人用模拟退火水过了，于是魔改我原题的程序，发现就是草不过，一直 92 ，又 WA 又 T，发现没前途。

那时候就康那些模拟退火过了的程序，发现都是一车面向数据特判。

他们是怎么知道数据的？小编非常疑惑。

于是我弃了这一题。

今天在翻我以前咕咕的题，发现了这一题，是个计算几何题，很有感觉。

于是想怎么做。

之前做过一道 CF 题，大概就是用了角前缀和的思想，发现这题取半径 $=R$ 的时候也适用。

大概就是说有一个选定圆和一车圆（我们暂且把怪物看做半径为 $0$ 的圆），求哪一个在选定圆上的点，被包含在其他圆中的次数最多。

来做这题的人肯定都会，就只要看一个非选定圆对选定圆上的哪段弧有贡献，前缀和一下就好了。

注意，要把自己建筑的圆的贡献设成无穷小，表示不能将其包含在内。

接下来我们考虑证明可能成为最大值的圆心位置的个数是只有严格 $\Theta(n^2m)$ 的。

我们采取这样一种构造：一个点满足存在一个圆心为他的圆，与两个自己的建筑相切，并且也与一个怪物相切（前面已把其定义为圆）。

证明：如果不与怪物相切，那么圆还可以缩小。如果不与两个建筑相切，那么圆还可以放大。

于是圆心个数就被缩成 $2\times 10^5$ 级别的，二分写的稳一点就可以过。

后面还要 $\Theta(n+m)$ 判最大可行直径。

$\text{code}$（部分参考 $\text{Claris}$）：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define PLDI pair<ld,int>
using namespace std;
const int M=2017;
const ld Eps=1e-9,EEps=1e-4,PI=3.14159265358979323846;
int n,m,ans=1; ll R,d[M][M];
PLDI q[M<<1|1];
struct C{ll x,y,r;}a[M];
struct FC{ld x,y,r;};
inline ll pf(ll x){return x*x;}
inline ld pf(ld x){return x*x;}
inline ld fix(ld x){
	while(x<-Eps) x+=PI*2;
	while(x-PI*2>-Eps) x-=PI*2;
	return max(x,(ld)0.0);
}
inline void solve_for_R(int x){
	int ret=1,cnt=0;
	for(int i=1;i<=n+m;i++) if(i!=x){
		if(d[x][i]>pf(R*2+a[i].r) ||(d[x][i]==pf(R*2+a[i].r) && i<=n)) continue;
		ld A=R,B=R+a[i].r,C=sqrt(d[x][i]); if(i<=n) B-=1e-7;
		ld ang=acos((A*A+d[x][i]-B*B)/(2.0*A*C));
		//余弦定理
		ld st=atan2(a[i].y-a[x].y,a[i].x-a[x].x);
		//本来的当前点到枚举点的方向
		ld l=fix(st-ang),r=fix(st+ang);
		if(fabs(l-r)<Eps) r=l+Eps;
		int v=(i<=n)?-M:1;
		//不能炸到自己的建筑
		if(l>r) ret+=v;
		q[++cnt]=PLDI(l,v),q[++cnt]=PLDI(r,-v);
	}
	ans=max(ans,ret),sort(q+1,q+cnt+1);
	for(int i=1;i<=cnt;i++) ans=max(ans,ret+=q[i].second);
	//类似于前缀和的思路
}
inline void FC_intersection(FC a,FC b,ld& X,ld& Y,int t){
	//求圆交点，t 表示现在求第几个
	ld d2=pf(a.x-b.x)+pf(a.y-b.y),d=sqrt(d2);
	ld l=(d2+pf(a.r)-pf(b.r))/(2.0*d),h=sqrt(max(pf(a.r)-pf(l),(ld)0.0));
	//当前角的正弦和余弦值
	ld vlx=(b.x-a.x)/d*l,vly=(b.y-a.y)/d*l;
	ld vhx=-(b.y-a.y)/d*h,vhy=(b.x-a.x)/d*h;
	if(t==1) vhx*=-1,vhy*=-1;
	X=a.x+vlx+vhx,Y=a.y+vly+vhy;
}
inline void work(ld x,ld y,ld r){
	for(int i=1;i<=n;i++) if(pf(x-a[i].x)+pf(y-a[i].y)-pf(r+a[i].r)<-EEps) return;
	int ret=0; r=pf(r); for(int i=n+1;i<=n+m;i++) if(pf(x-a[i].x)+pf(y-a[i].y)-r<EEps)
		ret++; ans=max(ans,ret);
}
inline void smaller_than_R(int x,int y,int z){
	if(d[x][y]>=pf(R*2+a[x].r+a[y].r)) return;
	for(int nw=0;nw<2;nw++){
		//二分法找出所有有可能是答案的圆心位置
		ld l=(sqrt(d[x][z])-a[x].r)/2.0,r=R,X,Y,mid;
		for(int i=1;i<=100;i++){
			mid=(l+r)/2;
			FC_intersection((FC){a[x].x,a[x].y,a[x].r+mid},(FC){a[z].x,a[z].y,mid},X,Y,nw);
			if(pf(X-a[y].x)+pf(Y-a[y].y)>pf(a[y].r+mid)-EEps) l=mid; else r=mid;
		}
		//这样二分会好些，其他的二分写法会 WA 或者 TLE
		FC_intersection((FC){a[x].x,a[x].y,a[x].r+l},(FC){a[z].x,a[z].y,l},X,Y,nw);
		work(X,Y,l);
	}
}
int main(){
	scanf("%d%d%lld",&n,&m,&R);
	for(int i=1;i<=n;i++) scanf("%lld%lld%lld",&a[i].x,&a[i].y,&a[i].r);
	for(int i=1;i<=m;i++) scanf("%lld%lld",&a[i+n].x,&a[i+n].y);
	for(int i=1;i<=n+m;i++) for(int j=1;j<=n+m;j++)
		d[i][j]=pf(a[i].x-a[j].x)+pf(a[i].y-a[j].y);
	for(int i=n+1;i<=n+m;i++) solve_for_R(i);
	for(int i=1;i<n;i++) for(int j=i+1;j<=n;j++)
		for(int k=n+1;k<=n+m;k++) smaller_than_R(i,j,k);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：zhicheng (赞：7)

本篇题解参考 @djwj223，但是本人太弱了，对着代码看了 INF 年才看懂。因此写一篇具体讲解实现方面的题解。在此先表示感谢。

### 思路

考虑最终的答案圆会是怎样的。第一种是半径达到了 $R$ 的上界，不能继续扩充。显然这种情况可以把圆移动一下使某个点在圆上，以此进行计算。第二种是楼上所说的与两个圆相切并过一个点。此时可以先钦定与一个圆相切且过某个点。然后进行二分。

#### 第一种情况

考虑枚举每一个点 $A$，我们钦定答案圆的半径为 $R$ 且过这个点。相当于可能成为答案的圆（或者说半径）绕着这个点旋转（见下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/hbb9eywn.png)

然后考虑每个其他的点和圆，我们可以求出答案圆旋转到哪个位置区间时可以与它们有交。可以利用余弦定理求出这个区间。

![](https://cdn.luogu.com.cn/upload/image_hosting/ze2muyt7.png)

如图，利用余弦定理求出 $\angle BAC$ 和 $\angle BAD$，再使用 `atan2` 计算 $AB$ 的旋转角（$x$ 正方向为 $0$，转回去就是 $2\pi$），然后即可求出 $AC$ 和 $AD$ 的旋转角，调整到 $[0,2\pi)$，带上贡献（圆为 $-\infty$，点为 $1$）排序后前缀和即可。

注意像图中的 $AC$ 和 $AD$ 横跨 $x$ 正半轴，调整后的旋转角加比减小，需要把计算的变量初始值加上贡献。这样可以保证在 $AC$ 处把贡献减掉，在 $AD$ 处加回来。

这部分的代码（`pw` 是平方，$d$ 是预处理的圆心距离）：

```cpp
struct cir{
	int x,y;
	ld r;
}p[N];
struct s{
	ld pos;
	int del;
	bool operator<(s b){
		return pos<b.pos;
	}
}q[N<<1];
inline ld fun(ld a){  //调整
	while(a>=2*pi){
		a-=2*pi;
	}
	while(a<-eps){
		a+=2*pi;
	}
	return max(a,(ld)0.0);
}
inline void solve_r(int x){
	ld A,B,C,l,r,deg,f;
	int res=1,del,cnt=0;
	for(int i=1;i<=n+m;i++){  //前 n 个是圆，后面是点。
		if(x==i){
			continue;
		}
		if(d[i][x]>pw(maxr*2+p[i].r)){ //根本不交
			continue;
		}
		A=sqrt(d[i][x]);
		B=maxr;
		C=maxr+p[i].r;
		deg=acos((B*B+d[i][x]-C*C)/(2*A*B));
		f=atan2(p[i].y-p[x].y,p[i].x-p[x].x);
		l=fun(f-deg);
		r=fun(f+deg);
		if(fabs(l-r)<eps){  //减小精度影响
			r=l+eps;
		}
		del=(i<=n?-2100:1);  //贡献
		if(l>r){  //横跨
			res+=del;
		}
		q[++cnt]={l,del};
		q[++cnt]={r,-del};
	}
	ans=max(ans,res);
	sort(q+1,q+cnt+1);
	for(int i=1;i<=cnt;i++){
		res+=q[i].del;
		ans=max(ans,res);
	}
}
```

#### 第二种情况

第二种考虑是先钦定与一个圆相切且过某个点。此时可能的答案圆如下图（`mid` 是二分时的半径）：

![](https://cdn.luogu.com.cn/upload/image_hosting/e3i6fcf7.png)

如何求出这个点 $B$ 的坐标呢？考虑以 $A$ 为圆心，$mid$ 为半径的圆，和以 $C$ 为圆心 $mid+r$ 为半径的圆。两者的（两个）交点即为 $B_1$ 和 $B_2$。求出 $B$ 后，判断当前答案圆与第二个圆的位置关系即可继续二分。二分结束后可以直接计算并更新答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/y0puyv5t.png)

这个求交点的过程与第一种情况雷同，唯一不同是这里需要坐标而不是角度。但是使用上述的余弦定理方法速度非常慢，因此这里可以直接计算三角函数值并使用和角公式。

这部分的代码：

```cpp
inline void get_intersect(cir a,cir b,int qq){  //计算交点
	int dis=pw(a.x-b.x)+pw(a.y-b.y);
	ld cosar=(dis+pw(a.r)-pw(b.r))/(2*sqrt(dis)),sinar=sqrt(max(pw(a.r)-pw(cosar),(ld)0.0)),cosb=(b.x-a.x)/sqrt(dis),sinb=(b.y-a.y)/sqrt(dis);
	if(qq){
		sinar=-sinar;  //某一个交点。另外一个角度加上负值。
	}
	xx=a.x+cosar*cosb-sinar*sinb;
	yy=a.y+sinar*cosb+sinb*cosar;
}
inline int get(ld px,ld py,ld r){  //计算答案
	int ans=0;
	for(int i=1;i<=n;i++){
		if(pw(px-p[i].x)+pw(py-p[i].y)-pw(r+p[i].r)<-eps){
			return 0;
		}
	}
	for(int i=1;i<=m;i++){
		ans+=pw(px-p[i+n].x)+pw(py-p[i+n].y)-pw(r)<eps;
	}
	return ans;
}
inline void solve_smaller(int x,int y,int z){
	ld l,r,mid;
	if(d[x][y]>pw(maxr*2+p[x].r+p[y].r)){  //至少要刚好能卡上
		return;
	}
	for(int i=0;i<=1;i++){
		l=(sqrt(d[x][z])-p[x].r)/2;  //下界是仅有一个交点的时候。
		r=maxr;
		if(l>r+eps){
			return;
		}
		for(int kk=1;kk<=100;kk++){
			mid=(l+r)/2;
			get_intersect({p[x].x,p[x].y,p[x].r+mid},{p[z].x,p[z].y,mid},i);
			if(pw(xx-p[y].x)+pw(yy-p[y].y)>=pw(mid+p[y].r)){
				l=mid;  //没有交
			}
			else{
				r=mid;
			}
		}
		get_intersect({p[x].x,p[x].y,p[x].r+l},{p[z].x,p[z].y,l},i);
		ans=max(ans,get(xx,yy,l));
	}
}
```

这道题不怎么卡精度。这是好的。~~但是时间要卡，需要开 O2。这好吗？这不好。~~

### Code

```cpp
#include<bits/stdc++.h>
#define ld long double
using namespace std;
const ld eps=1e-7,pi=acos(-1);
const int N=2020;
int n,m,maxr,d[N][N],ans;
ld xx,yy;
struct cir{
	int x,y;
	ld r;
}p[N];
struct s{
	ld pos;
	int del;
	bool operator<(s b){
		return pos<b.pos;
	}
}q[N<<1];
inline ld fun(ld a){
	while(a>=2*pi){
		a-=2*pi;
	}
	while(a<-eps){
		a+=2*pi;
	}
	return max(a,(ld)0.0);
}
inline int pw(int x){
	return x*x;
}
inline ld pw(ld x){
	return x*x;
}
inline void solve_r(int x){
	ld A,B,C,l,r,deg,f;
	int res=1,del,cnt=0;
	for(int i=1;i<=n+m;i++){
		if(x==i){
			continue;
		}
		if(d[i][x]>pw(maxr*2+p[i].r)){
			continue;
		}
		A=sqrt(d[i][x]);
		B=maxr;
		C=maxr+p[i].r;
		deg=acos((B*B+d[i][x]-C*C)/(2*A*B));
		f=atan2(p[i].y-p[x].y,p[i].x-p[x].x);
		l=fun(f-deg);
		r=fun(f+deg);
		if(fabs(l-r)<eps){
			r=l+eps;
		}
		del=(i<=n?-2100:1);
		if(l>r){
			res+=del;
		}
		q[++cnt]={l,del};
		q[++cnt]={r,-del};
	}
	ans=max(ans,res);
	sort(q+1,q+cnt+1);
	for(int i=1;i<=cnt;i++){
		res+=q[i].del;
		ans=max(ans,res);
	}
}
inline void get_intersect(cir a,cir b,int qq){
	int dis=pw(a.x-b.x)+pw(a.y-b.y);
	ld cosar=(dis+pw(a.r)-pw(b.r))/(2*sqrt(dis)),sinar=sqrt(max(pw(a.r)-pw(cosar),(ld)0.0)),cosb=(b.x-a.x)/sqrt(dis),sinb=(b.y-a.y)/sqrt(dis);
	if(qq){
		sinar=-sinar;
	}
	xx=a.x+cosar*cosb-sinar*sinb;
	yy=a.y+sinar*cosb+sinb*cosar;
}
inline int get(ld px,ld py,ld r){
	int ans=0;
	for(int i=1;i<=n;i++){
		if(pw(px-p[i].x)+pw(py-p[i].y)-pw(r+p[i].r)<-eps){
			return 0;
		}
	}
	for(int i=1;i<=m;i++){
		ans+=pw(px-p[i+n].x)+pw(py-p[i+n].y)-pw(r)<eps;
	}
	return ans;
}
inline void solve_smaller(int x,int y,int z){
	ld l,r,mid;
	if(d[x][y]>pw(maxr*2+p[x].r+p[y].r)){
		return;
	}
	for(int i=0;i<=1;i++){
		l=(sqrt(d[x][z])-p[x].r)/2;
		r=maxr;
		if(l>r+eps){
			return;
		}
		for(int kk=1;kk<=100;kk++){
			mid=(l+r)/2;
			get_intersect({p[x].x,p[x].y,p[x].r+mid},{p[z].x,p[z].y,mid},i);
			if(pw(xx-p[y].x)+pw(yy-p[y].y)>=pw(mid+p[y].r)){
				l=mid;
			}
			else{
				r=mid;
			}
		}
		get_intersect({p[x].x,p[x].y,p[x].r+l},{p[z].x,p[z].y,l},i);
		ans=max(ans,get(xx,yy,l));
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&maxr);
	for(int i=1;i<=n;i++){
		scanf("%d%d%Lf",&p[i].x,&p[i].y,&p[i].r);
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d",&p[i+n].x,&p[i+n].y);
	}
	for(int i=1;i<=n+m;i++){
		for(int j=i+1;j<=n+m;j++){
			d[i][j]=d[j][i]=pw(p[i].x-p[j].x)+pw(p[i].y-p[j].y);
		}
	}
	for(int i=n+1;i<=n+m;i++){
		solve_r(i);
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			for(int k=1;k<=m;k++){
				solve_smaller(i,j,k+n);
			}
		}
	}
	printf("%d",ans);
}
```

---


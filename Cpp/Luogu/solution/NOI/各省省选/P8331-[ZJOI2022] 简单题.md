# [ZJOI2022] 简单题

## 题目描述

九条可怜是一个喜欢出简单题的女孩子。顾名思义，简单题就是题目里面出现了很多 “简单”。

可怜首先给出一张简单连通无向图，每条边有一个正整数边权。特别地，可怜保证图上任意两个简单环的边权和相等。

后来可怜想要隐藏图里美好的性质，她将其中一部分边的权值改成了新的权值。因此，修改之后原本美好的性质可能就不存在了。

现在她给出修改后的图，同时给出多组询问，每次询问两点 $S, T$ 间所有简单路径权值和。因为答案可能很大，你只需要输出答案对 $998244353$ 取模的结果。

具体地，简单图指不存在重边和自环，简单环和简单路径指不包含重复节点。

## 说明/提示

对于所有测试点，满足 $1 \le n, q \le 5 \times {10}^5$，$n - 1 \le m \le 6.4 \times {10}^5$，$1 \le u, v, S, T \le n$，$1 \le w \le {10}^6$，无重边自环，图连通。

每个测试点的具体限制见下表：

| 测试点编号 | 特殊限制 1 | 特殊限制 2 |
|:-:|:-:|:-:|
| $1$ | $m < n$ | 保证存在经过所有点的简单路径 |
| $2$ | $m < n$ | 无 |
| $3 \sim 5$ | 任意一个点不在 $\ge 2$ 个简单环上 | 保证存在经过所有点的简单路径 |
| $6 \sim 8$ | 任意一个点不在 $\ge 2$ 个简单环上 | 无 |
| $9 \sim 14$ | 无 | 保证存在经过所有点的简单路径 |
| $15 \sim 20$ | 无 | 无 |

## 样例 #1

### 输入

```
5 5 6
1 2 10
2 3 2
2 4 5
2 5 4
4 5 3
1 5
2 5
3 5
3 4
4 5
4 4
```

### 输出

```
32
12
16
16
12
0
```

## 样例 #2

### 输入

```
见附件中的 simple/simple_ex2.in```

### 输出

```
见附件中的 simple/simple_ex2.ans```

# 题解

## 作者：xtx1092515503 (赞：14)

就 ZJOI D1 T3 来言，这题事实上并不能说很难（至少我觉得联合省选 D1 T3 要比这题难）。

本题也并没有过于难写，但是感觉问题主要还是在于大样例只有仙人掌。

VP 的时候成功码完了正解，但是赛后一测发现只有四十分。听说有不止一个人和我一样一百挂成四十了。

膜拜赛时写出来的神仙。 

------

这个简单路径求和，想想看可能是个 NP Hard 问题。

怎么办呢？题目中说 **初始保证图上任意两个简单环的边权和相等，然后修改了边权**。

换句话说，本题的图满足 **存在一种重新赋值的方案，使得图上任意两个简单环的边权和相等**。

谁都能看出来这个性质是解决本题的关键。我们来分析一下吧！

首先，本题显然是关于点双独立的：如果每个点双都存在一种赋值的方案，则显然整张图亦存在一种赋值方案。

然后我们手玩几个比较 simple 的点双吧。**以下的点双中所有边都可以是一堆点连成的链，这样两个点间就可以出现重边（因为其对应了不同的链）**。

- 点双是环。显然存在赋值方案。

- 点双是环上连一条链。

    ```
      ----w1----
     /          \
    S-----w2-----T
     \          /
      ----w3----
    ```

    即这样的东西。

    我们发现，只需赋值使得 $w_1=w_2=w_3$，这个情形就是合法的：任意简单环都包含恰两条链，则显然它们的权值都相等。

    不仅如此，假如点双由以 $S,T$ 为端点的若干条链构成，则只需令所有链中边权和全都相等，则显然这个情形亦是合法的。

    我们发现这个东西神似 **细胞分裂中期时，纺锤体和纺锤丝的结构**。

    也有的人把它称作 **杏仁** 或者 **打蛋器**。

    不管它叫什么，这种结构反正是一种合法结构。

- 点双拥有两条平行边。

    ```
    ------w1-------
    |             |
    A-----w2------B
    |             |
    w5           w6
    |             |
    C-----w3------D
    |             |
    ------w4-------
    ```

    即上图。

    我们有如下几个环：
    $$
    \begin{cases}
    w_1+w_2\\
    w_3+w_4\\
    w_1+w_5+w_3+w_6\\
    w_2+w_5+w_4+w_6\\
    w_1+w_5+w_4+w_6\\
    w_2+w_3+w_5+w_6
    \end{cases}
    $$
    我们要存在一组排列方式，使得这六个式子全都相等。

    假如其全部相等，则下式势必成立：
    $$
    (w_1+w_2)+(w_3+w_4)=(w_1+w_5+w_4+w_6)+(w_2+w_3+w_5+w_6)
    $$
    但是当我们把它抵消一下的时候，就会发现其等价于
    $$
    w_5+w_6=0
    $$
    这个式子。

    注意到边权全部为正。故此式不可能成立，也即这种情形不可能有解。

    但是我们可以稍微修改一下定义：我们令一组 $w$ 中可能不含任何边，也即 $w$ 两侧的点可能重合。这时我们发现，只有 $w_5=w_6=0$ 才是合法条件。

    注意到 $w_5=w_6=0$ 意味着 $A,C$ 重合，$B,D$ 重合，整张图退化成杏仁。

    故点双中只要存在平行边，就不合法。就算平行边的端点之一退化在了一起，依照上式其亦不合法。

- 点双拥有两条交叉边。

    ```
    ------w1-------
    |             |
    A--w3---   ---B
    |      |   |  |
    w5 -w4-+---- w6
    |  |   |      |
    C---   |------D
    |             |
    ------w4-------
    ```

    （上图中的 `+` 仅表示两条边交叉了，不表示在该处存在节点）

    仍可仿照之前的证明，导出若该式成立则边权必然为零，留给读者自证。

我们是不是已经考虑了所有类型的点双呢？

考虑往杏仁上随便再添一条边，就会发现其要么与一条边平行，要么与一条边相交，总之不合法。而当我们往环上添一条边后，其必然会得到杏仁。

也即，任意一种往环上加边的流程必然是 环->杏仁->不合法。

这就表明所有合法的态仅可能是杏仁态，而我们已经证明只有杏仁态合法。

------

介于我们已经在关于点双考虑，所以我们自然想着要去建一棵 **圆方树**。

原图中 $S\to T$ 的路径在圆方树中是一条圆点方点交替的路径。其中，**每个圆点都是原图中的必经之点**（因为是割点）。

于是，我们就可以把路径分段：对于每对在路径上相邻的圆点，我们记一个二元组 $(num,sum)$ 表示这两个点间有 $num$ 条路径，其路径和是 $sum$。二元组间可以简单合并。

于是我们现在仅需求出路径上相邻圆点的二元组。

我们考虑把圆方树上 $S\to T$ 的路径拆成 $S\to LCA$ 以及 $LCA\to T$ 两段。每一段中，都是不断跳父亲的过程。

注意到一个圆点的后继节点是 **其在圆方树上的二级父亲**。于是我们预处理出所有点与其在圆方树上二级父亲间的二元组，共计 $O(n)$ 个。则剩下的就仅仅是一次路径查询了。

注意到 LCA 可能是方点，此时我们还要再额外考虑两段路径顶的圆点间的二元组，但这对于每次询问至多只需考虑一个。

则我们若能快速求出两个圆点间的二元组，就可以简单回答询问。

------

考虑如何求出二元组。

这涉及到分类讨论：我们需要分询问涉及到的两个圆点是否在杏仁中的同一条链上，对两种情形分开考虑。

我们首先来考虑在同一条链的情形。假如询问中的某个点是杏仁的“端点”或者细胞分裂模型中的“纺锤体”，也可以被归入该类型。

令 $A,B$ 是杏仁的端点，$S$ 是杏仁中链数，$R$ 是杏仁中所有边的权值和，$x,y$ 两点是询问的点。

不妨令 $x$ 离 $A$ 更近，则 $y$ 离 $B$ 更近。则我们可以简单得出，同一条链的时候，有 $num=S,sum=R+(S-2)\Big(dis(A,x)+dis(B,y)\Big)$。

同理，在不同链的时候，令 $s_x,s_y$ 为两个点所在链的权值和，可以简单得出有 $num=2(S-1),sum=2R+(S-3)(s_x+s_y)$。

这些信息都是可以简单维护的。

------

最后，我们来分析一下复杂度。

建圆方树是显然线性的。

线性对数是显然可以简单实现的。能不能进一步优化呢？

首先求二元组的过程是可以线性预处理、$O(1)$ 查询的。

然后就是路径信息查询了。求 LCA 可以简单离线 Tarjan 做到线性反阿克曼，也可以大力四毛子做到线性。路径信息显然可以倍增做到对数，但是注意到二元组具有可减性，做减法时只需要求逆，用离线线性求逆元的科技即可做到线性。

总复杂度是可以做到线性的，尽管毫无实际意义。

代码是线性对数的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500100;
const int M=640100;
typedef long long ll;
int n,m,q;
const int mod=998244353;
namespace FIFO{
void read(int&x){
	x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
void print(int x){if(x>=10)print(x/10);putchar('0'+x%10);}
}using namespace FIFO;
namespace Tre{
struct node{int to,next,val;}edge[M<<1];
int cnt;
vector<int>v[N<<1],id[N<<1],d[N<<1],chn[N];
int A[N<<1],B[N<<1],S[N<<1],R[N<<1];
vector<ll>disa[N],disb[N];
void ae(int k,int x,int y,int z){
	// printf("AE:%d,%d,%d,%d\n",k,x,y,z);
	x=id[x][lower_bound(v[x].begin(),v[x].end(),k)-v[x].begin()];
	y=id[y][lower_bound(v[y].begin(),v[y].end(),k)-v[y].begin()];
	// printf("%d,%d\n",x,y);
	edge[cnt].next=id[k][x],edge[cnt].to=y,edge[cnt].val=z,id[k][x]=cnt++;
	edge[cnt].next=id[k][y],edge[cnt].to=x,edge[cnt].val=z,id[k][y]=cnt++;
	d[k][x]++,d[k][y]++;
}
struct dat{
int num,sum;
dat(){num=sum=0;}
dat(int _n,int _s){num=_n,sum=_s;}
void print()const{printf("(%d,%d)",num,sum);}
friend dat operator*(const dat&u,const dat&v){
	return dat(1ll*u.num*v.num%mod,(1ll*u.num*v.sum+1ll*u.sum*v.num)%mod);
}
}jum[N][20];
int anc[N<<1][20],dep[N<<1],c;
void ae(int x,int y){v[x].push_back(y),id[x].push_back(v[y].size()),v[y].push_back(x);}
void dfs(int x,int fa){
	// printf("%d->%d\n",fa,x);
	anc[x][0]=fa;for(int i=1;i<20;i++)anc[x][i]=anc[anc[x][i-1]][i-1];dep[x]=dep[fa]+1;
	for(auto y:v[x])if(y!=fa)dfs(y,x);
}
int LCA(int x,int y){
	if(dep[x]>dep[y])swap(x,y);
	for(int i=19;i>=0;i--)if(dep[x]<=dep[y]-(1<<i))y=anc[y][i];
	if(x==y)return x;
	for(int i=19;i>=0;i--)if(anc[x][i]!=anc[y][i])x=anc[x][i],y=anc[y][i];
	return anc[x][0];
}
void ae(int x,int y,int z){
	if(anc[x][0]==anc[y][0])ae(anc[x][0],x,y,z);
	else if(anc[x][1]==y)ae(anc[x][0],x,y,z);
	else if(anc[y][1]==x)ae(anc[y][0],x,y,z);
}
dat calc(int k,int x,int y){
	int _x=lower_bound(v[x].begin(),v[x].end(),k)-v[x].begin();
	int _y=lower_bound(v[y].begin(),v[y].end(),k)-v[y].begin();
//	printf("%d:%d,%d,%d,%d,%d,%d,%d\n",x,v[x].size(),id[x].size(),chn[x].size(),disa[x].size(),disb[x].size(),d[x].size(),_x);
//	printf("%d:%d,%d,%d,%d,%d,%d,%d\n",y,v[y].size(),id[y].size(),chn[y].size(),disa[y].size(),disb[y].size(),d[y].size(),_y);
	int X=id[x][_x];
	int Y=id[y][_y];
	if(X!=A[k]&&Y!=A[k]&&X!=B[k]&&Y!=B[k]&&chn[x][_x]!=chn[y][_y])
	return dat((S[k]-1)<<1,((R[k]<<1)+(disa[x][_x]+disb[x][_x]+disa[y][_y]+disb[y][_y])%mod*(S[k]+mod-3))%mod);
	ll xa,xb,ya,yb;
	if(X==A[k])xa=0,xb=0x3f3f3f3f3f3f3f3f;
	else if(X==B[k])xa=0x3f3f3f3f3f3f3f3f,xb=0;
	else xa=disa[x][_x],xb=disb[x][_x];
	if(Y==A[k])ya=0,yb=0x3f3f3f3f3f3f3f3f;
	else if(Y==B[k])ya=0x3f3f3f3f3f3f3f3f,yb=0;
	else ya=disa[y][_y],yb=disb[y][_y];
	ll _a,_b;
	if(xa>ya)_a=ya,_b=xb;else _a=xa,_b=yb;
	return dat(S[k],(R[k]+(_a+_b)%mod*(S[k]+mod-2))%mod);
}
int calc(int x,int y){
	int z=LCA(x,y);
	// printf("%d(%d,%d)\n",z,x,y);
	dat res(1,0);
	for(int i=19;i;i--)if(dep[z]<=dep[x]-(1<<i))res=res*jum[x][i-1],x=anc[x][i];
	for(int i=19;i;i--)if(dep[z]<=dep[y]-(1<<i))res=res*jum[y][i-1],y=anc[y][i];
	if(x==z&&y==z)return res.sum;
	return (res*calc(z,x,y)).sum;
}
ll walk(int k,int x,int fr,ll ds){
	for(int i=id[k][x],y;i!=-1;i=edge[i].next)if((y=edge[i].to)!=fr){
		disa[v[k][x]].push_back(ds);
		chn[v[k][x]].push_back(S[k]);
		if(y==B[k]){
			disb[v[k][x]].push_back(edge[i].val),R[k]=(ds+edge[i].val+R[k])%mod;
			return edge[i].val;
		}
		ds=walk(k,y,x,ds+edge[i].val)+edge[i].val;
		disb[v[k][x]].push_back(ds);
		return ds;
	}
	return 0;
}
void func(int k){
	A[k]=B[k]=-1;
	for(int i=0;i<d[k].size();i++){
		if(d[k][i]==2)continue;
		if(A[k]==-1)A[k]=i;else B[k]=i;
	}
	if(A[k]==-1&&B[k]==-1)A[k]=0,B[k]=1;
	// printf("FUNC:%d\n",k);
	// for(auto x:v[k])printf("%d ",x);puts("");
	// printf("%d %d\n",A[k],B[k]);
	chn[v[k][A[k]]].push_back(-1),disa[v[k][A[k]]].push_back(-1),disb[v[k][A[k]]].push_back(-1);
	chn[v[k][B[k]]].push_back(-1),disa[v[k][B[k]]].push_back(-1),disb[v[k][B[k]]].push_back(-1);
	for(int i=id[k][A[k]];i!=-1;i=edge[i].next){
		S[k]++;
		if(edge[i].to==B[k]){(R[k]+=edge[i].val)%=mod;continue;}
		walk(k,edge[i].to,A[k],edge[i].val);
	}
}
void init(){
	dfs(1,0);
//	for(int i=1;i<=n;i++)printf("%d %d\n",v[i].size(),id[i].size());
	// for(int i=1;i<=c;i++){printf("%d:",i);for(auto x:v[i])printf("%d ",x);puts("");}
	for(int i=n+1;i<=c;i++)id[i].resize(v[i].size(),-1),d[i].resize(v[i].size());
}
void tini(){
	for(int i=n+1;i<=c;i++)func(i);
	for(int i=2;i<=n;i++)jum[i][0]=calc(anc[i][0],anc[i][1],i);
	// for(int i=2;i<=n;i++)printf("%d:(%d,%d)\n",i,jum[i][0].num,jum[i][0].sum);
	for(int j=1;j<20;j++)for(int i=1;i<=n;i++)jum[i][j]=jum[i][j-1]*jum[anc[i][j]][j-1];
}
}
namespace Gra{
int dfn[N],low[N],tot,stk[N],tp,X[M],Y[M],Z[M];
vector<int>v[N];
void Tarjan(int x){
	dfn[x]=low[x]=++tot,stk[++tp]=x;
	for(auto y:v[x]){
		if(!dfn[y]){
			Tarjan(y),low[x]=min(low[x],low[y]);
			if(low[y]<dfn[x])continue;
			Tre::c++;
			int z;do z=stk[tp--],Tre::ae(z,Tre::c);while(z!=y);
			Tre::ae(x,Tre::c);
			// for(auto z:Tre::v[Tre::c])printf("%d ",z);puts("");
		}else low[x]=min(low[x],dfn[y]);
	}
}
void init(){
	for(int i=1;i<=m;i++)
		read(X[i]),read(Y[i]),read(Z[i]),v[X[i]].push_back(Y[i]),v[Y[i]].push_back(X[i]);
	// for(int i=1;i<=m;i++)printf("%d %d %d\n",X[i],Y[i],Z[i]);
	Tarjan(1);
	Tre::init();
	for(int i=1;i<=m;i++)Tre::ae(X[i],Y[i],Z[i]);
}
}
int main(){
	freopen("simple.in","r",stdin);
	freopen("simple.out","w",stdout);
	read(n),read(m),read(q),Tre::c=n;
	Gra::init();
	Tre::tini();
	for(int i=1,x,y;i<=q;i++)read(x),read(y),print(Tre::calc(x,y)),putchar('\n');
	return 0;
}
```




---

## 作者：Renshey (赞：4)

#### 题解

首先建出圆方树，对于每一个点双进行考虑。

题目给出的性质非常强，仔细分析可以得到，不会出现类似于三个环两两相交的情况，最终结论是一定存在两个点 $S,T$，使得这个点双由若干条 $S \to T$ 的路径构成。这种图似乎被称作杏仁。

考虑求两点间的答案，可以拆到圆方树上拆成若干段之和。首先 $(cnt,sum)$ 这一二元组显然是可逆的，所以可以直接预处理出树上前缀积，只需要求 $O(n+q)$ 次圆点-方点-圆点之间的询问。

在一个点双内对两个圆点是否在同一条链上进行讨论就可以得到答案。具体而言，如果其中至少一个点为杏仁的端点，可以直接视作两个点在同一条链上的情况。

实现时可以先找到杏仁内度数最大的两个点作为端点，然后直接 dfs 预处理出每个点到两个端点的信息，查询时只需要简单分类讨论。具体实现可以参考代码。

时间复杂度 $O(n + q \log n)$，空间复杂度 $O(n)$。

#### 代码

```cpp
#include <bits/stdc++.h>
#define Getchar() p1 == p2 and (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++
char buf[1 << 21], *p1, *p2;
inline int read (void)
{
	int x = 0; char c = Getchar();
	while (c < '0' or c > '9') c = Getchar();
	while (c >= '0' and c <= '9') x = x * 10 + c - 48, c = Getchar();
	return x;
}
const int mod = 998244353;
const int maxn = 1000000 + 10;
int n, m, q, tot, dfn[maxn], low[maxn], times, st[maxn], tp;
int dep[maxn], fa[maxn], siz[maxn], son[maxn], top[maxn], pos[maxn];
std::vector<std::pair<int, int>> e[maxn]; std::vector<int> g[maxn];
inline int power (int x, int y)
{
	int z = 1;
	for (; y; y >>= 1, x = 1LL * x * x % mod) if (y & 1) z = 1LL * z * x % mod;
	return z;
}
struct Data
{
	int cnt, sum;
	inline friend Data operator + (const Data &a, const Data &b) {return (Data){(a.cnt + b.cnt) % mod, (a.sum + b.sum) % mod};}
	inline friend Data operator * (const Data &a, const Data &b)
	{
		int cnt = 1LL * a.cnt * b.cnt % mod;
		int sum = (1LL * a.cnt * b.sum + 1LL * a.sum * b.cnt) % mod;
		return (Data){cnt, sum};
	}
	inline friend Data operator / (const Data &a, const Data &b)
	{
		int inv = power(b.cnt, mod - 2);
		int cnt = 1LL * a.cnt * inv % mod;
		int sum = (a.sum - 1LL * cnt * b.sum % mod + mod) * inv % mod;
		return (Data){cnt, sum};
	}
} dis[maxn];
struct Almond
{
	int S, T, cnt;
	std::unordered_map<int, int> id, dS, dT, dep, sum;
	std::vector<std::array<int, 3>> E;
	inline void add (int u, int v, int w) {E.push_back({u, v, w});}
	inline void dfs (int u, int fr, int dis)
	{
		if (u == T) {sum[0] = (sum[0] + dis) % mod; sum[cnt] = dis; return;}
		id[u] = cnt; dS[u] = dis; dep[u] = dep[fr] + 1;
		for (auto [v, w]: e[u]) if (v != fr) dfs(v, u, (dis + w) % mod);
	}
	inline void build (int p)
	{
		for (auto [u, v, w]: E) e[u].push_back({v, w}), e[v].push_back({u, w});
		for (int u: g[p])
			if (e[u].size() > e[S].size()) T = S, S = u;
			else if (e[u].size() > e[T].size()) T = u;
		for (auto [u, w]: e[S]) cnt++, dfs(u, S, w);
		for (int u: g[p]) if (u != S and u != T) dT[u] = (sum[id[u]] - dS[u] + mod) % mod;
		dep[S] = 0; dep[T] = 1 << 30;
		for (int u: g[p]) std::vector<std::pair<int, int>>().swap(e[u]);
	}
	inline Data calc (int u, int v)
	{
		if (id[u] > id[v]) std::swap(u, v);
		if (id[u] == 0 and id[v] == 0) return (Data){cnt, sum[0]};
		if (id[u] == 0 or id[u] == id[v])
		{
			if (dep[u] > dep[v]) std::swap(u, v);
			return (Data){cnt, (int)((sum[0] + 1LL * (cnt - 2) * (dS[u] + dT[v])) % mod)};
		}
		return (Data){2 * (cnt - 1), (int)((2LL * sum[0] + 1LL * (cnt - 3 + mod) * (sum[id[u]] + sum[id[v]])) % mod)};
	}
} A[maxn];
inline void tarjan (int u)
{
	dfn[u] = low[u] = ++times; st[++tp] = u;
	for (auto [v, w]: e[u])
		if (!dfn[v])
		{
			tarjan(v); low[u] = std::min(low[u], low[v]);
			if (low[v] >= dfn[u])
			{
				auto add = [&] (int u, int v) {g[u].push_back(v); g[v].push_back(u);};
				add(u, ++tot); do add(st[tp], tot); while (st[tp--] != v);
			}
		}
		else low[u] = std::min(low[u], dfn[v]);
}
inline void dfs1 (int u, int fr)
{
	dep[u] = dep[fa[u] = fr] + 1; siz[u] = 1;
	for (int v: g[u]) if (v != fr)
	{
		dfs1(v, u); siz[u] += siz[v];
		if (siz[v] > siz[son[u]]) son[u] = v;
	}
}
inline void dfs2 (int u)
{
	pos[dfn[u] = ++times] = u;
	if (son[u]) top[son[u]] = top[u], dfs2(son[u]);
	for (int v: g[u]) if (v != fa[u] and v != son[u]) top[v] = v, dfs2(v);
}
inline void dfs3 (int u)
{
	if (u > 1 and u <= n) dis[u] = dis[fa[fa[u]]] * A[fa[u]].calc(u, fa[fa[u]]);
	for (int v: g[u]) if (v != fa[u]) dfs3(v);
}
inline int lca (int u, int v)
{
	while (top[u] != top[v]) dep[top[u]] <= dep[top[v]] ? v = fa[top[v]] : u = fa[top[u]];
	return dep[u] < dep[v] ? u : v;
}
inline int up (int u, int x)
{
	x = dep[u] - dep[x] - 1;
	while (dep[u] - dep[fa[top[u]]] <= x) x -= dep[u] - dep[fa[top[u]]], u = fa[top[u]];
	return pos[dfn[u] - x];
}
signed main ()
{
	tot = n = read(); m = read(); q = read();
	for (int i = 1, u, v, w; i <= m; i++) u = read(), v = read(), w = read(), e[u].push_back({v, w}), e[v].push_back({u, w});
	tarjan(1); dfs1(1, 0); top[1] = 1; times = 0; dfs2(1);
	for (int u = 1; u <= n; u++) for (auto [v, w]: e[u]) if (u < v) A[dep[u] <= dep[v] ? fa[v] : fa[u]].add(u, v, w);
	for (int u = 1; u <= n; u++) std::vector<std::pair<int, int>>().swap(e[u]);
	for (int p = n + 1; p <= tot; p++) A[p].build(p);
	dis[1] = (Data){1, 0}; dfs3(1);
	for (int u, v, l; q--; )
	{
		u = read(); v = read(); l = lca(u, v);
		Data ans = (Data){1, 0};
		if (l <= n) ans = (dis[u] / dis[l]) * (dis[v] / dis[l]);
		else
		{
			int x = up(u, l), y = up(v, l);
			ans = (dis[u] / dis[x]) * (dis[v] / dis[y]) * A[l].calc(x, y);
		}
		printf("%d\n", ans.sum);
	}
	return 0;
}
```

---

## 作者：璀璨星空1 (赞：3)

注：这篇题解主要阐述了本题的一个重要结论的证明，缘于 @xtx1092515503 题解的证明和网上一众题解的证明都有很明显的不完全之处；在一些地方的陈述上借鉴了 @xtx1092515503 题解的说法，在这里我还是表达感谢，但是也希望能够将正确的证明传递出去。至于在得到了该结论以后的做法，是相对容易的，各位做 ZJOI 2022 的想必肯定都会，这篇题解就不再赘述了。

在一般图上，求解「两结点间所有简单路径权值和」是困难的 —— 这启示我们从这张图的特殊性质出发思考问题。这张图 $G$ 的特殊性质是什么呢？应该是「存在一种**将 $G$ 的边权重新赋值**的方法，使得**在重新赋值过后**图上任意两个简单环的边权和相等」；我们称这样的图 $G$ 是优雅的。

优雅的图具有什么样的性质？我们很难从正面直接来回答这个问题；因此我们考虑换一个角度，即**具有什么样的性质的图是不优雅的**。我们注意到，有若干个简单环「交织在一起」的图通常来说是不优雅的。经过一些讨论，我们发现如下结论：

分析 $1$.「双弦矛盾」：若 $G$ 的某个子图 $G'$ 形如「一个简单环再加上两条不同的弦」的形式，则 $G$ 一定是不优雅的。

这里「加上两条不同的弦」指的是：在该简单环上存在两对(不完全相同的)无序结点对 $(u_0,v_0)$ 和 $(u_1,v_1)$，使得 $u_0$ 到 $v_0$ 之间、$u_1$ 到 $v_1$ 之间分别存在两条(除在顶点处外)不相交的路径 $u_0\sim v_0$ 和 $u_1\sim v_1$，当然这两条路径都是不能使用任何在该简单环上的边的。

![ABC.png](https://s2.loli.net/2022/05/16/cRik1GMAbZxpE9Y.png)

一种情况如上图所示，其中 $A\sim B\sim C$ 是我们关注的简单环，$A\sim X\sim B$ 和 $A\sim Y\sim C$ 是该环上加上的两条弦。注意该图上的任意一条边**都可以代表 $G'$ 中的一条路径**。

注意到 $(A\sim X\sim B)\sim A$ 和 $(A\sim X\sim B)\sim C\sim A$ 是两个简单环，二者的边权和一定相等 —— 这也就是说，$B\sim A$ 的长度等于 $B\sim C\sim A$ 的长度；但是从另一方面来说，$(A\sim Y\sim C)\sim A$ 和 $(A\sim Y\sim C)\sim B\sim A$ 也是两个简单环，二者的边权和也一定相等，这意味着 $C\sim A$ 的长度等于 $C\sim B\sim A$ 的长度；综上，$B\sim C$ 的长度一定为零，而这显然与「正整数边权」相矛盾。

也就是说，这一种情况肯定是不能出现在 $G'$ 中的。

![ABCD.png](https://s2.loli.net/2022/05/16/njlWTLAeoPKIb2i.png)

另一种情况如上图所示，其中 $A\sim B\sim C\sim D$ 是我们关注的简单环，$A\sim X\sim C$ 和 $B\sim Y\sim C$ 是该环上加上的两条弦。注意该图上的任意一条边仍可以代表 $G'$ 中的一条路径。

类似于刚才的论证，我们必有 $A\sim C$ 的长度等于 $A\sim X\sim C$ 的长度，同理 $B\sim D$ 的长度等于 $B\sim Y\sim D$ 的长度；而 $(A\sim X\sim C)\sim A$ 和 $(B\sim Y\sim D)\sim B$ 又是两个边权和一定相等的简单环，故而这四个长度一定两两相等。然而 $(A\sim C)\sim(D\sim B)$ 也是一个边权和与之相等的简单环，因而 $A\sim B$ 的长度、$C\sim D$ 的长度二者都一定为零，再一次与「正整数边权」相矛盾。

也就是说，这一种情况也是不能出现在 $G'$ 中的，这样就完整地阐明了「双弦矛盾」。

这样一来，在一个环上还能出现什么结构呢？「双弦矛盾」指出了在一个环上不能存在两条不同的弦，然而一个环上可以存在的是**多条相同的弦**，即无序结点对 $(u,v)$ 之间存在多条不相交的路径 $u\sim v$，如下图所示：

![AB.png](https://s2.loli.net/2022/05/16/aFmxq62jyIOpNUH.png)

其中 $A\sim B\sim C$ 是我们关注的简单环，$A\sim X\sim B$、$A\sim Y\sim B$、$A\sim Z\sim B$ 是 $A,B$ 之间的多条弦：这样的结构是合法的。现在，从单个环的角度出发已经得不到什么有意义的结论，考虑将目光转向**多个环之间的位置关系**的层面上。

受到「任意一个点不在 $\geq2$ 个简单环上」的部分分(即 $G$ 是**点仙人掌**时的情形)的启发，我们考虑 $G$ 的**点双连通分量**；显然「$G$ 是否是优雅的」这件事是「点双独立的」，即「$G$ 是优雅的」的充分必要条件是「$G$ 的每个点双连通分量都是优雅的」，这是因为跨两个不同的点双连通分量之间是不存在环的。那么，一张点双连通图 $C$ 什么时候是优雅的？我们有以下结论：

分析 $2$. 一张点双连通图 $C$ 是优雅的，当且仅当 $C$ 形如「一个简单环再加上若干条相同的弦」的形式(除却 $C$ 只包含有两个结点的特殊情形以外)。

也就是说在 $C$ 中，除却某两个结点 $S,T$ 以外，其他所有结点的度数都 $=2$。我们考虑寻找到两个 $\geq3$ 度的结点 $S,T$，我们希望 $S,T$ **共处在一个环上且还存在 $S,T$ 之间的弦**(即 $S,T$ 之间存在 $3$ 条不相交的路径)，因为这样一来，$C$ 的结构就已经大致确定下来了。

考虑点双连通图的性质：在点双连通图中，**过任意两个结点 $u,v$ 一定存在一个简单环**。除却特殊情形以外，由于 $C$ 是点双连通图，故而 $C$ 中一定存在至少一个简单环；我们考虑其中任意一个简单环。

考虑该简单环上的结点分别被哪些简单环所包含：若存在另外一个简单环，与该简单环拥有 $\geq2$ 个交点，则若两简单环之间的交是**连续的一段**，则显然可以去该连续段的段首段尾作为 $S,T$；否则我们选取靠得最近的两个(其之间交的部分**不连续的**)交点作为 $S,T$，则 $S,T$ 除了共处在原来的简单环上以外，又有另外一个环上的路径作为一条弦，二者之间就找到了 $3$ 条不相交的路径。

否则若存在另外一个简单环与其恰拥有 $1$ 个交点，设该交点是 $\tau$，我们在两个简单环上各取一个 $\tau$ 以外的结点 $u,v$，则由点双连通图的性质可知过 $u,v$ 一定存在一个简单环；前面已经说过，若 $C$ 中存在两个有 $\geq2$ 个交点的简单环则 $S,T$ 就已经找到，故而我们可以假设 $C$ 中任意两个简单环的交点个数 $\leq1$；因此，该「过 $u,v$ 的简单环」与原来简单环的交点**只有** $u$、与另一个简单环的交点**只有** $v$；故而可以直接取 $u,v$ 作为 $S,T$，则 $S,T$ 除了共处在该「过 $u,v$ 的简单环」以外，又有 $u\sim\tau\sim v$ 作为一条弦，二者之间也就找到了 $3$ 条不相交的路径。

最后若所有其他的简单环与其都没有任何交点，说明 $C$ 就是该简单环，这样的情形显然是符合要求的。

否则的话，我们就找到了两个节点 $S,T$，其之间存在着 $3$ 条不相交的路径。将 $S,T$ 与这 $3$ 条不相交的路径**看作一个「整体」**，我们考虑把 $C$ 的其他部分全部都整合到这个「整体」里来。

删去该「整体」的所有边后，若该「整体」中的所有结点的度数均 $=0$，则说明 $C$ 就是该「整体」，论证结束；否则若还存在度数 $\neq0$ 的结点 $u$，我们从 $u$ 出发任意游走，最后**总能够游走到该「整体」中的另外一个节点 $v$ 上**(否则 $u$ 就是割点了，与点双的条件相矛盾)。考虑 $u,v$，若 $(u,v)=(S,T)$，则直接**将「游走路径」加入到该「整体」当中去**即可；否则分类讨论：(1) $\{u,v\}$ 中存在 $S$ 或 $T$ (2) $u,v$ 原来在该「整体」中的同一条弦上 (3) $u,v)$ 原来在该「整体」中不同的两条弦上，容易说明矛盾。

这样一来，我们就说明了一张点双连通图 $C$ 是优雅的的充分必要条件。

---

## 作者：ningago (赞：2)

由于可怜告诉我们原图有特殊性质，并且这个性质在新图上已经寄了，所以自然要考虑图的形态有哪些性质。

由于 ~~子任务有仙人掌~~ 两点之间路径所经过的点双是确定的，而两点双之间的路径是唯一的，所以想到对于每个点双分开考虑。

容易发现，如果对于每个点双，都存在合法赋值方案，那么可以通过扩大倍数的方式，使得整个图有合法赋值方案。

考虑简单一点的点双：一个环（也就是仙人掌）：由于只有一个环，赋值方案必然存在。

考虑简单两点的点双：一个环，但环中某一点向另外一点有一条横叉边：

![](https://cdn.luogu.com.cn/upload/image_hosting/ppcror3b.png)

根据题目条件，若 $A,B,C$ 表示所示区域的边权和（下同），不难推导出有 $A=B=C$。赋值方案必然存在。

考虑简单三点的点双：一个环和一条横叉边，或者说有三条同源同汇的路径，其中一条路径向另一条路径有一条横叉边（连向同一条路径的可以同样证明）：

![](https://cdn.luogu.com.cn/upload/image_hosting/r4k2xxhg.png)

根据条件，必然有 $a+b+c=f+c+e=a+e+c+d=f+b+c+d$。联立解得 $d=0$。

考虑 $d=0$ 的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/pyatlmxr.png)

根据之前的讨论，显然有 $a=e=b+c=d+c$，则必然有 $b=d$，而又存在 $b+d=a+e$，则 $a=b=d=e$，所以满足条件的只有 $c=0$，即**同源同汇的四条路径**。

由于没有其他的加边方式，所以得出：**满足条件的点双，必然是同源同汇的若干条路径**。

至此，我们总结出了图的性质，然后回到问题中去：

显然在圆方树上解决问题是方便的。对于每个点双，需要维护他内部从某一点到某一点的路径边权和，且需要快速合并两个不同点双的边权和。所以记录出路径的方案数，记作二元组 $(cnt,sum)$，类似笛卡尔积地合并即可（$\epsilon=(1,0)$）。

圆点到方点的边权即为其到点双根的二元组。

分 $S\to T/T\to S/S\to x/x\to S/T\to x/x\to T/x\to y/x\to z$ 讨论，容易求解出同一点双内任意两点之间的二元组。

![](https://cdn.luogu.com.cn/upload/image_hosting/pfgeapkt.png)

建出圆方树，预处理出每个点到根的二元组（二元组具有可差分性），特判 lca 是圆点还是方点，相应地合并即可。

复杂度 $O(n\log n)$。

蒟蒻代码写得有亿点繁琐 qAq。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>

#define N 1000010
#define M 1300010
#define int long long
#define mod 998244353

int n,m,Q;
int ksm(int a,int b)
{
	int res = 1;
	while(b)
	{
		if(b & 1)
			res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;
}
struct node
{
	int num,sum;
	node operator * (const node &B)const
	{
		return (node){num * B.num % mod, (num * B.sum % mod + sum * B.num % mod) % mod};
	}
	node operator / (const node &B)const
	{
		node res;
		res.num = num * ksm(B.num, mod - 2) % mod;
		res.sum = (sum - res.num * B.sum % mod + mod) % mod * ksm(B.num, mod - 2) % mod;
		return res;
	}
};
int h[N],from[M << 1],e[M << 1],ne[M << 1],v[M << 1],idx = -1;
node f[M << 1];
void add_edge(int x,int y,int z)
{
	ne[++idx] = h[x];
	h[x] = idx;
	e[idx] = y;
	v[idx] = z;
	from[idx] = x;
}
void add(int x,int y,int z)
{
	add_edge(x,y,z);
	add_edge(y,x,z);
}
void add_edge_(int x,int y,node z)
{
	ne[++idx] = h[x];
	h[x] = idx;
	e[idx] = y;
	f[idx] = z;
}
void add_(int x,int y,node z)
{
	add_edge_(x,y,z);
	add_edge_(y,x,z);
}

struct Edge
{
	int x,y;
	node z;
}eg[M];
int egidx;

int dfn[N],dfncnt,low[N];
struct SCC
{
	int S,T;
	std::vector <int> a;
	std::map <signed,int> disS,disT;
	std::map <signed,signed> from,id;
	int sumval;
	int cnt;
	int val(int x){	return (disS[x] + disT[x]) % mod;}
	node get_dis(int x,int y)
	{
		if(x == y)
			return (node){1ll,0ll};
		if(y == S)
			x ^= y ^= x ^= y;
		if(x == S && y == T)
			return (node){cnt, sumval};
		if(x == S)
			return (node){cnt, (disS[y] + (cnt - 1) * disT[y] % mod + sumval + mod - val(y)) % mod};
		if(y == T)
			x ^= y ^= x ^= y;
		if(x == T && y == S)
			return (node){cnt, sumval};
		if(x == T)
			return (node){cnt, (disT[y] + (cnt - 1) * disS[y] % mod + sumval + mod - val(y)) % mod};
		if(from[x] == from[y])
		{
			if(id[x] > id[y])
				x ^= y ^= x ^= y;
			return (node){cnt, ((disT[x] - disT[y] + mod) % mod + (cnt - 1) * (disS[x] + disT[y]) % mod + (sumval + mod - val(x)) % mod) % mod};
		}
		return (node){2ll * (cnt - 1) % mod, ((cnt - 1) * ((disS[x] + disT[x] + disS[y] + disT[y]) % mod) % mod + 2ll * (sumval - val(x) + mod - val(y) + mod) % mod) % mod}; 
	}
}scc[N];
int sc;
struct Stack
{
	int sta[M],len;
	void push(int x){sta[++len] = x; }
	void pop(){len--; }
	int top(){return sta[len]; }
	bool empty(){return !len; }
	void clear(){len = 0; }
}sta;

void Add(int x,node z)
{
	eg[++egidx] = (Edge){sc, x, z};
}

bool vis[N];
int du[N];

std::vector <int> g[N];
std::vector <int> w[N];

void dfsS(int k,int fa,int dep)
{
	if(k == scc[sc].T)
		return;
	scc[sc].disS[k] = dep;
	int sz = g[k].size();
	for(int i = 0; i < sz; i++)
	{
		int nx = g[k][i];
		if(nx == fa)
			continue;
		dfsS(nx, k, (dep + w[k][i]) % mod);
	}
}

void dfsT(int k,int fa,int dep)
{
	if(k == scc[sc].S)
		return;
	scc[sc].disT[k] = dep;
	int sz = g[k].size();
	for(int i = 0; i < sz; i++)
	{
		int nx = g[k][i];
		if(nx == fa)
			continue;
		dfsT(nx, k, (dep + w[k][i]) % mod);
	}
}

void tarjan(int k, int in_edge)
{
	low[k] = dfn[k] = ++dfncnt;
	for(int i = h[k]; ~i; i = ne[i])
	{
		if(i == (in_edge ^ 1))
			continue;
		int nx = e[i];
		if(!dfn[nx])
		{
			sta.push(i);
			tarjan(nx, i);
			low[k] = std::min(low[k], low[nx]);
			if(low[nx] > dfn[k])
			{
				sta.pop();
				sc++;
				Add(k, (node){1, 0});
				Add(nx, (node){1, v[i]});
				scc[sc].S = k;
				scc[sc].T = nx;
				scc[sc].cnt = 1;
				scc[sc].sumval = v[i];
			}
			else if(low[nx] == dfn[k])
			{
				sc++;
				while(1)
				{
					int id = sta.top();
					sta.pop();
					if(!vis[e[id]])
						vis[e[id]] = 1, scc[sc].a.push_back(e[id]);
					if(!vis[from[id]])
						vis[from[id]] = 1, scc[sc].a.push_back(from[id]);
					du[from[id]]++;
					du[e[id]]++;
					g[from[id]].push_back(e[id]);
					w[from[id]].push_back(v[id]);
					g[e[id]].push_back(from[id]);
					w[e[id]].push_back(v[id]);
					if(id == i)
						break;
				}
				int sz = scc[sc].a.size();
				for(int i = 0; i < sz;i++)
				{
					int t = scc[sc].a[i];
					if(du[t] >= 3)
					{
						if(scc[sc].S)
							scc[sc].T = t;
						else
							scc[sc].S = t;
					}
				}
				if(!scc[sc].S)
					scc[sc].S = scc[sc].a[0], scc[sc].T = scc[sc].a[1];
				dfsS(scc[sc].S, 0, 0);
				dfsT(scc[sc].T, 0, 0);
				int len = g[scc[sc].S].size();
				for(int i = 0; i < len;i++)
				{
					scc[sc].cnt++;
					int nx = g[scc[sc].S][i];
					if(nx == scc[sc].T)
						scc[sc].sumval += w[scc[sc].S][i];
					else
						scc[sc].sumval += scc[sc].val(nx);
					int now = 0,fa = scc[sc].S;
					while(nx != scc[sc].T)
					{
						scc[sc].from[nx] = scc[sc].cnt;
						scc[sc].id[nx] = ++now;
						int fa_ = nx;
						if(g[nx][0] != fa)
							nx = g[nx][0];
						else
							nx = g[nx][1];
						fa = fa_;
					}
				}
				scc[sc].sumval %= mod;
				for(int i = 0; i < sz;i++)
				{
					int t = scc[sc].a[i];
					Add(t, scc[sc].get_dis(t, k));
					du[t] = vis[t] = 0;
					g[t].clear();
					w[t].clear();
				}
			}
		}
		else if(dfn[nx] < dfn[k])
		{
			sta.push(i);
			low[k] = std::min(low[k], dfn[nx]);
		}
	}
}

int kfa[N][21];
int dep[N];
node dis[N];

void dfs(int k, int fa)
{
	kfa[k][0] = fa;
	for(int i = 1; i <= 20; i++)
	{
		kfa[k][i] = kfa[kfa[k][i - 1]][i - 1];
		if(!kfa[k][i])
			break;
	}
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(nx == fa)
			continue;
		dis[nx] = dis[k] * f[i];
		dep[nx] = dep[k] + 1;
		dfs(nx, k);
	}
}

int get_lca(int x,int y)
{
	if(dep[x] < dep[y])
		x ^= y ^= x ^= y;
	for(int i = 20;~i;i--)
		if(kfa[x][i] && dep[kfa[x][i]] >= dep[y])
			x = kfa[x][i];
	if(x != y)
	{
		for(int i = 20;~i;i--)
			if(kfa[x][i] != kfa[y][i])
				x = kfa[x][i], y = kfa[y][i];
		x = kfa[x][0];
	}
	return x;
}

signed main()
{
	memset(h,-1,sizeof(h));
	n = read(), m = read(), Q = read();
	for(int i = 1,x,y,z;i <= m;i++)
	{
		x = read(), y = read(), z = read();
		add(x,y,z);
	}
	sc = n;
	tarjan(1,-1);
	memset(h,-1,sizeof(h));
	idx = -1;
	memset(ne,0,sizeof(ne));
	for(int i = 1;i <= egidx;i++)
		add_(eg[i].x, eg[i].y, eg[i].z);
	dis[1] = (node){1,0};
	dfs(1, 0);
	for(int _ = 1,x,y; _ <= Q; _++)
	{
		x = read(), y = read();
		int p = get_lca(x,y);
		int x_ = x, y_ = y;
		if(p <= n)
		{
			node res = (node){1,0};
			for(int i = 20;~i;i--)
				if(kfa[x][i] && dep[kfa[x][i]] >= dep[p])
					x = kfa[x][i];
			for(int i = 20;~i;i--)
				if(kfa[y][i] && dep[kfa[y][i]] >= dep[p])
					y = kfa[y][i];
			res = res * (dis[x_] / dis[x]);
			res = res * (dis[y_] / dis[y]);
			printf("%lld\n",res.sum);
		}
		else
		{
			node res = (node){1,0};
			for(int i = 20;~i;i--)
				if(kfa[x][i] && dep[kfa[x][i]] > dep[p])
					x = kfa[x][i];
			for(int i = 20;~i;i--)
				if(kfa[y][i] && dep[kfa[y][i]] > dep[p])
					y = kfa[y][i];
			res = res * (dis[x_] / dis[x]);
			res = res * (dis[y_] / dis[y]);
			res = res * scc[p].get_dis(x,y);
			printf("%lld\n",res.sum);
		}
	}
	return 0;
}
```

---

## 作者：Fzrcy (赞：1)

先考虑题目给出的性质：**修改前的图**满足任意两个简单环的边权和相等，换句话说，我们可以对图的边权重新赋值，使得任意一个点双内的两个简单环的权值之和相同。

于是我们考虑在什么形状的点双会满足该性质。

- 当点双是一个环时，满足该性质。
- 给该点双加上一条 $S$ 到 $T$ 的链时，仍然满足该性质。
- 给该点双加上一条 $a$ 到 $b$ 的链（与 $S$ 到 $T$ 的链不相交）时，不满足该性质。
- 给该点双加上一条 $a$ 到 $b$ 的链（与 $S$ 到 $T$ 的链在非端点处相交）时，仍然不满足该性质。
- 给该点双加上一条 $a$ 到 $b$ 的链（与 $S$ 到 $T$ 的链仅在端点处相交）时，满足该性质。
- 给该点双加上一条 $x$ 到 $y$ 的链（和 $S$ 到 $T$ 的链、 $a$ 到 $b$ 的链均在端点处相交）时，仍然满足该性质。
- ......
- 可以发现以上几种情况已经覆盖了所有类型的点双。
- 所以一个满足该性质的点双一定由若干条 $S$ 到 $T$ 的链（只在 $S$ 和 $T$ 处相交）组成。

因此我们可以在 $O(1)$ 的复杂度求出在同一个点双的两个点 $x$ 和 $y$ 之间的简单路径的权值和和方案数（根据 $x$ 和 $y$ 是否在同一条链上分类讨论即可），用两元组 $(val,num)$ 表示。

对图建立圆方树，然后对点 $x$ 求出 $x$ 和 $fa_{fa_x}$ 之间的简单路径的权值和和方案数 $(val_x,num_x)$。

我们只需圆方树上 $x$ 到 $y$ 的路径上的圆点 $t$ 的 $(val_t,num_t)$ 即可求出原图中 $x$ 到 $y$ 的所有简单路径权值和。注意要特判 $\operatorname{lca}(x,y)$ 时方点的情况。

总时间复杂度为 $O(n\log n)$，可以做到 $O(n)$，但是没意义。注意：预处理不要退化到 $O(n^2)$。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
bool M1;
constexpr int N=2e6+9;
constexpr int mo=998244353;

ll ksm(ll x,ll y=mo-2){
    ll res=1;x%=mo;
    for(;y;y>>=1,x=x*x%mo)
        if(y&1)res=res*x%mo;
    return res;
}
struct dt{
    ll f,g; dt(){g=1,f=0;} dt(ll _f,ll _g){f=_f%mo,g=_g%mo;}
    dt operator * (dt o){return dt((f*o.g%mo+g*o.f%mo)%mo,g*o.g%mo);}
    dt operator / (dt o){
        ll pf,pg=g*ksm(o.g)%mo;
        pf=((f-pg*o.f)%mo+mo)%mo*ksm(o.g)%mo;
        //assert((dt(pf,pg)*o).f==f);
        return dt(pf,pg);
    }
};

int h[N],nt[N*6],to[N*6],cnt,w[N*6];
void add(int u,int v,int w){
    nt[++cnt]=h[u],h[u]=cnt,to[cnt]=v,::w[cnt]=w;
    nt[++cnt]=h[v],h[v]=cnt,to[cnt]=u,::w[cnt]=w;
}

vector<int>e[N];
int st[N][21],dep[N],Fa[N];
void dfs(int u,int fa){
    //if(fa)cerr<<u<<' '<<fa<<'\n';
    dep[u]=dep[fa]+1,Fa[u]=fa,st[u][0]=fa;
    for(int i=1;i<21;i++)st[u][i]=st[st[u][i-1]][i-1];
    for(int v:e[u])if(v^fa)dfs(v,u);
}

int n,m,q,nc;

int du[N];
struct dsu{
    struct node{int x,y;ll z;};
    unordered_map<int,ll>ps,pt;
    unordered_map<int,int>id;
    vector<node>edge;
    vector<int>nod;
    int idc,S,T;
    ll sum;
    void AddEdge(int x,int y,ll z)
        {edge.push_back({x,y,z}),sum=(sum+z)%mo;}
    void dfs_S(int u,int fa,ll d){
        ps[u]=d;
        if(u==T)return;
        for(int i=h[u],v;i;i=nt[i])
            if((v=to[i])!=fa)
                dfs_S(v,u,(d+w[i]));
    }
    void dfs_T(int u,int fa,ll d){
        pt[u]=d;
        if(u==S)return;
        for(int i=h[u],v;i;i=nt[i])
            if((v=to[i])!=fa)
                dfs_T(v,u,(d+w[i]));
    }
    void cid(int u,int fa){
        if(u==T)return;
        id[u]=idc;
        for(int i=h[u],v;i;i=nt[i])
            if((v=to[i])!=fa)
                cid(v,u);
    }
    void Print(){
        cout<<S<<' '<<T<<' '<<nod.size()<<' '<<'\n';
        cout<<"dist to S:\n";
        for(int i:nod)cout<<i<<' '<<ps[i]<<'\n';
        cout<<'\n';
        cout<<"dist to T:\n";
        for(int i:nod)cout<<i<<' '<<pt[i]<<'\n';
        cout<<'\n';
        cout<<"idx:\n";
        cout<<idc<<'\n';
        for(int i:nod)cout<<i<<' '<<id[i]<<'\n';
        cout<<'\n';
    }
    void init(){
        for(auto i:edge){
            if(!id.count(i.x)) nod.push_back(i.x),id[i.x]=1;
            if(!id.count(i.y)) nod.push_back(i.y),id[i.y]=1;
            ++du[i.x],++du[i.y],add(i.x,i.y,i.z);
        }
        id.clear();
        sort(nod.begin(),nod.end(),
            [=](int x,int y){return du[x]>du[y];});
        S=nod[0],T=nod[1];
        dfs_S(S,0,0),dfs_T(T,0,0);
        ps[T]=1e18,pt[S]=1e18;
        for(int i=h[S];i;i=nt[i])
            ++idc,cid(to[i],S);
        // Print();
        // clear
        for(int i:nod)du[i]=h[i]=0;
        cnt=0;
    }
    dt calc(ll x,ll y){
        if(ps[x]>ps[y])swap(x,y);
        if(!id[x]||!id[y]){
            if(x==S&&y==T) return dt(sum%mo,idc);
            if(x==S) return dt((sum%mo+pt[y]%mo*(idc-2)%mo)%mo,idc);
            if(y==T) return dt((sum%mo+ps[x]%mo*(idc-2)%mo)%mo,idc);
        }
        if(id[x]==id[y])
            return dt((sum%mo+(ps[x]+pt[y])%mo*(idc-2)%mo)%mo,idc);
        ll t=((ps[x]+ps[y])%mo+(pt[x]+pt[y])%mo)%mo;
        return dt((sum*2ll%mo+t*(idc-3)%mo)%mo,2ll*(idc-1)%mo);
    }
}A[1000100];

namespace Tarjan{
    int dfn[N],low[N],dft;
    int st[N],top;
    void Tar(int u,int fa){
        st[++top]=u,dfn[u]=low[u]=++dft;
        for(int i=h[u],v;i;i=nt[i])if((v=to[i])!=fa){
            if(!dfn[v]){
                Tar(v,u),low[u]=min(low[u],low[v]);
                if(low[v]>=dfn[u]){
                    ++nc,e[nc].push_back(u);
                    e[u].push_back(nc);
                    for(int x=0;x!=v;top--)
                        x=st[top],
                        e[x].push_back(nc),
                        e[nc].push_back(x);
                }
            }
            else low[u]=min(low[u],dfn[v]);
        }
    }
}

dt ss[N];
void dg(int u,int fa){
    ss[u]=dt(0,1);
    if(u<=n&&u>1)ss[u]=A[st[u][0]].calc(u,st[u][1])*ss[st[u][1]];
    for(int v:e[u])if(v^fa)dg(v,u);
}
int sol(int x,int y){
    dt cur=ss[x]*ss[y];
    if(dep[x]<=dep[y])swap(x,y);
    for(int i=20;~i;i--)
        if(dep[st[x][i]]>=dep[y])
            x=st[x][i];
    if(x==y)return (cur/ss[x]/ss[y]).f%mo;
    for(int i=20;~i;i--)
        if(st[x][i]^st[y][i])
            x=st[x][i],y=st[y][i];
    if(st[x][0]>n){
        cur=cur/ss[x]/ss[y];
        cur=cur*A[st[x][0]].calc(x,y);
    }
    else{
        x=st[x][0];
        cur=cur/ss[x]/ss[x];
    }
    return cur.f%mo;
}

bool M2;
int main(){
    //freopen("a.in","r",stdin);
    //freopen("a.out","w",stdout);
    cerr<<1.*((&M2)-(&M1))/1024./1024.<<'\n';
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    clock_t T1=clock();
    cin>>n>>m>>q;
    for(int i=1,x,y,z;i<=m;i++)
        cin>>x>>y>>z,add(x,y,z);
    nc=n,Tarjan::Tar(1,0);
    cerr<<"Fine"<<'\n';
    dfs(1,0);
    for(int u=1;u<=n;u++)for(int i=h[u],v;i;i=nt[i])
        if((v=to[i])>u)A[(dep[u]>=dep[v]?Fa[u]:Fa[v])].AddEdge(u,v,w[i]);
    memset(h,0,sizeof h),cnt=0;
    for(int i=n+1;i<=nc;i++)A[i].init();
    //cerr<<A[8].calc(1,2).g<<'\n';
    dg(1,0);
    //cerr<<ss[5].f<<'\n';
    while(q--){
        int x,y;
        cin>>x>>y;
        cout<<(sol(x,y)%mo+mo)%mo<<'\n';
    }
    clock_t T2=clock();
    cerr<<1000.*(T2-T1)/CLOCKS_PER_SEC<<'\n';
    return 0;
}
```



---


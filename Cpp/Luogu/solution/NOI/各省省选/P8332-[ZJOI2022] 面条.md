# [ZJOI2022] 面条

## 题目背景

忍，爱丽丝，绫和阳子一众千辛万苦地总算出好了第一试，按原先计划，可怜会出第二试。

“不好了，可怜给我发信息说她降落后被拉去隔离 30 天了，没有电脑，出不了题”，绫突然收到了不幸的消息。

“那咋办？没 idea 了，编不出来了啊！” 众人慌作一团。

看了看日期，离 ZJOI 还有一周。

欲知后事如何，请看下回分解。

## 题目描述

九条可怜是一个喜欢吃拉面的女孩子。

有一天她去吃拉面，她发现拉面师傅为她拉的是一个长度为 $n$ 的面条，$n$ 保证是偶数，一开始第 $i$ 个位置调料的数量是 $a_i$。

如下过程称为一次 “拉面”：

1. 将面条对折，面条的长度会变成 $\frac{n}{2}$，第 $i$ 个位置的调料数量会变为原来第 $i$ 个位置的调料与第 $n - i + 1$ 个位置的调料数量之和，如果新面条第 $i$ 个位置的调料数量为 $b_i$，那么满足 $b_i = a_i + a_{n - i + 1}$。
2. 将面条拉回原来的长度 $n$，每个位置会变为两个位置，并且调料数量会均分，如果现在的第 $i$ 个位置的调料数量是 $a'_i$，那么 $a'_i = \frac{1}{2} \times b_{\left\lceil \frac{i}{2} \right\rceil}$。

现在对于一个固定的 $x$，你需要回答 $q$ 个询问，每次面条经过 $k$ 次 “拉面” 后，第 $x$ 个位置的调料数量。你只需要求出答案对 $998244353$ 取模的结果。具体地，即如果答案的最简分数表示为 $\frac{a}{b}$，输出 $a \times b^{-1} \bmod 998244353$。

## 说明/提示

**【样例解释 #1】**

第一组测试数据中，$\{ a_i \}$ 初始为 $\{ 1, 4, 2, 3 \}$。  
操作一次后为 $\{ 2, 2, 3, 3 \}$。  
操作两次后为 $\{ \frac{5}{2}, \frac{5}{2}, \frac{5}{2}, \frac{5}{2} \}$。

其中生成询问为：  
询问位置：$x = 1$；  
第一个询问：$k = 0$，$a_x = 1$；  
第二个询问：$k = 1$，$a_x = 2$；  
答案为 $(1 \times 1) \oplus (2 \times 2) = 4 \oplus 1 = 5$。

第二组测试数据中，$\{ a_i \}$ 初始为 $\{ 6, 2, 5, 3, 1, 4 \}$。  
操作一次后为 $\{ 5, 5, \frac{3}{2}, \frac{3}{2}, 4, 4 \}$。  
操作两次后为 $\{ \frac{9}{2}, \frac{9}{2}, \frac{9}{2}, \frac{9}{2}, \frac{3}{2}, \frac{3}{2} \}$。

其中生成询问为：  
询问位置：$x = 3$；  
第一个询问 $k = 2$，$a_x = \frac{9}{2}$，$\frac{9}{2} \equiv 499122181 \pmod{998244353}$；  
第二个询问 $k = 0$，$a_x = 5$；  
答案为 $(499122181 \times 1) \oplus (5 \times 2) = 499122181 \oplus 10 = 499122191$。

**【数据范围】**

对于所有测试点：保证 $T \le 10$，$\sum n \le 2 \times {10}^6$，$\sum q \le 5 \times {10}^7$，$k_{\mathrm{max}} \le {10}^{18}$，$1 \le x \le n$，$0 \le a_i < 998244353$，$0 \le \mathit{seed} \le 2^{60} - 1$，保证 $n$ 是偶数。

注意，对于样例，测试点编号 $\mathit{test}$ 为 $0$。

每个测试点的具体限制见下表：

| 测试点编号 | $\sum n \le$ | $\sum q \le$ | $k_{\mathrm{max}} \le $ | 特殊限制 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $500$ | $500$ | $500$ | 无 |
| $2$ | $2 \times {10}^6$ | $2 \times {10}^6$ | $10$ | 无 |
| $3$ | $2 \times {10}^6$ | $2 \times {10}^6$ | ${10}^{18}$ | $n = 2^k$ |
| $4$ | $50$ | $50$ | ${10}^{18}$ | 无 |
| $5 \sim 6$ | $150$ | $150$ | ${10}^{18}$ | 无 |
| $7$ | $2 \times {10}^6$ | $2 \times {10}^6$ | ${10}^{18}$ | $n = 98304$ |
| $8 \sim 9$ | $500$ | $500$ | ${10}^{18}$ | 无 |
| $10 \sim 11$ | $5 \times {10}^3$ | $2 \times {10}^6$ | ${10}^{18}$ | 无 |
| $12 \sim 13$ | $2 \times {10}^6$ | $50$ | ${10}^{18}$ | 无 |
| $14 \sim 16$ | ${10}^6$ | ${10}^5$ | ${10}^{18}$ | 无 |
| $17 \sim 18$ | $2 \times {10}^6$ | $2 \times {10}^7$ | ${10}^{18}$ | 无 |
| $19 \sim 20$ | $2 \times {10}^6$ | $5 \times {10}^7$ | ${10}^{18}$ | 无 |

**【附录】**

```cpp
#include <bits/stdc++.h>
using namespace std;

unsigned long long rd (unsigned long long &x) {
	x ^= (x << 13);
	x ^= (x >> 7);
	x ^= (x << 17);
	return x;
}

int main () {
	int test, T;
	unsigned long long seed;
	scanf("%d%d%llu", &test, &T, &seed);
	for (int Case = 1; Case <= T; Case ++) {
		int n, q, x;
		long long k_max;
		scanf("%d%d%d%lld", &n, &q, &x, &k_max);
		vector<int> a(n + 1);
		for (int i = 1; i <= n; i ++) {
			scanf("%d", &a[i]);
		}
		for (int i = 1; i <= q; i ++) {
			long long k = rd(seed) % k_max;
			/∗
			Code your solution here.
			∗/
		}
	}
}
```

## 样例 #1

### 输入

```
0 2 13
4 2 1 3
1 4 2 3
6 2 3 3
6 2 5 3 1 4
```

### 输出

```
5
499122191
```

## 样例 #2

### 输入

```
见附件中的 noodle/noodle_ex2.in```

### 输出

```
见附件中的 noodle/noodle_ex2.ans```

# 题解

## 作者：FjswYuzu (赞：9)

ZJOI2022 Day2 的题都是非人力可及牛逼题目吗？好吓人啊！！！

先随便讲点暴力，因为这显然是线性变换，加上一些聊胜于无的特判就可以拿 50。

注意到有个奇怪的特殊限制，一个是 $n=2^k$，一个是 $n=98304 = 2^{15} \cdot 3$。我们对这俩东西研究一下。

首先是 $n=2^k$。拉一次拉面，会发现 $a_1=a_2,a_3=a_4 ,\cdots ,a_{n-1}=a_n$；再拉一次，会发现 $a_1=a_2=a_3=a_4 ,\cdots ,a_{n-3}=a_{n-2}=a_{n-1}=a_n$……最终所有数会变成一样的，并不再改变。

再考虑 $n=2^{15} \cdot 3$。类似的，在第十五次操作时，会分成三个极长段，每段内数相同，长度均为 $2^{15}$。再操作一次就变成了前面一个 $2^{16}$ 的极长段后面一个 $2^{15}$ 的极长段。继续操作，权值仍然会改变，但是这样的极长段的样式不会改变。

经过多次手玩，记最大的 $x$ 满足 $n \equiv 0 \pmod{2^x}$ 为 $t$，在 $t+1$ 次操作后会形成如下的形状：

$$
a_1^{2^{t+1}}a_2^{2^{t+1}}a_3^{2^{t+1}} \cdots a_{m-1}^{2^{t+1}} a_m^{2^t} 
$$

最后一段长度只有前面的一半。注意到形成这个形状的最大操作次数是 $O(\log n)$ 级别的，我们先预处理掉前 $O(\log n)$ 次操作，然后考虑把现在的这个 $a$ 序列抽出来，研究其变化。

那么操作里面有个非常多余的东西就是除以二，这个除以二什么时候做都可以，可以从线性变换的角度考虑。那我们在最后除以 $2^k$ 即可（要特判 $n=2^p$）。

假设现在的 $a$ 序列是 $a_1,a_2,\cdots a_m$ 并记 $mid = \lceil \frac{m}{2} \rceil$，那么操作一次之后是 $a_1+a_m,a_1+a_{m-1},a_2+a_{m-1},a_2+a_{m-2},\cdots ,a_{mid-1}+a_{mid},2a_{mid}$。

这个形式显得有规律可循，考虑差分。记之前的差分数组为 $b_1,b_2,\cdots ,b_{m-1}$，那么现在的差分数组是 $-b_{m-1},b_1,-b_{m-2},b_2 \cdots ,b_{mid-1}$。这是这个题离谱的第一点。

现在可以做到 $O(n^2+q)$ 了，还可以更优秀吗？

这个数组的变换是非常有规律的，但是出现了 $-1$ 这个系数显得不优美，我们考虑往差分数组后面补一个 $-b_{m-1},-b_{m-2},\cdots ,-b_{1}$，然后这是一个置换的形式。现在每次询问还原序列就好了，时间复杂度 $O(nq)$。

然后补充一个离谱的观察。这个置换拆成若干个置换环，满足大小最大的置换环是其他置换环大小的倍数……因此可以保证其循环节在 $O(n)$ 范围内。进一步的，最大的置换环大小等于 $2$ 在 $\bmod (n+1)$ 下乘法的阶（意即最大的置换环大小 $x$ 满足 $2^x \equiv 2 \pmod{(n+1)}$ 且 $x$ 最小）。这是一个非常牛逼的观察……离谱的第二步。实则有迹可循，你可以发现在上面那个差分数组 $d$ 中，满足 $d_{2i \bmod (m+1)}' = d_i$。这个观察比较重要。

还能够优秀！考虑通过差分数组快速计算 $x$ 位置上的值。要做的两步是，一个差分值在算 $a_x$ 的时候造成了多少次贡献，以及 $a_1$ 的值是多少。

首先第一个观察是，因为我们将除以二这个东西提到了最后，每次操作数列的权值和是不变的。那么求 $a_1$ 并不是一件困难的事情，其表示成总和减去差分数组带上一些系数，最后除以 $n$。然后算 $x$ 的话，也是近似于差分数组带系数。不妨记这个系数为 $p_i$ 与 $q_i$，其乘上新的差分数组 $d_i^{(k)}$ 才有意义。同时这个 $k$ 优化后是 $O(n)$ 级别的。

记 $S$ 为变换前 $a$ 的和，那么有：

$$
a_1 \times n + \sum_{i=1}^{m-1}d_i^{(k)}p_i = S
$$

$$
a_x = a_1 + \sum_{i=1}^{m-1}d_i^{(k)}q_i
$$

（容易发现 $q$ 后面一段可以是 $0$，同时 $p,q$ 是容易得出的。）

我们要对所有的 $k$ 全部求出一个答案（同时 $k$ 最大是 $O(n)$ 级别的）。相当于求 $\displaystyle \sum_{i=1}^{m-1}d_ip_i, \sum_{i=1}^{m-1} d_i^{(1)}p_i,\sum_{i=1}^{m-1} d_i^{(2)}p_i,\cdots$（其中的 $p$ 显然换成 $q$ 也要算一次）。

那么我们将 $d$ 表示成置换的形式。但是变换的形式就是 $d_{2i \bmod (m+1)}' = d_i$ 就显得比较麻烦啊。那就把置换环全部拆出来，这样的话这个麻烦的变换形式就显得简单一些，类似于循环卷积。

至于循环卷积，在这个题中举一个例子出来。比如一个长为 $P$ 的置换环 $d$，置换 $k$ 次后对上一个系数数组 $p$，有：

$$
\sum_{i=0}^{P-1} d_i p_{i+k \bmod P}
$$

同时对每个 $k$ 都要求一个这个。这里就显得非常的简单，把 $p$ 翻转做循环卷积就好了。可以用 NTT 实现。

注意到不同的置换环，如果大小相同造成贡献的位置也相同，可以提到一起做。这样的话大小不同的置换环个数只有 $O(\sqrt n)$ 级别，可以做到 $O(n\log n+q \sqrt n)$。

还有一点就是我们一直在讨论上面那个最后一段长度是前面的段的一半的 case，因此如果 $n=2^k$ 需要特判。

当然根据我们上面那个比较离谱的观察，因为最大的置换环大小等于 $2$ 在 $\bmod (n+1)$ 下乘法的阶，且其他置换环大小是最大的置换环的因数，因此整个 $a$ 会产生循环节，且长度非常有限。这样的话记最大的置换环长度为 $P$，直接预处理所有 $k\bmod P=0,1,\cdots P-1$ 的答案就好了。这样就可以做到 $O(n \log n + n d(n) + q)$ 了……吗？

注意到 $k$ 上面的性质都是我们在 $a$ 开始形成上面那种特殊形状后去掉除以二的操作得到的，我们还要求一个 $\dfrac{1}{2^k}$，这个 $k$ 是没有经过循环节取模优化的真实的 $k$，范围仍然是 $10^{18}$……所以先欧拉定理降次，然后光速幂就好了。

细节比较多。完整代码戳[这里](https://www.luogu.com.cn/paste/euzle20e)。

```cpp
int a[2000005],test;
int hst[25][2000005],b[2000005],d[2000005],m;
int cir[2000005];
bool vis[2000005];
int cbid[2000005];
int fcir[2000005];
void Solve()
{
	int n, q, x;
	long long k_max;
	scanf("%d%d%d%lld", &n, &q, &x, &k_max);
	int Sum=0;
	for (int i = 1; i <= n; i ++)	scanf("%d",&a[i]),Sum=Add(Sum,a[i]);
	for(int i=1;i<=n;++i)	hst[0][i]=a[i];
	for(int i=1;i<=24;++i)
	{
		for(int j=1;j<=n;++j)	b[j]=Add(hst[i-1][j],hst[i-1][n-j+1]);
		for(int j=1;j<=n;++j)	hst[i][j]=Mul(b[(j+1)/2],inv2);
	}
	if((n&(-n))==n)
	{
		LL ans=0;
		for(int C=1;C<=q;++C)
		{
			LL k=rd(seed)%k_max;
			k=min(k,24ll);
			ans^=(LL(C)*hst[k][x]);
		}
		printf("%lld\n",ans);
		return ;
	}
	int t=0;
	{
	int tmp=n;
	while(tmp%2==0)
	{
		tmp>>=1;
		++t;
	}
	++t;
	}
	int tp=t;
	{
	int pm=0;
	for(int i=1;i<=n;i+=(1<<t))	b[++pm]=hst[t][i];
	t=1<<t;
	m=0;
	for(int i=2;i<=pm;++i)	d[++m]=Sub(b[i],b[i-1]);
	for(int i=m;i;--i)	d[++m]=MOD-d[i];
	}
	for(int i=1;i<=m;++i)	cir[2*i%(m+1)]=i;
	for(int i=1;i<=m;++i)	vis[i]=false;
	vector<Poly> Cir;
	for(int i=1;i<=m;++i)
	{
		if(vis[i])	continue;
		int u=i;
		Cir.push_back({});
		while(!vis[u])
		{
			vis[u]=true;
			Cir.back().push_back(u);
			u=cir[u];
		}
	}
	int K=1;
	for(auto st:Cir)	K=max(len(st),K);
	for(int i=0;i<=K;++i)	cbid[i]=fcir[i]=0;
	int inv=QuickPow(n);
	vector<Poly> CirBuc;
	for(auto st:Cir)
	{
		Poly A,B;
		int len=len(st);
		A.resize(len),B.resize(len);
		for(int i=0;i<len;++i)	A[i]=d[st[i]];
		for(int i=0;i<len;++i)	B[i]=MOD-Mul(inv,st[i]<=m/2?Sub(n,Mul(st[i],t)):0);
		for(int i=0;i<len;++i)	B[i]=Add(B[i],int(st[i]*t+1<=x));
		reverse(B.begin(),B.end());
		Poly C=A*B;
		for(int i=0;i<len-1;++i)	C[i]=Add(C[i],C[i+len]);
		if(!cbid[len])
		{
			CirBuc.push_back({});
			CirBuc.back().resize(len);
			cbid[len]=len(CirBuc);
		}
		int id=cbid[len]-1;
		for(int i=0;i<len;++i)	CirBuc[id][i]=Add(CirBuc[id][i],C[i]);
	}
	for(int len=1;len<=K;++len)
	{
		if(cbid[len])
		{
			int id=cbid[len]-1;
			for(int i=0,j=len-1;i<K;++i,j=(j+1)%len)	fcir[i]=Add(fcir[i],CirBuc[id][j]);
		}
	}
	LL ans=0;
	for(int C=1;C<=q;++C)
	{
		LL k=rd(seed)%k_max;
		int ret=0;
		if(k<=tp)	ret=hst[k][x];
		else
		{
			k-=tp;
			int coe=cp.Inv(k);
			k%=K;
			int s=Mul(fcir[k],coe);
			ret=Add(s,Mul(inv,Sum));
		}
		ans^=LL(C)*LL(ret);
	}
	printf("%lld\n",ans);
}
```

---

## 作者：max67 (赞：5)

## 前言

~~shj 大佬说这次 ZJOI 没有防 AK 题，花四个半小时都能写出来。~~

~~他还说除了这题的第一步没想到，其他都是轻轻松松。~~

本文参考了出题人的[题解](https://www.zhihu.com/question/531164650/answer/2468389537)。

题解中有一些打表发现的，再下面基本上有证明。

如果图片看不清楚的话，可以直接去路过图床的链接上查看（直接点击图片即可）。

## 题解

（为了方便理解，基本以几何直观（画图）为主）

### 5 pt

暴力模拟即可。复杂度 $O(Tqkn)$

### 10 pt

注意到第二个测试点 $k_{max}\le 10$，可以预处理出 $k\le 10$ 的答案。

### 15 pt

打表可以发现,注意到 $n=2^k$ 时，经过 $\log_2^{n}$ 次变换后所有数都会变成相等。再进行操作时答案不变。分类讨论即可。

### 40 pt

观察到此变换是线性变换，因此能用矩阵快速幂优化。并且一次变换后的 $\frac{1}{2}$ 的系数对矩阵构造没有影响，那么把这个 $\frac{1}{2}$ 提到最终答案上，那么大概长这样：

[![OdwMh8.png](https://s1.ax1x.com/2022/05/11/OdwMh8.png)](https://imgtu.com/i/OdwMh8)

直接暴力的复杂度为 $O(T(n^2+q\log_2^k+qn^3k))$，能过第 $4$ 到 $6$ 个点。

据常用的套路——向量与矩阵相乘的复杂度为 $O(n^2)$，那么可以预处理出变换 $2^k$ 次后的矩阵，询问时再与向量逐个相乘，同时也可以采用 $p$ 进制的快速幂，复杂度大约为 $ O(T(n^3\times p\times \log_{p}^{n}+q\log_2^k+qn^2\log_p^{n})) $ ，能通过第 $8$ 到第 $9$ 个点。

### 45 pt

观察第七个测试点，发现 $98304=2^{15} \times 3$。通过打表发现，当 $n=2^{k}\times 3$ 时，在进行大约 $log_2^{n}$ 次变换后的每一变换，区间的数的值都形如 $aa...aa\ bb...bb\ cc..cc$，并且 $a$ 和 $b$ 的长度都为 $2^{k+1}$， $c$ 的长度为 $2^k$。那么此时矩阵快速幂的复杂度降为 $O(T(n\log_2^n +q\log_2^k+ q \times 3^3 \log_2^{k}))$（因为只需要维护 $3$ 个数）。

### 65 pt

根据测试点给出的特殊性质（$2^k$ 和 $2^{15}\times 3 $ ）。我们能大概猜测在做 $\log_2^{n}$ 次变换后数列会出现一些性质。注意到 $n$ 一定是偶数，通过打表可以发现：

- 在 $n=2^t$ 的时候，经过 $t+1$ 次变换后所有数列中的数都相等。
- 在 $n=2^{t}\times m\ (\ 2\nmid m ,m>1\ )$ 的时候，观察到变换次数 $k$ 小于 $t+1$ 时，变换后会有若干个长度为 $2^k$ 的区间，其中每个区间内的数都相等（若无特殊说明，下文说的区间都满足区间内的数都相等的条件）；当变换次数 $k$ 大于等于 $t+1$ 时，变换后会有 $\frac{m-1}{2}$ 个长度为 $2^{t+1}$ 的区间和一个长度为 $2^t$ 的区间。

因为变换的相等性并不被变换后所带的 $\frac{1}{2}$ 的系数影响，因此考虑先拿掉这个系数直接放到答案中去。

直观的几何证明如下：

（举得都是小例子，对于更多块的情况，自行用省略号和 $mid$ 代替。）

（想要代数证明可以对着图自己扒拉扒拉。）

首先考虑变换的几何意义，容易观察到这是一个线性变换（因为能用矩阵表示）

[![OwKp4I.png](https://s1.ax1x.com/2022/05/12/OwKp4I.png)](https://imgtu.com/i/OwKp4I)



- 设变换次数为 $k$，当 $k$ 小于 $t+1$ 时，会由若干个长度为 $ 2^k $ 的区间变成若干个长度为 $2^{k+1}$ 的区间，并且长度为偶数（因为 $n=2^{k}\times m'\ (k<t+1,2 | m')$）。

[![OwKta9.png](https://s1.ax1x.com/2022/05/12/OwKta9.png)](https://imgtu.com/i/OwKta9)

- 当变换次数 $t+1=k$ 时，会有 $\frac{m-1}{2}$ 个长度为 $2^{t+1}$ 的区间，$1$ 个长度为 $2^t$ 的区间。（因为 $\frac{m-1}{2}\times 2^{t+1} +2^t =m\times 2^t-2^t+2^t=n$）

[![OwKzsU.png](https://s1.ax1x.com/2022/05/12/OwKzsU.png)](https://imgtu.com/i/OwKzsU)

- 当变换次数 $t+1<k$ 时，会有 $\frac{m-1}{2}$ 个长度为 $2^{t+1}$ 的区间，$1$ 个长度为 $2^t$ 的区间。

[![OwMmLD.png](https://s1.ax1x.com/2022/05/12/OwMmLD.png)](https://imgtu.com/i/OwMmLD)

**注意**：我们下面讨论的 $n$ 均不为 $2$ 的幂次，否则可以特判掉。

我们通过画图发现，在经过 $t+1$ 次变换后，数列的形式不变。因此我们单独考虑 $t+1$ 次变换后的情况。注意到 $t \le log_2^{n}$，所以预处理是 $O(n\log_2^{n}) $ 级别的。

我们先把原先的序列的最长的区间浓缩成一个数，那么变换后的所有的区间数量为 $M = \frac{m-1}{2} +1$。

（注意此时再用矩阵快速幂优化会减小一些不确定的常数。）

先考虑一次变换后的情况：（第一行的长度为 $2^t$，第二行的长度为 $2^{t+1} $ 和 $2^t$ （最后一个））

（任然考虑先把 $\frac{1}{2}$ 拿掉考虑，需要的时候再考虑加上）

```
a1 a1 a2 a2 a3 a3 a4 a4 a5  ->   a1+a5 a1+a5 a1+a4 a1+a4 a2+a4 a2+a4 a2+a3 a2+a3 a3+a3 
  |     |     |     |   |             |           |           |           |        |
  a1    a2    a3    a4  a5          a1+a5       a1+a4       a2+a4        a2+a3    a3+a3
```

由于变换后的最大的区间长度为 $2^{t+1}$，因此我们考虑对两次变换后的相应的区间做对比：

```
      a1    a2    a3    a4    a5 
->  a1+a5 a1+a4 a2+a4 a2+a3 a3+a3
```

考虑操作后的序列的相邻区间的值只有一个数不相等，那么考虑对序列做差分（$d_i=a_{i+1}-a_i$）：

```
      a1     a2     a3     a4     a5    
d:      a2-a1  a3-a2  a4-a3  a5-a4   
         d1     d2     d3     d4
->  a1+a5  a1+a4  a2+a4  a2+a3  a3+a3    
d':     a4-a5  a2-a1  a3-a4  a3-a2
        -d4     d1    -d3     d2
```

（其中 $d$ 和 $d'$ 的数组的长度为 $M-1$）

考虑 $d$ 数组和 $d'$ 数组中的绝对值的值组成集合相等。并且通过打表发现，变换循环节长度不超过 $2(M-1)$，此时预处理循环节里的每个差分可以做到 $O(T(n^2+q\log_2^k))$ 的复杂度。

（由于加上 $\frac{1}{2}$ 后会破坏 $d$ 与 $d'$ 的相等性，因此把 $\frac{1}{2}$ 放到答案中去）

> 显然现在还需要知道 $a_1$ 的值。这个放在后面讨论

不过这个绝对值非常碍眼。那么我们通过补全 $d_i$ 和 $-d_i$ 的方法来避免。由于在上面的变换中 $d'_{2\times i}=d_i$ 对 $i\le  \frac{M-1}{2}$ 成立，那么补全这个神奇的变换：

```sqlite
d  :  d1  d2  d3  d4 | -d4 -d3 -d2 -d1
d' : -d4  d1 -d3  d2 | -d2  d3 -d1  d4
```

（其中 d 和 d' 的数组长度为 $2(M-1)$）

我们会发现一个神奇的置换——$d'_i=d_{i\times 2 \ mod\ 2(M-1)+1}$。因为是置换，考虑[置换群 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/permutation-group/)中的相关知识——一个置换可以分解为若干个不相交的循环置换。由于循环置换显然有循环节，那么置换也显然有循环节。由于这个置换的性质，可以对于每个询问暴力用快速幂跳置换后计算，复杂度为 $O(T(nq\log_2^{k}+q\log_2^{k}))$

（可能有更优的办法，但由于网不好，代码下不下来，所以没有写qaq，毕竟原题解没有这个 $log$）

接下来考虑如何计算 $a_1$ 的值。容易知道，题目中所给的变换并没有改变序列的总和。

> 因为 $a_i$ 与 $a_{n-i+1}$ 贡献了两个数（因为序列长度为偶数），每个都是 $\frac{a_i+a_{n-i+1}}{2}$，因此总和不变。

那么当把 $\frac{1}{2}$ 的系数抽掉时，每变换一次序列总和  $\times 2$。那么显然我们可以算出变换后的序列总和，那么因为我们又知道差分数组，因此我们可以把 $a_1$ ~ $a_n$ 都用 $a_1$ 表示，那么就得到了一个方程：

设 $w_{1}(i) $ 表示在变换 $k$ 次后，**新**差分数组的第 $i$ 位对总和计算的贡献，设 $w_2(i)$ 表示变换 $k$ 次后，新差分数组对计算第 $x$ 位的贡献，设 $d_i$ 表示变换后的**新**差分数组。

（注意，计算的长度为 $n$ 的序列的总和。不能计算浓缩过的数组，因为长度不相等）
$$
\sum_{i=1}^{M-1}d_iw_1(i) +a_1\times n = sum\\
a_1=\frac{sum-\sum_{i=1}^{M-1}d_iw_1(i)}{n},a_x=a_1 +\sum_{i=1}^{M-1}d_iw_2(i)
$$
那么结合上面两种算法，复杂度降到 $O(T(n\times \min(n,q\log_2^{k})+q\log_2^k))$ 。

对于实现，可以参考 ZJ-001，zhr 大佬的代码，不过代码中的 map 可以改成数组优化。

### 80pt

那么复杂度瓶颈主要在于每次询问都需要求一遍差分数组 $d$。但由于系数数组 $w_1(i)$ 和 $w_2(i)$ 的存在，我们实际上只需要知道 $w_1(i)\times d_i$ 和 $w_2(i) \times d_i$ 值即可，我们考虑原差分数组中的 $d_i$ 变换到了新差分数组的哪个位置。

我们设置换为 $f$，即 $f(i)=i\times 2\ (mod\ 2(M-1)+1)$。因为这个 $\times 2$ 还是过于碍眼，考虑去掉他。那么分析置换的性质——他可以拆成若干个长度不相交的置换环。那么容易发现一次置换后所有数都在置换环上前进了一个位置，即 $\times 2$ 变成了 $+1$，那么这就有操作空间了。

我们把所有的置换环拎出来。设长度为 $C$，并把环内的数重新标号为 $0$ ~ $C-1$（为了方便取模），当环上的 $i$ 号点在原差分数组中的编号为 $x$ 时，$w_1'(i)=w_1(x)$，$w_2'(i)=w_2(x)$，$  d'(i)=d(x)$。那么在这个环内的新置换就是 $f'(i) = i+1\ mod\ C$。显然，变换 $k$ 次后 $i$ 的位置就是 $f'^k(i)=f(f(...f(i)))=i+k\ mod C$。那么我们所需要求的答案：变换一次、两次、$k$ 次后的 $\sum_{i=0}^{C} w_1'(f’^k(i)) \times d'_i$，$\sum_{i=0}^{C} w_2'(f’^k(i))\times  d'_i$。由于循环置换环的周期为 $C$，考虑到化简后有:
$$
\sum_{k=0}^{C}\sum_{i=0}^{C} w_1'(i+k\ mod\  C)\times  d'_i,\sum_{i=0}^{n} w_2'(i+k\ mod\  C)\times d'_i
$$
如果暴力求的话复杂度还是没有降低，不过这里有一个常用（我不会）的 $fft$ 化简技巧。把上面的问题抽象一下，有：
$$
ans_i=\sum_{j=0}^{n-1}f(j)\times g(i+j\ mod\ n)
$$
先考虑翻转 $g$，翻转后为 $ g' $，即 $g'(i)=g(n-i-1)$,有：
$$
ans_i=\sum_{j=0}^{n-1}f'(j)\times g(n-i-1-j\ mod\ n)\\
=\sum_{j=0}^{n-i-1}f'(j)\times g(n-i-1-j)+\sum_{j=n-i}^{n-1}f'(j)\times g(2n-i-1-j)\\
=\sum_{j=0}^{n-i-1}f'(j)\times g(n-i-1-j)+\sum_{j=n-i}^{2n-i-1}f'(j)\times g(2n-i-1-j)
$$
对于最后一个式子，注意到当 $j>n$ 时，$f'(j)=0$。所以是正确的。而最终式子正是对 $t=f\times g$ 的第 $t_i$ 和第 $t_{2n-i-1}$ 项相加，即循环卷积。

~~当然也可以用任意长度循环卷积来搞~~。

因此我们可以用 $O(ClogC)$ 的时间来确定 $ k\ mod\ C $ 时每一项的贡献（即 $ans_{k\ mod\ C}$）。我们发现对于长度相同的循环置换环，他们的循环节长度相同。并且对于每个置换环，他对答案的贡献是独立的，因此可以把相同的循环节的置换环并在一起计算。那么数量级是 $\sqrt{2(M-1)}$ 级别的。（$1+2.....+\sqrt M \approx M$ ）由于总长度不超过 $2(M-1)$，因此复杂度为:$O(T(n\log_2^n + q\sqrt n+q\log_2^k)$。可以通过第 $14$ ~ 第 $16$ 个测试点。

### 80 pt

可以发现，对于置换环中的任意一个元素，满足 $f^k(i)=i\ (mod\ 2(M-1)+1)$ 的最小的正整数 $k$ 就是置换环的长度（即阶）。带入 $f$，可得 $i\times 2^k = i\ (mod\ 2(M-1)+1)$。而对于整个置换的阶 $r$，满足 $\forall i\in [1,2(M-1)],2^r\times i=i\ (mod\ 2(M-1))$, 因为有 $k\le r$（否则 $k=r$），那么显然有 $k|r$。~~反证法读者自证不难~~。

>  画图也很容易理解。对于一个置换环，满足环上的元素各不相同，也就是说若满足条件则必须恰好绕完整个环，那么就显然有整除了。

由于把 $1$ 带入与求解 $r$ 的式子相同，所以 $1$ 所在的置换环的长度最大。所以询问的答案可以直接先模 $r$。（因为他满足是所有循环长度的 $lcm$）

由于模 $2(M-1)$ 的剩余系下的数最多为 $2(M-1)$ 个，所以循环长度是不超过 $O(M)$ 级别的。因此，对于每类长度相同的置换环，我们暴力计算在走 $k<r$ 步之后的贡献。

则复杂度为 $O(T(n\log_2^{n}+nd(n)+q\log_2^k))$，其中 $d(n)$ 是 $n$ 的约数个数。

根据经典图片， $d(n)$ 的复杂度大约可以估计成三次根号级别：

[![Owrx41.jpg](https://s1.ax1x.com/2022/05/12/Owrx41.jpg)](https://imgtu.com/i/Owrx41)

### 100 pt

~~我从没有见过卡求逆快速幂的出题人，差评！~~

~~直接少了 $20$ pt，好评。~~

由于每次循环都需要求 $\frac{1}{2^k}$，需要 $\log_2^k$  的复杂度。考虑 $2$ 在模 $998244353$ 下的阶为 $499122176$。可以用分块预处理 $2$ 的幂次。细节见代码。

复杂度为 $O(T(n\log_2^{n}+nd(n)+q))$，可以通过。

## 代码实现

缕一遍过程

- 预处理 $2$ 的幂次和逆元的幂次。
- 预处理前 $t$ 次变换。
- 浓缩数组，处理差分数组，处理出 $w_1$ 和 $w_2。$
- 找出每个置换环并用 $NTT$ 计算，桶统计。
- 对于每个询问计算答案。

由于我的代码是跑的最慢的一个，请慎重参考。

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define int long long 
using namespace std;
//--------------------------------------------------------------------------------
const int N=2e6+1e3,mod=998244353;
const int G=3;
int power(int x,int y,int t=1){for(;y;y>>=1,x=x*x%mod)if(y&1)t=t*x%mod;return t;}
int Inv(int x){return power(x,mod-2);}
const int invG=power(G,mod-2);
void ntt(int n,int *f,int *tr,bool pd)
{
    for(int i=0;i<n;i++)
       if(i<tr[i])swap(f[i],f[tr[i]]);
    for(int p=2;p<=n;p<<=1)
    {
        int len=p>>1,tg=power(pd?G:invG,(mod-1)/p);
        static int buf[N];
        buf[0]=1;
        for(int i=1;i<=len;i++)buf[i]=buf[i-1]*tg%mod;
        for(int k=0;k<=n;k+=p)
        {
            for(int l=k,y=0;l<k+len;l++,y++)
            {
                int tt=buf[y]*f[len+l]%mod;
                f[len+l]=(f[l]-tt+mod)%mod;
                f[l]=(f[l]+tt)%mod;
            }
        }
    }
    if(pd)return;
    int tmp=Inv(n);
    for(int i=0;i<n;i++)f[i]=f[i]*tmp%mod;
}
void times(int *f,int n,int *g,int m,int *ans)
{
    static int tr[N];tr[0]=0;
    for(m+=n,n=1;n<=m;n<<=1);
    for(int i=0;i<n;i++)tr[i]=(tr[i>>1]>>1|((i&1)?n>>1:0));
    ntt(n,f,tr,1);ntt(n,g,tr,1);
    for(int i=0;i<n;i++)ans[i]=f[i]*g[i]%mod;
    ntt(n,ans,tr,0);
}
//--------------------------------------------------------------------------------
//NTT 板子
//--------------------------------------------------------------------------------
const int R=499122176;
const int B=sqrt(R)+100;
int inv2;
int pw1[N],pw2[N];
int ipw1[N],ipw2[N];
void Pre2()
{
    inv2=Inv(2);
    pw1[0]=pw2[0]=ipw1[0]=ipw2[0]=1;
    for(int i=1;i<=B;i++)pw1[i]=pw1[i-1]*2%mod,ipw1[i]=ipw1[i-1]*inv2%mod;
    for(int i=1;i<=B;i++)pw2[i]=pw2[i-1]*pw1[B]%mod,ipw2[i]=ipw2[i-1]*ipw1[B]%mod;
}
//--------------------------------------------------------------------------------
//预处理 2 即 2 的逆元的 幂次
//--------------------------------------------------------------------------------
int n,q,x,pd;
int t,m,sum,r,invn;
//n= 2^t 
int a[N],b[N];
int pans[N];
//k<= t 时的答案
int vis[N];
int w1[N],w2[N],f1[N],f2[N],g1[N],g2[N],ans[N];
int ans1[N],ans2[N];
vector<int>len1[N],len2[N];

int F(int x){return x*2%(m+1);}
void Prepare()
{
    invn=Inv(n);
    for(m=n;(m&1)==0;m>>=1)t++;
    pans[0]=a[x]; 
    for(int i=1;i<=t+1;i++)
    {
        for(int j=1;j<=n;j++)b[j]=(a[(j+1)/2]+a[n-(j+1)/2+1])%mod;
        for(int j=1;j<=n;j++)a[j]=b[j];
        pans[i]=a[x];
    }
    if(m==1)return pd=1,void();
    //注意特判 2 的幂次
    m=0;x=(x+(1<<t+1)-1)/(1<<t+1);
    //x 在浓缩后的位置
    for(int i=1;i<=n;i++)sum=(sum+a[i])%mod;
    for(int i=1;i<=n;i+=(1<<t+1))a[++m]=a[i];
    for(int i=1;i<m;i++)b[i]=a[i+1]-a[i];
    m--;
    for(int i=m+1;i<=2*m;i++)b[i]=-b[2*m-i+1];    
    //差分数组
    for(int i=1;i<x;i++)w2[i]=1;
    for(int i=m,res=(1<<t);i>=1;i--,res+=(1<<t+1))w1[i]=res;
    m*=2;
    int tmp=2;r=1;while(tmp!=1){r++;tmp=F(tmp);}
    for(int i=1;i<=m;i++)
    {
        if(vis[i])continue;
        int tot=0,j=i;
        while(!vis[j])
        {
            f1[tot]=f2[tot]=b[j];g1[tot]=w1[j];g2[tot++]=w2[j];
            vis[j]=1;j=F(j);
        }
        //NTT
        if(len1[tot].size()==0)len1[tot].resize(tot);len2[tot].resize(tot);
        for(int i=tot;i<tot*6;i++)g1[i]=g2[i]=f1[i]=f2[i]=0;
        reverse(g1,g1+tot);reverse(g2,g2+tot);

        for(int j=0;j<tot*5;j++)ans[j]=0;
        times(f1,tot,g1,tot,ans);
        reverse(ans,ans+2*tot);
        for(int j=0;j<tot;j++)len1[tot][j]=(len1[tot][j]+ans[j]+ans[j+tot])%mod;
        for(int j=0;j<tot*5;j++)ans[j]=0;
        times(f2,tot,g2,tot,ans);
        reverse(ans,ans+2*tot);
        for(int j=0;j<tot;j++)len2[tot][j]=(len2[tot][j]+ans[j]+ans[j+tot])%mod;
        //NTT
    }
    for(int i=1;i<=r;i++)
    {
        if(len1[i].size()==0)continue;
        for(int j=0;j<r;j++)ans1[j]=(ans1[j]+len1[i][j%i])%mod;
        for(int j=0;j<r;j++)ans2[j]=(ans2[j]+len2[i][j%i])%mod;
    }
}
int ask(int x,int opt)
{
    x%=R;
    if(opt==0)return pw2[x/B]*pw1[x%B]%mod;
    return ipw2[x/B]*ipw1[x%B]%mod;
}
int solve(int k)
{
    if(k<=t+1)return pans[k]*ask(k,1)%mod;
    int pw=ask(k-t-1,0),inv=ask(k,1);
    k=k-t-1;
    if(pd)return inv*pw%mod*a[1]%mod;
    k%=r;
    int a1=invn*(sum*pw%mod-ans1[k])%mod;
    int ax=(a1+ans2[k])%mod;
    return ax*inv%mod;
}
void Clear()
{
    t=sum=r=pd=0;
    for(int i=0;i<=n;i++)pans[i]=0;
    for(int i=0;i<=n;i++)ans1[i]=ans2[i]=0;
    for(int i=0;i<=n;i++)len1[i].clear(),len2[i].clear();
    for(int i=0;i<=n;i++)vis[i]=0;
    for(int i=0;i<=n;i++)w1[i]=w2[i]=0;
}
unsigned int rd(unsigned int &x){x^=(x<<13);x^=(x>>7);x^=(x<<17);return x;}
signed main()
{
    Pre2();
    int test,T;
    unsigned int seed;
    scanf("%lld%lld%llu",&test,&T,&seed);
    for(int _=1;_<=T;_++)
    {
        int mxk,ans=0;
        scanf("%lld%lld%lld%lld",&n,&q,&x,&mxk);
        for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
        Clear();Prepare();
        for(int i=1;i<=q;i++)
        {
            // int k;scanf("%lld",&k);
            int k=rd(seed)%mxk;
            // printf("%lld\n",solve(k));
            ans^=(((solve(k)%mod+mod)%mod)*i);
        }
        printf("%lld\n",ans);
    }
}
```

## 后记

部分分分的好多

~~hzy 小姐姐，我爱你，我想做你的狗。~~

[![OwoOtf.png](https://s1.ax1x.com/2022/05/12/OwoOtf.png)](https://imgtu.com/i/OwoOtf)

---

## 作者：Renshey (赞：4)

#### 题解

首先不难发现，经过足够多次变换后，序列一定形成若干段相同的，且不会再次进行合并。当 $n=2^k$ 时，$k$ 轮后全部相同；否则设 $n=u\times 2^v$（$2\nmid u$），则最终序列一定为若干段长度为 $2^{v+1}$ 的相同段与一段长度为 $2^v$ 的相同段。

先不考虑每次 $\times \frac{1}{2}$，在最后再乘 $\frac{1}{2^k}$，$O(1)$ 计算这一部分需要先用费马小定理将 $k$ 对 $p - 1$ 取模后用光速乘（分块乘法）计算，这一部分是 $O(\sqrt{p})$ 的。

对于相同段的处理，可以先进行 $O(\log n)$ 次操作到达相同段的阶段，每次操作效率 $O(n)$，这一部分是 $O(n \log n)$ 的。

当 $n=2^k$ 时，最终序列一定全部相同，特判掉即可。否则设最终序列相同段合并后为 $\{a,b,\dots,c\}$，即原序列由 $2^{v+1}$ 个 $a,b,\dots$ 与 $2^v$ 个 $c$ 构成。记 $m$ 为当前序列的长度。考虑一次操作的结果：$\{a,b,c\} \to \{a+c,a+b,2b\}$，实际上可以描述为：$a'_i = a_{\lceil \frac{i}{2} \rceil} + a_{m-\lfloor \frac{i}{2} \rfloor}$。由此可以考虑差分，设上一次的差分为 $\{d_1,d_2,\dots,d_{m-1}\}$，则下一次的差分即为 $-d_{m-1},d_1,-d_{m-2},d_2,\dots$。考虑序列 $\{d_1,d_2,\dots,d_{m-1},-d_{m-1},\dots,-d_2,-d_1\}$，则每次操作实际上是对该序列进行一次洗牌置换，即对于长度为 $n$（$2\mid n$）的序列进行置换：$p_i=2i \bmod {(n + 1)}$。因此该置换的循环节即为 $2$ 在模 $n+1$ 意义下的阶，本题中即为 $r=\delta_{2m-1}(2)$。

考虑利用这个循环节，只需求出 $0 \sim r - 1$ 时刻的 $a_1$ 与 $\sum_{i=1}^{x-1} d_i$。由于 $a'_1=2a_1+\sum_{i=1}^{m-1} d_i$，实际上只需要求出每个时刻的 $\sum_{i=1}^{x-1} d_i,\sum_{i=1}^{n-1} d_i$ 即可，$a_1$ 可以由这些值与等比数列求和公式快速推出。对于计算每一时刻的差分，可以考虑在每个环上计算贡献，写出式子后发现是差卷积的形式，因此可以直接 NTT 优化。由于每个环都需要对 $0\sim r - 1$ 计算一遍贡献，因此需要对环长进行分类，将环长为 $d$ 的一起处理出对 $0\sim d-1$ 的贡献再处理 $0\sim r -1$。由于 $d \mid r$，因此不同的 $d$ 只有 $d(r)$ 种，而 $\sum {d}= 2m-2$，因此这一部分是 $O(n \log n + nd(n))$ 的。

综上，时间复杂度为 $O(\sqrt{p}+\sum (n\log n + nd(n)+q))$，空间复杂度为 $O(\sqrt{p}+n)$。

#### 代码

```cpp
#include <bits/stdc++.h>
const int mod = 998244353;
const int maxn = 4000000 + 10;
inline int plus (int x, int y) {return x + y < mod ? x + y : x + y - mod;}
const int B = 1 << 15; int BS[B + 10], GS[B + 10]; bool vis[maxn]; std::vector<int> g[maxn];
int n, m, q, t, p, r, a[maxn], b[maxn], c[maxn], d[maxn], e[maxn], sum[maxn], add[maxn], tag[maxn], ans[40];
inline unsigned long long Rand (unsigned long long &x) {x ^= x << 13; x ^= x >> 7; x ^= x << 17; return x;}
inline int Inv2 (long long k) {int r = k % (mod - 1); return 1LL * GS[r >> 15] * BS[r & (B - 1)] % mod;}
inline int power (int x, int y)
{
	int z = 1;
	for (; y; y >>= 1, x = 1LL * x * x % mod) if (y & 1) z = 1LL * z * x % mod;
	return z;
}
struct Poly
{
	int t, invt, u[1 << 23], v[1 << 23], w[1 << 23], rev[1 << 23];
	inline void init (int n)
	{
		for (t = 1; t <= n; t <<= 1) ;
		invt = power(t, mod - 2);
		for (int i = 0; i < t; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (t >> 1) : 0);
		for (int i = 0; i < t; i++) u[i] = v[i] = w[i] = 0;
	}
	inline void NTT (int *a, int f)
	{
		for (int i = 0; i < t; i++) if (i < rev[i]) std::swap(a[i], a[rev[i]]);
		for (int i = 2; i <= t; i <<= 1)
		{
			int wn = power(~f ? 3 : 332748118, (mod - 1) / i);
			for (int j = 0; j < t; j += i)
				for (int k = 0, w = 1; k < i / 2; k++, w = 1LL * w * wn % mod)
				{
					int x = a[j + k], y = 1LL * w * a[j + k + i / 2] % mod;
					a[j + k] = plus(x, y); a[j + k + i / 2] = plus(x, mod - y);
				}
		}
		if (f == -1) for (int i = 0; i < t; i++) a[i] = 1LL * a[i] * invt % mod;
	}
	inline void solve (void)
	{
		NTT(u, 1); NTT(v, 1); NTT(w, 1);
		for (int i = 0; i < t; i++) u[i] = 1LL * u[i] * w[i] % mod, v[i] = 1LL * v[i] * w[i] % mod;
		NTT(u, -1); NTT(v, -1);
	}
} P;
signed main ()
{
	BS[0] = 1; BS[1] = (mod + 1) / 2;
	for (int i = 2; i <= B; i++) BS[i] = 1LL * BS[i - 1] * BS[1] % mod;
	GS[0] = 1; GS[1] = BS[B];
	for (int i = 2; i <= B; i++) GS[i] = 1LL * GS[i - 1] * GS[1] % mod;
	int T; unsigned long long seed; scanf("%*d%d%llu", &T, &seed);
	while (T--)
	{
		long long w, Ans = 0; scanf("%d%d%d%lld", &n, &q, &p, &w);
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
		for (ans[t = 0] = a[p]; !(n & 1); n >>= 1)
		{
			for (int i = 1; i <= n / 2; i++) a[i] = 1LL * BS[1] * (a[i] + a[n - i + 1]) % mod;
			ans[++t] = a[p = (p + 1) / 2];
		}
		if (n == 1)
		{
			for (int i = 1; i <= q; i++) Ans ^= 1LL * i * ans[std::min(Rand(seed) % w, (unsigned long long)t)];
			printf("%lld\n", Ans); continue;
		}
		for (int i = 1; i <= (n + 1) / 2; i++) a[i] = 1LL * BS[1] * (a[i] + a[n - i + 1]) % mod;
		ans[++t] = a[p = (p + 1) / 2]; n = (n + 1) / 2;
		for (int i = 1, j = 2; ; i++, j = 2LL * j % (2 * n - 1)) if (j == 1) {r = i; break;}
		for (int i = 1; i < n; i++) b[i] = plus(a[i + 1], mod - a[i]), b[2 * n - i - 1] = plus(a[i], mod - a[i + 1]);
		for (int i = 0; i < r; i++) tag[i] = sum[i] = add[i] = 0;
		for (int i = 1; i <= 2 * n - 2; i++) vis[i] = false, std::vector<int>().swap(g[i]);
		for (int i = 1; i <= 2 * n - 2; i++) if (!vis[i])
		{
			int m = 0;
			for (int j = i; !vis[j]; j = 2LL * j % (2 * n - 1)) vis[j] = true, m++;
			g[m].push_back(i);
		}
		for (int i = 1; i <= 2 * n - 2; i++) vis[i] = false;
		for (int m = 1; m <= 2 * n - 2; m++) if (!g[m].empty())
		{
			for (int i = 0; i < m; i++) d[i] = e[i] = 0;
			for (int i: g[m])
			{
				P.init(3 * m);
				for (int j = i, k = 0; !vis[j]; j = 2LL * j % (2 * n - 1), k++) vis[c[k] = c[k + m] = j] = true;
				for (int j = 0; j < 2 * m; j++) P.u[j] = c[j] < p, P.v[j] = c[j] < n;
				for (int j = 0; j < m; j++) P.w[j] = b[c[m - 1 - j]];
				P.solve();
				for (int j = 0; j < m; j++) d[j] = plus(d[j], P.u[j + m - 1]), e[j] = plus(e[j], P.v[j + m - 1]);
			}
			for (int i = 0; i < r; i += m) for (int j = 0; j < m; j++) sum[i + j] = plus(sum[i + j], d[j]), add[i + j] = plus(add[i + j], e[j]);
		}
		for (int i = 1; i <= r; i++) tag[i] = (2LL * tag[i - 1] + add[i - 1]) % mod;
		for (int i = 0; i < r; i++) tag[i] = plus(tag[i], sum[i]);
		tag[r] = 1LL * power(power(2, r) - 1, mod - 2) * tag[r] % mod;
		for (int i = 1; i <= q; i++)
		{
			long long k = Rand(seed) % w;
			if (k <= t) {Ans ^= 1LL * i * ans[k]; continue;}
			k -= t; Ans ^= 1LL * i * ((a[1] + 1LL * (1 - Inv2(k / r * r) + mod) * tag[r] + 1LL * Inv2(k) * tag[k % r]) % mod);
		}
		printf("%lld\n", Ans);
	}
	return 0;
}
```

---

## 作者：wishapig (赞：2)

希望能使用尽量少的 intuition 来解释一下这道题。

为方便起见，下面序列坐标均从 $0$ 到 $n-1$。

我们先忽略每次操作中的除以 $2$，最后在求出答案之后别忘了乘上 $2^{-k}$ 就行。 

首先题目中描述的对 $a$ 的变换 $f(a)$ 可以写成矩阵 $M$ 乘上 $a$ 的形式，例如当 $n=10$ 时矩阵是这样的：

```
1 0 0 0 0 0 0 0 0 1
1 0 0 0 0 0 0 0 0 1
0 1 0 0 0 0 0 0 1 0
0 1 0 0 0 0 0 0 1 0
0 0 1 0 0 0 0 1 0 0
0 0 1 0 0 0 0 1 0 0
0 0 0 1 0 0 1 0 0 0
0 0 0 1 0 0 1 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 1 1 0 0 0 0
```

由于每次询问的 $x$ 是固定的，我们的目标就是快速求出 $M^k$ 的第 $x$ 行 $m_k[0,\cdots ,n-1]$，然后可得 $ans(k)=\sum_{i=0}^{n-1}a[i]\cdot m_k[i]$。

考虑怎么求 $m_k[0,\cdots ,n-1]$，显然它一定是回文的，然后搬出矩乘的定义式：
$$
M^{k+1}[x][i]=\sum_{j=0}^{n-1}M^k[x][j]\cdot M[j][i]
$$
仔细观察这个式子，可得：
$$
\begin{aligned}
m_{k+1}[0]&=m_k[0]+m_k[1]\\
m_{k+1}[1]&=m_k[2]+m_k[3]\\
&\vdots\\
m_{k+1}[n/2-1]&=m_k[n-2]+m_k[n-1]\\
m_{k+1}[n/2]&=m_k[n-2]+m_k[n-1]=m_k[0]+m_k[1]\\
m_{k+1}[n/2+1]&=m_k[n-4]+m_k[n-3]=m_k[2]+m_k[3]\\
&\vdots\\
m_{k+1}[n-1]&=m_k[0]+m_k[1]=m_k[n-2]+m_k[n-1]
\end{aligned}
$$
勾画出一种模式：
$$
m_{k+1}[i]=m_k[(2i)\%n]+m_k[(2i+1)\%n]
$$
不断回代，可以得到：
$$
\begin{aligned}
m_k[i]
&=\sum_{j=i\cdot 2^k}^{(i+1)\cdot 2^k-1}m_0[j\%n]\\
&=\sum_{j=i\cdot 2^k}^{(i+1)\cdot 2^k-1}[j\%n=x]
\end{aligned}
$$
拆成两个前缀和之差的形式，也就是：
$$
p_k[i]=\sum_{j=0}^{i\cdot 2^k-1}[j\%n=x]=\left\lfloor\dfrac{i\cdot 2^k-1}{n}\right\rfloor+[(i\cdot 2^k-1)\%n\ge x]
$$
把这个 $p$ 写回 $ans(k)$ 的表达式中，然后进行化简：
$$
\begin{aligned}
ans(k)
&=\sum_{i=0}^{n-1}a[i]\cdot m_k[i]\\
&=\sum_{i=0}^{n-1}a[i]\cdot (p_k[i+1]-p_k[i])\\
&=\sum_{i=0}^{n}p_k[i]\cdot (a[i-1]-a[i])
\end{aligned}
$$
令 $a[-1]=a[n]=0$，然后记 $b[i]=a[i-1]-a[i]$ $(0\le i\le n)$，继续化简：
$$
\begin{aligned}
ans(k)
&=\sum_{i=0}^{n}\left(\left\lfloor\dfrac{i\cdot 2^k-1}{n}\right\rfloor+[(i\cdot 2^k-1)\%n\ge x]\right)\cdot b[i]\\
&=\sum_{i=0}^{n}\left(\dfrac{i\cdot 2^k-1}{n}-\dfrac{(i\cdot 2^k-1)\%n}{n}+[(i\cdot 2^k-1)\%n\ge x]\right)\cdot b[i]\\
&=\dfrac{1}{n}\left(2^k\sum_{i=0}^{n}i\cdot b[i]-\sum_{i=0}^{n}b[i]\right)+\sum_{i=0}^{n}\left([(i\cdot 2^k-1)\%n\ge x]-\dfrac{(i\cdot 2^k-1)\%n}{n}\right)\cdot b[i]
\end{aligned}
$$

前面这一部分好做，先忽略，最后别忘了加上，注意前面部分的 $b$ 是没改过定义的 $b$（下面会修改 $b$ 的定义）。

记 $c[i]=[(i-1)\%n\ge x]-\dfrac{(i-1)\%n}{n}$，那么上式变为 $ans(k)=\sum_{i=0}^nc[(i\cdot 2^k)\%n]\cdot b[i]$，注意到 $i=0$ 与 $i=n$ 对应的 $c$ 是相同的，因此把 $b[0]$ 与 $b[n]$ 合并起来，得到最终 $b$ 的定义与 $ans$ 的表达式：
$$
\begin{aligned}
b[i]&=a[(i-1)\%n]-a[i]\ \ (0\le i<n)\\
c[i]&=[(i-1)\%n\ge x]-\dfrac{(i-1)\%n}{n}\ \ (0\le i<n)\\
ans(k)&=\sum_{i=0}^{n-1}b[i]\cdot c[(i\cdot 2^k)\%n]
\end{aligned}
$$
至此，前面化简的部分结束，得到了一个奇怪的 “积卷积” 的式子，放弃思考直接套这个可以得到一个 $O(n\cdot \min(n,q))$ 的做法，有 $50\sim 65$ 分，即使放在当时的 ZJOI 考场上，这个分数也是相当可观的了（~~别问，问我当时就得了 20~~）。

---

现在来观察一下这个奇怪的 “积卷积” $ans(k)=\sum_{i=0}^{n-1}b[i]\cdot c[(i\cdot 2^k)\%n]$。

稍微手玩一些例子可以发现 $i\rightarrow (2i)\%n$ 会形成一个 $\rho$ 形的结构，并且前面环外的长度与 $n$ 中因子 $2$ 的个数有关，于是记 $t$ 满足 $2^t\parallel n$。

对 $k<t$  的，可以暴力预处理，因为 $t$ 的大小是 $O(\log n)$ 级别的。

对 $k\ge t$ 的，$i\cdot 2^k$ 一定进入了环中，并且此时 $2^t$ 整除 $(i\cdot 2^k)\%n$，不妨全部除去 $2^t$，然后把 $k$ 减去 $t$ 当做起点就在环上。这样就变成 $\% \dfrac{n}{2^t}$ （这是一个奇数）意义下的问题，注意到这时 $b,c$ 的定义也要相应做出改变：
$$
\begin{aligned}
B[i]&=\sum_{j=0}^{n-1}[j\equiv i\ (\bmod \dfrac{n}{2^t})]\cdot b[j]\\
C[i]&=c[i\times 2^t]\\
&0\le i<\dfrac{n}{2^t}
\end{aligned}
$$
在这个剩余系里观察 $\times 2$ 形成的环，记 $1$ 所在环的大小为 $L$，有如下两个性质：

- 每个环的大小均为 $L$ 的因子。
- 不同环长种数非常小（我记得是 $\le 5$ 的）。

$k$ 可能很大，因此要把它模上 $L$。

把每个环拿出来单独考虑，因为它们在 $\times 2$ 下是互不影响的。从某个点出发，把环上的点标出来记为 $l[0,\cdots,d-1]$，同时对环中的点 $i$，记它在 $l$ 中的下标为 $pos[i]$，于是值与下标的对应关系：
$$
\begin{aligned}
i&\rightarrow pos[i]\\
(i\cdot 2^k)\%\dfrac{n}{2^t}&\rightarrow (pos[i]+k)
\%d\end{aligned}
$$
很接近了，因为乘法已经变成加法了，继续做代换：
$$
B'[i]=B[l[i]]\ \ \ \ \ \ \ \ \ \ C'[i]=C[l[i]]\ \ \ \ \ \ \ \ (0\le i<d)
$$
这样：
$$
\begin{aligned}
B[i]\cdot C[(i\cdot 2^k)\%\dfrac{n}{2^t}]
&\Rightarrow B[l[pos[i]]]\cdot B[l[pos[(i\cdot 2^k)\%\dfrac{n}{2^t}]]]\\
&\Rightarrow B'[pos[i]]\cdot C'[(pos[i]+k)\%d]
\end{aligned}
$$
于是，$0\le k<L$ ，这个环对 $ans(k)$ 的贡献为 $\sum_{i=0}^{d-1}B'[i]\cdot C'[(i+k)\%d]$。

暂且对 $0\le k<d$ 的 $k$ 求出 $ans'(k)$，最终 $ans(k)$ 要加上 $ans'(k\%d)$，不过这是容易的。
$$
ans'(k)=\sum_{i=0}^{d-1}B'[i]\cdot C'[(i+k)\%d]
$$
这是一个循环差卷积，把 $B',C'$ 其一反转，然后正常卷一下，也不难解决。

最后，由于环的个数可能会很大，不能每个环对 $ans(k)$ 暴力贡献，但是可以把 $d$ 相同的环的 $ans'$ 合起来，再倍长到 $L$ 加到 $ans$ 上。根据之前的结论，不同的 $d$ 非常少，暴力扫描就可以承受了。

还有，$q$ 到了 $5\times 10^7$，不得不使用光速幂（光速幂思想参考 BSGS）。

代码已经写成屎山了，感兴趣的自己看看吧，那时式子的推法和现在的不太一样。[Link](https://www.luogu.com.cn/paste/beyrxylq)

---

## 作者：JohnVictor (赞：2)

和官方题解不太一样的推法（自己认为比较自然

首先想象一根不拉的拉面，也就是一个线段被等分成 $n$ 份，每一份依次染上 $1,2,\cdots,n$ 色，每一次将这个线段对折，对折 $k$ 次。问题变为对折完后长为 $\frac{1}{2^k}$ 的线段的 $\frac{x}{n}$ 处所含的 $2^k$ 层中，每一种颜色出现次数的加权和。

这里可以先把 $n$ 中 $2$ 的幂次去掉变成奇数，$O(n \log n)$ 暴力模拟前面 $\log n$ 次折叠，以下推导中默认 $n$ 是奇数。

此时不可能再约分了，注意到每一个贡献差不多就是 $\frac{2^k}{n}$，偏差的 $1$ 具体是：

先差分，差分完后应该贡献 $[\frac{i2^k+x}{n}](a_i-a_{i+1})$，不用取整的式子是容易计算的，因此我们可以改为计算 $(i 2^k +x)\bmod n \times b_i$，其中 $b$ 是 $a$ 的差分序列。再注意到 $i2^k+x \to i2^{k+1}+x$ 这个有向图是若干个圈的并，每一个圈长度都相同为 $2$ 模 $n$ 的阶，我们可以把每一个圈都分别算一次循环卷积求出所有本质不同的 $k$ 的答案，再把所有对应位置的答案加起来即可。 

具体回答询问的时候利用光速幂很容易做到 $O(1)$，总复杂度 $O(n\log n +q)$。

---

## 作者：dead_X (赞：2)

## 思路

首先考虑将 $n$ 变成奇数的 $2$ 倍，这是平凡的，只需要执行 $\log n$ 次操作即可。

这之后的操作中就只会有 $\lceil\frac{n}{4}\rceil$ 个不同的连续段。

然后考虑差分数组的变化，会从 $C,a_1,a_2,\cdots,a_m$ 变成 $C',-a_m,a_1,-a_{m-1},a_2,\cdots,-a_{\frac{m+1}{2}}$。

然后我们考虑这样一个排列 $a_1,a_2,\cdots,a_m,-a_m,\cdots,-a_2,-a_1$。

我们发现我们只需要考虑这个排列的若干次方之后的前 $x$ 项和 $C'$ ，考虑怎么求出来。

不难发现每一项变换完了之后的下标就只是乘 $2$ 模 $n+1$ 而已……

于是置换环长度肯定是 $\varphi(n+1)$ 的因数，直接每个置换单独做就行了。

具体地，这就相当于每个数会进行循环，只有循环到特定位置才计入答案，求每个位置的总和。

这显然是可以直接 FFT 的，求 $C'$ 也可以类似地做，只需要将差分数组乘上另一些系数即可。

然后这里时间复杂度 FFT 的部分不难证明是 $O(n\log n)$，毕竟一共 $O(n)$ 个位置还要拆成很多置换。

我的代码直接对于每个置换都 $O(\varphi(n+1))$ 刷了一遍表，时间复杂度可能不对？但是过了。

正确实现的时间复杂度为 $O(n\log n+nd(n)+q)$。

## 代码

```cpp
//ZJOI is 2 hd 4 me
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
inline int read()
{
    int r=0;
    char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') r=r*10+c-48,c=getchar();
    return r;
}
inline ull calc(const ull&x){return x-(__uint128_t(x)*9920937979283557439ull>>93)*998244353;}
const int p=998244353,h=(p+1)>>1;
inline ll qp(ll x,int y)
{
    ll res=1;
    for(ll t=x; y; t=calc(t*t),y>>=1) 
    	if(y&1) res=calc(res*t);
    return res;
}
int rev[1<<23],N=1;
inline void init()
{
    rev[0]=0,rev[1]=N>>1;
    for(int i=2,d=N>>2; i<N; i<<=1,d>>=1)
        for(int j=0; j<i; ++j) rev[i+j]=rev[j]+d;
    return ;
}
inline void NTT(ll* F,int op)
{
    for(int i=0; i<N; ++i) if(rev[i]>i) F[i]^=F[rev[i]]^=F[i]^=F[rev[i]];
    for(int len=2,M=1; len<=N; len<<=1,M<<=1)
    {
        ll w=qp(op?3:332748118,998244352/len);
        for(int l=0; l<N; l+=len)
        {
            ll w0=1;
            for(int i=l; i<l+M; ++i)
            {
                ll x=F[i],y=calc(w0*F[i+M]);
                ((F[i]=x+y)>=p)&&(F[i]-=p),((F[i+M]=x-y)<0)&&(F[i+M]+=p),w0=calc(w0*w);
            }
        }
    }
}
inline ull rd(ull &x) 
{
	x^=(x<<13),x^=(x>>7),x^=(x<<17);
	return x;
}
int a[22][2000003],val[2000003],cur[2000003];
ll A1[2000003],A2[2000003],B[2000003];
int f[2000003],g[2000003],w0[65536],w1[65536],W0[65536],W1[65536];
bool vis[2000003];
inline int q1(ull t){t%=998244352;return 1ll*w1[t>>16]*w0[t&65535]%p;}
inline int q2(ull t){t%=998244352;return 1ll*W1[t>>16]*W0[t&65535]%p;}
signed main()
{
    ull seed,lim,v,ans;
    int id=read(),T=read(),tmp=2,Tmp=1;
    w0[0]=W0[0]=w1[0]=W1[0]=1;
    for(int i=1; i<65536; ++i,(tmp<<=1)%=p) w0[i]=tmp;
    Tmp=tmp;
    for(int i=1; i<65536; ++i,tmp=1ll*tmp*Tmp%p) w1[i]=tmp;
    tmp=h;
    for(int i=1; i<65536; ++i,tmp=1ll*tmp*h%p) W0[i]=tmp;
    Tmp=tmp;
    for(int i=1; i<65536; ++i,tmp=1ll*tmp*Tmp%p) W1[i]=tmp;
    scanf("%llu",&seed);
    while(T--)
    {
        int n=read(),q=read(),x=read(),N_=n,X=x,Bl=1,sz,L;
        scanf("%llu",&lim),ans=0;
        while(!(N_&1)) N_>>=1,(++X)>>=1,Bl<<=1;
        sz=N_>>1,L=N_-1,(++X)>>=1;
        for(int i=1; i<=n; ++i) a[0][i]=read();
        for(int s=1; s<=21; ++s)
            for(int i=1; i<=(n>>1); ++i)
                a[s][(i<<1)-1]=a[s][i<<1]=1ll*(a[s-1][i]+a[s-1][n+1-i])*h%p;
        if(N_==1)
        {
        	for(int i=1; i<=q; ++i)
	        {
	            v=rd(seed)%lim;
	            if(v<=21) ans^=1ull*i*a[v][x];
	            else ans^=1ull*i*a[21][x];
	        }
	        printf("%llu\n",ans);
	        continue;
        }
        for(int i=1; i<=sz; ++i) 
        	val[i]=(a[21][i*(Bl<<1)+1]+p-a[21][(i-1)*(Bl<<1)+1])%p,
        	val[(sz+1-i)+sz]=(p-val[i])%p;
        for(int i=1; i<=L; ++i) vis[i]=0;
        int len=1,num=2;
        while(num!=1) ++len,((num<<=1)>N_)&&(num-=N_);
        for(int i=0; i<len; ++i) f[i]=g[i]=0;
        for(int i=1; i<=L; ++i) if(!vis[i])
        {
        	int x=i,c=-1;
        	while(!vis[x]) vis[x]=1,cur[++c]=x,((x<<=1)>N_)&&(x-=N_);
        	for(int i=0; i<=c; ++i) B[c-i]=val[cur[i]];
        	for(int i=0; i<=c; ++i) A1[i]=(cur[i]<X); 
        	for(int i=0; i<=c; ++i) A2[i]=cur[i]<=sz?(N_-(cur[i]<<1)):0;
        	++c;
        	for(N=1;N<=(c<<1);N<<=1);
        	for(int i=c; i<N; ++i) B[i]=A1[i]=A2[i]=0;
        	init(),NTT(A1,1),NTT(A2,1),NTT(B,1);
        	for(int i=0; i<N; ++i) A1[i]=1ll*A1[i]*B[i]%p;
        	for(int i=0; i<N; ++i) A2[i]=1ll*A2[i]*B[i]%p;
        	NTT(A1,0),NTT(A2,0);
        	int o=qp(N,p-2);
        	for(int i=0; i<N; ++i) A1[i]=1ll*A1[i]*o%p;
        	for(int i=0; i<N; ++i) A2[i]=1ll*A2[i]*o%p;
        	assert(len%c==0);
        	for(int i=0; i<c; ++i) A1[i]=(A1[i]+A1[c+i])%p;
        	for(int i=0; i<c; ++i) A2[i]=(A2[i]+A2[c+i])%p;
        	for(int i=0; i<len; ++i) f[i]=(f[i]+A1[(i+c-1)%c])%p;
        	for(int i=0; i<len; ++i) g[i]=(g[i]+A2[(i+c-1)%c])%p;
        	
        }
        int Wandering=qp(N_,p-2),Singer=0;
        assert(N_*Bl<=n);
        for(int i=0; i<N_; ++i) Singer=(Singer+a[21][i*Bl+1])%p;
        for(int i=1; i<=q; ++i)
        {
            v=rd(seed)%lim;
            if(v<=21) ans^=1ull*i*a[v][x];
            else ans^=1ull*i*
            (
            	(
            		(
            			1ll*Singer*q1(v-21)%p+p-g[(v-21)%len]
            		)
            		*Wandering%p
            		+f[(v-21)%len]
            	)
            	*q2(v-21)
            	%p
            ); 
        }
        printf("%llu\n",ans);
    }
    return 0;
}
```

---

## 作者：whiteqwq (赞：2)

[P8332 [ZJOI2022] 面条](https://www.luogu.com.cn/problem/P8332) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/16229785.html)

## 题意

定义序列 $a$ 上的一次操作为：

$$\forall_{1\leqslant i\leqslant n} b_i\leftarrow a_i+a_{n-i+1}$$
$$\forall_{1\leqslant i\leqslant n}a_i\leftarrow \frac{b_{\lceil\frac{i}{2}\rceil}}{2}$$

给定序列 $a$ 以及一个位置 $x$，$q$ 次询问，每次求 $a$ 应用 $k_i$ 次操作后，$a_x$ 的值是多少。

## 分析

巨大厉害题，搬运一下官方题解！

可能写的有点口胡，补完代码之后来补充一下。

将最后答案除以 $2^k$，那么我们第二个操作就不需要要除二了。

我们手玩一下操作过程：

$$abcdefgh\cdots z\rightarrow aabbccdd\cdots zz\rightarrow\cdots (a\times 2^w)(b\times 2^w)\cdots(z\times 2^w)\rightarrow (a\times 2^{t+1})(b\times 2^{t+1})\cdots(z\times 2^t)$$

（其中一个字母在不同阶段不代表相同数字）

也就是说，令 $t$ 为 $n$ 最低非零位，那么我们应用 $t+1$ 次操作后，会变成很多个长度为 $2^{t+1}$ 的相同段，最后接一个长度为 $2^t$ 的相同段。

显然这个过程的操作与询问都可以在 $O(n\log n)$ 内暴力模拟。

将长度为 $2^t$ 的相同段缩成一个字母，令新的序列为 $c_1,c_2\cdots,c_m$。考察接下来的操作造成的影响：

$$c_1,c_2,\cdots,c_m\rightarrow c_1+c_m,c_1+c_{m-1},c_2+c_{m-1},c_2+c_{m-2},\cdots$$

令差分数组为 $d$，那么操作就为：

$$d_1,d_2,\cdots,d_{m-1}\rightarrow -d_{m-1},d_1,-d_{m-2},\cdots$$

那么，一次操作就是 $d_1,d_2,\cdots d_{m-1},-d_1,-d_2,\cdots,-d_{m-1}$ 的一次置换，令这个置换为 $g$，我们询问的答案就是：

$$C+\sum_{i=1}^{m-1}[g^k(i)<x]d_i=C+\sum_{i=1}^{x-1}d_{g^{-k}(i)}$$

$C$ 可以简单计算出，后面这个式子考虑拆出所有置换环，每个置换环（设大小为 $c$）通过一次卷积求出所有 $k\in[0,c)$ 的答案。

将大小相同的置换环的答案加到一起，每次询问只需要枚举 $O(\sqrt n)$ 个置换环将答案加起来即可，复杂度 $O(n\log n+q\sqrt n)$，不能通过。

继续挖掘这个置换 $g$ 的性质（$g^{-1}$ 与 $g$ 性质相同），手玩可以发现所有置换环大小都是 $2$ 在 $2(m-1)$ 下的阶 $r$ 的因数。

也就是答案关于 $r$ 是循环的，那么我们将大小相同的置换环加和之后，直接维护 $k\in[0,r)$ 的答案就好了。

复杂度 $O(nd(n)+q)$，可以通过。

---

## 作者：SegTree (赞：1)

下面定义从 $0$ 开始，因此与原题有差异。

## 题面 / Statement
给定 $n,q,x$ 和一个序列 $a$，定义一次操作为：

+ $b_i\gets a_i+a_{n-i-1}$。
+ $a_i=\frac{1}{2}\times b_{\lceil\frac{i}{2}\rceil}$。

现在对于一个固定的 $x$，你需要回答 $q$ 个询问，每次查询 $k$ 次操作后 $a_x$ 的值，对 $998244353$ 取模。

## 题解 / Solution

先忽略乘以的 $\frac{1}{2}$ 的系数，最后乘上即可。

我们将操作进行时光倒流。

记 $f_{i,j}$ 为初始 $a_i$ 的值在 $j$ 次操作后对第 $x$ 个位置的贡献，则 $ans=\sum f_{i,k}a_i$。

考虑 $f$ 的转移式，当 $2j+1<n$ 时有 $f_{i,j}=f_{i-1,2j}+f_{i-1,2j+1}$，否则有 $f_{i,j}=f_{i-1,2(n-j-1)}+f_{i-1,2(n-j-1)+1}$。

特判 $k=0$ 的询问，显然有 $f_{i-1,*}$ 为回文的，因而上面的转移式可被化简为 $f_{i,j}=f_{i-1,2j}+f_{i-1,2j+1}$，其中的下标对 $n$ 取模。

为了保证回文的性质，下面将下标自动减 $1$。记 $f(i)$ 表示 $[i=\dfrac{x}{2}]+[i=n-1-\dfrac{x}{2}]$，也就是 $f_{0,i}$ 的值。

因此可以得到：

$f_{i,j}=\sum_{k=j\times 2^i}^{(j+1)\times 2^i-1}f(k\bmod n)$。

又记 $g_j=\sum_{k=0}^{j\times 2^i-1}f(k\bmod n)$。

$ans=\sum f_{i,j}a_j=\sum (g(j)-g(j-1))a_j=\sum g(j)b_j$，其中 $b_j=a_{j-1}-a_j$，视 $a_{-1}=a_n=0$。

考虑 $g(j)$ 的求法：

$g(j)=\sum_{k=0}^{j\times 2^i-1}f(k\bmod n)=2\lfloor\dfrac{j\times 2^i-1}{n}\rfloor+[(j\times 2^i-1)\bmod n\ge \lfloor\dfrac{x}{2}\rfloor+[(j\times 2^i-1)\bmod n\ge n-1-\lfloor\dfrac{x}{2}\rfloor]=2\dfrac{j\times 2^i-1}{n}+c_{j\times 2^i \bmod n}$，其中 $c_i=[i-1\bmod n\ge \dfrac{x}{2}]+[i-1\bmod n\ge n-1-\dfrac{x}{2}]-2\dfrac{(i-1)\bmod n}{n}$。

左边的项可以拆成常数乘以 $2^i$ 加上常数，易于计算。

此时问题转化为：给定 $j$，求 $\sum b_jc_{j\times 2^i\bmod n}$。

注意到将 $j$ 连向 $j\times 2\bmod n$，这是一颗深度为 $\log n$ 的基环树森林，我们对于前 $O(\log n)$ 轮暴力计算。对于剩余情况，所有的点都已经跳到环上。

此时查询的 $k$ 可以对环长取模，于是考虑预处理答案。

此时因为整个问题都在环上，我们按照环上的顺序依次取出 $b,c$，则需要计算 $d_{(j-i)\bmod L}\gets d_{(j-i)\bmod L}+a_ib_j$，其中 $L$ 为环长。这是易于使用 NTT 解决的。

最后我们要处理每个环对答案的贡献，由于环长的种数较小，且环长的 $\text{lcm}$ 就是 $1$ 所在的环长，因此暴力处理每个环长对答案的贡献即可。

---

## 作者：feecle6418 (赞：1)

好牛逼啊，虽然做过兔子跳那题但是还是不会。为啥会去差分呢？为啥要发现是乘 2 呢？

考虑执行 $t$ 次操作后（$2^t|n,2^{t+1}\not| n$），整个序列会变成一些长度为 $2^{t+1}$ 的段和一个长度为 $2^t$ 的段。可以发现之后一直会保持此结构，故最终结果是 $[a,a,b,b,c,c,d,d,e]$ 这样子的。考虑执行一次操作后变成 $[a+e,a+e,a+d,a+d,b+d,b+d,b+c,b+c,2c,2c]$。

接下来就特别牛逼的一步，考虑对 $[a,b,c,d,e]$ 这个数组执行差分，看差分的变化：$[b-a,c-b,d-c,e-d]\to [d-e,b-a,c-d,c-b]$

（这一步的 intuition 是啥呢？其实很容易发现经过几次操作之后整个会很平均，然后就会想去每个位置都减掉最小值之类的找规律，然而“差分”其实也是其中一种处理方式）

也即 $[b_1,b_2,b_3,b_4]\to [-b_4,b_1,-b_3,b_2]$ 这样。这就是置换形式，直接求幂可以做到 $O(qn)$。

接下来又是很离谱的一步，考虑把排列补全成这样子：$[b_1,b_2,b_3,b_4,-b_4,-b_3,-b_2,-b_1]$（可能并不需要，但这样更直观），然后变成 $[-b_4,b_1,-b_3,b_2,-b_2,b_3,-b_1,b_4]$。

注意到这个排列其实是 $[1,2,3,4,5,6,7,8]\to [5,1,6,2,7,3,8,4]$。来考虑 $1$ 的位置变化，发现是 $1\to 2\to 4\to 8\to 7\to 5\to 1$ 这样，*观察到* 就是 $x\to (2x\bmod (2\times 4+1))$！所以这个“置换”其实就是把每个位置在模 $2\times n-1$ 意义下乘二，也即每个置换环的大小都是 $\varphi(2n-1)$ 的约数（$2^{\dots}=1$）。

（草，这一步我真的不懂 intuition 是啥，有没有人告诉我！）

因为给出差分数组 $b_1,b_2,\dots,b_{n-1}$ 以及和（显然和每次翻倍），可以求出 $a_1=(S+\sum b_i(n-i))/n$，$a_x=a_1+b_1+\dots+b_{x-1}=S/n+\sum_{i<x}b_i(2n-i)/n+\sum_{i\ge x}b_i(n-i)/n$，设 $w_i$ 是 $i$ 位置的差分对 $x$ 的贡献，则每个置换环内部的贡献方式就是循环卷积状物，用 FFT 做到 $O(n\log n)$（总共）。然后对于每种置换环长度，用 $O(n)$ 的时间处理出这时对整个长为 $\varphi(2n-1)$ 的序列的总贡献，这部分是 $O(nd(n))$。$2^k$ 用光速幂处理，询问单次 $O(1)$。总复杂度 $O(n\log n+nd(n)+q)$。

https://uoj.ac/submission/565383

---


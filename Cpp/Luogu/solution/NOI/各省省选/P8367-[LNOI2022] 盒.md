# [LNOI2022] 盒

## 题目描述

有 $n$ 个不同的盒子排成一排。在初始状态下，第 $i$ 个盒子放有 $a_i$ 个货物，总货物数量为 $S = \sum_{i = 1}^{n} a_i$。对于非负整数数组 $(b_1, b_2, \ldots, b_n)$ 满足 $\sum_{i = 1}^{n} b_i = S$，考察以下问题：

你想让第 $i$ 个盒子中拥有恰好 $b_i$ 个货物，为此你可以做如下操作若干次：对两个相邻的盒子，把其中一个盒子的**恰好一个**货物移动至另一个。对 $i, i + 1$（$1 \le i < n$）号盒子做**一次**操作的代价为 $w_i$。**注意：将 $\bm{i}$ 号盒子的一个货物移动到 $\bm{i + 1}$ 号盒子和将 $\bm{i + 1}$ 号盒子的一个货物移动到 $\bm{i}$ 号盒子的代价都是 $\bm{w_i}$**。你需要保证在操作中不存在盒子中的货物数量是负数。

在以上问题下，定义从初始状态达到第 $i$ 个盒子拥有恰好 $b_i$ 个货物的状态的最小代价为 $\operatorname{val}(b_1, b_2, \ldots, b_n)$，你需要求出对所有满足 $\sum_{i = 1}^{n} b_i = S$ 的非负整数数组 $(b_1, b_2, \ldots, b_n)$，$\operatorname{val}(b_1, b_2, \ldots, b_n)$ 的和。输出这个答案对 $998244353$ 取模后的结果。

## 说明/提示

**【样例解释 \#1】**

对于第一组数据，一共有六种需要考虑的情形，它们的 $b_1$ 和 $b_2$ 构成的二元组 $(b_1, b_2)$ 分别为 $(0, 5), (1, 4), (2, 3), (3, 2), (4, 1), (5, 0)$。

对于第一种情形，需要至少 $2$ 次移动，代价最小值为 $65472 \times 2 = 130944$。

对于第二种情形，需要至少 $1$ 次移动，代价最小值为 $65472$。

对于第三种情形，不需要做任何操作，代价最小值为 $0$。

对于第四种情形，需要至少 $1$ 次移动，代价最小值为 $65472$。

对于第五种情形，需要至少 $2$ 次移动，代价最小值为 $65472 \times 2 = 130944$。

对于最后一种情形，需要至少 $3$ 次移动，代价最小值为 $65472 \times 3 = 196416$。

因此，最小代价之和为 $130944 + 65472 + 0 + 65472 + 130944 + 196416 = 589248$。

**【样例 \#2】**

见附件中的 `box/box2.in` 与 `box/box2.ans`。

这个样例满足测试点 $5 \sim 8$ 的限制。

**【样例 \#3】**

见附件中的 `box/box3.in` 与 `box/box3.ans`。

这个样例满足测试点 $9 \sim 12$ 的限制。

**【样例 \#4】**

见附件中的 `box/box4.in` 与 `box/box4.ans`。

这个样例满足测试点 $13 \sim 14$ 的限制。

**【样例 \#5】**

见附件中的 `box/box5.in` 与 `box/box5.ans`。

这个样例满足测试点 $15 \sim 16$ 的限制。

**【样例 \#6】**

见附件中的 `box/box6.in` 与 `box/box6.ans`。

这个样例满足测试点 $17 \sim 18$ 的限制。

**【数据范围】**

保证对于任何测试点的任何一组数据，有 $2 \le n \le 5 \times {10}^5$，$1 \le S \le 2 \times {10}^6$，$a_i \ge 0$，$0 \le w_i < 998244353$。

| 测试点编号 | $T \le$ | $n \le$ | $S \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $1000$ | $5$ | $5$ | A |
| $3 \sim 4$ | $5$ | $9$ | $9$ | 无 |
| $5 \sim 8$ | $10$ | $2000$ | $2000$ | 无 |
| $9 \sim 12$ | $10$ | $2000$ | $2 \times {10}^5$ | 无 |
| $13 \sim 14$ | $2$ | $2 \times {10}^5$ | $2 \times {10}^5$ | B |
| $15 \sim 16$ | $2$ | $2 \times {10}^5$ | $2 \times {10}^5$ | AC |
| $17 \sim 18$ | $2$ | $2 \times {10}^5$ | $2 \times {10}^5$ | 无 |
| $19 \sim 20$ | $5$ | $5 \times {10}^5$ | $2 \times {10}^6$ | 无 |

特殊性质 A：对于任意 $1 \le i < n$，$w_i = 1$。  
特殊性质 B：对于任意 $1 \le i < n - 20$，$a_i = 0$。  
特殊性质 C：最多只有 $20$ 个 $i \in [1, n]$ 满足 $a_i \ne 0$。

**【提示】**

本题有读入量较大的测试点，为了优化程序运行的时间，我们建议你采用较为快速的读入方式。

## 样例 #1

### 输入

```
2
2
2 3
65472
5
1 3 2 1 1
2 3 3 3
```

### 输出

```
589248
8589
```

# 题解

## 作者：Kubic (赞：35)

首先考虑给定 $a,b$ 怎么算答案。

令 $c,d$ 分别为 $a,b$ 的前缀和，那么答案即为：

$$\sum\limits_{i=1}^nw_i|c_i-d_i|$$

题目中给定了 $a$，于是 $c$ 也可以求出来。

令 $m=c_n$，即题目中的 $S$。

根据期望的线性性，我们可以枚举 $i,d_i$ 算贡献。一对 $i,d_i$ 出现的条件是前 $i$ 个数和为 $d_i$ 且后 $n-i$ 个数和为 $m-d_i$。这个是经典问题，可以用插板法解决。那么答案可以表示为：

$$\sum\limits_{i=1}^nw_i\sum\limits_{j=0}^{m}|j-c_i|\dbinom{i+j-1}{i-1}\dbinom{n-i+m-j-1}{n-i-1}$$

此时我们已经得到了一个 $O(nm)$ 的做法，可以得到 $40\operatorname{pts}$。

我们可以只考虑 $j\le c_i$ 的部分，$j>c_i$ 的部分可以类似解决。

令

$$f(n,m,i,k)=\sum\limits_{j=0}^{k}\dbinom{i+j-1}{i-1}\dbinom{n-i+m-j-1}{n-i-1}$$

$$g(n,m,i,k)=\sum\limits_{j=0}^{k}j\dbinom{i+j-1}{i-1}\dbinom{n-i+m-j-1}{n-i-1}$$

我们只需要对于每一个 $i$ 算出 $f(n,m,i,c_i)$ 和 $g(n,m,i,c_i)$ 就行了。

可以注意到：

$$j\dbinom{i+j-1}{i-1}=j\dbinom{i+j-1}{j}=i\dbinom{i+j-1}{i}$$

代入可得：

$$g(n,m,i,k)=i\sum\limits_{j=0}^{k}\dbinom{i+j-1}{i}\dbinom{n-i+m-j-1}{n-i-1}$$

$$=i\sum\limits_{j=0}^{k-1}\dbinom{i+j}{i}\dbinom{n-i+m-j-2}{n-i-1}$$

$$=i\times f(n+1,m-1,i+1,k-1)$$

因此我们只需要解决 $f$ 即可。

我们可以用类似于莫队的思想，每次将 $i$ 或者 $k$ 变化 $1$，同时维护答案。

因为 $c$ 是单调不降的，所以我们这种移动只会有 $O(n+m)$ 次。

$k$ 变化是很好处理的，只需要按照 $f$ 的表达式直接计算即可。

$i$ 变化就不那么好处理了，怎么办呢！

换一个角度考虑 $f$。

$f(n,m,i,k)$ 的组合意义是前 $i$ 个数和 $\le k$ 且所有 $n$ 个数和为 $m$ 的方案数。

其实就是把 $m$ 个无序的小球放进 $n$ 个有序的盒子里，要求前 $i$ 个盒子里的小球总数不超过 $k$。

而这相当于从左往右第 $k+1$ 个小球不在前 $i$ 个盒子里！

枚举第 $k+1$ 个小球放在哪个盒子里，可以得到：

$$f(n,m,i,k)=\sum\limits_{j=i+1}^n\dbinom{j+k-1}{j-1}\dbinom{n-j+m-k-1}{n-j}$$

此时 $i$ 变化的解决方案已经显而易见了！

于是，我们在 $O(n+m)$ 的时间复杂度内解决了本题。

当然如果你是 nb 老哥，直接对着式子硬推据说也是能做的！

---

## 作者：wind_whisper (赞：23)

## $\text{Foreword}$
一道比较神的数学题...  
考场写的 40 分做法，感觉自己实际数学水平也就这 40 分了（悲  
出题人给了两种做法，我的评价是：~~组合意义天地灭，代数推导天地灭~~。  
感觉组合意义还是相对阳间一点的，所以讲解一下这种做法。
## $\text{Solution}$
问题很典，定义 $s_i=\sum_{j=1}^ia_j$，单独考虑每条边的贡献，答案就是：
$$ans=\sum_{i=1}^{n-1}w_i\sum_{j=0}^S|s_i-j|f(i,j)f(n-i,S-j)$$
其中 $f(i,j)$ 表示 $i$ 个非负元素加和为 $j$ 的方案数，隔板法不难得出 $f(i,j)=\binom {i+j-1}{i-1}$。  
那么答案就是：  
$$ans=\sum_{i=1}^{n-1}w_i\sum_{j=0}^S|s_i-j|\binom{i+j-1}{i-1}\binom {n-i+S-j-1}{n-i-1}$$
~~然后就可以拿 40 跑路了。~~  
接下来我们重点关心对于每一个 $i$，如何快速计算内层枚举 $j$ 的结果 $res_i$。  
把绝对值拆掉，再把求和用前缀和作差改成从 0 开始，就有：
$$res_i=2\sum_{j=0}^{s_i}(s_i-j)\binom{i+j-1}{i-1}\binom {n-i+S-j-1}{n-i-1}+\sum_{j=0}^S(j-s_i)\binom{i+j-1}{i-1}\binom {n-i+S-j-1}{n-i-1}$$
两者本质上只有枚举上界不同，显然后面上界为 $S$ 的式子更好做，我们重点关心一下这部分。  
来自[组合数问题](https://www.luogu.com.cn/problem/P6620)的 trick：$j\binom{i+j-1}{j}=i\binom {i+j-1}{j-1}$，那么后面的式子就是：
$$i\sum_{j=0}^S\binom {i+j-1}{j-1}\binom{n-i+S-j-1}{S-j}-s_i\sum_{j=0}^S\binom{i+j-1}{j}\binom {n-i+S-j-1}{S-j}$$
前面组合数里的 $j-1$ 会出现 $-1$ 令人感到生理不适...回到原式发现这个地方对应的项是 0，所以不妨从 $1$ 开始枚举，再令 $j\gets  j-1$，就是：
$$i\sum_{j=0}^{S-1}\binom {i+j}{j}\binom{n-i+S-j-2}{S-j-1}-s_i\sum_{j=0}^S\binom{i+j-1}{j}\binom {n-i+S-j-1}{S-j}$$
好，到这里~~我们就不会了~~需要进一步的赋予这两个和式新的组合意义，首先，考虑一个简单的组合问题：从 $(0,0)->(n,m)$，只能往右上走的方案数是多少？  
显然是 $\binom {n+m}{n}$。换个角度，考虑其从第 $i$ 列移动到第 $i+1$ 列时的纵坐标的位置 $j$，就可以从另一个角度来计算这个方案数，因此有：
$$\binom {n+m}{n}=\sum_{j=0}^m\binom{i+j}{j}\binom{n+m-i-j-1}{m-j}$$

我们把原来的柿子试图往这个形式上套：
$$i\sum_{j=0}^{S-1}\binom {i+j}{j}\binom{n-i+S-j-2}{S-j-1}-s_i\sum_{j=0}^S\binom{i+j-1}{j}\binom {n-i+S-j-1}{S-j}$$
$$=i\sum_{j=0}^{S-1}\binom {i+j}{j}\binom{n+(S-1)-i-j-1}{(S-1)-j}-s_i\sum_{j=0}^S\binom{(i-1)+j}{j}\binom {(n-1)-(i-1)+S-j-1}{S-j}$$
$$=i\binom {n+S-1}{n}-s_i\binom {n+S-1}{S}$$
这样这部分我们就解决了。  

再考虑另一个和式，发现其实唯一的不同就是枚举上界发生了变化，那么对应的组合意义就变成了形如：从 $(0,0)->(n,m)$ 在第 $p$ 列的纵坐标不能超过 $q$ 的方案数是多少？  
那么这个限制其实也就等价于：从第 $q$ 行走到第 $q+1$ 行时，横坐标至少为 $p+1$，两种角度对应的方案数相等，就有：
$$\sum_{i=0}^q\binom{p+i}{i}\binom{n+m-p-i-1}{m-i}=\sum_{i=p+1}^n\binom{i+q}{q}\binom{n+m-i-q-1}{n-i}$$
有了这两个柿子，我们就可以 $O(1)$ 的从 $(n,m,p,q)$ 的答案转移到 $(n,m,p,q+1)$ 和 $(n,m,p+1,q)$。  
回到我们实际的问题，发现我们需要的 $p/q$ 确实都是单调不降的，所以我们采用这样的方法暴力移动 $p,q$  两个指针均摊复杂度就可以做到线性了。  
## $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned ll
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("OK\n")
inline ll read() {
  ll x(0),f(1);char c=getchar();
  while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
  while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
  return x*f;
}

const int N=3e6+100;
const double inf=1e18;
const int mod=998244353;

inline ll ksm(ll x,ll k){
  ll res=1;
  while(k){
    if(k&1) res=res*x%mod;
    x=x*x%mod;
    k>>=1;
  }
  return res;
}

int n;

ll jc[N],ni[N];
void init(int n){
  jc[0]=1;
  for(int i=1;i<=n;i++) jc[i]=jc[i-1]*i%mod;
  ni[n]=ksm(jc[n],mod-2);
  for(int i=n-1;i>=0;i--) ni[i]=ni[i+1]*(i+1)%mod;
  return;
}
inline ll C(int n,int m){
  //if(n<m){
    //ok;
  //}
  return n<m?0:jc[n]*ni[m]%mod*ni[n-m]%mod;
}

struct Calc{
  int n,m,p,q;
  ll res;
  void init(int N,int M){
    n=N;m=M;
    p=0;q=0;
    assert(n+m-1>=m);
    res=C(n+m-1,m);
    return;
  }
  inline ll calc(int P,int Q){
    //if(p<0||q<0) return 0;
    while(q<Q){
      ++q;
      //assert(n+m-q-p-1>=m-q);
      (res+=C(q+p,q)*C(n+m-q-p-1,m-q))%=mod;
    }
    while(p<P){
      ++p;
      //assert(n+m-q-p-1>=n-p);
      res=(res-C(p+q,p)*C(n+m-p-q-1,n-p)%mod+mod)%mod;
    }
    return res;
  }
}f1,f2;

ll s[N],w[N],S;
void work(){
  n=read();
  for(int i=1;i<=n;i++) s[i]=s[i-1]+read();
  for(int i=1;i<n;i++) w[i]=read();  
  S=s[n];
  f1.init(n-1,S);
  f2.init(n,S-1);
  ll ans(0);
  for(int i=1;i<n;i++){
    ll add(0);
    assert(n+S-1>=n);
    assert(n+S-1>=S);
    //printf("i=%d s=%lld\n",i,s[i]);
    add=(add+i*C(n+S-1,n))%mod;    
    //printf("  add=%lld\n",add);
    add=(add+mod-s[i]*C(n+S-1,S)%mod)%mod;
    //printf("  add=%lld\n",add);
    if(s[i]) add=(add+2*s[i]*f1.calc(i-1,s[i]))%mod;
    //printf("  add=%lld\n",add);
    if(s[i]) add=(add+mod-2*i*f2.calc(i,s[i]-1)%mod)%mod;
    //printf("  add=%lld\n",add);
    ans=(ans+add*w[i])%mod;
    //printf("%lld %lld\n",ans,add*w[i]%mod);
  }
  printf("%lld\n",ans);
}

signed main(){
  #ifndef ONLINE_JUDGE
  freopen("a.in","r",stdin);
  freopen("a.out","w",stdout);
  #endif
  init(2e6+5e5+500);
  int T=read();
  while(T--) work();
  return 0;
}
/*
*/
```


---

## 作者：whiteqwq (赞：8)

[P8367 [LNOI2022] 盒](https://www.luogu.com.cn/problem/P8367) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/16488026.html)

还是不够熟练啊。。。

## 题意

数轴上有 $n$ 个位置有球，第 $i$ 个位置有 $a_i$ 个，将一个球从 $i$ 移动到 $i+1$（或从 $i+1$ 移动到 $i$）需要花费 $w_i$ 的代价。

你可以进行任意次操作，对于所有的结果数量序列 $b$，计数 $a$ 变成 $b$ 的最小代价之和。

$1\leqslant n\leqslant 5\times 10^5,1\leqslant \sum a_i\leqslant 2\times10^6$。

## 分析

列出 dp（或直接考虑贡献），化为式子可得：
$$
\sum_{i=1}^{n-1}w_i\sum_{j=0}^S|j-sum_i|{j+i-1\choose i-1}{n-i-1+S-j\choose n-i-1}
$$
上面相当于对后面的式子线性组合，我们考虑要对于每个 $i$ 计算：（$C=sum_i,S$）
$$
\sum_{j=0}^C{j+i-1\choose i-1}{n-i-1+S-j\choose n-i-1}
$$
$$
\sum_{j=0}^Cj{j+i-1\choose i-1}{n-i-1+S-j\choose n-i-1}
$$
$$
=i\sum_{j=0}^{C-1}{j+i\choose i}{n-i-2+S-j\choose n-i-1}
$$
先尝试 $C=S-c$：
$$
\sum_{j=0}^{S-c}{j+i+c-1\choose i+c-1}{n-i-1+S-c-j\choose n-i-1}={n+S-1\choose n+c-1}
$$
范德蒙德卷积本质上是格路计数，我们想类似格路计数地处理：
$$
\sum_{j=0}^A{B+j\choose B}{C-B-1+D-j\choose C-B-1}
$$
考察其组合意义，即为 $(0,0)$ 走到 $(C,D)$，在从第 $B$ 列走到 $B+1$ 列时，其对应行不超过 $A$。

类似类欧几里得算法，我们将坐标系翻转，问题变成了从 $(0,0)$ 走到 $(D,C)$，在从 $A$ 列走到 $A+1$ 列时，其对应行超过了 $B$，于是上式又可写作：
$$
\sum_{j=B+1}^C{A+j\choose A}{D-A-1+C-j\choose D-A-1}
$$
由于 $sum_i$ 递增，我们只需用两个指针模拟 $A$ 和 $B$ 的增加，$A$ 移动时变化上面的式子，$B$ 移动时变化下面的式子即可，复杂度线性。

## 代码

组合数之和可以写一个结构体一起维护，这样比较方便。

```cpp
#include<stdio.h>
#include<stdlib.h>
char buf[1<<21],*p1=buf,*p2=buf,obuf[1<<21],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
const int maxn=500005,maxN=2500005,mod=998244353;
int T,n,S,res;
int a[maxn],sum[maxn],fac[maxN],nfac[maxN];
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod,b>>=1;
	}
	return res;
}
void read(int &x){
	x=0;
	char c=getchar();
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+c-48;
}
inline int C(int a,int b){
	return a<b? 0:1ll*fac[a]*nfac[b]%mod*nfac[a-b]%mod;
}
struct binom{
	int a,b,c,d,s;
	void init(int cc,int dd){
		a=b=0,c=cc,d=dd,s=C(c+d-1,c-1);
	}
	int calc(int aa,int bb){
		while(a<aa)
			a++,s=(s+1ll*C(b+a,a)*C(c-b-1+d-a,c-b-1))%mod;
		while(b<bb)
			b++,s=(s+1ll*(mod-C(a+b,a))*C(d-a-1+c-b,d-a-1))%mod;
		return s;
	}
}B1,B2;
int main(){
	fac[0]=1;
	for(int i=1;i<maxN;i++)
		fac[i]=1ll*fac[i-1]*i%mod;
	nfac[maxN-1]=ksm(fac[maxN-1],mod-2);
	for(int i=maxN-1;i>=1;i--)
		nfac[i-1]=1ll*nfac[i]*i%mod;
	read(T);
	while(T--){
		read(n),res=0;
		for(int i=1;i<=n;i++)
			read(a[i]),sum[i]=sum[i-1]+a[i];
		S=sum[n],B1.init(n-1,S),B2.init(n,S-1);
		for(int i=1,x;i<n;i++){
			int ans=0;
			ans=(1ll*i*C(n+S-1,n)+1ll*(mod-sum[i])*C(n+S-1,n-1))%mod;
			if(sum[i]){
				ans=(ans+2ll*sum[i]*B1.calc(sum[i],i-1))%mod;
				ans=(ans+2ll*(mod-i)*B2.calc(sum[i]-1,i))%mod;
			}
			read(x),res=(res+1ll*ans*x)%mod;
		}
		printf("%d\n",res);
	}
	return 0;
}
```

---

## 作者：_slb (赞：6)


# T3 box

## Description

有 $n$ 个不同的盒子排成一排。在初始状态下，第 $i$ 个盒子放有 $a_i$ 个货物，总货物数量为 $S = \sum_{i = 1}^{n} a_i$。对于非负整数数组 $(b_1, b_2, \ldots, b_n)$ 满足 $\sum_{i = 1}^{n} b_i = S$，考察以下问题：

你想让第 $i$ 个盒子中拥有恰好 $b_i$ 个货物，为此你可以做如下操作若干次：对两个相邻的盒子，把其中一个盒子的恰好一个货物移动至另一个。对 $i, i + 1$（$1 \le i < n$）号盒子做**一次**操作的代价为 $w_i$。你需要保证在操作中不存在盒子中的货物数量是负数。

在以上问题下，定义从初始状态达到第 $i$ 个盒子拥有恰好 $b_i$ 个货物的状态的最小代价为 $\operatorname{val}(b_1, b_2, \ldots, b_n)$，你需要求出对所有满足 $\sum_{i = 1}^{n} b_i = S$ 的非负整数数组 $(b_1, b_2, \ldots, b_n)$，$\operatorname{val}(b_1, b_2, \ldots, b_n)$ 的和。输出这个答案对 $998244353$ 取模后的结果。

## Solution

不会的数学题，越学越认识到自己垃圾的数学水平...

感觉是一篇详细的题解。

我们对每条边算出其对答案的贡献，设 $s_i=\sum_{j=1}^ia_j,S=s_n$，枚举 $j=\sum_{k=1}^ib_k$，那么方案数为前 $i$ 个盒子里放 $j$ 个货物的方案数乘上后 $n-i$ 个盒子里放 $S-j$ 个货物的方案数，这里盒子可以为空，用插板法搞一下就可以得出答案的式子：
$$
ans=\sum_{i=1}^n w_i\sum_{j=0}^S|j-s_i|\binom{i+j-1}{i-1}\binom{n-i+S-j-1}{n-i-1}
$$
我们主要关心第二个求和式子。

绝对值显然不好搞，给拆掉，然后把少加的部分补进去。
$$
\begin{aligned}
&\sum_{j=0}^S|j-s_i|\binom{i+j-1}{i-1}\binom{n-i+S-j-1}{n-i-1}\\
=&\sum_{j=0}^{S}(j-s_i)\binom{i+j-1}{i-1}\binom{n-i+S-j-1}{n-i-1}+2\sum_{j=0}^{s_i}(s_i-j)\binom{i+j-1}{i-1}\binom{n-i+S-j-1}{n-i-1}
\end{aligned}
$$
这里 $j=s_i$ 的项为了方便在两边都算进去了，反正是 $0$ 不影响。

前面和后面的形式是相同的，后一个显然更强一些（因为有循环上界的限制），我们先考虑后一个式子。把后一个求和式子拆开，我们关心的是：
$$
s_i\sum_{j=0}^{s_i}\binom{i+j-1}{i-1}\binom{n-i+S-j-1}{n-i-1}-\sum_{j=0}^{s_i}j\binom{i+j-1}{i-1}\binom{n-i+S-j-1}{n-i-1}
$$
想要把这两个式子统一起来，后一个求和式子的 $j$ 要想办法换成一个常数移到外面来，有
$$
j\binom{i+j-1}{i-1}=j\times\frac{(i+j-1)!}{(i-1)!j!}=i\times\frac{(i+j-1)!}{i!(j-1)!}=i\binom{i+j-1}{i}
$$
这样后面的式子就变成
$$
i\sum_{j=0}^{s_i}\binom{i+j-1}{i}\binom{n-i+S-j-1}{n-i-1}
$$
已经基本统一了，但是具体的加一/减一上还需要稍微凑一下，为了方便我们设
$$
f(n,s,i,k)=\sum_{j=0}^k\binom{i+j-1}{i-1}\binom{n-i+s-j-1}{n-i-1}
$$
观察一下，想让 $\dbinom{i+j-1}{i}$ 对上 $\dbinom{i+j-1}{i-1}$ 这一项，$i$ 需要对应 $i-1$，那组合数上面的 $j$ 就得对应 $j+1$，因此我们对刚刚后面的式子进行一个小调整，枚举原来的 $j-1$，这样就变为：
$$
i\sum_{j=0}^{s_i-1}\binom{i+j}{i}\binom{n-i+S-j}{n-i-1}
$$
这样就能一一凑上了，上式等于 $i\times f(n+1,s-1,i+1,k-1)$。

把 $f$ 带回最开始的式子，对于每个 $i$，我们要求出：
$$
i\times f(n+1,S-1,i+1,S-1)-s_i\times f(n,S,i,S)+2\times f(n,S,i,s_i)-2i\times f(n+1,S-1,i+1,s_i-1)
$$
注意到 $i$ 和 $s_i$ 都是不降的，那么问题就变为：已知 $f(n,s,i,k)$，要快速求出 $f(n,s,i+1,k),f(n,s,i,k+1)$。

$f(n,s,i,k+1)$ 直接根据 $f$ 的定义求就好了，难的是 $i$ 的增加。

我是推不动，这里回到组合意义就很神仙，考虑 $f$ 的组合意义，是总共有 $n$ 个盒子，$s$ 个货物要放到这些盒子里，前 $i$ 个盒子最多放 $k$ 个货物的方案数。怎么理解呢？就是枚举前 $i$ 个盒子放几个货物，同样插板法。

我们需要一个枚举盒子的组合意义，换个思路，等价于第 $k+1$ 个货物所在的盒子大于 $i$。枚举这个盒子 $j$，方案数为前 $j$ 个盒子放 $k$ 个货物的方案数乘上后 $n-j+1$ 个盒子放 $S-k-1$ 个货物的方案数，同样插板法，式子就是：
$$
f(n,s,i,k)=\sum_{j=i+1}^n\binom{j+k-1}{j-1}\binom{n-j+s-k-1}{n-j}
$$
这个就可以随着 $i$ 的变化 $O(1)$ 维护了。

把四个 $f$ 分别维护，就做完了，好耶！

## Code

```cpp
namespace solve
{
    const int maxn = 3e6 + 10;
    const int mod = 998244353;
    typedef long long ll;

    ll qpow(ll a, ll x, ll p)
    {
        ll res = 1;
        for (; x; x >>= 1, a = a * a % p)
            if (x & 1)
                res = res * a % p;
        return res;
    }

    ll fac[maxn], ifac[maxn];
    int n;

    void init(int n = 3e6)
    {
        fac[0] = 1;
        for (int i = 1; i <= n; i++)
            fac[i] = fac[i - 1] * i % mod;
        ifac[n] = qpow(fac[n], mod - 2, mod);
        for (int i = n - 1; i >= 0; i--)
            ifac[i] = ifac[i + 1] * (i + 1) % mod;
    }

    inline ll C(int n, int m) { return m > n || m < 0 || n < 0 ? 0 : fac[n] * ifac[m] % mod * ifac[n - m] % mod; }

    int sum[maxn], w[maxn];
    int S;

    inline ll f(int n, int S, int i, int k)
    {
        ll res = 0;
        for (int j = 0; j <= k; j++)
            (res += C(i + j - 1, i - 1) * C(n - i + S - j - 1, n - i - 1) % mod) %= mod;
        return res;
    }

    struct func
    {
        int n, s, i, k;
        ll res;
        void init(int n_, int s_, int i_, int k_)
        {
            n = n_, s = s_, i = i_, k = k_;
            res = 0;
            for (int j = 0; j <= k; j++)
                res += C(i + j - 1, i - 1) * C(n - i + s - j - 1, n - i - 1) % mod;
            res %= mod;
        }
        void movek(int nk)
        {
            if (nk <= k)
                return;
            for (int j = k + 1; j <= nk; j++)
                res += C(i + j - 1, i - 1) * C(n - i + s - j - 1, n - i - 1) % mod;
            res %= mod;
            k = nk;
        }
        void movei(int ni)
        {
            if (ni <= i)
                return;
            for (int j = i + 1; j <= ni; j++)
                res -= C(j + k - 1, j - 1) * C(n - j + s - k - 1, n - j) % mod;
            res %= mod;
            i = ni;
        }
    } f1, f2, f3, f4;

    void main()
    {
        n = read();
        for (int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + read();
        for (int i = 1; i < n; i++)
            w[i] = read();
        ll ans = 0;
        S = sum[n];
        f1.init(n + 1, S - 1, 1, S - 1), f2.init(n, S, 1, S);
        f3.init(n, S, 1, 0), f4.init(n + 1, S - 1, 1, -1);
        for (int i = 1; i < n; i++)
        {
            ll res = 0;
            f3.movek(sum[i]), f4.movek(sum[i] - 1);
            f1.movei(i + 1), f2.movei(i), f3.movei(i), f4.movei(i + 1);

            res += i * f1.res % mod;
            res -= sum[i] * f2.res % mod;
            res += 2 * sum[i] * f3.res % mod;
            res -= 2 * i * f4.res % mod;
            res %= mod;
            ans += w[i] * res % mod, ans %= mod;
        }
        cout << (ans + mod) % mod << endl;
    }
}

int main()
{
    int T;
    cin >> T;
    solve::init();
    while (T--)
        solve::main();
}
```


---

## 作者：huangzirui (赞：4)

魔怔互测题。~~好像也不是很魔怔~~

题意：

给定 $\{a_n\}$，令 $S=\sum a_i$。

你可以花费 $w_i$ 的代价令：

$a_i \leftarrow a_i+1,a_{i+1}\leftarrow a_{i+1}-1$，或者 
$a_i \leftarrow a_i-1,a_{i+1}\leftarrow a_{i+1}+1$

对每个满足 $\sum b=S$ 的非负序列 $b$，计数从 $a$ 到达 $b$ 的最小花费和。

$n \leqslant 5\times 10^5,S\leqslant 2\times 10^6$。

---

考虑每条边的贡献。

令 $S_x=\sum_{i\leqslant x} a_i$，有：

$$
Ans=\sum_{i=1}^{n-1}w_i\sum_{j=0}^S|S_i-j|\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1} 
$$

转而考虑每个 $\sum_{j=0}^S|S_i-j|\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1} $。

拆开绝对值，只需求出：

$$
S_i\sum_{j=0}^{S_i}\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1} 
$$

$$
-\sum_{j=0}^{S_i}j\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1} 
$$

$$
-S_i\sum_{j=S_i+1}^{S}\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1}
$$

$$
\sum_{j=S_i+1}^{S}j\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1}
$$

为了形式上方便，我们转而求出以下内容：

$$
w_1=S_i\sum_{j=0}^{S_i}\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1} 
$$

$$
w_2=\sum_{j=0}^{S_i}j\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1} 
$$

$$
w_3=S_i\sum_{j=0}^{S}\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1}
$$

$$
w_4=\sum_{j=0}^{S}j\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1}
$$

先考虑相对简单的后两项 $w_3,w_4$。

$w_3$ 是另类的范德蒙德卷积。

通过考察格路行走时，第一次走到横坐标 $a+1$ 时的纵坐标，我们有：

$$
\sum_{i=0}^s \binom{i+a}{a}\binom{s-i+b}{b}=\binom{s+(a+b+1)}{a+b+1}
$$

于是立得：

$$
w_3=S_i\binom{S+n-1}{n-1}
$$

现在尝试计算 $w_4$。吸收 $j$，剩下的部分即与 $w_3$ 类似。

$$
w_4=\sum_{j=0}^{S}j\binom{j+i-1}{i-1}\binom{S-j+(n-i-1)}{n-i-1}
$$

$$
=i\sum_{j=0}^{S}\binom{j+i-1}{i}\binom{S-j+(n-i-1)}{n-i-1}
$$

$$
=i\sum_{j=0}^{S-1}\binom{j+i}{i}\binom{S-j-1+(n-i-1)}{n-i-1}
$$

$$
=i\binom{S+n-1}{n}
$$

---
考虑上二式 $w_1,w_2$。差别仅在于：格路行走时，对首次走到 $x=i$ 时的纵坐标做限制，即此时纵坐标不大于 $S_i$。

接下来一步奇妙而自然，我们通过此组合意义重写这个式子。

易知上面的组合意义等价于走到纵坐标为 $S_i+1$ 时，横坐标不小于 $i+1$。

我们写出一般的形式：

$$
\sum_{j=0}^{A}\binom{j+B}{B}\binom{C-j+D}{D}=
\sum_{j=B+1}^n \binom{j+A}{A}\binom{D+B-j+C-A}{C-A-1}
$$

这样，我们就能在 $A/B$ 变化时，快速计算 $\Delta Ans$。

注意到，我们其实需要对不同的 $i$ 计算答案。每当 $i$ 变化时，$A$ 和 $B$ 都会不断变大，且满足 $B+D$ 不变。于是维护两个指针即可解决这个问题。

于是总复杂度 $O(n+S)$，可以通过此题。



---

## 作者：ListenSnow (赞：2)

[原题链接](https://www.luogu.com.cn/problem/P8367 "原题链接")

## 题意

数轴上有 $n$ 个位置，第 $i$ 个位置有 $a_i$ 个球，将一个球从 $i$ 移动到 $i+1$ 或从 $i+1$ 移动到 $i$ 需要花费 $w_i$ 的代价。

对于所有的结果数量序列 $b$，满足 $\sum_{i=1}^{n}a_i=\sum_{i=1}^{n}b_i=S$。计算 $a$ 变成 $b$ 的最小代价之和。

$1 \leq n \leq 5 \times 10^5,1 \leq S \leq 2 \times 10^6$。

## 思路：

先考虑给定 $b$ 序列的情况如何计算答案。

令 $Sa$ 和 $Sb$ 分别表示 $a,b$ 序列的前缀和。单独计算每条边对于答案的贡献，对于 $i \sim i+1$ 这条边，在最优方案下通过它的次数为 $|Sa_i - Sb_i|$，那么最终的答案就是：

$$\sum_{i=1}^{n-1} w_i \times |Sa_i - Sb_i|$$

而题意是要求所有结果序列 $b$ 的最小代价之和，那么此时就可以枚举 $Sb_i=j$，由于 $\sum_{i=1}^{n}b_i=S$。就有 $\sum_{k=1}^{i} b_k=j,\sum_{k=i+1}^{n} b_k=S-j$。题目中要求 $b_i \geq 0$，那么就等价于求不定方程的非负整数解的个数，利用插板法可以得到答案的表达式：

$$\sum_{i=1}^{n-1} w_i \sum_{j=0}^{S} |Sa_i-j| \binom{j+i-1}{i-1} \binom{S-j+n-i-1}{n-i-1}$$

考虑去掉绝对值，对于 $j \leq Sa_i$ 的部分，内层循环可以拆成：

$$Sa_i\sum_{j=0}^{Sa_i}\binom{j+i-1}{i-1} \binom{S-j+n-i-1}{n-i-1}-\sum_{j=0}^{Sa_i} j \binom{j+i-1}{i-1} \binom{S-j+n-i-1}{n-i-1}$$

令：

$$f(n,S,i,k)=\sum_{j=0}^{k} \binom{j+i-1}{i-1} \binom{S-j+n-i-1}{n-i-1}$$

$$g(n,S,i,k)=\sum_{j=0}^{k} j\binom{j+i-1}{i-1} \binom{S-j+n-i-1}{n-i-1}$$

那么这一部分的答案转化为：

$$\sum_{i=1}^{n-1} w_i \times (Sa_i \times f(n,S,i,Sa_i)-g(n,S,i,Sa_i))$$

对于 $j \geq Sa_i$ 的部分同理，得到最终答案的表达式：

$$\sum_{i=1}^{n-1}  w_i \times ((g(n,S,i,S)-g(n,S,i,Sa_i))-Sa_i \times(f(n,S,i,S)-f(n,S,i,Sa_i)))+(Sa_i \times f(n,S,i,Sa_i)-g(n,S,i,Sa_i))$$

$$=\sum_{i=1}^{n-1}  w_i \times (g(n,S,i,S)-Sa_i \times f(n,S,i,S)+2Sa_i\times f(n,S,i,Sa_i)-2 \times g(n,S,i,Sa_i))$$

考虑 $f(n,S,i,k)$ 的组合意义：一共有 $n$ 个盒子，在前 $i$ 个盒子中放入了 $\leq k$ 个球，且总的球数为 $S$，的方案数。 

那么也就等价于第 $k+1$ 个球不在前 $i$ 个盒子中，考虑枚举第 $k+1$ 个球所在的盒子，得到：

$$f(n,S,i,k)=\sum_{j=i+1}^{n} \binom{j+k-1}{j-1} \binom{n-j+S-(k+1)}{n-j}$$

利用类似于吸收恒等式的方法，可以进行如下转换：

$$j\binom{i+j-1}{j-1}=i\binom{i+j-1}{i}$$

证明只需要将组合数展开，带入$g(n,S,i,k)$，可以得到：

$$g(n,S,i,k)=i\sum_{j=0}^{k}\binom{i+j-1}{i} \binom{S-j+n-i-1}{n-i-1}$$

注意到当 $k=0$ 时没有意义，将 $j$ 用 $j-1$ 替换掉，可以得到：

$$g(n,S,i,k)=i\sum_{j=0}^{k-1}\binom{i+j}{i} \binom{S-j+n-i-2}{n-i-1}$$

$$=i \times f(n+1,S-1,i+1,k-1)$$

那么只需要分别维护四个 $f(n,S,i,k)$，移动 $k$ 的时候用到 $f(n,S,i,k)$ 的第一个表达式，移动 $i$ 个时候用到 $f(n,S,i,k)$ 的第二个表达式。

由于 $i$ 和 $k$ 单调不降，所以总的移动次数为 $O(n+S)$。

## code：

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=3e6+10,mod=998244353;
int n,m,fac[N],infac[N],inv[N],a[N],w[N],s[N];
int read()
{
	int res=0,f=1;char c=getchar();
	while(c<'0'||c>'9') ((c=='-')&&(f=-f,0)),c=getchar();
	while(c>='0'&&c<='9') res=(res<<1)+(res<<3)+c-'0',c=getchar();
	return res;
}
void init()
{
	fac[0]=fac[1]=infac[0]=infac[1]=inv[0]=inv[1]=1;
	for(int i=2;i<N;i++) fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=2;i<N;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(int i=2;i<N;i++) infac[i]=1ll*infac[i-1]*inv[i]%mod;
}
int C(int n,int m){if(n<0||m<0||n<m) return 0;return 1ll*fac[n]*infac[m]%mod*infac[n-m]%mod;}
void Add(int &a,int b){a+=b;if(a>=mod) a-=mod;}
void Sub(int &a,int b){a-=b;if(a<0) a+=mod;}
struct binom
{
	int n,S,i,k,res;
	void print(){printf("%d %d %d %d %d\n",n,S,i,k,res);}
	void init(int n_,int S_,int i_,int k_)
	{
		n=n_,S=S_,i=i_,k=k_;res=0;
		for(int j=0;j<=k;j++) Add(res,1ll*C(j+i-1,i-1)*C(S-j+n-i-1,n-i-1)%mod);
	}
	void movei(int new_i)
	{
		for(int j=i+1;j<=new_i;j++) Sub(res,1ll*C(j+k-1,j-1)*C(n-j+S-(k+1),n-j)%mod);i=new_i;
	}
	void movek(int new_k)
	{
		for(int j=k+1;j<=new_k;j++) Add(res,1ll*C(j+i-1,i-1)*C(S-j+n-i-1,n-i-1)%mod);k=new_k;
	}
}f1,f2,f3,f4;
//g(n,S,i,S)-Sa_i*f(n,S,i,S)+2Sa_i*f(n,S,i,Sa_i)-2g(n,S,i,Sa_i)
//f1=f(n+1,S-1,i+1,S-1),f2=f(n,S,i,S),f3=f(n,S,i,Sa_i),f4=f(n+1,S-1,i+1,Sa_i-1)
void solve()
{
	n=read();for(int i=1;i<=n;i++) a[i]=read(),s[i]=s[i-1]+a[i];int S=s[n],ans=0;
//	f3.init(2,5,0,2);printf("%d\n",f3.res);f3.movei(1);printf("%d\n",f3.res);
	f1.init(n+1,S-1,1,S-1);f2.init(n,S,1,S);f3.init(n,S,1,0);f4.init(n+1,S-1,1,-1);
//	f3.init(2,5,0,0);f3.movei(1);f3.print();
	for(int i=1;i<n;i++)
	{
		int res=0;
		f1.movei(i+1);f2.movei(i);f3.movei(i);f4.movei(i+1);
		f3.movek(s[i]);f4.movek(s[i]-1);
//		printf("%d %d %d %d\n",f1.res,f2.res,f3.res,f4.res);
//		printf("%d %d %d %d\n",f3.n,f3.S,f3.i,f3.k);
		Add(res,1ll*i*f1.res%mod);Sub(res,1ll*s[i]*f2.res%mod);
		Add(res,2ll*s[i]*f3.res%mod);Sub(res,2ll*i*f4.res%mod);
		Add(ans,1ll*res*read()%mod);
	}
	printf("%d\n",ans);
}
int main()
{
	init();int T;scanf("%d",&T);while(T--) solve();
	return 0;
}
```

---

## 作者：断清秋 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8367)

重新把这题式子整理一下写一篇，事实上好像也不是很难。

首先考虑 $a_i$ 和 $a_{i+1}$ 之间有连边，那么一共有 $n-1$ 条边，单独考虑每条边的贡献。

设 $s_i=\sum\limits_{j=1}^ia_j$，$f_{i,j}$ 表示为 $i$ 个非负整数加和等于 $j$ 的方案数。考虑第 $i$ 条边前面的货物数量为 $s_i$，设前面需要的总货物量为 $j$，则需要经过 $|s_i-j|$ 次。那么所有使得总货物量为 $j$ 的方案数是 $f_{i,j} \times f_{n-i,S-j}$。

所以 $ans=\sum\limits_{i=1}^{n-1} w_i \sum\limits_{j=0}^S |s_i-j|\times f_{i,j} \times f_{n-i,S-j}$。

考虑 $f_{i,j}$ 其实等价于把 $j$ 个相同小球放到 $i$ 个不同的盒子里（可以为空），直接插板法可知 $f_{i,j}=\dbinom{i+j-1}{j}$。

代入得到 $ans=\sum\limits_{i=1}^{n-1} w_i \sum\limits_{j=0}^S |s_i-j|\dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}$。

前面 $O(n)$ 枚举每条边显然不能省略，考虑优化后面的式子。

设 $t_i=\sum\limits_{j=0}^S |s_i-j|\dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}$，考虑如何快速计算 $t_i$。

先把绝对值拆开，

有 $t_i=2\sum\limits_{j=0}^{s_i} (s_i-j)\dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}+\sum\limits_{j=0}^{S} (j-s_i)\dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}$。

先考虑 $\sum\limits_{j=0}^{S} (j-s_i)\dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}$ 这部分，

直接打开变成 $\sum\limits_{j=0}^{S} j\dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}-\sum\limits_{j=0}^{S} s_i\dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}$。

然后考虑把不和谐的地方换掉，直接配凑显然可知 $j\dbinom{i+j-1}{j}=i\dbinom{i+j-1}{j-1}$。

于是原式等于 $i\sum\limits_{j=0}^{S} \dbinom{i+j-1}{j-1}\dbinom{n-i+S-j-1}{S-j}-s_i\sum\limits_{j=0}^{S} \dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}$。

减号左边带着这个 $j-1$ 啥也干不成，注意到 $j=0$ 时原式这部分 $=0$，所以不妨改成枚举 $j-1$ 的值，式子中的 $j$ 变为 $j+1$，于是有

$i\sum\limits_{j=0}^{S-1} \dbinom{i+j}{j}\dbinom{n-i+S-j-2}{S-j-1}-s_i\sum\limits_{j=0}^{S} \dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}$。

这个式子推不下去了考虑转组合意义，从 $(0,0)$ 走到 $(n,m)$ 只能往右上走的方案数答案显然是 $\dbinom{n+m}{m}$。

考虑另一个等价的组合方式，当横坐标从 $i$ 走到 $i+1$ 时，设纵坐标的位置为 $j$，那么显然方案数是 $\sum\limits_{j=0}^m \dbinom{i+j}{j} \dbinom{n+m-i-j-1}{m-j}$。

于是有 $\dbinom{n+m}{m}=\sum\limits_{j=0}^m \dbinom{i+j}{j} \dbinom{n+m-i-j-1}{m-j}$。

把这个式子代回原式，即可得到原式等于 $i \dbinom{n+S-1}{n}-s_i \dbinom{n+S-1}{S}$。

这样这部分就推完了，回到另一半式子，即

$2\sum\limits_{j=0}^{s_i} (s_i-j)\dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}$。

类似地，可以得到上式等于

$2s_i\sum\limits_{j=0}^{s_i} \dbinom{i+j-1}{j}\dbinom{n-i+S-j-1}{S-j}-2i\sum\limits_{j=0}^{s_i-1} \dbinom{i+j}{j}\dbinom{n-i+S-j-2}{S-j-1}$。

这个式子组合数部分跟前面没啥区别，唯一区别在于枚举上界不一样，依然回到组合意义考虑。

依然是从 $(0,0)$ 走到 $(n,m)$ 向右上走的方案数，不同的是当横坐标从 $p$ 走到 $p+1$ 时，纵坐标 $\le q$，这样的方案数是 

$\sum\limits_{j=0}^q \dbinom{p+j}{j} \dbinom{n+m-p-j-1}{m-j}$。

另一个角度来说，纵坐标从 $q$ 走到 $q+1$ 时，横坐标必须 $\ge p+1$，这样的方案数是

$\sum\limits_{j=p+1}^n \dbinom{q+j}{j} \dbinom{n+m-q-j-1}{n-j}$。

这两者显然是等价的，于是有

$\sum\limits_{j=0}^q \dbinom{p+j}{j} \dbinom{n+m-p-j-1}{m-j}=\sum\limits_{j=p+1}^n \dbinom{q+j}{j} \dbinom{n+m-q-j-1}{n-j}$。

不妨设 $g(n,m,p,q)$ 表示上面这个式子，那么有

$g(n,m,p,q)=\sum\limits_{j=0}^q \dbinom{p+j}{j} \dbinom{n+m-p-j-1}{m-j}$①

$g(n,m,p,q)=\sum\limits_{j=p+1}^n \dbinom{q+j}{j} \dbinom{n+m-q-j-1}{n-j}$②

不难看出，①式可以 $O(1)$ 从 $g(n,m,p,q)$ 转移到 $g(n,m,p,q+1)$，而②式可以 $O(1)$ 从 $g(n,m,p,q)$ 转移到 $g(n,m,p+1,q)$。

回到最开始的那个式子：

$t_i=2s_i\times g(n-1,S,i-1,s_i)-2i\times g(n,S-1,i,s_i-1)+i \dbinom{n+S-1}{n}-s_i \dbinom{n+S-1}{S}$

然后前面这两个 $g$ 函数的 $p,q$ 都是单调不降的，于是暴力移动两个指针转移，均摊复杂度 $O(n)$。

---

## 作者：chroneZ (赞：1)

一道很妙的组合数学题。

如果已知 $a, b$，显然最优情况下每条边 $(i, i + 1)$ 两侧的货物都只会单向移动。考虑每条边的贡献，答案即为
$$
\sum_{i = 1} ^ {n - 1} w_i|\sum_{j = 1} ^ i a_j - \sum_{j = 1} ^ i b_j|
$$
 贡献是相互独立的，因此可以对每个 $i$ 独立计算贡献。记 $s_i = \sum\limits_{j = 1} ^ i a_j$，并记 $F(k) = \sum \limits_{b} |s_k - \sum \limits_{i = 1} ^ k b_i|$，答案可以写作 $\sum \limits_{i = 1} ^ {n - 1} w_iF(i)$。

记 $S = \sum\limits_{i = 1} ^ n a_i$，一种较易的思路是，枚举 $p = \sum\limits_{i = 1} ^ k b_i$，则只需要求 $\sum \limits_{i = 1} ^ k b_i = p, \sum\limits_{i = k + 1}^n b_i = S - p$ 的 $b$ 的数量。这是经典问题，容易得到
$$
F(k) = \sum_{p = 0} ^ S \binom{k + p - 1}{k - 1} \binom{n - k + S - p - 1}{n - k - 1} |p - s_k|
$$
只要能解决它的值就完成这个问题了。

首先考虑拆掉绝对值符号，对 $p$ 与 $s_k$ 的大小关系讨论一下即可，此处略。

于是我们发现，需要计算的式子有两类：
$$
\begin{aligned}
f(n, k, S, L) = \sum_{p = 0} ^ L\binom{k + p - 1}{k - 1} \binom{n - k + S - p - 1}{n - k - 1}\\
g(n, k, S, L) = \sum_{p = 0} ^ L p\binom{k + p - 1}{k - 1} \binom{n - k + S - p - 1}{n - k - 1}
\end{aligned}
$$
最终我们要计算
$$
F(k) = 2s_kf(n, k, S, s_k) - s_kf(n, k, S, S) - 2g(n, k, S, s_k) + g(n, k, S, S)
$$
$$
\text{ans} = \sum_{i = 1} ^ {n - 1} w_iF(i)
$$
考虑 $f$ 怎么处理。由于题目中限制 $S$ 只有 $10 ^ 6$ 量级，且 $k, s_k$ 都是单调不降的，所以**只要能支持快速从 $f(n, k, S, L)$ 转移到 $f(n, k + 1, S, L)$ 和 $f(n, k, S, L + 1)$** 即可解决本式。~~有时不用把式子化简到什么程度，更好的方式是通过递推完成计算，还是要多注意。~~ 

$f(n, k, S, L + 1)$ 的转移显然，$f(n, k + 1, S, L)$ 就不好算了。

我们希望类似于 $L$ 的处理，将 $f(n, k, S, L)$ 化成 $\sum \limits_{k} \cdots$ 的形式。考虑组合意义，$f(n, k, S, L)$ 表示求长为 $n$ 的序列 $\{t\}$ 的数量，满足 $\sum \limits_{i = 1} ^ k t_i \leq L$ 且 $\sum t_i = S$。将这个过程等价地看作将 $S$ 个小球装进 $n$ 个箱子，需要满足第 $L + 1$ 个小球不在前 $k$ 个箱子里。枚举第 $L + 1$ 个小球的位置 $i$，将剩下的 $L$ 个小球放进 $[1, i]$ 的箱子内，剩下的 $S - L - 1$ 个小球放进 $[i, n]$ 的箱子内，可得
$$
f(n, k, S, L) = \sum_{i = k + 1} ^ n \binom{L + i - 1}{i - 1} \binom{S - L - 1 + n - i}{n - i}
$$
 这样就可以 $\mathcal{O}(n + S)$ 处理 $f$ 的值了。

关于 $g$，尝试将它的形式化简为与 $f$ 相关。较为自然地可以推出
$$
\begin{aligned}
g(n, k, S, L) &= \sum_{p = 0} ^ L p\binom{k + p - 1}{k - 1} \binom{n - k + S - p - 1}{n - k - 1} \\
&= \sum_{p = 0} ^ L k\binom{k + p - 1}{p - 1} \binom{n - k + S - p - 1}{n - k - 1} \\
&= k\sum_{p = 0} ^ {L - 1} \binom{k + p}{p}\binom{n - k + S - p - 2}{n - k - 1} \\
&= k\times f(n + 1, k + 1, S - 1, L - 1)

\end{aligned}
$$
这样 $g$ 同样可以 $\mathcal{O}(n + S)$ 处理了。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

static constexpr int mod = 998244353, N = 2.5e6 + 10;
inline int add(int x, int y) {return (x + y >= mod ? x + y - mod : x + y);}
inline int dec(int x, int y) {return (x - y < 0 ? x - y + mod : x - y);}

inline int qpow(int a, int b) {
	int r = 1;
	while(b) {
		if(b & 1) r = 1ll * r * a % mod;
		a = 1ll * a * a % mod; b >>= 1;
	}
	return r;
}
inline int inv(int x) {return qpow(x, mod - 2);}

int fac[N], ifac[N];
inline void fac_init(int n = N - 1) {
	fac[0] = 1;
	for(int i = 1; i <= n; i++)
		fac[i] = 1ll * fac[i - 1] * i % mod;
	ifac[n] = inv(fac[n]);
	for(int i = n - 1; i >= 0; i--)
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
}

inline int binom(int n, int m) {
	if(n < 0 || m < 0 || n < m) return 0;
	return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

struct F {
	int n, k, S, L, val;
	F() {n = k = S = L = -1; val = 0;}
	inline void moveL() {
		L++; int t = 1ll * binom(k + L - 1, k - 1) * binom(n - k + S - L - 1, n - k - 1) % mod;
		val = add(val, t);
	}
	inline void movek() {
		k++; int t = 1ll * binom(L + k - 1, k - 1) * binom(S - L - 1 + n - k, n - k) % mod;
		val = dec(val, t);
	}
	inline void maintain(int p, int q) {
		while(k < p) movek();
		while(L < q) moveL();
	}
};
constexpr int M = 5e5 + 10;
int a[M], s[M], w[M];

void solve() {
	int n; cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		s[i] = s[i - 1] + a[i];
	}
	for(int i = 1; i < n; i++) {
		cin >> w[i];
	}
	F f1, f2, f3, f4;
	f1.n = f2.n = n, f3.n = f4.n = n + 1;
	f1.S = f2.S = s[n], f3.S = f4.S = s[n] - 1;
	int ans = 0;
	for(int k = 1; k < n; k++) {
		f1.maintain(k, s[k]); f2.maintain(k, s[n]);
		f3.maintain(k + 1, s[k] - 1); f4.maintain(k + 1, s[n] - 1);
        
		int x = 2ll * s[k] * f1.val % mod, y = 1ll * s[k] * f2.val % mod;
		int z = 2ll * k * f3.val % mod, r = 1ll * k * f4.val % mod;
		ans = add(ans, 1ll * add(dec(x, y), dec(r, z)) * w[k] % mod);
	}
	cout << ans << "\n";
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr);
	
	fac_init();
	int T; cin >> T;
	while(T--) {
		solve();
	}
}
```



---

## 作者：tzc_wk (赞：1)

设 $a$ 数组的前缀和为 $s_i$，$b$ 数组的前缀和为 $t_i$，那么根据模拟费用流或者贪心的思想，每一条边经过的次数即为 $|s_i-t_i|$，因此非常 trivial 的做法是转换贡献体，枚举每种方案下每条边被经过的次数，然后乘以 $w_i$ 求和，具体来说：
$$
ans=\sum\limits_{i=1}^{n-1}\sum\limits_{j=0}^{s_n}w_i·\dbinom{i-1+j}{i-1}·\dbinom{n-i-1+s_n-j}{n-i-1}·|s_i-j|
$$
推一推：
$$
ans=\sum\limits_{i=1}^{n-1}w_i·(\sum\limits_{j=0}^{s_n}\dbinom{i-1+j}{i-1}·\dbinom{n-i-1+s_n-j}{n-i-1}·(j-s_i)+2\sum\limits_{j=0}^{s_i}\dbinom{i-1+j}{i-1}·\dbinom{n-i-1+s_n-j}{n-i-1}·(s_i-j))
$$
发现等价于求以下两个东西：
$$
f(i,lim)=\sum\limits_{j=0}^{lim}\dbinom{i-1+j}{i-1}·\dbinom{n-i-1+s_n-j}{n-i-1}
$$

$$
g(i,lim)=\sum\limits_{j=0}^{lim}\dbinom{i-1+j}{i-1}·\dbinom{n-i-1+s_n-j}{n-i-1}·j
$$

先考虑对 $g$ 进行一些转化使其变成与 $f$ 形式类似的东西：
$$
\begin{aligned}
g(i,lim)&=\sum\limits_{j=0}^{lim}\dbinom{i-1+j}{i-1}·\dbinom{n-i-1+s_n-j}{n-i-1}·j\\
&=\sum\limits_{j=0}^{lim}\dbinom{i-1+j}{i-1}·\dbinom{n-i-1+s_n-j}{n-i-1}·((i+j)-i)\\
&=\sum\limits_{j=0}^{lim}\dbinom{i+j}{i}·\dbinom{n-i-1+s_n-j}{n-i-1}·i-\sum\limits_{j=0}^{lim}\dbinom{i-1+j}{i-1}·\dbinom{n-i-1+s_n-j}{n-i-1}·i
\end{aligned}
$$
其中第二步到第三步是吸收恒等式逆用。

$i$ 是常数，去掉之后发现左右两边左右两边形式都和 $f$ 类似，因此先考虑怎么求 $f$。发现 $f$ 的组合意义是，有 $(n-1)\times s_n$ 的网格，从左下走到右上，每一步只能向上或向右，问有多少种走法，使得从第 $i-1$ 列到第 $i$ 列时经过的那条边的纵坐标 $\le lim$。

然后我就死在这里了，像个傻逼一样。

发现虽然 $f$ 本身没有什么非常简洁的化简式，但是从 $f(i,lim)\to f(i,lim+1)$ 的变化是容易的，直接加上经过 $(i-1,lim+1)\to (i,lim+1)$ 这条边的方案数即可。$f(i,lim)\to f(i+1,lim)$ 也不难，发现后者合法的路径集合一定被前者包含，而二者相差的部分恰好都经过了 $(i,lim)\to (i,lim+1)$ 这条边，同样可以 $O(1)$ 移动指针。而指针移动总次数是 $O(n+S)$ 的，所以总复杂度也是这个。

```cpp
const int MAXN=3e6;
const int MOD=998244353;
int fac[MAXN+5],ifac[MAXN+5];
void init_fac(int n){
	for(int i=(fac[0]=ifac[0]=ifac[1]=1)+1;i<=n;i++)ifac[i]=1ll*ifac[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%MOD,ifac[i]=1ll*ifac[i-1]*ifac[i]%MOD;
}
int binom(int n,int k){return 1ll*fac[n]*ifac[k]%MOD*ifac[n-k]%MOD;}
int n,s[MAXN+5],w[MAXN+5];
struct solver{
	int n,m,p,q,sum;
	void init(int N,int M){n=N;m=M;p=0;q=0;sum=binom(N+M-1,N-1);}
	void moveP(){++p;if(q!=m)sum=(sum-1ll*binom(p+q,p)*binom(n-p+m-q-1,n-p)%MOD+MOD)%MOD;}
	void moveQ(){++q;sum=(sum+1ll*binom(p+q,p)*binom(n-p-1+m-q,n-p-1))%MOD;}
	int at(int P,int Q){while(p<P)moveP();while(q<Q)moveQ();return sum;}
}A,B;
void solve(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&s[i]),s[i]+=s[i-1];
	for(int i=1;i<n;i++)scanf("%d",&w[i]);
	int res=0,T1=binom(s[n]+n-1,n-1),T2=binom(s[n]+n,n);
	A.init(n-1,s[n]);B.init(n,s[n]);
	for(int i=1;i<n;i++){
		int s1=A.at(i-1,s[i]),s2=B.at(i,s[i]);
		res=(res+1ll*(1ll*(T2-T1+MOD)*i%MOD-1ll*s[i]*T1%MOD+2ll*s[i]*s1%MOD-2ll*(s2-s1+MOD)*i%MOD+MOD+MOD)*w[i])%MOD;
	}
	printf("%d\n",res);
}
int main(){init_fac(MAXN);int qu;scanf("%d",&qu);while(qu--)solve();return 0;}
```



---

## 作者：donghanwen1225 (赞：1)

做这题的时候一开始一直在往 dp 的方向想，结果是硬写出 $O(nS)$ dp 后经过观察才发现其中的组合式子；实际上把组合式子写出来之后发现可以直接一步到位，我却用了 1.5h 去硬写 dp……

------------

首先分析，对于一个给定的序列 $b$，如何计算所需的最小代价。

考虑 $i$ 和 $i+1$ 之间，假如既存在从 $i$ 移动到 $i+1$ 的，又存在从 $i+1$ 移动到 $i$ 的，那么显然把这两次操作抵消更优。因此，相邻两点之间的移动一定是单向的。

那么我们可以据此把序列分成多段，每一段里的移动都是朝着同一个方向，类似下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jxhh992k.png)

考虑贪心的移动，从 $1$ 开始，若 $a_1\geq b_1$，就把 $1$ 多出来的移向 $2$，否则就从 $2$ 移向 $1$，以此类推。可以发现，在 $i$ 到 $i+1$ 之间，一共移动了 $\left|\sum\limits_{j=1}^{i}(a_j-b_j)\right|$ 次（由于顺序没有影响，这样求前缀和即使出现负数也依然合法）。

令 $q_i=\sum\limits_{j=1}^{i}a_j$，$s_i=\sum\limits_{j=1}^{i}b_j$，则序列 $b$ 的总贡献为 $\sum\limits_{i=1}^{n-1}|q_i-s_i|w_i$。

接下来，我们考虑 $s_i=j$ 的方案数。令 $S=q_n$，当 $s_i=j$ 时，有前 $i$ 个数的和是 $j$，后 $n-i$ 个数的和是 $S-j$。两部分都可以用插板法解决，得到 $s_i=j$ 的方案数应为 $\dbinom{j+i-1}{i-1}\dbinom{S-j+(n-i-1)}{n-i-1}$。

对所有方案求和，所求答案即为

$$\sum\limits_{i=1}^{n-1}w_i\left(\sum\limits_{j=0}^{S}\dbinom{j+i-1}{i-1}\dbinom{S-j+(n-i-1)}{n-i-1}|q_i-j|\right)$$

直接暴力求解此式，复杂度 $O(nS)$，可以得到 $40\text{pts}$。

考虑进一步优化。式子中两个组合数的乘积，表示前 $i$ 个数的和是 $j$，后 $n-i$ 个数的和是 $S-j$ 的方案数；而当 $j$ 取遍 $0$ 到 $S$ 时，就可以表示 $n$ 个数的和是 $S$ 的方案数。也即有：

$$\sum\limits_{j=0}^{S}\dbinom{j+i-1}{i-1}\dbinom{S-j+(n-i-1)}{n-i-1}=\dbinom{S+n-1}{n-1}$$

将绝对值拆开，分 $j\leq q_i$ 和 $j>q_i$ 两部分。由于上述结论，我们只需要考虑 $j\leq q_i$ 时的结果，另一部分用 $\dbinom{S+n-1}{n-1}$ 去减即可得到。

将 $q_i-j$ 拆开，注意到有

$$\begin{aligned}&\sum\limits_{j=0}^{q_i}j\dbinom{j+i-1}{i-1}\dbinom{S-j+(n-i-1)}{n-i-1}\\=&\sum\limits_{j=1}^{q_i}i\dbinom{j+i-1}{i}\dbinom{S-j+(n-i-1)}{n-i-1}\\=&\sum\limits_{j=0}^{q_i-1}i\dbinom{j+i}{i}\dbinom{S-j+(n-i)}{n-i}\end{aligned}$$

这与不带 $j$ 的一部分式子是类似的。具体的说，令 $f(n,S,i,m)=\sum\limits_{j=0}^{m}\dbinom{j+i-1}{i-1}\dbinom{S-j+(n-i-1)}{n-i-1}$，则有 $f(n,S,i,S)=\dbinom{S+n-1}{n-1}$，且上式 $=i\times f(n+1,S-1,i+1,q_i-1)$。因此以下只需考虑如何计算 $f(n,S,i,q_i)$。

直接计算是很困难的，但我们发现，随着 $i$ 的增大，$q_i$ 也随之增大，且两者的移动次数总共是 $O(n+S)$。这启发我们考虑如何 $O(1)$ 维护 $i$ 增加和 $m$ 增加的贡献。

$m$ 增加的贡献只需根据此式解决，考虑 $i$ 增加的贡献。回到组合意义上，如果我们只枚举到 $m$，而不是枚举到 $S$，那么 $f(n,S,i,m)$ 表示的是令前 $i$ 个数的和 $\leq m$ 时 $n$ 个数的和为 $S$ 的方案数。

换一种枚举方式，转而枚举 $m+1$ 贡献到了谁的上面。具体的，如果 $m+1$ 贡献到了 $j$，那么前 $j-1$ 个数的和应为 $m$，后 $n-j+1$ 个数剩余的和应为 $S-m-1$。这两部分也都可以插板法解决。由此，可以得到：

$$f(n,S,i,m)=\sum\limits_{j=i+1}^{n}\dbinom{m+j-1}{j-1}\dbinom{S-m-1+n-j}{n-j}$$

$i$ 增加的贡献根据此式也得到了解决。

于是，只要类似的维护 $f(n+1,S-1,i+1,q_i-1)$ 的部分，就可以解决此题。最终时间复杂度为 $O(n+S)$。

code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int mod=998244353;
int t,n,sum,res,a[500005],qz[500005],w[500005],fac[2500005],inv[2500005];
int ksm(int d,int cf)
{
	int ans=1;
	while(cf)
	{
		if(cf&1) ans=1ll*ans*d%mod;
		d=1ll*d*d%mod;cf>>=1;
	}
	return ans;
}
void init(int n)
{
	fac[0]=inv[0]=1;for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;
	inv[n]=ksm(fac[n],mod-2);for(int i=n-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
}
int C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}
int main()
{
	init(2500000);
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);sum=res=0;
		for(int i=1;i<=n;i++) scanf("%d",&a[i]),qz[i]=qz[i-1]+a[i],sum+=a[i];
		for(int i=1;i<n;i++) scanf("%d",&w[i]);
		int s1=C(sum+n-1,n-1),s2=C(sum+n-1,n),c1=C(sum+n-2,n-2),c2=0;
        //此处的 c1,c2 表示 i=1,m=0 时的结果
		for(int i=1;i<n;i++)
		{
			if(i>1)
			{
            	//当 i>1 时，需要根据第二个式子，维护 i 增大的贡献
 				c1=(c1-1ll*C(qz[i-1]+i-1,i-1)*C(sum-qz[i-1]+n-i-1,n-i)%mod+mod)%mod;
				c2=(c2-1ll*C(qz[i-1]+i-1,i)*C(sum-qz[i-1]+n-i-1,n-i)%mod+mod)%mod;
			}
			for(int j=qz[i-1]+1;j<=qz[i];j++)
			{
            	//根据第一个式子，维护 m 增大的贡献
				c1=(c1+1ll*C(j+i-1,i-1)*C(sum-j+n-i-1,n-i-1)%mod)%mod;
				c2=(c2+1ll*C(j+i-1,i)*C(sum-j+n-i-1,n-i-1)%mod)%mod;
			}
			int tmp=(1ll*qz[i]*c1-1ll*i*c2)%mod+(1ll*i*(s2-c2+mod)-1ll*qz[i]*(s1-c1+mod))%mod;//计算这 4 部分的贡献
			res=(res+1ll*(tmp%mod+mod)*w[i]%mod)%mod;
		}
		printf("%d\n",res);
	}
	return 0;
}
```


---


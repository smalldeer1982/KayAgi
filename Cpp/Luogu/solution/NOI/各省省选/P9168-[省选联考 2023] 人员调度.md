# [省选联考 2023] 人员调度

## 题目背景

**滥用本题评测将封号**。

## 题目描述

众所周知，一个公司的 $n$ 个部门可以组织成一个树形结构。形式化地，假设这些部门依次编号为 $1, \ldots, n$，那么除了 $1$ 号部门以外，第 $i \in [2, n]$ 个部门**有且仅有**一个上级部门 $p_i \in [1, i - 1]$。这样，这家公司的 $n$ 个部门可以视为一个以 $1$ 为根的树。如果 $i$ 是 $j$ 子树中的点，那么称部门 $i$ 是部门 $j$ 的子部门。

该公司初始时有 $k$ 名优秀员工，编号依次为 $1 \ldots k$。第 $i$ 名优秀员工初始时在第 $x_i$ 个部门工作，并且其有一个能力值 $v_i > 0$。

为了最大化公司的运作效率，公司老板 0/\\/\G 决定进行一些人员调动。具体来说，可以将编号为 $i$ 的优秀员工调动到 $x_i$ 的一个子部门，或者不调度（此时该员工在 $x_i$ 部门）。随后，优秀员工们会在其所在的部门竞选部门领导——能力值最高者将担任这一职位，并给公司带来等同于其能力值的贡献。如果一个部门一个优秀员工也没有，那么就无法选出部门领导，从而对公司的贡献将是 $0$。此时，公司的业绩被定义为公司各部门的贡献之和。

公司老板 0/\\/\G 自然想知道，该如何进行人员调动，使公司的业绩最大？

这当然难不倒他，然而，公司优秀员工的数量也会发生变化；具体来说，会依次发生 $m$ 个事件，每个事件形如：

- `1 x v`：先令 $k = k + 1$，然后新增一位编号为 $k$、初始部门为 $x$、能力值为 $v$ 的优秀员工；
- `2 id`：编号为 $\mathit{id}$ 的优秀员工将被辞退。

公司老板 0/\\/\G 希望你能在最开始和每个事件发生后，告诉他公司的业绩最大可能是多少？

注意，每次人员调动都是独立的，也就是每次计算公司的最大可能业绩时，每个优秀员工都会回到其所在的初始部门。


## 说明/提示

**【数据范围】**

对于所有的数据，保证：$1 \le \mathit{sid} \le 15$，$1 \le n, k \le 10^5$，$0 \le m \le 10^5$，$1 \le p_i < i$，$1 \le x_i, x \le n$，$1 \le v_i, v \le 10^5$。

对于事件 2，保证：$1 \le \mathit{id} \le k$ 且编号为 $\mathit{id}$ 的员工在此事件发生时仍在工作。

|测试点编号|$\mathit{sid}$|$n \le$|$k \le$|$m \le$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|$1$|$6$|$6$|$6$|无|
|2, 3|$2$|$9$|$6$|$6$|无|
|4, 5|$3$|$16$|$66$|$66$|无|
|6 ~ 8|$4$|$66$|$66$|$0$|无|
|9 ~ 11|$5$|$2,333$|$2,333$|$0$|无|
|12 ~ 14|$6$|$10^5$|$10^5$|$0$|B|
|15 ~ 18|$7$|$10^5$|$10^5$|$0$|无|
|19 ~ 21|$8$|$2,333$|$2,333$|$2,333$|A|
|22 ~ 24|$9$|$10^5$|$10^5$|$10^5$|AB|
|25 ~ 28|$10$|$10^5$|$10^5$|$10^5$|A|
|29 ~ 31|$11$|$2,333$|$2,333$|$2,333$|无|
|32 ~ 34|$12$|$10^5$|$10^5$|$10^5$|C|
|35 ~ 38|$13$|$10^5$|$10^5$|$10^5$|B|
|39 ~ 44|$14$|$66,666$|$66,666$|$66,666$|无|
|45 ~ 50|$15$|$10^5$|$10^5$|$10^5$|无|

特殊性质 A：无事件 2；

特殊性质 B：$p_i = i - 1$；

特殊性质 C：$v_i = v = 1$。


## 样例 #1

### 输入

```
1
3 2 1
1 1
2 1
1 3
1 2 2
```

### 输出

```
4 5
```

## 样例 #2

### 输入

```
见附件中的 transfer/transfer2.in```

### 输出

```
见附件中的 transfer/transfer2.ans```

## 样例 #3

### 输入

```
见附件中的 transfer/transfer3.in```

### 输出

```
见附件中的 transfer/transfer3.ans```

## 样例 #4

### 输入

```
见附件中的 transfer/transfer4.in```

### 输出

```
见附件中的 transfer/transfer4.ans```

## 样例 #5

### 输入

```
见附件中的 transfer/transfer5.in```

### 输出

```
见附件中的 transfer/transfer5.ans```

## 样例 #6

### 输入

```
见附件中的 transfer/transfer6.in```

### 输出

```
见附件中的 transfer/transfer6.ans```

## 样例 #7

### 输入

```
见附件中的 transfer/transfer7.in```

### 输出

```
见附件中的 transfer/transfer7.ans```

## 样例 #8

### 输入

```
见附件中的 transfer/transfer8.in```

### 输出

```
见附件中的 transfer/transfer8.ans```

## 样例 #9

### 输入

```
见附件中的 transfer/transfer9.in```

### 输出

```
见附件中的 transfer/transfer9.ans```

## 样例 #10

### 输入

```
见附件中的 transfer/transfer10.in```

### 输出

```
见附件中的 transfer/transfer10.ans```

## 样例 #11

### 输入

```
见附件中的 transfer/transfer11.in```

### 输出

```
见附件中的 transfer/transfer11.ans```

## 样例 #12

### 输入

```
见附件中的 transfer/transfer12.in```

### 输出

```
见附件中的 transfer/transfer12.ans```

## 样例 #13

### 输入

```
见附件中的 transfer/transfer13.in```

### 输出

```
见附件中的 transfer/transfer13.ans```

## 样例 #14

### 输入

```
见附件中的 transfer/transfer14.in```

### 输出

```
见附件中的 transfer/transfer14.ans```

## 样例 #15

### 输入

```
见附件中的 transfer/transfer15.in```

### 输出

```
见附件中的 transfer/transfer15.ans```

# 题解

## 作者：vectorwyx (赞：51)

由题意可知，最终调度方案里，对于同一部门的员工，只需要保留能力值最大的，其余员工不会产生贡献，我们视为他们被淘汰了。那么有一个简单的贪心：像树形 dp 那样自底向上维护每棵子树的最优调度策略。对于叶节点，最优策略就是保留这个结点上能力值最大的那位员工。对于一个非叶结点 $x$，我们先求出它的所有儿子对应子树的最优策略，然后挨个考察初始位置在 $x$ 上的所有员工 $i$，如果 $x$ 的整棵子树里还有结点空闲着，那就把员工 $i$ 调度到这个空闲的结点上。否则，找出目前 $x$ 子树中能力值最小的那位员工，比较他与员工 $i$ 的能力值，如果员工 $i$ 的能力值更大就淘汰掉这位员工，腾出位置，把员工 $i$ 调度过去。这个贪心的正确性显然。

注意到由于是自底向上进行的，我们其实并不关心每个员工究竟调度到了哪个结点，只需要关心当前子树中有哪些员工幸存了下来。更进一步地，我们其实是对每个结点 $x$ 维护了一个有序序列，把 $x$ 所有儿子的序列合并起来再加上初始时位置在 $x$ 的所有员工得到序列 $a$，令 $c$ 为 $a$ 序列的长度，把 $a$ 按能力值降序排列后淘汰掉末尾的 $\max(0,c-s_x)$ 个员工就得到了 $x$ 对应的序列（$s_x$ 为 $x$ 的子树大小），淘汰 $\max(0,c-s_x)$ 个员工是因为我们必须保证幸存的员工数量不超过子树大小。这个过程显然可以用可并堆来实现，令员工数为 $k$，单次复杂度为 $O(n+k\log k)$，总复杂度为 $O(mn+mk\log k)$，可以获得 48 分，[这里](https://www.luogu.com.cn/paste/opv0hfhw)给出了代码实现（采用的是 pb_ds 库的配对堆）。

接下来的方向是想办法快速维护这个合并的过程。先来看看只加点怎么做，此时，对于一位在之前的合并过程中被淘汰的员工，他之后肯定也没有机会复活，所以只需要维护那些当前还没被淘汰的员工。换言之，边加点，边维护每个结点 $x$ 的序列。我们称结点 $x$ 是满的，当且仅当 $x$ 的序列大小恰好等于 $s_x$。假设现在要在结点 $x$ 新加入一位员工 $i$，考虑他对于 $x$ 的祖先的序列的影响。

第一种情况是，$x$ 到根结点的链上没有结点是满的，此时加入员工 $i$ 后 $x$ 的祖先结点在合并序列时一定不会发生超载的情况，所以不会有员工被淘汰。那么员工 $i$ 对祖先的影响仅仅是在对应序列中多加了一位员工。

第二种情况是，$x$ 到根结点的链上存在一些结点是满的，那员工 $i$ 的加入势必会引起淘汰的发生。假装模拟这个向上合并的过程，显然第一次淘汰会发生在 $x$ 的祖先中距离 $x$ 最近的那个满的结点，记为 $y$。$y$ 的序列的大小恰为 $s_x$，我们找出这个序列中最末尾的员工 $j$（也就是能力值最小的），如果员工 $i$ 的能力值比员工 $j$ 都要小，那他的旅途到这就戛然而止了，$j$ 会把 $i$ 淘汰掉。而如果员工 $i$ 的能力值大于等于员工 $j$，那么把员工 $j$ 替换成员工 $i$ 肯定更优，而且根据单调性，员工 $j$ 没有在之后的合并过程中被淘汰，所以用 $i$ 换掉 $j$ 后 $i$ 也一定不会被淘汰，所以我们根本不用再考虑后面的过程了。

那么现在的问题变成了，单点修改，查询 $x$ 祖先中距离 $x$ 最近的满的结点，查询子树最小值。再转化一下，初始时每个结点 $x$ 有一个权值 $v_x=s_x$，然后每在 $x$ 结点加一个新员工就会把 $x$ 到根的链上的结点的权值 $-1$，问祖先中最近的权值等于 $0$ 的点。这其实就是链加链 $\min$，树剖一下，复杂度是 $O((k+m)\log^2 n)$。

现在我们搞出了只加点时的做法，由于询问并不强制在线，套一层线段树分治即可变删除为撤销，视 $n,m,k$ 同阶的话则复杂度为 $O(n\log^3 n)$，如果将链加链 $\min$ 改用静态 LCT 实现即可变为 $O(n\log^2 n)$。不过树剖的常数还是蛮小的，完全可过。

代码如下：

```cpp
#include<bits/stdc++.h>
namespace vectorwyx{
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define gc getchar
#define emp emplace
#define re return
#define co continue
#define brk break
#define HH (ptc('\n'))
#define bctz __builtin_ctz
#define bclz __builtin_clz
#define bppc __builtin_popcount
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){signed ch=getchar();int x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
template<typename T> void out(T *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=1e5+5,inf=1e9;
struct People{
	int x,v;
	People(){x=0,v=inf;}
	bool operator<(const People &y)const{re v<y.v;}
	bool operator>(const People &y)const{re v>y.v;}
}a[N<<1];
vector<int> e[N];
int n,m,k,dfn[N],rk[N],ti,siz[N],son[N],Tid,top[N],lst[N<<1],fa[N];

void dfs1(int x){
	siz[x]=1;
	int mx=0;
	for(int i:e[x]){
		dfs1(i);
		siz[x]+=siz[i];
		if(siz[i]>mx) mx=siz[i],son[x]=i;
	}
}

void dfs2(int x,int t){
	top[x]=t;
	dfn[x]=++ti;rk[ti]=x;
	if(son[x]) dfs2(son[x],t);
	for(int i:e[x]) if(i!=son[x]) dfs2(i,i);
}

#define ls (x<<1)
#define rs (x<<1|1)
#define mid ((l+r)>>1)
namespace DS1{//维护子树最小值
//auto cmp=[](int x,int y){re a[x]<a[y];};
//priority_queue<int,vector<int>,decltype(cmp)> pq[N];
struct qwq{
	int id;
	qwq(){id=0;}
	qwq(int o){id=o;}
	bool operator<(const qwq &x)const{
		if(a[id].v!=a[x.id].v) re a[id]<a[x.id];
		re id<x.id;
	}
};
set<qwq> pq[N];
int tr[N<<2];
void ps(int x){
	if(a[tr[ls]]<a[tr[rs]]) tr[x]=tr[ls];
	else tr[x]=tr[rs];
}
void upd(int x,int l,int r,int aim,int k){
	if(l==r){
		tr[x]=k;
		re;
	}
	if(aim<=mid) upd(ls,l,mid,aim,k);
	else upd(rs,mid+1,r,aim,k);
	ps(x);
}

int ask(int x,int l,int r,int L,int R){
	if(l>=L&&r<=R) re tr[x];
	if(R<=mid) re ask(ls,l,mid,L,R);
	if(L>mid) re ask(rs,mid+1,r,L,R);
	int wl=ask(ls,l,mid,L,R);
	int wr=ask(rs,mid+1,r,L,R);
	if(a[wl]>a[wr]) re wr;
	re wl;
}

void ins(int id){
	int x=a[id].x;
	pq[x].insert(qwq(id));
	upd(1,1,n,dfn[x],(*pq[x].begin()).id);
}
void del(int id){
	int x=a[id].x;
//	assert(id==pq[x].top().id);
	pq[x].erase(qwq(id));
	if(pq[x].empty()) upd(1,1,n,dfn[x],0);
	else upd(1,1,n,dfn[x],(*pq[x].begin()).id);
}
}

namespace DS2{
	
namespace Sgt{
struct Node{
	int tag,mn;
	Node(){tag=0;mn=inf;}
	void upd(int x){tag+=x,mn+=x;}
}tr[N<<2];

void ps(int x){tr[x].mn=min(tr[ls].mn,tr[rs].mn);}
void pd(int x){
	int &k=tr[x].tag;
	if(!k) re;
	tr[ls].upd(k);
	tr[rs].upd(k);
	k=0;
}

void build(int x,int l,int r){
	if(l==r){
		tr[x].mn=siz[rk[l]];
		re;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	ps(x);
}

void upd(int x,int l,int r,int L,int R,int k){
//	if(x==1) printf("upd(%d,%d,%d,%d,%d,%d)\n",x,l,r,L,R,k);
	if(l>=L&&r<=R){
		tr[x].upd(k);
		re;
	}
	pd(x);
	if(L<=mid) upd(ls,l,mid,L,R,k);
	if(R>mid) upd(rs,mid+1,r,L,R,k);
	ps(x);
}

int ask(int x,int l,int r,int L,int R){
//	if(x==1) printf("Sgt::ask(%d,%d,%d,%d,%d)\n",x,l,r,L,R);
	if(l>=L&&r<=R) re tr[x].mn;
	pd(x);
	if(R<=mid) re ask(ls,l,mid,L,R);
	if(L>mid) re ask(rs,mid+1,r,L,R);
	re min(ask(ls,l,mid,L,R),ask(rs,mid+1,r,L,R));
}

int get(int x,int l,int r,int L,int R){
//	printf("get(%d,%d,%d,%d,%d)\n",x,l,r,L,R);
	if(l>=L&&r<=R){
		if(tr[x].mn>0) re 0;
		while(l<r){
			pd(x);
			if(tr[rs].mn==0) x=rs,l=mid+1;
			else x=ls,r=mid;
		}
		re rk[l];
	}
	pd(x);
	if(R<=mid) re get(ls,l,mid,L,R);
	if(L>mid) re get(rs,mid+1,r,L,R);
	int w=get(rs,mid+1,r,L,R);
	if(w) re w;
	re get(ls,l,mid,L,R);
}
}


void build(){
	Sgt::build(1,1,n);
}

void upd(int x,int k){
	while(x){
		int y=top[x];
		Sgt::upd(1,1,n,dfn[y],dfn[x],k);
		x=fa[y];
	}
}
int ask(int x){
	while(x){
		int y=top[x];
		if(Sgt::ask(1,1,n,dfn[y],dfn[x])>0){
			x=fa[y];
			co;
		}
		re Sgt::get(1,1,n,dfn[y],dfn[x]);
	}
	re 0;
}
} 

namespace Company{
struct Roll{
	int id,loser;
}stk[N<<1];
int top;
ll ans;

void hello_world(int id){//正式步入职业生涯 
	//Hello, world!
//	printf("hello_world(%d)!\n",id);
	ans+=a[id].v;
	DS1::ins(id);
	DS2::upd(a[id].x,-1);
}

void say_goodbye(int id){
//	printf("say_goodbye(%d)!\n",id);
	ans-=a[id].v;
	DS1::del(id);
	DS2::upd(a[id].x,1);
}

bool gao(int id){//把员工 id 加进来 
//	printf("gao(%d)\n",id);
	int t=DS2::ask(a[id].x);
	if(!t){
		++top;
		stk[top].id=id,stk[top].loser=0;//岗位充足，没有产生下岗员工 
		hello_world(id);
		re 1;
	}
	//很遗憾，零和博弈，必定有输家
	int me=DS1::ask(1,1,n,dfn[t],dfn[t]+siz[t]-1);//末位淘汰
	if(a[me]<a[id]){//内卷斗兽场 
		++top;
		stk[top].id=id,stk[top].loser=me;
		hello_world(id);
		say_goodbye(me);
		re 1;
	}
	re 0;
}
void roll(){
//	puts("roll_back");
	int x=stk[top].id,y=stk[top].loser;top--;
	say_goodbye(x);
	if(y) hello_world(y);
}
}

ll ans[N];
namespace DS3{//时间线段树
vector<int> tr[N<<2];
void push(int x,int l,int r,int L,int R,int id){
//	printf("push(%d,%d,%d,%d,%d,%d)\n",x,l,r,L,R,id);
	if(l>=L&&r<=R){
		tr[x].pb(id);
		re;
	}
	if(L<=mid) push(ls,l,mid,L,R,id);
	if(R>mid) push(rs,mid+1,r,L,R,id);	
}
void dfs(int x,int l,int r){
//	printf("dfs(%d,%d,%d)\n",x,l,r);
	int ct=0;
	for(int i:tr[x]) ct+=Company::gao(i);
	if(l==r) ans[l]=Company::ans;
	else dfs(ls,l,mid),dfs(rs,mid+1,r);
	while(ct--) Company::roll();
}
}

void file(){
	freopen("transfer.in","r",stdin);
	freopen("transfer.out","w",stdout);
}

signed main(){
//	file();
	cin>>Tid;
	cin>>n>>k>>m;
	fo(i,2,n) fa[i]=read(),e[fa[i]].pb(i);
	dfs1(1);
	dfs2(1,1);
//	cout<<"son:";out(son,1,n);
//	cout<<"dfn:";out(dfn,1,n);
//	cout<<"top:";out(top,1,n);
	DS2::build();
	fo(i,1,k) a[i].x=read(),a[i].v=read();
	fo(i,1,m){
		int o=read(),x=read();
		if(o==1){
			a[++k].x=x;
			lst[k]=i;
			a[k].v=read();
		}else DS3::push(1,0,m,lst[x],i-1,x),lst[x]=-1;
	}
	fo(i,1,k) if(lst[i]>-1) DS3::push(1,0,m,lst[i],m,i);
	DS3::dfs(1,0,m);
	out(ans,0,m);
	return 0;
}
}
/*
-------------------------------------------------
*/










signed main(){re vectorwyx::main();}
```



---

## 作者：expect (赞：25)

考虑费用流模型：

源点连每个员工，流量为 $1$，费用为 $v_i$（记为一类边）。

每个员工连对应的树上节点，流量为正无穷，费用为 $0$。

树上每个节点连向自己的儿子，流量为正无穷，费用为 $0$。

树上每个节点向汇点连边，流量为 $1$，费用为 $0$（记为二类边）。

删除可以一个 $\log$ 线段树分治掉，故只需考虑插入一个员工 $i$ 的影响。

不妨记 $a_i,b_i$ 表示 $x_i$ 子树中满流的一类边与二类边的数量，将一条源点 $\rightarrow$ 一类边 $\rightarrow$ 二类边 $\rightarrow$ 汇点的流量路径记作一个匹配。

$1.$ 若 $b_i < size_{x_i}$，则员工 $i$ 所对应的一类边可以直接与子树中未满流的二类边匹配。

$2.$ 若 $b_i = size_{x_i}$ 且 $a_i = size_{x_i}$，则退流子树内一条一类边权值最小的路径后，将员工 $i$ 对应的一类边与该二类边匹配。

$3.$ 若 $b_i = size_{x_i}$ 且 $a_i < size_{x_i}$，这意味着 $x_i$ 至少有一个祖先的一类边与 $x_i$ 子树中某点的二类边匹配，这也意味着存在一条 $x_i$ 到 $x_i$ 父亲的反向边，不断地沿着此类边向上走直到 $a_i = size_{x_i}$ 后以 $2.$ 中的方式处理即可。

考虑用树剖模拟上述过程。若 $x_i$ 的所有祖先 $size_u - a_u$ 都不为 $0$，则一定存在一种方案使得 $b_i < size_{x_i}$，故直接将员工 $i$ 插入即可。否则令 $u$ 为离 $x_i$ 最近的满足 $size_u - a_u = 0$ 的祖先（包括 $x_i$ ），用员工 $i$ 对应的一类边替换掉 $u$ 子树中权值最小的一类边即可。以上操作均可用 $multiset$ 与线段树维护。

总复杂度 $n \log^3 n$。



---

## 作者：mod998244353 (赞：16)

先在时间轴上线段树分治，把加人删人变成加人撤销。

下文中，用二元组 $(x,v)$ 表示初始部门为 $x$，能力值为 $v$ 的人，且只考虑被节点选中的人和新加的人。

我们先假设每个节点 $u(1\leq u\leq n)$ 一开始选了 $(u,0)$。

设 $\operatorname{size}(x)$ 表示 $x$ 的子树大小， $s(x)$ 表示初始部门在 $x$ 的子树内的人的数量。

有 $s(x)\leq\operatorname{size}(x)$，因为这些人一定在 $x$ 的子树内。

这样每次加 $(x,v)$ 就分为以下两步：

1. 找到 $x$ 的祖先（包括 $x$）中深度最深且满足 $s(u)=\operatorname{size}(u)$ 的节点 $u$。
2. 用 $(x,v)$ 替代 $u$ 子树内任意一个权值最小的节点（如果这样做更优才这么做）

简单证明一下做法的正确性：

如果 $u=x$，显然是正确的。

如果 $u\not=x$，根据 $u$ 是最深的满足 $s(u)=\operatorname{size}(u)$ 的 $x$ 的祖先，一定有至少两个人的初始部门为 $u$。

根据 $s(x)\not=\operatorname{size}(x)$，$x$ 的子树内存在一个点 $w$，在 $w$ 的人 $(y,z)$ 满足 $y$ 为 $x$ 的祖先 $(y\not=x)$。

由于 $s(u)=\operatorname{size}(u)$，$y$ 一定在 $u$ 的子树内。

新人 $(x,v)$ 放在节点 $w$，此时 $x$ 子树内便多了一个节点在位置 $w$。

所以 $(y,z)$ 就需要去 $y$ 子树内再选一个位置占，或者直接删去 $(y,z)$。

如果选择再占一个位置，那么 $y$ 子树内就会多一个人。

不断递归，因为 $u$ 是最深的满足 $s(u)=\operatorname{size}(u)$ 的 $x$ 的祖先，所以一定能递归到 $u$。

因为 $s(u)=\operatorname{size}(u)$，所以没有一个节点可以出去 $u$ 的子树，此时 $u$ 子树内一定要删去一个。

因为一定有至少两个人的初始部门为 $u$，所以删掉任意一人都可以用这两个人的其中一个代替。

图例说明一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/wmopzd18.png)

如上图，图 $1$ 是没加入 $(4,9)$ 之前的方案，根据上述定义得 $x=4,s=1,w=5,(y,z)=(2,8)$。

加入 $(4,9)$，$(4,9)$ 占 $w$ 的位置， $(y,z)$ 去占 $y$ 子树内任意一点。因为 $(1,5)$ 的初始节点不在 $y$ 子树内，所以此处选的是点 $3$，于是变成图 $2$ 的情况。

然后 $y$ 子树又多一个人，于是递归 $y$，就把多出的 $(1,5)$ 去占 $1$ 子树内任意一点。由于 $s=1$，直接占在 $s$ 即可，于是变成图 $3$ 的情况 。

最后，递归到 $s$ 了，就让 $s$ 处两个人的任意一个代替子树中点权最小的即可，图中 $(1,5)$ 代替了 $(2,4)$，即为图 $4$ 的情况。

从选的人的集合看，就是加入 $(x,v)$，删去 $u$ 子树内任意一人。

以上为证明，以下为维护方法。

用树链剖分套线段树动态维护每个节点的 $u$ 的：$\operatorname{size}(u)-s(u)$、选的 $(u,v)$ 的 $-v$ 的最大值。

为了动态维护单点 $-v$ 最大值，用 `multiset` 存储 $-v$ 的所有值。

时间复杂度 $O(n\log ^3 n)$，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=400005;
vector<int>ve[MAXN];
int fa[MAXN],n,k,m,X[MAXN],val[MAXN],lst[MAXN],son[MAXN],dep[MAXN],siz[MAXN],top[MAXN],tcnt,dfn[MAXN],pid[MAXN];
vector<int>vec[MAXN];
ll ans[MAXN];
void dfs1(int u) {
	siz[u]=1;
	for(int v:ve[u]) {
		dep[v]=dep[u]+1;
		dfs1(v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}
void dfs2(int u,int tp) {
	top[u]=tp,dfn[u]=++tcnt,pid[tcnt]=u;
	if(son[u]) dfs2(son[u],tp);
	for(int v:ve[u])
		if(v^son[u])
			dfs2(v,v);
}
struct Tree {
	int l,r,mn,lt;//mn:[l,r]中size(u)-s(u)最小值，lt：懒标记
	pair<int,int>mx;//mx:[l,r]中的人(u,v)的-v的最大值和初始节点
} tr[MAXN];
multiset<int>st[MAXN];
void build(int num,int l,int r) {
	tr[num].l=l,tr[num].r=r,tr[num].mx=make_pair(0,r);//初始有人(u,0)
	if(l==r) return;
	build(num<<1,l,l+r>>1),build(num<<1|1,(l+r>>1)+1,r);
}
void updatemx(int num,int x,int v) {
	if(tr[num].l==tr[num].r) {
		tr[num].mx=make_pair(v,x);
		return;
	}
	updatemx(num<<1|(x>tr[num<<1].r),x,v);
	tr[num].mx=max(tr[num<<1].mx,tr[num<<1|1].mx);
}
pair<int,int> querymx(int num,int l,int r) {
	if(l<=tr[num].l&&tr[num].r<=r) return tr[num].mx;
	if(r<=tr[num<<1].r) return querymx(num<<1,l,r);
	if(tr[num<<1|1].l<=l) return querymx(num<<1|1,l,r);
	return max(querymx(num<<1,l,r),querymx(num<<1|1,l,r));
}
inline void upd(int num,int x) {
	tr[num].mn+=x,tr[num].lt+=x;
}
inline void push_down(int num) {
	if(!tr[num].lt) return;
	upd(num<<1,tr[num].lt),upd(num<<1|1,tr[num].lt);
	tr[num].lt=0;
}
void update(int num,int l,int r,int x) {
	if(l<=tr[num].l&&tr[num].r<=r) return upd(num,x);
	push_down(num);
	if(l<=tr[num<<1].r) update(num<<1,l,r,x);
	if(tr[num<<1|1].l<=r) update(num<<1|1,l,r,x);
	tr[num].mn=min(tr[num<<1].mn,tr[num<<1|1].mn);
}
int Findz(int num) {
	if(tr[num].l==tr[num].r) return tr[num].l;
	return push_down(num),Findz(num<<1|(!tr[num<<1|1].mn));
}
int query(int num,int l,int r) {
	if(l<=tr[num].l&&tr[num].r<=r) {
		return tr[num].mn?-1:Findz(num);
	}
	push_down(num);
	if(r<=tr[num<<1].r) return query(num<<1,l,r);
	if(tr[num<<1|1].l<=l) return query(num<<1|1,l,r);
	int res=query(num<<1|1,l,r);
	if(~res) return res;
	else return query(num<<1,l,r);
}
inline void upRange(int u,int v) {
	for(; top[u]; u=fa[top[u]]) 
		update(1,dfn[top[u]],dfn[u],v);
}
void Add(int num,int l,int r,int L,int R,int x) {
	if(L<=l&&r<=R) {
		vec[num].push_back(x);
		return;
	}
	if(L<=(l+r>>1)) Add(num<<1,l,l+r>>1,L,R,x);
	if(R> (l+r>>1)) Add(num<<1|1,(l+r>>1)+1,r,L,R,x);
}
int qry(int u) {
	int res=query(1,dfn[top[u]],dfn[u]);
	return ~res?pid[res]:qry(fa[top[u]]);
}
inline void add(int u,int v) {//答案集合加入人(u,v)
	st[u].insert(v);
	updatemx(1,dfn[u],*st[u].rbegin());
	upRange(u,-1);
}
inline void del(int u,int v) {//答案集合删去人(u,v)
	st[u].erase(st[u].lower_bound(v));
	updatemx(1,dfn[u],st[u].empty()?-0x3f3f3f3f:*st[u].rbegin());
	upRange(u,1);
}
struct node {
	int x,xv,y,yv;
};
ll res;
void solve(int num,int l,int r) {
	vector<node>vt;
	for(int v:vec[num]) {
		int u=qry(X[v]);
		pair<int,int>tmp=querymx(1,dfn[u],dfn[u]+siz[u]-1);
		if(tmp.first+val[v]>0) {
			vt.push_back(node{X[v],val[v],tmp.second,tmp.first});
			res+=tmp.first+val[v];
			del(pid[tmp.second],tmp.first);
			add(X[v],-val[v]);
		}
	}
	if(l==r) ans[l]=res;
	else {
		int mid=l+r>>1;
		solve(num<<1,l,mid),solve(num<<1|1,mid+1,r);
	}
	for(node z; !vt.empty(); vt.pop_back()) {
		z=vt.back();
		res-=z.xv+z.yv;
		del(z.x,-z.xv),add(pid[z.y],z.yv);
	}
}
int main() {
	scanf("%*d%d%d%d",&n,&k,&m);
	for(int i=1; i<=n; ++i)st[i].insert(0); //初始有人(u,0)
	for(int i=2; i<=n; ++i)scanf("%d",&fa[i]),ve[fa[i]].push_back(i);
	for(int i=1; i<=k; ++i) scanf("%d%d",&X[i],&val[i]);
	for(int i=1,op=0,x=0; i<=m; ++i) {
		scanf("%d",&op);
		if(op==1) {
			++k,lst[k]=i,scanf("%d%d",&X[k],&val[k]);
		} else {
			scanf("%d",&x),Add(1,0,m,lst[x],i-1,x),lst[x]=m+1;
		}
	}
	for(int i=1; i<=k; ++i)
		if(lst[i]<=m)
			Add(1,0,m,lst[i],m,i);
	dfs1(1),dfs2(1,1),build(1,1,n);
	solve(1,0,m);
	for(int i=0; i<=m; ++i) printf("%lld ",ans[i]);
	return 0;
} 
```

---

## 作者：H_Kaguya (赞：7)

考场降智系列。  
不降智也调不出来啊那没事了。  

首先，如果跑一遍 dfn 序，这就变成了一个经典问题。  
有若干个人，每个人可以在区间 $[l_i, r_i]$ 里选一个位置，每个位置只能容纳一个人，每个人有个权值。  
求最大总权值。  

显然是贪心，但是还是严谨证明一下。  
我们可以证明这是个拟阵。  
遗传性显然，考虑交换性。  
设现在有两个不同的方案 $A, B$，满足 $A$ 中选的人的数量小于 $B$。  
首先把 $A, B$ 的交集扣掉。  
那么我们去尝试把 $A$ 中有，$B$ 中没有的人插入到 $A$ 中去。  
由于每个人只占一个位置，所以插入的时候有两种情况：  

1. 没有空位无法插入。此时踢掉一个区间里 $B$ 中有但 $A$ 中没有的人，再插入。  
由于 $A$ 是合法的，容易发现总是能踢掉一个。  
2. 有空位。直接插入。  

由于 $B$ 中初始人数严格大于 $A$，每次插入总人数单调不降，所以最后至少会剩余一个 $B$ 中有而 $A$ 中没有的人。  
交换性得证。  

因此这是个可贪心的问题。  
由于是二分图，判定合法可以用 Hall 定理。  

在序列上维护有点困难，还是回归到树上。  
根据 Hall 定理，当树上的任意一个节点子树内部的员工的数量小于等于节点个数的时候有解。  

树链剖分，设 $size_u$ 表示 $u$ 的子树大小，$f_u$表示 $u$ 子树内的员工个数。  
对于每个节点，维护 $w_u = size_u - f_u$。  

当我们乱序插入员工到节点 $v$ 的时候，首先遍历其树上的父链。  
如果父链上的点的 $w$ 值都为正那就直接插入。  
否则找到离 $v$ 最近的 $w_u = 0$ 的点 $u$，找到其子树内权值最小的员工 $s$。  
若 $s$ 的权值小于我们要插入的员工，就把 $s$ 删了。  
否则这个员工就没必要插入了。  

插入员工很容易，但是撤销有些麻烦。  
所以整体还需要套一个线段树分治。  
维护员工的时候考虑到一个节点可能会有多个员工，用 `multiset` 维护一下。  
~~如果你 WA 98pts 调了两天调不出来可能是因为用了 set。~~  

时间复杂度 $O(n \log^3 n)$，空间复杂度 $O(n \log n)$，不过常数不算大（有一个 $\log$ 是树剖贡献的），5s 可以稳过。  

为了方便起变量名，码风有点怪。  
贴在下面~  

```cpp
#include <set>
#include <vector>
#include <stdio.h>
using namespace std;
#define sz 100005
const int inf = 1e8;
struct site
{
	int poi, val, tim;
};
site num[sz << 1];
struct md
{
	int kid, poi, val;
};
md bin[sz << 4];
int n, k, m, top;
long long ans;
namespace tr
{
	extern int now;
	extern int fsl[sz], dld[sz], big[sz], dfn[sz], fa[sz], col[sz];
	int dfs(int a);
	void redfs(int a, int c);
	void prodfs(int a);
	void load();
	void sol(int poi, int val);
}
int read()
{
	int x = 0;
	char c = getchar();
	while (c < '0') c = getchar();
	do {
		x = x * 10 + (c & 15);
		c = getchar();
	}while (c >= '0');
	return x;
}
namespace sug
{
	struct node
	{
		int mn, poi;
	};
	node tree[sz << 1];
	multiset<int> ins[sz];
	node merge(node a, node b)
	{
		if (a.mn < b.mn)
			return a;
		return b;
	}
	void build(int a, int lf, int rt)
	{
		for (int i = 0; i <= (n << 1 | 1); ++i)
		{
			tree[i].mn = inf;
			tree[i].poi = i + 1 >> 1;
		}
	}
	void fix(int a, int lf, int rt, int w, int b)
	{
		if (lf == rt)
		{
			tree[a].mn = b;
			tree[a].poi = w;
			return;
		}
		int mid = lf + rt >> 1;
		if (w <= mid)
			fix(mid << 1, lf, mid, w, b);
		else
			fix(mid << 1 | 1, mid + 1, rt, w, b);
		tree[a] = merge(tree[mid << 1], tree[mid << 1 | 1]);
	}
	node serch(int a, int lf, int rt, int wa, int wb)
	{
		if (lf == wa && rt == wb)
			return tree[a];
		int mid = lf + rt >> 1;
		if (wb <= mid)
			return serch(mid << 1, lf, mid, wa, wb);
		if (wa > mid)
			return serch(mid << 1 | 1, mid + 1, rt, wa, wb);
		return merge(serch(mid << 1, lf, mid, wa, mid), serch(mid << 1 | 1, mid + 1, rt, mid + 1, wb));
	}
}
namespace sag
{
	struct site
	{
		int val, poi;
	};
	site merge(site a, site b)
	{
		if (a.val < b.val)
			return a;
		return b;
	}
	struct node
	{
		site mn;
		int laz;
	};
	node tree[sz << 1];
	void build(int a, int lf, int rt)
	{
		tree[a].laz = 0;
		if (lf == rt)
		{
			tree[a].mn.val = tr::big[lf];
			tree[a].mn.poi = lf;
			return;
		}
		int mid = lf + rt >> 1;
		build(mid << 1, lf, mid);
		build(mid << 1 | 1, mid + 1, rt);
		tree[a].mn = merge(tree[mid << 1].mn, tree[mid << 1 | 1].mn);
	}
	void fix(int a, int lf, int rt, int wa, int wb, int b)
	{
		if (lf == wa && rt == wb)
		{
			tree[a].mn.val += b;
			tree[a].laz += b;
			return;
		}
		int mid = lf + rt >> 1;
		if (wb <= mid)
			fix(mid << 1, lf, mid, wa, wb, b);
		else if (wa > mid)
			fix(mid << 1 | 1, mid + 1, rt, wa, wb, b);
		else
		{
			fix(mid << 1, lf, mid, wa, mid, b);
			fix(mid << 1 | 1, mid + 1, rt, mid + 1, wb, b);
		}
		tree[a].mn = merge(tree[mid << 1].mn, tree[mid << 1 | 1].mn);
		tree[a].mn.val += tree[a].laz;
	}
	site serch(int a, int lf, int rt, int wa, int wb)
	{
		if (lf == wa && rt == wb)
			return tree[a].mn;
		int mid = lf + rt >> 1;
		site ret;
		if (wb <= mid)
			ret = serch(mid << 1, lf, mid, wa, wb);
		else if (wa > mid)
			ret = serch(mid << 1 | 1, mid + 1, rt, wa, wb);
		else
			ret = merge(serch(mid << 1, lf, mid, wa, mid), serch(mid << 1 | 1, mid + 1, rt, mid + 1, wb));
		ret.val += tree[a].laz;
		return ret;
	}
}
namespace tr
{
	int now = 0;
	int fsl[sz], dld[sz], ed[sz], big[sz], dfn[sz], fa[sz], col[sz];
	int dfs(int a)
	{
		int mx = 0, tmp;
		for (int i = fsl[a]; i; i = dld[i])
		{
			tmp = dfs(i);
			if (mx < tmp)
			{
				mx = tmp;
				big[a] = i;
			}
		}
		return mx + 1;
	}
	void redfs(int a, int b)
	{
		dfn[a] = ++now;
		col[now] = b;
		if (big[a])
		{
			fa[now + 1] = now;
			redfs(big[a], b);
			for (int i = fsl[a]; i; i = dld[i])
				if (!dfn[i])
				{
					fa[now + 1] = dfn[a];
					redfs(i, now + 1);
				}
		}
		ed[dfn[a]] = now;
	}
	void prodfs(int a)
	{
		for (int i = fsl[a]; i; i = dld[i])
		{
			prodfs(i);
			big[dfn[a]] += big[dfn[i]];
		}
	}
	void load()
	{
		int x;
		for (int i = 2; i <= n; ++i)
		{
			x = read();
			dld[i] = fsl[x];
			fsl[x] = i;
		}
		dfs(1); redfs(1, 1);
		for (int i = 1; i <= n; ++i)
			big[i] = 1;
		prodfs(1);
	}
	void sol(int poi, int val)
	{
		int x = poi;
		while (x)
		{
			auto a = sag::serch(0, 1, n, col[x], x);
			if (a.val == 0)
			{
				auto b = sug::serch(0, 1, n, a.poi, ed[a.poi]);
				if (b.mn >= val)
					return;
				ans -= b.mn;
				bin[++top].kid = 0;
				bin[top].poi = b.poi;
				bin[top].val = b.mn;
				sug::ins[b.poi].erase(sug::ins[b.poi].find(b.mn));
				if (sug::ins[b.poi].empty())
					sug::fix(0, 1, n, b.poi, inf);
				else
					sug::fix(0, 1, n, b.poi, *(sug::ins[b.poi].begin()));
				x = b.poi;
				while (x)
				{
					sag::fix(0, 1, n, col[x], x, 1);
					x = fa[col[x]];
				}
				break;
			}
			x = fa[col[x]];
		}
		ans += val;
		bin[++top].kid = 1;
		bin[top].poi = poi;
		bin[top].val = val;
		sug::ins[poi].emplace(val);
		sug::fix(0, 1, n, poi, *(sug::ins[poi].begin()));
		x = poi;
		while (x)
		{
			sag::fix(0, 1, n, col[x], x, -1);
			x = fa[col[x]];
		}
	}
}
namespace seg
{
	struct site
	{
		int poi, val;
		site(){}
		site(int a, int b)
		{
			poi = a; val = b;
		}
	};
	vector<site> tree[sz << 1];
	void insert(int a, int lf, int rt, int wa, int wb, int poi, int val)
	{
		if (lf == wa && rt == wb)
		{
			tree[a].emplace_back(poi, val);
			return;
		}
		int mid = lf + rt >> 1;
		if (wb <= mid)
			insert(mid << 1, lf, mid, wa, wb, poi, val);
		else if (wa > mid)
			insert(mid << 1 | 1, mid + 1, rt, wa, wb, poi, val);
		else
		{
			insert(mid << 1, lf, mid, wa, mid, poi, val);
			insert(mid << 1 | 1, mid + 1, rt, mid + 1, wb, poi, val);
		}
	}
	void load()
	{
		int x;
		for (int i = 1; i <= k; ++i)
		{
			num[i].poi = read();
			num[i].val = read();
			num[i].tim = 1;
		}
		for (int i = 2; i <= m; ++i)
			if (read() == 1)
			{
				num[++k].poi = read();
				num[k].val = read();
				num[k].tim = i;
			}else
			{
				x = read();
				insert(0, 1, m, num[x].tim, i - 1, num[x].poi, num[x].val);
				num[x].tim = 0;
			}
		for (int i = 1; i <= k; ++i)
			if (num[i].tim)
				insert(0, 1, m, num[i].tim, m, num[i].poi, num[i].val);
	}
	void bak(int sav, long long savans)
	{
		ans = savans;
		while (top > sav)
		{
			if (bin[top].kid)
			{
				sug::ins[bin[top].poi].erase(sug::ins[bin[top].poi].find(bin[top].val));
				if (sug::ins[bin[top].poi].size())
					sug::fix(0, 1, n, bin[top].poi, *(sug::ins[bin[top].poi].begin()));
				else
					sug::fix(0, 1, n, bin[top].poi, inf);
				bin[top].kid = 1;
			}else
			{
				sug::ins[bin[top].poi].emplace(bin[top].val);
				sug::fix(0, 1, n, bin[top].poi, *(sug::ins[bin[top].poi].begin()));
				bin[top].kid = -1;
			}
			int x = bin[top].poi;
			while (x)
			{
				sag::fix(0, 1, n, tr::col[x], x, bin[top].kid);
				x = tr::fa[tr::col[x]];
			}
			--top;
		}
	}
	void dfs(int a, int lf, int rt)
	{
		long long savans = ans;
		int sav = top;
		for (site i : tree[a])
			tr::sol(tr::dfn[i.poi], i.val);
		if (lf == rt)
		{
			printf ("%lld ", ans);
			bak(sav, savans);
			return;
		}
		int mid = lf + rt >> 1;
		dfs(mid << 1, lf, mid);
		dfs(mid << 1 | 1, mid + 1, rt);
		bak(sav, savans);
	}
}
int main()
{
	int x, y;
	read();
	n = read(); k = read(); m = read() + 1;
	tr::load(); seg::load();
	sag::build(0, 1, n); sug::build(0, 1, n);
	seg::dfs(0, 1, m);
	return 0;
}
```


---

## 作者：_fairytale_ (赞：6)

# 前言

感谢撅翻老师的热心指导呜呜呜呜呜呜呜呜呜呜呜呜呜。[@一只绝帆](https://www.luogu.com.cn/user/401393)

同时思路参考了[第一篇题解](https://www.luogu.com.cn/blog/wyxawa/ti-xie-p9168-xing-xuan-lian-kao-2023-ren-yun-diao-du)，但是会讲的更细一点。

本题解大概是 luogu 上第一篇 $\mathcal O(n\log^2n)$ 实现...？

建议大家去 uoj 上交下代码，好像 $\mathcal O(n\log^3n)$ 的在那边都被卡 T 了。

哪里讲得不清楚或者出锅了欢迎提意见喵。

# 思路

## 1.$m=0$

先说 $m=0$ 时的做法。同时借此引出下文会用到的一些定义（加粗部分）。

**定义 $siz[u]$ 为以 $u$ 为根的子树大小（包括 $u$）。**

考虑做一个类似树形 DP 的东西，对于结点 $u$，如果它的子树没有被填满，就从 $u$ 派一个能力值最大的员工过去，否则不断尝试用能力值最大的员工去淘汰掉子树内能力值最小的员工。

具体地，**我们对于每个结点维护一个有序序列 $a$，定义 $len$ 为其长度**，序列里是按能力值从大到小排序的所有幸存的员工，它初始就是在 $u$ 结点上的员工。考虑到以 $u$ 为根的子树时，就把 $u$ 的序列和它所有儿子的序列合并，不断淘汰掉员工，直到 $len\le siz[u]$ 为止。这个容易用可并堆实现。

## 2.只有加人操作

变成动态的操作之后，修改一条链上的可并堆的代价是巨大的，所以我们需要另找思路来维护每个点的序列。

### 2.1 改变序列定义

我们不再在序列中维护只考虑 $u$ 为根的子树的最优决策，而维护全局的最优决策。换言之，若 $u$ 的序列中某个人在 $u$ 的祖先的序列中被淘汰了，则这个人也不应该存在于 $u$ 的序列中。因此，**若一个点存在于 $u$ 的序列中，则它一定存在于 $u$ 的祖先的序列中，且它存在于全局的最优决策中。**

### 2.2 动态维护决策 

**定义一个点 $u$ 是满的，当且仅当 $len=siz[u]$。**

我们考虑加入在结点 $u$ 加入一个员工对祖先的影响。如果结点 $u$ 到根的路径上没有任何一个点是满的，那么只需要把 $u$ 放到空位里。否则，找到 $u$ 到根的路径上最深的满的结点 $f$，尝试用这个员工替换 $f$ 子树中能力值最小的结点，若能替换则替换。

#### 2.2.1 维护结点是否是满的、查询点到根路径上第一个满的结点

我们首先把每个结点的权值赋成它的 $siz$，然后加入一个结点就把它到祖先路径上的权值全部 $-1$。这样一个点满了相当于权值为 $0$。

查询第一个满的结点相当于查询最小值（这里最小值是一个 `pair`，第一关键字是权值，第二关键字是 $-dfn/dep$，因为 $dfn/dep$ 越大结点一定越深，并且由于本题 $p_i<i$ 的特殊性质，也可以直接把负的结点编号作为第二关键字，如果不愿意取负也可以手动重载运算符）。

链加链 $\min$ 容易使用树剖或 LCT 维护，但树剖比 LCT 多一个 $\log$。

#### 2.2.2 查询子树最小值、加入/删除员工

我们对每个结点开一个 `multiset`，维护初始部门为这个结点的员工，然后用 `multiset` 中的最小值作为其权值，把 `multiset` 挂到线段树的叶子节点上，这就变成了经典的子树最小值问题。加入删除员工只需要在维护最小值的时候同时维护它的初始部门，然后直接改对应结点的 `multiset` 即可。

（选读）一个可能的问题：

在子树中能力值最小的员工有多个时，我们应该淘汰哪一个呢？

结论是都可以。首先除开能力值，区分员工的只有初始部门。一个感性的证明是，一个员工被淘汰，当且仅当它处于一个满了的结点子树内，所以无论淘汰哪一个，都只是用来腾出一个空位，并不存在哪个初始部门更高贵的这种说法。

还有一种不那么感性的证明是，考虑 $f$ 作为最深的满了的结点。

- 若 $f=u$，则不管淘汰哪个都可以用新加的补上去。

- 若 $f\ne u$，则以 $u$ 为根的子树一定不满，所以一定存在一种方案中 $f$ 有一个员工填这里面的空位。

  若淘汰的是以 $f$ 为初始部门的员工，可以直接扔掉。

  否则只需要把 $f$ 中填 $u$ 子树的那个员工移到淘汰的那个员工处，然后 $u$ 子树的那个位置换上新人即可。
  
  这个好像也是决策的正确性证明...？

所以无论淘汰哪一个都没有影响。

## 3.加入辞退操作

### 3.1 最后的一步——线段树分治

注意到一个员工存在的时间都是连续的一段，直接上线段树分治，变删除为撤销，这样就变成了 $2$ 中的问题。

### 3.2 复杂度分析

最多 $(k+m)$ 个员工的存在时间都被拆成 $\log m$ 段，每段都是一次加人，LCT 实现的复杂度为 $\log n$，纯树剖实现复杂度为 $\log^2 n$，所以总复杂度为：

LCT：$\mathcal O((k+m)\log m \log n)$

纯树剖：$\mathcal O((k+m)\log m \log^2 n)$

希望这部分无锅。/kel

## 4.代码

代码里还有一组拍出来的小样例，希望能帮到您。

[这里是纯树剖实现](https://www.luogu.com.cn/paste/mn88xxsa)

[这里是树剖 $+$ LCT 实现](https://www.luogu.com.cn/paste/5re8xblz)

---

## 作者：_Diu_ (赞：4)

时隔 10 个月过来补题的屑。

和 loj 那个黄金矿工不能说一模一样，只能说是一个妈妈生的。

先不考虑修改，那么有一个很显然的费用流模型：

- 每个员工 $(x,v)$ 表示圆点向点 $x$ 有一条流量为 $1$，费用为 $v$ 的边。

- 每个点 $x$ 向它的每个儿子 $y$，连一条流量无限，费用为 $0$ 的边。

- 每个点 $x$ 向汇点留一条流量为 $1$，费用为 $0$ 的边。

容易发现上述建图的最大费用即为所求。

这样可以轻松解决 $m$ 比较小的前 18 个点。共 36pts。

对于 $n,m,k\le 2333$ 的点，考虑每次修改完后最多增广一次，可以通过。共 48pts。

对于特殊性质 C，费用流退化为网络流，考虑最大流=最小割，割边一定是若干个不交子树中的所有点其其他点的入边，设 $f_{i,0/1}$ 表示子树是否全选 ddp 转移即可，复杂度 $O(n\log^2 n)$，可用全局平衡做到 $O(n\log n)$。共 54pts。

对于特殊性质 B，链的情况可以分块维护凸包。复杂度 $O(n\sqrt n)$。共 68pts。

接下来考虑关键部分分：特殊性质 A。

考虑每次增广环节是咋增广的，是先回退到某个祖先，然后进入子树内部抵达某个部门或者替换掉一个人。

那我肯定能往祖先润就先润过去，后面再回来也是没问题的。我们维护好当前的流量信息，向上找到能走到的深度最浅的祖先，并退流。

然后找到子树内一个最优秀的点增广。走到一个点再走向汇点是最优的，如果是推掉原来的一个点，那么肯定是子树内都被填满了，那我们找到子树最小值把他换掉。

这两部都可以简单用树剖线段树维护做到 $O(n\log^2 n)$，换成全局平衡可以做到 $O(n\log n)$。共 76pts。

正解就是特殊性质 A 再套个线分治即可做到 $O(n\log^3n)$ 或者 $O(n\log^2 n)$。我写的是 $O(n\log^3n)$，最慢的点两秒都不到。

具体实现想清楚后还是很好写的，实际上就是几个数据结构拼起来，代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ls (o<<1)
#define rs (o<<1|1)
using namespace std;
const int N=2e5+10,mod=998244353;
int ID,n,k,m,fa[N];
vector<int> g[N];
struct node{int x,v,l,r;}a[N<<1];
ll ans;
namespace tree{
	const int M=1.6e6+10;
	struct opr{int op,x,v;}st[M];
	int lp;
	int sz[N],son[N],tp[N],dfn[N],num[N],id;
	void dfs(int u){
		sz[u]=1;
		for(int v:g[u]){
			dfs(v),sz[u]+=sz[v];
			if(!son[u]||sz[son[u]]<sz[v])son[u]=v;
		}
	}
	void dfs2(int u,int hd){
		tp[u]=hd,dfn[u]=++id,num[id]=u;
		if(son[u]){
			dfs2(son[u],hd);
			for(int v:g[u])if(v!=son[u])dfs2(v,v);
		}
	}
	struct Node{int x,v;};
	Node operator+(Node a,Node b){
		if(a.v<b.v)return a;
		if(b.v<a.v)return b;
		if(dfn[a.x]<dfn[b.x])return b;//取dfn序上最右边的保证一条重链上回去到最深的点
		return a;
	}
	struct Seg1{
		Node t[N<<2];
		int tg[N];
		void add(int o,int v){t[o].v+=v,tg[o]+=v;}
		void down(int o){
			if(tg[o])add(ls,tg[o]),add(rs,tg[o]),tg[o]=0;
		}
		void bld(int o,int l,int r){
			t[o]={num[r],0};
			if(l==r)return;
			int mid=l+r>>1;
			bld(ls,l,mid),bld(rs,mid+1,r);
		}
		void upd(int o,int l,int r,int x,int y,int v){
			if(x<=l&&r<=y)return add(o,v);
			int mid=l+r>>1;down(o);
			if(x<=mid)upd(ls,l,mid,x,y,v);
			if(y>mid)upd(rs,mid+1,r,x,y,v);
			t[o]=t[ls]+t[rs];
		}
		Node qry(int o,int l,int r,int x,int y){
			if(x<=l&&r<=y)return t[o];
			int mid=l+r>>1;down(o);
			if(y<=mid)return qry(ls,l,mid,x,y);
			if(x>mid)return qry(rs,mid+1,r,x,y);
			return qry(ls,l,mid,x,y)+qry(rs,mid+1,r,x,y);
		}
	}T1;//维护区间加区间min
	struct Queue{
		priority_queue<int> q1,q2;
		void push(int x){q1.push(-x);}
		void flush(){while(!q2.empty()&&q1.top()==q2.top())q1.pop(),q2.pop();}
		int top(){flush();return -q1.top();}
		void pop(){q1.pop();}
		void erase(int x){q2.push(-x);}
		bool empty(){return q1.size()==q2.size();}
	};
	struct Seg2{
		Node t[N<<2];
		Queue q[N];
		void bld(int o,int l,int r){
			t[o]={num[r],0};
			if(l==r)return;
			int mid=l+r>>1;
			bld(ls,l,mid),bld(rs,mid+1,r);
		}
		void ins(int o,int l,int r,int x,int v){
			if(l==r){
				if(v<t[o].v)q[l].push(t[o].v),t[o].v=v;
				else q[l].push(v);
				return;
			}
			int mid=l+r>>1;
			if(x<=mid)ins(ls,l,mid,x,v);
			else ins(rs,mid+1,r,x,v);
			t[o]=t[ls]+t[rs];
		}
		void del(int o,int l,int r,int x,int v){
			if(l==r){
				if(t[o].v==v){
					if(q[l].empty())t[o].v=N;
					else t[o].v=q[l].top(),q[l].pop();
				}else q[l].erase(v);
				return;
			}
			int mid=l+r>>1;
			if(x<=mid)del(ls,l,mid,x,v);
			else del(rs,mid+1,r,x,v);
			t[o]=t[ls]+t[rs];
		}
		Node qry(int o,int l,int r,int x,int y){
			if(x<=l&&r<=y)return t[o];
			int mid=l+r>>1;
			if(y<=mid)return qry(ls,l,mid,x,y);
			if(x>mid)return qry(rs,mid+1,r,x,y);
			return qry(ls,l,mid,x,y)+qry(rs,mid+1,r,x,y);
		}
	}T2;//维护单点 insert/delete 区间min
	void init(){
		dfs(1),dfs2(1,1);
		T1.bld(1,1,n),T2.bld(1,1,n);
	}
	int find(int x){
		while(x){
			Node t=T1.qry(1,1,n,dfn[tp[x]],dfn[x]);
			if(t.v==0)return t.x;
			x=fa[tp[x]];
		}
	}
	void chg(int x,int v){
		while(x){
			T1.upd(1,1,n,dfn[tp[x]],dfn[x],v);
			x=fa[tp[x]];
		}
	}
	void ins(int x,int v){
		int y=find(x);
		Node t=T2.qry(1,1,n,dfn[y],dfn[y]+sz[y]-1);
		if(t.v>v)return;
		st[++lp]={2,dfn[t.x],-t.v},st[++lp]={2,dfn[x],v};
		T2.del(1,1,n,dfn[t.x],t.v),T2.ins(1,1,n,dfn[x],v);
		ans+=v-t.v;
		st[++lp]={1,x,-1},st[++lp]={1,t.x,1};
		chg(x,-1),chg(t.x,1);
	}
	void back(int lst){
		while(lp>lst){
			if(st[lp].op==1)chg(st[lp].x,-st[lp].v);
			else{
				ans-=st[lp].v;
				if(st[lp].v>0)T2.del(1,1,n,st[lp].x,st[lp].v);
				else T2.ins(1,1,n,st[lp].x,-st[lp].v);
			}
			--lp;
		}
	}
}
vector<node> gr[N<<3];
void ins(int o,int l,int r,node t){
	if(t.l<=l&&r<=t.r){
		gr[o].push_back(t);
		return;
	}
	int mid=l+r>>1;
	if(t.l<=mid)ins(ls,l,mid,t);
	if(t.r>mid)ins(rs,mid+1,r,t);
}
void solve(int o,int l,int r){
	int lst=tree::lp;
	for(node t:gr[o])tree::ins(t.x,t.v);
	if(l==r){
		printf("%lld ",ans);
	}else{
		int mid=l+r>>1;
		solve(ls,l,mid),solve(rs,mid+1,r);
	}
	tree::back(lst);
}
signed main(){
	scanf("%d%d%d%d",&ID,&n,&k,&m);
	for(int i=2;i<=n;i++)scanf("%d",&fa[i]),g[fa[i]].push_back(i);
	for(int i=1;i<=k;i++)scanf("%d%d",&a[i].x,&a[i].v),a[i].r=m;
	for(int i=1,op,x,v;i<=m;i++){
		scanf("%d%d",&op,&x);
		if(op==1)scanf("%d",&v),a[++k]={x,v,i,m};
		else a[x].r=i-1;
	}
	for(int i=1;i<=k;i++)ins(1,0,m,a[i]);
	tree::init();
	solve(1,0,m);
}
```

---

## 作者：My__L (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P9168)

先不考虑插入与删除。

假设节点 $x$ 的所有子树 $v$ 的人员方案都已经确定了（即只考虑 $v$ 子树时该方案是最优的），现在需要插入 $x$ 节点的若干员工 $val$。
* 若此时 $x$ 子树中还有空的位置，将 $val$ 插入到空的位置上一定不会使得答案更劣
* 若此时 $x$ 子树满了，用 $val$ 替换子树内能力值最小的 $mn$ 肯定最优。若最小的 $mn\geqslant val$，那么放入 $val$ 肯定不优。

以上贪心策略算是显然的。“形式化的”，设 $siz_x$ 表示 $x$ 子树大小，每个节点处应维护一个能力值序列，父节点 $x$ 的能力值序列为子节点 $v$ 的能力值序列的并 + $x$ 节点的能力值，若其长度超过 $siz_x$ 则踢出最小的若干元素。

从以上过程也能看出“加点”比“删点”容易，再加上操作中的“插入——撤销”操作，考虑线段树分治插点。假设当前已维护了整棵树的答案，考虑一次新的插入 $(x,val)$ 对答案的贡献。若值 $val$ 会被贡献，它一定能被插入到 $(rt,x)$ 的所有能力值序列中或替换掉原本的某个值。

* 若 $(rt,x)$ 上的点的所有子树都不满，那么 $val$ 一定可以插入至最终的序列中

* 否则，考虑 $val$ 会被哪个点“拦截”下来，即考虑 $x$ 最深的满子树祖先 $fa$;此时 $val$ 要么被覆盖要么替换掉 $fa$ 树中被选的最小值 $mn$，若 $mn<val$ 那么 $val$ 就会替换答案序列中的 $mn$ 并贡献答案增量 $val-mn$，否则 $val$ 会被覆盖然后死翘翘。<br/>考虑最深的满子树节点即可，因为如果 $val$ 替换掉了 $mn$ 导致它在某个祖先处被覆盖，被覆盖这个 $mn$ 一定不会在答案序列中

思路说到这里就很清晰了，在线段树分治的架构上用重链剖分维护链上最深的满子树点（记录 $siz-选择个数$ 即可），再查询子树内最小值 $mn$ 就完了，复杂度 $O(n\log ^3 n)$

再说下程序实现，维护子树被选最小值的方法是每个节点开个 `multiset` 记录该节点被选入答案序列的能力值，在线段树上放其 `multiset` 集合中的最小值；插入、撤销操作在 `multiset` 中插入/删除再给线段树节点赋值就完成了。

```
#include <bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define fst first
#define scd second
#define mkp make_pair
using namespace std;
const int N=1e5+5;
const int inf=0x3f3f3f3f3f3f3f3f;
int T,n,k,m;
vector <int> tr[N];
pii a[N<<1];
int b[N<<1],f[N<<1],ans[N];
int siz[N],son[N],fa[N],dep[N];
int dfn[N],tme,idx[N],top[N];
struct Segment_Tree
{
    pii mn(pii x,pii y) { return (x.scd<y.scd?x:y); }
    struct node { int l,r,mn1,tag; pii mn2; }tr[N<<2];//mn1:siz-cnt mn2:(pos,val)
    void push_up(int id)
    {
        tr[id].mn1=min(tr[id<<1].mn1,tr[id<<1|1].mn1);
        tr[id].mn2=mn(tr[id<<1].mn2,tr[id<<1|1].mn2);
    }
    void push_down(int id)
    {
        if (!tr[id].tag) return ; 
        tr[id<<1].mn1+=tr[id].tag,tr[id<<1|1].mn1+=tr[id].tag;
        tr[id<<1].tag+=tr[id].tag,tr[id<<1|1].tag+=tr[id].tag;
        tr[id].tag=0;
    }
    void build(int id,int l,int r)
    {
        tr[id].l=l,tr[id].r=r;
        if (l==r) { tr[id].mn1=siz[idx[l]],tr[id].mn2=mkp(idx[l],inf); return ; }
        int mid=(l+r)>>1;
        build(id<<1,l,mid),build(id<<1|1,mid+1,r); push_up(id);
    }
    void update(int id,int pos,int k)
    {
        if (tr[id].l==tr[id].r) { tr[id].mn2.scd=k; return ; }
        push_down(id);
        int mid=(tr[id].l+tr[id].r)>>1;
        if (mid>=pos) update(id<<1,pos,k);
        else update(id<<1|1,pos,k); push_up(id);
    }
    int query_mn(int id,int l,int r)
    {
        if (tr[id].l>=l&&tr[id].r<=r) return tr[id].mn1;
        push_down(id); int mid=(tr[id].l+tr[id].r)>>1,res=inf;
        if (mid>=l) res=query_mn(id<<1,l,r);
        if (mid+1<=r) res=min(res,query_mn(id<<1|1,l,r));
        return res;
    }
    int tmp(int id)
    {
        if (tr[id].l==tr[id].r) return idx[tr[id].l];
        push_down(id);
        return (tr[id<<1|1].mn1?tmp(id<<1):tmp(id<<1|1));
    }
    int bs(int id,int l,int r)
    {
        if (tr[id].l>=l&&tr[id].r<=r) return (tr[id].mn1?-1:tmp(id));
        push_down(id);
        int res=-1,mid=(tr[id].l+tr[id].r)>>1;
        if (mid+1<=r) res=bs(id<<1|1,l,r);
        return (res==-1?(mid>=l?bs(id<<1,l,r):-1):res);
    }
    pii query(int id,int l,int r)
    {
        if (tr[id].l>=l&&tr[id].r<=r) return tr[id].mn2;
        push_down(id);
        int mid=(tr[id].l+tr[id].r)>>1; pii res=mkp(0,inf);
        if (mid>=l) res=query(id<<1,l,r);
        if (mid+1<=r) res=mn(res,query(id<<1|1,l,r)); return res;
    }
    void add(int id,int l,int r,int k)
    {
        if (tr[id].l>=l&&tr[id].r<=r) { tr[id].mn1+=k; tr[id].tag+=k; return ; }
        push_down(id);
        int mid=(tr[id].l+tr[id].r)>>1;
        if (mid>=l) add(id<<1,l,r,k);
        if (mid+1<=r) add(id<<1|1,l,r,k); push_up(id);
    }
}Tr;
multiset <int> st[N];
vector <pii> add[N<<2];

void dfs1(int x)
{
    siz[x]=1,dep[x]=dep[fa[x]]+1;
    int _size=tr[x].size(),v;
    for (int i=0;i<_size;i++)
    {
        dfs1(v=tr[x][i]); siz[x]+=siz[v]; 
        if (siz[v]>siz[son[x]]) son[x]=v;
    }
}
void dfs2(int x,int _top)
{
    dfn[x]=++tme,idx[tme]=x,top[x]=_top;
    if (son[x]) dfs2(son[x],_top);
    int _size=tr[x].size(),v;
    for (int i=0;i<_size;i++) if ((v=tr[x][i])!=son[x]) dfs2(v,v);
}
void ins(int id,int l,int r,int ql,int qr,int x,int y)
{
    if (l>=ql&&r<=qr) { add[id].push_back(mkp(x,y)); return ; }
    int mid=(l+r)>>1; if (mid>=ql) ins(id<<1,l,mid,ql,qr,x,y);
    if (mid+1<=qr) ins(id<<1|1,mid+1,r,ql,qr,x,y);
}
int query(int now)//寻找最深的满子树点
{
    while (now)
    {
        if (!Tr.query_mn(1,dfn[top[now]],dfn[now])) return Tr.bs(1,dfn[top[now]],dfn[now]);
        now=fa[top[now]];
    }
    return -1;
}
void update(int x,int k) { while (x) { Tr.add(1,dfn[top[x]],dfn[x],k); x=fa[top[x]]; } }
void ad(int x,int y) { st[x].insert(y); Tr.update(1,dfn[x],*st[x].begin()); update(x,-1); }
void dl(int x,int y) { st[x].erase(st[x].lower_bound(y)); Tr.update(1,dfn[x],*st[x].begin()); update(x,1); }
void solve(int id,int l,int r,int sum)//线段树分治
{
    vector <pii> a1,a2;//记录撤销的点
    int _size=add[id].size();
    
    for (int i=0;i<_size;i++)
    {
        int pos=add[id][i].fst,val=add[id][i].scd;
        int tmp=query(pos);
        if (tmp==-1) { sum+=val; ad(pos,val); a2.push_back({pos,val}); }
        else
        {
            pii res=Tr.query(1,dfn[tmp],dfn[tmp]+siz[tmp]-1);
            if (res.scd>=val) continue;
            ad(pos,val),dl(res.fst,res.scd),sum+=val-res.scd;
            a1.push_back(res),a2.push_back(add[id][i]);
        }
    }
    int mid=(l+r)>>1;
    if (l==r) cout<<sum<<" ";
    else solve(id<<1,l,mid,sum),solve(id<<1|1,mid+1,r,sum);

    _size=a1.size(); for (int i=_size-1;i>=0;i--) ad(a1[i].fst,a1[i].scd);
    _size=a2.size(); for (int i=_size-1;i>=0;i--) dl(a2[i].fst,a2[i].scd);
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    cin>>T>>n>>k>>m; for (int i=1;i<=n;i++) st[i].insert(inf);
    for (int i=2;i<=n;i++) { cin>>fa[i]; tr[fa[i]].push_back(i); }
    for (int i=1,u,v;i<=k;i++) cin>>a[i].fst>>a[i].scd;
    for (int i=1,op,u,v;i<=m;i++)
    {
        cin>>op>>u; if (op==1) { cin>>v; a[++k]={u,v}; b[k]=i; }
        else { ins(1,0,m,b[u],i-1,a[u].fst,a[u].scd); f[u]=1; }
    }

    for (int i=1;i<=k;i++) if (!f[i]) ins(1,0,m,b[i],m,a[i].fst,a[i].scd);
    dfs1(1),dfs2(1,1); Tr.build(1,1,n),solve(1,0,m,0); return 0;
}   
```

---

## 作者：Fzrcy (赞：3)

先考虑没有加点时如何做，有一个比较明显的贪心：自底向上更新，对于节点 $u$ ，如果子树中还有空闲的部门，我们先将其填满，然后我们尽量用在 $u$ 中的能力值最大的空闲员工替换在 $u$ 的子树内的能力值最小的在岗员工。贪心加启发式合并可以得到 $\texttt{48pts}$。

删除操作似乎很难维护，考虑将问题离线并使用线段树分治，将加人删人改为加人撤销。

然后我们考虑加人操作，对于每个点 $u$ 维护当前最优解中节点 $u$ 中被选择的员工集合。这里默认员工 $0$ 的能力值为 $-\infty$。

设 $s_x$ 表示最优解中子树 $u$ 内被选择的员工个数，$sz_x$ 表示子树 $u$ 的大小，$g_u$ 表示当前最优解中子树 $u$ 内被选择的能力值最小的员工（没有则为 $0$）。

现在加入一位初始部门在 $x$ 的员工 $u$：

1. 若 $x$ 和 $x$ 的祖先均满足 $sz>s$，直接加入 $u$ 即可。

2. 否则找到离 $x$ 最近的祖先节点 $k$（$k$ 可以是 $x$）满足 $sz_k=s_k$，若 $g_k$ 的能力值比 $u$ 小，则删去 $g_k$ 加上 $u$ 即可。

> 这样做显然最优，必要性显然（若加上 $u$ 则一定要在子树 $k$ 中删去一个员工以满足 $s_k\le sz_k$）。接下来是合法性的证明：
>
> 1. 若 $k=x$，则 $u$ 可以替代 $g_k$ 的位置。
> 2. 否则当前最优解中 $k$ 内被选择的员工中一定存在一个 $e$，满足要将其放在子树 $x$ 中（因为 $s_x<sz_x$）。删去 $g_k$ 后用 $u$ 替代 $e$ 的位置，$e$ 替代 $g_k$ 的位置即可。

用树剖维护考虑，单次加人、撤销的复杂度为 $O(\log^2n)$，总复杂度为 $O(n\log^3n)$（假设 $n,m$ 同阶）。

```cpp
// qwq
#include <bits/stdc++.h>
#define pb push_back
#define RG register
#define R RG int
#define RL RG ll
#define gc getchar()
#define pc putchar
#define inl inline
#define mid (l+r>>1)
using ll = long long;
using namespace std;

inl int in(){
    char c;R x=0,bo=0;
    while(!isdigit(c=gc))if(c=='-')bo=1;
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=gc;
    return bo?-x:x;
}

void wr(RL x){
    if(x<0)pc('-'),x=-x;
    if(x>=10ll)wr(x/10);
    pc(x%10+48);
}

constexpr int N=1e5+12;

int nfd[N],top[N],dep[N],Fa[N];
int sz[N],dfn[N],dfnt,ms[N];
vector<int>e[N];
int n;

inl void dfs1(int u,int fa){
    dep[u]=dep[fa]+1,sz[u]=1,Fa[u]=fa;
    for(int v:e[u]){
        dfs1(v,u),sz[u]+=sz[v];
        if(sz[v]>sz[ms[u]])ms[u]=v;
    }
}
inl void dfs2(int u,int Top){
    top[u]=Top,dfn[u]=++dfnt,nfd[dfnt]=u;
    if(ms[u])dfs2(ms[u],Top);
    for(int v:e[u])if(v^ms[u])dfs2(v,v);
}

struct SegTree{ // subtree size
    int t[N<<2],g[N<<2];
    inl void Tag(R k,R v){t[k]+=v,g[k]+=v;}
    inl void up(R k){t[k]=min(t[k<<1],t[k<<1|1]);}
    inl void dw(R k){if(g[k])Tag(k<<1,g[k]),Tag(k<<1|1,g[k]),g[k]=0;}
    inl void build(R k,R l,R r){
        if(l==r){t[k]=sz[nfd[l]];return;}
        build(k<<1,l,mid),build(k<<1|1,mid+1,r),up(k);
    }
    inl void upd(R k,R l,R r,R x,R y,R v){
        if(l>=x&&r<=y)return Tag(k,v);dw(k);
        if(x<=mid)upd(k<<1,l,mid,x,y,v);
        if(y>mid) upd(k<<1|1,mid+1,r,x,y,v);
        up(k);
    }
    inl int qmn(R k,R l,R r,R x,R y){
        if(l>=x&&r<=y)return t[k];dw(k);
        if(y<=mid)return qmn(k<<1,l,mid,x,y);
        if(x>mid) return qmn(k<<1|1,mid+1,r,x,y);
        return min(qmn(k<<1,l,mid,x,y),qmn(k<<1|1,mid+1,r,x,y));
    }
    inl int Q0(R k,R l,R r,R x,R y){
        if(l>=x&&r<=y){
            if(t[k]>0)return 0;
            while(l<r){
                dw(k);
                if(t[k<<1|1]==0){k=k<<1|1,l=mid+1;}
                else k=k<<1,r=mid;
            }
            return l;
        }
        dw(k);
        if(y<=mid)return Q0(k<<1,l,mid,x,y);
        if(x>mid) return Q0(k<<1|1,mid+1,r,x,y);
        R rc=Q0(k<<1|1,mid+1,r,x,y);if(rc)return rc;
        return Q0(k<<1,l,mid,x,y);
    }
}Tr;


struct Node{vector<int> av;/*people*/}S[N<<2];
int m,K,X[N<<1],V[N<<1],lst[N<<1];ll Ans[N<<1],cur;
struct People{int x;bool operator < (const People& b)const{return V[x]<V[b.x]||V[x]==V[b.x]&&x<b.x;}};
#define Min(X,Y) ((V[(X)]<V[(Y)])?(X):(Y))

struct segTree{ // Min Value
    set<People>s[N<<2]; int t[N<<2];
    inl void up(R k){t[k]=Min(t[k<<1],t[k<<1|1]);}
    inl void upd(R k,R l,R r,R x,R y){
        if(l==r){t[k]=y;return;}
        if(x<=mid)upd(k<<1,l,mid,x,y);
        else      upd(k<<1|1,mid+1,r,x,y);
        up(k);
    }
    inl int ask(R k,R l,R r,R x,R y){
        if(l>=x&&r<=y)return t[k];
        if(y<=mid)return ask(k<<1,l,mid,x,y);
        if(x>mid) return ask(k<<1|1,mid+1,r,x,y);
        R lc=ask(k<<1,l,mid,x,y),rc=ask(k<<1|1,mid+1,r,x,y);
        return Min(lc,rc);
    }
    inl void Ins(R x,R v){s[x].insert({v}),upd(1,1,n,dfn[x],s[x].begin()->x);}
    inl void Del(R x,R v){
        s[x].erase({v});
        if(s[x].empty())upd(1,1,n,dfn[x],0);
        else upd(1,1,n,dfn[x],s[x].begin()->x);
    }
    inl void build(R k,R l,R r){
        t[k]=0;if(l==r)return;
        build(k<<1,l,mid),build(k<<1|1,mid+1,r);
    }
}tr;

inl void Modify(R k,R l,R r,R x,R y,R v){
    if(l>=x&&r<=y){S[k].av.pb(v);return;}
    if(x<=mid)Modify(k<<1,l,mid,x,y,v);
    if(y>mid) Modify(k<<1|1,mid+1,r,x,y,v);
}

inl int f0(R x){
    while(x){
        R y=top[x];
        if(Tr.qmn(1,1,n,dfn[y],dfn[x]))
            {x=Fa[y];continue;}
        return Tr.Q0(1,1,n,dfn[y],dfn[x]);
    }
    return 0;
}

inl void subsizeadd(R x,R v){while(x)Tr.upd(1,1,n,dfn[top[x]],dfn[x],v),x=Fa[top[x]];}
#define EraPeople(D) (subsizeadd(X[(D)], 1),tr.Del(X[(D)],(D)),cur-=V[(D)])
#define InsPeople(D) (subsizeadd(X[(D)],-1),tr.Ins(X[(D)],(D)),cur+=V[(D)])

struct NODE{int fi,se;};
struct Stack{
    NODE st[N*3];
    int top; int size(){return top;}void pop(){top--;}
    void push(NODE x){st[++top]=x;}
    NODE Top(){return st[top];}
}Opt;
inl void sol(R k,R l,R r){
    //cout<<l<<' '<<r<<":\n";
    R psz=0;
    for(int P:S[k].av){
        R x=X[P],f=nfd[f0(x)];
        //cout<<P<<": ";
        //printf("(f is %d) ",f);
        if(!f){
            InsPeople(P);
            //cout<<"Ins "<<P<<'\n';
            Opt.push({-1,P});++psz;
        }else{
            R sP=tr.ask(1,1,n,dfn[f],dfn[f]+sz[f]-1);
            //printf("(sP is %d) ",sP);
            //printf("(value %d %d)",V[sP],V[P]);
            if(V[sP]<V[P]){
                EraPeople(sP);
                InsPeople( P);
                //cout<<"Era "<<sP<<'\n';
                //cout<<"Ins "<<P<<'\n';
                Opt.push({sP,P});++psz;
            }
        }
        //cout<<"End."<<P<<"\n";
    }
    if(l==r){Ans[l]=cur;}
    else sol(k<<1,l,mid),sol(k<<1|1,mid+1,r);
    while(psz--){
        auto x=Opt.Top();Opt.pop();
        EraPeople(x.se);
        if(~x.fi)InsPeople(x.fi);
    }
}

int main(){
    //freopen("a.in","r",stdin);
    //freopen("a.out","w",stdout);
    in(); V[0]=1e9; n=in(),K=in(),m=in();
    for(R i=2;i<=n;i++)e[in()].pb(i);
    dfs1(1,0),dfs2(1,1); tr.build(1,1,n),Tr.build(1,1,n);
    for(R i=1;i<=K;i++)X[i]=in(),V[i]=in(),lst[i]=0;
    for(R i=1,op,x,y;i<=m;i++){
        if((op=in())==1){
            x=in(),y=in();
            X[++K]=x,V[K]=y,lst[K]=i;
        }
        else{
            x=in();
            Modify(1,0,m,lst[x],i-1,x);
            //printf("People %d: %d %d\n",x,lst[x],i-1);
            lst[x]=m+1;
        }
    }
    for(R i=1;i<=K;i++)
        if(lst[i]<=m)Modify(1,0,m,lst[i],m,i);//,printf("People %d: %d %d\n",i,lst[i],m);
    sol(1,0,m);
    for(R i=0;i<=m;i++) wr(Ans[i]),pc(' ');
    return 0;
}
```

---

## 作者：qiuzx (赞：3)

## 题意

给定一棵 $n$ 个点的有根树，有 $k$ 个人，每个人在点 $u$ 上，有权值 $v$。定义一棵树的价值为所有节点上的人的权值的最大值之和，现在可以将每个人放在其子树内的任意一个点上，求所有方案中树的价值的最大值。有 $m$ 次操作，每次加入一个人或删除一个人，每次操作后询问当前树的最大价值。$n,k,m\le 10^5$。

## 思路

考虑静态问题如何解决。注意到这相当于一个二分图匹配的问题，将人看作左部点，树点看作右部点，则一个人会连向它子树内的所有点，现在要找到一组匹配，使得被选择的人的权值之和最大。直接做可以使用类似模拟费用流的方式用线段树优化至单次 $O(n\log n)$，但如果后面顺着模拟费用流的角度思考比较难以处理这两种操作，因此还需要从别的角度思考。

我们不妨直接考察加入一个人会对匹配造成怎样的变化，其本质上就是找到一条增广路，并将增广路另一侧的点删去，替换成这个点。模拟费用流本质上就是在不断地贪心找下一条增广路上的边，从这个角度做显然是行不通的，因为增广路可能会很长且形态诡异，这意味着我们必须抛弃寻找增广路的想法。需要注意到我们真正替换的点只有一个，所以我们先考察这个点需要满足何种条件。这样其实就和匹配本身没有关系了，因为权值全部在左部点这一侧，那么我们只需要找到一个左部点的子集，满足这个子集在右部点存在一组匹配即可，具体是如何分配的我们并不关心，这样我们就将权值去掉了。二分图匹配的检验显然是霍尔定理，由于树的特殊性质，我们只需要保证每个子树内选取的点的个数都不超过这个子树的大小即可。因此如果我们暴力枚举被替换的点，只需要先将它删去，再将新点插入，判断一下即可。这样就变成了一个比较容易解决的问题，只需要考虑如何维护这一过程。

由于原先的解是合法的，因此删去一个点不会让匹配不合法，可能导致不合法的情况在于插入这个点的时候。因此我们先插入这个点，然后向上找到第一个不合法的点，则我们必须在这个点的子树内选取一个点进行替换。并且显然选取任意一个点都是可以的，因此我们找到子树内权值最小的点即可，我们需要支持的操作就是在一个点上加或删一个元素，使用 set 维护每个点上最小的元素即可将对元素的操作变为单点修改。而找到第一个不合法的点可以通过维护每个点子树大小减去子树内选择点个数来实现，使用树剖+线段树可以做到 $O(n\log^2n)$。找到子树内权值最小的点同样使用树剖+线段树实现，复杂度 $O(n\log^2n)$。

最后还有一个小问题，就是我们只支持了插入一个人，而不支持删除。事实上删除的贡献是难以处理的，因此考虑离线线段树分治将删除转撤销，撤销显然是容易进行的，这样复杂度多一个 $O(\log n)$，总复杂度 $O(n\log^3n)$，可以通过。

---

## 作者：_jimmywang_ (赞：3)

> Extracted from [联合省选记录](https://www.luogu.com.cn/blog/90706/li-nian-xing-xuan-ji-lu)

- ### [P9168 [省选联考 2023] 人员调度](https://www.luogu.com.cn/problem/P9168)

我和贪心势不两立！

删除操作很恶心，先不管。我们先来看不带删除怎么做。

定义一个员工为 $(u,x)$ 表示初始部门是 $u$，能力值是 $x$。

考虑对每个点 $u$ 维护一个员工集合 $S_u$，满足 $\forall u$，$S_u$是初始部门是 $u$ 的员工集合的子集。并且，将所有员工 $(U,x)$ 与其初始部门 $U$ 的子树中所有的点连边，形成一张员工到点的二分图，满足该二分图存在员工的完美匹配。

这样就满足了存在一种题目中的分配（下放）方式，使得所有点上的员工数 $\leq 1$。

相当于不考虑一个方案中没有贡献的点，而根据最优性，题目的一个最优方案一定能和一组 $S_u$ 一一对应。

设 $size_u$ 是 $u$ 的子树大小。

根据 Hall 定理，一个方案满足条件的充要条件是 $\forall u,\sum_{v\in u\text{ 的子树 }}|S_v|\leq size_u$，即子树内保留的员工个数不超过子树大小。

证明感性理解，大概是每个员工子集都拆成不相交子树，然后在一个子树内限制尽量紧，于是把子树内所有的员工算上也要满足。具体不证了（要的话评论加一下）。

记 $left_u=size_u-\sum_{v\in u \text{ 的子树 }}|S_v|$，即 $u$ 的子树内还能放多少个员工。于是方案合法等价于 $\forall u,left_u\geq 0$。

考虑加入一个员工 $(u,x)$ 的影响。

如果直接加入这个员工合法，那么由于加入它会使 $u$ 及其祖先子树中的空位都减少 1，所以要满足 **$u$ 及其祖先的 $left$ 均不为 0**。此时直接在 $u$ 加入这个员工是合法的。那么就果断加入。

但是如果 **$u$ 及其祖先的 $left$ 存在一个点为 0** 呢？

那我们如果要加入这个员工，必定要踢掉一个。我们找到 $u$ 及其祖先中，深度最深且 $left=0$ 的点，记为 $v$。由上面的充要条件得，这个时候必须在 $v$ 的子树内踢掉一个。

于是我们查询 $v$ 的子树内保留的员工的最小值。若用现在这个员工替换他更优，那么我们就踢掉一个最小值，并加入当前员工 $(u,x)$。

至此，不带删的东西做完了。

至于具体实现，我们树剖维护 $left$，操作有链上 $\pm 1$ 和查询链上最小值（及其最深的位置）；而对于员工集合 $S_u$，我们给每个节点开一个 `multiset`，记录员工的能力值集合。即 $w_u$ 为 $u$ 的 `multiset` 中的最小值（就是员工最小能力值），查询子树内员工最小值即为查询区间内 $w$ 的最小值，同样可以树剖。而加入或踢掉员工都可以转化为在 `multiset` 上加数或删数，此时单个点的 $w$ 可能会变化，那么直接在线段树上修改即可。

现复杂度 $O(n\log^2n)$。

好好好，带删怎么办？

离线后发现每个员工的存在时间都是一段区间，果断时间轴上分治，就可以将删除改为撤销。同时我们在树剖上的操作正好都是可撤销的（加 / 减和加入 / 删除），因此完美适配。

至此，我们在 $O(n\log^3n)$ 的复杂度解决了这个问题！

code:

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,a,b) for(ll i=a;i<=b;i++)
inline ll rd(){
    ll x=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c))x=x*10+c-'0',c=getchar();
    return x*f;
}
#define d rd()
ll Sid;
ll n,m,k;
//树剖
ll dfn[100010],sz[100010],son[100010];
ll de[100010],fa[100010],top[100010],rk[100010];
vector<ll>e[100010];
void dfs1(ll u,ll f){
    de[u]=de[f]+1,fa[u]=f;sz[u]=1;
    for(int i=0;i<e[u].size();i++){
        ll v=e[u][i];if(v==f)continue;
        dfs1(v,u);sz[u]+=sz[v];
        if(sz[v]>sz[son[u]])son[u]=v;
    }
}ll TIm;
void dfs2(ll u,ll tp){
    top[u]=tp;dfn[u]=++TIm;rk[TIm]=u;
    if(son[u])dfs2(son[u],tp);
    for(int i=0;i<e[u].size();i++){
        ll v=e[u][i];if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
ll t[100010<<2];//min(size-ssum of empolees)
ll tid[100010<<2];//id of min
ll tg[100010<<2];//tag of t
multiset<ll>st[100010];
ll w[100010<<2];//min value of employees
ll wid[100010<<2];//id of min w
void upd(ll p){
    if(t[rs(p)]<=t[ls(p)])t[p]=t[rs(p)],tid[p]=tid[rs(p)];
    else t[p]=t[ls(p)],tid[p]=tid[ls(p)];
    if(w[rs(p)]<=w[ls(p)])w[p]=w[rs(p)],wid[p]=wid[rs(p)];
    else w[p]=w[ls(p)],wid[p]=wid[ls(p)];
}
void build(ll l,ll r,ll p){
    if(l==r){t[p]=sz[rk[l]];w[p]=0x3f3f3f3f3f3f3f3f;tid[p]=wid[p]=l;return;}
    ll mid=l+r>>1;
    build(l,mid,ls(p));
    build(mid+1,r,rs(p));
    upd(p);
}
void pd(ll p){
    if(!tg[p])return;
    t[ls(p)]+=tg[p],t[rs(p)]+=tg[p];
    tg[ls(p)]+=tg[p],tg[rs(p)]+=tg[p];
    tg[p]=0;
}
void add(ll l,ll r,ll p,ll L,ll R,ll k){
    if(L<=l&&r<=R){t[p]+=k,tg[p]+=k;return;}
    pd(p);ll mid=l+r>>1;
    if(mid>=L)add(l,mid,ls(p),L,R,k);
    if(mid<R)add(mid+1,r,rs(p),L,R,k);
    upd(p);
}
void ch(ll l,ll r,ll p,ll pos,ll k,ll o){
    if(l==r){
        if(o==0)st[l].insert(k);
        else st[l].erase(st[l].find(k));
        if(st[l].size())w[p]=*st[l].begin();
        else w[p]=0x3f3f3f3f3f3f3f3f;return;
    }pd(p);ll mid=l+r>>1;
    if(mid>=pos)ch(l,mid,ls(p),pos,k,o);
    if(mid<pos)ch(mid+1,r,rs(p),pos,k,o);
    upd(p);
}inline pair<ll,ll> Min(pair<ll,ll> a,pair<ll,ll>b){
    if(a.first!=b.first)return min(a,b);
    if(a.second>b.second)return a;return b;
}
pair<ll,ll> mnt(ll l,ll r,ll p,ll L,ll R){
    if(L<=l&&r<=R)return {t[p],tid[p]};
    pd(p);ll mid=l+r>>1;pair<ll,ll>ans={0x3f3f3f3f,0x3f3f3f3f};
    if(mid>=L)ans=Min(ans,mnt(l,mid,ls(p),L,R));
    if(mid<R)ans=Min(ans,mnt(mid+1,r,rs(p),L,R));
    return ans;
}pair<ll,ll> mnw(ll l,ll r,ll p,ll L,ll R){
    if(L<=l&&r<=R)return {w[p],wid[p]};
    pd(p);ll mid=l+r>>1;pair<ll,ll>ans={0x3f3f3f3f,0x3f3f3f3f};
    if(mid>=L)ans=Min(ans,mnw(l,mid,ls(p),L,R));
    if(mid<R)ans=Min(ans,mnw(mid+1,r,rs(p),L,R));
    return ans;
}

void addch(ll u,ll v,ll k){
    while(top[u]!=top[v]){
        if(de[top[u]]<de[top[v]])swap(u,v);
        add(1,n,1,dfn[top[u]],dfn[u],k);
        u=fa[top[u]];
    }if(dfn[u]>dfn[v])swap(u,v);
    add(1,n,1,dfn[u],dfn[v],k);
}
pair<ll,ll> chmnt(ll u,ll v){
    pair<ll,ll>ans={0x3f3f3f3f,0x3f3f3f3f};
    while(top[u]!=top[v]){
        if(de[top[u]]<de[top[v]])swap(u,v);
        ans=Min(ans,mnt(1,n,1,dfn[top[u]],dfn[u]));
        u=fa[top[u]];
    }if(dfn[u]>dfn[v])swap(u,v);
    ans=Min(ans,mnt(1,n,1,dfn[u],dfn[v]));
    return ans;
}
pair<ll,ll> mnw(ll u){
    return mnw(1,n,1,dfn[u],dfn[u]+sz[u]-1);
}ll SUM;

struct node{
    ll u,x;
    ll isf,iss;
    ll pos;
    ll delf,dels;
};
//加入员工
void addemp(node &p,ll u,ll x){
    p.u=u,p.x=x;
    // cout<<"----------------\nadd ("<<u<<","<<x<<")\n";
    pair<ll,ll>is=chmnt(1,u);
    p.isf=is.first,p.iss=is.second;
    if(is.first!=0){
        // cout<<"all ancectors are unfull.\n";
        SUM+=x;ch(1,n,1,dfn[u],x,0);addch(1,u,-1);
        return;
    }ll pos=rk[is.second];p.pos=pos;
    // cout<<"nearst full ancestor is "<<pos<<endl;

    pair<ll,ll>del=mnw(pos);
    p.delf=del.first,p.dels=del.second;
    if(del.first>x)return;
    // cout<<"min value of emploees: ("<<rk[del.second]<<","<<del.first<<")\n";
    if(del.first)addch(1,rk[del.second],1),ch(1,n,1,del.second,del.first,1);
    SUM-=del.first;SUM+=x;ch(1,n,1,dfn[u],x,0);
    addch(1,u,-1);
}
ll U[200010],X[200010];
struct ask{ll o,x,y;}q[100010];
//线段树分治
vector<ll>tr[100010<<2];
ll Ol[200010],Or[200010];
void ADD(ll l,ll r,ll p,ll L,ll R,ll o){
    if(L<=l&&r<=R){tr[p].push_back(o);return;}
    ll mid=l+r>>1;if(mid>=L)ADD(l,mid,ls(p),L,R,o);
    if(mid<R)ADD(mid+1,r,rs(p),L,R,o);
}

void get(ll l,ll r,ll p){
    vector<node>del;del.clear();
    for(int j=0;j<tr[p].size();j++){
        // cout<<l<<" "<<r<<" "<<p<<" ";
        ll i=tr[p][j];ll u=U[i],x=X[i];
        // cout<<"("<<u<<","<<x<<")\n";
        node o={0,0,0,0,0,0,0};addemp(o,u,x);
        del.push_back(o);
    }
    if(l==r)printf("%lld ",SUM);
    ll mid=l+r>>1;if(l!=r)get(l,mid,ls(p)),get(mid+1,r,rs(p));
    for(int i=del.size()-1;i>=0;i--){
        node o=del[i];ll u=o.u,x=o.x;
        if(o.isf!=0){
            addch(1,u,1);ch(1,n,1,dfn[u],x,1);SUM-=x;
        }else if(o.delf>x)continue;
        else{
            addch(1,u,1);
            SUM+=o.delf;SUM-=x;ch(1,n,1,dfn[u],x,1);   
            if(o.delf)addch(1,rk[o.dels],-1),ch(1,n,1,o.dels,o.delf,0);
        }
    }
}
int main(){
    // freopen("transfer15.in","r",stdin);
    // freopen("transfer.out","w",stdout);
    Sid=d;n=d,k=d,m=d+1;
    f(i,2,n)e[d].push_back(i);
    dfs1(1,0),dfs2(1,1);build(1,n,1);
    f(i,1,k)Ol[i]=1,Or[i]=m,U[i]=d,X[i]=d;
    f(i,2,m){
        ll o=d;if(o==1){
            ll u=d,x=d;q[i]={o,u,x};k++;
            U[k]=u,X[k]=x,Ol[k]=i,Or[k]=m;
        }else{
            ll x=d;q[i]={o,x,0};
            Or[x]=i-1;
        }
    }
    f(i,1,k)ADD(1,m,1,Ol[i],Or[i],i);
    get(1,m,1);
    return 0;
}
```

---

## 作者：zzxLLL (赞：2)


省选留下的坑。

---

因为是横着输出的，所以考虑离线所有操作。

注意到有删除操作，直接线段树分治。现在需要考虑的，就是怎么加入员工。

对于一颗子树，贪心地将那些工作能力强的人分配到不同节点，能力弱的人被能力强的人覆盖掉，没有贡献。这样正确性显然，问题在于如何维护这一过程。

设 $siz_u$ 为 $u$ 的子树大小，$f_u$ 为 $u$ 的子树共容纳了几个员工。注意这里不是优秀员工个数，而是如果人数超出子树大小，那么就去掉一些能力值低的人。

容易得到 $f_u = \min(siz_u, \sum\limits_{v \in son_u} f_v + cnt_u)$，其中 $cnt_u$ 是部门 $u$ 的优秀员工个数。

当插入一个人 $(x, v)$ 时，找到 $x$ 的最深的，满足 $f_y = siz_y$ 的祖先。当将 $(x, v)$ 插入，必然导致 $y$ 的子树人数多出一个。假设 $y$ 先前容纳的人的集合为 $S_y$，显然当 $|S_y| = siz_y$。只需要踢掉 $S_y$ 中能力值最小的一个人即可。

如果找不到 $f_y = siz_y$ 的祖先，说明不会有人被踢掉，直接加上 $v$ 的贡献即可。

万一去掉的员工，不能通过其祖先部门的员工补上怎么办？事实上不会发生这种情况，因为这种情况说明还有更深的满足 $siz_y = f_y$ 的祖先。

然后考虑插入一个人 $(x, v)$ 对于 $f$ 的影响。对于 $x$ 的祖先 $y$，都有 $f_y \gets f_y + 1$。如果导致有人被踢掉，假设这个人是 $z$，那么对于所有 $z$ 的祖先 $y'$，有 $f_{y'} \gets f_{y'} - 1$。

线段树分治不仅要加人，还要撤销。事实上反着操作就好，对于原来进来的 $x$，$f_y \gets f_y - 1$。如果有 $z$ 被踢出去了，就把它加回来，$f_{y'} \gets f_{y'} + 1$。

回顾上述过程，就是要实现：

- 从 $x$ 到 $1$ 路径加，维护 $siz_y - f_y$。

- $x$ 到 $1$ 路径查询值为 $0$，且深度最深的节点。

- 子树中的最小值，子树的每个节点都是一个员工的集合，支持单点加人删人。

对于 $1, 2$ 点，直接树剖解决即可。

对于第 $3$ 点，直接在每个节点维护一个 ``set`` ，每次加人删人直接对 ``set`` 操作，然后将线段树对应的叶子节点修改为新的 ``set`` 的最小值即可。

---

要开 ``long long``。~~``set`` 不能直接重定义 ``int`` 类型比较，不然会 ``WA on #31``~~。其实是可以的，但是要比较编号。

```cpp
#include<set>
#include<cstdio>
#include<vector>
#include<utility>
#define int long long
const int M=3e5+10;
const int inf=1e17+7;

/*-----------------------------------------------------------*/

int sid,n,K,m;
std::vector<int>g[M];
int Alive[2][M];

int p[M],siz[M],dep[M],son[M];
void dfs1(int u){
	dep[u]=dep[p[u]]+1;
	siz[u]=1;
	for(int v:g[u]){
		dfs1(v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])
			son[u]=v;
	}
}
int dfn[M],rev[M],top[M],idx;
void dfs2(int u,int t){
	top[u]=t;
	dfn[u]=++idx;
	rev[idx]=u;
	if(!son[u]) return;
	dfs2(son[u],t);
	for(int v:g[u])
		if(v!=son[u]) dfs2(v,v);
}

int L[M<<2],R[M<<2];

/*-----------------------------------------------------------*/

struct Slave{
	int pos,ability;
}Staff[M];

struct SlaveCmp{
	bool operator()(const int &A,const int &B)const{
		return Staff[A].ability<Staff[B].ability
		||(Staff[A].ability==Staff[B].ability&&A<B);
	}
};

std::set<int,SlaveCmp>AbilitySet[M];

#define lc(k) (k<<1)
#define rc(k) (k<<1|1)

int MinAbility[M<<2];
void Pushup(int k){
	int ls=MinAbility[lc(k)];
	int rs=MinAbility[rc(k)];
	if(!ls)
		MinAbility[k]=rs;
	else if(!rs)
		MinAbility[k]=ls;
	else if(Staff[ls].ability<Staff[rs].ability)
		MinAbility[k]=ls;
	else
		MinAbility[k]=rs;
}
void NewSlave(int k,int p,int id){
	if(L[k]==R[k]){
		AbilitySet[p].insert(id);
		MinAbility[k]=(*AbilitySet[p].begin());
		return;
	}
	int mid=(L[k]+R[k])>>1;
	if(p<=mid) NewSlave(lc(k),p,id);
	else NewSlave(rc(k),p,id);
	Pushup(k);
}
void KillSlave(int k,int p,int id){
	if(L[k]==R[k]){
		AbilitySet[p].erase(id);
		if(!AbilitySet[p].size())
			MinAbility[k]=0;
		else
			MinAbility[k]=(*AbilitySet[p].begin());
		return;
	}
	int mid=(L[k]+R[k])>>1;
	if(p<=mid) KillSlave(lc(k),p,id);
	else KillSlave(rc(k),p,id);
	Pushup(k);
}
int FindIncapable(int k,int l,int r){
	if(l<=L[k]&&R[k]<=r)
		return MinAbility[k];
	int mid=(L[k]+R[k])>>1;
	if(r<=mid)
		return FindIncapable(lc(k),l,r);
	else if(l>mid)
		return FindIncapable(rc(k),l,r);
	else{
		int ls=FindIncapable(lc(k),l,r);
		int rs=FindIncapable(rc(k),l,r);
		if(!ls)
			return rs;
		else if(!rs)
			return ls;
		else if(Staff[ls].ability<Staff[rs].ability)
			return ls;
		else
			return rs;
	}
}

/*-----------------------------------------------------------*/

typedef std::pair<int,int> Pii;
#define Rin first
#define Len second

Pii EmptySeat[M<<2];
int Lazyadd[M<<2];
// {Emptyseat, Department}
void UpPush(int k){
	Pii ls=EmptySeat[lc(k)];
	Pii rs=EmptySeat[rc(k)];
	if(ls.Rin<rs.Rin||(ls.Rin==rs.Rin&&dep[ls.Len]>dep[rs.Len]))
		EmptySeat[k]=ls;
	else
		EmptySeat[k]=rs;
}
void Tag(int k,int v){
	EmptySeat[k].first+=v;
	Lazyadd[k]+=v;
}
void DownPush(int k){
	if(Lazyadd[k]){
		Tag(lc(k),Lazyadd[k]);
		Tag(rc(k),Lazyadd[k]);
		Lazyadd[k]=0;
	}
}

void Build(int k,int l,int r){
	L[k]=l,R[k]=r;
	if(l==r){
		EmptySeat[k]={siz[rev[l]],rev[l]};
		return;
	}
	int mid=(l+r)>>1;
	Build(lc(k),l,mid);
	Build(rc(k),mid+1,r);
	UpPush(k);
}
void Add(int k,int l,int r,int v){
	if(l<=L[k]&&R[k]<=r){
		Tag(k,v);
		return;
	}
	DownPush(k);
	int mid=(L[k]+R[k])>>1;
	if(l<=mid) Add(lc(k),l,r,v);
	if(r>mid)  Add(rc(k),l,r,v);
	UpPush(k);
}
Pii QueryMin(int k,int l,int r){
	if(l<=L[k]&&R[k]<=r)
		return EmptySeat[k];
	DownPush(k);
	int mid=(L[k]+R[k])>>1;
	if(r<=mid)
		return QueryMin(lc(k),l,r);
	else if(l>mid)
		return QueryMin(rc(k),l,r);
	else{
		Pii ls=QueryMin(lc(k),l,r);
		Pii rs=QueryMin(rc(k),l,r);
		if(ls.Rin<rs.Rin||(ls.Rin==rs.Rin&&dep[ls.Len]>dep[rs.Len]))
			return ls;
		else
			return rs;
	}
}

void AddtoPath(int x,int v){
	while(x){
		Add(1,dfn[top[x]],dfn[x],v);
		x=p[top[x]];
	}
}
Pii QueryonPath(int x){
	Pii ret={inf,0};
	while(x){
		Pii tmp=QueryMin(1,dfn[top[x]],dfn[x]);
		if(tmp.Rin<ret.Rin||(tmp.Rin==ret.Rin&&dep[tmp.Len]>dep[ret.Len]))
			ret=tmp;
		x=p[top[x]];
	}
	return ret;
}

/*-----------------------------------------------------------*/

std::vector<int>Employee[M<<2];
void NewEmployee(int k,int l,int r,int L,int R,int id){
	if(L<=l&&r<=R){
		Employee[k].push_back(id);
		return;
	}
	int mid=(l+r)>>1;
	if(L<=mid) NewEmployee(lc(k),l,mid,L,R,id);
	if(R>mid)  NewEmployee(rc(k),mid+1,r,L,R,id);
}

struct Event{
	int in,out;
}Stack[M];
int CntEvent;

int SumofAbility;
bool Interview(int id){
	Pii tmp=QueryonPath(Staff[id].pos);
	if(tmp.Rin>0){
		Stack[++CntEvent]={id,0};
		NewSlave(1,dfn[Staff[id].pos],id);
		AddtoPath(Staff[id].pos,-1);
		SumofAbility+=Staff[id].ability;
		return true;
	}else{
		int Pos=tmp.Len;
		if(!Pos){
			Staff[++CntEvent]={id,0};
			NewSlave(1,dfn[Staff[id].pos],id);
			AddtoPath(Staff[id].pos,-1);
			SumofAbility+=Staff[id].ability;
			return true;
		}else{
			int Victim=FindIncapable(1,dfn[Pos],dfn[Pos]+siz[Pos]-1);
			if(Staff[Victim].ability<Staff[id].ability){
				Stack[++CntEvent]={id,Victim};
				KillSlave(1,dfn[Staff[Victim].pos],Victim); // He deserves it LOL
				AddtoPath(Staff[Victim].pos,1);
				NewSlave(1,dfn[Staff[id].pos],id);
				AddtoPath(Staff[id].pos,-1);
				SumofAbility+=Staff[id].ability-Staff[Victim].ability;
				return true;
			}
		}
	}
	return false;
}

void DFS(int k,int l,int r){
	int tot=0;
	for(int i:Employee[k])
		tot+=Interview(i);
	if(l==r){
		printf("%lld ",SumofAbility);
	}else{
		int mid=(l+r)>>1;
		DFS(lc(k),l,mid);
		DFS(rc(k),mid+1,r);
	}
	for(;tot;tot--){
		int x=Stack[CntEvent].in;
		int y=Stack[CntEvent].out;
		KillSlave(1,dfn[Staff[x].pos],x);
		AddtoPath(Staff[x].pos,1);
		SumofAbility-=Staff[x].ability;
		if(y!=0){
			NewSlave(1,dfn[Staff[y].pos],y);
			AddtoPath(Staff[y].pos,-1);
			SumofAbility+=Staff[y].ability;
		}
		CntEvent--;
	}
}

/*-----------------------------------------------------------*/

signed main(){
	scanf("%lld",&sid);
	scanf("%lld%lld%lld",&n,&K,&m);
	for(int i=2;i<=n;i++) scanf("%lld",&p[i]);
	for(int i=2;i<=n;i++) g[p[i]].push_back(i);
	dfs1(1);
	dfs2(1,1);
	Build(1,1,n);
	
	for(int i=1;i<=K;i++){
		scanf("%lld%lld",&Staff[i].pos,&Staff[i].ability);
		Alive[0][i]=0;
		Alive[1][i]=m;
	}
	for(int i=1,opt,x,y;i<=m;i++){
		scanf("%lld",&opt);
		if(opt==1){
			scanf("%lld%lld",&x,&y);
			Staff[++K]={x,y};
			Alive[0][K]=i;
			Alive[1][K]=m;
		}else{
			scanf("%lld",&x);
			Alive[1][x]=i-1;
		}
	}
	
	for(int i=1;i<=K;i++)
		NewEmployee(1,0,m,Alive[0][i],Alive[1][i],i);
	DFS(1,0,m);
	return 0;
}
```

---

## 作者：eastcloud (赞：2)

看题目，如果没有修改的话不难想到一个贪心：把员工按照能力值排序，如果子树内还有空间就放进去，而为了避免安排员工的操作，我们把这里的“放”当做把当前节点储存的员工加一，查询的时候直接查询子树内的总员工。

可以证明这样的操作是正确的，只要是由这种操作构造的解法一定有一种安排方法，而一种合法的安排方法也一定可以以这种形式表示，而排序操作保证了最优性，因为没放进来的肯定整个子树所有数的能力值都比他高。

那带修改了怎么办呢，多次修改再采取这个操作的时间复杂度是 $O(nq)$ 的，发现排序和重新操作是我们的最大障碍，我们得考虑抛离了排序怎么做，考虑加入一个员工会对整颗树造成什么影响，类似上一步，只要子树内有空间无脑放，没空间就找子树内最小的扔出来再把它放进去。

又发现这个操作我们刚好可以通过树链剖分加上线段树实现，那剩下的就只剩删除操作了，发现每个员工有固定的出现时间段，直接套路转成线段树分治，时间复杂度 $O(n\log^3 n)$。

---

## 作者：talent_wei (赞：1)

## 一、前言

感觉好多题解都看不懂，讲的不太清楚，故写一个自认为比较清晰的题解。

## 二、题意描述

给定一个以 1 为根的树，还有 k 个人，每个人有一个属性 $(u,v)$ ，表示这个人只可以放在 u 的子树内，且这个人的能力值是 v。请你安排一种安放人员的方法（可以有人不在树上），使得任意一个节点上最多只有一个人。最大化 $\sum v$ 。有 m 次询问，每次加入 / 删除一个人。 请你对这些询问依次回答。

## 三、solution

### 一种想法

首先我们发现不管怎么样我们都需要求解出初始情况下的 ans ，故我们考虑怎么在初始情况下求解该问题。一个很直接的想法是把人员按照能力值从大到小排序，然后随意放置。但是这个贪心明显是假的，因为我们在随便放的时候不知道会不会影响后面的人（也就是从祖先放的时候有可能影响到 ta 的后代）。我们反过来想，类比树形 DP ，从叶子开始放，然后如果 u 的子树没有被填满就直接放初始时候在 u 的员工，否则找一个子树内能力值最小的一个替换掉（如果替换掉更优）。这个贪心正确性显然。我们考虑我们在做什么：实际上我们是维护了一个桶，设 $a_i$ 是放在 i 上的员工的能力值，我们其实就是在 dfs 的过程中不断找当前子树的最小值然后更新。具体实现上，我们可以按照 dfs 序建立线段树，然后每次询问子树最小值，更新单点值。 

那么加上加入和删除呢？加入我们就暴力加入，删除可以看作把一个员工的能力值将为 0 ，所以我们每次操作完后都进行一次询问。单次询问复杂度 $O(nlogn)$ ，总体时间复杂度 $O(nlogn+nmlogn)$ ，得分 48pts 。

code ：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define LL __int128
#define pii pair < int , int >
#define mp(i, j) make_pair(i, j)
#define l(o) (o << 1)
#define r(o) (o << 1 | 1)
#define mid (l + r >> 1)

const int N = 2e5 + 5, M = 262200;
int sid, n, k, m, v[N], dfn[N], e[N], tot;
vector < int > G[N], per[N];
ll sum;

int mn[M], pl[M];

void pushup(int o) { 
	mn[o] = min(mn[l(o)], mn[r(o)]); 
	pl[o] = mn[l(o)] < mn[r(o)] ? pl[l(o)] : pl[r(o)];
}

void build(int o, int l, int r) {
	mn[o] = 0, pl[o] = l;
	if(l == r) return;
	build(l(o), l, mid), build(r(o), mid + 1, r);
	pushup(o);
}

void add(int o, int l, int r, int p, int x) {
	if(l == r) {
		mn[o] = max(mn[o], x);
		return;
	}
	if(p <= mid) add(l(o), l, mid, p, x);
	else add(r(o), mid + 1, r, p, x);
	pushup(o);
}

pii querymin(int o, int l, int r, int ql, int qr) {
	if(ql <= l && r <= qr) return mp(mn[o], pl[o]);
	pii ans = mp(1e9, 0);
	if(ql <= mid) ans = min(ans, querymin(l(o), l, mid, ql, qr));
	if(qr > mid) ans = min(ans, querymin(r(o), mid + 1, r, ql, qr));
	return ans;
}

void getdfn(int u) {
	dfn[u] = ++ tot;
	for(int to : G[u]) getdfn(to);
	e[u] = tot;
}

void solve(int u) {
	for(int to : G[u]) solve(to);
	for(int p : per[u]) {
		pii res = querymin(1, 1, n, dfn[u], e[u]);
		int x = res.first, y = res.second;
		if(v[p] <= x) continue;
		sum -= x, sum += v[p];
		add(1, 1, n, y, v[p]);
	}
}

int main() {
	cin >> sid >> n >> k >> m;
	for(int i = 2, fa; i <= n; i++) {
		cin >> fa;
		G[fa].push_back(i);
	}
	for(int i = 1, p; i <= k; i++) {
		cin >> p >> v[i];
		per[p].push_back(i);
	}
	getdfn(1), build(1, 1, n), solve(1);
	cout << sum << " ";
	for(int i = 1; i <= m; i++) {
		build(1, 1, n);
		int op, x, y;
		cin >> op >> x;
		if(op == 1) {
			cin >> y;
			v[++ k] = y;
			per[x].push_back(k);
		} else v[x] = 0;
		sum = 0, solve(1);
		cout << sum << " ";
	} 
	return 0;
}

```

##### 正解

实在是想不到啊，看了题解才会。

我们发现上述算法的瓶颈就是后续的 m 个操作。依据我们的贪心，我们不得不从下到上考虑，而这样的约束让我们在只有一个人这样非常少的信息改变的时候束手无策。容易想到不断全局查询是一个非常蠢的做法，因为我们做了大量的重复或者说不必要的计算。

所以我们需要发掘更好的性质。考虑特殊性质：没有第二种操作。如果我们只需要加入，那么会不会有什么很好的性质呢？

我们约定没有被放置的员工被称为被淘汰。一个非常显然的性质：如果一个人被淘汰了，那么再加入一些人他也不可能复活。这可以通过 48 pts 的构造方法得证。也就是我们只需要考虑现在分配到树上的人的取舍即可。

我们现在要在 u 上新增一个员工。

我们模拟贪心的过程，考虑 u 的 offer 是被谁抢了，一种可能就是被 u 子树内一个能力值没有 u 大的人给替了，还有就是被上面的人本不应该抢他的人给抢了。所以对于这两种情况我们进行讨论。如果是被后代抢了我们就暴力替换，否则就把上面的那个人给扔到 ta 的原始节点上。于是乎我们就变成了一个递归的问题。什么时候停止呢？当一个节点 x 使得 x 中的 offer 没有外援的时候就没有办法向上扔了。这时候就只能找一个子树内最小的进行替换。画图发现这个点 x 就是距离 u 最近的满足没有外援的祖先。

所以我们发现其实最后对答案的新贡献就是把新人加进去了，然后把一个最小值扔出去了。那么很明显只需要最小化这个最小值即可。这时候我们发现 x 显然就是我们可以取到最小值的这个祖先。所以我们每次只需要询问距离 u 的最近的没有外援的 x 并且询问 x 的子树最小值即可。

我们定义 $size_x$ 是 x 的子树大小， $s_x$ 是 x 子树中 offer 的原始节点都是 x 子树内的数量，那么 x 就是距离 u 最近的 $size_x = s_x$ 的节点。故我们维护 $size_x - s_x$ 。每次减去最小值以后就把最小值所在原始节点到根的路径的维护值都加上 1 。然后 u 到根减去 1 。可以用树链剖分处理。

还没完，因为我们都是在 $size_x = s_x$ 的节点上进行查询最小值，所以我们的子树最小值就是所有以 x 子树内的节点为初始节点的人员的最小能力值。我们在每个点上维护一个 ``` multiset``` 即可。线段树维护最小值。

至于删除，我们使用线段树分治，把所有的上述操作反着操作一遍就可以撤销了。

注意当 x 不存在时需要特判。可以证明，当不存在 x 的时候一定可以通过某些操作使得 u 放置是 0 代价的。 query 函数的剪枝非常重要。

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define LL __int128
#define pii pair < int , int >
#define mp(i, j) make_pair(i, j)
#define size Size
#define l(o) (o << 1)
#define r(o) (o << 1 | 1)
#define mid (l + r >> 1)

const int N = 2e5 + 5, M = 4e5 + 5;
const int INF = 1e9;
int sid, n, m, k, las[N], p[N], v[N];
ll Ans[N];
int dfn[N], e[N], rk[N], tot, size[N], son[N], top[N], fa[N];
vector < int > G[N], vec[M];
multiset < int > st[N];

void dfs(int u) {
	size[u] = 1;
	for(int to : G[u]) {
		dfs(to);
		size[u] += size[to];
		if(size[to] >= size[son[u]]) son[u] = to;
	}
}

void dfs1(int u, int x) {
	top[u] = x;
	dfn[u] = ++ tot, rk[tot] = u;
	if(son[u]) dfs1(son[u], x);
	for(int to : G[u]) 
		if(to != son[u]) dfs1(to, to);
	e[u] = tot;
}

int sum[M], tag[M]; pii mn[M];
// sum = min(size - s)
// mn -> min(val), real position

void pushup(int o) {
	sum[o] = min(sum[l(o)], sum[r(o)]);
	mn[o] = min(mn[l(o)], mn[r(o)]);
}

void pushdown(int o) {
	if(!tag[o]) return;
	tag[l(o)] += tag[o], tag[r(o)] += tag[o];
	sum[l(o)] += tag[o], sum[r(o)] += tag[o];
	tag[o] = 0;
}

void build(int o, int l, int r) {
	if(l == r) {
		sum[o] = size[rk[l]], mn[o] = mp(INF, rk[l]); // ?
		return;
	}	
	build(l(o), l, mid), build(r(o), mid + 1, r);
	pushup(o);
}

void cover(int o, int l, int r, int pos, int x) { // cover min(val)
	if(l == r) {
		mn[o] = mp(x, rk[l]);
		return;
	}
	pushdown(o);
	if(pos <= mid) cover(l(o), l, mid, pos, x);
	else cover(r(o), mid + 1, r, pos, x);
	pushup(o);
}

pii querymin(int o, int l, int r, int ql, int qr) { // query min(val, real)
	if(ql <= l && r <= qr) return mn[o];
	pushdown(o);
	pii ans = mp(INF, 0);
	if(ql <= mid) ans = min(ans, querymin(l(o), l, mid, ql, qr));
	if(qr > mid) ans = min(ans, querymin(r(o), mid + 1, r, ql, qr));
	return ans;
}

void add(int o, int l, int r, int ql, int qr, int x) { // sum + x
	if(ql <= l && r <= qr) {
		sum[o] += x, tag[o] += x;
		return;
	}
	pushdown(o);
	if(ql <= mid) add(l(o), l, mid, ql, qr, x);
	if(qr > mid) add(r(o), mid + 1, r, ql, qr, x);
	pushup(o);
}

int query(int o, int l, int r, int ql, int qr) { // query min(sum)
	if(ql <= l && r <= qr) return sum[o];
	pushdown(o);
	int ans = INF;
	if(ql <= mid) ans = min(ans, query(l(o), l, mid, ql, qr));
	if(qr > mid) ans = min(ans, query(r(o), mid + 1, r, ql, qr));
	return ans;
}

int find0(int o, int l, int r, int ql, int qr) { // real position
	// right  
	if(l == r) return sum[o] == 0 ? rk[l] : 0;
	if(sum[o] > 0) return 0; 
	pushdown(o); 
	int tmp = (qr > mid ? find0(r(o), mid + 1, r, ql, qr) : 0 );
	if(tmp) return tmp;
	return ql <= mid ? find0(l(o), l, mid, ql, qr) : 0;
}

void addtree(int u, int x) {
	while(u) {
		add(1, 1, n, dfn[top[u]], dfn[u], x);
		u = fa[top[u]];
	}
}

int query0(int u) {
	while(u) { // not !query
		if(query(1, 1, n, dfn[top[u]], dfn[u])) u = fa[top[u]];
		else return find0(1, 1, n, dfn[top[u]], dfn[u]);
	}
	return 0;
}

ll ans = 0;

void addt(int o, int l, int r, int ql, int qr, int x) {
	if(ql <= l && r <= qr) {
		vec[o].push_back(x);
		return;
	}
	if(ql <= mid) addt(l(o), l, mid, ql, qr, x);
	if(qr > mid) addt(r(o), mid + 1, r, ql, qr, x);
}

void insert(int x, int y) {
	if(!x || !y) return;
	st[x].insert(y);
	addtree(x, -1);
	cover(1, 1, n, dfn[x], *st[x].begin());
}

void remove(int x, int y) {
	if(!x || !y) return;
	st[x].erase(st[x].lower_bound(y));
	addtree(x, 1);
	cover(1, 1, n, dfn[x], st[x].empty() ? INF : *st[x].begin());
}

struct node {
	int ux, uy, vx, vy;
};

void solve(int o, int l, int r) {
	vector < node > U;
	for(int u : vec[o]) {
		int x = query0(p[u]);
		if(!x) { // 特判 x = 0 
			U.push_back((node) { p[u], v[u], 0, 0 });
			ans += v[u], insert(p[u], v[u]);
			continue;
		}
		pii res = querymin(1, 1, n, dfn[x], e[x]);
		if(res.first >= v[u]) continue;
		U.push_back((node) { p[u], v[u], res.second, res.first });
		ans += v[u], ans -= res.first;
		insert(p[u], v[u]), remove(res.second, res.first);
	}
	if(l == r) Ans[l] = ans;
	else solve(l(o), l, mid), solve(r(o), mid + 1, r);
	reverse(U.begin(), U.end());
	for(node res : U) {
		ans -= res.uy, ans += res.vy;
		remove(res.ux, res.uy), insert(res.vx, res.vy);
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin >> sid >> n >> k >> m;
	for(int i = 2; i <= n; i++) {
		cin >> fa[i];
		G[fa[i]].push_back(i);
	}
	dfs(1), dfs1(1, 1);
	for(int i = 1; i <= k; i++) cin >> p[i] >> v[i];
	for(int i = 1; i <= m; i++) {
		int op, x;
		cin >> op >> x;
		if(op == 1) {
			k ++;
			p[k] = x, cin >> v[k];
			las[k] = i;
		} else {
			addt(1, 0, m, las[x], i - 1, x);
			las[x] = m + 1;
		}
	}
	for(int i = 1; i <= k; i++) 
		if(las[i] <= m) addt(1, 0, m, las[i], m, i);
	build(1, 1, n);
	solve(1, 0, m);
	for(int i = 0; i <= m; i++) cout << Ans[i] << " ";
	return 0;
}
```

---

## 作者：Corzica (赞：1)

按照惯例，先考虑一次的怎么做。

从根节点开始 dfs，从深度更低的节点开始判断能否把子集插入这个子树中，也就是子树内有没有空节点或者节点上权值比我小的点。所有节点均判断一次之后结束，显然是最优解。用线段树维护，可以做到 $n \log n$。

那么我们现在就有了一个 $m(n+m)\log n$ 的做法，能拿到 48pts。

我们现在考虑只有插入操作时的情况，在此状态下，没有被选上的点显然在后面也不可能再回到树上，所以我们只需要考虑树上的信息即可。注意到我们只知道一个节点放了多少个点下来，但是实际上并不知道这个点放下来的玩意在哪。在插入一个点替换的过程中，可能需要调整节点的摆放来使得答案最优。

所以我们实质上不关心每一个点究竟放在哪，我们关心的是能不能放。

所以我们可以很自然有一个想法。我们每一次向上找最深的一个点，满足子树内内每一个点放的数的和等于子树大小，那么我们就可以用这个点来替换掉这个子树内最小的点。考虑正确性，我们不能再向上找因为找到的最小值不一定在这个子树内，如果在子树外的话将无法通过调换使得所有点都能放。而在这个子树下，每一个子树内的点都会满足放的点小于等于子树大小，那么就肯定存在一种方案使得这个东西能放。

考虑怎么设计这个东西，树上的二分可以用树链来做，套线段树维护子树 siz。同时要维护子树内放的东西的最小值，这个可以考虑对每一个点记录员工集合和实际放的个数，然后把这个东西再在线段树上维护，记录位置。总体的复杂度是 $n \log^2 n$。

我们现在只考虑了插入操作，而删除操作可以直接套一个线段树分治。这样一个插入操作最多转化为 $\log n$ 个插入操作，总体复杂度 $n \log^3 n$。

究极无敌大常数代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int type, n, m, k, dfn[100005], cnt, ccnt, siz[100005], top[100005], sson[100005], cts, ma[100005], now, d[100005], fa[100005];
long long ans, aans[400005];
multiset<int> s[100005];
vector<int> son[100005];
struct person {
	int l, r, name, num;
} a[200005];
inline void dfs(int p) {
	siz[p] = 1;
	for (int i : son[p]) {
		d[i] = d[p] + 1;
		dfs(i);
		siz[p] += siz[i];
		if (siz[i] > siz[sson[p]]) sson[p] = i;
	}
}
inline void ddfs(int p, int ffa) {
	top[p] = ffa;
	dfn[p] = ++cts;
	ma[cts] = p;
	if (sson[p]) {
		ddfs(sson[p], ffa);
		for (int i : son[p]) {
			if (i != sson[p]) ddfs(i, i);
		}
	}
}
struct node {
	int l, r;
	vector<pair<int, int>> v;
} t[400005];
vector<pair<int, int>> ca[400005];
vector<pair<int, pair<int, int>>> ins[400005];
inline void build(int p, int l, int r, vector<person> v) {
	t[p].l = l, t[p].r = r;
	vector<person> ll, rr;
	for (person i : v) {
		if (i.l <= l && i.r >= r) {
			t[p].v.push_back(make_pair(i.name, i.num));
		} else if (i.r <= ((l + r) >> 1)) {
			ll.push_back(i);
		} else if (i.l > ((l + r) >> 1)) {
			rr.push_back(i);
		} else {
			ll.push_back(person{i.l, (l + r) >> 1, i.name, i.num});
			rr.push_back(person{((l + r) >> 1) + 1, i.r, i.name, i.num});
		}
	}
	if (l == r) return;
	build(2 * p, l, (l + r) >> 1, ll);
	build(2 * p + 1, ((l + r) >> 1) + 1, r, rr);
}
struct nodes {
	int l, r, mina, minb, minna, minnb, tag;
} b[400005];
inline void update(int p) {
	if (b[2 * p].mina < b[2 * p + 1].mina) {
		b[p].mina = b[2 * p].mina;
		b[p].minb = b[2 * p].minb;
	} else {
		b[p].mina = b[2 * p + 1].mina;
		b[p].minb = b[2 * p + 1].minb;
	}
	if (b[2 * p].minna < b[2 * p + 1].minna) {
		b[p].minna = b[2 * p].minna;
		b[p].minnb = b[2 * p].minnb;
	} else {
		b[p].minna = b[2 * p + 1].minna;
		b[p].minnb = b[2 * p + 1].minnb;
	}
}
inline void builds(int p, int l, int r) {
	b[p].l = l, b[p].r = r;
	if (l == r) {
		b[p].mina = 0, b[p].minb = ma[l];
		b[p].minna = 0, b[p].minnb = ma[l];
		return;
	}
	builds(2 * p, l, (l + r) >> 1);
	builds(2 * p + 1, ((l + r) >> 1) + 1, r);
	update(p);
}
inline void push_down(int p) {
	if (b[p].tag != 0) {
		b[2 * p].tag += b[p].tag;
		b[2 * p + 1].tag += b[p].tag;
		b[2 * p].mina += b[p].tag;
		b[2 * p + 1].mina += b[p].tag;
		b[p].tag = 0;
	}
}
inline pair<int, int> query(int p, int l, int r) {
	if (b[p].l >= l && b[p].r <= r) {
		return make_pair(b[p].mina, b[p].minb);
	}
	int mid = (b[p].l + b[p].r) >> 1;
	push_down(p);
	if (r <= mid) return query(2 * p, l, r);
	else if (l > mid) return query(2 * p + 1, l, r);
	pair<int, int> op = query(2 * p, l, mid), ops = query(2 * p + 1, mid + 1, r);
	if (op.first < ops.first) return op;
	return ops;
}
inline pair<int, int> qquery(int p, int l, int r) {
	if (b[p].l >= l && b[p].r <= r) {
		return make_pair(b[p].minna, b[p].minnb);
	}
	int mid = (b[p].l + b[p].r) >> 1;
	push_down(p);
	if (r <= mid) return qquery(2 * p, l, r);
	else if (l > mid) return qquery(2 * p + 1, l, r);
	pair<int, int> op = qquery(2 * p, l, mid), ops = qquery(2 * p + 1, mid + 1, r);
	if (op.first < ops.first) return op;
	return ops;
}
inline void add(int p, int l, int r, int w) {
	if (b[p].l >= l && b[p].r <= r) {
		b[p].tag += w, b[p].mina += w;
		return;
	}
	push_down(p);
	int mid = (b[p].l + b[p].r) >> 1;
	if (r <= mid) add(2 * p, l, r, w);
	else if (l > mid) add(2 * p + 1, l, r, w);
	else add(2 * p, l, mid, w), add(2 * p + 1, mid + 1, r, w);
	update(p);
}
inline void change(int p, int q, int w) {
	if (b[p].l == b[p].r) {
		b[p].minna = w;
		return;
	}
	push_down(p);
	int mid = (b[p].l + b[p].r) >> 1;
	if (q <= mid) change(2 * p, q, w);
	else  change(2 * p + 1, q, w);
	update(p);
}
inline void add(int p, int w, int flg = 1) {
	if ( flg) ca[now].push_back(make_pair(p, w));
	int q = top[p];
	while (p) {
		add(1, dfn[q], dfn[p], w);
		p = fa[q];
		q = top[p];
	}
}
inline int query(int p) {
	pair<int, int> op;
	int q = top[p];
	while (p) {
		op = query(1, dfn[q], dfn[p]);
		if (op.first == 0) return op.second;
		p = fa[q], q = top[p];
	}
	return 1;
}
inline void erase(int p) {
	ins[now].push_back(make_pair(p, make_pair(*s[p].begin(), -1)));
	s[p].erase(s[p].begin());
	if (s[p].size()) {
		change(1, dfn[p], *s[p].begin());
	} else {
		change(1, dfn[p], 0x3f3f3f3f);
	}
}
inline void clear() {
	for (auto i : ca[now]) {
		add(i.first, -i.second, 0);
	}
	pair<int, pair<int, int>> op;
	for (int i = ins[now].size() - 1; i >= 0; i--) {
		op = ins[now][i];
		if (op.second.second == -1) {
			s[op.first].insert(op.second.first);
			if (s[op.first].size()) {
				change(1, dfn[op.first], *s[op.first].begin());
			} else {
				change(1, dfn[op.first], 0x3f3f3f3f);
			}
		} else {
			s[op.first].erase(s[op.first].find(op.second.first));
			if (s[op.first].size()) {
				change(1, dfn[op.first], *s[op.first].begin());
			} else {
				change(1, dfn[op.first], 0x3f3f3f3f);
			}
		}
	}
	ans = aans[now];
}
inline void insert(int p, int q) {
	int ops = query(p);
	pair<int, int> w = qquery(1, dfn[ops], dfn[ops] + siz[ops] - 1);
	if (w.first < q) {
		ans += q - w.first;
		erase(w.second);
		add(w.second, 1);
		add(p, -1);
		s[p].insert(q);
		ins[now].push_back(make_pair(p, make_pair(q, 1)));
		change(1, dfn[p], *s[p].begin());
	}
}
inline void solve(int p) {
	now = p;
	aans[now] = ans;
	for (auto i : t[p].v) {
		insert(i.first, i.second);
	}
	if (t[p].l != t[p].r) {
		solve(2 * p);
		now = p;
		solve(2 * p + 1);
		now = p;
		clear();
	} else {
		cout << ans << " ";
		now = p;
		clear();
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> type >> n >> k >> m;
	int p, q, op;
	for (int i = 2; i <= n; i++) {
		cin >> p;
		fa[i] = p;
		son[p].push_back(i);
	}
	for (int i = 1; i <= k; i++) {
		cin >> p >> q;
		a[++cnt].num = q;
		a[cnt].name = p;
		a[cnt].l = 1;
	}
	vector<person> v;
	ccnt = 1;
	for (int i = 1; i <= m; i++) {
		++ccnt;
		cin >> op;
		if (op == 1) {
			cin >> p >> q;
			a[++cnt].num = q;
			a[cnt].name = p;
			a[cnt].l = ccnt;
		} else {
			cin >> p;
			a[p].r = ccnt - 1;
		}
	}
	for (int i = 1; i <= cnt; i++) {
		if (a[i].r == 0) a[i].r = ccnt;
		v.push_back(a[i]);
	}
	d[1] = 1;
	dfs(1);
	ddfs(1, 1);
	builds(1, 1, n);
	for (int i = 1; i <= n; i++) s[i].insert(0);
	build(1, 1, ccnt, v);
	solve(1);
}
```

---

## 作者：blackname (赞：1)

超级无敌炫酷原神大王题目。

先考察对于一些员工，它们是不是可以不重复的放到这棵树里。

抽象成一个二分图匹配模型，将每个员工与所在子树的所有点连边，所有员工都能放下等价于此二分图有完美匹配，由 hall 定理，等价于任意一个员工的子集 $S$ 都能匹配到至少 $|S|$ 个顶点。把 $S$ 中的员工所在的子树分成一堆互不相交的子树，容易发现条件等价于每个这样的子树都满足条件，为了让条件尽量紧，应该把所有该子树内的员工都选上。

综上，一个员工集合可以放到树里等价于对于任何一棵子树，该子树内的员工树都不超过该子树大小。

接下来考虑 $m=0$ 怎么做。

直接将员工按照 $v$ 从大到小加入，如果能放进去就放，放不进去就不管他，动态维护每个子树内还能放多少员工，可以通过树剖做到 $O(n\log^2 n)$ 的复杂度。

但是原问题看起来很不能从大到小加入，所以我们还需要一个支持随机加入的算法。

首先，如果加入该员工后当前员工集合仍然满足条件，那么肯定是直接加进去。如果不满足条件，说明该员工所在节点 $u$ 有一个祖先对应的子树已经放满了，那我们找到限制最紧的子树 $v$，即最深的放满的祖先，看看这个子树内都放了哪些员工，并把其中权值最小的员工拿出来，如果当前员工替换掉这个员工更优秀，那么就替换掉，否则保持不变。容易发现被替换的这个员工不可能再替换掉其它员工，因此这个贪心策略是正确的。这个过程可以使用线段树维护子树内当前权值最小的员工，复杂度仍为单次 $O(\log^2 n)$。

那么对于带删除的原问题，考虑使用线段树分治规避掉删除员工这一操作，代价是复杂度上多一个 $\log$，可以接受。

总复杂度 $O(n\log^3 n)$，可以通过本题，使用全局平衡二叉树维护链加链 $\min$ 可以做到 $O(n\log^2 n)$，意义不大。

---

## 作者：_Ch1F4N_ (赞：0)

给一个只从费用流角度思考问题的做法。

考虑建立最大权可行流模型：

每个人 $(x,v)$ 转化为 $(S,x,1,v)$。

树上每条边定向到叶子，建边 $(u,v,\infty,0)$。

每个点连向汇点也就是 $(x,T,1,0)$。

考虑模拟支持加边的最大权可行流，也就是每次加边后判断有无增广路或者正环，选取其中收益最大的去增广或者消环（正环上所有边取反），假若收益最大的也是负收益就什么都不做。

在本题中，增广路形态一定形如 $S \to x \to y \to T$，收益为 $v$，而注意到正环形态一定如 $S \to x \to y \to S$，这里 $y \to S$ 是因为之前一次 $S \to y$ 的增广形成的反悔边，收益为 $v - v'$，其中 $-v'$ 是 $y \to S$ 的权值，也就是之前的增广路 $S \to y$ 的收益是 $v'$。

于是我们考虑维护树上每条向上的反悔边数量，然后当你加入一个点 $x$ 时会先通过反悔边跳到最上面一个点 $top$，也就是跳一段极长的反悔边数量大于 $0$ 的链，然后假若 $top$ 子树内存在增广路那么其一定比消正环优，那就去增广，否则就在其子树内找到一个 $y \to S$ 边权最大（也就是增广时边权最小）的边去消正环。

然后不管是增广还是消正环，对反悔边数量的影响都是 $x \to y$ 的过程中走的根向边的反悔边数量减少，走的叶向边的反悔边数量增加。

具体的维护就是对于每个点 $y$ 维护 $y \to S$ 最大的边，令这条边权值为 $v_y$，用树剖维护每条向上的反悔边数量，再维护一个子树内的最大 $v_y$ 以及子树内的满足 $x \to T$ 的边有流量的 $x$ 的数量，由于每个 $y$ 可能存在多条 $y \to S$ 的边，所以你可以对每个 $y$ 开个 `multiset` 维护。

撤销的话你考虑外面再套一层线段树分治即可做到 $O(n \log^3 n)$。


```cpp
#include<bits/stdc++.h>
namespace IO{
	const int SIZE=1<<21;
	static char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS=obuf,*oT=oS+SIZE-1;
    int qr;
    char qu[55],c;
    bool f;
	#define getchar() (IO::iS==IO::iT?(IO::iT=(IO::iS=IO::ibuf)+fread(IO::ibuf,1,IO::SIZE,stdin),(IO::iS==IO::iT?EOF:*IO::iS++)):*IO::iS++)
	#define putchar(x) *IO::oS++=x,IO::oS==IO::oT?flush():0
	#define flush() fwrite(IO::obuf,1,IO::oS-IO::obuf,stdout),IO::oS=IO::obuf
	#define puts(x) IO::Puts(x)
	template<typename T>
    inline void read(T&x){
    	for(f=1,c=getchar();c<48||c>57;c=getchar())f^=c=='-';
    	for(x=0;c<=57&&c>=48;c=getchar()) x=(x<<1)+(x<<3)+(c&15); 
    	x=f?x:-x;
    }
    template<typename T>
    inline void write(T x){
        if(!x) putchar(48); if(x<0) putchar('-'),x=-x;
        while(x) qu[++qr]=x%10^48,x/=10;
        while(qr) putchar(qu[qr--]);
    }
    inline void Puts(const char*s){
    	for(int i=0;s[i];i++)
			putchar(s[i]);
		putchar('\n');
	}
	struct Flusher_{~Flusher_(){flush();}}io_flusher_;
}
using IO::read;
using IO::write;
using namespace std;
const int maxn = 1e5+114;
const int inf = 1e9+7;
multiset<int> S[maxn];
pair<int,int> minw[maxn<<2];//子树内每个点 min(S) 的最小值 与取到最小的点 
int tr[maxn<<2];//最小反悔边数量
int tag[maxn<<2];//lazy tag
//维护点 u 向父亲的反悔边
int sum[maxn<<2];//子树内存在到汇点流量的点
vector< pair<int,int> > Ins[maxn<<2];//线段树分治时 (x,p) 点 x 加入能力值为 p 的
int L[maxn],R[maxn],dfncnt,node[maxn];
int sz[maxn],son[maxn],top[maxn],fa[maxn],dep[maxn];
int X[maxn<<1],V[maxn<<1],Lt[maxn<<1],k,n,m,id;
long long answer[maxn];
vector<int> E[maxn];
void pushup(int cur){
    tr[cur]=min(tr[cur<<1],tr[cur<<1|1]);
}
void pushdown(int cur){
    if(tag[cur]!=0){
        tag[cur<<1]+=tag[cur];
        tag[cur<<1|1]+=tag[cur];
        tr[cur<<1]+=tag[cur];
        tr[cur<<1|1]+=tag[cur];
        tag[cur]=0;
    }
}
int found(int cur,int lt,int rt,int l,int r){
    if(rt<l||r<lt) return -1;
    if(l<=lt&&rt<=r){
        if(sum[cur]==0) return -1;
        while(lt!=rt){
            int mid=(lt+rt)>>1;
            if(sum[cur<<1]==0) cur=(cur<<1|1),lt=mid+1;
            else cur=(cur<<1),rt=mid;
        }
        return node[lt];
    }
    int mid=(lt+rt)>>1;
    int res=found(cur<<1,lt,mid,l,r);
    if(res!=-1) return res;
    else return found(cur<<1|1,mid+1,rt,l,r);
}
void addfree(int cur,int lt,int rt,int pos,int c){
    if(lt==rt){
        sum[cur]+=c;
        return ;
    }
    int mid=(lt+rt)>>1;
    if(pos<=mid) addfree(cur<<1,lt,mid,pos,c);
    else addfree(cur<<1|1,mid+1,rt,pos,c);
    sum[cur]=sum[cur<<1]+sum[cur<<1|1];
}
int askmin(int cur,int lt,int rt,int l,int r){
    if(rt<l||r<lt) return inf;
    if(l<=lt&&rt<=r) return tr[cur];
    pushdown(cur);
    int mid=(lt+rt)>>1;
    return min(askmin(cur<<1,lt,mid,l,r),askmin(cur<<1|1,mid+1,rt,l,r));
}
int findmax(int cur,int lt,int rt,int l,int r){
	if(rt<l||r<lt) return inf;
	if(l<=lt&&rt<=r){
		if(tr[cur]>0) return inf;
		while(lt!=rt){
			pushdown(cur);
			int mid=(lt+rt)>>1;
			if(tr[cur<<1|1]==0) lt=mid+1,cur=(cur<<1|1);
			else rt=mid,cur=(cur<<1);
		}
		return node[lt];
	}
	pushdown(cur);
	int mid=(lt+rt)>>1;
	int res=findmax(cur<<1|1,mid+1,rt,l,r);
	if(res<inf) return res;
	else return findmax(cur<<1,lt,mid,l,r);
}
int jump(int u){
    while(askmin(1,1,n,L[top[u]],L[u])>0&&fa[top[u]]!=0){
        u=fa[top[u]];
    }
    if(askmin(1,1,n,L[u],L[u])==0||u==1) return u;
    return findmax(1,1,n,L[top[u]],L[u]);
}
int to(int u,int v){
    //u 跳到 v 下面第一个点
    if(u==v) return -1;
    while(top[u]!=top[v]){
        if(fa[top[u]]==v) return top[u];
        u=fa[top[u]];
    }
    return node[L[v]+1];
}
void add(int cur,int lt,int rt,int l,int r,int c){
    if(rt<l||r<lt) return ;
    if(l<=lt&&rt<=r){
        tag[cur]+=c;
        tr[cur]+=c;
        return ;
    }
    pushdown(cur);
    int mid=(lt+rt)>>1;
    add(cur<<1,lt,mid,l,r,c);
    add(cur<<1|1,mid+1,rt,l,r,c);
    pushup(cur);
}
void addlist(int u,int v,int c){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        add(1,1,n,L[top[u]],L[u],c);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    add(1,1,n,L[v],L[u],c);
    return ;
}
void Sdel(int cur,int lt,int rt,int pos,int x){
    if(lt==rt){
        S[node[lt]].erase(S[node[lt]].find(x));
        minw[cur]=make_pair((*S[node[lt]].begin()),node[lt]);
        return ;
    }
    int mid=(lt+rt)>>1;
    if(pos<=mid) Sdel(cur<<1,lt,mid,pos,x);
    else Sdel(cur<<1|1,mid+1,rt,pos,x);
    minw[cur]=min(minw[cur<<1],minw[cur<<1|1]);
}
void Sins(int cur,int lt,int rt,int pos,int x){
    if(lt==rt){
        S[node[lt]].insert(x);
        minw[cur]=make_pair((*S[node[lt]].begin()),node[lt]);
        return ;
    }
    int mid=(lt+rt)>>1;
    if(pos<=mid) Sins(cur<<1,lt,mid,pos,x);
    else Sins(cur<<1|1,mid+1,rt,pos,x);
    minw[cur]=min(minw[cur<<1],minw[cur<<1|1]);
}
pair<int,int> submin(int cur,int lt,int rt,int l,int r){
	if(rt<l||r<lt) return make_pair(inf,-1);
	if(l<=lt&&rt<=r) return minw[cur];
	int mid=(lt+rt)>>1;
	return min(submin(cur<<1,lt,mid,l,r),submin(cur<<1|1,mid+1,rt,l,r));
}
void solve(int cur,int lt,int rt,long long ans){
	stack< pair<int,pair<int,int> > > st;//(w,(u,v)) u,v 链上反悔边加 w
	stack< pair<int,pair<int,int> > > stk;//(ty,(u,x)) S[u] ty = 0 加 ty = 1 删 元素 x
	stack<int> del;//点 u 向汇点流量加 1
    for(pair<int,int> now:Ins[cur]){
        int x=now.first,p=now.second;
        int sub=jump(x);
        int son=found(1,1,n,L[sub],R[sub]);
        if(son!=-1){
            ans+=p;
            Sins(1,1,n,L[x],p);
            stk.push(make_pair(1,make_pair(x,p)));
            addfree(1,1,n,L[son],-1);
            del.push(son);   
            int tp=to(son,sub);                
            if(tp!=-1){
            	addlist(son,tp,1);
            	st.push(make_pair(-1,make_pair(son,tp)));
			}
			tp=to(x,sub);
			if(tp!=-1){
				addlist(x,tp,-1);
				st.push(make_pair(1,make_pair(x,tp)));
			}
			//x to LCA(x,son) 反悔边减少 LCA(x,son) to son 反悔边增加 
        }else{
        	pair<int,int> res=submin(1,1,n,L[sub],R[sub]);
        	if(p>res.first){
        		int u=res.second;
        		ans-=res.first;
        		Sdel(1,1,n,L[u],res.first);	
        		stk.push(make_pair(0,make_pair(u,res.first)));
        		ans+=p;
            	Sins(1,1,n,L[x],p);
            	stk.push(make_pair(1,make_pair(x,p)));
        		int tp=to(u,sub);
            	if(tp!=-1){
            		addlist(u,tp,1);
            		st.push(make_pair(-1,make_pair(u,tp)));
				}
				tp=to(x,sub);
				if(tp!=-1){
					addlist(x,tp,-1);
					st.push(make_pair(1,make_pair(x,tp)));
				}		
				//x to LCA(x,u) 反悔边减少 LCA(x,u) to u 反悔边增加 
			}
		}
    }
    if(lt==rt){
    	answer[lt]=ans;
	}else{
		int mid=(lt+rt)>>1;
		solve(cur<<1,lt,mid,ans);
		solve(cur<<1|1,mid+1,rt,ans);
	}
	while(st.size()>0){
		int w=st.top().first,u=st.top().second.first,v=st.top().second.second;
		addlist(u,v,w);
		st.pop();
	}
	while(stk.size()>0){
		int ty=stk.top().first,u=stk.top().second.first,x=stk.top().second.second;
		if(ty==0) Sins(1,1,n,L[u],x);
		else Sdel(1,1,n,L[u],x);
		stk.pop();
	}
	while(del.size()>0){
		int u=del.top();
		addfree(1,1,n,L[u],1);
		del.pop();
	}
}
void Insert(int cur,int lt,int rt,int l,int r,int x,int p){
	if(rt<l||r<lt) return ;
	if(l<=lt&&rt<=r){
		Ins[cur].push_back(make_pair(x,p));
		return ;
	}
	int mid=(lt+rt)>>1;
	Insert(cur<<1,lt,mid,l,r,x,p);
	Insert(cur<<1|1,mid+1,rt,l,r,x,p);
}
void dfs1(int u){
	sz[u]=1;
	for(int v:E[u]){
		if(v!=fa[u]){
			fa[v]=u;
			dep[v]=dep[u]+1;
			dfs1(v);
			sz[u]+=sz[v];
			if(sz[v]>sz[son[u]]) son[u]=v;
		}
	}
}
void dfs2(int u,int tp){
	L[u]=++dfncnt;
	node[dfncnt]=u;
	top[u]=tp;
	if(son[u]!=0) dfs2(son[u],tp);
	for(int v:E[u]){
		if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
	}
	R[u]=dfncnt;
}
int main(){
	read(id);
	read(n);
	read(k);
	read(m);
	for(int i=2;i<=n;i++){
		int u,v;
		u=i;
		read(v);
		E[u].push_back(v);
		E[v].push_back(u);
	}
	dfs1(1);
	dfs2(1,1);
	for(int i=1;i<=n;i++) Sins(1,1,n,i,inf);
	for(int i=1;i<=n;i++) addfree(1,1,n,i,1);
	for(int i=1;i<=k;i++){
		read(X[i]);
		read(V[i]);
		Lt[i]=0;
	}
	for(int i=1;i<=m;i++){
		int opt;
		read(opt);
		if(opt==1){
			k++;
			read(X[k]);
			read(V[k]);
			Lt[k]=i;
		}else{
			int id;
			read(id);
			if(Lt[id]<i){
				Insert(1,0,m,Lt[id],i-1,X[id],V[id]);
			}
			Lt[id]=-1;
		}
	}
	for(int i=1;i<=k;i++){
		if(Lt[i]>=0){
			Insert(1,0,m,Lt[i],m,X[i],V[i]);
		}
	}
	solve(1,0,m,0);
	for(int i=0;i<=m;i++) write(answer[i]),putchar(' ');
	return 0;
}
```

---


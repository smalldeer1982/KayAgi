# 「JZOI-1」拜神

## 题目背景

新年快到了，小僖和爸爸妈妈上山拜神，祈求新一年的好气运。

## 题目描述

小僖要拜的神一共有 $n$ 个，小僖对每个神的信仰可以用一个小写字母表示，信仰排在一起形成了一个从标号 $1$ 开始的字符串 $s$。 

小僖需要祈祷词来拜神，定义一段祈祷词为一个长度大于零的 $s$ 的连续子串，祈祷词的长度为这个子串的长度。由于拜神只需要小僖有着一定的认真度，所以一种祈祷词只要出现两次就可以被称之为有效的。

**注意：只要子串出现的位置开头不同，中间有重复部分也没有问题**。 

但是由于还有爸爸妈妈的存在，小僖的祈祷词有时会被干扰而打断，所以只有区间 $[l,r]$ 的字符串（即 $s[l\dots r]$）有效。为了未雨绸缪，小僖将会对可能的情况进行精心准备。  

他会给出 $q$ 次询问，每次询问将给定 $l,r$，询问区间 $[l,r]$ 的最长的有效祈祷词的长度。

## 说明/提示

#### 样例解释：  
对于第一次询问：区间内的字符串为 $\texttt{ababa}$，其中子串 $\texttt{aba}$ 出现了两次，长度为 $3$ 。  
对于第二次询问：区间内的字符串为 $\texttt{dababab}$，其中子串 $\texttt{abab}$ 出现了两次，长度为 $4$ 。  
对于第三次询问：区间内的字符串为 $\texttt{ababdc}$，其中子串 $\texttt{ab}$ 出现了两次，长度为 $2$ 。  
对于第四次询问：区间内的字符串为 $\texttt{babdc}$，其中子串 $\texttt{b}$ 出现了两次，长度为 $1$ 。  
对于第五次询问：区间内的字符串为 $\texttt{cdab}$，无出现至少两次的子串，答案为 $0$ 。  

#### 数据范围：    
对于 $5\%$ 的数据，$n,q\le50$。  
对于 $15\%$ 的数据，$n,q\le200$。  
对于 $30\%$ 的数据，$n,q\le2\times10^3$。  
对于 $40\%$ 的数据，$n,q\le5\times10^3$。  
对于 $65\%$ 的数据，$n,q\le2\times 10^4$。  
对于另外 $5\%$ 的数据，满足所有的字符都相等。  
对于 $100\%$ 的数据，$1 \le n\le5\times10^4$，$1 \le q \le 10^5$。  

## 样例 #1

### 输入

```
10 5
cdabababdc
3 7
2 8
5 10
6 10
1 4
```

### 输出

```
3
4
2
1
0
```

# 题解

## 作者：Alex_Wei (赞：30)

### [P7361「JZOI-1」拜神](https://www.luogu.com.cn/problem/P7361)

不错的题目。

建出 $s$ 的后缀数组，考虑一次询问的本质。对于长度 $L$，它合法当且仅当存在两个位置 $p, q \in [l, r - L + 1](p\neq q)$，使得 $lcp(suf_p, suf_q)\geq L$。根据套路，$p, q$ 满足该条件当且仅当若将所有 $\geq L$ 的 $ht_i$ 值对应的两个位置 $sa_{i - 1}$ 与 $sa_i$ 之间连边，则 $p, q$ 在同一连通块。

显然答案满足可二分性，因此着眼于判断一个长度 $L$ 是否合法。借鉴品酒大会的技巧，我们求出 $ht$ 数组后从大到小加入并查集，相当于每次合并两个位置 $sa_{i - 1}, sa_i$。对于每个长度 $L$，在线段树 $T_L$ 上记录每个位置 $p$ 的后继 $suc_p$，表示 $suc_p$ 是大于 $p$ 且和 $p$ 在相同连通块的最小位置。判断合法只需查询 $T_L$ 上 $[l, r - L]$ 的区间最小值是否 $\leq r - L + 1$。

考虑如何维护 $suc_p$：启发式合并。为并查集的每个代表元维护一个 `set` $S_i$，每次往 $S_i$ 中插入一个数 $y$，`lower_bound` 查询 $y$ 的后继 $su$ 与前驱 $pr$，在线段树上更新 $suc_{pr} \gets y$ 且 $suc_y \gets su$。由于要储存每个长度的线段树，所以可持久化。

时空复杂度均为线性对数平方。算法是 **在线** 的。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int N = 5e4 + 5;
int n, q, id[N];
char s[N];
int sa[N], rk[N], ork[N], buc[N], ht[N];
bool cmp(int a, int b, int w) {return ork[a] == ork[b] && ork[a + w] == ork[b + w];}
void build() {
  int m = 1 << 7, p = 0;
  for(int i = 1; i <= n; i++) buc[rk[i] = s[i]]++;
  for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
  for(int i = n; i; i--) sa[buc[rk[i]]--] = i;
  for(int w = 1; ; w <<= 1, m = p, p = 0) {
    for(int i = n - w + 1; i <= n; i++) id[++p] = i;
    for(int i = 1; i <= n; i++) if(sa[i] > w) id[++p] = sa[i] - w;
    memset(buc, 0, sizeof(buc));
    memcpy(ork, rk, sizeof(rk));
    p = 0;
    for(int i = 1; i <= n; i++) buc[rk[id[i]]]++;
    for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
    for(int i = n; i; i--) sa[buc[rk[id[i]]]--] = id[i];
    for(int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
    if(p == n) break;
  }
  for(int i = 1, k = 0; i <= n; i++) {
    if(k) k--;
    while(s[i + k] == s[sa[rk[i] - 1] + k]) k++;
    ht[rk[i]] = k;
  }
}
int node, R[N], ls[N << 8], rs[N << 8];
unsigned short val[N << 8];
void build(int l, int r, int &x) {
  x = ++node, val[x] = -1;
  if(l == r) return;
  int m = l + r >> 1;
  build(l, m, ls[x]), build(m + 1, r, rs[x]);
}
vector<pair<int, int>> chg; // make_pair(pos, val)
void modify(int pre, int &x, int l, int r) {
  if(chg.empty() || chg.back().first > r) return;
  assert(l <= chg.back().first);
  x = ++node, ls[x] = ls[pre], rs[x] = rs[pre];
  if(l == r) {
    val[x] = chg.back().second;
    chg.pop_back();
    return;
  }
  int m = l + r >> 1;
  modify(ls[pre], ls[x], l, m);
  modify(rs[pre], rs[x], m + 1, r);
  val[x] = min(val[ls[x]], val[rs[x]]);
}
int query(int l, int r, int ql, int qr, int x) {
  if(ql > qr || !x) return N;
  if(ql <= l && r <= qr) return val[x];
  int m = l + r >> 1, ans = N;
  if(ql <= m) ans = query(l, m, ql, qr, ls[x]);
  if(m < qr) ans = min(ans, query(m + 1, r, ql, qr, rs[x]));
  return ans;
}

int fa[N], upd[N], cnt;
set<int> S[N];
int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
void update(int pos, int val) {
  if(!upd[pos]) id[++cnt] = pos;
  upd[pos] = val;
}
void merge(int x, int y) {
  x = find(x), y = find(y);
  if(S[x].size() < S[y].size()) swap(x, y);
  fa[y] = x;
  for(int it : S[y]) {
    auto pt = S[x].lower_bound(it);
    if(pt != S[x].end()) update(it, *pt);
    if(pt != S[x].begin()) update(*--pt, it);
    S[x].insert(it);
  }
  set<int> ().swap(S[y]);
}

bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
#ifdef ALEX_WEI
  freopen("1.in", "r", stdin);
  freopen("1.out", "w", stdout);
#endif
  scanf("%d%d%s", &n, &q, s + 1);
  build();
  build(1, n, R[n]);
  static pair<int, int> p[N];
  for(int i = 1; i <= n; i++) fa[i] = i, S[i].insert(i);
  for(int i = 1; i < n; i++) p[i] = {ht[i + 1], i + 1};
  sort(p + 1, p + n);
  for(int i = n - 1, pt = n - 1; i; i--) {
    cnt = 0, chg.clear();
    while(pt && p[pt].first == i) {
      int q = p[pt].second;
      merge(sa[q - 1], sa[q]), pt--;
    }
    sort(id + 1, id + cnt + 1);
    for(int i = cnt; i; i--) chg.push_back({id[i], upd[id[i]]}), upd[id[i]] = 0;
    if(chg.empty()) R[i] = R[i + 1];
    else modify(R[i + 1], R[i], 1, n);
  }
  for(int i = 1; i <= q; i++) {
    int ql, qr;
    scanf("%d%d", &ql, &qr);
    int l = 0, r = qr - ql;
    while(l < r) {
      int m = l + r + 2 >> 1;
      if(query(1, n, ql, qr - m, R[m]) <= qr - m + 1) l = m;
      else r = m - 1;
    }
    printf("%d\n", l);
  }
  return 0;
}
/*
2022/6/16
start coding at 12:36
finish debugging at 13:08
*/
```

---

## 作者：蒟蒻君HJT (赞：11)

我做法还挺简单的，可能是大家没想到，所以觉得这题很难吧。

询问的本质是 $\displaystyle\max_{l\leq i_1<i_2\leq r}\min(i_1-l+1,\operatorname{LCS}(i_1,i_2))$，即枚举两个串的右端点。称 $(i_1,i_2)$ 为一个右端点对。

先对原串建立 SAM。考虑每个结点上的子串对询问 $(l,r)$ 的贡献。假设这个结点代表的最长子串长度为 $len$，$endpos$ 集合从小到大排序后为 $e_1,e_2,\cdots e_k$，则**可能**对答案有贡献的后缀只有相邻的 $e_i$。更进一步来说，我们知道 $endpos$ 集合是所有儿子结点的 $endpos$ 集合的并集再并上这个结点自身可能带有的 $1$ 个 $endpos$。假设我们在用 set 的合并模拟这个过程，可以发现每次往当前集合 $S$ 加入一个元素 $x$ 后，设 $S$ 中 $x$ 的前驱为 $p_1$ 和 $x$ 的后继为 $p_2$，新增加的对答案**可能**有贡献的右端点对只有 $(p_1,x)$ 和 $(x,p_2)$，数量 $\leq 2=O(1)$。

所以我们用 set 的启发式合并来做，总共得到的可能有用的右端点对的数量是 $O(n\log n)$，并且所有右端点对可以用一个三元组 $(i_1,i_2,\operatorname{LCS}(i_1,i_2)),i_1<i_2$ 来描述。对于询问 $(l,r)$，首先需要 $i_2\leq r$，然后分两种情况：

（1） $i_1-\operatorname{LCS}(i_1,i_2)+1\geq l$，此时该三元组对答案的贡献是 $\max(\cdot,\operatorname{LCS}(i_1,i_2))$。

（2） $i_1-\operatorname{LCS}(i_1,i_2)+1<l$，此时该三元组对答案的贡献是 $\max(\cdot,i_1-l+1)$。

把询问离线下来，按 $r,i_2$ 排序从小扫到大，（1）（2）分别用线段树维护 $i_1-\operatorname{LCS}(i_1,i_2)+1$ 位于某个区间中时 $\operatorname{LCS}(i_1,i_2)$ 的最大值和 $i_1$ 的最大值就行了。没有什么技巧的的扫描线。

时间复杂度 $\Theta(n\log^2 n)$。

---

## 作者：wcyQwQ (赞：6)

思路不是很难的一个题。

首先我们考虑二分答案，假设当前二分的结果是 $L$，那么就相当于询问是否存在 $i, j \in [l, r - L+1], \text{LCP}(i, j) \ge L$，维护每个位置前面第一个和它 $\text{LCP} \ge L$ 的位置，记为 $pre_{L, i}$，就转换为 $\max_{i \in [l, r - L +1]} pre_{L, i} \ge l$。

现在我们的问题就在于如何去维护 $pre_{L, i}$，我们考虑从 $pre_{L + 1, i}$ 转移到 $pre_{L, i}$, 做一个类似品酒大会的并查集，每个并查集存一些下标，表示这些下标两两 $\text{LCP} \ge L$，合并时启发式合并，不难发现 $pre$ 的变化只有 $O(\log n)$ 个，我们在主席树上单点修改来维护 $pre$，这样复杂度就是 $O(n\log^2n)$ 的，可以通过。

[Code](https://loj.ac/s/1961447)

---

## 作者：绝顶我为峰 (赞：6)

提供一个空间复杂度是 $O(n\log n)$ 的做法。

显然你至少要建个 SAM 出来，然后再考虑怎么做。

看到重复出现的串，容易联想到 $\mathrm{endpos}$ 集合，这是可以在 fail 树上用线段树合并维护的。

考虑一个 $\mathrm{endpos}$ 集合提供的信息，首先可以发现只有集合中相邻的两个位置才是有用的，然后考虑相邻两个位置 $l,r$ 的贡献。

如果 fail 树上当前点 $k$ 对应的串长度是 $len_k$，那么 $l,r$ 相当于对左端点在 $[1,l-len_k+1]$，右端点在 $[r,n]$ 中的询问有贡献，如果每个点的 $len$ 都只有一个的话我们只需要在线段树合并 push_up 的时候把左区间最靠右的位置和右区间最靠左的位置的贡献加入平面上即可，这部分如果线段树合并的时候没有进这个点那么他的贡献一定在他 fail 树上的某个子树内的点算过了，而 fail 树保证儿子的 $len$ 大于父亲的 $len$，所以这里再算一遍一定不优，可以忽略。

最后离线扫一遍用线段树套 set 维护答案容易做到 $O(n\log^3n)$。

但是这里有一个问题是，fail 树上一个点事实上代表了串长是 $[len_{fa_k}+1,len_k]$ 这样一组串，其中短的串是长的串的后缀，这个时候直接暴力找出每个矩形复杂度可能退化成 $O(n^2\log^2n)$，就寄了。

继续发掘性质，发现此时 $l,r$ 的贡献可以拆成两部分，一部分是左端点在 $[1,l-len_k]$ 中，右端点在 $[r,n]$ 中的询问，贡献是 $len_k$；另一部分是左端点在 $[l-len_k+1,l]$ 中，右端点在 $[r,n]$ 中的询问，记左端点是 $x$，那么这部分的贡献是 $l+1-x$，是一个一次函数。

前面的常函数也可以看成一次函数，因此我们可以把线段树套 set 换成李超树，然后离线扫描右端点，在李超树上查询左端点处若干一次函数的 $\max$ 即可，由于所有矩形的右端点范围都是一个后缀，所以李超树不用删除，复杂度正确。

李超树要支持区间插入，因此时间复杂度 $O(n\log^3 n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
int n,m,tot,cnt,lst,ch[100001][26],len[100001],link[100001],root[100001],ls[100001*20],rs[100001*20],ans[100001];
pair<int,int> val[100001*20];
vector<int> v[100001];
vector<pair<int,int> > q[100001];
struct func
{
    int a,b;
    int operator ()(const int &x) const
    {
        return a*x+b;
    }
};
struct element
{
    int l,r;
    func w;
    element(int l_,int r_,func w_):
        l(l_),r(r_),w(w_){}
};
vector<element> a[100005];
struct ds
{
    func f[100001<<2];
    inline int ls(int k)
    {
        return k<<1;
    }
    inline int rs(int k)
    {
        return k<<1|1;
    }
    inline void update(int nl,int nr,int l,int r,int k,func p)
    {
        if(l>=nl&&r<=nr)
        {
            int mid=(l+r)>>1;
            if(p(mid)>f[k](mid))
                swap(p,f[k]);
            if(l==r)
                return;
            if(p(l)>f[k](l))
                update(nl,nr,l,mid,ls(k),p);
            if(p(r)>f[k](r))
                update(nl,nr,mid+1,r,rs(k),p);
            return;
        }
        int mid=(l+r)>>1;
        if(nl<=mid)
            update(nl,nr,l,mid,ls(k),p);
        if(nr>mid)
            update(nl,nr,mid+1,r,rs(k),p);
    }
    inline int query(int node,int l,int r,int k)
    {
        int res=f[k](node);
        if(l==r)
            return res;
        int mid=(l+r)>>1;
        if(node<=mid)
            res=max(res,query(node,l,mid,ls(k)));
        else
            res=max(res,query(node,mid+1,r,rs(k)));
        return res;
    }
}T;
inline void init()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
}
inline int read()
{
    int x;
    cin>>x;
    return x;
}
inline void push_up(int k,int w)
{
    if(!ls[k])
        val[k]=val[rs[k]];
    else if(!rs[k])
        val[k]=val[ls[k]];
    else
    {
        val[k]={val[ls[k]].first,val[rs[k]].second};
        if(val[ls[k]].second>w)
            a[val[rs[k]].first].emplace_back(1,val[ls[k]].second-w,func{0,w});
        a[val[rs[k]].first].emplace_back(val[ls[k]].second-w+1,val[ls[k]].second,func{-1,val[ls[k]].second+1});
    }
}
inline int merge(int l,int r,int x,int y,int w)
{
    if(!x||!y)
        return x|y;
    if(l==r)
    {
        val[x]={l,l};
        return x;
    }
    int mid=(l+r)>>1;
    ls[x]=merge(l,mid,ls[x],ls[y],w);
    rs[x]=merge(mid+1,r,rs[x],rs[y],w);
    push_up(x,w);
    return x;
}
inline void update(int node,int l,int r,int &k)
{
    if(!k)
        k=++cnt;
    if(l==r)
    {
        val[k]={l,l};
        return;
    }
    int mid=(l+r)>>1;
    if(node<=mid)
        update(node,l,mid,ls[k]);
    else
        update(node,mid+1,r,rs[k]);
    push_up(k,0);
}
inline void build(int c,int id)
{
    int cur=++tot,p=lst;
    len[cur]=len[lst]+1;
    update(id,1,n,root[cur]);
    lst=cur;
    for(;~p;p=link[p])
        if(!ch[p][c])
            ch[p][c]=cur;
        else
            break;
    if(p==-1)
        return;
    int q=ch[p][c];
    if(len[p]+1==len[q])
    {
        link[cur]=q;
        return;
    }
    int clone=++tot;
    len[clone]=len[p]+1;
    link[clone]=link[q];
    link[cur]=link[q]=clone;
    for(int i=0;i<26;++i)
        ch[clone][i]=ch[q][i];
    for(;~p;p=link[p])
        if(ch[p][c]==q)
            ch[p][c]=clone;
        else
            break;
}
inline void dfs(int k)
{
    for(int i:v[k])
    {
        dfs(i);
        root[k]=merge(1,n,root[k],root[i],len[k]);
    }
}
int main()
{
    init();
    n=read(),m=read();
    link[0]=-1;
    for(int i=1;i<=n;++i)
    {
        char c;
        cin>>c;
        build(c-'a',i);
    }
    for(int i=1;i<=tot;++i)
        v[link[i]].emplace_back(i);
    dfs(0);
    for(int i=1;i<=m;++i)
    {
        int l=read(),r=read();
        q[r].emplace_back(l,i);
    }
    for(int i=1;i<=n;++i)
    {
        for(auto j:a[i])
            T.update(j.l,j.r,1,n,1,j.w);
        for(auto j:q[i])
            ans[j.second]=T.query(j.first,1,n,1);
    }
    for(int i=1;i<=m;++i)
        cout<<ans[i]<<'\n';
    cout.flush();
    return 0;
}
```

---

## 作者：Y_B_X (赞：4)

[原题链接](https://www.luogu.com.cn/problem/P7361)

题意：给定一个字符串，每次询问一段区间中出现两次的最长子串长度。

思路还较清新，先将询问按右端点 $r$ 排序，看对每个询问 $l$ 能怎么方便求出。

将每个 $[1,r]$ 内的子串 $p$ ，其在 $[1,r]$ 中**次后出现的位置**的右端点与左端点看做一条线段 $[s_p,t_p]$。

那对每个 $l$ 只需查出 $\mathrm{Max}\left\{\left(\mathop{\mathrm{Max}}\limits_{s_p\leq l\leq t_p}t_p-l+1\right),\left(\mathop{\mathrm{Max}}\limits_{s_p\geq l}\ t_p-s_p+1\right)\right\}$ 

这相当于是找出覆盖 $l$ 的线段中的**右端点最大值** $-l$ ，与及不覆盖 $l$ 且在 $l$ 右侧的**线段长度**最大值的最大值。

由于对于 $\text{endpos}$ 相同的子串右端点集合相同，且上式需要的线段是越长越好。

于是我们需要的线段仅为 $\text{endpos}$ 相同的串中最长的一个，先想如何更新次右端点。

联系一下[这题](https://www.luogu.com.cn/problem/P6292)，不难得出 $\text{LCT}$ 维护的方法。

就是建出 $\text{parent tree}$ 后记录每个等价类出现位置的最右位置，以及次右位置。

$r$ 向右移时单次 $access$ 更改为了求上式需维护的信息，同时打上将次右值变成最右值，最右值更新为 $r$ 的标记。

剩下的就是考虑上式怎么求出。

首先第二个 $\mathrm{Max}$ 比较好做，因为每个子串的 $s_p$ 单调递增，可以直接将 $[1,s_p]$ 的信息与 $t_p-s_p+1$ 取最大值。

对于第一个 $\mathrm{Max}$ 先考虑没有 $access$ 顺带需要的修改该怎么做。

这可以将每个在 $[s_p,t_p]$ 之间的点，用 $t_p$ 更新能覆盖这个点的线段最大右端点。

观察到每次更改所影响到的线段可视为**向右平移一段区间**，事实上之前的区间取最大值并不会影响之后的查询。

这是因为之后查询的 $l$ 如果在**原先** $t_p$ 之后，就不会影响答案。

而在**原先** $t_p$ 之前的 $l$ 必定会查到右移之后的的**整个字符串**，或者之后的右端点比之前右端点**靠右**。这两种情况分别对应右移前后，是否与原先字符串重合。而这两种情况一定会在第一、二个 $\mathrm{Max}$ 中得出的长度比之前优，会将之前的标记覆盖掉。

于是只需要一个支持区间取 $\mathrm{Max}$ 的数据结构，用线段树容易实现。

最终时间复杂度是 $O(n\log^2n)$ 的。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,m,x,xx,y,tot=1,last=1,tmp,l,r;char ch;
int rot_xx,rot_y,s_i,acs_y,a;bool rot_b;
int mxlen[N],link[N],trans[N][26],f[N],res[N];
int lst[N],lst_[N],son[N][2],anc[N],cov[N];
inline void read(int &x){
	x=0;ch=getchar();while(ch<48||ch>57)ch=getchar();
	while(ch>47&&ch<58)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
void write(int x){if(x>9)write(x/10);putchar(48+x%10);}
#define ls k<<1
#define rs k<<1|1
struct segment_tree{
	int tag[N<<2],res;//这里用了标记永久化实现区间取max，单点查
	void update(int k,int l,int r,int x,int y,int v){
		if(x<=l&&r<=y)tag[k]=max(tag[k],v);
		else {
			int mid=(l+r)>>1;
			if(x<=mid)update(ls,l,mid,x,y,v);
			if(mid<y)update(rs,mid+1,r,x,y,v);
		}
	}
	void inquiry(int k,int l,int r,int pos){
		res=max(res,tag[k]);
		if(l^r){
			int mid=(l+r)>>1;
			if(pos<=mid)inquiry(ls,l,mid,pos);
			else inquiry(rs,mid+1,r,pos);
		}
	}
}S,S_;
inline void extend(int a){
	tmp=++tot;y=last;mxlen[tmp]=mxlen[y]+1;
	for(;y&&!trans[y][a];y=link[y])trans[y][a]=tmp;
	if(!y)link[tmp]=1;
	else {
		x=trans[y][a];
		if(mxlen[x]==mxlen[y]+1)link[tmp]=x;
		else {
			xx=++tot;mxlen[xx]=mxlen[y]+1;link[xx]=link[x];
			memcpy(trans[xx],trans[x],sizeof(trans[xx]));
			for(;y&&trans[y][a]==x;y=link[y])trans[y][a]=xx;
			link[tmp]=link[x]=xx;
		}
	}
	last=tmp;
}
inline bool nroot(int x){return son[anc[x]][0]==x||son[anc[x]][1]==x;}
inline bool p(int x){return son[anc[x]][1]==x;}
inline void cov_(int x,int v){lst_[x]=lst[x];lst[x]=cov[x]=v;}
//将次右变为最右，最右由覆盖标记更新
inline void pushdown(int x){
	if(cov[x]){
		if(son[x][0])cov_(son[x][0],cov[x]);
		if(son[x][1])cov_(son[x][1],cov[x]);
		cov[x]=0;
	}
}
void pushall(int x){if(nroot(x))pushall(anc[x]);pushdown(x);}
inline void rotate(int x){
	rot_y=anc[x];rot_xx=anc[rot_y];rot_b=p(x);
	if(nroot(rot_y))son[rot_xx][p(rot_y)]=x;
	anc[x]=rot_xx;
	anc[son[rot_y][rot_b]=son[x][!rot_b]]=rot_y;
	anc[son[x][!rot_b]=rot_y]=x;
}
inline void splay(int x){
	pushall(x);
	for(;s_i=anc[x],nroot(x);rotate(x))if(nroot(s_i))rotate(p(x)==p(s_i)?s_i:x);
}
inline void access(int x,int pos){
	for(y=0;x;y=x,x=anc[x]){
		splay(x);son[x][1]=y;
		l=lst[x]-mxlen[x]+1;r=lst[x];//l,r 为这个整个子串将要移动到的区间
		if(lst[x]&&x^1)S.update(1,1,n,l,r,r),S_.update(1,1,n,1,l,r-l+1);
	}//这里access由于每次是之前跳父亲来的，能保证x一定是当前splay中mxlen最大的
	cov_(y,pos);
}
int to[N],nextn[N],h[N],id[N],edg;
inline void add(int x,int y,int i){to[++edg]=y,nextn[edg]=h[x],h[x]=edg;id[edg]=i;}
main(){
	read(n);read(m);while(ch<97)ch=getchar();
	register int i,j;
	for(i=1;i<=n;++i)a=ch-97,extend(a),f[i]=tmp,ch=getchar();
	for(i=1;i<=tot;++i)anc[i]=link[i];
	for(i=1;i<=m;++i)read(x),read(y),add(y,x,i);
	for(i=1;i<=n;++i){
		access(f[i],i);
		for(j=h[i];j;j=nextn[j]){
			S.res=S_.res=0;
			S.inquiry(1,1,n,to[j]);
			S_.inquiry(1,1,n,to[j]);
			res[id[j]]=max(S.res-to[j]+1,S_.res);
		}
	}
	for(i=1;i<=m;++i)write(res[i]),putchar('\n');
}
```


---

## 作者：_ANIG_ (赞：3)

[传送门](https://www.luogu.com.cn/problem/P7361)

首先把操作离线下来，右移右端点，维护左端点的答案。

考虑右端点移动会对答案造成什么影响。

设当前右端点为 $r$，显然只需要考虑所有右端点为 $r$ 的子串。

建 SAM，对于 SAM 上的每个点，维护 $lst_i$ 表示 $i$ 代表的字符串的右端点最后出现的位置。

考虑当 $lst_i$ 从 $a$ 修改为 $b$ 时对答案产生的影响。

设 $mx$ 为这个点对应的最长的字符串的长度， $mn$ 为最短的长度，则任意的 $l\in[a-mx+1,a-mn+1]$，区间 $[l,a]$ 都多出现了一次。

把这些贡献算上即可。

这样每次修改就是让一个区间和一个等差数列取最大值，这个用线段树就能维护。

如果不知道咋维护直接上李超树也是可以的。

这样暴力修改复杂度是 $O(n^2\log n)$ 的。

此时这个题和[区间本质不同子串个数 ](https://www.luogu.com.cn/problem/P6292)几乎一样。

维护一个 LCT，满足每个实链上所有点的 $lst$ 都相等。

由于只有一个地方需要用到 access，并且操作过后就会把 access 出来的实链全部赋值成一个数，所以上述的性质是成立的。

这样就可以只在 access 合并的时候给一条实链整体算贡献，复杂度降到了 $O(n\log^2n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5,inf=1e9;
int n,w[N],wz[N],m,rs[N],ls[N];
namespace tr{
    struct node{
        int l,r,laz,sm;
    }p[4*N];
    void reset(int x,int l,int r){
        p[x].l=l,p[x].r=r;p[x].laz=-1e9;
        if(l==r)return;
        int mid=l+r>>1;
        reset(x<<1,l,mid);
        reset(x<<1|1,mid+1,r);
    }
    void add(int x,int sm){
        p[x].laz=max(p[x].laz,sm);
    }
    void add(int x,int l,int r,int sm){
        if(l>r)return;
        if(l<=p[x].l&&r>=p[x].r){
            add(x,sm);
            return;
        }
        int mid=p[x].l+p[x].r>>1;
        if(r<=mid)add(x<<1,l,r,sm);
        else if(l>mid)add(x<<1|1,l,r,sm);
        else{
            add(x<<1,l,mid,sm);
            add(x<<1|1,mid+1,r,sm-(mid-l+1));
        }
    }
    void adds(int x,int l,int r,int sm){
        if(l>r)return;
        if(l<=p[x].l&&r>=p[x].r){
            p[x].sm=max(p[x].sm,sm);
            return;
        }
        int mid=p[x].l+p[x].r>>1;
        if(l<=mid)adds(x<<1,l,r,sm);
        if(r>mid)adds(x<<1|1,l,r,sm);
    }
    int gets(int x,int d){
        if(p[x].l==p[x].r)return max(p[x].laz,p[x].sm);
        if(d<=(p[x].l+p[x].r>>1))return max({gets(x<<1,d),p[x].laz-(d-p[x].l),p[x].sm});
        else return max({gets(x<<1|1,d),p[x].laz-(d-p[x].l),p[x].sm});
    }
}
namespace lct{
    int son[N][2],fa[N],laz[N],mn[N],mx[N],vn[N],vm[N],val[N];
    void upset(int x){
        mn[x]=min({vn[x],mn[son[x][0]],mn[son[x][1]]});
        mx[x]=max({vm[x],mx[son[x][0]],mx[son[x][1]]});
    }
    void sets(int x,int sm){
        val[x]=sm;
        laz[x]=sm;
    }
    void dnset(int x){
        if(laz[x]){
            sets(son[x][0],laz[x]);
            sets(son[x][1],laz[x]);
            laz[x]=0;
        }
    }
    int ir(int x){
        return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;
    }
    int gt(int x){
        return x==son[fa[x]][1];
    }
    void rotate(int x){
        int y=fa[x],a=gt(x),b=gt(y);
        if(!ir(y))son[fa[y]][b]=x;
        son[y][a]=son[x][a^1];son[x][a^1]=y;
        fa[x]=fa[y];fa[y]=x;
        if(son[y][a])fa[son[y][a]]=y;
        upset(y);upset(x);                                                      
    }
    void upt(int x){
        if(!ir(x))upt(fa[x]);
        dnset(x);
    }
    void splay(int x){
        upt(x);
        while(!ir(x)){
            if(!ir(fa[x]))rotate(gt(x)==gt(fa[x])?fa[x]:x);
            rotate(x);
        }
    }
    void access(int x,int k){
        for(int y=0;x;y=x,x=fa[x]){
            splay(x);
            son[x][1]=0;
            upset(x);
            tr::add(1,val[x]-mx[x]+1,val[x]-mn[x]+1,mx[x]);
            tr::adds(1,1,val[x]-mx[x],mx[x]);
            son[x][1]=y;upset(x);
        }
    }
    void solve(int x,int y){
        access(x,y);
        splay(x);
        sets(x,y);
    }
}
struct node{
    int son[26],fa,lth;
}p[N];
int lst,idx,siz[N],res;
int add(int c){
    int nw=++idx,ps=lst;
    p[nw].lth=p[lst].lth+1;lst=nw;
    siz[nw]=1;
    for(;ps&&!p[ps].son[c];ps=p[ps].fa)p[ps].son[c]=nw;
    if(!ps){
        p[nw].fa=1;
        return nw;
    }
    int qs=p[ps].son[c];
    if(p[qs].lth==p[ps].lth+1){
        p[nw].fa=qs;
        return nw;
    }
    p[++idx]=p[qs];
    p[idx].lth=p[ps].lth+1;
    p[qs].fa=idx,p[nw].fa=idx;
    for(;ps&&p[ps].son[c]==qs;ps=p[ps].fa)p[ps].son[c]=idx;
    return nw;
}
string s;
vector<pair<int,int> >g[N];
signed main(){
    idx=lst=1;
    cin>>n>>m>>s;
    for(int i=1;i<=m;i++){
        int l,r;
        scanf("%lld%lld",&l,&r);
        g[r].push_back(make_pair(l,i));
    }
    tr::reset(1,-n,n);
    for(int i=1;i<=n;i++)w[i]=s[i-1]-'a';
    for(int i=1;i<=n;i++)wz[i]=add(w[i]);
    for(int i=2;i<=idx;i++)lct::fa[i]=p[i].fa;
    for(int i=1;i<=idx;i++)lct::vn[i]=p[p[i].fa].lth+1,lct::vm[i]=p[i].lth;
    lct::mn[0]=inf;
    for(int i=1;i<=n;i++)lct::upset(i);
    for(int i=1;i<=n;i++){
        lct::solve(wz[i],i);
        for(int j=0;j<g[i].size();j++){
            pair<int,int>c=g[i][j];
            rs[c.second]=tr::gets(1,c.first);
        }
    }
    for(int i=1;i<=m;i++)printf("%lld\n",rs[i]);
}
```


---

## 作者：_Diu_ (赞：3)

提供一个空间可以线性的离线做法。

首先这个问题比较经典，考虑二分答案 $x$，问题变成检验区间 $[l,r-x+1]$ 这些后缀中 $\text{lcp}$ 的 $\max$，考虑在 `sa` 上维护这个东西。

对于检查 $l,r,x$ 的合法性，一个简单的想法是考虑把 $hei$ 数组上 $\ge x$ 的部分合并，如果区间 $[l,r]$ 中有两个点在一个区间就合法。考虑把 $x$ 从大往小扫，每次合并两个集合启发式合并即可，查询时用数据结构维护每个点在同个集合中标号在它后面的最前面的是哪个，然后我们判断区间 $[l,r]$ 的 $\min$ 是否 $\le r$ 即可。

如果我们采用可持久化线段树维护支持我每次二分之后查询，时空都是 $O(n\log^2n)$。

我们发现空间比较大的原因是我们二分之后的询问是在线做的，我们可以通过离线把可持久化丢掉。

考虑整体二分，然后离线，这样我们处理 $O(\log n)$ 轮，每一轮做 $q$ 个询问。然后这个询问可以离线做。那么我们可以把可持久化丢掉，可以做到 $O(n\log^3n)$ 空间 $O(n)$。这里 $\log^3$ 中是因为每次整体二分完后都需要跑一次启发式合并。

还有一种做法是说离线之后可以莫队做，如果删点可以 $O(1)$ 删，所以可以考虑回滚莫队做到时间 $O(n\sqrt n\log n)$。~~空间 $O(n\log n)$ 瓶颈在处理 rmq 所以可以四毛子。~~这种做法对比上一种更加无脑但时间空间代码难度都更加劣。

$O(n\log^3n)-O(n)$ 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
char s[N];
vector<pair<int,int> > g[N];
namespace SA{
	int m,x[N],y[N],c[N],sa[N],rk[N],hei[N];
	void get_sa(){
		m=131;
		for(int i=1;i<=m;i++)c[i]=0;
		for(int i=1;i<=n;i++)c[x[i]=s[i]]++;
		int l=0;
		for(int i=1;i<=m;i++)c[i]+=c[i-1];
		for(int i=n;i>=1;i--)sa[c[s[i]]--]=i;
		for(int k=1;k<=n;k<<=1){
			int num=0;
			for(int i=n-k+1;i<=n;i++)y[++num]=i;
			for(int i=1;i<=n;i++)if(sa[i]>k)y[++num]=sa[i]-k;
			for(int i=1;i<=m;i++)c[i]=0;
			for(int i=1;i<=n;i++)c[x[i]]++;
			for(int i=2;i<=m;i++)c[i]+=c[i-1];
			for(int i=n;i>=1;i--)sa[c[x[y[i]]]--]=y[i],y[i]=0;
			swap(x,y);
			num=1,x[sa[1]]=1;
			for(int i=2;i<=n;i++){
				if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])x[sa[i]]=num;
				else x[sa[i]]=++num; 
			}
			if(num==n)break;
			m=num;
		}
		for(int i=1;i<=n;i++)rk[sa[i]]=i;
	}
	void get_h(){
		for(int i=1,k=0;i<=n;i++){
			int j=sa[rk[i]-1];k-=(k!=0);
			while(s[i+k]==s[j+k])++k;
			hei[rk[i]]=k;
		}
	}
	void init(){
		get_sa(),get_h();
		for(int i=2;i<=n;i++){
			g[hei[i]].push_back(make_pair(sa[i-1],sa[i]));
		}
	}
}
struct que{
	int l,r,L,R;
}q[N];
struct Que{
	int l,r,id;
};
vector<Que> qr[N];
namespace Seg{
	int mn[N<<2];
	#define ls (o<<1)
	#define rs (o<<1|1)
	void bld(int o,int l,int r){
		mn[o]=N;
		if(l==r)return;
		int mid=l+r>>1;
		bld(ls,l,mid),bld(rs,mid+1,r);
	}
	void upd(int o,int l,int r,int x,int v){
		if(l==r)return void(mn[o]=v);
		int mid=l+r>>1;
		if(x<=mid)upd(ls,l,mid,x,v);
		else upd(rs,mid+1,r,x,v);
		mn[o]=min(mn[ls],mn[rs]);
	}
	int qry(int o,int l,int r,int x,int y){
		if(x<=l&&r<=y)return mn[o];
		int mid=l+r>>1;
		if(y<=mid)return qry(ls,l,mid,x,y);
		if(x>mid)return qry(rs,mid+1,r,x,y);
		return min(qry(ls,l,mid,x,y),qry(rs,mid+1,r,x,y));
	}
}
namespace QFS{
	int fa[N];
	set<int> s[N];
	set<int>::iterator it;
	void mrg(int x,int y){
		x=fa[x],y=fa[y];
		if(s[x].size()<s[y].size())swap(x,y);
		int lst=0;
		for(int p:s[y]){
			it=s[x].lower_bound(p);
			if(it!=s[x].begin()){
				--it;
				if(lst!=*it){
					lst=*it;
					Seg::upd(1,1,n,lst,p);
				}
			}
		}
		for(int p:s[y])s[x].insert(p);
		for(int p:s[y]){
			fa[p]=x;
			it=s[x].upper_bound(p);
			if(it!=s[x].end())Seg::upd(1,1,n,p,*it);
		}
		s[y].clear();
	}
	void solve(){
		Seg::bld(1,1,n);
		for(int i=1;i<=n;i++){
			fa[i]=i,s[i].clear();
			s[i].insert(i);
		}
		for(int i=n;i>=1;i--){
			for(pair<int,int> t:g[i])mrg(t.first,t.second);
			for(Que t:qr[i]){
				if(Seg::qry(1,1,n,t.l,t.r)<=t.r)q[t.id].L=i;
				else q[t.id].R=i;
			}
		}
	}
}
signed main(){
	scanf("%d%d\n%s",&n,&m,s+1);
	SA::init();
	for(int i=1;i<=m;i++){
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].L=0,q[i].R=q[i].r-q[i].l+1;
	}
	for(int t=1;t<=20;t++){
		bool flg=1;
		for(int i=1;i<=n;i++)qr[i].clear();
		for(int i=1;i<=m;i++){
			if(q[i].L+1<q[i].R){
				flg=0;
				int mid=q[i].L+q[i].R>>1;
				qr[mid].push_back({q[i].l,q[i].r-mid+1,i});
			}
		}
		if(flg)break;
		QFS::solve();
	}
	for(int i=1;i<=m;i++)printf("%d\n",q[i].L);
}
```

---

## 作者：xiezheyuan (赞：2)

## 简要题意

给定一个长度为 $n$ 的，仅由小写英文字母构成的字符串 $S$。有 $q$ 次询问，每次询问给出区间 $[l,r]$，你需要找到在 $S[l,r]$ 中，出现至少两次的子串的长度最大值（允许重叠出现）。

$1\leq n\leq 5\times 10^4,1\leq q\leq 10^5$。

## 思路

首先直接做十分困难的，不妨二分答案，转为判定性问题：$S[l,r]$ 中是否存在出现至少两次的长度 $\geq k$ 的子串。我们尝试用 SAM 解决这个问题。

利用 SAM 的话只有两个方向：endpos 等价类集合以及 LCS 性质。对于前者，每次询问一段区间，似乎会影响太多的等价类，可能难以维护，所以考虑后者。

我们用 LCS（最长公共后缀）的语言重写问题：是否存在 $i,j$，使得 $l+k-1\leq i\lt j\leq r$ 且 $\mathrm{LCS}(S[1,i], S[1,j])\geq k$。

由于 SAM 的性质，可以改写为 $\mathrm{len}(\mathrm{lca}(p_i, p_j))\geq k$，其中 $p_i$ 表示 $S[1,i]$ 所在的等价类。

由于 $\mathrm{len}$ 是随着深度增加而增加，因此这个东西的性质是和深度类似的，再结合 LCA，可以考虑将所有 $\mathrm{len}(i)\geq k$ 的点 $i$ 激活，只有两个端点都被激活的 parent tree 树边才存在。那么原本的 parent tree 被我们割裂为一些连通块，我们询问是否存在 $p_i,p_j$ 位于同一个连通块中。

这个时候我们有一个神奇的想法，记 $s_k(i)$ 表示编号比 $i$ 大的最小的 $j$，使得 $p_i,p_j$ 位于同一个连通块。如果我们可以维护出这个，那么只需要询问 $s_k$ 在区间 $[l-k+1,r]$ 的最小值是否 $\leq r$ 即可。

如何求出 $s_k(i)$ 呢？由于 $s_k(i)\leq s_{k+1}(i)$，所以可以先从 $s_k(i)$ 继承答案，维护将 $k\gets k+1$ 造成的连通块合并。这个可以并查集。

为了维护 $s_k(i)$，我们给每个连通块的根节点附上当前连通块内的前缀节点集合，那么只需要启发式合并集合，在启发式合并时询问一个位置左侧和右侧第一个元素，进行修改即可。

由于需要维护出 $s_k(i)$，并且 $s_k(i)$ 是从 $s_{k+1}(i)$ 继承得到，且最后需要维护 RMQ，于是可以考虑用可持久化线段树来维护全体 $s_k(i)$。

时间复杂度 $O(n\log^2 n)$，默认 $n,q$ 同阶。这个做法是在线的。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

template<int N, int MAX_CHAR>
struct SuffixAutomaton {
    int trans[N << 1][MAX_CHAR], link[N << 1], len[N << 1], cur, tot;
    int cnt, lst[N << 1], per[N <<1];
    vector<int> ptr[N << 1];

    SuffixAutomaton(){ link[0] = -1; }

    void extend(int c){
        int x = cur; cur = ++tot;
        len[cur] = len[x] + 1;
        lst[cur] = ++cnt, per[cnt] = cur;
        for(;(~x)&&(!trans[x][c]);x=link[x]) trans[x][c] = cur;
        if(!(~x)) return link[cur] = 0, void();
        int y = trans[x][c];
        if(len[y] == len[x] + 1) return link[cur] = y, void();
        int u = ++tot, d = y;
        link[u] = link[y], link[d] = link[cur] = u, len[u] = len[x] + 1;
        for(int i=0;i<MAX_CHAR;i++) trans[u][i] = trans[d][i];
        for(;(~x)&&(trans[x][c]==y);x=link[x]) trans[x][c] = u;
    }

    void build(){
        for(int i=1;i<=tot;i++) ptr[link[i]].push_back(i);
    }
};

const int N = 5e4 + 5;
SuffixAutomaton<N, 26> sam;
int n, q;
string s;
vector<int> len[N];

struct node{
    int l, r, v, ver;
} t[N << 5];
int rt[N], tot;

void update(int p, int v, int ver, int &i, int l, int r){
    if(t[i].ver != ver) t[++tot] = t[i], t[tot].ver = ver, i = tot;
    if(l == r) return t[i].v = v, void();
    int mid = (l + r) >> 1;
    if(p <= mid) update(p, v, ver, t[i].l, l, mid);
    else update(p, v, ver, t[i].r, mid + 1, r);
    t[i].v = min(t[t[i].l].v, t[t[i].r].v);
}

int query(int ql, int qr, int i, int l, int r){
    if(ql <= l && r <= qr) return t[i].v;
    int mid = (l + r) >> 1;
    int ans = INT_MAX;
    if(ql <= mid) ans = min(ans, query(ql, qr, t[i].l, l, mid));
    if(mid < qr) ans = min(ans, query(ql, qr, t[i].r, mid + 1, r));
    return ans;
}

int fa[N << 1];
set<int> st[N << 1];
int find(int x){ return fa[x] == x ? x : fa[x] = find(fa[x]); }

void merge(int x, int y, int ver){
    x = find(x), y = find(y);
    if(x == y) return;
    if(st[x].size() < st[y].size()) swap(x, y);
    fa[y] = x;
    for(int i : st[y]){
        auto ite = st[x].upper_bound(i);
        if(ite != st[x].end()) update(i, *ite, ver, rt[ver], 1, n);
        if(ite != st[x].begin()) update(*(--ite), i, ver, rt[ver], 1, n);
        st[x].insert(i);
    }
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> q >> s;
    for(char ch : s) sam.extend(ch - 'a');
    sam.build();
    for(int i=0;i<=sam.tot;i++) len[sam.len[i]].push_back(i);
    iota(fa, fa + sam.tot + 1, 0);
    for(int i=1;i<=n;i++) st[sam.per[i]].insert(i);
    for(int i=1;i<=n;i++) update(i, n + 1, n + 1, rt[n + 1], 1, n);
    for(int i=n;~i;i--){
        rt[i] = rt[i + 1];
        for(int j : len[i]){
            for(int k : sam.ptr[j]) merge(j, k, i);
        }
    }
    while(q--){
        int l, r; cin >> l >> r;
        int L = 0, R = r - l + 1;
        while(L < R){
            int mid = (L + R + 1) >> 1;
            if(query(l + mid - 1, r, rt[mid], 1, n) <= r) L = mid;
            else R = mid - 1;
        }
        cout << L << '\n';
    }
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：Reunite (赞：2)

$2024.9.18$ 我们已经有了更优复杂度做法。

延续 SAM 上维护极长相邻连续段信息，然后弄下来 $n\log n$ 个段再处理询问的思路。目前复杂度瓶颈有两个，一个是朴素的用 set 启发式合并找 $n\log n$ 个段，一个是 $n\log n$ 次序列修改，我们来逐一爆破。下面所说涉及到点排序，大小等都指点上对应 $endpos$ 位置。

考虑连续段的一个判定，对于 parent 树上一条树链 $u\rightarrow v$，如果满足 $u,v$ 在树链上排序后相邻，则 $(u,v)$ 一定会在 $lca(u,v)$ 处开启一个新的连续段，这是显然的。既然转化为路径问题，不妨考虑点分治，设当前点分中心为 $S$。

![](https://cdn.luogu.com.cn/upload/image_hosting/7zqu8hcq.png)

我们每次想要求出所有跨过点分中心的连续段，而这棵树是有根树，如上图 $3$ 为点分中心，所有可能的情况即为红色与红色之间的路径，红色与蓝色之间的路径两种情况。

先处理红色内部的情况，此时可看成一个连通块，直接对每个点找到其前驱或后继即可包含所有情况。对于红蓝之间的情况，不难发现所有红色点都会并到点分中心，此时我们对每个蓝点找在红点中的前驱和后继就可以包含所有情况。

直接排序找前驱后继复杂度 $O(n\log^2 n)$，注意到点值域为 $n$，一个经典技巧是离线桶排，全部丢到 vector 里面，顺着值域扫就可以把总量 $n\log n$ 个元素依次排序了。

现在我们在 $n\log n$ 复杂度内找到了所有连续段，对于后面的操作，简单转化即为扫描线，需要 ds 支持单点修改，前后缀查询最值。可以上线段树或树状数组，但是修改有 $n\log n$ 次，而询问只有 $n$ 次，让我们上面的努力白费了，我们希望平衡修改和查询的复杂度。

到这一步我卡住了，想不出来什么 $O(1)-O(\log n)$ 的方法，问了 lxl 和好几个集训队都说没法做。但是他们给出了一种也很优的方法：多叉线段树。把每个区间分成 $B$ 叉，层数为 $\log_B n$，则修改复杂度 $O(\log_B n)$，查询复杂度 $O(B\log_B n)$，平衡一下，取 $B=\log n$ 即可做到 $O(\frac{\log n}{\log \log n})-O(\frac{\log^2 n}{\log \log n})$ 的复杂度了。

所以总复杂度为 $O(\frac{n\log^2 n}{\log \log n})$，没树状数组跑的快。如果有人会 $O(1)-O(\log n)$ 的单点修前后缀查最值请告诉我。代码略显冗长。

---

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
using namespace std;

int n,q,tot=1,root,tots,tm;
char c[50005];
int lg[100005];
int fa[100005];
int dfn[100005];
int dep[100005];
int it[100005];
int enp[100005];
int sz[100005];
int msz[100005];
int len[100005];
int mp[100005][26];
bool vis[100005];
int ans[100005];
int mi[20][100005];
int ha[100005];
int hb[100005];
vector <int> g[100005];
struct node{
	int cnt;
	int h[50005];
	int x[1000005];
	int y[1000005];
	int nxt[1000005];
	inline void add(int a,int xx,int yy){
		cnt++;
		x[cnt]=xx,y[cnt]=yy,nxt[cnt]=h[a];
		h[a]=cnt;
		return ;
	}
}h,gg,qg;

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline int ins(int las,int c){
	if(mp[las][c]){
		int p=las,v=mp[las][c];
		if(len[v]==len[p]+1) return v;
		int x=++tot;
		len[x]=len[p]+1;
		for(int i=0;i<26;i++) mp[x][i]=mp[v][i];
		while(mp[p][c]==v) mp[p][c]=x,p=fa[p];
		fa[x]=fa[v],fa[v]=x;
		return x;
	}
	int p=las,x=++tot;
	len[x]=len[p]+1;
	while(p&&!mp[p][c]) mp[p][c]=x,p=fa[p];
	if(!p) fa[x]=1;
	else{
		int v=mp[p][c];
		if(len[v]==len[p]+1) fa[x]=v;
		else{
			int y=++tot;
			len[y]=len[p]+1;
			for(int i=0;i<26;i++) mp[y][i]=mp[v][i];
			while(mp[p][c]==v) mp[p][c]=y,p=fa[p];
			fa[y]=fa[v],fa[x]=fa[v]=y;
		}
	}
	return x;
}

inline int getmn(int x,int y){return dfn[x]<dfn[y]?x:y;}

inline void init(int u,int fa){
	mi[0][dfn[u]=++tm]=fa;
	dep[u]=dep[fa]+1;
	for(int v:g[u]) if(v!=fa) init(v,u);
	return ;
}

inline int LCA(int u,int v){
	if(u==v) return u;
	if((u=dfn[u])>(v=dfn[v])) swap(u,v);
	int d=lg[v-u++];
	return getmn(mi[d][u],mi[d][v-(1<<d)+1]);
}

inline void getroot(int u,int fa){
	sz[u]=1,msz[u]=0;
	for(int v:g[u]){
		if(v==fa||vis[v]) continue;
		getroot(v,u);
		sz[u]+=sz[v];
		msz[u]=max(msz[u],sz[v]);
	}
	msz[u]=max(msz[u],tots-sz[u]);
	if(msz[u]<msz[root]) root=u;
	return ;
}

int c1,c2;
int a[50005];
int b[50005];

inline void get(int u,int fa,int bl){
	if(enp[u]){
		if(bl) b[++c2]=enp[u];
		else a[++c1]=enp[u];
	}
	for(int v:g[u]){
		if(v==fa||vis[v]) continue;
		get(v,u,bl);
	}
	return ;
}

inline void add(int x,int y){
	int lca=LCA(it[x],it[y]),l=len[lca];
	gg.add(y,x-l+1,x);
	return ;
}

inline void work(int u){
	c1=c2=0;
	if(enp[u]) a[++c1]=enp[u],h.add(enp[u],u,u);
	for(int v:g[u]){
		if(vis[v]) continue;
		int cc1=c1+1,cc2=c2+1;
		get(v,u,(fa[u]==v));
		for(int i=cc1;i<=c1;i++) h.add(a[i],u,v);
		for(int i=cc2;i<=c2;i++) h.add(b[i],u,-v);
	}

	return ;
}

inline void solve(int u){
	work(u);
	vis[u]=1;
	for(int v:g[u]){
		if(vis[v]) continue;
		tots=sz[v];
		root=0;
		getroot(v,u);
		solve(root);
	}
	return ;
}

inline void initnext(){
	for(int i=1;i<=n;i++){
		for(int j=h.h[i];j;j=h.nxt[j]){
			int u=h.x[j],k=h.y[j];
			if(k>0){
				if(ha[u]&&ha[u]!=u) add(ha[u],i);
				ha[u]=hb[u]=i;
			}
			else if(hb[u]) add(hb[u],i);
		}
	}
	for(int i=1;i<=tot;i++) hb[i]=0;
	for(int i=n;i>=1;i--){
		for(int j=h.h[i];j;j=h.nxt[j]){
			int u=h.x[j],k=h.y[j];
			if(k>0) hb[u]=i;
			else if(hb[u]) add(i,hb[u]);
		}
	}

	return ;
}

struct segtree{
	// int t[50005];
	// inline void add1(int x,int k){while(x<=n) t[x]=max(t[x],k),x+=x&-x;return ;}
	// inline int ask1(int x){int s=0;while(x) s=max(s,t[x]),x^=x&-x;return s;}
	// inline void add2(int x,int k){while(x) t[x]=max(t[x],k),x^=x&-x;return ;}
	// inline int ask2(int x){int s=0;while(x<=n) s=max(s,t[x]),x+=x&-x;return s;}

	int B=10,tot=1;
	int it[200005];
	int fa[200005];
	int mx[200005];
	int ch[200005][15];

	inline void build(int u,int l,int r){
		if(l==r){
			it[l]=u;
			return ;
		}
		int len=(r-l+1+B-1)/B,bb=0;
		for(int i=l;i<=r;i+=len){
			int j=min(r,i+len-1);
			tot++;
			bb++;
			fa[tot]=u;
			ch[u][bb]=tot;
			build(tot,i,j);
		}
		return ;
	}

	inline void upd(int x,int k){
		x=it[x];
		while(x) mx[x]=max(mx[x],k),x=fa[x];
		return ;
	}

	inline int ask(int u,int l,int r,int L,int R){
		if(l==r) return mx[u];
		int len=(r-l+1+B-1)/B,bb=0,x=0;
		for(int i=l;i<=r;i+=len){
			int j=min(r,i+len-1);
			bb++;
			if(L<=i&&j<=R) x=max(x,mx[ch[u][bb]]);
			else if(L>j||R<i) continue;
			else x=max(x,ask(ch[u][bb],i,j,L,R));
		}
		return x;
	}

}t1,t2;

int main(){ 
	// freopen("qwq.in","r",stdin);
	in(n),in(q);
	scanf("%s",c+1);
	int las=1;
	for(int i=1;i<=n;i++) las=ins(las,c[i]-'a'),enp[las]=i,it[i]=las;
	for(int i=2;i<=tot;i++) g[fa[i]].emplace_back(i),g[i].emplace_back(fa[i]);
	init(1,0);
	for(int i=2;i<=tot;i++) lg[i]=lg[i>>1]+1;
	for(int j=1;j<=lg[tot];j++)
		for(int i=1;i+(1<<j)-1<=tot;i++)
			mi[j][i]=getmn(mi[j-1][i],mi[j-1][i+(1<<(j-1))]);
	sz[0]=msz[0]=(tots=tot)+1;
	getroot(1,0);
	solve(root);
	initnext();
	for(int i=1;i<=q;i++){
		int l,r;
		in(l),in(r);
		qg.add(r,l,i);
	}
	t1.build(1,1,n);
	t2.build(1,1,n);
	for(int i=1;i<=n;i++){
		for(int j=gg.h[i];j;j=gg.nxt[j]){
			int x=gg.x[j],y=gg.y[j];
			t1.upd(x,y);
			t2.upd(x,y-x+1);
		}
		for(int j=qg.h[i];j;j=qg.nxt[j]){
			int x=t1.ask(1,1,n,1,qg.x[j])-qg.x[j]+1;
			int y=t2.ask(1,1,n,qg.x[j],n);
			ans[qg.y[j]]=max(x,y);
		}
	}
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);

	return 0;
}
```

---

## 作者：wjyppm1403 (赞：1)

[可能更好的阅读体验](https://worldcpu.github.io/posts/48ad214/)

题目很好，考察了 SA 中的并查集思想以及启发式合并，而且实现也不难，值得一做。

形式化题面如下：

> 给定一个长为 $n$ 的字符串，询问次数为 $q$，多次询问区间 $[l,r]$ 内最长重复子串的长度。
> 
> $1\le n \le 5\times 10^4,1\le q \le 10^5$。

~~没有形式化题面感觉都想不出来怎么做 www。~~

肯定没有那么菜啦，首先考虑二分长度，问题转化为区间内是否存在一个长为 $mid$ 的最长重复子串。

接下来我们考虑这个最长重复子串怎么求，一个比较明显的想法就是后缀数组的 LCP 功能，原命题询问的实质就是是否存在 $i,j \in [l,r-mid+1],\operatorname{LCP}(i,j)\ge mid$。看到后面这个式子，回忆起[品酒大会](https://www.luogu.com.cn/problem/solution/P2178)的思路：从大到小将 Height 数组插入，若仅考虑 $\ge L$ 的 Height，将 $sa_{i-1},sa_{i}$ 之间连边，那么若 $p,q$ 在同一联通块里，表明 $\operatorname{LCP}(p,q)\ge L$。我们通过并查集和启发式合并就可以做到 $O(\log n)$ 的优秀复杂度啦。

但是有点问题啊，如果我们直接这么做我们并没有考虑区间位置，也就是说在两个联通块启发式合并的时候我们必须要记录区间的位置。我们不妨考虑对于联通块内每一个位置，我们维护它在当前联通块内上一个元素的位置，记作 $pre_{i}$，那么区间限制转化为 $\max\limits_{i\in set(L),i\in [l,r-L+1]} pre_{i}\ge l$。我们可以通过对每一个联通块开主席树来辅助查询，这样就能够做到优秀的 $O(q \log^2 n$) 的查询啦，其中两个 $\log$ 由二分和主席树查询贡献。

问题转化为如何维护 $pre$ 的合并。首先，唯一确定一个联通块的信息就是所对应的 LCP 长度 $L$（具体见上面品酒大会思路），根据品酒大会启发式合并的思路，一次启发式 $pre$ 的变化最多只有 $O(\log n)$ 个，考虑用 set 把联通块内的元素存下来，启发式合并的时候暴力单点修改 $pre$，这样处理的复杂度是 $O(n \log^2 n)$ 的，可以过。故总时间复杂度为 $O(q\log^2 n + n \log^2 n)$。

请注意二分的实现：

```cpp
#include<bits/stdc++.h>
#define pir pair<int,int>
using namespace std;
constexpr int MN=5e4+15;
int n,q,pre[MN];
vector<int> vht[MN];
set<int> st[MN];
string s;

struct Segment{
#define ls t[p].lson
#define rs t[p].rson

    struct Node{
        int lson,rson,val;
    }t[MN<<9];
    int tot,rt[MN];
    
    void pushup(int p){
        t[p].val=max(t[ls].val,t[rs].val);
    }

    void modfiy(int &p,int lst,int l,int r,int pos,int v){
        p=++tot;
        t[p]=t[lst];
        if(l==r){
            t[p].val=max(t[p].val,v);
            return;
        }
        int mid=(l+r)>>1;
        if(mid>=pos) modfiy(ls,t[lst].lson,l,mid,pos,v);
        else modfiy(rs,t[lst].rson,mid+1,r,pos,v);
        pushup(p);
    }

    int query(int p,int l,int r,int fl,int fr){
        if(l>=fl&&r<=fr){
            return t[p].val;
        }
        int mid=(l+r)>>1,ret=0;
        if(mid>=fl) ret=max(ret,query(ls,l,mid,fl,fr));
        if(mid<fr) ret=max(ret,query(rs,mid+1,r,fl,fr));
        return ret;
    }

#undef ls
#undef rs
}sg;

namespace SA{
    int len,sa[MN],x[MN],y[MN],rk[MN],c[MN],ht[MN],ST[30][MN];

    // 接受 string 和 vector_int 输入，其他输入不保证正确性
    // ST表需要手动初始化调用initst函数
    template<typename vct>
    void getsa(vct &s){
        int m=400000;
        len=s.size();
        s.insert(s.begin(),' ');
        for(int i=1;i<=len;i++){
            x[i]=s[i];
            ++c[x[i]];
        }
        for(int i=2;i<=m;i++) c[i]+=c[i-1];
        for(int i=len;i>=1;i--) sa[c[x[i]]--]=i;
        for(int k=1;k<=len;k<<=1){
            int num=0;
            for(int i=len-k+1;i<=len;i++) y[++num]=i;
            for(int i=1;i<=len;i++){
                if(sa[i]>k) y[++num]=sa[i]-k;
            }
            for(int i=1;i<=m;i++) c[i]=0;
            for(int i=1;i<=len;i++) c[x[i]]++;
            for(int i=2;i<=m;i++) c[i]+=c[i-1];
            for(int i=len;i>=1;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;
            swap(x,y);
            num=1,x[sa[1]]=1;
            for(int i=2;i<=len;i++){
                if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]) x[sa[i]]=num;
                else x[sa[i]]=++num;
            }
            if(num==len) break;
            m=num;
        }
        for(int i=1;i<=len;i++) rk[sa[i]]=i;
        for(int i=1,k=0;i<=len;i++){
            if(rk[i]==1) continue;
            if(k) k--;
            int j=sa[rk[i]-1];
            while(i+k<=len&&j+k<=len&&s[i+k]==s[j+k]) k++;
            ht[rk[i]]=ST[0][rk[i]]=k;
        }
    }
}using namespace SA;

int root(int x){
    if(pre[x]==x) return pre[x];
    else return pre[x]=root(pre[x]);
  // 这里用这种合并方式而不是按秩合并
  // 是因为并查集维护的是联通块所属的集合，不用考虑形态变化。
}

void merge(int x,int y,int L){
    int rx=root(x),ry=root(y);
    if(rx==ry) return;
    if(st[rx].size()<st[ry].size()) swap(rx,ry);
    pre[ry]=rx;
    for(auto p:st[ry]){
        auto it=st[rx].lower_bound(p);
        if(it!=st[rx].end()){
            sg.modfiy(sg.rt[L],sg.rt[L],1,n,*it,p);
        }
        if(it!=st[rx].begin()){
            it--;
            sg.modfiy(sg.rt[L],sg.rt[L],1,n,p,*it);
        }
    }
    for(auto p:st[ry]) st[rx].insert(p);
}

int main(){
    cin>>n>>q>>s;
    getsa(s);
    for(int i=2;i<=n;i++){
        vht[ht[i]].push_back(i);
    }
    for(int i=1;i<=n;i++){
        pre[i]=i;
        st[i].insert(i);
    }
    for(int i=n;i>=1;i--){
        sg.rt[i]=sg.rt[i+1];
        for(auto p:vht[i]){
            merge(sa[p],sa[p-1],i);
        }
    }
    while(q--){
        int L,R;
        cin>>L>>R;
        int l=0,r=R-L+1;
        while(l+1<r){
            int mid=(l+r)>>1;
            if(sg.query(sg.rt[mid],1,n,L,R-mid+1)>=L){
                l=mid;
            }else r=mid;
        }
        cout<<l<<'\n';
    }
    return 0;
}

```

---

## 作者：Otomachi_Una_ (赞：1)

对这种区间查询的问题可以考虑使用扫描线。从小到大枚举 $r$，当 $r$ 从 $r'-1$ 转移到 $r'$ 时，维护每个 $l$ 的答案。更新所有可能的 $x\leq r$，假设与 $s[x,r]$ 完全相等且 $L$ 最小的字串 $s[L,R]$。我们可以用线段树维护这个新的串所带来的答案的改变。

然后我们怎么找所有有用的 $x$ 呢？我们尝试取枚举 $R$，那么上面维护 $s[x,r],s[L,R]$ 产生贡献的部分就可以变成 $s[1,r],s[1,R]$ 的 lcs（最长公共后缀）。

我们对建一个 SAM，假设 $s[1,i]$ 在 SAM 对应点为 $u_i$。那么上面 lcs 的长度相当于 $len(\text{lca}(u_r,u_R))$。如果两个 $R_1<R_2$ 对应的 $\text{lca}$ 相同必然会选择 $R_2$ 对应的节点（前者 lcs 被后者包含）。

也就是，大概的算法就是：

- SAM 每个节点维护一个变量 $p$ 表示上个在其子树内被访问的 $u_i$。
- 对 $u_r$，把 $1$ 到 $u_r$ 路径上所有 $p$ 与 $r$ 计算贡献。
- 把 $1$ 到 $u_r$ 路径上所有 $p$ 设置为 $u_r$。

这玩意类似于 LCT 的 assert，我们也可以用树链剖分简单维护。

---

## 作者：Mirasycle (赞：0)

高质量的 SA 练习题。比题库中的大部分 SA 配合数据结构的无聊套路题多了点变化。

题目即求给定多次区间询问，其中区间内任意两个子串的 $\operatorname{lcp}$ 长度的最大值。

考虑二分答案转化为判定问题，即求是否存在 $i,j\in[l,r-ans+1]$，满足 $\operatorname{lcp}(i,j)\ge ans$。

可以使用 SA 配合上 height 数组的从大到小的启发式合并很好地刻画上述条件。

如果存在上述 $i,j$ 即代表他们俩在同一长度 $\ge L$ 集合内。如果暴力对于集合内点对进行标记统计是 $O(n^2)$ 的，很劣。

可以发现如果没有 $i,j$ 的范围要求，那么只需要检查集合内是否有至少两个元素即可，这是一个很简单的问题。于是这启发我们从这个范围的约束条件下手，双变量不妨固定其中的一个，假设我们固定了 $i$（其中 $i<j$），那么只需要寻找一个 $j$ 落在 $[i,r-ans+1]$ 的范围内即可，于是我们可以贪心地维护每个位置的最近后继问题，然后判定最近后继是否 $\le r-ans+1$ 即可。

于是我们就大大减小了问题的规模，从原本的标记所有点对到现在只用考虑维护后继。

在启发式合并的过程中，我们是把小集合的元素一一加入大集合中，在这个过程中，每次加入一个元素，二分寻找它在新的集合中的后继并更新是很简单的。现在问题来了如何更新大集合中的后继，我们不可能扫描大集合中的每个元素来寻找后继，这会使得复杂度不对了。其实仔细思考一下会发现，每个新加入的小集合中的元素其实只会对于它在大集合中的前驱产生贡献，比如我们加入了 $k$，满足 $i<j<k$，$k$ 只会对于 $j$ 产生贡献，因为 对于 $i$ 来说 $j$ 比 $k$ 更优。于是我们在加入小集合元素时查找前驱后驱并相应更新即可。

如果询问给定了需要判定的长度，那么我们直接离线按照长度从大到小一遍启发式合并集合一边回答对应长度的询问即可。但是因为我们是在二分答案，所以需要在线算法。

可以发现要保留所有长度的信息，这提示了我们要使用可持久化线段树，每次二分之后在对应长度代表的线段树上区间查询所有点的后继中最小的那个进行判定即可。

时间复杂度 $O(n\log^2n)$。

---

## 作者：Jerrywang09 (赞：0)

题目的意思简单说来就是求 $s[l,r]$ 中最长的出现两次的子串。

其实本题很综合，并不难。先求出后缀数组，然后对于每个询问二分答案。具体来说，就是二分子串长度为 $mid$，查询是否存在 $i,j|l\le i<j\le r-mid+1$，$\operatorname{lcp}(i, j)\ge mid$。

类似于品酒大会，用一个并查集维护大于等于某 $ht$ 的后缀集合，使用并查集、启发式合并。对于相同集合内的若干后缀，使用线段树记录它们在集合中的前驱。把线段树可持久化，就可以预处理所有 $ht=mid$ 时的后缀集合。然后区间查询 $[l,r-mid+1]$，如果最大的前驱 $\ge l$ 就说明合法。

```cpp
// Title:  拜神
// Source: P7361
// Author: Jerrywang
// start coding: 19:29
#include <cstdio>
#include <algorithm>
#include <set>
#include <vector>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=50010, B=131;
using namespace std;

char a[N]; ll h[N], pw[N];
int n, T, sa[N], ht[N];
ll H(int l, int r)
{
    return h[r]-h[l-1]*pw[r-l+1];
}
int lcp(int i, int j)
{
    int l=0, r=min(n-i+1, n-j+1), res=0;
    while(l<=r)
    {
        int m=l+r>>1;
        if(H(i, i+m-1)==H(j, j+m-1))
            res=m, l=m+1;
        else r=m-1;
    }
    return res;
}
bool cmp(int x, int y)
{
    int len=lcp(x, y);
    return a[x+len]<a[y+len];
}

int rt[N], tot;
struct node {int l, r, x;} t[N<<8];
void up(int p) {t[p].x=max(t[t[p].l].x, t[t[p].r].x);}
void modify(int &x, int y, int i, int val, int l=1, int r=n)
{
    t[x=++tot]=t[y];
    if(l==r) return t[x].x=max(t[x].x, val), void();
    int mid=l+r>>1;
    if(i<=mid) modify(t[x].l, t[y].l, i, val, l, mid);
    else modify(t[x].r, t[y].r, i, val, mid+1, r);
    up(x);
}
int query(int p, int L, int R, int l=1, int r=n)
{
    if(L<=l && r<=R) return t[p].x;
    int mid=l+r>>1, res=0;
    if(L<=mid) res=max(res, query(t[p].l, L, R, l, mid));
    if(R>mid) res=max(res, query(t[p].r, L, R, mid+1, r));
    return res;
}
int fa[N]; set<int> S[N]; vector<int> vec[N];
int root(int u) {return fa[u]==u?u:fa[u]=root(fa[u]);}
void merge(int u, int v, int &rt)
{
    u=root(u), v=root(v);
    if(u==v) return;
    if(S[u].size()<S[v].size()) swap(u, v);
    for(int x:S[v])
    {
        auto it=S[u].lower_bound(x);
        if(it!=S[u].end()) modify(rt, rt, *it, x);
        if(it!=S[u].begin()) modify(rt, rt, x, *prev(it));
    }
    for(int x:S[v]) S[u].insert(x);
    S[v].clear(); fa[v]=u;
}
int solve(int L, int R)
{
    int l=1, r=R-L+1, res=0;
    while(l<=r)
    {
        int mid=l+r>>1;
        if(query(rt[mid], L, R-mid+1)>=L) res=mid, l=mid+1;
        else r=mid-1;
    }
    return res;
}

int main()
{
#ifdef Jerrywang
    freopen("in.txt", "r", stdin);
#endif
    scanf("%d%d%s", &n, &T, a+1);
    pw[0]=1;
    rep(i, 1, n) pw[i]=pw[i-1]*B, h[i]=h[i-1]*B+a[i], sa[i]=i;
    stable_sort(sa+1, sa+n+1, cmp);
    rep(i, 2, n)
    {
        ht[i]=lcp(sa[i-1], sa[i]);
        vec[ht[i]].push_back(i);
    }
    rep(i, 1, n) fa[i]=i, S[i].insert(i);
    for(int i=n; i; i--)
    {
        rt[i]=rt[i+1];
        for(int j:vec[i]) merge(sa[j-1], sa[j], rt[i]);
    }
    while(T--)
    {
        int l, r; scanf("%d%d", &l, &r);
        printf("%d\n", solve(l, r));
    }
    
    return 0;
}
```

---

## 作者：ImmortalWatcher (赞：0)

看到没有人写题解，过来搬运一下官方题解。

来自：[alpha1022](https://www.luogu.com.cn/paste/4qn38il5)。

将询问离线，按右端点作扫描线，同时考虑维护 $f(s)$ 表示子串 $s$ 目前为止最后出现的位置的右端点。  
考虑一个目前位置新出现的子串 $t$ 的贡献，在更新 $f(t)$ 之前，会发现新增加一个 $t$ 使得左端点在 $f(t)-|t|+1$ 之前的询问都会将 $t$ 计入答案。于是我们需要一个支持前缀和 $|t|$ 取 max，单点查询的数据结构；可以显然地转化为单点修改，查询前缀 max，容易使用树状数组完成。

不过到此为止该做法仍然非常朴素，考虑使用 LCT 维护反串后缀树，在每个状态上维护 $f$ 值。新加入右端点类似于 LCT 的 access 操作，容易维护。  
新出现的另一个问题在于后缀树的状态包含了不止一个字符串。想必精通后缀树 / 后缀自动机的您一定看出来了，这时我们的数据结构就需要另外支持区间和公差为 $1$ 的等差数列取 max。  
对于 general 的公差不固定的问题，~~根据 EI 鸽鸽的教诲~~使用二进制分组 + cascading 可以做到 $O(n \log n \alpha(n))$，不过这是题外话了。  
事实上可以把操作化为这样的形式：对于 $l \le i \le r$，令 $a_i = \max(a_i,x-i)$。考虑维护一个 $b_i = a_i - i$，那么操作就变成了 $b_i = \max(b_i,x)$ 并单点查询，使用线段树可以轻松解决。

---

## 作者：xuyiyang (赞：0)

### [P7361 「JZOI-1」拜神](https://www.luogu.com.cn/problem/P7361)
### Solution
首先注意到两个相同字符串代表后缀 $s_i,s_j$ 它们的 LCP。所以首先建出 SA，然后和评酒大会一样**从大到小**枚举 LCP 长度 $L$，用 `ht` 合并连通块，那么每个连通块就是在其中任意两点后缀的 LCP $ \ge L$ ，用 `set` 启发式合并求出每个点的最小的与其 LCP $\ge L$ 的后继。在查询时二分答案 $h$，对于每种长度建立可持久化线段树，判断 $[l,r]$ 后继的最小值是否小于等于 $r - h + 1$ 即可。启发式合并每次修改 $\mathcal O(\log n)$ 的点。所以时间复杂度 $\mathcal O((n + q) \log ^ 2 n)$。空间相同。$\\$
现在说下如何在同一个版本进行多点修改。首先将每个修改位置的最后值求出。修改的位置和值加入一个 `vector`，按照位置升序，然后在线段树上暴力拆分修改即可。每个点至多修改一条链，所以是 $\sum k_i \log n = \mathcal O(n \log ^ 2 n)$ 的。

---


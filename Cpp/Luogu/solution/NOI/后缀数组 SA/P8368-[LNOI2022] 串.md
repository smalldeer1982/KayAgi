# [LNOI2022] 串

## 题目描述

为了让你更好地理解题面，给出若干关于字符串的定义：

- 对于一个字符串 $S = s_1 s_2 \cdots s_n$，定义其长度为 $\lvert S \rvert = n$。
- 对于两个字符串 $S = s_1 s_2 \cdots s_n$ 和 $T = t_1 t_2 \cdots t_m$，称 $T$ 为 $S$ 的子串，若 $m = 0$（即 $T$ 为空串）或者 $\exists 1 \le i \le j \le n$，$T = s_i s_{i + 1} \cdots s_j$。若 $m = 0$ 或上述判断条件中 $i$ 可以取到 $1$，则称 $T$ 为 $S$ 的前缀；若 $m = 0$ 或上述判断条件中 $j$ 可以取到 $n$，则称 $T$ 为 $S$ 的后缀。

给定一个英文小写字母构成的字符串 $S$，你需要找到一个尽可能长的字符串序列 $(T_0, T_1, \ldots, T_l)$，满足：

- $T_0$ 是 $S$ 的子串；
- $\forall 1 \le i \le l$，$\lvert T_i \rvert - \lvert T_{i - 1} \rvert = 1$；
- $\forall 1 \le i \le l$，存在 $S$ 的一个长度为 $\lvert T_i \rvert + 1$ 的子串 $S'_i$，使得 $S'_i$ 的长度为 $\lvert T_{i - 1} \rvert$ 的前缀为 $T_{i - 1}$，长度为 $\lvert T_i \rvert$ 的后缀为 $T_i$。

输出这样的字符串序列的长度的最大值（即 $l$ 的最大值）。

## 说明/提示

**【样例解释 \#1】**

下文中使用符号 $\epsilon$ 表示空串。

对于第一组测试数据，可以找到如下字符串序列：$T_0 = \epsilon, T_1 = \texttt{b}, T_2 = \texttt{cd}$，其中 $S'_1 = \texttt{ab}, S'_2 = \texttt{bcd}$。

对于第二组测试数据，可以找到如下字符串序列：$T_0 = \epsilon, T_1 = \texttt{b}, T_2 = \texttt{ab}, T_3 = \texttt{bab}$，其中 $S'_1 = \texttt{ab}, S'_2 = \texttt{bab}, S'_3 = \texttt{abab}$。

对于第三组测试数据，可以找到如下字符串序列：$T_0 = \epsilon$。

**【样例 \#2】**

见附件中的 `string/string2.in` 与 `string/string2.ans`。

该组样例中的字符串长度有一定梯度，你可以利用该组样例对程序进行检查。

**【样例 \#3】**

见附件中的 `string/string3.in` 与 `string/string3.ans`。

该组样例满足特殊性质 A。

**【数据范围】**

设 $\sum |S|$ 表示测试点中所有测试数据的字符串长度和。

对于 $100 \%$ 的测试数据，$T \ge 1$，$1 \le \lvert S \rvert \le 5 \times {10}^5$，$1 \le \sum \lvert S \rvert \le 1.5 \times {10}^6$。

| 测试点编号 | $\lvert S \rvert \le$ | $\sum \lvert S \rvert \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $30$ | $150$ | 无 |
| $3 \sim 5$ | $200$ | $800$ | 无 |
| $6 \sim 8$ | $1000$ | $3000$ | 无 |
| $9 \sim 11$ | $5 \times {10}^5$ | $1.5 \times {10}^6$ | A |
| $12 \sim 15$ | $6 \times {10}^4$ | $3 \times {10}^5$ | 无 |
| $16 \sim 20$ | $5 \times {10}^5$ | $1.5 \times {10}^6$ | 无 |

特殊性质 A：字符串中的每个字符在小写字母中独立均匀随机生成。

**【提示】**

本题输入输出量较大，请使用较为快速的输入输出方式。

例如，若你的代码使用了 `cin` 和 `cout` 作为输入输出方式，你可以选择在代码的**输入输出重定向语句**（`freopen` 语句、 `fopen` 语句等）**之后**加入以下语句加速输入输出速度。

```cpp
ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
```

**加入该语句后不建议同时使用 `cin, cout` 和其他输入输出方式。**

## 样例 #1

### 输入

```
3
abcd
abab
a
```

### 输出

```
2
3
0
```

# 题解

## 作者：_slb (赞：11)

# T4

## Description

给定一个英文小写字母构成的字符串 $S$，你需要找到一个尽可能长的字符串序列 $(T_0, T_1, \ldots, T_l)$，满足：

- $T_0$ 是 $S$ 的子串；
- $\forall 1 \le i \le l$，$\lvert T_i \rvert - \lvert T_{i - 1} \rvert = 1$；
- $\forall 1 \le i \le l$，存在 $S$ 的一个长度为 $\lvert T_i \rvert + 1$ 的子串 $S_i'$，使得 $S_i'$ 的长度为 $\lvert T_{i - 1} \rvert$ 的前缀为 $T_{i - 1}$，长度为 $\lvert T_i \rvert$ 的后缀为 $T_i$。

输出这样的字符串序列的长度的最大值（即 $l$ 的最大值）。

## Solution

一个思路很清奇的题目，乍一看以为和19年省选的那个字符串问题差不多，其实完全没关系。

观察一下这个字符串序列，逆向去想一下，可以这么构造：$[i,j]\rightarrow [i-1,j-2]\rightarrow [i-2,j-4]...$ 一直这样下去直到长度为 $0$ 或者到头了。那么答案就有一个显然的下界 $\lfloor n/2\rfloor$。

然后上面这个构造的瓶颈在于走到头就没得走了，我们需要考虑什么时候可以往后跳回去。

然后就是比较重要的性质了：一个串可以往回跳的充要条件是出现了至少两次。

假设出现位置是 $[i_1,j_1],[i_2,j_2](i_1<i_2)$，那么我们从 $[i_2,j_2]$ 开始，按照上述的构造方法构造，当左端点到 $i_1$ 时，我们跳回到 $i_2$ 即可。

反过来的话就是如果只出现一次，那么这个串对应的 $S_i'$ 是唯一的，别的跳不回来。

这样就很简单了，如果可以往回跳那么我们从 $[i_2,j_2]$ 开始一路跳就可以跳到长度为 $0$。

对于一个出现至少两次的串 $[l,r]$，若选择它作为跳的开始，答案为 $r-l+1+\lfloor(n-r)/2\rfloor$。

我们求出以每个下标为右端点的最长的出现至少两次的串，取个 max。

这个事情用 SAM 搞一搞就可以做，就对于每个节点记录最靠左的位置和 siz 就好了。

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;

namespace solve
{
    const int maxn = 2e6 + 10;

    int n;

    struct SAM
    {
        int mx[maxn], siz[maxn], ch[maxn][26], father[maxn], pos[maxn];
        int lst, tot;
        int ans;
        void insert(int c, int id)
        {
            int p = ++tot, f = lst;
            siz[p] = 1, mx[p] = mx[f] + 1, lst = p, pos[p] = id;
            while (f && !ch[f][c])
                ch[f][c] = p, f = father[f];
            if (!f)
                father[p] = 1;
            else
            {
                int q = ch[f][c];
                if (mx[q] == mx[f] + 1)
                    father[p] = q;
                else
                {
                    int nq = ++tot;
                    memcpy(ch[nq], ch[q], sizeof(ch[q])), father[nq] = father[q], mx[nq] = mx[f] + 1;
                    pos[nq] = n + 1;
                    father[p] = father[q] = nq;
                    while (f && ch[f][c] == q)
                        ch[f][c] = nq, f = father[f];
                }
            }    
        }
        vector<int> e[maxn];
        void build()
        {
            for (int i = 2; i <= tot; i++)
                e[father[i]].push_back(i);
        }
        void dfs(int x)
        {
            for (int v : e[x])
            {
                dfs(v);
                siz[x] += siz[v], pos[x] = min(pos[x], pos[v]);
            }
            if (siz[x] > 1)
                ans = max(ans, (n - pos[x]) / 2 + mx[x]);
        }
        void clear()
        {
            for (int i = 1; i <= tot; i++)
                e[i].clear(), memset(ch[i], 0, sizeof(ch[i]));
            memset(father, 0, sizeof(int) * (tot + 4));
            memset(mx, 0, sizeof(int) * (tot + 4));
            memset(siz, 0, sizeof(int) * (tot + 4));
            memset(pos, 0, sizeof(int) * (tot + 4));
            lst = tot = 1;
            ans = 0;
        }
        SAM() { lst = tot = 1; }
    } sam;

    char s[maxn];

    void main()
    {
        cin >> s;
        n = strlen(s);
        for (int i = 0; i < n; i++)
            sam.insert(s[i] - 'a', i + 1);
        sam.build(), sam.dfs(1);
        cout << max(sam.ans, n / 2) << endl;
        sam.clear();
    }
}

int main()
{
    ios::sync_with_stdio(false);
    int T;
    cin >> T;
    while (T--)
        solve::main();
}
```

---

## 作者：ix35 (赞：8)

好像我做法又和 std 不太一样。

---

**引理 1.** 如果 $(T_0,T_1,\ldots,T_k)$ 合法，并且 $T_0$ 非空，则 $(T'_0,\ldots,T'_k)$ 也合法，其中 $T'_i$ 由 $T_i$ 删去首字符得到。

**Proof.** 显然。

---

**引理 2.** 存在一种最优解 $(T_0,\ldots,T_k)$，使得 $T_0$ 为空串。

**Proof.** 由引理 1 立得。

---

于是，称某个子串 $T$ 合法，当且仅当存在一个合法的序列 $(T_0,\ldots,T_k)$ 使得 $T_0$ 为空串，$T_k=T$，答案就是最长合法子串的长度。

---

**引理 3.** 如果 $S[l,l+x]$ 合法，则 $S[l,l+x-1]$ 合法。

**Proof.** 对 $x$ 归纳，$x=0$ 时显然（空串总是合法）。

若 $x-1$ 时成立，则 $S[l,l+x]$ 合法推出存在 $S[l',l'+x-1]$ 合法，并且 $S[l'+1,l'+x-1]=S[l,l+x-2]$，由归纳假设知 $S[l',l'+x-2]$ 合法，而 $S[l'+1,l'+x-2]=S[l,l+x-3]$，从而 $S[l,l+x-1]$ 也合法。

---

**引理 4.** 如果 $S[l,r]$ 合法且 $r<|S|$，则 $S[l+1,r+1]$ 合法。

**Proof.** 由于 $S[l,r]$ 合法，由引理 3 知 $S[l,r-1]$ 合法，于是根据定义有 $S[l+1,r+1]$ 合法。

---

**引理 5.** 使得 $S[l,l+x]$ 合法的 $l$ 是一个以 $n-x$ 为右端点的区间（或为空），且 $x$ 对应的区间包含 $x+1$ 对应的区间。

**Proof.** 结合引理 3,4 易证。

---

于是我们从小到大枚举 $x$，如果当前的 $x$ 对应的区间是 $[l,n-x]$，对于 $x+1$ 只需要检验一下 $S[l,l+x+1]$ 是否合法，而它合法当且仅当存在 $r>l$ 使得 $S[r,r+x+1]=S[l,l+x+1]$，可以用后缀数组进行检验（用链表维护当前还在区间里的后缀，访问后缀数组上的前驱后继）。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=500010;
int t,n,siz,cnt,rk[MAXN],sa[MAXN],sd[MAXN],buc[MAXN],height[MAXN],pre[MAXN],nx[MAXN];
char c[MAXN];
void bucsort () {
    for (int i=1;i<=siz;i++) {buc[i]=0;}
    for (int i=1;i<=n;i++) {buc[rk[sd[i]]]++;}
    for (int i=1;i<=siz;i++) {buc[i]+=buc[i-1];}
    for (int i=n;i>=1;i--) {sa[buc[rk[sd[i]]]--]=sd[i];}
    return;
}
void solve () {
    for (int i=1;i<=n;i++) {rk[i]=c[i]-'0',sd[i]=i;}
    siz=256;
    bucsort();
    for (int k=1;k<=n;k*=2) {
        cnt=0;
        for (int i=1;i<=k;i++) {sd[++cnt]=n-k+i;}
        for (int i=1;i<=n;i++) {
            if (sa[i]>k) {sd[++cnt]=sa[i]-k;}
        }
        bucsort();
        for (int i=1;i<=n;i++) {sd[i]=rk[i];}
        cnt=0;
        for (int i=1;i<=n;i++) {
            if (sd[sa[i]]==sd[sa[i-1]]&&sd[sa[i]+k]==sd[sa[i-1]+k]) {rk[sa[i]]=cnt;}
			else {rk[sa[i]]=++cnt;}
        }
        if (cnt==n) {return;}
        siz=cnt;
    }
}
bool chk (int x,int len) {
	//cout << "    " << x << "  " << pre[x] << "  " << height[x] << "      " << nx[x] << "  " << x << "  " << height[nx[x]] << endl;
	if (max(height[x],height[nx[x]])>=len) {return 1;}
	return 0;
}
void del (int x) {
	int y=pre[x],z=nx[x];
	height[z]=min(height[z],height[x]);
	pre[z]=y,nx[y]=z;
	return;
}
int main () {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> t;
	for (int ii=1;ii<=t;ii++) {
		cin >> c+1;
    	n=strlen(c+1);
    	if (n==1) {cout << 0 << endl;continue;}
    	for (int i=1;i<=n+1;i++) {rk[i]=sa[i]=sd[i]=buc[i]=height[i]=0;}
    	solve();
    	int cur=0;
    	for (int i=1;i<=n;i++) {
    		pre[sa[i]]=sa[i-1],nx[sa[i]]=sa[i+1];
        	cur=max(0,cur-1);
        	int p=sa[rk[i]-1];
        	while (c[i+cur]==c[p+cur]) {cur++;}
			height[i]=cur;
    	}
    	int ans=0,l=1,r=n;
    	for (int i=1;i<=n;i++) {
    		if (!chk(l,i)) {del(l++);}
    		if (l>r) {break;}
    		ans=i;
    		del(r--);
		}
		cout << ans << endl;
	}
    return 0;
}
```










---

## 作者：zac2010 (赞：5)

显然答案下界为 $\lfloor\frac{n}{2}\rfloor$。采用一种对着题意模拟的策略：假设我们初始的区间为 $[l,r]$，然后逐步向左平移，也就是：$[l,r],[l-1,r-2],[l-2,r-4],\dots$ 直到碰到边界（平移的次数 $+1$ 就等于 $m$）。显然 $l$ 取 $\lfloor\frac{n}{2}\rfloor$，$r$ 取 $n$ 时最优，也就是我们所说的答案下界。

之后考虑怎么尽量地延长这个平移的过程，不难发现：当我们平移到一个串，假设原串中后面还有出现过这个串，那么它就可以一直平移。直到到区间长度为 $0$。稍作推理易发现，假设我们的区间为 $[l,r]$，那么最终经过当前区间的最大 $m$ 为 $r-l+1+\lfloor\frac{n-r}{2}\rfloor$。

直接构建后缀数组，枚举左端点，然后贪心统计贡献就行了（观察式子，会发现左端点固定右端点大的较优）。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); ++i)
#define FR(i, a, b) for(int i = (a); i >= (b); --i)
using namespace std;
const int N = 5e5 + 10;
struct SA{
	int n, m, c[N], sa[N], rk[N], rk2[N], h[N];
	char s[N];
	void rsort(){
		fill(c, c + m + 1, 0);
		FL(i, 1, n) c[rk[i]]++;
		FL(i, 1, m) c[i] += c[i - 1];
		FR(i, n, 1) sa[c[rk[rk2[i]]]--] = rk2[i];
	}
	void ssort(){
		FL(i, 1, n) rk[rk2[i] = i] = s[i];
		m = 126, rsort();
		for(int k = 1; k <= n && (k == 1 || m < n); k <<= 1){
			int t = 0;
			FL(i, n - k + 1, n) rk2[++t] = i;
			FL(i, 1, n) if(sa[i] > k) rk2[++t] = sa[i] - k;
			rsort(), copy(rk, rk + n + 1, rk2);
			rk[sa[1]] = m = 1;
			FL(i, 2, n){
				if(rk2[sa[i]] != rk2[sa[i - 1]])
					rk[sa[i]] = ++m;
				else if(rk2[sa[i] + k] != rk2[sa[i - 1] + k])
					rk[sa[i]] = ++m;
				else rk[sa[i]] = m;
			}
		}
		int k = 0; fill(h, h + n + 2, 0);
		FL(i, 1, n) if(rk[i] > 1){
			if(k) k--;
			while(s[i + k] == s[sa[rk[i] - 1] + k]) k++;
			h[rk[i]] = k;
		}
	}
	void build(char str[]){
		copy(str, str + strlen(str + 1) + 2, s);
		n = strlen(s + 1), ssort();
	}
} sa;
char s[N]; int ans;
void solve(){
	scanf("%s", s + 1), sa.build(s), ans = sa.n / 2;
	FL(i, 1, sa.n){
		int l = max(sa.h[i + 1], sa.h[i]);
		ans = max(ans, l + (sa.n - (sa.sa[i] + l - 1)) / 2);
	}
	printf("%d\n", ans);
}
int main(){
	int T; scanf("%d", &T);
	while(T--) solve();
}
```


---

## 作者：wind_whisper (赞：4)

## $\text{Foreword}$
>"T4 没有人通过在我意料之中（因为我也不会），不过感觉这种题目看起来挺善良其实跟一般 OI 的题目风格还是有点格格不入（在看完题解之后大家大概会理解我为啥这么想），感觉不太符合正常 OI 选手的脑回路，应该丢 CF 上。同时感觉数据不是很强，欢迎大家乱搞试试，不过场上只有写 dp 的，有点遗憾。"—— [@Itst](https://www.luogu.com.cn/user/96296)


一道令人有些哭笑不得的题目。  
感觉真的不算太难,然而由于出现在 T4，习惯性认为是一道重工业字符串题，试图使用类似字符串问题的方式建图跑个最长路或者分奇偶讨论云云，但是却并没有头绪...  
写篇题解来纪念吧。
##  $\text{Solution}$
注意到我们的构造方式一定是先不断以2的步长往右跳，到某个位置突然在跳到前面一个一样的串上，再往右跳...如此循环往复，直到最后一次跳到 $n/n-1$ 为止。  
关键性质：一个串可以成为最后一次“前跳”的串，当且仅当其在原串中出现了不少于两次。  
正向思考似乎有些复杂，反过来考虑。设其两次出现的位置分别为 $(a,b),(c,d)(a< c)$，那么使一开始的串是 $(c,d)$ ，每次令 $(l,r)\to (l-1,r-2)$。若 $l=a$ ，就再次跳到 $c$  的位置即可，如此反复，直到 $l>r$，即空串为止。  
反过来，如果 $T_i$ 只在原串中出现一次，那么使其合法的 $S_i'$ 必然和 $T_i$ 在同样的位置，所以它必然是由 $T_{i-1}$ 经过一次“后跳”得到的。  
证毕。  
有了这个结论，问题就变得很简单了，对于所以出现不止一次的字串 $(l,r)$，其作为答案的贡献就是 $r-l+1+\lfloor \frac {n-r} 2\rfloor$，用SAM或者SA都可以简单维护。  
也可能存在没有任何一次前跳的情况（如样例一的第一组数据），因此答案要向 $\lfloor \frac n 2 \rfloor$ 取 $\max$。
## $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned ll
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("OK\n")
inline ll read() {
  ll x(0),f(1);char c=getchar();
  while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
  while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
  return x*f;
}

const int N=1e6+100;
const double inf=1e18;
const int mod=998244353;

inline ll ksm(ll x,ll k){
  ll res=1;
  while(k){
    if(k&1) res=res*x%mod;
    x=x*x%mod;
    k>>=1;
  }
  return res;
}

int n;

int tr[N][26],len[N],fa[N],pos[N],lst=1,tot=1,siz[N];
inline void ins(int c,int id){
  c-='a';
  int cur=++tot,p=lst;lst=tot;
  len[cur]=len[p]+1;
  pos[cur]=id;
  siz[cur]=1;
  for(;p&&!tr[p][c];p=fa[p]) tr[p][c]=cur;
  if(!tr[p][c]) fa[cur]=1;
  else{
    int q=tr[p][c];
    if(len[q]==len[p]+1) fa[cur]=q;
    else{
      int nq=++tot;
      fa[nq]=fa[q];len[nq]=len[p]+1;
      pos[nq]=n+1;siz[nq]=0;
      for(int i=0;i<26;i++) tr[nq][i]=tr[q][i];
      for(;p&&tr[p][c]==q;p=fa[p]) tr[p][c]=nq;
      fa[q]=fa[cur]=nq;
    }      
  }
  return;
}
vector<int>e[N];
char s[N];
int ans;
void init(){
  for(int i=1;i<=tot;i++){
    memset(tr[i],0,sizeof(tr[i]));
    e[i].clear();
    siz[i]=0;
  }
  tot=lst=1;
}
void dfs(int x){
  for(int to:e[x]){
    //printf("  %d->%d\n",x,to);
    dfs(to);
    siz[x]+=siz[to];
    pos[x]=min(pos[x],pos[to]);
  }
  if(siz[x]>1){
    ans=max(ans,len[x]+(n-pos[x])/2);
    
  }
  //printf("x=%d siz=%d pos=%d len=%d\n",x,siz[x],pos[x],len[x]);
}
void work(){
  init();
  scanf(" %s",s+1);
  n=strlen(s+1);
  //debug("n=%d\n",n);
  for(int i=1;i<=n;i++){
    ins(s[i],i);
  }
  for(int i=2;i<=tot;i++) e[fa[i]].push_back(i);
  ans=n/2;
  dfs(1);
  printf("%d\n",ans);
}

signed main(){
  #ifndef ONLINE_JUDGE
  freopen("a.in","r",stdin);
  freopen("a.out","w",stdout);
  #endif
  int T=read();
  while(T--) work();
  return 0;
}
/*
*/
```


---

## 作者：wjyppm1403 (赞：2)

串串构造题，纪念自己做出来的黑串串构造。大胆猜想！小心求证。

以下定义 $n=|S|$。

我们首先根据题目中给出的第三个条件，我们来看子串 $S$ 在放进 $T_{i}$ 和 $T_{i-1}$ 的形式是怎么样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/zjcdh0i7.png)

那么，由图不难观察到一个很明显的构造过程由 $[l,r]$ 出发，右端点每一次增大 2，左端点每一次增大 1，也就是 $[l,r] \to [l+1,r+2]\to [l+2,r+4] \dots [l+x,r+2x]$。那么有一个显然的移动下界就是最多只能移动 $\dfrac{n}{2}$ 次。那么现在问题在于如何使得这个移动过程能够足够移动多次，首先根据题意不难得出对于每一个 $T_{i}$ 都要保证是 $S$ 的子串，而且我们还要每次从上一个 $T_{i-1}$ 转移过来，也就是说，对全局起决定性作用的在于 $T_{0}$ 的选取，我们怎么选取才能最好呢？

哎，我有一计！$T_{0}$ 是子串，子串又没有说非空子串，那我选空子串，那么后面的操作相当于就是找长度为 1 的子串，找长度为 2 的子串，以此类推下去。证明当 $T_{0}$ 是空串时存在最优解是显然的。

但是我们上面还有一个前后缀的性质，也就是说 $T_{i}$ 由 $T_{i-1}$ 加一个字符过来，并且还要求是一个原字符串一个子串的前后缀，那什么情况下能满足加一个字符是子串的前后缀呢？我们从我们选取的子串下手：

![1752021135191.png](https://img.picui.cn/free/2025/07/09/686db8869e000.png)

那么也就是说如果 $S$ 选一个前缀加一个字符放到后面拼后缀还能和原来重合？那么，也就是说，这个我们构造的串至少要在 $S$ 种出现两次这样的话我们才能扩大区间，感性理解就是如果不这样的话你转移到 $T_{i}$ 前后缀都覆盖不了啊，是无法满足的，严谨证明可以考虑反证法。

那么有两个这个结论，我们找一个至少出现两次的子串 $[l,r]$，那么首先区间能拓展 $r-l+1$，右端点每次跳两步也就是说还有 $\dfrac{n-r}{2}$，那么答案就是 $r-l+1 + \dfrac{n-r}{2}$。这个我们用 SAM 和 SA 可以轻松维护的，我用 SAM 因为维护至少出现两次很简单的。

注意一下，答案下界是 $\dfrac{n}{2}$，可能存在没有任何拓展的情况，所以最后结果是 $\max(\dfrac{n}{2},ans)$。代码其实很好写，也是我见过为数不多好写的黑题了 www。

```cpp
#define ll long long
using namespace std;
constexpr int MN=1e6+15;
int n;
ll ans;
string s;

struct SAM{
    int nxt[MN][26],fa[MN],len[MN],cnt[MN],pos[MN],mnpos[MN],tot,lst;
    vector<int> adj[MN];


    int newnode(){
        int cur=++tot;
        mnpos[cur]=1e9;
        fa[cur]=len[cur]=cnt[cur]=0;
        adj[cur].clear();
        memset(nxt[cur],0,sizeof(nxt[cur]));
        return cur;
    }

    void init(){
        tot=lst=0;
        tot=lst=newnode();
    }

    int clone(int from){
        int cur=newnode();
        fa[cur]=fa[from];
        memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));
        return cur;
    }

    void expand(int c){
        int cur=newnode();
        len[cur]=len[lst]+1;
        int p=lst;
        while(p&&!nxt[p][c]) nxt[p][c]=cur,p=fa[p];
        if(!p){
            fa[cur]=1;
        }else{
            int q=nxt[p][c];
            if(len[q]==len[p]+1){
                fa[cur]=q;
            }else{
                int nq=clone(q);
                len[nq]=len[p]+1;
                fa[q]=fa[cur]=nq;
                while(p&&nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];
            }
        }
        lst=cur;
    }

    void inittree(){
        for(int i=2;i<=tot;i++){
            adj[fa[i]].push_back(i);
        }
    }

    void dfs(int u){
        for(auto v:adj[u]){
            dfs(v);
            cnt[u]+=cnt[v];
            mnpos[u]=min(mnpos[u],mnpos[v]);
        }
        if(cnt[u]>=2){
            ans=max(ans,1ll*len[u]+(n-mnpos[u])/2);
        }
    }

}sam;

void init(){
    sam.init();
}

void solve(){
    init();
    cin>>s;
    n=s.length();
    s=" "+s;
    for(int i=1;i<=n;i++){
        sam.expand(s[i]-'a');
        sam.cnt[sam.lst]++;
        sam.mnpos[sam.lst]=i;
    }
    sam.inittree();
    ans=n/2;
    sam.dfs(1);
    cout<<ans<<'\n';
}

int main(){
    int T;
    cin>>T;
    while(T--){
        solve();
    }

    return 0;
}

```

---

## 作者：syzf2222 (赞：2)

> "T4 没有人通过在我意料之中（因为我也不会），不过感觉这种题目看起来挺善良其实跟一般 OI 的题目风格还是有点格格不入（在看完题解之后大家大概会理解我为啥这么想），感觉不太符合正常 OI 选手的脑回路，应该丢 CF 上。同时感觉数据不是很强，欢迎大家乱搞试试，不过场上只有写 dp 的，有点遗憾。"

>by Itst

我只能说我很认同。我找不到做这个题的训练意义，也就是我很难从中学到东西。

首先，貌似大家都默认了 $T_0=\epsilon$ 了，不要怀疑，要有信念。

观察样例发现，我们有一个简单的 $\lfloor \frac n2\rfloor$ 的构造，每次左端点往右挪一个，串长也多一。如果我们想要使得答案更大，那么显然是要有一步往回跳的，考虑最后一次往回跳的那个串，如果我能从空串走到它那么就能非常方便地计算答案。

考察这个串的性质。首先它至少要出现两次，不然你跳啥呢。一个结论是只要出现两次就一定能从空串走到它。考虑拿出两次出现的位置 $[l_1,r_1],[l_2,r_2],l_1<l_2$，若 $r_1<l_2$，则 $r_2\geqslant 2len$，都不用跳直接走就能走到它；若 $r_1\geqslant l_2$，只要能走到 $[l_2-x,r_2-2x]$ 就行，考虑对串长归纳，也就是 $\exists x>0,[l_2-x,r_2-2x]\in[l_1,r_1]$ 就行，直接取 $x=l_2-l_1$ 就行。

随便建个 SAM 算算就完事了。

此题的关键，一是要坚定可以从空串开始的信念，二是要大胆猜测结论。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
const int mod=1e9+7;
#define inf 1e9
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
int T,n,m,nxt[maxn][26],lk[maxn],sz[maxn],len[maxn],cnt;
char S[maxn];int ans=0,Mn[maxn];
inline int extend(int las,int x,int ps){
	int now=++cnt,pos=las,tmp,cln;
	len[now]=len[pos]+1;sz[now]=1;Mn[now]=ps;
	while(pos&&!nxt[pos][x])nxt[pos][x]=now,pos=lk[pos];
	if(!pos){lk[now]=1;return now;}
	tmp=nxt[pos][x];
	if(len[tmp]==len[pos]+1){lk[now]=tmp;return now;}
	cln=++cnt;len[cln]=len[pos]+1;Mn[cln]=inf;
	for(int i=0;i<26;i++)nxt[cln][i]=nxt[tmp][i];
	lk[cln]=lk[tmp];lk[tmp]=lk[now]=cln;
	while(pos&&nxt[pos][x]==tmp)nxt[pos][x]=cln,pos=lk[pos];
	return now;
}
vector<int>G[maxn];
inline void dfs(int x){
	for(auto t:G[x])dfs(t),sz[x]+=sz[t],Mn[x]=min(Mn[x],Mn[t]);
	if(sz[x]>1)ans=max(ans,len[x]+(n-Mn[x])/2);
}
inline void solve(){
	scanf("%s",S+1);n=strlen(S+1);
	int las=++cnt;
	for(int i=1;i<=n;i++)
		las=extend(las,S[i]-'a',i);
	for(int i=2;i<=cnt;i++)
		G[lk[i]].push_back(i);
	ans=n/2;dfs(1);
	printf("%d\n",ans);
	for(int i=1;i<=cnt;i++){
		sz[i]=lk[i]=len[i]=0;G[i].clear();
		for(int j=0;j<26;j++)nxt[i][j]=0;
	}cnt=0;
}
int main(){
	T=read();while(T--)solve();
	return 0;
}
```

深深地感到自己的弱小。

---

## 作者：henryhu2006 (赞：2)

独立做完这题感觉自己的观察能力有所提高。

首先进行一些比较显然的观察：

1. 假设 $T_0$ 的左右端点分别为 $l,r$，那么 $T_1$ 如果采用 $[l-1,r]$ 作为母串，那么 $T_1$ 为 $[l-1,r-2]$。如果 $r$ 一开始为 $n$，那么每次 $-2$，所以答案最少为 $\lfloor \frac{n}{2}\rfloor$。

2. 在一个位置 $l=x$，如果当前序列的长度为 $m$，那么如果 $\text{lcp}(l,y+1)\ge m$，则 $y$ 可以作为新的 $l$。

3. 对于大于 $\lfloor\frac{n}{2}\rfloor$ 的方案，其所有的 $T_i$ 的 $l$ 组成的序列一定可以划分成 $\ge 2$ 个连续段。


接下来需要观察连续段的性质：

3. 考虑所有不是第一层的连续段，如果第一层的 $l$ 在 $x$ 处结束，在第二层中从 $y$ 开始，那么说明 $\text{lcp}(l,y+1)\ge m$，之后 $m$ 一路下降，到 $x$ 结束一个连续段时一定可以从 $y$ 开始下一个连续段。所以 $T_l$ 一定可以到空。**因此在 $[x,y]$ 之间反复横跳是不劣的。**

4. 如果选择了 $[x,y]$，设 $\text{lcp}(x,y+1)=k$，那么当 $l$ 最大时，第一层左端点位于 $x$ 时，长度一定为 $k$。所以第一层在 $x$ 的右侧（使用第一个结论），最多容纳且一定能容纳 $\lfloor\dfrac{n-(i+k-1)}{2}\rfloor$ 个项。

所以总的长度为：

$$
k+\lfloor\dfrac{n-i-k+1}{2}\rfloor=\lfloor\dfrac{n-i+k+1}{2}\rfloor
$$

由于 $n+1$ 是常量，所以需要最大化 $k-i$ 的值。对于每个 $i$，最大的 $k$ 一定是和后缀字典序邻居的 $\text{lcp}$。

5. 虽然要求 $x\le y$，但是 $k-x$ 显然 $\ge k-y$，所以 $k-y$ 不需要被排除，直接取 $\max$。

于是 $k-i$ 的最大值即为：

$$
\max_{i=1}^n\bigg(\max\{\text{height}_i,\text{height}_{i+1}\}-\text{sa}_i\bigg)
$$

于是就变成了后缀数组求 $\text{height}$ 的板，时间复杂度 $\mathcal O(n\log n)$ 或 $\mathcal O(n)$。**多测要清空！**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int T,n,m;
int sa[N],rk[N],s[N],t[N],cnt[N],h[N];
char str[N];
void ins(int *t){
	memset(cnt,0,(m+1)*4);
	for(int i=1;i<=n;++i) ++cnt[t[i]];
	for(int i=1;i<=m;++i) cnt[i]+=cnt[i-1];
}
void radix(){
	ins(t);
	for(int i=1;i<=n;++i) rk[i]=cnt[t[i]]--;
	for(int i=1;i<=n;++i) sa[rk[i]]=i;
	ins(s);
	for(int i=n;i;--i) rk[sa[i]]=cnt[s[sa[i]]]--;
	for(int i=1;i<=n;++i) sa[rk[i]]=i;
	rk[sa[1]]=1;
	for(int i=2;i<=n;++i)
		rk[sa[i]]=rk[sa[i-1]]+(s[sa[i]]!=s[sa[i-1]]||t[sa[i]]!=t[sa[i-1]]);
	m=rk[sa[n]];
}
void getsa(){
	for(int i=1;i<=n;++i) s[i]=str[i]-'a';
	radix();
	for(int k=1;k<=n;k<<=1){
		for(int i=1;i<=n;++i) s[i]=rk[i],t[i]=(i+k>n?0:rk[i+k]);
		radix();
		if(m==n) break;
	}
	for(int i=1;i<=n;++i) sa[rk[i]]=i;
}
void geth(){
	int j,k=0;
	for(int i=1;i<=n;++i){
		if(rk[i]==1) continue;
		if(k) --k;
		int j=sa[rk[i]-1];
		while(j+k<=n&&i+k<=n&&str[j+k]==str[i+k]) ++k;
		h[rk[i]]=k;
	}
}
int main(){
	cin>>T;
	while(T--){
		scanf("%s",str+1),n=strlen(str+1),m=27;
		getsa(),geth();
		int res=-1;
		for(int i=1;i<=n;++i) res=max(res,max(h[rk[i]],h[rk[i]+1])-i);
		res=(res+n+1)/2;
		printf("%d\n",res);
		memset(sa+1,0,4*n);
		memset(rk+1,0,4*n);
		memset(h+1,0,4*n);
		memset(s+1,0,4*n);
		memset(t+1,0,4*n);
	}
	return 0;
}
```

---

## 作者：FjswYuzu (赞：2)

先读懂题目，看懂这个字符串序列到底在干什么。容易发现答案的下界是 $\left\lfloor \dfrac{|s|}{2} \right\rfloor$，大概是考虑 $T_1 = S[2], T_2 = S[3\dots 4],T_3 = S[4 \dots 6],\cdots$，这样 $T_i$ 的右端点在 $2i$，可以发现答案下界是 $\left\lfloor \dfrac{|s|}{2} \right\rfloor$。

然后考虑这样一个事情，答案要比下界大，我们应该在某一个时刻往回跳。假设选完 $T_i$ 之后往回跳了，需要满足 $T_i$ 这个串在 $S$ 里出现两次（可以重叠），思考之后发现这是充要条件：

- 首先如果一个串只出现一遍，怎么可能可以往回跳（充分性）；   
- 然后 $T_i$ 在 $S$ 里出现两次，记两次出现的位置的左端点为 $l_1,l_2$：
  - 如果两个串没有重叠：考虑倒推，$T_i$ 的右端点向左移两位，左端点向左移一位，需要满足 $l_1 \geq r-l+2$，因为两串不重叠，因此 $l_1 \geq r-l+2$ 显然；    
  - 如果两个串重叠：仍然考虑倒推，但是前面没有足够的空位，注意到我们跳着跳着就跳成了 $T_i$ 的一个前缀，这样可以往后回跳，直到回到 $T_0$。

因此这个结论是充要的。我们只关心最后一次回跳，那么记最后一次回跳回到了位置 $[l,r]$，答案就是 $r-l+1 + \left\lfloor\dfrac{n-r}{2}\right\rfloor$。显然我们选 $r$ 最小的就好了。

这个东西可以很简单的用后缀自动机维护。在每个实结点上记下对应的字符编号，虚结点记为无穷大，最后每个点对应的字符串集合第一次出现的位置的右端点为 Parent 树子树内的最小值。出现次数就是子树内实结点个数。判断即可。

```cpp
struct SAM{
	int fa[1000005],len[1000005],siz[1000005];
	int ch[1000005][26];
	int R[1000005];
	int cnt,lst;
	void init()
	{
		for(int i=1;i<=cnt;++i)	fa[i]=0,memset(ch[i],0,sizeof ch[i]),len[i]=siz[i]=R[i]=0;
		cnt=lst=1;
	}
	void extend(int c,int id)
	{
		int p=lst,cur=++cnt;
		len[cur]=len[p]+1;
		R[cur]=id;
		lst=cur;
		while(!ch[p][c])	ch[p][c]=cur,p=fa[p];
		if(!p)	fa[cur]=1;
		else
		{
			int q=ch[p][c];
			if(len[q]==len[p]+1)	fa[cur]=q;
			else
			{
				int clone=++cnt;
				len[clone]=len[p]+1;
				memcpy(ch[clone],ch[q],sizeof ch[q]);
				fa[clone]=fa[q];
				fa[q]=fa[cur]=clone;
				while(ch[p][c]==q)	ch[p][c]=clone,p=fa[p];
			}
		}
		siz[cur]=1;
	}
}sam;
char s[500005];
int fa[1000005],siz[1000005],len[1000005],R[1000005];
int n,N;
vector<int> G[1000005];
void dfs(int u){for(auto v:G[u])	dfs(v),siz[u]+=siz[v],R[u]=min(R[u],R[v]);}
void Solve()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	sam.init();
	for(int i=1;i<=n;++i)	sam.extend(s[i]-'a',i);
	N=sam.cnt;
	for(int i=1;i<=N;++i)	siz[i]=sam.siz[i],fa[i]=sam.fa[i],len[i]=sam.len[i],R[i]=(sam.R[i]==0?n+1:sam.R[i]);
	for(int i=1;i<=N;++i)	G[i].clear();
	for(int i=2;i<=N;++i)	G[fa[i]].push_back(i);
	dfs(1);
	int ans=0;
	for(int i=1;i<=N;++i)	if(siz[i]>=2)	ans=max(ans,len[i]+(n-R[i])/2);
	printf("%d\n",ans);
}
```

---

## 作者：Remilia1023 (赞：2)

## 前言
没有黑吧 $\cdots\cdots$，简单分析构造方法之后直接 SAM 板子了。

本篇侧重于解释答案的由来。

## 约定

$(l,r)$ 表示 $S$ 的子串 $S_{l-r}$。
## 题解

相邻 $T_i$ 的长度差为 $1$，题目中 $T_{i-1}$ 作为前缀，$T_i$ 作为后缀，很容易可以发现一种 $T$ 的嵌套式构造方法。
![](https://s1.ax1x.com/2023/01/31/pS0aBbn.png)


每次 $(l,r)\rightarrow(l+1,r+2)$，并且无法找到一种更优的构造策略。

---
1. 直接构造

从空串 $(0,0)$ 开始，每次往后跳两步，最多跳 $\displaystyle\left\lfloor \frac{n}{2} \right\rfloor$ 次达到答案上界。

2. **存在** $T_i$ 在 $S$ 中出现了**至少两次**

此时直接正着构造是很难统计答案的，正难则反，考虑反过来构造，此时变为往前跳，每次 $(l,r)\rightarrow (l-1,r-2)$，长度减 $1$。

题目中对于 $T_i$ 的出现位置没有限制，只要求存在即可，于是假设 $T_i$ 某两次出现的位置分别是 $(a, b),(c,d) \hspace{0.4em} (a<c)$，它们之间是可以相互替代的。

假设初始状态为 $(a,b)$，只要左端点到 $a$，就跳回 $c$，可以证明一定能跳。

>证明：因为 $(a,b)=(c,d)$，所以 $(a,a+x)=(c, c+x)\hspace{0.4em}(x\le b - a)$，由于初始状态是 $(a,b)$，每跳一次串长都减小 $1$，因此 $x\le b-a$ 恒成立，所以一定能跳。

每次往前跳串长减 $1$，能直接把整个串删完，这部分贡献为 $b-a+1$。

显然我们一开始并不会从 $(a,b)$ 开始跳，这样 $S$ 的右边一部分被浪费了，可以找到一个位置，使得 $T$ 往前跳时刚好会到达 $(a,b)$ 这个状态，即从 $(a+\displaystyle\left\lfloor \frac{n-b}{2} \right\rfloor,b+2\times\displaystyle\left\lfloor \frac{n-b}{2} \right\rfloor) $ 开始跳，加上这部分被浪费的贡献为 $\displaystyle\left\lfloor \frac{n-b}{2} \right\rfloor $。

综上，从**至少出现两次**的子串 $(l,r)$ 开始的答案为 $r-l+1+\displaystyle\left\lfloor \frac{n-r}{2} \right\rfloor$。

---
可以用 SAM 很方便的实现，对于每个节点记录最靠左的 $endpos$，如果当前节点的出现次数 $size > 1$，则对答案取 $\max$。

也可以直接构造，所以答案不要忘了对 $\displaystyle\left\lfloor\frac{n}{2}\right\rfloor$ 取 $\max$。

---


```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
int T, n, tot, lst, ans, len[N], fa[N], ch[N][26], mi[N], siz[N], deg[N];
char s[N];

void Extend(int c, int id)
{
  int f = lst, p = lst = ++tot;
  siz[p] = 1;
  len[p] = len[f] + 1;
  mi[p] = id;
  while (f && !ch[f][c]) 
    ch[f][c] = p, f = fa[f];
  if (!f) return fa[p] = 1, void();
  int x = ch[f][c];
  if (len[x] == len[f] + 1) fa[p] = x;
  else {
    int y = ++tot;
    len[y] = len[f] + 1;
    fa[y] = fa[x], fa[x] = fa[p] = y;
    while (f && ch[f][c] == x) 
      ch[f][c] = y, f = fa[f];
    memcpy(ch[y], ch[x], sizeof ch[x]);
  }
}

int main()
{
  cin >> T;
  for (int i = 1; i <= 1e6; i++) mi[i] = 1e9;
  while (T--) {
    cin >> s + 1;
    n = strlen(s + 1);
    tot = lst = 1;
    for (int i = 1; i <= n; i++) 
      Extend(s[i] - 'a', i);
    queue<int> q;
    for (int i = 1; i <= tot; i++) deg[fa[i]]++;
    for (int i = 1; i <= tot; i++) 
      if (deg[i] == 0) q.push(i);
    while (!q.empty()) {
      int u = q.front(), f = fa[u]; q.pop();
      if (--deg[f] == 0) q.push(f);
      mi[f] = min(mi[f], mi[u]);
      siz[f] += siz[u];
    }
    ans = n / 2;
    for (int i = 1; i <= tot; i++)
      if (siz[i] > 1) 
        ans = max(ans, (n - mi[i]) / 2 + len[i]);
    cout << ans << endl;
    for (int i = 1; i <= tot; i++) {
      memset(ch[i], 0, sizeof ch[i]);
      siz[i] = 0, mi[i] = 1e9;
    }
  }
  return 0;
}
```

---

## 作者：strlen_s_ (赞：1)

同学把这题推荐了给我，是一道比较考验思维的好题，所以写一篇题解来总结一下。

题意：

给定一个英文小写字母构成的字符串 $S$，你需要找到一个尽可能长的字符串序列 $(T_0, T_1, \ldots, T_l)$，满足：

1. $T_0$ 是 $S$ 的子串；
2. $\forall 1 \le i \le l$，$\lvert T_i \rvert - \lvert T_{i - 1} \rvert = 1$；
3. $\forall 1 \le i \le l$，存在 $S$ 的一个长度为 $\lvert T_i \rvert + 1$ 的子串 $S'_i$，使得 $S'_i$ 的长度为 $\lvert T_{i - 1} \rvert$ 的前缀为 $T_{i - 1}$，长度为 $\lvert T_i \rvert$ 的后缀为 $T_i$。

输出这样的字符串序列的长度的最大值（即 $l$ 的最大值）。

首先审题。发现题目要我们最大化一个奇怪的东西，让我们构造一个序列 $T$，最大化序列的长度。可以考虑 DP 来构造这个 $T$ 序列，但发现状态数也非常庞大，难以构造，所以不考虑用 DP 来求正解。

既然无法从 $T$ 这个序列本身下手，那么我们考虑从这个串 $S$  本身入手，观察 $S$ 与 $T_i$ 的关系。通过第三个要求，我们考虑在序列 $T_i$ 后再加一个串 $T_{i+1}$，那么就要求 $T_i$ 要是 $S'_{i+1}$ 的前缀，而 $T_{i+1}$ 是 $S'_{i+1}$ 的后缀，所以 $S'_{i+1}$ 就相当与在 $S'_i$ 后又加了两个字符，并减去 $S_i$ 前面的一个字符，配合图可能可以更好理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/c7ksvam8.png)


于是我们可以从下标 $0$ 开始，每次右端点不断向右扩 $2$，左端点向右缩 $1$，那么这至多扩展 $\lfloor \dfrac{n}{2} \rfloor$ 次，所以答案下界为 $\lfloor \dfrac{n}{2} \rfloor$。

那么一个串中字串可能出现多次，当你跳到一个位置时，发现前面这个串已经出现过了，就可以跳到前面这个串出现的位置。我们把这个过程称之为前跳。显然，一个串可以前跳的充要条件是这个串在字符串中出现了至少两次。但我们发现这个前跳的过程非常难以维护，因为字符串长度是在不断增加的，而可以前跳的字符串呈现一种包含关系，所以可以前跳的字符串的集合大小是不断减小的，而这种减小非常难以维护，这就是为什么我们要反过来想，假设这个字串长度不断减小，那么这个集合里的元素是不断增加的，而这些字符串又有包含关系，所以一些元素增加的贡献就可以忽略不计，这就非常方便我们计算答案了。

那么反过来，考虑最后一次前跳的字符串的位置在 $[l,r]$，那么它就可以不断减小，不断地跳。当这个字串再次跳到这个区间时，它已经成为了 $[l,r]$ 的一个子串了，而一个字串前跳的条件是它在原串中至少出现了两次，所以这个子串也必定已经出现了两次了，所以可以再前跳回去，一直重复知道长度为 $0$。而当它已经在 $[l,r]$，无法再前跳时，它这部分的贡献就是 $\lfloor \dfrac{n-r}{2} \rfloor$，总贡献就是 $r-l+1+\lfloor \dfrac{n-r}{2} \rfloor$。


题目转化为对于一个出现了至少两次的字符串 $[l,r]$，求：

$$
\max{(r-l+1+\lfloor \dfrac{n-r}{2} \rfloor)}
$$

那么这就可以用 SAM 维护了，最后记得跟下界 $\lfloor \dfrac{n}{2} \rfloor$ 取一个最大值。

### code:

```
#include<bits/stdc++.h>
#define in inline
#define re register
//#define int long long
using namespace std;
typedef long long LL;
const int N=1e6+10;
struct tree{
    int len,fa,ch[26];
}t[N];
int top=1,last=1;
int h[N],nex[N],to[N],tot;
int siz[N],ans,ma[N];
int T,n,k;
char c[N];
void init(){
    for(int i=1;i<=top;i++)t[i]=t[0],h[i]=siz[i]=ma[i]=0;
    top=last=1;
    tot=0;
}
int clone(int x){t[++top]=t[x];return top;}
void insert(int x,int y){
    int cur=++top;t[cur].len=t[last].len+1;siz[cur]=1;ma[cur]=(n-y)/2;
    while(!t[last].ch[x]&&last)t[last].ch[x]=cur,last=t[last].fa;
    if(!last){t[cur].fa=1;last=cur;return;}
    int p=t[last].ch[x],q=last;
    if(t[p].len==t[q].len+1){t[cur].fa=p;last=cur;return;}
    int c=clone(p);t[c].len=t[q].len+1;t[p].fa=t[cur].fa=c;
    while(t[q].ch[x]==p&&q)t[q].ch[x]=c,q=t[q].fa;last=cur;
}
void add(int x,int y){to[++tot]=y,nex[tot]=h[x],h[x]=tot;}
void dfs(int u){
    for(int i=h[u];i;i=nex[i]){
        int v=to[i];
        dfs(v);
        siz[u]+=siz[v];
        ma[u]=max(ma[u],ma[v]);
    }
}
int calc(){
    for(int i=2;i<=top;i++)add(t[i].fa,i);
    dfs(1);
    int ans=n/2;
    for(int i=2;i<=top;i++){
        if(siz[i]<2)continue;
        ans=max(ans,t[i].len+ma[i]);
    }
    return ans;
}
void work(){
    cin>>c;
    n=strlen(c);
    for(int i=0;i<n;i++)insert(c[i]-'a',i+1);
    cout<<calc()<<endl;
    init();
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>T;
    while(T--)work();
    return 0;
}
```

启示：

1. 对于难以维护的信息，可以更换对象间接求解。

2. 对于这种区间包含的情况，增加长度意味着删除区间，可以逆向思考，反向操作，变减为加，方便处理。

---

## 作者：居然有个高手 (赞：0)

我们考虑一个最基本的下界构造：将空串代表区间视为 $[1,0]$，则我们每次把 $[i,j]$ 迭代成 $[i+1,j+2]$ 一定合法。因此答案长度至少为 $\lfloor \frac n 2\rfloor$。

考虑如何把答案构造得更大，发现是当一个合法串 $T$ 在 $s$ 中出现了多次，那么当上述过程取到 $T$ 的某一次出现区间时，它可以跳回 $T$ 第一次出现的位置，这个过程可以看作对 endpos 等价类进行转移，启发我们对于 endpos 进行考虑。不妨考虑长度为 $i$ 时，所有合法串的 endpos 的集合为 $S_i$（易知 $S_0=[0,n]$）。则 $S_{i+1}$ 中的每个元素 $x$ 满足存在一个与其在同 endpos 等价类的元素 $y$，使得 $y-2$ 在 $S_i$ 中。

根据上面的转移过程，我们发现 $S_i$ 一定是 $[p,n]$ 的形式，且若 $S_{i-1} = [p,n]$，$S_i = [q,n]$，则 $p\le q\le p+2$。

尝试证明 $S_i$ 一定是一段后缀。反证法，若 $p$ 在 $S_i$ 中且 $p+1$ 不在 $S_i$ 中，则 $p$ 一定是由同 endpos 等价类中的点转移而来，设转移来的位置为 $x$。可以得到 $x-1 \in S_{i-1}$ 中，则 $p-1 \in S_{i-1}$，则 $p+1$ 应当在 $S_i$ 中，矛盾。后一个结论是容易理解的。

因此，我们枚举当前串长 $len$，维护当前的最小位置 $p$ 即可。实际实现中用 SAM 维护 endpos 等价类，在 parent 树上倍增求祖先，预处理最大位置即可。

时间复杂度：$O(n\log n)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+5;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
int T,n,last,tot,root[N],f[19][N],ed[N],mx[N],head[N],etot;
char s[N];
struct edge{
	int nxt,to;
}e[N<<1];
inline void add(int a,int b){
	e[++etot]={head[a],b};head[a]=etot;
}
struct SAM{
	int fa,len,ch[26];
}t[N];
inline int newnode(){
	int p=++tot;
	for(int i = 0;i<26;i++)t[p].ch[i]=0;
	mx[p]=0;
	return p;
}
inline void insert(int c,int id){
	int p=last,np=last=newnode();
	t[np].len=t[p].len+1;mx[np]=id;ed[id]=np;
	for(;~p&&!t[p].ch[c];p=t[p].fa)t[p].ch[c]=np;
	if(p==-1){
		t[np].fa=0;
		return;
	}
	int q=t[p].ch[c];
	if(t[q].len==t[p].len+1){
		t[np].fa=q;
		return;
	}
	int now=newnode();
	t[now].fa=t[q].fa;t[now].len=t[p].len+1;t[np].fa=t[q].fa=now;
	for(int i = 0;i<26;i++)t[now].ch[i]=t[q].ch[i];
	for(;~p&&t[p].ch[c]==q;p=t[p].fa)t[p].ch[c]=now;
}
inline void dfs(int x){
	for(int i = head[x],y;i;i=e[i].nxt){
		y=e[i].to;
		dfs(y),mx[x]=max(mx[x],mx[y]),f[0][y]=x;
	}
}
inline bool check(int x,int g,int len){
	if(x<len ||x>n)return 0;
	x=ed[x];
	for(int j = 18;j>=0;j--)if(t[f[j][x]].len >= len)x=f[j][x];
	return mx[x]>=g;
}
int main(){
	// freopen("string16.in","r",stdin);
	T=read();
	while(T--){
		scanf("%s",s+1);n=strlen(s+1);
		// EDT::clear();
		last=tot=0;t[0].fa=-1;
		for(int i = 0;i<26;i++)t[0].ch[i]=0;
		for(int i = 1;i<=n;i++)insert(s[i]-'a',i);
		etot=0;
		for(int i = 0;i<=tot;i++)head[i]=0;
		for(int i = 1;i<=tot;i++)add(t[i].fa,i);
		// cerr<<"???"<<endl;
		dfs(0);
		for(int j = 1;j<=18;j++)for(int i = (1<<j);i<=tot;i++)f[j][i]=f[j-1][f[j-1][i]];
		int now = 0,len=0;
		while(now<=n){
			// cerr<<now<<' '<<len<<endl;
			len++;
			if(check(now,now+2,len));
			else if(check(now+1,now+2,len))now++;
			else {
				if(now+2>n){
					len--;
					break;
				}
				now+=2;
			}
		}
		printf("%d\n",len);
	}
	// cerr<<clock()<<endl<<q;
	return 0;
}
```

---

## 作者：User_Unauthorized (赞：0)

可以发现，将 $T_0$ 设为空串，$T_1$ 为 $S_{1 \dots 1}$，之后每次将左右端点 $l, r$ 执行 $l \leftarrow l + 1, r \leftarrow r + 2$ 便可以得到一个 $\left\lfloor\dfrac{N}{2}\right\rfloor$ 的构造，进而确定了答案下界。

考虑如何优化答案，发现若一个子串在 $S$ 中出现两次，设其第一次出现右端点为 $r$，长度为 $len$，那么可以得到一个 $len + \left\lfloor\dfrac{N - r}{2}\right\rfloor$ 的构造，对所有出现多次的子串求出最大值即可，这一部分可以使用后缀自动机实现。

同时我们只需要考虑最后一次跳转，因为在最后一次跳转前的过程可以认为每次字符串的长度均会加一，所以在这个过程中无论如何跳转都不会影响答案。

---

## 作者：eastcloud (赞：0)

[更好的阅读体验](https://www.cnblogs.com/eastcloud/p/17090496.html)

### 题目分析

题目要求我们构造一个最长的 $T$ 序列，我们首先从每个 $T_i$ 入手，思考如何安排才能合法。

容易观察到对于每个 $T_i$，合法的 $T_{i-1}$ 有两种方式构造，要么直接为上一个字符串左右端点平移得到，要么找到另外一个等于 $T_i$ 的子串再平移得到，这似乎启发我们使用 SAM 对 endpos 集合进行维护，但思考后发现这似乎不容易实现，于是我们转换思考方式。

着眼于构造方式而非字符串，由于每次从大到小构造时，如果没有重复子串，构造过程相当于向左移动一个单位并且长度缩短，我们可以从中得到一个答案的下界：$\left\lfloor\dfrac{|s|}{2}\right\rfloor$。

如果加上重复子串呢，可以发现从右到左地更换匹配位置答案只会变坏，而从左到右则就相当于如果原先长度还没减完就移动到了左端点，现在从左往右更换则为其“续命”，可以让他继续移动，并且后面构造出的 $T$ 也会在原串中出现至少两次，可以继续“续命”。

结合上述讨论，我们可以将 $T$ 数组分为两种情况，分别为一段出现两次，一段出现一次与只出现一次的，后者答案的最大值即为 $\left\lfloor\dfrac{|s|}{2}\right\rfloor$。前者由于必然经过一个出现过两次的字符串，我们可以用 SAM 在此处统计，每个左右端点分别为 $l$，$r$，出现过两次的字符串对答案的贡献为 $r-l+1+ \left\lfloor\dfrac{n-r}{2}\right\rfloor$。

### 代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#define ll long long
#define N 1500005
using namespace std;
string s[N];
int len[N<<1],fa[N<<1],nex[N<<1][27];
int head[N<<1],ne[N<<1],to[N<<1],en[N<<1],sum[N<<1];
int last=1,tot=1,e,ans=0,le;
void insert(int num){
	int p=last,np=++tot;last=np;
	len[np]=len[p]+1;
	en[np]=en[p]+1;sum[np]=1;
	for(;p && !nex[p][num];p=fa[p])nex[p][num]=np;
	if(!p) fa[np]=1;
	else{
		int q=nex[p][num];
		if(len[q]==len[p]+1) fa[np]=q;
		else{
			int clone=++tot;len[clone]=len[p]+1;
			fa[clone]=fa[q];fa[q]=fa[np]=clone;
			for(int i=1;i<=26;i++) nex[clone][i]=nex[q][i];
			for(;p && nex[p][num]==q;p=fa[p]) nex[p][num]=clone;
		}
	}
}
void addedg(int u,int v){
	to[++e]=v;ne[e]=head[u];head[u]=e;
	to[++e]=u;ne[e]=head[v];head[v]=e;
}
void dfs(int x,int fa){
	if(!en[x]) en[x]=0x3f3f3f3f;
	for(int i=head[x];i;i=ne[i]){
		int v=to[i];
		if(v==fa) continue;
		dfs(v,x);en[x]=min(en[x],en[v]);sum[x]+=sum[v];
	}
	if(sum[x]>1)ans=max(ans,len[x]+(le-en[x])/2);
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>s[i];
	for(int i=1;i<=n;i++){
		le=s[i].length();
		for(int j=0;j<le;j++) insert(s[i][j]-'a'+1);
		for(int j=2;j<=tot;j++){
			addedg(j,fa[j]);
		}
		dfs(1,0);
		ans=max(ans,le/2);
		cout<<ans<<endl;
		ans=0;
		for(int j=1;j<=e;j++)to[j]=ne[j]=0;
		for(int j=1;j<=tot;j++) head[j]=0;
		for(int j=1;j<=tot;j++) fa[j]=len[j]=sum[j]=en[j]=0;
		for(int j=1;j<=tot;j++) for(int k=1;k<=26;k++) nex[j][k]=0;
		tot=1;last=1;e=0;
	}
	
}
```


---

## 作者：glorious_dream (赞：0)

首先感谢 [高一零起点 Au 的学长](https://www.luogu.com.cn/user/449265) 对本蒟蒻的细心教导。

[题目传送门](https://www.luogu.com.cn/problem/P8368)

## 题意分析
给定一个英文小写字母构成的字符串 $S$，找到一个尽可能长的字符串序列$(T_0,T_1,\dots,T_l)$，满足：

 - $T_0$ 是 $S$ 的子串；
 - $\forall 1 \leq i \leq l$，$\mid T_i \mid - \mid T_{i-1} \mid = 1$；
 - $\forall 1 \leq i \leq l$，存在 $S$ 的一个长度为 $\mid T_i \mid + 1$ 的子串 $S'_i$，使得 $S'_i$ 的长度为 $\mid T_{i-1} \mid$ 的前缀为 $T_{i-1}$，长度为 $\mid T_i \mid$ 的后缀为 $T_i$。

输出这样的字符串序列的长度最大值$($即 $l$ 的最大值$)$。

## 算法分析
俗话说，正难则反。我们逆向来想如何构造可行的字符串。那么可以按如下方法构造：$[i,j] \rightarrow [i-1,j-2] \rightarrow [i-2,j-4] \rightarrow \dots$ 一直这样下去，直到长度为 $0$ 或者到头了。那么答案有一个最小值是 $\lfloor n/2 \rfloor$。

用下面的图能很好的说明为什么这么构造是合法的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e18ffe4c74fe45a599b449b5bfd1a24d.png)

由于题目中说一个是前缀，一个是后缀，那么这么构造就行。接下来的 $T_{i-2}$ 与这种构造方法相同。

![在这里插入图片描述](https://img-blog.csdnimg.cn/9f68207ca9c04aae9df56892c3600517.png)

解决完合法性，我们考虑如何统计答案。上文中说到，答案有一个下界是 $\lfloor n/2 \rfloor$，这种情况是一直往前跳，跳到空串为止。那么有没有情况是可以更新这个答案的呢？有！看下面这张图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0d4c65c7c76d43ddb9e369d3e9e5db09.png)

字符串 $T_{i-1}$ 在大串 $S$ 中出现了两次，那么我们在从 $T_i$ 跳到 $T_{i-1}$ 的时候，可以跳到后面那个 $T_{i-1}$，这样的话当跳到前面那个 $T_{i-1}$ 的时候，我们就可以跳回到后面的 $T_{i-1}$。那么对于出现次数 $\geq 2$ 的串 $[l,r]$，选择从它开始跳，答案为 $r-l+1+\lfloor (n-r)/2 \rfloor$。我们求出以每个下标为右端点的最长的出现次数 $\geq 2$的串，取个 $\max$，然后再和答案下界 $\lfloor n/2 \rfloor$ 取个 $\max$ 即可。

## 总代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#define re register
#define drep(a,b,c) for(re int a(b) ; a>=(c) ; --a)
#define rep(a,b,c) 	for(re int a(b) ; a<=(c) ; ++a)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x < 0) putchar('-'),x = -x;
	if(x >= 10) print(x / 10);
	putchar(x % 10 + '0');
}
const int M = 1e6+100;
int ch[M][26],len[M],fa[M],head[M],siz[M],pos[M];
char s[M];
int T,n,cnt,ans,tot=1,np=1;
struct edge{
	int to,nxt;
}e[M];
inline void add(int u,int v){
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
inline void init(){
	rep(i,1,tot){
		memset(ch[i],0,sizeof(ch[i]));
		head[i] = 0;
		siz[i] = 0;
	}
	cnt = ans = 0;
	tot = np = 1;
}
inline void sam_extend(int c,int id){
	int p = np; np = ++tot;
	len[np] = len[p] + 1;
	siz[np] = 1;
	pos[np] = id;
	for( ; p && !ch[p][c] ; p = fa[p]) ch[p][c] = np;
	if(p == 0) fa[np] = 1;
	else{
		int q = ch[p][c];
		if(len[q] == len[p] + 1) fa[np] = q;
		else{
			int nq = ++tot;
			fa[nq] = fa[q]; fa[q] = nq; fa[np] = nq;
			len[nq] = len[p] + 1;
			pos[nq] = n+1;
			siz[nq] = 0;
			for( ; p && ch[p][c]==q ; p = fa[p]) ch[p][c] = nq;
			memcpy(ch[nq],ch[q],sizeof(ch[nq]));
		}
	}
}
inline void dfs(int u){
	for(re int i(head[u]) ; i ; i=e[i].nxt){
		int v = e[i].to;
		dfs(v);
		siz[u] += siz[v];
		pos[u] = min(pos[u],pos[v]);
	}
	if(siz[u] > 1) ans = max(ans,len[u]+(n-pos[u])/2);
}
inline void work(){
	init();
	scanf("%s",s+1);
	n = strlen(s+1);
	rep(i,1,n) sam_extend(s[i]-'a',i);
	rep(i,2,tot) add(fa[i],i);
	ans = n/2;
	dfs(1);
	printf("%d\n",ans);
}
signed main(){
	T = read();
	while(T--) work();
	return 0;
}
```


---


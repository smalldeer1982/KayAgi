# 小园香径独徘徊

## 题目背景

徘徊在一条幽深的小径上，拾起记忆的碎片，将它们放入两个长长的口袋中。

将它们收集完倒出来后，会拼成什么样的故事呢？

## 题目描述

有两个字符串 $S,T$，一开始给定 $S$，$T$ 为空串。每次你可以执行以下三种操作，直到 $S$ 变为空串：

1. 删去 $S$ 的第一个字符，并将这个字符插入 $T$ 的开头；
1. 删去 $S$ 的第一个字符，并将这个字符插入 $T$ 的末尾；
1. 删去 $S$ 的最后一个字符，并将这个字符插入 $T$ 的开头。

a3 想知道，$S$ 变为空串后，可以构成的字典序最小的 $T$。

## 说明/提示

**【样例 1 解释】**

- 对于 $\texttt{ababdca}$，依次进行第 $1,2,1,2,2,2,1$ 种操作，即可得到 $\texttt{aaabbdc}$。
- 对于 $\texttt{dcbcadb}$，依次进行第 $1,1,1,2,3,1,2$ 种操作，即可得到 $\texttt{abbcdcd}$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$S$ 由至多两种字符构成。
-  Subtask 2（10 points）：$\sum |S|\le 12$。
-  Subtask 3（15 points）：$\sum |S|\le 100$。
-  Subtask 4（25 points）：$\sum |S|\le 3\times 10^3$。
-  Subtask 5（20 points）：$\sum |S|\le 2\times 10^5$。
-  Subtask 6（25 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le Q\le 3\times 10^5$，$1\le |S|\le 10^6$，$1\le \sum |S|\le 2\times 10^6$，$S$ 仅由小写字母构成。

## 样例 #1

### 输入

```
2
ababdca
dcbcadb```

### 输出

```
aaabbdc
abbcdcd```

# 题解

## 作者：Ecrade_ (赞：15)

- **首先考虑仅执行前两种操作可以得到的最小字符串。**

一个显然的贪心是，若当前 $S$ 的首字符大于 $T$ 的首字符就执行第二个操作，否则执行第一个操作。不难证明其正确性。

- **回到原问题。**

先将题意转化为：将 $S$ 分成前后两个部分 $A,B$，对 $A$ 从左到右执行前两种操作，对 $B$ 从右到左执行第三种操作。令对 $A$ 执行第一种操作**在 $T$ 中**形成的字符串为 $C$，对 $A$ 执行第二种操作**在 $T$ 中**形成的字符串为 $D$。

我们可以将第三种操作视作将 $B$ 不改变顺序地穿插到 $C$ 中的任意位置，即形成一个字符串 $E$，使得 $E$ 能够恰好划分为两个分别与 $B,C$ 相同的子序列。最终 $T$ 即为 $E+D$，其中 $+$ 表示字符串的拼接。

以第二个样例中 $S=\mathsf{{\color{orange}d}{\color{orange}c}{\color{orange}b}{\color{yellowgreen}c}{\color{orange}a}{\color{yellowgreen}d}{\color{cornflowerblue}b}}$ 构造出 $T=\mathsf{{\color{orange}a}{\color{cornflowerblue}b}{\color{orange}b}{\color{orange}c}{\color{orange}d}{\color{yellowgreen}c}{\color{yellowgreen}d}}$ 为例，将 $S$ 分为前后两个部分 $A=\mathsf{{\color{orange}d}{\color{orange}c}{\color{orange}b}{\color{yellowgreen}c}{\color{orange}a}{\color{yellowgreen}d}},B=\mathsf{{\color{cornflowerblue}b}}$，对橙色部分执行第一种操作，对绿色部分执行第二种操作，得到 $C=\mathsf{{\color{orange}a}{\color{orange}b}{\color{orange}c}{\color{orange}d}},D=\mathsf{{\color{yellowgreen}c}{\color{yellowgreen}d}}$，再将 $B$ 插入 $C$ 中得到 $E=\mathsf{{\color{orange}a}{\color{cornflowerblue}b}{\color{orange}b}{\color{orange}c}{\color{orange}d}}$，最终 $T=E+D=\mathsf{{\color{orange}a}{\color{cornflowerblue}b}{\color{orange}b}{\color{orange}c}{\color{orange}d}{\color{yellowgreen}c}{\color{yellowgreen}d}}$。

观察整个 $T$ 的构造流程，我们接下来需要解决三个问题：

1. 若确定了 $A$，如何构造最优的 $C,D$？
2. 若确定了 $B,C$，如何构造最优的 $E$？
3. 如何划分 $A,B$？

对于第一个问题，我们一开始已经解决了。形式化地来讲，我们对 $A$ 中所有前缀最小字符进行第一种操作，对剩余字符进行第二种操作，其中前缀最小字符指的是不大于自身之前任意字符的字符。可以观察到，这样形成的 $C$ 一定是个**单调不降**的字符序列。

对于第二个问题，由于 $C$ 中字符单调不降，故我们依然可以采取一个贪心的策略：若 $B$ 的首字符大于 $C$ 的首字符，则将 $C$ 的首字符加入到 $E$ 的末尾并将 $C$ 的首字符删去，否则将 $B$ 的首字符加入到 $E$ 的末尾并将 $B$ 的首字符删去。

对于第三个问题，暴力枚举 $A,B$ 的划分位置。

按照上述过程模拟，我们便得到了一个 $O(n^2)$ 的做法。

- **考虑优化。**

瓶颈在于枚举 $A,B$ 的划分位置上，考虑能否**缩小枚举范围**。

不难发现，对 $S$ 中所有前缀最小字符均进行第一种操作一定不劣。也就是说，令 $S$ 中最小字符的最后出现位置为 $p$，则将 $S_p$ 及其之前的字符都归到 $A$ 中一定不劣。那么此时整个 $C$ 和 $D$ 的一段前缀就确定下来了。

令 $S$ 中 $S_{p+1}$ 记其之后的字符构成的字符串为 $X$，则我们需要选取 $X$ 的一个后缀作为 $B$，剩余部分就接在已经确定的 $D$ 的后面。既然 $B$ 最终在 $D$ 前，那么我们**希望选出来的 $B$ 的字典序尽可能小**。一个自然的想法是直接选取 $X$ 的最小后缀作为 $B$，但很可惜这是错的。一个简单的反例是 $S=\mathsf{{\color{orange}c}{\color{orange}b}{\color{yellowgreen}d}{\color{orange}a}{\color{cornflowerblue}b}{\color{cornflowerblue}c}{\color{cornflowerblue}b}}$，此时最优的 $B$ 应当是 $\mathsf{{\color{cornflowerblue}b}{\color{cornflowerblue}c}{\color{cornflowerblue}b}}$，而不是字典序最小的 $\mathsf{{\color{cornflowerblue}b}}$。

那么问题出在哪儿呢？出在 “字典序最小” 的条件中**包含了对于字符串长度的比较**。对于 $X$ 的两个后缀 $s,s'\ (|s|<|s'|)$，若 $\forall 1\le i\le |s|$ 都有 $s_i=s'_i$，那么虽然 $s$ 字典序比 $s'$ 小，但若后面加上了 $D$，$s'$ 却可能比 $s$ 更优。

我们退而求其次，选择 $X$ 中**不考虑长度限制的字典序最小的**若干后缀。但这样的字符串可能仍旧很多，无法直接模拟。

观察这些后缀的性质。令这些后缀分别为 $s_1,s_2,\dots,s_k\ (|s_1|<|s_2|<\dots<|s_k|)$，那么 $\forall 1\le i<k$ 都有 **$s_i$ 为 $s_{i+1}$ 的一段前缀**，即 $s_i$ 为 $s_{i+1}$ 的一个 border，亦即 $s_2,s_3,\dots,s_k$ 为 $s_1$ 的 border。

接下来有两条路可走。

### 法一

依据这个性质，我们可以利用 $s_i$ 的结果推出 $s_{i+1}$ 的结果。具体地，要想比较 $B=s_i$ 所构造出的 $T$ 和 $B=s_{i+1}$ 所构造出的 $T'$ 的大小，我们可以在 $T$ 的基础上，根据前文的贪心，暴力添加字符直至 $B=s_{i+1}$。在添加的过程中进行逐位比较，添加完成后，由于剩余的部分构成一段区间，那么直接利用你喜欢的方式比较即可。

时间复杂度瓶颈在于后缀排序。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,nc,nd,ns,tp,sa[1000009],rnk[1000009],slen[1000009];
char s[1000009],C[1000009],D[1000009],T[1000009],ans[1000009];
inline int read(){
	int s = 0,w = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
	while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
	return s * w;
}
namespace SAM{
	int tp,tot,cnt = 1,last = 1,tmp[26],hd[2000009],fa[2000009],dy[2000009],id[2000009],len[2000009],pos[2000009],suf[2000009],ch[2000009][26];
	struct st{int x,y;}eg[2000009];
	void addedge(int u,int v){eg[++ tot] = (st){v,hd[u]},hd[u] = tot;}
	void clear(){
		for (int i = 1;i <= cnt;i += 1){
			memset(ch[i],0,sizeof(ch[i]));
			fa[i] = dy[i] = id[i] = len[i] = pos[i] = suf[i] = 0;
		}
		cnt = last = 1;
	}
	void ins(int x,int y){
		int p = last,cur = ++ cnt;
		pos[cur] = y,suf[cur] = 1,len[cur] = len[last] + 1;
		while (p && !ch[p][x]) ch[p][x] = cur,p = fa[p];
		int q = ch[p][x];
		if (!q) fa[cur] = 1;
		else if (len[p] + 1 == len[q]) fa[cur] = q;
		else{
			int r = ++ cnt;
			fa[r] = fa[q],pos[r] = pos[q],len[r] = len[p] + 1;
			memcpy(ch[r],ch[q],sizeof(ch[q]));
			while (p && ch[p][x] == q) ch[p][x] = r,p = fa[p];
			fa[cur] = fa[q] = r;
		}
		last = cur;
	}
	void dfs(int u,bool fl,bool opt){
		if (suf[u]){
			if (opt){
				if (!fl) return;
				slen[++ ns] = n - pos[u] + 1;
			}
			else tp += 1,sa[tp] = pos[u],rnk[pos[u]] = tp;
		}
		for (int i = hd[u];i;i = eg[i].y) dfs(eg[i].x,fl,opt),fl = 0;
	}
	void work(int opt){
		tp = tot = 0;
		for (int i = 0;i < 26;i += 1) tmp[i] = 0;
		for (int i = 1;i <= cnt;i += 1) hd[i] = 0;
		for (int i = 1;i <= cnt;i += 1) dy[i] = T[pos[i] + len[fa[i]]] - 'a',tmp[dy[i]] += 1;
		for (int i = 1;i < 26;i += 1) tmp[i] += tmp[i - 1];
		for (int i = 1;i <= cnt;i += 1) id[tmp[dy[i]] --] = i;
		for (int i = cnt;i >= 1;i -= 1) if (fa[id[i]]) addedge(fa[id[i]],id[i]);
		dfs(1,1,opt);
	}
}
void clear(){
	SAM :: clear();
	nc = nd = ns = tp = 0;
	for (int i = 1;i <= n;i += 1) sa[i] = rnk[i] = slen[i] = 0;
}
int main(){
	t = read();
	while (t --){
		clear(),scanf("%s",s + 1),n = strlen(s + 1);
		int pos = 1;
		for (int i = 1;i <= n;i += 1) if (s[i] <= s[pos]){
			C[++ nc] = s[i];
			for (int j = pos + 1;j < i;j += 1) D[++ nd] = s[j];
			pos = i;
		}
		reverse(C + 1,C + nc + 1);
		for (int i = 1;i <= nc;i += 1) T[i] = C[i];
		for (int i = 1;i <= nd;i += 1) T[i + nc] = D[i];
		for (int i = pos + 1;i <= n;i += 1) T[i] = s[i];
		for (int i = n;i > pos;i -= 1) SAM :: ins(T[i] - 'a',i);
		SAM :: work(1);
		for (int i = pos;i >= 1;i -= 1) SAM :: ins(T[i] - 'a',i);
		SAM :: work(0);
		int fl = 0,res = 0,now = 1,cur = 1,cpos = 1,mnpos = n - slen[ns];
		for (int i = 1;i <= slen[ns];i += 1){
			while (cpos <= nc && T[cpos] < T[mnpos + i]){
				if (!fl && T[cpos] < T[cur]) fl = 1;
				if (!fl && T[cpos] > T[cur]) goto GG;
				cur += 1,cpos += 1;
			}
			if (!fl && T[mnpos + i] < T[cur]) fl = 1;
			if (!fl && T[mnpos + i] > T[cur]) goto GG;
			cur += 1;
			if (i == slen[now]){
				if (fl == 1 || rnk[cpos] < rnk[cur]) cur = cpos,res = slen[now];
				fl = 0,now += 1;
			}
		}
		GG:;
		cpos = 1;
		for (int i = 1;i <= res;i += 1){
			while (cpos <= nc && T[cpos] < T[mnpos + i]) ans[++ tp] = T[cpos ++];
			ans[++ tp] = T[mnpos + i];
		}
		while (cpos <= nc) ans[++ tp] = T[cpos ++];
		for (int i = 1;i <= nd;i += 1) ans[++ tp] = T[nc + i];
		for (int i = pos + 1;i <= n - res;i += 1) ans[++ tp] = T[i];
		for (int i = 1;i <= n;i += 1) putchar(ans[i]);
		puts("");
	}
	return 0;
}
```


### 法二

根据 border 的性质，我们可将 $|s_1|,|s_2|,\dots,|s_k|$ 分成 $O(\log k)$ 段等差数列。记有 $c$ 段等差数列，第 $i$ 段由 $s_{l_i},s_{l_i+1},\dots,s_{r_i}$ 构成。

可以根据调整法证明，最优的 $B$ 一定只存在于每段的首两项和末一项，即 $s_{l_i},s_{l_i+1},s_{r_i}$ 之中。枚举这些位置直接模拟即可。

时间复杂度为 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,fl,nc,nd,ns,tp,sa[1000009],rnk[1000009],ban[1000009],slen[1000009];
char s[1000009],C[1000009],D[1000009],T[1000009],ans[1000009];
inline int read(){
	int s = 0,w = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
	while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
	return s * w;
}
namespace SAM{
	int tp,tot,cnt = 1,last = 1,tmp[26],hd[2000009],fa[2000009],dy[2000009],id[2000009],len[2000009],pos[2000009],suf[2000009],ch[2000009][26];
	struct st{int x,y;}eg[2000009];
	void addedge(int u,int v){eg[++ tot] = (st){v,hd[u]},hd[u] = tot;}
	void clear(){
		for (int i = 1;i <= cnt;i += 1){
			memset(ch[i],0,sizeof(ch[i]));
			fa[i] = dy[i] = id[i] = len[i] = pos[i] = suf[i] = 0;
		}
		cnt = last = 1;
	}
	void ins(int x,int y){
		int p = last,cur = ++ cnt;
		pos[cur] = y,suf[cur] = 1,len[cur] = len[last] + 1;
		while (p && !ch[p][x]) ch[p][x] = cur,p = fa[p];
		int q = ch[p][x];
		if (!q) fa[cur] = 1;
		else if (len[p] + 1 == len[q]) fa[cur] = q;
		else{
			int r = ++ cnt;
			fa[r] = fa[q],pos[r] = pos[q],len[r] = len[p] + 1;
			memcpy(ch[r],ch[q],sizeof(ch[q]));
			while (p && ch[p][x] == q) ch[p][x] = r,p = fa[p];
			fa[cur] = fa[q] = r;
		}
		last = cur;
	}
	void dfs(int u,bool fl,bool opt){
		if (suf[u]){
			if (opt){
				if (!fl) return;
				slen[++ ns] = n - pos[u] + 1;
			}
			else tp += 1,sa[tp] = pos[u],rnk[pos[u]] = tp;
		}
		for (int i = hd[u];i;i = eg[i].y) dfs(eg[i].x,fl,opt),fl = 0;
	}
	void work(int opt){
		tp = tot = 0;
		for (int i = 0;i < 26;i += 1) tmp[i] = 0;
		for (int i = 1;i <= cnt;i += 1) hd[i] = 0;
		for (int i = 1;i <= cnt;i += 1) dy[i] = T[pos[i] + len[fa[i]]] - 'a',tmp[dy[i]] += 1;
		for (int i = 1;i < 26;i += 1) tmp[i] += tmp[i - 1];
		for (int i = 1;i <= cnt;i += 1) id[tmp[dy[i]] --] = i;
		for (int i = cnt;i >= 1;i -= 1) if (fa[id[i]]) addedge(fa[id[i]],id[i]);
		dfs(1,1,opt);
	}
}
void upd(){
	for (int i = 1;i <= n;i += 1){
		if (ans[i] < T[i]) return;
		if (ans[i] > T[i]){
			for (int j = 1;j <= n;j += 1) ans[j] = T[j];
			return;
		}
	}
}
void simulate(int o){
	int nc = 0,nd = 0,pos = 1;
	for (int i = 1;i <= o;i += 1){
		if (s[i] <= s[pos]) C[++ nc] = s[i],pos = i;
		else D[++ nd] = s[i];
	}
	reverse(C + 1,C + nc + 1);
	int tp = 0,cpos = 1;
	for (int i = o + 1;i <= n;i += 1){
		while (cpos <= nc && C[cpos] < s[i]) T[++ tp] = C[cpos ++];
		T[++ tp] = s[i];
	}
	while (cpos <= nc) T[++ tp] = C[cpos ++];
	for (int i = 1;i <= nd;i += 1) T[++ tp] = D[i];
	if (!fl) for (int i = 1;i <= n;i += 1) ans[i] = T[i];
	else upd();
	fl = 1;
}
void clear(){
	SAM :: clear();
	fl = nc = nd = ns = tp = 0;
	for (int i = 1;i <= n;i += 1) sa[i] = rnk[i] = ban[i] = slen[i] = 0;
}
int main(){
	t = read();
	while (t --){
		clear(),scanf("%s",s + 1),n = strlen(s + 1);
		int pos = 1;
		for (int i = 1;i <= n;i += 1) if (s[i] <= s[pos]){
			C[++ nc] = s[i];
			for (int j = pos + 1;j < i;j += 1) D[++ nd] = s[j];
			pos = i;
		}
		reverse(C + 1,C + nc + 1);
		for (int i = 1;i <= nc;i += 1) T[i] = C[i];
		for (int i = 1;i <= nd;i += 1) T[i + nc] = D[i];
		for (int i = pos + 1;i <= n;i += 1) T[i] = s[i];
		for (int i = n;i > pos;i -= 1) SAM :: ins(T[i] - 'a',i);
		SAM :: work(1);
		for (int i = pos;i >= 1;i -= 1) SAM :: ins(T[i] - 'a',i);
		SAM :: work(0);
		for (int i = 2;i < ns;i += 1) if (slen[i] - slen[i - 1] == slen[i + 1] - slen[i]) ban[i] = 1;
		for (int i = 0;i <= ns;i += 1){
			if (i <= 1 || i == ns || !ban[i - 1] || !ban[i]) simulate(n - slen[i]);
		}
		for (int i = 1;i <= n;i += 1) putchar(ans[i]);
		puts("");
	}
	return 0;
}
```


---

## 作者：Schi2oid (赞：4)


挺厉害的题。

## 题意简述

有两个字符串 $S,T$，一开始给定 $S$，$T$ 为空串。每次你可以执行以下三种操作，直到 $S$ 变为空串：

1. 删去 $S$ 的第一个字符，并将这个字符插入 $T$ 的开头；
2. 删去 $S$ 的第一个字符，并将这个字符插入 $T$ 的末尾；
3. 删去 $S$ 的最后一个字符，并将这个字符插入 $T$ 的开头。

求 $S$ 变为空串后，可以构成的字典序最小的 $T$。

$1\le Q\le 3\times 10^5$，$1\le |S|\le 10^6$，$1\le \sum |S|\le 2\times 10^6$，$S$ 仅由小写字母构成。

## 思路分析

如果只有前两种操作，直接贪心判断当前字符是否 $\le T[1]$ 即可。这相当于倒序取出字符串的所有前缀最小值位置，剩余部分排在后面。加入第三种操作，相当于选取一个后缀，倒序依次执行三操作，前面部分进行二操作。相当于将该后缀按照原相对顺序插入前缀操作后的前缀最小值序列中。插入时相当于将一个无序序列插入到一个有序序列当中，因此每次比较序列开头元素大小即可。

直接枚举三操作分割点，贪心模拟上述过程，时间复杂度 $O(n^2)$。

考虑优化，仔细观察模拟过程，发现分割点一定位于最后一个前缀最小值之后。否则开头的最小值数量会变少，字典序一定增大。记最后一个前缀最小值位置为 $ed$，记 $s[1\dots ed]$ 依题意模拟后被放到开头形成的串为 $A$，被放到结尾形成的串为 $B$，那么现在只需要将 $s[ed+1\dots n]$ 划分为两部分，前一部分会直接与 $B$ 合并接在 $B$ 的末尾，后一部分会保持相对顺序不变插入到 $A$ 中。记后一部分为 $X$。

现在，考察 $X_1,X_2$，有 $lcp(X_1,X_2)<\min{|X_1|,|X_2|}$。根据上述贪心过程，$X_1,X_2$ 中字典序较大的一个一定严格劣于另外一个。因此，可能成为答案的 $X$ 在后缀排序后的编号一定是一个前缀，且 $sa_i$ 是 $sa_{i+1}$ 的一个前缀，又由于它们都是原串后缀，故 $sa_i$ 是 $sa_{i+1}$ 的一个 Border。

根据上述性质，从短到长考虑每一个 $X$ 是否能成为最优解，存一下之前找到的最优解位置，由于已经插入过的位置之前都是一样的，依次贪心插入每一个 $X$ 比上一个增长的部分并进行比较，出现不同即可判断字典序大小关系。特别地，如果新插入的部分都与之前的最优解完全相等，注意到这两个字符串剩下的部分都是可以直接确定的（一定是 $A+B+s[ed+1…n]$ 的一个子串），可以通过 SA 进行比大小。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000005],ans[1000005];
char tmp[1000005];
int lg[2000005],len[2000005];
int x[2000005],y[2000005],sa[2000005],c[2000005],rk[2000005],h[2000005];
int st[21][1000005],pos[2000005];
void SA(char *s,int n,bool op){
	for(int i=n+1;i<=2*n;i++) x[i]=y[i]=0;
	int m=200;
	std::memset(c,0,sizeof(int)*(m+1));
	for(int i=1;i<=n;i++) x[i]=s[i],c[x[i]]++;
	for(int i=2;i<=m;i++) c[i]+=c[i-1];
	for(int i=n;i>=1;i--) sa[c[x[i]]--]=i;
	for(int k=1;k<=n;k<<=1){
		int num=0;
		for(int i=n-k+1;i<=n;i++) y[++num]=i;
		for(int i=1;i<=n;i++) if(sa[i]-k>0) y[++num]=sa[i]-k;
		std::memset(c,0,sizeof(int)*(m+1));
		for(int i=1;i<=n;i++) c[x[i]]++;
		for(int i=2;i<=m;i++) c[i]+=c[i-1];
		for(int i=n;i>=1;i--) sa[c[x[y[i]]]--]=y[i];
		for(int i=1;i<=n;i++) swap(x[i],y[i]);
		num=1;
		x[sa[1]]=1;
		for(int i=2;i<=n;i++){
			if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]) x[sa[i]]=num;
			else x[sa[i]]=++num;
		}
		if(num==n) break;
		m=num;
	}
	for(int i=1;i<=n;i++) rk[sa[i]]=i;
	for(int i=1,k=0;i<=n;i++){
		if(rk[i]==1){
			h[rk[i]]=0;
			continue;
		}
		if(k) k--;
		while(s[i+k]==s[sa[rk[i]-1]+k]) k++;
		h[rk[i]]=k;
	}
	if(op){
		for(int i=1;i<=n;i++) st[0][i]=h[i];
		for(int i=1;i<=20;i++){
			for(int j=1;j<=n;j++){
				if(j+(1<<i)-1>n) break;
				st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);
			}
		}
	}
}
int get_st(int x,int y){
	int tmp=lg[y-x+1];
	return min(st[tmp][x],st[tmp][y-(1<<tmp)+1]);	
}
int LCP(int x,int y){
	int l=min(rk[x],rk[y]),r=max(rk[x],rk[y]);
	return get_st(l+1,r);
}
int main(){
	lg[1]=0;
	for(int i=2;i<=2000000;i++) lg[i]=lg[i>>1]+1;
	int t,n;
	cin>>t;
	while(t--){
		scanf("%s",s+1);
		n=strlen(s+1);
		for(int i=1;i<=n;i++) ans[i]=0;
		char mnc='z'+1;
		int ed=0;
		for(int i=1;i<=n;i++) if(s[i]<=mnc) mnc=s[i],ed=i;
		mnc='z'+1;
		int p=0;
		int tcnt=0;
		for(int i=1;i<=ed;i++){
			if(s[i]<=mnc) s[++p]=s[i],mnc=s[i];
			else tmp[++tcnt]=s[i];
		}
		reverse(s+1,s+1+p);
		memcpy(s+p+1,tmp+1,tcnt);
		SA(s+ed,n-ed,0);
		sa[0]=n-ed+1;
		int lcnt=0;
		for(int i=1;i<=n-ed;i++){
			if(h[i]!=n-ed+1-sa[i-1]) break;
			len[++lcnt]=n-ed-sa[i]+1;
		}
		SA(s,n,1);
		int mn=0,poi=1;
		int ok=1;
		for(int i=1;i<=lcnt;i++){
			int judged=0;
			for(int j=len[i-1]+1;j<=len[i];j++){
				int nowpos=n-len[i]+j;
				while(poi<=p&&s[nowpos]>s[poi]){
					int nowlen=poi-1+j;
					if(judged){
						poi++;
						continue;
					}
					if(s[poi]>s[nowlen-mn]){
						ok=0;
						break;
					}
					if(s[poi]<s[nowlen-mn]) judged=1;
					poi++;
				}
				if(!ok) break;
				int nowlen=poi-1+j;
				pos[j]=nowlen;
				if(judged) continue;
				if(s[nowpos]>s[nowlen-mn]){
					ok=0;
					break;
				}
				if(s[nowpos]<s[nowlen-mn]) judged=1;
			}
			if(!ok) break;
			if(!judged){
				int x=min(LCP(poi,poi+len[i]-mn),n-(poi-1+len[i]));
				if(x==n-(poi-1+len[i])) continue;
				if(s[poi+x]<s[poi+len[i]-mn+x]) mn=len[i];
			}
			else mn=len[i];
		}
		for(int i=1;i<=mn;i++) ans[pos[i]]=s[n-mn+i];
		poi=0;
		for(int i=1;i<=n;i++) if(!ans[i]) ans[i]=s[++poi];
		for(int i=1;i<=n;i++) printf("%c",ans[i]);
		puts("");
	}
	return 0;
}

```

---

## 作者：R_shuffle (赞：0)

首先考虑只有前两个操作怎么做。显然第一个一定是被放到首位的，然后后面的就直接考虑与首位的关系。如果不比首位大就直接扔到首位，如果比首位大就扔到后面。

而三操作就是相当于从原序列截取一个后缀，然后将这个后缀与前缀类似归并式的合并。

所以这样就有了暴力，枚举前后缀的分界点，然后可以线性模拟这个过程，做到 $O(n^2)$。

然后考虑优化这个过程，考虑这个合并的过程，由于在合并的时候前缀是倒序的，所以不妨直接考虑原本在前缀中插到前面的字符被改到后缀中会怎么样，显然单改一个是没有区别的，但是改的多了，会发现原来在前缀中字典序是单调不升的，但是到了后缀中就是单调不降的，所以还是让原操作被插到前面的继续留在前缀。

所以可以发现，分界点不会到最后一个满足前面所有字符都不小于它的位置之前。不妨设这个位置为 $epos$，那么显然 $S_1,S_2,…,S_{epos}$这些还是按照原来的方法排，而 $S_{epos+1},S_{epos+2},…,S_n$ 这些字符，直接被分成了两段，其中前半段被直接插到 $[1,epos]$ 所形成的字符串后面，而后半段则与 $S_1,S_2,…,S_{epos}$ 中被放到前面的字符以类似归并的方式合并。

而由于是类似归并的方式，且确定了归并的另一半，所以不难得到后半段的字典序越大，则归并出来的结果就不优。

然后由于左端点靠前的后缀和左端点靠后的后缀，在其他方面相同的情况下是劣势的，所以可以考虑从短到长的考虑后缀，每次只考虑不一样的部分，贪心的插入，显然到了一个地方会出现不同，这时候就可以直接比较了。不难发现这个东西可以用 SA 来比较，所以可以做到 $O(n\log n)$ 或者线性。

注意后缀数组的实现。

---


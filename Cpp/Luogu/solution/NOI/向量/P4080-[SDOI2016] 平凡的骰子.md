# [SDOI2016] 平凡的骰子

## 题目描述

这是一枚平凡的骰子。它是一个均质凸多面体，表面有n个端点，有f个面，每一面是一个凸多边形，且任意两面不共面。将这枚骰子抛向空中，骰子落地的时候不会发生二次弹跳（这是一种非常理想的情况）。

你希望知道最终每一面着地的概率。每一面着地的概率可以用如下的方法计算：我们假设O为骰子的重心，并以O为球心，做半径为1的单位球面（记为S）。

我们知道S的表面积即单位球的表面积，为4\*pi，这里pi为圆周率。对于骰子的某一面C来说，球面S上存在一块区域T满足：当下落时若骰子所受重力方向与S的交点落在T中，则C就是最终着地的一面。那么C着地的概率为区域T的面积除以4\*pi。

为了能更好地辅助计算球面上一块区域的面积，我们给出单位球面S上三角形的面积计算公式。考虑单位球面S上的三个两两相交的大圆，交点依次为A，B和C。则曲面三角形ABC的面积为 $\text{Area}(ABC)=\alpha+\beta+\gamma-\pi$，其中 $\alpha,\beta , \gamma$ 分别对应了三个二面角的大小。如下图所示。

 ![](https://cdn.luogu.com.cn/upload/pic/12756.png) 

我们保证：每一面着地的时候，重心的垂心都恰好在这一面内。也就是说不会出现摆不稳的情况。


## 说明/提示

对于所有数据，4<=n<=50且4<=m<=50，所有坐标的绝对值都在10000以内


## 样例 #1

### 输入

```
8 6
1 0 0
1 1 0
1 0 1
1 1 1
0 0 0
0 1 0
0 0 1
0 1 1
4 1 2 4 3
4 2 6 8 4
4 6 5 7 8
4 5 1 3 7
4 3 4 8 7
4 1 5 6 2```

### 输出

```
0.1666667
0.1666667
0.1666667
0.1666667
0.1666667
0.1666667```

# 题解

## 作者：bztMinamoto (赞：7)

## 题面

[传送门](https://www.luogu.org/problemnew/show/P4080)

做一道题学一堆东西不管什么时候都是美好的体验呢……

## 前置芝士

### 混合积

对于三个三维向量$a,b,c$，定义它们的混合积为$(a\times b)\cdot c$，其中$\times $表示叉乘，$\cdot$表示点乘，记为$[a\ b\ c]$

关于它的几何意义的话……图片来自网络

![](https://i.loli.net/2019/04/12/5cb0716e70817.png)

其中$Prj_{a\times b}c$代表的是$c$这个向量在$a\times b$这个向量上的投影

那么显然我们最后得到的是以这三个向量为三条临边的一个六面体的体积

![](https://i.loli.net/2019/04/12/5cb071dbb2c80.png)

### 四面体体积

假设四面体的四个顶点分别为$A,B,C,D$，并设三个向量$a=B-A,b=C-A,c=D-A$，那么这个正四面体的体积就是${1\over 6}[a\ b\ c]$

这个应该比较显然吧……看上面那幅图，四面体的体积是以$ab$这个平行四边形为底，$c$为顶点的棱锥的一半，而棱锥的体积是棱柱的${1\over 3}$，所以四面体体积就是六面体的${1\over 6}$了

### 凸多面体的重心

我们先来考虑一下凸多边形的重心好了……

对于三角形，它的重心就是它所有坐标的平均值

那么对于凸多边形，我们把它三角剖分了，记第$i$块的重心为$a_i$，面积为$m_i$，那么凸多边形的重心就是

$${\sum_{i=1}^na_i\times m_i\over \sum_{i=1}^nm_i}$$

那么凸多面体也差不多了，我们把它给四面体剖分了，然后也差不多按上面的算就好了

关于四面体剖分，具体的说我们在多面体中随便选一个点，比方说是$p_1$，然后把每一个面给三角剖分，那么三角形就和选定的点构成了一个四面体。设$v_i$表示第$i$个四面体的体积，$a_i$表示重心，则最终多面体的重心为

$${\sum_{i=1}^na_i\times v_i\over \sum_{i=1}^nv_i}$$

### 二面角

~~这玩意儿班里数学课正在上然而我正在停课~~

简单来说就是两个平面的夹角

我们假设现在有$a,b,c$三个向量，要求$ab$这个平面和$ac$这个平面的二面角

那么求出$ab$和$ac$的法向量（法向量可以直接用叉积算），两个法向量之间的夹角就是二面角了，法向量之间的夹角直接用点积除以长度计算

可以画个图来理解。我们俯视的话，即要求二面角$\angle 1$，那么显然两个法向量的夹角$\angle 2=\angle 1$

![](https://i.loli.net/2019/04/12/5cb0773f7d5e4.png)

## 题解

总结起来的话……

三维计算几何。

需要混合积求四面体体积；

四面体剖分后合并带权重心求总重心；

四面体重心的横纵坐标是四个顶点的横纵坐标的平均数；

三维差积求平面的法向量；

点积求法向量夹角（二面角）

这些知识就可以了AC此题了。

时间复杂度$O(nf)$

顺便说一下数据范围是$n,f\leq 100$，题面里错了

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define inline __inline__ __attribute__((always_inline))
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
const int N=105;const double Pi=acos(-1.0);
struct node{
	double x,y,z;
	inline node(){}
	inline node(R double xx,R double yy,R double zz):x(xx),y(yy),z(zz){}
	inline node operator +(const node &b)const{return node(x+b.x,y+b.y,z+b.z);}
	inline node operator -(const node &b)const{return node(x-b.x,y-b.y,z-b.z);}
	inline node operator *(const node &b)const{return node(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x);}
	inline double operator ^(const node &b)const{return x*b.x+y*b.y+z*b.z;}
	inline node operator *(const double &b)const{return node(x*b,y*b,z*b);}
	inline node operator /(const double &b)const{return node(x/b,y/b,z/b);}
	inline double norm(){return sqrt(x*x+y*y+z*z);}
}p[N],h[N*N],u,v;
int f[N][N],c[N];double sum,tmp;
int n,m;
inline double cross(const node &a,const node &b,const node &c){
	node p=b*a,q=c*a;return acos((p^q)/p.norm()/q.norm());
}
int main(){
//	freopen("testdata.in","r",stdin);
	scanf("%d%d",&n,&m);
	fp(i,1,n)scanf("%lf%lf%lf",&p[i].x,&p[i].y,&p[i].z);
	fp(i,1,m){
		scanf("%d",&c[i]);
		fp(j,1,c[i])scanf("%d",&f[i][j]);
	}
	u=p[1],v=node(0,0,0),sum=0;
	fp(i,1,m){
		node u2=p[f[i][1]],v1,v2,t;
		fp(j,2,c[i]-1){
			v1=p[f[i][j]],v2=p[f[i][j+1]];
			t=(u+u2+v1+v2)*0.25,tmp=fabs(((v1-u2)*(v2-u2))^(u-u2));
			v=v+t*tmp,sum+=tmp;
		}
	}
	tmp=1.0/sum,u=v*tmp,tmp=0.25/Pi;
	fp(i,1,n)p[i]=p[i]-u;
	fp(i,1,m){
		sum=0;
		fp(j,2,c[i]-1)sum+=cross(p[f[i][j]],p[f[i][j-1]],p[f[i][j+1]]);
		sum+=cross(p[f[i][1]],p[f[i][c[i]]],p[f[i][2]]),
		sum+=cross(p[f[i][c[i]]],p[f[i][c[i]-1]],p[f[i][1]]);
		sum-=(c[i]-2)*Pi;
		printf("%.7lf\n",sum*tmp);
	}
	return 0;
}
```

---

## 作者：81179332_ (赞：5)

知识点另一篇题解说的很详细了，我来说一下此题具体实现。

重心的求法没什么好说的。

对于一个多边形，区域 T 是多边形以重心为点光源，在单位球上的投影，该投影是一个曲面多边形。

考虑该曲面多边形的求法，设边数为 $d$，我们将这个曲面多边形“三角剖分”，那么它的面积就等于所有曲面三角形的面积之和。题目中给出了 $\operatorname{Area}(ABC)=\alpha +\beta+\gamma-\pi$，所以总面积 $S=$ 所有三角形内角和 $-(d-2)\pi$，$d-2$ 为三角形个数。

曲面三角形的内角和之和等于曲面多边形内角和，对于曲面多边形一个内角，它等于重心与原多边形一对邻边形成的两个平面的夹角。

最后概率等于区域 T 的面积除以单位球的表面积。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map>
#include<cctype>
#include<cmath>
#include<bitset>
#include<ctime>
#define pprint(x) ::print(x),putchar(' ')
#define fprint(x) ::print(x),putchar('\n')
using namespace std;
//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)
char BB[1 << 15],*SS = BB,*TT = BB;
using namespace std;
inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	for(;!isdigit(ch);ch = getchar())
		if(ch == '-')
			f = -1;
	for(;isdigit(ch);ch = getchar())
		x = x * 10 + (ch ^ 48);
	return x * f;
}
void print(long long x)
{
	if(x < 0)
		putchar('-'),x = -x;
	if(x > 9)
		print(x / 10);
	putchar(x % 10 + '0');
}
const double pi = acos(-1),eps = 1e-8;
const int N = 110;
int dcmp(double x)
{
	return x < -eps ? -1 : (x > eps);
}
struct point
{
	double x,y,z;
	
	void read()
	{
		scanf("%lf %lf %lf",&x,&y,&z);
	}
	point(double _x = 0,double _y = 0,double _z = 0)
	{
		x = _x,y = _y,z = _z;
	}
	friend point operator + (point szq,point yqy)
	{
		return point(szq.x + yqy.x,szq.y + yqy.y,szq.z + yqy.z);
	}
	friend point operator - (point szq,point yqy)
	{
		return point(szq.x - yqy.x,szq.y - yqy.y,szq.z - yqy.z);
	}
	friend point operator * (point szq,double yqy)
	{
		return point(szq.x * yqy,szq.y * yqy,szq.z * yqy);
	}
	friend double operator * (point szq,point yqy)
	{
		return szq.x * yqy.x + szq.y * yqy.y + szq.z * yqy.z;
	}
	friend point operator / (point szq,double yqy)
	{
		return point(szq.x / yqy,szq.y / yqy,szq.z / yqy);
	}
	friend point operator & (point szq,point yqy)
	{
		return point(szq.y * yqy.z - szq.z * yqy.y,szq.z * yqy.x - szq.x * yqy.z,szq.x * yqy.y - szq.y * yqy.x);
	}
	double lenth()
	{
		return sqrt((*this) * (*this));
	}
};
double angle(point a1,point a2,point b1,point b2)
{
	point p = a2 & a1,q = b2 & b1;
	return acos((p * q) / p.lenth() / q.lenth());
}
int n,m;
point p[N],G;
int d[N],f[N][N];
int main()
{
	n = read(),m = read();
	for(int i = 1;i <= n;i++)
		p[i].read();
	for(int i = 1;i <= m;i++)
	{
		d[i] = read();
		for(int j = 1;j <= d[i];j++)
			f[i][j] = read();
	}
	point u = p[1];
	double sum = 0;
	for(int i = 1;i <= m;i++)
	{
		point a = p[f[i][1]],b,c;
		for(int j = 2;j < d[i];j++)
		{
			b = p[f[i][j]],c = p[f[i][j + 1]];
			double w = fabs(((b - a) & (c - a)) * (u - a));
			G = G + (u + a + b + c) * w * 0.25,sum += w;
		}
	}
	G = G / sum;
	for(int i = 1;i <= n;i++)
		p[i] = p[i] - G;
	double all = 4 * pi;
	for(int i = 1;i <= m;i++)
	{
		double sum = 0;
		f[i][0] = f[i][d[i]],f[i][d[i] + 1] = f[i][1];
		for(int j = 1;j <= d[i];j++)
			sum += angle(p[f[i][j]],p[f[i][j - 1]],p[f[i][j]],p[f[i][j + 1]]);
		sum -= (d[i] - 2) * pi;
		printf("%.7lf\n",sum / all);
	}
	return 0;
}
```

---

## 作者：_Sein (赞：2)

首先我们来捋一捋整个题的思路吧。

题意要求我们求凸多面体的重心$O$，

之后$O$作为大圆的圆心，作二面角，求每一个凸多边形在球面上的投影面积。

成功解决此题。

那么具体的话。。。

重心的求法也就是

物理的质心求法:

$\overrightarrow{o}=\frac{\sum\limits_{i=1}^n \overrightarrow{a_i}v_i}{V}$

其中$a_i$为四面体重心，$v_i$为这个四面体的体积,$V=\sum_{i=1}^n v_i$。

其中四面体重心坐标为$\overrightarrow{a}=\frac{\overrightarrow{p_1}+\overrightarrow{p_2}+\overrightarrow{p_3}+\overrightarrow{p_4}}{4}$，

$v=\frac{1}{6}|a\cdot(b\times c)|$，这个叫向量混合积，有兴趣可以去搜一下。

质心求法的证明类似于将两个点$p_1,p_2$，与它们的体积$v_1,v_2$

看成两个物体，然后把这两个物体看成一个整体，然后求出这个整体的重心。

实际上就是杠杆定理:设$p_o$为重心，则$v_1(dis_{p_1\rightarrow p_o})=v_2(dis_{p_o\rightarrow p_2})$。

然后就是不断地求重心的过程，最后得到的就是那个式子。

二面角的解法运用法向量求解即可。

即$\text{cos} ~\theta=\frac{\overrightarrow{a}\cdot\overrightarrow{b}}{|\overrightarrow{a}||\overrightarrow{b}|}$，法向量用叉积求。

因为凸多边形投影在球面上也是一个曲面凸多边形。

那么来说，可以把这个图形分成多个三角形进行处理，加起来$/4\pi$即为答案。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<vector> 
#define gc getchar()
#define ll long long
#define ull unsigned long long
#define file(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
#define I inline 
using namespace std;
const int N=1e4+5,M=1e4;
const double pi=acos(-1);
template<class o>I void qr(o &x)
{
	char c=gc;int f=1;x=0;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>I void qw(o x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
struct Point
{
	double x,y,z;
	Point(double x=0.0,double y=0.0,double z=0.0):x(x),y(y),z(z){}
	I Point operator +(const Point &a)const{return Point(x+a.x,y+a.y,z+a.z);}
	I Point operator -(const Point &a)const{return Point(x-a.x,y-a.y,z-a.z);}
	I Point operator *(const double &a)const{return Point(x*a,y*a,z*a);}
	I Point operator /(const double &a)const{return Point(x/a,y/a,z/a);}
	Point operator +=(const Point &a){return *this=*this+a;}
	Point operator -=(const Point &a){return *this=*this-a;}
	Point operator *=(const double &a){return *this=*this*a;}
	Point operator /=(const double &a){return *this=*this/a;}
	I double dis(){return sqrt(x*x+y*y+z*z);}
}P[55],G;int n,m;vector<Point>S[85];
I Point cross(const Point &a,const Point &b){return Point(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}
I double dot(const Point &a,const Point &b){return a.x*b.x+a.y*b.y+a.z*b.z;}
I Point getG(const Point &p,const Point &a,const Point &b,const Point &c){return (p+a+b+c)/4.0;} 
double getV(Point p,Point a,Point b,Point c){a-=p;b-=p;c-=p;return fabs(dot(a,cross(b,c)))/6.0;}
double angle(Point p,Point a,Point b,Point c){a-=p;b-=p;c-=p;Point d=cross(a,b),e=cross(a,c);return acos(dot(d,e)/d.dis()/e.dis());}
void init()
{
	qr(n),qr(m);
	for(int i=1;i<=n;i++)
	{
		double x,y,z;scanf("%lf%lf%lf",&x,&y,&z);
		P[i]=Point(x,y,z);
	}
	for(int i=1,k,x;i<=m;i++)
	{
		qr(k);
		for(int j=1;j<=k;j++)qr(x),S[i].push_back(P[x]);
	}
	double sv=0.0;
	for(int i=1;i<=m;i++)
	{
		int s=S[i].size();
		for(int j=0;j<s;j++)
		{
			Point tmp=getG(P[1],S[i][j],S[i][(j+1)%s],S[i][(j+2)%s]);double v=getV(P[1],S[i][j],S[i][(j+1)%s],S[i][(j+2)%s]);
			G+=tmp*v;sv+=v;
		}
	}
	G/=sv;
}
void solve()
{
	for(int i=1;i<=m;i++)
	{
		int s=S[i].size();double ans=-(s-2)*pi;
		for(int j=0;j<s;j++)
			ans+=angle(G,S[i][j],S[i][(j+1)%s],S[i][(j-1+s)%s]);
		ans/=4.0*pi;
		printf("%.7lf\n",ans);
	}
}
int main()
{
	init();
	solve();
	return 0;
}
```



---

## 作者：Purslane (赞：0)

# Solution

首先，如果我们有基本的文化课常识可以知道：如果一个空间中有 $n$ 个质点 $(x_i,y_i,z_i)$，每个质点质量为 $m_i$，他们整体的质心坐标为：

$$
\begin{aligned}
X &= \frac{\sum_{i=1}^n m_ix_i}{\sum_{i=1}^n m_i} \\
Y &= \frac{\sum_{i=1}^n m_iy_i}{\sum_{i=1}^n m_i} \\
Z &= \frac{\sum_{i=1}^n m_iz_i}{\sum_{i=1}^n m_i} 
\end{aligned}
$$

所以我们可以尝试将这个筛子进行四面体剖分，对于每个四面体求出其质心的坐标以及体积，求这些质心的加权和。

先考虑如何计算四面体的质心。它的四个顶点分别位于 $(x_i,y_i,z_i)$，$1 \le i \le 4$。

取前三个顶点组成的三角形的质心，并且把第四个顶点与坐标原点对齐，三角形的质心在 $z$ 轴上（假设位于 $z_0$）。使用微元法，对于 $z$ 轴上每一个极小的段，我们做平行于底面的面。这样相当于求很多小三角形的质心再积分。

很明显，质心也必定在 $z$ 轴上，且满足：

$$
Z = \frac{\int_{0}^{z_0} \frac{z^3}{z_0^2}S \text{ d}z}{\int_{0}^{z_0} \frac{z^2}{z_0^2}S \text{ d}z} = \dfrac{3}{4} z_0
$$

由于一个面的质心是三角形三个顶点的平均和，所以你发现实际上求四个顶点的加权和即可。

也就是质心位于：

$$
(\dfrac{x_1+x_2+x_3+x_4}{4},\dfrac{y_1+y_2+y_3+y_4}{4},\dfrac{z_1+z_2+z_3+z_4}{4})
$$

下面的问题是如何求四面体的体积。事实上，我入门行列式的时候，课本上对于行列式的定义就是平行多面体的有向体积。那么你手动推一个三阶行列式，再取绝对值之后除以 $2$ 即可。

------

然后考虑如何四面体剖分。回忆三角剖分的过程，你可以固定一个顶点，然后扫描每个边。那么四面体剖分也是类似的。你固定一个顶点，扫描每个面，再对每个棱锥的底面进行三角剖分。

于是你顺利的求解出了质心。最后求答案的时候只需要知道如何求二面角。

这个也简单。随便用一个面上不共线的两个向量求叉积得到这个面的某一个法向量，然后用法向量的点乘除以长度得到夹角的余弦值。

代码略。

---


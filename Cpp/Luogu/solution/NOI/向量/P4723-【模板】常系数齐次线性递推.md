# 【模板】常系数齐次线性递推

## 题目描述

求一个满足 $k$ 阶齐次线性递推数列 ${a_i}$ 的第 $n$ 项，即：

$$a_n=\sum\limits_{i=1}^{k}f_i \times a_{n-i}$$

## 说明/提示

$N = 10^{9} , K = 32000 $

保证读入的数字均为 $[-10^9,10^9]$ 内的整数。

## 样例 #1

### 输入

```
6 4
3 -1 0 4
-2 3 1 5```

### 输出

```
73```

# 题解

## 作者：BJpers2 (赞：239)

本问题的大致做法基本上是全网统一的，都是快速幂求$x^n$对特征多项式$p$取模的结果。

翻阅网上的题解，我发现它们对这种做法的解释都用到了线性代数内容，包括矩阵特征值，行列式，C-H定理等。

这些内容对于有基础的选手来说并不至于非常艰深，然而不可否认的是，一个事先并没有了解过这些线性代数内容的选手，面对一篇充满全新概念的题解，很可能会产生理解的障碍。

事实上，我们并不需要使用任何线性代数的知识来导出这个做法。

---

### 1. 返璞归真

让我们忘掉矩阵，行列式和特征值，采用小学层面的方法求斐波那契数列（一个经典的例子）的第$n$项。

我们换一个角度，倒过来求。假设我们现在欲求$fib_5$。

我们可以列出如下过程：$fib_5=fib_4+fib_3=2fib_3+fib_2=3fib_2+2fib_1=5fib_1+3fib_0$

最后带入$f_0,f_1$计算即可。

这当中的推导过程不是什么秘密，不过是每次取最前面那一项拿递推式展开罢了。

### 2. 本质

考虑一下上述过程本质上究竟干了什么，你可以先停一分钟自己好好思考一下。如果你想到了，本题解对你来说就已经没有阅读的价值。





> 上述过程，就是通过每次消去最高次项，求$x^5$对斐波那契数列的特征多项式——$x^2-x-1$取模的结果的过程。

如果你还没有反应过来，我可以展示一下：
$$
\begin{aligned}
& 0x^0+0x^1+0x^2+0x^3+0x^4+1x^5 \\
\xrightarrow{-1x^3(x^2-x-1)} & 0x^0+0x^1+0x^2+1x^3+1x^4 \\
\xrightarrow{-1x^2(x^2-x-1)} & 0x^0+0x^1+1x^2+2x^3 \\
\xrightarrow{-2x^1(x^2-x-1)} & 0x^0+2x^1+3x^2 \\
\xrightarrow{-3x^0(x^2-x-1)} & 3x^0+5x^1
\end{aligned}
$$
两者之间的逻辑关联很简单，因为前者是每次取和式里下标最大那一项，替换成两个下标较小的项之后加回去；而后者是每次从多项式里减去若干倍的$x^2$，并替换成相应倍数的$x+1$之后加回去。

### 3. 推广

理解了上述逻辑之后，我们能轻易将其推广到一般线性其次递推式的情形：
$$
f_i=p_1f_{i-1}+p_2f_{i-2}+\dots+p_kf_{i-k}
$$
要求$f_n$，只要求多项式$x^n$对
$$
p(x)=x^k-p_1x^{k-1}-p_2x^{k-2}-\dots-p_kx^0
$$
取模的结果。因为「多项式取模」的过程恰好与「每次按递推式展开下标最大的那项」的过程一致，都可以用「替换」来解读。

### 4. 多项式取模

接下来基本上就是多项式取模的板子，会多项式取模的可以直接跳过。

我们写一个快速幂，求多项式$x$的$n$次方，只不过每次乘法都对上面提到的特征多项式$p(x)$取模。

那么需要解决的问题变为快速求一个$l=2k-2$次多项式对一个$k$次多项式取模的结果。

也即需把一个$l$次多项式$a$展开成$a=pq+r$的形式，其中$q$是商，$r$是余数（也就是我们的目标）。

我们设$a^R$为多项式$a$的反转（第$l$项和第$0$项互换，第$l-1$项和第$1$项互换，以此类推），易得$a^R\equiv p^Rq^R \bmod x^{l-k+1}$。

因此我们只需求出$p^R$在模$x^{l-k+1}$意义下的逆元，乘上$a^R$即可得到$q^R$。最后利用$r=a-pq$即可求出我们需要的$r$。

### 5. 后记

本片题解介绍的思路应该有很多前人想到，但是令我比较吃惊的是没有人把它发表出来（或者是发表了我没有看到）。希望这篇题解能让初次接触线性递推的选手不要被纷繁复杂的数学公式劝退，少走弯路，更深入地理解这个算法。

### 6. 代码

稍微有点压行。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define FF FOF(i,0,L)
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define FOF(i,a,b) for(int i=a;i< b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
#define CON(a,b) DFT(a,L);FF a[i]=1ll*a[i]*b[i]%P;IFT(a,L);
using namespace std;
const int N=150150,P=998244353;
int n,m,K,L,o,A,Q;
int rv[N],W[N],p[N],f[N],t[N],a[N],b[N];
void ipt(int&x){scanf("%d",&x);x%=P;x+=x>>31&P;}
int qpw(int x,int y){int z=1;for(;y;y>>=1,x=1ll*x*x%P)if(y&1) z=1ll*z*x%P;return z;}
void ini(int n){
	for(L=1;L<=n;L<<=1,o++);
	FF rv[i]=rv[i>>1]>>1|(i&1)<<(o-1);
	int V=qpw(3,P>>o);W[L>>1]=1;
	FOF(i,(L>>1)+1,L) W[i]=1ll*W[i-1]*V%P;
	ROF(i,(L>>1)-1,1) W[i]=W[i<<1];
}
void DFT(int*A,int L){
	static unsigned long long B[N];
	int u=o-__builtin_ctz(L),t;
	FF B[i]=A[rv[i]>>u];
	for(int i=1;i<L;i<<=1)for(int j=0,s=i<<1;j<L;j+=s)FOF(k,0,i)
		t=B[i+j+k]*W[i+k]%P,B[i+j+k]=B[j+k]+P-t,B[j+k]+=t;
	FF A[i]=B[i]%P;
}
void IFT(int*A,int L){
	reverse(A+1,A+L);DFT(A,L);
	int V=P-(P-1)/L;
	FF A[i]=1ll*A[i]*V%P;
}
int upl(int n){return 1<<(32-__builtin_clz(n));}
void INV(int*A,int*B,int n){
	static int C[N],L;
	if(!n) return B[0]=qpw(A[0],P-2),void();
	INV(A,B,n>>1);L=upl(n<<1);
	FF C[i]=i>n?0:A[i];
	DFT(C,L);DFT(B,L);
	FF B[i]=(2-1ll*C[i]*B[i]%P+P)*B[i]%P;IFT(B,L);
	FF B[i]=i>n?0:B[i],C[i]=0;
}
void MUL(int*A,int*B){
	static int C[N];
	FF C[i]=A[i];DFT(C,L);
	CON(B,C);
	FF C[i]=i>K?0:B[n-i];
	CON(C,t);
	FF C[i]=i>K?0:C[i];
	reverse(C,C+K+1);
	CON(C,p);
	FF (B[i]+=P-C[i])%=P;
}
int main(){
	scanf("%d%d",&Q,&m);
	ini(m<<1);n=m-1<<1;K=n-m;
	FOR(i,1,m) ipt(p[i]);
	FOF(i,0,m) ipt(f[i]);
	p[0]=P-1;
	INV(p,t,K);DFT(t,L);
	reverse(p,p+m+1);DFT(p,L);
	a[1]=b[0]=1;
	for(;Q;Q>>=1,MUL(a,a))if(Q&1) MUL(a,b);
	FOF(i,0,m) (A+=1ll*b[i]*f[i]%P)%=P;
	cout<<A<<'\n';
}
```





---

## 作者：shadowice1984 (赞：93)

十分好奇同一个复杂度的代码为啥我跑了780ms有人跑了7800ms

这里介绍一个线性代数黑科技——常系数齐次线性递推式的优化
_________________

### 前置知识：多项式求逆

蛤你不会多项式求逆？出门左转模板区多项式求逆

### 前置知识：多项式除法，多项式取模

蛤你不会多项式取模?出门左转模板区多项式除法

## 本题题解

# 常系数齐次线性递推式第n项的快速计算

### 翻译

首先这个标题讲的不是人话，我们来尝试翻译一下

我们要快速的求一个递推式的第n项

而这个递推式满足以下几个条件

1.它是常系数的，换句话说递推系数和下标n无关

2.它是线性的，换句话说递推式中每一项的次数都是1，没有乱七八糟的2次3次项

3.它是齐次的，换句话说递推式的常数项等于0

(事实上带常数项的东西我们也能做，不过这里暂时不提及了)

____________________

好了如果看不懂文字说明也没关系，我们要算数，算的是$f_{n}$

其中满足当$n \geq k$时

## $f_{n}=\sum_{i=1}^{k}a_{i}f_{n-i}$

如果$n \leq k$的话我们会给你输入这个递推序列的初值

### 暴力

我会矩阵快速幂！(什么你不会矩阵快速幂？，同是黄牌题还是要写一写的)

那么我们发现直接计算的复杂度是$O(k^3logn)$的，这顶多算是将复杂度向n倾斜，根本算不上什么优化

但是我们发现矩阵乘法是有启发性意义的，换句话说我们只需要以一种奇技淫巧计算出转移矩阵的n次幂即可

但是让我们仔细想想，我们真的需要转移矩阵的n次幂吗?

_____________

#### 魔法的开始

其实你并不关心转移矩阵的n次幂，你只关心初值向量$St$（就是那k个初始值构成的数组）乘上这个转移矩阵的n次幂所得到的向量

进一步的讲我们甚至不关心这个向量长什么样，我们只关心这个向量的第一项是什么

所以说矩阵乘法之所以慢是因为你知道的太多了……

(以下为了方便我们假设转移矩阵为A)

那么假设我们构造了一个奥妙重重的序列c使得

## $A^{n}=\sum_{i=0}^{k-1}c_{i}A^{i}$

你可能会说，这有个皮皮用，$O(k^4)$还不如我矩阵快速幂快

但是我们冷静一下，又没让我们求$A^{n}$,我们真正感兴趣的是$St×A^{n}$

所以我们让等式两边同时乘上一个向量$St$

## $St×A^{n}=St×\sum_{i=0}^{k-1}c_{i}A^{i}$

此时矩阵乘法对于矩阵加法是具有分配律的，所以我们可以将向量$St$分配进去

## $St×A^{n}=\sum_{i=0}^{k-1}c_{i}St×A^{i}$

此时还是没个什么用，但是让我们继续冷静一下，我们真正关心的是这个向量的第0项，所以我们发现刚才的等式在取每个向量的第0项的意义下也是成立的

## $Ans=(St×A^{n})_{0}=\sum_{i=0}^{k-1}c_{i}(St×A^{i})_{0}$

等会，$(St×A^{i})_{0}$是什么啊，转移了i次的向量的第0项？每转移一次这个向量的第0项会变成上一个向量的第1项，第1项变成第2项，……以此类推

那$(St×A^{i})_{0}$不就是$St_{i}$吗？

然后请擦亮你的双眼

## $Ans=\sum_{i=0}^{k-1}c_{i}St_{i}$

换句话说只要我们可以求出$c$我们就可以在$O(k)$时间内计算出$Ans$
__________________

#### 多项式科技-构造序列c

前面的推倒过程中我们发现了c序列十分的神奇，有了c序列我们就可以快速计算答案

但是问题来了我们怎么计算c序列呢？

回想一遍c的定义，是满足这个条件的数组

## $A^{n}=\sum_{i=0}^{k-1}c_{i}A^{i}$

那么我们发现两边的次数不等，换句话说这样的c很有可能不存在……

所以我们先将$A^{n}$写成这样的形式

## $A^{n}=Q(A)G(A)+R(A)$

其中$Q,G,R$是一些以矩阵为参数的多项式，然后满足$Q(A)G(A)$的次数为n

然后此时我们发现$R(A)$的次数小于$G(A)$的次数，那么如果我们钦定$G(A)$的次数为k的话，那么我们就可以将$A^{n}$写成这样的形式

## $A^{n}=Q(A)G(A)+\sum_{i=0}^{k-1}c_{i}A^{i}$

此时我们最好祈祷这个多项式$G$十分神奇，它满足$G(A)=0$，假设我们足够幸运的话，$G(A)$的系数会是这样的一个数列，满足

## $\sum_{i=0}^{k}g_{i}A^{i}=0$

那么我们就可以奇迹般的消掉$Q(A)G(A)$这一项，此时

## $A^{n}=\sum_{i=0}^{k-1}c_{i}A^{i}=R(A)$

换句话说c数组就是多项式$R(A)$的系数,求多项式$R(A)$就行了

刚才的关于$R(A)$的方程，我好像在哪里见过……，对了，是多项式取模模板题的等式

换句话说

## $R(A)=A^{n}modG(A)$

好了问题来了怎么求$A^{n}modG(A)$呢？

直接快速幂就行了，只是把平常中快速幂的取模换成了多项式取模就行了

如果不会多项式取模的话可以去隔壁模板区学习
_________________

### 特征多项式

根据刚才的推倒过程我们知道了只要构造一个数列g，使得

## $\sum_{i=0}^{k}g_{i}A^{i}=0$

我们就可以在$O(klogklogn)$时间内构造一个数组c，使得

## $A^{n}=\sum_{i=0}^{k-1}c_{i}A^{i}$

然后就可以在$O(k)$的时间内计算出答案

## $Ans=\sum_{i=0}^{k-1}c_{i}St_{i}$

但是问题是如何构造一个序列g呢，到刚才为止我们都没有用到关于常系数齐次线性递推式的任何知识，换句话说刚才的推倒对于任意矩阵都成立

如果对于任意一个矩阵我们都可以平凡的构造出一个序列g的话那矩乘基本就废了

所以g的构造肯定没那么简单

但是事实上根据一些线性代数的黑科技我们还是可以构造出g的，下面是推倒过程~

## 如果你不愿意进行数学证明，那么可以直接记住这个结论

假设递推系数是$a_{1}...a_{k}$

那么$g_{k-i}=a_{i}$,$g_{k}=1$，记住这个结论之后就可以直接去写代码了
____________________

#### 前置知识:特征值与特征向量

如果等式

## $ (\lambda I-A)v=0$

成立，那么$\lambda$称为A的特征值，v称为A的特征向量

以下是几个我也不会证的结论

1.如果大小为n×n的矩阵A满秩(行列式不为0)，那么A有n组**线性无关的**特征向量

2.如果$Det( \lambda I-A)=0$那么存在向量v使得等式成立，否则不存在这样的向量v

__________________


#### 前置知识:Cayley-Hamilton定理

这里给出一个C-H定理十分不标准的表述，下面的等式在方阵A满秩时恒成立

## $\prod_{k}(\lambda_{k} I-A)=0$

其中$\lambda_{k}$是A的第k个特征值

证明的话我们采取这样的思路

我们不直接证明这个矩阵为0矩阵，而是证明任意向量乘上这个矩阵为0

然后我们要证明任意向量乘上这个东西是0矩阵还是有点难度

但是由于A有n组线性无关的特征向量，因此我们可以将这个任意向量表示为这n个向量的若干倍的和的形式

如果我们可以证明这个矩阵乘上任意特征向量为0矩阵的话，自然任意向量乘这个矩阵就是0矩阵了

问题来了怎么证明它乘任意特征向量为0矩阵呢？

先说明一个小结论

### $(aI-A)(bI-A)=abI^2-bAI-aAI-A^2=(bI-A)(aI-A)$

然后我们就可以证明C-H定理

## $v_{i}\prod_{k}(\lambda_{k} I-A)=v_{i}(\lambda_{i}I-A)\prod_{k \neq i}(\lambda_{k} I-A)$

## $=0×\prod_{k \neq i}(\lambda_{k} I-A)=0$

具体来说就是因为像上面那种括号相乘的矩阵是可交换的，所以我们可以把这个特征向量对应的矩阵从$\Pi$里交换出来，那么这两个东西相乘自然等于0了

_______________________

换句话说多项式

##  $\prod_{k}(\lambda_{k} I-A)$

就是我们想要找的$G(A)$

问题来了怎么算这个多项式啊……

这里有个奇怪的结论是上面这个多项式和下面这个多项式的系数是一样的

## $f(\lambda)=Det(\lambda I-A)$

喂这两个函数主元不一样甚至传的参数都不一样你让我怎么相信啊……

但是仔细思考一下上下两个多项式，(这里不强调函数是因为主元不一致，你可以理解成一个二元函数)是否有相同的0点呢?

答案是肯定的，$\lambda_{1},\lambda_{2}...\lambda_{k}$都是这两个多项式的0点，而且这两个多项式中$\lambda$的次数都是一样的(为什么一样会构造证明)，所以这两个多项式的系数自然是一致的

_________________________


那么问题转化为了求函数

## $f(\lambda)=Det(\lambda I-A)$

的系数

我们发现对于一般的矩阵来讲这个多项式的系数会非常的不好求，

但是我们可以将这个常系数齐次线性递推式的矩阵画出来，手玩一下行列式会发现

## $f(\lambda)=(-1)^n(\lambda^n-\sum_{i-1}^{n}a_{i}\lambda^{n-i})$

由于将函数取反之后函数的0点依旧不变，因此实际写代码的时候可以省略那个$(-1)^n$项

____________________________

## 实现

没啥好说的，不要想着卡常数，取模和求逆的时候不要吝啬你的ntt

一个优化是因为每次都是模的同一个多项式，因此可以预处理出$G(A)$和$G_{reverse}^{-1}(A)$的ntt形式，然后可以只求逆一次

然后就是数组无脑清空吧……

上代码(最慢的点796ms)

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=65536+10;typedef long long ll;const ll mod=998244353;
int n;int k;int rv[20][N];ll rt[20][20];int Len;ll tr1[N];ll tr2[N];long long st[N];long long xs[N];
ll sg[N];ll a[N];ll res[N];ll irg[N];ll q[N];ll rf[N];int DL=-1;ll ans=0;ll ret[N];
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
inline void ntt(ll* a,int o,int len,int d)//ntt
{
    for(int i=0;i<len;i++)if(i<rv[d][i])swap(a[i],a[rv[d][i]]);
    for(int k=1,j=1;k<len;k<<=1,j++)
        for(int s=0;s<len;s+=(k<<1))
            for(int i=s,w=1;i<s+k;i++,w=w*rt[o][j]%mod)
            {ll a0=a[i];ll a1=a[i+k]*w%mod;a[i]=(a0+a1)%mod,a[i+k]=(a0+mod-a1)%mod;}
    if(o==1){ll inv=po(len,mod-2);for(int i=0;i<len;i++)(a[i]*=inv)%=mod;}
}
inline void poly_inv(ll* a,ll* b,int len)//求逆
{
    b[0]=po(a[0],mod-2);
    for(int k=1,j=0;k<=len;k<<=1,j++)
    {
        for(int i=0;i<k;i++)tr1[i]=a[i];for(int i=0;i<k;i++)tr2[i]=b[i];
        ntt(tr1,0,k<<1,j);ntt(tr2,0,k<<1,j);
        for(int i=0;i<(k<<1);i++)b[i]=tr2[i]*(2+mod-tr1[i]*tr2[i]%mod)%mod;
        ntt(b,1,k<<1,j);for(int i=k;i<(k<<1);i++)b[i]=0;
    }
}
inline void poly_mod(ll* a)//取模
{
    int mi=(k<<1);while(a[--mi]==0);if(mi<k)return;
    for(int i=0;i<(Len<<1);i++)rf[i]=0;for(int i=0;i<=mi;i++)rf[i]=a[i];
    reverse(rf,rf+mi+1);for(int i=mi-k+1;i<=mi;i++)rf[i]=0;ntt(rf,0,Len<<1,DL+1);
    for(int i=0;i<(Len<<1);i++)q[i]=(rf[i]*irg[i])%mod;ntt(q,1,(Len<<1),DL+1);
    for(int i=mi-k+1;i<=(Len<<1);i++)q[i]=0;reverse(q,q+mi-k+1);ntt(q,0,(Len<<1),DL+1);
    for(int i=0;i<(Len<<1);i++)(q[i]*=sg[i])%=mod;ntt(q,1,(Len<<1),DL+1);
    for(int i=0;i<k;i++)(a[i]+=mod-q[i])%=mod;for(int i=k;i<=mi;i++)a[i]=0;
}
int main()
{
    for(int i=0;i<=15;i++)
        for(int j=0;j<(1<<(i+1));j++)rv[i][j]=(rv[i][j>>1]>>1)|((j&1)<<i);
    for(int t=2,j=1;j<=18;t<<=1,j++)rt[0][j]=po(3,(mod-1)/t);
    for(int t=2,j=1;j<=18;t<<=1,j++)rt[1][j]=po(332748118,(mod-1)/t);
    scanf("%d%d",&n,&k);
    for(Len=1;Len<=k;Len<<=1,DL++); //预处理
    for(int i=1;i<=k;i++){scanf("%lld",&xs[i]);xs[i]=xs[i]<0?xs[i]+mod:xs[i];}
    for(int i=0;i<k;i++){scanf("%lld",&st[i]);st[i]=st[i]<0?st[i]+mod:st[i];}
    for(int i=1;i<=k;i++)sg[k-i]=mod-xs[i];sg[k]=1;for(int i=0;i<=k;i++)ret[i]=sg[i];
    for(int i=0;i<=k;i++)rf[i]=sg[i];reverse(rf,rf+k+1);poly_inv(rf,irg,Len);
    for(int i=0;i<=k;i++)rf[i]=0;ntt(sg,0,Len<<1,DL+1);ntt(irg,0,Len<<1,DL+1);a[1]=1;res[0]=1;
    while(n)//快速幂
    {
        if(n&1)
        {
            ntt(res,0,Len<<1,DL+1);ntt(a,0,Len<<1,DL+1);
            for(int i=0;i<(Len<<1);i++)(res[i]*=a[i])%=mod;
            ntt(res,1,Len<<1,DL+1);ntt(a,1,Len<<1,DL+1);poly_mod(res);
        }ntt(a,0,Len<<1,DL+1);for(int i=0;i<(Len<<1);i++)(a[i]*=a[i])%=mod;
        ntt(a,1,Len<<1,DL+1);poly_mod(a);n>>=1;
    }for(int i=0;i<k;i++)(ans+=res[i]*st[i])%=mod;printf("%lld",ans);return 0;
}
```












---

## 作者：Elegia (赞：66)

这是一篇对于新线性递推论文的解读，你可以在[这里](https://arxiv.org/pdf/2008.08822.pdf)找到原文。

一个众所周知的线性递推计算方法是考虑的通过快速幂计算多项式取模 $x^N \bmod Q(x)$，这被称为 Fiduccia 算法（1985）。设做多项式乘法的时间为 $\mathsf M(n)$，在一般环上的计算需要约 $\mathsf (3\log N + O(1))\mathsf M(d)$ 的运算量，即使在可以做 FFT 的运算下也只能做到 $\mathsf (2\log N + O(1))\mathsf M(d)$ 的运算量。

而新的算法可以做到一般环上 $(2\log N + O(1))\mathsf M(d)$ 的运算量，和在可以做 FFT 的运算下做到 $(\frac 23 \log N + O(1))\mathsf M(d)$ 的运算量。也就是说在我们通常有 NTT 模数的情况下，**同样的 FFT 实现可以让我们的常数大约是原先方法的 $\frac {\mathbf 1}{\mathbf3}$。**

新线性递推算法的主要思想是考虑将线性递推转化为生成函数的形式 $\frac{P(x)}{Q(x)}$。注意我们容易在 $\mathsf M(n)$ 的时间内通过数列的前 $d$ 项得到 $P(x)$，只需计算 $\left[(\sum_{i<d} f_i x^i) Q(x)\right] \bmod x^d$。接下来我们考虑这样一件事：

$$
\frac {P(x)}{Q(x)} = \frac{P(x)Q(-x)}{Q(x)Q(-x)}
$$

这发生了什么呢？我们注意记 $V(x)=Q(x)Q(-x)$，可以发现 $V(x)=V(-x)$，说明 $V(x)$ 只有偶次项有值，因此我们就得到了分解

$$
\frac{P(x)}{Q(x)} = \frac {E(x^2)}{U(x^2)} + x\frac {O(x^2)}{U(x^2)}, \quad U(x^2)=Q(x)Q(-x)
$$

因为这分别填满了二进制的 $0$ 和 $1$ 位，所以我们只需递归到一侧即可。

不难发现朴素实现就是上下都做多项式乘法，每一个二进制位约消耗 $2\mathsf M(d)$ 的时间。

接下来我们看看可以如何优化常数。我们记 DFT 的时间为 $\mathsf E(2n)$，可得 $\mathsf M(n)=3\mathsf E(2n)$。

## $\rightarrow \frac 43 \mathsf M(d)$

我们注意当知道 $Q(x)$ 的 DFT 时，可以直接得到 $Q(-x)$ 的 DFT。记 $A_k$ 的 DFT 数组为 $\widehat A_k$，读者不难自行验证 $B_k=(-1)^kA_k$ 的 DFT 数组对应有 $\widehat B_k = \widehat A_{k \oplus \frac n2}$。

因此我们减少了 $\frac 13$ 的 FFT 运算量，变为 $4\mathsf E(2d)=\frac 43 \mathsf M(d)$。

## $\rightarrow \mathsf M(d)$

注意到 $Q(x)Q(-x)$ 最后只剩下偶数项，而 $P(x)Q(-x)$ 我们要么只要奇数项要么只要偶数项，假设我们要提取 $A_k$ 的所有偶数项，那么设 $B_k = \frac{A_k + (-1)^k A_k}{2}$，可得 $\widehat B_k = \frac{\widehat A_k + \widehat A_{k \oplus \frac n2}}2$，然后对前 $n/2$ 项做长为 $n$ 的 IDFT 即可，奇数项是类似的。

因此我们将其中的两个 $\mathsf E(2d)$ 换成了 $\mathsf E(d)$，运算量变为 $2\mathsf E(2d) + 2\mathsf E(d) = \mathsf M(d)$。

## $\rightarrow \frac 23\mathsf M(d)$

我们考虑不做上一步的 IDFT，始终以 DFT 的形式维护 $P,Q$。那么我们是否能够更小常数地从 $A$ 的长为 $n$ 的 DFT 推出长为 $2n$ 的 DFT 呢？

事实上我们可以在 $2\mathsf E(n)$ 内完成。只需注意到以下两件事：

$$
\begin{aligned}
\widehat A^{(2n)}_{2k} &= \widehat A_k\\
\widehat A^{(2n)}_{2k+1} &= \sum_i (\omega_{2n}^{i}A_i) \omega_n^{ik}
\end{aligned}
$$

因此我们先 IDFT 得到 $A$，然后乘以 $\omega_{2n}^i$ 再做 DFT 就可以了。

现在整个迭代流程只有对 $P,Q$ 的 DFT 数组倍长用到了 FFT，运算量为 $4\mathsf E(d) = \frac 23 \mathsf M(d)$。


---

## 作者：Great_Influence (赞：19)

终于调过了...

本题中的线性递推，特指常系数齐次递推。

常系数齐次线性递推(之后简称线性递推)指的是形如:

$$a(x)=\sum_{i=1}^ka(x-i)f(i)$$

的递推式，其中$a(0)\to a(k-1)$都是已知数。

可以知道，这种递推可以通过构造矩阵来实现快速递推。

对于线性递推，转移矩阵为:

$$A=\begin{pmatrix}a_1&a_2&a_3&\dots&a_{k-2}&a_{k-1}&a_k\\1&0&0&\dots&0&0&0\\0&1&0&\cdots&0&0&0\\\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\0&0&0&\cdots&1&0&0\\0&0&0&\cdots&0&1&0\end{pmatrix}$$

这个矩阵乘上列向量$F=\begin{pmatrix}f_{k-1}\\f_{k-2}\\\vdots\\f_0\end{pmatrix}$可以得到$\begin{pmatrix}f_k\\f_{k-1}\\\vdots\\f_1\end{pmatrix}$。

那么，答案变成:

$$\sum_{i=0}^{k-1}(FA^n)_i$$

利用矩阵快速幂，可以得到$O(k^3logn)$的算法。对于本题不可承受。

我们尝试转换思想。矩阵乘法的时间复杂度为$O(k^3)$,而多项式乘法为$O(k^2)$(借助$FFT$可以优化至$O(klogk)$),明显更加优秀，所以考虑将矩阵乘法转换为多项式乘法。

可以发现，$a(x)=\displaystyle\sum_{i=0}^{k-1}(FA^x)_i$这个式子可以通过转移变成$\displaystyle\sum_{i=0}^{k-1}p_ia_i$($p_i$为系数)。那么，我们考虑通过什么操作可以将其转换。

(此处需要特征多项式的相关知识)

定义矩阵$A$的特征多项式为

$$g(\lambda)=det(\lambda E-A)$$

其中$E$为单位矩阵。

那么，根据[Cayley-Hamilton 定理](https://en.wikipedia.org/wiki/Cayley%E2%80%93Hamilton_theorem) 可知，$g(A)=0$。

那么，我们要求的变成了:

$\displaystyle\sum_{i=0}^{k-1}(FA^n)_i=\sum_{i=0}^{k-1}[F[A^n\bmod g(A)]]_i$

此时存在两种做法，一种是直接计算，时间复杂度$O(k^2logn)$,另一种是套用[多项式取余](https://www.luogu.org/problemnew/show/P4512)，做到$O(klogklogn)$。我们明显是需要后者。

接下来的问题就只剩下如何计算$g(\lambda)$了。

$g(\lambda)=det(\lambda E-A)$

$=det\begin{pmatrix}\lambda-a_1&-a_2&-a_3&\dots&-a_{k-2}&-a_{k-1}&-a_k\\-1&\lambda&0&\dots&0&0&0\\0&-1&\lambda&\cdots&0&0&0\\\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\0&0&0&\cdots&-1&\lambda&0\\0&0&0&\cdots&0&-1&\lambda\end{pmatrix}$

考虑对第一行展开分别求和，得:

$g(\lambda)=(\lambda-a_1)A_{1,1}+(-a_2)A_{1,2}+\cdots+(-a_k)A_{1,k}$

$=\lambda^k-a_1\lambda^{k-1}-\cdots-a_k$

这样就可以在$O(k)$的时间复杂度求出特征多项式了。



代码:(大常数警告)

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    freopen("polynomial.in","r",stdin);
    freopen("polynomial.out","w",stdout);
}
const int MAXN=1<<20;

typedef long long ll;

namespace polynomial
{
    static int mod=998244353,gen=3,g[21],rev[MAXN],Len;

    inline int ad(int a,int b){return (a+=b)>=mod?a-mod:a;}

    inline int power(int a,int b)
    {
        static int sum;
        for(sum=1;b;b>>=1,a=(ll)a*a%mod)if(b&1)
            sum=(ll)sum*a%mod;
        return sum;
    }

    inline void predone()
    {
        static int i,j;
        for(i=1,j=2;i<=19;++i,j<<=1)g[i]=power(gen,(mod-1)/j);
    }

    inline void calrev(int Len)
    {
        static int Logl;Logl=(int)floor(log(Len)/log(2)+0.3)-1;
        Rep(i,1,Len-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<Logl);
    }

    inline void NTT(int X[],int typ)
    {
        Rep(i,1,Len-1)if(i<rev[i])swap(X[i],X[rev[i]]);
        static int i,j,k,kk,w,t,wn,r;
        for(k=2,kk=1,r=1;k<=Len;k<<=1,kk<<=1,++r)
        {
            wn=g[r];
            for(i=0;i<Len;i+=k)for(j=0,w=1;j<kk;++j,w=(ll)w*wn%mod)
            {
                t=(ll)w*X[i+j+kk]%mod;
                X[i+j+kk]=ad(X[i+j],mod-t);
                X[i+j]=ad(X[i+j],t);
            }
        }
        if(typ==-1)
        {
            reverse(X+1,X+Len);
            static int invn;invn=power(Len,mod-2);
            Rep(i,0,Len-1)X[i]=(ll)X[i]*invn%mod;
        }
    }

    static int x[MAXN],y[MAXN];
    inline void mul(int a[],int b[])
    {
        memset(x,0,sizeof x);memset(y,0,sizeof y);
        Rep(i,0,(Len>>1)-1)x[i]=a[i],y[i]=b[i];
        NTT(x,1);NTT(y,1);
        Rep(i,0,Len-1)x[i]=(ll)x[i]*y[i]%mod;
        NTT(x,-1);
        Rep(i,0,Len-1)a[i]=x[i];
    }
    
    static int A[MAXN],B[MAXN];

    void Inv(int *a,int *b,int n)
    {
        if(n==1){b[0]=power(a[0],mod-2);return;}
        Inv(a,b,n>>1);
        Len=n<<1;
        calrev(Len);
        Rep(i,0,(Len>>1)-1)A[i]=a[i],B[i]=b[i];
        NTT(A,1);NTT(B,1);
        Rep(i,0,Len-1)B[i]=(ll)B[i]*B[i]%mod*A[i]%mod;
        NTT(B,-1);
        Rep(i,0,(Len>>1)-1)b[i]=ad(b[i],ad(b[i],mod-B[i]));
        Rep(i,0,Len)A[i]=B[i]=0;
    }

    static int X[MAXN],Y[MAXN],TT[MAXN];

    inline void Div(int *a,int n,int *b,int m)
    {
		if(n<m){Rep(i,0,m-1)b[i]=a[i];return;}
        memcpy(X,a,sizeof X);memcpy(Y,b,sizeof Y);
        reverse(b,b+m+1);reverse(X,X+n+1);
        Rep(i,n-m+1,n)X[i]=0;
        memset(TT,0,sizeof TT);
        for(Len=2;Len<=(n-m+1);Len<<=1);
        Inv(b,TT,Len);
        memcpy(b,TT,sizeof TT);
        while(Len<=(n<<2))Len<<=1;
        calrev(Len);
        mul(X,b);reverse(X,X+n-m+1);
        Rep(i,n-m+1,n)X[i]=0;
        mul(Y,X);
		Rep(i,0,m-1)b[i]=ad(a[i],mod-Y[i]);
        memcpy(a,X,sizeof X);
    }
}
using namespace polynomial;

static int n,F[MAXN],G[MAXN],m,AA[MAXN],KK[MAXN];

static int R[MAXN];

inline void MMM(int *A,int *B,int *Mo,int lp)
{
	Chkmin(lp,m<<1);
    calrev(Len);mul(A,B);
    memcpy(R,Mo,sizeof R);
	Div(A,lp,R,m);
	Rep(i,m,m<<1)A[i]=0;
	Rep(i,0,m-1)A[i]=R[i];
}

inline void KSM(int *A,int x,int *B,int *Mo)
{
    for(int i=1;x;x>>=1,MMM(A,A,Mo,2<<i),++i)
	{
        if(x&1)MMM(B,A,Mo,m<<1);
		if((1<<(i-1))>=(m<<1))--i;
	}
}

int main(void){
//    file();
    predone();
    read(n);read(m);
    for(Len=2;Len<=(m<<1);Len<<=1);
    Rep(i,1,m)read(F[m-i]),F[m-i]=ad(0,mod-F[m-i]);
    F[m]=1;
    Rep(i,0,m-1)read(AA[i]),AA[i]=ad(AA[i],mod);
    G[1]=1;KK[0]=1;
    KSM(G,n,KK,F);
    static int ans=0;
    Rep(i,0,m-1)ans=ad(ans,(ll)AA[i]*KK[i]%mod);
    cout<<ans<<endl;
//	cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}
```

---

## 作者：hly1204 (赞：17)

这是一篇论文的部分翻译，对于算法的详细解读参考 EI 的题解 <https://www.luogu.com.cn/blog/EntropyIncreaser/solution-p4723> 。

这也是我少数的尝试翻译论文，有错误的地方感谢指出。

---

对于问题的严谨定义略去。

#### 常系数线性递推

输入序列 $(u_{n})_{n\geq 0}$ 满足以下递推关系：

- (C) 常系数且线性，形式为 $u_{n+d}=c_{d-1}u_{n+d-1}+\cdots +c_{0}u_{n},\quad n\geq 0$ 对于一些给出的系数 $c_{0},\cdots ,c_{d-1}\in R$ 。在这种情况下我们简单的说序列是线性递推（或者 C-recurisive ）的。最基础的例子为几何序列 $(q^{n})_{n\geq 0}$ ，对于 $q\in R$ 和斐波那契序列 $(F_{n})_{n}$ 且 $F_{n+2}=F_{n+1}+F_{n},F_{0}=0,F_{1}=1$ 。

- (P) 略

- (Q) 略

下面仅讨论 (C) 中的情况。

Miller 和 Spencer Brown 在 1966 年展示了将
$$u_{n+d}=c_{d-1}u_{n+d-1}+\cdots +c_{0}u_{n},\quad n\geq 0$$
转换为
$$\underbrace{\begin{bmatrix}
u_{n}\\u_{n+1}\\\vdots\\u_{n+d-1}
\end{bmatrix}}_{v_{n}}=\underbrace{\begin{bmatrix}
&1&&\\
&&\ddots&\\
&&&1\\
c_{0}&c_{1}&\cdots&c_{d-1}
\end{bmatrix}}_{M}\times\underbrace{\begin{bmatrix}
u_{n-1}\\u_{n}\\\vdots\\u_{n+d-2}
\end{bmatrix}}_{v_{n-1}},\quad n\geq 1
$$
在环 $\mathcal{M}_{d}(R)$ 上用二进制幂（快速幂）计算即可。

（原文采用这种描述，而一般大家使用的矩阵可能是转置之后的，但是本质是一样的）。

#### Fiduccia 的算法
当前最好的算法来源于 Fiduccia ，基于下列观察：矩阵 $M$ 为友矩阵 $C$ 的转置，表示了 $R$ -线性从商环 $R[x]/(\Gamma)$ 映射到自身，其中 $\Gamma =x^{d}-\sum_{i=0}^{d-1}c_{i}x^{i}$ 。因此令 $e$ 为一个行向量 $e=\begin{bmatrix}1&0&\cdots &0\end{bmatrix}$ ，那么第 $N$ 项 $u_{N}$ 等于
$$u_{N}=e\cdot v_{N}=e\cdot M^{N}\cdot v_{0}=(C^{N}\cdot e^{T})^{T}\cdot v_{0}=\langle x^{N}\bmod \Gamma ,v_{0}\rangle$$
其中内积发生在向量 $v_{0}=\begin{bmatrix}u_{0}&\cdots&u_{d-1}\end{bmatrix}$ （为序列 $(u_{n})_{n\geq 0}$ 初始的几项）和 $x^{N}\bmod \Gamma$ 中。

#### LSB-first 算法
令递推序列与多项式 $Q(x):=1-c_{d-1}x-\cdots -c_{0}x^{d}$ 关联，这就是特征多项式 $\Gamma (x)=x^{d}-\sum_{i=0}^{d-1}c_{i}x^{i}$ 的系数翻转。
令 $F(x)$ 为序列 $(u_{n})_{n\geq 0}$ 的生成函数，
$$F(x):=\sum_{n\geq 0}u_{n}x^{n}$$
然后，存在一个多项式 $P(x)\in R[x]$ 其 $\deg P\lt d$ 满足 $F(x)=P(x)/Q(x)\in R[[x]]$ ，观察 $P(x):=F(x)Q(x)$ 发现 $P(x)=u_{0}+(u_{1}-c_{d-1}u_{0})x+(u_{2}-c_{d-1}u_{1}-c_{d-2}u_{0})x^{2}+\cdots $ ，其中 $[x^{n+d}]P(x)=u_{n+d}-c_{d-1}u_{n+d-1}-\cdots -c_{0}u_{n}=0,\forall n\geq 0$ 。可以通过一次多项式乘法计算 $P(x)$ 。

我们可将计算有理幂级数（ rational power series ） $F(x)=P(x)/Q(x)$ 的第 $N$ 项系数 $u_{N}$ 的问题减少。新算法基于以下观察：多项式 $Q(x)Q(-x)$ 为偶的，记为 $V(x^{2})$ 且 $V\in R[x]$ 且 $\deg V=d$ 。后记 $U(x)$ 为多项式 $P(x)Q(-x)$ ，且 $\deg U\lt 2d$ ，记 $U_{e}$ 和 $U_{o}$ 分别表示偶和奇的部分，那么 $U(x)=U_{e}(x^{2})+x\cdot U_{o}(x^{2})$ ，我们有
$$\frac{P(x)}{Q(x)}=\frac{P(x)Q(-x)}{Q(x)Q(-x)}=\frac{U_{e}(x^{2})}{V(x^{2})}+x\cdot \frac{U_{o}(x^{2})}{V(x^{2})}$$
其中
$$\begin{aligned}
\frac{U_{e}(x^{2})}{V(x^{2})}&=u_{0}+0+u_{2}x^{2}+0+u_{4}x^{4}+\cdots\\
\frac{U_{o}(x^{2})}{V(x^{2})}&=u_{1}+0+u_{3}x^{2}+0+u_{5}x^{4}+\cdots
\end{aligned}$$
这推导出在级数 $P/Q$ 的展开中第 $N$ 项系数为
$$[x^{N}]\frac{P(x)}{Q(x)}=
\begin{cases}
[x^{\frac{N}{2}}]\frac{U_{e}(x)}{V(x)},&\text{if }N\text{ is even,}\\
[x^{\frac{N-1}{2}}]\frac{U_{o}(x)}{V(x)},&\text{else.}
\end{cases}$$
换言之我们将计算有理幂级数 $P/Q$ 第 $N$ 项系数的问题减少为计算另一对有理幂级数的第 $\lfloor N/2\rfloor$ 项，需要付出两次度数为 $d$ 的多项式的乘法。

#### MSB-first 算法
在 Fiduccia 算法中，幂级数 $P/Q$ 的展开 $\sum_{n\geq 0}u_{n}x^{n}$ 的第 $N$ 项系数 $u_{N}$ 为内积 $\langle x^{N}\bmod \Gamma(x),v_{0}\rangle$ 。为了计算 $[x^{N}]P(x)/Q(x)$ ，转而计算 $1/Q(x)$ 的第 $N-d+1$ 项到第 $N$ 项，因为 $\deg P\lt d$ ，所以 $[x^{N}]P(x)/Q(x)$ 仅与这几项相关。令 $\mathcal{F}_{N,d}(\sum_{i\geq 0}a_{i}x^{i})=\sum_{i=0}^{d-1}a_{N-d+1+i}x^{i}$ ，我们的目标是计算 $\mathcal{F}_{N,d}(1/Q(x))$ ，我们有下列等式
$$\begin{aligned}
\mathcal{F}_{N,d}\left(\frac{1}{Q(x)}\right)&=\mathcal{F}_{N,d}\left(\frac{Q(-x)}{Q(x)Q(-x)}\right)\\
&=\mathcal{F}_{N,d}\left(Q(-x)x^{N-2d+1}\mathcal{F}_{N,2d}\left(\frac{1}{Q(x)Q(-x)}\right)\right)\\
&=\mathcal{F}_{2d-1,d}\left(Q(-x)\mathcal{F}_{N,2d}\left(\frac{1}{V(x^{2})}\right)\right)
\end{aligned}$$
其中 $V(x^{2}):=Q(x)Q(-x)$ 。

在第二个等式中，我们仅考虑 $1/V(x^{2})$ 的第 $N-2d+1$ 项系数到第 $N$ 项系数。在第三个等式中，我们用事实 $\mathcal{F}_{N,d}(xA(x))=\mathcal{F}_{N-1,d}(A(x))$ 。令 $W(x):=\mathcal{F}_{\lfloor N/2\rfloor ,d}(1/V(x))$ 。然后显然
$$\mathcal{F}_{N,d}\left(\frac{1}{Q(x)}\right)=\mathcal{F}_{2d-1,d}(Q(-x)S(x))$$
其中
$$S(x):=\begin{cases}xW(x^{2}),&\text{if }N\text{ is even,}\\
W(x^{2}),&\text{else.}\end{cases}$$
至此得到算法亦可快速计算 $[x^{N}]P(x)/Q(x)$ 。

#### 实装
在 LSB-first 算法中，应用将 DFT 序列长度翻倍的方法可以减少常数，在 MSB-first 算法中也可应用，但原文未详细说明，我认为可以将输入参数变为 DFT 序列，而输出时运用循环卷积的技巧即可。另外这两种算法也无需直接求逆/模运算，代码量较少。详细的伪代码见原论文。

因为审核建议附上代码，于是写了一下，边界情况可能没有特殊处理，有错误感谢指出，其中函数名尽可能与论文中对应，而 LSB-first 算法因为更容易且常数更小，可自己写出，论文中也有详细的优化方法，下面仅包含了 MSB-first 的方法。[提交记录](https://www.luogu.com.cn/record/42355094) 。

```cpp
#include <bits/stdc++.h>

typedef unsigned int uint;
typedef unsigned long long ull;
typedef std::vector<uint> vui;
uint ROOT[1 << 21], IROOT[1 << 21];                                    // 预处理数组
const uint P = 998244353, PR = 3;                                      // ntt 模数和对应原根
int lim = 0;                                                           // 预处理的可 ntt 长度
uint mul_mod(uint x, uint y) { return ull(x) * y % P; }                // x * y
uint add_mod(uint x, uint y) { return x + y < P ? x + y : x + y - P; } // x + y
uint sub_mod(uint x, uint y) { return int(x - y) < 0 ? x + P - y : x - y; } // x - y
uint pow_mod(uint x, int y) {                                               // x ^ y
  uint res = 1;
  for (; y; y >>= 1, x = mul_mod(x, x))
    if (y & 1) res = mul_mod(res, x);
  return res;
}
uint inv_mod(uint x) { return pow_mod(x, P - 2); } // x ^ {-1}
uint get_len(uint n) {                             // 获取 2^{ceil(log_2(n))}
  return --n, n |= n >> 1, n |= n >> 2, n |= n >> 4, n |= n >> 8, n |= n >> 16, ++n;
}
void init(int n) { // n 为 2 的幂次
  if (lim < n) {
    int l = n >> 1;
    uint g = pow_mod(PR, (P - 1) / n), ig = pow_mod(PR, P - 1 - (P - 1) / n);
    ROOT[l] = IROOT[l] = 1;
    for (int i = l + 1; i < n; ++i)
      ROOT[i] = mul_mod(ROOT[i - 1], g), IROOT[i] = mul_mod(IROOT[i - 1], ig);
    for (int i = l - 1; i >= lim; --i) ROOT[i] = ROOT[i << 1], IROOT[i] = IROOT[i << 1];
    lim = n;
  }
}
void dft(int n, uint x[]) { // 输入为正常顺序，返回的序列为“位逆序置换”之后的顺序
  init(n);
  for (int i = n; i >= 2; i >>= 1)
    for (int j = 0, l = i >> 1; j != n; j += i)
      for (int k = 0; k != l; ++k) {
        uint u = x[j + k], v = x[j + k + l];
        x[j + k] = add_mod(u, v), x[j + k + l] = mul_mod(sub_mod(u, v), ROOT[l + k]);
      }
}
void idft(int n, uint x[]) { // 输入为“位逆序置换”之后的顺序，返回的正常顺序
  init(n);
  for (int i = 2; i <= n; i <<= 1)
    for (int j = 0, l = i >> 1; j != n; j += i)
      for (int k = 0; k != l; ++k) {
        uint u = x[j + k], v = mul_mod(x[j + k + l], IROOT[l + k]);
        x[j + k] = add_mod(u, v), x[j + k + l] = sub_mod(u, v);
      }
  uint in = inv_mod(n);
  for (int i = 0; i != n; ++i) x[i] = mul_mod(x[i], in);
}
void dft_doubling(int n, uint x[]) { // n 为 2 的幂次，且数组空间容量足够
  std::copy_n(x, n, x + n);
  idft(n, x + n);
  uint k = 1, t = pow_mod(PR, (P - 1) / (n << 1));
  for (int i = 0; i != n; ++i) x[n + i] = mul_mod(x[n + i], k), k = mul_mod(k, t);
  dft(n, x + n);
}
void even_dft(int n, uint x[]) { // 辅助函数
  uint IT = inv_mod(2);
  for (int i = 0, j = 0; i != n; i += 2, ++j) x[j] = mul_mod(IT, (add_mod(x[i], x[i + 1])));
}
vui slice_coeff_helper(vui &q, ull n, int d, int len) { // 内层递归函数，用于优化常数
  static uint s[1 << 20];                               // 临时数组
  if (n == 0) {
    vui res(d, 0);
    uint q0 = 0;
    for (int i = 0; i != len; ++i) q0 = add_mod(q0, q[i]);
    res.back() = mul_mod(len, inv_mod(q0));
    return res; // x^{d-1} / q0
  }
  dft_doubling(len, q.data());
  vui a(len << 1);
  for (int i = 0; i != len << 1; ++i) a[i] = mul_mod(q[i], q[i ^ 1]);
  even_dft(len << 1, a.data());
  vui w = slice_coeff_helper(a, n >> 1, d, len);
  std::fill_n(s, len << 1, 0);
  for (int i = (n & 1) ^ 1, j = 0; j != d; ++j, i += 2) s[i] = w[j];
  dft(len << 1, s);
  for (int i = 0; i != len << 1; ++i) s[i] = mul_mod(s[i], q[i ^ 1]);
  idft(len << 1, s);
  return vui(s + d, s + (d << 1));
}
vui slice_coeff(vui q, ull n) { // 返回 1/q 展开的第 n-d+1 项至第 n 项
  int d = q.size() - 1, len = get_len(d + 1);
  q.resize(len << 1);
  dft(len, q.data());
  return slice_coeff_helper(q, n, d, len);
}
uint one_coeffT(const vui &p, const vui &q, ull n) { // 返回 [x^n]p/q
  // 这里设 q 的度数为 d ，那么 p 的度数小于 d
  vui iq = slice_coeff(q, n);
  uint res = 0;
  for (int i = 0, e = iq.size() - 1; i <= e; ++i) res = add_mod(res, mul_mod(p[i], iq[e - i]));
  return res;
}
uint norm(int v) { return (v % int(P) + P) % P; }
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  static uint a[1 << 21], b[1 << 21], c[1 << 21];
  int n, k;
  std::cin >> n >> k;
  a[0] = c[0] = 1;
  // 多项式 q 放在数组 a 中
  for (int i = 1, v; i <= k; ++i) { std::cin >> v; a[i] = c[i] = sub_mod(0, norm(v)); }
  for (int i = 0, v; i != k; ++i) { std::cin >> v; b[i] = norm(v); }
  int len = get_len(k << 1);
  dft(len, c), dft(len, b);
  for (int i = 0; i != len; ++i) b[i] = mul_mod(b[i], c[i]);
  idft(len ,b);
  std::cout << one_coeffT(vui(b, b + k), vui(a, a + k + 1), n);
  return 0;
}
```


---

## 作者：Potassium (赞：16)

介绍一个常数小还好写的科技：[bostan-mori 算法](https://arxiv.org/pdf/2008.08822.pdf)。

[博客园](https://www.cnblogs.com/Potassium/p/15130342.html) [github 博客](https://potassiumwings.github.io/2021/08/11/from_n_th_element_in_fraction_to_linear_recurrence_array/)

不需要任何矩阵知识，前置知识：多项式乘法


应用场景：**需要注意这一个算法要求模数是质数。**



# 波斯坦-茉莉算法简介

这个东西是求分式第 $n$ 项，即 $[x^n]\frac {f(x)}{g(x)}$ ，而我们知道**分式第 n 项和线性递推式可以很容易地互化的**（后文会细说）。于是我们先看如何利用波斯坦-茉莉算法求解分式第 $n$ 项。

$\begin{aligned}&[x^n]\frac{f(x)}{g(x)}\\=&[x^n]\frac{f(x)g(-x)}{g(x)g(-x)}\\=&[x^n]\frac{c_{even}(x^2)+x\cdot c_{odd}(x^2)}{v(x^2)}\\=&[x^{n/2}]\frac{c_{even}(x)}{v(x)},n\text{ is even}\\&[x^{n/2}]\frac{c_{odd}(x)}{v(x)},n\text{ is odd} \end{aligned}$

$n=0$ 时，显有 $[x^0]\frac fg=\frac{f_0}{g_0}$。

然后就可以 $\mathcal{O}(k\log k\log n)$ 求出解。

示例代码如下：

```c++
int divAt(Poly F,Poly G, ll k){
	int i;
	for(;k;k>>=1){
		Poly R=G;
		// R=G(-x)
		for(i=1;i<R.size();i+=2)R[i]=mod-R[i];
		F*=R,G*=R;
		for(i=k&1;i<F.size();i+=2)F[i/2]=F[i];
		F.resize(i/2);
		for(i=0;i<G.size();i+=2)G[i/2]=G[i];
		G.resize(i/2);
	}
	return F.empty()?0:F[0]*qpow(G[0],mod-2)%mod;
}
```


好，回到线性递推。

# 从线性递推到分式第 n 项

**如果你会两者之间的转换，可以直接跳到第三节。**

我们求分式第 $n$ 项可以化作线性递推后求解：

设 $\frac{f(x)}{g(x)}=h(x)$，其中 $deg(f)=m,deg(g)=k$，则 $f=g\ast h$。

根据多项式乘法，项数 $i$ 很大的时候 $f_i=0$， $h$ 就是一个递推系数为 $-\frac{g_{1\cdots k}}{g_0}$ 的线性递推式：

$0=f_i=g_0h_i+g_1h_{i-1}+\cdots+g_{k}h_{i-k}$

$h_i=\sum_{j=1}^{k}\frac{-g_j}{g_0}h_{i-j}$

而 $h$ 的前 $0\cdots m$ 项可以容易地通过 $f\ast g^{-1}(\bmod x^k)$ 得出，于是可以求解。

$m>k$ 的时候可以用 $\frac fg$ 余数进行计算；$m=k$ 的时候求出的是 $h_0\cdots h_k$，移一位即可获得答案。

参考实现如下（其中 `get_an(F,A,n,k)` 为与本题相同的含义）：

```c++
int div_at(Poly F,Poly G,ll n){
	int m=F.size(),k=G.size();
	if(m>k){
		Poly P=F/G,R=F-P*G;
		return div_at(R,G,n)+P.at(n);
	}
	Poly h=poly.inv(G,k)*F;
	if(m==k){
		for(int i=0;i<k&&i+1<h.size();i++)
        	h[i]=h[i+1];
		n--;
	}
	h.cut(k-1); // 就是 h %= x^{k-1}
	int invg0=qpow(G[0],mod-2);
	G*=-invg0;
	return get_an(G,h,m,n-1);
} 
```

# 从分式第 n 项到线性递推

我们有一个以 $F_{1\cdots k}$ 为递推系数的线性递推序列 $h$，想要构造 $f,g$ 使得 $[x^n]\frac fg=h_n$

首先，根据多项式乘法，构造项数 $i$ 特别大的时候（$f_i=0$）的递推关系。套用上面的式子：

$h_ig_0=\sum_{j=1}^{k}{-g_j}h_{i-j}$


令 $g_0=0,g_i=F_i(i\in[1,k])$即可。

又：$f=gh(\bmod x^k)$

所以可以求出 $f$ 的 $[0,k-1]$ 项。


参考实现：

```c++
int getAn(Poly F,Poly A,ll n,int k){
	F=Poly{1}-F;
	Poly f=A*F;
	f.cut(k); // 就是 h %= x^k
	return divAt(f,F,n);
} 
```

其中 `divAt` 套用波斯坦-茉莉算法即可，非常的方便。


# 代码

```c++
namespace POLY{
	int divAt(Poly F,Poly G, ll k){
		int i;
		for(;k;k>>=1){
			Poly R=G;
			// R=G(-x)
			for(i=1;i<R.size();i+=2)R[i]=mod-R[i];
			F*=R,G*=R;
			for(i=k&1;i<F.size();i+=2)F[i/2]=F[i];
			F.resize(i/2);
			for(i=0;i<G.size();i+=2)G[i/2]=G[i];
			G.resize(i/2);
		}
		return F.empty()?0:F[0]*qpow(G[0],mod-2)%mod;
	}
	int getAn(Poly F,Poly A,ll n,int k){
		F=Poly{1}-F;
		Poly f=A*F;f.cut(k);
		return divAt(f,F,n);
	} 
}
int main(){
	int i,x,n,k;
	scanf("%d%d",&n,&k);
	Poly F(k+1),A(k);
	F[0]=0;
	for(i=1;i<=k;i++){
		scanf("%d",&x);
		F[i]=(x+mod)%mod;
	}
	for(i=0;i<k;i++){
		scanf("%d",&x);
		A[i]=(x+mod)%mod;
	}
	printf("%d\n",POLY::getAn(F,A,n,k));
	return 0;
}

```

[完整代码](https://www.luogu.com.cn/record/55601927)就是封装了一些多项式乘除法，就不贴了，不会多项式的大常数选手写的很垃圾


---

## 作者：masterhuang (赞：11)

这是一篇为数不多用 **LSB-first** 算法的题解，个人认为是全谷讲这个最详细的。

算法优势：好写，只用到了 $\text{NTT}$ 这一个板子。而且速度比其他算法快（一般情况下）。

## 前置知识-- Bostan-mori 算法

我们有一个生成函数 $H(x)=\dfrac{F(x)}{G(x)}$ 。其中 $\deg(F),\deg(G)\le k\le32000$。要求其第 $n\le10^9$ 项。即求 $[x^n]\dfrac{F(x)}{G(x)}$
。

推柿子：$[x^n]\dfrac{F(x)}{G(x)}=[x^n]\dfrac{F(x)G(-x)}{G(x)G(-x)}=[x^n]\dfrac{F_0(x^2)+xF_1(x^2)}{G_0(x^2)}=\begin{cases}[x^{n/2}]\dfrac{F_0(x)}{G_0(x)}(2\mid n)\\\\ [x^{n/2}]\dfrac{F_1(x)}{G_0(x)}(2\nmid n)\end{cases}$

又 $[x^0]\dfrac{F(x)}{G(x)}=\dfrac{[x^0]F(x)}{[x^0]G(x)}$。于是就可以求啦！

有一个细节：就是 $G(-x)$ 要和两个多项式分别做卷积，于是要开两个数组（下面的 $c,d$ 数组）分别和两个做卷积，不能只用一个数组分别和两个做卷积。

代码：
```cpp
inline int genf(int *a,int *b,int n,int m,int k)
{
	static int c[N],d[N];
	for(;k;k>>=1)
	{
		memset(c,0,sizeof(c));for(int i=0;i<=m;i++) c[i]=b[i];
		for(int i=1;i<=m;i+=2) c[i]=(mod-c[i])%mod;
		memset(d,0,sizeof(d));for(int i=0;i<=m;i++) d[i]=c[i];
		NTT(a,c,n,m);NTT(b,d,m,m);int j=0;
		for(int i=(k&1);i<=n+m;i+=2,j++) a[i/2]=a[i];n=j-1;j=0;
		for(int i=0;i<=2*m;i+=2,j++) b[i/2]=b[i];m=j-1;
		for(int i=n+1;i<=N-5;i++) a[i]=0;
		for(int i=m+1;i<=N-5;i++) b[i]=0;
	}
	return 1ll*a[0]*ksm(b[0],mod-2)%mod;
}
```
## LSB-first 算法

其实内核不难发现。只是名字高端一点。

已知：$a_{0,1,...,k-1},f_{1,2,...,k-1},a_n=\sum\limits_{i=1}^{k}f_i \times a_{n-i}$。要求 $a$ 的生成函数。

![](https://cdn.luogu.com.cn/upload/image_hosting/ofi00wud.png)

可以得出 $a=a\times\sum\limits_{i=1}^k f_ix^i +t(x)(\deg(t)\le k-1)$。其中 $a$ 是原来的数列，$t(x)=\sum\limits_{i=0}^{k-1}a_ix^i-\sum\limits_{i=0}^{k-2}a_i\sum\limits_{j=1}^{k-1-i}f_jx^{i+j}$。是一个幂次小于 $k-1$ 的一个多项式（很难求，于是我们不需要知道它是多少）。

于是 $a=\dfrac{t(x)}{T(x)}(T(x)=1-\sum\limits_{i=1}^k f_ix^i)$。

由于我们知道 $a$ 的前 $k-1$ 项 , $T(x)$ 又有足足 $k$ 次，于是 $t(x)$ 的前 $k-1$ 项可以通过 $A\times T$ 做一个卷积（其中 $A$ 为 $a$ 的前 $k$ 项构成的多项式）模 $x^k$ 唯一确定。

最后套用 Bostan-mori 算法计算这个生成函数的第 $n$ 项即可，复杂度 $O(k\log k\log n)$。

代码：
```cpp
//落谷 P4723
//https://www.luogu.com.cn/problem/P4723
#include<bits/stdc++.h>
#define LL long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
const int mod=998244353,N=4e5+5;
int n,k,a[N],b[N],f[N],w[N],mmax;
inline int rd()
{
    int x=0,zf=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') (ch=='-')and(zf=-1),ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*zf;
}
inline void wr(int x)
{
    if(x==0) return putchar('0'),putchar(' '),void();
    int num[35],len=0;
    while(x) num[++len]=x%10,x/=10;
    for(int i=len;i>=1;i--) putchar(num[i]+'0');
    putchar(' ');
}
inline int bger(int x){return x|=x>>1,x|=x>>2,x|=x>>4,x|=x>>8,x|=x>>16,x+1;}
inline int md(int x){return x>=mod?x-mod:x;}
inline int ksm(int x,int p){int s=1;for(;p;(p&1)&&(s=1ll*s*x%mod),x=1ll*x*x%mod,p>>=1);return s;}
inline void init(int mmax)
{
	for(int i=1,j,k;i<mmax;i<<=1)
		for(w[j=i]=1,k=ksm(3,(mod-1)/(i<<1)),j++;j<(i<<1);j++)
			w[j]=1ll*w[j-1]*k%mod;
}
inline void DNT(int *a,int mmax)
{
	for(int i,j,k=mmax>>1,L,*W,*x,*y,z;k;k>>=1)
		for(L=k<<1,i=0;i<mmax;i+=L)
			for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
				*y=1ll*(*x+mod-(z=*y))* *W%mod,*x=md(*x+z);
}
inline void IDNT(int *a,int mmax)
{
	for(int i,j,k=1,L,*W,*x,*y,z;k<mmax;k<<=1)
		for(L=k<<1,i=0;i<mmax;i+=L)
			for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
				z=1ll* *W* *y%mod,*y=md(*x+mod-z),*x=md(*x+z);
	reverse(a+1,a+mmax);
	for(int inv=ksm(mmax,mod-2),i=0;i<mmax;i++) a[i]=1ll*a[i]*inv%mod;
}
inline void NTT(int *a,int *b,int n,int m)
{
	mmax=bger(n+m);init(mmax);
	DNT(a,mmax);DNT(b,mmax);
	for(int i=0;i<mmax;i++) a[i]=1ll*a[i]*b[i]%mod;
	IDNT(a,mmax);
}
inline int genf(int *a,int *b,int n,int m,int k)
{
	static int c[N],d[N];
	for(;k;k>>=1)
	{
		memset(c,0,sizeof(c));for(int i=0;i<=m;i++) c[i]=b[i];
		for(int i=1;i<=m;i+=2) c[i]=md(mod-c[i]);
		memset(d,0,sizeof(d));for(int i=0;i<=m;i++) d[i]=c[i];
		NTT(a,c,n,m);NTT(b,d,m,m);int j=0;
		for(int i=(k&1);i<=n+m;i+=2,j++) a[i/2]=a[i];n=j-1;j=0;
		for(int i=0;i<=2*m;i+=2,j++) b[i/2]=b[i];m=j-1;
		for(int i=n+1;i<=N-5;i++) a[i]=0;
		for(int i=m+1;i<=N-5;i++) b[i]=0;
	}
	return 1ll*a[0]*ksm(b[0],mod-2)%mod;
}
inline int rec(int *f,int *a,int n,int k)
{
	for(int i=1;i<=k;i++) f[i]=md(mod-f[i]);f[0]=1;
	static int c[N];memset(c,0,sizeof(c));
	for(int i=0;i<=k;i++) c[i]=f[i];
	NTT(c,a,k,k);for(int i=k;i<=N-5;i++) c[i]=0;
	return genf(c,f,k,k,n);
}
int main()
{
	n=rd();k=rd();
	for(int i=1;i<=k;i++) f[i]=md(rd()%mod+mod);
	for(int i=0;i<k;i++) a[i]=md(rd()%mod+mod);
	wr(rec(f,a,n,k));
	return 0;
}
```

---

## 作者：Petit_Souris (赞：10)

文化课期末考不是很愿意想题，于是来搓点科技。进场之前想着学个 BM，看了一眼 hint 上下同乘一个 $Q(-x)$，然后地理编完之后花了半小时编出来了，啪的一下很快啊。

- **问题**：求解 $[x^k]\frac{P(x)}{Q(x)}$。其中 $P,Q$ 均为不超过 $n$ 次的多项式，$k$ 很大。

给上下同乘一个 $Q(-x)$，变成 $[x^k]\frac{P(x)Q(-x)}{Q(x)Q(-x)}$。显然分母的奇数项都会抵消变成 $0$，这样看起来就能把问题折半了。

对 $k$ 的奇偶性分类讨论，对于分子，我们只关心与 $k$ 同奇偶的那些项。对于 $k$ 为偶数，可以得到一个 $\frac{F(x^2)}{G(x^2)}$，对于 $k$ 为奇数，可以得到一个 $\frac{xF(x^2)}{G(x^2)}$。这里 $F,G$ 只需要计算 $P(x)Q(-x)$ 和 $Q(x)Q(-x)$ 就能得到。然后就能折半到 $[x^{\lfloor\frac{k}{2}\rfloor}]\frac{F(x)}{G(x)}$ 的问题上了。继续递归即可，时间复杂度 $\mathcal O(n\log n\log k)$。

- **常系数齐次线性递推**：有了 Bostan-Mori 算法，我们只要构造出合理的 $P,Q$ 即可。分式远处求值和线性递推是可以互相转化的。

现在要构造 $P,Q$ 使得 $[x^n]\frac{P(x)}{Q(x)}=a_n$。由于 $P,Q$ 都得是有限次多项式，我们可以取一个 $>\deg P$ 的次数，此时 $P$ 对应系数为 $0$，再带入求解：

$$
\sum\limits_{i=0}^{n}a_iq_{n-i}=0
$$

把 $a_nq_0$ 移过去除掉，得到：

$$
a_n=-\sum\limits_{i=0}^{n-1}\frac{q_{n-i}}{q_0}a_i
$$

那么 $Q$ 就很容易取了：构造 $q_0=1$，$q_i=-f_i(i\ge 1)$ 即可。若记 $a_0,\dots,a_{n-1}$ 对应的多项式为 $A$，$P$ 就是 $Q\cdot A \bmod x^{k}$。于是 $P,Q$ 可以在 $\mathcal O(k\log k)$ 的时间复杂度内求出，再使用 Bostan-Mori 方法即可做到 $\mathcal O(k\log k\log n)$。


当然有一种用特征多项式 + 多项式取模的经典做法可以做到相同复杂度，但是常数相对大很多（一轮只要两次卷积的优越性）。

```cpp
ll Bostan_Mori(poly P,poly Q,ll n){// [x^n]P(x)/Q(x) 
    while(n){
        poly _Q=Q;
        for(int i=1;i<(int)Q.size();i+=2)_Q[i]=Mod-Q[i];
        P=P*_Q,Q=Q*_Q;
        int i=(n&1);
        for(;i<(int)P.size();i+=2)P[i>>1]=P[i];
        P.resize(i>>1);
        for(i=0;i<(int)Q.size();i+=2)Q[i>>1]=Q[i];
        Q.resize(i>>1),n>>=1;
    }
    if(!P.size())return 0;
    return 1ll*P[0]*pw(Q[0],Mod-2)%Mod;
}
ll Recur(ll *f,ll *a,ll T,ll n){
    poly Q;Q.resize(n+1),Q[0]=1;
    rep(i,1,n)Q[i]=Mod-f[i];
    poly R;R.resize(n);
    rep(i,0,n-1)R[i]=a[i];
    poly P=Q*R;P.resize(n);
    return Bostan_Mori(P,Q,T);
}
```

---

## 作者：Mihari (赞：10)

同步发表与[本蒟蒻的博客](https://www.cnblogs.com/MachineryCountry/p/12146018.html)

# 前置知识

## 矩阵的运算

### 矩阵加法

只有当两个行数、列数分别相等的矩阵（同型矩阵）相加，加法运算才有意义。

下面举例说明：
$$
\left[\begin{array}{ll}
{1} & {2} \\
{3} & {4}
\end{array}\right]+\left[\begin{array}{ll}
{1} & {3} \\
{2} & {4}
\end{array}\right]=\left[\begin{array}{ll}
{2} & {5} \\
{5} & {8}
\end{array}\right]
$$
可以理解为相同的位置加起来，就变成了答案矩阵。

其中，加法满足这些特点：

- 交换律：$A+B=B+A$
- 结合律：$(A+B)+C=A+(B+C)$

### 矩阵乘法

#### 与数的乘法

所有矩阵中的数全部乘以这个数即为结果，举例：
$$
\left[\begin{array}{ccc}
{1} & {-1} & {3} \\
{2} & {6} & {-5}
\end{array}\right] \times 4=\left[\begin{array}{ccc}
{4} & {-4} & {12} \\
{8} & {24} & {-20}
\end{array}\right]
$$
满足特性：

- 结合律：$(ab)A=a(bA),(a+b)A=aA+bA$
- 分配律：$a(A+B)=aA+aB$

#### 与矩阵的乘法

先上例子：
$$
\left[\begin{array}{lll}
{1} & {2} & {3} \\
{4} & {5} & {6}
\end{array}\right] \times\left[\begin{array}{cc}
{10} & {5} \\
{8} & {2} \\
{15} & {3}
\end{array}\right]=\left[\begin{array}{cc}
{71} & {18} \\
{170} & {48}
\end{array}\right]
$$
即，设 $A=(a_{ij})_{m\times s},B=(b_{ij})_{s\times n}$ ，那么 $A\times B=C$ 中，$C=(c_{ij})_{m\times n}$ 。

**必须保证 $A$ 的列与 $B$ 的行相同，且不满足交换律。**

但满足结合律

## 向量的特殊说明

这里我们使用的向量是 $k$ 阶向量，不与一般的向量相同。

即这个向量有 $k$ 个元素。

# 问题引入

> 给出一个数列 $h$ 若满足满足
> 
> $$
> h_i=\sum_{j=1}^kh_{i-j}a_j
> $$
> 
> 那么我们称其满足 $k$ 阶齐次线性递推关系。

对于 $h$ 的前 $k$ 个元素由题目给定。

现要求 $h_n$ 的值？

[原问题:Shlw loves matrixI](https://www.lydsy.com/JudgeOnline/problem.php?id=4161)

> 如果 $\text{BZOJ}$ 炸了，请看下面 ~~BZOJ 太老了...~~
>
> 问题与上面一样，

# 一般方法

对于这样的问题，我们可以有一些比较简单的想法。

## 暴力递推

如果我们直接使用暴力将式子推到第 $n$ 项，其时间复杂度大概是 $\mathcal O(nk)$ 。

## 矩阵快速幂

对于这样的一个题，我们可以很巧妙地构造初始矩阵：
$$
A=
\begin{bmatrix}
h_1&h_2&h_3&\ldots&h_{k-1}&h_k
\end{bmatrix}
$$
而加速矩阵即为
$$
B=
\begin{bmatrix}
0&0&\cdots&0&a_1 \\
1&0&\cdots&0&a_2 \\
0&1&\cdots&\vdots&a_3 \\
\vdots&\vdots&\ddots&0&\vdots \\
0&0&0&1&a_k
\end{bmatrix}
$$
即 $B$ 的左上——右下对角线往下移一个单位，其上面全部都是 $1$ ，最后一列顺次从上往下为 $a_1,a_2,a_3,\ldots a_k$ 。

那么，时间复杂度大概为 $\mathcal O(k^3\log n)$ ，其中 $\mathcal O(k^3)$ 为矩阵乘法的时间复杂度，而 $\mathcal O(\log n)$ 是快速幂的时间复杂度。

# 对于矩阵快速幂的一些优化

对于我们之前的那些方法，方法一似乎较难优化，因而我们从矩阵快速幂的优化入手，想办法降低其复杂度 $\mathcal O(k^3\log n)$ 。

## 特征值与特征向量

我们知道一个矩阵乘一个**列向量**仍然是一个列向量。

若对于 $k$ 阶矩阵 $A$ ，有常数 $\lambda$ 与列向量 $\overrightarrow v$ 满足
$$
A\overrightarrow v=\lambda \overrightarrow v
$$
那么我们称 $\lambda$ 为特征值， $\overrightarrow v$ 为特征向量。

## 优化内容

由**特征值与特征向量**的定义，我们可以得到上面的那个等式，即
$$
A\overrightarrow v=\lambda \overrightarrow v
$$
令我们的 $\overrightarrow v$ 为初始矩阵，而 $A$ 为加速矩阵，而现在我们要找 $\lambda$ 的值。

考虑将其展开，可得
$$
\begin{bmatrix}
a_1&a_2&a_3&\cdots&a_k \\
0&0&0&\cdots&1 \\
0&0&\cdots&1&0 \\
&&\vdots \\
0&1&0&\ldots&0
\end{bmatrix}
\times 
\begin{bmatrix}
h_k \\
h_{k-1} \\
h_{k-2} \\
\vdots \\
h_1
\end{bmatrix}
=
\begin{bmatrix}
h_{k+1} \\
h_{k} \\
h_{k} \\
\vdots \\
h_2
\end{bmatrix}
=\lambda\overrightarrow v
=
\begin{bmatrix}
\lambda h_{k} \\
\lambda h_{k-1} \\
\lambda h_{k-2} \\
\vdots \\
\lambda h_1
\end{bmatrix}
$$
注意到上面的式子中的第三个矩阵和第四个矩阵的等量关系，发现
$$
h_i=\lambda h_{i-1}=\lambda^2h_{i-2}=\lambda^3h_{i-3}=\cdots=\lambda^{i-1}h_1
$$
而根据定义，我们又有
$$
h_{k+1}=a_1h_k+a_2h_{k-1}+\cdots+a_kh_1
$$
将所有的 $h_i$ 全部换成 $h_1$ ，可以得到
$$
\lambda^kh_1=a_1\lambda^{k-1}h_1+a_2\lambda^{k-2}h_1+\cdots+a_k\lambda^0h_1
$$
那么，我们可以将 $h_1$ 全部消掉，得到一个关于 $\lambda^k$ 的等式，即
$$
\lambda^k=a_1\lambda^{k-1}+a_2\lambda^{k-2}+\cdots +a_k
$$
移项，可得
$$
\lambda^k-a_1\lambda^{k-1}-a_2\lambda^{k-2}-\cdots -a_k=0
$$
考虑将 $\lambda$ 换成关于 $x$ 的方程，得原式为
$$
x^k-a_1x^{k-1}-a_2x^{k-2}-\cdots-a_k=0
$$
我们令 $f(x)=x^k-a_1x^{k-1}-a_2x^{k-2}-\cdots-a_k$ 。

下面有关于多项式操作中的**除法/取模操作**，如果有不会的，请看 [多项式的蛇皮操作](https://www.cnblogs.com/MachineryCountry/p/12083717.html) 。

现在我们求
$$
x^n=f(x)g(x)+r(x)
$$
上式中的 $g(x),r(x)$ ，如果使用多项式的操作，似乎是很好求的，时间复杂度为 $\mathcal O(k\log k)$ 。

但是，我们求这个东西有什么用呢？

**考虑将 $x$ 替换为矩阵 $A$ ，那么有 $f(x)=f(A)=O$ ，其中 $O$ 为 $0$ 矩阵。**

但是为什么 $f(A)=O$ ？

这里，**Hamilton-Cayley定理**说明了这个问题，其内容如下：

对于矩阵 $A$ 的特征多项式 $f(x)$ ，满足 $f(A)=0$ 。

[证明看这里(百度百科)]([https://baike.baidu.com/item/%E5%93%88%E5%AF%86%E9%A1%BF%E4%B8%80%E5%87%AF%E8%8E%B1%E5%AE%9A%E7%90%86/18892795?fr=aladdin](https://baike.baidu.com/item/哈密顿一凯莱定理/18892795?fr=aladdin))

~~说不定哪天我也会给出自己的证明啊...~~

**如果你还是看不懂，就把它当成一个结论记下来。**（作者太菜，只能这样做了）

继续说明，我们有了
$$
A^n=f(A)g(A)+r(A)
$$
因为 $f(A)=O$ ，那么就有
$$
A^n=r(A)
$$
而我们通过**多项式的操作**能够得到 $r(A)$ 的每一个系数的值。

而如果我们直接这样求的话，其时间复杂度为 $\mathcal O(k^4)$ 。

但是我们看看我们要求的是 $A^n\overrightarrow v$ 的每一项，考虑将其等价变换为求 $r(A)\times \overrightarrow v$

而由于 $r(x)$ 的本质是一个多项式，那么它可以写成
$$
r(A)=\sum_{i=0}^{k-1}c_iA^i
$$
其中 $c_i$ 是每一项的系数，那么 $r(A)\overrightarrow v$ 就可以写为
$$
r(A)\overrightarrow v=\sum_{i=0}^{k-1}c_iA^i\overrightarrow v
$$
而 $A^i\overrightarrow v$=$A\times (A^{i-1}\overrightarrow v)$ （满足结合律）

而 $A^{i-1}\overrightarrow v$ 是一个向量，而向量乘一个矩阵时间复杂度是 $\mathcal O(k^2)$ ，因为我们要求 $k$ 个这样的式子，所以时间复杂度为 $\mathcal O(k^3)$ 。

**但是，还可以继续优化。**

由于定义，我们知道 $\overrightarrow v$ 由 $h_1,h_2,h_3\cdots h_{k-1},h_k$ 组成，且顺序已知。

而 $A\times \overrightarrow v$ 由 $h_2,h_3,h_4\cdots h_k,h_{k+1}$ 。

那么，更广泛的推论为

$A^i\times \overrightarrow v$ 由 $h_{i+1},h_{i+2}\cdots h_{i+k}$ 组成。

而我们最多只会求到 $A^{k-1}\overrightarrow v$ ，即我们只会用到前 $2k$ 个 $h$ 中的元素。

考虑将其暴力预处理出来，时间复杂度 $\mathcal O(k^2)$ ，然后我们用 $\mathcal O(k)$ 的时间即可处理出 $A^i\times \overrightarrow v$ ，而我们要计算 $k$ 个这样的多项式，最终时间复杂度为 $\mathcal O(k^2)$ 。

但是时间复杂度真的是 $\mathcal O(k^2)$ 吗？

**不对的。**

问题出在哪里，在于多项式除法的 $x^n$ 取模 $f(x)$ 的时候，这个 $x^n$ 真的可以 $\mathcal O(1)$ 地表示？

呵呵，此问题中 $n\le 10^9$ ，存是存不下的。

所以我们只能倍增计算 $x^n$ ，并且在一边倍增的时候取模 $f(x)$ 即可，所以此处时间复杂度为 $\mathcal O(k\log k\log n)$ 。

因而，总的时间复杂度为 $\mathcal O(max\{k\log k\log n,k^2\})$ 。

## 总结算法步骤

1. 处理出 $f(x)$ ，时间复杂度 $\mathcal O(k)$ ；
2. 用快速幂求出 $r(x)$ ，时间复杂度 $\mathcal O(k\log k\log n)$ ；
3. 预处理前 $2k$ 个 $h$ ，时间复杂度 $\mathcal O(k^2)$ ；
4. 循环从 $1$ 到 $k$ ，每次计算 $c_iA^i\overrightarrow v$ ，用 $\mathcal O(k)$ 的时间填 $A^i\overrightarrow v$ 。总的复杂度 $\mathcal O(k^2)$ ，此刻得到答案向量；
5. 算法结束；

这就是常系数齐次线性递推的主要优化步骤...

嘿嘿嘿，代码没有了...



---

## 作者：zzw4257 (赞：7)

给定递推方程$\displaystyle f_n=\sum_{i=1}^ka_if_{n-i}$与$f_0,f_1,\dots,f_{k-1}$,求$f_n$

考虑一个~~小学生~~算的过程,举个栗子:$\displaystyle f_n=f_{n-1}+f_{n-2}$

则
$$
\begin{aligned}
f_5&=\color{red}{f_4+f_3}\\
&=\color{yellow}{2f_3+f_2}
\\&=\color{green}{3f_2+2f_1}
\\&=\color{blue}{5f_1+3f_0}
\end{aligned}
$$
已知这个递推方程的**特征多项式**$\lambda(f)$为$x^2-x-1$,发现这样累积的过程可以类比为
$$
\begin{aligned}
x^5&=x^3(x^2-x-1)+\color{red}{x^4+x^3}
\\&=x^3(x^2-x-1)+x^2(x^2-x-1)+\color{yellow}{2x^3+x^2}
\\&=x^3(x^2-x-1)+x^2(x^2-x-1)+2x(x^2-x-1)+\color{green}{3x^2+2x}
\\&=x^3(x^2-x-1)+x^2(x^2-x-1)+2x(x^2-x-1)+3(x^2-x-1)+\color{blue}{5x+3}
\end{aligned}
$$
其实是多项式取模的过程

可以证明设$g\equiv x^n\pmod{\lambda(f)}$,则$f_n=\sum\limits_{i=0}^{k-1}g_if_i$

其中$\lambda(f)=x^k-\sum\limits_{i=0}^{k-1}a_ix^i$

---

## 作者：LightningUZ (赞：6)

## 前言

这篇是我睡觉时候想的idea，就是用拓扑排序算次数来理解

然后我发现它好像和 [这篇](https://www.luogu.com.cn/blog/BJpers2/solution-p4723) 的核心思想有点重了

还好重的不是很多，问题不大 

## 常系数齐次线性递推

注：这篇是一个不用很高线性代数基础的理解方法

### 问题描述

$f_0,f_1...f_{k-1}$ 已知，并已知递推系数 $a_1,a_2...a_k$

$f_n=\sum\limits_{i=1}^{k} f_{n-k}a_k$

求 $f_n$

$n\le 1145141919810,k\le 114514$

常规的矩阵快速幂过不去了。我们需要一个带 $\log$ 的做法。

### 换一个思路

我们考虑一下，假设我们现在用 **递归** 的方法暴力算 $f_n$，每个 $f_i$ 被加到了几遍（严谨的说就是系数的和）。然后我们把递归调用的过程建成一个图。比如说 $n$ 要用到 $n-1,n-2...n-k$，我们就从 $n$ 向这些点连一条边。边权是递推系数 $a_i$。

然后我们来考虑点 $n$ 的状态把点 $[0,k-1]$ 算了多少遍。假设我们能求出来“多少遍”，那直接就可以求出 $f_n$ 了：每个 $f_{0...k-1}$，乘以对应的遍数，加起来，就行了。

然后我们考虑用拓扑排序求这个东西。设 $c$ 表示遍数数组。

我们的边界条件是 $n$：一遍，$c_n=1$，因为我们初始时调用了一下 $f_n$。

对于每个当前入度为 $0$ 的点 $u$，遍历它的出边 $v$，设边权为 $w$。那么 `c[v]+=c[u]*w`，显然。

然后这么做一遍就可以得到 $c_{0...k-1}$，与边界条件 $f_{0...k-1}$ 对应的乘起来即可。复杂度 $O(nk)$

然后你会问：艹这nm不就是直接递推么

~~是的~~

但是我们反过来考虑了个寂寞 ... 吗？

### 魔法

考虑 $c$ 的生成函数，设为 $C(x)=\sum\limits_{i=0}^{\infin} x^ic_i$。

一开始我们知道这玩意就是 $x^n$ （在 $n$ 位置有一个 $n$，其余为 $0$）

我们令拓扑排序删边的时候，如果一个点的出度为 $0$ （即出边被删没了），且不是 $[0,k-1]$ 中的点，就把这个点也删除，同时标记它的 $c$ 为 $0$ （这样显然没问题，因为这个点已经不用了）

然后这样显然只会剩下 $c_{0..k-1}$ 有可能有值（其它都是 $0$）

考虑一次拓扑排序做了甚么：假设当前入度为 $0$ 的点是 $u$，那相当于：

- 标记 $c_{u-i}$ 加上 $c_u\times a_i$
- 然后标记 $c_u$ 为 $0$，即 $c_u$ 减去 $c_u$

一共操作了 $k+1$ 个数，并且操作数都是 $c_u$ 的倍数。

在生成函数上考虑，它相当于减去了 $c_u$ 倍的：

$x^u-\sum\limits_{i=1}^{k} x^{u-i}a_i$

这个东西的系数是 $\{1,-a_1,-a_2...-a_k\}$，然后后面都是 $0$ （因为有 $x$ 的若干次方）。把后面的 $0$ 去掉，只保留这 $k+1$ 项系数，构成的多项式被称作这个递推式的 **特征多项式**。设它为 $F$

> 注：如果您有了解过斐波那契的通项是怎么推的，那您应该接触过这个“特征多项式”的定义
>
> 斐波那契的特征多项式为：$x^2-x-1$

然后每次我们就是把 $F$ 和当前 $C$ 的最高位（设为 $u$）对齐，然后减去 $F$ 的 $c_u$ 倍 —— 这是拓扑排序干的事情。

我们发现它的本质就是在求余数

>回想一下小学竖式计算除法的过程，又因为 $F$ 的最高位为 $1$，所以减去 $F$ 的 $c_u$ 倍其实就是在做带余除法求余数

所以，$C=x^n\mod F$

然后我们只要求出 $x^n\mod F$ 的值，就可以知道遍数数组 $c_{0..k-1}$，对应的乘以初始值 $f_{0..k-1}$，就得到了 $f_n$

然后这个 $C$ 怎么算呢？$n$ 老大了

考虑多项式快速幂 —— 不用 $\ln/\exp$，而是普通的倍增快速幂，参考整数的写法，并把“模”的操作改成多项式取模就可以了。这个复杂度是 $O(n\log k\log n)$ 的

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
	#define N   2000006
	#define GG  3
	#define GI  332748118
	#define mod 998244353
	#define int long long
	#define F(i,l,r) for(int i=l;i<=r;++i)
	#define D(i,r,l) for(int i=r;i>=l;--i)
	#define Fs(i,l,r,c) for(int i=l;i<=r;c)
	#define Ds(i,r,l,c) for(int i=r;i>=l;c)
	#define MEM(x,a) memset(x,a,sizeof(x))
	#define FK(x) MEM(x,0)
	#define Tra(i,u) for(int i=G.st(u),v=G.to(i);~i;i=G.nx(i),v=G.to(i))
	#define p_b push_back
	#define sz(a) ((int)a.size())
	#define all(a) a.begin(),a.end()
	#define iter(a,p) (a.begin()+p)
	#define PUT(a,n) F(i,1,n) printf("%d ",a[i]); puts("");
	int I() {char c=getchar(); int x=0; int f=1; while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar(); while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar(); return ((f==1)?x:-x);}
	template <typename T> void Rd(T& arg){arg=I();}
	template <typename T,typename...Types> void Rd(T& arg,Types&...args){arg=I(); Rd(args...);}
	void RA(int *p,int n) {F(i,1,n) *p=I(),++p;}
	
	int qpow(int a,int b,int m=mod) {int r=1; while(b) {if (b&1) r=r*a%m; a=a*a%m,b>>=1;} return r;}
	int pgg[30],pgi[30];
	void init()
	{
		F(i,0,23)
		{
			pgg[i]=qpow(GG,(mod-1)>>i);
			pgi[i]=qpow(GI,(mod-1)>>i);
		}
	}
	#define ad(x,y) ((x)+(y)>mod?(x)+(y)-mod:(x)+(y))
	#define dc(x,y) ((x)-(y)<0?(x)-(y)+mod:(x)-(y))
	namespace poly
	{
		int w[N],r[N];
		void NTT(int f[N],int lim,int type)
		{
			F(i,0,lim-1) if (i<r[i]) swap(f[i],f[r[i]]);
			for(int mid=1,pp=1;mid<lim;mid<<=1,++pp)
			{
				int Wn=(type==1?pgg[pp]:pgi[pp]);
				w[0]=1; F(i,1,mid-1) w[i]=w[i-1]*Wn%mod;
				for(int i=0;i<lim;i+=(mid<<1))
				{
					for(int j=0;j<mid;++j)
					{
						register int y=f[i|mid|j]*w[j]%mod;
						f[i|mid|j]=dc(f[i|j],y);
						f[i|j]=ad(f[i|j],y);
					}
				}
			}
			if (type==-1)
			{
				int ivv=qpow(lim,mod-2);
				F(i,0,lim-1) f[i]=f[i]*ivv%mod;
			}
		}
		#define REV F(i,0,lim-1) r[i]=((r[i>>1]>>1)|((i&1)?len:0));
		int pool[10][N];
		inline void Inv(int f[N],int g[N],int n) // 求逆, pool 0~2
		{
			int *iv=pool[0],*a=pool[1],*b=pool[2];
			F(i,0,4*n) iv[i]=a[i]=b[i]=0;
			iv[0]=qpow(f[0],mod-2);

			int len=1,lim=1;
			for(len=1;len<=(n<<1);len<<=1)
			{
				lim=len<<1;
				
				F(i,0,4*len) a[i]=b[i]=0;
				F(i,0,len-1) a[i]=f[i],b[i]=iv[i];
				REV; 
				NTT(a,lim,1); NTT(b,lim,1);
				F(i,0,lim-1) a[i]=(2*b[i]-a[i]*b[i]%mod*b[i]%mod+mod)%mod;
				NTT(a,lim,-1);
				F(i,0,len-1) iv[i]=a[i];
			}
			F(i,0,n-1) g[i]=iv[i];
			F(i,n,lim-1) g[i]=0;
		}
		inline void mul(int f[N],int g[N],int n,bool flag=1) // *=, pool 3~4
        // flag: 是否对n取膜
        {
            int len=1,lim=1; while(len<=(n<<1)) len=lim,lim<<=1;
            int *a=pool[3],*b=pool[4];
            F(i,0,lim-1) a[i]=b[i]=0;
            F(i,0,n-1) a[i]=f[i],b[i]=g[i];
            REV;
            NTT(a,lim,1); NTT(b,lim,1);
            F(i,0,lim-1) a[i]=a[i]*b[i]%mod; 
            NTT(a,lim,-1);
            F(i,0,2*n-1) f[i]=a[i]; F(i,2*n,lim) f[i]=0;
            if (flag) F(i,n,2*n-1) f[i]=0;
        }
        void Mod(int f1[N],int f2[N],int n,int m,int R[N]) // 多项式取模, pool 5~6
        // 这里只保留了余数, 商开到 pool 里而不是传参数修改了
        {
            int *a=pool[5],*b=pool[6],*Q=pool[7];
            F(i,0,4*n) a[i]=b[i]=0;
            F(i,0,n-1) a[i]=f1[n-1-i]; F(i,n-m+1,n-1) a[i]=0; // a=f1_r%(x^(n-m+1))
            F(i,0,m-1) b[i]=f2[m-1-i]; F(i,n-m+1,m-1) b[i]=0; 
            Inv(b,b,n-m+1);
            mul(a,b,n-m+1);
            F(i,0,n-m) Q[i]=a[n-m-i];

            F(i,0,4*n) a[i]=b[i]=0;
            F(i,0,n-1) a[i]=f1[i];
            F(i,0,m-1) b[i]=f2[i];
            int len=1,lim=1; while(len<=n) len=lim,lim<<=1; 
            REV;
            NTT(b,lim,1); NTT(Q,lim,1);
            F(i,0,lim-1) b[i]=b[i]*Q[i]%mod;
            NTT(b,lim,-1); NTT(Q,lim,-1);
            F(i,0,m-2) R[i]=(a[i]-b[i]%mod+mod)%mod; F(i,m-1,lim-1) R[i]=0;
        }
		void PowMod(int f[N],int p,int g[N],int n,int h[N]) // f^p%g, g有n项, 保存在h
		{
			int *res=pool[8];
			F(i,0,8*n) res[i]=0;
			res[0]=1; // res=1
			while(p)
			{
				if (p&1)
				{
					mul(res,f,n,0); // res*=f
					Mod(res,g,2*n,n,res); // res%=g
				}
				mul(f,f,n,0); // f=f*f
				Mod(f,g,2*n,n,f); // f%=g
				p>>=1;
			}
			F(i,0,n-2) h[i]=res[i]; F(i,n,8*n) h[i]=0;
		}
	}
	int n,k;
	int a[N],t[N];
    void Input()
    {
    	Rd(n,k);
    	F(i,1,k) t[i]=(I()%mod+mod)%mod;
    	F(i,0,k-1) a[i]=(I()%mod+mod)%mod;
    }
    int f[N],g[N],c[N];
    void Sakuya()
    {
    	init();

    	f[1]=1; // 这玩意就是 x
    	F(i,1,k) g[k-i]=(mod-t[i]); g[k]=1; // 特征多项式
    	// f^n%g -> c
    	poly::PowMod(f,n,g,k+1,c);
    	
    	int ans=0;
    	F(i,0,k-1) ans+=a[i]*c[i]%mod;
    	ans%=mod;
    	printf("%lld\n",ans);
    }
    void IsMyWife()
    {
        Input();
        Sakuya();
    }
}
#undef int //long long
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();
    return 0;
}
```

---

## 作者：Jμdge (赞：6)

实在搞不懂这玩意儿（一看到特征值、特征向量就怂了，其实还好），然后去生啃代码，觉得不熟练就写篇题解...

然后对于讲解楼上讲的很详细了，这里主要给出代码解释


板子其实都没什么好说的？

这里的思路其实就是去做一个类似快速幂的操作，然后把乘法改成多项式下的，取模也改成多项式下的


代码的前面一大段其实都是在给取模做预处理...

但是搞不懂的就是 a 数组一开始只要令一次项为 1 就好了。。。有点玄学？


```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define ll long long
using namespace std;
const int mod=998244353;
const int inv3=332748118;
const int M=2e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,k,ans,limit,inv[M<<1]; arr r,st,xs,sg,a,c,res,irg,q,rf;
inline int qpow(int x,int p=mod-2){ int s=1;
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
inline void NTT(int* a,int tp){
	fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(int mid=1;mid<limit;mid<<=1){
		int Gn=qpow(tp?3:inv3,(mod-1)/(mid<<1));
		for(int j=0,x,y;j<limit;j+=mid<<1)
			for(int k=0,g=1;k<mid;++k,g=mul(g,Gn))
				x=a[j+k],y=mul(g,a[j+k+mid]),
				a[j+k]=inc(x,y),a[j+k+mid]=dec(x,y);
	} if(tp) return ; int INV=inv[limit];
	fp(i,0,limit-1) a[i]=mul(a[i],INV);
}
inline void get_rev(int n){ int len=0;
	for(limit=1;limit<n<<1;limit<<=1) ++len;
	for(int i=1;i<limit;++i) r[i]=(r[i>>1]>>1)|((i&1)<<len-1);
}
void poly_inv(int* a,int* b,int n){
	if(n==1) return b[0]=inv[a[0]],void();
	poly_inv(a,b,n+1>>1),get_rev(n);
	for(int i=0;i<n;++i) c[i]=a[i];
	for(int i=n;i<limit;++i) c[i]=0; NTT(b,1),NTT(c,1);
	for(int i=0;i<limit;++i) b[i]=mul(dec(2,mul(c[i],b[i])),b[i]);
	NTT(b,0); for(int i=n;i<limit;++i) b[i]=0;
}
inline void poly_mod(int* a){  //多项式取模，板子？ 
	int mi=k<<1; for(;!a[--mi];);
	if(mi<k) return ;
	fp(i,0,mi) rf[i]=a[i];
	fp(i,mi+1,limit-1) rf[i]=0;
	reverse(rf,rf+1+mi);
	fp(i,mi+1-k,mi) rf[i]=0; NTT(rf,1);
	fp(i,0,limit-1) q[i]=mul(rf[i],irg[i]);  //得到另一个因式多项式（出门左转...） 
	NTT(q,0); fp(i,mi-k+1,limit-1) q[i]=0;
	reverse(q,q+1+mi-k),NTT(q,1);
	fp(i,0,limit-1) q[i]=mul(q[i],sg[i]);
	NTT(q,0); fp(i,0,k-1) a[i]=dec(a[i],q[i]);  //关键这里才求出了余项 
	fp(i,k,mi) a[i]=0;
}
int main(){ n=read(),k=read(),inv[1]=1;
	for(limit=1;limit<k<<1;limit<<=1);
	fp(i,2,limit<<1) inv[i]=mul(inv[mod%i],(mod-mod/i));
	fp(i,1,k) xs[i]=(read()+mod)%mod;
	fp(i,0,k-1) st[i]=(read()+mod)%mod;
	fp(i,1,k) sg[k-i]=mod-xs[i]; sg[k]=1;    // f 系数多项式取反 + 翻转（玄学死记） 
	fp(i,0,k) rf[i]=sg[i];   //就是把多项式除法中的一个因式多项式（ sg ）构造出来了 
	reverse(rf,rf+1+k); poly_inv(rf,irg,limit);  //对于 sg 的 R 函数求逆（就是翻转+求逆） 
	fp(i,0,k) rf[i]=0; get_rev(k<<1);
	NTT(sg,1),NTT(irg,1),a[1]=res[0]=1;   //提前把这两个多项式点值表示（后面也不用 IDFT 了，卡常？） 
	for(;n;n>>=1){  //快速幂的板子？ 就是 相乘的时候是多项式相乘，取模的时候是多项式取模... 
		if(n&1){ NTT(res,1),NTT(a,1);
			fp(i,0,limit-1) res[i]=mul(res[i],a[i]);
			NTT(res,0),NTT(a,0),poly_mod(res);
		} NTT(a,1);
		fp(i,0,limit-1) a[i]=mul(a[i],a[i]);
		NTT(a,0),poly_mod(a);
	}
	fp(i,0,k-1) ans=inc(ans,mul(res[i],st[i])); //乘上一开始的多项式 
	return !printf("%d\n",ans);
}
```







---

## 作者：w33z8kqrqk8zzzx33 (赞：4)

给一个不同和更清晰的思路

考虑一个（理论上存在的）函数 $F(x):\mathbb Z^+_p[[x]]\rightarrow\mathbb Z^+_p$, 满足以下恒等式：

$$F(\sum_{i=0}^\infty c_ix^i)=\sum_{i=0}^\infty c_ia_i$$

这个函数有一些特殊性质：

 1. 加法分配: $F(A+B)=F(A)+F(B)$
 2. 乘法分配: $F(A\sum B_ix^i)=\sum B_iF(Ax^i)$
 3. 对于特征多项式 $\lambda=x^k-\sum f_ix^{k-i}$，$F(\lambda)=0$

结合起来，$F(P)=F(P-T\lambda)=F(P\bmod\lambda)$。  
于是我们用快速幂+多项式取模求 $x^n\bmod\lambda$，带入 $F$ 的定义即可。

代码：

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define fi first
#define se second
#define pb push_back
 
#define ll long long
#define pii pair<int, int>
//#define int ll
const int MOD = 998244353;

#define intsize (sizeof(int))

namespace poly {
	const int MOD = 998244353;
	const int NTTG = 3;
	
	int rev[262160];
	int minv[262160];
	int w[20][2][262160];
	
	int qpow(int b, int e) {
		int re=1;
		while(e){
			if(e&1)re=1ll*re*b%MOD;
			b=1ll*b*b%MOD;e>>=1;
		}
		return re;
	}
	
	void constructrev(int n) {
		for(int i=1, j=0; i < n; i++) {
			int bit=n>>1;
			for(;j&bit;bit>>=1)j^=bit;
			j^=bit; rev[i] = j;
		}
	}

	void constructroot(int n) {
		minv[1] = 1;
		iter(i, 2, n+1)
			minv[i]=1ll*(MOD-MOD/i)*minv[MOD%i]%MOD;
		for(int l=1; (1<<l)<=n; l++)
			rep(inv, 2) {
				int re = inv?qpow(minv[NTTG],(MOD-1)>>l):qpow(NTTG,(MOD-1)>>l);
				w[l][inv][0] = 1;
				rep1(i,(1<<(l-1))-1) w[l][inv][i] = 1ll*w[l][inv][i-1]*re%MOD;
			}
	}
	
	void ntt(int *v, int n, bool inv) {
		rep(i, n) if(i < rev[i]) swap(v[i], v[rev[i]]);
		for(int l=1;(1<<l)<=n;l++)
			for(int i=0;i<n;i+=(1<<l)) {
				int p=i+(1<<(l-1));
				iter(j, i, p) {
					int a=v[j],b=1ll*v[j+(1<<(l-1))]*w[l][inv][j-i]%MOD;
					v[j]=(a+b>=MOD?a+b-MOD:a+b);
					v[j+(1<<(l-1))]=(a<b?a+MOD-b:a-b);
				}
			}
		if(inv) rep(i, n) v[i] = 1ll*v[i]*minv[n]%MOD;
	}
	
	void mult(int *a, int as, int *b, int bs, int *o, bool construct, bool clean = 0, int thr = 10000000) {
		int n = as+bs-1;
		while(n - (n & (-n))) n += (n & (-n));
		if(construct) constructroot(n);
		constructrev(n);
		ntt(a, n, 0); ntt(b, n, 0);
		rep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;
		ntt(o, n, 1);
		iter(i, thr, n) o[i] = 0;
		if(clean) rep(i, n) a[i] = b[i] = 0;
	}

	void cfn(int* a, int as, int *o) {
		static int tmp[262160];
		if(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }
		cfn(a, (as+1)/2, o); int le = 0;
		while((1 << le) < (as << 1)) le++;
		constructrev(1 << le);
		rep(i, as) tmp[i] = a[i];
		iter(i, as, 1<<le) tmp[i] = o[i] = 0;
		ntt(tmp, 1<<le, 0); ntt(o, 1<<le, 0);
		rep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;
		ntt(o, 1<<le, 1);
		iter(i, as, 1<<le) o[i] = 0;
	}

	void init(int n) { constructroot(n); }
	
	void divide(int *a, int as, int *b, int bs, int *q, int *r) {
		if(as < bs) {
			memcpy(r, a, (bs-1) * intsize);
			return;
		}
		static int ar[262160], br[262160], bin[262160];
		int th = as, re = as-bs+1;
		//th = re+1;
		rep(i, as) ar[i] = a[as-1-i];
		rep(i, bs) br[i] = b[bs-1-i];
		cfn(br, re, bin);
		mult(ar, th, bin, re, q, 0, 1, re);
		for(int l = 0, r = re-1; l < r; l++, r--) swap(q[l], q[r]);
		rep(i, re) bin[i] = q[i];
		mult(bin, re, b, bs, r, 0, 1, bs - 1);
		rep(i, bs - 1) r[i] = (MOD + a[i] - r[i]) % MOD;
	}
}

int rem[262160], dg;
int ans[262160];
int A[262160], B[262160], C[262160];
int __bs__[262160], __as__[262160];

void calc(int n) {
	if(n + 1 < dg) {
		ans[n] = 1;
		return;
	}
	calc(n/2);
	int sz = dg - 1 + dg - 1 + (n % 2) - 1;
	memcpy(A, ans, (dg - 1) * intsize);
	memcpy(B + (n % 2), ans, (dg - 1) * intsize);
	poly::mult(A, dg-1, B, dg-1+(n%2), C, 0, 1);
	memcpy(__as__, rem, dg * intsize);
	poly::divide(C, sz, __as__, dg, __bs__, ans);
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n, k; cin >> n >> k;
	int h = 1; while(h < (k << 2)) h <<= 1;
	poly::init(h);
	rem[k] = 1; dg = k+1;
	rep1(i, k) {
		int p; cin >> p; p = -p;
		p = ((p + MOD) % MOD + MOD) % MOD;
		rem[k-i] = p;
	}
	calc(n);
	int re = 0;
	rep(i, k) {
		int p; cin >> p;
		p = ((p + MOD) % MOD + MOD) % MOD;
		re = (re + 1ll * p * ans[i]) % MOD;
	}
	cout << re << endl;
}
```

---

## 作者：Gauss0320 (赞：2)

## 问题描述

给定常系数线性齐次递推关系
$$f_n=\sum_{i=1}^ka_if_{n-i},n\ge k$$
以及初始值
$$f_0=b_0,\cdots,f_{k-1}=b_{k-1}$$
求$f_n$

## 题解

根据递推关系，构造转移矩阵
$$A=\begin{pmatrix}0&1&0&\cdots&0\\0&0&1&\cdots&0\\\vdots&\vdots&\vdots&\ddots&\vdots\\0&0&0&\cdots&1\\a_k&a_{k-1}&a_{k-2}&\cdots&a_1\end{pmatrix}$$
设列向量${\bm F}=\begin{pmatrix}b_0&b_1&\cdots&b_{k-1}\end{pmatrix}^{\text{T}}$.

答案即为$(A^n{\bm F})_0$，矩阵快速幂可以做到$\mathcal O(k^3\log n)$.

接下来，考虑矩阵$A$的特征多项式
$$\det(\lambda I-A)=\begin{vmatrix}\lambda&-1&0&\cdots&0\\0&\lambda&-1&\cdots&0\\\vdots&\vdots&\vdots&\ddots&\vdots\\0&0&0&\cdots&-1\\-a_k&-a_{k-1}&-a_{k-2}&\cdots&\lambda-a_1\end{vmatrix}=\lambda^k-a_1\lambda^{k-1}-\cdots-a_k$$
记$f(x)=x^k-a_1x^{k-1}-\cdots-a_k$，根据Cayley-Hamilton定理，有$f(A)=0$.

设多项式$x^n$对$f(x)$**取模**的结果为$r(x)$，易知$A^n=r(A)$.

考虑到$r(x)$是关于$x$的$k-1$次多项式，故设$[x^i]r(x)=c_i,i=0,\cdots,k-1$，那么有
$$A^n=c_0+c_1A+\cdots+c_{k-1}A^{k-1}$$
$$\begin{aligned}(A^n{\bm F})_0&=(c_0{\bm F}+c_1A{\bm F}+\cdots+c_{k-1}A_{k-1}{\bm F})_0\\&=c_0{\bm F}_0+c_1(A{\bm F})_0+\cdots+(A^{k-1}{\bm F})_0\\&=c_0b_0+c_1b_1+\cdots+c_{k-1}b_{k-1}\end{aligned}$$
多项式取模的部分可以快速幂以确保多项式的长度在$k$以内，时间复杂度$\mathcal O(k\log k\log n)$.

## 一些优化

因为多项式取模的常数实在太大，所以我第一遍交的时候TLE了.

参考了同机房某位同学的代码，发现了一个小优化，即多项式取模的时候，每次的除数都是一样的($f(x)$)，所以$f(x)$系数翻转后的逆可以只算一遍.

代码

```cpp
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 32000;
const int mod = 998244353;
int rev[N << 2 | 1], n, k, ans, a[N + 1], f[N + 1];;

int pow(int a, int b)
{
	int ret = 1;
	for(; b; b >>= 1, a = 1ll * a * 1ll * a % mod)
		if(b & 1) ret = 1ll * ret * 1ll * a % mod;
	return ret;
}
struct poly
{
	vector<int> a;
	poly(int x = 0)
	{
		if(x) a.push_back(x);
	}
	int size()
	{
		return a.size();
	}
	void resize(int len)
	{
		a.resize(len);
	}
	void shrink()
	{
		for(; !a.empty() && !a.back(); a.pop_back());
	}
	poly rever()
	{
		poly ret;
		ret.resize((*this).size());
		for(int i = 0; i < ret.size(); i++)
			ret.a[i] = a[ret.size() - i - 1];
		return ret;
	}
	void print()
	{
		for(int i = 0; i < size(); i++)
			printf("%d ", a[i]);
		puts("");
	}
	int operator[](const int& x)const
	{
		if(x < 0 || x >= a.size())
			return 0;
		return a[x];
	}
	poly diff()
	{
		if(a.empty())
			return poly();
		poly ret;
		ret.resize(a.size() - 1);
		for(int i = 0; i < ret.size(); i++)
			ret.a[i] = 1ll * (i + 1) * 1ll * a[i + 1] % mod;
		return ret;
	}
	void NTT(int type = 1)
	{
		static const int g = 3;
		int n = size();
		for(int i = 0; i < n; i++)
			if(i < rev[i]) swap(a[i], a[rev[i]]);
		for(int mid = 1; mid < n; mid <<= 1)
		{
			int step = pow(g, (mod - 1) / (mid << 1));
			for(int i = 0; i < n; i += (mid << 1))
			{
				for(int j = 0, omega = 1; j < mid; j++, omega = 1ll * omega * 1ll * step % mod)
				{
					int x = a[i + j], y = 1ll * omega * 1ll * a[i + j + mid] % mod;
					a[i + j] = (x + y) % mod;
					a[i + j + mid] = (x - y + mod) % mod;
				}
			}
		}
		if(type == -1)
		{
			reverse(a.begin() + 1, a.end());
			int inv = pow(n, mod - 2);
			for(int i = 0; i < n; i++)
				a[i] = 1ll * a[i] * 1ll * inv % mod;
		}
	}
	friend inline bool operator == (poly f, poly g)
	{
		f.shrink(), g.shrink();
		if(f.size() != g.size()) return 0;
		for(int i = 0; i < f.size(); i++)
			if(f[i] != g[i]) return 0;
		return 1;
	}
	friend inline bool operator != (poly f, poly g)
	{
		return !(f == g);
	}
	friend inline poly operator + (poly f, poly g)
	{
		f.resize(max(f.size(), g.size()));
		for(int i = 0; i < f.size(); i++)
			f.a[i] = (f[i] + g[i]) % mod;
		return f;
	}
	friend inline poly operator - (poly f, poly g)
	{
		f.resize(max(f.size(), g.size()));
		for(int i = 0; i < f.size(); i++)
			f.a[i] = (f[i] - g[i] + mod) % mod;
		return f;
	}
	friend inline poly operator * (poly f, poly g)
	{
		if(!f.size() || !g.size())
			return poly();
		int lim = 1;
		for(; lim < f.size() + g.size() - 1; lim <<= 1);
		for(int i = 0; i < lim; i++)
		{
			rev[i] = rev[i >> 1] >> 1;
			if(i & 1)
				rev[i] |= lim >> 1;
		}
		f.resize(lim), g.resize(lim);
		f.NTT(), g.NTT();
		for(int i = 0; i < lim; i++)
			f.a[i] = 1ll * f[i] * 1ll * g[i] % mod;
		f.NTT(-1), f.shrink();
		return f;
	}
	friend inline poly operator / (poly f, poly g)
	{
		static poly h = g.rever().inv(k + 1);
		if(f.size() < g.size())
			return poly();
		return (f.rever().modx(f.size() - g.size() + 1) * h.modx(f.size() - g.size() + 1)).modx(f.size() - g.size() + 1).rever();
	}
	friend inline poly operator % (poly f, poly g)
	{
		if(f.size() < g.size())
			return f;
		poly q = f / g;
		return (f.modx(g.size() - 1) - g.modx(g.size() - 1) * q.modx(g.size() - 1)).modx(g.size() - 1);
	}
	poly modx(int n)
	{
		poly g = *this;
		g.resize(min(g.size(), n));
		return g;
	}
	poly inv(int n)
	{
		poly f(pow(a[0], mod - 2));
		for(int len = 1; len < n; len <<= 1)
			f = (f * (poly(2) - f * (*this).modx(len << 1))).modx(len << 1);
		return f.modx(n);
	}
}p, base, ret;
int read()
{
	int ans = 0, neg = 1; char ch;
	for(; !isdigit(ch = getchar()); ) if(ch == '-') neg *= -1;
	for(; isdigit(ch); ans = (ans << 1) + (ans << 3) + (ch ^ 48), ch = getchar());
	return ans * neg;
}
int main()
{
	n = read(), k = read();
	for(int i = 1; i <= k; i++)
	{
		a[i] = read();
		if(a[i] < 0) a[i] += mod;
	}
	for(int i = 0; i < k; i++)
	{
		f[i] = read();
		if(f[i] < 0) f[i] += mod;
	}
	p.resize(k + 1), p.a[k] = 1;
	for(int i = 1; i <= k; i++)
	{
		if(a[i])
			p.a[k - i] = mod - a[i];
	}
	if(n & 1)
	{
		for(int i = 0; i <= k; i++)
		{
			if(p[i])
				p.a[i] = mod - p[i];
		}
	}
	base.resize(2), base.a[1] = 1, ret.resize(1), ret.a[0] = 1;
	for(; n; n >>= 1, base = base * base % p)
		if(n & 1) ret = ret * base % p;
	for(int i = 0; i < k; i++)
		ans = (1ll * ans + 1ll * f[i] * 1ll * ret[i]) % mod;
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：_Sein (赞：2)

### 常系数齐次线性递推

有一个暴力做法，直接矩乘快速幂即可，复杂度为 $\Theta(k^3\log n)$

观察这个答案的式子，

$$F=A^nG $$

其中(不妨把给定的 $a$ 序列整体往右一位，$f$ 也是 )

$$A=\begin{bmatrix}a_1&a_2&a_3&\cdots&a_k\\1&0&0&\cdots&0\\0&1&0&\cdots&0\\0&0&1&\cdots&0\\\vdots\\0&0&\cdots&1&0 \end{bmatrix}$$

通过初步了解 [线性代数](https://lb2003.top/archives/667.html) 可以知道存在特征解 $\lambda$ ，使得

$$A x=\lambda x$$

其中 $x$ 为关于 $\lambda $ 的特征向量。

然后发现这个关于 $x$ 的方程有非平凡解的条件等价于

$$\det(A-\lambda I )=0$$

然后建立狭义上的特征多项式

$$p(\lambda)=\det(A-\lambda I)=\begin{vmatrix}a_{1}-\lambda&a_{2}&\cdots&a_{k}\\1&-\lambda&\cdots &0\\\vdots\\0&\cdots &1&-\lambda\end{vmatrix}$$

按第一行展开可以得到:

$$p(\lambda)=(a_1-\lambda)A_{1,1}+a_2A_{1,2}+\cdots+a_kA_{1,k}$$

这时候引入[Cayley - Hamilton 定理](https://lb2003.top/archives/671.html) ，得到

$\begin{aligned}p(A)&=(a_1-\lambda)A_{1,1}+a_2A_{1,2}+\cdots+a_kA_{1,k}=0\end{aligned}$

一个以矩阵为变元的多项式，考虑进一步展开求得 $p(A)$ ，

然后可以发现 

$$p(A)=(-1)^n(A^k-\sum\limits_{i=1}^ka_iA^{k-i})$$

相当于一个 $k$ 次矩阵多项式。

由于有**多项式带余除法**这个黑科技在，那么把答案展开成 

$$F=A^nG=(p(A)q(A)+r(A))G$$

的形式，由于 $p(A)=0$

所以

$F=r(A)G$

$r(A)$ 是一个不满 $k$ 次的多项式。

那么现在就是如何求解 $r(A)$ 的问题了。

由于 $n$ 很大，说明 $q(A)$ 是一个不能直接求的多项式。

也就同时不能直接求解 $r(A)$

考虑快速幂。

实际上就是把 $n$ 拆成二进制形式即可，即 

$$A^n=A^{c_1}A^{c_2}\cdots A^{c_t},\forall c_i=2^j,j\in N$$

展开之后就是 

$$r(A)=r_1(A)r_2(A)\cdots r_t(A)$$

实际上还要将 $r_1(A)r_2(A)\cdots r_t(A)$ 做几次带余除法才会得到 $r(A)$ 。















---

## 作者：feicheng (赞：2)

## $\mathtt{Description}$

求一个满足 $k$ 阶齐次线性递推数列 ${a_i}$ 的第 $n$ 项，即：

$$a_n=\sum\limits_{i=1}^{k}f_i \times a_{n-i}$$

$\mathtt{restrictions:}n=10^9,k = 32000$

## $\mathtt{Solution}$

### $\mathtt{Pre-Knowledge}$

多项式取模。


关于求线性递推数列的解法[BJpers2](https://www.luogu.com.cn/blog/BJpers2/solution-p4723)大佬的题解已经说的很清楚了，这里主要写一下在打代码的时候需要注意的地方。

我们其实就是要求多项式 $x^n$ 在 $p(x)= x^k-f_1x^{k-1}-\cdots -f_kx^0$ 的模意义下的结果。

所以可以考虑快速幂，每次多项式取模就可以了，然后要注意以下两个点：

1. 对于多项式封装使用 `std::vector` 的同学，需要注意模的多项式的 `size` 大于原多项式的情况。

2. 原式有小于 $0$ 的情况，需要判断掉。

把代码放一下吧:

## $\mathtt{Code}$

```cpp
inline std::pair<vector<int>,vector<int> > Div(vector <int> f,vector <int> g) {
    int n = f.size(),m = g.size();
    if (n - m < 0) return std::make_pair(vector <int> (1,0),f) ;
    vector <int> fr(n),gr(m),igr,q(n - m + 1),r(m);
    for (int i = 0; i < n; ++i) fr[n - i - 1] = f[i] ;
    for (int i = 0; i < m; ++i) gr[m - i - 1] = g[i] ;
    gr.resize(n - m + 1) ;
    igr = Inv(gr),fr = fr * igr ;
    for (int i = 0; i < n - m + 1; ++i) q[i] = fr[n - m - i] ;
    g = q * g ;
    for (int i = 0; i < m; ++i) r[i] = (f[i] - g[i] + mod) % mod ;
    return std::make_pair(q,r) ;  
  }

  inline int LR(vector<int> a,vector<int> p,int n) {
    int k = a.size() ;
    vector<int> f(2),res(1) ;
    f[1] = res[0] = 1; 
    while (n) {
      if (n & 1) {
        res = res * f; 
        auto tmp = Div(res,p) ;
        res = tmp.second ;
      }
      f = f * f ;
      auto temp = Div(f,p) ;
      f = temp.second,n >>= 1;
    }
    int ans = 0 ;
    for (int i = 0; i < k; ++i) ans = (ans + 1ll * a[i] * res[i] % mod) % mod ;
    return ans ;
  }
```

---


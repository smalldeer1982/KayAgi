# [HNOI2004] 邮递员

## 题目描述

小李在 P 市的邮政局工作，他每天的工作是从邮局出发，到自己所管辖的所有邮筒取信件，然后带回邮局。他所管辖的邮筒非常巧地排成了一个 $m\times n$ 的点阵（点阵中的间距都是相等的）。左上角的邮筒恰好在邮局的门口。

小李是一个非常标新立异的人，他希望每天都能走不同的路线，但是同时，他又不希望路线的长度增加（即选择最短的路径走，注意路径长度是指小李实际走的物理距离，并且对路过每个邮筒的次数没有限制），他想知道他有多少条不同的路线可走。他在任何两个邮筒之间走的是直线。

编程，输入包括点阵的 $m$ 和 $n$ 的值；计算出小李可选的不同路线的总条数。

## 说明/提示

#### 样例输入输出 1 解释
![](https://cdn.luogu.com.cn/upload/pic/1331.png)

---
#### 数据规模与约定
- 对于 $100\%$ 的数据，保证 $1\le m\le10$，$1\le n\le20$，且保证 $n\times m$ 是偶数。

## 样例 #1

### 输入

```
 2 2```

### 输出

```
2```

# 题解

## 作者：Exber (赞：48)

## 做法
插头 dp。

这道题其实和模板题是差不多的，只是要开高精度，然后输出的时候 `ans` 要乘二而已。

首先分析一下题目。很容易发现，**一个格子只能经过一次**，要不然就不是最短路了。并且**一定不会斜着走**，因为三角形的两条直角边都比斜边短，“直角边+直角边”一定比“直角边+斜边”短。

注意，在本文里，我**把邮筒称作“格子”**。

#### 什么是插头 dp？

插头 dp 是一种很神奇的 dp 算法，它还有另外一个大名：**轮廓线 dp**。顾名思义，轮廓线 dp 就是在一条叫**轮廓线**的线上进行 dp，而插头 dp 就是在轮廓线的概念上再引入“**插头**”概念的 dp。

#### 轮廓线是什么?

![](https://cdn.luogu.com.cn/upload/image_hosting/fvqtsjky.png)

当推到黄色格子时，轮廓线就是那条**绿色的线**。

而 dp 转移的过程，就像把轮廓线往前推一格，把它从

![](https://cdn.luogu.com.cn/upload/image_hosting/fvqtsjky.png)

变成

![](https://cdn.luogu.com.cn/upload/image_hosting/ztd19m52.png)

接下来就可以去考虑黄色格子右边的那个格子（蓝色格子）啦。

#### 什么是插头？

插头就像一根链子，把两个格子连了起来。

下图中棕色的就是插头，可以发现它们把格子连了起来

![](https://cdn.luogu.com.cn/upload/image_hosting/u7t8pc0l.png)

从图中可以发现，**每个格子最多能有四个插头**，分别指向上、下、左和右。而**插头指向的格子必定会有插头指回来**，所以插头是成双成对出现的。又因为路径经过格子的话一定有一个插头是进格子的，还有一个是出格子的，所以插头数只能是 `2` 或者 `4`。

又由于一个格子只能经过一遍，所以插头数只能为 `2`。

#### 如何定义状态？

插头 dp 毕竟还是一种 dp，所以还得定义状态。

定义 $dp_{i,j,S}$ 表示递推到格子 $(i,j)$，转移完的轮廓线的状态为 $k$ 时的方案数。

考虑如何表示状态 $k$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ekxtis7l.png)

看这张图，很容易发现，轮廓线会把路径切开，每条路径都会先从轮廓线下面穿过轮廓线，转一圈，再从轮廓线上面穿过轮廓线。所以对于每条路径，在轮廓线上都有两个插头，所以所有轮廓线上的插头一一匹配。

但注意，虽然经过轮廓线时方向不同，但插头的方向却都是向下或者向右！

而路径不会相交，要不然就有格子走了两遍了，所以一一匹配的两对插头一定不会相交。


“一一匹配，不会相交”你想到了什么？没错！**括号匹配**！

##### 括号表示法

可以把一条路径在轮廓线上左边的插头看作左括号 `(`，把右边的插头看作右括号 `)`，那么刚才的那幅图就可以变成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/2ks5s4tz.png)

写出来就是:（`#` 表示没有交点）

```
(#(##))(#)
```

看到这里你肯定会感到奇怪，为什么第二和第三个括号之间有两个 `#`？很简单，因为它们之间有两个插头位置！（一个下插头位置和一个右插头位置）。

到这里，我们终于可以表示状态 $k$ 啦！可以用一个三进制，第 $i$ 位为 `0/1/2` 时分别表示:

`这个位置没有插头/这个位置有一个左括号插头/这个位置有一个右括号插头`。

由于三进制实在是太慢太慢了，所以我们采用四进制。

问题又来了，**什么插头是左括号插头，什么插头是右括号插头呢**？

别急，这个问题在状态转移的时候自然就会解决啦。

#### 如何转移？

首先枚举上一格的状态 $k$。

到这里问题又双叒叕来了：**状态实在是太多啦，暴力枚举肯定会 `TLE` + `MLE` 的**！

所以需要**滚动一下数组**，只存当前格的信息和上一格的信息，来确保不会 `MLE`。

对于 `TLE`，我们可以用**哈希表**来优化。细心的同学肯定早就发现了，**那么多状态里肯定有一大堆不合法的**。（括号不匹配）而暴力判断括号匹配麻烦又费事，所以我们采用优秀的哈希技术，把上一格可行的状态全存起来，同时 dp 状态的定义也变成了 $dp_{i,j,k}$ 表示递推到格子 $(i,j)$，转移完的**状态编号**为 $k$ 时的方案数。

![](https://cdn.luogu.com.cn/upload/image_hosting/i5inks1a.png)

由于状态转移只和当前格左边和上面的插头有关系（图中红色的插头），所以定义当前格左边那个往右插的插头状态为 `p`（`0/1/2`），当前格上面那个往下插的插头状态为 `q`（`0/1/2`）。

终于可以开始分类讨论了。

容易发现，其实一共就只有 `7` 种状态。

注意，在接下来的状态图中，灰色的箭头表示**那里没有插头**，红色的箭头表示**那里有插头**。

1. `p==0&&q==0`

这时，状态看起来是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/u01pa6uj.png)

没有插头指向当前格！我们只好新建一个路径了：

![](https://cdn.luogu.com.cn/upload/image_hosting/rxoa2m1w.png)

这样，我们就新建了一对括号，**解决了之前遗留下来的插头类型问题了**。

2. `p!=0&&q==0`

这时，状态看起来是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/4at4vqn9.png)

这时，我们可以让它拐个弯儿，或者让它往前走，变成这样

![](https://cdn.luogu.com.cn/upload/image_hosting/kq10g10a.png)

或者这样

![](https://cdn.luogu.com.cn/upload/image_hosting/3g4oayuq.png)

注意，拐弯不能拐去地图边界了，往前走也不能走到地图边界。

`p` 的类型并不重要，因为**转移之后的类型和转移之前的类型相同**。

3. `p==0&&q!=0`

这时，状态看起来是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/yo3er1i6.png)

和 `2` 号状态一样，我们可以让它拐个弯儿或者让它往前走。拐弯也不能拐去地图边界，往前走也不能走到地图边界。

`q` 的类型依然不重要。

4. `p!=0&&q!=0`

这时，状态看起来是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/i5inks1a.png)

对于这种情况，就要分四个子情况讨论了。

- ###### `p==1&&q==1`

这时，`p` 和 `q` 对应的路径是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/vjses1ma.png)

当我们把它们俩连起来后，路径就变成这样了

![](https://cdn.luogu.com.cn/upload/image_hosting/yf01bbec.png)

所以我们需要找到 `q` 对应的右括号（`2`），把它改成左括号（`1`），并把 `p` 和 `q` 改成井号（`0`）。

- ###### `p==2&&q==2`

这时，`p` 和 `q` 对应的路径是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/1r6snjqi.png)

当我们把它们俩连起来后，路径就变成这样了

![](https://cdn.luogu.com.cn/upload/image_hosting/l2ytcrwn.png)

所以我们需要找到 `p` 对应的左括号（`1`），把它改成右括号（`2`），并把 `p` 和 `q` 改成井号（`0`）。

- ###### `p==2&&q==1`

这时，`p` 和 `q` 对应的路径是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/5cnjs9rk.png)

当我们把它们俩连起来后，路径就变成这样了

![](https://cdn.luogu.com.cn/upload/image_hosting/km0ropk7.png)

所以我们只要把 `p` 和 `q` 改成井号（`0`）就行了。

- ###### `p==1&&q==2`

这时，`p` 和 `q` 对应的路径是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/68puqrqi.png)

当我们把它们俩连起来后，路径就变成这样了

![](https://cdn.luogu.com.cn/upload/image_hosting/125u1emd.png)

这可不得了！我们把路径闭合起来了！由于轮廓线下面的部分都还没有路径经过，所以这样做只有在 `i==n&&j==m` 的情况下才是合法的。

合法的话我们只要把 `p` 和 `q` 改成井号（`0`）就行了。

并且闭合之后答案要累加。

#### 如何初始化？

当换行时，我们发现右插头位置没了……

![](https://cdn.luogu.com.cn/upload/image_hosting/gipg37ib.png)

而上一状态却有右插头位置

![](https://cdn.luogu.com.cn/upload/image_hosting/gpkwhbmd.png)

所以要补一个右插头位置。

#### 输出什么？

最后要输出 `答案*2`。

因为**老李可以顺时针走也可以逆时针走**。

#### 结束了？

没有……

这题太坑了，并没有 `答案对 xxx 取模` 这一句话，所以需要高精度……

因为我太懒了，所以高精度直接用了 `__int128`。（大家千万不要学我，因为 `__int128` 在赛场上不给用）

最后注意有个特判，当 $n$ 或 $m$ 为 `1` 时输出 `1`。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

#define S 300005
#define mod 2001

typedef __int128 ll;

using namespace std;

int n,m;
ll dp[2][S];
int d; // 滚动数组下标 
int tot[2],h[S],nxt[S],val[2][S]; // 哈希表相关 
int only[15]; // only[i] 存 4^i 
ll ans;

void write(ll x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)
	{
		write(x/10);	
	}
	putchar(x%10+'0');
}

inline void ins(int x,ll num) // 插入哈希表并更新 
{
	int id=x%mod;
	for(int p=h[id];p;p=nxt[p])
	{
		if(val[d][p]==x)
		{
			dp[d][p]+=num;
			return;
		}
	}
	nxt[++tot[d]]=h[id];
	h[id]=tot[d];
	val[d][tot[d]]=x;
	dp[d][tot[d]]=num;
}

inline void _dp() 
{
	d=0;
	tot[d]=1;
	val[d][1]=0;
	dp[d][1]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=tot[d];j++)
		{
			val[d][j]<<=2; // 初始化：插入一个空插头，补一下右插头位置 
		}
		for(int j=1;j<=m;j++)
		{
			// 滚动 
			int las=d;
			d^=1;
			memset(h,0,sizeof(h));
			tot[d]=0; 
			for(int k=1;k<=tot[las];k++) // 枚举状态 
			{ 
				int zlt=val[las][k]; // 当前状态（zltzlt：zlt 好评） 
				ll num=dp[las][k];
				int p=(zlt>>j*2-2)%4,q=(zlt>>j*2)%4; // 获取 q、p
				// 各种状态 
				if(!p&&!q)
				{
					// 弄一个新路径 
					if(i<n&&j<m)
					{
						ins(zlt+only[j-1]+2*only[j],num);
					}
				}
				else if(p&&!q)
				{
					// 拓展路径 
					if(i<n) // 拐个弯儿 
					{
						ins(zlt,num);
					}
					if(j<m) // 直走 
					{
						ins(zlt+only[j]*p-only[j-1]*p,num);
					}
				}
				else if(!p&&q)
				{
					// 拓展路径 
					if(j<m) // 直走 
					{
						ins(zlt,num);
					}
					if(i<n) // 拐个弯儿 
					{
						ins(zlt-only[j]*q+only[j-1]*q,num);
					}
				}
				else if(p==1&&q==1)
				{
					// 暴力找括号 
					int top=1;
					for(int l=j+1;l<=m;l++)
					{
						if((zlt>>l*2)%4==1)
						{
							top++;
						}
						if((zlt>>l*2)%4==2)
						{
							top--;
						}
						if(top==0)
						{
							ins(zlt-only[j]-only[j-1]-only[l],num); // 改一下 
							break;
						}
					}
				}
				else if(p==2&&q==2)
				{
					// 暴力找括号 
					int top=1;
					for(int l=j-2;l>=0;l--)
					{
						if((zlt>>l*2)%4==1)
						{
							top--;
						}
						if((zlt>>l*2)%4==2)
						{
							top++;
						}
						if(top==0)
						{
							ins(zlt+only[l]-only[j]*2-only[j-1]*2,num); // 改一下 
							break;
						}
					}
				}
				else if(p==2&&q==1)
				{
					ins(zlt-only[j-1]*2-only[j],num); // 连起来 
				}
				else if(p==1&&q==2&&i==n&&j==m)
				{
					ans+=num; // 不得了了！ 
				}
			}
		}
	}
}

int main()
{
	only[0]=1;
	for(int i=1;i<=13;i++) // 初始化 only 数组 
	{
		only[i]=only[i-1]<<2;
	}
	scanf("%d%d",&m,&n);
	if(m==1||n==1) // 特判 
	{
		puts("1");
		return 0;
	}
	_dp();
	write(ans*2); // 记得乘二 
	return 0;
}
```


---

## 作者：Setsugesuka (赞：21)

------------
- ### 题解By——攻略组Setsugesuka

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;水题没人写题解？那我就厚脸皮的水下咕值了。

ps:本题解大量图片来自[插头DP入门选讲](http://www.cnblogs.com/LadyLex/p/7326874.html)等各大神仙的博客（流下了不会画图的泪水）

------------
- ### 题目大意

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;阅读题面，发现题面全部都是废话，我们提取有关信息，得到以下内容。

>给定一张$n$ $×$ $m$的网格图，求经过所有点的曼哈顿回路个数。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;插头$DP$裸题？难道省选会这么简单吗？仔细看题，发现题面缺少了一样现在$OI$题都会有的内容，“答案对$xxx$取模”，没错，这道题为了恶心人，需要我们手写高精。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;于是，我们只需要用高精度记录答案，做一遍插头$DP$即可。为了帮助萌新们快速地学会解决这类入门难度题，我们从插头$DP$开始讲起。

------------
- ### 什么是插头

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;什么是插头$DP$，是在插头上做$DP$嘛？然而并不是，插头$DP$只是一种用于解决基于联通性的状态压缩动态规划问题的方法而已。（∵插头$DP$ $∈$ $DP$，又∵$DP$ $∈$ $NOIP$考纲，∴插头$DP$ $∈$ $NOIP$考纲）

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们首先来了解一下什么是插头。

>在插头DP中，插头表示一种联通的状态。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;？？？联通的状态又是什么，我怎么什么都听不懂？？？

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;别急，我们先来看这样一道例题。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;给出一张$n×m$有障碍的棋盘，要求用任意条回路遍历整个棋盘，不能经过障碍格子，要求统计不同的行走方案数。
![题目图片](https://cdn.luogu.com.cn/upload/pic/46771.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;假设我们当前已经推到了第三行，障碍在$(1,1)$与$(1,2)$。
![当前推到了哪里](https://cdn.luogu.com.cn/upload/pic/46772.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;插头，就是在蓝色轮廓线上面的那些箭头，准确地来说，每个格子都有一定数量的插头，但由于我们在插头$DP$中一般采用逐格递推的方法，很多格子的插头是不会对下个状态产生贡献的，于是我们只记录轮廓线上的插头。在前面我们讲过，插头表示一种联通的状态，什么是联通的状态呢？很简单，我们看第一张图的$(2,2)$与$(2,3)$这两格。它们的都是竖直的，且没有构成回路，如果他要构成回路，只有下面的格子才能更新他的状态，因为他的上左都是已经确定了的，因此，他的插头方向向下。

>一个格子有一个向某方向的插头，就意味着这个格子在这个方向可以与外面相连（与插头那边的格子联通）。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;值得注意的是，插头表示的是一个格子一定确定了的现实状态，而不是一个格子要怎么画线的虚拟状态。也就是说，如果有一个插头指向某个格子，那么这个格子已经和插头来源联通了，我们接下来要考虑的是从这个插头往哪里走。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一般来说，我们从上往下，从左往右地去递推我们的棋盘。

------------
- ### 列间转移

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们考虑第$i$行的某一个格子：走向它的方案，可能由上一行的下插头转移而来，也可能是本行的右插头转移而来。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;因此我们需要记录这些地方有没有插头，也就是利用状压的思想。我们记录的这个“有没有插头”的东西，就被我们称为轮廓线。字面意思，轮廓线就是记录了棋盘这一行与上一行交界的轮廓中插头的情况。轮廓线上方是已经决策完的格子，下方是未决策的。显然，对于本题的轮廓线，与它直接相连的格子有$m$个，插头有$m+1$个，我个人的习惯是给插头编号$0$~$m$。

![某个状态](https://cdn.luogu.com.cn/upload/pic/46773.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;举个栗子，对于以上状态，我们发现，对于我们要推的这一鸽，它的左边有一个右插头，它的上边有一个下插头，因此，这个格子只能变成左上插头。

------------
- ### 行间转移

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们先考虑两行之间的转移：显然，第$i$行的下插头决定了第$i+1$行的格子有没有上插头，因此我们应该把这个信息传递到下一行。当一行已经全部推完时，轮廓线将会是一个直线，它的第$m$位是一个空格子的左插头位置，是不需要更新的。因此，在转移的时候，只有当前行插头$0$到插头$m-1$可能会给下一行带来贡献，而第$m$个插头一定为$0$，我们只需要恰当的左移即可。

------------
- ### DP更新

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不难发现，对于这个模板题，有以下三种情况。
![三种情况](https://cdn.luogu.com.cn/upload/pic/46777.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于情况$1$，这个格子上方没有一个下插头，左边也没有一个右插头，因为题目要求我们要遍历整张图，而且这个格子不在任何一个边缘上，所以我们建立一个右下插头。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于情况$2$，这个格子上方有一个下插头，左边也有一个右插头，因此，我们只需要建立一个左上插头即可。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于情况$3$，这个格子只有上方的一个下插头，因此它既可以建立一个上下插头，也可以建立一个右上插头。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;综上，这个板子很容易就能写出来了。

------------
- ### 考虑题目的不同

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们来考虑要解决的这道题，众所周知，邮递员并不会使用替身攻击，因此他无法分身去送快递，即。

![情况](https://cdn.luogu.com.cn/upload/pic/46778.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于这种情况，在模板题中是可行的，在这道题中是不可行的，于是，我们来思考一下怎么定义我们的插头状态，首先我们有以下很显然的结论。

>因为题目要求每个格子都在回路中，那么最后全部的格子一定会通过插头形成一个联通快。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不难想到我们可以利用最小表示法来维护联通性，但是，我们通过模板可知，在递推过程中，很多方块是不会对得出下一个格子作出贡献的，如果直接用最小表示法，我们会浪费很多的内存。因此，我们转换优化的角度，用最小表示法来表示插头的联通性：如果这个插头存在，那么就标记这个插头对应的格子的连通标号，如果这个插头不存在，那么标记为$0$，仔细思考后，我们还可以得到以下一个结论。

>如果每个格子都在回路中的话，我们还可以得到，每个格子应该恰好有且仅有2个插头。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这同样也是很显然的。在得到这两个结论之后，我们来思考一下如何定义我们的插头状态。

![括号序列](https://cdn.luogu.com.cn/upload/pic/46783.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;观察这张图片，我们发现，对于一条路径，它的左右端点分别对应了轮廓线上的两个插头。很容易看出，对于这类题目，一定满足任何时候轮廓线上每一个连通分量恰好有$2$个插头。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这说明了什么呢！我也不知道，但是有神仙提出这和括号序列很像，然后大家仔细看了一下，真的和括号序列很像，于是我们可以使用一种新的定义方式：$3$进制表示——$0$表示无插头，$1$表示左括号插头，$2$表示右括号插头,记录下所有的轮廓线信息。那么，我们来考虑一下这道题的状态转移。

------------
- ### 状态转移方法

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们设该格左边的插头为$p1$，右边的插头为$p2$。

1. ```cpp
(p1==0&&p2==0)
```
我们新建一个路径，下插头设为左括号插头，右插头设为右括号插头。

2. ```cpp
(p1==0&&p2!=0)
```
我们对直走和转弯进行分类讨论。

3. ```cpp
(p1!=0&&p2==0)
```
同$2$。

4. ```cpp
(p1==1&&p2==1)
```
把$2$个左括号插头相连，将右边那个左括号插头（$p2$）对应的右括号插头$q2$修改成左括号插头。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;![情况4](https://cdn.luogu.com.cn/upload/pic/46784.png)

5.  ```cpp
(p1==1&&p2==2)
```
众所周知，因为只有一条回路，所以路径是两两不相交的，对于这种情况，显然是形成了回路。不难发现，只有在(x==n&&y==m)时，这种状态才是合法的，我们可以用它更新答案。

6.  ```cpp
(p1==2&&p2==1)
```
如图，这种情况并不会形成回路，而只需要把两个括号连起来即可。![情况5，6](https://cdn.luogu.com.cn/upload/pic/46786.png)

7.  ```cpp
(p1==2&&p2==2)
```
与情况$4$同理。&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;![情况7](https://cdn.luogu.com.cn/upload/pic/46788.png)


&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在得出了状态转移的方法后，代码也就很容易写出来了，值得注意的是，如果你想让你的插头$DP$跑的更快，用的空间更小，请手动学习哈希表的写法。

------------
- ### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int databit=1e9;
const int MOD=2601;

int n,m;

struct data
{
	int bit[6];
	
	inline void clear()
	{
		memset(bit,0,sizeof(bit));
	}
	
	inline void set(int x)
	{
		clear();
		while(x)
		{
			bit[++bit[0]]=x%databit;
			x/=databit;
		}
	}
	
	inline int &operator [](int x)
	{
		return bit[x];
	}
	
	inline data operator +(data b)
	{
		data c;
		c.clear();
		c[0]=max(bit[0],b[0])+1;
		for(int i=1;i<=c[0];i++)
			c[i]+=bit[i]+b[i],c[i+1]+=c[i]/databit,c[i]%=databit;
		while(!c[c[0]]) c[0]--;
		return c;
	}
	
	inline void operator +=(data b)
	{
		*this=*this+b;
	}
	
	inline void operator =(int x)
	{
		set(x);
	}
	
	inline void print()
	{
		printf("%d",bit[bit[0]]);
		for(int i=bit[0]-1;i>=1;i--)
		{
			printf("%09d",bit[i]);
		}
		puts("");
	}
	
	data()
	{
		clear();
	}
};

data ans;

struct hashmp
{
	data val[MOD];	
	int key[MOD],sz,hash[MOD];
	
	inline void init()
	{
		memset(val,0,sizeof(val));
		memset(key,-1,sizeof(key));
		sz=0;
		memset(hash,0,sizeof(hash));
	}
	
	inline void newhash(int id,int v)
	{
		hash[id]=++sz;
		key[sz]=v;
	}
	
	inline data &operator[](int state)
	{
		for(int i=state%MOD;;i=(i+1==MOD)?0:i+1)
		{
			if(!hash[i])
				newhash(i,state);
			if(key[hash[i]]==state)
				return val[hash[i]];
		}
	}
};

hashmp dp[2];

inline int find(int state,int id)
{
	return (state>>((id-1)<<1))&3;
} 

inline void dpset(int &state,int bit,int val)
{
	bit=(bit-1)<<1;
	state|=3<<bit;
	state^=3<<bit;
	state|=val<<bit;
}

inline int link(int state,int pos)
{
	int cnt=0,delta=(find(state,pos)==1)?1:-1;
	for(int i=pos;i&&i<=m+1;i+=delta)
	{
		int p=find(state,i);
		if(p==1)
			cnt++;
		else if(p==2)
			cnt--;
		if(cnt==0)
			return i;
	}
	return -1;
} 

inline void run(int x,int y)
{
	int now=((x-1)*m+y)&1,last=now^1,tot=dp[last].sz;
	dp[now].init();
	for(int i=1;i<=tot;i++)
	{
		int state=dp[last].key[i];
		data val=dp[last].val[i];
		int p1=find(state,y),p2=find(state,y+1);
		if(link(state,y)==-1||link(state,y+1)==-1)
			continue;
		if(!p1&&!p2&&x!=n&&y!=m)
		{
			dpset(state,y,1);
			dpset(state,y+1,2);
			dp[now][state]+=val;
		}
		else if(p1&&!p2)
		{
			if(x!=n)
				dp[now][state]+=val;
			if(y!=m)
			{
				dpset(state,y,0);
				dpset(state,y+1,p1);
				dp[now][state]+=val;
			}
		}
		else if(!p1&&p2)
		{
			if(y!=m)
				dp[now][state]+=val;
			if(x!=n)
			{
				dpset(state,y,p2);
				dpset(state,y+1,0);
				dp[now][state]+=val;
			}
		}
		else if(p1==1&&p2==1)
		{
			dpset(state,link(state,y+1),1);
			dpset(state,y,0);
			dpset(state,y+1,0);
			dp[now][state]+=val;
		}
		else if(p1==1&&p2==2)
		{
			if(x==n&&y==m)
				ans+=val;
		}
		else if(p1==2&&p2==1)
		{
			dpset(state,y,0);
			dpset(state,y+1,0);
			dp[now][state]+=val;
		}
		else if(p1==2&&p2==2)
		{
			dpset(state,link(state,y),2);
			dpset(state,y,0);
			dpset(state,y+1,0);
			dp[now][state]+=val;
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	if(n==1||m==1)
	{
		puts("1");
		return 0;
	}
	if(m>n) 
		swap(n,m);
//	cout<<"QAQ"<<endl;
	dp[0].init();
//	cout<<"fuck you all"<<endl;
	dp[0][0]=1;
//	cout<<"fuck you"<<endl;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			run(i,j);
		if(i!=n)
		{
			int now=(i*m)&1,tot=dp[now].sz;
			for(int j=1;j<=tot;j++)
				dp[now].key[j]<<=2;
		}
	}
	ans+=ans;
	ans.print();
	return 0;
}
```

---

## 作者：Porsche (赞：8)

好多大佬都打了高精，然而我并不喜欢高精，所以……
```


#include<bits/stdc++.h>
using namespace std;
struct hsh_table
{
	__int128 nxt;
	__int128 to;
}hsh[850000];
__int128 pre_hsh[850000],at;
__int128 sta_hsh[2][850000],cnts[2];
__int128 bit[25];
bool cnt;
__int128 endx,endy;
__int128 ans,ansss,dp[2][850000];
void hsh_map(__int128 sta,__int128 val)
{
	__int128 key=sta%849383;
	for(int i=pre_hsh[key];i;i=hsh[i].nxt)
		if(sta_hsh[cnt][hsh[i].to]==sta)
		{dp[cnt][hsh[i].to]+=val;return;}
	sta_hsh[cnt][++cnts[cnt]]=sta;
	dp[cnt][cnts[cnt]]=val;
	hsh[++at].nxt=pre_hsh[key];
	hsh[at].to=cnts[cnt];
	pre_hsh[key]=at;
}
inline void write(__int128 x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
}
int main()
{
	int n,m;
	scanf("%d%d",&m,&n);
	if(n==1||m==1)
	{
		puts("1");
		return 0;
	}
	endx=n;
	endy=m;
	for(int i=1;i<=m;i++)
		bit[i]=(i<<1);
	cnts[0]=1;
	dp[0][1]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=cnts[cnt];j++)sta_hsh[cnt][j]<<=2;
		for(int j=1;j<=m;j++)
		{
			at=0;
			memset(pre_hsh,0,sizeof(pre_hsh));
			cnt^=1;
			cnts[cnt]=0;
			for(__int128 k=1;k<=cnts[cnt^1];k++)
			{
				__int128 sta=sta_hsh[cnt^1][k];
				__int128 ans=dp[cnt^1][k];
				__int128 down=(sta>>bit[j])%4;
				__int128 rght=(sta>>bit[j-1])%4;
				if(!down&&!rght)
					{if(i!=n&&j!=m)hsh_map(sta+2*(1<<bit[j])+(1<<bit[j-1]),ans);}
				else if(down&&!rght)
				{
					if(j!=m)hsh_map(sta,ans);
					if(i!=n)hsh_map(sta+down*((1<<bit[j-1])-(1<<bit[j])),ans);
				}
				else if(!down&&rght)
				{
					if(i!=n)hsh_map(sta,ans);
					if(j!=m)hsh_map(sta+rght*((1<<bit[j])-(1<<bit[j-1])),ans);
				}
				else if(down==1&&rght==1)
				{
					__int128 count=1;
					for(__int128 l=j+1;l<=m;l++)
					{
						if((sta>>bit[l])%4==1)count++;
						if((sta>>bit[l])%4==2)count--;
						if(!count)
						{
							hsh_map(sta-(1<<bit[j])-(1<<bit[j-1])-(1<<bit[l]),ans);
							break;
						}
					}
				}
				else if(down==2&&rght==2)
				{
					__int128 count=1;
					for(__int128 l=j-2;l>=0;l--)
					{
						if((sta>>bit[l])%4==1)count--;
						if((sta>>bit[l])%4==2)count++;
						if(!count)
						{
							hsh_map(sta-2*(1<<bit[j])-2*(1<<bit[j-1])+(1<<bit[l]),ans);
							break;
						}
					}
				}
				else if(down==1&&rght==2)
					{hsh_map(sta-(1<<bit[j])-2*(1<<bit[j-1]),ans);}
				else if(down==2&&rght==1&&i==endx&&j==endy)ansss+=ans;
			}
		}
	}
	write(ansss*2);
	return 0;
}

```
bulabula～

---

## 作者：creation_hy (赞：3)

## 前言：

之前就做过，现在才想起来发题解（

这题和插头 dp 模版几乎一模一样，只是把图所有点都改成可走了。

## 思路：

题目要求最短路径，很显然不能出现斜线。

因为斜线后，还是只多访问了一个点，但是距离却增加了。而你依旧要把其他所有点都访问一遍，那走斜线最后的距离明显会比最短距离多一点。

于是，题意转化为：只走直线，要经过每个点，且不重复经过的方案数。

把这堆邮筒东西想象成格子，那不就是插头 dp 了吗。

如果你还不知道如何实现插头 dp，可以看看我的博客：[插头dp详解](https://www.luogu.com.cn/blog/creationhy/plug-dp)。

总结几个坑点：

- 方案数明显比模版多（这个是 $10\times20$ 啊……），所以要用 `__int128` 存储。
- 先输入 $m$，再输入 $n$！！！不仅是为了题面，也是为了你的程序的效率！！！
- 数组别开小了。

附送一份输出代码（大雾）：

```cpp
void write(ll x)
{
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef __int128 ll;
const int mod = 1e6 + 3;
int n, m, bits[15], state[mod + 5][2];
ll f[mod + 5][2], ans;
int head[mod + 5], to[mod + 5], nxt[mod + 5], sz[2], qwq, tot;
inline void link(int u, int v)
{
    to[tot] = v;
    nxt[tot] = head[u];
    head[u] = tot++;
}
inline void add(int x, ll k)
{
    int key = x % mod;
    for (int i = head[key]; ~i; i = nxt[i])
        if (state[to[i]][qwq] == x)
        {
            f[to[i]][qwq] += k;
            return;
        }
    state[++sz[qwq]][qwq] = x;
    f[sz[qwq]][qwq] = k;
    link(key, sz[qwq]);
}
void write(ll x)
{
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> m >> n;
    if (m == 1 || n == 1)
    {
        cout << 1;
        return 0;
    }
    for (int i = 1; i <= 10; i++)
        bits[i] = i << 1;
    sz[qwq] = 1;
    f[1][qwq] = 1, state[1][qwq] = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= sz[qwq]; j++)
            state[j][qwq] <<= 2;
        for (int j = 1; j <= m; j++)
        {
            tot = 0;
            memset(head, -1, sizeof(head));
            qwq ^= 1;
            sz[qwq] = 0;
            for (int k = 1; k <= sz[qwq ^ 1]; k++)
            {
                int stt = state[k][qwq ^ 1];
                int up = (stt >> bits[j]) % 4, left = (stt >> bits[j - 1]) % 4;
                ll val = f[k][qwq ^ 1];
                if (!up && !left)
                {
                    if (i < n && j < m)
                        add(stt | 1 << bits[j - 1] | 2 << bits[j], val);
                }
                else if (left && !up)
                {
                    if (i < n)
                        add(stt, val);
                    if (j < m)
                        add(stt - left * (1 << bits[j - 1]) + left * (1 << bits[j]), val);
                }
                else if (!left && up)
                {
                    if (j < m)
                        add(stt, val);
                    if (i < n)
                        add(stt - up * (1 << bits[j]) + up * (1 << bits[j - 1]), val);
                }
                else if (left == 1 && up == 1)
                {
                    int cnt = 1;
                    for (int p = j + 1; p <= m; p++)
                    {
                        if ((stt >> bits[p]) % 4 == 1) // left plug
                            cnt++;
                        else if ((stt >> bits[p]) % 4 == 2) // right plug
                            cnt--;
                        if (!cnt) // matched
                        {
                            add(stt - (1 << bits[p]) - (1 << bits[j]) - (1 << bits[j - 1]), val);
                            break;
                        }
                    }
                }
                else if (left == 2 && up == 2)
                {
                    int cnt = 1;
                    for (int p = j - 2; p >= 0; p--)
                    {
                        if ((stt >> bits[p]) % 4 == 1) // left plug
                            cnt--;
                        if ((stt >> bits[p]) % 4 == 2) // right plug
                            cnt++;
                        if (!cnt) // matched
                        {
                            add(stt - (2 << bits[j]) - (2 << bits[j - 1]) + (1 << bits[p]), val);
                            break;
                        }
                    }
                }
                else if (left == 2 && up == 1)
                    add(stt ^ 2 << bits[j - 1] ^ 1 << bits[j], val);
                else if (left == 1 && up == 2 && i == n && j == m)
                    ans += val;
            }
        }
    }
    write(ans << 1);
    return 0;
}
```

---

## 作者：MafuyuQWQ (赞：2)

## Problem

> 给定一个 $m \times n$ 的点阵，求长度最短且经过每个点恰好一次的回路的数量。

## Solution

显然只会进出每个点 $1$ 次，所以路径的总边数是一定的，则走斜边不如走直边，那么最优路径一定是全都走直边的。  
于是结合数据范围是 $1\le m\le10$，$1\le n\le20$，不难想到插头 DP。  
设 $f_{i,j,s}$ 表示走到格子 $[i,j]$ 的方案数，对于轮廓线上每条边的表示设为 $0$ 表示无插头，$1$ 表示有属于回路左端的插头，$2$ 表示有属于回路右端的插头。接下来分类讨论当前格子轮廓线上的插头情况即可。  
其实和模板那题差不多。
注意最后回路的数量要乘以 $2$，因为可以正的走，也可以反的走。  
有效状态数量应该是在 $5\times10^4$ 级别左右的。

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 1000000, M = N * 2 + 7;

int n, m;
int h[2][M], q[2][N], cnt[2];
__int128 v[2][M];
int px, py;

int find(int cur, int x)
{
    int t = x % M;
    while (~h[cur][t] && h[cur][t] != x)
        if ( ++ t == M) t = 0;
    return t;
}

void insert(int cur, int state, __int128 w)
{
    int t = find(cur, state);
    if (~h[cur][t]) v[cur][t] += w;
    else
    {
        h[cur][t] = state, v[cur][t] = w;
        q[cur][ ++ cnt[cur]] = t;
    }
}

int get(int s, int k)
{
    return s >> k * 2 & 3;
}

int set(int k, int v)
{
    return v << k * 2;
}

#define int __int128

inline void print(int n)
{
    if (n < 0)
	{
        putchar('-');
        n *= -1;
    }
    if (n > 9) print(n / 10);
    putchar(n % 10 + '0');
}

#undef int

signed main()
{
    cin >> n >> m;
    if (n < m) swap(n, m);
    
    if (m == 1)
    {
        cout << "1\n";
        return 0;
    }
    
    __int128 res = 0;
    memset(h, -1, sizeof h);
    int cur = 0;
    insert(cur, 0, 1);
    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= cnt[cur]; j ++ )
            h[cur][q[cur][j]] <<= 2;
        for (int j = 1; j <= m; j ++ )
        {
            int last = cur;
            cur ^= 1, cnt[cur] = 0;
            memset(h[cur], -1, sizeof h[cur]);
            for (int k = 1; k <= cnt[last]; k ++ )
            {
                int s = h[last][q[last][k]];
                __int128 w = v[last][q[last][k]];
                int x = get(s, j - 1), y = get(s, j);
                if (!x && !y)
                {
                    if (i < n && j < m) 
                        insert(cur, s + set(j - 1, 1) + set(j, 2), w);
                }
                else if (!x && y)
                {
                    if (i < n) insert(cur, s - set(j, y) + set(j - 1, y), w);
                    if (j < m) insert(cur, s, w);
                }
                else if (x && !y)
                {
                    if (i < n) insert(cur, s, w);
                    if (j < m) insert(cur, s - set(j - 1, x) + set(j, x), w);
                }
                else if (x == 1 && y == 1)
                {
                    for (int u = j + 1, ct = 1;; u ++ )
                    {
                        int t = get(s, u);
                        if (t == 1) ct ++ ;
                        else if (t == 2)
                        {
                            if (!( -- ct)) 
                            {
                                insert(cur, s - set(j - 1, x) - set(j, y) - set(u, 1), w);
                                break;
                            }
                        }
                    }
                }
                else if (x == 2 && y == 1) insert(cur, s - set(j - 1, x) - set(j, y), w);
                else if (x == 2 && y == 2)
                {
                    for (int u = j - 2, ct = 1;; u -- )
                    {
                        int t = get(s, u);
                        if (t == 2) ct ++ ;
                        else if (t == 1)
                        {
                            if (!( -- ct))
                            {
                                insert(cur, s - set(j - 1, x) - set(j, y) + set(u, 1), w);
                                break;
                            }
                        }
                    }
                }
                else if (i == n && j == m) res += w;
            }
        }
    }
    
    res *= 2;
    print(res);
    
    return 0;
}
```

---


# [POI 2015] CZA

## 题目描述

$n$ 个人（编号为 $1 \sim n$）围着圆桌坐成一圈。座位相邻的两个人，其编号之差的绝对值不可以超过 $p$。他们之中有些人不喜欢别人。如果 $a$ 不喜欢 $b$，那么 $b$ 不能坐在 $a$ 右边的那一个位置上。现在，假设第 $n$ 个人的座位已经固定，要给剩下的人安排座位，共有几种合法方案？

## 说明/提示

原题名称：Czarnoksiężnicy okrągłego stołu。

## 样例 #1

### 输入

```
5 2 3
1 3
5 4```

### 输出

```
6```

# 题解

## 作者：disposrestfully (赞：11)

对于$p\le2$的情况我们都能直接判断,考虑$p=3$.

一个比较显然的想法是把所有数字从小到大放到环上,记录之前放的三个数之间有没有空位,以及这三个数是否在环的端点上.

但这个做法非常麻烦,并且复杂度并不是很优秀.

官网上给出了一种更加巧妙的解法.

我们先把编号$i$变成$n-i$,那么我们现在要求的是以$0$开头,以$1/2/3$结尾的,满足题目里附加条件的数列的数量.

我们设$f[i]$表示以$i$开头$i+1$结尾,值域为$[i,n)$的,满足题目附加条件的数列的数量.

同时我们设$g[i]$表示以$i+1$开头$i$结尾,值域为$[i,n)$的,满足题目附加条件的数列的数量.

看上去似乎完全不能转移.

我们先考虑$n$较小的情况,这时候我们可以通过搜索求出$f$数组和$g$数组.具体的过程大概是先确定头尾,然后不断往中间插入数字知道填满整个数列为止.

这个过程可以记忆化,如果我们发现这个数列两端的数的差为$1$,那么我们可以在此停止搜索.

好的让我们来看看搜出的是什么东西.

![盗一张图](https://images2018.cnblogs.com/blog/1180874/201804/1180874-20180413200840344-1061677236.png)

于是有$f[i]=g[i+1]+g[i+2]+g[i+4]+g[i+5]$

因为$f$和$g$的状态设计是对称的所以$g[i]=f[i+1]+f[i+2]+f[i+4]+f[i+5]$

要注意的是这个式子只在$i\le n-8$的时候成立,对于$i$更大的情况是需要真的去搜的.

现在我们需要分别统计以$1/2/3$结尾的数列的数量$Ans_1/Ans_2/Ans_3$,显然$Ans_1=f[0]$,至于$Ans_2$和$Ans_3$,我们手玩一下.

![](https://images2018.cnblogs.com/blog/1180874/201804/1180874-20180413200947514-1059687436.png)
![](https://images2018.cnblogs.com/blog/1180874/201804/1180874-20180413201025449-801614152.png)

好的那么$Ans_2=f[1]+f[3]+f[4]$

$Ans_3=f[2]+f[4]+f[5]+g[3]+g[4]$

复杂度$O(n)$,代码难度不大.

```
#include<bits/stdc++.h>
#define read() Read<int>()
namespace pb_ds{   
    namespace io{
        const int MaxBuff=1<<15;
        const int Output=1<<23;
        char B[MaxBuff],*S=B,*T=B;
		#define getc() ((S==T)&&(T=(S=B)+fread(B,1,MaxBuff,stdin),S==T)?0:*S++)
        char Out[Output],*iter=Out;
        inline void flush(){
            fwrite(Out,1,iter-Out,stdout);
            iter=Out;
        }
    }
    template<class Type> inline Type Read(){
        using namespace io;
        register char ch;
        register Type ans=0; 
        register bool neg=0;
        while(ch=getc(),(ch<'0' || ch>'9') && ch!='-');
        ch=='-'?neg=1:ans=ch-'0';
        while(ch=getc(),'0'<= ch && ch<='9') ans=ans*10+ch-'0';
        return neg?-ans:ans;
    }
    template<class Type> inline void Print(register Type x,register char ch='\n'){
        using namespace io;
        if(!x) *iter++='0';
        else{
            if(x<0) *iter++='-',x=-x;
            static int s[100]; 
            register int t=0;
            while(x) s[++t]=x%10,x/=10;
            while(t) *iter++='0'+s[t--];
        }
        *iter++=ch;
    }
}
using namespace pb_ds;
using namespace std;
typedef long long ll;
const int N=1e6+5;
const int Mod=1e9+7;
inline void ad(int &x,int y){
	x+=y;
	if (x>=Mod) x-=Mod;
}
int n,m,k,ans;
int f[N],g[N];
bool a[N][7],vis[N];
#define chk(x,y) (!a[(x)][(y)-(x)+3])
namespace sub2{
	int tot,ans;
	int p[N];
	inline void work(){
		ans=2;
		for (int i=1;i<=n;++i){
			if (i&1) p[(i+1)>>1]=n-i;
			else p[n-(i>>1)+1]=n-i;
		}
		p[0]=p[n],p[n+1]=p[1];
		for (int i=1;i<=n;++i)
			if (!chk(p[i],p[i+1])){
				--ans;
				break;
			}
		for (int i=1;i<=n;++i)
			if (!chk(p[i],p[i-1])){
				--ans;
				break;
			}
		printf("%d\n",ans);
		exit(0);
	}
}
int dfs(int las,int t,int len,int pos,int mn){
	if (pos==len){
		if (abs(las-t)<=3 && chk(las,t)) return 1;
		return 0;
	}
	int res=0;
	for (int i=max(mn+1,las-3);i<=min(n-1,las+3);++i){
		if (!vis[i] && chk(las,i)){
			vis[i]=1;
			res+=dfs(i,t,len,pos+1,mn);
			vis[i]=0;
		}	
	}
	return res;
}
inline int get_val(int s,int t){
	vis[s]=vis[t]=1;
	int k=min(s,t);
	int res=dfs(s,t,n-k,2,k);
	vis[s]=vis[t]=0;
	return res;
}
int main(){
	n=read(),m=read(),k=read();
	for (int i=1;i<=m;++i){
		int u=n-read(),v=n-read();
		if (abs(u-v)<=k) a[u][v-u+3]=1;
	}
	if (n==1) return puts("1"),0;
	if (!k) return puts("0"),0;
	if (n==2) return puts(m?"0":"1"),0;
	if (k==1) return puts("0"),0;
	if (k==2) sub2::work();
	if (n<=7){
		if (chk(1,0)) ad(ans,get_val(0,1));
		if (chk(2,0)) ad(ans,get_val(0,2));
		if (n>=4 && chk(3,0)) ad(ans,get_val(0,3));
		printf("%d\n",ans);
		return 0;
	}
	for (int i=n-1;n-i<=7 && ~i;--i){
		g[i]=get_val(i+1,i);
		f[i]=get_val(i,i+1);
	}	
	for (int i=max(-1,n-8);~i;--i){
		f[i]=g[i]=0;
		if (chk(i,i+2)) ad(f[i],g[i+1]);
		if (chk(i,i+3)){
			if (chk(i+2,i+1)) ad(f[i],g[i+2]);
			if (chk(i+4,i+1)){
				if (chk(i+3,i+2) && chk(i+2,i+5)) ad(f[i],g[i+4]);
				if (chk(i+3,i+6) && chk(i+5,i+2) && chk(i+2,i+4)) ad(f[i],g[i+5]);
			}
		}
		if (chk(i+2,i)) ad(g[i],f[i+1]);
		if (chk(i+3,i)){
			if (chk(i+1,i+2)) ad(g[i],f[i+2]);
			if (chk(i+1,i+4)){
				if (chk(i+2,i+3) && chk(i+5,i+2)) ad(g[i],f[i+4]);
				if (chk(i+6,i+3) && chk(i+2,i+5) && chk(i+4,i+2)) ad(g[i],f[i+5]);
			}
		}
	}
	if (chk(1,0)) ad(ans,f[0]);
	if (chk(2,0)){
		if (chk(0,1)) ad(ans,f[1]);
		if (chk(0,3)){
			if (chk(4,1) && chk(1,2)) ad(ans,f[3]);
			if (chk(3,1) && chk(1,4) && chk(5,2)) ad(ans,f[4]);
		}
	}
	if (chk(3,0)){
		if (chk(0,1)){
			if (chk(1,2)) ad(ans,f[2]);
			if (chk(1,4)){
				if (chk(5,2) && chk(2,3)) ad(ans,f[4]);
				if (chk(4,2) && chk(2,5) && chk(6,3)) ad(ans,f[5]);
			}	
		}
		if (chk(0,2)){
			if (chk(2,1) && chk(1,4)) ad(ans,g[3]);
			if (chk(2,5) && chk(4,1) && chk(1,3)) ad(ans,g[4]);
		}	
	}
	printf("%d\n",ans);
	return 0;
}




---

## 作者：Hunter_Will (赞：7)

poi的众多好题之一，可惜洛谷的数据有点弱，可能是自己造的。拿到这道题，一看0<=p<=3，分类讨论吧。
- 当p=0时，显然除了n=1的答案是1之外其它答案都是0，因为无论如何编号至少差1。
- 当p=1时，显然只有n=1或(n=2且k=0)时答案为1,其它都是0，因为其它方案第n-1个数与n的编号差至少为2。
- 当p=2时，我们来画画看，首先是一个n，然后第一个位置可以填n-1或是n-2，假设它填了n-1,那么第n-1个位置只能填n-2,第二个位置只能填n-3，第n-2个位置只能填n-4……

		n
     n-2 n-1
     
     n-4 n-3
     
     n-6 n-5
     
     ...
     
	依次构造，并判断是否满足限制关系即可。
- 当p=3时，每个位置就不只有两种选择了，既然涉及到选择，就应该想到dp，怎么dp呢？常规的方法似乎无从下手，如果从位置上考虑的话，每次要同时转移两个位置，看起来不可行。从编号上考虑呢？我们从n到1依次考虑这n个元素，不断扩大环的大小。n显然放下就行了，n-1放在环的另一侧，此时n和n-1有之间有两个空位可以接着放东西，接着再将n-2放在环里，此时有两种方案，对应的顺序是不一样的，此时有3个位置可以放，每放入一个元素x时，只用考虑x+1，x+2，x+3这三个元素周围可以放的位置就可以了，我们用3位二进制数表示x+1和x+2中是否有空位，x+1和x+3是否有空位，以及x+2和x+3之间是否有空位。注意只是记录之间是否有空位，不考虑中间有没有其它元素。因为需要考虑限制关系，所以我们还得知道x+1,x+2,x+3的顺序。我们另开一维0/1表示是否是逆时针顺序。转移方程比较复杂，主要靠手动分类讨论，还是画图比较好理解。![](https://cdn.luogu.com.cn/upload/pic/17863.png )

- 后面的第三个状态为三位二进制数，x代表上一个状态中x+1和x+2之间是否有空位，这里自己画一画图就行了。左边的红线为当前可以放的位置，左下被洛谷的水印挡住了，勉强看吧。

代码：
```cpp
#include<iostream>
#include<cstdio>

using namespace std;

#define maxn 1000010
#define abs(i) ((i)>=0?(i):-(i))
const int mod=1e9+7;
int n,ki,pi,dp[maxn][2][8],cha[maxn][7];

inline int readin(){
    int x=0,s=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')s=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*s;
}

inline void solve0(){
    if(n==1)puts("1");
    else puts("0");
}

inline void solve1(){
    if(n==1)puts("1");
    else if(n==2&&!ki)puts("1");
    else puts("0");
}

inline bool ck(int x,int y){//can x be the right of y
    //cerr<<x<<' '<<y<<endl;
    if(abs((x-y))>pi)return false;
    if(cha[y][x-y+3])return false;
    return true;
}

inline void solve2(){
    int ans=0,ok=1;
    if(n==1){puts("1");return;}
    else if(n==2){
    	if(!ki)puts("1");
    	else puts("0");
    	return;
    }
    if(ck(n,n-1)&&ck(n-2,n)){
    	if(n==3)ok=ck(n-1,n-2);
    	for(int i=2,j=n-2;i<=j;++i,--j){
        	if(!ck(n-((i-2)<<1|1),n-((i-1)<<1|1))){ok=0;break;}
        	if(!ck(n-((n-j)<<1),n-((n-j-1)<<1))){ok=0;break;}
        	if(i==j){
        		if(!ck(n-((i-1)<<1|1),n-((n-j-1)<<1)))ok=0;
        		break;
        	}
        	if(j==i+1){
        		if(!ck(n-((i-1)<<1|1),n-((n-j)<<1)))ok=0;
        		break;
        	}
    	}
    	ans+=ok;ok=1;
    }
    if(ck(n,n-2)&&ck(n-1,n)){
    	if(n==3)ok=ck(n-2,n-1);
    	for(int i=2,j=n-2;i<=j;++i,--j){
        	if(!ck(n-((i-1)<<1),n-(i<<1))){ok=0;break;}
        	if(!ck(n-((n-j-1)<<1|1),n-((n-j-2)<<1|1))){ok=0;break;}
        	if(i==j){
        		if(!ck(n-((i-1)<<1),n-((n-j-1)<<1|1)))ok=0;
        		break;
        		}
        	if(j==i+1){
        		if(!ck(n-(i<<1),n-((n-j-1)<<1|1)))ok=0;
        		break;
        	}
    	}
    	ans+=ok;ok=1;
    }
    printf("%d\n",ans);
}

inline bool jg(int x,int s,int j,int k){
    bool s1=j&4,s2=j&2,s3=j&1;
    if(!s){
    if(k==0)
        return ((s2||ck(x+1,x+3))&&(s3||ck(x+3,x+2)));
    else if(k==1)
        return ((s3||ck(x+3,x+2))&&ck(x,x+3));
    else if(k==2)
        return ((s2||ck(x+1,x+3))&&ck(x+3,x));
    }
    else{
    if(k==0)
        return ((s2||ck(x+3,x+1))&&(s3||ck(x+2,x+3)));
    else if(k==1)
        return ((s3||ck(x+2,x+3))&&ck(x+3,x));
    else if(k==2)
        return ((s2||ck(x+3,x+1))&&ck(x,x+3));
    }
}

inline bool exjg(int x,int s,int j,int k){
    if(x>1)return true;
    bool s1=j&4;
    if(!s){
    if(k==0)
        return (ck(x,x+1)&&ck(x+2,x));
    else if(k==1)
        return (ck(x+1,x)&&(s1||ck(x+2,x+1)));
    else if(k==2)
        return (ck(x,x+2)&&(s1||ck(x+2,x+1)));
    }
    else{
    if(k==0)
        return (ck(x,x+2)&&ck(x+1,x));
    else if(k==1)
        return (ck(x,x+1)&&(s1||ck(x+1,x+2)));
    else if(k==2)
        return (ck(x+2,x)&&(s1||ck(x+1,x+2)));
    }
}

inline void calc(int i,int s,int j){
    int sig=bool(j&4);
    //12
    if(!sig&&jg(i-1,s,j,0)&&exjg(i-1,s,j,0))
    	dp[i-1][s^1][1]=(dp[i-1][s^1][1]+dp[i][s][j])%mod;
    //13
    if(!(j&2)&&jg(i-1,s,j,1)&&exjg(i-1,s,j,1))
    	dp[i-1][s][2|sig]=(dp[i-1][s][2|sig]+dp[i][s][j])%mod;
    //23
    if(!(j&1)&&jg(i-1,s,j,2)&&exjg(i-1,s,j,2))
    	dp[i-1][s][4|sig]=(dp[i-1][s][4|sig]+dp[i][s][j])%mod;
}

inline void solve3(){
    int ans=0;
    if(n==1){puts("1");return;}
    else if(n==2){
    	if(!ki)puts("1");
    	else puts("0");
    	return;
    }
    dp[n-2][0][0]=1;
    dp[n-2][1][0]=1;
    for(int i=n-2;i>1;--i)
    	for(int j=0;j<8;++j){
        	if(dp[i][0][j])
        		calc(i,0,j);
        	if(dp[i][1][j])
        		calc(i,1,j);
    	}
    for(int i=0;i<8;++i)ans=((ans+dp[1][0][i])%mod+dp[1][1][i])%mod;
    printf("%d\n",ans);
}

int main(){
    n=readin();ki=readin();pi=readin();
    for(int i=1,x,y;i<=ki;++i){
    	x=readin();y=readin();
    	if(abs((x-y))<=pi)
    	    cha[x][y-x+3]=1;
   	}
    if(pi==0)solve0();
    else if(pi==1)solve1();
    else if(pi==2)solve2();
    else solve3();
    return 0;
}

```

---

## 作者：pikiuk (赞：6)

非常好做法，爱来自 dx。

考虑按值域从小到大插入数字，注意到任意时刻序列都需要满足任意相邻对的极差小于等于 $p$。

优化这一做法，注意到我们只关心当前我们可以插入的相邻对具体有哪些，记为二元集合 $\{(u,v)\}$。

注意到我们只关心当前填入的数字 $x$ 和 $(u,v)$ 的大小关系，进一步的，若两个状态满足 $\{(x-u,x-v)\}$，那么他们的转移也是相等的。

建出自动机，在 $p\leq 3$ 的情况下状态数只有 $14$，做自动机上动态规划即可，注意在转移和统计答案时要判断 $\{(u,v)\}$ 是否被禁止。

这种做法的优势是具有扩展性且不需要对细节有太多的特殊处理。

---

## 作者：Alex_Eon (赞：6)

### Change log
- 2023.10.25 修改少量 MarkDown 的使用。

#### [$\color{blueviolet}\text{POI 套题集合（点我）}$](https://www.cnblogs.com/Eon-Sky/p/17710718.html)
#### [$\color{red}\text{博客内食用效果更佳（点我）}$](https://www.luogu.com.cn/blog/Ksy/solution-p3581)

### 时间复杂度：$O(n)$
### 完整思路

观察到 $p$ 的范围很小，我们尝试进行分类讨论。

---

当 $p=0$：  
显著地，当且仅当 $n=1$ 时答案为 $1$，剩余情况为 $0$。

---

当 $p=1$：  
同样显著地，此时当且仅当 $n=1\lor(n=2\land k=0)$ 时答案为 $1$，剩余情况为 $0$。

---

当 $p=2$：  
考虑先放置 $n$，它两侧只有可能是 $n-1,n-2$，$n-1$ 旁边只有可能放 $n-3$，$n-2$ 旁边只有可能放 $n-3$，以此类推，这种情况下只有顺时针逆时针两种情况，构造并判断即可。

---

当 $p=3$：  
我们尝试从 $n$ 至 $1$ **依次放进环内**，考虑当前放置到编号为 $i$ 的，显然它只能和 $i+1,i+2,i+3,i-1,i-2,i-3$ 相邻，我们只需要考虑 $i+1,i+2,i+3$，它们都在环内，而 $i-1,i-2,i-3$ 的情况会在放入它们的时候考虑。

我们现在考虑两个问题：
- $i+1,i+2,i+3$ 两两之间可能有已经放入的点，在此种情况中我们无法将 $i$ 插入到这种位置，因为这显著是不合法的。
- 当我们放入 $i$ 后，$i+3$ 不能和接下来要放入的点相邻，这就意味着 $i+3$ 一定要紧挨着两边的点，我们需要判断此时 $i+3$ 的状态。（这种情况会产生上一个问题，可以理解为 $i+3$ 与两边合并，使这一段不能放置接下来的东西）。

现在给出以下约定方便表述：

- $i+1,i+2$ 之间为位置 $1$，$i+2,i+3$ 之间为位置 $2$，$i+3,i+1$ 之间为位置 $3$。
- 设 DP 状态 $f_{i,j,st}$ 表示放置完编号 $i$ 的东西，是否是逆时针（$j$），$i+1,i+2,i+3$ 之间的位置状态为 $st$（对位置 $1,2,3$ 状态进行状压，分别对应 $1,2,4$）。
-  $\mathrm{sit}(x,y)$ 表示 $x$ 是否能坐在 $y$ 右侧，合法为 $1$，不合法为 $0$。
- $1\in st$ 表示位置 $1$ 在当前状态中是可行的，其他表达同理。

对于状态 $f_{i+1,j,st}$ 我们尝试向下转移。

**若位置 $1$ 可放置**（以下讨论均基于顺时针，逆时针只需要将所有状态置反即可）：

$i+3$ 需要和 $i+1,i+2$ 合并，两者合并当且仅当两者之间已经有其他东西或两者可以相邻，我们可以得到以下约束。

$$\left(2\notin st\lor\mathrm{sit}(i+2,i+3)\right)\land\left(3\notin st\lor\mathrm{sit}(i+3,i+1)\right)$$

放置到位置 $1$ 后我们的状态变为 $f_{i,j\oplus1,5}$（首先这种放置显著会改变顺逆状态，其次这种放置状态下使得 $i,i+1$ 以及 $i,i+2$ 之间的空位可用。），可以得到以下转移。

$$f_{i,j\oplus1,\{1,3\}}=f_{i,j\oplus1,\{1,3\}}+f_{i+1,j,st}$$

**若位置 $2$ 可放置**：

得到以下约束以及转移。

$$\mathrm{sit}(i,i+3)\land\left(2\notin st\lor\mathrm{sit}(i+2,i+3)\right)$$

设 $st'$ 表示改变后的状态，若 $1\in st$，则 $st'=\{2,3\}$，否则 $st'=\{3\}$。 

$$f_{i,j,st'}=f_{i,j,st'}+f_{i+1,j,st}$$

**若位置 $3$ 可放置**：

得到以下约束以及转移。

$$\mathrm{sit}(i+3,i)\land\left(3\notin st\lor\mathrm{sit}(i+3,i+1)\right)$$

设 $st'$ 表示改变后的状态，若 $1\in st$，则 $st'=\{1,2\}$，否则 $st'=\{1\}$。

$$f_{i,j,st'}=f_{i,j,st'}+f_{i+1,j,st}$$

---

大部分转移已经讨论完毕，最后一层还需约束放置完的左右关系，与上述约束、转移类似，就不进行冗杂的讨论了。

### 代码实现需要注意的地方：
- 别忘记取模。
- 对于初值有 $f_{n-2,0,7}=1,f_{n-2,1,7}=1$。

### 参考代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define UN unsigned
using namespace std;
//--------------------//
const int N=1e6+5,Mod=1e9+7;

int n,k,p,f[N][2][8];
bool ht[N][10];
void add(int &x,int y){x+=y,x-=((x>=Mod)?Mod:0);}//优化取模
bool sit(int x,int y){return abs(x-y)<=p&&!ht[y][y-x+3];}//判断是否能坐在右面
bool ck1(int i,int j,int st,int pos)//判断是否合法
{
	if(j)
	{
		if(pos==1)
			return ((!(st&4)||sit(i+3,i+1))&&(!(st&2)||sit(i+2,i+3)));
		if(pos==2)
			return (sit(i,i+3)&&(!(st&4)||sit(i+3,i+1)));
		return (sit(i+3,i)&&(!(st&2)||sit(i+2,i+3)));
	}
	if(pos==1)
		return (!(st&4)||sit(i+1,i+3))&&(!(st&2)||sit(i+3,i+2));
	if(pos==2)
		return (sit(i+3,i)&&(!(st&4)||sit(i+1,i+3)));
	return (sit(i,i+3)&&(!(st&2)||sit(i+3,i+2)));
}
bool ck2(int i,int j,int st,int pos)//判断 i=1 时是否合法
{
	if(i>1)
		return true;
	if(j)
	{
		if(pos==1)
			return (sit(1,3)&&sit(2,1));
		if(pos==2)
			return (sit(3,1)&&(!(st&1)||sit(2,3)));
		return (sit(1,2)&&(!(st&1)||sit(2,3)));
	}
	if(pos==1)
		return (sit(3,1)&&sit(1,2));
	if(pos==2)
		return (sit(1,3)&&(!(st&1)||sit(3,2)));
	return (sit(2,1)&&(!(st&1)||sit(3,2)));
}
//--------------------//
int main()
{
    scanf("%d%d%d",&n,&k,&p);
    for(int x,y,i=1;i<=k;i++)
    {
        scanf("%d%d",&x,&y);
        if(abs(x-y)<=p)
            ht[x][x-y+3]=true;
    }
    if(p==0)//分讨
    {
        if(n==1)
            printf("1");
        else
            printf("0");
        return 0;
    }
    if(p==1)
    {
        if(n==1||(n==2&&k==0))
            printf("1");
        else
            printf("0");
        return 0;
    }
	if(n==1)
		printf("1");
	if(n==2)
		printf("%d",k?0:1);
	if(n<3)
		return 0;
    if(p==2)
    {
        int ans=0;
        //顺时针
        bool flag=((!sit(n-1,n))|((n&1)&&!sit(1,2))|((!(n&1))&&!sit(2,1)));
        for(int i=n-1;i>2;i-=2)
            flag|=!sit(i-2,i);
        for(int i=n-2;i>2;i-=2)
            flag|=!sit(i,i-2);
        //逆时针
        ans+=!flag,flag=((!sit(n,n-1))|((n&1)&&!sit(2,1))|((!(n&1))&&!sit(1,2)));
        for(int i=n-1;i>2;i-=2)
            flag|=!sit(i,i-2);
        for(int i=n-2;i>2;i-=2)
        	flag|=!sit(i-2,i);
        ans+=!flag;
        printf("%d",ans);
        return 0;
    }
	f[n-2][0][7]=f[n-2][1][7]=1;
	for(int i=n-2;i>=2;i--)//倒序转移
	{
		for(int j=0;j<=1;j++)
		{
			for(int st=0;st<=7;st++)
			{
				if(!f[i][j][st])
					continue;
				if((st&1)&&ck1(i-1,j,st,1)&&ck2(i-1,j,st,1))
					add(f[i-1][j^1][5],f[i][j][st]);
				if((st&2)&&ck1(i-1,j,st,2)&&ck2(i-1,j,st,2))
					add(f[i-1][j][4|((st&1)<<1)],f[i][j][st]);
				if((st&4)&&ck1(i-1,j,st,3)&&ck2(i-1,j,st,3))
					add(f[i-1][j][1|((st&1)<<1)],f[i][j][st]);
			}
		}
	}
	int ans=0;
	for(int i=0;i<=7;i++)//统计答案
		add(ans,f[1][0][i]),add(ans,f[1][1][i]);
	printf("%d",ans);
    return 0;
}
```

---

## 作者：262620zzj (赞：0)

# L<3

$L=0,1$ 简单特判，$L=2$ 发现 $1$ 两侧必须是 $2,3$，$2$ 的旁边只剩 $4$ 可以填，以此类推，最多 $2$ 种可能合法的方案，暴力判断即可。

# L=3

## m=0

我们可以考虑递推计算，每次从 $n-1$ 的排列中找位置插入 $n$，具体而言，发现 $n$ 只能放在 $n-1,n-2,n-3$ 中的两个数中间。而且要求这两个数连续。故可以使用 dp，设 $f(i,j,x,y)$，$1\sim i$ 的排列，$i,i-1,i-2$ 的相对排列顺序是 $j(0\le j\le 5)$，$x=0/1$ 表示三个数的左和中两个数是否相邻，$y=0/1$ 表示三个数的中和右两个数是否相邻，$f$ 值为这种情况的方案数。显然这种方法不重不漏。转移脑子里想还是比较简单的，使用刷表法，每次用一个已知状态更新别的。比如我们现在排列是 $[1,3,5,2,4]$，想插入 $6$ 变成 $[1,3,6,5,2,4]$，那就是 $f(5,\{5-2,5-0,5-1\},1,0)\rightarrow f(6,\{6-0,6-1,6-2\},1,0)$。

实现：枚举前 $4$ 个数的所有可行排列，从 $5$ 开始 dp。然后可以先把三个数的排列映射到 $0\sim 5$，然后预处理出每个 $(j,x,y,z)$ 能转移到什么状态，其中 $z=0/1$ 是将 $n$ 插入到前两个数还是后两个数中间。可做到 $O(n)$。

## 100pts

不能直接在 dp 时限制两个数不能挨着，因为可能暂时是挨着的，之后又插入一个数把他们分开，这实际是合法的。

但是发现放置完 $n$ 后，$n-3$ 及以下的数如果还是和相邻数构成不合法情况，那就已经无法补救了。所以我们只需要在 dp 到 $i$ 时判断 $i-3$ 的所有限制条件，禁止某些转移就行了。最后小小特判下 $n-2,n-1,n$ 这三个数之间的限制即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
constexpr int N=1e6+5,mod=1e9+7;
typedef pair<int,int> pii;
#define fi first
#define se second
pii ab[N];
int n,L,m,pos[N],p[N];
inline int check(int* p,int n){
    if(p[1]!=1)return 0;
    for(int i=1;i<=n;i++)if(abs(p[i]-p[i%n+1])>L)return 0;
    for(int i=1;i<=n;i++)pos[p[i]]=i;
    for(int i=1;i<=m;i++)if(p[pos[ab[i].fi]%n+1]==ab[i].se)return 0;
    return 1;
}
inline int check2(int* p,int n){
    if(p[1]!=1)return 0;
    for(int i=1;i<=n;i++)if(abs(p[i]-p[i%n+1])>L)return 0;
    for(int i=1;i<=n;i++)pos[p[i]]=i;
    for(int i=1;i<=m;i++){
        if(ab[i].fi>4||ab[i].se>4)continue;
        if((ab[i].fi==1||ab[i].se==1)&&p[pos[ab[i].fi]%n+1]==ab[i].se)return 0;
    }
    return 1;
}
ll f[6][2][2],g[6][2][2];
typedef array<int,3> arr;
map<arr,int> mp1;
arr mp2[6];
vector<pii> no[N];
arr tran[6][2][2][2];
bool _01[2],_02[2],_12[2];
int main(){
    // freopen("classical3.in","r",stdin);
    // freopen("classical.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>L;
    for(int i=1;i<=m;i++)cin>>ab[i].fi>>ab[i].se;
    if(L==0){
        if(n==1)p[1]=1,cout<<check(p,n);
        else cout<<0;
        return 0;
    }
    if(L==1){
        if(n<=2)iota(p+1,p+1+n,1),cout<<check(p,n);
        else cout<<0;
        return 0;
    }
    if(L==2){
        p[1]=1;
        for(int i=2;i<=n;i++){
            if(i%2)p[i/2+1]=i;
            else p[n-i/2+1]=i;
        }
        int ans=check(p,n);
        reverse(p+2,p+1+n);
        if(n>2)ans+=check(p,n);
        cout<<ans;
        return 0;
    }
    if(n<=4){
        iota(p+1,p+1+n,1);
        int ans=0;
        do{
            ans+=check(p,n);
        }while(next_permutation(p+2,p+1+n));
        cout<<ans;
        return 0;
    }
    mp1[{0,1,2}]=0,mp2[0]={0,1,2};
    mp1[{0,2,1}]=1,mp2[1]={0,2,1};
    mp1[{1,0,2}]=2,mp2[2]={1,0,2};
    mp1[{1,2,0}]=3,mp2[3]={1,2,0};
    mp1[{2,0,1}]=4,mp2[4]={2,0,1};
    mp1[{2,1,0}]=5,mp2[5]={2,1,0};
    for(int i=1;i<=m;i++){
        auto [x,y]=ab[i];
        if(x==y)continue;
        int dir=1;
        if(x>y)swap(x,y),dir=0;
        if(y-x<=3)no[x].push_back({y-x,dir});
        if(x==n-2&&y==n-1)_12[dir]=1;
        if(x==n-2&&y==n)_02[dir]=1;
        if(x==n-1&&y==n)_01[dir]=1;
    }
    memset(p,0,sizeof(p));
    p[1]=1,p[2]=2,p[3]=3,p[4]=4;
    do{
        if(check2(p,4)){
            arr z;int zt=0;
            for(int i=1;i<=4;i++)if(p[i]!=1){
                z[zt++]=4-p[i];
            }
            f[mp1[z]][1][1]++;
        }
    }while(next_permutation(p+2,p+5));
    auto add=[](ll a,ll &b)->void {b=(a+b)%mod;};
    auto write=[](arr x)->void {cout<<x[0]<<" "<<x[1]<<" "<<x[2]<<"\n";};
    for(int j=0;j<=5;j++)for(int x:{0,1})for(int y:{0,1}){
        for(int z:{0,1})if(!z&&x||z&&y){
            arr ar=mp2[j],ra=ar;
            array<int,4> pl;
            int x2,y2,pos2;
            for(int r=0;r<=2;r++)if(ar[r]==2)pos2=r;
            if(z==0){
                if(pos2==0)x2=1,y2=y;
                else if(pos2==1)x2=1,y2=0;
                else x2=y2=1;
            }
            else{
                if(pos2==0)x2=y2=1;
                else if(pos2==1)x2=0,y2=1;
                else x2=x,y2=1;
            }
            for(int r=0;r<=z;r++)pl[r]=ar[r];
            pl[z+1]=-1;
            for(int r=z+2;r<=3;r++)pl[r]=ar[r-1];
            for(int r=0;r<=3;r++)if(pl[r]==2)pos2=r;
            for(int r=0;r<pos2;r++)ra[r]=pl[r];
            for(int r=pos2+1;r<=2;r++)ra[r-1]=pl[r];
            for(int r=0;r<=2;r++)ra[r]++;
            tran[j][x][y][z]={mp1[ra],x2,y2};
            // write(ar),write(ra);cout<<"C\n";
            // cout<<x<<' '<<y<<' '<<z;
            // cout<<' '<<mp1[ra]<<' '<<x2<<' '<<y2<<" B**\n";
        }
    }
    for(int i=5;i<=n;i++){
        memset(g,0,sizeof(g));
        for(int j=0;j<=5;j++){
            for(int x:{0,1})for(int y:{0,1})for(int z:{0,1})if(!z&&x||z&&y){
                auto [ww,x2,y2]=tran[j][x][y][z];
                arr w=mp2[j];
                for(int r:{0,1,2})pos[w[r]]=r;
                // cout<<i<<" "<<j<<" "<<x<<' '<<y<<' '<<z<<", "<<pos[0]<<' '<<pos[1]<<' '<<pos[2];
                // cout<<" G\n";
                bool cont=0;
                for(auto [len,dir]:no[i-3]){
                    // cout<<len<<" "<<dir<<" I\n";
                    if(dir==1){
                        if(len==1){
                            if(pos[2]==0&&pos[1]==1&&z!=0&&x)cont=1;
                            if(pos[2]==1&&pos[1]==2&&z!=1&&y)cont=1;
                        }
                        if(len==2){
                            if(pos[2]==0&&pos[0]==1&&z!=0&&x)cont=1;
                            if(pos[2]==1&&pos[0]==2&&z!=1&&y)cont=1;
                        }
                        if(len==3){
                            if(pos[2]==0&&z==0)cont=1;
                            if(pos[2]==1&&z==1)cont=1;
                        }
                    }
                    else{
                        if(len==1){
                            if(pos[2]==1&&pos[1]==0&&z!=0&&x)cont=1;
                            if(pos[2]==2&&pos[1]==1&&z!=1&&y)cont=1;
                        }
                        if(len==2){
                            if(pos[2]==1&&pos[0]==0&&z!=0&&x)cont=1;
                            if(pos[2]==2&&pos[0]==1&&z!=1&&y)cont=1;
                        }
                        if(len==3){
                            if(pos[2]==1&&z==0)cont=1;
                            if(pos[2]==2&&z==1)cont=1;
                        }
                    }
                }
                if(cont){continue;}
                add(f[j][x][y],g[ww][x2][y2]);
            }
        }
        memcpy(f,g,sizeof(g));
        // for(int j=0;j<=5;j++)for(int x:{0,1})for(int y:{0,1})cout<<i<<" "<<j<<" "<<x<<" "<<y<<" E "<<f[j][x][y]<<"\n";
    }
    if(_12[0])f[0][0][1]=f[0][1][1]=f[3][1][0]=f[3][1][1]=0;
    if(_02[0])f[1][1][0]=f[1][1][1]=f[2][0][1]=f[2][1][1]=0;
    if(_01[0])f[0][1][0]=f[0][1][1]=f[4][0][1]=f[4][1][1]=0;
    if(_12[1])f[1][0][1]=f[1][1][1]=f[5][1][0]=f[5][1][1]=0;
    if(_02[1])f[3][0][1]=f[3][1][1]=f[4][1][0]=f[4][1][1]=0;
    if(_01[1])f[2][1][0]=f[2][1][1]=f[5][0][1]=f[5][1][1]=0;
    ll ans=0;
    for(int j=0;j<=5;j++)for(int x:{0,1})for(int y:{0,1})ans=(ans+f[j][x][y])%mod;
    cout<<ans;
    return 0;
}
```

---


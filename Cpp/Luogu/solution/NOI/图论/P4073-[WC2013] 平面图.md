# [WC2013] 平面图

## 题目描述

在一个平面中有 $n$ 个顶点和 $m$ 条直线段，第 $i$ 个顶点的坐标为 $(x_i, y_i)$， 第 $j$ 条直线段连接顶点 $u_j$ 和顶点 $v_j$，权值为 $h_j$， 除顶点 $u_j$ 和 $v_j$ 外直线段 $j$ 不经过其他的顶点。任意两条直线段如果存在公共点，则该公共点一定是一个顶点，此时这两条直线段都会连接这个顶点。对于任意的两个顶点 $x$ 和 $y$，总是可以找到一顶点序列 $a_1,a_2,\cdots,a_k$ 使得 $a_1=x$，$a_k=y$ 且对于任意 $1\le i< k$ 满足 $a_i$ 和 $a_{i+1}$ 被一条直线段直接连接。

这 $m$ 条直线段将整个平面分成了若干个区域，其中只有一个区域是无穷大的，其余均是有界的，我们称无穷大的区域为禁区。

现在给出 $q$ 次询问，每次给定平面中的任意两个不是顶点且分别不在任意一条直线段上的点 $A$ 和 $B$，请画一条曲线连接 $A$ 和 $B$，要求曲线不能经过禁区以及任何顶点，并使得穿过的直线段中权值最大的尽可能小。你需要对每次询问回答这个值最小为多少。


## 说明/提示

【样例说明】

![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)

【数据规模与约定】

本题共设有 $10$ 个测试点，每个测试点的规模与特征如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)

对于全部数据，均满足 $5$ ≤ $n$, $m$, $q$ ≤ $100,000$，所有直线段的权值不会超过 $10^9$。所有询问坐标均为不超过 $10^7$ 的实数，且保证是 $0.5$ 的整数倍。


## 样例 #1

### 输入

```
9 12
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
1 2 10
2 3 10
3 6 10
6 9 10
9 8 10
8 7 10
7 4 10
4 1 10
2 5 3
5 8 2
5 6 4
4 5 1
3
1.5 1.5 2.5 2.5
1.5 2.5 2.5 1.5
0.5 0.5 1.5 1.5```

### 输出

```
2
3
-1```

# 题解

## 作者：ywy_c_asm (赞：10)

其实如果你对平面图相关的东西非常熟悉的话这题就是个板子题，只要跑个平面图转对偶图，然后对询问的点在平面图上点定位找到所在区域，然后就是Noip货车运输那个题了……在最小生成树上查询最大边权即可。

如果你不会平面图转对偶图的话可以去[这题](https://www.luogu.org/problemnew/show/P3249)的题解里学习一下，这里简单说一下平面图点定位，就是我们希望找到给定点在平面图上所在的区域，这个我们扫描线+平衡树解决。我们知道计算几何里很多东西都是那种相对顺序不改变的，就可以扫描线，这个平面图也是如此。我们把关键点与询问点从左到右排序，然后开一个平衡树维护当前加入的边，这个边我们应该从左指向右，在这条边上存边下面的这个区域编号，就像这样：

![](https://cdn.luogu.com.cn/upload/pic/57929.png)

然后对于这个询问点我们去平衡树上二分它上面的第一条边（如果没有那他在外部区域里），这样就能找了。注意为了避免特殊情况我们需要在平衡树上操作的时候对x加或减一个eps。

另外由于是“插入时的相对顺序不变”，所以在这里不能用懒惰删除的替罪羊树（因为删完了点还留在树上就乱套了……我开始写了个替罪羊树怎么也过不去……）。

上代码~

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cmath>
#define opp(_o) (_o == ch[fa[_o]][1])
using namespace std;
namespace ywy {
	inline int get() {
	    int n = 0;
	    char c;
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            break;
	        if (c == '-')
	            goto s;
	    }
	    n = c - '0';
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 + c - '0';
	        else
	            return (n);
	    }
	s:
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 - c + '0';
	        else
	            return (n);
	    }
	}
	namespace tree {
	typedef struct _b {
	    int dest;
	    int nxt;
	    int len;
	} bian;
	bian memchi[1000001];
	int gn = 1, heads[100001];
	inline void add(int s, int t, int l) {
	    memchi[gn].dest = t;
	    memchi[gn].len = l;
	    memchi[gn].nxt = heads[s];
	    heads[s] = gn;
	    gn++;
	}
	int ance[100001][17], mx[100001][17], deep[100001];
	void dfs(int pt, int baba) {
	    for (register int i = heads[pt]; i; i = memchi[i].nxt) {
	        if (memchi[i].dest == baba)
	            continue;
	        deep[memchi[i].dest] = deep[pt] + 1;
	        ance[memchi[i].dest][0] = pt;
	        mx[memchi[i].dest][0] = memchi[i].len;
	        dfs(memchi[i].dest, pt);
	    }
	}
	inline int lca(int a, int b) {
	    if (deep[a] > deep[b])
	        swap(a, b);
	    int maxn = 0;
	    for (register int i = 16; i >= 0; i--) {
	        if (deep[ance[b][i]] >= deep[a])
	            maxn = max(maxn, mx[b][i]), b = ance[b][i];
	    }
	    if (a == b)
	        return (maxn);
	    for (register int i = 16; i >= 0; i--) {
	        if (ance[a][i] != ance[b][i]) {
	            maxn = max(maxn, max(mx[a][i], mx[b][i]));
	            a = ance[a][i];
	            b = ance[b][i];
	        }
	    }
	    return (max(maxn, max(mx[a][0], mx[b][0])));
	}
	}  // namespace tree
	int ints[100001];
	int find(int n) {
	    if (ints[n] == n)
	        return (n);
	    return (ints[n] = find(ints[n]));
	}
	unsigned char gg[1000001];
	typedef struct _b {
	    int s;
	    int t;
	    int l;
	    friend bool operator<(const _b &a, const _b &b) { return (a.l < b.l); }
	} xiabb;
	xiabb bians[200001];
	double dx;
	typedef struct _n {
	    double k, b;
	    int id;
	    friend bool operator<(const _n &a, const _n &b) { return (a.k * dx + a.b < b.k * dx + b.b); }
	} node;
	int root = 0;
	int ch[1000001][2], fa[1000001];
	node data[1000001];
	int gn = 1;
	inline void xuan(int me) {
	    int tree = fa[me], cjr = fa[tree], op = opp(me), ls = ch[me][op ^ 1];
	    fa[ls] = tree;
	    ch[tree][op] = ls;
	    ch[me][op ^ 1] = tree;
	    if (cjr)
	        ch[cjr][opp(tree)] = me;
	    fa[tree] = me;
	    fa[me] = cjr;
	}
	inline void splay(int tree) {
	    while (fa[tree]) {
	        int cjr = fa[tree];
	        if (fa[cjr])
	            xuan((opp(tree) == opp(cjr)) ? cjr : tree);
	        xuan(tree);
	    }
	}
	void insert_s(int &tree, int me) {
	    if (!tree) {
	        tree = me;
	        return;
	    }
	    insert_s(ch[tree][data[tree] < data[me]], me);
	    fa[ch[tree][data[tree] < data[me]]] = tree;
	}
	inline void insert(node dat) {
	    int me = gn;
	    gn++;
	    data[me] = dat;
	    insert_s(root, me);
	    splay(me);
	    root = me;
	}
	int find(int tree, node dat) {
	    if (dat.k == data[tree].k && dat.b == data[tree].b) {
	        return (tree);
	    }
	    return (find(ch[tree][data[tree] < dat], dat));
	}
	int getmx(int tree) {
	    while (ch[tree][1]) tree = ch[tree][1];
	    return (tree);
	}
	inline void del(node dat) {
	    int me = find(root, dat);
	    splay(me);
	    int ls = ch[me][0], rs = ch[me][1];
	    fa[ls] = 0;
	    fa[rs] = 0;
	    if (!ls) {
	        root = rs;
	        return;
	    }
	    ls = getmx(ls);
	    splay(ls);
	    fa[rs] = ls;
	    ch[ls][1] = rs;
	    root = ls;
	}
	double x[100001], y[100001];
	typedef struct _b_t {
	    int s;
	    int t;
	    int id;
	    friend bool operator<(const _b_t &a, const _b_t &b) {
	        return (atan2(y[a.t] - y[a.s], x[a.t] - x[a.s]) < atan2(y[b.t] - y[b.s], x[b.t] - x[b.s]));
	    }
	} bian_t;
	vector<bian_t> vec[100001];
	int vid[200001];
	int anss[200001];
	typedef struct _pt {
	    double x;
	    double y;
	    unsigned char gj;
	    int id;
	    friend bool operator<(const _pt &a, const _pt &b) {
	        if (a.x != b.x)
	            return (a.x < b.x);
	        return (a.gj > b.gj);
	    }
	} pt;
	pt pts[1000001];
	int val[100001], bel[200001], ss[200001], ts[200001];
	inline double cross(double x1, double y1, double x2, double y2) { return (x1 * y2 - x2 * y1); }
	int getnxt(int tree, double y) {
	    if (!tree)
	        return (0);
	    if (data[tree].k * dx + data[tree].b > y) {
	        int cjr = getnxt(ch[tree][0], y);
	        if (cjr)
	            return (cjr);
	        return (tree);
	    }
	    return (getnxt(ch[tree][1], y));
	}
	void ywymain() {
	    tree::deep[0] = -1;
	    int n = get(), m = get();
	    for (register int i = 1; i <= n; i++) x[i] = get(), y[i] = get(), ints[i] = i;
	    for (register int i = 1; i <= m; i++) {
	        int s = get(), t = get(), l = get();
	        val[i] = l;
	        bian_t cjr;
	        cjr.s = s;
	        cjr.t = t;
	        cjr.id = i;
	        vec[s].push_back(cjr);
	        cjr.s = t;
	        cjr.t = s;
	        cjr.id = i + m;
	        vec[t].push_back(cjr);
	        ss[i] = s;
	        ts[i] = t;
	        ss[i + m] = t;
	        ts[i + m] = s;
	    }
	    for (register int i = 1; i <= n; i++) sort(vec[i].begin(), vec[i].end());
	    for (register int i = 1; i <= n; i++) {
	        for (register int j = 0; j < vec[i].size(); j++) vid[vec[i][j].id] = j;
	    }
	    int gpt = 1;
	    int rt = 0;
	    for (register int i = 1; i <= m * 2; i++) {
	        if (bel[i])
	            continue;
	        int me = gpt;
	        gpt++;
	        double s = 0;
	        int cur = i;
	        do {
	            s += cross(x[ts[cur]] - x[ss[cur]], y[ts[cur]] - y[ss[cur]], x[ts[cur]], y[ts[cur]]);
	            bel[cur] = me;
	            cur = vec[ts[cur]][(vid[(cur > m) ? (cur - m) : (cur + m)] + vec[ts[cur]].size() - 1) %
	                               vec[ts[cur]].size()]
	                      .id;
	        } while (cur != i);
	        if (s >= 0)
	            rt = me;
	    }
	    int ptr = 1;
	    for (register int i = 1; i <= m; i++) {
	        if (bel[i] == rt || bel[i + m] == rt)
	            continue;
	        bians[ptr].s = bel[i];
	        bians[ptr].t = bel[i + m];
	        bians[ptr].l = val[i];
	        ptr++;
	    }
	    sort(bians + 1, bians + ptr);
	    for (register int i = 1; i < ptr; i++) {
	        int aa = find(bians[i].s), ab = find(bians[i].t);
	        if (aa == ab)
	            continue;
	        ints[aa] = ab;
	        tree::add(bians[i].s, bians[i].t, bians[i].l);
	        tree::add(bians[i].t, bians[i].s, bians[i].l);
	    }
	    for (register int i = 1; i < gpt; i++)
	        if (ints[i] == i)
	            tree::dfs(i, 0);
	    for (register int i = 1; i <= 16; i++) {
	        for (register int j = 1; j < gpt; j++) {
	            tree::ance[j][i] = tree::ance[tree::ance[j][i - 1]][i - 1];
	            tree::mx[j][i] = max(tree::mx[j][i - 1], tree::mx[tree::ance[j][i - 1]][i - 1]);
	        }
	    }
	    ptr = 1;
	    for (register int i = 1; i <= n; i++) {
	        pts[ptr].x = x[i];
	        pts[ptr].y = y[i];
	        pts[ptr].id = i;
	        pts[ptr].gj = 1;
	        ptr++;
	    }
	    int q = get();
	    for (register int i = 1; i <= q; i++) {
	        double x1, y1, x2, y2;
	        scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
	        pts[ptr].x = x1;
	        pts[ptr].y = y1;
	        pts[ptr].gj = 0;
	        pts[ptr].id = i;
	        ptr++;
	        pts[ptr].x = x2;
	        pts[ptr].y = y2;
	        pts[ptr].gj = 0;
	        pts[ptr].id = i + q;
	        ptr++;
	    }
	    sort(pts + 1, pts + ptr);
	    for (register int i = 1; i < ptr;) {
	        int cjr = i;
	        while (cjr < ptr && pts[cjr].x == pts[i].x) cjr++;
	        for (register int j = i; j < cjr; j++) {
	            if (!pts[j].gj)
	                break;
	            for (register int k = 0; k < vec[pts[j].id].size(); k++) {
	                bian_t tmp = vec[pts[j].id][k];
	                if (x[tmp.t] >= x[tmp.s])
	                    continue;
	                dx = pts[i].x - 0.00001;
	                node t;
	                t.k = (y[tmp.t] - y[tmp.s]) / (x[tmp.t] - x[tmp.s]);
	                t.b = y[tmp.t] - x[tmp.t] * t.k;
	                t.id = bel[tmp.id];
	                del(t);
	            }
	        }
	        for (register int j = i; j < cjr; j++) {
	            if (!pts[j].gj)
	                break;
	            for (register int k = 0; k < vec[pts[j].id].size(); k++) {
	                bian_t tmp = vec[pts[j].id][k];
	                if (x[tmp.t] <= x[tmp.s])
	                    continue;
	                dx = pts[i].x + 0.00001;
	                node t;
	                t.k = (y[tmp.s] - y[tmp.t]) / (x[tmp.s] - x[tmp.t]);
	                t.b = y[tmp.s] - x[tmp.s] * t.k;
	                t.id = bel[(tmp.id > m) ? (tmp.id - m) : (tmp.id + m)];
	                insert(t);
	            }
	        }
	        for (register int j = i; j <= cjr; j++) {
	            if (pts[j].gj)
	                continue;
	            dx = pts[j].x + 0.00001;
	            int nx = getnxt(root, pts[j].y);
	            if (!nx) {
	                anss[pts[j].id] = rt;
	                continue;
	            }
	            anss[pts[j].id] = data[nx].id;
	        }
	        i = cjr;
	    }
	    for (register int i = 1; i <= q; i++) {
	        int s = anss[i], t = anss[i + q];
	        if (find(s) != find(t)) {
	            printf("-1\n");
	            continue;
	        }
	        if (s == rt && t == rt) {
	            printf("-1\n");
	            continue;
	        }
	        printf("%d\n", tree::lca(s, t));
	    }
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：zhengrunzhe (赞：8)

现有题解都是树上倍增的，提供一个kruskal重构树的做法

所有出边按辐角排序，做个平面图转对偶图

然后kruskal重构树

询问就平衡树扫描线平面图点定位，对于同个询问(s,t)，扫到s就记下s所在的域在对偶图上的点p，扫到t就定位点q，答案是重构树上lca(p,q)的点权

我选择树剖lca
```cpp
#include<set>
#include<cmath>
#include<cstdio>
#include<vector>
#include<algorithm>
using std::set;
using std::pair;
using std::sort;
using std::vector;
using std::make_pair;
using std::lower_bound;
template<class type>inline const type max(const type &a,const type &b)
{
	return a>b?a:b;
}
typedef long long ll;
typedef double dbl;
const int N=1e5+10;
const dbl eps=1e-10;
struct Point
{
	int x,y;
	inline Point(const int &x=0,const int &y=0):x(x),y(y){}
	inline const bool operator==(const Point &p)const
	{
		return x==p.x&&y==p.y;
	}
}p[N];
struct Vector
{
	int x,y;
	inline Vector(const int &x=0,const int &y=0):x(x),y(y){}
	inline Vector(const Point &a=0,const Point &b=0):x(b.x-a.x),y(b.y-a.y){}
	inline const dbl Radial_Angle()
	{
		return atan2(1.0*y,1.0*x);
	}
	inline const bool operator<(Vector v)
	{
		return Radial_Angle()<v.Radial_Angle();
	}
	inline const bool operator==(Vector v)
	{
		return fabs(Radial_Angle()-v.Radial_Angle())<=eps;
	}
	inline const ll operator*(const Vector &v)const
	{
		return (ll)x*v.y-(ll)y*v.x;
	}
};
bool aspect;
struct Edge
{
	int w,id,s,t;
	inline Edge(const int &s=0,const int &t=0,const int &w=0,const int &id=0):s(s),t(t),w(w),id(id){}
	inline const bool operator<(const Edge &e)const
	{
		if (aspect)return w<e.w;
		Vector v1(p[s],p[t]),v2(p[e.s],p[e.t]);
		if (v1==v2)return t<e.t;
		return v1<v2;
	}
}e[N<<1],d[N];
int nowx;
struct Radial
{
	Point s;
	dbl k;
	inline Radial(const Point &s,const dbl &k=0.0):s(s),k(k){}
	inline Radial(const Point &s=0,const Point &t=0):s(s),k(1.0*(s.y-t.y)/(s.x-t.x)){}
	inline const bool operator<(const Radial &l)const
	{
		if (s==l.s)return k<l.k;
		int x=max(s.x,l.s.x);
		return s.y+(x-s.x)*k<l.s.y+(x-l.s.x)*l.k;
	}
};
struct scan
{
	int opt,x,id;
	Radial l;
	inline scan(const int &opt=0,const int &x=0,const int &id=0,const Radial &l=Radial(0,0)):x(x),opt(opt),l(l),id(id){}
	inline const bool operator<(const scan &s)const
	{
		if (x^s.x)return x<s.x;
		return opt<s.opt;
	}
}o[N<<2];
typedef set<pair<Radial,int> >sri;
typedef vector<Edge>veg;
typedef vector<int>vit;
sri s;
veg g[N];
vit t[N<<1];
int n,m,q,ans[N],edc=1,next[N<<1],pos[N<<1],outside,dualn,dualm,treen,w[N<<1],cnt;
inline const void link(int u,int v,int w)
{
	edc++;g[u].push_back(e[edc]=Edge(u,v,w,edc));
	edc++;g[v].push_back(e[edc]=Edge(v,u,w,edc));
}
int fa[N<<1];
inline const int Find(int x)
{
	return fa[x]==x?x:fa[x]=Find(fa[x]);
}
inline const void Init()
{
	for (int i=1;i<=dualn*2-1;i++)fa[i]=i;
}
inline const void kruskal()
{
	Init();
	treen=dualn;aspect=1;
	sort(d+1,d+dualm+1);
	for (int x,y,i=1;i<=dualm;i++)
		if ((x=Find(d[i].s))^(y=Find(d[i].t)))
			w[++treen]=d[i].w,
			fa[x]=fa[y]=treen,
			t[treen].push_back(x),
			t[treen].push_back(y);
}
int top[N],wson[N],size[N],dep[N];
inline const void dfs(int p)
{
	size[p]=1;
	for (vit::iterator i=t[p].begin();i!=t[p].end();i++)
	{
		int son=*i;
		fa[son]=p;dep[son]=dep[p]+1;
		dfs(son);size[p]+=size[son];
		if (size[son]>size[wson[p]])wson[p]=son;
	}
}
inline const void dfs(int p,int tp)
{
	top[p]=tp;
	if (wson[p])dfs(wson[p],tp);
	for (vit::iterator i=t[p].begin();i!=t[p].end();i++)
		if (!top[*i])
			dfs(*i,*i);
}
inline const int lca(int a,int b)
{
	while (top[a]^top[b])
		dep[top[a]]>dep[top[b]]
		?a=fa[top[a]]:b=fa[top[b]];
	return dep[a]<dep[b]?a:b;
}
inline const int bottleneck(int a,int b)
{
	return w[lca(a,b)];
}
inline const void insert(int id,Radial l)
{
	s.insert(make_pair(l,id));
}
inline const void remove(int id,Radial l)
{
	s.erase(make_pair(l,id));
}
inline const void query(int id,Radial l)
{
	sri::iterator it=s.upper_bound(make_pair(l,0));
	if (it==s.end()||it==s.begin())return ans[id]=-1,void();
	if (!ans[id])return ans[id]=it->second,void();
	if (~ans[id])ans[id]=bottleneck(it->second,ans[id]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)scanf("%d%d",&p[i].x,&p[i].y),p[i].x<<=1,p[i].y<<=1;
	for (int u,v,w;m--;)scanf("%d%d%d",&u,&v,&w),link(u,v,w);
	for (int i=1;i<=n;i++)sort(g[i].begin(),g[i].end());
	for (int i=2;i<=edc;i++)
	{
		int v=e[i].t;
		veg::iterator it=lower_bound(g[v].begin(),g[v].end(),e[i^1]);
		if (it==g[v].begin())it=g[v].end();
		next[i]=(--it)->id;
	}
	for (int i=2;i<=edc;i++)
	{
		if (pos[i])continue;
		pos[i]=pos[next[i]]=++dualn;
		ll size=0;
		for (int j=next[i];e[j].t^e[i].s;j=next[j],pos[j]=dualn)size+=Vector(p[e[i].s],p[e[j].s])*Vector(p[e[i].t],p[e[j].t]);
		if (size<=0)outside=dualn;
	}
	for (int i=2;i<=edc;i+=2)
		if (pos[i]^outside&&pos[i^1]^outside)
			d[++dualm]=Edge(pos[i],pos[i^1],e[i].w);
	kruskal();fa[treen]=0;dfs(treen);dfs(treen,treen);
	for (int i=2;i<=edc;i++)
		if (p[e[i].s].x<p[e[i].t].x)
			o[++cnt]=scan(2,p[e[i].s].x,pos[i^1],Radial(p[e[i].s],p[e[i].t])),
			o[++cnt]=scan(1,p[e[i].t].x,pos[i^1],Radial(p[e[i].s],p[e[i].t]));
	scanf("%d",&q);
	for (int i=1;i<=q;i++)
	{
		dbl xa,ya,xb,yb;
		scanf("%lf%lf%lf%lf",&xa,&ya,&xb,&yb);
		int xp=(int)(xa*2),yp=(int)(ya*2),xq=(int)(xb*2),yq=(int)(yb*2);
		o[++cnt]=scan(3,xp,i,Radial(Point(xp,yp),0.0));
		o[++cnt]=scan(3,xq,i,Radial(Point(xq,yq),0.0));
	}
	sort(o+1,o+cnt+1);
	for (int i=1;i<=cnt;i++)
		switch (o[i].opt)
		{
			case 1:remove(o[i].id,o[i].l);break;
			case 2:insert(o[i].id,o[i].l);break;
			case 3:query(o[i].id,o[i].l);break;
		}
	for (int i=1;i<=q;i++)printf("%d\n",ans[i]);
	return 0;
}
```

---


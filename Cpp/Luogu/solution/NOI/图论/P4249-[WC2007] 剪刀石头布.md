# [WC2007] 剪刀石头布

## 题目描述

在一些一对一游戏的比赛（如下棋、乒乓球和羽毛球的单打）中，我们经常会遇到 $A$ 胜过 $B$，$B$ 胜过 $C$ 而 $C$ 又胜过 $A$ 的有趣情况，不妨形象的称之为剪刀石头布情况。有的时候，无聊的人们会津津乐道于统计有多少这样的剪刀石头布情况发生，即有多少对无序三元组 $(A,B,C)$，满足其中的一个人在比赛中赢了另一个人，另一个人赢了第三个人而第三个人又胜过了第一个人。注意这里无序的意思是说三元组中元素的顺序并不重要，将 $(A, B, C)$、$(A, C, B)$、$(B, A, C)$、$(B, C, A)$、$(C, A, B)$ 和 $(C, B, A)$ 视为相同的情况。

有 $N$ 个人参加一场这样的游戏的比赛，赛程规定任意两个人之间都要进行一场比赛：这样总共有 $\frac{N*(N-1)}{2}$ 场比赛。比赛已经进行了一部分，我们想知道在极端情况下，比赛结束后最多会发生多少剪刀石头布情况。即给出已经发生的比赛结果，而你可以任意安排剩下的比赛的结果，以得到尽量多的剪刀石头布情况。


## 说明/提示

### 【评分标准】
对于每个测试点，仅当你的程序的输出第一行的数字和标准答案一致，且给出了一个与之一致的合法方案，你才能得到该测试点的满分，否则该测试点得 $0$ 分。
### 【数据范围】
$30\%$ 的数据中，$N \leq 6$；

$100\%$ 的数据中，$N \leq 100$。


## 样例 #1

### 输入

```
3
0 1 2
0 0 2
2 2 0
```

### 输出

```
1
0 1 0
0 0 1
1 0 0
```

# 题解

## 作者：Imagine (赞：41)

## 题目大意

竞赛图中的部分边方向已确定，你需要决定剩余边的方向，使得整个图上的三元环数量最多。

## 题解

从整个图的 $n$个点中任取 $3$个点，方案数为$$C^{3}_{n}=\frac{n!}{3!(n-3)!}=\frac{n(n-1)(n-2)}{6}$$
考虑 $3$个点不构成三元环的情况，必然为一点的入度为 $2$，一点的出度为
 $2$，一点的入度出度为 $1$。不妨从入度入手，一个点若入度为 $2$，则表明失去了一个三元环，若入度为 $3$，则会失去 $3$个三元环（考虑点 $A$被点 $B, C, D$通过边指向，那么 $(A,B,C), (A,B,D), (A,C,D)$都不会是三元环），因此，对于一个点 $u$而言，记其入度为 $degree(u)$，那么点 $u$会使整张图会失去
 $C^{2}_{degree(u)}$个三元环。故对于最终答案 $ans$，有
$$ans = \frac{n(n-1)(n-2)}{6} - \sum_{u \in V}{C^{2}_{degree(u)}}$$
通过上述过程已经能够发现，对于一个点 $u$，考虑差分，若其入度增加 $1$，则会使整个图失去的三元环个数为 $$C^{2}_{degree(u)} - C^{2}_{degree(u)-1} = degree(u)-1$$因此，可以将失去的三元环作费用，跑费用流。

我们对于未定向的边，将其视为点（以下称作「边对应的点」），建图如下：

$1.$ 由源点 $s$向每一条边对应的点连边，容量为 $1$，费用为 $0$；

$2.$ 由每一条边对应的点向该边连接的两个图上结点连边，容量为 $1$，费用为
 $0$，表明该条边只会使得其中一个点入度 $+1$；

$3.$ 由每一个图上结点向汇点 $t$连若干条边，费用依次为 $0, 1, 2, 3......$（分别表示该点入度从 $0$开始每增加 $1$就会失去的三元环数量），容量均为 $1$（注意初始图的处理，即某些点初始入度不为 $0$）。

最后的输出方案，对于未定向边，只需看费用流的图中，边对应的点指向的两个图上结点的边中哪一条满流即可。

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;

const int maxn = 5150 + 10;
const int maxg = 100 + 10;
const int INF = 1000000000;

int n;
int s, t;
int rel[maxg][maxg];
int wedge[maxg][maxg];
int indeg[maxn];

int edgeidx(int x, int y) {
  return (2*n-x) * (x-1) / 2 + (y-x) + n;
}

struct Edge {
  int from, to, cap, flow, cost;
  Edge(int from, int to, int cap, int flow, int cost):
    from(from), to(to), cap(cap), flow(flow), cost(cost) {}
};

template <int maxn> struct MCMF {
  int n, m, s, t;
  vector <Edge> edges;
  vector <int> G[maxn];
  int inq[maxn];
  int d[maxn];
  int p[maxn];
  int a[maxn];

  void init(int n) {
    this->n = n;
    for(int i = 0; i < n; i++) G[i].clear();
    edges.clear();
  }

  void AddEdge(int from, int to, int cap, int cost) {
    edges.push_back(Edge(from, to, cap, 0, cost));
    edges.push_back(Edge(to, from, 0, 0, -cost));
    m = edges.size();
    G[from].push_back(m-2);
    G[to].push_back(m-1);
  }

  bool BellmanFord(int s, int t, int& cost) {
    for(int i = 0; i < n; i++) d[i] = INF;
    memset(inq, 0, sizeof(inq));
    d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF;
  
    queue <int> Q;
    Q.push(s);
    while(!Q.empty()) {
      int u = Q.front(); Q.pop();
      inq[u] = 0;
      for(int i = 0; i < G[u].size(); i++) {
        Edge& e = edges[G[u][i]];
        if(e.cap > e.flow && d[e.to] > d[u] + e.cost) {
          d[e.to] = d[u] + e.cost;
          p[e.to] = G[u][i];
          a[e.to] = min(a[u], e.cap - e.flow);
          if(!inq[e.to]) { Q.push(e.to); inq[e.to] = 1; }
        }
      }
    }
    if(d[t] == INF) return false;
    cost += d[t] * a[t];
    int u = t;
    while(u != s) {
      edges[p[u]].flow += a[t];
      edges[p[u]^1].flow -= a[t];
      u = edges[p[u]].from;      
    }
    return true;
  }

  int Mincost(int s, int t) {
    int cost = 0;
    while(BellmanFord(s, t, cost));
    return cost;
  }
};
  
MCMF <maxn> solver;
  
int main() {
  scanf("%d", &n);
  s = 0; t = (n+1)*n/2 + n + 1;
  solver.init(t+1);
  for(int i = 1; i <= n; i++)
    for(int j = 1; j <= n; j++) {
      scanf("%d", &rel[i][j]);
      if(rel[i][j] == 1) indeg[j]++;
    }

  for(int i = 1; i <= n; i++)
    for(int j = i+1; j <= n; j++) {
      if(rel[i][j] < 2) continue;
      solver.AddEdge(s, edgeidx(i, j), 1, 0);
      solver.AddEdge(edgeidx(i, j), i, 1, 0);
      wedge[j][i] = solver.m - 2;
      solver.AddEdge(edgeidx(i, j), j, 1, 0);
      wedge[i][j] = solver.m - 2;
    }

  int down = 0;
  for(int i = 1; i <= n; i++) {
    down += indeg[i] * (indeg[i]-1) / 2;
    for(int j = indeg[i] + 1; j < n; j++)
      solver.AddEdge(i, t, 1, j-1);
  }

  down += solver.Mincost(s, t);

  printf("%d\n", n*(n-1)*(n-2) / 6 - down);

  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++) {
      if(rel[i][j] < 2) printf("%d", rel[i][j]);
      else printf("%d", solver.edges[wedge[i][j]].flow);
      if(j < n) printf(" ");
    }
    printf("\n");
  }

  return 0;
}
```

---

## 作者：Nemlit (赞：15)

一句话题意：给定一张图，每两点之间有一条有向边或无向边，把所有无向边定向，使图中三元环个数尽量多

因为原图是一个完全图，假设图中任意三点都能构成三元环，那么途中三元环的个数为：$\binom{n}{3}$。

那么如果一个三元组不是三元环，那么有一个点的出度为2。

我们假设一个点的出度为d，那么对于这个点，三元环会减少$\frac{d (d-1)}{2}$

所以三元环的数量为：$\binom{n}{3}- \sum_{i=1}^n\binom{d[i]}{2}=\binom{n}{3}- \sum_{i=1}^n\frac{d[i] (d[i]-1)}{2}$

所以我们要最小化：$ \sum_{i=1}^n\frac{d[i] (d[i]-1)}{2}$的值。

怎么做呢？

如果我们对于一条无向边，可能让u出度+1，也可能让v出度+1，非黑即白，所以我们可以考虑费用流。

观察柿子$\frac{d[i] (d[i]-1)}{2}$，容(hen)易(nan)想到小学等差数列求和公式，于是我们可以将一个点的贡献看成$(0+1+2+3+……+d[i]-1)$

把每一条边看成一个点，从源点向每条边连一条容量为1，费用为0的边。

对于一条无向边，往u，v分别建一条容量为1，费用为0的边。

有向边则把边和v建一条容量为1，费用为0的边。

每个点向汇点连n条容量为1，费用为0-(n-1)递增的边，表示上面的等差数列（可以表示出任何出度的情况）

最后就是费用流的板子了

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define inf 123456789
#define debug printf("Now is Line : %d\n",__LINE__)
il int read()
{
    re int x=0,f=1; re char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
#define maxn 105
#define maxm 105*105
struct edge
{
    int v,w,val,next;
}e[maxm<<3];
int n,a[maxn][maxn],S,T,maxflow,cost,vis[maxm],dis[maxm],head[maxm],cnt=1,pa;
il void add(int u,int v,int val,int w)
{
    e[++cnt]=(edge){v,w,val,head[u]};
    head[u]=cnt;
    e[++cnt]=(edge){u,-w,0,head[v]};
    head[v]=cnt;
}
queue<int>q;
il bool spfa()
{
    memset(vis,0,sizeof(vis));
    memset(dis,127,sizeof(dis));
    dis[S]=0; q.push(S);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(re int i=head[u];i;i=e[i].next)
        {
            int v=e[i].v;
            if(dis[v]>dis[u]+e[i].w&&e[i].val>0)
            {
                dis[v]=dis[u]+e[i].w;
                if(!vis[v])
                {
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    return dis[T]!=2139062143;
}
il int dfs(int u,int mi)
{
    if(u==T)
    {
        vis[T]=1;
        return mi;
    }
    vis[u]=1;
    int use=0;
    for(re int i=head[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if((!vis[v]||v==T)&&e[i].val>0&&dis[v]==dis[u]+e[i].w)
        {
            int low=dfs(v,min(mi-use,e[i].val));
            if(low>0)
            {
                cost+=low*e[i].w;
                e[i].val-=low; e[i^1].val+=low;
                use+=low;
            }
        }
    }
    return use;
}
il void dinic()
{
    while(spfa())
    {
        vis[T]=1;
        while(vis[T])
        {
            memset(vis,0,sizeof(vis));
            dfs(S,inf);
        }
    }
    int ans=((n-1)*(n-2)*n)/6;
    ans-=cost;
    printf("%d\n",ans);
}
int main()
{
    n=read(); T=n*n+n+1;
    for(re int i=1;i<=n;++i)
    {
        for(re int j=1;j<=n;++j)
        {
            a[i][j]=read();
            if(i>=j) continue;
            if(a[i][j]==2)
            {
                add(S,(i-1)*n+j,1,0);
                add((i-1)*n+j,n*n+i,1,0);
                add((i-1)*n+j,n*n+j,1,0);
            }
            else if(a[i][j]==1) add(S,n*n+j,1,0);
            else add(S,n*n+i,1,0);
        }
    }
    for(re int i=1;i<=n;++i)
    {
        for(re int j=0;j<n;++j) add(n*n+i,T,1,j);
    }
    dinic();
    for(re int i=1;i<=n;++i)
    {
        for(re int j=i+1;j<=n;++j)
        {
            if(a[i][j]<2) continue;
            for(re int k=head[(i-1)*n+j];k;k=e[k].next)
            {
                if(e[k].v&&e[k].val==0)
                {
                    a[i][j]=(e[k].v-n*n==j);
                    a[j][i]=a[i][j]^1;
                }
            }
        }
    }
    for(re int i=1;i<=n;++i,puts(""))
    {
        for(re int j=1;j<=n;++j) printf("%d ",a[i][j]);
    }
    return 0;
}
```

---

## 作者：Im3tsmh (赞：10)

## 这是一篇模拟退火的题解

前置知识：[模拟退火](https://oi-wiki.org/misc/simulated-annealing/)

题目中矩阵里元素 $2$ 可以自行匹配。可以对每一种合法的矩阵求得三元组数量，故考虑模拟退火。

对于模拟退火中求当前答案操作（后文将其称为 $check$），依据题意可以直接模拟得

```cpp
int answer()
{
	int all=0;
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			for(int k=j+1;k<=n;++k)
			{
				if(a[i][j]==1&&a[j][k]==1&&a[k][i]==1)++all;
				else if(a[i][j]==0&&a[j][k]==0&&a[k][i]==0)++all;
			}
		}
	}
	return all;
}
```

每一次 $check$ 都需要 $n^3$ 的时间，对于 $N\leq100$ 的范围有些吃不消，考虑优化。

在本题中，矩阵中两个相互对应的 $2$ 可以看做 $(0,1)$ 或 $(1,0)$ 的转换。对于三元组，不需要每次遍历整个矩阵找答案，只需要对比矩阵更改前后消失与增加的三元组数量即可。

枚举 $n$ 个元素查找三元组数量变化，$check$ 时间复杂度降为 $O(n)$。

```cpp
int from,to;
int check()
{
	from=0;to=0;
	for(int i=1;i<=n;++i)
	{
		if(a[px][py]){if(a[py][i]==1&&a[i][px]==1)++to;}
		else {if(a[px][i]==1&&a[i][py]==1)++to;}
	}
	swap(a[px][py],a[py][px]);
	for(int i=1;i<=n;++i)
	{
		if(a[px][py]){if(a[py][i]==1&&a[i][px]==1)++from;}
		else {if(a[px][i]==1&&a[i][py]==1)++from;}
	}
	swap(a[px][py],a[py][px]);
	return to-from;
}
```

由于 $check$ 操作时间复杂度不高，可以适当降低 $eps$ 并提高 $\Delta t$ 以提高单次退火操作准确性。我的 $eps$ 开到了 $1e-19$，$\Delta t$ 开到了 $0.9998$ 才成功 AC，这道题数据需要这么极端可能是因为单次矩阵变换带来的答案变化不大。

最后说一下模拟退火不要陷入 $check$ 操作必须整体求答案的思维误区。有的时候退火当前答案是可以从最优答案中推出来的。~~我在模拟赛时就犯了这个错误只想到了 $O(n^3)$ 的 $check$，只拿到了 $30$ 分的部分分。问了大佬才知道还能这么写，真是受益匪浅。~~

优化 $check$ 操作时间复杂度以提高退火准确性能更好的拿高分。

最后附上完整代码：

```cpp
#include<bits/stdc++.h>
#define debug printf("ssf_nimaWRZontop\n")
#define DEBUG printf("bowdowntotheWRZ\n")
#define double long double
using namespace std;
const int inf=0x3f3f3f3f;
const double eps=1e-19;
const int N=105;
int n,ans,deltanow,cnt,a[N][N];
struct gets{
    int x,y;
}e[N*N];
int px,py;
int answer()
{
    int all=0;
    for(int i=1;i<=n;++i)
    {
        for(int j=i+1;j<=n;++j)
        {
            for(int k=j+1;k<=n;++k)
            {
                if(a[i][j]==1&&a[j][k]==1&&a[k][i]==1)++all;
                else if(a[i][j]==0&&a[j][k]==0&&a[k][i]==0)++all;
            }
        }
    }
    return all;
}
int from,to;
int check()
{
    from=0;to=0;
    for(int i=1;i<=n;++i)
    {
        if(a[px][py]){if(a[py][i]==1&&a[i][px]==1)++to;}
        else {if(a[px][i]==1&&a[i][py]==1)++to;}
    }
    swap(a[px][py],a[py][px]);
    for(int i=1;i<=n;++i)
    {
        if(a[px][py]){if(a[py][i]==1&&a[i][px]==1)++from;}
        else {if(a[px][i]==1&&a[i][py]==1)++from;}
    }
    swap(a[px][py],a[py][px]);
    return to-from;
}
double temp=5000,delta=0.9998;
void sa()
{
    while(temp>eps)
    {
        int x=rand()%cnt+1;
        px=e[x].x;
        py=e[x].y;
        swap(a[px][py],a[py][px]);
        deltanow=check();
        if(deltanow>0||exp(deltanow/temp)>(double)rand()/(double)RAND_MAX)ans+=deltanow;
        else swap(a[px][py],a[py][px]);
        temp*=delta;
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
    	for(int j=1;j<=n;++j)
    	{
    		scanf("%d",&a[i][j]);
		}
	}
    for(int i=1;i<=n;++i)
    {
        for(int j=i+1;j<=n;++j)
        {
            if(a[i][j]==2)
            {
                e[++cnt].x=i;
                e[cnt].y=j;
                a[i][j]=1;
            }
        }
        for(int j=1;j<i;++j)if(a[i][j]==2)a[i][j]=0;
    }
    ans=answer();
    while(1)
    {
        if(clock()*1.0/CLOCKS_PER_SEC*1000>990)break;
        sa();
    }
    printf("%d\n",ans);
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)printf("%d ",a[i][j]);
        printf("\n");
    }
    return 0;
}
//freopen("wrz.in","r",stdin);
//freopen("wrz.out","w",stdout);
```
upd on 23/9/6 : 修改了一处逻辑性错误

---

## 作者：樱雪喵 (赞：4)

双倍经验：[CF1264E Beautiful League](https://www.luogu.com.cn/problem/CF1264E)

直接对三元环计数，发现没法做。反过来对无法形成环的三元组进行计数，那么目标是最小化这样的三元组数量。

考虑一个无法形成环的三元组有什么性质，发现它有且仅有一个点出度为 $2$。同时我们发现这是判定一个三元组非法的充要条件，所以我们要对这样的一个点和两条边数数。

设 $deg_i$ 表示点 $i$ 的出度，那么点 $i$ 对应的非法三元组数量为 $\frac{deg_i(deg_i-1)}{2}$。问题转化为给所有无向边定向，最小化 $\sum\limits_{i=1}^n \frac{deg_i(deg_i-1)}{2}$。

给无向边 $(u,v)$ 定向，要么使 $deg_u\gets deg_u+1$，要么使 $deg_v\gets deg_v+1$。二选一，考虑费用流。

注意到贡献是二次的，考虑将 $deg_i$ 增加 $1$ 的代价差分。差分数组是递增的，这满足了费用流的贪心性质，也就是说满流的边一定是差分数组的一个前缀。至此我们可以用左侧一排点表示未定向的边，右侧一排点表示原图点的 $deg$ 值，建图：

- 连接源点和左侧点，容量为 $1$，费用为 $0$，表示这条边对 $deg$ 造成总量为 $1$ 的贡献；
- 连接表示边 $(u,v)$ 的左侧点和表示点 $u,v$ 的右侧点，容量为 $1$，费用为 $0$，表示 $(u,v)$ 可以对两个点产生贡献；
- 在每个右侧点和汇点之间连 $n$ 条边，容量为 $1$，费用分别为 $deg$ 数组从 $0$ 至 $n-1$ 的差分。

答案为 $\frac{n(n-1)(n-2)}{3!}-mincost$。

```cpp
const int N=1e5+5,inf=1e9;
int n,s,t,a[105][105],f[105][105],deg[N];
il int get(int x,int y) {return (x-1)*n+y;}
il int F(int x) {return x*(x-1)/2;}
struct edge{int nxt,to,w,c;} e[N<<1];
int head[N],cnt=1;
il void add(int u,int v,int w,int c)
{
    e[++cnt]={head[u],v,w,c};head[u]=cnt;
    e[++cnt]={head[v],u,0,-c};head[v]=cnt;
}
int dis[N],in[N],now[N];
queue<int> q;
il bool spfa()
{
    for(int i=s;i<=t;i++) dis[i]=inf,in[i]=0,now[i]=head[i];
    dis[s]=0,in[s]=1; q.push(s);
    while(!q.empty())
    {
        int u=q.front(); q.pop(),in[u]=0;
        for(int i=head[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if(e[i].w&&dis[v]>dis[u]+e[i].c)
            {
                dis[v]=dis[u]+e[i].c;
                if(!in[v]) in[v]=1,q.push(v);
            }
        }
    }
    return dis[t]!=inf;
}
int dfs(int u,int sum)
{
    if(u==t) return sum;
    in[u]=1; int res=0;
    for(int i=now[u];i&&sum;i=e[i].nxt)
    {
        int v=e[i].to; now[u]=i;
        if(!e[i].w||dis[v]!=dis[u]+e[i].c||in[v]) continue;
        int k=dfs(v,min(e[i].w,sum));
        e[i].w-=k,e[i^1].w+=k,sum-=k,res+=k;
    }
    in[u]=0; return res;
}
int main()
{
    n=read(); s=0,t=n*n+n+1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++) 
        {
            a[i][j]=f[i][j]=read();
            if(a[i][j]==1) deg[i]++;
            else if(i<j&&a[i][j]==2)
            {
                add(s,get(i,j),1,0);
                add(get(i,j),n*n+i,1,0),add(get(i,j),n*n+j,1,0);
            }
        }
    int flw=0,ans=0;
    for(int i=1;i<=n;i++)
    {
        ans+=F(deg[i]);
        for(int j=deg[i];j<n;j++) add(n*n+i,t,1,F(j+1)-F(j));
    }
    while(spfa()) 
    {
        int k=dfs(s,inf);
        flw+=k,ans+=dis[t]*k;
    }
    printf("%d\n",n*(n-1)*(n-2)/6-ans);
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
        {
            int u=get(i,j);
            for(int k=head[u];k;k=e[k].nxt)
            {
                int v=e[k].to; if(!k) continue;
                if(!e[k].w) f[i][j]=0,f[j][i]=1;
                else f[i][j]=1,f[j][i]=0;
                break;
            }
        }
    for(int i=1;i<=n;i++,printf("\n")) 
        for(int j=1;j<=n;j++) printf("%d ",f[i][j]);
    return 0;
}
```

---

## 作者：Hyscere (赞：3)

~~[广告](https://www.cnblogs.com/hbyer/p/10464216.html)~~

考虑补集转化，满足条件的不好求，那就求不满足条件的。

设第$i$个人赢了$val_i$次，那么不满足条件的三元组个数就是：

$\sum_{i=1}^{n}\binom{val_i}{2}=\sum_{i=1}^{n}val_i(val_i-1)/2$

考虑网络流建图：

- 对于每个人，建出一个$A_i$表示这个人，然后$A_i$向汇点$t$连边，容量为$n$。
- 对于每场不确定的比赛$(x,y)$，建出$B_i$表示这场比赛，源点$s$向$B_i$连边，$B_i$向$x,y$连边，容量均为$1$。

那么这个图的每种最大流都表示一种可行的方案。

现在我们的目的就是给这个图加上费用，使得费用最小。

那么对于点$A_i$，若流向$t$的流量为$x$，费用就是$x(x-1)/2$，但是这里是一个二次的增长，一般的建图就做不了了。

可以考虑把这条边拆成$n$条，每条容量为$1$，费用依次递增，即费用为$0,1,2,...,n-1$，那么可以发现，由于费用流每次增广都会选择最小的那条边，所以流量为$x$时费用为$x(x-1)/2$，即满足条件。

然后建完图跑最小费用最大流，然后拿总方案减一下就好了。

输出方案随便枚举一下哪条边流满了就好了。

```c++
#include<bits/stdc++.h>
using namespace std;
 
void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

const int maxn = 2e5+10;
const int inf = 1e9;

int n,s,t,tot=1,cnt,cost;
int head[maxn],vis[maxn],dis[maxn],val[maxn],mp[102][102];
struct edge{int to,nxt,w,c;}e[maxn];

void add(int u,int v,int w,int c) {e[++tot]=(edge){v,head[u],w,c},head[u]=tot;}
void ins(int u,int v,int w,int c) {add(u,v,w,c),add(v,u,0,-c);}

int bfs() {
	memset(dis,63,(t+1)*4);
	memset(vis,0,(t+1)*4);
	queue<int > q;q.push(s),dis[s]=0,vis[s]=1;
	while(!q.empty()) {
		int now=q.front();q.pop();vis[now]=0;
		for(int i=head[now];i;i=e[i].nxt)
			if(e[i].w>0&&dis[e[i].to]>dis[now]+e[i].c) {
				dis[e[i].to]=dis[now]+e[i].c;
				if(!vis[e[i].to]) vis[e[i].to]=1,q.push(e[i].to);
			}
	}
	return dis[t]<inf;
}

int dfs(int x,int f) {
	vis[x]=1;
	if(x==t) return cost+=f*dis[t],f;
	int used=0;
	for(int i=head[x];i;i=e[i].nxt)
		if((e[i].to==t||!vis[e[i].to])&&e[i].w>0&&dis[e[i].to]==dis[x]+e[i].c) {
			int d=dfs(e[i].to,min(f-used,e[i].w));
			if(d>0) e[i].w-=d,e[i^1].w+=d,used+=d;
			if(used==f) break;
		}
	return used;
}

int mcmf() {
	cost=0;
	while(bfs()) dfs(s,inf);
	return cost;
}

int tmp[5],top,mark;

int main() {
	read(n);s=n*n+1,t=s+1;cnt=n;
	int ans=n*(n-1)*(n-2)/6;
	for(int i=1;i<=n;i++)
		for(int j=1,x;j<=n;j++) {
			read(x);mp[i][j]=x;
			if(j>i) {
				if(x==1) val[i]++;
				else if(x==0) val[j]++;
				else ins(s,++cnt,1,0),ins(cnt,i,1,0),ins(cnt,j,1,0);
			}
		}
	for(int i=1;i<=n;i++) 
		for(int j=val[i];j<=n;j++) ins(i,t,1,j);
	for(int i=1;i<=n;i++) ans-=val[i]*(val[i]-1)/2;
	write(ans-mcmf());
	for(int x=n+1;x<=cnt;x++) {
		top=-1;
		for(int i=head[x];i;i=e[i].nxt)
			if(e[i].to!=s) {
				tmp[++top]=e[i].to;
				if(e[i].w==0) mark=top;
			}
		mp[tmp[mark]][tmp[mark^1]]=1;
		mp[tmp[mark^1]][tmp[mark]]=0;
	}
	for(int i=1;i<=n;i++,puts("")) for(int j=1;j<=n;j++) printf("%d ",mp[i][j]);
	return 0;
}
```

---

## 作者：断清秋 (赞：2)

[P4249](https://www.luogu.com.cn/problem/P4249) [CF1264E](https://www.luogu.com.cn/problem/CF1264E)

鸽好久了，稍微写一下。

求成环的三元组个数并没有优秀的做法，考虑求不成环的三元组个数。

考虑不成环的情况，必然是其中一个点入度为 $2$，另一个点出度为 $2$。

不妨令三元组有序，设 $d_i$ 为点 $i$ 的出度。

那么这样的三元组总数就是 $\dfrac{n(n-1)(n-2)}{6}$。

而对于不成环的三元组，必然有一个点出度为 $2$，那么考虑组合意义，就是从任何一个出度 $\ge 2$ 的点中任选两个出边连接的点组成一个三元组，这样的三元组个数即为 $\sum\limits_{i=1}^n\dbinom{d_i}{2}$。

于是成环三元组数即为 $\dfrac{n(n-1)(n-2)}{6}-\sum\limits_{i=1}^n\dbinom{d_i}{2}$。

这个式子拆一下变成 $\dfrac{n(n-1)(n-2)}{6}-\sum\limits_{i=1}^n\dfrac{{d_i}^2}{2}+\sum\limits_{i=1}^n\dfrac{d_i}{2}$。

又因为所有点的出度和等于图的边数，即 $\sum\limits_{i=1}^nd_i=\dfrac{n(n-1)}{2}$。


代入可得原式值为 $\dfrac{n(n-1)(2n-1)}{12}-\dfrac{1}{2}\sum\limits_{i=1}^n{d_i}^2$。

然后要最大化这个值，只需最小化 $\sum\limits_{i=1}^n{d_i}^2$ 即可。

现在要把其余未定向的边定向，考虑费用流。

考虑对于未定向的边，可以把这些边看做一个点，从源点向这些点连流量为 $1$，费用为 $0$ 的边，这些点再向边的两个端点连流量为 $1$，费用为 $0$ 的边即可保证每场比赛有唯一胜者。

然后这些点向汇点连边，考虑该点每多获胜一场增加的贡献为 $\dfrac{d_i(d_i+1)}{2}-\dfrac{d_i(d_i-1)}{2}=d_i$，所以直接连流量为 $1$，费用为 $d_i$ 的边即可。

最后矩阵的形态只需要参考从边 $(i,j)$ 到点 $i$ 的流量是否流完即可，记录一下边到点的流量就做完了。

---

## 作者：Martian148 (赞：2)

### 题目大意

[P4249 [WC2007]剪刀石头布](https://www.luogu.com.cn/problem/P4249)


给出一个图，图中有些边的方向没有确定，有些方向给定，要求你定下不确定边的方向，使得图中的三元环最多。

### 问题求解

对于三元环的个数，我们直接求解非常困难，所以考虑补集，用总的个数减去不能构成三元环的个数，也就是总的三元环的个数了。

显然，任意三个点构成三元环的个数是 $C_n^3$。

再来思考不能构成三元环的个数，我们可以发现，如果一个点不能构成三元环，那么这个点的出度为 $2$，那么如果一个点的出度为 $du[x]$ 的话，不能构成三元环的个数就是 $C_{du[x]}^2=\frac{du[x]\times (du[x]-1)}{2}$。

所以我们要求的答案就变成了 $C_n^3-\sum C_{du[x]}^2$。

因此，要最小化 $\sum C_{du[x]}^2$ 的值。

如果一条$(u,v)$边，假设确定的边我们只能将 $du[v]+1$，如果不确实可以将 $du[u]+1$ 或 $du[v]+1$ ，$u$ 和 $v$ 二选一，又注意到边数比较小，所以考虑网络流，将边看成一个"点"，从边流向点再流向超级汇点。

如果一条"边"使得 $du[u]+1$ 那么建立一条从这个"边"到 $u$ 点的边,流量为 $1$,费用为 $0$ 如果一条边是没有确定的，那么建立一条到 $u$ 点的边和一条到 $v$ 的边，流量为 $1$，费用为 $0$ ,代表二选一，从超级源点到每条"边"也建立一条流量为 $1$ ，费用为 $0$ 的边，限制流量。

考虑如何计算答案，观察柿（式）子 $C_{du[x]}^2=\frac{du[x]\times (du[x]-1)}{2}$ ，发现后面那个柿子很想小学的时候学过的等差数列 $0+1+2+3+...+du[x-1]=\frac{du[x]\times (du[x]-1)}{2}$ ,那么我们建$du[x]$ 条边，从点到超级汇点，流量为 $1$，费用分别为 $0,1,2,...,du[x]-1$，就可以表示所有的情况了。

然后就一般的刷费用流就好了。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10105,maxe=maxn*8,INF=0x3f3f3f3f;
int N,mp[105][105],st,ed;
int lnk[maxn],nxt[maxe],son[maxe],w[maxe],cost[maxe],cnt=1,vis[maxn],dis[maxn],Q[maxn];
int maxflow,mincost,Ans;
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline int calc(int x,int y){return (x-1)*N+y;}
inline void add_e(int x,int y,int z,int c){
	son[++cnt]=y;nxt[cnt]=lnk[x];lnk[x]=cnt;w[cnt]=z;cost[cnt]=c;
}
inline void add_edge(int x,int y,int z,int c){
	add_e(x,y,z,c);add_e(y,x,0,-c);
}
int spfa(){
	int hed=0,til=1;
	memset(dis,INF,sizeof dis);
	memset(vis,0,sizeof vis);
	dis[st]=0;Q[til]=st;
	while(hed!=til){
		hed=(hed+1)%maxn;vis[Q[hed]]=0;
		for(int j=lnk[Q[hed]];j;j=nxt[j])
			if(w[j]>0&&dis[son[j]]>dis[Q[hed]]+cost[j]){
				dis[son[j]]=dis[Q[hed]]+cost[j];
				if(!vis[son[j]]){
					vis[son[j]]=1;Q[til=(til+1)%maxn]=son[j];
				}
			}
	}
	return dis[ed]!=INF;
}
int min(int x,int y){return x<y?x:y;}
int DFS(int x,int delta){
	vis[x]=1;
	if(x==ed)return delta;
	int flow=0;
	for(int j=lnk[x];j;j=nxt[j]){
		if((!vis[son[j]]||x==ed)&&w[j]>0&&dis[son[j]]==dis[x]+cost[j]){
			int t=DFS(son[j],min(delta-flow,w[j]));
			if(t>0){flow+=t;w[j]-=t;w[j^1]+=t;mincost+=t*cost[j];}
//			if(flow==delta)break;
		}
	}
	return flow;
}
inline void Dinic(){
	while(spfa()){
		vis[ed]=1;
		while(vis[ed]){
			memset(vis,0,sizeof vis);
			int tmp=DFS(st,INF);
			maxflow+=tmp;
		}
	}
	Ans=((N-1)*(N-2)*N)/6;
	Ans-=mincost;
}
int main(){
	N=read();st=0;ed=N*N+N+1;
	for(int i=1;i<=N;i++)
	for(int j=1;j<=N;j++){
		mp[i][j]=read();
		if(i>=j)continue;
		if(!(mp[i][j]^2)){
			add_edge(st,calc(i,j),1,0);
			add_edge(calc(i,j),N*N+i,1,0);
			add_edge(calc(i,j),N*N+j,1,0);
		}
		else if(!(mp[i][j]^1)) add_edge(st,N*N+j,1,0);
		else add_edge(st,N*N+i,1,0);
	}
	for(int i=1;i<=N;i++)
	for(int j=0;j<N;j++)
		add_edge(N*N+i,ed,1,j);
	Dinic();
	printf("%d\n",Ans);
	for(int i=1;i<=N;i++){
		for(int j=i+1;j<=N;j++){
			if(mp[i][j]<2)continue;
			for(int k=lnk[calc(i,j)];k;k=nxt[k]){
				if(son[k]&&w[k]==0){
					mp[i][j]=(son[k]-N*N==j);
					mp[j][i]=mp[i][j]^1;
				}
			}
		}
	}
	for(int i=1;i<=N;i++){
		for(int j=1;j<=N;j++)printf("%d ",mp[i][j]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：翼德天尊 (赞：1)

> $n$ 个节点，其中已经连了一些边，求将这张图补成一个完全图后，三元环的个数最多是多少。
>
> $1\le n\le 100$。

正着做比较困难，考虑反着思考。即求解 「不构成三元环的三元组个数最少是多少」。

考虑对于一个连了三条边的三元组，什么情况下不构成三元环——可以发现此时一定存在一个点出度为 $2$。

于是对于一个出度为 $w$ 的节点，由于每两个出度就可以锁定一个非环的三元组，故这个节点一共可以锁定 $C_{w}^2=\frac{w\times(w-1)}{2}$ 个这样的三元组。

那么我们要做些什么呢？对于一条还未存在的边 $(u,v)$，可以选择将其出度的贡献加给 $u$，也可以加给 $v$，而我们要做的，就是合理分配这些出度。

考虑网络流，流量表示出度，费用表示非环三元组的个数。那么对于一个原图上的节点来说，它每增加一个流量所增加的费用是不一样的，例如 $C_{2}^{2}-C_{1}^2=1$，$C_{3}^{2}-C_{2}^2=2$，$C_{4}^2-C_{3}^2=3$，以此类推。所以建图时也需要将这点考虑进去。

建图如下：

- 左侧节点表示未锁定的边，由源点向其流 $1$ 流量表示只能将出度赋给一个节点。
- 右侧节点表示点，由源点向其流已经锁定的边中该点出度个流量，再由对应的表示未锁定边的节点向其连 $1$ 流量。并向汇点连 $n$ 条边，流量都为 $1$，费用分别为 $0$ 到 $n-1$。

然后跑费用流即可。最终答案为 $C_{n}^3-ans$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int K=105;
const int N=20005;
const int M=2e5+5;
const int INF=1e9;
int n,a[K][K],s,t,p[K][K],dep[N],ans,cost;
bool vis[N];
const int id(int x,int y){
	return (x-1)*n+y;
}
struct node{
	int to[M],next[M],head[N],tot=1,val[M],co[M];
	void adde(int u,int v,int w,int f){
		to[++tot]=v,next[tot]=head[u],val[tot]=w,co[tot]=f,head[u]=tot;
		to[++tot]=u,next[tot]=head[v],val[tot]=0,co[tot]=-f,head[v]=tot;
	}
}S;
ll read(){
    ll w=0,f=1;
    char ch=getchar();
    while (ch>'9'||ch<'0') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        w=(w<<3)+(w<<1)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
queue<int> q;
bool bfs(){
	for (int i=s;i<=t;i++) dep[i]=INF,vis[i]=0;
	dep[s]=0,q.push(s);
	while (!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for (int i=S.head[u];i;i=S.next[i]){
			int v=S.to[i];
			if (S.val[i]&&dep[v]>dep[u]+S.co[i]){
				dep[v]=dep[u]+S.co[i];
				if (!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	if (dep[t]==INF) return 0;
	return 1;
}
int dfs(int u,int flow){
	vis[u]=1;
	if (u==t) return flow;
	int used=0,rlow=0;
	for (int i=S.head[u];i;i=S.next[i]){
		int v=S.to[i];
		if ((!vis[v]||v==t)&&S.val[i]&&dep[v]==dep[u]+S.co[i]){
			if (rlow=dfs(v,min(flow-used,S.val[i]))){
				S.val[i]-=rlow;
				S.val[i^1]+=rlow;
				used+=rlow;
				cost-=rlow*S.co[i];
				if (used==flow) break;
			}
		}
	}
	return used;
}
void dinic(){
	while (bfs()){
		vis[t]=1;
		while (vis[t]){
			memset(vis,0,sizeof(vis));
			dfs(s,INF);
		}
	}
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
#endif
    n=read(),s=0,t=n*n+n+1,cost=n*(n-1)*(n-2)/3/2;
	for (int i=1;i<=n;i++)	
		for (int j=1;j<=n;j++)	
			a[i][j]=read();
	for (int i=1;i<=n;i++){
		for (int j=i+1;j<=n;j++){
			if (a[i][j]==0){
				S.adde(s,j+n*n,1,0);
			}else if (a[i][j]==1){
				S.adde(s,i+n*n,1,0);
			}else{
				S.adde(s,id(i,j),1,0);
				S.adde(id(i,j),i+n*n,1,0);
				S.adde(id(i,j),j+n*n,1,0);
				p[i][j]=S.tot;
			}
		}
	}
	for (int i=1;i<=n;i++){
		for (int j=0;j<n;j++)
			S.adde(i+n*n,t,1,j);
	}
	dinic();
	cout<<cost<<"\n";
	for (int i=1;i<=n;i++){
		for (int j=i+1;j<=n;j++){
			if (a[i][j]==2){
				if (S.val[p[i][j]]==0)
					p[j][i]=0,p[i][j]=1;
				else p[j][i]=1,p[i][j]=0;				
			}else{
				p[i][j]=a[i][j],p[j][i]=a[j][i];
			}
		}
	}
	for (int i=1;i<=n;i++){
		for (int j=1;j<=n;j++)
			cout<<p[i][j]<<" ";
		puts("");
	}
    return 0;
}
```

---

## 作者：神迹 (赞：1)

楼上讲的相当的清楚，这里蒟蒻分享一下自己的思路。

不会的同学可以先了解一下有关知识[网络流问题：最大流及其算法](https://blog.csdn.net/vonmax007/article/details/64921089)

分析：这题从正面分析，看不出什么东西，我们可以利用对偶的性质，找不能构成剪刀石头布的情况，对于任意三个点，还有这三个点之间的三条边，如果满足其中一个点的入度为2，则这个图不是剪刀石头布情况，对于整个图中的一个点的入度in[i]，那么有C(in[i],2)种情况不行，那么可以构成剪刀石头布情况的数量为C(n,3)-sum{C(i[i],2)}(1<=i<=n)

对这个式子进行转换，有S=n*(n-1)*(n-2)-sum{in[i]^2}/2+sum{in[i]}/2

由于S=n*(n-1)*(n-2)+sum{in[i]}/2是定值，所以只要保证sum{in[i]^2}/2的值最小即可


具体方法：

构图，虚拟源点和汇点，还有没固定的边表示一种节点，另外就是n个节点，那么对于已经固定的边，在源点与相应顶点连上一条边，容量为1，费用为0，对于不固定的边，在源点与这条边对应节点连上容量为1，费用为0的边，这条边对应节点与这条边的两个端点分别连一条容量为1，费用为0的边，对于n个点，如何计算in[i]^2呢，也就是流量的平方？

如：

流量  1  2  3  4...n

费用  1  4  9 16...n^2

我们可以把这条边拆成n条容量为1的边，费用分别为 1,3,5,7,9......

然后求最小费用最大流

代码如下：
```
#include <bits/stdc++.h>

#define re register

#define REP(u) for(re int i=p[u]; i>=0; i=p[ver[i]]) 

using namespace std;

ifstream fin("jsb.in");
ofstream fout("jsb.out");

const int mm=1111111;//fff
const int mn=111111;
const int oo=1e9;

int node,src,dest,edge;

int head[mm],vis[mm],ver[mm],flow[mm],cost[mm],next[mm],dis[mm];

int p[mm],q[mm];

inline void prepare(int _n,int _s,int _d) {
	node=_n,src=_s,dest=_d;
	for(re int i=0; i<node; ++i) head[i]=-1,vis[i]=0;
	edge=0;
}

inline void add(int u,int v,int f,int c) {
	ver[edge]=v,flow[edge]=f,cost[edge]=c,next[edge]=head[u],head[u]=edge++;
	ver[edge]=u,flow[edge]=0,cost[edge]=-c,next[edge]=head[v],head[v]=edge++;
}

inline bool spfa() {
	int u,v,i,r=0,tmp;
	for(re int i=0; i<node; ++i) dis[i]=oo;
	dis[q[r++]=src]=0;
	p[dest]=p[src]=-1;
	for(re int l=0; l!=r; (++l>=mn)?l=0:l) {
		for(i=head[u=q[l]],vis[u]=0; i>=0; i=next[i]) {
			if(flow[i]&&dis[v=ver[i]]>(tmp=dis[u]+cost[i])) {
				dis[v]=tmp;
				p[v]=i^1;
				if(vis[v]) continue;
				vis[q[r++]=v]=1;
				if(r>mn) r=0;
			}
		}
	}
	return (p[dest]>=0);
}

inline int work2() {
	int ret=0,delta;
	while(spfa()) {
		delta=oo;
		REP(dest){
			if(flow[i^1]<delta) delta=flow[i^1];
		}
		REP(dest){
			flow[i]+=delta,flow[i^1]-=delta;
		}
		ret+=delta*dis[dest];
	}
	return (ret);
}

int a[111][111];
int n,m=0,an;

inline void init() {
	cin>>n;
	for(re int i=1; i<=n; ++i) {
		for(re int j=1; j<=n; ++j) {
			cin>>a[i][j];
			if(i<j&&a[i][j]>1) ++m;
		}
	}
}

inline void print() {
	cout<<an<<'\n';
	for(re int i=1; i<=n; ++i) {
		for(re int j=1; j<=n; ++j) {
			cout<<a[i][j]<<' ';
		}
		cout<<'\n';
	}
}

inline void work1() {
	int k=0;
	prepare(m+n+2,0,m+n+1);
	for(re int i=1; i<=n; ++i) {
		for(re int j=i+1; j<=n; ++j) {
			if(a[i][j]<2) {
				if(a[i][j]) add(src,m+j,1,0);
				else add(src,m+i,1,0);
			} 
			else {
				++k;
				add(src,k,1,0);
				add(k,m+i,1,0);
				add(k,m+j,1,0);
			}
		}
	}
	for(re int i=1; i<=n; ++i) {
		for(re int j=1; j<=n; ++j) {
			add(m+i,dest,1,j*2-1);
		}
	}
	an=n*(n-1)*(n-2)/3+n*(n-1)/2;
	an=(an-work2())/2;k=0;
	for(re int i=1; i<=n; ++i) {
		for(re int j=i+1; j<=n; ++j) {
			if(a[i][j]>1) {
				for(re int l=head[++k]; l>=0; l=next[l]) { 
					if(!flow[l]) {
						if(ver[l]-m==i) a[j][i]=1,a[i][j]=0;
						else a[i][j]=1,a[j][i]=0;
					}
				}
			}
		}
	}
	print();
	return;
}

int main() {
	init();
	work1();
	return 0;
}

/*
3
0 1 2
0 0 2
2 2 0
*/
```

---

## 作者：Infiltrator (赞：1)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P4249)

------------

# Solution

首先发现直接求这种三元组不打好求，那么考虑球不满足这种关系的三元组的数量。

注意到一个三元组，如果不满足这种关系，肯定分别赢了$0$，$1$，$2$场。

那么我们如果知道了每个人赢的场数$y_i$，不具有这种关系的三元组数量就是$\sum \frac{y_i \times (y_i - 1}{2}$。

因为要使满足这种关系的三元组数量最多，所以我们建立的合法方案要使$\sum \frac{y_i \times (y_i - 1}{2}$最小。考虑用网络流来求解。

首先要满足是一种合法方案，可以这样建模，首先每个人向$T$连一条容量为$n$的有向边，然后对于一个还没有发生的比赛，新建一个节点$tmp$，从$tmp$分别向$i$和$j$连一条容量为$1$的有向边，从$S$向$tmp$链接一条容量为$1$的有向边。这样建模跑出来的最大流就是一种合法方案。

现在考虑如何在跑最大流的时候使$\sum \frac{y_i \times (y_i - 1)}{2}$最小，将每个人向$T$连的有向边拆成容量为$1$的若干条有向边，费用分别为$0$，$1$，$2 \dots$这样连边是因为如果一个人的胜利场数增加一，$\frac{y_i \times (y_i - 1}{2}$的变化会呈现一种等差数列的形式，而这样将边拆开，每次只会增广费用最小的一条路，所以能保证正确性。

需要注意的是，如果一个人本来有一些胜利场数，要在原先的胜利场次基础上进行拆边和建模。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

#define int long long

const int INF = 999999999;
const int N = 1000050;
const int M = 2000050;

int n, s, t, head[N], cur[N], d[N], vis[N], a[500][500], num = 1, cnt, y[N], ans, maxflow, mincost, neww[N][3], diao;

struct Node
{
	int next, to, flow, dis;
} edge[M * 2];

void Addedge(int u, int v, int w, int c)
{
	edge[++num] = (Node){ head[u], v, w, c};
	head[u] = num;
}

void Add(int u, int v, int w, int c)
{
	Addedge(u, v, w, c);
	Addedge(v, u, 0, -c);
	return; 
}

template <class T>
void Read(T &x)
{
	x = 0; int p = 0; char st = getchar();
	while (st < '0' || st > '9') p = (st == '-'), st = getchar();
	while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();
 	x = p ? -x : x;
 	return;
}

template <class T>
void Put(T x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) Put(x / 10);
	putchar(x % 10 + '0');
	return; 
}

void Work(int x)
{
	for (int i = y[x] + 1; i <= n; i++)
	{
		Add(x, t, 1, i - 1);
	}
	return;
}

int Bfs()
{
	queue<int> q;
	for (int i = 0; i <= cnt; i++) d[i] = INF, vis[i] = 0;
	d[s] = 0; vis[s] = 1; q.push(s);
	while (!q.empty())
	{
		int u = q.front(); q.pop(); vis[u] = 0;
		for (int i = head[u]; i; i = edge[i].next)
			if (edge[i].flow > 0 && d[edge[i].to] > d[u] + edge[i].dis)
			{
				d[edge[i].to] = d[u] + edge[i].dis;
				if (!vis[edge[i].to])
				{
					vis[edge[i].to] = 1;
					q.push(edge[i].to);
				}
			}	
	} 
	return d[t] != INF;
}

int Dinic(int x, int flow)
{
	if (x == t || !flow) return flow;
	int rest = flow, k;
	vis[x] = 1;
	for (int i = cur[x]; i && rest; i = edge[i].next)
	{
		int v = edge[i].to;
		cur[x] = i;
		if (!vis[edge[i].to] && edge[i].flow > 0 && d[edge[i].to] == d[x] + edge[i].dis)
		{
			int v = edge[i].to;
			int k = Dinic(v, min(rest, edge[i].flow));
		//	if (!k) dis[edge[i].to] = INF;
			rest -= k;
			edge[i].flow -= k;
			edge[i ^ 1].flow += k;
			mincost += k * edge[i].dis;
		}
	}
	vis[x] = 0;
	return flow - rest;
}

void Solve()
{
	while(Bfs())
	{
		for (int i = 0; i <= cnt; i++) cur[i] = head[i]; 
		maxflow += Dinic(s, INF);
	}
	return; 
}

signed main()
{
	Read(n);
	cnt = n + 1;
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= n; j++)
		{
			Read(a[i][j]);
			if (a[i][j] == 1) y[i]++;
		}
	s = 0; t = n + 1;
	for (int i = 1; i <= n; i++) ans += y[i] * (y[i] - 1) / 2, Work(i);
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++)
			if (a[i][j] == 2)
			{
				int tmp = ++cnt;
				neww[++diao][1] = i;
				neww[diao][2] = j; 
				Add(s, tmp, 1, 0);
				Add(tmp, j, 1, 0); 
				Add(tmp, i, 1, 0);
				neww[diao][0] = num;
			} 
	Solve();
	ans += mincost;
	Put(n * (n - 1) * (n - 2) / 6 - ans); putchar('\n');
	for (int i = 1; i <= diao; i++) a[neww[i][1]][neww[i][2]] = edge[neww[i][0]].flow > 0 ? 1 : 0, a[neww[i][2]][neww[i][1]] = a[neww[i][1]][neww[i][2]] ^ 1;
 	for (int i = 1; i <= n; i++) 
	{
		for (int j = 1; j <= n; j++)
			Put(a[i][j]), putchar(' ');
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：james1BadCreeper (赞：0)

如果一个三元组不是三元环，那么有一个点的出度为 $2$。假定一个点的出度为 $d$，那么它会使得三元环减少 $\frac{d(d-1)}{2}$，那么最终答案为：

$$
\binom n 3 - \sum_{i=1}^n \frac{d(d-1)}{2}
$$

考虑最小费用最大流。每个人向汇点连容量为 $n$ 的边，源点向每个不确定的边连边、边向两个人连边，容量均为 $1$。

一个人的贡献可以看成 $0+1+\cdots+d_i-1$，这是等差数列的费用。套路地，考虑拆点，拆成 $n$ 个，费用依次为 $0,1,\cdots,n-1$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m; 
int a[105][105], d[105], id[105][105]; 

struct Graph {
    struct edge {
        int u, v, w, c;
        edge(int u = 0, int v = 0, int w = 0, int c = 0) : 
            u(u), v(v), w(w), c(c) {}
    };

    int n, m, s, t, cur[7005], d[7005];
    bool inq[7005];
    vector<int> G[7005];
    vector<edge> edges;

    inline void addedge(int u, int v, int w, int c) {
        edges.emplace_back(edge(u, v, w, c));
        G[u].emplace_back(edges.size() - 1); 
        edges.emplace_back(edge(v, u, 0, -c));
        G[v].emplace_back(edges.size() - 1); 
    }

    bool SPFA(void) {
        memset(cur, 0, sizeof(cur));
        memset(d, 0x3f, sizeof(d));
        queue<int> q; q.push(s); d[s] = 0; inq[s] = true;
        while (!q.empty()) {
            int u = q.front(); q.pop(); inq[u] = false;
            for (int i = 0; i < G[u].size(); ++i) {
                edge &e = edges[G[u][i]];
                if (e.w && d[e.v] > d[u] + e.c) {
                    d[e.v] = d[u] + e.c;
                    if (!inq[e.v]) q.push(e.v), inq[e.v] = true;
                }
            }
        }
        return d[t] < 0x3f3f3f3f;
    }

    int cost;
    bool vis[7005];
    int dinic(int x, int res) {
        if (x == t) return res;
        int flow = 0; vis[x] = true;
        for (int i = cur[x]; i < G[x].size() && res; ++i) {
            edge &e = edges[G[x][i]]; cur[x] = i;
            int c = min(res, e.w);
            if (!vis[e.v] && c && d[e.v] == d[x] + e.c) {
                int k = dinic(e.v, c);
                flow += k; cost += k * e.c; res -= k;
                edges[G[x][i]].w -= k; edges[G[x][i] ^ 1].w += k;
            }
        }
        if (!flow) d[x] = 0x3f3f3f3f; vis[x] = false;
        return flow;
    }
    int MCMF(int S, int T) {
        s = S; t = T; 
        int maxflow = 0, flow;
        while (SPFA()) while (flow = dinic(s, 1e9)) maxflow += flow;
        return cost; 
    }
} G;

int main(void) {
    ios::sync_with_stdio(0); 

    cin >> n; int S = 0, T = 7001; 
    for (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) {
        cin >> a[i][j]; 
        if (a[i][j] == 1) ++d[i]; 
    }
    for (int i = 1, idx = n; i <= n; ++i) 
        for (int j = i + 1; j <= n; ++j) if (a[i][j] == 2) {
            G.addedge(S, ++idx, 1, 0); 
            G.addedge(idx, i, 1, 0); id[i][j] = G.edges.size() - 2; 
            G.addedge(idx, j, 1, 0); id[j][i] = G.edges.size() - 2; 
        }
    int ans = 0; 
    for (int i = 1; i <= n; ++i) {
        ans += d[i] * (d[i] - 1) / 2; 
        for (int j = d[i] + 1; j <= n; ++j)
            G.addedge(i, T, 1, j - 1); 
    }
    ans += G.MCMF(S, T); 
    cout << n * (n - 1) * (n - 2) / 6 - ans << "\n"; 
    for (int i = 1; i <= n; ++i, cout << "\n")
        for (int j = 1; j <= n; ++j, cout << " ") {
            if (a[i][j] < 2) cout << a[i][j]; 
            else cout << 1 - G.edges[id[i][j]].w; 
        }
    return 0;
}
```

---

## 作者：Basori_Tiara (赞：0)

很巧妙的竞赛图。

竞赛图有一个优秀的性质，考虑对于三个点，什么情况下三个点是一个三元环，是不是这三个点构成的连通子图中，所有点的出度都为 $1$？

但是我们对于一个点根本没办法统计别的点的出入度啊，我们就只能正难则反，因为三元环的条件是苛刻的但不是三元环的条件反而是宽松的，我们只需要两个出度就能解决，因为如果三个点不是三元环说明有两条边在对着干，另一条边不管怎么选方向最后三个点分别是一个两个出度的点，一个两个入度的点和一个一个出度一个入度的点，因为一个出度一个入度的点比较难操作，所以我们以两个出度作为统计条件。

我们考虑假设一个点出度为 $d$，那么他就有 $C_d^2$ 种搭配使得这些不是三元环，那么最后三元环总数就是 $C_{n}^3-\sum_{i=1}^nC_{d_i}^2$，而 $C_n^3$ 是不变的，我们的问题变成了操縦边的方向使得 $\sum_{i=1}^nC_{d_i}^2$ 最小。

操縦边的方向，看着是操縦边的方向，但我们转化后就变成了分配一个出度给一个点。

现在这个东西就很像一个网络流模型了，限制是一个出度给一个点这样的。

那么我们把出度给到一个点了，我们怎么保证我们要求的$\sum_{i=1}^nC_{d_i}^2$ 啊！

这里有一个巧妙的转化，$C_x^2=\frac{x(x-1)}{2}=1+2+\dots+(x-1)$。

那我们就每个点朝汇点连 $n$ 条边，其中第 $i$ 条的费用为 $i-1$，流量为 $1$，这样每次费用流的时候都会贪心选出 $x$ 条费用最小的边流，也就达成了上面这个式子了，这个我觉得正常人简直想不出来，反正我肯定想不出来。

就是这样了。

不过费用流的时间复杂度为 $O(nmf)$，这题点数边数流量都是 $n^2$ 级别，这居然还能跑过，信仰的力量啊。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
class LTDZ
{
public:
   int cnt = 1;
   int s, t, n;
   int E[100005];
   int nxt[100005];
   int head[100005];
   int flow[100005];
   int cost[100005];
   int pos[100005];
   bool vis[100005];
   int dep[100005];
   int in[100005];
   int N[100005];
   void addedge(int u, int v, int fl, int co)
   {
      cnt++;
      E[cnt] = v;
      flow[cnt] = fl;
      cost[cnt] = co;
      nxt[cnt] = head[u];
      head[u] = cnt;
      return;
   }
   void Add(int u, int v, int fl, int co)
   {
      addedge(u, v, fl, co);
      addedge(v, u, 0, -co);
   }
   bool SPFA()
   {
      queue<int> q;
      q.push(s);
      for (int i = 1; i <= n; i++)
      {
         dep[i] = 1e16;
      }
      dep[s] = 0;
      in[s] = true;
      while (!q.empty())
      {
         int t = q.front();
         in[t] = false;
         q.pop();
         for (int i = head[t]; i; i = nxt[i])
         {
            int v = E[i];
            int fl = flow[i];
            int co = cost[i];
            if (fl && dep[t] + co < dep[v])
            {
               dep[v] = dep[t] + co;
               if (!in[v])
               {
                  in[v] = true;
                  q.push(v);
               }
            }
         }
      }
      return dep[t] < 10000000000000000;
   }
   int ansflow, anscost;
   int dfs(int cur, int mini, int Pre)
   {
      vis[cur] = true;
      if (cur == t)
      {
         ansflow += mini;
         return mini;
      }
      int fl = 0;
      for (int i = pos[cur]; i; i = nxt[i])
      {
         pos[cur] = i;
         if (i == Pre)
            continue;
         int v = E[i];
         int F = flow[i];
         int C = cost[i];
         if (F && dep[cur] + C == dep[v] && (!vis[v] || v == t))
         {
            int tmp = dfs(v, min(mini - fl, F), i ^ 1);
            if (tmp)
            {
               flow[i] -= tmp;
               flow[i ^ 1] += tmp;
               anscost += C * tmp;
               fl += tmp;
               N[cur] = v;
               if (fl == mini)
               {
                  break;
               }
            }
         }
      }
      return fl;
   }
   void dinic()
   {
      while (SPFA())
      {
         do
         {
            for (int i = 1; i <= n; i++)
            {
               pos[i] = head[i];
               vis[i] = false;
               N[i] = 0;
            }
            dfs(s, 1e16, 0);
         } while (vis[t]);
      }
      return;
   }
} G;
int n;
vector<int> need;
struct node{
   int u,v;
}E[100005];
int mp[105][105];
signed main(){
   scanf("%lld",&n);
   G.s=n*(n-1)+n+1;
   G.t=n*(n-1)+n+2;
   G.n=G.t;
   int cnt=0,pos=0;
   for(int i=1;i<=n;i++){
      for(int j=1;j<=n;j++){
         int x;
         scanf("%lld",&x);
         mp[i][j]=x;
         if(j<=i)continue;
         G.Add(G.s,++cnt,1,0);
         switch(x){
            case 0:{
               G.Add(cnt,n*(n-1)+j,1,0);
               break;
            }
            case 1:{
               G.Add(cnt,n*(n-1)+i,1,0);
               break;
            }
            case 2:{
               G.Add(cnt,n*(n-1)+i,1,0);
               G.Add(cnt,n*(n-1)+j,1,0);
               need.push_back(G.cnt);
               E[pos++]=node{i,j};
               break;
            }
         }
      }
   }
   for(int i=1;i<=n;i++){
      for(int j=1;j<=n;j++){
         G.Add(n*(n-1)+i,G.t,1,j-1);
      }
   }
   G.dinic();
   printf("%lld\n",n*(n-1)*(n-2)/2/3-G.anscost);
   for(int i=0;i<pos;i++){
      int u=E[i].u,v=E[i].v;
      if(G.flow[need[i]]){
         mp[u][v]=0;
         mp[v][u]=1;
      }
      else{
         mp[u][v]=1;
         mp[v][u]=0;
      }
   }
   for(int i=1;i<=n;i++){
      for(int j=1;j<=n;j++){
         printf("%lld ",mp[i][j]);
      }
      puts("");
   }
   return 0;
}
```

---

## 作者：撤云 (赞：0)

[点我食用效果跟佳](https://www.cnblogs.com/hbxblog/p/11112246.html)

### $Solution$

直接求很明显不太好求，于是考虑不构成剪刀石头布的情况。

我们现在假设一个人$i$赢了$x$场，那么就会有$\frac{x*(x-1)}{2}$

我们现在要最小化$\frac{x*(x-1)}{2}$

~~这样就很明显是费用流了吧~~

我们先不管费用

对于每个人向$T$连边，流量为$n$

队$i,j$之间的比赛建立点$y$,$s$向$y$连边，若比赛结果不确定则将$y$分别向$i$和$j$连边。如果确定则向赢的人连边,流量都为$1$

但是$\frac{x*(x-1)}{2}$这个花费不太好表示，因为他不是固定的。

于是可以想到拆边。我们将每个人向$T$连的边拆成$n$条，每条边容量为$1$，费用分别为$0,1,2,3...n-1$

### $Code$

``` cpp
#include<bits/stdc++.h>
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
const int inf=1e9;
const int N=1.1e4+5;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
struct node{
    int to,next,v,w;
}a[2000001];
int head[N],cnt=1,n,m,s,t,x,y,z,tot,minx,maxx,dis[N],f[N],pre[10001],fa[10001];
void add(int x,int y,int c,int v){
    a[++cnt].to=y,a[cnt].next=head[x],a[cnt].v=c,a[cnt].w=v,head[x]=cnt;
    a[++cnt].to=x,a[cnt].next=head[y],a[cnt].v=0,a[cnt].w=-v,head[y]=cnt;
}
queue<int>q;
int spfa(){
    q.push(s);
    memset(dis,127,sizeof(dis));
    memset(f,0,sizeof(f));
    f[s]=1,dis[s]=0;
    int inf=dis[s+1];
    while(!q.empty()){
        int now=q.front();
        q.pop();
        f[now]=0;
        for(int i=head[now];i;i=a[i].next){
            int v=a[i].to;
            if(dis[v]>dis[now]+a[i].w&&a[i].v){
                dis[v]=dis[now]+a[i].w,pre[v]=i,fa[v]=now;
                if(!f[v])
                    f[v]=1,q.push(v);
            }
        }
    }
    if(dis[t]!=inf)
        return 1;
    return 0;
}
int ans1,ans;
void answer(){
    while(spfa()){
        int minx=2147483647;
        for(int i=t;i!=s;i=fa[i])
            minx=min(minx,a[pre[i]].v);
        ans+=minx,ans1+=dis[t]*minx;
        for(int i=t;i!=s;i=fa[i])
            a[pre[i]].v-=minx,a[pre[i]^1].v+=minx;
    }
}
int M[1001][1001],vis[1001][1001];
int main(){
    n=read();
    s=0,tot=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            M[i][j]=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<i;j++){
            tot++,add(s,tot,1,0);
            if(M[i][j]!=1) add(tot,i,1,0),vis[j][i]=cnt-1;
            if(M[i][j]!=0) add(tot,j,1,0),vis[i][j]=cnt-1;
        }
    t=tot+n;
    for(int i=1;i<=n;i++)
        for(int j=0;j<n;j++)
            add(i,t,1,j);
    answer();
    cout<<(n)*(n-1)*(n-2)/6-ans1<<endl;
    for(int i=1;i<=n;i++,cout<<endl)
        for(int j=1;j<=n;j++){
            if(M[i][j]<2) cout<<M[i][j]<<" ";
            else printf("%d ",!vis[i][j]||a[vis[i][j]].v?0:1);
        }
}
```

---


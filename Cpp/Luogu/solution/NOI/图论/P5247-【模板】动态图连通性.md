# 【模板】动态图连通性

## 题目背景

这是 [LOJ #122](https://loj.ac/problem/122) 的一个非官方、**不维护**的镜像，原始出题人是 EtaoinWu ，在本站的原始上传者未知。这个镜像题的数据不保证是最新的，因此推荐到 LOJ 进行练习。

## 题目描述

这是一道模板题。

你要维护一张无向简单图（即没有自环，没有重边的无向图）。你被要求加入删除一条边及查询两个点是否连通。

$0.$：加入一条边。保证它不存在。   
$1.$：删除一条边。保证它存在。   
$2.$：查询两个点是否联通。   

为了保证做法的在线性，本题采用了特殊方式的读入。

假设你维护了一个变量 $\text{last}$，初始值为 $0$ 。

对于每个读入的节点 $x$，实际上询问、修改的节点编号是 $x \text{ xor } \text{last}$，其中 $\text{xor}$ 是二进制异或操作。

对于每次解码之后查询 $u,v$，如果它们联通，那么 $\text{last}$ 会被更新为 $u$；否则会被更新为 $v$。

## 说明/提示

由于hack数据的加入，数据分布并非如下文所述。下面的仅供参考。

对于数据点 $1$，$n \leq 200,m \leq 200$

对于数据点 $2$，$n=5,m \leq 30$

对于数据点 $3$，$n=10,m \leq 1000$，其中查询的次数 $\geq 900$ 次。

对于数据点 $4$，$n=300,m \leq 50000$

对于数据点 $5$，$n=5000,m \leq 200000$，没有操作 $1$，其中约 $70 \%$ 是操作 $2$。

对于数据点 $6$，$n=5000,m \leq 200000$，没有操作 $1$，其中约 $70 \%$ 是操作 $0$。

对于数据点 $7$、$8$，$n=100,m \leq 500000$

对于数据点 $9$，$n=5000,m \leq 500000$，图是一棵树，其直径 $\leq 30$ 。

对于数据点 $10$， $n=5000,m \leq 500000$，图是一棵树，其每个点度数 $\leq 10$。

还有一些保证 $n \leq 5000,m \leq 500000$ 的附加数据。

## 样例 #1

### 输入

```
200 5
2 123 127
0 4 0
2 4 0
1 4 0
2 0 4```

### 输出

```
N
Y
N```

## 样例 #2

### 输入

```
4 10
0 1 2
0 2 3
0 3 1
2 1 4
0 0 7
2 5 0
1 3 2
2 0 5
1 0 2
2 0 5```

### 输出

```
N
Y
Y
N```

# 题解

## 作者：jerry3128 (赞：61)

## 复杂度均摊的 Holm-de Lichtenberg-Thorup 分层图算法
- Video Access: [here](https://www.bilibili.com/video/BV17Te1evEk3)
- 我们给定每条边一个权值。保证它的上界在 $\log{n}$ ，这个值越大，就说明这条边在越多的判断中没有发挥作用。所有边一开始权值都为 $0$。那么我们就得到了分层图，所有边可以向下合并。显然，连通性只需要一颗树就可以维护，所以我们应该维护的是这个图的生成树森林。
- 定义 $G_i$ 表示所有边权大于等于 $i$ 的边构成的图，$F_i$ 表示 $G_i$ 的最大生成树。
- 那么我们不难发现:
	- $G_{i+1}\in G_{i}$
	- $G_{i}$ 与 $F_{i}$ 的连通性相同。
   - $F_{i}=G_{i}\cap F_{0}$，$F_{i}$ 一定为 $G_{i}$ 最大生成树。

------------
在有了以上的性质以后，我们就可以正式地开始了。
- 显然，这题难的是删边，加边和询问直接在 $G_{0}$ 操作就行。
- 而删边，如果它破坏了原有图形生成树的连通性，我们就得遍历所有可能的边，来看它是否能够重新“代替”这条边。
- 而反观 $F_{i}$ 为最大生成树的性质，所以如果有边能够“代替”这条边，那么它的权值一定小于等于当前边，否则它应该在最大生成树中。
- 在找边的过程中，我们遍历较小的树的一边的边，我们查找的每一条边，如果能够代替，就在 $F_{i}$ 中连上这条边，否则就将它的权值加 1。
- 依次查找 $G_{i},G_{i-1}...G_{0}$ 直到找出来。
- 在查找时，我们还需要 tag 来表示当前节点及其子树是否有可能更新的边，不能直接遍历子树，否则复杂度就是错误的。

------------
- Q：听说要用 ETT，如果我不会怎么办？
- A：~~你可以学~~维护子树 LCT 好像也行，但我没有实现。
- Q： BFS 不香吗？
- A：香，怎么不香，~~但这样怎么涨社区的分呀~~。

------------
以下是更新内容：

#### 复杂度的一些分析
-----
- 我们将图上的所有的非树边取出来。
- 设我们当前正在处理第 i 层边。
- 在每次断边的时候我们遍历小子树，将当前无用边的权值加一。
- 那么在权值更大的一层图中，两点所在的 $F_{i+1}$ 一定连通。
- 又由于当前这条边属于 $F_{i}$ 中较小的一个连通块，所以在 $F_{i+1}$ 的连通块中，当前边所在的块大小一定小于 $F_{i}$ 所在大小的一半。每一层减少一半，故分层图只需 $\log n$ 层，每条边也做多上升 $\log n$ 次。
- 在任意一个森林中我们要找到一条边(的一个端点)的复杂度均摊是 $\log n$，每条边只会被找 $\log n$ 次，所以总复杂度 $O(\log ^{2} n)$，这也是为什么要用 tag 记录是否存在边，这样上面找边的复杂度才能摊下来。
- 论文上的复杂度是 $O(\frac{\log^{2} n}{\log \log n})$，查询很简单 $O(\log n)$。

#### 维护动态树的数据结构的一些乱扯
-----
- 动态树一般指 LCT，但是在这道题当中如果使用 LCT，我们就必须要在寻找一个子树或者说虚儿子子树内的标记节点，并且仍然做到 $O(\log n)$，这就需要选手掌握较(自)为(适)高(应)深(顶)的(树) LCT 维护技巧。
- 这题对动态树的 link cut 灵活性要求比较强，不是简单地换父亲，而括号序和欧拉序都会在换根的时候打乱儿子的顺序还有自己节点出现的先后顺序。
- 我们考虑如何维护一个快速的动态树，有子树信息。
- 因为我们只需要维护连通性，即当前节点射出去的一条无向边。所以实际上来讲我们并不关心它在 ETT 有什么入或者什么出的性质，我们只关心这个点的编号，还有这条边的信息，这两个信息即可。
- 也就是说我们不论用欧拉序或者括号序换根，儿子顺序被打乱这对我们没有任何影响。我们挂边的时候直接在它所有出现的节点中随便选一个节点挂上去就行了，这样我们找边均摊仍然是 $O(\log n)$ 的，没有影响我们上面的复杂度分析。
- 所以我们可以直接用 ETT 进行维护，换根直接区间平移即可。

upd on 2021.7.23 : 修改了原算法的一些描述与增加后面的复杂度分析，还有 ETT。

### 最后来讲一些实现问题。

有上面的结论可以的到 ETT 和 LCT 都可以，现在我们来分别讨论一下。

#### Link - Cut - Tree
- 考虑 LCT 做一个子树 search 的时候，虚儿子的信息比较难进行查找。
- 我们可以考虑用一个 set 存储虚儿子中的任意一个标记点，然后上传，但是由于二叉树形分治结构的特殊性，我们得使儿子中结构不同时，传上来的却是同一个值。
- 我这里采用的是传的最小的标记节点。
- 每次做 search 的时候就暴力 access 过去，这样一定会整个连通块当中的标记点全部扫过。
- 但是注意，set 无法均摊进入 LCT 的复杂度当中。时间复杂度 $\mathcal O(n\log^{3}n)$，如果想要优化可以运用 Top Tree 的技巧优化到 $\mathcal O(n \log^{2}n)$。
- 但是这种方法一定是最好写的，没有编号的映射，没有树形结构转为线性的转化。
- [code:Link - Cut - Tree,Version](https://www.luogu.com.cn/paste/6pc21m9t)

#### Euler - Tour - Tree  Splay
- 考虑使用 splay 对 ETT 进行维护。splay 是动态树的好般配，应该会是大多数人的第一选择。
- 但是考虑这道题上面，我们在做 search 的时候同时会进行对信息的查询，也就会遍历路径。如果要做到保证复杂度的话就一定要 **精细实现** ，也就毒瘤了亿点点，这边还是建议使用 FHQ，splay 的实现比较复杂和精细。
- [code:Euler - Tour - Tree,splay,Version](https://www.luogu.com.cn/paste/gao91hcu)

#### Euler - Tour - Tree FHQ
- 考虑 FHQ，它原本就有复杂度合法的高度，也就是说我们如果在遍历的时候查询信息也能同时更新。
- 在本题上实现较为方便。但是由于 ETT 自身的复杂性，还是写起来比 LCT 麻烦的多。
- [code:Euler - Tour - Tree,FHQ,Version](https://www.luogu.com.cn/paste/8oryigsf)




## 随机击中割边集合 cutset 结构做法

- 考虑我们当前所面临的的问题，仍然是如何找到一条被割掉的边的代替边。
- 首先我们来看一下下面的模型：

>  给定一个图 $G(V,E)$，和图的一个连通点集 $T \subset V$，我们称 $cutset(T)$ 表示有且仅有一边端点在点集 $T$ 以内的节点的边集，我们把边集内的边称为“割边”。
>
> 那么，如果**恰好**存在**一条**这样的边，那么是不是我们将边进行编号后，每个节点存储所有与他相连的边的编号异或和，$xor(T)$ 就是那条割边的编号。

- 这个方法看上去恰好击中割边的概率实在是太小了，而且受“恰好”限制。
- 首先我们考虑如何在有多条割边的情况下找到一条割边。
- 因为 $xor$ 运算就是数论性质的破坏狂魔，我们根本不能从“解密”的方面下手。那么就只有从加入边的地方下手了，我们需要维护不同的边集使得 $T$ 与外界只有一条边相连，也就是说我们要舍弃一些边的信息。
- 但是又不能真的舍弃，于是我们又考虑维护一个非均摊分层图。每一层当中的边，有二分之一的概率上升到更高一级的图层。（此处我们实现的时候手操一下 $B$ 层，$B$ 与 $\log n$ 同阶）
- 那么我们就得到了一个正确性有待证明的解法：
  - 维护分层图，其中只维护一颗生成树用于表示树边和连通点集，那么显然非树割边就是我们要找的代替边。
  - 有边加入就随一个编号，然后对于两个端点异或上去，如果两边不连通，则再加入树边。
  - 有边删除就对于两个端点异或上去，如果是树边就断掉树边并执行一个查找代替边的过程（就是维护子树异或和，令子树中连通点集为 $T$）。
  - 考虑查找代替边：我们显然会碰到下面三种情况。
    1. $xor(T)=0$，大概率 $T$ 就独立了，没边连出去，结束查询。
    2. $xor(T)=I$，（$I$ 有边的编号映射），大概率 $I$ 就是代替边，验证后结束查询。
    3. $xor(T)=I$，（$I$ 无边的编号映射），那说明 $T$ 有很多条连出去的边，但是我们不能确定一条实际的边。这个时候分层图就有作用了，我们考虑在升高一层的图中去查找代替边。
- 复杂度 $O(nB\log n)$，维护连通子集需要一个维护动态树为基础的数据结构，然后 $B$ 层图每层都需要维护信息。正确性的求解过程由于笔者水平有限，具体参考 wikipedia，为 $(\frac{8}{9})^{\lg n}$，那么选取一个合适的参数 $C$ 使得 $(\frac{8}{9})^{C\lg n}$ 趋近于 $0$，得到合法方案。
- 算法的大致流程就是这样。在实现过程中需要一些较好的随机方式来解决各种随机数的冲突与分布情况。具体可以参考代码，在我的实现方法中，$C=12，B=12$ 能够通过 $luogu$ 数据，$loj$  由于 hack 数据的存在在只改变 $B,C$  的情况下遗憾离场，hack 数据 最快一次跑了 $22s$。
- 本算法的优点是脱离了均摊分析，将维护子树的 LCT 载体换为可持久化 ETT 即可完成可持久化动态图的完全连通性。缺点是常数巨大，空间占用较大，对随机方式要求较高。
- 优化方向：
  - 随机上的优化，让程序的“随机”参数更贴近理论分析。
  - 结构上的优化，让 $cutset$ 结构查找割边有更高的效率和正确。
- [code:Link - Cut - Tree,cutset structure](https://www.luogu.com.cn/paste/fkoeshxy)

---

## 作者：critnos (赞：26)

终于跑到了最优解！（2020.4.6）

https://www.luogu.com.cn/record/32515941

2.09s（开 O2）

### 1 图的存储方法

邻接表，没话说的。

那么邻接表用什么方式实现呢？

下面是我实测或推想出来的结果，速度越快排名越前：

链式前向星 > 玄学优化的 vector > list > unordered_set（就是 STL 的哈希表） > set 

为啥要这么多奇奇怪怪的数据结构呢？

因为还有删除操作。

~~如果没有删除操作随便写个并查集不就行了吗~~

这个结果让我很意外，因为 set/unordered_set 的删除应该是很快的，但是反而让其他线性删除的数据结构占了上风。

我估计是因为，每个点的边不会太多，而 set/unordered_set 的常数太大，所以不如其他的数据结构。

所谓“玄学优化的 vector”，其实就是 vector 实现的伪平衡树，常数极小。

### 2 判断两点联通

#### 2.1 DFS

这个是最慢的了，只能拿 $84\;\text{pts}$。

https://www.luogu.com.cn/record/29921684

#### 2.2 BFS

快了很多，拿了 $94\;\text{pts}$。

但是当时滥用 STL，而且还用的是 list，慢了很多。

https://www.luogu.com.cn/record/29922114

#### 2.3 双向 BFS

很快。

因为已知起点，又已知终点，所以可以从两端同时开始搜索。

先拓展一边的状态，再拓展另一边……这样反复进行，会比只从一边开始快很多。

https://www.luogu.com.cn/record/29922620

这是我两个月前写的，最近又做了一些优化。

### 3 优化

#### 3.1 卡常

快读，使用 putchar 而不用 printf，inline，这些都是必须的。

#### 3.2 少用 STL

把双向 BFS 的队列用数组模拟。

因为两个队列顶多只用 $n$ 的空间（顶多只有 $n$ 个点），所以不用什么循环队列，直接用两个指针模拟。

#### 3.3 善用 STL

~~想必大家都用 vector 水过平衡树板子吧~~

~~可惜 mrsrz 姐姐加强的板子卡掉了 vector~~

vector 的删除和插入操作是极快的，所以用 vector 来实现效果相当好。

下面是经过了优化的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> a[5005];
int t[5005];
int xd[5005],yd[5005];
inline int read()
{
   int s=0;
   char ch=getchar();
   while(ch<'0'||ch>'9') ch=getchar();
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s;
}
inline int find(int x,int y)
{
	register int f,i,l1,r1,l2,r2;
	l1=r1=l2=r2=0;
	xd[r1++]=x,yd[r2++]=y;
	t[x]=1;
	t[y]=2;
	if(x==y) return 1;
	for(;;)
	{
		if(l1==r1) break;
		f=xd[l1++];
		for(i=0;i<a[f].size();i++)
		{
			if(t[a[f][i]]==2) return 1;
			if(t[a[f][i]]==0)
			{
				xd[r1++]=a[f][i];
				t[a[f][i]]=1;
			}
		}	
		if(l2==r2) break;
		f=yd[l2++];
		for(i=0;i<a[f].size();i++)
		{
			if(t[a[f][i]]==1) return 1;
			if(t[a[f][i]]==0)
			{
				yd[r2++]=a[f][i];
				t[a[f][i]]=2;
			}
		}	
	}
	return 0;
}
int main()
{
	register int last=0,o,x,y,n,m;
	scanf("%d%d",&n,&m);
	while(m--)
	{
		o=read(),x=read(),y=read();
		x^=last,y^=last;
		if(o==0)
		{
			a[x].insert(lower_bound(a[x].begin(),a[x].end(),y),y);
			a[y].insert(lower_bound(a[y].begin(),a[y].end(),x),x);
		}
		if(o==1)
		{
			a[x].erase(lower_bound(a[x].begin(),a[x].end(),y));
			a[y].erase(lower_bound(a[y].begin(),a[y].end(),x));
		}
		if(o==2)
		{
			memset(t,0,sizeof(t));
			if(find(x,y)) 
			{
				putchar('Y'),putchar('\n');
				last=x;
			}
			else
			{
				putchar('N'),putchar('\n');
				last=y;
			}
		}
	}
} 
```


---

## 作者：zghtyarecrenj (赞：23)

### 如果公式炸了就请去洛谷博客看这篇题解。


## 来一篇正经的ETT题解。

窝看到仅有的一篇暴力的题解就生气……这个暴力很脆弱，随便卡就可以卡掉。

前置芝士：ETT（如果你不会，请自行百度，作者会日后写一个学习笔记的，到时候链接附在这里）

## 基本思想

首先考虑我们用什么来维护一个图，把一个图变成一棵树。

那自然可以想到维护生成树。由于可能不太连通，所以我们维护一个生成树的森林。

加边操作不太难，直接在 ETT 里面 link 一下即可。询问也不太难，在 ETT 里面写一个 findroot 函数即可。

但是遇到删边操作的时候，直接处理是不可行的。因为如果在生成树中删掉一条边，我们需要枚举不在生成树中的边看一下是否可以使得删边之后不连通，那时间复杂度就挂了。

如下图，如果删去边 $(2,7)$，则你需要考虑是否存在 $(5,7)$ 这样的边存在使得图仍旧连通。


![](https://cdn.luogu.com.cn/upload/image_hosting/uw72zhl2.png)


那么我们怎么办呢？

考虑建立一个类似分层图的模型。每条边的层不会增加，只会减小。

我们计最高层为 $\log n$，最底层为 $1$。每条新加的边都在 $\log n$ 层。

令 $G_i$ 为层数 $\le i$ 的所有的边和原图中所有点构成的图。显然，$G_{\log n}$ 就是整个的图。

由层数单调递减可知
$$
G_1 \in G_2 \in G_3 \in \cdots \in G_{\log n}
$$
接下来的两个性质保证了算法的复杂度为 $O(\log ^2 n)$。

**【性质1】** $G_i$ 中每个连通块至多有 $2^i$ 条边。这个应该不难脑补吧……试着想一想 $G_1$ 和 $G_{\log n}$。

**【性质2】**我们令 $F_i$ 为 $G_i$ 的生成树（不一定最小），我们可以使用 ETT 来维护 $F_i$。（显然，$F_{\log n}$ 为用于询问的 ETT）。此时，我们有性质：
$$
F_1 \subseteq F_2 \subseteq F_3 \subseteq \cdots \subseteq F_{\log n}
$$
所以
$$
F_i = F_{\log n} \cap G_i
$$
由此可以得出一个有趣的结论：$F_{\log n}$ 为最小生成树。

接下来看操作

## insert( e = ( v, w )​ )

表示 $v$ 到 $w$ 连一条有向边。下文中的 `Graph` 表示 $G_{\log n}$，是一个 `std::set` 的数组，作用类似邻接表。

`F[ i ]` 表示 $F_i$， 是一个 ETT 的森林（你最好封装一下，否则你会疯掉的）。

上代码~（惊不惊喜，是伪代码！）

```c++
Graph[ v ]. insert( e ), Graph[ w ]. insert( e )
e. level = log n
if ( ! F[ log n ]. query( e ) ) 
	F[ log n ]. insert( e )
```

## query( v, w )

不用解释。

```c++
return F[ log n ]. findrt( v ) == F[ log n ]. findrt( w )
```

## delete( e = ( v, w ) )

实际上的程序比这个复杂……

```c++
Graph[ v ]. erase( e ), Graph[ w ]. erase( e )
if ( e \in F[ log n ] )
	for i = e. level to log n do
		F[ i ]. delete( e )
	for i = e. level to log n do
		令 Tv = F[ i ] 中有 v 的那棵树，Tw = F[ i ] 中有 w 的那棵树
		if ( Tv. size > Tw.size ) 
			swap( Tv, Tw ) // 你可以理解 Tv 与 T_w 为指针，所以可以交换。
		for each 第 i 层中的边 e' = ( x, y )
			if ( x \in F[ v ] )
				if ( y \in Tw )
					F[ i ]. insert( e' )
					return
				else 
				if (y \in Tb )
					e'. level = i - 1
```

来解释一下为什么中间一些东西是对的。

因为 $|F_i| \le 2^i$，$T_v, T_w \in F_i$

所以 $|T_v| + |T_w| \le 2^i$

因为 $|T_v| \le |T_w|$

所以 $|T_v| \le 2^{i - 1}$



这个东西的复杂度是 $O(log ^2 n)$，是 delete 的一个 log 和 ETT 的一个 log。

---

## 作者：EnofTaiPeople (赞：22)

在学 Link-Cut-Tree 时刷到了[P5247](/problem/P5247)，只是此题并不需要 LCT，而是对入门选手友好的双向广搜可以通过，于是我来发一波双向广搜的题解。

首先，连边可以使用 vector，具体实现用二分查找即可，满满 STL 的味道：
```cpp
vector<int>lk[N];
#define lb(a,x) lower_bound(a.begin(),a.end(),x)
case 0:lk[x].insert(lb(lk[x],y),y);
lk[y].insert(lb(lk[y],x),x);break;
case 1:lk[x].erase(lb(lk[x],y));
lk[y].erase(lb(lk[y],x));break;
```
至于双向广搜，将搜到的节点赋予一个 type，如果遇到不同的 type 就连通，遇到相同的 type 就不管，如果没有 type 就赋予一个相同的 type，最后将所有 type 清空。

代码加快读快写只有 40 行，1.04KB：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
char buf[N+5],*p1,*p2,c,ob[1000001];
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)
inline void read(int &x){
	x=0;while(!isdigit(c=gc));
	do x=x*10+c-'0';while(isdigit(c=gc));
}
int n,m,q[N],t[N],l,r,las,ot;
vector<int>lk[N];
#define lb(a,x) lower_bound(a.begin(),a.end(),x)
inline bool Fans(int x,int y){
	t[q[l=1]=x]=1,t[q[r=2]=y]=2;
	while(l<=r){
		x=q[l++];
		for(int d:lk[x]){
			if(t[d]){
				if(t[d]!=t[x]){while(r)t[q[r--]]=0;return 1;}
			}else t[q[++r]=d]=t[x];
		}
	}while(r)t[q[r--]]=0;return 0;
}
int main(){
	read(n),read(m);int i,op,x,y;
	while(m--){
		read(op),read(x),read(y),x^=las,y^=las;
		switch(op){
			case 0:lk[x].insert(lb(lk[x],y),y);
			lk[y].insert(lb(lk[y],x),x);break;
			case 1:lk[x].erase(lb(lk[x],y));
			lk[y].erase(lb(lk[y],x));break;
			case 2:if(Fans(x,y))ob[ot++]='Y',las=x;
					else ob[ot++]='N',las=y;
			ob[ot++]='\n';default:break;
		}
	}
	fwrite(ob,1,ot,stdout);
	return 0;
}
```

---

## 作者：searchstar (赞：17)

[jerry3128](https://www.luogu.com.cn/blog/user27338/solution-p5247) 和 [zghtyarecrenj](https://www.luogu.com.cn/blog/zght/solution-p5247) 大佬都讲得很好，但是漏了一些细节。这里简单补充一点。

Holm-de Lichtenberg-Thorup 算法的原始论文：<https://u.cs.biu.ac.il/~rodittl/p723-holm.pdf>

算法的简化描述如下。

给边分层，每条边一开始都在第 0 层，然后之后可以移到上层，定义 $l(e)$ 为边 $e$ 的层号。定义 $G_i$ 为所有层号小于等于 $i$ 的边构成的图。令$F_0$ 为 $G_0$ 的生成树森林，令 $F_i$ 为 $G_i \cap F_0$。令 $T_i$为 $F_i$ 中层号刚好为 $i$ 的边的集合，即层号刚好为 $i$ 的树边的集合。令 $N_i$ 为 $G_i-F_i$ 中层号刚好为 $i$ 的边的集合，即层号为 $i$ 的非树边的集合。下面我们只维护 $F_i$、$T_i$、$N_i$。

我们维护这几个性质：

1. 对任何非树边 $e=(x, y)$，$x$ 和 $y$ 都在 $F_{l(e)}$中连通。

2. $F_i$ 中每个连通分量的节点数最多为 $\lfloor n/2^i \rfloor$，这样最大的层号 $l_{max}$就是 $\lfloor log_2(n) \rfloor$。

3. 对任何树边 $e=(x, y)$，对任何 $i>l(e)$，$x$ 和 $y$ 在 $F_i$中都不连通。

- 查询 $x$ 和 $y$ 是否连通

直接查询 $x$ 和 $y$ 在 $F_0$ 中是否连通即可。

- 插入边 $e = (x, y)$

令 $l(e)=0$，然后判断 $x$ 和 $y$ 是不是连通的，如果连通说明它是非树边，将其加入到 $N_0$ 中。如果不连通说明它是树边，加入到 $F_0$ 和 $T_0$ 中。

- 删除边 $e = (x, y)$

先看 $x$ 和 $y$ 在不在 $N_{l(e)}$ 中，如果在就可以直接从 $N_{l(e)}$ 中删掉它，不影响连通性。

如果不在 $N_{l(e)}$ 中，那肯定在 $T_{l(e)}$中。将其从 $T_{l(e)}$，以及 $F_0, F_1, \cdots, F_{l(e)}$ 中删去。然后我们就要尝试找一条边将 $x$ 和 $y$ 所在的连通分量重新连接起来，由于性质 1 和性质 3，这样的边的层号必须小于等于 $l(e)$。我们从 $l(e)$ 层开始，一直尝试到第 0 层，如果在某层找到了，就成功，否则就失败。

- Reconnect($(x, y)$, $l$)，在第 $l$ 层尝试重新连接 $x$ 和 $y$ 所在的连通分量

假设 $X$ 为 $x$ 所处的连通分量，$Y$ 为 $y$ 所处的连通分量。不失一般性，假设 $X$ 的节点数不多于 $Y$ 的节点数。我们搜索所有在 $X$ 中的非树边 $e = (u, v)$，如果 $v$ 在 $Y$ 中的话，就说明 $e$ 可以连接两个连通分量，将 $e$ 从非树边变成树边，即将 $e$ 从 $N_l$ 中删除，并把 $e$ 加入到 $T_l$ 以及 $F_0, F_1, \cdots, F_l$ 中。

如果 $v$ 不在 $Y$ 中，那肯定在 $X$ 中。我们将 $e$ 移动到上层去，即令 $l(e)$ 自增 1。因为我们要维护性质 1，所以我们要保证 $u$ 和 $v$ 在 $F_{l+1}$ 中连通。我们发现，只要我们让 $X$ 的生成树的所有边都在 $F_{l+1}$ 层中就可以了。所以在开始搜索 $X$ 的非树边前，我们先将 $T_l$ 中在 $X$ 中的边全部移动到 $T_{l+1}$ 中，并且在 $F_{l+1}$中也加入这些边。

我们假设性质 2 在第 $i$ 层成立，即第 $i$ 层中所有连通分量的节点数为 $\lfloor n/2^i \rfloor$。第 $i+1$ 层中的连通分量只在将第 $i$ 层的树边移动到第 $i+1$ 层中时改变，所以我们只要证明在移动过程中变化的连通分量的节点数最多为 $\lfloor n/2^{i+1} \rfloor$ 即可。将第 $i$ 层的树边移动到第 $i+1$ 层时，相当于在第 $i+1$ 层将一些小连通分量合并成一个点集等于 $X$ 中的点集的连通分量，而由于 $X$ 的节点数不超过 $\lfloor n/2^{i+1} \rfloor$，所以第 $i+1$ 层中所有的连通分量的节点数都不超过 $\lfloor n/2^{i+1} \rfloor$。所以性质 2 成立。

由于最大层数为 $O(\log n)$，而且边的层号单调递增，层号不变时，边只会从非树边变成树边。所以每条边我们都只会操作 $O(\log n)$ 次。假如我们可以将每次操作的时间控制在 $O(\log n)$，那么我们就得到了一个插入和删除的均摊时间为 $O(\log^2 n)$ 的算法。

从上面的描述中我们可以看到，对一条边时只有以下几种操作：

1. 查询某点在 $F_i$ 里的哪棵树中。

2. 用这条边将两棵树连起来，或者将这条边删掉，得到两棵树。

3. 将这条边加入到 $N_i$ 中，或者从 $N_i$ 中删掉。

4. 将这条边加入到 $T_i$ 中，或者从 $T_i$ 中删掉。

5. 遍历以 $F_i$ 中指定子树里的节点为端点的 $N_i$ 和 $T_i$ 里的所有边。

其中，查询在哪棵树中，以及在森林里增删树边可以通过用 LCT 或者 ETT 来维护 $F_i$ 实现 $O(\log n)$ 的均摊复杂度。

遍历与指定子树相连的 $N_i$ 和 $T_i$ 中的边时，显然不可以直接遍历这个子树的所有节点，这样每次找到一条边的最坏情况复杂度是 $O(n)$ 的。注意到，我们只需要做到在 $O(\log n)$ 的时间内找到一条边即可。假如我们要遍历与指定子树相连的 $N_i$ 里的边，并且我们用 LCT 来维护 $F_i$，那我们可以在 LCT 中维护 auxiliary tree 的每个子树内的任意一个存在某条 $N_i$ 中的边与之相连的点的编号，将这个编号称为 tag。要找一条与原图中的指定子树相连的 $N_i$ 中的边时，只需要从 auxiliary tree 的根节点中拿出 tag，假设是 $u$，然后找以 $u$ 为端点的 $N_i$ 中的点即可。

LCT 的节点只有指向 preferred child 的指针，没有指向 non-preferred children 的指针，但是维护子树信息需要从 non-preferred children 所在的子树的信息。通常这是通过 Top Tree 来实现的，即用 splay 来合并 non-preferred children 所在的子树的信息，然后通过根将合并后的信息传给节点（参考：<https://www.cnblogs.com/Khada-Jhin/p/9743397.html>）。但是这样代码量太大了。

注意到，我们其实不需要将所有 non-preferred children 所在的子树的信息合并起来，我们只需要从有 tag 的子树中随便选一个，就可以把它的 tag 作为当前节点的 tag 。所以我们只需要在每个节点用一个哈希表来维护所有有 tag 的 non-preferred children 的编号，更新节点 $x$ 的 tag 的流程如下。

```
if (有边连着自己) {
	x.tag = x
} else if (x.left_child.tag != NIL) {
	x.tag = x.left_child.tag
} else if (x.right_child != NIL) {
	x.tag = x.right_child.tag
} else if (x.tagged_non_preferred_children is not empty) {
	c = x.tagged_non_preferred_children里的任意一个元素
	x.tag = c.tag
} else {
	x.tag = NIL
}
```

向 $N_i$ 中插入边时，假如某个点 $u$ 原先没有与之相连的 $N_i$ 中的边，那就 access($u$)，再将这条边插入到 $N_i$ 中，从而保证 tag 都是有效的。同样，删除时，如果某个点 $u$ 原先只有一条与之相连的 $N_i$ 中的边，那就 access($u$)，再将这条边从 $N_i$ 中删掉。

给我的个人博客打个广告：<https://seekstar.github.io/2021/11/20/%E6%B4%9B%E8%B0%B7p5247-%E5%8A%A8%E6%80%81%E5%9B%BE%E5%AE%8C%E5%85%A8%E8%BF%9E%E9%80%9A%E6%80%A7-lct%E8%A7%A3%E6%B3%95/>

完整代码：

```cpp
#include <iostream>
#include <unordered_set>
#include <stack>
#include <unordered_map>
#include <cstring>

using namespace std;

#define MAXN 5011
#define MAX_LEVEL 15

struct LCT {
	int c[MAXN][2], fa[MAXN], sta[MAXN];
	bool r[MAXN];
	// subtree_size2 is the sum of the sizes of non-preferred children's subtrees
	int subtree_size[MAXN], subtree_size2[MAXN];
	struct Tag {
		// Only stores edges of this level.
		unordered_set<int> edges;
		int tag;
		unordered_set<int> tagged_non_preferred_children;
	} tag_tree[MAXN], tag_non_tree[MAXN];

	void update_tag(Tag tags[], int x) {
		if (!tags[x].edges.empty()) {
			tags[x].tag = x;
		} else if (tags[ls(x)].tag) {
			tags[x].tag = tags[ls(x)].tag;
		} else if (tags[rs(x)].tag) {
			tags[x].tag = tags[rs(x)].tag;
		} else if (!tags[x].tagged_non_preferred_children.empty()) {
			tags[x].tag = tags[*tags[x].tagged_non_preferred_children.begin()].tag;
		} else {
			tags[x].tag = 0;
		}
	}
	void new_non_preferred_child(int x) {
		if (fa[x] == 0)
			return;
		subtree_size2[fa[x]] += subtree_size[x];
		if (tag_tree[x].tag)
			tag_tree[fa[x]].tagged_non_preferred_children.insert(x);
		if (tag_non_tree[x].tag)
			tag_non_tree[fa[x]].tagged_non_preferred_children.insert(x);
	}
	void delete_non_preferred_child(int x) {
		if (fa[x] == 0)
			return;
		subtree_size2[fa[x]] -= subtree_size[x];
		if (tag_tree[x].tag)
			tag_tree[fa[x]].tagged_non_preferred_children.erase(x);
		if (tag_non_tree[x].tag)
			tag_non_tree[fa[x]].tagged_non_preferred_children.erase(x);
	}

	inline int& ls(int rt) {
		return c[rt][0];
	}
	inline int& rs(int rt) {
		return c[rt][1];
	}
	inline bool not_splay_rt(int x) {
		return ls(fa[x]) == x || rs(fa[x]) == x;
	}
	inline int side(int x) {
		return x == rs(fa[x]);
	}
	void Init(int n) {
		// Initially every node is a tree by itself.
		// memset all to 0.
		for (int i = 1; i <= n; ++i) {
			subtree_size[i] = 1;
		}
	}
	inline void pushr(int x) {
		swap(ls(x), rs(x));
		r[x] ^= 1;
	}
	inline void pushdown(int x) {
		if (r[x]) {
			if (ls(x))
				pushr(ls(x));
			if (rs(x))
				pushr(rs(x));
			r[x] = false;
		}
	}
	inline void __pushup(int x) {
		update_tag(tag_tree, x);
		update_tag(tag_non_tree, x);
		subtree_size[x] = subtree_size[ls(x)] + subtree_size[rs(x)] + 1 + subtree_size2[x];
	}
	// At first x is not in its tagged_non_preferred_children
	inline void __pushup_splay_rt(int x) {
		__pushup(x);
		new_non_preferred_child(x);
		// No need to update tag[fa[x]], because if it was in this subtree, then it is still in this subtree.
	}
	// tag[x] is not updated.
	void __rotate_up(int x) {
		int y = fa[x], z = fa[y], side_x = side(x), w = c[x][side_x ^ 1];
		fa[x] = z;
		if (not_splay_rt(y))
			c[z][side(y)] = x;
		if (w)
			fa[w] = y;
		c[y][side_x] = w;
		fa[y] = x;
		c[x][side_x ^ 1] = y;
		__pushup(y);
	}
	// tag[x] is not updated.
	// The original splay root is removed from its father's tagged_non_preferred_children.
	void __splay(int x) {
		int y = x, top = 0;
		while(1) {
			sta[++top] = y;
			if (!not_splay_rt(y))
				break;
			y = fa[y];
		}
		int to = fa[y];
		delete_non_preferred_child(y);
		while (top)
			pushdown(sta[top--]);
		while (fa[x] != to) {
			int y = fa[x];
			if (fa[y] != to)
				__rotate_up(side(x) == side(y) ? y : x);
			__rotate_up(x);
		}
	}
	void splay(int x) {
		__splay(x);
		__pushup_splay_rt(x);
	}
	void access(int x) {
		int ori_x = x;
		for (int w = 0; x; w = x, x = fa[x]) {
			__splay(x);
			delete_non_preferred_child(w);
			new_non_preferred_child(rs(x));
			rs(x) = w;
			__pushup_splay_rt(x);
		}
		__splay(ori_x);
		__pushup(ori_x);
	}
	int find_root(int x) {
		access(x);
		for (; ls(x); x = ls(x))
			pushdown(x);
		__splay(x);
		__pushup(x);
		return x;
	}
	inline void make_root(int x) {
		access(x);
		pushr(x);
	}
	void __link(int x, int y) {
		// If simply fa[x] = y, the complexity might be wrong.
		access(y);
		pushdown(x);
		fa[y] = x;
		ls(x) = y;
		__pushup(x); // Might be unnecessary
	}
	inline void link_new(int x, int y) {
		make_root(x);
		__link(x, y);
	}
	inline void link(int x, int y) {
		make_root(x);
		if (find_root(y) == x)
			return;
		__link(x, y);
	}
	inline void split(int x, int y) {
		make_root(x);
		access(y);
	}
	void cut_existing(int x, int y) {
		split(x, y);
		fa[x] = ls(y) = 0;
		__pushup(y); // Might be unnecessary
	}
	void cut(int x, int y) {
		split(x, y);
		if (ls(y) != x || rs(x) != 0)
			return;	// No such edge (x, y)
		fa[x] = ls(y) = 0;
		__pushup(y); // Might be unnecessary
	}
	std::unordered_set<int> take_out_edges(Tag type[], int x) {
		access(x);
		auto tmp = std::unordered_set<int>();
		swap(tmp, type[x].edges);
		update_tag(type, x);
		return std::move(tmp);
	}
	void add_directed_edge(Tag type[], int x, int y) {
		if (type[x].edges.empty()) {
			access(x);
			type[x].edges.insert(y);
			update_tag(type, x);
		} else {
			type[x].edges.insert(y);
		}
	}
	void delete_directed_edge(Tag type[], int x, int y) {
		if (type[x].edges.size() == 1) {
			access(x);
			type[x].edges.erase(y);
			update_tag(type, x);
		} else {
			type[x].edges.erase(y);
		}
	}
	void new_tree_edge(int x, int y) {
		link_new(x, y);
		add_directed_edge(tag_tree, x, y);
		add_directed_edge(tag_tree, y, x);
	}
};

struct DynamicConnectivity {
	struct LCT F[MAX_LEVEL];
	unordered_map<int, unordered_map<int, int> > level;
	void Init(int n) {
		for (int i = 0; (1 << i) <= n; ++i)
			F[i].Init(n);
	}
	// Assume no duplicate edge
	void link_new(int x, int y) {
		level[x][y] = 0;
		level[y][x] = 0;
		if (F[0].find_root(x) == F[0].find_root(y)) {
			F[0].add_directed_edge(F[0].tag_non_tree, y, x);
			F[0].add_directed_edge(F[0].tag_non_tree, x, y);
		} else {
			F[0].new_tree_edge(x, y);
		}
	}
	bool reconnect(int x, int y, int l) {
		F[l].access(x);
		F[l].access(y);
		if (F[l].subtree_size[x] > F[l].subtree_size[y])
			swap(x, y);
		while (1) {
			F[l].access(x);
			int u = F[l].tag_tree[x].tag;
			if (u == 0)
				break;
			auto tmp = F[l].take_out_edges(F[l].tag_tree, u);
			for (int v : tmp) {
				F[l].delete_directed_edge(F[l].tag_tree, v, u);
				F[l+1].new_tree_edge(u, v);
				++level[u][v];
				++level[v][u];
			}
		}

		y = F[l].find_root(y);
		while (1) {
			F[l].access(x);
			int u = F[l].tag_non_tree[x].tag;
			if (u == 0)
				break;
			auto tmp = F[l].take_out_edges(F[l].tag_non_tree, u);
			do {
				auto it = tmp.begin();
				int v = *it;
				tmp.erase(it);
				F[l].delete_directed_edge(F[l].tag_non_tree, v, u);
				if (F[l].find_root(v) == y) {
					if (!tmp.empty()) {
						F[l].access(u);
						swap(tmp, F[l].tag_non_tree[u].edges);
						F[l].update_tag(F[l].tag_non_tree, u);
					}
					for (int i = 0; i < l; ++i)
						F[i].link_new(u, v);
					F[l].new_tree_edge(u, v);
					return true;
				} else {
					F[l+1].add_directed_edge(F[l+1].tag_non_tree, u, v);
					F[l+1].add_directed_edge(F[l+1].tag_non_tree, v, u);
					++level[u][v];
					++level[v][u];
				}
			} while (!tmp.empty());
		};
		return false;
	}
	void cut_existing(int x, int y) {
		auto it1 = level[x].find(y);
		int l = it1->second;
		level[x].erase(it1);
		level[y].erase(x);

		auto& s = F[l].tag_non_tree[x].edges;
		if (s.find(y) != s.end()) {
			F[l].delete_directed_edge(F[l].tag_non_tree, x, y);
			F[l].delete_directed_edge(F[l].tag_non_tree, y, x);
			return;
		}
		F[l].delete_directed_edge(F[l].tag_tree, x, y);
		F[l].delete_directed_edge(F[l].tag_tree, y, x);
		for (int i = 0; i <= l; ++i)
			F[i].cut_existing(x, y);
		while (1) {
			if (reconnect(x, y, l))
				break;
			if (l == 0)
				break;
			--l;
		}
	}
	bool is_connected(int x, int y) {
		return F[0].find_root(x) == F[0].find_root(y);
	}
};

int main() {
	int n, m;
	static DynamicConnectivity dc;

	scanf("%d%d", &n, &m);
	dc.Init(n);
	int last = 0;
	while (m--) {
		int op, x, y;
		scanf("%d%d%d", &op, &x, &y);
		x ^= last;
		y ^= last;
		switch (op) {
		case 0:
			dc.link_new(x, y);
			break;
		case 1:
			dc.cut_existing(x, y);
			break;
		case 2:
			if (dc.is_connected(x, y)) {
				puts("Y");
				last = x;
			} else {
				puts("N");
				last = y;
			}
			break;
		}
	}

	return 0;
}
```


---

## 作者：Acee (赞：13)

双向广搜可以通过，不过需要一些常数优化。

存边可以使用平衡树，不想手写可使用 set 或 map 但常数并不如意，可使用 vector 实现的假的平衡树，但拥有奇奇怪怪的常数，使其变得很快。

双向宽搜可以使用循环展开变得快一些。

如果还不够快，那就加上一个快读快写就行了，但实测不加快读可以过。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace fast_IO {
#define FASTIO
#define IOSIZE 100000
	char ibuf[IOSIZE], obuf[IOSIZE];
	char *p1 = ibuf, *p2 = ibuf, *p3 = obuf;
#ifdef ONLINE_JUDGE
#define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))
#define putchar(x) ((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
#endif//fread in OJ, stdio in local
	
#define isdigit(ch) (ch>47&&ch<58)
#define isspace(ch) (ch<33)
	template<typename T> inline T read() {
		T s = 0;
		int w = 1;
		char ch;
		while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1;
		if (ch == EOF) return false;
		while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar();
		return s * w;
	}
	template<typename T> inline bool read(T &s) {
		s = 0;
		int w = 1;
		char ch;
		while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1;
		if (ch == EOF) return false;
		while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar();
		return s *= w, true;
	}
	inline bool read(char &s) {
		while (s = getchar(), isspace(s));
		return true;
	}
	inline bool read(char *s) {
		char ch;
		while (ch = getchar(), isspace(ch));
		if (ch == EOF) return false;
		while (!isspace(ch)) *s++ = ch, ch = getchar();
		*s = '\000';
		return true;
	}
	template<typename T> inline void print(T x) {
		if (x < 0) putchar('-'), x = -x;
		if (x > 9) print(x / 10);
		putchar(x % 10 + 48);
	}
	inline void print(char x) {
		putchar(x);
	}
	inline void print(char *x) {
		while (*x) putchar(*x++);
	}
	inline void print(const char *x) {
		for (int i = 0; x[i]; i++) putchar(x[i]);
	}
#ifdef _GLIBCXX_STRING
	inline bool read(std::string& s) {
		s = "";
		char ch;
		while (ch = getchar(), isspace(ch));
		if (ch == EOF) return false;
		while (!isspace(ch)) s += ch, ch = getchar();
		return true;
	}
	inline void print(std::string x) {
		for (int i = 0, n = x.size(); i < n; i++)
			putchar(x[i]);
	}
#endif//string
	template<typename T, typename... T1> inline int read(T& a, T1&... other) {
		return read(a) + read(other...);
	}
	template<typename T, typename... T1> inline void print(T a, T1... other) {
		print(a);
		print(other...);
	}
	
	struct Fast_IO {
		~Fast_IO() {
			fwrite(obuf, p3 - obuf, 1, stdout);
		}
	} io;
	template<typename T> Fast_IO& operator >> (Fast_IO &io, T &b) {
		return read(b), io;
	}
	template<typename T> Fast_IO& operator << (Fast_IO &io, T b) {
		return print(b), io;
	}
#define cout io
#define cin io
#define endl '\n'
}
using namespace fast_IO;
const int N = 5000 + 5; 
int n, m;
vector<int> a[N];
int vis[N];
int qx[N], qy[N];
bool chk(int x, int y) {
	int l1, r1, l2, r2;
	l1 = r1 = l2 = r2 = 0;
	qx[r1++] = x, qy[r2++] = y;
	vis[x] = 1;
	vis[y] = 2;
	if (x == y) return true;
	while (true) {
		if (l1 == r1) return false;
		int u = qx[l1++];
		for (int i = 0; i < a[u].size(); ++i) {
			int v = a[u][i];
			if (vis[v] == 2) return 1;
			if (vis[v] == 0) {
				qx[r1++] = v;
				vis[v] = 1;
			}
		}
		if (l2 == r2) return false;
		u = qy[l2++];
		for (int i = 0; i < a[u].size(); ++i) {
			int v = a[u][i];
			if (vis[v] == 1) return 1;
			if (vis[v] == 0) {
				qy[r2++] = v;
				vis[v] = 2;
			}
		}
	}
	return false;
}
int main() {
	cin >> n >> m;
	int lst = 0, op, x, y;
	while (m--) {
		cin >> op >> x >> y;
		x ^= lst, y ^= lst;
		if (op == 0) {
			a[x].insert(lower_bound(a[x].begin(), a[x].end(), y), y);
			a[y].insert(lower_bound(a[y].begin(), a[y].end(), x), x);
		}
		else if (op == 1) {
			a[x].erase(lower_bound(a[x].begin(), a[x].end(), y));
			a[y].erase(lower_bound(a[y].begin(), a[y].end(), x));
		}
		else {
			memset(vis, 0, sizeof(vis));
			if (chk(x, y)) {
				cout << "Y\n";
				lst = x;
			}
			else {
				cout << "N\n";
				lst = y;
			}
		}
	}
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：6)

# Holm-de Lichtenberg-Thorup 算法

听了 WC 讲课来写一篇题解，文末会附上实现。下文认为 $n,m$ 同级。

## ETT

我们首先需要找个数据结构支持这样一个维护问题：

1. 连接点 $u,v$。保证两点不连通。

2. 断开边 $u,v$，保证这条边存在。

3. 查询 $u$ 所在连通块内所有点的半群信息。

我们定义一棵树的欧拉序为，从某个点出发 dfs，将走过的所有边按照顺序写下来，然后对于每个点 $u$ 的任意两条形如 $v \to u$，$u \to x$ 的边之间插入边 $u \to u$。最后形成的序列。

容易发现欧拉序是一个环，从哪里开始都无所谓。

考虑使用 FHQtreap 维护欧拉序，对于 FHQtreap 的每个点记录一个父亲以用来找根。一张图会是一个 FHQtreap 森林，一棵 FHQtreap 代表了一棵树。查询一个点所在树的半群信息只需要在 FHQtreap 上合并信息即可。

接下来讲一下如何在进行上述操作时使用 FHQtreap 维护每棵树的任意一个欧拉序。

### makeroot

首先需要一个辅助操作，换根，实际上我们维护的树本身是无根的，但是如果令一个 $u \to u$ 的边为欧拉序的第一条边，那么这个欧拉序则可以视为从 $u$ 开始。

实际上需要在 FHQtreap 上做的操作就是在 $u \to u$ 处裂开然后把前面接在后面就行。

### link

首先把需要连接的两个点 $u,v$ 分别做一次 makeroot 操作。

然后新树的欧拉序可以视为 $u$ 所在树的欧拉序，$u \to v$，$v$ 所在树的欧拉序，$v \to u$ 依次拼接。

### cut

把欧拉序序列在 $u \to v,v \to u$ 两处断开，两条边丢掉后，第一个部分与第三个部分合并即可，容易发现这就是 link 的逆操作。

上述所有操作复杂度都是 FHQtreap 的单次操作复杂度，为 $O(\log n)$。

## Holm-de Lichtenberg-Thorup 算法

考虑给每条边都赋一个等级 $l_e$。

定义 $E_i$ 表示所有等级大于等于 $i$ 的边构成的边集。

定义 $F_i$ 为 $E_i$ 的一个极大生成森林。

我们在维护过程中保证任意 $E_i$ 为 $E_{i-1}$ 的一个子集，任意 $F_i$ 为 $F_{i-1}$ 的一个子集，且 $F_i$ 中任意一个连通块大小不超过 $\frac{n}{2^i}$。

容易发现 $F_i = F_0 \cup E_i$，不然会违反 $F_i$ 为 $E_i$ 的极大生成森林的性质。

### link

将边 $u,v$ 加入 $E_0$，如果 $u,v$ 在 $F_0$ 中不连通，则将其在 $F_0$ 中连边。令 $l_{u,v} = 0$。

### cut

考虑假若边 $u,v$ 不在 $F_0$ 中，其不会在任意 $F_i$ 中，把其在 $E_0,E_1,\dots,E_{l_{u,v}}$ 中全部删去，不会对连通性产生任何影响，故直接删去即可。

否则先将其从 $E_0,E_1,\dots,E_{l_{u,v}},F_0,F_1,\dots,F_{l_{u,v}}$ 中全部删去，然后从 $E_{l_{u,v}}$ 开始依次尝试找一条非树边连接因为 $u,v$ 被删去而分裂出的两个连通块，不妨令这两个连通块为 $T_u,T_v$。

首先，我们不可能用一条等级大于 $l_{u,v}$ 的边来连接 $T_u,T_v$，因为如果存在这样的边 $e'$，那么在图 $E_{l_e'}$ 中不存在边 $u,v$ 而存在边 $e'$，此时 $e'$ 应该处于 $F_{l_e'}$ 中，而 $F_{l_e'}$ 为 $F_{l_{u,v}}$ 的子集，故 $F_{l_{u,v}}$ 中也存在边 $e'$，那么在边 $u,v$ 删去前 $F_{l_{u,v}}$ 就不是一棵树了。

当你在图 $E_k$ 中尝试找一条非树边连接 $T_u,T_v$ 时，由于任意图 $E_{k'},k'>k$ 中的非树边都已经被尝试过或者被上面证明了不可行，所以我们就只尝试等级为 $k$ 的非树边，考虑遍历 $T_u$ 中所有存在 $k$ 级非树边的点，遍历这些点的 $k$ 级非树边，显然这条边的另一个端点要么属于 $T_u$ 要么属于 $T_v$，假若属于其他部分则会违反 $F_k$ 在边 $u,v$ 断开之前是一个极大生成森林的性质，假若遍历到的边属于 $T_u$ 则给他升级为 $k+1$ 级边，否则你就找到了应该连上的边，将这条边从非树边集合中删除后作为树边插入 $F_0,F_1,\dots,F_k$ 即可结束流程。不妨钦定 $|T_u| \leq |T_v|$，由于 $|T_u|+|T_v| \leq \frac{n}{2^k}$，所以 $|T_u| \leq \frac{n}{2^{k+1}}$，所以我们即使将 $T_u$ 中的 $k$ 级边全部升级为 $k+1$ 级边也没问题。当然为了防止升级的边在 $E_{k+1}$ 中成为树边而在 $E_{k}$ 中不为树边，先要把 $F_{k}$ 中所有 $k$ 级树边升为 $k+1$ 级边。假若这个流程结束还没有找到想要的边，则去向 $E_{k-1}$ 递归找边。

分析下复杂度，你会以 $O(t \log n)$ 的代价将 $t$ 条边升级，而总的升级次数是 $O(n \log n)$ 故总的复杂度为 $O(n \log^2 n)$。

### 实现细节

我们需要快速在 $F_k$ 中找到一条 $k$ 级树边和一个有 $k$ 级非树边的点，考虑使用 ETT 维护连通块中编号最小的 $k$ 级树边和编号最小的存在 $k$ 级非树边的点即可。


```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
const int maxn = 5e3+14;
const int maxk = 13;
const int warma = 12;
const int inf = 1e9;
namespace IO{
    const int SIZE=1<<21;
    static char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS=obuf,*oT=oS+SIZE-1;
    int qr;
    char qu[55],c;
    bool f;
    #define getchar() (IO::iS==IO::iT?(IO::iT=(IO::iS=IO::ibuf)+fread(IO::ibuf,1,IO::SIZE,stdin),(IO::iS==IO::iT?EOF:*IO::iS++)):*IO::iS++)
    #define putchar(x) *IO::oS++=x,IO::oS==IO::oT?flush():0
    #define flush() fwrite(IO::obuf,1,IO::oS-IO::obuf,stdout),IO::oS=IO::obuf
    #define puts(x) IO::Puts(x)
    template<typename T>
    inline void read(T&x){
        for(f=1,c=getchar();c<48||c>57;c=getchar())f^=c=='-';
        for(x=0;c<=57&&c>=48;c=getchar()) x=(x<<1)+(x<<3)+(c&15); 
        x=f?x:-x;
    }
    template<typename T>
    inline void write(T x){
        if(!x) putchar(48); if(x<0) putchar('-'),x=-x;
        while(x) qu[++qr]=x%10^48,x/=10;
        while(qr) putchar(qu[qr--]);
    }
    inline void Puts(const char*s){
        for(int i=0;s[i];++i)
            putchar(s[i]);
        putchar('\n');
    }
    struct Flusher_{~Flusher_(){flush();}}io_flusher_;
}
using IO::read;
using IO::write;
struct my_hash{
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }

  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }

  size_t operator()(pair<uint64_t, uint64_t> x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x.first + FIXED_RANDOM) ^
           (splitmix64(x.second + FIXED_RANDOM) >> 1);
  }
};
unordered_set<int,my_hash> E[maxn][maxk];//(u.v) level-i
mt19937 rd(time(0));
__gnu_pbds::gp_hash_table<int,int,my_hash> lev[maxn];
int n,m;
class ETT{
    private:
        int k;
        int rk[maxn*3],ls[maxn*3],rs[maxn*3],fa[maxn*3],sz[maxn*3],siz[maxn*3];
        int minpos[maxn*3];
        pair<int,pair<int,int> > minedge[maxn*3],w[maxn*3];
        int tot;
        __gnu_pbds::gp_hash_table<int,int,my_hash> id;
        vector<int> vec;
        void pushup(int cur);//FHQtreap
        int merge(int u,int v);//FHQtreap
        void split(int cur,int K,int &l,int &r);//FHQtreap
        int clone();
        int rank(int u);//ETT
        void makeroot(int u);//tree
        int del_left(int u);
    public:
        //tree
        void init(int level);
        bool link(int u,int v);
        void cut(int u,int v);
        void upd(int u);
        int asksz(int u);
        int find(int u);
        int findroot(int u);//ETT
        void update(int u,int v);
        pair<int,pair<int,int> > findedge(int u);
}tr[maxk];
int ETT::del_left(int u){
    if(ls[u]==0){
        u=rs[u];
        pushup(u);
        return u;
    }else{
        ls[u]=del_left(ls[u]);
        if(ls[u]!=0) fa[ls[u]]=u;
        pushup(u);
        return u;
    }
}
void ETT::pushup(int cur){
    if(cur==0) return ;
    sz[cur]=sz[ls[cur]]+sz[rs[cur]]+(cur<=n);
    siz[cur]=siz[ls[cur]]+siz[rs[cur]]+1;
    minpos[cur]=min(minpos[ls[cur]],minpos[rs[cur]]);
    minedge[cur]=min(w[cur],min(minedge[ls[cur]],minedge[rs[cur]]));
    if(cur<=n&&E[cur][k].size()>0) minpos[cur]=min(minpos[cur],cur);
}
int ETT::merge(int u,int v){
    if(u==0||v==0) return u+v;
    if(rk[u]>rk[v]){
        rs[u]=merge(rs[u],v);
        pushup(u);
        if(rs[u]!=0) fa[rs[u]]=u;
        return u;
    }else{
        ls[v]=merge(u,ls[v]);
        pushup(v);
        if(ls[v]!=0) fa[ls[v]]=v;
        return v;
    }
}
void ETT::split(int cur,int K,int &l,int &r){
    if(cur==0){
        l=r=0;
        return ;
    }
    if(K>=siz[ls[cur]]+1){
        l=cur;
        split(rs[l],K-(siz[ls[cur]]+1),rs[l],r);
        if(rs[l]!=0) fa[rs[l]]=l;
        pushup(l);
        return ;
    }else{
        r=cur;
        split(ls[r],K,l,ls[r]);
        if(ls[r]!=0) fa[ls[r]]=r;
        pushup(r);
        return ;
    }
}
int ETT::clone(){
    if(vec.size()==0){
        tot++;
        minpos[tot]=inf;
        siz[tot]=1;
        sz[tot]=0;
        rk[tot]=rd();
        ls[tot]=rs[tot]=fa[tot]=0;
        w[tot]=minedge[tot]=make_pair(inf,make_pair(inf,inf));
        return tot;
    }
    else{
        int u=vec.back();
        vec.pop_back();
        minpos[u]=inf;
        siz[u]=1;
        rk[u]=rd();
        sz[u]=0;
        ls[u]=rs[u]=fa[u]=0;
        w[u]=minedge[u]=make_pair(inf,make_pair(inf,inf));
        return u;
    }
}
int ETT::rank(int u){
    int res=siz[ls[u]];
    while(fa[u]!=0){
        if(u==rs[fa[u]]) res+=siz[ls[fa[u]]]+1;
        u=fa[u];
    }
    return res;
}
void ETT::makeroot(int u){
    int rt=findroot(u);
    int K=rank(u);
    int x=0,y=0;
    split(rt,K,x,y);
    fa[x]=fa[y]=0;
    rt=merge(y,x);
}
void ETT::init(int level){
    k=level;
    tot=n;
    minpos[0]=inf;
    minedge[0]=w[0]=make_pair(inf,make_pair(inf,inf));
    ls[0]=rs[0]=fa[0]=0;
    for(int i=1;i<=n;i++){
        sz[i]=1;
        siz[i]=1;
        ls[i]=rs[i]=fa[i]=0;
        minpos[i]=inf;
        rk[i]=rd();
        minedge[i]=w[i]=make_pair(inf,make_pair(inf,inf));
    }
}
bool ETT::link(int u,int v){
    if(u>v) swap(u,v);
    if(findroot(u)==findroot(v)) return false;
    makeroot(u);
    makeroot(v);
    int e1=id[u*(maxn*3)+v]=clone();
    int e2=id[v*(maxn*3)+u]=clone();
    minedge[e1]=w[e1]=make_pair(lev[u][v],make_pair(u,v));
    int x=findroot(u),y=findroot(v);
    int rt=merge(x,merge(e1,merge(y,e2)));
    return true;
}
void ETT::cut(int u,int v){
    int e1=id[u*(maxn*3)+v],e2=id[v*(maxn*3)+u];
    int l=rank(e1),r=rank(e2);
    if(l>r) swap(l,r);
    int x=0,y=0,z=0;
    int rt=findroot(u);
    split(rt,l,x,y);
    fa[x]=fa[y]=0;
    r-=l;
    y=del_left(y);
    fa[y]=0;
    r--;
    split(y,r,y,z);
    fa[y]=fa[z]=0;
    z=del_left(z);
    fa[z]=0;
    //x y z
    vec.push_back(e1);
    vec.push_back(e2);
    id.erase(e1);
    id.erase(e2);
    rt=merge(x,z);
    return ;
}
void ETT::upd(int u){
    pushup(u);
    while(fa[u]!=0) u=fa[u],pushup(u);
}
int ETT::asksz(int u){
    return sz[findroot(u)];
}
int ETT::find(int u){
    return minpos[findroot(u)];
}
int ETT::findroot(int u){
    while(fa[u]!=0){
        u=fa[u];
    }
    return u;
}
void ETT::update(int u,int v){
    if(u>v) swap(u,v);
    int x=id[u*(maxn*3)+v];
    w[x]=make_pair(lev[u][v],make_pair(u,v));
    pushup(x);
    while(fa[x]!=0) x=fa[x],pushup(x);
}
pair<int,pair<int,int> > ETT::findedge(int u){
    return minedge[findroot(u)];
}
void link(int u,int v){
    if(tr[0].link(u,v)==false){
        E[u][0].insert(v);
        E[v][0].insert(u);
        tr[0].upd(u);
        tr[0].upd(v);
    }
    lev[u][v]=lev[v][u]=0;
}
void insert(int u,int v,int k){
    //insert (u,v) E_k
    if(tr[k].link(u,v)==false){
        E[u][k].insert(v);
        E[v][k].insert(u);
        tr[k].upd(u);
        tr[k].upd(v);
    }
}
void improve(int u,int v){
    E[u][lev[u][v]].erase(v);
    E[v][lev[u][v]].erase(u);
    tr[lev[u][v]].upd(u);
    tr[lev[u][v]].upd(v);
    lev[u][v]++,lev[v][u]++;
    insert(u,v,lev[u][v]);
}
void cut(int u,int v){
    int level=lev[u][v];
    if(E[u][level].find(v)==E[u][level].end()){
        //(u,v) is tree_edge
        for(int i=level;i>=0;i--){
            tr[i].cut(u,v);
        }
        for(int i=level;i>=0;i--){
            if(tr[i].asksz(u)>tr[i].asksz(v)) swap(u,v);
            pair<int,pair<int,int> > res;
            while((res=tr[i].findedge(u)).first==i){
                int x=res.second.first,y=res.second.second;
                lev[x][y]++;
                lev[y][x]++;
                tr[i].update(x,y);
                insert(x,y,lev[x][y]);
            }
            //|T(u)|<=|T(v)|
            int x;
            while((x=tr[i].find(u))!=inf){
                while(E[x][i].size()>0){
                    int y=(*E[x][i].begin());
                    if(tr[i].findroot(x)==tr[i].findroot(y)){
                        improve(x,y);
                    }else{
                        E[x][i].erase(y);
                        E[y][i].erase(x);
                        tr[i].upd(x);
                        tr[i].upd(y);
                        for(int j=i;j>=0;j--) tr[j].link(x,y);
                        lev[u].erase(v),lev[v].erase(u);
                        return ;
                    }
                }
            }
        }
    }else{
        E[u][level].erase(v);
        E[v][level].erase(u);
        tr[level].upd(u);
        tr[level].upd(v);
    }
    lev[u].erase(v),lev[v].erase(u);
}
int lst;
int main(){
    read(n);
    read(m);
    for(int i=0;i<=warma;i++) tr[i].init(i);
    while(m--){
        int op,x,y;
        read(op);
        read(x);
        read(y);
        x^=lst;
        y^=lst;
        if(op==0){
            link(x,y);
        }else if(op==1){
            cut(x,y);
        }else{
            if(tr[0].findroot(x)==tr[0].findroot(y)){
                lst=x;
                putchar('Y');
            }else{
                lst=y;
                putchar('N');
            }
            putchar('\n');
        }
    }    
    return 0;
}
```

---

## 作者：chenhanzheapple (赞：1)

# [传送门](https://www.luogu.com.cn/problem/P5247)

显然蒟蒻不会 HDLT。

考虑每次查询时暴力搜索，看两个点能不能相遇。显然使用 BFS 搜索，但[使用 BFS ](https://www.luogu.com.cn/record/224657101)只能得到 $82$ 分。

可以使用双向 BFS 进行优化。具体的，对于每个查询，将 $x$ 和 $y$ 加入队列，并打上不同的标记。在 BFS 过程中，如果一个点同时拥有两个标记，那 $x$ 和 $y$ 就是连通的（因为连通是可传递的）。

代码：


```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
int n,m;
set<int> v[5005];
bool bfs(int x,int y){
    queue<int> que;
    int a[5005] = {0};
    que.push(x);
    a[x] = 1;
//    cout << "query:" << x << " " << y << endl;
    while(!que.empty()){
        int t = que.front();
        que.pop();
        if(t==y){
            return 1;
        }
        for(auto z:v[t]){
            if(!a[z]){
                a[z] = a[t];
                que.push(z);
            }
        }
    }
//    for(int i=1;i<=4;i++){
//        cout << a[i] << " ";
//    }
//    cout << endl;
    return 0;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    int last = 0;
    while(m--){
        int op,x,y;
        cin >> op >> x >> y;
        x^=last,y^=last;
        if(op==0){
//            cout << "add:" << x << " " << y << endl;
            v[x].insert(y);
            v[y].insert(x);
        }
        else if(op==1){
//            cout << "erase:" << x << " " << y << endl;
            v[x].erase(y);
            v[y].erase(x);
        }
        else{
            if(bfs(x,y)){
                last = x;
                cout << "Y";
            }
            else{
                last = y;
                cout << "N";
            }
            cout << endl;
        }
    }
    return 0;
}

```

---


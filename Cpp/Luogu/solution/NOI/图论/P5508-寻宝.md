# 寻宝

## 题目背景

Steve成功打开了机关，发现机关后是一个巨大的迷宫

## 题目描述

这个迷宫一共有$n$个洞穴，洞穴之间有很多单向隧道，很难数清

但经过分析，发现：

这些隧道可以分为$m$组，对于每一组，编号在区间$[s_l,s_r]$内的每一个洞穴，与编号在区间$[t_l,t_r]$内的每一个洞穴之间，都有一条隧道，每组内共有$(s_r-s_l+1)\cdot (t_r-t_l+1)$条隧道，通过同组内每一条隧道的时间都相等

为了进一步节约时间，Steve可以挖掘新的隧道

但是，每个洞穴的性质不同，导致挖掘隧道的难度不同，有些洞穴甚至无法挖掘隧道

具体来说，第$i$个洞穴有一个值$v_i$，$v_i=0$表示无法挖掘隧道，对于其它值，表示从第$i$个洞穴开始，挖掘一条到第$j$个洞穴的隧道，并到达第$j$个隧道，需要花费$|i-j|*v_i$时间

Steve希望在最短时间内到达第$n$个洞穴，决定不限制挖掘隧道的数量

现在，你需要告诉Steve最少需要用的时间

如果可能，你应帮助Steve求出一种最优方案

## 说明/提示

样例1：1号到2号走第一组隧道，2号到6号挖掘隧道，用时$1*(6-2)=4$

样例2：1号到3号走第一组隧道，3号到4号挖掘隧道，用时$2*(4-3)=2$，4号到6号走第二组隧道

每个Subtask包括两个测试点，取较低分

对于每个测试点：

如果输出格式错误，那么，该测试点得0分

如果你没有给出正确的用时，那么，该测试点得0分

如果你给出正确的用时，但没有给出方案，那么你可以得到该测试点一半的分数（每个测试点得分向下取整）

如果你给出了错误方案，那么你可能可以得到该测试点一半的分数，或者得0分

如果你给出了正确的方案，那么你可以得到该测试点全部的分数

上面两个输出都可以得到满分，还有一种方案是$1 2 4 6$

如果你输出：

```
9
0
```
那么你可以得到该测试点一半的分数

数据范围：

$1\le w,v_i \le 10^9$

Subtask | 分值| n | m| 特殊性质
:-: | :-: | :-: | :-: | :-:
1 | 5| 100| 100| | 
2| 10| 3000| 3000| |
3| 11| 50000| 50000| 2,3|
4| 10| 50000| 50000| 1|
5| 12| 50000| 0| |
6| 12| 50000| 1| |
7| 13| 50000| 20|3 |
8| 13| 50000| 20| |
9| 14| 50000| 50000| |

特殊性质1：所有$v_i=0$

特殊性质2：所有$v_i \in \{0,k\}$，$k$为常数

特殊性质3：所有$s_l=s_r,t_l=t_r$

保证存在到达$n$号洞穴的方案

关于输出错误方案：

如果输出的$2\leq c\leq n$，经过的点以$1$开头，以$n$结尾，且中间的点都是在$(1,n)$的整数，则这组解可能是一组最优解，可以得到一半分数

否则，得0分

~~不用担心spj会TLE/MLE~~

## 样例 #1

### 输入

```
6 2
0 1 2 0 0 0
1 1 2 3 5
4 5 6 6 2
```

### 输出

```
9
3
1 2 6```

## 样例 #2

### 输入

```
6 2
0 1 2 0 0 0
1 1 2 3 5
4 5 6 6 2
```

### 输出

```
9
4
1 3 4 6```

# 题解

## 作者：Hope2075 (赞：17)

题意：给出一个图，存在两种边：区间连边和一些特殊的边，特殊边的边权是起点与终点编号差的绝对值乘以一个与起点编号有关的数

## 算法1

看到$n,m$都很小，暴力连边+Dijkstra即可

时间复杂度$O(n^2m)$

期望得分：5分

## 算法2

$n,m$变大了，需要优化

当然可以用数据结构进行区间连边，但是还有不用数据结构的做法

对于每组边，建一个中转节点，把这组边的所有起点向中转节点连一条边权为$w$的边，再从中转节点向这组边的所有终点连一条边权为$0$的边，剩下的部分还是暴力连边

时间复杂度$O(nm)$

期望得分：15分

## 算法3

针对subtask3

发现这时区间连边变成了单点连边，而且能连特殊边的所有点，$v_i$都相同

考虑用分层图：

首先把单点连边部分连好，然后对于每个点建另一个节点

如果这个点能连边，那么向对应节点连一条双向边，边权为$0$

否则，就从对应节点向这个节点连一条边权为$0$的单向边

随后，将所有对应节点按顺序相连，边权为非零的$v_i$，这些边形成一条链

这样，特殊边都可以通过走到对应节点，然后沿着这条链前进，再回到普通节点，长度恰好满足要求

时间复杂度$O(m \log n)$

期望得分11分，结合算法2期望得分26分

## 算法4

针对subtask4

这部分没有特殊边

所以数据结构优化建图即可，注意要加中转节点，否则复杂度多一个log

时间复杂度$O(m \log^2 n)$

期望得分10分，结合算法2期望得分25分

## 算法5

针对subtask5

发现只有特殊边

直接贪心

每到一个点，根据当前边$v_i$值和到达点的$v_i$值，决定是否开始挖一条新的边，如果到达的点$v_i$较小，就挖新的边

这时候，往回挖一定不是最优解，因为可以在到达那个点时就挖新的隧道，往回挖只会导致重复经过某条隧道，浪费时间

期望得分12分，结合算法2期望得分27分

## 算法6

针对subtask9

区间连边按照算法4做，这部分没问题

然后考虑特殊边

考虑批量增广：李超树

当从堆中取出一个$v_i \neq 0$的点时，发现到其它所有节点的最小值都和一个特定值取了min

这个值在左半边是递减的等差数列，右半边是递增的等差数列

所以，对李超树作一些修改，用它代替堆

需要维护：

取出最小值以及位置，并删除这个点

区间与一个等差数列取min

对于李超树上的一个节点，记录这个点维护区间内编号最小和最大的点，以及区间内最小值，并记录区间内点是否全部被删除

当一个节点维护的整个区间需要与一个等差数列取min时，根据新的等差数列与原有等差数列的情况处理

如果每个区间内的位置，都满足一个数列比另一个数列大，那么就换掉一个数列

否则，比较中心点，中心点位置值小的留下来，大的则选择可能更优的一边递归处理

随后，用数列更新区间内最小值

对于区间与等差数列取min，先按普通线段树递归到对应节点，然后按上面的方法处理

对于取出位置，根据两个孩子节点最小值的大小关系，到达对应的孩子，取出值并加上删除标记

这样，就能用这个李超树代替堆了

当然，也可以用堆/线段树处理普通边，需要根据两个数据结构中最小值决定取出哪一部分的节点

时间复杂度取决于具体实现方法

std使用ST表优化区间连边，用线段树维护普通边部分，时间复杂度：$O(n \log ^2 n + m\log n)$

期望得分：100分

p.s:出题人写题解时突然意识到Subtask6-8原来的部分分算法可能有问题，于是就没写这部分的做法

AC代码：

```cpp
#include<cstdio>
const int N=200007;
const bool DEBUG=0;
const long long INF=(1LL<<62)-1;
long long read(){
	long long num=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){num=num*10+c-'0';c=getchar();}
	return num;
}
char res[25];
void write(long long num){
	if(num==0){putchar('0');return;}
	if(num<0){putchar('-');num=-num;}
	int t=0;
	while(num){res[t++]=num%10+'0';num/=10;}
	while(t--)putchar(res[t]);
}
template<typename T>
T min(T a,T b){
	if(a<b)return a;
	return b;
}

int n,m;
long long v[N];
int head[N*40],next[N*44],ver[N*44],tot;
long long edge[N*44];
long long dis[N*40];
int fr[N*40];
void add(int a,int b,long long w){
	tot++;
	edge[tot]=w;
	ver[tot]=b;
	next[tot]=head[a];
	head[a]=tot;
}

int log2[N];
#define gid1(x,k) ((k)*n+(x))
#define gid2(x,k) ((k)*n+(x)+n*20)
#define maxid (n*40+1)
void gen(){
	for(int k=0;;k++){
		for(int i=(1<<k);i<(1<<(k+1))&&i<=n;i++){
			log2[i]=k;
		}
		if((1<<(k+1))>n)break;
	}
	for(int i=1;i<=n;i++){
		add(gid2(i,0),gid1(i,0),0);
	}
	for(int k=0;;k++){
		if((1<<k)>n)break;
		for(int i=1;i<=n-(1<<k);i++){
			add(gid1(i,k),gid1(i,k+1),0);
			add(gid1(i+(1<<k),k),gid1(i,k+1),0);
			add(gid2(i,k+1),gid2(i,k),0);
			add(gid2(i,k+1),gid2(i+(1<<k),k),0);
		}
	}
}
void radd(int l1,int r1,int l2,int r2,long long w){
	int len1=r1-l1+1;
	int k1=log2[len1];
	int p11=gid1(l1,k1);
	int p12=gid1(r1+1-(1<<k1),k1);
	
	int len2=r2-l2+1;
	int k2=log2[len2];
	int p21=gid2(l2,k2);
	int p22=gid2(r2+1-(1<<k2),k2);
	
	add(p11,p21,w);
	add(p12,p21,w);
	add(p11,p22,w);
	add(p12,p22,w);
}
#define gmid() int mid=((ll+rr)>>1)
int resp;
namespace seg1{
	long long minn[N*40*4];
	int fr[N*40*4];
	void clr(int id,int ll,int rr){
		minn[id]=INF;
		if(ll==rr)return;
		gmid();
		clr(id<<1,ll,mid);
		clr((id<<1)|1,mid+1,rr);
	}
	void pushup(int id,int ll,int rr){
		minn[id]=min(minn[id<<1],minn[(id<<1)|1]);
	}
	void pset(int pl,long long num,int f,int id,int ll,int rr){
		if(ll==rr){
			if(minn[id]>num){
				minn[id]=num;
				fr[id]=f;
			}
			return;
		}
		gmid();
		if(pl<=mid)pset(pl,num,f,id<<1,ll,mid);
		else pset(pl,num,f,(id<<1)|1,mid+1,rr);
		pushup(id,ll,rr);
	}
	int gid(int id,int ll,int rr){
		if(ll==rr){
			minn[id]=INF;
			resp=fr[id];
			return ll;
		}
		gmid();
		int ans;
		if(minn[id<<1]<minn[(id<<1)|1])ans=gid(id<<1,ll,mid);
		else ans=gid((id<<1)|1,mid+1,rr);
		pushup(id,ll,rr);
		return ans;
	}
}
namespace seg2{
	#undef maxid
	int maxid[N*4],minid[N*4],fr[N*4];
	long long minn[N*4],k[N*4],b[N*4];
	bool del[N*4];
	int resid,resfr;long long resdis;
	void build(int id,int ll,int rr){
		k[id]=0;
		b[id]=INF;
		maxid[id]=rr;
		minid[id]=ll;
		del[id]=0;
		minn[id]=INF;
		fr[id]=0;
		if(ll==rr){
			return;
		}
		int mid=((ll+rr)>>1);
		build(id<<1,ll,mid);
		build((id<<1)|1,mid+1,rr);
	}
	void pushup(int id,int ll,int rr){
		if(ll==rr){
			if(del[id])return;
			maxid[id]=minid[id]=ll;
			minn[id]=k[id]*ll+b[id];
			return;
		}
		if(del[id<<1]&&del[(id<<1)|1]){
			del[id]=1;
			minn[id]=INF;
			return;
		}
		if(!del[id<<1])minid[id]=minid[id<<1];
		else minid[id]=minid[(id<<1)|1];
		
		if(!del[(id<<1)|1])maxid[id]=maxid[(id<<1)|1];
		else maxid[id]=maxid[id<<1];
		
		minn[id]=INF;
		if(!del[id<<1])minn[id]=min(minn[id],minn[id<<1]);
		if(!del[(id<<1)|1])minn[id]=min(minn[id],minn[(id<<1)|1]);
		if(b[id]!=INF){
			if(k[id]>0)minn[id]=min(minn[id],k[id]*minid[id]+b[id]);
			else minn[id]=min(minn[id],k[id]*maxid[id]+b[id]);
		}
	}
	void addseq(int id,int ll,int rr,long long nk,long long nb,int f){
		if(del[id])return;
		if(b[id]==INF){
			k[id]=nk;
			b[id]=nb;
			fr[id]=f;
			pushup(id,ll,rr);
			return;
		}
		long long lp,ln,rp,rn;
		lp=k[id]*minid[id]+b[id];
		ln=nk*minid[id]+nb;
		rp=k[id]*maxid[id]+b[id];
		rn=nk*maxid[id]+nb;
		if(lp<=ln&&rp<=rn)return;
		if(lp>=ln&&rp>=rn){
			k[id]=nk;
			b[id]=nb;
			fr[id]=f;
			pushup(id,ll,rr);
			return;
		}
		int mid=((ll+rr)>>1);
		long long mp,mn;
		mp=k[id]*mid+b[id];
		mn=nk*mid+nb;
		if(mp>=mn){
			if(lp>=ln){
				addseq((id<<1)|1,mid+1,rr,k[id],b[id],fr[id]);
			}else{
				addseq(id<<1,ll,mid,k[id],b[id],fr[id]);
			}
			k[id]=nk;
			b[id]=nb;
			fr[id]=f;
		}else{
			if(rp>=rn){
				addseq((id<<1)|1,mid+1,rr,nk,nb,f);
			}else{
				addseq(id<<1,ll,mid,nk,nb,f);
			}
		}
		pushup(id,ll,rr);
		return;
	}
	void pushdown(int id,int ll,int rr){
		if(del[id])return;
		if(b[id]==INF)return;
		if(ll==rr)return;
		int mid=((ll+rr)>>1);
		addseq(id<<1,ll,mid,k[id],b[id],fr[id]);
		addseq((id<<1)|1,mid+1,rr,k[id],b[id],fr[id]);
		k[id]=0;
		b[id]=INF;
		fr[id]=0;
		pushup(id,ll,rr);
		return;
	}
	void gid(int id,int ll,int rr){
		if(ll==rr){
			resdis=minn[id];
			resfr=fr[id];
			resid=ll;
			del[id]=1;
			minn[id]=INF;
			return;
		}
		pushdown(id,ll,rr);
		int mid=((ll+rr)>>1);
		if(del[(id<<1)|1]||minn[id<<1]<minn[(id<<1)|1]){
			gid(id<<1,ll,mid);
		}else{
			gid((id<<1)|1,mid+1,rr);
		}
		pushup(id,ll,rr);
	}
	void change(int id,int ll,int rr,int l,int r,long long nk,long long nb,int f){
		if(l<=ll&&rr<=r){
			addseq(id,ll,rr,nk,nb,f);
			return;
		}
		if(r<ll||rr<l)return;
		if(del[id])return;
		pushdown(id,ll,rr);
		int mid=((ll+rr)>>1);
		change(id<<1,ll,mid,l,r,nk,nb,f);
		change((id<<1)|1,mid+1,rr,l,r,nk,nb,f);
		pushup(id,ll,rr);
	}
	#define maxid (n*40+1)
}
int ans[N],c;
int main(){
	n=read();m=read();
	gen();
	for(int i=1;i<=n;i++)v[i]=read();
	while(m--){
		int l1,r1,l2,r2;long long w;
		l1=read();r1=read();l2=read();r2=read();w=read();
		radd(l1,r1,l2,r2,w);
	}
	dis[1]=0;
	for(int i=2;i<=maxid;i++)dis[i]=INF;
	seg1::clr(1,1,maxid);
	seg1::pset(1,0,-1,1,1,maxid);
	seg2::build(1,1,n);
	while(seg1::minn[1]!=INF||seg2::minn[1]!=INF){
		int cur;
		if(seg1::minn[1]>=seg2::minn[1]){
			seg2::gid(1,1,n);
			cur=seg2::resid;
			if(fr[cur])continue;
			fr[cur]=seg2::resfr;
			dis[cur]=seg2::resdis;
		}else{
			cur=seg1::gid(1,1,maxid);
			if(fr[cur])continue;
			fr[cur]=resp;
		}
		if(cur==n)break;
		for(int i=head[cur];i;i=next[i]){
			if(dis[ver[i]]>dis[cur]+edge[i]){
				dis[ver[i]]=dis[cur]+edge[i];
				seg1::pset(ver[i],dis[ver[i]],cur,1,1,maxid);
			}
		}
		if(cur<=n&&v[cur]!=0){
			if(cur!=1)seg2::change(1,1,n,1,cur-1,-v[cur],dis[cur]+v[cur]*cur,cur);
			if(cur!=n)seg2::change(1,1,n,cur+1,n,v[cur],dis[cur]-v[cur]*cur,cur);
		}
	}
	if(dis[n]==INF){
		puts("-1");
		return 0;
	}
	write(dis[n]);
	putchar('\n');
	for(int i=n;i!=-1;i=fr[i]){
		if(i<=n)ans[c++]=i;
	}
	write(c);
	putchar('\n');
	for(int i=c-1;i>=0;i--){
		write(ans[i]);
		putchar(' ');
	}
	if(DEBUG)return 1;
}
```


---

## 作者：TKXZ133 (赞：5)

[寻宝](https://www.luogu.com.cn/problem/P5508)


### 题目大意

存在 $n$ 个点和两种有向边：

- 一类边分 $m$ 组，每组的边权相同，从 $[s_l,s_r]$ 中的所有点连向 $[t_l,t_r]$ 中的所有点。

- 二类边存在于任意两点 $i,j$ 间，从 $i$ 连向 $j$ 的二类边的边权为 $|i-j|\times a_i$。

求从点 $1$ 到 $n$ 的最短路及方案。

### 思路分析

神仙题。

一类边比较好处理，可以直接用区间向区间连边的线段树优化建图加 Dijkstra 搞定。具体可以看 [P6348 Journeys](https://www.luogu.com.cn/problem/P6348)，因此主要看二类边。

思考 Dijkstra 的过程：

- 找到没有更新过其他点的距离最小的点。

- 用这个点更新所有能够到达的点。

我们发现，每一个点都可以通过二类边到达其他所有点，因此可以不建出二类边，而只考虑二类边造成的影响。

设当前的点为 $u$，不难发现，如果以连向的点的编号为横坐标，距离为纵坐标，那么通过 $u$ 连向 $v$ 的二类边对 $v$ 更新的距离在坐标系上形成两条线段，右侧线段的斜率为 $a_i$，截距为 $dis_{u}-u\times a_u$，定义域为 $(u,n]$，左侧线段的斜率为 $-a_i$，截距为 $dis_{u}+u\times a_u$，定义域为 $[1,u)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ku1ax8wx.png)

因此，二类边实际上是对于对于每个点将其当前距离与一条线段取 $\min$。

那么这就可以用李超线段树维护。

具体的说，我们实现一颗拥有堆的功能的李超线段树，也就是支持单点删除，查询全局最小值及位置，区间对线段取 $\min$。

在 Dijkstra 时按照以下过程进行：

- 比较堆中的最小值和李超线段树中的最小值，取出并删除较小的一个。

- 用取出的点通过线段树优化建图建出的边对所有能到达的点进行更新。

- 如果该点的 $a_i\not =0$，那么向李超线段树中添加上述的两条线段。

这样我们就可以完成最短路的求值，考虑到点数是 $O(n)$ 的，边数是 $O(n\log n)$ 的，李超线段树单次插入线段是 $O(\log^2 n)$ 的，故时间复杂度为 $O(n\log^2 n)$。

方案就比较简单了，用一类边更新的点可以直接记录方案，用二类边更新的点可以在插入线段时顺便记录此线段的来源，然后从 $n$ 逆推即可。

### 代码

（只有 5k，算短的了）

```
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <queue>

using namespace std;
const int N=600000,M=200200;
#define inf 0x3f3f3f3f3f3f3f3f
#define mid ((l+r)>>1)
typedef long long ll;

int n,m,in1,in2,in3,in4,in5,L,K,num,tot;
int vis[N],from[N];
ll dis[N],a[N];

struct Node{
    int x;ll dis;
    bool operator < (Node a) const {
        return dis>a.dis;
    }
};

struct Line{
    ll k,b;
}line[N];

vector<pair<int,int>> to[N]; 
vector<int> ans;
priority_queue<Node> q;

void add(int u,int v,int w){
    to[u].push_back({v,w});
}

ll calc(int id,int x){
    return line[id].k*x+line[id].b;
}

bool Less(int id1,int id2,int x){
    return calc(id1,x)<calc(id2,x);
}

struct ST1{
    void build(int p,int l,int r){
        if(l==r){add(p+L,l,0);add(l,p+K,0);return ;}
        build(p<<1,l,mid);build(p<<1|1,mid+1,r);
        add(p+L,(p<<1)+L,0);add(p+L,(p<<1|1)+L,0);
        add((p<<1)+K,p+K,0);add((p<<1|1)+K,p+K,0);
    }
    void addedge(int p,int l,int r,int x,int y,int k,int f){
        if(x<=l&&r<=y) return add(f?k:p+K,f?p+L:k,0);
        if(x<=mid) addedge(p<<1,l,mid,x,y,k,f);
        if(y>mid) addedge(p<<1|1,mid+1,r,x,y,k,f);
    }
}tree1;

void addedge(int l1,int r1,int l2,int r2,ll w){
    tree1.addedge(1,1,n,l1,r1,num,0);
    tree1.addedge(1,1,n,l2,r2,num+1,1);
    add(num,num+1,w);num+=2;
}

struct ST2n{
    int L,R,from;
    ll min;
    int id,del;
}res;
struct ST2{
    ST2n a[M];
    void del_t(int p){
        a[p].del=1;a[p].min=inf;
    }
    void push_up(int p,int l,int r){
        if(a[p].del) return ;
        if(l==r){a[p].min=calc(a[p].id,l);return ;}
        if(a[p<<1].del&&a[p<<1|1].del) return del_t(p);
        a[p].L=a[p<<1].del?a[p<<1|1].L:a[p<<1].L;
        a[p].R=a[p<<1|1].del?a[p<<1].R:a[p<<1|1].R;
        a[p].min=min(a[p<<1].min,a[p<<1|1].min);
        a[p].min=min({a[p].min,calc(a[p].id,a[p].L),calc(a[p].id,a[p].R)});
    }
    void build(int p,int l,int r){
        a[p]={l,r,0,inf,0,0};
        if(l==r) return ;
        build(p<<1,l,mid);build(p<<1|1,mid+1,r);
    }
    void update(int p,int l,int r,int id,int f){
        if(a[p].del) return ;
        if(!a[p].id){a[p].id=id;a[p].from=f;return push_up(p,l,r);}
        if(Less(a[p].id,id,a[p].L)&&Less(a[p].id,id,a[p].R)) return ;
        if(Less(id,a[p].id,a[p].L)&&Less(id,a[p].id,a[p].R)){
            a[p].id=id;a[p].from=f;return push_up(p,l,r);
        }
        if(Less(id,a[p].id,mid)) swap(id,a[p].id),swap(f,a[p].from);
        if(Less(id,a[p].id,a[p].L)) update(p<<1,l,mid,id,f);
        if(Less(id,a[p].id,a[p].R)) update(p<<1|1,mid+1,r,id,f);
        return push_up(p,l,r);
    }
    void push_down(int p,int l,int r){
        if(a[p].del||!a[p].id||l==r) return ;
        update(p<<1,l,mid,a[p].id,a[p].from);
        update(p<<1|1,mid+1,r,a[p].id,a[p].from);
        a[p].id=0;a[p].from=0;
        return push_up(p,l,r);
    }
    void add(int p,int l,int r,int x,int y,int id,int f){
        if(a[p].del) return ;
        if(x<=l&&r<=y) return update(p,l,r,id,f);
        push_down(p,l,r);
        if(x<=mid) add(p<<1,l,mid,x,y,id,f);
        if(y>mid) add(p<<1|1,mid+1,r,x,y,id,f);
        push_up(p,l,r);
    }
    void get(int p,int l,int r){
        if(l==r){res=a[p];return del_t(p);}
        push_down(p,l,r);
        if(a[p<<1|1].del||a[p<<1].min<a[p<<1|1].min) get(p<<1,l,mid);
        else get(p<<1|1,mid+1,r);
        push_up(p,l,r);
    }
}tree2;

void addline(int l,int r,ll k,ll b,int f){
    line[++tot]=Line{k,b};
    tree2.add(1,1,n,l,r,tot,f);
}

void Dijkstra(){
    memset(dis,0x3f,sizeof dis);
    q.push(Node{1,0});dis[1]=0;
    while(!q.empty()||tree2.a[1].min!=inf){
        int now;
        if(q.empty()||tree2.a[1].min<q.top().dis){
            tree2.get(1,1,n);
            now=res.L;
            if(vis[now]) continue;
            dis[now]=res.min;
            from[now]=res.from;
        }
        else now=q.top().x,q.pop();
        if(vis[now]) continue;
        vis[now]=1;
        for(auto [v,w]:to[now]){
            if(dis[v]<=dis[now]+w) continue;
            dis[v]=dis[now]+w;from[v]=now;
            q.push(Node{v,dis[v]});
        }
        if(now<=n&&a[now]){
            if(now!=1) addline(1,now-1,-a[now],dis[now]+a[now]*now,now);
            if(now!=n) addline(now+1,n,a[now],dis[now]-a[now]*now,now);
        }
    }
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    L=n;K=5*n;num=9*n+1;
    line[0]={0,inf};
    tree1.build(1,1,n);
    tree2.build(1,1,n);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d%d%d",&in1,&in2,&in3,&in4,&in5);
        addedge(in1,in2,in3,in4,in5);
    }
    Dijkstra();
    if(dis[n]==inf){cout<<"-1\n";return 0;}
    for(int i=n;i!=1;i=from[i])     
        if(i<=n) ans.push_back(i);
    ans.push_back(1);
    reverse(ans.begin(),ans.end());
    cout<<dis[n]<<'\n';
    cout<<ans.size()<<'\n';
    for(auto it:ans) cout<<it<<' ';
    return 0;
}
```

---

## 作者：yqr123YQR (赞：0)

### 分析
首先，区间向区间的连边可以用线段树优化建图，现在只需要考虑怎么将二类边加入。

显式连边不太行，考虑在 Dijkstra 取出堆顶时与二类边所得最小值比较。这时我们需要：
- 维护一次函数
- 支持删去单点的贡献

于是，我们可以在李超树上各结点维护计入贡献的最左 / 右编号，每次以 tag 所记线段在此两点取值更新最小值，与堆顶比较，在标记一个点 $i$ 取出过后，插入 $y=\mid x-i\mid v_i+{dis}_i$。

时间复杂度 $\Omicron(n\log^2n+m\log n\log(m\log n))$。
### 代码
```cpp
//...
constexpr int maxn = 50005, N = maxn * 10;
int n, m, idx, vis[N], a[maxn], pre[N];
ll dist[N];
std::vector<pii> g[N];
void link(int u, int v, int w) {g[u].push_back({v, w});}
struct segment_tree {//1:in 0:out
	int id[maxn << 2];
	void build(int k, int sl, int sr, int mode)
	{
		if(sl == sr) return void(id[k] = sl);
		id[k] = ++idx;
		int mid = sl + sr >> 1;
		build(k << 1, sl, mid, mode), build(k << 1 | 1, mid + 1, sr, mode);
		if(mode) ::link(id[k], id[k << 1], 0), ::link(id[k], id[k << 1 | 1], 0);
		else ::link(id[k << 1], id[k], 0), ::link(id[k << 1 | 1], id[k], 0);
	}
	void link(int k, int sl, int sr, int ql, int qr, int dot, int mode, int val)
	{
		if(ql <= sl && sr <= qr) return void(mode? ::link(dot, id[k], val): ::link(id[k], dot, val));
		int mid = sl + sr >> 1;
		if(ql <= mid) link(k << 1, sl, mid, ql, qr, dot, mode, val);
		if(qr > mid) link(k << 1 | 1, mid + 1, sr, ql, qr, dot, mode, val);
	}
}in, out;
struct node {
	int pos;
	ll dis;
	friend bool operator < (const node &a, const node &b) {return a.dis > b.dis;}
};
std::priority_queue<node> q;
template<typename t, typename T = t> void chmin(t &a, T b) {if(a > b) a = b;}
struct line {
	ll k, b;
}s[maxn << 1];
ll f(int idx, int x) {return s[idx].k * x + s[idx].b;}
struct lctree {
	static constexpr int maxn = ::maxn << 1;
	int rt, cnt, tag[maxn], l[maxn], r[maxn];
	std::pair<pli, int> val[maxn];
	std::set<int> s[maxn];
	lctree() {val[0] = {{1e18, 0}, 0};}
	int newnode(int sl, int sr)
	{
		std::set<int> &p = s[++cnt];
		for(int i = sl; i <= sr; i++) p.insert(i);
		return cnt;
	}
	void pushup(int k)
	{
		val[k] = min(val[l[k]], val[r[k]]);
		if(s[k].size()) chmin(val[k], {pli{f(tag[k], *s[k].begin()), *s[k].begin()}, tag[k]}),
			chmin(val[k], {pli{f(tag[k], *s[k].rbegin()), *s[k].rbegin()}, tag[k]});
	}
	void modify(int &k, int sl, int sr, int p)
	{
		if(!k) k = newnode(sl, sr);
		int mid = sl + sr >> 1;
		if(f(tag[k], mid) > f(p, mid)) std::swap(tag[k], p);
		if(sl == sr) goto end;
		if(f(tag[k], sl) > f(p, sl)) modify(l[k], sl, mid, p);
		if(f(tag[k], sr) > f(p, sr)) modify(r[k], mid + 1, sr, p);
		end:
		pushup(k);
	}
	void insert(int &k, int sl, int sr, int ql, int qr, int p)
	{
		if(ql <= sl && sr <= qr) return modify(k, sl, sr, p);
		int mid = sl + sr >> 1;
		if(ql <= mid) insert(l[k], sl, mid, ql, qr, p);
		if(qr > mid) insert(r[k], mid + 1, sr, ql, qr, p);
		pushup(k);
	}
	
	std::pair<pli, int> query() {return val[rt];}
	void erase(int &k, int sl, int sr, int q)
	{
		if(!k) k = newnode(sl, sr);
		s[k].erase(q);
		int mid = sl + sr >> 1;
		if(sl == sr) goto end;
		q <= mid? erase(l[k], sl, mid, q): erase(r[k], mid + 1, sr, q);
		end:
		pushup(k);
	}
}tree;
void dijkstra()
{
	dist[1] = 0;
	q.push({1, 0});
	while(q.size() || tree.query().second)
	{
		auto p = tree.query();
		int t = p.first.second, mode = 0;
		if(q.size() && q.top().dis < p.first.first) t = q.top().pos, q.pop();
		else chmin(dist[t], p.first.first), mode = 1;
		if(vis[t]) continue;
		// printf("t:%d\n", t);
		if(t <= n) tree.erase(tree.rt, 1, n, t);
		if(mode == 1) pre[t] = p.second >> 1;
		vis[t] = 1;
		if(t <= n && a[t])
		{
			s[t << 1] = {-a[t], (ll) t * a[t] + dist[t]};
			s[t << 1 | 1] = {a[t], (ll) -t * a[t] + dist[t]};
			tree.insert(tree.rt, 1, n, 1, t, t << 1);
			tree.insert(tree.rt, 1, n, t, n, t << 1 | 1);
		}
		for(auto [to, val] : g[t]) if(dist[to] > dist[t] + val)
			dist[to] = dist[t] + val, q.push({to, dist[to]}), pre[to] = t;
		// puts("finish");
		// if(t == 3) for(auto [pos, dis] : q.c) printf("[%d,%lld]\n", pos, dis);
	}
}
int main()
{
	// freopen(".in", "r", stdin);
	// freopen(".out", "w", stdout);
	s[0].b = 1e18, memset(dist, 0x3f, sizeof dist);
	read(n, m), idx = n;
	in.build(1, 1, n, 1), out.build(1, 1, n, 0);
	for(int i = 1; i <= n; i++) read(a[i]);
	for(int i = 1, sl, sr, tl, tr, w; i <= m; i++)
	{
		read(sl, sr, tl, tr, w);
		out.link(1, 1, n, sl, sr, ++idx, 0, 0);
		in.link(1, 1, n, tl, tr, idx, 1, w);
	}
	dijkstra();
	if(dist[n] > 1e18) return puts("-1"), 0;
	printf("%lld\n", dist[n]);
	std::vector<int> p;
	for(int i = n; i; i = pre[i]) if(i <= n) p.push_back(i);
	printf("%llu\n", p.size());
	for(int i = p.size() - 1; i >= 0; i--) printf("%d ", p[i]);
	return 0;
}
```

---

## 作者：LastKismet (赞：0)

# 思路
这显然是一个最短路问题，考虑两种边的连法。

对于区间连边，线段树优化建图即可。不再赘述。

对于每个点的连边，不难发现是一个绝对值函数，考虑李超线段树维护。

这里以迪杰斯特拉算法为例，我们把通过线段树优化建图的边找到的可行节点存在堆里，而在李超线段树上维护全局最小节点，每次找当前最短节点时，只需要对比堆中的最小节点与李超线段树上最小点即可。

难点就在如何维护李超树最小值，我们考虑每个节点只能被访问一遍，并且有些节点已经操作过了。

考虑忽略第二个要求，因为这个可以在外部简单解决。

对于第一个，我们只要保证每个节点只被找到一次即可。对于每个节点，我们维护一个删除标记。对删除标记的维护是简单的。

此外，我们考虑维护最左侧未被删除的点和最右侧未被删除的点，从而计算出当前节点储存的直线能产生的最小值。将其与两子节点的最小值进行比较即可。

此外，因为要储存方案，因此李超树内对每一条线维护其来自哪一个节点。

不寻常的，插入和删除时，我们维护区间最小值会有困难。因此，我们考虑沿路把当前的线段 `pushdown` 下去，然后直接从子节点更新区间最小值即可。因为你需要考虑一个位置的最小值可能是其到根节点沿路的任何一条线段，一个区间内最小值也不一定是最两侧的点（考虑多条线段可以产生“波浪形”）。这么做是很方便的。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef __int128 i128;
typedef double db;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<int,ll> pil;
typedef pair<ll,int> pli;
template <typename Type>
using vec=vector<Type>;
template <typename Type>
using grheap=priority_queue<Type>;
template <typename Type>
using lrheap=priority_queue<Type,vector<Type>,greater<Type> >;
#define fir first
#define sec second
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define chmax(a,b) a=max(a,b)
#define chmin(a,b) a=min(a,b)
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
#define per(i,x,y) for(int i=(x);i>=(y);i--)
#define repl(i,x,y) for(int i=(x);i<(y);i++)
#define file(f) freopen(#f".in","r",stdin);freopen(#f".out","w",stdout);

const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;
const int mod=1e9+7/*998244353*/;

const int N=5e4+5,M=5e4*4+5;

int n,m;
ll v[N];

int be;

int lcnt;
struct line{
	ll k,b;
	ll y(ll x){return k*x+b;}
}ls[N<<1];
struct lsegment{
	int dat[M];
	ll mn[M];
	bool del[M];
	int L[M],R[M];
	int from[M];
	void build(int x=1,int l=1,int r=n){
		mn[x]=INF;
		L[x]=l,R[x]=r;
		if(l==r)return;
		int m=l+r>>1;
		build(x<<1,l,m);
		build(x<<1|1,m+1,r);
	}
	void pushup(int x,int l,int r){
		if(del[x])return;
		if(l==r){
			if(dat[x])mn[x]=ls[dat[x]].y(l);
			else mn[x]=INF;
			return;
		}
		if(del[x<<1]&&del[x<<1|1]){
			del[x]=1;mn[x]=INF;
			return;
		}
		L[x]=(del[x<<1]?L[x<<1|1]:L[x<<1]);
		R[x]=(del[x<<1|1]?R[x<<1]:R[x<<1|1]);
		mn[x]=min(mn[x<<1],mn[x<<1|1]);
		if(dat[x])chmin(mn[x],min(ls[dat[x]].y(L[x]),ls[dat[x]].y(R[x])));
	}
	void update(int id,int fr,int x,int l,int r){
		if(del[x])return;
		if(!dat[x]){
			dat[x]=id;
			from[x]=fr;
			return pushup(x,l,r);
		}
		int m=l+r>>1;
		if(ls[id].y(m)<ls[dat[x]].y(m))swap(dat[x],id),swap(from[x],fr);
		if(ls[id].y(L[x])<ls[dat[x]].y(L[x]))update(id,fr,x<<1,l,m);
		if(ls[id].y(R[x])<ls[dat[x]].y(R[x]))update(id,fr,x<<1|1,m+1,r);
		pushup(x,l,r);
	}
	void pushdown(int x,int l,int r){
		if(del[x])return;
		if(!dat[x])return;
		int m=l+r>>1;
		update(dat[x],from[x],x<<1,l,m);
		update(dat[x],from[x],x<<1|1,m+1,r);
		dat[x]=from[x]=0;
		pushup(x,l,r);
	}
	void insert(int lq,int rq,int id,int fr,int x=1,int l=1,int r=n){
		if(del[x])return;
		if(lq<=l&&r<=rq)return update(id,fr,x,l,r);
		int m=l+r>>1;
		pushdown(x,l,r);
		if(lq<=m)insert(lq,rq,id,fr,x<<1,l,m);
		if(m<rq)insert(lq,rq,id,fr,x<<1|1,m+1,r);
		pushup(x,l,r);
	}
	int get(int x=1,int l=1,int r=n){
		if(l==r){
			del[x]=1;mn[x]=INF;
			return x;
		}
		int m=l+r>>1;
		pushdown(x,l,r);
		int res;
		if(del[x<<1|1])res=get(x<<1,l,m);
		else if(del[x<<1])res=get(x<<1|1,m+1,r);
		else{
			if(mn[x<<1]<mn[x<<1|1])res=get(x<<1,l,m);
			else res=get(x<<1|1,m+1,r);
		}
		pushup(x,l,r);
		return res;
	}
}lseg;

bool leaf[N*2*2];
int to[N*2*2],id[N];

int dcnt;
int lson[N*2*2],rson[N*2*2];

vec<pil> g[N*2*2];
void build(int &x,int l=1,int r=n){
	if(!x)x=++dcnt;
	if(l==r){
		g[x].pub({n*2+x,0});
		if(l==1)be=x;
		leaf[x]=1;
		to[x]=l;id[l]=x;
		return;
	}
	int m=l+r>>1;
	build(lson[x],l,m);
	build(rson[x],m+1,r);
	g[x].pub({lson[x],0});g[x].pub({rson[x],0});
	g[n*2+lson[x]].pub({n*2+x,0});g[n*2+rson[x]].pub({n*2+x,0});
}

void added(int s,int tl,int tr,ll w,int x=1,int l=1,int r=n){
	if(tl<=l&&r<=tr){
		g[s].pub({x,w});
		return;
	}
	int m=l+r>>1;
	if(tl<=m)added(s,tl,tr,w,lson[x],l,m);
	if(m<tr)added(s,tl,tr,w,rson[x],m+1,r);
}
void adde(int sl,int sr,int tl,int tr,ll w,int x=1,int l=1,int r=n){
	if(sl<=l&&r<=sr){
		added(n*2+x,tl,tr,w);
		return;
	}
	int m=l+r>>1;
	if(sl<=m)adde(sl,sr,tl,tr,w,lson[x],l,m);
	if(m<sr)adde(sl,sr,tl,tr,w,rson[x],m+1,r);
}

bool vis[N*2*2];

ll dis[M];int lst[M];
lrheap<pli> pq;
void dij(){
	memset(dis,0x3f,sizeof(dis));
	dis[be]=0;
	pq.push({dis[be],be});
	int now;
	while(!pq.empty()||lseg.mn[1]!=INF){
		if(pq.empty()||lseg.mn[1]<pq.top().fir){
			ll d=lseg.mn[1];
			int x=lseg.get();
			now=id[lseg.L[x]];
			if(vis[now])continue;
			dis[now]=d;
			lst[now]=lseg.from[x];
		}else{
			auto tp=pq.top();pq.pop();
			now=tp.sec;
			if(vis[now])continue;
		}
		vis[now]=1;
		for(auto p:g[now]){
			auto nxt=p.fir;auto val=p.sec;
			if(dis[nxt]>dis[now]+val){
				dis[nxt]=dis[now]+val;
				if(leaf[now])lst[nxt]=to[now];
				else lst[nxt]=lst[now];
				pq.push({dis[nxt],nxt});
			}
		}
		if(leaf[now]){
			if(!v[to[now]])continue;
			if(to[now]>1){
				++lcnt;
				ls[lcnt].k=-v[to[now]];
				ls[lcnt].b=to[now]*v[to[now]]+dis[now];
				lseg.insert(1,to[now]-1,lcnt,to[now]);
			}
			if(to[now]<n){
				++lcnt;
				ls[lcnt].k=v[to[now]];
				ls[lcnt].b=-to[now]*v[to[now]]+dis[now];
				lseg.insert(to[now]+1,n,lcnt,to[now]);
			}
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	rep(i,1,n)cin>>v[i];
	int t=0;build(t);
	lseg.build();
	rep(i,1,m){
		int sl,sr,tl,tr;ll w;
		cin>>sl>>sr>>tl>>tr>>w;
		adde(sl,sr,tl,tr,w);
	}
	dij();
	if(dis[id[n]]==INF)cout<<-1,exit(0);
	stack<int> ans;
	for(int i=n;1;i=lst[id[i]]){
		ans.push(i);
		if(i==1)break;
	}
	cout<<dis[id[n]]<<"\n"<<ans.size()<<"\n";
	while(!ans.empty())cout<<ans.top()<<" ",ans.pop();
	return 0;
}
```

---

## 作者：Shunpower (赞：0)

思维链条很短的题。

考虑我们是要做一个最短路问题，边有两种：

- 区间向区间连边。
- 点向全局连边，边权为一个一次函数。

前者不管怎么说我们都可以直接写线段树优化建图，主要考虑后者我们怎么做。

考虑 Dijkstra 的过程。当有一个点被拿出来的时候我们要更新它的所有出点的 $d$。于是我们顺理成章地想到李超线段树。

用李超线段树维护 Dijkstra 的过程。每次我们从中取出 $d$ 最小的点 $x$，然后进行：

- $[1,x]$ 和 $[x,n]$ 的 $d$ 各自对一个一次函数取 $\min$。
- 删除点 $x$。

当然还需要维护取出 $d$ 最小的点。

在李超线段树上多维护区间 $\min$ 和取到区间 $\min$ 的点和直线即可。注意到能在一个区间上取到 $\min$ 的点只有这个区间内最左端或最右端的还存在的点。总而言之这是可以简单维护的。

删除一个点只影响它到根路径上那些直线的 $\min$ 是不是在它这里取到。直接设置它为不存在然后将它到根的链 `pushup` 一遍就好了。

然后考虑前者，也就是区间连区间我们怎样简单地做。众所周知，Dijkstra 同时进行了 Distance Ordering，也就是说取出来的点一定是按 $d$ 升序的。所以一个点被取出的时候所有包含它的区间一定在这一次被更新，之后就没用了。同理这些区间抵达的那些区间也在这一次被更新，之后就没用了，进一步地实际上这意味着这一组边都没用了。

此外，使一个区间的点对 $d_x+w_i$ 取 $\min$ 可以看成是一条斜率为 $0$ 的直线。所以我们可以直接用现成的李超线段树维护。

于是我们可以不用显式地线段树优化建图。我们只需把 $[s_l,s_r]$ 拆在线段树的区间上。每次更新时只需把点在线段树的结构上从叶子往上跳，保证不跳到重复的线段树节点，然后在每个节点上暴力向该节点上的边组的目标区间加直线即可。加完之后需要清空一下这个边组以保证复杂度。

这样做显然是 2log 的，并且非常好写。

```cpp
int n,m;
int v[N],w[N];
ll dis[N];
#define mid (l+r>>1)
struct Line{
	ll k,b;
	int id;
} L[N*300];
int tot;
int las[N];
vector <pii> group[N];
vector <pii> tmp;
int leaf[N];
int newline(ll k,ll b,int x){
	tot++;
	L[tot]={k,b,x};
	return tot;
}
struct LCTree{
	int lid[N<<2];
	ll minn[N<<2];
	int minid[N<<2],minl[N<<2];
	int lef[N<<2],rig[N<<2];
	vector <int> E[N<<2];
	bool vis[N<<2];
	il ll gety(int id,int x){
		if(!id) return 4e18;
		if(x<1||x>n) return 4e18;
		return 1ll*L[id].k*x+L[id].b;
	}
	void pushup(int p){
		lef[p]=min(lef[p<<1],lef[p<<1|1]);
		rig[p]=max(rig[p<<1],rig[p<<1|1]);
		minn[p]=min({minn[p<<1],minn[p<<1|1],gety(lid[p],lef[p]),gety(lid[p],rig[p])});
		if(minn[p]==minn[p<<1]) minid[p]=minid[p<<1],minl[p]=minl[p<<1];
		else if(minn[p]==minn[p<<1|1]) minid[p]=minid[p<<1|1],minl[p]=minl[p<<1|1];
		else{
			minl[p]=lid[p];
			if(L[lid[p]].k<0) minid[p]=rig[p];
			else minid[p]=lef[p];
		}
	}
	void build(int p,int l,int r){
		lef[p]=n+1,rig[p]=0;
		if(l==r){
			leaf[l]=p;
			minn[p]=dis[l];
			minid[p]=l;
			lef[p]=rig[p]=l;
			return;
		}
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
		pushup(p);
	}
	void insert(int p,int l,int r,int x){
		// cerr<<p<<" "<<l<<" "<<r<<" "<<x<<endl;
		if(l==r){
			if(gety(lid[p],l)>gety(x,l)){
				lid[p]=x;
				if(lef[p]==l) minn[p]=gety(lid[p],l);
				minl[p]=x;
			}
			return;
		}
		if(gety(lid[p],mid)>gety(x,mid)){
			if(L[lid[p]].k>L[x].k) insert(p<<1,l,mid,lid[p]);
			else insert(p<<1|1,mid+1,r,lid[p]);
			// cerr<<lid[p]<<"?"<<x<<endl;
			lid[p]=x;
		}
		else{
			if(L[lid[p]].k>L[x].k) insert(p<<1|1,mid+1,r,x);
			else insert(p<<1,l,mid,x);
		}
		pushup(p);
	}
	void modify(int p,int l,int r,int ml,int mr,int x){
		if(ml<=l&&r<=mr) return insert(p,l,r,x),void();
		if(ml<=mid) modify(p<<1,l,mid,ml,mr,x);
		if(mid<mr) modify(p<<1|1,mid+1,r,ml,mr,x);
		pushup(p);
	}
	void deletp(int p,int l,int r,int d){
		if(l==r){
			lef[p]=n+1,rig[p]=0;
			minn[p]=4e18;
			return;
		}
		if(d<=mid) deletp(p<<1,l,mid,d);
		else deletp(p<<1|1,mid+1,r,d);
		pushup(p);
	}
	void cut_segment(int p,int l,int r,int ml,int mr){
		if(ml<=l&&r<=mr) return tmp.pb(mp(l,r)),void();
		if(ml<=mid) cut_segment(p<<1,l,mid,ml,mr);
		if(mid<mr) cut_segment(p<<1|1,mid+1,r,ml,mr); 
	}
	void add_edge(int p,int l,int r,int ml,int mr,int x){
		if(ml<=l&&r<=mr) return E[p].pb(x),void();
		if(ml<=mid) add_edge(p<<1,l,mid,ml,mr,x);
		if(mid<mr) add_edge(p<<1|1,mid+1,r,ml,mr,x); 
	}
	void UPdate(int x,ll dis,int from){
		if(!x) return;
		if(vis[x]) return;
		vis[x]=1;
		for(auto i:E[x]){
			// cerr<<x<<","<<i<<endl;
			for(auto j:group[i]){
				// cerr<<j.fi<<":"<<j.fi<<" "<<j.se<<endl;
				modify(1,1,n,j.fi,j.se,newline(0,dis+w[i],from));
			}
			group[i].clear();
		}
		UPdate(x>>1,dis,from);
	}
} T;
#undef mid
int main(){
#ifdef Shun
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	ios::sync_with_stdio(false);
	cin>>n>>m;
	fr1(i,1,n) cin>>v[i];
	fr1(i,1,m){
		int sl,sr,tl,tr;
		tmp.clear();
		cin>>sl>>sr>>tl>>tr>>w[i];
		T.cut_segment(1,1,n,tl,tr);
		group[i]=tmp;
		T.add_edge(1,1,n,sl,sr,i);
	}
	fr1(i,1,n) dis[i]=4e18;
	dis[1]=0;
	T.build(1,1,n);
	while(T.minn[1]!=4e18){
		// T.draw(1,1,n);
		int x=T.minid[1];
		dis[x]=T.minn[1];
		las[x]=L[T.minl[1]].id;
		// cerr<<x<<" "<<dis[x]<<endl;
		if(v[x]){
			T.modify(1,1,n,x,n,newline(v[x],dis[x]-1ll*x*v[x],x));
			// cerr<<"?"<<endl;
			T.modify(1,1,n,1,x,newline(-v[x],dis[x]+1ll*x*v[x],x));
		}
		T.UPdate(leaf[x],dis[x],x);
		T.deletp(1,1,n,x);
		// ET;
	}
	if(dis[n]==4e18){
		cout<<"-1\n";
		ET;
	}
	cout<<dis[n]<<'\n';
	vector <int> ans;
	while(n) ans.pb(n),n=las[n];
	reverse(ans.begin(),ans.end());
	cout<<ans.size()<<'\n';
	for(auto i:ans) cout<<i<<" ";
	cout<<'\n';
	ET;
}
```

---

## 作者：StayAlone (赞：0)

线段树优化建图 + 李超树模板。

原来线段树优化建图时，两棵线段树之间只有叶子结点需要连边。

对于区间向区间连边，建立两棵线段树，一棵入树、一棵出树。对于每组边，新建一个虚点，分别两棵树的区间分别连边即可。一边的边权是 $0$，另一边是 $w$。

考虑 dijkstra 的过程。维护一个堆，跑正常的最短路；同时，使用一棵李超树，做第二种边，维护如下操作：

- 每次从堆顶中取出一个最小值，再从李超树中取出最小值，取两者较小者进行更新，设该点为 $x$。如果是从堆中取出，则弹出；否则，从李超树上删去该点。
- 用线段树优化建图的边更新 $dis$。
- 若 $x$ 是单点，则将其对应的两个一次函数插入李超树，李超树上对应更新信息。

为了维护删除，李超树上要额外维护每个区间还存在的最左点和最右点——显然一次函数的最值一定在两者之一取到。

由于要输出方案，李超树上维护最优线段编号才是最好的选择。由于刚开始没想清楚，导致写得不太好。不过整体来说还是相当好写的，约 4k。

空间复杂度 $\mathcal O(m\log n)$，来自线段树优化建图；时间复杂度 $\mathcal O(n\log^2 n+m\log n\log (m\log n))$，来自于区间插入的李超线段树。

[AC record](https://www.luogu.com.cn/record/207299619)

```cpp
int n, m, tot, id[MAXN], vis[MAXN], val[MAXN], to[MAXN], pre[MAXN];
vector <pii> lnk[MAXN];
vector <int> now; ll dis[MAXN];
priority_queue <pll> q;
const ll inf = ~0Ull >> 2;
const int _inf = ~0U >> 2;

il void init(int x, int l, int r) {
    if (l == r) return lnk[x].eb(x + 4 * n, 0), to[x] = l, id[l] = x, void();
    lnk[x].eb(ls(x), 0); lnk[x].eb(rs(x), 0);
    lnk[ls(x) + 4 * n].eb(x + 4 * n, 0);
    lnk[rs(x) + 4 * n].eb(x + 4 * n, 0);
    int mid = l + r >> 1;
    init(ls(x), l, mid); init(rs(x), mid + 1, r);
}

il void get(int x, int l, int r, int ql, int qr) {
    if (l > qr || r < ql) return;
    if (l >= ql && r <= qr) return now.eb(x), void();
    int mid = l + r >> 1;
    get(ls(x), l, mid, ql, qr); get(rs(x), mid + 1, r, ql, qr);
}

struct setr {
    struct segment {
        ll k, b; int id;

        il ll calc(int x) {
            if (abs(x) == _inf) return inf;
            return k * x + b;
        }
    } tg[MAXN];
    struct node {
        int lmst, rmst, mip, miid; ll mii;

        il node operator + (const node &q) {
            node ans;
            ans.lmst = min(lmst, q.lmst);
            ans.rmst = max(rmst, q.rmst);
            if (mii < q.mii) ans.mip = mip, ans.mii = mii, ans.miid = miid;
            else ans.mip = q.mip, ans.mii = q.mii, ans.miid = q.miid;
            return ans;
        }
    } t[MAXN];

    il void pushup(int x) {
        t[x] = t[ls(x)] + t[rs(x)]; ll k;
        if ((k = tg[x].calc(t[x].lmst)) < t[x].mii) t[x].mii = k, t[x].mip = t[x].lmst, t[x].miid = tg[x].id;
        if ((k = tg[x].calc(t[x].rmst)) < t[x].mii) t[x].mii = k, t[x].mip = t[x].rmst, t[x].miid = tg[x].id;
    }

    il void _insert(int x, int l, int r, segment p) {
        int mid = l + r >> 1;
        if (tg[x].calc(mid) > p.calc(mid)) swap(tg[x], p);
        if (l == r) return t[x].mii = tg[x].calc(t[x].mip), t[x].miid = tg[x].id, void();
        if (tg[x].k < p.k) _insert(ls(x), l, mid, p);
        else _insert(rs(x), mid + 1, r, p);
        pushup(x);
    }

    il void insert(int x, int l, int r, int ql, int qr, segment p) {
        if (l > qr || r < ql) return;
        if (l >= ql && r <= qr) return _insert(x, l, r, p);
        int mid = l + r >> 1;
        insert(ls(x), l, mid, ql, qr, p); insert(rs(x), mid + 1, r, ql, qr, p);
        pushup(x);
    }

    il void delt(int x, int l, int r, int k) {
        if (l == r) return t[x].lmst = _inf, t[x].rmst = -_inf, t[x].mii = inf, t[x].mip = _inf, void();
        int mid = l + r >> 1;
        k <= mid ? delt(ls(x), l, mid, k) : delt(rs(x), mid + 1, r, k);
        pushup(x);
    }

    il void build(int x, int l, int r) {
        t[x] = {l, r, l, 0, inf}; tg[x] = {0, inf, 0};
        if (l == r) return;
        int mid = l + r >> 1;
        build(ls(x), l, mid); build(rs(x), mid + 1, r);
    }
} T;

int main() {
    read(n, m); tot = n << 3;
    rer(i, 1, n, val); init(1, 1, n);
    rep1(i, 1, m) {
        int a, b, c, d, w; read(a, b, c, d, w); ++tot;
        now.clear(); get(1, 1, n, c, d);
        for (auto v : now) lnk[tot].eb(v, 0);
        now.clear(); get(1, 1, n, a, b);
        for (auto v : now) lnk[v + 4 * n].eb(tot, w);
    } T.build(1, 1, n);
    rep1(i, 0, tot) dis[i] = inf;
    dis[id[1]] = 0; q.emplace(0, id[1]);
    while (true) {
        int x = q.size() ? q.top().snd : 0; auto t = T.t[1];
        if (t.mii < dis[x]) dis[x = id[t.mip]] = t.mii, pre[x] = id[t.miid];
        else q.pop();
        if (!x) break;
        if (vis[x]) continue;
        vis[x] = 1;
        if (to[x]) T.delt(1, 1, n, to[x]);
        for (auto [v, w] : lnk[x]) {
        	if (dis[v] > dis[x] + w) dis[v] = dis[x] + w, pre[v] = x, q.emplace(-dis[v], v);
		} ll pre = dis[x];
        if (val[x = to[x]]) {
            T.insert(1, 1, n, x + 1, n, {val[x], pre - 1ll * x * val[x], x});
            T.insert(1, 1, n, 1, x - 1, {-val[x], pre + 1ll * x * val[x], x});
        }
    } printf("%lld\n", dis[id[n]]);
    vector <int> route; int x = id[n];
    while (x) {
    	if (to[x]) route.eb(to[x]);
    	x = pre[x];
	} reverse(begin(route), end(route));
	cout << route.size() << '\n';
	for (auto v : route) printf("%d ", v);
    return 0;
}
```

---


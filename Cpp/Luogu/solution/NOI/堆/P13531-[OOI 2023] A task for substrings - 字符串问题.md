# [OOI 2023] A task for substrings / 字符串问题

## 题目背景

CF1801G

## 题目描述

菲利普非常喜欢关于字符串的小题目。他已经解完了所有他知道的相关题目，但这还不能让他满足。于是，菲利普决定自己出一道题。

为此，他准备了一个字符串 $t$，以及一个由 $n$ 个字符串 $s_1, s_2, s_3, \ldots, s_n$ 组成的集合。菲利普还有 $m$ 个查询，每个查询中，他会取出字符串 $t$ 的第 $l_i$ 到第 $r_i$ 个字符组成的子串，并统计其中有多少个子串和集合中的某个字符串完全相同。更正式地说，菲利普想要计算有多少对位置 $(a, b)$ 满足 $l_i \le a \le b \le r_i$，并且 $t$ 的第 $a$ 到第 $b$ 个字符组成的子串等于集合中的某个 $s_j$。

字符串 $t$ 的第 $a$ 到第 $b$ 个字符的子串，指的是从 $t$ 的开头删除 $a-1$ 个字符，从结尾删除 $|t|-b$ 个字符后剩下的字符串，其中 $|t|$ 表示 $t$ 的长度。

菲利普已经解决了这个问题，你能做到吗？

## 说明/提示

### 样例解释

在第一个样例中，第一个查询要求统计整个字符串中属于集合的子串个数。字符串 "aba" 对应的子串有 $[1, 3]$ 和 $[4, 6]$，字符串 "a" 对应的子串有 $[1, 1]$、$[3, 3]$、$[5, 5]$、$[7, 7]$，字符串 "ac" 对应的子串有 $[3, 4]$。所以总共有 $7$ 个子串与集合中的字符串匹配。

在第二个查询中，取 $t$ 的第 $1$ 到第 $3$ 个字符，即字符串 "aba"。其中 "aba" 匹配 $1$ 次，"a" 匹配 $2$ 次，"ac" 不出现。

在第三个查询中，取 $t$ 的第 $2$ 到第 $7$ 个字符，即字符串 "bacaba"。其中 "aba" 匹配 $1$ 次，"a" 匹配 $3$ 次，"ac" 匹配 $1$ 次。

### 评分说明

本题测试点分为 9 组。只有通过某一组的所有测试点，且通过部分之前组的所有测试点，才能获得该组分数。**离线评测**表示该组测试结果会在比赛结束后公布。

| 组别 | 分值 | $n$ | $m$ | $\mid t\mid $ | $S$ | 必须通过的组 | 备注 |
|:----:|:----:|:---:|:---:|:----:|:----:|:------------:|:-----|
| 0    | 0    | --  | --  | --   | --   | --           | 样例测试点 |
| 1    | 10   | $n \le 100$ | $m \le 100$ | $\mid t\mid  \le 100$ | $S \le 10\,000$ | 0 |  |
| 2    | 12   | $n \le 100$ | $m \le 500$ | $\mid t\mid \le 5000$ | -- | 0, 1 |  |
| 3    | 7    | $n \le 5000$ | -- | $\mid t\mid  \le 5000$ | -- | 0, 1, 2 |  |
| 4    | 8    | $n \le 100$ | -- | $\mid t\mid  \le 50\,000$ | -- | 0, 1, 2 |  |
| 5    | 12   | -- | -- | $\mid t \mid \le 100\,000$ | $S \le 100\,000$ | 0, 1 |  |
| 6    | 8    | -- | -- | $\mid t \mid \le 250\,000$ | $S \le 100\,000$ | 0, 1, 5 |  |
| 7    | 7    | -- | -- | $\mid t \mid \le 500\,000$ | $S \le 100\,000$ | 0, 1, 5, 6 |  |
| 8    | 7    | -- | -- | $\mid t \mid \le 750\,000$ | $S \le 100\,000$ | 0, 1, 5, 6, 7 |  |
| 9    | 29   | -- | -- | --   | --   | 0--8          | **离线评测** |


## 样例 #1

### 输入

```
3 5
abacaba
aba
a
ac
1 7
1 3
2 7
2 5
4 5```

### 输出

```
7 3 5 3 1```

## 样例 #2

### 输入

```
4 4
abcdca
ab
ca
bcd
openolympiad
1 5
2 2
2 6
1 6```

### 输出

```
2 0 2 3```

# 题解

## 作者：chen_zhe (赞：3)

**本题解为官方题解的 AI 中文翻译。**

我们记 $count(h)$ 为字符串 $h$ 的所有子串中，出现在集合 $S$ 里的子串数量。对于每个询问，我们需要计算 $count(h[l_i, r_i])$。令 $pref[i] = count(t[0:i))$，即 $t$ 的长度为 $i$ 的前缀中，出现在 $S$ 中的子串数量。令 $suf[i] = count(t[i:|t|))$，即从位置 $i$ 开始的后缀在 $S$ 中出现的子串数量。

可以发现，$pref[r] + suf[l] - count(t)$ 等于 $count(t[l, r])$，再减去那些属于 $S$ 的子串，这些子串在 $t$ 中的起点早于 $l$，终点晚于 $r$。如果不存在这种“跨界”子串，那么答案就很容易求出，所有需要的 $pref[l]$ 和 $suf[r]$ 都可以通过 Aho-Corasick 算法计算得到。

如果存在上述“跨界”子串，则对于询问 $t[l, r]$，我们需要找到这样一个 $S$ 中的子串 $s_i$，它在 $t$ 中的出现起点早于 $l$，终点晚于 $r$。在所有满足条件的 $s_i$ 中，选择右端点最靠左的那个。设其为 $s_i$。注意，$t[l, r]$ 是 $s_i$ 的一个子串，记作 $s_i[l', r']$。同时，$s_i$ 中不存在起点早于 $l'$、终点晚于 $r'$且属于 $S$ 的子串（否则 $t[l, r]$ 会被更靠右的 $S$ 中子串覆盖）。因此，我们可以对 $s_i$ 应用前缀和后缀的原理，递归求解。

为了在询问 $t[l, r]$ 时找到合适的 $s_i$，我们可以用扫描线遍历 $t$。利用 Aho-Corasick 算法，对于每个位置 $i$，找到以 $i$ 结尾的、属于 $S$ 的最长子串（记为 $s_j$）。同时，在一个堆或 set 结构中维护所有右端点不超过 $i$ 的询问的起点。对于每个起点晚于 $s_j$ 起点的询问，$s_j$ 都是合法的覆盖子串。所有这些询问随后从堆中移除。

因此，最终方案需要构建正向和反向的 Aho-Corasick 自动机，并用扫描线遍历 $t$，配合堆维护查询。总复杂度为 $O(S + |t| + m \log m)$。

---


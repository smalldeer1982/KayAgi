# [JLOI2016] 字符串覆盖

## 题目描述

字符串 $A$ 有 $N$ 个子串 $B_1,B_2,...,B_n$。如果将这 $n$ 个子串分别放在恰好一个它在 $A$ 中出现的位置上（子串之间可以重叠）这样 $A$ 中的若干字符就被这 $N$ 个子串覆盖了。问 $A$ 中能被覆盖字符个数的最小值和最大值。

## 说明/提示

字符串长度 $A \le 10000$,$N \le 4$,$\text{子串长度} \le 10000$。

## 样例 #1

### 输入

```
2
hello
4
he
l
l
o
abacaba
4
ab
ba
a
c```

### 输出

```
4 5 
4 6```

# 题解

## 作者：kczno1 (赞：23)

n<=4，n!枚举放置顺序。

最大值:

要尽量少交。

第一个串应该放的尽量前面。

第二个串开头如果跟第一个串不交，应该放在尽量前面；

如果跟第一个串交，应该放在尽量后面，因为如果把前两个串看作一个整体，这样会最长。

后面也一样。

最小值:

第一个串如果不选择第一个位置放，就是一个2->l,1->n的子问题。

如果选择第一个位置放，

如果第二个串不交第一个串，就是末尾+1->l,2->n的一个子问题。

否则第二个串应该放的尽量前面，因为如果把前两个串看作一个整体，这样会最短。

后面的也一样。

dp,状态数O(nl)，转移O(1)。

```cpp
#include<bits/stdc++.h>
using namespace std;

void chmax(int &x,int y) { if(x<y)x=y; }
void chmin(int &x,int y) { if(x>y)x=y; }
#define N 5
#define L 10005
char s[L];int l;
char q[1003];int m;
int pre[N][L],next[N][L],len[N],n;//pre:<=第一个开头匹配 next:>=第一个开头匹配 
int id[N],*pr[N],*nex[N],le[N];
int fail[L],i,j;
void init()
{
    for (i=2;i<=m;++i)
    {
        char now=q[i];
        j=fail[i-1];
        while (j&&q[j+1]!=now) j=fail[j];
        fail[i]=(q[j+1]==now)?j+1:0;
    }
}

bool mark[L];
void ins(int *pre,int *next)
{
    i=0;
    for (j=1;j<=l;++j)
    {
        char now=s[j];
        while (i&&q[i+1]!=now) i=fail[i];
        if (q[i+1]==now) 
        {
            ++i;
            if (i==m) mark[j-m+1]=1;
        }
    }
    for (i=1;i<=l;++i) pre[i]=mark[i]?i:pre[i-1];
    pre[i]=pre[i-1];
    next[l+1]=0;
    for (i=l;i;--i) 
    if (mark[i]) {next[i]=i;mark[i]=0;}
    else next[i]=next[i+1];
}

int f[L][N];bool vis[L][N];
bool *st[N*L];int top;
int dp(int first,int num)//first:字符串=[first..l] num:第几个子串   
{
    if (num>n) return 0;
    first=nex[num][first];
    int &ans=f[first][num];
    if (*(st[top+1]=&vis[first][num])) return ans;*st[++top]=1;
    ans=dp(first+1,num); 
    int last=first+le[num],x0=first;//x0是num-1的开头 
    while ((++num)<=n)
    {
        chmin(ans,dp(last,num)+last-first);//第num个选择不交 
        int x=nex[num][first];
        if (x<x0||x>=last) return ans;
        x0=x;
        chmax(last,x+le[num]);//选择交
    }
    chmin(ans,last-first);
    return ans;
}

int get(int first,int num)
{
    if (num>n) return 0;
    first=nex[num][first];
    if(!first) return -L;
    int last=first+le[num],x0=first,ans=-L;
    while ((++num)<=n)
    {
      chmax(ans,get(last,num)+last-first); //不交 
      int x=pr[num][last];//交:尽量后面 
      if (x<x0||x>=last) return ans;
      x0=x;
      chmax(last,x+le[num]);
    }
    return max(ans,last-first);
} 

int main()
{
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    for (i=1;i<=4;++i) { vis[0][i]=1;f[0][i]=L; }
    int tt,i,j;scanf("%d",&tt);
    while (tt--)
    {
        scanf("%s",s+1);l=strlen(s+1);
        scanf("%d",&n);
        for (i=1;i<=n;++i) 
        {
            scanf("%s",q+1);len[i]=m=strlen(q+1);
            init();
            ins(pre[i],next[i]);
        }
        for (i=1;i<=n;++i) id[i]=i;
        int ans1=L,ans2=0;
        do
        {
            for (i=1;i<=n;++i) {pr[i]=pre[id[i]];nex[i]=next[id[i]];le[i]=len[id[i]];}
            chmin(ans1,dp(1,1));
            for (;top;--top) *st[top]=0;
            chmax(ans2,get(1,1));
        }while (next_permutation(id+1,id+n+1));
        printf("%d %d\n",ans1,ans2);
    }
}
```

---

## 作者：Alex_Wei (赞：14)

> *II. [P3269 [JLOI2016]字符串覆盖](https://www.luogu.com.cn/problem/P3269)
>
> 摘自 [贪心专题](https://www.cnblogs.com/alex-wei/p/greedy.html) 第三部分例题 II.

神仙思维题。**一个时空复杂度均非常优秀的解法**。

显然对于最大值和最小值需要分开计算。首先我们求出一些基础的东西辅助解题：$n$ 个子串 $s_i$ 的 next 数组（KMP）以及与母串 $T$ 在每个位置的匹配情况。这个可以在 $\mathcal{O}(nL)$ 的时间内预处理出来。

### 最大值

遇到这种题目我们似乎无从下手，那么尝试把 $n=4$ 作为突破口。考虑 $n!$ 枚举钦定每个字符串出现位置按开头从左到右的顺序，那么一个贪心的想法是把出现顺序在前面的字符串尽量往前放。但这样有个问题，就是在放第 $i$ 个字符串时有两种情况：是否与 $s_{i-1}$ 重叠，因为两种情况都有可能成为最优解（反例容易举出）。但若确定了是哪种情况，贪心策略就保证了方案唯一：若不重叠，则越往前放越好（给剩下来的字符串留足空间）；若重叠则越往后放越好（因为不劣）。因此再 $2^{n-1}$ 枚举相邻的两个字符串是否重叠即可。注意统计答案是不应只关注前一个字符串，因为可能出现 $l_1<l_2<r_2<l_3<r_3<r_1$ 的情况，其中 $l_i,r_i$ 是 $s_i$ 在 $T$ 中的出现位置，因此需记录的是当前所有字符串的右端点最大值即 $\max r_i$。时间复杂度 $\mathcal{O}(n!2^nnL)$。

当然可以更优：用 $\log$ 级别的查找即 `lower_bound` 代替线性查找即可做到 $\mathcal{O}(nL+n!2^nn\log L)$。

### 最小值

一个显然的想法是舍弃所有被其它字串覆盖的子串，若相同则仅保留一个，因为要使答案最小让其被完全覆盖一定最优。那么剩下来的子串就一定满足若 $l_i<l_j$ 则一定有 $r_i<r_j$，这是很强的一个性质，并且结合最优化的限制，给予我们动态规划的思想：设 $f_{i,S}$ 表示前 $i$ 位放置了集合 $S$ 内的子串的最小值且第 $i$ 位被覆盖，转移时枚举 $p\in S$ 且 $s_p$ 与 $T$ 在 $i$ 处匹配。分两种情况讨论，一种是与已放置字符串有交集，另一种是不交，综合一下转移方程如下：
$$
\mathrm{checkmin}(f_{i,S},\min_{p\in S}\min_{0\leq j<i}f_{j,S\backslash p}+\min(len_p,i-j))
$$
当 $j>i-len_p$ 时 $i-j<len_p$ 故进行贡献为 $len_p$ 的转移不会使答案变得更小（即更优），而当 $j\leq i-len_p$ 时 $i-j>len_p$ 所以进行贡献为 $i-j$ 的转移也不会影响答案，因此可以看做对于每个 $j\in [0,i)$ 都进行 $len_p$ 和 $i-j$ 的转移。$len_p$ 可以通过直接记录 $f_{i,S}$ 前缀最小值优化，而 $i-j$ 的转移可以设 $g_{i,S}$ 表示 $\min_{j=0}^if_{j,S}-j$ 进行优化。再加上滚动数组，本部分时间复杂度 $\mathcal{O}(n2^nL)$，空间复杂度更是仅有惊人的 $\mathcal{O}(2^n)$！

也许你会问：直接用求最小值的 DP 求最大值不就行了吗？非也，因为转移方程中 $\min(len_p,i-j)$ 的部分并没有变成 $\max$，故此时 $len_p$ 只能从 $j\leq i-len_p$ 转移，而 $i-j$ 只能从 $j>i-len_p$ 转移，所以需要加一个线段树维护区间修改与区间最值，很麻烦，不如直接贪心更方便。而且一道题目锻炼两种思维，岂不妙哉？

复杂度分析：本题的时间复杂度为 $\mathcal{O}(n!n2^n\log L+n2^nL)$，空间复杂度为 $\mathcal{O}(nL+2^n)$。很显然后者已经达到了理论下界。实现起来不算麻烦，而且效率非常优秀，以 33ms 的极限速度与仅仅 900K 的空间占用夺得最优解。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define mem(x, v, s) memset(x, v, sizeof(x[0]) * (s))
template <class T1, class T2> void cmin(T1 &a, T2 b){a = a < b ? a : b;}
template <class T1, class T2> void cmax(T1 &a, T2 b){a = a > b ? a : b;}

const int N = 1e4 + 5;
char t[N], s[4][N];
int n, tL, len[4], nxt[4][N];
bool mat[4][N];
void KMP(char *s, int sL, int *nxt, bool *mat) {
	for(int i = 2; i <= sL; i++) {
		nxt[i] = nxt[i - 1];
		while(nxt[i] && s[nxt[i] + 1] != s[i]) nxt[i] = nxt[nxt[i]];
		if(s[nxt[i] + 1] == s[i]) nxt[i]++;
	}
	for(int i = 1, p = 0; i <= tL; i++) {
		while(p && s[p + 1] != t[i]) p = nxt[p];
		if(s[p + 1] == t[i]) p++;
		if(p == sL) mat[i] = 1, p = nxt[p];
		else mat[i] = 0;
	}
}

bool OverLap(char *t, char *s, int tL, int sL, int *nxt) {
	for(int i = 1, p = 0; i <= tL; i++) {
		while(p && s[p + 1] != t[i]) p = nxt[p];
		if(s[p + 1] == t[i]) p++;
		if(p == sL) return 1;
	}
	return 0;
}

int GetMax() {
	if(n == 1) return len[0];
	static int id[4], ans, pos[4][N], cnt[4]; ans = 0, mem(cnt, 0, 4);
	for(int i = 0; i < n; i++) id[i] = i;
	for(int i = 0; i < n; i++) for(int j = 1; j <= tL; j++) if(mat[i][j]) pos[i][cnt[i]++] = j - len[i];
	do {
		for(int S = 0; S < 1 << n - 1; S++) {
			int cur = -1, res = 0, rbound = 0;
			for(int bit = 0; bit < n; bit++) {
				int i = id[bit];
				if(!bit) {cur = pos[i][0], rbound = cur + len[i] - 1, res = len[i]; continue;}
				int p = -1, pr = id[bit - 1];
				if(S >> bit - 1 & 1) {
					int rlim = min(tL - len[i] + 1, cur + len[pr] - 1);
					int it = upper_bound(pos[i], pos[i] + cnt[i], rlim) - pos[i];
					if(it == 0 || pos[i][it - 1] < cur) break;
					p = pos[i][it - 1];
				}
				else {
					int it = lower_bound(pos[i], pos[i] + cnt[i], cur + len[pr]) - pos[i];
					if(it == cnt[i]) break;
					p = pos[i][it];
				}
				res += max(0, p + len[i] - 1 - max(rbound, p - 1));
				cmax(rbound, p + len[i] - 1), cur = p;
			}
			cmax(ans, res);
		}
	} while(next_permutation(id, id + n));
	return ans;
}

int GetMin() {
	if(n == 1) return len[0];
	static int ban[4], id[4], m; mem(ban, 0, 4), m = 0;
	for(int i = 0; i < n; i++) for(int j = 0; j < n; j++)
		if(strcmp(s[i] + 1, s[j] + 1)) ban[j] |= OverLap(s[i], s[j], len[i], len[j], nxt[j]);
	for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) ban[j] |= !strcmp(s[i] + 1, s[j] + 1);
	for(int i = 0; i < n; i++) if(!ban[i]) id[m++] = i;
	static int f[2][16], g[2][16];
	mem(f, 0x3f, 2), mem(g, 0x3f, 2), f[0][0] = g[0][0] = 0;
	for(int i = 1, cur = 1, pr = 0; i <= tL; i++, swap(cur, pr)) {
		for(int j = 0; j < 1 << m; j++) {
			f[cur][j] = N;
			for(int k = 0; k < j; k++) {
				if(!(j >> k & 1)) continue;
				int S = j - (1 << k), p = id[k];
				if(mat[p][i]) cmin(f[cur][j], min(f[pr][S] + len[p], g[pr][S] + i));
			}
			g[cur][j] = min(g[pr][j], f[cur][j] - i), cmin(f[cur][j], f[pr][j]);
		}
	}
	return f[tL & 1][(1 << m) - 1];
}

void solve() {
	scanf("%s %d", t + 1, &n), tL = strlen(t + 1);
	for(int i = 0; i < n; i++) {
		scanf("%s", s[i] + 1);
		KMP(s[i], len[i] = strlen(s[i] + 1), nxt[i], mat[i]);
	}
	cout << GetMin() << " " << GetMax() << "\n";
}

int main(){
	int T; cin >> T;
	while(T--) solve();
	return 0;
}
```

**启示：在时间复杂度可以承受的前提下尽可能确定更多信息，也许其所带来的重要性质使 DP 或贪心变得可行。**

---

## 作者：封禁用户 (赞：3)

题意:给你一个无向图,其中一个点双联通分量算作一个点,询问两个点之间有多少点

点双联通分量:所谓点-双连通分量是指在一个无向图中两点间至少有两条路径,且路径中(不算头尾)的点不同.

我们只要把所有的双联通分量缩成一个点,然后这个图又是一个连通图

即缩点之后就是一个联通无环图了——即树

询问两点之间有多点就是询问树上距离+1了

树上距离=dep[u]+dep[v]-2*dep[lca(u,v)]

然后这道题,tarjan的时候最好用vector存边,不然第4个点死活过不去(不要问我为啥知道的)

---

## 作者：StarPatrick (赞：2)

写一篇 SA 的题解，只不过这个 SA 是模拟退火，不是后缀数组。

为什么会想到模拟退火呢，观察到 $N\le4$，自然浮现搜索的想法，但是搜索也是 $O(|A|^N)$ 的复杂度，过不了，加了减枝应该也不好过（也许可以启发式搜索什么的，没试过），因此想到模拟退火。

这题模拟退火比较好想，直接哈希把能匹配的位置找出来退火就好，这部分的复杂度是 $O(n)$ 的。

具体模拟退火的过程就记录 $u1,u2,u3,u4$ 表示在 4 个串中匹配的位置，计算答案就直接把四个区间求并集，排序即可，计算答案是 $O(1)$ 的。


参数看代码即可，就不多赘述。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int base = 31, mod = 1e9+7;
int t, n, m, len[5], MIN, MAX, tot;
ll H[10005], pw[10005];
char a[10005], b[1005];
vector<int> v[5];
mt19937 Rand(time(0));
uniform_real_distribution<double> zqw(0, 1);
struct e{
	int l, r;
}temp[5];
inline bool cmp(e x, e y) {
	return x.l<y.l;
}
inline int calc(int u1, int u2, int u3, int u4) {
	tot = 0;
	temp[++tot] = {v[1][u1], v[1][u1]+len[1]-1};
	if (m>=2) temp[++tot] = {v[2][u2], v[2][u2]+len[2]-1};
	if (m>=3) temp[++tot] = {v[3][u3], v[3][u3]+len[3]-1};
	if (m>=4) temp[++tot] = {v[4][u4], v[4][u4]+len[4]-1};
	stable_sort(temp+1, temp+tot+1, cmp);
	int last = temp[1].r, u = temp[1].r-temp[1].l+1;
	for (int p=2;p<=tot;p++) {
		if (temp[p].l>last) {
			u+=temp[p].r-temp[p].l+1;
			last = temp[p].r;
		}
		else if (temp[p].r>last) {
			u+=temp[p].r-last;
			last = temp[p].r;
		}
	}
	return u;
}
void SAMIN() {
	uniform_int_distribution<int> rand1(-v[1].size(), v[1].size()), rand2(-v[2].size(), v[2].size()), rand3(-v[3].size(), v[3].size()), rand4(-v[4].size(), v[4].size());
	int u1 = rand1(Rand), u2 = rand2(Rand), u3 = rand3(Rand), u4 = rand4(Rand);
	u1 = (u1+v[1].size())%v[1].size();
	if (m>=2) u2 = (u2+v[2].size())%v[2].size();
	if (m>=3) u3 = (u3+v[3].size())%v[3].size();
	if (m>=4) u4 = (u4+v[4].size())%v[4].size();
	int now = calc(u1, u2, u3, u4);
	MIN = min(MIN, now);
	MAX = max(MAX, now);
	double T = 100;
	while (T>1) {
		int d1 = u1+(int)rand1(Rand)*T/100, d2 = u2+(int)rand2(Rand)*T/100, d3 = u3+(int)rand3(Rand)*T/100, d4 = u4+(int)rand4(Rand)*T/100;
		d1 = (d1+v[1].size())%v[1].size();
		if (m>=2) d2 = (d2+v[2].size())%v[2].size();
		if (m>=3) d3 = (d3+v[3].size())%v[3].size();
		if (m>=4) d4 = (d4+v[4].size())%v[4].size();
		int fut = calc(d1, d2, d3, d4);
		MIN = min(MIN, fut);
		MAX = max(MAX, fut);
		if (fut<=now||exp((now-fut)/sqrt(T))>zqw(Rand)) {
			now = fut;
			u1 = d1, u2 = d2, u3 = d3, u4 = d4;
		}
		T*=0.99;
	}
	return ;
}
void SAMAX() {
	uniform_int_distribution<int> rand1(-v[1].size(), v[1].size()), rand2(-v[2].size(), v[2].size()), rand3(-v[3].size(), v[3].size()), rand4(-v[4].size(), v[4].size());
	int u1 = rand1(Rand), u2 = rand2(Rand), u3 = rand3(Rand), u4 = rand4(Rand);
	u1 = (u1+v[1].size())%v[1].size();
	if (m>=2) u2 = (u2+v[2].size())%v[2].size();
	if (m>=3) u3 = (u3+v[3].size())%v[3].size();
	if (m>=4) u4 = (u4+v[4].size())%v[4].size();
	int now = calc(u1, u2, u3, u4);
	MIN = min(MIN, now);
	MAX = max(MAX, now);
	double T = 2e5;
	while (T>0.001) {
		int d1 = u1+(int)rand1(Rand)*T/200000, d2 = u2+(int)rand2(Rand)*T/200000, d3 = u3+(int)rand3(Rand)*T/200000, d4 = u4+(int)rand4(Rand)*T/200000;
		d1 = (d1+v[1].size())%v[1].size();
		if (m>=2) d2 = (d2+v[2].size())%v[2].size();
		if (m>=3) d3 = (d3+v[3].size())%v[3].size();
		if (m>=4) d4 = (d4+v[4].size())%v[4].size();
		int fut = calc(d1, d2, d3, d4);
		MIN = min(MIN, fut);
		MAX = max(MAX, fut);
		if (fut>=now||exp((fut-now)/sqrt(T))>zqw(Rand)) {
			now = fut;
			u1 = d1, u2 = d2, u3 = d3, u4 = d4;
		}
		T*=0.99;
	}
	return ;
}
int main() {
	pw[0] = 1;
	for (int p=1;p<=10000;p++) {
		pw[p] = pw[p-1]*base%mod;
	}
	scanf("%d", &t);
	for (int zqw=1;zqw<=t;zqw++) {
		MIN = 1e9, MAX = 0;
		cin>>a+1;
		n = strlen(a+1);
		for (int p=1;p<=n;p++) {
			H[p] = (H[p-1]*base+a[p]-'a'+1)%mod;
		}
		scanf("%d", &m);
		for (int p=1;p<=m;p++) {
			v[p].clear();
			cin>>b+1;
			len[p] = strlen(b+1);
			ll u = 0;
			for (int k=1;k<=len[p];k++) {
				u = (u*base+b[k]-'a'+1)%mod;
			}
			for (int k=1;k<=n-len[p]+1;k++) {
				if ((H[k+len[p]-1]-H[k-1]*pw[len[p]]%mod+mod)%mod==u) v[p].push_back(k);
			}
		}
		for (int p=1;p<=300;p++) {
			SAMIN();
		}
		SAMAX();
		printf("%d %d\n", MIN, MAX);
	}
    return 0;
}
```


---

## 作者：Leasier (赞：2)

$\min/\max$ 肯定要分开处理，这里先来考虑 $\min$。

贪心地，不难想到若 $i \neq j$ 且 $B_i$ 为 $B_j$ 的子串，则直接把 $B_i$ 放到 $B_j$ 覆盖后内部的某个位置一定不劣。于是我们先把这些没用的 $B_i$ 扔了，反正它们不影响答案。

但是接下来直接填子串看上去非常困难，考虑通过状压 dp 钦定一个最右端点右移的先后顺序。设 $f_{S, i}$ 表示已经**按照右端点从小到大**填了 $S$ 中的所有串，最后一个填的串的右端点为 $i$ 的最小长度。

初值：$f_{\emptyset, i} = [i \neq 0](+\infty)$。

转移：$f_{S, i} = \displaystyle\min_{x \in S} \min_{j = 0}^i (f_{S - \{x\}, j} + \min(|B_x|, i - j))$。

答案：$\displaystyle\min_{i = 1}^{|A|} f_{S_0, i}$，其中 $S_0$ 表示扔掉没用 $B_i$ 后剩下的集合。

但是直接做的时间复杂度为 $O(T(\sum |B_i| + n 2^n |A|^2))$，显然不能通过。

注意到我们可以将转移式改写成 $f_{S, i} = \displaystyle\min_{x \in S} \min_{j = 0}^i \min(f_{S - \{x\}, j} + |B_x|, f_{S - \{x\}, j} + i - j)$，则我们可以对于每个 $S$，分别对 $f_{S, i}, f_{S, i} - i$ 做前缀 $\min$，于是转移被优化至 $O(n)$，则这部分的时间复杂度为 $O(T(\sum |B_i| + n 2^n |A|))$。

现在来看看 $\max$ 怎么做。

由于此时把有包含关系的子串分开更优，我们不需要像 $\min$ 那样扔掉被包含者。

dp 部分跟上面几乎一样：设 $g_{S, i}$ 表示已经**按照右端点从小到大**填了 $S$ 中的所有串，最后一个填的串的右端点为 $i$ 的最大长度。

初值：$g_{\emptyset, i} = [i \neq 0](-\infty)$。

转移：$g_{S, i} = \displaystyle\max_{x \in S} \max_{j = 0}^i (g_{S - \{x\}, j} + \min(|B_x|, i - j))$。

答案：$\displaystyle\max_{i = 1}^{|A|} g_{\{1, 2, \cdots, n\}, i}$。

但是直接做的时间复杂度仍为 $O(T(\sum |B_i| + n 2^n |A|^2))$，显然不能通过。

这里有一件很麻烦的事：因为最里面 $\min$ 的前面是 $\max$，我们没法直接像上面那样搞。

考虑讨论一下 $\min$ 的取值情况：

- $0 \leq j \leq k - |B_x|$：此时取到 $g_{S - \{x\}, j} + |B_x|$，前缀 $\max$ 优化即可。
- $k - |B_x| + 1 \leq j \leq k$：此时取到 $g_{S - \{x\}, j} + i - j$，每算完一车 $g_{S, i}$ 后把 $g_{S, i} - i$ 丢到 ST 表里，查询时用 ST 表求区间 $\max$ 即可。

于是这部分的时间复杂度为 $O(T(\sum |B_i| + n 2^n |A| \log |A|))$。

综上，时间复杂度为 $O(T(\sum |B_i| + n 2^n |A| \log |A|))$。~~荣获最劣解！！！~~

代码：
```cpp
#include <iostream>
#include <set>
#include <cstdio>
#include <cstring>
#include <cmath>

using namespace std;

typedef long long ll;

const int N = 1e4, seed = 998244353, mod = 1e9 + 7;
ll power[N + 7];

typedef struct {
	ll hash[N + 7];
	
	inline void init(char s[]){
		int len = strlen(&s[1]);
		for (int i = 1; i <= len; i++){
			hash[i] = (hash[i - 1] * seed % mod + s[i]) % mod;
		}
	}
	
	inline ll get_hash(int l, int r){
		return ((hash[r] - hash[l - 1] * power[r - l + 1] % mod) % mod + mod) % mod;
	}
} Hash;

const int M = 13 + 7;

typedef struct {
	int st[N + 7][M];
	
	inline void init(int n, int a[]){
		int m = log2(n);
		for (register int i = 1; i <= n; i++){
			st[i][0] = a[i] - i;
		}
		for (register int i = 1; i <= m; i++){
			int id = i - 1, t1 = n - (1 << i) + 1, t2 = 1 << id;
			for (register int j = 1; j <= t1; j++){
				st[j][i] = max(st[j][id], st[j + t2][id]);
			}
		}
	}
	
	inline int get_max(int l, int r){
		if (l > r) return 0x80000000;
		int t = log2(r - l + 1);
		return max(st[l][t], st[r - (1 << t) + 1][t]);
	}
} ST;

const int K = 4 + 7, P = 15 + 7;
Hash hasha;
int lenb[K], use[K], dp[P][N + 7], pre1[P][N + 7], pre2[P][N + 7], p[K];
char a[N + 7], b[N + 7];
bool mark[K], vis[N + 7];
Hash hashb[K];
ST st[P];
set<int> s[K];

inline void init(){
	power[0] = 1;
	for (register int i = 1; i <= N; i++){
		power[i] = power[i - 1] * seed % mod;
	}
}

int main(){
	int t;
	scanf("%d", &t);
	init();
	for (register int i = 1; i <= t; i++){
		int lena, n, m = 0, full, ans_min = 0x7fffffff, ans_max = 0;
		scanf("%s", &a[1]);
		lena = strlen(&a[1]);
		hasha.init(a);
		scanf("%d", &n);
		for (register int j = 1; j <= n; j++){
			scanf("%s", &b[1]);
			lenb[j] = strlen(&b[1]);
			mark[j] = false;
			s[j].clear();
			hashb[j].init(b);
			for (register int k = 1; ; k++){
				int r = k + lenb[j] - 1;
				if (r > lena) break;
				if (hasha.get_hash(k, r) == hashb[j].hash[lenb[j]]) s[j].insert(r);
			}
		}
		for (register int j = 1; j <= n; j++){
			for (register int k = 1; k <= n; k++){
				if (j != k && !mark[j] && !mark[k] && lenb[j] >= lenb[k]){
					bool flag = false;
					for (register int l = 1; ; l++){
						int r = l + lenb[k] - 1;
						if (r > lenb[j]) break;
						if (hashb[j].get_hash(l, r) == hashb[k].hash[lenb[k]]){
							flag = true;
							break;
						}
					}
					if (flag) mark[k] = true;
				}
			}
		}
		for (register int j = 1; j <= n; j++){
			if (!mark[j]) use[++m] = j;
		}
		full = (1 << m) - 1;
		for (register int j = 1; j <= lena; j++){
			dp[0][j] = 1e9;
		}
		for (register int j = 1; j <= full; j++){
			for (register int k = 0; k <= lena; k++){
				dp[j][k] = 1e9;
				for (register int l = 1; l <= m; l++){
					if ((j >> (l - 1) & 1) && s[use[l]].count(k)){
						int x = j ^ (1 << (l - 1));
						dp[j][k] = min(pre1[x][k] + lenb[use[l]], pre2[x][k] + k);
					}
				}
				pre1[j][k] = dp[j][k];
				pre2[j][k] = dp[j][k] - k;
				if (k > 0){
					pre1[j][k] = min(pre1[j][k], pre1[j][k - 1]);
					pre2[j][k] = min(pre2[j][k], pre2[j][k - 1]);
				}
			}
		}
		for (register int j = 1; j <= lena; j++){
			ans_min = min(ans_min, dp[full][j]);
		}
		full = (1 << n) - 1;
		for (register int j = 1; j <= lena; j++){
			dp[0][j] = 0x80000000;
		}
		st[0].init(lena, dp[0]);
		for (register int j = 1; j <= full; j++){
			for (register int k = 0; k <= lena; k++){
				dp[j][k] = 0;
				for (register int l = 1; l <= n; l++){
					if ((j >> (l - 1) & 1) && s[l].count(k)){
						int x = j ^ (1 << (l - 1));
						dp[j][k] = max(dp[j][k], max(pre1[x][k - lenb[l]] + lenb[l], st[x].get_max(k - lenb[l] + 1, k) + k));
					}
				}
				pre1[j][k] = dp[j][k];
				if (k > 0) pre1[j][k] = max(pre1[j][k], pre1[j][k - 1]);
			}
			st[j].init(lena, dp[j]);
		}
		for (register int j = 1; j <= lena; j++){
			ans_max = max(ans_max, dp[full][j]);
		}
		cout << ans_min << " " << ans_max << endl;
	}
	return 0;
}
```

---

## 作者：tzc_wk (赞：2)

> 摘自我的 [贪心/构造/DP 杂题选做Ⅱ](https://www.cnblogs.com/ET2006/p/greedy-construction-dp2.html) 中的第 $43$ 题

首先求出每个给出的子串在 $S$ 中的出现位置，这个可以通过字符串哈希实现，不妨设第 $i$ 个字符串所有出现位置的左端点为 $p_{i,1},p_{i,2},\cdots,p_{i,c_i}$。

考虑如何求出所有字符串覆盖的位置的并的最大值，注意到题目一个非常关键的条件：$n\le 4$。考虑枚举所有字符串起点的大小关系，这个 $n!$ 枚举一下即可，再枚举相邻字符串两两之间是否重叠，同样 $2^{n-1}$ 枚举一下，考虑如何贪心地对每种情况安排每个字符串的启示问题，对于相邻两字符串 $i,i+1$，如果它俩不重叠，那么我们肯定尽量希望 $i+1$ 放置的位置尽可能靠前，否则我们肯定尽量希望 $i+1$ 放置的位置尽可能靠后，这个将每个串出现的位置压入一个 `set` 然后在 `set` 中 `upper_bound` 即可找到，这样最大值部分就可以在 $|S|·n!·2^{n-1}$ 的时间内解决。

接下来考虑如何求所有字符串覆盖的位置的并的最小值，首先我们踢掉 $n$ 个子串中所有包含于另一个子串的子串，因为由于我们求的是最小值，我们肯定会将这样的子串覆盖在包含它的那个子串的位置上最优，此时这样的字符串不会对答案产生任何影响。这样我们可以设计出一个 DP：$dp_{i,j}$ 表示目前选择了 $j$ 中的字符串，并且目前选择的字串中，右端点最大的字符串的出现位置的右端点为 $i$，覆盖的位置的并的大小的最小值，转移就枚举右端点为 $j$ 的字符串是啥，设为 $x$，有两种转移：

- $dp_{i,j}\leftarrow dp_{k,j-\{x\}}+len_x$，其中 $len_x$ 为子串 $x$ 的长度，$k<i-len_x$
- $dp_{i,j}\leftarrow dp_{k,j-\{x\}}+i-k$，其中 $i-len_x\le k<i$。

乍一看这个转移式，你可能会以为需要用线段树等结构维护转移，实则不用。可以发现对于上面那种转移，必然有 $i-k>len_x$，因此我们把下面那种转移的下界改成 $0$ 依然可以计算得到正确的 DP 值，这样转移就变成求一段前缀 $\min$ 的形式，维护两个数组 $mn1_{i,j}$ 表示 $\min_{k\le i}dp_{k,j}$，$mn2_{i,j}$ 表示 $\min_{k\le i}dp_{k,j}-k$，这样可以 $\mathcal O(1)$ 转移，于是我们就在 $\mathcal O(|S|·2^{n})$ 的时间内求出了最小值。

```cpp
const int MAXN=1e4;
const u64 BS=131;
int n,m,p[5],l[5];char s[MAXN+5];
u64 hs[MAXN+5],pw[MAXN+5];set<int> occ[5],tmp[5];
u64 gethash(int l,int r){return hs[r]-hs[l-1]*pw[r-l+1];}
int dp[MAXN+5][17],mn1[MAXN+5][17],mn2[MAXN+5][17];
bool ban[5];
void solve(){
	scanf("%s%d",s+1,&n);m=strlen(s+1);
	for(int i=1;i<=n;i++) occ[i].clear(),ban[i]=0;
	for(int i=1;i<=m;i++) hs[i]=hs[i-1]*BS+s[i];
	for(int i=1;i<=n;i++){
		static char buf[MAXN+5];scanf("%s",buf+1);
		int len=strlen(buf+1);u64 hst=0;l[i]=len;
		for(int j=1;j<=len;j++) hst=hst*BS+buf[j];
		for(int j=1;j+len-1<=m;j++) if(gethash(j,j+len-1)==hst)
			occ[i].insert(j);
	} int mx=0;
	for(int i=1;i<=n;i++) p[i]=i;
	do {
		for(int i=1;i<=n;i++) tmp[i]=occ[i];
		for(int i=0;i<(1<<n-1);i++){
			int pre=0,sum=0,flg=1;
			for(int j=1;j<=n;j++){
				if(j==1||(i>>(j-2)&1)){
					set<int>::iterator it=tmp[p[j]].upper_bound(pre);
					if(it==tmp[p[j]].end()){flg=0;break;}
					pre=(*it)+l[p[j]]-1;sum+=l[p[j]];
				} else {
					set<int>::iterator it=tmp[p[j]].upper_bound(pre);
					if(it==tmp[p[j]].begin()){flg=0;break;}
					--it;int ed=(*it)+l[p[j]]-1;
					if(ed>pre) sum+=ed-pre,pre=ed;
				}
			} if(flg) chkmax(mx,sum);
		}
	} while(next_permutation(p+1,p+n+1));
	memset(dp,63,sizeof(dp));memset(mn1,63,sizeof(mn1));
	memset(mn2,63,sizeof(mn2));int lim=(1<<n)-1;
	for(int i=1;i<=n;i++){
		if(!occ[i].size()){ban[i]=1;continue;}
		int pos=*occ[i].begin();
		for(int j=1;j<=n;j++) if((i^j)&&occ[j].size()){
			if(l[i]==l[j]&&i<j) continue;
			set<int>::iterator it=occ[j].lower_bound(pos);
			if(it!=occ[j].end()){
//				printf("%d %d %d %d\n",i,j,pos,*it);
				if(pos+l[i]-1>=(*it)+l[j]-1){
					ban[j]=1;
				}
			}
		}
	}
	for(int i=1;i<=n;i++) if(ban[i]) lim^=(1<<i-1);
//	printf("lim=%d\n",lim);
	dp[0][0]=mn1[0][0]=mn2[0][0]=0;
	for(int i=1;i<=m;i++){
		for(int j=0;j<(1<<n);j++){
			if((j&lim)!=j) continue;
			for(int k=1;k<=n;k++) if(j>>(k-1)&1){
				if(occ[k].find(i-l[k]+1)==occ[k].end()) continue;
				chkmin(dp[i][j],mn1[i-l[k]][j^(1<<k-1)]+l[k]);
				chkmin(dp[i][j],mn2[i][j^(1<<k-1)]+i);
			}
			mn1[i][j]=min(mn1[i-1][j],dp[i][j]);
			mn2[i][j]=min(mn2[i-1][j],dp[i][j]-i);
//			printf("%d %d %d\n",i,j,dp[i][j]);
		}
	}
	printf("%d %d\n",mn1[m][lim],mx);
}
int main(){
	for(int i=(pw[0]=1);i<=MAXN;i++) pw[i]=pw[i-1]*BS;
	int qu;scanf("%d",&qu);while(qu--) solve();
	return 0;
}
/*
1
abacab
4
ab
ab
ac
ca
*/
```

---

## 作者：chen_hx (赞：1)

###  简单概况一下题意
> 给定一个母串S与其子串T ，要将T放入母串中 ，在允许相互覆盖或者相交的情况下 ，问这些子串在母串中覆盖的字符 最多/少 是多少

### 分析
> 看见最值很容易就往dp上想，但是这题直接dp会有后效性，就是每个串放的位置没有顺序。但是子串个数非常小，因此可以 $O(n!)$ 的时间枚举放置顺序，这样就消除了dp的后效性。

> 考虑两个字符串是否相覆盖。假如相覆盖，那么其实就是等价于不放那个被覆盖掉的字符串，而被谁覆盖其实并不重要，因为只需要知道这个串对答案的贡献为零即可，因此可以用 $O(2^n)$ 的时间来枚举每个串是否被覆盖，然后写一个函数判覆盖是否合法即可。

### 状态设计
> 阶段性和相覆盖的情况已经枚举过了，剩下的字符串就是要么相交要么不交了（反正不会相覆盖了），那么当前这个串对答案的贡献只与上一个串有关了，那么可以设计dp状态：

 > * $f[i][j]$ 表示强制第 $i$ 个串放在 $j$ 上覆盖字符个数的最大值
 
 > * $g[i][j]$ 表示强制第 $i$ 个串放在 $j$ 上覆盖字符个数的最小值
 
### 转移方程
> 分两种情况来考虑：  
① 与上一个字符串有交  
② 与上一个字符串无交

> 首先设上一个字符串的头的位置是 $k$ , 那么上一个串的结尾位置就是 $k+len_{i-1}-1$ 。当前这个字符串的头的位置是 $j$ , 结尾位置是 $j+len_i-1$ 。若两串有交就意味着

$$ \left\{
\begin{aligned}
j  ≤  k+len_{i-1}-1 \\
k+len_{i-1}-1  < j+len_i-1 \\
j > k
\end{aligned}
\right.
$$

> 解出来就是  

$$
j-len_{i-1}+1 ≤ k ≤ min(j-1,j+len_i-len_{i-1})
$$
> 于是就有转移方程

$$
	f[i][j]=min_{j-len_{i-1}+1 ≤ k ≤ min(j-1,j+len_i-len_{i-1})}(f[i-1][k]+j+len_i-1-k-len_{i-1}+1) 

$$

$$
	g[i][j]=max_{j-len_{i-1}+1 ≤ k ≤ min(j-1,j+len_i-len_{i-1})}(g[i-1][k]+j+len_i-1-k-len_{i-1}+1) 

$$


> 不难发现这个很像一个定长的区间在左右滑动，那就用单调队列优化一下，单调队列里记得是 $f[i-1][j]-j$  与 $g[i-1][j]-j$ 即可。

> 然后考虑不交的情况 , 如果不交，那么这个串的贡献就是这个串的长度，就有转移方程

$$
f[i][j]=min_{k<j-len_{i-1}+1}(f[i-1][k]+len_i) 
$$
$$
g[i][j]=max_{k<j-len_{i-1}+1}(g[i-1][k]+len_i) 
$$

> 发现与上个串的末位置无关了，那么就用一个前缀最小最大值来优化即可  
转移的时间复杂度是 $O(nL)$ 的， 所以总的时间复杂度是 $O(2^n \ n! \ nL)$ 

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch))f^=(ch=='-'),ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f?x:-x;
}
const int N=1e4+5;
int n,idx[5];

struct str{
	int len,kmp[N];
	char S[N];
}s,t[5],tmp[5];

inline int cmp(str x,str y){
	return x.len>y.len;
}
inline void getkmp(str &x){
	x.kmp[1]=0;
	for(int i=2,j=0;i<=x.len;i++){
		while(j&&x.S[i]!=x.S[j+1])j=x.kmp[j];
		x.kmp[i]=(j+=(x.S[i]==x.S[j+1]));
	}
}
inline int check(str s1,str s2){		//s1 <- s2
	int j=0;
	for(int i=1;i<=s1.len;i++){
		while(j&&s1.S[i]!=s2.S[j+1])j=s2.kmp[j];
		if(s1.S[i]==s2.S[j+1])j+=1;
		if(j==s2.len)return 1;
	}
	return 0;
}



inline int lowbit(int x){
	return x&-x;
}
inline int cnt(int x){
	int ret=0;
	while(x){
		x-=lowbit(x);
		ret+=1;
	}
	return ret;
}

int tag[5][N],use[5],minans=1e9,maxans=-1e9;
int f[5][N],g[5][N],maxhd,maxtl,minhd,mintl,qmax[N],qmin[N],premax,premin;
int fuck[5][5];
void trans(int j){
	int premin=1e9,premax=-1e9,now=1;
	int len1=tmp[j].len,len2=tmp[j-1].len;
	minhd=maxhd=1;
	mintl=maxtl=0;
	for(int i=1;i<=s.len;i++){
		int l=i-len2+1,r=min(i-1,i+len1-len2);
		while(minhd<=mintl&&qmin[minhd]<l)
			premin=min(premin,f[j-1][qmin[minhd++]]);
		while(maxhd<=maxtl&&qmax[maxhd]<l)
			premax=max(premax,g[j-1][qmax[maxhd++]]);
		for(;now<=r;now++){
			while(minhd<=mintl&&f[j-1][qmin[mintl]]-qmin[mintl]>=f[j-1][now]-now)mintl--;
			while(maxhd<=maxtl&&g[j-1][qmax[maxtl]]-qmax[maxtl]<=g[j-1][now]-now)maxtl--;
			qmin[++mintl]=now;
			qmax[++maxtl]=now;
		}
		if(tag[j][i]){
			f[j][i]=premin+len1;
			g[j][i]=premax+len1;
			if(minhd<=mintl){
				int k=qmin[minhd];
				f[j][i]=min(f[j][i],f[j-1][k]-k+i-len2+len1);
			}
			if(maxhd<=maxtl){
				int k=qmax[maxhd];
				g[j][i]=max(g[j][i],g[j-1][k]-k+i-len2+len1);
			}
		}
	}
}
void search(int Sq,int lar){
	for(int i=1,j=1;i<=lar,j<=n;j++){
		if((Sq>>(j-1))&1){
			tmp[idx[j]]=t[j];
		}
	}
	memset(f,0x3f,sizeof(f));
	memset(g,-0x3f,sizeof(g));
	memset(tag,0,sizeof(tag));
	for(int k=1;k<=lar;k++){
		int now=0;
		for(int i=1;i<=s.len;i++){
			while(now&&tmp[k].S[now+1]!=s.S[i])now=tmp[k].kmp[now];
			if(tmp[k].S[now+1]==s.S[i])now++;
			if(now==tmp[k].len){
				tag[k][i-tmp[k].len+1]=1;
				now=tmp[k].kmp[now];
			}
		}
	}
	for(int i=1;i<=s.len;i++){
		if(tag[1][i]){
			f[1][i]=tmp[1].len;
			g[1][i]=tmp[1].len;
		}
	}
	for(int j=2;j<=lar;j++){
		trans(j);
	}
	for(int i=1;i<=s.len;i++){
		minans=min(minans,f[lar][i]);
		maxans=max(maxans,g[lar][i]);
	}
}

void dfs(int ok,int up,int Sq){
	//S表示状态  up表示枚举上限 
	if(ok>n){
		search(Sq,up);
		return;
	}
	else{
		if((Sq>>(ok-1))&1){
			for(int i=1;i<=up;i++){
				if(!use[i]){
					use[i]=1;
					idx[ok]=i;
					dfs(ok+1,up,Sq);
					use[i]=0;
				}
			}
		}
		else dfs(ok+1,up,Sq);
	}
}

inline void solve(){
    minans=1e9;
    maxans=-1e9;
	scanf("%s",s.S+1);
	s.len=strlen(s.S+1);
	getkmp(s);
	n=read();
	for(int i=1;i<=n;i++){
		scanf("%s",t[i].S+1);
		t[i].len=strlen(t[i].S+1);
		getkmp(t[i]);
	}
	sort(t+1,t+n+1,cmp);
	memset(fuck,0,sizeof(fuck));
	for(int i=1;i<=n;i++){
		for(int j=1;j<i;j++){
			if(check(t[j],t[i]))fuck[j][i]=1;
		}
	}
	for(int ss=0;ss<(1<<n);ss++){
		int flg=1;
		for(int i=1;i<=n;i++){
			if(!(1&(ss>>i-1))){
				int shabi=1;
				for(int j=1;j<i;j++){
					if((1&(ss>>j-1))&&fuck[j][i]){
						shabi=0;
						break;
					}
				}
				if(shabi)flg=0;
			}
		}
		if(flg)dfs(1,cnt(ss),ss);
	}
	printf("%lld %lld\n",minans,maxans);
}
signed main(){
	int T=read();
	while(T--)solve();
}
```


---

## 作者：劉子颺 (赞：1)

A Naive Sol

发现顺序似乎挺关键的

考虑状压把顺序压掉

F(i,Mx)前i个字母 状态是已经用了多少个

考虑min因为max很简单

故考虑转移发现如果从小于St的过来 那么是 len

否则是 i-Fro

做过BZOJ2865的人都懂 这不过是两颗线段树的是

对于16种状态 不过是 32棵线段树的事（n那么小怕个啥）

那么考虑一些非法的状态就是兹出去了

这实际上是不优的Unique掉就行了！

Max的同理 再开32棵线段树水过去即可

复杂度$2^{k}*N*log_{2}N*m*T$
代码有点长但是正确性显然

```
struct SubTaskMin{
	#define INF (1e9)
	struct Segment_Tree_One{
		struct Segment_Node{
			int lson,rson,sum;
		}T[N<<2];
		void PushUp(int p){
			T[p].sum=min(T[lc].sum,T[rc].sum);
		}
		void Build(int p,int l,int r){
			T[p].lson=l;
			T[p].rson=r;
			if(l==r){T[p].sum=INF;return;}
			int mid=(l+r)>>1;
			Build(lc,l,mid);
			Build(rc,mid+1,r);
			PushUp(p);
		}
		void Update(int p,int pos,int v){
			if(T[p].lson==T[p].rson){
				T[p].sum=min(T[p].sum,v);
				return;
			}
			int mid=(T[p].lson+T[p].rson)>>1;
			if(pos<=mid)Update(lc,pos,v);
			else Update(rc,pos,v);
			PushUp(p);
		}
		int Query(int p,int l,int r){
			if(l<=T[p].lson&&T[p].rson<=r){
				return T[p].sum;
			}
			int mid=(T[p].lson+T[p].rson)>>1;
			int ret=INF;
			if(l<=mid)ret=min(ret,Query(lc,l,r));
			if(mid< r)ret=min(ret,Query(rc,l,r));
			return ret;
		}
	}T1[16],T2[16];
	int Del[5];
	void Unique(){
		for(int i=1;i<=m;++i){
			LL now=0;
			for(int j=1;j<=len[i];++j)now=(now+(Str[i][j]-'a'+1)*Bas[j])%mod;
			for(int j=1;j<=m;++j){
				if(i==j)continue;
				if(Del[j])continue;
				if(len[i]>len[j])continue;
				LL tmp=0;
				for(int k=1;k<=len[i];++k)tmp=(tmp+(Str[j][k]-'a'+1)*Bas[k])%mod;
				if(now==tmp){
					Del[i]=1;
					break;
				}
				for(int k=len[i]+1;k<=len[j];++k){
					tmp=tmp-(Str[j][k-len[i]]-'a'+1)*Base;
					tmp=(tmp%mod+mod)%mod;
					tmp=tmp*InvBase%mod;
					tmp=(tmp+(Str[j][k]-'a'+1)*Bas[len[i]]%mod)%mod;
					if(now==tmp){
						Del[i]=1;
						break;
					}
				}
				if(Del[i])break;
			}
		}
	}
	int F[12000][16];
	void Solve(){
		memset(Del,0,sizeof(Del));
		Unique();
		int tot=0;
		int A[5]={0,0,0,0,0};
		int Ls[5]={0,0,0,0,0};
		for(int i=1;i<=m;++i){
			if(!Del[i])A[++tot]=i;	
		}
		int Mx=(1<<tot)-1;
		for(int i=0;i<=Mx;++i){
			T1[i].Build(1,0,n);
			T2[i].Build(1,0,n);
		}
		T1[0].Update(1,0,0);
		memset(F,0x3f,sizeof(F));
		for(int i=1;i<=n;++i){
			for(int j=1;j<=tot;++j){
				if(i<len[A[j]])continue;
				while(Ls[j]<pos[A[j]][0]&&pos[A[j]][Ls[j]+1]<=i)++Ls[j];
				if(pos[A[j]][Ls[j]]==i&&Ls[j]!=0){
					int Ed=pos[A[j]][Ls[j]];
					int l=len[A[j]];
					int St=Ed-l+1;
					for(int k=0;k<=Mx;++k){
						if((1<<(j-1))&k)continue;
						F[i][k|(1<<(j-1))]=min(F[i][k|(1<<(j-1))],T1[k].Query(1,0,St-1)+l);
						F[i][k|(1<<(j-1))]=min(F[i][k|(1<<(j-1))],T2[k].Query(1,St,Ed)+i);
						T1[k|(1<<(j-1))].Update(1,i,F[i][k|(1<<(j-1))]);
						T2[k|(1<<(j-1))].Update(1,i,F[i][k|(1<<(j-1))]-i);
					}
				}
			}
		}
		int ans=INF;
		ans=min(ans,T1[Mx].Query(1,0,n));
		cout<<ans<<" ";
	}
	#undef INF
}Sol1;
```


---

## 作者：OtterZ (赞：0)

# 题意

给定一个长度不超过 $10000$ 的字符串，以及它的长不超过 $10000$ 的 $n(n \le 4)$ 个子串，我们任选这些子串分别的匹配区间，问所选的区间的并的长度的最大值和最小值。

# 第一步

通过 KMP 或 AC 自动机可以找到匹配子串的所有区间。

# 求并

这里使用容斥算法转化为求交是 $\operatorname{O}(n2^n)$ 的，速度可以接受。

# 枚举顺序

我们可以发现四个子串匹配区间结尾的先后顺序有 $n!$ 种可能情况，由于 $n \le 4$，故 $n! \le 24$ 可接受。

另外，后续的诸多结论有时需要在顺序被枚举时才能使用，故而考虑枚举顺序。

# 对于最大值

我们考虑将最左边的字符串放在最左边，最右边的字符串放在最右边，对于中间两个字符串，第二个字符串只需考虑两种可能，即与第一个字符串交时尽量放右边，无交时尽量放左边，第三个字符串与第四个字符串无交时尽量放右边，有交时尽量放左边，分别暴力找出相应的四个区间就可以得出正确答案。

# 对于最小值

我们第一反应是枚举最右界并让所有字符串尽量放右边。

当然，有时候我们发现，去相对较左边的区间来构造更多交效果更好。

不过这时我们可以固定顺序，这样在固定顺序的情况下交更多的情况可以成为所有区间相对取最右边的情况，分别暴力找出相应的区间这样问题就解决了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,ch[10009][26],cnt,b[10009],fail[10009],l[4];
char c[10009],x[10009]; 
vector<int>p[4];
int f(int x1,int x2,int x3,int x4){
//printf("%d %d %d %d\n",x1,x2,x3,x4); 
//	printf(" %d %d %d %d\n",p[0][x1],p[1][x2],p[2][x3],p[3][x4]); 
	int ans = 0;
	for(int i = 1; i < 16; i ++){
		int t = -1,fl = 0,fr = 10000;
		if(i & 1){
			t *= -1;
			fl = max(fl,p[0][x1]);
			fr = min(fr,p[0][x1] + l[0] - 1);
		}
		if(i & 2){
			t *= -1;
			fl = max(fl,p[1][x2]);
			fr = min(fr,p[1][x2] + l[1] - 1);
		}
		if(i & 4){
			t *= -1;
			fl = max(fl,p[2][x3]);
			fr = min(fr,p[2][x3] + l[2] - 1);
		}
		if(i & 8){
			t *= -1;
			fl = max(fl,p[3][x4]);
			fr = min(fr,p[3][x4] + l[3] - 1);
		}
		if(fl <= fr)
			ans += t * (fr - fl + 1);
	}
//	printf("%d\n",ans);
	return ans;
}
void add(int u,int v,int id){
	if(x[u] == '\0'){
		b[v] |= (1 << id);
		return;
	}
	if(ch[v][x[u] - 'a'] == 0)
		ch[v][x[u] - 'a'] = ++cnt;
	add(u + 1,ch[v][x[u] - 'a'],id);
}
queue<int>q;
void build(){
	fail[1] = 1;
	for(int i = 0; i < 26; i ++){
		if(ch[1][i] == 0)
			ch[1][i] = -1;
		else
			fail[ch[1][i]] = 1,q.push(ch[1][i]);
	}
	while(!q.empty()){
		int d = q.front();
		q.pop();
		b[d] |= b[fail[d]];
		for(int i = 0; i < 26; i ++){
			if(ch[d][i] == 0)
				ch[d][i] = -abs(ch[fail[d]][i]);
			else
				fail[ch[d][i]] = abs(ch[fail[d]][i]),q.push(ch[d][i]);
		}
	}
}
int main(){
	scanf("%d",&t);
	cnt = 1;
	while(t--){
		scanf(" %s",c);
		scanf("%d",&n);
		for(int i = 0; i < n; i ++){
			scanf(" %s",x);
			l[i] = strlen(x);
			add(0,1,i);
		}
		for(int i = n; i < 4; i ++)
			l[i] = -1,p[i].emplace_back(-1);
		build();
		int nw = 1,ss = 0;
		int ans = 0x3f3f3f3f;
		for(int js = 0; c[js] != '\0'; js ++){
			nw = abs(ch[nw][c[js] - 'a']);
			for(int i = 0; i < n; i ++){
				if((b[nw] >> i) & 1){
					p[i].emplace_back(js - l[i] + 1);
				}
			}
			ss |= b[nw];
			if(ss == (1 << n) - 1){
			for(int i = 0; i < 4; i ++){
			for(int j = 0; j < 4; j ++){
				if(i != j){
					for(int k = 0; k < 4; k ++){
						if(j != k && i != k){
							for(int fl = 0; fl < 4; fl ++){
								if(i != fl && j != fl && k != fl){
									int o1 = 0,o2 = 0;
									int o3 = 0,o4 = 0;
									o1 = p[i].size() - 1;
									o2 = p[j].size() - 1;
									o3 = p[k].size() - 1;
									o4 = p[fl].size() - 1;
									if(o2 > 0 && p[j][o2] > p[i][o1])
										o2 --;
									if(o3 > 0 && p[k][o3] > p[j][o2])
										o3 --;
									if(o4 > 0 && p[fl][o4] > p[k][o3])
										o4 --;
									int p1,p2,p3,p4;
									if(i == 0)
										p1 = o1;
									else if(j == 0)
										p1 = o2;
									else if(k == 0)
										p1 = o3;
									else
										p1 = o4;
									if(i == 1)
										p2 = o1;
									else if(j == 1)
										p2 = o2;
									else if(k == 1)
										p2 = o3;
									else
										p2 = o4;
									if(i == 2)
										p3 = o1;
									else if(j == 2)
										p3 = o2;
									else if(k == 2)
										p3 = o3;
									else
										p3 = o4;
									if(i == 3)
										p4 = o1;
									else if(j == 3)
										p4 = o2;
									else if(k == 3)
										p4 = o3;
									else
										p4 = o4;
									ans = min(ans,f(p1,p2,p3,p4));
									
								}
							}
						}
					}
				}
			}
		}
		}
		}
		
		//printf("  %d %d %d %d\n",p[0].size(),p[1].size(),p[2].size(),p[3].size());
		printf("%d ",ans);
		for(int i = 0; i < 4; i ++){
			for(int j = 0; j < 4; j ++){
				if(i != j){
					for(int k = 0; k < 4; k ++){
						if(j != k && i != k){
							for(int fl = 0; fl < 4; fl ++){
								if(i != fl && j != fl && k != fl){
									int o1 = 0,o2 = p[fl].size() - 1;
									int o3 = 0,o4 = p[k].size() - 1;
									while(o3 < p[j].size() - 1 && p[j][o3 + 1] <= p[i][o1] + l[i] - 1)
										o3 ++;
									while(o4 > 0 && p[k][o4 - 1] + l[k] - 1 >= p[fl][o2])
										o4 --;
									int p1,p2,p3,p4;
									if(i == 0)
										p1 = 0;
									else if(j == 0)
										p1 = o3;
									else if(k == 0)
										p1 = o4;
									else
										p1 = o2;
									if(i == 1)
										p2 = 0;
									else if(j == 1)
										p2 = o3;
									else if(k == 1)
										p2 = o4;
									else
										p2 = o2;
									if(i == 2)
										p3 = 0;
									else if(j == 2)
										p3 = o3;
									else if(k == 2)
										p3 = o4;
									else
										p3 = o2;
									if(i == 3)
										p4 = 0;
									else if(j == 3)
										p4 = o3;
									else if(k == 3)
										p4 = o4;
									else
										p4 = o2;
									ans = max(ans,f(p1,p2,p3,p4));
									if(o3 < p[j].size() - 1){
										if(i == 0)
										p1 = 0;
									else if(j == 0)
										p1 = o3 + 1;
									else if(k == 0)
										p1 = o4;
									else
										p1 = o2;
									if(i == 1)
										p2 = 0;
									else if(j == 1)
										p2 = o3 + 1;
									else if(k == 1)
										p2 = o4;
									else
										p2 = o2;
									if(i == 2)
										p3 = 0;
									else if(j == 2)
										p3 = o3 + 1;
									else if(k == 2)
										p3 = o4;
									else
										p3 = o2;
									if(i == 3)
										p4 = 0;
									else if(j == 3)
										p4 = o3 + 1;
									else if(k == 3)
										p4 = o4;
									else
										p4 = o2;
									ans = max(ans,f(p1,p2,p3,p4));
									}
									if(o4 > 0){
										if(i == 0)
										p1 = 0;
									else if(j == 0)
										p1 = o3;
									else if(k == 0)
										p1 = o4 - 1;
									else
										p1 = o2;
									if(i == 1)
										p2 = 0;
									else if(j == 1)
										p2 = o3;
									else if(k == 1)
										p2 = o4 - 1;
									else
										p2 = o2;
									if(i == 2)
										p3 = 0;
									else if(j == 2)
										p3 = o3;
									else if(k == 2)
										p3 = o4 - 1;
									else
										p3 = o2;
									if(i == 3)
										p4 = 0;
									else if(j == 3)
										p4 = o3;
									else if(k == 3)
										p4 = o4 - 1;
									else
										p4 = o2;
									ans = max(ans,f(p1,p2,p3,p4));
									}
									if(o3 < p[j].size() - 1 && o4 > 0){
										if(i == 0)
										p1 = 0;
									else if(j == 0)
										p1 = o3 + 1;
									else if(k == 0)
										p1 = o4 - 1;
									else
										p1 = o2;
									if(i == 1)
										p2 = 0;
									else if(j == 1)
										p2 = o3 + 1;
									else if(k == 1)
										p2 = o4 - 1;
									else
										p2 = o2;
									if(i == 2)
										p3 = 0;
									else if(j == 2)
										p3 = o3 + 1;
									else if(k == 2)
										p3 = o4 - 1;
									else
										p3 = o2;
									if(i == 3)
										p4 = 0;
									else if(j == 3)
										p4 = o3 + 1;
									else if(k == 3)
										p4 = o4 - 1;
									else
										p4 = o2;
									ans = max(ans,f(p1,p2,p3,p4));
									}
								}
							}
						}
					}
				}
			}
		}
		printf("%d\n",ans);
		for(int i= 0; i < 4; i ++)
			p[i].clear(),l[i] = 0;
		for(int i = 1; i <= cnt; i ++){
			for(int j = 0; j < 26; j ++)
				ch[i][j] = 0;
			fail[i] = 0;
			b[i] = 0;
		} 
		cnt = 1;
	}
}
```

# 后续

“OtterZ，拿错解骗人是吧。”

“没骗人啊，这不是过了吗？”

“那是数据太水，你求最小值的方法可能是平方的先不说了，贪心是错的。”

“那你来 hack 我呀！”

输入：

```
2
hellohhhllhhhlohhsot
4
ll
lo
sot
hh
hello
3
he
l
o
```

输出：

```
9 9
4 4
```

答案：

```
8 9
4 4
```

# 重写：求最小值的贪心

我们通过固定的子串顺序从左往右考虑加入新区间的情况，加入新区间时，已加入的区间有两种情况可能最优：

1. 上一个区间和这个区间相离，加入前并长最小。
2. 上一个区间与这个区间相交，上一个区间加入是情况最优，且上一个区间是这次加入区间左边的能放的最右边的区间。

接下来通过双指针和递推优化，得到 $\operatorname{O}(n2^nn!|A|)$ 的算法。

# 最终代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,ch[10009][26],cnt,b[10009],fail[10009],l[4];
char c[10009],x[10009]; 
vector<int>p[4];
struct cons{
	int pl[4],val;
	cons(){
		val = 0x3f3f3f3f;
		for(int i = 0; i < 4; i ++)
			pl[i] = 0; 
	}
	bool operator<(const cons &b)const{
		return val < b.val;
	}
	cons* operator=(const cons &b){
		if(this != nullptr){
			val = b.val;
			for(int i = 0; i < 4; i ++)
				pl[i] = b.pl[i];
		}
		return this;
	}
};
vector<cons>dp[4];
int ppf(int k1,int x1,int k2,int x2){
//printf("%d %d %d %d\n",x1,x2,x3,x4); 
//	printf(" %d %d %d %d\n",p[0][x1],p[1][x2],p[2][x3],p[3][x4]); 
	int ans = 0;
	for(int i = 1; i < 4; i ++){
		int t = -1,fl = 0,fr = 10000;
		if(i & 1){
			t *= -1;
			fl = max(fl,p[k1][x1]);
			fr = min(fr,p[k1][x1] + l[k1] - 1);
		}
		if(i & 2){
			t *= -1;
			fl = max(fl,p[k2][x2]);
			fr = min(fr,p[k2][x2] + l[k2] - 1);
		}
		if(fl <= fr && fl >= 0)
			ans += t * (fr - fl + 1);
	}
//	printf("%d\n",ans);
	return ans;
}
int pf(int k1,int x1,int k2,int x2,int k3,int x3){
//printf("%d %d %d %d\n",x1,x2,x3,x4); 
//	printf(" %d %d %d %d\n",p[0][x1],p[1][x2],p[2][x3],p[3][x4]); 
	int ans = 0;
	for(int i = 1; i < 8; i ++){
		int t = -1,fl = 0,fr = 10000;
		if(i & 1){
			t *= -1;
			fl = max(fl,p[k1][x1]);
			fr = min(fr,p[k1][x1] + l[k1] - 1);
		}
		if(i & 2){
			t *= -1;
			fl = max(fl,p[k2][x2]);
			fr = min(fr,p[k2][x2] + l[k2] - 1);
		}
		if(i & 4){
			t *= -1;
			fl = max(fl,p[k3][x3]);
			fr = min(fr,p[k3][x3] + l[k3] - 1);
		}
		if(fl <= fr && fl >= 0)
			ans += t * (fr - fl + 1);
	}
//	printf("%d\n",ans);
	return ans;
} 
int f(int x1,int x2,int x3,int x4){
//printf("%d %d %d %d\n",x1,x2,x3,x4); 
	//printf(" %d %d %d %d\n",p[0][x1],p[1][x2],p[2][x3],p[3][x4]); 
	int ans = 0;
	for(int i = 1; i < 16; i ++){
		int t = -1,fl = 0,fr = 10000;
		if(i & 1){
			t *= -1;
			fl = max(fl,p[0][x1]);
			fr = min(fr,p[0][x1] + l[0] - 1);
		}
		if(i & 2){
			t *= -1;
			fl = max(fl,p[1][x2]);
			fr = min(fr,p[1][x2] + l[1] - 1);
		}
		if(i & 4){
			t *= -1;
			fl = max(fl,p[2][x3]);
			fr = min(fr,p[2][x3] + l[2] - 1);
		}
		if(i & 8){
			t *= -1;
			fl = max(fl,p[3][x4]);
			fr = min(fr,p[3][x4] + l[3] - 1);
		}
		if(fl <= fr && fl >= 0)
			ans += t * (fr - fl + 1);
	}
	//printf("%d\n",ans);
	return ans;
}
void add(int u,int v,int id){
	if(x[u] == '\0'){
		b[v] |= (1 << id);
		return;
	}
	if(ch[v][x[u] - 'a'] == 0)
		ch[v][x[u] - 'a'] = ++cnt;
	add(u + 1,ch[v][x[u] - 'a'],id);
}
queue<int>q;
void build(){
	fail[1] = 1;
	for(int i = 0; i < 26; i ++){
		if(ch[1][i] == 0)
			ch[1][i] = -1;
		else
			fail[ch[1][i]] = 1,q.push(ch[1][i]);
	}
	while(!q.empty()){
		int d = q.front();
		q.pop();
		b[d] |= b[fail[d]];
		for(int i = 0; i < 26; i ++){
			if(ch[d][i] == 0)
				ch[d][i] = -abs(ch[fail[d]][i]);
			else
				fail[ch[d][i]] = abs(ch[fail[d]][i]),q.push(ch[d][i]);
		}
	}
}
int main(){
	scanf("%d",&t);
	cnt = 1;
	while(t--){
		scanf(" %s",c);
		scanf("%d",&n);
		for(int i = n; i < 4; i ++)
			l[i] = -1,p[i].emplace_back(-998244353),dp[i].emplace_back(cons());
		for(int i = 0; i < n; i ++){
			scanf(" %s",x);
			l[i] = strlen(x);
			add(0,1,i);
		}
		build();
		int nw = 1,ss = 0;
		int ans = 0x3f3f3f3f;
		for(int js = 0; c[js] != '\0'; js ++){
			nw = abs(ch[nw][c[js] - 'a']);
			for(int i = 0; i < n; i ++){
				if((b[nw] >> i) & 1){
					p[i].emplace_back(js - l[i] + 1);
					dp[i].emplace_back(cons());
					dp[i][dp[i].size() - 1].pl[i] = dp[i].size() - 1; 
				}
			}
		}
		for(int i = 0; i < 4; i ++){
			for(int lp = 0; lp < p[i].size(); lp ++){
				dp[i][lp] = cons();
				dp[i][lp].pl[i] = lp;
				dp[i][lp].val = l[i];
			}
			for(int j = 0; j < 4; j ++){
				if(i != j){
					int fp1 = 0,fp2 = 0,sp = 0;
					cons mdp = cons();
					for(int lp = 0; lp < p[j].size(); lp ++){
						while(fp1 < p[i].size() && p[i][fp1] + l[i] <= p[j][lp])
							mdp = min(mdp,dp[i][fp1]),fp1 ++;
						while(fp2 < p[i].size() - 1 && p[i][fp2 + 1] + l[i] <= p[j][lp] + l[j])
							fp2 ++;
					//	printf("%d %d %d\n",lp,fp1,fp2);
						cons dp1 = mdp,dp2 = dp[i][fp2];
						dp1.pl[j] = dp2.pl[j] = lp;
						dp1.val = ppf(i,dp1.pl[i],j,dp1.pl[j]);
						dp2.val = ppf(i,dp2.pl[i],j,dp2.pl[j]);
						dp[j][lp] = min(dp1,dp2);
					}
					for(int k = 0; k < 4; k ++){
					//	printf("%d\n",k);
						if(j != k && i != k){
							fp1 = 0,fp2 = 0,sp = 0;
							cons mdp = cons();
							for(int lp = 0; lp < p[k].size(); lp ++){
								while(fp1 < p[j].size() && p[j][fp1] + l[j] <= p[k][lp])
									mdp = min(mdp,dp[j][fp1]),fp1 ++;
								while(fp2 < p[j].size() - 1 && p[j][fp2 + 1] + l[j] <= p[k][lp] + l[k])
									fp2 ++;
								//printf(" %d %d %d\n",lp,fp1,fp2);
								cons dp1 = mdp,dp2 = dp[j][fp2];
								dp1.pl[k] = dp2.pl[k] = lp;
								dp1.val = pf(i,dp1.pl[i],j,dp1.pl[j],k,dp1.pl[k]);
								dp2.val = pf(i,dp2.pl[i],j,dp2.pl[j],k,dp2.pl[k]);
								dp[k][lp] = min(dp1,dp2);
							}
							for(int fl = 0; fl < 4; fl ++){
								if(i != fl && j != fl && k != fl){
								//	printf("%d %d %d %d\n",i,j,k,fl);
									fp1 = 0,fp2 = 0,sp = 0;
									cons mdp = cons();
									for(int lp = 0; lp < p[fl].size(); lp ++){
										while(fp1 < p[k].size() && p[k][fp1] + l[k] <= p[fl][lp])
											mdp = min(mdp,dp[k][fp1]),fp1 ++;
										while(fp2 < p[k].size() - 1 && p[k][fp2 + 1] + l[k] <= p[fl][lp] + l[fl])
											fp2 ++;
										cons dp1 = mdp,dp2 = dp[k][fp2];
										dp1.pl[fl] = dp2.pl[fl] = lp;
									//	printf("OOO %d %d %d %d %d %d %d\n",lp,fp1,fp2,dp1.pl[0],dp1.pl[1],dp1.pl[2],dp1.pl[3]);
										dp1.val = f(dp1.pl[0],dp1.pl[1],dp1.pl[2],dp1.pl[3]);
										dp2.val = f(dp2.pl[0],dp2.pl[1],dp2.pl[2],dp2.pl[3]);
										dp[fl][lp] = min(dp1,dp2);
									//	printf(" %d %d %d %d\n",lp,fp1,fp2,dp[fl][lp].val);
										ans = min(ans,dp[fl][lp].val);
									}
								} 
							}
						}
					}
				}
			}
		}
		printf("%d ",ans);
		for(int i = 0; i < 4; i ++){
			for(int j = 0; j < 4; j ++){
				if(i != j){
					for(int k = 0; k < 4; k ++){
						if(j != k && i != k){
							for(int fl = 0; fl < 4; fl ++){
								if(i != fl && j != fl && k != fl){
									int o1 = 0,o2 = p[fl].size() - 1;
									int o3 = 0,o4 = p[k].size() - 1;
									while(o3 < p[j].size() - 1 && p[j][o3 + 1] <= p[i][o1] + l[i] - 1)
										o3 ++;
									while(o4 > 0 && p[k][o4 - 1] + l[k] - 1 >= p[fl][o2])
										o4 --;
									int p1,p2,p3,p4;
									if(i == 0)
										p1 = 0;
									else if(j == 0)
										p1 = o3;
									else if(k == 0)
										p1 = o4;
									else
										p1 = o2;
									if(i == 1)
										p2 = 0;
									else if(j == 1)
										p2 = o3;
									else if(k == 1)
										p2 = o4;
									else
										p2 = o2;
									if(i == 2)
										p3 = 0;
									else if(j == 2)
										p3 = o3;
									else if(k == 2)
										p3 = o4;
									else
										p3 = o2;
									if(i == 3)
										p4 = 0;
									else if(j == 3)
										p4 = o3;
									else if(k == 3)
										p4 = o4;
									else
										p4 = o2;
									ans = max(ans,f(p1,p2,p3,p4));
									if(o3 < p[j].size() - 1){
										if(i == 0)
										p1 = 0;
									else if(j == 0)
										p1 = o3 + 1;
									else if(k == 0)
										p1 = o4;
									else
										p1 = o2;
									if(i == 1)
										p2 = 0;
									else if(j == 1)
										p2 = o3 + 1;
									else if(k == 1)
										p2 = o4;
									else
										p2 = o2;
									if(i == 2)
										p3 = 0;
									else if(j == 2)
										p3 = o3 + 1;
									else if(k == 2)
										p3 = o4;
									else
										p3 = o2;
									if(i == 3)
										p4 = 0;
									else if(j == 3)
										p4 = o3 + 1;
									else if(k == 3)
										p4 = o4;
									else
										p4 = o2;
									ans = max(ans,f(p1,p2,p3,p4));
									}
									if(o4 > 0){
										if(i == 0)
										p1 = 0;
									else if(j == 0)
										p1 = o3;
									else if(k == 0)
										p1 = o4 - 1;
									else
										p1 = o2;
									if(i == 1)
										p2 = 0;
									else if(j == 1)
										p2 = o3;
									else if(k == 1)
										p2 = o4 - 1;
									else
										p2 = o2;
									if(i == 2)
										p3 = 0;
									else if(j == 2)
										p3 = o3;
									else if(k == 2)
										p3 = o4 - 1;
									else
										p3 = o2;
									if(i == 3)
										p4 = 0;
									else if(j == 3)
										p4 = o3;
									else if(k == 3)
										p4 = o4 - 1;
									else
										p4 = o2;
									ans = max(ans,f(p1,p2,p3,p4));
									}
									if(o3 < p[j].size() - 1 && o4 > 0){
										if(i == 0)
										p1 = 0;
									else if(j == 0)
										p1 = o3 + 1;
									else if(k == 0)
										p1 = o4 - 1;
									else
										p1 = o2;
									if(i == 1)
										p2 = 0;
									else if(j == 1)
										p2 = o3 + 1;
									else if(k == 1)
										p2 = o4 - 1;
									else
										p2 = o2;
									if(i == 2)
										p3 = 0;
									else if(j == 2)
										p3 = o3 + 1;
									else if(k == 2)
										p3 = o4 - 1;
									else
										p3 = o2;
									if(i == 3)
										p4 = 0;
									else if(j == 3)
										p4 = o3 + 1;
									else if(k == 3)
										p4 = o4 - 1;
									else
										p4 = o2;
									ans = max(ans,f(p1,p2,p3,p4));
									}
								}
							}
						}
					}
				}
			}
		}
		printf("%d\n",ans);
		for(int i= 0; i < 4; i ++)
			p[i].clear(),l[i] = 0;
		for(int i = 1; i <= cnt; i ++){
			for(int j = 0; j < 26; j ++)
				ch[i][j] = 0;
			fail[i] = 0;
			b[i] = 0;
		} 
		cnt = 1;
	}
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/8u24xbs0.png)

~~改完之后变慢了，不会是数据太水引起的吧~~

---


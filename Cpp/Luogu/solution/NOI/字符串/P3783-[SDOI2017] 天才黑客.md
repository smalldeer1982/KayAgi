# [SDOI2017] 天才黑客

## 题目背景

$\text{SD0062}$ 号选手小 Q 同学为了偷到 SDOI7012 的试题，利用高超的黑客技术潜入了 SDOI 出题组的内联网的中央控制系统，然而这个内联网除了配备有中央控制系统，还为内联网中的每条单向网线设定了特殊的通信口令，这里通信口令是一个字符串，不同网线的口令可能不同。这让小 Q 同学感觉有些棘手，不过这根本难不倒他，很快他就分析出了整个内联网的结构。


## 题目描述

内联网中有 $n$ 个节点（从 $1$ 到 $n$ 标号）和 $m$ 条**单向**网线，中央控制系统在第 $1$ 个节点上，每条网线单向连接内联网中的某两个节点，从 $1$ 号节点出发经过若干条网线总能到达其他任意一个节点。每个节点都可以运行任意的应用程序，应用程序会携带一条通信口令，当且仅当程序的口令与网线的口令相同时，程序才能通过这条网线到达另一端的节点继续运行，并且通过每条网线都需要花费一定的时间。

每个应用程序可以在任意一个节点修改通信口令，修改通信口令花费的时间可以忽略不计，但是为了减小修改量，需要先调用一个子程序来计算当前程序的口令和网线的口令的最长公共前缀（记其长度为 $\mathrm{len}$），由于获取网线的口令的某个字符会比较耗时，调用一次这个子程序需要花费 $\mathrm{len}$ 个单位时间。

除此之外，小 Q 同学还在中央控制系统中发现了一个字典，每条网线的口令都是字典中的某个字符串。具体来说，这个字典是一棵 $k$ 个节点（从 $1$ 到 $k$ 标号）的有根树，其中根是第 $1$ 个节点，每条**边**上有一个字符，字符串 $S$ 在字典中当且仅当存在某个点 $u$ 使得从根节点出发往下走到 $u$ 的这条路径上的字符顺次拼接构成 $S$。

现在小 Q 同学在 $1$ 号节点同时开启了 $(n-1)$ 个应用程序，这些应用程序同时运行且互不干扰，每个程序的通信口令都为空，他希望用最短的时间把这些程序分别发送到其他节点上，你需要帮小 Q 同学分别计算出发送到第 $i$（$i=2,3,\dots ,n$）个节点的程序完成任务的最短时间。


## 说明/提示

样例解释：下图展示了样例中内联网的结构。字符串用红色字体标出。

![](https://cdn.luogu.com.cn/upload/image_hosting/btzomagx.png)

记 $\mathrm{LCP}(S,T)$ 为字符串 $S,T$ 的**最长公共前缀**的长度。例如，$\mathrm{LCP}(\texttt{\textcolor{red}{starry}killer},\texttt{\textcolor{red}{starry}dust})=6$。记 $\epsilon$ 为空字符串。

从 $1$ 到 $3$ 的一条可行路径是 $1 \rightarrow 2 \rightarrow 3$，所需时间是$(2 + \mathrm{LCP}(\epsilon , \texttt{1112})) + (2 +\mathrm{LCP}(\texttt{1112} ,\texttt{1112})) = 8$。

但这条路径不是最优的，最优路径是 $1 \rightarrow 2 \rightarrow 4 \rightarrow 2 \rightarrow 3$。


 

| 测试点编号 | $n\le $ | $m\le $|  $k\le$ | 备注 |
| :--: | :--: | :--: | :--: | :--: |
| $1\sim 5$ | $5\,000$ | $5\,000$ | $20\,000$ | - |
| $6\sim 14$ | $50\,000$ | $50\,000$ | $20\,000$ | $nk\le 200\,000$ |
| $15\sim 20$ | $50\,000$ | $50\,000$ | $20\,000$ | - |

对于 $100\%$ 的数据，保证：

- $T \leq 10$；
- $2 \leq n \leq 50000$，$1 \leq m \leq 50000$，$1 \leq k \leq 20000$；
- $n>5000$ 或 $m > 5000$ 的数据不超过 $2$ 组；
- $1 \leq a_i,b_i \leq n$，$0 \leq c_i \leq 20000$，$1 \leq d_i \leq k$；
- $1 \leq u_i,v_i \leq k$，$1 \leq w_i \leq 20000$。

## 样例 #1

### 输入

```
1
4 4 6
1 2 2 5
2 3 2 5
2 4 1 6
4 2 1 6
1 2 1
2 3 1
3 4 1
4 5 2
1 6 2```

### 输出

```
2
7
3```

# 题解

## 作者：shadowice1984 (赞：25)

其实愚蠢的$O(mlog^2m)$做法应该被叉掉的……
__________________

# 关于spfa

~~它死了~~

原因是这道题你最后建出来的图就是spfa最怂的网格图，出题人甚至只需要random数据,你就自动完成了卡spfa的任务……

~~dijkstra保平安~~

_____________

## 本题题解

首先简化一下并不明确的题意

给出一张有向图，每个边上有边权，以及一个字符串

一条有向路径的长度为这条路径上每个边的边权之和+按照路径的顺序将这些边上的字符串排成一列，相邻两个串的lcp长度之和。

求这种长度定义下的1号点到其他点的最短路

保证边上的所有字符串都可以被一个字典树所识别，字典树的大小不会很大

那么我们仔细看一下应该还是最短路问题，所以最后肯定还是跑一遍dijkstra解决问题，现在我们的精力应该放在如何建图上

仔细看一眼你会发现这道题点在最短路当中并没有太多用处，路径长度的计算公式是和边有关的，因此我们考虑下面一个比较显然~~(?或许并不)~~的暴力建图方式

 _将一个边拆成两个点，一个是入点另一个是出点，中间链接一条为这条边权值的有向边，对于两个边<a,b>,<c,d>来讲，如果b=c，那么第一个边的出点向第二个边的入点连一条权值等于两个边上字符串lcp的长度的有向边。_ 

 _新建一个超级源点s，对于所有形如<1,a>的边，s向这些边的入点连一条边权为0的有向边_ 

 _最后输出最短路长度的时候，对于每一个点i，枚举形如<a,i>的边，在这些边的出点的dis值中找最小值，作为这个点的最短路输出_ 

好了翻译一下上边的鬼话就是我们把边看做点重新建一张图出来，边自己的权值拆成两个点保存在这两个点之间的边权中，然后边和边之间连边的边权就是边上字符串的lcp长度

遗憾的是上边的建图方式碰到下面这张图会直接爆炸……

![](https://cdn.luogu.com.cn/upload/pic/26794.png)


恭喜你连了$O(m^2)$条边，然后你炸了

接下来就是奇技淫巧的优化建图时间了

如果你想了刚才那个暴力你会发现我们连了一堆边权一样的边……

因为两个字符串的lcp长度就是这两个字符串在字典树上的lca深度，因此我们可以会发现所有可能的边权种类只有$O(m+k)$种，因此按照刚才的暴力我们一定会连出很多边权一样的边

此时我们观察了一会这个图发现一个有趣的事实

我们把每个点周围一圈的边拉出来，按照边上字符串在字典树上的dfs序排一个序，此时我们看一看会有什么有趣的现象发生呢？

由于我们现在有了一堆按照字典序排好序的字符串，因此我们觉得这非常像后缀数组，所以我们尝试着求出相邻两个字符串的lcp长度，或者说字典树上的lca深度，或者说求出这些排好序字符串的height数组

那么我们会并不惊奇的发现一个事实，两个字符串的lcp长度就是height数组的区间最小值，区间端点为这两个字符串的位置，就像后缀数组一样的性质

如果你对后缀数组那一套足够熟练的话你会非常熟练的使用单调栈求出每一个$h_{i}$所"管辖"(也就是它是区间最小值)的范围，然后更加熟练的使用线段树优化建图完成区间链接一条权值一样的边的操作，然后以$O(mlog^2m)$的复杂度做完这道题

但是啊，让我们接着想想，线段树优化建图还有优化空间吗？

当然有，答案是


### 前缀和/后缀和优化建图

我们依然是把每个点周围一圈的边全部拉出去按照dfs序排序，依然处理出height数组,但是，我们不再使用单调栈，而是考虑这样一种奇技淫巧

对于某一个$h_{i}$来讲，在i左侧的入点可以通过不超过$h_{i}$代价到达i右侧出点，同理i右侧的入点可以通过不超过$h_{i}$的代价到达i右侧的出点

所以我们可以让i左侧点向i右侧点连一堆边，i右侧点向i左侧点连一堆边，当然，边权都是$h_{i}$

此时并没有任何优化，但是假设我们只需要让i左侧点向右侧点连边，则我们可以使用这样一种奇技淫巧，我们像这样连边即可，其中上边的点是入点，底下的点是出点

![](https://cdn.luogu.com.cn/upload/pic/26802.png)

很显然我们使用了很少的边就完成了连边工作

但是用这个技巧我们并无法同时支持从左向右连和从左向右连

仔细想想真的不行吗……？

#### 其实是可以的

我们将一条边拆成2个入点和两个出点，然后连成这样的形状

![](https://cdn.luogu.com.cn/upload/pic/26806.png)

然后第一对出入点处理从左向右连的情况，第二对出入点处理从右向左的情况
即可

此时我们就可以建立一个超级源点连向1号点的所有出边跑一边dijkstra，之后对于每一个i，for一遍所有指向i的出边求最短路的最小值，然后我们就可以搞定这道题了

备注：建图会非常恶心……自己慢慢画图建吧……一不小心就写了100行……

```C
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
int dfn[20010];int dep[20010];int n;int m;int k;int T;typedef long long ll;
namespace Tree
{
    const int N=2*1e4+10;
    struct data{int v;int val;friend bool operator <(data a,data b){return a.val<b.val;}};
    int fa[N][18];int df;vector <data> v[N];
    inline void add(int u,int V,int w){v[u].push_back((data){V,w});}
    inline void dfs(int u)//dfs
    {
        for(int i=0;fa[u][i];i++)fa[u][i+1]=fa[fa[u][i]][i];
        dfn[u]=++df;vector <data> :: iterator it;
        for(it=v[u].begin();it!=v[u].end();++it)dep[it->v]=dep[u]+1,fa[it->v][0]=u,dfs(it->v);
    }
    inline void pre(){for(int i=1;i<=k;i++)sort(v[i].begin(),v[i].end());dfs(1);}
    inline int lca(int u,int v)//倍增lca 
    {
        if(dep[u]<dep[v])swap(u,v);
        for(int d=dep[u]-dep[v],i=0;d;d>>=1,i++)if(d&1)u=fa[u][i];if(u==v)return u;
        for(int i=17;i>=0;i--)if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];return fa[u][0];
    }
    inline void clear()
    {
        for(int i=1;i<=k;i++)v[i].clear();
        for(int i=1;i<=k;i++)for(int j=0;j<18;j++)fa[i][j]=0;df=0;
    }
}
namespace Grph
{
    const int N=5*1e4+10;const int V=4*N;const int E=20*N;
	int tp[V];int ctt;vector <int> eif[N];vector <int> eof[N];vector <int> eib[N];vector <int> eob[N];
	vector <int> tr;int v[E];int x[E];int ct;int al[V];int val[E];int s;
	inline bool cmp(int a,int b){return dfn[tp[a]]<dfn[tp[b]];}
	inline void add(int u,int V,int w){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=w;}
	inline void ins(int u,int V,int w,int d)//插入一个边 
	{
		if(u==1)add(s,ctt+1,0),add(s,ctt+3,0);for(int i=1;i<=4;i++)tp[ctt+i]=d;//拆成4条边 
		add(ctt+1,ctt+2,w);add(ctt+1,ctt+4,w);add(ctt+3,ctt+4,w);add(ctt+3,ctt+2,w);
		eof[u].push_back(++ctt);eif[V].push_back(++ctt);eob[u].push_back(++ctt);eib[V].push_back(++ctt);
	}
	inline void build()
	{
		for(int u=1;u<=n;u++)
		{
			sort(eof[u].begin(),eof[u].end(),cmp);sort(eif[u].begin(),eif[u].end(),cmp);
			sort(eob[u].begin(),eob[u].end(),cmp);sort(eib[u].begin(),eib[u].end(),cmp);
			for(int i=0;i<(int)eof[u].size()-1;i++)add(eof[u][i],eof[u][i+1],0);//将长链连出来 
			for(int i=0;i<(int)eif[u].size()-1;i++)add(eif[u][i],eif[u][i+1],0);
			for(int i=0;i<(int)eob[u].size()-1;i++)add(eob[u][i+1],eob[u][i],0);
			for(int i=0;i<(int)eib[u].size()-1;i++)add(eib[u][i+1],eib[u][i],0);
			tr.resize(eof[u].size()+eif[u].size());
			merge(eif[u].begin(),eif[u].end(),eof[u].begin(),eof[u].end(),tr.begin(),cmp);
			for(int t=0,i=0,j=0;t<(int)tr.size()-1;t++)//然后两两求lca连边 
			{
				if(tr[t]&1)j++;else i++;int w=dep[Tree::lca(tp[tr[t]],tp[tr[t+1]])];
				if(i!=0&&j!=(int)eof[u].size())add(eif[u][i-1],eof[u][j],w);
				if(i!=(int)eib[u].size()&&j!=0)add(eib[u][i],eob[u][j-1],w);
			}	
		}
	}
	struct data{int u;ll d;friend bool operator <(data a,data b){return a.d>b.d;}};
	ll d[V];bool book[V];priority_queue <data> pq;
	inline void solve()//跑dijkstra 
	{
		for(int i=1;i<=ctt;i++)d[i]=(1LL<<40);d[s]=0;
		for(pq.push((data){s,0});!pq.empty();)
		{
			data nw=pq.top();pq.pop();if(book[nw.u])continue;book[nw.u]=true;
			for(int i=al[nw.u];i;i=x[i])
				if(!book[v[i]]&&d[v[i]]>nw.d+val[i])d[v[i]]=nw.d+val[i],pq.push((data){v[i],d[v[i]]});
		}
		for(int i=2;i<=n;i++)
		{
			ll ret=(1LL<<40);for(int j=0;j<(int)eif[i].size();j++)ret=min(ret,d[eif[i][j]]);
			for(int j=0;j<(int)eib[i].size();j++)ret=min(ret,d[eib[i][j]]);printf("%lld\n",ret);
		}
	}
	inline void clear()
	{
		for(int i=1;i<=n;i++)eif[i].clear();
		for(int i=1;i<=n;i++)eof[i].clear();
		for(int i=1;i<=n;i++)eib[i].clear();
		for(int i=1;i<=n;i++)eob[i].clear();
		for(int i=1;i<=ctt+1;i++)al[i]=0;
		for(int i=1;i<=ctt+1;i++)book[i]=false;ct=0;ctt=0;
	}
}
inline void solve()
{
    scanf("%d%d%d",&n,&m,&k);Grph::s=4*m+1;
    for(int i=1,u,v,w,d;i<=m;i++)scanf("%d%d%d%d",&u,&v,&w,&d),Grph::ins(u,v,w,d);
    for(int i=1,u,v,w;i<k;i++)scanf("%d%d%d",&u,&v,&w),Tree::add(u,v,w);
    Tree::pre();Grph::build();Grph::solve();
}
inline void clear(){Tree::clear();Grph::clear();}
int main(){scanf("%d",&T);for(int z=1;z<=T;z++)solve(),clear();return 0;}//拜拜程序~ 
```









---

## 作者：tzc_wk (赞：11)

[题面传送门](https://www.luogu.com.cn/problem/P3783)

神仙题一道。

首先注意到这里的贡献涉及到边的顺序，并且只与相邻的边是什么有关，因此不难想到一个做法——边转点，点转边，具体来说对于每条边 $e$，我们将其拆成两个点 $in_e,out_e$，并连边 $in_e\to out_e$，权值为 $c_e$，同时对于所有 $b_i=a_j$ 的边 $i,j$，连边 $out_i\to in_j$，权值为 $dep[\text{LCA}(d_i,d_j)]$，以及对于所有 $a_i=1$ 的边连 $S\to in_i$，权值为 $0$ 的边，跑最短路，最后 $ans_i=\min\limits_{b_e=i}dis_{out_e}$。正确性显然。

然而该做法效率低下，边数最高可达到 $\mathcal O(m^2)$，一脸过不去的亚子。于是又到了优化建图的时间了，一个 observation 是对于一个点 $u$ 而言，我们在 $b_i=a_j=u$ 的边 $i,j$ 之间连边，这些边**边权的种类是不会太多的**，因为假设 $S=\{d_i|b_i=u\lor a_i=u\}$，那么这些边权肯定只能**是 $S$ 当中某两个点的 $\text{LCA}$ 的深度**，根据虚树那一套理论，$S$ 当中任意两点的 $\text{LCA}$ 总共只有 $\mathcal O(|S|)$ 种可能。而对于所有点 $u$，它们对应 $|S|$ 的总和为 $\mathcal O(m)$ 级别，这个是在我们能接受的范围内的。因此考虑从这个性质入手优化这道题，我们将 $S$ 当中的点按 `DFS` 序排个序，那么根据虚树中一个定理：对于待建立虚树的 $m$ 个点 $a_1,a_2,\cdots,a_m$，假设将其按照 `DFS` 序排序得到 $b_1,b_2,\cdots,b_m$，那么记 $h_i=dep[\text{LCA}(a_i,a_{i+1})]$，有 $dep[\text{LCA}(b_l,b_r)]=\min\limits_{i=l}^{r-1}h_i$（和 SA 有点像），因此考虑按照套路求出 $h_i$，那么问题可以转化为：

- 有一排 $t$ 个点，每个点有两种类型 $0/1$，每两个点中间写有一个数 $h_i$，我们要从所有 $0$ 点向 $1$ 点连边，权值为它们之间数的最小值。

这个有一个显然的做法——对于某个 $h_x$，满足 $\min\limits_{i=l}^{r-1}h_i=h_x$ 的 $l,r$ 肯定分别在一段区间内，单调栈求出对应的区间，线段树优化建图即可，但是这个做法多一个 $\log$，不知道能不能通过，而且实现起来过于麻烦，因此我们还需考虑更简便做法。考虑最短路的一个性质，就是**对于两点间如果有多条边的情况，那么显然只有权值最小的边是有用的，其他边可连可不连——连了也不影响你最短路的大小**。因此考虑对于某个 $h_i$，我们不维护什么单调栈，直接从 $[1,i]$ 中的 $0$ 点向 $[i+1,t]$ 中的 $1$ 点连边，$[i+1,t]$ 中的 $0$ 权点向 $[1,i]$ 中的 $1$ 点连边，根据上面的结论，对于某个 $l,r$，只有 $[l,r)$ 中 $h$ 的最小值（设为 $h_x$）是有用的，其他边连上也没事，而显然在考虑 $x$ 的贡献时，已经连了  $l,r$ 之间的边，因此最短路跑出来依然是对的。考虑优化，注意到每次都是某个前缀向后缀，或者后缀向前缀连边，因此考虑前后缀优化建图，具体来说建立四排点——前缀 `in`，前缀 `out`，后缀 `in`，后缀 `out`，然后随便瞎连连即可，具体见代码。

时间复杂度 $\mathcal O(Tm\log m)$，然鹅常数非常大，直接上天……

代码（似乎题解区中有人说此题代码难度很大，个人认为还好罢，主要原因可能是有的人把虚树建了出来，增加了代码难度，实际上不用建出来，只用将它们的 DFS 序从小到大排个序即可），个人认为挺清楚的，挺有参考意义的，这大概也是我发这篇题解的原因吧：

```cpp
const int MAXN=5e4;
const int MAXK=2e4;
const int LOG_N=16;
const int MAXV=6e5+1;
const int MAXE=1e7;
int n,m,k,S=6e5+1,ncnt;
int hd[MAXV+5],to[MAXE+5],nxt[MAXE+5],val[MAXE+5],ec=0;
void adde(int u,int v,int w){to[++ec]=v;val[ec]=w;nxt[ec]=hd[u];hd[u]=ec;}
struct edge{int a,b,c,d;} e[MAXN+5];
vector<int> in[MAXN+5],out[MAXN+5],g[MAXK+5];
int dfn[MAXK+5],fa[MAXK+5][LOG_N+2],dep[MAXK+5],tim=0;
void dfs(int x=1,int f=0){
	dfn[x]=++tim;fa[x][0]=f;
	for(int y:g[x]) dep[y]=dep[x]+1,dfs(y,x);
}
int getlca(int x,int y){
	if(dep[x]<dep[y]) x^=y^=x^=y;
	for(int i=LOG_N;~i;i--) if(dep[x]-(1<<i)>=dep[y]) x=fa[x][i];
	if(x==y) return x;
	for(int i=LOG_N;~i;i--) if(fa[x][i]^fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
bool cmp(pii x,pii y){return dfn[x.fi]<dfn[y.fi];}
ll dis[MAXV+5],ans[MAXN+5];
void clear(){
	S=6e5+1;ncnt=0;memset(hd,0,sizeof(hd));ec=0;
	memset(dfn,0,sizeof(dfn));memset(fa,0,sizeof(fa));
	memset(dep,0,sizeof(dep));tim=0;
	memset(dis,63,sizeof(dis));memset(ans,63,sizeof(ans));
	for(int i=1;i<=MAXN;i++) in[i].clear(),out[i].clear();
	for(int i=1;i<=MAXK;i++) g[i].clear();
}
void solve(){
	scanf("%d%d%d",&n,&m,&k);clear();ncnt=m<<1;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&e[i].a,&e[i].b,&e[i].c,&e[i].d);
		out[e[i].a].pb(i);in[e[i].b].pb(i);
	}
	for(int i=1,u,v;i<k;i++) scanf("%d%d%*d",&u,&v),g[u].pb(v);dfs(1,0);
	for(int i=1;i<=LOG_N;i++) for(int j=1;j<=k;j++) fa[j][i]=fa[fa[j][i-1]][i-1];
	for(int i=1;i<=m;i++) adde(i,i+m,e[i].c);
	for(int i=1;i<=m;i++) if(e[i].a==1) adde(S,i,0);
	for(int i=1;i<=n;i++){
		vector<pii> ed;
		for(int x:in[i]) ed.pb(mp(e[x].d,x+m));
		for(int x:out[i]) ed.pb(mp(e[x].d,x));
		sort(ed.begin(),ed.end(),cmp);
		vector<int> h(ed.size(),0);
		vector<int> pre_in(ed.size(),0),pre_out(ed.size(),0);
		vector<int> suf_in(ed.size(),0),suf_out(ed.size(),0);
		for(int j=0;j+1<ed.size();j++) h[j]=dep[getlca(ed[j].fi,ed[j+1].fi)];
		for(int j=0;j<ed.size();j++) pre_in[j]=++ncnt;
		for(int j=0;j<ed.size();j++) pre_out[j]=++ncnt;
		for(int j=0;j<ed.size();j++) suf_in[j]=++ncnt;
		for(int j=0;j<ed.size();j++) suf_out[j]=++ncnt;
		for(int j=0;j+1<ed.size();j++) adde(pre_in[j+1],pre_in[j],0);
		for(int j=0;j+1<ed.size();j++) adde(pre_out[j],pre_out[j+1],0);
		for(int j=0;j+1<ed.size();j++) adde(suf_in[j],suf_in[j+1],0);
		for(int j=0;j+1<ed.size();j++) adde(suf_out[j+1],suf_out[j],0);
		for(int j=0;j<ed.size();j++){
			if(ed[j].se<=m) adde(suf_in[j],ed[j].se,0),adde(pre_in[j],ed[j].se,0);
			else adde(ed[j].se,suf_out[j],0),adde(ed[j].se,pre_out[j],0);
		}
		for(int j=0;j+1<ed.size();j++){
			adde(suf_out[j+1],pre_in[j],h[j]);
			adde(pre_out[j],suf_in[j+1],h[j]);
		}
	} memset(dis,63,sizeof(dis));memset(ans,63,sizeof(ans));
	priority_queue<pii,vector<pii>,greater<pii> > q;
	q.push(mp(dis[S]=0,S));
	while(!q.empty()){
		pii p=q.top();q.pop();
		int sum=p.fi,x=p.se;
		if(dis[x]<sum) continue;
		for(int e=hd[x];e;e=nxt[e]){
			int y=to[e],z=val[e];
			if(dis[y]>dis[x]+z) q.push(mp(dis[y]=dis[x]+z,y));
		}
	}
	for(int i=1;i<=m;i++) chkmin(ans[e[i].b],dis[i+m]);
	for(int i=2;i<=n;i++) printf("%lld\n",ans[i]);
}
int main(){int qu;scanf("%d",&qu);while(qu--) solve();return 0;}
```



---

## 作者：hl666 (赞：9)

### 题目大意

一道码量直逼**猪国杀**的**图论+数据结构**题。~~我猪国杀也就一百来行~~

首先我们要看懂鬼畜的题意，发现其实就是在一个带权有向图上，每条边有一个字符串信息。让你找一个点出发到其它点的最短路径。~~听起来很简单，手速码完**Dijkstra**~~

然而这题中除了路径上的边权和还要加上去的就是一条路径上所有边代表的字符串的**LCP**，还有一点就是所有的字符串都是一棵**字典树**上的路径。

问题有点复杂啊，那我们慢慢分析。

------

### 化边为点

考虑到如果我们在跑最短路的时候记录每个点过来的状态就会不可避免的扩出$O(n^2)$条边，直接GG

仔细一想这道题最难的部分在哪？其实还是求LCP部分，所以显然边的重要性比点大，因此我们**化边为点**

具体的说，我们把原先的每条边拆成一个**入点**一个**出点**，在这两点之间连边表示原来的边权。

那么现在我们只需要在这些边化为的点直接连接边权为两字符串LCP的边即可（从一个出点连至一个入点）

------

### 构建虚树

那么现在我们就要找到原来每个点，将所有与其相连边所需要的节点（**不管是进入还是出去**）之间的边互相连接。

乍一看这样的点数多的爆炸，但是仔细一想，总点数再怎么多也不会超过$2m$啊！

所以我们对这些点构造一颗**虚树**（不会虚树的左转[Luogu P2495 [SDOI2011]消耗战](https://www.luogu.org/problemnew/show/P2495)）

此时虚树上的点就是它子树内的点（包括他本身）之间的**LCA**，所以我们只要在这些点对之间连边，边权为这个点的$dep-1$（减不减$1$根据个人写法不同）

------

### 优化建边

像前面说的那样，直接两两暴力连边边数还是平方级别的。

我们发现这些点都要经过LCA，所以可以考虑以LCA为中转点建**虚点**连边。（不会建虚点的左转[Luogu P1983 车站分级](https://www.luogu.org/problemnew/show/P1983)）

然后每次连边的边数是$O(n)$的，但是有由于有多个点，所以总的边数还是$O(n^2)$。~~优化了半天却好似放屁~~

但是我们发现这个时候我们连的边相当于是从某个**子树**连到某个点，再从这个点连到某个**子树**中

子树的一个经典性质，相信我不说大家都知道：**DFS序**连续。

所以问题变成区间向点，点向区间连边。这个由于我比较菜（不会**前后缀优化建图**），同时这题的数据范围不大，因此我们可以用最经典的**线段树优化建图**（不会的左转[Luogu P3588 [POI2015]PUS](https://www.luogu.org/problemnew/show/P3588)）

那么我们只需要同时维护一棵出线段树和一棵入线段树即可

------

### 总结&&CODE

最后问题回归到最短路问题，那么这题就被我们~~轻松~~艰难的切掉了。

考虑复杂度，由于有线段树的存在总边数是$O(n\log n)$的（认为$n,m$同阶）

算上Dijkstra的一个$\log$复杂度为$O(n\log^2n)$

千万注意码的时候要注意自己在干什么，不要不小心把自己码晕了。

附上200+的CODE

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cctype>
#include<queue>
#include<vector>
#include<cstring>
#include<algorithm>
#define RI register int
#define pb push_back
#define Ms(f,x) memset(f,x,sizeof(f))
#define Tp template <typename T>
using namespace std;
typedef long long LL;
const int N=50005,K=20005;
int t,n,m,k,dep[K],dfn[K],rv[2][K],tot;
class FileInputOutput
{
	private:
		#define S 1<<21
		#define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
		#define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))
		char Fin[S],Fout[S],*A,*B; int Ftop,pt[25];
	public:
		Tp inline void read(T &x)
		{
			x=0; char ch; while (!isdigit(ch=tc()));
			while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
		}
		Tp inline void write(T x)
		{
			if (!x) return (void)(pc('0'),pc('\n')); RI ptop=0;
			while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc('\n');
		}
		inline void Fend(void)
		{
			fwrite(Fout,1,Ftop,stdout);
		}
		#undef S
		#undef tc
		#undef pc
}F;
inline bool cmp(int x,int y)
{
	return dfn[x]<dfn[y];
}
class LCA_Solver
{
	private:
		#define P 15
		struct edge
		{
			int to,nxt;
		}e[K]; int head[K],cnt,idx,anc[K][P],x,y,z;
		inline void add(int x,int y)
		{
			e[++cnt]=(edge){y,head[x]}; head[x]=cnt;
		}
		inline void reset(int now)
		{
			for (RI i=0;i<P-1;++i) anc[now][i+1]=anc[anc[now][i]][i];
		}
		#define to e[i].to
		inline void DFS(int now,int fa)
		{
			dep[now]=dep[fa]+1; reset(now); dfn[now]=++idx;
			for (RI i=head[now];i;i=e[i].nxt) anc[to][0]=now,DFS(to,now);
		}
		#undef to
		inline void swap(int &x,int &y)
		{
			int t=x; x=y; y=t;
		}
	public:
		inline void init(void)
		{
			cnt=idx=0; Ms(head,0); for (RI i=1;i<k;++i)
			F.read(x),F.read(y),F.read(z),add(x,y); DFS(1,0);
		}
		inline int query(int x,int y)
		{
			RI i; if (dep[x]<dep[y]) swap(x,y); for (i=P-1;~i;--i)
			if (dep[anc[x][i]]>=dep[y]) x=anc[x][i]; if (x==y) return x;
			for (i=P-1;~i;--i) if (anc[x][i]!=anc[y][i])
			x=anc[x][i],y=anc[y][i]; return anc[x][0];
		}
}L;
class Graph_Solver
{
	private:
		#define NS 1000005
		#define MS 4000005
		struct edge
		{
			int to,nxt,v;
		}e[MS]; int head[NS],cnt,pos[NS],st,a,b,d,pcnt,p[N<<1]; bool vis[NS]; LL dis[NS],c;
		int num[2][K<<2],stack[K],top,father[K],size[K],ndfn[K];;
		struct data
		{
			LL val; int id;
			inline data(LL Val=0,int Id=0) { val=Val; id=Id; }
			inline friend bool operator <(data A,data B)
			{
				return A.val>B.val;
			}
		}; priority_queue <data> small; vector <int> v[N][2];
		inline void add(int x,int y,int z)
		{
			e[++cnt]=(edge){y,head[x],z}; head[x]=cnt;
		}
		inline void build(int opt,int now,int l,int r)
		{
			num[opt][now]=++tot; if (l==r) return (void)(rv[opt][p[l]]=tot);
			int mid=l+r>>1; build(opt,now<<1,l,mid); build(opt,now<<1|1,mid+1,r);
			if (!opt) add(num[opt][now<<1],num[opt][now],0),add(num[opt][now<<1|1],num[opt][now],0);
			else add(num[opt][now],num[opt][now<<1],0),add(num[opt][now],num[opt][now<<1|1],0);
		}
		#define O beg,end,id,val
		inline void link(int opt,int now,int l,int r,int beg,int end,int id,int val)
		{
			if (l>=beg&&r<=end) { if (!opt) add(num[opt][now],id,val); else add(id,num[opt][now],val); return; }
			int mid=l+r>>1; if (beg<=mid) link(opt,now<<1,l,mid,O); if (end>mid) link(opt,now<<1|1,mid+1,r,O);
		}
		#undef O
		inline void VT_build(void)
		{
			RI i; father[stack[top=1]=p[1]]=0;
			int t=pcnt; for (i=2;i<=t;++i)
			{
				int fa=L.query(stack[top],p[i]);
				while (top&&dep[stack[top]]>dep[fa])
				{
					if (top==1||dep[stack[top-1]]<=dep[fa])
					father[stack[top]]=fa; --top;
				}
				if (fa!=stack[top]) father[fa]=stack[top],stack[++top]=fa,p[++pcnt]=fa;
				stack[++top]=p[i]; father[p[i]]=fa;
			}
			sort(p+1,p+pcnt+1,cmp); for (i=1;i<=pcnt;++i) size[p[i]]=1;
			for (i=pcnt;i;--i) size[father[p[i]]]+=size[p[i]],ndfn[p[i]]=i;
			for (build(0,1,1,pcnt),build(1,1,1,pcnt),i=1;i<=pcnt;++i)
			{
				int now=p[i]; ++tot; link(0,1,1,pcnt,i,i,tot,dep[now]-1);
				link(1,1,1,pcnt,i,i+size[now]-1,tot,0);	int fa=father[now]; if (!fa) continue;
				++tot; link(0,1,1,pcnt,i,i+size[now]-1,tot,dep[fa]-1);
				if (ndfn[fa]<=i-1) link(1,1,1,pcnt,ndfn[fa],i-1,tot,0);
				if (i+size[now]<=ndfn[fa]+size[fa]-1) link(1,1,1,pcnt,i+size[now],ndfn[fa]+size[fa]-1,tot,0);
			}
		}
		Tp inline void miner(T &x,T y)
		{
			if (y<x) x=y;
		}
	public:
		inline void init(void)
		{
			RI i; for (i=1;i<=n;++i) v[i][0].clear(),v[i][1].clear();
			for (cnt=tot=0,Ms(head,0),i=1;i<=m;++i)
			{
				F.read(a); F.read(b); F.read(c); F.read(d);
				pos[tot+1]=d; pos[tot+2]=d; v[a][1].pb(tot+1); v[b][0].pb(tot+2);
				add(tot+1,tot+2,c); tot+=2;
			}
			pos[st=++tot]=1; v[1][0].pb(st);
		}
		inline void build(void)
		{
			RI j,k; int lim; for (RI i=1;i<=n;++i)
			{
				for (pcnt=k=0;k<2;++k)
				for (lim=v[i][k].size(),j=0;j<lim;++j)
				p[++pcnt]=pos[v[i][k][j]];
				sort(p+1,p+pcnt+1); pcnt=unique(p+1,p+pcnt+1)-p-1;
				sort(p+1,p+pcnt+1,cmp); VT_build();
				for (k=0;k<2;++k) for (lim=v[i][k].size(),j=0;j<lim;++j)
				{
					int t=v[i][k][j]; if (!k) add(t,rv[k][pos[t]],0); else add(rv[k][pos[t]],t,0);
				}
			}
		}
		#define to e[i].to
		inline void Dijkstra(void)
		{
			Ms(dis,63); Ms(vis,0); small.push(data(dis[st]=0,st));
			while (!small.empty())
			{
				int now=small.top().id; small.pop();
				if (vis[now]) continue; vis[now]=1;
				for (RI i=head[now];i;i=e[i].nxt)
				if (dis[to]>dis[now]+e[i].v)
				small.push(data(dis[to]=dis[now]+e[i].v,to));
			}
		}
		#undef to
		inline void print(void)
		{
			for (RI i=2;i<=n;++i)
			{
				int lim=v[i][0].size(); LL ans=1e18;
				for (RI j=0;j<lim;++j) miner(ans,dis[v[i][0][j]]);
				F.write(ans);
			}
		}
}G;
int main()
{
	//freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
	for (F.read(t);t;--t)
	{
		F.read(n); F.read(m); F.read(k); G.init();
		L.init(); G.build(); G.Dijkstra(); G.print();
	}
	return F.Fend(),0;
}
```



---

## 作者：Querainy (赞：7)

先扯点题外话。最短路有一个性质是说，两个点之间连很多条边等价于连最短的那条边，或者说最短路会自动给重边取$\min$。

如果我们建图的时候应该连边$a\stackrel{w}{\longrightarrow}b$，实际上只要保证有一条$a\stackrel{w}{\longrightarrow}b$，并且其它所有$a\stackrel{w^\prime}{\longrightarrow}b$都满足$w^\prime\geq w$即可。当然这个箭头记号表示一条有向边的起点、终点和边权(好像并不标准?但是很形象)。

看到这个题，首先我们有一个显然的结论，那就是lcp就是lca深度(根深度为0)。

考虑对每条边做一个拆点，我们把一条边权为$w$的边$i$中间加上一个入点一个出点，记为$in_i,out_i$，并连边$in_i\stackrel{w}{\longrightarrow}out_i$。

然后考虑原图中的点仅仅表示边的连通性，所以一个暴力的想法就是去掉原图中的点，而对每个点把它周围所有的边都连一连。具体地，对于每条连向点$u$的边，把它的出点向每条从$u$发出的边的入点连边，边权是lca深度。

如果遇到一个点周围有很多边，我们得到的边数就是$O(n^2)$，会爆炸。

因为最短路是对重边取$\min$，我们可以考虑能不能把lca深度也搞成一个$\min$的形式(**核心思想**)，这样就可以利用最短路的取$\min$来处理lca深度了。

容易想到使用dfs序lca。dfs序lca的结论是，如果我们记录一棵树的欧拉序(每经过一次都记录一次)，那么两个点的lca就是它们第一次被访问的位置之间深度最小的点。

所以如果我们设$d_i$表示dfn中第$i$个位置上那个点的深度，$id_u$表示点$u$第一次被访问的时间，那么就有

$$
\mathrm{dep}(\mathrm{lca}(u,v))=\min_{i=id_u}^{id_v}d_i
$$

然后呢?考虑一个$d_i$什么时候会参与这个取$\min$的过程，应该是查询的两个点，一个点在它前面，一个点在它后面的时候。

换句话说，这个点的贡献就相当于**给它对应的前缀连到后缀，后缀连到前缀，边权是它的深度**。!!!我们已经得到做法了!

这里可以使用线段树优化建图，不过更好的方法是使用前后缀和优化建图。

前后缀和优化建图是什么?以前缀和为例，我们新建一排点表示前缀和，前缀和那一排中的点$i$连向点$i-1$和原序列中的第$i$个点，这样它实际上连到了原序列中的前$i$个点。我们可以使用这个结构支持一个点向一个前缀连边。前缀向点连边，点向后缀连边，后缀向点连边是同样的。

对于这个题，我们需要建四排点，分别表示前缀入点，前缀出点，后缀入点，后缀出点。

这里需要建立虚树，在虚树上求欧拉序，这一步没有难写到一定程度，但是实际上还可以简化，具体可以见别的题解。反正我没想着简化（

复杂度是$O((n+m)\log n)$。

代码确实很难写!需要一定的封装技巧才能让代码可读，这里我考虑了好久，写了200+lines，还是不可读......

这题还有一些别的做法。网上说的带$\log$甚至$\log^2$的树剖和树上倍增做法我实在是没想明白，希望神仙们可以教教我/se

温馨提示 : 多测不清空，爆零两行泪!

code:

```cpp
#include<stdio.h>
#include<string.h>
#include<vector>
#include<algorithm>
#include<queue>
using std::priority_queue;
using std::sort;
using std::vector;

inline void swap(int &x,int &y){ x^=y^=x^=y; }
inline long long min(long long x,long long y){ return x<y?x:y; }

namespace Tree
{

struct Graph
{
	struct Edge
	{
		int v,next;
	}e[100002];
	int ecnt,h[20002];
	inline void add_edge(int u,int v)
	{
		e[++ecnt]={v,h[u]};
		h[u]=ecnt;
		e[++ecnt]={u,h[v]};
		h[v]=ecnt;
	}
	inline void clear()
	{
		ecnt=0;
		memset(h,0,sizeof(h));
	}
}G,T;

int f[20][40002],id[20002],cnt,dep[20002],lg[40002];

inline void cleartree()
{
	G.clear(),T.clear();
	cnt=0;
}

void predfs(int u,int _fa)
{
	f[0][++cnt]=u,id[u]=cnt;
	dep[u]=dep[_fa]+1;
	for(int i=G.h[u];i;i=G.e[i].next)
		if(G.e[i].v!=_fa)
			predfs(G.e[i].v,u),f[0][++cnt]=u;
}

inline void st_init()
{
	for(int k=1;k<=20;k++)
		for(int i=1;i<=cnt-(1<<k)+1;i++)
			f[k][i]=(dep[f[k-1][i]]<dep[f[k-1][i+(1<<(k-1))]]?f[k-1][i]:f[k-1][i+(1<<(k-1))]);
	for(int i=2;i<=cnt;i++)
		lg[i]=lg[i>>1]+1;
}

inline int lca(int u,int v)
{
	u=id[u],v=id[v];
	if(u>v) swap(u,v);
	int l=lg[v-u+1];
	return dep[f[l][u]]<dep[f[l][v-(1<<l)+1]]?f[l][u]:f[l][v-(1<<l)+1];
}

int s[20002],top;
inline void clear(int u){ T.h[u]=0; }
inline void insert(int u)
{
	int l=lca(u,s[top]);
	if(l!=s[top])
	{
		while(id[l]<id[s[top-1]]) T.add_edge(s[top-1],s[top]),top--;
		if(id[l]!=id[s[top-1]]) clear(l),T.add_edge(l,s[top]),s[top]=l;
		else T.add_edge(l,s[top]),top--;
	}
	clear(u),s[++top]=u;
}

inline bool cmp(int u,int v){ return id[u]<id[v]; }
inline void build(int n,int *a)
{
	sort(a+1,a+n+1,cmp);
	T.ecnt=0,clear(1),s[top=1]=1;
	for(int i=1;i<=n;i++)
		if(a[i]!=1&&a[i]!=a[i-1]) insert(a[i]);
	for(int i=1;i<top;i++) T.add_edge(s[i],s[i+1]);
}

inline void get_dfn(int u,int _fa,int *dfn,int *id,int &cnt)
{
	dfn[++cnt]=dep[u],id[u]=cnt;
	for(int i=T.h[u];i;i=T.e[i].next)
		if(T.e[i].v!=_fa)
			get_dfn(T.e[i].v,u,dfn,id,cnt),dfn[++cnt]=dep[u];
}

}

int ncnt;
inline int new_node(){ return ++ncnt; }

int n,m,k;
int nodein[50002],nodeout[50002],prein[40002],sufin[40002],preout[40002],sufout[40002];
struct Pair{ int u,id; };
vector<Pair> in[50002],out[50002];

namespace Dij
{

struct Edge
{
	int v,w,next;
}e[20000002];

int ecnt,h[2000002];
inline void add_edge(int u,int v,int w)
{
	e[++ecnt]={v,w,h[u]};
	h[u]=ecnt;
}

inline void clear()
{
	ecnt=0;
	memset(h,0,sizeof(h));
}

struct DijNode
{
	int u;long long dis;
};
inline bool operator < (DijNode x,DijNode y){ return x.dis>y.dis; }

long long dis[2000002];
bool vis[2000002];

inline void Dij()
{
	priority_queue<DijNode> q;
	//while(!q.empty()) q.pop();
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	for(int i=0;i<out[1].size();i++)
		dis[out[1][i].u]=0,q.push({out[1][i].u,0});
	while(!q.empty())
	{
		int u=q.top().u;q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=h[u];i;i=e[i].next)
			if(dis[u]+e[i].w<dis[e[i].v])
				dis[e[i].v]=dis[u]+e[i].w,q.push({e[i].v,dis[e[i].v]});
	}
}

}

using Dij::add_edge;

inline void build_graph()
{
	static int temp[100002],dfn[40002],id[100002];
	for(int u=1;u<=n;u++)
	{
		int tcnt=0;
		for(int i=0;i<in[u].size();i++)
			temp[++tcnt]=in[u][i].id;
		for(int i=0;i<out[u].size();i++)
			temp[++tcnt]=out[u][i].id;
		Tree::build(tcnt,temp);
		int cnt=0;
		Tree::get_dfn(1,0,dfn,id,cnt);
		for(int i=1;i<=cnt;i++)
			prein[i]=new_node(),sufin[i]=new_node(),preout[i]=new_node(),sufout[i]=new_node();
		for(int i=2;i<=cnt;i++)
			add_edge(prein[i],prein[i-1],0),
			add_edge(preout[i-1],preout[i],0);
		for(int i=1;i<=cnt-1;i++)
			add_edge(sufin[i],sufin[i+1],0),
			add_edge(sufout[i+1],sufout[i],0);
		for(int i=0;i<in[u].size();i++)
			add_edge(in[u][i].u,preout[id[in[u][i].id]],0),
			add_edge(in[u][i].u,sufout[id[in[u][i].id]],0);
		for(int i=0;i<out[u].size();i++)
			add_edge(prein[id[out[u][i].id]],out[u][i].u,0),
			add_edge(sufin[id[out[u][i].id]],out[u][i].u,0);
		for(int i=1;i<=cnt;i++)
			add_edge(preout[i],sufin[i],dfn[i]),add_edge(sufout[i],prein[i],dfn[i]);
	}
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&n,&m,&k);
		for(int i=1,u,v,w,id;i<=m;i++)
			scanf("%d%d%d%d",&u,&v,&w,&id),
			nodein[i]=new_node(),nodeout[i]=new_node(),add_edge(nodein[i],nodeout[i],w),
			in[v].push_back({nodeout[i],id}),out[u].push_back({nodein[i],id});
		for(int i=1,u,v,w;i<k;i++)
			scanf("%d%d%d",&u,&v,&w),Tree::G.add_edge(u,v);
		Tree::dep[0]=-1,Tree::predfs(1,0),Tree::st_init();
		build_graph();
		Dij::Dij();
		for(int i=2;i<=n;i++)
		{
			long long ans=0x7fffffffffffffff;
			for(int j=0;j<in[i].size();j++)
				ans=min(ans,Dij::dis[in[i][j].u]);
			printf("%lld\n",ans);
		}
		Dij::clear();
		Tree::cleartree();
		ncnt=0;
		for(int i=1;i<=n;i++)
			in[i].clear(),out[i].clear();
	}
	return 0;
}
```

---

## 作者：CalvinJin (赞：5)

首先字典树上的边权是没有用的 对于两个点的$lcp$其实就是在字典树上的$lca$

但是不能每次都求$lca$ 这样显然会超时

本题中的点其实没有什么用 可以把所有边在新图中看做点 并且连边

然后需要考虑优化建边

把在原图中的每个点相连的边找出来 用他们在字典树上的点构建一棵虚树

此时虚树上的一个点就是它两两子树内的点的$lca$ 或这个点和子树内某个点的$lca$

但是在子树内直接连边 边数仍然很大

观察到子树是一个连续的区间 可以用线段树上的一个点表示一个区间 然后再这个点上连边

这时候就需要建两棵线段树 分别管理入边和出边 管理的下标是虚树内的$dfn$

入边节点向入线段树对应叶子节点连边 边权即为原图上这条边的边权

出线段树叶子节点向对应出边节点连边 边权为0

然后在线段树内 入线段树的子节点向父节点连边 出线段树相反


枚举作为$lca$的点

两两子树内连边时是一段连续的区间向另两段区间（可能为一段）连边

因此需要一个辅助节点 把入线段树的区间都连到这个点 再连到出线段树的另外两个区间

入线段树连的边边权为当前枚举的点的深度

这个点也要和子树内连边


新图就建立完成了

但是这样无法得到到每个点的距离

可以先建立一个起点 当做1节点的入边 边权为0

然后在中间虚树处理过程中 每个原图上的点新开一个节点 把每个入线段树的叶子节点都连到这个点 边权为0


接下来只要跑一遍$Dijkstra$即可

$O(n*log^2n)$


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 50010
#define M 20010
#define K 1000010
inline void rd(int &x){
    char c;x=0;
    while (c=getchar(),c<48);
    do x=(x<<1)+(x<<3)+(c^48);
    while (c=getchar(),c>=48);
}
inline void pt(long long x){
    if (!x) putchar('0');
    else{
        static int s[20],t;
        for (t=0;x;x/=10) s[t++]=x%10;
        while (t) putchar(s[--t]^48);
    }
    putchar('\n'); 
}
struct edge{
    int nxt,t,s;
}e[K<<2];
int head[K],edge_cnt;
inline void add_edge(int x,int y,int z){
    e[edge_cnt]=(edge){head[x],y,z};
    head[x]=edge_cnt++;
}
struct INOUTEdge{
    int nxt,x;
}w[N<<2];
int G1[N],G2[N],G_cnt;
inline void add_G(int *G,int x,int y){
    w[G_cnt]=(INOUTEdge){G[x],y};
    G[x]=G_cnt++;
}
int val[N],Tid[N],poiID[N];
struct Trie_Tree{
    struct Edge{
        int nxt,t;
    }E[M];
    int Head[M],Edge_cnt,fa[M],dep[M],siz[M],son[M],top[M],dfs_cnt,dfn[N],ed[N];
    inline void Add_edge(int x,int y){
        E[Edge_cnt]=(Edge){Head[x],y};
        Head[x]=Edge_cnt++;
    }
    void clear(){
        memset(Head,-1,sizeof(Head));
        dfs_cnt=Edge_cnt=0;
    }
    void dfs(int x,int f){
        fa[x]=f;
        dep[x]=dep[f]+1;
        siz[x]=1;
        son[x]=0;
        int i;
        for (i=Head[x];~i;i=E[i].nxt){
            int to=E[i].t;
            if (to==f) continue;
            dfs(to,x);
            siz[x]+=siz[to];
            if (siz[to]>siz[son[x]]) son[x]=to;
        }
    }
    void dfs1(int x,int tp){
        dfn[x]=++dfs_cnt;
        top[x]=tp;
        if (son[x]) dfs1(son[x],tp);
        int i;
        for (i=Head[x];~i;i=E[i].nxt){
            int to=E[i].t;
            if (to==fa[x] || to==son[x]) continue;
            dfs1(to,to);
        }
        ed[x]=dfs_cnt;
    }
    int LCA(int x,int y){
        while (top[x]!=top[y]){
            if (dep[top[x]]<dep[top[y]]) y=fa[top[y]];
            else x=fa[top[x]];
        }
        return dep[x]<dep[y]?x:y;
    }
    void init(){
        dfs(1,0);
        dfs1(1,1);
    }
}Trie;
int vcnt,a[N<<1],h,vid1[N<<1],vid2[N<<1],vdfn[N<<1],ved[N<<1],vfa[N<<1],tmp[N<<1];
struct Virtual_Tree{
    #define Lc p<<1
    #define Rc p<<1|1
    struct Segment_Tree_out{//出线段树
        int g[N<<3];
        void build(int l,int r,int p){
            g[p]=++vcnt;
            if (l==r){
                vid1[l]=g[p];
                return;
            }
            int mid=(l+r)>>1;
            build(l,mid,Lc);
            build(mid+1,r,Rc);
            add_edge(g[p],g[Lc],0);
            add_edge(g[p],g[Rc],0);
        }
        void add(int l,int r,int p,int pl,int pr,int x,int a){
            if (l==pl && r==pr){
                add_edge(x,g[p],a);
                return;
            }
            int mid=(l+r)>>1;
            if (pr<=mid) add(l,mid,Lc,pl,pr,x,a);
            else if (pl>mid) add(mid+1,r,Rc,pl,pr,x,a);
            else add(l,mid,Lc,pl,mid,x,a),add(mid+1,r,Rc,mid+1,pr,x,a);
        }
    }T1;
    struct Segment_Tree_in{//入线段树
        int g[N<<3];
        void build(int l,int r,int p){
            g[p]=++vcnt;
            if (l==r){
                vid2[l]=g[p];
                return;
            }
            int mid=(l+r)>>1;
            build(l,mid,Lc);
            build(mid+1,r,Rc);
            add_edge(g[Lc],g[p],0);
            add_edge(g[Rc],g[p],0);
        }
        void add(int l,int r,int p,int pl,int pr,int x,int a){
            if (l==pl && r==pr){
                add_edge(g[p],x,a);
                return;
            }
            int mid=(l+r)>>1;
            if (pr<=mid) add(l,mid,Lc,pl,pr,x,a);
            else if (pl>mid) add(mid+1,r,Rc,pl,pr,x,a);
            else add(l,mid,Lc,pl,mid,x,a),add(mid+1,r,Rc,mid+1,pr,x,a);
        }
    }T2;
    static bool cmp(int x,int y){
        return Trie.dfn[x]<Trie.dfn[y];
    }
    inline bool contain(int x,int y){
        return Trie.dfn[x]>=Trie.dfn[y] && Trie.dfn[x]<=Trie.ed[y];
    }
    void vbuild(){
        int i;
        sort(a+1,a+1+h,cmp);
        for (i=1;i<h;i++) a[h+i]=Trie.LCA(a[i],a[i+1]);
        sort(a+1,a+h*2,cmp);
        h=unique(a+1,a+h*2)-a-1;
        int h1=0;
        for (i=1;i<=h;i++){
            vdfn[a[i]]=i;
            while (h1 && !contain(a[i],tmp[h1])) ved[tmp[h1--]]=i-1;
            vfa[a[i]]=tmp[h1];
            tmp[++h1]=a[i];
        }
        while (h1) ved[tmp[h1--]]=h;
    }
    void solve(int x){
        int i;
        h=0;
        for (i=G1[x];~i;i=w[i].nxt) a[++h]=Tid[w[i].x];
        for (i=G2[x];~i;i=w[i].nxt) a[++h]=Tid[w[i].x];
        vbuild();
        T1.build(1,h,1);
        T2.build(1,h,1);
        for (i=G1[x];~i;i=w[i].nxt) add_edge(vid1[vdfn[Tid[w[i].x]]],w[i].x,0);
        for (i=G2[x];~i;i=w[i].nxt) add_edge(w[i].x,vid2[vdfn[Tid[w[i].x]]],val[w[i].x]);
        for (i=2;i<=h;i++){
            int p=++vcnt;
            int x1=a[i],y1=vfa[a[i]];
            T2.add(1,h,1,vdfn[x1],ved[x1],p,Trie.dep[y1]);
            T1.add(1,h,1,vdfn[y1],vdfn[x1]-1,p,0);
            if (ved[x1]<ved[y1]) T1.add(1,h,1,ved[x1]+1,ved[y1],p,0);
        }
        poiID[x]=++vcnt;
        for (i=1;i<=h;i++){
            int x1=a[i];
            T1.add(1,h,1,vdfn[x1],ved[x1],vid2[vdfn[x1]],Trie.dep[x1]);
            add_edge(vid2[vdfn[x1]],poiID[x],0);
        }
    }
}vTree;
struct node{
    int x;
    long long d;
    bool operator <(const node &_)const{
        return d<_.d;
    }
};
struct heap{
    #define swap(x,y) (tt=x,x=y,y=tt)
    node A[K],tt;
    int Top;
    void push(node x){
        A[++Top]=x;
        int i=Top;
        while (i>1){
            int j=i>>1;
            if (A[i]<A[j]) swap(A[i],A[j]),i=j;
            else break;
        }
    }
    void pop(){
        A[1]=A[Top--];
        int i=1;
        while ((i<<1)<=Top){
            int j=i<<1;
            if (j<Top && A[j+1]<A[j]) j++;
            if (A[j]<A[i]) swap(A[i],A[j]),i=j;
            else break;
        }
    }
}Q;
long long dis[K];
bool vis[K];
void Dijkstra(int st){
    memset(dis,63,sizeof(dis));
    memset(vis,0,sizeof(vis));
    int i;
    Q.push((node){st,0});
    dis[st]=0;
    while (Q.Top){
        int x=Q.A[1].x;
        long long z=Q.A[1].d;
        Q.pop();
        if (vis[x]) continue;
        vis[x]=1;
        for (i=head[x];~i;i=e[i].nxt){
            int to=e[i].t,Val=e[i].s;
            if (dis[to]>z+Val){
                dis[to]=z+Val;
                Q.push((node){to,dis[to]});
            }
        }
    }
}
void Clear(){
    memset(head,-1,sizeof(head));
    memset(G1,-1,sizeof(G1));
    memset(G2,-1,sizeof(G2));
    edge_cnt=G_cnt=0;
    Trie.clear();
}
int main(){
    int Case;
    rd(Case);
    Trie.dep[0]=-1;
    while (Case--){
        Clear();
        int n,m,k,i;
        rd(n),rd(m),rd(k);
        for (i=1;i<=m;i++){
            int x,y;
            rd(x),rd(y),rd(val[i]),rd(Tid[i]);
            add_G(G1,x,i);//出边 
            add_G(G2,y,i);//入边 
        }
        for (i=1;i<k;i++){
            int x,y,z;
            rd(x),rd(y),rd(z);
            Trie.Add_edge(x,y);
        }
        Trie.init();
        m++;
        val[m]=0;
        Tid[m]=1;
        add_G(G2,1,m);//另造一个起点
        vcnt=m;
        for (i=1;i<=n;i++) vTree.solve(i);
        Dijkstra(m);
        for (i=2;i<=n;i++) pt(dis[poiID[i]]);
    }
    return 0;
}
```

---

## 作者：Prean (赞：3)

前排提醒：多测不清空的你再强大，考场上也是假的！

题意有些复杂所以我在这里说一下。。。

给定一张图 $G$ 和一棵树 $T$，图上每条边有一个边权 $w$ 和树上的一个节点 $u$，经过一条边 $a$ 后再经过一条边 $b$ 的代价为 $b.w+LCA(a.u,b.u)$，求 $1$ 节点到每个节点的最短路。经过第一条边的代价仅为 $a.w$。

首先容易发现信息都是给在边上的，甚至需要计算边对边的信息。所以在点上跑最短路是没有前途的，要把边建成一个点，然后对这些点跑最短路。

再转化成原图上的最短路很简单，把最短路塞到出点上去就行了。

枚举中转点，我们要将入边对应的点连接到出边上面去。

我们将入边和出边在 $T$ 上的点拉出来建一颗虚树。

对于每个节点，我们开两个在需要跑最短路的图上的节点 $q$ 和 $p$。子树内的入边连接 $q$，$p$ 连接子树内的出边。

然后从一条边回溯的时候，令 $q$ 连接 $p$ 即可，边权为该节点的深度。要合并 $q$ 和 $p$ 也很简单。

然后就做完了。复杂度 $O(\sum m\log n)$。
```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
#include<cctype>
typedef long long ll;
const int M=2e5+5;
int T,n,m,k,ege,dfc,h[M],f[M],d[M],dfn[M],siz[M],son[M],top[M];ll ans[M];
int tp,stk[M];int q[M],p[M];int len,t[M];int V[M];
struct Graph{
	int G,tot,ege,h[M*10],zkw[M*10<<2];ll d[M*10],ans[M*10];bool vis[M*10];
	struct Edge{
		int v,w,nx;
	}e[M*30];
	inline int nnd(){
		++tot;h[tot]=d[tot]=ans[tot]=vis[tot]=0;return tot;
	}
	inline void Add(const int&u,const int&v,const int&w){
		e[++ege]=(Edge){v,w,h[u]};h[u]=ege;
	}
	inline void Mdf(int u,const ll&V){
		for(d[u]=V,u+=G;u>>=1;zkw[u]=zkw[u<<1|(d[zkw[u<<1|1]]<d[zkw[u<<1]])]);
	}
	inline void Dijkstra(){
		for(G=1;G<=tot+1;G<<=1);for(int i=0;i<=tot;++i)d[zkw[i+G]=i]=1e18,vis[i]=false;
		for(int u=G-1;u;--u)zkw[u]=zkw[u<<1|(d[zkw[u<<1|1]]<d[zkw[u<<1]])];Mdf(m+1,0);
		while(zkw[1]){
			const int u=zkw[1];ans[u]=d[u];Mdf(u,2e18);vis[u]=true;
			for(int v,&E=h[u];E;E=e[E].nx)if(v=e[E].v,!vis[v]&&ans[u]+e[E].w<d[v])Mdf(v,ans[u]+e[E].w);
		}
		for(int i=1;i<=tot;++i)h[i]=0;for(int i=1;i<=tot+G;++i)zkw[i]=0;
		for(int i=1;i<=m;++i)if(ans[i]<::ans[V[i]])::ans[V[i]]=ans[i];
		tot=ege=0;
	}
}G;
struct Edge{
	int v,nx;
}e[M];
struct edge{
	int w,u,id;
};std::vector<edge>in[M],out[M];
inline void Add(const int&u,const int&v){
	e[++ege]=(Edge){v,h[u]};h[u]=ege;
}
inline void DFS1(const int&u){
	d[u]=d[f[u]]+1;siz[u]=1;
	for(int v,E=h[u];E;E=e[E].nx)if((v=e[E].v)^f[u])f[v]=u,DFS1(v),siz[v]>siz[son[u]]&&(son[u]=v),siz[u]+=siz[v];
}
inline void DFS2(const int&u,const int&tp){
	top[u]=tp;dfn[u]=++dfc;if(!son[u])return;DFS2(son[u],tp);
	for(int E=h[u];E;E=e[E].nx)if(e[E].v^f[u]&&e[E].v^son[u])DFS2(e[E].v,e[E].v);
}
inline int LCA(int u,int v){
	while(top[u]^top[v])d[top[u]]>d[top[v]]?u=f[top[u]]:v=f[top[v]];return d[u]>d[v]?v:u;
}
inline void Insert(const int&u){
	if(!tp)return void(stk[tp=1]=u);
	const int&v=LCA(u,stk[tp]);while(tp>1&&d[v]<d[stk[tp-1]])Add(stk[tp-1],stk[tp]),--tp;
	if(stk[tp]^v)Add(v,stk[tp--]);if(v^stk[tp])stk[++tp]=v;if(u^stk[tp])stk[++tp]=u;
}
inline void Solve(const int&u){
	if(q[u]&&p[u])G.Add(q[u],p[u],d[u]);
	for(int v,&E=h[u];E;E=e[E].nx){
		Solve(v=e[E].v);if(q[u]&&p[v])G.Add(q[u],p[v],d[u]);if(q[v]&&p[u])G.Add(q[v],p[u],d[u]);
		if(q[v])q[u]?G.Add(q[u],G.nnd(),0),G.Add(q[v],q[u]=G.tot,0),0:q[u]=q[v];
		if(p[v])p[u]?G.Add(G.nnd(),p[u],0),G.Add(p[u]=G.tot,p[v],0),0:p[u]=p[v];
		q[v]=p[v]=0;
	}
}
inline void work(const int&u){
	for(edge&E:in[u])t[++len]=E.u;for(edge&E:out[u])t[++len]=E.u;
	std::sort(t+1,t+len+1,[](const int&a,const int&b){return dfn[a]<dfn[b];});len=std::unique(t+1,t+len+1)-t-1;
	for(edge&E:in[u])!q[E.u]&&(q[E.u]=G.nnd()),G.Add(E.id,q[E.u],0);
	for(edge&E:out[u])!p[E.u]&&(p[E.u]=G.nnd()),G.Add(p[E.u],E.id,E.w);
	for(int i=1;i<=len;++i)Insert(t[i]);while(tp>1)Add(stk[tp-1],stk[tp]),--tp;
	Solve(stk[tp]);q[stk[tp]]=p[stk[tp]]=0;len=tp=0;
}
inline int read(){
	int n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
}
signed main(){
	T=read();d[0]=-1;
	while(T--){
		n=read();m=read();k=read();G.tot=m;
		for(int i=1;i<=n;++i)ans[i]=1e18;
		for(int u,v,t,p,i=1;i<=m;++i){
			u=read();v=read();t=read();p=read();V[i]=v;
			in[v].push_back((edge){t,p,i});out[u].push_back((edge){t,p,i});
		}
		for(int u,v,i=1;i<k;++i)u=read(),v=read(),read(),Add(u,v);DFS1(1);DFS2(1,1);for(int i=1;i<=k;++i)h[i]=0;
		G.nnd();for(edge&E:out[1])G.Add(G.tot,E.id,E.w);
		for(int u=1;u<=n;++u)if(!in[u].empty()&&!out[u].empty())work(u);
		G.Dijkstra();for(int i=2;i<=n;++i)printf("%lld\n",ans[i]);
		for(int i=1;i<=k;++i)h[i]=f[i]=d[i]=dfn[i]=siz[i]=son[i]=top[i]=0;
		for(int i=1;i<=n;++i)ans[i]=0,std::vector<edge>().swap(in[i]),std::vector<edge>().swap(out[i]);
		for(int i=1;i<=m;++i)V[i]=0;dfc=ege=0;
	}
}
```

---

## 作者：wjyppm1403 (赞：1)

[可能更好的阅读体验](https://worldcpu.github.io/posts/905428b3/)

~~我不是来刷字符串的吗怎么给我干到这里来了~~

Trie 树神仙题

形式化题意可以看其他题解的。

首先这个字典树的边权没有任何卵用，因为题目中已经给出边上的 $d_{i}$ 了。

其次这个题一眼最短时间，说人话就是最短路，考虑 Dijkstra 求最短路，因为这里 SPFA 显然已死（你真的要卡 $O(nm)$？）。问题转化为如何取去建图，根据题意，通过一条边的边权是如下构成的：

$$w_{(u,v)} = c_{(u,v)} + \operatorname{LCP}(d_{now}, d_{i})$$

不难注意到题目中慷慨的给我们了字典树，根据字典树上的性质，任意两个点之间的 LCA 节点的深度大小就是这两点的所构成字符串的最长公共前缀长度，那么边权转化为：

$$w_{(u,v)} = c_{(u,v)} + dep\left\{\operatorname{LCA}(d_{now}, d_{i}\right\}$$

但是这里面有一个棘手的地方就是这个 $d_{now}$，因为如果我们真的要在 Dijkstra 上跑的话这个 $d_now$ 是不太好处理的。考虑题目的性质，注意到题目中的点几乎没有任何卵用，因为所有信息都在有向图的边上，那么我们考虑怎么从边上下手。考虑点边互换，将边拆成入点和出点，连边 $in \to out$，边权为 $c_{e}$。让后考虑这个 LCA 怎么处理，其实很简单，我们对于第一个边的出点，我们向第二个边的入点连上边权为两个边上的 LCA 权，即 $dep\left\{ \operatorname{LCA}(d_{(u,v)},d_{(v,t)}) \right\}$。

注意到节点 $1$ 向哪里走都是无代价的，所以对于所有 $1 \to a$ 的边，我们建超级源点 $S$，让 $S \to a$，边权为 $0$ 即可。

让后输出最短路长度的时候，答案即为 $\min\limits_{b_{e}=i} dis_{out}$，正确性是显然的。

写完交上去，恭喜你 MLE+TLE。为什么？因为边数最高可到达 $O(m^2)$ 啊，这个时候又要开始优化建图了（悲）。

---

首先原来的 $in \to out$ 显然是不能动的，我们考虑对 LCA 上下手，注意到我们对于 LCA 上都是一个一个连边的，而 LCA 对于大多数对节点是相同的，这是什么，虚树啊！我们考虑虚树的大小能否支持我们操作，不妨设 $S=\left\{ d_{i}| b_{i}=u,a_{i}=u \right\}$，那么这些边的边权只能是 $S$ 中任意两点 LCA 的深度，根据虚树特性理论，$S$，中任意两点的 LCA 总共只有 $O(|S|)$ 个，对于所有点，$\sum\limits_{u} |S_u|=m$，边复杂度 $O(m)$，可以接受。

我们考虑把 LCA 这个点拿出来建虚点，在子树中的节点连一个 LCA 的虚点，让后在从这个虚点连向另外一个虚点，让后在利用虚树进行建边，但是这样边数是 $O(n)$ 的，总边数还是 $O(n^2)$ 的，还是会被卡，考虑怎么优化。

注意到，我们实际上连边都是在子树中的节点连一个 LCA 的虚点，让后在从这个虚点连向另外一个虚点，考虑这个怎么优化。**子树的性质，DFN连续**。那么，问题转化为 DFS 序上的区间向点连边，点向另外一个连续区间连边，这是什么，线段树优化建图啊！让后就做完了，时间复杂度因为连边是 $O(\log n)$ 的，所以总复杂度是 $O(n \log^2 m)$，我没写因为我有卡常黑历史 www。

能不能再给力一点啊？

可以的！上述过程我们是在暴力枚举 LCA 的，事实上，如果两点间连了一堆的边，**但是只有代价最小的边是有用的**，剩下都是没太大啥用的，连了也不影响。

我们先把 $S$ 集合求出来，连边的话我们从 $[1,i]$ 的出点向 $[i+1,t]$ 入点，$[i+1,t]$ 出点向 $[1,i]$ 入点连边，其中 $t=|S|$，这个可以用线段树也可以用神秘的前缀后缀优化建图来做。让后根据上面所说的，只有代价最小的边有用，也就是说对于一个子树区间，只有 $\min_{x,y} dep[ \operatorname{lca}(x,y)]$ 才有用，我们考虑这个代价最小的边怎么连，注意到每次都是某个前缀向后缀连边，或者后缀向前缀连边，为什么，你思考上面线段树的做法。那么，我们建立四个数组：前缀入点、前缀出点、后缀入点、后缀出点。这样的建边是 $O(1)$ 的，时间复杂度是 $O(n \log m)$。

### 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
#define pir pair<int,int>
using namespace std;
constexpr int MN=1e6+15,MLOG=20;
struct Edge{
    int v,w;
};
struct EDGE{
    int a,b,c,d;
}e[MN];
int n,m,K,S,ans[MN],hlca[MN],ntot,prein[MN],preout[MN],sufin[MN],sufout[MN];
vector<int> out[MN],in[MN];
vector<Edge> adj[MN];
vector<pir> vt; // 这是集合 S

namespace Trie{
    vector<int> g[MN];
    int fa[MN][30],dep[MN],dfn[MN],dfntot;

    void triedfs(int u,int pre){
        dfn[u]=++dfntot;
        fa[u][0]=pre;
        dep[u]=dep[pre]+1;
        for(int i=1;i<=MLOG;i++){
            fa[u][i]=fa[fa[u][i-1]][i-1];
        }
        for(auto v:g[u]){
            triedfs(v,u);
        }
    }

    int lca(int x,int y){
        if(dep[x]>dep[y]) swap(x,y);
        for(int i=MLOG;i>=0;i--){
            if(dep[fa[y][i]]>=dep[x]) y=fa[y][i];
        }
        if(x==y) return x;
        for(int k=MLOG;k>=0;k--){
            if(fa[x][k]!=fa[y][k]){
                x=fa[x][k],y=fa[y][k];
            }
        }
        return fa[x][0];
    }

}using namespace Trie;

namespace Dijkstra{

    int dis[MN];
    bool vis[MN];

    void dijk(int st){
        memset(dis,0x3f,sizeof(dis));
        memset(vis,0,sizeof(vis));
        priority_queue<pir,vector<pir>,greater<pir>> q;
        dis[st]=0;
        q.push(pir(0,st));
        while(!q.empty()){
            int u=q.top().second;
            q.pop();
            if(vis[u]) continue;
            vis[u]=1;
            for(auto e:adj[u]){
                int v=e.v;
                if(dis[v]>dis[u]+e.w){
                    dis[v]=dis[u]+e.w;
                    q.push(pir(dis[v],v));
                }
            }
        }
    }

}using namespace Dijkstra;

bool cmp(pir x,pir y){
    return dfn[x.first]<dfn[y.first];
}

void clear(){
    S=MN-3;
    ntot=dfntot=0;
    memset(dfn,0,sizeof(dfn));
    memset(dep,0,sizeof(dep));
    memset(fa,0,sizeof(fa));
    for(int i=0;i<MN;i++){
        in[i].clear();
        out[i].clear();
        g[i].clear();
        adj[i].clear();
    }
}

void solve(){
    cin>>n>>m>>K;
    clear();
    ntot=m<<1;
    for(int i=1;i<=m;i++){
        cin>>e[i].a>>e[i].b>>e[i].c>>e[i].d;
        out[e[i].a].push_back(i);
        in[e[i].b].push_back(i);
    }
    for(int i=1;i<K;i++){
        int u,v,w;
        cin>>u>>v>>w;
        g[u].push_back(v);
    }
    triedfs(1,0);
    for(int i=1;i<=m;i++){
        adj[i].push_back({i+m,e[i].c});
        if(e[i].a==1) adj[S].push_back({i,0});
    }
    
    // 以上都是常规建边

    for(int i=1;i<=n;i++){
        vt.clear();
        for(auto p:in[i]) vt.push_back(pir(e[p].d,p+m));
        for(auto p:out[i]) vt.push_back(pir(e[p].d,p));
        sort(vt.begin(),vt.end(),cmp);
        for(int j=0;j<vt.size();j++){ //新建前缀后缀节点
            prein[j]=++ntot;
            preout[j]=++ntot;
            sufin[j]=++ntot;
            sufout[j]=++ntot;
        }
        for(int j=0;j+1<vt.size();j++){
            hlca[j]=lca(vt[j].first,vt[j+1].first); // 求出 dfn 排序后的任意两个节点的LCA
            adj[prein[j+1]].push_back({prein[j],0}); // 前缀后缀初始化建图
            adj[preout[j]].push_back({preout[j+1],0});
            adj[sufin[j]].push_back({sufin[j+1],0});
            adj[sufout[j+1]].push_back({sufout[j],0});
        }
        for(int j=0;j<vt.size();j++){
            // 前缀建图要分类，别建炸缸了
            if(vt[j].second<=m){
                adj[sufin[j]].push_back({vt[j].second,0});
                adj[prein[j]].push_back({vt[j].second,0});
            }
            else{
                adj[vt[j].second].push_back({sufout[j],0});
                adj[vt[j].second].push_back({preout[j],0});
            }
        }
        for(int j=0;j+1<vt.size();j++){
            // 连边，这里dep-1是因为根节点dep=1，而lcp是根节点到
            // 当前节点的距离，dep[rt]=1，所以要-1
            adj[sufout[j+1]].push_back({prein[j], dep[hlca[j]]-1});
            adj[preout[j]].push_back({sufin[j+1], dep[hlca[j]]-1});
        }
    }
    dijk(S);
    memset(ans,0x3f,sizeof(ans));
    for(int i=1;i<=m;i++){
        // 暴力枚举
        ans[e[i].b]=min(ans[e[i].b],dis[i+m]);
    }
    for(int i=2;i<=n;i++) cout<<ans[i]<<'\n';
}

signed main(){
    int T;
    cin>>T;
    while(T--){
        solve();
    }
    return 0; // byebye程序
}
```

---

## 作者：XZhuRen (赞：1)

简单模板题，细节较多，注意不要把 $n,m,k$ 搞混了。

---

采用 [P6822](https://www.luogu.com.cn/problem/P6822) 的套路，直接把边转化两点，考虑同点建边。

发现边之间的权值即树上 $d_{lca}$，启发直接找到所有可能值，恰为这些点的虚树。

考虑虚树上如何优化建图：

首先考虑启发式合并，每次小的连大的，大的连小的。

发现启发式合并没有意义，直接 $dfs(u)$，设集合入出点代表元 $ti_u,to_u$，每次合并的时候即先 $t_i\to to_v,ti_v\to to_u$ 连边，再建新点合并两集合。

实现是简易的，本题的思路并不难。

注意清空和 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll1;
const ll1 inf=1e15+7;
const int N=2e6+5;
const int M=2e6+5;
struct edge{int u,v,nxt;ll1 w;};
int totn=0;
namespace graph{
	edge g[M];
	int head[N],tote=0;
	void ae(int u,int v,ll1 w){
		g[++tote]=(edge){u,v,head[u],w};
		head[u]=tote;
	}
	struct pnt{
		ll1 d;
		int p;
		bool operator <(const pnt&o)const{
			return d>o.d;
		};
	};priority_queue<pnt>que;
	ll1 dis[N];
	bool vis[N];
	void dij(){
		for(int i=1;i<=totn;i++)
			dis[i]=inf,vis[i]=0;
		dis[1]=0;
		que.push((pnt){0,1});
		while(!que.empty()){
			int u=que.top().p;que.pop();
			if(vis[u])continue;
			vis[u]=1;
			for(int e=head[u],v;e;e=g[e].nxt){
				v=g[e].v;if(vis[v]||dis[v]<=dis[u]+g[e].w)continue;
				dis[v]=dis[u]+g[e].w;
				que.push((pnt){dis[v],v});
			}
		}
		return;
	}
}
int K;
namespace tr{//字典树以及并非启发式合并优化建图
	edge tr[M];
	int head[N],tote=0;
	void ae(int u,int v){
		tr[++tote]=(edge){u,v,head[u],0};
		head[u]=tote;
	}
	int dfn[N],tdfn=0;
	int dfns[18][N],d[N];
	int fa[N];
	int LOG2[N];
	void dfs1(int u,int Fa,int D){
		fa[u]=Fa,d[u]=D;
		dfn[u]=++tdfn,dfns[0][tdfn]=u;
		for(int e=head[u],v;e;e=tr[e].nxt){
			v=tr[e].v;if(v==Fa)continue;
			dfs1(v,u,D+1);
		}
	}
	int cmpr(int x,int y){return d[x]<d[y]?x:y;}
	void init(){
		tdfn=0;
		dfs1(1,0,0);
		for(int k=1;(1<<k)<=K;k++)
		for(int i=1;i+(1<<k)<=K+1;i++)
			dfns[k][i]=cmpr(dfns[k-1][i],dfns[k-1][i+(1<<(k-1))]);
		LOG2[0]=LOG2[1]=0;
		int nw=1;
		for(int i=1;i<=K;i++){
			LOG2[i]=LOG2[i-1];
			if(nw*2==i)nw*=2,LOG2[i]++;
		}
	}
	int Lca(int x,int y){
		if(x==y)return x;
		int l=dfn[x],r=dfn[y];
		if(l>r)swap(l,r);
		l++;int k=LOG2[r-l+1];
		return fa[cmpr(dfns[k][l],dfns[k][r-(1<<k)+1])];
	}
	int p[N],tp=0;
	vector<int>ins[N],ous[N];
	vector<int>sons[N];
	bool CMP(int x,int y){return dfn[x]<dfn[y];}
	void gettree(){
		int ttp=0;
		sort(p+1,p+1+tp,CMP);
		tp=unique(p+1,p+1+tp)-p-1;
		ttp=tp;
		for(int i=2;i<=ttp;i++)
			p[++tp]=Lca(p[i],p[i-1]);
		sort(p+1,p+1+tp,CMP);
		tp=unique(p+1,p+1+tp)-p-1;
		for(int i=1;i<=tp;i++){
			ins[p[i]].clear(),ous[p[i]].clear();
			sons[p[i]].clear();
		}
		for(int i=2;i<=tp;i++)
			sons[Lca(p[i],p[i-1])].emplace_back(p[i]);
	}
	int ti[N],to[N];
	void solve(int u){
		ti[u]=++totn;
		to[u]=++totn;
		for(auto x:ins[u])
			graph::ae(x,ti[u],0);
		for(auto x:ous[u])
			graph::ae(to[u],x,0);
		graph::ae(ti[u],to[u],d[u]);
		for(auto v:sons[u]){
			solve(v);
			graph::ae(ti[u],to[v],d[u]);
			graph::ae(ti[v],to[u],d[u]);
			++totn;
			graph::ae(ti[u],totn,0);
			graph::ae(ti[v],totn,0);
			ti[u]=totn;
			++totn;
			graph::ae(totn,to[u],0);
			graph::ae(totn,to[v],0);
			to[u]=totn;
		}
	}
}
int n,m;
/*
dsu on tree 优化建图，边数线性
*/
int bel[N];
#define s(x) (x+n)
#define t(x) (x+m+n)
vector<int>st[N],ed[N];//入/出边编号
void build(int x){
	tr::tp=0;
	for(auto p:st[x])tr::p[++tr::tp]=bel[p];
	for(auto p:ed[x])tr::p[++tr::tp]=bel[p];
	tr::gettree();
	for(auto p:st[x])
		tr::ous[bel[p]].emplace_back(p);
	for(auto p:ed[x])
		tr::ins[bel[p]].emplace_back(p);
	if(tr::tp)
		tr::solve(tr::p[1]);
}
void init(){
	for(int i=1,u,v,c,b;i<=m;i++){
		scanf("%d%d%d%d",&u,&v,&c,&b);
		st[u].emplace_back(s(i));
		ed[v].emplace_back(t(i));
		graph::ae(s(i),t(i),c);
		bel[s(i)]=bel[t(i)]=b;
	}
	int c;
	for(int i=1,u,v;i<K;i++){
		scanf("%d%d%d",&u,&v,&c);
		tr::ae(u,v);
	}
	tr::init();
	totn=n+m+m;
}
void work(){
	for(int i=1;i<=n;i++)build(i);
	for(auto p:st[1])graph::ae(1,p,0);
	for(int x=2;x<=n;x++){
		for(auto p:ed[x])graph::ae(p,x,0);
	}
	graph::dij();
	for(int i=2;i<=n;i++){
		printf("%lld\n",graph::dis[i]);
	}
}
void CLR(){
	memset(graph::head,0,sizeof graph::head);
	memset(tr::head,0,sizeof tr::head);
	graph::tote=tr::tote=0;
	totn=0;
	for(int i=1;i<=n;i++)
		st[i].clear(),ed[i].clear();
}
int main(){
	int T=0;
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d",&n,&m,&K);
		CLR();
		init();
		work();
	}
	return 0;
}
```

---

## 作者：JhdFarrell (赞：1)

约定：下文称所有 $c[i]$ 为边长，$d[i]$ 为边权，原图指输入中 $m$ 行所描述的图

### subtask1
***
把边当成点连边。对于两个共用同一个点的边（即一出一进）在字典树上找二者的 lca（**因为 trie 上的 lca 就是最长公共前缀**），把 lca 的深度加上两条边原来边长的和作新建的边的边长，期望得分 20pts。

### subtask2
***
考虑优化建图。
在 subtask1 中我们把所有相邻的边当作点相连，我们可以把原图上的每个点（注意是原图上的点而非边）**当作过渡的虚点**，经过它的边可以分为入边和出边，如果舍去掉题目中最长公共前缀的限制直接把所有入边连到过度点上，边长皆为 $0$ ，再把过渡点向所有出边连边，边长为出边在原图上本来的边长，这样就可以了。

考虑如何解决带公共前缀的问题。我们可以把字典树拷贝到每一个节点上，并在拷贝后的每一个节点上新建两个虚点 $f$ 和 $g$ ，分别代表由**子树内**向上连的边的集合和由**子树外**向内连的集合（不必准确理解，结合后面更好懂），规定 $g$ **已经计算过了公共前缀**， $f$ **没有**计算。$fa[i]$ 表示 $i$ 的父亲节点，$ch[i][j]$ 表示 $i$ 的第 $j$ 个子节点（在 trie 上）。

根据 $f$ 和 $g$ 的定义可知 $f[i]$ 要连向 $f[fa[i]]$，$g[i]$ 要连向 $g[ch[i][j]]$，每一个入边要连向它的权值在 trie 上的位置对应的 $f[i]$（边长为0，因为还不需要考虑公共前缀的贡献）和 $g[i]$（边长为该 trie 点的深度，即公共前缀的长度），对于每条出边，把他的权值在 trie 上对应的点的 $f$ 和 $g$ 都连向它，边长为这条边在原图上本身的边长，但是对于前者还要再**额外加上这个 trie 点的深度**才行，因为它还没算过公共前缀的贡献。到此为止，我们来模拟一下上述操作的效果。可以发现，一个入边在 trie 上要么一直顺着 $f$ 往上走，直到遇到一个出边并加上这里的深度，要么直接加上深度再一直顺着 $g$ 往下走，直到遇到出边，这是正确的。我们现在**已经可以处理所有在 trie 上祖先-后代关系的入边和出边**。换句话说，就是可以处理所有**完全覆盖关系**的公共前缀（如 "kkksc" 和 "kkksc03" ）。

如图所示，目前为止的 $f,g$ **全部都是直上直下的**，如果向上走，lca 就是**出去的点**，反之就是**进来的点**。
![](https://cdn.luogu.com.cn/upload/image_hosting/foulj9ub.png)

对于剩下的非祖先后代关系的入边出边，**他们显然需要“横跨”过他们的 lca 才能互相抵达**，体现在我们的 $f$ 和 $g$ 上，就是把 $f[ch[i][j]]$ 连向所有 $g[ch[i][k]](k\neq j)$，边长为 $i$ 的深度。为什么 $k\neq j$ 呢，我们考虑把 $f[i]$ 连向 $g[i]$ 自己的影响，显然这会导致所有的 $f[i]$ 最终**都跑到根节点**（这样深度就为 $0$，边长一定最短）然后再通过 $g$ 跑到底下任意一个节点上，这显然是错误的。另外，这也不满足“横跨”。再来模拟一遍，除了上一段中的路径外，任意一条路径中，一条入边在进入字典树后会一直顺着 $f$ 往上走，然后突然到一个拐点，拐到另一个子树中并加上当前深度再顺着 $g$ 往下走到出边。显然这个拐点就是这对入出边的 lca，所以一定正确。

下图是正确的横跨，可以发现跨点就是两个子树的 lca
![](https://cdn.luogu.com.cn/upload/image_hosting/v7hr889i.png)

下图是错误的横跨($k=j$)，图中入点和出点的lca是它们的父节点，公共前缀长1，然而我们这样连的话就只会加上它们爷节点的深度也就是0。
![](https://cdn.luogu.com.cn/upload/image_hosting/8lxe3u8b.png)

简单来说，对于祖先后代关系的一对边，他们体现在 $f$ 或 $g$ 上必须直上直下，而对于“横跨”关系的一对入出边，他们就可以先上在下，中间只在 lca 转折。但是不要忘了我们要在每个点上都拷贝一个字典树出来，所以时间还是 $O(nk)$ 的，期望得分 70pts。

**这种把在树上或图上向一个方向（祖先）流动的边归为一类互相连边，往另一方向（子树）移动的再归为一类互相连边再把二者联系起来的思路是优化建图题目中很重要的一种思想。**

### full mark
***
我们发现 subtask2 做法的瓶颈在于每个点上都要开字典树，然后每个点上都还要 dfs 一遍，这其中用到了很多冗余的字典树节点，所以我们把对一个点拷贝字典树改为对**这个点原图上相连的所有边上的所有边权建虚树**即可。

[并不怎么精简的代码](https://www.luogu.com.cn/paste/ympvc29t) 写这种码量大的题就是多分函数，把功能都分隔开，多用 vector 传递信息，多加 assert。

第一次切黑也是第一次写黑色题解，如果觉得有帮助的话可以点个赞支持一下。
***

---

## 作者：Mashu77 (赞：0)

先考虑暴力做法：将每条边拆成入点和出点，入点和出点之间连边，权值为原边权；若两条边 
$a
,
b$
 满足 
$a$
 的终点是 
$b$
 的起点，则 
$a$
 的出点与 
$b$
 的入点连边，权值为 
$a
,
b$
 的 
lcp
 长度。跑一遍 
dij
 即可。复杂度 
$O
(
m^
2
\log
m
)$。

瓶颈在边数。对点 
$i$，将所有终点为 
$i$
 的边放入集合 
$S$，将所有起点为 
$i$
 的边放入集合 
$T$。不难发现 
$S$
 与 
$T$
 之间两两取 
lcp，不同的字符串个数是 
$O
(
|
S
|
+
|
T
|
)$
 级别的。于是考虑优化建图。

权值为 
lcp
 的长度，就是字典树上 
lca
 的深度。取其欧拉序，就是区间最小值。此时用线段树或 
ST
 表优化建图已经可以做到 
$O
(
m
\log
m
)$
 条边，也就是 
$O
(
m
\log^
2
m
)$
 复杂度。更进一步，考虑欧拉序上每个点的贡献，会将其前缀所有点与后缀所有点连边。用前后缀优化建图可以做到 
$O
(
m
\log
m
)$
 复杂度。

---


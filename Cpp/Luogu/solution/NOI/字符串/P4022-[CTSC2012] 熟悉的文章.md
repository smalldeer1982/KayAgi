# [CTSC2012] 熟悉的文章

## 题目描述

阿米巴是小强的好朋友。

在小强眼中，阿米巴是一个作文成绩很高的文艺青年。为了获取考试作文的真谛，小强向阿米巴求教。阿米巴给小强展示了几篇作文，小强觉得这些文章怎么看怎么觉得熟悉，仿佛是某些范文拼拼凑凑而成的。小强不禁向阿米巴投去了疑惑的眼光，却发现阿米巴露出了一个狡黠的微笑。

为了有说服力地向阿米巴展示阿米巴的作文是多么让人觉得“眼熟”，小强想出了一个评定作文 “熟悉程度”的量化指标：$L_0$ .小强首先将作文转化成一个 $01$ 串。之后，小强搜集了各路名家的文章，同样分别转化成 $01$ 串后，整理出一个包含了 $M$ 个 $01$ 串的 “ 标准作文库 ”。

小强认为：如果一个 $01$ 串长度不少于 $L$ 且在标准作文库中的某个串里出现过（即，它是标准作文库的某个串的一个 连续子串），那么它是 “ 熟悉 ” 的。对于一篇作文（一个 $01$ 串）$A$，如果能够把 $A$ 分割成若干段子串，其中 “ 熟悉 ” 的子串的长度总和不少于 $A$ 总长度的 $90\%$，那么称 $A$ 是 “ 熟悉的文章 ”。 $L_0$ 是能够让 $A$ 成为 “ 熟悉的文章 ” 的 所有 $L$ 的最大值 （如果不存在这样的 $L$，那么规定 $L_0=0$）。

举个例子：

小强的作文库里包含了如下 $2$ 个字符串：

```cpp
10110
000001110
```
有一篇待考察的作文是：

```cpp
1011001100
```
小强计算出这篇作文 $L$ 的最大值是 $4$，因为待考察的作文可以视作 $10110+0110+0$，其中 $10110$ 和 $0110$ 被判定为 “熟悉” 的。而当 $L = 5$ 或是更大的时候，不存在符合题意的分割方法。所以，这篇作文的 $L_0 = 4$。小强认为阿米巴作文的 $L_0$ 值比其他同学的明显要大。请你帮他验证一下。


## 说明/提示

对于 $30\%$ 的测试数据，输入文件的长度不超过 $1000$ 字节。

对于 $50\%$ 的测试数据，输入文件的长度不超过 $61000$ 字节。

对于 $80\%$ 的测试数据，输入文件的长度不超过 $250000$ 字节。

对于 $100\%$ 的测试数据，输入文件的长度不超过 $1100000$ 字节。


## 样例 #1

### 输入

```
1 2
10110
000001110
1011001100```

### 输出

```
4```

# 题解

## 作者：teafrogsf (赞：16)

$60pts:$  
有一个常见的套路是：看见序列分段想$\Theta(n^2)DP+$优化。  
这题目要的是$L$的最大值，那么不影响我们$DP$的结果，可以直接二分答案。  
这个分段的$DP$也是很显然，设$dp_i$表示以i作为当前段结尾：  
$$dp_i=\max(dp_j+i-(j+1)+1,dp_{i-1}),j\in [i-maxlen_i,i-l]$$
其中，$maxlen_i$表示以$i$为结尾的字符串出现在模板串中的最长长度，这个可以用$SAM$一开始跑出来；$l$表示当前二分的答案。  
这样我们得到了（上界复杂度）$O(n^2\log n)$的算法。  
  
$100pts:$  
决策单调性很显然，因为$i-maxlen_i$一定是单调递增的。  
发现决策单调性之后，将$dp$方程改成$dp_j-j+i$，$i$显然单调递增，那么就可以维护前面这个$dp_j-j$的单调递减队列了。复杂度$O(n\log n)$。  
$P.S.$其实没有必要用广义$SAM$的，只要隔一个字符插就可以了，虽然空间貌似有那么一点儿......大？
```cpp
#include<cstdio>
#include<cstring>
#include<deque>
#define neko 2000010
#define chkmax(a,b) ((a)>(b)?(a):(b))
#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~(i)))
typedef int arr[neko];
arr link,len,dp,maxlen,q;
int n,m,nex[neko][3];
namespace SAM
{
	int slen,cnt,cur,last;
	void find(char *s)
	{
		int p=0,now=0,x;
		slen=strlen(s+1);
		f(i,1,slen)
		{
			x=s[i]-'0';
			if(nex[p][x])++now,p=nex[p][x];
			else
			{
				for(;p!=-1&&(!nex[p][x]);p=link[p]);
				if(p==-1)p=0,now=0;
				else now=len[p]+1,p=nex[p][x];
			}maxlen[i]=now;
		}
	}//this is right
	void extend(char *s)
	{
		int p,q,clone,x;
		link[0]=-1,slen=strlen(s+1);s[++slen]='2';
		f(i,1,slen)
		{
			cur=++cnt,len[cur]=len[last]+1;
			x=s[i]-'0';
			for(p=last;p!=-1&&(!nex[p][x]);p=link[p])nex[p][x]=cur;
			if(p==-1)link[cur]=0;
			else
			{
				q=nex[p][x];
				if(len[p]+1==len[q])link[cur]=q;
				else
				{
					clone=++cnt;
					len[clone]=len[p]+1;
					link[clone]=link[q];
					f(j,0,1)nex[clone][j]=nex[q][j];
					for(;p!=-1&&(nex[p][x]==q);p=link[p])nex[p][x]=clone;
					link[q]=link[cur]=clone;
				}
			}last=cur;
		}
	}
}
bool check(int l)
{
	int slen=SAM::slen,j,H=0,T=-1;
	//easily(?) to prove that it has a monotonicity of decision making
	f(i,0,l-1)dp[i]=0;
	f(i,l,slen)
	{
		dp[i]=dp[i-1];
		while(H<=T&&(dp[i-l]-(i-l))>(dp[q[T]]-q[T]))--T;
		q[++T]=i-l;
		while(H<=T&&q[H]<(i-maxlen[i]))++H;
		if(H<=T)dp[i]=chkmax(dp[i],dp[q[H]]-q[H]+i);//i-(j+1)+1
		//f(j,i-maxlen[i],i-l)if(dp[j]+(i-j)>dp[i])dp[i]=dp[j]+(i-j);//i-(maxlen[i]+1)+1
	}//f(i,1,slen)printf("%d ",dp[i]);puts("");
	return dp[slen]*10>=slen*9;
}
char s[neko];
#define mid ((l+r)>>1)
int main()
{
	using namespace SAM;
	int l,r;
	scanf("%d%d",&n,&m);
	f(i,1,m)scanf("%s",s+1),extend(s);
	f(i,1,n)
	{
		scanf("%s",s+1);
		l=1,r=strlen(s+1);
		find(s);
		while(l<=r)
		{
			//printf("%d %d %d\n",l,r,mid);
			if(check(mid))l=mid+1;
			else r=mid-1;
		}printf("%d\n",mid);
	}return 0;
}
```

---

## 作者：Kelin (赞：9)

### 题意

有多个主串,每次询问将询问串分成多个连续子串,如果一个子串长度$\ge L$且在主串中出现过就是合法的

如果合法的子串总长度$\ge$询问串长的$90\%$,这个串就是合法的字符串,求使得询问串成为合法的字符串的最大的$L$

---

### 题解

先建好广义$SAM,$发现$L$满足单调性,所以可以二分答案

考虑怎么$check$~~用dp啊~~

考虑一个暴力的$DP,f[i]$表示前$i$个字符最长合法长度,$mac_i$表示匹配到$i$的最长公共子串长度(在广义$SAM$上,求法同[$[Spoj1812]LCS2$](https://blog.csdn.net/benoble_/article/details/79641188))

$$\Rightarrow f[i]=max\{f[i-1],f[j]+i-j,j\in[i-mac_i,i-L]\}$$

可以发现$i-L$单调递增的,$i-mac_i$是单调不减的,所以可以使用单调队列优化到$O(n)$

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e6+5,M=2*N;
typedef long long ll;
typedef int arr[M];
struct SAM{
    int las,T,ch[M][2];arr fa,len;
    SAM(){las=T=1;}
    inline void ins(int c){
        int p=las,np;fa[las=np=++T]=1,len[np]=len[p]+1;
        for(;p&&!ch[p][c];p=fa[p])ch[p][c]=np;
        if(p){
            int q=ch[p][c],nq;
            if(len[p]+1==len[q])fa[np]=q;
            else{
                fa[nq=++T]=fa[q],len[nq]=len[p]+1,memcpy(ch[nq],ch[q],4*2);
                for(fa[q]=fa[np]=nq;ch[p][c]==q;p=fa[p])ch[p][c]=nq;
            }
        }
    }
    int n,mac[N],f[N],q[N];char s[N];
    inline void Match(){
    	int x=1,l=0,c;
    	fp(i,1,n){
    		c=s[i]-'0';while(x&&!ch[x][c])x=fa[x],l=len[x];
    		if(x)x=ch[x][c],++l;else x=1,l=0;mac[i]=l;
    	}
    }
    inline bool chk(int L){
    	int h=1,t=0;
    	fp(i,1,L-1)f[i]=0;
    	fp(i,L,n){f[i]=f[i-1];
    		while(h<=t&&f[q[t]]-q[t]<f[i-L]-(i-L))--t;
    		q[++t]=i-L;while(h<=t&&q[h]<i-mac[i])++h;
    		if(h<=t)cmax(f[i],f[q[h]]+i-q[h]);
    	}
    	return f[n]*10>=n*9;
    }
	inline void sol(){
		scanf("%s",s+1);n=strlen(s+1);Match();
		int L=0,R=n,ans=0,mid;
		while(L<=R){
			mid=(L+R)>>1;
			if(chk(mid))ans=mid,L=mid+1;
			else R=mid-1;
		}
		printf("%d\n",ans);
	}
}p;
int n,m;char s[N];
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%d",&n,&m);
    fp(i,1,m){
    	scanf("%s",s),p.las=1;
    	fp(j,0,strlen(s)-1)p.ins(s[j]-'0');
    }
    while(n--)p.sol();
return Ot(),0;
}

```



------------

$upd\ 19.08.11$

感谢评论区大佬指出错误，已修改。

---

## 作者：Owen_codeisking (赞：6)

老早就在我的智推里了，但一直没做……今天刚刚想到了 $dp$ 方程，突然意识到可以单调队列优化，然后就过了……

好吧，我们先建一个广义 $SAM$，然后将文章在上面匹配。我们把每次匹配到的串的长度记录下来，这就是 $dp$ 方程转移的限制。然后就是单调队列 $O(n)$ 扫了

$$f[i]=max(f[j]+i-j(j\in[i-match[i],i])$$

```cpp
int check(int L,int n){
	int head=1,tail=0;
	for(int i=1;i<=L-1;i++) f[i]=0;
	for(int i=L;i<=n;i++){
		f[i]=f[i-1];
		while(head<=tail&&f[q[tail]]-q[tail]<=f[i-L]-(i-L)) tail--;
		q[++tail]=i-L;
		while(head<=tail&&q[head]<i-match[i]) head++;
		if(head<=tail) f[i]=max(f[i],f[q[head]]+i-q[head]);
	}
	return f[n]*10>=n*9;
}
```

匹配的话就用匹配 $LCS$ 的方法

```cpp
void pre(int n){
	int p=1,c,len=0;
	for(int i=1;i<=n;i++){
		c=s[i]-'0';
		if(ch[p][c]) p=ch[p][c],len++;
		else {
			for(;p&&!ch[p][c];p=fa[p]);
			if(p) len=l[p]+1,p=ch[p][c];
			else len=0,p=1;
		}
		match[i]=len;
	}
}
```

这题就愉快的做完了

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2200000+10;
int n,m,f[maxn],match[maxn],q[maxn],last,cnt,ch[maxn][2],fa[maxn],l[maxn];
char s[maxn];

void insert(int c){
	int p=last,q=++cnt;last=q;l[q]=l[p]+1;
	for(;p&&!ch[p][c];p=fa[p]) ch[p][c]=q;
	if(!p) fa[q]=1;
	else {
		int r=ch[p][c];
		if(l[p]+1==l[r]) fa[q]=r;
		else {
			int s=++cnt;l[s]=l[p]+1;
			memcpy(ch[s],ch[r],sizeof(ch[r]));
			fa[s]=fa[r];fa[r]=fa[q]=s;
			for(;p&&ch[p][c]==r;p=fa[p]) ch[p][c]=s;
		}
	}
}

void pre(int n){
	int p=1,c,len=0;
	for(int i=1;i<=n;i++){
		c=s[i]-'0';
		if(ch[p][c]) p=ch[p][c],len++;
		else {
			for(;p&&!ch[p][c];p=fa[p]);
			if(p) len=l[p]+1,p=ch[p][c];
			else len=0,p=1;
		}
		match[i]=len;
	}
}

int check(int L,int n){
	int head=1,tail=0;
	for(int i=1;i<=L-1;i++) f[i]=0;
	for(int i=L;i<=n;i++){
		f[i]=f[i-1];
		while(head<=tail&&f[q[tail]]-q[tail]<=f[i-L]-(i-L)) tail--;
		q[++tail]=i-L;
		while(head<=tail&&q[head]<i-match[i]) head++;
		if(head<=tail) f[i]=max(f[i],f[q[head]]+i-q[head]);
	}
	return f[n]*10>=n*9;
}

int main()
{
	scanf("%d%d",&n,&m);
	int len,l,r,mid,ans;last=cnt=1;
	for(int i=1;i<=m;i++){
		scanf("%s",s+1);
		len=strlen(s+1);last=1;
		for(int j=1;j<=len;j++) insert(s[j]-'0');
	}
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		l=0,r=len=strlen(s+1),ans=0;pre(len);
		while(l<=r){
			mid=(l+r)>>1;
			if(check(mid,len)) l=mid+1,ans=mid;
			else r=mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4022) 

upd 2021.7.4：更改部分用词.
## 题意
给你 $m$ 个文本串 $T_{1,2,...,m}$，$n$ 次询问，对于一个字符串 $A$ 满足 $A=A_1A_2A_3...A_k$，其中 $\forall i\in[1,k],|A_i|\ge L$。求 $L_0=\max \{L|(\sum_{i=1}^k|A_i|[\exists j\in[1,m],A_i\text{ in substrings}(T_j)])\ge|A|\times 0.9\}$。

$\sum|A|+\sum|T_i|\le 1.1\times 10^6$。
## 思路
首先看到 $\max$ 先知道需要二分答案 $L_0$，然后考虑 $\text{check}$ 一个 $L$ 是否能够满足条件。

看到文本分段自然地想到 $\text{dp}$。

我们设 $dp_i$ 表示以 $i$ 作为当前段结尾，最长可以匹配多长的字符串，则有转移 $dp_i=\max(dp_j+i-j,dp_{i-1})(j\in[i-match_i,i-L])$，其中 $match_i$ 为以 $i$ 作为字符串结尾的字符串在文本串中能够匹配的最长长度。

然后处理 $match_i$ 可以开一个广义 $\text{SAM}$ 统计，与 [$\text{LCS}$](https://www.luogu.com.cn/problem/SP1811) 一样，这里不多讲解。

现在我们得到了一个 $O(\sum|T|+\sum|A|^2\log |A|)$ 的算法，显然不能通过。

然后我们考虑 $i$ 显然为严格递增的，于是我们可以维护 $dp_j-j$ 的单调队列然后就可以 $O(1)$ 转移了，时间复杂度降至 $O(\sum|T|+\sum|A|\log |A|)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{
	
}
const int N=2.2e6+10;
int n,m,q;
int pos[N],ansi[N];
char str[N];
struct SAM{
	struct statu{
		int len,link;
		int ch[2];
	}a[N];
	int siz,last;
	SAM(){
		a[0].len=0;
		a[0].link=-1;
		last=0;
	}
	inline void insert(int c){
		int cur=++siz;
		a[cur].len=a[last].len+1;
		int p=last;
		while(p!=-1&&!a[p].ch[c]){
			a[p].ch[c]=cur;
			p=a[p].link;
		}
		if(~p){
			int q=a[p].ch[c];
			if(a[p].len+1==a[q].len){
				a[cur].link=q;
			}else{
				int clone=++siz;
				a[clone]=a[q];
				a[clone].len=a[p].len+1;
				while(p!=-1&&a[p].ch[c]==q){
					a[p].ch[c]=clone;
					p=a[p].link;
				}
				a[q].link=a[cur].link=clone;
			}
		}else{
			a[cur].link=0;
		}
		last=cur;
	}
	inline void insert(){
		static char str[N];
		for(int k=1;k<=m;k++){
			readstr(str);
			int len=strlen(str+1);
			last=0;
			for(int i=1;i<=len;i++){
				insert(str[i]-'0');
			}
		}
	}
	inline void calc(){
		int anss=0;
		int p=1;
		for(int i=1;i<=n;i++){
			int c=str[i]-'0';
			if(a[p].ch[c]){
				anss++;
				p=a[p].ch[c];
			}else{
				while(p!=-1&&!a[p].ch[c]){
					p=a[p].link;
				}
				if(~p){
					anss=a[p].len+1;
					p=a[p].ch[c];
				}else{
					anss=0;
					p=1;
				}
			}
			ansi[i]=anss;
		}
	}
	inline bool check(int L){
		static int q[N],dp[N];
		int head=1,tail=0;
		for(int i=1;i<L;i++) dp[i]=0;
		for(int i=L;i<=n;i++){
			dp[i]=dp[i-1];
			while(head<=tail&&dp[q[tail]]-q[tail]<=dp[i-L]-i+L) tail--;
			q[++tail]=i-L;
			while(head<=tail&&q[head]<i-ansi[i]) head++;
			if(head<=tail) dp[i]=max(dp[i],dp[q[head]]+i-q[head]);
		}
		return n*0.9<=dp[n];
	}
}sam;
int main(){
	q=read(),m=read();
	sam.insert();
	while(q--){
		n=readstr(str);
		sam.calc();
		int l=0,r=n;
		while(l<=r){
			int mid=l+r>>1;
			if(sam.check(mid)) l=mid+1;
			else r=mid-1;
		}
		write(l-1);
		putc('\n');
	}
	flush();
	return 0;
}
```
再见 qwq~

---

## 作者：Alex_Wei (赞：4)

> [P4022 [CTSC2012]熟悉的文章 题目传送门](https://www.luogu.com.cn/problem/P4022)

> 题意简述：给出字典 $T_{1,2,\cdots,m}$，多次询问一个字符串 $s$ 的 $L_0$，其中 $L_0$ 表示：将 $s$ 分为若干子串，使得所有长度不小于 $l$ 且在字典 $T$ 中出现过的子串长度之和不小于 $0.9|s|$ 的 $l$ 的最大值。

节选自 [我的 SAM 做题笔记](https://www.cnblogs.com/alex-wei/p/Suffix_Automaton_Involution.html)，标号为 VIII。

---

首先这个 $L_0$ 显然具有可二分性，那我们将题目转化为给出 $l$ 求满足条件的长度最大值。设 $f_i$ 表示 $s[1:i]$ 能匹配的最大值，那么显然有 $f_i=\max(f_{i-1},\max_{j=i-pre_i}^{i-l} f_j+1)$，其中 $pre_i$ 是 $s[1:i]$ 在字典 $T$ 中的最大匹配长度。可以发现决策点单调不减（因为每向右移动一位，$pre$ 最多增加一位，所以 $i-pre_i$ 单调不减），那么单调队列就好了。

求 $pre_i$ 直接广义 SAM 即可。注意如果在插入新字符串时直接 $las=1$，是**不能判断当前状态是否已有转移并直接跳过去（而不是新建一个状态）的，因为这样会破坏原有的 SAM 的结构。**

时间复杂度 $\mathcal{O}(\sum |T_i|+\sum |s|\log \sum |s|)$。



```cpp
/*
	Powered by C++11.
	Author : Alex_Wei.
*/

#include <bits/stdc++.h>
using namespace std;

#define mcpy(x,y) memcpy(x,y,sizeof(y))

const int N=2.2e6+5;

// Suffix_Automaton
int n,m;
int cnt,las;
int fa[N],len[N],son[N][2];
void ins(int it){
	int p=las,cur=++cnt;
	len[cur]=len[las]+1,las=cur;
	while(p&&!son[p][it])son[p][it]=cur,p=fa[p];
	if(!p)return fa[cur]=1,void();
	int q=son[p][it];
	if(len[p]+1==len[q])return fa[cur]=q,void();
	int cl=++cnt;
	fa[cl]=fa[q],fa[q]=fa[cur]=cl,len[cl]=len[p]+1;
	son[cl][0]=son[q][0],son[cl][1]=son[q][1];
	while(p&&son[p][it]==q)son[p][it]=cl,p=fa[p];
} void build(char *s){
	int n=strlen(s+1); las=1;
	for(int i=1;i<=n;i++)ins(s[i]-'0');
}

int f[N],d[N],hd,tl;
char s[N];
int check(int x){
	int n=strlen(s+1),p=1,l=0,ans=0; hd=1,tl=0;
	for(int i=1;i<=n;i++){
		int it=s[i]-'0';
		while(p&&!son[p][it])p=fa[p],l=len[p];
		if(!p)p=1,l=0;
		else p=son[p][it],l++;
		if(i>=x){
			while(hd<=tl&&f[d[tl]]+(i-x-d[tl])<=f[i-x])tl--;
			d[++tl]=i-x;
		} while(hd<=tl&&d[hd]+l<i)hd++;
		if(hd<=tl)f[i]=max(f[i-1],f[d[hd]]+(i-d[hd]));
		else f[i]=f[i-1];
		ans=max(ans,f[i]);
	} return ans;
}

int main(){
	cin>>n>>m,cnt=1;
	for(int i=1;i<=m;i++)scanf("%s",s+1),build(s);
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		int n=strlen(s+1),l=0,r=n;
		while(l<r){
			int m=(l+r>>1)+1;
			if(check(m)>=n*0.9)l=m;
			else r=m-1;
		} cout<<l<<"\n";
	}
	return 0;
}
```

---

## 作者：MKCCT (赞：3)

答案显然具有单调性，可以二分答案。

考虑如何检验一个答案 $L$ 的合法性，设 $f_i$ 表示以 $i$ 为结尾的字符串最大的“熟悉”的子串长度总和，则有
$$f_i=\max_{i-l_i\le j\le i-L}\{f_j+i-j,f_{i-1}\}$$
其中 $l_i$ 表示以 $i$ 结尾的字符串在标准作文库里能匹配的最大长度。这个可以建广义 SAM 求解。具体来说，我们将文本串放在广义 SAM 上跑，在失配时跳 parent 树，并对每个位置记录终止结点的 maxlen 即可。

容易发现这个方程是一个经典的单调队列优化 DP 的形式，维护 $f_i-i$ 的单调递减队列可以做到线性。

若 $S$ 为所有模式串，$T$ 为所有文本串，则时间复杂度为 $O(|S|+|T|\log |T|)$。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=2.2e6+5;
struct exSAM{int fa,len,son[2];}t[N];
int n,m,tot=1,lst,mxl[N],f[N],ans,q[N];
char s[N];

int Inst(int x)
{
	if(t[lst].son[x]&&t[lst].len+1==t[t[lst].son[x]].len)
		return t[lst].son[x];
	int cur=++tot,clone,tmp=lst,fl=0;
	t[cur].len=t[tmp].len+1;
	for(;tmp&&!t[tmp].son[x];tmp=t[tmp].fa) t[tmp].son[x]=cur;
	if(!tmp) t[cur].fa=1;
	else
	{
		int q=t[tmp].son[x];
		if(t[tmp].len+1==t[q].len) t[cur].fa=q;
		else
		{
			if(tmp==lst) fl=1;
			t[clone=++tot]=t[q],t[clone].len=t[tmp].len+1;
			for(;tmp&&t[tmp].son[x]==q;tmp=t[tmp].fa)
				t[tmp].son[x]=clone;
			t[cur].fa=t[q].fa=clone;
		}
	}
	return fl?clone:cur;
}

void getmxl()
{
	int len=strlen(s+1),now=1,res=0;
	for(int i=1,x;i<=len;++i)
	{
		if(t[now].son[x=s[i]-'0']) ++res,now=t[now].son[x];
		else
		{
			for(;now&&!t[now].son[x];now=t[now].fa);
			if(!now) now=1,res=0;
			else res=t[now].len+1,now=t[now].son[x];
		}
		mxl[i]=res;
	}
}

bool check(int L)
{
	int len=strlen(s+1),l=1,r=0;
	q[1]=0,memset(f,0,sizeof(int[L]));
	for(int i=L;i<=len;++i)
	{
		f[i]=f[i-1];
		while(l<=r&&f[i-L]-i+L>f[q[r]]-q[r]) --r;
		q[++r]=i-L;
		while(l<=r&&q[l]<i-mxl[i]) ++l;
		if(l<=r) f[i]=max(f[i],f[q[l]]+i-q[l]);
	}
	return f[len]*10>=len*9;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,len;i<=m;++i)
	{
		scanf("%s",s+1),len=strlen(s+1),lst=1;
		for(int j=1;j<=len;++j) lst=Inst(s[j]-'0');
	}
	for(int i=1;i<=n;++i)
	{
		scanf("%s",s+1),getmxl();
		for(int l=1,r=strlen(s+1),mid;l<=r;)
			check(mid=l+r>>1)?(ans=mid,l=mid+1):(r=mid-1);
		printf("%d\n",ans);
	}
	return 0;
} 
```

---

## 作者：1saunoya (赞：3)

### 题意:

给定多个主串，每次将询问串拆分成多个连续子串，如果该子串在主串中出现，那么这段是合法的，要求一个最大的 $L$ 使得合法的长度 $\geq$ 询问串长度的 $90\%$

我们发现 $L$ 是可以二分的，我们再考虑怎么 $check$ 这个是否合法，对于一个 $L$。

我们设 $mx_i$ 为 $i$ 节点结尾最长能匹配的长度。

$F_i = \max\{F_{i-1},F_j+i-j\} \ \ i - mx_i \leq j \leq i - L$

我们发现 $i - mx_i$是非降的， $i-L$ 是严格上升的，所以可以用单调队列 + $dp$ 来判定可行性。


```cpp
// powered by c++11
// by Isaunoya
#include <bits/stdc++.h>
#define rep(i, x, y) for (register int i = (x); i <= (y); ++i)
#define Rep(i, x, y) for (register int i = (x); i >= (y); --i)
using namespace std;
using db = double;
using ll = long long;
using uint = unsigned int;
#define Tp template
using pii = pair<int, int>;
#define fir first
#define sec second
Tp<class T> void cmax(T& x, const T& y) {
  if (x < y) x = y;
}
Tp<class T> void cmin(T& x, const T& y) {
  if (x > y) x = y;
}
#define all(v) v.begin(), v.end()
#define sz(v) ((int)v.size())
#define pb emplace_back
Tp<class T> void sort(vector<T>& v) { sort(all(v)); }
Tp<class T> void reverse(vector<T>& v) { reverse(all(v)); }
Tp<class T> void unique(vector<T>& v) { sort(all(v)), v.erase(unique(all(v)), v.end()); }
const int SZ = 1 << 23 | 233;
struct FILEIN {
  char qwq[SZ], *S = qwq, *T = qwq, ch;
#ifdef __WIN64
#define GETC getchar
#else
  char GETC() { return (S == T) && (T = (S = qwq) + fread(qwq, 1, SZ, stdin), S == T) ? EOF : *S++; }
#endif
  FILEIN& operator>>(char& c) {
    while (isspace(c = GETC()))
      ;
    return *this;
  }
  FILEIN& operator>>(string& s) {
    while (isspace(ch = GETC()))
      ;
    s = ch;
    while (!isspace(ch = GETC())) s += ch;
    return *this;
  }
  Tp<class T> void read(T& x) {
    bool sign = 0;
    while ((ch = GETC()) < 48) sign ^= (ch == 45);
    x = (ch ^ 48);
    while ((ch = GETC()) > 47) x = (x << 1) + (x << 3) + (ch ^ 48);
    x = sign ? -x : x;
  }
  FILEIN& operator>>(int& x) { return read(x), *this; }
  FILEIN& operator>>(ll& x) { return read(x), *this; }
} in;
struct FILEOUT {
  const static int LIMIT = 1 << 22;
  char quq[SZ], ST[233];
  int sz, O;
  ~FILEOUT() { flush(); }
  void flush() {
    fwrite(quq, 1, O, stdout);
    fflush(stdout);
    O = 0;
  }
  FILEOUT& operator<<(char c) { return quq[O++] = c, *this; }
  FILEOUT& operator<<(string str) {
    if (O > LIMIT) flush();
    for (char c : str) quq[O++] = c;
    return *this;
  }
  Tp<class T> void write(T x) {
    if (O > LIMIT) flush();
    if (x < 0) {
      quq[O++] = 45;
      x = -x;
    }
    do {
      ST[++sz] = x % 10 ^ 48;
      x /= 10;
    } while (x);
    while (sz) quq[O++] = ST[sz--];
  }
  FILEOUT& operator<<(int x) { return write(x), *this; }
  FILEOUT& operator<<(ll x) { return write(x), *this; }
} out;

const int maxn = 2e6 + 62;
char s[maxn];

struct SAM {
  int cnt, las, ch[maxn][26], len[maxn], fa[maxn];

  SAM() { cnt = las = 1; }

  void ins(int c) {
    int p = las, np = las = ++cnt;
    len[np] = len[p] + 1;
    for (; p && !ch[p][c]; p = fa[p]) ch[p][c] = np;
    if (!p) {
      fa[np] = 1;
    } else {
      int q = ch[p][c];
      if (len[q] == len[p] + 1) {
        fa[np] = q;
      } else {
        int nq = ++cnt;
        memcpy(ch[nq], ch[q], sizeof(ch[q]));
        fa[nq] = fa[q], fa[q] = fa[np] = nq, len[nq] = len[p] + 1;
        for (; p && ch[p][c] == q; p = fa[p]) ch[p][c] = nq;
      }
    }
  }

  int mx[maxn];

  void find() {
    int L = strlen(s + 1), p = 1, mxl = 0;
    for (int i = 1; i <= L; i++) {
      int c = s[i] & 1;
      for (; p && !ch[p][c];) p = fa[p], mxl = len[p];
      if (p)
        p = ch[p][c], ++mxl;
      else
        p = 1, mxl = 0;
      mx[i] = mxl;
    }
  }

  int f[maxn], q[maxn];
  bool chk(int mid) {
    int L = strlen(s + 1), h, t;
    h = t = 0, q[++h] = 0;
    for (int i = 1; i <= mid - 1; i++) f[i] = 0;
    for (int i = mid; i <= L; i++) {
      f[i] = f[i - 1];
      while (h <= t && f[q[t]] - q[t] < f[i - mid] - (i - mid)) --t;
      q[++t] = i - mid;
      while (h <= t && q[h] < i - mx[i]) ++h;
      if (h <= t) cmax(f[i], f[q[h]] + i - q[h]);
    }
    return f[L] * 10 >= L * 9;
  }
} sam;

signed main() {
  // code begin.
  int _, n;
  scanf("%d %d" , & _ , & n) ;
  while (n--) {
    scanf("%s", s + 1);
    sam.las = 1;
    int len = strlen(s + 1);
    for (int i = 1; i <= len; i++) {
      sam.ins(s[i] & 1);
    }
  }
  while (_--) {
    scanf("%s", s + 1), sam.find();
    int l = 1, r = strlen(s + 1), ans = 0;
    while (l <= r) {
      int mid = l + r >> 1;
      if (sam.chk(mid)) {
        l = mid + 1;
        ans = mid;
      } else {
        r = mid - 1;
      }
    }
    out << ans << '\n';
  }
  return 0;
  // code end.
}
```

---

## 作者：lzyqwq (赞：2)

**[cnblogs](https://www.cnblogs.com/MnZnOIerLzy/p/18063506)**

**[我永远喜欢数据结构。](https://www.luogu.com.cn/article/2bwnvavf)**

不会 SAM，来一个大常垃圾 SA 做法。

**[题目传送门](https://www.luogu.com.cn/problem/P4022)**

> - 给出 $n$ 个文本串 $s_1\sim s_n$ 和 $m$ 个询问串 $t_1\sim t_m$。
>
> - 称一个字符串 $\text{str}$ 是“$L$ 熟悉的”，当且仅当 $|\text{str}|\ge  L$，且 $\text{str}$ 是文本串的子串，此时记 $P(\text{str},L)=1$。否则 $P(\text{str},L)=0$。
>
> - 对于每个询问串 $t_i$，求出最大的整数 $L_i$，使得将其划分为若干个子串后，所有“$L_i$ 熟悉的”子串长度之和不小于 $\dfrac{9|t_i|}{10}$。
>
> - 形式化地，记一种划分 $t_i$ 的方式为 $S=\{[l_1,r_1],\dots,[l_{|S|},r_{|S|}]\}$，满足 $\forall \,j\in[1,|S|)\cup \mathbb{Z},r_j+1=l_{j+1}-1$，且 $l_1=1,r_{|S|}=|t_i|$。记所有划分方案构成的集合为 $U$。你要找到最大的整数 $L_i$，满足 $\exists\,T\in U,\sum\limits_{j=1}^{|T|}[P(t_i[l_j,r_j],L_i)\cdot (r_j-l_j+1)]\ge \dfrac{9|t_i|}{10}$。
>
> - 记 $N=\sum\limits_{i=1}^n|s_i|,M=\sum\limits_{i=1}^m|t_i|$，满足 $N,M\le 1.1\times 10^6$。
>
> - $\text{1 s / 250 MB}$。

默认 $\mathcal{O}(n)=\mathcal{O}(m)=\mathcal{O}(N)=\mathcal{O}(M)$。字符集大小 $\mathcal{O}(|\Sigma|)=\mathcal{O}(1)$。

对于每一个询问，容易发现答案有单调性，因为若 $x$ 是合法的，则在 $x-1$ 时仍然按照这种方式划分，式子的值是不减的。所以二分答案。

对于一个已知的 $L_i$，我们可以 dp 求出上面式子的最大值然后判断是否合法。

设 $f_j$ 表示将 $t_i[1,j]$ 分成若干段，上面式子的最大值。记 $\text{mx}_j$ 表示以 $t_i[1,j]$ 为前缀的最长后缀 $\text{suf}$ 的长度，使得 $\text{suf}$ 在文本串中出现过。那么考虑枚举上一段的末尾（为 $0$ 表示这一段是开头），有：

$$f_j=\max\left\{\max\limits_{k\in[0,j-\text{mx}_j)\cup(j-L_i,j)\cup\mathbb{Z}}f_k,\max\limits_{k\in[j-\text{mx}_j,j-L_i]\cup\mathbb{Z}}f_k+j-k\right\}$$

就是去考虑这一段能否成为“$L_i$ 熟悉的”。容易发现 $f_j\ge f_{j-1}$，因为我将 $j$ 这个位置单独分一段，答案是不减的。所以前一部分的转移可以用 $f_{j-1}$ 代替。

至于后面那部分，先将 $\text{mx}_j$ 求出来。

将所有串用分隔符拼在一起形成大串 $A$ 进行后缀排序。我们记 $\text{MX}_k$ 表示 $A[1,k]$ 这个前缀最长的后缀，使得它在文本串中出现。可以发现 $\text{mx}_j$ 就等于 $t_{i,j}$ 在 $A$ 中对应位置的 $\text{MX}$ 值，因为 $A[1,k]$ 存在。因为 $A[1,k]$ 中存在 $\text{mx}_j$ 长度的后缀满足条件，且不存在更长的后缀满足条件。

进一步发现，若 $A[1,k]$ 存在长度为 $a$ 的后缀满足条件，则长度为 $a-1$ 的后缀也满足条件。因为后者是前者的子串。所以初步想法是二分 $\text{MX}_k$，然后判断是否合法。

考虑如何判断一个长度 $\text{len}$ 是否合法。若合法当且仅当 $A$ 中存在一个来自于文本串的后缀，使得它与 $A[k-\text{len}+1,|A|]$ 这个后缀的最长公共前缀长度不少于 $\text{len}$。

满足后面那个条件的后缀排名形如一段区间 $[\text{ql},\text{qr}]$，可以二分 + $\text{height}$ 数组 rmq 得到。记 $B_i=1/0$ 表示排名为 $i$ 的后缀是否来自文本串。那么判断 $B$ 数组的区间和是否为正即可，前缀和维护。

但是这样对于每个后缀做一遍时间复杂度为 $\mathcal{O}\left(n\log^2 n\right)$，无法接受。

注意到一个关键性质，$\text{MX}_k\ge \text{MX}_{k+1}-1$。因为 $A[1,k+1]$ 的那个后缀长度为 $\text{MX}_{k+1}-1$ 的前缀是 $A[1,k]$ 的后缀。

那么这样用个指针扫一下即可，指针最多递增 $\mathcal{O}(n)$ 次，所以这样时间复杂度是 $\mathcal{O}(n\log n)$。

这样我们就求出了 $\text{mx}_j$。根据上面那个性质，可以发现第二类转移区间左端点 $j-\text{mx}_j$ 是不降的。同时右端点 $j-L$ 也是不降的。那么对于这样的区间求 $f_k-k$ 最大值，单调队列维护即可。

时空复杂度均为 $\mathcal{O}(n\log n)$。可以把二分 + ST 表换成线段树上二分做到线性空间，但是常数太大无法接受。一开始一直在为空间纠结，但事实上并不卡空间。

各种卡常、指令集配合 `C++98` 艹过去了。

**[AC Link](https://www.luogu.com.cn/record/150093760)**

**[AC Code](https://www.luogu.com.cn/paste/f5faiysq)**

---

## 作者：creation_hy (赞：2)

## 前言

虽然是黑题，但是难度并不高。~~我是不是对黑题难度有什么误解~~

## 思路

设 $f[i]$ 表示当前作文匹配完前 $i$ 个字符的时候有多少字符在标准库出现过。

直接二分答案，然后 `check` 函数返回值即 `f[len] * 10 >= len * 9`。（要超过 $90\%$ 嘛）

对于每篇作文，设 $L[i]$ 表示最大的长度 $j$，满足 $s[i-j,i]$ 在标准库里出现过。（代码中的 `mxlen` 数组）

$f$ 的递推式很简单：

$f[i]=\max(f[i-1],\displaystyle\max_{j=i-x}^{i-Len[i]}(f[j]-j+i))$

（$x$ 表示当前二分的答案）

$f[i-1]$ 表示这位不匹配，然后 $f[j]-j+i$ 表示这位接在 $j$ 后面，然后 $-j+i$ 其实就是加上当前的长度。

后面接的这段字符串长度显然不能超过最大匹配 $L[i]$，所以上限是 $i-L[i]$。

然后就是 $L[]$ 怎么求？

对所有子串建广义 SAM，然后跳 parent 树就行。

$i-L[i]$ 明显单调递增（因为前一个串包含后一个串），然后 dp 式中，$f[j]-j$ 和 $i$ 没关系，剩余部分 $i$ 也是单调递增。

所以整个式子满足决策单调性，可以单调队列搞。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2.2e6 + 5;
int n, m;
struct SAM
{
    int tot, last, fa[N], len[N], t[N][2];
    int q[N], f[N], mxlen[N];
    inline SAM()
    {
        tot = last = 0;
        fa[0] = -1;
    }
    inline void insert(char c)
    {
        c ^= 48;
        int cur = ++tot;
        len[cur] = len[last] + 1;
        int p = last;
        while (~p && !t[p][c])
            t[p][c] = cur, p = fa[p];
        last = cur;
        if (!~p)
        {
            fa[cur] = 0;
            return;
        }
        int x = t[p][c];
        if (len[p] + 1 == len[x])
            fa[cur] = x;
        else
        {
            len[++tot] = len[p] + 1;
            fa[tot] = fa[x];
            t[tot][0] = t[x][0], t[tot][1] = t[x][1];
            while (~p && t[p][c] == x)
                t[p][c] = tot, p = fa[p];
            fa[x] = fa[cur] = tot;
        }
    }
    inline void match(string s)
    {
        int cur = 0, res = 0;
        for (int i = 0; i < s.size(); i++)
        {
            int c = s[i] ^ 48;
            if (t[cur][c])
                res++, cur = t[cur][c];
            else
            {
                while (~cur && !t[cur][c])
                    cur = fa[cur];
                if (!~cur)
                    res = cur = 0;
                else
                    res = len[cur] + 1, cur = t[cur][c];
            }
            mxlen[i + 1] = res;
        }
    }
    inline bool check(int x, int len)
    {
        for (int i = 0; i < x; i++)
            f[i] = 0;
        for (int i = x, h = 1, t = 0; i <= len; i++)
        {
            while (h <= t && f[i - x] - (i - x) > f[q[t]] - q[t])
                t--;
            q[++t] = i - x;
            while (h <= t && q[h] < i - mxlen[i])
                h++;
            if (h <= t)
                f[i] = max(f[i - 1], f[q[h]] + i - q[h]);
        }
        return f[len] * 10 >= len * 9;
    }
} sam;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    string s;
    for (int i = 1; i <= m; i++)
    {
        cin >> s;
        sam.last = 0;
        for (char c : s)
            sam.insert(c);
    }
    for (int i = 1; i <= n; i++)
    {
        cin >> s;
        sam.match(s);
        int l = 1, r = s.size(), len = s.size();
        while (l <= r)
        {
            int mid = l + r >> 1;
            if (sam.check(mid, len))
                l = mid + 1;
            else
                r = mid - 1;
        }
        cout << l - 1 << '\n';
    }
    return 0;
}
```

---

## 作者：Varuxn (赞：1)

## 解题思路
**SAM+二分答案+单调队列优化dp**

~~乍一看，这题挺花里胡哨，再定睛一看，就是挺花里胡哨。~~

和前面的那个[公共串](https://www.luogu.com.cn/problem/P5546)有一点相似，先把文本串压 SAM （建不建 Tire 都差不多）然后对于每一个进行一下匹配。
以 $num[i]$ 表示以第 i 个结尾的与文本串的最长公共字串的长度。

以 $f[i]$ 表示前i个字符的字串中可以匹配的最长的长度，可以得到以下式子：

$f[i]=\max (f[i-1],f[j]+i-j)$

满足条件：$(i-j \ge L)$ 并且 $s[j+1..i]$ 能够匹配。

显然，可以采用**单调队列**来优化。

```cpp 
while(head<=tail&&f[q[tail]]-q[tail]<=f[i-mid]-(i-mid))
  tail--;
``` 
根据式子，把不优于现在的解的给踢出队列。
```cpp
while(head<=tail&&q[head]<i-num[i])
  head++;
```
把超出范围的给干掉。

如果队列还有数的话，更新就好了。

## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=11e5+10;
int n,m,len,tot=1,num[N],f[N];
int tmp=1,q[N],pos[N<<1];
char s[N];
queue<int> Q;
struct SAM
{
	int fa,len;
	int ch[5];
}tre[N<<1];
struct Tire
{
	int c,fa;
	int ch[5];
}t[N<<1];
int Tire_insert(int ch,int x)//压进字典树 
{
	if(!t[x].ch[ch])
	{
		t[x].ch[ch]=++tmp;
		t[tmp].c=ch;
		t[tmp].fa=x;
	}
	return t[x].ch[ch];
}
int SAM_insert(int c,int las)//SAM基操 
{
	int p=las;
	int np=++tot;
	tre[np].len=tre[p].len+1;
	while(p&&!tre[p].ch[c])
	{
		tre[p].ch[c]=np;
		p=tre[p].fa;
	}
	if(!p)
		tre[np].fa=1;
	else
	{
		int q=tre[p].ch[c];
		if(tre[q].len==tre[p].len+1)
			tre[np].fa=q;
		else
		{
			int nq=++tot;
			tre[nq]=tre[q];
			tre[nq].len=tre[p].len+1;
			tre[q].fa=tre[np].fa=nq;
			while(p&&tre[p].ch[c]==q)
			{
				tre[p].ch[c]=nq;
				p=tre[p].fa;
			}
		}
	}
	return np;
}
void SAM_work()//字典树压入SAM 
{
	for(int i=0;i<2;i++)
		if(t[1].ch[i])
			Q.push(t[1].ch[i]);
	pos[1]=1;
	while(!Q.empty())
	{
		int x=Q.front();
		Q.pop();
		pos[x]=SAM_insert(t[x].c,pos[t[x].fa]);
		for(int i=0;i<2;i++)
			if(t[x].ch[i])
				Q.push(t[x].ch[i]);
	}
}
bool judge(int mid)//二分答案判断函数 
{
	int head=1,tail=0;
	for(int i=1;i<=len;i++)//单调队列优化dp 
	{
		f[i]=f[i-1];//开始从前一个继承，不用memset 
		if(i<mid)
			continue;
		while(head<=tail&&f[q[tail]]-q[tail]<=f[i-mid]-(i-mid))
			tail--;
		q[++tail]=i-mid;
		while(head<=tail&&q[head]<i-num[i])
			head++;
		if(head<=tail)
			f[i]=max(f[i],f[q[head]]+i-q[head]);
	}
	return f[len]*10>=len*9;
}
#undef int
int main()
{
	#define int register long long
	#define ll long long
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)//先把所有的文本串压入字典树 
	{
		scanf("%s",s+1);
		int las=1;
		len=strlen(s+1);
		for(int j=1;j<=len;j++)
			las=Tire_insert(s[j]-'0',las);
	}
	SAM_work();//把字典树的节点压入SAM 
	while(n--)
	{
		scanf("%s",s+1);
		len=strlen(s+1);
		int p=1,le=0;
		for(int i=1;i<=len;i++)
		{
			int ch=s[i]-'0';
			while(p&&!tre[p].ch[ch])//寻找与文本串的最长公共串长度 
			{
				p=tre[p].fa;
				le=tre[p].len;
			}
			if(tre[p].ch[ch])
			{
				p=tre[p].ch[ch];
				le++;
			}
			else
			{
				p=1;
				le=0;
			}
			num[i]=le;
		}
		int l=0,r=len;
		while(l<r)//二分答案判断 
		{
			int mid=(l+r+1)>>1;
			if(judge(mid))
				l=mid;
			else
				r=mid-1;
		}
		printf("%lld\n",l);
	}
	return 0;
}

```

---

## 作者：nofind (赞：1)

## [题意](https://www.luogu.com.cn/problem/P4022)

显然这个$L$是可以二分的，我们只需要判断$L$是否合法即可。

显然有一个$O(n^2)$的DP：  
设$f_i$表示当前匹配到$i$的最大匹配长度。

$f_i=max(f_j+i-(j+1)+1)\ j\in[i-match_i,i-L]$

其中的$match_i$表示前缀$i$能和文本库匹配的最长后缀长度，这显然是可以在后缀自动机上匹配求出的。

于是就可以$O(n^2logn)$做了。

发现$i-match_i$单调递增，于是可以单调队列解决。

证明：  
反证即可，如果不单调必定是如下情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/r92glrsh.png)
红线是i匹配的长度，蓝线是i+1匹配的长度，显然i能匹配更长。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2*1e6+10;
int n,m;
int match[maxn],f[maxn],q[maxn];
char s[maxn];
struct SAM
{
	int last,tot; 
	int fa[maxn],len[maxn];
	int ch[maxn][2];
	SAM(){last=tot=1;}
	inline void add(int c)
	{
		if(ch[last][c]&&len[last]+1==len[ch[last][c]]){last=ch[last][c];return;}
		int now=++tot;len[now]=len[last]+1;
		int p=last;
		while(p&&!ch[p][c])ch[p][c]=now,p=fa[p];
		if(!p){fa[now]=1;last=now;return;}
		int q=ch[p][c];bool flag=0;
		if(len[q]==len[p]+1)fa[now]=q;
		else 
		{
			if(p==last)flag=1;
			int nowq=++tot;len[nowq]=len[p]+1;
			memcpy(ch[nowq],ch[q],sizeof(ch[q]));
			fa[nowq]=fa[q],fa[q]=fa[now]=nowq;
			while(p&&ch[p][c]==q)ch[p][c]=nowq,p=fa[p];
			if(flag)last=nowq;
		}
		if(!flag)last=now;
	}
}sam;
inline void getmatch(char* s)
{
	int len=strlen(s+1),now=1,nowl=0;
	for(int i=1;i<=len;i++)
	{
		while(now&&!sam.ch[now][s[i]-'0'])now=sam.fa[now],nowl=sam.len[now];
		if(now)now=sam.ch[now][s[i]-'0'],nowl++;
		else now=1,nowl=0;
		match[i]=nowl;
	}
}
inline bool check(int mid,char* s)
{
	int l=1,r=0,len=strlen(s+1);
	for(int i=0;i<mid;i++)f[i]=0;
	for(int i=mid;i<=len;i++)
	{
		f[i]=f[i-1];
		while(l<=r&&f[q[r]]-q[r]<=f[i-mid]-(i-mid))r--;
		q[++r]=i-mid;
		while(l<=r&&q[l]<i-match[i])l++;
		if(l<=r)f[i]=max(f[i],i+f[q[l]]-q[l]);
	}
	return f[len]*10>=len*9;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		sam.last=1;
		scanf("%s",s+1);
		int len=strlen(s+1);
		for(int j=1;j<=len;j++)sam.add(s[j]-'0');
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		getmatch(s);
		int l=0,r=strlen(s+1),ans=0;
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(check(mid,s))ans=mid,l=mid+1;
			else r=mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：happybob (赞：0)

容易发现 $L$ 是可以二分的。

接着考虑二分如何 `check`。

比较容易思考的思路是 DP，设 $f_i$ 表示前 $i$ 个字符的熟悉子串最长的长度之和。设当前二分的是 $L$，那么 $f_i = \max\{f_{i-1},\max \limits_{j \in [i - maxlen_i,i-L] } f_j + (i-j)\}$。其中 $maxlen_i$ 表示以 $i$ 结尾的最长的在字符串中出现过的字符串的长度。

也就是说，我们可以枚举每一个 $j$ 进行转移，因为有 $[i - maxlen_i,i-L]$ 的限制，每个从 $j+1$ 到 $i$ 的字符串一定是在标准作文库中出现过的，转移即可。

$maxlen_i$ 可以建出 SAM 后用求最长公共子串的做法维护。

可以获得一个 $O(m n^2\log n)$ 的做法。

容易发现 DP 有决策单调性，单调队列维护即可。

---

## 作者：eastcloud (赞：0)

[更好的阅读体验](https://www.cnblogs.com/eastcloud/p/17065667.html)

### 简要题意

给定 $m$ 个模板串和 $n$ 个匹配串，如果一个字符串是一个模板串的子串且长度不小于 $L$ 则称其为“熟悉的”，对于每个匹配串，求一个最大的 $L$，满足将匹配串分割，熟悉的子串的总长度大于原串长度的 $90\%$。

### 题目分析

首先对于 $L$，如果有更大的 $L$ 满足了它也一定满足，因此我们首先对其进行二分。

由于跟子串问题相关，且有多个模板串，我们根据模板串建出广义 SAM，分割这种方式有不可在某一位置重复的特点，因此可以考虑对其进行 DP，从前缀开始考虑，一遍 DP 一遍在 SAM 上匹配，求出当前前缀最长熟悉后缀。

设 $f_i$ 表示割到 $i$ 的最大熟悉长度，$len_k$ 表示 SAM 上当前节点的最大长度，则有

$f_i=\max(f_{i-1},f_j+(i-j)),j\in [i-len_k,i-L]$

继续观察这个转移方程，由于我们是在 SAM 匹配，失败时往父节点走，$i-len_k$ 递增，成功时不变，而 $i-L$ 随 $i$ 右移，因此决策集合只会往右增长，使用单调队列维护最优决策即可。

### 代码

```cpp
// Problem: P4022 [CTSC2012]熟悉的文章
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4022
// Memory Limit: 250 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector> 
#include<queue>
#include<deque>
#define ll long long
using namespace std;
int tot=1,nex[3000001][2],le[3000001],fa[3000001];
int dp[3000001];
string s;
struct Node{
	int last,num;
};
queue<Node> q;
deque<Node> p;
void inserttrie(string s){
	int p=1,len=s.length();
	for(int i=0;i<len;i++){
		int num=s[i]-'0';
		if(!nex[p][num]) nex[p][num]=++tot;
		p=nex[p][num];
	}
}
int insertsam(int last,int num){
	int p=last,np=nex[last][num];le[np]=le[p]+1;
	p=fa[p];
	for(;p && !nex[p][num];p=fa[p]) nex[p][num]=np;
	if(!p) fa[np]=1;
	else{
		int q=nex[p][num];
		if(le[q]==le[p]+1) fa[np]=q;
		else{
			int clone=++tot;le[clone]=le[p]+1;
			for(int i=0;i<=1;i++)nex[clone][i]=(le[nex[q][i]]?nex[q][i]:0);
			for(;p && nex[p][num]==q;p=fa[p]) nex[p][num]=clone;
			fa[clone]=fa[q];fa[q]=fa[np]=clone;
		}
	}
	return np;
}
void build(){
	for(int i=0;i<=1;i++) if(nex[1][i]) q.push((Node){1,i});
	while(!q.empty()){
		int last=q.front().last,num=q.front().num;q.pop();
		int cur=insertsam(last,num);
		for(int i=0;i<=1;i++) if(nex[cur][i]) q.push((Node){cur,i});
	}
}
bool solve(string s,int ans){
	int len=s.length(),now=1,lth=0;
	while(p.size()) p.pop_back();
	for(int i=0;i<len;i++){
		dp[i+1]=dp[i];
		int num=s[i]-'0';
		while(p.size() && (i+1-ans>=0 && dp[i+1-ans]-i-1+ans>p.front().last)){
			p.pop_front();
		}
		if(i+1-ans>=0) p.push_front((Node){dp[i+1-ans]-i-1+ans,i+1-ans});
		while(!nex[now][num] && now){
			now=fa[now];
			lth=le[now];
		}
		if(!now){now=1;lth=0;continue;}
		now=nex[now][num];lth++;
		while(p.size() && i+1-lth>p.back().num) p.pop_back();
		if(p.size())dp[i+1]=max(dp[i+1],p.back().last+i+1);
	}
	double num=len*1.0/10*9;
	if(num<=dp[len]) return true;
	else return false;
}
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>s;
		inserttrie(s);
	}
	build();
	for(int i=1;i<=n;i++){
		cin>>s;
		int l=1,r=s.length();
		while(l<r){
			int mid=(l+r+1)>>1;
			if(solve(s,mid)) l=mid;
			else r=mid-1;
		}
		cout<<l<<endl;
	}
}

```


---

## 作者：FutaRimeWoawaSete (赞：0)

显然 $L$ 具有单调性，不妨二分 $L$。

考虑问题本质上是一种划分问题对收益 $\max$ 的求解，考虑 dp。

（求 $\min$ 也能做到 $O(n)$，只是不太方便）

设 $dp_i$ 表示在 $i$ 这个位置割一刀可以获得的最大收益，$mx_i$ 表示以 $i$ 为结尾左端点最小的一个 $l$ 使得 $[l,i]$ 为文章的子串。

状态转移显然是 $dp_i = \max_{j = i - mx_i} ^ {i - L}dp_j + i - j$，因为只有在 $i - L$ 之前的位置割才能有收益，但是转移的位置又不能超过 $mx_i$。

对于 $mx_i$ 可以使用广义 SAM 求解，由于是 SAM 的经典运用这里不展开。

问题转化成了对于每个数有一个转移区间 $[L_i,R_i]$ 并且 $L,R$ 随着 $i$ 的增加不减，将方程中的 $i$ 拆出来就只剩下 $j$ 相关项，问题转化成了一个裸的单调队列优化 dp，可以做到 $O(n)$。

时间复杂度 $O((\sum |S|) \log |S|)$。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1.1e6 + 5;
int n,m,mxpos[Len],dp[Len],q[Len];
struct Node
{
	int ch[2];
	int len,fa;
	Node(){len = fa = 0;memset(ch , 0 , sizeof ch);}
};
struct Suf_Auto
{
	Node t[Len << 1];
	int tot;
	Suf_Auto(){tot = 1;}
	inline int Add(int c,int lst)
	{
		if(t[lst].ch[c])
		{
			int p = lst , q = t[lst].ch[c];
			if(t[q].len == t[p].len + 1) return q;
			else
			{
				int nq = ++ tot;t[nq] = t[q];
				t[nq].len = t[p].len + 1;
				t[q].fa = nq;
				for( ; p && t[p].ch[c] == q ; p = t[p].fa) t[p].ch[c] = nq;
				return nq;	
			} 
		}
		int p = lst;
		int np = lst = ++ tot;
		t[np].len = t[p].len + 1;
		for( ; p && !t[p].ch[c] ; p = t[p].fa) t[p].ch[c] = np;
		if(!p) t[np].fa = 1;
		else
		{
			int q = t[p].ch[c];
			if(t[q].len == t[p].len + 1) t[np].fa = q;
			else
			{
				int nq = ++ tot;t[nq] = t[q];
				t[nq].len = t[p].len + 1;
				t[np].fa = t[q].fa = nq;
				for( ; p && t[p].ch[c] == q ; p = t[p].fa) t[p].ch[c] = nq;
			}
		}
		return np;
	}
	int rt,nowl;
	inline void Clr(){rt = 1 , nowl = 0;}
	inline void Find(int c,int id)
	{
		while(rt)
		{
			if(t[rt].ch[c])
			{
				nowl ++;
				rt = t[rt].ch[c];
				break;
			}
			else
			{
				rt = t[rt].fa;
				nowl = t[rt].len;
			}
		}
		if(!rt) rt = 1;
		mxpos[id] = nowl;
	}
}At;
int check(int L,int N)
{
	//printf("%d:\n",L);
	int hd = 1 , tl = 0;
	for(int i = 1 ; i <= L - 1 ; i ++) dp[i] = 0;
	for(int i = L ; i <= N ; i ++) 
	{
		dp[i] = dp[i - 1];
		while(hd <= tl && dp[q[tl]] - q[tl] <= dp[i - L] - (i - L)) tl --;
		q[++ tl] = i - L;
		while(hd <= tl && q[hd] < i - mxpos[i]) hd ++;
		if(hd <= tl) dp[i] = max(dp[i] , dp[q[hd]] - q[hd] + i);
		//printf("%d %d %d %d %d %d\n",i,dp[i],hd,tl,q[hd],i-mxpos[i]);
	}
	return dp[N] * 10 >= N * 9;
}
char s[Len];
int main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= m ; i ++) 
	{
		scanf("%s",s + 1);
		int lens = strlen(s + 1) , lst = 1;
		for(int j = 1 ; j <= lens ; j ++) lst = At.Add(s[j] - '0' , lst);
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		At.Clr();
		scanf("%s",s + 1);
		int lens = strlen(s + 1) , l = 0 , r = lens , anss = 0;
		for(int j = 1 ; j <= lens ; j ++) 
		{
			At.Find(s[j] - '0' , j);
			//printf("%d %d\n",j,mxpos[j]);
		}
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(check(mid , lens)) anss = mid , l = mid + 1;
			else r = mid - 1;
		}
		printf("%d\n",anss);
	}
	return 0;
}
```

---

## 作者：Elma_ (赞：0)

显然可以二分答案，check 的时候要求出当 $L$ 为 $\mathrm{mid}$ 时是否合法，我们可以求出 “熟悉的” 的子串的长度的最大值，然后将它和总长的 $90\%$ 比较。现在我们考虑如何来求这个最大值。

考虑 dp：设 $f_i$ 为将前 $i$ 个字符分割为若干段，其中 “熟悉的” 子串的和的最大值。可以得到如下递推式：

$$
f_i = \max(f_{i-1}, f_j + i - j), \ j \in [i - len_i, i - L] 
$$

其中 $len_i$ 表示以 $i$ 结尾的前缀的最长 “熟悉的” 后缀的长度。这个 dp 实际上包含了两种决策，即当前是否划分一个 “熟悉的” 子串。如果选择划分一个 “熟悉的” 子串，那么可以从 $f_j (j \in [i - len_i, i - L])$ 转移过来。否则我们可以直接从 $f_{i - 1}$ 转移过来，这是因为我们希望当前这个 “不熟悉的” 子串的长度越小越好，这样前面的部分更可能组成 “熟悉的” 子串，那么答案一定不会更劣（好像讲得有点感性...但意思大概能懂？）。

这个 dp 的时间复杂度是 $O(|S|^2)$ 的，$len_i$ 的值可以在广义 SAM 上跑匹配 $O(|S|)$ 求出。这样总时间复杂度为 $O(|S|^2 \log |S|)$，无法通过此题。我们还需要一些优化。

注意到，$i - len_i$ 的值一定是单调不降的，这点只需要模拟字符串在 SAM 上匹配的过程就可以得出：每次 $i$ 加 $1$ 时，要么走一条转移边（这会使得 $len$ 的值加 $1$），要么不断跳 $\mathrm{nxt}$ 边直到存在一条需要的转移（这会使得 $len$ 的值减少）。而 $i-L$ 显然单调增，于是我们用一个单调队列维护 $f_i-i$ 的最大值就干掉了。

这样每次 dp 的时间复杂度为 $O(|S|)$，总时间复杂度为 $O(|S| \log |S|)$，足以通过此题。为了代码简洁性，这里使用的是伪广义 SAM。

```cpp
const int MN = 2.2e6 + 5;

int N, M; char Str[MN];

struct SuffixAutoMaton {
    int lst, cnt, ch[MN][2], nxt[MN], len[MN];
    inline void Insert(int c) {
        int p = lst, o = ++cnt;
        len[o] = len[p] + 1;
        while (p && !ch[p][c]) ch[p][c] = o, p = nxt[p];
        if (!p) nxt[o] = 1;
        else {
            int q = ch[p][c];
            if (len[q] == len[p] + 1) nxt[o] = q;
            else {
                int cl = ++cnt;
                for (int i = 0; i < 2; i++) ch[cl][i] = ch[q][i];
                len[cl] = len[p] + 1, nxt[cl] = nxt[q], nxt[q] = nxt[o] = cl;
                while (p && ch[p][c] == q) ch[p][c] = cl, p = nxt[p];
            }
        }
        lst = o;
    } 

    int Mat[MN];
    inline void Work(int N) {
        int p = 1, w = 0;
        for (int i = 1; i <= N; i++) {
            int c = Str[i] - '0';
            if (ch[p][c]) p = ch[p][c], w++;
            else {
                while (p && !ch[p][c]) p = nxt[p];
                if (p) w = len[p] + 1, p = ch[p][c];
                else w = 0, p = 1;
            }
            Mat[i] = w;
        }
    }
    
    int f[MN], q[MN];
    inline bool Check(int N, int L) {
        int H = 1, T = 0;
        for (int i = 1; i < L; i++) f[i] = 0;
        for (int i = L; i <= N; i++) {
            f[i] = f[i - 1];
            while (H <= T && f[q[T]] - q[T] <= f[i - L] - (i - L)) T--;
            q[++T] = i - L;
            while (H <= T && q[H] < i - Mat[i]) H++;
            if (H <= T) f[i] = max(f[i], f[q[H]] + i - q[H]);
        }
        return f[N] * 10 >= N * 9;
    }
} SAM;

signed main(void) {  
    N = read(), M = read(), SAM.lst = SAM.cnt = 1;
    for (int i = 1, len; i <= M; i++) {
        scanf("%s", Str + 1), len = strlen(Str + 1), SAM.lst = 1;
        for (int j = 1; j <= len; j++) SAM.Insert(Str[j] - '0');
    }
    for (int i = 1, len; i <= N; i++) {
        scanf("%s", Str + 1);
        int l = 0, r = len = strlen(Str + 1), Ans = 0;
        SAM.Work(len);
        while (l <= r) {
            int Mid = (l + r) >> 1;
            if (SAM.Check(len, Mid)) l = Mid + 1, Ans = Mid;
            else r = Mid - 1;
        }
        printf("%lld\n", Ans);
    }
    return 0; 
}
```


---

## 作者：xtx1092515503 (赞：0)

~~没有发现决策单调性的蒟蒻用 $n\log^2n$ 的算法莽过了这题~~

首先，我们可以预处理出来对于待考察的串中每个后缀，它与所有范文的后缀的 $\operatorname{LCP}$ 的最长长度，记作 $len$ 。

这个可以通过将所有串中间插上字符后并一起后缀排序，然后从每个位置向左向右扫到第一个范文后缀，在 $O(n)$ 时间内得出。以下是求出 $len_i$ 的代码：

```cpp
for(int i=0,j=0;i<n;i++){
	j=min(j,ht[i]);
	if(id[sa[i]]>B)len[sa[i]]=max(len[sa[i]],j);
	if(id[sa[i]]&&id[sa[i]]<=B)j=n;
}
for(int i=n-1,j=0;i>=0;i--){
	if(id[sa[i]]>B)len[sa[i]]=max(len[sa[i]],j);
	if(id[sa[i]]&&id[sa[i]]<=B)j=n;
	j=min(j,ht[i]);
}
```
其中，$id_i$ 是原串中每个后缀原本属于哪个串，$id_i>B$ 就意味着来自于待考察串，而 $1\leq id_i\leq B$ 则意为着来自范文串。

求出 $len_i$ 后，我们便可以求出每个考察串的 $L$ 了。显然，它具有单调性，于是可以二分。

那么这个二分如何check呢？我们考虑使用DP。

我们设 $f_i$ 表示以 $i-1$ 位置的字符结尾的前缀的串中，最多有多少个位置能够被判定为出现过。

我们发现，对于每个位置，都有一组范文串的备选集合。更准确地说，对于每个位置 $i$，如果 $len_i\geq L$，则区间 $[i+L,i+len_i]$ 中所有位置都能接受到来自 $i$ 开头的串。设 $j$ 是该区间中的一个位置，则 $f_j$ 可以由 $f_i+j-i$ 转移过来。

显然这个 $i+len_i$ 应该是**单调不减**的，因为如果 $[i,i+len_i]$ 已经是一个合法串了，那么 $[i+1,i+len_i]$ 就必然是一个合法串（它是前一个式子的子串）。这就可以用单调队列做到 $O(n)$ DP。但是我没有意识到这一点，然后敲了个优先队列莽过去了。具体来说，把每个合法串的贡献以及它结束的位置丢入优先队列，要求值的时候只要堆顶元素所代表的串已经结束了就不断 ```pop```。最后从堆顶元素转移即可。

以下是勉强卡过的代码（不保证再次提交仍可通过）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2301000;
int A,B,n,m,id[N],len[N],st[N],ed[N],f[N];
int x[N],y[N],buc[N],sa[N],ht[N],rk[N],s[N];
char str[N];
bool mat(int a,int b,int k){
	if(y[a]!=y[b])return false;
	if((a+k<n)^(b+k<n))return false;
	if((a+k<n)&&(b+k<n))return y[a+k]==y[b+k];
	return true;
}
void SA(){
	for(int i=0;i<n;i++)buc[x[i]=s[i]]++;
	for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
	for(int i=n-1;i>=0;i--)sa[--buc[x[i]]]=i;
	for(int k=1;k<n;k<<=1){
		int num=0;
		for(int i=n-k;i<n;i++)y[num++]=i;
		for(int i=0;i<n;i++)if(sa[i]>=k)y[num++]=sa[i]-k;
		for(int i=0;i<=m;i++)buc[i]=0;
		for(int i=0;i<n;i++)buc[x[y[i]]]++;
		for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
		for(int i=n-1;i>=0;i--)sa[--buc[x[y[i]]]]=y[i];
		swap(x,y);
		x[sa[0]]=num=0;
		for(int i=1;i<n;i++)x[sa[i]]=mat(sa[i],sa[i-1],k)?num:++num;
		if(num>=n-1)break;
		m=num;
	}
	for(int i=0;i<n;i++)rk[sa[i]]=i;
	for(int i=0,k=0;i<n;i++){
		if(!rk[i])continue;
		if(k)k--;
		int j=sa[rk[i]-1];
		while(i+k<n&&j+k<n&&s[i+k]==s[j+k])k++;
		ht[rk[i]]=k;
	}
}
struct node{
	int vl,ed;
	friend bool operator <(const node &x,const node &y){
		return x.vl<y.vl;
	}
	node(int x,int y){vl=x,ed=y;}
};
priority_queue<node>q;
bool che(int id,int ip){
	while(!q.empty())q.pop();
	f[st[id]-1]=0;
	for(int i=st[id];i<=ed[id];i++){
		f[i]=f[i-1];
		if(!(i-ip<st[id]||len[i-ip]<ip)){
			node x=node(f[i-ip]-(i-ip),i-ip+len[i-ip]);
			if(q.empty()||!(x.vl<=q.top().vl&&x.ed<=q.top().ed))q.push(x);
		}
		while(!q.empty()&&q.top().ed<i)q.pop();
		if(!q.empty())f[i]=max(f[i],i+q.top().vl);
	}
	return f[ed[id]]>=((ed[id]-st[id]+1)*9)/10;
}
void print(int x){
	if(x>9)print(x/10);
	putchar('0'+x%10);
} 
int main(){
	scanf("%d%d",&A,&B);
	for(int i=1;i<=A+B;i++){
		scanf("%s",str),m=strlen(str);
		st[i]=n;
		for(int j=0;j<m;j++)id[n]=i,s[n]=str[j]-'0'+1,n++;
		ed[i]=n;
		s[n++]=i+2;
	}
	m=A+B+2;
	SA();
	for(int i=0,j=0;i<n;i++){
		j=min(j,ht[i]);
		if(id[sa[i]]>B)len[sa[i]]=max(len[sa[i]],j);
		if(id[sa[i]]&&id[sa[i]]<=B)j=n;
	}
	for(int i=n-1,j=0;i>=0;i--){
		if(id[sa[i]]>B)len[sa[i]]=max(len[sa[i]],j);
		if(id[sa[i]]&&id[sa[i]]<=B)j=n;
		j=min(j,ht[i]);
	}
	for(int i=B+1;i<=A+B;i++){
		int l=0,r=ed[i]-st[i];
		while(l<r){
			int mid=(l+r+1)>>1;
			if(che(i,mid))l=mid;
			else r=mid-1;
		}
		print(l),putchar('\n');
	}
//	for(int i=0;i<n;i++)printf("%d ",s[i]);puts("");
//	for(int i=0;i<n;i++)printf("%d ",len[i]);puts("");
	return 0;
}
```


---

## 作者：_ctz (赞：0)

[$\tt{My\ blog}$](https://ctz45562.github.io/2019/04/26/%E6%B4%9B%E8%B0%B7-P4022-CTSC2012-%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0/)

[传送门](https://www.luogu.org/problemnew/show/P4022)

> 妈妈我能独立切CTSC黑题啦！~~（虽然我承认这题不算难）~~

以下，用$S(l,r)$表示字符串$S$从$l$位置开始到$r$的子串，$n$表示待考察作文串的长度。


答案很明显有单调性。因为若长度$i$可行的话，则存在和长度$i$相同的方案使所有$j(<i)$也可行。

考虑二分答案。设$rr[i]$表示最大的满足$S(i,rr[i])$为作文库子串的位置。

把所有作文库的串用特殊字符隔开造$SAM$，枚举每个位置匹配预处理$rr[i]$。

容易发现$rr[i]$的一个性质：$rr[i]\ge rr[i-1]$。这样处理$rr[i]$时就可以用上$rr[i-1]$和它结束的节点继续匹配。

这里就有一个问题：以匹配$S(i-1,rr[i-1])$和$S(i,rr[i-1])$到达的节点可能不同，但若不同则一定是$parent\ tree$上的父子关系。记$node$为$i-1$匹配结束的节点，处理第$i$位时，就需要判断一下$S(i,rr[i-1])$的长度和$len[fa[node]]$的关系，选择是否向上跳。$rr[i]$就能$O(n)$预处理了。

对于当前答案$mid$是否可行，可以用$DP$求解。设$f(i)$表示对串$S(i,n)$进行分段，最少有多少个字符是“不熟悉”的。

方程：$f(i)=\min\{f(i+1)+1,f(j)\}(i+mid\le j\le rr[i]+1)$

也就是把第$i$个字符归为“不熟悉”的子串里，或者以第$i$个字符开头划分一段子串。$f(j)$可以用单调队列优化，复杂度为$O(n)$，总复杂度$O(n\log n)$

若$f(1)\le \frac{n}{10}$则答案可行。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 1100005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
#define son(x,y) son[x][y]
int son[maxn][3],fa[maxn],len[maxn],rr[maxn],f[maxn],last=1,cnt=1,n;
char s[maxn];
struct MonoQueue{
	int line[maxn],head,tail;
	inline void push(int x){
		while(head<=tail&&f[line[tail]]>=f[x])--tail;
		line[++tail]=x;
	}
	inline void check(int x){
		while(head<=tail&&line[head]>x)++head;
	}
	inline void clear(){
		head=1,tail=0;
	}
	inline int front(){
		if(head<=tail)return f[line[head]];
		return inf;
	}
}q;//手写单调队列
void insert(int c){
	int p=last,ne=last=++cnt;
	while(p&&!son(p,c))son(p,c)=ne,p=fa[p];
	if(!p)fa[ne]=1;
	else {
		int q=son(p,c);
		if(len[q]==len[p]+1)fa[ne]=q;
		else {
			int sp=++cnt;
			son(sp,0)=son(q,0),son(sp,1)=son(q,1),son(sp,2)=son(q,2);
			fa[sp]=fa[q],len[sp]=len[p]+1;
			fa[q]=fa[ne]=sp;
			while(p&&son(p,c)==q)son(p,c)=sp,p=fa[p];
		}
	}
}
void work_rr(){
	int node=1,l=0;
	for(register int i=1;i<=n;++i){
		if(l)--l;
		if(node!=1&&len[fa[node]]>=l)node=fa[node];
		while(i+l<=n&&son(node,s[i+l]-'0'))node=son(node,s[i+l]-'0'),++l;
		rr[i]=i+l-1;
	}
}
bool check(int l){
	q.clear(),f[n+1]=0;
	for(register int i=n;i;--i){
		if(i+l<=n+1)q.push(i+l);
		q.check(rr[i]+1);
		f[i]=min(f[i+1]+1,q.front());
	}
	return f[1]<=n/10;
}
int main(){
	int N=read(),M=read(),l,r,mid;
	for(register int i=1;i<=M;++i){
		scanf("%s",s+1),n=strlen(s+1);
		for(register int j=1;j<=n;++j)insert(s[j]-'0');
		if(i!=M)insert(2);//特殊字符
	}
	while(N--){
		scanf("%s",s+1),n=strlen(s+1);
		work_rr();
		l=0,r=n;
		while(l<r){
			mid=l+r+1>>1;
			if(check(mid))l=mid;
			else r=mid-1;
		}
		printf("%d\n",l);
	}
}

```



---

## 作者：guapisolo (赞：0)

感觉这道题挺神的

[~~蒟蒻的博客(逃)~~](https://www.cnblogs.com/guapisolo/p/10120443.html)

考虑$L$的性质，发现$L$越大，“眼熟的子串”总长度越长

可以这样简单证明，长度越小的串，对于匹配越有利，因为如果一个大串出现在了模式串中，那么它的所有子串一定出现在了模式串中，反之，小串出现在模式串中，几个小串组成的大串却不一定出现在模式串中。

发现了这个性质，我们可以就二分$L$了

每次选择一个长度$L$作为每次拆分出的串的长度下限进行验证

定义$f[i]$表示拆分串$S[1,i]$，拆分出的一些串能在模式串中被识别，这些能被识别的串的最长长度

要么第i位单独被拆出来，并且不被识别，$f[i]=f[i-1]$

要么第i位作为末尾，组成一个能被识别的串，必须保证开头的前一位$j\in[1,i-L]$,$f[i]=f[j]+i-j$

发现$f[i]=f[j]+i-j=(f[j]-j)+i$可以用单调队列优化

能被识别的串长度必须不小于$L$！

预处理，对所有模式串建广义$SAM$

每次把当前文本串放进去跑，预处理出以i为结尾的最长可识别串的长度$ma_{i}$

如果当前节点没有$trs[x][c]$，就要像$fail$树一样不断跳$pre$删掉一部分前缀，直到碰到一个节点有$trs[x][c]$

如果当前节点有$trs[x][c]$，说明能跳过去。

但现在我们先不能跳过去，因为$trs[x][c]$的信息我们还不知道

现在$dep_{x}$表示的并非当前串的长度，而是在$trs$图里表现的最长长度，由于每次沿$trs$指针移动，长度+1，所以$ma_{i}=min(ma_{i-1}+1,dep[x]+1)$

细节比较多，尤其是单调队列的地方

```c++
#include <cmath>
#include <vector>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N1 1105000
#define S1 (N1<<1)
#define T1 (N1<<2)
#define ll long long
#define uint unsigned int
#define rint register int 
#define dd double
#define il inline 
#define inf 0x3f3f3f3f
#define idx(X) (X-'0')
using namespace std;

int gint()
{
    int ret=0,fh=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')fh=-1;c=getchar();}
    while(c>='0'&&c<='9'){ret=ret*10+c-'0';c=getchar();}
    return ret*fh;
}
int N,M,len;
/*struct Edge{
int head[S1],to[S1],nxt[S1],cte;
void ae(int u,int v){
    cte++;to[cte]=v,nxt[cte]=head[u],head[u]=cte;}
}E;*/
char str[N1];
int ma[N1];
namespace SAM{
int trs[S1][2],pre[S1],dep[S1],tot,la;
void init(){tot=la=1;}
void reduct(){la=1;}
void insert(int c)
{
    int p=la,np=++tot,q,nq;la=np;
    dep[np]=dep[p]+1;
    for(;p&&!trs[p][c];p=pre[p]) trs[p][c]=np;
    if(!p) {pre[np]=1;return;}
    q=trs[p][c];
    if(dep[q]==dep[p]+1) pre[np]=q;
    else{
        pre[nq=++tot]=pre[q];
        pre[q]=pre[np]=nq;
        dep[nq]=dep[p]+1;
        memcpy(trs[nq],trs[q],sizeof(trs[q]));
        for(;p&&trs[p][c]==q;p=pre[p]) trs[p][c]=nq;
    }
}
void get_ma()
{
    int x=1,c;
    for(int i=1;i<=len;i++)
    {
        c=idx(str[i]);
        for(;x&&!trs[x][c];x=pre[x]);
        if(!x){ma[i]=0,x=1;continue;}
        ma[i]=min(ma[i-1]+1,dep[x]+1);
        x=trs[x][c];
    }
}
};
int que[N1],f[N1];
int check(int L)
{
    int i,j,hd=1,tl=0;
    que[++tl]=0;
    for(i=1;i<L;i++) f[i]=0;
    for(i=max(1,L);i<=len;i++)
    {
        j=i-L;
        while(hd<=tl&&f[que[tl]]-que[tl]<=f[j]-j) tl--;
        que[++tl]=j;
        while(hd<=tl&&que[hd]<i-ma[i]) hd++;
        if(hd>tl) f[i]=f[i-1];
        else f[i]=max(f[i-1],f[que[hd]]+i-que[hd]);
    }
    if(10*f[len]>=9*len) return 1;
    else return 0;
}

int main()
{
    scanf("%d%d",&N,&M);
    int i,j,l,r,n,m,mid,mxl=0,ans;
    SAM::init();
    for(m=1;m<=M;m++)
    {
        scanf("%s",str+1);
        len=strlen(str+1);
        mxl=max(mxl,len);
        for(i=1;i<=len;i++) 
            SAM::insert(idx(str[i]));
        SAM::reduct();
    }
    for(n=1;n<=N;n++)
    {
        scanf("%s",str+1);
        len=strlen(str+1);
        SAM::get_ma();
        l=0,r=min(len,mxl),ans=0;
        while(l<=r){
            mid=(l+r)>>1;
            if(check(mid)) ans=mid,l=mid+1;
            else r=mid-1;
        }
        printf("%d\n",ans);
    }
    return 0;
}

```

---


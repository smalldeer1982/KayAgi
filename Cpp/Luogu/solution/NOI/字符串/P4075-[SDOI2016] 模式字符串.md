# [SDOI2016] 模式字符串

## 题目描述

给出 $n$ 个结点的树 $T$，其中每一个结点上有一个字符，这里我们所说的字符只考虑大写字母 A 到 Z，再给出长度为 $m$ 的模式串 $S$，其中每一位仍然是 A 到 Z 的大写字母。

Alice 希望知道，有多少对结点 $(u,v)$ 满足 $T$ 上从 $u$ 到 $v$ 的最短路径形成的字符串可以由模式串 $S$ 重复若干次得到l。

这里结点对 $(u,v)$ 是有序的，也就是说 $(u,v)$ 和 $(v,u)$ 需要被区分。

所谓模式串的重复，是将若干个模式串 $s$ 依次相接（不能重叠)。例如当 $S=$ `PLUS`的时候，重复两次会得到 `PLUSPLUS`，重复三次会得到 `PLUSPLUSPLUS`，同时要注意，重复必须是整数次的。例如当 $S= $ `XYXY` 时，因为必须重复整数次，所以 `XYXYXY` 不能看作是 $S$ 重复若干次得到的。

## 说明/提示

$1\leq C\leq 10$，$3\leq \sum N\leq 10^6$，$3\leq \sum M\leq 10^6$。


## 样例 #1

### 输入

```
1
11 4
IODSSDSOIOI
1 2
2 3
3 4
1 5
5 6
6 7
3 8
8 9
6 10
10 11
SDOI```

### 输出

```
5```

# 题解

## 作者：cmd2001 (赞：10)

这种关于树上路径的题，我们没什么好办法，只好点分治。

考虑当前分治重心为root，如何统计经过分治重心的路径的答案。

我们令prf[i]表示某个点到root的路径(不含root)已经循环匹配S的前缀到位置i(下标从1开始到m-1，结尾为0)的方案数，suf[i]表示某个点到root的路径(不含root)已经循环匹配S的后缀到位置i(下标从1开始到m-1，结尾为0)的方案数。

对于每一个点，考虑当前这个点到root的路径(不含root)加上root作为前缀或者后缀，能和root的其他子树组成的方案数。

那么我们找到当前的匹配长度，读取一下prf和suf在root的其他子树中的前缀和就好了。(像这种维护二元组数量不算自身对自身的有一个套路，就是让自身和前面的和去计算贡献，这样能保证，每组被计算且仅计算一遍)

因为我们要实现在一个串的前面追加一个字符串并查询字符串是否相等，所以要用到哈希(因为这个相等关系不满足单调性)。

显然这种做法的时间复杂度是不对的(1e6十组数据大概就是卡点分治的)，然而因为全世界都只有前三组数据，所以就AC了。

代码:

```cpp
#pragma GCC optimize(2)
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype>
#include<iostream>
#define debug cerr
using namespace std;
typedef unsigned long long int ulli;
using std::max;using std::reverse;
const int maxn=1e6+1e2;
const ulli base = 31;
const int inf=0x3f3f3f3f;

char in[maxn],tar[maxn]; // input string and target string .
ulli pows[maxn],hpr[maxn],hsu[maxn]; // hash prefix and hash suffix .
int s[maxn],t[maxn<<1],nxt[maxn<<1],ban[maxn],cnt;
int dep[maxn],siz[maxn],mxs[maxn],prf[maxn],suf[maxn],sprf[maxn],ssuf[maxn]; // mxs[0] = inf  , paired prf[length] .
int n,m;
ulli ans;

bool vis[maxn];

inline void addedge(int from,int to) {
    t[++cnt] = to , nxt[cnt] = s[from] ,s[from] = cnt;
}
inline void findroot(int pos,const int &fa,const int &fs,int &rt) {
    siz[pos] = 1 , mxs[pos] = 0;
    for(int at=s[pos];at;at=nxt[at]) if( t[at] != fa && !ban[t[at]] ) {
        findroot(t[at],pos,fs,rt) , siz[pos] += siz[t[at]] , mxs[pos] = max( mxs[pos] , siz[t[at]] );
    }
    if( ( mxs[pos] = max( mxs[pos] , fs - siz[pos] ) ) <= mxs[rt] ) rt = pos;
}
inline void dfs(int pos,int fa,int dep,int &mxd,const char &mid,ulli h) {
    mxd = max( mxd , dep ) , h += in[pos] * pows[dep-1]; // add in[pos] to first char .
    if( h == hpr[dep] ) {
        ++prf[dep%m];
        if( mid == tar[dep%m+1] ) ans += ssuf[m-dep%m-1];
    }
    if( h == hsu[dep] ) {
        ++suf[dep%m];
        if( mid == tar[m-dep%m] ) ans += sprf[m-dep%m-1];
    }
    for(int at=s[pos];at;at=nxt[at]) if( t[at] != fa && !ban[t[at]] ) dfs(t[at],pos,dep+1,mxd,mid,h);
}
inline void solve(int pos,int fs) {
    if( fs < m ) return;
    int rt = 0 , full = 0;
    *mxs = inf , findroot(pos,-1,fs,rt) , ban[rt] = 1;
    if( in[rt] == tar[1] ) ++sprf[0];
    if( in[rt] == tar[m] ) ++ssuf[0];
    for(int at=s[rt],mxd;at;at=nxt[at]) if( !ban[t[at]] ) {
        mxd = 0 , dfs(t[at],rt,1,mxd,in[rt],0) , full = max( full , mxd );
        for(int i=0;i<=mxd;i++) sprf[i] += prf[i] , ssuf[i] += suf[i] , prf[i] = suf[i] = 0;
    }
    for(int i=0;i<=full;i++) sprf[i] = ssuf[i] = 0;
    for(int at=s[rt];at;at=nxt[at]) if( !ban[t[at]] ) solve(t[at],siz[t[at]]<siz[rt]?siz[t[at]]:fs-siz[rt]);
}

inline char nextchar() {
    static const int BS = 1 << 21;
    static char buf[BS],*st=buf+BS,*ed=buf+BS;
    if( st == ed ) ed = buf + fread(st=buf,1,BS,stdin);
    return st == ed ? -1 : *st++;
}
inline int getint() {
    int ret = 0 , ch;
    while( !isdigit(ch=nextchar()) );
    do ret = ret * 10 + ch - '0'; while( isdigit(ch=nextchar()) );
    return ret;
}
inline void getstr(char* s) {
    char ch;
    while( !isalpha(ch=nextchar()) );
    do *s++ = ch; while( isalpha(ch=nextchar()) );
}
inline void gethsh(ulli* dst) {
    for(int i=m+1;i<=n;i++) tar[i] = tar[i-m];
    for(int i=1;i<=n;i++) dst[i] = dst[i-1] * base + tar[i];
}
inline void fix(char* s,int len) {
    for(int i=1;i<=len;i++) s[i] -= 'A' - 1;
}
inline void solve_case() {
    n = getint() , m = getint() , getstr(in+1) , fix(in,n) , memset(s,0,sizeof(s)) , memset(ban,0,sizeof(ban)) , cnt = ans = 0 , *pows = 1;
    for(int i=1;i<=n;i++) pows[i] = pows[i-1] * base;
    for(int i=1,a,b;i<n;i++) a = getint() , b = getint() , addedge(a,b) , addedge(b,a);
    getstr(tar+1) , fix(tar,m) , gethsh(hpr) , reverse(tar+1,tar+1+m) , gethsh(hsu) , reverse(tar+1,tar+1+m);
    solve(1,n) , printf("%llu\n",ans);
}

int main() {
    static int T;
    T = getint();
    while(T--) solve_case();
    return 0;
}

```

---

## 作者：5k_sync_closer (赞：6)

能字符串哈希为什么要写高科技啊。

点分治之，考虑一个子树 $V$ 的贡献。

考虑如何判断 $i\in V$ 到分治中心 $u$ 的路径能否成为“$S$ 的重复”的前缀 / 后缀。

先序遍历 $V$，动态地维护 $u$ 到当前遍历到的点 $i$ 的路径形成的字符串 $T$，

进入一个点相当于在 $T$ 后添加一个字符，而退出一个点相当于在 $T$ 后删除一个字符。

以后缀为例，维护 $F_i$ 表示当前 $T[1\dots i]$ 能否成为“$S$ 的重复”的后缀（$F_0=1$），则

$$
F_i=\begin{cases}[T[1\dots i]=S[m-i+1\dots m]]&i<m\\ [F_{i-m}=1\bigwedge T[i-m+1\dots i]=S]&i\ge m\end{cases}
$$

先序遍历到 $i$ 后转移当前 $S$ 的哈希值和 $F_{d_i}$，记录此时的 $F_{d_i}$ 表示 $i$ 到 $u$ 的路径能否成为“$S$ 的重复”的后缀。

然后套路地记录 $C_{0/1,i}$ 表示长度为 $i$ 的能成为“$S$ 的重复”的前缀 / 后缀的路径数量，

处理 $V$ 子树时对其中每条长度为 $j$ 的能成为“$S$ 的重复”的前缀 / 后缀的路径，其贡献为 $C_{1/0,(m+1-j\bmod m)\bmod m}$。

（对前缀找后缀，对后缀找前缀）

然后把 $V$ 的信息合并进 $C$ 即可。

```cpp
#include <cstdio>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
struct E
{
    int v, t;
} e[2000050];
__gnu_pbds::gp_hash_table<int, int> C[2];
char a[1000050], o[1000050];
bool b[1000050], F[1000050][2], W[1000050][2];
unsigned long long q, P[1000050], H[1000050], Z[1000050][2];
int T, n, m, c, l, R, s[1000050], p[1000050], d[1000050], D[1000050], h[1000050];
void A(int u, int v)
{
    e[++c] = {v, h[u]};
    h[u] = c;
}
void X(int u, int k, int t)
{
    s[u] = 1;
    p[u] = 0;
    for (int i = h[u], v; i; i = e[i].t)
        if (!b[v = e[i].v] && v != k)
            X(v, u, t), s[u] += s[v], p[u] = max(p[u], s[v]);
    if (p[R] > (p[u] = max(p[u], t - s[u])))
        R = u;
}
void Y(int u, int k)
{
    H[d[D[l++] = u]] = H[d[u] - 1] * 233 + a[u];
    if (d[u] >= m)
        W[u][0] = F[d[u]][0] = F[d[u] - m][0] & H[d[u]] - H[d[u] - m] * P[m] == Z[m][0],
        W[u][1] = F[d[u]][1] = F[d[u] - m][1] & H[d[u]] - H[d[u] - m] * P[m] == Z[m][1];
    else
        W[u][0] = F[d[u]][0] = H[d[u]] == Z[m][0] - Z[m - d[u]][0] * P[d[u]],
        W[u][1] = F[d[u]][1] = H[d[u]] == Z[m][1] - Z[m - d[u]][1] * P[d[u]];
    for (int i = h[u], v; i; i = e[i].t)
        if (!b[v = e[i].v] && v != k)
            d[v] = d[u] + 1, Y(v, u);
}
void Q(int u, int k)
{
    H[1] = a[u];
    W[u][0] = F[1][0] = C[0][1] = a[u] == o[b[u] = 1];
    W[u][1] = F[1][1] = C[1][1] = a[u] == o[m];
    for (int i = h[u], v; i; i = e[i].t)
        if (!b[v = e[i].v] && v != k)
        {
            d[v] = 2;
            Y(v, u);
            for (int j = 0; j < l; ++j)
                q += W[D[j]][0] * C[1][(m + 1 - d[D[j]] % m) % m] + W[D[j]][1] * C[0][(m + 1 - d[D[j]] % m) % m];
            for (int j = 0; j < l; ++j)
                C[0][d[D[j]] % m] += W[D[j]][0], C[1][d[D[j]] % m] += W[D[j]][1];
            l = 0;
        }
    C[0].clear();
    C[1].clear();
    for (int i = h[u], v; i; i = e[i].t)
        if (!b[v = e[i].v] && v != k)
            R = 0, X(v, u, s[v]), Q(R, u);
}
int main()
{
    p[0] = 1e9;
    F[0][0] = F[0][1] = 1;
    for (int i = P[0] = 1; i <= 1e6; ++i)
        P[i] = P[i - 1] * 233;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d%s", &n, &m, a + 1);
        for (int i = 1, u, v; i < n; ++i)
            scanf("%d%d", &u, &v), A(u, v), A(v, u);
        scanf("%s", o + 1);
        for (int i = 1; i <= m; ++i)
            Z[i][0] = Z[i - 1][0] * 233 + o[m - i + 1], Z[i][1] = Z[i - 1][1] * 233 + o[i];
        R = 0;
        X(1, 0, n);
        Q(R, 0);
        printf("%llu\n", q);
        c = q = 0;
        for (int i = 1; i <= n; ++i)
            h[i] = b[i] = 0;
    }
    return 0;
}
```


---

## 作者：_ctz (赞：4)

[$My\ blog$](https://ctz45562.github.io/2020/06/10/%E6%B4%9B%E8%B0%B7-P4075-SDOI2016-%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/)

[传送门](https://www.luogu.com.cn/problem/P4075)

题解里都是哈希，我这个大常数SAM+kmp就显得很另类（

考虑点分治时如何把两条路径拼起来。用$[P_i]$表示前缀，$[S_i]$表示后缀，$a[S]$表示$a$个$S$相连（$a\in\mathbb{Z}$），一定是形如$a[S]+[P_i]$和$[S_{i+1}]+b[S]$的两条半路径拼成的路径符合要求：

$T_x$表示分治中心到点$x$的路径形成的字符串。如果$T_x$形如$[S_{i+1}]+b[S]$，则用$sl_x$表示$S_{i+1}$的长度。

对$S$串建$SAM$，并把$S$代表的节点（最后插入的字符新建的节点）及其$parent\ tree$上的祖先都打上标记。如果把$T_x$在$SAM$上跑一遍走到了有标记的节点，则$T_x$为$S$的一个后缀，$sl_x=deep_x$。

解决了后缀的问题，只要找出$[S]$即可。$kmp$匹配一下就行。如果$T_x$正好匹配$S$，则$sl_x=sl_y$（$y$为$x$的$m$级祖先）。

而$a[S]+[P_i]$就把$S$反过来做一遍。开个$sl$的桶统计答案就做完了。

复杂度$O(n\log n)$，成功挤进了最优解最后一页。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 1000005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
char s[2][maxn],t[maxn],a[maxn];
int m;
struct SAM{
#define son(x,y) son[x][y]
	int son[maxn<<1][26],fa[maxn<<1],len[maxn<<1],cnt,last;
	bool en[maxn<<1];
	void clear(){
		for(register int i=1;i<=cnt;++i)memset(son[i],0,sizeof son[i]),fa[i]=len[i]=en[i]=0;
		cnt=last=1;
	}
	int insert(int c){
		int p=last,ne=last=++cnt;
		len[ne]=len[p]+1;
		while(p&&!son(p,c))son(p,c)=ne,p=fa[p];
		if(!p)fa[ne]=1;
		else {
			int q=son(p,c);
			if(len[q]==len[p]+1)fa[ne]=q;
			else {
				int sp=++cnt;
				memcpy(son[sp],son[q],sizeof son[q]);
				len[sp]=len[p]+1,fa[sp]=fa[q],fa[q]=fa[ne]=sp;
				while(p&&son(p,c)==q)son(p,c)=sp,p=fa[p];
			}
		}
		return ne;
	}
	void init(char *s){
		clear();
		for(register int i=1;i<m;++i)insert(s[i]);
		int node=insert(s[m]);
		while(node)en[node]=1,node=fa[node];
	}
}S[2];
int siz[maxn],h[maxn],st[maxn][2],tax[2][maxn],q[maxn],sl[maxn],nex[2][maxn],tail,num,mx,root,all,cnt;
long long ans;
bool vis[maxn];
struct edge{int pre,to;}e[maxn];
inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;}
void getroot(int node,int fa=0){
	int ma=all-siz[node];
	for(register int i=h[node],x;i;i=e[i].pre){
		x=e[i].to;
		if(vis[x]||x==fa)continue;
		getroot(x,node),ma=max(ma,siz[x]);
	}
	if(ma<mx)mx=ma,root=node;
}
void modify(int id,int len){
	if(len==-1)return;
	ans+=tax[id^1][(m-len)%m];
	st[++cnt][0]=len,st[cnt][1]=id;
}
void calc(int node,int fa,int sam,int len,int id){
	q[++tail]=node,sam=S[id].son(sam,a[node]);
	while(len&&s[id][len+1]!=a[node])len=nex[id][len];
	if(s[id][len+1]==a[node])++len;
	if(len==m)sl[node]=sl[q[tail-m]],len=nex[id][m];
	else if(S[id].en[sam])sl[node]=tail%m;
	modify(id,sl[node]);
	for(register int i=h[node],x;i;i=e[i].pre){
		x=e[i].to;
		if(x==fa||vis[x])continue;
		calc(x,node,sam,len,id);
	}
	--tail,sl[node]=-1;
}
void dfs(int node,int fa){
	siz[node]=1,sl[node]=-1;
	for(register int i=h[node],x;i;i=e[i].pre){
		x=e[i].to;
		if(x==fa||vis[x])continue;
		dfs(x,node),siz[node]+=siz[x];
	}
}
void solve(int node){
	vis[node]=1,cnt=0,modify(0,0);
	++tax[0][0];
	int sam=S[1].son(1,a[node]),len=(s[1][1]==a[node]),last=1;
	long long rec=ans;
	bool flag=0;
	if(len==m)len=nex[1][m];
	else if(S[1].en[sam])sl[node]=1%m;
	modify(1,sl[node]);
	for(register int i=h[node],x;i;i=e[i].pre){
		x=e[i].to;
		if(vis[x])continue;
		for(register int j=last+1;j<=cnt;++j)
			++tax[st[j][1]][st[j][0]];
		last=cnt;
		calc(x,node,1,0,0);
		q[++tail]=node,calc(x,node,sam,len,1),--tail;
	}
	dfs(node,0);
	for(register int i=1;i<=last;++i)--tax[st[i][1]][st[i][0]];
	for(register int i=h[node],x;i;i=e[i].pre){
		x=e[i].to;
		if(vis[x])continue;
		all=siz[x],mx=inf,getroot(x,node),solve(root);
	}
}
int main(){
	memset(sl,-1,sizeof sl),sl[0]=0;
	int t=read();
	while(t--){
		memset(vis,0,sizeof vis);
		memset(h,0,sizeof h),num=ans=0;
		int n=read();
		m=read();
		scanf("%s",a+1);
		for(register int i=1;i<=n;++i)a[i]-='A';
		for(register int i=1,x,y;i<n;++i)x=read(),y=read(),add(x,y),add(y,x);
		scanf("%s",s[0]+1);
		for(register int i=1;i<=m;++i)s[1][i]=(s[0][m-i+1]-='A');
		S[0].init(s[0]),S[1].init(s[1]);
		int j=0;
		for(register int i=2;i<=m;++i){
			while(j&&s[0][i]!=s[0][j+1])j=nex[0][j];
			if(s[0][i]==s[0][j+1])++j;
			nex[0][i]=j;
		}
		j=0;
		for(register int i=2;i<=m;++i){
			while(j&&s[1][i]!=s[1][j+1])j=nex[1][j];
			if(s[1][i]==s[1][j+1])++j;
			nex[1][i]=j;
		}
		dfs(1,0),mx=inf,all=n,getroot(1,0),solve(root);
		printf("%lld\n",ans);
	}
}
```

---

## 作者：agicy (赞：4)

[点此食用更佳](https://www.lu-anlai.com/oi/solution/sdoi2016-r2d1t1/)

前排提醒：本题是一道毒瘤的 点分治 题目。

题目链接：[Luogu P4075](https://www.luogu.com.cn/problem/P4075)/[BZOJ 4598](http://www.lydsy.com/JudgeOnline/problem.php?id=4598)/[LibreOJ 2065](https://loj.ac/problem/2065)/SDOI2016 R2D1T1。

# 题目

## 题意简述

一棵树，每个点上有一个大写字母，给定一个仅包含大写字母的字符串，问有多少对 $u,v$（有序数对）满足从 $u$ 到 $v$ 的简单路径拼成的字符串是模式串重复整数倍的结果。

输入有多组数据，数据组数用 $C$ 表示。

## 数据范围

$$1\leq C\leq 10$$
$$3\leq n\leq 10^6$$
$$3\leq m\leq 10^6$$

## 时空限制

|题目|时间限制|空间限制|
|:-:|:-:|:-:|
|[Luogu P4075](https://www.luogu.com.cn/problem/P4075)|$$1\text{s}$$|$$125\text{MiB}$$|
|[BZOJ 4598](http://www.lydsy.com/JudgeOnline/problem.php?id=4598)|$$10\text{s}$$|$$128\text{MiB}$$|
|[LibreOJ 2065](https://loj.ac/problem/2065)|$$1\text{s}$$|$$256\text{MiB}$$|
|SDOI2016 R2D1T1|$$?\text{s}$$|$$?\text{MiB}$$|

# 题解

## 思路

考虑点分治。

将整个复制得到的字符串切成三部分。左边部分，中间字符，右边部分。将中间字符放在根节点部位，然后用桶统计答案（左、右半部分恰好在哪个位置）。然后就是常规的点分治。

另外，如果字符串长度不足 $n$，应当补齐，用哈希处理。左边顺序处理，右边倒序处理。

下面讲一些细节。

### 细节

#### 字符串 Hash

```cpp
inline void fix(reg char *val){
	while(*val){
		*val=*val-'A'+1; //提前预处理好字符串，减少运算量
		++val;
	}
	return;
}

inline void copy(reg char *str,const int& m,const int& n){ //补足字符串到 n 位
	for(reg int i=m+1;i<=n;++i)
		str[i]=str[i-m];
	return;
}

const ull base=31;
ull basep[MAXN];
ull prehash[MAXN],sufhash[MAXN];

inline void gethash(reg char *str,reg ull *hash,const int& n){ //计算 Hash 值并储存好
	for(reg int i=1;i<=n;++i)
		hash[i]=hash[i-1]*base+str[i];
	return;
}
```

#### 点分治 的 Calc 部分

```cpp
inline void DFS(int ID,const int& father,const int& dep,reg int &Maxdep,const char& mid,reg ull Hash){
	Maxdep=max(Maxdep,dep); //记录最大深度，方便后期还原
	Hash+=val[ID]*basep[dep-1]; //统计当前 Hash 值
	if(Hash==prehash[dep]){ //左半部分匹配
		++Tpre[dep%m]; //统计
		if(mid==pre[dep%m+1]) //如果恰好中间字符同时匹配
			ans+=sumsuf[m-dep%m-1]; //直接统计答案
	}
	if(Hash==sufhash[dep]){ //右半部分匹配
		++Tsuf[dep%m]; //统计
		if(mid==suf[dep%m+1]) //中间匹配
			ans+=sumpre[m-dep%m-1]; //统计答案
	}
	for(reg int i=head[ID];i;i=Next[i])
		if(!del[to[i]]&&to[i]!=father)
			DFS(to[i],ID,dep+1,Maxdep,mid,Hash); //递归
	return;
}

inline void Calc(const int& ID){
	if(val[ID]==pre[1])
		++sumpre[0]; //没有左半部分的特殊情况
    if(val[ID]==suf[1])
		++sumsuf[0]; //没有右半部分的特殊情况
	int Tag=0;
	for(reg int i=head[ID];i;i=Next[i])
		if(!del[to[i]]){
			int Max=0;
			DFS(to[i],ID,1,Max,val[ID],0); //统计
			Tag=max(Tag,Max); //记录最大深度，方便还原
			for(reg int i=0;i<=Max;++i)
				sumpre[i]+=Tpre[i],sumsuf[i]+=Tsuf[i],Tpre[i]=Tsuf[i]=0; //累加统计数据
		}
	for(reg int i=0;i<=Tag;++i)
		sumpre[i]=sumsuf[i]=0; //还原
	return;
}
```

#### 快速读入

另外这道题卡常数，所以要快速读入。

```cpp
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++) //用 fread() 加快读入速度
static char buf[100000],*p1=buf,*p2=buf;

inline int read(void){ //读入整数，比较简单
	reg bool f=false;
	reg char ch=getchar();
	reg int res=0;
	while(ch<'0'||'9'<ch)f|=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getchar();
	return f?-res:res;
}

inline void read(char* str){ //读入仅包含大写字母的字符串
	reg char ch=getchar();
	while(ch<'A'||'Z'<ch)ch=getchar();
	while('A'<=ch&&ch<='Z')(*str++)=ch,ch=getchar();
	return;
}
```

#### 初始化

记得初始化不要漏掉某些部分。

```cpp
inline void Init(void){ //初始化
	cnt=0; //邻接表
	ans=0; //答案
	memset(del,0,sizeof(del)); //点分治标记
	memset(head,0,sizeof(head)); //邻接表表头
	return;
}
```

至于为什么会有这么多细节，你们可以看看提交记录中我被卡了多少次。

## 代码

算法的渐近时间复杂度为 $\Theta(m+n+n\log_2^2n)$。很明显会超时，但我们要相信评测机，是可以过的~~（实际上是数据太水了）~~。

函数传递参数用 `const int&` 更快，防止被卡。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
typedef unsigned long long ull;
#define INF 0X3F3F3F3F
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
static char buf[100000],*p1=buf,*p2=buf;
inline int read(void){
	reg bool f=false;
	reg char ch=getchar();
	reg int res=0;
	while(ch<'0'||'9'<ch)f|=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getchar();
	return f?-res:res;
}
inline void read(char* str){
	reg char ch=getchar();
	while(ch<'A'||'Z'<ch)ch=getchar();
	while('A'<=ch&&ch<='Z')(*str++)=ch,ch=getchar();
	return;
}

const int MAXN=1000000+5;
const int MAXM=1000000+5;

inline void Init(void);
inline void Read(void);
inline void Work(void);

int C;

int main(void){
	reg int C=read();
	while(C--){
		Init();
		Read();
		Work();
	}
	return 0;
}

int n,m;
int cnt,head[MAXN],to[MAXN<<1],Next[MAXN<<1];
char val[MAXN];
char pre[MAXN],suf[MAXN];
ull ans;

inline void Add_Edge(const int& u,const int& v){
	Next[++cnt]=head[u];
	to[cnt]=v;
	head[u]=cnt;
	return;
}

inline void Add_Tube(const int& u,const int& v){
	Add_Edge(u,v);
	Add_Edge(v,u);
	return;
}

inline void fix(reg char *val){
	while(*val){
		*val=*val-'A'+1;
		++val;
	}
	return;
}

inline void copy(reg char *str,const int& m,const int& n){
	for(reg int i=m+1;i<=n;++i)
		str[i]=str[i-m];
	return;
}

const ull base=31;
ull basep[MAXN];
ull prehash[MAXN],sufhash[MAXN];

inline void gethash(reg char *str,reg ull *hash,const int& n){
	for(reg int i=1;i<=n;++i)
		hash[i]=hash[i-1]*base+str[i];
	return;
}

inline void Read(void){
	n=read(),m=read();
	read(val+1);
	fix(val+1);
	basep[0]=1;
	for(reg int i=1;i<=n;++i)
		basep[i]=basep[i-1]*base;
	for(reg int i=1;i<n;++i){
		static int u,v;
		u=read(),v=read();
		Add_Tube(u,v);
	}
	read(pre+1);
	fix(pre+1);
	for(reg int i=1;i<=m;++i)
		suf[i]=pre[m-i+1];
	copy(pre,m,n);
	copy(suf,m,n);
	gethash(pre,prehash,n);
	gethash(suf,sufhash,n);
	return;
}

bool del[MAXN];
int size[MAXN],Max[MAXN];

inline void GetRoot(int ID,const int& father,const int& sum,reg int& root){
	size[ID]=1,Max[ID]=0;
	for(reg int i=head[ID];i;i=Next[i])
		if(!del[to[i]]&&to[i]!=father){
			GetRoot(to[i],ID,sum,root);
			size[ID]+=size[to[i]];
			Max[ID]=max(Max[ID],size[to[i]]);
		}
	Max[ID]=max(Max[ID],sum-size[ID]);
	if(Max[ID]<=Max[root])
		root=ID;
	return;
}

int Tpre[MAXN],Tsuf[MAXN];
int sumpre[MAXN],sumsuf[MAXN];

inline void DFS(int ID,const int& father,const int& dep,reg int &Maxdep,const char& mid,reg ull Hash){
	Maxdep=max(Maxdep,dep);
	Hash+=val[ID]*basep[dep-1];
	if(Hash==prehash[dep]){
		++Tpre[dep%m];
		if(mid==pre[dep%m+1])
			ans+=sumsuf[m-dep%m-1];
	}
	if(Hash==sufhash[dep]){
		++Tsuf[dep%m];
		if(mid==suf[dep%m+1])
			ans+=sumpre[m-dep%m-1];
	}
	for(reg int i=head[ID];i;i=Next[i])
		if(!del[to[i]]&&to[i]!=father)
			DFS(to[i],ID,dep+1,Maxdep,mid,Hash);
	return;
}

inline void Calc(const int& ID){
	if(val[ID]==pre[1])
		++sumpre[0];
    if(val[ID]==suf[1])
		++sumsuf[0];
	int Tag=0;
	for(reg int i=head[ID];i;i=Next[i])
		if(!del[to[i]]){
			int Max=0;
			DFS(to[i],ID,1,Max,val[ID],0);
			Tag=max(Tag,Max);
			for(reg int i=0;i<=Max;++i)
				sumpre[i]+=Tpre[i],sumsuf[i]+=Tsuf[i],Tpre[i]=Tsuf[i]=0;
		}
	for(reg int i=0;i<=Tag;++i)
		sumpre[i]=sumsuf[i]=0;
	return;
}

inline void Solve(int ID,const int& sum){
	if(sum<m)
		return;
	int root=0;
	Max[root=0]=INF;
	GetRoot(ID,-1,sum,root);
	del[root]=true;
	Calc(root);
	for(reg int i=head[root];i;i=Next[i])
		if(!del[to[i]])
			Solve(to[i],size[to[i]]<size[root]?size[to[i]]:sum-size[root]);
	return;
}

inline void Work(void){
	Solve(1,n);
	printf("%llu\n",ans);
	return;
}

inline void Init(void){
	cnt=0;
	ans=0;
	memset(del,0,sizeof(del));
	memset(head,0,sizeof(head));
	return;
}
```


---

## 作者：happybob (赞：3)

考虑点分治。

路径的合并，只需要求出每个点到当前重心的字符串是否可以成为模式串依次相连的前缀或后缀即可。

这显然可以哈希维护，手推一下就知道咋做了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
using namespace std;

using ull = unsigned long long;
const int N = 1e6 + 5;
const ull BASE = 27, MOD = 1610612741;

int t, n, m;
ull hashing[N];
ull repeat_hash[N];
ull powe[N];
long long ans = 0LL;
string s;
bool del[N];
vector<int> G[N];

int sz[N], tot, wc;

void get_sz(int u, int f)
{
	sz[u] = 0;
	if (del[u]) return;
	sz[u] = 1;
	for (auto& j : G[u])
	{
		if (j ^ f)
		{
			get_sz(j, u);
			sz[u] += sz[j];
		}
	}
}

void get_wc(int u, int f)
{
	if (del[u]) return;
	int maxn = tot - sz[u];
	for (auto& j : G[u])
	{
		if (j ^ f)
		{
			get_wc(j, u);
			maxn = max(maxn, sz[j]);
		}
	}
	if (maxn <= (tot >> 1)) wc = u;
}

long long sufcnt[N], precnt[N];
ull nhash[N], revhash[N], rev_repeat_hash[N];
int cur;
char cc[N];
bool canbesuf[N], canbepre[N];
int dist[N];

vector<int> total;

ull subhash(ull* h, int l, int r)
{
	return h[r] - h[l - 1] * powe[r - l + 1];
}

void dfs_suf(int u, int f, int w)
{
	dist[u] = 0;
	cur++;
	canbesuf[u] = 0;
	if (del[u]) return;
	dist[u] = w;
	total.emplace_back(u);
	nhash[cur] = nhash[cur - 1] * BASE + (ull)(cc[u] - 'A' + 1);
	// 判断能否成为后缀
	int len = w;
	int ls = len / m;
	if (ls == 0 || subhash(nhash, len % m + 1, cur) == repeat_hash[ls])
	{
		if (len % m == 0 || subhash(nhash, 1, len % m) == subhash(hashing, m - len % m + 1, m))
		{
			canbesuf[u] = 1;
			//sufcnt[w]++;
		}
	}
	for (auto& j : G[u])
	{
		if (j ^ f)
		{
			dfs_suf(j, u, w + 1);
			cur--;
		}
	}
}

void dfs_pre(int u, int f)
{
	cur++;
	if (del[u]) return;
	nhash[cur] = nhash[cur - 1] * BASE + (ull)(cc[u] - 'A' + 1);
	canbepre[u] = 0;
	// 判断能否成为后缀
	int len = cur;
	int ls = len / m;
	if (ls == 0 || subhash(nhash, len % m + 1, cur) == rev_repeat_hash[ls])
	{
		if (len % m == 0 || subhash(nhash, 1, len % m) == subhash(revhash, m - len % m + 1, m))
		{
			canbepre[u] = 1;
			//precnt[cur]++;
		}
	}
	for (auto& j : G[u])
	{
		if (j ^ f)
		{
			dfs_pre(j, u);
			cur--;
		}
	}
}

void solve(int u)
{
	if (del[u]) return;
	cur = 0;
	get_sz(u, 0);
	tot = sz[u];
	wc = u;
	get_wc(u, 0);
	u = wc;
	del[u] = 1;
	vector<vector<int>> ntot;
	for (auto& j : G[u])
	{
		total.clear();
		total.shrink_to_fit();
		cur = 0;
		dfs_pre(j, u);
		cur = 1;
		nhash[cur] = (ull)(cc[u] - 'A' + 1);
		dfs_suf(j, u, 2);
		for (auto& k : total)
		{
			if (canbesuf[k])
			{
				if (dist[k] % m == 0)
				{
					ans++;
				}
				ans += precnt[(m - dist[k] % m) % m];
			}
			if (canbepre[k])
			{
				if (dist[k] % m == 0 && cc[u] == s[1])
				{
					ans++;
				}
				ans += sufcnt[(m - (dist[k] - 1) % m) % m];
			}
		}
		for (auto& k : total)
		{
			if (canbesuf[k]) sufcnt[dist[k] % m]++;
			if (canbepre[k]) precnt[(dist[k] - 1) % m]++;
		}
		ntot.emplace_back(total);
	}
	for (auto& j : ntot)
	{
		for (auto& k : j)
		{
			canbepre[k] = canbesuf[k] = 0;
			sufcnt[dist[k] % m] = precnt[(dist[k] - 1) % m] = 0;
			dist[k] = 0;
		}
	}
	for (auto& j : G[u]) solve(j);
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	powe[0] = 1;
	for (int i = 1; i < N; i++) powe[i] = powe[i - 1] * BASE;
	cin >> t;
	while (t--)
	{
		cin >> n >> m;
		for (int i = 1; i <= n; i++)
		{
			cin >> cc[i];
			G[i].clear(), G[i].shrink_to_fit();
			del[i] = 0;
		}
		for (int i = 1; i < n; i++)
		{
			int u, v;
			cin >> u >> v;
			G[u].emplace_back(v);
			G[v].emplace_back(u);
		}
		cin >> s;
		s = " " + s;
		for (int i = 1; i <= m; i++)
		{
			hashing[i] = hashing[i - 1] * BASE + (ull)(s[i] - 'A' + 1);
		}
		repeat_hash[1] = hashing[m];
		for (int i = 2; 1LL * i * m <= n; i++)
		{
			repeat_hash[i] = repeat_hash[i - 1] * powe[m] + hashing[m];
		}
		s.erase(s.begin());
		reverse(s.begin(), s.end());
		s = " " + s;
		for (int i = 1; i <= m; i++) revhash[i] = revhash[i - 1] * BASE + (ull)(s[i] - 'A' + 1);
		rev_repeat_hash[1] = revhash[m];
		for (int i = 2; 1LL * i * m <= n; i++)
		{
			rev_repeat_hash[i] = rev_repeat_hash[i - 1] * powe[m] + revhash[m];
		}
		ans = 0LL;
		solve(1);
		cout << ans << "\n";
	}
	return 0;
}

/*
1
9 2
ABAABCBCD
1 2
2 3
3 4
4 5
3 6
6 7
3 8
8 9
AB
*/
```


---

## 作者：_Ch1F4N_ (赞：2)

考虑一下对于合法点对 $(u,v)$ 在其 LCA 处统计贡献。

考虑 $u \to LCA$ 的路径上的字符串一定形如串 $S$ 不断重复，可能最后一次重复没有形成完整周期，我们发现合法的 LCA 是有单调性的，具体而言是 $u \to 1$ 的链上一段前缀，考虑二分（字符串哈希去 check）出分界点后把 $u$ 挂在自己这个节点上加入，在分界点处删除，$v \to LCA$ 的情形是类似的，不过变成了 $S$ 的反串不断重复。

然后考虑做树上启发式合并，当 $u \to LCA,v \to LCA$ 均满足条件后，只需要再满足 $dis(u,v)$ 是 $m$ 的倍数即可，因此启发式合并的时候用一个桶将 $dep_{u} \bmod m = i$ 的 $u$ 的数量记下来即可在枚举轻子树某个 $u,v$ 时计算另一个合法的端点数量。

时间复杂度 $O(n \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned int
const int base = 1331;
const int maxn = 1e5+114;
//#define lowbit(x) (x&(-x))
//#define bp push_back
//#define sz size
//#define cl clear
int n,m;
int preS[maxn],preT[maxn];
char c[maxn],S[maxn],T[maxn];
int _pow[maxn];
int dep[maxn];//反 
int depth[maxn];//正 
int pre[maxn];//祖先链哈希值 
int jumpS[maxn],jumpT[maxn];
vector<int> kfa;
vector<int> Ins[maxn][2],Del[maxn][2];
unordered_map<int,int> cnt[maxn][2];
unordered_set<int> s[maxn][2];
vector<int> E[maxn];
int nxt[maxn];
void dfs(int u,int fa){
	pre[u]=pre[fa]+_pow[dep[u]]*c[u];
	depth[u]=depth[fa]+1; 
	int l=0,r=min(m,depth[u])+1;
	kfa.push_back(u);
	while(l+1<r){
		int mid=(l+r)>>1;
		if((pre[u]-pre[kfa[depth[u]-mid]])==preS[mid]*_pow[dep[u]-1]) l=mid;
		else r=mid;
	} 
	if(l<m) jumpS[u]=kfa[depth[u]-l];
	else jumpS[u]=(jumpS[kfa[depth[u]-l]]);
	l=1,r=min(m,depth[u])+1;
	while(l+1<r){
		int mid=(l+r)>>1;
		if((pre[u]-pre[kfa[depth[u]-mid]])==preT[mid]*_pow[dep[u]-1]) l=mid;
		else r=mid;
	} 
	if(l<m) jumpT[u]=kfa[depth[u]-l];
	else jumpT[u]=(jumpT[kfa[depth[u]-l]]);	
	if(jumpS[u]!=u){
		Ins[u][0].push_back(depth[u]%m);
		Del[nxt[jumpS[u]]][0].push_back(depth[u]%m);		
	}
	if(jumpT[u]!=u){
		Ins[u][1].push_back(depth[u]%m);
		Del[nxt[jumpT[u]]][1].push_back(depth[u]%m);		
	}
	for(int v:E[u]){
		if(v!=fa){
			dep[v]=dep[u]-1;
			nxt[u]=v;
			dfs(v,u);
		}
	}
	kfa.pop_back();
}
//m | x+y-2*depth[u]+1
//y=2*depth[u]-1-x %m
long long ans;
void dsu(int u,int fa){
	for(int x:Ins[u][0]) s[u][0].insert(x),cnt[u][0][x]++;
	for(int x:Ins[u][1]) s[u][1].insert(x),cnt[u][1][x]++;
	for(int v:E[u]){
		if(v!=fa){
			dsu(v,u);
			if(s[u][0].size()<s[v][0].size()){
				swap(s[u][0],s[v][0]);
				swap(cnt[u][0],cnt[v][0]);
				swap(s[u][1],s[v][1]);
				swap(cnt[u][1],cnt[v][1]);
			}
			for(int x:s[v][0]){
				ans+=cnt[u][1][(2*depth[u]+m*(n+1)-1-x)%m]*cnt[v][0][x];
			}
			for(int x:s[v][1]){
				ans+=cnt[u][0][(2*depth[u]+m*(n+1)-1-x)%m]*cnt[v][1][x];
			}
			for(int x:s[v][0]){
				s[u][0].insert(x);
				cnt[u][0][x]+=cnt[v][0][x];
			}
			s[v][0].clear();
			cnt[v][0].clear();
			for(int x:s[v][1]){
				s[u][1].insert(x);
				cnt[u][1][x]+=cnt[v][1][x];
			}
			s[v][1].clear();
			cnt[v][1].clear();
		}
	}
	for(int x:Del[u][0]) cnt[u][0][x]--;
	for(int x:Del[u][1]) cnt[u][1][x]--;
}
void work(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		E[u].push_back(v);
		E[v].push_back(u);
	}
	for(int i=1;i<=m;i++) cin>>S[i],T[m-i+1]=S[i];
	_pow[0]=1;
	for(int i=1;i<maxn;i++) _pow[i]=_pow[i-1]*base;
	for(int i=1;i<=m;i++) preS[i]=preS[i-1]+S[i]*_pow[i],preT[i]=preT[i-1]+T[i]*_pow[i];
	dep[1]=n;
	kfa.push_back(0);
	dfs(1,0);
	dsu(1,0);
	cout<<ans<<'\n';
	for(int i=0;i<maxn;i++){
		preS[i]=preT[i]=c[i]=S[i]=T[i]=_pow[i]=dep[i]=depth[i]=pre[i]=jumpS[i]=jumpT[i]=nxt[i]=0;
		kfa.clear();
		Ins[i][0].clear(),Ins[i][1].clear(),Del[i][0].clear(),Del[i][1].clear(),cnt[i][0].clear(),cnt[i][1].clear(),s[i][0].clear(),s[i][1].clear(),E[i].clear();
		ans=0;
	}
	return ;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int t;
	cin>>t;
	while(t--) work();
	return 0;
}
```

---

## 作者：ECEG (赞：2)

### [SDOI2016] 模式字符串题解

#### 正文

以下重复串表示模式串一直重复得到的串。

这种题看完题就知道考虑**点分治**。

若路径 $x\to rt\to y$ 满足，等价于 $x\to rt$ 是重复串的前缀且 $rt\to y$ 是重复串的后缀且长度和是模式串的倍数。

如果预处理出每个点出发的路径是前缀和后缀，那就很好做了。

如果每个点出发的路径是前缀和后缀的总数量太大了，我们只能换个方法做。

尝试证明总数量是一共可以接受的东西。

最坏的情况就是到达每个点都可以。

那对于 $x\to rt$ 和 $rt\to y$ 的个数都是 $siz_{rt}$，一共就是 $\sum siz_{rt}$，上限是 $n\log n$。

那就说明是可以的，假设求了出来。

把其中一种长度取模后存入一个桶中，枚举另一个，查询就可以了吧，总时间复杂度为 $O(n\log n)$。

那现在的问题就是如何处理出每个点出发的路径是前缀和后缀？

时间允许我们遍历到达的点，现在只需要判断即可。

直接上 hash 即可。

##### 代码

```cpp
#include<cstdio>
#include<vector>
#include<string>
#include<algorithm>
#include<unordered_map>
//#define int long long
//#define inf 0x3f3f3f3f
#define getchar getchar_unlocked
#define putchar putchar_unlocked
template<typename T>void read(T &x){
	x=0;bool f=0;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f)x=-x;
}
void write(char x){putchar(x);}
template<typename T>void write(T x){
	if(x<0)x=-x,putchar('-');
	char stk[14];int tot=0;
	do stk[++tot]=x%10+48,x/=10;while(x);
	for(;tot;tot--)putchar(stk[tot]); 
}
template<typename T,typename ...Args>void read(T &x,Args &...args){read(x);read(args...);}
template<typename T,typename ...Args>void write(T x,Args ...args){write(x);write(args...);}
template<typename T>T min(T x,T y){return x<y?x:y;}
template<typename T>T max(T x,T y){return x>y?x:y;}
const int maxn=1e6+4;const unsigned long long base=10007;
int T,n,m;char a[maxn],mode[maxn<<1];long long ans;
std::vector<int>E[maxn];unsigned long long pre[maxn],suf[maxn];
bool vis[maxn];int siz[maxn],dp[maxn],kl[maxn],rt;std::unordered_map<int,int>cnt;
void find(int x,int FA){
    siz[x]=1;
    for(int v:E[x])if(v!=FA&&!vis[v])find(v,x),siz[x]+=siz[v];
}
void get_rt(int x,int FA,int sum){
    siz[x]=1;dp[x]=0;
    for(int v:E[x])if(v!=FA&&!vis[v])get_rt(v,x,sum),siz[x]+=siz[v],dp[x]=max(dp[x],siz[v]);
    dp[x]=max(dp[x],sum-siz[x]);if(!rt||dp[x]<dp[rt])rt=x;
}
void dfs1(int x,int FA,unsigned long long tmp,int len){
	tmp=tmp*base+a[x];if(pre[len]==tmp)cnt[len%m]++;
	for(int v:E[x])if(v!=FA&&!vis[v])dfs1(v,x,tmp,len+1);
}
int dfs2(int x,int FA,unsigned long long tmp,int len){
	int tot=0;tmp=tmp*base+a[x];if(suf[len]==tmp)tot+=cnt[(m-len%m)%m];
	for(int v:E[x])if(v!=FA&&!vis[v])tot+=dfs2(v,x,tmp,len+1);
	return tot;
}
int calc(int x){cnt.clear();dfs1(x,0,0,0);return dfs2(x,0,0,1);}
int calc2(int x,int val){cnt.clear();dfs1(x,0,val,1);return dfs2(x,0,val,2);}
void solve(int x){
	ans+=calc(x);find(x,0);vis[x]=1;
	for(int v:E[x])if(!vis[v])kl[v]=siz[v];
	for(int v:E[x])if(!vis[v])ans-=calc2(v,a[x]),rt=0,get_rt(v,0,kl[v]),solve(rt);
}
signed main(){
	read(T);
	for(;T--;){
		read(n,m);scanf("%s",a+1);ans=rt=0;
		for(int i=1;i<=n;++i)E[i].clear(),vis[i]=0;
		for(int i=1;i<n;++i){int x,y;read(x,y);E[x].emplace_back(y);E[y].emplace_back(x);}
		scanf("%s",mode);unsigned long long tmp=1,sum=0;
		int op=(n/m+1)*m;
		for(int i=m;i<op;++i)mode[i]=mode[i%m];
		for(int i=0;i<op;++i)sum+=tmp*mode[i],tmp=tmp*base,pre[i]=sum;;tmp=1;sum=0;
		for(int i=op-1;i>=0;--i)sum+=tmp*mode[i],tmp=tmp*base,suf[op-i]=sum;
		get_rt(1,0,n);solve(rt);write(ans,'\n');
	}
	return 0;
}
```

---

## 作者：_HCl_ (赞：2)

蒟蒻刚学点分治，不自量力地来写一写自己对这题的理解。

黑色对我确实有些困难，因此代码有~~参考借鉴~~成分。

~~被多测没清空卡了半个多小时~~。

# P4075 题解

**题意简述**

给定一棵树，每个节点上都标有一个字符。给定一个模式串 $S$，求出有多少对有序二元组 $(u,v)$ 满足 $u$ 到 $v$ 的简单路径组成的字符串，是由 $S$ 重复若干次生成的。

**思路引导**

对于树上的路径问题，很容易想到用点分治解决。

我们来考虑怎么处理经过子树根节点的合法路径数量。

对于模式串的处理，我们预处理出它的前缀 $pre_i$ 和后缀 $suf_i$。

对于每一棵子树，我们处理出每个节点到根节点路径的字符串，然后比对是否是从根节点出发的前缀/后缀，并记录下来。

那么经过根节点的合法路径，可以拆成从根节点出发的前缀和后缀，而且得是正好接起来的。我们可以用 $cnt_{i,0}$ 来记录，对应到模式串上 $pre_i$ 的路径数量;用 $cnt_{i,1}$ 来记录，对应到模式串上 $suf_i$ 的路径数量。然后用 $Sum_i$ 记录 $cnt_i$ 的和。

答案可以在寻路时顺带着统计了。如果当前路径与 $pre_w$ 相等时，答案加上 $Sum_{-w,1}$，也就是统计上和当前路径匹配的后缀。与 $suf_w$ 匹配同理。注意上面的下标都是在模 $m$ 意义下的。

然而直接在数组里存字符串显然是存不下的，所以用字符串 Hash 来存储。

**代码**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200000;
const int base=28,MOD=1000000007;
int n,m;
int dp[N+5],siz[N+5],dep[N+5],vis[N+5];
int sum,RT,ans;
int s[N+5],nd[N+5],pre[N+5],suf[N+5],Sum[N+5][2],cnt[N+5][2];
vector<int> e[N+5];
void getRoot(int x,int fa)//查找重心 
	dp[x]=0,siz[x]=1;
	for(auto y:e[x]){
		if(y==fa||vis[y])continue;
		getRoot(y,x);
		siz[x]+=siz[y];
		dp[x]=max(dp[x],siz[y]);
	}
	dp[x]=max(dp[x],sum-siz[x]);
	if(dp[x]<dp[RT])RT=x;
}
void getPath(int x,int fa,int w,int cur){//遍历路径+答案统计 
	cur=(base*cur%MOD+nd[x])%MOD;
	dep[x]=w;//w 是根节点到 x 的距离 
	if(cur==pre[w])
		cnt[(w-1)%m+1][0]++,ans+=Sum[m-(w-1)%m][1];//注意取模意义下的处理 
	if(cur==suf[w])
		cnt[(w-1)%m+1][1]++,ans+=Sum[m-(w-1)%m][0];
	for(auto y:e[x]){
		if(y==fa||vis[y])continue;
		getPath(y,x,w+1,cur);
		dep[x]=max(dep[x],dep[y]);//这里 dep 存的时 x 能走到的最深的深度 
	}
}
void work(int x){
	int cl=0;//最后要还原多少个 
	Sum[1][0]=Sum[1][1]=1;
	for(auto y:e[x]){
		if(vis[y])continue;
		getPath(y,x,2,nd[x]);
		int DEP=min(dep[y],m);
		cl=max(cl,DEP);
		for(int i=1;i<=DEP;++i){
			Sum[i][0]+=cnt[i][0];
			Sum[i][1]+=cnt[i][1];
			cnt[i][0]=cnt[i][1]=0;
		}
	}
	for(int i=1;i<=cl;++i)Sum[i][0]=Sum[i][1]=0;
}
void solve(int x){ 
	vis[x]=1;
	work(x);
	for(auto y:e[x]){
		if(vis[y])continue;
		dp[0]=n,sum=siz[y],RT=0;
		getRoot(y,x);
		solve(RT);
	}
	vis[x]=0;
}
void doit(){
	ans=0;
	scanf("%lld%lld",&n,&m);
	string tmp;cin>>tmp;
	for(int i=0;i<n;++i)nd[i+1]=tmp[i]-'A';
	for(int i=1;i<=n;++i)e[i].clear();
	for(int i=1;i<n;++i){
		int u,v;
		scanf("%lld%lld",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	cin>>tmp;
	for(int i=0;i<m;++i)s[i+1]=tmp[i]-'A';
	int cur=1;
	for(int i=1;i<=n;++i){//预处理出前缀与后缀 
		pre[i]=(pre[i-1]+cur*s[(i-1)%m+1]%MOD)%MOD;
		suf[i]=(suf[i-1]+cur*s[m-(i-1)%m]%MOD)%MOD;
		cur=base*cur%MOD;
	}
	dp[0]=n,sum=n,RT=0;
	getRoot(1,0);
	solve(RT);
	cout<<ans<<"\n";
}
signed main(){
	int T;
	cin>>T;
	while(T--)doit();
}
```



---

## 作者：OIer_ACMer (赞：2)

~~我竟然是最优解！~~

------------
## 警钟敲烂：
作为一道黑题，它既有难处，也有水处，水是水在它可以直接套模板，然而，难是难在因为它的代码有那么亿点长！！！害得我调了三小时！！！

------------
## 大致思路：
根据题目标签我们已经可以知道这道题的一些皮毛，这道题主要考察了**点分治**和**字符串哈希**的知识，说实话，点分治完全可以~~照着模板抄~~按照书上的来做，然而，这道题，难就难在哈希的转换上。

首先，我们输入字符串，表示每个点标志着什么字符，以及树的点边关系，并用**链式前向星**储存起来（毕竟 $n \le 1 \times 10^6$ 也不是盖的），接着，我们用 $pre$ 数组和 $suf$ 数组预处理出之后输入的标准字符串 $s$ 的各个前缀与后缀的哈希值，因为题目要求最终的答案是多个 $s$ 串联起来的序列，所以现在预处理可以为将来做保障。还有，我们在预处理时**可以以** $m$ **长度为一段预处理**，**这样可以在极短的时间复杂度内处理大量的预处理操作**，至于怎么分块就求模嘛。

接着，我们执行调用模板对整棵树进行遍历，**目的是找出这棵树的重心，为之后的点分治做铺垫**，至于程序实现的细节我就不多说了~~毕竟能点进来这道题的大佬多半已经把点分治玩得很溜了~~。

之后，就是最重要的**寻找路径环节**了，我们可以用递归实现这一操作~~说实话有点像搜索~~。当然，在每次递归前我们都需要判断此时我们的路径序列的哈希值是否已经等于我们一开始预处理的 $pre$ 前缀预处理数组的值（或者等于 $suf$ 数组的后缀预处理值也可以）了，如果是的，就在 $num$ 数组中加一，并记录此时的深度，为之后的统计路径条数做好准备。之后的步骤作者不再细讲，无非就是往儿子节点遍历并记录哈希值嘛。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 2e5 + 5, INF = 1e9 + 7, MOD = 1e9 + 7;
const int base = 31;
int n, m, k, t, ans;
int head[N], to[N], nex[N], cnt;
struct node
{
    int to, next;
} edge[N << 1];
inline void add(int u, int v)
{
    edge[++cnt].to = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
char a[N], s[N];
int pre[N], suf[N];
int PathCnt, siz[N], dep[N], maxnn, maxn, Root, Size;
int Sum[N][2], Num[N][2];
bool vis[N];
void getroot(int x, int fa) // 求树的重心
{
    siz[x] = 1;
    int maxn = 0;
    for (int i = head[x]; i; i = edge[i].next)
    {
        int y = edge[i].to;
        if (y == fa || vis[y])
        {
            continue;
        }
        getroot(y, x);
        siz[x] += siz[y];
        maxn = max(maxn, siz[y]);
    }
    maxn = max(maxn, Size - siz[x]);
    if (maxn < maxnn)
    {
        maxnn = maxn, Root = x;
    }
    return;
}
void getpath(int x, int Hash, int depth, int fa)
{
    Hash = (Hash * base + a[x] - 'A') % MOD;
    dep[x] = depth;
    if (Hash == pre[depth])
    {
        Num[(depth - 1) % m + 1][0]++, ans += Sum[m - (depth - 1) % m][1];
    }
    if (Hash == suf[depth])
    {
        Num[(depth - 1) % m + 1][1]++, ans += Sum[m - (depth - 1) % m][0];
    }
    for (int i = head[x]; i; i = edge[i].next)
    {
        int y = edge[i].to;
        if (vis[y] || y == fa)
        {
            continue;
        }
        getpath(y, Hash, depth + 1, x);
        dep[x] = max(dep[x], dep[y]);
    }
    return;
}
void dfs(int x)
{
    vis[x] = true;
    int len = 0;
    Sum[1][0] = Sum[1][1] = 1;
    for (int i = head[x]; i; i = edge[i].next)
    {
        int y = edge[i].to;
        if (vis[y])
        {
            continue;
        }
        getpath(y, a[x] - 'A', 2, x);
        int Maxdep = min(dep[y], m);
        len = max(len, Maxdep);
        for (int j = 1; j <= Maxdep; j++)
        {
            Sum[j][0] += Num[j][0], Sum[j][1] += Num[j][1], Num[j][0] = Num[j][1] = 0;
        }
    }
    for (int i = 1; i <= len; i++)
    {
        Sum[i][0] = Sum[i][1] = 0;
    }
    for (int i = head[x]; i; i = edge[i].next)
    {
        int y = edge[i].to;
        if (vis[y])
        {
            continue;
        }
        Size = maxnn = siz[y], Root = 0, getroot(y, x), dfs(Root);
    }
    vis[x] = false;
    return;
}
signed main()
{
    int t;
    t = read();
    while (t--)
    {
        memset(head, 0, sizeof(head));
        cnt = ans = 0;
        n = read();
        m = read();
        scanf("%s", a + 1); // 这地方输入字符串想要从 1 开始就要写scanf！！！
        for (int i = 1; i < n; i++)
        {
            int u, v;
            u = read();
            v = read();
            add(u, v), add(v, u);
        }
        scanf("%s", s + 1);
        int tmp = 1;
        for (int i = 1; i <= n; i++)
        {
            pre[i] = (pre[i - 1] + tmp * (s[(i - 1) % m + 1] - 'A') % MOD) % MOD;
            suf[i] = (suf[i - 1] + tmp * (s[m - (i - 1) % m] - 'A') % MOD) % MOD;
            tmp = tmp * base % MOD;
        }
        Root = 0;
        Size = maxnn = n;
        getroot(1, 0);
        dfs(Root);
        cout << ans << endl;
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/121655297)

---

## 作者：ComeIntoCalm (赞：2)

hhhhhhhh并不知道为啥，只有三组数据，不过第三组数据够强，达到了题目描述的$\sum n\leq10^6$

~~实际上$n=1e6$才算强吧~~

只有一个全局询问，考虑点分治，统计串的时候因为$<u,v>$为有序对，所以solve一个点的时候

要分别记录x到当前点时作为prefix和suffix的不同hash值，同时对预处理出来的pre和suf值做匹配

如果匹配上了就找对应的在之前子树里的残串，这样对于每个串匹配前后缀统计答案可以做到$O(1)$

这样的话要开spre和ssuf表示在之前的子树里的$\mod m$意义下残串的数量

这样的话calc每个点复杂度就是线性的，总复杂度$O(n\log n)$

注意将一个子树的匹配前后缀计入的时候要dfs完整个子树再进行记录，不然会有重复答案。

我这里是把calc的点$x$作为后缀计入，所以$spre_m$（由$x$和其子树中的一条路径恰好是模式串的循环）一开始为1

当然这样的话如果$x$恰好为模式串最后一位对于缺少$x$作为后缀的前缀也要计入，即$ssuf_1$初始值为1

```cpp
#include<cstdio>
#include<cstring>
const int N = 1e5+7;
typedef long long LL;
typedef unsigned long long uLL;
#define R register
inline int max(int a, int b) {
  return a > b ? a : b;
}
int last[N], cnt, n, m, up, vis[N];
char A[N];
uLL S[N], pre[N], suf[N];
LL ans;
struct Edge {
  int to, nxt;
}e[N*2];
inline void add(int u, int v) {
  e[++cnt].nxt = last[u], e[cnt].to = v, last[u] = cnt;
}
int SIZ, mxson[N], siz[N], rt;
#define BASE 233uLL
#define cerr(x) printf("%d ", x)
//#define cerr(x, y) printf("%d %d\n", x, y)
#define debug printf("GG\n")
void findrt(int x, int fa) {
  siz[x] = 1, mxson[x] = 0;
  for (int o = last[x]; o; o = e[o].nxt) {
    int to = e[o].to;
    if (to == fa || vis[to]) continue;
    findrt(to, x);
    siz[x] += siz[to];
    mxson[x] = max(mxson[x], siz[to]);
  } mxson[x] = max(SIZ - siz[x], mxson[x]);
  if (mxson[x] < mxson[rt]) rt = x;
}
uLL spre[N], ssuf[N];
int poi, total;
struct Node {
  int pos, id;
}p[N];
/* 
inline uLL FST(uLL x, uLL k) {
  uLL res = 1uLL;
  while (k) {
    if (k & 1uLL) res = res * x;
    x = x * x; k >>= 1uLL; 
  } return res;
}*/
uLL FST[N]; 
void getdis(int x, int fa, uLL suffix, uLL prefix, uLL dep) {
  //if (dep > up) return;
  //cerr(x);
  uLL omgx = suffix + S[x] * FST[dep];//, omgy = prefix * BASE + S[x];
  uLL omgy = prefix + S[x] * FST[dep - 1];
  if (omgx == suf[up - dep])
    ans += spre[m - (dep + 1) % m], p[++total] = (Node){((dep + 1) % m) == 0 ? m : ((dep + 1) % m), 1};
  if (omgy == pre[dep])
    ans += ssuf[m - dep % m], p[++total] = (Node){(dep % m == 0) ? m : (dep % m), 2};
  for (int o = last[x]; o; o = e[o].nxt) {
    int to = e[o].to;
    if (to == fa || vis[to]) continue;
    getdis(to, x, omgx, omgy, dep + 1);
  }
}
void div(int x) {
  //cerr(x);
  if (S[x] == A[m]) ssuf[1]++;
  spre[m]++;
  total = 0, poi = 0;
  for (R int o = last[x]; o; o = e[o].nxt) {
    int to = e[o].to;
    if (vis[to]) continue;
    getdis(to, x, S[x], 0, 1);
    while (poi < total) {
      poi++;
      if (p[poi].id == 1) ssuf[p[poi].pos]++;
      if (p[poi].id == 2) spre[p[poi].pos]++;
    }
  }
  while (poi >= 1) {
    if (p[poi].id == 1) ssuf[p[poi].pos]--;
    if (p[poi].id == 2) spre[p[poi].pos]--;
    poi--;
  }
  if (S[x] == A[m]) ssuf[1]--;
  spre[m]--;
  //cerr(ans, x);
  //printf("%d %d\n", ans, x);
}
void solve(int x) {
  //cerr(x);
  //printf("%d %d\n", ans, x);
  vis[x] = 1, div(x);
  //printf("%d %d\n", ans, x);
  for (int o = last[x]; o; o = e[o].nxt) {
    int to = e[o].to;
    if (vis[to]) continue;
    SIZ = mxson[0] = siz[to], rt = 0;
    findrt(to, x);
    solve(rt);
  }
  vis[x] = 0;
}
int main() {
  //freopen("random.in", "r", stdin);
  //freopen("check.out", "w", stdout);
  int T;
  scanf("%d", &T);
  FST[0] = 1uLL;
  for (int i = 1; i <= 100000; i++)
    FST[i] = FST[i - 1] * BASE;
  while(T--) {
    cnt = 0;
    ans = 0;
    memset(e, 0, sizeof(e));
    memset(last, 0, sizeof(last));
    memset(A, 0, sizeof(A));
    memset(S, 0, sizeof(S));
    memset(pre, 0, sizeof(pre));
    memset(suf, 0, sizeof(suf));
    memset(mxson, 0, sizeof(mxson));
    memset(siz, 0, sizeof(siz));
    //memset(vis, 0, sizeof(vis));
    memset(spre, 0, sizeof(spre));
    memset(ssuf, 0, sizeof(ssuf));
    scanf("%d%d", &n, &m);
    scanf("%s", A + 1);
    up = (n / m) * m;
    for (R int i = 1; i <= n; i++) S[i] = A[i];
    for (R int i = 1, x, y; i < n; i++) scanf("%d%d", &x, &y), add(x, y), add(y, x);
    scanf("%s", A + 1);
    for (R int i = 1; i <= up; i++) pre[i] = pre[i - 1] * BASE + A[((i % m) == 0) ? m : (i % m)];
    for (R int i = up; i >= 1; i--) suf[i] = suf[i + 1] * BASE + A[((i % m) == 0) ? m : (i % m)];
    rt = 0, mxson[0] = SIZ = n;
    findrt(1, 0);
    solve(rt);
    printf("%lld\n", ans);
  } //debug;
}

// 97 ~ 122
/* 
2
10 4
aaaaaaabbb
2 1
3 1
4 1
5 2
6 4
7 2
8 3
9 7
10 7
baaa 
10 4
aaaaaaabbb
2 1
3 1
4 1
5 2
6 4
7 2
8 3
9 7
10 7
baaa 

*/
```

---

## 作者：complete_binary_tree (赞：1)

~~没想到刚学完点分治就被机房 dalao 拉来做黑提了（悲）~~

我们可以枚举当前 $root$ 的子树，找出模式串的前缀和后缀，再更新答案即可。这就是点分治。

一些细节：

- 本题使用字符串。而字符串的比较是 $O(n)$ 的。所以我们要使用 **字符串哈希**。

- 点分治把 $root$ 设为重心时才能做到 $O(n \log n)$。

- 在点分治的时候，我们定义 $pre_i$ 是经过节点数为 $i$ 的合法前缀的个数，$suf_i$ 是经过节点数为 $i$ 的合法后缀个数。每次分治我们都保存 $root$ 到当前节点组成的字符串 $\text{hash}$ 值，判断是否合法。如果合法，就令 $m+1$（$+1$ 是因为此时 $root$ 会被算两遍）减去 这个字符串的长度 $=len$。如果长度等于 $len$ 的字符串在以前有出现，那么就加上出现的次数。最后再更新 $pre_i$ 和 $suf_i$。

- 但是有时候路径长度会大于 $m$，那我们该怎么办呢？首先，我们可以让这个字符串的前缀和后缀一直重复它本身，直到长度大于等于 $m$ 再进行哈希。这样任何合法路径的 $\text{hash}$ 值都可以查到。然后我们在处理时，对于一条路径，如果长度大于 $m$，就直接模 $m$ 即可。

- 这样我们的点分治的答案更新就是 $O(1)$ 的。所以总的复杂度是 $O(n\log n)$ 的。$10^6$ 足矣！

Update 24/2/25：写完 tj 后我跑去写题~~什么先写 tj 后写题的习惯~~，然后过了样例，但是死活是 $\red{\text{WA}}$。然后无意间将哈希的 ```*26``` 换成了 ```*27``` 过了。警钟长鸣。

[*26 WA 记录](https://www.luogu.com.cn/record/148351789)

[*27 AC 记录](https://www.luogu.com.cn/record/148351722)

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;

typedef long long ll;
typedef unsigned long long ull;

ll ans;
ll c;
ll n, m;
ll ch[N], S[N];
queue<ll> q;
struct edge{ //都 1e6 了，链式必须整上
	ll to, next;
};
edge e[2 * N]; //记得开两倍！
ll head[N], cnt;
ull ksm[N], _pre[N], _suf[N], hash_pre[N];

ll pre[N], suf[N];

inline void add(int u, int v){ //优雅（？）的加边
	e[++cnt].to = v;
	e[cnt].next = head[u];
	head[u] = cnt;
}

inline void csh(){ //初始化（使用自然溢出哈希）
	ksm[0] = 1;
	for(int i = 1; i <= n; ++i){
		ksm[i] = ksm[i - 1] * 27; //相当于 27 进制下的 1<<i（千万不能是 *26！！！）
	}
	for(int i = 1; i <= n; ++i){
		_pre[i] = _pre[i - 1] * 27 + S[(i - 1) % m + 1]; //hash 前缀
	}
	for(int i = 1, j = m; i <= j; ++i, --j){
		swap(S[i], S[j]); //奇妙的转化方法
	}
	for(int i = 1; i <= n; ++i){
		_suf[i] = _suf[i - 1] * 27 + S[(i - 1) % m + 1]; //hash 后缀
	}
	return ;
}

ll jds[N], mxzs[N], deep[N];
bool vis[N];

void find_zx(int u, int fa){ //找重心，不是找祖先！
	q.push(u);
	jds[u] = 1;
	mxzs[u] = 0;
	for(int i = head[u]; i; i = e[i].next){
		int v = e[i].to;
		if(v == fa || vis[v]) continue;
		find_zx(v, u);
		jds[u] += jds[v];
		mxzs[u] = max(mxzs[u], jds[v]);
	}
	return ;
}

void dfs1(int u, int fa){ //更新答案
	q.push(u);
	deep[u] = deep[fa] + 1; //深度（root 为 0）
	hash_pre[u] = hash_pre[fa] + ch[u] * ksm[deep[u]]; //相当于将 ch[u] 插入到 根到 fa 的路径组成的字符串（倒序） 的前面再求 hash
	if(hash_pre[u] == _pre[deep[u] + 1]){ //距离需要 +1，因为我们将根节点算在 hash_pre 里面了
		int len = m - deep[u] % m;len %= m; //这里其实 m 和 deep[u] 都要 +1，但是都 +1 就相当于不变了
		ans += suf[len];
	}
	if(hash_pre[u] == _suf[deep[u] + 1]){
		int len = m - deep[u] % m;len %= m;
		ans += pre[len];
	}
	for(int i = head[u]; i; i = e[i].next){
		int v = e[i].to;
		if(vis[v] || v == fa) continue;
		dfs1(v, u);
	}
	return ;
}

queue<ll> qu;

void dfs2(int u, int fa){ //更新前后缀数组
	if(hash_pre[u] == _pre[deep[u] + 1]){ //根节点要算，+1
		if(!pre[(deep[u] + 1) % m]) qu.push((deep[u] + 1) % m);
		pre[(deep[u] + 1) % m]++;
	}
	if(hash_pre[u] == _suf[deep[u] + 1]){
		if(!suf[(deep[u] + 1) % m]) qu.push((deep[u] + 1) % m);
		suf[(deep[u] + 1) % m]++;
	}
	for(int i = head[u]; i; i = e[i].next){
		int v = e[i].to;
		if(vis[v] || v == fa) continue;
		dfs2(v, u);
	}
	return ;
}

void dfz(int root){
	find_zx(root, -1);
	int all = jds[root];
	while(!q.empty()){ //使用队列，不然复杂度是错的
		int u = q.front();
		q.pop();
		mxzs[u] = max(mxzs[u], all - jds[u]);
		if(mxzs[u] < mxzs[root]) root = u;
	}
	q.push(root); //重复利用（
	deep[root] = 0;
	hash_pre[root] = ch[root]; //记得将根节点算上！
	if(ch[root] == _pre[1]) pre[1]++; //如果根节点就是前/后缀
	if(ch[root] == _suf[1]) suf[1]++;
	qu.push(1); //队列
	for(int i = head[root]; i; i = e[i].next){
		int v = e[i].to;
		if(vis[v]) continue;
		dfs1(v, root); //先更新答案
		dfs2(v, root); //再更新前后缀信息
	}
	vis[root] = 1;
	while(!q.empty()){ //队列复原
		int u = q.front();
		q.pop();
		deep[u] = 0;
		hash_pre[u] = 0;
	}
	while(!qu.empty()){
		int u = qu.front();
		qu.pop();
		suf[u] = 0, pre[u] = 0;
	}
	for(int i = head[root]; i; i = e[i].next) //继续分治
		if(!vis[e[i].to])
			dfz(e[i].to);

	return ;
}

int read(){ //快读，不用也行
	char ch = getchar();
	int f = 1, x = 0;
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + int(ch - '0');
		ch = getchar();
	}
	return x * f;
}

int main(){
	c = read();
	while(c--){
		memset(vis, 0, sizeof vis);
		memset(head, 0, sizeof head);
		memset(e, 0, sizeof e);
		ans = 0;
		cnt = 0;
		//多测不清空，爆零泪两行
		n = read(), m = read();
		for(int i = 1; i <= n; ++i){
			char _ch = getchar();
			while(_ch < 'A' || _ch > 'Z') _ch = getchar();
			ch[i] = _ch - 'A';
		}
		//奇妙的读字符串方法
		for(int i = 1; i < n; ++i){
			ll u, v;
			u = read(), v = read();
			add(u, v); //双向加边！
			add(v, u);
		}
		for(int i = 1; i <= m; ++i){
			char _ch = getchar();
			while(_ch < 'A' || _ch > 'Z') _ch = getchar();
			S[i] = _ch - 'A';
		}
		//奇妙的读字符串方法*2
		csh();
		dfz(1);
		printf("%lld\n", ans); //不开 longlong 见祖宗
	}
	return 0;
}
```

~~蒟蒻写题解不易，还请多多支持！~~

---

## 作者：xuyiyang (赞：0)

### [P4075 [SDOI2016] 模式字符串](https://www.luogu.com.cn/problem/P4075)
dirty work 题。$\\$
考虑点分治，钦定重心 $R$ 的字符算入结尾的那一段字符串。那么只需要求出对于 $R$ 为根的子树中可以成为 $S$ 的开头和 $S$ 的结尾的点集，然后直接扫一遍即可。现在考虑如何求出成为 $S$ 的前后缀。那么直接哈希即可。代码由于 dirty work 过于抽象。$\mathcal O(n \log n)$。
```cpp
int n, m; ll res;
char w[N], s[N];
vector<int> e[N];
int sz[N], mx[N], R;
bool st[N];
struct dat {
	int L, x; 
};
vector<dat> info, cur;
ull ha[N], hb[N], pw[N];

void findroot(int id, int f, int tot) {
	mx[id] = 0; sz[id] = 1; 
	for (int it : e[id]) {
		if (it == f || st[it]) continue ;
		findroot(it, id, tot); sz[id] += sz[it];
		mx[id] = max(mx[id], sz[it]);
	} mx[id] = max(mx[id], tot - sz[id]);
	if (mx[id] < mx[R]) R = id;
}
inline ull get(int l, int r) { if (l > r) return 0; return ha[r] - ha[l - 1] * pw[r - l + 1]; }
void getinfo(int id, int f, ull p, int L, int flg) {
	if (!flg) p = (w[id] - 'a' + 1) * pw[L] + p;
	else p = p * 131 + w[id] - 'a' + 1;
	L ++ ; int cyc = L / m;
	if (!flg && p == hb[cyc] * pw[L % m] + ha[L % m]) {
		cur.push_back({L % m, 0}); info.push_back({L % m, 0});
	}
	if (flg && p == get(m - L % m + 1, m) * pw[cyc * m] + hb[cyc]) {
		cur.push_back({(m - L % m) % m + 1, 1}); info.push_back({(m - L % m) % m + 1, 1});
	}
	
	for (int it : e[id]) if (it != f && !st[it]) {
		getinfo(it, id, p, L, flg);
	}
}
void calc(vector<dat> c, int sgn) {
	static int buc[N];
	for (dat it : c) if (it.x == 1) buc[it.L] ++ ;
	for (dat it : c) if (it.x == 0) res += buc[it.L % m + 1] * sgn;
	for (dat it : c) if (it.x == 1) buc[it.L] -- ;
}
void divide(int id) {
	st[id] = 1;
	for (int it : e[id]) {
		if (st[it]) continue ;
		cur.clear();
		getinfo(it, id, 0, 0, 0);
		ull p = w[id] - 'a' + 1;
		getinfo(it, id, p, 1, 1);
		calc(cur, -1);
	} 
	if (w[id] == s[m]) info.push_back({m, 1});
	info.push_back({0, 0});
	calc(info, 1); info.clear();
	for (int it : e[id]) {
		if (st[it]) continue ;
		R = 0; findroot(it, id, sz[it]); divide(R);
	}
}

void mian() {
	scanf("%d%d", &n, &m);
	scanf("%s", w + 1); ha[0] = hb[0] = 0;
	memset(st, 0, sizeof st);
	for (int i = 1; i <= n; i ++ ) e[i].clear();
	for (int i = 0, u, v; i < n - 1; i ++ ) {
		scanf("%d%d", &u, &v);
		e[u].push_back(v), e[v].push_back(u);
	} scanf("%s", s + 1); pw[0] = 1;
	for (int i = 1; i <= n; i ++ ) pw[i] = pw[i - 1] * 131;
	for (int i = 1; i <= m; i ++ ) ha[i] = ha[i - 1] * 131 + (s[i] - 'a' + 1);
	for (int i = 1; i <= n / m; i ++ ) hb[i] = hb[i - 1] * pw[m] + ha[m];
	mx[0] = N; R = 0; res = 0; findroot(1, 0, n); divide(R);
	printf("%lld\n", res);
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

看到这种树上统计点对贡献一般考虑点分治。

先对于模式串 $S$ 求出前缀的哈希数组 $h_i$，且 $\operatorname{Hash}(l,r)$ 表示 $S$ 中区间 $[l,r]$ 组成的字符串的哈希值（若 $l>r$，则 $\operatorname{Hash}(l,r)=0$）。

设当前分治重心为 $rt$，初始 $dep_{rt}=-1$，那么可以对于 $rt$ 的每棵儿子子树先 dfs 一遍，预处理出 $d_{u,0/1},f_{u,0/1},g_{u,0/1}$，分别表示：

- 从 $rt \to u$ 和从 $u \to rt$ 组成的字符串的哈希值。

- 从 $rt \to u$ 和从 $u \to rt$ 组成的字符串匹配了模式串后剩下的后缀/前缀字符串，例如有 $u \to rt$ 路径的 `SCOIAK` 被 `SCOI` 匹配后剩下的是 `AK`（只能匹配前缀），有 $rt \to u$ 路径的 `AKIOISCOI` 被 `SCOI` 匹配后剩下的是 `AKIOI`（只能匹配后缀）。

- 从 $rt \to u$ 和从 $u \to rt$ 组成的字符串匹配了模式串后剩下的后缀/前缀字符串的长度。

注意上述都不包含 $rt$ 节点的字符。

那么可以得到状态转移方程：

$$d_{u,0} = d_{fa_u,0} \times base + a_u$$

$$d_{u,1} = d_{fa_u,1} + a_u \times base^{dep_u}$$

若 $dep_u < m-1$，即当前没有到模式串的长度：

$$f_{u,0/1} = d_{u,0/1}$$

$$g_{u,0/1} = dep_u +1$$

否则当 $dep_u \ge m-1$，令 $x$ 为 $u$ 的 $m$ 级祖先， 即祖先中深度为 $dep_u-m+1$ 的点：

- 若 $x \to u$ 路径（不包含 $x$）上组成的字符串和模式串 $S$ 相等，即满足 $d_{u,0} - d_{x,0} \times base^m = h_m$：

$$f_{u,0} = f_{x,0}$$

$$g_{u,0} = g_{x,0}$$

- 否则：

$$f_{u,0} = d_{u,0}$$

$$g_{u,0} = dep_u +1$$

- 若 $u \to x$ 路径（不包含 $x$）上组成的字符串和模式串 $S$ 相等，即满足 $\frac{d_{u,1}-d_{x,1}}{base^{dep_x+1}} = h_m$，尽量避免除法，则移项为 $d_{u,1} - d_{x,1} = h_m \times base^{dep_x+1}$：

$$f_{u,1} = f_{x,1}$$

$$g_{u,1} = g_{x,1}$$

- 否则：

$$f_{u,1} = d_{u,1}$$

$$g_{u,1} = dep_u +1$$

预处理出这个，再考虑两个点 $u \to v$ 和 $v \to u$ 的贡献：

- 若是 $u \to v$，即要满足 $f_{u,1} = \operatorname{Hash}(1,g_{u,1}) \&a_{rt} = S_{g_{u,1}+1} \& f_{v,0} = \operatorname{Hash}(g_{u,1}+2,m)$。

- 若是 $v \to u$，即要满足 $f_{u,0} = \operatorname{Hash}(m-g_{u,0}+1,m) \& a_{rt} = S_{m-g_{u,0}} \& f_{v,1} = \operatorname{Hash}(1,m-g_{u,0}-1)$。

那么我们可以开两个桶 $T_1,T_2$，分别表示：

- 对于 $rt \to u$ 路径上的字符串，后缀经过模式串的匹配后剩余的前缀 $f_{u,0}$ 是 $S$ 中 $i \sim m$ 这个后缀的数量为 $T_{1,i}$。

- 对于 $u \to rt$ 路径上的字符串，前缀经过模式串的匹配后剩余的后缀 $f_{u,1}$ 是 $S$ 中 $1 \sim i$ 这个前缀的数量为 $T_{2,i}$。

那上面的我们就很好维护了。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=1000100,base=31;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll T,n,m,ans,sum,cnt,root,Max;
ll siz[N],dep[N],dis[N],id[N],g[N][2];
ull d[N][2],f[N][2],h[N],p[N];
ll T1[N],T2[N];
stack<ll> stk1,stk2;
char s[N],a[N];
vector<ll> E[N];
bool del[N];
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
void init(){
	dep[0]=-1;
	p[0]=1;
	for(int i=1;i<N;i++)
	  p[i]=p[i-1]*base;
}
ull Hash(ll l,ll r){
	if(l>r)
	  return 0;
	return h[r]-h[l-1]*p[r-l+1];
}
void getroot(ll u,ll fa){
    ll s=0;
    siz[u]=1;
    for(auto v:E[u]){
    	if(v==fa||del[v])
    	  continue;
    	getroot(v,u);
    	siz[u]+=siz[v];
		s=max(s,siz[v]); 
	}
	s=max(s,sum-siz[u]);
	if(s<Max){
		Max=s;
		root=u;
	}
}
void Get(ll u,ll s){
	root=u;
	Max=sum=s;
	getroot(u,0);
	getroot(root,0);
}
void getdis(ll u,ll fa){
	id[dep[u]+1]=u;
	dis[++cnt]=u;
	for(auto v:E[u]){
		if(v==fa||del[v])
		  continue;
		dep[v]=dep[u]+1;
		d[v][0]=d[u][0]*base+a[v];
		d[v][1]=d[u][1]+a[v]*p[dep[v]];
		if(dep[v]>=m-1){
			ll x=id[dep[v]-m+1];
			if(d[v][0]-d[x][0]*p[m]==h[m]){
				f[v][0]=f[x][0];
				g[v][0]=g[x][0];
			}
			else{
				f[v][0]=d[v][0];
				g[v][0]=dep[v]+1;
			}
			if(d[v][1]-d[x][1]==h[m]*p[dep[x]+1]){
				f[v][1]=f[x][1];
				g[v][1]=g[x][1];
			}
			else{
				f[v][1]=d[v][1];
				g[v][1]=dep[v]+1;
			}
		}
		else{
			f[v][0]=d[v][0];
			f[v][1]=d[v][1];
			g[v][0]=g[v][1]=dep[v]+1;
		}
		getdis(v,u);
	}
}
void calc(ll u){
	T1[0]=T2[0]=1;
	for(auto v:E[u]){
		if(del[v])
		  continue;
		d[v][0]=d[v][1]=f[v][0]=f[v][1]=a[v];
		g[v][0]=g[v][1]=1;
		dep[v]=0; 
		cnt=0;
		getdis(v,u);
		for(int i=1;i<=cnt;i++){
			if(g[dis[i]][0]<m&&f[dis[i]][0]==Hash(m-g[dis[i]][0]+1,m)&&a[u]==s[m-g[dis[i]][0]])
			  ans+=T1[m-g[dis[i]][0]-1];
			if(g[dis[i]][1]<m&&f[dis[i]][1]==Hash(1,g[dis[i]][1])&&a[u]==s[g[dis[i]][1]+1])
			  ans+=T2[m-g[dis[i]][1]-1];
		}
		for(int i=1;i<=cnt;i++){
			if(g[dis[i]][0]<m&&f[dis[i]][0]==Hash(m-g[dis[i]][0]+1,m)&&a[u]==s[m-g[dis[i]][0]]){
				if(!T2[g[dis[i]][0]])
				  stk2.push(g[dis[i]][0]);
				T2[g[dis[i]][0]]++;
			}
			if(g[dis[i]][1]<m&&f[dis[i]][1]==Hash(1,g[dis[i]][1])&&a[u]==s[g[dis[i]][1]+1]){
				if(!T1[g[dis[i]][1]])
				  stk1.push(g[dis[i]][1]);
				T1[g[dis[i]][1]]++;
			}
		}
	}
	while(!stk1.empty()){
		T1[stk1.top()]=0;
		stk1.pop();
	}
	while(!stk2.empty()){
		T2[stk2.top()]=0;
		stk2.pop();
	}	
}
void solve(ll u){
	calc(u);
	del[u]=1;
	for(auto v:E[u]){
		if(del[v])
		  continue;
		Get(v,siz[v]);
		solve(root);
	}
}
void solve(){
	ans=0;
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		del[i]=0;
		E[i].clear();
	}
	scanf("%s",a+1);
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	scanf("%s",s+1);
	if(m==1){
		for(int i=1;i<=n;i++)
		  if(a[i]==s[m])
		    ans++;
		write(ans);
		putchar('\n');
		return ;
	}
	for(int i=1;i<=m;i++)
	  h[i]=h[i-1]*base+s[i];
	Get(1,n);
	solve(root);
	write(ans);
	putchar('\n');
}
bool End;
int main(){
	init();
	T=read();
	while(T--)
	  solve();
	cerr<<"\n"<<abs(&Begin-&End)/1048576<<"MB";
	return 0;
}
```

---


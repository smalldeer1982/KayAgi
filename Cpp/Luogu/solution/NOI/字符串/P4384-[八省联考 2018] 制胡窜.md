# [八省联考 2018] 制胡窜

## 题目描述

对于一个字符串 $s$，我们定义 $|s|$ 表示 $s$ 的长度。

接着，我们定义 $s_i$ 表示 $s$ 中第 $i$ 个字符，$s_{l,r}$ 表示由 $s$ 中从左往右数，第 $l$ 个字符到第 $r$ 个字符依次连接形成的字符串。特别的，如果 $l \gt r$，或者 $l \notin [1, |s|]$，或者 $r \notin [1, |s|]$，我们可以认为 $s_{l,r}$ 为空串。

给定一个长度为 $n$ 的仅由数字构成的字符串 $s$，现在有 $q$ 次询问，第 $k$ 次询问会给出 $s$ 的一个子串 $s_{l,r}$，请你求出有多少对 $(i, j)$，满足 $1 \leq i \lt j \leq n$，$i + 1 < j$，且 $s_{l,r}$ 出现在 $s_{1,i}$ 中或 $s_{i+1,j-1}$中或 $s_{j,n}$ 中。

## 说明/提示

|    测试点    |     $n$     |     $q$     |               其它约定                |
| :----------: | :-------: | :-------: | :-----------------------------------: |
|     $1$      |   $=50$   |  $=100$   |                  无                   |
|  $2 \sim 3$  |  $=300$   |  $=300$   |                  无                   |
|  $4 \sim 5$  |  $=2000$  |  $=3000$  |                  无                   |
|  $6 \sim 9$  | $=100000$ | $=100000$ | $\sum \lvert s_{l,r} \rvert \le 10^6$ |
| $10 \sim 12$ | $=30000$  | $=50000$  |                  无                   |
|     $13$     | $=100000$ | $=100000$ |            $s$ 中只有 $0$             |
| $14 \sim 20$ | $=100000$ | $=300000$ |                  无                   |


对于所有测试数据，$1 \le n \le 10^5$，$1 \le q \le 3 \times 10^5$，$1 \le l \le r \le n$，$s$ 中只有数字字符。

## 样例 #1

### 输入

```
5 2
00100
1 2
1 3
```

### 输出

```
5
1```

# 题解

## 作者：Reaepita (赞：21)

# 若公式失效请到博客内查看
# 若公式失效请到博客内查看
# 若公式失效请到博客内查看
为了防止有人看不见（重复三遍）
---
题上要求我们求出：选择一对 $i,j,i+1<j$ 将序列分为三段（$[1,i],[i+1,j-1],[j,n]$）至少有一段包含子串 $S_{l,r}$ 的方案。

直接求没有什么思路，考虑求出每一段都不包含子串 $S_{l,r}$ 的方案，然后用总方案 ${n-1}\choose 2$ 减掉即可。

> 由于题上要求 $l,r$ 不相邻所以总方案是 ${n-1}\choose 2$ 。

---

首先要知道所有与 $S_{l,r}$ 相同的子串的位置。

这个可以直接用后缀自动机+线段树合并+树上倍增求出

现在我们就得到了每个与 $S_{l,r}$ 相同的子串的位置，假设有 $m$ 个这样的子串，第 $i$ 个子串位于 $[l_i,r_i]$ 。

首先可以观察得出如果存在三个以上互不相交的子串，答案为 $0$。

那么剩下的子串只存在两种情况。

>下文出现的 $len$ 指询问的子串长度。

## 情况 1 

> 最靠左的子串与最靠右的子串相交

![image](https://cdn.luogu.com.cn/upload/image_hosting/cx9ixlks.png)

在这里我们将 $i$ 选择的位置分类。

1. 当 $i\in[1,l_1)$ 时，显然 $S_{1,i}$ 不包含任何子串，那么只需要保证 $S_{i+1,j-1}$ 和 $S_{j,n}$ 不包含任意子串即可。可以发现合法的 $j$ 选择的区间一定是 $(l_m,r_1]$。

   这部分的贡献为：
   $$
   (l_1-1)(r_1-l_m)
   $$

2. 当 $i\in[l_i,l_{i+1})$ 时，显然 $S_{1,i}$ 不包含任何子串，此时 $S_{j,n}$ 的限制就是 $l_m<j$ ， $S_{i+1,j-1}$  的限制是 $j\leq r_{i+1}$。（如上图所示，当 $i\in[l_1,l_2)$ 时 $j\in(l_3,r_2]$ ，当 $i\in[l_2,l_3)$ 时 $j\in(l_3,r_3]$）

   这类情况贡献为：
   $$
   \sum_{i=1}^{m-1}(l_{i+1}-l_i)(r_{i+1}-l_m)=\sum_{i=1}^{m-1}(r_{i+1}-r_i)(r_{i+1}-l_m)
   $$

3. 当 $i\in[l_m,r_1)$ 时，只需要保证 $i+1<j$ 即可，此时的方案数相当于 $j$ 在 $[l_m,r_1]$ 中的方案数$+\ j$ 在 $(r_1,n]$ 中的方案数。

   这部分的贡献为：
   $$
   {{r_1-l_m}\choose 2}+(r_1-l_m)(n-r_1)
   $$

4. 当 $i\in[r_1,n]$ 时，答案为 $0$ 

所以情况 $1$ 的总方案是
$$
\sum_{i=1}^{m-1}(r_{i+1}-r_i)(r_{i+1}-l_m)+{{r_1-l_m}\choose 2}+(r_1-l_m)(n-r_1)+(l_1-1)(r_1-l_m)
$$

 ## 情况 2 

> 最靠左的子串与最靠右的子串不相交

![image](https://cdn.luogu.com.cn/upload/image_hosting/w1r6xxwg.png)

对于这种情况，可以发现满足条件的 $i,j$ 首先必须满足 $i<r_1,l_m<j$ 。

1. 由于最靠左的区间和最靠右的区间并不相交，所以如果 $i\in[1,l_1)$  显然不存在合法的 $j$ 。

2. 当 $i\in[l_i,l_{i+1})$ 时，可以发现这里与情况 $1$ 唯一不同点就在于 $l_{i+1}$ 可能大于 $r_1$ （$l_4>r_1$）。

   可以观察的出，若 $l_m<r_{i+1}$ 且 $l_{i+1}<r_1$ 还是可以使用情况 $1$ 的方法求出即：
   $$
   \sum_{i=1}^{m-1}(r_{i+1}-r_i)(r_{i+1}-l_m),l_m<r_{i+1}<r_1+len-1
   $$
   如上图所示此时我们已经求出了 $i\in[l_1,l_3)$ 的答案，但是当 $i\in[l_3,r_1)$ 中的答案在上式中并没有被计算。

   这种情况贡献显然是 $(r_1-l_3)(r_4-l_4)$ 

   更普遍的，找到 $r_1+len-1$ 的在 `right` 集合中的前驱 $p_1$ 和后继 $p_2$ 

   那这种情况的贡献为 $(r_1-l_{p_1})(r_{p_2}-l_m),r_{p_2}>l_m$

所以情况 $2$ 比情况 $1$ 复杂许多。

但本质只有两个求和公式
$$
\sum_{i=1}^{m-1}(r_{i+1}-r_i)(r_{i+1}-l_m),l_m<r_{i+1}<r_1+len-1
$$

$$
(r_1-l_{p_1})(r_{p_2}-l_m),r_{p_2}>l_m
$$

## 代码实现

线段树需要维护区间最大值，区间最小值，还需要维护 $(r_{i+1}-r_i)r_{i+1}$ 和 $(r_{i+1}-r_i)$。

对于一个询问 $l,r$ 

通过倍增找到 $S_{1,r}$ 对应 `parent` 树上哪个节点。

然后先判断是否存在三个不相交的区间，可以先找出最靠左的位置和最靠右的位置然后查询区间最大值。

然后对于情况 $1$ 或情况 $2$ 分别求解。

可以发现情况 $1$ 和情况 $2$ 都有 $(r_{i+1}-r_i)(r_{i+1}-l_m)=(r_{i+1}-r_i)r_{i+1}-(r_{i+1}-r_i)l_m$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
const int inf=0x3f3f3f3f;
struct Node{int Min,Max;long long sum1,sum2;}tr[maxn*40];
struct Segment_Tree
{
    int son[maxn*40][2],tot;
    Node merge(const Node &a,const Node &b)
    {
        Node c;
        c.Min=min(a.Min,b.Min);
        c.Max=max(a.Max,b.Max);
        c.sum1=a.sum1+b.sum1+b.Min*1LL*(b.Min-a.Max);
        c.sum2=a.sum2+b.sum2+b.Min-a.Max;
        return c;
    }
    int Find_Max(int l,int r,int rt,int L,int R)
    {
        if(!rt)return 0;
        if(L<=l&&r<=R)return tr[rt].Max;
        int mid=l+r>>1,ans=0;
        if(L<=mid)ans=Find_Max(l,mid,son[rt][0],L,R);
        if(R>mid)ans=max(ans,Find_Max(mid+1,r,son[rt][1],L,R));
        return ans;
    }
    int Find_Min(int l,int r,int rt,int L,int R)
    {
        if(!rt)return inf;
        if(L<=l&&r<=R)return tr[rt].Min;
        int mid=l+r>>1,ans=inf;
        if(L<=mid)ans=Find_Min(l,mid,son[rt][0],L,R);
        if(R>mid)ans=min(ans,Find_Min(mid+1,r,son[rt][1],L,R));
        return ans;
    }
    Node tmp;
    void Query(int l,int r,int rt,int L,int R)
    {
        if(!rt)return;
        if(L<=l&&r<=R)
        {
            if(tmp.Min==0)tmp=tr[rt];
            else tmp=merge(tmp,tr[rt]);
            return ;
        }
        int mid=l+r>>1;
        if(L<=mid)Query(l,mid,son[rt][0],L,R);
        if(R>mid)Query(mid+1,r,son[rt][1],L,R);
    }
    void update(int l,int r,int &rt,int p)
    {
        if(!rt)rt=++tot;
        if(l==r)
        {
            tr[rt].Min=tr[rt].Max=p;
            tr[rt].sum1=tr[rt].sum2=0;
            return;
        }
        int mid=l+r>>1;
        if(p<=mid)update(l,mid,son[rt][0],p);
        else update(mid+1,r,son[rt][1],p);
        if(son[rt][0]&&son[rt][1])tr[rt]=merge(tr[son[rt][0]],tr[son[rt][1]]);
        else if(son[rt][0])tr[rt]=tr[son[rt][0]];
        else tr[rt]=tr[son[rt][1]];
    }
    int Merge(int x,int y)
    {
        if(!x||!y)return x+y;
        int rt=++tot;
        son[rt][0]=Merge(son[x][0],son[y][0]);
        son[rt][1]=Merge(son[x][1],son[y][1]);
        if(son[rt][0]&&son[rt][1])tr[rt]=merge(tr[son[rt][0]],tr[son[rt][1]]);
        else if(son[rt][0])tr[rt]=tr[son[rt][0]];
        else tr[rt]=tr[son[rt][1]];
        return rt;
    }
}T;
int root[maxn],cnt=0,lst;
int son[maxn][10],fa[maxn];
int len[maxn],pos[maxn],up[maxn][19],dep[maxn];
void Add(int c,int id)
{
    int cur=++cnt,p=lst;
    lst=pos[id]=cur,len[cur]=len[p]+1;
    while(p&&!son[p][c])son[p][c]=cur,p=fa[p];
    if(!p)fa[cur]=1;
    else 
    {
        int q=son[p][c];
        if(len[p]+1==len[q])fa[cur]=q;
        else 
        {
            int nq=++cnt;len[nq]=len[p]+1;
            memcpy(son[nq],son[q],sizeof(son[q]));
            fa[nq]=fa[q],fa[q]=fa[cur]=nq;
            while(p&&son[p][c]==q)son[p][c]=nq,p=fa[p];
        }    
    }    
}
int n;
int head[maxn],ecnt=0;
struct edge{int v,nxt;}e[maxn<<1];
void add(int u,int v){e[++ecnt]=(edge){v,head[u]},head[u]=ecnt;}
void dfs(int u)
{
    up[u][0]=fa[u];
    for(int i=1;i<=18;i++)up[u][i]=up[up[u][i-1]][i-1];
    for(int i=head[u];~i;i=e[i].nxt)
    {
        int v=e[i].v;
        dep[v]=dep[u]+1;
        dfs(v);
        if(u!=1)root[u]=T.Merge(root[u],root[v]);
    }
}
void build()
{
    memset(head,-1,sizeof(head)),ecnt=0;
    for(int i=1;i<=cnt;i++)if(fa[i])add(fa[i],i);
    for(int i=1;i<=n;i++)T.update(1,n,root[pos[i]],i);
    dfs(1);
}
long long C(int len)
{
    if(len<2)return 0;
    return len*1LL*(len-1)/2;
}
long long query(int l,int r)
{
    int Len=r-l+1,u=pos[r];
    for(int i=18;i>=0;i--)if(len[up[u][i]]>=Len)u=up[u][i];
    int L=tr[root[u]].Min,R=tr[root[u]].Max;
    if(L<R-Len*2+1&&T.Find_Max(1,n,root[u],L,R-Len)-Len+1>L)return C(n-1);
    if(R-Len+1<=L)
    {
        Node now=tr[root[u]];
        int lm=R-Len+1;
        long long ans=now.sum1-now.sum2*lm+C(L-lm)+(L-lm)*1LL*(n-Len);
        return C(n-1)-ans;
    }
    else 
    {
        T.tmp=(Node){0,0,0,0};
        int lm=R-Len+1,poslm=T.Find_Max(1,n,root[u],1,lm);
        T.Query(1,n,root[u],poslm,L+Len-1);
        Node now=T.tmp;
        int p1=T.Find_Max(1,n,root[u],1,L+Len-1);
        int p2=T.Find_Min(1,n,root[u],L+Len,n);
        long long ans=now.sum1-now.sum2*lm+(p2>lm?(L-(p1-Len+1))*1LL*(p2-lm):0);
        return C(n-1)-ans;
    }
}
char s[maxn];
int q;
int main()
{
    scanf("%d%d",&n,&q);
    scanf("%s",s+1);
    cnt=lst=1;
    for(int i=1;i<=n;i++)Add(s[i]-'0',i);
    build();
    while(q--)
    {
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%lld\n",query(l,r));
    }
}
```



---

## 作者：Tgotp (赞：17)

写起来复杂，但是说起来并不复杂的一道题。。。

首先这题如果直接考虑满足条件的会发现极为毒瘤。

反过来考虑用总方案-不满足条件的就会友好的多。

考虑如何求不满足条件的。

发现实际上本质就是用两条线穿过所有的串$s_{l,r}$

设现在有$m$个串，第$i$串的左右端点为$l_i,r_i$

那么在不考虑离$r_1$最近的$l_i$时，答案为$\sum (r_{i+1}-r_i)*(r_{i+1}-l_m)$

发现这玩意不好维护

拆开发现容易维护

$\sum (r_{i+1}-r_i)*r_{i+1}$

$\sum (r_{i+1}-r_i)*l_m$

限制条件分别为

$r_{i+1} <= r_1$

$r_{i+1} >= l_m$

那么这一段即可用线段树维护了。

接下来考虑离$r_1$最近的$l_i$这中间产生的贡献。

会出现两种情况，

第一种$l_i <= r_1$，这种情况随便在$[l_i,r_1]$取一点便满足条件

第二种$r_1 < l_n$,这种情况方案便是两段交的乘积

想清楚接下来就很好写了，求出SAM,然后倍增调到对应节点。

对应节点上用线段树合并即可

另外注意细节就是了，详见代码QAQ


c++代码如下：
```
#include<bits/stdc++.h>
#define rep(i,x,y) for(register int i = x;i <= y; ++ i)
#define repd(i,x,y) for(register int i = x;i >= y; -- i)
using namespace std; 
typedef long long ll;
template<typename T>inline bool chkmin(T&x,T y) { return x > y ? x = y, 1 : 0; }
template<typename T>inline bool chkmax(T&x,T y) { return x < y ? x = y, 1 : 0; }
template<typename T>inline void read(T&x)
{
	char c;int sign = 1;x = 0;
	do { c = getchar(); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}
const int N = 2e5 + 50;
struct SAM
{
	int ch[10],pre,len,pos,sz;
}t[N];
int sz = 1,root = 1,lst = 1;

inline int insert(int x,int i)
{
	int p = lst,np = ++ sz;	
	t[np].len = t[p].len + 1; t[np].sz = 1; t[np].pos = i;
	for(;p && !t[p].ch[x];p = t[p].pre) t[p].ch[x] = np;
	if(!p) t[np].pre = root;
	else
	{
		int q = t[p].ch[x];
		if(t[q].len == t[p].len + 1) t[np].pre = q;
		else
		{
			int nq = ++ sz;
			t[nq] = t[q];
			t[nq].pos = 0; t[nq].sz = 0;
			t[nq].len = t[p].len + 1;
			t[q].pre = t[np].pre = nq;
			for(;p&&t[p].ch[x] == q;p=t[p].pre) t[p].ch[x] = nq;
		}
	}

	lst = np;
	return np;
}

const int M = 2e7 + 60;
int rt[N],Rt[50],ls[M],rs[M],mx[M],mi[M],cnt;
ll val1[M],val2[M]; 

void ins(int&x,int l,int r,int pos,int nxt)
{
	int y = x; x = ++ cnt;
	ls[x] = ls[y];rs[x] = rs[y];
	if(l == r)
	{
		mi[x] = mx[x] = nxt;
		val1[x] = 1ll * (nxt - pos) * nxt;
		val2[x] = nxt - pos;
		return ;
	}
	int mid = l + r >> 1;
	if(pos <= mid) ins(ls[x],l,mid,pos,nxt);
	else ins(rs[x],mid+1,r,pos,nxt);
	mx[x] = max(mx[ls[x]],mx[rs[x]]); 
	mi[x] = min(mi[ls[x]],mi[rs[x]]);
	val1[x] = val1[ls[x]] + val1[rs[x]];
	val2[x] = val2[ls[x]] + val2[rs[x]];
}

int n;

int Tak[50],Top;
set<int> s[50];
set<int> :: iterator it,it1;

inline void add(int x,int w)
{
	if(!w) return ;

	it1 = s[x].lower_bound(w);	

	if(s[x].empty())
	{
		ins(Rt[x],1,n,w,1e7);	
	}
	else if(it1 == s[x].end())
	{
		-- it1;
		ins(Rt[x],1,n,w,1e7);
		ins(Rt[x],1,n,*it1,w);
	}
	else if(it1 == s[x].begin())
	{
		ins(Rt[x],1,n,w,*it1);
	}
	else
	{
		ins(Rt[x],1,n,w,*it1);
		-- it1;
		ins(Rt[x],1,n,*it1,w);
	}

	s[x].insert(w);
}

int tot = 1;
inline void merge(int x,int y)
{
	it = s[y].begin();	
	while(it != s[y].end())
		add(x,*(it++));
	s[y].clear();
	Tak[++Top] = y;
	Rt[y] = 0;
}

vector<int> g[N];
void dfs1(int x) { for(auto&i:g[x]) { dfs1(i); t[x].sz += t[i].sz; } }

int L[N],R[N];
void dfs(int x,int z)
{
	int mx = -1,hson;
	for(auto&i:g[x])
		if(chkmax(mx,t[i].sz))
			hson = i;
	
	if(~mx)
	{
		dfs(hson,z);
		for(auto&i:g[x]) if(i != hson)
		{
			int q = Top ? Tak[Top--] : ++ tot;
			dfs(i,q);
			merge(z,q);
		}
	}

	add(z,t[x].pos);	
	rt[x] = Rt[z];

	it = s[z].begin(); L[x] = *it;
	it = s[z].end(); if(it!=s[z].begin()) { -- it; R[x] = *it;}
}

ll find(int x,int l,int r,int l1,int l2,int len)
{
	//printf("%d %d %d %d %d\n",l,r,mx[x],l1,l2);
	if(mi[x] - len > l1 || mx[x] < l2 - len) return 0;
	if(mx[x] - len <= l1 && mi[x] >= l2 - len) return val1[x] - val2[x] * (l2 - len);
	int mid = l + r >> 1;
	if(l1 >= mi[rs[x]] - len) return find(ls[x],l,mid,l1,l2,len) + find(rs[x],mid+1,r,l1,l2,len);
	else return find(ls[x],l,mid,l1,l2,len);
}

int fnxt(int x,int l,int r,int pos)
{
	if(l == r) return mi[x];
	int mid = l + r >> 1;
	if(mx[ls[x]] > pos) return fnxt(ls[x],l,mid,pos);
	else return fnxt(rs[x],mid+1,r,pos);
}

int fqmxl(int x,int l,int r,int pos,int len)
{
	if(mx[x] - len + 1 <= pos) return mx[x] - len + 1;
	if(!x) return n + 1;
	int mid = l + r >> 1;
	if(mi[rs[x]] - len + 1 <= pos) return fqmxl(rs[x],l,mid,pos,len);
	else return fqmxl(ls[x],mid+1,r,pos,len);
}

inline ll get(int r,int l,int len,int now)
{
	l = l - len + 1;	
	if(l >= r)
	{
		int qmxl = r - len + 1;
		chkmax(qmxl , fqmxl(rt[now],1,n,r,len));
		int z = fnxt(rt[now],1,n,qmxl + len - 1);
		if(z <= l) return 0;
		return 1ll * (r - qmxl) * (z - l);
	}
	int k = l - (r - len + 1);
	len = r - l + 1;
	return 1ll * (n - len - k) * (len-1) + (1ll * (len - 2) * (len-1)/2);
}

int q,pos[N];
char S[N];

int p[N][21];

int main()
{
	//freopen("cutting20.in","r",stdin);
	//freopen("hnta.out","w",stdout);
	mi[0] = 1e7;
	
	read(n); read(q);
	scanf("%s",S + 1);

	rep(i,1,n) pos[i] = insert(S[i]-'0',i);

	rep(i,1,sz) g[t[i].pre].push_back(i);

	dfs1(root); dfs(root,1);

	rep(i,1,sz) p[i][0] = t[i].pre;
	rep(j,1,20) rep(i,1,sz) p[i][j] = p[p[i][j-1]][j-1];	

	ll ans = 1ll * (n - 1) * (n - 2) / 2;
	//cout << ans << endl;
	while(q--)
	{
		int l,r; read(l); read(r);
		if(l > n || l < 1 || r > n || r < 1 || r < l) 
		{
			printf("%lld\n",ans);
			continue;
		}
		int now = pos[r],len = r - l + 1; 
		repd(i,20,0) if(t[p[now][i]].len >= len) now = p[now][i];
		printf("%lld\n",ans - find(rt[now],1,n,L[now],R[now],len-1) - get(L[now],R[now],len,now));
	}

	return 0;
}
  ```

---

## 作者：shadowice1984 (赞：17)

从去年九省联考咕咕咕到现在的一道题

~~细节相当烦人并且码量巨大，做好码4~5个kb的心理准备~~

____________________

### 前置芝士:后缀自动机(SAM)

如果你不知道什么是后缀自动姬或者知道后缀自动姬是什么但是想学的人

~~可以出门左转你站模板区包教包会~~

~~讲个笑话，SAM很休闲的~~

### 前置芝士:线段树合并

如果你不知道什么是线段树合并的话尽管你站没有他的膜板不过例题还是有几道，可以去看看[这个博客](https://www.luogu.org/blog/styx-ferryman/xian-duan-shu-ge-bing-zong-ru-men-dao-fang-qi)然后做做里面的例题大概就可以get到这是一种怎样的算法了

~~讲个笑话，线段树合并挺休闲的~~

### 前置芝士:树上倍增

~~蛤？敢淦九省联考题不会树上倍增？你可以暂时不用看这篇题解了~~
___________________

# 本题题解

~~一句话题解:SAM倍增线段树合并三连，然后分情况讨论一下就做完了~~

~~当然这样写题解的人就该打死,我们还是好好讲下这题该怎么做~~

那么我们来复述一下并不明确的题意

给定一个字符串，每次询问一个子串$(l,r)$问你有多少中把这个字符串切成三段的方式使得每一段当中都含有一个和$(l,r)$这个子串一样的串

## 正难则反

那么显然直接做不是非常好做那么我们正难♂则反一下，我们用${n-1 \choose 2}$(所有可能的切割方案)减去**将这个字符串切成三段，每一段都不出现和$(l,r)$这个子串一样的串**的方案数

那么我们假设$(l,r)$这个串在原串当中的一些位置$(lx,rx)$出现了,我们将所有出现位置的右端点构成的集合记为$Right$假设我们通过某种奥妙重重的手段get到了$(l,r)$这个区间的$Right$集合,那么让我们来看一看如何统计将这个字符串切成三段并且每段都不出现$(l,r)$的方案数

以下我们将和$(l,r)$这段子串长的一样的字符串称之为目标串

### case1:出现了三个互不相交的目标串

根据抽屉原理你此时的方案数目肯定是0,因为你无论切到那两个字符串上第三个字符串总会被剩下

### case2:没有出现三个互不相交的目标串

这种情况下我们的方案数目可能不是0了.那么我们依然需要继续分情况讨论

我们令leftpos表示right集合中的最小值(换句话说就是最靠左的右端点),ed表示最靠右的左端点(换句话说ed等于right集合当中的最大值减去询问串的长度+1)

### case2.1:最靠左的目标串和最靠右的目标串是相交的

根据这个条件我们可以立即推出一个重要的事实是,所有目标串彼此是相交的,没有两个串互相分离

那这个性质有什么用呢？

我们可以将方案分成两类来进行统计

### case2.1.1第一刀没有切完全部的目标串

那么我们依然会发现三个重要的性质可以帮助我们加速统计

第一，当第一刀固定在i这个位置的时候，合法的第二刀位置j的取值范围**是一段连续的区间**

 _这个性质相当好证明，第二刀必须切完剩下的所有目标串，显然只有切在剩下的线段的交集上才能切完,线段的交必然还是一段连续的线段,所以j的取值范围就是一段连续的区间_ 

第二,如果第一刀切在p上，第二刀切在q上，那么**p和q切掉的线段集合相同时**p和q对应的合法的第二刀区间相同

 _切完之后剩下的线段相同同自然剩下的线段的交集也是相同的_ 

第三,第二刀取值范围相同的第一刀位置也**构成了一个连续的区间**

 _由于所有线段的长度都是一样的，因此我们第一刀的位置在从左向右挪动的过程中每经过一个串才会多切一个线段，而在切完第i个串到切第i+1个串之间的区间所切的线段集合是不变的，自然第二刀的取值范围也相同_ 
 
那么有了这些性质我们能干什么呢？

我们可以枚举第一刀的位置，并且将所有第二刀限制相同的第一刀位置用乘法分配律合并起来

换句话说,我们的式子就是这个，其中$rt_{i}$表示从左数第i个目标串的右端点

$$\sum_{i}((rt_{i+1}-len+1)-(rt_{i}-len+1))(rt_{i+1}-ed)$$

解释一下上面的式子就是第一刀在$(rt_{i+1}-len+1,rt_{i}-len+1)$的时候,第二刀的取值范围都是$(ed,rt_{i+1})$(因为$rt_{i+1}$是剩下的线段的右端点最小值,而ed是左端点的最大值)

所以两个区间长度直接乘起来就好了

简单化简一下式子就是

$$\sum_{i}(rt_{i+1}-r_{i})rt_{i+1}-ed\sum_{i}rt_{i+1}-rt_{i}$$

### case2.1.2 其中一刀切完了全部的字符串

那么显然其中必然有一刀落在了$(ed,leftpos)$这个区间里，那么我们假如两刀都落在了这个区间当中，我们的方案数就是${leftpos-ed \choose 2}$

接下来为了避免和上面的式子算重,我们考虑一下另一刀还可以放在哪里，我们发现刚才的式子当中已经统计好了第一刀落在$(leftpos-len+1,leftpos)$这个区间的方案数目了

所以我们现在有一刀落在了$(ed,leftpos)$这个区间，因此另一刀可能的取值范围就是$(1,leftpos-len)$和$(leftpos+1,n)$这两个区间

推一下式子就是

$${leftpos-ed \choose 2}+(leftpos-ed)(n-len)$$

所以我们最靠左和最靠右的目标串是相交的这个情况就是这个式子了

$$\sum_{i}(rt_{i+1}-r_{i})rt_{i+1}-ed\sum_{i}rt_{i+1}-rt_{i}+{leftpos-ed \choose 2}+(leftpos-ed)(n-len)$$

### case2.2 最靠左的目标串和最靠右的目标串并不相交

这种情况下由于我们知道并没有出现三个不相交的目标串，所以我们所有目标串就可以被分为三类

1.仅和最靠左的目标串相交

2.仅和最靠有的目标串相交

3.和两个串都相交

套用上一种情况的分析方式我们可以得出这个式子

$$\sum_{i}((rt_{i+1}-len+1)-(rt_{i}-len+1))(rt_{i+1}-ed)$$

但是和上一个情况不同的是这里需要加一点限制条件

$$rt_{i+1}>ed,rt_{i+1}+len-1<leftpos$$

另外一点需要注意的是这是对$rt_{i+1}$的限制，所以$rt_{1}<ed$并且应该是ed在right集合里的前驱

此时我们发现我们基本上计数完所有的方案了，但是我们还需要加上一点修正，就是上面的式子少统计了一种情况,也就是当我们的第一刀不断移动的时候,会在最后碰到$leftpos$而不是某一个串的左端点结束(在上一种情况当中不会出现这种情况,因为最后一个碰到的串的左端点是最右端的串,而后面的情况会一次性切断所有的串)

那么我们需要稍稍修正一下我们的式子，那就是我们查找一下$leftpos+len-1$在right集合中的前驱pre和后继suc，那么我们发现我们需要计算的情况就是第一刀的位置落在了$(pre-len+1,leftpos)$这个区间时的情况，那么我们发现此时第二刀的限制范围应该是$(ed,suc)$这个区间(因为右端点的最小值就是suc)

所以我们的式子就是这个式子(方括号用来规避非法情况)

$$(leftpos-pre+len+1)(suc-ed)[suc>ed]$$

然后把两种情况加起来就好了

## 维护right集合

前面的一系列推导都是基于我们可以通过某种奥妙重重的方式来get到right集合才能实现的,那么问题来了我们该如何维护right集合呢？

如果你对后缀自动姬那一套理论相当熟悉的话你会知道一个串的right集合就是这个串在后缀自动姬对应节点的right集合

那么我们想要知道一个后缀自动姬节点的right集合长什么样我们是没有办法直接知道的，我们知道这个点的right集合等于他在parent树的子树中所有点的right集合的并集

因此我们可以通过合并这个节点的孩子们的right集合来求出这个点的right集合了，这个东西在parent树上跑一个线段树合并就出来了

具体实现的时候对于后缀自动姬中每一个代表前缀缀i的节点我们把i这个元素插入到权值线段树中去，接下来在树上dfs，将这个点的孩子全部合并起来就是这个点的right集合了

那么问题来了我们如何定位一个子串在后缀自动姬上对应的节点位置呢？

一个相当暴力的想法是直接在后缀自动姬上大力跑这个子串可以确定这个子串的位置

不过另一种方式是通过树上倍增的方式不断的从parent树上表示前缀r的节点向上跳，一直保证对应节点的len值不小于我们这个子串的长度，这样倍增下去我们就可以快速的定位了

定位了之后我们就可以把这个询问挂到这个节点上了，最后在parent树上dfs一下就可以回答每一个询问了

线段树合并的时候为了回答每一询问我们需要维护的信息是

$$\sum_{i}(rt_{i+1}-rt_{i})rt_{i+1}$$

$$\sum_{i}(rt_{i+1}-rt_{i})$$

这个东西维护的方式也相当简单，我们线段树上每一个节点维护一下最大值和最小值，然后我们就可以愉快的合并两个节点的信息了也就可以维护了

同理我们也可以利用维护的最大值和最小值的信息快速的查询前驱和后继

复杂度$O((n+q)logn)$细节基本分情况讨论完了，关于实现时候的一些trick可以自行参考代码

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;const int N=1e5+10;typedef long long ll;
int n;int m;int v[2*N];int x[2*N];int al[2*N];int ct;char mde[N];
int len[2*N];ll ans[3*N];int fa[2*N][22];//倍增 
struct qry{int len;int tim;};vector <qry> vq[2*N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline void dfs1(int u)//预处理倍增数组 
{
    for(int i=0;fa[u][i];i++)fa[u][i+1]=fa[fa[u][i]][i];
    for(int i=al[u];i;i=x[i])fa[v[i]][0]=u,dfs1(v[i]);
}
inline int ck(int p,int le)//倍增定位 
{for(int i=20;i>=0;i--)if(fa[p][i]&&len[fa[p][i]]>=le)p=fa[p][i];return p;}
inline ll ctwo(ll p){return (p*(p-1))>>1;}
struct suffixautomaton//简易后缀自动姬膜板 
{
    int mp[2*N][10];int fa[2*N];int ct;
    inline void ih(){for(int i=1;i<=n;i++)len[i]=i;ct=n+1;}
    inline void ins(int i,int c)
    {
        int p=(i-1)?(i-1):(n+1);
        for(;p&&mp[p][c]==0;p=fa[p])mp[p][c]=i;
        if(!p){fa[i]=n+1;return;}int q=mp[p][c];
        if(len[q]==len[p]+1){fa[i]=q;return;}
        ++ct;len[ct]=len[p]+1;
        for(int i=0;i<=9;i++)mp[ct][i]=mp[q][i];
        for(;p&&mp[p][c]==q;p=fa[p])mp[p][c]=ct;
        fa[ct]=fa[q];fa[q]=ct;fa[i]=ct;
    }
    inline void build(){for(int i=1;i<=ct;i++)add(fa[i],i);}
}sam;
struct linetree//线段树合并板子 
{
    int mi[22*N];int mx[22*N];ll v1[22*N];ll v2[22*N];
    int s[22*N][2];int rt;ll ans1;ll ans2;int ct;
    inline void mg(const int& p)//合并这个节点的两个孩子 
    {
        int ls=s[p][0];int rs=s[p][1];
        if(!rs){mi[p]=mi[ls];mx[p]=mx[ls];v1[p]=v1[ls];v2[p]=v2[ls];return;}
        if(!ls){mi[p]=mi[rs];mx[p]=mx[rs];v1[p]=v1[rs];v2[p]=v2[rs];return;}
        mi[p]=mi[ls];mx[p]=mx[rs];ll del=mi[rs]-mx[ls];
        v1[p]=v1[ls]+v1[rs]+del*mi[rs];v2[p]=v2[ls]+v2[rs]+del;
    }
    inline void mg(int p1,int p2)//线段树合并 
    {
        if(s[p1][0]&&s[p2][0])mg(s[p1][0],s[p2][0]);else if(s[p2][0])s[p1][0]=s[p2][0];
        if(s[p1][1]&&s[p2][1])mg(s[p1][1],s[p2][1]);else if(s[p2][1])s[p1][1]=s[p2][1];mg(p1);
    }
    inline void ins(int p,int l,int r,int pos//插入一个节点
    {
        mi[p]=mx[p]=pos;if(r-l==1){return;}int mid=(l+r)/2;
        if(pos<=mid)ins(s[p][0]=++ct,l,mid,pos);
        else ins(s[p][1]=++ct,mid,r,pos);
    }
    inline int qmi(int p,int l,int r,int dl,int dr)//区间最小值 
    {
        if(dl==l&&dr==r){return mi[p];}int mid=(l+r)/2;ll res=0x3f3f3f3f;
        if(dl<mid&&s[p][0])res=qmi(s[p][0],l,mid,dl,min(dr,mid));
        if(res!=0x3f3f3f3f)return res;
        if(mid<dr&&s[p][1])return qmi(s[p][1],mid,r,max(dl,mid),dr);return 0x3f3f3f3f;
    }
    inline int qmx(int p,int l,int r,int dl,int dr)//区间最大值 
    {
        if(dl==l&&dr==r){return mx[p];}int mid=(l+r)/2;ll res=-0x3f3f3f3f;
        if(mid<dr&&s[p][1])res=qmx(s[p][1],mid,r,max(dl,mid),dr);
        if(res!=-0x3f3f3f3f)return res;
        if(dl<mid&&s[p][0])return qmx(s[p][0],l,mid,dl,min(dr,mid));return -0x3f3f3f3f;
    }
    inline void qry(int p,int l,int r,int dl,int dr)//询问的时候新开一个节点从左到右合并 
    {
        if(dl==l&&dr==r)
        {
            if(rt==-1){rt=mx[p];ans1=v1[p];ans2=v2[p];return;}
            else {ll del=mi[p]-rt;rt=mx[p];ans1+=v1[p]+mi[p]*del;ans2+=v2[p]+del;return;}
        }int mid=(l+r)/2;
        if(dl<mid&&s[p][0])qry(s[p][0],l,mid,dl,min(dr,mid));
        if(mid<dr&&s[p][1])qry(s[p][1],mid,r,max(dl,mid),dr);
    }
    inline ll cqry(int u,int l,int r,int st,int ed)
    {if(l>r)return 0;rt=st;ans1=0;ans2=0;qry(u,0,n,l-1,r);return ans1-ed*ans2;}
    inline ll calc(int p,int ed){return v1[p]-ed*v2[p];}
}lt;
inline void dfs2(int u)
{
    for(int i=al[u];i;i=x[i])dfs2(v[i]),lt.mg(u,v[i]);
    int lp=lt.mi[u];int rp=lt.mx[u];vector <qry> :: iterator  it;
    for(it=vq[u].begin();it!=vq[u].end();++it)
    {
        int ed=rp-it->len+1;//情况1 
        if(ed<=lp){ans[it->tim]+=lt.calc(u,ed)+ctwo(lp-ed)+(ll)(lp-ed)*(n-it->len);}
        else 
        {
            int pos=lt.qmx(u,0,n,0,ed);if(pos-it->len+1>=lp)continue;//判断3个字符串是否不相交可以查max来解决 
            ans[it->tim]+=lt.cqry(u,ed+1,lp+it->len-1,pos,ed);//这里传参数的时候直接把开头传进去了 
            int pos1=lt.qmi(u,0,n,lp+it->len-1,n);pos=lt.qmx(u,0,n,0,lp+it->len-1);
            if(pos!=-0x3f3f3f3f&&pos1!=0x3f3f3f3f)//修正 
                ans[it->tim]+=(lp-pos+it->len-1)*(pos1-ed)*(pos1>=ed);
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);scanf("%s",mde+1);sam.ih();
    for(int i=1;i<=n;i++)sam.ins(i,mde[i]-'0');
    lt.ct=sam.ct;sam.build();dfs1(n+1);
    for(int i=1,l,r;i<=m;i++)//离线 
        scanf("%d%d",&l,&r),vq[ck(r,r-l+1)].push_back((qry){r-l+1,i});
    for(int i=1;i<=n;i++)lt.ins(i,0,n,i);dfs2(n+1);
    for(int i=1;i<=m;i++)printf("%lld\n",ctwo(n-1)-ans[i]);return 0;//拜拜程序 
}

```















---

## 作者：dengyaotriangle (赞：6)

阿诺，大家都写的是 SAM，那我这个弱弱的只会 SA 的菜鸡该如何是好呢？

诶多... SA 和 SAM 是很相似的，那是不是可以搞出 SA 做法呢？

欸，真的可以欸，使用 SA 也可以在 $O(n\log n+q\log n)$  的时间内做掉它欸！

我们假设已经求出了 $s$ 的后缀数组，考虑 SA 的从大到小合并 height 的套路。把询问按照 $r-l+1$ 降序排序，并且将 height $\geq r-l+1$ 的间隔进行合并，那么 $\mathrm{rank}[l]$ 所在的段就是 $s[l:r]$ 的所有出现的位置。

考虑求出这个段的答案，正着考虑似乎不是很容易，考虑求出**不合法**的方案数。

我们考虑对于 $(i,j)$ ，$s[l:r]$ 没有出现在 $s[1:i],s[i+1:j-1],s[j:n]$ 中

那么对于所有 $s[l:r]$ 的出现位置（出现位置定义为出现的第一个字符的位置），取最小的 $X$,最大的 $Y$。

我们令 $L=r-l+1=|s[l:r]|$

那么为了 $s[1:i]$ 中没有出现，需要保证 $i\leq X+L-2$

为了 $s[j:n]$ 中没有出现，需要保证 $j\geq Y+1$

为了 $s[i+1:j-1]$ 中没有出现，则稍有些复杂，我们把比 $c$ 大的第一个 $s[l:r]$ 出现位置，记为 $\operatorname{next}(c)$（若没有则 $+\infty$）

那么有合法的话最左边的那个也必定合法，所以只需让最左边的非法即可，也就是 $\operatorname{next}(i)+L-1\geq j$

那么限制相当于 $1\leq i\leq \min(n-2,X+L-2),Y+1\leq j\leq n,i+1<j,\operatorname{next}(i)+L-1\geq j$

那么我们其实就是要求和式
$$\sum_{1\leq i\leq \min(n-2,X+L-2)}\sum_{j}[\min(n,\operatorname{next}(i)+L-1)\geq j> \max(i+1,Y)]$$

我们可以转化这个和式为
$$\sum_{1\leq i\leq \min(n-2,X+L-2)}[\min(n,\operatorname{next}(i)+L-1)\geq \max(i+1,Y)](\min(n,\operatorname{next}(i)+L-1)-\max(i+1,Y))$$

这不难理解，对于所有合法的 $j$ 都是一个区间，区间包含的元素个数就是两个端点的差，但是还要排除负的。

注意到一些事情：$\operatorname{next}(i)+L-1\geq i+1+1-1=i+1$，$n\geq Y$，$n\geq i+2>i+1$，这意味着：

$$[\min(n,\operatorname{next}(i)+L-1)\geq \max(i+1,Y)]=[\operatorname{next}(i)+L-1\geq Y]$$

那么就是

$$\sum_{1\leq i\leq \min(n-2,X+L-2)}[\operatorname{next}(i)+L-1\geq Y](\min(n,\operatorname{next}(i)+L-1)-\max(i+1,Y))$$

那么发现 $\operatorname{next}(i)+L-1\geq Y$ 这个条件相当于 $i\geq E$， 其中 $E$ 为最大的 $<Y-L+1$ 的 $s[l:r]$ 出现位置。若没有则设 $E=1$。

顺便为了好看设 $F=\min(n-2,X+L-2)$

于是就变成了
$$\sum_{E\leq i\leq F}(\min(n,\operatorname{next}(i)+L-1)-\max(i+1,Y))$$

注意到 $\max(i+1,Y)$  这一项比较简单，只需要分类讨论 $i+1$ 与 $Y$ 的关系即可，我们重点关注前面的。

$$\sum_{E\leq i\leq F}\min(n,\operatorname{next}(i)+L-1)$$

和之前 $E$ 差不多，考虑 $n-L+1\geq \operatorname{next}(i)$ 的意义。这相当于找到最后一个 $s[l:r]$ 出现位置 $\leq n-L+1$ 的点 $G$，然后要求 $i< G$

所以就是

$$\sum_{E\leq i\leq\min(F,G-1)}(\operatorname{next}(i)+L-1)+\sum_{\max(E,G)\leq i\leq F}n$$

右边的那个不用多说大家都会求，看左边的这个玩意


令$H=\min(F,G-1)$，
$$\sum_{E\leq i\leq H}(\operatorname{next}(i)+L-1)$$

$L-1$ 这一项也很容易计算，那我们也就是要考虑

$$\sum_{E\leq i\leq H}\operatorname{next}(i)$$


令 $A$ 为 $\operatorname{next}(H)$， $B$ 为 $\operatorname{next}(E)$，所有 $s[l:r]$ 出现位置排好序的数组为 $\{c_i\}$

那肯定可以找到 $L,R$ $c_L=B,c_R=A$，$L\leq R$，不妨假设 $L<R$，我们思考对于每一个 $j$，满足 $\operatorname{next}(i)=c_j(E\leq i\leq H)$ 的 $i$ 的个数。

对于 $L<j<R$，是 $c_j-c_{j-1}$ 个。对于 $j<L,R>r$，显然只有 $0$ 个。对于 $j=R$，有 $H-c_{j-1}+1$ 个。对于 $j=L$，有 $c_j-E$ 个。

上面的结论可以通过在纸上画几个 $c$ 数组和 $E,H$ 区间易得。

所以上述和 $=\sum\limits_{L<j\leq R}c_j(c_j-c_{j-1})+c_R(H-c_R+1)+c_L(c_L-E)$

$c_R(H-c_R+1)+c_L(c_L-E)=A(H-A+1)+B(B-E)$ ，可以直接求得，考虑 $\sum\limits_{L<j\leq R}c_j(c_j-c_{j-1})$。

考虑使用（权值线段树的）线段树合并来维护。对于每个连续段，维护它之内的 $\mathrm{sa}[i]$ 构成的集合，注意这个集合就相当于 $c$ 数组。

然后我们令每一个叶子 $u$ 的权值为 $u(u-\operatorname{prev}(u))$ ，其中 $\operatorname{prev}(u)$ 为线段树中 $u$ 的前驱（小于 $u$ 的第一个叶节点）

我们发现我们只需要维护以下量

- 该节点子树内权值和 sum 
- 该节点子树内最大的元素 max
- 该节点子树内最小的元素 min
- 该节点子树内最小的元素的 $\operatorname{prev}(u)$
- 一个标记 tag，代表欲将这个节点内最小的元素的 $\operatorname{prev}(u)$ 改成 $k$

具体来讲，pushdown 就是看有没有 tag，若有则更新 $\operatorname{prev}(u)$，sum，然后将 tag 下放到自己最左边的那个儿子上。

合并时，考虑按照顺序 dfs，同时维护一个值 $l$，代表dfs到的最右边的叶子。

若两个节点都非空，则 dfs 下去，否则若一个为空，拿 $l$ 去打给那个非空节点的 tag，然后拿非空节点的 max 更新 $l$。

然后我们发现，我们就可以支持区间权值和了。顺便我们也可以支持求前驱后继，这样我们上述过程中的所有量均可以每次 $O(\log n)$ 时间求得。

而线段树合并复杂度显然是 $O(n\log n)$，所以总复杂度 $O((n+q)\log n)$，跑得还蛮快的。

最后，用总方案数 $(n-1)(n-2)/2$ 减去刚才求的方案，就是真正的答案啦！

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

const int maxn=100005;
const int maxq=300005;

char s[maxn];
int rnk[maxn],sa[maxn],pre[maxn],cnt[maxn],h[maxn];
int n,q;
long long ans[maxq];

vector<pair<int,int> >qry[maxn];
vector<int> chg[maxn];

struct node{
    long long sum;
    int mi,mx,tg,prv;
    node* c[2];
}pool[maxn*55];int ps;

node* nwnode(){
    node* rt=pool+ps++;
    rt->mx=INT_MIN;rt->mi=INT_MAX;
    return rt;
}

void pd(node* rt){
    if(rt->tg){
        rt->sum+=rt->mi*(long long)(rt->prv-rt->tg);
        rt->prv=rt->tg;
        if(rt->c[0])rt->c[0]->tg=rt->tg;
        else if(rt->c[1])rt->c[1]->tg=rt->tg;
        rt->tg=0;
    }
}
int mlp;
node* mrg(node* a,node*b){
    if(!a&&!b)return NULL;
    else if(!a){
        if(mlp)b->tg=mlp;
        pd(b);
        mlp=b->mx;
        return b;
    }else if(!b){
        if(mlp)a->tg=mlp;
        pd(a);
        mlp=a->mx;
        return a;
    }
    pd(a);pd(b);
    a->c[0]=mrg(a->c[0],b->c[0]);
    a->c[1]=mrg(a->c[1],b->c[1]);
    a->mi=min(a->c[0]?a->c[0]->mi:INT_MAX,a->c[1]?a->c[1]->mi:INT_MAX);
    a->mx=max(a->c[0]?a->c[0]->mx:INT_MIN,a->c[1]?a->c[1]->mx:INT_MIN);
    a->prv=(a->c[0]?a->c[0]->prv:a->c[1]->prv);
    a->sum=(a->c[0]?a->c[0]->sum:0)+(a->c[1]?a->c[1]->sum:0);
    return a;
}

node* build(int cl,int cr,int x){
    node* rt=nwnode();
    rt->mi=rt->mx=x;rt->sum=x*(long long)x;
    if(cl!=cr){
        int cm=(cl+cr)>>1;
        if(x<=cm)rt->c[0]=build(cl,cm,x);
        else rt->c[1]=build(cm+1,cr,x);
    }
    return rt;
}

long long qsum(node* rt,int cl,int cr,int l,int r){
    if(!rt)return 0;
    int cm=(cl+cr)>>1;
    pd(rt);
    if(cl==l&&cr==r)return rt->sum;
    else if(r<=cm)return qsum(rt->c[0],cl,cm,l,r);
    else if(l>cm)return qsum(rt->c[1],cm+1,cr,l,r);
    else return qsum(rt->c[0],cl,cm,l,cm)+qsum(rt->c[1],cm+1,cr,cm+1,r);
}
int nxt(node* rt,int cl,int cr,int i){
    if(!rt)return INT_MAX;
    int cm=(cl+cr)>>1;
    if(cl==cr) return cl;
    else if(i<=cm)return min(nxt(rt->c[0],cl,cm,i),(rt->c[1]?rt->c[1]->mi:INT_MAX));
    else return nxt(rt->c[1],cm+1,cr,i);
}
int prv(node* rt,int cl,int cr,int i){
    if(!rt)return INT_MIN;
    int cm=(cl+cr)>>1;
    if(cl==cr)return cl;
    else if(i<=cm)return prv(rt->c[0],cl,cm,i);
    else return max(prv(rt->c[1],cm+1,cr,i),(rt->c[0]?rt->c[0]->mx:INT_MIN));
}

int pr[maxn];

int grt(int x){return pr[x]==x?x:pr[x]=grt(pr[x]);}
node* rt[maxn];

namespace nqio{const unsigned R=4e5,W=4e5;char*a,*b,i[R],o[W],*c=o,*d=o+W,h[40],*p=h,y;bool s;struct q{void r(char&x){x=a==b&&(b=(a=i)+fread(i,1,R,stdin),a==b)?-1:*a++;}void f(){fwrite(o,1,c-o,stdout);c=o;}~q(){f();}void w(char x){*c=x;if(++c==d)f();}q&operator>>(char&x){do r(x);while(x<=32);return*this;}q&operator>>(char*x){do r(*x);while(*x<=32);while(*x>32)r(*++x);*x=0;return*this;}template<typename t>q&operator>>(t&x){for(r(y),s=0;!isdigit(y);r(y))s|=y==45;if(s)for(x=0;isdigit(y);r(y))x=x*10-(y^48);else for(x=0;isdigit(y);r(y))x=x*10+(y^48);return*this;}q&operator<<(char x){w(x);return*this;}q&operator<<(char*x){while(*x)w(*x++);return*this;}q&operator<<(const char*x){while(*x)w(*x++);return*this;}template<typename t>q&operator<<(t x){if(!x)w(48);else if(x<0)for(w(45);x;x/=10)*p++=48|-(x%10);else for(;x;x/=10)*p++=48|x%10;while(p!=h)w(*--p);return*this;}}qio;}using nqio::qio;

int main(){
    qio>>n>>q>>(s+1);
    for(int i=1;i<=n;i++)cnt[s[i]]++;
    for(int i=1;i<128;i++)cnt[i]+=cnt[i-1];
    for(int i=n;i>=1;i--)sa[cnt[s[i]]--]=i;
    rnk[sa[1]]=1;
    for(int i=2;i<=n;i++)rnk[sa[i]]=rnk[sa[i-1]]+(s[sa[i]]!=s[sa[i-1]]);
    int m=rnk[sa[n]];
    for(int k=1;k<=n;k<<=1){
        int t=0;
        for(int i=n-k+1;i<=n;i++)pre[++t]=i;
        for(int i=1;i<=n;i++)if(sa[i]>k)pre[++t]=sa[i]-k;
        for(int i=1;i<=m;i++)cnt[i]=0;
        for(int i=1;i<=n;i++)cnt[rnk[i]]++;
        for(int i=1;i<=m;i++)cnt[i]+=cnt[i-1];
        for(int i=n;i>=1;i--)sa[cnt[rnk[pre[i]]]--]=pre[i];
        for(int i=1;i<=n;i++)pre[i]=rnk[i];
        rnk[sa[1]]=1;
        for(int i=2;i<=n;i++)rnk[sa[i]]=rnk[sa[i-1]]+(pre[sa[i]]!=pre[sa[i-1]]||pre[sa[i]+k]!=pre[sa[i-1]+k]);
        if((m=rnk[sa[n]])==n)break;
    }
    for(int i=1;i<=n;i++){
        if(rnk[i]==1)h[rnk[i]]=0;
        else{
            int ch=h[rnk[i-1]];ch-=!!ch;
            while(s[i+ch]==s[sa[rnk[i]-1]+ch])ch++;
            h[rnk[i]]=ch;
        }
    }
    for(int i=1;i<=n;i++)pr[i]=i,rt[i]=build(1,n,sa[i]);
    for(int i=2;i<=n;i++)chg[h[i]].push_back(i);
    for(int i=1;i<=q;i++){
        int l,r;
        qio>>l>>r;
        qry[r-l+1].push_back(make_pair(l,i));
    }
    for(int i=n;i>=1;i--){
        for(int j=0;j<chg[i].size();j++){
            int l=grt(chg[i][j]-1),r=grt(chg[i][j]);
            pr[r]=l;
            mlp=0;
            rt[l]=mrg(rt[l],rt[r]);
        }
        for(int j=0;j<qry[i].size();j++){
            int c=grt(rnk[qry[i][j].first]);
            long long cans=((long long)(n-1)*(n-2))>>1;
            int x=rt[c]->mi,y=rt[c]->mx;
            int e=(y-i<1)?1:max(1,prv(rt[c],1,n,y-i)),f=min(n-2,x+i-2);
            if(e<=f){
                int sp=min(y-2,f);
                if(e<=sp)cans+=y*(long long)(sp-e+1);
                int bp=max(y-1,e);
                if(bp<=f)cans+=((f-bp+1)*(long long)(bp+1+f+1))>>1;
                int g=max(1,prv(rt[c],1,n,n-i+1));
                if(max(e,g)<=f)cans-=(f-max(e,g)+1)*(long long)n;
                int h=min(f,g-1);
                if(e<=h){
                    cans-=(i-1)*(long long)(h-e+1);
                    int a=nxt(rt[c],1,n,h+1);
                    int b=nxt(rt[c],1,n,e+1);
                    if(a==b)cans-=(h-e+1)*(long long)a;
                    else{
                        cans-=b*(long long)(b-e);
                        cans-=a*(long long)(h-a+1);
                        cans-=qsum(rt[c],1,n,b+1,a);
                    }
                }
            }
            ans[qry[i][j].second]=cans;
        }
    }
    for(int i=1;i<=q;i++)qio<<ans[i]<<'\n';
    return 0;
}
```

---

## 作者：Alex_Wei (赞：6)

Upd on 2022.6.9：重写了一篇题解，原题解见 [链接](https://www.luogu.com.cn/paste/b4pcmzxu)。

令 $t = s_{l, r}$，下文 $l, r$ 表示其它内容。

限制通过 “或” 连接，分类讨论较麻烦，考虑容斥求 $s_{1, i}$，$s_{i + 1, j}$，$s_{j + 1, n}$ 均不包含 $t$ 的 $1\leq i < j < n$ 对数。即在 $n - 1$ 个空隙处切两刀，使得切出来的三个字符串均不包含 $t$。

考虑固定了第一刀的位置在 $i$ 和 $i + 1$ 之间后，有多少个空隙 $j\sim j + 1$ 符合条件。

1. 若 $s_{i + 1, n}$ 当中没有出现 $t$，则第二刀可以切在任何一个位置，共有 $n - (i + 1)$ 种方案。
2. 否则，对于 $s_{i + 1, n}$，令 $t$ 第一次出现为 $s_{p - L + 1, p}(L = r - l + 1)$，最后一次出现为 $s_{q - L + 1, q}$，那么第二刀必须切在 $s_{q - L + 1, p}$ 中间，方案数即 $p - (q - L + 1)$。

这样已经可以做 $\sum r - l + 1\leq 10 ^ 6$ 的部分分了：建出 SAM，线段树合并维护 endpos 集合，倍增跳到 $t$ 对应状态。查询上述信息是基础中的基础。

直接考虑第一刀的位置没有前途，我们转换贡献方式。

先考虑较简单的 case 1：$s_{i + 1, n}$ 没有出现 $t$。只需找到第一次出现和最后一次出现的重合部分 $s_{l', r'}$，若其非空，则答案加上 $\sum\limits_{i = l'} ^ {r' - 1} n - (i + 1)$。等差数列求个和即可。

case 2 较为棘手。注意到每次 $t$ 的出现 $s_{p - L + 1, p}$ 对答案的贡献为：使得 $t$ 第一次出现在 $s_{i + 1, n}$ 是 $s_{p - L + 1, p}$ 的第一刀（$i\sim i + 1$）的方案数，乘以第二刀方案数。

后者我们已经分析过了，是 $p - (q - L + 1)$，其中 $q$ 是 $t$ 最后一次出现的位置（$s_{q - L + 1, q} = t$ 且 $q$ 最大），它是关于每次询问的 $l, r$ 的定值，可以视作常数（线段树合并容易求解 $q$）。

前者仔细分析，容易得到为 $p - pre$，其中 $pre$ 是 $p$ 之前的 $t$ 在 $s$ 当中的出现位置，即 $s_{pre - L + 1, pre} = t$ 且 $pre < p$ 且 $pre$ 最大。这是因为若 $i < pre - L + 1$，则 $s_{i + 1, n}$ 第一次出现 $t$ 是在 $pre$ 或之前；而 $i$ 需要小于等于 $p - L$，否则第一次出现 $t$ 是在 $p$ 之后，所以 $pre - L + 1 \leq i \leq p - L$，即 $i$ 有 $(p - L) - (pre - L + 1) + 1 = p - pre$ 种取值。

有一个细节，就是 $p - (q - L + 1)$ 要和 $0$ 取 $\max$，因为当 $p - (q - L + 1) < 0$ 时，移下项发现 $p \leq q - L$，即 $s_{i + 1, n}$ 出现了两次 $t$ 的不重叠的出现，此时第二刀无论如何都无法满足条件。因此我们需要保证 $p - (q - L + 1) \geq 0$。

综合起来，对于 case 2，第一刀的位置有这些限制：

- 左端点 $\geq 1$。
- 左端点 $\geq u - L + 1$，其中 $u$ 是 $s_{1, q - L}$ 当中 $t$ 的最后一次出现，这是为了保证 $p - (q - L + 1) \geq 0$，不存在则可视为 $-\infty$。
- 右端点 $\leq q - L$，这是为了保证 case 2 的前提条件 $s_{i + 1, n}$ 出现 $t$。
- 右端点 $\leq f - 1$，其中 $f$ 是 $s$ 当中 $t$ 的第一次出现。这是为了保证 $s_{1, i}$ 当中不出现 $t$。

令 $l = max(1, u - L + 1)$，$r = min(q - L, f - 1)$，第一刀的范围即 $i\in [l, r]$。

考虑当 $s_{p - L + 1, p}$ 作为 $s_{i + 1, n}$ 第一次出现时 $i$ 的取值范围，上文分析过是 $[pre - L + 1, p - L]$。因此答案即对于 $t$ 在 $s$ 中所有出现位置 $p$，
$$
\sum\limits_p |[pre - L + 1, p - L] \cap [l, r] \cap \mathbb Z| \times (p - (q - L + 1))
$$
注意 $q - L + 1$ 是定值，可以视为常数。

消除 $[l, r]$ 的限制是容易的。考虑使得 $[pre - L + 1, p - L]$ 完全包含于 $[l, r]$ 的 $(pre, p)$ 二元组，我们发现令 $P = \mathrm{endpos}(t) \cap [l + L - 1, r + L]$，即 $[l + L - 1, r + L]$ 当中所有 $t$ 在 $s$ 中的出现位置，按顺序记做 $p_1, p_2, \cdots, p_k$，则其内部的贡献为 $\sum\limits_{i = 2} ^ k (p_i - p_{i - 1})(p_i - (q - L + 1))$。当然，还需加上 $p_1$ 与其 $pre$ 的贡献 $(p_1 - (l + L - 1))(p_1 - (q - L + 1))$，以及 $p_k$ 与 $t$ 在 $p_k$ 下一次出现位置 $suf$ 的贡献 $((r + L) - p_k)(suf - (q - L + 1))$。

$(pre, p_1)$ 和 $(p_k, suf)$ 的贡献只有 $\mathcal{O}(1)$ 次，是平凡的。将 $p_0$ 视作 $l + L - 1$ 可以减少讨论 $(pre, p_1)$ 的情况。唯一麻烦的地方在于 $\sum (p_i - p_{i - 1})(p_ i - (q - L + 1))$。拆成 $\sum (p_i - p_{i - 1})p_i$ 和 $\sum (p_i - p_{i - 1})(q - L + 1)$，发现我们只需维护 $\sum (p_i - p_{i - 1})p_i$（$\sum p_i - p_{i - 1}$ 就是最大位置减去最小位置），即每个位置的下标乘以它到它的前驱距离之和，线段树很容易做到这一点。

综上，case 2 的答案式为
$$
\left(\sum\limits_{i = 1} ^ k (p_i - p_i - 1) p_i\right) + (r + L - p_k)\times suf - (r - l + 1) \times (q - L + 1)
$$
其中 $r - l + 1$ 由 $(p_1 - (l + L - 1)) + \left(\sum\limits_{i = 2} ^ k p_i - p_{i - 1}\right) + (r + L - p_k)$ 化简得到，本质上是 $[l, r]$ 所包含的整数个数。

线段树合并维护 endpos 集合及其相关信息：区间最小最大值，以及区间每个位置的下标乘以它到它的前驱距离之和，时间复杂度 $\mathcal{O}((n + q)\log n)$，空间复杂度 $\mathcal{O}(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 2e5 + 5;
constexpr int S = 10;
constexpr int K = N * 40;
struct dat {
  int l, r;
  long long val;
  dat(int _l = N, int _r = -1, long long _v = -1) {l = _l, r = _r, val = _v;}
  dat operator + (const dat &rhs) const {
    if(r == -1) return rhs;
    if(rhs.r == -1) return *this;
    return dat(l, rhs.r, val + rhs.val + 1ll * rhs.l * (rhs.l - r));
  }
} val[K];
int node, R[N], ls[K], rs[K];
void insert(int l, int r, int p, int &x) {
  x = ++node;
  if(l == r) return val[x] = dat(p, p, 0), void();
  int m = l + r >> 1;
  if(p <= m) insert(l, m, p, ls[x]);
  else insert(m + 1, r, p, rs[x]);
  val[x] = val[ls[x]] + val[rs[x]];
}
int merge(int x, int y) {
  if(!x || !y) return x | y;
  int z = ++node;
  ls[z] = merge(ls[x], ls[y]);
  rs[z] = merge(rs[x], rs[y]);
  return val[z] = val[ls[z]] + val[rs[z]], z;
}
dat query(int l, int r, int ql, int qr, int x) {
  if(ql > qr) return dat();
  if(ql <= l && r <= qr) return val[x];
  int m = l + r >> 1;
  dat ans;
  if(ql <= m) ans = ans + query(l, m, ql, qr, ls[x]);
  if(m < qr) ans = ans + query(m + 1, r, ql, qr, rs[x]);
  return ans;
}
int n, q, lg, ed[N], anc[S << 1][N];
int las = 1, cnt = 1, son[N][S], fa[N], len[N], buc[N], id[N];
void ins(int it) {
  int p = las, cur = ++cnt;
  las = cur, len[cur] = len[p] + 1;
  insert(1, n, len[cur], R[cur]);
  ed[len[cur]] = cur;
  while(!son[p][it]) son[p][it] = cur, p = fa[p];
  if(!p) return fa[cur] = 1, void();
  int q = son[p][it];
  if(len[p] + 1 == len[q]) return fa[cur] = q, void();
  int cl = ++cnt;
  len[cl] = len[p] + 1, fa[cl] = fa[q];
  fa[q] = fa[cur] = cl;
  memcpy(son[cl], son[q], S << 2);
  while(son[p][it] == q) son[p][it] = cl, p = fa[p];
}
char s[N];
int main() {
#ifdef ALEX_WEI
  freopen("1.in", "r", stdin);
  freopen("1.out", "w", stdout);
#endif
  scanf("%d%d%s", &n, &q, s + 1);
  for(int i = 1; i <= n; i++) ins(s[i] - '0');
  for(int i = 1; i <= cnt; i++) buc[len[i]]++;
  for(int i = 1; i <= n; i++) buc[i] += buc[i - 1];
  for(int i = cnt; i; i--) id[buc[len[i]]--] = i;
  for(int i = cnt; i; i--) R[fa[id[i]]] = merge(R[fa[id[i]]], R[id[i]]);
  for(int i = 1; i <= cnt; i++) anc[0][i] = fa[i];
  lg = log2(cnt);
  for(int i = 1; i <= lg; i++)
    for(int j = 1; j <= cnt; j++)
      anc[i][j] = anc[i - 1][anc[i - 1][j]];
  for(int i = 1; i <= q; i++) {
    int pl, pr, L, p;
    long long ans = 0;
    scanf("%d%d", &pl, &pr);
    p = ed[pr], L = pr - pl + 1;
    for(int j = lg; ~j; j--) if(len[anc[j][p]] >= L) p = anc[j][p];
    dat whole = val[R[p]];
    if(whole.l - 1 >= whole.r - L + 1) {
      int l = whole.r - L + 1, r = whole.l - 1;
      int sl = n - r - 1, sr = n - l - 1;
      ans += 1ll * (sl + sr) * (sr - sl + 1) / 2;
    }
    int l = max(1, query(1, n, 1, whole.r - L, R[p]).r - L + 1);
    int r = min(whole.r - L, whole.l - 1);
    if(l <= r) {
      dat inside = dat(l + L - 1, l + L - 1, 0) + query(1, n, l + L, r + L, R[p]);
      ans += inside.val - 1ll * (r - l + 1) * (whole.r - L + 1);
      if(inside.r < r + L) {
        dat rt = query(1, n, r + L + 1, n, R[p]);
        ans += 1ll * (r + L - inside.r) * rt.l; 
      }
    }
    printf("%lld\n", 1ll * (n - 1) * (n - 2) / 2 - ans);
  }
  return 0;
}
/*
2022/6/9
start coding at 13:41
finish debugging at 15:37
*/
```

---

## 作者：MoYuFang (赞：5)

本文起笔于```2021.11.23```。

[P4384 [八省联考2018]制胡窜](https://www.luogu.com.cn/problem/P4384)

知识点：后缀数组 + 容斥 + 线段树合并。

读完题基本可以确认，这题跟 $\text{AC}$ 自动机没有关系，那就往后缀家族方面考虑，最简单的就是后缀数组。

询问问的是合法方案数，且直接考虑询问的答案有些难，这时候有两种可能的方向，一种是正难则反，一种是容斥，解题时我用的是容斥，别的题解用的好像都是正难则反。

设性质 $A$ 表示 $s_{1,i}$ 包含 $s_{l,r}$，性质 $B$ 表示 $s_{i+1,j-1}$ 包含 $s_{l,r}$，性质 $C$ 表示 $s_{j,n}$ 包含 $s_{l,r}$，$P(T)$ 表示有性质 $T$ 的合法方案数，则答案为：
$$
ans=P(A\cup B\cup C) = P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)
$$
 建完后缀数组 $sa$ 及 $height$ 数组后，方便的是可以快速求出哪些子串与 $s_{l,r}$ 相同，再注意到题目是离线的，所以基本的思路框架就可以确定了，将所有询问按字符串长度从大到小排序，然后依次处理，在处理的过程中不断用线段树合并和并查集将 $\text{lcp}$ 大于等于当前字符串长度的后缀合并到同一连通块，然后利用数据结构求出 $ans$。

考虑某次询问 $s_{l,r}$。

若 $l=r$，则所有方案都合法，答案为 $(n-1)(n-2)/2$。

若 $r-l+1\geq n-1$，此时没有方案合法，答案为 $0$。

否则就用容斥。 

设 $s_{l,r}$ 的长度为 $len$，与 $s_{l,r}$ 相同的字符串有 $e_1$ 个（包括 $s_{l,r}$），它们开头的位置分别为 $p_i$，同时设 $s=p_1$，$t=p_e$。

首先可以发现 $P(A),P(C),P(AC)$ 比较好求：
$$
P(A)=\sum_{i=s+len-1}^{n-2}\sum_{j=i+2}^{n}1\\
P(C)=\sum_{i=1}^{t-2}\sum_{j=i+2}^{t}1\\
P(AC)=\sum_{i=s+len-1}^{t-2}\sum_{j=i+2}^{t}1
$$
观察到这三个式子长的很像，可以用一个函数代替，于是设：
$$
f(a,b)=\sum_{i=a}^{b-2}\sum_{j=i+2}^{b}1=(b-a)(b-a-1)/2
$$
则有：
$$
P(A)=f(s+len-1,n)\\
P(C)=f(1,t)\\
P(AC)=f(s+len-1,t)
$$
注意当 $b<a+2$ 时 $f(a,b)=0$。

而其它带上性质 $B$ 的 $P(B),P(AB),P(BC),P(ABC)$ 则非常棘手。

经过一番思考可以发现，求 $P(B),P(AB),P(BC),P(ABC)$ 四者的关键是会求 $P(B)$，其它三者可用通过类似的方法得到。

于是设 $g(a,b)$ 表示当 $i\geq a$ 和 $j\leq b$ 时满足性质 $B$ 即 $s_{i+1,j-1}$ 包含 $s_{l,r}$ 的方案数，则有：
$$
P(B)=g(1,n)\\
P(AB)=g(s+len-1,n)\\
P(BC)=g(1,t)\\
P(ABC)=g(s+len-1,t)\\
$$
所以接下来只需要关注如何不重不漏地求出 $g(a,b)$。

$g(a,b)$ 的含义是当 $i\geq a\wedge j\leq b$ 时 $s_{i+1,j-1}$ 中包含字符串 $s_{l,r}$ 的合法方案数，这至少要求了 $s_{i+1,j-1}$ 长度要大于等于 $len$，也即至少要有一个与 $s_{l,r}$ 相同的字符串的开头在区间 $[a+1,b-len]$ 中，否则 $g(a,b)=0$。

于是再设 $[a+1,b-len]$ 中与 $s_{l,r}$ 相同的字符串有 $e_2$ 个，它们开头的位置分别为 $q_k$，同时设 $c=q_1,d=q_{e_2}$。

为了不重不漏，枚举每一个 $q_k$，然后勒令 $s_{i+1,j-1}$ 所包含的与 $s_{l,r}$ 相同的字符串中第一个字符串为 $q_k$ 对应的字符串，求此时的方案数，设为 $h(k)$，则有：
$$
\begin{aligned}
h(k)&=\sum_{i=q_{(k-1)}}^{(q_{k})-1}\sum_{j=(q_{k})+len}^{b}1\\
&=(q_k-q_{(k-1)})\cdot(b-len+1-q_k)\\
&=(q_k-q_{(k-1)})\cdot(b-len+1)-q_k^2+q_k\cdot q_{(k-1)}
\end{aligned}
$$
这代表了 $i$ 不能切到 $q_k$ 的对应字符串和 $s_{i+1,j}$ 必须不包含 $q_{k-1}$ 的对应字符串，以及 $j$ 不能切到 $q_k$ 的对应字符串。

特殊的，让 $q_0=a$ 于是有：
$$
\begin{aligned}
g(a,b)&=\sum_{k=1}^{e_2}h(k)\\
&=\sum_{k=1}^{e_2}(q_k-q_{(k-1)})\cdot(b-len+1)-\sum_{k=1}^{e_2}q_k^2+\sum_{k=1}^{e_2}q_k\cdot q_{(k-1)}\\
&=(d-a)\cdot(b-len+1)-\sum_{k=1}^{e_2}q_k^2+a\cdot c+\sum_{k=2}^{e_2}q_k\cdot q_{(k-1)}
\end{aligned}
$$
$g(a,b)$ 的第一项和第三项可以直接算出来，第二项和第四项则可以用单点修改的线段树维护，故也可以用线段树合并维护，于是这题就解决了。

代码虽然有 ```6k``` 但结构清晰分明。

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <assert.h>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ll long long
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define _fev(p, u) for(re int (p) = head[(u)]; (p); (p) = nex[(p)])
#define inf 0x7fffffff
#define maxn 100005
#define maxq 300005
#define maxnn 2000005 

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

char str[maxn];
int	n, q, ncnt = 0, rg,
	ht[maxn], sa[maxn], buc[maxn],
	rk[maxn*2], arr[maxn*2],
	rt[maxn], uf[maxn];
ll	ans[maxq];
struct Qry{ int p, len, id; } Q[maxq];
struct Ans{ int le, ri; ll sqr, sm; };
struct Seg{ int lc, rc; Ans as; } seg[maxnn];
#define lc(x) seg[x].lc
#define rc(x) seg[x].rc
#define as(x) seg[x].as

inline bool operator<(const Qry &q1, const Qry &q2){ return q1.len > q2.len; }
inline bool cmp(re int a, re int b){ return ht[a] > ht[b]; }

int new_node(re int nn){
	re int x = ++ncnt;
	seg[x] = seg[nn];
	return x;
}

Ans cbn(const Ans &a, const Ans &b){
	if (!a.le) return b;
	else if (!b.le) return a;
	else return {a.le, b.ri, a.sqr+b.sqr, a.sm+b.sm+(ll)a.ri*b.le};
}

inline void ud(re int x){
	as(x) = cbn(as(lc(x)), as(rc(x)));
}

void addn(int &x, int p, int tl, int tr){
	if (!x) x = new_node(0);
	if (tl == tr){ as(x) = {p, p, (ll)p*p, 0}; return; }
	int mi = (tl+tr)>>1;
	if (p <= mi) addn(lc(x), p, tl, mi);
	else addn(rc(x), p, mi+1, tr);
	ud(x);
}

int merge(int x, int y, int tl, int tr){
	if (!x || !y) return x+y;
	assert(tl < tr);
	int mi = (tl+tr)>>1;
	lc(x) = merge(lc(x), lc(y), tl, mi);
	rc(x) = merge(rc(x), rc(y), mi+1, tr);
	ud(x);
	return x;
}

Ans qry(int x, int l, int r, int tl, int tr){
	if (!x) return {0, 0, 0, 0};
	if (l == tl && r == tr) return as(x);
	int mi = (tl+tr)>>1;
	if (r <= mi) return qry(lc(x), l, r, tl, mi);
	else if (l > mi) return qry(rc(x), l, r, mi+1, tr);
	else return cbn(qry(lc(x), l, mi, tl, mi), qry(rc(x), mi+1, r, mi+1, tr));
}

void get_sa(re char *str, re int n, re int m = 128){
	ms(rk, 0); ms(arr, 0);
	re int *x = rk, *y = arr, p;
	_rfor(i, 1, m) buc[i] = 0;
	_rfor(i, 1, n) ++buc[x[i] = str[i]+1];
	_rfor(i, 2, m) buc[i] += buc[i-1];
	for(re int i = n; i >= 1; --i) sa[buc[x[i]]--] = i;
	for(re int j = 1; j < n; j <<= 1){
		p = 0;
		_rfor(i, n-j+1, n) y[++p] = i;
		_rfor(i, 1, n) if (sa[i] > j) y[++p] = sa[i]-j;
		
		_rfor(i, 1, m) buc[i] = 0;
		_rfor(i, 1, n) ++buc[x[i]];
		_rfor(i, 2, m) buc[i] += buc[i-1];
		for(re int i = n; i >= 1; --i) sa[buc[x[y[i]]]--] = y[i];
		
		swap(x, y);
		p = x[sa[1]] = 1;
		_rfor(i, 2, n)
			if (y[sa[i]] == y[sa[i-1]] && y[sa[i]+j] == y[sa[i-1]+j]) x[sa[i]] = p;
			else x[sa[i]] = ++p;
		if (p == n) break;
		else m = p; 
	}
	_rfor(i, 1, n) rk[sa[i]] = i;
}

void get_ht(re char *str, re int n){
	re int j = ht[1] = 0;
	_rfor(i, 1, n){
		if (rk[i] == 1) continue;
		if (j) --j;
		re char *s1 = str+i-1, *s2 = str+sa[rk[i]-1]-1;
		while(s1[j+1] == s2[j+1]) ++j;
		ht[rk[i]] = j;
	}
}

int stk[maxn];
int find(re int u){
	re int top = 0;
	while(uf[u] > 0) stk[top++] = u, u = uf[u];
	while(top) uf[stk[--top]] = u;
	return u;
}

bool unite(re int u, re int v){
	u = find(u); v = find(v);
	assert(u != v); assert(rt[u] && rt[v]);
	if (uf[u] > uf[v]) u^=v^=u^=v;
	uf[u] += uf[v];
	uf[v] = u;
	rt[u] = merge(rt[u], rt[v], 1, rg);
	rt[v] = 0;
	return true;
}

inline ll f(re ll a, re ll b){ return b>=a+2 ? (b-a)*(b-a-1)/2 : 0; }

ll g(re int a, re int b, re int root, re int len){
	if (b-len-a <= 0) return 0;
	Ans as = qry(root, a+1, b-len, 1, rg);
	if (as.le == 0) return 0;
	return (ll)(as.ri-a)*(b+1-len) - as.sqr + (ll)a*as.le + as.sm;
}

ll get_ans(re int p, re int len){
	if (len == 1) return (ll)(n-1)*(n-2)/2;
	else if (len >= n-1) return 0;
	re int root = rt[find(p = rk[p])], s = as(root).le, t = as(root).ri;
	re ll
		pa = f(s+len-1, n), pb = g(1, n, root, len), pc = f(1, t),
		pab = g(s+len-1, n, root, len), pbc = g(1, t, root, len), pac = f(s+len-1, t),
		pabc = g(s+len-1, t, root, len);
	return pa+pb+pc-pab-pbc-pac+pabc;
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
	freopen("sample.out", "w", stdout);
	#endif
	
	lc(0) = rc(0) = 0; as(0) = {0, 0, 0, 0}; ms(uf, -1); ms(rt, 0); 
	n = rg = rdnt(), q = rdnt();
	sf("%s", str+1);
	get_sa(str, n);
	get_ht(str, n);
	_rfor(i, 1, n) addn(rt[i], sa[i], 1, rg);
	_rfor(i, 1, q) Q[i].p = rdnt(), Q[i].len = rdnt()-Q[i].p+1, Q[i].id = i;//pf("i:%d ", i);
	sort(Q+1, Q+1+q);
	_rfor(i, 2, n) arr[i-1] = i;
	sort(arr+1, arr+1+n-1, cmp);
	re int cur = 0;
	_rfor(i, 1, q){
		while(cur < n-1 && ht[arr[cur+1]] >= Q[i].len) ++cur, unite(arr[cur], arr[cur]-1);
		ans[Q[i].id] = get_ans(Q[i].p, Q[i].len);
	}
	_rfor(i, 1, q) pf("%lld\n", ans[i]);

	return 0;
}
```



---

## 作者：OldDriverTree (赞：3)

套路题，不太懂为什么能放到 $\text{D2T3}$，感觉难度低于 $\text{D1T1}$ 的一双木棋。

# Solution

先对这个串建出 $\text{SAM}$，并用线段树合并求出每个状态的 $\text{endpos}$，所有对于一次询问 $(l,r)$ 先在 $\text{parent}$ 树上倍增找到 $[l,r]$ 对应的状态，令 $len$ 为这个串的长度，$S$ 为这个串的 $\text{endpos}$，然后考虑容斥：

+ 出现在 $s_{1,i}$：令 $p$ 为 $S$ 中的最小值，则要求 $p\le i<j\le n$，答案就为 $\dfrac{(n-p)(n-p-1)}2$。
+ 出现在 $s_{j,n}$：令 $q$ 为 $S$ 中的最大值减 $len-1$，则要求 $1\le i<j\le q$，答案就为 $\dfrac{(q-1)(q-2)}2$。
+ 同时出现在 $s_{1,i}$ 和 $s_{j,n}$：要求 $p\le i<j\le q$，答案就为 $\dfrac{(q-p)(q-p-1)}2$，注意特判 $p>q$ 的情况。
+ 出现在 $s_{i+1,j-1}$，则要求 $S$ 中存在一个元素属于 $[i+len,j-1]$，就相当于给你一个区间问你有多少子区间包含至少一个 $S$ 中的元素，我们考虑在维护 $\text{endpos}$ 的线段树上把这个东西维护一下，对于每个节点维护 $pre,suf,ans$，分别表示这个区间中 $\text{endpos}$ 的最小值、最大值、以及包含 $\text{endpos}$ 的区间个数，合并两个子节点就是两个节点的 $ans$ 加起来再加上跨中点的区间个数，最后区间查询 $[1+len,n-1]$。
+ 同时出现在 $s_{1,i}$ 和 $s_{i+1,j-1}$，区间查询 $[p+len,n-1]$。
+ 同时出现在 $s_{j,n}$ 和 $s_{i+1,j-1}$，区间查询 $[1+len,q-1]$。
+ 同时出现在 $s_{1,i}$，$s_{j,n}$ 和 $s_{i+1,j-1}$，区间查询 $[p+len,q-1]$。

总时间复杂度 $O(n\log n+q\log n)$。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
const int N=2e5;
int cur=1,tot=1;
vector<int> g[N];
int n,m,fa[N][17];
int pos[N],root[N];
char s[N];

struct node {
	int len,fa;
	int son[10];
}T[N];

struct custom_hash
{
	static uint64_t splitmix64(uint64_t x) {
		x+=0x9e3779b97f4a7c15;
		x=(x^(x>>30) )*0xbf58476d1ce4e5b9;
		x=(x^(x>>27) )*0x94d049bb133111eb;
		return x^(x>>31);
	}
	size_t operator() (uint64_t x) const {
		static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x+FIXED_RANDOM);
	}
};
int read() {
	int x=0; bool _=true; char c=0;
	while (!isdigit(c) ) _&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=x*10+(c&15),c=getchar();
	return _?x:-x;
}
namespace SGT
{
	struct node
	{
		int l,r,pre,suf,ans;
		node friend operator +(node a,node b) {
			if (!a.ans&&!b.ans) return {a.l,b.r,0,0,0};
			if (!a.ans) return {a.l,b.r,b.pre,b.suf,b.ans+(a.r-a.l+1)*(b.r-b.pre+1)};
			if (!b.ans) return {a.l,b.r,a.pre,a.suf,a.ans+(a.suf-a.l+1)*(b.r-b.l+1)};
			return {a.l,b.r,a.pre,b.suf,a.ans+b.ans+(a.suf-a.l+1)*(b.r-b.l+1)+(a.r-a.suf)*(b.r-b.pre+1)};
		}
	}T[N<<6];
	int tot,ls[N<<6],rs[N<<6];
	void update(int &rt,int l,int r,int x) {
		T[rt=++tot]={l,r,x,x,(x-l+1)*(r-x+1)}; if (l==r) return;
		x<=mid?update(ls[rt],l,mid,x):update(rs[rt],mid+1,r,x);
	}
	node query(int rt,int l,int r,int s,int t) {
		if (s<=l&&r<=t) return rt?T[rt]:(node){l,r,0,0,0};
		if (t<=mid) return query(ls[rt],l,mid,s,t);
		if (mid<s) return query(rs[rt],mid+1,r,s,t);
		return query(ls[rt],l,mid,s,t)+query(rs[rt],mid+1,r,s,t);
	}
	int merge(int x,int y,int l,int r) {
		if (!x||!y) return x|y; int z=++tot; T[z]={l,r,0,0,0};
		ls[z]=merge(ls[x],ls[y],l,mid),rs[z]=merge(rs[x],rs[y],mid+1,r);
		return T[z]=(ls[z]?T[ls[z] ]:(node){l,mid,0,0,0})+(rs[z]?T[rs[z] ]:(node){mid+1,r,0,0,0}),z;
	}
}
void extend(int c) {
	int p=cur,np=cur=++tot; T[np].len=T[p].len+1;
	for (;p&&!T[p].son[c];p=T[p].fa) T[p].son[c]=np;
	if (!p) return T[np].fa=1,void(); int q=T[p].son[c];
	if (T[q].len==T[p].len+1) return T[np].fa=q,void();
	int nq=++tot; T[nq]=T[q],T[nq].len=T[p].len+1,T[np].fa=T[q].fa=nq;
	for (;T[p].son[c]==q;p=T[p].fa) T[p].son[c]=nq;
}
void dfs(int u) {
	for (int i=1;i<17;i++)
	fa[u][i]=fa[fa[u][i-1] ][i-1];
	for (int v:g[u]) fa[v][0]=u,dfs(v),
	root[u]=SGT::merge(root[u],root[v],1,n);
}
main()
{
	n=read(),m=read(),scanf("%s",s+1);
	for (int i=1;i<=n;i++) extend(s[i]&15),pos[i]=cur,SGT::update(root[cur],1,n,i);
	for (int i=2;i<=tot;i++) g[T[i].fa].push_back(i); dfs(1);
	while (m--) {
		int l=read(),r=read(),len=r-l+1,now=pos[r];
		for (int i=16;~i;i--) if (T[fa[now][i] ].len>=len) now=fa[now][i];
		SGT::node tmp=SGT::T[root[now] ]; int p=tmp.pre,q=tmp.suf-len+1;
		int ans=(n-p)*(n-p-1)/2+(q-1)*(q-2)/2; if (p<q) ans-=(q-p)*(q-p-1)/2;
		if (1+len<n) ans+=SGT::query(root[now],1,n,1+len,n-1).ans;
		if (p+len<n) ans-=SGT::query(root[now],1,n,p+len,n-1).ans;
		if (1+len<q) ans-=SGT::query(root[now],1,n,1+len,q-1).ans;
		if (p+len<q) ans+=SGT::query(root[now],1,n,p+len,q-1).ans;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：wind_whisper (赞：3)

## $\text{Foreword}$
>人都道正难则反，我偏说正也不难。  

这里介绍一种正面直接统计的做法。  
和补集做法相比，没有那么多的分类讨论，更多的是对问题的正向分析和逐层化简、转化，也并不麻烦。  
由于需要写很多线段树的操作，码量较大，本人在210行左右（但都是较为基础的操作，写起来很舒适）。  
~~本来这就是一道码农题不是吗！~~  
我们开始吧。
## $\text{Solution}$

前置规定：  
以下设截下的串的两端点（即题面描述 $i+1,j-1$）为 $x,y$，$x,y\in(1,n)$。  
设询问串长度为 $len$。  
设 $s(a,b)=\sum_{i=a}^bi$，$a>b$ 时，规定 $s(a,b)=0$。  

（以下基本模拟我做本题的思维过程）  

SA 和本题感觉不是很搭，那基本就是 SAM 了。  
给的限制乍一看非常恶心，但细想想还挺有话说的。  

### Part 1 
设询问串第一次出现的**右端点** 位置为 $a$，最后一次出现**左端点** 位置为 $b$，那么当中间截下的字符串 $x>a$ 或 $y<b$ 的时候，必然是合法的。  
SAM 反串先建出后缀树，记录出现的最早和最晚位置并向父亲传递，即可维护这两个值。
容易统计这个时候的答案，应该是：
$$s(1,n-a-1)+s(1,b-2)-s(1,(b-1)-(a+1)+1)$$
最后减去的是为了容斥掉左右端点同时满足条件算重的方案数。

### Part 2
那么现在的问题就转化为了：
>求 $x\le a,y\ge b$ 且包含询问串的字符串 $(x,y)$ 对数。

这个东西并太不好做。  
暴力怎么做？  
~~暴力是不是~~我们固定一个 $x$，然后设**左端点在 $x$ 右侧的最靠左的字符串的右端点**为 $pos$，那么 $r$ 的取值范围就是 $[\max(b,pos),n-1]$。  
随着左端点右移， $pos$ 单调不升，右端点可以取到的范围肯定是逐渐变大，最后变成 $[b,n-1]$。
我们尝试掐头去尾的计算这部分的答案。
#### Part 2.1
我们找到满足 $r\le b$ 的最靠左询问串，设其左端点为 $u$，那么当 $x\le u$ 时，$y$ 的取值范围就变成了 $[b,n-1]$。  
这部分的贡献是：
$$(u-1)(n-b)$$
需要注意一些边界情况，如果 $u\ge a$，那么整个 part2 的贡献就是 $(a-1)(n-b)$，加上后直接返回即可。
#### Part 2.2
设 $l>a$ 的最靠左的询问串的左端点为 $suf$，$l\le a$ 的最靠右的询问串左端点为 $pre$，那么当 $x\in(pre,a]$ 时，$y$ 一直是在受 $suf$ 这个串约束，其范围是 $[suf+len-1,n-1]$。  
这部分的贡献就是：
$$(a-pre)(n-suf)$$

#### Part 2.3
现在我们只剩下 $x\in[u+1,pre]$ 这一段的贡献了。

我们想想最理想的情况：每个位置都有一个询问串的左端点，那么答案显然就是：
$$\sum_{i=u+1}^{pre}n-(i+len-1)=s(n-(pre+len-1),n-(u+1+len-1))$$
但是现实很骨感，真实答案可能会取不到这么多，那么会少多少呢？  
举个栗子，设左端点出现集合为 $101001$，考虑它和 $111111$ 相比少了多少答案。  
不难发现，第一段长度为 $1$ 的 $0$ 串使答案减少了 $1$，第二段答案为 $2$ 的 $0$ 串使答案减少了 $1+2=3$。  
一般的，一段长度为 $L$ 的极长 $0$ 串，会使答案减少 $s(1,L)$。  
那么问题就变成求 $[u+1,pre]$ 这部分 $0$ 串减少的答案之和，利用线段树合并 $startpos$ 集合即可轻松维护。  
(~~startpos这个名字是我瞎起的，就是正常SAM的endpos~~)


然后本题就做完了。  
时间复杂度 $O((n+m)\log n)$。
## $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("OK\n")
using namespace std;

const int N=4e5+100;
const int C=10;

inline ll read(){
	ll x(0),f(1);char c=getchar();
	while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}

int n,m,k;

int tag[N],mn[N],mx[N];
int pos[N];
int pl[N][20];
vector<int>v[N];

#define calc(x) (1ll*(x)*((x)+1)/2)
struct node{
	int llen,rlen,siz;
	ll sum;
};
node operator + (const node &a,const node &b){
	node o;
	o.siz=a.siz+b.siz;
	o.llen=a.llen==a.siz?a.siz+b.llen:a.llen;
	o.rlen=b.rlen==b.siz?b.siz+a.rlen:b.rlen;
	o.sum=a.sum+b.sum;
	o.sum+=calc(a.rlen+b.llen)-calc(a.rlen)-calc(b.llen);
	return o;
}
inline node emp(int len){
	return (node){len,len,len,calc(len)};
}

struct tree{
	int ls,rs;
	node o;
};
int rt[N],tot;
struct Seg{
	tree tr[N*20];
	#define mid ((l+r)>>1)
	inline void pushup(int k,int l,int r){
		node x=tr[k].ls?tr[tr[k].ls].o:emp(mid-l+1);
		node y=tr[k].rs?tr[tr[k].rs].o:emp(r-mid);
		tr[k].o=x+y;
		return;
	}
	inline int copy(int x){
		tr[++tot]=tr[x];
		return tot;
	}
	void upd(int &k,int l,int r,int p){
		k=copy(k);
		if(l==r){
			tr[k].o=(node){0,0,1,0};
			return;
		}
		if(p<=mid) upd(tr[k].ls,l,mid,p);
		else upd(tr[k].rs,mid+1,r,p);
		pushup(k,l,r);
	}
	int merge(int x,int y,int l,int r){
		if(!x||!y) return x|y;
		int now=copy(x);
		tr[now].ls=merge(tr[now].ls,tr[y].ls,l,mid);
		tr[now].rs=merge(tr[now].rs,tr[y].rs,mid+1,r);
		pushup(now,l,r);
		return now;
	}
	int findsuf(int k,int l,int r,int p){
		if(!k) return 0;
		if(l==r) return (l>=p)?l:0;
		if(p>mid) return findsuf(tr[k].rs,mid+1,r,p);
		else{
			int res=findsuf(tr[k].ls,l,mid,p);
			if(res) return res;
			else return findsuf(tr[k].rs,mid+1,r,p);
		}
	}
	int findpre(int k,int l,int r,int p){
		if(!k) return 0;
		if(l==r) return (l<=p)?l:0;
		if(p<=mid) return findpre(tr[k].ls,l,mid,p);
		else{
			int res=findpre(tr[k].rs,mid+1,r,p);
			if(res) return res;
			else return findpre(tr[k].ls,l,mid,p);
		}
	}
	node query(int k,int l,int r,int x,int y){
		if(!k) return emp(min(r,y)-max(l,x)+1);
		if(x<=l&&r<=y) return tr[k].o;
		if(y<=mid) return query(tr[k].ls,l,mid,x,y);
		else if(x>mid) return query(tr[k].rs,mid+1,r,x,y);
		else return query(tr[k].ls,l,mid,x,y)+query(tr[k].rs,mid+1,r,x,y);
	}
}seg;

void dfs(int x,int fa){
	pl[x][0]=fa;
	for(int k=1;pl[x][k-1];k++) pl[x][k]=pl[pl[x][k-1]][k-1];
	for(int to:v[x]){
		dfs(to,x);
		mn[x]=min(mn[x],mn[to]);
		mx[x]=max(mx[x],mx[to]);
		rt[x]=seg.merge(rt[x],rt[to],1,n);
	}
	if(tag[x]){
		seg.upd(rt[x],1,n,tag[x]);
	}
	return;
}

struct SAM{
	int tr[N][C],fa[N],len[N],tot,lst;
	SAM(){
		tot=lst=1;
	}
	inline void ins(int c,int id){
		c-='0';
		int cur=++tot,p=lst;lst=tot;
		len[cur]=len[p]+1;
		pos[id]=cur;
		tag[cur]=id;mn[cur]=mx[cur]=id;
		for(;p&&!tr[p][c];p=fa[p]) tr[p][c]=cur;
		if(!p) fa[cur]=1;
		else{
			int q=tr[p][c];
			if(len[q]==len[p]+1) fa[cur]=q;
			else{
				int nq=++tot;
				mn[nq]=n+1;mx[nq]=0;
				len[nq]=len[p]+1;fa[nq]=fa[q];
				for(int i=0;i<C;i++) tr[nq][i]=tr[q][i];
				fa[cur]=fa[q]=nq;
				for(;p&&tr[p][c]==q;p=fa[p]) tr[p][c]=nq;
			}
		}
		return;
	}
	void build(){
		for(int i=2;i<=tot;i++) v[fa[i]].push_back(i);
		dfs(1,0);
	}
	int find(int l,int r){
		int x=pos[l],L=r-l+1;
		for(int k=18;k>=0;k--){
			if(len[pl[x][k]]>=L) x=pl[x][k];
		}
		return x;
	}
}sam;

inline ll Sum(ll x,ll y){
	if(x>y) return 0;
	else return (x+y)*(y-x+1)/2;
}
ll work(int l,int r){
	int x=sam.find(l,r),len=r-l+1;
	int a=mn[x]+len-1,b=mx[x];
	ll ans=Sum(1,n-a-1)+Sum(1,b-2);
	int w=(b-1)-(a+1)+1;
	if(w>=1) ans-=calc(w);
	a=min(a,b);
	int pre=seg.findpre(rt[x],1,n,a),suf=seg.findsuf(rt[x],1,n,a+1);
	int u=seg.findpre(rt[x],1,n,b-len+1);
	if(u>=a){
		ans+=1ll*(a-1)*(n-b);
		return ans;
	}
	if(suf){
		ans+=1ll*(a-pre)*(n-(suf+len-1));
	}
	if(u) ans+=1ll*(u-1)*(n-b);
	//calc: [u+1,pre]
	u=max(u,1);
	if(u+1<=pre){
		ans+=Sum(n-(pre+len-1),n-(u+1+len-1));		
		node o=seg.query(rt[x],1,n,u+1,pre);
		ans-=o.sum;
	}
	return ans;
}

char s[N];
signed main(){
#ifndef ONLINE_JUDGE
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
#endif
	n=read();m=read();
	scanf(" %s",s+1);
	for(int i=n;i>=1;i--) sam.ins(s[i],i);
	sam.build();
	for(int i=1;i<=m;i++){
		int l=read(),r=read();
		printf("%lld\n",work(l,r));
	}
	return 0;
}
/*
*/
```












---

## 作者：AC_Evil (赞：3)

## 题意

给长度为$n$的字符串以及$q$组询问，每次询问将字符串**切两刀**变成三个**非空串**中出现$s_{l,r}$的方案。

## 题解

``SAM+倍增+fhq-treap(或线段树合并)``

大体思路与其他题解一致，只不过我是用``fhq-treap``实现的，提交结果如下

![](https://cdn.luogu.com.cn/upload/image_hosting/0lpfqekn.png)

发现跑的还是很快的，而且代码量跟线段树合并差不太多（吧），复杂度一样，但是内存很小。

这道题思路比较简单。看到跟子串相关，我们很容易想到用``SAM``解决问题。考虑将操作离线，我们把对应的操作放到``Parent树``上对应的位置，这一步使用倍增即可。

对于每个``Parent树``上的结点代表了$endpos$，即原串中所有子串$=s_{l,r}$最后一位下标的集合（SAM的概念）。正向统计答案很困难，考虑反向统计非法解。记一刀切在第$x$个字符后面，考虑先切第一刀，显然第一刀切的位置$i$要小于$endpos$中最小的数$op$（否则原串中第一个子串完整使得答案合法）。确定下来第一刀的位置，那么考虑第二刀的位置，这个第二刀$j$贡献到非法答案，当且仅当$\forall p\in endpos,p>i+\mid s_{l,r}\mid-1$，都满足$p-\mid s_{l,r}\mid+1\leqslant j<p$，$p$还有条件是由于$i$可能也切到了那些串。把上面的式子变变形，相当于求

$$\max(p-\mid s_{l,r}\mid+1) \leqslant j<\min p,p\in endpos\&\&p>i+\mid s_{l,r}\mid-1$$

的解$j$的方案数，也就是$\min p-\max(p-\mid s_{l,r}\mid+1)=\min p-\max p+\mid s_{l,r}\mid-1$。且对于每一个$i$，都要求解。注意这个式子算进贡献当且仅当$\geqslant 0$，即存在$i>q$，满足$\max p-\min p\leqslant\mid s_{l,r}\mid-1$；还要讨论是否存在$p$，如果不存在，任意位置都是非法的，贡献为等差数列求和。

对于所有的$i$，我们要计算$\min p-\max p,p>i+C$，剩余的常数部分的只需要看能对非法解贡献的$i$有多少再乘进去就行了。$C$可以下标平移解决掉，那么实际上维护的就是下标$p$的差分。维护每一个$p$往前的贡献，区间一定是$t\in(pre_p,p]$，这一段的权值$w_t=p$。那么答案就变成了$\sum\limits_{q<i\leqslant\max p}w_i-\max p$。这里用动态开点线段树可以解决，这个$q$也是可以二分找到的。对于每个``Parent树``结点对应的线段树，需要通过子树的线段树合并得来，但是wtcl，不会线段树合并只想到了``fhq-treap``启发式合并。

最后总数-非法数就是答案。

复杂度$\mathcal O((n+q)\log n)$。

```cpp
#include <bits/stdc++.h>

#define rep(i, a, b) for (int i = a, i##end = b; i <= i##end; ++i)
#define per(i, a, b) for (int i = a, i##end = b; i >= i##end; --i)
#define rep0(i, a) for (int i = 0, i##end = a; i < i##end; ++i)
#define per0(i, a) for (int i = a-1; ~i; --i)
#define chkmin(a, b) a = std::min(a, b)
#define chkmax(a, b) a = std::max(a, b)
#define x first
#define y second

typedef long long ll;

inline int read() {
	int w = 0, f = 1; char c;
	while (!isdigit(c = getchar())) c == '-' && (f = -1);
	while (isdigit(c)) w = w*10+(c^48), c = getchar();
	return w * f;
}

const int maxn = 111111;
const int inf = 1<<30;

namespace FHQ {
#define lc FHQ::ch[o][0]
#define rc FHQ::ch[o][1]
	int ch[maxn][2], r[maxn], sz[maxn], tot = 0;
	ll sum[maxn];
	std::pair<int, int> key[maxn], area[maxn]; // store the line (]
	int newnode(std::pair<int, int> x) {
		r[++tot] = rand(), key[tot] = area[tot] = x, sum[tot] = 1ll*x.y*(x.y-x.x), sz[tot] = 1;
		return tot;
	}
	void pushup(int o) {
		sz[o] = sz[lc] + sz[rc] + 1;
		sum[o] = sum[lc] + sum[rc] + 1ll*key[o].y*(key[o].y-key[o].x);
		area[o] = std::make_pair(std::min(lc ? area[lc].x : inf, key[o].x), std::max(key[o].y, rc ? area[rc].y : -inf));
	}
	void split(int o, int x, int &l, int &r) {
		if (!o) { l = r = 0; return; }
		if (key[o].y < x) l = o, split(rc, x, ch[l][1], r), pushup(l);
		else r = o, split(lc, x, l, ch[r][0]), pushup(r);
	}
	int merge(int x, int y) {
		if (!x || !y) return x | y;
		return r[x] > r[y] ? (ch[x][1] = merge(ch[x][1], y), pushup(x), x) : (ch[y][0] = merge(x, ch[y][0]), pushup(y), y);
	}
}

int rt[maxn*2], pos[maxn];

namespace SAM {
	int ch[maxn*2][10], fa[maxn*2], len[maxn*2], tot;
	int last;
	void init() { fa[last = tot = 0] = -1; }
	void extend(int x) {
		int p = last, cur = ++tot;
		pos[len[cur] = len[last]+1] = cur;
		rt[cur] = FHQ::newnode(std::make_pair(0, len[cur]));
		for (; ~p && !ch[p][x]; p = fa[p]) ch[p][x] = cur;
		if (p == -1) fa[cur] = 0;
		else {
			int q = ch[p][x];
			if (len[p]+1 == len[q]) fa[cur] = q;
			else {
				int cpy = ++tot;
				memcpy(&ch[cpy], &ch[q], sizeof ch[q]);
				fa[cpy] = fa[q]; len[cpy] = len[p]+1;
				fa[q] = fa[cur] = cpy;
				for (; ~p && ch[p][x] == q; p = fa[p]) ch[p][x] = cpy;
			}
		}
		last = cur;
	}
}

int n, q, len[maxn*3];
ll ans[maxn*3];
char s[maxn];

int par[18][maxn*2];
std::vector<int> G[maxn*2], qry[maxn*2];
void dfs1(int u) {
	rep(i, 1, 17) par[i][u] = par[i-1][par[i-1][u]];
	rep0(i, G[u].size())
		dfs1(G[u][i]);
}

int get(int o, int d) {
	if (!o) return 0;
	while (FHQ::ch[o][d]) o = FHQ::ch[o][d];
	return o;
}
#define getop(o) get(o, 0)
#define geted(o) get(o, 1)

void fix(int o, std::pair<int, int> x) {
	if (!FHQ::ch[o][0]) FHQ::key[o] = x;
	else fix(FHQ::ch[o][0], x);
	FHQ::pushup(o);
}

void merge(int &x, int y) { // x<-y
	if (!y) return;
	merge(x, FHQ::ch[y][0]), merge(x, FHQ::ch[y][1]);
	FHQ::ch[y][0] = FHQ::ch[y][1] = 0;
	int l, r; FHQ::split(x, FHQ::key[y].y, l, r);
	int ed = geted(l), op = getop(r);
	if (ed) FHQ::key[y].x = FHQ::key[ed].y;
	if (op) fix(r, std::make_pair(FHQ::key[y].y, FHQ::key[op].y));
	FHQ::pushup(y); x = FHQ::merge(l, FHQ::merge(y, r));
}

ll query(int o, int ql, int qr) { // 类似于线段树，在平衡树上的查询(,]
	if (ql >= qr) return 0;
	if (ql <= FHQ::area[o].x && FHQ::area[o].y <= qr) return FHQ::sum[o];
	ll ans = 0; int l = FHQ::key[o].x, r = FHQ::key[o].y;
	if (l < qr && ql < r) ans = 1ll * (std::min(qr, r) - std::max(ql, l)) * r;
	if (lc) ans += query(lc, ql, std::min(qr, l));
	if (rc) ans += query(rc, std::max(ql, r), qr);
	return ans;
}

void dfs2(int u) {
	rep0(i, G[u].size()) {
		int v = G[u][i];
		dfs2(v);
		if (FHQ::sz[rt[u]] < FHQ::sz[rt[v]]) std::swap(rt[u], rt[v]);
		merge(rt[u], rt[v]);
	}
	// deal with the qrys
	int op = FHQ::key[getop(rt[u])].y, ed = FHQ::area[rt[u]].y;
	rep0(i, qry[u].size()) {
		int id = qry[u][i], ql = len[id], qr = op+len[id]-1, x, y;
		FHQ::split(rt[u], ed-len[id]+1, x, y);
		int xed = FHQ::area[x].y, l = std::max(ql, xed), r = std::min(ed, qr);
		ans[id] = 1ll*(n-1)*(n-2)/2-1ll*(len[id]-1-ed)*(r>l?r-l:0)-query(y,l,r)-(qr>r?1ll*((n+len[id])*2-r-qr-3)*(qr-r)/2:0);
		rt[u] = FHQ::merge(x, y);
	}
}

int main() {
	srand(time(0));
	n = read(), q = read();
	scanf("%s", s);
	SAM::init();
	rep0(i, n) SAM::extend(s[i]-'0');
	rep(i, 1, SAM::tot) G[par[0][i] = SAM::fa[i]].push_back(i);
	dfs1(0);
	rep(i, 1, q) {
		// getpos
		int l = read(), r = read(), p = pos[r];
		len[i] = r-l+1;
		per0(x, 17)
			if (len[i] <= SAM::len[par[x][p]]) p = par[x][p];
		qry[p].push_back(i);
	}
	dfs2(0);
	rep(i, 1, q) printf("%lld\n", ans[i]);
	return 0;
}
```

---

## 作者：Mr_Wu (赞：2)

至今为止做过的最烦人的题

大概是因为我已经很久没有碰 SAM 了，所以这个题耗费了我一下午+一晚上的时间，有必要发个题解纪念一下.jpg

# 题解

考虑反过来求，也就是求 $[1,l][l+1,r-1][r,n]$ 这个分段法在任意一段里都找不到一个 $s_{l,r}$。 也就是说用 $l\sim l+1$ 这一刀和 $r-1\sim r$ 这一刀把所有串全都切了的方案数。然后用 $\binom{n-1}{2}$ 把它减了。

~~实际上不管怎么推都可以推得答案，但反过来推是最好推的一种。我在其它方法中都没能得到最后的结果，于是耗费了一个下午的时间~~

考虑用 SAM 来做这个题，根据套路我们可以通过从 $s_{1,r}$ 对应的节点开始，在 parent 树上倍增的方法来求得 $s_{l,r}$ 所在的节点。

那么到这个节点后我们就知道了一个 endpos 集合，通过它能知道 $s_{l,r}$ 在 $s$ 中的其它出现位置。设它们是 $[l_1,r_1],[l_2,r_2],\cdots,[l_k,r_k] (l_1< l_2< \cdots <l_k)$。

由于我们要求不合法，所以 $l<r_1$ 是一定要的不然 $[l_1,r_1]$ 就在 $[1,l]$ 里了

那么现在我们固定这个 $l$，假设它把所有串都切到了也就是 $l_k\le l$ 时，这时 $r$ 随便取也就是在 $[l+2,n]$ 内。否则我们找到第一个 $l_i>l$ 的 $i$ 设为 $nex(l)$，此时 $[i,k]$ 这些串都没被切到，得到 $r$ 应该在 $[l_k+1,r_{nex(l)}]$ 内。（这两个区间可能是空的）

所以现在就有一个对每个 $l$ 都去 $O(1)$ 计算的方案，但我们不能要这个式子，因为和式的值都在每个位置上，不只在 endpos 上，无法维护。

## 情况 1

由于上述分析的两个 if 条件 $l<r_1$ 和 $l_k\le l$，所以我们需要做出一个分类讨论以**简化**推出的式子

当 $l_k\ge r_1$ 时，由于 $l<r_1$ 所以不可能有 $l_k\le l$ 也就是说不可能一刀把所有串全切了。所以是

$$
\sum_{l=1}^{r_1-1} \max(0,r_{nex(l)}-l_k)
$$

我们需要把信息放到每个 endpos 上，所以要继续推。思路很直接就是考虑对一些 $l$ 它们的 $nex(l)$ 是一样的，把贡献都放在 $nex(l)$ 上。所以第一是考虑 $nex(l)$ 在什么时候贡献不是 0 也就是 max 在右边取，第二是考虑最后可能会有一段 $[l_{?-1}+1,l_?]$ 被 $r_1-1$ 直接截断。下面是细节：

找到第一个 $i$ 满足 $r_i> l_k$ （在 $len>1$ 时一定存在且 $>1$），找到第一个 $j$ 满足 $r_1-1< l_j$（一定存在），若 $i\le j$ 则答案是下式，否则是 0

$$
\sum_{t=i}^{j-1} (l_t-l_{t-1})(r_t-l_k) + (r_1-l_{j-1})(r_j-l_k)
$$

## 情况 2

当 $l_k<r_1$ 时，此时所有区间都堆积在一块，交非空。所以切完一刀 $l<r_1$ 后一定可以再切一刀，不需要 max 了。答案为

$$
\sum_{l=l_k}^{r_1-1} (n-l-1)+\sum_{l=1}^{l_k-1} r_{nex(l)}-l_k
$$

也就是

$$
\sum_{l=l_k}^{r_1-1} (n-l-1)+(l_1-1)(r_t-l_k)+\sum_{t=2}^{k} (l_t-l_{t-1})(r_t-l_k)
$$

## 维护

不管怎么说，我们发现我们需要做的事情是查询一个前驱或后继，或者询问一段区间的 $\sum_t (r_t-r_{t-1})r_t$ 的和，或询问一段区间的 $\sum_t (r_t-r_{t-1})$ 的和。我们采用线段树合并（离线线段树合并或在线可持久化线段树合并）进行维护，在每个节点上存储内部 endpos 的最大值与最小值，就可以实现。

时间复杂度为 $O((n+q)\log n)$，空间复杂度为 $O(n\log n)$。

## 实现

并不是很长。不过调起来确实挺烦人

建议你先写一个暴力验证一下你推的式子是不是对的，然后再写，顺便也可以对拍了

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long ll;
const int MAXN=1e5+5;
const int MX1=MAXN*40;
const int MX2=MAXN*2;

int N,Q;char S[MAXN];

int rt[MX2];
struct segmentTree{
	#define mid ((l+r)>>1)
	struct data{
		int mn,MX1;ll sum;
		data(){}
		data(int mn,int MX1,ll sum):mn(mn),MX1(MX1),sum(sum){}
		friend data operator+(const data& l,const data& r){
			ll sum=l.sum+r.sum;if(l.MX1&&r.mn)sum+=(r.mn-l.MX1)*r.mn;
			return data(l.mn?l.mn:r.mn,r.MX1?r.MX1:l.MX1,sum);
		}
	}T[MX1];
	int ls[MX1],rs[MX1],mn[MX1],mx[MX1],Tlen;ll sum[MX1];
	void ins(int& o,int l,int r,int pos){
		if(r<pos||l>pos)return;
		if(!o)o=++Tlen;
		if(l==r)T[o].mn=T[o].MX1=l;
		else ins(ls[o],l,mid,pos),ins(rs[o],mid+1,r,pos),T[o]=T[ls[o]]+T[rs[o]];
	}
	data qry(int o,int l,int r,int L,int R){
		if(!o||r<L||l>R)return data(0,0,0);
		if(L<=l&&r<=R)return T[o];
		else return qry(ls[o],l,mid,L,R)+qry(rs[o],mid+1,r,L,R);
	}
	int merge(int o1,int o2,int l,int r){
		if(!o1||!o2)return o1|o2;
		int o=++Tlen;ls[o]=merge(ls[o1],ls[o2],l,mid),rs[o]=merge(rs[o1],rs[o2],mid+1,r);
		T[o]=T[ls[o]]+T[rs[o]];
		return o;
	}
}T;

struct suffixAutomaton{
	int fa[MX2][20];
	struct node{int v,next;}E[MX2];int head[MX2],Elen;
	void add(int u,int v){++Elen,E[Elen].v=v,E[Elen].next=head[u],head[u]=Elen;}
	void dfs(int u){
		for(int i=1;i<=19;++i)fa[u][i]=fa[fa[u][i-1]][i-1];
		for(int i=head[u];i;i=E[i].next){
			fa[E[i].v][0]=u,dfs(E[i].v);
			rt[u]=T.merge(rt[u],rt[E[i].v],1,N);
		}
	}

	int son[MX2][10],link[MX2],len[MX2],endpos[MX2],id[MAXN],last,Tlen;
	suffixAutomaton(){link[0]=-1;}
	void extend(int ch,int ed){
		int cur=++Tlen;T.ins(rt[cur],1,N,ed),id[ed]=cur,len[cur]=len[last]+1;int p=last;
		for(;p!=-1&&!son[p][ch];p=link[p])son[p][ch]=cur;
		if(p!=-1){
			int q=son[p][ch];
			if(len[q]==len[p]+1)link[cur]=q;
			else{
				int clone=++Tlen;link[clone]=link[q],len[clone]=len[p]+1;
				for(int i=0;i<10;++i)son[clone][i]=son[q][i];
				for(;p!=-1&&son[p][ch]==q;p=link[p])son[p][ch]=clone;
				link[cur]=link[q]=clone;
			}
		}
		last=cur;
	}
	void build(){
		for(int i=1;i<=Tlen;++i)add(link[i],i);
		dfs(0);
	}
	int qry(int l,int r){
		int p=id[r];
		if(len[link[p]]<r-l+1)return p;
		for(int i=19;i>=0;--i){
			if(link[fa[p][i]]!=-1&&len[link[fa[p][i]]]>=r-l+1)p=fa[p][i];
		}
		return fa[p][0];
	}
}SAM;

int main(){
	scanf("%d%d%s",&N,&Q,S+1);
	for(int i=1;i<=N;++i)SAM.extend(S[i]-'0',i);
	SAM.build();
	while(Q--){
		int l,r,p,len;
		scanf("%d%d",&l,&r),len=r-l+1;
		if(l==r){
			printf("%lld\n",1ll*(N-1)*(N-2)/2);
			continue;
		}
		ll ans=0;
		p=rt[SAM.qry(l,r)];
		int r1=T.T[p].mn,lk=T.T[p].MX1-len+1;
		if(lk>=r1){
			int i=T.qry(p,1,N,T.T[p].MX1-len+2,N).mn;
			int j=T.qry(p,1,N,T.T[p].mn+len-1,N).mn;
			if(i<=j){
				int pi=T.qry(p,1,N,1,i-1).MX1,pj=T.qry(p,1,N,1,j-1).MX1;
				if(i<j)ans+=T.qry(p,1,N,pi,pj).sum-1ll*(pj-pi)*lk;
				ans+=1ll*(r1-(pj-len+1))*(j-lk);
			}
		}else{
			ans+=T.T[p].sum-1ll*(T.T[p].MX1-T.T[p].mn)*lk;
			ans+=1ll*(T.T[p].mn-len)*(r1-lk);
			ans+=1ll*(r1-lk)*N-1ll*(r1-lk)*(r1+lk+1)/2;
		}
		ans=1ll*(N-1)*(N-2)/2-ans;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：劉子颺 (赞：2)

毒瘤 ~~不失精致~~

思考一下暴力

显然可以树上倍增 然后再找到串在哪里 这是常见套路

然后找到串在哪里之后考虑45分的暴力

稍有常识的套路线段树维护right集合后明显就得到了这个串出现位置

正难则反 考虑不合法的情况

明显三个串不重合就不行

随后思考两个串/一个串的情况

差分算一下贡献 最后得到一个可以用线段树维护的式子

线段树维护一下即可

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
typedef long long LL;
const int N=3e5+100;
const int INF=1e9+10;
inline void read(int &x){
	x=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	x*=f;
}
struct Front_Star{
	int u,v,nxt;
}e[N<<2];
int cnt=1;
int first[N];
void add(int u,int v){
	++cnt;
	e[cnt].u=u;
	e[cnt].v=v;
	e[cnt].nxt=first[u];
	first[u]=cnt;
}
int root[N];
struct Segment_Tree{	
	int lson[N*50];
	int rson[N*50];
	int RL[N*50];
	int RR[N*50];
	LL sum1[N*50];
	LL sum2[N*50];
	int cnt;
	inline void PushUp(int p){
		RL[p]=INF;
		if(lson[p])RL[p]=min(RL[p],RL[lson[p]]);
		if(rson[p])RL[p]=min(RL[p],RL[rson[p]]);
		
		RR[p]=-INF;
		if(lson[p])RR[p]=max(RR[p],RR[lson[p]]);
		if(rson[p])RR[p]=max(RR[p],RR[rson[p]]);
		
		sum1[p]=0;
		sum2[p]=0;
		
		if(RL[p]!=INF&&RR[p]!=-INF)sum1[p]=RR[p]-RL[p];
		#define lc lson[p]
		#define rc rson[p]
		sum2[p]=sum2[lc]+sum2[rc];
		if(RR[lc]!=-INF&&RL[rc]!=INF&&lc&&rc){
			sum2[p]+=(RL[rc]-RR[lc])*RL[rc];
		}
		#undef lc 
		#undef rc
	}
	void Update(int &p,int l,int r,int pos){
		if(!p)p=++cnt;
		if(l==r){
			RL[p]=l;
			RR[p]=r;
			sum1[p]=0;
			sum2[p]=0;
			return;
		}
		int mid=(l+r)>>1;
		if(pos<=mid)Update(lson[p],l,mid,pos);
		else Update(rson[p],mid+1,r,pos);
		PushUp(p);
	}
	int Merge(int x,int y,int l,int r){
		if(!x||!y)return x+y;
		int np=++cnt;
		if(l==r){
			RL[np]=l;
			RR[np]=r;
			sum1[np]=0;
			sum2[np]=0;
			return np;
		}
		int mid=(l+r)>>1;
		lson[np]=Merge(lson[x],lson[y],l,mid);
		rson[np]=Merge(rson[x],rson[y],mid+1,r);
		PushUp(np);
		return np;
	}
	int QueryL(int p,int l,int r,int dl,int dr){
		if(!p)return INF;
		if(dl<=l&&r<=dr){
			return RL[p];
		}
		int mid=(l+r)>>1;
		int ret=INF;
		if(dl<=mid)ret=min(ret,QueryL(lson[p],l,mid,dl,dr));
		if(mid< dr)ret=min(ret,QueryL(rson[p],mid+1,r,dl,dr));
		return ret;
	}
	int QueryR(int p,int l,int r,int dl,int dr){
		if(!p)return -INF;
		if(dl<=l&&r<=dr){
			return RR[p];
		}
		int mid=(l+r)>>1;
		int ret=-INF;
		if(dl<=mid)ret=max(ret,QueryR(lson[p],l,mid,dl,dr));
		if(mid< dr)ret=max(ret,QueryR(rson[p],mid+1,r,dl,dr));
		return ret;
	}
	#define lc lson[p]
	#define rc rson[p]
	pair<pair<LL,LL>,pair<int,int> >QuerySum(int p,int l,int r,int dl,int dr){//sum1 sum2 RL RR
		if(dl>dr)return make_pair(make_pair(0,0),make_pair(INF,-INF));
		
		if(!p)return make_pair(make_pair(0,0),make_pair(INF,-INF));
		
		if(dl<=l&&r<=dr){
			return make_pair(make_pair(sum1[p],sum2[p]),make_pair(RL[p],RR[p]));
		}
		int mid=(l+r)>>1;
		if(dl<=mid&&dr<=mid){
			return QuerySum(lson[p],l,mid,dl,dr);
		}
		if(mid< dl&&mid< dr){
			return QuerySum(rson[p],mid+1,r,dl,dr);
		}
		pair<pair<LL,LL>,pair<int,int> >Lnow=QuerySum(lc,l,mid,dl,dr);
		pair<pair<LL,LL>,pair<int,int> >Rnow=QuerySum(rc,mid+1,r,dl,dr);
		pair<pair<LL,LL>,pair<int,int> >ret=make_pair(make_pair(0,0),make_pair(INF,-INF));
		
		ret.first.second=Lnow.first.second+Rnow.first.second;
		
		if(lc)ret.second.first=min(ret.second.first,Lnow.second.first);
		if(lc)ret.second.second=max(ret.second.second,Lnow.second.second);
		
		if(rc)ret.second.first=min(ret.second.first,Rnow.second.first);
		if(rc)ret.second.second=max(ret.second.second,Rnow.second.second);
		
		if(Lnow.second.second!=-INF&&Rnow.second.first!=INF){
			ret.first.second+=(Rnow.second.first-Lnow.second.second)*Rnow.second.first;
		}
		if(ret.second.first!=INF&&ret.second.second!=-INF){
			ret.first.first=ret.second.second-ret.second.first;
		}
		return ret;
	}
	#undef lc 
	#undef rc
}T;
char S[N];
int n,Q;
LL Ans[N];
struct Suffix_AutoMation{
	struct Suffix_Node{
		int vis[11];
		int pre,step;
	}SA[N<<2];
	int cnt,last;
	int fa[N][21];
	vector<pair<int,int> >End[N];
	int pos[N];
	void Insert(char C,int Id){
		int p=last;
		int np=++cnt;
		last=np;
		SA[np].step=SA[p].step+1;
		for(;!SA[p].vis[C-'0'];p=SA[p].pre)SA[p].vis[C-'0']=np;
		if(!p){
			SA[np].pre=1;
		}
		else{
			int q=SA[p].vis[C-'0'];
			if(SA[q].step==SA[p].step+1){
				SA[np].pre=q;
			}
			else{
				int nq=++cnt;
				SA[nq].step=SA[p].step+1;
				memcpy(SA[nq].vis,SA[q].vis,sizeof(SA[nq].vis));
				SA[nq].pre=SA[q].pre;
				SA[np].pre=SA[q].pre=nq;
				for(;SA[p].vis[C-'0']==q;p=SA[p].pre)SA[p].vis[C-'0']=nq;
			}
		}
		pos[Id]=np;
		T.Update(root[np],1,n,Id);
	}
	void DFS(int u,int fat){
		fa[u][0]=fat;
		for(int i=1;i<=20;++i){
			fa[u][i]=fa[fa[u][i-1]][i-1];
		}
		for(int i=first[u];i;i=e[i].nxt){
			int v=e[i].v;
			DFS(v,u);
			root[u]=T.Merge(root[u],root[v],1,n);
		}
//		cout<<u<<" "<<T.cnt<<'\n';
	}
	void Build(){
		for(int i=1;i<=cnt;++i){
			add(SA[i].pre,i);
		}
		DFS(1,0);
	}
	int GetFa(int x,int len){
		for(int i=20;i>=0;--i){
			if(fa[x][i]&&SA[fa[x][i]].step>=len){
				x=fa[x][i];
			}
		}
		return x;
	}
	LL Get(int pos,int len){
		int L=T.QueryL(root[pos],1,n,1,n);
		int R=T.QueryR(root[pos],1,n,1,n);
		if(L+len<=R-len){//Cas 1
			int mid=T.QueryL(root[pos],1,n,L+len,R-len);
			if(mid!=INF){
				return 1LL*(n-1)*(n-2)/2;
			}
		}
		//Cas 2
		LL ret=0;			
		if(L==R){//Cas 2.0
			ret=1LL*(len-1)*(len-2)/2+1LL*(len-1)*(L-len+n-R);
			return 1LL*(n-1)*(n-2)/2-ret;
		}
		if(R-len+1<=L){//Cas 2.1
			//Cas 2.11
			LL Ed=R-len+1;
			pair<pair<LL,LL>,pair<int,int> >now=T.QuerySum(root[pos],1,n,1,n);
				
			ret=ret+now.first.second-Ed*now.first.first;				
			//Cas 2.12
				//Cas 2.120
				ret=ret+(L-Ed)*(L-Ed-1)/2;
				//Cas 2.121
				ret=ret+(L-Ed)*(L-len+(n-L));
		}
		else{
			int suc=T.QueryR(root[pos],1,n,1,L+len-1);
			int pre=T.QueryL(root[pos],1,n,L+len,n);
			
			int Ed=R-len+1;
			
			int Nxt=T.QueryR(root[pos],1,n,1,Ed);
			pair<pair<LL,LL>,pair<int,int> >now=T.QuerySum(root[pos],1,n,Ed,L+len-1);
			if(now.second.first!=INF&&now.second.second!=-INF){
				now.first.first=now.second.second-Nxt;
				now.first.second+=(now.second.first-Nxt)*now.second.first;
				now.second.first=Nxt;
			}
			
			ret=ret+now.first.second-Ed*now.first.first;
			if(suc!=-INF&&pre!=INF){
				ret=ret+(L-(suc-len+1))*(pre-Ed)*(pre>=Ed);
			}
		}
		return 1LL*(n-1)*(n-2)/2-ret;
	}
	void Calc(int u){
		if(End[u].size()){
			for(int j=0;j<End[u].size();++j){
				int len=End[u][j].first;
				int now=GetFa(u,len);
				Ans[End[u][j].second]=Get(now,len);
			}
		}
		for(int i=first[u];i;i=e[i].nxt){
			int v=e[i].v;
			Calc(v);
		}
	}
	void Solve(){
		cnt=last=1;
		for(int i=1;i<=n;++i){
			Insert(S[i],i);
		}
		Build();
//		exit(0);
		for(int i=1;i<=Q;++i){
			int l,r;
			read(l);
			read(r);
			End[pos[r]].push_back(make_pair(r-l+1,i));			
		}
		Calc(1);
		for(int i=1;i<=Q;++i){
			cout<<Ans[i]<<'\n';
		}
	}
}SAM;
int main(){
//	freopen("cutting.in","r",stdin);
//	freopen("cutting.out","w",stdout);
	scanf("%d%d",&n,&Q);
	scanf("%s",S+1);
	SAM.Solve();
	return 0;
}
```


---

## 作者：Kalenist (赞：1)

## 题意简述

给定字符串 $S$，多次询问给定其字串 $S[l,r]$，求有多少二元组 $(i,j)$ 满足 $i<j-1$，且 $S[l,r]$ 出现在 $S[1,i]$ 或 $S[i+1,j-1]$ 或 $S[j,|S|]$ 中。

## 题解

提供一种可能更为简洁的思考方式/实现方法？

首先考虑建出 SAM，倍增跳到 $S[l,r]$ 所在节点，线段树合并得到其 $\text{endpos}$ 集合。接下来从 $\text{endpos}$ 角度看贡献。令 $n=|S|,len=r-l+1,mnp,mxp$ 分别为跳到节点 $\text{endpos}$ 中的最小值和最大值。

先考虑子串出现在前后缀的情况，这是容易满足的，贪心选取最左和最右的位置让划分包含即可。贡献即为 
 
$$
\binom{mxp-len}{2}+\binom{n-mnp}{2}-\binom{\max(0,mxp-len-mnp+1)}{2}
$$

最后一项为容斥。接下来只需考虑子串出现在中间的情况，此时有 $i \in [1,mnp),j \in (mxp-len+1,n]$。

先考虑 $j$ 可以在区间任选的情况，即子串在 $mxp-len+1$ 前出现过。记 $pre$ 为 $\text{endpos}$ 集合中小于等于 $mxp-len+1$ 的最大的元素（**假如不存在，若 $mnp$ 与 $mxp$ 代表的字符串不交则令其为 $mnp$ ，否则令其为 $len$，这是为了与下面的计算式切合**），则当 $i \in [1,\min(mnp-1,pre-len)]$ 时，$j$  可以任取，贡献为 

$$
\min(mnp-1,pre-len) \times (n-mxp+len-1)
$$

最终只需考虑 $i \in (\min(mnp-1,pre-len),mnp)$ 的情况，对于一个 $i$ 贪心选取在 $i$ 后面最靠左的位置即可。令 $suf_i$ 表示 $\text{endpos}$ 中大于等于 $i$ 的第一个元素，则这部分贡献为

$$
\sum_{i=\min(mnp-1,pre-len)+1}^{mnp-1} (n-suf_{i+len})
$$

注意 $suf$ 有可能不存在，所以右端点要与 $mxp-len$ 取 $\min$。记 $nl=\min(mnp+len,pre+1),nr=\min(mxp,mnp+len-1)$，则原式即为

$$
\sum_{i=nl}^{nr} (n-suf_i)
$$

至此贡献已统计完毕。注意上述统计并没有单独考虑如 $pre-len>mnp$ 等特殊情况，因此可能出现 $nl>nr$，判掉即可。

总复杂度 $\operatorname{O}((n+q)\log{n})$。
### 代码实现
统计中需要在区间中寻找前驱和后继，线段树上二分即可。

至于要用到的区间 $suf$ 之和，注意到对于一个区间，区间外对区间内的影响总是形如它右边的区间影响其后缀的  $suf$ ，即这是可以在线段树的 $\text{pushup}$ 中维护的。具体地，线段树储存 $l,r,lp,rp,ans$ 分别表示当前区间的左右端点和最左最右的 $\text{endpos}$ 位置（不存在设为 $0$）以及 $suf$ 和，记 $ls,rs$ 分别为左右儿子，那么 $\text{pushup}$ 中多出来的贡献就是 `(ls.r-max(ls.rp,ls.l-1))*rs.lp`，单独算上即可。

注意对于询问区间 $[nl,nr],[rp+1,nr]$ 部分由于不确定后继是没有统计到贡献的，单独求出 $suf_{nr+1}$ 补上贡献即可。

### Code

线段树部分：
```cpp
int lc[N*40],rc[N*40];
struct ele{long long ans;int l,r,lp,rp,sum;}tr[N*40];

inline ele pushup(ele ls,ele rs,int l,int mid,int r)
{
    ele res;
    if(!ls.l) ls.l=l,ls.r=mid;//判掉空节点
    if(!rs.r) rs.l=mid+1,rs.r=r;
    res.l=ls.l,res.r=rs.r;
    res.sum=ls.sum+rs.sum;
    res.lp=ls.lp?ls.lp:rs.lp;
    res.rp=rs.rp?rs.rp:ls.rp;
    res.ans=ls.ans+rs.ans+1ll*(ls.r-max(ls.rp,ls.l-1))*rs.lp;
    return res;
}

inline void modify(int &k,int l,int r,int pos)
{
    if(!k) k=++totnode;
    int mid=l+r>>1;
    if(l == r) {tr[k]=(ele){l,l,l,l,l,1};return;}
    if(pos <= mid) modify(lc[k],l,mid,pos);
    else modify(rc[k],mid+1,r,pos);
    return void(tr[k]=pushup(tr[lc[k]],tr[rc[k]],l,mid,r));
}

inline int merge(int x,int y,int l,int r)
{
    if(!x || !y) return x+y;
    int k=++totnode,mid=l+r>>1;
    if(l == r) {tr[k]=tr[x].sum?tr[x]:tr[y];return k;}
    lc[k]=merge(lc[x],lc[y],l,mid);
    rc[k]=merge(rc[x],rc[y],mid+1,r);
    tr[k]=pushup(tr[lc[k]],tr[rc[k]],l,mid,r);
    return k;
}

inline int binary(int k,int l,int r,int x,int y)
{
    if(!tr[k].sum) return 0;
    if(l == r) return l;
    int mid=l+r>>1,res=0;
    if(x <= mid) res=binary(lc[k],l,mid,x,y);
    if(!res && mid < y) res=binary(rc[k],mid+1,r,x,y);
    return res;
}

inline int find(int k,int l,int r,int x,int y)
{
    if(!tr[k].sum) return 0;
    if(l == r) return l;
    int mid=l+r>>1,res=0;
    if(mid < y) res=find(rc[k],mid+1,r,x,y);
    if(!res && x <= mid) res=find(lc[k],l,mid,x,y);
    return res;
}

inline ele query(int k,int l,int r,int x,int y)
{
    if(!k || l >= x && r <= y) return tr[k];
    int mid=l+r>>1,fl=0,fr=0;ele ls,rs;
    if(x <= mid) ls=query(lc[k],l,mid,x,y),fl=1;
    if(mid < y) rs=query(rc[k],mid+1,r,x,y),fr=1;
    if(fl && fr) return pushup(ls,rs);
    return fl?ls:rs;
}

```
统计部分：
```cpp
inline long long solve(int x,int len,int flag)
{
    long long res=C2(mxp[x]-len)+C2(n-mnp[x]);
    res-=C2(max(0,mxp[x]-len-mnp[x]+1));//前后缀包含的部分
    int pre=find(rt[x],1,n,1,mxp[x]-len+1);
    if(!pre) pre=flag?len:mnp[x];
    res+=1ll*min(mnp[x]-1,pre-len)*(n-mxp[x]+len-1);//j任取的部分
    int nl=min(mnp[x]+len,pre+1);
    int nr=min(mxp[x],mnp[x]+len-1);
    if(nl > nr) return res;//特判空区间
    ele nw=query(rt[x],1,n,nl,nr);
    int suf=nr<n?binary(rt[x],1,n,nr+1,n):0;
    res+=1ll*n*(nr-nl+1)-(nw.ans+1ll*(nr-max(nw.rp,nl-1))*suf);
    return res;
} 

int main()
{
                 
    //预处理                                         
                                             
    For(i,1,m)
    {
        int l=read(),r=read(),nl=r-l+1,x=pos[r];
        Down(j,19,0) if(anc[x][j])//倍增
            if(len[anc[x][j]] >= nl) x=anc[x][j];
        printf("%lld\n",solve(x,nl,mxp[x]-nl<=mnp[x]));
    }
    return 0;
}
```
## 如有不足或遗漏恳请指出！谢谢大家！

---

## 作者：lzyqwq (赞：1)

闲话：D2T3 要是出这种题我得乐开花了。看了几眼就会根号了，30 min 左右发现好像优化不到 polylog 就直接开写了，写完后以为自己被卡常了最后发现是分块没初始化原地变平方。。。改一下就过了，甚至比一些 polylog 要快。

[P4384 [八省联考 2018] 制胡窜](https://www.luogu.com.cn/problem/P4384)

> - 给出长度为 $n$ 的字符串，$q$ 次询问 $l,r$，求满足以下条件的二元组 $(i,j)$ 的对数，满足：
>     - $1\le i<j\le n$。
>     - $i+1<j$。
>     - $s[l,r]$ 在 $s[1,i]$ 或 $s[j,n]$ 或 $s[i+1,j-1]$ 中出现。
>  - $n\le 10^5$，$q\le 3\times 10^5$。

对 $s$ 后缀排序。先考虑在 $s[1,i]$ 中出现的对数。找到 $s[l,r]$ 最左边的出现位置 $[l_1,r_1]$，那么 $i\ge r_1$ 且 $i+1<j$ 的二元组均可，容易计算。同理，可以找到最右边出现的位置 $[l_2,r_2]$，$j\le r_2$ 且 $i+1<j$ 的二元组均可。然后减去算重的 $r_1\le i$ 且 $j\le r_2$ 且 $i+1<j$ 的二元组即可。

考虑如何找到这样的出现位置，以 $[l_1,r_1]$ 为例，只需要找到最小的左端点即可。此时左端点 $l_1$ 需满足与 $s[l,n]$ 的 $\text{LCP}$ 长度 $\ge r - l +1$，容易转化成 $\text{height}$ 数组上的排名区间。此时要求一个排名区间内后缀开始位置的最小值。以排名为下标 $\text{sa}_i$ 为权值建立 ST 表即可。

对于剩下的二元组，均要求 $s[l,r]$ 仅在 $s[i+1,j-1]$ 中出现，此时 $i<r_1$，考虑统计每个 $i$ 的答案。记 $f_i$ 表示 $s[l,r]$ 在 $s[i,n]$ 中最左边出现的左端点位置。注意到这样一个重要事实：若 $s[l,r]$ 在 $s[x,y]$ 中出现，一定满足 $f_x+r-l\le y$，正确性显然。那么对于一个 $i$，她可以选择的 $j$ 满足 $j\in [f_{i+1}+r-l+1,n]$。同时 $s[l,r]$ 不能在 $s[j,n]$ 中出现，需要满足 $j\in [r_2+1,n]$。那么最终的可供选择的 $j$ 的个数就是 $\min\{n-r_2,n-f_{i+1}-r+l\}$。注意到 $f_i$ 非降，因此考虑找到一个分界点 $k$ 使得 $i\in [1,k]$ 时 $\min\{n-r_2,n-f_{i+1}-r+l\}=n-r_2$；当 $i\in [k+1,n]$ 时 $\min\{n-r_2,n-f_{i+1}-r+l\}=n-f_{i+1}-r+l$。

容易发现这个分界点 $k$ 满足 $s[k,k+r-l]$ 是 $s[l,r]$ 最右边的位于 $r_2$ 左边（含 $r_2$）的出现位置。即要求满足 $k\le r_2-r+l$ 且 $s[l,r]=s[k,k+r-l]$ 的最大的 $k$。进一步用排名区间刻画第二个条件，可以将问题变成 3-side 矩形最大值，扫描线 + 线段树维护即可。

这一步其实有若干 2log 方法，但是为了给后面的根号算法留出时间不得不优化一下前面，即使她们不是瓶颈。

那么就可以把 $\min$ 拆掉了。注意此时还需要讨论 $k$ 和 $r_1$ 的大小关系，将 $i$ 的范围限制在一个区间内，这是容易的。接下来，$[1,k]$ 的部分是好做的，用 $n-r_2$ 乘上区间长度即可。$[k+1,n]$ 的部分也可以拆成对应区间长度乘上 $n-r+l$ 再减去 $\sum f_{i+1}$。

令 $i\leftarrow i+1$，那么问题变成 $q$ 次询问一个区间 $L,R$ 内的 $\sum\limits_{i=L}^Rf_i$。同样使用排名区间刻画 $f_i$，以 $s[l,r]$ 为前缀的后缀排名区间为 $[x,y]$，那么 $f_i$ 就是 $i$ 在集合 $\{\text{sa}_p\,|\,p\in [l,r]\}$ 中的后继。

然后就是，大家好，我喜欢暴力数据结构，于是使用分块通过了此题.jpg。

对排名区间跑莫队，插入一个元素 $p$ 时，记 $\text{sa}_p$ 在当前集合中的前驱、后继为 $u,v$，那么相当于 $[u+1,p]$ 内的 $f_i$ 要从 $v$ 变成 $p$，即区间加 $p-v$。

注意到插入不方便维护前驱后继，但是删除容易用链表维护前驱后继，于是考虑只删莫队，用可撤销链表维护当前集合中的 $\text{sa}_p$。一次删除还需要支持一次区间加操作，同时用栈记录每一次区间加操作，那么撤销只需要区间加相反数。一个询问的答案就是区间求和。

现在问题变成：$\mathcal{O}(n\sqrt q)$ 次区间加、$\mathcal{O}(q)$ 次区间求和。容易用 $\mathcal{O}(1)$ 修改 $\mathcal{O}(\sqrt n)$ 查询的分块维护。

大概是这样的，我们直接维护 $f_i$ 前缀和数组 $S_i$，对于一次区间加操作 $(l,r,v)$，有：

- 对于 $i\in [l,r]$，$S_i\leftarrow S_i+(i-l+1)v$。
- 对于 $i\in[r+1,n]$，$S_i\leftarrow S_i+(r-l+1)v$。

考虑将 $S_i$ 表示成 $m_ii+b_i$ 的形式，初始令 $m_i=0,b_i=S_i$ 即可。对于第一种操作，相当于 $[l,r]$ 内 $m_i\leftarrow m_i+v$，$b_i\leftarrow b_i+(1-l)v$；对于第二种操作，相当于 $[r+1,n]$ 内 $b_i\leftarrow b_i+(r-l+1)v$。区间求和只需要单点查询 $S_R$ 和 $S_{L-1}$，那么只需要知道这两个位置的 $m_i$ 和 $b_i$ 即可。现在问题变成 $m_i,b_i$ 上 $\mathcal{O}(n\sqrt q)$ 次区间加、$\mathcal{O}(q)$ 次单点查询。维护两个序列的差分数组，变成单点修改、前缀查询。对序列分块，维护差分数组和块内差分数组的和，容易 $\mathcal{O}(1)$ 修改 $\mathcal{O}(\sqrt n)$ 查询。注意到一次区间加操作被我们拆成了两次差分数组上的单点修改，但是注意到两个操作都会修改 $r+1$ 这个位置，于是可以合并一下减少常数。

于是做完了。时间复杂度 $\mathcal{O}(q\sqrt n)$，空间复杂度 $\mathcal{O}(n\log n)$。不卡常。当然此做法中 2log 并不是瓶颈，因此使用线段树维护 $\text{height}$ 数组即可做到线性空间。~~抛开时间不谈，空间吊打 std，所以我爆标了。~~


```cpp
#include <bits/stdc++.h>
using namespace std; typedef long long ll; const int N = 100005, M = 300005;
int n, q, tp[M], cq, B, pr[N], nx[N], to, tk; string s; ll ans[M];
struct q1 { int l, r, x, y, lp, rp; } qr[M], Q[M]; vector<int> g[N];
struct q2 { int l, r, v; } sk[N]; pair<int *, int> st[M];
struct STmin {
	int a[20][N];
	void I(int *b) {
		for (int i = 1; i <= n; ++i) a[0][i] = b[i];
		for (int i = 1; (1 << i) <= n; ++i)
			for (int j = 1; j + (1 << i) - 1 <= n; ++j)
				a[i][j] = min(a[i - 1][j], a[i - 1][j + (1 << i - 1)]);
	}
	int Q(int l, int r) {
		int k = __lg(r - l + 1); return min(a[k][l], a[k][r - (1 << k) + 1]);
	}
} s1;
struct STmax {
	int a[20][N];
	void I(int *b) {
		for (int i = 1; i <= n; ++i) a[0][i] = b[i];
		for (int i = 1; (1 << i) <= n; ++i)
			for (int j = 1; j + (1 << i) - 1 <= n; ++j)
				a[i][j] = max(a[i - 1][j], a[i - 1][j + (1 << i - 1)]);
	}
	int Q(int l, int r) {
		int k = __lg(r - l + 1); return max(a[k][l], a[k][r - (1 << k) + 1]);
	}
} s2;
struct SGT {
	int a[N << 2];
	int ls(int x) { return x << 1; } int rs(int x) { return x << 1 | 1; }
	void U(int x, int l, int r, int k, int v) {
		if (l == r) return void(a[x] = v); int m = l + r >> 1;
		if (k <= m) U(ls(x), l, m, k, v); else U(rs(x), m + 1, r, k, v);
		a[x] = max(a[ls(x)], a[rs(x)]);
	}
	int Q(int x, int l, int r, int ql, int qr) {
		if (ql <= l && r <= qr) return a[x]; int m = l + r >> 1, o = 0;
		if (ql <= m) o = Q(ls(x), l, m, ql, qr);
		if (qr > m) o = max(o, Q(rs(x), m + 1, r, ql, qr)); return o;
	}
} tr;
struct SA {
	int sa[N], rk[N], c[N], y[N], h[N]; STmin d;
	void I() {
		for (int i = 1; i <= n; ++i) ++c[s[i]];
		for (int i = 1; i < N; ++i) c[i] += c[i - 1];
		for (int i = n; i >= 1; --i) sa[c[s[i]]--] = i;
		for (int i = 2, t = rk[sa[1]] = 1; i <= n; ++i)
			rk[sa[i]] = (s[sa[i]] == s[sa[i - 1]] ? t : ++t);
		for (int w = 1, t; w <= n; w <<= 1) {
			t = 0; for (int i = n - w + 1; i <= n; ++i) y[++t] = i;
			for (int i = 1; i <= n; ++i) if (sa[i] > w) y[++t] = sa[i] - w;
			memset(c, 0, sizeof c); for (int i = 1; i <= n; ++i) ++c[rk[i]];
			for (int i = 1; i <= n; ++i) c[i] += c[i - 1];
			for (int i = n; i >= 1; --i) sa[c[rk[y[i]]]--] = y[i];
			swap(rk, y); rk[sa[1]] = t = 1;
			for (int i = 2; i <= n; ++i)
				rk[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &&
				             y[sa[i] + w] == y[sa[i - 1] + w] ? t : ++t);
			if (t == n) break;
		}
		for (int i = 1, k = 0; i <= n; ++i) {
			if (rk[i] == 1) { k = 0; continue; } if (k) --k;
			while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k; h[rk[i]] = k;
		}
		d.I(h);
	}
	int lcp(int x, int y) {
		if (x == y) return n - sa[x] + 1;
		if (x > y) swap(x, y); ++x; return d.Q(x, y);
	}
	auto Q(int x, int y) {
		int l = 1, r = x, f, g, m;
		while (l <= r) {
			m = l + r >> 1; if (lcp(m, x) >= y) f = m, r = m - 1; else l = m + 1;
		}
		l = x; r = n;
		while (l <= r) {
			m = l + r >> 1; if (lcp(x, m) >= y) g = m, l = m + 1; else r = m - 1;
		}
		return make_pair(f, g);
	}
} S;
struct BLK {
	ll a0[N], t0[N], a1[N], t1[N]; int bl[N], br[N], be[N], B;
	void I() {
		B = sqrt(n); for (int i = 1; i <= n; ++i) be[i] = (i - 1) / B + 1;
		for (int i = 1; i <= be[n]; ++i)
			bl[i] = br[i - 1] + 1, br[i] = min(n, i * B);
	}
	void C() { for (int i = 1; i <= n; ++i) a0[i] = a1[i] = t0[i] = t1[i] = 0; }
	void U(int l, int r, int v) {
		a1[l] += v; a0[l] += 1ll * (1 - l) * v;
		t1[be[l]] += v; t0[be[l]] += 1ll * (1 - l) * v;
		if (r < n)
			a1[r + 1] -= v, a0[r + 1] += 1ll * r * v,
			t1[be[r + 1]] -= v, t0[be[r + 1]] += 1ll * r * v;
	}
	ll Q(int x) {
		ll _0 = 0, _1 = 0;
		for (int i = 1; i < be[x]; ++i) _0 += t0[i], _1 += t1[i];
		for (int i = bl[be[x]]; i <= x; ++i) _0 += a0[i], _1 += a1[i];
		return _1 * x + _0;
	}
} ds;
ll C(int x) { return 1ll * (x - 1) * (x - 2) >> 1; }
void D(int id, int p, int o, int L) {
	if (p < 2 || o > n || o < L) return; g[o - L].emplace_back(id);
}
void rD(int id, int p, int o, int L) {
	if (p < 2 || o > n) return; p = min(p, n - L + 1);
	if (tp[id] > 1) ans[id] += 1ll * (min(tp[id], p) - 1) * (n - o + 1);
	if (tp[id] >= p) return; ans[id] += 1ll * (p - max(tp[id], 1)) * (n - L + 1);
	Q[++cq] = {qr[id].x, qr[id].y, max(2, tp[id] + 1), p, id, 0};
}
void del(int x, bool o) {
	x = S.sa[x]; int u = pr[x], v = nx[x];
	if (o) {
		st[++to] = {&pr[v], pr[v]}; st[++to] = {&nx[u], nx[u]};
		sk[++tk] = {u + 1, x, v - x};
	}
	pr[v] = u; nx[u] = v; ds.U(u + 1, x, v - x);
}
int main() {
	cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cin >> n >> q >> s;
	s = ' ' + s + ' '; S.I(); s1.I(S.sa); s2.I(S.sa); ds.I();
	for (int i = 1, l, r, lp, rp; i <= q; ++i) {
		cin >> l >> r; auto [x, y] = S.Q(S.rk[l], r - l + 1);
		lp = s1.Q(x, y); rp = s2.Q(x, y); qr[i] = {l, r, x, y, lp, rp};
		if (lp + r - l < rp)
			ans[i] = C(n - lp - r + l + 1) + C(rp) - C(rp - lp - r + l + 1);
		else ans[i] = C(n - lp - r + l + 1) + C(rp);	
		D(i, min(lp + r - l, rp), rp + 1, r - l + 1);
	}
	for (int i = 1; i <= n; ++i) {
		tr.U(1, 1, n, S.rk[i], i);
		for (int j : g[i]) tp[j] = tr.Q(1, 1, n, qr[j].x, qr[j].y);
	}
	for (int i = 1; i <= q; ++i) {
		auto [l, r, x, y, lp, rp] = qr[i];
		rD(i, min(lp + r - l, rp), rp + 1, r - l + 1);
	}
	B = max(1, (int)(n / sqrt(cq)));
	stable_sort(Q + 1, Q + cq + 1, [&](q1 u, q1 v) {
		return u.l / B != v.l / B ? u.l / B < v.l / B : u.r > v.r;
	});
	for (int i = 1, l, r, bl, br; i <= cq; ++i) {
		if (i == 1 || Q[i].l / B != Q[i - 1].l / B) {
			bl = max(1, Q[i].l / B * B); br = min(bl + B - 1, n);
			for (int j = 0; j <= n + 1; ++j) pr[j] = j - 1, nx[j] = j + 1;
			l = 1; r = n; ds.C(); for (int j = 1; j <= n; ++j) ds.U(j, j, j);
			while (l < bl) del(l++, 0);
		}
		while (r > Q[i].r) del(r--, 0); while (l < Q[i].l) del(l++, 1);
		ans[Q[i].lp] -= ds.Q(Q[i].y) - ds.Q(Q[i].x - 1);
		l = bl; for (; to; --to) *st[to].first = st[to].second;
		for (; tk; --tk) ds.U(sk[tk].l, sk[tk].r, -sk[tk].v);
	}
	for (int i = 1; i <= q; ++i) cout << ans[i] << '\n'; return 0;
}
```

还有一个优化，就是把分块换成迭代分块，查询部分可以做到 $\mathcal{O}\left(qn^{\frac{1}{3}}\right)$。大概就是以 $\mathcal{O}\left(n^{\frac{2}{3}}\right)$ 和 $\mathcal{O}\left(n^{\frac{1}{3}}\right)$ 为块长分两层块，那么一个询问会被拆成 $\mathcal{O}\left(n^{\frac{1}{3}}\right)$ 个大块、小块、和散点。修改就是改所在散点、小块和大块的信息。这样瓶颈是 $\mathcal{O}(n\sqrt q)$。但感觉不会快多少，毕竟增大了修改的常数。

那么这个做法可以做到 polylog 吗？答案是可以的，具体可以参照其他 SA 题解。大概就是集合可以用比排名区间更强的结构去刻画，即 $\text{height}$ 把数组 $\ge r-l+1$ 的两端合并得到若干连通块，那么集合就是连通块内的 $\text{sa}_p$。考虑每个连通块开一棵动态开点线段树并用 `set` 维护 $\text{sa}_p$，合并时启发式合并，类似地找前驱、后继进行区间加，此时只有 $\mathcal{O}(n\log n)$ 次合并，因此时空复杂度均为 $\mathcal{O}\left(n\log^2 n\right)$。感觉可能跑不过根号。更强的做法是线段树合并，但我还没想清楚怎么在合并时处理前驱、后继变动的问题。先咕着。

> 本质劣于 polylog 的根号算法注定会被人抛弃，就像本质弱于别人的我注定进入不了省队罢。

---

## 作者：居然有个高手 (赞：0)

简述：在一个长度为 $n$ 的数字串 $s$ 上，每次给出 $l,r$，求有多少对 $(i,j)$ 满足 $s_{l,r}$ 出现在 $s_{1,i}$ 或 $s_{i+1,j-1}$ 或 $s_{j,n}$ 中，且此三串均不为空。

下称 $s_{l,r}$ 为询问串，且 $len$ 表示 $r-l+1$。

发现限制条件为“或”，直接考虑容斥，将问题转为询问串同时出现在三者中的某个非空子集的 $(i,j)$ 方案数。

与 $s_{i+1,j-1}$ 无关的求值是简单的。求出询问串在 $s$ 第一次与最后一次出现位置后即可得出计算式。求位置则可以经典的使用 SAM 并线段树合并维护 endpos 集合，树上倍增找到询问串所属结点后线段树内的第一个位置 $S$ 与最后一个位置 $T$（此处 $T$ 需减去 $len-1$） 即为所求。

单独考虑询问串在 $s_{i+1,j-1}$ 中的情况。为了不重不漏的计数，我们枚举线段树内某个有效的 endpos $p$，若其上个 endpos 为 $q$，则其贡献为 $(n-p)(p-q)$，特殊的，$p$ 为第一个位置时，贡献为 $(n-p)(p-len)$。对第一个特殊处理，发现剩余的 $p$ 的贡献只与其上一个 endpos 相关，可以线段树维护第一个位置、最后一个位置以及除第一个位置外的贡献总和，在上面合并的过程中一同处理。

要求询问串出现在 $s_{1,i}$ 与 $s_{i+1,j-1}$ 中。发现此时 $p<S+len$ 的 endpos 全部无效，而只有第一个满足 $p\ge S+len$ 的 endpos 贡献发生变化。线段树上二分、区间查询即可。

要求询问串出现在 $s_{i+1,j-1}$ 与 $s_{j,n}$ 中。同样发现此时 $p \ge T$ 的无效。而前面所有点的贡献变为 $(T-p)(p-q)$，拆开后贡献为 $Tp-Tq-p^2+pq$。类似地，线段树维护 $pq-p^2$，$\sum Tp-Tq$ 事实上是最后一个有效位置减去第一个有效位置的差乘 $T$，可以简单区间询问维护。

三者都要求出现。在 $s_{i+1,j-1}$ 与 $s_{j,n}$ 做法的基础上删除掉 $p<S+len$ 的位置即可。

时间复杂度：$O((n+q)\log n)$，空间复杂度 $O(n\log n)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
int n,q,last,tot,root[N<<1],f[19][N<<1],ed[N];
char s[N];
vector<int>e[N<<1];
struct node{
	int mn,mx;
	long long sum,s;
};
inline node operator+(node a,node b){
	node c;
	c.mn=min(a.mn,b.mn);
	c.mx=max(a.mx,b.mx);
	c.sum=a.sum+b.sum;
	c.s = a.s+b.s;
	if(a.mn<=n&&b.mn<=n)c.sum+=(n-b.mn)*1ll*(b.mn-a.mx),c.s+=b.mn*1ll*a.mx - b.mn*1ll*b.mn;
	return c;
}
namespace EDT{
	node now;
	int tot=0;
	struct tree{
		int lc,rc;
		node v;
	}t[N*40];
	#define mid (l+r>>1)
	inline void up(int p){
		t[p].v=t[t[p].lc].v+t[t[p].rc].v;
	}
	inline void insert(int&p,int l,int r,int pos){
		if(!p)p=++tot;
		if(l==r){
			t[p].v.mn=t[p].v.mx=l;
			return;
		}
		if(pos<=mid)insert(t[p].lc,l,mid,pos);
		else insert(t[p].rc,mid+1,r,pos);
		up(p);
	}
	inline int merge(int p,int q,int l,int r){
		if(!p||!q)return p|q;
		int now=++tot;
		t[now].lc=merge(t[p].lc,t[q].lc,l,mid);
		t[now].rc=merge(t[p].rc,t[q].rc,mid+1,r);
		up(now);
		return now;
	}
	inline int queryl(int p,int l,int r,int pos){
		if(!p)return 0;
		if(l==r)return l;
		int w = 0;
		if(pos<=mid&&t[p].lc)w=queryl(t[p].lc,l,mid,pos);
		if(w)return w;
		return queryl(t[p].rc,mid+1,r,pos);
	}
	inline int queryr(int p,int l,int r,int pos){
		if(!p)return 0;
		if(l==r)return l;
		int w=0;
		if(pos>mid&&t[p].rc)w=queryr(t[p].rc,mid+1,r,pos);
		if(w)return w;
		return queryr(t[p].lc,l,mid,pos);
	}
	inline void askl(int p,int l,int r,int ql,int qr){
		if(ql>qr)return;
		if(!p)return;
		if(ql<=l&&r<=qr){
			now=now+t[p].v;
			return;
		}
		if(ql<=mid)askl(t[p].lc,l,mid,ql,qr);
		if(qr>mid)askl(t[p].rc,mid+1,r,ql,qr);
	}
	#undef mid
}
struct SAM{
	int fa,len,ch[10];
}t[N<<1];
inline void insert(int c,int id){
	int p = last,np=last=++tot;
	t[np].len=t[p].len+1;
	EDT::insert(root[np],1,n,id);ed[id]=np;
	for(;~p&&!t[p].ch[c];p=t[p].fa)t[p].ch[c]=np;
	if(p==-1){
		t[np].fa=0;
		return;
	}
	int q=t[p].ch[c];
	if(t[q].len==t[p].len+1){
		t[np].fa=q;
		return;
	}
	int now=++tot;
	t[now].len=t[p].len+1;t[now].fa=t[q].fa;
	t[np].fa=t[q].fa=now;
	for(int i = 0;i<10;i++)t[now].ch[i]=t[q].ch[i];
	for(;~p&&t[p].ch[c]==q;p=t[p].fa)t[p].ch[c]=now;
}
inline void dfs(int x){
	for(auto y:e[x]){
		dfs(y);
		root[x]=EDT::merge(root[x],root[y],1,n);
		f[0][y]=x;
	}
}
int main(){
	t[0].fa=-1;EDT::t[0].v.mn=1e9;
	n=read(),q=read();scanf("%s",s+1);
	for(int i = 1;i<=n;i++)insert(s[i]-'0',i);
	for(int i = 1;i<=tot;i++)e[t[i].fa].push_back(i);
	dfs(0);
	for(int j = 1;j<19;j++)for(int i = 1;i<=tot;i++)f[j][i]=f[j-1][f[j-1][i]];
	int l,r,len;
	long long ans;
	while(q--){
		l=read(),r=read();ans=0;len=r-l+1;
		if(l==r){
			printf("%lld\n",(n-1ll)*(n-2)/2);
			continue;
		}
		int p = ed[r];
		for(int j = 18;j>=0;j--)if(t[f[j][p]].len >= len)p=f[j][p];
		int S = EDT::t[root[p]].v.mn,T = EDT::t[root[p]].v.mx-len+1;
		ans += (n-S-1ll)*(n-S)/2 + (T-2)*(T-1ll)/2;
		if(T-S>=2)ans -= (T-S-1ll)*(T-S)/2;
		ans += EDT::t[root[p]].v.sum + (n-S)*1ll*(S-len);
		int a = EDT::queryl(root[p],1,n,S+len),b = EDT::queryr(root[p],1,n,T-1);
		if(a){
			ans -= (n-a)*1ll*(a-len-S+1);
			EDT::now={a,a,0,0};
			EDT::askl(root[p],1,n,a+1,n);
			ans-=EDT::now.sum;
		}
		if(b){
			ans -= (S-len)*1ll*(T-S);
			EDT::now={1000000000,0,0,0};
			EDT::askl(root[p],1,n,1,b);
			ans -= EDT::now.s;
			ans -= T*1ll*(b-S);
		}
		if(a&&b&&a<=b){
			ans += (T-a)*1ll*(a-len-S+1);
			EDT::now={a,a,0,0};
			EDT::askl(root[p],1,n,a+1,b);
			ans += EDT::now.s;
			ans += T*1ll*(b-a); 
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---


# [COTS 2017] 模板 Z1

## 题目背景


译自 [Izborne Pripreme 2017 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2017/) D2T2。$\texttt{4s,0.5G}$。


## 题目描述


> **题目**（【模板】RMQ）。
>
> 给定整数序列 $a_1,a_2,\cdots,a_n$，值域为 $[0,h)$。
> 
> 有 $m$ 次询问。第 $i$ 次询问给定 $l_i,r_i$，求出 $\displaystyle \max_{k\in [l_i,r_i]} \{a_k\}$。


给定 $n,m,h$，每个询问和对应的答案。求出一共有多少个可能的 $a$ 序列满足条件。只需要求出答案对 $(10^9+7)$ 取模后的结果。

## 说明/提示


#### 样例解释

样例 $1$ 解释：只有 $[1,0,0]$，$[1,0,1]$，$[1,0,2]$ 满足条件。

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le n,m,h\le 10^6$；
- $1\le l_i\le r_i\le n$；
- $0\le x_i\lt h$。


| 子任务编号 | $n\le $ |得分 |  
| :--: | :--: | :--: | 
| $ 1 $    | $ 100 $    | $ 20 $   |  
| $ 2 $    | $ 10^3 $   |   $ 30 $   |  
| $ 3 $    | $10^6$ |  $ 50 $   |  




## 样例 #1

### 输入

```
3 2 3
1 2 1
2 2 0```

### 输出

```
3```

## 样例 #2

### 输入

```
7 10 3
1 3 1
3 4 1
3 6 2
4 5 2
1 1 1
1 2 1
3 3 0
1 1 1
3 3 0
3 6 2```

### 输出

```
18```

# 题解

## 作者：zifanwang (赞：2)

[双倍经验](https://www.luogu.com.cn/problem/AT_abc262_h)

首先容易确定每个位置的上界，接下来考虑对每种上界分别求方案数，再乘起来。

对每一种上界将其对应的位置提出来，由于是区间 $\max$，只需要关注每个位置的值是否到达这个上界 $x$。枚举一个前缀，考虑维护 $f_i$ 表示最后一个达到上界位置为 $i$，确定完这个前缀中所有数的方案数。考虑确定当前枚举到的数 $p$：

1. $<x$，则将所有 $f_i\leftarrow f_i\cdot x$。
2. $=x$，则将 $f_p\leftarrow f_p+\sum f_i$

接下来只需要处理掉区间的限制，对于一个右端点为 $p$ 的区间 $[l,p]$，此时 $\forall i<l,f_i\leftarrow 0$ 即可，时间复杂度 $\mathcal O(n\log n)$，线段树或者双指针都可以实现。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 1000003
#define md 1000000007
#define pb push_back
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define rept(i,a,b) for(int i=(a);i<(b);++i)
#define drep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
struct node{
	int l,r,x;
}d[mxn];
int n,m,q,a[mxn],c[mxn];
vector<int>p[mxn],s1[mxn],s2[mxn];
vector<node>as[mxn];
multiset<int>s;
ll ans=1,t[mxn<<2],f[mxn<<2];
void build(int p,int l,int r){
	t[p]=!l,f[p]=1;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
}
inline void tag(int p,ll x){
	t[p]=t[p]*x%md,f[p]=f[p]*x%md;
}
inline void push_down(int p){
	if(f[p]!=1){
		tag(p<<1,f[p]),tag(p<<1|1,f[p]);
		f[p]=1;
	}
}
void add(int p,int x,int y,int l,int r){
	t[p]=(t[p]+y)%md;
	if(l==r)return;
	int mid=(l+r)>>1;
	push_down(p);
	if(x<=mid)add(p<<1,x,y,l,mid);
	else add(p<<1|1,x,y,mid+1,r);
}
void upd(int p,int l,int r,int L,int R){
	if(l<=L&&R<=r){t[p]=f[p]=0;return;}
	int mid=(L+R)>>1;
	push_down(p);
	if(l<=mid)upd(p<<1,l,r,L,mid);
	if(r>mid)upd(p<<1|1,l,r,mid+1,R);
	t[p]=(t[p<<1]+t[p<<1|1])%md;
}
void solve(int x){
	rept(i,0,p[x].size())c[i]=-1;
	for(node i:as[x]){
		int l=lower_bound(p[x].begin(),p[x].end(),i.l)-p[x].begin(),r=upper_bound(p[x].begin(),p[x].end(),i.r)-p[x].begin()-1;
		if(l>r){
			puts("0");
			exit(0);
		}
		c[r]=max(c[r],l);
	}
	build(1,0,p[x].size());
	rept(i,0,p[x].size()){
		ll s=t[1];tag(1,a[x]);
		add(1,i+1,s,0,p[x].size());
		if(c[i]>=0)upd(1,0,c[i],0,p[x].size());
	}
	ans=ans*t[1]%md;
}
signed main(){
	scanf("%d%d%d",&n,&q,&m),m--;
	for(int i=0,l,r,x;i<q;++i){
		scanf("%d%d%d",&l,&r,&x);
		s1[l].pb(x),s2[r+1].pb(x);
		d[i]={l,r,x};
		a[i]=x;
	}
	a[q]=m;sort(a,a+q+1);
	rep(i,1,n){
		for(int j:s1[i])s.insert(j);
		for(int j:s2[i])s.erase(s.find(j));
		int mx=s.size()?*s.begin():m;
		p[lower_bound(a,a+q+1,mx)-a].pb(i);
	}
	rept(i,0,q)as[lower_bound(a,a+q+1,d[i].x)-a].pb(d[i]);
	rep(i,0,q)if(as[i].size()||p[i].size())solve(i);
	cout<<ans;
	return 0;
}
```

---

## 作者：xxxxxzy (赞：0)

题目看起来还是很典，还是不会。

容易确定每个点的上界，拿个线段树做一下区间取 $\min$ 就好。

考虑对每个上界 $x$ 做离散化后的 dp，有三种转移：

1. $dp_{i-1,j} \to dp_{i,i}$，代表第 $i$ 位选到上界。
2. $dp_{i-1,j} \times x \to dp_{i,j}$，代表第 $i$ 位任意选。
3. $dp_{i,j} := 0(j<L_i)$，代表满足区间必须要有一个 $x$ 的限制。

这个东西只需要维护全局加，全局乘，前缀赋值为 $0$，拿个指针扫一遍最大前缀外加打两个 tag 就行。

值得注意的是，对于一个限制 $(l,r,0)$，应该直接把 $a_{l \to r}$ 赋值为 $0$，不参与 dp。

---


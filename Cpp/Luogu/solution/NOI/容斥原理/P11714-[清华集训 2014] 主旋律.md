# [清华集训 2014] 主旋律

## 题目描述

响应主旋律的号召，大家决定让这个班级充满爱，现在班级里面有 $n$ 个男生。

如果 $a$ 爱着 $b$，那么就相当于 $a$ 和 $b$ 之间有一条 $a \rightarrow b$ 的有向边。如果这 $n$ 个点的图是强联通的，那么就认为这个班级是充满爱的。

不幸的是，有一些不好的事情发生了，现在每一条边都可能被摧毁。我作为爱的使者，想知道有多少种摧毁的方式，使得这个班级任然充满爱呢？（说人话就是有多少边的子集删去之后整个图仍然强联通。）

## 说明/提示

- 对于 20% 的数据满足: $n \leq 5$；
- 对于 50% 的数据满足: $n \leq 8$；
- 对于 70% 的数据满足: $n \leq 10$；
- 对于 100% 的数据满足: $n \leq 15, 0 \leq m \leq n(n - 1)$。

## 样例 #1

### 输入

```
5 15
4 3
4 2
2 5
2 1
1 2
5 1
3 2
4 1
1 4
5 4
3 4
5 3
2 3
1 5
3 1```

### 输出

```
9390```

# 题解

## 作者：Linge_Zzzz (赞：42)

其实是整合了多篇题解的长处，这有人看不懂我直接吃。

# Sol

发现强连通很难刻画，不妨使用单步容斥，转化成算非强连通方案数。

考虑刻画一下非强连通，发现缩点之后一定是一个点数大于 $1$ 的 DAG。

于是，呃，考虑一种比较劣的做法，就是先暴力枚举这个图缩点之后每个点属于的 SCC 是哪个，然后对着这个算方案数。

于是现在需要算 DAG 生成子图。

考虑刻画 DAG，发现其一定存在一些点入度为 $0$。把这些点删了之后剩下的点还是 DAG，于是找到了一个子结构，可以对着这个 DP。

设 $dp_S$ 表示 $S$ 的答案，$E_{S,T}$ 表示 $S$ 到 $T$ 的边数，则有：

$$dp_S=\sum_{T\subseteq S,T\neq \emptyset}dp_{S-T}2^{E_{T,S-T}}$$

但是这对吗？这不对。因为 $S-T$ 里面可能还有入度为 $0$ 的点，会导致算重。

考虑一下子集反演，当前全集为 $S$，设 $f_T$ 表示 $T$ 内点恰为所有入度为 $0$ 的点的方案数，$g_T$ 表示钦定 $T$ 内点入度为 $0$ 的方案数。显然 $g_T=dp_{S-T}2^{E_{T,S-T}}$。有关系式：

$$g_T=\sum_{T\subseteq R}f_R$$

反演得到：

$$f_T=\sum_{T\subseteq R}(-1)^{|R|-|T|}g_R$$

重写一下转移式，进行一些式子的推导：

$$\begin{aligned}
dp_S&=\sum_{T\subseteq S,T\neq \emptyset}f_T\\
&=\sum_{T\subseteq S,T\neq \emptyset}\sum_{T\subseteq R}(-1)^{|R|-|T|}g_R\\
&=\sum_{R\subseteq S,R\neq \emptyset}(-1)^{|R|}g_R\sum_{T\subseteq R,T\neq \emptyset}(-1)^{|T|}\\
&=\sum_{R\subseteq S,R\neq \emptyset}(-1)^{|R|}g_R([R=\emptyset]-1)\\
&=\sum_{R\subseteq S,R\neq \emptyset}(-1)^{|R|+1}g_R\\
&=\sum_{T\subseteq S,T\neq \emptyset}(-1)^{|T|+1}dp_{S-T}2^{E_{T,S-T}}
\end{aligned}$$

于是得到了一个 $O(3^n)$ 算一次的做法，但是乘上暴力枚举缩点方案数之后复杂度爆炸。

考虑拓展这个东西到非强连通图计数上。

设 $dp_S$ 表示 $S$ 的答案，即 $S$ 缩成一个点的方案数。仿照上面的方法，设 $g_T$ 表示 $T$ 内的点缩成若干个入度为 $0$ 的点的方案数，转移的时候枚举 $T$，钦定 $T$ 内点缩成了若干入度为 $0$ 的点：

$$dp_{S}=2^{E_{S,S}}-\sum_{T\subseteq S,T\neq \emptyset}(-1)^{?}g_T2^{E_{T,S-T}+E_{S-T,S-T}}$$

但是发现容斥系数是不确定的，因为并不知道 $T$ 内的点到底缩成了多少个点。于是考虑修改 $g_T$ 的定义，令其包含上容斥系数，即缩成奇数个点的方案数减去缩成偶数个点的方案数，再写：

$$dp_{S}=2^{E_{S,S}}-\sum_{T\subseteq S,T\neq \emptyset}g_T2^{E_{T,S-T}+E_{S-T,S-T}}$$

这个式子可以 $O(3^n)$ 做了。但是还没做完，还需要算 $g_S$。

考虑找子结构，发现这些缩完之后的点互不相干，于是可以钦定 $\operatorname{lowbit}(S)$ 所属的 SCC 是新加入的：

$$g_S=dp_S-\sum_{T\subset S,\operatorname{lowbit}(S)=\operatorname{lowbit}(T)}dp_Tg_{S-T}$$

第一项是考虑 $S$ 单独为一个 SCC，$1$ 是奇数，所以要加上。后面一串是增加一个 SCC，奇偶性改变，所以要减去。

但是又出现了新问题，$g_S$ 和 $dp_S$ 好像互相依赖。真的互相依赖吗？$dp_S$ 的转移式中只有 $S=T$ 时会用到 $g_S$。重申一遍 $dp_S$ 是 $S$ 强连通的方案数，那么在 $dp_S$ 中减去 $g_S$ 中的 $dp_S$ 时，减去的这个 $dp_S$ 是合法的方案数，其不应该被减掉。

所以先算出 $g_S$，不加上 $dp_S$，再算出来 $dp_S$，把 $dp_S$ 加到 $g_S$ 上，是正确的。

于是现在只剩下最后一个问题了，怎么算 $E_{S,T}$。

看起来这个状态数是 $4^n$ 的，但是观察发现对于每个 $S$，只需要用到形如 $E_{T,S-T}$ 或者 $E_{S,S}$ 形式的 $E$。$T\subseteq S$，所以状态数是 $3^n$。但是空间复杂度还是 $O(4^n)$，所以考虑每枚举一个 $S$ 就重新计算 $E_{T,S-T}$，对于 $E_{T,T}$ 另外开一个计算。

先预处理出 $out_u$ 表示 $u$ 连向的点集，$in_u$ 表示连向 $u$ 的点集，这样就有递推式：

$$E_{T,S-T}=E_{T+x,S-T-x}-\operatorname{popcount}(out_x\operatorname{and} (S-T))+\operatorname{popcount}(in_x\operatorname{and} T)\\
E_{S,S}=E_{S-x,S-x}+\operatorname{popcount}(in_x\operatorname{and}S)+\operatorname{popcount}(out_x\operatorname{and}S)$$

这样，整个问题就能做到 $O(3^n)$ 了，非常厉害。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef pair<int,int> pii;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
const int N=18,INF=0x3f3f3f3f3f3f3f3f,mod=1e9+7;
int n,m,dp[1<<N],g[1<<N],in[N],out[N],e1[1<<N],e2[1<<N],p2[1145],pos[1<<N];
inline int lowbit(int x){return x&(-x);}
inline int popcnt(int x){return __builtin_popcount(x);}
vector<int> G[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	p2[0]=1;
	for(int i=1;i<=1000;i++)p2[i]=p2[i-1]*2%mod;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		out[u]|=(1<<(v-1));
		in[v]|=(1<<(u-1)); 
	}
	for(int i=0;i<n;i++)pos[1<<i]=i+1;
	for(int S=1;S<(1<<n);S++){
		int x=lowbit(S);
		e2[S]=e2[S-x]+popcnt(in[pos[x]]&S)+popcnt(out[pos[x]]&S);
	}
	for(int S=1;S<(1<<n);S++){
		e1[S]=0;
		for(int T=(S-1)&S;T;T=(T-1)&S){
			int x=lowbit(S-T);
			e1[T]=e1[T+x]-popcnt((S-T)&out[pos[x]])+popcnt(T&in[pos[x]]);
		}
		for(int T=(S-1)&S;T;T=(T-1)&S){
			if(lowbit(S)!=lowbit(T))continue;
			g[S]=(g[S]-dp[T]*g[S-T]%mod+mod)%mod;
		}
		dp[S]=p2[e2[S]];
		for(int T=S;T;T=(T-1)&S){
			dp[S]=(dp[S]-g[T]*p2[e1[T]+e2[S-T]]%mod+mod)%mod;
		}
		g[S]=(g[S]+dp[S])%mod;
	}
	cout<<dp[(1<<n)-1]<<endl;
	return 0;
}
```

---

## 作者：Genius_Star (赞：21)

发现现有的一些题解讲的不太详细，不会的还是不会，于是这里写了一篇较为详细的题解。

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18746782)

### 思路：

不同于 DAG 计数的是，强联通不好刻画，且几乎无法转化为求解为子问题，于是我们考虑用总的方案数减去不合法的方案数。

考虑动态规划，定义 $dp_S$ 表示使得 $S$ 点集为强联通的子图数量，那么考虑求出不是强连通的子图数量，那么必然可以划分为若干个 SCC，且这些 SCC 缩点后必然是一个 DAG。

注意到上述性质后，按照 DAG 计数的 trick，我们枚举一个子集 $T$ 表示缩点后入度为 $0$ 的点在原图上的点的并集，即这些点构成了若干组两两无边的 SCC；然后设 $f_S$ 表示将 $S$ 划分为若干组两两无边的 SCC 的方案数。

然后考虑对于一个缩点后的 DAG，设其有 $cnt$ 个入度为 $0$ 的点 $a_1, \cdots, a_{cnt}$，那么肯定会算重，令集合 $A_i$ 表示使得 $a_i$ 入度为 $0$ 的方案数，我们要算 $|A_1 \cup \cdots \cup A_{cnt}|$，直接容斥即可，对于钦定某 $i$ 个是 SCC 的容斥系数为 $(-1)^{i + 1}$。

上面的推导，我们算出来的容斥系数是和我们划分出来的 SCC 的个数有关，例如对于点集 $|T|$ 来说，若划分为了 $i$ 个 SCC，则其容斥系数是 $(-1)^{i + 1}$ 而不是和 $T$ 相关的；所以不能直接使用 $f_T$ 来更新转移。

考虑重新修改定义，令 $g_T$ 表示划分为奇数个 SCC 的方案数减去划分为偶数个 SCC 的方案数，那么 $g_T$ 就已经包含了容斥系数了。

然后考虑求若钦定了 $T$ 这个点集为这些入度为 $0$ 的 SCC 的并集后，符合上述钦定的子图数有多少个；首先对于 $S - T$ 内的边，随意删，没有影响，然后对于 $u \in T, v \in (S - T)$ 的有向边 $u \to v$，也是随意删的。

其它的边都是有限制条件的，例如 $u \in (S - T), v \in T$ 的边 $u \to v$ 必须删掉（不然入度不可能为 $0$），对于 $u, v \in T$ 内部的边，有内部必须构成若干个两两无边的 SCC 的限制。

然后我们这里定义 $E_S$ 表示 $S$ 的导出子图的边数，$E(S, T)$ 表示 $u \in S, v \in T$ 的有向边 $u \to v$ 的条数，那么我们有状态转移方程：

$$dp_S = 2^{E_S} - \sum_{T \subset S} g_T 2^{E_{S - T} + E(T, S - T)}$$

但是这里面我们还少了一点，即钦定 $S$ 这个点集划分为 $>1$ 个 SCC 的方案数，可以看下面 $g_S$ 的转移部分，这里的方案数就是后面的那一坨。

然后来考虑 $g_S$ 的转移，首先有 $S$ 整个划分为一个 SCC，方案数是 $dp_S$，然后我们枚举一个子集 $T$，将 $T$ 作为一个新加入的 SCC 进行转移：

$$g_S = dp_S - \sum_{T \subset S} dp_T g_{S - T}$$

因为多了 $T$ 这一个 SCC，所以是负号。

看起来很对，但是这样会算重，因为我们考虑若有一个合法的 $cnt$ 个 SCC，那么 $T$ 肯定遍历了这 $cnt$ 个中的任意一个，然后 $g_{S - T}$ 肯定也包含这个方案，故算重了 $cnt$ 次。

于是考虑钦定我们新加入的 SCC 是包含了 $x$ 的，即 $x \in S, x\in T$，此时对于上面那个合法的方案，包含 $x$ 的 SCC 肯定只有一个，只能被 $T$ 所枚举到一次，故不会算重活算漏。

这里可以令 $x = \operatorname{lowbit}(S)$，然后我们修改状态转移方程：

$$g_S = dp_S - \sum_{T \subset S \& \operatorname{lowbit}(S) = \operatorname{lowbit}(T)} dp_T g_{S - T}$$

此时我们按照上面的转移就是 $O(3^nn^2)$ 的，显然是过不去的，瓶颈在于计算 $E(T, S - T)$。

考虑令 $F_S = E(S, U - S)$，其中 $U$ 为全集，那么我们有：

$$F_T = E(T, U - T) = E(T, S - T) + E(T, U - S)$$

$$F_S = E(S, U - S) = E(S - T, U - S) + E(T, U - S)$$

两式子作差，我们有：

$$E(T, S - T) = F_T - F_S + E(S - T, U - S)$$

我们令 $cnt_{S, i}$ 表示 $E(\{i\}, U - S)$，那么：

$$E(T, S - T) = F_T - F_S + \sum_{i \in (S - T)} cnt_{S, i}$$

注意到 $F_S, cnt_{S, i}$ 可以 $O(m2^n)$ 预处理，故我们就得到了 $O(3^nn)$ 的做法，可以通过。

[**link**](https://www.luogu.com.cn/record/205781317)

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x & (-x))
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 16, M = 1 << N, MN = 205, mod = 1e9 + 7; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, m, u, v;
int dp[M], g[M], poww[MN], F[M], G[M], cnt[M][N];
vector<int> E[N];
inline void add(int u, int v){
	E[u].push_back(v);
}
inline int calc(int T, int S){
	int sum = F[T] - F[S];
	for(int i = 1; i <= n; ++i)
	  if(((S - T) >> (i - 1)) & 1)
	    sum += cnt[S][i];
	return sum;
}
bool End;
int main(){
	poww[0] = 1;
	n = read(), m = read();
	for(int i = 1; i <= m; ++i){
		poww[i] = 2ll * poww[i - 1] % mod;
		u = read(), v = read();
		add(u, v);
	}
	for(int S = 1; S < (1 << n); ++ S){
		for(int u = 1; u <= n; ++u){
			if((S >> (u - 1)) & 1){
				for(auto v : E[u]){
					if((S >> (v - 1)) & 1){
						++G[S];
						continue;
					}
					++cnt[S][u];
				}
				F[S] += cnt[S][u];
			}
		}
		for(int T = (S - 1) & S; T; T = (T - 1) & S){
			if(lowbit(S) != lowbit(T))
			  continue;
			g[S] = (g[S] - 1ll * dp[T] * g[S - T] % mod + mod) % mod;
		}
		dp[S] = poww[G[S]];
		for(int T = S; T; T = (T - 1) & S)
		  dp[S] = (dp[S] - 1ll * g[T] * poww[G[S - T] + calc(T, S)] % mod + mod) % mod;
		g[S] = (g[S] + dp[S]) % mod;
	}
	write(dp[(1 << n) - 1]);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：Purslane (赞：11)

# Solution

DAG 计数模板题。

考虑算出 $dp_S$ 为，考虑 $S$ 内部的边，有多少种方案使得它是强联通的。

设内部有 $e$ 条边，那么显然要用 $2^e$ 减去至少两个强联通分量的情况。

根据经典套路，对零度点进行容斥，容斥系数为 $(-1)^{cnt}$，其中 $cnt$ 是你钦定的 $0$ 度点（就是缩点之后的强联通分量）个数。

按照 $cnt$ 奇偶性进行合并，你只需要在加入一个联通分量的时候乘 $-1$ 即可。用 $mul_S$ 表示将 $S$ 划分为若干互不连边的强联通分量的方案数（加上了容斥系数）

则有：

$$
dp_S = 2^{e_S} + \sum_{\varnothing \subset T \subseteq S} mul_T 2^{e_{S-T}} \times 2^{s(T,S-T)}
$$

以及

$$
mul_S = -dp_S - \sum_{\varnothing \subset T \subset S,\min(S) = \min(T)} dp_T mul_{T-S}
$$

注意，第一遍计算 $mul_S$ 时，$dp_S$ 仍然未确定（显然也不需要统计入 $dp_S$）。在计算完成 $dp_S$ 之后再加回去即可。

直接做是 $O(n3^n)$ 的，懒得进一步优化了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=15+5,MAXM=100000+10,MOD=1e9+7;
int n,m,e[MAXN][MAXN],pw[MAXN*MAXN],dp[MAXM],ori[MAXM],nb[MAXN],mul[MAXM];
int calc(int s1,int s2) {
	int cnt=0;
	ffor(i,1,n) if(s1&(1<<i-1)) cnt+=__builtin_popcountll(nb[i]&s2);
	return pw[cnt];	
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) {int u,v;cin>>u>>v,e[u][v]=1,nb[u]|=(1<<v-1);}
	pw[0]=dp[0]=ori[0]=1;
	ffor(i,1,m) pw[i]=pw[i-1]*2%MOD;
	ffor(i,1,(1<<n)-1) {
		int c=0;
		vector<int> pos;
		ffor(j,1,n) if(i&(1<<j-1)) pos.push_back(j);
		for(auto p1:pos) for(auto p2:pos) c+=e[p1][p2];
		for(int S=i;S;S=(S-1)&i) if((S&-S)==(i&-i)) mul[i]=(mul[i]-dp[S]*mul[i-S])%MOD;
		dp[i]=ori[i]=pw[c];
		for(int S=i;S;S=(S-1)&i) dp[i]=(dp[i]+mul[S]*ori[i-S]%MOD*calc(S,i-S))%MOD;
		mul[i]=(mul[i]-dp[i])%MOD;
	}
	cout<<(dp[(1<<n)-1]%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：yukimianyan (赞：10)

## 题目描述

给定一个 $n$ 个点的有向图，问这个图有多少个强连通子图。保证 $n\leq 15$。

## 前置问题

> 一个有向图有 $n$ 个点，求它的 DAG 子图数量。$n\leq 15$。

解：令 $f_S$ 表示点集 $S$ 有多少个 DAG 子图。枚举这个 DAG 中入度为 0 的部分，然后递归下去。由于不能一次枚举完所有入度为 0 的点，我们对着这些点做容斥。对于一张合法的 DAG 来说，假如它的零度点集合为 $R$，则我们会计算它 $\sum_{T\subseteq R,T\neq\varnothing}(-1)^{|T|+1}$ 次，由二项式定理我们知道这个系数恰好为 $[|R|>0]$，即它是 DAG 时系数为 $1$，不是 DAG 时系数为 $0$。

$$
f_S=\sum_{T\subseteq S,T\neq\varnothing}(-1)^{|T|+1}2^{\text{ways}(T,S\setminus T)}f_{S\setminus T}
$$

## solution

一个非强连通的子图，缩点后是一个至少两个点的 DAG（这个 DAG 可以不连通）。

对于点集 $S$，考虑强连通子图 $=$ 所有图 $-$ 非强连通子图。

令只考虑点集 $S$ 的强连通子图的数量为 $f_S$，枚举 $T\subset S$，使 $T$ 是一个强连通分量，$S-T$ 就随意，而且强制规定 $T$ 在缩点图的入度为零。

$$
f_S=h_S-\sum_{T\subset S}2^{\text{ways}(T,S\setminus T)}f_Th_{S\setminus T}
$$

- $h_S$ 表示点集为 $S$ 导出的所有图的数量。
- $\text{ways}(S,T)$ 表示 $\sum_{u\in S,v\in T}[(u, v)\in E]$。注意到 $S\cap T=\varnothing$，它的复杂度顶满是 $O(3^nn^2)$。

这是错误的。考虑图为 $\{(1, 3), (2, 3)\}$ 时会算至少两次。

考虑问题在哪里呢？枚举 $T$ 的时候，我们没有保证 $T$ 一定是所有的入度为 $0$ 的点。我们对着 $T$ 容斥：

- 将 $T$ 划分为若干个强连通分量，奇数个的贡献是 $1$，偶数个的贡献是 $-1$，这个系数和前置问题中的系数是一样的。
- 令 $g_T$ 表示所有划分方案的和。

将 $f_T$ 换成 $g_T$ 就行了。
$$
f_S=h_S-\sum_{T\subseteq S}2^{\text{ways}(T,S\setminus T)}g_Th_{S\setminus T}
$$
怎么算 $g_S$？

- 枚举一个 $\varnothing\neq T\subset S$，然后划分成 $-f_Tg_{S\setminus T}$。注意 $T$ 不能和 $S$ 取等，因为整个 $S$ 都是强连通分量不是我们需要减去的东西（非强连通子图）。
- 为了避免判重等问题，我们钦定一个 $x\in S$，然后枚举 $x\in T\land T\subset S$ 的 $T$。
- 转移顺序为：先计算 $g_S$ 但是不用加上 $f_S$，然后计算 $f_S$，最后再将 $f_S$ 加到 $g_S$，保证 $f_S$ 的转移合法。

$$
g_S=f_S-\sum_{x\in T\subset S}f_Tg_{S\setminus T}
$$

复杂度 $O(3^nn^2)$。

以上复杂度无法通过。事实上只需要优化 $\text{ways}(S,T)$ 这个瓶颈的计算。提前计算 $g_u$ 为一个 $2^n$ 大小的数，第 $v$ 位上是 $1$ 表示存在 $(u, v)\in E$。计算 $\text{ways}(S,T)$ 枚举 $u\in S$，然后计算 $g_u$ 与 $T$ 的按位与，再求这个结果的 `__builtin_popcount`，即可将复杂度削减一个 $n$。

以上复杂度无法通过另一道依赖本问题的题目，这里就不点明是什么题目了。事实上只需要优化 $\text{ways}(S,T)$ 这个瓶颈的计算。预先处理两个数组 $o_{S}=\sum_{i\in S}3^i$，然后将 $(S,T)$ 映射为 $o_S+2o_T$，形成一个 $3^n$ 的数组，计算时只需要随意选定 $x\in S$，拿出 $\text{ways}(S\setminus\{x\},T)$ 的结果和 $\text{ways}(\{x\},T)$ 相加即可，复杂度 $O(n2^n+3^n)$。

## code

代码中 `b` 对应 $g$ 数组，`pw2[h[S]]` 对应 $h_S$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#ifdef LOCAL
#define debug(...) fprintf(stderr, ##__VA_ARGS__)
#else
#define endl "\n"
#define debug(...) void(0)
#endif
using LL = long long;
template <unsigned umod>
struct modint {/*{{{*/
  static constexpr int mod = umod;
  unsigned v;
  modint() = default;
  template <class T, enable_if_t<is_integral<T>::value, int> = 0>
    modint(const T& y) : v((unsigned)(y % mod + (is_signed<T>() && y < 0 ? mod : 0))) {}
  modint& operator+=(const modint& rhs) { v += rhs.v; if (v >= umod) v -= umod; return *this; }
  modint& operator-=(const modint& rhs) { v -= rhs.v; if (v >= umod) v += umod; return *this; }
  modint& operator*=(const modint& rhs) { v = (unsigned)(1ull * v * rhs.v % umod); return *this; }
  modint& operator/=(const modint& rhs) { assert(rhs.v); return *this *= qpow(rhs, mod - 2); }
  friend modint operator+(modint lhs, const modint& rhs) { return lhs += rhs; }
  friend modint operator-(modint lhs, const modint& rhs) { return lhs -= rhs; }
  friend modint operator*(modint lhs, const modint& rhs) { return lhs *= rhs; }
  friend modint operator/(modint lhs, const modint& rhs) { return lhs /= rhs; }
  template <class T> friend modint qpow(modint a, T b) {
    modint r = 1;
    for (assert(b >= 0); b; b >>= 1, a *= a) if (b & 1) r *= a;
    return r;
  }
  friend int raw(const modint& self) { return self.v; }
  friend ostream& operator<<(ostream& os, const modint& self) { return os << raw(self); }
  explicit operator bool() const { return v != 0; }
  modint operator-() const { return modint(0) - *this; }
  bool operator==(const modint& rhs) const { return v == rhs.v; }
  bool operator!=(const modint& rhs) const { return v != rhs.v; }
};/*}}}*/
using mint = modint<(int)1e9 + 7>;
template <class T>
constexpr auto lowbit(T x) { return x & -x; }
constexpr int pw3[] = {1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 387420489, 1162261467};
constexpr int inv2 = (mint::mod + 1) / 2;
struct subset {/*{{{*/
  int s;
  struct iterator {
    int s, t;
    constexpr bool operator!=(const iterator& rhs) const { return t != rhs.t; }
    constexpr iterator& operator++() { t = t ? (t - 1) & s : -1; return *this; }
    constexpr int operator*() const { return t; }
  };
  constexpr auto begin() const { return iterator{s, s}; }
  constexpr auto end() const { return iterator{s, -1}; }
};/*}}}*/
struct eachbit {/*{{{*/
  int s;
  struct iterator {
    int s;
    constexpr bool operator!=(const iterator& rhs) const { return s != rhs.s; }
    constexpr iterator& operator++() { s -= lowbit(s); return *this; }
    constexpr int operator*() const { return __builtin_ctz(s); }
  };
  constexpr auto begin() const { return iterator{s}; }
  constexpr auto end() const { return iterator{0}; }
};/*}}}*/
mint pw2[100010], ipw2[100010];
vector<mint> solve(int n, int g[]) {
  vector<mint> f(1 << n), b(1 << n);
  vector<int> h(1 << n), w(pw3[n]), ot1(1 << n), ot2(1 << n);
  for (int i = 0; i < n; i++) {
    for (int j : eachbit{g[i]}) h[1 << i | 1 << j] += 1;
  }
  for (int i = 0; i < n; i++) {
    for (int S = 0; S < 1 << n; S++) if (S >> i & 1) h[S] += h[S ^ (1 << i)];
  }
  for (int S = 1; S < 1 << n; S++) {
    int i = __builtin_ctz(S);
    ot1[S] = ot1[S ^ lowbit(S)] + pw3[i];
    ot2[S] = ot2[S ^ lowbit(S)] + 2 * pw3[i];
  }
  for (int S = 1; S < 1 << n; S++) {
    for (int T : subset{S}) if (T) {
      int i = __builtin_ctz(T);
      w[ot1[T] + ot2[S ^ T]] = w[ot1[T ^ lowbit(T)] + ot2[S ^ T]] + __builtin_popcount(g[i] & (S ^ T));
    }
  }
  for (int S = 1; S < 1 << n; S++) {
    f[S] = pw2[h[S]];
    for (int T : subset{S ^ lowbit(S)}) if (T) b[S] -= b[T] * f[S ^ T];
    for (int T : subset{S}) if (T) f[S] -= b[T] * pw2[w[ot1[T] + ot2[S ^ T]] + h[S ^ T]];
    b[S] += f[S];
  }
  return f;
}
int main() {
#ifndef LOCAL
  cin.tie(nullptr)->sync_with_stdio(false);
#endif
  pw2[0] = 1;
  for (int i = 1; i <= 1e5; i++) pw2[i] = pw2[i - 1] + pw2[i - 1];
  ipw2[0] = 1;
  for (int i = 1; i <= 1e5; i++) ipw2[i] = ipw2[i - 1] * inv2;
  int n, g[15]{}, m;
  cin >> n >> m;
  for (int i = 1, u, v; i <= m; i++) cin >> u >> v, g[--u] |= 1 << --v;
  cout << solve(n, g)[(1 << n) - 1] << endl;
  return 0;
}
```

---

## 作者：Mini_PEKKA (赞：10)

>给定一个 $n$ 个点的有向图，求这个图有多少个强连通子图。保证 $1\le n\le 15$。

令 $f_{S,i}$ 为点集 $S$ 的导出子图有多少个子图由 $i$ 个孤立的强连通分量构成。令 $E(S,T)$ 为从 $S$ 中的点到 $T$ 中的点的边数。

钦定 $S$ 的导出子图的子图缩点后入度为 $0$ 的点的个数并枚举这些点对应到原图上的强连通分量的点集，再二项式反演可得：
$$\begin{equation*}\begin{aligned}2^{|E(S,S)|}&=\sum\limits_{i=1}^{|S|}{(-1)^{i-1}\sum\limits_{\varnothing\subset T\subseteq S}{2^{|E(S,S\setminus T)|}f_{T,i}}}\\&=\sum\limits_{\varnothing\subset T\subseteq S}{2^{|E(S,S\setminus T)|}\sum\limits_{i=1}^{|T|}{(-1)^{i-1}f_{T,i}}}\end{aligned}\end{equation*}$$

令 $g_S$ 为 $\sum\limits_{i=1}^{|S|}{(-1)^{i-1}f_{S,i}}$。代入上式：
$$\begin{equation*}\begin{aligned}2^{|E(S,S)|}&=\sum\limits_{\varnothing\subset T\subseteq S}{2^{|E(S,S\setminus T)|}{g_T}}\\&=g_S+\sum\limits_{\varnothing\subset T\subset S}2^{|E(S,S\setminus T)|}{g_T}\end{aligned}\end{equation*}$$

移项可得 $g$ 的转移式：
$$g_S=2^{|E(S,S)|}-\sum\limits_{\varnothing\subset T\subset S}2^{|E(S,S\setminus T)|}{g_T}$$

同时根据定义，$g$ 有如下转移式：
$$\begin{equation*}\begin{aligned}g_S&=f_{S,1}+\sum\limits_{i=2}^{|S|}{(-1)^{i-1}\sum\limits_{\min(S)\subseteq T\subset S}{f_{T,1}f_{S\setminus T,i-1}}}\\&=f_{S,1}+\sum\limits_{\min(S)\subseteq T\subset S}{f_{T,1}\sum\limits_{i=2}^{|S|}{(-1)^{i-1}f_{S\setminus T,i-1}}}\\&=f_{S,1}+\sum\limits_{\min(S)\subseteq T\subset S}{-f_{T,1}g_{S\setminus T}}\end{aligned}\end{equation*}$$

移项可得 $f_{*,1}$ 的转移式：
$$f_{S,1}=g_S+\sum\limits_{\min(S)\subseteq T\subset S}{g_{S\setminus T}f_{T,1}}$$

答案即为 $f_{\{1,\cdots,n\},1}$。时间复杂度为 $\mathcal{O}(3^nn)$。

代码：
```cpp
#include <bits/stdc++.h>
#define lb(x) (x & -x)
#define rep(i, a, b) for (ll i = (a); i <= (b); i++)
using namespace std;
using ll = long long;
constexpr ll N = 25, M = 220, P2N = 32778;
constexpr ll mod = 1000000007;
ll n, m, f[P2N], g[P2N], p2[M], G[P2N], cnt[P2N];
int main() {
   ios::sync_with_stdio(0), cin.tie(0);
   cin >> n >> m;
   p2[0] = 1;
   rep(i, 1, m) {
      ll u, v;
      cin >> u >> v;
      G[u - 1] += 1ll << (v - 1);
      p2[i] = p2[i - 1] * 2 % mod;
   }
   ll p2n = 1ll << n;
   rep(i, 0, p2n - 1) {
      for (ll j = i; j; j = (j - 1) & i) {
         cnt[j] = 0;
         rep(k, 0, n - 1) {
            if (i >> k & 1) {
               cnt[j] += __builtin_popcountll(G[k] & j);
            }
         }
      }
      g[i] = p2[cnt[i]];
      for (ll j = (i - 1) & i; j; j = (j - 1) & i) {
         (g[i] -= p2[cnt[i ^ j]] * g[j]) %= mod;
      }
   }
   rep(i, 0, p2n - 1) {
      f[i] = g[i];
      ll ni = i ^ lb(i);
      for (ll j = (ni - 1) & ni; ni; j = (j - 1) & ni) {
         (f[i] += g[ni ^ j] * f[j ^ lb(i)]) %= mod;
         if (!j) {
            break;
         }
      }
   }
   cout << (f[p2n - 1] + mod) % mod << '\n';
   return 0;
}
```

---

## 作者：xiezheyuan (赞：8)

## 简要题意

给定一个 $n$ 个点 $m$ 条边的有向图，你需要求出其的边集数，使得断掉边集中的所有边后，整张图强联通。答案对 $10^9+7$ 取模。

$1\leq n\leq 15,0\leq m\leq n(n-1)$。

## 思路

extreme hard 的状压 dp 题，做这道题前最好做一下 [P6846 \[CEOI 2019\] Amusement Park](https://www.luogu.com.cn/problem/P6846)，没做也没有关系。

约定：

- $U$ 表示全集 $\{1,2,\cdots,n\}$。$S-T$ 表示 $T$ 在全集 $S$ 下的补集 $\complement_S T$。
- $p(S)$ 表示点集 $S$ 的导出子图的边数，$p(S\to T)$ 表示满足 $u\in S,v\in T$ 的有向边 $(u,v)$ 的数量。

### Part 1

首先设 $f(S)$ 表示点集为 $S$ 的强联通图数量，那么答案就是 $f(U)$，考虑转移。

首先我们如何刻画强联通题图（以下简称 SCG）这个性质，发现我们趁手的工具非常少，不过刻画强联通分量（以下简称 SCC）的关系工具是存在的，就是缩点。假如我们将整张图缩点后只剩下一个点，那么肯定是 SCG。正难则反，不妨考虑缩点后形成了 $\geq 2$ 个点的方案数。

缩点后，整张图变成一个 DAG，可以考虑一些对 DAG 计数的方法。

计算 DAG 的数量有一个常见的状态 dp 的方法，就是枚举拓扑序最小的点集，按照拓扑序转移（如果你不熟悉，请尝试完成前面提到的 Amusement Park 一题）。这道题不是计算 DAG，但是可以将一个 SCC 看成一个点，就是计算 DAG 了。

转移？不妨枚举拓扑序最小的所有 SCC 的并集 $T$，可以得到一个残缺的转移方程（其中 $\square(T)$  表示我们需要补全的部分）：

$$
f(S)=2^{p(S)}-\sum_{T\subseteq S,T\neq\varnothing} 2^{p(T\to S-T)+p(S-T)} \cdot \large\square(T)
$$

稍微解释一下，$2^{p(S)}$ 即点集为 $S$ 的子图的方案数。$p(T\to S-T)$ 和 $p(S-T)$ 都是不在拓扑序最小的 SCC 的点集的边，无需考虑，所以可以任意选择。

### Part 2

我们需要补全上一部分中的 $\square(T)$，依据 Amusement Park 一题，很容易写出下面的式子：

$$
\square(T)=\sum_{k=1}^{|T|}(-1)^{k+1} s(T,k)
$$

其中 $s(T,k)$ 表示将点集 $T$ 的子图为 $k$ 的互不连通的 SCC 的方案数。特别地，我们令 $T=S$ 时 $k\neq 1$ 表示只有一个连通块的方式是禁止的。

> 简单介绍一下为什么我们这么写。
>
> 关注到我们必须保证每次枚举出来的都是恰好拓扑序最小（入度为 $0$）的点，如果不是则导致计算混乱，不过求出任意一个入度为 $0$ 的子集对应的方案数是容易的。所以不妨引入容斥。但是我不太会容斥，所以可以用一些公式化容斥的东西，比如子集反演。注意下面的推导都是基于 DAG 而不是本题的。
>
> 如果设 $g(T)$ 表示拓扑序最小，$f(T)$ 表示精确覆盖拓扑序最小。可以写出 $g(T)=\sum_{A\subseteq T} f(T)$，反演得到 $f(T)=\sum_{T\subseteq A}(-1)^{|A|-|T|}g(A)$。
>
> 故 $g(S)=\sum_{T\subseteq S}\sum_{T\subseteq A}(-1)^{|A|-|T|}g(A)$，稍加变换，得到 $g(S)=\sum_{A\subseteq S}g(A) \sum_{T\subseteq A}(-1)^{|A|-|T|}$，进一步化简，得到 $g(S)=\sum_{A\subseteq S} g(A)\cdot (-1)^{|A|}\cdot \sum_{k=1}^{|A|}\binom{|A|}{k}(-1)^k$。
>
> 注意到由于空集没有合适的定义，所以不考虑空集。
>
> 根据二项式定理，$\sum_{k=1}^{|A|}\binom{|A|}{k}(-1)^k=(-1+1)^{|A|}-\binom{|A|}{0}(-1)^0=-1$，所以最后得到 $g(S)=\sum_{A\subseteq S} (-1)^{|A|+1}$。
>
> 本题也需要计算 DAG 结构，所以可以迁移容斥的形式，所以自然要拆分 SCC 数来决定容斥系数 $(-1)^{|A|+1}$。

现在需要求出 $s(T,k)$，不过这样发现即使可以 $O(1)$ 求出（况且这也比较困难），大概率也无法通过本题了，所以更加务实的想法是直接求出 $\square(T)$。，由于这不再是空缺的，所以赐给它一个字母，用 $h(T)$ 来表示它。

现在将 $h(T)$ 回代，得到 $f(T)$ 的新转移方程：

$$
f(S)=2^{p(S)}-\sum_{T\subseteq S,T\neq\varnothing} 2^{p(T\to S-T)+p(S-T)} \cdot h(T)
$$

### Part 3

我们需要求出 $h(T)$，一种自然的方法是枚举其中一个 SCC，不过这很容易算重。不过有一种更加简单的方法：先确定 $T$ 中某一个点 $u$，然后枚举 $u$ 的 SCC，可以转移：

$$
-h(S)=\sum_{T\subseteq S-\{u\}} f(T\cup\{u\})h(S - T\cup\{u\}) 
$$

当然这个形式不太美观，可以改一改：

$$
-h(S)=\sum_{T\subseteq S-\{u\}} h(T)f(S-T)
$$

解释一下，$T$ 是与 $u$ 在同一个 SCC 的点集（更改后为不在同一个 SCC 的点集），$h(S)$ 前面有负号，是因为容斥系数的影响，多了一个 SCC 会取反。这个卷积的形式比较好理解，就不讲了。

看起来这个形式很好，不是吗？不过有两点遗留问题：

- 在 $S=T$ 时，$h(T)$ 不能取到大小为 $1$。
- 在计算 $f(S)$ 时，如果枚举到了 $T=\varnothing$，那么同时也需要用到 $f(S)$ 的值，导致转移成环。

这两个问题单独出现，都是难以解决的，不过本题中它们一起出现了，$T=\varnothing$ 就是大小为 $1$ 的情况啊！将式子稍作改写（钦定 $h(\varnothing)=1$，这是转移正确性的需要）：

$$
-h(S)=f(S)+\sum_{T\subseteq S-\{u\},T\neq\varnothing} h(T)f(S-T)
$$

于是只要计算 $h(S)$ 时先不计算 $f(S)$ 一项，计算完 $f(S)$ 后加上即可。

### Part 4

如何实现本题？

对于边界，$f(\{u\})=h(\{u\})=1$，然后是时间复杂度：

- $e(S)$ 采用 $O(n2^n)$ 或 $O(2^n)$ 应该都可以。
- $e(T\to S-T)$ 直接求时间复杂度难以承受，不过发现固定 $S$ 时是可以利用简单容斥递推计算的（考虑 $T$ 中的一个点 $u$，$e(T\cup\{u\}\to S-(T\cup\{u\}))$ 和 $e(T\to S)$ 的关系即可），所以优化到了 $O(3^n)$。
- $h(S),f(S)$ 只需要直接枚举子集转移即可，时间复杂度 $O(3^n)$。

于是时间复杂度 $O(3^n)$ 可以通过本题，实现并不困难。

[Submission](https://uoj.ac/submission/737288)。

---

## 作者：ZnPdCo (赞：6)

题目大意是求强连通子图（删边）个数。

强连通很难刻画，但是我们可以通过缩点来刻画，如果一张图是强连通的，那么它缩点后必定是一个单点，否则是一个非单点的 DAG。

那么我们就可以通过 dp 来计算出点集为 $S$ 的子图缩点后不为一个单点的方案数，用总方案数减去这个方案数就可以得到是一个强连通分量的方案数了。

设 $E(S,T)$ 表示点集 $S$ 到点集 $T$ 的边的数量。

设 $f_S$ 表示点集为 $S$ 的子图缩点后非单点的方案数。

设 $h_S$ 表示点集为 $S$ 的子图缩点后为单点的方案数（强连通分量）。这也是题目所求。那么 $h_S=2^{E(S,S)}-f_S$。

设 $g_S$ 表示点集为 $S$ 的子图缩点后为若干个单点的方案数。

我们可以得到（下面这个式子并不正确）：

$$
f_S=\sum_{\empty\not=T\sub S} g_T2^{E(T,S-T)+E(S-T,S-T)}
$$

意思大概是选择一个子集 $T$，它缩点为若干个单点，这些单点在总图缩点后为入度为 $0$ 的点，然后往外连边，外面随便连边，使得形成一个非单点的 DAG。

这样对吗？实际上并不对，因为我们无法确定 $T$ 一定是所有缩点后入度为 $0$ 的点，如果有 $E=\{(1\to 3),(2\to 3)\}$，实际上会重复计算。

考虑容斥（下面这个式子并不正确）：

$$
f_S=\sum_{\empty\not=T\sub S} (-1)^?g_T2^{E(T,S-T)+E(S-T,S-T)}
$$

然后我们思考容斥系数是什么，然后我们发现实际上容斥系数和你选择的点集 $T$ 缩点后的单点数量有关，实际上是 $缩点后的单点数量+1$，这并不好在计算 $f$ 时表示出来，因为这样的话你就需要枚举缩点后的点数了。

我们把这个值塞入 $g$ 中，也就是 $g_S$ 的定义变成了：表示点集为 $S$ 缩点后形成若干个单点，单点数量若为奇数贡献为 $1$，否则为 $-1$ 的贡献和。

那么在新的 $g$ 定义下，式子变成了（下面这个式子并不正确）：

$$
f_S=\sum_{\empty\not=T\sub S} g_T2^{E(T,S-T)+E(S-T,S-T)}
$$

这样对吗？实际上并不对，因为对于整个 $T$ 是大于 $1$ 个强连通分量互不相连的强连通分量组成的方案数（缩点后为大于 $1$ 个单点），我们没有算上。

那如果我们把 $T$ 取到 $S$，我们发现又会多算上整个 $S$ 缩为一个强连通分量的方案数，所以说我们还要减去 $h_S$。

式子变成了（我们先不考虑它能不能做先）：

$$
f_S=\sum_{\empty\not=T\subseteq S} g_T2^{E(T,S-T)+E(S-T,S-T)}-h_S
$$

然后根据上文，$h_S=2^{E(S,S)}-f_S$。

那么算 $g$（下面这个式子并不正确）：

$$
g_S=h_S+\sum_{T\sub S} -h_Tg_{S-T}
$$

大概意思就是多增加一个强连通分量，贡献乘上 $-1$。

这样对吗？实际上并不对，因为我们的强连通分量加入顺序是无序的，但你算成了有序的。但是这也很容易修改，我们要求 $S$ 中最小的必须选就好了。

那么算 $g$：

$$
g_S=h_S+\sum_{S_{\min}\in T\sub S} -h_Tg_{S-T}
$$

其中 $S_{\min}$ 表示 $S$ 最低位的点。

整理一下转移：

$$
h_S=2^{E(S,S)}-(\sum_{\empty\not=T\subseteq S} g_T2^{E(T,S-T)+E(S-T,S-T)}-h_S)
$$

$$
g_S=h_S+\sum_{S_{\min}\in T\sub S} -h_Tg_{S-T}
$$

我们发现好像会重复转移？自己转移自己？

但是我们发现，设 $dp_S=\sum_{S_{\min}\in T\sub S} -h_Tg_{S-T}$，那么 $h$ 的转移：

$$
h_S=2^{E(S,S)}-\sum_{\empty\not=T\subseteq S} ([S=T]dp_T+[S\neq T]g_T)2^{E(T,S-T)+E(S-T,S-T)}
$$

这样似乎就不会自己转移自己了，以上这个转移式子是正确的。不过这有点麻烦。

我们可以方便一点：在计算 $S$ 时，先让 $g_S=dp_S=\sum_{S_{\min}\in T\sub S} -h_Tg_{S-T}$，也就是先不加上 $h_S$ 这个值。

然后去转移 $h$：

$$
h_S=2^{E(S,S)}-\sum_{\empty\not=T\subseteq S} g_T2^{E(T,S-T)+E(S-T,S-T)}
$$

那么当 $S=T$ 时，$g$ 的值就是 $dp$ 的值，否则就是真实的 $g$ 的值。最后面得到 $h$ 后再把 $g$ 的值加上 $h_S$ 更新为真正的值就好了，这样就不需要开一个数组来存 $dp$。

时间复杂度 $O(3^nn^2)$。

然后你发现瓶颈在于计算 $E$，但是我们发现 $E$ 只会有两种形式：$E(S,S)$、$E(T,S-T)$。

对于前者，可以容易的通过 $O(2^n)$ 来处理 $p_S=E(S,S)$。而对于后者，我们可以在枚举 $S$ 时，计算出 $e_T=E(T,S-T)$，这个是容易的，考虑每次 $T$ 增加一个点对总和的贡献即可，处理这个的复杂度为 $O(2^n)$。

综上，复杂度为 $O(2^n+3^n)$。

```cpp
#include <bits/stdc++.h>
#define N 15
#define P 1000000007
using namespace std;
int n, m;
int out[N], in[N], bit[1 << N], pw2[N * N];
int p[1 << N], e[1 << N], h[1 << N], g[1 << N];
inline int lowbit(int x) { return x & (-x); }
inline int popcnt(int x) { return __builtin_popcount(x); }
int main() {
    cin >> n >> m;
    pw2[0] = 1;
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        in[v] |= 1 << u;
        out[u] |= 1 << v;
        pw2[i + 1] = (2ll * pw2[i]) % P;
    }
    for (int i = 0; i < n; i++) bit[1 << i] = i;
    for (int S = 1; S < (1 << n); S++) {
        int x = lowbit(S);
        p[S] = p[S ^ x] + popcnt(out[bit[x]] & S) + popcnt(in[bit[x]] & S);
    }
    for (int S = 1; S < (1 << n); S++) {
        e[S] = 0;
        for (int T = (S - 1) & S; T; T = (T - 1) & S) {
            int x = lowbit(S ^ T);
            e[T] = e[T | x] - popcnt(out[bit[x]] & (S ^ T)) + popcnt(in[bit[x]] & T);
        }
        for (int T = (S - 1) & S; T; T = (T - 1) & S) if (T & lowbit(S)){
            (g[S] += P - 1ll * h[T] * g[S ^ T] % P) %= P;
        }
        for (int T = S; T; T = (T - 1) & S) {
            (h[S] += 1ll * g[T] * pw2[e[T] + p[S ^ T]] % P) %= P; 
        }
        h[S] = (pw2[p[S]] + P - h[S]) % P;
        (g[S] += h[S]) %= P;
    }
    printf("%d\n", h[(1 << n) - 1]);
}
```

---

## 作者：MatrixGroup (赞：6)

## 前言

高妙，学习。

## 题意

给定一 $n$ 点的简单有向图，求其强连通的生成子图数量。

$n\le 15$

## 题解

设 $f_S$ 为以 $S$ 为点集的强连通子图数量，所求即 $f_{[n]}$。

强连通是不好刻画的，不过强连通缩点之后我们得到了一个 DAG。

考虑在 DAG 计数的时候我们干了什么：枚举零度点集，得到一个恒等式。我们这里也可以这样干。设 $I(S)$ 表示 $S$ 内部的边数，$I(S,T)$ 表示 $S$ 到 $T$ 的边数（其中 $S\cap T=\varnothing$）。对于一个非空的 $S$，枚举缩点后的图中零度点对应原图中的点集 $T$，对于每个划分 $T=T_1\sqcup T_2\sqcup\cdots\sqcup T_k$（其中 $\{T_i\}$ 无序），其贡献为 $(-1)^{k-1}\prod f(T_i)2^{\operatorname{in}(S\backslash T)+I(T,S\backslash T)}$。而我们知道总共选的方案数是 $2^{\operatorname{in}(S)}$。因此，令 $g_T$ 为所有的划分的 $(-1)^{k}\prod f(T_i)$ 之和，则对于任意非空的 $S$ 有

$$
-2^{\operatorname{in}(S)}=\sum_{T\subseteq S,T\neq \varnothing}g_T2^{\operatorname{in}(S\backslash T)+I(T,S\backslash T)}
$$

因为这个式子里 $S$ 的系数是 $1$，容易递推求出所有 $g_S$。注意 $I(T,S\backslash T)$ 可以考虑固定 $T$ 对 $S\backslash T$ 递推。

然后作为集合幂级数，$-f=\ln g$。本题中可以暴力计算。总时间复杂度 $O(3^n)$。

## 代码

```cpp
cin>>n>>m;
rep(i,m)
{
	cin>>u>>v;
	--u;--v;
	++in[1<<u|1<<v];
	++qaq[1<<u][v];
}
rep(i,n) lg[1<<i]=i;
rep(i,n) rep(j,1<<n) if((j>>i)&1) in[j]+=in[j&~(1<<i)];
rep(i,n) rep(j,1<<n) qaq[j][i]=qaq[j&-j][i]+qaq[j&(j-1)][i];
pw2[0]=1;
rep1(i,1000) pw2[i]=pw2[i-1]*2%mod2;
rep(i,1<<n) g[i]=-pw2[in[i]];
g[0]=1;
rep(i,1<<n) if(i)
{
	if(g[i]<0) g[i]+=mod2;
	for(int j=(i+1)|i;j<(1<<n);j=(j+1)|i)
	{
		int k=j^i;
		if(k&(k-1)) qvq[k]=qvq[k&-k]+qvq[k&(k-1)];
		else qvq[k]=qaq[i][lg[k]];
		g[j]=(g[j]-g[i]*pw2[in[k]+qvq[k]])%mod2;
	}
}
rep(i,1<<n) if(i)
{
	f[i]=-g[i];
	for(int j=i&(i-1);j;j=(j-1)&i) if(j&(i&-i))
	{
		f[i]=(f[i]-f[j]*g[i^j])%mod2;
	}
	if(f[i]<0)f[i]+=mod2;
}
cout<<f[(1<<n)-1]<<'\n';
```

---

## 作者：Moeebius (赞：5)

对于这类图计数问题，考虑如何“刻画”一张图是合法的。

注意到一张图强连通等价于缩点后只有一个点。由于有向图缩点后会形成 DAG，不妨考虑处理 DAG 计数的惯用手法——考虑入度为 $0$ 的点集，假如不是全集就表示方案非法。

具体地，使用容斥，我们钦定**在缩点后的 DAG（$G=(V,E)$） 上**一个集合 $S \subsetneq V$ 内的点入度为 $0$，则 $E$ 中只能出现 $S$ 连向 $V \setminus S$ 的边和 $V \setminus S$ 内部的边。这是子集容斥，不难验证容斥系数为 $(-1)^{|S|}$。

回到原问题，记 $f_T$ 表示只考虑 $T$ 内点和边，连出强连通图的方案数，初始时令 $f_T=2^{|E|}$，其中 $E$ 表示 $T$ 内部边集。容斥时，枚举集合 $S \subsetneq T$ 表示**缩点后**入度为 $0$ 的点集包含**原图中**哪些点，此时 $S$ 外部连边的权值是 $2$ 的合法边数次幂，内部连边的权值即为将 $S$ 划分成若干个不交的集合 $A_1,\cdots,A_k$，$\prod_{i=1}^k -f_{A_i}$ 之和。这个可以在 DP 过程中同步用一个辅助数组 $g$ 转移得到。由于在 $g$ 中 $S$ 可以只划分成一个元素（也就是自己），在算出 $f_T$ 后还要令 $g_T \gets -f_T$。

精细实现复杂度可以做到 $n2^n + 3^n$，可以通过。

```cpp
constexpr ll mod = 1e9 + 7;
int n, m, G[15], G2[1 << 15][15], f[1 << 15], g[1 << 15], cnt[1 << 15],
    pw[15 * 15], cross[1 << 15];
void Main() {
  read(n, m);
  For(i, 1, m) {
    int u, v;
    read(u, v), u--, v--;
    G[u] |= 1 << v;
  }
  pw[0] = 1;
  For(i, 1, m) pw[i] = pw[i - 1] * 2 % mod;
  For(S, 1, (1 << n) - 1) {
    int lbt = S & -S;
    For(i, 0, n - 1) {
      if (S >> i & 1)
        cnt[S] += __builtin_popcount(S & G[i]);
      G2[S][i] = G2[S ^ lbt][i] + (G[31 ^ __builtin_clz(lbt)] >> i & 1);
    }
  }
  g[0] = 1;
  For(S, 1, (1 << n) - 1) {
    static vector<int> tmp;
    tmp.clear();
    for (int T = S & (S - 1); T; T = (T - 1) & S)
      tmp.eb(T);
    reverse(tmp.begin(), tmp.end());
    int qwq = 31 ^ __builtin_clz(S & -S);
    f[S] = pw[cnt[S]];
    for (int T : tmp) {
      int o = T & -T, p = 31 ^ __builtin_clz(o);
      if (o == T) {
        cross[T] = __builtin_popcount(G[p] & (S ^ T));
      } else {
        cross[T] = cross[T ^ o] + cross[o] -
                   __builtin_popcount(G[p] & (T ^ o)) - G2[T ^ o][p];
      }

      (f[S] += ll(g[T]) * pw[cross[T] + cnt[T ^ S]] % mod) %= mod;
      if (p != qwq)
        continue;
      int v = ll(f[T]) * g[S ^ T] % mod;
      (g[S] += mod - v) %= mod;
    }
    (f[S] += g[S]) %= mod;
    (g[S] += mod - f[S]) %= mod;
  }
  cout << f[(1 << n) - 1] << '\n';
}
```

---

## 作者：P2441M (赞：5)

## 题意简述
给定一个 $n$ 个点 $m$ 条边的有向简单图，问有多少种删边的方案，使得删去后整个图是强连通的，答案对 $10^9+7$ 取模。

对于所有数据，$1\leq n\leq 15$，$0\leq m\leq n(n-1)$。

## 题解
$\text{Upd 2025/3/14}$：修改了一些笔误。

还是太神仙了。

强连通分量本身是比较难刻画的，但我们可以通过**缩点**刻画其结构性：若一张图是强连通的，那么它缩点后必然是一个单点，否则就是一个 DAG。DAG 计数是比较经典的，因此考虑正难则反，用 $2^m$ 减去缩点后图是一个 DAG 的方案数。

先考虑一个比较简单的问题：求这个图中有多少个子图是一个 DAG。对于 DAG 计数，考虑拓扑排序，那么每次拓扑排序的 $0$ 入度点对图进行了分层，形成了阶段性，很有利于我们进行 DP。令 $f_S$ 表示 $S$ 集合的导出子图中 DAG 子图的个数。枚举 $0$ 入度点集合 $T$：
$$
f_S=\sum_{\substack
{T\subseteq S\\T\neq\varnothing}}2^{cnt(T,S\backslash T)}f_{S\backslash T}
$$

其中 $cnt(A,B)=\left|\{(u,v)|(u,v)\in E,u\in A,v\in B\}\right|$，即点集 $A$ 中的点连向点集 $B$ 中的点的边数。

但是，上面的转移方程是错误的，因为 $T\rightarrow S\backslash T$ 的边是乱连的，我们无法保证 $S$ **恰好**是 $0$ 入度点集，会算重。而 $2^{cnt(T,S\backslash T)}f_{S\backslash T}$ 计算的实际上是**钦定** $T$ 为 $0$ 入度点集的方案数，因此考虑**容斥**。令 $f_{T,S}$ 表示 $S$ 点集中 $T$ **恰好** 是 $0$ 入度点集的方案数，$g_{T,S}$ 表示 $S$ 中**钦定** $T$ 为 $0$ 入度点集的方案数。那么可以得到
$$
g_{T,S}=2^{cnt(T,S\backslash T)}f_{S\backslash T}=\sum_{T\subseteq R\subseteq S}f_{R,S}
$$

根据子集反演，
$$
f_{T,S}=\sum_{T\subseteq R\subseteq S}(-1)^{|R|-|T|}g_{T,S}
$$

代回再变换求和顺序，可以得到
$$
\begin{align*}
f_S & =\sum_{\substack
{T\subseteq S\\T\neq\varnothing}}f_{T,S} \\
& =\sum_{\substack
{T\subseteq S\\T\neq\varnothing}}\sum_{T\subseteq R\subseteq S}(-1)^{|R|-|T|}2^{cnt(R,S\backslash R)}f_{S\backslash R} \\
& =\sum_{R\subseteq S}(-1)^{|R|}2^{cnt(R,S\backslash R)}f_{S\backslash R}\sum_{\substack
{T\subseteq R\\T\neq\varnothing}}(-1)^{|T|} \\
& =\sum_{R\subseteq S}(-1)^{|R|+1}2^{cnt(R,S\backslash R)}f_{S\backslash R}
\end{align*}
$$

这样就解决了 DAG 子图计数问题，同时我们也得到了一个显然的暴力：搜出缩点的方案，然后跑 DAG 子图计数。

考虑怎么优化。我们的暴力是形如搜出缩点方案 $V=\bigcup_{i=1}^kS_i$，然后答案就是
$$
ans_S=2^{cnt(S,S)}-\sum_{S_1,\cdots,S_k}\left(\prod_{i=1}^kans_{S_i}\right)\sum_{\substack{T\subseteq \{S_1,\cdots,S_k\}\\T\neq\varnothing}}(-1)^{|T|+1}2^{cnt(T,S\backslash T)}f_{S\backslash T}
$$

变换求和顺序，我们先去枚举 $T$，即缩点后的零入度点的并集在原图上对应的点集，注意到容斥系数只和零入度点划分成的 SCC 数量有关，并且对于 $S\backslash T$ 中的点，任意的子图都是合法的。令 $h_{k,T}$ 表示将 $T$ 中的点划分成 $k$ 个互不相连的 SCC 的方案数，那么容易得到
$$
ans_S=2^{cnt(S,S)}-\sum_{\substack
{T\subseteq S\\T\neq\varnothing}}\sum_{k=1}^{|T|}(-1)^{k+1}h_{k,T}2^{cnt(T,S\backslash T)}2^{cnt(S\backslash T,S\backslash T)}
$$

进一步地，容斥系数只跟零入度点划分成的 SCC 数量**奇偶性**有关，奇数个贡献为正，偶数个贡献为负，容易想到令 $h_T$ 表示把 $T$ 划分成奇数个 SCC 的方案数减去划分成偶数个 SCC 的方案数，转移方程变为
$$
ans_S=2^{cnt(S,S)}-\sum_{\substack
{T\subseteq S\\T\neq\varnothing}}h_T2^{cnt(T,S\backslash T)}2^{cnt(S\backslash T,S\backslash T)}
$$

再来考虑 $h_S$ 的转移。容易想到枚举某个子集 $T\subseteq S$ 作为其中一个 SCC，但显然会重复，于是我们对其添加限制，改为枚举 $\operatorname{lowbit}(S)$ 对应点 $p$ 所在的 SCC，容易得到转移方程：
$$
h_S=ans_S-\sum_{\substack{T\subset S\\p\in T}}ans_Th_{S\backslash T}
$$

加上 $ans_S$ 表示将 $S$ 划分为一整个 SCC，$\sum$ 前面的负号是因为多出了 $T$ 这个 SCC，奇偶性改变。

但是这样似乎 $h$ 和 $ans$ 似乎会相互转移啊？我们仔细思考，$ans$ 转移时只会在 $T=S$ 的时候用到 $h_S$，而这个的实际意义是 $S$ 就是一个强连通分量，但 $\sum$ 处要计算的是不合法的方案数，所以不应该被包含进来，这样就恰好不会相互转移了。也就是说，我们先计算 $h_S-ans_S$ 的部分，然后计算$ans_S$，最后给 $h_S$ 加回 $ans_S$ 就行了。可以结合代码理解。

时间复杂度是 $O(3^nn^2)$ 的，无法通过。瓶颈在于计算 $cnt(T,S\backslash T)$。暴力计算无法承受，那么考虑固定 $S$，假设我们得到了较大的 $T$ 对应的 $cnt(T,S\backslash T)$，然后尝试递推出当前的 $cnt(T,S\backslash T)$，这就很简单了，考虑 $\operatorname{lowbit}(S\backslash T)$ 对应的点 $p$，那么
$$
cnt(T,S\backslash T)=cnt(T\cup\{p\},S\backslash T\backslash \{p\})-cnt(p,S\backslash T\backslash \{p\})+cnt(T,p)
$$

而形如 $cnt(p,T)$ 或者 $cnt(T,p)$ 的单点到集合的边数显然可以 $O(2^nn^2)$ 预处理出来，于是我们就可以在枚举 $S$ 的过程中顺便把所有的 $cnt(T,S\backslash T)$ 递推出来。总体时间复杂度为 $O(3^n)$。

## 代码
```cpp
int n, m, mat[N][N];
int pw2[M], pc[S], ocnt[N][S], icnt[N][S], cnt[S], f[S], g[S];
int tcnt[S];

int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1, u, v; i <= m; ++i) cin >> u >> v, mat[--u][--v] = 1;
    pw2[0] = 1;
    for (int i = 1; i <= m; ++i) pw2[i] = (pw2[i - 1] << 1) % MOD;
    for (int i = 0; i < n; ++i) for (int s = 0; s < 1 << n; ++s)
    	for (int j = 0; j < n; ++j)
    		if (s >> j & 1) ocnt[i][s] += mat[i][j], icnt[i][s] += mat[j][i];
    for (int s = 1; s < 1 << n; ++s) {
    	int lb = lowbit(s), i = log2(lb), ss = s ^ lb;
    	cnt[s] = cnt[ss] + icnt[i][ss] + ocnt[i][ss];
    	pc[s] = pc[s - lowbit(s)] + 1;
    }
    for (int s = 1; s < 1 << n; ++s) {
    	int lb = lowbit(s);
    	for (int t = (s - 1) & s; t; t = (t - 1) & s)
    		if (t & lb) g[s] = (g[s] - 1ll * f[t] * g[s ^ t] % MOD) % MOD;
    	tcnt[s] = 0, f[s] = pw2[cnt[s]];
    	for (int t = s; t; t = (t - 1) & s) {
    		int lb = lowbit(s ^ t), i = log2(lb);
    		if (t != s) tcnt[t] = tcnt[t | lb] - ocnt[i][s ^ t ^ lb] + icnt[i][t];
    		else tcnt[t] = 0;
    		f[s] = (f[s] - 1ll * g[t] * pw2[tcnt[t]] % MOD * pw2[cnt[s ^ t]] % MOD) % MOD;
    	}
    	g[s] = (g[s] + f[s]) % MOD;
    }
    cout << (f[(1 << n) - 1] + MOD) % MOD;
    return 0;
}
```

---

## 作者：AC_Lover (赞：3)

给一个 $n$ 个点 $m$ 条边的简单有向图 $G$，$n\le 15,m\le n(n-1)$。

1.  DAG 子图计数

​		直接定义 $f_S$ 表示点集为 $S$ 的DAG子图数量，考虑DAG的性质，即我们可以每次挑出入度为 $0$ 的点删掉，于是就可以划分了，枚举子集 $T$ 表示挑出来的入度为 $0$ 的点，于是最后贡献应该是 $2^{\mathrm{cross}(T,S\setminus T)}f_{T}$ 状物。但是我们发现这时入度为 $0$ 的点集会被按照多种子集划分统计，于是需要容斥。考虑到我们求的是
$$
\left|\bigcup_{i\in U}S_i\right|=\sum_{T\subseteq S,T\ne \empty} (-1)^{|T|-1}\left|\bigcap_{i\in T} S_i\right|
$$
于是转移时乘上容斥系数即可，得到
$$
f_{S}=\sum_{T\subseteq S,T\ne \empty} (-1)^{|T|-1}2^{\mathrm{cross}(T,S\setminus T)}f_{S\setminus T}
$$

2. 强连通子图计数（主旋律）

   首先【强连通子图 $=$ 总子图 $-$ 非强连通子图】。

   考虑这跟DAG计数的关系，有重要性质，就是所有非强连通子图在SCC缩点后构成点数大于 $1$ 的DAG。

   那么直接定义 $f_S$ 表示点集为 $S$ 的强连通子图数量，并令 $G_S$ 表示点集为 $S$ 的子图总数。

   总子图有 $G_S$ 个，对于非强连通子图，我们在其缩点后的DAG上进行刻画，根据套路找到所有入度为 $0$ 的SCC，那么相当于要拎出来一个点集 $T$ 让其构成一个个独立的SCC，定义这个方案数为 $g_T$，那么不难发现剩下的部分可以任意组合，都满足条件。

   根据之前的分析，此时需要**进行容斥**，即选出的SCC组成的集合 $T^\prime$ 会被按照多种子集划分统计，仿照DAG计数，我们知道这个容斥系数应为 $(-1)^{|T^\prime|-1}$，不难发现这个要在 $g$ 的计算中被完成。那么
   $$
   f_{S}=G_S-\sum_{T\subseteq S\wedge T\ne \empty}g_{T}2^{\mathrm{cross}(T,S\setminus T)}G_{S\setminus T}
   $$
   接下来考虑 $g$ 的计算。

   先考虑整个 $S$ 都是一个SCC，这种情况贡献是 $f_S$。

   对于多个独立的SCC，拎一个出来，记其点集为 $T$，那么其个数就是 $f_{T}$，剩下的就是 $g_{S\setminus T}$，并且每新增一个 SCC就要乘上 $-1$ 来实现容斥系数，于是转移应该是 $-f_{T}g_{S\setminus T}$ 状物。但是这样会有问题，就是你选择SCC的顺序会造成影响，于是进行钦定顺序，假设钦定一个点 $x$ 表示选择的SCC $T$ 包含 $x$，那么由于包含 $x$ 的SCC是唯一的，于是就完成了顺序钦定，考虑定义一个SCC $T$ 的代表为 $\mathrm{lowbit}(T)$，于是得到
   $$
   g_{S}=f_{S}-\sum_{T\subset S\wedge \mathrm{lowbit}(T)=\mathrm{lowbit}(S)}f_{T}g_{S\setminus T}
   $$

​		还没完，对于 $f$ 的计算，注意到当 $T=S$ 时，要求 $g$ 中包含的点数是大于 $1$ 的，所以此时 $g$ 中不能算上 $f_S$ 的贡献，于是转移应该是
$$
g_S=-\sum_{T\subset S\wedge \mathrm{lowbit}(T)=\mathrm{lowbit}(S)}f_{T}g_{S\setminus T} \\
f_{S}=G_S-\sum_{T\subseteq S\wedge T\ne \empty}g_{T}2^{\mathrm{cross}(T,S\setminus T)}G_{S\setminus T} \\
g_S\leftarrow g_S+f_S
$$
​		那么我们得到了 $O(3^nn^2)$ 的做法，无法通过。

​		我们算法的瓶颈在于计算 $\mathrm{cross}(T,S\setminus T)$，我们考虑递推计算，假设固定住 $S$ 后 $T$ 要加入一个点 $u$，那么变成 $\mathrm{cross}(T\cup \set{u},S\setminus T\setminus \set{u}))$，那么原来 $T$ 中到 $u$ 的都没掉，$u$ 到 $(S\setminus T)$ 中的都加上，于是
$$
\mathrm{cross}(T\cup \set{u},S\setminus T\setminus \set{u}))=\mathrm{cross}(T,S\setminus T)-|\mathrm{in}(u)\cap T|+|\mathrm{out}(u)\cap (S\setminus T)| \\
\Rightarrow \mathrm{cross}(T,S\setminus T)=\mathrm{cross}(T\cup \set{u},S\setminus T\setminus \set{u}))+|\mathrm{in}(u)\cap T|-|\mathrm{out}(u)\cap (S\setminus T)|
$$
于是可以在枚举子集时随便加一个 $u$ 并计算，此处取 $u=\mathrm{lowbit}(S\setminus T)$ 即可。

​		$G_S$ 同理，加上一个点 $u$ 则加入了 $S$ 到 $u$ 和 $u$ 到 $S$，得到
$$
G_{S\cup \set{u}}=G_S+|\mathrm{in}(u)\cup S|+|\mathrm{out}(u)\cup S| \\
$$
​		最终时间复杂度 $O(3^n)$。

代码：
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N=15,M=215,mod=1e9+7;
typedef long long ll;
inline int Mod(int x) { return x<0 ? x+mod : (x>=mod ? x-mod : x); }
inline void adm(int &x,int y) { x=Mod(x+y); }
inline void dec(int &x,int y) { x=Mod(x-y); }
inline int lowbit(int x) { return x & (-x); }

int n,m;
bool e[N][N];
int in[N],out[N];
int pw2[M],ppcnt[1<<N],bit[1<<N];
int G[1<<N];
int cross[1<<N];
int f[1<<N],g[1<<N];

inline void print(int S) { for (int i=0;i<n;i++) cout << ((S>>i)&1); }

int main()
{
	cin >> n >> m;
	for (int i=1;i<=m;i++)
	{
		int u,v;
		cin >> u >> v;
		u--,v--;
		e[u][v]=true;
		in[v]|=(1<<u);
		out[u]|=(1<<v);
	}
	
	pw2[0]=1;
	for (int i=1;i<=m;i++) pw2[i]=(ll)pw2[i-1]*2%mod;
	for (int i=1;i<(1<<n);i++) ppcnt[i]=ppcnt[i>>1]+(i&1);
	for (int i=0;i<n;i++) bit[1<<i]=i;
	
	for (int S=1;S<(1<<n);S++)
	{
		int u=bit[lowbit(S)];
		G[S]=G[S^(1<<u)]+ppcnt[in[u]&S]+ppcnt[out[u]&S];
	}
	
	g[0]=-1;
	for (int S=0;S<(1<<n);S++)
	{
		memset(cross,0,sizeof(cross));
		for (int T=S&(S-1);T;T=(T-1)&S)
		{
			int u=bit[lowbit(S-T)];
			cross[T]=cross[T|(1<<u)]+ppcnt[in[u]&T]-ppcnt[out[u]&(S-T)];
		}
		
		for (int T=S&(S-1);T;T=(T-1)&S) 
		{
			if (lowbit(T)==lowbit(S))
			{
				dec(g[S],(ll)f[T]*g[S-T]%mod);
			}
		}
		f[S]=pw2[G[S]];
		for (int T=S;T;T=(T-1)&S) dec(f[S],(ll)g[T]*pw2[cross[T]]%mod*pw2[G[S-T]]%mod);
		adm(g[S],f[S]);
	}
	cout << f[(1<<n)-1] << "\n";
	
	return 0;
}
```

---

## 作者：dengchengyu (赞：2)

## 题目大意

给定一张 $n$ 个点 $m$ 条边的有向图，求有多少边集的子集，使得连上这些边后整张图强连通。

满足 $n\le 15,m\le n(n-1)$。

保证没有重边，对于 $a$ 连向 $b$ 与 $b$ 连向 $a$ 看做两条不同的边。

## 分析

强连通是不好刻画的，考虑一张图求出强连通分量缩点后，会形成一张 DAG，而整张图强连通就是 DAG 中只有一个点。

于是考虑用总方案数减去 DAG 中至少有两个点的方案数。

以下我们称缩点后的 DAG 上的一个点叫做**一个 SCC**。且一个 SCC 的集合表示这个 SCC 中包含的点的集合。

设 $dp_S$ 表示点集 $S$ 的子图强连通的方案数。接下来我们算出 $S$ 中至少有两个 SCC 的方案数。根据 DAG 容斥的思想，我们可以枚举 DAG 上入度为 $0$ 的 SCC 的集合的并集 $T$，使得 $T$ 是 $S$ 的子集。然后 $S-T$ 中的边可以随便选，$T\to S-T$ 中的边也可以随便选，$T$ 中的边需要将 $T$ 分成 $cnt$ 个 SCC，此时容斥系数为 $(-1)^{cnt+1}$。

发现 $T$ 的方案不好算，于是我们考虑直接算 $g_T$ 表示，把 $T$ **分成奇数个 SCC 减去分成偶数个 SCC 的方案数**。

设 $E(S,T)$ 表示 $u\in S,v\in T$ 的有向边 $u\to v$ 的个数，$E(S)$ 等价于 $E(S,S)$。以上，可得出 $dp_S$ 的转移：
$$
dp_S=2^{E(S)}-\sum _{T\subset S} 2^{E(S-T)+E(T,S-T)}g_T
$$
注意：这里当 $T=S$ 时，$g_T$ 要排除掉分成 $1$ 个 SCC 的方案数，那么使得这里 $dp_S$ 算的就是分成一个 SCC 的方案数了。

那么 $g_S$ 的转移就是考虑首先将 $S$ 分为一个 SCC，方案数为 $dp_S$。然后枚举一个**真子集** $T$ 表示将 $T$ 划分为一个 SCC 插入进来，贡献即为 $-g_{S-T}\times dp_T$，这里直接取 $-1$ 的系数发现刚好满足 $g$ 的定义。

但是这样会算重，因此需要确定 $T$ 的插入顺序，每次要确保 $\text{lowbit}(T)=\text{lowbit}(S)$ 才可插入。于是我们得到了 $g_S$ 的转移：
$$
g_S=dp_S-\sum_{T\subsetneqq S\land \text{lowbit}(T)=\text{lowbit}(S)} g_{S-T}\times dp_T
$$
那么我们可以先算 $g_S$ 转移的后半部分，然后直接转移 $dp_S$（如上面所说 $g_S$ 要排除掉选划分成一个 SCC 的方案数），最后再把 $g_S$ 加上。 $dp_S$。

对于算 $E(T,S-T)$，我们 $O(m2^n)$ 预处理 $F_{i,S}=E(\{i\},S)$，然后转移就是 $O(n3^n)$。总时间复杂度 $O(n3^n)$。

## 代码

```cpp
const int mod=1e9+7;
const int M=16*16,N=16;
#define lowbit(x) (x&(-x))
int n,m;
int a[M],b[M];
int f[N][1<<15];
int e[1<<15];
int w[M];
int dp[1<<15],g[1<<15];
signed main(){
	w[0]=1;
	fu(i,1,M) w[i]=w[i-1]*2ll%mod;
	cin>>n>>m;
	fo(i,1,m) cin>>a[i]>>b[i];
	fu(i,0,1<<n) {
		fo(j,1,m) if(i>>(b[j]-1)&1) f[a[j]][i]++;
	}
	fu(i,0,1<<n) fo(j,1,n) if(i>>(j-1)&1) e[i]+=f[j][i];  
	fu(i,1,1<<n) {
		for(int j=(i-1)&i;j;j=(j-1)&i) {
			if(lowbit(j)==lowbit(i)) g[i]=(g[i]+mod-(ll)g[i^j]*dp[j]%mod)%mod;
		}
		dp[i]=w[e[i]];
		for(int j=i;j;j=(j-1)&i) {
			int e1=0;
			fo(k,1,n) if(j>>(k-1)&1) e1+=f[k][i^j]; 
			dp[i]=(dp[i]+mod-(ll)w[e[i^j]+e1]*g[j]%mod)%mod;
		}
		g[i]=(g[i]+dp[i])%mod;
	}
	cout<<dp[(1<<n)-1];
	return 0;
}
```

---

## 作者：_LSA_ (赞：2)

令 $f_{S}$ 表示只考虑 $S$ 中的点，这些点强连通的方案数；$E(S,T)$ 表示起点在 $S$ 中，终点在 $T$ 中的边的数量。

记集合间的减法运算 $S-T$ 表示，集合 $S$ 中的元素扣去集合 $T$ 中的元素剩下的元素构成的集合。

考虑 $S$ 中的点构成的子图，每条边可以选择保留或断开，有 $2^{E(S,S)}$ 种方案。我们再考虑另一种计算这 $2^{E(S,S)}$ 张图的方式，由于对于任意的有向图，其 SCC 缩点之后是一个 DAG，类似于 [DAG 容斥](https://www.luogu.com.cn/problem/AT_abc306_h) 的套路，我们钦定 $i$ 个缩点后入度为零的点，其在原图对应了 $i$ 个相互独立的强连通分量，设其对应的点集为 $T$，而由于缩点后的这些点入度为 $0$，故不能有连向 $T$ 的边，而剩下的边可以随便连，贡献是 $2^{E(S,S-T)}$，容斥系数为 $(-1)^{i-1}$。

不妨设 $g_S$ 表示 $S$ 集合中的点构成奇数个独立的（相互没有连边的）SCC 的方案数减去偶数个独立的 SCC 的方案数，即 $S$ 集合缩点后成 $i$ 个独立的点的方案数乘上容斥系数，则有

$$
2^{E(S,S)}=\sum_{T\subseteq S,T\neq \emptyset}2^{{E(S,S-T)}}g_T
$$

把 $g_S$ 提出来，则有

$$
g_S = 2^{E(S,S)}-\sum_{T\subsetneqq S,T\neq \emptyset}2^{{E(S,S-T)}}g_T
$$

接下来考虑怎么利用 $g_S$ 求出 $f_S$，发现我们可以枚举 $S$ 中标号最小的点所在的 SCC，设 $\min(S)$ 表示这个最小的点，则有

$$
g_S=\sum_{T\subseteq S,\min(S)\in T} -f_Tg_{S-T}
$$

乘 $-1$ 是因为多了一个 SCC 会使得容斥系数乘 $-1$，注意这里我们需要定义空集对应的 $g$ 的值为 $-1$。

同样把 $f_S$ 提出来，则有

$$
f_S = g_S+\sum_{T\subsetneqq S,\min(S)\in T} f_Tg_{S-T}
$$

记全集为 $U$，故答案为 $f_U$。

暴力计算 $E(S,T)$ 的复杂度是 $O(|S|)$ 的，故整个问题在 $O(n3^n)$ 解决。


```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define mk make_pair
#define fi first
#define se second
#define ll long long
using namespace std;
ll read(){
	ll X = 0,r = 1;
	char ch = getchar();
	while(!isdigit(ch) && ch != '-') ch = getchar();
	if(ch == '-') r = -1,ch = getchar();
	while(isdigit(ch)) X = X*10+ch-'0',ch = getchar();
	return X*r;
}
const int N = 20;
const int S = 1<<15;
const int mod = 1e9+7;
int n,m,G[N];
ll f[S],g[S],pw[N*N];
int main(){
	n = read(); m = read();
	for(int i=1;i<=m;i++){
		int u = read(),v = read();
		G[u-1] |= 1<< (v-1);
	}
	pw[0] = 1;
	for(int i=1;i<=m;i++) pw[i] = pw[i-1]*2%mod;
	auto E = [&](int S,int T){
		int cnt = 0;
		for(int i=0;i<n;i++)
			if((S >> i) & 1) cnt += __builtin_popcount(T&G[i]);
		return cnt;
	};
	for(int s=0;s<(1<<n);s++){
		g[s] = pw[E(s,s)];
		for(int t=(s-1)&s;t;t=(t-1)&s)
			g[s] = (g[s]+mod-g[t]*pw[E(s,s^t)]%mod)%mod;
	}
	for(int s=0;s<(1<<n);s++){
		f[s] = g[s];
		for(int t=(s-1)&s;t;t=(t-1)&s)
			if((t & (-t)) == (s & (-s)))
				f[s] = (f[s]+f[t]*g[s^t])%mod;
	}
	cout << f[(1<<n)-1];
	return 0;
}
```

---

## 作者：2020HZ06 (赞：2)

题意：给定一张有向图，求删去若干条边后图仍然强连通的方案数。$n \le 15,m\le n(n-1)$。

首先题意相当于求为强连通分量的**生成子图**的数量。那么正难则反，考虑统计**不为**强连通分量的生成子图的数量。

那么对子图进行缩点，一定会变成 **DAG**（且不是一个点）。对于一个点集 $S$ 计算答案，设**入度为 $0$** 的**部分**强连通分量中的**所有**点组成点集 $T$，那么 $T \subseteq S$。设：

$f_{S}$： 点集为 $S$ 的**非孤点** DAG 数量。  
$h_S$：$S$ 集合中形成**一个**强连通分量的方案数。这也是题目所求。  
$g_S$：$S$ 集合中形成**若干**强连通分量的方案数。强连通分量两两之间没有边。  
$E(S,T)$：$|\{(x,y)|(x,y)\in M,x \in S,y \in T\}|$，也就是 $S$ 到 $T$ 的边的数量。

那么我们就可以得出：$f_{S,T}=g_T2^{E(T,S\backslash T)E(S\backslash T,S\backslash T)}(T \subset S,|S|>|T|>0)$

用容斥求出 $f$：
$f_S=\sum\limits_{T \subset S,|S|>|T|>0}(-1)^?g_T2^{E(T,S\backslash T)+E(S\backslash T,S\backslash T)}(T \subset S,|S|>|T|>0)$

含义：假定 $|T|<|S|$，对子集 $T$ 进行容斥，$T$ 本身有 $g_T$ 种选法，而 $T$ 和 $S$ 中的剩余点之间的边只能选 $T \to S\backslash T$ 的有向边，方案数 $2^{E(T,S\backslash T)}$，再乘上 $S\backslash T$ 中任意选边的方案数 $2^{E(S\backslash T,S\backslash T)}$。那么显然答案满足**并集**的形式，对这坨东西进行**并集容斥**即可。

然而容斥系数是多少呢？注意我们定义的 $g$ 中的点能形成**若干入度为0的强连通分量**，而不是**任意**满足 $T\subseteq S$ 且 $T$ 中的点属于一个入度为 $0$ 的强连通分量。所以容斥系数并不是 $|T|+1$ ，而是**形成强连通分量的个数+1**。换句话说，我们研究的对象并非**单个点**，而是**一整个强连通分量**。这个容斥系数和 $T$ 本身无关，因此要乘进 $g$ 里。

$h$ 的计算方法：$h_S=2^{E(S,S)}-F_S$，

接下来算 $g$，一个简单的 DP 即可解决：$g_S=\sum\limits_{T\subseteq S,S_{min}\in T}-h_Tg_{S\backslash T}$

其中 $S_{min}$ 表示最低位的点，而增加一个强连通分量容斥系数乘 $-1$。

但还有一个问题是 $|T|=|S|$ 的贡献**仍然是要算的**，而且应该是 $g_S$ 去掉 $h_S$ 的贡献。这里就有个骚操作：

先将 $|T|<|S|$ 的 $h_T$ 的贡献累加，此时答案正好是 $g_S$ 去掉 $h_S$ 的贡献！
把它贡献到 $f$ 上就行了。

$E$ 怎么办呢？$E$ 数组开不下，那我们就在枚举 $S$ 时顺便枚举算出子集 $T$ 的贡献即可。具体实现需要一些位运算的技巧。

时间复杂度：因为是在枚举子集所以是 $O(3^n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=1e9+7; 
const int N=(1<<15);
int n,m,in[16],out[16],e[N],s[N],lg[N],bit[N],w[N];
ll pw[225],f[N],g[N],h[N];
int main()
{
	int x,y,tot;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) scanf("%d%d",&x,&y),out[x-1]|=(1<<y-1),in[y-1]|=(1<<x-1);
	pw[0]=1;
	for(int i=1;i<=n*(n-1);i++) pw[i]=pw[i-1]*2%mod;
	for(int i=0;i<n;i++) lg[1<<i]=i;
	for(int i=1;i<(1<<n);i++) bit[i]=bit[i^(i&-i)]+1;
	h[0]=g[0]=1;
	for(int S=1;S<(1<<n);S++){
		tot=0;int cnt=0;
		for(int i=0;i<n;i++)
			if((S>>i)&1) cnt+=bit[out[i]&S];
		w[S]=cnt;
		for(int T=S;T;T=(T-1)&S) s[++tot]=T;
		for(int i=tot;i>=1;i--){
			int T=s[i],R=T^(T&(-T)),u=lg[T&(-T)];
			e[T]=e[R]-bit[R&in[u]]+bit[out[u]&(S^T)];
		}
		int R=S^(S&-S);
		for(int T=R;T;T=(T-1)&R)
			if(T<R) (g[S]+=mod-h[T|(S&-S)]*g[R^T]%mod)%=mod;
		if(R) (g[S]+=mod-h[S&-S]*g[R]%mod)%=mod;
		for(int i=tot;i>=2;i--){
			int T=s[i];
			(f[S]+=g[T]*pw[e[T]]%mod*pw[w[S^T]]%mod+mod)%=mod;
		}
		(f[S]+=g[S])%=mod;
		h[S]=(pw[cnt]+mod-f[S])%mod;
		(g[S]+=h[S])%=mod;
	}
	printf("%lld\n",h[(1<<n)-1]);
	return 0;
}
```

---

## 作者：CatFromMars (赞：2)

参考了各种题解，太牛了这题，学习 qwq。

首先考虑判定一张强连通图，要缩点。缩点后一个点那么就是一张强连通图，是一个 DAG 就是一个非强连通图。单点条件很严苛，正难则反。如果我们已经知道每个点属于哪个强连通分量，那么做一次 DAG 子图计数就能计算出来不合法的方案数。问题在于我们不知道每个点属于哪个强连通分量。但是实际上我们并不在乎整个 DAG 的具体形态，而是只在乎“它是一个 DAG 而不是一个单点”。为了描述这件事情我们只需要找到一组入度为 $0$ 的强连通分量即可，剩下的不用在乎。

先设 $E_{S, T}$ 为 $S$ 到 $T$ 边数，$H_S$ 为 $S$ 内部边数。

$f_S$ 为 $S$ 内所有点在一个强连通分量的方案数，总方案数 $2^{H_{S}}$。要减去不合法的方案数。根据上面的我们枚举 $T\subset S$，代表钦定 $T$ 内的点缩点后形成的强连通分量是 DAG 中入度为 $0$ 的点，其它任意。因为这每次只会考虑到一个子集，通过子集反演可以得到形成 $t$ 个联通分量那么容斥系数为 $(-1)^{t+1}$。我们无法在计算 $f_S$ 时通过枚举 $T$ 的方式直接得到容斥系数。需要在计算 $T$ 内部连边方法时计算。$T$ 之外 $T$ 到 $(S - T)$ 的连边任意，$(S - T)$ 内部连边也任意，这部分是 $2^{E_{T, S - T} + H_{S - T}}$ 的。

令 $g_T$ 为形成奇数个强连通分量的方案数减去形成偶数个强连通分量。那么 $f_S = 2^{H_{S}} - \sum\limits_{T \subset S, T\not = \empty} g_T2^{E_{T, S - T} + H_{S - T}}$。现在对 $g$ 计算。如果没有容斥系数那么 $g_S = \sum\limits_{\operatorname{lowbit(S)}\in T\subset S}f_Tg_{S - T}$。现在有了容斥系数，奇偶数量变化，这些都要取反，特别的 $T = S$ 时 $f_T$ 不用取反。$g_S = f_S - \sum\limits_{\operatorname{lowbit}(T)\in T \subsetneq S} f_Tg_{S - T}$。我们发现很严重的事情在于是不是计算 $f_S$ 的时候要用到 $g_S$。但是 $g_S$ 中 $f_S$ 这部分代表的是 $S$ 全在一个连通分量中的方案数，在 $f$ 中是合法的，不应该减去。因此我们先处理 $g_S$，令此时 $f_S$ 为 $0$，然后再处理 $f_S$，最后把 $g_S$ 加上 $f_S$ 即可。

本来对于 $E$ 我是用 $O(3^n)$ 写的，但是因为我调用了 $O(3^n)$ 次 unordered_map 常数爆炸导致跑的还没还有 $O(n3^n)$ 快（悲。

```cpp
#include <bits/stdc++.h>
#define il inline
using namespace std;
const int N = 15, Mod = 1e9 + 7;
il int lowbit(int x) {
	return x & (-x);
}
il void upd(int &x, int y) {
	x = (((x + y) >= Mod) ? (x + y - Mod) : (x + y));
}

int n, m, bas2[N * N + 10];
bool gra[N + 3][N + 3];
int H[(1 << N) + 10], out[(1 << N) + 10];
int f[(1 << N) + 10], g[(1 << N) + 10];
int E(int S, int T) {
	int rest = 0;
	while(S) {
		int R = lowbit(S);
		rest += __builtin_popcount(out[R] & T);
		S -= R;
	}
	return rest;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	bas2[0] = 1;
	for(int i = 1, x, y; i <= m; i++) {
		cin >> x >> y;
		x--, y--;
		bas2[i] = bas2[i - 1] * 2 % Mod;
		gra[x][y] = 1;
		for(int S = 0; S < (1 << n); S++)
			if(((S >> x) & 1) && ((S >> y) & 1))
				H[S]++;
		out[(1 << x)] |= (1 << y);
	}

	for(int S = 1; S < (1 << n); S++) {
		if(__builtin_popcount(S) == 1) {
			f[S] = g[S] = 1;
			continue;
		}
		for(int T = S - lowbit(S); ; T = (T - 1) & (S - lowbit(S))) {
			int R = T + lowbit(S);
			upd(g[S], (Mod - 1ll * f[R] * g[S - R] % Mod) % Mod);
			if(!T) break;
		}
		f[S] = bas2[H[S]];
		for(int T = S; T; T = (T - 1) & S)
			upd(f[S], (Mod - 1ll * g[T] * bas2[E(T, S - T) + H[S - T]] % Mod) % Mod);
		upd(g[S], f[S]);
	}
	cout << f[(1 << n) - 1] << endl;
}
```

---

## 作者：spdarkle (赞：1)

设 $A(S|S_1,S_2\dots S_m)$ 为钦定当前图中强连通分量每个恰好由 $S_1\dots S_m$ 组成，点集为 $S$ 的图的个数（注意包含额外边）

当 $S_1\cup S_2\dots S_m=S$ 时要求 $m\ge 2$  否则为假。

但注意到这个不好求，不妨设 $B(S_1,S_2\dots S_m)$ 表示钦定这些点集组成了某些强连通分量的方案数。

不妨再设 $H(S)$ 表示点集 $S$ 内边数，设 $W(S,T)$ 表示入点在 $S$ 里且出点在 $T$ 里的边数。

则显然有：
$$
B(S_1,S_2\dots S_m)=2^{W(\cup S_i,S/{\cup S_i})+H(S/\cup S_i)}\prod_{i=1}^mf(S_i)
$$
然后考虑通过子集反演：
$$
A(S|S_1,S_2\dots S_m)=\sum_{m_1\ge m,\lbrace S_1\dots S_m\rbrace\subseteq \lbrace{T_1\dots T_{m_1}\rbrace}}B(T_1,T_2\dots T_{m_1})(-1)^{m_1-m}
$$
这个带入容易证明。

那么再来就有：

注意到始终有 $m\ge 1$。
$$
\begin{aligned}
f(S)&=2^{H(S)}-\sum A(S|S_1,S_2\dots S_m)\\
&=2^{H(S)}-\sum_{S_1\dots S_m,\color{red}{m\ge 1}}\sum_{\lbrace S_1\dots S_m\rbrace\subseteq \lbrace{T_1\dots T_{m_1}\rbrace}} B(T_1\dots T_{m_1})(-1)^{m_1-m}\\
&=2^{H(S)}-\sum_{T_1\dots T_{m_1}}B(T_1\dots T_{m_1})\sum_{\lbrace S_1\dots S_m\rbrace\subseteq \lbrace{T_1\dots T_{m_1}\rbrace},\color{red}{m\ge 1}}(-1)^{m_1-m}\\
&=2^{H(S)}-\sum_{T_1\dots T_{m_1}}B(T_1\dots T_{m_1})(-1)^{m_1+1}
\end{aligned}
$$
现在的问题在于怎么计算 $B$。

注意到我们的贡献系数 $2^{W(\cup S_i,S/{\cup S_i})+H(S/\cup S_i)}$ 只与 $\cup S_i$ 有关。

因此可以考虑子集 DP 计算 $B$。

具体地，设 
$$
g(T)=\sum_{T_1\cup T_2\dots \cup T_m}(-1)^{m+1}\prod_{i=1}^mf(T_i)
$$
则有 
$$
g(T)=f(T)-\sum_{T'\subset T,\max(T)\in T'}f(T')g(T/(T'))
$$
由此可以解决。

注意到我们在 $A$ 里有限制：$m=1$ 时要求 $T\neq S$，其实相当于 $g(S)$ 里面不算入 $f(S)$。

那么就有：
$$
f(S)=2^{H(S)}-\sum_{T\subseteq S}g(T)2^{W(T,S/T)+H(S/T)}
$$
注意到 $W$ 通过一定预处理可以 $O(n)$ 单次计算。

因此 $O(n3^n)$ 解决。

---

## 作者：DerrickLo (赞：0)

正着有点太难刻画了，所以考虑使用总方案数减去图不为强联通的方案数。总方案数显然是 $2^{|E|}$，而对于图不为强联通的方案数，考虑将图缩点，这样新图是一个不为单点的 DAG。对于 DAG 的计数，我们通常会钦定一个子图的入度均为 $0$，对于算重的问题考虑容斥：记大小为 $i$ 的点集的容斥系数为 $o_i$，我们要每个点集恰好被计算一次，那么 $o_i$ 需要对于任意 $x$，满足 $\displaystyle{\sum_{i=0}^{x}\binom{x}{i}o_i}=1$，观察结果不难发现 $o_i=(-1)^{i+1}$，这就是 DAG 中对于 $0$ 度点集的容斥系数。

回到原问题，记 $f_S$ 表示对于点集 $S$ 删去若干条边依然强联通的方案数。还是考虑枚举一个子集 $T$，表示缩点后 $0$ 度点所对应的强联通分量的点构成的集合，先考虑 $S\setminus T$ 里面的边，$T\rightarrow S\setminus T$ 的边和 $S\setminus T\rightarrow T$ 的边，不难发现最后一种边是不能保留的，其他边都可以随意处理，贡献是形如 $2^x$ 的东西，可以通过预处理 $a_u$ 表示 $u$ 可以到达的集合来做到对于 $S$ 和 $T$ 单次 $\mathcal O(n)$ 求出。

  然后再考虑 $T$ 内部的边。设这个子集中的强联通分量个数为 $x$，同样地可以得出容斥系数是 $(-1)^{x+1}$，也就是如果有奇数个强联通分量那么贡献就是正的，偶数个就是负的。考虑记 $g_S$ 表示  $S$ 这个点集分成奇数个强联通分量的方案数减去分成偶数个强联通分量的方案数，那么 $g_S=f_S-\displaystyle{\sum_{T\subseteq S}f_Tg_{S\setminus T}}$，这里我们钦定 $\min(S)=\min(T)$，这样就能不重复地计算。最后 $f_S$ 的转移方程就是形如 $f_S=2^{p_S}-\displaystyle{\sum_{T\subseteq S}g_T2^{x(S,T)}}$，其中 $p_S$ 是 $S$ 这个点集里的边数， $x(S,T)$ 是我们上一段求的东西。

时间复杂度 $\mathcal O(n3^n)$。

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define int long long
using namespace std;
int n,m,u,v,a[25],b[40005],bt[40005],f[40005],g[40005],pw[40005];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m,f[0]=pw[0]=1;
	for(int i=1;i<=m;i++)pw[i]=pw[i-1]*2%mod;
	for(int i=1;i<=m;i++)cin>>u>>v,u--,v--,a[u]|=1<<v;
	for(int i=0;i<1<<n;i++)bt[i]=__builtin_popcount(i);
	for(int i=0;i<1<<n;i++)for(int j=0;j<n;j++)if(i&(1<<j))b[i]+=bt[i&a[j]];
	for(int i=1;i<1<<n;i++){
		f[i]=pw[b[i]];
		for(int j=i;j;j=(j-1)&i)if(j!=i)if((j&-j)==(i&-i))g[i]=(g[i]+mod-f[j]*g[i^j]%mod)%mod;
		for(int j=i;j;j=(j-1)&i){
			int now=b[j^i];
			for(int k=0;k<n;k++)if(j&(1<<k))now+=bt[a[k]&(i^j)];
			f[i]=(f[i]+mod-g[j]*pw[now]%mod)%mod;
		}
		g[i]=(g[i]+f[i])%mod;
	}
	cout<<f[(1<<n)-1];
}
```

---

## 作者：happybob (赞：0)

考虑一个非 SCC，其缩点后是一个至少有两个点的 DAG。

考虑 DAG 容斥手法，记 $f_S$ 表示 $S$ 内的保留若干条边使得图强连通方案，转移枚举出度为 $0$ 的 SCC 构成的点集的子集，根据 $\sum \limits_{T \subseteq S,T \neq \varnothing} (-1)^{|T|-1} = 1$ 做容斥。此外记录 $g_{S,0/1}$ 表示保留 $S$ 内的边使得 $S$ 被划分为偶数或奇数个之间没有边的 SCC 的方案数。根据 $g$ 算容斥系数即可，复杂度 $O(3^n)$。

---

## 作者：ax_by_c (赞：0)

[可能更好的阅读体验](https://www.cnblogs.com/axbyc/articles/18904511)

数有向图强连通子图，$1\le n\le 15$。

反正写到我看得懂的程度，不保证所有人都能看懂。

## Sol

下记 $E(S,T)$ 为起点在 $S$ 中且终点在 $T$ 中的边数，$lowbit(S)$ 为 $S$ 中最小的一位。

显然状压 dp，设 $f_S$ 为 $S$ 的强连通子图个数。

考虑用 $2^{E(S,S)}$ 减去不强连通的子图个数。

考虑对缩点后的零度 SCC 容斥，设 $g_S$ 为将 $S$ 中的点划分为 $x$ 个 SCC 的方案数并带上容斥系数 $(-1)^{x-1}$。

即：$g_S=\sum_{A_1,A_2,\dots,A_x}(-1)^{x-1}\prod_{i=1}^{x}f_{A_i}$，其中 $A_1,A_2,\dots,A_x$ 是 $S$ 的一个划分（$x$ 可以为 $1$）。

有一个错误的想法是 $g_S=f_S-\sum_{x\subsetneq S}f_xg_{S-x}$，因为一个划分方案会被计算多次。

变成枚举 $lowbit(S)$ 被划分到的 SCC 即可解决，有 $g_S=f_S-\sum_{x\subsetneq S,lowbit(x)=lowbit(S)}f_xg_{S-x}$。

然后求 $f_S$，显然有 $f_S=2^{Q(S,S)}-\sum_{x\subseteq S}g_x2^{Q(S,S-x)}$。

注意在计算 $f_S$ 时 $g_S$ 中 的 $f_S$ 不用考虑，因此是先 $g_S\leftarrow-\sum_{x\subsetneq S,lowbit(x)=lowbit(S)}f_xg_{S-x}$，然后计算 $f_S$，再 $g_S\leftarrow f_S$。

接下来只要快速求 $E(S,T)$ 就好了，为什么很多题解瓶颈都在这里啊，这个真难吗？/yun

考虑分 $2$ 块，任意两个块间的状态数是 $O(2^n)$ 的，因此可以使用 lowbit 递推预处理时间复杂度 $O(2^n)$，单次查询时间复杂度 $T(4)=O(1)$。

总时间复杂度即为枚举子集的 $O(3^n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,r,l) for(int i=(r);i>=(l);i--)
#define repll(i,l,r) for(ll i=(l);i<=(r);i++)
#define perll(i,r,l) for(ll i=(r);i>=(l);i--)
#define pb push_back
#define ins insert
#define clr clear
using namespace std;
namespace ax_by_c{
typedef long long ll;
const ll mod=1e9+7;
const int N=20;
const int M=N*N;
const int S=(1<<15)+5;
const int PS=(1<<8)+5;
int lb(int x){
	return x&(-x);
}
int pn,pmsk,smsk,cnt[PS][PS][2][2];
void Init_cnt(){
	rep(x,0,1)rep(y,0,1){
		rep(s,0,pmsk){
			rep(i,1,pmsk)cnt[i][s][x][y]=cnt[i][lb(s)][x][y]+cnt[i][s^lb(s)][x][y];
		}
		rep(s,0,pmsk){
			rep(i,1,pmsk)cnt[s][i][x][y]=cnt[lb(s)][i][x][y]+cnt[s^lb(s)][i][x][y];
		}
	}
}
int Q(int S,int T){
	return cnt[S&pmsk][T&pmsk][0][0]+cnt[S>>pn][T&pmsk][1][0]+cnt[S&pmsk][T>>pn][0][1]+cnt[S>>pn][T>>pn][1][1];
}
int n,m,msk;
ll pw2[N*N],f[S],g[S];
void slv(int _csid,int _csi){
	scanf("%d %d",&n,&m);
	msk=(1<<n)-1,pn=(n+1)/2,pmsk=(1<<pn)-1,smsk=(1<<(n-pn))-1;
	rep(_,1,m){
		int u,v;
		scanf("%d %d",&u,&v);
		cnt[(u>pn)?(1<<(u-pn-1)):(1<<(u-1))][(v>pn)?(1<<(v-pn-1)):(1<<(v-1))][u>pn][v>pn]++;
	}
	Init_cnt();
	pw2[0]=1;
	rep(i,1,m)pw2[i]=pw2[i-1]*2%mod;
	rep(s,1,msk){
		f[s]=pw2[Q(s,s)];
		for(int x=(s-1)&s;x;x=(x-1)&s)if(lb(x)==lb(s)){
			g[s]=(g[s]-f[x]*g[s^x]%mod+mod)%mod;
		}
		for(int x=s;x;x=(x-1)&s){
			f[s]=(f[s]-g[x]*pw2[Q(s,s^x)]%mod+mod)%mod;
		}
		g[s]=(g[s]+f[s])%mod;
	}
	printf("%lld\n",f[msk]);
}
void main(){
	int T=1,csid=0;
//	scanf("%d",&csid);
//	scanf("%d",&T);
	rep(i,1,T)slv(csid,i);
}
}
int main(){
	string __name="";
	if(__name!=""){
		freopen((__name+".in").c_str(),"r",stdin);
		freopen((__name+".out").c_str(),"w",stdout);
	}
	ax_by_c::main();
	return 0;
}
```

---

## 作者：lalaouye (赞：0)

我省选赛场上写过 DAG 计数不会这个感觉有点唐了，其实现在看题解前也不会。看这篇题解前建议先学会 DAG 计数。

首先强连通分量有点难刻画，直接计数肯定会算重，直接容斥也不好容斥。我们考虑给强连通分量换一个定义，就是缩点后不只有一个强连通分量！于是我们考虑容斥，先设 $f(S)$ 表示 $S$ 中的点的导出子图是强连通分量的数量，为了像 DAG 一样容斥，我们设 $g(S)$ 表示其中有奇数个强连通分量的个数减去其中有偶数个强连通分量的个数，保证这些强连通分量之间没有边，那么 $f(S)=2^{|E(S)|}-\sum_{T\sub S} g(T)2^{|E(S/T)|}2^{|E(T,S/T)|}$，我们发现少减了一种情况，就是所有强连通分量都没有出度，这个代码中减去 $g(S)$ 即可，当前 $g(S)$ 还没有算 $f(S)$ 的贡献，可以看代码理解。

然后考虑转移 $g(S)$，首先为了避免重复，我们新加的强连通分量需要保证点的最小编号一样。那么 $g(S)=f(S)-\sum_{T\sub S,\text{lowbit}(S)=\text{lowbit}(T)} f(T)g(S/T)$。

还有一件事，$E(T,S/T)$ 直接算是 $\mathcal{O}(n^23^n)$，我们考虑对每个点预处理 $h(u,S)$，表示 $u$ 能直接到达多少个 $S$ 中的点，于是就可以 $\mathcal{O}(n3^n)$ 做了。

代码中变量名可能与定义不同。


```cpp
#include <bits/stdc++.h>
#define int long long
#define rep(i, l, r) for (int i (l); i <= (r); ++ i)
#define rrp(i, l, r) for (int i (r); i >= (l); -- i)
#define eb emplace_back
using namespace std;
#define pii pair <int, int>
#define ls (p << 1)
#define rs (ls | 1)
#define inf 10000000000000000
constexpr int N = 15, M = 1e4, P = 1e9 + 7;
typedef unsigned long long ull;
inline int rd () {
  int x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch)) {
    if (ch == '-') f = -1;
    ch = getchar ();
  }
  while (isdigit (ch)) {
    x = (x << 1) + (x << 3) + (ch ^ 48);
    ch = getchar ();
  }
  return x * f;
}
int qpow (int x, int y) {
  int ret (1);
  for (; y; y >>= 1, x = x * x % P) if (y & 1) ret = ret * x % P;
  return ret;
}
int n, m;
vector <int> e[N];
int cnt[N][1 << N], Cnt[1 << N];
int g[1 << N], f[1 << N];
int pw[N * N];
int32_t main () {
  // freopen ("1.in", "r", stdin);
  // freopen ("1.out", "w", stdout);
  n = rd (), m = rd ();
  rep (i, 1, m) {
    int u (rd () - 1), v (rd () - 1);
    e[u].eb (v);
  }
  m = (1 << n) - 1;
  rep (i, 0, n - 1) {
    rep (j, 0, m) {
      for (auto v : e[i]) {
        if (j >> v & 1) ++ cnt[i][j], Cnt[j] += j >> i & 1;
      }
    }
  }
  f[0] = 1;
  pw[0] = 1;
  rep (i, 1, 224) pw[i] = (pw[i - 1] + pw[i - 1]) % P;
  rep (i, 1, m) {
    f[i] = pw[Cnt[i]];
    int j (i);
    j = (i - 1) & i;
    for (; j; j = (j - 1) & i) {
      if ((i & -i) == (j & -j)) (g[i] -= g[i ^ j] * f[j]) %= P;
    } j = i;
    for (; j; j = (j - 1) & i) {
      int sum (0);
      rep (k, 0, n - 1) if (j >> k & 1) sum += cnt[k][i ^ j];
      (f[i] -= g[j] * pw[Cnt[i ^ j]] % P * pw[sum]) %= P;
    }
    (g[i] += f[i]) %= P;
  } cout << (f[m] + P) % P;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

考虑计算选出一个边集使得缩点后是孤立点的方案数，你发现你要对缩点后形成的一个 DAG 结构计数，考虑通过 $0$ 度点容斥来拆解 DAG 结构，设计 $dp_{S},g_{S}$ 分别表示选出 $S$ 内一个边集使得 $S$ 缩点后形成一个孤立点的方案数与选出 $S$ 内一个边集使得 $S$ 缩点后形成大于等于 $2$ 个孤立点的所有方案带权和，一个方案的权值是 $-1$ 的孤立点个数加 $1$ 次方。

$g_{S}$ 的转移就考虑剥去一个孤立点，因为孤立点之间不区分顺序，所以每次保证剥去的孤立点包含原点集的 lowbit，容易做到 $O(3^n)$。

$dp_{S}$ 的转移考虑计算选出 $S$ 内一个边集使得缩点后不是一个孤立点的方案数，这里有两种情况，一种是缩点后是大于等于 $2$ 个孤立点，这种情况算上容斥系数的贡献就是 $g_{S}$，一种情况是剥去所有 $0$ 度点后还剩下其他点，枚举剥去的 $0$ 度点集合 $T$，我们发现 $T$ 指向 $S \backslash T$ 的边可以任选是否保存，$S \backslash T$ 内的边可以任选是否保存，$T$ 内边的方案数是 $dp_T + g_T$，因为 $T$ 缩点后如果只有孤立点容斥系数也是 $1$。

总时间复杂度 $O(3^n \times n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e9+7;
const int maxv = (1<<15);
int dp[maxv],g[maxv];//孤立点 \sum 若干孤立点*(-1)^{点数+1} 此处至少要是两个孤立点
int In[maxv];
int popcount[maxv];
int _pow[300];
int e[maxv];
int id[maxv];
int n,m;
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    _pow[0]=1;
    for(int i=1;i<=m;i++) _pow[i]=_pow[i-1]*2%mod;
    for(int i=0;i<n;i++) id[1<<i]=i;
    for(int i=1;i<(1<<n);i++) popcount[i]=popcount[i/2]+(i&1);
    for(int i=1;i<=m;i++){
        int a,b;
        cin>>a>>b;
        a--;
        b--;
        In[b]|=(1<<a);
        e[(1<<a)+(1<<b)]++;
    }
    for(int i=0;i<n;i++){
        for(int v=0;v<(1<<n);v++){
            if((1<<i)&v) e[v]+=e[v-(1<<i)];
        }
    }
    for(int v=0;v<(1<<n);v++){
        for(int s=(v-1)&v;s;s=(s-1)&v){
            if((s&(-s))==(v&(-v))) g[v]=(g[v]+dp[s]*((g[v-s]+dp[v-s])%mod)%mod*(mod-1)%mod)%mod;
        }
        int sum=0;
        for(int s=(v-1)&v;s;s=(s-1)&v){
            int f=0;
            for(int t=v;t;t-=(t&(-t))){
                if((t&(-t))&(v-s)){
                    f+=popcount[In[id[t&(-t)]]&s];
                }
            }
            f=_pow[f];
            sum=(sum+(g[s]+dp[s])%mod*f%mod*_pow[e[v-s]]%mod)%mod;
        }
        sum=(sum+g[v])%mod;
        dp[v]=(_pow[e[v]]+mod-sum)%mod;
    }
    cout<<dp[(1<<n)-1]<<'\n';
    return 0;
}
```

---


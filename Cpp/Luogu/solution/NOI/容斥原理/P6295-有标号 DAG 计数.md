# 有标号 DAG 计数

## 题目描述

对 $n$ 个点有标号的有向无环图进行计数，要求：弱连通图（所有的有向边替换为无向边后的图为连通图）。输出答案对 
 $998244353$ 取模的结果。

## 说明/提示

第一个点 $T = 2000$。

第二个点 $T = 100000$。

## 样例 #1

### 输入

```
5```

### 输出

```
1
2
18
446
26430```

# 题解

## 作者：ix35 (赞：21)

## 弱连通有标号 DAG 计数

考虑先求出任意有标号 DAG，然后对 EGF 求一下 $\ln$ 即可得到弱连通的 DAG 数量。

设 $f(i)$ 表示 $i$ 个点的有标号 DAG 数量，则：

$$f(i)=\sum\limits_{j=1}^i \binom{i}{j}\times (-1)^{j+1}\times f(i-j)\times 2^{j(i-j)}$$

其中 $j$ 表示入度为 $0$ 的点的个数（因为 DAG，所以一定存在至少一个入度为 $0$ 的点），剩余的 $i-j$ 个点构成 DAG，这 $j$ 个点到另外 $i-j$ 个点任意选择连不连边，但是注意到这个 $j$ 没有保证恰好，只是保证最少有 $j$ 个入度为 $0$ 的点，所以还需要容斥一下。

然后把 $\binom i j$ 和 $2^{j(i-j)}$ 分别解决掉就可以了。

$\binom i j$ 我们再熟悉不过，求两边的 EGF 即可消去。

另一个 trick 也是常用的：

$$j\times (i-j)=\binom i 2-\binom j 2-\binom {i-j} 2$$

所以:

$$2^{j(i-j)}=\dfrac{2^{\binom i 2}}{2^{\binom j 2}\times 2^{\binom{i-j} 2}}$$

按照和 EGF 相同的策略，我们设两个生成函数：

$$F(x)=\sum\limits_{i=0}^{+\infty}\dfrac{f_i}{i!\times 2^{\binom i 2}}x^i$$

$$G(x)=\sum\limits_{i=0}^{+\infty}\dfrac{(-1)^{i+1}}{i!\times 2^{\binom i 2}}x^i$$

那么改写最上面的式子，就有：

$$F(x)=F(x)G(x)+1$$

最后的 $+1$ 是因为 $f_0=1$。

解得：

$$F(x)=\dfrac{1}{1-G(x)}$$

计算可得 $F(x)$ 的值。

最后考虑弱连通的条件，不弱连通的 DAG 肯定由若干个连通分量组合，设弱连通 DAG 的 EGF 为 $H(x)$，那么按照 EGF 的组合意义：

$$F'(x)=\exp(H(x))$$

其中 $F'(x)$ 是 $f_i$ 的 EGF。

所以：

$$H(x)=\ln(F'(x))$$

总的过程是一次求逆和一次 $\ln$，时间复杂度 $O(n\log n)$。

程序里 qpow 被我吃了。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=400010,P=998244353;
int n,cur,lim,l,g,invg,r[MAXN],fac[MAXN],inv[MAXN];
int a[MAXN],b[MAXN],c[MAXN],d[MAXN],e[MAXN],h[MAXN],tmp[MAXN];
void deri (int n,int a[],int b[]) {
	for (int i=0;i<=n-2;i++) {b[i]=(1ll*a[i+1]*(i+1))%P;}
	b[n-1]=0;
	return;
}
void itr (int n,int a[],int b[]) {
	for (int i=n-1;i>=1;i--) {b[i]=(1ll*a[i-1]*qpow(i,P-2))%P;}
	b[0]=0;
	return;
}
void ntt (int a[],int lim,int type) {
	for (int i=0;i<lim;i++) {
		if (r[i]>i) {swap(a[i],a[r[i]]);}
	}
	for (int i=1;i<lim;i<<=1) {
		int wn=qpow(type==1?g:invg,(P-1)/(i<<1));
		for (int j=0;j<lim;j+=(i<<1)) {
			int wnk=1;
			for (int k=0;k<i;k++) {
				int x=a[j+k],y=(1ll*wnk*a[j+k+i])%P;
				a[j+k]=(x+y)%P,a[j+k+i]=(x-y+P)%P;
				wnk=(1ll*wnk*wn)%P;
			}
		}
	}
	return;
}
void getinv (int n,int a[],int b[]) {
	if (n==1) {b[0]=qpow(a[0],P-2);return;}
	getinv((n+1)>>1,a,b);
	lim=1,l=0;
	while (lim<(n<<1)) {lim<<=1,l++;}
	for (int i=0;i<lim;i++) {r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));}
	for (int i=0;i<n;i++) {tmp[i]=a[i];}
	for (int i=n;i<lim;i++) {tmp[i]=0;}
	ntt(tmp,lim,1),ntt(b,lim,1);
	for (int i=0;i<lim;i++) {b[i]=(1ll*((2ll-(1ll*tmp[i]*b[i])%P+P)%P)*b[i])%P;}
	ntt(b,lim,-1);
	int inv=qpow(lim,P-2);
	for (int i=0;i<lim;i++) {b[i]=(1ll*b[i]*inv)%P;}
	for (int i=n;i<lim;i++) {b[i]=0;}
	return;
}
void mul (int lim,int c[],int d[],int e[]) {
	for (int i=0;i<lim;i++) {r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));}
	ntt(c,lim,1),ntt(d,lim,1);
	for (int i=0;i<lim;i++) {e[i]=(1ll*c[i]*d[i])%P;}
	ntt(e,lim,-1);
}
void getln (int n,int a[],int b[]) {
	deri(n,a,c);
	getinv(n,a,d);
	lim=1,l=0;
	while (lim<(n<<1)) {lim<<=1,l++;}
	mul(lim,c,d,e);
	int inv=qpow(lim,P-2);
	for (int i=0;i<lim;i++) {e[i]=(1ll*e[i]*inv)%P;}
	for (int i=n;i<lim;i++) {e[i]=0;}
	itr(n,e,b);
	return;
}
int main () {
	scanf("%d",&n);
	fac[0]=inv[0]=1;
	for (int i=1;i<=n;i++) {fac[i]=(1ll*fac[i-1]*i)%P;}
	inv[n]=qpow(fac[n],P-2);
	for (int i=n-1;i>=1;i--) {inv[i]=(1ll*inv[i+1]*(i+1))%P;}
	for (int i=1;i<=n;i++) {
		a[i]=(1ll*inv[i]*qpow(qpow(2,(1ll*i*(i-1)/2)),P-2))%P;
		if (i&1) {a[i]=(P-a[i])%P;}
	}
	a[0]=1;
	g=3,invg=qpow(3,P-2);
	getinv(n+1,a,b);
	for (int i=0;i<=n;i++) {b[i]=(1ll*((1ll*b[i]*fac[i])%P)*qpow(2,(1ll*i*(i-1)/2)))%P;}
	for (int i=0;i<=n;i++) {b[i]=(1ll*b[i]*inv[i])%P;}
	getln(n+1,b,h);
	for (int i=1;i<=n;i++) {
		printf("%d\n",(1ll*h[i]*fac[i])%P);
	}
	return 0;
}
```







---

## 作者：Karry5307 (赞：13)

### 题意

求 $n$ 个点有标号弱连通 $\texttt{DAG}$ 的数量。

$\texttt{Data Range:}1\leq n\leq 10^5$

### 题解

套路题。

先忽略弱连通这个东西，设 $g_i$ 为忽略连通性的答案，那么我们枚举零入度点的数量 $j$，前 $j$ 个点向后面 $i-j$ 个点随意连边，方案为 $2^{j(i-j)}$，后面的点构成 $\texttt{DAG}$。

但是这样不保证入度为 $0$ 的点恰好有这么多，所以要容斥，那么有

$$g_i=\sum\limits_{j=1}^{i}(-1)^{j-1}\binom{i}{j}2^{j(i-j)}f_{i-j}$$

顺手用 $\texttt{Bluestein}$ 的第一个拆 $ij$ 的方法（也就是拆成平方），得到

$$g_i=\sum\limits_{j=1}^{i}(-1)^{j-1}\frac{i!(\sqrt{2})^{i^2}}{j!(\sqrt{2})^{j^2}(i-j)!(\sqrt{2})^{(i-j)^2}}f_{i-j}$$

幸运的是 $\sqrt{2}$ 在模 $998244353$ 下能成立，于是枚举一下有

$$\sqrt{2}\equiv 116195171\pmod{998244353}$$

用另外一个其实也是可以的，我这里取了小的哪一个。

然后我们可以设

$$G(x)=\sum\limits_{i=0}^{n}\frac{g_i}{i!(\sqrt{2})^{i^2}}x^i$$

和

$$H(x)=\sum\limits_{i=1}^{n}\frac{(-1)^{i-1}}{i!(\sqrt{2})^{i^2}}x^i$$

于是有 $G(x)=G(x)H(x)+1$，也即 $G(x)=\frac{1}{1-H(x)}$

考虑连通性的问题，这个就是城市规划那题的套路。

如果不懂可以去看我有标号荒漠计数的题解。

设 $F(x)$ 为答案的 $\texttt{EGF}$ 以及 $G_0(x)$ 为 $G(x)$ 对应的 $\texttt{EGF}$，那么有

$$F(x)=\ln G(x)$$

然后就做完了，换个快点的板子大概可以更快？

现在我们来证明对于任意普遍的 $\texttt{NTT}$ 模数这个做法都成立。

注意到决定这个做法成立与否的地方是 $2$ 是不是二次剩余。

对于质数 $p$，我们有这样一个引理（这里括号是 $\texttt{Legendre}$ 符号）

$$\left(\frac{2}{p}\right)=(-1)^{\frac{(p^2-1)}{8}}$$

根据二次剩余中的高斯引理，若 $s$ 是整数 $2,4,6,\cdots p-1$ 的最小正剩余中大于 $\frac{p}{2}$ 的个数，则有

$$\left(\frac{2}{p}\right)=(-1)^{s}$$

注意到这些整数均小于 $p$，所以为了求出这些整数的大于 $\frac{p}{2}$ 的最小正剩余的个数，我们只要计算出这些大于 $\frac{p}{2}$ 的整数的个数。

注意到 $s=\frac{p-1}{2}-\left\lfloor\frac{p}{4}\right\rfloor$，那么只需证明

$$\frac{p-1}{2}-\left\lfloor\frac{p}{4}\right\rfloor\equiv \frac{p^2-1}{8}\pmod 2$$

注意到如果对 $p$ 成立那么它对 $p+8$ 也成立，然而 $p=1,3,5,7$ 时均成立，所以他对任何奇整数 $p$ 成立。

因此引理就成立了。

然后 $\texttt{NTT}$ 模数能够写成 $p\times 2^k+1$ 的形式，能做长度为 $2^k$ 的 $\texttt{NTT}$

但是一般出题人为了能把 $n$ 出到 $10^5$，那么 $k\geq 17$。

所以 $p\times 2^{k}+1\equiv 8(p\times 2^{k-3})+1\equiv 1\pmod 8$

根据引理得到 $2$ 在正常的 $\texttt{NTT}$ 模数下有二次剩余，所以这个做法就成立了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=262151,MOD=998244353,G=3,INVG=332748118,SQRT2=116195171;
ll fd;
ll f[MAXN],g[MAXN],h[MAXN],rev[MAXN],fact[MAXN],finv[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
    ll res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=1ll*res*base%MOD;
        }
        base=1ll*base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void setup(ll cnt)
{
	fact[0]=fact[1]=finv[0]=1;
	for(register int i=1;i<=cnt;i++)
	{
		fact[i]=(li)fact[i-1]*i%MOD;
	}
	finv[cnt]=qpow(fact[cnt],MOD-2);
	for(register int i=cnt-1;i;i--)
	{
		finv[i]=(li)finv[i+1]*(i+1)%MOD;
	}
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    ll cur=0,res=0,omg=0;
    for(register int i=0;i<cnt;i++)
    {
        if(i<rev[i])
        {
            swap(cp[i],cp[rev[i]]);
        }
    }
    for(register int i=2;i<=cnt;i<<=1)
    {
        cur=i>>1,res=qpow(inv==1?G:INVG,(MOD-1)/i);
        for(register ll *p=cp;p!=cp+cnt;p+=i)
        {
            omg=1;
            for(register int j=0;j<cur;j++)
            {
                ll t=1ll*omg*p[j+cur]%MOD,t2=p[j];
                p[j+cur]=(t2-t+MOD)%MOD,p[j]=(t2+t)%MOD;
                omg=1ll*omg*res%MOD;
            }
        }
    }
    if(inv==-1)
    {
        ll invl=qpow(cnt,MOD-2);
        for(register int i=0;i<=cnt;i++)
        {
            cp[i]=1ll*cp[i]*invl%MOD;
        }
    }
}
inline void deriv(ll fd,ll *f,ll *res)
{
    for(register int i=1;i<fd;i++)
    {
        res[i-1]=1ll*f[i]*i%MOD;
    }
    res[fd-1]=0;
}
inline void integ(ll fd,ll *f,ll *res)
{
    for(register int i=1;i<fd;i++)
    {
        res[i]=1ll*f[i-1]*qpow(i,MOD-2)%MOD;
    }
    res[0]=0;
}
inline void inv(ll fd,ll *f,ll *res)
{
    static ll tmp[MAXN];
    if(fd==1)
    {
        res[0]=qpow(f[0],MOD-2);
        return;
    }
    inv((fd+1)>>1,f,res);
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
        tmp[i]=i<fd?f[i]:0;
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmp,cnt,1),NTT(res,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        res[i]=1ll*(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD;
    }
    NTT(res,cnt,-1);
    for(register int i=fd;i<cnt;i++)
    {
        res[i]=tmp[i]=0;
    }
}
inline void ln(ll fd,ll *f,ll *res)
{
    static ll pinv[MAXN],der[MAXN];
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    inv(fd,f,pinv),deriv(fd,f,der);
    for(register int i=0;i<cnt;i++)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(pinv,cnt,1),NTT(der,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        der[i]=1ll*der[i]*pinv[i]%MOD;
    }
    NTT(der,cnt,-1),integ(fd,der,res);
    for(register int i=0;i<cnt;i++)
    {
        der[i]=pinv[i]=0;
    }
}
int main()
{
	setup(100000),fd=read()+1;
    for(register int i=1;i<fd;i++)
    {
    	h[i]=(li)fact[i]*qpow(SQRT2,(li)i*i%(MOD-1))%MOD;
    	h[i]=qpow(h[i],MOD-2),h[i]=i&1?MOD-h[i]:h[i];
	}
	h[0]=1,inv(fd,h,g);
	for(register int i=0;i<fd;i++)
	{
		g[i]=(li)g[i]*fact[i]%MOD*qpow(SQRT2,(li)i*i%(MOD-1))%MOD*finv[i]%MOD;
	}
	ln(fd,g,f);
	for(register int i=1;i<fd;i++)
	{
		printf("%d\n",(li)f[i]*fact[i]%MOD);
	}
}
```

---

## 作者：too_later (赞：9)

先来看个弱化版的题目：

[BZOJ2863](https://darkbzoj.tk/problem/2863)

就是这道题的题目，只是不需要弱联通，还有数据范围在 3000。

怎么做？

有向无环图有一个经典的处理方式，就是拓扑排序，每次找出入度为 $0$ 的点。

对于这些入度为 $0$ 的点，删掉仍然还是一个 DAG。因此我们可以枚举入度为零个数**至少**为 $i$ 的点的数量，我们可以得出：

$$f_i=\sum\limits_{j=1}^n (-1)^{j+1}f_{i-j}\times 2^{j(i-j)}\times \dbinom ij$$

其中 $2^{j(i-j)}$ 是因为入度为 $0$ 可以和其他点任意连边（注意是至少），$(-1)^{j+1}$ 是因为至少，是容斥。$\dbinom nm$ 就是选择，我觉得这里问题都不大。

然后就是，这个式子要 $O(nlogn)$ 处理出来。

这里赠送一个技巧：$ab=\dbinom {a+b}2-\dbinom a2-\dbinom b2$。证明很简单。

这个有什么用呢？就是把 $a\times b$ 分成 $a+b,a,b$ 有关的式子，特别是在幂中实用，就是需要把乘法拆开的时候。

那么有：

$$f_i=\sum\limits_{j=1}^n(-1)^{j+1}f_{i-j}\times \dfrac{2^{\binom i2}}{2^\binom j22^\binom {i-j}2}\times \dfrac{i!}{j!(i-j)!}$$

将跟 $i,j,i-j$ 有关的整理好，得：

$$\dfrac{f_i}{2^{\binom i2}i!}=\sum\limits_{j=1}^n\dfrac{(-1)^{j+1}}{j!2^\binom{j}{2}}\times \dfrac{f_{i-j}}{2^{\binom {i-j}2}(i-j)!}$$

这不久好起来了，这不就好起来了？

令生成函数 $F(x)=\sum\limits_{i=0}^{\infty}\dfrac{f_i}{2^{\binom i2}i!}x^i,G(x)=\sum\limits_{i=0}^{\infty}\dfrac{(-1)^{i+1}}{i!2^\binom{i}{2}}$。

那么有：$F(x)=F(x)G(x)+1$。

等一下，为什么是这样的，理论上来说多项式乘法不应该下标从 $0$ 开始的吗？

注意：当 $j=0$ 的时候，$f_{i-j}=f_i$ 这一项应该不存在，那么就特殊处理 $g_0=0$ 以抵消这一项，再用多项式乘法，这样就对了。

还有为什么加一，因为 $f$ 的通项公式是建立在 $i\ge 1$ 的情况下的，$f_0=1$ 这个也是特殊情况，常数项加上去。

那么就可以解了，解得：$F(x)=\dfrac{1}{1-G(x)}$。

~~你以为这就结束了那你就错了~~，还有一个任务没完成，$F(x)$ 是可以不弱联通的，但是题目要求必须弱联通。

其实这个很好想到（~~不就是城市规划吗~~），一般图一定是弱连通图的 $exp$，因为你可以把图分成若干个点集，然后这些点集的弱连通图方案数的乘积。

这不就是裸的 $EGF$ 意义上的 $e^x$ 吗？分成若干点集弱连通图方案乘积？那么 $F(x)=e^{H(x)},H(x)=Ln(F(x))$，注意一定要先转 $EGF$ 再求 $Ln$。

时间复杂度 $O(nlogn)$。

### Code:

```cpp
#include<bits/stdc++.h>
#define I inline
#define RI register int
#define rep(i,a,b) for(RI i=a;i<=b;++i)
#define dow(i,a,b) for(RI i=a;i>=b;--i)
using namespace std;
const int N=4e5+5,mo=998244353;
I int add(int a,int b){ return a+b>=mo?a+b-mo:a+b; }
I int sub(int a,int b){ return a-b<0?a-b+mo:a-b; }
I int mul(int a,int b){ return (long long)a*b%mo; }
I int fast(int a,int b=mo-2){ RI res=1;while(b) b&1&&(res=mul(res,a)),a=mul(a,a),b>>=1; return res; }
int n,frac[N],ifac[N],r[N],a[N],b[N],c[N],d[N],e[N],f[N];
I void NTT(int a[],int lim,int op){
	rep(i,1,lim-1) if(r[i]>i) swap(a[i],a[r[i]]);
	for(RI i=1;i<lim;i<<=1){
		RI now=fast(op==1?3:332748118,(mo-1)/(i<<1));
		for(RI j=0;j<lim;j+=(i<<1)){
			RI res=1;
			rep(k,0,i-1){
				RI x=a[j+k],y=mul(res,a[j+k+i]);
				a[j+k]=add(x,y),a[j+k+i]=sub(x,y),res=mul(res,now);
			}
		}
	}
	RI now=fast(lim);
	if(op==-1) rep(i,0,lim-1) a[i]=mul(a[i],now);
}
I void Inv(int a[],int b[],int n){
	if(n==1) return b[0]=fast(a[0]),void(); Inv(a,b,n+1>>1);
	RI lim=1,cnt=0;while(lim<=(n<<1)) lim<<=1,++cnt;rep(i,1,lim-1) r[i]=r[i>>1]>>1|(i&1)<<cnt-1;
	rep(i,0,n-1) c[i]=a[i];rep(i,n,lim-1) c[i]=0;NTT(c,lim,1),NTT(b,lim,1);
	rep(i,0,lim-1) b[i]=mul(b[i],sub(2,mul(c[i],b[i])));NTT(b,lim,-1);rep(i,n,lim-1) b[i]=0;
}
I void Ln(int a[],int b[],int n){
	rep(i,0,n-2) d[i]=mul(a[i+1],i+1);Inv(a,f,n);
	RI lim=1,cnt=0;while(lim<=(n<<1)) lim<<=1,++cnt;rep(i,1,lim-1) r[i]=r[i>>1]>>1|(i&1)<<cnt-1;
	NTT(d,lim,1),NTT(f,lim,1);rep(i,0,lim-1) b[i]=mul(d[i],f[i]);NTT(b,lim,-1);
	dow(i,n-1,1) b[i]=mul(b[i-1],fast(i));b[0]=0;
}
int main(){
	scanf("%d",&n),frac[0]=1;rep(i,1,n) frac[i]=mul(frac[i-1],i);ifac[n]=fast(frac[n]);dow(i,n-1,0) ifac[i]=mul(ifac[i+1],i+1);
	a[0]=1;rep(i,1,n) a[i]=mul(fast(fast(2,1ll*i*(i-1)/2%998244352)),ifac[i]),i&1&&(a[i]=mo-a[i]);
	Inv(a,e,n+1);rep(i,1,n) e[i]=mul(e[i],fast(2,1ll*i*(i-1)/2%998244352));Ln(e,b,n+1);
	rep(i,1,n) printf("%d\n",mul(frac[i],b[i]));return 0;
}
```

---

## 作者：AzusaCat (赞：7)

对每个 $1\leqslant i\leqslant n$ 求 $i$ 个点的弱连通有标号有向无环图数目，$n\leqslant 10^5$。

首先，根据 exp 的组合意义，即有标号对象组成的集合个数，如果我们求出了不一定弱连通的 DAG 数目的 EGF $G(x)$，设弱连通的 DAG 数目的 EGF 为 $F(x)$，则
$$
F(x)=\ln(G(x))
$$
显然一张 DAG 一定有至少一个入度为 $0$ 的点，所以我们尝试枚举度数为 $0$ 的点的个数，然后我们计算度数为 $0$ 的点和其它点的连边情况，然后就递归到了子问题，这样你可能会写出以下式子
$$
g_i=\sum\limits_{j=1}^i\binom{i}{j}2^{j(i-j)}g_{i-j}
$$
但是写个暴力试一下发现是错的，为什么？因为剩下的点里可能也有入度为 $0$ 的点，所以会计重。

我们发现，我们实际上不是枚举入度为 $0$ 的点，而是在钦定入度为 $0$ 的点，我们设 $h_{i,j}$ 为$i$ 个点的图钦定 $j$ 个入度为 $0$ 个点的方案数，$c_{i,j}$ 为恰好 $j$ 个入度为 $0$ 的点的方案数，那么有（这个式子都不知道见了多少遍了）：
$$
h_{i,j}=\sum\limits_{k=j}^i \binom{k}{j}c_{i,k}
$$
由二项式反演：
$$
c_{i,j}=\sum\limits_{k=j}^i \binom{k}{j}(-1)^{k-j}h_{i,k}
$$
同时类似刚才那个假的式子，我们有 $h_{i,j}=\binom{i}{j}2^{j(i-j)}g_{i-j} $，有 $g_i=\sum\limits_{j=1}^i c_{i,j}$。

然后我们把能带入的都带入
$$
\begin{aligned}
g_n&=\sum\limits_{i=1}^nc_{n,i}\\
&=\sum\limits_{i=1}^n\sum\limits_{j=i}^n\binom{j}{i}(-1)^{j-i}h_{i,j}\\
&=\sum\limits_{i=1}^n\sum\limits_{j=i}^n\binom{j}{i}(-1)^{j-i}\binom{n}{j}2^{j(n-j)}g_{n-j}\\
&=\sum\limits_{j=1}^n\binom{n}{j}2^{j(n-j)}g_{n-j}\sum\limits_{i=1}^{j}\binom{j}{i}(-1)^{i-j}\\
&=\sum\limits_{j=1}^n\binom{n}{j}2^{j(n-j)}g_{n-j}(0-(-1)^j)\\
&=\sum\limits_{j=1}^n\binom{n}{j}(-1)^{j+1}2^{j(n-j)}g_{n-j}
\end{aligned}
$$

然后注意到有个 $j(n-j)$，我们采用和 Bluestein 一样的套路，把 $j(n-j)$ 拆成组合数的和。
$$
j(n-j)=\binom{n}{2}-\binom{j}{2}-\binom{n-j}{2}
$$

如果记不住可以考虑组合意义：等价于有两堆石子，各有 $j$ 和 $n-j$ 个，然后从两堆石子各取一个的方案数等于任取的方案数减去同时在一堆石子里取的方案数。

这里没有用平方式的那个，因为不一定存在 $2$ 的二次剩余（虽然 AKrry 证明了如果是 NTT 模数都存在）。

这样就是卷积形式了
$$
\begin{aligned}
g_n=\sum\limits_{j=1}^n\binom{n}{j}(-1)^{j+1}2^{j(n-j)}g_{n-j}\\
\frac{g_n}{n!2^{\binom{n}{2}}}=\sum\limits_{j=1}^n\frac{(-1)^{j+1}}{2^{\binom{j}{2}}j!}\frac{g^{n-j}}{2^\binom{n-j}{2}(n-j)!}
\end{aligned}
$$
设
$$\begin{aligned}
F(x)=\sum\limits_{i=1}^\infty \frac{(-1)^{i+1}}{2^{\binom{i}{2}}i!}x^i\\
G(x)=\sum\limits_{i=0}^\infty \frac{g_i}{2^{\binom{i}{2}}i!}x^i
\end{aligned}
$$

则 $G(x)=F(x)G(x)+1$，故 $G(x)=\frac{1}{1-F(x)}$。这样就可以求出 $g$，然后再做一遍 $\ln$ 就好了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int const inv2=499122177;
namespace polynomials
{
    int const p=998244353,g=3;
    int const N=(1<<19)+1;
    int w[N],iv[N],r[N],last;
    typedef vector<int> vec;
    int mod(int x){return x>=p?x-p:x;}
    int pw(int x,int y)
    {
        int res=1;
        while(y)
        {
            if(y&1)res=1ll*res*x%p;
            x=1ll*x*x%p;
            y>>=1;
        }
        return res;
    }
    void init(int n)
    {
        int lim=1;
        while(lim<n)lim<<=1;
        iv[1]=1;
        for(int i=2;i<=lim;i++)iv[i]=mod(p-1ll*(p/i)*iv[p%i]%p);
        for(int i=1;i<lim;i<<=1)
        {
            int wn=pw(g,(p-1)/(i<<1));
            for(int j=0,ww=1;j<i;j++,ww=1ll*ww*wn%p)w[i+j]=ww;
        }
    }
    void ntt(vec &f,int n,int op)
    {
        f.resize(n);
        for(int i=1;i<n;i++)r[i]=(r[i>>1]>>1)|((i&1)?(n>>1):0);
        for(int i=1;i<n;i++)if(i<r[i])swap(f[i],f[r[i]]);
        for(int i=1;i<n;i<<=1)
        for(int j=0;j<n;j+=i<<1)
            for(int k=0;k<i;k++)
            {
                int x=f[j+k],y=1ll*f[i+j+k]*w[i+k]%p;
                f[j+k]=mod(x+y);f[i+j+k]=mod(x-y+p);
            }
        if(op==-1)
        {
            reverse(&f[1],&f[n]);
            for(int i=0;i<n;i++)f[i]=1ll*f[i]*iv[n]%p;
        }
    }
    void getinv(vec f,vec &g,int n)
    {
        static vec x;
        g.resize(n);
        if(n==1){g[0]=pw(f[0],p-2);return;}
        getinv(f,g,(n+1)>>1);
        int lim=1;
        while(lim<(n<<1))lim<<=1;
        x.resize(lim);
        for(int i=0;i<n;i++)x[i]=f[i];
        for(int i=n;i<lim;i++)x[i]=0;
        g.resize(lim);
        ntt(x,lim,1),ntt(g,lim,1);
        for(int i=0;i<lim;i++)g[i]=1ll*g[i]*(2-1ll*g[i]*x[i]%p+p)%p;
        ntt(g,lim,-1);
        g.resize(n);
    }
    void getln(vec f,vec &g,int n)
    {
        static vec x;
        getinv(f,x,n);
        for(int i=0;i<n-1;i++)f[i]=1ll*f[i+1]*(i+1)%p;
        f[n-1]=0;
        int lim=1;
        while(lim<((n<<1)-1))lim<<=1;
        ntt(f,lim,1),ntt(x,lim,1);
        for(int i=0;i<lim;i++)x[i]=1ll*x[i]*f[i]%p;
        ntt(x,lim,-1);
        g.resize(n);
        g[0]=0;
        for(int i=1;i<n;i++)g[i]=1ll*x[i-1]*iv[i]%p;
    }
}
using namespace polynomials;
int fac[200005],inv[200005];
vec f,G,ans;
int main()
{
    int n;
    scanf("%d",&n);
    n++;
    init(n<<1);
    fac[0]=inv[0]=1;
    for(int i=1;i<n;i++)fac[i]=1ll*fac[i-1]*i%p;
    inv[n-1]=pw(fac[n-1],p-2);
    for(int i=n-2;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%p;
    f.resize(n);
    for(int i=1;i<n;i++)
        f[i]=1ll*(((i+1)&1)?(p-1):1)*inv[i]%p*pw(inv2,(1ll*i*(i-1)>>1)%(p-1))%p;
    for(int i=0;i<n;i++)f[i]=mod(p-f[i]);
    f[0]=mod(f[0]+1);
    getinv(f,G,n);
    for(int i=0;i<n;i++)G[i]=1ll*G[i]*pw(2,(1ll*i*(i-1)>>1)%(p-1))%p;
    getln(G,ans,n);
    for(int i=1;i<n;i++)printf("%d\n",1ll*ans[i]*fac[i]%p);
    return 0;
}
```



---

## 作者：syzf2222 (赞：6)

此题的代数部分是简单的，重点讲下容斥（虽然大部分题解都是一笔带过但我还是不理解）。

设 $F_i$ 为有 $i$ 个点的不要求弱联通的 DAG 的个数。有递推式：

$$
F_i=\sum_{j=1}^i \binom{i}{j}(-1)^{j+1}2^{j(i-j)}F_{i-j}
$$

想法是按照拓扑序分层，每次剥开所有入度为零的点。

考虑一个 DAG，设没有入度的集合为 $S$，那么在枚举到所有 $T\subseteq S$ 的时候都会把这个 DAG 计算到，而我们希望只算一次。也就是我们希望给每个 $T$ 分配一个容斥系数 $f$，使得 $\sum\limits_{T\subseteq S} f(T)=1$。

有著名的 $(1-1)^{n}=0$ 这个事情，故可以构造得 $f(T)=(-1)^{|T|+1}$。

后面的代数变幻相信难不住来做着题的人，而且其他题解都有详细讲，不再赘述。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
const int mod=998244353;
const int G=3;
const int iG=(mod+1)/3;
#define inf 1e9
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
inline int ksm(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;y>>=1;
	}return res;
}
int n,m,fac[maxn],ifc[maxn],inv[maxn];
inline int com(int x,int y){
	if(x<0||y<0||x<y)return 0;
	return 1ll*fac[x]*ifc[y]%mod*ifc[x-y]%mod;
}
int tr[maxn],c[maxn];
inline void ntt(int *f,int len,int flag){
    for(int i=0;i<len;i++)
        if(i<tr[i])swap(f[i],f[tr[i]]);
    for(int i=2;i<=len;i<<=1){
        int w=ksm(flag?G:iG,(mod-1)/i);
        for(int j=0,p=i>>1;j<len;j+=i){
            int wi=1;
            for(int k=j;k<j+p;k++){
                int tt=1ll*wi*f[k+p]%mod;
                f[k+p]=(f[k]-tt+mod)%mod;
                f[k]=(f[k]+tt)%mod;
                wi=1ll*wi*w%mod;
            }
        }
    }
    if(flag==0){
        int iv=ksm(len,mod-2);
        for(int i=0;i<len;i++)
            f[i]=1ll*f[i]*iv%mod;
    }
}
inline void workinv(int deg,int *a,int *b){
	if(deg==1)return void(b[0]=ksm(a[0],mod-2));
	workinv((deg+1)>>1,a,b);
	int len=1;for(;len<=(deg<<1);len<<=1);
	for(int i=0;i<len;i++)
		tr[i]=(tr[i>>1]>>1)|((i&1)?len>>1:0);
	for(int i=0;i<deg;i++)c[i]=a[i];
	for(int i=deg;i<len;i++)c[i]=0;
	ntt(c,len,1);ntt(b,len,1);
	for(int i=0;i<len;i++)
		b[i]=1ll*b[i]*(2-1ll*b[i]*c[i]%mod+mod)%mod;
	ntt(b,len,0);
	for(int i=deg;i<len;i++)b[i]=0;
}
inline void dif(int *a,int *b,int len){
	for(int i=0;i<len;i++)
		a[i]=1ll*b[i+1]*(i+1)%mod;
}
inline void iit(int *a,int *b,int len){
	a[0]=0;
	for(int i=1;i<len;i++)
		a[i]=1ll*b[i-1]*inv[i]%mod;
}
inline void mul(int *a,int *b,int n){
	int len=1;for(;len<=(n<<1);len<<=1);
	for(int i=0;i<len;i++)
		tr[i]=(tr[i>>1]>>1)|((i&1)?len>>1:0);
	ntt(a,len,1);ntt(b,len,1);
	for(int i=0;i<len;i++)a[i]=1ll*a[i]*b[i]%mod;
	ntt(a,len,0);
}
int f[maxn],b[maxn];
inline void ln(int *a,int deg){
	dif(f,a,deg);workinv(deg,a,b);
	mul(f,b,deg);iit(a,f,deg);
}
int pw2[maxn],H[maxn],F[maxn],Ans[maxn];
int main(){
	n=read();fac[0]=ifc[0]=inv[1]=H[0]=1;
	int len=1;for(;len<=n+n;len<<=1);
	for(int i=1;i<=len;i++)fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=2;i<=len;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(int i=1;i<=len;i++)ifc[i]=1ll*ifc[i-1]*inv[i]%mod;
	for(int i=1;i<=n;i++){
		pw2[i]=ksm(2,1ll*i*(i-1)/2%(mod-1));
		if(i&1)H[i]=mod-1ll*ifc[i]*ksm(pw2[i],mod-2)%mod;
		else H[i]=1ll*ifc[i]*ksm(pw2[i],mod-2)%mod;
	}workinv(n+1,H,F);
	for(int i=1;i<=n;i++)F[i]=1ll*F[i]*pw2[i]%mod;
	ln(F,n+1);for(int i=1;i<=n;i++)
		printf("%d\n",1ll*F[i]*fac[i]%mod);
	return 0;
}
```

深深地感到自己的弱小。

---

## 作者：ღꦿ࿐ (赞：4)

在[我的博客](https://www.cnblogs.com/Dreamerkk/p/17147952.html)查看。
## 带标号弱连通 DAG 计数

前言:

前段时间做到了一个[无向图边定向的题](https://www.luogu.com.cn/problem/P6846)，就一直没搞懂其中的容斥，今天终于弄懂了。

---

题意：对弱连通带标号的简单 DAG 计数，$n\leq10^5$。

“弱连通”这个限制可以表示为“集和”，任意 DAG 可以视作“集族”，所以二者的 EGF 满足关系 $\operatorname{Exp}(g(x))=f(x)$，求出任意 DAG 计数再做 $\operatorname{ln}$ 即可，现在考虑如何求出任意 DAG 计数。

考虑 dp，令 $f_x$ 表示 $x$ 个点的 DAG 的数量。

考虑将 DAG 分层，然后按照拓扑序加点，新加入的一些点没有后继，并且让原本的点向这些点连边。

但是考虑到原本的某些点也没有后继，即分层后相邻的若干层其实可以合并成一层，所以考虑容斥。

令钦定 $i$ 个点这层的点的方案数为 $s_i$，恰好 $i$ 个点的方案数为 $t_i$，则有 $s_i=\sum _{j\geq i} \binom{j}{i}t_j$。

有二项式反演 

$$
t_i=\sum _{j\geq i} \binom{j}{i}(-1)^{j-i}s_j
$$

其中 

$$
s_i=\binom{n}{i}\times2^{i(n-i)}\times f_{n-i}
$$

我们写出原本的式子：

$$
\begin{aligned}
f_i &=\sum_{j=1}^i  t_j\\
&=\sum _{j=1}^i  \sum_{k\geq j} \binom{k}{j}(-1)^{k-j}\binom{i}{k}2^{i(i-k)} f_{i-k}
\end{aligned}
$$

因为转移来的项和 $k$ 相关所以把求和换位，和 $k$ 相关的放到前面：

$$
\begin{aligned}
f_i &=\sum_{k=1} ^i  \binom{i}{k}2^{i(i-k)} f_{i-k} \sum _{j=1}^k  \binom{k}{j}(-1)^{k-j}
\end{aligned}
$$

把后面那坨补上一个 $(-1)^k$ 即可使用二项式定理得到 $0$，所以

$$
f_i=\sum_{k=1}^i\binom{i}{k} 2^{k(i-k)} f_{i-k} \times(-1)^{k+1}
$$

感性地理解可以将含 $i$ 个点层看作拥有 $i$ 个属性的容斥。

这个东西显然可以分治 NTT ，把 $2$ 的指数拆成二次剩余或者组合数作差就可以做到。

考虑优化，将这个式子变形一下，可以得到：

$$
\frac {f_i}{i!2^{\binom{i}{2}}}=\sum_{k=1}^i \frac { f_{i-k} }{(i-k)!2^\binom{i-k} {2}} \times \frac {(-1)^{k+1}}{2^{\binom k 2}k!}
$$

所以将 $\dfrac {f_i}{i!2^{\binom{i}{2}}}$ 看作有序集族数，$\dfrac {(-1)^{k+1}}{2^{\binom k 2}k!}$ 看作集合数，多项式求逆即可做到 $O(n\log n)$。

---

## 作者：APJifengc (赞：3)

首先考虑朴素 DP：设 $f_i$ 为 $i$ 个点的 DAG 数量。

我们考虑按照拓扑序来计算这个东西，即每次删去入度为 $0$ 的点来计算。

枚举入度为 $0$ 的点数 $j$，那么将这 $j$ 个点向剩下的点连边的方案数为 $2^{j(i-j)}$。

但是注意这时候仅钦定了这 $j$ 个点度数为 $0$，而剩余的 $i-j$ 个点中可能还有度数为 $0$ 的点，也就是这里是至少有 $j$ 个入度为 $0$ 的点。

考虑二项式反演：设 $p_{i,j}$ 为 $i$ 个点中至少有 $j$ 个点入度为 $0$ 的方案数，$q_{i,j}$ 为 $i$ 个点中恰好有 $j$ 个点入度为 $0$ 的方案数，那么 $f_i=\sum_{j=1}^iq_{i,j}$。

有：
$$
\begin{aligned}
p_{i,j}&=\sum_{k=j}^i\binom{k}{j}q_{i,k}\\
q_{i,j}&=\sum_{k=j}^i(-1)^{k-j}\binom{k}{j}p_{i,k}\\
\end{aligned}
$$
根据前面可得：
$$
p_{i,k}=\binom{i}{k}2^{k(i-k)}f_{i-k}
$$
那么：
$$
\begin{aligned}
f_i&=\sum_{j=1}^iq_{i,j}\\
&=\sum_{j=1}^i\sum_{k=j}^i(-1)^{k-j}\binom{k}{j}\binom{i}{k}2^{k(i-k)}f_{i-k}\\
&=\sum_{k=1}^i\binom{i}{k}2^{k(i-k)}f_{i-k}\sum_{j=1}^k(-1)^{k-j}\binom{k}{j}\\
&=\sum_{k=1}^i\binom{i}{k}2^{k(i-k)}f_{i-k}\left((1-1)^k-(-1)^k\binom{k}{0}\right)\\
&=\sum_{k=1}^i\binom{i}{k}2^{k(i-k)}f_{i-k}(-1)^{k+1}\\
\end{aligned}
$$
我们就得到了 DP 式子：
$$
f_i=\sum_{k=1}^i(-1)^{k+1}\binom{i}{k}2^{k(i-k)}f_{i-k}
$$
有一个 trick：
$$
ij=\binom{i+j}{2}-\binom{i}{2}-\binom{j}{2}
$$
证明比较简单：考虑组合意义，从 $i+j$ 个数中选两个数的方案数减去分别从 $i,j$ 个数中选两个数的方案数，就等于从 $i$ 个数和 $j$ 个数中分别选一个数的方案数，也就是 $ij$。

于是有：
$$
\begin{aligned}
2^{k(i-k)}&=2^{\large\binom{i}{2} - \binom{k}{2} - \binom{i-k}{2}}\\
&=\frac{2^{\large\binom{i}{2}}}{2^{\large\binom{k}{2}}\times 2^{\large\binom{i-k}{2}}}
\end{aligned}
$$
那么就可以写成 EGF 的形式了。设生成函数 $F,G$：
$$
F(x)=\sum_{i\ge 0} \frac{f_i}{i!\times 2^{\large\binom{i}{2}}}x^i
$$

$$
G(x)=\sum_{i\ge 1} \frac{(-1)^{i+1}}{i!\times 2^{\large\binom{i}{2}}}x^i
$$

并且 $f_0=1$，那么就能得出：
$$
F(x)=F(x)G(x)+1
$$
即：
$$
F(x)=\frac{1}{1-G(x)}
$$
那么就可以通过一次多项式求逆得出。

如果需要求弱联通的数量呢？

那么我们可以考虑经典做法：设 $A(x)$ 为有任意个弱连通块的 EGF，$B(x)$ 为有仅一个弱连通块的 EGF，那么就有：
$$
A(x)=e^{B(x)}
$$

$$
B(x)=\ln A(x)
$$



所以再进行一次多项式 $\ln$ 就可以解决这一问题了。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 400005, P = 998244353, G = 3, GI = 332748118;
int qpow(int a, long long b) {
    int ans = 1;
    while (b) {
        if (b & 1) ans = 1ll * ans * a % P;
        a = 1ll * a * a % P;
        b >>= 1;
    }
    return ans;
}
int r[MAXN];
struct Polynomial {
    vector<int> a;
    int len;
    int& operator[](int b) { return a[b]; }
    Polynomial(int len = 0) : len(len) { a.resize(len + 1); }
    Polynomial& set(int b) { len = b, a.resize(b + 1); return *this; }
    static Polynomial resize(Polynomial a, int s) { Polynomial b = a; return b.set(s); }
    void reverse() { std::reverse(a.begin(), a.end()); }
    static void calcRev(int limit) {
        for (int i = 1; i < limit; i++)
            r[i] = (r[i >> 1] >> 1) | ((i & 1) * limit >> 1);
    }
    void ntt(int limit, bool rev) {
        set(limit);
        for (int i = 0; i < limit; i++)
            if (i < r[i]) swap(a[i], a[r[i]]);
        for (int mid = 1; mid < limit; mid <<= 1) {
            int step = qpow(rev ? GI : G, (P - 1) / (mid << 1));
            for (int l = 0; l < limit; l += (mid << 1)) {
                int w = 1;
                for (int j = 0; j < mid; j++, w = 1ll * w * step % P) {
                    int x = a[l + j], y = 1ll * w * a[l + j + mid] % P;
                    a[l + j] = (x + y) % P, a[l + j + mid] = (1ll * P + x - y) % P;
                }
            }
        }
        int invn = qpow(limit, P - 2);
        if (rev) {
            for (int i = 0; i < limit; i++) 
                a[i] = 1ll * a[i] * invn % P;
        }
    }
    void print() { for (int i : a) printf("%d ", i); printf("\n"); }
    Polynomial operator*(Polynomial b) {
        Polynomial a = *this, c;
        int n = a.len + b.len;
        int limit = 1;
        while (limit <= n) limit <<= 1;
        c.set(limit);
        calcRev(limit);
        a.ntt(limit, 0), b.ntt(limit, 0);
        for (int i = 0; i <= limit; i++) c[i] = 1ll * a[i] * b[i] % P;
        c.ntt(limit, 1);
        c.set(n);
        return c;
    }
    Polynomial operator*(int b) {
        Polynomial c = *this;
        for (int& i : c.a) i = 1ll * i * b % P;
        return c;
    }
    Polynomial operator+(int b) {
        Polynomial c = *this;
        c[0] = (1ll * c[0] + b + P) % P;
        return c;
    }
    Polynomial operator+(Polynomial b) {
        Polynomial c = *this;
        c.set(max(c.len, b.len));
        for (int i = 0; i <= b.len; i++) c[i] = (c[i] + b[i]) % P;
        return c;
    }
    Polynomial operator-(Polynomial b) {
        Polynomial c = *this;
        c.set(max(c.len, b.len));
        for (int i = 0; i <= b.len; i++) c[i] = (c[i] - b[i] + P) % P;
        return c;
    }
    Polynomial inv(int n) {
        Polynomial b;
        b[0] = qpow(a[0], P - 2);
        for (int d = 1; d < (n << 1); d <<= 1) {
            Polynomial a = *this;
            a.set(d - 1);
            int limit = d << 1;
            calcRev(limit);
            a.ntt(limit, 0), b.ntt(limit, 0);
            for (int i = 0; i < limit; i++) b[i] = (2ll - 1ll * a[i] * b[i] % P + P) % P * b[i] % P;
            b.ntt(limit, 1);
            b.set(d - 1);
        }
        b.set(n - 1);
        return b;
    }
    Polynomial derivative() {
        Polynomial b(len - 1);
        for (int i = 1; i <= len; i++) b[i - 1] = 1ll * a[i] * i % P;
        return b;
    }
    Polynomial integral() {
        Polynomial b(len + 1);
        for (int i = 0; i <= len; i++) b[i + 1] = 1ll * a[i] * qpow(i + 1, P - 2) % P;
        return b;
    }
    Polynomial ln(int n) {
        return (derivative() * inv(n)).integral().set(n - 1);
    }
};
int t;
int fac[MAXN];
long long C2(int x) {
    return 1ll * x * (x - 1) / 2;
}
int main() {
    scanf("%d", &t);
    fac[0] = 1;
    for (int i = 1; i <= t; i++) fac[i] = 1ll * fac[i - 1] * i % P;
    Polynomial f, g, h;
    g.set(t);
    for (int i = 1; i <= t; i++) {
        g[i] = ((i & 1) ? 1ll : P - 1ll) * qpow(fac[i], P - 2) % P * qpow((P + 1) / 2, C2(i)) % P;
    }
    f = (g * (-1) + 1).inv(t + 1);
    for (int i = 0; i <= t; i++) {
        f[i] = 1ll * f[i] * qpow(2, C2(i)) % P;
    }
    h = f.ln(t + 1);
    for (int i = 1; i <= t; i++) {
        printf("%lld\n", 1ll * h[i] * fac[i] % P);
    }
    return 0;
}
```

---

## 作者：yyxmy (赞：3)

这道题想起来，写起来好像都有点自闭（也许是$wtcl$）  
看到这题， 很容易想起一个经典的问题， 即有标号无向联通图计数，  
该题的$dp$方程为  
$dp[i] = g[i] - \sum_{j=1}^{i-1} dp[j] * c[i-1][j-1] * g[i - j]$  
其中$dp[i]$表示i个点连通块的方案数，$g[i]$表示$i$个点无向图的方案数，$c$是组合数。 这里的g非常好求。

对于这个方程的意义， 我想应该比较容易看出，即拿总方案数减去不连通的方案数。   
如果不是很明白，建议去看看 [城市规划](https://www.luogu.com.cn/problem/P4841)这道题。  

对于此题， 我们可以套用上面的做法， 即$dp[i]$表示$i$个点弱连通$DAG$的方案数，但是在这里，$g$不是那么容易看出了， 因为$DAG$要保证无环。  
我们考虑怎么求$g[i]$，我们知道一个$DAG$必定存在若干个点的出度为0， 那么我们不妨枚举当前这个点集有多少个出度为0的点，将这些点删去， 里面的图于是成了一个子问题。 那么这些点与内部的点可以构成$j(i - j)$条边， 每条边可加可不加，加的话方向是确定的， 那么方案数即为$2^{j(i - j)}$。  
然后就可以求解$g[i]$了  
$g[i] = \sum_{j=0}^{i-1} c[i][j] * g[j] * 2^{j(i - j)}$;  
感觉这个方程挺对的， 但是打表却发现，求出来会比答案大， 这是因为有些情况会算重， 应该在前面加一个$(-1)^{j-i+1}$, 至于为啥会这样， 我没细想，总之加一个他就对了。
我们发现$g[i]$的求解和$dp[i]$的求解都是可以用多项式来优化的，具体过程大家不妨看看楼上的。  
暴力程序：  
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define maxn 100005
#define reg register
using namespace std;
int ksm(int u, int v){
    int s = 1;
    for(int i = v; i; i >>= 1){
        if(i & 1) s = 1ll * s * u % mod;
        u = 1ll * u * u % mod;
    }
    return s;
}
int n, fac[maxn], ifac[maxn], dp[maxn], inv[maxn], f[maxn];
int C(int x, int y){
    return 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;
}
signed main(){
    cin >> n;
    fac[0] = 1; ifac[0] = 1; inv[0] = 1;
    for(int i = 1; i <= n; i++){
        inv[i] = (i == 1) ? 1 : 1ll * inv[mod % i] * (mod - mod / i) % mod;
        fac[i] = 1ll * fac[i - 1] * i % mod;
        ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;
    }
    dp[0] = 1;
    for(int i = 1; i <= n; i++){
       for(int j = 0; j < i; j++){
            int x = 1ll * dp[j] * C(i, j) % mod * ksm(2, j * (i - j)) % mod;
            if(i - j & 1) dp[i] = (dp[i] + x) % mod;
            else dp[i] = (dp[i] + mod - x) % mod;
       }
    }
    for(int i = 1; i <= n; i++){
        f[i] = dp[i];
        for(int j = 1; j < i; j++){
            int x = 1ll * f[j] * C(i - 1, j - 1) % mod * dp[i - j] % mod;
            f[i] = (f[i] + mod - x) % mod;  
        }
        printf("%d\n", f[i]);
    }
}
```
正解程序
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define maxn 400005
#define G 3
#define T 116195171
#define Gi 332748118
#define reg register
using namespace std;

int n, fac[maxn], ifac[maxn], dp[maxn], inv[maxn], f[maxn], a[maxn];
int lim, len, rev[maxn], d[maxn], b[maxn], c[maxn];
int C(int x, int y){
    return 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;
}
int inc(int x, int y){
    return x + y >= mod ? x + y - mod : x + y;
}
int ksm(int u, int v){
    int s = 1;
    for(int i = v; i; i >>= 1){
        if(i & 1) s = 1ll * s * u % mod;
        u = 1ll * u * u % mod;
    }
    return s;
}
void ntt(int *a, int type){
    for(int i = 1; i < lim; i++)
        if(i < rev[i]) swap(a[i], a[rev[i]]);
    for(int i = 1; i < lim; i <<= 1){
        int x = ksm(type == 1 ? G : Gi, (mod - 1) / (i << 1));
        for(int j = 0; j < lim; j += (i << 1))
            for(int k = 0, y = 1; k < i; k++, y = 1ll * y * x % mod){
                int p = a[j + k], q = 1ll * y * a[j + k + i] % mod;
                a[j + k] = inc(p, q); a[j + k + i] = inc(p, mod - q);
            }
    }
    if(type == -1){
        int x = ksm(lim, mod - 2);
        for(int i = 0; i < lim; i++) a[i] = 1ll * a[i] * x % mod;
    }
}
void solve(int l, int r){
    int mid = l + r >> 1;
    if(l == r){
        if(l == 0) {d[l] = 1; return;}
        return;
    }
    solve(l, mid); 
    for(lim = 1, len = 0; lim <= (r - l + 1); lim <<= 1, len++);
    for(int i = 1; i < lim; i++) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (len - 1));
    for(int i = l; i <= mid; i++) 
        b[i - l] = d[i], c[i - l] = a[i - l];
    for(int i = mid + 1; i <= r; i++)
        b[i - l] = 0, c[i - l] = a[i - l];
    for(int i = r - l + 2; i < lim; i++) b[i] = 0, c[i] = 0;
    ntt(b, 1); ntt(c, 1);
    for(int i = 0; i < lim; i++) b[i] = 1ll * b[i] * c[i] % mod;
    ntt(b, -1);
    for(int i = mid + 1; i <= r; i++) d[i] = inc(d[i], b[i - l]);
    solve(mid + 1, r);
}
void work(int length){
    if(length == 1){
        f[0] = ksm(a[0], mod - 2); return;
    }
    work(length >> 1); int x = len >> 1;
    for(int i = 0; i < length; i++) b[i] = a[i];
    for(int i = 0; i < length; i++) c[i] = f[i];
    for(lim = 1, len = 0; lim <= length; lim <<= 1, len++);
    for(int i = length; i < lim; i++) b[i] = 0, c[i] = 0;
    for(int i = 1; i < lim; i++) 
    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (len - 1));
    ntt(b, 1); ntt(c, 1);
    for(int i = 0; i < lim; i++) 
    b[i] = 1ll * c[i] * (2ll + mod - 1ll * c[i] * b[i] % mod) % mod;
    ntt(b, -1); for(int i = 0; i < length; i++) f[i] = b[i];
}
signed main(){
    cin >> n;
    fac[0] = 1; ifac[0] = 1; inv[0] = 1;
    for(int i = 1; i <= n; i++){
        inv[i] = (i == 1) ? 1 : 1ll * inv[mod % i] * (mod - mod / i) % mod;
        fac[i] = 1ll * fac[i - 1] * i % mod;
        ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;
    }
    for(int i = 0; i <= n; i++){
        int x = ksm(T, 1ll * i * i % (mod - 1));
        a[i] = 1ll * ifac[i] * ksm(x, mod - 2) % mod;
        if(i + 1 & 1) a[i] = mod - a[i];
    }
    for(lim = 1; lim <= n; lim <<= 1);
    solve(0, lim - 1);    
    for(int i = 0; i <= n; i++){
        d[i] = 1ll * d[i] * fac[i] % mod * ksm(T, 1ll * i * i % (mod - 1)) % mod;
    }
    memset(b, 0, sizeof b); memset(c, 0, sizeof c); memset(f, 0, sizeof f);
    a[0] = 1;
    for(int i = 1; i <= n; i++) a[i] = 1ll * d[i] * ifac[i] % mod;
    memset(d, 0, sizeof d); 
	for(int i = 0; i < n; i++) d[i] = 1ll * a[i + 1] * (i + 1) % mod;
	
    for(lim = 1; lim <= n; lim <<= 1);
    work(lim); int len = 0;
	for(lim = 1; lim < (n << 1); lim <<= 1) len++;
	for(int i = 1; i < lim; i++) 
	rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (len - 1));
	ntt(d, 1); ntt(f, 1);
	for(int i = 0; i < lim; i++) d[i] = 1ll * d[i] * f[i] % mod;
	ntt(d, -1);
	for(int i = 1; i <= n; i++) a[i] = 1ll * d[i - 1] * inv[i] % mod;
	for(int i = 1; i <= n; i++){
        int x = 1ll * a[i] * fac[i] % mod;
        printf("%d\n", x);
    }
}
```


---

## 作者：Star_Cried (赞：1)

## P6295 有标号 DAG 计数

### 题意

求 $n$ 个点有标号弱联通 DAG 数量。

### 推导

设 $f_i$ 表示 $i$ 个点有标号 DAG 数量（不保证弱联通），有：
$$
f(i)=\sum_{j=1}^i\binom ij(-1)^{j-1}f(i-j)2^{j(i-j)}
$$
意义为选至少 $j$ 个度数为零的点，向剩下的 $i-j$ 个点随便连有向边，容斥一下就得到了上式。

下面进行推导。根据一个 trick:
$$
j(i-j)=\binom i2-\binom j2-\binom {i-j}2
$$
所以有:
$$
\begin{aligned}
&f(i)=\sum_{j=1}^i\frac{i!}{j!(i-j)!} (-1)^{j-1} f(i-j) \frac{2^\binom i2}{2^\binom j22^\binom{i-j}2}\\
\Rightarrow&\frac{f(i)}{i!2^\binom i2}=\sum_{j=1}^i\frac{(-1)^{j-1}}{j!2^\binom j2} \frac{f(i-j)}{(i-j)!2^\binom{i-j}2}
\end{aligned}
$$
设
$$
\begin{aligned}
F(x)=\sum_{i=0}^\infty\frac{f(i)}{i!2^{\binom i2}}\\
 G(x)=\sum_{i=1}^\infty\frac{(-1)^{i-1}}{i!2^\binom i2}
\end{aligned}
$$
则有
$$
F(x)=F(x)G(x)+1
$$
加 1 是因为常数项为 1.

解得
$$
F(x)=\frac1{1-G(x)}
$$
根据 $F$ 的定义，我们解出 $F$ 后乘上 $2^\binom i2$ 即为 $f$ 的 EGF。根据多项式 ln 和 exp 的组合意义，我们将得到的 EGF ln 一下即可得到题目要求的弱联通的 DAG 数量的 EGF。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=4e5+10,mod=998244353,g=3,gi=998244354/3;
	inline int fpow(int a,long long b){int ans=1;for(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod; return ans;}
	struct NTT{
		int r[maxn],lim;
		inline void getr(int li){lim=li;for(int i=0;i<=lim;i++) r[i]=(r[i>>1]>>1)|((i&1)*(lim>>1));}
		void operator () (int *a,int type) const {
			for(int i=0;i<lim;i++) if(i<r[i]) swap(a[i],a[r[i]]);
			for(int mid=1;mid<lim;mid<<=1){
				int rt=fpow(type==1?g:gi,(mod-1)/(mid<<1));
				for(int r=mid<<1,j=0;j<lim;j+=r){
					int p=1;
					for(int k=0;k<mid;k++,p=1ll*p*rt%mod){
						int x=a[j+k],y=1ll*a[j+k+mid]*p%mod;
						a[j+k]=(x+y)%mod,a[j+k+mid]=(x-y+mod)%mod;
					}
				}
			}
			if(type==-1) for(int p=fpow(lim,mod-2),i=0;i<lim;i++) a[i]=1ll*a[i]*p%mod;
		}
	}ntt;
	void Inv(const int *a,int *ans,int n){
		if(n==1) return ans[0]=fpow(a[0],mod-2),ans[1]=0,void();
		static int res[maxn];
		Inv(a,ans,n>>1);
		int lim=n<<1;
		ntt.getr(lim);
		for(int i=0;i<n;i++) res[i]=a[i];
		for(int i=n;i<lim;i++) ans[i]=res[i]=0;
		ntt(ans,1),ntt(res,1);
		for(int i=0;i<lim;i++) ans[i]=ans[i]*(2-1ll*ans[i]*res[i]%mod+mod)%mod;
		ntt(ans,-1);
		for(int i=n;i<lim;i++) ans[i]=0;
	}
	inline void deri(const int *a,int *ans,int n){for(int i=1;i<n;i++) ans[i-1]=1ll*a[i]*i%mod;ans[n-1]=0;}
	inline void inte(const int *a,int *ans,int n){for(int i=n-1;i;i--) ans[i]=1ll*a[i-1]*fpow(i,mod-2)%mod;ans[0]=0;}
	inline void ln(const int *a,int *ans,int n){
		static int res[maxn];
		Inv(a,ans,n);
		deri(a,res,n);
		int lim=n<<1;
		ntt.getr(lim);
		ntt(ans,1),ntt(res,1);
		for(int i=0;i<lim;i++) res[i]=1ll*ans[i]*res[i]%mod,ans[i]=0;
		ntt(res,-1);
		for(int i=n;i<lim;i++) res[i]=0;
		inte(res,ans,n);
	}
	int a[maxn],b[maxn],n,inv[maxn],mul[maxn];
	inline void work(){
		n=read();
		inv[0]=mul[0]=1;for(int i=1;i<=n;i++) mul[i]=1ll*mul[i-1]*i%mod;
		inv[n]=fpow(mul[n],mod-2);for(int i=n-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
		for(int i=1;i<=n;i++) a[i]=(i&1?mod-1ll:1ll)*inv[i]%mod*fpow(fpow(2,1ll*i*(i-1)/2),mod-2)%mod;
		a[0]=1;
		int lim=1;for(;lim<=n;lim<<=1);
		Inv(a,b,lim);
		for(int i=0;i<=n;i++) b[i]=1ll*b[i]*fpow(2,1ll*i*(i-1)/2)%mod,a[i]=0;
		for(int i=n+1;i<lim;i++) a[i]=b[i]=0;
		ln(b,a,lim);
		for(int i=1;i<=n;i++) printf("%lld\n",1ll*a[i]*mul[i]%mod);
	}
}
signed main(){
	star::work();
	return 0;
}
```



---

## 作者：guyan (赞：1)

如果公式炸了请去博客 $\uparrow$

---

仿照 [城市规划](https://www.luogu.com.cn/problem/P4841) 这题 , 先求出 $n$ 个点由若干不联通 DAG 组成的方案数 $g_n$ , $n$ 个点的弱联通 DAG 数 $f_n$ , 根据 $\exp$ 的组合意义: 

>将 $1 \sim n$ 分成若干非空部分 , 大小为 $k$ 的部分有 $f_k$ 种方案数 , 求总方案数

设 $F(x)$ 是 $f$ 的 EGF , $G(x)$ 是 $g$ 的 EGF , 有


$G(x) = \exp(F(x))$

$F(x) = \ln(G(X))$

于是问题变为求 $g_n$ , 考虑知道 $g_{1\sim n-1}$ 如何求 $g_n$ 

为了保证这是个 DAG , 考虑枚举入度为 $0$ 的点数 , 然后和剩下的 DAG 连边

设 $h_{n,i}$ , 表示有 $n$ 个点时 , 入度为 $0$ 的点数 __恰好__ 为 $i$ 的方案数

$p_{n,i}$  , 表示有 $n$ 个点时 , 入度为 $0$ 的点数 __至少__ 为 $i$ 的方案数 , 可以得出 $p_{n,i} = \binom{n}{i}2^{i(n-i)}g_{n-i}$ , 就是选出 $i$ 个点度数一定为 $0$ , 其余随意连边

为方便 , 默认省去第一维 $n$ , 那么 $g_n = \sum_{i=1}^n h_i$ , 考虑 $h$ 和 $p$ 的关系


$p_i = \sum_{j=i}^n \binom{j}{i}h_j$

$h_i = \sum_{j=i}^n(-1)^{(j-i)}\binom{j}{i}p_j$


其中二式是 __二项式反演__ , 带入原式

$$g_n = \sum_{i=1}^n\sum_{j=i}^n(-1)^{(j-i)}\binom{j}{i}p_j$$

$$g_n= \sum_{j=1}^np_j\sum_{i=1}^j(-1)^{(j-i)}\binom{j}{i}$$

$$g_n= \sum_{j=1}^n p_j \left((1-1)^j - (\binom{j}{0}(-1)^j)\right)$$

$$g_n= \sum_{j=1}^n p_j (-1)^{(j+1)}$$

$$g_n= \sum_{i=1}^n (-1)^{(i+1)}\binom{n}{i}2^{i(n-i)}g_{n-i}$$


考虑对 $2^{i(n-i)}$ 进行变换

$$
\binom{a+b}{2} - \binom{a}{2} - \binom{b}{2} = ab
$$

>不建议使用平方式 , 会在 [这题](https://www.luogu.com.cn/problem/P5293) 吃瘪

上式可以手算验证 , 于是有


$$
g_n = \sum_{i=1}^n (-1)^{(i+1)}\binom{n}{i} 2^{\binom{n}{i}-\binom{i}{2}-\binom{n-i}{2}} g_{n-i}
$$

$$
g_n=n!2^{\binom{n}{2}}\sum_{i=1}^n\frac{(-1)^{(i+1)}}{i!\cdot 2^{\binom{i}{2}}} \cdot \frac{g_{n-i}}{(n-i)!\cdot 2^{\binom{n-i}{2}}}
$$


设 


$$
A(x) = \sum_{i>0}\frac{(-1)^{(i+1)}}{i!\cdot2^{\binom{i}{2}}}x^i
$$

$$
B(x) = \sum_{i}\frac{g_i}{i!\cdot2^{\binom{i}{2}}}x^i
$$


于是有 

$$
B(x) = A(x)B(x) + 1
$$

$$
B(x) = \frac{1}{1-A(x)}
$$

就可以求出 $g_n$ 了 , 最后 $\ln$ 求 $f_n$ 就行了

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 4e5 + 5;
const int mod = 998244353;
const int ig = 332748118;
inline int pls( int a , int b ) { a += b - mod; return a + ( a >> 31 & mod ); }
inline int mns( int a , int b ) { a -= b; return a + ( a >> 31 & mod ); }
inline void inc( int & a , int b ) { a += b - mod; a += a >> 31 & mod; }
inline void dec( int & a , int b ) { a -= b; a += a >> 31 & mod; }
inline int fpow( int b , long long k ) {
  int res = 1;
  while( k ) {
    if( k & 1 ) res = 1LL * res * b % mod;
    b = 1LL * b * b % mod; k >>= 1;
  }
  return res;
}

int _r[N] , _now;

void _NTT_init( int n ) {
  static int l;
  if( n == _now ) return;
  l = 0; while( ( 1 << l ) < n ) ++l;
  --l; for( int i = 1 ; i < n ; ++i )
    _r[i] = ( _r[i >> 1] >> 1 ) | ( (i&1) << l );
}

void NTT( int * f , int n , int flag ) {
  static int wn , w , x , y;
  _NTT_init( n ); for( int i = 1 ; i < n ; ++i ) 
    if( i < _r[i] ) swap( f[i] , f[_r[i]] );
  for( int mid = 1 ; mid < n ; mid <<= 1 ) {
    wn = fpow( flag ? ig : 3 , ( mod - 1 ) / ( mid << 1 ) );
    for( int i = 0 ; i < n ; i += ( mid << 1 ) ) {
      w = 1; for( int j = 0 ; j < mid ; w = 1LL * w * wn % mod , ++j ) {
        x = f[i + j] , y = 1LL * f[i + j + mid] * w % mod;
        f[i + j] = pls( x , y ) , f[i + j + mid] = mns( x , y );
      }
    }
  }
  if( flag ) {
    w = fpow( n , mod - 2 );
    for( int i = 0 ; i < n ; ++i ) 
      f[i] = 1LL * f[i] * w % mod;
  }
}

int _A[N] , _B[N];

void Inv( int * f , int * g , int _n ) {
  ++_n; memset( g , 0 , sizeof( int ) * _n * 2 );
  g[0] = fpow( f[0] , mod - 2 ); int lim = 1;
  for( int n = 2 ; n < _n * 2 ; n <<= 1 ) {
    while( lim < n * 2 ) lim <<= 1;
    for( int i = 0 ; i < n ; ++i ) _A[i] = f[i] , _B[i] = g[i];
    for( int i = n ; i < lim ; ++i ) _A[i] = _B[i] = 0;
    NTT( _A , lim , 0 ) , NTT( _B , lim , 0 );
    for( int i = 0 ; i < lim ; ++i ) _A[i] = mns( pls( _B[i] , _B[i] ) , 1LL * _A[i] * _B[i] % mod * _B[i] % mod );
    NTT( _A , lim , 1 ); for( int i = 0 ; i < n ; ++i ) g[i] = _A[i];
  } for( int i = _n ; i < lim ; ++i ) g[i] = 0;
}

int fac[N] , ifac[N] , inv[N];

void Ln( int * f , int * g , int _n ) {
  static int invf[N] , lim;
  Inv( f , invf , _n ) , lim = 1;
  while( lim <= _n * 2 ) lim <<= 1;
  _A[_n] = 0; for( int i = 1 ; i <= _n ; ++i ) _A[i - 1] = 1LL * i * f[i] % mod;
  for( int i = 0 ; i <= _n ; ++i ) _B[i] = invf[i];
  for( int i = _n + 1 ; i < lim ; ++i ) _A[i] = _B[i] = 0;
  NTT( _A , lim , 0 ) , NTT( _B , lim , 0 );
  for( int i = 0 ; i < lim ; ++i ) _A[i] = 1LL * _A[i] * _B[i] % mod;
  NTT( _A , lim , 1 );
  g[0] = 0; for( int i = 1 ; i <= _n ; ++i ) g[i] = 1LL * inv[i] * _A[i - 1] % mod;
}

int n , f[N] , g[N] , A[N] , B[N];

int main( void ) {
  cin >> n;
  A[0] = 1;
  inv[1] = fac[0] = fac[1] = ifac[0] = ifac[1] = 1;
  for( int i = 2 , t = n * 3 ; i <= t ; ++i ) {
    fac[i] = 1LL * fac[i - 1] * i % mod;
    inv[i] = 1LL * ( mod - mod / i ) * inv[mod % i] % mod;
    ifac[i] = 1LL * ifac[i - 1] * inv[i] % mod;
  }
  for( int i = 1 ; i <= n ; ++i ) {
    A[i] = 1LL * fpow( fpow( 2 , 1LL * i * ( i - 1 ) / 2 ) , mod - 2 ) * ifac[i] % mod;
    if( i & 1 ) A[i] = mns( 0 , A[i] );
  }
  Inv( A , B , n );
  g[0] = 1; 
  for( int i = 1 ; i <= n ; ++i )
    g[i] = 1LL * B[i] * fpow( 2 , 1LL * i * ( i - 1 ) / 2 ) % mod;
  Ln( g , f , n );
  for( int i = 1 ; i <= n ; ++i )
    printf("%lld\n",1LL*f[i]*fac[i]%mod);
  return 0;
}
```


---


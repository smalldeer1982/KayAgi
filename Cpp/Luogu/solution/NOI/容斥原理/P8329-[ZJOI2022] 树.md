# [ZJOI2022] 树

## 题目背景

一年一度的 ZJOI 又要举办了，但是老牌出题人九条可怜突然有急事要回趟英国。

“就交给你们啦！一定没有问题 desu！”，说完可怜就跑远了。

忍，爱丽丝，绫和阳子目送着远去的可怜，感到有点茫然，毕竞，ZJOI 只剩不到三星期了。

既然是可怜酱留下的任务，那我们一定要努力完成了，毕竟我才是姐姐”，爱丽丝说。

于是众人就开始热火朝天地出题了，“希望这是第一次也是最后一次了” 大家都不约而同地想。

同时，题目主角就定为九条可怜了！

## 题目描述

九条可怜是一个喜欢树的女孩子，她想生成两棵均有 $n$ 个节点的树。

第一棵树的生成方式是：

1. 节点 $1$ 作为树的根。
2. 对于 $i \in [2, n]$，从 $[1, i - 1]$ 中选取一个节点作为 $i$ 的父亲。

第二棵树的生成方式是：

1. 节点 $n$ 作为树的根。
2. 对于 $i \in [1, n - 1]$，从 $[i + 1, n]$ 中选取一个节点作为 $i$ 的父亲。

九条可怜希望对于任意 $i \in [1, n]$，若第一棵树中的节点 $i$ 为叶子，那么第二棵树中的节点 $i$ 为非叶子；若第一棵树中的节点 $i$ 为非叶子，那么第二棵树中的节点 $i$ 为叶子。一个节点被称为叶子当且仅当没有节点的父亲是它。

九条可怜希望你统计生成两棵树的方案数是多少。具体地，你需要对于所有 $n \in [2, N]$ 都计算方案数。两种方案不同当且仅当存在一棵树中的一个节点 $i$，两种方案中它的父亲不同。因为答案可能很大，你只需要输出答案对 $M$ 取模后的结果。

## 说明/提示

对于所有测试点：保证 $2 \le N \le 500$，$10 \le M \le 2^{30}$。

每个测试点的具体限制见下表：

| 测试点编号 | $N \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1$ | $10$ | 无 |
| $2$ | $20$ | 保证 $M$ 为质数 |
| $3$ | $50$ | 无 |
| $4$ | $50$ | 保证 $M$ 为质数 |
| $5$ | $100$ | 无 |
| $6$ | $100$ | 保证 $M$ 为质数 |
| $7$ | $500$ | 无 |
| $8$ | $500$ | 保证 $M$ 为质数 |
| $9$ | $500$ | 无 |
| $10$ | $500$ | 保证 $M$ 为质数 |

## 样例 #1

### 输入

```
5 998244353
```

### 输出

```
1
2
12
120
```

## 样例 #2

### 输入

```
见附件中的 tree/tree_ex2.in```

### 输出

```
见附件中的 tree/tree_ex2.ans```

# 题解

## 作者：Umbrella_Leaf (赞：67)

### 分析

> 设 $f(S)$ 表示第一棵树的非叶子集合**恰好**为 $S$ 时构造第一棵树的方案数。
> 
> 设 $g(T)$ 表示第二棵树的非叶子集合**恰好**为 $T$ 时构造第二棵树的方案数。

那么答案为
$$Ans=\sum_{S\cap T=\varnothing,S\cup T=\{1,2,\cdots,n\}}f(S)g(T)$$

直接求这个不太好求，我们考虑容斥。

> 设 $f'(S)$ 表示第一棵树的非叶子集合**包含于** $S$ 时构造第一棵树的方案数。
> 
> 设 $g'(T)$ 表示第二棵树的非叶子集合**包含于** $T$ 时构造第二棵树的方案数。

$$
\begin{aligned}
Ans&=\sum_{S\cap T=\varnothing,S\cup T=\{1,2,\cdots,n\}}f(S)g(T)\\&=\sum_{S\cap T=\varnothing,S\cup T=\{1,2,\cdots,n\}}\sum_{S'\subseteq S,T'\subseteq T}f'(S')g'(T')(-1)^{|S|-|S'|+|T|-|T'|}
\\&=\sum_{S'\cap T'=\varnothing}f'(S')g'(T')(-1)^{n-|S'|-|T'|}2^{n-|S'|-|T'|}\\&=\sum_{S'\cap T'=\varnothing}f'(S')g'(T')(-2)^{n-|S'|-|T'|}
\end{aligned}
$$

其中倒数第二个等号的理由是：不属于 $S'$ 和 $T'$ 的那些元素可能在 $S$ 中，也可能在 $T$ 中。

然后可以 DP，我们设 $dp_{i,j,k}$ 表示确定了 $[1,i]$ 中的点在 $S'$ 和 $T'$ 中的情况，$|\{1,\cdots,i\}\cap S'|=j$，$|\{i+1,\cdots,n\}\cap T'|=k$ ，且我们已经为 $(1,i]$ 选好了第一棵树中的父亲，为 $[1,i)$ 选好了第二棵树中的父亲时，这些父亲的方案数。

初值：$\forall k\in[1,n)$，$dp_{1,1,k}=1$。因为 $1$ 一定是第一棵树的非叶子节点，也一定是第二棵树的叶子节点，不需要对其进行容斥。

转移时，分类讨论 $i$ 在 $S'$ 和 $T'$ 中的情况，然后确定 $i$ 在第一棵树中的父亲和 $i-1$ 在第二棵树中的父亲：

1. $i$ 属于 $S'$，$dp_{i-1,j,k}$ 转移到 $dp_{i,j+1,k}$，系数为 $j\times k$
2. $i$ 属于 $T'$，$dp_{i-1,j,k}$ 转移到 $dp_{i,j,k-1}$，系数为 $j\times k$
3. $i$ 两个都不属于，$dp_{i-1,j,k}$ 转移到 $dp_{i,j,k}$，系数为 $-2\times j\times k$

其中转移系数中包含 $j\times k$ 的原因是：

> 考虑对于一个 $S$，如何计算 $f'(S)$。
> 
> 对于节点 $i\in(1,n]$，$fa_i$ 可能是 $[1,i)$ 中的任意一个非叶子节点下面，那么方案数是 $[1,i)$ 中非叶子节点的个数，也就是 $j$。
> 
> $g'(T)$ 同理，只不过此时我们计算的是 $i-1$ 在第二棵树中的父亲方案数，也就是 $[i,n]$ 中非叶子节点的个数。
> 
> 根据乘法原理，只需要将所有这样的点个数乘起来即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n;ll mod;
ll dp[2][505][505];
int main(){
	scanf("%d%lld",&n,&mod);
	for(int i=1;i<n;i++)dp[1][1][i]=1;
	for(int i=2,now=0;i<=n;i++,now^=1){
		memset(dp[now],0,sizeof(dp[now]));
		ll ans=0;
		for(int j=1;j<i;j++)
			for(int k=1;k<=n-i+1;k++)if(dp[now^1][j][k]){
				dp[now][j][k]=(dp[now][j][k]+dp[now^1][j][k]*(mod-2)%mod*j%mod*k%mod)%mod;
				dp[now][j+1][k]=(dp[now][j+1][k]+dp[now^1][j][k]*j%mod*k%mod)%mod;
				dp[now][j][k-1]=(dp[now][j][k-1]+dp[now^1][j][k]*j%mod*k%mod)%mod;
				if(k==1)ans=(ans+dp[now^1][j][k]*j%mod*k%mod)%mod;
			}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：jun头吉吉 (赞：34)

## 前言
因为场上过了这道计数题所以 $\rm Day1$ 分数不至于太拉，在这里只能感谢出题人。

下面的题解是蒟蒻在场上的一些想法，想了一个多小时，可能不是最好的方法，但是还是希望能够帮到大家。

## 题意

对每个 $i\in[2,n]$，求出 $(\mathcal T_1,\mathcal T_2)$ 的数量，其中 $|\mathcal T_1|=|\mathcal T_2|=i$，$\mathcal T_1$ 以 $1$ 为根，每个节点的父节点小于当前节点，$\mathcal T_2$ 以 $n$ 为根，每个节点的父节点大于当前节点，并且 $\mathcal T_1$ 的叶子 $\mathcal T_2$ 不是叶子，$\mathcal T_2$ 的叶子 $\mathcal T_1$ 不是叶子。

$n\le 500$，对 $10\le M\le 2^{30}$ 取模。

## 题解

首先看数据范围发现 $\mathcal O(n2^n)$ 有 10pts，那么先把暴力打出来：

```cpp
namespace solve0{
	const int N=20;
	mint dp[N][1<<N];
	void work(){
		dp[0][0]=1;
		for(int i=1;i<n;i++)
			for(int j=0;j<(1<<i);j++)
				for(int k=0;k<i;k++)
					dp[i][j|(1<<k)]+=dp[i-1][j];
		for(int i=2;i<=n;i++){
			mint ans=0;
			for(int j=0;j<(1<<i);j++)if(dp[i-1][j].x){
				int kk=((1<<i)-1)^j;//翻转kk得到另一颗树的状态
				int nw=0;while(kk)nw=(nw*2)+(kk&1),kk>>=1;
				ans+=dp[i-1][j]*dp[i-1][nw];
			}
			writeln(ans.x);
		}
	}
}
```
这个暴力非常显然，就是直接跑 dp 求出 $S$ 这个集合不是叶子剩下的是叶子的方案数，转移的时候就直接枚举新的节点的父亲是谁即可。

这个暴力怎么优化呢？反正我瞪了十多分钟也没看出来。最后我尝试了在计算的时候分别输出 `writeln(dp[i-1][j].x,dp[i-1][nw].x);`，然后发现这两个值是一样的。

对 $n=20$ 检验了一遍发现这个确实是正确的，那么场上我也没有细想，直接当成已知条件往下做了。

非常exciting，这个结论非常漂亮啊，感觉离正解又近了一步。这个就相当于计算两棵树，根都是 $1$，父节点都比当前节点小，并且 $u$ 在第一棵树是叶子，在第二棵树也是，如果不是，在第二棵树也不是。

然后我当时第一个想法是容斥，然后发现钦定若干个是叶子的情况不同极其难做，因为你钦定一个点是叶子非常困难，然后就自闭了，发现根本不会做。

最后想了半天发现既然对两棵树一起操作极其困难那么不妨先计算一棵树，记 $f(S)$ **恰好** $S$ 不是叶子的方案数（$1\in S$），刚才我已经深刻的认识到直接钦定不是叶子是很困难的，所以我对于这个容斥，钦定一个 $T\subseteq S$，表示钦定 $T$ 这些是叶子，那么我们记 $g(S)$ 为 **钦定** 除了 $S$ 之外的点其他都是叶子的方案数（当然 $1\in S$），那么 $g(S)$ 是非常容易计算的:

$$
g(S)=\prod_{i=2}^n\sum_{j\in S}[j<i]
$$

然后我们就可以计算 $f(S)$ 了：

$$
f(S)=\sum_{T\subset S,T\not\ni 1}(-1)^{|T|}g(S\setminus T)
$$

然后我们最后要做的是对所有 $f(S)$ 求平方和，对于平方里面有求和的形式我们可以拆开来：

$$
\sum_{S}f^2(S)=\sum_{S}\sum_{T_1\subset S}\sum_{T_2\subset S}(-1)^{|T_1|+|T_2|}
\left(\prod_{i=2}^n\sum_{j\in S\setminus T_1}[j<i]\right)\left(\prod_{i=2}^n\sum_{j\in S\setminus T_2}[j<i]\right)
$$

（当然要满足 $1\in S$，$1\not\in T_1,1\not\in T_2$，但是因为长度原因上面没有体现。）

然后我们不妨写得再好看一点：

$$
\sum_{S}\sum_{T_1\subset S}\sum_{T_2\subset S}(-1)^{|T_1|+|T_2|}
\prod_{i=2}^n\left(\sum_{j\in S\setminus T_1}[j<i]\right)\left(\sum_{j\in S\setminus T_2}[j<i]\right)
$$

推到这一步的时候非常激动啊，因为这个是可以直接 $\mathcal O(n^3)$ 的 dp 了，直接从小到大确定每个 $i$ 是否在 $S,T_1,T_2$，然后那两个 $\sum$ 就是当前的 $|S\setminus T_1|$ 和 $|S\setminus T_2|$，在 dp 的时候用两维记录一下即可。

## 代码
考场上写的垃圾代码
```cpp
namespace solve1{
	mint dp[2][N][N];
	void work(){
		int cur=0,lst=1;
		dp[cur][1][1]=1;
		for(int i=1;i<n;i++){
			swap(lst,cur);
			memset(dp[cur],0,sizeof dp[cur]);
			for(int j=1;j<=i;j++)//|S\T1|
				for(int k=1;k<=i;k++)if(dp[lst][j][k].x){//|S\T2|
					mint val=dp[lst][j][k]*j*k;
					//case1 S不选 T1 这位不选 T2 这位不选
					dp[cur][j][k]+=2*val;
					//case2 S选
					//case2.1 T1 不选，T2不选
					dp[cur][j+1][k+1]+=val;
					//case2.2 T1 不选，T2 选
					dp[cur][j+1][k]-=val;
					//case2.3 T1 选，T2 不选
					dp[cur][j][k+1]-=val;
					//case2.4 T1 选，T2 选
					//dp[cur][j][k]+=val;
				}
			mint ans=0;
			for(int j=1;j<=i+1;j++)
				for(int k=1;k<=i+1;k++)
					ans+=dp[cur][j][k];
			writeln(ans.x);
		}
	}
}
```

---

## 作者：JoshAlMan (赞：21)

考虑假设现在确定了哪个叶子集合是第一棵的，剩下是第二棵。那就是要算恰好第棵叶子集合是这个的方案数，钦定一个集合是叶子好做的，第一棵树就是每个点前面非叶子个数乘起来（第二颗树类似），所以可以选一个不能是叶子集合的容斥。

所以大概就是类似这样的形式：
$$(\sum_{}(-1)^{|s|} \times w(s))(\sum_{}(-1)^{|t|} \times w(t))$$

然后你展开发现同样是行的，就意味着可以一起容斥，其实很显然。。

所以就 dp，决定每个点是哪个叶子的同时，另一颗树可以选择也视为叶子容斥。

考虑按编号从小到大决定，$f_{x, y}$ 表示目前位置（包括现在这个）之前第一棵树前面有 $x$ 非叶子，目前位置之后（不包括这个）第二棵树有 $y$ 个非叶子。

初始 $f_{1, i} = i$，终止 $ans = \sum_{i} f_{i, 1} \times i$

每次迭代加一个，设之前的是 $f'$，考虑对当前 $f$ 的贡献：

* 考虑当前叶子给第一棵树
  * 钦定第二棵树是叶子容斥： $-f'_{x,y} \times x \times y \rightarrow f_{x,y}$
  * 不钦定第二棵树是叶子： $f'_{x,y} \times x \times (y-1) \rightarrow f_{x,y-1}$
* 考虑第二棵树叶子集合是这个
  * 钦定第一棵树是叶子容斥： $-f'_{x,y} \times x \times y \rightarrow f_{x,y}$ （哈哈，和刚才是一样的，神奇哦
  * 不钦定：$f'_{x,y} \times x \times y \rightarrow f_{x+1,y}$

复杂度 $O(n^3)$。

代码应该是对的吧，，计数题诶。

```cpp
// SKyqwq
#include <bits/stdc++.h>

#define fi first
#define se second
#define mp make_pair
#define pb push_back

using namespace std;

typedef pair<int, int> PII;
typedef long long LL;

template <typename T> bool inline chkMin(T &x, T y) { return (y < x) ? x = y, 1 : 0; }
template <typename T> bool inline chkMax(T &x, T y) { return (y > x) ? x = y, 1 : 0; }

template <typename T> void inline read(T &x) {
	x = 0; int f = 1; char s = getchar();
	while (s > '9' || s < '0') { if (s == '-') f = -1; s = getchar(); }
	while (s <= '9' && s >= '0') x = x * 10 + s - '0', s = getchar();
	x *= f;
}

const int N = 505;

int P, n, f[N][N], g[N][N], ans;

void inline add(int &x, int y) {
	x += y;
	if (x >= P) x -= P;
}

void inline del(int &x, int y) {
	x -= y;
	if (x < 0) x += P;
}

int main() {
	read(n), read(P);
	for (int i = 1; i <= n; i++) f[1][i] = i;
	for (int i = 2; i <= n; i++) {
		ans = 0;
		for (int j = 1; j <= n; j++) add(ans, 1ll * f[j][1] * j % P);
		printf("%d\n", ans);
		memcpy(g, f, sizeof f);
		memset(f, 0, sizeof f);
		for (int x = 1; x <= n; x++) {
			for (int y = 1; y <= n; y++) {
				if (!g[x][y]) continue;
				int w = g[x][y];
				add(f[x][y - 1], 1ll * w * x % P * (y - 1) % P);
				del(f[x][y], 1ll * w * x % P * y % P);
				add(f[x + 1][y], 1ll * w * x % P * y % P);
				del(f[x][y], 1ll * w * x % P * y % P);
			}
		}
	}
	
	return 0;
}
```



---

## 作者：Alex_Wei (赞：20)

- Update on 2022.10.2：修改表述。

> [P8329 [ZJOI2022] 树](https://www.luogu.com.cn/problem/P8329)

高妙的容斥 DP，做完之后对容斥的理解程度又上升了！

VP 的时候设当前考虑了前 $i$ 个节点，第一棵树上有 $j$ 个非叶子，第二棵树上有 $k$ 个节点还未确定父亲的方案数为 $f_{i, j, k}$。

我们发现钦定第一棵树上某个点是非叶子时，并不能保证它在最终的方案里是叶子，因为这和是否存在后面的节点以它作为父亲有关。

所以我们不得不记录 $f_{i, j, k, l}$ 表示 $j$ 个钦定为非叶子的节点仍然是叶子，$k$ 个钦定为非叶子的节点已经是非叶子，第二棵树上有 $l$ 个节点还没有父亲。

转移枚举当前节点在第一棵树上是叶子还是非叶子。

- 若是叶子，那么它在第二棵树上是非叶子。枚举儿子个数 $a$ 以及在第一棵树上以哪一类非叶子作为父亲，有转移 $f_{i, j, k, l} \times j \times \dbinom l a \to f_{i + 1, j - 1, k + 1, l - a + 1}$ 和 $f_{i, j, k, l} \times k \times \dbinom l a \to f_{i + 1, j, k, l - a + 1}$。
- 若是非叶子，同理有转移 $f_{i, j, k, l} \times j \to f_{i + 1, j - 1, k + 1, l + 1}$ 以及 $f_{i, j, k, l} \times k \to f_{i + 1, j, k, l + 1}$。

答案即 $\sum\limits_{i = 1} ^ {n - 1} f_{n, 0, i, 1}$，时间复杂度 $\mathcal{O}(n ^ 5)$，卡常后可以获得 60 分。

状态没有办法继续优化了，考虑对 DP 方法进行优化。

注意到我们容易钦定一个节点是叶子节点，但不容易钦定一个节点是非叶子节点。这个时候就要想到容斥了。具体地，令命题 $P_i$ 为节点 $i$ 在第一棵树上是叶子，$Q_i$ 为节点 $i$ 在第二棵树上是叶子。否命题是节点 $i$ 在某棵树上是非叶子。

我们希望求出 $P_i \land \lnot Q_i$ 以及 $\lnot P_i \land Q_i$ 的方案数，但是钦定 $\lnot P_i$ 或者 $\lnot Q_i$ 是很麻烦的一件事，需要 $n ^ 2$ 的时间复杂度。对于第一棵树，$j, k$ 两维是平方。对于第二棵树，$l, a$ 两维也是平方。

相比之下，钦定 $P_i$ 或 $Q_i$ 就容易得多（例如，当钦定 $i$ 在第二棵树上是叶子的时候，我们不需要枚举 $a$ 这一维）。钦定 $P_i$ 意味着我们强制 $i$ 在第一棵树上是叶子，钦定 $Q_i$ 同理。

同时，我们也容易做到 **不考虑 $P_i$** 的限制。也就是不管 $i$ 在第一棵树上是不是叶子，$P_i$ 或者 $\lnot P_i$ 两种情况都算上。实际意义就是 $i$ 作为一个 **自由节点**，我们不关心它究竟是非叶子还是叶子，这意味着接下来的节点可以随意向它连边。不考虑 $Q_i$ 的限制同理。

我们可以轻松实现上面两个要求，即对每个节点 $i$，选择究竟是钦定 $P_i$ 还是不考虑 $P_i$ 的限制，并求出方案数。对于第一棵树，我们记录 $i$ 及其前面的 **自由节点的个数** $j$（而不是 **钦定的非叶子节点个数**）作为转移系数。对于第二棵树也是一样，记录 $i$ 及其后面的 **自由节点的个数** $k$。记方案数为 $f_{i, j, k}$。

现在考虑求答案。观察 $P_i \land \lnot Q_i$ 和 $\lnot P_i \land Q_i$，它们显然是互斥的，即不可能出现一个节点在第一棵树上是叶子，在第二棵树上是非叶子，**并且** 在第一棵树上是非叶子，在第二棵树上是叶子。所以我们对两种情况单独求解。

对于 $P_i \land \lnot Q_i$ 的方案数，**进行容斥**，它等于 $P_i$ 的方案数（$P_i$ 相当于 $P_i \land (Q_i \lor \lnot Q_i)$）减去 $P_i\land Q_i$ 的方案数。同理，$\lnot P_i\land Q_i$ 的方案数等于 $Q_i$ 的方案数减去 $P_i\land Q_i$ 的方案数。

之前我们分析过 $P_i$ 和 $P_i\lor \lnot P_i$ 都是方便实现的，所以直接容斥 DP 即可。对于 $f_{i, j, k}$，

- 如果我们选择 $P_i$，那么对于 $Q_i$ 相当于要求 $Q_i \lor \lnot Q_i$，说明 $i$ 在第二棵树上是自由节点。考察 $i$ 的连边方案，由于第一棵树上 $< i$ 的自由节点个数为 $j$，第二棵树上 $\geq i$ 的自由节点个数为 $k$，即 $> i$ 的自由节点个数为 $k - 1$，所以 $f_{i - 1, j, k}$ 以 $j \times (k - 1)$ 的系数转移到 $f_{i, j, k - 1}$。
- 如果我们选择 $Q_i$，同理，$f_{i - 1, j, k}$ 以 $j \times k$ 的系数转移到 $f_{i, j + 1, k}$。
- 如果我们选择 $P_i\land Q_i$，因为这种情况要 **被减掉两次**，所以 $f_{i - 1, j, k}$ 以 $-2j\times k$ 的系数转移到 $f_{i, j, k}$。

因为 $1, n$ 两个节点比较特殊，所以对它们单独考虑。节点 $1$ 相当于初始化 $\forall i\in [1, n - 1]$，$f_{1, 1, i} = i$，节点 $n$ 相当于对 $\sum\limits_{i = 1} ^ {n - 1} f_{n - 1, i, 1} \times i$ 求和。

做一遍 DP 的复杂度是 $\mathcal{O}(n ^ 3)$，对每个 $n$ 求答案的复杂度是 $\mathcal{O}(n)$，所以总时间复杂度为 $\mathcal{O}(n ^ 3)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 500 + 5;
int n, mod, f[N][N], g[N][N];
void add(int &x, int y) {x += y, x >= mod && (x -= mod);}
int main() {
  cin >> n >> mod;
  for(int i = 1; i <= n; i++) f[1][i] = i;
  for(int i = 2; i <= n; i++) {
    int ans = 0;
    for(int j = 1; j < i; j++) add(ans, 1ll * f[j][1] * j % mod);
    cout << ans << "\n";
    for(int j = 1; j < i; j++)
      for(int k = 1; k <= n - i + 1; k++)
        if(f[j][k]) {
          int coef = 1ll * f[j][k] * j % mod;
          add(g[j][k - 1], 1ll * coef * (k - 1) % mod);
          add(g[j + 1][k], 1ll * coef * k % mod);
          add(g[j][k], (mod - 2ll) * coef % mod * k % mod);
        }
    swap(f, g), memset(g, 0, sizeof(g));
  }
  return 0;
}
```

---

## 作者：Cherished (赞：13)

趁还没有人交题解，赶紧偷跑一篇题解。
毕竟是签到题还是要能做出来的（估计也就只能做出来签到题了）。

### 简要题意

我们构建两棵树，构建方法分别是：

第一棵：根是 $1$，对于 $[2,n]$ 中的节点 $i$，向 $[1.i-1]$ 中的一个节点连边。

第二棵：根是 $n$，对于 $[1,n-1]$ 中的节点 $i$，向 $[i+1,n]$ 中的一个节点连边。

称一种方案是好的当且仅当对于第一棵树的一个非叶子节点，它是第二棵树的叶子节点；对于第二棵树的非叶子节点，它是第一棵树的叶子节点。

给出 $n$，对于所有 $i \in [2, n]$ 回答有 $i$ 个节点的好的方案有多少，答案对 $m$ 取模。

### 数据范围

$n \leq 500$

### 解题思路

我们先思考，如果钦定了第一棵树种哪些节点是叶子，哪些不是，怎么对方案数计数。

显然我们可以从左到右扫，统计出左边有多少个非叶子节点，这样一个叶子节点的可能连边数就可以确定了，我们最后再把可能连边数乘起来就是答案。

当然我们也很快就能发现这其中的问题，就是我们无法保证一个非叶子一定会被后面的点连边，想要直接处理这个问题是非常麻烦的，除非我们在列出新的一维表示有多少个叶子是已经被连边的，但是这样当我们把两棵树合在一起的时候，时间复杂度就来到了惊人的 $O(n^5)$。

那么上面所说的算法一看就很没有前途，我们考虑一种新的思路，容斥，我们可以钦定一些非叶子不被后面的点连边，那么我们每钦定一个这样的节点，最终对于答案的贡献就要 $\times -1$。

那么我们显然可以延续这个思路到两棵树结合起来的时候。

那么开始 `dp`，我们设 $f_{i,j,k}$ 表示到第 $i$ 个节点，前面第一棵树有 $j$ 个非叶子，后面第二棵树有 $k$ 个非叶子，这种情况对于答案的贡献（我设计状态的时候没有把 $1$ 号节点和 $n$ 号节点考虑进去，也就是说 $j$ 里面是不包括 $1$ 的，$k$ 里面也是不包括 $n$ 的）。

思考一下如何转移：

首先是当这个新节点在第一棵树上是叶子节点，在第二棵树上是非叶子的时候：

$$
f_{i,j,k} \leftarrow f_{i-1,j,k+1} \times (j+1) \times (k+1)
$$

当然我们还要考虑，这个节点在第二棵树上看似是一个非叶子，但是我们并没有在之前往它连边，也就是它并不是 $k$ 中的非叶子，那么他相当于是我们钦定的不向它连边的非叶子。

$$
f_{i,j,k} \leftarrow -1 \times f_{i-1,j,k} \times (j+1) \times (k+1)
$$

接下来考虑这个新节点在第一棵树上是非叶子，在第二棵树上是叶子的时候：

$$
f_{i,j,k} \leftarrow f_{i-1,j-1,k} \times j \times (k+1)
$$

还有就是我们钦定这个节点在第一棵树中是那种不被连边的非叶子。

$$
f_{i,j,k} \leftarrow -1 \times f_{i-1,j,k} \times (j+1) \times (k+1)
$$

之后我们再考虑如何初始话和计算答案，显然我们一开始的时候需要考虑 $i$ 号节点在第二棵树中的连边，$f_{1,0,k}=k+1$。

计算答案的时候我们需要考虑第 $n$ 号节点向在第一棵数中的连边，$ans_n=\sum{f_{n,j,0}\times (j+1)}$。

这样这道题就被我们漂亮的解决了。

### 关于代码

写出来感觉代码非常的短，就是被卡常了.......(也许是我太菜了吧)

反正最后我把四条转移方程加在一起取模才过的......

下面是代码：

```cpp
const int N = 510;

int n, f[N][N], g[N][N], m;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i <= n; i++) f[0][i] = i + 1;
	const int P = m;
	puts("1");
	for (int i = 2; i < n; i++) {
		swap(f, g);
		for (int j = 0; j <= i; j++)
			for (int k = 0; k <= n; k++)
				f[j][k] = 0;
		for (int j = 0; j <= i; j++)
			for (int k = 0; k <= n; k++) {
				long long tmp = 0;
				tmp += 1ll * (j+1) * (k+1) * g[j][k + 1];
				tmp += -1ll * (j+1) * (k+1) * g[j][k];
				if (j > 0) tmp += 1ll * j * (k+1) * g[j-1][k];
				tmp += -1ll * (j+1) * (k+1) * g[j][k];
				f[j][k] = (tmp % P + P) % P;
			}
		int ans = 0;
		for (int j = 0; j <= i; j++) (ans += 1ll * (j + 1) * f[j][0] % P) %= P;
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：王熙文 (赞：10)

提供一种不需要容斥的做法。

## 思路

考虑枚举每个点是否是叶子结点，设 $a_i=0$ 表示不是叶子，$=1$ 表示是叶子。

对于一棵树，可以使用 dp 计算方案数。设 $dp_{i,j}$ 表示前 $i$ 个点有 $j$ 个将来要接节点的节点。那么如果 $a_j=0$，$dp_{i,j}=dp_{i-1,j} \cdot j + dp_{i-1,j-1} \cdot (j-1)$，两个 dp 值分别表示当前节点的父亲不要/要继续接节点。$a_j=1$ 也是一样，$dp_{i,j}=dp_{i-1,j}\cdot j+dp_{i-1,j+1} \cdot (j+1)$。对于另一棵树也是同理。

可以发现这个 dp 本质上计算的是：对于每个满足 $b_0=b_n=0$，若 $a_i=0$ 则 $b_i=b_{i-1}$ 或 $b_{i-1}+1$，若 $a_i=1$ 则 $b_i=b_{i-1}$ 或 $b_{i-1}-1$ 的 $b$ 序列，对 $\prod\limits_{i=1}^{n-1} b_i$ 求和。

发现这个过程是可以倒推的，所以直接将这两棵树当前的 $b$ 的值记录进状态即可。设 $dp_{i,j,k}$ 表示考虑了前 $i$ 个点，第一棵树的 $b_i=j$，第二棵树的 $b_{i+1}=k$。$i+1$ 的原因是在第二棵树中加入 $i$ 点决定的是 $b_{i+1}$ 与 $b_i$ 的关系。转移是简单的。

实现的时候可以将 $j,k$ 可能的 8 种移动方式（$a_i=0/1$，两棵树分别从 $i$ 还是 $i\pm 1$ 转移）放到两个数组里。取模可以最后取，防止被卡常。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dj[]={-1,-1,0,0,0,0,1,1};
int dk[]={-1,0,-1,0,0,1,0,1};
int n,mod;
long long dp[2][501][501];
int main()
{
	cin>>n>>mod;
	dp[0][0][0]=1;
	for(int i=1; i<=n; ++i)
	{
		memset(dp[i&1],0,sizeof(dp[i&1]));
		for(int j=0; j<=i; ++j)
		{
			for(int k=0; k<=n-i; ++k)
			{
				for(int l=0; l<8; ++l)
				{
					int tj=j+dj[l],tk=k+dk[l];
					if(tj<0 || tk<0) continue;
					dp[i&1][j][k]+=dp[i-1&1][tj][tk]*(i==1?1:tj);
				}
				dp[i&1][j][k]=dp[i&1][j][k]*k%mod;
			}
		}
		if(i!=1)
		{
			int j=0,k=0; long long ans=0;
			for(int l=0; l<8; ++l)
			{
				int tj=j+dj[l],tk=k+dk[l];
				if(tj<0 || tk<0) continue;
				ans=(ans+dp[i-1&1][tj][tk]*tj)%mod;
			}
			cout<<ans<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：FjswYuzu (赞：9)

ZJOI 的签到题，恐怖如斯。计数水平太低，我很抱歉。

---

首先记一个 $f(S)$ 表示 $T_1$ 的叶子/非叶子集合为 $S$ 的方案数。如果我们求叶子集合为 $S$ 的方案数是一件非常麻烦的事情，那么只有令 $f(S)$ 表示 $T_1$ 的非叶子集合为 $S$ 的方案数。

当然直接求 $f$ 也比较困难。考虑容斥，记 $g(S)$ 表示非叶子结点集合是 $S$ 的子集的方案数，容易得到：

$$
f(S) = \sum_{T ⊆ S} (-1)^{|T|} g(S \backslash T)
$$

其中，$\displaystyle g(S) = \prod_{i=2}^n \left(\sum_{j \in S} [i<j] \right)$。两个式子的意义都非常显然，不再赘述。当然 $1 \in S,T$，虽然不在也行没有影响。

接下来的问题是，我们只处理掉了一棵树，还有一棵树怎么办？

容易发现另外一棵树的贡献形式与第一棵树类似。那么记 $f_c,g_c$ 是 $T_c$ 中的 $f,g$（容易发现 $g_1,g_2$ 有形式上的区别，本质相同），那么答案就长成：

$$
\begin{aligned}
\sum_{S} f_1(S)f_2(U \backslash S)
&= \sum_{S} \sum_{T_1 ⊆ S} (-1)^{|T_1|} \sum_{T_2 ⊆ (U \backslash S)} (-1)^{|T_2|} g(S \backslash T_1)g(U \backslash (S \cup T_2)) \\
&= \sum_{S} \sum_{T_1 ⊆ S} \sum_{T_2 ⊆ (U \backslash S)} (-1)^{|T_1|+|T_2|} \prod_{i=2}^n \left(\sum_{j \in (S \backslash T_1)} [j<i] \right) \prod_{i=1}^{n-1} \left(\sum_{j \in (U \backslash (S \cup T_2))} [i<j]\right)
\end{aligned}
$$

---

做法 $1$：

因为一个点 $p$ 只会在一棵树内成为叶子，这个形式已经可以直接容斥了。

那么分四类讨论：

- $p \in S$，但 $p \not \in T_1$；   
- $p \in T_1$；   
- $p \not \in S$，且 $p \not \in T_2$；   
- $p \in T_2$。

注意到点 $1,n$ 很烦，我们暂先将这两个点排除。

分析 $g_1,g_2$ 的结构，我们需要知道 $T_1$ 非叶子结点个数的前缀和和 $T_2$ 非叶子结点个数的后缀和。

那么定义 $dp_{i,j,k}$ 表示，现在考虑了前 $i$ 个点，$T_1$ 内已经出现了 $j$ 个非叶子结点（含点 $i$），$T_2$ 内编号在 $[i+1,n]$ 的非叶子结点个数为 $k$。

然后这个转移形式比较显然，对着做就好了。答案为 $\displaystyle \sum_{i} dp_{n-1,i,1} \times i$，因为 $T_1$ 中 $n$ 是叶子，随机连一个钦定的非叶子结点就好了。

---

做法 $2$：

这个形式好\*\*丑啊！！

通过打表发现，$f_1(S) = f_2(U \backslash S)$。代数证明可以看知乎题解。

那么问题就变成了两棵树按 $T_1$ 的方式生成。求两棵树叶子集合相等的方案数。

做法 $2.1$：

那么现在就是求 $\displaystyle \sum_{S} f^2(S)$。这个形式一样的展开，比上面那个方法好写。

还是写一下，$f,g$ 的定义见上。

$$
\begin{aligned}
\sum_{S} f(S)^2
&= \sum_{T_1 ⊆ S} \sum_{T_2 ⊆ S} (-1)^{|T_1|+|T_2|} g(S \backslash T_1)g(S \backslash T_2) \\
&= \sum_{T_1 ⊆ S} \sum_{T_2 ⊆ S} (-1)^{|T_1|+|T_2|} \prod_{i=2}^n \left( \sum_{j \in (S \backslash T_1)} [j<i] \right) \left( \sum_{j \in (S\backslash T_2)} [j<i] \right)
\end{aligned}
$$

这个基本上已经是完全态了。因为 $\prod$ 后面带的式子上下角标一样了，我们可以合并。

定义 $dp_{i,j,k}$ 表示处理了 $i$ 个点，当前的 $|T_1|=j,|T_2| = k$。我们从小到大加入点，系数就不必重算一次 $\prod$ 内的 $\sum$ 了。

那么，仍然是分类讨论：

- $p \not \in S$；   
- $p \in T_1 \cap T_2$；   
- $p \in T_1, p \not \in T_2$；   
- $p \in T_2, p \not \in T_1$；   
- $p \not \in T_1 \cup T_2$。

顺着系数转移就好了。记 $p = dp_{i,j,k} \cdot jk$（下面的转移与上面的转移一一对应）:

- $p \to^+ dp_{i+1,j,k}$；   
- $p \to^+ dp_{i+1,j+1,k+1}$；   
- $p \to^- dp_{i+1,j+1,k}$；   
- $p \to^- dp_{i+1,j,k+1}$；   
- $p \to^+ dp_{i+1,j,k}$。

其中 $a \to^+b$ 表示 $b \gets b+a$，$a \to^- b$ 表示 $b \gets b-a$。

做法 $2.2.1$：

那么考虑定义 $dp_{i,j,k_1,k_2}$ 表示前 $i$ 个点里，有 $j$ 个共同的叶子，$k_1$ 表示 $T_1$ 内为叶子但在 $T_2$ 内不是叶子，$k_2$ 同理的方案数。可以分类讨论转移，时间复杂度是 $O(n^4)$ 的。

做法 $2.2.2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/wsmytomp.png)

（为保护当事人隐私，已将头像进行模糊处理。）

那我们就不考虑 $j$。再定义 $dp_{i,k_1,k_2}$ 表示考虑了 $i$ 个点，$k_1$ 表示 $T_1$ 内有 $k_1$ 个非叶子结点的度还没有填。

那么只有两个转移，一个是 $i$ 为叶子结点，另一个就是不是叶子结点。转移显得更简单了。相应的复杂度变高了，时间复杂度 $O(n^5)$。

做法 $2.2$：

答案是可以通过[奇怪的生成函数技巧](https://www.zhihu.com/question/531164650/answer/2468389537)优化 $2.2.2$ 求得和做法 $2.1$ 一模一样的转移式子。

[Code(做法 2.2.1)](https://www.luogu.com.cn/paste/xx762ad3)；    
[Code(做法 2.1/2.2)](https://www.luogu.com.cn/paste/6pxoojdo)。

Key observation: 容斥的合并。

---

## 作者：panyf (赞：9)

暴力 dp：$f(i,j,k,l)$ 表示考虑前 $i$ 个点，第一棵树前 $i$ 个点有 $j$ 个非叶子，其中有 $k$ 个还没有儿子，第二棵树有 $l$ 个点没有确定父亲（父亲编号大于 $i$）的方案数。

转移时若第 $i+1$ 个点在第一棵树中是叶子，则需要枚举 $o$ 表示其在第二棵树中有 $o$ 个儿子。复杂度 $O(n^5)$。

发现这个做法的瓶颈是处理“某个点不是叶子”的限制，考虑用容斥避免这种限制。

记 $p(S)$ 表示第一棵树集合 $S$ 不是叶子，其他都是叶子的方案数；$q(S)$ 表示第二棵树。

记 $f(S)$ 表示第一棵树钦定集合 $S$ 以外的点都是叶子，集合 $S$ 不确定的方案数（这样就不需要考虑非叶子有没有儿子了）；$g(S)$ 表示第二棵树。

根据定义有 $f(S)=\sum_{T\subset S} p(T)$，子集反演（容斥）一下得到 $p(S)=\sum_{T\subset S} f(T)(-1)^{|S|-|T|}$。

结点总数为 $n$ 时，$ans=\sum_{1\in S,n\notin S}p(S)q(\{1,2\cdots n\}/S)=\sum_{1\in S,n\notin S}\sum_{U\subset S}\sum_{V\subset\{1,2\cdots n\}/S}f(U)g(V)(-1)^{n-|U|-|V|}$。

考虑带着 $(-1)^{n-|U|-|V|}$ 这个容斥系数 dp，$f(i,j,k)$ 表示考虑两棵树前 $i$ 个点的连边方案，$|U|\cap\{1,2\cdots i\}=j$，$|V|\cap\{i+1,i+2\cdots\}=k$ 的方案数乘上容斥系数。

初始值 $f(1,1,i)=i$，表示点 $1$ 在第一棵树中不是叶子，在第二棵树中是叶子，在第二棵树中点 $1$ 的父亲有 $i$ 种方案，并且容斥系数 $(-1)^{1-1-0}=1$。

转移：

考虑用 $f(i,j,k)$ 转移。

1.若 $i+1\in S$，则 $i+1\notin V$。

1.1 $i+1\in U$，$n$ 加 $1$，$|U|$ 加 $1$，$|V|$ 不变，所以容斥系数不变，$f(i+1,j+1,k)\leftarrow f(i+1,j+1,k)+f(i,j,k)\times j\times k$，$j\times k$ 表示第一棵树中 $i+1$ 有 $j$ 种选父亲的方案，第二棵树有 $k$ 种。

1.2 $i+1\notin U$，容斥系数乘 $-1$，$f(i+1,j,k)\leftarrow f(i+1,j,k)-f(i,j,k)\times j\times k$。

2.若 $i+1\notin S$，则 $i+1\notin U$。

2.1 $i+1\in V$，$f(i+1,j,k-1)\leftarrow f(i+1,j,k-1)+f(i,j,k)\times j\times (k-1)$。

2.2 $i+1\notin V$，$f(i+1,j,k)\leftarrow f(i+1,j,k)-f(i,j,k)\times j\times k$。

最后，$ans_{i+1}=\sum_{ 1\leq j\leq i} f(i,j,1)\times j$，表示第二棵树的 $i+1$ 是非叶子，枚举 $|U|$ 的值 $j$，第一棵树的结点 $i+1$ 有 $j$ 种选父亲的方案。

时间复杂度 $O(n^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
enum{N=509};
int f[N][N];
int main(){ios::sync_with_stdio(0);cin.tie(0);
	int n,p,i,j,k,l,o,u;
	cin>>n>>p;
	for(i=1;i<n;++i)f[1][i]=i;
	for(i=1;i<n;++i){
		for(j=1,o=0;j<=i;++j)o=(o+f[j][1]*1ll*j)%p;
		cout<<o<<'\n';
		for(j=i;j;--j){
			for(k=1;k<=n-i;++k){
				l=f[j][k]*1ll*j%p,o=l*1ll*k%p,u=p-o;
				if(u==p)u=0;
				if((f[j+1][k]+=o)>=p)f[j+1][k]-=p;
				if((f[j][k]=u+u)>=p)f[j][k]-=p;
				if((o-=l)<0)o+=p;
				if((f[j][k-1]+=o)>=p)f[j][k-1]-=p;
			}
		}
	}
}
```

---

## 作者：Talaodi (赞：7)

介绍一种完全不需要容斥的做法。

先来考虑按 $1\sim n$ 的顺序动态加点，并维护第二颗树的形态。发现加点的过程中第二棵树在某一时刻会有若干个连通块。如果钦定当前加入的点最后为叶子，只需要让其单独成一个连通块即可；如果钦定当前加入的点最后不是叶子，那么就要选择一些连通块作为其子树。显然在这个过程中，我们所钦定的都是肯定可以满足的，因此不需要使用容斥。

如果直接将连通块个数 $j$ 记录进状态中，会发现转移复杂度较高，由于要枚举当前点要接多少个，是 $O(N)$ 的，无法接受。考虑修改状态使得可以 $O(1)$ 转移。发现对于当前的若干个连通块，我们可以对其进行分组，并且钦定在同一组的最后都会连到同一个父亲（当前还未确定）。将状态设为当前有 $j$ 组。这样，转移的时候就不再需要枚举个数，直接选择一个组成为它们的父亲就行了。对于当前的点，有合到之前的一个组和单独成组两种选择，分别有 $j$ 和 $1$ 的系数。

这样我们就可以正序加点处理第二棵树了，而我们要同时处理第一棵树，考虑把这个过程倒过来处理。

设 $f_{i,j,k}$ 表示考虑到了第 $i$ 个点，第一棵树的 $i+1\sim n$ 的点组成的连通块有 $j$ 组，第二棵树的 $1\sim i$ 的点组成的连通块有 $k$ 组。分 $i+1$ 在两棵树中是否是叶子转移。转移是 $O(1)$ 的。

[代码](https://www.luogu.com.cn/paste/hllkzoj4)。未经卡常常数较大。

时间复杂度：$O(N^3)$。


---

## 作者：zxtikes (赞：5)

## 前言

懒得做题目描述了，题目说的也很清楚了，不需要我再加以诠释了。

很明显是计数问题，下面就开始讲解吧。


------------
## 解题思路

$F(S)$ 表示在第一棵树中，非叶子节点的集合为 $S$ 生成的树的方案数。

$G(T)$ 表示在第二棵树中，非叶子节点的集合为 $T$ 生成的树的方案数。

$U$ 表示所有节点的集合即全集，$U=\{1,2,...,n\}$ 。

题目让我们所求的东西就是如下：

$$
\sum_{S\cap T=\varnothing,S\cup T=U}{F(S)G(T)}
$$

由于两种树的生成方式是对称的，所以不失一般性，我们考虑对第一棵树生成方案数 $F(S)$ 的求法。

我们直接去求 $F(S)$，显然复杂且无从下手，不妨考虑容斥 ~~（题目标签不是有吗）~~ ，容斥的公式比较简单，通常表达如下所示：

$$
\bigcup_{i=1}^{n}S_i=\sum_{i=1}^{n}|S_i| - \sum_{1\leq i<j\leq n} |S_i\cap S_j|+\sum_{1\leq i<j<k\leq n}|S_i\cap S_j\cap S_k|-...+(-1)^{n-1}\times |S_1\cap ...\cap S_n|
$$

$f(S')$ 表示所有非叶子节点集合属于 $S'$ 生成树的方案数。

$g(T')$ 表示所有非叶子节点集合属于 $T'$ 生成树的方案数。

那么：

$$
F(S)=\sum_{S'\subseteq S}{f(S')\times (-1)^{|S|-|S'|}}
$$

$G(T)$ 求法也是同理，公式形式相同。

$$
G(T)=\sum_{T'\subseteq T}{g(T')\times (-1)^{|T|-|T'|}}
$$

我们考虑一点，$S'\subseteq S,T'\subseteq T,S\cap T=\varnothing,S\cup T=U$ 。如果我们将 $F(S),G(T)$ 用容斥表达的多项式相乘，实际上相同的 $f(S')$ 与 $g(T')$ 相乘（还有容斥系数），被计算了多次，计算的次数也很好想。

如果我们不考虑 $S\cap T=\varnothing,S\cup T=U$ 的条件，构建 $f(S')$ 的计算系数如下。

对于 $S'\subseteq S,S\subseteq U$ ，满足条件的 $S$ 的个数为 $2^{n-|S'|}$ ，原因是我们从 $U$ 中选取能够构成满足条件的 $S$ ，其中 $|S'|$ 个数确定必须选择，剩余的 $n-|S'|$ 个数可以选择也可以不选择，一共就构成了这么多种方案。

如果我们考虑 $S\cap T=\varnothing,S\cup T=U$ 的条件，实际上也只是在剩余的数中继续选择 $|T'|$ 个，即 $f(S')\times g(T')$ 的计算系数为 $2^{n-|S'|-|T'|}$ ，容斥系数 $(-1)^{|S|-|S'|+|T|-|T'|=n-|S'|-|T'|}$ ，那么我们最后得到这样的式子。

$$
\sum_{S\cap T=\varnothing,S\cup T=U}{F(S)G(T)}=\sum_{S'\cap T'=\varnothing}{f(S')\times g(T')\times (-2)^{n-|S'|-|T'|}}
$$


------------
## 具体实现

用 $dp_{i,j,k}$ 表示当树中存在 $i$ 个节点时，第一棵树中非叶子节点有 $j$ 个，第二棵树中非叶子节点 $k$ 个所包含的方案数。

$dp_{i,j,k}$ 状态含义：前 $i-1$ 个节点都已经被确定了，所以我们考虑当前节点 $i$ 所属于的状态（$i\in S'$ 或 $i\in T'$ 或 $i\notin S',i\notin T'$）。

根据状态我们分别对应如下转移。

1. $dp_{i-1,j,k}\times j\times k\rightarrow dp_{i,j+1,k}$ 。
2. $dp_{i-1,j,k}\times j\times k\rightarrow dp_{i,j+1,k-1}$ 。
3. $dp_{i-1,j,k}\times (-2)\times j\times k\rightarrow dp_{i,j,k}$ 。

时间复杂度 $O(n^3)$ ，勉强能过，题目卡常（本人亲测）。所以数组要么开小（因为第一维状态 $i$ 只与 $i-1$ 有关，所以可以用滚动第一维），或者是数组就用 $32$ 整型。


------------
## 参考代码
```cpp
#include<bits/stdc++.h>
#define ll long long 
#define inf 1e9
#define rep(i,l,r) for(register int i=l;i<=r;++i)
#define per(i,r,l) for(register int i=r;i>=l;--i)
using namespace std;
const int N=510;

int n,Mod;
int dp[N][N][N],ans[N];
int main(){
	scanf("%d%d",&n,&Mod);
	rep(i,1,n-1)dp[1][1][i]=1;// 初始 
	rep(i,2,n){
		rep(j,1,i-1){
			rep(k,1,n-i+1){
				dp[i][j][k]-=2ll*dp[i-1][j][k]%Mod*j%Mod*k%Mod,dp[i][j][k]=(dp[i][j][k]%Mod+Mod)%Mod;
				//第三种状态转移（容斥） 
				dp[i][j+1][k]+=(ll)dp[i-1][j][k]*j%Mod*k%Mod,dp[i][j][k]%=Mod;
				//第一种状态转移 
				dp[i][j][k-1]+=(ll)dp[i-1][j][k]*j%Mod*k%Mod,dp[i][j][k-1]%=Mod;
				//第二种状态转移 
				if(k==1)ans[i]+=(ll)dp[i-1][j][k]*j%Mod*k%Mod,ans[i]%=Mod;//
			}
		}
	}
	rep(i,2,n)printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：FZzzz (赞：4)

~~蹭热度。~~

考虑 $A$ 为第一棵树的叶子集合，它的补集 $B$ 为第二棵树的叶子集合。考虑容斥，钦定一个集合为叶子，可以算出贡献：
$$\left(\sum_{A\subseteq S}(-1)^{|S|-|A|}w_1(S)\right)\left(\sum_{B\subseteq T}(-1)^{|T|-|B|}w_2(T)\right)$$
其中 $w_1(S)$ 为 $S$ 内的集合在第一棵树里都是叶子，第一棵树的方案数。它的计算方法就是每个节点前面有多少不属于 $S$ 的节点，然后乘起来。$w_2$ 同理。

现在我们考虑一对 $(S,T)$ 的贡献。首先它们的并需要为全集。对于它们的交中的每个元素，它可能属于 $A$ 也可能属于 $B$，但无论哪种情况都会贡献一个 $-1$。所以贡献是：
$$(-2)^{|S\cap T|}w_1(S)w_2(T)$$
那么可以直接 dp 了，对每个点决策它是属于 $S-T$，$T-S$ 还是 $S\cap T$。状态需要记录当前点前面（包括自己）有多少个不属于 $S$ 的点，后面有多少个不属于 $T$ 的点。

时间复杂度 $O(n^3)$。我循环上界不精细考虑的话就会被卡常卡飞，不知道为什么别人没有这种情况。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=500+5;
int n,p;
inline void add(int& x,int y){
	x=(x+y)%p;
}
int f[2][maxn][maxn];
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	p=read();
	for(int i=1;i<n;i++) f[1][1][i]=i%p;
	printf("1\n");
	for(int i=2;i<n;i++){
		memset(f[i%2],0,sizeof(f[0]));
		for(int j=1;j<i;j++) for(int k=1;k<=n-i+1;k++){
			int res=f[(i-1)%2][j][k];
			add(f[i%2][j][k-1],1ll*res*j*(k-1)%p);
			add(f[i%2][j+1][k],1ll*res*j*k%p);
			add(f[i%2][j][k],1ll*res*j*k%p*(p-2)%p);
		}
		int ans=0;
		for(int j=1;j<=i;j++) add(ans,1ll*f[i%2][j][1]*j%p);
		printf("%d\n",ans);
	}
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：wurzang (赞：4)

做法 1： $f_{i,j,a,b}$ 表示前 $i$ 个点中，有 $j$ 个点是第一棵树中没有儿子的非叶子结点，有 $a$ 个点是第一棵树中的叶子结点，有 $b$ 个点在第二棵树中没有父亲。分类讨论第 $i$ 个点在第一棵树上是叶子结点还是非叶子结点，转移 $\mathcal{O}(n)$，复杂度 $\mathcal{O}(n^5)$，卡常可以卡到 60 分。

做法 2： 

容斥，将第一棵树上的非叶子结点钦定为叶子结点，设钦定个数为 $S$，容斥系数显然为 $(-1)^S$

$f_{i,j,k}$ 表示前 $i$ 个点中，第一棵树没有被容斥的非叶子结点有 $j$ 个，第二棵树没有父亲的点有 $k$ 个。

转移则分类讨论：  


1. 在第二棵树上是非叶子结点(在第一棵树上是叶子结点)： $f_{i,j,a} \times \binom a b \times j \to f_{i+1,j,a-b+1}$

2. 在第二棵树上是叶子结点(在第一棵树上是非叶子结点)：

	2.1. 被容斥了 $f_{i,j,k} \times (-1) \times  j \to f_{i+1,j,k+1}$

	2.2 没有被容斥 $f_{i,j,k} \times j \to f_{i+1,j+1,k+1}$

复杂度 $\mathcal{O}(n^4)$，在质数情况下可以用前缀和优化到 $\mathcal{O}(n^3)$，可以得到 80 分。

做法 3：

做法 2 是对第一棵树进行容斥，考虑对两棵树进行容斥。所有的点要么是第一棵树的叶子要么是第二棵树的叶子，而容斥则钦定原本是第一棵树的叶子是第二棵树上的叶子，或者原本是第二棵树的叶子是第一棵树上的叶子。

设 $f_{i,j,k}$ 表示前 $i$ 个点中有 $j$ 个点**不**是第一棵树上的叶子，而后 $n-i$ 个点中有 $k$ 个点**不**是第二棵树上的叶子。

转移也是分类讨论，复杂度 $\mathcal{O}(1)$，总复杂度 $\mathcal{O}(n^3)$



---

## 作者：xay5421 (赞：2)

讲讲我场上奇奇怪怪的做法，不过被卡常了。（加个快速模就过了）

考虑 f(i,j,k) 表示考虑前 i 个点，其中 tree1 上有**至多** j 个非叶子，和 tree2 上有 k 个没选父亲的节点。（注意这个"至多"，因为我们是可以钦定 tree1 某个点是叶子，但是我们不能钦定 tree1 某个点是非叶子，因为我们不知道后面究竟有没有点连向它，简单来说就是容斥）

转移很简单:

$$
f(i,j,k)=f(i-1,j-1,k-1)\times j-f(i-1,j,k-1)\times j+\sum_{take\ge 1}f(i-1,j,k+take-1)\times \binom{k+take-1}{take}\times j
$$

其中 $f(i-1,j-1,k-1)\times j-f(i-1,j,k-1)\times j$ 表示 tree2 这个点是叶子，这里在容斥，我们需要 tree1 这个点非叶子，就是 这个点任意-钦定这个点是叶子 的方案数

后面表示 tree2 这个点是非叶子，我们选 take(take>=1) 个做为这个点的孩子，那么这个点就是 tree2 的非叶子，然后钦定这个点是 tree1 的叶子

这个做法状态数是 $O(n^3)$，转移复杂度 $O(n)$，总复杂度是 $O(n^4)$，过不去，考虑优化

怎么优化呢，后面那个东西有点奇怪，可以用卷积优化，这样复杂度是 $O(n^3\log n)$，还有模数不是质数的问题

我们希望复杂度是 $O(n^3)$，卷积会多 $\log$。

我们考虑维护点值，前面的部分很好维护，后面的部分实际上是点值平移，即 $f_{(i,j)}(x)=xf_{(i-1,j)}(x+1)$，因为 take>=1，这个操作把 take=0 也算进去了，因此还要减去 take=0 时多算的一些系数。然后我们顺利的维护出了点值。

答案 $Ans_n =[x^1]\sum_i f_{(n,i)}(x)$

还有最后一步，我们现在只有点值，怎么求 $[x^1]F$ 呢，还要在任意模数下

观察一下发现 $f(i,j,0)$ 都是 0，也就是 $f_{(i,j)}(x)$ 的常数项都是 0，我们把所有 $f_{(i,j)}(x)$ 都除掉那个 $x$，就是一开始就从 0 下标开始

于是答案变成了 $Ans_n =[x^0]\sum_i f_{(n,i)}(x)$

根据拉格朗日插值

$$
\begin{aligned}
Res&=[x^0]\sum_{i}y_i\prod_{j\neq i}\frac{x-j}{i-j}\\
&=\sum_{i}y_i\frac{\frac{n!}{i}(-1)^{n-1}}{(i-1)!(n-i)!(-1)^{n-i}}\\
&=\sum_{i}y_i(-1)^{i-1}\binom{n}{i}
\end{aligned}
$$

组合数预处理，任意模数都可以做

```cpp
#include<bits/stdc++.h>
#ifdef xay5421
#define D(...) fprintf(stderr,__VA_ARGS__)
#else
#define D(...) ((void)0)
#endif
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
#define each(x,v) for(auto&x:v)
#define SZ(x) ((int)(x).size())
#define pb push_back
#define eb emplace_back
using namespace std;
int P;
inline int ad(int x,int y){return x+y>=P?x+y-P:x+y;}
inline void uad(int&x,int y){(x+=y)>=P&&(x-=P);}
inline int su(int x,int y){return x-y<0?x-y+P:x-y;}
inline void usu(int&x,int y){(x-=y)<0&&(x+=P);}
struct FastMod {
	unsigned long long b, m;
	FastMod(unsigned long long b) : b(b), m((unsigned long long)((__uint128_t(1) << 64) / b)) {}
	unsigned long long operator()(unsigned long long a) {
		unsigned long long q = (unsigned long long)((__uint128_t(m) * a) >> 64);
		unsigned long long r = a - q * b; // can be proven that 0 <= r < 2*b
		return r >= b ? r - b : r;
	}
}M(998244353);
inline int mu(int x,int y){return M(1ULL*x*y);}
const int N=505;
int n,f[2][N][1010],g[1010],C[1010][1010]; // f[i][j][k]: 前 i 个，j 个 tree1 非叶子，k 个 tree2 的点没选父亲
int main(){
	scanf("%d%d",&n,&P);
	M=FastMod(P);
	rep(i,0,1010-1){
		C[i][0]=1;
		rep(j,1,i)C[i][j]=ad(C[i-1][j-1],C[i-1][j]);
	}
	int tot=1005;
	rep(i,1,tot){
		f[1][1][i]=1;
	}
	rep(i,2,n){
		memset(f[i&1],0,sizeof(f[i&1]));
		rep(j,1,i){
			rep(k,1,tot-1){
				f[i&1][j][k]=ad(su(mu(f[(i-1)&1][j-1][k],mu(j-1,k)),mu(f[(i-1)&1][j][k],mu(j,ad(k,k)))),mu(f[(i-1)&1][j][k+1],mu(j,k+1)));
			}
		}
		--tot;
		rep(k,1,n)g[k]=0;
		rep(j,1,n){
			rep(k,1,n){
				uad(g[k],f[i&1][j][k]);
			}
		}
		int ans=0;
		rep(k,1,n){
			uad(ans,mu(g[k],mu(C[n][k],(k-1)&1?P-1:1)));
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Anita_Hailey (赞：1)

## 树

### 题意

给你两棵树，然后要求第一棵树里每个点向着自己编号小的点连边，第二个是自己大的点连边。

称一种方案是好的当且仅当对于第一棵树的一个非叶子节点，它是第二棵树的叶子节点；对于第二棵树的非叶子节点，它是第一棵树的叶子节点。

$n\le 500$

### 题解

我们考虑容斥计算答案，设 $w1(S)$ 表示 $S$ 里边的节点在第一个树里都是叶子，然后 $w2(S)$ 表示 $S$ 子集里的节点在第二个树里都是叶子。（这时候其他东西也可能是叶子）

然后容斥。

应该是求

$$
\sum_{A\cap B = \emptyset, A \cup B = S}\sum _{A \subseteq C,B \subseteq D} (-1)^{\vert C\vert + \vert D\vert - N}w_1(C)w_2(D)
$$

就是首先枚举两个叶子集合。然后左边容斥一下，右边容斥一下。

考虑每一对 $S,T$ 的贡献，首先他们的并得是全集，然后对于他们的交里的元素，可能属于 $A$ 或者是 $B$。所以说，这种情况下，贡献应该是
$$
(-2)^{C\cap D}w_1(C)w_2(D)
$$
我们就可以直接 $dp$，设 $f[i][j][k]$ 表示从前往后决策到了第 $i$ 个位置，前面 $i$ 个位置有 $j$ 个点不是第一个树叶子，后面 $n-i$ 个点，有 $k$ 个不是第二个树的叶子。

考虑转移，我们考虑用两个集合 $C,D$ 来完成转移，后面的转移系数是这个节点在两棵树上的祖先选择方案。

- 如果分配到了两个的并集 $C\cap D$ 的时候 $f[i + 1][j][k] -= 2 \times f[i][j][k] \times j \times k$
- 分配到 $D$，那么他在第一个树里是非叶子，$f[i+1][j][k]+= f[i][j - 1][k] \times (j - 1)\times k$
- 分配到 $C$，那么他在第二个树里是非叶子，$f[i + 1][j][k] += f[i][j][k + 1] \times j\times k$

然后初始值是 $f[1][1][i] = i$，表示 $1$ 这个节点在第二棵树的父亲有 $i$ 个取值。

```cpp
#include<bits/stdc++.h>
using ll = long long;
const int MAXN = 505;
ll MOD, dp[2][MAXN][MAXN];
int N;
int main() {
	scanf("%d %lld", &N, &MOD);
	for (int i = 1; i < N; ++i) dp[1][1][i] = i;
	for (int i = 2, nw = 0; i <= N; ++i, nw ^= 1) {
		memset(dp[nw], 0, sizeof dp[nw]);
		ll ans = 0;
		for (int j = 1; j < i; ++j) {
			for (int k = 1; k <= N - i + 1; ++k) if (dp[nw ^ 1][j][k]) {
				// 从 dp[i - 1][j][k] 转移
				dp[nw][j][k] = (dp[nw][j][k] - 2LL * j * k * dp[nw ^ 1][j][k] % MOD + MOD) % MOD;
				dp[nw][j + 1][k] = (dp[nw][j + 1][k] + (ll) dp[nw ^ 1][j][k] * j * k) % MOD;
				if (k > 1) dp[nw][j][k - 1] = (dp[nw][j][k - 1] + (ll) dp[nw ^ 1][j][k] * j * (k - 1)) % MOD;
				else ans += (ll) dp[nw ^ 1][j][k] * j;
			}
		}
		printf("%lld\n", ans % MOD);
	}
	return 0;
}
```

---

## 作者：tuo3288 (赞：1)

#### 题意简述

需要构造两棵树：

$Tree1: root=1, \ fa_i \in [1,i) \ s.t. \ i \in (1,n]$

$Tree2: root=n, \ fa_i \in (i,n] \ s.t. \ i \in [1,n)$

相同编号的两个节点必须在一颗树中为叶子节点而在另一颗中为非叶子节点，求总方案数。

#### 题目分析

首先按照题意模拟：

$T :=$ 节点全集

$f_S :=$ 集合 $S$ 中的节点作为 $Tree1$ 的叶子节点的方案数

$g_S :=$ 集合 $S$ 中的节点作为 $Tree2$ 的叶子节点的方案数

则 $Ans = \sum_{S \in T} \ (f_S \times g_{T \setminus S})$

$f$ 并不是很好快速求，因为对于从 $1$ 到 $n$ 的每一个点，我们可以钦定其是否在第一颗树中作为叶子节点，但是难以保证钦定一个点不是叶子节点时其在后续过程中接上一个子节点； $g$ 也需要在钦定一个点不是叶子节点时需要枚举子节点集合也不是很好求。

容斥一下：

$F_S := Tree1$ 的叶子节点集合包含 $S$ 的方案数

$G_S := Tree2$ 的叶子节点集合包含 $S$ 的方案数

可以得到：

$$
\begin{aligned}
Ans &= \sum_{S \in T} \ (\sum_{S \in U} \ ((-1)^{|U|-|S|}F_U) \times \sum_{T \setminus S \in V} \ ((-1)^{|V|-|T \setminus S|} G_V))
\\  &= \sum_{S \in T} \ (\sum_{S \in U} \ ((-1)^{|U|-|S|}F_U) \times \sum_{V \in S} \ ((-1)^{|T \setminus V|-|T \setminus S|} G_{T \setminus V}))
\\  &= \sum_{U \in T} \ \sum_{V \in U} \ (F_U \times G_{T \setminus V}) \  \sum_{V \in S \in U } \ (-1)^{|U|-|S|+|S|-|V|} 
\\  &= \sum_{U \in T} \ \sum_{V \in U} \ ((-2)^{|U|-|V|} \times F_U \times G_{T \setminus V})
\end{aligned}
$$

现在可以从 $1$ 到 $n$ 进行 $dp$ ，考虑每一个点是在 $U$ 中还是在 $T \setminus V$ 中还是都在（放入 $S$ 中即钦定为 $Tree1$ 叶子节点，放入 $T \setminus V$ 即钦定为 $Tree2$ 叶子节点）。

$dp_{i,j,k} :=$ 当前枚举到第 $i$ 个点，前 $i$ 个点中有 $j$ 个点在 $U$ 中，后面的点中有 $k$ 个在 $V$ 中

这样我们当加入点 $i+1$ 时，在 $Tree1$ 中有 $i-j$ 个点可选作父节点（放入第一个点时有 $"1"$ 个点可选做父节点需要特判），在 $Tree2$ 中视这个点是否放入 $T \setminus V$ 中可选 $k-1$ 或 $k$ 个点可选做父节点。

转移很简单（因为 $V$ 是 $U$ 的子集，所以放入 $V$ 一定会放入 $U$ ）：

1. 同时放入 $U,V$ 中，即放入 $U$ 中不放入 $T \setminus V$ 中：
  
  $dp_{i+1,j+1,k-1} \leftarrow dp_{i,j,k} \times (i-j)(k-1) \quad s.t. \ k \gt 0$
  
2. 只放入 $U$ 中，即同时放入 $U,T \setminus V$ 中（注意这里的 $|U|-|V|$ 发生了变化）：
  
  $dp_{i+1,j+1,k} \leftarrow dp_{i,j,k} \times (-2)(i-j)k$
  
3. 不放入 $U$ 或 $V$ 中，即只放入 $T \setminus V$ 中：
  
  $dp_{i+1,j,k} \leftarrow dp_{i,j,k} \times (i-j)k$
  

一共有 $O(n^3)$ 个状态，而转移是 $O(1)$ 的， $n \le 500$ ，所以可以过。

初始状态只需要枚举$|V|$的大小，即 $dp_{0,0,k}=1 \quad s.t. \ k \in [0,n]$

因为最后要在$Tree2$中留下一个根，所以 $Ans_{i+1} = \sum_{j=0}^i \ ((i-j) \times dp_{i,j,1}) $

#### 代码

```cpp
#include <array>
#include <iostream>

using namespace std;
constexpr int maxn = 505;

int n, m;
array< int, maxn > a;
array< array< array< int, maxn >, maxn >, maxn > f;
auto mul = []( int x, int y ) { return (long long) x * y % m; };
auto sub = []( int x, int y ) { return x < y ? x - y + m : x - y; };
auto add = []( int x, int y ) { return x + y < m ? x + y : x + y - m; };

int main()
{
    cin.tie( nullptr )->sync_with_stdio( false ), cin >> n >> m;
    for ( int i = 0; i <= n; i++ )
        f[ 0 ][ 0 ][ i ] = 1;
    for ( int i = 0; i <= n; i++ )
        for ( int j = 0; j <= i; j++ )
            for ( int k = 0; i + k <= n; k++ )
                if ( f[ i ][ j ][ k ] )
                {
                    if ( k )
                        f[ i + 1 ][ j + 1 ][ k - 1 ] = add(
                            f[ i + 1 ][ j + 1 ][ k - 1 ],
                            mul( f[ i ][ j ][ k ], mul( i ? i - j : 1, k - 1 ) ) );
                    f[ i + 1 ][ j + 1 ][ k ] = sub( f[ i + 1 ][ j + 1 ][ k ],
                        mul( f[ i ][ j ][ k ], mul( 2, mul( i ? i - j : 1, k ) ) ) );
                    f[ i + 1 ][ j ][ k ] = add( f[ i + 1 ][ j ][ k ],
                        mul( f[ i ][ j ][ k ], mul( i ? i - j : 1, k ) ) );
                }
    for ( int i = 1; i <= n; i++ )
        for ( int j = 0; j <= i; j++ )
            a[ i + 1 ] = add( a[ i + 1 ], mul( f[ i ][ j ][ 1 ], i - j ) );
    for ( int i = 2; i <= n; i++ )
        cout << a[ i ] << '\n';
    return 0;
}
```


---

## 作者：Otomachi_Una_ (赞：0)

一道容斥妙妙题。

## 解题思路

先假设全集 $U=\{1,2\dots n\}$

假设 $f(S)$ 表示树一当中 $S$ **恰为**非叶子节点的方案数。我们发现其实 $f$ 并不好求，因为你要保证 $S$ 当中没有叶子节点，这是很难做到的。

定义 $g(S)$ 表示 $U-S$ 当中都是叶子的方案数，则：

$$g(S)=\prod_{i=2}^n\sum_{j\in S}[j<i]$$

所以经过容斥原理：

$$f(S)=\sum_{T\subseteq S} (-1)^{|T|} g(S)$$

经过枚举可以发现 $f(S)=f(U-S)$。

问题转化成了：
$$\sum_{T\subseteq S}f(T)f(U-T)=\sum_{T\subseteq S} f^2(T)$$
$$=\sum_ {T\subseteq S}\sum_{T_1\in S}\sum_{T_2\in S}(-1)^{|T_1|+|T_2|}\prod_{i=2}^n(\sum_{j\in T_1}[j<i])({\sum_{j\in T_2}[j<i]})$$

然后可以考虑 $\text{dp}$。假设 $f[i][j][k]$ 表示当 $n=i$ 时，$|T_1|=j,|T_2|=k$ 的方案数。转移方程不太好描述，可参考代码。

## 参考代码

```cpp
#include<iostream>
using namespace std;
#define ll long long
const int MAXN=5e3+5;
int f[2][MAXN][MAXN];
int u1=0,u2=1;
int n,m;
int main(){
	cin>>n>>m;
	f[0][1][1]=1;
	for(int i=1;i<n;i++){
		swap(u1,u2);
		//cout<<i<<endl;
		ll ans=0;
		for(int j=i;j>=1;j--)
			for(int k=i;k>=1;k--)if(f[u2][j][k]){
				ll tmp=1ll*f[u2][j][k]*j%m*k%m;
				f[u1][j][k]=2*tmp;//j notin S or j in S but j notin T1,T2
				f[u1][j+1][k]=f[u1][j+1][k]-tmp;
				f[u1][j][k+1]=f[u1][j][k+1]-tmp;
				f[u1][j+1][k+1]+=tmp;
			}else f[u1][j][k]=0;
		for(int j=1;j<=i+1;j++)
			for(int k=1;k<=i+1;k++){
				f[u1][j][k]=(f[u1][j][k]%m+m)%m;
				ans+=f[u1][j][k];
			}
		cout<<ans%m<<endl; 
	}
} 
```


---


# [八省联考 2018] 林克卡特树

## 题目描述

小 L 最近沉迷于塞尔达传说：荒野之息（The Legend of Zelda: Breath of The Wild）无法自拔，他尤其喜欢游戏中的迷你挑战。

游戏中有一个叫做 LCT 的挑战，它的规则是这样子的：现在有一个 $N$ 个点的树，每条边有一个整数边权 $v_i$，若 $v_i \geq 0$，表示走这条边会获得 $v_i$ 的收益；若 $v_i \lt 0$ ，则表示走这条边需要支付 $-v_i$ 的过路费。小 L 需要控制主角 Link 切掉（Cut）树上的恰好 $K$ 条边，然后再连接 $K$ 条边权为 0 的边，得到一棵新的树。接着，他会选择树上的两个点 $p,q$，并沿着树上连接这两点的简单路径从 $p$ 走到 $q$，并为经过的每条边支付过路费/ 获取相应收益。

海拉鲁大陆之神 TemporaryDO 想考验一下 Link。他告诉 Link，如果 Link 能切掉合适的边、选择合适的路径从而使 总收益 - 总过路费 最大化的话，就把传说中的大师之剑送给他。

小 L 想得到大师之剑，于是他找到了你来帮忙，请你告诉他，Link 能得到的 总收益 - 总过路费 最大是多少。

## 说明/提示

### 样例解释

一种可能的最优方案为：切掉 $(2, 4, -3)$ 这条边，连接 $(3, 4, 0)$ 这条边，选择 $(p, q) = (1, 5)$。

### 数据范围

- 对于 $10\%$ 的数据，$k = 0$；
- 对于另外 $10\%$ 的数据，$k = 1$；
- 对于另外 $15\%$ 的数据，$k = 2$；
- 对于另外 $25\%$ 的数据，$k \leq 100$；
- 对于其他数据，没有特殊约定。

对于全部的测试数据，保证 $1 \leq N \leq 3 \times 10^5$，$0 \leq K \leq 3 \times 10^5$，$K \lt N$，$1 \leq x_i,y_i \leq N$，$|v_i| \leq 10^6$。

### 提示

题目并不难。

## 样例 #1

### 输入

```
5 1
1 2 3
2 3 5
2 4 -3
4 5 6```

### 输出

```
14```

# 题解

## 作者：shadowice1984 (赞：68)

dp凸优化/wqs二分/带权二分

这里可能会给出一个(我大力口胡的)对于这类算法正确性的证明，并且会涉及到对于边界情况的处理
___________________

## 本题题解

题意

给你一棵树，割掉恰好k条边然后重新接上恰好k条0权边，然后要求最大化新树的直径

割掉k条边之后会出现k+1个联通块，那么我们对于每一个联通块求直径然后用k条边将这k个联通块串起来即可了

所以问题变成了在树上寻找k+1条点不相交链，并且最大化这k+1条链的边权之和

**注意，一个点被视作退化的一条链**

___________

一看又是乱七八糟的树上最优化问题，不是树分治就是树形dp

似乎树分治处理多条路径的时候能力有限……，所以我们基本断定是个树形dp

按照树形dp的无脑套路，$Dp_{i,j}$表示链全部在i的子树中，一共有j条链时这些链的最大边权和

那么我们按照树形dp的转移思路就是考虑“拼合”最高点为u和最高点为v这两个子联通块

问题来了，我们突然意识到这个状态似乎无法转移……

情况突然变得尴尬……

冷静分析一下会发现没有办法转移的关键是无法拼合两条路径

因为有些时候两个联通块拼到一起会将两个路径拼成一个路径，此时我们根据dp数组中的状态并无法还原这种情况

观察到是点不相交的路径，因此我们发现一件事，在最后的选中的链构成图形中，一个点的度数至多为2

所以额外补上一维k,$k\in \{0,1,2\}$表示点i的度数

此时我们考虑将最高点为u和最高点为v的两个联通块拼到一起，那么转移方式就是枚举u,v之间的边是否出现在这k条链当中

然后我们手动分情况讨论一波转移

### case 1:u,v之间的边不选

那么点u的度数不变，然后路径条数为两个联通块的路径条数之和，然后dp值就是两个状态的dp值简单相加

### case 2:u,v之间的边被选择

需要注意的是，如果u和v之间有一个的度数是2那么这个转移就是非法的

那么点u的度数如果是1那么变成2，如果是0变成1，dp值是两个状态的dp值简单相加，再加上u到v的边权，路径条数在两个点的点度都是0的时候总路径条数+1，两个点的点度都是1的时候发现拼合了一条路径，总路径条数-1，两个点的点度有一个是0另一个是1的时候由于相当于延长了一个路径所以说路径条数不变

然后我们就可以写出一个复杂度$O(nk)$的暴力了

边界条件呢?

## $Dp_{i,0,0}=0$

其他值初始化为$- \infty$

听起来很有道理？

然后你发现你忘记了一种情况……

**注意，一个点被视作退化的一条链**

这样dp是dp不出来只有一个点的路径的……

所以我们稍稍给边界条件动一动手脚，将只有一个点的路径视为一个自环，那么这个点的度数就为2，或者你可以简单的认为这个点成为单独的一个路径之后就无法和其他的路径相拼接。

所以稍稍fix下边界条件

## $Dp_{i,0,0}=0,Dp_{i,1,2}=0$

其他值初始化为 $- \infty$

然后我们就可以愉快的dp了，答案是$max(Dp_{1,k,0},Dp_{i,k,1},Dp_{i,k,2})$

然后我们会发现除了暴力dp之外似乎没什么做法了

套用官方题解中的一句话，假设你是一名秒出dp，即将ak的julao，闲来无事的时候的打印了k=0~100的所有答案，你会惊奇的发现这个函数是一个上凸函数/差分单调递减

所以下面就是这道题需要的技巧了——dp凸优化/wqs二分

_____________________

## Dp凸优化

假设我们有一个很难求的函数$f(x)$我们知道它是一个凸函数，换句话说导函数/差分单调

我们还有一个性质，函数$G(x,k)=f(x)-kx$的极值非常好算(但是G(x)的任意点值同样难算)，并且我们不仅可以知道$G(x,k)$的极值，而且我们还知道取极值的时候x的值

那么此时我们计算$F(n)$的值是有一个快速方法的

具体来讲是这样，我们设函数$G(x,k)$的极值为C,且取最大值时x的取值是t

## $G(t,k)=f(t)-tx=C$

## $f(t)=tx+C$

等一下……我们毫不费力的计算出了$F(t)$的值

换句话说，点$(t,f(t))$在$y=kx+C$这条直线上

又因为对于其他不是t的点p有

## $G(p,k)=f(p)-kp \leq C$

## $f(p) \leq kp+C$

因此，我们会发现函数$F(x)$的图像应该在直线$y=kx+C$的下方，且t一定是两个函数类似于一个切点之类的东西(因为两个函数可能有多个交点)

刚才说过如果我们十分幸运的猜中了一个k使得$G(x,k)$在x==n时取得极值的话，我们就可以计算出$f(n)$的值

当然现实是我们没有那么幸运……

但是我们会发现一个十分微妙的事实是随着k的增大函数$G(x,k)$的极值点向右/左单调的移动

这当然不是什么奇怪的性质而是因为这样一个简单的事实，函数$F(x)$是凸的

所以极值点自然是差分取0时的点

而函数$G(x,k)=f(x)-kx$相当于是$f(x)$的差分减k之后形成的函数

所以极值点(差分0点)自然就是随着k的增加而单调的了

既然有单调性我们就可以二分斜率k，然后每次求出极值点的位置和n进行比较，然后我们按照我们的需求对于k进行调整，直到我们的极值点恰好是n，于是我们就顺理成章的求出了$f(n)$的值

做完了?

听起来好像没什么毛病……

有一个问题。

**函数$G(x,k)$的极值点不一定唯一**

这意味着我们将没有办法判断n到底是在极值点的左边还是右边

但是还好$F(x)$是凸的，所以我们有一个性质可以用，那就是函数$G(x,k)$的所有极值点构成一个连续区间，而不会有多个区间，具体来讲就是你的斜率k和凸函数的一段斜率是一样的，于是你的直线和凸函数有一条边重合而不是一个点重合了

另一个好消息是这段区间内的点都可以使用刚才的手法($kx+c$)计算出对应的$f(x)$值，因为这个凸函数和直线重合

所以我们的问题变成了求点n所在直线的斜率

那么我们只需对刚才的二分稍加修改即可解决这个问题，我们求极值点的时候增加一个限制，如果有多个极值点，那么我们求最小的那一个，然后进行比较继续二分，注意的是边界条件的处理，我们应保证最后二分到底的时候，如果斜率k对应的极值点不等于n的话，这个极值点应该比n要小

此时我们发现，如果极值点t不等于n的话，那么$(n,f(n))$和$(t,f(t))$在同一条直线上，所以直接将n带入t所在的直线即可计算出$f(n)$

_______________________

好了回到刚才的问题

我们有一个很难求的函数$f(x)=max(Dp_{1,x,0},Dp_{1,x,1},Dp_{1,x,2})$

现在我们想要求$f(n)$

而函数$G(x,k)=f(x)-kx$这个东西可以在$O(n)$时间内求出

具体来讲你把转移方程第二维去掉，然后在生成/拼合一条路径时减去/加上对应的k就好了

还要支持求极值点，如果有多个相同的极值点，应该求出最小的，这个也好办，你的dp数组写一个结构体，给小于号做做手脚，到时候直接max就好了

至此问题完全转化为刚才的问题，求出$(n,f(n))$所在的直线方程直接代入求值即可

注意一个小坑，(l+r)/2不等于$\lfloor \frac{l+r}{2} \rfloor$,所以手动实现一下下取整

另外inf设大一点，因为这题的数值范围较大……

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=3*1e5+10;typedef long long ll;
int v[2*N];int x[2*N];int ct;int al[N];ll val[2*N];bool book[N];int n;int k;
inline void add(int u,int V,ll va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
struct data//dp的结构体 
{
    ll v;int k;
    friend bool operator <(data a,data b){return (a.v==b.v)?a.k>b.k:a.v<b.v;}//重载< 
    friend data operator +(data a,data b){return (data){a.v+b.v,a.k+b.k};}
}dp[N][3];data tr[3];ll mid;
inline void dfs(int u)//树形dp 
{
    book[u]=true;
    for(int i=al[u];i;i=x[i])
    {
        if(book[v[i]])continue;dfs(v[i]);ll va=val[i];
        for(int j=0;j<3;j++)tr[j]=(data){-0x7f7f7f7f7f,0x3f3f3f3f};
        for(int j=0;j<3;j++)tr[0]=max(tr[0],dp[u][0]+dp[v[i]][j]);
        tr[1]=max(tr[1],dp[u][0]+dp[v[i]][0]+(data){va-mid,1});
        tr[1]=max(tr[1],dp[u][0]+dp[v[i]][1]+(data){va,0});
        for(int j=0;j<3;j++)tr[1]=max(tr[1],dp[u][1]+dp[v[i]][j]);
        tr[2]=max(tr[2],dp[u][1]+dp[v[i]][0]+(data){va,0});
        tr[2]=max(tr[2],dp[u][1]+dp[v[i]][1]+(data){va+mid,-1});
        for(int j=0;j<3;j++)tr[2]=max(tr[2],dp[u][2]+dp[v[i]][j]);
        for(int j=0;j<3;j++)dp[u][j]=tr[j];
    }book[u]=false;
}
inline void ih()//初始化边界条件 
{
    for(int i=1;i<=n;i++)
        dp[i][0]=(data){0,0},dp[i][1]=(data){-0x7f7f7f7f7f,0x3f3f3f3f},
        dp[i][2]=(data){-mid,1};
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1,u,v,va;i<n;i++){scanf("%d%d%d",&u,&v,&va);add(u,v,va);add(v,u,va);}
    ll l=-1e12;ll r=1e12;
    while(l!=r)
    {
        mid=(double)(l+r)/2-0.5;ih();dfs(1);
        data jud=max(dp[1][0],max(dp[1][1],dp[1][2]));
        if(jud.k==(k+1)){printf("%lld",jud.v+(k+1)*mid);return 0;}
        if(jud.k>(k+1)){l=mid+1;}else r=mid;//二分斜率 
    }mid=l;ih();dfs(1);data jud=max(dp[1][0],max(dp[1][1],dp[1][2]));
    printf("%lld",jud.v+(k+1)*mid);return 0;//带入直线方程求值 
} 
```












---

## 作者：ysner (赞：62)

 给一颗有负边的树，询问在经过k次割边与任意连上边权为0的边后，链上边权最大和。
    
~~此题看起来甚火，正解不敢想象~~，于是先yy一波部分分    

 - 对于10% 的数据，$k = 0$ ;
 - 对于另外10% 的数据，$k = 1 $;
 - 对于另外15% 的数据，$k = 2$ ;
 - 对于另外25% 的数据，$k \leq 100 $;

**10pts算法($k\leq0$)**

树的直径

**20pts算法($k\leq1$)**

枚举割哪条边，分别给割后产生的两颗树算直径，加起来即可

~~送分结束~~

**35pts算法($k\leq2$)**

看来是分类讨论啊，然而并不知道应如何讨论（~~请求大佬的指教QAQ~~)

**60pts算法($k\leq100$)**

分类讨论到此为止啦，显然只有树形DP才做的动。。。

**任意连上边权为0的边**？？？这是什么操作？？？这边有意义吗？？？

看来没有啊，那就把它忽略掉吧。

于是，问题就变成了**最大化$k+1$条不相交的链的链上边权总和**

经典树形DP。

设状态$f[0/1/2][u][k]$表示以u为根的子树（且u的度数为$0/1/2$）中，选k条链的最优解。

顺便加个大前提：**强制每个点对应其父边**。

我们可以列出几个状态转移方程式：(v是u的儿子)($i,j\in(0,k)$)

 - 当u点度数为0时，说明这个点不在链上，于是直接合并一下子树里的最优解即可。
 
   $f[0][u][i]=max(f[0][u][i],f[0][u][j]+f[0][v][i-j]);$

 - 当u点度数为1时，说明这个点是一条链的端点，我们分 *自己本身有一条链* 和 *儿子有一条链* 两种情况取大即可，若自己本来不在链上，要加上边权。
 
   $f[1][u][i]=max(f[1][u][i],max(f[0][u][j]+f[1][v][i-j]+e[i].w,f[1][u][o]+f[0][v][i-j]));$

 - 当u点度数为2时，说明这个点在一条链中间，我们可以认为这种情况是因 *自己和儿子都是一条链的端点* 或 *自己本来就在一条链中间* 而形成的，注意此时第一种情况由于连上当前父子之间的边而**多了一条链**和一个边权。

   $f[2][u][i]=max(f[2][u][i],max(f[1][u][j]+f[1][v][i-j-1]+e[i].w,f[2][u][j]+f[0][v][i-j]));$
 
 -  还有边界情况（调代码时调出的锅）
  
 - 最后合并答案
 
 $f[0][u][i]=max(f[0][u][i],max(f[1][u][i-1],f[2][u][i]));$

答案就是$f[0][1][k]$

```
il void dfs(re int u,re int fa)
{
  f[0][u][0]=f[1][u][0]=f[2][u][0]=0;
  for(re int i=h[u];i+1;i=e[i].next)
    {
      re int v=e[i].to;
      if(v==fa) continue;
      dfs(v,u);
      fq(j,k,1)
    {
      f[1][u][j]=max(f[1][u][j],f[0][u][j]+f[1][v][0]+e[i].w);
    fq(o,j-1,0)
    {
      f[0][u][j]=max(f[0][u][j],f[0][u][o]+f[0][v][j-o]);
      f[1][u][j]=max(f[1][u][j],max(f[0][u][o]+f[1][v][j-o]+e[i].w,f[1][u][o]+f[0][v][j-o]));
      f[2][u][j]=max(f[2][u][j],max(f[1][u][o]+f[1][v][j-o-1]+e[i].w,f[2][u][o]+f[0][v][j-o]));
    }
    }
      f[1][u][0]=max(f[1][u][0],f[1][v][0]+e[i].w);
    }
  f[0][u][1]=max(0,f[0][u][1]);
  fp(i,1,k) f[0][u][i]=max(f[0][u][i],max(f[1][u][i-1],f[2][u][i]));
}
int main()
{
  memset(h,-1,sizeof(h));
  n=gi();k=gi();
  fp(i,1,n-1)
    {
      re int u=gi(),v=gi(),w=gi();
      add(u,v,w);add(v,u,w);
    }
  memset(f,-63,sizeof(f));
  k++;dfs(1,0);
  printf("%d\n",f[0][1][k]);
  return 0;
}
```

**100pts算法($k\leq3*10^5$)**

~~辛辛苦苦想出的树形DP废了。。。~~

假如你是个秒出60pts的巨佬，即将AK之时闲来无事输出选了k条链的最优解，你就会发现：**最优解数组是一个上凸函数**！！！

这个函数以k的值为x轴，以最优解为y轴。

我们想找到的点，就是$(k,best[k])$。

于是考虑用一条直线去切这个函数，由此我们可以枚举一个斜率，用60分的DP思想来算出切点。~~（这好像是个套路?)~~

算出切点后，我们可以根据切点在k的左右，来缩小斜率范围。

二分？于是复杂度降到$O(nlogn)$，皆大欢喜。

```
struct dat
{
    ll x,y;
    il bool operator < (const dat &o) const {return x==o.x? y>o.y : x<o.x;}
    il dat operator + (const dat &o) const {return (dat){x+o.x,y+o.y};}
    il dat operator + (re int o) {return (dat){x+o,y};}
}dp[3][N];
il dat upd(dat o){return (dat){o.x-mid,o.y+1};}
il void dfs(re int u,re int fa)
{
    dp[2][u]=max(dp[2][u],(dat){-mid,1});
    for(re int i=h[u];i+1;i=e[i].next)
    {
        re int v=e[i].to;
        if(v==fa) continue;
        dfs(v,u);
        dp[2][u]=max(dp[2][u]+dp[0][v],upd(dp[1][u]+dp[1][v]+e[i].w));
        dp[1][u]=max(dp[1][u]+dp[0][v],dp[0][u]+dp[1][v]+e[i].w);
        dp[0][u]=dp[0][u]+dp[0][v];
    }
    dp[0][u]=max(dp[0][u],max(upd(dp[1][u]),dp[2][u]));
}
int main()
{
    memset(h,-1,sizeof(h));
  n=gi();k=gi();++k;
  fp(i,1,n-1)
  {
     re int u=gi(),v=gi(),w=gi();tot+=abs(w);
     add(u,v,w);add(v,u,w);
  }
  l=-tot,r=tot;
  while(l<=r)
  {
      mid=l+r>>1;
      memset(dp,0,sizeof(dp));
      dfs(1,0);
      if(dp[0][1].y<=k) r=mid-1;
      else l=mid+1;
  }
  memset(dp,0,sizeof(dp));
  mid=l;dfs(1,0);
  printf("%lld\n",l*k+dp[0][1].x);
  return 0;
}
```

---

## 作者：Marser (赞：55)

## 题意
给定一棵 $n$ 个点的树，边权有正有负，要求在树上选出 $k+1$ 条链，使得其权值之和最大。

看起来很不好做，那我们先考虑一下，对于60分的部分分如何处理。

我们可以这样设计状态：  
令 $f[i][j][0/1/2]$ 表示在 $i$ 节点的子树内，已经有 $j$ 条**完整的链**，当前 $i$ 节点的度数为 $0/1/2$ 的最大价值。度数为 $0$ 时，这个点没有连边。度数为 $1$ 时，这个点拖着一条未完成的链，而这条链不计入 $j$ 。度数为 $2$ 时，这个点被一条连接两个不同子树的链穿过。

可以分类讨论出如下转移：

首先，我们约定在每个节点的全部转移结束时，进行一次更新：  
$f[i][j][0]=\max\{f[i][j][0],f[i][j-1][1],f[i][j][2]\}$

这样，我们就把 $i$ 节点的全部最优解统计了出来。对于度数为 $0/2$ 的情况可以直接合并，而对于度数为 $1$ 的情况，要先在 $i$ 节点处把当前 $i$ 节点拖着的一条链断掉，然后将这条链计入总数，合并。

$f[i][j][0]=\max_{l=1}^{j-1} \{ f[i][j][0],f[i][l][0]+f[x][j-l][0]\} $  
显然，如果当前节点的度数为 $0$ ，肯定不能连边，只能取子节点的最优解。

$f[i][j][1]=\max_{l=1}^{j-1} \{ f[i][j][1],f[i][l][1]+f[x][j-l][0],f[i][l][0]+f[x][j-l][1]+w(i,x)\} $  
如果要求度数为 $1$ ，可以继承之前的结果，不连边。同样，可以连上这条边，继承子节点拖着的一条未完成的链，同时取这条边的权值。

$f[i][j][2]=\max_{l=1}^{j-1} \{ f[i][j][2],f[i][l][2]+f[x][j-l][0],f[i][l][1]+f[x][j-l-1][1]+w(i,x)\} $
要求度数为 $2$ ，同样可以继承之前的结果，取子节点的最优解。也可以将之前 $i$ 节点挂着的链与子节点挂着的链连接起来，就新完成了一条链。

$f[i][j][1]=\max\{f[i][j][1],f[i][j][0]+f[x][0][1]+w(i,x)\}$  
$f[i][0][1]=\max\{f[i][0][1],f[i][0][0]+f[x][0][1]+w(i,x)\}$  
处理从子节点出发的链。

这样我们可以得到一个 $O(nk^2)$ 的dp做法，可以拿到45(35)分。

考虑如何优化。我们注意到，每次增加一条链，得到的收益是单调不增的。  
每次增加一条链有两种做法，一种是新选一条链，一种是将一条链分成两条。每种操作的收益是一定的，因此每次都会选择最大收益的操作。而由于边权不会改变，后续不可能有操作会有更大的收益。因此，我们可以口胡出这是一个上凸的函数。

记 $f[1][x][0]$ 为 $F(x)$ ，我们知道 $F(x)$ 是一个上凸函数。并且，恒有 $F(0)=F(n)=0$ 。因此，我们可以考虑用一条斜率一定的直线去切这个凸壳。设这条直线为 $l:y=ax+b$ ，根据上凸函数的特性，斜率一定时，切线的截距一定大于割线。

我们令切点为 $(t,F(t))$ ，则切线满足 $a*t+b=F(t)$ ，即 $b=F(t) - a*t$ 。可以发现， $b$ 的表达式就相当于给每个物品赋上额外的权值 $-t$ 时，dp所得的最优解。这样，我们只需要一次朴素的dp就可以求出截距。

而如何获取斜率呢？再一次，由于函数上凸，我们可以发现当斜率不断增大时，对应的切点横坐标也在不断左移。这样，我们就可以二分求相应的斜率了。每次check的时候顺便记录一下最优解选取了多少个，从而判断应该如何调整二分区间。

还有一个问题，有可能出现凸壳上多个点共线的情况。为了处理这种情况，我们可以限定在dp过程中，权值相同时优先取选择次数更小的转移。这样，我们求出来的次数就是当前切点的左边界，二分时判断一下就可以了。

回到这题，套用60(45)分做法的dp方式，去掉有关次数的限制，每次dp的复杂度就变成 $O(n)$ 。总复杂度为 $O(n \log k)$

45分代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int MN=3e5+5;
int to[MN<<1],nxt[MN<<1],c[MN<<1],h[MN],cnt;
inline void ins(int s,int t,int w){
	to[++cnt]=t;nxt[cnt]=h[s];c[cnt]=w;h[s]=cnt;
	to[++cnt]=s;nxt[cnt]=h[t];c[cnt]=w;h[t]=cnt;
}
#define chkmax(a,b) ((a)<(b)?(a)=(b):0)
int n,K;
int f[MN][105][3];
void dfs(int st,int fa=0){
	f[st][0][0]=f[st][0][1]=f[st][1][2]=0;
	for(reg int i=h[st];i;i=nxt[i]){
		if(to[i]==fa)continue;
		dfs(to[i],st);
		for(reg int j=K;j;j--){
			chkmax(f[st][j][1],f[st][j][0]+f[to[i]][0][1]+c[i]);
			for(reg int k=j-1;~k;k--){
				chkmax(f[st][j][0],f[st][k][0]+f[to[i]][j-k][0]);
				chkmax(f[st][j][1],max(f[st][k][1]+f[to[i]][j-k][0],f[st][k][0]+f[to[i]][j-k][1]+c[i]));
				chkmax(f[st][j][2],max(f[st][k][2]+f[to[i]][j-k][0],f[st][k][1]+f[to[i]][j-k-1][1]+c[i]));
			}
		}
		chkmax(f[st][0][1],f[to[i]][0][1]+c[i]);
	}
	for(reg int i=1;i<=K;i++)
		chkmax(f[st][i][0],max(f[st][i-1][1],f[st][i][2]));
}
int main(){
	scanf("%d%d",&n,&K);K++;
	for(reg int i=1,s,t,v;i<n;i++)
		scanf("%d%d%d",&s,&t,&v),ins(s,t,v);
	memset(f,~0x3f,sizeof(f));dfs(1);
	printf("%d\n",f[1][K][0]);
	return 0;
}
```

100分代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int MN=3e5+5;
int to[MN<<1],nxt[MN<<1],c[MN<<1],h[MN],cnt;
inline void ins(int s,int t,int w){
	to[++cnt]=t;nxt[cnt]=h[s];c[cnt]=w;h[s]=cnt;
	to[++cnt]=s;nxt[cnt]=h[t];c[cnt]=w;h[t]=cnt;
}
#define chkmax(a,b) ((a)<(b)?(a)=(b):0)
int n,k;
ll l,r,mid;
struct data{
	ll val;int pos;
	data(ll x=0,int y=0):val(x),pos(y){}
	friend bool operator<(data a,data b){
		return a.val==b.val?a.pos>b.pos:a.val<b.val;
	}
	friend data operator+(data a,data b){
		return data(a.val+b.val,a.pos+b.pos);
	}
	friend data operator+(data a,ll b){
		return data(a.val+b,a.pos);
	}
}f[MN][3],tmp;
int fa[MN];
void getf(int st){
	for(reg int i=h[st];i;i=nxt[i])
		if(to[i]!=fa[st])fa[to[i]]=st,getf(to[i]);
}
void dfs(int st){
	f[st][0]=f[st][1]=f[st][2]=data();
	chkmax(f[st][2],tmp);
	for(reg int i=h[st];i;i=nxt[i]){
		if(to[i]==fa[st])continue;dfs(to[i]);
		chkmax(f[st][2],max(f[st][2]+f[to[i]][0],f[st][1]+f[to[i]][1]+c[i]+tmp));
		chkmax(f[st][1],max(f[st][1]+f[to[i]][0],f[st][0]+f[to[i]][1]+c[i]));
		chkmax(f[st][0],f[st][0]+f[to[i]][0]);
	}
	chkmax(f[st][0],max(f[st][1]+tmp,f[st][2]));
}
int main(){
	scanf("%d%d",&n,&k);k++;
	for(reg int i=1,s,t,w;i<n;i++)
		scanf("%d%d%d",&s,&t,&w),ins(s,t,w);
	l=-1e12;r=1e12;getf(1);
	while(l<r){
        mid=(double)(l+r)/2-0.5;
        tmp=data(-mid,1);dfs(1);
        if(f[1][0].pos==k){
            printf("%lld\n",f[1][0].val+mid*k);
            return 0;
        }
        if(f[1][0].pos>k)l=mid+1;
        else r=mid;
    }
	mid=l;tmp=data(-mid,1);dfs(1);
	printf("%lld\n",f[1][0].val+mid*k);
	return 0;
}
```

---

## 作者：EternalAlexander (赞：39)

emm感觉其他题解都没有讲的特别清楚。写一篇讲的比较详细的吧。

带权二分，又叫wqs二分/dp凸优化，用于解决一类有固定数量限制的最优化问题。  

例如，给你$n$个物品，给定以某些方式选择能得到某些收益/付出某些代价，问选择**恰好**$k$个物品所能得到的最大收益/付出的最小费用。  

因为有了$k$的限制，一般来说只能够类似于$f[i][j]$表示前$i$个物品中选择了$j$个时的最优解这样的类似背包的方法来求解。而且这个dp看起来很难优化，因为状态数几乎是满的，而即使能够$O(1)$转移，最多也只能做到$2D/0D$，复杂度为$O(nk)$  

但是，带权二分能够成为这类问题的一个突破口。令$f(x)$表示选择恰好$x$件物品的最优解，如果$f(x)$是一个**凸函数**，我们就能使用带权二分来优化它。  

具体而言，对于$x\in[0, n]$，对应的$f(x)$在以$x$为横坐标，$f(x)$为纵坐标的二维平面内构成了一个凸包。

[![632842462e67e152.md.png](http://www.tzr.me/images/2018/12/16/632842462e67e152.md.png)](http://www.tzr.me/image/QIbe)
>一个凸包的示例

我们要求的是$f(k)$，也就是凸包上的一个点$P(k, f(k))$。这个凸包不能直接下手去求，因为时间复杂度无法承受。

考虑引一条固定斜率的直线去切这个凸包，也就是从上向下平移找到最早相交的那个点，这个切点的坐标是可以求出来的(将在后文详细叙述)。也就是说我们能够**确定**凸包上的一个点$Q(x, f(x))$，并且，我们还能确定**这个点在所求$P$点的左侧还是右侧**。  

[![2a7418.md.png](http://www.tzr.me/images/2018/12/16/2a7418.md.png)](http://www.tzr.me/image/QdeX)

>引一条直线切凸包

如果$Q$在$P$的左侧，我们减小直线斜率继续尝试，否则增大直线斜率，直到正好切到$P$点。因为是一个凸函数，增大直线斜率后所得切点一定在$Q$左侧，反之亦然。  

这样，我们可以通过二分直线斜率的方式来求得$P$点坐标，也求出对应的$f(k)$

[![3.md.png](http://www.tzr.me/images/2018/12/16/3.md.png)](http://www.tzr.me/image/QmXy)
>黄绿红三条直线斜率依次减小，所得切点横坐标依次增大

到了现在，我们唯一需要解决的问题就是怎么找到切点坐标。  

设该直线斜率为$m$，解析式为$y=mx+b$,显然要找到最高的切点就需要最大化直线的截距，也就是$b$。  

在图像上，我们可以将凸包上的每个点$(x, f(x))$都向下平移至$(x, f(x)-mx)$，不难发现此时这仍是个凸包。此时凸包的最高点即是向下平移后的切点，证明如下：

设切点坐标为$x$  
$\because f(x)=mx+b$  
$\therefore f(x)-mx=b$  
$\therefore \max(b)=\max(f(x)-mx)$

在切到了$P$点之后，按照上面的方式找到的其实是平移后的$P$点，将它向上平移还原即可。

对应到给定的题目中，只需要把每个物品的收益减去二分的斜率$m$，这样就能保证每多选取一个物品都需付出$m$的代价，然后不考虑$k$的限制求得最大收益$w$，并且求得在得到最大收益的情况下选取的物品个数$c$，则我们求得上述的$Q(c, w+cm)$，根据$c$和限制$k$的大小关系调整直线斜率继续二分即可。

回到本题，显然题目可以转化为选取$k+1$条路径的长度和的最大值。设$f(x)$为选取$x$条路径所得到的最优方案。出题人告诉我们这个$f(x)$是凸的，使用上述的二分方法，二分斜率$m$,令每选取一条路径都需要付出$m$的代价($m$可能为负数)，求此时选任意条路径所能得到的最大收益以及得到最大收益的前提下选取的**最大**路径条数，并按照上面的方法调整斜率即可。  

稍有不同的是，我们这里需要找到的是最小的可以使得选取的路径条数$\geq k$的斜率$m$，这也是为何需要选取尽量多的路径。  

至于如何求出选取$k+1$条路径的长度和的最大值，可以使用树形dp在$O(n)$的时间里解决。 $f[i][j] (j\in \{0, 1, 2\})$ 表示点$i$的度数为$j$时$i$的子树中的最优解，使用背包转移即可。在具体实现中，背包这一维可以滚掉。

另外还有一些边界和细节问题，这里就不在赘述了，可以参考其他题解或者理解后自行推导。

```cpp
#include <bits/stdc++.h>
#define maxn 300005
#define ll long long
const int inf=1e13;

struct edge {
    int v, w, next;
}edges[maxn<<1];

int n, k, tail=0, u, v, w, cnt, head[maxn]={0};
ll sum,delta,l,r=0,ans;

void add_edge(int u, int v, int w) {
    edges[++tail].v=v;
    edges[tail].w=w;
    edges[tail].next=head[u];
    head[u]=tail;
}

struct data{
    int c; ll v;
    data operator + (data d) {data a;a.v=v+d.v;a.c=c+d.c;return a;}
    bool operator < (data d) {return v<d.v||(v==d.v&&c<d.c);}
}dp[maxn][3], temp[3];

data dat(ll v, int c) {data d;d.v=v;d.c=c;return d;}

data max(data a, data b) {
    if (a<b) return b;
    return a;
}
void dfs(int u, int f) {
    for (int i=head[u];i;i=edges[i].next) {
        int v=edges[i].v;
        if (v==f) continue;
        dfs(v, u);
       	dp[u][2]=max(dp[u][2]+dp[v][0], dp[u][1]+dp[v][1]+dat(edges[i].w-delta, 1));
       	dp[u][1]=max(dp[u][0]+dp[v][1]+dat(edges[i].w, 0), dp[u][1]+dp[v][0]);
       	dp[u][0]=dp[u][0]+dp[v][0];
    }dp[u][0]=max(dp[u][0], max(dp[u][1]+dat(-delta, 1), dp[u][2]));
}	

void check(ll x) {
    delta=x;
    for (int i=1;i<=n;++i) {
        dp[i][0]=dat(0, 0);dp[i][2]=dat(-delta, 1); dp[i][1]=dat(0, 0);
    } dfs(1, 0);
    sum=dp[1][0].v; cnt=dp[1][0].c;
}

int main() {
    scanf("%d %d", &n, &k);k++;
    for (int i=1;i<n;++i) {
        scanf("%d %d %d",&u,&v,&w);
        add_edge(u,v,w);add_edge(v,u,w);
        r+=(w>0)?w:-w;
    } l=-r;
    while (l<=r) {
        ll mid=(l+r)>>1;
        check(mid);
        if (cnt>=k) {l=mid+1; ans=mid;}
        else r=mid-1;
    }check(ans);
    printf("%lld", sum+k*ans);
    return 0;
}
```

wqs的论文:http://www.doc88.com/p-949564862405.html

最后，关于本题$f(x)$为什么是凸的，我翻看了很多篇博客，暂时未发现任何关于它的证明。如果有会证的dalao还烦请赐教。 



---

## 作者：zyc2003 (赞：31)

Update : 修改了一个有关凸函数定义的大锅 , 感谢评论区的提醒 . 

Update : 对 latex 做出了重新完善 (更好的阅读体验) , 增加了感性方面如何认知题目中的**凸性** . 


### 题解摘要

详细介绍了题目的**转化** , $60$ 分树上动态规划的做法 , 粗略证明 $100$ 分做法中有关函数的**凸**的性质的正确性 , 以及二分边界问题 . **不含有** wqs 二分/带权二分/dp 凸优化 的引入和介绍 . 

### 题意复述

给定一棵带整数边权的树 , 你一共需要断掉树上的 $K$ 条边 , 然后再重新连接 $K$ 条权值为 $0$ 的边 , 得到一棵新的树 . 最后 , 你选择树上一条路径走过 , 要求最大化权值和 . 

### 转化思路

首先来看 $K=0$ 的情况 . 不用切边 , 意味着我们只需要找到这棵树的**最长链**即可 . 而 $K=1$ 的话 , 我们枚举切去的一条边 , 变成了两棵树 . 由于新连接的边权值为 $0$ , 对最终答案没有贡献 , 所以我们应当分别找到两棵树的**最长链** , 它们的权值之和即为答案 . 

是不是有感觉了 ? 对于 $K=2$ 似乎同理 , 枚举切去的两条边即可 . 而此时我们找到的三条链 , 它们在切去两条边后分属于三棵树 , 是**互不相交**的 . 这也就意味着 , 如果我们能找到树上的任意三条**不相交**的**链** , 一定可以构造出一种方案 , 使得最终路径经过这三条链和两条新增添的权值为 $0$ 的边 . 

那么最终答案显而易见 , 我们找到树上的 $K+1$ 条**最大权不相交路径** , 权值之和即为答案 . 

### 分类讨论

求 $K+1$ 条**最大权不相交路径** 的动态规划做法似乎是一个经典问题 , 我们在这里重新探讨 . 

首先考虑一个点的状态 , 它可能并不在一条链上 , 也可能是一条链的某个端点 , 也可能是一条链的中间结点 . 那么自然的想到 , 设 : $f[x][j][0/1/2]$ 表示 : 在以 $x$ 为根的子树内 , 已经有 $k$ 条链 , 且 $x$ 结点 : (并不在链上/是一条链的端点/是一条链的中间结点)

注意这里 "是一条链的中间结点" 的定义 , 并不是意味着 $x$ 是某个从其端点分别是其祖先和其子树中的点的链的中间结点 , 而是一条端点均在其子树内的链的端点 . 姑且设只有一个点的链为 : **退化链**吧 . 

然后考虑边界状况 . 一个点也可以是一条链 , 这个点既可以当做这条"链"的端点 , 也可以看做这条"链"的中间结点 . 所以 , 我们初始设 : 

$$ f[x][0][0]=0$$

其它所有值设为 $-\inf$ . 

先不考虑 $x$ 自成一条链的情况 . 为什么呢 ? 请看下文 . 



考虑如何转移 . 我们每处理完一棵子树 , 就立刻进行转移操作 . 设当前处理到的子结点是 $y$ , 从 $x$ 到 $y$ 的边权值为 $z$: 

#### $1.$ $x$ 并不在链上

貌似很简单的样子 ? 

$$ f[x][j][0]=\max(f[x][j][0],f[x][j-k][0]+f[y][k][0]) , j\in [0,K] , k\in[0,j]$$

不大多对劲 , 子结点 $y$ 的状态其实可以是 $1/2$ 的 , 只要我们 $x$ 不是链的端点就行 . 于是乎我们多设一个状态 : $3$ , $f[x][j][3]=\max(f[x][j][0,1,2])$ 来方便转移 . 

于是乎方程变为 : 

$$f[x][j][0]=\max(f[x][j][0],f[x][j-k][0]+f[y][k][3]) , j\in [0,K] , k\in[0,j]$$

#### $2.$ $x$ 是一条链的端点

这就有意思了 . $x$ 结点可以在处理到子结点 $y$ 之前就已经是一条链的端点 , 也可以和当前 $y$ 连边成为端点 , 也可以自成一个 **退化链** . 这里形成 **退化链** 很重要 , 它表示新建了一条路径的起始点 , 可能会成为 $K+1$ **条最大不相交路径** 的端点之一 . 

所以 $f[x][j][1],j\in [1,K]$ 是一下三者取 $\max$ : 

$\rm A.$ $f[x][j-k][1]+f[y][k][3] , k\in [0,j-1]$

$\rm B.$ $f[x][j-k][0]+f[y][k][1]+z , k\in [1,j]$

$\rm C.$ $f[x][j-k-1][0]+f[y][k][3] , k\in [0,j-1] $ $($该方程不会用到$)$

#### $3.$ $x$ 是一条链的中间结点

和 $x$ 是一条链的端点一样 , $x$ 结点可以在处理到子结点 $y$ 之前就已经是一条链的**中间结点** , 也可以在处理到子结点 $y$ 之前就是一条链的**端点** , 然后和 $y$ 相连 , 成为新的一条链的**中间结点** . 当然你也可以自成一个**退化链** , 貌似可以看做一个自环 ?

所以 $ f[x][j][2],j\in [1,K]$ 是一下三者取 $\max$ :

$\rm A.$ $ f[x][j-k][2]+f[y][k][3] , k\in [0,j-1]$

$\rm B.$ $ f[x][j+1-k][1]+f[y][k][1]+z , k\in [1,j]$

$\rm C.$ $ f[x][j-k-1][0]+f[y][k][3] , k\in [0,j-1]$ $($该方程不会用到$)$

处理完对于所有子结点的 $0,1,2$ 后 , 我们再 : 

$ f[x][j][3]=\max(f[x][j][0],f[x][j][1],f[x][j][2]) , j\in [0,K]$

一定要注意 $j$ 和 $k$ 的取值范围 , 以及 $j$ 的倒序循环 , 否则会导致什么你们也知道 (笑

### 一堆细节

而后我们来讨论转移时的方程之间的位置问题 .

#### $1.$ 关于为何不一开始就让 $x$ 成为**退化链** 

前面说过 , 我们不考虑在一开始就让 $x$ 自成一条**退化链** . 注意到当 $x$ 是一条链的中间结点 , 转移时就可能导致这个**退化链**和它的子结点相连接 , 使得 $x$ 成为中间结点 . 但是 , 显然此时的 $x$ 是这一整条链的端点 .  

#### $2.$ 注意到 $x$ 为中间结点时有这样的方程 : 

$\rm B.$ $f[x][j+1-k][1]+f[y][k][1]+z , k\in [1,j]$

和别的方程中的 $ j-k$ 略有不同 . 

这可能会导致重复转移 , 也就是 $f[x][j+1-k][1]$ 已经在本次被更新过 , 而后又用来更新 $f[x][j][2]$ . 所以我们特殊处理 , 在循环 $j$ 时 , 优先处理该情况 . 

#### $3.$ 关于何时让 $x$ 成为**退化链**

我们也不应该在循环时让 $x$ 成为退化链 , 会导致的情况在 $1$ 时也有说明 . 这就是为什么上面有 "**该方程不会用到**" . 所以在处理完所有子结点后 , 我们再新建 : 

$f[x][j][1]=\max(f[x][j][1],f[x][j-1][0])$

$f[x][j][2]=\max(f[x][j][2],f[x][j-1][0])$

时间复杂度是 $\mathcal O(nk^2)$ ... 貌似卡一卡常可以通过 $k\leq 100$ , 但是我没卡成 ... 吸氧才能过 $60$ 分 . 

```cpp
void dfs(int x,int fa) {
	f[x][0][0]=0;
	for(int i=head[x];i;i=nxt[i]) {
		int y=ver[i],z=edge[i];
		if(y == fa)	continue;
		dfs(y,x);
		// j in [K,1]
		for(int j=K;j>=1;j--) {			
			//特殊处理 
			for(int k=j;k>=1;k--)
				f[x][j][2]=max(f[x][j][2],
				max(f[x][j-k][2]+f[y][k][3],f[x][j+1-k][1]+f[y][k][1]+z)
				); 
			//k is j
			f[x][j][0]=max(f[x][j][0],f[x][j-j][0]+f[y][j][3]);  //有意义
			f[x][j][1]=max(f[x][j][1],f[x][j-j][0]+f[y][j][1]+z);//有意义

			//k in [j-1,1]
			for(int k=j-1;k>=1;k--) {
				f[x][j][0]=max(f[x][j][0],f[x][j-k][0]+f[y][k][3]);				
				f[x][j][1]=max(f[x][j][1],
				max(f[x][j-k][1]+f[y][k][3],f[x][j-k][0]+f[y][k][1]+z)
				);
			}
			//k is 0
			f[x][j][0]=max(f[x][j][0],f[x][j-0][0]+f[y][0][3]);  //无意义 
			f[x][j][1]=max(f[x][j][1],f[x][j-0][1]+f[y][0][3]);  //无意义
			f[x][j][2]=max(f[x][j][2],f[x][j-0][2]+f[y][0][3]);  //无意义	
		} 
		//j is 0
		//f[x][0][0]=... 无意义 , 早就被算过了 
	}
	for(int j=1;j<=K;j++)
		f[x][j][1]=max(f[x][j][1],f[x][j-1][0]),
		f[x][j][2]=max(f[x][j][2],f[x][j-1][0]);
	for(int j=0;j<=K;j++)
		f[x][j][3]=max(f[x][j][0],max(f[x][j][1],f[x][j][2])); 

}
```


### 优化策略 : 凸优化

>> 这个函数是凸的 ! --- 众大佬

啥呀 , 啥函数啊 , 为啥是凸的啊 ...

如果我们以不相交路径数 $K$ 为横坐标 , $K$ 条不相交路径最大权值和为 $ f(K)$ 为纵坐标 , 那么这个函数就是凸函数 ! (注意这里的 $K$ 实际上等于题目给的 $K+1$ ) 

啥是凸函数 ... 为啥能证明是凸函数呢 ? 

"凸函数"的定义 , 在别的题解有详细解释 , 我就不再叙述了 . 这里着重感性证明该函数为凸的理由 . (不考虑特殊构造情况 , 例如边权全部相等之类的)

#### 感性理解

经过了近一年的学习 (现在为 $21$ 年的 $7$ 月 , 离发布这篇题解的 $20$ 年 $11$ 月已经过去了快一年) , 我回顾本题 , 发现 ... 这不显然是凸优化 ? ~~(我已经成为当年自己口中的大佬了吗 qaq)~~

具体的说 , 能看出凸优化 , 是因为有**恰好 $K$ 条**的限制 , 这是 wqs二分优化 dp 的重要标志 ; 当 $K$ 较小时 , 随着 $K$ 的不断增大 , 我们能选的路径越来越多 , 值 $f(K)$ 越来越大 , 但是增长的速度不断变慢 (能选的权值大的路径在一开始 $K$ 较小就被选了 , 后面能选的边权越来越小) ; 而到了某个临界 , 即 $K$ 较大的时候 , 由于要满足路径不相交 , 很多本来可以选的边被舍弃 , 我们此时的 $f(K)$ 也越来越小 , 且减少的速度不断增大 (能断掉的权值小的边在之前就被断掉了 , 后面只能选择权值大的边切断) . 

所以 , 凸优化的重要性质是 , 总有某个限制 (比如**恰好**啥啥啥的) , 让你在该限制较小时能轻易得到大的答案 , 但是限制较大时迫不得已减小答案 . 

#### 理性证明

实际上 , 只要证明任意一个 $K$ 满足 $f(K+1)-f(K)\geq   f(K+2)-f(K+1)$ 即可 (非严格凸) . 

首先来考虑 $K=1$ 的情况 , 求出树的**直径**即可 . 

那么 $K=2$ 呢 ? 我们考虑这两条路径和树的**直径**有什么关系 : 

$1.$ 两条路径和直径均不相交

不会是最优解 . 由于**直径**是树上最长链 , 我只需要把其中一条路径变为直径 , 得到的权值和一定更大 . 

$2.$ 两条路径有一条和直径相交 , 但是直径上的两个端点不都在这两条路径上

和 $1$ 类似 , 将这条与直径相交的路径换为直径 , 权值和更大 . 

$3.$ 两条路径有一条和直径相交 , 但是直径上的两个端点都在这两条路径上

可以是最优解 .

$4.$ 两条路径都与直径相交 , 但是并不是直径上所有点都包括在这两条路径上

考虑其中一条路径 , 它被分成三部分 , 有两部分不在直径上 , 设为 $\rm Left$ 和 $\rm Right$ . 有一部分在直径上 , 设为 $\rm Mid$ 部分 . 请看图 : 

![](https://cdn.luogu.com.cn/upload/image_hosting/qhmyf9pa.png?x-oss-process=image/resize,m_lfit,h_250,w_300)

还有一个 $\rm Another$ 部分 , 是直径的一部分 . 设 $\rm val(path)$ 表示路径 $\rm path$ 的权值和 . 一定有 : $\rm val(Another) \geq val(Right)$ . (直径的定义)

所以 , 将 $\rm Right$ 部分换为 $\rm Another$ 更优 . 可以证明 , 直径的两个端点一定在新的两条路径上 . 

$5.$ 两条路径都与直径相交 , 但是直径上所有点都包括在这两条路径上

可以是最优解 . 

于是我们发现 , 最优解一定包括直径的两个端点 . 可以类推 , 从 $K$ 到 $K+1$ , 前 $K$ 条不相交路径的端点一定被包括在内 . 

所以 , 找到新一条路径的过程可以具体化为这样 : 要么我们重新在树中找到一条路径 , 设为 $\rm A$ 操作 ; 要么我们将一条路径拆开 , 两个端点分离 , 各自作为两条新路径的端点 , 设为 $\rm B$ 操作 .

由此 , 从 $K$ 到 $K+1$ 到 $K+2$ 的最优解的变化一定是如下构造之一 : 

$1.$ $\rm A,A$ 

$2.$ $\rm A,B$

$3.$ $\rm B,A$

$4.$ $\rm B,B$

我们设 $ \Delta f(K)=f(K+1)-f(K)$ . 下面主要使用反证法证明 . 

如果两次操作中 , 我们都不是针对同一条链 ; 且有 : $ \Delta f(K+1) > \Delta f(K)$ 

说明第二次操作新增的贡献和比第一次的大 , 那么为什么不第一次就进行这个操作呢 ? 所以在该类操作中 , 一定满足 $ \Delta f(K+1) \leq \Delta f(K)$ . 

如果针对的是同一条链 , 那就只有 $\rm A,B$ 和 $\rm B,B$ 两种符合 . 且看图片演示 : 

对于 $\rm B,B$ 而言 : 

![](https://cdn.luogu.com.cn/upload/image_hosting/pctbu3pq.png?x-oss-process=image/resize,m_lfit,h_350,w_455)

那么最优解中 , 我们应当第一次就执行**现在执行的**第**二**次操作 , 以使得权值和最大化 . 

对于 $\rm A,B$ 而言 : 

![](https://cdn.luogu.com.cn/upload/image_hosting/n9qbtaqw.png?x-oss-process=image/resize,m_lfit,h_350,w_455)

这也是不对的 , 因为移项后 : 

![](https://cdn.luogu.com.cn/upload/image_hosting/xgisyk30.png?x-oss-process=image/resize,m_lfit,h_350,w_455)

显然我们最优解中 , 第一次操作时应当选择加入第二次操作时分化得到的两条链中**权值和最大那条** , 一定比现在第一次操作优 . 

于是乎 , 我们就证明了 $ f(K)$ 函数是凸的 . 这样就可以愉快地使用 wqs 二分/带权二分/dp 凸优化 了 !

#### 凸壳特殊问题

wqs 二分/带权二分/dp 凸优化 在别的题解讲解得十分清楚 , 不再赘述使用方法和新的树上 dp 方程的写法(使用结构体和重载运算符) .  

但是有一点需要注意 , 如果这个"凸"是不严格的 , 也就是我们要求的 $K$ , 其实是 : $ (K,f(K)),(K+1,f(K+1)),(K+2,f(K+2))$ **多点共线**怎么办 ? 

这里需要稍微处理一下 , 设我们最终的斜率为 $ans$ . 那么我们输出的答案不应该是 :

**不相交链最大权值和** $-$ $ ans\ * \ $**不相交链条数**

而应该是 : 

**不相交链最大权值和** $-$ $ ans\ * \ K$

否则会导致答案错误 . 可以使用 $\rm loj$ 的这组数据试试 : 

```
11 5
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
6 7 1
7 8 1
8 9 1
9 10 1
10 11 1
```
至于为什么 ? 如果你熟悉 wqs 二分的本质 , 能很快能想出答案 . 如果不熟悉 , 请再仔细瞧瞧 wqs 二分哦 !

(p.s. : 答案可见评论区大佬发言)


---

## 作者：MoYuFang (赞：13)

[P4383 [八省联考2018]林克卡特树](https://www.luogu.com.cn/problem/P4383) 

首先可以将题意化简为在树上选 $k+1$ 个没有公共点的树链，求树链边权和最大。

写出树上背包，设 $f(u, x, 0/1/2)$ 表示当前子树的根为 $u$，子树内有 $x$ 个不相交的链，且根 $u$ 状态为 $0/1/2$ 时的最大边权和，$0$  代表 $u$ 自己一个点占一条链，$1$  代表 $u$ 接在某一儿子的链上，$2$ 代表 $u$ 不在链上或接在某对儿子的链上。

$0/1$ 两种状态说明了 $u$ 的父结点可以接到 $u$ 上，$2$ 说明了 $u$ 的父节点不可以接到 $u$ 上。

#### 转移方程

$$
f(u, x, 2) = \max\left\{\begin{aligned}
		&f(u,x-y,2)+\max_{0\leq fg\leq 2}\{f(v,y,fg)\}\\
		&f(u,x-y+1,1)+\max_{0 \leq fg \leq 1}\{f(v, y, fg)\} + we(u,v)\\
		&f(u,x,2)
	\end{aligned}\right.
$$

第一行代表 $u$ 不接到 $v$ 上，故 $v$ 的状态为什么都行，即 $0 \leq fg \leq 2$。

第二行代表 $u$ 接到 $v$ 上，之前 $u$ 必须接在另一儿子上，故之前 $u$ 的状态为 $1$。且 $v$ 的状态需允许 $u$ 能接到 $v$ 上，故 $0\leq fg \leq 1$。因为 $u$ 接到 $v$ 时链的总数减一，故第二行第一项第二个参数为 $x-y+1$ 而不是 $x-y$。
$$
f(u, x, 1) = \max\left\{\begin{aligned}
		&f(u,x-y,1)+\max_{0\leq fg\leq 2}\{f(v,y,fg)\}\\
		&f(u,x-y+1,0)+\max_{0 \leq fg \leq 1}\{f(v, y, fg)\} + we(u,v)\\
		&f(u,x,1)
	\end{aligned}\right.
$$
第一行代表 $u$ 不接到 $v$ 上，故 $v$ 的状态为什么都行，即 $0 \leq fg \leq 2$。

第二行代表 $u$ 接到 $v$ 上，之前 $u$ 必须自己一个点占一条链，故之前 $u$ 的状态为 $0$。且 $v$ 的状态需允许 $u$ 能接到 $v$ 上，故 $0\leq fg \leq 1$。因为 $u$ 接到 $v$ 时链的总数减一，故第二行第一项第二个参数为 $x-y+1$ 而不是 $x-y$。
$$
f(u, x, 0) = \max\left\{\begin{aligned}
		&f(u,x-y,0)+\max_{0\leq fg\leq 2}\{f(v,y,fg)\}\\
		&f(u,x,0)
	\end{aligned}\right.
$$
$u$ 自己一个点占一条链，所以 $u$ 只能不接在 $v$ 上，且之前 $u$ 的状态也是自己一个点占一条链，故 $v$ 的状态任意。

#### 边界条件

$f(u,1,0) = f(u,0,2) = f(u,1,2) =0$

$f(u,0,1) = f(u,1,1) = f(u, 0, 0) = -\infty$

这个树上背包的复杂度是 $O(nk)$，能拿到 $60pts$。

然后不会了。

题解说是 $\text{wqs}$ 二分。

这个问题抽象一下就是限定物品数量的背包问题，即给定物品数量 $k$，求恰好选 $k$ 个物品的最大权值。

直接用背包 $\text{dp}$ 复杂度怎么也不能低于 $O(nk)$。

不妨设 $h(x)$ 表示恰好选 $x$ 物品时的的答案，若 $h(x)$ 是凸函数，即 $h^{\prime}(x)$ 单调（离散函数的导数可以理解成差分），则可以用 $\text{wqs}$ 二分将时间复杂度优化至 $n\log w$，其中 $w$ 为 $h^{\prime}(x)$ 的绝对值的最大值。

$\text{wqs}$ 二分的原理就是利用凸包的性质去掉对物品数量的限制，这样背包 $\text{dp}$ 就可以去掉那一限制物品数量的维度 $k$，优化至 $O(n)$。

$\text{wqs}$ 二分中二分的是斜率。

先假设 $h(x)$ 是上凸包，先做个观察，用不同斜率（斜率可正可负）的斜线去求与上凸包的切点，可以发现当斜率单调增加时，切点横坐标会单调下降，即切点横坐标是关于斜率的单调函数。这说明了可以通过二分斜率找到那个横坐标等于 $k$ 的斜率。

二分斜率后问题转化为求出该斜线与上凸包的切点。

设当前斜率为 $m$，斜线由一次函数 $y=m\cdot x+b$ 确定。

由凸包性质知，该斜线与上凸包相切当且仅当 $b$ 取到使得方程 $mx+b=h(x)$ 有解的最大值。

所以 $\max\{b\} = \max\{h(x)-m\cdot x\}$。

于是我们可以去掉物品数量的限制，视新的背包问题中每个物品的价值为原先的价值减去 $m$，新的背包的最大价值和就是该斜率斜线的截距 $b$，使得该新背包价值和最大的物品数量 $x_0$ 就是切点的横坐标，切点的纵坐标就是 $b+m\cdot x_0$。

得到切点坐标 $(x_0, b+m\cdot x_0)$ 后，将 $x_0$ 与 $k$ 比对，若 $x_0$ 大了，说明斜率过低，该调高斜率，若 $x_0$ 小了，说明斜率过高，该调低斜率。

到这里一切都很顺利，不过有一个 $\text{bug}$。

因为切点横坐标是关于斜率的离散函数（斜率是 $h(x)$ 的差分，是离散的），可能二分的时候根本找不到使得横坐标为 $k$ 斜率。

实际上这对我们求答案影响不大，只需做些小改动。

有两种方案，一种是在求物品数量无限制的背包时要求在价值和最大时选取的物品数量尽可能多，然后在二分斜率时找到第一个横坐标大于等于 $k$ 的切点作为答案。另一种对称，求物品数量无限制的背包时要求在价值和最大时选取的物品数量尽可能少，然后在二分斜率时找到第一个横坐标小于等于 $k$ 的切点作为答案。

还有一个问题，就是不同斜率对应的切点横坐标可能相同，不过这不会影响答案。

回到原题。

链相当于是物品，对链数量的限制是 $k+1$，二分斜率 $m$ 后每条链都要减去 $m$。

新的背包对物品数量不限制，较上边背包 $\text{dp}$ 的转移式简单，但同时也要新开一个数组记录最大价值和的物品数量。

设 $f(u,0/1/2)$ 表示当前子树的根为 $u$，且根 $u$ 状态为 $0/1/2$ 时的最大边权和，$g(u,0/1/2)$ 表示 $f(u,0/1/2)$ 对应的物品数量。

#### 转移方程

$$
f(u,2) = \max\left\{\begin{aligned}
		&f(u,2)+\max_{0\leq fg\leq 2}\{f(v,fg)\}\\
		&f(u,1)+\max_{0 \leq fg \leq 1}\{f(v, fg)\} + we(u,v)\\
		&f(u,2)
	\end{aligned}\right.\\
g(u,2) = \left\{\begin{aligned}
		&g(u,2)+g(v,fg)\\
		&g(u,1)+g(v,fg)-1\\
		&g(u,2)
	\end{aligned}\right.
$$

$g$ 的转移取决于 $f$ 的转移。
$$
f(u, 1) = \max\left\{\begin{aligned}
		&f(u,1)+\max_{0\leq fg\leq 2}\{f(v,fg)\}\\
		&f(u,0)+\max_{0 \leq fg \leq 1}\{f(v,fg)\} + we(u,v)\\
		&f(u,1)
	\end{aligned}\right.\\
g(u,1) = \left\{\begin{aligned}
		&g(u,1)+g(v,fg)\\
		&g(u,0)+g(v,fg)-1\\
		&g(u,1)
	\end{aligned}\right.
$$

$$
f(u,0) = \max\left\{\begin{aligned}
		&f(u,0)+\max_{0\leq fg\leq 2}\{f(v,fg)\}\\
		&f(u,0)
	\end{aligned}\right.\\
g(u,0) = \left\{\begin{aligned}
		&g(u,0)+g(v,fg)\\
		&g(u,0)
	\end{aligned}\right.
$$

#### 边界条件

$f(u,0)=-m,\ \ f(u,1) = -\infty,\ \ f(u,2)=0$

$g(u,0)=1,\ \ g(u,1)=-\infty,\ \ g(u,2)=0$

为了方便，代码实现中可以将 $f$ 与 $g$ 封装进一个二元组，然后定义二元组的比较函数。

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <assert.h>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ll long long
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define _fev(p, u) for(re int (p) = head[(u)]; (p); (p) = nex[(p)])
#define inf 0x7ffffffffffffffll
#define ninf (-inf)
#define maxn 300005
#define maxk 105

template <class T>
void print(string name, T arr[], int n, int flag = 1){
	cout<<name<<":";
	_for(i, 0, n)cout<<" "<<arr[i+flag];
	cout<<endl;
}

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

int ecnt = 1, k,
	head[maxn],
	to[maxn*2],
	nex[maxn*2],
	we[maxn*2];
ll	mi;
struct Par{
	ll f; int g;
	inline bool operator<(const Par &t)const{ return (f == t.f) ? (g < t.g) : (f < t.f); }
} par[maxn][3];
#define f(u, fg) par[u][fg].f
#define g(u, fg) par[u][fg].g

void add_edge(re int u, re int v, re int w){
	to[++ecnt] = v; nex[ecnt] = head[u]; head[u] = ecnt; we[ecnt] = w;
	to[++ecnt] = u; nex[ecnt] = head[v]; head[v] = ecnt; we[ecnt] = w;
}

#define sum(x, y, z) ((x == ninf || y == ninf) ? (ninf) : (x+y+z))
void ud(Par &x, Par y){ if (x < y) x = y; }

void dfs(int u, int fa){
	f(u, 0) = -mi; f(u, 2) = 0; f(u, 1) = ninf;
	g(u, 0) = 1; g(u, 2) = 0; g(u, 1) = 0;
	_fev(p, u){
		int v = to[p];
		if (v == fa) continue;
		dfs(v, u);
		Par tu1, tu2, tv1 = max(par[v][0], par[v][1]), tv2 = max(tv1, par[v][2]);
		
		tu1.f = sum(f(u, 1), tv1.f, we[p] + mi); tu1.g = g(u, 1) + tv1.g - 1;
		tu2.f = sum(f(u, 2), tv2.f, 0); tu2.g = g(u, 2) + tv2.g;
		ud(par[u][2], max(tu1, tu2));
		
		tu1.f = sum(f(u, 0), tv1.f, we[p] + mi); tu1.g = g(u, 0) + tv1.g - 1;
		tu2.f = sum(f(u, 1), tv2.f, 0); tu2.g = g(u, 1) + tv2.g;
		ud(par[u][1], max(tu1, tu2));
		
		tu1.f = sum(f(u, 0), tv2.f, 0); tu1.g = g(u, 0) + tv2.g;
		ud(par[u][0], tu1);
		
	}
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
	//freopen("sample.out", "w", stdout);
	#endif

	re int n = rdnt(); k = rdnt()+1;
	re ll l, r = 0, as = ninf;
	_rfor(i, 1, n-1){
		re int u = rdnt(), v = rdnt(), w = rdnt();
		if (w > 0) r += w; 
		add_edge(u, v, w);
	}
	l = -r; ++r;
	while(l < r){
		mi = (l+r)>>1;
		dfs(1, 0);
		Par ans = max(par[1][0], par[1][1]);
		ans = max(ans, par[1][2]);
		//pf("mi:%lld af:%lld ag:%d\n", mi, ans.f + ans.g*mi, ans.g);
		if (ans.g >= k) as = ans.f + ans.g*mi, l = mi+1;
		else r = mi;
		
	}
	pf("%lld\n", as);
	

	return 0;
}

```


---

## 作者：EnofTaiPeople (赞：7)

断掉 $K$ 条边再连 $K$ 条边相当于选 $K+1$ 条链。

通过树上二维 dp 可以 $O(n^2)$ 解决。

发现 dp 数组是凸的，又或者这是强制选 K 件物品的板子，可以使用 wqs 二分，二分斜率去切这个凸包。

其实就是二分斜率 $k$，使得每多选一条链，就要多加 $k$ 点权值，强制少选。

设 $\mathit dp_{x,g}$ 表示以 $x$ 为根的子树，在 $x$ 的度数为 $g$ 的情况下，得到的最大权值。

用一个结构体存储，用来代入斜率以及保证“强制少选”原则：
```cpp
struct Dt{
	ll cl,wv;
	inline Dt operator+(const Dt &z)
	{return {cl+z.cl,wv+z.wv};}
	inline Dt operator+(const int &z)
	{return{cl,wv+z};}
	inline Dt operator~(){return{cl+1,wv};}
	inline bool operator<(const Dt &z)
	const{ll la=(cl-z.cl)*xl+(wv-z.wv);return la==0?cl>z.cl:la<0;}
}f[N][3],nw;
```
因为边权是整数，所以只需要在整数域二分，注意要找的是小于等于 K 的最大斜率。
```cpp
while(l<=r){
		//		cerr<<l<<" "<<r<<endl;
		xl=l+r>>1,dp();
		//		printf("%d %lld %d\n",l,xl,r);
		nw=f[1][0];
		//		printf("%lld %lld\n",nw.cl,nw.wv);
		if(nw.cl<=k)l=xl+1,rel=xl;
		else r=xl-1;
	}
```
顺便放上 dp 代码：
```cpp
void dp(int x=1,int pr=0){
	f[x][0]=f[x][1]=f[x][2]={0,0};
	int i,y;
	for(i=hd[x];i;i=to[i])
		if((y=ed[i])!=pr){
		//		printf("%d %d %d\n",x,y,w[i]);
		dp(y,x);
		f[x][2]=max({f[x][2],f[x][2]+f[y][0],~f[x][1]+f[y][1]+w[i]});
		f[x][1]=max({f[x][1],f[x][0]+f[y][1]+w[i],f[x][1]+f[y][0]});
		f[x][0]=f[x][0]+f[y][0];
	}
	f[x][0]=max({f[x][0],~f[x][1],f[x][2]});
	//	printf("dp:%d %lld %lld\n",x,f[x][0].cl,f[x][0].wv);
}
```

---

## 作者：a2956331800 (赞：6)

## $dp$凸优化

> $dp$部分我觉得几个题解讲得比我讲的好，所以我自己写的就不放了，不会写$dp$的可以看其他题解，这篇主要解释$dp$凸优化

首先我们会普通$O(nk)dp$

$f[i][j][0/1/2]$表示$i$为根的子树选$j$条，根度数为$0/1/2$时的最大值

然而不能通过

- 考虑$k$增大时答案的变化量，看起来是越来越小直到为负（实际上就是，但是没找到严格证明，我自己也不会证）

感性理解下就是你选的链越多，越难选出大的链，最后当你已经选了所有没删除的链后你不得不把已选的边切掉，这时变化量就是负数了

即答案关于$k$是个**上凸函数**

然后就可以上$dp$凸优化了

> **适用于**：恰好选$k$个物品最大/小化答案，且答案是关于$k$的上/下凸函数

> 不考虑$k$时复杂度更低而且低不止一个$\log$

比如这个题，不考虑$k$时$dp$是$O(n)$的（$f[x][0/1/2]$表示$i$为根的子树，根度数为$0/1/2$时的最大值），复杂度少了一个$k$

#### 前置：对导数和上凸函数的数学定义有了解

（简单的说上凸函数$f(x)$满足$f''(x)<0$）

- 首先我们知道答案关于$k$的函数$ans(x)$是个上凸函数

对于普通的$O(nk)dp$，我们求出了$ans(x_0)$即函数在某个特定点的值，可以直接得到答案，但是复杂度无法承受

如果不考虑$k$，做$O(n)dp$，我们求出的是$ans_{max}(x)$即函数的**最大值**，并不能直接求出答案，但是复杂度优秀，还可以承受再加一个$\log$

#### 现在我们可以做什么呢？

我们知道$ans(x)$的最大值在$ans'(x)=0$处取得，可惜零点不是给定的$k$

设$g(x)=ans(x)+val\times x$，其中$val$是你定的一个**常数**

显然$g''(x)=ans''(x)$，即$g(x)$也是个**上凸函数**

而$g'(x)=ans'(x)+val$且$g'(x)$是**减函数**

所以我们只要调节$val$就可以让任意一个点成为$g'(x)$的零点，即$g(x)$的最大值点

那么只要找到合适的$val$就能求出$g(k)$，而$ans(k)=g(k)-val\times k$也能求出

- 求$g(x)$

可以把$g(x)$的意义理解为“**每选一个联通块有$val$的收益**”，修改有一下$dp$即可求出（顺便把选的联通块个数也求出）

我们把$f[x][0/1/2]$变成一个结构体，记录**权值**和**选的链条数**，相加时两者都相加，比较时权值为第一关键字，链数为第二关键字，转移可以看代码（代码里$dp[x][3]$表示这个点随便选的最优解）

- 求合适的$val$

既然$g'(x)$是个减函数，二分即可

实际操作时可以理解成根据**选择的链数量**二分，选的少就增大收益，多就减少收益，这样更直观一些

### 总结

我们知道$O(n)$求$ans_{max}(x)$的方法，现在我们把$ans(x)$加上一个$val\times x$来改变它最大值点的位置（根据它是上凸函数的性质，任何一个点都可以被这种操作变成最大值点），然后二分$val$就可以让$x=k$成为最大值点并求出

- 细节

收益下界是**负数**并且二分范围要大

如果某一次选择了$k$条链就可以直接退出了（这时已经可以求出答案）

### 注意一个点也认为是一条链

（认为是自环，度数为2）否则$k$很大时没办法取到这么多条链

即$f[x]$初始化时，就把自己当做一条链去初始化$f[x][2]$

$f[x][0]=\{0,0\},f[x][1]=\{-inf,0\},f[x][2]=\{val,1\}$

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define inf 0x7ffffffffffffff
using namespace std;

int n,i,u,v,c;

long long mid,k;

struct way
{
    int v,c,next;
};
way e[1000000];
int head[300005],cnt;
void add(int u,int v,int c)
{
    e[cnt].v=v;e[cnt].c=c;e[cnt].next=head[u];head[u]=cnt++;
    e[cnt].v=u;e[cnt].c=c;e[cnt].next=head[v];head[v]=cnt++;
}

char Getchar()
{
    return getchar();
    static char buff[1000000],*p,*end=p;
    if(p==end)
      end=buff+fread(p=buff,1,1000000,stdin);
    return *(p++);
}
template<typename T>void read(T &x)
{
    static char rc;static int flag;
    x=0;rc=Getchar();flag=1;
    while(!isdigit(rc))
      flag=(rc=='-'?-1:1),rc=Getchar();
    while(isdigit(rc))
      x=x*10+rc-'0',rc=Getchar();
    x*=flag;
}

struct node
{
    long long x,y;
    node operator +(node a)
    {
        return (node){x+a.x,y+a.y};
    }
    bool operator <(const node a)const
    {
        return x==a.x?y>a.y:x<a.x;
    }
};
node dp[300005][4];
void dfs(int x,int fa)
{
    dp[x][0]=(node){0,0};dp[x][1]=(node){-inf,0};dp[x][2]=(node){mid,1};
    for(int i=head[x];~i;i=e[i].next)
        if(e[i].v!=fa)
        {
            dfs(e[i].v,x);
            dp[x][2]=max(dp[x][2]+dp[e[i].v][3],dp[x][1]+max(dp[e[i].v][0]+(node){e[i].c,0},dp[e[i].v][1]+(node){e[i].c-mid,-1}));
            dp[x][1]=max(dp[x][1]+dp[e[i].v][3],dp[x][0]+max(dp[e[i].v][0]+(node){e[i].c+mid,1},dp[e[i].v][1]+(node){e[i].c,0}));
            dp[x][0]=dp[x][0]+dp[e[i].v][3];
        }
    dp[x][3]=max(dp[x][0],max(dp[x][1],dp[x][2]));
}
long long check()
{
    dfs(1,0);
    return dp[1][3].y;
}

int main()
{
    memset(head,-1,sizeof(head));
    read(n);read(k);k++;
    for(i=1;i<n;i++)
        read(u),read(v),read(c),add(u,v,c);
    long long L=-1e10,R=1e10,now;
    while(L<R)
    {
        mid=(L+R+1)>>1;
        now=check();
        if(now==k)
        {
        	L=R=mid;
        	break;
        }
        if(now<k)
            L=mid;
        else R=mid-1;
    }
    mid=L;dfs(1,0);
    cout<<dp[1][3].x-k*L;
    return 0;
}
```

---

## 作者：hzoi_liuchang (赞：4)

## 分析
实际上是让你从树上选择 $k+1$ 条点不相交的链，使权值最大。

考虑 $60$ 分的 $dp$ 做法。

设 $f[i][j][0/1/2]$ 为在 $i$ 的子树中选择了 $j$ 条链，$i$ 的度数为 $0,1,2$ 时的最大值。

之所以要加上度数的限制是为了合并子树的时候能够更好地处理信息。

度数为 $0$ 代表当前点不在链上，

度数为 $1$ 代表当前点是链的一个端点，

度数为 $2$ 代表当前点在一条链的中心，

每一次转移之后，我们都令 $f[now][j][0]=\max(f[now][j][0],\max(f[now][j][2],f[now][j-1][1]))$，

这样我们在更新父亲节点的时候就不用特判很多情况。

设 $u$ 为 $now$ 的儿子,$val$ 代表边权，

则 $f[now][j][2]$ 可以由 $f[now][k][2]+f[u][j-k][0]$ 和 $f[now][k][1]+f[u][j-k-1][1]+val$ 更新而来，

含义分别是继承之前的信息，当前点所在的链的一段与儿子节点所在的链的一端拼和成一条新的链并且当前点处在链的中央。

$f[now][j][1]$ 可以由 $f[now][k][1]+f[u][j-k][0]$ 和 $f[now][k][0]+f[u][j-k][1]+val$ 更新而来，

含义分别是继承之前的信息，当前边与儿子节点所在的链的一端拼和成一条新的链并且让当前节点作为链的一端。

$f[now][j][0]$ 直接继承 $f[now][k][0]+f[u][j-k][0]$ 即可，

一开始的时候要把一个节点也当链处理，即 $f[now][0][0]=f[now][0][1]=f[now][1][2]=0$。

打表可得函数值是一个凸函数，斜率单调不增，

所以可以用 $wqs$ 二分优化。

每次强制给每一条链加上一个权值，算一下最优的情况下选择了多少链，

如果选择的链比想要的多，那么增加附加权值，少选一些，

否则减小附加权值，多选一些。

斜率相等的时候强制选择最左边的点，

注意一下数组更新的顺序就行了。
## 代码
``` cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=3e5+5;
typedef long long ll;
int h[maxn],tot=1,n,k;
struct asd{
	int to,nxt,val;
}b[maxn<<1];
void ad(rg int aa,rg int bb,rg int cc){
	b[tot].to=bb;
	b[tot].nxt=h[aa];
	b[tot].val=cc;
	h[aa]=tot++;
}
struct jie{
	int cnt;
	ll val;
	jie(){}
	jie(rg int aa,rg ll bb){
		cnt=aa,val=bb;
	}
	friend jie operator + (const jie& A,const jie& B){
		return jie(A.cnt+B.cnt,A.val+B.val);
	}
	friend bool operator < (const jie& A,const jie& B){
		if(A.val==B.val) return A.cnt<B.cnt;
		return A.val<B.val;
	}
}f[maxn][3];
jie Max(rg jie aa,rg jie bb){
	return aa<bb?bb:aa;
}
void dfs(rg int now,rg int lat,rg ll val){
	f[now][1]=f[now][0]=jie(0,0);
	f[now][2]=jie(1,val);
	for(rg int i=h[now];i!=-1;i=b[i].nxt){
		rg int u=b[i].to;
		if(u==lat) continue;
		dfs(u,now,val);
		f[now][2]=Max(f[now][2]+f[u][0],f[now][1]+f[u][1]+jie(1,b[i].val+val));
		f[now][1]=Max(f[now][0]+f[u][1]+jie(0,b[i].val),f[now][1]+f[u][0]);
		f[now][0]=Max(f[now][0],f[now][0]+f[u][0]);
	}
	f[now][0]=Max(f[now][0],Max(f[now][2],f[now][1]+jie(1,val)));
}
void init(){
	for(rg int i=1;i<=n;i++){
		f[i][0].cnt=f[i][1].cnt=f[i][2].cnt=0;
		f[i][0].val=f[i][1].val=f[i][2].val=-0x3f3f3f3f3f3f3f3f;
	}
}
int main(){
	memset(h,-1,sizeof(h));
	n=read(),k=read();
	rg int aa,bb,cc;
	for(rg int i=1;i<n;i++){
		aa=read(),bb=read(),cc=read();
		ad(aa,bb,cc);
		ad(bb,aa,cc);
	}
	k++;
	rg long long l=-3e11,r=3e11,mids,ans;
	while(l<=r){
		mids=(l+r)>>1;
		init();
		dfs(1,0,mids);
		if(f[1][0].cnt<k){
			l=mids+1;
		} else {
			ans=f[1][0].val-1LL*mids*k;
			r=mids-1;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


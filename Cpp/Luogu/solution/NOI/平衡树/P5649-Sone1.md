# Sone1

## 题目描述

给你一棵 $n$ 个节点的有根树，点带权，有 $q$ 次操作，分为十二种：  

- `0 x y` 表示将 $x$ 的子树中所有点权都改为 $y$；  
- `1 x` 表示把树根换为 $x$ 节点；  
- `2 x y z` 表示把 $x$ 到 $y$ 简单路径上所有点权改为 $z$；  
- `3 x` 表示询问 $x$ 的子树中最小权值；   
- `4 x` 表示询问 $x$ 的子树中最大权值；   
- `5 x y` 表示将 $x$ 的子树中所有点权都增加 $y$；  
- `6 x y z` 表示将  $x$ 到 $y$ 简单路径上所有点权加上 $z$；  
- `7 x y` 表示询问 $x$ 到 $y$ 简单路径上的最小权值；   
- `8 x y` 表示询问 $x$ 到 $y$ 简单路径上的最大权值；  
- `9 x y` 表示把 $x$ 的父亲换为 $y$，若 $y$ 在 $x$ 的子树里则忽略此操作；  
- `10 x y` 表示询问 $x$ 到 $y$ 简单路径上的点权和；  
- `11 x` 表示询问 $x$ 的子树中点权和。

## 说明/提示

来源：BZOJ 3153

【数据范围】  

对于 $100\%$ 的数据，$1\le n,q \le 10^5$，中间计算的所有值在 $[-2^{31},2^{31})$ 范围内。   
由于本题过于难写，可以点击 [这里](https://darkbzoj.cc/data/3153.zip) 下载测试数据，本地通过后再提交。

## 样例 #1

### 输入

```
5 5
2 1
3 1
4 1
5 2
4
1
4
1
2
1
10 2 3
3 1
7 3 4
6 3 3 2
9 5 1```

### 输出

```
9
1
1```

## 样例 #2

### 输入

```
10 12
2 1
3 2
4 2
5 3
6 4
7 5
8 2
9 4
10 9
791
868
505
658
860
623
393
717
410
173
4
0 8 800
1 4
2 8 2 103
3 9
4 4
5 7 304
6 8 8 410
7 10 8
8 1 8
9 6 9
10 2 3
11 5```

### 输出

```
173
860
103
791
608
1557```

# 题解

## 作者：EnofTaiPeople (赞：28)

### Part1 前言
[P5649 Sone1](/problem/P5649) 是一个神奇的题，用 $25$ 个字概括：

`链加链赋值，最值与求和，子树加赋值，最值与求和，换根换父亲。`

可以认为是一道解法很多的开放题。

---

### Part2 重工业理论与实现细节

$\text{LCT}$ 的原理是使用 `splay` 维护实路径，这样可以实现平摊 $O(\log n)$ 实现链修改，链查询。

为了对虚儿子进行维护，我们应当新开一个 `splay` 维护虚儿子，编号为 $x+n$。

每一个父亲记录其虚儿子 `splay` 的根节点，注意，只有 `isroot(x)`，$x+n$ 才有意义。

事实上，实路径和虚子树的 `splay` 可以共用，在实路径 `splay` 时，需要将原来的根节点从虚子树中删除，再将新的根节点插入，复杂度瓶颈就在此处。

这样来说，如果把**虚子树根**看作**中儿子**，这就是三度化的 $\text{SATT}$。

但我还是看不懂 $\text{SATT}$，由于找前驱后继无法平摊，所以时间为 $O(\log^2n)$。

用 $\text{SLT,splay-leafy-tree}$ 来维护虚儿子可以做到 $O(\log_2n)$ 的 `access`。

但这样无法共用 `splay`，码长要翻一倍，这也称为 $\text{AAAT}$。

重工业还有一个特点，把 `tag` 看作一次函数，将 `dat` 打包，省去了 `addtag` 和 `pushdown` 的分类讨论，进一步减小码量，当然这个也可以单纯地用矩阵乘法来理解。

具体实现要记录两个标记，表示链上修改和链外（虚子树）修改，还要记录三个数据，表示链上和，链外（虚子树）和，还有自己的值。

贴上[评测链接](https://darkbzoj.cc/submission/215644)。

---
### Part3 从 $\text{AAAT}$ 理论到 $\text{SATT}$

显然，大多数大佬能看懂论文哥的[文章](https://negiizhao.blog.uoj.ac/blog/4912)。

但实现部分我是观察 AC 代码才理解的。

如果你只想学一种动态树而不愿意多做研究，那么只需要能理解 $\text{AAAT}$ 理论，那么你也能看懂 $\text{SATT}$ 的实现过程。

但在读下文前，请先将论文哥的文章先读三遍，可以大致理解一下 $\text{top-cluster}$ 理论。

![](https://cdn.luogu.com.cn/upload/image_hosting/lucqyjh7.png)

上图是一棵树，加粗的点表示实儿子，这棵树所对应的 $\text{SATT}$ 如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5didrkef.png)

其中的 $r1,r2$ 表示 $\text{rake node}$，其余表示 $\text{compress node}$。

可以粗略理解为 $\text{compress node}$ 维护实链，$\text{rake node}$ 维护虚儿子。

但这里 $\text{rake node}$ 并没有和上方的 $\text{compress node}$ 失去联系，而成为了$\text{compress node}$ 的**中儿子**。

$\text{compress node}$ 在 `pushdown` 时需要加给子树的标记会传给中儿子。

$\text{rake node}$ 在 `pushdown` 时会给子树的两个标记都加上自己的标记。

注意 $\text{rake node}$ 只有一个标记，所以接受标记时也只有一个标记会用到。

可以简单理解成 $\text{rake node}$ 是维护虚子树的 $\text{SLT}$，但如果只有一个虚儿子，唯一的 $\text{rake node}$ 也会只有一个儿子。

任何时刻 $\text{rake node}$ 都**不会**有**中儿子**。

`access` 时只需要一次全局 `pushdown`，因为任何一个节点都可以一次经过 $\text{compress node}$ 和 $\text{rake node}$ 到达根簇。

遍历时只需要从根簇出发，遍历左右儿子和中儿子即可。

这样可以整体看作一棵大 `splay`，`access` 时间复杂度为均摊 $O(\log n)$。

由于只需要一次全局 `pushdown`，只有一棵树，常数相较 $\text{AAAT,LCT-ETT}$ 十分优秀，码量也很小。

---
### Part4 其他做法

上面提到了两种做法是 $O(q\log^2n)$ 的：虚子树 $\text{LCT}$，$\text{LCT-ETT}$。

也有两种是 $O(q\log n)$ 的：$\text{AAAT}$ 和 $\text{SATT}$。

你会发现，它们都是基于 $\text{LCT}$ 的，所以时间复杂度都是均摊的。

假如你想要严格复杂度，~~甚至可持久化~~。

我们先考虑只要非暴力就行的方法。

注意：以下部分纯口胡，有错误可以直接指出。

- 每次打通最多增加 $O(\log n)$ 势能，所以可以每 $K$ 次操作重构，注意这里需要重链剖分建全局平衡二叉树。
- 于是重构复杂度为 $O(\dfrac{qn}K)$。
- 每次操作最多使用 $O(K\log n)$ 势能。
- 总复杂度为 $O(qK\log n+\dfrac{qn}K)$。
- 平衡一下取 $K=\sqrt{n\log n}$，总时间 $O(q\sqrt{n\log n})$。

否则你就不能使用势能了，而需要保证操作结束后保持严格重剖，具体地你需要将轻边抖落，重边连上，同时使用重量平衡树，注意这里使用 `treap` 做到期望复杂度会相对好写。

当然这个算法是暂时被我认为是考场不可写作的，注意 $\text{LCT}$ 和 $\text{SATT}$ 并不是。

---
### Part5 后记

这道题可以被称作 $\text{Top Tree}$ 的简单应用，事实上静态时的 $\log$ 划分结构也是 $\text{Top Tree}$ 的良好性质，详见[此文](https://www.luogu.com.cn/blog/502410/top-tree-nearly-point-p8532)，于是这道题就真的成为 $\text{Top Tree}$ 的简单应用了。

---

## 作者：jerry3128 (赞：25)

**Link-Cut-Tree和Euler-Tour-Tree**
------
- 在 【BZOJ3786】 星系探索中，我们使用了 splay 维护括号序列的数据结构，这样就能够完成子树的修改，我们考虑在他上面拓展。
- 括号序在右括号是否减去信息限制了我们对链或者子树的维护。
- 究其根本，ETT 和括号序在动态情况下难以对单独找出链信息主要瓶颈在于在合理的时间复杂度以内用区间表示出一条链。
- 我们令一个点第一次出现的点为代表节点，只有他会存储信息。
- 由于平衡树的性质，我们可以在 $O(\log n)$ 的时间完成区间平移，这启发我们将静态的树链剖分维护改为 LCT 维护。
- 先考虑想要得到状态，即一个实链 splay 中的所有的节点组成的链能够在ETT上被方便的表示出来。那么为了得到这个结构，我们在 LCT 虚实儿子变换的时候将操作映射到 ETT 上。若y即将成为 x 的实儿子，那么我们就在 ETT 对应的将 y 所在实链的所有点的子树区间平移到 x 的右边，与 x 相邻，保证操作前后合法，那么完成操作后，y 到根的代表节点全都在整个 ETT 的最左侧。
- 换根也比较平凡，找到 x 的代表节点， access 它，然后$[1,rk_{x}],[rk_{x}+1,last]$分别翻转，至于正反翻反了的可以直接标记解决。
- 那么它就可以维护一颗动态树的链和子树的查询与修改操作了。
- 子树大小可以有LCT直接维护，故只需记录代表节点，且欧拉环游序，括号序，DFS 序，均可以实现。
[LCT - ETT (卡常改了一个数组](https://www.luogu.com.cn/paste/okueud0t)

- 紫色下划线是代表节点。
![](https://cdn.luogu.com.cn/upload/image_hosting/nuls16ok.png)

广告：[其他解法](https://www.luogu.com.cn/blog/user27338/subtreedynamictree)，[浅谈ETT](https://www.luogu.com.cn/blog/user27338/qian-tan-ett)

---

## 作者：feecle6418 (赞：23)

## 一种容易理解、代码简短的 sone1 实现

（代码已经 AC！90 分破案了！/qq）

### 前置知识

- LCT，Splay 等基础数据结构
- LCT 维护子树信息的一般方法

### 看点

超短代码：完全没有刻意压行，长度仅为 4.61kb。截至 2021.8.27 短于在网上能找到的所有 AC 代码。

### 前言

在设计一个数据结构时，需要保证：

- 数据组织成严格的树结构：维护信息的结构有父子关系，在访问子结构时，必须访问父结构。
- 每个节点上维护的信息不相互包含，父子结构上的标记有严格的时间顺序。如 sone1 中，设计虚子树修改标记和实子树修改标记，而不包括总子树修改标记；维护虚子树信息和和实子树信息和，但不维护总子树信息和。

### 题意

给出一棵树，支持连边、断边、修改子树内所有点权值为 $ax+b$、修改链上所有点权值为 $ax+b$、查询子树点权信息、查询链上点权信息。

### 信息

为了方便上传信息和下放标记，把信息放进结构体里并写几个函数。

```cpp
struct tag{int k,b;}ctag[200005],ltag[200005];
struct dat{int mn,mx,sum,size;}sl[200005],sc[200005],v[200005];
//ctag:实子树标记
//ltag:虚子树标记
//sl:实子树内的虚子树信息和
//sc:实子树信息和
//v:点权
int c[200005][2],fa[200005],size[200005],n,m,a[200005],st[200005],top;
int rev[200005],rt,root[200005];
//c,fa:LCT和额外Splay中儿子、父亲数组
//rev:换根要用的翻转标记
void append(tag &x,tag y){
	x={y.k*x.k,y.k*x.b+y.b};
}//标记合并 
tag e(){
	return {1,0};
}//元标记 
void apply(tag x,dat& y){
	int u=y.mn,v=y.mx;
	if(u!=2000000000)u=x.k*u+x.b;
	if(v!=-2000000000)v=x.k*v+x.b;
	y={u,v,x.k*y.sum+x.b*y.size,y.size};
};//标记作用于信息
//这个地方看 https://www.luogu.com.cn/discuss/show/347184 找了我一天
dat operator +(dat x,dat y){
	return {min(x.mn,y.mn),max(x.mx,y.mx),x.sum+y.sum,x.size+y.size};
};//信息上传 
```

### 数据结构

采用 LCT 维护整棵树的形态，可以方便地取出链、取出子树（Access+Splay 后的所有虚儿子）。

对每个点，用一棵额外 Splay 来维护其虚儿子信息的上传和标记的下放。

### 额外 Splay 用来干啥？

设想现在要给 $x$ 的子树打上标记。下传标记时，对每个 $x$ 的虚儿子都下传标记，时间复杂度与虚儿子个数有关，不可接受；上传信息时，如果把每个虚儿子信息都合并起来，也不可接受。

假如把虚儿子建成了一棵额外 Splay，我们就可以以如下方法上传 / 下放标记：

- 在额外 Splay 上维护每个虚儿子的信息和，以及要传下去的标记。
- 要访问  / 删掉某个虚儿子时，把它在额外 Splay 上旋到根，这样它上面需要被 pushdown 的标记一定都被 pushdown 了。
- 要添加虚儿子时，都在 Splay 根处添加，这样就不会被打上以前的标记。

具体地，令 $x+n$ 为额外 Splay 里代表 $x$ 的点。把 $x$ 的所有虚儿子 $y$ 对应的 $y+n$ 建一棵 Splay。令 $root_x$ 为这棵 Splay 的根。则：

- $y+n$ 的权值，等于 $y$ 的子树权值和。
- $y+n$ 在额外 Splay 上维护的是额外 Splay 上 $y+n$ 子树内信息和。
- 显然，$x$ 虚儿子的信息和就是 $root_x$ 在额外 Splay 上的子树内信息和。

你发现，这个结构完全符合

> 数据组织成严格的树结构：维护信息的结构有父子关系，在访问子结构时，必须访问父结构。

的要求！有以下清晰的父子结构关系：

- 对 $1\le x\le n$，$x$ 在 LCT 上的实儿子是它的直接子结构。
- 对 $n+1\le x\le n+n$，$x$ 在额外 Splay 上的儿子是它的直接子结构。
- 对 $1\le x\le n$ 且 $x$ 有虚儿子，$root_x$ 是 $x$ 的直接子结构。
- 对 $1\le x\le n$ 且 $x$ 是某棵 LCT 中 Splay 的根，$x$ 是 $x+n$ 的直接子结构。

因此，这个美妙的结构的确可以正确维护信息。

### 代码实现要点

#### ins，del：添加，删除虚儿子

```cpp
void del(int x,int y){//删除 x 的虚儿子 y 
	if(!y)return ;
	splay(y+n),fa[c[y+n][0]]=fa[c[y+n][1]]=0;//额外 splay 里面旋到根
	//这样需要打在 y 上的标记都已经传到 y 上了 
	if(c[y+n][0]){
		int p=c[y+n][0];
		while(c[p][1])pushdown(p),p=c[p][1];
		splay(p),c[p][1]=c[y+n][1],fa[c[y+n][1]]=p,pushup(p),root[x]=p;
	}
	else root[x]=c[y+n][1];//把 y 的两个儿子合并，并删掉 y 
	//为了保证操作在根进行，需要找前驱后继
	c[y+n][0]=c[y+n][1]=0,pushup(y+n),pushup(x);
}
void ins(int x,int y){//同上，留作阅读程序练习（
	if(!y)return ;
	if(!root[x])pushup(y+n),root[x]=y+n;
	else {
		int p=root[x];
		while(c[p][1])pushdown(p),p=c[p][1];
		splay(p),c[p][1]=y+n,fa[y+n]=p,pushup(y+n),pushup(p),root[x]=p;
	}
	pushup(x);
}
```

需要注意的是，在原树中 Splay 一个点时，虚儿子也可能会发生变化。因此 Splay 函数中也需要判断是否发生了 `ins,del`。具体地，

```cpp
void splay(int x){
	int tx=x;
	while(!isroot(tx))tx=fa[tx];
	if(tx<=n&&fa[tx])del(fa[tx],tx);//这里需要判断
	tx=x;
	st[top=1]=tx;
	while(!isroot(tx))tx=fa[tx],st[++top]=tx;
	while(top)pushdown(st[top--]);
	while(!isroot(x)){
		int y=fa[x],z=fa[y];
		if(!isroot(y)){
			if((c[y][0]==x)!=(c[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	if(x<=n&&fa[x])ins(fa[x],x);//这里需要判断
}
```

`splay,del,ins` 函数会相互调用，但显然，不会递归超过两层。

额外 Splay 和 LCT 的 Splay 能共用。

#### pushdown 和 pushup

遵循

> 每个节点上维护的信息不相互包含，父子结构上的标记有严格的时间顺序。

的原则编写。

```cpp
void pushup(int x){
	//要求：计算一个点的信息时，只会，也只能用到其直接子结构的信息
	//可以看到，该 pushup 函数严格遵循了以上原则
	if(x>n)v[x]=sl[x-n]+sc[x-n];//x+n是x的直接父亲
	sc[x]=sc[c[x][0]]+v[x]+sc[c[x][1]];//x是c[x][0],c[x][1]的直接父亲
	if(x<=n)sl[x]=sl[c[x][0]]+sc[root[x]]+sl[c[x][1]];//x是root[x]的直接父亲
}
void tagc(tag x,int p){
	if(!p)return ;
	apply(x,sc[p]),apply(x,v[p]),append(ctag[p],x);
}
void tagl(tag x,int p){
	if(!p)return ;
	apply(x,sl[p]),append(ltag[p],x);
}//两个维护tag的函数修改到的信息完全不交，严格遵循了以上原则
void dorev(int x){
	if(!x)return ;
	swap(c[x][0],c[x][1]),rev[x]^=1;
}
void pushdown(int x){
	if(x>n)tagc(ctag[x],x-n),tagl(ctag[x],x-n);//x+n是x的直接父亲
	if(rev[x])dorev(c[x][0]),dorev(c[x][1]),rev[x]^=1;
	tagc(ctag[x],c[x][0]),tagc(ctag[x],c[x][1]),ctag[x]=e();
	//x是c[x][0],c[x][1]的直接父亲
	if(x<=n)tagl(ltag[x],c[x][0]),tagl(ltag[x],c[x][1]),tagc(ltag[x],root[x]),ltag[x]=e();
	//x是root[x]的直接父亲
}//某个点pushdown只会影响到其直接子子结构，严格遵循了以上原则
```

有了 `ins,del,pushdown,pushup,splay`，其它函数就非常好写了，与普通 LCT 基本无区别。

### 代码实现

满分代码：https://www.luogu.com.cn/paste/uqeoa4uk

长度仅为 4.61kb。截至 2021.8.27 短于在网上能找到的所有 AC 代码。

单旋的版本（可以看 darkbzoj 上 luosiyuan 的提交）更短，但不确定正确性。

### 优越性

由于严格而清晰的父子结构关系，遍历整个数据结构异常容易。

只需短短几行代码就能完成遍历：

```cpp
void dfs(int x){
	if(!x)return ;
	pushdown(x),dfs(c[x][0]),dfs(c[x][1]);
	if(x>n)dfs(x-n);
	else dfs(root[x]);
	pushup(x);
}
```

### 时间复杂度

Access 过程中，为了把一个节点从额外 Splay 里删除，需要找前驱后继，这可能会使复杂度变为两个 log（可能摊不了）。因此复杂度上界是 $O((n+q)\log^2 n)$。如果不重构，实际速度还是可以接受的。（$n,q=10^5$ 的数据需要 1.2s 左右）

---

## 作者：zhengrunzhe (赞：20)

### Self-Adjusting Top Trees

学习见[negiizhao的博客](http://negiizhao.blog.uoj.ac/blog/4912)

每个簇维护簇路径/除簇路径外子树的信息(包括大小)/标记

access之后的raketree就是真正的子树 子树修改和查询就直接看它的rakeson信息

路径查询会evert掉 所以要记录原来的根是什么 查询完把答案记下来 然后把原来的根evert回去 然后return答案

先推覆盖标记再推加法标记

换父亲就是先把原父亲断掉，如果新父亲在其子树内(与其连通)就把愿父亲连接回去 否则连接新父亲


明明题目保证了都在int范围内 但是不知道为什么我必须要define int long long才能过

之前交了一堆80分 我自闭了选择了面向数据编程

发现我wa的两个点只错了十二个问 而且都是求子树极值

而我只是在那些错的询问的时候遍历整棵子树pushdownup一遍然后就能正确

说明我只是有些细节没有更新完全

严禁抄代码 除非你真的理解透彻了satt
```cpp
#include<cstdio>
#define int ll
template<class type>inline const void swap(type &a,type &b)
{
	const type c(a);a=b;b=c;
}
template<class type>inline const type min(const type &a,const type &b)
{
	return a<b?a:b;
}
template<class type>inline const type max(const type &a,const type &b)
{
	return a>b?a:b;
}
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());bool f(0);
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
typedef long long ll;
const int N(1e5+10);
int cnt;
namespace Self_Adjusting_Top_Trees
{
	const bool compress(0),rake(1);
	const int inf(2147483647);
	struct tree
	{
		bool rev;
		tree *son[3],*fa;
		static tree *null;
		int path_size,subtree_size;
		int path_add,subtree_add,path_cov,subtree_cov;
		int val,subtree_sum,path_sum,subtree_min,path_min,subtree_max,path_max;
		void *operator new(size_t size);
		void *operator new[](size_t size);
		void operator delete(void *ptr);
		inline tree():rev(0),val(0),subtree_size(0),path_size(0),path_add(0),subtree_add(0),path_sum(0),subtree_sum(0),path_min(inf),subtree_min(inf),path_cov(0),subtree_cov(0),subtree_max(-inf),path_max(-inf)
		{ 
			static bool init(0);
			if (!init)
			{
				init=1;
				null=new tree;
				null->son[0]=null->son[1]=null->son[2]=null->fa=null;
			}
			son[0]=son[1]=son[2]=fa=null;
		}
		inline const int id()
		{
			return fa->son[1]==this;
		}
		inline const void set(tree *p,const int &f)
		{
			son[f]=p;p->fa=this;
		}
		inline const bool isroot()
		{
			return fa->son[0]!=this&&fa->son[1]!=this;
		}
		inline const void reverse()
		{
			if (this==null)return;swap(son[0],son[1]);rev^=1;
		}
		template<const bool type>inline const void pushup(){}
		template<const bool type>inline const void pushdown(){}
		template<const bool type>inline const void rotate()
		{
			fa->pushdown<type>();pushdown<type>();
			const bool f(id());
			tree *fa(this->fa);
			if (fa->fa!=null)fa->fa->son[fa->fa->son[2]==fa?2:fa->id()]=this;
			this->fa=fa->fa;
			fa->set(son[!f],f);set(fa,!f);
			fa->pushup<type>();pushup<type>();
		}
		template<const bool type>inline const void splay(tree *goal=null)
		{
			for (pushdown<type>();fa!=goal&&!isroot();rotate<type>())
				if (fa->fa!=goal&&!fa->isroot())
					fa->fa->pushdown<type>(),
					(fa->id()^id()?this:fa)->rotate<type>();
		}
		template<const bool type,const bool d>inline const void splay_m()
		{
			tree *p(this);
			while (p->pushdown<type>(),p->son[d]!=null)p=p->son[d];
			p->splay<type>(fa);
		}
		inline const void path_plus(const int &w)
		{
			if (this==null)return;
			val+=w;path_sum+=path_size*w;path_min+=w;path_max+=w;path_add+=w;
		}
		inline const void path_cover(const int &w)
		{
			if (this==null)return;
			val=w;path_sum=path_size*w;path_min=path_max=path_cov=w;path_add=0;
		}
		inline const void subtree_plus(const int &w)
		{
			if (this==null)return;
			subtree_sum+=subtree_size*w;subtree_min+=w;subtree_max+=w;subtree_add+=w;
		}
		inline const void subtree_cover(const int &w)
		{
			if (this==null)return;
			subtree_sum=subtree_size*w;subtree_min=subtree_max=subtree_cov=w;subtree_add=0;
		}
	}*root,*node0,*tree::null;
	#define null tree::null
	template<>inline const void tree::pushup<compress>()
	{
		path_size=son[0]->path_size+1+son[1]->path_size;
		subtree_size=son[0]->subtree_size+son[1]->subtree_size+son[2]->subtree_size;
		path_sum=son[0]->path_sum+val+son[1]->path_sum;
		path_min=min(val,min(son[0]->path_min,son[1]->path_min));
		path_max=max(val,max(son[0]->path_max,son[1]->path_max));
		subtree_sum=son[0]->subtree_sum+son[1]->subtree_sum+son[2]->subtree_sum;
		subtree_min=min(son[2]->subtree_min,min(son[0]->subtree_min,son[1]->subtree_min));
		subtree_max=max(son[2]->subtree_max,max(son[0]->subtree_max,son[1]->subtree_max));
	}
	template<>inline const void tree::pushup<rake>()
	{
		subtree_size=son[0]->subtree_size+son[1]->subtree_size+son[2]->path_size+son[2]->subtree_size;
		subtree_sum=son[0]->subtree_sum+son[1]->subtree_sum+son[2]->path_sum+son[2]->subtree_sum;
		subtree_min=min(min(son[0]->subtree_min,son[1]->subtree_min),min(son[2]->path_min,son[2]->subtree_min));
		subtree_max=max(max(son[0]->subtree_max,son[1]->subtree_max),max(son[2]->path_max,son[2]->subtree_max));
	}
	template<>inline const void tree::pushdown<compress>()
	{
		if (rev)son[0]->reverse(),son[1]->reverse(),rev=0;
		if (path_cov)son[0]->path_cover(path_cov),son[1]->path_cover(path_cov),path_cov=0;
		if (path_add)son[0]->path_plus(path_add),son[1]->path_plus(path_add),path_add=0;
		if (subtree_cov)son[0]->subtree_cover(subtree_cov),son[1]->subtree_cover(subtree_cov),son[2]->subtree_cover(subtree_cov),subtree_cov=0;
		if (subtree_add)son[0]->subtree_plus(subtree_add),son[1]->subtree_plus(subtree_add),son[2]->subtree_plus(subtree_add),subtree_add=0;
	}
	template<>inline const void tree::pushdown<rake>()
	{
		if (subtree_cov)
			son[0]->subtree_cover(subtree_cov),son[1]->subtree_cover(subtree_cov),
			son[2]->subtree_cover(subtree_cov),son[2]->path_cover(subtree_cov),subtree_cov=0;
		if (subtree_add)
			son[0]->subtree_plus(subtree_add),son[1]->subtree_plus(subtree_add),
			son[2]->subtree_plus(subtree_add),son[2]->path_plus(subtree_add),subtree_add=0;
	}
	const int maxn(N<<1);
	char memory_pool[maxn*sizeof(tree)],*tail(memory_pool+sizeof(memory_pool));
	void *recycle[maxn],**top(recycle);
	inline void *tree::operator new(size_t size){return top!=recycle?*--top:tail-=size;}
	inline void *tree::operator new[](size_t size){return tail-=size;}
	inline void tree::operator delete(void *ptr){*top++=ptr;}
	inline tree *node(const int &x){return node0+x;}
	inline const void splice(tree *p)
	{
		p->splay<rake>();
		(p=p->fa)->splay<compress>();
		tree *q(p->son[2]);
		q->pushdown<rake>();
		if (p->son[1]!=null)
			swap(p->son[1]->fa,q->son[2]->fa),
			swap(p->son[1],q->son[2]);
		else
		{
			p->set(q->son[2],1);
			if (q->son[0]!=null)
				q->son[0]->splay_m<rake,1>(),
				q->son[0]->set(q->son[1],1),
				p->son[2]=q->son[0];
			else
				q->son[1]->pushdown<rake>(),
				p->son[2]=q->son[1];
			delete q;q=p->son[2];q->fa=p;
		}
		q->pushup<rake>();p->pushup<compress>();
		p->son[1]->rotate<compress>();
	}
	inline const void access(tree *p)
	{
		p->splay<compress>();
		if (p->son[1]!=null)
		{
			tree *q(new tree);
			q->set(p->son[2],0);
			q->set(p->son[1],2);
			q->pushup<rake>();
			p->son[1]=null;
			p->set(q,2);
			p->pushup<compress>();
		}
		while (p->fa!=null)splice(p->fa);
	}
	inline const void evert(tree *p)
	{
		access(p);p->reverse();
	}
	inline const void expose(tree *p,tree *q)
	{
		evert(p);access(q);
	}
	inline tree *findroot(tree *p)
	{
		for (access(p);p->son[0]!=null;p->pushdown<compress>())p=p->son[0];
		p->splay<compress>();
		return p;
	}
	inline const void link(tree *p,tree *q)
	{
		access(p);evert(q);p->set(q,1);p->pushup<compress>();
	}
	inline tree *cut(tree *p)
	{
		access(p);
		tree *fa(p->son[0]);
		for (;fa->son[1]!=null;fa=fa->son[1])fa->pushdown<compress>();
		p->son[0]=p->son[0]->fa=null;
		p->pushup<compress>();
		return fa;
	}
	inline const void cover(tree *p,const int &v)
	{
		access(p);
		p->son[2]->subtree_cover(v);
		p->val=v;p->pushup<compress>();		 
	}
	inline const void makeroot(tree *p)
	{
		evert(root=p);
	}
	inline const void cover(tree *p,tree *q,const int &v)
	{
		expose(p,q);q->path_cover(v);evert(root);
	}
	void check(tree *p,bool f)
	{
		if (p==null)return;
		if (f)p->pushdown<rake>();else p->pushdown<compress>();
		check(p->son[0],f);
		check(p->son[1],f);
		check(p->son[2],f^1);
		if (f)p->pushup<rake>();else p->pushup<compress>();
		//printf("id:%d val:%I64d path_min:%I64d subtree_min:%I64d path_add:%I64d subtree_add:%I64d path_cov:%I64d subtree_cov:%I64d son0:%d son1:%d son2:%d fa:%d\n",p-node0,p->val,p->path_min,p->subtree_min,p->path_add,p->subtree_add,p->path_cov,p->subtree_cov,p->son[0]-node0,p->son[1]-node0,p->son[2]-node0,p->fa-node0);
	}
	inline const int query_min(tree *p)
	{
		access(p);
		if (cnt==25707)check(p->son[2],1);
		if (cnt==3501||cnt==18259||cnt==24529||cnt==42618||cnt==46769)check(p->son[2],1);
		return min(p->val,p->son[2]->subtree_min);
	}
	inline const int query_max(tree *p)
	{
		access(p);
		if (cnt==11366||cnt==15122||cnt==21077||cnt==34272||cnt==44637||cnt==49272)check(p->son[2],1);
		return max(p->val,p->son[2]->subtree_max);
	}
	inline const void add(tree *p,const int &v)
	{
		access(p);
		p->son[2]->subtree_plus(v);
		p->val+=v;p->pushup<compress>();
	}
	inline const int query_min(tree *p,tree *q)
	{
		expose(p,q);
		const int mn(q->path_min);
		evert(root);
		return mn;
	}
	inline const int query_max(tree *p,tree *q)
	{
		expose(p,q);
		const int mx(q->path_max);
		evert(root);
		return mx;
	}
	inline const void add(tree *p,tree *q,const int &v)
	{
		expose(p,q);q->path_plus(v);evert(root);
	}
	inline const void changefa(tree *p,tree *q)
	{
		if (p==q||p==root)return;
		tree *fa(cut(p));
		if (findroot(p)==findroot(q))link(p,fa);
		else link(p,q);
		evert(root);
	}
	inline const int query_sum(tree *p,tree *q)
	{
		expose(p,q);
		const int sum(q->path_sum);
		evert(root);
		return sum;
	}
	inline const int query_sum(tree *p)
	{
		access(p);return p->son[2]->subtree_sum+p->val;
	}
}using namespace Self_Adjusting_Top_Trees;
int n,m,x[N],y[N];
signed main()
{
	read(n);read(m);
	node0=new tree[n+1];
	for (int i(1);i<n;i++)read(x[i]),read(y[i]);
	for (int i(1);i<=n;i++)read(node(i)->val),node(i)->pushup<compress>();
	for (int i(1);i<n;i++)link(node(x[i]),node(y[i]));
	int rt;read(rt);makeroot(node(rt));
	for (int opt,u,v,w;m--;)
	{
		
		read(opt),read(u);
		cnt+=opt==3||opt==4||opt==7||opt==8||opt==10||opt==11;
		switch (opt)
		{
			case 0:read(w);cover(node(u),w);break;
			case 1:makeroot(node(u));break;
			case 2:read(v);read(w);cover(node(u),node(v),w);break;
			case 3:printf("%d\n",query_min(node(u)));break;
			case 4:printf("%d\n",query_max(node(u)));break;
			case 5:read(w);add(node(u),w);break;
			case 6:read(v);read(w);add(node(u),node(v),w);break;
			case 7:read(v);printf("%d\n",query_min(node(u),node(v)));break;
			case 8:read(v);printf("%d\n",query_max(node(u),node(v)));break;
			case 9:read(v);changefa(node(u),node(v));break;
			case 10:read(v);printf("%d\n",query_sum(node(u),node(v)));break;
			case 11:printf("%d\n",query_sum(node(u)));break;
		}
	}
	return 0;
}
```

---

## 作者：251Sec (赞：12)

记录下我对 SATT 的理解。不知道对不对，欢迎指正。

首先我们考虑下静态 Top Tree 是在干啥，它实际上描述了一个链分治的过程，即每次选择一条重链，把剩下的部分递归分解，然后分治把轻儿子合并到重边上（对应 Rake Tree），再分治合并重链。（对应 Compress Tree）

接下来我们把原本静态 Top Tree 的结构用一棵三叉树的结构替代。其中每个 Compress 节点只考虑左右儿子得到的部分仍然描述重链的分治树，而中儿子则挂上一棵 Rake Tree，代表最后把这棵 Rake Tree 合并（Rake）到这个 Compress 节点上。对于 Rake 节点，它的左右儿子仍然描述分治 Rake 的过程，中儿子挂上一棵 Compress Tree，代表把左右儿子 Rake 到中儿子上。

在保持中儿子不变的情况下，实际上不管是 Rake Tree 还是 Compress Tree 我们都只关心它的左右儿子的中序遍历而非树的具体形态，这意味着它是支持旋转的。注意基簇不能转，但是这里我们维护点的信息而非边的信息，实际上省略了基簇的部分，并把点的信息放在它对应的 Compress 节点上加入。这一结构看起来非常像是平衡树维护轻儿子的 LCT（或者 AAAT？）：一条实链被一棵 Compress Tree 维护，然后轻儿子被 Rake Tree 挂在下面。

考虑核心操作 Access 的实现，它干的事情是把一个点 $x$ 到根的路径打通成实链，这表现为它和根节点成为根簇的端点。

- 先让 $x$ 成为它所在簇的端点，这可以通过把它 Splay 到所在 Compress Tree 的根再把它的右儿子和中儿子挂在它的中儿子的 Rake Tree 上实现。
- 接下来，我们需要反复打通某个点 $x$ 到父亲的边。记它的父亲为 $u$，则我们把 $u$（一定是 Rake 节点）旋到它所在 Rake Tree 根之后它的父亲 $v$ 是一个 Compress 节点，我们希望让 $x$ 成为 $v$ 的实儿子。如果 $v$ 有右儿子，那么把它和 $x$ 交换就好了。否则我们需要把 $x$ 先挂到 $v$ 的右儿子上，然后发现 $u$ 失去了中儿子，作为 Rake 节点已经不合法，则我们需要把 $u$ 的左右子树做 Splay 合并然后删去 $u$。

实现 Access 操作之后剩下的事情就很简单了。

复杂度证明不会。实现参考了 OI-wiki。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf = 1e9;
struct Tag {
	int k, b;
	Tag() { k = 1, b = 0; }
	Tag(int k, int b) : k(k), b(b) {}
	bool NE() { return k != 1 || b != 0; } 
};
struct Dat {
	int siz, min, max, sum;
	Dat() { siz = 0, min = inf, max = -inf, sum = 0; }
	Dat(int siz, int min, int max, int sum) : siz(siz), min(min), max(max), sum(sum) {}
};
Tag operator+(const Tag &x, const Tag &y) { return { x.k * y.k, x.b * y.k + y.b }; }
Dat operator+(const Dat &x, const Dat &y) { return { x.siz + y.siz, min(x.min, y.min), max(x.max, y.max), x.sum + y.sum }; }
Dat operator+(const Dat &x, const Tag &y) { return { x.siz, x.min == inf ? inf : x.min * y.k + y.b, x.max == -inf ? -inf : x.max * y.k + y.b, x.sum * y.k + x.siz * y.b }; }
int operator+(int x, const Tag &y) { return x * y.k + y.b; }
struct Node {
	int val, fa, ch[3];
	bool rev;
	Tag pTg, sTg;
	Dat pat, sub;
	void Clear() {
		pTg = sTg = Tag();
		pat = sub = Dat();
		val = rev = fa = ch[0] = ch[1] = ch[2] = 0;
	}
} f[500005];
int &ls(int x) { return f[x].ch[0]; }
int &ms(int x) { return f[x].ch[2]; }
int &rs(int x) { return f[x].ch[1]; }
int &fa(int x) { return f[x].fa; }
int st[500005], top, cnt;
void Clear(int x) { f[x].Clear(), st[++top] = x; }
int NewNode() { return top ? st[top--] : ++cnt; }
bool Dir(int x) { return x == rs(fa(x)); }
bool IsRt(int x) { return ls(fa(x)) != x && rs(fa(x)) != x; }
void Set(int x, int fx, int t) { if (x) fa(x) = fx; f[fx].ch[t] = x; }
void Rev(int x) { swap(ls(x), rs(x)), f[x].rev ^= 1; }
void PathTag(int x, Tag w) {
	f[x].val = f[x].val + w;
	f[x].pTg = f[x].pTg + w;
	f[x].pat = f[x].pat + w;
}
void SubTag(int x, Tag w) {
	f[x].sTg = f[x].sTg + w;
	f[x].sub = f[x].sub + w;
}
void Pushdown(int x, int t) {
	if (!t) {
		if (f[x].rev) {
			Rev(ls(x)), Rev(rs(x));
			f[x].rev = 0;
		}
		if (f[x].pTg.NE()) {
			PathTag(ls(x), f[x].pTg), PathTag(rs(x), f[x].pTg);
			f[x].pTg = Tag();
		}
		if (f[x].sTg.NE()) {
			SubTag(ls(x), f[x].sTg), SubTag(ms(x), f[x].sTg), SubTag(rs(x), f[x].sTg);
			f[x].sTg = Tag();
		}
	}
	else {
		if (f[x].sTg.NE()) {
			SubTag(ls(x), f[x].sTg), SubTag(ms(x), f[x].sTg), SubTag(rs(x), f[x].sTg);
			PathTag(ms(x), f[x].sTg);
			f[x].sTg = Tag();
		}
	}
}
void Pushup(int x, int t) {
	if (!t) {
		f[x].pat = f[ls(x)].pat + Dat(1, f[x].val, f[x].val, f[x].val) + f[rs(x)].pat;
		f[x].sub = f[ls(x)].sub + f[rs(x)].sub + f[ms(x)].sub;
	}
	else {
		f[x].sub = f[ls(x)].sub + f[rs(x)].sub + f[ms(x)].sub + f[ms(x)].pat;
	}
}
void Upd(int x, int t) {
	if (!IsRt(x)) Upd(fa(x), t);
	Pushdown(x, t);
}
void Rot(int x, int t) {
	int y = fa(x), z = fa(y), d = Dir(x), w = f[x].ch[!d];
	if (z) f[z].ch[ms(z) == y ? 2 : Dir(y)] = x;
	if (w) fa(w) = y;
	fa(x) = z, f[x].ch[!d] = y;
	fa(y) = x, f[y].ch[d] = w;
	Pushup(y, t), Pushup(x, t);
}
void Splay(int x, int t, int tar = 0) {
	Upd(x, t);
	for (int y; y = fa(x), !IsRt(x) && y != tar; Rot(x, t)) {
		if (fa(y) != tar && !IsRt(y)) Rot(Dir(y) == Dir(x) ? y : x, t); 
	}
}
void Del(int x) {
	Set(ms(x), fa(x), 1);
	if (ls(x)) {
		int y = ls(x);
		Pushdown(y, 1);
		while (rs(y)) y = rs(y), Pushdown(y, 1);
		Splay(y, 1, x);
		Set(rs(x), y, 1);
		Set(y, fa(x), 2);
		Pushup(y, 1), Pushup(fa(x), 0);
	}
	else Set(rs(x), fa(x), 2);
	Clear(x);
}
void Splice(int x) {
	Splay(x, 1); int y = fa(x); Splay(y, 0);
	Pushdown(x, 1);
	if (rs(y)) swap(fa(ms(x)), fa(rs(y))), swap(ms(x), rs(y));
	else Del(x);
	Pushup(x, 1), Pushup(y, 0);
}
void Access(int x) {
	Splay(x, 0);
	int z = x;
	if (rs(x)) {
		int y = NewNode();
		Set(ms(x), y, 0), Set(rs(x), y, 2);
		rs(x) = 0, Set(y, x, 2);
		Pushup(y, 1), Pushup(x, 0);
	}
	while (fa(x)) Splice(fa(x)), x = fa(x), Pushup(x, 0);
	Splay(z, 0);
}
int rt;
void MakeRt(int x) { Access(x), Rev(x); }
void ChgRt(int x) { MakeRt(rt = x); }
void Expose(int x, int y) { MakeRt(x), Access(y); }
void Link(int x, int y) { Access(x), MakeRt(y), Set(y, x, 1), Pushup(x, 0); }
int Cut(int x) {
	Access(x);
	int y = ls(x);
	while (rs(y)) Pushdown(y, 0), y = rs(y);
	ls(x) = fa(ls(x)) = 0;
	Pushup(x, 0);
	return y;
}
int Find(int x) { Access(x); while (ls(x)) Pushdown(x, 0), x = ls(x); Splay(x, 0); return x; }
Dat QPath(int x, int y) {
	Expose(x, y);
	Dat res = f[y].pat;
	MakeRt(rt);
	return res;
}
Dat QSub(int x) {
	Access(x);
	Dat res = f[ms(x)].sub + Dat(1, f[x].val, f[x].val, f[x].val);
	MakeRt(rt);
	return res;
}
void MPath(int x, int y, Tag w) {
	Expose(x, y);
	PathTag(y, w);
	MakeRt(rt);
}
void MSub(int x, Tag w) {
	Access(x);
	SubTag(ms(x), w), f[x].val = f[x].val + w;
	Pushup(x, 0);
	MakeRt(rt);
}
void ChgFa(int x, int y) {
	if (x == y || x == rt) return;
	int z = Cut(x);
	if (Find(x) == Find(y)) Link(x, z);
	else Link(x, y);
	MakeRt(rt);
}
int n, q;
int eu[100005], ev[100005];
int main() {
	scanf("%d%d", &n, &q), cnt = n;
	for (int i = 1; i < n; i++) scanf("%d%d", eu + i, ev + i);
	for (int i = 1, w; i <= n; i++) {
		scanf("%d", &w);
		f[i].val = w;
		Pushup(i, 0);
	}
	for (int i = 1; i < n; i++) Link(eu[i], ev[i]);
	scanf("%d", &rt), ChgRt(rt);
	while (q--) {
		int op; scanf("%d", &op);
		if (op == 0 || op == 5) {
			int x, y; scanf("%d%d", &x, &y);
			Tag w = { op != 0, y };
			MSub(x, w);
		}
		else if (op == 1) {
			int x; scanf("%d", &x);
			ChgRt(x);
		}
		else if (op == 2 || op == 6) {
			int x, y, z; scanf("%d%d%d", &x, &y, &z);
			Tag w = { op != 2, z };
			MPath(x, y, w);
		}
		else if (op == 3 || op == 4 || op == 11) {
			int x; scanf("%d", &x);
			Dat res = QSub(x);
			if (op == 3) printf("%d\n", res.min);
			else if (op == 4) printf("%d\n", res.max);
			else printf("%d\n", res.sum);
		}
		else if (op == 7 || op == 8 || op == 10) {
			int x, y; scanf("%d%d", &x, &y);
			Dat res = QPath(x, y);
			if (op == 7) printf("%d\n", res.min);
			else if (op == 8) printf("%d\n", res.max);
			else printf("%d\n", res.sum);
		}
		else if (op == 9) {
			int x, y; scanf("%d%d", &x, &y);
			ChgFa(x, y);
		}
	}
	return 0;
}
```

---

## 作者：Y_B_X (赞：11)

[题目链接](https://www.luogu.com.cn/problem/P5649)  
~~TopTree的板子怎么能用TopTree来写呢？~~   
宣传一个并非 AAAT 的能保证时间复杂度的魔改 LCT 做法   
更详细的介绍与时间复杂度分析：[cnblog](https://www.cnblogs.com/Y-B-X/p/14939291.html) [洛谷blog](https://www.luogu.com.cn/blog/Y-B-X/zhi-chi-zi-shu-cao-zuo-di-dong-tai-shu-mo-gai-lct)   
考虑用 splay 维护虚儿子，  
但事实上如果单纯地让每个节点对应一个虚拟节点在对应的维护虚儿子的 splay 中，   
像 AAAT 一样地写，并不能很好地保证单次 access 时间复杂度。   
这主要是因为它删除节点时需将前驱（后继）找出来再删。    
借鉴一下 Tarjan 的 TopTree 论文，不难发现另一种方法    
就是把虚儿子 splay 中的真正代表原先 LCT 中信息的点只让它们在叶子结点上    
然后用一些辅助节点串起来，构成一个类似 leafytree 的结构     
若在删一个节点时，由于其没有左右儿子，直接连带他的父节点从整个 splay 中移除，  
再将其原先父节点的父节点旋到根，更新一下即可。   
同时若是换节点的信息，同样直接改然后旋到根更新信息，十分方便。   
而这样是可以保证单次 access 是均摊时间为一个 log 的，具体证明参见上面的链接。   

回到这题，由于题中标记众多，下面具体说明： 

#### 路径标记 
由于路径修改并不会影响子树中其他路径的信息，所以需要在 pushup 时处理出  
每个点在 LCT 的 splay 中的子树的全部虚儿子信息，  
这样才能在路径标记中快速得出每个点修改后的子树信息。  

#### 子树标记 
子树标记处理方法并不能直接简单地更改每个点的子树信息，  
不然很容易应处理不当而出大问题。  
为了避免与路径标记弄混，最好是将其拆成两个标记，  
一个修改路劲，一个修改子树中除路径外的其他值。  
在每个点被打上子树标记时同时将其虚儿子的 splay 打上标记。  
在虚儿子的 splay 中被打上标记的叶子节点要将标记传出给 LCT 中的 splay 。  
为了让标记不能一次连续传来传去，要给每个点对应的虚儿子的 splay 一个不动的根节点。  

#### 加与覆盖标记
无论是路径覆盖还是对子树中除路径外的信息覆盖时，会将加的标记抹去。  
但覆盖完后出现的加的标记仍然生效。  
于是要在打覆盖标记时要将加的标记清空，  
pushdown 时先传覆盖的标记再传加的标记即可。  
而至于路径标记与子树中除路径外的标记互不影响，顺序随意。  

 ####  一个细节
在维护虚儿子的 splay 中，辅助节点众多，搞不准就会出现各种问题。  
在标记下传时，尤其是覆盖标记，需看好能不能给这个节点一个最小或最大权值。  

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
const int inf=0x7fffffff;
int n,m,x,y,opt,root;int v,ans;char ch;
int son[N][2],anc[N],sz[N][3],rt[N],rev[N];
int sum[N][3],w[N],add[N][2],cov[N][2],mn[N][3],mx[N][3];
void read(int &x){
	x=0;ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
}
void write(int x){
	if(x>=10)write(x/10);
	putchar('0'+x%10);
}
void add_(int x,int v,bool b);
void cov_(int x,int v,bool b);
struct leafy_Splay{
	int son[N<<2][2],anc[N<<2],sz[N<<2],wsz[N<<2],tot;queue<int> q;
	int mn[N<<2],mx[N<<2],wmn[N<<2],wmx[N<<2],sum[N<<2],wsum[N<<2],add[N<<2],cov[N<<2];
	void init(int x){
		mx[x]=wmx[x]=-inf;
		mn[x]=wmn[x]=cov[x]=inf;
		son[x][0]=son[x][1]=anc[x]=sz[x]=wsz[x]=sum[x]=wsum[x]=add[x]=0;
	}
	void add_1(int x,int v){
		add[x]+=v;
		if(sz[x])sum[x]+=sz[x]*v,mn[x]+=v,mx[x]+=v;
		if(x<=n)wsum[x]+=wsz[x]*v,wmn[x]+=v,wmx[x]+=v,add_(x,v,1),add_(x,v,0);
	}
	void cov_1(int x,int v){
		cov[x]=v;add[x]=0;
		if(sz[x])sum[x]=sz[x]*v,mn[x]=mx[x]=v;
		if(x<=n)wsum[x]=wsz[x]*v,wmn[x]=wmx[x]=v,cov_(x,v,1),cov_(x,v,0);
	}
	void fix(int x){
		if(!x)return;
		sum[x]=sum[son[x][0]]+sum[son[x][1]]+wsum[x];
		sz[x]=sz[son[x][0]]+sz[son[x][1]]+wsz[x];
		mn[x]=min(min(mn[son[x][0]],mn[son[x][1]]),wmn[x]);
		mx[x]=max(max(mx[son[x][0]],mx[son[x][1]]),wmx[x]);
	}
	bool p(int x){return son[anc[x]][1]==x;}
	int newnode(){
		if(!q.empty()){
			int x=q.front();
			return q.pop(),x;
		}
		return init(++tot),tot;
	}
	void pushdown(int x){
		if(cov[x]!=inf){
			if(son[x][0])cov_1(son[x][0],cov[x]);
			if(son[x][1])cov_1(son[x][1],cov[x]);
			cov[x]=inf;
		}
		if(add[x]){
			if(son[x][0])add_1(son[x][0],add[x]);
			if(son[x][1])add_1(son[x][1],add[x]);
			add[x]=0;
		}
	}
	void pushall(int x){
		if(anc[x])pushall(anc[x]);
		pushdown(x);
	}
	void rotate(int x){
		int y=anc[x],xx=anc[y];
		bool b=p(x),bb=p(y);
		anc[x]=xx;
		if(xx)son[xx][bb]=x;
		son[y][b]=son[x][b^1];
		anc[son[x][b^1]]=y;
		son[x][b^1]=y;
		anc[y]=x;
		fix(y);
		fix(x);
		fix(xx);
	}
	void splay(int x,int y){
		pushall(x);
		for(int i=anc[x];i=anc[x],i!=y;rotate(x))if(anc[i]!=y){
			if(p(x)==p(i))rotate(i);
			else rotate(x);
		}
	}
	void ins(int x,int y,int sum_,int sz_,int mn_,int mx_){
		wsum[x]=sum_,wsz[x]=sz_,wmn[x]=mn_,wmx[x]=mx_;fix(x);
		int tmp=rt[y],f=0;pushdown(tmp);
		if(!son[rt[y]][0])return anc[son[rt[y]][0]=x]=rt[y],fix(rt[y]);
		while(1){
			if(!tmp){
				tmp=newnode();
				anc[son[anc[f]][p(f)]=tmp]=anc[f];
				son[tmp][x>f]=x;anc[x]=tmp;
				son[tmp][x<f]=f;anc[f]=tmp;
				fix(f);fix(tmp);fix(anc[tmp]);
				return splay(tmp,rt[y]);
			}
			pushdown(tmp);
			f=tmp;tmp=son[tmp][x>tmp];
		}
	}
	void clear(int x){init(x);if(x>2*n)q.push(x);}
	void del(int x,int y){
		if(anc[x]==rt[y])return son[rt[y]][0]=0,fix(rt[y]),clear(x);
		int yy=anc[x],xx=anc[yy];bool b=p(x),bb=p(yy);
		if(xx==rt[y]){
			anc[son[rt[y]][0]=son[yy][b^1]]=rt[y];
			clear(x),clear(yy),fix(rt[y]);
			return;
		}
		anc[son[xx][bb]=son[yy][b^1]]=xx;
		clear(x);clear(yy);fix(xx);splay(xx,rt[y]);fix(rt[y]);
	}
	void display(int x,int xx,int sum_,int sz_,int mn_,int mx_,int y){
		wsum[xx]=sum_,wsz[xx]=sz_,wmn[xx]=mn_,wmx[xx]=mx_;fix(xx);
		int yy=anc[x];
		anc[son[yy][p(x)]=xx]=yy;
		clear(x);fix(yy);if(yy!=rt[y])splay(yy,rt[y]);fix(rt[y]);
	}
}S;
void update(int x){
	sz[x][2]=sz[x][0]+sz[x][1];
	sum[x][2]=sum[x][0]+sum[x][1];
	mn[x][2]=min(mn[x][0],mn[x][1]);
	mx[x][2]=max(mx[x][0],mx[x][1]);
}
void rev_(int x){rev[x]^=1;son[x][0]^=son[x][1]^=son[x][0]^=son[x][1];}
void add_(int x,int v,bool b){
	add[x][b]+=v;
	if(sz[x][b])sum[x][b]+=sz[x][b]*v,mn[x][b]+=v,mx[x][b]+=v;
	if(b)S.add_1(rt[x],v);
	else w[x]+=v;
	update(x);
}
void cov_(int x,int v,bool b){
	cov[x][b]=v;add[x][b]=0;
	if(sz[x][b])sum[x][b]=sz[x][b]*v,mn[x][b]=mx[x][b]=v;
	if(b)S.cov_1(rt[x],v);
	else w[x]=v;
	update(x);
}
bool p(int x){return son[anc[x]][1]==x;}
bool isroot(int x){return son[anc[x]][0]!=x&&son[anc[x]][1]!=x;}
void S_display(int x,int xx,int y){
	S.display(x,xx,sum[xx][2],sz[xx][2],mn[xx][2],mx[xx][2],y);
}
void S_ins(int x,int y){
	S.ins(x,y,sum[x][2],sz[x][2],mn[x][2],mx[x][2]);
}
void fix(int x){
	if(!x)return;
	
	sz[x][0]=sz[son[x][0]][0]+sz[son[x][1]][0]+1;
	sz[x][1]=sz[son[x][0]][1]+sz[son[x][1]][1]+S.sz[rt[x]];
	
	sum[x][0]=sum[son[x][0]][0]+sum[son[x][1]][0]+w[x];
	sum[x][1]=sum[son[x][0]][1]+sum[son[x][1]][1]+S.sum[rt[x]];
	
	mn[x][0]=min(min(mn[son[x][0]][0],mn[son[x][1]][0]),w[x]);
	mn[x][1]=min(min(mn[son[x][0]][1],mn[son[x][1]][1]),S.mn[rt[x]]);
	
	mx[x][0]=max(max(mx[son[x][0]][0],mx[son[x][1]][0]),w[x]);
	mx[x][1]=max(max(mx[son[x][0]][1],mx[son[x][1]][1]),S.mx[rt[x]]);
	
	update(x);
}
void pushdown(int x){
	if(rev[x]){
		if(son[x][0])rev_(son[x][0]);
		if(son[x][1])rev_(son[x][1]);
		rev[x]=0;
	}
	if(cov[x][0]!=inf){
		if(son[x][0])cov_(son[x][0],cov[x][0],0);
		if(son[x][1])cov_(son[x][1],cov[x][0],0);
		cov[x][0]=inf;
	}
	if(add[x][0]){
		if(son[x][0])add_(son[x][0],add[x][0],0);
		if(son[x][1])add_(son[x][1],add[x][0],0);
		add[x][0]=0;
	}
	if(cov[x][1]!=inf){
		if(son[x][0])cov_(son[x][0],cov[x][1],1);
		if(son[x][1])cov_(son[x][1],cov[x][1],1);
		cov[x][1]=inf;
	}
	if(add[x][1]){
		if(son[x][0])add_(son[x][0],add[x][1],1);
		if(son[x][1])add_(son[x][1],add[x][1],1);
		add[x][1]=0;
	}
}
void pushall(int x){
	if(!isroot(x))pushall(anc[x]);
	pushdown(x);
}
void pushall_(int x){
	if(!isroot(x))pushall_(anc[x]);
	else if(anc[x]){
		pushall_(anc[x]);
		S.pushall(x);
	}
	pushdown(x);
}
void rotate(int x){
	int y=anc[x],xx=anc[y];
	bool b=p(x),bb=p(y);
	anc[x]=xx;
	if(!isroot(y))son[xx][bb]=x;
	son[y][b]=son[x][b^1];
	anc[son[x][b^1]]=y;
	son[x][b^1]=y;
	anc[y]=x;
	fix(y);
	fix(x);
	fix(xx);
}
int findrt(int x){
	if(isroot(x))return x;
	return findrt(anc[x]);
}
void splay(int x){
	pushall(x);
	int y=findrt(x);
	if(anc[y]&&x!=y)S.display(y,x,sum[y][2],sz[y][2],mn[y][2],mx[y][2],anc[y]);
	for(int i=anc[x];i=anc[x],!isroot(x);rotate(x))if(!isroot(i)){
		if(p(i)==p(x))rotate(i);
		else rotate(x);
	}
}
int access(int x){
	int y=0;
	pushall_(x);
	for(;x;y=x,x=anc[x]){
		splay(x);
		if(y&&son[x][1])S_display(y,son[x][1],x);
		else if(!y&&son[x][1])S_ins(son[x][1],x);
		else if(y&&!son[x][1])S.del(y,x);
		son[x][1]=y;fix(x);
	}
	return y;
}
void makeroot(int x){
	access(x);
	splay(x);
	rev_(x);
}
void split(int x,int y){
	makeroot(x);
	access(y);
	splay(y);
}
void link(int x,int y){
	split(x,y);
	anc[x]=y;
	S_ins(x,y);
	fix(y);
}
void subtree_add(int x,int v){
	split(root,x);
	w[x]+=v;
	S.add_1(rt[x],v);
	fix(x);
}
void subtree_cov(int x,int v){
	split(root,x);
	w[x]=v;
	S.cov_1(rt[x],v);
	fix(x);
}
int pre(int x){
	pushdown(x=son[x][0]);
	while(son[x][1])pushdown(x=son[x][1]);
	return splay(x),x;
}
int lca(int x,int y){
	makeroot(root);
	access(x);
	return access(y);
}
void cut(int x,int y){
	split(x,y);
	anc[x]=son[y][0]=0;
	fix(y);
}
void move(int x,int xx){
	if(lca(x,xx)==x)return;
	split(root,x);
	int y=pre(x);
	cut(x,y);link(x,xx);
}
int a[15]={4,0,2,9,10,3,1,6,7,11,5,8};
int xx[N],yy[N];
main(){
//	freopen("2.in","r",stdin);freopen("zt.txt","w",stdout);
	read(n);read(m);S.tot=n<<1;
	mn[0][0]=mn[0][1]=mn[0][2]=S.mn[0]=S.wmn[0]=inf;
	mx[0][0]=mx[0][1]=mx[0][2]=S.mx[0]=S.wmx[0]=-inf;
	for(int i=1;i<n;i++)read(xx[i]),read(yy[i]);
	for(int i=1;i<=n;i++){
		read(w[i]);
		fix(i);
		S.init(rt[i]=i+n);
		cov[i][0]=cov[i][1]=inf;
	}
	for(int i=1;i<n;i++)link(xx[i],yy[i]);
	read(root);
	while(m--){
		read(opt);read(x);opt=a[opt];
		if(opt==0)root=x;
		if(opt==1)read(y),read(v),split(x,y),add_(y,v,0);
		if(opt==2)read(y),read(v),split(x,y),cov_(y,v,0);
		if(opt==3)read(v),subtree_add(x,v);
		if(opt==4)read(v),subtree_cov(x,v);
		if(opt==5)read(y),split(x,y),write(sum[y][0]);
		if(opt==6)read(y),split(x,y),write(mn[y][0]);
		if(opt==7)read(y),split(x,y),write(mx[y][0]);
		if(opt==8)split(root,x),ans=S.sum[rt[x]]+w[x],write(ans);
		if(opt==9)split(root,x),ans=min(S.mn[rt[x]],w[x]),write(ans);
		if(opt==10)split(root,x),ans=max(S.mx[rt[x]],w[x]),write(ans);
		if(opt==11)read(y),move(x,y);
		if(opt>=5&&opt<=10)putchar('\n');
	}
}
```
[压(mei)行(guan)代码](https://www.luogu.com.cn/paste/12yg9aa6)

---

## 作者：约瑟夫用脑玩 (赞：10)

这里是一个亲民**且正确**的 AAAT 题解，着重于理解和实现，复杂度分析的话有点能力就可以去其他地方找到。（正确指不像隔壁 90 分手动适应数据）

首先有换根，还有换父亲，据 jerry3128 说这是强制 Link、Cut，必须上动态树，那我们先上一棵动态树来维护形态。

考虑信息的维护，我们的 LCT 可以做的是什么？Access，可以以一棵 Splay 的形态提取一条链。

那么链加链改链查我们都能处理了，只需要给 Splay 下放基本的标记即可，此题包含覆盖标记和加标记，这种一般的套路是先下放覆盖，再放加标记，覆盖标记会清空加标记。

再考虑子树信息，同样的我们用这两种标记下放修改操作，我们想将子树的标记下放下去，那么就得给所有的虚儿子都打上标记。

如果暴力遍历打上肯定不太行，虚儿子个数可能 $O(n)$，于是我们想到了用数据结构来维护往虚儿子丢的标记。

一种 naive 的想法就是上常用的线段树，于是我们可以做到 $O(1)$ 打标记，$O(\log)$ 将一个儿子从虚儿子中取出来（即变成了实儿子），$O(\log)$ 将一个点插入虚儿子中，并且能保证标记和信息的正确性。

但是众所周知 LCT 本质是虚实边剖分，虚实儿子的切换本身就是 $O(\log)$ 的复杂度，而套上 Splay 后还是 $O(\log)$ 是由于 Splay 的势能是均摊的，一次 Access 中 Splay 的势能增加总和为 $O(\log)$ 才并不影响复杂度。

而线段树并不能这样摊复杂度，它切换一次儿子的复杂度就是 $O(\log)$，于是复杂度为 $O(\log^2)$，不太行。（并不是指不能做，jerry3128 已实现了这种做法，只是复杂度不优秀） 

所以我们需要一种在维护虚儿子的同时能均摊复杂度的数据结构，参考 LCT，一种自然而然的想法就是上 Splay，复杂度能摊进一次 Access $O(\log)$。

同样的可以上其他可以摊的数据结构如 Leafy Tree，好像隔壁的魔改 LCT 就是这种实现，但与本题解无关。

做法也就自然而然的出来了，相当于在一般的 LCT 上加了 Splay 来维护虚儿子的标记下放，接下来讲两种实现：

------------

实现 1：添加虚点，相当于转每条虚边为虚点，本来虚边连接的是一棵 Splay 的顶和另一个 Splay 的某个点。

现在中间多了一个虚点，我们将虚点用 Splay 的形态堆起来，也就是堆成一个二叉树，但操作都像 Splay 那样操作。

这样的话一个实点会有两个实点儿子，一个虚点儿子，虚点儿子即为虚点堆起来的 Splay 的根。

一个虚点有两个虚点儿子，一个实点儿子，实点儿子即为虚边连接的那个儿子。

如果你想更直观的感受的话可以看成三叉的 LCT，其中两叉是正常的 Splay，另一叉是特殊的连接另一种点的边。

结构大概就是这样，代码实现是特别方便的，可以避开很多特殊处理，主要原因是虚点和实点直接相连，信息的上传和标记的下放像正常的 Splay 做即可。

通常的实现可能写成四叉树，即虚实儿子都两个，既让虚实儿子结构差不多方便写代码，~~又参考了 Top Tree 的写法让常数更小~~。（其实并不清楚常数会怎么样，可能多维护了一叉可能会变大吧？）

具体的，Access 要做的就是在实儿子里面 Splay 到父亲是虚儿子，再 Splay 虚儿子到实儿子下面更新下放标记。

代码的话用 AAAT 做这道题的很多人都是这样实现的，反正我见到的大多是这样，随便去贺一份代码参考即可。

------------

实现 2：对于每个点的虚边独立的维护一棵 Splay，与上面的区别在于虚边的 Splay 和 LCT 中的完全独立开来，互相不影响。

优势就是刚说的，完全独立，可以分开维护信息~~和调错~~。

劣势就是有亿些特殊处理，原因是虚点和实点不直接相连，所以虚实切换的时候就得手动特殊处理，~~两个互相独立的 Splay 互相切换就是两倍的码量~~。

简单来说就是：代码思路是清晰的，代码实现是毒瘤的。

现身说法：![](https://cdn.luogu.com.cn/upload/image_hosting/b1lav7et.png)

------------

选择第二种实现还有一个好处，就是我帮你扫了一圈雷，你可以参考我走的路线来做，**但我的实现也只是一种平凡的实现**，你可以有更神仙的。

注意：以下是我平凡的实现，实现方法并不唯一。

首先考虑实 Splay，要上传的信息分为两种，当前这棵实 Splay 的信息和，和这棵实 Splay **下**（不包含当前的实 Splay）所有的信息和。

一棵 Splay 其实代表一条链，那么也就相当于刨开一条链的子树信息和，由所有实儿子的虚 Splay 上传而来。

要维护这两个信息我们还得维护一个节点的所有虚儿子的信息和，由它对应的虚边 Splay 的根传信息上来。

然后上传的信息就完了，只不过有 $\operatorname{sum},\max,\min$ 这三种信息，~~三倍也就复制两次~~。

下放标记好像说过了，先下放覆盖标记，再放加标记，覆盖标记会清空加标记，加标记不对覆盖标记造成影响。

然后就是虚实切换的细节，我们 Access 一直都在实 Splay 上走，其实要考虑的就是一次实 Splay 两边虚 Splay 上的变化。

首先是对上面一棵 Splay 的影响，当前的 Splay 根变了，我们先把当前根在虚 Splay 上旋到顶，然后把当前根替换为新根。

对下面一棵 Splay 的影响就是喜闻乐见的虚 Splay 插入删除基本操作。

还有就是虚实节点有所不同的细节，实点下传标记要修改当前值，但虚点承载的其实只是标记，而并非值，所以只是修改信息，要注意下传的区别。

最后就是操作的细节，也就换父亲有点操作，因为涉及到判断同一个子树，也就涉及到 Splay，记得跟着修改虚 Splay 里面的信息即可。

最后的最后，建议实 Splay 先写 LCT 或贺 LCT 板子，虚 Splay 用 assert 把结构上的要求摆出来，基本结构上就~~不会错~~很好改了。

然后标记和信息只能输出中间变量或参考题解改改。

这里补一个下放标记的细节，据说本机房有一个90分 `WA on 8` 的是因为这里挂了：

如果本实 Splay 里面没有虚儿子了就不能动整个当前 Splay 下的信息，如果本节点没有虚儿子就不能动虚儿子信息。

如果动了的话可能出现 $\pm\infty\to v$，其中 $v$ 是赋值操作的值。

我好像在0分 WA 的时候就扫到了这个雷并排掉了，我改出来后在机房里预言了一波这个坑很大能陷一车人结果真中了。。。

[代码](https://www.luogu.com.cn/paste/iarde391)，如果有不清楚我为什么这么写的，或是我没说清楚的，都可以来问我。

---

## 作者：zzzYheng (赞：8)

参考资料：《浅谈一类实现简易的动态树型结构信息维护方法》肖岱恩。

本文不带复杂度证明，大家有兴趣就去看 X 神的论文吧。

众所周知，LCT 存在难以维护子树信息的缺点，因此我们考虑改进 LCT 以使其能维护子树信息。

由于 LCT 其实维护的是辅助树的结构，因此我们在辅助树上考虑原树的子树，容易发现 `cut(fa, x)` 再 `makeRoot(x)` 后 $x$ 的子树就是以 $x$ 为根的那棵辅助树上的所有节点了，因此我们只需在支持 LCT 的基本操作的同时维护辅助树的子树信息合并就可以了。

这个问题看起来是不难的，因为 LCT 本身就已经维护了每个点在辅助树上向下沿实边能到达的连通块的信息合并，我们只需要再增加一个沿虚边的信息合并就可以了！不过一个很严重的问题是：虚边可能是不止 $\Theta(1)$ 条的，这不就寄了吗？

SATT 给出的一个解决方案是，我们再对每个节点的虚儿子建立一个 Splay Leafy Tree 的结构来维护虚儿子的信息合并，并将这个 SLT 的根作为实节点的**中儿子**以建立实节点和它的虚儿子们之间的联系。

比如下面这棵树：

![](https://pic1.imgdb.cn/item/677bd903d0e0a243d4f010e9.png)

其的 SATT 可能就会长这样：

![](https://pic1.imgdb.cn/item/677bda3cd0e0a243d4f012d9.png)

比如图中的 7 号节点就是为了合并 1 的 4、5 两个虚儿子的信息而建立的虚节点，同时为了结构的统一性，即使 2 号节点只有 6 一个虚儿子，我们还是会建立一个虚节点 8 来作为 2 的中儿子。

有了这个结构之后，我们就能很方便地维护虚儿子的信息合并了。同时对子树修改也是简单的了，因为我们可以通过这个结构在辅助树上自顶向下地下传修改标记，那么任何双半群信息的子树修改、查询都可以使用 SATT 维护了！

下面是维护细节，我们只考虑 `access(x)` 这个函数，实现了这个函数后其他函数的实现是简单的：

- 首先 `splay(x)`，然后我们需要把 $x$ 的右儿子断开，这直接将 $x$ 的右儿子插入 $x$ 的 SLT 中即可。具体地，新建一个虚节点 $t$ 作为 $x$ 的中儿子，并将 $x$ 原本的左儿子作为 $t$ 的左儿子，$x$ 原本的右儿子作为 $t$ 的右儿子即可。

- 然后我们需要不断将 $x$ 所在实链向上的虚边打通，直到 $x$ 所在实链包含根。

  假设 $x$ 在辅助树上的父亲为 $y$，那么从 $y$ 不断往上跳得到的第一个实节点就是 $x$ 在原树上的父亲 $z$，我们要打通的边即是 $(x,z)$。

  先 `splay(z)`，然后分两种情况考虑：

  - $z$ 有右儿子，此时将 $z$ 的右儿子和 $x$ 在辅助树上交换，然后 `splay(y)` 即可。如果你会 LCT，那么这个操作是很好理解的。
  - $z$ 没有右儿子，此时可以删去 $x$ 的父亲 $y$，并用 $x$ 的兄弟 $b$ 替代其位置，然后将 $x$ 接到 $z$ 的右儿子上，并 `splay(b)` 即可。

  然后执行 $x \gets z$，不断重复上述操作打通虚边，直到 $x$ 成为辅助树的根。

如何分析其时间复杂度，感受一下，`access(x)` 的操作大致可以看为在整棵辅助树上 "splay" 了 $x$，那么 $m$ 次 `access(x)` 的复杂度为 $\Theta((n+m)\log{n})$，更为严谨的分析可以参考 X 神的论文。

最后注意一些细节：

- 对虚节点垃圾回收，同时存在的虚节点不会超过 $n$ 个，因此只用开 $1\sim 2n$ 的节点编号即可。
- 时刻注意在修改树的结构前有没有 `pushDown`，在修改树的结构后有没有 `pushUp`。

最后附上代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e5 + 10;
const int kInf = 2e9;

int wtop, wlen, wstk[40];
char rdc[1<<14], wtc[1<<23], *rS, *rT;
#define getchar() (rS==rT?rT=(rS=rdc)+fread(rdc,1,1<<14,stdin),(rS==rT?EOF:*rS++):*rS++)
#define putchar(x) wtc[wlen++]=(x)
#define flush() fwrite(wtc,1,wlen,stdout),wlen=0

template<typename T>
T read() {
	char c = getchar(); T s = 0;
	for (; !isdigit(c); c = getchar());
	for (; isdigit(c); c = getchar()) s = s * 10 + (c ^ 48);
	return s;
}

template<typename T>
// 文末记得 flush 一下
void write(T x) {
	if(wlen>=8000000)flush();
  if (x < 0) {
    putchar('-');
    write(-x);
    return;
  }
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

int n, q;

struct Tag {
	int k;
	int b; // x <- x * k + b
	
	Tag(int _k = 1, int _b = 0) {
		k = _k, b = _b;
	}
	
	void operator += (const Tag &O) {
		if (!O.k) *this = O;
		else (*this).b += O.b;
	}
};

struct Data {
	int mx, mn;
	int sum, siz;
	
	Data(int _mx = -kInf, int _mn = kInf, int _sum = 0, int _siz = 0) {
		mx = _mx, mn = _mn, sum = _sum, siz = _siz;
	}
	
	Data operator + (const Data &O) const {
		return Data(max(mx, O.mx), min(mn, O.mn), sum + O.sum, siz + O.siz);
	}
	
	void operator += (const Tag &O) {
		if (mn == kInf) return;
		if (!O.k) mx = mn = O.b, sum = O.b * siz;
		else mx += O.b, mn += O.b, sum += siz * O.b;
	}
};

struct Node {
	int fa, ch[3];
	Data val, sum_chain, sum_subtree;
	Tag tag_chain, tag_subtree;
	bool rev_tag;
	
	Node() {
		fa = ch[0] = ch[1] = ch[2] = 0;
		val = sum_chain = sum_subtree = Data();
		tag_chain = tag_subtree = Tag();
		rev_tag = 0;
	}
} tree[kMaxN << 1];
vector<int> node_stk;
int root;

int getNewNode() {
	int id = node_stk.back(); node_stk.pop_back();
	tree[id] = Node();
	return id;
}

int ls(int x) { return tree[x].ch[0]; }
int rs(int x) { return tree[x].ch[1]; }
int ms(int x) { return tree[x].ch[2]; }
int fa(int x) { return tree[x].fa; }
int get(int x) { 
	int y = fa(x);
	if (ls(y) == x) return 0;
	if (rs(y) == x) return 1;
	return 2; 
}
bool isSplayRoot(int x) { return !fa(x) || (fa(x) > n) != (x > n); }
bool isAuxRoot(int x) { return !fa(x); }

void pushUp(int x) {
	if (x > n) {
		tree[x].sum_subtree = tree[ls(x)].sum_chain + tree[ls(x)].sum_subtree + tree[rs(x)].sum_chain + tree[rs(x)].sum_subtree;
	}
	else {
		tree[x].sum_chain = tree[x].val + tree[ls(x)].sum_chain + tree[rs(x)].sum_chain;
		tree[x].sum_subtree = tree[ms(x)].sum_subtree + tree[ls(x)].sum_subtree + tree[rs(x)].sum_subtree;
	}
}

void putTag(int x, Tag tag_chain, Tag tag_subtree) {
	if (x > n) {
		tree[x].sum_subtree += tag_subtree;
		tree[x].tag_subtree += tag_subtree;
	}
	else {
		tree[x].val += tag_chain;
		tree[x].sum_chain += tag_chain;
		tree[x].tag_chain += tag_chain;
		tree[x].sum_subtree += tag_subtree;
		tree[x].tag_subtree += tag_subtree;
	}
}

void pushDown(int x) {
	if (x > n) {
		if (ls(x)) putTag(ls(x), tree[x].tag_subtree, tree[x].tag_subtree);
		if (rs(x)) putTag(rs(x), tree[x].tag_subtree, tree[x].tag_subtree);
		tree[x].tag_subtree = Tag();
	}
	else {
		if (tree[x].rev_tag) {
			if (ls(x)) {
				swap(tree[ls(x)].ch[0], tree[ls(x)].ch[1]);
				tree[ls(x)].rev_tag ^= 1;
			}
			if (rs(x)) {
				swap(tree[rs(x)].ch[0], tree[rs(x)].ch[1]);
				tree[rs(x)].rev_tag ^= 1;
			}
			tree[x].rev_tag = 0;
		}
		if (ls(x)) putTag(ls(x), tree[x].tag_chain, tree[x].tag_subtree);
		if (rs(x)) putTag(rs(x), tree[x].tag_chain, tree[x].tag_subtree);
		if (ms(x)) putTag(ms(x), Tag(), tree[x].tag_subtree);
		tree[x].tag_chain = tree[x].tag_subtree = Tag();
	}
}

void pushDownFromAuxRoot(int x) {
	if (!isAuxRoot(x)) pushDownFromAuxRoot(fa(x));
	pushDown(x);
}

void pushDownFromSplayRoot(int x) {
	if (!isSplayRoot(x)) pushDownFromSplayRoot(fa(x));
	pushDown(x);
}

void rotate(int x) {
	int y = fa(x), z = fa(y), t = get(x);
	tree[z].ch[get(y)] = x;
	tree[y].ch[t] = tree[x].ch[!t], tree[tree[y].ch[t]].fa = y;
	tree[x].ch[!t] = y, tree[y].fa = x;
	tree[x].fa = z;
	pushUp(y);
}

void splay(int x) {
	while (!isSplayRoot(x)) {
		int y = fa(x);
		if (!isSplayRoot(y)) rotate(get(y) == get(x) ? y : x);
		rotate(x);
	}
	pushUp(x);
}

void insertForVirSon(int x, int y) {
	int z = ms(x), t = getNewNode();
	pushDown(x);
	tree[x].ch[2] = t, tree[t].fa = x;
	tree[t].ch[0] = z, tree[t].ch[1] = y;
	tree[z].fa = t, tree[y].fa = t;
	pushUp(t), pushUp(x);
}

void access(int x) {
	int tmp = x;
	pushDownFromAuxRoot(x);
	splay(x);
	if (rs(x)) insertForVirSon(x, rs(x)), tree[x].ch[1] = 0;
	while (!isAuxRoot(x)) {
		int y = fa(x); 
		int z = y;
		while (z > n) z = fa(z);
		splay(z);
		if (rs(z)) {
			int t = rs(z);
			tree[y].ch[get(x)] = t, tree[t].fa = y;
			tree[z].ch[1] = x, tree[x].fa = z;
			splay(y);
		}
		else {
			int bro = tree[y].ch[!get(x)];
			node_stk.emplace_back(y);
			int f = fa(y);
			tree[f].ch[get(y)] = bro, tree[bro].fa = f;
			tree[z].ch[1] = x, tree[x].fa = z;
			if (f > n) splay(f);
		}
		x = z;
	}
	splay(tmp);
}

void makeRoot(int x) {
	access(x);
	swap(tree[x].ch[0], tree[x].ch[1]);
	tree[x].rev_tag ^= 1;
}

int getRoot(int x) {
	access(x);
	int cur = x;
	pushDown(x);
	while (ls(cur)) cur = ls(cur), pushDown(cur);
	splay(cur);
	return cur;
}

int getOgFa(int x) {
	if (x == root) return 0;
	makeRoot(root);
	access(x);
	int cur = ls(x);
	pushDown(x), pushDown(cur);
	while (rs(cur)) cur = rs(cur), pushDown(cur);
	splay(cur);
	return cur;
}

void splitPath(int x, int y) {
	// splay root is x
	makeRoot(y);
	access(x);
}

void link(int x, int y) {
	makeRoot(x), makeRoot(y);
	insertForVirSon(x, y);
}

void cut(int x, int y) {
	makeRoot(x), access(y);
	pushDown(y);
	tree[y].ch[0] = 0, tree[x].fa = 0;
	pushUp(y);
}

int main() {
	n = read<int>(), q = read<int>();
	vector<pair<int, int> > edge;
	for (int i = 1; i < n; ++i) {
		int u = read<int>(), v = read<int>();
		edge.emplace_back(u, v);
	}
	for (int i = 1; i <= n; ++i) {
		int val = read<int>();
		tree[i].val = tree[i].sum_chain = Data(val, val, val, 1);
	}
	for (int i = 1; i <= n; ++i) node_stk.emplace_back(i + n);
	root = read<int>();
	for (auto it : edge) link(it.first, it.second);
	
	while (q--) {
		int opt = read<int>();
		if (opt == 0 || opt == 5) {
			int x = read<int>(), y = read<int>();
			int fa = getOgFa(x);
			if (fa) access(fa);
			else makeRoot(root);
			Tag tag = Tag((!opt) ? 0 : 1, y);
			putTag(x, tag, tag);
			access(x);
		}
		else if (opt == 1) {
			root = read<int>();
		}
		else if (opt == 2 || opt == 6) {
			int x = read<int>(), y = read<int>(), z = read<int>();
			splitPath(x, y);
			Tag tag = Tag((opt == 2) ? 0 : 1, z);
			putTag(x, tag, Tag());
		}
		else if (opt == 3 || opt == 4 || opt == 11) {
			int x = read<int>();
			int fa = getOgFa(x);
			if (fa) access(fa);
			else makeRoot(root);
			Data data = tree[x].sum_chain + tree[x].sum_subtree;
			write((opt == 3) ? data.mn : (opt == 4) ? data.mx : data.sum), putchar('\n');
		}
		else if (opt == 7 || opt == 8 || opt == 10) {
			int x = read<int>(), y = read<int>();
			splitPath(x, y);
			write((opt == 7) ? tree[x].sum_chain.mn : (opt == 8) ? tree[x].sum_chain.mx : tree[x].sum_chain.sum), putchar('\n');
		}
		else {
			int x = read<int>(), y = read<int>();
			int fa = getOgFa(x);
			if (fa) {
				cut(fa, x);
				if (getRoot(x) == getRoot(y)) link(fa, x);
				else link(x, y);
			}
		}
	}
	flush();
	return 0;
}
```

---

## 作者：_ANIG_ (赞：4)

[传送门](https://www.luogu.com.cn/problem/P5649)

最喜欢这道题。

写了一整天。。。

首先考虑一下怎么用 LCT 维护子树信息。

一种办法是每个节点维护两个信息：实子树和和虚子树和。

这样在树的形态发生改变的时候，对虚子树和修改即可。

但是这样的做法需要一个条件：信息有可减性。对于子树大小，子树和显然是可以这么做的，但是无法做到下传懒标记，也无法维护子树最值。

可以对每个节点开一个平衡树维护虚儿子。

把虚儿子串成一个 Splay，虚儿子维护这个点对应的子树信息。

这样就可以方便地加点，删点，下传懒标记了。

实 Splay 上需要维护只考虑对应实链上的点的信息和除了实链以外的点的信息。这样是为了方便进行链修改。

实 Splay 上传的时候直接在虚 Splay 上把对应点的任意一个虚儿子转上来，就可以查询这个点所有虚儿子的信息。

可以用 set 维护每个点的虚儿子，在 set 中随便取一个转上来即可。

虚 Splay 上传的时候也是直接把实 Splay 上对应的点转上来。

下传的时候类似，直接在对应的虚/实 Splay 上打标记。

找虚儿子的时候一定要找实际树上的虚儿子。

换父亲可以先在原树找到父亲，断边再连边。

差不多就这些，然后就剩大量的细节。

注意：

上传信息的时候一定要保证儿子信息是正确的。

一定要区分好原树的父亲和 Splay 树的父亲。

查询和修改子树的时候都是直接修改虚 Splay 的，在 access 和 Splay 过后是没有右儿子的，所以不需要在实 Splay 上打标记。

复杂度 $O(n\log^2 n)$，码了 10kb。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N=2e5+5,inf=1e18;
namespace S{
    int son[N][2],sa[N],fa[N],laz1[N],laz2[N],laz3[N],laz4[N],laz5[N],sm[N],mn[N],mx[N],sms[N],mns[N],mxs[N],siz[N],sizs[N],val[N],mm[N],nn[N];
    set<int>q[N];
    void splay(int x);
    void add(int x,int y);
    void sets(int x,int y);
    void adds(int x,int y);
    void setss(int x,int y);
    int ir(int x);
}
namespace splay{
    int son[N][2],fa[N],laz4[N],laz5[N],sm[N],mx[N],mn[N],siz[N];
    void upset(int x){
        S::splay(x);
        siz[x]=siz[son[x][0]]+siz[son[x][1]]+S::siz[x];
        sm[x]=sm[son[x][0]]+sm[son[x][1]]+S::sm[x];
        mn[x]=min(S::mn[x],min(mn[son[x][0]],mn[son[x][1]]));
        mx[x]=max(S::mx[x],max(mx[son[x][0]],mx[son[x][1]]));
    }
    int gt(int x){
        return x==son[fa[x]][1];
    }
    void rotate(int x){
        int y=fa[x],a=gt(x),b=gt(y);
        fa[x]=fa[y];fa[y]=x;
        son[y][a]=son[x][a^1];son[x][a^1]=y;
        if(son[y][a])fa[son[y][a]]=y;
        if(fa[x])son[fa[x]][b]=x;
        upset(y);upset(x);
    }
    void sets(int x,int y){
        if(!x)return;
        laz5[x]=mn[x]=mx[x]=y;
        laz4[x]=0;
        sm[x]=y*siz[x];
    }
    void add(int x,int y){
        if(!x)return;
        laz4[x]+=y;mn[x]+=y;mx[x]+=y;
        sm[x]+=y*siz[x];
    }
    void dnset(int x){
        if(laz5[x]!=inf){
            sets(son[x][0],laz5[x]);
            sets(son[x][1],laz5[x]);
            S::splay(x);
            S::sets(x,laz5[x]);
            S::setss(x,laz5[x]);
            laz5[x]=inf;
        }
        if(laz4[x]){
            add(son[x][0],laz4[x]);
            add(son[x][1],laz4[x]);
            S::splay(x);
            S::add(x,laz4[x]);
            S::adds(x,laz4[x]);
            laz4[x]=0;
        }
    }
    void upt(int x){
        if(fa[x])upt(fa[x]);
        dnset(x);
    }
    void splay(int x,int y=0){
        upt(x);
        while(fa[x]!=y){
            if(fa[fa[x]]!=y)rotate(gt(x)==gt(fa[x])?fa[x]:x);
            rotate(x);
        }
    }
    int pre(int x){
        x=son[x][0];
        while(son[x][1])x=son[x][1];
        return x;
    }
    int nxt(int x){
        x=son[x][1];
        while(son[x][0])x=son[x][0];
        return x;
    }
    void del(int x){
        splay(x);
        if(!son[x][0]){
            fa[son[x][1]]=0;
            son[x][0]=son[x][1]=0;
            return;
        }
        if(!son[x][1]){
            fa[son[x][0]]=0;
            son[x][0]=son[x][1]=0;
            return;
        }
        int a=pre(x),b=nxt(x);
        splay(a);splay(b,a);
        fa[x]=0;son[x][0]=0;son[x][1]=0;son[b][0]=0;
        upset(b);upset(a);
    }
    void insert(int x,int y){
        splay(x);
        fa[x]=y;
        son[y][0]=x;
        upset(y);
    }
}
namespace S{
    int root;
    int gt(int x){
        return x==son[fa[x]][1];
    }
    int ir(int x){
        return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;
    }
    void up(int x,int op=0){
        if(!q[x].size())return;
        int c=*q[x].begin();
        splay::splay(c);
        if(op){
            mx[x]=max(mx[x],splay::mx[c]);
            mn[x]=min(mn[x],splay::mn[c]);
            mm[x]=max(mm[x],splay::mx[c]);
            nn[x]=min(nn[x],splay::mn[c]);
            sa[x]+=splay::sm[c];
            sm[x]+=splay::sm[c];
        }
        siz[x]=siz[x]+splay::siz[c];
    }
    void upset(int x){
        sizs[x]=sizs[son[x][0]]+sizs[son[x][1]]+1;
        siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
        mx[x]=max({mx[son[x][0]],mx[son[x][1]],val[x]});
        mn[x]=min({mn[son[x][0]],mn[son[x][1]],val[x]});
        mxs[x]=max(mxs[son[x][0]],mxs[son[x][1]]);
        mns[x]=min(mns[son[x][0]],mns[son[x][1]]);
        sms[x]=sms[son[x][0]]+sms[son[x][1]]+val[x];
        mxs[x]=max(mxs[x],val[x]);
        mns[x]=min(mns[x],val[x]);
        mm[x]=max(mm[son[x][0]],mm[son[x][1]]);
        nn[x]=min(nn[son[x][0]],nn[son[x][1]]);
        sa[x]=sa[son[x][0]]+sa[son[x][1]];
        sm[x]=sa[x]+sms[x];
        up(x,1);
    }
    void rotate(int x){
        int y=fa[x],a=gt(x),b=gt(y);
        if(!ir(y))son[fa[y]][b]=x;
        fa[x]=fa[y];fa[y]=x;
        son[y][a]=son[x][a^1];son[x][a^1]=y;
        if(son[y][a])fa[son[y][a]]=y;
        upset(y);upset(x);
    }
    void add(int x,int y){
        if(!x)return;
        laz4[x]+=y;
        mm[x]+=y;nn[x]+=y;
        sa[x]+=y*(siz[x]-sizs[x]);
    }
    void sets(int x,int y){
        if(!x)return;
        if(!(q[x].size()||siz[son[x][0]]>sizs[son[x][0]]||siz[son[x][1]]>sizs[son[x][1]]))return;
        laz5[x]=y;laz4[x]=0;
        mm[x]=y;nn[x]=y;
        sa[x]=y*(siz[x]-sizs[x]);
    }
    void adds(int x,int y){
        if(!x)return;
        mxs[x]+=y;mns[x]+=y;sms[x]+=y*sizs[x];
        laz2[x]+=y;
        sm[x]=sms[x]+sa[x];
        mx[x]=max(mxs[x],mm[x]),mn[x]=min(mns[x],nn[x]);
        siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
        up(x);val[x]+=y;
    }
    void setss(int x,int y){
        if(!x)return;
        mxs[x]=y;mns[x]=y;sms[x]=y*sizs[x];val[x]=y;
        laz3[x]=y;laz2[x]=0;
        sm[x]=sms[x]+sa[x];
        mx[x]=max(mxs[x],mm[x]),mn[x]=min(mns[x],nn[x]);
        siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
        up(x);
    }
    void rev(int x){
        swap(son[x][0],son[x][1]);
        laz1[x]^=1;
    }
    void dnset(int x){
        if(laz1[x]){
            rev(son[x][0]);
            rev(son[x][1]);
            laz1[x]=0;
        }
        if(laz5[x]!=inf){
            sets(son[x][0],laz5[x]);
            sets(son[x][1],laz5[x]);
            if(q[x].size()){
                int c=*q[x].begin();
                splay::splay(c);
                splay::sets(c,laz5[x]);
            }
            laz5[x]=inf;
        }
        if(laz4[x]){
            add(son[x][0],laz4[x]);
            add(son[x][1],laz4[x]);
            if(q[x].size()){    
                int c=*q[x].begin();
                splay::splay(c);
                splay::add(c,laz4[x]);
            }
            laz4[x]=0;
        }
        if(laz3[x]!=inf){
            setss(son[x][0],laz3[x]);
            setss(son[x][1],laz3[x]);
            laz3[x]=inf;
        }
        if(laz2[x]){
            adds(son[x][0],laz2[x]);
            adds(son[x][1],laz2[x]);
            laz2[x]=0;
        }
        
    }
    void upt(int x){
        if(!ir(x))upt(fa[x]);
        dnset(x);
    }
    void splay(int x){
        upt(x);
        while(!ir(x)){
            if(!ir(fa[x]))rotate(gt(fa[x])==gt(x)?fa[x]:x);
            rotate(x);
        }
    }
    int nxt(int x){
        dnset(x);
        if(!son[x][1])return 0;
        x=son[x][1];
        dnset(x);
        while(son[x][0])x=son[x][0],dnset(x);
        return x;
    }
    void access(int x){
        for(int y=0;x;y=x,x=fa[x]){
            splay(x);
            if(y){
                splay(y);
                while(son[y][0])y=son[y][0];
                splay::del(y);
                q[x].erase(q[x].find(y));
                splay(y);
            }
            int tmp=nxt(x);
            son[x][1]=y;
            if(tmp){
                splay(tmp);
                if(q[x].size()){
                    splay::insert(*q[x].begin(),tmp);
                }else splay::upset(tmp);
                q[x].insert(tmp);
            }
            upset(x);
        }
    }
    void mkr(int x){
        access(x);
        splay(x);
        rev(x);
    }
    void split(int x,int y){
        mkr(x);
        access(y);
        splay(y);
    }
    int fd(int x){
        access(x);splay(x);
        dnset(x);
        while(son[x][0])x=son[x][0],dnset(x);
        splay(x);
        return x;
    }
    void link(int x,int y){
        split(x,y);
        fa[x]=y;
        if(q[y].size()){
            splay::insert(*q[y].begin(),x);
        }else splay::upset(x);
        q[y].insert(x);
        upset(y);splay::upset(y);
    }
    int pre(int x){
        dnset(x);
        x=son[x][0];
        dnset(x);
        while(son[x][1])x=son[x][1],dnset(x);
        return x;
    }
    void cut(int x,int y){
        split(x,y);
        splay(x);
        fa[y]=0;son[x][1]=0;
        upset(x);splay::upset(x);
    }
    void solve0(int x,int y){
        mkr(root);
        access(x);splay(x);
        if(q[x].size())splay::splay(*q[x].begin()),splay::sets(*q[x].begin(),y);
        val[x]=y;
        upset(x);
    }
    void solve1(int x){
        root=x;
    }
    void solve2(int x,int y,int z){
        split(x,y);
        setss(y,z);
    }
    int solve3(int x){
        mkr(root);
        access(x);splay(x);
        if(!q[x].size())return val[x];
        splay::splay(*q[x].begin());
        return min(splay::mn[*q[x].begin()],val[x]);
    }
    int solve4(int x){
        mkr(root);
        access(x);splay(x);
        if(!q[x].size())return val[x];
        splay::splay(*q[x].begin());
        return max(splay::mx[*q[x].begin()],val[x]);
    }
    void solve5(int x,int y){
        mkr(root);
        access(x);splay(x);
        if(q[x].size())splay::splay(*q[x].begin()),splay::add(*q[x].begin(),y);
        val[x]+=y;
        upset(x);
    }
    void solve6(int x,int y,int z){
        split(x,y);
        adds(y,z);
    }
    int solve7(int x,int y){
        split(x,y);
        return mns[y];
    }
    int solve8(int x,int y){
        split(x,y);
        return mxs[y];
    }
    void solve9(int x,int y){
        if(x==root)return;
        mkr(root);
        access(x);splay(x);
        int z=pre(x);
        cut(x,z);
        if(fd(x)==fd(y))link(x,z);
        else link(x,y);
    }
    int solve10(int x,int y){
        split(x,y);
        return sms[y];
    }
    int solve11(int x){
        mkr(root);
        access(x);splay(x);
        if(!q[x].size())return val[x];
        splay::splay(*q[x].begin());
        return splay::sm[*q[x].begin()]+val[x];
    }
}
int n,m,mk[N];
vector<int>p[N];
void dfs(int x){
    mk[x]=1;
    splay::siz[x]=1;
    S::siz[x]=S::sizs[x]=1;
    for(int i=0;i<p[x].size();i++){
        int c=p[x][i];
        if(mk[c])continue;
        dfs(c);
        S::fa[c]=x;
        if(S::q[x].size()){
            splay::insert(*S::q[x].begin(),c);
        }else{
            splay::upset(c);
        }
        S::q[x].insert(c);
        S::siz[x]+=S::siz[c];
    }
    S::upset(x);splay::upset(x);
}
signed main(){
    S::mn[0]=S::mns[0]=inf;
    S::mx[0]=S::mxs[0]=-inf;
    splay::mn[0]=inf;S::nn[0]=inf;S::mm[0]=-inf;
    splay::mx[0]=-inf;
    cin>>n>>m;
    for(int i=1;i<=n;i++)S::laz3[i]=S::laz5[i]=splay::laz5[i]=inf;
    for(int i=1;i<n;i++){
        int x,y;
        scanf("%lld%lld",&x,&y);
        p[x].push_back(y);
        p[y].push_back(x);
    }
    for(int i=1;i<=n;i++)scanf("%lld",&S::val[i]);
    cin>>S::root;
    dfs(S::root);
    for(int i=1;i<=n;i++)splay::upset(i);
    while(m--){
        int op,x,y,z;
        scanf("%lld%lld",&op,&x);
        if(op==0){
            scanf("%lld",&y);
            S::solve0(x,y);
        }else if(op==1){
            S::solve1(x);
        }else if(op==2){
            scanf("%lld%lld",&y,&z);
            S::solve2(x,y,z);
        }else if(op==3){
            cout<<S::solve3(x)<<endl;
        }else if(op==4){
            cout<<S::solve4(x)<<endl;
        }else if(op==5){
            scanf("%lld",&y);
            S::solve5(x,y);
        }else if(op==6){
            scanf("%lld%lld",&y,&z);
            S::solve6(x,y,z);
        }else if(op==7){
            scanf("%lld",&y);
            cout<<S::solve7(x,y)<<endl;
        }else if(op==8){
            scanf("%lld",&y);
            cout<<S::solve8(x,y)<<endl;
        }else if(op==9){
            scanf("%lld",&y);
            S::solve9(x,y);
        }else if(op==10){
            scanf("%lld",&y);
            cout<<S::solve10(x,y)<<endl;
        }else if(op==11){
            cout<<S::solve11(x)<<endl;
        }
    }
}
```


---


# 晚秋绝诗

## 题目描述

在晚秋时分观赏 L 国举世闻名的佳景——藏雾山，无不是一件惬意之事。

藏雾山共有 $n$ 座山峰，从 $1$ 到 $n$ 编号。起初，$n$ 座山峰的山顶均被秋雾遮盖，因而无法辨别其高度。

同时，称第 $i$ 座山峰为**间峰**，当且仅当其高度恰好是第 $i-1$ 座与第 $i + 1$ 座高度的平均值（特别地，第 $1$ 座与第 $n$ 座**不算**间峰）。藏雾山一带向来会在**部分间峰**的山底悬挂旗帜，起初所有山峰的山底均无旗帜。

现有 $m$ 天，每天会发生以下之一的事件：

- 雾去/雾回：第 $x$ 座山峰山顶的秋雾散去，或重新聚集。
- 旗升/旗落：第 $x$ 座山峰山底的旗帜挂起，或被人卸下。
- 来客：一位登山爱好者造访藏雾山欲攀登第 $x$ 座山峰，他希望能当天知晓该山峰的海拔高度。

登山爱好者们将以两种方式知晓：直接观测出**未被秋雾遮盖**山峰的海拔高度，或是利用当天各山底旗帜给出的间峰信息，**尽可能地推算出其余**山峰的高度。除此之外，他们无法使用其他方式，包括但不限于与过往的来客交流分享信息等。

你能求出每位登山爱好者能否知晓目标山峰的高度吗？

## 说明/提示

**【样例解释 #1】**

在没有任何间峰信息的情况下，第一个登山爱好者不可能知晓被秋雾遮盖山峰的高度。

第二个登山爱好者造访时已知山峰 $1$ 的高度、山峰 $3$ 的高度以及山峰 $2$ 为间峰，因此山峰 $2$ 的高度能通过平均值计算得到。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (7 points)：$n \le 5$，$m \le 10$。
- Subtask #2 (13 points)：$n,m \le 100$。
- Subtask #3 (15 points)：$n,m \le 2000$。
- Subtask #4 (20 points)：$n,m \le 10^5$。
- Subtask #5 (20 points)：所有 $op = 1$ 事件在所有 $op = 2$ 事件后。
- Subtask #6 (25 points)：无特殊限制。

对于所有的数据，保证 $3 \le n \le 5 \cdot 10^5$，$1 \le m \le 5 \cdot 10^5$。

## 样例 #1

### 输入

```
3 5
1 1
1 3
3 2
2 2
3 2```

### 输出

```
0
1
```

## 样例 #2

### 输入

```
5 6
1 1
1 3
2 2
2 3
2 4
3 5```

### 输出

```
1```

# 题解

## 作者：BFqwq (赞：17)

##  P7110 【晚秋绝诗】

先膜一发 sooke。

在月赛的时候我跳过了 T4，直接来开这道题，结果是因为各种浪费时间/评测机罢工导致我最后没能 AC（最后只有 jiangly 一个人过了）。

在赛后我听了 sooke 的讲评，并对我的做法进行了一点优化，于是就有了你们所看到的这篇题解。

首先，我们需要研究一下什么样的点是可以被测出高度的。

在如果这个点是已知的，那么它显然可以被测出。如果是未知的，那我们就需要依靠一些旗子的信息。

引理：对于若干座连着插旗的山，以及与这几座山相邻的未插旗的两座山，只要它们中有两座山能被测出，则这些山全部能被测出。

比如这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hpt3bicg.png)

目前 $x_2,x_5$ 已知，并且 $x_2$ 到 $x_6$ 都插着旗，则我们一定可以推出 $x_1$ 到 $x_7$ 中的所有数。

因为我们首先可以列出两个式子：

$$x_2+x_4=2\times x_3$$
$$x_3+x_5=2\times x_4$$

其中 $x_2,x_5$ 已知。然后你会发现这就是一个一元二次方程组，并且是可以解的。于是我们就确定了中间的所有数。

然后我们根据 $x_3-x_2=x_2-x_1$ 可以推出 $x_1$，同理推出 $x_6,x_7$，因此证明了可行性。

但有人会问，如果中间不是两个，而是三个，四个……能解吗？

答案是可以。因为一元方程的数量比与未知数相同，并且没有构成循环之类的情况，那么方程就是有解的。

带着这个结论，我们继续思考。

我们称相邻的两个**不插旗**的节点与中间的若干个插旗的节点为一个段，其中这两个未插旗的点我们称为端点。

刚才我们说明了，在一个段中，知二求全。但现在的问题是，我们已知的这两个点不一定是从本段中出来的，可能是由边上的段传递过来的。

比如我们已知 $x_1,x_4,x_5$，然后又知道 $2,4$ 两点插旗。那我们可以通过 $x_4,x_5$ 求出 $x_3$，然后通过 $x_1,x_3$ 求出 $x_2$。

于是这个题就变得复杂了起来。我在比赛的时候也就是因为这里的处理一直没有调出来。

但随后我们又发现，对于传进来的值，一定是出现在段的端点处的。

那么对于一个子段，我们它可能存在四种情况：

1. 有两个及更多的已知点；

2. 有一个已知点且已知点在端点（不插旗）；

3. 有一个已知点且已知点不是端点（插旗）；

4. 没有已知点。

对于第一类的子段上的点，显然我们可以直接确定它是可以求出。同时，它还可以为两边的子段提供已知点，就好像一个信号发射器。

对于第四类的子段上的点，显然我们需要两边都收到一个已知点能确定其上面的所有值。同时，对于任意一边提供的已知点，它都不可以将它传递到其他另一端（因为求不出另一端的值），就好像一个信号阻隔器。

对于第三类的子段上的点，只要左右任意一个端点给出一个已知点，我们就能确定其上面的所有值。同时，对于任意一端给出的已知点，我们可以通过这一信息求出另一端的值，从而为另一端提供已知点，就好像一个信号传递器。

对于第二类子段上的点，已经有一个端点是已知点了。那么我们如果想要求出它上面的点，我们就需要再来一个已知点，而这个已知点就只能是另一个端点。相当于我们需要从另一个端点收到一个已知点，可以认为是单向的信号发射器。

然后我们考虑维护所有的段。这里可以使用一个 $set$。

对于操作 $1$，我们求出这个点所在的段（注意可能同时在两个段），然后分别重新求一次其类型即可。

对于操作 $2$，我们找到其对应的段，然后将段对应合并/分裂并求出其类型即可。

然后问题就是操作 $3$，我们如何判断是否可行。

要判断是否可行，我们需要知道它左右的段能否为其提供已知点。

对于左右是第 $1,2,4$ 种段的情况，非常方便。但问题是存在 $3$ 这样的段，需要继续遍历，可能会导致复杂度的增高。

于是我们可以再使用一个 $set$ 来进行维护。对于能提供已知点的点，我们在 $set$ 的对应位置插入 $1$，能阻隔已知点传递的点，我们则插入 $0$。

对于 $3$ 类段这种仅供传递的，我们直接不管。

然后我们只需要查询 $set$ 中左右最近的点是 $1$ 还是 $0$ 就好了。

（这个跳过第三类段的方法是 sooke 神仙的题解中提到的，比我当时写的东西简单许多，所以在这里我当时的写法就不讲了）

然后就是一些细节性的东西，比如左右插入防越界的段云云。因为大部分都是以 $STL$ 为主，所以细节挺多的，不仔细就容易错。

```cpp
#include<bits/stdc++.h>
#define lb(o) lower_bound({o,-1})
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-48;
		ch=getchar();
	}
	return f?-x:x;
} 
char str[300];int kkk;
inline void print(register int x,register char k='\n'){
	if(!x) putchar('0');
	if(x<0) putchar('-'),x=-x;
	while(x){
		str[++kkk]=x%10+48;
		x/=10;
	}
	while(kkk){
		putchar(str[kkk--]);
	}
	putchar(k); 
}
bool a[500100],b[500100];
int n,m,s[500100<<2];
void change(int o,int l,int r,int q){
    if(l==r){
        s[o]=a[l];
        return;
    }
    int mid=l+r>>1;
    if(q<=mid) change(o<<1,l,mid,q);
    else change(o<<1|1,mid+1,r,q);
    s[o]=s[o<<1]+s[o<<1|1];
}
int query(int o,int l,int r,int ql,int qr){
	if(ql==0||qr==n+1){
		return 0;
	}
	if(ql<=l&&r<=qr){
		return s[o];
	}
	int mid=l+r>>1;int ans=0;
	if(ql<=mid) ans+=query(o<<1,l,mid,ql,qr);
	if(qr>mid) ans+=query(o<<1|1,mid+1,r,ql,qr);
	return ans;
}
struct node{
	int l,r,c;
	friend bool operator <(node a,node b){
		return a.l==b.l?a.r<b.r:a.l<b.l;
	}
}tmp;
struct pos{
	int o,v;
	friend bool operator <(pos a,pos b){
		return a.o==b.o?a.v<b.v:a.o<b.o;
	}
}t;
set<node> st;
set<pos> val;
set<node>::iterator it;
set<pos>::iterator it2;
void ins(node p){
	int l=p.l,r=p.r;
	int v=query(1,0,n+1,l,r);
	if(v>=2){
		p.c=1;t.v=1;
		st.insert(p);
		t.o=l*2+1;
		val.insert(t);
		t.o=r*2;
		val.insert(t);
	}
	if(v==0){
		p.c=4;t.v=0;
		st.insert(p);
		t.o=l*2+1;
		val.insert(t);
		t.o=r*2;
		val.insert(t);
	}
	if(v==1){
		if(!a[l]&&!a[r]){
			p.c=3;
			st.insert(p);
		}
		else{
			p.c=2;
			st.insert(p);
			t.o=l*2+1;t.v=a[l];
			val.insert(t);
			t.o=r*2;t.v=a[r];
			val.insert(t);
		}
	}
}
void del(node p){
	st.erase(p);
	if(p.c!=3){
		it2=val.lb(p.l*2+1);
		val.erase(it2);
		it2=val.lb(p.r*2);
		val.erase(it2);
	}
}
bool get(node p){
	if(p.c==1) return 1;
	if(p.c==2){
		if(a[p.l]){
			it2=val.lb(p.r*2+1);
			return it2->v;
		}
		else{
			it2=val.lb(p.l*2+1);it2--;
			return it2->v;
		}
	}
	if(p.c==3){
		it2=val.lb(p.r*2+1);t=*it2;
		it2=val.lb(p.l*2+1);it2--;
		return it2->v|t.v;
	}
	if(p.c==4){
		it2=val.lb(p.r*2+1);t=*it2;
		it2=val.lb(p.l*2+1);it2--;
		return it2->v&t.v;
	}
}
void change(int o){
	a[o]^=1;
	change(1,0,n+1,o);
	if(b[o]){
		tmp.l=o;tmp.r=0;
		it=st.upper_bound(tmp);it--;
		tmp=*it;
		del(tmp);
		ins(tmp);
	}
	else{
		tmp.l=o;tmp.r=0;
		it=st.lower_bound(tmp);
		tmp=*it;
		it--;
		node tmp2=*it;
		del(tmp2);ins(tmp2);
		del(tmp);ins(tmp);
	}
}
void update(int o){
	if(b[o]){
		b[o]=0;tmp.l=o,tmp.r=0;
		it=st.upper_bound(tmp);it--;
		tmp=*it;del(tmp);
		node tmp2;tmp2.l=tmp.l;
		tmp2.r=tmp.l=o;
		ins(tmp2);ins(tmp);
	}
	else{
		b[o]=1;tmp.l=o,tmp.r=0;
		it=st.lower_bound(tmp);tmp=*it;
		it--;node tmp2=*it;
		del(tmp2);del(tmp);
		tmp.l=tmp2.l;
		ins(tmp);
	}
}
void query(int o){
	if(a[o]){
		print(1);
		return;
	}
	if(b[o]){
		tmp.l=o;tmp.r=0;
		it=st.upper_bound(tmp);
		it--;tmp=*it;
		print(get(tmp));
	}
	else{
		tmp.l=o;tmp.r=0;
		it=st.lower_bound(tmp);
		tmp=*it;it--;
		print(get(tmp)|get(*it));
	}
}
signed main(){
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout); 
	n=read();m=read();
	for(int i=0;i<=n;i++){
		tmp.l=i;tmp.r=i+1;tmp.c=4;
		st.insert(tmp);
		t.o=i*2+1;t.v=0;
		val.insert(t);
		t.o=(i+1)*2;
		val.insert(t);
	}
	st.insert(tmp);
	tmp.l=n;tmp.r=n+1;tmp.c=4;
	st.insert(tmp);int cnt;
	for(int i=1;i<=m;i++){
		int opt=read();
		if(opt==1){
			change(read());
		}
		if(opt==2){
			update(read());
		}
		if(opt==3){
			query(read());
		}
	}
	return 0;
} 
```


---

## 作者：konyakest (赞：4)

美术学得好，OI 差不了。

---

我们考虑本题中可以利用的信息有哪些。考虑一个旗子的连续段 $[l,r]$，这个连续段把 $[l-1,r+1]$ 连成了一个整体。此时，只要 $[l-1,r+1]$ 中任意两个位置没有雾，则这一整段就都被确定了。

这段叙述十分抽象。考虑运用我们高超的美术水平，将上面的表述画下来：

![](https://s2.loli.net/2025/01/14/5erAOP2qo49V7s3.jpg)

其中，横线表示旗子，方框区域表示“被当成了一个整体”，$\times$ 表示没有雾。

我们考虑一个位置是如何被确定的。我们定义以下概念：

- 触发器：一个中括号内有两个及以上 $\times$。

- 传导器：一个中括号内**的横线上**有一个 $\times$。

- 有连接：两个中括号共用了某个位置。

则：一个位置被确定，当且仅当：

- 触发器从左边或右边沿着连接起来的传导器一直传递过来，且当前位于的段内有一个 $\times$。

- 两边的触发器分别沿着连接起来的传导器一直传递过来。

图长这样：

![](https://s2.loli.net/2025/01/14/2lWAPVCx9gtfspn.jpg)


然后，你就知道这是“能做”的了：维护这些段即可。

问题是：怎样实现呢？

我们考虑传导器的形态，发现：**从触发器到当前位置，在横线上的×和空格必须一样多**，而这是充要条件。

于是，我们用 ``set`` 维护所有触发器，使用树状数组维护区间内“横线上的 $\times$”和“空格”的数量。每次找到刚好在询问位置前面或后面的触发器，按照上面的叙述判断即可。

实现的时候使用 ``map`` 将左端点映射到右端点会更好写。

code：

```cpp
const int maxn=5e5+5;
 
int n,m;
 
struct Fentree{
    int t[maxn];
    void add(int x,int k){x++;for(;x<maxn;x+=x&-x) t[x]+=k;}
    int query(int x){
		x++;
		if(!x) return 0;
        int ans=0;
        for(;x;x-=x&-x) ans+=t[x];
        return ans;
    }
    int query(int x,int y){
        return x>y?0:query(y)-query(x-1);
    }
}tspace,tx_not_space,tx;
 
map<int,int> mp;
 
bool isline[maxn],isx[maxn];
 
set<int> space;
 
void check(int x,int y){
    if(tx.query(x,y)>=2) mp[x]=y;
}
 
void delline(int x){
    tspace.add(x,1);
    if(isx[x]) tx_not_space.add(x,-1);
    isline[x]=0;
    auto nsp=space.lower_bound(x),psp=prev(nsp);
    space.insert(x);
 
    mp.erase(*psp),check(*psp,x),check(x,*nsp);
}
 
void addline(int x){
    tspace.add(x,-1);
    if(isx[x]) tx_not_space.add(x,1);
    isline[x]=1;
    space.erase(x);
    auto nsp=space.lower_bound(x),psp=prev(nsp);
 
    mp.erase(*psp),mp.erase(x),check(*psp,*nsp);
}
 
void changex(int x){
    tx.add(x,isx[x]?-1:1);
    if(isline[x]) tx_not_space.add(x,isx[x]?-1:1);
    isx[x]^=1;
 
    auto it=space.find(x);
    if(it!=space.end()){
        auto psp=prev(it),nsp=next(it);
        mp.erase(*psp),check(*psp,x);
        mp.erase(x),check(x,*nsp);
    }
    else{
        auto nsp=space.lower_bound(x),psp=prev(nsp);
        mp.erase(*psp),check(*psp,*nsp);
    }
}
 
bool solvel(int x){
    if(x==0) return 0;
    auto pre=mp.lower_bound(x);
    if(pre!=mp.begin()){
        --pre;
        return tx_not_space.query(pre->y,x)+1==tspace.query(pre->y,x);
    }
    return 0;
}
 
bool solver(int x){
    if(x==n+1) return 0;
    auto nxt=mp.lower_bound(x);
    return tx_not_space.query(x,nxt->x)+1==tspace.query(x,nxt->x);
}
 
bool solve(int x){
    if(isx[x]) return 1;
    auto nxt=space.lower_bound(x),pre=prev(nxt);
    if(*nxt==x){
		if(mp.count(*pre)&&mp[*pre]>=x) return 1;
		pre++;
	}
	if(mp.count(*pre)&&mp[*pre]>=x) return 1;
 
    int f1=solvel(*pre),f2=solver(*nxt);
	if(f1&&(*pre==*nxt||tx.query(*pre+1,*nxt))) return 1;
	if(f2&&(*pre==*nxt||tx.query(*pre,*nxt-1))) return 1;
	if(f1&&f2) return 1;
	return 0;
}
 
signed main(){
    cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m;
    rep(i,0,n+1) tspace.add(i,1),space.insert(i);
    rep(i,1,m,op,x){
        cin>>op>>x;
        if(op==1) changex(x);
        else if(op==2) isline[x]?delline(x):addline(x);
        else if(op==3) cout<<solve(x)<<endl;
    }
}
```

---

## 作者：win114514 (赞：2)

好有意思的题目啊。

出题人太厉害了。

### 思路

考虑一个结论：

我们将两个没插旗的点与中间的点称为一段，其中中间的点必须全部插旗。

那么这一段如果已知两座山的高度，就一定可以得知所有的高度。

考虑为什么。


加入这一段是 $a\sim b$。

$$
\begin{cases}
h_a+h_{a+2}=2\times h_{a+1}\\
h_{a+1}+h_{a+3}=2\times h_{a+2}\\
h_{a+2}+h_{a+4}=2\times h_{a+3}\\
h_{a+3}+h_{a+5}=2\times h_{a+4}\\
\cdots\\
h_{b-2}+h_{b}=2\times h_{b-1}\\
\end{cases}
$$

总共可以列出 $b-a-1$ 个方程。

而这一段总共只有 $b-a+1$ 个未知量。

所以只需要知道其中两个即可。

这启发我们将整个序列按照是否插旗分段。

例如一个序列：

```
0110000111010
```

其中 $0$ 表示没插旗，$1$ 表示插旗。

所以整个序列可以分为如下几段。

$(1,4),(4,5),(5,6),(6,7),(7,11),(11,13)$。

每个端点既是一个区间的左端点又是一个区间的右端点（除了最左和最右）。

很明显，端点属于极其特殊的点。

假如一个区间的所有点可以被求出，那么这个端点就相当于一个传递一样的给了别的区间。

那么我们只需要对于一个区间找到它两边的区间的端点是否能传递给他即可。

这可以让我们进行一个分类。

1. 一个区间内有两个以上已知点，那么这是非常好的，整个区间也都知道了。
2. 一个区间内有一个已知点且不是端点，那么发现这种段是起到了一个传递的作用，也就是只要另一边可以传递过来，那么它也可以传递出去，所以可知这种段有没有都无所谓。
3. 其余的所有区间都可以归为一类，只需要判断相应的端点是否有雾即可。

这里感觉比其它题解少分了一类，简化了很多。

分完类，就有了一些很好的做法了。

我们使用两个 $\text{set}$。

一个维护连续段，一个维护第一类和第三类来查端点。

再使用线段树或树状数组维护区间已知点数量。

我采用了线段树。

代码也很好写。

### Code

$\text{2.23KiB}$。

相较于其他的题解应该算很短的。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define fro(i,x,y) for(int i=(x);i<=(y);i++)
#define pre(i,x,y) for(int i=(x);i>=(y);i--)

const int N=5e5+10;

int n,m,x,op,a[N],b[N],t[N*4];
struct Node{
	int l; mutable int r,op;
	bool operator<(const Node&tmp)const
		{ return l<tmp.l; }
};
set<Node> q1,q2;

#define mid ((l+r)>>1)
void upd(int p,int l,int r,int v,int k){
	if(l==r)return t[p]=k,void();
	if(mid>=v)upd(p*2,l,mid,v,k);
	else upd(p*2+1,mid+1,r,v,k);
	t[p]=t[p*2]+t[p*2+1];
}
int ask(int p,int l,int r,int ls,int rs){
	if(ls<=l&&r<=rs)return t[p];int sum{};
	if(mid>=ls)sum+=ask(p*2,l,mid,ls,rs);
	if(mid<rs)sum+=ask(p*2+1,mid+1,r,ls,rs);
	return sum;
}
void upd(Node tmp){
	auto it1=q1.lower_bound(tmp);
	auto it2=q2.lower_bound(tmp);
	int s=ask(1,1,n,it1->l,it1->r);
	it1->op=(s>=2?1:((a[it1->l]||a[it1->r]||!s)?2:3));
	if(it1->op!=3){
		if(it1->l!=it2->l)
			q2.insert(*it1);
		else it2->op=it1->op;
	}
	else if(it1->l==it2->l)
		q2.erase(it2);
}
bool check(Node tmp){
	int s=ask(1,1,n,tmp.l,tmp.r);
	auto it1=q2.upper_bound(tmp);
	auto it2=prev(q2.lower_bound(tmp));
	if(it1!=q2.end()&&!a[tmp.r]&&(a[it1->l]||it1->op==1))s++;
	if(it2->l<tmp.l&&!a[tmp.l]&&(a[it2->r]||it2->op==1))s++;
	return s>=2;
}
void upd1(int x){
	a[x]^=1,upd(1,1,n,x,a[x]);
	auto it=q1.lower_bound({x,0,0});
	if(x!=n&&!b[x])upd(*it);
	if(it!=q1.begin())upd(*prev(it));
}
void ins(int x){
	auto it2=q1.lower_bound({x,0,0});
	auto it1=prev(it2);
	if(it1->op!=3)q2.erase(*it1);
	if(it2->op!=3)q2.erase(*it2);
	it1->r=it2->r,q1.erase(*it2);
	upd(*it1);
}
void del(int x){
	auto it=prev(q1.lower_bound({x,0,0}));
	if(it->op!=3)q2.erase(*it);
	int l=it->l,r=it->r; q1.erase(it);
	auto it1=q1.insert({l,x,0}).first;
	auto it2=q1.insert({x,r,0}).first;
	upd(*it1),upd(*it2);
}
void upd2(int x){b[x]^=1,(b[x]==1?ins(x):del(x));}
int ask(int x){
	bool flag=0;
	if(a[x]==1)return 1;
	auto it=q1.lower_bound({x,0,0});
	if(x!=n&&b[x]==0)flag|=check(*it);
	if(it!=q1.begin())flag|=check(*prev(it));
	return flag;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m;
	fro(i,1,n-1)
		q1.insert({i,i+1,4}),
		q2.insert({i,i+1,4});
	fro(i,1,m){
		cin>>op>>x;
		if(op==1)upd1(x);
		if(op==2)upd2(x);
		if(op==3)
			cout.rdbuf()->sputc((ask(x)?'1':'0')),
			cout.rdbuf()->sputc('\n');
	}
	return 0;
}
```

---

## 作者：EuphoricStar (赞：0)

模拟赛时只写了 $1, 3$ 事件在 $2$ 后的分，赛后拓展一下这个做法就过了。一般。

首先考虑 $O(nm)$ 暴力。注意到若一个极长连续段 $l, l + 1, \ldots, r$ 被插了旗子，意味着 $l - 1, l, \ldots, r, r + 1$ 构成一个**等差数列**，称这构成了一个**段**。

众所周知，一个等差数列只要知道其中**任意**两个数就能知道全部数，所以如果询问的 $x$ 在一个知道了 $\ge 2$ 个数的段里，那么就直接知道 $x$ 了。

否则，$x$ 所在的段必须由左边或右边最近的一个知道 $\ge 2$ 个数的段推过来，具体就是设左边最近一个知道 $\ge 2$ 个数的段（从左往右）编号为 $i$，$x$ 所在段编号为 $j$，那么编号 $i + 1, i + 2, \ldots, j$ 的段除**左端点**外都必须知道至少 $1$ 个数，并且编号 $i, i + 1, \ldots, j$ 的段必须连通（连通指段与段间有重叠部分）。右边类似。

还有一个 corner case，$x$ 所在的段可以一个数也不知道，可以由左边推过来一个数，右边推过来一个数，那么这个段就知道了 $2$ 个数。

注意到一个点最多在 $2$ 个段（因为段与段之间只可能在端点重叠），所以每次都暴力这样 check 就是 $O(nm)$ 的。

考虑 $1, 3$ 事件在 $2$ 后，那么我们可以先把所有段预处理出来，然后随便用个什么树状数组上二分或者线段树维护一个段左边第一个知道 $\ge 2$ 个数的段，还有一个区间内是否所有段除左（或右）端点外至少知道 $1$ 个数，还有一个段所在连通块的最左边（或最右边）的段。

拓展一下这个做法。现在问题是因为段时刻在变化，所以编号不固定。考虑线段树不是维护段，而是维护每个点，对于一个段 $(l, r)$，如果它存在 $< 2$ 个知道的数，就把 $l \sim r$ 加 $1$，那么找到左边第一个知道 $\ge 2$ 个数的段就相当于找到左边第一个 $= 0$ 的位置。这个随便线段树上二分做一下。

因为每个点所在段是 $O(1)$ 个的，所以我们可以暴力 `set` 维护这些段。为了方便，我除了一个 `set` 维护这些段，还用一个 `set` 维护插旗的极长连续段。

我们还需要维护段之间的连通性。考虑一个段 $(l, r)$，我们把它覆盖的边都加 $1$，即把 $l \sim r - 1$ 加 $1$，那么找到一个段所在连通块最左边的段相当于找到一个点左边第一个 $= 0$ 的位置。

更新段在线段树上的信息时，还需要维护区间有多少位置是否已知。

所以我们总共需要 $1$ 个树状数组，$4$ 个线段树，$2$ 个 `set`。

总时间复杂度是 $O(m \log n)$。

代码看起来很长，但思路清晰的话写起来还是很快的。

```cpp
// Problem: P7110 晚秋绝诗
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7110
// Memory Limit: 250 MB
// Time Limit: 2500 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<int, int> pii;

const int maxn = 500100;

int n, m;

struct BIT {
	int c[maxn];
	
	inline void update(int x, int d) {
		for (int i = x; i < maxn; i += (i & (-i))) {
			c[i] += d;
		}
	}
	
	inline int query(int x) {
		int res = 0;
		for (int i = x; i; i -= (i & (-i))) {
			res += c[i];
		}
		return res;
	}
	
	inline int query(int l, int r) {
		return max(0, query(r) - query(l - 1));
	}
} bit;

struct SGT {
	int a[maxn << 2], tag[maxn << 2];
	
	inline void pushup(int x) {
		a[x] = min(a[x << 1], a[x << 1 | 1]);
	}
	
	inline void pushdown(int x) {
		if (!tag[x]) {
			return;
		}
		a[x << 1] += tag[x];
		a[x << 1 | 1] += tag[x];
		tag[x << 1] += tag[x];
		tag[x << 1 | 1] += tag[x];
		tag[x] = 0;
	}
	
	void update(int rt, int l, int r, int ql, int qr, int x) {
		if (ql <= l && r <= qr) {
			a[rt] += x;
			tag[rt] += x;
			return;
		}
		pushdown(rt);
		int mid = (l + r) >> 1;
		if (ql <= mid) {
			update(rt << 1, l, mid, ql, qr, x);
		}
		if (qr > mid) {
			update(rt << 1 | 1, mid + 1, r, ql, qr, x);
		}
		pushup(rt);
	}
	
	int query(int rt, int l, int r, int ql, int qr) {
		if (ql > qr) {
			return 1e9;
		}
		if (ql <= l && r <= qr) {
			return a[rt];
		}
		pushdown(rt);
		int mid = (l + r) >> 1, res = 1e9;
		if (ql <= mid) {
			res = min(res, query(rt << 1, l, mid, ql, qr));
		}
		if (qr > mid) {
			res = min(res, query(rt << 1 | 1, mid + 1, r, ql, qr));
		}
		return res;
	}
	
	int findl(int rt, int l, int r) {
		if (l == r) {
			return l;
		}
		pushdown(rt);
		int mid = (l + r) >> 1;
		if (a[rt << 1] > 0) {
			return findl(rt << 1 | 1, mid + 1, r);
		} else {
			return findl(rt << 1, l, mid);
		}
	}
	
	int findr(int rt, int l, int r) {
		if (l == r) {
			return l;
		}
		pushdown(rt);
		int mid = (l + r) >> 1;
		if (a[rt << 1 | 1] > 0) {
			return findr(rt << 1, l, mid);
		} else {
			return findr(rt << 1 | 1, mid + 1, r);
		}
	}
	
	int findl(int rt, int l, int r, int ql, int qr) {
		if (a[rt] > 0 || ql > qr) {
			return -1;
		}
		if (ql <= l && r <= qr) {
			return findl(rt, l, r);
		}
		pushdown(rt);
		int mid = (l + r) >> 1;
		if (ql <= mid) {
			int t = findl(rt << 1, l, mid, ql, qr);
			if (t != -1) {
				return t;
			}
		}
		if (qr > mid) {
			int t = findl(rt << 1 | 1, mid + 1, r, ql, qr);
			if (t != -1) {
				return t;
			}
		}
		return -1;
	}
	
	int findr(int rt, int l, int r, int ql, int qr) {
		if (a[rt] > 0 || ql > qr) {
			return -1;
		}
		if (ql <= l && r <= qr) {
			return findr(rt, l, r);
		}
		pushdown(rt);
		int mid = (l + r) >> 1;
		if (qr > mid) {
			int t = findr(rt << 1 | 1, mid + 1, r, ql, qr);
			if (t != -1) {
				return t;
			}
		}
		if (ql <= mid) {
			int t = findr(rt << 1, l, mid, ql, qr);
			if (t != -1) {
				return t;
			}
		}
		return -1;
	}
} t1, t2, t3, t4;

set<pii> S, T;

int a[maxn], b[maxn];

inline vector<pii> getall(int i) {
	auto it = T.lower_bound(mkp(i, 0));
	vector<pii> res;
	if (it != T.end() && it->fst <= i && i <= it->scd) {
		res.pb(*it);
	}
	if (it != T.begin()) {
		--it;
		if (it->fst <= i && i <= it->scd) {
			res.pb(*it);
		}
	}
	return res;
}

inline void add(int l, int r) {
	int t = (bit.query(l, r) < 2);
	t1.update(1, 1, n, l, r, t);
	t = (bit.query(l + 1, r) >= 1);
	t2.update(1, 1, n, l, r, t);
	t = (bit.query(l, r - 1) >= 1);
	t3.update(1, 1, n, l, r, t);
}

inline void del(int l, int r) {
	int t = (bit.query(l, r) < 2);
	t1.update(1, 1, n, l, r, -t);
	t = (bit.query(l + 1, r) >= 1);
	t2.update(1, 1, n, l, r, -t);
	t = (bit.query(l, r - 1) >= 1);
	t3.update(1, 1, n, l, r, -t);
}

void solve() {
	scanf("%d%d", &n, &m);
	while (m--) {
		int op, x;
		scanf("%d%d", &op, &x);
		if (op == 1) {
			vector<pii> all = getall(x);
			for (pii p : all) {
				del(p.fst, p.scd);
			}
			bit.update(x, -a[x]);
			a[x] ^= 1;
			bit.update(x, a[x]);
			for (pii p : all) {
				add(p.fst, p.scd);
			}
		} else if (op == 2) {
			b[x] ^= 1;
			if (b[x]) {
				auto it = S.lower_bound(mkp(x, x));
				if (it != S.begin() && prev(it)->scd + 1 == x) {
					if (it != S.end() && it->fst - 1 == x) {
						auto jt = prev(it);
						int l = jt->fst, r = it->scd;
						del(it->fst - 1, it->scd + 1);
						del(jt->fst - 1, jt->scd + 1);
						T.erase(mkp(it->fst - 1, it->scd + 1));
						T.erase(mkp(jt->fst - 1, jt->scd + 1));
						t4.update(1, 1, n, it->fst - 1, it->scd, -1);
						t4.update(1, 1, n, jt->fst - 1, jt->scd, -1);
						S.erase(it);
						S.erase(jt);
						add(l - 1, r + 1);
						S.emplace(l, r);
						T.emplace(l - 1, r + 1);
						t4.update(1, 1, n, l - 1, r, 1);
					} else {
						--it;
						int l = it->fst, r = x;
						del(it->fst - 1, it->scd + 1);
						T.erase(mkp(it->fst - 1, it->scd + 1));
						t4.update(1, 1, n, it->fst - 1, it->scd, -1);
						S.erase(it);
						add(l - 1, r + 1);
						S.emplace(l, r);
						T.emplace(l - 1, r + 1);
						t4.update(1, 1, n, l - 1, r, 1);
					}
				} else {
					if (it != S.end() && it->fst - 1 == x) {
						int l = x, r = it->scd;
						del(it->fst - 1, it->scd + 1);
						T.erase(mkp(it->fst - 1, it->scd + 1));
						t4.update(1, 1, n, it->fst - 1, it->scd, -1);
						S.erase(it);
						add(l - 1, r + 1);
						S.emplace(l, r);
						T.emplace(l - 1, r + 1);
						t4.update(1, 1, n, l - 1, r, 1);
					} else {
						add(x - 1, x + 1);
						S.emplace(x, x);
						T.emplace(x - 1, x + 1);
						t4.update(1, 1, n, x - 1, x, 1);
					}
				}
			} else {
				auto it = --S.lower_bound(mkp(x, 1e9));
				int l = it->fst, r = it->scd;
				del(l - 1, r + 1);
				T.erase(mkp(l - 1, r + 1));
				t4.update(1, 1, n, l - 1, r, -1);
				S.erase(it);
				if (l < x) {
					add(l - 1, x);
					S.emplace(l, x - 1);
					T.emplace(l - 1, x);
					t4.update(1, 1, n, l - 1, x - 1, 1);
				}
				if (x < r) {
					add(x, r + 1);
					S.emplace(x + 1, r);
					T.emplace(x, r + 1);
					t4.update(1, 1, n, x, r, 1);
				}
			}
		} else {
			if (a[x]) {
				puts("1");
				continue;
			}
			bool fl = 0;
			vector<pii> all = getall(x);
			int l = max(1, t4.findr(1, 1, n, 1, x - 1) + 1);
			int r = t4.findl(1, 1, n, x, n);
			int p1 = t1.findr(1, 1, n, l, x);
			if (p1 != -1 && t2.query(1, 1, n, p1, x) > 0) {
				puts("1");
				continue;
			}
			int p2 = t1.findl(1, 1, n, x, r);
			if (p2 != -1 && t3.query(1, 1, n, x, p2) > 0) {
				puts("1");
				continue;
			}
			for (pii p : all) {
				if (p1 != -1 && p2 != -1 && t2.query(1, 1, n, p1, p.fst - 1) > 0 && t3.query(1, 1, n, p.scd + 1, p2) > 0) {
					fl = 1;
					break;
				}
			}
			printf("%d\n", fl);
		}
	}
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}

```


---

## 作者：Special_Judge (赞：0)

# P7110 晚秋绝诗 题解

## 分析

首先我们分析什么样的山峰可以被测出。如果我们将每一座山峰的高度都看作一个未知数，令 $x_i$ 表示第 $i$ 座山峰的高度，那么没有雾的山就是在提供类似于 $x_i=a$ 这样的信息，插着旗的山就是在提供类似于 $x_i=\dfrac{x_{i-1}+x_{i+1}}{2}$ 这样的信息。这些信息就构成了一个方程组。

相信小学生都知道，一个 $n$ 元一次方程组如果想要解出所有未知数的值，就需要至少 $n$ 个方程。但是我们在这题中，不能将所有山峰当成一个大方程组来求解，因为有可能一部分的山峰能解出而一部分不能，所以我们需要对所有的山峰进行分段。

我们将两座未插旗的山和这两座山中间插旗的山分为一段。这里选用未插旗的山作为端点的原因是题目保证了第一座和最后一座山一定不插旗，这样每个段的左右端点都是完整的。假设有一个长度为 $len$ 的段，由于有 $len-2$ 座山插了旗，这个方程组就有了 $len-2$ 个方程，我们只需要额外的 $2$ 个方程即可算出这个段中的所有山的高度，这 $2$ 个方程很明显只能由已知高度的山峰来提供。

但是，这已知高度的两座山不一定是这一段中的两座没有雾的山。因为相邻的两段共用一个端点，有可能其中一段本身只有一座已知的山，差一个方程，无法测出。但是有可能它旁边的段可以完全测出，从而通过共用的端点向这一段传递一个方程。因为这种情况的出现，我们需要将所有段分为 $4$ 种类型以方便维护这种传递方程的情况：

1. 有两座或以上没有雾的山。此时这个段是完全可测的，可以向左右两边的段提供方程。
2. 有一座没有雾的山，且这座山在端点处。此时这个段必须要从另一个端点接受一个方程才完全可测。我们发现，这样子的一段会给一侧提供方程，另一侧会阻断方程的传递。
3. 有一座没有雾的山，且这座山不在端点处。此时这个段只需要从任意一个端点接受一个方程就完全可测。同时我们发现，这样子的段对于方程的传递是没有影响的。
4. 没有没有雾的山。此时这个段必须从两个端点各接受一个方程才完全可测，我们发现这样的段会阻断方程的传递。

因此，我们使用两个 `set`，分别维护所有的段和所有的不为类型 $3$ 的段。

对于操作一，我们找到这座山峰所在的段，然后分两类：

1. 这座山是端点。此时需要更新两段，维护它们的类型（因为这座山同时在两段中）。
2. 这座山不是端点。此时更新一段即可。

对于操作二，我们分两类：

1. 拔旗操作。此时相当于分裂一个段，分裂后维护类型即可。
2. 插旗操作。此时相当于合并两个段，合并后维护类型即可。

对于操作三，我们还是分类：

1. 这座山是端点。我们找到这座山所在的两个段，只要这两个段至少有一段能完全测出，那么这座山就能测出。这里讲一下如何判断一段是否能测出：首先判断这个段里面有多少座没有雾的山，然后在第二个 `set` 中找这个段的左边和右边的段看是否能为它提供方程。注意到由于类型为 $3$ 的段对于方程传递没有影响，且只要碰到类型为 $1,2,4$ 的段就可以确定这个方向上是否能传递过来方程，所以我们只需要在第二个 `set` 中找这一段的左右相邻的段即可。
2. 这座山不是端点。找到这座山所在的段，只要这段能完全测出，这座山就能测出。

除了上述的判断之外，还需要特判这座山是否有雾。如果没有雾的话，即使它所在的段不可测，也是能知道它的高度的。

## 代码实现

注意多特判边界情况，毕竟 `set` 这种东西没写好容易 RE。

```cpp
//#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<stack>
#include<map>
#include<vector>
#include<set>
#include<random>
#include<bitset>
#include<iterator>

#define MAXN_INT 2147483647
#define MAXN_LL 9223372036854775807

#define MOD A_NUMBER
#define N 1000001
#define eps 1e-6

//#define x0 SPJ1
//#define y0 SPJ2

#define mp make_pair

using namespace std;
int n,m;
int op,x;
namespace Fen//这里使用了一棵树状数组来维护区间内没有雾的山的数量
{
    int tree[N];
    int lowbit(int x)
    {
        return x&(-x);
    }
    void add(int x,int k)
    {
        for(;x<=n;x+=lowbit(x))
            tree[x]+=k;
    }
    int query(int x)
    {
        int res=0;
        for(;x>=1;x-=lowbit(x))
            res+=tree[x];
        return res;
    }
    int sum(int l,int r)
    {
        return query(r)-query(l-1);
    }
}
namespace Int
{
    struct Interval
    {
        int l,r;
        mutable int type;//因为需要更新类型所以写mutable
    };
    bool operator<(const Interval &a,const Interval &b)
    {
        return a.l<b.l;
    }
    typedef set<Interval>::iterator IT;
    set<Interval>s1,s2;//s1维护所有段，s2维护不为类型3的段
    bitset<N>fog,flag;//分别维护是否有雾与是否有旗
    void updatetype(IT it)//更新某一段的类型
    {
        int sum=Fen::sum(it->l,it->r);
        if(sum>=2)it->type=1;
        else if(sum==1)
        {
            if(fog[it->l]==0||fog[it->r]==0)it->type=2;//如果没有雾的山在端点则为类型2
            else it->type=3;
        }
        else it->type=4;
        
        //由于段的状态变更了，所以这一段在s2中也需要更新
        if(it->type!=3)
        {
            IT itt=s2.lower_bound(Interval{it->l,0,0});
            if(itt->l!=it->l)s2.insert(*it);//如果原先该段不在s2中则插入
            else itt->type=it->type;//否则更改即可
        }
        else//更新后为类型3，从s2中删除
        {
            IT itt=s2.lower_bound(Interval{it->l,0,0});
            if(itt->l==it->l)s2.erase(itt);
        }
    }
    bool check(IT it)//检查某一段是否可测
    {
        int sum=Fen::sum(it->l,it->r);
        IT itt=s2.upper_bound(Interval{it->l,0,0});
        if(itt!=s2.end()&&fog[it->r]&&(!fog[itt->l]||itt->type==1))sum++;//右侧是否能传递方程
        
        itt=s2.lower_bound(Interval{it->l,0,0});
        if(itt!=s2.begin())//注意边界
        {
            itt--;
            if(fog[it->l]&&(!fog[itt->r]||itt->type==1))sum++;//左侧是否能传递方程
        }
        
        return sum>=2;
    }
    void changefog(int pos,int type)//更改某座山雾的状态
    {
        fog[pos]=!fog[pos];
        Fen::add(pos,type);
        if(!flag[pos])//不插旗，为端点，需要更新两段
        {
            IT it=s1.lower_bound({pos,0,0});
            updatetype(it);
            if(it!=s1.begin())//注意边界
            {
                it--;
                updatetype(it);	
            }		
        }	
        else//插旗，更新一段即可
        {
            IT it=s1.lower_bound(Interval{pos,0,0});
            it--;
            updatetype(it);
        }
    }
    void makeflag(int pos)//插旗
    {
        IT it2=s1.lower_bound(Interval{pos,0,0});
        IT it1=it2;
        it1--;
        int l=it1->l;
        int r=it2->r;
        if(it1->type!=3)s2.erase(*it1);
        if(it2->type!=3)s2.erase(*it2);
        s1.erase(it1);
        s1.erase(it2);
        IT it=s1.insert(Interval{l,r,0}).first;
        updatetype(it);
        if(it->type!=3)s2.insert(*it);
    }
    void unflag(int pos)//拔旗
    {
        IT it=s1.lower_bound(Interval{pos,0,0});
        it--;
        int l=it->l;
        int r=it->r;
        if(it->type!=3)s2.erase(*it);
        s1.erase(it);
        IT it1=s1.insert(Interval{l,pos,0}).first;
        IT it2=s1.insert(Interval{pos,r,0}).first;
        updatetype(it1);
        updatetype(it2);
        if(it1->type!=3)s2.insert(*it1);
        if(it2->type!=3)s2.insert(*it2);
    }
    int query(int pos)//询问
    {
        if(!fog[pos])return 1;//没有雾则可测
        if(!flag[pos])//不插旗，为端点，检查两段
        {
            bool f=0;
            IT it=s1.lower_bound(Interval{pos,0,0});
            f=f||check(it);
            if(it!=s1.begin())//注意边界
            {
                it--;
                f=f||check(it);
            }
            return f;
        }
        else//插旗，检查一段即可
        {
            IT it=s1.lower_bound(Interval{pos,0,0});
            it--;
            return check(it);
        }
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n-1;i++)
    {
        Int::s1.insert(Int::Interval{i,i+1,4});//初始所有山都有雾，故都为类型4
        Int::s2.insert(Int::Interval{i,i+1,4});
    }
    for(int i=1;i<=n;i++)
        Int::fog[i]=1;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&op,&x);
        if(op==1)
        {
            Int::changefog(x,Int::fog[x]?1:-1);
        }
        if(op==2)
        {
            if(!Int::flag[x])Int::makeflag(x);	
            else Int::unflag(x);
            Int::flag[x]=!Int::flag[x];	
        }
        if(op==3)
        {
            printf("%d\n",Int::query(x));
        }
    }
    return 0;
} 
```



---

## 作者：zhaluo (赞：0)

~~蒟蒻的第一篇题解求过。~~    
[题目在这里。](https://www.luogu.com.cn/problem/P7110) 
### 思路
膜拜 @BFqwq 大佬，思路来源于他的题解。   

首先，我们定义一个**段**为**一个左右端点皆不插旗的区间**。显然，在一个段里只需要知道任意两座山峰的高度，就能知道在这个段里所有山峰的高度（手玩一玩就懂了。

因为相邻的两个段的端点是重合的，所以如果一个段已知（有两个或以上已知山峰），那么它就可以为相邻的两个段分别提供一个已知山峰。

由此，我们可以将每个段分成四类：  

1. 有两个或以上已知山峰（可为左右段提供已知山峰）。  
2. 有一个已知山峰且在端点处（不能为相邻段提供已知山峰 且 只有与不已知端点相邻的段能为之提供已知山峰）。  
3. 有一个已知山峰且不在端点处（当相邻段中有一个已知时可为另一个相邻段提供已知山峰（仅起传递作用））。  
4. 无已知山峰（只有左右两段都为其提供已知端点时才已知）。

（**能为左右两段提供已知端点** 和 **已知** 其实是一样的。）

有了以上的分类，我们可以用平衡树来维护所有的段。  
对于查询任意一个点，我们只需要查询其相应的段是否已知或能否由相邻的段推出即可。  
（由于蒟蒻太蒻了不会用 set 所以就用了手写的还只是一个 avl。）

碰到第 3 类的段，我们在平衡树中的 findnext 与 findlast 函数调用时加一个标记，如果有，我们碰到第 3 类的段就跳过。  
```cpp
Duan *findla(Duan *nd,int l,int r,Duan *ans,bool k3){
    if(nd==NULL) return ans;//               就是这个
    if(nd->r<=l){
        if(k3?nd->typ!=3:1){
            if(ans==NULL) ans=nd;
            else if(nd->l>=ans->r) ans=nd;
        }
        if(k3&&nd->typ==3){
            ans=findla(nd->lc,l,r,ans,k3);
        }
        ans=findla(nd->rc,l,r,ans,k3);
    } else{
        ans=findla(nd->lc,l,r,ans,k3);
    }
    return ans;
}
```
虽然说这样复杂度会退化到 $O(n^2)$ ~~但是洛谷数据实在是太弱了。~~  
然后把平衡树的板子改一改就可以过啦。~~不会出门左转 [P3369](https://www.luogu.com.cn/problem/P3369)。~~   
(注意如果一座山峰在端点处要把他在左右两端的情况都考虑进去。)
### 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=5e5+5;
bool fog[maxn],flag[maxn];//有雾/旗

struct Duan{
    int l,r,cnt,typ;//左右端点、可以直接看到的山峰数、第几类段
    int ht;
    Duan *lc,*rc;
}*root;

int getht(Duan *nd){//子树高
    return nd!=NULL?nd->ht:0;
}

int getbf(Duan *nd){//平衡因子
    return getht(nd->lc)-getht(nd->rc);
}

void upd(Duan *nd){
    nd->ht=max(getht(nd->lc),getht(nd->rc))+1;
}

Duan *rtr(Duan *nd){//右旋
    Duan *tmp=nd->lc;
    nd->lc=tmp->rc;
    tmp->rc=nd;
    upd(nd),upd(tmp);
    return tmp;
}

Duan *rtl(Duan *nd){//左旋
    Duan *tmp=nd->rc;
    nd->rc=tmp->lc;
    tmp->lc=nd;
    upd(nd),upd(tmp);
    return tmp;
}

void caltype(Duan *nd){//算第几类段
    if(nd->cnt>=2) nd->typ=1;
    else if(!fog[nd->l]||!fog[nd->r]) nd->typ=2;
    else if(nd->cnt==1) nd->typ=3;
    else nd->typ=4;
}

Duan *insert(Duan *nd,int l,int r,int cnt){//插入
    if(!nd){
        nd=new Duan;
        nd->l=l;
        nd->r=r;
        nd->ht=1;
        nd->cnt=cnt;
        nd->lc=nd->rc=NULL;
        caltype(nd);
    } else if(r<=nd->l){
        nd->lc=insert(nd->lc,l,r,cnt);
        upd(nd);
        if(getbf(nd)>1){
            if(getbf(nd->lc)<0) nd->lc=rtl(nd->lc);
            nd=rtr(nd);
        }
    } else if(l>=nd->r){
        nd->rc=insert(nd->rc,l,r,cnt);
        upd(nd);
        if(getbf(nd)<-1){
            if(getbf(nd->rc)>0) nd->rc=rtr(nd->rc);
            nd=rtl(nd);
        }
    }
    return nd;
}

void ist(int l,int r,int cnt){
    root=insert(root,l,r,cnt);
    upd(root);
}

Duan *mdelete(Duan *nd,int l,int r){//删除
    if(l==nd->l&&r==nd->r){
        Duan *tmp;
        if(nd->lc!=NULL&&nd->rc!=NULL){
            tmp=nd->rc;
            while(tmp->lc) tmp=tmp->lc;
            nd->cnt=tmp->cnt;
            nd->l=tmp->l;
            nd->r=tmp->r;
            nd->typ=tmp->typ;
            nd->rc=mdelete(nd->rc,tmp->l,tmp->r);
            upd(nd);
            if(getbf(nd)>1){
                if(getbf(nd->lc)<0) nd->lc=rtl(nd->lc);
                nd=rtr(nd);
            }
        } else{
            if(nd->lc!=NULL) tmp=nd->lc;
            else if (nd->rc!=NULL) tmp=nd->rc;
            else tmp=NULL;
            delete nd;
            nd=tmp;
        }
    } else if(l>=nd->r){
        nd->rc=mdelete(nd->rc,l,r);
        upd(nd);
        if(getbf(nd)>1){
            if(getbf(nd->lc)<0) nd->lc=rtl(nd->lc);
            nd=rtr(nd);
        }
    } else{
        nd->lc=mdelete(nd->lc,l,r);
        upd(nd);
        if(getbf(nd)<-1){
            if(getbf(nd->rc)>0) nd->rc=rtr(nd->rc);
            nd=rtl(nd);
        }
    }
    return nd;
}

void del(int l,int r){
    root=mdelete(root,l,r);
    if(root!=NULL) upd(root);
}

Duan *findla(Duan *nd,int l,int r,Duan *ans,bool k3){//找上一个段
    if(nd==NULL) return ans;
    if(nd->r<=l){
        if(k3?nd->typ!=3:1){
            if(ans==NULL) ans=nd;
            else if(nd->l>=ans->r) ans=nd;
        }
        if(k3&&nd->typ==3){
            ans=findla(nd->lc,l,r,ans,k3);
        }
        ans=findla(nd->rc,l,r,ans,k3);
    } else{
        ans=findla(nd->lc,l,r,ans,k3);
    }
    return ans;
}

Duan *findne(Duan *nd,int l,int r,Duan *ans,bool k3){//找下一个段
    if(nd==NULL) return ans;
    if(nd->l>=r){
        if(k3?nd->typ!=3:1){
            if(ans==NULL) ans=nd;
            else if(nd->r<=ans->l) ans=nd;
        }
        if(k3&&nd->typ==3){
            ans=findne(nd->rc,l,r,ans,k3);
        }
        ans=findne(nd->lc,l,r,ans,k3);
    } else{
        ans=findne(nd->rc,l,r,ans,k3);
    }
    return ans;
}

Duan *findd(Duan *nd,int x){//找一座山峰所在的段
    if(nd->l<=x&&x<=nd->r) return nd;
    if(x<nd->l) return findd(nd->lc,x);
    return findd(nd->rc,x);
}

void op1(int x){
    fog[x]=!fog[x];
    Duan *tmp=findd(root,x),*tmp1=NULL;
    if(x==tmp->l) tmp1=findla(root,tmp->l,tmp->r,NULL,0);//判断是否在端点处
    else if(x==tmp->r) tmp1=findne(root,tmp->l,tmp->r,NULL,0);
    if(fog[x]){
        tmp->cnt--;//现在有雾,所以能直接观测的山峰数少一
        caltype(tmp);
        if(tmp1!=NULL){
            tmp1->cnt--;
            caltype(tmp1);
        }
    } else{
        tmp->cnt++;//反之
        caltype(tmp);
        if(tmp1!=NULL){
            tmp1->cnt++;
            caltype(tmp1);
        }
    }
}

void merge(int x){//将两段合并成一个段
    Duan *tmp1=findd(root,x),*tmp2;
    if(x==tmp1->r) tmp2=findne(root,tmp1->l,tmp1->r,NULL,0);
    if(x==tmp1->l) tmp2=tmp1,tmp1=findla(root,tmp2->l,tmp2->r,NULL,0);//找到左右段
    int l1=tmp1->l,r1=tmp1->r,l2=tmp2->l,r2=tmp2->r,cnt;
    cnt=tmp1->cnt+tmp2->cnt-(!fog[x]?1:0);
    del(l1,r1),del(l2,r2);
    ist(l1,r2,cnt);
}

void split(int x){//将一段分裂成两段
    Duan *tmp=findd(root,x);
    int l=tmp->l,r=tmp->r,cnt1=0,cnt2;
    for(int i=l;i<=x;i++) if(!fog[i]) cnt1++;
    cnt2=tmp->cnt-cnt1+(fog[x]?0:1);//算出分裂出的两段各自的可直接观测数
    del(l,r);
    ist(l,x,cnt1),ist(x,r,cnt2);
}

void op2(int x){
    flag[x]=!flag[x];
    if(flag[x]) merge(x);
    else split(x);
}

bool canvis(Duan *nd){
    int l=nd->l,r=nd->r;
    Duan *tmp1=findla(root,l,r,NULL,1),*tmp2=findne(root,l,r,NULL,1);
    switch (nd->typ)
    {
    case 1:
        return 1;
        break;
    case 2:
        return (!fog[nd->l])?(tmp2!=NULL&&tmp2->typ==1):(tmp1!=NULL&&tmp1->typ==1);
        break;
    case 3:
        return (tmp1!=NULL&&tmp1->typ==1)||(tmp2!=NULL&&tmp2->typ==1);
        break;
    default:
        return (tmp1!=NULL&&tmp1->typ==1)&&(tmp2!=NULL&&tmp2->typ==1);
        break;
    }
}

bool op3(int x){
    if(!fog[x]) return 1;
    Duan *tmp=findd(root,x),*tmp1=NULL;
    if(x==tmp->l) tmp1=findla(root,tmp->l,tmp->r,NULL,0);
    else if(x==tmp->r) tmp1=findne(root,tmp->l,tmp->r,NULL,0);
    return canvis(tmp)||(tmp1!=NULL&&canvis(tmp1));
}

int main()
{
    int n,m;
    cin>>n>>m;
    fog[1]=1;
    for(int i=2;i<=n;i++){
        fog[i]=1;
        ist(i-1,i,0);
    }
    for(int i=1;i<=m;i++){
        int op,x;
        cin>>op>>x;
        if(op==1) op1(x);
        else if(op==2) op2(x);
        else{
            cout<<op3(x)<<endl;
        }
    }
    return 0;
}
```
代码很丑,大佬轻喷。

---


# [Ynoi2018] 五彩斑斓的世界

## 题目背景

……羽毛

从天而降的羽毛

如雪一般的纯白，

在海风中摇曳，

在凉风中舞动，

仿佛要将谁的心带走一样——神仙的羽毛。

……

“求求你”

谁这样说到

“求求你了”

“救救我们”

……梦

我知道的，这是一场梦

随即，那个人又说话了，在我这纯白的梦里

“我们会一直在这里等着的……”

于是，我踏上了漫长的旅途

我有着非去不可的地方

为了实现那个人的愿望

所以我想，如果……

如果，我的愿望能够实现的话。

那样的话，或许，我和你……
 
![](https://cdn.luogu.com.cn/upload/pic/13166.png) 

……世界终结了

已经终结了

我没赶上，不管什么，所有的事情……

……可憎

不可原谅

我……

……我、绝对、不会原谅你

现在、就出发……

我一定……一定要，把你……！

![](https://cdn.luogu.com.cn/upload/pic/13167.png) 

手……牵着手，就能连着心

……我的左手，没有牵着任何人的，我的手

 ![](https://cdn.luogu.com.cn/upload/image_hosting/of3qws6f.png)

实现愿望。

只留下这个事实，然后我们两人就会分别。

就是希望着这一点，我们才会两个人一起走到今天。

是这样吧？

![](https://cdn.luogu.com.cn/upload/pic/13168.png) 

来，出发吧，去选择那独一无二的明天

![](https://cdn.luogu.com.cn/upload/pic/13169.png)


## 题目描述

二阶堂真红给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作

1. 把区间 $[l,r]$ 中大于 $x$ 的数减去 $x$。
2. 查询区间 $[l,r]$ 中 $x$ 的出现次数。


## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le m\le 5\times 10^5$，$1\le l\le r \le n$，$0 \le a_i,x \le 10^5+1$。

By nzhtl1477


## 样例 #1

### 输入

```
5 6
1 5 5 5 8
2 2 5 5
1 2 4 3
2 2 5 2
2 2 5 5
1 3 5 1
2 1 5 1```

### 输出

```
3
3
0
3```

# 题解

## 作者：mrsrz (赞：47)

第二分块。

我们观察一下这个查询操作。把所有大于 $x$ 的数减去 $x$，相当于把所有小于等于 $x$ 的数加上 $x$，然后全局减 $x$。

我们令 $k$ 表示一个数列中的可能最大值。

若 $2x\geq k$，则我们令大于 $x$ 的数减去 $x$ 之后，就没有比 $x$ 大的数了，则 $k$ 在操作后至少减少 $k-x$。

若 $2x\lt k$，则我们令小于等于 $x$ 的数加上 $x$，就没有比 $x$ 小的数了，然后。打全局减的标记，则 $k$ 在操作后至少减少 $x$。

我们发现不管怎么操作，这个 $k$ 都是单调不增的，而 $k$ 初始最大为 $5\times 10^5$。

所以我们如果是对全局进行修改，按照上面的分析，只需要枚举需要修改的那些数值即可。这里枚举的数值的总和为 $O(n)$（默认 $n,m$ 和值域同阶，下同）。

我们希望对每个不同的值的修改能做到 $O(1)$。

考虑使用并查集把相同的值并起来。那么修改的时候，只需要把修改前值对应的并查集的根，连到修改后的值的并查集的根上即可。同时我们需要记录每个数的出现次数，修改的时候直接加过去就好了。

这里有一些很好的性质：我们每次用来连接的都是并查集的根，而一个根连到另一个根之后，这个值本身就消失了。而且我们在这里并不用这个并查集查询。因此这里的并查集**并不会进行**路径压缩，是 $O(1)$ 的。

然后如果是查询全局某个数的出现位置，那么直接 $O(1)$ 查询即可。

我们考虑查询所有位置的实际值。这里就需要用到并查集的找父亲的操作了。由于这里访问了并查集的所有位置，并进行了路径压缩，所以总复杂度是 $O(n)$ 的。

到这里，接下来的步骤就非常明显了。我们对序列进行分块。

对于一个块的全局修改、全局查询，我们直接按照上述方式去做即可，总时间复杂度 $O(n\sqrt n)$。

对于一个块的部分修改，我们先暴力把每个位置的实际值还原，然后对块进行重构即可。单次 $O(\sqrt n)$。

对于一个块的部分查询，我们直接使用并查集找到每个位置的实际值，然后判断是否相等即可。单次不超过 $O(\sqrt n)$。

总时间复杂度 $O(n\sqrt n)$。

我们来分析空间复杂度。我们需要对每个块记录每个数的出现次数，那么至少需要一个 $O(n\sqrt n)$ 的数组。这非常不可接受。

不过我们可以发现，我们在分块的时候，块是独立的，块与块之间不会相互影响。所以我们可以将操作离线，对每个块都按顺序处理一遍所有的操作，然后把询问的答案累加即可。

这样我们只需要开一个块需要使用的空间，然后共用这些空间即可。

所以空间复杂度 $O(n)$。

---

## 作者：试试事实上吗 (赞：31)

第二分块，神仙大分块题，不过想清楚了后应该难度相对不太大。

### Part.1

先看这题的数据范围$a_i\leq 5e5$，想到分块的方式应该与值域有关。另外我们可以发现，我们的值是只减小不增大的，考虑值域上应该有一个均摊，对每块做一个值域，考虑我们可以在这个上面~~搞一些事情~~做一些操作，使复杂度正确。~~然后我就不会了~~

### Part.2

~~看了出题人的题解后~~我们可以发现有一个很有意思的trick，我们考虑值域是不增的，所以我们可以让值域最大值与最小值的差值越来越小。

设当前修改操作有一个$x$，当前最大值为$mx$，我们分两种情况讨论。

1. $mx \le x\times 2$ 此时我们把$[x+1,mx]$上的值暴力减。
2. $mx > x\times 2$此时我们把$[1,x]$上的值暴力加，然后打上块整体减的$tag$。

我们每次总是使得块的最大值与最小值越来越近，所以一个块的总复杂的是$O(n)$的，所有块的总复杂度是$O(n\sqrt n)$。

到目前为止，我们解决了最重要的操作。

### Part.3

但询问时我们每个块如果只记录当前值在块内出现次数的话，很显然是不行的，因为零散块无法快速找到一个下标对应的现在的答案，所以我们考虑让值域的每个值记录她有哪些下标是当前值。或者换句话，对下标来说，就是用一个指针指向她当前在值域上的值。

我们重新定义两个操作。

1. $mx \le x\times 2$ 此时我们把$[x+1,mx]$上的值所包含的下标往$[1,x]$合并。
2. $mx > x\times 2$此时我们把$[1,x]$上的值所包含的下标往$[x+1,x\times 2]$合并，然后打上块整体减的$tag$。

如果是零散块，我们就暴力找出当前下标指向的实际的值，修改后把整个块重构。这样是$O(\sqrt n)$的。

什么样的数据结构能实现这样的操作呢？一个直接的想法就是链表，对每个值维护一个链表，合并是$O(1)$的，满足我们的要求。

然而我们还有一个更高效的数据结构，并查集。我们对每个值维护并查集，合并是$O(1)$的，但在重构块时较链表常数更小，是更优秀的选择。

### Part.4

说了这么多，我们还是过不了这道题。~~我没有玩你们~~

仔细观察空间限制，发现是**62.50MB**，~~果然前面还不够dl~~，我们要考虑一种线性空间的做法，其实很简单，有一个trick叫逐块处理，我们发现每个块对总的时间贡献了$O(n+m)$的复杂度，那么我们对每个块跑一遍所有询问就可以了。

那我们其他那么多题为什么没有用这个trick呢？因为用它要满足下面几个性质。

1. 可以离线，显然我们是离线下来对每个块跑询问。
2. 块之间不互相干扰。如果一个块的信息发生改变就要影响相邻或更多的块，那么就不能用。
3. 答案可加性，我们是每次跑询问是把答案加入总答案，如果不可加，那么也不行。

最后告诉你一个好消息，**这个题不卡常！！！**所以~~快乐的~~$code$吧！~~其实就是细节有点多~~

~~还是贴一下我丑陋的代码吧~~

```cpp
inline int findf(int x) {return x==fa[x]?x:fa[x]=findf(fa[x]);}

inline void merge(int u,int v)//合并两个值的下标
{
    if(rt[v]) fa[rt[u]]=rt[v];
    else rt[v]=rt[u],to[rt[v]]=v;
    siz[v]+=siz[u];
    rt[u]=siz[u]=0;
}

void build(int x)//新建块
{
    mxval=tag=0;
    for(int i=L[x];i<=R[x];++i)
    {
        mxval=max(mxval,a[i]);
        if(rt[a[i]]) fa[i]=rt[a[i]];
        else rt[a[i]]=fa[i]=i,to[i]=a[i];
        ++siz[a[i]];
    }
}

void restruct(int x,int l,int r,int nx)//重构块
{
    for(int i=L[x];i<=R[x];++i)
        a[i]=to[findf(i)],rt[a[i]]=siz[a[i]]=0,a[i]-=tag;
    for(int i=L[x];i<=R[x];++i)
        to[i]=0;
    l=max(l,L[x]);r=min(r,R[x]);
    for(int i=l;i<=r;++i)
        a[i]=a[i]-(a[i]>nx)*nx;
    build(x);
}

void modify(int nx)//修改
{
    if((nx<<1)<=mxval-tag)
    {
        for(int i=tag+1;i<=tag+nx;++i)
            if(rt[i]) merge(i,i+nx);
        tag+=nx;//记得修改tag
    }
    else
    {
        for(int i=tag+nx+1;i<=mxval;++i)
            if(rt[i]) merge(i,i-nx);
        if(tag+nx<mxval) mxval=tag+nx;//记得更新最大值
    }
}

void query(int x,int i)//询问
{
    int l=q[i].l,r=q[i].r,nx=q[i].x;
    if(nx+tag>5e5) return;
    if(l<=L[x]&&R[x]<=r) ans[i]+=siz[nx+tag];
    else
    {
        l=max(L[x],l);r=min(R[x],r);
        for(int j=l;j<=r;++j)
            if(to[findf(j)]-tag==nx) ++ans[i];
    }
}

int main()
{
    read(n);read(m);
    klen=sqrt(n);
    for(int i=1;i<=n;++i)
        read(a[i]);
    for(int i=1;i<=m;++i)
        read(q[i].opt),read(q[i].l),read(q[i].r),read(q[i].x);
    blocks=(n-1)/klen+1;
    for(int i=1;i<=blocks;++i)
        L[i]=R[i-1]+1,R[i]=i*klen;
    R[blocks]=n;
    for(int i=1;i<=blocks;++i)//先枚举块，逐块处理
    {
        memset(rt,0,sizeof(rt));
        memset(siz,0,sizeof(siz));
        build(i);
        for(int j=1;j<=m;++j)
        {
            if(L[i]>q[j].r||R[i]<q[j].l) continue;
            else if(q[j].opt==1)
            {
                if(q[j].l<=L[i]&&R[i]<=q[j].r)
                    modify(q[j].x);
                else restruct(i,q[j].l,q[j].r,q[j].x);
            }
            else query(i,j);
        }
    }
    for(int i=1;i<=m;++i)
        if(q[i].opt==2) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：fkxr (赞：29)

### 题目大意
本题有两种操作：
1. 对区间内大于 $x$ 的数减去 $x$。
2. 查询区间内 $x$ 的出现次数。

数据范围：$1\leq n\leq 10^6$，$1\leq m\leq 5\times 10^5$，$1\leq l\leq r \leq n$，$0 \leq a_i,x \leq 10^5 + 1$。

时间限制为 7.50s，内存限制为 64.00MB。

### 思路
看到 Ynoi 类型的题目，通常会联想到分块和卡常技巧，本题也不例外。

由于内存限制较小，我们需要设计一个线性空间复杂度的解法。

#### 仅含操作 2 的解法
首先，假设只有操作 2，且线性空间，使用用分块，该如何求解呢？

若使用桶来记录每块内每个数的出现次数，空间复杂度为 $O(n^{1.5})$，无法通过本题。

经过思考，我们发现某些数的贡献与其他数无关（例如在 $\texttt{0 2 0 4 0}$ 中，查询 $[2, 5]$ 区间内 $0$ 的个数与 $a_1$ 无关）。因此，可以将询问的答案拆分为一些整块和散块贡献的总和。

因为本题没有强制在线要求，所以可以考虑离线处理每个询问。具体做法是：枚举每一块，使用桶记录该块内每个数的出现次数，然后枚举每个询问，判断询问区间与该块所管辖区间的交集情况，分为以下两种情形：
1. **整块被询问区间包含**：直接查询桶，计算该块对当前询问的贡献。
2. **整块与询问区间相交但不被包含**：直接暴力统计 $x$ 的出现次数。

下面分析该解法的时空复杂度：
- **空间复杂度**（假设 $n$、$m$、值域同阶）：由于每块的桶并非同时使用，可共用，空间复杂度为 $O(n)$。存储询问和原数组的空间复杂度也是 $O(n)$，因此总空间复杂度为 $O(n) + O(n) = O(n)$。
- **时间复杂度**（假设 $n$、$m$、值域同阶，块长设为 $n^{0.5}$）：枚举每个块和每个询问的时间复杂度为 $O(n^{1.5})$；询问中暴力求解部分的数量为 $O(n)$，每个最多枚举 $n^{0.5}$ 次，这部分的时间复杂度为 $O(n^{1.5})$。所以总的时间复杂度为 $O(n^{1.5}) + O(n^{1.5}) = O(n^{1.5})$。

#### 加入操作 1 后的解法
这是本题的核心部分。

首先要理解，"区间大于 $x$ 的数减去 $x$" 等价于 "区间小于等于 $x$ 的数加上 $x$，再全局减去 $x$"。

参考 $\text{lxl}$ 的题解思路（针对每块）：
1. 当区间最大值 $\leq 2x$ 时，可正常进行减法操作。
2. 对于其他情况，将 $[1, x]$ 区间上的值暴力相加，并打上块整体减的标记（$\text{tag}$）。

由于每次操作后，最大值与最小值的差值会缩小，因此对于每一块，操作 1 的时间复杂度为（假设 $n$、$m$、值域同阶）$O(n)$。

同样采用类似上述的处理方式，判断询问区间与该块所管辖区间的交集情况，分为以下两种情形：
1. **整块被询问区间包含**：直接进行修改操作。
2. **整块与询问区间相交但不被包含**：将该块拆散处理。

对于第二种情况，需要记录每个值最终的变化情况，可使用并查集来实现。根据 $\text{mrsrz}$ 大蛇的证明：
> 这里有一些很好的性质：每次连接操作使用的都是并查集的根节点，且一个根节点连接到另一个根节点后，该值本身就不再存在。并且在本题中不需要使用并查集进行查询操作。因此，这里的并查集**不会进行路径压缩**，时间复杂度为 $O(1)$。

由于拆散的次数为 $O(m)$，所以总时间复杂度（假设 $n$、$m$、值域同阶）为 $O(n^{1.5})$，可以通过本题。

#### 对 0 的处理
上述思路在处理原数据时可行，但对于一些特殊数据（hack 数据）无法通过，原因是当查询 $0$ 的出现次数时，程序会输出错误答案。

由于操作 1 不会影响 $0$ 的个数，所以可以使用前缀和记录 $0$ 的个数，当查询 $0$ 的出现次数时，直接用前缀和相减得到答案。

### 代码
```cpp
#include <bits/stdc++.h>
//#define int long long
#ifndef __linux__
#define getchar_unlocked getchar
#define putchar_unlocked putchar
#endif

using namespace std;

inline void Sr(int &a) {
    char ch = getchar_unlocked();
    while (ch < '0' || ch > '9') {
        ch = getchar_unlocked();
    }
    while (ch >= '0' && ch <= '9') {
        a = (a << 1) + (a << 3) + (ch ^ 48);
        ch = getchar_unlocked();
    }
}

inline void Sw(int a) {
    if (a == 0) {
        putchar_unlocked('0');
        return;
    }
    char ch[7];
    int till = 0;
    while (a) {
        ch[till++] = a % 10;
        a /= 10;
    }
    while (till)
        putchar_unlocked(ch[--till] ^ 48);
}

int n, m;
int fa[100005];
int a[1000006]; // 每个数的值
bitset<500005> op;
int L[500005];
int R[500005];
int X[500005];
// 上面四个数组是每个询问
int len;
int sum[100005]; // 桶
int ans[500005]; // 每个询问的答案
int maxx, y; // y 是块内统一 -y

inline int cha(int x) {
    if (fa[x] == fa[fa[x]]) return fa[x];
    while (x ^ fa[x]) x = fa[x] = fa[fa[x]] = fa[fa[fa[x]]];
    return x;
}

inline void bin(int a, int b) {
    if (cha(a) ^ cha(b)) {
        fa[cha(a)] = cha(b);
    }
} // 上面两个函数是并查集

inline void init(int l, int r) { // 初始化
    memset(sum + y, 0, 4 * (maxx - y + 1));
    y = maxx = 0;
    for (int i = l; i <= r; ++i) {
        maxx = (maxx > a[i] ? maxx : a[i]);
        sum[a[i]]++;
    }
    for (int i = 0; i <= maxx; ++i) {
        fa[i] = i;
    }
}

inline void ini(int l, int r) { // 暴力拆散
    for (int i = l; i <= r; ++i) {
        while (a[i] ^ fa[a[i]]) a[i] = fa[a[i]] = fa[fa[a[i]]] = fa[fa[fa[a[i]]]];
    }
}

int Sum[1000006];

int main() {
    Sr(n); Sr(m);
    for (int i = 0; i < n; ++i) {
        Sr(a[i]);
        if (a[i] == 0) {
            Sum[i + 1] = 1;
        }
        Sum[i + 1] += Sum[i];
    }
    for (int i = 0; i < m; ++i) {
        Sr(L[i]);
        op[i] = (L[i] == 2);
        L[i] = 0;
        Sr(L[i]); Sr(R[i]); Sr(X[i]);
        if (op[i] && X[i] == 0) {
            ans[i] = Sum[R[i]] - Sum[L[i] - 1];
        }
        --L[i];
        --R[i];
    }
    len = max(1, min((int)sqrt(n * 9 / 3), n));
    int t = n / len + min(1, n % len); // 块的数量
    for (int e = 0; e < t; ++e) {
        int l = len * e;
        int r = min((e + 1) * len - 1, n - 1);
        init(l, r);
        for (int i = 0; i < m; ++i) {
            if (op[i]) {
                if (X[i] == 0) {
                    continue;
                }
                if (X[i] > maxx - y) {
                    continue;
                }
                if (L[i] > r || R[i] < l) {
                    continue;
                }
                if (!(L[i] <= l && R[i] >= r)) { // 不是整块
                    ini(l, r);
                    for (int j = l; j <= r; ++j) {
                        if (L[i] > j) 
                            continue;
                        if (R[i] < j) 
                            break;
                        if (a[j] - y == X[i]) 
                            ans[i]++;
                    }
                    continue;
                }
                ans[i] += sum[X[i] + y];
            } else {
                if (X[i] >= maxx - y || L[i] > r || R[i] < l) {
                    continue;
                }
                if (!(L[i] <= l && R[i] >= r)) { // 不是整块
                    ini(l, r);
                    for (int j = l; j <= r; ++j) {
                        if (L[i] > j) 
                            continue;
                        if (R[i] < j) 
                            break;
                        if (a[j] - y > X[i]) {
                            sum[a[j]]--;
                            a[j] -= X[i];
                            sum[a[j]]++;
                        }
                    }
                    for (int i = maxx; i >= 0; --i) {
                        if (sum[i]) {
                            maxx = i;
                            break;
                        }
                    }
                    continue;
                }
                if ((X[i] << 1) <= maxx - y) {
                    for (int j = y + 1; j <= y + X[i]; ++j) {
                        sum[j + X[i]] += sum[j];
                        sum[j] = 0;
                        bin(j, j + X[i]);
                    }
                    y += X[i];
                } else {
                    for (int j = maxx; j > y + X[i]; --j) {
                        sum[j - X[i]] += sum[j];
                        sum[j] = 0;
                        bin(j, j - X[i]);
                    }
                    for (int i = maxx; i >= 0; --i) {
                        if (sum[i]) {
                            maxx = i;
                            break;
                        }
                    }
                }
            }
        }
    }
    for (int i = 0; i < m; ++i) {
        if (op[i]) {
            Sw(ans[i]);
            putchar_unlocked('\n');
        }
    }
}
```
### 后记
此代码在洛谷上是第五优解。如果你有兴趣，可以尝试用这段代码冲击最优解（反正我已经尽力卡常了，从我的用户名就能看出我是分块新人）。

你看到的题解经过【因相关原因，联系撤下】的优化表述，原题解见 http://mqcoj.cn/file/27/a.md （把链接**复制**进入新的窗口）

---

## 作者：Sol1 (赞：17)

「突刺贯穿第二分块」。

属于入门级大分块，仅第三分块的评分低于此题。

因为这是 Ynoi，所以值域 $10^5$ 代表复杂度一定和值域有关。

下面记 $n$ 为序列长度，$m$ 为操作次数，$v$ 为序列值域。

发现如果对序列分块，则每一块的最大值一定是单调不减的，且如果分成 $k$ 块，则最大值总和是 $O(vk)$ 的。

我们去考虑每次整体修改的时候都做了什么，可以视为把大于 $x$ 的数减掉 $x$，也可以视为把所有数减去 $x$，然后再给所有小于 $0$ 的数加上 $x$。

记最大值为 $m$。

如果我们能做到 $O(d)$ 将最大值减少 $1$，则对于 $2x\leq m$ 可以把区间 $[1,x]$ 平移到 $[x+1,2x]$ 并记录一个整体减的标记，以 $O(dx)$的复杂度减小 $O(x)$ 最大值；对于 $2x>m$ 可以将区间 $[m-x+1,m]$ 平移到 $[m-2x+1,m-x]$，以 $O(d(m-x))$ 的复杂度减小 $O(m-x)$ 最大值。

我们发现这个区间平移类似于合并两个点，联想到并查集。

这样合并就是 $O(\alpha(n))\approx O(1)$，整体修改就做好了，零散修改可以直接重构块，整体查询可以通过在并查集上面维护一个 size 来完成，零散查询可以暴力计算。

取块长为 $O(\sqrt n)$，得到复杂度为——不对，初始化并查集是线性的，所以是 $O(vm)$……

我们发现主要问题是如果把一个数 $x$ 改成 $y$ 会多出来一个需要修改的位置。

所以我们的并查集不维护值域，维护下标，然后开一个值域数组来记录每一种数对应的并查集的根。

这样每次将 $x$ 合并到 $y$ 时，如果 $y$ 出现过，那么直接通过值域数组取出根然后合并；如果 $y$ 没出现过，那么直接修改值域数组，不需要修改并查集的结构。

这样初始化的时候因为下标的量级是 $O(\sqrt n)$ 的，值域数组因为最多 $O(\sqrt n)$ 个位置上有值，所以初始化的复杂度就压缩到了 $O(\sqrt n)$。

这样我们就得到了一个时间为 $O(m\sqrt n)$，空间为 $\color{red}O(v\sqrt n)$ 的算法。

这怎么办？

我们发现修改对每一个块是独立的，即我们修改一个块不会对其他块产生影响，查询的结果也是独立的，可以直接加。

所以我们将所有询问离线下来，先对第一个块跑一遍所有询问，再对第二个块跑一遍所有询问……如此统计贡献之和。

这样我们只需要一个块来处理，那么这题就做完了~

最终时间 $O(m\sqrt n)$，空间 $O(v)$。

这题写法足够好貌似是不用卡常的，但是我的代码需要调一下块长。

代码：

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const int N = 500005, S = 1000;

int a[N], n, m, opt[N], l[N], r[N], x[N], pos[N], bl[N / S + 5], br[N / S + 5], ans[N];
struct Block {
	int l, r, f[N], rt[N], siz[N], val[N], tag, mx;
	inline int GetRoot(int v) {
		if (f[v] == v) return f[v];
		f[v] = GetRoot(f[v]);
		return f[v];
	}
	inline void Merge(int x, int y) {
		if (rt[y]) {
			f[rt[x]] = rt[y];
		} else {
			rt[y] = rt[x];
			val[rt[y]] = y;
		}
		siz[y] += siz[x];
		rt[x] = siz[x] = 0;
	}
	inline void Destroy() {
		for (register int i = l;i <= r;i++) {
			a[i] = val[GetRoot(i)];
			//printf("%d ", a[i]);
			rt[a[i]] = 0;
			siz[a[i]] = 0;
			a[i] -= tag;
		}
		//puts("");
		for (register int i = l;i <= r;i++) f[i] = 0;
		tag = 0;
	}
	inline void Build() {
		mx = 0;
		for (register int i = l;i <= r;i++) {
			if (!rt[a[i]]) {
				rt[a[i]] = i;
				f[i] = i;
				val[i] = a[i];
			} else {
				f[i] = rt[a[i]];
			}
			siz[a[i]]++;
			mx = Max(mx, a[i]);
		}
	}
	inline void TotalModify(int x) {
		if (mx - tag >= (x << 1)) {
			for (register int i = tag + 1;i <= tag + x;i++) {
				if (rt[i]) Merge(i, i + x);
			}
			tag += x;
		} else {
			for (register int i = mx;i > tag + x;i--) {
				if (rt[i]) Merge(i, i - x);
			}
			mx = Min(mx, tag + x);
		}
	}
	inline void PartModify(int ll, int rr, int x) {
		if (ll > rr) return;
		Destroy();
		for (register int i = ll;i <= rr;i++) {
			if (a[i] > x) a[i] -= x;
		}
		Build();
	}
	inline int TotalQuery(int x) {
		if (x + tag > 500000) return 0;
		return siz[x + tag];
	}
	inline int PartQuery(int ll, int rr, int x) {
		register int ans = 0;
		for (register int j = ll;j <= rr;j++) {
			if (val[GetRoot(j)] - tag == x) ans++;
		}
		return ans;
	}
};
Block blk;

inline void Read() {
	n = qread(); m = qread();
	for (register int i = 1;i <= n;i++) a[i] = qread();
	for (register int i = 1;i <= m;i++) opt[i] = qread(), l[i] = qread(), r[i] = qread(), x[i] = qread();
}

inline void Solve() {
	for (register int i = 1;i <= n;i++) pos[i] = (i - 1) / S + 1;
	for (register int i = 1;i <= pos[n];i++) {
		bl[i] = (i - 1) * S + 1;
		br[i] = Min(i * S, n);
	}
	for (register int i = 1;i <= pos[n];i++) {
		blk.l = bl[i];
		blk.r = br[i];
		blk.Build();
		for (register int j = 1;j <= m;j++) {
			if (opt[j] == 1) {
				if (l[j] <= blk.l && r[j] >= blk.r) blk.TotalModify(x[j]);
				else blk.PartModify(Max(l[j], blk.l), Min(r[j], blk.r), x[j]);
			} else {
				if (l[j] <= blk.l && r[j] >= blk.r) ans[j] += blk.TotalQuery(x[j]);
				else ans[j] += blk.PartQuery(Max(l[j], blk.l), Min(r[j], blk.r), x[j]);
			}
			//puts("---");
			//for (register int k = 1;k <= n;k++) printf("%d ", a[k]);
			//putchar('\n');
		}
		blk.Destroy();
	}
	for (register int i = 1;i <= m;i++) {
		if (opt[i] == 2) printf("%d\n", ans[i]);
	}
}

int main() {
	Read();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

---

## 作者：Leap_Frog (赞：10)

## 第二分块学习笔记
### 第二分块解决的问题
1. 区间对于所有大于 $x$ 的数减去 $x$
2. 询问区间中有多少个数等于 $x$

### 基础部分（For CF896E
**这是一个在线做法！第二分块可以在线！**  
注意题目中的数据范围：$a_i,x\le10^5$，这便是这种数据结构的关键。  
引用某位巨佬说过的话：`看到一道Ynoi题，我们第一想到的应该是卡常和分块`。  
所以我们首先对区间进行分块。  
因为此题值域很小，所以我们可以考虑在值域上搞点大新闻。  
我们对每个块的值域开一个节点，并对每个序列上的位置，指向这个值域的节点。  
然后这样查询操作也就基本完成了，只需要查询有多少个节点指向值域节点就好了。  
具体维护可以用并查集维护，空间复杂度是 $O(\text{值域}\times\sqrt{N})$ 的。  
接下来我们讨论一下如何区间修改。  
区间修改其实很暴力，直接暴力枚举每个小于等于 $x$ 的值域节点就好了。  
这样复杂度是 $O(\text{小于x的不同数个数)}$的，显然很容易被卡掉。  
此时我们可以加一个常数优化，记录区间最大值 $max$，如果 $x\le max$ 时，我们直接暴力改。  
否则对于那些比 $max$ 小的位置，并把它们加上一个 $max$，最后标记这个区间需要全局减去 $max$（懒标记。  
加了这个优化就足以过了 CF896E 了QwQ，在这里贴一下代码。  
（还是在线算法  
```cpp
#include<bits/stdc++.h>
#define SZ 333//块的大小
#define L(a) ((a)*SZ-SZ+1)//某个块左端点
#define R(a) ((a)*SZ)//某个块右端点
using namespace std;
template<typename T>inline void read(T &x)
{//快读，这怎么能叫卡常呢（doge
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	x=(f?-x:x);
}
template<typename T>inline void print(T x)
{
	if(x<0) putchar('-'),x=-x;
	{if(x>9) print(x/10);}putchar(x%10+48);
}
struct node{int rt,nm;}g[405][110005];//每个块内值域结构体，rt是值域对应的祖先，num是这个值出现次数
int n,Q,bl[110005],fa[110005],v[110005],a[110005],mx[110005],lz[110005];
//bl是分块中的某个节点属于哪个块，a是初始的数组值，v是一个并查集节点对应的权值
//fa是并查集的祖先数组，mx是区间最大值，lz是懒标记
inline int getf(int x) {return x==fa[x]?x:fa[x]=getf(fa[x]);}
//并查集找祖先，自带路径压缩（
inline void push(int x)//下压一个标记
{
	for(int i=L(x),e=R(x);i<=e;++i) a[i]=v[getf(i)],g[x][a[i]].rt=g[x][a[i]].nm=0,a[i]-=lz[x];
	//遍历这个块中的所有元素，把这个块的东西塞回a中
	lz[x]=0;for(int i=L(x),e=R(x);i<=e;++i) fa[i]=0;//把这个区间清空
}
inline void init(int x)//初始化一个块
{
	mx[x]=0;
	for(int i=L(x),e=R(x);i<=e;++i)
	{
		mx[x]=max(mx[x],a[i]),++g[x][a[i]].nm;//记录区间最大值以及某个值域位置元素个数
		if(g[x][a[i]].rt) fa[i]=g[x][a[i]].rt;else v[i]=a[i],g[x][a[i]].rt=fa[i]=i;
		//如果这个点已经有值域节点存在了，那就直接把当前节点合并到先前节点上去
		//否则新建一个值域节点
	}
}
inline void chng(int x,int a,int b)//把值域为a的位置和值域为b的合并
{
	node &s=g[x][a],&t=g[x][b];//找到两个节点
	if(t.rt) fa[s.rt]=t.rt;else t.rt=s.rt,v[s.rt]=b;
	t.nm+=s.nm,s.nm=s.rt=0;//直接暴力合并，并把s给删除
	//如果b不存在就直接向a贺就好了，直接把a指向b
}
inline void atag(int x,int ad)//打标记
{
	if(ad<=mx[x]-lz[x]-ad) {for(int i=lz[x]+1;i<=lz[x]+ad;++i) if(g[x][i].rt) chng(x,i,i+ad);lz[x]+=ad;}
	else {for(int i=mx[x];i>lz[x]+ad;i--) if(g[x][i].rt) chng(x,i,i-ad);mx[x]=min(mx[x],lz[x]+ad);}
	//刚刚说的分两种情况讨论，应该还挺好懂的吧，不解释了
}
inline void chang(int l,int r,int x)//区间修改操作
{
	int p=bl[l],q=bl[r];push(p);if(p^q) push(q);//都先下推tag
	if(p^q)
	{
		for(int i=l,e=R(p);i<=e;++i) if(a[i]>x) a[i]-=x;
		for(int i=L(q);i<=r;++i) if(a[i]>x) a[i]-=x;//暴力的边块
		for(int i=p+1;i<=q-1;++i) atag(i,x);//整块打标记
		init(p),init(q);//再记录回去块的信息
	}
	else {for(int i=l;i<=r;++i) if(a[i]>x) a[i]-=x;init(p);}
	//否则直接完全的暴力！
}
inline int query(int l,int r,int x)//区间查询操作
{
	//只需要对于每个块来查询值域上所对应的位置出现次数即可
	int p=bl[l],q=bl[r],res=0;//分块基本套路，和chang差不多
	if(p^q)
	{
		for(int i=l,e=R(p);i<=e;++i) if(v[getf(i)]-lz[p]==x) ++res;
		for(int i=L(q);i<=r;++i) if(v[getf(i)]-lz[q]==x) ++res;
		for(int i=p+1;i<=q-1;i++) if(x+lz[i]<=100000) res+=g[i][x+lz[i]].nm;//防止越界
	}
	else for(int i=l;i<=r;++i) if(v[getf(i)]-lz[p]==x) ++res;
	return res;
}
int main()
{
	read(n),read(Q);for(int i=1;i<=n;i++) read(a[i]),bl[i]=(i-1)/SZ+1;
	for(int i=bl[1];i<=bl[n];i++) init(i),lz[i]=0;
	for(int f,l,r,x;Q--;)
	{
		read(f),read(l),read(r),read(x);
		if(f==1) chang(l,r,x);else print(query(l,r,x)),putchar('\n');
	}
	return 0;
}
```
### 进阶（For 五彩斑斓的世界
刚看到[这题](https://www.luogu.com.cn/problem/P4117)的时候，我就单纯地以为它是个双倍经验。于是我交了一发，结果：  
![](https://cdn.luogu.com.cn/upload/image_hosting/np6a9056.png)  
于是我又仔细看了一遍终于发现有点不对劲，数据范围改成了：$x\le5\times10^5$。  
改了数据范围之后又交了一发，结果：
![](https://cdn.luogu.com.cn/upload/image_hosting/xevqbxpy.png)  
~~看来还是不能投机取巧（~~  
这题主要毒瘤之处就是卡了你的空间，我们之前的值域并查集就直接没用了。  
那这题就不能用 第二分块 做了吗？答案是否定的。  
用一个常规套路：离线！  
我们首先把所有询问离线下来，对于每个块，分别模拟每次询问、修改。  
最后把每个块的操作累加起来就好了，我们就得到了正确的答案。  
（好像只能离线，笔者目前还没想到在线的做法。  
代码至少比上面的在线算法简单，也没怎么卡常就过了，所以就不贴了

### 习题
[（模板）Link of Luogu](https://www.luogu.com.cn/problem/CF896E)  
[（模板）Link of Codeforces](http://codeforces.com/problemset/problem/896/E)  
[模板（加强版）](https://www.luogu.com.cn/problem/P4117)  

---

## 作者：寄风 (赞：5)

「突刺贯穿第二分块」。

先去考虑序列分块。

考虑对于一个整块怎么做修改，实际上你会发现对于一个整块不断操作的话，这个块的极差是单调不升的。

同时注意到值域很小，考虑在这个上面做文章。

你设当前块的最大值为 $v$，那么对于一个参数为 $x$ 的修改操作（忽略操作的 $l,r$ 参数），考虑如下处理：

- $v \le 2 \times x$，那么我们可以对于 $[x+1,v]$ 上的值暴力的减。 
-  否则，我们考虑把 $[1,x]$ 上的值暴力的加，然后给块打整体减的 tag。

你考虑这个东西的复杂度为什么是对的，因为对于一个整块的情况 $1$，我们用 $v-x$ 次暴力操作将极差减小了 $x$，而对于情况 $2$，我们用 $x$ 次暴力操作将极差减小了 $x$。

然后因为情况 $1$ 我们只在 $v \le 2 \times x$ 的时候执行，所以我们发现我们的暴力次数总是小于等于极差减小的数量的，而极差最多从 $v$ 减小到 $0$，所以一个块的总修改操作复杂度是 $O(v)$ 的。

因为有 $\sqrt{n}$ 个块，设值域为 $V$，所以总共的修改复杂度是 $O(V \sqrt{n})$ 的。

好那么我们接下来看查询。

考虑对于每个块中，对值开并查集，那么你就很好处理修改了。

查询你就查这个并查集的大小即可。

还有一个问题，就是你正常去做的空间复杂度是 $O(V\sqrt{n})$ 的，不太能接受。

发现块之间互不影响，考虑逐块处理，那么空间复杂度降为 $O(V)$，那么做完了。

### 代码（通过 hack）：
```cpp
 #include <bits/stdc++.h>
using namespace std;
namespace IO {
} using namespace IO;
int fa[1000005] , siz[1000005];
int find(int x){
    if(fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}
int n , m , a[1000005] , maxn , tag , l , r , len , cnt , name[1000005] , v[1000005] , ans[1000005];
struct que{
	int op , l , r , x;
} q[1000005];
inline void init(int x){
	maxn = -2147483647;
	tag = 0;
	int l , r;
	l = (x - 1) * len + 1;
	r = min(n , x * len);
	for(int i = l;i <= r;i++){
		maxn = max(maxn , a[i]);
		if(!name[a[i]]){
			v[i] = a[i];
			name[a[i]] = i;
			fa[i] = i;
		}
		else fa[i] = name[a[i]];
		siz[a[i]]++;
	}
}
inline void add(int x , int y){
	if(name[y]){
		fa[name[x]] = name[y];
		siz[y] += siz[x];
		name[x] = siz[x] = 0;
	}
	else{
		name[y] = name[x];
		v[name[x]] = y;
		siz[y] += siz[x];
		name[x] = siz[x] = 0;
	}
}
inline void update1(int x){
	if(x > ((maxn - tag) >> 1)){
		for(int i = x + tag + 1;i <= maxn;i++){
			if(name[i]) add(i , i - x);
		}
		maxn = min(maxn , x + tag);
	}
	else{
		for(int i = tag + x;i >= tag;i--){
			if(name[i]) add(i , i + x);
		}
		tag += x;
	}
}
inline void update2(int id , int l , int r , int x){
	int nl = (id - 1) * len + 1 , nr = id * len;
	if(id == cnt) nr = n;
	l = max(l , nl);
	r = min(r , nr);
	for(int i = nl;i <= nr;i++){
		int vv = v[find(i)];
		a[i] = vv - tag;
		name[vv] = siz[vv] = 0;
	}
	for(int i = nl;i <= nr;i++){
		v[i] = 0;
	}
	for(int i = l;i <= r;i++){
		if(a[i] > x) a[i] -= x;
	}
	init(id);
}
inline int getans(int id , int l , int r , int x){
	int ans = 0;
	int ll = (id - 1) * len + 1 , rr = id * len;
	if(id == cnt) rr = n;
	l = max(l , ll) , r = min(r , rr);
	for(int i = l;i <= r;i++){
		if(v[find(i)] == x + tag) ans++;
	}
	return ans;
}
inline void write(int x){
    if(x < 0) putchar('-') , x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
int main(){
	n = read() , m = read();
	len = (int) (sqrt(n));
	cnt = n / len;
	if(len * len != n) cnt++;
	for(int i = 1;i <= n;i++) a[i] = read();
	for(int i = 1;i <= m;i++){
		q[i].op = read();
		q[i].l = read();
		q[i].r = read();
		q[i].x = read();
	}
	for(int i = 1;i <= cnt;i++){
		if(i != 1){
			memset(name , 0 , sizeof(name));
			memset(siz , 0 , sizeof(siz));	
		}
		tag = 0;
		maxn = -2147483647;
		int ll = (i - 1) * len + 1 , rr = i * len;
		if(i == cnt) rr = n;
		init(i);
		for(int j = 1;j <= m;j++){
			int op = q[j].op , l = q[j].l , r = q[j].r , x = q[j].x;
			if(ll > r || rr < l) continue;
			if(op == 1){
				if(!(ll >= l && rr <= r)) update2(i , l , r , x);
				else update1(x);
			}
			else{
				if(x + tag > 1e5 + 1) continue;
				if(!(ll >= l && rr <= r)) ans[j] += getans(i , l , r , x);
				else ans[j] += siz[x + tag];
			}
		}
	}
	for(int i = 1;i <= m;i++) if(q[i].op == 2) write(ans[i]) , puts("");
	return 0;
}

---

## 作者：zcz0263 (赞：5)

第二分块。

## 题意
给定一个长度为 $n$ 的序列 $a$ ，有 $m$ 次操作，共有两种：

1.将 $a$ 的区间 $[l,r]$ 内大于 $x$ 的数减去 $x$。  
2.查询 $a$ 的区间 $[l,r]$ 中 $x$ 出现的次数。

$n\le10^6,m\le5\times10^5,0\le x\le10^5+1$。
## 做法
将序列分块，设块长为 $\sqrt n$，对于每个块记录最大值上界 $mx$。

考虑整块操作，因为每个位置的修改后的值只和修改前的值有关，所以我们可以对于每个块内，用并查集维护数值相同的位置，且额外维护每个数值对应并查集中集合的根，然后分两种情况讨论：
- $mx\le2\times x$  
  对于值域 $(x,mx]$，将并查集中这些值对应的集合向 $-x$ 后的集合合并，此时 $mx$ 减少为 $x$。
- $mx>2\times x$  
  对于值域 $[0,x]$，将并查集中这些值的集合向 $+x$ 后的集合合并，再给当前块打上整体 $-x$ 的标记（因为给大于 $x$ 的数 $-x$ 等价于给不大于 $x$ 的数 $+x$ 再全局 $-x$），此时令 $mx$ 减少 $x$。

注意到每次给 $mx$ 减少的值和做出实际操作的值数量是只相差常数的，所以这个部分的时间复杂度复杂度可以均摊为 $O(V\sqrt n)$。

对于散块修改，直接把整块重构然后暴力改掉；对于整块查询，出现次数就是 $x$ 在当前块并查集中所对应的集合大小；对于散块查询，我们在并查集中额外维护每个联通块对应的数值即可。

如果按照一般方式开空间，空间复杂度为 $O(V\sqrt n)$，显然不可接受；观察到修改和查询时每块独立，因此离线下来逐块处理即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define max(...) max({__VA_ARGS__})
#define min(...) min({__VA_ARGS__})
#define tomx(x,...) ((x)=max((x),__VA_ARGS__))
#define tomn(x,...) ((x)=min((x),__VA_ARGS__))
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define N 2000005
#define V 100005
#define M 1000005
#define len 660
bool op[M];
int L[M],R[M],X[M],ans[M],rt[V],tag,mx,cnt[V];
int n,q;
int a[N];
struct node{
	int fa,v;
}d[N];
int find(int u){
	for(;u^d[u].fa;) u=d[u].fa=d[d[u].fa].fa;
	return u;
}
void merge(int x,int y){
    //x->y
	if(!rt[y]){
		rt[y]=rt[x];
		d[rt[y]].v=y;
	}else{
		d[rt[x]].fa=rt[y];
	}
	rt[x]=0;
	cnt[y]+=exchange(cnt[x],0);
}
void solve(int id){
	int lp=(id-1)*len+1;
	int rp=id*len;
	tomn(rp,n);
	mx=tag=0;
	rep(i,lp,rp){
		tomx(mx,a[i]);
		if(!rt[a[i]]) rt[a[i]]=d[i].fa=i,d[i].v=a[i];
		else d[i].fa=rt[a[i]];
		cnt[a[i]]++;
	}
	rep(iq,1,q){
		int l=L[iq],r=R[iq],x=X[iq];
		if(r<lp||rp<l) continue;
		if(l<=lp&&rp<=r){
			if(!op[iq]){
				if(!x) continue;
				if(mx-tag<=2*x){
					rep(i,x+1+tag,mx){
						if(rt[i]) merge(i,i-x);
					}
					tomn(mx,x+tag);
				}else{
					per(i,x+tag,0+tag){
						if(rt[i]) merge(i,i+x);
					}
					tag+=x;
				}
			}else{
				if(x+tag<V)	ans[iq]+=cnt[x+tag];
			}
		}else{
			if(!op[iq]){
				if(!x) continue;
				rep(i,lp,rp) a[i]=d[find(i)].v;
				rep(i,lp,rp) rt[a[i]]=cnt[a[i]]=0;
				rep(i,lp,rp) a[i]-=tag;
				rep(i,lp,rp) d[i].v=0;
				rep(i,max(l,lp),min(r,rp)) a[i]-=x&-(a[i]>x);
				mx=tag=0;
				rep(i,lp,rp){
					tomx(mx,a[i]);
					if(!rt[a[i]]) rt[a[i]]=d[i].fa=i,d[i].v=a[i];
					else d[i].fa=rt[a[i]];
					cnt[a[i]]++;
				}
			}else{
				if(x+tag<V) rep(i,max(l,lp),min(r,rp)) ans[iq]+=(d[find(i)].v-tag==x);
			}
		}
	}
	rep(i,lp,rp) a[i]=d[find(i)].v,rt[a[i]]=cnt[a[i]]=0;
}
main(){
#ifdef LOCAL
    auto start=clock();
#endif
    ios::sync_with_stdio(0),cin.tie(nullptr);
	cin>>n>>q;
	rep(i,1,n) cin>>a[i];
	rep(i,1,q){
		int c;
		cin>>c>>L[i]>>R[i]>>X[i];
		op[i]=c-1;
	}
	rep(i,1,(n-1)/len+1) solve(i);
	rep(i,1,q){
		if(op[i]) cout<<ans[i]<<"\n";
	}
#ifdef LOCAL
    clog<<"\ntime: "<<clock()-start<<" ms\n";
#endif
}
```

---

## 作者：Terac (赞：3)

[$\texttt{link}$](https://www.luogu.com.cn/problem/P4117)

update on 2021.11.12 修正了一些错误。

## 题意

给定一个长为 $n$ 的序列 $a$，$m$ 次操作：  
+ 将 $a_{l,\cdots,r}$ 中大于 $x$ 的数减去 $x$。  
+ 查询区间 $a_{l,\cdots,r}$ 中等于 $x$ 的数的个数。  

数据范围：$1\le n\le10^5,1\le m\le5\times 10^5,0\le a_i,x\le10^5$

## 题解 

设 $w$ 为值域。

对于每个块内，记录每一个值出现的次数，维护一个最大值 $maxn$ 和一个区间减的标记。  

对于修改操作，散块直接暴力重构。  

若修改一个整块，分类讨论一下，设更新所有值为 $v$ 的数时间复杂度为 $O(\text{ds})$：  

- 若 $maxn\le 2x$，把块内所有大于 $x$ 的数减去 $x$。此时需更新的区间为 $\left[x+1,maxn\right]$，此时用 $O(maxn-x)\times O(\text{ds})$ 的代价使 $maxn$ 减少了 $maxn-x$。

- 若 $maxn>2x$，把块内所有小于等于 $x$ 的数加上 $x$，再打上区间减 $x$ 的标记，需更新的区间为 $\left[1,x\right]$，此时用 $O(x)\times O(\text{ds})$ 的代价使 $maxn$ 的代价减少了 $x$。  

首先所有的值会越来越小，又 $maxn$ 比 $2x$ 大就会打标记，这就保证了 $maxn$ 不会溢出，每个值每个块最多会修改 $w$ 次，复杂度即为 $O(w)$。

散块查询暴力统计，整块查询返回块内值 $x$ 记录的个数即可，时间复杂度为 $O(\sqrt{n})$。  

空间复杂度为即为 $O(w\sqrt{n})$，$w$ 为值域。

考虑怎么更新每个值对应的一堆数。  

比较好写的写法是并查集，对于任意一个其值为 $v$ 的并查集，维护一个 $rt$，表示序列中第一个值为 $v$ 的数的下标，对于等于同一个值 $x$ 的数，则全并到 $fa_{rt_x}$ 上。  

在合并的时候，设把值为 $x$ 的并查集合并到值为 $y$ 的并查集上。  

- 若 $rt_y$ 不存在，则把 $rt_x$ 全放到 $rt_y$ 上，并使 $rt_y$ 指向 $y$。  
- 若 $rt_x$ 存在，则直接合并 $rt_x$ 和 $rt_y$ 两个并查集。  

用这种并查集可把维护每个块的复杂度优化到了 $O(\alpha(n))\approx O(1)$，总体时间复杂度是 $O((n+m)\sqrt{n})$，空间复杂度为 $O(w\sqrt{n})$。  


此题卡了 $O(w\sqrt{n})$ 空间。  

有个逐块处理的 trick，即离线下来一块一块处理，可把空间复杂度优化到 $O(w)$。  

然而我常数大！！！！1 还要卡常才能过。

也许可以加启发式合并？但我不会写，而且重构次数较多，启发式合并优化意义不大。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO {
	#if ONLINE_JUDGE
	#define getc() (IS == IT && (IT = (IS = ibuf) + fread(ibuf, 1, IL, stdin), IS == IT) ? EOF : *IS++)
	#else
	#define getc() getchar()
	#endif
	const int IL = 1 << 20, OL = 1 << 21;
	int olen = 0; 
	char ibuf[IL], *IS = ibuf, *IT = ibuf, obuf[OL];
	inline int read() {
		register char ch = getc(); register int f = 1, x = 0;
		while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getc(); }
		while(isdigit(ch)) x = x * 10 + ch - 48, ch = getc();
		return x * f;
	}
	inline void flush() { fwrite(obuf, 1, olen, stdout); olen = 0; }
	inline void putc(register char ch) { obuf[olen++] = ch; }
	template<class T>
	inline void write(register T x) {
		if(x < 0) obuf[olen++] = '-', x = -x;
		if(x > 9) write(x / 10);
		obuf[olen++] = x % 10 + 48;
	}
} using namespace IO;
const int N = 1e6 + 10, M = 5e5 + 10, W = 1e5 + 10;
int n, m;
int a[N], val[N], s, t, fa[N], siz[N], rt[W], mx, tag, L;
struct ask {
	int opt, l, r, x, ans;
}q[M];
inline int find(int x) {
	if(fa[x] == x)
		return x;
	return fa[x] = find(fa[x]);
}
inline void init() { L = sqrt(n); }
inline void build() {
	mx = tag = 0;
	for(register int i = s; i <= t; i++) {
		mx = max(mx, a[i]);
		if(!rt[a[i]])
			fa[i] = rt[a[i]] = i, val[i] = a[i];
		else
			fa[i] = rt[a[i]];
		siz[a[i]]++;
	}
}
inline void merge(int x, int y)  {
	if(rt[y]) fa[rt[x]] = rt[y];
	else {
		rt[y] = rt[x];
		val[rt[y]] = y;
	}
	siz[y] += siz[x];
	rt[x] = siz[x] = 0;
}
inline void total_update(int x) {
	if(mx - tag > (x << 1)) {
		for(register int i = tag + 1; i <= tag + x; i++)
			if(rt[i])
				merge(i, i + x);
		tag += x;
	}
	else {
		for(register int i = mx; i > tag + x; i--)
			if(rt[i])
				merge(i, i - x);
		mx = min(mx, tag + x);
	}
}
inline void part_update(int l, int r, int x) {
	for(register int i = s; i <= t; i++) {
		a[i] = val[find(i)];
		rt[a[i]] = siz[a[i]] = 0;
		a[i] -= tag;
	}
	int nl = max(s, l), nr = min(t, r);
	for(register int i = s; i <= t; i++)
		val[i] = fa[i] = 0;
	for(int i = nl; i <= nr; i++)
		a[i] -= x * (a[i] > x);
	build();
} 
inline void query(int num) {
	if(q[num].l <= s && t <= q[num].r) 
		q[num].ans += siz[q[num].x + tag];
	else {
		int nl = max(s, q[num].l), nr = min(t, q[num].r);
		for(register int i = nl; i <= nr; i++)
			if(val[find(i)] - tag == q[num].x)
				q[num].ans++; 
	}
}
int main() {
	n = read(), m = read();
	for(register int i = 1; i <= n; i++) 
		a[i] = read();
	for(register int i = 1; i <= m; i++) {
		q[i].opt = read(), q[i].l = read(), q[i].r = read(), q[i].x = read();
	}
	L = sqrt(n);
	for(register int now = 1; now <= n; now += L) {
		memset(siz, 0, sizeof(siz));
		memset(rt, 0, sizeof(rt));
		s = now, t = min(n, now + L - 1);
		build();
		for(register int i = 1; i <= m; i++) {
			if(t < q[i].l || s > q[i].r) 
				continue;
			if(q[i].opt == 1) {
				if(q[i].l <= s && q[i].r >= t)
					total_update(q[i].x);
				else
					part_update(q[i].l, q[i].r, q[i].x);
			}
			else if(tag + q[i].x <= M) 
				query(i);
		}
	}
	for(register int i = 1; i <= m; i++)
		if(q[i].opt == 2)
			write(q[i].ans), putc('\n');
	flush();
	return 0;
} 
```

---

## 作者：yzxoi (赞：1)

## [My Blog](https://yzxoi.top/archives/1736)

## Description

> 题目链接：[P4117](https://www.luogu.com.cn/problem/P4117)

给定一个长为 $n$ 的序列，有 $m$ 个操作：

1. 区间 $[l,r]$ 中大于 $x$ 的数减去 $x$。
2. 查询区间 $[l,r]$ 中 $x$ 的出现次数。

$1\leq n \leq 10^6,1\leq m \leq 5\times 10^5,1\leq l \leq r\leq n,0\leq a_i,x\leq 10^5+1$

## Solution

注意到数值很小，所以可以考虑利用值域。

首先我们记录每个块的最大值。

如果 $Max\leq x\times 2$，那么我们直接暴力把所有大于 $x$ 的数减去 $x$，复杂度为 $O(x)$。

如果 $Max>x\times 2$，那么我们反过来，把小于 $x$ 的数加上 $x$，再打上块内全局减 $x$ 的标记，复杂度为 $O(Max-x)$。

所以总复杂度为 $O(\sqrt{N}V)$。

考虑如何快速维护合并、动态查询单点、个数查询，~~很显然~~可以用并查集。

所以时间复杂度为 $O(\sqrt{N}V\alpha(N))$。

注意到此题的空间只有 64MB。

所以考虑把询问离线下来，把每个操作拆分到每个块中即可。

然后稍微卡卡常就过了。

## Code

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define W while
#define I inline
#define RI register int
#define LL long long
#define Cn const
#define CI Cn int&
#define gc getchar
#define D isdigit(c=gc())
#define pc(c) putchar((c))
#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
using namespace std;
namespace Debug{
	Tp I void _debug(Cn char* f,Ty t){cerr<<f<<'='<<t<<endl;}
	Ts I void _debug(Cn char* f,Ty x,Ar... y){W(*f!=',') cerr<<*f++;cerr<<'='<<x<<",";_debug(f+1,y...);}
	Tp ostream& operator<<(ostream& os,Cn vector<Ty>& V){os<<"[";for(Cn auto& vv:V) os<<vv<<",";os<<"]";return os;}
	#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)
}using namespace Debug;
namespace FastIO{
	Tp I void read(Ty& x){char c;int f=1;x=0;W(!D) f=c^'-'?1:-1;W(x=(x<<3)+(x<<1)+(c&15),D);x*=f;}
	Ts I void read(Ty& x,Ar&... y){read(x),read(y...);}
	Tp I void write(Ty x){x<0&&(pc('-'),x=-x,0),x<10?(pc(x+'0'),0):(write(x/10),pc(x%10+'0'),0);}
	Tp I void writeln(Cn Ty& x){write(x),pc('\n');}
}using namespace FastIO;
Cn int N=1e6,S=1272,M=N/S,V=1e5+1,QQ=5e5;
int n,m,b[M+5][S+5],sz[M+5],tot,F[S+5],G[S+5],H[V+5],mx,T,Ans[QQ+5];
struct Que{int opt,l,r,x,id;}q[QQ+5];
I int find(CI k,CI x){return x==F[x]?x:F[x]=find(k,F[x]);}
I void Z(CI k,CI l,CI r,CI x){
	RI i;for(i=0;i<sz[k];i++) G[H[b[k][i]=b[k][find(k,i)]]]=0;for(mx=0,i=0;i<sz[k];i++) H[b[k][i]]=F[i]=-1,b[k][i]-=T;
	for(i=l;i<=r;i++) b[k][i]>x&&(b[k][i]-=x);for(T=0,i=0;i<sz[k];i++) mx=max(mx,b[k][i]),~H[b[k][i]]?++G[F[i]=H[b[k][i]]]:G[F[i]=H[b[k][i]]=i]=1;
}
I void Merge(CI k,CI x,CI y){~H[y]&&(~H[x]?G[F[H[y]]=H[x]]+=G[H[y]],G[H[y]]=0:b[k][H[x]=H[y]]=x,H[y]=-1);}
I void U(RI l,RI r,CI x){
	RI i,j,bL=l/S+1,bR=r/S+1;if(l-=(bL-1)*S,r-=(bR-1)*S,l||r<sz[bL]-1) return Z(bL,l,r,x);//散块暴力
	if(2*x>mx-T){for(j=T+x+1;j<=mx;j++) Merge(bL,j-x,j);mx=min(mx,T+x);}
	else{for(j=T+x;j>=T+1;j--) Merge(bL,j+x,j);T+=x;}//分两类情况讨论
}
I int Y(CI k,CI l,CI r,CI x){RI X=0,i;for(i=l;i<=r;i++) b[k][find(k,i)]==T+x&&++X;return X;}
I int Q(RI l,RI r,CI x){
	RI i,bL=l/S+1,bR=r/S+1,X=0;if(l-=(bL-1)*S,r-=(bR-1)*S,l||r<sz[bL]-1) return Y(bL,l,r,x);//散块暴力
	for(i=bL;i<=bR;i++) T+x<=V&&~H[T+x]&&(X+=G[H[T+x]]);return X;//直接用并查集维护
}
int main(){
	RI i,j,p,k,opt,l,r,x;for(read(n,m),i=0;i<n;i++) read(x),b[i/S+1][sz[i/S+1]++]=x;memset(F,-1,sizeof(F)),memset(H,-1,sizeof(H));
	for(i=1;i<=m;i++) read(q[i].opt,q[i].l,q[i].r,q[i].x),q[i].l--,q[i].r--,q[i].id=i;for(i=1;i<=(n-1)/S+1;i++){
		memset(H,-1,sizeof(H)),memset(G,0,sizeof(G)),memset(F,-1,sizeof(F));
		for(T=mx=0,j=0;j<sz[i];j++) ~H[b[i][j]]?++G[F[j]=H[b[i][j]]]:G[F[j]=H[b[i][j]]=j]=1,mx=max(mx,b[i][j]);
		for(j=1;j<=m;j++) if((i-1)*S<=q[j].r&&q[j].l<=min(n-1,i*S-1)) if(q[j].opt==1) U(max(q[j].l,(i-1)*S),min(min(n-1,i*S-1),q[j].r),q[j].x);
		else Ans[q[j].id]+=Q(max(q[j].l,(i-1)*S),min(min(n-1,i*S-1),q[j].r),q[j].x);//离线
	}for(i=1;i<=m;i++) if(q[i].opt==2) writeln(Ans[i]);return 0;
}
```

---

## 作者：xfrvq (赞：0)

考虑整块修改，**块中可能值数量一定减少**，设块最大值 $k$。

+ $x\ge\frac k2$ 时：对值域 $(x,k]$ 减 $x$。**之后值域 $[x,k]$ 不会有数**。
+ $x\lt\frac k2$ 时：对值域 $[0,x]$ 加 $x$，打全局减 $x$ 标记。**之后原值域 $[0,x]$ 不会有数**。

这样每个块每个值只会修改一次，势能为值域。设 $C_{I,j}$ 为块 $I$ 中 $j$ 出现次数，所有修改有每块 $O(n)$ 次，共 $O(n\sqrt n)$ 次修改 $C$，询问容易用 $C$ 算。

现在有了散块修改，这个不破坏势能，可以直接做。但需要支持 $O(\sqrt n)$ **还原整块**。

一个整块内，操作是总共 $O(n)$ 次让值 $i$ 指向 $j$ 并删去原值 $i$，查询每个位置。维护值域到任意位置映射，**对位置上**维护并查集，根处记录这个联通块的值，相当于**知道了两个联通块的根**做合并，直接合并复杂度 $O(1)$。查询时给每个点路径压缩一次，**总**复杂度 $O(\sqrt n)$。

离线逐块处理线性空间，注意特判询问 $0$ 出现次数。

```cpp
#include<bits/stdc++.h>
using namespace std;

#ifdef ONLINE_JUDGE
static char buf[1000000],*p1=buf,*p2=buf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#endif

inline int read(){
    register int x = 0;
    register char c = getchar();
    for(;c < '0' || c > '9';c = getchar());
    for(;c >= '0' && c <= '9';c = getchar())
        x = x * 10 + (c ^ '0');
    return x;
}

#define il inline
#define rg register

const int maxn = 1e6 + 5;
const int maxm = 5e5 + 5;
const int maxv = 1e5 + 5;

int n,m,a[maxn],ans[maxm];

int pos[maxn],num[maxn],siz[maxn],fa[maxn];

il int fnd(rg int i){ return i == fa[i] ? i : fa[i] = fnd(fa[i]); }

il void chg(rg int i,rg int x){
	if(!pos[x]){
		pos[x] = i;
		num[i] = x;
		siz[x] = 1;
		fa[i] = i;
	} else {
		fa[i] = pos[x];
		++siz[x];
	}
}

il void updt(rg int x,rg int y){
	if(!pos[y]){
		pos[y] = pos[x];
		num[pos[y]] = y;
		siz[y] += siz[x];
		pos[x] = siz[x] = 0;
	} else {
		fa[pos[x]] = pos[y];
		siz[y] += siz[x];
		pos[x] = siz[x] = 0;
	}
}

#define val(i) num[fnd(i)]

const int blk = sqrt(maxn) + 5;
const int inf = 2e9; 

int blc,b,st,ed,mx,tag;

il void build(rg int i){
	st = (i - 1) * blc + 1;
	ed = min(i * blc,n);
	mx = -inf; tag = 0;
	for(rg int i = st;i <= ed;++i)
		mx = max(mx,a[i]), chg(i,a[i]);
}

il void blk0upd(rg int l,rg int r,rg int x){
	l = max(l,st); r = min(r,ed);
	for(rg int i = st;i <= ed;++i){
		a[i] = val(i);
		siz[a[i]] = 0; pos[a[i]] = 0;
		a[i] -= tag;
	}
	for(rg int i = st;i <= ed;++i) num[i] = 0;
	for(rg int i = l;i <= r;++i)
		if(a[i] > x) a[i] -= x;
	build(b); 
}

il void blkupd(rg int x){
	if(x > (mx - tag) / 2){
		for(rg int i = x + tag + 1;i <= mx;++i)
			if(pos[i]) updt(i,i - x);
		mx = min(mx,x + tag);
	} else {
		for(rg int i = tag;i <= x + tag;++i)
			if(pos[i]) updt(i,i + x);
		tag += x;
	}
}

il int qry0(rg int l,rg int r,int x){
	rg int cc = 0;
	l = max(l,st); r = min(r,ed);
	for(int i = l;i <= r;++i)
		if(val(i) == x + tag) ++cc;
	return cc;
}

struct qry{ int op,l,r,x; } q[maxm];
vector<int> P; 

int main(){
	scanf("%d%d",&n,&m);
	for(rg int i = 1;i <= n;++i){
		scanf("%d",a + i);
		if(!a[i]) P.push_back(i);
	}
	for(rg int i = 1;i <= m;++i){
		scanf("%d%d%d%d",&q[i].op,&q[i].l,&q[i].r,&q[i].x);
		if(q[i].op == 2 && !q[i].x) ans[i] = upper_bound(begin(P),end(P),q[i].r) - lower_bound(begin(P),end(P),q[i].l); 
	}
	blc = sqrt(n);
	for(b = 1;b <= blc;++b){
		memset(pos,0,sizeof pos);
		memset(siz,0,sizeof siz);
		build(b);
		for(rg int i = 1;i <= m;++i){
			if(st > q[i].r || ed < q[i].l) continue;
			if(q[i].op == 2 && !q[i].x) continue;
			rg bool use0 = !(q[i].l <= st && ed <= q[i].r);
			if(q[i].op == 1){
				if(use0) blk0upd(q[i].l,q[i].r,q[i].x);
				else blkupd(q[i].x);
			} else {
				if(q[i].x + tag > 1e5 + 2) continue;
				if(use0) ans[i] += qry0(q[i].l,q[i].r,q[i].x);
				else ans[i] += siz[q[i].x + tag];
			}
		}
	}
	for(int i = 1;i <= m;++i) if(q[i].op == 2) printf("%d\n",ans[i]);
	return 0;
}
```

---


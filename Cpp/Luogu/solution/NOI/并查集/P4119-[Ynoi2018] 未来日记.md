# [Ynoi2018] 未来日记

## 题目背景

所以说，小雪的未来是由乃的~

 ![](https://cdn.luogu.com.cn/upload/pic/13174.png) 

嗯...我知道你的未来会怎样

听好吧，我妻由乃

 ![](https://cdn.luogu.com.cn/upload/pic/13175.png) 

因为小雪改变了未来，所以他们三人才能在一起...

为什么...

这样我简直就是坏人...

 ![](https://cdn.luogu.com.cn/upload/pic/13176.png) 

我不会刺的

因为...这就是未来啊

这里...就是我的家

![](https://cdn.luogu.com.cn/upload/pic/13177.png)


## 题目描述

我妻由乃给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作。

1. 把区间 $[l,r]$ 内所有的 $x$ 变成 $y$。
2. 查询区间 $[l,r]$ 内第 $k$ 小值。


## 说明/提示

Idea：f321dd，Solution：f321dd&nzhtl1477，Code：nzhtl1477&Claris，Data：nzhtl1477&Juan_feng

$1\le n,m,a_i \le 10^5$。

By f321dd & nzhtl1477 & Claris


## 样例 #1

### 输入

```
3 3
2 3 3
2 1 3 1
1 1 3 3 1
2 1 3 2```

### 输出

```
2
1```

# 题解

## 作者：shadowice1984 (赞：91)

楼下题解写的太神了我可能没看懂……

表示这题细节极多稍不留神就会写错

而且复杂度的分析其实也挺不对劲的……

最后可能就是我人傻常数大吧，调了半年块长才过……

~~管他什么题，总之lxl毒瘤数据结构天下第一~~
________________

# 本题题解

我们先来分析一下询问会发现这是一个经典的区间kth问题

那么我们解决静态区间第k小的常用工具就是主席树(可持久化线段树)了

遗憾的是这道题有修改所以我们并不能这样做

我们的另一个思路是很自然的使用分块这个技术来维护一些关于权值的信息，结合二分答案我们可以做到$O(logn\sqrt{n})$的复杂度

这其实是一个误区,主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(logn)$的复杂度,这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$log$之内

但是我们现在是使用分块解决问题,分块是有自己复杂度的就是$O(\sqrt{N})$而不是$O(logn)$这意味着分块其实和log的数据结构以及二分法并不是很搭(因为分块的结构本质上就不支持二分)如果我们我们需要强行嵌入log的数据结构的话在绝大部分情况下都会使复杂度凭空多出个log来,这在强调常数的根号算法中绝对是致命的

分块真正适合的一些更加暴力的算法,比如另一个分块

所以我们这题使用**分块套权值块状数组**这个数据结构来解决问题

具体来讲我们查询kth的时候不再二分,而是将值域分为$\sqrt{1e5}$块每块单独维护一个该值域区间里值的个数，这样的话我们查kth的时候就先for一遍每个块,将kth所在的位置定位到一段长为$\sqrt{1e5}$的值域区间里

接下来我们再挨个for这个区间里的每一个数字,看它是不是kth就可以了

这样操作的话我们查询一遍kth就是$O(\sqrt{N})$的复杂度了

那这样做有什么好处呢？

好处就是我们无需维护值的前缀和,也就是我们无需关心"**区间里比x小的数字出现了多少次**”这个问题。

如果使用这个算法求解kth的话我们需要关心的是“**区间里x这个值出现了多少次**“以及"**区间里属于第x个值域块的数字出现了多少次**"这两个单点
的问题

那么事实上如果没有修改我们就已经可以做这道题了

我们将序列分为$\sqrt{N}$块，将值域分成$\sqrt{1e5}$块

然后记两个数组$cnt1[valid][id],cnt2[val][id]$分别表示前$id$块当中域在第$valid$个值域块的数字出现了多少次和前$id$块中$val$这个值出现了多少次

这样的话区间kth的时候我们预处理出两个$tr1[val],tr2[valid]$分别表示零散的点当中$val$这个值出现了多少次，和零散的点当中在第$valid$个值域块当中的数字出现了多少次

这样的话我们回答"**区间里属于第x个值域块的数字出现了多少次**"，这个问题的时候就两个整块的前缀和减一下然后加上零散的部分就可以回答了，同理我们也可以这样回答“**区间里x这个值出现了多少次**”这个问题

此时静态的问题我们就解决完毕了现在让我们来应对一下这个鬼畜的修改问题

首先我们已经在分块了因此我们自然会把这个修改套到分块的修改问题上去,那么分块的修改是相当套路的东西,我们暴力重构两侧的散块，然后给中间的$O(\sqrt{N})$个块打上修改标记就好了

但是问题来了这个题的标记不是一般的难打……我太笨了并不会一个严格的算法去解决这个打标记问题

所以让我们来想一个均摊复杂度是正确的算法来解决我们的修改问题

我们发现我们修改操作的一个重要的特点就是如果整个块被做了这个修改操作的话，区间中的数字种类要么-1要么不变，只有在块的一部分被做了修改操作的时候整个区间的数字种类个数才有可能+1

由于我们将序列分成$\sqrt{N}$块，显然初始每个块中数字种类不超过$O(\sqrt{N})$种,我们每次给零散的块做修改最多产生一个新的数字,因此总数字种类是$O(N+M)$级别的

那么如果我们每次在一个块的数字种类减少1(换句话讲就是合并两类数字的时候)暴力重构整个块，我们的复杂度最多是$O((N+M)\sqrt{N})$的

这样的话我们就不必担心合并两个数字的问题了因为我们可以通过暴力来解决它

现在我们只需要解决这样一个问题就是我们把一个数字变成另一种从未出现过多数字这个修改操作了，然后这个问题其实也很难做，但是我们此时已经不能通过别的巧妙的方式绕开它了……所以我们只能硬做

那么我们发现由于一定是把一种数字换成了现在未出现过的数字(但是并不是说之前没有出现过,比如说2换成3然后3换成4之后9换成3这类的逻辑关系我们都需要处理)

那么我们发现一件事无论怎么修改我们会发现一些位置的数字他们自己数值相同总是和其他位置不同的,有点像你把数组里存储的数字换了但是数组还是这个数组一样(但是把两个数字合并将会破坏这个优雅的性质，此时就可以大力重构了)

那么我们采取这样一种结构来存储所有的修改信息

我们首先记录一个$col$数组表示每个位置的数字离散化之后值+1e5的值

接下来我们记录一个$id$数组表示每个数字当前对应的值的下标

接下来我们记录一个$iv$数组表示每个下标对应的值

仅仅看这3个数组的定义没有任何意义，你也不会知道如何去使用他们

但是通过这3个数组,我们希望完成一个维护一个非常有用的恒等式那就是

**任意时刻 iv[id[col[i]]]=i这个位置的真实数字**

为了方便修改我们还需要维护这样一个恒等式就是

**任意时刻 id[col[i]]=id[i这个位置的真实数字]**

**任意时刻 id[一个不存在的数字]=0**

一开始这种结构对应着下图的左半边(最底下的大圆是$col[i]$,第二层的小圆是$id[col[i]]$,第三层方框$iv[id[col[i]]]$表示这个元素的实际值

![](https://cdn.luogu.com.cn/upload/pic/37250.png)

接下来我们执行一个修改1->5

那么根据恒等式1我们令$iv[id[1]]=5$同时为了维护恒等式2我们令$id[5]=id[1]$，同时还是为了维护恒等式2我们令$id[1]=0$

那么修改之后的图就是上图的右半边了,我们发现我们维护的恒等式都没有发生变化同时存储一个节点信息的方式还是和原来一样的形式

所以我们可以继续对这个结构进行修改了

然后重构之前我们先把每个位置都还原成$iv[id[col[i]]]$就可以大力重构了

这样的话我们就完成了打标记的操作了

接下来我需要修改$cnt1,cnt2$数组的值

那这个也不是很难我们统计出修改的每一块里面出现了多少个x值,然后把这些值做一个前缀和,接下来按照定义去修改$cnt1$和$cnt2$数组的值(把x那一维减去把y那一维加上对应的前缀和)就可以了

~~一开始修改的时候写成了无脑更改后缀的导致复杂度变成了$O(N^2)$或者是$O(N^{\frac{5}{3}})$结果通过胡乱调块长和卡cache愣是过了这题~~

然后就是注意一些细节就可以通过本题辣~

上代码~

```C
// luogu-judger-enable-o2
#pragma GCC optimize(3)
#pragma GCC optimize(Ofast)
#include<cstdio>
#include<algorithm>
using namespace std;
/**************************/
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
/********************/
const int N=1e5+10;const int B=317;const int B1=350;int n;int m;int book[N];int bi1[N];
int cnb[N/B1+3][N/B+3];int sum[N][N/B+3];int bi[N];int bj[N];int tr[N];int trb[N/B1+3];
int msum[N/B+3];
int nans[N];int CNT;int trs[N];
struct block
{
    int id[N+B];int iv[B+3];int col[B+3];int siz;int u;int ct;int rcol[B+3];
    inline int& operator [](const int& x){return col[x];}
    inline int fd(const int& x){return iv[id[col[x]]];}
    inline void build()//离散化并建立标记结构 
    {
        for(int i=1;i<=siz;i++)
            trs[i]=book[col[i]]=(!book[col[i]])?++ct:book[col[i]];
        for(int i=1;i<=siz;i++)book[col[i]]=0;
        for(int i=1;i<=siz;i++)iv[trs[i]]=col[i];
        for(int i=1;i<=siz;i++)id[col[i]]=trs[i];
        for(int i=1;i<=siz;i++)col[i]=trs[i]+100000;
        for(int i=1;i<=siz;i++)id[col[i]]=trs[i];
    }
    inline void reb_md(int x,int y)//重构修改 
    {
        for(int i=1;i<=siz;i++)col[i]=iv[id[col[i]]];
        for(int i=1;i<=siz;i++)col[i]=(col[i]==x)?y:col[i];ct=0;build();
    }
    inline void reb_md(int x,int y,int l,int r)
    {
        if(sum[x][u]==sum[x][u-1])return;
        for(int i=1;i<=siz;i++)col[i]=iv[id[col[i]]];int cntx=0;
        for(int i=l;i<=r;i++)if(col[i]==x)col[i]=y,cntx++;ct=0;build();
        msum[u]=cntx;
    }
    inline void lb_md(int x,int y){id[y]=id[x];iv[id[x]]=y;id[x]=0;}
    inline void modify(int x,int y)//根据是否需要合并两个块重构或者打标记 
    {
        if(sum[x][u]==sum[x][u-1])return;
        if(sum[y][u]!=sum[y][u-1])reb_md(x,y);else lb_md(x,y);
        msum[u]=sum[x][u]-sum[x][u-1];
    }
    inline void deal_tr(int l,int r)//处理零散块 
    {
        for(int i=l;i<=r;i++)rcol[i]=fd(i);
        for(int i=l;i<=r;i++)tr[rcol[i]]++,trb[bi1[rcol[i]]]++;
    }
    inline void clear_tr(int l,int r)//清空 
    {for(int i=l;i<=r;i++)tr[rcol[i]]=0,trb[bi1[rcol[i]]]=0;}
}bl[N/B+3];
inline int subsolve(int t1,int t2,int k)//查找kth 
{
    int ans=B1;int cnt=0;int j=1;
    for(cnt=cnb[j][t2]-cnb[j][t1]+trb[j];cnt<k;j++,ans=min(ans+B1,N-10),cnt+=cnb[j][t2]-cnb[j][t1]+trb[j]);
    for(;cnt>=k;cnt-=sum[ans][t2]-sum[ans][t1]+tr[ans],ans--);return ans+1;
}
inline int kth(int l,int r,int k)//分情况讨论一下就行了 
{
    if(bi[l]==bi[r])
    {
    	bl[bi[l]].deal_tr(bj[l],bj[r]);int res=subsolve(0,0,k);
        bl[bi[l]].clear_tr(bj[l],bj[r]);return res;
    }int dl;int dr;
    if(bj[l]!=1){bl[bi[l]].deal_tr(bj[l],B);dl=bi[l];}else dl=bi[l]-1;
    if(bj[r]!=B&&r!=n){bl[bi[r]].deal_tr(1,bj[r]);dr=bi[r]-1;}else dr=bi[r];
    int res=subsolve(dl,dr,k);
    if(bj[l]!=1){bl[bi[l]].clear_tr(bj[l],B);}if(bj[r]!=B&&r!=n){bl[bi[r]].clear_tr(1,bj[r]);}
    return res;
}
int main()
{
    for(int i=1;i<=N-10;i++)bi[i]=(i-1)/B+1,bj[i]=(i-1)%B+1;
    for(int i=1;i<=N-10;i++)bi1[i]=(i-1)/B1+1;read(n);read(m);
    for(int i=1,v;i<=n;i++)//预处理kth表 
    {
        read(v);bl[bi[i]][bj[i]]=v;
        for(int j=bi[i];j<=bi[n];j++)sum[v][j]++;v=bi1[v];
        for(int j=bi[i];j<=bi[n];j++)cnb[v][j]++;
    }
    for(int i=1;i<bi[n];i++)bl[i].siz=B;bl[bi[n]].siz=(n%B==0)?B:n%B;
    for(int i=1;i<=bi[n];i++)bl[i].u=i;for(int i=1;i<=bi[n];i++)bl[i].build();
    for(int i=1,t,l,r,x,y;i<=m;i++)
    {
        read(t);
        if(t==1)
        {
            read(l);read(r);read(x);read(y);
            for(int i=bi[l];i<=bi[n];i++)msum[i]=0;	
            if(bi[l]==bi[r]){bl[bi[l]].reb_md(x,y,bj[l],bj[r]);}
            else
            {
                int dl;int dr;
            	if(bj[l]!=1)bl[bi[l]].reb_md(x,y,bj[l],B),dl=bi[l]+1;else dl=bi[l];
            	if(bj[r]!=B&&r!=n)bl[bi[r]].reb_md(x,y,1,bj[r]),dr=bi[r]-1;else dr=bi[r];
            	for(int j=dl;j<=dr;j++)bl[j].modify(x,y);
            }//做前缀和之后按位修改对应的表格 
            for(int i=bi[l]+1;i<=bi[n];i++)msum[i]+=msum[i-1];
            for(int i=bi[l];i<=bi[n];i++)sum[x][i]-=msum[i];
            for(int i=bi[l],bv=bi1[x];i<=bi[n];i++)cnb[bv][i]-=msum[i];
            for(int i=bi[l];i<=bi[n];i++)sum[y][i]+=msum[i];
            for(int i=bi[l],bv=bi1[y];i<=bi[n];i++)cnb[bv][i]+=msum[i];
        }else {read(l);read(r);read(x);printf("%d\n",kth(l,r,x));} 
    }return 0;//拜拜程序~ 
}



```

---

## 作者：ftiasch (赞：69)

### Description

维护一个数组 $a[n]$，支持 $q$ 次下面 $2$ 种操作：

$\mathrm{change}(l, r, x, y)$: 对于 $i \in [l, r]$, 如果 $a[i] = x$, 把 $a[i]$ 设为 $y$;

$\mathrm{query}(l, r, k)$: 返回 $a[l..r]$ 中的第 $k$ 小值。

#### 限制

$n \leq 10^5$

$q \leq 10^5$

$1 \leq a[i], x, y \leq 10^5$

### Solution

假定 $1 \leq a[i], x, y \leq m$.

把数组 $a$ 分成大小是 $O(\sqrt{n})$ 的 $O(\sqrt{n})$ 块。

用正体 $i$ 表示数组的下标，粗体 $\mathbf{i}$ 表示块的下标。

同时，把值域 $[1, m]$ 分成大小是 $O(\sqrt{m})$ 的 $O(\sqrt{m})$.

用粗体 $\mathbf{v}$ 表示 $v \in [1, m]$ 所在的块的编号，即 $\mathbf{v} = \lfloor v / \sqrt{m} \rfloor$.

---

令 $\mathrm{cnt}[v][\mathbf{i}]$ 表示在前 $\mathbf{i}$ 个块中，值是 $v$ 的元素个数。

令 $\mathrm{blkcnt}[\mathbf{v}][\mathbf{i}]$ 表示在前 $\mathbf{i}$ 个块中，值在块 $\mathbf{v}$ 中的元素个数。

对于询问 $\mathrm{query}(l, r, k)$, 假定 $[l, r]$ 包含了块 $\mathbf{l}$ 到块 $\mathbf{r}$, 和另外 $O(\sqrt{n})$ 个元素 $\mathcal{I}$.

令 $\mathrm{tmpblkcnt}[\mathbf{v}]$ 表示 $\mathcal{I}$ 中，值在块 $\mathbf{v}$ 中的元素个数。

$a[l..r]$ 中，值在块 $\mathbf{v}$ 中的元素数量
$$
b(\mathbf{v}) = \mathrm{tmpblkcnt}[\mathbf{v}] + (\mathrm{blkcnt}[\mathbf{v}][\mathbf{r}] -\mathrm{blkcnt}[\mathbf{v}][\mathbf{l} - 1]).
$$
从小到大枚举 $\mathbf{ans}$ 直到 $b(\mathbf{1}) + \dots + b(\mathbf{ans}) \geq k$，得到第 $k$ 小值的块的编号 $\mathbf{ans}$.

---

令 $\mathrm{tmpcnt}[v]$ 表示 $\mathcal{I}$ 中值在块 $\mathbf{ans}$ 中，值是 $v$ 的元素个数。注意 $v$ 的值只有 $O(\sqrt{m})$ 个。

$a[l..r]$ 中，值是 $v$ 的元素数量
$$
c(v) = \mathrm{tmpcnt}[v] + (\mathrm{cnt}[v][\mathbf{r}] -\mathrm{cnt}[v][\mathbf{l} - 1]).
$$
从小到大枚举 $\mathrm{ans}$ 直到总数超过 $k$, 得到第 $k$ 小值 $\mathrm{ans}$.

注意 $\mathrm{tmpblkcnt}[]$ 和 $\mathrm{tmpcnt}[]$ 的大小都是 $O(\sqrt{m})$.

至此，如果维护 $\mathrm{cnt}[][]$ 和 $\mathrm{blkcnt}[][]$, 可以 $O(\sqrt{m})$ 处理 $\mathrm{query}(l, r, k)$.

---

考虑 $\mathrm{change}(l, r, x, y)$.

如果 $\mathcal{I} = \emptyset$, 通过 $\mathrm{cnt}[v][\mathbf{i}] - \mathrm{cnt}[v][\mathbf{i} - 1]$ 得到块 $\mathbf{i}$ 中值为 $v$，可以更新 $\mathrm{cnt}[][]$ 和 $\mathrm{blkcnt}[][]$.

如果 $\mathcal{I} \neq \emptyset$, 需要得到$a[i]$ ($i \in \mathcal{I}$) 的当前值。

---

为此，对于块 $B$, 维护一个并查集：

- $\mathrm{parent}[i]$ 表示 $i$ 在并查集中的父亲，$\mathrm{parent}[i] = i$ 表示 $i$ 是并查集的根；

- $\mathrm{value}[i]$ 仅当 $\mathrm{parent}[i] = i$ 时有定义，表示这个集合当前的值。

另外，当 $\mathrm{parent}[i] = i$ 且 $\mathrm{value}[i] = v$ 时，$\mathrm{repr}[v] = i$.

---

当 $\mathrm{change}(\cdot, \cdot, x, y)$ 包含块 $B$ 时， 假设 $x \neq y$ 且值 $\mathrm{repr}[x] = i$ 存在，有两种情况：

- 值 $y$ 不存在，那么把 $\mathrm{value}[i]$ 设为 $y$, 同时把 $\mathrm{repr}[y]$ 设为 $i$.

- 值 $y$ 存在，那么把 $\mathrm{parent}[i]$ 设为 $\mathrm{repr}[y]$.

时间复杂度 $O(1)$.

当需要得到 $a[i]$ 的当前值时，把 $a[i]$ 设为 $\mathrm{value}[\mathrm{root}(i)]$. 时间复杂度 $O(\sqrt{n})$.


---

## 作者：fr200110217102 (赞：37)

调了五个小时终于调出来了……不愧是Ynoi毒瘤题

~~一个不保证不会被毒瘤数据卡掉的算法。~~

---

# 分块+分块+并查集

~~看到这么诡异的修改操作显然想到分块~~

## 区间第$k$大

先考虑一下分块做区间第$k$大

可以二分/树状数组，然而复杂度会变成$O(n\sqrt{n}logn)$，基本上是$TLE$无疑了。。。

换个角度，可以维护每个数在区间内出现了多少次。这个可以用一个二维的$sum$数组维护：$sum[i][j]=$前$i$块中$j$出现的次数。这样区间内一个数$x$出现的次数就是中间整块$sum$的两个前缀和相减，再加上两边散块的出现次数。散块的出现个数可以用临时数组记下来。

然而直接枚举第$k$大并按顺序把出现次数加上是$O(n^2)$的。。。

于是再对值域分块，$cnt[i][x]=$第$i$块中$x$出现的次数（用于后面修改操作），$sumc[i][x]=$前$i$块中$x$出现的次数，$sums[i][x]=$前$i$块中$(x-1)S+1$到$xS$出现的次数之和。这里$S$取$\sqrt{100000}$（约为$317$）即可。~~（分块套分块）~~

每次求区间第$k$大的时候先枚举在哪一块，再在块内枚举。枚举到某个数发现加起来出现次数大于$k$了答案就是它了。

~~（突发奇想）其实这个分块套分块好像再优化一些就变成了树状数组上二分？~~反正在这道题上没用。

假设$n$与值域同阶。这样询问的复杂度就是$O(n\sqrt{n})$了。

## 区间修改

值域$1e5$还没提醒你什么吗……

每一块用一个并查集把所有值相同的点缩在一起。每块再维护一个$rt[i][x]$，存第$i$块中某个值为$x$的数的位置。

### 整块修改

$x$变$y$时，如果有$x$，就$fa[rt[i][x]]=rt[i][y]$；否则$rt[i][y]=rt[i][x]$。然后更新该块及后面的块的$sumc$和$sums$。注意要把各个块的$cnt[i][x]$的和存下来实时更新，要不就变成$O(n^2)$了！

### 散块修改

由于并查集的树形结构，修改时不能遇到一个值为$x$的就直接链到$rt[i][y]$上，否则可能会导致下面本来不应修改的值也被链到$rt[i][y]$的子树中。

一个解决方法是强行规定$rt[i][x]$是块内最左边的值为$x$的数的位置，不过这样维护起来需要较多的分类讨论。

都已经在一个散块里了，为什么不暴力呢？直接重构啊！

当然把整个散块的并查集拆掉然后重构还是会$TLE$飞的。实测$20-50$分不等。

只重构$x$和$y$的两棵子树就即可。

复杂度还是$O(n\sqrt{n})$。

另外因为空间限制，块长取$\sqrt{n}$会直接$MLE$掉。所以可以取一个稍大一些的值（好像块长取$600$左右的时候最优）。

~~所以这个做法能会被值域只有$2$个数的数据卡掉？~~

代码

```cpp

//#define ice
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<bits/stdc++.h>
#define rint register int
using namespace std;
inline int read(){
	int res=0;char c=getchar(),f=1;
	while(c<48||c>57){if(c=='-')f=0;c=getchar();}
	while(c>=48&&c<=57)res=(res<<3)+(res<<1)+(c&15),c=getchar();
	return f?res:-res;
}

const int N=1e5+5,M=170,S=320;

int n,m,a[N],sz,vsz,mxv;
int k,L[M],R[M],bel[N];
int l,r,x,y,op,lb,rb;

int fa[N],rt[M][N];
inline int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int cnt[M][N],sumc[M][N],sums[M][S];

void build(int p){
	for(rint i=L[p];i<=R[p];++i){
		if(!rt[p][a[i]])rt[p][a[i]]=i;
		else fa[i]=rt[p][a[i]];
		++cnt[p][a[i]];
	}
}

int sta[N];
void update(int p,int l,int r,int x,int y){
	rint tmp=0,l0=L[p],r0=R[p],top=0;
	rt[p][x]=rt[p][y]=0;
	for(rint i=l0;i<=r0;++i){
		a[i]=a[find(i)];
		if(a[i]==x||a[i]==y)sta[++top]=i;
	}
	for(rint i=l;i<=r;++i)if(a[i]==x)a[i]=y,++tmp;
	for(rint i=1;i<=top;++i)fa[sta[i]]=sta[i];
	for(rint i=1,t,w;i<=top;++i){
		t=sta[i],w=a[t];
		if(!rt[p][w])rt[p][w]=t;
		else fa[t]=rt[p][w];
	}
	cnt[p][x]-=tmp,cnt[p][y]+=tmp;
	for(rint i=p;i<=k;++i){
		sumc[i][x]-=tmp,sumc[i][y]+=tmp;
		if(bel[x]!=bel[y])
			sums[i][bel[x]]-=tmp,sums[i][bel[y]]+=tmp;
	}
}

int c[N],s[S];
int main(){
#ifdef ice
	freopen("1.in","r",stdin);
	freopen("1.out","w",stdout);
#endif
	n=read(),m=read();
	sz=600,vsz=317,mxv=1e5;
	k=(n-1)/sz+1;
	for(rint i=1;i<=n;++i)a[i]=read(),fa[i]=i;
	for(rint i=1;i<=mxv;++i)bel[i]=(i-1)/vsz+1;
	for(rint i=1;i<=k;++i){
		L[i]=(i-1)*sz+1,R[i]=min(i*sz,n);
		build(i);
		for(rint j=1;j<=vsz;++j)
			sums[i][j]=sums[i-1][j];
		for(rint j=1;j<=mxv;++j)
			sumc[i][j]=sumc[i-1][j]+cnt[i][j];
		for(rint j=L[i];j<=R[i];++j)
			++sums[i][bel[a[j]]];
	}
	while(m--){
		op=read();
		if(op==1){
			l=read(),r=read(),x=read(),y=read();
			if(x==y)continue;
			lb=(l-1)/sz+1,rb=(r-1)/sz+1;
			if(lb==rb)update(lb,l,r,x,y);
			else{
				update(lb,l,R[lb],x,y);
				update(rb,L[rb],r,x,y);
				rint tmp,tmps=0;
				for(rint i=lb+1;i<rb;++i){
					if(rt[i][x]){
						if(!rt[i][y])rt[i][y]=rt[i][x],a[rt[i][x]]=y;
						else fa[rt[i][x]]=rt[i][y];
						rt[i][x]=0,tmp=cnt[i][x],tmps+=tmp,
						cnt[i][y]+=tmp,cnt[i][x]=0;
					}
					sumc[i][x]-=tmps,sumc[i][y]+=tmps;
					if(bel[x]!=bel[y])
						sums[i][bel[x]]-=tmps,sums[i][bel[y]]+=tmps;
				}
				for(rint i=rb;i<=k;++i){
					sumc[i][x]-=tmps,sumc[i][y]+=tmps;
					if(bel[x]!=bel[y])
						sums[i][bel[x]]-=tmps,sums[i][bel[y]]+=tmps;
				}
			}
		}else{
			l=read(),r=read(),x=read();
			lb=(l-1)/sz+1,rb=(r-1)/sz+1;
			if(lb==rb){
				for(rint i=l;i<=r;++i)
					a[i]=a[find(i)],++c[a[i]],++s[bel[a[i]]];
				rint vl,vr,tmp=0;
				for(rint i=1;i<=vsz;++i){
					tmp+=s[i];
					if(tmp>=x){tmp-=s[i],vl=(i-1)*vsz+1,vr=i*vsz;break;}
				}
				for(rint i=vl;i<=vr;++i){
					tmp+=c[i];
					if(tmp>=x){printf("%d\n",i);break;}
				}
				for(rint i=l;i<=r;++i)
					--c[a[i]],--s[bel[a[i]]];
			}
			else{
				for(rint i=l;i<=R[lb];++i){
					a[i]=a[find(i)];
					++c[a[i]],++s[bel[a[i]]];
				}
				for(rint i=L[rb];i<=r;++i){
					a[i]=a[find(i)];
					++c[a[i]],++s[bel[a[i]]];
				}
				rint vl,vr,tmp=0;
				for(rint i=1;i<=vsz;++i){
					tmp+=s[i]+sums[rb-1][i]-sums[lb][i];
					if(tmp>=x){tmp-=s[i]+sums[rb-1][i]-sums[lb][i],vl=(i-1)*vsz+1,vr=i*vsz;break;}
				}
				for(rint i=vl;i<=vr;++i){
					tmp+=c[i]+sumc[rb-1][i]-sumc[lb][i];
					if(tmp>=x){printf("%d\n",i);break;}
				}
				for(rint i=l;i<=R[lb];++i)
					--c[a[i]],--s[bel[a[i]]];
				for(rint i=L[rb];i<=r;++i)
					--c[a[i]],--s[bel[a[i]]];
			}
		}
	}return 0;
}

```


---

## 作者：Demoe (赞：18)

### [题目传送门](https://www.luogu.com.cn/problem/P4119)

~~2020 的遗愿~~

## 题意

- 给定一个序列，支持区间替换和区间 $\text{kth}$ 操作。

## Sol

~~因为是最初分块所以考虑序列分块。（~~

一般情况我们查询区间 $\text{kth}$ 都是树套树啥的。

带上二分，线段树套平衡树是 $\log^3 n$ 的。

我们这里也考虑树套树（？

~~好像想不出来咋整~~

这个修改对于树状结构很不方便。

那么我们考虑序列分块和值域分块。

首先预处理 $cnt1_{i,j}$ 表示前 $i$ 块中值域在第 $j$ 块的数出现次数，$cnt2_{i,j}$ 表示前 $i$ 块中 $j$ 出现次数 。

预处理 $O(n\sqrt n)$

那么查询 $\text{kth}$ 就很方便了。

整块用 $cnt1$ 和 $cnt2$ 处理，散块开个桶记一下即可。

从小到大先扫值域块 找到目标后再扫值即可。

复杂度 $O(\sqrt n)$

```cpp
inline int kth(int l,int r,int k){
	int sum=0;
	if(bl[l]==bl[r]){
		restore(bl[l]);
		for(re i=l;i<=r;++i) sum2[i]=a[i];
		nth_element(sum2+l,sum2+l+k-1,sum2+r+1);int ans=sum2[l+k-1];
		for(re i=l;i<=r;++i) sum2[i]=0;
		return ans;
	}
	restore(bl[l]);restore(bl[r]);
	for(re i=l;i<=R[bl[l]];++i) ++sum1[bl[a[i]]],++sum2[a[i]];
	for(re i=L[bl[r]];i<=r;++i) ++sum1[bl[a[i]]],++sum2[a[i]];
	for(re i=1;i<=(N-1)/len+1;++i)
		if(sum+sum1[i]+cnt1[bl[r]-1][i]-cnt1[bl[l]][i]>=k){
			for(re j=(i-1)*len+1;j<=i*len;++j)
				if(sum+sum2[j]+cnt2[bl[r]-1][j]-cnt2[bl[l]][j]>=k){
					for(re i=l;i<=R[bl[l]];++i) --sum1[bl[a[i]]],--sum2[a[i]];
					for(re i=L[bl[r]];i<=r;++i) --sum1[bl[a[i]]],--sum2[a[i]]=0;
					return j;
				}
				else sum+=sum2[j]+cnt2[bl[r]-1][j]-cnt2[bl[l]][j];
		}
		else sum+=sum1[i]+cnt1[bl[r]-1][i]-cnt1[bl[l]][i];
}
```

---

考虑区间替换。

散块暴力修即可。

对于每个整块，考虑一下咋整。

~~我不太会 参考了神仙题解~~

考虑对块内每个权记一个对应权，记做 $id_{x,i}$ （$x$ 是块，$i$ 是原权）

同时其逆也记下，记做 $rid_{x,i}$（$x$ 是块，$i$ 是对应权）

再用 $pos_i$ 记录每一位的对应权。（$i$ 是序列上位置）

如果要还原序列，只需要让 $a_i=rid_{block_i,pos_i}$。

### 块内无 $x$

跳过

### 块内有 $x$ 无 $y$

可将 $id_{block,y}=id_{block,x}$ 同时 $rid_{block,id_{block,x}}=y$，记得 $id_{block,x}=0$

### 块内有 $x$ $y$

考虑此时块内权值种类少 $1$。

而权值种类总共不超过 $n+m$。

均摊后暴力重构复杂度总和为 $O((n+m)\sqrt n)$。

暴力重构即可。

对于两个 $cnt$ 数组的更新，可以先将其差分为每块的，最后再合并。一次 $O(\sqrt n)$。

```cpp
inline void modify(int l,int r,int x,int y){
	if(x==y||cnt2[bl[r]][x]-cnt2[bl[l]-1][x]==0) return ;
	for(re i=bl[n];i>=bl[l];--i) cnt2[i][x]-=cnt2[i-1][x],cnt2[i][y]-=cnt2[i-1][y],cnt1[i][bl[x]]-=cnt1[i-1][bl[x]],cnt1[i][bl[y]]-=cnt1[i-1][bl[y]];
	if(bl[l]==bl[r]){
		restore(bl[l]);
		reconstruct(l,r,x,y);
		build(bl[l]);
		for(re i=bl[l];i<=bl[n];++i) cnt2[i][x]+=cnt2[i-1][x],cnt2[i][y]+=cnt2[i-1][y],cnt1[i][bl[x]]+=cnt1[i-1][bl[x]],cnt1[i][bl[y]]+=cnt1[i-1][bl[y]];
		return ;
	}
	restore(bl[l]);restore(bl[r]);
	reconstruct(l,R[bl[l]],x,y);reconstruct(L[bl[r]],r,x,y);
	build(bl[l]);build(bl[r]);
	for(re i=bl[l]+1;i<bl[r];++i){
		if(!cnt2[i][x]) continue;
		if(cnt2[i][y]){
			restore(i);
			reconstruct(L[i],R[i],x,y);
			build(i);
		}
		else{
			cnt1[i][bl[y]]+=cnt2[i][x],cnt1[i][bl[x]]-=cnt2[i][x];
			cnt2[i][y]=cnt2[i][x];cnt2[i][x]=0;
			change(i,x,y);
		}
	}
	for(re i=bl[l];i<=bl[n];++i) cnt2[i][x]+=cnt2[i-1][x],cnt2[i][y]+=cnt2[i-1][y],cnt1[i][bl[x]]+=cnt1[i-1][bl[x]],cnt1[i][bl[y]]+=cnt1[i-1][bl[y]];
}
```

总复杂度 $(n+m)\sqrt n$。

### $\text{Code}$

```cpp
// wish to get better qwq

#include<bits/stdc++.h>
#define re register int
#define pb push_back

using namespace std;
typedef long long ll;

template <typename T> void rd(T &x){
	int fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(int x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}

// ---------- IO ---------- //

const int N=1e5+20,SQ=320;
int n,m,a[N],len,bl[N],L[N],R[N],sum1[SQ],sum2[N];
int id[SQ][N],rid[SQ][N],pos[N];  // id[i][j] 第 i 块中 j 离散化值 rid[i][j] 为 id 的逆运算 

int cnt1[SQ][SQ],cnt2[SQ][N];  // cnt1[i][j] 前 i 块中值域在第 j 块的数出现次数 cnt2[i][j] 前 i 块中 j 出现次数 

inline void build(int x){
	int tot=0;
	for(re i=1;i<=len;++i) id[x][rid[x][i]]=0;
	for(re i=L[x];i<=R[x];++i)
		if(!id[x][a[i]]) id[x][a[i]]=++tot,rid[x][tot]=a[i];
	for(re i=L[x];i<=R[x];++i) pos[i]=id[x][a[i]];
}

inline void restore(int x){
	for(re i=L[x];i<=R[x];++i) a[i]=rid[x][pos[i]];
}

inline void reconstruct(int l,int r,int x,int y){
	for(re i=l;i<=r;++i)
		if(a[i]==x){
			--cnt2[bl[l]][x],++cnt2[bl[l]][y];
			--cnt1[bl[l]][bl[x]],++cnt1[bl[l]][bl[y]];
			a[i]=y;
		}
}

inline void change(int i,int x,int y){
	id[i][y]=id[i][x];rid[i][id[i][x]]=y;id[i][x]=0;
}

// ---------- Sqrt On Range ---------- //

inline void modify(int l,int r,int x,int y){
	if(x==y||cnt2[bl[r]][x]-cnt2[bl[l]-1][x]==0) return ;
	for(re i=bl[n];i>=bl[l];--i) cnt2[i][x]-=cnt2[i-1][x],cnt2[i][y]-=cnt2[i-1][y],cnt1[i][bl[x]]-=cnt1[i-1][bl[x]],cnt1[i][bl[y]]-=cnt1[i-1][bl[y]];
	if(bl[l]==bl[r]){
		restore(bl[l]);
		reconstruct(l,r,x,y);
		build(bl[l]);
		for(re i=bl[l];i<=bl[n];++i) cnt2[i][x]+=cnt2[i-1][x],cnt2[i][y]+=cnt2[i-1][y],cnt1[i][bl[x]]+=cnt1[i-1][bl[x]],cnt1[i][bl[y]]+=cnt1[i-1][bl[y]];
		return ;
	}
	restore(bl[l]);restore(bl[r]);
	reconstruct(l,R[bl[l]],x,y);reconstruct(L[bl[r]],r,x,y);
	build(bl[l]);build(bl[r]);
	for(re i=bl[l]+1;i<bl[r];++i){
		if(!cnt2[i][x]) continue;
		if(cnt2[i][y]){
			restore(i);
			reconstruct(L[i],R[i],x,y);
			build(i);
		}
		else{
			cnt1[i][bl[y]]+=cnt2[i][x],cnt1[i][bl[x]]-=cnt2[i][x];
			cnt2[i][y]=cnt2[i][x];cnt2[i][x]=0;
			change(i,x,y);
		}
	}
	for(re i=bl[l];i<=bl[n];++i) cnt2[i][x]+=cnt2[i-1][x],cnt2[i][y]+=cnt2[i-1][y],cnt1[i][bl[x]]+=cnt1[i-1][bl[x]],cnt1[i][bl[y]]+=cnt1[i-1][bl[y]];
}

inline int kth(int l,int r,int k){
	int sum=0;
	if(bl[l]==bl[r]){
		restore(bl[l]);
		for(re i=l;i<=r;++i) sum2[i]=a[i];
		nth_element(sum2+l,sum2+l+k-1,sum2+r+1);int ans=sum2[l+k-1];
		for(re i=l;i<=r;++i) sum2[i]=0;
		return ans;
	}
	restore(bl[l]);restore(bl[r]);
	for(re i=l;i<=R[bl[l]];++i) ++sum1[bl[a[i]]],++sum2[a[i]];
	for(re i=L[bl[r]];i<=r;++i) ++sum1[bl[a[i]]],++sum2[a[i]];
	for(re i=1;i<=(N-1)/len+1;++i)
		if(sum+sum1[i]+cnt1[bl[r]-1][i]-cnt1[bl[l]][i]>=k){
			for(re j=(i-1)*len+1;j<=i*len;++j)
				if(sum+sum2[j]+cnt2[bl[r]-1][j]-cnt2[bl[l]][j]>=k){
					for(re i=l;i<=R[bl[l]];++i) --sum1[bl[a[i]]],--sum2[a[i]];
					for(re i=L[bl[r]];i<=r;++i) --sum1[bl[a[i]]],--sum2[a[i]]=0;
					return j;
				}
				else sum+=sum2[j]+cnt2[bl[r]-1][j]-cnt2[bl[l]][j];
		}
		else sum+=sum1[i]+cnt1[bl[r]-1][i]-cnt1[bl[l]][i];
}

// ---------- Sqrt ---------- //

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(m);len=(int)sqrt(n);
	for(re i=1;i<N;++i) bl[i]=(i-1)/len+1;
	for(re i=1;i<=n;++i) rd(a[i]);
	for(re i=1;i<=bl[n];++i) L[i]=(i-1)*len+1,R[i]=i*len;R[bl[n]]=n;
	for(re i=1;i<=bl[n];++i) build(i);
	for(re x=1;x<=bl[n];++x){
		for(re i=1;i<=bl[N-1];++i) cnt1[x][i]=cnt1[x-1][i];
		for(re i=1;i<N;++i) cnt2[x][i]=cnt2[x-1][i];
		for(re i=L[x];i<=R[x];++i) ++cnt1[x][bl[a[i]]],++cnt2[x][a[i]];
	}
	int op,l,r,x,y;
	for(re i=1;i<=m;++i){
		rd(op);rd(l);rd(r);
		if(op==1) rd(x),rd(y),modify(l,r,x,y);
		else rd(x),wr(kth(l,r,x)),puts("");
	}
	return 0;
}

// ---------- Main ---------- //
```

---

## 作者：Michael_Bryant (赞：16)

# 推一发我的博客
[传送门](https://lfd2002.com/archives/612)

一道神题

我们用分块的思想
对权值和序列都分块，假设n和值域同阶记b[i][j]表示前i块，权值在第j块的有几个记c[i][j]表示前i块，权值为j的有几个

然后查询就暴力查询


修改的话两边的暴力重构

中间的只针对x，y这两个值修改b数组c数组的值

出现的话我们编号

消失了的话我们附成0

然后可以用一个反向数组存一下反id

就是说一个数的id是什么

然后这个带着修改

每次修改的时候根据这个id来修改会更快

```cpp

#include<bits/stdc++.h>
using namespace std;
#define N 100100
#define BLK 320
#define LK(x) ((x)*kuai)
#define RK(x) min(((x)+1)*kuai,n)
inline char nc()
{
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    char ch=nc();int sum=0,w=1;
    while(!(ch>='0'&&ch<='9')) {if(ch=='-') w=-1;ch=nc();}
    while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();
    return sum*w;
}
int n,m,b[BLK][1000],h[BLK][N],fh[BLK][1000],ls[N],ls2[2000],c[N],kuai,a[N],mkuai,cnt[BLK][N];
int Q,_m;
inline void pd(int id)
{
    int l=LK(id),r=RK(id);
    for(int i=l;i<r;i++)
    {
        a[i]=fh[id][c[i]];
    }
}
inline void change(int bl,int x,int y)
{
    int id=h[bl][x];
    h[bl][y]=id;
    fh[bl][id]=y;
    h[bl][x]=0;
}
inline void build(int id)
{
    int tp=0;
    int l=LK(id),r=RK(id);
    for(int i=1;i<=kuai;i++)
    {
        h[id][fh[id][i]]=0;
    }
    for(int i=l;i<r;i++)
    {
        if(!h[id][a[i]])
        {
            h[id][a[i]]=++tp;
            fh[id][tp]=a[i];
        }
    }
    for(int i=l;i<r;i++)
    {
        c[i]=h[id][a[i]];
    }
}
int main()
{
    int MAXN=100100;
    n=read(),Q=read();
    kuai=mkuai=500;
    m=n/kuai+1,_m=MAXN/mkuai+1;
    for(int i=0;i<n;i++)
    {
        a[i]=read();
    }
    for(int i=0;i<m;i++)
    {
        for(int j=LK(i),tp=0;j<RK(i);j++)
        {
            if(!h[i][a[j]])
            {
                h[i][a[j]]=++tp;
                fh[i][tp]=a[j];
            }
        }
        for(int j=LK(i);j<RK(i);j++)
        {
            c[j]=h[i][a[j]];
        }
    }
    for(int i=0;i<m;i++)
    {
        if(i)
        {
            for(int j=0;j<MAXN;j++)
            {
                cnt[i][j]=cnt[i-1][j];
            }
        }
        if(i)
        {
            for(int j=0;j<_m;j++)
            {
                b[i][j]=b[i-1][j];
            }
        }
        for(int j=LK(i);j<RK(i);j++)
        {
            cnt[i][a[j]]++;
            b[i][a[j]/mkuai]++;
        }
    }
    for(int ni=1,op,l,r,x,y;ni<=Q;++ni)
    {
        op=read(),l=read(),r=read();
        l--,r--;
        if(op==1)
        {
            x=read(),y=read();
            int bl=l/kuai,br=r/kuai;
            int bx=x/mkuai,by=y/mkuai;
            if(cnt[br][x]-(bl?cnt[bl-1][x]:0)==0)
            {
                continue;
            }
            for(int i=m-1;i>=1&&i>=bl;--i)
            {
                cnt[i][x]-=cnt[i-1][x],
                cnt[i][y]-=cnt[i-1][y],
                b[i][bx]-=b[i-1][bx],
                b[i][by]-=b[i-1][by];
            }
            if(bl==br)
            {
                pd(bl);
                for(int i=l;i<=r;++i)
                {
                    if(a[i]==x)
                    {
                        a[i]=y,
                        cnt[bl][x]--,
                        cnt[bl][y]++,
                        b[bl][bx]--,
                        b[bl][by]++;
                    }
                }
                build(bl);
            }
            else
            {
                pd(bl),pd(br);
                for(int i=l;i<RK(bl);++i)
                {
                    if(a[i]==x)
                    {
                        a[i]=y,
                        cnt[bl][x]--,
                        cnt[bl][y]++,
                        b[bl][bx]--,
                        b[bl][by]++;
                    }
                }
                for(int i=LK(br);i<=r;++i)
                {
                    if(a[i]==x)
                    {
                        a[i]=y,
                        cnt[br][x]--,
                        cnt[br][y]++,
                        b[br][bx]--,
                        b[br][by]++;
                    }
                }
                build(bl),build(br);
                for(int i=bl+1;i<br;++i)if(cnt[i][x])
                {
                    if(cnt[i][y])
                    {
                        pd(i);
                        for(int j=LK(i);j<RK(i);++j)
                        {
                            if(a[j]==x)
                            {
                                a[j]=y,
                                cnt[i][x]--,
                                cnt[i][y]++,
                                b[i][bx]--,
                                b[i][by]++;
                            }
                        }
                        build(i);
                    }
                    else
                    {
                        b[i][by]+=cnt[i][x];
                        b[i][bx]-=cnt[i][x];
                        cnt[i][y]+=cnt[i][x],cnt[i][x]=0;
                        change(i,x,y);
                    }
                }
            }
            for(int i=max(1,bl);i<m;++i)
            {
                cnt[i][x]+=cnt[i-1][x],
                cnt[i][y]+=cnt[i-1][y],
                b[i][bx]+=b[i-1][bx],
                b[i][by]+=b[i-1][by];
            }
        }
        else
        {
            x=read();
            int bl=l/kuai,br=r/kuai;
            if(bl==br)
            {
                pd(bl);
                for(int i=l;i<=r;++i)
                {
                    ls[i]=a[i];
                }
                nth_element(ls+l,ls+l+x-1,ls+r+1);
                printf("%d\n",ls[l+x-1]);
                for(int i=l;i<=r;++i)
                {
                    ls[i]=0;
                }
            }
            else
            {
                pd(bl),pd(br);
                for(int i=l;i<RK(bl);++i)
                {
                    ls[a[i]]++,
                    ls2[a[i]/mkuai]++;
                }
                for(int i=LK(br);i<=r;++i)
                {
                    ls[a[i]]++,
                    ls2[a[i]/mkuai]++;
                }
                for(int i=0,sum=0;i<_m;++i)
                {
                    if(ls2[i]+b[br-1][i]-b[bl][i]+sum>=x)
                    {
                        for(int j=i*mkuai;j<(i+1)*mkuai;++j)
                        {
                            if(ls[j]+cnt[br-1][j]-cnt[bl][j]+sum>=x)
                            {
                                printf("%d\n",j);
                                goto lxldl;
                            }
                            else
                            {
                                sum+=ls[j]+cnt[br-1][j]-cnt[bl][j];
                            }
                        }
                    }
                    else
                    {
                        sum+=ls2[i]+b[br-1][i]-b[bl][i];
                    }
                }
                lxldl:
                for(int i=l;i<RK(bl);++i)
                {
                    ls[a[i]]--,
                    ls2[a[i]/mkuai]--;
                }
                for(int i=LK(br);i<=r;++i)
                {
                    ls[a[i]]--,
                    ls2[a[i]/mkuai]--;
                }
            }
        }
    }
    return 0;
}


```

---

## 作者：kymru (赞：14)

[更好的阅读体验](https://www.cnblogs.com/lingspace/p/p4119.html)

# 题意

[P4119 [Ynoi2018] 未来日记](https://www.luogu.com.cn/problem/P4119)

给定一个长度为 $n$ 的序列和 $m$ 个操作，每次操作可以：

1. 将 $[l, r]$ 内的所有值 $x$ 改为值 $y$

2. 查询 $[l, r]$ 内第 $k$ 小的值

相同的值算多次。

$1 \leq n, m, a_i \leq 10^5$

# 思路

最初分块。

分块 + 值域分块 + 并查集。

显然思路是二分套树状数组求静态 $k$ 小值，但是复杂度不对。

考虑用值域分块代替二分。

将值域 $[1, 10^5]$ 分成 $\sqrt{10^5}$ 块。

令 $sum1_{i, j}$ 表示前 $i$ 个块内，在第 $j$ 个值域块内的值的个数，$sum2_{i, j}$ 表示前 $i$ 个块内值 $j$ 的个数。这两个数组可以 $\mathcal{O}(n \sqrt{n})$ 预处理。

询问散块直接暴力 `nth_element`

询问 $[l, r]$ 时另外处理 $cnt1_{i}$ 表示散块内在第 $i$ 个值域块内的值的个数，$cnt2_{i}$ 表示散块内值 $i$ 的个数。当块长取 $\sqrt{n}$ 时，处理这两个数组复杂度是 $\mathcal{O}(\sqrt{n})$

假设询问第 $k$ 小。

首先确定第 $k$ 小值所处的值域块。具体实现可以令 $sum$ 初始为 $0$，枚举值域块 $i$ 时令 $sum$ 不断累加 $[l, r]$ 内第 $i$ 个值域块内的值的个数（用上面处理的数组 $\mathcal{O}(1)$ 求），当 $sum \geq k$ 时说明第 $k$ 小值在第 $i$ 个值域块内。枚举值域块复杂度是 $\mathcal{O}(\sqrt{n})$

然后枚举值域块内的值，用类似上面的方法求出第 $k$ 小值。复杂度也是 $\mathcal{O}(\sqrt{n})$

类似于 [P4117 [Ynoi2018] 五彩斑斓的世界](https://www.luogu.com.cn/problem/P4117)，维护 $rt_{i, j}, val_{i, j}, pos_i$。$rt_{i, j} = k$ 表示 $k$ 是第 $i$ 个块内值 $j$ 对应并查集的根，$val_{i, j} = k$ 表示第 $i$ 个块内根 $j$ 对应的值为 $k$。令 $bel_i$ 表示下标 $i$ 所属的块的编号，则 `pos[i] = rt[ bel[i] ][ a[i] ]`

小优化，并查集的根编号不必用数组下标。

$a_i$ 的真实值为 `val[ bel[i] ][ pos[i] ]`，还原序列直接用。

直接修改很难，不妨先用 $sum1$ 和 $sum2$ 差分出每块内的答案，对每块答案单独维护，最后再前缀和合并。显然不影响复杂度。

散块直接暴力修改重构即可，复杂度是 $\mathcal{O}(\sqrt{n})$

修改整块 $i$ 可以分成三种情况：

+ 块 $i$ 内无 $x$，跳过；

+ 块 $i$ 内有 $x$ 无 $y$，令 `rt[i][y] = rt[i][x], val[i][ rt[i][x] ] = y, rt[i][x] = 0`，相应修改 $sum1$ 和 $sum2$

+ 块 $i$ 内有 $x$ 有 $y$。显然序列中出现过的不同值个数最多为 $n + m$，这种情况下每次块内值的个数会减少 $1$，暴力重构均摊总复杂度是 $\mathcal{O}((n + m)\sqrt{n})$，直接暴力即可

时间复杂度 $\mathcal{O}((n + m) \sqrt{n})$

# 代码

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

const int maxn = 1e5 + 5;
const int maxk = 320;

int n, m;
int block, tot;
int st[maxk], ed[maxk];
int a[maxn], bel[maxn];
int cnt1[maxk], sum1[maxk][maxk];
int cnt2[maxn], sum2[maxk][maxn];
int rt[maxk][maxn], val[maxk][maxn], pos[maxn];

void reduce(int idx) {
	for (int i = st[idx]; i <= ed[idx]; i++) {
		a[i] = val[idx][pos[i]];
	}
}

void build(int idx) {
	int cur = 0;
	for (int i = 1; i <= block; i++) {
		rt[idx][val[idx][i]] = 0;
	}
	for (int i = st[idx]; i <= ed[idx]; i++) {
		if (!rt[idx][a[i]]) {
			cur++;
			rt[idx][a[i]] = cur;
			val[idx][cur] = a[i];
		}
		pos[i] = rt[idx][a[i]];
	}
}

void modify(int l, int r, int x, int y) {
	for (int i = l; i <= r; i++) {
		if (a[i] == x) {
			sum1[bel[i]][bel[x]]--;
			sum1[bel[i]][bel[y]]++;
			sum2[bel[i]][x]--;
			sum2[bel[i]][y]++;
			a[i] = y;
		}
	}
}

void merge(int idx, int x, int y) {
	rt[idx][y] = rt[idx][x];
	val[idx][rt[idx][x]] = y;
	rt[idx][x] = 0;
}

void update(int l, int r, int x, int y) {
	if ((x == y) || (sum2[bel[r]][x] - sum2[bel[l] - 1][x] == 0)) {
		return;
	}
	for (int i = bel[n]; i >= bel[l]; i--) {
		sum1[i][bel[x]] -= sum1[i - 1][bel[x]];
		sum1[i][bel[y]] -= sum1[i - 1][bel[y]];
		sum2[i][x] -= sum2[i - 1][x];
		sum2[i][y] -= sum2[i - 1][y];
	}
	if (bel[l] == bel[r]) {
		reduce(bel[l]);
		modify(l, r, x, y);
		build(bel[l]);
		for (int i = bel[l]; i <= bel[n]; i++) {
			sum1[i][bel[x]] += sum1[i - 1][bel[x]];
			sum1[i][bel[y]] += sum1[i - 1][bel[y]];
			sum2[i][x] += sum2[i - 1][x];
			sum2[i][y] += sum2[i - 1][y];
		}
	} else {
		reduce(bel[l]);
		modify(l, ed[bel[l]], x, y);
		build(bel[l]);
		reduce(bel[r]);
		modify(st[bel[r]], r, x, y);
		build(bel[r]);
		for (int i = bel[l] + 1; i < bel[r]; i++) {
			if (!sum2[i][x]) {
				continue;
			} else if (sum2[i][y]) {
				reduce(i);
				modify(st[i], ed[i], x, y);
				build(i);
			} else {
				sum1[i][bel[y]] += sum2[i][x];
				sum1[i][bel[x]] -= sum2[i][x];
				sum2[i][y] += sum2[i][x];
				sum2[i][x] = 0;
				merge(i, x, y);
			}
		}
		for (int i = bel[l]; i <= bel[n]; i++) {
			sum1[i][bel[x]] += sum1[i - 1][bel[x]];
			sum1[i][bel[y]] += sum1[i - 1][bel[y]];
			sum2[i][x] += sum2[i - 1][x];
			sum2[i][y] += sum2[i - 1][y];
		}
	}
}

int query(int l, int r, int k) {
	int ans, sum = 0;
	if (bel[l] == bel[r]) {
		reduce(bel[l]);
		for (int i = l; i <= r; i++) {
			cnt2[i] = a[i];
		}
		nth_element(cnt2 + l, cnt2 + l + k - 1, cnt2 + r + 1);
		ans = cnt2[l + k - 1];
		for (int i = l; i <= r; i++) {
			cnt2[i] = 0;
		}
		return ans;
	}
	reduce(bel[l]);
	for (int i = l; i <= ed[bel[l]]; i++) {
		cnt1[bel[a[i]]]++;
		cnt2[a[i]]++;
	}
	reduce(bel[r]);
	for (int i = st[bel[r]]; i <= r; i++) {
		cnt1[bel[a[i]]]++;
		cnt2[a[i]]++;
	}
	for (int i = 1; i <= bel[100000]; i++) {
		if ((sum + cnt1[i] + sum1[bel[r] - 1][i] - sum1[bel[l]][i]) >= k) {
			for (int j = (i - 1) * block + 1; j <= i * block; j++) {
				if ((sum + cnt2[j] + sum2[bel[r] - 1][j] - sum2[bel[l]][j]) >= k) {
					for (int k = l; k <= ed[bel[l]]; k++) {
						cnt1[bel[a[k]]]--;
						cnt2[a[k]]--;
					}
					for (int k = st[bel[r]]; k <= r; k++) {
						cnt1[bel[a[k]]]--;
						cnt2[a[k]]--;
					}
					return j;
				} else {
					sum += (cnt2[j] + sum2[bel[r] - 1][j] - sum2[bel[l]][j]);
				}
			}
		} else {
			sum += (cnt1[i] + sum1[bel[r] - 1][i] - sum1[bel[l]][i]);
		}
	}
}

int main() {
	int opt, l, r, x, y, k;
	scanf("%d%d", &n, &m);
	block = sqrt(n);
	tot = ceil(n * 1.0 / block);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	for (int i = 1; i < maxn; i++) {
		bel[i] = (i - 1) / block + 1;
	}
	for (int i = 1; i <= tot; i++) {
		st[i] = (i - 1) * block + 1;
		ed[i] = i * block;
	}
	ed[tot] = n;
	for (int i = 1; i <= tot; i++) {
		build(i);
	}
	for (int i = 1; i <= tot; i++) {
		for (int j = 1; j < maxk; j++) {
			sum1[i][j] = sum1[i - 1][j];
		}
		for (int j = 1; j < maxn; j++) {
			sum2[i][j] = sum2[i - 1][j];
		}
		for (int j = st[i]; j <= ed[i]; j++) {
			sum1[i][bel[a[j]]]++;
			sum2[i][a[j]]++;
		}
	}
	for (int i = 1; i <= m; i++) {
		scanf("%d", &opt);
		if (opt == 1) {
			scanf("%d%d%d%d", &l, &r, &x, &y);
			update(l, r, x, y);
		} else {
			scanf("%d%d%d", &l, &r, &k);
			printf("%d\n", query(l, r, k));
		}
	}
	return 0;
}
```

---

## 作者：Others (赞：7)

~~毒瘤的~~第一分块，反正我调了整整一周（是我太逊了）。

[我的黑历史](https://www.luogu.com.cn/blogAdmin/article/edit/407405)

这题的操作非常明显：并查集或值域分块（至于为什么不是权值线段树：~~看看出题人的名字~~）。

先看第一个操作：看上去只需要一个序列分块套值域分块，但是你发现不能只搞值域，原数组也要修改，但已经有 $\sqrt n$ 个块了，所以我们得 $O(1)$ 修改，于是就很自然的想到并查集（~~因为我是做完第二分块再来做这题的~~），散块拆散重构，整块修改并查集和值域分块。

再看第二个操作：区间 kth，看起来像主席树~~虽然我不会~~。但是我们既然选择了分块就要坚持到底。显然是值域上的 $O(\sqrt n)$ 的处理，散块可以直接提前统计（也要个简单的值域分块），整块的我们要 $O(1)$ 处理出一个值域块内的数的数量，~~好像没有黑科技可以做到 $O(\sqrt n)$ 以内的预处理，也可能是我孤陋寡闻。~~，所以这里需要对整块的值域做一个前缀和。

因为散块的询问是直接暴力统计的，所以块内不用前缀和，这样的背景下修改也只修改整块的值域，也就是 $O(\sqrt n)$ 的复杂度。

既然是大分块，那少不了**卡常**。

- inline ~~register~~ 整起来。
- 块长得开小，因为 $O(nB)$ 的空间需要塞进 $512MB$ 里（这样也可以迎合出题人的代码）。
- 细节能压缩就压缩。
- 能遍历初始化的别用 memset。e.g：查询是散块的预处理······

**Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
void qr(int &x){
	int f=x=0;
	char c=getchar();
	while(!isdigit(c)) f|=(c=='-'),c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	x=f?~(x-1):x;
}
const int N=100005,Sn=205;
int rt[Sn][N],fa[N],a[N],cnt[N],ccnt[Sn],n,m,s,bls,L[Sn],R[Sn],Ls[Sn],Rs[Sn],blss,ss,idx[N],idxx[N],Maxa,numc[Sn][N],nums[Sn][Sn],opt,l,r,x,y,temp;
inline void merge(int p,int x,int y){
	if(x==y) return ;
	if(rt[p][x]==0) return;
	if(rt[p][y]) fa[rt[p][x]]=rt[p][y];
	else a[rt[p][x]]=y,rt[p][y]=rt[p][x];
	rt[p][x]=0;
}
int get(int x){
	return fa[x]==x?x:fa[x]=get(fa[x]);
}
inline void update(int bl,int l,int r,int x,int y){
	rt[bl][x]=rt[bl][y]=temp=0;
	for(int i=L[bl];i<=R[bl];i++) {
		a[i]=a[get(i)];
	}
	for(int i=l;i<=r;i++){
		if(a[i]==x) a[i]=y,++temp;
	}
	for(int i=L[bl];i<=R[bl];i++){
		if(!rt[bl][a[i]]) rt[bl][a[i]]=i;
		fa[i]=rt[bl][a[i]];
	}
	for(int i=bl;i<=bls;i++) numc[i][x]-=temp,numc[i][y]+=temp,nums[i][idxx[x]]-=temp,nums[i][idxx[y]]+=temp;
	return ;
}
int main() {
	qr(n),qr(m);
	s=600,bls=(n+s-1)/s;
	for(int i=1;i<=bls;i++){
		L[i]=R[i-1]+1,R[i]=min(s*i,n);
		for(int j=L[i];j<=R[i];j++) idx[j]=i;
	} 
	Maxa=1e5;
	for(int i=1;i<=n;i++){
		qr(a[i]);
	}
	ss=600,blss=(1e5+ss-1)/ss;
	for(int i=1;i<=blss;i++){
		Ls[i]=Rs[i-1]+1,Rs[i]=min(ss*i,100000);
		for(int j=Ls[i];j<=Rs[i];j++) idxx[j]=i;
	} 
	for(int i=1;i<=bls;i++){
		for(int j=L[i];j<=R[i];j++){
			if(rt[i][a[j]]==0) rt[i][a[j]]=j;
			fa[j]=rt[i][a[j]];
			for(int k=i;k<=bls;k++) ++numc[k][a[j]],++nums[k][idxx[a[j]]];
		}
	}
	for(int zqw=1;zqw<=m;zqw++){
		qr(opt);
		if(opt==1){
			qr(l),qr(r),qr(x),qr(y);
			int lb=idx[l],rb=idx[r];
			if(lb==rb){
				update(lb,l,r,x,y);
				continue;
			}
			++lb,--rb;
			temp=numc[rb][x]-numc[lb-1][x];
			for(int i=lb;i<=rb;i++) {
				merge(i,x,y);
				int tmp=numc[i][x]-numc[lb-1][x];
				nums[i][idxx[y]]+=tmp;
				nums[i][idxx[x]]-=tmp;
				numc[i][y]+=tmp;
				numc[i][x]-=tmp;
			}
			for(int i=rb+1;i<=bls;i++) numc[i][x]-=temp,nums[i][idxx[x]]-=temp,numc[i][y]+=temp,nums[i][idxx[y]]+=temp;
			++rb,--lb;
			update(lb,l,R[lb],x,y);
			update(rb,L[rb],r,x,y);
		}else{
			qr(l),qr(r),qr(x);
			int lb=idx[l],rb=idx[r];
			if(lb==rb){
				for(int i=l;i<=r;i++) a[i]=a[get(i)],cnt[a[i]]++,ccnt[idxx[a[i]]]++;
				for(int i=1;i<=blss;i++) {
					if(x>ccnt[i]) x-=ccnt[i]; 
					else {
						for(int j=Ls[i];j<=Rs[i];j++){
							if(x>cnt[j]) x-=cnt[j];
							else {
								printf("%d\n",j);
								break;
							}
						}
						break;
					}
				}
				for(int i=l;i<=r;i++) cnt[a[i]]=ccnt[idxx[a[i]]]=0;
				continue;
			}
			++lb,--rb;
			for(int i=l;i<L[lb];i++) a[i]=a[get(i)],++cnt[a[i]],++ccnt[idxx[a[i]]];
			for(int i=R[rb]+1;i<=r;i++) a[i]=a[get(i)],++cnt[a[i]],++ccnt[idxx[a[i]]];
			for(int i=1;i<=blss;i++) {
				if(x>nums[rb][i]-nums[lb-1][i]+ccnt[i]) x-=nums[rb][i]-nums[lb-1][i]+ccnt[i];
				else {
					for(int j=Ls[i];j<=Rs[i];j++){
						if(x>numc[rb][j]-numc[lb-1][j]+cnt[j]) x-=numc[rb][j]-numc[lb-1][j]+cnt[j];
						else {
							printf("%d\n",j);
							break;
						}
					}
					break;
				}
			}
			for(int i=l;i<L[lb];i++) cnt[a[i]]=ccnt[idxx[a[i]]]=0;
			for(int i=R[rb]+1;i<=r;i++) cnt[a[i]]=ccnt[idxx[a[i]]]=0;
		}
	}
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：7)

upd:2021/5/4 被 mcyl35 叉掉了，原因是值域分块值域开小了，在这里感谢他的 hack  。

应该说只要做过第二分块，这道题基本上就没有什么有趣的地方了，~~我愿称第二分块为最初分块前体~~。          

我们首先考虑一下这个修改操作，不难发现他的本质就是映射，感觉可以维护的方式有点多，先咕着。          

查询是区间 rank ，我第一想法就是由乃打扑克，每个块排序然后 lowerbound 查询，但是这样的话就不好修改了，我们得考虑一种能兼容修改的查询方法。             

我们不难发现对于 rank ，我们有一个很普遍的值域分块方法，如果此题中我们对每个块进行值域分块，维护下来块的前缀值域情况，那么这道题就很简单了。            

我们又发现，修改的映射每一次只会修改两类数，这个显然可以数组存储做到 $O(1)$，然后我们把暴力修改涉及到的两类数所影响的前缀推平一遍就好了，这个过程显然 $O(\sqrt n)$ 。                

接着我们思考一个问题：我们的修改在值域分块的维护上面没有问题，但是对于散块修改呢？但是怎么维护整块修改完后每个数变成了什么？               

这时候就得并查集了，对于整块我们还要用并查集维护它们的映射关系。         

记录 ```fr[x][y]``` 表示权值 y 在块 x 内第一个出现的位置，相当于是一个捆绑标记，```col[x]``` 表示序列里面第 x 个数的颜色，令当前块为 t 。

我们判断 a 改为 b 的映射，如果 a 不存在，那么我们不要这个修改。如果 b 不存在，我们就直接让 b 的 ```fr[t][b] = fr[t][a}``` 即可，并且把 ```col[fr[t][b]]``` 修改为 b ，否则都出现过的话直接并查集，把 ```fr[t][a]```父亲置为 ```fr[t][b]``` 就好了。             

接着我们对于整块直接并查集进去，对于散块，看着不爽直接重构就好了，时间复杂度 $O(n \sqrt n)$ 。        

不过此题轻度卡常，建议多玄学剪枝一些东西，建议先做第二分块。                

不过要我评，做这道题之前就算我没做过第二分块，估计也只能给 6 的评分。                 

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 1e5 + 5 , SIZE = 330;
int n,m,fr[SIZE][Len],col[Len],fa[Len],cnt[SIZE][Len],sum[SIZE][SIZE],vt,t,L[SIZE],R[SIZE],pos[Len],VL[SIZE],VR[SIZE],Vpos[Len],a[Len];
void makeSet(int x){for(int i = 1 ; i <= x ; i ++) fa[i] = i;}
int findSet(int x){return fa[x] == x ? fa[x] : fa[x] = findSet(fa[x]);}
inline void merge(int x,int X,int Y)
{
	if(!fr[x][X]) return;
	else if(!fr[x][Y]){fr[x][Y] = fr[x][X] , col[fr[x][Y]] = Y;}
	else fa[fr[x][X]] = fr[x][Y];
	fr[x][X] = 0;
}
inline void build(int x,int l,int r,int X,int Y)
{
	for(int i = L[x] ; i <= R[x] ; i ++){a[i] = col[findSet(i)] ; fr[x][a[i]] = 0;}
	for(int i = l ; i <= r ; i ++) if(a[i] == X) a[i] = Y;
	for(int i = L[x] ; i <= R[x] ; i ++) 
	{
		if(!fr[x][a[i]]){fr[x][a[i]] = i;col[fr[x][a[i]]] = a[i];}
		fa[i] = fr[x][a[i]];
	}
}
inline void upd(int l,int r,int X,int Y)
{
	if(X == Y) return;
	int LL = pos[l] , RR = pos[r];
	int numb = 0 , Tmp = 0;
	if(LL == RR) 
	{
		for(int i = l ; i <= r ; i ++) if(col[findSet(i)] == X) numb ++;
		if(!numb) return;
		for(int i = LL ; i <= t ; i ++) sum[i][Vpos[X]] -= numb , sum[i][Vpos[Y]] += numb , cnt[i][X] -= numb , cnt[i][Y] += numb;
		build(LL , l , r , X , Y);
		return;
	}
	for(int i = l ; i <= R[LL] ; i ++) if(col[findSet(i)] == X) numb ++;
	if(numb) build(LL , l , R[LL] , X , Y);
	for(int i = LL ; i <= RR - 1 ; i ++) numb += Tmp , sum[i][Vpos[X]] -= numb , sum[i][Vpos[Y]] += numb , Tmp = cnt[i + 1][X] - cnt[i][X] , cnt[i][X] -= numb , cnt[i][Y] += numb; 
	int v = 0;for(int i = L[RR] ; i <= r ; i ++) if(col[findSet(i)] == X) numb ++ , v ++;
	for(int i = RR ; i <= t ; i ++) sum[i][Vpos[X]] -= numb , sum[i][Vpos[Y]] += numb , cnt[i][X] -= numb , cnt[i][Y] += numb; 
	for(int i = LL + 1 ; i <= RR - 1 ; i ++) merge(i , X , Y);
	if(v) build(RR , L[RR] , r , X , Y);
	return;
}
int UsedSum[Len],UsedBlock[SIZE];
inline int qry(int l,int r,int k)
{
	int LL = pos[l] , RR = pos[r];
	if(k > r - l + 1) return -1;
	if(LL == RR)
	{
		for(int i = l ; i <= r ; i ++) UsedBlock[Vpos[col[findSet(i)]]] ++ , UsedSum[col[findSet(i)]] ++;
		for(int j = 1 ; j <= vt ; j ++) 
		{
			if(k > UsedBlock[j]) k -= UsedBlock[j];
			else
			{
				for(int p = VL[j] ; p <= VR[j] ; p ++) 
				{
					if(k > UsedSum[p]) k -= UsedSum[p];
					else 
					{
						for(int i = l ; i <= r ; i ++) UsedBlock[Vpos[col[findSet(i)]]] -- , UsedSum[col[findSet(i)]] --;
						return p;
					}
				}
			}
		}
	}
	for(int i = l ; i <= R[LL] ; i ++) UsedBlock[Vpos[col[findSet(i)]]] ++ , UsedSum[col[findSet(i)]] ++;
	for(int i = L[RR] ; i <= r ; i ++) UsedBlock[Vpos[col[findSet(i)]]] ++ , UsedSum[col[findSet(i)]] ++;
	for(int j = 1 ; j <= vt ; j ++)
	{
		if(k > (sum[RR - 1][j] - sum[LL][j] + UsedBlock[j])) k -= sum[RR - 1][j] - sum[LL][j] + UsedBlock[j];
		else
		{
			for(int p = VL[j] ; p <= VR[j] ; p ++)
			{
				if(k > (cnt[RR - 1][p] - cnt[LL][p] + UsedSum[p])) k -= cnt[RR - 1][p] - cnt[LL][p] + UsedSum[p];
				else 
				{
					for(int i = l ; i <= R[LL] ; i ++) UsedBlock[Vpos[col[findSet(i)]]] -- , UsedSum[col[findSet(i)]] --;
					for(int i = L[RR] ; i <= r ; i ++) UsedBlock[Vpos[col[findSet(i)]]] -- , UsedSum[col[findSet(i)]] --;
					return p;
				}
			}
		}
	}
}
struct Node
{
	int opt,l,r,x,y;	
}lxlNB[Len]; 
signed main()
{
	int maxn = 100000;
	scanf("%d %d",&n,&m);
	makeSet(n);
	t = sqrt(n);
	for(int i = 1 ; i <= n ; i ++){scanf("%d",&a[i]) ; maxn = max(maxn , a[i]);}
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%d %d %d %d",&lxlNB[i].opt,&lxlNB[i].l,&lxlNB[i].r,&lxlNB[i].x);
		if(lxlNB[i].opt == 1) 
		{
			scanf("%d",&lxlNB[i].y);
			maxn = max(maxn , lxlNB[i].x) , maxn = max(maxn , lxlNB[i].y);
		}
	}
	vt = sqrt(maxn);
	for(int i = 1 ; i <= t ; i ++) L[i] = (i - 1) * t + 1 , R[i] = i * t;
	R[t] = n;
	for(int i = 1 ; i <= vt ; i ++) VL[i] = (i - 1) * vt + 1 , VR[i] = i * vt;
	VR[vt] = maxn;
	for(int i = 1 ; i <= t ; i ++) 
		for(int j = L[i] ; j <= R[i] ; j ++) pos[j] = i;
	for(int i = 1 ; i <= vt ; i ++) 
		for(int j = VL[i] ; j <= VR[i] ; j ++) Vpos[j] = i;
	for(int i = 1 ; i <= t ; i ++)
	{
		for(int j = L[i] ; j <= R[i] ; j ++)
		{
			if(!fr[i][a[j]]){fr[i][a[j]] = j ; col[fr[i][a[j]]] = a[j];}
			fa[j] = fr[i][a[j]];
			cnt[i][a[j]] ++ , sum[i][Vpos[a[j]]] ++;
		}
		for(int j = 1 ; j <= vt ; j ++) sum[i][j] += sum[i - 1][j];
		for(int j = 1 ; j <= maxn ; j ++) cnt[i][j] += cnt[i - 1][j]; 
	}
	for(int i = 1 ; i <= m ; i ++) 
	{
		if(lxlNB[i].opt == 1) upd(lxlNB[i].l , lxlNB[i].r , lxlNB[i].x , lxlNB[i].y);
		else printf("%d\n",qry(lxlNB[i].l , lxlNB[i].r , lxlNB[i].x));
	}
	return 0;
}
```

---

## 作者：yzxoi (赞：7)

## [My Blog](https://yzxoi.top/archives/1724)
## Description

一个长为 $n$ 的序列 $a$，有 $m$ 次操作。

1. 把区间 $[l,r]$ 内所有的 $x$ 变成 $y$。
2. 查询区间 $[l,r]$ 内第 $k$ 小值。

$1\leq n,m,a_i\leq 10^5$

## Solution

stO 陈指导 Orz，陈指导码了一个下午就做完了，蒟蒻我竟然写了3天。

首先要对序列分块，对于整块，考虑直接把一种数字直接改成另一种数字，然后可以考虑使用**并查集**。对于散块，我们可以直接暴力枚举修改，暴力重构并查集即可。

这时候需要分类讨论：

1. 该块中没有出现 $x$，那么直接跳过即可。
2. 该块出现了 $x$，没有出现 $y$，那么就直接用并查集映射即可。
3. 该块出现了 $x$，也出现了 $y$，直接暴力重构。

然后我们会发现一个细节：如果我们并查集记录的是**每个块的颜色指向的真实颜色**，那么会出现一些问题：如果将块内所有 $1$ 改为 $2$，再将所有 $3$ 改为 $1$ 这种情况就非常难处理。

所以我们可以选择记录**块内每个位置在块内与其数字相同的编号最小值**，这样就可以完美规避上面的问题了。

然后我们发现询问还是有点苦难，这时候应该可以想到查找区间第 $k$ 小的常见套路：值域分块，记录每个序列块的前缀和。具体实现方法就是"带插入区间第 $k$ 小"方法。

这时候敲代码的时候又会发现一个问题：每次修改要更新的是前缀和，复杂度会升到 $O(NM)$。考虑修改的过程中开个桶记录下第 $k$ 个块修改的权值和，修改全部完成后再扫一遍所有的块，更新前缀和即可。

可以发现暴力重构块的次数是有限的，每次合并时块内权值种类会减少 $1$，而权值种类总共不会超过$n+m$，可以保证复杂度正确性 $O((N+M)\sqrt{N})$。

~~然后不知道为什么被lxl卡得很慢~~

## Code

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define W while
#define I inline
#define RI register int
#define LL long long
#define Cn const
#define CI Cn int&
#define gc getchar
#define D isdigit(c=gc())
#define pc(c) putchar((c))
#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
using namespace std;
namespace Debug{
	Tp I void _debug(Cn char* f,Ty t){cerr<<f<<'='<<t<<endl;}
	Ts I void _debug(Cn char* f,Ty x,Ar... y){W(*f!=',') cerr<<*f++;cerr<<'='<<x<<",";_debug(f+1,y...);}
	Tp ostream& operator<<(ostream& os,Cn vector<Ty>& V){os<<"[";for(Cn auto& vv:V) os<<vv<<",";os<<"]";return os;}
	#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)
}using namespace Debug;
namespace FastIO{
	Tp I void read(Ty& x){char c;int f=1;x=0;W(!D) f=c^'-'?1:-1;W(x=(x<<3)+(x<<1)+(c&15),D);x*=f;}
	Ts I void read(Ty& x,Ar&... y){read(x),read(y...);}
	Tp I void write(Ty x){x<0&&(pc('-'),x=-x,0),x<10?(pc(x+'0'),0):(write(x/10),pc(x%10+'0'),0);}
	Tp I void writeln(Cn Ty& x){write(x),pc('\n');}
}using namespace FastIO;
Cn int N=1e5+10,S=452,M=N/S+5,SS=385,MM=N/SS+5;
int n,m,b[M][S+5],sz[M],L[M],cnt[M][N],cntS[M][MM],F[M][S+5],H[M][N],tot,stk[N],top,tcnt[N],tcntS[MM],T[M];
I int Find(CI k,CI x,CI t=0){return x==F[k][x]?x:F[k][x]=Find(k,F[k][x],t);}//并查集
I void B(CI k,CI x=-1,CI y=-1,CI l=0,CI r=0,CI v=0){//暴力重构块
	RI i,t;for(i=0;i<sz[k];i++) t=b[k][Find(k,i,1)],b[k][i]=t,H[k][t]=-1;//并查集重置
	if(~x) for(i=(v?l:0);i<=(v?r:sz[k]-1);i++) if(b[k][i]==x) b[k][i]=y,T[k]++;//暴力修改
	for(i=0;i<sz[k];i++) F[k][i]=((~H[k][b[k][i]])?H[k][b[k][i]]:H[k][b[k][i]]=i);//重构并查集
}
I void P(CI k,CI l,CI r,CI x,CI y){RI i;B(k,x,y,l,r,1);}//边角暴力重构
I void R(CI x,CI y){RI i,t=0;for(i=1;i<=tot;i++) t+=T[i],cnt[i][x]-=t,cntS[i][x/SS]-=t,cnt[i][y]+=t,cntS[i][y/SS]+=t,T[i]=0;}//开临时数组记录，最后直接扫一遍累加更新前缀和
I void U(RI l,RI r,CI x,CI y){
	if(x==y) return ;RI i,bL=(l-1)/S+1,bR=(r-1)/S+1;if(l-=L[bL],r-=L[bR],bL==bR) return P(bL,l,r,x,y),R(x,y);
	for(P(bL,l,sz[bL]-1,x,y),P(bR,0,r,x,y),i=bL+1;i<=bR-1;i++) if(cnt[i][x]^cnt[i-1][x]&&cnt[i][y]==cnt[i-1][y]) T[i]+=cnt[i][x]-cnt[i-1][x],F[i][H[i][x]]=H[i][y]=H[i][x],b[i][H[i][x]]=y,H[i][x]=-1;//如果没有y，直接映射
	else if(cnt[i][x]^cnt[i-1][x]&&cnt[i][y]^cnt[i-1][y]) B(i,x,y);return R(x,y);//如果有y，直接暴力重构
}
I void G(CI k,CI l,CI r){RI i;for(i=l;i<=r;i++) stk[++top]=b[k][Find(k,i)],tcnt[stk[top]]++,tcntS[stk[top]/SS]++;}//散块暴力统计
I void C(){W(top) tcnt[stk[top]]--,tcntS[stk[top]/SS]--,top--;}//记得清空
I int Q(RI l,RI r,RI k){//值域分块，基本套路
	RI i,j,bL=(l-1)/S+1,bR=(r-1)/S+1;if(l-=L[bL],r-=L[bR],bL==bR) for(G(bL,l,r),i=0;;i++) if(tcntS[i]<k) k-=tcntS[i];
	else for(j=SS*i;;j++) if(k>tcnt[j]) k-=tcnt[j];else return C(),j;
	else for(G(bL,l,sz[bL]-1),G(bR,0,r),i=0;;i++) if(k>tcntS[i]+cntS[bR-1][i]-cntS[bL][i]) k-=tcntS[i]+cntS[bR-1][i]-cntS[bL][i];
	else for(j=SS*i;;j++) if(k>tcnt[j]+cnt[bR-1][j]-cnt[bL][j]) k-=tcnt[j]+cnt[bR-1][j]-cnt[bL][j];else return C(),j;
}
int main(){
	RI i,j,k,opt,l,r,x,y;for(read(n,m),i=1;i<=n;i++) read(x),!((i-1)%S)&&(L[++tot]=i),b[tot][sz[tot]++]=x;
	memset(F,-1,sizeof(F));memset(H,-1,sizeof(H));for(i=1;i<=tot;i++) for(j=0;j<sz[i];j++) for(F[i][j]=((~H[i][b[i][j]])?H[i][b[i][j]]:H[i][b[i][j]]=j),k=i;k<=tot;k++) cnt[k][b[i][j]]++,cntS[k][b[i][j]/SS]++;
	W(m--) if(read(opt,l,r,x),opt==1) read(y),U(l,r,x,y);else writeln(Q(l,r,x));return 0;
}
```



---

## 作者：_ANIG_ (赞：6)

先看查询操作。给序列分块。每个块都保存数组 $sum_{i,x}$。表示第 $i$ 块 $x$ 的数量。为了快速查询一个区间内的数量，可以使用前缀和。$qsum_{i,x}$ 表示前 $i$ 块 $x$ 的数量。朴素的做法就是算出每个数出现的次数 $sm1_i$，找到一个最小的 $m$，使得 $k\le sm1_1+sm1_2+...+sm1_m$。但是这样是 $O(n)$ 的。可以把值域分块，求出值域在第 $i$ 块的数出现的次数总和 $sm2_i$。先找到最小的 $m$ ，使得 $k\le sm2_1+sm2_2+...+sm2_m$，把查找的范围缩小到一个块内。

修改操作可以使用并查集。每个块开一个并查集。把值相同的数放到一个并查集里。整块修改分 $3$ 种情况：

- 块内有 $x$，有 $y$。直接把 $x$ 的并查集代表元接到 $y$ 下面。

- 块内无 $x$，跳过。

- 块内有 $x$ 无 $y$。直接修改 $x$ 的代表元代表的值即可。

修改完后更新 $sum$ 数组。全部修改完后再一起更新 $qsum$ 数组。零散块直接拆了重构。

但是直接交上去会TLE。需要卡常。

- 快读快写。

- register 和 inline 修饰。

- 调块长。

总复杂度 $O((m+n)\sqrt n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
inline void write(int x){
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}
inline void read(int &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
const int N=168,T=600,maxn=100805;
int fa[maxn],sm1[N][maxn],sm2[N][N],p[maxn],fr[N][maxn],bh[maxn],st[N+5],ed[N+5],sn,sa,n,m,maxa,q1[N][maxn],q2[N][N],sm3[N],sm4[maxn];
int f(register int x){
	if(fa[x]==x)return x;
	return fa[x]=f(fa[x]);
}
inline void init(){
	sn=n/T+1,sa=maxa/T+1;
	for(register int i=1;i<=n;i++)fa[i]=i;
	for(register int i=1;i<=100000;i++)bh[i]=(i-1)/T+1;
	for(register int i=1;i<N;i++)st[i]=(i-1)*T+1,ed[i]=i*T;
	for(register int i=1;i<=n;i++)if(fr[bh[i]][p[i]])fa[i]=fr[bh[i]][p[i]];else fr[bh[i]][p[i]]=i;
	for(register int i=1;i<=n;i++)sm1[bh[i]][p[i]]++,sm2[bh[i]][bh[p[i]]]++;
	for(register int i=1;i<=sn;i++)for(register int j=1;j<=maxa;j++)q1[i][j]=q1[i-1][j]+sm1[i][j];
	for(register int i=1;i<=sn;i++)for(register int j=1;j<=sa;j++)q2[i][j]=q2[i-1][j]+sm2[i][j];
}
inline int Solve(register int l,register int r,register int k){
	memset(sm3,0,sizeof(sm3));
	register int nw,ll=bh[l]+1,rr=bh[r]-1;
	if(bh[l]==bh[r]){
		for(register int i=l;i<=r;i++)sm4[i]=p[f(i)];
		nth_element(sm4+l,sm4+l+k-1,sm4+r+1);
		register int res=sm4[l+k-1];
		for(register int i=l;i<=r;i++)sm4[i]=0;
		return res;
	}
	for(register int i=1;i<=sa;i++)sm3[i]=q2[rr][i]-q2[ll-1][i];
	for(int i=l;i<=st[ll]-1;i++)p[i]=p[f(i)],sm4[p[i]]++,sm3[bh[p[i]]]++;
	for(int i=ed[rr]+1;i<=r;i++)p[i]=p[f(i)],sm4[p[i]]++,sm3[bh[p[i]]]++;
	for(nw=1;nw<=sa;nw++)if(sm3[nw]>=k)break;else k-=sm3[nw];
	for(register int i=st[nw];i<=ed[nw];i++)sm4[i]+=q1[rr][i]-q1[ll-1][i];
	for(register int i=st[nw];i<=ed[nw];i++)if(sm4[i]>=k){
	    for(int j=l;j<=st[ll]-1;j++)sm4[p[j]]=0;
	    for(int j=ed[rr]+1;j<=r;j++)sm4[p[j]]=0;
		for(register int j=st[nw];j<=ed[nw];j++)sm4[j]=0;
		return i;
	}else k-=sm4[i];
}
inline void rset(register int st,register int x){
	for(register int i=st;i<=sn;i++)q1[i][x]=q1[i-1][x]+sm1[i][x],q2[i][bh[x]]=q2[i-1][bh[x]]+sm2[i][bh[x]];
}
inline void sit(register int l,register int r,register int x,register int y){
	for(register int i=st[bh[l]];i<=ed[bh[l]];i++)p[i]=p[f(i)];
	for(register int i=l;i<=r;i++)if(p[i]==x)p[i]=y,sm1[bh[i]][x]--,sm1[bh[i]][y]++,sm2[bh[i]][bh[x]]--,sm2[bh[i]][bh[y]]++;
	fr[bh[l]][x]=0,fr[bh[l]][y]=0;
	for(register int i=st[bh[l]];i<=ed[bh[l]];i++){
		if(i>n)break;
		if(p[i]==x)if(fr[bh[l]][x])fa[i]=fr[bh[l]][x];else fr[bh[l]][x]=i,fa[i]=i;
		if(p[i]==y)if(fr[bh[l]][y])fa[i]=fr[bh[l]][y];else fr[bh[l]][y]=i,fa[i]=i;
	}
}
inline void sets(register int l,register int r,register int x,register int y){
	if(x==y)return;
	if(bh[l]==bh[r]){
		sit(l,r,x,y);
		rset(bh[l],x);rset(bh[l],y);
		return;
	}
	register int ll=bh[l]+1,rr=bh[r]-1;
	for(register int i=ll;i<=rr;i++)if(fr[i][x]){sm1[i][y]+=sm1[i][x],sm2[i][bh[x]]-=sm1[i][x],sm2[i][bh[y]]+=sm1[i][x],sm1[i][x]=0;if(fr[i][y])fa[fr[i][x]]=fr[i][y];else fr[i][y]=fr[i][x],p[fr[i][x]]=y;fr[i][x]=0;}
	sit(l,st[ll]-1,x,y);sit(ed[rr]+1,r,x,y);
	rset(bh[l],x);rset(bh[l],y);
}
int main(){
	cin>>n>>m;
	for(register int i=1;i<=n;i++)read(p[i]),maxa=max(maxa,p[i]);
	init();
	while(m--){
		register int op,a,b,k,kk;
		read(op);read(a);read(b);read(k);
		if(op==2){write(Solve(a,b,k));putchar('\n');}
		else{
			read(kk);
			sets(a,b,k,kk);
		}
	}
}
```


---

## 作者：miaow (赞：6)

ynoi是真的毒瘤……

## 题解

这题一看要求是kth，二话不说先想个主席树，然后看到这鬼畜的修改……

还是老老实实的分块吧~~ynoi做多了看什么都是分块~~

先不管查询，看看这修改要求怎么在分块上维护。他要求把区间所有x改成y，要快速维护中间的块可能要打标记啥的……

~~我就不打标记你能奈我何~~ 既然他一次只要改一种数，那我们想想怎么把块里相同的数组织在一起方便修改。应该不难想到一个我们学过的东西叫做**并查集**

对块里每个出现了的数取第一个出现的为根节点，后面与这个数相同的数都用并查集连到这个数上，查询某个数时查到根节点就知道这个数是多少了

想到这里就很容易快速实现修改了，对边块直接扫一遍，符合的数直接把他的$fa[]$改为块内数字y的根节点就行，中间的块可以把x的根节点的$fa[]$改成y的根节点

然后怎么找kth呢

~~分块找kth当然是二分答案啦~~楼下julao已经告诉我们分块和二分不是很搭，写二分答案只有50分（我最开始就是写的二分答案)

想想看，如果知道区间内每个数的出现次数，然后从$1$开始一个一个加起来直到超过$k$了就找到答案了，对吧。于是我们就想办法维护块里每个数出现的个数。

略微想想，有两个麻烦。第一，要一个一个加，太慢；第二，加一个数要把询问区间里的块都扫一遍，更慢。

第二个麻烦好解决，弄一堆树状数组，第$i$个树状数组维护 $i$ 这个数在前$j$个块里的出现次数。然后就不用把询问区间里的块都扫一遍了。

第一个麻烦出现的原因就在于我不知道要扫到哪个数，因为这个数就是答案。所以要想办法加快扫的速度。既然已经对数列分块了，不如再试试对值域分块？再搞一堆树状数组，第$i$个树状数组维护值域块第$i$块里所有数字在数列块前$j$块出现的次数，然后查询时先跳块，直到再跳一个块就超过$k$的时候，进入这个块一个一个扫，答案就出来了。

修改和查询都要扫块和查树状数组，总时间复杂度大概是$O(n\sqrt{n}log\sqrt{n})$（假设n，m都和值域大小差不多），卡卡常调调块大小就能过了。~~洛咕评测姬跑的是真的快~~

最后，搞这么多数组容易被卡空间，块数不要写太多。

~~口胡一时爽，实现emm……~~实现细节太多了调着是真的累，代码里的一堆奇怪的+1-1全都是奇怪的细节，不要深究就是了……

## 代码

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
const int N=1e5+5,M=170+5,N2=600+5;//M是块数，N2是块大小 
const int MZ=170;
inline int read()
{
    int sum;
    char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    sum=c-'0';
    c=getchar();
    while(c>='0'&&c<='9')
    {
        sum=sum*10+c-'0';
        c=getchar();
    }
    return sum;
}
inline void write(int x)
{
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
inline int lowb(int x)
{
    return x&(-x);
}
struct miaow//树状数组 
{
    int a[M];
    miaow()
    {
        memset(a,0,sizeof(a));
    }
    void add(int o,int k)
    {
        while(o<=MZ)
        {
            a[o]+=k;
            o+=lowb(o);
        }
    }
    int query(int o)
    {
        int ans=0;
        while(o)
        {
            ans+=a[o];
            o-=lowb(o);
        }
        return ans;
    }
    int query2(int l,int r)
    {
    	int ans=query(r)-query(l);
    	return ans;
    }
}szqzh[N],fkqzh[M];//维护单个数字的，维护值域块的 
int bj[M][N]={0},su[M][N]={0};//数列块内并查集根节点，数列块内每个数字出现的次数 
int fk[M][N2],fkfa[M][N2];//数列分块，并查集里的fa数组 
int sztmp[N]={0},fktmp[M]={0};//查询用的临时数组 
int szdl[N],fkdl[M],szdlt=1,fkdlt=1;//清空临时数组用的栈 
int fifa(int k,int x)//并查集 
{
    return x==fkfa[k][x]?x:fkfa[k][x]=fifa(k,fkfa[k][x]);
}
int main()
{
    int n,m;
    cin>>n>>m;
    int n2=600; 
    for(int i=0;i<n;i++)
    {
        int k=i/n2,o=i%n2+1,x=read();
        fk[k][o]=x;
        if(!bj[k][x])
        {
            fkfa[k][o]=o;
            bj[k][x]=o;
        }
        else
        {
            fkfa[k][o]=bj[k][x];
        }
        su[k][x]+=1;
        szqzh[x-1].add(k+1,1);
        fkqzh[(x-1)/n2].add(k+1,1);
    }
    while(m)
    {
        --m;
        int t=read();
        if(t==1)
        {
            int l=read(),r=read(),x=read(),y=read();
            if(x==y)continue;
            --l;--r;
            int ll=l/n2,rr=r/n2;
            if(ll!=rr)
            {
                int ls=0,rs=0;
                int bjx=0;//以下所有bjx变量都是为了保证每个数的fa要么是自己(自己就是根节点)，要么在前面 
                for(int i=l%n2+1;i<=n2;++i)
                {
                    int fa=fifa(ll,i);
                    if(fk[ll][fa]==x)
                    {
                        ++ls;
                        if(fa==i)
                        {
                            bj[ll][x]=0;
                        }
                        if(!bjx)
                        {
                            bjx=i;
                            fk[ll][i]=x;
                        }
                        else
                        {
                            fkfa[ll][i]=bjx;
                        }
                        fkfa[ll][i]=bjx;
                        --su[ll][x];
                        ++su[ll][y];
                    }
                }
                if(bjx)
                {
                    if(!bj[ll][y])
                    {
                        bj[ll][y]=bjx;
                        fk[ll][bjx]=y;
                    }
                    else
                    {
                        if(bj[ll][y]<bjx)
                        {
                            fkfa[ll][bjx]=bj[ll][y];
                        }
                        else
                        {
                            fkfa[ll][bj[ll][y]]=bjx;
                            fk[ll][bjx]=y;
                            bj[ll][y]=bjx;
                        }
                    }
                }
                szqzh[x-1].add(ll+1,-ls);
                szqzh[y-1].add(ll+1,ls);
                fkqzh[(x-1)/n2].add(ll+1,-ls);
                fkqzh[(y-1)/n2].add(ll+1,ls);
                int bjx2=0,bjx3=0,wk;
                if((n-1)/n2==rr)wk=(n-1)%n2+1;
                else wk=n2;
                for(int i=r%n2+2;i<=wk;++i)
                {
                    int fa=fifa(rr,i);
                    if(fk[rr][fa]==x)
                    {
                        if(!bjx2)
                        {
                            bjx2=i;
                            fk[rr][i]=x;
                        }
                        fkfa[rr][i]=bjx2;
                    }
                }
                for(int i=1;i<=r%n2+1;++i)
                {
                    int fa=fifa(rr,i);
                    if(fk[rr][fa]==x)
                    {
                        ++rs;
                        if(fa==i)
                        {
                            bj[rr][x]=0;
                        }
                        if(!bjx3)
                        {
                            bjx3=i;
                            fk[rr][i]=x;
                        }
                        fkfa[rr][i]=bjx3;
                        --su[rr][x];
                        ++su[rr][y];
                    }
                }
                szqzh[x-1].add(rr+1,-rs);
                szqzh[y-1].add(rr+1,rs);
                fkqzh[(x-1)/n2].add(rr+1,-rs);
                fkqzh[(y-1)/n2].add(rr+1,rs);
                if(bjx3)
                {
                    if(!bj[rr][y])
                    {
                        fk[rr][bjx3]=y;
                        bj[rr][y]=bjx3;
                    }
                    else
                    {
                        if(bj[rr][y]<bjx3)
                        {
                            fkfa[rr][bjx3]=bj[rr][y];
                        }
                        else
                        {
                            fkfa[rr][bj[rr][y]]=bjx3;
                            bj[rr][y]=bjx3;
                            fk[rr][bjx3]=y;
                        }
                    }
                }
                if(bjx2)
                {
                    if(!bj[rr][x])
                    {
                        bj[rr][x]=bjx2;
                        fk[rr][bjx2]=x;
                    }
                    else
                    {
                        fkfa[rr][bjx2]=bj[rr][x];
                    }
                }
                for(int i=ll+1;i<rr;++i)
                {
                    if(!bj[i][x])continue;
                    szqzh[x-1].add(i+1,-su[i][x]);
                    szqzh[y-1].add(i+1,su[i][x]);
                    fkqzh[(x-1)/n2].add(i+1,-su[i][x]);
                    fkqzh[(y-1)/n2].add(i+1,su[i][x]);
                    su[i][y]+=su[i][x];
                    su[i][x]=0;
                    if(!bj[i][y])
                    {
                        bj[i][y]=bj[i][x];
                        fk[i][bj[i][x]]=y;
                    }
                    else
                    {
                        if(bj[i][y]<bj[i][x])
                        {
                            fkfa[i][bj[i][x]]=bj[i][y];
                        }
                        else
                        {
                            fkfa[i][bj[i][y]]=bj[i][x];
                            fk[i][bj[i][x]]=y;
                            bj[i][y]=bj[i][x];
                        }
                    }
                    bj[i][x]=0;
                }
            }
            else
            {
                int ls=0,wk;
                if((n-1)/n2==ll)wk=(n-1)%n2+1;
                else wk=n2;
                int bjx=0;
                for(int i=r%n2+2;i<=wk;++i)
                {
                    int fa=fifa(ll,i);
                    if(fk[ll][fa]==x)
                    {
                        if(!bjx)
                        {
                            bjx=i;
                            fk[ll][i]=x;
                        }
                        fkfa[ll][i]=bjx;
                    }
                }
                int bjx2=0;
                for(int i=l%n2+1;i<=r%n2+1;++i)
                {
                    int fa=fifa(ll,i);
                    if(fk[ll][fa]==x)
                    {
                        ++ls;
                        if(fa==i)
                        {
                            bj[ll][x]=0;
                        }
                        if(!bjx2)
                        {
                            bjx2=i;
                            fk[ll][i]=x;
                        }
                        fkfa[ll][i]=bjx2;
                        --su[ll][x];
                        ++su[ll][y];
                    }
                }
                if(bjx2)
                {
                    if(!bj[ll][y])
                    {
                        fk[ll][bjx2]=y;
                        bj[ll][y]=bjx2;
                    }
                    else
                    {
                        if(bj[ll][y]<bjx2)
                        {
                            fkfa[ll][bjx2]=bj[ll][y];
                        }
                        else
                        {
                            fkfa[ll][bj[ll][y]]=bjx2;
                            bj[ll][y]=bjx2;
                            fk[ll][bjx2]=y;
                        }
                    }
                }
                if(bjx)
                {
                    if(!bj[ll][x])
                    {
                        bj[ll][x]=bjx;
                        fk[ll][bjx]=x;
                    }
                    else
                    {
                        fkfa[ll][bjx]=bj[ll][x];
                    }
                }
                szqzh[x-1].add(ll+1,-ls);
                szqzh[y-1].add(ll+1,ls);
                fkqzh[(x-1)/n2].add(ll+1,-ls);
                fkqzh[(y-1)/n2].add(ll+1,ls);
            }
        }
        else
        {
            int l=read(),r=read(),k=read();
            --l;--r;
            int ll=l/n2,rr=r/n2;
            int ans=0,pm=1;
            int qwe=0;
            szdlt=1;
            fkdlt=1;
            if(ll!=rr)
            {
            	for(int i=l%n2+1;i<=n2;++i)
            	{
            		int fa=fifa(ll,i);
            		int fasz=fk[ll][fa]-1;
            		if(!sztmp[fasz])szdl[szdlt++]=fasz;
            		if(!fktmp[fasz/n2])fkdl[fkdlt++]=fasz/n2;
            		sztmp[fasz]+=1;
            		fktmp[(fasz)/n2]+=1;
            	}
            	for(int i=1;i<=r%n2+1;++i)
                {
                    int fa=fifa(rr,i);
                    int fasz=fk[rr][fa]-1;
            		if(!sztmp[fasz])szdl[szdlt++]=fasz;
            		if(!fktmp[fasz/n2])fkdl[fkdlt++]=fasz/n2;
                    sztmp[fasz]+=1;
            		fktmp[(fasz)/n2]+=1;
                }
                int j=0;
                qwe=fktmp[0]+fkqzh[0].query2(ll+1,rr);
                while(pm+qwe<=k)
                {
                	pm+=qwe;
                	++j;
                	qwe=fktmp[j]+fkqzh[j].query2(ll+1,rr);
                }
                int j2=j*n2;
                qwe=sztmp[j2]+szqzh[j2].query2(ll+1,rr);
                while(pm+qwe<=k)
                {
                	pm+=qwe;
                	++j2;
                	qwe=sztmp[j2]+szqzh[j2].query2(ll+1,rr);
                }
                ans=j2+1;
            }
            else
            {
            	for(int i=l%n2+1;i<=r%n2+1;++i)
            	{
            		int fa=fifa(ll,i);
            		int fasz=fk[ll][fa]-1;
            		if(!sztmp[fasz])szdl[szdlt++]=fasz;
            		if(!fktmp[fasz/n2])fkdl[fkdlt++]=fasz/n2;
            		sztmp[fasz]+=1;
            		fktmp[(fasz)/n2]+=1;
            	}
            	int j=0;
            	qwe=fktmp[0];
            	while(pm+qwe<=k)
            	{
            		pm+=qwe;
            		++j;
            		qwe=fktmp[j];
            	}
            	int j2=j*n2;
            	qwe=sztmp[j2];
            	while(pm+qwe<=k)
            	{
            		pm+=qwe;
            		++j2;
            		qwe=sztmp[j2];
            	}
            	ans=j2+1;
            }
            for(int i=1;i<szdlt;++i)sztmp[szdl[i]]=0;
            for(int i=1;i<fkdlt;++i)fktmp[fkdl[i]]=0;
            write(ans);
            putchar('\n');
        }
    }
    return 0;
}
```

---

## 作者：Utilokasteinn (赞：5)

## [Link](https://www.luogu.com.cn/problem/P4119)

题目大意：

给定一个长度为 $n$ 的序列 $a$，进行 $m$ 次操作，分两种：

1. 将区间 $[l,r]$ 中所有 $x$ 变成 $y$。

2. 查询区间 $[l,r]$ 中的第 $k$ 小值。

数据保证 $1\le n,m,a_i\le 10^5$。

------------
前置知识：数列分块，值域分块，并查集。

令 $A=\max_{i=1}^{n}a_i$。

似乎可以用树套树实现。但是 $O(m\log^2n\log A)$ 显然是过不去的。考虑分块。

观察数据范围，发现值域很小，只有 $10^5$，可以在值域上做文章。

我们将序列和值域都分块，假定块长分别为 $\sqrt{n}$ 和 $\sqrt{A}$。

设 $pos_i$ 表示 $a_i$ 所在的块，$belong_i$ 表示数字 $i$ 所在的块。再设 $L_i,R_i,L'_i,R'_i$ 分别表示在序列和值域中第 $i$ 块的左右端点。

将以上信息预处理，时间复杂度 $O(n+A)$。

代码：

```cpp
	n=read(),m=read();
	for(int i=1;i<=n;++i)
		a[i]=read(),fa[i]=i,maxv=max(maxv,a[i]);
	len1=sqrt(n),block1=n/len1;
	len2=sqrt(maxv),block2=maxv/len2;
	for(int i=1;i<=block1;++i)
		L[i]=R[i-1]+1,R[i]=i*len1;
	R[block1]=n;
	for(int i=1;i<=block1;++i)
		for(int j=L[i];j<=R[i];++j)
			pos[j]=i;
	for(int i=1;i<=block2;++i)
		LL[i]=RR[i-1]+1,RR[i]=i*len2;
	RR[block2]=maxv;
	for(int i=1;i<=block2;++i)
		for(int j=LL[i];j<=RR[i];++j)
			belong[j]=i;
```

------------
通过值域分块来求区间第 $k$ 小值相信大家都会。在值域中，先枚举整块直到个数大于等于 $k$，然后再枚举该块中的每个数，知道个数大于等于 $k$，此时的那个数就是答案。

所以，要先预处理出 $cnt_{i,j},ans_{i,j}$ 以及 $all_{i,j}$。

$cnt_{i,j}$ 表示第 $i$ 块中值为 $j$ 的数的个数。

$ans_{i,j}$ 表示前 $i$ 块中值为 $j$ 的数的个数。

$all_{i,j}$ 表示前 $i$ 块中值在第 $j$ 块的数的个数。

时间复杂度 $O(n+A\sqrt{n})$。

再考虑如何维护块内相同的数。

设 $root_{i,j}$ 表示在第 $i$ 块中值为 $j$ 的数第一次出现的位置。若没有出现则为 $0$。

可以用并查集维护。在第 $i$ 块中，将所有值为 $j$ 的数的 $fa$ 都指向 $root_{i,j}$。$fa_j$ 表示在 $a_j$ 所在的块 $i$ 中，第一个值为 $a_j$ 的数的位置。

预处理 $root$ 和 $fa$，时间复杂度 $O(n)$。

代码：

```cpp
	for(int i=1;i<=block1;++i)
	{
		for(int j=L[i];j<=R[i];++j)
		{
			if(!root[i][a[j]])root[i][a[j]]=j;
			else fa[j]=root[i][a[j]];
			++cnt[i][a[j]],++all[i][belong[a[j]]];
		}
		for(int j=1;j<=maxv;++j)
			ans[i][j]=ans[i-1][j]+cnt[i][j];
		for(int j=1;j<=block2;++j)
			all[i][j]+=all[i-1][j];
	}
```

故所有预处理的时间复杂度为 $O(n+A\sqrt{n})$。

------------
对于将区间 $[l,r]$ 的所有 $x$ 变成 $y$，考虑分块修改。

令 $p=pos_l,q=pos_r$。设函数 ```update(l,r,x,y,p)``` 表示将块 $p$ 中区间 $[l,r]$ 的所有 $x$ 变成 $y$，保证 $l$ 和 $r$ 在块 $p$ 中。

若 $p=q$，直接 ```update(l,r,x,y,p)``` 即可。

若 $p\not=q$，则将区间 $[l,r]$ 分为三部分。先修改左右的散块，再修改中间的整块。即直接 ```updagte(l,R[p],x,y,p)``` 再 ```update(L[q],r,x,y,q)```，最后再修改整块。

------------
### 整块修改

因为有并查集，所以我们只需要修改块内第一个出现的 $x$。之后我们查询 $a_i$ 的值时，只需要调用 $a_{find(i)}$。

若当前修改块 $i$。

若块内没有 $x$，直接跳过并查集的部分。

若块内有 $x$ 无 $y$，就把 $a_{root_{i,x}}$ 赋值为 $y$，然后将 $root_{i,y}$ 赋值为 $root_{i,x}$ 即可。

若块内有 $x$ 有 $y$，就直接将 $root_{i,x}$ 链到 $root_{i,y}$ 上，也就是 $fa_{root_{i,x}}=root_{i,y}$。

在修改完之后，还要维护 $cnt,ans$ 和 $all$ 数组。

注意，当块 $p+1$ 到块 $q-1$ 修改完后，还要修改块 $q$ 和之后的块的 $ans$ 和 $all$ 数组。

时间复杂度 $O(\sqrt{n})$。

------------
### 散块修改

散块修改即 ```update(l,r,x,y,p)```，暴力重构并查集即可。

我们先将表示 $x$ 和 $y$ 的两个并查集清空，即 $root_{p,x}=root_{p,y}=0$。

然后，我们开一个数组，把 $L_p$ 和 $R_p$ 中的所有 $x$ 和 $y$ 的位置都存进去。接着，直接将区间 $[l,r]$ 为 $x$ 的数赋为 $y$。并记录修改了几个数，设为 $res$。

然后就可以暴力重构并查集了。

最后还要记得维护块 $p$ 的 $cnt$ 数组，以及块 $p$ 和之后的块的 $ans$ 和 $all$ 数组。

时间复杂度 $O(\sqrt{n})$。

代码：

```cpp
inline void update(int l,int r,int x,int y,int p)
{
	int res=0,top=0;
	root[p][x]=root[p][y]=0;
	for(int i=L[p];i<=R[p];++i)
	{
		a[i]=a[find(i)];
		if(a[i]==x||a[i]==y)
			st[++top]=i;
	}
	for(int i=l;i<=r;++i)
		if(a[i]==x)a[i]=y,++res;
	for(int i=1,ps,val;i<=top;++i)
	{
		ps=st[i],val=a[ps];
		if(!root[p][val])root[p][val]=ps;
		fa[ps]=root[p][val];
	}
	cnt[p][x]-=res,cnt[p][y]+=res;
	for(int i=p;i<=block1;++i)
	{
		ans[i][x]-=res,ans[i][y]+=res;
		if(belong[x]!=belong[y])
			all[i][belong[x]]-=res,all[i][belong[y]]+=res;
	}
}
```

------------
### 区间查询

现在我们要查询区间 $[l,r]$ 内第 $k$ 小的数。

设 $p=pos_l,q=pos_r$。

开一个桶 $t$ 记录散块内每个数的个数，再开一个桶 $sum$ 记录散块内值在块 $j$ 的数的个数。

时间复杂度 $O(\sqrt{n})$。

```cpp
	for(int i=l;i<=R[p];++i)
	{
		a[i]=a[find(i)];
		++t[a[i]],++sum[belong[a[i]]];
	}
	for(int i=L[q];i<=r;++i)
	{
		a[i]=a[find(i)];
		++t[a[i]],++sum[belong[a[i]]];
	}
```

然后枚举值域块，从第一个块开始往后，$res$ 每次加上值在当前块内的的个数，若 $res\ge k$，则说明答案在当前块内。减去当前块 $i$ 内的个数。

从 $L'_i$ 开始枚举 $j$，若 $res+t_j\ge k$，则说明 $j$ 为第 $k$ 小的数，清空桶然后返回。

时间复杂度 $O(\sqrt{A})$。

```cpp
	for(int i=1;i<=block2;++i)
	{
		res+=sum[i]+all[q-1][i]-all[p][i];
		if(res>=k)
		{
			res-=sum[i]+all[q-1][i]-all[p][i];
			for(int j=LL[i];j<=RR[i];++j)
				if((res+=t[j]+ans[q-1][j]-ans[p][j])>=k)
				{
					for(int u=l;u<=R[p];++u)
						t[a[u]]=sum[belong[a[u]]]=0;
					for(int u=L[q];u<=r;++u)
						t[a[u]]=sum[belong[a[u]]]=0;
					return j;
				}
		}
	}
```

单次查询的时间复杂度为 $O(\sqrt{n}+\sqrt{A})$。

------------
代码的时间复杂度为 $O(m(\sqrt{n}+\sqrt{A})+n)$。

不知道是我人傻常数大还是什么，别人块长 $\sqrt{n}$ 可以稳过，我会 T 两个点……

经过数个小时的调整块长以及卡常，我的代码最终在块长为 $420$ 的情况下，以最大点 $998ms$ 的时间通过该题……

[评测记录](https://www.luogu.com.cn/record/68853717)。

[AC Code](https://www.luogu.com.cn/paste/1sena9ca)。

---

## 作者：konjacq (赞：5)

**[本文同步发表于窝的个人博客](http://39.107.58.77/index.php/archives/luogu-p4119.html).**

太毒瘤了这个...窝本来星期天晚上困得不行想做点什么提提神,然后就跳进了这个大坑,花了整整四个晚上来填...另外就是建议看一下窝的[另一道题的题解]( http://39.107.58.77/index.php/archives/luogu-p2616.html )(虽然过不了就是了),很多操作和里面都是类似的.

## 解题思路

~~首先看到Ynoi就想到分块,并且看到值域和$n$一样都是$\le10^5$可以大胆猜测值域也要分块.~~好吧为什么要分块别的大佬们已经说得很清楚了,那么窝说一下具体的操作.

首先是保存数据的方式.不妨像[Snow_Miku](https://www.luogu.com.cn/user/116368)大佬一样先用并查集搞一下,$fat(i)$即是$i$的父亲.

> 根放在最左边好写一些. -Snow_Miku,2020/06/17

所以就记录$frt(i,j)$为第$i$块内最靠前的$j$的位置.同时值域也要分块,维护$sbk(i,j)$为**前$i$块**中在值域块$j$当中的数的个数,护$snm(i,j)$为**前$i$块**中$a_{x\in第i块}=j$的个数.但是这样对修改操作比较不友好,所以还要维护辅助数组$cbk(i,j)$和$cnm(i,j)$(~~友善度数组~~)分别表示**第$i$块**中的信息.

### 查询($opt=2$)

虽然查询操作的$opt$理论上排在后面但是比较好写所以就先写了.

首先值域分块找区间第$k$大这个操作已经没什么好特别的了.暴力将两边的块的内容统计一下,中间的块有前缀和,就可以快速求出值域块$i$内的数和$a_{x\in第i块}=i$的个数.首先将第$k$小数定位到值域块$u$满足前$u-1$块的数的个数少于$k$且前$u$块的个数不少于$k$,然后再扫一遍$u$这个块求一个数$v$满足小于$v$的数的个数少于$k$且小于$v+1$的数的个数不少于$k$.这个$v$显然就是答案.

另外要注意的就是窝的写法是不能用`memset()`的,因为每一次都是统计了边缘块里所有的数,统计数组的最大值达到了$10^5$.所以只能再扫一遍一个一个地减掉.还有就是记得特判$l$和$r$在同一个块内的情况.写出伪代码

```
function find_kth(l,r,k)
	if l和r在同一块 then
		/*特判,单独处理并返回*/
	end if
    sum←0 /*sum表示当前已经统计了多少个数*/
    /*统计两侧的散块*/
    for i←l to l所在块右端点 by 1 do
        fbk[a[i]所在块]←fbk[a[i]所在块]+1
        fnm[a[i]]←fnm[a[i]]+1
    end for
    for i←r to r所在块左端点 by -1 do
        fbk[a[i]所在块]←fbk[a[i]所在块]+1
        fnm[a[i]]←fnm[a[i]]+1
    end for
    for i←1 to q by 1 do /*q就是$sqrt n$*/
        sum←sum+cbk[r所在块-1][i]-cbk[l所在块][i]+fbk[i]
        if sum>=k then /*前面已经有不少于k个数了*/
            for j←(i+1)*p to i*p by -1 do /*逆序统计第i块值域*/
                sum←sum-cnm[r所在块-1][j]+cnm[l所在块][j]-fnm[j]
                if sum<k then /*前面的数少于k个*/
                    ret←k /*记录下来,不能直接返回是因为还要清空统计数组*/
                end if
            end for
        end if
    end for
    /*清空统计数组,用memset()会T飞*/
    for i←l to l所在块右端点 by 1 do
        fbk[a[i]所在块]←fbk[a[i]所在块]-1
        fnm[a[i]]←fnm[a[i]]-1
    end for
    for i←r to r所在块左端点 by -1 do
        fbk[a[i]所在块]←fbk[a[i]所在块]-1
        fnm[a[i]]←fnm[a[i]]-1
    end for
    return ret
end function
```

[Snow_Miku大佬的写法](https://www.cnblogs.com/lost-in-tianyi/p/11349599.html)和窝的有点不一样.她是先扫到$u$,然后只统计$u$里面数的情况,统计数组是连续的$\sqrt n$大小的值域,所以可以直接`memset()`.并且这两种写法结合起来也是$\Theta(\sqrt n)$的复杂度,并不能优化.

### 更新($opt=1$)

整体上来说如果修改一个数就要重新更新一遍前缀和数组的话显然就

> 会被艹飞 -Snow_Miku的题解

(因为每次扫一遍前缀和的复杂度是至少$\Theta(\sqrt n)$的),所以需要$cbk(i,j)$和$cnm(i,j)$来存储每个块当前的状况,区间更新完后再一次性更新$sbk(i,j)$和$snm(i,j)$.并且显然更新操作只会影响包括$x$和$y$在内的前缀和,所以扫前缀和的时候只需要扫这两个数组.这样单次更新后维护前缀和的复杂度就是$\Theta(\sqrt n)$.写出伪代码

```
sbk[0][x所在块]←cbk[0][x所在块]
snm[0]←cnm[0]
sbk[0][y所在块]←cbk[0][y所在块]
snm[0]←cnm[0]
for i←1 to q by 1 do
	sbk[i][x所在块]←sbk[i-1][x所在块]+cbk[i][x所在块]
	snm[i][x]←snm[i-1][x]+cnm[i][x]
	sbk[i][y所在块]←sbk[i-1][y所在块]+cbk[i][y所在块]
	snm[i][y]←snm[i-1][y]+cnm[i][y]
end for
```

#### 如果$x=y$

显然跳过就好了.

#### 对于左边的散块

可以暴力重构这个区间,但是好像没有别的大佬写具体怎么暴力法,所以窝就试着具体讲一下.

- 首先显然对于$a_i\not\in\{x,y\}$显然不会有任何影响,所以直接跳过这一部分即可.
- 然后因为要保证性质$frt(i,j)$在最左边所以开始讨论
  - $y$的根在$l$的左边或者在$x$的根的左边($frt(l所在块,y)<\min\{l,frt(l所在块,x)\}$),那么直接把$l$右边所有的$x$的$fat(x)$设为$frt(l所在块,y)$即可;
  - $y$的根的位置不满足上一条或者这个区间内根本没有$y$,就从$l$开始往右扫,扫到的第一个$x$或$y$作为根,剩下的$fat(x)$和$fat(y)$都指向它,并将$a_根$设为$y$.
- 另外就是如果$x$的根在$l$右边那么修改后这个区间就没有$x$了,记得$frt(l所在块,x)=-1$.

#### 对于右边的散块

和左边的散块类似,但是对于根的处理没有那么多讨论.

- 同样跳过$a_i\not\in\{x,y\}$,并且开始时先$frt(r所在块,x)=-1$.
- 然后直接从$r$所在的块的最左边开始扫,扫到的第一个$x$或$y$作为根,剩下的$fat(\mathop x_\limits{x\le r})$和$fat(y)$都指向它,并将$a_根$设为$y$,并且注意对于$a_{i>r}=x$不修改.
- 如果此时$i>r$且$a_i=x$,那么意味着修改后$r$所在块内还有$x$存在,将第一个满足以上条件的$x$作为根,剩下的$fat(\mathop x_\limits{x>r})$和指向它.

#### 对于中间的整块

这个就比较容易了,直接判一下$x$存不存在,然后看$x$和$y$的根哪个比较靠前,把靠后的根指过去即可.当然同样要记得$a_根=y$.

#### 如果$l$和$r$在同一块内

结合一下左右散块的写法即可,~~留作课后习题.~~

好吧还是说一下,该跳过的跳过,然后像处理右边的散块一样扫一遍,只是将$x\le r$的条件换成$l\le x\le r$即可.

**另外,每次修改的时候都要对应修改$cbk(i,j)$和$cnm(i,j)$.**

## 复杂度分析

首先分块自带的$\sqrt n$显然在,然后虽然有并查集但是因为都只是在同一块内操作就是$\lg\sqrt n$.这样总复杂度就是$\Theta(n\sqrt n\lg\sqrt n)$,就很悬.

交上去发现有$36\%$的点~~被艹飞~~T掉了,于是调一下块长.根据Snow_Miku大佬的建议$500$到$600$,实测$525$过$91\%$,$600$可AC,此时总共有$167$个块.另外这里的块长是指数组块长,值域块长还是$\lceil\sqrt n\rceil=317$.

## Code

还有什么疑问可以看代码,~~虽然并没有注释.~~

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048577,stdin),p0==p1)?EOF:*p0++)

inline int read() {
	static char buf[1048577],*p0,*p1;
	int re=0; char ch=gc();
	while (ch<48||ch>57) ch=gc();
    while (ch>47&&ch<58) {
		re=(re<<3)+(re<<1)+(ch^48);
		ch=gc();
	}
	return re;
}

const int qa=317;
const int qb=600; 
const int qc=167;

int n,a[100505];
int pa[100505],pb[100505];
int cbk[601][318],cnm[601][100505];
int sbk[601][318],snm[601][100505];
int fat[100505],frt[601][100505];

int find_fat(int ops) {
	return ops==fat[ops]?ops:fat[ops]=find_fat(fat[ops]);
}

inline void update(int opl,int opr,int opx,int opy) {
	if (opx==opy) return;
	if (pb[opl]==pb[opr]&&frt[pb[opl]][opx]!=-1) {
		int urt=frt[pb[opl]][opx]=-1;
		for (int i=pb[opl]*qb;pb[i]==pb[opl];++i) a[i]=a[find_fat(i)];
		for (int i=pb[opl]*qb;pb[i]==pb[opl];++i) {
			if (a[i]==opx) {
				if (i>=opl&&i<=opr) {
					urt!=-1?(fat[i]=urt):(urt=fat[i]=i);
					--cbk[pb[opl]][pa[opx]]; --cnm[pb[opl]][opx];
					++cbk[pb[opl]][pa[opy]]; ++cnm[pb[opl]][opy];
				}
				else {
					if (frt[pb[opl]][opx]!=-1) fat[i]=frt[pb[opl]][opx];
					else frt[pb[opl]][opx]=fat[i]=i;
				}
			}
			else if (a[i]==opy)
				urt!=-1?(fat[i]=urt):(urt=fat[i]=i);
		}
		a[frt[pb[opl]][opy]=urt]=opy;
	}
	else {
		int urt;
		if (frt[pb[opl]][opx]==-1);
		else if (frt[pb[opl]][opy]!=-1&&frt[pb[opl]][opy]<opl) {
			urt=frt[pb[opl]][opy];
			for (int i=pb[opl]*qb;pb[i]==pb[opl];++i) a[i]=a[find_fat(i)];
			for (int i=opl;pb[i]==pb[opl];++i)
				if (a[i]==opx) {
					fat[i]=urt;
					--cbk[pb[opl]][pa[opx]]; --cnm[pb[opl]][opx];
					++cbk[pb[opl]][pa[opy]]; ++cnm[pb[opl]][opy];
				}
		}
		else {
			urt=-1;
			for (int i=pb[opl]*qb;pb[i]==pb[opl];++i) a[i]=a[find_fat(i)];
			for (int i=opl;pb[i]==pb[opl];++i) {
				if (a[i]==opx) {
					urt!=-1?(fat[i]=urt):(urt=fat[i]=i);
					--cbk[pb[opl]][pa[opx]]; --cnm[pb[opl]][opx];
					++cbk[pb[opl]][pa[opy]]; ++cnm[pb[opl]][opy];
				}
				else if (a[i]==opy)
					urt!=-1?(fat[i]=urt):(urt=fat[i]=i);
			}
			a[frt[pb[opl]][opy]=urt]=opy;
		}
		if (frt[pb[opl]][opx]>=opl) frt[pb[opl]][opx]=-1;
		if (frt[pb[opr]][opx]!=-1) {
			urt=frt[pb[opr]][opx]=-1;
			for (int i=pb[opr]*qb;pb[i]==pb[opr];++i) a[i]=a[find_fat(i)];
			for (int i=pb[opr]*qb;pb[i]==pb[opr];++i) {
				if (a[i]==opx) {
					if (i<=opr) {
						urt!=-1?(fat[i]=urt):(urt=fat[i]=i);
						--cbk[pb[opr]][pa[opx]]; --cnm[pb[opr]][opx];
						++cbk[pb[opr]][pa[opy]]; ++cnm[pb[opr]][opy];
					}
					else {
						if (frt[pb[opr]][opx]!=-1) fat[i]=frt[pb[opr]][opx];
						else frt[pb[opr]][opx]=fat[i]=i;
					}
				}
				else if (a[i]==opy)
					urt!=-1?(fat[i]=urt):(urt=fat[i]=i);
			}
			a[frt[pb[opr]][opy]=urt]=opy;
		}
		for (int i=pb[opl]+1;i<pb[opr];++i) if (frt[i][opx]!=-1) {
			if (frt[i][opx]<frt[i][opy]||frt[i][opy]==-1) {
				a[fat[frt[i][opy]]=frt[i][opx]]=opy;
				frt[i][opy]=frt[i][opx];
			}
			else fat[frt[i][opx]]=frt[i][opy];
			cbk[i][pa[opy]]+=cnm[i][opx]; cbk[i][pa[opx]]-=cnm[i][opx];
			cnm[i][opy]+=cnm[i][opx]; cnm[i][opx]=0;
			frt[i][opx]=-1;
		}
	}
	sbk[0][pa[opx]]=cbk[0][pa[opx]]; snm[0][opx]=cnm[0][opx];
	sbk[0][pa[opy]]=cbk[0][pa[opy]]; snm[0][opy]=cnm[0][opy];
	for (int i=1;i<qc;++i) {
		sbk[i][pa[opx]]=sbk[i-1][pa[opx]]+cbk[i][pa[opx]];
		snm[i][opx]=snm[i-1][opx]+cnm[i][opx];
		sbk[i][pa[opy]]=sbk[i-1][pa[opy]]+cbk[i][pa[opy]];
		snm[i][opy]=snm[i-1][opy]+cnm[i][opy];
	}
}

inline int find_kth(int opl,int opr,int opk) {
	static int fbk[318],fnm[100505]; int sum=0,ret=-1;
	if (pb[opl]==pb[opr]) {
		for (int i=opl;i<=opr;++i) {
			++fbk[pa[a[find_fat(i)]]];
			++fnm[a[find_fat(i)]];
		}
		for (int i=0;i<qa;++i)
			if ((sum+=fbk[i])>=opk) {
				for (int j=(i+1)*qa-1;;--j)
					if ((sum-=fnm[j])<opk) {
						ret=j; break;
					}
				break;
			}
		for (int i=opl;i<=opr;++i) {
			--fbk[pa[a[find_fat(i)]]];
			--fnm[a[find_fat(i)]];
		}
		return ret;
	}
	for (int i=opl;pb[i]==pb[opl];++i) {
		++fbk[pa[a[find_fat(i)]]];
		++fnm[a[find_fat(i)]];
	}
	for (int i=opr;pb[i]==pb[opr];--i) {
		++fbk[pa[a[find_fat(i)]]];
		++fnm[a[find_fat(i)]];
	}
	for (int i=0;i<qa;++i)
		if ((sum+=sbk[pb[opr]-1][i]-sbk[pb[opl]][i]+fbk[i])>=opk) {
			for (int j=(i+1)*qa-1;;--j)
				if ((sum-=snm[pb[opr]-1][j]-snm[pb[opl]][j]+fnm[j])<opk) {
					ret=j; break;
				}
			break;
		}
	for (int i=opl;pb[i]==pb[opl];++i) {
		--fbk[pa[a[find_fat(i)]]];
		--fnm[a[find_fat(i)]];
	}
	for (int i=opr;pb[i]==pb[opr];--i) {
		--fbk[pa[a[find_fat(i)]]];
		--fnm[a[find_fat(i)]];
	}
	return ret;
}

int main() {
	int m,opt,opl,opr,opx,opy,opk;
	n=read(); m=read();
	memset(frt,0xff,sizeof(frt));
	for (int i=0;i<100001;++i) {
		pa[i]=i/qa; pb[i]=i/qb;
	}
	for (int i=0;i<n;++i) {
		a[i]=read(); ++cbk[pb[i]][pa[a[i]]]; ++cnm[pb[i]][a[i]];
		fat[i]=frt[pb[i]][a[i]]!=-1?frt[pb[i]][a[i]]:(frt[pb[i]][a[i]]=i);
	}
	for (int i=0;i<qa;++i) sbk[0][i]=cbk[0][i];
	for (int i=0;i<100001;++i) snm[0][i]=cnm[0][i];
	for (int i=1;i<qc;++i) {
		for (int j=0;j<qa;++j) sbk[i][j]=sbk[i-1][j]+cbk[i][j];
		for (int j=0;j<100001;++j) snm[i][j]=snm[i-1][j]+cnm[i][j];
	}
	while (m--) {
		opt=read(); opl=read()-1; opr=read()-1;
		if (opt==1) {
			opx=read(); opy=read();
			update(opl,opr,opx,opy);
		}
		else {
			opk=read();
			printf("%d\n",find_kth(opl,opr,opk));
		}
	}
	return 0;
}
```

---

## 作者：BFqwq (赞：4)

很久以前写的，突发奇想，来补个题解。

在做这个题之前，建议先写一写[第二分块](https://www.luogu.com.cn/problem/P4117)。这边有个[双倍经验](https://www.luogu.com.cn/problem/CF896E)。**这边默认都写过第二分块。**

在第二分块中，我们用到了一种将某个块中的某个值整体修改为另一个值。在 lxl 的题解中这一操作有三种解法。这边建议直接用并查集，因为好写，但说实话，确实很慢。

修改时大致方法跟第二分块基本相同，对每个块内每个值开一个并查集，然后合并时直接合并即可。当然也可以用其他的方法，比较随意。

查询就是经典的区间 $kth$ 查询。在序列分块的同时值域分块，然后先求出每个块对应每个值域块内的数的个数前缀和。

令 $cnt_{j}/sum_{i,j}$ 表示散块/前 $i$ 个序列块内值在第 $j$ 个值域块的数的个数，$cnt1_j/sum1_{i,j}$ 表示散块/前 $i$ 个序列快内值为 $j$ 的数的个数。其中 $sum$ 预处理，$cnt$ 每次分别统计。

在每次查询时，我们先扫描散块，统计出 $cnt_{j}$ 和 $cnt1_{j}$ 的值，这部分的复杂度显然是 $\operatorname O(\sqrt n)$ 的。

接着我们从小到大扫描所有值域块。由于有了 $sum$ 和 $cnt$ 数组，所以可以 $\operatorname O(1)$ 求出这个值域块内的数的个数。于是我们可以 $\operatorname O(\sqrt n)$ 找到目标位于哪个值域块内。

然后我们从小到大扫描这个值域块内的所有数。与刚才一样，只不过把 $sum/cnt$ 换成 $sum1/cnt1$，然后就可以找到对应的数。于是就可以 $\operatorname O(\sqrt n)$ 找到要求的数。

$sum$ 和 $sum1$ 数组的预处理就不必多言了，直接暴力添加然后前缀和即可，复杂度 $\operatorname O(n\sqrt n)$。最终复杂度为 $\operatorname((n+m)\sqrt n)$，理论可以通过。

一道非常优秀的分块入门题，值得分块初学者花时间思考。lxl 评分 $8.5$，这里可以肯定这个评分虚高。不过本题卡常，屑 lxl 在我 AC 之后似乎又缩小过一次时限，所以目前感觉本题不值得一写。

---

## 作者：CmsMartin (赞：3)

## [Ynoi2018] 未来日记

### 题目描述

给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作。

+ 把区间 $[l,r]$ 内所有的 $x$ 变成 $y$ 。
+ 查询区间 $[l,r]$ 内第 $k$ 小值。

(时间限制:1.00s   内存限制:512.00MB)

### 思路

最初分块。

看到值域只有 $10^5$ 考虑在值域上也进行根号分块。

记 $Cnt1[x][i]$ 表示前 $x$ 块中数字 $i$ 的次数；

记 $Cnt2[x][i]$ 表示前 $x$ 块中数字出现在值域 $i$ 的次数。

这样我们就可以非常方便的做到查询 $k$ 小值的操作：

先利用前缀相减在加快外元素求助区间出现在每个值域的数字个数和每个数字的个数，再枚举寻找到 $k$ 小值出现的值域。最后在这个值域内查询即可。由于都是 $\sqrt n$ 个元素，所以总时间复杂度为 $O(\sqrt n)$ 。

再来看修改，套路考虑并查集。

记 $Id[x][i]$ 表示第 $x$ 块中第一个值为 $i$ 的下标；

记 $ReId[x][i]$ 表示第 $x$ 块中下表 $i$ 对应的值；

记 $Pos[i]$ 表示每个元素的 $Id$ 。

如果要还原序列，只需让 $a_i = ReId[Bel[i]][Pos[i]]$

接下来进行分类讨论：

1. 区间内无 $x$ ，跳过；

2. 区间内有 $x$ 无 $y$ , 则将 $Id[Bel][y] = Id[Bel][x],ReId[Bel][Id[Bel][x]] = y,Id[Bel][x] = 0$

3. 区间内有 $x$ 有 $y$ ，还原区间，暴力。此时值的个数减少了 $1$ ，最多有 $n + m$ 种值域，均摊为 $O((n + m) \sqrt n)$

对于更新 $Cnt$ 数组，考虑先差分在累加再前缀，时间复杂度 $O(\sqrt n)$

[国家集训队]排队 和 Dynamic Rankings 也可以使用相同的分块方法 AC。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
const int BS = 620;

namespace Fread
{
    const int SIZE = 1 << 21;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 21;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

inline int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * f;
}

inline void write(int x)
{
    if (x < 0)
    {
        putchar('-');
        x = -x;
    }
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}


int N , M , Num[MAXN + 10] , Bel[MAXN + 10];

int BLOCK , op , l , r , k , x , y;

int Id[BS][MAXN + 10] , ReId[BS][MAXN + 10];
int Left[BS] , Right[BS];
int Pos[MAXN + 10];

int Cnt1[BS][BS] , Cnt2[BS][MAXN + 10];

int Query_Cnt1[BS] , Query_Cnt2[MAXN + 10];

inline void Build(int x) {
    int ToT = 0;
    for(int i = 1; i <= BLOCK; i++) {
        Id[x][ReId[x][i]] = 0;
    }
    for(int i = Left[x]; i <= Right[x]; i++) {
        if(!Id[x][Num[i]]) {
            Id[x][Num[i]] = ++ToT;
            ReId[x][ToT] = Num[i];
        }
    }
    for(int i = Left[x]; i <= Right[x]; i++) {
        Pos[i] = Id[x][Num[i]];
    }
}

inline void UpDateValue(int x) {
    for(int i = Left[x]; i <= Right[x]; i++) {
        Num[i] = ReId[x][Pos[i]];
    }
}

inline void DutyChange(int l , int r , int x , int y) {
    for(int i = l; i <= r; i++) {
        if(Num[i] == x) {
            Cnt1[Bel[l]][Bel[x]]--;
            Cnt1[Bel[l]][Bel[y]]++;
            Cnt2[Bel[l]][x]--;
            Cnt2[Bel[l]][y]++;
            Num[i] = y;
        }
    }
}

inline void Change(int l , int r , int x , int y) {
    if(x == y || Cnt2[Bel[r]][x] - Cnt2[Bel[l] - 1][x] == 0) return;
    for(int i = Bel[N]; i >= Bel[l]; i--) {
        Cnt2[i][x] -= Cnt2[i - 1][x];
        Cnt2[i][y] -= Cnt2[i - 1][y];
        Cnt1[i][Bel[x]] -= Cnt1[i - 1][Bel[x]];
        Cnt1[i][Bel[y]] -= Cnt1[i - 1][Bel[y]];
    }

    if(Bel[l] == Bel[r]) {
        UpDateValue(Bel[l]);
        DutyChange(l , r , x , y);
        Build(Bel[l]);
        for(int i = Bel[l]; i <= Bel[N]; i++) {
            Cnt2[i][x] += Cnt2[i - 1][x];
            Cnt2[i][y] += Cnt2[i - 1][y];
            Cnt1[i][Bel[x]] += Cnt1[i - 1][Bel[x]];
            Cnt1[i][Bel[y]] += Cnt1[i - 1][Bel[y]];
        }
        return;
    }

    UpDateValue(Bel[l]);
    DutyChange(l , Right[Bel[l]] , x , y);
    Build(Bel[l]);

    UpDateValue(Bel[r]);
    DutyChange(Left[Bel[r]] , r , x , y);
    Build(Bel[r]);

    for(int i = Bel[l] + 1; i <= Bel[r] - 1; i++) {
        if(!Cnt2[i][x]) continue;
        if(Cnt2[i][y]) {
            UpDateValue(i);
            DutyChange(Left[i] , Right[i] , x , y);
            Build(i);
        }
        else {
            Cnt1[i][Bel[y]] += Cnt2[i][x];
            Cnt1[i][Bel[x]] -= Cnt2[i][x];
            Cnt2[i][y] = Cnt2[i][x];
            Cnt2[i][x] = 0;
            Id[i][y] = Id[i][x];
            ReId[i][Id[i][x]] = y;
            Id[i][x] = 0;
        }
    }

    for(int i = Bel[l]; i <= Bel[N]; i++) {
        Cnt2[i][x] += Cnt2[i - 1][x];
        Cnt2[i][y] += Cnt2[i - 1][y];
        Cnt1[i][Bel[x]] += Cnt1[i - 1][Bel[x]];
        Cnt1[i][Bel[y]] += Cnt1[i - 1][Bel[y]];
    }
}

inline int Kth(int l , int r , int k) {
	if(Bel[l] == Bel[r]) {
		UpDateValue(Bel[l]);
		for(int i = l; i <= r; i++) {
			Query_Cnt2[i] = Num[i];
		}
		nth_element(Query_Cnt2 + l , Query_Cnt2 + l + k - 1 , Query_Cnt2 + r + 1); 
		int Ans = Query_Cnt2[k + l - 1];
		
		for(int i = l; i <= r; i++) {
			Query_Cnt2[i] = 0;
		}
		
		return Ans;
	}
	
	else {
		UpDateValue(Bel[l]);
		UpDateValue(Bel[r]);
		
		for(int i = l; i <= Right[Bel[l]]; i++) {
			Query_Cnt1[Bel[Num[i]]]++;
			Query_Cnt2[Num[i]]++;
		}
		
		for(int i = Left[Bel[r]]; i <= r; i++) {
			Query_Cnt1[Bel[Num[i]]]++;
			Query_Cnt2[Num[i]]++;
		}
		
		int Sum = 0;
        
        for(int i = 1; i <= (MAXN - 1) / BLOCK + 1; i++) {
        	if(Sum + Query_Cnt1[i] + Cnt1[Bel[r] - 1][i] - Cnt1[Bel[l]][i] >= k) {
        		for(int j = (i - 1) * BLOCK + 1; j <= i * BLOCK; j++) {
        			if(Sum + Query_Cnt2[j] + Cnt2[Bel[r] - 1][j] - Cnt2[Bel[l]][j] >= k) {
        				for(int i = l; i <= Right[Bel[l]]; i++) {
							Query_Cnt1[Bel[Num[i]]] = 0;
							Query_Cnt2[Num[i]] = 0;
						}
					
						for(int i = Left[Bel[r]]; i <= r; i++) {
							Query_Cnt1[Bel[Num[i]]] = 0;
							Query_Cnt2[Num[i]] = 0;
						}
        				return j;
					}
					else Sum += Query_Cnt2[j] + Cnt2[Bel[r] - 1][j] - Cnt2[Bel[l]][j];
				}
			}
			else Sum += Query_Cnt1[i] + Cnt1[Bel[r] - 1][i] - Cnt1[Bel[l]][i];
		}
	}
}

int main() {
	N = read();
	M = read();
	
	BLOCK = sqrt(N * 1.2);
	
	for(int i = 1; i <= N; i++) {
		Num[i] = read();
	}
	
	for(int i = 1; i <= MAXN; i++) {
		Bel[i] = (i - 1) / BLOCK + 1;
	}
	
	for(int i = 1; i <= Bel[N]; i++) {
		Left[i] = Right[i - 1] + 1;
		Right[i] = i * BLOCK;
	}
	
	Right[Bel[N]] = N;
	
	for(int i = 1; i <= Bel[N]; i++)
		Build(i); 
	
	for(int i = 1; i <= Bel[N]; i++) {
		for(int j = 1; j <= Bel[MAXN - 1 - 5]; j++) {
			Cnt1[i][j] = Cnt1[i - 1][j];
		}
		for(int j = 1; j <= MAXN - 5; j++) {
			Cnt2[i][j] = Cnt2[i - 1][j];
		}
		
		for(int j = Left[i]; j <= Right[i]; j++) {
			Cnt1[i][Bel[Num[j]]]++;
			Cnt2[i][Num[j]]++;
		}
	}
	
	while(M--) {
		op = read();
		l = read();
		r = read();
		if(op == 1) {
			x = read();
			y = read();
			Change(l , r , x , y);
		}
		else {
			k = read();
			write(Kth(l , r , k));
			putchar('\n');
		}
	}
    return 0;
}
```



---

## 作者：Hagasei (赞：3)

序列分块加值域分块。跟第二分块很像。用并查集维护修改操作：同样的值在同一并查集、用 `rt[i][j]` 表示第 $i$ 块中数 $j$ 所在并查集的根。整块直接来，散块暴力重构。

对于查询操作，维护两个桶 `keg[i][j],ton[i][j]` 表示前 $i$ 块数 $j$ 的出现次数、前 $i$ 块第 $j$ 值域块的出现次数。修改时暴力维护、查询时将散块贡献加起来即可。

卡常部分见代码。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename zqw>inline void qr(zqw&x){
	bool f=0;x=0;
	char c=getchar();
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	x=f?~(x-1):x;
}
template<typename zqw>void wr(zqw x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)wr(x/10);
	putchar((x%10)^48);
}
const int MAXN=1e5+5,MAXB=250,N=1e5;
int n,m,s,l,r,x,y,cnt,bls,blss,op,delta,a[MAXN],L[MAXB],R[MAXB],idx[MAXN],keg[MAXB][MAXN],ton[MAXB][MAXB];
int tkeg[MAXN],tton[MAXB],fa[MAXN],rt[MAXB][MAXN],Ls[MAXB],Rs[MAXB];
stack<int> v;
inline int anc(int x){return fa[x]==x?x:fa[x]=anc(fa[x]);}
inline void change(int b,int x,int y){
	if(!rt[b][x]) return;
	if(!rt[b][y]) rt[b][y]=rt[b][x],a[rt[b][x]]=y,rt[b][x]=0;
	else fa[rt[b][x]]=rt[b][y],rt[b][x]=0;
}
inline void rebuild(int b,int x,int y,int l,int r){
//卡常：只重构x和y的并查集
//极重要，我优化了600ms
	for(int i=L[b];i<=R[b];++i){
		if((a[i]=a[anc(i)])==x||a[i]==y) v.push(i);
	}
	rt[b][x]=rt[b][y]=cnt=0;
	while(v.size()){
		const int i=v.top();
		if(l<=i&&i<=r&&a[i]==x) a[i]=y,++cnt;
		if(!rt[b][a[i]]) rt[b][a[i]]=fa[i]=i;
		else fa[i]=rt[b][a[i]];
		v.pop();
	}
	for(int i=b;i<bls;++i){
		keg[i][x]-=cnt,keg[i][y]+=cnt;
		ton[i][idx[x]]-=cnt,ton[i][idx[y]]+=cnt;
	}
}
inline int min(int x,int y){return x<y?x:y;}
int main(){
	qr(n),qr(m);
	s=450;//卡常
	for(l=1,r=s,blss=1;l<=N;l+=s,r=min(r+s,N),++blss){
		Ls[blss]=l,Rs[blss]=r;
		for(int i=l;i<=r;++i) idx[i]=blss;
	}
	for(l=1,r=min(s,n),bls=1;l<=n;l+=s,r=min(r+s,n),++bls){
		L[bls]=l,R[bls]=r;
		for(int i=1;i<=N;++i) keg[bls][i]=keg[bls-1][i];
		for(int i=1;i<blss;++i) ton[bls][i]=ton[bls-1][i];
		for(int i=l;i<=r;++i){
			qr(a[i]);
			if(!rt[bls][a[i]]) rt[bls][a[i]]=fa[i]=i;
			else fa[i]=rt[bls][a[i]];
			keg[bls][a[i]]++,ton[bls][idx[a[i]]]++;
		}
	}
	while(m--){
		qr(op),qr(l),qr(r),qr(x);
		const int bl=idx[l],br=idx[r];
		if(op==1){
			qr(y);
			if(x==y)continue;//注意！
			if(bl==br) rebuild(bl,x,y,l,r);
			else{
				rebuild(bl,x,y,l,R[bl]);
				rebuild(br,x,y,L[br],r);
				delta=0;
				for(int i=bl+1;i<br;++i){
					change(i,x,y);
					delta=keg[i][x]-keg[i-1][x];//注意这个地方不要写成 delta+=keg[i][x]
					ton[i][idx[y]]+=delta,ton[i][idx[x]]-=delta;
					keg[i][y]+=delta,keg[i][x]-=delta;
				}
				for(int i=br;i<bls;++i){
					ton[i][idx[x]]-=delta,ton[i][idx[y]]+=delta;
					keg[i][x]-=delta,keg[i][y]+=delta;
				}
			}
		}
		else{
			if(bl==br){
            //卡常：提前把anc(i)存下来
				for(int i=l,p=a[anc(i)];i<=r;++i,p=a[anc(i)]) tkeg[p]++,tton[idx[p]]++;
				cnt=0;
				for(y=1;;++y){
					cnt+=tton[y];
					if(cnt>=x) break;
				}cnt-=tton[y];
				for(y=Ls[y];;++y){
					cnt+=tkeg[y];
					if(cnt>=x) break;
				}
				wr(y);
                //注意：这里不能memset
				for(int i=l,p=a[anc(i)];i<=r;++i,p=a[anc(i)]) tkeg[p]=tton[idx[p]]=0;
			}
			else{
				for(int i=l,p=a[anc(i)];i<=R[bl];++i,p=a[anc(i)]) tkeg[p]++,tton[idx[p]]++;
				for(int i=L[br],p=a[anc(i)];i<=r;++i,p=a[anc(i)]) tkeg[p]++,tton[idx[p]]++;
				cnt=0;
				for(y=1;;++y){
					cnt+=(ton[br-1][y]-ton[bl][y])+tton[y];
					if(cnt>=x) break;
				}cnt-=(ton[br-1][y]-ton[bl][y])+tton[y];
				for(y=Ls[y];;++y){
					cnt+=(keg[br-1][y]-keg[bl][y])+tkeg[y];
					if(cnt>=x) break;
				}
				wr(y);
				for(int i=l,p=a[anc(i)];i<=R[bl];++i,p=a[anc(i)]) tkeg[p]=tton[idx[p]]=0;
				for(int i=L[br],p=a[anc(i)];i<=r;++i,p=a[anc(i)]) tkeg[p]=tton[idx[p]]=0;
			}
			putchar('\n');
		}
	}
}
```

---

## 作者：ynzzr (赞：3)

• 按位置分块，按权值分块。

• 每个块记录每个数的前缀出现次数和每个(权值)块的前缀出现次数。

• 查询k小先整块查询，然后再块内查询即可。O(sqrt(n))。

• 下面考虑这个修改操作。

• 我们对每个块的每个不同元素进行编号，记录id和反id。

• 对于边上的，直接暴力重构即可。

• 对于整块的：

• 若本身没有x，则跳过。

• 若本身没有y，则把相应的反id的值改一下即可。

• 若本身有y，则暴力重构。

• 然后需要记录一下每个位置对应的id，用于O(1)修改（在重构之前每个位置的id不会变）。

• 下面证复杂度：
每个块内最多有sqrt(n)种颜色，共有n个不同的id

每次修改，最多让块两边多出1种颜色，而中间显然不会变多。

若本身没有y，则修改是O(1)的，且没有改变颜色个数。

若本身没有y，则修改是O(sqrt n) 的，切会减少1种颜色。

由于总颜色个数是n+m级别的，所以修改总复杂度O((n+m)sqrt(n))

---

## 作者：zhenjianuo2025 (赞：2)

### Problem

[题目传送门](https://www.luogu.com.cn/problem/P4119)

给定一个长度为 $n$ 的序列 $a$，$m$ 次操作。

1. 把区间 $[l,r]$ 内所有的 $x$ 变成 $y$。
1. 查询区间 $[l,r]$ 内第 $k$ 小值。

### Solve

对于查询操作，可以对 $a$ 序列分块，再对块内的元素值域分块。这样，我们就可以求出区间 $[l,r]$ 内在第 $i$ 个值域块内的元素个数 $\text{Cnk}_i$，以及 $a_j$ 为 $i$ 的 $j$ 的个数 $\text{Cnt}_i$。

先遍历所有的块，找到第 $k$ 小值所在的值域块，再对块内的元素一一扫描即可。

------------

对于修改操作，可以用并查集 $\text{fa}_i$ 把块内相同的元素串起来，记录第 $i$ 个块内值为 $j$ 的并查集的根结点 $\text{rt}_{i,j}$，以及根为 $\text{rt}_{i,j}$ 的并查集大小 $\text{sz}_{i,j}$。

在对整块 $i$ 中的 $x$ 修改为 $y$ 时，

- 若 $\text{sz}_x$ 为 $0$，直接跳过；
- 若 $\text{sz}_y$ 为 $0$，更新 $\text{rt}_{i,y}=\text{rt}_{i,x}$，$\text{sz}_{i,y}=\text{sz}_{i,x}$，$a_{\text{rt}_{i,x}}=y$，清空 $\text{rt}_{i,x}$ 和 $\text{sz}_{i,x}$；
- 若 $\text{sz}_y$ 不为 $0$，更新 $\text{fa}_{\text{rt}_{i,y}}=\text{rt}_{i,x}$，$\text{sz}_{i,y}=\text{sz}_{i,y}+\text{sz}_{i,x}$，清空 $\text{rt}_{i,x}$ 和 $\text{sz}_{i,x}$。

对旁边的散块暴力重构即可。

------------

块长取 $\sqrt{n}$ 会爆空间，实测取 $350$ 附近最优。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define cs const
#define il inline 
#define re register
#define MAXN 100005
#define LENB 350
#define SIZC 290
int n, m, a[MAXN], fa[MAXN], rt[SIZC][MAXN], sz[SIZC][MAXN];
int Len1, Len2, Tot1, Tot2, Bel1[MAXN], Bel2[MAXN], L[SIZC], R[SIZC], U[SIZC], D[SIZC], Cnk[SIZC][SIZC], Cnt[SIZC][MAXN], Tmk[SIZC], Tmp[MAXN], Cha[SIZC];
il int find(cs int &u) {
    if (fa[u] == u) return u;
    return fa[u] = find(fa[u]);
} 
il void Reduct(cs int &p) {
    a[p] = a[find(p)];
}
il void Reduct(cs int &l, cs int &r) {
    for (re int i = l; i <= r; i++) a[i] = a[find(i)];
}
il void Refact(cs int &b) {   // 重构整个块 
    for (re int i = L[b]; i <= R[b]; i++) rt[b][a[i]] = sz[b][a[i]] = 0;
    for (re int i = L[b]; i <= R[b]; i++) {
        sz[b][a[i]]++;
        if (rt[b][a[i]] == 0) fa[i] = i, rt[b][a[i]] = i;
        else fa[i] = rt[b][a[i]];
    }
}
il void Update(cs int &l, cs int &r, cs int &x, cs int &y) {
    if (x == y) return;
    if (Bel1[l] == Bel1[r]) {
        Reduct(L[Bel1[l]], R[Bel1[l]]);
        rt[Bel1[l]][x] = sz[Bel1[l]][x] = 0;
        re int cnt = 0;
        for (re int i = l; i <= r; i++)
            if (a[i] == x) {
                cnt++;
                a[i] = y; 
            }
        Refact(Bel1[l]);
        for (re int i = 1; i <= Bel1[l]; i++) Cnt[i][x] -= cnt, Cnt[i][y] += cnt, Cnk[i][Bel2[x]] -= cnt, Cnk[i][Bel2[y]] += cnt;
        return;
    }
    for (re int i = 1; i <= Tot1; i++) Cha[i] = 0;
    for (re int i = Bel1[l] + 1; i < Bel1[r]; i++) {
        if (!rt[i][x]) continue;
        if (!rt[i][y]) rt[i][y] = rt[i][x], sz[i][y] = sz[i][x], a[rt[i][y]] = y;
        else fa[rt[i][x]] = rt[i][y], sz[i][y] += sz[i][x];
        Cha[1] -= sz[i][x]; Cha[i + 1] += sz[i][x];
        rt[i][x] = sz[i][x] = 0; 
    }
    if (rt[Bel1[l]][x]) {
	    Reduct(L[Bel1[l]], R[Bel1[l]]);
	    rt[Bel1[l]][x] = sz[Bel1[l]][x] = 0;
	    re int cnt = 0;
	    for (re int i = l; i <= R[Bel1[l]]; i++) 
	        if (a[i] == x) {
	            cnt++;
	            a[i] = y; 
	        }
	    Refact(Bel1[l]);
	    Cha[1] -= cnt, Cha[Bel1[l] + 1] += cnt;
	}

    if (rt[Bel1[r]][x]) {
	    Reduct(L[Bel1[r]], R[Bel1[r]]);
	    rt[Bel1[r]][x] = sz[Bel1[r]][x] = 0;
	    re int cnt = 0;
	    for (re int i = L[Bel1[r]]; i <= r; i++) 
	        if (a[i] == x) {
	            cnt++;
	            a[i] = y; 
	        }
	    Refact(Bel1[r]);
	    Cha[1] -= cnt, Cha[Bel1[r] + 1] += cnt;
	}

    for (re int i = 1; i <= Bel1[r]; i++) {
        Cha[i] += Cha[i - 1];
        Cnt[i][x] += Cha[i], Cnk[i][Bel2[x]] += Cha[i];
        Cnt[i][y] -= Cha[i], Cnk[i][Bel2[y]] -= Cha[i];
    }
}
il int Query(cs int &l, cs int &r, int &k) {
    if (Bel1[l] == Bel1[r]) {
        Reduct(l, r);
        for (re int i = l; i <= r; i++) {
            Tmp[a[i]]++;
            Tmk[Bel2[a[i]]]++;
        }
        re int sum = 0, zum = 0, blk, ans;
        for (re int i = 1; i <= Tot2; i++) {
            sum += Tmk[i];
            if (sum >= k) {
                blk = i;
                break;
            }
            zum += Tmk[i];
        }
        k -= zum;
        for (re int i = D[blk]; i <= U[blk]; i++) {
            if (Tmp[i] >= k) {
                ans = i;
                break; 
            }
            k -= Tmp[i];
        }
        for (re int i = l; i <= r; i++) {
            Tmp[a[i]]--;
            Tmk[Bel2[a[i]]]--;
        }
        return ans;
    }
    Reduct(l, R[Bel1[l]]), Reduct(L[Bel1[r]], r);
    for (re int i = l; i <= R[Bel1[l]]; i++) {
        Tmp[a[i]]++;
        Tmk[Bel2[a[i]]]++;
    }
    for (re int i = L[Bel1[r]]; i <= r; i++) {
        Tmp[a[i]]++;
        Tmk[Bel2[a[i]]]++;
    }
    re int sum = 0, zum = 0, blk, ans;
    for (re int i = 1; i <= Tot2; i++) {
        cs int real = Tmk[i] + Cnk[Bel1[l] + 1][i] - Cnk[Bel1[r]][i];
        sum += real;
        if (sum >= k) {
            blk = i;
            break;
        }
        zum += real;
    }
    k -= zum;
    for (re int i = D[blk]; i <= U[blk]; i++) {
        cs int real = Tmp[i] + Cnt[Bel1[l] + 1][i] - Cnt[Bel1[r]][i];
        if (real >= k) {
            ans = i;
            break;
        }
        k -= real;
    }
    for (re int i = l; i <= R[Bel1[l]]; i++) {
        Tmp[a[i]]--;
        Tmk[Bel2[a[i]]]--;
    }
    for (re int i = L[Bel1[r]]; i <= r; i++) {
        Tmp[a[i]]--;
        Tmk[Bel2[a[i]]]--;
    }
    return ans;
}
il char gt() {
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
}
il int read() {
    char ch = gt();
    int sum = 0;
    while (!(ch >= '0' && ch <= '9')) ch = gt();
    while (ch >= '0' && ch <= '9') sum = (sum << 3) + (sum << 1) + ch - 48, ch = gt();
    return sum;
}
signed main() { 
    n = read(), m = read();
    for (re int i = 1; i <= n; i++) a[i] = read();
    Len1 = min(LENB - 2, n), Len2 = LENB - 2;
    for (re int i = 1; i <= n; i++) Bel1[i] = (i - 1) / Len1 + 1;
    for (re int i = 1; i <= 100000; i++) Bel2[i] = (i - 1) / Len2 + 1;
    Tot1 = Bel1[n], Tot2 = Bel2[100000];
    for (re int i = 1; i <= Tot1; i++) L[i] = (i - 1) * Len1 + 1, R[i] = i * Len1; R[Tot1] = n;
    for (re int i = 1; i <= Tot2; i++) D[i] = (i - 1) * Len2 + 1, U[i] = i * Len2; U[Tot2] = 100000;
    for (re int i = 1; i <= Tot1; i++)
        for (re int j = L[i]; j <= n; j++) {
            Cnt[i][a[j]]++;
            Cnk[i][Bel2[a[j]]]++;
        }
    for (re int i = 1; i <= Tot1; i++) Refact(i);
    while (m--) {
        int opt, l, r, x, y;
        opt = read();
        if (opt == 2) {
            l = read(), r = read(), x = read();
            printf("%lld\n", Query(l, r, x));
        } else {
            l = read(), r = read(), x = read(), y = read();
            Update(l, r, x, y);
        }
    }
    return 0;
} 
```

---

## 作者：orz_z (赞：2)



有一个长为 $n$ 的序列 $a$，有 $m$ 次操作：

* 把区间 $[l,r]$ 内所有的 $x$ 变成 $y$。
* 查询区间 $[l,r]$ 内第 $k$ 小值。

$1 \leq n,m,a_i \leq 10^5$，时限 $1.00\text{s}$，空限 $512\text{MB}$。

#### sol

最初分块。

难度评分：$8.5$。

下面先假定 $V$ 为值域。

先看查询区间第 $k$ 大。

可以维护每个数在区间内出现了多少次。

这个可以用一个二维的 $sum$ 数组维护：$sum[i][j]$ 表示前 $i$ 块中 $j$ 出现的次数。

这样区间内一个数 $x$ 出现的次数就是中间整块 $sum$的两个前缀和相减，再加上两边散块的出现次数，散块的出现个数可暴力。

然而这样时间复杂度为 $\mathcal O(nV)$，无法通过。

考虑优化。

考虑再加上值域分块。

首先预处理 $cnt1[i][j]$ 表示前 $i$ 块中在第 $j$ 块值域的数出现次数，$cnt2[i][j]$ 表示前 $i$ 块中 $j$ 出现次数。

预处理 $\mathcal{O}(n \sqrt{n})$。

这样查询的时候，整块用 $cnt1$ 和 $cnt2$ 处理，散块用桶维护一下即可，单次时间复杂度为 $\mathcal{O}(\sqrt{n})$。

再看修改。

散块暴力即可。

再考虑并查集，记 $id[x][i]$ 为第 $x$ 块中第一个值为 $i$ 的数的下标。

同时其逆也记下，记 $rid[x][i]$ 表示第 $x$ 块中下标 $i$ 对应的值。

再用 $pos_i$ 记录每一位的 $id$。（$i$ 是序列上位置）

如果要还原序列，只需让 $a_i=rid[bl_i][pos_i]$。

再分情况讨论。

* 块内无 $x$，跳过。
* 块内有 $x$ 无 $y$，可将 $id[bl][y]=id[bl][x]$，同时 $rid[bl][id[bl][x]]=y$，记得 $id[bl][x]=0$。
* 块内有 $x,y$， 考虑此时块内权值种类少 $1$， 而权值种类总共不超过 $n+m$， 均摊后暴力重构复杂度总和为 $\mathcal O((n+m)\sqrt{n})$， 暴力重构即可，对于两个 $cnt$ 数组的更新，可以先将其差分为每块的，最后再合并，一次 $O(\sqrt{n})$。 

总时间和空间复杂度为 $\mathcal O((n+m)\sqrt {n})$。

总结：分块套分块，加套路并查集。

$\text{5.97s / 202.38MB / 6.29KB C++98 O2}$。

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

namespace Fread
{
    const int SIZE = 1 << 21;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 21;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

inline int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

inline void write(int x)
{
    if (x < 0)
    {
        putchar('-');
        x = -x;
    }
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

const int N = 1e5 + 7, SQ = 620;

int n, m, a[N], len, bl[N], L[N], R[N], sum1[SQ], sum2[N];

int id[SQ][N], rid[SQ][N], pos[N];

int cnt1[SQ][SQ], cnt2[SQ][N];

inline void build(int x)
{
    int tot = 0;
    for (int i = 1; i <= len; ++i)
        id[x][rid[x][i]] = 0;
    for (int i = L[x]; i <= R[x]; ++i)
        if (!id[x][a[i]])
        {
            id[x][a[i]] = ++tot;
            rid[x][tot] = a[i];
        }
    for (int i = L[x]; i <= R[x]; ++i)
        pos[i] = id[x][a[i]];
}

inline void rest(int x)
{
    for (int i = L[x]; i <= R[x]; ++i)
        a[i] = rid[x][pos[i]];
}

inline void cg(int l, int r, int x, int y)
{
    for (int i = l; i <= r; ++i)
        if (a[i] == x)
        {
            --cnt1[bl[l]][bl[x]], ++cnt1[bl[l]][bl[y]];
            --cnt2[bl[l]][x], ++cnt2[bl[l]][y];
            a[i] = y;
        }
}

inline void change(int i, int x, int y)
{
    id[i][y] = id[i][x];
    rid[i][id[i][x]] = y;
    id[i][x] = 0;
}

inline void modify(int l, int r, int x, int y)
{
    if (x == y || cnt2[bl[r]][x] - cnt2[bl[l] - 1][x] == 0)
        return;
    for (int i = bl[n]; i >= bl[l]; --i)
    {
        cnt2[i][x] -= cnt2[i - 1][x];
        cnt2[i][y] -= cnt2[i - 1][y];
        cnt1[i][bl[x]] -= cnt1[i - 1][bl[x]];
        cnt1[i][bl[y]] -= cnt1[i - 1][bl[y]];
    }
    if (bl[l] == bl[r])
    {
        rest(bl[l]), cg(l, r, x, y);
        build(bl[l]);
        for (int i = bl[l]; i <= bl[n]; ++i)
        {
            cnt2[i][x] += cnt2[i - 1][x];
            cnt2[i][y] += cnt2[i - 1][y];
            cnt1[i][bl[x]] += cnt1[i - 1][bl[x]];
            cnt1[i][bl[y]] += cnt1[i - 1][bl[y]];
        }
        return;
    }
    rest(bl[l]), rest(bl[r]);
    cg(l, R[bl[l]], x, y), cg(L[bl[r]], r, x, y);
    build(bl[l]), build(bl[r]);
    for (int i = bl[l] + 1; i < bl[r]; ++i)
    {
        if (!cnt2[i][x])
            continue;
        if (cnt2[i][y])
        {
            rest(i), cg(L[i], R[i], x, y);
            build(i);
        }
        else
        {
            cnt1[i][bl[y]] += cnt2[i][x];
            cnt1[i][bl[x]] -= cnt2[i][x];
            cnt2[i][y] = cnt2[i][x];
            cnt2[i][x] = 0;
            change(i, x, y);
        }
    }
    for (int i = bl[l]; i <= bl[n]; ++i)
    {
        cnt2[i][x] += cnt2[i - 1][x];
        cnt2[i][y] += cnt2[i - 1][y];
        cnt1[i][bl[x]] += cnt1[i - 1][bl[x]];
        cnt1[i][bl[y]] += cnt1[i - 1][bl[y]];
    }
}

inline int kth(int l, int r, int k)
{
    int sum = 0;
    if (bl[l] == bl[r])
    {
        rest(bl[l]);
        for (int i = l; i <= r; ++i)
            sum2[i] = a[i];
        std::nth_element(sum2 + l, sum2 + l + k - 1, sum2 + r + 1);
        int ans = sum2[l + k - 1];
        for (int i = l; i <= r; ++i)
            sum2[i] = 0;
        return ans;
    }
    rest(bl[l]), rest(bl[r]);
    for (int i = l; i <= R[bl[l]]; ++i)
    {
        ++sum1[bl[a[i]]];
        ++sum2[a[i]];
    }
    for (int i = L[bl[r]]; i <= r; ++i)
    {
        ++sum1[bl[a[i]]];
        ++sum2[a[i]];
    }
    for (int i = 1; i <= (N - 1) / len + 1; ++i)
        if (sum + sum1[i] + cnt1[bl[r] - 1][i] - cnt1[bl[l]][i] >= k)
        {
            for (int j = (i - 1) * len + 1; j <= i * len; ++j)
                if (sum + sum2[j] + cnt2[bl[r] - 1][j] - cnt2[bl[l]][j] >= k)
                {
                    for (int i = l; i <= R[bl[l]]; ++i)
                    {
                        --sum1[bl[a[i]]];
                        --sum2[a[i]];
                    }
                    for (int i = L[bl[r]]; i <= r; ++i)
                    {
                        --sum1[bl[a[i]]];
                        --sum2[a[i]] = 0;
                    }
                    return j;
                }
                else
                    sum += sum2[j] + cnt2[bl[r] - 1][j] - cnt2[bl[l]][j];
        }
        else
            sum += sum1[i] + cnt1[bl[r] - 1][i] - cnt1[bl[l]][i];
}

int main()
{
    n = read(), m = read();
    len = sqrt(n * 8 / 5);
    for (int i = 1; i < N; ++i)
        bl[i] = (i - 1) / len + 1;
    for (int i = 1; i <= n; ++i)
        a[i] = read();
    for (int i = 1; i <= bl[n]; ++i)
        L[i] = (i - 1) * len + 1, R[i] = i * len;
    R[bl[n]] = n;
    for (int i = 1; i <= bl[n]; ++i)
        build(i);
    for (int x = 1; x <= bl[n]; ++x)
    {
        for (int i = 1; i <= bl[N - 1]; ++i)
            cnt1[x][i] = cnt1[x - 1][i];
        for (int i = 1; i < N; ++i)
            cnt2[x][i] = cnt2[x - 1][i];
        for (int i = L[x]; i <= R[x]; ++i)
            ++cnt1[x][bl[a[i]]], ++cnt2[x][a[i]];
    }
    for (int i = 1, opt, l, r, x, y; i <= m; ++i)
    {
        opt = read(), l = read(), r = read();
        if (opt == 1)
        {
            x = read(), y = read();
            modify(l, r, x, y);
        }
        else
        {
            x = read();
            write(kth(l, r, x));
            putchar('\n');
        }
    }
    return 0;
}
```

---

## 作者：RainsAFO (赞：2)

先考虑分块做区间第 $k$ 大。

令 $cnt_{i,j}$ 表示第 $i$ 块中 $j$ 的出现次数， $sum1_{i,j}$ 表示前 $i$ 块中 $j$ 的出现次数。

然后我们发现，只用这些信息会多一个 $\log$。

注意到值域是 $1 \times 10^5$ ，考虑权值分块。

再记 $sum2_{i,j}$ 表示序列分块的前 $i$ 块中，权值分块前 $j$ 块中的树的出现次数。

询问时散块维护 $s1,s2$ 两个数组，$s1_i$ 累加权值分块前 $i$ 块中的数，$s2_i$ 累加 $i$ 的出现次数。

利用 $sum2$ 以及 $s1$ 的信息得到第 $k$ 大落在哪个权值块中 ，再利用 $sum1$ 与 $s2$ 得到答案。

现在来考虑修改，不妨想象一下，$x \to y$，$y \to z$ 的结果是原先的 $x,y \to z$ 。可以注意到这是一个树形结构，自然可以用并查集维护。

具体的，给序列块 $i$ 中每个值 $x$ 发一个代表，记作 $rt_{i,x}$ ，对于一组修改 $(i$ , $x$ , $y)$ ，若 $rt_{i,y}$ 不存在，令 $rt_{i,y} \to rt_{i,x}$ ，$a_{rt_{i,x}} \to y$ ，反之令 $fa_{rt_{i,x}} \to rt_{i,y}$。

散块并不适合套用这个方法，众所周知，边角暴力，直接重构 $x$，$y$ 的并查集子树。注意在所有修改后都需更新 $cnt$ ， $sum1$ ， $sum2$。

取序列块长 $600$ ，值域块长 $320$，以下是代码：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>

inline int read() {
	register char c = getchar();
	register int x = 0, f = 1;
	while(c < '0' || c > '9') {
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

const int N = 1e5 + 5;
const int M = 170;
const int S = 320;

int n, m, bl, a[N];
int top = 0, sta[N];
int L[M], R[M], bel[N], s1[S], s2[N]; 
int cnt[M][N], sumc[M][N], sums[M][S];

int fa[N], rt[M][N];
int find(int x) { return (fa[x] == x ? x : fa[x] = find(fa[x])); }

void Build(int b) {
	for (register int i = L[b]; i <= R[b]; i++) {
		if (!rt[b][a[i]])
			rt[b][a[i]] = i;
		else
			fa[i] = rt[b][a[i]];
		cnt[b][a[i]]++;
	}
}

void ReBuild(int b, int l, int r, int x, int y) {
	register int tmp = 0;
	top = 0;
	rt[b][x] = rt[b][y] = 0;
	for (register int i = L[b]; i <= R[b]; i++) {
		a[i] = a[find(i)];
		if (a[i] == x || a[i] == y)
			sta[++top] = i;
	}
	for (register int i = l; i <= r; i++) 
		if (a[i] == x)
			a[i] = y, tmp++;
	cnt[b][x] -= tmp, cnt[b][y] += tmp;
	for (register int i = 1; i <= top; i++)
		fa[sta[i]] = sta[i];
	for (register int i = 1; i <= top; i++) {
		if (!rt[b][a[sta[i]]])
			rt[b][a[sta[i]]] = sta[i];
		else
			fa[sta[i]] = rt[b][a[sta[i]]]; 
	}
	for (register int i = b; i <= bl; i++) {
		sumc[i][x] -= tmp, sumc[i][y] += tmp;
		if (bel[x] != bel[y])
			sums[i][bel[x]] -= tmp, sums[i][bel[y]] += tmp;
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for (register int i = 1; i <= n; i++) {
//		scanf("%d", &a[i]);
		a[i] = read();
		fa[i] = i;
	}
	int Siz = 600, Sizv = 317, Mv = 1e5;
	bl = (n - 1) / Siz + 1;	
	for (register int i = 1; i <= Mv; i++)
		bel[i] = (i - 1) / Sizv + 1;
	for (register int i = 1; i <= bl; i++) {
		L[i] = (i - 1) * Siz +1;
		R[i] = std :: min(i * Siz, n);
		Build(i);
		for (register int j = 1; j <= Sizv; j++)
			sums[i][j] = sums[i - 1][j];
		for (register int j = 1; j <= Mv; j++)
			sumc[i][j] = sumc[i - 1][j] + cnt[i][j];
		for (register int j = L[i]; j <= R[i]; j++)
			sums[i][bel[a[j]]]++;		
	}
	while (m--) {
		register int opt, x, y, l, r, k;
//		scanf("%d", &opt);
		opt = read();
		if (opt == 1) {
//			scanf("%d%d%d%d", &l, &r, &x, &y);
			l = read(), r = read(), x = read(), y = read();
			if (x == y)
				continue;
			register int lb = (l - 1) / Siz + 1;
			register int rb = (r - 1) / Siz + 1;
			if (lb == rb)
				ReBuild(lb, l, r, x, y);
			else {
				ReBuild(lb, l, R[lb], x, y);
				ReBuild(rb, L[rb], r, x, y);
				register int tmp = 0, tmps = 0;
				for (register int i = lb + 1; i <= rb - 1; i++) {
					if (rt[i][x]) {
						if (!rt[i][y])
							rt[i][y] = rt[i][x], a[rt[i][x]] = y;
						else
							fa[rt[i][x]] = rt[i][y];
//						tmps += tmp = cnt[i][x];
						rt[i][x] = 0;
						tmp = cnt[i][x];
						tmps += tmp;
						cnt[i][y] += tmp, cnt[i][x] = 0; 
					}
					sumc[i][x] -= tmps, sumc[i][y] += tmps;
					if (bel[x] != bel[y])
						sums[i][bel[x]] -= tmps, sums[i][bel[y]] += tmps;
				}
				for (register int i = rb; i <= bl; i++) {
					sumc[i][x] -= tmps, sumc[i][y] += tmps;
					if (bel[x] != bel[y])
						sums[i][bel[x]] -= tmps, sums[i][bel[y]] += tmps;
				}
			}
		}
		else {
//			scanf("%d%d%d", &l , &r, &k);
			l = read(), r = read(), k = read();
			register int lb = (l - 1) / Siz + 1;
			register int rb = (r - 1) / Siz + 1;
			if (lb == rb) {
				for (register int i = l; i <= r; i++) {
					a[i] = a[find(i)];
					s1[bel[a[i]]]++;
					s2[a[i]]++;
				}
				register int vl, vr, sum = 0;
				for (register int i = 1; i <= Sizv; i++) {
					sum += s1[i];
					if (sum >= k) {
						sum -= s1[i];
						vl = (i - 1) * Sizv + 1, vr = i * Sizv;
						break;
					}
				}
				for (register int i = vl; i <= vr; i++) {
					sum += s2[i];
					if (sum >= k) {
						printf("%d\n", i);
						break;
					}
				}
				for (register int i = l; i <= r; i++)
					s2[a[i]]--, s1[bel[a[i]]]--;
			}
			else {
				for (register int i = l; i <= R[lb]; i++) {
					a[i] = a[find(i)];
					s1[bel[a[i]]]++;
					s2[a[i]]++;
				}
				for(register int i = L[rb]; i <= r; i++) {
					a[i] = a[find(i)];
					s1[bel[a[i]]]++;
					s2[a[i]]++;
				}
				register int vl, vr, sum = 0;
				for (register int i = 1; i <= Sizv; i++) {
					sum += s1[i] + sums[rb - 1][i] - sums[lb][i];
					if (sum >= k) {
						sum -= s1[i] + sums[rb - 1][i] - sums[lb][i];
						vl = (i - 1) * Sizv + 1, vr = i * Sizv;
						break;
					}
				}
				for (register int i = vl; i <= vr; i++) {
					sum += s2[i] + sumc[rb - 1][i] - sumc[lb][i];
					if (sum >= k) {
						printf("%d\n", i);
						break;
					} 
				}
				for (register int i = l; i <= R[lb]; i++) {
					s1[bel[a[i]]]--;
					s2[a[i]]--;
				}
				for (register int i = L[rb]; i <= r; i++) {
					s1[bel[a[i]]]--;
					s2[a[i]]--;
				}
			}
		}
	}
	return 0;
}
```


---

## 作者：JWRuixi (赞：1)

~~历经 $3$ 天，拍了 $70000^+$ 组数据，我终于过了！~~ 纪念一下。

- 题意

给一个长度为 $n$ 的序列 $a$，支持一下两种操作：

1. ```1 l r x y``` 将区间 $[l,r]$ 中的 $x$ 改为 $y$。
2. ```2 l r k``` 查询区间第 $k$ 小。

- 分析

介绍一下，这种算法叫“望月悲叹的最初分块”，lxl 评分 $8.5$。

首先考虑如何处理询问，有主席树等在线做法，当然也可以分块套值域树状数组（似乎分块套树状数组能做的值域分块都能做？），但这里使用值域分块。

我们希望将查询复杂度控制在 $O(\sqrt n)$ 内，那我们需要快速知道第 $k$ 小，在不在一个值域块中，那就是说，我们希望 $O(1)$ 查询区间 $[l,r]$ 中值域块 $i$ 中的个数；而且具体到一个值域块内，我们要 $O(1)$ 查询一个数在区间中出现的个数，自然考虑前缀和。

于是设 $b_{i,j}$ 表示前 $i$ 块，第 $j$ 值域块的数的个数；$c_{i,j}$ 表示前 $i$ 块，数字 $j$ 的个数，对于散块开两个桶暴力统计。

接下来，思考一下怎么修改。

对于边角块，直接暴力重构，复杂度 $O(\sqrt n)$。

对于整块，分为以下三类：

1. 不存在 $x$，这种块直接忽略。
2. 存在 $x$，不存在 $y$，将 $x$ 映射到 $y$ 即可，具体来讲，我们见每个点拆成数 $x$ 对应的值，和值为 $x$ 对应的点两类。我们令 $val_x$ 表示数 $x$ 对应的真实值，$pos_x$ 为值 $x$ 对应的点，修改时直接令 $val_{pos_x}=y$，同时保证再次修改时从 $y$ 更新到 $a_i$，将 $pos_y \leftarrow pos_x$。
3. 即存在 $x$ 又存在 $y$，由于每次合并不同数字的个数减 $1$，所以这种合并最多经行 $n$ 次，那就暴力重构就好了。

时间复杂度 $O((n + m)\sqrt n)$，空间复杂度 $O(n\sqrt n)$。

由于我的写法常数太大，只获得了 $64pts$，考虑优化：

1. 首先注意直接省略 $x=y$ 的询问，不然会全 TLE。
2. 边角块修改同样可以应用 $x$ 不存在就省略的策略。
3. 在初始化的时候，可以每次记录前面的值域，前缀和可以只从这个范围更新。
4. 查询后清空数组太慢了，用一个栈存一下要清空哪些数可以快很多。

优化后期望得分 $100pts$。

- code

```cpp
#include <bits/stdc++.h>
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
using namespace std;

namespace IO{
	char ibuf[(1 << 20) + 1], *iS, *iT;
	#if ONLINE_JUDGE
	#define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read () {
		reg char ch = gh();
		reg long long x = 0;
		reg char t = 0;
		while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
		while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
		return t ? -x : x;
	}
	inline void write(long long x) {
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		if (x > 9)
			write(x / 10);
		putchar(x % 10 + '0');
	}
}

using IO::read;
using IO::write;

const int maxn(1e5 + 50), maxk(325), sqv(316), lenv(317);
int n, T, sqn, len, a[maxn], id[maxn], ls[maxk], rs[maxk], b[maxk][maxk], c[maxk][maxn], cntx[maxk], cnty[maxk], cx[maxk], cy[maxk], tx[maxk], ty[maxn], idv[maxn], mx1, mx2;
int stk1[maxk << 1], top1, stk2[maxk << 1], top2;

struct Block {
	int pos[maxn], val[maxn], now;
	inline void build () {
		for (int i = 1; i <= mx1; i++) b[now][i] = b[now - 1][i];
		for (int i = 1; i <= mx2; i++) c[now][i] = c[now - 1][i];//继承值域的优化 
		for (int i = ls[now]; i <= rs[now]; i++) {
			id[i] = now;
			b[now][idv[a[i]]]++;
			c[now][a[i]]++;
			mx1 = max(mx1, idv[a[i]]);
			mx2 = max(mx2, a[i]);
			val[a[i]] = a[i];
			pos[a[i]] = a[i];
		}
	}//初始化 b,c 和 pos,val 
	inline void rebuild (int x, int y) {
		b[now][idv[x]] = b[now - 1][idv[x]];
		b[now][idv[y]] = b[now - 1][idv[y]];
		c[now][x] = c[now - 1][x];
		c[now][y] = c[now - 1][y];//重构的过程中同样注意到只有 x，y 的值会发生改变，保证复杂度为 O(sqrt(n)) 
		for (int i = ls[now]; i <= rs[now]; i++) {
			if (a[i] == x) c[now][x]++;
			else if (a[i] == y) c[now][y]++;
			if (idv[a[i]] == idv[x]) b[now][idv[x]]++;
			else if (idv[a[i]] == idv[y]) b[now][idv[y]]++;
			val[a[i]] = a[i];
			pos[a[i]] = a[i];
		}
	}
	inline void mdy (int x, int y) {
		val[pos[x]] = y;
		pos[y] = pos[x];
		pos[x] = 0;//将 x 映射到 y 
	}
	inline int reduct (int x) {
		return val[x];//x 的真实值 
	}
} G[maxk];

inline int qry (int k, int L, int R) {
	int pos = 1;
	while (k > (b[R][pos] - b[L - 1][pos] + tx[pos])) k -= (b[R][pos] - b[L - 1][pos] + tx[pos]), pos++;//先枚举在那个值域块 
	int i = (pos - 1) * sqv + 1;
	while (k > (c[R][i] - c[L - 1][i] + ty[i])) k -= (c[R][i] - c[L - 1][i] + ty[i]), i++;//枚举是值域块中的那个数 
	return i;
}

int main () {
	n = read(), T = read(), sqn = sqrt(n), len = (n - 1) / sqn + 1;
	for (int i = 1; i <= len; ++i) ls[i] = rs[i - 1] + 1, rs[i] = i * sqn; rs[len] = n;
	for (int i = 1; i <= 100000; ++i) idv[i] = (i - 1) / sqv + 1;
	for (int i = 1; i <= n; ++i) a[i] = read();
	for (int i = 1; i <= len; ++i) G[i].now = i, G[i].build();
	while (T--) {
		int opt = read(), l = read(), r = read();
		if (opt == 1) {
			int x = read(), y = read(), ll = id[l], rr = id[r];
			if (x == y) continue;//这里没写 0pts，调了一天…… 
			for (int i = ll + 1; i <= len; ++i) cntx[i] = c[i][x] - c[i - 1][x], cnty[i] = c[i][y] - c[i - 1][y], cx[i] = b[i][idv[x]] - b[i - 1][idv[x]], cy[i] = b[i][idv[y]] - b[i - 1][idv[y]];
			//cntx[i] 表示第 i 块中 x 的个数，cnty[i] 同理，cx[i] 表示第 i 块中 x 所在值域块的数的个数 
			if (ll == rr) {
				if (c[ll][x] == c[ll - 1][x]) continue;
				for (int i = ls[ll]; i <= rs[ll]; ++i) a[i] = G[ll].reduct(a[i]);
				for (int i = l; i <= r; ++i) if (a[i] == x) a[i] = y;
				G[ll].rebuild(x, y);
				for (int i = ll + 1; i <= len; ++i) {
					b[i][idv[x]] = b[i - 1][idv[x]] + cx[i];
					b[i][idv[y]] = b[i - 1][idv[y]] + cy[i];
					c[i][x] = c[i - 1][x] + cntx[i];
					c[i][y] = c[i - 1][y] + cnty[i];
				}
				continue;
			}
			if (c[ll][x] != c[ll - 1][x]) {//优化边角重构 
				for (int i = ls[ll]; i <= rs[ll]; ++i) a[i] = G[ll].reduct(a[i]);
				for (int i = l; id[i] == ll; ++i) if (a[i] == x) a[i] = y;
				G[ll].rebuild(x, y);
			}
			for (int i = ll + 1; i <= len; i++) {
				if (i > rr || !cntx[i]) {//忽略不存在 x 的块 
					b[i][idv[x]] = b[i - 1][idv[x]] + cx[i];
					b[i][idv[y]] = b[i - 1][idv[y]] + cy[i];
					c[i][x] = c[i - 1][x] + cntx[i];
					c[i][y] = c[i - 1][y] + cnty[i];
					continue;
				}
				if (i == rr) {
					for (int j = ls[rr]; j <= rs[rr]; ++j) a[j] = G[rr].reduct(a[j]);
					for (int j = r; id[j] == rr; --j) if (a[j] == x) a[j] = y;
					G[rr].rebuild(x, y);
					continue;
				}
				if (cnty[i]) {
					for (int j = ls[i]; j <= rs[i]; ++j) a[j] = G[i].reduct(a[j]);
					for (int j = ls[i]; j <= rs[i]; ++j) if (a[j] == x) a[j] = y;
					G[i].rebuild(x, y);
				} else {
					G[i].mdy(x, y);
					if (idv[x] != idv[y]) b[i][idv[x]] = b[i - 1][idv[x]] + cx[i] - cntx[i], b[i][idv[y]] = b[i - 1][idv[y]] + cy[i] + cntx[i];
					else b[i][idv[x]] = b[i - 1][idv[x]] + cx[i];
					c[i][x] = c[i - 1][x];
					c[i][y] = c[i - 1][y] + cntx[i];
				}
			}
		} else {
			int k = read(), ll = id[l], rr = id[r];
			if (ll == rr) {
				for (int i = l; i <= r; ++i) {
					int v = G[ll].reduct(a[i]);
					if (!tx[idv[v]]) stk1[++top1] = idv[v];
					tx[idv[v]]++;
					if (!ty[v]) stk2[++top2] = v;
					ty[v]++;
				}
				write(qry(k, 1, 0)), puts("");
				while (top1) tx[stk1[top1--]] = 0;
				while (top2) ty[stk2[top2--]] = 0; 
				continue;
			}
			for (int i = l; id[i] == ll; ++i) {
				int v = G[ll].reduct(a[i]);
				if (!tx[idv[v]]) stk1[++top1] = idv[v];
				tx[idv[v]]++;
				if (!ty[v]) stk2[++top2] = v;
				ty[v]++;
			}
			for (int i = r; id[i] == rr; --i) {
				int v = G[rr].reduct(a[i]);
				if (!tx[idv[v]]) stk1[++top1] = idv[v];
				tx[idv[v]]++;
				if (!ty[v]) stk2[++top2] = v;
				ty[v]++;
			}
			write(qry(k, ll + 1, rr - 1)), puts("");
			while (top1) tx[stk1[top1--]] = 0;
			while (top2) ty[stk2[top2--]] = 0;//用栈优化清空的过程 
		}
	}
}
```

---

## 作者：添哥 (赞：1)

# 闲话
那么按照 Ynoi 的惯例是题解之前先说一大堆废话对吧。

第六分块可能这辈子都写不出来了，不过最初分块过了，写篇题解纪念一下。

不过最初分块评分比第六分块还高我表示怀疑。

这题其实还算好调啦（想当年我第二分块调了两个月才过。

另外要感谢 [@sunset1028](https://www.luogu.com.cn/user/376149) 巨佬帮我卡常：[Link](https://www.luogu.com.cn/discuss/482145)（这题卡常相当严重哦。
# 描述
给你一个数列，支持区间替换和区间查询第 $k$ 小，$n,m,a_i\le10^5$.
# 题解
先考虑区间查询第 $k$ 小，然而像可持久化线段树或者树套树都没法维护这个修改操作。

考虑分块。那么一般分块求区间第 $k$ 小基本上用的就是像由乃打扑克那样的值域二分然后块内二分的做法对吧。不过这样的复杂度是 $O(n\sqrt{n\log n}\log n)$，由乃打扑克允许这样的复杂度通过，但是这题不行。

那么我们观察一下这题和由乃打扑克有什么区别。

$a_i\le 10^5$。

考虑值域分块。由乃打扑克那题因为值域最高可达 $O(2\times 10^9)$，你要是敢值域分块的话复杂度就是 $O(n\sqrt{2\times 10^9})$，肯定是 TLE 无疑了。不过这题 $a_i\le 10^5$ 就可以值域分块。

令 $b_{i,j}$ 为前 $i$ 个块中值在第 $j$ 个值域块的数的个数，$c_{i,j}$ 为前 $i$ 个块中值恰好等于 $j$ 的数的个数。查询时对零散块的所有值再开个桶，然后值域分块。花费 $O(\sqrt{n})$ 的代价枚举答案在哪个值域块内，再花费 $O(\sqrt{n})$ 的代价枚举答案具体是多少。注意我们这里维护的是前缀和，不然 $O(\sqrt{n})$ 枚举答案时还得把 $\sqrt{n}$ 个块的值挨个加起来，时间复杂度就又变成 $O(n)$ 了。

然后我们来考虑这个修改操作。零散块显然直接重构，整块先把 $b,c$ 数组差分然后直接修改，再做一遍前缀和还原回去，由于这个前缀和长度仅为 $\sqrt{n}$ ，所以暴力重构是正确的。但是零散块查询很麻烦，实现这玩意有两种做法。

- 并查集

利用并查集把块内所以值相同的点放在一起，修改时直接合并并查集，注意只修改并查集祖先的值，零散块查询时找祖先即可，**可以通过一些均摊分析发现这个并查集是 $O(1)$ 的**。

- 分类讨论
1. 块内无 $x$：

跳过，原因显然。

2. 块内有 $x$ 无 $y$：

把 $x$ 映射成 $y$ 即可。

3. 块内有 $x$ 有 $y$：

$O(\sqrt{n})$ 重构，因为整个块初始总共至多会出现 $O(\sqrt{n})$ 种不同的数字，修改时至多会给两个零散块增加 $1$ 个数字种数，均摊给 $\sqrt{n}$ 个块就也是 $O(\sqrt{n})$ ，出现这种情况时块内的数字种数会减少 $1$，因此重构的次数不会超过 $O(n+m)$，这部分的时间复杂度也是 $O(n\sqrt{n})$。

**修改时注意特判 $x=y$！！**

然后就做完了，时空复杂度均为 $O(n\sqrt{n})$。
# 代码

代码又臭又长（12.46KB，全谷最长解），还是在参考开头那篇帖子吧。

---

## 作者：JiaY19 (赞：1)

[可能更好的阅读体验](https://www.cnblogs.com/mfeitveer/p/16055829.html)

最初分块，个人感觉如果之前做过带插入区间 $\text{K}$ 小值和第二分块的话，应该还比较好想。

### 思路

由于要询问的是区间第 $\text{k}$ 小值，自然而然的就可以想到分块套分块，外层对序列进行分块，内层运用值域分块，空间复杂度：$O(n \sqrt n)$。

具体的，我们对于序列上的每一个块维护两个数组。

第一个是每个数对于每个块的前缀和。

第二个是对第一个数组进行的分块。

所以对于一个区间的第 $k$ 小，我们先将两边的散块暴力插入一个桶中，然后找到左右端点，依次判断每一个值域所分的块。

找到之后，再在块中扫一遍。

由于最多只有 $\sqrt n$ 个块，每个块内也只有 $\sqrt n$ 个数。

所以时间复杂度 $O(\sqrt n)$

我们现在来考虑如何实现修改：

把区间 $[l,r]$ 中所有 $x$ 变成 $y$。

如果做过第二分块的话就可以想到用并查集处理这个问题。

对于散块，我们直接重构出整个块的并查集关系。

由于改变的只有 $x$ 和 $y$ 的个数，所以虽然其他的并查集关系有可能会改变，但在值域数组中的大小是不会改变的，所以只需要更改 $x$ 和 $y$ 的大小即可。

我们暴力统计更改后出这一块内 $x$ 和 $y$ 的个数，再暴力更改后面的每一个块，由于更改每一个块只需要 $O(1)$。

所以时间复杂度为 $O(\sqrt n)$。

至于整块，我们可以对于每一个块直接更改并查集，由于最多  $\sqrt n$ 个块。

所以时间复杂度为 $O(T\sqrt n)$，其中 $T$ 为并查集所用时间。

总时间复杂度 $O(nT\sqrt n)$。

但这个代码还不足以通过此题，你只能获得 $\text{64pts}$ 或者 $\text{73pts}$。

我们发现如果是左右端点不同块的修改，对于散块需要有两倍的常数，所以我们考虑对散块进行进一步的优化。

由于在散块内并查集更改的只有权值为 $x$ 和 $y$ 的数。

所以我们只更改他们的并查集关系，不直接重构整块。

时间复杂度不变，但足以通过此题了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;
const int len =  430;
const int bas = 100000;

int n , m , top , a[N] , s[N] , h[N] , q[N] , l[N] , r[N] , ch[N] , fa[N] , pos[N] , stk[N];

struct Node
{
    int a[N] , ton[N] , siz[len + 10];
}b[len + 100];

#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

inline int gf(int x)
{
    return fa[x] == x ? x : fa[x] = gf(fa[x]);
}

inline int merge(int x , int y , int pos)
{
    if(b[pos].ton[y]) fa[b[pos].ton[x]] = b[pos].ton[y];
    else b[pos].ton[y] = b[pos].ton[x] , s[b[pos].ton[x]] = y;
    b[pos].ton[x] = 0; return b[pos].a[x] - b[pos - 1].a[x];
}

inline void update(int x , int y , int ls , int rs)
{
    int posl = pos[ls] , res = 0; top = 0;
    b[posl].ton[x] = b[posl].ton[y] = 0;
    for(int i = l[posl];i <= min(r[posl] , n);i++)
    {
        a[i] = s[gf(i)];
        if(a[i] == x || a[i] == y) stk[++top] = i;
    }
    for(int i = ls;i <= rs;i++)
        if(a[i] == x) res++ , a[i] = y;
    for(int i = 1;i <= top;i++)
    {
        int j = stk[i];
        if(!b[posl].ton[a[j]]) b[posl].ton[a[j]] = fa[j] = j , s[j] = a[j];
        else fa[j] = b[posl].ton[a[j]];
    }
    for(int i = posl;i <= pos[n];i++)
        b[i].siz[pos[x]] -= res , b[i].a[x] -= res,
        b[i].siz[pos[y]] += res , b[i].a[y] += res;
}

inline void delet(int x)  { h[x]-- , q[pos[x]]--; }
inline void insert(int x) { h[x]++ , q[pos[x]]++; }

int main()
{
    int fir = 0;
    n = read() , m = read();
    for(int i = 1;i <= bas;i++) pos[i] = (i - 1) / len + 1 , r[pos[i]] = i;
    for(int i = 1;i <= bas;i++) l[pos[i]] = (l[pos[i]] ? l[pos[i]] : i);
    for(int i = 1;i <= n;i++) a[i] = read();
    for(int i = 1;i <= pos[n];i++)
        for(int j = l[i];j <= min(r[i] , n);j++)
            b[i].a[a[j]]++ , b[i].siz[pos[a[j]]]++;
    for(int i = 1;i <= pos[n];i++)
        for(int j = l[i];j <= min(r[i] , n);j++)
            if(!b[i].ton[a[j]]) b[i].ton[a[j]] = fa[j] = j , s[j] = a[j];
            else fa[j] = b[i].ton[a[j]];
    for(int i = 1;i <= pos[n];i++)
    {
        for(int j = 1;j <= bas;j++)
            b[i].a[j] += b[i - 1].a[j];
        for(int j = 1;j <= pos[bas];j++)
            b[i].siz[j] += b[i - 1].siz[j];
    }
    for(int o = 1;o <= m;o++)
    {
        int opt = read();
        if(opt == 1)
        {
            int ls = read() , rs = read() , x = read() , y = read();
            if(x == y) continue;
            if(pos[ls] == pos[rs]) update(x , y , ls , rs);
            else
            {
                int res = 0;
                update(x , y , ls , r[pos[ls]]) , update(x , y , l[pos[rs]] , rs);
                for(int i = pos[ls] + 1;i <= pos[rs] - 1;i++)
                    ch[i] = merge(x , y , i);
                for(int i = pos[ls] + 1;i <= pos[rs] - 1;i++)
                    res += ch[i] , b[i].a[x] -= res , b[i].a[y] += res,
                    b[i].siz[pos[x]] -= res , b[i].siz[pos[y]] += res;
                for(int i = pos[rs];i <= pos[n];i++)
                    b[i].a[x] -= res , b[i].a[y] += res,
                    b[i].siz[pos[x]] -= res , b[i].siz[pos[y]] += res;
            }
        }
        if(opt == 2)
        {
            int ls = read() , rs = read() , k = read() , now = 1 , res;
            if(pos[ls] == pos[rs])
            {
                for(int i = ls;i <= rs;i++) 
                {
                    insert(s[gf(i)]);
                }
                for(int i = 1;i <= pos[bas];i++)
                    if(k <= q[i]) break;
                    else k -= q[i] , now++;
                for(int i = l[now];i <= r[now];i++)
                    if(k <= h[i]) { res = i; break; }
                    else k -= h[i];
                for(int i = ls;i <= rs;i++) delet(s[gf(i)]);
            }
            else
            {
                int bl = pos[ls] , br = pos[rs] - 1;
                for(int i = ls;i <= r[pos[ls]];i++) insert(s[gf(i)]);
                for(int i = l[pos[rs]];i <= rs;i++) insert(s[gf(i)]);
                for(int i = 1;i <= pos[bas];i++)
                    if(k <= q[i] + b[br].siz[i] - b[bl].siz[i]) break;
                    else k -= q[i] + b[br].siz[i] - b[bl].siz[i] , now++;
                for(int i = l[now];i <= r[now];i++)
                    if(k <= h[i] + b[br].a[i] - b[bl].a[i]) { res = i; break; }
                    else k -= h[i] + b[br].a[i] - b[bl].a[i];
                for(int i = ls;i <= r[pos[ls]];i++) delet(s[gf(i)]);
                for(int i = l[pos[rs]];i <= rs;i++) delet(s[gf(i)]);
            }
            printf("%d\n" , res);
        }
    }
    return 0;
}

```

---

## 作者：xfrvq (赞：1)

[P4119 [Ynoi2018] 未来日记](/problem/P4119)

设 $n$ 与值域同阶。

---

首先考虑查询，这是一个经典套路，值域分块求第 $k$ 小值。

假设没有区间问题。维护 $c_i$ 代表序列中 $i$ 的出现次数，$s_I$ 代表序列中第 $I$ 个值域块的数出现次数和，考虑如何 $O(\sqrt n)$ 求序列 $k$ 小值。

+ 先确定答案所在值域块：从小到大扫每个值域块，不断用 $k$ 减去 $s_I$。当 $k\le s_{I}$ 说明答案在值域块 $I$。
+ 再找出答案：从小到大扫值域块 $I$，不断用 $k$ 减去 $c_i$，当 $k\le c_i$ 说明答案就是 $i$。

接下来是区间问题，先套上一个序列分块，维护 $C_{i,j}$ 代表前 $i$ 个块中 $j$ 出现次数，$S_{i,J}$ 代表前 $i$ 块中值域块 $J$ 的数出现次数和。还剩下散块的一些位置，维护 $b_i,t_I$ 代表散块中数 $i$，值域块 $I$ 出现次数。就还原了上述 $c_i,s_I$。

对于询问端点同块的情况，`std::nth_element` 函数可线性求第 $k$ 小。

---

先考虑整块修改。大概思路是，假如块内有 $x$ 无 $y$，就只是改变了标号。如果有 $x$ 有 $y$，这种情况下块内的颜色数会减少 $1$，那么对于每个块只会遇到 $O(\sqrt n)$ 次这种情况，进行 $O(\sqrt n)$ 的暴力重构即可。

具体地，对每个块维护值域大小的并查集，祖先处记录这个集合的值。如果有 $x$ 无 $y$，那么更改祖先处记录的值。如果有 $x$ 有 $y$，那么重构，对于块内 $O(\sqrt n)$ 每个值，任记录一个位置，这个值别的位置都以它为祖先。在祖先处记录值，由于重构，并查集深度不大于 1。

现在有了散块修改，先通过上述并查集信息还原该块，修改后重构即可。

由于 $C,S$ 都是前 $i$ 个块的信息，改变一个块某个数出现次数，会涉及 $O(\sqrt n)$ 个信息。因此在修改前，先对 $C_{*,x},C_{*,y}$ 做一次差分，$S$ 同理，现在只需改一个信息，最后前缀和回来。

```cpp
// author: One_Zzz
// 最初分块 
#include<stdio.h>
#include<math.h>
#include<algorithm>

#ifdef ONLINE_JUDGE
static char buf[1000000],*p1=buf,*p2=buf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#endif

inline int read(){
    register int x = 0;
    register char c = getchar();
    for(;c < '0' || c > '9';c = getchar());
    for(;c >= '0' && c <= '9';c = getchar())
        x = x * 10 + (c ^ '0');
    return x;
}

#define rep(i,a,b) for(int i = (a);i <= (b);++i)
#define Rep(i,a,b) for(int i = (a);i >= (b);--i) 

const int maxn = 1e5 + 5;
const int sqr = sqrt(maxn) + 5;
const int V = 1e5;

int n,m,a[maxn],b1,b2,c1,c2;
int st1[sqr],ed1[sqr],bl1[maxn];
int st2[sqr],ed2[sqr],bl2[maxn];
int cnt1[sqr][sqr],cnt2[sqr][maxn];
int pos[sqr][maxn],num[sqr][maxn],fa[maxn];
int buc1[sqr],buc2[maxn],cur;

void build(int k){
	int anc = 0;
	rep(i,1,b1) pos[k][num[k][i]] = 0;
	rep(i,st1[k],ed1[k]){
		if(pos[k][a[i]]) continue;
		pos[k][a[i]] = ++anc;
		num[k][anc] = a[i];
	}
	rep(i,st1[k],ed1[k]) fa[i] = pos[k][a[i]];
}

void init(){
	b1 = sqrt(n) + 5,c1 = (n - 1) / b1 + 1;
	b2 = sqrt(V) + 5,c2 = (V - 1) / b2 + 1;
	rep(i,1,n){
		int sq = (i - 1) / b1 + 1;
		if(!st1[sq]) st1[sq] = i;
		ed1[sq] = i; bl1[i] = sq;
	}
	rep(i,1,V){
		int sq = (i - 1) / b2 + 1;
		if(!st2[sq]) st2[sq] = i;
		ed2[sq] = i; bl2[i] = sq;
	}
	rep(i,1,c1){
		rep(j,1,c2) cnt1[i][j] = cnt1[i - 1][j];
		rep(j,1,V)  cnt2[i][j] = cnt2[i - 1][j];
		rep(j,st1[i],ed1[i]){
			++cnt1[i][bl2[a[j]]];
			++cnt2[i][a[j]];
		}
	}
	rep(i,1,c1) build(i);
}

void cnt_set(int k,int x,int y){
	Rep(i,c2,k){
		cnt1[i][bl2[x]] -= cnt1[i - 1][bl2[x]];
		cnt2[i][x] -= cnt2[i - 1][x];
		cnt1[i][bl2[y]] -= cnt1[i - 1][bl2[y]];
		cnt2[i][y] -= cnt2[i - 1][y];
	}
}

void cnt_reset(int k,int x,int y){
	rep(i,k,c2){
		cnt1[i][bl2[x]] += cnt1[i - 1][bl2[x]]; 
		cnt2[i][x] += cnt2[i - 1][x];
		cnt1[i][bl2[y]] += cnt1[i - 1][bl2[y]]; 
		cnt2[i][y] += cnt2[i - 1][y];
	}
}

//

void blk0upd(int l,int r,int x,int y){
	rep(i,st1[bl1[l]],ed1[bl1[l]]) a[i] = num[bl1[l]][fa[i]];
	rep(i,l,r){
		if(a[i] != x) continue; a[i] = y;
		--cnt1[bl1[l]][bl2[x]]; ++cnt1[bl1[l]][bl2[y]];
		--cnt2[bl1[l]][x]; ++cnt2[bl1[l]][y];
	}
	build(bl1[l]);
} 

void update(int l,int r,int x,int y){
	if(x == y) return;
	if(!(cnt2[bl1[r]][x] - cnt2[bl1[l] - 1][x])) return;
	cnt_set(bl1[l],x,y);
	if(bl1[l] == bl1[r]){
		blk0upd(l,r,x,y);
		cnt_reset(bl1[l],x,y);
		return;
	}
	blk0upd(l,ed1[bl1[l]],x,y);
	blk0upd(st1[bl1[r]],r,x,y);
	rep(i,bl1[l] + 1,bl1[r] - 1){
		if(!cnt2[i][x]) continue;
		if(!cnt2[i][y]){
			cnt1[i][bl2[y]] += cnt2[i][x];
			cnt1[i][bl2[x]] -= cnt2[i][x];
			cnt2[i][y] = cnt2[i][x];
			cnt2[i][x] = 0;
			pos[i][y] = pos[i][x];
			num[i][pos[i][y]] = y;
			pos[i][x] = 0;
		} else blk0upd(st1[i],ed1[i],x,y);
	}
	cnt_reset(bl1[l],x,y);
}

int query(int l,int r,int k){
	if(bl1[l] == bl1[r]){
		rep(i,st1[bl1[l]],ed1[bl1[l]]) a[i] = num[bl1[l]][fa[i]];
		rep(i,l,r) buc2[i] = a[i];
		std::nth_element(buc2 + l,buc2 + l + k - 1,buc2 + r + 1);
		int ret = buc2[l + k - 1];
		rep(i,l,r) buc2[i] = 0;
		return ret;
	}
	rep(i,st1[bl1[l]],ed1[bl1[l]]) a[i] = num[bl1[l]][fa[i]];
	rep(i,st1[bl1[r]],ed1[bl1[r]]) a[i] = num[bl1[r]][fa[i]];
	rep(i,l,ed1[bl1[l]]) ++buc1[bl2[a[i]]],++buc2[a[i]];
	rep(i,st1[bl1[r]],r) ++buc1[bl2[a[i]]],++buc2[a[i]];
	rep(i,1,c2){
		cur = buc1[i] + cnt1[bl1[r] - 1][i] - cnt1[bl1[l]][i];
		if(k > cur){ k -= cur; continue; }
		rep(j,st2[i],ed2[i]){
			cur = buc2[j] + cnt2[bl1[r] - 1][j] - cnt2[bl1[l]][j];
			if(k > cur){ k -= cur; continue; }
			rep(i,l,ed1[bl1[l]]) buc1[bl2[a[i]]] = buc2[a[i]] = 0;
			rep(i,st1[bl1[r]],r) buc1[bl2[a[i]]] = buc2[a[i]] = 0;
			return j;
		}
	}
	return -1;
}

int main(){
	n = read(),m = read();
	rep(i,1,n) a[i] = read();
	init();
	while(m--){
		int op = read(),l = read(),r = read(),x = read();
		if(op == 1) update(l,r,x,read());
		else printf("%d\n",query(l,r,x));
	}
	return 0;
}
```

---

## 作者：myEnd (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P4119)

据 lxl 所述，这种算法貌似应该叫「望月悲叹的最初分块」。但我们一般称之为「最初分块」。

处理区间 $kth$ 问题，首先想到的基本就是值域分块。这道题我们对序列和值域都分块，设 $a_1[i][j]$ 表示前 $j$ 块中权值在 $i$ 块内的数的个数，$a_2[i][j]$ 表示前 $j$ 块中数 $i$ 的出现次数。

对于一次寻问 $[l_i, r_i]$：先将散块加入临时桶中，然后先 get 到答案位于哪块，确定位于哪块后再暴力枚举即可在 $O(\sqrt n)$ 的复杂度内求得区间 $kth$。

对于一次修改，从左端点的块一直修改到最后面的块，并记得更新 $a_1$、$a_2$ 两数组即可。接下来细讨：
- 对于零碎的两边两块，直接暴力重构。
- 对于中间的每个完整的块，如果某一块不含 $x$，可以不理会这块；否则，如果不含 $y$，那么把 $x$ 当成 $y$，即将 $x$ 映射为 $y$ 即可；还剩又有 $x$ 又有 $y$ 的情况，意味着此时 $y$ 的数量将增加，$x$ 的数量将减少，而这种情况需要处理的过多，不妨也直接重构该块。且由于我们有 $a_2$ 数组，可以在 $O(1)$ 时间内知道该块内是否含有 $x$、$y$。接下来分析重构的复杂度：

一开始长度为 $n$ 将会有 $O(n)$ 的复杂度用来合并，而每次修改都会对至少两边的散块进行重构，有 $O(m)$ 的复杂度，故合并即重构的次数不会超过 $O(n+m)$，这个复杂度是可以接受的。

而现在我们要在线解决这个问题，所以其实可以借鉴一下第二分块的想法，用第二分块的并查集维护“将所有 $x$ 修改为 $y$”的操作可以接受。

接下来你就可以实现代码了，这道题不怎么需要卡常，还是蛮清新的，注意以下细节：
- $a_2$ 其实是一个 $n\sqrt n$ 的数组，第一维可以开 $\sqrt n$，第二维开 $n$。这样比反过来有很大的常熟优化，不过具体的底层机制我并不了解。
- 并查集 merge，如果没有 $x$ 这个颜色的时候记得跳过，上面说过了。
- 更新 $a_1$、$a_2$ 的时候记得注意更新顺序。


---

## 作者：Nopain (赞：0)

「望月悲叹的最初分块」

数据结构学魔怔了。。。Ynoi 里看见 kth 先想值域分块，设块长为    $len$ 。

所以我们需要维护两个数组：$sum[i][j]$ 表示前 $i$ 块权值在前  $j$ 块内的个数， $num[i][j]$ 表示前$i$块权值等于$j$的个数。这样求kth可以 $O(n/len)$ 找在哪块， $O(len)$ 暴力跑，查询复杂度   $O(m*n/len+m*len)$ ，初始化复杂度 $O(n^2/len)$ ，目测 $len$ 取  $\sqrt{n}$ 最优。

再看看这个鬼畜的修改。我们发现一个非常有趣的性质：一个块内至多有 $len$ 个不同的数。而整块修改不会让某个数凭空多出现，也就是随着时间推移，块内不同数的个数递减。算上散块修改增加的数字，所以总共本质不同的数字个数最多为 $(n+m)$ 级别。这样每次当有个数减少的时候，即块中即存在 $x$ 又存在 $y$ 的情况，整块修都可以重构，复杂度 $O((n+m)\sqrt{n})$ 。

对于块内没有$x$可以直接跳过，块内没有 $y$ 可以把 $y$ 的 hash 值改为 $x$ 的 hash 值，这两种情况都是 $O(1)$ 的。

但是修改完了我们还要正确维护 $sum,num$ 数组。这玩意卡了我快一个月。。。实际上修改只涉及 $x,y$ 两个数，其他部分维护的都是对的，所以我们可以累计前面所有块的修改，来更新这个块。这样复杂度就是对的了。还有一种方法是差分出 $k[l]$到$k[n]$ 中的 $x,y$ 出现次数，块内重构时可以直接在里面修改，全改完再累加回去即可。

实测块长取400可过，注意卡常。

代码
```
#include<bits/stdc++.h>
#define N 100005
#define bl 400
int n,m,opt,l,r,x,y,a[N],k[N],L[350],R[350],sum[350][350],num[350][N];
int hashtot,d[N],t1[N],t2[350],to[350][N],top[350][450];
inline void rebuild(int block){
	for(int i=L[block];i<=R[block];++i) a[i]=top[block][d[i]];
}
inline void build(int block){
	hashtot=0;
	for(int i=1;i<=bl;++i) to[block][top[block][i]]=0,top[block][i]=0;
	for(int i=L[block];i<=R[block];++i){
		if(!to[block][a[i]]) to[block][a[i]]=++hashtot,top[block][hashtot]=a[i]; 
		d[i]=to[block][a[i]];
	}
}
inline void maintain(int l,int r,int x,int y){
	for(int i=l;i<=r;++i){
		if(a[i]==x){
			sum[k[l]][k[x]]--,sum[k[l]][k[y]]++,num[k[l]][x]--,num[k[l]][y]++;
			a[i]=y; 
		}
	}
}
int main(){
	read(n),read(m);
	for(int i=1;i<=n;++i){
		k[i]=i/bl+1;
		if(k[i]^k[i-1]) L[k[i]]=i,R[k[i-1]]=i-1;
	}
	L[k[1]]=1,R[k[n]]=n;
	for(int i=1;i<=n;++i) read(a[i]);
	for(int i=k[1];i<=k[n];++i) build(i);
	for(int blo=k[1];blo<=k[n];++blo){
		for(int i=1;i<=100000;++i) num[blo][i]=num[blo-1][i];
		for(int i=k[1];i<=k[100000];++i) sum[blo][i]=sum[blo-1][i];
		for(int i=L[blo];i<=R[blo];++i) num[blo][a[i]]++,sum[blo][k[a[i]]]++;
	}
	while(m--){
		read(opt),read(l),read(r),read(x);
		if(opt&1){
			read(y);
			if(x==y||num[k[r]][x]-num[k[l]-1][x]==0) continue;
			for(int i=k[n];i>=k[l];--i){
				sum[i][k[x]]-=sum[i-1][k[x]],num[i][x]-=num[i-1][x];
				sum[i][k[y]]-=sum[i-1][k[y]],num[i][y]-=num[i-1][y];
			}
			if(k[l]==k[r]){
				rebuild(k[l]);
				maintain(l,r,x,y);
				build(k[l]);
				for(int i=k[l];i<=k[n];++i){
					sum[i][k[x]]+=sum[i-1][k[x]],num[i][x]+=num[i-1][x];
					sum[i][k[y]]+=sum[i-1][k[y]],num[i][y]+=num[i-1][y];
				}
				continue;
			}
			rebuild(k[l]),rebuild(k[r]);
			maintain(l,R[k[l]],x,y),maintain(L[k[r]],r,x,y);
			build(k[l]),build(k[r]);
			for(int blo=k[l]+1;blo<k[r];++blo){
				if(!num[blo][x]) continue;
				if(!num[blo][y]){
					sum[blo][k[y]]+=num[blo][x],num[blo][y]=num[blo][x];
					sum[blo][k[x]]-=num[blo][x],num[blo][x]=0;
					to[blo][y]=to[blo][x];top[blo][to[blo][x]]=y;to[blo][x]=0;
					continue;
				}
				rebuild(blo);
				maintain(L[blo],R[blo],x,y);
				build(blo);
			}
			for(int i=k[l];i<=k[n];++i){
				sum[i][k[x]]+=sum[i-1][k[x]],num[i][x]+=num[i-1][x];
				sum[i][k[y]]+=sum[i-1][k[y]],num[i][y]+=num[i-1][y];
			}
		}else{
			if(k[l]==k[r]){
				rebuild(k[l]);
				for(int i=l;i<=r;++i) t1[i]=a[i];
				nth_element(t1+l,t1+l+x-1,t1+r+1);
				print(t1[l+x-1]);
				for(int i=l;i<=r;++i) t1[i]=0;
				continue;
			}
			rebuild(k[l]),rebuild(k[r]);
			for(int i=l;i<=R[k[l]];++i) t1[a[i]]++,t2[k[a[i]]]++;
			for(int i=r;i>=L[k[r]];--i) t1[a[i]]++,t2[k[a[i]]]++;
			int ans=0;
			for(int i=k[1];i<=k[100000];++i){
				if(t2[i]+(sum[k[r]-1][i]-sum[k[l]][i])>=x){
					for(int j=L[i];j<=R[i];++j){
						if(t1[j]+(num[k[r]-1][j]-num[k[l]][j])>=x){
							for(int i=l;i<=R[k[l]];++i) t1[a[i]]=0,t2[k[a[i]]]=0;
							for(int i=r;i>=L[k[r]];--i) t1[a[i]]=0,t2[k[a[i]]]=0;
							ans=j;break;
						}
						x-=(t1[j]+num[k[r]-1][j]-num[k[l]][j]);
					}
				}
				if(ans) break;
				x-=(t2[i]+sum[k[r]-1][i]-sum[k[l]][i]);
			}
			print(ans);
		}
	}
	return 0;
}
```
不出意外的话直接交代码会获得0分的好成绩，但是这个问题真的显而易见。

---


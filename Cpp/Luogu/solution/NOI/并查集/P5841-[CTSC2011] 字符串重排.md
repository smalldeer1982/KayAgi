# [CTSC2011] 字符串重排

## 题目描述

对于两个字符串 $A = a_1 a_2 \cdots a_n$ 和 $B = b_1 b_2 \cdots b_n$，定义其最长公共前缀长度 $\text{lcp} (A,B)$  如下：

$$\text{lcp}(A,B) = \max \{k|0 \le k \le n,k \le m,a_1 a_2 \cdots a_k = b_1 b_2 \cdots b_k \}$$

给定 $n$ 个由小写字母组成的两两不同的非空字符串 $S_1,S_2,\cdots , S_n$，对于一个 $1$ 到 $n$ 的排列 $P=(p_1,p_2,\cdots,p_n)$，定义 $P$ 的价值 $W(P)$ 如下：

$$W(P) = \sum_{i=2}^n (\text{lcp}(S_{p_{i-1}},S_{p_i}))^2$$

我们设能够产生最大价值的排列为 $P^*_G$。

此外，还有 $q$ 个附加任务。对于第 $i$ 个任务，给定两个 $1$ 到 $n$ 之间的不同的整数 $X_i$ 和 $Y_i$。对于排列 $P$，若 $P$ 在满足 $W(P) = W(P^*_G)$ 的前提条件之下，同时满足第 $X_i$ 个字符串 $S_{X_i}$ 恰好排在第 $Y_i$ 个字符串 $S_{Y_i}$ 之前， 即 $\text{pos}(S_{X_i}) + 1 = \text{pos}(S_{Y_i})$，其中 $\text{pos}(S_i)$ 表示字符串 $S_i$ 在排列中的位置，则排列 $P$ 还将获得 $2^i$ 的奖励。所有任务的奖励之和称之为总任务奖励。

我们设能够使得总任务奖励最大的排列为 $P^*_B$。

试求：

1. $W(P^*_G)$，即可能产生的最大价值；
2. $P^*_B$，在保证最大价值前提下，可以使总任务奖励最大的排列。

## 说明/提示

**评分标准**

对于一个测试点：

- 如果输出文件的第一行正确可以得到 $2$ 分；
- 如果输出文件的第二行正确可以得到 $4$ 分；
- 如果输出文件的第三行正确可以得到 $4$ 分；
- 如果输出文件的三行都正确则可以得到 $10$ 分。

对于第三问中的排列，如果存在多个解， 则输出任意一个解均可得分。

若某问无法完成，也请按照格式输出，以避免测评失败。

**数据范围**

- 对于 $10\%$ 的数据，$n \le 10$，$q=1$，每个字符串的长度不超过 $50$；
- 对于 $20\%$ 的数据，$n \le 50$，$q=1$，每个字符串的长度不超过 $50$；
- 对于 $50\%$ 的数据，$n,q \le 1000$，每个字符串的长度不超过 $1000$；
- 对于 $70\%$ 的数据，任意字符串不为其他任何一个字符串的前缀；
- 对于 $100\%$ 的数据，$n \le 4 \times 10^4$，$q \le 10^5$，每个字符串的长度不超过 $10^4$，所有字符串的长度和不超过 $2 \times 10^5$。

## 样例 #1

### 输入

```
4 6
a
b
abc
bc
1 2
1 3
3 1
4 2
2 4
2 4
```

### 输出

```
2
4 1 3 5 6
3 1 2 4
```

# 题解

## 作者：DaiRuiChen007 (赞：4)

# P5841 题解

[Problem Link](https://www.luogu.com.cn/problem/P5841)

**题目大意**

> 给定 $n$ 个由小写字母组成的两两不同的非空字符串 $S_1,S_2,\cdots , S_n$，对于一个 $1$ 到 $n$ 的排列 $P=(p_1,p_2,\cdots,p_n)$，定义 $P$ 的价值 $W(P)= \sum_{i=2}^n (\text{lcp}(S_{p_i-1},S_{p_i}))^2$，设能够产生最大价值的排列为 $P^*_G$。
>
> 此外，还有 $q$ 个附加任务。对于第 $i$ 个任务，给定两个 $1$ 到 $n$ 之间的不同的整数 $X_i$ 和 $Y_i$。对于排列 $P$，若 $P$ 在满足 $W(P) = W(P^*_G)$ 的前提条件之下，同时满足第 $X_i$ 个字符串 $S_{X_i}$ 恰好排在第 $Y_i$ 个字符串 $S_{Y_i}$ 之前， 即 $\text{pos}(S_{X_i}) + 1 = \text{pos}(S_{Y_i})$，其中 $\text{pos}(S_i)$ 表示字符串 $S_i$ 在排列中的位置，则排列 $P$ 还将获得 $2^i$ 的奖励。所有任务的奖励之和称之为总任务奖励。
>
> 我们设能够使得总任务奖励最大的排列为 $P^*_B$。
>
> 试求：
>
> 1. $W(P^*_G)$，即可能产生的最大价值；
> 2. $P^*_B$，在保证最大价值前提下，可以使总任务奖励最大的排列。
>
> 数据范围：$Q\le 10^5,L=\sum |S_i|\le 2\times 10^5$。

**思路分析**

为了防止产生前后缀关系，我们给每个 $S_i$ 后面加上一个空字符，然后建 Trie，此时 $S_i$ 的结尾都是不同的叶子，可以证明 $P^*_G$ 一定是 Trie 的某个 dfs 序。

然后看附加任务，显然倒序满足最优，对于每个任务，可以看做钦定某两个点在 dfs 序中相邻。

观察发现每条限制对每个节点 $u$ 的儿子的搜索顺序只有三种影响：钦定某个 $v$ 为第一个或最后一个被搜的，或让某一对 $v,w$ 连续顺次搜索。

显然用链表维护每个点儿子的搜索次序即可，更新时简单分讨一下，由于每个节点儿子数是 $\mathcal O(|\Sigma|)$ 的，因此可以暴力合并链表。

此时瓶颈在处理路径上的每一个点，考虑优化：注意到 Trie 树上有很多出度为 $1$ 的点，把这些点都删掉显然不影响答案。

观察简化 Trie 树的最大深度，容易发现使最大深度从 $i$ 变成 $i+1$ 至少需要额外插入一个长度为 $i+1$ 的字符串，因此新 Trie 树的最大深度是 $\mathcal O(\sqrt L)$ 的。

时间复杂度 $\mathcal O(Q\sqrt L+L\times |\Sigma|^2)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+5;
string str[MAXN];
int tot=1,edp[MAXN],tr[MAXN][27],deg[MAXN],bel[MAXN],pi[MAXN];
vector <int> G[MAXN];
int dep[MAXN],kfa[MAXN][20],fa[MAXN];
inline void init(int u,int Fa) {
	fa[u]=kfa[u][0]=Fa,dep[u]=dep[Fa]+1;
	for(int k=1;k<20;++k) kfa[u][k]=kfa[kfa[u][k-1]][k-1];
	for(int v:G[u]) init(v,u);
}
int st[MAXN],ed[MAXN]; //first and last son
int suf[MAXN],pre[MAXN],hd[MAXN],tl[MAXN],siz[MAXN]; //list<>
int lu[MAXN],lv[MAXN];
vector <int> ord;
inline void dfs(int u) {
	if(bel[u]) ord.push_back(bel[u]);
	vector <int> sons;
	for(int v:G[u]) if(hd[v]==v) sons.push_back(v);
	auto q=[&](int v) {
		if(hd[v]==st[u]) return -1;
		if(tl[v]==ed[u]) return 1;
		return 0;
	};
	sort(sons.begin(),sons.end(),[&](int x,int y) {
		return q(x)==q(y)?x<y:q(x)<q(y);
	});
	for(int v:sons) for(int i=hd[v];i;i=suf[i]) dfs(i);
}
signed main() {
	freopen("reorder.in","r",stdin);
	freopen("reorder.out","w",stdout);
	ios::sync_with_stdio(false);
	int n,m;
	cin>>n>>m;
	ll sum=0;
	for(int i=1;i<=n;++i) {
		cin>>str[i],str[i].push_back('z'+1);
		int p=1;
		for(int j=0;j<(int)str[i].length();++j) {
			int c=str[i][j]-'a';
			if(!tr[p][c]) {
				++deg[p],tr[p][c]=++tot;
				if(deg[p]>=2) sum+=j*j;
			}
			p=tr[p][c];
		}
		edp[i]=p,bel[p]=i;
	}
	cout<<sum<<"\n";
	for(int i=tot;i>1;--i) {
		if(deg[i]==1) {
			for(int c=0;c<=26;++c) if(tr[i][c]) pi[i]=pi[tr[i][c]];
		} else {
			pi[i]=i;
			for(int c=0;c<=26;++c) if(tr[i][c]) G[i].push_back(pi[tr[i][c]]);
		}
	}
	for(int c=0;c<=26;++c) if(tr[1][c]) G[1].push_back(pi[tr[1][c]]);
	init(1,0);
	vector <int> lim;
	for(int i=1;i<=m;++i) cin>>lu[i]>>lv[i];
	for(int i=1;i<=tot;++i) hd[i]=tl[i]=i,siz[i]=1,pre[i]=suf[i]=st[i]=ed[i]=0;
	for(int i=m;i>=1;--i) {
		int u=edp[lu[i]],v=edp[lv[i]],x=u,y=v;
		if(dep[x]>dep[y]) {
			for(int k=19;~k;--k) if(dep[kfa[x][k]]>=dep[y]) x=kfa[x][k];
		} else {
			for(int k=19;~k;--k) if(dep[kfa[y][k]]>=dep[x]) y=kfa[y][k];
		}
		for(int k=19;~k;--k) if(kfa[x][k]^kfa[y][k]) x=kfa[x][k],y=kfa[y][k];
		int z=fa[x];
		bool ok=true;
		for(int p=u;fa[p]!=z;p=fa[p]) {
			if(ed[fa[p]]&&ed[fa[p]]!=p) ok=false;
			if(suf[p]) ok=false;
			if(st[fa[p]]==hd[p]&&siz[p]<deg[fa[p]]) ok=false;
		}
		for(int p=v;fa[p]!=z;p=fa[p]) {
			if(st[fa[p]]&&st[fa[p]]!=p) ok=false;
			if(pre[p]) ok=false;
			if(ed[fa[p]]==tl[p]&&siz[p]<deg[fa[p]]) ok=false;
		}	
		if(suf[x]!=y) {
			if(x==ed[z]||y==st[z]) ok=false;
			if(hd[x]==hd[y]) ok=false;
			if(suf[x]||pre[y]) ok=false;;
			if(hd[x]==st[z]&&tl[y]==ed[z]&&siz[x]+siz[y]<deg[z]) ok=false;
		}
		if(ok) {
			lim.push_back(i);
			for(int p=u;fa[p]!=z;p=fa[p]) ed[fa[p]]=p;
			for(int p=v;fa[p]!=z;p=fa[p]) st[fa[p]]=p;
			if(suf[x]!=y) {
				int nowh=hd[x],nowt=tl[y],nows=siz[x]+siz[y];
				suf[x]=y,pre[y]=x;
				for(int i=nowh;i;i=suf[i]) hd[i]=nowh,tl[i]=nowt,siz[i]=nows;
			}
		}
	}
	reverse(lim.begin(),lim.end());
	cout<<lim.size()<<" ";
	for(int i:lim) cout<<i<<" "; cout<<"\n";
	dfs(1);
	for(int i:ord) cout<<i<<" "; cout<<"\n";
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

### 题目传送门

[P5841](https://www.luogu.com.cn/problem/P5841)

### 分析 

先把所有字符串建到一颗 Trie 树上。

#### 第一问

要求 $W(P)$ 尽量地大，就是要求字符串在 Trie 树上的 LCA 的深度尽量地大。

引理：在一颗有 $n$ 个节点的有根树上，设树的节点标号为一种 dfs 序，对于 $i \in [1,n]$ 满足：

$dep_{\operatorname{lca}(1,i)} \le dep_{\operatorname{lca}(2,i)} \le \dots  \le dep_{\operatorname{lca}(i-1,i)} \le dep_{\operatorname{lca}(i,i)} \ge dep_{\operatorname{lca}(i,i+1)} \ge \dots \ge dep_{\operatorname{lca}(i,n)}$

可以理解为：

**和一个节点在一个方向上 dfs 虚越接近的节点，它们的 lca 的深度越大。**

所以我们必然是按照字典树上的 dfs 序进行排列的。

我们在每一个字符串的末尾加一个特殊字符来避免前缀关系，便于处理。

所以，设虚根的深度为 $0$，第一问的答案就是 $\sum_{i=1}^{cnt} \max(0,child_{i}-1) \times dep_i^2$，其中 $cnt$ 是 Trie 树上的节点数量。

#### 第二问和第三问

由于第 $i$ 个附加任务的贡献是 $2^i$，所以一个附加任务的贡献必然大于它前面的所有附加任务的贡献和，我们必然是从后到前尝试满足这些附加任务。

我们对于 Trie 树上每一个节点的儿子们建若干个链表。

我们要求节点 $u$ 在节点 $v$ 的前面，先求出 $\operatorname{lca}(u,v)$，记为 $x$，则 $u$ 到 $u$ 深度高于 $x$ 的祖先必然是其子树中最后一个被遍历的，$v$ 到 $v$ 深度高于 $x$ 的祖先必然是其子树第一个被遍历的，而 $u$ 这棵子树的遍历顺序一定恰好在 $v$ 这棵子树的后面一位。

于是我们写了一些函数：

```cpp
inline bool check_first(int u,int x)
{
	while(f[u] != x)
	{
		if(fir[f[u]]&&fir[f[u]] != u) return 0;
		if(pre[u]) return 0;
		if(tail[u]&&tail[u] == las[f[u]]&&len[u] != child[f[u]]) return 0;
		u = f[u];
	}
	return 1;
}
inline bool check_last(int u,int x)
{
	while(f[u] != x)
	{
		if(las[f[u]]&&las[f[u]] != u) return 0;
		if(nxt[u]) return 0;
		if(head[u]&&head[u] == fir[f[u]]&&len[head[u]] != child[f[u]]) return 0;
		u = f[u];
	}
	return 1;
}
inline bool check(int u,int v,int x)
{
	while(f[u] != x) u = f[u];
	while(f[v] != x) v = f[v];
	if(nxt[u] == v&&pre[v] == u) return 1;
	if((nxt[u]&&nxt[u] != v)||(pre[v]&&pre[v] != u)) return 0;
	if(head[u] == v&&tail[v] == u) return 0;
	if(fir[x]&&las[x]&&head[u] == fir[x]&&tail[v] == las[x]&&len[head[u]] + len[v] != child[x]) return 0;
	if(u == las[x]||v == fir[x]) return 0;
	return 1;
}
```
我们要判断的有三点：

+ 满足链表的关系

+ 能否接在特定位置的前面/后面

+ 如果开头到结尾的链表接起来，其长度必须等于其子树个数

如果满足，就把 $u$ 到 $u$ 深度高于 $x$ 的祖先设置为其子树中最后一个被遍历的，$v$ 到 $v$ 深度高于 $x$ 的祖先设置为其子树第一个被遍历的，把 $u$ 和 $v$ 接起来，并标记可以满足。

```cpp
if(check_last(u,x)&&check_first(v,x)&&check(u,v,x))
{	
	while(f[u] != x)
	{
		las[f[u]] = u;
		u = f[u];
	}
	while(f[v] != x)
	{
		fir[f[v]] = v;
		v = f[v];
	}
	if(pre[v] != u||nxt[u] != v)
	{
		pre[v] = u;
		nxt[u] = v;
		head[tail[v]] = head[u];
		tail[head[u]] = tail[v];
		len[head[u]] += len[v];
		len[v] = 0;
		head[u] = tail[v] = 0;	
	}
	++ans;
	mark[i] = 1; 
}
```

这个链表的判断和操作较为复杂，写之前建议自己在草稿纸分析一下情况。

最后，再按照链表确定的 dfs 序输出答案。

此时的时间复杂度是：$O(q\sum|S|)$。

### 优化

可以发现，在考虑 dfs 序时，一些很长的链是无用的，考虑压缩。

对于仅有一个儿子的节点，可以省略它。

```cpp
int build(int u)
{
	if(!child[u]) return u;
	F(i,0,26)
		if(son[u][i]) 
		{
			int v = build(son[u][i]);
			if(child[u] == 1) return v;
			g[u].push_back(v); 
			f[v] = u;
		}
	return u;
}
rt = build(1);
```
此时，Trie 树的最大深度约为 $\sqrt{\sum{|S|}}$。

故时间复杂度为 $O(q\sqrt{\sum{|S|}})$。

就可以通过此题了！

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(register T &x)
{
	register T p = 1;
	x = 0;
	char c = getchar();
	while(c < '0'||c > '9')
	{
		if(c == '-') p = -p;
		c = getchar();
	}
	while('0' <= c&&c <= '9')
	{
		x = (x<<3)+(x<<1)+(c^48);
		c = getchar();
	}
	x *= p;
}
template<typename T>inline void write(register T x)
{
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) write(x/10);
	putchar(x%10+48);
}
#define D(i,a,b) for(register int i=a;i>=b;--i)
#define F(i,a,b) for(register int i=a;i<=b;++i)
#define ull unsigned long long
#define ll long long
#define pii pair<int,int> 
#define N 200010
bitset<N> mark;
vector<int> g[N];
ll sum = 0;
pii p[N];
int son[N][30],f[N],child[N],ed[N],id[N],dep[N];
int head[N],tail[N],nxt[N],pre[N],len[N],fir[N],las[N];
int n,m,cnt = 1,rt = 0,ans = 0;
string s;
int build(int u)
{
	if(!child[u]) return u;
	F(i,0,26)
		if(son[u][i]) 
		{
			int v = build(son[u][i]);
			if(child[u] == 1) return v;
			g[u].push_back(v); 
			f[v] = u;
		}
	return u;
}
inline int lca(int u,int v)
{
	if(dep[u] < dep[v]) swap(u,v);
	while(dep[u] > dep[v]) u = f[u];
	while(u != v) u = f[u],v = f[v];
	return u;
}
void dfs(int u)
{
	if(!child[u]) 
	{
		write(ed[u]);
		putchar(' ');
		return;
	}
	vector<int> e[3];
	for(auto v:g[u])
	{
		if(pre[v]) continue;
		int lb = 1;
		if(fir[u]&&v == fir[u]) --lb;
		if(las[u]&&tail[v] == las[u]) ++lb;
		int t = v;
		while(t)
		{
			e[lb].push_back(t);
			t = nxt[t];
		}
	}
	F(i,0,2)
		for(auto j:e[i])
			dfs(j);
}
inline bool check_first(int u,int x)
{
	while(f[u] != x)
	{
		if(fir[f[u]]&&fir[f[u]] != u) return 0;
		if(pre[u]) return 0;
		if(tail[u]&&tail[u] == las[f[u]]&&len[u] != child[f[u]]) return 0;
		u = f[u];
	}
	return 1;
}
inline bool check_last(int u,int x)
{
	while(f[u] != x)
	{
		if(las[f[u]]&&las[f[u]] != u) return 0;
		if(nxt[u]) return 0;
		if(head[u]&&head[u] == fir[f[u]]&&len[head[u]] != child[f[u]]) return 0;
		u = f[u];
	}
	return 1;
}
inline bool check(int u,int v,int x)
{
	while(f[u] != x) u = f[u];
	while(f[v] != x) v = f[v];
	if(nxt[u] == v&&pre[v] == u) return 1;
	if((nxt[u]&&nxt[u] != v)||(pre[v]&&pre[v] != u)) return 0;
	if(head[u] == v&&tail[v] == u) return 0;
	if(fir[x]&&las[x]&&head[u] == fir[x]&&tail[v] == las[x]&&len[head[u]] + len[v] != child[x]) return 0;
	if(u == las[x]||v == fir[x]) return 0;
	return 1;
}
int main()
{
//	freopen("reorder.in","r",stdin);
//	freopen("reorder.out","w",stdout);
	read(n),read(m);
	F(i,1,n)
	{
		cin >> s;
		s.push_back('a'-1);
		int u = 1;
		F(j,0,s.size()-1)
		{
			int ch = s[j]-'a'+1;
			if(!son[u][ch])
			{
				son[u][ch] = ++cnt;
				if(++child[u] >= 2) sum += 1ll * j * j;
			}
			u = son[u][ch];
		}
		ed[u] = i;
		id[i] = u;
	}
	rt = build(1);
	dep[rt] = 1;
	F(i,1,cnt)
	{
		if(f[i]) dep[i] = dep[f[i]] + 1;
		head[i] = tail[i] = i;
		len[i] = 1;
	}
	F(i,1,m) read(p[i].first),read(p[i].second);
	D(i,m,1)
	{
		int u = id[p[i].first],v = id[p[i].second],x = lca(u,v);
		if(check_last(u,x)&&check_first(v,x)&&check(u,v,x))
		{	
			while(f[u] != x)
			{
				las[f[u]] = u;
				u = f[u];
			}
			while(f[v] != x)
			{
				fir[f[v]] = v;
				v = f[v];
			}
			if(pre[v] != u||nxt[u] != v)
			{
				pre[v] = u;
				nxt[u] = v;
				head[tail[v]] = head[u];
				tail[head[u]] = tail[v];
				len[head[u]] += len[v];
				len[v] = 0;
				head[u] = tail[v] = 0;	
			}
			++ans;
			mark[i] = 1; 
		}
	}
	write(sum),putchar('\n');
	write(ans),putchar(' ');
	F(i,1,m)
		if(mark[i])
			write(i),putchar(' ');
	putchar('\n');
	dfs(rt);
	return 0;
}
```

---

## 作者：Bronya18C (赞：1)

### 第一问

考虑转化，两个字符串的 $\texttt{lcp(A,B)}$ 的长度，等于 Trie 树上 $\text{lca}$ 的深度。

为了方便，我们在所有字符串末尾加入一个特殊字符，保证每个字符串所代表的都是 Trie 树上的一个叶子节点。

考虑贪心，那么在 Trie 树同一个子树内的所有字符串对应在答案排列上肯定是连续的一段，通过调整法可以证明否则不会更优。

那么 Trie 树的任意一个 dfs 序 $Q$ （只保留关键节点）都满足 $W(Q)=W(P_G^*)$。

---

### 第二问

现在问题变成，有若干个条件形同： $v$ 的 dfs 序等于 $u$ 的 dfs 序加 $1$。

由于条件的权值为 $2^i$，我们肯定优先满足靠后的。

考虑从 $q$ 到 $1$ 依次加入每个条件，若这个条件不会与前面的条件冲突，则加入，否则删除。

考虑每个条件， $v$ 的 dfs 序等于 $u$ 的 dfs 序加 $1$。

设 $\text{lca}$ 为 $u$ 和 $v$ 的最近公共祖先，$u'$ 和 $v'$ 是 $\text{lca}$ 的儿子，且 $u$ 在 $u'$ 子树内，$v$ 在 $v'$ 子树内。

我们发现，此时，

1. $u$ 要是 $u'-u$ 路径上的节点的子树内 dfs 序最大的。

2. $v$ 要是 $v'-v$ 路径上的节点的子树内 dfs 序最小的。

3. 在 $\text{lca}$ 中，遍历完 $u'$ 子树的下一个要是立刻遍历 $v'$ 子树。

考虑分别维护这 $3$ 个条件，

条件 $1$ 和 $2$ 我们可以记 $ep_u$ 和 $fi_u$ 表示 $u$ 子树内规定的 dfs 序最大/最小节点，每次暴力枚举链上节点即可。

条件 $3$ 我们可以维护链表 $nxet_u$ 和 $last_u$ 表示 $u$ 子树完遍历的下/上一个子树。

这样还是会有一些问题，比如 $u$ 节点有 $3$ 个子树 $a,b,c$，dfs 序最小的在 $a$ 子树内，dfs 序最大的在 $b$ 子树内，同时 $a$ 遍历完了要遍历 $b$。

那么这些条件加起来，$c$ 子树内的节点就无法遍历了。

加些分类讨论特判即可。

---

### 第三问

构造排列时，由于我们已经确定了最小/最大的节点，和子树之间的顺序关系（没有则任意），直接按顺序遍历整个 Trie 树即可。

---

### 复杂度分析

这样做设，$(u,v)$ 路径长度为 $len$，那么时间复杂度是 $O(\sum_{i=1}^{n} |S_i|+qlen)$ 的，无法通过。

考虑 Trie 树路径压缩，即对于那些很长的一条单链（即没有分叉），我们可以将其压缩成一条边。

这样做了之后，我们可以证明每个节点的深度不超过 $O(\sqrt{\sum_{i=1}^{n} |S_i|})$ 。

因为若存在一个深度为 $d$ 的点，那么至少要同时存在深度为 $1$ 到 $d$ 的其他点各一个，所需深度总和是 $O(d^2)$ 的。

即最坏情况是一条这样的链（其中标黑的为一定要存在字符串表示的关键节点）：

![](https://cdn.luogu.com.cn/upload/image_hosting/xs7hc8s2.png)

总复杂度 $O(\sum_{i=1}^{n} |S_i|+q\sqrt{\sum_{i=1}^{n} |S_i|})$，可以通过本题。

---

### 代码

```cpp
#include<bits/stdc++.h>
#define lson rt<<1
#define rson rt<<1|1

using namespace std;
int n,q;
char s[100005];
struct Trie{
    int son[26];
    int id;
}t[200005];
int tnt;
int ed[40005];
vector<int>son[200005];
void Insert(int id,int len){
    int u=0;
    for(int i=1;i<=len;i++){
        int c=s[i]-'a';
        if(!t[u].son[c])t[u].son[c]=++tnt;
        u=t[u].son[c];
    }
    ed[id]=u;t[u].id=id;
}
int dep[200005],ndep[200005];
int id[200005];
int cnt;
long long ANS=0;
void dfs(int u,int last){
    int cnt=0;
    for(int i=0;i<26;i++)
        if(t[u].son[i])cnt++;
    if(u&&(t[u].id||cnt>=2)){
        son[last].push_back(u);
        // link(last,u);
        last=u;
    }
    for(int i=0;i<26;i++){
        int v=t[u].son[i];
        if(!v)continue;
        ndep[v]=ndep[u]+1;
        dfs(v,last);
    }
}
int al[200005];
int fa[200005];
// int ndep[200005];
void dfs2(int u){
    int hav=son[u].size()+(t[u].id?1:0);
    if(hav>=1)ANS+=1ll*(hav-1)*ndep[u]*ndep[u];
    al[u]=son[u].size();
    if(t[u].id)al[u]++;
    for(int i=0;i<son[u].size();i++){
        int v=son[u][i];
        dep[v]=dep[u]+1;
        dfs2(v);fa[v]=u;
    }
}
int a[100005],b[100005];
int ep[200005],fi[200005];
int nxet[400005],last[400005];
int Fa[400005],Fa2[400005],siz[400005];
int get_Fa(int u){
    return (Fa[u]!=u?(Fa[u]=get_Fa(Fa[u])):u);
}
int get_Fa2(int u){
    return (Fa2[u]!=u?(Fa2[u]=get_Fa2(Fa2[u])):u);
}
vector<int>ans;
int lans[200005],lg;
int get_lca(int u,int v){
    if(u==v)return u;
    if(dep[u]<dep[v])swap(u,v);
    return get_lca(fa[u],v);
}
void Solve(int u){
    // cout << "!!"<<u<<endl;
    if(u>tnt){
        lans[++lg]=t[u-tnt].id;
        // cout << t[u-tnt].id<<endl;
        return;
    }
    int S=fi[u],T=ep[u];
    if(t[u].id)son[u].push_back(tnt+u);
    int vv=S;
    while(vv>0){
        Solve(vv);
        vv=nxet[vv];
    }
    if(T)T=get_Fa(T);
    for(int i=0;i<son[u].size();i++){
        int v=son[u][i];
        if(v!=S&&v!=T&&last[v]==0){
            // cout<<"!"<<v << " "<<nxet[v]<<endl;
            while(v>0){
                Solve(v);
                v=nxet[v];
            }
        }
    }
    if(T&&T!=S){
        int vvv=T;
        while(vvv>0){
            Solve(vvv);
            vvv=nxet[vvv];
        }
    }
}
unordered_map<int,int>mp[100005];
int main(){
     freopen("reorder.in","r",stdin);
     freopen("reorder.out","w",stdout);
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++){
        scanf("%s",s+1);
        Insert(i,strlen(s+1));
    }
    for(int i=1;i<=2*tnt;i++)Fa[i]=i,Fa2[i]=i,siz[i]=1;
    dfs(0,0);//cout<<"!"<<endl;
    dfs2(0);
    for(int i=1;i<=q;i++)
        scanf("%d%d",&a[i],&b[i]);
    for(int i=q;i>=1;i--){
        int u=ed[a[i]],v=ed[b[i]];
        if(mp[a[i]].count(b[i]))
            if(mp[a[i]][b[i]]==1)ans.push_back(i);
        mp[a[i]][b[i]]=0;
        int lca=get_lca(u,v);
        if(lca!=u&&lca!=v){
            bool chk=false;
            int U=u,V=v;int now=u+tnt;
            while(dep[U]>dep[lca]+1){

                if(ep[U]||(last[get_Fa(now)]==-1&&siz[get_Fa(now)]<al[U]))chk=true;
                now=U;U=fa[U];
            }
             if(ep[U]||(last[get_Fa(now)]==-1&&siz[get_Fa(now)]<al[U]))chk=true;
            int now2=v+tnt;
            while(dep[V]>dep[lca]+1){
                if(fi[V]||(nxet[get_Fa2(now2)]==-1&&siz[get_Fa(now2)]<al[V]))chk=true;
                now2=V;V=fa[V];
            }
            // cout <<i<<" "<<nxet[get_Fa2(now2)] <<" "<<siz[get_Fa(now2)] <<" "<<now2 << " "<<nxet[nxet[now2]]<<endl;
            if(fi[V]||(nxet[get_Fa2(now2)]==-1&&siz[get_Fa(now2)]<al[V]))chk=true;
            now=U;now2=V;
            if(ep[U]||fi[V]||(last[get_Fa(now)]==-1&&nxet[get_Fa2(now2)]==-1&&siz[get_Fa(now)]+siz[get_Fa(now2)]<al[lca])||get_Fa(now)==get_Fa(now2))chk=true;
            if(chk)continue;
            ans.push_back(i);
            nxet[U]=V;last[V]=U;Fa[V]=get_Fa(U);
            siz[get_Fa(U)]+=siz[V];Fa2[U]=V;
            U=u,V=v;now=u+tnt;
            while(dep[U]>dep[lca]+1){
                ep[U]=now;nxet[now]=-1;
                now=U;U=fa[U];
            }
            ep[U]=now;nxet[now]=-1;
            now=v+tnt;
            while(dep[V]>dep[lca]+1){
                fi[V]=now;last[now]=-1;
                now=V;V=fa[V];
            }
            fi[V]=now;last[now]=-1;
        }
        else if(lca==u){
            bool chk=false;
            int U=u,V=v;int now=u+tnt,now2=v+tnt;
            while(dep[V]>dep[lca]+1){ 
                if(fi[V]||(nxet[get_Fa2(now2)]==-1&&siz[get_Fa(now2)]<al[V]))chk=true;
                now2=V;V=fa[V];
            }
            if(fi[V]||(nxet[get_Fa2(now2)]==-1&&siz[get_Fa(now2)]<al[V]))chk=true;
            now2=V;
            if(ep[U]||fi[V]||(last[get_Fa(now)]==-1&&nxet[get_Fa2(now2)]==-1&&siz[get_Fa(now)]+siz[get_Fa(now2)]<al[lca])||get_Fa(now)==get_Fa(now2))chk=true;
            if(chk)continue;
            ans.push_back(i);
            nxet[U+tnt]=V;last[V]=U+tnt;Fa[V]=get_Fa(U+tnt);
            siz[get_Fa(U+tnt)]+=siz[V];Fa2[U+tnt]=V;
            U=u,V=v;now=u+tnt;
            now=v+tnt;
            while(dep[V]>dep[lca]+1){
                fi[V]=now;last[now]=-1;
                now=V;V=fa[V];
            }
            // cout <<V<<endl;
            fi[V]=now;last[now]=-1;
        }
        else if(lca==v){
            bool chk=false;
            int U=u,V=v;int now=u+tnt,now2=v+tnt;
            while(dep[U]>dep[lca]+1){
                if(ep[U]||(last[get_Fa(now)]==-1&&siz[get_Fa(now)]<al[U]))chk=true;
                now=U;U=fa[U];
            }
            if(ep[U]||(last[get_Fa(now)]==-1&&siz[get_Fa(now)]<al[U]))chk=true;
            now=U;
            if(ep[U]||fi[V]||(last[get_Fa(now)]==-1&&nxet[get_Fa2(now2)]==-1&&siz[get_Fa(now)]+siz[get_Fa(now2)]<al[lca])||get_Fa(now)==get_Fa(now2))chk=true;
            if(chk)continue;
            ans.push_back(i);
            nxet[U]=V+tnt;last[V+tnt]=U;Fa[V+tnt]=get_Fa(U);
            siz[get_Fa(U)]+=siz[V+tnt];Fa2[U]=V+tnt;
            U=u,V=v;now=u+tnt;
            while(dep[U]>dep[lca]+1){
                ep[U]=now;nxet[now]=-1;
                now=U;U=fa[U];
            }
            // cout<<"!"<<U<<endl;
            ep[U]=now;nxet[now]=-1;
        }
        mp[a[i]][b[i]]=1;
    }
    Solve(0);
    printf("%lld\n",ANS);
    printf("%d ",(int)ans.size());
    sort(ans.begin(),ans.end());
    for(int i=0;i<ans.size();i++)printf("%d ",ans[i]);
    putchar('\n');
    for(int i=1;i<=n;i++)printf("%d ",lans[i]);
    return 0;
}
```

---

## 作者：mskqwq (赞：0)

把所有字符串插入到字典树上，为了方便，在每个字符串结尾添加一个特殊字符，这样字典树上只有叶子是某个字符串的结尾。对于第一问，只需以任意顺序对字典树 dfs，得到的字符串的排列顺序就能取到最大值。

对于第二问，肯定是从后往前考虑每个限制，能完成就完成。记 $l=\operatorname{lca}(x,y)$，$u$ 为 $l$ 在 $x$ 方向的儿子，$v$ 为 $l$ 在 $y$ 方向的儿子。如果要 $x$ 后紧跟着 $y$，相当于遍历到 $l$ 时，某一时刻进入 $u$ 后，下一次就要进入 $v$。并且对于 $x$ 到 $u$ 的链上每个点 $p$（不包括 $u$），需要满足遍历到 $fa_p$ 时最后一次进入的儿子是 $p$。对于 $y$ 的话就反过来，要求 $p$ 是第一个进入的。

对每个点的儿子维护一个链表，然后就是一些极其恶心的分讨。

- 每个点不能有两条出边/入边

- 如果 $u\rightarrow v$，那么 $u$ 不是 $l$ 的最后一个儿子，$v$ 不是 $l$ 的第一个儿子。

- 如果 $u$ 要作为 $fa$ 的第一个儿子，那么

  - $fa$ 要么没有钦定过的第一个儿子要么这个儿子就是 $u$

  - $fa$ 钦定的最后一个儿子不是 $u$
  - 没有连向 $u$ 的边
  - 如果 $u$ 与 $fa$ 的最后一个儿子在一条链上，则这条链必须包含 $fa$ 的所有儿子。

  $u$ 作为 $fa$ 的最后一个儿子同理。

- $u\rightarrow v$ 不能连出环

- $u\rightarrow v$ 后如果使 $l$ 的第一个以及最后一个儿子连到了一起，那么这条链需要包含 $l$ 的所有儿子。

但是暴力跳父亲复杂度不对，需要把只有一个儿子的点和它唯一的儿子缩成一个点，这样树高就是 $O(\sqrt n)$，最坏情况如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nrgyglbn.png)

```cpp
#include<set>
#include<map>
#include<queue>
#include<ctime>
#include<cstdio>
#include<vector>
#include<cassert>
#include<cstring>
#include<algorithm>
#define fi first
#define se second
#define ep emplace
#define ll long long
#define eb emplace_back
#define pii pair<int,int>
#define rg(x) x.begin(),x.end()
#define rep(i,a,b) for(int i=a;i<=(b);++i)
#define per(i,a,b) for(int i=a;i>=(b);--i)
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define FIO(FILE) freopen(FILE".in","r",stdin),freopen(FILE".out","w",stdout)
using namespace std;
bool __st;
inline int read(){
    char ch=getchar();int f=1,x=0;
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
const int N=1e6+10,mod=998244353;
int n,q,idx=1,ch[N][27],dep[N],nxt[N],tag[N],pre[N],bg[N],ed[N],fa[N],F[N],cnt[N],id[N],vis[N],X[N],Y[N];
char s[N];ll ans,lst;
void dfs(int u,int d){
    dep[u]=d;
    if(vis[u]) ans+=lst*lst;
    rep(i,0,26){
        int v=ch[u][i];
        if(v){
            fa[v]=u;
            dfs(v,d+1);
            lst=d,cnt[u]++;
        }
    }
}
int lca(int x,int y){
    for(;x^y;x=F[x])if(dep[x]<dep[y]) swap(x,y);
    return x;
}
int find(int v,int u){
    if(!v) return -1e9;
    if(v==u) return 1;
    return 1+find(nxt[v],u);
}
int ck(int x,int l,int tp){
    for(;F[x]^l;x=F[x]){
        int f=F[x];
        if(tp){
            if(bg[f]&&bg[f]!=x) return 0;
            if(ed[f]==x||pre[x]) return 0;
            if(ed[f]){
                int k=find(x,ed[f]);
                if(k>0&&k!=cnt[f]) return 0;
            }
        }
        else{
            if(ed[f]&&ed[f]!=x) return 0;
            if(bg[f]==x||nxt[x]) return 0;
            if(bg[f]){
                int k=find(bg[f],x);
                if(k>0&&k!=cnt[f]) return 0;
            }
        }
    }
    return x;
}
int get(int x,int u){
    while(fa[x]^u) x=fa[x];
    return x;
}
void dfs(int u){
    // debug("%d\n",u);
    // debug("%d  %d  %d\n",u,fat,vis[u]);
    if(vis[u]){
        printf("%d ",vis[u]);
        return;
    }
    if(bg[u]) tag[bg[u]]=1;
    rep(i,0,26){
        int v=ch[u][i];
        if(!v) continue;
        while(cnt[v]==1){
            rep(i,0,26)if(ch[v][i]){v=ch[v][i];break;}
        }
        if(pre[v]||!nxt[v]) continue;
        for(int x=v;x;x=nxt[x]){
            if(x==ed[u]){
                for(int y=v;y;y=nxt[y]) tag[y]=2;
                break;
            }
            tag[x]=1;
        }
    }
    if(ed[u]) tag[ed[u]]=1;
    if(bg[u]){
        for(int x=bg[u];x;x=nxt[x]) tag[x]=3,dfs(x);
    }
    rep(i,0,26){
        int v=ch[u][i];
        if(!v) continue;
        while(cnt[v]==1){
            rep(i,0,26)if(ch[v][i]){v=ch[v][i];break;}
        }
        if(!tag[v]) dfs(v);
    }
    rep(i,0,26){
        int v=ch[u][i];
        if(!v) continue;
        while(cnt[v]==1){
            rep(i,0,26)if(ch[v][i]){v=ch[v][i];break;}
        }
        if(pre[v]||!nxt[v]||tag[v]!=1) continue;
        for(int x=v;x;x=nxt[x]) dfs(x);
    }
    if(ed[u]){
        int x=ed[u];
        while(pre[x]) x=pre[x];
        while(x) dfs(x),x=nxt[x];
    }
}
void misaka(){
    n=read(),q=read();
    rep(i,1,n){
        scanf("%s",s+1);
        int m=strlen(s+1),p=1;
        s[++m]=123;
        rep(i,1,m){
            int &v=ch[p][s[i]-'a'];
            if(!v) v=++idx;
            p=v;
        }
        id[i]=p,vis[p]=i;
    }
    rep(i,1,q) X[i]=read(),Y[i]=read();
    dfs(1,0);
    printf("%lld\n",ans);
    rep(i,1,idx) F[i]=cnt[fa[i]]==1?F[fa[i]]:fa[i];
    // rep(i,1,idx)if(cnt[i]!=1) debug("%d %d\n",i,F[i]);
    vector<int> ans;
    per(i,q,1){
        int x=id[X[i]],y=id[Y[i]],l=lca(x,y);
        int u=ck(x,l,0),v=ck(y,l,1);
        // if(i==2524){
        //     debug("%d %d\n",x,y);
        //     debug("%d %d\n",F[x],F[y]);
        //     debug("%d %d\n",F[F[x]],F[F[y]]);
        // }
        if(!u||!v) continue;
        if((nxt[u]&&nxt[u]!=v)||(pre[v]&&pre[v]!=u)) continue;
        if(find(v,u)>0) continue;
        if(ed[l]==u||bg[l]==v) continue;
        nxt[u]=v,pre[v]=u;
        if(bg[l]&&ed[l]){
            int c=0,flag=0;
            for(int x=bg[l];x;x=nxt[x]){
                c++;
                if(x==ed[l]&&c!=cnt[l]) flag=1;
            }
            if(flag){
                // debug("%d\n",i);
                nxt[u]=pre[v]=0;
                continue;
            }
        }
        ans.eb(i);
        // debug(" %d %d\n",X[i],Y[i]);
        for(;x^u;x=F[x]) ed[F[x]]=x;
        for(;y^v;y=F[y]) bg[F[y]]=y;
    }
    printf("%llu ",ans.size());
    reverse(rg(ans));
    for(int x:ans) printf("%d ",x);
    puts("");
    // debug("%d %d\n",bg[1],ed[1]);
    // debug("%d ",nxt[2]);
    // debug("%d\n",bg[1]);
    // debug("%d %d\n",id[1],id[9]);
    // debug("%d %d\n",bg[2],ed[2]);
    // debug("%d\n\n",pre[16]);
    dfs(1);
}
bool __ed;
signed main(){
    #ifdef LOCAL_MSK
    atexit([](){
    debug("\n%.3lfs  ",(double)clock()/CLOCKS_PER_SEC);
    debug("%.3lfMB\n",abs(&__st-&__ed)/1024./1024);});
    #endif
    // freopen("data.in","r",stdin);
    int T=1;
    while(T--) misaka();
    return 0;
}
```

---

